// subject_CRT.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

PVFV g_t409000 = null; // 0000000000409000
PVFV g_t409010 = null; // 0000000000409010
PVFV g_t409018 = null; // 0000000000409018
PVFV g_t409030 = null; // 0000000000409030
word64 g_qw409060 = 0x00; // 0000000000409060
// subject_PE_header.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

word16 g_w400000 = 23117; // 0000000000400000
Eq_1709 g_t400006 = // 0000000000400006
	{
		
		{
		},
	};
word32 g_dw40003C = 0x80; // 000000000040003C
Eq_1826 g_t400090 = // 0000000000400090
	{
		
		{
		},
	};
// subject_bss.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

word32 g_dw407000 = 0x00; // 0000000000407000
word32 g_dw407004 = 0x00; // 0000000000407004
char * (* g_ptr407008)[] = null; // 0000000000407008
word64 g_qw407010 = 0x00; // 0000000000407010
word32 g_dw407018 = 0x00; // 0000000000407018
uint32 g_dw40701C = 0x00; // 000000000040701C
word32 g_dw407020 = 0x00; // 0000000000407020
int32 g_dw407024 = 0; // 0000000000407024
word32 g_dw407040 = 0x00; // 0000000000407040
word32 g_dw407050 = 0x00; // 0000000000407050
word32 g_dw407060 = 0x00; // 0000000000407060
word32 g_dw407064 = 0x00; // 0000000000407064
word32 g_dw407068 = 0x00; // 0000000000407068
word32 g_dw407070 = 0x00; // 0000000000407070
word32 g_dw407080 = 0x00; // 0000000000407080
word32 g_dw407090 = 0x00; // 0000000000407090
Eq_269 g_t4070A0 = null; // 00000000004070A0
word32 g_dw4070A8 = 0x00; // 00000000004070A8
word64 g_qw4070C0 = 0x00; // 00000000004070C0
word64 g_qw407240 = 0x00; // 0000000000407240
Eq_67 g_t407340 = null; // 0000000000407340
word32 g_dw407350 = 0x00; // 0000000000407350
struct Eq_1000 * g_ptr407358 = null; // 0000000000407358
int32 g_dw407360 = 0; // 0000000000407360
Eq_280 g_t407370 = null; // 0000000000407370
word32 g_dw407380 = 0x00; // 0000000000407380
CONTEXT g_t4073A0 = // 00000000004073A0
	{
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		
		{
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			
			{
				0x00,
				0x00,
				0x00,
				0x00,
				0x00,
				0x00,
				0x00,
				0x00,
				0x00,
				0x00,
				0x00,
				0x00,
				0x00,
				0x00,
				0x00,
				0x00,
				0x00,
				0x00,
				0x00,
				0x00,
				0x00,
				0x00,
				0x00,
				0x00,
				0x00,
				0x00,
				0x00,
				0x00,
				0x00,
				0x00,
				0x00,
				0x00,
				0x00,
				0x00,
				0x00,
				0x00,
				0x00,
				0x00,
				0x00,
				0x00,
				0x00,
				0x00,
				0x00,
				0x00,
				0x00,
				0x00,
				0x00,
				0x00,
				0x00,
				0x00,
				0x00,
				0x00,
				0x00,
				0x00,
				0x00,
				0x00,
				0x00,
				0x00,
				0x00,
				0x00,
				0x00,
				0x00,
				0x00,
				0x00,
				0x00,
				0x00,
				0x00,
				0x00,
				0x00,
				0x00,
				0x00,
				0x00,
				0x00,
				0x00,
				0x00,
				0x00,
				0x00,
				0x00,
				0x00,
				0x00,
			},
			0x00,
		},
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		
		{
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
		},
	};
word64 g_qw407420 = 0x00; // 0000000000407420
ptr64 g_ptr407438 = 0x00; // 0000000000407438
Eq_2092 g_t407498 = 0x00; // 0000000000407498
word32 g_dw407880 = 0x00; // 0000000000407880
word32 g_dw407884 = 0x00; // 0000000000407884
Eq_2092 g_t407890 = 0x00; // 0000000000407890
word32 g_dw407920 = 0x00; // 0000000000407920
struct _RTL_CRITICAL_SECTION g_t407940 = // 0000000000407940
	{
		null,
		0,
		0,
		null,
		null,
		0x00,
	};
struct Eq_2159 * g_ptr407968 = null; // 0000000000407968
byte * g_ptr407990 = null; // 0000000000407990
word32 g_dw407998 = 0x00; // 0000000000407998
ptr64 g_ptr4079A0 = 0x00; // 00000000004079A0
word64 g_qw4079A8 = 0x00; // 00000000004079A8
word64 g_qw4079B0 = 0x00; // 00000000004079B0
word32 g_dw4079B8 = 0x00; // 00000000004079B8
uint64 g_qw4079C0 = 0x00; // 00000000004079C0
// subject_data.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

<anonymous> * g_ptr403000 = fn0000000000401600; // 0000000000403000
struct Eq_1966 * g_ptr403030 = &g_t402D30; // 0000000000403030
struct _EXCEPTION_POINTERS g_t403040 = // 0000000000403040
	{
		&g_t407880,
		null,
	};
word32 g_dw403050 = 0x02; // 0000000000403050
word32 g_dw403060 = ~0x00; // 0000000000403060
ui64 g_qw403070 = 0x2B992DDFA232; // 0000000000403070
ui64 g_qw403080 = ~0x2B992DDFA232; // 0000000000403080
// subject_idata.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

word64 g_qw408050 = 0x8440; // 0000000000408050
word64 g_qw408058 = 33880; // 0000000000408058
word64 g_qw408060 = 0x8470; // 0000000000408060
word64 g_qw408068 = 0x8484; // 0000000000408068
word64 g_qw408070 = 33946; // 0000000000408070
word64 g_qw408078 = 0x84B0; // 0000000000408078
word64 g_qw408080 = 0x84C0; // 0000000000408080
word64 g_qw408088 = 34004; // 0000000000408088
word64 g_qw408090 = 34022; // 0000000000408090
word64 g_qw408098 = 34040; // 0000000000408098
word64 g_qw4080A0 = 34066; // 00000000004080A0
word64 g_qw4080A8 = 0x8522; // 00000000004080A8
word64 g_qw4080B0 = 34110; // 00000000004080B0
word64 g_qw4080B8 = 34134; // 00000000004080B8
word64 g_qw4080C0 = 0x8566; // 00000000004080C0
word64 g_qw4080C8 = 0x8580; // 00000000004080C8
word64 g_qw4080D0 = 0x8596; // 00000000004080D0
word64 g_qw4080D8 = 0x85AA; // 00000000004080D8
word64 g_qw4080E0 = 34244; // 00000000004080E0
word64 g_qw4080E8 = 0x85D8; // 00000000004080E8
word64 g_qw4080F0 = 34294; // 00000000004080F0
word64 g_qw4080F8 = 34302; // 00000000004080F8
word64 g_qw408100 = 34322; // 0000000000408100
word64 g_qw408108 = 34336; // 0000000000408108
word64 g_qw408110 = 34364; // 0000000000408110
word64 g_qw408118 = 34382; // 0000000000408118
word64 g_qw408128 = 34398; // 0000000000408128
word64 g_qw408130 = 34422; // 0000000000408130
word64 g_qw408138 = 34436; // 0000000000408138
word64 g_qw408140 = 34452; // 0000000000408140
word64 g_qw408148 = 34464; // 0000000000408148
word64 g_qw408150 = 34478; // 0000000000408150
word64 g_qw408158 = 34494; // 0000000000408158
word64 g_qw408160 = 0x86D0; // 0000000000408160
word64 g_qw408168 = 34532; // 0000000000408168
word64 g_qw408170 = 0x86EE; // 0000000000408170
word64 g_qw408178 = 34556; // 0000000000408178
word64 g_qw408180 = 0x8706; // 0000000000408180
word64 g_qw408188 = 0x8710; // 0000000000408188
word64 g_qw408190 = 34588; // 0000000000408190
word64 g_qw408198 = 0x8724; // 0000000000408198
word64 g_qw4081A0 = 34606; // 00000000004081A0
word64 g_qw4081A8 = 0x8738; // 00000000004081A8
word64 g_qw4081B0 = 0x8740; // 00000000004081B0
word64 g_qw4081B8 = 34634; // 00000000004081B8
word64 g_qw4081C0 = 34642; // 00000000004081C0
word64 g_qw4081C8 = 0x875C; // 00000000004081C8
word64 g_qw4081D0 = 34660; // 00000000004081D0
word64 g_qw4081D8 = 0x876E; // 00000000004081D8
word64 g_qw4081E0 = 0x8778; // 00000000004081E0
word64 g_qw4081E8 = 0x8782; // 00000000004081E8
word64 g_qw4081F0 = 0x878C; // 00000000004081F0
word64 g_qw4081F8 = 0x8796; // 00000000004081F8
word64 g_qw408200 = 0x87A0; // 0000000000408200
word64 g_qw408210 = 34732; // 0000000000408210
word64 g_qw408218 = 0x87C0; // 0000000000408218
word64 g_qw408220 = 0x87DC; // 0000000000408220
word64 g_qw408228 = 0x87F8; // 0000000000408228
word64 g_qw408230 = 0x8804; // 0000000000408230
word64 g_qw408238 = 0x8844; // 0000000000408238
<anonymous> * __imp__DeleteCriticalSection = &g_t8440; // 0000000000408248
<anonymous> * __imp__EnterCriticalSection = &g_t8458; // 0000000000408250
<anonymous> * __imp__GetCurrentProcess = &g_t8470; // 0000000000408258
<anonymous> * __imp__GetCurrentProcessId = &g_t8484; // 0000000000408260
<anonymous> * __imp__GetCurrentThreadId = &g_t849A; // 0000000000408268
<anonymous> * __imp__GetLastError = &g_t84B0; // 0000000000408270
<anonymous> * __imp__GetModuleHandleA = &g_t84C0; // 0000000000408278
<anonymous> * __imp__GetProcAddress = &g_t84D4; // 0000000000408280
<anonymous> * __imp__GetStartupInfoA = &g_t84E6; // 0000000000408288
<anonymous> * __imp__GetSystemTimeAsFileTime = &g_t84F8; // 0000000000408290
<anonymous> * __imp__GetTickCount = &g_t8512; // 0000000000408298
<anonymous> * __imp__InitializeCriticalSection = &g_t8522; // 00000000004082A0
<anonymous> * __imp__LeaveCriticalSection = &g_t853E; // 00000000004082A8
<anonymous> * __imp__LoadLibraryW = &g_t8556; // 00000000004082B0
<anonymous> * __imp__QueryPerformanceCounter = &g_t8566; // 00000000004082B8
<anonymous> * __imp__RtlAddFunctionTable = &g_t8580; // 00000000004082C0
<anonymous> * __imp__RtlCaptureContext = &g_t8596; // 00000000004082C8
<anonymous> * __imp__RtlLookupFunctionEntry = &g_t85AA; // 00000000004082D0
<anonymous> * __imp__RtlVirtualUnwind = &g_t85C4; // 00000000004082D8
<anonymous> * __imp__SetUnhandledExceptionFilter = &g_t85D8; // 00000000004082E0
<anonymous> * __imp__Sleep = &g_t85F6; // 00000000004082E8
<anonymous> * __imp__TerminateProcess = &g_t85FE; // 00000000004082F0
<anonymous> * __imp__TlsGetValue = &g_t8612; // 00000000004082F8
<anonymous> * __imp__UnhandledExceptionFilter = &g_t8620; // 0000000000408300
<anonymous> * __imp__VirtualProtect = &g_t863C; // 0000000000408308
<anonymous> * __imp__VirtualQuery = &g_t864E; // 0000000000408310
<anonymous> * __imp____C_specific_handler = &g_t865E; // 0000000000408320
<anonymous> * __imp____dllonexit = &g_t8676; // 0000000000408328
<anonymous> * __imp____getmainargs = &g_t8684; // 0000000000408330
<anonymous> * __imp____initenv = &g_t8694; // 0000000000408338
<anonymous> * __imp____iob_func = &g_t86A0; // 0000000000408340
<anonymous> * __imp____lconv_init = &g_t86AE; // 0000000000408348
<anonymous> * __imp____set_app_type = &g_t86BE; // 0000000000408350
<anonymous> * __imp____setusermatherr = &g_t86D0; // 0000000000408358
<anonymous> * __imp___acmdln = &g_t86E4; // 0000000000408360
<anonymous> * __imp___amsg_exit = &g_t86EE; // 0000000000408368
<anonymous> * __imp___cexit = &g_t86FC; // 0000000000408370
<anonymous> * __imp___fmode = &g_t8706; // 0000000000408378
<anonymous> * __imp___initterm = &g_t8710; // 0000000000408380
<anonymous> * __imp___lock = &g_t871C; // 0000000000408388
<anonymous> * __imp___onexit = &g_t8724; // 0000000000408390
<anonymous> * __imp___unlock = &g_t872E; // 0000000000408398
<anonymous> * __imp__abort = &g_t8738; // 00000000004083A0
<anonymous> * __imp__calloc = &g_t8740; // 00000000004083A8
<anonymous> * __imp__exit = &g_t874A; // 00000000004083B0
<anonymous> * __imp__fprintf = &g_t8752; // 00000000004083B8
<anonymous> * __imp__free = &g_t875C; // 00000000004083C0
<anonymous> * __imp__fwrite = &g_t8764; // 00000000004083C8
<anonymous> * __imp__malloc = &g_t876E; // 00000000004083D0
<anonymous> * __imp__memcpy = &g_t8778; // 00000000004083D8
<anonymous> * __imp__signal = &g_t8782; // 00000000004083E0
<anonymous> * __imp__strlen = &g_t878C; // 00000000004083E8
<anonymous> * __imp__strncmp = &g_t8796; // 00000000004083F0
<anonymous> * __imp__vfprintf = &g_t87A0; // 00000000004083F8
<anonymous> * __imp___ZNSolsEPFRSoS_E = &g_t87AC; // 0000000000408408
<anonymous> * __imp___ZNSt8ios_base4InitC1Ev = &g_t87C0; // 0000000000408410
<anonymous> * __imp___ZNSt8ios_base4InitD1Ev = &g_t87DC; // 0000000000408418
<anonymous> * __imp___ZSt4cerr = &g_t87F8; // 0000000000408420
<anonymous> * __imp___ZSt4endlIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_ = &g_t8804; // 0000000000408428
<anonymous> * __imp___ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_PKc = &g_t8844; // 0000000000408430
// subject_rdata.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

WCHAR g_t404260 = L'm'; // 0000000000404260
word32 g_dw404288 = 0x00; // 0000000000404288
word32 g_dw40428C = 0x00; // 000000000040428C
word32 g_dw404290 = 0x01; // 0000000000404290
struct Eq_1201 g_t404294 = // 0000000000404294
	{
		0x8420,
		5383,
		0x20,
	};
// subject_text.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 0000000000401000: void fn0000000000401000()
void fn0000000000401000()
{
}

// 0000000000401010: void fn0000000000401010()
void fn0000000000401010()
{
	Eq_2 r9_8 = (uint64) g_dw407050;
	g_dw407020 = g_dw407040;
	g_dw407024 = __getmainargs(&g_dw407004, &g_ptr407008, &g_qw407010, r9_8);
}

// 0000000000401060: void fn0000000000401060()
void fn0000000000401060()
{
	g_dw407068 = 0x01;
	g_dw407064 = 0x01;
	g_dw407060 = 0x01;
	g_dw407070 = 0x01;
	uint32 eax_47 = 0x00;
	if (g_w400000 == 23117)
	{
		struct Eq_40 * rdx_15 = 0x00400000 + (int64) g_dw40003C;
		if (rdx_15->dw0000 == 0x4550)
		{
			word16 cx_20 = rdx_15->w0018;
			if (cx_20 != 0x010B)
			{
				if (cx_20 == 0x020B && rdx_15->dw0084 > 0x0E)
					eax_47 = (uint32) (int8) (rdx_15->dw00F8 != 0x00);
			}
			else if (rdx_15->dw0074 > 0x0E)
				eax_47 = (uint32) (int8) (rdx_15->dw00E8 != 0x00);
		}
	}
	g_dw40701C = eax_47;
	if (g_dw407080 != 0x00)
		__set_app_type(0x02);
	else
		__set_app_type(0x01);
	word64 rax_65 = fn00000000004016A0();
	word32 edx_72 = g_dw407090;
	g_qw4079B0 = rax_65;
	g_qw4079A8 = rax_65;
	*fmode = edx_72;
	fn0000000000401D70();
	if (g_dw403060 != 0x01)
		return;
	fn0000000000401C80(&g_t401C90);
}

// 0000000000401180: Register word32 fn0000000000401180(Register (ptr32 Eq_126) gs)
// Called from:
//      fn00000000004014B0
//      Win32CrtStartup
word32 fn0000000000401180(struct Eq_126 * gs)
{
	word32 r11d_26 = g_dw407080;
	uint64 rcx_24;
	word64 * rdi_179 = fp - 0x98;
	for (rcx_24 = 0x0D; rcx_24 != 0x00; --rcx_24)
	{
		*rdi_179 = 0x00;
		++rdi_179;
	}
	if (r11d_26 != 0x00)
		GetStartupInfoA(fp - 0x98);
	word64 rbx_39 = gs->ptr0030->qw0008;
	__lock();
	word64 rax_42;
	__cmpxchg(g_qw4079C0, rbx_39, 0x00, out rax_42);
	uip32 esi_117 = 0x00;
	if (rax_42 != 0x00)
	{
		esi_117 = 0x01;
		if (rbx_39 != rax_42)
		{
			do
			{
				Sleep(1000);
				__lock();
				word64 rax_64;
				__cmpxchg(g_qw4079C0, rbx_39, 0x00, out rax_64);
				if (rax_64 == 0x00)
				{
					esi_117 = 0x00;
					goto l0000000000401204;
				}
			} while (rbx_39 != rax_64);
			esi_117 = 0x01;
			if (g_dw4079B8 == 0x01)
			{
l0000000000401434:
				_amsg_exit(0x1F);
				if (g_dw4079B8 != 0x01)
					goto l000000000040123A;
				goto l0000000000401450;
			}
l0000000000401213:
			if (g_dw4079B8 != 0x00)
				g_dw407000 = 0x01;
			else
			{
				g_dw4079B8 = 0x01;
				_initterm(&g_t409018, &g_t409030);
			}
			if (g_dw4079B8 != 0x01)
			{
l000000000040123A:
				if (esi_117 == 0x00)
				{
					__lock();
					g_qw4079C0 = 0x00;
				}
				<anonymous> * rax_140 = g_ptr403000;
				if (rax_140 != null)
					rax_140();
				word64 r9_721;
				word64 rdx_719;
				word64 r8_720;
				word64 rcx_718;
				fn0000000000401F60(out rcx_718, out rdx_719, out r8_720, out r9_721);
				g_t4070A0 = SetUnhandledExceptionFilter(&g_t401A30);
				fn0000000000401920();
				Eq_277 rax_260 = GetProcAddress(fn0000000000402590(), 0x00404000);
				if (rax_260 != null)
					rax_260();
				fn0000000000402660();
				if (g_dw407080 != 0x00)
				{
					byte * rax_287 = *acmdln;
					ui32 ecx_712 = 0x00;
l00000000004012CC:
					byte cl_298 = (byte) ecx_712;
					ci8 dl_292 = *rax_287;
					if (dl_292 > 0x20)
					{
						ecx_712 = ecx_712 ^ 0x01;
						goto l00000000004012C8;
					}
					if (dl_292 != 0x00)
					{
						if (cl_298 != 0x00)
						{
l00000000004012C8:
							++rax_287;
							goto l00000000004012CC;
						}
						do
						{
							++rax_287;
							ci8 dl_307 = *rax_287;
						} while (dl_307 <= 0x20 && dl_307 != 0x00);
					}
					g_ptr407990 = rax_287;
					g_ptr4079A0 = 0x00400000;
					word32 eax_328 = 0x0A;
					if ((bLoc5C & 0x01) != 0x00)
						eax_328 = (word32) (uint64) wLoc58;
					g_dw407998 = eax_328;
				}
				uint64 rdi_334 = (uint64) g_dw407004;
				char * rax_340[] = malloc((int64) ((word32) rdi_334 + 0x01) << 0x03);
				int32 edi_344 = (word32) rdi_334;
				Eq_318 rax_343 = 0x00;
				char * rsi_347[] = g_ptr407008;
				if (edi_344 > 0x00)
				{
					uint64 rbx_349 = 0x00;
					do
					{
						word64 r12_363 = CONVERT(strlen(rsi_347[rbx_349]) + 0x01, word32, int64);
						char * rax_365 = malloc(r12_363);
						rax_340[rbx_349] = rax_365;
						memcpy(rax_365, rsi_347[rbx_349], r12_363);
						++rbx_349;
					} while (edi_344 > (word32) rbx_349);
					rax_343 = (int64) edi_344 * 0x08;
				}
				Mem381[rax_340 + rax_343:word64] = 0x00;
				g_ptr407008 = rax_340;
				fn0000000000402710();
				*_initenv = g_qw407010;
				uint64 rax_397 = (uint64) fn00000000004014F0();
				word32 eax_406 = (word32) rax_397;
				uint32 r9d_408 = g_dw40701C;
				g_dw407018 = eax_406;
				if (r9d_408 == 0x00)
					exit((uint64) eax_406);
				else
				{
					if (g_dw407000 == 0x00)
					{
						cexit();
						rax_397 = (uint64) g_dw407018;
					}
					return (word32) rax_397;
				}
			}
l0000000000401450:
			_initterm(&g_t409000, &g_t409010);
			g_dw4079B8 = 0x02;
			goto l000000000040123A;
		}
	}
l0000000000401204:
	if (g_dw4079B8 == 0x01)
		goto l0000000000401434;
	goto l0000000000401213;
}

// 00000000004014B0: void fn00000000004014B0(Register (ptr32 Eq_126) gs)
void fn00000000004014B0(struct Eq_126 * gs)
{
	g_dw407080 = 0x01;
	fn0000000000402730();
	fn0000000000401180(gs);
}

// 00000000004014D0: Register Eq_186 Win32CrtStartup()
Eq_186 Win32CrtStartup()
{
	g_dw407080 = 0x00;
	fn0000000000402730();
	return fn0000000000401180(gs);
}

// 00000000004014F0: Register word32 fn00000000004014F0()
// Called from:
//      fn0000000000401180
word32 fn00000000004014F0()
{
	fn0000000000402710();
	word64 rax_20;
	ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_PKc();
	ZNSolsEPFRSoS_E();
	return 0x00;
}

// 000000000040152A: void fn000000000040152A()
void fn000000000040152A()
{
	ZNSt8ios_base4InitD1Ev();
}

// 0000000000401545: void fn0000000000401545(Register Eq_487 ecx, Register word32 edx)
// Called from:
//      fn0000000000401581
void fn0000000000401545(Eq_487 ecx, word32 edx)
{
	Eq_487 ecx = (word32) rcx;
	if (ecx == 0x01 && edx == 0xFFFF)
	{
		word64 rax_35;
		ZNSt8ios_base4InitC1Ev();
		fn0000000000401760(&g_t40152A);
	}
}

// 0000000000401581: void fn0000000000401581()
void fn0000000000401581()
{
	fn0000000000401545(0x01, 0xFFFF);
}

// 00000000004015D0: void fn00000000004015D0(Register up32 edx)
void fn00000000004015D0(up32 edx)
{
	if (edx != 0x00 && edx != 0x03)
		return;
	fn0000000000402A90(edx);
}

// 0000000000401600: void fn0000000000401600(Register up32 edx)
void fn0000000000401600(up32 edx)
{
	if (g_dw403050 != 0x02)
		g_dw403050 = 0x02;
	if (edx == 0x02)
	{
		word64 * rbx_17 = &g_qw409060;
		if (0x00409060 == 0x00409060)
			return;
		do
		{
			<anonymous> * rax_23 = *rbx_17;
			if (rax_23 != null)
			{
				word64 rcx_71;
				rax_23();
			}
			++rbx_17;
		} while (&g_qw409060 != rbx_17);
	}
	else if (edx == 0x01)
		fn0000000000402A90(edx);
}

// 0000000000401670: void fn0000000000401670()
void fn0000000000401670()
{
}

// 0000000000401680: void fn0000000000401680()
void fn0000000000401680()
{
	word64 rax_4;
	_lconv_init();
}

// 0000000000401690: Register word64 fn0000000000401690()
// Called from:
//      fn00000000004016B0
word64 fn0000000000401690()
{
	return rcx;
}

// 00000000004016A0: Register word64 fn00000000004016A0()
// Called from:
//      fn0000000000401060
//      fn00000000004016B0
word64 fn00000000004016A0()
{
	return rcx;
}

// 00000000004016B0: Register Eq_500 fn00000000004016B0(Register Eq_500 rcx)
// Called from:
//      fn0000000000401760
Eq_500 fn00000000004016B0(Eq_500 rcx)
{
	if (fn0000000000401690() == ~0x00)
		return _onexit(rcx);
	lock();
	fn0000000000401690();
	fn0000000000401690();
	Eq_500 rax_39 = __dllonexit(rcx, fp - 0x18, fp - 0x10);
	g_qw4079A8 = fn00000000004016A0();
	g_qw4079B0 = fn00000000004016A0();
	word64 r8_51;
	word64 rdx_52;
	unlock();
	return rax_39;
}

// 0000000000401760: void fn0000000000401760(Register Eq_500 rcx)
// Called from:
//      fn0000000000401545
//      fn0000000000402710
void fn0000000000401760(Eq_500 rcx)
{
	fn00000000004016B0(rcx);
}

// 0000000000401780: void fn0000000000401780(Register (ptr64 up32) rcx)
void fn0000000000401780(up32 * rcx)
{
	word32 ebx_139;
	up32 eax_10 = *rcx;
	if (eax_10 <= 0xC0000091)
	{
		if (eax_10 >= 0xC000008D)
			goto l0000000000401795;
		if (eax_10 == 0xC0000008)
			return;
		if (eax_10 <= 0xC0000008)
		{
			if (eax_10 == 0x80000002)
				return;
			if (eax_10 != 0xC0000005)
				return;
			void (* rax_96)(int32 rcx) = signal(11, null);
			if (rax_96 != (void (*)(int32)) 0x01)
			{
				if (rax_96 != null)
					rax_96(11);
			}
			else
				signal(11, rax_96);
			return;
		}
		if (eax_10 != 0xC000001D)
		{
			if (eax_10 != 0xC000008C)
				return;
			return;
		}
	}
	else
	{
		if (eax_10 == 0xC0000094)
		{
			ebx_139 = 0x00;
l000000000040179A:
			void (* rax_130)(int32 rcx) = signal(0x08, null);
			if (rax_130 != (void (*)(int32)) 0x01)
			{
				if (rax_130 != null)
					rax_130(0x08);
			}
			else
			{
				signal(0x08, rax_130);
				if (ebx_139 != 0x00)
					fn0000000000402660();
			}
			return;
		}
		if (eax_10 <= 0xC0000094)
		{
			if (eax_10 == 0xC0000092)
				return;
			if (eax_10 != 0xC0000093)
				return;
l0000000000401795:
			ebx_139 = 0x01;
			goto l000000000040179A;
		}
		if (eax_10 == 0xC0000095)
			return;
		if (eax_10 != 0xC0000096)
			return;
	}
	void (* rax_40)(int32 rcx) = signal(0x04, null);
	if (rax_40 != (void (*)(int32)) 0x01)
	{
		if (rax_40 != null)
			rax_40(0x04);
	}
	else
		signal(0x04, rax_40);
}

// 0000000000401920: void fn0000000000401920()
// Called from:
//      fn0000000000401180
void fn0000000000401920()
{
	ui64 rax_20 = fn0000000000402480();
	uint64 rax_29 = (uint64) g_dw4070A8;
	word32 eax_33 = (word32) rax_29;
	word32 rax_32_32_39 = SLICE(rax_29, word32, 32);
	if (rax_20 != 0x00 && eax_33 == 0x00)
	{
		g_dw4070A8 = 0x01;
		word64 rax_40 = fn00000000004022F0(rax_32_32_39, ".pdata");
		if (rax_40 == 0x00)
		{
			uint64 rcx_152 = 0x30;
			word64 * rdi_149 = &g_qw4070C0;
			struct Eq_713 * rbp_109 = &g_qw4070C0;
			while (true)
			{
				word56 rcx_56_8_171 = SLICE(rcx_152, word56, 8);
				if (rcx_152 == 0x00)
					break;
				*rdi_149 = rax_40;
				++rdi_149;
				--rcx_152;
			}
			word64 * rdi_144 = &g_qw407240;
			word32 r12d_175 = (word32) (4200320 - rax_20);
			word64 rcx_147;
			for (rcx_147 = SEQ(rcx_56_8_171, 0x20); rcx_147 != 0x00; --rcx_147)
			{
				*rdi_144 = rax_40;
				++rdi_144;
			}
			uint64 rdi_102;
			for (rdi_102 = 0x00; rdi_102 != 0x20; ++rdi_102)
			{
				struct Eq_746 * rax_78 = fn0000000000402400(rdi_102);
				if (rax_78 == null)
				{
					if (rdi_102 == 0x00)
						return;
					break;
				}
				(&g_qw407240)[rdi_102 * 0x08] = (word64) 0x09;
				((char *) &g_qw407240 + 4)[rdi_102 * 0x08] = (char) r12d_175;
				word32 edx_96 = rax_78->dw000C;
				rbp_109->dw0000 = edx_96;
				word32 edx_107 = edx_96 + rax_78->dw0008;
				rbp_109->dw0008 = (word32) 0x00407240 + (word32) rdi_102 * 0x08 - (word32) rax_20;
				rbp_109->dw0004 = edx_107;
				++rbp_109;
			}
			KERNEL32.dll!RtlAddFunctionTable();
		}
	}
}

// 0000000000401A30: void fn0000000000401A30(Register (ptr64 (ptr64 Eq_799)) rcx)
void fn0000000000401A30(struct Eq_799 ** rcx)
{
	struct Eq_799 * rdx_11 = *rcx;
	uint32 eax_15 = rdx_11->dw0000;
	if ((eax_15 & 0x20FFFFFF) == 0x20474343 && (rdx_11->b0004 & 0x01) == 0x00)
		return;
	word32 esi_153;
	if (eax_15 > 0xC0000091)
	{
		if (eax_15 == 0xC0000094)
		{
			esi_153 = 0x00;
			goto l0000000000401AAC;
		}
		if (eax_15 <= 0xC0000094)
		{
			if (eax_15 == 0xC0000092)
				return;
			if (eax_15 != 0xC0000093)
				goto l0000000000401A80;
l0000000000401AA7:
			esi_153 = 0x01;
l0000000000401AAC:
			void (* rax_145)(int32 rcx) = signal(0x08, null);
			if (rax_145 == (void (*)(int32)) 0x01)
			{
				signal(0x08, (void (*)(int32)) 0x01);
				if (esi_153 != 0x00)
					fn0000000000402660();
				return;
			}
			if (rax_145 != null)
			{
				rax_145(0x08);
				return;
			}
			goto l0000000000401A80;
		}
		if (eax_15 == 0xC0000095)
			return;
		if (eax_15 != 0xC0000096)
			goto l0000000000401A80;
	}
	else
	{
		if (eax_15 >= 0xC000008D)
			goto l0000000000401AA7;
		if (eax_15 == 0xC0000008)
			return;
		if (eax_15 <= 0xC0000008)
		{
			if (eax_15 == 0x80000002)
				return;
			if (eax_15 == 0xC0000005)
			{
				void (* rax_47)(int32 rcx) = signal(11, null);
				if (rax_47 == (void (*)(int32)) 0x01)
				{
					signal(11, (void (*)(int32)) 0x01);
					return;
				}
				if (rax_47 != null)
				{
					rax_47(11);
					return;
				}
			}
			goto l0000000000401A80;
		}
		if (eax_15 != 0xC000001D)
		{
			if (eax_15 == 0xC000008C)
				return;
			goto l0000000000401A80;
		}
	}
	void (* rax_94)(int32 rcx) = signal(0x04, null);
	if (rax_94 == (void (*)(int32)) 0x01)
	{
		signal(0x04, (void (*)(int32)) 0x01);
		return;
	}
	if (rax_94 != null)
	{
		rax_94(0x04);
		return;
	}
l0000000000401A80:
	Eq_269 rax_186 = g_t4070A0;
	if (rax_186 == null)
		return;
	rax_186();
}

// 0000000000401C40: void fn0000000000401C40(Register word32 ecx, Register word64 rdx, Register word128 xmm2, Register word128 xmm3, Stack word64 qwArg28)
void fn0000000000401C40(word32 ecx, word64 rdx, word128 xmm2, word128 xmm3, word64 qwArg28)
{
	word32 ecx = (word32) rcx;
	Eq_67 rax_5 = g_t407340;
	if (rax_5 != null)
		rax_5();
}

// 0000000000401C80: void fn0000000000401C80(Register Eq_67 rcx)
// Called from:
//      fn0000000000401060
void fn0000000000401C80(Eq_67 rcx)
{
	g_t407340 = rcx;
	__setusermatherr(rcx);
}

// 0000000000401C90: void fn0000000000401C90(Register (ptr64 up32) rcx)
void fn0000000000401C90(up32 * rcx)
{
	if (*rcx > 0x06)
	{
l0000000000401C9F:
	}
	else
	{
		switch (*rcx)
		{
		case 0x00:
			goto l0000000000401C9F;
		case 0x01:
			break;
		case 0x02:
			break;
		case 0x03:
			break;
		case 0x04:
			break;
		case 0x05:
			break;
		case 0x06:
			break;
		}
	}
	word64 rax_48;
	_iob_func();
	fprintf(rax_48 + 0x60, "_matherr(): %s in %s(%g, %g)  (retval=%g)\n", 0x00);
}

// 0000000000401D70: void fn0000000000401D70()
// Called from:
//      fn0000000000401060
void fn0000000000401D70()
{
}

// 0000000000401D80: Register word32 fn0000000000401D80(Register ptr64 rcx, Register (ptr64 char) rdx, Register Eq_186 r8, Register Eq_261 r9, Register out (ptr64 Eq_1380) rcxOut, Register out Eq_946 rdxOut, Register out ptr64 r8Out, Register out ptr64 r9Out)
// Called from:
//      fn0000000000401DF0
//      fn0000000000401F60
word32 fn0000000000401D80(ptr64 rcx, char * rdx, Eq_186 r8, Eq_261 r9, union Eq_1380 & rcxOut, union Eq_946 & rdxOut, ptr64 & r8Out, ptr64 & r9Out)
{
	word64 rax_21;
	_iob_func();
	word64 rax_35;
	word64 r9_39;
	_iob_func();
	char * rcx_45;
	char * rdx_46;
	Eq_308 r8_47;
	msvcrt.dll!vfprintf();
	abort();
	union Eq_1380 * rcx_51;
	Eq_946 rdx_52;
	ptr64 r8_53;
	ptr64 r9_54;
	uint64 rax_50 = (uint64) fn0000000000401DF0(rcx_45, rdx_46, r8_47, out rcx_51, out rdx_52, out r8_53, out r9_54);
	rcxOut = rcx_51;
	rdxOut = rdx_52;
	r8Out = r8_53;
	r9Out = r9_54;
	return (word32) rax_50;
}

// 0000000000401DF0: Register word32 fn0000000000401DF0(Register (ptr64 char) rcx, Register (ptr64 char) rdx, Register Eq_308 r8, Register out (ptr64 char) rcxOut, Register out (ptr64 char) rdxOut, Register out Eq_308 r8Out, Register out Eq_977 r9Out)
// Called from:
//      fn0000000000401D80
//      fn0000000000401F60
word32 fn0000000000401DF0(char * rcx, char * rdx, Eq_308 r8, char & rcxOut, char & rdxOut, union Eq_308 & r8Out, PDWORD & r9Out)
{
	if (r8 != 0x00)
	{
		uint64 r12_37;
		int32 ecx_33 = g_dw407360;
		if (ecx_33 > 0x00)
		{
			struct Eq_998 * rax_41 = &g_ptr407358->t0008;
			int32 r12d_44 = 0x00;
			do
			{
				char * rdx_49 = rax_41->qw0000;
				if (rcx >= rdx_49 && rcx < rdx_49 + (uint64) (rax_41->ptr0010)->dw0008)
					goto l0000000000401EE0;
				r12_37 = (uint64) (r12d_44 + 0x01);
				r12d_44 = (word32) r12_37;
				++rax_41;
			} while (r12d_44 != ecx_33);
		}
		else
			r12_37 = 0x00;
		word32 r12d_108 = (word32) r12_37;
		Eq_186 r8_76;
		struct Eq_1033 * rax_73 = fn0000000000402390(rcx, out r8_76, out r9);
		if (rax_73 != null)
		{
			int64 r12_109 = (int64) r12d_108;
			struct Eq_1058 * r13_115 = g_ptr407358 + (r12_109 << 0x03) /64 16;
			r13_115->ptr0010 = rax_73;
			r13_115->dw0000 = 0x00;
			r13_115->qw0008 = fn0000000000402480() + (uint64) rax_73->dw000C;
			struct Eq_1000 * rax_133 = g_ptr407358;
			if (SEQ(SLICE(rax_133, word32, 32), VirtualQuery(rax_133->t0008, fp - 0x68, 0x30)) != 0x00)
			{
				if (dwLoc44 != 0x04 && dwLoc44 != 0x40)
				{
					r9 = (Eq_977) (g_ptr407358 + (r12_109 << 0x03) /64 16);
					VirtualProtect(qwLoc68, qwLoc50, 0x40, r9);
				}
				++g_dw407360;
l0000000000401EE0:
				void * rax_212 = memcpy(rcx, rdx, r8);
				rcxOut = rcx;
				rdxOut = rdx;
				r8Out = r8;
				r9Out = r9;
				return (word32) rax_212;
			}
		}
		else
		{
			Eq_261 r9_105;
			word64 r8_318;
			word64 rcx_316;
			word64 rdx_317;
			fn0000000000401D80(0x004041A0, rcx, r8_76, r9_105, out rcx_316, out rdx_317, out r8_318, out r9_105);
		}
		Eq_261 r9_158;
		word64 rcx_319;
		word64 rdx_320;
		word64 r8_321;
		fn0000000000401D80(0x004041C0, (uint64) rax_73->dw0008, g_ptr407358->t0008, r9_158, out rcx_319, out rdx_320, out r8_321, out r9_158);
		Eq_308 r8_161;
		char * rcx_162;
		char * rdx_163;
		Eq_977 r9_165;
		uint64 rax_164 = (uint64) fn0000000000401F60(out rcx_162, out rdx_163, out r8_161, out r9_165);
		rcxOut = rcx_162;
		rdxOut = rdx_163;
		r8Out = r8_161;
		r9Out = r9_165;
		return (word32) rax_164;
	}
	else
	{
		rcxOut = rcx;
		rdxOut = rdx;
		r8Out = r8;
		r9Out = r9;
		return (word32) rax;
	}
}

// 0000000000401F60: Register word32 fn0000000000401F60(Register out Eq_258 rcxOut, Register out Eq_259 rdxOut, Register out Eq_186 r8Out, Register out Eq_261 r9Out)
// Called from:
//      fn0000000000401180
//      fn0000000000401DF0
word32 fn0000000000401F60(LPVOID & rcxOut, union Eq_259 & rdxOut, union Eq_186 & r8Out, union Eq_261 & r9Out)
{
	if (g_dw407350 != 0x00)
	{
l0000000000401F79:
		rcxOut = rcx;
		rdxOut = rdx;
		r8Out = r8;
		r9Out = r9;
		return (word32) rax;
	}
	g_dw407350 = 0x01;
	ui64 rax_37 = (word64) ((word64) ((int64) fn00000000004023D0(out rcx, out rdx) * 0x18) + 30);
	fn0000000000402B30(rax_37 & ~0x0F);
	g_dw407360 = 0x00;
	g_ptr407358 = fp - 0x88 - (rax_37 & ~0x0F) + 0x20;
	struct Eq_1201 * rbx_297 = &g_dw404288;
	rax = 0x004042A0 - 0x00404288;
	if (rax <= (struct Eq_1205 *) 0x07)
		goto l0000000000401F79;
	if (rax > (struct Eq_1205 *) 11)
	{
		if (g_dw404288 != 0x00 || g_dw40428C != 0x00)
		{
l0000000000402001:
			if (rbx_297 >= (struct Eq_1201 *) 0x004042A0)
				goto l0000000000401F79;
			do
			{
				++rbx_297;
				word64 rcx_723;
				rax = (uint64) fn0000000000401DF0((uint64) rbx_297->dw0004 + 0x00400000, fp - 44, 0x04, out rcx_723, out rdx, out r8, out r9);
			} while (rbx_297 < (struct Eq_1201 *) 0x004042A0);
			goto l0000000000402036;
		}
		if (g_dw404290 != 0x00)
			goto l00000000004020E9;
		rbx_297 = (struct Eq_1201 *) &g_t404294;
	}
	r9.u0 = (uint64) rbx_297->dw0000;
	if ((word32) r9 == 0x00)
	{
		r8 = (uint64) rbx_297->dw0004;
		if ((word32) r8 == 0x00)
		{
l00000000004020E9:
			rdx = (uint64) rbx_297[1];
			if ((word32) rdx != 0x01)
			{
l0000000000402257:
				struct Eq_1345 * rcx_412;
				char * rdx_413;
				Eq_186 r8_414;
				Eq_261 r9_415;
				fn0000000000401D80(4211192, rdx_413, r8_414, r9_415, out rcx_412, out rdx_413, out r8_414, out r9_415);
				Eq_258 rcx_420;
				Eq_259 rdx_421;
				uint64 rax_419 = (uint64) fn0000000000402270(rcx_412, out rcx_420, out rdx_421);
				rcxOut = rcx_420;
				rdxOut = rdx_421;
				r8Out = r8_414;
				r9Out = r9_415;
				return (word32) rax_419;
			}
			struct Eq_1372 * rbx_104 = &rbx_297->dw0008 + 1;
			if (rbx_104 >= (struct Eq_1372 *) 0x004042A0)
				goto l0000000000401F79;
			do
			{
				uint64 r8_123;
				byte r8b_112 = rbx_104->b0008;
				struct Eq_1205 * rax_114 = (uint64) r8b_112;
				rdx = (uint64) rbx_104->dw0000 + 0x00400000;
				up32 eax_118 = (word32) rax_114;
				union Eq_1380 * rcx_117 = (uint64) rbx_104->dw0004 + 0x00400000;
				Eq_261 r9_120 = *rdx;
				if (eax_118 != 0x10)
				{
					Eq_261 r9_164;
					if (eax_118 <= 0x10)
					{
						if (eax_118 != 0x08)
							goto l0000000000402139;
						r8_123 = (uint64) *rcx_117;
						if (((byte) r8_123 & 0x80) != 0x00)
							goto l00000000004021CB;
						goto l00000000004021B5;
					}
					while (true)
					{
						word32 eax_168 = (word32) rax_114;
						if (eax_168 == 0x20)
							break;
						if (eax_168 == 0x40)
							goto l0000000000402169;
l0000000000402139:
						Eq_186 r8_163;
						rax_114 = (uint64) fn0000000000401D80(0x00404230, (uint64) r8b_112, r8_163, r9_164, out rcx_117, out rdx, out r8_163, out r9_164);
						r8b_112 = (byte) r8_163;
						r9_120 = r9_164;
					}
					r8_123 = (uint64) *rcx_117;
					if (((word32) r8_123 & 0x80000000) != 0x00)
						goto l00000000004021F5;
					goto l00000000004021B5;
				}
				r8_123 = (uint64) *rcx_117;
				if (((word32) r8_123 & 0x8000) != 0x00)
				{
l00000000004021A4:
					char * rcx_217;
					rax = (uint64) fn0000000000401DF0(rcx_217, fp - 0x38, 0x02, out rcx_217, out rdx, out r8, out r9);
					goto l0000000000402178;
				}
l00000000004021B5:
				r8 = r8_123 - rdx;
				up32 eax_187 = (word32) rax_114;
				r9 = r9_120 + r8;
				if (eax_187 == 0x10)
					goto l00000000004021A4;
				if (eax_187 <= 0x10)
				{
					rax = rax_114;
					if (eax_187 == 0x08)
					{
l00000000004021CB:
						char * rcx_241;
						rax = (uint64) fn0000000000401DF0(rcx_241, fp - 0x38, 0x01, out rcx_241, out rdx, out r8, out r9);
					}
				}
				else if (eax_187 != 0x20)
				{
					rax = rax_114;
					if (eax_187 == 0x40)
					{
l0000000000402169:
						char * rcx_286;
						rax = (uint64) fn0000000000401DF0(rcx_286, fp - 0x38, 0x08, out rcx_286, out rdx, out r8, out r9);
					}
				}
				else
				{
l00000000004021F5:
					char * rcx_263;
					rax = (uint64) fn0000000000401DF0(rcx_263, fp - 0x38, 0x04, out rcx_263, out rdx, out r8, out r9);
				}
l0000000000402178:
				++rbx_104;
			} while (rbx_104 < (struct Eq_1372 *) 0x004042A0);
l0000000000402036:
			rcx = (Eq_258) (uint64) g_dw407360;
			if ((word32) rcx > 0x00)
			{
				Eq_1262 rbx_346 = 0x00;
				uint64 rsi_348 = 0x00;
				do
				{
					rax = rbx_346 + Mem334[0x0000000000407358<p64>:word64];
					rdx = (uint64) rax->dw0000;
					word32 esi_434 = (word32) rsi_348;
					word32 rax_32_32_370 = SLICE(rax, word32, 32);
					if ((word32) rdx != 0x00)
					{
						if (SEQ(rax_32_32_370, VirtualQuery(rax->t0008, fp - 0x68, 0x30)) == 0x00)
						{
							word64 rbx_375 = rbx_346 + Mem334[0x0000000000407358<p64>:word64];
							word64 rcx_724;
							Eq_261 r9_391;
							word64 r8_726;
							word64 rdx_725;
							fn0000000000401D80(0x004041C0, (uint64) rbx_375->ptr0010->dw0008, rbx_375->t0008, r9_391, out rcx_724, out rdx_725, out r8_726, out r9_391);
							goto l0000000000402257;
						}
						struct Eq_1000 * rax_426 = g_ptr407358;
						r8 = CONVERT(Mem334[rax_426 + rbx_346:word32], word32, uint64);
						r9 = fp - 44;
						rdx = qwLoc50;
						rcx = qwLoc68;
						rax = SEQ(SLICE(rax_426, word32, 32), VirtualProtect(qwLoc68, qwLoc50, r8, fp - 44));
					}
					rsi_348 = (uint64) (esi_434 + 0x01);
					rbx_346 = (word64) rbx_346 + 24;
				} while ((word32) rsi_348 < g_dw407360);
			}
			goto l0000000000401F79;
		}
	}
	goto l0000000000402001;
}

// 0000000000402270: Register word32 fn0000000000402270(Register (ptr64 Eq_1345) rcx, Register out (ptr64 Eq_1345) rcxOut, Register out Eq_1347 rdxOut)
// Called from:
//      fn0000000000401F60
//      fn00000000004022F0
//      fn0000000000402390
//      fn00000000004023D0
//      fn0000000000402400
//      fn0000000000402480
//      fn00000000004024B0
//      fn0000000000402500
word32 fn0000000000402270(struct Eq_1345 * rcx, struct Eq_1345 & rcxOut, union Eq_1347 & rdxOut)
{
	if (rcx->t0000 == 23117)
	{
		rdx.u0 = (int64) rcx->dw003C;
		rcx += rdx;
		if (rcx->t0000 == 0x4550)
		{
			uint64 rax_31 = (uint64) (int8) (rcx->w0018 == 0x020B);
			rcxOut = rcx;
			rdxOut = rdx;
			return (word32) rax_31;
		}
	}
	rcxOut = rcx;
	rdxOut = rdx;
	return 0x00;
}

// 00000000004022A0: Register (ptr64 Eq_1548) fn00000000004022A0(Register (ptr64 Eq_1549) rcx, Register Eq_1550 rdx, Register out Eq_1550 r8Out, Register out (ptr64 Eq_1548) r9Out)
// Called from:
//      fn0000000000402390
//      fn00000000004024B0
//      fn0000000000402500
struct Eq_1548 * fn00000000004022A0(struct Eq_1549 * rcx, Eq_1550 rdx, union Eq_1550 & r8Out, struct Eq_1548 & r9Out)
{
	struct Eq_1553 * rcx_6 = rcx + (int64) rcx->dw003C /64 64;
	Eq_1550 r8_10 = (uint64) rcx_6->w0006;
	struct Eq_1548 * r9_12 = (uint64) rcx_6->w0014;
	struct Eq_1548 * rax_24 = null;
	word32 r8d_13 = (word32) r8_10;
	word16 r9w_17 = (word16) r9_12;
	if (r8d_13 != 0x00)
	{
		rax_24 = (struct Eq_1548 *) (&rcx_6->w0014 + 2 + (uint64) r9w_17 /64 22);
		r9_12 = rax_24 + 0x28 + CONVERT(r8d_13 - 0x01, word32, uint64) * 0x28;
		do
		{
			word32 ecx_31 = rax_24->dw000C;
			r8_10.u0 = (uint64) ecx_31;
			if (r8_10 <= rdx && rdx < (uint64) (ecx_31 + rax_24->dw0008))
				goto l00000000004022EE;
			rax_24 += 0x28;
		} while (rax_24 != r9_12);
		rax_24 = null;
	}
l00000000004022EE:
	r8Out = r8_10;
	r9Out = r9_12;
	return rax_24;
}

// 00000000004022F0: Register (ptr64 char) fn00000000004022F0(Register word32 rax_32_32, Register (ptr64 char) rcx)
// Called from:
//      fn0000000000401920
char * fn00000000004022F0(word32 rax_32_32, char * rcx)
{
	char * rbx_14 = null;
	if (SEQ(rax_32_32, strlen(rcx)) > 0x08)
		return rbx_14;
	word64 rcx_128;
	word64 rdx_129;
	if (fn0000000000402270(&g_w400000, out rcx_128, out rdx_129) == 0x00)
		return rbx_14;
	struct Eq_1622 * rax_36 = 0x00400000 + (int64) g_dw40003C;
	word32 edx_41 = (word32) (uint64) rax_36->w0006;
	word16 cx_45 = rax_36->w0014;
	if (edx_41 == 0x00)
		return rbx_14;
	rbx_14 = (char *) (&rax_36->w0014 + 2 + (uint64) cx_45 /64 22);
	word64 rdi_54 = rbx_14 + 0x28 + CONVERT(edx_41 - 0x01, word32, uint64) * 0x28;
	do
	{
		if (strncmp(rbx_14, rcx, 0x08) == 0x00)
			return rbx_14;
		rbx_14 += 0x28;
	} while (rbx_14 != rdi_54);
	return null;
}

// 0000000000402390: Register uint64 fn0000000000402390(Register (ptr64 char) rcx, Register out ptr64 r8Out, Register out ptr64 r9Out)
// Called from:
//      fn0000000000401DF0
uint64 fn0000000000402390(char * rcx, ptr64 & r8Out, ptr64 & r9Out)
{
	word64 rcx_63;
	word64 rdx_64;
	if (fn0000000000402270(&g_w400000, out rcx_63, out rdx_64) == 0x00)
	{
		r8Out = r8;
		r9Out = r9;
		return 0x00;
	}
	else
	{
		Eq_1550 rdx_30 = rcx - 0x00400000;
		ptr64 r8_35;
		ptr64 r9_36;
		uint64 rax_37 = fn00000000004022A0(&g_w400000, rdx_30, out r8_35, out r9_36);
		r8Out = r8_35;
		r9Out = r9_36;
		return rax_37;
	}
}

// 00000000004023D0: Register word32 fn00000000004023D0(Register out ptr64 rcxOut, Register out Eq_1171 rdxOut)
// Called from:
//      fn0000000000401F60
word32 fn00000000004023D0(ptr64 & rcxOut, union Eq_1171 & rdxOut)
{
	Eq_1171 rdx_23 = 0x00;
	ptr64 rcx_7;
	word64 rdx_45;
	if (fn0000000000402270(&g_w400000, out rcx_7, out rdx_45) != 0x00)
		rdx_23.u0 = (uint64) (&g_t400006)[(int64) g_dw40003C /64 2];
	rcxOut = rcx_7;
	rdxOut = rdx_23;
	return (word32) rdx_23;
}

// 0000000000402400: Register (ptr64 Eq_1711) fn0000000000402400(Register uint64 rcx)
// Called from:
//      fn0000000000401920
struct Eq_1711 * fn0000000000402400(uint64 rcx)
{
	uint64 rbx_50 = rcx;
	struct Eq_1711 * rdx_19 = null;
	word64 rcx_94;
	word64 rdx_95;
	if (fn0000000000402270(&g_w400000, out rcx_94, out rdx_95) != 0x00)
	{
		struct Eq_1724 * rax_26 = 0x00400000 + (int64) g_dw40003C;
		word32 ecx_31 = (word32) (uint64) rax_26->w0006;
		word16 r8w_35 = rax_26->w0014;
		if (ecx_31 != 0x00)
		{
			rdx_19 = (struct Eq_1711 *) (&rax_26->w0014 + 2 + (uint64) r8w_35 /64 22);
			word64 rax_44 = rdx_19 + 0x28 + CONVERT(ecx_31 - 0x01, word32, uint64) * 0x28;
			do
			{
				if ((rdx_19->b0027 & 0x20) != 0x00)
				{
					if (rbx_50 == 0x00)
						return rdx_19;
					--rbx_50;
				}
				rdx_19 += 0x28;
			} while (rdx_19 != rax_44);
			rdx_19 = null;
		}
	}
	return rdx_19;
}

// 0000000000402480: Register Eq_1770 fn0000000000402480()
// Called from:
//      fn0000000000401920
//      fn0000000000401DF0
Eq_1770 fn0000000000402480()
{
	Eq_1770 rdx_14 = 0x00;
	word64 rcx_31;
	word64 rdx_32;
	if (fn0000000000402270(&g_w400000, out rcx_31, out rdx_32) != 0x00)
		rdx_14.u1 = 0x00400000;
	return rdx_14;
}

// 00000000004024B0: void fn00000000004024B0(Register ui64 rcx)
void fn00000000004024B0(ui64 rcx)
{
	word64 rdx_105;
	word64 rcx_104;
	if (fn0000000000402270(&g_w400000, out rcx_104, out rdx_105) == 0x00)
		return;
	word64 r8_106;
	word64 r9_107;
	if (fn00000000004022A0(&g_w400000, rcx - 0x00400000, out r8_106, out r9_107) == 0x00)
		;
}

// 0000000000402500: Register uint64 fn0000000000402500(Register int32 ecx, Register out Eq_1806 ebxOut)
// Called from:
//      fn0000000000402590
uint64 fn0000000000402500(int32 ecx, union Eq_1806 & ebxOut)
{
	uint64 rbp_103 = 0x00;
	int32 ebx_120 = ecx;
	word64 rdx_178;
	word64 rcx_177;
	if (fn0000000000402270(&g_w400000, out rcx_177, out rdx_178) != 0x00)
	{
		Eq_1550 rdi_39 = (uint64) (&g_t400090)[(int64) g_dw40003C /64 4];
		if ((word32) rdi_39 != 0x00)
		{
			word64 r9_180;
			word64 r8_179;
			if (fn00000000004022A0(&g_w400000, rdi_39, out r8_179, out r9_180) != 0x00)
			{
				struct Eq_1840 * rdi_58 = (word64) rdi_39.u0 + 0x00400000;
				if (rdi_58 != null)
				{
					while (rdi_58->dw0004 != 0x00 || rdi_58->dw000C != 0x00)
					{
						if (ebx_120 <= 0x00)
						{
							rbp_103 = (uint64) rdi_58->dw000C + 0x00400000;
							goto l000000000040256F;
						}
						--ebx_120;
						++rdi_58;
					}
					ebxOut.u0 = <invalid>;
					return 0x00;
				}
			}
		}
	}
l000000000040256F:
	ebxOut.u0 = <invalid>;
	return rbp_103;
}

// 0000000000402590: Register Eq_280 fn0000000000402590()
// Called from:
//      fn0000000000401180
Eq_280 fn0000000000402590()
{
	Eq_280 rax_104 = g_t407370;
	if (rax_104 == null)
	{
		uint64 rcx_114 = 0x00;
		while (true)
		{
			word64 rbx_26 = <invalid>;
			word32 ebx_196;
			Eq_281 rax_20 = fn0000000000402500((word32) rcx_114, out ebx_196);
			word32 ebx_107 = (word32) rbx_26;
			if (rax_20 == 0x00)
				break;
			byte dl_40 = *rax_20;
			if (dl_40 == 77 || dl_40 == 0x6D)
			{
				byte dl_49 = *((word64) rax_20 + 1);
				if (dl_49 == 0x53 || dl_49 == 115)
				{
					byte dl_58 = *((word64) rax_20 + 2);
					if (dl_58 == 0x56 || dl_58 == 118)
					{
						byte dl_67 = *((word64) rax_20 + 3);
						if (dl_67 == 0x43 || dl_67 == 99)
						{
							byte dl_76 = *((word64) rax_20 + 4);
							if (dl_76 == 0x52 || dl_76 == 114)
							{
								uint64 rdx_84 = (uint64) *((word64) rax_20 + 5);
								byte dl_85 = (byte) rdx_84;
								word32 edx_90 = (word32) rdx_84;
								if (dl_85 == 0x54 || (dl_85 == 116 || (byte) edx_90 <= 0x39))
								{
									rax_104 = GetModuleHandleA(rax_20);
									g_t407370 = rax_104;
									if (rax_104 == null)
										break;
									return rax_104;
								}
							}
						}
					}
				}
			}
			rcx_114 = (uint64) ebx_107;
		}
		rax_104 = LoadLibraryW(&g_t404260);
		g_t407370 = rax_104;
	}
	return rax_104;
}

// 0000000000402660: void fn0000000000402660()
// Called from:
//      fn0000000000401180
//      fn0000000000401780
//      fn0000000000401A30
void fn0000000000402660()
{
	__fninit();
}

// 0000000000402670: void fn0000000000402670()
void fn0000000000402670()
{
	<anonymous> * rax_10 = g_ptr403030->qw0000;
	while (rax_10 != null)
	{
		rax_10();
		struct Eq_1966 * rax_16 = g_ptr403030;
		rax_10 = rax_16->ptr0008;
		g_ptr403030 = (struct Eq_1966 *) &rax_16->ptr0008;
	}
}

// 00000000004026B0: void fn00000000004026B0()
// Called from:
//      fn0000000000402710
void fn00000000004026B0()
{
	word32 eax_11 = g_dw402D10;
	uint64 rbx_14 = (uint64) eax_11;
	if (eax_11 == ~0x00)
	{
		rbx_14 = 0x00;
		while (true)
		{
			word32 eax_25 = (word32) rbx_14 + 0x01;
			if ((&g_dw402D10)[(uint64) eax_25 * 0x08] == 0x00)
				break;
			rbx_14 = (uint64) eax_25;
		}
	}
	if ((word32) rbx_14 != 0x00)
	{
		uint64 rbx_54 = rbx_14;
		do
		{
			word32 ebx_41 = (word32) rbx_54;
			uint64 rax_43 = (uint64) ebx_41;
			word64 rdx_51;
			(&g_dw402D10)[rax_43 * 0x08]();
			rbx_54 = (uint64) (ebx_41 - 0x01);
		} while ((word32) rbx_54 != 0x00);
	}
	fn0000000000401760(&g_t402670);
}

// 0000000000402710: void fn0000000000402710()
// Called from:
//      fn0000000000401180
//      fn00000000004014F0
void fn0000000000402710()
{
	if (g_dw407380 != 0x00)
		return;
	g_dw407380 = 0x01;
	fn00000000004026B0();
}

// 0000000000402730: void fn0000000000402730()
// Called from:
//      fn00000000004014B0
//      Win32CrtStartup
void fn0000000000402730()
{
	ui64 rbx_19 = g_qw403070;
	if (rbx_19 == 0x2B992DDFA232)
	{
		GetSystemTimeAsFileTime(fp - 0x48);
		uint64 rbp_28 = (uint64) GetCurrentProcessId();
		uint64 rdi_31 = (uint64) GetCurrentThreadId();
		uint64 rsi_35 = (uint64) GetTickCount();
		QueryPerformanceCounter(fp - 0x38);
		ui64 r12_41 = qwLoc38 ^ rbp_28 ^ rdi_31 ^ rsi_35;
		ui64 r12_42 = r12_41 & 0xFFFFFFFFFFFF;
		ui64 rax_45 = ~(r12_41 & 0xFFFFFFFFFFFF);
		if ((r12_41 & 0xFFFFFFFFFFFF) == rbx_19)
		{
			rax_45 = 18446696136809930188;
			r12_42 = 0x2B992DDFA233;
		}
		g_qw403070 = r12_42;
		g_qw403080 = rax_45;
	}
	else
		g_qw403080 = ~rbx_19;
}

// 0000000000402800: void fn0000000000402800(Register word64 rcx, Stack Eq_2092 qwArg00)
void fn0000000000402800(word64 rcx, Eq_2092 qwArg00)
{
	RtlCaptureContext(&g_t4073A0);
	Eq_2092 rbx_17 = g_t407498;
	if (RtlLookupFunctionEntry(rbx_17, fp - 0x30, null) != null)
	{
		KERNEL32.dll!RtlVirtualUnwind();
l0000000000402873:
		Eq_2092 rax_48 = g_t407498;
		g_qw407420 = rcx;
		g_dw407880 = 0xC0000409;
		g_dw407884 = 0x01;
		g_t407890 = rax_48;
		word32 rax_32_32_70 = SLICE(SetUnhandledExceptionFilter(null), word32, 32);
		UnhandledExceptionFilter(&g_t403040);
		TerminateProcess(SEQ(rax_32_32_70, GetCurrentProcess()), 0xC0000409);
		abort();
	}
	g_t407498 = qwArg00;
	g_ptr407438 = fp;
	goto l0000000000402873;
}

// 0000000000402900: void fn0000000000402900()
// Called from:
//      fn0000000000402A90
void fn0000000000402900()
{
	EnterCriticalSection(&g_t407940);
	struct Eq_2159 * rbx_17;
	for (rbx_17 = g_ptr407968; rbx_17 != null; rbx_17 = rbx_17->ptr0010)
	{
		Eq_258 rax_27 = TlsGetValue((uint64) rbx_17->dw0000);
		if (GetLastError() == 0x00 && rax_27 != null)
			rbx_17->ptr0008();
	}
	LeaveCriticalSection(&g_t407940);
}

// 0000000000402970: void fn0000000000402970(Register word32 ecx, Register (ptr64 code) rdx)
void fn0000000000402970(word32 ecx, <anonymous> * rdx)
{
	word32 ecx = (word32) rcx;
	if (g_dw407920 == 0x00)
		return;
	struct Eq_2159 * rax_33 = calloc(0x01, 0x18);
	if (rax_33 == null)
		return;
	rax_33->dw0000 = ecx;
	rax_33->ptr0008 = rdx;
	EnterCriticalSection(&g_t407940);
	struct Eq_2159 * rax_44 = g_ptr407968;
	g_ptr407968 = rax_33;
	rax_33->ptr0010 = rax_44;
	LeaveCriticalSection(&g_t407940);
}

// 00000000004029F0: void fn00000000004029F0(Register word32 ecx)
void fn00000000004029F0(word32 ecx)
{
	word32 ecx = (word32) rcx;
	if (g_dw407920 == 0x00)
		return;
	EnterCriticalSection(&g_t407940);
	struct Eq_2159 * rax_17 = g_ptr407968;
	if (rax_17 != null)
	{
		struct Eq_2159 * rcx_29;
		if (rax_17->dw0000 == ecx)
		{
			g_ptr407968 = rax_17->ptr0010;
			rcx_29 = rax_17;
l0000000000402A68:
			free(rcx_29);
			LeaveCriticalSection(&g_t407940);
			return;
		}
		while (true)
		{
			rcx_29 = rax_17->ptr0010;
			if (rcx_29 == null)
				break;
			if (rcx_29->dw0000 == ecx)
			{
				rax_17->ptr0010 = rcx_29->ptr0010;
				goto l0000000000402A68;
			}
			rax_17 = rcx_29;
		}
	}
	LeaveCriticalSection(&g_t407940);
}

// 0000000000402A90: void fn0000000000402A90(Register up32 edx)
// Called from:
//      fn00000000004015D0
//      fn0000000000401600
void fn0000000000402A90(up32 edx)
{
	if (edx == 0x01)
	{
		if (g_dw407920 == 0x00)
			InitializeCriticalSection(&g_t407940);
		g_dw407920 = 0x01;
	}
	else if (edx >= 0x01)
	{
		if (edx == 0x03 && g_dw407920 != 0x00)
			fn0000000000402900();
	}
	else
	{
		if (g_dw407920 != 0x00)
			fn0000000000402900();
		if (g_dw407920 == 0x01)
		{
			g_dw407920 = 0x00;
			DeleteCriticalSection(&g_t407940);
		}
	}
}

// 0000000000402B30: void fn0000000000402B30(Register uint64 rax)
// Called from:
//      fn0000000000401F60
void fn0000000000402B30(uint64 rax)
{
	struct Eq_2323 * rcx_10 = fp + 0x08;
	if (rax >= 0x1000)
	{
		do
		{
			rcx_10 -= 0x1000;
			rcx_10->qw0000 = rcx_10->qw0000;
			rax -= 0x1000;
		} while (rax > 0x1000);
	}
	word64 * rcx_24 = rcx_10 - rax;
	*rcx_24 = *rcx_24;
}

word32 g_dw402D10 = ~0x00; // 0000000000402D10
Eq_1966 g_t402D30 = // 0000000000402D30
	{
		0x00,
		null,
	};
