// subject_CRT.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

PVFV g_t409000 = null; // 0000000000409000
PVFV g_t409010 = null; // 0000000000409010
PVFV g_t409018 = null; // 0000000000409018
PVFV g_t409030 = null; // 0000000000409030
word64 g_qw409060 = 0x00; // 0000000000409060
// subject_PE_header.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

Eq_38 g_t400000 = // 0000000000400000
	{
		23117
	};
word16 g_a400006[] = // 0000000000400006
	{
	};
word32 g_dw40003C = 0x80; // 000000000040003C
word32 g_a400090[] = // 0000000000400090
	{
	};
// subject_bss.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

word32 g_dw407000 = 0x00; // 0000000000407000
int32 g_dw407004 = 0; // 0000000000407004
Eq_2405 (* g_ptr407008)[] = null; // 0000000000407008
char ** g_ptr407010 = null; // 0000000000407010
int32 g_dw407018 = 0; // 0000000000407018
uint32 g_dw40701C = 0x00; // 000000000040701C
word32 g_dw407020 = 0x00; // 0000000000407020
int32 g_dw407024 = 0; // 0000000000407024
word32 g_dw407040 = 0x00; // 0000000000407040
word32 g_dw407050 = 0x00; // 0000000000407050
word32 g_dw407060 = 0x00; // 0000000000407060
word32 g_dw407064 = 0x00; // 0000000000407064
word32 g_dw407068 = 0x00; // 0000000000407068
word32 g_dw407070 = 0x00; // 0000000000407070
word32 g_dw407080 = 0x00; // 0000000000407080
word32 g_dw407090 = 0x00; // 0000000000407090
Eq_267 g_t4070A0 = null; // 00000000004070A0
word32 g_dw4070A8 = 0x00; // 00000000004070A8
union Eq_729 g_u4070C0 = // 00000000004070C0
	{
		0x00
	};
struct Eq_732 g_t407240 = // 0000000000407240
	{
		
		{
		},
	};
Eq_69 g_t407340 = null; // 0000000000407340
word32 g_dw407350 = 0x00; // 0000000000407350
struct Eq_1053 * g_ptr407358 = null; // 0000000000407358
int32 g_dw407360 = 0; // 0000000000407360
Eq_278 g_t407370 = // 0000000000407370
	{
		null
	};
word32 g_dw407380 = 0x00; // 0000000000407380
CONTEXT g_t4073A0 = // 00000000004073A0
	{
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		
		{
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			
			{
				0x00,
				0x00,
				0x00,
				0x00,
				0x00,
				0x00,
				0x00,
				0x00,
				0x00,
				0x00,
				0x00,
				0x00,
				0x00,
				0x00,
				0x00,
				0x00,
				0x00,
				0x00,
				0x00,
				0x00,
				0x00,
				0x00,
				0x00,
				0x00,
				0x00,
				0x00,
				0x00,
				0x00,
				0x00,
				0x00,
				0x00,
				0x00,
				0x00,
				0x00,
				0x00,
				0x00,
				0x00,
				0x00,
				0x00,
				0x00,
				0x00,
				0x00,
				0x00,
				0x00,
				0x00,
				0x00,
				0x00,
				0x00,
				0x00,
				0x00,
				0x00,
				0x00,
				0x00,
				0x00,
				0x00,
				0x00,
				0x00,
				0x00,
				0x00,
				0x00,
				0x00,
				0x00,
				0x00,
				0x00,
				0x00,
				0x00,
				0x00,
				0x00,
				0x00,
				0x00,
				0x00,
				0x00,
				0x00,
				0x00,
				0x00,
				0x00,
				0x00,
				0x00,
				0x00,
				0x00,
			},
			0x00,
		},
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		
		{
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
			0x00,
		},
	};
word64 g_qw407420 = 0x00; // 0000000000407420
ptr64 g_ptr407438 = 0x00; // 0000000000407438
Eq_2064 g_t407498 = 0x00; // 0000000000407498
word32 g_dw407880 = 0x00; // 0000000000407880
word32 g_dw407884 = 0x00; // 0000000000407884
Eq_2064 g_t407890 = 0x00; // 0000000000407890
word32 g_dw407920 = 0x00; // 0000000000407920
struct _RTL_CRITICAL_SECTION g_t407940 = // 0000000000407940
	{
		null,
		0,
		0,
		null,
		null,
		0x00,
	};
struct Eq_2145 * g_ptr407968 = null; // 0000000000407968
byte * g_ptr407990 = null; // 0000000000407990
word32 g_dw407998 = 0x00; // 0000000000407998
struct Eq_37 * g_ptr4079A0 = null; // 00000000004079A0
word64 g_qw4079A8 = 0x00; // 00000000004079A8
word64 g_qw4079B0 = 0x00; // 00000000004079B0
word32 g_dw4079B8 = 0x00; // 00000000004079B8
uint64 g_qw4079C0 = 0x00; // 00000000004079C0
// subject_data.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

<anonymous> * g_ptr403000 = fn0000000000401600; // 0000000000403000
struct Eq_1947 * g_ptr403030 = &g_t402D30; // 0000000000403030
struct _EXCEPTION_POINTERS g_t403040 = // 0000000000403040
	{
		&g_t407880,
		null,
	};
word32 g_dw403050 = 0x02; // 0000000000403050
word32 g_dw403060 = ~0x00; // 0000000000403060
ui64 g_qw403070 = 0x2B992DDFA232; // 0000000000403070
ui64 g_qw403080 = ~0x2B992DDFA232; // 0000000000403080
// subject_idata.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

word64 g_qw408050 = 0x8440; // 0000000000408050
word64 g_qw408058 = 33880; // 0000000000408058
word64 g_qw408060 = 0x8470; // 0000000000408060
word64 g_qw408068 = 0x8484; // 0000000000408068
word64 g_qw408070 = 33946; // 0000000000408070
word64 g_qw408078 = 0x84B0; // 0000000000408078
word64 g_qw408080 = 0x84C0; // 0000000000408080
word64 g_qw408088 = 34004; // 0000000000408088
word64 g_qw408090 = 34022; // 0000000000408090
word64 g_qw408098 = 34040; // 0000000000408098
word64 g_qw4080A0 = 34066; // 00000000004080A0
word64 g_qw4080A8 = 0x8522; // 00000000004080A8
word64 g_qw4080B0 = 34110; // 00000000004080B0
word64 g_qw4080B8 = 34134; // 00000000004080B8
word64 g_qw4080C0 = 0x8566; // 00000000004080C0
word64 g_qw4080C8 = 0x8580; // 00000000004080C8
word64 g_qw4080D0 = 0x8596; // 00000000004080D0
word64 g_qw4080D8 = 0x85AA; // 00000000004080D8
word64 g_qw4080E0 = 34244; // 00000000004080E0
word64 g_qw4080E8 = 0x85D8; // 00000000004080E8
word64 g_qw4080F0 = 34294; // 00000000004080F0
word64 g_qw4080F8 = 34302; // 00000000004080F8
word64 g_qw408100 = 34322; // 0000000000408100
word64 g_qw408108 = 34336; // 0000000000408108
word64 g_qw408110 = 34364; // 0000000000408110
word64 g_qw408118 = 34382; // 0000000000408118
word64 g_qw408128 = 34398; // 0000000000408128
word64 g_qw408130 = 34422; // 0000000000408130
word64 g_qw408138 = 34436; // 0000000000408138
word64 g_qw408140 = 34452; // 0000000000408140
word64 g_qw408148 = 34464; // 0000000000408148
word64 g_qw408150 = 34478; // 0000000000408150
word64 g_qw408158 = 34494; // 0000000000408158
word64 g_qw408160 = 0x86D0; // 0000000000408160
word64 g_qw408168 = 34532; // 0000000000408168
word64 g_qw408170 = 0x86EE; // 0000000000408170
word64 g_qw408178 = 34556; // 0000000000408178
word64 g_qw408180 = 0x8706; // 0000000000408180
word64 g_qw408188 = 0x8710; // 0000000000408188
word64 g_qw408190 = 34588; // 0000000000408190
word64 g_qw408198 = 0x8724; // 0000000000408198
word64 g_qw4081A0 = 34606; // 00000000004081A0
word64 g_qw4081A8 = 0x8738; // 00000000004081A8
word64 g_qw4081B0 = 0x8740; // 00000000004081B0
word64 g_qw4081B8 = 34634; // 00000000004081B8
word64 g_qw4081C0 = 34642; // 00000000004081C0
word64 g_qw4081C8 = 0x875C; // 00000000004081C8
word64 g_qw4081D0 = 34660; // 00000000004081D0
word64 g_qw4081D8 = 0x876E; // 00000000004081D8
word64 g_qw4081E0 = 0x8778; // 00000000004081E0
word64 g_qw4081E8 = 0x8782; // 00000000004081E8
word64 g_qw4081F0 = 0x878C; // 00000000004081F0
word64 g_qw4081F8 = 0x8796; // 00000000004081F8
word64 g_qw408200 = 0x87A0; // 0000000000408200
word64 g_qw408210 = 34732; // 0000000000408210
word64 g_qw408218 = 0x87C0; // 0000000000408218
word64 g_qw408220 = 0x87DC; // 0000000000408220
word64 g_qw408228 = 0x87F8; // 0000000000408228
word64 g_qw408230 = 0x8804; // 0000000000408230
word64 g_qw408238 = 0x8844; // 0000000000408238
<anonymous> * __imp__DeleteCriticalSection = &g_t8440; // 0000000000408248
<anonymous> * __imp__EnterCriticalSection = &g_t8458; // 0000000000408250
<anonymous> * __imp__GetCurrentProcess = &g_t8470; // 0000000000408258
<anonymous> * __imp__GetCurrentProcessId = &g_t8484; // 0000000000408260
<anonymous> * __imp__GetCurrentThreadId = &g_t849A; // 0000000000408268
<anonymous> * __imp__GetLastError = &g_t84B0; // 0000000000408270
<anonymous> * __imp__GetModuleHandleA = &g_t84C0; // 0000000000408278
<anonymous> * __imp__GetProcAddress = &g_t84D4; // 0000000000408280
<anonymous> * __imp__GetStartupInfoA = &g_t84E6; // 0000000000408288
<anonymous> * __imp__GetSystemTimeAsFileTime = &g_t84F8; // 0000000000408290
<anonymous> * __imp__GetTickCount = &g_t8512; // 0000000000408298
<anonymous> * __imp__InitializeCriticalSection = &g_t8522; // 00000000004082A0
<anonymous> * __imp__LeaveCriticalSection = &g_t853E; // 00000000004082A8
<anonymous> * __imp__LoadLibraryW = &g_t8556; // 00000000004082B0
<anonymous> * __imp__QueryPerformanceCounter = &g_t8566; // 00000000004082B8
<anonymous> * __imp__RtlAddFunctionTable = &g_t8580; // 00000000004082C0
<anonymous> * __imp__RtlCaptureContext = &g_t8596; // 00000000004082C8
<anonymous> * __imp__RtlLookupFunctionEntry = &g_t85AA; // 00000000004082D0
<anonymous> * __imp__RtlVirtualUnwind = &g_t85C4; // 00000000004082D8
<anonymous> * __imp__SetUnhandledExceptionFilter = &g_t85D8; // 00000000004082E0
<anonymous> * __imp__Sleep = &g_t85F6; // 00000000004082E8
<anonymous> * __imp__TerminateProcess = &g_t85FE; // 00000000004082F0
<anonymous> * __imp__TlsGetValue = &g_t8612; // 00000000004082F8
<anonymous> * __imp__UnhandledExceptionFilter = &g_t8620; // 0000000000408300
<anonymous> * __imp__VirtualProtect = &g_t863C; // 0000000000408308
<anonymous> * __imp__VirtualQuery = &g_t864E; // 0000000000408310
<anonymous> * __imp____C_specific_handler = &g_t865E; // 0000000000408320
<anonymous> * __imp____dllonexit = &g_t8676; // 0000000000408328
<anonymous> * __imp____getmainargs = &g_t8684; // 0000000000408330
<anonymous> * __imp____initenv = &g_t8694; // 0000000000408338
<anonymous> * __imp____iob_func = &g_t86A0; // 0000000000408340
<anonymous> * __imp____lconv_init = &g_t86AE; // 0000000000408348
<anonymous> * __imp____set_app_type = &g_t86BE; // 0000000000408350
<anonymous> * __imp____setusermatherr = &g_t86D0; // 0000000000408358
<anonymous> * __imp___acmdln = &g_t86E4; // 0000000000408360
<anonymous> * __imp___amsg_exit = &g_t86EE; // 0000000000408368
<anonymous> * __imp___cexit = &g_t86FC; // 0000000000408370
<anonymous> * __imp___fmode = &g_t8706; // 0000000000408378
<anonymous> * __imp___initterm = &g_t8710; // 0000000000408380
<anonymous> * __imp___lock = &g_t871C; // 0000000000408388
<anonymous> * __imp___onexit = &g_t8724; // 0000000000408390
<anonymous> * __imp___unlock = &g_t872E; // 0000000000408398
<anonymous> * __imp__abort = &g_t8738; // 00000000004083A0
<anonymous> * __imp__calloc = &g_t8740; // 00000000004083A8
<anonymous> * __imp__exit = &g_t874A; // 00000000004083B0
<anonymous> * __imp__fprintf = &g_t8752; // 00000000004083B8
<anonymous> * __imp__free = &g_t875C; // 00000000004083C0
<anonymous> * __imp__fwrite = &g_t8764; // 00000000004083C8
<anonymous> * __imp__malloc = &g_t876E; // 00000000004083D0
<anonymous> * __imp__memcpy = &g_t8778; // 00000000004083D8
<anonymous> * __imp__signal = &g_t8782; // 00000000004083E0
<anonymous> * __imp__strlen = &g_t878C; // 00000000004083E8
<anonymous> * __imp__strncmp = &g_t8796; // 00000000004083F0
<anonymous> * __imp__vfprintf = &g_t87A0; // 00000000004083F8
<anonymous> * __imp___ZNSolsEPFRSoS_E = &g_t87AC; // 0000000000408408
<anonymous> * __imp___ZNSt8ios_base4InitC1Ev = &g_t87C0; // 0000000000408410
<anonymous> * __imp___ZNSt8ios_base4InitD1Ev = &g_t87DC; // 0000000000408418
<anonymous> * __imp___ZSt4cerr = &g_t87F8; // 0000000000408420
<anonymous> * __imp___ZSt4endlIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_ = &g_t8804; // 0000000000408428
<anonymous> * __imp___ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_PKc = &g_t8844; // 0000000000408430
// subject_rdata.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

void g_v404180 = ??void??; // 0000000000404180
word32 g_dw404288 = 0x00; // 0000000000404288
word32 g_dw40428C = 0x00; // 000000000040428C
word32 g_dw404290 = 0x01; // 0000000000404290
// subject_text.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 0000000000401000: void fn0000000000401000()
void fn0000000000401000()
{
}

// 0000000000401010: void fn0000000000401010()
void fn0000000000401010()
{
	uint64 r9_8 = (uint64) g_dw407050;
	g_dw407020 = g_dw407040;
	g_dw407024 = __getmainargs(&g_dw407004, &g_ptr407008, &g_ptr407010, (int32) r9_8);
}

// 0000000000401060: void fn0000000000401060()
void fn0000000000401060()
{
	g_dw407068 = 0x01;
	g_dw407064 = 0x01;
	g_dw407060 = 0x01;
	g_dw407070 = 0x01;
	uint32 eax_49 = 0x00;
	if (g_t400000.u0 == 23117)
	{
		struct Eq_41 * rdx_15 = &g_t400000.u0 + (int64) g_dw40003C;
		if (rdx_15->dw0000 == 0x4550)
		{
			word16 cx_20 = rdx_15->w0018;
			if (cx_20 != 0x010B)
			{
				if (cx_20 == 0x020B && rdx_15->dw0084 > 0x0E)
					eax_49 = (uint32) (int8) (rdx_15->dw00F8 != 0x00);
			}
			else if (rdx_15->dw0074 > 0x0E)
				eax_49 = (uint32) (int8) (rdx_15->dw00E8 != 0x00);
		}
	}
	g_dw40701C = eax_49;
	if (g_dw407080 != 0x00)
		__set_app_type(2);
	else
		__set_app_type(1);
	word64 rax_68 = fn00000000004016A0();
	word32 edx_75 = g_dw407090;
	g_qw4079B0 = rax_68;
	g_qw4079A8 = rax_68;
	*fmode = edx_75;
	fn0000000000401D70();
	if (g_dw403060 != 0x01)
		return;
	fn0000000000401C80(&g_t401C90);
}

// 0000000000401180: Register word32 fn0000000000401180(Register (ptr32 Eq_128) gs)
// Called from:
//      fn00000000004014B0
//      Win32CrtStartup
word32 fn0000000000401180(struct Eq_128 * gs)
{
	Eq_129 tLoc98;
	byte bLoc5C_722 = SLICE(tLoc98, byte, 480);
	word16 wLoc58_725 = SLICE(tLoc98, word16, 512);
	word32 r11d_26 = g_dw407080;
	uint64 rcx_24;
	struct _STARTUPINFOA * rdi_189 = &tLoc98;
	for (rcx_24 = 0x0D; rcx_24 != 0x00; --rcx_24)
	{
		rdi_189->cb.u1 = 0x00;
		++rdi_189;
	}
	if (r11d_26 != 0x00)
		GetStartupInfoA(&tLoc98);
	word64 rbx_40 = gs->ptr0030->qw0008;
	__lock();
	word64 rax_43;
	__cmpxchg<word64>(g_qw4079C0, rbx_40, 0x00, out rax_43);
	uip32 esi_123 = 0x00;
	if (rax_43 != 0x00)
	{
		esi_123 = 0x01;
		if (rbx_40 != rax_43)
		{
			do
			{
				Sleep(1000);
				__lock();
				word64 rax_67;
				__cmpxchg<word64>(g_qw4079C0, rbx_40, 0x00, out rax_67);
				if (rax_67 == 0x00)
				{
					esi_123 = 0x00;
					goto l0000000000401204;
				}
			} while (rbx_40 != rax_67);
			esi_123 = 0x01;
			if (g_dw4079B8 == 0x01)
			{
l0000000000401434:
				_amsg_exit(31);
				if (g_dw4079B8 != 0x01)
					goto l000000000040123A;
				goto l0000000000401450;
			}
l0000000000401213:
			if (g_dw4079B8 != 0x00)
				g_dw407000 = 0x01;
			else
			{
				g_dw4079B8 = 0x01;
				_initterm(&g_t409018, &g_t409030);
			}
			if (g_dw4079B8 != 0x01)
			{
l000000000040123A:
				if (esi_123 == 0x00)
				{
					__lock();
					g_qw4079C0 = 0x00;
				}
				<anonymous> * rax_148 = g_ptr403000;
				if (rax_148 != null)
					rax_148();
				word64 rcx_753;
				word64 rdx_754;
				word64 r9_755;
				fn0000000000401F60(out rcx_753, out rdx_754, out r9_755);
				g_t4070A0 = SetUnhandledExceptionFilter(&g_t401A30);
				fn0000000000401920();
				Eq_275 rax_274 = GetProcAddress(fn0000000000402590(), 0x00404000);
				if (rax_274 != null)
					rax_274();
				fn0000000000402660();
				if (g_dw407080 != 0x00)
				{
					byte * rax_303 = *acmdln;
					ui32 ecx_747 = 0x00;
l00000000004012CC:
					byte cl_315 = (byte) ecx_747;
					ci8 dl_308 = *rax_303;
					if (dl_308 > 0x20)
					{
						ecx_747 = ecx_747 ^ 0x01;
						goto l00000000004012C8;
					}
					if (dl_308 != 0x00)
					{
						if (cl_315 != 0x00)
						{
l00000000004012C8:
							++rax_303;
							goto l00000000004012CC;
						}
						do
						{
							++rax_303;
							ci8 dl_325 = *rax_303;
						} while (dl_325 <= 0x20 && dl_325 != 0x00);
					}
					g_ptr407990 = rax_303;
					g_ptr4079A0 = (struct Eq_37 *) &g_t400000;
					word32 eax_348 = 0x0A;
					if ((bLoc5C_722 & 0x01) != 0x00)
						eax_348 = (word32) wLoc58_725;
					g_dw407998 = eax_348;
				}
				uint64 rdi_354 = (uint64) g_dw407004;
				union Eq_2405 rax_360[] = malloc((word32) rdi_354 + 0x01 << 0x03);
				int32 edi_364 = (word32) rdi_354;
				Eq_312 rax_363 = 0x00;
				union Eq_2405 rsi_368[] = g_ptr407008;
				if (edi_364 > 0x00)
				{
					uint64 rbx_372 = 0x00;
					do
					{
						int64 r12_387 = (int64) ((word32) strlen(rsi_368[rbx_372].u0) + 1);
						void * rax_389 = malloc((size_t) r12_387);
						rax_360[rbx_372].u0 = (char *) rax_389;
						memcpy(rax_389, rsi_368[rbx_372].u0, (size_t) r12_387);
						++rbx_372;
					} while (edi_364 > (word32) rbx_372);
					rax_363 = (int64) edi_364 * 0x08;
				}
				Mem405[rax_360 + rax_363:word64] = 0x00;
				g_ptr407008 = (Eq_2405 (*)[]) rax_360;
				fn0000000000402710();
				*_initenv = (char ***) g_ptr407010;
				uint64 rax_422 = (uint64) fn00000000004014F0();
				int32 eax_432 = (word32) rax_422;
				uint32 r9d_434 = g_dw40701C;
				g_dw407018 = eax_432;
				if (r9d_434 == 0x00)
					exit(eax_432);
				else
				{
					if (g_dw407000 == 0x00)
					{
						cexit();
						rax_422 = (uint64) g_dw407018;
					}
					return (word32) rax_422;
				}
			}
l0000000000401450:
			_initterm(&g_t409000, &g_t409010);
			g_dw4079B8 = 0x02;
			goto l000000000040123A;
		}
	}
l0000000000401204:
	if (g_dw4079B8 == 0x01)
		goto l0000000000401434;
	goto l0000000000401213;
}

// 00000000004014B0: void fn00000000004014B0(Register (ptr32 Eq_128) gs)
void fn00000000004014B0(struct Eq_128 * gs)
{
	g_dw407080 = 0x01;
	fn0000000000402730();
	fn0000000000401180(gs);
}

// 00000000004014D0: Register Eq_191 Win32CrtStartup()
Eq_191 Win32CrtStartup()
{
	struct Eq_128 * gs;
	g_dw407080 = 0x00;
	fn0000000000402730();
	return fn0000000000401180(gs);
}

// 00000000004014F0: Register word32 fn00000000004014F0()
// Called from:
//      fn0000000000401180
word32 fn00000000004014F0()
{
	fn0000000000402710();
	ZNSolsEPFRSoS_E(ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_PKc(&ZSt4cerr, 0x00404020), 0x004015A0);
	return 0x00;
}

// 000000000040152A: void fn000000000040152A()
void fn000000000040152A()
{
	ZNSt8ios_base4InitD1Ev(0x00407030);
}

// 0000000000401545: void fn0000000000401545(Register word32 ecx, Register word32 edx)
// Called from:
//      fn0000000000401581
void fn0000000000401545(word32 ecx, word32 edx)
{
	word64 rcx;
	word32 ecx = (word32) rcx;
	if (ecx == 0x01 && edx == 0xFFFF)
	{
		ZNSt8ios_base4InitC1Ev(0x00407030);
		fn0000000000401760(&g_t40152A);
	}
}

// 0000000000401581: void fn0000000000401581()
void fn0000000000401581()
{
	fn0000000000401545(0x01, 0xFFFF);
}

// 00000000004015D0: void fn00000000004015D0(Register up32 edx)
void fn00000000004015D0(up32 edx)
{
	if (edx != 0x00 && edx != 0x03)
		return;
	fn0000000000402A90(edx);
}

// 0000000000401600: void fn0000000000401600(Register up32 edx)
void fn0000000000401600(up32 edx)
{
	if (g_dw403050 != 0x02)
		g_dw403050 = 0x02;
	if (edx == 0x02)
	{
		word64 * rbx_17 = &g_qw409060;
		if (&g_qw409060 == &g_qw409060)
			return;
		do
		{
			<anonymous> * rax_23 = *rbx_17;
			if (rax_23 != null)
			{
				word64 rcx_73;
				rax_23();
			}
			++rbx_17;
		} while (&g_qw409060 != rbx_17);
	}
	else if (edx == 0x01)
		fn0000000000402A90(edx);
}

// 0000000000401670: void fn0000000000401670()
void fn0000000000401670()
{
}

// 0000000000401680: void fn0000000000401680()
void fn0000000000401680()
{
	_lconv_init();
}

// 0000000000401690: Register word64 fn0000000000401690()
// Called from:
//      fn00000000004016B0
word64 fn0000000000401690()
{
	word64 rcx;
	return rcx;
}

// 00000000004016A0: Register word64 fn00000000004016A0()
// Called from:
//      fn0000000000401060
//      fn00000000004016B0
word64 fn00000000004016A0()
{
	word64 rcx;
	return rcx;
}

// 00000000004016B0: Register Eq_494 fn00000000004016B0(Register Eq_494 rcx)
// Called from:
//      fn0000000000401760
Eq_494 fn00000000004016B0(Eq_494 rcx)
{
	PVFV * ptrLoc18;
	PVFV * ptrLoc10;
	word64 rax_11 = fn0000000000401690();
	ptrLoc18 = rax_11;
	if (rax_11 == ~0x00)
		return _onexit(rcx);
	lock(0x08, 0x08);
	ptrLoc18 = fn0000000000401690();
	ptrLoc10 = fn0000000000401690();
	Eq_494 rax_39 = __dllonexit(rcx, &ptrLoc18, &ptrLoc10);
	g_qw4079A8 = fn00000000004016A0();
	g_qw4079B0 = fn00000000004016A0();
	unlock(0x08, 0x08);
	return rax_39;
}

// 0000000000401760: void fn0000000000401760(Register Eq_494 rcx)
// Called from:
//      fn0000000000401545
//      fn0000000000402710
void fn0000000000401760(Eq_494 rcx)
{
	fn00000000004016B0(rcx);
}

// 0000000000401780: void fn0000000000401780(Register (ptr64 up32) rcx)
void fn0000000000401780(up32 * rcx)
{
	word32 ebx_146;
	up32 eax_10 = *rcx;
	if (eax_10 <= 0xC0000091)
	{
		if (eax_10 >= 0xC000008D)
			goto l0000000000401795;
		if (eax_10 == 0xC0000008)
			return;
		if (eax_10 <= 0xC0000008)
		{
			if (eax_10 == 0x80000002)
				return;
			if (eax_10 != 0xC0000005)
				return;
			void (* rax_100)(int32 rcx) = signal(11, null);
			if (rax_100 != (void (*)(int32)) 0x01)
			{
				if (rax_100 != null)
					rax_100(11);
			}
			else
				signal(11, rax_100);
			return;
		}
		if (eax_10 != 0xC000001D)
		{
			if (eax_10 != 0xC000008C)
				return;
			return;
		}
	}
	else
	{
		if (eax_10 == 0xC0000094)
		{
			ebx_146 = 0x00;
l000000000040179A:
			void (* rax_137)(int32 rcx) = signal(8, null);
			if (rax_137 != (void (*)(int32)) 0x01)
			{
				if (rax_137 != null)
					rax_137(8);
			}
			else
			{
				signal(8, rax_137);
				if (ebx_146 != 0x00)
					fn0000000000402660();
			}
			return;
		}
		if (eax_10 <= 0xC0000094)
		{
			if (eax_10 == 0xC0000092)
				return;
			if (eax_10 != 0xC0000093)
				return;
l0000000000401795:
			ebx_146 = 0x01;
			goto l000000000040179A;
		}
		if (eax_10 == 0xC0000095)
			return;
		if (eax_10 != 0xC0000096)
			return;
	}
	void (* rax_41)(int32 rcx) = signal(4, null);
	if (rax_41 != (void (*)(int32)) 0x01)
	{
		if (rax_41 != null)
			rax_41(4);
	}
	else
		signal(4, rax_41);
}

// 0000000000401920: void fn0000000000401920()
// Called from:
//      fn0000000000401180
void fn0000000000401920()
{
	ui64 rax_20 = fn0000000000402480();
	uint64 rax_30 = (uint64) g_dw4070A8;
	word32 eax_35 = (word32) rax_30;
	word32 rax_32_32_42 = SLICE(rax_30, word32, 32);
	if (rax_20 != 0x00 && eax_35 == 0x00)
	{
		g_dw4070A8 = 0x01;
		word64 rax_43 = fn00000000004022F0(rax_32_32_42, ".pdata");
		if (rax_43 == 0x00)
		{
			uint64 rcx_161 = 0x30;
			union Eq_729 * rdi_158 = &g_u4070C0;
			union Eq_729 * rbp_105 = &g_u4070C0;
			while (true)
			{
				word56 rcx_56_8_180 = SLICE(rcx_161, word56, 8);
				if (rcx_161 == 0x00)
					break;
				rdi_158->u0 = rax_43;
				rdi_158 = (union Eq_729 *) &rdi_158->u1.dw0008;
				--rcx_161;
			}
			struct Eq_732 * rdi_153 = &g_t407240;
			word32 r12d_184 = (word32) (4200320 - rax_20);
			word64 rcx_156;
			for (rcx_156 = SEQ(rcx_56_8_180, 0x20); rcx_156 != 0x00; --rcx_156)
			{
				rdi_153->a0000[0] = rax_43;
				++rdi_153;
			}
			uint64 rdi_110;
			for (rdi_110 = 0x00; rdi_110 != 0x20; ++rdi_110)
			{
				struct Eq_763 * rax_84 = fn0000000000402400(rdi_110);
				if (rax_84 == null)
				{
					if (rdi_110 == 0x00)
						return;
					break;
				}
				(&g_t407240)[rdi_110] = (struct Eq_732) 0x09;
				((char *) &g_t407240.a0000 + 4)[rdi_110 * 0x08] = (char) r12d_184;
				word32 edx_104 = rax_84->dw000C;
				rbp_105->u1.dw0000 = edx_104;
				word32 edx_115 = edx_104 + rax_84->dw0008;
				rbp_105->u1.dw0008 = (word32) &g_t407240 + (word32) rdi_110 * 0x08 - (word32) rax_20;
				rbp_105->u1.dw0004 = edx_115;
				rbp_105 = (union Eq_729 *) ((char *) rbp_105 + 0x0C);
			}
			KERNEL32.dll!RtlAddFunctionTable(rax_20, &g_u4070C0);
		}
	}
}

// 0000000000401A30: void fn0000000000401A30(Register (ptr64 (ptr64 Eq_815)) rcx)
void fn0000000000401A30(struct Eq_815 ** rcx)
{
	struct Eq_815 * rdx_11 = *rcx;
	uint32 eax_15 = rdx_11->dw0000;
	if ((eax_15 & 0x20FFFFFF) == 0x20474343 && (rdx_11->b0004 & 0x01) == 0x00)
		return;
	word32 esi_157;
	if (eax_15 > 0xC0000091)
	{
		if (eax_15 == 0xC0000094)
		{
			esi_157 = 0x00;
			goto l0000000000401AAC;
		}
		if (eax_15 <= 0xC0000094)
		{
			if (eax_15 == 0xC0000092)
				return;
			if (eax_15 != 0xC0000093)
				goto l0000000000401A80;
l0000000000401AA7:
			esi_157 = 0x01;
l0000000000401AAC:
			void (* rax_149)(int32 rcx) = signal(8, null);
			if (rax_149 == (void (*)(int32)) 0x01)
			{
				signal(8, (void (*)(int32)) 0x01);
				if (esi_157 != 0x00)
					fn0000000000402660();
				return;
			}
			if (rax_149 != null)
			{
				rax_149(8);
				return;
			}
			goto l0000000000401A80;
		}
		if (eax_15 == 0xC0000095)
			return;
		if (eax_15 != 0xC0000096)
			goto l0000000000401A80;
	}
	else
	{
		if (eax_15 >= 0xC000008D)
			goto l0000000000401AA7;
		if (eax_15 == 0xC0000008)
			return;
		if (eax_15 <= 0xC0000008)
		{
			if (eax_15 == 0x80000002)
				return;
			if (eax_15 == 0xC0000005)
			{
				void (* rax_48)(int32 rcx) = signal(11, null);
				if (rax_48 == (void (*)(int32)) 0x01)
				{
					signal(11, (void (*)(int32)) 0x01);
					return;
				}
				if (rax_48 != null)
				{
					rax_48(11);
					return;
				}
			}
			goto l0000000000401A80;
		}
		if (eax_15 != 0xC000001D)
		{
			if (eax_15 == 0xC000008C)
				return;
			goto l0000000000401A80;
		}
	}
	void (* rax_97)(int32 rcx) = signal(4, null);
	if (rax_97 == (void (*)(int32)) 0x01)
	{
		signal(4, (void (*)(int32)) 0x01);
		return;
	}
	if (rax_97 != null)
	{
		rax_97(4);
		return;
	}
l0000000000401A80:
	Eq_267 rax_192 = g_t4070A0;
	if (rax_192 == null)
		return;
	rax_192();
}

// 0000000000401C40: void fn0000000000401C40(Register word32 ecx, Register word64 rdx, Register word128 xmm2, Register word128 xmm3, Stack word64 qwArg28)
void fn0000000000401C40(word32 ecx, word64 rdx, word128 xmm2, word128 xmm3, word64 qwArg28)
{
	word64 rcx;
	ptr64 fp;
	word32 ecx = (word32) rcx;
	Eq_69 rax_5 = g_t407340;
	if (rax_5 != null)
		rax_5();
}

// 0000000000401C80: void fn0000000000401C80(Register Eq_69 rcx)
// Called from:
//      fn0000000000401060
void fn0000000000401C80(Eq_69 rcx)
{
	g_t407340 = rcx;
	__setusermatherr(rcx);
}

// 0000000000401C90: void fn0000000000401C90(Register (ptr64 up32) rcx)
void fn0000000000401C90(up32 * rcx)
{
	up32 v21_20 = *rcx;
	if (*rcx > 0x06)
	{
l0000000000401C9F:
	}
	else
	{
		switch (v21_20)
		{
		case 0x00:
			goto l0000000000401C9F;
		case 0x01:
			break;
		case 0x02:
			break;
		case 0x03:
			break;
		case 0x04:
			break;
		case 0x05:
			break;
		case 0x06:
			break;
		}
	}
	fprintf(_iob_func() + 96, "_matherr(): %s in %s(%g, %g)  (retval=%g)\n", 0x00);
}

// 0000000000401D70: void fn0000000000401D70()
// Called from:
//      fn0000000000401060
void fn0000000000401D70()
{
}

// 0000000000401D80: Register word32 fn0000000000401D80(Register ptr64 rcx, Register out (ptr64 Eq_1409) rcxOut, Register out Eq_977 rdxOut, Register out ptr64 r9Out)
// Called from:
//      fn0000000000401DF0
//      fn0000000000401F60
word32 fn0000000000401D80(ptr64 rcx, union Eq_1409 & rcxOut, union Eq_977 & rdxOut, ptr64 & r9Out)
{
	ptr64 fp;
	word64 rax_21 = _iob_func(fp + 0x10);
	fwrite(&g_v404180, 0x01, 0x1B, rax_21 + 96);
	msvcrt.dll!vfprintf(fp + 0x10, _iob_func(0x01, 0x1B, 0x1B, rax_21 + 96, &g_v404180, 0x01) + 96, rcx);
	abort();
	union Eq_1409 * rcx_51;
	Eq_977 rdx_52;
	ptr64 r9_54;
	uint64 rax_50 = (uint64) fn0000000000401DF0(rcx_45, rdx_46, r8_47, out rcx_51, out rdx_52, out r9_54);
	rcxOut = rcx_51;
	rdxOut = rdx_52;
	r9Out = r9_54;
	return (word32) rax_50;
}

// 0000000000401DF0: Register word32 fn0000000000401DF0(Register (ptr64 word32) rcx, Register Eq_1022 rdx, Register uint64 r8, Register out (ptr64 word32) rcxOut, Register out Eq_1022 rdxOut, Register out Eq_1026 r9Out)
// Called from:
//      fn0000000000401D80
//      fn0000000000401F60
word32 fn0000000000401DF0(word32 * rcx, Eq_1022 rdx, uint64 r8, word32 & rcxOut, union Eq_1022 & rdxOut, PDWORD & r9Out)
{
	Eq_1037 tLoc68;
	word32 dwLoc44;
	Eq_1026 r9;
	word64 rax;
	if (r8 != 0x00)
	{
		uint64 r12_41;
		int32 ecx_34 = g_dw407360;
		if (ecx_34 > 0x00)
		{
			struct Eq_1051 * rax_46 = &g_ptr407358->t0008;
			int32 r12d_49 = 0x00;
			do
			{
				word32 * rdx_55 = rax_46->qw0000;
				if (rcx >= rdx_55 && rcx < rdx_55 + (uint64) (rax_46->ptr0010)->dw0008)
					goto l0000000000401EE0;
				r12_41 = (uint64) (r12d_49 + 0x01);
				r12d_49 = (word32) r12_41;
				++rax_46;
			} while (r12d_49 != ecx_34);
		}
		else
			r12_41 = 0x00;
		word32 r12d_115 = (word32) r12_41;
		struct Eq_1090 * rax_79 = fn0000000000402390(rcx, out r9);
		if (rax_79 != null)
		{
			int64 r12_116 = (int64) r12d_115;
			struct Eq_1111 * r13_122 = g_ptr407358 + (r12_116 << 0x03) /64 16;
			r13_122->ptr0010 = rax_79;
			r13_122->dw0000 = 0x00;
			r13_122->qw0008 = fn0000000000402480() + (uint64) rax_79->dw000C;
			struct Eq_1053 * rax_141 = g_ptr407358;
			if (SEQ(SLICE(rax_141, word32, 32), VirtualQuery(rax_141->t0008, &tLoc68, 0x30)) != 0x00)
			{
				if (dwLoc44 != 0x04 && dwLoc44 != 0x40)
				{
					r9 = (Eq_1026) (g_ptr407358 + (r12_116 << 0x03) /64 16);
					VirtualProtect(tLoc68.BaseAddress, tLoc68.Type, 0x40, r9);
				}
				++g_dw407360;
l0000000000401EE0:
				void * rax_220 = memcpy(rcx, rdx, (size_t) r8);
				rcxOut = rcx;
				rdxOut = rdx;
				r9Out = r9;
				return (word32) rax_220;
			}
		}
		else
		{
			word64 rcx_327;
			word64 rdx_328;
			word64 r9_329;
			fn0000000000401D80(0x004041A0, out rcx_327, out rdx_328, out r9_329);
		}
		word64 rcx_330;
		word64 rdx_331;
		word64 r9_332;
		fn0000000000401D80(0x004041C0, out rcx_330, out rdx_331, out r9_332);
		word32 * rcx_170;
		Eq_1022 rdx_171;
		Eq_1026 r9_173;
		uint64 rax_172 = (uint64) fn0000000000401F60(out rcx_170, out rdx_171, out r9_173);
		rcxOut = rcx_170;
		rdxOut = rdx_171;
		r9Out = r9_173;
		return (word32) rax_172;
	}
	else
	{
		rcxOut = rcx;
		rdxOut = rdx;
		r9Out = r9;
		return (word32) rax;
	}
}

// 0000000000401F60: Register word32 fn0000000000401F60(Register out Eq_258 rcxOut, Register out Eq_259 rdxOut, Register out (ptr64 Eq_260) r9Out)
// Called from:
//      fn0000000000401180
//      fn0000000000401DF0
word32 fn0000000000401F60(union Eq_258 & rcxOut, union Eq_259 & rdxOut, DWORD & r9Out)
{
	ptr64 fp;
	Eq_1199 tLoc68;
	Eq_191 tLoc2C;
	DWORD * r9;
	struct Eq_1202 * rax;
	Eq_258 rcx;
	Eq_259 rdx;
	if (g_dw407350 != 0x00)
	{
l0000000000401F79:
		rcxOut = rcx;
		rdxOut = rdx;
		r9Out = r9;
		return (word32) rax;
	}
	g_dw407350 = 0x01;
	ui64 rax_39 = (int64) fn00000000004023D0(out rcx, out rdx) * 0x18 + 30;
	fn0000000000402B30(rax_39 & ~0x0F);
	g_dw407360 = 0x00;
	g_ptr407358 = fp - 0x88 - (rax_39 & ~0x0F) + 32;
	Eq_1239 rbx_307 = 0x00404288;
	rax = 0x004042A0 - &g_dw404288;
	if (rax <= (struct Eq_1202 *) 0x07)
		goto l0000000000401F79;
	if (rax > (struct Eq_1202 *) 11)
	{
		if (g_dw404288 != 0x00 || g_dw40428C != 0x00)
		{
l0000000000402001:
			if (rbx_307 >= (struct Eq_2411 *) 0x004042A0)
				goto l0000000000401F79;
			do
			{
				word32 * rcx_321 = &g_t400000.u0 + (uint64) (rbx_307.u0)->dw0004;
				tLoc2C = (Eq_191) (*rcx_321 + (rbx_307.u0)->dw0000);
				&rbx_307.u0->dw0000 = rbx_307.u0 + 1;
				word64 rcx_714;
				rax = (uint64) fn0000000000401DF0(rcx_321, &tLoc2C, 0x04, out rcx_714, out rdx, out r9);
			} while (rbx_307 < (struct Eq_2411 *) 0x004042A0);
			goto l0000000000402036;
		}
		if (g_dw404290 != 0x00)
		{
l00000000004020E9:
			rdx.u0 = (uint64) rbx_307.u0[1];
			if ((word32) rdx != 0x01)
			{
l0000000000402257:
				struct Eq_37 * rcx_427;
				DWORD * r9_430;
				word64 rdx_718;
				fn0000000000401D80(4211192, out rcx_427, out rdx_718, out r9_430);
				Eq_258 rcx_434;
				Eq_259 rdx_435;
				uint64 rax_433 = (uint64) fn0000000000402270(rcx_427, out rcx_434, out rdx_435);
				rcxOut = rcx_434;
				rdxOut = rdx_435;
				r9Out = r9_430;
				return (word32) rax_433;
			}
			Eq_1239 rbx_105 = &rbx_307.u0->dw0008 + 1;
			if (rbx_105 >= (struct Eq_2411 *) 0x004042A0)
				goto l0000000000401F79;
			do
			{
				uint64 r8_131;
				struct Eq_1202 * rax_122 = (uint64) rbx_105.u1->b0008;
				rdx.u0 = &g_t400000.u0 + (uint64) (rbx_105.u0)->dw0000;
				up32 eax_126 = (word32) rax_122;
				union Eq_1409 * rcx_125 = &g_t400000.u0 + (uint64) (rbx_105.u0)->dw0004;
				word64 r9_128 = *rdx.u0;
				if (eax_126 != 0x10)
				{
					if (eax_126 <= 0x10)
					{
						if (eax_126 != 0x08)
							goto l0000000000402139;
						r8_131 = (uint64) rcx_125->u0;
						if (((byte) r8_131 & 0x80) != 0x00)
							goto l00000000004021CB;
						goto l00000000004021B5;
					}
					while (true)
					{
						word32 eax_177 = (word32) rax_122;
						if (eax_177 == 0x20)
							break;
						if (eax_177 == 0x40)
							goto l0000000000402169;
l0000000000402139:
						rax_122 = (uint64) fn0000000000401D80(0x00404230, out rcx_125, out rdx, out r9_128);
					}
					r8_131 = (uint64) rcx_125->u2;
					if (((word32) r8_131 & 0x80000000) != 0x00)
						goto l00000000004021F5;
					goto l00000000004021B5;
				}
				r8_131 = (uint64) rcx_125->u1;
				if (((word32) r8_131 & 0x8000) != 0x00)
				{
l00000000004021A4:
					word32 * rcx_227;
					rax = (uint64) fn0000000000401DF0(rcx_227, fp - 56, 0x02, out rcx_227, out rdx, out r9);
					goto l0000000000402178;
				}
l00000000004021B5:
				up32 eax_197 = (word32) rax_122;
				r9 = r9_128 + (r8_131 - rdx);
				if (eax_197 == 0x10)
					goto l00000000004021A4;
				if (eax_197 <= 0x10)
				{
					rax = rax_122;
					if (eax_197 == 0x08)
					{
l00000000004021CB:
						word32 * rcx_251;
						rax = (uint64) fn0000000000401DF0(rcx_251, fp - 56, 0x01, out rcx_251, out rdx, out r9);
					}
				}
				else if (eax_197 != 0x20)
				{
					rax = rax_122;
					if (eax_197 == 0x40)
					{
l0000000000402169:
						word32 * rcx_296;
						rax = (uint64) fn0000000000401DF0(rcx_296, fp - 56, 0x08, out rcx_296, out rdx, out r9);
					}
				}
				else
				{
l00000000004021F5:
					word32 * rcx_273;
					rax = (uint64) fn0000000000401DF0(rcx_273, fp - 56, 0x04, out rcx_273, out rdx, out r9);
				}
l0000000000402178:
				&rbx_105.u0->dw0000 = (word64) rbx_105 + 0x0C;
			} while (rbx_105 < (struct Eq_2411 *) 0x004042A0);
l0000000000402036:
			rcx.u0 = (uint64) g_dw407360;
			if ((word32) rcx > 0x00)
			{
				Eq_1301 rbx_359 = 0x00;
				uint64 rsi_361 = 0x00;
				do
				{
					rax = rbx_359 + Mem344[0x0000000000407358<p64>:word64];
					rdx.u0 = (uint64) rax->dw0000;
					word32 esi_448 = (word32) rsi_361;
					word32 rax_32_32_385 = SLICE(rax, word32, 32);
					if ((word32) rdx != 0x00)
					{
						if (SEQ(rax_32_32_385, VirtualQuery(rax->t0008, &tLoc68, 0x30)) == 0x00)
						{
							word64 r9_717;
							word64 rdx_716;
							word64 rcx_715;
							fn0000000000401D80(0x004041C0, out rcx_715, out rdx_716, out r9_717);
							goto l0000000000402257;
						}
						struct Eq_1053 * rax_440 = g_ptr407358;
						rdx.u0 = tLoc68.Type;
						rcx.u0 = tLoc68.BaseAddress;
						r9 = &tLoc2C;
						rax = SEQ(SLICE(rax_440, word32, 32), VirtualProtect(rcx, (SIZE_T) rdx, Mem344[rax_440 + rbx_359:word32], &tLoc2C));
					}
					rsi_361 = (uint64) (esi_448 + 0x01);
					rbx_359 = (word64) rbx_359 + 24;
				} while ((word32) rsi_361 < g_dw407360);
			}
			goto l0000000000401F79;
		}
		&rbx_307.u0->dw0000 = 0x00404294;
	}
	r9 = (uint64) rbx_307.u0->dw0000;
	if ((word32) r9 == 0x00 && (rbx_307.u0)->dw0004 == 0x00)
		goto l00000000004020E9;
	goto l0000000000402001;
}

// 0000000000402270: Register word32 fn0000000000402270(Register (ptr64 Eq_37) rcx, Register out (ptr64 Eq_37) rcxOut, Register out Eq_1379 rdxOut)
// Called from:
//      fn0000000000401F60
//      fn00000000004022F0
//      fn0000000000402390
//      fn00000000004023D0
//      fn0000000000402400
//      fn0000000000402480
//      fn00000000004024B0
//      fn0000000000402500
word32 fn0000000000402270(struct Eq_37 * rcx, struct Eq_37 & rcxOut, union Eq_1379 & rdxOut)
{
	Eq_1379 rdx;
	if (rcx->t0000.u0 == 23117)
	{
		rdx.u0 = (int64) rcx->dw003C;
		rcx += rdx;
		if (rcx->t0000.u1 == 0x4550)
		{
			uint64 rax_31 = (uint64) (int8) (rcx->w0018 == 0x020B);
			rcxOut = rcx;
			rdxOut = rdx;
			return (word32) rax_31;
		}
	}
	rcxOut = rcx;
	rdxOut = rdx;
	return 0x00;
}

// 00000000004022A0: Register (ptr64 Eq_1562) fn00000000004022A0(Register (ptr64 Eq_37) rcx, Register uint64 rdx, Register out (ptr64 Eq_1562) r9Out)
// Called from:
//      fn0000000000402390
//      fn00000000004024B0
//      fn0000000000402500
struct Eq_1562 * fn00000000004022A0(struct Eq_37 * rcx, uint64 rdx, struct Eq_1562 & r9Out)
{
	struct Eq_1566 * rcx_6 = rcx + (int64) rcx->dw003C /64 64;
	struct Eq_1562 * r9_12 = (uint64) rcx_6->w0014;
	struct Eq_1562 * rax_25 = null;
	word32 r8d_13 = (word32) rcx_6->w0006;
	word16 r9w_18 = (word16) r9_12;
	if (r8d_13 != 0x00)
	{
		rax_25 = (struct Eq_1562 *) (&rcx_6->w0014 + 2 + (uint64) r9w_18 /64 22);
		r9_12 = rax_25 + 40 + CONVERT(r8d_13 - 0x01, word32, uint64) * 0x28;
		do
		{
			word32 ecx_32 = rax_25->dw000C;
			if ((uint64) ecx_32 <= rdx && rdx < (uint64) (ecx_32 + rax_25->dw0008))
				goto l00000000004022EE;
			rax_25 += 0x28;
		} while (rax_25 != r9_12);
		rax_25 = null;
	}
l00000000004022EE:
	r9Out = r9_12;
	return rax_25;
}

// 00000000004022F0: Register (ptr64 char) fn00000000004022F0(Register word32 rax_32_32, Register (ptr64 char) rcx)
// Called from:
//      fn0000000000401920
char * fn00000000004022F0(word32 rax_32_32, char * rcx)
{
	char * rbx_14 = null;
	if (SEQ(rax_32_32, strlen(rcx)) > 0x08)
		return rbx_14;
	word64 rcx_137;
	word64 rdx_138;
	if (fn0000000000402270(&g_t400000, out rcx_137, out rdx_138) == 0x00)
		return rbx_14;
	struct Eq_1634 * rax_37 = &g_t400000.u0 + (int64) g_dw40003C;
	word32 edx_42 = (word32) rax_37->w0006;
	word16 cx_47 = rax_37->w0014;
	if (edx_42 == 0x00)
		return rbx_14;
	rbx_14 = (char *) (&rax_37->w0014 + 2 + (uint64) cx_47 /64 22);
	word64 rdi_56 = rbx_14 + 40 + CONVERT(edx_42 - 0x01, word32, uint64) * 0x28;
	do
	{
		if (strncmp(rbx_14, rcx, 0x08) == 0x00)
			return rbx_14;
		rbx_14 += 0x28;
	} while (rbx_14 != rdi_56);
	return null;
}

// 0000000000402390: Register uint64 fn0000000000402390(Register (ptr64 word32) rcx, Register out ptr64 r9Out)
// Called from:
//      fn0000000000401DF0
uint64 fn0000000000402390(word32 * rcx, ptr64 & r9Out)
{
	ptr64 r9;
	word64 rcx_66;
	word64 rdx_67;
	if (fn0000000000402270(&g_t400000, out rcx_66, out rdx_67) == 0x00)
	{
		r9Out = r9;
		return 0x00;
	}
	else
	{
		uint64 rdx_31 = rcx - &g_t400000;
		ptr64 r9_37;
		uint64 rax_38 = fn00000000004022A0(&g_t400000, rdx_31, out r9_37);
		r9Out = r9_37;
		return rax_38;
	}
}

// 00000000004023D0: Register word32 fn00000000004023D0(Register out ptr64 rcxOut, Register out Eq_1215 rdxOut)
// Called from:
//      fn0000000000401F60
word32 fn00000000004023D0(ptr64 & rcxOut, union Eq_1215 & rdxOut)
{
	Eq_1215 rdx_24 = 0x00;
	ptr64 rcx_7;
	word64 rdx_48;
	if (fn0000000000402270(&g_t400000, out rcx_7, out rdx_48) != 0x00)
		rdx_24.u0 = (uint64) g_a400006[(int64) g_dw40003C];
	rcxOut = rcx_7;
	rdxOut = rdx_24;
	return (word32) rdx_24;
}

// 0000000000402400: Register (ptr64 Eq_1712) fn0000000000402400(Register uint64 rcx)
// Called from:
//      fn0000000000401920
struct Eq_1712 * fn0000000000402400(uint64 rcx)
{
	uint64 rbx_53 = rcx;
	struct Eq_1712 * rdx_19 = null;
	word64 rcx_105;
	word64 rdx_106;
	if (fn0000000000402270(&g_t400000, out rcx_105, out rdx_106) != 0x00)
	{
		struct Eq_1724 * rax_27 = &g_t400000.u0 + (int64) g_dw40003C;
		word32 ecx_32 = (word32) rax_27->w0006;
		word16 r8w_37 = rax_27->w0014;
		if (ecx_32 != 0x00)
		{
			rdx_19 = (struct Eq_1712 *) (&rax_27->w0014 + 2 + (uint64) r8w_37 /64 22);
			word64 rax_46 = rdx_19 + 40 + CONVERT(ecx_32 - 0x01, word32, uint64) * 0x28;
			do
			{
				if ((rdx_19->b0027 & 0x20) != 0x00)
				{
					if (rbx_53 == 0x00)
						return rdx_19;
					--rbx_53;
				}
				rdx_19 += 0x28;
			} while (rdx_19 != rax_46);
			rdx_19 = null;
		}
	}
	return rdx_19;
}

// 0000000000402480: Register (ptr64 Eq_37) fn0000000000402480()
// Called from:
//      fn0000000000401920
//      fn0000000000401DF0
struct Eq_37 * fn0000000000402480()
{
	struct Eq_37 * rdx_14 = null;
	word64 rdx_35;
	word64 rcx_34;
	if (fn0000000000402270(&g_t400000, out rcx_34, out rdx_35) != 0x00)
		rdx_14 = (struct Eq_37 *) &g_t400000;
	return rdx_14;
}

// 00000000004024B0: void fn00000000004024B0(Register ui64 rcx)
void fn00000000004024B0(ui64 rcx)
{
	word64 rdx_113;
	word64 rcx_112;
	if (fn0000000000402270(&g_t400000, out rcx_112, out rdx_113) == 0x00)
		return;
	word64 r9_114;
	if (fn00000000004022A0(&g_t400000, rcx - &g_t400000, out r9_114) == 0x00)
		;
}

// 0000000000402500: Register uint64 fn0000000000402500(Register int32 ecx, Register out Eq_1796 ebxOut)
// Called from:
//      fn0000000000402590
uint64 fn0000000000402500(int32 ecx, union Eq_1796 & ebxOut)
{
	uint64 rbp_113 = 0x00;
	int32 ebx_130 = ecx;
	word64 rdx_195;
	word64 rcx_194;
	if (fn0000000000402270(&g_t400000, out rcx_194, out rdx_195) != 0x00)
	{
		uint64 rdi_41 = (uint64) g_a400090[(int64) g_dw40003C];
		if ((word32) rdi_41 != 0x00)
		{
			word64 r9_196;
			if (fn00000000004022A0(&g_t400000, rdi_41, out r9_196) != 0x00)
			{
				struct Eq_1825 * rdi_106 = &g_t400000.u0 + rdi_41;
				if (rdi_106 != null)
				{
					while (rdi_106->dw0004 != 0x00 || rdi_106->dw000C != 0x00)
					{
						if (ebx_130 <= 0x00)
						{
							rbp_113 = &g_t400000.u0 + (uint64) rdi_106->dw000C;
							goto l000000000040256F;
						}
						--ebx_130;
						++rdi_106;
					}
					ebxOut.u0 = <invalid>;
					return 0x00;
				}
			}
		}
	}
l000000000040256F:
	ebxOut.u0 = <invalid>;
	return rbp_113;
}

// 0000000000402590: Register Eq_278 fn0000000000402590()
// Called from:
//      fn0000000000401180
Eq_278 fn0000000000402590()
{
	Eq_278 rax_102 = g_t407370.u0;
	if (rax_102 == 0x00)
	{
		uint64 rcx_119 = 0x00;
		while (true)
		{
			word64 rbx_28 = <invalid>;
			word32 ebx_206;
			Eq_279 rax_22 = fn0000000000402500((word32) rcx_119, out ebx_206);
			word32 ebx_112 = (word32) rbx_28;
			if (rax_22 == 0x00)
				break;
			byte dl_44 = rax_22.u0->b0000;
			if (dl_44 == 77 || dl_44 == 0x6D)
			{
				byte dl_53 = rax_22.u0->b0001;
				if (dl_53 == 0x53 || dl_53 == 115)
				{
					byte dl_62 = rax_22.u0->b0002;
					if (dl_62 == 0x56 || dl_62 == 118)
					{
						byte dl_71 = rax_22.u0->b0003;
						if (dl_71 == 0x43 || dl_71 == 99)
						{
							byte dl_80 = rax_22.u0->b0004;
							if (dl_80 == 0x52 || dl_80 == 114)
							{
								uint64 rdx_88 = (uint64) rax_22.u0->b0005;
								byte dl_89 = (byte) rdx_88;
								word32 edx_94 = (word32) rdx_88;
								if (dl_89 == 0x54 || (dl_89 == 116 || (byte) edx_94 <= 0x39))
								{
									rax_102 = GetModuleHandleA(rax_22);
									g_t407370.u0 = (HMODULE) rax_102;
									if (rax_102 == 0x00)
										break;
									return rax_102;
								}
							}
						}
					}
				}
			}
			rcx_119 = (uint64) ebx_112;
		}
		rax_102 = LoadLibraryW("m\0s\0v\0c\0r\0t\0.\0d\0l\0l\0\0");
		g_t407370.u0 = (HMODULE) rax_102;
	}
	return rax_102;
}

// 0000000000402660: void fn0000000000402660()
// Called from:
//      fn0000000000401180
//      fn0000000000401780
//      fn0000000000401A30
void fn0000000000402660()
{
	__fninit();
}

// 0000000000402670: void fn0000000000402670()
void fn0000000000402670()
{
	<anonymous> * rax_11 = g_ptr403030->qw0000;
	while (rax_11 != null)
	{
		rax_11();
		struct Eq_1947 * rax_17 = g_ptr403030;
		rax_11 = rax_17->ptr0008;
		g_ptr403030 = (struct Eq_1947 *) &rax_17->ptr0008;
	}
}

// 00000000004026B0: void fn00000000004026B0()
// Called from:
//      fn0000000000402710
void fn00000000004026B0()
{
	Eq_1963 eax_11 = g_t402D10.dw0000;
	Eq_1963 ebx_35 = eax_11;
	if (eax_11 == ~0x00)
	{
		uint64 rbx_17 = 0x00;
		while (true)
		{
			word32 eax_26 = (word32) rbx_17 + 0x01;
			ebx_35 = (word32) rbx_17;
			if ((&g_t402D10)[(uint64) eax_26] == 0x00)
				break;
			rbx_17 = (uint64) eax_26;
		}
	}
	if (ebx_35 == 0x00)
		fn0000000000401760(&g_t402670);
}

// 0000000000402710: void fn0000000000402710()
// Called from:
//      fn0000000000401180
//      fn00000000004014F0
void fn0000000000402710()
{
	if (g_dw407380 != 0x00)
		return;
	g_dw407380 = 0x01;
	fn00000000004026B0();
}

// 0000000000402730: void fn0000000000402730()
// Called from:
//      fn00000000004014B0
//      Win32CrtStartup
void fn0000000000402730()
{
	Eq_1997 tLoc48;
	Eq_1998 tLoc38;
	ui64 rbx_19 = g_qw403070;
	tLoc48.dwLowDateTime = (DWORD) 0x00;
	if (rbx_19 == 0x2B992DDFA232)
	{
		GetSystemTimeAsFileTime(&tLoc48);
		Eq_2014 r12_25 = tLoc48.dwLowDateTime;
		uint64 rbp_28 = (uint64) GetCurrentProcessId();
		uint64 rdi_31 = (uint64) GetCurrentThreadId();
		uint64 rsi_35 = (uint64) GetTickCount();
		QueryPerformanceCounter(&tLoc38);
		ui64 r12_41 = r12_25 ^ tLoc38.QuadPart ^ rbp_28 ^ rdi_31 ^ rsi_35;
		ui64 r12_42 = r12_41 & 0xFFFFFFFFFFFF;
		ui64 rax_45 = ~(r12_41 & 0xFFFFFFFFFFFF);
		if ((r12_41 & 0xFFFFFFFFFFFF) == rbx_19)
		{
			rax_45 = 18446696136809930188;
			r12_42 = 0x2B992DDFA233;
		}
		g_qw403070 = r12_42;
		g_qw403080 = rax_45;
	}
	else
		g_qw403080 = ~rbx_19;
}

// 0000000000402800: void fn0000000000402800(Register word64 rcx, Stack Eq_2064 qwArg00)
void fn0000000000402800(word64 rcx, Eq_2064 qwArg00)
{
	ptr64 fp;
	Eq_2064 tLoc30;
	RtlCaptureContext(&g_t4073A0);
	Eq_2064 rbx_17 = g_t407498;
	if (RtlLookupFunctionEntry(rbx_17, &tLoc30, null) != null)
	{
		KERNEL32.dll!RtlVirtualUnwind(0x00, 0x00, rbx_17, 0x00, tLoc30, &g_t4073A0, fp - 32, fp - 40, 0x00);
l0000000000402873:
		Eq_2064 rax_50 = g_t407498;
		g_qw407420 = rcx;
		g_dw407880 = 0xC0000409;
		g_dw407884 = 0x01;
		g_t407890 = rax_50;
		word32 rax_32_32_73 = SLICE(SetUnhandledExceptionFilter(null), word32, 32);
		UnhandledExceptionFilter(&g_t403040);
		TerminateProcess(SEQ(rax_32_32_73, GetCurrentProcess()), 0xC0000409);
		abort();
	}
	g_t407498 = qwArg00;
	g_ptr407438 = fp;
	goto l0000000000402873;
}

// 0000000000402900: void fn0000000000402900()
// Called from:
//      fn0000000000402A90
void fn0000000000402900()
{
	EnterCriticalSection(&g_t407940);
	struct Eq_2145 * rbx_17;
	for (rbx_17 = g_ptr407968; rbx_17 != null; rbx_17 = rbx_17->ptr0010)
	{
		Eq_258 rax_28 = TlsGetValue(rbx_17->t0000);
		if (GetLastError() == 0x00 && rax_28 != 0x00)
			rbx_17->ptr0008();
	}
	LeaveCriticalSection(&g_t407940);
}

// 0000000000402970: void fn0000000000402970(Register Eq_191 ecx, Register (ptr64 code) rdx)
void fn0000000000402970(Eq_191 ecx, <anonymous> * rdx)
{
	word64 rcx;
	Eq_191 ecx = (word32) rcx;
	if (g_dw407920 == 0x00)
		return;
	struct Eq_2145 * rax_34 = calloc(0x01, 0x18);
	if (rax_34 == null)
		return;
	rax_34->t0000 = ecx;
	rax_34->ptr0008 = rdx;
	EnterCriticalSection(&g_t407940);
	struct Eq_2145 * rax_46 = g_ptr407968;
	g_ptr407968 = rax_34;
	rax_34->ptr0010 = rax_46;
	LeaveCriticalSection(&g_t407940);
}

// 00000000004029F0: void fn00000000004029F0(Register Eq_191 ecx)
void fn00000000004029F0(Eq_191 ecx)
{
	word64 rcx;
	Eq_191 ecx = (word32) rcx;
	if (g_dw407920 == 0x00)
		return;
	EnterCriticalSection(&g_t407940);
	struct Eq_2145 * rax_18 = g_ptr407968;
	if (rax_18 != null)
	{
		struct Eq_2145 * rcx_31;
		if (rax_18->t0000 == ecx)
		{
			g_ptr407968 = rax_18->ptr0010;
			rcx_31 = rax_18;
l0000000000402A68:
			free(rcx_31);
			LeaveCriticalSection(&g_t407940);
			return;
		}
		while (true)
		{
			rcx_31 = rax_18->ptr0010;
			if (rcx_31 == null)
				break;
			if (rcx_31->t0000 == ecx)
			{
				rax_18->ptr0010 = rcx_31->ptr0010;
				goto l0000000000402A68;
			}
			rax_18 = rcx_31;
		}
	}
	LeaveCriticalSection(&g_t407940);
}

// 0000000000402A90: void fn0000000000402A90(Register up32 edx)
// Called from:
//      fn00000000004015D0
//      fn0000000000401600
void fn0000000000402A90(up32 edx)
{
	if (edx == 0x01)
	{
		if (g_dw407920 == 0x00)
			InitializeCriticalSection(&g_t407940);
		g_dw407920 = 0x01;
	}
	else if (edx >= 0x01)
	{
		if (edx == 0x03 && g_dw407920 != 0x00)
			fn0000000000402900();
	}
	else
	{
		if (g_dw407920 != 0x00)
			fn0000000000402900();
		if (g_dw407920 == 0x01)
		{
			g_dw407920 = 0x00;
			DeleteCriticalSection(&g_t407940);
		}
	}
}

// 0000000000402B30: void fn0000000000402B30(Register uint64 rax)
// Called from:
//      fn0000000000401F60
void fn0000000000402B30(uint64 rax)
{
	ptr64 fp;
	struct Eq_2300 * rcx_10 = fp + 8;
	if (rax >= 0x1000)
	{
		do
		{
			rcx_10 -= 0x1000;
			rcx_10->qw0000 = rcx_10->qw0000;
			rax -= 0x1000;
		} while (rax > 0x1000);
	}
	word64 * rcx_24 = rcx_10 - rax;
	*rcx_24 = *rcx_24;
}

Eq_1963 g_t402D10 = // 0000000000402D10
	{
		~0x00,
	};
Eq_1947 g_t402D30 = // 0000000000402D30
	{
		0x00,
		null,
	};
