// subject_PE_header.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

Eq_545 g_t400000 = // 00400000
	{
		23117,
		0xF0,
	};
// subject_data.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

ui32 g_dw406020 = 0xBB40E64E; // 00406020
ui32 g_dw406024 = 1153374641; // 00406024
word32 g_dw406168 = 0x00; // 00406168
Eq_88 g_t40616C = // 0040616C
	{
		0x00
	};
word32 g_dw406170 = 0x00; // 00406170
word32 g_dw406174 = 0x00; // 00406174
Eq_88 g_t406180 = // 00406180
	{
		0x00
	};
word32 g_dw406184 = 0x00; // 00406184
word32 g_dw4064BC = 0x00; // 004064BC
Eq_174 g_t4064CC = 0; // 004064CC
word32 g_dw4064E4 = 0x00; // 004064E4
<anonymous> * g_ptr4064E8 = null; // 004064E8
// subject_idata.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

word32 g_dw40703C = 0x757A; // 0040703C
word32 g_dw407040 = 30052; // 00407040
word32 g_dw407044 = 30036; // 00407044
word32 g_dw407048 = 30010; // 00407048
word32 g_dw40704C = 29994; // 0040704C
word32 g_dw407050 = 29974; // 00407050
word32 g_dw407054 = 29944; // 00407054
word32 g_dw407058 = 29916; // 00407058
word32 g_dw40705C = 29896; // 0040705C
word32 g_dw407060 = 0x74B4; // 00407060
word32 g_dw407064 = 0x74A4; // 00407064
word32 g_dw407068 = 29838; // 00407068
word32 g_dw40706C = 0x7470; // 0040706C
word32 g_dw407070 = 29800; // 00407070
word32 g_dw407074 = 29778; // 00407074
word32 g_dw407078 = 0x7590; // 00407078
word32 g_dw4070B4 = 0x738C; // 004070B4
word32 g_dw4070B8 = 29602; // 004070B8
word32 g_dw4070BC = 29622; // 004070BC
word32 g_dw4070C0 = 29676; // 004070C0
word32 g_dw4070C4 = 0x737A; // 004070C4
word32 g_dw4070C8 = 0x7404; // 004070C8
word32 g_dw4070CC = 0x740C; // 004070CC
word32 g_dw4070D0 = 0x7416; // 004070D0
word32 g_dw4070D4 = 0x7430; // 004070D4
word32 g_dw4070D8 = 0x7442; // 004070D8
word32 g_dw4070DC = 0x7370; // 004070DC
word32 g_dw4070E0 = 0x7364; // 004070E0
word32 g_dw4070E4 = 0x7350; // 004070E4
word32 g_dw4070E8 = 0x733A; // 004070E8
word32 g_dw4070EC = 29484; // 004070EC
word32 g_dw4070F0 = 0x7320; // 004070F0
word32 g_dw4070F4 = 0x7314; // 004070F4
word32 g_dw4070F8 = 0x730C; // 004070F8
word32 g_dw4070FC = 0x72FE; // 004070FC
word32 g_dw407100 = 0x72F6; // 00407100
word32 g_dw407104 = 29420; // 00407104
word32 g_dw407108 = 29404; // 00407108
word32 g_dw40710C = 29390; // 0040710C
word32 g_dw407110 = 0x72BE; // 00407110
word32 g_dw407114 = 29338; // 00407114
word32 g_dw407118 = 29686; // 00407118
word32 g_dw40711C = 0x7284; // 0040711C
<anonymous> * __imp__GetCurrentProcessId = &g_t757A; // 00407160
<anonymous> * __imp__GetCurrentThreadId = &g_t7564; // 00407164
<anonymous> * __imp__GetTickCount = &g_t7554; // 00407168
<anonymous> * __imp__QueryPerformanceCounter = &g_t753A; // 0040716C
<anonymous> * __imp__DecodePointer = &g_t752A; // 00407170
<anonymous> * __imp__IsDebuggerPresent = &g_t7516; // 00407174
<anonymous> * __imp__SetUnhandledExceptionFilter = &g_t74F8; // 00407178
<anonymous> * __imp__UnhandledExceptionFilter = &g_t74DC; // 0040717C
<anonymous> * __imp__GetCurrentProcess = &g_t74C8; // 00407180
<anonymous> * __imp__TerminateProcess = &g_t74B4; // 00407184
<anonymous> * __imp__EncodePointer = &g_t74A4; // 00407188
<anonymous> * __imp__HeapSetInformation = &g_t748E; // 0040718C
<anonymous> * __imp__InterlockedCompareExchange = &g_t7470; // 00407190
<anonymous> * __imp__Sleep = &g_t7468; // 00407194
<anonymous> * __imp__InterlockedExchange = &g_t7452; // 00407198
<anonymous> * __imp__GetSystemTimeAsFileTime = &g_t7590; // 0040719C
<anonymous> * __imp___crt_debugger_hook = &g_t738C; // 004071D8
<anonymous> * __imp__?terminate@@YAXXZ = &g_t73A2; // 004071DC
<anonymous> * __imp__?_type_info_dtor_internal_method@type_info@@QAEXXZ = &g_t73B6; // 004071E0
<anonymous> * __imp___unlock = &g_t73EC; // 004071E4
<anonymous> * __imp____set_app_type = &g_t737A; // 004071E8
<anonymous> * __imp___lock = &g_t7404; // 004071EC
<anonymous> * __imp___onexit = &g_t740C; // 004071F0
<anonymous> * __imp___except_handler4_common = &g_t7416; // 004071F4
<anonymous> * __imp___invoke_watson = &g_t7430; // 004071F8
<anonymous> * __imp___controlfp_s = &g_t7442; // 004071FC
<anonymous> * __imp___fmode = &g_t7370; // 00407200
<anonymous> * __imp___commode = &g_t7364; // 00407204
<anonymous> * __imp____setusermatherr = &g_t7350; // 00407208
<anonymous> * __imp___configthreadlocale = &g_t733A; // 0040720C
<anonymous> * __imp___initterm_e = &g_t732C; // 00407210
<anonymous> * __imp___initterm = &g_t7320; // 00407214
<anonymous> * __imp____initenv = &g_t7314; // 00407218
<anonymous> * __imp__exit = &g_t730C; // 0040721C
<anonymous> * __imp___XcptFilter = &g_t72FE; // 00407220
<anonymous> * __imp___exit = &g_t72F6; // 00407224
<anonymous> * __imp___cexit = &g_t72EC; // 00407228
<anonymous> * __imp____getmainargs = &g_t72DC; // 0040722C
<anonymous> * __imp___amsg_exit = &g_t72CE; // 00407230
<anonymous> * __imp__??3@YAXPAX@Z = &g_t72BE; // 00407234
<anonymous> * __imp___CxxThrowException = &g_t729A; // 00407238
<anonymous> * __imp____dllonexit = &g_t73F6; // 0040723C
<anonymous> * __imp____CxxFrameHandler3 = &g_t7284; // 00407240
// subject_rdata.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

Eq_270 g_t404000 = null; // 00404000
Eq_266 g_t404208 = null; // 00404208
<anonymous> * ??_7type_info@@6B@[1] = // 00404740
	{
		fn0040117B,
	};
// subject_text.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 00401005: Register word32 fn00401005(Stack word32 dwArg04, Register out ptr32 ebxOut)
// Called from:
//      Win32CrtStartup
word32 fn00401005(word32 dwArg04, ptr32 & ebxOut)
{
	ptr32 fp;
	struct Eq_6 * fs;
	ptr32 eax_13 = fs->ptr0000;
	fs->ptr0000 = fp - 16;
	struct Eq_16 * esp_31 = fp - 44;
	if (dwArg04 == 0x09)
		CxxThrowException(fp - 24, fp - 24, 0x00405084, 0x00);
	if (dwArg04 == 0x00)
		CxxThrowException(fp - 28, 0x00, fp - 28, 0x00405070);
	fs->ptr0000 = eax_13;
	ebxOut = esp_31->ptr000C;
	return dwArg04 + 0x0A;
}

// 0040117B: void fn0040117B(Register (ptr32 Eq_47) ecx, Register word32 ebx, Stack byte bArg04)
void fn0040117B(struct type_info * ecx, word32 ebx, byte bArg04)
{
	if ((bArg04 & 0x02) != 0x00)
	{
		void * esi_48;
		if ((fn0040162E(ebx, ecx - 4, ecx, out esi_48)->b0008 & 0x01) != 0x00)
			operator delete(esi_48);
	}
	else
	{
		_type_info_dtor_internal_method(ecx);
		if ((bArg04 & 0x01) != 0x00)
			operator delete(ecx);
	}
}

// 004014A8: Register Eq_88 Win32CrtStartup()
Eq_88 Win32CrtStartup()
{
	ptr32 fp;
	struct Eq_90 * fs;
	word32 ebx;
	Eq_66 esi;
	struct type_info * edi;
	word32 dwLoc0C;
	Eq_95 tLoc14;
	fn00401A50();
	ptr32 esp_12 = fp - 8;
	struct Eq_102 * ebp_19 = fn00401970(ebx, esi, edi, dwLoc0C, 0x10);
	if (g_dw4064E4 == 0x00)
	{
		HeapSetInformation(null, tLoc14, (void *) 0x01, 0x00);
		esp_12 = fp - 0x0C;
	}
	ebp_19->dwFFFFFFFC = 0x00;
	Eq_88 esi_42 = fs->ptr0018->t0004.u0;
	ebp_19->dwFFFFFFE4 = 0x00;
	while (true)
	{
		struct Eq_146 * esp_46 = esp_12 - 4;
		esp_46->t0000.u0 = 0x00;
		esp_46->tFFFFFFFC.u0 = (DWORD) esi_42;
		esp_46->ptrFFFFFFF8 = &g_t4064CC;
		Eq_88 eax_55 = InterlockedCompareExchange(esp_46->ptrFFFFFFF8, esp_46->tFFFFFFFC.u1, esp_46->t0000.u1);
		if (eax_55 == 0x00)
			break;
		if (eax_55 == esi_42)
		{
			ebp_19->dwFFFFFFE4 = 0x01;
			break;
		}
		esp_46->t0000.u0 = 1000;
		Sleep(esp_46->t0000.u0);
	}
	if (g_dw4064BC == 0x01)
	{
		esp_46->t0000.u0 = 0x1F;
		_amsg_exit(esp_46->t0000.u1);
	}
	struct Eq_195 * esp_206;
	Eq_88 eax_223;
	if (g_dw4064BC == 0x00)
	{
		g_dw4064BC = 0x01;
		esp_46->t0000.u0 = 4212248;
		esp_46->tFFFFFFFC.u0 = 0x0040430C;
		esp_206 = (struct Eq_195 *) ((char *) &esp_46->t0000 + 4);
		if (_initterm_e(esp_46->tFFFFFFFC.u0, esp_46->t0000.u0) != 0x00)
		{
			ebp_19->dwFFFFFFFC = ~0x01;
			eax_223.u0 = 0xFF;
			goto l004013A1;
		}
	}
	else
		g_dw406184 = 0x01;
	if (g_dw4064BC == 0x01)
	{
		struct Eq_263 * esp_106 = esp_12 - 4;
		esp_106->ptr0000 = &g_t404208;
		esp_106->ptrFFFFFFFC = &g_t404000;
		_initterm(esp_106->ptrFFFFFFFC, esp_106->ptr0000);
		g_dw4064BC = 0x02;
	}
	if (ebp_19->dwFFFFFFE4 == 0x00)
	{
		struct Eq_292 * esp_125 = esp_12 - 4;
		esp_125->t0000.u0 = 0x00;
		esp_125->ptrFFFFFFFC = (LONG *) &g_t4064CC;
		InterlockedExchange(esp_125->ptrFFFFFFFC, esp_125->t0000.u1);
	}
	ptr32 esp_138 = esp_12;
	if (g_ptr4064E8 != null)
	{
		struct Eq_354 * esp_139 = esp_12 - 4;
		esp_139->dw0000 = 0x004064E8;
		esp_138 = &esp_139->dw0000 + 1;
		if (fn004018A0(esp_139->dw0000) != 0x00)
		{
			esp_139->dw0000 = 0x00;
			esp_139->dwFFFFFFFC = 0x02;
			esp_139->dwFFFFFFF8 = 0x00;
			word32 edx_179;
			g_ptr4064E8();
		}
	}
	_initenv->u0 = g_t40616C.u0;
	struct Eq_321 * esp_187 = esp_138 - 4;
	esp_187->t0000.u0 = g_t40616C.u0;
	esp_187->dwFFFFFFFC = g_dw406170;
	esp_187->dwFFFFFFF8 = g_dw406168;
	word32 ebx_197;
	Eq_88 eax_196 = fn00401005(esp_187->dwFFFFFFF8, out ebx_197);
	g_t406180.u0 = (DWORD) eax_196;
	esp_206 = (struct Eq_195 *) ((char *) &esp_187->t0000 + 4);
	if (g_dw406174 == ebx_197)
	{
		esp_187->t0000.u0 = (DWORD) eax_196;
		exit(esp_187->t0000.u1);
	}
	if (g_dw406184 == ebx_197)
		cexit();
	ebp_19->dwFFFFFFFC = ~0x01;
	eax_223.u0 = g_t406180.u0;
l004013A1:
	word32 esi_238;
	fn004019B5(ebp_19, esp_206->ptrFFFFFFFC, out esi_238);
	return eax_223;
}

// 004015D0: Register word32 fn004015D0(Register word32 ebx, Register Eq_66 esi, Register (ptr32 Eq_47) edi)
// Called from:
//      fn00401679
word32 fn004015D0(word32 ebx, Eq_66 esi, struct type_info * edi)
{
	ptr32 fp;
	word32 dwLoc0C;
	struct Eq_102 * ebp_13 = fn00401970(ebx, esi, edi, dwLoc0C, 0x14);
	ebp_13->dwFFFFFFFC = 0x00;
	struct Eq_420 * esp_31 = fp - 8;
	while (true)
	{
		int32 v9_25 = ebp_13->dw0010 - 0x01;
		ebp_13->dw0010 = v9_25;
		if (v9_25 < 0x00)
			break;
		word32 ecx_39 = ebp_13->dw0008 - (ebp_13->t000C).u0;
		ebp_13->dw0008 = ecx_39;
		ebp_13->ptr0014();
	}
	ebp_13->dwFFFFFFFC = ~0x01;
	word32 esi_60;
	return fn004019B5(ebp_13, esp_31->ptrFFFFFFFC, out esi_60);
}

// 0040162E: Register word32 fn0040162E(Register word32 ebx, Register Eq_66 esi, Register (ptr32 Eq_47) edi, Register out ptr32 esiOut)
// Called from:
//      fn0040117B
word32 fn0040162E(word32 ebx, Eq_66 esi, struct type_info * edi, ptr32 & esiOut)
{
	ptr32 fp;
	word32 dwLoc0C;
	struct Eq_102 * ebp_13 = fn00401970(ebx, esi, edi, dwLoc0C, 0x0C);
	ebp_13->dwFFFFFFE4 = 0x00;
	Eq_66 esi_21 = ebp_13->t000C.u0;
	ebp_13->dw0008 += esi_21 *s ebp_13->dw0010;
	ebp_13->dwFFFFFFFC = 0x00;
	struct Eq_489 * esp_53 = fp - 8;
	while (true)
	{
		int32 v14_33 = ebp_13->dw0010 - 0x01;
		ebp_13->dw0010 = v14_33;
		if (v14_33 < 0x00)
			break;
		ebp_13->dw0008 -= esi_21;
		ebp_13->ptr0014();
	}
	ebp_13->dwFFFFFFE4 = 0x01;
	ebp_13->dwFFFFFFFC = ~0x01;
	ptr32 esi_58;
	word32 ebp_54 = fn004019B5(fn00401679(ebx, ebp_13, esi_21, edi), esp_53->ptrFFFFFFFC, out esi_58);
	esiOut = esi_58;
	return ebp_54;
}

// 00401679: Register (ptr32 Eq_102) fn00401679(Register word32 ebx, Register (ptr32 Eq_102) ebp, Register Eq_66 esi, Register (ptr32 Eq_47) edi)
// Called from:
//      fn0040162E
struct Eq_102 * fn00401679(word32 ebx, struct Eq_102 * ebp, Eq_66 esi, struct type_info * edi)
{
	if (ebp->dwFFFFFFE4 == 0x00)
		ebp = fn004015D0(ebx, esi, edi);
	return ebp;
}

// 00401810: Register uint32 fn00401810(Stack (ptr32 Eq_545) dwArg04)
// Called from:
//      fn004018A0
uint32 fn00401810(struct Eq_545 * dwArg04)
{
	if (dwArg04->w0000 != 23117)
		return 0x00;
	struct Eq_551 * eax_16 = dwArg04 + dwArg04->dw003C / 64;
	if (eax_16->dw0000 != 0x4550)
		return 0x00;
	return (uint32) (int8) (eax_16->w0018 == 0x010B);
}

// 00401850: Register (ptr32 Eq_569) fn00401850(Stack (ptr32 Eq_570) dwArg04, Stack uint32 dwArg08)
// Called from:
//      fn004018A0
struct Eq_569 * fn00401850(struct Eq_570 * dwArg04, uint32 dwArg08)
{
	struct Eq_572 * ecx_12 = dwArg04 + dwArg04->dw003C / 64;
	up32 esi_20 = (word32) ecx_12->w0006;
	up32 edx_21 = 0x00;
	struct Eq_569 * eax_24 = ecx_12 + ((word32) ecx_12->w0014 + 24) / 22;
	if (esi_20 != 0x00)
	{
		do
		{
			uint32 ecx_32 = eax_24->dw000C;
			if (dwArg08 >= ecx_32 && dwArg08 < eax_24->dw0008 + ecx_32)
				return eax_24;
			++edx_21;
			++eax_24;
		} while (edx_21 < esi_20);
	}
	eax_24 = null;
	return eax_24;
}

// 004018A0: Register ui32 fn004018A0(Stack ui32 dwArg04)
// Called from:
//      Win32CrtStartup
ui32 fn004018A0(ui32 dwArg04)
{
	ptr32 fp;
	struct Eq_612 * fs;
	ptr32 eax_17 = fs->ptr0000;
	fs->ptr0000 = fp - 20;
	if (fn00401810(&g_t400000) != 0x00)
	{
		struct Eq_632 * eax_64 = fn00401850(&g_t400000, dwArg04 - 0x00400000);
		if (eax_64 != null)
		{
			ui32 eax_100 = ~(eax_64->dw0024 >> 0x1F) & 0x01;
			fs->ptr0000 = eax_17;
			return eax_100;
		}
	}
	fs->ptr0000 = eax_17;
	return 0x00;
}

// 00401970: Register ptr32 fn00401970(Register word32 ebx, Register Eq_66 esi, Register (ptr32 Eq_47) edi, Stack word32 dwArg00, Stack ui32 dwArg08)
// Called from:
//      Win32CrtStartup
//      fn004015D0
//      fn0040162E
ptr32 fn00401970(word32 ebx, Eq_66 esi, struct type_info * edi, word32 dwArg00, ui32 dwArg08)
{
	ptr32 fp;
	struct Eq_655 * fs;
	struct Eq_656 * esp_14 = fp - 8 - dwArg08;
	esp_14->dwFFFFFFFC = ebx;
	esp_14->tFFFFFFF8.u0 = (int32) esi;
	esp_14->ptrFFFFFFF4 = edi;
	esp_14->dwFFFFFFF0 = g_dw406020 ^ fp + 8;
	esp_14->dwFFFFFFEC = dwArg00;
	fs->ptr0000 = fp - 8;
	return fp + 8;
}

// 004019B5: Register (ptr32 Eq_102) fn004019B5(Register (ptr32 Eq_102) ebp, Stack (ptr32 Eq_102) dwArg00, Register out ptr32 esiOut)
// Called from:
//      Win32CrtStartup
//      fn004015D0
//      fn0040162E
struct Eq_102 * fn004019B5(struct Eq_102 * ebp, struct Eq_102 * dwArg00, ptr32 & esiOut)
{
	struct Eq_686 * fs;
	ptr32 dwArg0C;
	fs->dw0000 = ebp->dwFFFFFFF0;
	struct Eq_102 * ebp_19 = ebp->ptr0000;
	ebp->ptr0000 = dwArg00;
	esiOut = dwArg0C;
	return ebp_19;
}

// 00401A50: void fn00401A50()
// Called from:
//      Win32CrtStartup
void fn00401A50()
{
	Eq_701 tLoc14;
	Eq_702 tLoc0C;
	ui32 eax_11 = g_dw406020;
	tLoc0C.dwLowDateTime = (DWORD) 0x00;
	tLoc0C.dwHighDateTime = (DWORD) 0x00;
	if (eax_11 != 0xBB40E64E && (eax_11 & 0xFFFF0000) != 0x00)
		g_dw406024 = ~eax_11;
	else
	{
		GetSystemTimeAsFileTime(&tLoc0C);
		ui32 esi_48 = tLoc0C.dwHighDateTime ^ tLoc0C.dwLowDateTime ^ GetCurrentProcessId() ^ GetCurrentThreadId() ^ GetTickCount();
		QueryPerformanceCounter(&tLoc14);
		ui32 esi_56 = esi_48 ^ (tLoc14.dw0004 ^ (tLoc14.u).LowPart);
		if (esi_56 == 0xBB40E64E)
			esi_56 = ~0x44BF19B0;
		else if ((esi_56 & 0xFFFF0000) == 0x00)
			esi_56 |= (esi_56 | 0x4711) << 0x10;
		g_dw406020 = esi_56;
		g_dw406024 = ~esi_56;
	}
}

