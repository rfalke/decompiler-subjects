/* This file was generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2020 Hex-Rays <info@hex-rays.com>

   Detected compiler: GNU C++
*/

#include <defs.h>

#include <stdarg.h>


//-------------------------------------------------------------------------
// Function declarations

// void (*init_proc())(void);
// const __int32_t **__ctype_toupper_loc(void);
// int raise(int sig);
// char *strstr(const char *haystack, const char *needle);
// int strcmp(const char *s1, const char *s2);
// int __cdecl __mempcpy_chk(_DWORD, _DWORD, _DWORD, _DWORD); weak
// struct passwd *getpwuid(__uid_t uid);
// int fflush(FILE *stream);
// void _exit(int status);
// int sigprocmask(int how, const sigset_t *set, sigset_t *oset);
// int dirfd(DIR *dirp);
// int __cdecl wcwidth(_DWORD); weak
// void *memmove(void *dest, const void *src, size_t n);
// int _setjmp(struct __jmp_buf_tag env[1]);
// void free(void *ptr);
// void *memcpy(void *dest, const void *src, size_t n);
// int mbsinit(const mbstate_t *ps);
// unsigned __int64 __strtoull_internal(const char *nptr, char **endptr, int base, int group);
// int fclose(FILE *stream);
// int fseeko64(void); weak
// __sighandler_t signal(int sig, __sighandler_t handler);
// int memcmp(const void *s1, const void *s2, size_t n);
// int gettimeofday(struct timeval *tv, __timezone_ptr_t tz);
// void _obstack_newchunk(struct obstack *, int);
// char *dcgettext(const char *domainname, const char *msgid, int category);
// time_t mktime(struct tm *tp);
// int __cdecl stpcpy(_DWORD, _DWORD); weak
// int _obstack_begin(struct obstack *, int, int, void *(*)(int), void (*)(void *));
// int sigismember(const sigset_t *set, int signo);
// int fflush_unlocked(FILE *stream);
// int iswcntrl(wint_t wc);
// char *textdomain(const char *domainname);
// ssize_t readlink(const char *path, char *buf, size_t len);
// int fnmatch(const char *pattern, const char *name, int flags);
// int iswprint(wint_t wc);
// int ioctl(int fd, unsigned int request, ...);
// size_t fwrite(const void *ptr, size_t size, size_t n, FILE *s);
// int __cdecl __fxstat64(_DWORD, _DWORD, _DWORD); weak
// size_t __ctype_get_mb_cur_max(void);
// char *strcpy(char *dest, const char *src);
// size_t __fpending(FILE *fp);
// size_t wcstombs(char *s, const wchar_t *pwcs, size_t n);
// size_t mbrtowc(wchar_t *pwc, const char *s, size_t n, mbstate_t *p);
// int __cdecl __cxa_atexit(void (__cdecl *lpfunc)(void *), void *obj, void *lpdso_handle);
// void error(int status, int errnum, const char *format, ...);
// int strcoll(const char *s1, const char *s2);
// char *getenv(const char *name);
// void *realloc(void *ptr, size_t size);
// int __cdecl lgetfilecon(_DWORD, _DWORD); weak
// void *malloc(size_t size);
// int __freading(FILE *fp);
// int __cdecl __memcpy_chk(_DWORD, _DWORD, _DWORD, _DWORD); weak
// void exit(int status);
// int __cdecl fputs_unlocked(_DWORD, _DWORD); weak
// size_t strftime(char *s, size_t maxsize, const char *format, const struct tm *tp);
// int getopt_long(int argc, char *const *argv, const char *shortopts, const struct option *longopts, int *longind);
// int __cdecl getfilecon(_DWORD, _DWORD); weak
// struct tm *localtime(const time_t *timer);
// unsigned int strtoul(const char *nptr, char **endptr, int base);
// char *strchr(const char *s, int c);
// size_t strlen(const char *s);
// int __cdecl __libc_start_main(int (__cdecl *main)(int, char **, char **), int argc, char **ubp_av, void (*init)(void), void (*fini)(void), void (*rtld_fini)(void), void *stack_end);
// int sigaddset(sigset_t *set, int signo);
// void *memset(void *s, int c, size_t n);
// int *__errno_location(void);
// __pid_t tcgetpgrp(int fd);
// char *strncpy(char *dest, const char *src, size_t n);
// int fileno(FILE *stream);
// size_t fwrite_unlocked(const void *ptr, size_t size, size_t n, FILE *stream);
// int __printf_chk(_DWORD, const char *, ...); weak
// int __cdecl mempcpy(_DWORD, _DWORD, _DWORD); weak
// int __cdecl wcswidth(_DWORD, _DWORD); weak
// int sigemptyset(sigset_t *set);
// char *nl_langinfo(nl_item item);
// char *setlocale(int category, const char *locale);
// int __cdecl acl_extended_file_nofollow(_DWORD); weak
// char *strrchr(const char *s, int c);
// int __overflow(_IO_FILE *, int);
// size_t mbstowcs(wchar_t *pwcs, const char *s, size_t n);
// struct lconv *localeconv(void);
// int __cdecl freecon(_DWORD); weak
// __int64 __cdecl lseek64(_DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl readdir64(_DWORD); weak
// int __fprintf_chk(_DWORD, _DWORD, const char *, ...); weak
// int clock_gettime(clockid_t clock_id, struct timespec *tp);
// int sigaction(int sig, const struct sigaction *act, struct sigaction *oact);
// char *bindtextdomain(const char *domainname, const char *dirname);
// int strncmp(const char *s1, const char *s2, size_t n);
// int isatty(int fd);
// void abort(void);
// int __cdecl __xstat64(_DWORD, _DWORD, _DWORD); weak
// int __cdecl __lxstat64(_DWORD, _DWORD, _DWORD); weak
// int closedir(DIR *dirp);
// DIR *opendir(const char *name);
// struct group *getgrgid(__gid_t gid);
// const __int32_t **__ctype_tolower_loc(void);
// void __assert_fail(const char *assertion, const char *file, unsigned int line, const char *function);
// const unsigned __int16 **__ctype_b_loc(void);
// void *calloc(size_t nmemb, size_t size);
// int __fastcall __sprintf_chk(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
void __cdecl __noreturn main(int argc, char **a2);
// void __usercall __noreturn start(int@<eax>, void (*)(void)@<edx>);
void sub_804BE60();
int sub_804BEC0();
int __cdecl sub_804BEF0(unsigned __int64 *, unsigned int);
bool __cdecl sub_804BF20(_QWORD *, _QWORD *);
int __cdecl sub_804BF70(int a1);
// bool __usercall sub_804BF90@<al>(int@<eax>);
void j__free(void *ptr);
// int __usercall sub_804C010@<eax>(char **@<eax>, char **@<edx>, char@<cl>, _DWORD *);
// _DWORD *__usercall sub_804C280@<eax>(int@<eax>);
// int __usercall sub_804C2B0@<eax>(char *@<eax>, char *@<edx>, char@<cl>);
void *sub_804C320();
unsigned int sub_804C3F0();
int __cdecl sub_804C550(const char **, const char **);
int __cdecl sub_804C570(const char **, const char **);
int __cdecl sub_804C590(int, int);
int __cdecl sub_804C620(int, int);
int __cdecl sub_804C6B0(char *, char *); // idb
int __cdecl sub_804C740(char *, char *); // idb
int __cdecl sub_804C760(char *, char *); // idb
int __cdecl sub_804C7F0(char *, char *); // idb
// int __usercall sub_804C810@<eax>(char *@<eax>, char@<dl>);
// unsigned int __usercall sub_804C970@<eax>(unsigned int result@<eax>, unsigned int@<edx>);
// FILE *__usercall sub_804CA20@<eax>(FILE *result@<eax>, int@<edx>);
// size_t __usercall sub_804CAE0@<eax>(char *s@<eax>, int a2@<edx>, size_t a3@<ecx>);
// size_t __usercall sub_804CBA0@<eax>(__uid_t a1@<eax>, size_t a2@<edx>, int a3@<ecx>);
// __int64 __usercall sub_804CBF0@<edx:eax>(FILE *@<eax>, int@<edx>, int *@<ecx>, _DWORD *);
int sub_804CF70();
int __cdecl sub_804CF90(int, int);
int __cdecl sub_804D040(int, int);
int __cdecl sub_804D0F0(int, int);
int __cdecl sub_804D1A0(int, int);
// int __usercall sub_804D260@<eax>(char@<al>, __int16@<dx>, int@<ecx>);
// bool __usercall sub_804D3A0@<al>(char@<al>, __int16@<dx>, int@<ecx>);
// __int64 __usercall sub_804D3F0@<edx:eax>(int@<eax>);
// int __usercall sub_804D570@<eax>(int@<eax>, const char *@<edx>, int@<ecx>);
// size_t __usercall sub_804D600@<eax>(int@<eax>, int@<ecx>);
// int __usercall sub_804D660@<eax>(__uid_t a1@<eax>, int a2@<ecx>);
int __cdecl sub_804D6B0(int, int);
int __cdecl sub_804D7A0(char *s1, char *s2); // idb
int __cdecl sub_804D7E0(char *s1, char *s2); // idb
int __cdecl sub_804D800(char *s1, char *s2); // idb
int __cdecl sub_804D820(char *s1, char *s2); // idb
int __cdecl sub_804D8B0(char *s1, char *s2); // idb
size_t sub_804D940();
// size_t __usercall sub_804D980@<eax>(int@<eax>);
size_t sub_804D9D0();
// int __usercall sub_804D9F0@<eax>(struct obstack *@<ecx>, int@<eax>, char@<dl>, int);
void sub_804DF20();
// __int64 __usercall sub_804DF70@<edx:eax>(int@<eax>, int@<edx>);
// int __usercall sub_804E120@<eax>(char *@<eax>, const char *haystack@<edx>, const struct tm *@<ecx>, int);
// char __usercall sub_804E240@<al>(int@<eax>, unsigned int@<ecx>);
// int __usercall sub_804EB40@<eax>(char *@<eax>, size_t@<edx>, unsigned __int8@<cl>, char *);
// unsigned int __usercall sub_804F7E0@<eax>(char@<al>);
int sub_804FA80();
int __cdecl sub_804FEA0(char *s1, char *s2); // idb
int __cdecl sub_804FF30(int, int);
int __cdecl sub_804FFC0(char *s1, char *s2); // idb
int __cdecl sub_8050050(int, int);
int __cdecl sub_80500E0(char *s1, char *s2); // idb
int __cdecl sub_80501A0(int, int);
int __cdecl sub_8050260(char *s1, char *s2); // idb
int __cdecl sub_8050320(char *s1, char *s2); // idb
int __cdecl sub_8050390(int, int);
int __cdecl sub_8050400(char *s1, char *s2); // idb
int __cdecl sub_8050470(int, int);
int __cdecl sub_80504E0(char *s1, char *s2); // idb
int __cdecl sub_8050590(int, int);
int __cdecl sub_8050640(char *s1, char *s2); // idb
int __cdecl sub_80506F0(char *s1, char *s2); // idb
int __cdecl sub_8050760(int, int);
int __cdecl sub_80507D0(char *s1, char *s2); // idb
int __cdecl sub_8050840(int, int);
int __cdecl sub_80508B0(char *s1, char *s2); // idb
int __cdecl sub_8050960(int, int);
int __cdecl sub_8050A10(char *s1, char *s2); // idb
int __cdecl sub_8050AC0(char *s1, char *s2); // idb
int __cdecl sub_8050B30(int, int);
int __cdecl sub_8050BA0(char *s1, char *s2); // idb
int __cdecl sub_8050C10(int, int);
int __cdecl sub_8050C80(char *s1, char *s2); // idb
int __cdecl sub_8050D30(int, int);
int __cdecl sub_8050DE0(char *s1, char *s2); // idb
int __cdecl sub_8050E90(const char **, const char **);
int __cdecl sub_8050F20(const char **, const char **);
int __cdecl sub_8050FB0(char *s1, char *s2); // idb
int __cdecl sub_8051040(char *s1, char *s2); // idb
int __cdecl sub_80510D0(char *s1, char *s2); // idb
int __cdecl sub_80511C0(char *s1, char *s2); // idb
int __cdecl sub_80512B0(int, int);
void __cdecl __noreturn sub_80513A0(int status); // idb
int __cdecl sub_8051AA0(int, int);
char *__cdecl sub_8051B00(char *path, int);
void __noreturn sub_8051BE0(); // weak
int __cdecl sub_8051C00(char *, int, void *, size_t); // idb
void __cdecl sub_8051D10(int, int, int);
_IO_FILE *__cdecl sub_8051DB0(_IO_FILE *, void *s2, size_t n);
int __cdecl sub_8051EE0(int, char *, _IO_FILE *, void *, size_t, int); // idb
void __cdecl sub_8051FD0();
_BYTE *__cdecl sub_80520B0(_BYTE *);
size_t __cdecl sub_8052100(char *s);
int __cdecl sub_80522D0(int, char *);
void *__cdecl sub_80522E0(int, char *, int);
void *__cdecl sub_8052310(int, char *, int);
// char *__usercall sub_8052420@<eax>(char **@<eax>);
int __cdecl sub_80524B0(char *, char *); // idb
int __cdecl sub_8052840(struct timespec *); // idb
bool __cdecl sub_8052890(int category);
int __cdecl sub_8052900(int a1, unsigned int a2);
bool __cdecl sub_8052910(int a1, int a2);
// unsigned int __usercall sub_8052920@<eax>(int a1@<eax>, int a2@<edx>);
// int __usercall sub_8052950@<eax>(int@<eax>, int@<edx>, int **@<ecx>, char);
// int __usercall sub_8052A50@<eax>(int@<eax>, int@<edx>, char@<cl>);
// int __usercall sub_8052B60@<eax>(float **@<eax>);
// unsigned int __usercall sub_8052C10@<eax>(unsigned int@<eax>, char@<dl>, float);
int __cdecl sub_8052D20(int);
void *__cdecl sub_8053140(unsigned int, void *, int (*)(), int (*)(), int);
void __cdecl sub_80532B0(void *);
int __cdecl sub_8053370(int, unsigned int);
int __cdecl sub_80534F0(int, int, int *);
int __cdecl sub_80536D0(int, int);
int __cdecl sub_8053710(int, int);
char *__cdecl sub_8053850(unsigned __int64, int, __int16, __int64, __int64);
int __cdecl sub_8054660(char *, int, int); // idb
int __cdecl sub_8054860(__uid_t); // idb
int __cdecl sub_80549F0(__gid_t); // idb
int __cdecl sub_8054B80(unsigned int, int, int);
int __cdecl sub_8054C60(unsigned int, unsigned int, int);
int __cdecl sub_8054CE0(char *, int, int, int, int, char); // idb
__int64 __cdecl sub_8055160(char *, int, int);
__int64 __cdecl sub_8055350(char *s, int);
// _DWORD *__usercall sub_8055380@<eax>(_DWORD *result@<eax>, unsigned int@<edx>, int *@<ecx>, int (__cdecl *)(int, int));
_DWORD *__cdecl sub_80555B0(_DWORD *, unsigned int, int (__cdecl *)(int, int));
char *__cdecl sub_80555D0(char *s);
_BYTE *__cdecl sub_8055690(int, int);
_BYTE *__cdecl sub_80556C0(int);
// _DWORD *__usercall sub_80556E0@<eax>(_DWORD *@<eax>, int@<edx>);
// __int64 __usercall sub_8055760@<edx:eax>(_BYTE *@<eax>, unsigned int@<edx>, int@<ecx>, unsigned int, int, int, int, char *, char *);
// _BYTE *__usercall sub_8056220@<eax>(unsigned int a1@<eax>, int a2@<edx>, unsigned int a3@<ecx>, int a4);
void *__cdecl sub_80563C0(int *);
int __cdecl sub_8056410(int *);
int *__cdecl sub_8056430(int *, int);
unsigned int __cdecl sub_8056450(int *a1, unsigned __int8 a2, char a3);
int *__cdecl sub_80564D0(int *, int, int);
__int64 __cdecl sub_8056510(_BYTE *, unsigned int, int, unsigned int, int *);
_BYTE *__cdecl sub_8056590(int, unsigned int, _DWORD *, int *);
_BYTE *__cdecl sub_8056740(int, int);
_BYTE *__cdecl sub_8056760(int, int, unsigned int);
_BYTE *__cdecl sub_8056780(int);
_BYTE *__cdecl sub_80567D0(int, int, int);
_BYTE *__cdecl sub_8056800(int, int, int, unsigned int);
_BYTE *__cdecl sub_8056890(int, unsigned int, unsigned __int8);
_BYTE *__cdecl sub_8056950(int, unsigned __int8);
_BYTE *__cdecl sub_8056980(int);
_BYTE *__cdecl sub_80569D0(int, int, int, int, unsigned int);
_BYTE *__cdecl sub_8056A80(int, int, int, int);
// int __usercall sub_8056B30@<eax>(int@<eax>, int@<edx>, int@<ecx>);
// __int64 __usercall sub_8056B70@<edx:eax>(char@<al>, char *@<edx>, int@<ecx>, char *, const struct tm *tp, int, int);
__int64 __cdecl sub_8058320(char *, int, char *, const struct tm *, int, int);
int __cdecl sub_8058370(int, const char *, const char *, const char *, int *, int);
int __cdecl sub_8058920(int, const char *, const char *, const char *, int);
int sub_8058980(int, const char *, const char *, const char *, ...);
void *__cdecl sub_8058A70(size_t size);
void *__cdecl sub_8058AA0(void *ptr, size_t size);
void *__cdecl sub_8058BA0(void *src, size_t n);
void *__cdecl sub_8058BD0(char *s);
void __noreturn sub_8058C00();
int __cdecl sub_8058C50(char *, char **, int, int, char *s); // idb
void __cdecl __noreturn sub_8059090(unsigned int, int, char, int, int);
// int __usercall sub_8059140@<eax>(unsigned int *@<eax>, signed int@<edx>);
// int __usercall sub_80591F0@<eax>(unsigned int *@<eax>, signed int@<edx>, int@<ecx>);
int __cdecl sub_8059230(char *, char **, int, int, char *s); // idb
int __cdecl sub_8059550(int, const char **);
int __cdecl sub_80595E0(int, const char **);
int __cdecl sub_8059700(FILE *); // idb
int __cdecl sub_8059790(FILE *fp); // idb
int __cdecl sub_8059840(FILE *stream); // idb
int __cdecl sub_80598A0(FILE *, int, int, int); // idb
int __cdecl sub_8059950(__int64, __int64);
int __cdecl sub_8059AC0(signed __int64, __int64);
unsigned int __cdecl sub_8059C90(unsigned __int64 a1, unsigned int a2, unsigned int a3);
int __cdecl sub_8059DC0(unsigned __int64, __int64);
void __cdecl init(int a1, int a2, int a3);
void fini(void); // idb
void sub_8059FB2();
int __cdecl sub_8059FC0(void (__cdecl *)(void *)); // idb
void (*sub_805A000())(void);

//-------------------------------------------------------------------------
// Data declarations

_UNKNOWN unk_805A068; // weak
_UNKNOWN unk_805A0AC; // weak
char byte_805A227[] = { '*' }; // weak
_UNKNOWN unk_805A278; // weak
int sig[12] = { 20, 14, 1, 2, 13, 3, 15, 29, 27, 26, 24, 25 }; // weak
const struct option longopts = { (const char *)0x805A3F8, 0, NULL, 97 }; // idb
const _IO_FILE stru_805AFE0 =
{
  134587572,
  (char *)0x805A1CB,
  (char *)0x805A49B,
  "extension",
  (char *)0x805A082,
  NULL,
  (char *)0xFFFFFFFF,
  (char *)4,
  (char *)2,
  (char *)1,
  (char *)3,
  "atime",
  &aAccess,
  &aUse,
  134587604,
  134587610,
  0,
  2u,
  '\0',
  "",
  (_IO_lock_t *)2,
  4294967298LL,
  (void *)1,
  NULL,
  NULL,
  &aVerbose,
  134587625u,
  134587630,
  "\xF5\xA4\x05\x08\x00\xA5\x05\b\a\xA5\x05\b\x10\xA5\x05\b\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x04\x00\x00\x00\x03\x00\x00\x00\x03"
}; // idb
const _IO_FILE stru_805B080 =
{
  134599940,
  "yes",
  "force",
  "never",
  "no",
  "none",
  "auto",
  (char *)0x805A539,
  "if-tty",
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  0,
  0,
  1,
  1u,
  '\0',
  "",
  (_IO_lock_t *)1,
  0LL,
  NULL,
  (void *)2,
  (void *)2,
  (void *)2,
  134587572u,
  134587709,
  "\x14\xA4\x05\b\v\xA4\x05\b\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x02\x00\x00\x00\x03\x00\x00\x00posix-\x00\x00F\xA1\x05\b"
}; // idb
int dword_805B124[7] = { 0, 1, 2, 3, 0, 0, 0 }; // weak
char *const off_805B140 = "lc"; // idb
int (__cdecl *off_805B1C0[4])(char *s1, char *s2) = { &sub_804D7E0, &sub_804D820, &sub_804D800, &sub_804D8B0 }; // weak
int dword_805B2A0[10] = { 13, 8, 11, 6, 10, 5, 7, 9, 5, 6 }; // weak
char byte_805B2C8[] = { '?' }; // weak
int dword_805B2E0[14] = { 1, 2, 0, 3, 0, 4, 0, 5, 0, 6, 0, 7, 0, 8 }; // weak
_UNKNOWN unk_805D40C; // weak
char byte_805D46C[] = { '\0' }; // weak
char *off_805D478[2] = { "human-readable", "si" }; // weak
int dword_805D484[] = { 176 }; // weak
int dword_805D7E0[8] = { 0, 1, 2, 3, 4, 5, 6, 7 }; // weak
const _IO_FILE stru_805D800 =
{
  134587474,
  "shell",
  &unk_805D4FE,
  (char *)0x805DD28,
  "c-maybe",
  "escape",
  (char *)0x805A15F,
  "clocale",
  NULL,
  (char *)0x252F6D25,
  (char *)0x79252F64,
  (char *)0x2D592500,
  (_IO_marker *)0x252D6D25,
  (_IO_FILE *)0x48250064,
  978134330,
  21285,
  134575746,
  27887u,
  '\x05',
  "\b",
  &loc_8056CEF,
  577987901074533615LL,
  &loc_8056CEF,
  &loc_8056CEF,
  &loc_8056CEF,
  &loc_8056CEF,
  134573295u,
  134573295,
  "\xEF\x6C\x05\b\xEF\x6C\x05\b\xEF\x6C\x05\b\xEF\x6C\x05\b\xEF\x6C\x05\b\xEF\x6C\x05\b\xEF\x6C\x05\b\xEF\x6C\x05\b\xEF\x6C\x05\b\xEF\x6C\x05\b"
}; // idb
char asc_805DE6D[3] = "--"; // weak
int dword_8061EF8[] = { -1 }; // weak
int dword_8061F00[] = { -1 }; // weak
_UNKNOWN unk_8061F04; // weak
int dword_8061F08 = 0; // weak
void *off_8061FF0 = &unk_80621C4; // weak
Elf32_Dyn *off_8061FF4 = &stru_8061F0C; // weak
int dword_80621E0[] = { 2 }; // weak
void *off_80621E4 = &asc_805A307; // idb
int dword_80621E8 = 1; // weak
char *off_80621EC = "m"; // weak
_UNKNOWN unk_80621F0; // weak
int dword_80621F4 = 0; // weak
_UNKNOWN unk_80621F8; // weak
_UNKNOWN unk_8062200; // weak
int dword_8062218 = 5; // weak
char *s1 = "01;36"; // idb
int dword_8062244 = 0; // weak
int dword_806224C = 0; // weak
_UNKNOWN unk_8062298; // weak
__int64 qword_80622A0 = 1LL; // weak
char byte_80622A8 = '\x01'; // weak
char byte_80622A9 = '\x01'; // weak
char *off_80622AC = "%b %e  %Y"; // idb
char *haystack = "%b %e %H:%M"; // idb
_UNKNOWN unk_80622B4; // weak
int dword_80622B8 = -1; // weak
char byte_80622BC = '\x01'; // weak
int dword_80622C0 = 1; // weak
char *off_80622C4 = "8.13"; // weak
int off_80622C8 = 134552544; // idb
int dword_80622CC = 1; // idb
void *off_80622D0 = &dword_80622D8; // idb
int dword_80622D4 = 1; // weak
int dword_80622D8 = 256; // weak
void *off_80622DC = &unk_8062E00; // weak
int program_invocation_short_name; // weak
_IO_FILE *stderr; // idb
int program_invocation_name; // weak
int optind; // weak
FILE *stdout; // idb
char *optarg; // idb
char byte_8062328; // weak
int dword_806232C; // weak
int dword_8062340; // weak
int dword_8062344; // idb
int status; // idb
char byte_806234C; // weak
int dword_8062350; // weak
struct timespec stru_8062354; // idb
char byte_806235C; // weak
char byte_806235D; // weak
int dword_8062360; // weak
char byte_8062364; // weak
sigset_t set; // idb
int dword_8062400; // weak
char byte_8062404; // weak
int dword_8062408; // weak
char byte_806240C; // weak
void *dword_8062410; // idb
struct obstack stru_8062420; // idb
int dword_806244C; // weak
char byte_8062450; // weak
char byte_8062451; // weak
char byte_8062452; // weak
char byte_8062453; // weak
char byte_8062454; // weak
char byte_8062455; // weak
struct obstack stru_8062460; // idb
struct obstack stru_80624A0; // idb
int dword_80624CC; // weak
void *qword_80624D0; // idb
int dword_80624D8; // weak
char byte_80624DC; // weak
int dword_80624E0; // weak
char byte_80624E4; // weak
int dword_80624E8; // weak
char byte_80624EC; // weak
char byte_80624ED; // weak
char byte_80624EE; // weak
int dword_80624F0; // weak
int dword_80624F4; // weak
int dword_80624F8; // weak
int dword_80624FC; // weak
__int64 qword_8062500; // weak
int dword_8062508; // weak
int dword_806250C; // weak
char byte_8062510; // weak
int dword_8062514; // weak
int dword_8062518; // weak
int dword_806251C; // weak
_UNKNOWN unk_8062520; // weak
void *ptr; // idb
void *dword_8062CB0; // idb
void *dword_8062CB4; // idb
char byte_8062CB8; // weak
int dword_8062CBC; // weak
int dword_8062CC0; // weak
int dword_8062CC4; // weak
int dword_8062CC8; // weak
int dword_8062CCC; // weak
int dword_8062CD0; // weak
int dword_8062CD4; // weak
int dword_8062CD8; // weak
int dword_8062CDC; // weak
int dword_8062CE0; // weak
int dword_8062CE4; // weak
struct __jmp_buf_tag env[1]; // idb
void *dword_8062D9C; // idb
int dword_8062DA0; // weak
int dword_8062DA4; // weak
char byte_8062DA8; // weak
int dword_8062DAC; // weak
int dword_8062DB4; // weak
int dword_8062DBC; // weak
int dword_8062DC0; // weak
int dword_8062DC4; // weak
int dword_8062DC8; // weak
int dword_8062DCC; // weak
int dword_8062DD0; // weak
int dword_8062DD4; // weak
int dword_8062DD8; // weak
int dword_8062DDC; // weak
int dword_8062DE0; // weak
int dword_8062DE4; // weak
int dword_8062DE8; // weak
int dword_8062DEC; // weak
_UNKNOWN unk_8062E00; // weak


//----- (08049B80) --------------------------------------------------------
void __cdecl __noreturn main(int argc, char **a2)
{
  char *v2; // eax
  int v3; // ebx
  int v4; // eax
  char *v5; // ebx
  char *v6; // eax
  int v7; // ebx
  char *v8; // eax
  int v9; // ebx
  char v10; // di
  int v11; // eax
  int v12; // eax
  const char *v13; // eax
  int v14; // eax
  _DWORD *v15; // eax
  int v16; // edx
  int v17; // eax
  unsigned int v18; // eax
  char *v19; // eax
  unsigned int v20; // eax
  unsigned __int8 *v21; // esi
  unsigned __int8 v22; // al
  char v23; // al
  int v24; // ebx
  int v25; // ebx
  char *v26; // eax
  const char *v27; // esi
  int v28; // edi
  int *v29; // eax
  int v30; // eax
  unsigned int v31; // eax
  _DWORD *v32; // ebx
  int v33; // eax
  char *v34; // esi
  int v35; // eax
  int v36; // edx
  int v37; // eax
  FILE *v38; // edx
  char *v39; // eax
  char *v40; // eax
  int v41; // eax
  int v42; // edi
  char *v43; // ebx
  int v44; // esi
  int v45; // esi
  size_t v46; // edx
  unsigned __int8 v47; // al
  __int64 v48; // rax
  int v49; // eax
  _BYTE *v50; // ebx
  char *v51; // eax
  char *v52; // eax
  int v53; // ebx
  int v54; // esi
  int v55; // esi
  void (*v56)(int); // eax
  char *v57; // eax
  int v58; // eax
  char *v59; // eax
  char *v60; // ebx
  size_t v61; // eax
  FILE *v62; // edx
  char *v63; // eax
  char *v64; // ebx
  FILE *v65; // eax
  char *v66; // edx
  int v67; // ebx
  int v68; // esi
  char v69; // al
  char *v70; // eax
  char *v71; // eax
  char *next_free; // esi
  void *v73; // eax
  char *v74; // eax
  _BYTE *v75; // ebx
  char *v76; // eax
  _BYTE *v77; // ebx
  char *v78; // eax
  _BYTE *v79; // ebx
  char *v80; // eax
  char *v81; // eax
  int i; // ebx
  int v83; // eax
  int v84; // edi
  nl_item v85; // esi
  char *v86; // edi
  char *v87; // eax
  unsigned int v88; // eax
  char *v89; // eax
  char *v90; // eax
  char *v91; // edx
  char *v92; // edi
  char *v93; // eax
  char *v94; // eax
  _DWORD *v95; // ebx
  void *v96; // eax
  int v97; // edx
  FILE *v98; // eax
  char *IO_write_ptr; // edx
  char *v100; // eax
  bool v101; // zf
  int v102; // eax
  char *v103; // eax
  _DWORD *k; // eax
  _DWORD *v105; // ebx
  char v106; // al
  char v107; // dl
  int j; // esi
  char v109; // al
  _DWORD *v110; // eax
  void *v111; // eax
  char v112; // al
  _BYTE *v113; // esi
  char *v114; // eax
  _BYTE *v115; // [esp+20h] [ebp-3ECh]
  _BYTE *v116; // [esp+20h] [ebp-3ECh]
  char *v117; // [esp+20h] [ebp-3ECh]
  _BYTE *v118; // [esp+24h] [ebp-3E8h]
  int v119; // [esp+28h] [ebp-3E4h]
  int v120; // [esp+2Ch] [ebp-3E0h]
  int v121; // [esp+34h] [ebp-3D8h]
  __int64 v122; // [esp+38h] [ebp-3D4h]
  unsigned __int64 v123; // [esp+38h] [ebp-3D4h]
  int v124; // [esp+40h] [ebp-3CCh]
  char *v125; // [esp+44h] [ebp-3C8h]
  char *v126; // [esp+44h] [ebp-3C8h]
  char *v127; // [esp+44h] [ebp-3C8h]
  char *v128; // [esp+44h] [ebp-3C8h]
  char *v129; // [esp+44h] [ebp-3C8h]
  DIR *v130; // [esp+48h] [ebp-3C4h]
  int *v131; // [esp+4Ch] [ebp-3C0h]
  struct sigaction v132; // [esp+5Ch] [ebp-3B0h] BYREF
  int v133; // [esp+E8h] [ebp-324h] BYREF
  int v134; // [esp+ECh] [ebp-320h]
  __int64 v135; // [esp+140h] [ebp-2CCh]
  _BYTE v136[16]; // [esp+148h] [ebp-2C4h] BYREF
  char s1[8]; // [esp+158h] [ebp-2B4h] BYREF
  int v138; // [esp+160h] [ebp-2ACh] BYREF
  int longind; // [esp+164h] [ebp-2A8h] BYREF
  char *v140; // [esp+168h] [ebp-2A4h] BYREF
  char *v141; // [esp+16Ch] [ebp-2A0h] BYREF
  _DWORD v142[167]; // [esp+170h] [ebp-29Ch] BYREF

  v142[163] = __readgsdword(0x14u);
  sub_80555D0(*a2);
  setlocale(6, "");
  bindtextdomain("coreutils", "/usr/share/locale");
  textdomain("coreutils");
  dword_80622CC = 2;
  sub_8059FC0((void (__cdecl *)(void *))sub_8051FD0);
  status = 0;
  byte_806234C = 1;
  dword_8062350 = 0;
  stru_8062354.tv_sec = 0x80000000;
  stru_8062354.tv_nsec = -1;
  byte_80624E4 = 0;
  if ( dword_80622C0 == 2 )
  {
    dword_8062360 = 2;
    sub_8056430(0, 5);
  }
  else if ( dword_80622C0 == 3 )
  {
    dword_8062360 = 0;
    sub_8056430(0, 5);
  }
  else
  {
    if ( dword_80622C0 != 1 )
LABEL_4:
      abort();
    if ( isatty(1) )
    {
      dword_8062360 = 2;
      byte_80624E4 = 1;
    }
    else
    {
      dword_8062360 = 1;
    }
  }
  dword_80624E8 = 0;
  dword_806244C = 0;
  byte_80624EC = 0;
  byte_80624ED = 0;
  byte_8062451 = 0;
  dword_8062408 = 0;
  byte_80624EE = 0;
  dword_8062400 = 1;
  byte_806240C = 0;
  byte_8062404 = 0;
  dword_80624F0 = 0;
  dword_80624F4 = 0;
  dword_80624F8 = 0;
  byte_8062450 = 0;
  v2 = getenv("QUOTING_STYLE");
  v3 = (int)v2;
  if ( v2 )
  {
    v4 = sub_8051C00(v2, (int)&stru_805D800, dword_805D7E0, 4u);
    if ( v4 < 0 )
    {
      v79 = sub_8056780(v3);
      v80 = dcgettext(0, "ignoring invalid value of environment variable QUOTING_STYLE: %s", 5);
      error(0, 0, v80, v79);
    }
    else
    {
      sub_8056430(0, dword_805D7E0[v4]);
    }
  }
  v5 = getenv("LS_BLOCK_SIZE");
  sub_8054660(v5, (int)&dword_80624FC, (int)&qword_8062500);
  if ( v5 || getenv("BLOCK_SIZE") )
    qword_80622A0 = qword_8062500;
  dword_8062508 = 80;
  v6 = getenv("COLUMNS");
  v7 = (int)v6;
  if ( v6 && *v6 )
  {
    if ( sub_8058C50(v6, 0, 0, (int)&v138, 0) || !v138 )
    {
      v50 = sub_8056780(v7);
      v51 = dcgettext(0, "ignoring invalid width in environment variable COLUMNS: %s", 5);
      error(0, 0, v51, v50);
    }
    else
    {
      dword_8062508 = v138;
    }
  }
  if ( ioctl(1, 0x5413u, s1) != -1 && *(_WORD *)&s1[2] )
    dword_8062508 = *(unsigned __int16 *)&s1[2];
  v8 = getenv("TABSIZE");
  dword_806250C = 8;
  v9 = (int)v8;
  if ( v8 )
  {
    if ( sub_8058C50(v8, 0, 0, (int)&v138, 0) )
    {
      v77 = sub_8056780(v9);
      v78 = dcgettext(0, "ignoring invalid tab size in environment variable TABSIZE: %s", 5);
      error(0, 0, v78, v77);
    }
    else
    {
      dword_806250C = v138;
    }
  }
  v10 = 0;
  v125 = 0;
  while ( 1 )
  {
    longind = -1;
    v11 = getopt_long(argc, a2, "abcdfghiklmnopqrstuvw:xABCDFGHI:LNQRST:UXZ1", &longopts, &longind);
    if ( v11 == -1 )
      break;
    v12 = v11 + 131;
    switch ( v12 )
    {
      case 0:
        v13 = "coreutils" + 7;
        if ( dword_80622C0 != 1 )
        {
          v13 = "dir";
          if ( dword_80622C0 != 2 )
            v13 = "vdir";
        }
        sub_8058980((int)stdout, v13, "GNU coreutils", off_80622C4, "Richard M. Stallman", "David MacKenzie", 0);
        exit(0);
        return;
      case 1:
        sub_80513A0(0);
      case 180:
        dword_8062360 = dword_8062360 != 0;
        continue;
      case 196:
        if ( !dword_80624F0 )
          dword_80624F0 = 1;
        continue;
      case 197:
        sub_804C280((int)"*~");
        sub_804C280((int)".*~");
        continue;
      case 198:
        dword_8062360 = 2;
        continue;
      case 199:
        byte_8062455 = 1;
        continue;
      case 201:
        dword_8062408 = 3;
        continue;
      case 202:
        byte_80622A9 = 0;
        continue;
      case 203:
        dword_8062400 = 3;
        continue;
      case 204:
        sub_804C280((int)optarg);
        continue;
      case 207:
        dword_8062400 = 5;
        continue;
      case 209:
        sub_8056430(0, 0);
        continue;
      case 212:
        sub_8056430(0, 3);
        continue;
      case 213:
        byte_806240C = 1;
        continue;
      case 214:
        dword_806244C = 2;
        v10 = 1;
        continue;
      case 215:
        if ( sub_8058C50(optarg, 0, 0, (int)&v138, 0) )
        {
          v116 = sub_8056780((int)optarg);
          v57 = dcgettext(0, "invalid tab size: %s", 5);
          error(2, 0, v57, v116);
        }
        dword_806250C = v138;
        continue;
      case 216:
        dword_806244C = -1;
        v10 = 1;
        continue;
      case 219:
        dword_806244C = 1;
        v10 = 1;
        continue;
      case 221:
        byte_8062450 = 1;
        continue;
      case 228:
        dword_80624F0 = 2;
        continue;
      case 229:
        sub_8056430(0, 5);
        continue;
      case 230:
        dword_80624E8 = 1;
        continue;
      case 231:
        byte_8062404 = 1;
        continue;
      case 233:
        dword_80624F0 = 2;
        dword_806244C = -1;
        if ( !dword_8062360 )
          dword_8062360 = 2 - (isatty(1) == 0);
        byte_8062451 = 0;
        v10 = 1;
        byte_806235C = 0;
        continue;
      case 234:
        dword_8062360 = 0;
        byte_80622A8 = 0;
        continue;
      case 235:
        dword_80624FC = 176;
        qword_8062500 = 1LL;
        qword_80622A0 = 1LL;
        continue;
      case 236:
        byte_80624EE = 1;
        continue;
      case 238:
        dword_80624FC = 0;
        qword_8062500 = 1024LL;
        qword_80622A0 = 1024LL;
        continue;
      case 239:
        goto LABEL_27;
      case 240:
        dword_8062360 = 4;
        continue;
      case 241:
        byte_80624ED = 1;
LABEL_27:
        dword_8062360 = 0;
        break;
      case 242:
        dword_8062360 = 0;
        byte_80622A9 = 0;
        break;
      case 243:
        dword_8062408 = 1;
        break;
      case 244:
        byte_80624E4 = 1;
        break;
      case 245:
        byte_80624EC = 1;
        break;
      case 246:
        byte_8062451 = 1;
        break;
      case 247:
        dword_806244C = 4;
        v10 = 1;
        break;
      case 248:
        dword_80624E8 = 2;
        break;
      case 249:
        dword_806244C = 3;
        v10 = 1;
        break;
      case 250:
        if ( sub_8058C50(optarg, 0, 0, (int)&v138, 0) || !v138 )
        {
          v115 = sub_8056780((int)optarg);
          v19 = dcgettext(0, "invalid line width: %s", 5);
          error(2, 0, v19, v115);
        }
        dword_8062508 = v138;
        break;
      case 251:
        dword_8062360 = 3;
        break;
      case 259:
        byte_8062510 = 1;
        break;
      case 260:
        v18 = sub_8054660(optarg, (int)&dword_80624FC, (int)&qword_8062500);
        if ( v18 )
          sub_8059090(v18, longind, 0, (int)&longopts, (int)optarg);
        qword_80622A0 = qword_8062500;
        break;
      case 261:
        if ( !optarg
          || (v17 = *(&stru_805B080._old_offset
                    + sub_8051EE0(
                        (int)"--color",
                        optarg,
                        (_IO_FILE *)&stru_805B080,
                        &stru_805B080._old_offset,
                        4u,
                        off_80622C8)),
              v17 == 1)
          || v17 == 2 && isatty(1) )
        {
          byte_806235C = 1;
          dword_806250C = 0;
        }
        else
        {
          byte_806235C = 0;
        }
        break;
      case 262:
        dword_8062400 = 4;
        break;
      case 263:
        dword_8062408 = 2;
        break;
      case 264:
        dword_8062360 = *(_DWORD *)&stru_805AFE0._unused2[4
                                                        * sub_8051EE0(
                                                            (int)"--format",
                                                            optarg,
                                                            (_IO_FILE *)&stru_805AFE0.__pad4,
                                                            &stru_805AFE0._unused2[20],
                                                            4u,
                                                            off_80622C8)
                                                        + 20];
        break;
      case 265:
        dword_8062360 = 0;
        v125 = "full-iso";
        break;
      case 266:
        byte_8062453 = 1;
        break;
      case 267:
        v15 = sub_8058A70(8u);
        *v15 = optarg;
        v16 = dword_80624F8;
        dword_80624F8 = (int)v15;
        v15[1] = v16;
        break;
      case 268:
        dword_8062408 = *(_DWORD *)&stru_805B080._unused2[4
                                                        * sub_8051EE0(
                                                            (int)"--indicator-style",
                                                            optarg,
                                                            (_IO_FILE *)&stru_805B080.__pad5,
                                                            &stru_805B080._unused2[12],
                                                            4u,
                                                            off_80622C8)
                                                        + 12];
        break;
      case 269:
        v14 = sub_8051EE0((int)"--quoting-style", optarg, (_IO_FILE *)&stru_805D800, dword_805D7E0, 4u, off_80622C8);
        sub_8056430(0, dword_805D7E0[v14]);
        break;
      case 270:
        byte_80624E4 = 0;
        break;
      case 271:
        dword_80624FC = 144;
        qword_8062500 = 1LL;
        qword_80622A0 = 1LL;
        break;
      case 272:
        v10 = 1;
        dword_806244C = *((_DWORD *)&stru_805AFE0._IO_write_end
                        + sub_8051EE0(
                            (int)"--sort",
                            optarg,
                            (_IO_FILE *)&stru_805AFE0,
                            &stru_805AFE0._IO_write_end,
                            4u,
                            off_80622C8));
        break;
      case 273:
        dword_80624E8 = *((_DWORD *)&stru_805AFE0._cur_column
                        + sub_8051EE0(
                            (int)"--time",
                            optarg,
                            (_IO_FILE *)&stru_805AFE0._IO_save_end,
                            &stru_805AFE0._cur_column,
                            4u,
                            off_80622C8));
        break;
      case 274:
        v125 = optarg;
        break;
      default:
        sub_80513A0(2);
    }
  }
  v20 = 1;
  if ( (unsigned int)dword_8062508 > 2 )
    v20 = dword_8062508 / 3u;
  dword_8062514 = v20;
  dword_80624E0 = (int)sub_80563C0(0);
  if ( sub_8056410((int *)dword_80624E0) == 5 )
    sub_8056450((int *)dword_80624E0, 0x20u, 1);
  if ( (unsigned int)dword_8062408 > 1 )
  {
    v21 = (unsigned __int8 *)(dword_8062408 + 134586917);
    v22 = byte_805A227[dword_8062408 - 2];
    if ( v22 )
    {
      do
      {
        ++v21;
        sub_8056450((int *)dword_80624E0, v22, 1);
        v22 = *v21;
      }
      while ( *v21 );
    }
  }
  dword_8062518 = (int)sub_80563C0(0);
  sub_8056450((int *)dword_8062518, 0x3Au, 1);
  if ( byte_8062455 && dword_8062360 )
    byte_8062455 = 0;
  if ( (unsigned int)(dword_80624E8 - 1) <= 1 && !v10 )
  {
    if ( !dword_8062360 )
      goto LABEL_176;
    dword_806244C = 4;
  }
  if ( dword_8062360 )
  {
LABEL_112:
    v126 = (char *)optind;
    if ( !byte_806235C )
      goto LABEL_113;
    v52 = getenv("LS_COLORS");
    v140 = v52;
    if ( !v52 || !*v52 )
      goto LABEL_195;
    strcpy(s1, "??");
    v95 = 0;
    v96 = sub_8058BD0(v52);
    v97 = 0;
    ptr = v96;
    v141 = (char *)v96;
    while ( 1 )
    {
      switch ( v97 )
      {
        case 0:
          v109 = *v140;
          if ( *v140 == 42 )
          {
            v110 = sub_8058A70(0x14u);
            ++v140;
            v95 = v110;
            v111 = dword_8062CB0;
            dword_8062CB0 = v95;
            v95[4] = v111;
            v95[1] = v141;
            v97 = (unsigned __int8)sub_804C010(&v141, &v140, 1, v95) == 0 ? 5 : 3;
          }
          else if ( v109 == 58 )
          {
            ++v140;
          }
          else
          {
            if ( !v109 )
            {
LABEL_336:
              if ( dword_8062218 == 6 && !strncmp(::s1, "target", 6u) )
                byte_806235D = 1;
LABEL_195:
              if ( byte_806235C )
              {
                if ( sub_804BF90(13) || sub_804BF90(14) && byte_806235D || sub_804BF90(12) && !dword_8062360 )
                  byte_8062364 = 1;
                if ( tcgetpgrp(1) >= 0 )
                {
                  v53 = 0;
                  sigemptyset(&set);
                  do
                  {
                    v54 = sig[v53];
                    sigaction(v54, 0, &v132);
                    if ( v132.sa_handler != (__sighandler_t)1 )
                      sigaddset(&set, v54);
                    ++v53;
                  }
                  while ( v53 != 12 );
                  LOBYTE(v53) = 0;
                  qmemcpy(&v132.sa_mask, &set, sizeof(v132.sa_mask));
                  v132.sa_flags = 0x10000000;
                  do
                  {
                    v55 = sig[v53];
                    if ( sigismember(&set, v55) )
                    {
                      v56 = (void (*)(int))sub_804CF70;
                      if ( v55 != 20 )
                        v56 = (void (*)(int))sub_804BF70;
                      v132.sa_handler = v56;
                      sigaction(v55, &v132, 0);
                    }
                    ++v53;
                  }
                  while ( v53 != 12 );
                }
              }
LABEL_113:
              if ( dword_8062400 == 1 )
              {
                v58 = 2;
                if ( !byte_8062404 && dword_8062408 != 3 )
                  v58 = dword_8062360 == 0 ? 2 : 4;
                dword_8062400 = v58;
              }
              if ( byte_806240C )
              {
                dword_8062410 = sub_8053140(0x1Eu, 0, (int (*)())sub_804BEF0, (int (*)())sub_804BF20, (int)j__free);
                if ( !dword_8062410 )
LABEL_324:
                  sub_8058C00();
                _obstack_begin(&stru_8062420, 0, 0, (void *(*)(int))malloc, free);
              }
              if ( dword_806244C == 2 || dword_806244C == 4 || !dword_8062360 || byte_8062450 || byte_8062451 )
              {
                byte_8062452 = 1;
                goto LABEL_118;
              }
              v23 = 1;
              byte_8062452 = 0;
              if ( !byte_806240C && !byte_806235C && !dword_8062408 && !byte_8062453 )
LABEL_118:
                v23 = 0;
              byte_8062454 = v23;
              if ( byte_8062455 )
              {
                _obstack_begin(&stru_8062460, 0, 0, (void *(*)(int))malloc, free);
                _obstack_begin(&stru_80624A0, 0, 0, (void *(*)(int))malloc, free);
              }
              dword_80624CC = 100;
              *(_QWORD *)&qword_80624D0 = (unsigned int)sub_8058A70(0x3200u);
              sub_804C320();
              v24 = argc - (_DWORD)v126;
              if ( argc - (int)v126 <= 0 )
              {
                if ( byte_8062404 )
                  sub_804EB40(".", 3u, 1u, (char *)"");
                else
                  sub_804C2B0(".", 0, 1);
              }
              else
              {
                v25 = (int)v126;
                do
                {
                  v26 = a2[v25++];
                  sub_804EB40(v26, 0, 1u, (char *)"");
                }
                while ( argc > v25 );
                v24 = argc - (_DWORD)v126;
              }
              if ( !*(&qword_80624D0 + 1) )
                goto LABEL_126;
              sub_804C3F0();
              if ( !byte_8062404 )
                sub_804C810(0, 1);
              if ( *(&qword_80624D0 + 1) )
              {
                sub_804FA80();
                v124 = dword_8062350;
                if ( dword_8062350 )
                {
                  v98 = stdout;
                  IO_write_ptr = stdout->_IO_write_ptr;
                  if ( IO_write_ptr >= stdout->_IO_write_end )
                  {
                    __overflow(stdout, 10);
                  }
                  else
                  {
                    *IO_write_ptr = 10;
                    v98->_IO_write_ptr = IO_write_ptr + 1;
                  }
                  ++dword_80624D8;
                  v124 = dword_8062350;
                }
              }
              else
              {
LABEL_126:
                v124 = dword_8062350;
                if ( v24 <= 1 && dword_8062350 && !*(_DWORD *)(dword_8062350 + 12) )
                  byte_806234C = 0;
              }
LABEL_127:
              if ( !v124 )
                goto LABEL_235;
              while ( 1 )
              {
                dword_8062350 = *(_DWORD *)(v124 + 12);
                if ( dword_8062410 && !*(_DWORD *)v124 )
                {
                  next_free = stru_8062420.next_free;
                  if ( (unsigned int)(stru_8062420.next_free - stru_8062420.object_base) <= 0xF )
                    __assert_fail(
                      "sizeof (struct dev_ino) <= __extension__ ({ struct obstack const *__o = (&dev_ino_obstack); (unsig"
                      "ned) (__o->next_free - __o->object_base); })",
                      "ls.c",
                      0x3D5u,
                      "dev_ino_pop");
                  if ( stru_8062420.chunk_limit - stru_8062420.next_free < -16 )
                  {
                    _obstack_newchunk(&stru_8062420, -16);
                    next_free = stru_8062420.next_free;
                  }
                  stru_8062420.next_free = next_free - 16;
                  qmemcpy(v136, next_free - 16, sizeof(v136));
                  v73 = (void *)sub_8053710((int)dword_8062410, (int)v136);
                  if ( !v73 )
                    __assert_fail("found", "ls.c", 0x59Du, "main");
                  free(v73);
                  free(*(void **)v124);
                  free(*(void **)(v124 + 4));
                  free((void *)v124);
                  v124 = dword_8062350;
                  goto LABEL_127;
                }
                v27 = *(const char **)v124;
                v28 = *(_DWORD *)(v124 + 4);
                v127 = *(char **)v124;
                v121 = *(unsigned __int8 *)(v124 + 8);
                v29 = __errno_location();
                *v29 = 0;
                v131 = v29;
                v130 = opendir(v27);
                if ( !v130 )
                {
                  v81 = dcgettext(0, "cannot open directory %s", 5);
                  sub_804D570(v121, v81, (int)v27);
                  goto LABEL_234;
                }
                if ( dword_8062410 )
                {
                  v30 = dirfd(v130);
                  if ( v30 < 0 )
                    v31 = (unsigned int)__xstat64(3, v127, &v133) >> 31;
                  else
                    v31 = (unsigned int)__fxstat64(3, v30, &v133) >> 31;
                  if ( (_BYTE)v31 )
                  {
                    v70 = dcgettext(0, "cannot determine device and inode of %s", 5);
                    sub_804D570(v121, v70, (int)v127);
                    closedir(v130);
                    goto LABEL_234;
                  }
                  v122 = v135;
                  v119 = v133;
                  v120 = v134;
                  v32 = sub_8058A70(0x10u);
                  *(_QWORD *)v32 = v122;
                  v32[3] = v120;
                  v32[2] = v119;
                  v33 = sub_80536D0((int)dword_8062410, (int)v32);
                  if ( !v33 )
                    goto LABEL_324;
                  if ( v32 != (_DWORD *)v33 )
                  {
                    free(v32);
                    v75 = sub_8056980((int)v127);
                    v76 = dcgettext(0, "%s: not listing already-listed directory", 5);
                    error(0, 0, v76, v75);
                    closedir(v130);
                    status = 2;
                    goto LABEL_234;
                  }
                  v34 = stru_8062420.next_free;
                  if ( stru_8062420.chunk_limit - stru_8062420.next_free <= 15 )
                  {
                    _obstack_newchunk(&stru_8062420, 16);
                    v34 = stru_8062420.next_free;
                  }
                  stru_8062420.next_free = v34 + 16;
                  v35 = v133;
                  *((_DWORD *)v34 + 3) = v134;
                  v36 = HIDWORD(v135);
                  *((_DWORD *)v34 + 2) = v35;
                  v37 = v135;
                  *((_DWORD *)v34 + 1) = v36;
                  *(_DWORD *)v34 = v37;
                }
                if ( byte_806240C || byte_806234C )
                {
                  if ( !byte_80622BC )
                  {
                    v38 = stdout;
                    v39 = stdout->_IO_write_ptr;
                    if ( v39 >= stdout->_IO_write_end )
                    {
                      __overflow(stdout, 10);
                    }
                    else
                    {
                      *v39 = 10;
                      v38->_IO_write_ptr = v39 + 1;
                    }
                    ++dword_80624D8;
                  }
                  byte_80622BC = 0;
                  if ( byte_8062455 )
                  {
                    fwrite_unlocked("  ", 1u, 2u, stdout);
                    dword_80624D8 += 2;
                    if ( byte_8062455 )
                    {
                      v74 = stru_80624A0.next_free;
                      if ( stru_80624A0.chunk_limit < stru_80624A0.next_free + 4 )
                      {
                        _obstack_newchunk(&stru_80624A0, 4);
                        v74 = stru_80624A0.next_free;
                      }
                      *(_DWORD *)v74 = dword_80624D8;
                      stru_80624A0.next_free += 4;
                    }
                  }
                  if ( !v28 )
                    v28 = (int)v127;
                  dword_80624D8 += sub_804CBF0(stdout, v28, (int *)dword_8062518, 0);
                  if ( byte_8062455 )
                  {
                    v40 = stru_80624A0.next_free;
                    if ( stru_80624A0.chunk_limit < stru_80624A0.next_free + 4 )
                    {
                      _obstack_newchunk(&stru_80624A0, 4);
                      v40 = stru_80624A0.next_free;
                    }
                    *(_DWORD *)v40 = dword_80624D8;
                    stru_80624A0.next_free += 4;
                  }
                  fwrite_unlocked(":\n", 1u, 2u, stdout);
                  dword_80624D8 += 2;
                }
                sub_804C320();
                v123 = 0LL;
                do
                {
                  while ( 1 )
                  {
                    *v131 = 0;
                    v41 = readdir64(v130);
                    v42 = v41;
                    if ( !v41 )
                      break;
                    v43 = (char *)(v41 + 19);
                    if ( dword_80624F0 == 2 )
                    {
LABEL_162:
                      v45 = dword_80624F4;
                      if ( dword_80624F4 )
                      {
                        while ( fnmatch(*(const char **)v45, v43, 4) )
                        {
                          v45 = *(_DWORD *)(v45 + 4);
                          if ( !v45 )
                            goto LABEL_165;
                        }
                      }
                      else
                      {
LABEL_165:
                        v46 = 0;
                        v47 = *(_BYTE *)(v42 + 18) - 1;
                        if ( v47 <= 0xDu )
                          v46 = dword_805B2E0[v47];
                        LODWORD(v48) = sub_804EB40(v43, v46, 0, v127);
                        v123 += v48;
                        if ( dword_8062360 == 1 && dword_806244C == -1 && !byte_8062451 && !byte_806240C )
                        {
                          sub_804C3F0();
                          sub_804FA80();
                          sub_804C320();
                        }
                      }
                    }
                    else if ( *(_BYTE *)(v41 + 19) == 46 )
                    {
                      if ( dword_80624F0 )
                      {
                        v69 = *(_BYTE *)(v41 + 20);
                        if ( v69 == 46 )
                          v69 = *(_BYTE *)(v42 + 21);
                        if ( v69 )
                          goto LABEL_162;
                      }
                    }
                    else
                    {
                      if ( dword_80624F0 )
                        goto LABEL_162;
                      v44 = dword_80624F8;
                      if ( !dword_80624F8 )
                        goto LABEL_162;
                      while ( fnmatch(*(const char **)v44, v43, 4) )
                      {
                        v44 = *(_DWORD *)(v44 + 4);
                        if ( !v44 )
                          goto LABEL_162;
                      }
                    }
                  }
                  if ( !*v131 )
                    break;
                  v59 = dcgettext(0, "reading directory %s", 5);
                  sub_804D570(v121, v59, (int)v127);
                }
                while ( *v131 == 75 );
                if ( closedir(v130) )
                {
                  v71 = dcgettext(0, "closing directory %s", 5);
                  sub_804D570(v121, v71, (int)v127);
                }
                sub_804C3F0();
                if ( byte_806240C )
                  sub_804C810(v127, v121);
                if ( !dword_8062360 || byte_8062451 )
                {
                  if ( byte_8062455 )
                  {
                    fwrite_unlocked("  ", 1u, 2u, stdout);
                    dword_80624D8 += 2;
                  }
                  v60 = dcgettext(0, "total", 5);
                  fputs_unlocked(v60, stdout);
                  v61 = strlen(v60);
                  v62 = stdout;
                  dword_80624D8 += v61;
                  v63 = stdout->_IO_write_ptr;
                  if ( v63 >= stdout->_IO_write_end )
                  {
                    __overflow(stdout, 32);
                  }
                  else
                  {
                    *v63 = 32;
                    v62->_IO_write_ptr = v63 + 1;
                  }
                  ++dword_80624D8;
                  v64 = sub_8053850(v123, (int)v142, dword_80624FC, 512LL, qword_8062500);
                  fputs_unlocked(v64, stdout);
                  dword_80624D8 += strlen(v64);
                  v65 = stdout;
                  v66 = stdout->_IO_write_ptr;
                  if ( v66 >= stdout->_IO_write_end )
                  {
                    __overflow(stdout, 10);
                  }
                  else
                  {
                    *v66 = 10;
                    v65->_IO_write_ptr = v66 + 1;
                  }
                  ++dword_80624D8;
                }
                if ( *(&qword_80624D0 + 1) )
                  sub_804FA80();
LABEL_234:
                free(*(void **)v124);
                free(*(void **)(v124 + 4));
                free((void *)v124);
                byte_806234C = 1;
                v124 = dword_8062350;
                if ( !dword_8062350 )
                {
LABEL_235:
                  if ( byte_806235C )
                  {
                    if ( byte_80624DC
                      && (dword_80621E0[0] != 2
                       || memcmp(off_80621E4, "\x1B[", 2u)
                       || dword_80621E8 != 1
                       || *off_80621EC != 109) )
                    {
                      sub_804D9D0();
                    }
                    v67 = 0;
                    fflush_unlocked(stdout);
                    do
                    {
                      v68 = sig[v67];
                      if ( sigismember(&set, v68) )
                        signal(v68, 0);
                      ++v67;
                    }
                    while ( v67 != 12 );
                    for ( i = dword_8062340; i; --i )
                      raise(19);
                    if ( dword_8062344 )
                      raise(dword_8062344);
                  }
                  if ( byte_8062455 )
                  {
                    sub_804CA20((FILE *)"//DIRED//", (int)&stru_8062460);
                    sub_804CA20((FILE *)"//SUBDIRED//", (int)&stru_80624A0);
                    v83 = sub_8056410((int *)dword_80624E0);
                    __printf_chk(
                      1,
                      "//DIRED-OPTIONS// --quoting-style=%s\n",
                      *((const char **)&stru_805D800._flags + v83));
                  }
                  if ( dword_8062410 )
                  {
                    if ( sub_8052D20((int)dword_8062410) )
                      __assert_fail("hash_get_n_entries (active_dir_set) == 0", "ls.c", 0x5DCu, "main");
                    sub_80532B0(dword_8062410);
                  }
                  exit(status);
                }
              }
            }
            v97 = 1;
            s1[0] = *v140++;
          }
          break;
        case 1:
          v97 = 5;
          if ( *v140 )
          {
            LOBYTE(v97) = 2;
            s1[1] = *v140++;
          }
          continue;
        case 2:
          v107 = *v140++;
          if ( v107 != 61 )
            goto LABEL_340;
          for ( j = 0; ; ++j )
          {
            if ( !(&off_805B140)[j] )
              goto LABEL_355;
            if ( !strcmp(s1, (&off_805B140)[j]) )
              break;
          }
          *(&off_80621E4 + 2 * j) = v141;
          v112 = sub_804C010(&v141, &v140, 0, &dword_80621E0[2 * j]);
          v97 = 0;
          if ( !v112 )
          {
LABEL_355:
            v113 = sub_8056780((int)s1);
            v114 = dcgettext(0, "unrecognized prefix: %s", 5);
            error(0, 0, v114, v113);
LABEL_340:
            v97 = 5;
          }
          continue;
        case 3:
          v106 = *v140++;
          v97 = 5;
          if ( v106 == 61 )
          {
            v95[3] = v141;
            v97 = (unsigned __int8)sub_804C010(&v141, &v140, 0, v95 + 2) == 0 ? 5 : 0;
          }
          continue;
        case 5:
          v103 = dcgettext(0, "unparsable value for LS_COLORS environment variable", 5);
          error(0, 0, v103);
          free(ptr);
          for ( k = dword_8062CB0; k; k = v105 )
          {
            v105 = (_DWORD *)k[4];
            free(k);
          }
          byte_806235C = 0;
          goto LABEL_336;
        default:
          goto LABEL_4;
      }
    }
  }
LABEL_176:
  if ( !v125 )
  {
    v100 = getenv("TIME_STYLE");
    v129 = v100;
    v101 = v100 == 0;
    v102 = 134586719;
    if ( !v101 )
      v102 = (int)v129;
    v125 = (char *)v102;
  }
  while ( !memcmp(v125, &stru_805B080._unused2[28], 6u) )
  {
    if ( !sub_8052890(2) )
      goto LABEL_112;
    v125 += 6;
  }
  if ( *v125 == 43 )
  {
    v90 = strchr(v125 + 1, 10);
    v91 = v125 + 1;
    v92 = v90;
    if ( v90 )
    {
      v117 = v90 + 1;
      v93 = strchr(v90 + 1, 10);
      v91 = v117;
      if ( v93 )
      {
        v118 = sub_80556C0((int)(v125 + 1));
        v94 = dcgettext(0, "invalid time style format %s", 5);
        error(2, 0, v94, v118);
        v91 = v117;
      }
      *v92 = 0;
    }
    off_80622AC = v125 + 1;
    haystack = v91;
  }
  else
  {
    v49 = dword_805B124[sub_8051EE0(
                          (int)"time style",
                          v125,
                          (_IO_FILE *)&stru_805B080._unused2[36],
                          dword_805B124,
                          4u,
                          off_80622C8)];
    switch ( v49 )
    {
      case 1:
        haystack = (char *)&unk_805A278;
        off_80622AC = (char *)&unk_805A278;
LABEL_185:
        if ( !strstr(haystack, "%b") )
          goto LABEL_112;
LABEL_288:
        dword_806251C = 5;
        do
        {
          v84 = dword_806251C;
          v85 = 131086;
          dword_806251C = 0;
          v128 = (char *)v84;
          v86 = (char *)&unk_8062520;
          do
          {
            longind = (int)v128;
            v87 = nl_langinfo(v85);
            if ( (unsigned int)sub_8054CE0(v87, (int)v86, 161, (int)&longind, 0, 0) > 0xA0 )
            {
              dword_806251C = 0;
              goto LABEL_298;
            }
            v88 = longind;
            if ( dword_806251C >= (unsigned int)longind )
              v88 = dword_806251C;
            ++v85;
            v86 += 161;
            dword_806251C = v88;
          }
          while ( v85 != 131098 );
        }
        while ( v88 < (unsigned int)v128 );
        if ( !v88 )
        {
LABEL_298:
          v89 = dcgettext(0, "error initializing month strings", 5);
          error(0, 0, v89);
        }
        goto LABEL_112;
      case 0:
        haystack = "%Y-%m-%d %H:%M:%S.%N %z";
        off_80622AC = "%Y-%m-%d %H:%M:%S.%N %z";
        goto LABEL_185;
      case 2:
        off_80622AC = "%Y-%m-%d ";
        haystack = "%m-%d %H:%M";
        break;
      default:
        if ( v49 == 3 && sub_8052890(2) )
        {
          off_80622AC = dcgettext(0, off_80622AC, 2);
          haystack = dcgettext(0, haystack, 2);
        }
        break;
    }
  }
  if ( strstr(off_80622AC, "%b") )
    goto LABEL_288;
  goto LABEL_185;
}
// 804AAEC: variable 'v48' is possibly undefined
// 8049760: using guessed type int __cdecl __fxstat64(_DWORD, _DWORD, _DWORD);
// 8049870: using guessed type int __cdecl fputs_unlocked(_DWORD, _DWORD);
// 8049980: using guessed type int __printf_chk(_DWORD, const char *, ...);
// 8049A50: using guessed type int __cdecl readdir64(_DWORD);
// 8049AD0: using guessed type int __cdecl __xstat64(_DWORD, _DWORD, _DWORD);
// 805ACE0: using guessed type int sig[12];
// 805B124: using guessed type int dword_805B124[7];
// 805B2E0: using guessed type int dword_805B2E0[14];
// 805D7E0: using guessed type int dword_805D7E0[8];
// 80621E0: using guessed type int dword_80621E0[];
// 80621E8: using guessed type int dword_80621E8;
// 80621EC: using guessed type char *off_80621EC;
// 8062218: using guessed type int dword_8062218;
// 80622A0: using guessed type __int64 qword_80622A0;
// 80622A8: using guessed type char byte_80622A8;
// 80622A9: using guessed type char byte_80622A9;
// 80622BC: using guessed type char byte_80622BC;
// 80622C0: using guessed type int dword_80622C0;
// 80622C4: using guessed type char *off_80622C4;
// 8062308: using guessed type int optind;
// 8062340: using guessed type int dword_8062340;
// 806234C: using guessed type char byte_806234C;
// 8062350: using guessed type int dword_8062350;
// 806235C: using guessed type char byte_806235C;
// 806235D: using guessed type char byte_806235D;
// 8062360: using guessed type int dword_8062360;
// 8062364: using guessed type char byte_8062364;
// 8062400: using guessed type int dword_8062400;
// 8062404: using guessed type char byte_8062404;
// 8062408: using guessed type int dword_8062408;
// 806240C: using guessed type char byte_806240C;
// 806244C: using guessed type int dword_806244C;
// 8062450: using guessed type char byte_8062450;
// 8062451: using guessed type char byte_8062451;
// 8062452: using guessed type char byte_8062452;
// 8062453: using guessed type char byte_8062453;
// 8062454: using guessed type char byte_8062454;
// 8062455: using guessed type char byte_8062455;
// 80624CC: using guessed type int dword_80624CC;
// 80624D8: using guessed type int dword_80624D8;
// 80624DC: using guessed type char byte_80624DC;
// 80624E0: using guessed type int dword_80624E0;
// 80624E4: using guessed type char byte_80624E4;
// 80624E8: using guessed type int dword_80624E8;
// 80624EC: using guessed type char byte_80624EC;
// 80624ED: using guessed type char byte_80624ED;
// 80624EE: using guessed type char byte_80624EE;
// 80624F0: using guessed type int dword_80624F0;
// 80624F4: using guessed type int dword_80624F4;
// 80624F8: using guessed type int dword_80624F8;
// 80624FC: using guessed type int dword_80624FC;
// 8062500: using guessed type __int64 qword_8062500;
// 8062508: using guessed type int dword_8062508;
// 806250C: using guessed type int dword_806250C;
// 8062510: using guessed type char byte_8062510;
// 8062514: using guessed type int dword_8062514;
// 8062518: using guessed type int dword_8062518;
// 806251C: using guessed type int dword_806251C;

//----- (0804BE34) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __usercall __noreturn start(int a1@<eax>, void (*a2)(void)@<edx>)
{
  int v2; // esi
  int v3; // [esp-4h] [ebp-4h] BYREF
  char *retaddr; // [esp+0h] [ebp+0h] BYREF

  v2 = v3;
  v3 = a1;
  __libc_start_main((int (__cdecl *)(int, char **, char **))main, v2, &retaddr, (void (*)(void))init, fini, a2, &v3);
  __halt();
}
// 804BE37: positive sp value 4 has been found

//----- (0804BE60) --------------------------------------------------------
void sub_804BE60()
{
  int v0; // eax
  unsigned int i; // ebx

  if ( !byte_8062328 )
  {
    v0 = dword_806232C;
    for ( i = ((&unk_8061F04 - (_UNKNOWN *)dword_8061F00) >> 2) - 1; dword_806232C < i; v0 = dword_806232C )
    {
      dword_806232C = v0 + 1;
      ((void (*)(void))dword_8061F00[v0 + 1])();
    }
    byte_8062328 = 1;
  }
}
// 8061F00: using guessed type int dword_8061F00[];
// 8062328: using guessed type char byte_8062328;
// 806232C: using guessed type int dword_806232C;

//----- (0804BEC0) --------------------------------------------------------
int sub_804BEC0()
{
  int result; // eax

  result = dword_8061F08;
  if ( dword_8061F08 )
    return 0;
  return result;
}
// 8061F08: using guessed type int dword_8061F08;

//----- (0804BEF0) --------------------------------------------------------
int __cdecl sub_804BEF0(unsigned __int64 *a1, unsigned int a2)
{
  return sub_8059DC0(*a1, a2);
}

//----- (0804BF20) --------------------------------------------------------
bool __cdecl sub_804BF20(_QWORD *a1, _QWORD *a2)
{
  bool result; // al

  result = 0;
  if ( *a2 == *a1 )
    return a2[1] == a1[1];
  return result;
}

//----- (0804BF70) --------------------------------------------------------
int __cdecl sub_804BF70(int a1)
{
  int result; // eax

  result = dword_8062344;
  if ( !dword_8062344 )
  {
    result = a1;
    dword_8062344 = a1;
  }
  return result;
}

//----- (0804BF90) --------------------------------------------------------
bool __usercall sub_804BF90@<al>(int a1@<eax>)
{
  int v1; // edx
  _BYTE *v2; // esi
  bool result; // al

  v1 = dword_80621E0[2 * a1];
  v2 = *(&off_80621E4 + 2 * a1);
  result = 0;
  if ( v1 )
  {
    if ( v1 == 1 )
    {
      return *v2 != 48;
    }
    else
    {
      result = 1;
      if ( v1 == 2 )
        return memcmp(v2, &unk_805A068, 2u) != 0;
    }
  }
  return result;
}
// 80621E0: using guessed type int dword_80621E0[];

//----- (0804C010) --------------------------------------------------------
int __usercall sub_804C010@<eax>(char **a1@<eax>, char **a2@<edx>, char a3@<cl>, _DWORD *a4)
{
  unsigned int v4; // edi
  int v5; // esi
  char *v6; // ebx
  char *v7; // ecx
  int result; // eax
  char v9; // di
  char v10; // dl
  bool v11; // cc
  char v12; // di
  char **v13; // edx
  int v14; // edi
  int v15; // edi
  char v16; // dl
  _BYTE *v17; // ecx

  v4 = 0;
  v5 = 0;
  v6 = *a1;
  v7 = *a2;
  result = 0;
  while ( 2 )
  {
    if ( v4 == 2 )
    {
      while ( 1 )
      {
        v14 = (unsigned __int8)*v7;
        if ( (unsigned __int8)(v14 - 48) > 7u )
          break;
        result = v14 + 8 * result - 48;
        ++v7;
      }
      goto LABEL_14;
    }
    if ( v4 > 2 )
    {
LABEL_19:
      v15 = (unsigned __int8)*v7;
      v16 = v15 - 48;
      while ( 2 )
      {
        switch ( v16 )
        {
          case 0:
          case 1:
          case 2:
          case 3:
          case 4:
          case 5:
          case 6:
          case 7:
          case 8:
          case 9:
            ++v7;
            result = v15 + 16 * result - 48;
            v15 = (unsigned __int8)*v7;
            v16 = v15 - 48;
            if ( (unsigned __int8)(v15 - 48) <= 0x36u )
              continue;
            break;
          case 17:
          case 18:
          case 19:
          case 20:
          case 21:
          case 22:
            ++v7;
            result = v15 + 16 * result - 55;
            v15 = (unsigned __int8)*v7;
            v16 = v15 - 48;
            if ( (unsigned __int8)(v15 - 48) <= 0x36u )
              continue;
            break;
          case 49:
          case 50:
          case 51:
          case 52:
          case 53:
          case 54:
            ++v7;
            result = v15 + 16 * result - 87;
            goto LABEL_19;
          default:
            goto LABEL_14;
        }
        break;
      }
LABEL_14:
      *v6 = result;
      v9 = *v7;
      ++v6;
      ++v5;
      v10 = *v7;
      v11 = *v7 <= 61;
      if ( *v7 == 61 )
        goto LABEL_15;
      goto LABEL_5;
    }
    while ( 1 )
    {
      while ( 1 )
      {
        v9 = *v7;
        v10 = *v7;
        v11 = *v7 <= 61;
        if ( *v7 == 61 )
        {
LABEL_15:
          if ( a3 )
          {
            v13 = a2;
            result = 1;
            goto LABEL_11;
          }
          goto LABEL_28;
        }
LABEL_5:
        if ( !v11 )
          break;
        if ( !v10 || v10 == 58 )
        {
          v13 = a2;
          v4 = 5;
          goto LABEL_31;
        }
LABEL_28:
        ++v7;
        *v6 = v9;
        ++v5;
        ++v6;
      }
      if ( v9 == 92 )
        break;
      if ( v9 != 94 )
        goto LABEL_28;
      v12 = *++v7;
      if ( (unsigned __int8)(*v7 - 64) <= 0x3Eu )
      {
        v9 = v12 & 0x1F;
        goto LABEL_28;
      }
      if ( v12 != 63 )
      {
        v13 = a2;
        result = 0;
        goto LABEL_11;
      }
      *v6 = 127;
      ++v5;
      ++v6;
    }
    v17 = v7 + 1;
    switch ( *v17 )
    {
      case 0:
        v4 = 6;
        goto LABEL_24;
      case 0x30:
      case 0x31:
      case 0x32:
      case 0x33:
      case 0x34:
      case 0x35:
      case 0x36:
      case 0x37:
        result = (unsigned __int8)*v17 - 48;
        v4 = 2;
        goto LABEL_24;
      case 0x3F:
        result = 127;
        goto LABEL_23;
      case 0x58:
      case 0x78:
        v4 = 3;
        result = 0;
        goto LABEL_24;
      case 0x5F:
        result = 32;
        goto LABEL_23;
      case 0x61:
        result = 7;
        goto LABEL_23;
      case 0x62:
        result = 8;
        goto LABEL_23;
      case 0x65:
        result = 27;
        goto LABEL_23;
      case 0x66:
        result = 12;
        goto LABEL_23;
      case 0x6E:
        result = 10;
        goto LABEL_23;
      case 0x72:
        result = 13;
        goto LABEL_23;
      case 0x74:
        result = 9;
        goto LABEL_23;
      case 0x76:
        result = 11;
        goto LABEL_23;
      default:
        result = (unsigned __int8)*v17;
LABEL_23:
        *v6 = result;
        ++v5;
        ++v6;
        v4 = 0;
LABEL_24:
        v7 = v17 + 1;
        if ( v4 <= 4 )
          continue;
        v13 = a2;
        break;
    }
    break;
  }
LABEL_31:
  LOBYTE(result) = v4 != 6;
LABEL_11:
  *a1 = v6;
  *v13 = v7;
  *a4 = v5;
  return result;
}
// 804C03A: conditional instruction was optimized away because edi.4==0
// 804C0E3: conditional instruction was optimized away because edi.4==3

//----- (0804C280) --------------------------------------------------------
_DWORD *__usercall sub_804C280@<eax>(int a1@<eax>)
{
  _DWORD *result; // eax
  int v3; // edx

  result = sub_8058A70(8u);
  v3 = dword_80624F4;
  *result = a1;
  result[1] = v3;
  dword_80624F4 = (int)result;
  return result;
}
// 80624F4: using guessed type int dword_80624F4;

//----- (0804C2B0) --------------------------------------------------------
int __usercall sub_804C2B0@<eax>(char *a1@<eax>, char *a2@<edx>, char a3@<cl>)
{
  _DWORD *v6; // edi
  void *v7; // eax
  void *v8; // eax
  int result; // eax

  v6 = sub_8058A70(0x10u);
  v7 = 0;
  if ( a2 )
    v7 = sub_8058BD0(a2);
  v6[1] = v7;
  v8 = 0;
  if ( a1 )
    v8 = sub_8058BD0(a1);
  *v6 = v8;
  *((_BYTE *)v6 + 8) = a3;
  result = dword_8062350;
  dword_8062350 = (int)v6;
  v6[3] = result;
  return result;
}
// 8062350: using guessed type int dword_8062350;

//----- (0804C320) --------------------------------------------------------
void *sub_804C320()
{
  void *result; // eax
  unsigned int v1; // ebx
  int v2; // esi

  result = (void *)dword_80624D4;
  if ( dword_80624D4 )
  {
    v1 = 0;
    do
    {
      v2 = *((_DWORD *)dword_8062CB4 + v1);
      free(*(void **)v2);
      free(*(void **)(v2 + 4));
      result = *(void **)(v2 + 112);
      if ( result != &unk_80622B4 )
        result = (void *)freecon(*(_DWORD *)(v2 + 112));
      ++v1;
    }
    while ( dword_80624D4 > v1 );
  }
  dword_80624D4 = 0;
  byte_8062CB8 = 0;
  dword_8062CBC = 0;
  dword_8062CC0 = 0;
  dword_8062CC4 = 0;
  dword_8062CC8 = 0;
  dword_8062CCC = 0;
  dword_8062CD0 = 0;
  dword_8062CD4 = 0;
  dword_8062CD8 = 0;
  dword_8062CDC = 0;
  dword_8062CE0 = 0;
  return result;
}
// 8049A30: using guessed type int __cdecl freecon(_DWORD);
// 80624D4: using guessed type int dword_80624D4;
// 8062CB8: using guessed type char byte_8062CB8;
// 8062CBC: using guessed type int dword_8062CBC;
// 8062CC0: using guessed type int dword_8062CC0;
// 8062CC4: using guessed type int dword_8062CC4;
// 8062CC8: using guessed type int dword_8062CC8;
// 8062CCC: using guessed type int dword_8062CCC;
// 8062CD0: using guessed type int dword_8062CD0;
// 8062CD4: using guessed type int dword_8062CD4;
// 8062CD8: using guessed type int dword_8062CD8;
// 8062CDC: using guessed type int dword_8062CDC;
// 8062CE0: using guessed type int dword_8062CE0;

//----- (0804C3F0) --------------------------------------------------------
unsigned int sub_804C3F0()
{
  unsigned int v0; // ebx
  unsigned int result; // eax
  _DWORD *v2; // ecx
  char *v3; // edx
  int v4; // eax
  int v5; // esi
  unsigned int v6; // ecx
  int v7; // eax
  _DWORD *v8; // ebx
  char *v9; // edx
  int v10; // edx
  int v11; // eax
  void *v12; // eax

  v0 = dword_80624D4;
  result = dword_80624D4 + ((unsigned int)dword_80624D4 >> 1);
  if ( result > dword_8062CE4 )
  {
    free(dword_8062CB4);
    if ( v0 > 0x15555555 )
      sub_8058C00();
    v12 = sub_8058A70(12 * v0);
    v0 = dword_80624D4;
    dword_8062CB4 = v12;
    result = 3 * dword_80624D4;
    dword_8062CE4 = 3 * dword_80624D4;
  }
  if ( v0 )
  {
    v2 = dword_8062CB4;
    result = 0;
    v3 = (char *)dword_80624D0;
    do
    {
      v2[result++] = v3;
      v3 += 128;
    }
    while ( result != v0 );
  }
  if ( dword_806244C != -1 )
  {
    v4 = _setjmp(env);
    v5 = dword_806244C;
    if ( v4 )
    {
      if ( dword_806244C == 3 )
        __assert_fail("sort_type != sort_version", "ls.c", 0xD63u, "sort_files");
      v6 = dword_80624D4;
      v7 = 0;
      v8 = dword_8062CB4;
      v9 = (char *)dword_80624D0;
      if ( dword_80624D4 )
      {
        do
        {
          v8[v7++] = v9;
          v9 += 128;
        }
        while ( v7 != v6 );
      }
      v10 = 1;
    }
    else
    {
      v6 = dword_80624D4;
      v10 = 0;
      v8 = dword_8062CB4;
    }
    v11 = 0;
    if ( v5 == 4 )
      v11 = dword_80624E8;
    return (unsigned int)sub_80555B0(
                           v8,
                           v6,
                           (int (__cdecl *)(int, int))*(&off_805B1C0[8 * v5]
                                                      + 8 * v11
                                                      + 4 * v10
                                                      + 2 * (unsigned __int8)byte_80624EC
                                                      + (unsigned __int8)byte_8062453));
  }
  return result;
}
// 805B1C0: using guessed type int (__cdecl *off_805B1C0[4])(char *s1, char *s2);
// 806244C: using guessed type int dword_806244C;
// 8062453: using guessed type char byte_8062453;
// 80624D4: using guessed type int dword_80624D4;
// 80624E8: using guessed type int dword_80624E8;
// 80624EC: using guessed type char byte_80624EC;
// 8062CE4: using guessed type int dword_8062CE4;

//----- (0804C550) --------------------------------------------------------
int __cdecl sub_804C550(const char **a1, const char **a2)
{
  return strcmp(*a1, *a2);
}

//----- (0804C570) --------------------------------------------------------
int __cdecl sub_804C570(const char **a1, const char **a2)
{
  return strcmp(*a2, *a1);
}

//----- (0804C590) --------------------------------------------------------
int __cdecl sub_804C590(int a1, int a2)
{
  bool v2; // al

  v2 = *(_DWORD *)(a2 + 104) == 3 || *(_DWORD *)(a2 + 104) == 9;
  if ( *(_DWORD *)(a1 + 104) == 3 || *(_DWORD *)(a1 + 104) == 9 )
  {
    if ( v2 )
      return strcmp(*(const char **)a1, *(const char **)a2);
    return -1;
  }
  else
  {
    if ( !v2 )
      return strcmp(*(const char **)a1, *(const char **)a2);
    return 1;
  }
}

//----- (0804C620) --------------------------------------------------------
int __cdecl sub_804C620(int a1, int a2)
{
  bool v2; // al

  v2 = *(_DWORD *)(a2 + 104) == 3 || *(_DWORD *)(a2 + 104) == 9;
  if ( *(_DWORD *)(a1 + 104) == 3 || *(_DWORD *)(a1 + 104) == 9 )
  {
    if ( v2 )
      return strcmp(*(const char **)a2, *(const char **)a1);
    return -1;
  }
  else
  {
    if ( !v2 )
      return strcmp(*(const char **)a2, *(const char **)a1);
    return 1;
  }
}

//----- (0804C6B0) --------------------------------------------------------
int __cdecl sub_804C6B0(char *a1, char *a2)
{
  bool v2; // dl

  v2 = *((_DWORD *)a2 + 26) == 9 || *((_DWORD *)a2 + 26) == 3;
  if ( *((_DWORD *)a1 + 26) == 3 || *((_DWORD *)a1 + 26) == 9 )
  {
    if ( v2 )
      return sub_80524B0(*(char **)a2, *(char **)a1);
    return -1;
  }
  else
  {
    if ( !v2 )
      return sub_80524B0(*(char **)a2, *(char **)a1);
    return 1;
  }
}

//----- (0804C740) --------------------------------------------------------
int __cdecl sub_804C740(char *a1, char *a2)
{
  return sub_80524B0(*(char **)a2, *(char **)a1);
}

//----- (0804C760) --------------------------------------------------------
int __cdecl sub_804C760(char *a1, char *a2)
{
  bool v2; // dl

  v2 = *((_DWORD *)a2 + 26) == 9 || *((_DWORD *)a2 + 26) == 3;
  if ( *((_DWORD *)a1 + 26) == 3 || *((_DWORD *)a1 + 26) == 9 )
  {
    if ( v2 )
      return sub_80524B0(*(char **)a1, *(char **)a2);
    return -1;
  }
  else
  {
    if ( !v2 )
      return sub_80524B0(*(char **)a1, *(char **)a2);
    return 1;
  }
}

//----- (0804C7F0) --------------------------------------------------------
int __cdecl sub_804C7F0(char *a1, char *a2)
{
  return sub_80524B0(*(char **)a1, *(char **)a2);
}

//----- (0804C810) --------------------------------------------------------
int __usercall sub_804C810@<eax>(char *a1@<eax>, char a2@<dl>)
{
  int v4; // edi
  int v5; // esi
  void **v6; // ebx
  char *v7; // eax
  _BYTE *v8; // eax
  int v9; // ebx
  int v10; // esi
  int result; // eax
  _DWORD *v12; // ecx
  int v13; // edx
  bool v14; // zf
  char v15; // al
  char *ptr; // [esp+18h] [ebp-24h]
  char v17; // [esp+1Ch] [ebp-20h]

  if ( a1 && dword_8062410 )
    sub_804C2B0(0, a1, 0);
  v17 = a2;
  v4 = 4 * dword_80624D4 - 4;
  v5 = dword_80624D4;
  while ( v5 )
  {
    --v5;
    v6 = *(void ***)((char *)dword_8062CB4 + v4);
    if ( v6[26] != (void *)3 && v6[26] != (void *)9 )
      goto LABEL_6;
    v7 = (char *)*v6;
    if ( !a1 )
      goto LABEL_5;
    v8 = sub_80520B0(*v6);
    if ( *v8 != 46 || (v15 = v8[(v8[1] == 46) + 1], v15 != 0 && v15 != 47) )
    {
      v7 = (char *)*v6;
      if ( *(_BYTE *)*v6 == 47 )
      {
LABEL_5:
        sub_804C2B0(v7, (char *)v6[1], v17);
        if ( v6[26] != (void *)9 )
          goto LABEL_6;
      }
      else
      {
        ptr = (char *)sub_80522E0((int)a1, v7, 0);
        sub_804C2B0(ptr, (char *)v6[1], v17);
        free(ptr);
        if ( v6[26] != (void *)9 )
          goto LABEL_6;
      }
      free(*v6);
    }
LABEL_6:
    v4 -= 4;
  }
  v9 = 0;
  v10 = dword_80624D4;
  result = 0;
  if ( dword_80624D4 )
  {
    v12 = dword_8062CB4;
    result = 0;
    do
    {
      v13 = v12[v9];
      v14 = *(_DWORD *)(v13 + 104) == 9;
      v12[result] = v13;
      ++v9;
      result += !v14;
    }
    while ( v9 != v10 );
  }
  dword_80624D4 = result;
  return result;
}
// 80624D4: using guessed type int dword_80624D4;

//----- (0804C970) --------------------------------------------------------
unsigned int __usercall sub_804C970@<eax>(unsigned int result@<eax>, unsigned int a2@<edx>)
{
  unsigned int v3; // ebx
  FILE *v4; // eax
  char *IO_write_ptr; // edx
  unsigned int v6; // ecx
  char *v7; // edx

  v3 = result;
  if ( result < a2 )
  {
    while ( 1 )
    {
      v6 = dword_806250C;
      if ( dword_806250C )
      {
        if ( a2 / dword_806250C > (v3 + 1) / dword_806250C )
        {
          v4 = stdout;
          IO_write_ptr = stdout->_IO_write_ptr;
          if ( IO_write_ptr >= stdout->_IO_write_end )
          {
            __overflow(stdout, 9);
            v6 = dword_806250C;
          }
          else
          {
            *IO_write_ptr = 9;
            v4->_IO_write_ptr = IO_write_ptr + 1;
          }
          result = v3 / v6;
          v3 = v6 + v3 - v3 % v6;
          goto LABEL_7;
        }
        ++v3;
      }
      else
      {
        ++v3;
      }
      result = (unsigned int)stdout;
      v7 = stdout->_IO_write_ptr;
      if ( v7 >= stdout->_IO_write_end )
      {
        result = __overflow(stdout, 32);
LABEL_7:
        if ( a2 <= v3 )
          return result;
      }
      else
      {
        *v7 = 32;
        *(_DWORD *)(result + 20) = v7 + 1;
        if ( a2 <= v3 )
          return result;
      }
    }
  }
  return result;
}
// 806250C: using guessed type int dword_806250C;

//----- (0804CA20) --------------------------------------------------------
FILE *__usercall sub_804CA20@<eax>(FILE *result@<eax>, int a2@<edx>)
{
  int v2; // ecx
  int v3; // edi
  unsigned int v4; // esi
  int v5; // ebp
  int v6; // ecx
  int v7; // ebx
  int v8; // eax
  char *IO_write_ptr; // edx

  v2 = *(_DWORD *)(a2 + 12);
  v3 = *(_DWORD *)(a2 + 8);
  v4 = (unsigned int)(v2 - v3) >> 2;
  if ( v4 )
  {
    if ( v2 == v3 )
      *(_BYTE *)(a2 + 40) |= 2u;
    v5 = *(_DWORD *)(a2 + 16);
    v6 = ~*(_DWORD *)(a2 + 24) & (*(_DWORD *)(a2 + 24) + v2);
    *(_DWORD *)(a2 + 12) = v6;
    if ( v6 - *(_DWORD *)(a2 + 4) > v5 - *(_DWORD *)(a2 + 4) )
      *(_DWORD *)(a2 + 12) = v5;
    v7 = 0;
    *(_DWORD *)(a2 + 8) = *(_DWORD *)(a2 + 12);
    fputs_unlocked(result, stdout);
    do
    {
      v8 = *(_DWORD *)(v3 + 4 * v7++);
      __printf_chk(1, " %lu", v8);
    }
    while ( v7 != v4 );
    result = stdout;
    IO_write_ptr = stdout->_IO_write_ptr;
    if ( IO_write_ptr >= stdout->_IO_write_end )
    {
      return (FILE *)__overflow(stdout, 10);
    }
    else
    {
      *IO_write_ptr = 10;
      result->_IO_write_ptr = IO_write_ptr + 1;
    }
  }
  return result;
}
// 8049870: using guessed type int __cdecl fputs_unlocked(_DWORD, _DWORD);
// 8049980: using guessed type int __printf_chk(_DWORD, const char *, ...);

//----- (0804CAE0) --------------------------------------------------------
size_t __usercall sub_804CAE0@<eax>(char *s@<eax>, int a2@<edx>, size_t a3@<ecx>)
{
  int v4; // esi
  size_t v5; // ebx
  FILE *v6; // eax
  char *IO_write_ptr; // edx
  size_t result; // eax

  if ( s )
  {
    v4 = a3 - sub_8055350(s, 0);
    if ( v4 < 0 )
      v4 = 0;
    fputs_unlocked(s, stdout);
    v5 = v4 + strlen(s);
    do
    {
      v6 = stdout;
      IO_write_ptr = stdout->_IO_write_ptr;
      if ( IO_write_ptr >= stdout->_IO_write_end )
      {
        __overflow(stdout, 32);
      }
      else
      {
        *IO_write_ptr = 32;
        v6->_IO_write_ptr = IO_write_ptr + 1;
      }
      --v4;
    }
    while ( v4 != -1 );
  }
  else
  {
    v5 = a3;
    __printf_chk(1, "%*lu ", a3, a2);
  }
  result = v5 + dword_80624D8 + 1;
  dword_80624D8 = result;
  return result;
}
// 8049870: using guessed type int __cdecl fputs_unlocked(_DWORD, _DWORD);
// 8049980: using guessed type int __printf_chk(_DWORD, const char *, ...);
// 80624D8: using guessed type int dword_80624D8;

//----- (0804CBA0) --------------------------------------------------------
size_t __usercall sub_804CBA0@<eax>(__uid_t a1@<eax>, size_t a2@<edx>, int a3@<ecx>)
{
  char *v4; // eax
  char *v6; // eax

  v4 = "?";
  if ( !a3 )
    return sub_804CAE0(v4, a1, a2);
  v4 = 0;
  if ( byte_80624ED )
    return sub_804CAE0(v4, a1, a2);
  v6 = (char *)sub_8054860(a1);
  return sub_804CAE0(v6, a1, a2);
}
// 80624ED: using guessed type char byte_80624ED;

//----- (0804CBF0) --------------------------------------------------------
__int64 __usercall sub_804CBF0@<edx:eax>(FILE *a1@<eax>, int a2@<edx>, int *a3@<ecx>, _DWORD *a4)
{
  unsigned int v5; // eax
  int v6; // edi
  __int64 result; // rax
  char *v8; // edx
  _BYTE *v9; // edi
  const char *v10; // esi
  char v11; // al
  size_t v12; // eax
  int v13; // ebx
  int v14; // eax
  int v15; // edx
  void *v16; // esp
  char *v17; // ebx
  int v18; // esi
  const unsigned __int16 *v19; // ecx
  char *v20; // eax
  char *v21; // esi
  const unsigned __int16 **v22; // eax
  char *v23; // edx
  _BYTE v24[8]; // [esp+20h] [ebp-2048h] BYREF
  int v25; // [esp+28h] [ebp-2040h]
  FILE *stream; // [esp+2Ch] [ebp-203Ch]
  _DWORD *v27; // [esp+30h] [ebp-2038h]
  void *ptr; // [esp+34h] [ebp-2034h]
  unsigned int v29; // [esp+38h] [ebp-2030h]
  int v30; // [esp+3Ch] [ebp-202Ch]
  wchar_t pwc; // [esp+40h] [ebp-2028h] BYREF
  char v32[8192]; // [esp+44h] [ebp-2024h] BYREF
  mbstate_t p; // [esp+2044h] [ebp-24h] BYREF
  unsigned int v34; // [esp+204Ch] [ebp-1Ch]

  stream = a1;
  v25 = a2;
  v27 = a4;
  v34 = __readgsdword(0x14u);
  v5 = sub_8056510(v32, 0x2000u, a2, 0xFFFFFFFF, a3);
  ptr = v32;
  v6 = v5;
  if ( v5 > 0x1FFF )
  {
    v16 = alloca(v5 + 16);
    ptr = v24;
    sub_8056510(v24, v5 + 1, v25, 0xFFFFFFFF, a3);
  }
  if ( !byte_80624E4 )
  {
    if ( v27 )
    {
      if ( __ctype_get_mb_cur_max() <= 1 )
      {
        v30 = 0;
        v17 = (char *)ptr + v6;
        if ( ptr < (char *)ptr + v6 )
        {
          v18 = 0;
          v19 = *__ctype_b_loc();
          v20 = (char *)ptr;
          do
            v18 -= ((v19[(unsigned __int8)*v20++] & 0x4000) == 0) - 1;
          while ( v20 != v17 );
          v30 = v18;
        }
      }
      else
      {
        v30 = sub_8055160((char *)ptr, v6, 0);
      }
    }
    goto LABEL_7;
  }
  if ( __ctype_get_mb_cur_max() <= 1 )
  {
    v30 = v6;
    v21 = (char *)ptr + v6;
    if ( ptr < (char *)ptr + v6 )
    {
      v22 = __ctype_b_loc();
      v23 = (char *)ptr;
      do
      {
        if ( ((*v22)[(unsigned __int8)*v23] & 0x4000) == 0 )
          *v23 = 63;
        ++v23;
      }
      while ( v23 != v21 );
      v30 = v6;
    }
    goto LABEL_7;
  }
  v30 = 0;
  v29 = (unsigned int)ptr + v6;
  v8 = (char *)ptr + v6;
  v6 = 0;
  if ( ptr >= v8 )
    goto LABEL_7;
  v9 = ptr;
  v10 = (const char *)ptr;
  while ( 1 )
  {
    v11 = *v10;
    if ( *v10 <= 95 )
      break;
    if ( (unsigned __int8)(v11 - 97) > 0x1Du )
      goto LABEL_20;
LABEL_38:
    *v9 = v11;
    ++v10;
    ++v9;
    ++v30;
LABEL_30:
    if ( (unsigned int)v10 >= v29 )
    {
      v6 = v9 - (_BYTE *)ptr;
      goto LABEL_7;
    }
  }
  if ( v11 >= 65 || v11 >= 32 && (v11 <= 35 || (unsigned __int8)(v11 - 37) <= 0x1Au) )
    goto LABEL_38;
LABEL_20:
  p.__count = 0;
  p.__wch = 0;
  while ( 1 )
  {
    v12 = mbrtowc(&pwc, v10, v29 - (_DWORD)v10, &p);
    v13 = v12;
    if ( v12 == -1 )
    {
      *v9 = 63;
      ++v10;
      ++v9;
      ++v30;
      goto LABEL_30;
    }
    if ( v12 == -2 )
      break;
    if ( !v12 )
      v13 = 1;
    v14 = wcwidth(pwc);
    if ( v14 < 0 )
    {
      *v9 = 63;
      v10 += v13;
      ++v9;
      ++v30;
    }
    else
    {
      v15 = 0;
      do
      {
        v9[v15] = v10[v15];
        ++v15;
      }
      while ( v13 != v15 );
      v30 += v14;
      v9 += v13;
      v10 += v13;
    }
    if ( mbsinit(&p) )
      goto LABEL_30;
  }
  *v9 = 63;
  ++v30;
  v6 = v9 + 1 - (_BYTE *)ptr;
LABEL_7:
  if ( stream )
    fwrite_unlocked(ptr, 1u, v6, stream);
  if ( v27 )
    *v27 = v30;
  HIDWORD(result) = __readgsdword(0x14u) ^ v34;
  LODWORD(result) = v6;
  return result;
}
// 8049590: using guessed type int __cdecl wcwidth(_DWORD);
// 80624E4: using guessed type char byte_80624E4;

//----- (0804CF70) --------------------------------------------------------
int sub_804CF70()
{
  int result; // eax

  result = dword_8062344;
  if ( !dword_8062344 )
    return ++dword_8062340;
  return result;
}
// 8062340: using guessed type int dword_8062340;

//----- (0804CF90) --------------------------------------------------------
int __cdecl sub_804CF90(int a1, int a2)
{
  bool v2; // bl
  int v3; // edi
  int result; // eax
  int v5; // ebx
  int v6; // esi

  v2 = *(_DWORD *)(a2 + 104) == 9 || *(_DWORD *)(a2 + 104) == 3;
  if ( *(_DWORD *)(a1 + 104) == 3 || *(_DWORD *)(a1 + 104) == 9 )
  {
    if ( !v2 )
      return -1;
  }
  else if ( v2 )
  {
    return 1;
  }
  v3 = *(_DWORD *)(a1 + 88);
  result = -1;
  v5 = *(_DWORD *)(a2 + 92);
  v6 = *(_DWORD *)(a1 + 92);
  if ( *(_DWORD *)(a2 + 88) <= v3 )
  {
    result = 1;
    if ( *(_DWORD *)(a2 + 88) >= v3 )
    {
      result = v6 - v5;
      if ( v6 == v5 )
        return strcmp(*(const char **)a2, *(const char **)a1);
    }
  }
  return result;
}

//----- (0804D040) --------------------------------------------------------
int __cdecl sub_804D040(int a1, int a2)
{
  bool v2; // bl
  int v3; // edi
  int result; // eax
  int v5; // ebx
  int v6; // esi

  v2 = *(_DWORD *)(a2 + 104) == 9 || *(_DWORD *)(a2 + 104) == 3;
  if ( *(_DWORD *)(a1 + 104) == 3 || *(_DWORD *)(a1 + 104) == 9 )
  {
    if ( !v2 )
      return -1;
  }
  else if ( v2 )
  {
    return 1;
  }
  v3 = *(_DWORD *)(a1 + 80);
  result = -1;
  v5 = *(_DWORD *)(a2 + 84);
  v6 = *(_DWORD *)(a1 + 84);
  if ( *(_DWORD *)(a2 + 80) <= v3 )
  {
    result = 1;
    if ( *(_DWORD *)(a2 + 80) >= v3 )
    {
      result = v6 - v5;
      if ( v6 == v5 )
        return strcmp(*(const char **)a2, *(const char **)a1);
    }
  }
  return result;
}

//----- (0804D0F0) --------------------------------------------------------
int __cdecl sub_804D0F0(int a1, int a2)
{
  bool v2; // bl
  int v3; // edi
  int result; // eax
  int v5; // ebx
  int v6; // esi

  v2 = *(_DWORD *)(a2 + 104) == 9 || *(_DWORD *)(a2 + 104) == 3;
  if ( *(_DWORD *)(a1 + 104) == 3 || *(_DWORD *)(a1 + 104) == 9 )
  {
    if ( !v2 )
      return -1;
  }
  else if ( v2 )
  {
    return 1;
  }
  v3 = *(_DWORD *)(a1 + 72);
  result = -1;
  v5 = *(_DWORD *)(a2 + 76);
  v6 = *(_DWORD *)(a1 + 76);
  if ( *(_DWORD *)(a2 + 72) <= v3 )
  {
    result = 1;
    if ( *(_DWORD *)(a2 + 72) >= v3 )
    {
      result = v6 - v5;
      if ( v6 == v5 )
        return strcmp(*(const char **)a2, *(const char **)a1);
    }
  }
  return result;
}

//----- (0804D1A0) --------------------------------------------------------
int __cdecl sub_804D1A0(int a1, int a2)
{
  bool v2; // bl
  int v3; // ebx
  int v4; // ecx
  unsigned int v5; // edi
  unsigned int v6; // esi

  v2 = *(_DWORD *)(a2 + 104) == 9 || *(_DWORD *)(a2 + 104) == 3;
  if ( *(_DWORD *)(a1 + 104) == 3 || *(_DWORD *)(a1 + 104) == 9 )
  {
    if ( !v2 )
      return -1;
  }
  else if ( v2 )
  {
    return 1;
  }
  v3 = *(_DWORD *)(a1 + 56);
  v4 = *(_DWORD *)(a2 + 56);
  v5 = *(_DWORD *)(a1 + 52);
  v6 = *(_DWORD *)(a2 + 52);
  if ( v3 < v4 )
    return -1;
  if ( v3 > v4 )
    return 1;
  if ( v5 < v6 )
    return -1;
  if ( v3 >= v4 && v5 > v6 )
    return 1;
  return strcmp(*(const char **)a2, *(const char **)a1);
}

//----- (0804D260) --------------------------------------------------------
int __usercall sub_804D260@<eax>(char a1@<al>, __int16 a2@<dx>, int a3@<ecx>)
{
  bool v4; // al
  int result; // eax
  bool v6; // si
  bool v7; // si
  bool v8; // si

  v4 = a3 == 5;
  if ( a1 )
    v4 = (a2 & 0xF000) == 0x8000;
  if ( v4 )
  {
    result = 0;
    if ( a1 )
    {
      if ( dword_8062408 == 3 )
        return (a2 & 0x49) != 0 ? 0x2A : 0;
    }
  }
  else
  {
    if ( a1 )
      v6 = (a2 & 0xF000) == 0x4000;
    else
      v6 = a3 == 3 || a3 == 9;
    result = 47;
    if ( !v6 )
    {
      result = 0;
      if ( dword_8062408 != 1 )
      {
        v7 = a3 == 6;
        if ( a1 )
          v7 = (a2 & 0xF000) == 40960;
        result = 64;
        if ( !v7 )
        {
          v8 = a3 == 1;
          if ( a1 )
            v8 = (a2 & 0xF000) == 4096;
          result = 124;
          if ( !v8 )
          {
            LOBYTE(result) = a3 == 7;
            if ( a1 )
              LOBYTE(result) = (a2 & 0xF000) == 49152;
            return -result & 0x3D;
          }
        }
      }
    }
  }
  return result;
}
// 8062408: using guessed type int dword_8062408;

//----- (0804D3A0) --------------------------------------------------------
bool __usercall sub_804D3A0@<al>(char a1@<al>, __int16 a2@<dx>, int a3@<ecx>)
{
  unsigned __int8 v3; // bl
  FILE *v4; // eax
  char *IO_write_ptr; // edx

  v3 = sub_804D260(a1, a2, a3);
  if ( v3 )
  {
    v4 = stdout;
    IO_write_ptr = stdout->_IO_write_ptr;
    if ( IO_write_ptr >= stdout->_IO_write_end )
    {
      __overflow(stdout, v3);
    }
    else
    {
      *IO_write_ptr = v3;
      v4->_IO_write_ptr = IO_write_ptr + 1;
    }
    ++dword_80624D8;
  }
  return v3 != 0;
}
// 80624D8: using guessed type int dword_80624D8;

//----- (0804D3F0) --------------------------------------------------------
__int64 __usercall sub_804D3F0@<edx:eax>(int a1@<eax>)
{
  int v2; // ebx
  int v3; // eax
  int v4; // eax
  int v5; // ebx
  __int64 result; // rax
  char *v7; // eax
  const char *s; // eax
  int v9; // [esp+2Ch] [ebp-2A0h] BYREF
  char v10[652]; // [esp+30h] [ebp-29Ch] BYREF
  unsigned int v11; // [esp+2BCh] [ebp-10h]

  v2 = 0;
  v11 = __readgsdword(0x14u);
  if ( byte_80624EE )
  {
    v2 = dword_8062CBC + 1;
    if ( dword_8062360 == 4 )
    {
      s = (const char *)sub_8054C60(*(_DWORD *)(a1 + 96), *(_DWORD *)(a1 + 100), (int)v10);
      v2 = strlen(s) + 1;
    }
  }
  if ( byte_8062451 )
  {
    v3 = dword_8062CC0 + 1;
    if ( dword_8062360 == 4 )
    {
      v3 = 2;
      if ( *(_BYTE *)(a1 + 116) )
      {
        v7 = sub_8053850(*(_QWORD *)(a1 + 64), (int)v10, dword_80624FC, 512LL, qword_8062500);
        v3 = strlen(v7) + 1;
      }
    }
    v2 += v3;
  }
  if ( byte_8062450 )
  {
    v4 = dword_8062CD4 + 1;
    if ( dword_8062360 == 4 )
      v4 = strlen(*(const char **)(a1 + 112)) + 1;
    v2 += v4;
  }
  sub_804CBF0(0, *(_DWORD *)a1, (int *)dword_80624E0, &v9);
  v5 = v9 + v2;
  if ( dword_8062408 )
    v5 += (unsigned __int8)sub_804D260(*(_BYTE *)(a1 + 116), *(_DWORD *)(a1 + 24), *(_DWORD *)(a1 + 104)) != 0;
  HIDWORD(result) = __readgsdword(0x14u) ^ v11;
  LODWORD(result) = v5;
  return result;
}
// 8062360: using guessed type int dword_8062360;
// 8062408: using guessed type int dword_8062408;
// 8062450: using guessed type char byte_8062450;
// 8062451: using guessed type char byte_8062451;
// 80624E0: using guessed type int dword_80624E0;
// 80624EE: using guessed type char byte_80624EE;
// 80624FC: using guessed type int dword_80624FC;
// 8062500: using guessed type __int64 qword_8062500;
// 8062CBC: using guessed type int dword_8062CBC;
// 8062CC0: using guessed type int dword_8062CC0;
// 8062CD4: using guessed type int dword_8062CD4;

//----- (0804D570) --------------------------------------------------------
int __usercall sub_804D570@<eax>(int a1@<eax>, const char *a2@<edx>, int a3@<ecx>)
{
  _BYTE *v5; // edi
  int *v6; // eax
  int result; // eax

  v5 = sub_8056980(a3);
  v6 = __errno_location();
  error(0, *v6, a2, v5);
  result = a1;
  if ( (_BYTE)a1 )
  {
    status = 2;
  }
  else
  {
    result = status;
    if ( !status )
      status = 1;
  }
  return result;
}

//----- (0804D600) --------------------------------------------------------
size_t __usercall sub_804D600@<eax>(int a1@<eax>, int a2@<ecx>)
{
  char s[11]; // [esp+21h] [ebp-1Bh] BYREF
  unsigned int v4; // [esp+2Ch] [ebp-10h]

  v4 = __readgsdword(0x14u);
  __sprintf_chk(a2, 0, s, 1, 11, 134586507, a1);
  return strlen(s);
}
// 8049B70: using guessed type int __fastcall __sprintf_chk(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (0804D660) --------------------------------------------------------
int __usercall sub_804D660@<eax>(__uid_t a1@<eax>, int a2@<ecx>)
{
  char *v4; // eax
  int v5; // eax
  int v6; // edx

  if ( byte_80624ED )
    return sub_804D600(a1, a2);
  v4 = (char *)sub_8054860(a1);
  if ( !v4 )
    return sub_804D600(a1, a2);
  v5 = sub_8055350(v4, 0);
  v6 = 0;
  if ( v5 >= 0 )
    return v5;
  return v6;
}
// 804D675: variable 'a2' is possibly undefined
// 80624ED: using guessed type char byte_80624ED;

//----- (0804D6B0) --------------------------------------------------------
int __cdecl sub_804D6B0(int a1, int a2)
{
  bool v2; // dl
  const char *v3; // edi
  char *v4; // eax
  const char *v5; // esi
  const char *v6; // ebx
  char *v7; // eax
  int result; // eax

  v2 = *(_DWORD *)(a2 + 104) == 9 || *(_DWORD *)(a2 + 104) == 3;
  if ( *(_DWORD *)(a1 + 104) == 3 || *(_DWORD *)(a1 + 104) == 9 )
  {
    if ( !v2 )
      return -1;
  }
  else if ( v2 )
  {
    return 1;
  }
  v3 = *(const char **)a2;
  v4 = strrchr(*(const char **)a2, 46);
  v5 = *(const char **)a1;
  v6 = v4;
  v7 = strrchr(*(const char **)a1, 46);
  if ( !v7 )
    v7 = (char *)"";
  if ( !v6 )
    v6 = "";
  result = strcmp(v6, v7);
  if ( !result )
    return strcmp(v3, v5);
  return result;
}

//----- (0804D7A0) --------------------------------------------------------
int __cdecl sub_804D7A0(char *s1, char *s2)
{
  *__errno_location() = 0;
  return strcoll(s1, s2);
}

//----- (0804D7E0) --------------------------------------------------------
int __cdecl sub_804D7E0(char *s1, char *s2)
{
  return sub_804D7A0(*(char **)s1, *(char **)s2);
}

//----- (0804D800) --------------------------------------------------------
int __cdecl sub_804D800(char *s1, char *s2)
{
  return sub_804D7A0(*(char **)s2, *(char **)s1);
}

//----- (0804D820) --------------------------------------------------------
int __cdecl sub_804D820(char *s1, char *s2)
{
  bool v2; // dl

  v2 = *((_DWORD *)s2 + 26) == 9 || *((_DWORD *)s2 + 26) == 3;
  if ( *((_DWORD *)s1 + 26) == 3 || *((_DWORD *)s1 + 26) == 9 )
  {
    if ( v2 )
      return sub_804D7A0(*(char **)s1, *(char **)s2);
    return -1;
  }
  else
  {
    if ( !v2 )
      return sub_804D7A0(*(char **)s1, *(char **)s2);
    return 1;
  }
}

//----- (0804D8B0) --------------------------------------------------------
int __cdecl sub_804D8B0(char *s1, char *s2)
{
  bool v2; // dl

  v2 = *((_DWORD *)s2 + 26) == 9 || *((_DWORD *)s2 + 26) == 3;
  if ( *((_DWORD *)s1 + 26) == 3 || *((_DWORD *)s1 + 26) == 9 )
  {
    if ( v2 )
      return sub_804D7A0(*(char **)s2, *(char **)s1);
    return -1;
  }
  else
  {
    if ( !v2 )
      return sub_804D7A0(*(char **)s2, *(char **)s1);
    return 1;
  }
}

//----- (0804D940) --------------------------------------------------------
size_t sub_804D940()
{
  if ( dword_80621F4 )
    return sub_804D980((int)&unk_80621F0);
  sub_804D980((int)dword_80621E0);
  sub_804D980((int)&unk_80621F8);
  return sub_804D980((int)&dword_80621E8);
}
// 80621E0: using guessed type int dword_80621E0[];
// 80621E8: using guessed type int dword_80621E8;
// 80621F4: using guessed type int dword_80621F4;

//----- (0804D980) --------------------------------------------------------
size_t __usercall sub_804D980@<eax>(int a1@<eax>)
{
  int v2; // [esp+1Ch] [ebp-10h]

  if ( !byte_80624DC )
  {
    v2 = a1;
    byte_80624DC = 1;
    sub_804D940();
    a1 = v2;
  }
  return fwrite_unlocked(*(const void **)(a1 + 4), *(_DWORD *)a1, 1u, stdout);
}
// 80624DC: using guessed type char byte_80624DC;

//----- (0804D9D0) --------------------------------------------------------
size_t sub_804D9D0()
{
  sub_804D980((int)dword_80621E0);
  return sub_804D980((int)&dword_80621E8);
}
// 80621E0: using guessed type int dword_80621E0[];
// 80621E8: using guessed type int dword_80621E8;

//----- (0804D9F0) --------------------------------------------------------
int __usercall sub_804D9F0@<eax>(struct obstack *a1@<ecx>, int a2@<eax>, char a3@<dl>, int a4)
{
  _BOOL4 v6; // esi
  char *next_free; // eax
  int v8; // eax
  int v9; // ebx
  char *v10; // eax
  int v12; // ecx
  const char *v13; // edi
  int v14; // esi
  int v15; // edx
  int *v16; // ebx
  int v17; // eax
  int v18; // esi
  size_t v19; // eax
  char *v20; // ebx
  const char *v21; // edi
  size_t v22; // esi
  int v23; // eax
  bool v24; // al
  bool v25; // al
  bool v26; // al
  bool v27; // al
  bool v28; // al
  bool v29; // al
  int v30; // [esp+1Ch] [ebp-A0h]
  sigset_t oset; // [esp+20h] [ebp-9Ch] BYREF

  if ( a3 )
  {
    v6 = 0;
    v30 = *(_DWORD *)(a2 + 4);
    if ( !byte_806235C )
      goto LABEL_3;
  }
  else
  {
    v30 = *(_DWORD *)a2;
    v6 = 0;
    if ( !byte_806235C )
      goto LABEL_3;
  }
  if ( !a3 )
  {
    v13 = *(const char **)a2;
    if ( byte_806235D )
    {
      LOBYTE(v12) = 0;
      if ( *(_BYTE *)(a2 + 117) )
      {
        v14 = *(_DWORD *)(a2 + 108);
        LOBYTE(v12) = 1;
        goto LABEL_38;
      }
    }
    else
    {
      LOBYTE(v12) = *(_BYTE *)(a2 + 117);
    }
    v14 = *(_DWORD *)(a2 + 24);
LABEL_38:
    v12 = (unsigned __int8)v12;
    goto LABEL_39;
  }
  v12 = 0;
  v13 = *(const char **)(a2 + 4);
  v14 = *(_DWORD *)(a2 + 108);
  if ( !*(_BYTE *)(a2 + 117) )
  {
    v15 = 12;
    if ( dword_8062244 )
      goto LABEL_18;
    v12 = -1;
  }
LABEL_39:
  if ( *(_BYTE *)(a2 + 116) )
  {
    v23 = v14 & 0xF000;
    if ( v23 != 0x8000 )
    {
      if ( v23 == 0x4000 )
      {
        if ( (v14 & 0x202) != 514 || (v29 = sub_804BF90(20), v15 = 20, !v29) )
        {
          if ( (v14 & 2) == 0 || (v28 = sub_804BF90(19), v15 = 19, !v28) )
          {
            v15 = 6;
            if ( (v14 & 0x200) != 0 )
              v15 = !sub_804BF90(18) ? 6 : 18;
          }
        }
      }
      else if ( v23 == 40960 )
      {
        v15 = 7;
        if ( !v12 )
        {
          v15 = 13;
          if ( memcmp(s1, "target", 6u) )
            v15 = dword_806224C == 0 ? 7 : 13;
        }
      }
      else
      {
        v15 = 8;
        if ( v23 != 4096 )
        {
          LOBYTE(v15) = 9;
          if ( v23 != 49152 )
          {
            LOBYTE(v15) = 10;
            if ( v23 != 24576 )
              v15 = 2 * (v23 != 0x2000) + 11;
          }
        }
      }
      goto LABEL_18;
    }
    if ( (v14 & 0x800) != 0 )
    {
      LOWORD(v23) = 16;
      v24 = sub_804BF90(v23);
      v15 = 16;
      if ( v24 )
        goto LABEL_18;
    }
    if ( (v14 & 0x400) != 0 && (v25 = sub_804BF90(17), v15 = 17, v25)
      || sub_804BF90(21) && (v15 = 21, *(_BYTE *)(a2 + 124))
      || (v14 & 0x49) != 0 && (v26 = sub_804BF90(14), v15 = 14, v26)
      || *(_DWORD *)(a2 + 28) > 1u && (v27 = sub_804BF90(22), v15 = 22, v27) )
    {
LABEL_18:
      v16 = &dword_80621E0[2 * v15];
      goto LABEL_19;
    }
  }
  else
  {
    v15 = dword_805B2A0[*(_DWORD *)(a2 + 104)];
    if ( v15 != 5 )
      goto LABEL_18;
  }
  v19 = strlen(v13);
  v20 = (char *)dword_8062CB0;
  v21 = &v13[v19];
  v22 = v19;
  if ( !dword_8062CB0 )
  {
LABEL_45:
    v15 = 5;
    goto LABEL_18;
  }
  while ( v22 < *(_DWORD *)v20 || strncmp(&v21[-*(_DWORD *)v20], *((const char **)v20 + 1), *(_DWORD *)v20) )
  {
    v20 = (char *)*((_DWORD *)v20 + 4);
    if ( !v20 )
      goto LABEL_45;
  }
  v16 = (int *)(v20 + 8);
LABEL_19:
  if ( !v16[1] )
  {
    v6 = sub_804BF90(4);
LABEL_3:
    if ( a1 )
      goto LABEL_4;
    goto LABEL_23;
  }
  if ( sub_804BF90(4) )
    sub_804D9D0();
  v6 = 1;
  sub_804D980((int)dword_80621E0);
  sub_804D980((int)v16);
  sub_804D980((int)&dword_80621E8);
  if ( a1 )
  {
LABEL_4:
    if ( byte_8062455 )
    {
      next_free = a1->next_free;
      if ( a1->chunk_limit < next_free + 4 )
      {
        _obstack_newchunk(a1, 4);
        next_free = a1->next_free;
      }
      *(_DWORD *)next_free = dword_80624D8;
      a1->next_free += 4;
    }
    v8 = sub_804CBF0(stdout, v30, (int *)dword_80624E0, 0);
    dword_80624D8 += v8;
    v9 = v8;
    if ( byte_8062455 )
    {
      v10 = a1->next_free;
      if ( a1->chunk_limit < v10 + 4 )
      {
        _obstack_newchunk(a1, 4);
        v10 = a1->next_free;
      }
      *(_DWORD *)v10 = dword_80624D8;
      a1->next_free += 4;
    }
    if ( !v6 )
      return v9;
    goto LABEL_28;
  }
LABEL_23:
  v17 = sub_804CBF0(stdout, v30, (int *)dword_80624E0, 0);
  dword_80624D8 += v17;
  v9 = v17;
  if ( !v6 )
    return v9;
LABEL_28:
  while ( dword_8062344 || dword_8062340 )
  {
    if ( byte_80624DC )
      sub_804D9D0();
    fflush_unlocked(stdout);
    sigprocmask(0, &set, &oset);
    v18 = dword_8062344;
    if ( dword_8062340 )
    {
      v18 = 19;
      --dword_8062340;
    }
    else
    {
      signal(dword_8062344, 0);
    }
    raise(v18);
    sigprocmask(2, &oset, 0);
  }
  sub_804D940();
  if ( a4 / (unsigned int)dword_8062508 == (v9 + a4 - 1) / (unsigned int)dword_8062508 )
    return v9;
  sub_804D980((int)&unk_8062298);
  return v9;
}
// 805B2A0: using guessed type int dword_805B2A0[10];
// 80621E0: using guessed type int dword_80621E0[];
// 80621E8: using guessed type int dword_80621E8;
// 8062244: using guessed type int dword_8062244;
// 806224C: using guessed type int dword_806224C;
// 8062340: using guessed type int dword_8062340;
// 806235C: using guessed type char byte_806235C;
// 806235D: using guessed type char byte_806235D;
// 8062455: using guessed type char byte_8062455;
// 80624D8: using guessed type int dword_80624D8;
// 80624DC: using guessed type char byte_80624DC;
// 80624E0: using guessed type int dword_80624E0;
// 8062508: using guessed type int dword_8062508;

//----- (0804DF20) --------------------------------------------------------
void sub_804DF20()
{
  if ( byte_806235C )
  {
    if ( sub_804BF90(4) )
    {
      sub_804D980((int)dword_80621E0);
      sub_804D980((int)&unk_8062200);
      sub_804D980((int)&dword_80621E8);
    }
  }
}
// 80621E0: using guessed type int dword_80621E0[];
// 80621E8: using guessed type int dword_80621E8;
// 806235C: using guessed type char byte_806235C;

//----- (0804DF70) --------------------------------------------------------
__int64 __usercall sub_804DF70@<edx:eax>(int a1@<eax>, int a2@<edx>)
{
  const char *v4; // eax
  int v5; // edx
  char *v6; // eax
  int v7; // edx
  int v8; // eax
  int v9; // esi
  __int64 result; // rax
  char v11[652]; // [esp+20h] [ebp-29Ch] BYREF
  unsigned int v12; // [esp+2ACh] [ebp-10h]

  v12 = __readgsdword(0x14u);
  sub_804DF20();
  if ( byte_80624EE )
  {
    v4 = "?";
    if ( *(_BYTE *)(a1 + 116) && *(_QWORD *)(a1 + 96) )
      v4 = (const char *)sub_8054C60(*(_DWORD *)(a1 + 96), *(_DWORD *)(a1 + 100), (int)v11);
    v5 = 0;
    if ( dword_8062360 != 4 )
      v5 = dword_8062CBC;
    __printf_chk(1, "%*s ", v5, v4);
  }
  if ( byte_8062451 )
  {
    v6 = "?";
    if ( *(_BYTE *)(a1 + 116) )
      v6 = sub_8053850(*(_QWORD *)(a1 + 64), (int)v11, dword_80624FC, 512LL, qword_8062500);
    v7 = 0;
    if ( dword_8062360 != 4 )
      v7 = dword_8062CC0;
    __printf_chk(1, "%*s ", v7, v6);
  }
  if ( byte_8062450 )
  {
    v8 = 0;
    if ( dword_8062360 != 4 )
      v8 = dword_8062CD4;
    __printf_chk(1, "%*s ", v8, *(const char **)(a1 + 112));
  }
  v9 = sub_804D9F0(0, a1, 0, a2);
  if ( dword_8062408 )
    v9 += sub_804D3A0(*(_BYTE *)(a1 + 116), *(_DWORD *)(a1 + 24), *(_DWORD *)(a1 + 104));
  HIDWORD(result) = __readgsdword(0x14u) ^ v12;
  LODWORD(result) = v9;
  return result;
}
// 8049980: using guessed type int __printf_chk(_DWORD, const char *, ...);
// 8062360: using guessed type int dword_8062360;
// 8062408: using guessed type int dword_8062408;
// 8062450: using guessed type char byte_8062450;
// 8062451: using guessed type char byte_8062451;
// 80624EE: using guessed type char byte_80624EE;
// 80624FC: using guessed type int dword_80624FC;
// 8062500: using guessed type __int64 qword_8062500;
// 8062CBC: using guessed type int dword_8062CBC;
// 8062CC0: using guessed type int dword_8062CC0;
// 8062CD4: using guessed type int dword_8062CD4;

//----- (0804E120) --------------------------------------------------------
int __usercall sub_804E120@<eax>(char *a1@<eax>, const char *haystack@<edx>, const struct tm *a3@<ecx>, int a4)
{
  char *v5; // esi
  char *v7; // ebp
  int v9; // eax
  int v10; // eax
  char *v11; // eax
  char *needle; // [esp+4h] [ebp-148h]
  char v13[261]; // [esp+27h] [ebp-125h] BYREF
  unsigned int v14; // [esp+12Ch] [ebp-20h]

  v14 = __readgsdword(0x14u);
  v5 = (char *)haystack;
  if ( dword_806251C )
  {
    v7 = strstr(haystack, "%b");
    if ( v7 )
    {
      if ( strlen(v5) <= 0x65 )
      {
        v9 = v7 - v5;
        needle = v5;
        v5 = v13;
        v10 = __mempcpy_chk(v13, needle, v9, 261);
        v11 = (char *)stpcpy(v10, 161 * a3->tm_mon + 134620448);
        strcpy(v11, v7 + 2);
      }
    }
  }
  return sub_8058320(a1, 1001, v5, a3, 0, a4);
}
// 8049530: using guessed type int __cdecl __mempcpy_chk(_DWORD, _DWORD, _DWORD, _DWORD);
// 8049680: using guessed type int __cdecl stpcpy(_DWORD, _DWORD);
// 806251C: using guessed type int dword_806251C;

//----- (0804E240) --------------------------------------------------------
char __usercall sub_804E240@<al>(int a1@<eax>, unsigned int a2@<ecx>)
{
  int v3; // eax
  bool v4; // cf
  char *v5; // edx
  char *v6; // esi
  char *v7; // edi
  int v8; // eax
  int v9; // eax
  char *v10; // eax
  char v11; // al
  char *v12; // edi
  char *v13; // eax
  size_t v14; // ecx
  int v15; // edx
  char *v16; // edx
  int v17; // eax
  int v18; // esi
  int v19; // eax
  char *v20; // edx
  int v21; // esi
  char *v22; // esi
  char v23; // al
  char *v24; // esi
  __int64 v25; // rax
  int v26; // ecx
  char *v27; // esi
  int v28; // esi
  int v29; // eax
  int v30; // ecx
  int v31; // edi
  int v32; // eax
  int v33; // eax
  int v34; // eax
  __time_t tv_sec; // ecx
  char *v36; // eax
  unsigned int v37; // eax
  int v38; // esi
  int v39; // eax
  int v40; // eax
  __int64 s; // [esp+0h] [ebp-12BCh]
  __int64 sa; // [esp+0h] [ebp-12BCh]
  char *v44; // [esp+2Ch] [ebp-1290h]
  __gid_t v45; // [esp+2Ch] [ebp-1290h]
  int v46; // [esp+30h] [ebp-128Ch]
  unsigned int v47; // [esp+30h] [ebp-128Ch]
  int v48; // [esp+34h] [ebp-1288h]
  int v49; // [esp+34h] [ebp-1288h]
  int tv_nsec; // [esp+38h] [ebp-1284h]
  int v51; // [esp+38h] [ebp-1284h]
  unsigned int v52; // [esp+3Ch] [ebp-1280h]
  int v53; // [esp+3Ch] [ebp-1280h]
  time_t timer; // [esp+48h] [ebp-1274h] BYREF
  int v55; // [esp+4Ch] [ebp-1270h]
  time_t v56; // [esp+50h] [ebp-126Ch] BYREF
  char v57[3643]; // [esp+57h] [ebp-1265h] BYREF
  char v58[1001]; // [esp+E92h] [ebp-42Ah] BYREF
  char v59[21]; // [esp+127Bh] [ebp-41h] BYREF
  char v60; // [esp+1290h] [ebp-2Ch] BYREF
  char v61[15]; // [esp+1291h] [ebp-2Bh] BYREF

  *(_DWORD *)&v61[11] = __readgsdword(0x14u);
  if ( *(_BYTE *)(a1 + 116) )
  {
    sub_80522D0(a1 + 8, &v60);
    if ( !byte_8062CB8 )
    {
LABEL_3:
      v61[9] = 0;
      goto LABEL_4;
    }
  }
  else
  {
    v33 = *(_DWORD *)(a1 + 104);
    strcpy(v61, "??????????");
    v60 = byte_805B2C8[v33];
    if ( !byte_8062CB8 )
      goto LABEL_3;
  }
  v34 = *(_DWORD *)(a1 + 120);
  if ( v34 == 1 )
  {
    v61[9] = 46;
LABEL_4:
    v3 = dword_80624E8;
    v4 = dword_80624E8 == 0;
    if ( dword_80624E8 != 1 )
      goto LABEL_5;
LABEL_55:
    v5 = *(char **)(a1 + 88);
    v55 = *(_DWORD *)(a1 + 92);
    timer = (time_t)v5;
    goto LABEL_7;
  }
  if ( v34 != 2 )
    goto LABEL_4;
  v3 = dword_80624E8;
  v61[9] = 43;
  v4 = dword_80624E8 == 0;
  if ( dword_80624E8 == 1 )
    goto LABEL_55;
LABEL_5:
  if ( v4 )
  {
    v5 = *(char **)(a1 + 80);
    v55 = *(_DWORD *)(a1 + 84);
    timer = (time_t)v5;
  }
  else
  {
    if ( v3 != 2 )
      abort();
    v5 = *(char **)(a1 + 72);
    v55 = *(_DWORD *)(a1 + 76);
    timer = (time_t)v5;
  }
LABEL_7:
  v6 = v57;
  if ( byte_80624EE )
  {
    if ( *(_BYTE *)(a1 + 116) )
    {
      v5 = *(char **)(a1 + 100);
      a2 = *(_DWORD *)(a1 + 96);
      if ( *(_QWORD *)(a1 + 96) )
        sub_8054C60(a2, (unsigned int)v5, (int)v58);
    }
    __sprintf_chk(a2, v5, v57, 1, 3643, "%*s ", dword_8062CBC);
    v6 = &v57[strlen(v57)];
  }
  if ( byte_8062451 )
  {
    v7 = "?";
    if ( *(_BYTE *)(a1 + 116) )
      v7 = sub_8053850(*(_QWORD *)(a1 + 64), (int)v58, dword_80624FC, 512LL, qword_8062500);
    v48 = dword_8062CC0;
    v8 = sub_8055350(v7, 0);
    v5 = v6;
    a2 = v48 - v8;
    v9 = v48 - v8;
    if ( v9 <= 0 )
      goto LABEL_17;
    v10 = &v6[v9];
    do
      *v6++ = 32;
    while ( v6 != v10 );
    do
    {
      v5 = v6;
LABEL_17:
      v11 = *v7++;
      v6 = v5 + 1;
      *v5 = v11;
    }
    while ( v11 );
    *v5 = 32;
  }
  if ( *(_BYTE *)(a1 + 116) )
    sub_8054C60(*(_DWORD *)(a1 + 28), 0, (int)v58);
  __sprintf_chk(a2, v5, v6, 1, -1, "%s %*s ", &v60);
  v12 = &v6[strlen(v6)];
  if ( byte_8062455 )
  {
    fwrite_unlocked("  ", 1u, 2u, stdout);
    dword_80624D8 += 2;
  }
  if ( byte_80622A8 || byte_80622A9 || byte_8062510 || byte_8062450 )
  {
    fputs_unlocked(v57, stdout);
    dword_80624D8 += v12 - v57;
    if ( byte_80622A8 )
      sub_804CBA0(*(_DWORD *)(a1 + 32), dword_8062CC8, *(unsigned __int8 *)(a1 + 116));
    if ( byte_80622A9 )
    {
      v13 = "?";
      v14 = dword_8062CCC;
      v15 = *(_DWORD *)(a1 + 36);
      if ( *(_BYTE *)(a1 + 116) )
      {
        v13 = 0;
        if ( !byte_80624ED )
        {
          v45 = *(_DWORD *)(a1 + 36);
          v46 = dword_8062CCC;
          v13 = (char *)sub_80549F0(v45);
          v14 = v46;
          v15 = v45;
        }
      }
      sub_804CAE0(v13, v15, v14);
    }
    if ( byte_8062510 )
      sub_804CBA0(*(_DWORD *)(a1 + 32), dword_8062CD0, *(unsigned __int8 *)(a1 + 116));
    v12 = v57;
    if ( byte_8062450 )
      sub_804CAE0(*(char **)(a1 + 112), 0, dword_8062CD4);
  }
  v16 = "?";
  if ( *(_BYTE *)(a1 + 116) )
  {
    v17 = *(_DWORD *)(a1 + 24) & 0xF000;
    if ( v17 == 24576 || v17 == 0x2000 )
    {
      v37 = *(_QWORD *)(a1 + 40) >> 12;
      LOBYTE(v37) = 0;
      v38 = dword_8062CE0 + -2 - dword_8062CD8 - dword_8062CDC;
      s = *(unsigned __int8 *)(a1 + 40) | v37;
      v39 = sub_8054C60(s, HIDWORD(s), (int)v59);
      v53 = dword_8062CDC;
      v51 = v39;
      sa = (*(_DWORD *)(a1 + 40) >> 8) & 0xFFF | *(_DWORD *)(a1 + 44) & 0xFFFFF000;
      sub_8054C60(sa, HIDWORD(sa), (int)v58);
      v40 = 0;
      if ( v38 >= 0 )
        v40 = v38;
      __sprintf_chk(v51, v53, v12, 1, -1, &unk_805A0AC, dword_8062CD8 + v40);
      v24 = &v12[dword_8062CE0 + 1];
      goto LABEL_44;
    }
    v16 = sub_8053850(*(_QWORD *)(a1 + 52), (int)v58, dword_80624FC, 1LL, qword_80622A0);
  }
  v18 = dword_8062CE0;
  v44 = v16;
  v19 = sub_8055350(v16, 0);
  v20 = v44;
  v21 = v18 - v19;
  if ( v21 > 0 )
  {
    v22 = &v12[v21];
    do
      *v12++ = 32;
    while ( v12 != v22 );
  }
  while ( 1 )
  {
    v23 = *v20++;
    v24 = v12 + 1;
    *v12 = v23;
    if ( !v23 )
      break;
    ++v12;
  }
  *v12 = 32;
LABEL_44:
  LODWORD(v25) = localtime(&timer);
  *v24 = 1;
  if ( *(_BYTE *)(a1 + 116) )
  {
    if ( !(_DWORD)v25 )
      goto LABEL_88;
    tv_sec = stru_8062354.tv_sec;
    HIDWORD(v25) = timer;
    tv_nsec = stru_8062354.tv_nsec;
    v49 = v55;
    if ( timer > stru_8062354.tv_sec || timer >= stru_8062354.tv_sec && stru_8062354.tv_nsec - v55 < 0 )
    {
      v47 = v25;
      sub_8052840(&stru_8062354);
      tv_sec = stru_8062354.tv_sec;
      v25 = __PAIR64__(timer, v47);
      tv_nsec = stru_8062354.tv_nsec;
      v49 = v55;
    }
    if ( tv_sec - 15778476 < SHIDWORD(v25) || (v52 = 0, tv_sec - 15778476 <= SHIDWORD(v25)) && tv_nsec - v49 < 0 )
    {
      v52 = 1;
      if ( tv_sec <= SHIDWORD(v25) )
      {
        v52 = 0;
        if ( tv_sec >= SHIDWORD(v25) )
          v52 = (unsigned int)(v49 - tv_nsec) >> 31;
      }
    }
    LODWORD(v25) = sub_804E120(v24, (&off_80622AC)[v52], (const struct tm *)v25, v49);
    if ( (_DWORD)v25 || !*v24 )
    {
      v36 = &v24[v25];
      *v36 = 32;
      v27 = v36 + 1;
      v36[1] = 0;
      goto LABEL_47;
    }
    if ( *(_BYTE *)(a1 + 116) )
LABEL_88:
      sub_8054B80(timer, timer >> 31, (int)v59);
  }
  LODWORD(v25) = dword_80622B8;
  if ( dword_80622B8 < 0 )
  {
    v56 = 0;
    LODWORD(v25) = localtime(&v56);
    if ( !(_DWORD)v25
      || ((LODWORD(v25) = sub_804E120(v58, off_80622AC, (const struct tm *)v25, 0), (_DWORD)v25) ? (v25 = sub_8055160(v58, v25, 0),
                                                                                                    dword_80622B8 = v25) : (LODWORD(v25) = dword_80622B8),
          (int)v25 < 0) )
    {
      dword_80622B8 = 0;
      LODWORD(v25) = 0;
    }
  }
  __sprintf_chk(v26, HIDWORD(v25), v24, 1, -1, "%*s ", v25);
  v27 = &v24[strlen(v24)];
LABEL_47:
  v28 = v27 - v57;
  fputs_unlocked(v57, stdout);
  dword_80624D8 += v28;
  v29 = sub_804D9F0(&stru_8062460, a1, 0, v28);
  v30 = *(_DWORD *)(a1 + 104);
  v31 = v29;
  if ( v30 == 6 )
  {
    v32 = *(_DWORD *)(a1 + 4);
    if ( v32 )
    {
      fwrite_unlocked(" -> ", 1u, 4u, stdout);
      dword_80624D8 += 4;
      sub_804D9F0(0, a1, 1, v28 + v31 + 4);
      LOBYTE(v32) = dword_8062408;
      if ( dword_8062408 )
        LOBYTE(v32) = sub_804D3A0(1, *(_DWORD *)(a1 + 108), 0);
    }
  }
  else
  {
    LOBYTE(v32) = dword_8062408;
    if ( dword_8062408 )
      LOBYTE(v32) = sub_804D3A0(*(_BYTE *)(a1 + 116), *(_DWORD *)(a1 + 24), v30);
  }
  return v32;
}
// 804E2FC: variable 'a2' is possibly undefined
// 804E2FC: variable 'v5' is possibly undefined
// 804E566: variable 'v26' is possibly undefined
// 804E566: variable 'v25' is possibly undefined
// 8049870: using guessed type int __cdecl fputs_unlocked(_DWORD, _DWORD);
// 8049B70: using guessed type int __fastcall __sprintf_chk(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 80622A0: using guessed type __int64 qword_80622A0;
// 80622A8: using guessed type char byte_80622A8;
// 80622A9: using guessed type char byte_80622A9;
// 80622B8: using guessed type int dword_80622B8;
// 8062408: using guessed type int dword_8062408;
// 8062450: using guessed type char byte_8062450;
// 8062451: using guessed type char byte_8062451;
// 8062455: using guessed type char byte_8062455;
// 80624D8: using guessed type int dword_80624D8;
// 80624E8: using guessed type int dword_80624E8;
// 80624ED: using guessed type char byte_80624ED;
// 80624EE: using guessed type char byte_80624EE;
// 80624FC: using guessed type int dword_80624FC;
// 8062500: using guessed type __int64 qword_8062500;
// 8062510: using guessed type char byte_8062510;
// 8062CB8: using guessed type char byte_8062CB8;
// 8062CBC: using guessed type int dword_8062CBC;
// 8062CC0: using guessed type int dword_8062CC0;
// 8062CC4: using guessed type int dword_8062CC4;
// 8062CC8: using guessed type int dword_8062CC8;
// 8062CCC: using guessed type int dword_8062CCC;
// 8062CD0: using guessed type int dword_8062CD0;
// 8062CD4: using guessed type int dword_8062CD4;
// 8062CD8: using guessed type int dword_8062CD8;
// 8062CDC: using guessed type int dword_8062CDC;
// 8062CE0: using guessed type int dword_8062CE0;
// 804E240: using guessed type char var_1265[3643];

//----- (0804EB40) --------------------------------------------------------
int __usercall sub_804EB40@<eax>(char *a1@<eax>, size_t a2@<edx>, unsigned __int8 a3@<cl>, char *a4)
{
  __int64 v4; // rax
  int v5; // edi
  unsigned int v6; // edx
  _WORD *v7; // edi
  int v8; // edx
  size_t v9; // ecx
  bool v10; // zf
  unsigned int v11; // esi
  char *v12; // ebx
  char v13; // di
  int v14; // edx
  int v15; // ecx
  int v16; // edx
  int v17; // eax
  int v18; // esi
  char *v19; // eax
  int v20; // eax
  int v21; // ecx
  int v22; // ecx
  int v23; // ebx
  signed int v24; // eax
  signed int v25; // eax
  char v26; // al
  void *v27; // eax
  char *v29; // eax
  bool v30; // al
  int v31; // eax
  int v32; // edx
  char v33; // cl
  bool v34; // al
  char v35; // cl
  int v36; // esi
  int v37; // eax
  bool v38; // al
  int *v39; // eax
  int v40; // eax
  const char *v41; // eax
  signed int v42; // eax
  size_t v43; // ebx
  void *v44; // esp
  char v45; // dl
  char *v46; // eax
  char *v47; // ecx
  char *v48; // ecx
  char i; // dl
  const char *v50; // eax
  signed int v51; // eax
  int v52; // eax
  char *v53; // eax
  int v54; // eax
  const char *v55; // esi
  int *v56; // eax
  int v57; // eax
  const char *v58; // eax
  signed int v59; // eax
  unsigned __int64 v60; // rcx
  int v61; // eax
  const char *v62; // eax
  signed int v63; // edx
  int v64; // eax
  int v65; // eax
  char *v66; // esi
  char *v67; // eax
  int v68; // edi
  size_t v69; // eax
  char *v70; // edi
  int v71; // eax
  int v72; // eax
  int *v73; // eax
  char *v74; // eax
  int v75; // edx
  char *v76; // eax
  unsigned __int64 v77; // [esp+0h] [ebp-368h]
  const char **v78; // [esp+4h] [ebp-364h]
  _BYTE v79[8]; // [esp+20h] [ebp-348h] BYREF
  int v80; // [esp+28h] [ebp-340h]
  unsigned __int8 v81; // [esp+2Fh] [ebp-339h]
  size_t n; // [esp+30h] [ebp-338h]
  char *v83; // [esp+34h] [ebp-334h]
  char *s; // [esp+38h] [ebp-330h]
  int v85; // [esp+3Ch] [ebp-32Ch]
  char v86[16]; // [esp+48h] [ebp-320h] BYREF
  int v87; // [esp+58h] [ebp-310h]
  char v88[652]; // [esp+ABh] [ebp-2BDh] BYREF
  char v89[21]; // [esp+337h] [ebp-31h] BYREF
  unsigned int v90; // [esp+34Ch] [ebp-1Ch]

  n = a2;
  v81 = a3;
  v90 = __readgsdword(0x14u);
  s = a1;
  v4 = *(_QWORD *)&qword_80624D0;
  v83 = a4;
  if ( *(&qword_80624D0 + 1) == (void *)dword_80624CC )
  {
    if ( (unsigned int)*(&qword_80624D0 + 1) > 0xFFFFFF )
      sub_8058C00();
    LODWORD(v4) = sub_8058AA0(qword_80624D0, (_DWORD)*(&qword_80624D0 + 1) << 8);
    HIDWORD(v4) = *(&qword_80624D0 + 1);
    dword_80624CC *= 2;
    qword_80624D0 = (void *)v4;
  }
  v5 = v4 + (HIDWORD(v4) << 7);
  v85 = v5;
  v6 = 128;
  if ( (v5 & 1) != 0 )
  {
    *(_BYTE *)v5 = 0;
    LOBYTE(v6) = 127;
    ++v5;
  }
  if ( (v5 & 2) != 0 )
  {
    *(_WORD *)v5 = 0;
    v6 -= 2;
    v5 += 2;
  }
  memset((void *)v5, 0, 4 * (v6 >> 2));
  v7 = (_WORD *)(v5 + 4 * (v6 >> 2));
  if ( (v6 & 2) != 0 )
    *v7++ = 0;
  if ( (v6 & 1) != 0 )
    *(_BYTE *)v7 = 0;
  v8 = v85;
  v9 = n;
  v10 = v81 == 0;
  *(_DWORD *)(v85 + 96) = 0;
  *(_DWORD *)(v8 + 100) = 0;
  *(_DWORD *)(v8 + 104) = v9;
  if ( !v10 || byte_8062452 || n == 3 && byte_806235C && (sub_804BF90(19) || sub_804BF90(18) || sub_804BF90(20)) )
    goto LABEL_12;
  if ( byte_80624EE || (v18 = 0, byte_8062454) )
  {
    if ( !n || n == 6 )
    {
      v11 = dword_8062400;
      if ( dword_8062400 == 5 || byte_806235D || byte_8062364 )
      {
LABEL_13:
        v12 = s;
        if ( *s == 47 || !*v83 )
          goto LABEL_15;
        v43 = strlen(s);
        v44 = alloca(v43 + strlen(v83) + 17);
        v12 = v79;
        v45 = *v83;
        if ( *v83 == 46 )
        {
          if ( v83[1] )
            goto LABEL_97;
          v46 = v79;
        }
        else
        {
          v46 = v79;
          if ( v45 )
          {
LABEL_97:
            v46 = v79;
            v47 = v83;
            do
            {
              ++v47;
              *v46 = v45;
              v45 = *v47;
              ++v46;
            }
            while ( *v47 );
            if ( v83 < v47 && *(v47 - 1) != 47 )
              *v46++ = 47;
          }
        }
        v48 = s;
        for ( i = *s; *v48; ++v46 )
        {
          ++v48;
          *v46 = i;
          i = *v48;
        }
        *v46 = 0;
LABEL_15:
        v83 = (char *)(v85 + 8);
        if ( v11 >= 3 )
        {
          if ( v11 <= 4 )
          {
            if ( v81 )
            {
              v13 = 1;
              v37 = __xstat64(3, v12, v83);
              v14 = v37;
              if ( v11 == 3
                || (v37 < 0 ? (v80 = v37, v73 = __errno_location(), v14 = v80, v38 = *v73 == 2) : (v38 = (*(_DWORD *)(v85 + 24) & 0xF000) != 0x4000),
                    v13 = 1,
                    !v38) )
              {
LABEL_17:
                if ( !v14 )
                  goto LABEL_18;
                goto LABEL_47;
              }
            }
          }
          else if ( v11 == 5 )
          {
            v13 = 1;
            v14 = __xstat64(3, v12, v85 + 8);
            if ( !v14 )
            {
LABEL_18:
              v15 = v85;
              v10 = n == 5;
              *(_BYTE *)(v85 + 116) = 1;
              if ( v10 || (*(_DWORD *)(v15 + 24) & 0xF000) == 0x8000 )
              {
                if ( byte_806235C )
                {
                  v80 = v14;
                  v30 = sub_804BF90(21);
                  v14 = v80;
                  if ( v30 )
                    *(_BYTE *)(v85 + 124) = 0;
                }
              }
              if ( dword_8062360 && !byte_8062450 )
                goto LABEL_22;
              v80 = v14;
              v78 = (const char **)(v85 + 112);
              if ( v13 )
                v31 = sub_8059550((int)v12, v78);
              else
                v31 = sub_80595E0((int)v12, v78);
              v32 = v80;
              if ( v31 < 0 )
              {
                *(_DWORD *)(v85 + 112) = &unk_80622B4;
                v80 = v32;
                v39 = __errno_location();
                v32 = v80;
                v40 = *v39;
                if ( v40 != 61 && v40 != 95 )
                {
                  *(_DWORD *)(v85 + 120) = 0;
                  goto LABEL_114;
                }
                v33 = 0;
              }
              else
              {
                v33 = strcmp("unlabeled", *(const char **)(v85 + 112)) != 0;
              }
              v34 = 0;
              if ( !dword_8062360 )
              {
                LOBYTE(v80) = v33;
                v57 = sub_8051AA0((int)v12, (int)v83);
                v33 = v80;
                v32 = (unsigned int)v57 >> 31;
                v34 = v57 > 0;
              }
              if ( v33 )
              {
                v35 = 1;
                v36 = 1;
                if ( !v34 )
                  goto LABEL_78;
              }
              else if ( !v34 )
              {
                v35 = 0;
                v36 = 0;
LABEL_78:
                byte_8062CB8 |= v35;
                *(_DWORD *)(v85 + 120) = v36;
                if ( !v32 )
                {
LABEL_22:
                  v16 = *(_DWORD *)(v85 + 24);
                  v17 = v16 & 0xF000;
                  if ( v17 == 40960 )
                  {
                    if ( !dword_8062360 || byte_8062364 )
                    {
                      v66 = sub_8051B00(v12, *(_DWORD *)(v85 + 52));
                      *(_DWORD *)(v85 + 4) = v66;
                      if ( v66
                        || (v70 = 0,
                            v76 = dcgettext(0, "cannot read symbolic link %s", 5),
                            sub_804D570(v81, v76, (int)v12),
                            (v66 = *(char **)(v85 + 4)) != 0) )
                      {
                        if ( *v66 == 47 || (v67 = strrchr(v12, 47)) == 0 )
                        {
                          v70 = (char *)sub_8058BD0(v66);
                        }
                        else
                        {
                          v68 = v67 - v12;
                          n = v67 - v12 + 1;
                          v69 = strlen(v66);
                          v70 = (char *)sub_8058A70(v68 + v69 + 2);
                          strncpy(v70, v12, n);
                          strcpy(&v70[n], v66);
                        }
                        if ( v70 && ((unsigned int)dword_8062408 > 1 || byte_8062364) && !__xstat64(3, v70, v86) )
                        {
                          v10 = v81 == 0;
                          *(_BYTE *)(v85 + 117) = 1;
                          if ( v10 || !dword_8062360 || (v87 & 0xF000) != 0x4000 )
                            *(_DWORD *)(v85 + 108) = v87;
                        }
                      }
                      free(v70);
                      v16 = *(_DWORD *)(v85 + 24);
                      v17 = v16 & 0xF000;
                      if ( v17 != 40960 )
                        goto LABEL_23;
                      if ( byte_8062364 )
                        goto LABEL_131;
                    }
                    *(_BYTE *)(v85 + 117) = 1;
                    v17 = v16 & 0xF000;
                    if ( v17 == 40960 )
                    {
LABEL_131:
                      *(_DWORD *)(v85 + 104) = 6;
                      goto LABEL_25;
                    }
                  }
LABEL_23:
                  if ( v17 == 0x4000 )
                  {
                    if ( !v81 || byte_8062404 )
                      *(_DWORD *)(v85 + 104) = 3;
                    else
                      *(_DWORD *)(v85 + 104) = 9;
                  }
                  else
                  {
                    *(_DWORD *)(v85 + 104) = 5;
                  }
LABEL_25:
                  v18 = *(_DWORD *)(v85 + 64);
                  if ( !dword_8062360 || byte_8062451 )
                  {
                    v19 = sub_8053850(*(_QWORD *)(v85 + 64), (int)v88, dword_80624FC, 512LL, qword_8062500);
                    v20 = sub_8055350(v19, 0);
                    if ( v20 > dword_8062CC0 )
                      dword_8062CC0 = v20;
                    if ( !dword_8062360 )
                    {
                      if ( byte_80622A8 )
                      {
                        v71 = sub_804D660(*(_DWORD *)(v85 + 32), v21);
                        if ( v71 > dword_8062CC8 )
                          dword_8062CC8 = v71;
                      }
                      if ( byte_80622A9 )
                      {
                        v22 = v85;
                        v23 = *(_DWORD *)(v85 + 36);
                        if ( byte_80624ED || (v74 = (char *)sub_80549F0(*(_DWORD *)(v85 + 36))) == 0 )
                        {
                          v24 = sub_804D600(v23, v22);
                        }
                        else
                        {
                          v75 = sub_8055350(v74, 0);
                          v24 = 0;
                          if ( v75 >= 0 )
                            v24 = v75;
                        }
                        if ( dword_8062CCC < v24 )
                          dword_8062CCC = v24;
                      }
                      if ( byte_8062510 )
                      {
                        v72 = sub_804D660(*(_DWORD *)(v85 + 32), v21);
                        if ( v72 > dword_8062CD0 )
                          dword_8062CD0 = v72;
                      }
                    }
                  }
                  if ( byte_8062450 && (v25 = strlen(*(const char **)(v85 + 112)), v25 > dword_8062CD4) )
                  {
                    dword_8062CD4 = v25;
                    if ( dword_8062360 )
                      goto LABEL_40;
                  }
                  else if ( dword_8062360 )
                  {
                    goto LABEL_40;
                  }
                  v50 = (const char *)sub_8054C60(*(_DWORD *)(v85 + 28), 0, (int)v89);
                  v51 = strlen(v50);
                  if ( v51 > dword_8062CC4 )
                    dword_8062CC4 = v51;
                  v52 = *(_DWORD *)(v85 + 24) & 0xF000;
                  if ( v52 == 24576 || v52 == 0x2000 )
                  {
                    v77 = (*(_DWORD *)(v85 + 40) >> 8) & 0xFFF | (unsigned __int64)(*(_DWORD *)(v85 + 44) & 0xFFFFF000);
                    v58 = (const char *)sub_8054C60(v77, HIDWORD(v77), (int)v88);
                    v59 = strlen(v58);
                    if ( v59 > dword_8062CD8 )
                      dword_8062CD8 = v59;
                    v60 = *(_QWORD *)(v85 + 40);
                    v61 = v60 >> 12;
                    LOBYTE(v61) = 0;
                    v62 = (const char *)sub_8054C60((unsigned __int8)v60 | v61, 0, (int)v88);
                    v63 = strlen(v62);
                    v64 = dword_8062CDC;
                    if ( v63 > dword_8062CDC )
                    {
                      dword_8062CDC = v63;
                      v64 = v63;
                    }
                    v65 = v64 + dword_8062CD8 + 2;
                    if ( v65 > dword_8062CE0 )
                    {
                      dword_8062CE0 = v65;
                      v26 = byte_80624EE;
                      goto LABEL_41;
                    }
                  }
                  else
                  {
                    v53 = sub_8053850(*(_QWORD *)(v85 + 52), (int)v88, dword_80624FC, 1LL, qword_80622A0);
                    v54 = sub_8055350(v53, 0);
                    if ( v54 > dword_8062CE0 )
                      dword_8062CE0 = v54;
                  }
LABEL_40:
                  v26 = byte_80624EE;
LABEL_41:
                  if ( v26 )
                  {
                    v41 = (const char *)sub_8054C60(*(_DWORD *)(v85 + 96), *(_DWORD *)(v85 + 100), (int)v88);
                    v42 = strlen(v41);
                    if ( v42 > dword_8062CBC )
                      dword_8062CBC = v42;
                  }
                  goto LABEL_42;
                }
LABEL_114:
                v55 = sub_8056980((int)v12);
                v56 = __errno_location();
                error(0, *v56, "%s", v55);
                goto LABEL_22;
              }
              v35 = 1;
              v36 = 2;
              goto LABEL_78;
            }
LABEL_47:
            v18 = 0;
            v29 = dcgettext(0, "cannot access %s", 5);
            sub_804D570(v81, v29, (int)v12);
            if ( v81 )
              return v18;
            goto LABEL_42;
          }
        }
        v13 = 0;
        v14 = __lxstat64(3, v12, v83);
        goto LABEL_17;
      }
    }
    if ( byte_80624EE )
    {
LABEL_12:
      v11 = dword_8062400;
      goto LABEL_13;
    }
    if ( byte_8062454 )
    {
      if ( !n )
        goto LABEL_12;
      v18 = 0;
      if ( n == 5
        && (dword_8062408 == 3
         || byte_806235C && (sub_804BF90(14) || sub_804BF90(16) || sub_804BF90(17) || sub_804BF90(21))) )
      {
        goto LABEL_12;
      }
    }
    else
    {
      v18 = 0;
    }
  }
LABEL_42:
  v27 = sub_8058BD0(s);
  *(&qword_80624D0 + 1) = (char *)*(&qword_80624D0 + 1) + 1;
  *(_DWORD *)v85 = v27;
  return v18;
}
// 804ED92: variable 'v22' is possibly undefined
// 804F6A9: variable 'v21' is possibly undefined
// 8049AD0: using guessed type int __cdecl __xstat64(_DWORD, _DWORD, _DWORD);
// 8049AE0: using guessed type int __cdecl __lxstat64(_DWORD, _DWORD, _DWORD);
// 80622A0: using guessed type __int64 qword_80622A0;
// 80622A8: using guessed type char byte_80622A8;
// 80622A9: using guessed type char byte_80622A9;
// 806235C: using guessed type char byte_806235C;
// 806235D: using guessed type char byte_806235D;
// 8062360: using guessed type int dword_8062360;
// 8062364: using guessed type char byte_8062364;
// 8062400: using guessed type int dword_8062400;
// 8062404: using guessed type char byte_8062404;
// 8062408: using guessed type int dword_8062408;
// 8062450: using guessed type char byte_8062450;
// 8062451: using guessed type char byte_8062451;
// 8062452: using guessed type char byte_8062452;
// 8062454: using guessed type char byte_8062454;
// 80624CC: using guessed type int dword_80624CC;
// 80624ED: using guessed type char byte_80624ED;
// 80624EE: using guessed type char byte_80624EE;
// 80624FC: using guessed type int dword_80624FC;
// 8062500: using guessed type __int64 qword_8062500;
// 8062510: using guessed type char byte_8062510;
// 8062CB8: using guessed type char byte_8062CB8;
// 8062CBC: using guessed type int dword_8062CBC;
// 8062CC0: using guessed type int dword_8062CC0;
// 8062CC4: using guessed type int dword_8062CC4;
// 8062CC8: using guessed type int dword_8062CC8;
// 8062CCC: using guessed type int dword_8062CCC;
// 8062CD0: using guessed type int dword_8062CD0;
// 8062CD4: using guessed type int dword_8062CD4;
// 8062CD8: using guessed type int dword_8062CD8;
// 8062CDC: using guessed type int dword_8062CDC;
// 8062CE0: using guessed type int dword_8062CE0;
// 804EB40: using guessed type char var_31[21];
// 804EB40: using guessed type char var_320[16];

//----- (0804F7E0) --------------------------------------------------------
unsigned int __usercall sub_804F7E0@<eax>(char a1@<al>)
{
  int v1; // ebp
  unsigned int v2; // edx
  void *v3; // eax
  unsigned int v4; // ebx
  unsigned int v5; // ecx
  unsigned int v6; // esi
  char *v7; // eax
  unsigned int v8; // esi
  _DWORD *v9; // ecx
  int v10; // edx
  _DWORD *v11; // ebx
  int v12; // esi
  unsigned int i; // edx
  int v14; // ecx
  unsigned int v15; // eax
  int v16; // eax
  unsigned int v17; // ecx
  _DWORD *v18; // ebx
  unsigned int v19; // edi
  unsigned int v20; // esi
  unsigned int v21; // eax
  unsigned int *v22; // esi
  unsigned int result; // eax
  char *v24; // edx
  unsigned int v25; // [esp+18h] [ebp-34h]
  unsigned int v26; // [esp+1Ch] [ebp-30h]
  int v27; // [esp+20h] [ebp-2Ch]
  unsigned int v29; // [esp+28h] [ebp-24h]
  unsigned int v30; // [esp+2Ch] [ebp-20h]

  v1 = (int)*(&qword_80624D0 + 1);
  v2 = (unsigned int)*(&qword_80624D0 + 1);
  if ( dword_8062514 <= (unsigned int)*(&qword_80624D0 + 1) )
    v2 = dword_8062514;
  v26 = v2;
  if ( v2 > dword_8062DA0 )
  {
    if ( v2 < (unsigned int)dword_8062514 >> 1 )
    {
      if ( v2 > 0xAAAAAAA )
        goto LABEL_42;
      v4 = 2 * v2;
      dword_8062D9C = sub_8058AA0(dword_8062D9C, 24 * v2);
    }
    else
    {
      if ( (unsigned int)dword_8062514 > 0x15555555 )
        goto LABEL_42;
      v3 = sub_8058AA0(dword_8062D9C, 12 * dword_8062514);
      v4 = dword_8062514;
      dword_8062D9C = v3;
    }
    v5 = v4 + dword_8062DA0 + 1;
    if ( v4 <= v5 && v5 == (v4 - dword_8062DA0) * v5 / (v4 - dword_8062DA0) )
    {
      v6 = ((v4 - dword_8062DA0) * v5) >> 1;
      if ( v6 <= 0x3FFFFFFF )
      {
        v7 = (char *)sub_8058A70(4 * v6);
        if ( v4 > dword_8062DA0 )
        {
          v8 = dword_8062DA0 + 1;
          v9 = (char *)dword_8062D9C + 12 * dword_8062DA0 + 8;
          v10 = 4 * (dword_8062DA0 + 1);
          while ( 1 )
          {
            *v9 = v7;
            v7 += v10;
            v9 += 3;
            v10 += 4;
            if ( v4 <= v8 )
              break;
            ++v8;
          }
        }
        v1 = (int)*(&qword_80624D0 + 1);
        dword_8062DA0 = v4;
        goto LABEL_15;
      }
    }
LABEL_42:
    sub_8058C00();
  }
LABEL_15:
  if ( v26 )
  {
    v11 = dword_8062D9C;
    v12 = 3;
    for ( i = 0; ; ++i )
    {
      v14 = v11[2];
      v15 = 0;
      *(_BYTE *)v11 = 1;
      v11[1] = v12;
      do
        *(_DWORD *)(v14 + 4 * v15++) = 3;
      while ( i >= v15 );
      v11 += 3;
      v12 += 3;
      if ( i + 1 == v26 )
        break;
    }
  }
  if ( v1 )
  {
    v25 = 0;
    do
    {
      v16 = sub_804D3F0(*((_DWORD *)dword_8062CB4 + v25));
      v30 = (unsigned int)*(&qword_80624D0 + 1);
      v27 = v16;
      if ( v26 )
      {
        v17 = 1;
        v18 = dword_8062D9C;
        v19 = (unsigned int)*(&qword_80624D0 + 1);
        v29 = dword_8062508;
        while ( 1 )
        {
          if ( *(_BYTE *)v18 )
          {
            v20 = a1 ? v25 / (v19 / v17) : v25 % v17;
            v21 = v27 + 2 * (v17 - 1 != v20);
            v22 = (unsigned int *)(v18[2] + 4 * v20);
            if ( v21 > *v22 )
            {
              v18[1] += v21 - *v22;
              *v22 = v21;
              *(_BYTE *)v18 = v18[1] < v29;
            }
          }
          v18 += 3;
          ++v19;
          if ( v26 <= v17 )
            break;
          ++v17;
        }
      }
      ++v25;
    }
    while ( v25 < v30 );
  }
  result = v26;
  if ( v26 > 1 && !*((_BYTE *)dword_8062D9C + 12 * v26 - 12) )
  {
    v24 = (char *)dword_8062D9C + 12 * v26 - 24;
    do
    {
      if ( --result == 1 )
        break;
      v24 -= 12;
    }
    while ( !v24[12] );
  }
  return result;
}
// 8062508: using guessed type int dword_8062508;
// 8062514: using guessed type int dword_8062514;
// 8062DA0: using guessed type int dword_8062DA0;

//----- (0804FA80) --------------------------------------------------------
int sub_804FA80()
{
  int result; // eax
  char *v1; // edx
  char *v2; // ebp
  int v3; // ebx
  int v4; // edi
  int v5; // esi
  unsigned int v6; // ebx
  int v7; // ebp
  int v8; // ecx
  FILE *v9; // eax
  char *v10; // edx
  int v11; // edi
  int v12; // esi
  int v13; // esi
  int v14; // ebx
  int v15; // edi
  int v16; // eax
  unsigned int v17; // eax
  int v18; // ebp
  char v19; // dl
  FILE *v20; // eax
  char *v21; // ecx
  FILE *v22; // eax
  char *v23; // ecx
  unsigned int v24; // ebx
  unsigned int v25; // ecx
  char *IO_write_ptr; // edx
  unsigned int v27; // ebx
  char *v28; // edx
  unsigned int v29; // eax
  unsigned int v30; // et2
  int v31; // ebp
  int v32; // ebx
  unsigned int v33; // esi
  int v34; // edi
  int v35; // eax
  FILE *v36; // eax
  char *v37; // edx
  int v38; // [esp+14h] [ebp-38h]
  int v39; // [esp+14h] [ebp-38h]
  unsigned int v40; // [esp+18h] [ebp-34h]
  int v41; // [esp+18h] [ebp-34h]
  int v42; // [esp+18h] [ebp-34h]
  char *v43; // [esp+1Ch] [ebp-30h]
  int v44; // [esp+1Ch] [ebp-30h]
  int v45; // [esp+20h] [ebp-2Ch]
  char *v46; // [esp+24h] [ebp-28h]
  unsigned int v47; // [esp+2Ch] [ebp-20h]

  result = dword_8062360;
  switch ( dword_8062360 )
  {
    case 0:
      v24 = 0;
      if ( *(&qword_80624D0 + 1) )
      {
        do
        {
          sub_804DF20();
          sub_804E240(*((_DWORD *)dword_8062CB4 + v24), v25);
          result = (int)stdout;
          IO_write_ptr = stdout->_IO_write_ptr;
          if ( IO_write_ptr >= stdout->_IO_write_end )
          {
            result = __overflow(stdout, 10);
          }
          else
          {
            *IO_write_ptr = 10;
            *(_DWORD *)(result + 20) = IO_write_ptr + 1;
          }
          ++dword_80624D8;
          ++v24;
        }
        while ( (unsigned int)*(&qword_80624D0 + 1) > v24 );
      }
      break;
    case 1:
      v27 = 0;
      if ( *(&qword_80624D0 + 1) )
      {
        do
        {
          sub_804DF70(*((_DWORD *)dword_8062CB4 + v27), 0);
          result = (int)stdout;
          v28 = stdout->_IO_write_ptr;
          if ( v28 >= stdout->_IO_write_end )
          {
            result = __overflow(stdout, 10);
          }
          else
          {
            *v28 = 10;
            *(_DWORD *)(result + 20) = v28 + 1;
          }
          ++v27;
        }
        while ( (unsigned int)*(&qword_80624D0 + 1) > v27 );
      }
      break;
    case 2:
      v29 = sub_804F7E0(1);
      v47 = 0;
      v46 = (char *)dword_8062D9C + 12 * v29 - 12;
      v30 = (unsigned int)*(&qword_80624D0 + 1) % v29;
      result = (unsigned int)*(&qword_80624D0 + 1) / v29;
      v45 = result + (v30 != 0);
      if ( v45 )
      {
        do
        {
          v31 = 0;
          v32 = 0;
          v33 = v47;
          v34 = 4 * v47;
          while ( 1 )
          {
            v39 = *(_DWORD *)((char *)dword_8062CB4 + v34);
            v42 = sub_804D3F0(v39);
            v35 = *(_DWORD *)(*((_DWORD *)v46 + 2) + v31);
            v31 += 4;
            v44 = v35;
            sub_804DF70(v39, v32);
            v33 += v45;
            v34 += 4 * v45;
            if ( v33 >= (unsigned int)*(&qword_80624D0 + 1) )
              break;
            sub_804C970(v32 + v42, v32 + v44);
            v32 += v44;
          }
          v36 = stdout;
          v37 = stdout->_IO_write_ptr;
          if ( v37 >= stdout->_IO_write_end )
          {
            __overflow(stdout, 10);
          }
          else
          {
            *v37 = 10;
            v36->_IO_write_ptr = v37 + 1;
          }
          ++v47;
          result = v45;
        }
        while ( v47 != v45 );
      }
      break;
    case 3:
      v40 = sub_804F7E0(0);
      v2 = (char *)dword_8062D9C + 12 * v40 - 12;
      v3 = *(_DWORD *)dword_8062CB4;
      v4 = sub_804D3F0(*(_DWORD *)dword_8062CB4);
      v5 = **((_DWORD **)v2 + 2);
      sub_804DF70(v3, 0);
      if ( (unsigned int)*(&qword_80624D0 + 1) > 1 )
      {
        v6 = 1;
        v43 = v2;
        v7 = 0;
        v8 = v5;
        do
        {
          v12 = v6 % v40;
          if ( v6 % v40 )
          {
            v38 = v7 + v8;
            sub_804C970(v4 + v7, v7 + v8);
            v7 = v38;
          }
          else
          {
            v9 = stdout;
            v10 = stdout->_IO_write_ptr;
            if ( v10 >= stdout->_IO_write_end )
            {
              v7 = 0;
              __overflow(stdout, 10);
            }
            else
            {
              *v10 = 10;
              v7 = 0;
              v9->_IO_write_ptr = v10 + 1;
            }
          }
          v11 = *((_DWORD *)dword_8062CB4 + v6++);
          sub_804DF70(v11, v7);
          v4 = sub_804D3F0(v11);
          v8 = *(_DWORD *)(*((_DWORD *)v43 + 2) + 4 * v12);
        }
        while ( v6 < (unsigned int)*(&qword_80624D0 + 1) );
      }
      goto LABEL_2;
    case 4:
      if ( *(&qword_80624D0 + 1) )
      {
        v13 = 0;
        v14 = 0;
        v15 = *(_DWORD *)dword_8062CB4;
        v41 = sub_804D3F0(*(_DWORD *)dword_8062CB4);
        while ( 1 )
        {
          sub_804DF70(v15, v14);
          if ( ++v13 >= (unsigned int)*(&qword_80624D0 + 1) )
            break;
          v14 += v41;
          v15 = *((_DWORD *)dword_8062CB4 + v13);
          v16 = sub_804D3F0(v15);
          v41 = v16;
          if ( v13 )
          {
            v14 += 2;
            v17 = v14 + v16;
            v18 = v17 < dword_8062508 ? 32 : 10;
            v19 = v18;
            if ( v17 >= dword_8062508 )
              v14 = 0;
            v20 = stdout;
            v21 = stdout->_IO_write_ptr;
            if ( v21 >= stdout->_IO_write_end )
            {
              __overflow(stdout, 44);
              v19 = v18;
            }
            else
            {
              *v21 = 44;
              v20->_IO_write_ptr = v21 + 1;
            }
            v22 = stdout;
            v23 = stdout->_IO_write_ptr;
            if ( v23 >= stdout->_IO_write_end )
            {
              __overflow(stdout, (unsigned __int8)v18);
            }
            else
            {
              *v23 = v19;
              v22->_IO_write_ptr = v23 + 1;
            }
          }
        }
      }
LABEL_2:
      result = (int)stdout;
      v1 = stdout->_IO_write_ptr;
      if ( v1 >= stdout->_IO_write_end )
      {
        result = __overflow(stdout, 10);
      }
      else
      {
        *v1 = 10;
        *(_DWORD *)(result + 20) = v1 + 1;
      }
      break;
    default:
      return result;
  }
  return result;
}
// 804FC75: variable 'v25' is possibly undefined
// 8062360: using guessed type int dword_8062360;
// 80624D8: using guessed type int dword_80624D8;
// 8062508: using guessed type int dword_8062508;

//----- (0804FEA0) --------------------------------------------------------
int __cdecl sub_804FEA0(char *s1, char *s2)
{
  int v2; // ecx
  int v3; // ebx
  unsigned int v4; // esi
  unsigned int v5; // edi

  v2 = *((_DWORD *)s1 + 14);
  v3 = *((_DWORD *)s2 + 14);
  v4 = *((_DWORD *)s1 + 13);
  v5 = *((_DWORD *)s2 + 13);
  if ( v3 < v2 )
    return -1;
  if ( v3 > v2 )
    return 1;
  if ( v5 < v4 )
    return -1;
  if ( v3 >= v2 && v5 > v4 )
    return 1;
  return sub_804D7A0(*(char **)s1, *(char **)s2);
}

//----- (0804FF30) --------------------------------------------------------
int __cdecl sub_804FF30(int a1, int a2)
{
  int v2; // ecx
  int v3; // ebx
  unsigned int v4; // esi
  unsigned int v5; // edi

  v2 = *(_DWORD *)(a1 + 56);
  v3 = *(_DWORD *)(a2 + 56);
  v4 = *(_DWORD *)(a1 + 52);
  v5 = *(_DWORD *)(a2 + 52);
  if ( v3 < v2 )
    return -1;
  if ( v3 > v2 )
    return 1;
  if ( v5 < v4 )
    return -1;
  if ( v3 >= v2 && v5 > v4 )
    return 1;
  return strcmp(*(const char **)a1, *(const char **)a2);
}

//----- (0804FFC0) --------------------------------------------------------
int __cdecl sub_804FFC0(char *s1, char *s2)
{
  int v2; // ebx
  int v3; // ecx
  unsigned int v4; // esi
  unsigned int v5; // edi

  v2 = *((_DWORD *)s1 + 14);
  v3 = *((_DWORD *)s2 + 14);
  v4 = *((_DWORD *)s2 + 13);
  v5 = *((_DWORD *)s1 + 13);
  if ( v2 < v3 )
    return -1;
  if ( v2 > v3 )
    return 1;
  if ( v5 < v4 )
    return -1;
  if ( v2 >= v3 && v5 > v4 )
    return 1;
  return sub_804D7A0(*(char **)s2, *(char **)s1);
}

//----- (08050050) --------------------------------------------------------
int __cdecl sub_8050050(int a1, int a2)
{
  int v2; // ebx
  int v3; // ecx
  unsigned int v4; // esi
  unsigned int v5; // edi

  v2 = *(_DWORD *)(a1 + 56);
  v3 = *(_DWORD *)(a2 + 56);
  v4 = *(_DWORD *)(a2 + 52);
  v5 = *(_DWORD *)(a1 + 52);
  if ( v2 < v3 )
    return -1;
  if ( v2 > v3 )
    return 1;
  if ( v5 < v4 )
    return -1;
  if ( v2 >= v3 && v5 > v4 )
    return 1;
  return strcmp(*(const char **)a2, *(const char **)a1);
}

//----- (080500E0) --------------------------------------------------------
int __cdecl sub_80500E0(char *s1, char *s2)
{
  bool v2; // bl
  int v3; // ebx
  int v4; // ecx
  unsigned int v5; // edi
  unsigned int v6; // esi

  v2 = *((_DWORD *)s2 + 26) == 9 || *((_DWORD *)s2 + 26) == 3;
  if ( *((_DWORD *)s1 + 26) == 3 || *((_DWORD *)s1 + 26) == 9 )
  {
    if ( !v2 )
      return -1;
  }
  else if ( v2 )
  {
    return 1;
  }
  v3 = *((_DWORD *)s2 + 14);
  v4 = *((_DWORD *)s1 + 14);
  v5 = *((_DWORD *)s2 + 13);
  v6 = *((_DWORD *)s1 + 13);
  if ( v3 < v4 )
    return -1;
  if ( v3 > v4 )
    return 1;
  if ( v5 < v6 )
    return -1;
  if ( v3 >= v4 && v5 > v6 )
    return 1;
  return sub_804D7A0(*(char **)s1, *(char **)s2);
}

//----- (080501A0) --------------------------------------------------------
int __cdecl sub_80501A0(int a1, int a2)
{
  bool v2; // bl
  int v3; // ebx
  int v4; // ecx
  unsigned int v5; // edi
  unsigned int v6; // esi

  v2 = *(_DWORD *)(a2 + 104) == 9 || *(_DWORD *)(a2 + 104) == 3;
  if ( *(_DWORD *)(a1 + 104) == 3 || *(_DWORD *)(a1 + 104) == 9 )
  {
    if ( !v2 )
      return -1;
  }
  else if ( v2 )
  {
    return 1;
  }
  v3 = *(_DWORD *)(a2 + 56);
  v4 = *(_DWORD *)(a1 + 56);
  v5 = *(_DWORD *)(a2 + 52);
  v6 = *(_DWORD *)(a1 + 52);
  if ( v3 < v4 )
    return -1;
  if ( v3 > v4 )
    return 1;
  if ( v5 < v6 )
    return -1;
  if ( v3 >= v4 && v5 > v6 )
    return 1;
  return strcmp(*(const char **)a1, *(const char **)a2);
}

//----- (08050260) --------------------------------------------------------
int __cdecl sub_8050260(char *s1, char *s2)
{
  bool v2; // bl
  int v3; // ebx
  int v4; // ecx
  unsigned int v5; // edi
  unsigned int v6; // esi

  v2 = *((_DWORD *)s2 + 26) == 9 || *((_DWORD *)s2 + 26) == 3;
  if ( *((_DWORD *)s1 + 26) == 3 || *((_DWORD *)s1 + 26) == 9 )
  {
    if ( !v2 )
      return -1;
  }
  else if ( v2 )
  {
    return 1;
  }
  v3 = *((_DWORD *)s1 + 14);
  v4 = *((_DWORD *)s2 + 14);
  v5 = *((_DWORD *)s1 + 13);
  v6 = *((_DWORD *)s2 + 13);
  if ( v3 < v4 )
    return -1;
  if ( v3 > v4 )
    return 1;
  if ( v5 < v6 )
    return -1;
  if ( v3 >= v4 && v5 > v6 )
    return 1;
  return sub_804D7A0(*(char **)s2, *(char **)s1);
}

//----- (08050320) --------------------------------------------------------
int __cdecl sub_8050320(char *s1, char *s2)
{
  int result; // eax
  int v3; // edi
  int v4; // ebx
  int v5; // esi

  result = -1;
  v3 = *((_DWORD *)s2 + 22);
  v4 = *((_DWORD *)s1 + 23);
  v5 = *((_DWORD *)s2 + 23);
  if ( *((_DWORD *)s1 + 22) <= v3 )
  {
    result = 1;
    if ( *((_DWORD *)s1 + 22) >= v3 )
    {
      result = v5 - v4;
      if ( v5 == v4 )
        return sub_804D7A0(*(char **)s1, *(char **)s2);
    }
  }
  return result;
}

//----- (08050390) --------------------------------------------------------
int __cdecl sub_8050390(int a1, int a2)
{
  int result; // eax
  int v3; // edi
  int v4; // ebx
  int v5; // esi

  result = -1;
  v3 = *(_DWORD *)(a2 + 88);
  v4 = *(_DWORD *)(a1 + 92);
  v5 = *(_DWORD *)(a2 + 92);
  if ( *(_DWORD *)(a1 + 88) <= v3 )
  {
    result = 1;
    if ( *(_DWORD *)(a1 + 88) >= v3 )
    {
      result = v5 - v4;
      if ( v5 == v4 )
        return strcmp(*(const char **)a1, *(const char **)a2);
    }
  }
  return result;
}

//----- (08050400) --------------------------------------------------------
int __cdecl sub_8050400(char *s1, char *s2)
{
  int result; // eax
  int v3; // edi
  int v4; // ebx
  int v5; // esi

  result = -1;
  v3 = *((_DWORD *)s1 + 22);
  v4 = *((_DWORD *)s2 + 23);
  v5 = *((_DWORD *)s1 + 23);
  if ( *((_DWORD *)s2 + 22) <= v3 )
  {
    result = 1;
    if ( *((_DWORD *)s2 + 22) >= v3 )
    {
      result = v5 - v4;
      if ( v5 == v4 )
        return sub_804D7A0(*(char **)s2, *(char **)s1);
    }
  }
  return result;
}

//----- (08050470) --------------------------------------------------------
int __cdecl sub_8050470(int a1, int a2)
{
  int result; // eax
  int v3; // edi
  int v4; // ebx
  int v5; // esi

  result = -1;
  v3 = *(_DWORD *)(a1 + 88);
  v4 = *(_DWORD *)(a2 + 92);
  v5 = *(_DWORD *)(a1 + 92);
  if ( *(_DWORD *)(a2 + 88) <= v3 )
  {
    result = 1;
    if ( *(_DWORD *)(a2 + 88) >= v3 )
    {
      result = v5 - v4;
      if ( v5 == v4 )
        return strcmp(*(const char **)a2, *(const char **)a1);
    }
  }
  return result;
}

//----- (080504E0) --------------------------------------------------------
int __cdecl sub_80504E0(char *s1, char *s2)
{
  bool v2; // bl
  int v3; // edi
  int result; // eax
  int v5; // ebx
  int v6; // esi

  v2 = *((_DWORD *)s2 + 26) == 9 || *((_DWORD *)s2 + 26) == 3;
  if ( *((_DWORD *)s1 + 26) == 3 || *((_DWORD *)s1 + 26) == 9 )
  {
    if ( !v2 )
      return -1;
  }
  else if ( v2 )
  {
    return 1;
  }
  v3 = *((_DWORD *)s2 + 22);
  result = -1;
  v5 = *((_DWORD *)s1 + 23);
  v6 = *((_DWORD *)s2 + 23);
  if ( *((_DWORD *)s1 + 22) <= v3 )
  {
    result = 1;
    if ( *((_DWORD *)s1 + 22) >= v3 )
    {
      result = v6 - v5;
      if ( v6 == v5 )
        return sub_804D7A0(*(char **)s1, *(char **)s2);
    }
  }
  return result;
}

//----- (08050590) --------------------------------------------------------
int __cdecl sub_8050590(int a1, int a2)
{
  bool v2; // bl
  int v3; // edi
  int result; // eax
  int v5; // ebx
  int v6; // esi

  v2 = *(_DWORD *)(a2 + 104) == 9 || *(_DWORD *)(a2 + 104) == 3;
  if ( *(_DWORD *)(a1 + 104) == 3 || *(_DWORD *)(a1 + 104) == 9 )
  {
    if ( !v2 )
      return -1;
  }
  else if ( v2 )
  {
    return 1;
  }
  v3 = *(_DWORD *)(a2 + 88);
  result = -1;
  v5 = *(_DWORD *)(a1 + 92);
  v6 = *(_DWORD *)(a2 + 92);
  if ( *(_DWORD *)(a1 + 88) <= v3 )
  {
    result = 1;
    if ( *(_DWORD *)(a1 + 88) >= v3 )
    {
      result = v6 - v5;
      if ( v6 == v5 )
        return strcmp(*(const char **)a1, *(const char **)a2);
    }
  }
  return result;
}

//----- (08050640) --------------------------------------------------------
int __cdecl sub_8050640(char *s1, char *s2)
{
  bool v2; // bl
  int v3; // edi
  int result; // eax
  int v5; // ebx
  int v6; // esi

  v2 = *((_DWORD *)s2 + 26) == 9 || *((_DWORD *)s2 + 26) == 3;
  if ( *((_DWORD *)s1 + 26) == 3 || *((_DWORD *)s1 + 26) == 9 )
  {
    if ( !v2 )
      return -1;
  }
  else if ( v2 )
  {
    return 1;
  }
  v3 = *((_DWORD *)s1 + 22);
  result = -1;
  v5 = *((_DWORD *)s2 + 23);
  v6 = *((_DWORD *)s1 + 23);
  if ( *((_DWORD *)s2 + 22) <= v3 )
  {
    result = 1;
    if ( *((_DWORD *)s2 + 22) >= v3 )
    {
      result = v6 - v5;
      if ( v6 == v5 )
        return sub_804D7A0(*(char **)s2, *(char **)s1);
    }
  }
  return result;
}

//----- (080506F0) --------------------------------------------------------
int __cdecl sub_80506F0(char *s1, char *s2)
{
  int result; // eax
  int v3; // edi
  int v4; // ebx
  int v5; // esi

  result = -1;
  v3 = *((_DWORD *)s2 + 20);
  v4 = *((_DWORD *)s1 + 21);
  v5 = *((_DWORD *)s2 + 21);
  if ( *((_DWORD *)s1 + 20) <= v3 )
  {
    result = 1;
    if ( *((_DWORD *)s1 + 20) >= v3 )
    {
      result = v5 - v4;
      if ( v5 == v4 )
        return sub_804D7A0(*(char **)s1, *(char **)s2);
    }
  }
  return result;
}

//----- (08050760) --------------------------------------------------------
int __cdecl sub_8050760(int a1, int a2)
{
  int result; // eax
  int v3; // edi
  int v4; // ebx
  int v5; // esi

  result = -1;
  v3 = *(_DWORD *)(a2 + 80);
  v4 = *(_DWORD *)(a1 + 84);
  v5 = *(_DWORD *)(a2 + 84);
  if ( *(_DWORD *)(a1 + 80) <= v3 )
  {
    result = 1;
    if ( *(_DWORD *)(a1 + 80) >= v3 )
    {
      result = v5 - v4;
      if ( v5 == v4 )
        return strcmp(*(const char **)a1, *(const char **)a2);
    }
  }
  return result;
}

//----- (080507D0) --------------------------------------------------------
int __cdecl sub_80507D0(char *s1, char *s2)
{
  int result; // eax
  int v3; // edi
  int v4; // ebx
  int v5; // esi

  result = -1;
  v3 = *((_DWORD *)s1 + 20);
  v4 = *((_DWORD *)s2 + 21);
  v5 = *((_DWORD *)s1 + 21);
  if ( *((_DWORD *)s2 + 20) <= v3 )
  {
    result = 1;
    if ( *((_DWORD *)s2 + 20) >= v3 )
    {
      result = v5 - v4;
      if ( v5 == v4 )
        return sub_804D7A0(*(char **)s2, *(char **)s1);
    }
  }
  return result;
}

//----- (08050840) --------------------------------------------------------
int __cdecl sub_8050840(int a1, int a2)
{
  int result; // eax
  int v3; // edi
  int v4; // ebx
  int v5; // esi

  result = -1;
  v3 = *(_DWORD *)(a1 + 80);
  v4 = *(_DWORD *)(a2 + 84);
  v5 = *(_DWORD *)(a1 + 84);
  if ( *(_DWORD *)(a2 + 80) <= v3 )
  {
    result = 1;
    if ( *(_DWORD *)(a2 + 80) >= v3 )
    {
      result = v5 - v4;
      if ( v5 == v4 )
        return strcmp(*(const char **)a2, *(const char **)a1);
    }
  }
  return result;
}

//----- (080508B0) --------------------------------------------------------
int __cdecl sub_80508B0(char *s1, char *s2)
{
  bool v2; // bl
  int v3; // edi
  int result; // eax
  int v5; // ebx
  int v6; // esi

  v2 = *((_DWORD *)s2 + 26) == 9 || *((_DWORD *)s2 + 26) == 3;
  if ( *((_DWORD *)s1 + 26) == 3 || *((_DWORD *)s1 + 26) == 9 )
  {
    if ( !v2 )
      return -1;
  }
  else if ( v2 )
  {
    return 1;
  }
  v3 = *((_DWORD *)s2 + 20);
  result = -1;
  v5 = *((_DWORD *)s1 + 21);
  v6 = *((_DWORD *)s2 + 21);
  if ( *((_DWORD *)s1 + 20) <= v3 )
  {
    result = 1;
    if ( *((_DWORD *)s1 + 20) >= v3 )
    {
      result = v6 - v5;
      if ( v6 == v5 )
        return sub_804D7A0(*(char **)s1, *(char **)s2);
    }
  }
  return result;
}

//----- (08050960) --------------------------------------------------------
int __cdecl sub_8050960(int a1, int a2)
{
  bool v2; // bl
  int v3; // edi
  int result; // eax
  int v5; // ebx
  int v6; // esi

  v2 = *(_DWORD *)(a2 + 104) == 9 || *(_DWORD *)(a2 + 104) == 3;
  if ( *(_DWORD *)(a1 + 104) == 3 || *(_DWORD *)(a1 + 104) == 9 )
  {
    if ( !v2 )
      return -1;
  }
  else if ( v2 )
  {
    return 1;
  }
  v3 = *(_DWORD *)(a2 + 80);
  result = -1;
  v5 = *(_DWORD *)(a1 + 84);
  v6 = *(_DWORD *)(a2 + 84);
  if ( *(_DWORD *)(a1 + 80) <= v3 )
  {
    result = 1;
    if ( *(_DWORD *)(a1 + 80) >= v3 )
    {
      result = v6 - v5;
      if ( v6 == v5 )
        return strcmp(*(const char **)a1, *(const char **)a2);
    }
  }
  return result;
}

//----- (08050A10) --------------------------------------------------------
int __cdecl sub_8050A10(char *s1, char *s2)
{
  bool v2; // bl
  int v3; // edi
  int result; // eax
  int v5; // ebx
  int v6; // esi

  v2 = *((_DWORD *)s2 + 26) == 9 || *((_DWORD *)s2 + 26) == 3;
  if ( *((_DWORD *)s1 + 26) == 3 || *((_DWORD *)s1 + 26) == 9 )
  {
    if ( !v2 )
      return -1;
  }
  else if ( v2 )
  {
    return 1;
  }
  v3 = *((_DWORD *)s1 + 20);
  result = -1;
  v5 = *((_DWORD *)s2 + 21);
  v6 = *((_DWORD *)s1 + 21);
  if ( *((_DWORD *)s2 + 20) <= v3 )
  {
    result = 1;
    if ( *((_DWORD *)s2 + 20) >= v3 )
    {
      result = v6 - v5;
      if ( v6 == v5 )
        return sub_804D7A0(*(char **)s2, *(char **)s1);
    }
  }
  return result;
}

//----- (08050AC0) --------------------------------------------------------
int __cdecl sub_8050AC0(char *s1, char *s2)
{
  int result; // eax
  int v3; // edi
  int v4; // ebx
  int v5; // esi

  result = -1;
  v3 = *((_DWORD *)s2 + 18);
  v4 = *((_DWORD *)s1 + 19);
  v5 = *((_DWORD *)s2 + 19);
  if ( *((_DWORD *)s1 + 18) <= v3 )
  {
    result = 1;
    if ( *((_DWORD *)s1 + 18) >= v3 )
    {
      result = v5 - v4;
      if ( v5 == v4 )
        return sub_804D7A0(*(char **)s1, *(char **)s2);
    }
  }
  return result;
}

//----- (08050B30) --------------------------------------------------------
int __cdecl sub_8050B30(int a1, int a2)
{
  int result; // eax
  int v3; // edi
  int v4; // ebx
  int v5; // esi

  result = -1;
  v3 = *(_DWORD *)(a2 + 72);
  v4 = *(_DWORD *)(a1 + 76);
  v5 = *(_DWORD *)(a2 + 76);
  if ( *(_DWORD *)(a1 + 72) <= v3 )
  {
    result = 1;
    if ( *(_DWORD *)(a1 + 72) >= v3 )
    {
      result = v5 - v4;
      if ( v5 == v4 )
        return strcmp(*(const char **)a1, *(const char **)a2);
    }
  }
  return result;
}

//----- (08050BA0) --------------------------------------------------------
int __cdecl sub_8050BA0(char *s1, char *s2)
{
  int result; // eax
  int v3; // edi
  int v4; // ebx
  int v5; // esi

  result = -1;
  v3 = *((_DWORD *)s1 + 18);
  v4 = *((_DWORD *)s2 + 19);
  v5 = *((_DWORD *)s1 + 19);
  if ( *((_DWORD *)s2 + 18) <= v3 )
  {
    result = 1;
    if ( *((_DWORD *)s2 + 18) >= v3 )
    {
      result = v5 - v4;
      if ( v5 == v4 )
        return sub_804D7A0(*(char **)s2, *(char **)s1);
    }
  }
  return result;
}

//----- (08050C10) --------------------------------------------------------
int __cdecl sub_8050C10(int a1, int a2)
{
  int result; // eax
  int v3; // edi
  int v4; // ebx
  int v5; // esi

  result = -1;
  v3 = *(_DWORD *)(a1 + 72);
  v4 = *(_DWORD *)(a2 + 76);
  v5 = *(_DWORD *)(a1 + 76);
  if ( *(_DWORD *)(a2 + 72) <= v3 )
  {
    result = 1;
    if ( *(_DWORD *)(a2 + 72) >= v3 )
    {
      result = v5 - v4;
      if ( v5 == v4 )
        return strcmp(*(const char **)a2, *(const char **)a1);
    }
  }
  return result;
}

//----- (08050C80) --------------------------------------------------------
int __cdecl sub_8050C80(char *s1, char *s2)
{
  bool v2; // bl
  int v3; // edi
  int result; // eax
  int v5; // ebx
  int v6; // esi

  v2 = *((_DWORD *)s2 + 26) == 9 || *((_DWORD *)s2 + 26) == 3;
  if ( *((_DWORD *)s1 + 26) == 3 || *((_DWORD *)s1 + 26) == 9 )
  {
    if ( !v2 )
      return -1;
  }
  else if ( v2 )
  {
    return 1;
  }
  v3 = *((_DWORD *)s2 + 18);
  result = -1;
  v5 = *((_DWORD *)s1 + 19);
  v6 = *((_DWORD *)s2 + 19);
  if ( *((_DWORD *)s1 + 18) <= v3 )
  {
    result = 1;
    if ( *((_DWORD *)s1 + 18) >= v3 )
    {
      result = v6 - v5;
      if ( v6 == v5 )
        return sub_804D7A0(*(char **)s1, *(char **)s2);
    }
  }
  return result;
}

//----- (08050D30) --------------------------------------------------------
int __cdecl sub_8050D30(int a1, int a2)
{
  bool v2; // bl
  int v3; // edi
  int result; // eax
  int v5; // ebx
  int v6; // esi

  v2 = *(_DWORD *)(a2 + 104) == 9 || *(_DWORD *)(a2 + 104) == 3;
  if ( *(_DWORD *)(a1 + 104) == 3 || *(_DWORD *)(a1 + 104) == 9 )
  {
    if ( !v2 )
      return -1;
  }
  else if ( v2 )
  {
    return 1;
  }
  v3 = *(_DWORD *)(a2 + 72);
  result = -1;
  v5 = *(_DWORD *)(a1 + 76);
  v6 = *(_DWORD *)(a2 + 76);
  if ( *(_DWORD *)(a1 + 72) <= v3 )
  {
    result = 1;
    if ( *(_DWORD *)(a1 + 72) >= v3 )
    {
      result = v6 - v5;
      if ( v6 == v5 )
        return strcmp(*(const char **)a1, *(const char **)a2);
    }
  }
  return result;
}

//----- (08050DE0) --------------------------------------------------------
int __cdecl sub_8050DE0(char *s1, char *s2)
{
  bool v2; // bl
  int v3; // edi
  int result; // eax
  int v5; // ebx
  int v6; // esi

  v2 = *((_DWORD *)s2 + 26) == 9 || *((_DWORD *)s2 + 26) == 3;
  if ( *((_DWORD *)s1 + 26) == 3 || *((_DWORD *)s1 + 26) == 9 )
  {
    if ( !v2 )
      return -1;
  }
  else if ( v2 )
  {
    return 1;
  }
  v3 = *((_DWORD *)s1 + 18);
  result = -1;
  v5 = *((_DWORD *)s2 + 19);
  v6 = *((_DWORD *)s1 + 19);
  if ( *((_DWORD *)s2 + 18) <= v3 )
  {
    result = 1;
    if ( *((_DWORD *)s2 + 18) >= v3 )
    {
      result = v6 - v5;
      if ( v6 == v5 )
        return sub_804D7A0(*(char **)s2, *(char **)s1);
    }
  }
  return result;
}

//----- (08050E90) --------------------------------------------------------
int __cdecl sub_8050E90(const char **a1, const char **a2)
{
  const char *v2; // esi
  char *v3; // eax
  const char *v4; // edi
  const char *v5; // ebx
  char *v6; // eax
  int result; // eax

  v2 = *a2;
  v3 = strrchr(*a2, 46);
  v4 = *a1;
  v5 = v3;
  v6 = strrchr(*a1, 46);
  if ( !v6 )
    v6 = (char *)"";
  if ( !v5 )
    v5 = "";
  result = strcmp(v5, v6);
  if ( !result )
    return strcmp(v2, v4);
  return result;
}

//----- (08050F20) --------------------------------------------------------
int __cdecl sub_8050F20(const char **a1, const char **a2)
{
  const char *v2; // esi
  char *v3; // eax
  const char *v4; // edi
  const char *v5; // ebx
  char *v6; // eax
  int result; // eax

  v2 = *a1;
  v3 = strrchr(*a1, 46);
  v4 = *a2;
  v5 = v3;
  v6 = strrchr(*a2, 46);
  if ( !v6 )
    v6 = (char *)"";
  if ( !v5 )
    v5 = "";
  result = strcmp(v5, v6);
  if ( !result )
    return strcmp(v2, v4);
  return result;
}

//----- (08050FB0) --------------------------------------------------------
int __cdecl sub_8050FB0(char *s1, char *s2)
{
  char *v2; // ebx
  char *v3; // eax
  int result; // eax

  v2 = strrchr(*(const char **)s2, 46);
  v3 = strrchr(*(const char **)s1, 46);
  if ( !v3 )
    v3 = (char *)"";
  if ( !v2 )
    v2 = (char *)"";
  result = sub_804D7A0(v2, v3);
  if ( !result )
    return sub_804D7A0(*(char **)s2, *(char **)s1);
  return result;
}

//----- (08051040) --------------------------------------------------------
int __cdecl sub_8051040(char *s1, char *s2)
{
  char *v2; // ebx
  char *v3; // eax
  int result; // eax

  v2 = strrchr(*(const char **)s1, 46);
  v3 = strrchr(*(const char **)s2, 46);
  if ( !v3 )
    v3 = (char *)"";
  if ( !v2 )
    v2 = (char *)"";
  result = sub_804D7A0(v2, v3);
  if ( !result )
    return sub_804D7A0(*(char **)s1, *(char **)s2);
  return result;
}

//----- (080510D0) --------------------------------------------------------
int __cdecl sub_80510D0(char *s1, char *s2)
{
  bool v2; // dl
  char *v3; // ebx
  char *v4; // eax
  int result; // eax

  v2 = *((_DWORD *)s2 + 26) == 9 || *((_DWORD *)s2 + 26) == 3;
  if ( *((_DWORD *)s1 + 26) == 3 || *((_DWORD *)s1 + 26) == 9 )
  {
    if ( !v2 )
      return -1;
  }
  else if ( v2 )
  {
    return 1;
  }
  v3 = strrchr(*(const char **)s1, 46);
  v4 = strrchr(*(const char **)s2, 46);
  if ( !v4 )
    v4 = (char *)"";
  if ( !v3 )
    v3 = (char *)"";
  result = sub_804D7A0(v3, v4);
  if ( !result )
    return sub_804D7A0(*(char **)s1, *(char **)s2);
  return result;
}

//----- (080511C0) --------------------------------------------------------
int __cdecl sub_80511C0(char *s1, char *s2)
{
  bool v2; // dl
  char *v3; // ebx
  char *v4; // eax
  int result; // eax

  v2 = *((_DWORD *)s2 + 26) == 9 || *((_DWORD *)s2 + 26) == 3;
  if ( *((_DWORD *)s1 + 26) == 3 || *((_DWORD *)s1 + 26) == 9 )
  {
    if ( !v2 )
      return -1;
  }
  else if ( v2 )
  {
    return 1;
  }
  v3 = strrchr(*(const char **)s2, 46);
  v4 = strrchr(*(const char **)s1, 46);
  if ( !v4 )
    v4 = (char *)"";
  if ( !v3 )
    v3 = (char *)"";
  result = sub_804D7A0(v3, v4);
  if ( !result )
    return sub_804D7A0(*(char **)s2, *(char **)s1);
  return result;
}

//----- (080512B0) --------------------------------------------------------
int __cdecl sub_80512B0(int a1, int a2)
{
  bool v2; // dl
  const char *v3; // edi
  char *v4; // eax
  const char *v5; // esi
  const char *v6; // ebx
  char *v7; // eax
  int result; // eax

  v2 = *(_DWORD *)(a2 + 104) == 9 || *(_DWORD *)(a2 + 104) == 3;
  if ( *(_DWORD *)(a1 + 104) == 3 || *(_DWORD *)(a1 + 104) == 9 )
  {
    if ( !v2 )
      return -1;
  }
  else if ( v2 )
  {
    return 1;
  }
  v3 = *(const char **)a1;
  v4 = strrchr(*(const char **)a1, 46);
  v5 = *(const char **)a2;
  v6 = v4;
  v7 = strrchr(*(const char **)a2, 46);
  if ( !v7 )
    v7 = (char *)"";
  if ( !v6 )
    v6 = "";
  result = strcmp(v6, v7);
  if ( !result )
    return strcmp(v3, v5);
  return result;
}

//----- (080513A0) --------------------------------------------------------
void __cdecl __noreturn sub_80513A0(int status)
{
  int v1; // esi
  char *v2; // eax
  char *v3; // eax
  FILE *v4; // esi
  char *v5; // eax
  FILE *v6; // esi
  char *v7; // eax
  FILE *v8; // esi
  char *v9; // eax
  FILE *v10; // esi
  char *v11; // eax
  FILE *v12; // esi
  char *v13; // eax
  FILE *v14; // esi
  char *v15; // eax
  FILE *v16; // esi
  char *v17; // eax
  FILE *v18; // esi
  char *v19; // eax
  FILE *v20; // esi
  char *v21; // eax
  FILE *v22; // esi
  char *v23; // eax
  FILE *v24; // esi
  char *v25; // eax
  FILE *v26; // esi
  char *v27; // eax
  FILE *v28; // esi
  char *v29; // eax
  FILE *v30; // esi
  char *v31; // eax
  FILE *v32; // esi
  char *v33; // eax
  FILE *v34; // esi
  char *v35; // eax
  FILE *v36; // esi
  char *v37; // eax
  FILE *v38; // esi
  char *v39; // eax
  FILE *v40; // esi
  char *v41; // eax
  FILE *v42; // esi
  char *v43; // eax
  FILE *v44; // esi
  char *v45; // eax
  FILE *v46; // esi
  char *v47; // eax
  FILE *v48; // esi
  char *v49; // eax
  FILE *v50; // esi
  char *v51; // eax
  FILE *v52; // esi
  char *v53; // eax
  _BYTE *v54; // esi
  char *v55; // eax
  char *v56; // eax
  FILE *v57; // esi
  char *v58; // eax
  char *v59; // eax
  _BYTE *v60; // esi
  char *v61; // eax
  _BYTE *v62; // esi
  char *v63; // eax

  v1 = dword_8062DBC;
  if ( status )
  {
    v2 = dcgettext(0, "Try `%s --help' for more information.\n", 5);
    __fprintf_chk(stderr, 1, v2, v1);
  }
  else
  {
    v3 = dcgettext(0, "Usage: %s [OPTION]... [FILE]...\n", 5);
    __printf_chk(1, v3, v1);
    v4 = stdout;
    v5 = dcgettext(
           0,
           "List information about the FILEs (the current directory by default).\n"
           "Sort entries alphabetically if none of -cftuvSUX nor --sort is specified.\n"
           "\n",
           5);
    fputs_unlocked(v5, v4);
    v6 = stdout;
    v7 = dcgettext(0, "Mandatory arguments to long options are mandatory for short options too.\n", 5);
    fputs_unlocked(v7, v6);
    v8 = stdout;
    v9 = dcgettext(
           0,
           "  -a, --all                  do not ignore entries starting with .\n"
           "  -A, --almost-all           do not list implied . and ..\n"
           "      --author               with -l, print the author of each file\n"
           "  -b, --escape               print C-style escapes for nongraphic characters\n",
           5);
    fputs_unlocked(v9, v8);
    v10 = stdout;
    v11 = dcgettext(
            0,
            "      --block-size=SIZE      scale sizes by SIZE before printing them.  E.g.,\n"
            "                               `--block-size=M' prints sizes in units of\n"
            "                               1,048,576 bytes.  See SIZE format below.\n"
            "  -B, --ignore-backups       do not list implied entries ending with ~\n"
            "  -c                         with -lt: sort by, and show, ctime (time of last\n"
            "                               modification of file status information)\n"
            "                               with -l: show ctime and sort by name\n"
            "                               otherwise: sort by ctime, newest first\n",
            5);
    fputs_unlocked(v11, v10);
    v12 = stdout;
    v13 = dcgettext(
            0,
            "  -C                         list entries by columns\n"
            "      --color[=WHEN]         colorize the output.  WHEN defaults to `always'\n"
            "                               or can be `never' or `auto'.  More info below\n"
            "  -d, --directory            list directory entries instead of contents,\n"
            "                               and do not dereference symbolic links\n"
            "  -D, --dired                generate output designed for Emacs' dired mode\n",
            5);
    fputs_unlocked(v13, v12);
    v14 = stdout;
    v15 = dcgettext(
            0,
            "  -f                         do not sort, enable -aU, disable -ls --color\n"
            "  -F, --classify             append indicator (one of */=>@|) to entries\n"
            "      --file-type            likewise, except do not append `*'\n"
            "      --format=WORD          across -x, commas -m, horizontal -x, long -l,\n"
            "                               single-column -1, verbose -l, vertical -C\n"
            "      --full-time            like -l --time-style=full-iso\n",
            5);
    fputs_unlocked(v15, v14);
    v16 = stdout;
    v17 = dcgettext(0, "  -g                         like -l, but do not list owner\n", 5);
    fputs_unlocked(v17, v16);
    v18 = stdout;
    v19 = dcgettext(
            0,
            "      --group-directories-first\n"
            "                             group directories before files.\n"
            "                               augment with a --sort option, but any\n"
            "                               use of --sort=none (-U) disables grouping\n",
            5);
    fputs_unlocked(v19, v18);
    v20 = stdout;
    v21 = dcgettext(
            0,
            "  -G, --no-group             in a long listing, don't print group names\n"
            "  -h, --human-readable       with -l, print sizes in human readable format\n"
            "                               (e.g., 1K 234M 2G)\n"
            "      --si                   likewise, but use powers of 1000 not 1024\n",
            5);
    fputs_unlocked(v21, v20);
    v22 = stdout;
    v23 = dcgettext(
            0,
            "  -H, --dereference-command-line\n"
            "                             follow symbolic links listed on the command line\n"
            "      --dereference-command-line-symlink-to-dir\n"
            "                             follow each command line symbolic link\n"
            "                             that points to a directory\n"
            "      --hide=PATTERN         do not list implied entries matching shell PATTERN\n"
            "                               (overridden by -a or -A)\n",
            5);
    fputs_unlocked(v23, v22);
    v24 = stdout;
    v25 = dcgettext(
            0,
            "      --indicator-style=WORD  append indicator with style WORD to entry names:\n"
            "                               none (default), slash (-p),\n"
            "                               file-type (--file-type), classify (-F)\n"
            "  -i, --inode                print the index number of each file\n"
            "  -I, --ignore=PATTERN       do not list implied entries matching shell PATTERN\n"
            "  -k                         like --block-size=1K\n",
            5);
    fputs_unlocked(v25, v24);
    v26 = stdout;
    v27 = dcgettext(
            0,
            "  -l                         use a long listing format\n"
            "  -L, --dereference          when showing file information for a symbolic\n"
            "                               link, show information for the file the link\n"
            "                               references rather than for the link itself\n"
            "  -m                         fill width with a comma separated list of entries\n",
            5);
    fputs_unlocked(v27, v26);
    v28 = stdout;
    v29 = dcgettext(
            0,
            "  -n, --numeric-uid-gid      like -l, but list numeric user and group IDs\n"
            "  -N, --literal              print raw entry names (don't treat e.g. control\n"
            "                               characters specially)\n"
            "  -o                         like -l, but do not list group information\n"
            "  -p, --indicator-style=slash\n"
            "                             append / indicator to directories\n",
            5);
    fputs_unlocked(v29, v28);
    v30 = stdout;
    v31 = dcgettext(
            0,
            "  -q, --hide-control-chars   print ? instead of non graphic characters\n"
            "      --show-control-chars   show non graphic characters as-is (default\n"
            "                             unless program is `ls' and output is a terminal)\n"
            "  -Q, --quote-name           enclose entry names in double quotes\n"
            "      --quoting-style=WORD   use quoting style WORD for entry names:\n"
            "                               literal, locale, shell, shell-always, c, escape\n",
            5);
    fputs_unlocked(v31, v30);
    v32 = stdout;
    v33 = dcgettext(
            0,
            "  -r, --reverse              reverse order while sorting\n"
            "  -R, --recursive            list subdirectories recursively\n"
            "  -s, --size                 print the allocated size of each file, in blocks\n",
            5);
    fputs_unlocked(v33, v32);
    v34 = stdout;
    v35 = dcgettext(
            0,
            "  -S                         sort by file size\n"
            "      --sort=WORD            sort by WORD instead of name: none -U,\n"
            "                             extension -X, size -S, time -t, version -v\n"
            "      --time=WORD            with -l, show time as WORD instead of modification\n"
            "                             time: atime -u, access -u, use -u, ctime -c,\n"
            "                             or status -c; use specified time as sort key\n"
            "                             if --sort=time\n",
            5);
    fputs_unlocked(v35, v34);
    v36 = stdout;
    v37 = dcgettext(
            0,
            "      --time-style=STYLE     with -l, show times using style STYLE:\n"
            "                             full-iso, long-iso, iso, locale, +FORMAT.\n"
            "                             FORMAT is interpreted like `date'; if FORMAT is\n"
            "                             FORMAT1<newline>FORMAT2, FORMAT1 applies to\n"
            "                             non-recent files and FORMAT2 to recent files;\n"
            "                             if STYLE is prefixed with `posix-', STYLE\n"
            "                             takes effect only outside the POSIX locale\n",
            5);
    fputs_unlocked(v37, v36);
    v38 = stdout;
    v39 = dcgettext(
            0,
            "  -t                         sort by modification time, newest first\n"
            "  -T, --tabsize=COLS         assume tab stops at each COLS instead of 8\n",
            5);
    fputs_unlocked(v39, v38);
    v40 = stdout;
    v41 = dcgettext(
            0,
            "  -u                         with -lt: sort by, and show, access time\n"
            "                               with -l: show access time and sort by name\n"
            "                               otherwise: sort by access time\n"
            "  -U                         do not sort; list entries in directory order\n"
            "  -v                         natural sort of (version) numbers within text\n",
            5);
    fputs_unlocked(v41, v40);
    v42 = stdout;
    v43 = dcgettext(
            0,
            "  -w, --width=COLS           assume screen width instead of current value\n"
            "  -x                         list entries by lines instead of by columns\n"
            "  -X                         sort alphabetically by entry extension\n"
            "  -Z, --context              print any SELinux security context of each file\n"
            "  -1                         list one file per line\n",
            5);
    fputs_unlocked(v43, v42);
    v44 = stdout;
    v45 = dcgettext(0, "      --help     display this help and exit\n", 5);
    fputs_unlocked(v45, v44);
    v46 = stdout;
    v47 = dcgettext(0, "      --version  output version information and exit\n", 5);
    fputs_unlocked(v47, v46);
    v48 = stdout;
    v49 = dcgettext(
            0,
            "\n"
            "SIZE may be (or may be an integer optionally followed by) one of following:\n"
            "KB 1000, K 1024, MB 1000*1000, M 1024*1024, and so on for G, T, P, E, Z, Y.\n",
            5);
    fputs_unlocked(v49, v48);
    v50 = stdout;
    v51 = dcgettext(
            0,
            "\n"
            "Using color to distinguish file types is disabled both by default and\n"
            "with --color=never.  With --color=auto, ls emits color codes only when\n"
            "standard output is connected to a terminal.  The LS_COLORS environment\n"
            "variable can change the settings.  Use the dircolors command to set it.\n",
            5);
    fputs_unlocked(v51, v50);
    v52 = stdout;
    v53 = dcgettext(
            0,
            "\n"
            "Exit status:\n"
            " 0  if OK,\n"
            " 1  if minor problems (e.g., cannot access subdirectory),\n"
            " 2  if serious trouble (e.g., cannot access command-line argument).\n",
            5);
    fputs_unlocked(v53, v52);
    v54 = sub_80520B0((_BYTE *)dword_8062DBC);
    v55 = dcgettext(0, "\nReport %s bugs to %s\n", 5);
    __printf_chk(1, v55, v54, "bug-coreutils@gnu.org");
    v56 = dcgettext(0, "%s home page: <%s>\n", 5);
    __printf_chk(1, v56, "GNU coreutils", "http://www.gnu.org/software/coreutils/");
    v57 = stdout;
    v58 = dcgettext(0, "General help using GNU software: <http://www.gnu.org/gethelp/>\n", 5);
    fputs_unlocked(v58, v57);
    v59 = setlocale(5, 0);
    if ( v59 )
    {
      if ( strncmp(v59, "en_", 3u) )
      {
        v62 = sub_80520B0((_BYTE *)dword_8062DBC);
        v63 = dcgettext(0, "Report %s translation bugs to <http://translationproject.org/team/>\n", 5);
        __printf_chk(1, v63, v62);
      }
    }
    v60 = sub_80520B0((_BYTE *)dword_8062DBC);
    v61 = dcgettext(0, "For complete documentation, run: info coreutils '%s invocation'\n", 5);
    __printf_chk(1, v61, v60);
  }
  exit(status);
}
// 8049870: using guessed type int __cdecl fputs_unlocked(_DWORD, _DWORD);
// 8049980: using guessed type int __printf_chk(_DWORD, const char *, ...);
// 8049A60: using guessed type int __fprintf_chk(_DWORD, _DWORD, const char *, ...);
// 8062DBC: using guessed type int dword_8062DBC;

//----- (08051AA0) --------------------------------------------------------
int __cdecl sub_8051AA0(int a1, int a2)
{
  int result; // eax
  int v3; // edx

  result = 0;
  if ( (*(_DWORD *)(a2 + 16) & 0xF000) != 40960 )
  {
    result = acl_extended_file_nofollow(a1);
    if ( result < 0 )
    {
      v3 = *__errno_location();
      result = 0;
      if ( v3 != 38 && v3 != 95 && v3 != 22 )
        return (v3 == 16) - 1;
    }
  }
  return result;
}
// 80499E0: using guessed type int __cdecl acl_extended_file_nofollow(_DWORD);

//----- (08051B00) --------------------------------------------------------
char *__cdecl sub_8051B00(char *path, int a2)
{
  size_t len; // ebx
  char *buf; // eax
  char *v4; // esi
  ssize_t v5; // edi
  int *v7; // eax
  char *size; // [esp+0h] [ebp-3Ch]
  int v9; // [esp+18h] [ebp-24h]
  int *v10; // [esp+1Ch] [ebp-20h]

  len = 1025;
  if ( (unsigned int)a2 <= 0x400 )
    len = a2 + 1;
  while ( 2 )
  {
    buf = (char *)malloc(len);
    v4 = buf;
    if ( !buf )
      return v4;
    while ( 1 )
    {
      v5 = readlink(path, buf, len);
      if ( v5 < 0 )
      {
        v7 = __errno_location();
        if ( *v7 != 34 )
        {
          size = v4;
          v4 = 0;
          v10 = v7;
          v9 = *v7;
          free(size);
          *v10 = v9;
          return v4;
        }
      }
      if ( len > v5 )
      {
        v4[v5] = 0;
        return v4;
      }
      free(v4);
      if ( len > 0x3FFFFFFF )
        break;
      len *= 2;
      buf = (char *)malloc(len);
      v4 = buf;
      if ( !buf )
        return v4;
    }
    if ( len <= 0x7FFFFFFE )
    {
      len = 0x7FFFFFFF;
      continue;
    }
    break;
  }
  *__errno_location() = 12;
  return 0;
}

//----- (08051BE0) --------------------------------------------------------
void __noreturn sub_8051BE0()
{
  sub_80513A0(1);
}
// 8051BE0: using guessed type void __noreturn sub_8051BE0();

//----- (08051C00) --------------------------------------------------------
int __cdecl sub_8051C00(char *s, int a2, void *a3, size_t n)
{
  size_t v4; // eax
  const char *v5; // ebx
  char *s2; // edi
  int v7; // esi
  int v8; // eax
  char v9; // dl
  int v10; // eax
  size_t v12; // [esp+18h] [ebp-34h]
  int v13; // [esp+1Ch] [ebp-30h]
  char v14; // [esp+20h] [ebp-2Ch]

  v4 = strlen(s);
  v13 = -1;
  v5 = *(const char **)a2;
  v12 = v4;
  if ( *(_DWORD *)a2 )
  {
    s2 = (char *)a3;
    v7 = 0;
    v14 = 0;
    while ( 1 )
    {
      while ( strncmp(v5, s, v12) )
      {
LABEL_7:
        ++v7;
        s2 += n;
        v5 = *(const char **)(a2 + 4 * v7);
        if ( !v5 )
          goto LABEL_12;
      }
      if ( strlen(v5) == v12 )
        return v7;
      if ( v13 != -1 )
      {
        if ( a3 )
        {
          v8 = memcmp((char *)a3 + n * v13, s2, n);
          v9 = v14;
          if ( v8 )
            v9 = 1;
          v14 = v9;
        }
        else
        {
          v14 = 1;
        }
        goto LABEL_7;
      }
      s2 += n;
      v13 = v7++;
      v5 = *(const char **)(a2 + 4 * v7);
      if ( !v5 )
      {
LABEL_12:
        v10 = -2;
        if ( !v14 )
          return v13;
        return v10;
      }
    }
  }
  return v13;
}

//----- (08051D10) --------------------------------------------------------
void __cdecl sub_8051D10(int a1, int a2, int a3)
{
  char *v3; // esi
  _BYTE *v4; // ebx
  _BYTE *v5; // eax

  if ( a3 == -1 )
    v3 = dcgettext(0, "invalid argument %s for %s", 5);
  else
    v3 = dcgettext(0, "ambiguous argument %s for %s", 5);
  v4 = sub_8055690(1, a1);
  v5 = sub_80567D0(0, 6, a2);
  error(0, 0, v3, v5, v4);
}

//----- (08051DB0) --------------------------------------------------------
_IO_FILE *__cdecl sub_8051DB0(_IO_FILE *a1, void *s2, size_t n)
{
  char *v4; // eax
  const char *flags; // edi
  int v6; // ebx
  _IO_FILE *result; // eax
  char *IO_write_ptr; // edx
  const void *s1; // [esp+18h] [ebp-24h]

  v4 = dcgettext(0, "Valid arguments are:", 5);
  __fprintf_chk(stderr, 1, v4);
  flags = (const char *)a1->_flags;
  if ( a1->_flags )
  {
    s1 = 0;
    v6 = 0;
    do
    {
      while ( !v6 || memcmp(s1, s2, n) )
      {
        ++v6;
        __fprintf_chk(stderr, 1, "\n  - `%s'", flags);
        s1 = s2;
        s2 = (char *)s2 + n;
        flags = (const char *)*(&a1->_flags + v6);
        if ( !flags )
          goto LABEL_7;
      }
      ++v6;
      s2 = (char *)s2 + n;
      __fprintf_chk(stderr, 1, ", `%s'", flags);
      flags = (const char *)*(&a1->_flags + v6);
    }
    while ( flags );
  }
LABEL_7:
  result = stderr;
  IO_write_ptr = stderr->_IO_write_ptr;
  if ( IO_write_ptr >= stderr->_IO_write_end )
    return (_IO_FILE *)__overflow(stderr, 10);
  *IO_write_ptr = 10;
  result->_IO_write_ptr = IO_write_ptr + 1;
  return result;
}
// 8049A60: using guessed type int __fprintf_chk(_DWORD, _DWORD, const char *, ...);

//----- (08051EE0) --------------------------------------------------------
int __cdecl sub_8051EE0(int a1, char *a2, _IO_FILE *a3, void *s2, size_t n, int a6)
{
  int result; // eax

  result = sub_8051C00(a2, (int)a3, s2, n);
  if ( result < 0 )
  {
    sub_8051D10(a1, (int)a2, result);
    sub_8051DB0(a3, s2, n);
    ((void (*)(void))a6)();
    return -1;
  }
  return result;
}

//----- (08051FD0) --------------------------------------------------------
void __cdecl sub_8051FD0()
{
  char *v0; // ebx
  const char *v1; // esi
  int *v2; // eax
  int *v3; // eax

  if ( sub_8059700(stdout) && (!byte_8062DA8 || *__errno_location() != 32) )
  {
    v0 = dcgettext(0, "write error", 5);
    if ( dword_8062DA4 )
    {
      v1 = sub_8056980(dword_8062DA4);
      v2 = __errno_location();
      error(0, *v2, "%s: %s", v1, v0);
    }
    else
    {
      v3 = __errno_location();
      error(0, *v3, "%s", v0);
    }
LABEL_8:
    _exit(dword_80622CC);
  }
  if ( sub_8059700(stderr) )
    goto LABEL_8;
}
// 8062DA4: using guessed type int dword_8062DA4;
// 8062DA8: using guessed type char byte_8062DA8;

//----- (080520B0) --------------------------------------------------------
_BYTE *__cdecl sub_80520B0(_BYTE *a1)
{
  _BYTE *result; // eax
  char i; // dl
  _BYTE *v3; // ecx
  char v4; // bl

  result = a1;
  for ( i = *a1; *result == 47; i = *result )
    ++result;
  if ( i )
  {
    v3 = result;
    v4 = 0;
    do
    {
      while ( i == 47 )
      {
        ++v3;
        v4 = 1;
        i = *v3;
        if ( !*v3 )
          return result;
      }
      if ( v4 )
      {
        result = v3;
        v4 = 0;
      }
      i = *++v3;
    }
    while ( *v3 );
  }
  return result;
}

//----- (08052100) --------------------------------------------------------
size_t __cdecl sub_8052100(char *s)
{
  size_t result; // eax

  result = strlen(s);
  if ( result > 1 )
  {
    do
    {
      if ( s[result - 1] != 47 )
        break;
      --result;
    }
    while ( result != 1 );
  }
  return result;
}

//----- (080522D0) --------------------------------------------------------
int __cdecl sub_80522D0(int a1, char *a2)
{
  int v2; // eax
  char v3; // cl
  int v4; // ebx
  int v5; // ecx
  char v6; // cl
  int v7; // ecx
  char v8; // cl
  int result; // eax

  v2 = *(_DWORD *)(a1 + 16);
  v3 = 45;
  v4 = v2 & 0xF000;
  if ( v4 != 0x8000 )
  {
    v3 = 100;
    if ( v4 != 0x4000 )
    {
      v3 = 98;
      if ( v4 != 24576 )
      {
        v3 = 99;
        if ( v4 != 0x2000 )
        {
          v3 = 108;
          if ( v4 != 40960 )
          {
            v3 = 112;
            if ( v4 != 4096 )
            {
              v3 = 115;
              if ( v4 != 49152 )
                v3 = 63;
            }
          }
        }
      }
    }
  }
  *a2 = v3;
  a2[1] = (v2 & 0x100) == 0 ? 45 : 114;
  a2[2] = (v2 & 0x80) == 0 ? 45 : 119;
  v5 = -((v2 & 0x40) == 0);
  if ( (v2 & 0x800) != 0 )
    v6 = (v5 & 0xE0) + 115;
  else
    v6 = (v5 & 0xB5) + 120;
  a2[3] = v6;
  a2[4] = (v2 & 0x20) == 0 ? 45 : 114;
  a2[5] = (v2 & 0x10) == 0 ? 45 : 119;
  v7 = -((v2 & 8) == 0);
  if ( (v2 & 0x400) != 0 )
    v8 = (v7 & 0xE0) + 115;
  else
    v8 = (v7 & 0xB5) + 120;
  a2[6] = v8;
  a2[7] = (v2 & 4) == 0 ? 45 : 114;
  a2[8] = (v2 & 2) == 0 ? 45 : 119;
  if ( (v2 & 0x200) != 0 )
    result = (v2 & 1) == 0 ? 84 : 116;
  else
    result = (v2 & 1) == 0 ? 45 : 120;
  a2[9] = result;
  a2[10] = 32;
  a2[11] = 0;
  return result;
}

//----- (080522E0) --------------------------------------------------------
void *__cdecl sub_80522E0(int a1, char *a2, int a3)
{
  void *result; // eax

  result = sub_8052310(a1, a2, a3);
  if ( !result )
    sub_8058C00();
  return result;
}

//----- (08052310) --------------------------------------------------------
void *__cdecl sub_8052310(int a1, char *a2, int a3)
{
  _BOOL4 v3; // ebp
  char *s; // ebx
  size_t v5; // eax
  char *i; // ebx
  void *v7; // eax
  void *v8; // edi
  _BYTE *v9; // eax
  _BYTE *v10; // ebp
  char *v12; // [esp+18h] [ebp-24h]
  size_t v13; // [esp+1Ch] [ebp-20h]

  v3 = 0;
  s = sub_80520B0((_BYTE *)a1);
  v5 = sub_8052100(s);
  v12 = &s[v5 - a1];
  if ( v5 )
    v3 = s[v5 - 1] != 47;
  for ( i = a2; *i == 47; ++i )
  {
    if ( *++i != 47 )
      break;
  }
  v13 = strlen(i);
  v7 = malloc((size_t)&v12[v3 + 1 + v13]);
  v8 = v7;
  if ( v7 )
  {
    v9 = (_BYTE *)mempcpy(v7, a1, v12);
    v10 = &v9[v3];
    *v9 = 47;
    if ( a3 )
      *(_DWORD *)a3 = &v10[-(*a2 == 47)];
    *(_BYTE *)mempcpy(v10, i, v13) = 0;
  }
  return v8;
}
// 8049990: using guessed type int __cdecl mempcpy(_DWORD, _DWORD, _DWORD);

//----- (08052420) --------------------------------------------------------
char *__usercall sub_8052420@<eax>(char **a1@<eax>)
{
  char *v1; // esi
  char *v2; // edx
  char v3; // cl
  char v4; // bl

  v1 = 0;
  v2 = *a1;
  v3 = **a1;
  if ( v3 )
  {
    v4 = 0;
    do
    {
      while ( v4 )
      {
        v4 = 0;
        if ( (v3 & 0xFFFFFFDF) - 65 > 0x19 )
          goto LABEL_4;
LABEL_6:
        *a1 = ++v2;
        v3 = *v2;
        if ( !*v2 )
          return v1;
      }
      if ( v3 == 46 )
      {
        v4 = 1;
        if ( !v1 )
          v1 = v2;
        goto LABEL_6;
      }
      if ( (unsigned int)(v3 - 48) <= 9 )
        goto LABEL_6;
      if ( (v3 & 0xFFFFFFDF) - 65 > 0x19 )
      {
LABEL_4:
        if ( v3 != 126 )
          v1 = 0;
        goto LABEL_6;
      }
      *a1 = ++v2;
      v3 = *v2;
    }
    while ( *v2 );
  }
  return v1;
}

//----- (080524B0) --------------------------------------------------------
int __cdecl sub_80524B0(char *s1, char *s2)
{
  char *v2; // esi
  char *v3; // ebx
  char v4; // al
  char v5; // dl
  char *v7; // edi
  char *v8; // eax
  char *v9; // edx
  char *v10; // ecx
  char *v11; // eax
  char *v12; // edx
  char *v13; // esi
  int v14; // edi
  int v15; // ecx
  unsigned __int8 v16; // bl
  unsigned __int8 v17; // cl
  int v18; // edi
  int v19; // ebp
  int v20; // ecx
  int v21; // edi
  int v22; // ecx
  char *n; // [esp+10h] [ebp-3Ch]
  char *v25; // [esp+14h] [ebp-38h]
  char *v26; // [esp+18h] [ebp-34h]
  char v27; // [esp+18h] [ebp-34h]
  char *v28; // [esp+18h] [ebp-34h]
  int v29; // [esp+1Ch] [ebp-30h]
  char *v30; // [esp+28h] [ebp-24h] BYREF
  char *v31; // [esp+2Ch] [ebp-20h] BYREF

  v2 = s1;
  v3 = s2;
  v29 = strcmp(s1, s2);
  if ( !v29 )
    return v29;
  v4 = *s1;
  if ( !*s1 )
    return -1;
  v5 = *s2;
  if ( !*s2 )
    return 1;
  if ( v4 == 46 && !s1[1] )
    return -1;
  if ( v5 == 46 && !s2[1] )
    return 1;
  if ( 46 == v4 && s1[1] == 46 && !s1[2] )
    return -1;
  if ( 46 == v5 && s2[1] == 46 && !s2[2] )
    return 1;
  if ( v4 == 46 )
  {
    v2 = s1 + 1;
    v3 = s2 + 1;
    if ( v5 == 46 )
      goto LABEL_16;
    return -1;
  }
  if ( v5 == 46 )
    return 1;
LABEL_16:
  v30 = v2;
  v31 = v3;
  v7 = sub_8052420(&v30);
  v8 = sub_8052420(&v31);
  v9 = v7;
  if ( !v7 )
    v9 = v30;
  n = (char *)(v9 - v2);
  v10 = v8;
  if ( !v8 )
    v10 = v31;
  v25 = (char *)(v10 - v3);
  if ( (v8 || v7) && n == v25 )
  {
    v25 = (char *)(v9 - v2);
    if ( !strncmp(v2, v3, (size_t)n) )
    {
      n = (char *)(v30 - v2);
      v25 = (char *)(v31 - v3);
    }
  }
  v11 = 0;
  v12 = 0;
LABEL_23:
  if ( v25 > v11 || n > v12 )
  {
    v26 = v2;
    v13 = v3;
    while ( 1 )
    {
      if ( n <= v12 || (v17 = v12[(_DWORD)v26], (unsigned int)((char)v17 - 48) <= 9) )
      {
        if ( v25 <= v11 )
        {
          v3 = v13;
          v2 = v26;
          LOBYTE(v19) = v11[(_DWORD)v3];
          goto LABEL_57;
        }
        if ( (unsigned int)(v11[(_DWORD)v13] - 48) <= 9 )
        {
          v3 = v13;
          LOBYTE(v19) = v11[(_DWORD)v13];
          v2 = v26;
LABEL_57:
          v27 = v12[(_DWORD)v2];
          if ( v27 == 48 )
          {
            do
              ++v12;
            while ( v12[(_DWORD)v2] == 48 );
            v27 = v12[(_DWORD)v2];
          }
          if ( (_BYTE)v19 == 48 )
          {
            do
              ++v11;
            while ( v11[(_DWORD)v3] == 48 );
            LOBYTE(v19) = v11[(_DWORD)v3];
          }
          if ( (unsigned int)(v27 - 48) > 9 )
          {
            v21 = 0;
            goto LABEL_71;
          }
          v19 = (char)v19;
          if ( (unsigned int)((char)v19 - 48) > 9 )
            return 1;
          v20 = v27;
          v21 = 0;
          v28 = v3;
          while ( 1 )
          {
            v22 = v20 - v19;
            if ( !v21 )
              v21 = v22;
            v20 = (++v12)[(_DWORD)v2];
            ++v11;
            v3 = v28;
            if ( (unsigned int)(v20 - 48) > 9 )
              break;
            v19 = v11[(_DWORD)v28];
            if ( (unsigned int)(v19 - 48) > 9 )
              return 1;
          }
          LOBYTE(v19) = v11[(_DWORD)v28];
LABEL_71:
          if ( (unsigned int)((char)v19 - 48) > 9 )
          {
            if ( !v21 )
              goto LABEL_23;
            return v21;
          }
          return -1;
        }
        if ( n == v12 )
        {
          v14 = 0;
LABEL_29:
          v16 = v11[(_DWORD)v13];
          v15 = v16;
          if ( (unsigned int)v16 - 48 <= 9 )
          {
            v15 = 0;
          }
          else if ( (v16 & 0xDFu) - 65 > 0x19 )
          {
            v15 = v16 + 256;
            if ( v16 == 126 )
              v15 = -1;
          }
          goto LABEL_33;
        }
        v17 = v12[(_DWORD)v26];
      }
      v14 = v17;
      if ( (unsigned int)v17 - 48 > 9 )
      {
        if ( (v17 & 0xDFu) - 65 > 0x19 )
        {
          v14 = v17 + 256;
          if ( v17 == 126 )
            v14 = -1;
        }
      }
      else
      {
        v14 = 0;
      }
      v15 = 0;
      if ( v25 != v11 )
        goto LABEL_29;
LABEL_33:
      if ( v14 != v15 )
      {
        v18 = v14 - v15;
        if ( !v18 )
          return v29;
        return v18;
      }
      ++v12;
      ++v11;
    }
  }
  return v29;
}

//----- (08052840) --------------------------------------------------------
int __cdecl sub_8052840(struct timespec *tp)
{
  int result; // eax
  struct timeval tv; // [esp+18h] [ebp-14h] BYREF

  result = clock_gettime(0, tp);
  if ( result )
  {
    gettimeofday(&tv, 0);
    tp->tv_sec = tv.tv_sec;
    result = 1000 * tv.tv_usec;
    tp->tv_nsec = 1000 * tv.tv_usec;
  }
  return result;
}

//----- (08052890) --------------------------------------------------------
bool __cdecl sub_8052890(int category)
{
  char *v1; // esi
  bool result; // al

  v1 = setlocale(category, 0);
  result = 1;
  if ( v1 )
    return (*v1 != 67 || v1[1]) && strcmp(v1, "POSIX") != 0;
  return result;
}

//----- (08052900) --------------------------------------------------------
int __cdecl sub_8052900(int a1, unsigned int a2)
{
  return __ROR4__(a1, 3) % a2;
}

//----- (08052910) --------------------------------------------------------
bool __cdecl sub_8052910(int a1, int a2)
{
  return a1 == a2;
}

//----- (08052920) --------------------------------------------------------
unsigned int __usercall sub_8052920@<eax>(int a1@<eax>, int a2@<edx>)
{
  unsigned int v3; // eax

  v3 = (*(int (__cdecl **)(int, _DWORD))(a1 + 24))(a2, *(_DWORD *)(a1 + 8));
  if ( v3 >= *(_DWORD *)(a1 + 8) )
    abort();
  return *(_DWORD *)a1 + 8 * v3;
}

//----- (08052950) --------------------------------------------------------
int __usercall sub_8052950@<eax>(int a1@<eax>, int a2@<edx>, int **a3@<ecx>, char a4)
{
  int *v7; // ebp
  int result; // eax
  _DWORD *v9; // edx
  int *v10; // edx
  int v11; // ebx

  v7 = (int *)sub_8052920(a1, a2);
  *a3 = v7;
  result = *v7;
  if ( !*v7 )
    return result;
  if ( a2 == result )
    goto LABEL_13;
  if ( (*(unsigned __int8 (__cdecl **)(int, int))(a1 + 28))(a2, result) )
  {
    result = *v7;
LABEL_13:
    if ( a4 )
    {
      v10 = (int *)v7[1];
      if ( v10 )
      {
        v11 = v10[1];
        *v7 = *v10;
        v7[1] = v11;
        *v10 = 0;
        v10[1] = *(_DWORD *)(a1 + 36);
        *(_DWORD *)(a1 + 36) = v10;
      }
      else
      {
        *v7 = 0;
      }
    }
    return result;
  }
  v9 = (_DWORD *)v7[1];
  result = 0;
  if ( v9 )
  {
    while ( 1 )
    {
      result = *v9;
      if ( *v9 == a2 )
      {
        if ( !a4 )
          return result;
        goto LABEL_10;
      }
      if ( (*(unsigned __int8 (__cdecl **)(int, _DWORD))(a1 + 28))(a2, *v9) )
        break;
      v7 = (int *)v7[1];
      v9 = (_DWORD *)v7[1];
      if ( !v9 )
        return 0;
    }
    v9 = (_DWORD *)v7[1];
    result = *v9;
    if ( a4 )
    {
LABEL_10:
      v7[1] = v9[1];
      *v9 = 0;
      v9[1] = *(_DWORD *)(a1 + 36);
      *(_DWORD *)(a1 + 36) = v9;
    }
  }
  return result;
}

//----- (08052A50) --------------------------------------------------------
int __usercall sub_8052A50@<eax>(int a1@<eax>, int a2@<edx>, char a3@<cl>)
{
  int *v4; // ebp
  int result; // eax
  int v6; // edi
  int *v7; // esi
  int v8; // edi
  _DWORD *v9; // eax
  int *v10; // edx
  _DWORD *v11; // eax
  _DWORD *v12; // esi
  _DWORD *v13; // eax
  int v14; // edx

  v4 = *(int **)a2;
  result = 1;
  if ( *(_DWORD *)a2 < *(_DWORD *)(a2 + 4) )
  {
    while ( 1 )
    {
      while ( 1 )
      {
        v6 = *v4;
        if ( *v4 )
        {
          v7 = (int *)v4[1];
          if ( v7 )
          {
            while ( 1 )
            {
              v8 = *v7;
              v9 = (_DWORD *)sub_8052920(a1, *v7);
              v10 = (int *)v7[1];
              if ( *v9 )
              {
                v7[1] = v9[1];
                v9[1] = v7;
                if ( !v10 )
                  goto LABEL_9;
              }
              else
              {
                *v9 = v8;
                ++*(_DWORD *)(a1 + 12);
                *v7 = 0;
                v7[1] = *(_DWORD *)(a1 + 36);
                *(_DWORD *)(a1 + 36) = v7;
                if ( !v10 )
                {
LABEL_9:
                  v6 = *v4;
                  break;
                }
              }
              v7 = v10;
            }
          }
          v4[1] = 0;
          if ( !a3 )
            break;
        }
        v4 += 2;
        if ( *(_DWORD *)(a2 + 4) <= (unsigned int)v4 )
          return 1;
      }
      v11 = (_DWORD *)sub_8052920(a1, v6);
      v12 = v11;
      if ( *v11 )
      {
        v13 = *(_DWORD **)(a1 + 36);
        if ( v13 )
        {
          *(_DWORD *)(a1 + 36) = v13[1];
        }
        else
        {
          v13 = malloc(8u);
          if ( !v13 )
            return 0;
        }
        v14 = v12[1];
        *v13 = v6;
        v13[1] = v14;
        v12[1] = v13;
      }
      else
      {
        *v11 = v6;
        ++*(_DWORD *)(a1 + 12);
      }
      *v4 = 0;
      v4 += 2;
      --*(_DWORD *)(a2 + 12);
      if ( *(_DWORD *)(a2 + 4) <= (unsigned int)v4 )
        return 1;
    }
  }
  return result;
}

//----- (08052B60) --------------------------------------------------------
int __usercall sub_8052B60@<eax>(float **a1@<eax>)
{
  float *v1; // edx
  int v2; // ecx
  long double v3; // fst6
  long double v4; // fst7
  long double v5; // fst5

  v1 = *a1;
  v2 = 1;
  if ( *a1 != (float *)&unk_805D40C )
  {
    v3 = v1[2];
    if ( v3 <= 0.1
      || v3 >= 0.89999998
      || v1[3] <= 1.1
      || *v1 < 0.0
      || (v4 = *v1 + 0.1, v5 = v1[1], v5 <= v4)
      || v5 > 1.0
      || v3 <= v4 )
    {
      *a1 = (float *)&unk_805D40C;
      return 0;
    }
  }
  return v2;
}

//----- (08052C10) --------------------------------------------------------
unsigned int __usercall sub_8052C10@<eax>(unsigned int a1@<eax>, char a2@<dl>, float a3)
{
  unsigned int v3; // edi
  long double v4; // fst6
  unsigned int v5; // edi
  int v6; // esi
  unsigned int v7; // ebx
  unsigned int v8; // ecx

  v3 = a1;
  if ( !a2 )
  {
    v4 = (long double)a1 / a3;
    if ( v4 >= 4294967300.0 )
      return 0;
    v3 = (__int64)v4;
  }
  if ( v3 <= 9 )
  {
    v5 = 11;
    goto LABEL_6;
  }
  v5 = v3 | 1;
  if ( v5 == -1 )
    return 0;
  while ( 1 )
  {
LABEL_6:
    if ( v5 <= 9 )
    {
      v8 = 3;
      goto LABEL_11;
    }
    if ( v5 != 3 * (v5 / 3) )
      break;
LABEL_12:
    v5 += 2;
    if ( v5 == -1 )
      return 0;
  }
  v6 = 16;
  v7 = 9;
  v8 = 3;
  while ( 1 )
  {
    v7 += v6;
    v8 += 2;
    if ( v7 >= v5 )
      break;
    v6 += 8;
    if ( !(v5 % v8) )
      goto LABEL_12;
  }
LABEL_11:
  if ( !(v5 % v8) )
    goto LABEL_12;
  if ( v5 >= 0x40000000 )
    return 0;
  return v5;
}

//----- (08052D20) --------------------------------------------------------
int __cdecl sub_8052D20(int a1)
{
  return *(_DWORD *)(a1 + 16);
}

//----- (08053140) --------------------------------------------------------
void *__cdecl sub_8053140(unsigned int a1, void *a2, int (*a3)(), int (*a4)(), int a5)
{
  void *v5; // edi
  void *v6; // esi
  void *v7; // ebp
  void *v8; // ebx
  unsigned int v9; // eax
  unsigned int v10; // ebp
  char *v11; // eax
  void *size; // [esp+0h] [ebp-2Ch]

  v5 = a3;
  v6 = a4;
  v7 = a2;
  if ( !a3 )
    v5 = sub_8052900;
  if ( !a4 )
    v6 = sub_8052910;
  v8 = malloc(0x28u);
  if ( v8 )
  {
    if ( !a2 )
      v7 = &unk_805D40C;
    *((_DWORD *)v8 + 5) = v7;
    if ( (unsigned __int8)sub_8052B60((float **)v8 + 5)
      && (v9 = sub_8052C10(a1, *((_BYTE *)v7 + 16), *((float *)v7 + 2)), v10 = v9, (*((_DWORD *)v8 + 2) = v9) != 0)
      && (v11 = (char *)calloc(v9, 8u), (*(_DWORD *)v8 = v11) != 0) )
    {
      *((_DWORD *)v8 + 1) = &v11[8 * v10];
      *((_DWORD *)v8 + 3) = 0;
      *((_DWORD *)v8 + 4) = 0;
      *((_DWORD *)v8 + 6) = v5;
      *((_DWORD *)v8 + 7) = v6;
      *((_DWORD *)v8 + 8) = a5;
      *((_DWORD *)v8 + 9) = 0;
    }
    else
    {
      size = v8;
      v8 = 0;
      free(size);
    }
  }
  return v8;
}

//----- (080532B0) --------------------------------------------------------
void __cdecl sub_80532B0(void *a1)
{
  int *v1; // edi
  int v2; // eax
  int *i; // ebx
  unsigned int v4; // eax
  int *v5; // edi
  _DWORD *ptr; // eax
  _DWORD *v7; // ebx
  _DWORD *v8; // eax
  _DWORD *v9; // ebx

  if ( *((_DWORD *)a1 + 8) && *((_DWORD *)a1 + 4) )
  {
    v1 = *(int **)a1;
    if ( *(_DWORD *)a1 >= *((_DWORD *)a1 + 1) )
      goto LABEL_18;
    do
    {
      v2 = *v1;
      if ( *v1 && v1 )
      {
        for ( i = v1; ; v2 = *i )
        {
          (*((void (__cdecl **)(int))a1 + 8))(v2);
          i = (int *)i[1];
          if ( !i )
            break;
        }
      }
      v4 = *((_DWORD *)a1 + 1);
      v1 += 2;
    }
    while ( v4 > (unsigned int)v1 );
  }
  else
  {
    v4 = *((_DWORD *)a1 + 1);
  }
  v5 = *(int **)a1;
  if ( *(_DWORD *)a1 < v4 )
  {
    do
    {
      ptr = (_DWORD *)v5[1];
      if ( ptr )
      {
        while ( 1 )
        {
          v7 = (_DWORD *)ptr[1];
          free(ptr);
          if ( !v7 )
            break;
          ptr = v7;
        }
      }
      v5 += 2;
    }
    while ( *((_DWORD *)a1 + 1) > (unsigned int)v5 );
  }
LABEL_18:
  v8 = (_DWORD *)*((_DWORD *)a1 + 9);
  if ( v8 )
  {
    while ( 1 )
    {
      v9 = (_DWORD *)v8[1];
      free(v8);
      if ( !v9 )
        break;
      v8 = v9;
    }
  }
  free(*(void **)a1);
  free(a1);
}

//----- (08053370) --------------------------------------------------------
int __cdecl sub_8053370(int a1, unsigned int a2)
{
  int v2; // esi
  unsigned int nmemb; // eax
  int v4; // edi
  void *v5; // eax
  int v6; // eax
  int v7; // eax
  void *ptr; // [esp+18h] [ebp-34h] BYREF
  int v10; // [esp+1Ch] [ebp-30h]
  int v11; // [esp+20h] [ebp-2Ch]
  int v12; // [esp+24h] [ebp-28h]
  int v13; // [esp+28h] [ebp-24h]
  int v14; // [esp+2Ch] [ebp-20h]
  int v15; // [esp+30h] [ebp-1Ch]
  int v16; // [esp+34h] [ebp-18h]
  int v17; // [esp+38h] [ebp-14h]
  int v18; // [esp+3Ch] [ebp-10h]

  v2 = *(_DWORD *)(a1 + 20);
  nmemb = sub_8052C10(a2, *(_BYTE *)(v2 + 16), *(float *)(v2 + 8));
  v4 = nmemb;
  if ( !nmemb )
    return 0;
  if ( *(_DWORD *)(a1 + 8) == nmemb )
    return 1;
  v5 = calloc(nmemb, 8u);
  ptr = v5;
  if ( !v5 )
    return 0;
  v10 = (int)v5 + 8 * v4;
  v6 = *(_DWORD *)(a1 + 24);
  v11 = v4;
  v12 = 0;
  v13 = 0;
  v15 = v6;
  v7 = *(_DWORD *)(a1 + 28);
  v14 = v2;
  v16 = v7;
  v17 = *(_DWORD *)(a1 + 32);
  v18 = *(_DWORD *)(a1 + 36);
  if ( (unsigned __int8)sub_8052A50((int)&ptr, a1, 0) )
  {
    free(*(void **)a1);
    *(_DWORD *)a1 = ptr;
    *(_DWORD *)(a1 + 4) = v10;
    *(_DWORD *)(a1 + 8) = v11;
    *(_DWORD *)(a1 + 12) = v12;
    *(_DWORD *)(a1 + 36) = v18;
    return 1;
  }
  else
  {
    *(_DWORD *)(a1 + 36) = v18;
    if ( !(unsigned __int8)sub_8052A50(a1, (int)&ptr, 1) || !(unsigned __int8)sub_8052A50(a1, (int)&ptr, 0) )
      abort();
    free(ptr);
    return 0;
  }
}

//----- (080534F0) --------------------------------------------------------
int __cdecl sub_80534F0(int a1, int a2, int *a3)
{
  int v3; // edx
  int result; // eax
  int *v5; // ebx
  _DWORD *v6; // edx
  int v7; // eax
  int v8; // ecx
  long double v9; // fst7
  long double v10; // fst6
  long double v11; // fst6
  long double v12; // fst7
  int *v13; // [esp+2Ch] [ebp-10h] BYREF

  if ( !a2 )
    goto LABEL_19;
  v3 = sub_8052950(a1, a2, &v13, 0);
  if ( !v3 )
  {
    if ( (long double)*(unsigned int *)(a1 + 12) <= (long double)*(unsigned int *)(a1 + 8)
                                                  * *(float *)(*(_DWORD *)(a1 + 20) + 8) )
      goto LABEL_8;
    sub_8052B60((float **)(a1 + 20));
    v8 = *(_DWORD *)(a1 + 20);
    v9 = *(float *)(v8 + 8);
    v10 = (long double)*(unsigned int *)(a1 + 8);
    if ( (long double)*(unsigned int *)(a1 + 12) <= v9 * v10 )
      goto LABEL_8;
    v11 = v10 * *(float *)(v8 + 12);
    if ( *(_BYTE *)(v8 + 16) )
      v12 = v11;
    else
      v12 = v9 * v11;
    if ( v12 >= 4294967300.0 || !(unsigned __int8)sub_8053370(a1, (__int64)v12) )
      return -1;
    if ( !sub_8052950(a1, a2, &v13, 0) )
    {
LABEL_8:
      v5 = v13;
      if ( !*v13 )
      {
        *v13 = a2;
        result = 1;
        ++*(_DWORD *)(a1 + 16);
        ++*(_DWORD *)(a1 + 12);
        return result;
      }
      v6 = *(_DWORD **)(a1 + 36);
      if ( v6 )
      {
        *(_DWORD *)(a1 + 36) = v6[1];
      }
      else
      {
        v6 = malloc(8u);
        result = -1;
        if ( !v6 )
          return result;
      }
      v7 = v5[1];
      *v6 = a2;
      v6[1] = v7;
      result = 1;
      v5[1] = (int)v6;
      ++*(_DWORD *)(a1 + 16);
      return result;
    }
LABEL_19:
    abort();
  }
  result = 0;
  if ( a3 )
    *a3 = v3;
  return result;
}

//----- (080536D0) --------------------------------------------------------
int __cdecl sub_80536D0(int a1, int a2)
{
  int v2; // ebx
  int v3; // eax
  int v5[4]; // [esp+1Ch] [ebp-10h] BYREF

  v2 = a2;
  v3 = sub_80534F0(a1, a2, v5);
  if ( v3 == -1 )
    return 0;
  if ( !v3 )
    return v5[0];
  return v2;
}
// 80536D0: using guessed type int var_10[4];

//----- (08053710) --------------------------------------------------------
int __cdecl sub_8053710(int a1, int a2)
{
  int v2; // esi
  int *v3; // eax
  int v5; // eax
  int v6; // eax
  long double v7; // fst7
  long double v8; // fst7
  _DWORD *ptr; // eax
  _DWORD *v10; // edi
  int *v11; // [esp+2Ch] [ebp-10h] BYREF

  v2 = sub_8052950(a1, a2, &v11, 1);
  if ( v2 )
  {
    v3 = v11;
    --*(_DWORD *)(a1 + 16);
    if ( !*v3 )
    {
      v5 = *(_DWORD *)(a1 + 12) - 1;
      *(_DWORD *)(a1 + 12) = v5;
      if ( (long double)*(unsigned int *)(a1 + 8) * **(float **)(a1 + 20) > (long double)(unsigned int)v5 )
      {
        sub_8052B60((float **)(a1 + 20));
        v6 = *(_DWORD *)(a1 + 20);
        v7 = (long double)*(unsigned int *)(a1 + 8);
        if ( *(float *)v6 * v7 > (long double)*(unsigned int *)(a1 + 12) )
        {
          v8 = v7 * *(float *)(v6 + 4);
          if ( !*(_BYTE *)(v6 + 16) )
            v8 = v8 * *(float *)(v6 + 8);
          if ( !(unsigned __int8)sub_8053370(a1, (__int64)v8) )
          {
            ptr = *(_DWORD **)(a1 + 36);
            if ( ptr )
            {
              while ( 1 )
              {
                v10 = (_DWORD *)ptr[1];
                free(ptr);
                if ( !v10 )
                  break;
                ptr = v10;
              }
            }
            *(_DWORD *)(a1 + 36) = 0;
          }
        }
      }
    }
  }
  return v2;
}

//----- (08053850) --------------------------------------------------------
char *__cdecl sub_8053850(unsigned __int64 a1, int a2, __int16 a3, __int64 a4, __int64 a5)
{
  struct lconv *v5; // eax
  const char *decimal_point; // ebp
  struct lconv *v7; // ebx
  size_t v8; // eax
  char *grouping; // ecx
  const char *s; // ebx
  bool v11; // cc
  bool v12; // cf
  unsigned __int64 v13; // rax
  long double v14; // fst6
  long double v15; // fst5
  long double v16; // fst7
  unsigned __int64 v17; // rax
  long double v18; // fst6
  long double v19; // fst5
  long double v20; // fst4
  long double v21; // fst7
  long double v22; // fst6
  long double v23; // fst7
  long double v24; // fst7
  long double v25; // fst6
  __int64 v26; // rax
  __int64 v27; // rcx
  long double v28; // fst6
  long double v29; // rtt
  long double v30; // fst6
  long double v31; // fst7
  bool v32; // zf
  size_t v33; // edi
  unsigned __int64 v34; // rax
  size_t v35; // ebx
  long double v36; // fst7
  __int64 v37; // rax
  __int64 v38; // rcx
  long double v39; // fst6
  long double v40; // rt1
  long double v41; // fst6
  long double v42; // fst7
  __int64 v43; // rax
  unsigned int v44; // ebx
  int v45; // eax
  int v46; // edx
  int v47; // esi
  unsigned __int64 v48; // rax
  unsigned __int64 v49; // rax
  __int64 v50; // rdi
  __int64 v51; // rax
  unsigned int v52; // ecx
  int v53; // ebx
  char *v54; // esi
  char *v55; // ebx
  char v56; // dl
  char *result; // eax
  __int64 v58; // rax
  int v59; // ebx
  unsigned __int64 v60; // rax
  char *v61; // edi
  unsigned int v62; // edi
  unsigned int v63; // esi
  unsigned int v64; // ebp
  int v65; // eax
  unsigned __int64 v66; // rax
  bool v67; // al
  bool v68; // al
  char *v69; // ebp
  char *v70; // ebx
  unsigned int v71; // edi
  unsigned int v72; // esi
  __int64 v73; // rax
  size_t v74; // ebx
  size_t v75; // edi
  char *v76; // esi
  size_t v77; // ebp
  unsigned __int8 v78; // al
  __int64 v79; // rax
  __int64 v80; // rcx
  long double v81; // fst6
  long double v82; // rtt
  long double v83; // fst6
  long double v84; // fst7
  unsigned __int64 v85; // rax
  int i; // edi
  int v87; // ecx
  long double v88; // rtt
  long double v89; // rt0
  long double v90; // rt1
  char *s_4; // [esp+4h] [ebp-D8h]
  size_t n; // [esp+8h] [ebp-D4h]
  __int64 na; // [esp+8h] [ebp-D4h]
  long double v94; // [esp+10h] [ebp-CCh]
  long double v95; // [esp+10h] [ebp-CCh]
  long double v96; // [esp+10h] [ebp-CCh]
  unsigned int v97; // [esp+34h] [ebp-A8h]
  int v98; // [esp+38h] [ebp-A4h]
  unsigned int v99; // [esp+40h] [ebp-9Ch]
  char *v100; // [esp+44h] [ebp-98h]
  char *v101; // [esp+50h] [ebp-8Ch]
  char *v102; // [esp+54h] [ebp-88h]
  size_t v103; // [esp+5Ch] [ebp-80h]
  int v104; // [esp+60h] [ebp-7Ch]
  unsigned __int64 v105; // [esp+68h] [ebp-74h]
  unsigned int v106; // [esp+68h] [ebp-74h]
  __int64 v107; // [esp+70h] [ebp-6Ch]
  unsigned int v108; // [esp+7Ch] [ebp-60h]
  const char *v109; // [esp+80h] [ebp-5Ch]
  __int64 v110; // [esp+88h] [ebp-54h]
  char v111[41]; // [esp+93h] [ebp-49h] BYREF
  unsigned int v112; // [esp+BCh] [ebp-20h]

  v112 = __readgsdword(0x14u);
  v104 = a3 & 3;
  v99 = (a3 & 0x20) == 0 ? 1000 : 1024;
  v5 = localeconv();
  decimal_point = v5->decimal_point;
  v7 = v5;
  v8 = strlen(v5->decimal_point);
  grouping = v7->grouping;
  s = v7->thousands_sep;
  v100 = grouping;
  v11 = v8 - 1 <= 0xF;
  if ( v8 - 1 > 0xF )
    v8 = 1;
  v103 = v8;
  if ( !v11 )
    decimal_point = ".";
  v12 = strlen(s) < 0x11;
  LODWORD(v13) = "";
  if ( v12 )
    LODWORD(v13) = s;
  v101 = (char *)v13;
  v102 = (char *)(a2 + 648);
  if ( a5 <= (unsigned __int64)a4 )
  {
    LODWORD(v13) = sub_8059DC0(a4, a5);
    HIDWORD(v13) |= v13;
    if ( !HIDWORD(v13) )
    {
      LODWORD(v58) = sub_8059C90(a4, a5, HIDWORD(a5));
      na = v58;
      v59 = HIDWORD(v58) * a1 + v58 * HIDWORD(a1);
      v60 = (unsigned int)v58 * (unsigned __int64)(unsigned int)a1;
      HIDWORD(v60) += v59;
      v107 = v60;
      LODWORD(v13) = sub_8059C90(v60, na, HIDWORD(na));
      HIDWORD(v13) = a1 ^ v13 | HIDWORD(a1) ^ HIDWORD(v13);
      if ( !HIDWORD(v13) )
      {
        v53 = 0;
        v52 = 0;
        goto LABEL_68;
      }
    }
  }
  else if ( a4 )
  {
    LODWORD(v13) = sub_8059DC0(a5, a4);
    HIDWORD(v13) |= v13;
    if ( !HIDWORD(v13) )
    {
      LODWORD(v43) = sub_8059C90(a5, a4, HIDWORD(a4));
      v44 = HIDWORD(v43);
      v108 = v43;
      v45 = sub_8059DC0(a1, v43);
      v47 = 10 * v46;
      v48 = 10LL * (unsigned int)v45;
      HIDWORD(v48) += v47;
      v105 = v48;
      LODWORD(v49) = sub_8059DC0(v48, __SPAIR64__(v44, v108));
      LODWORD(v50) = v49 >> 31;
      HIDWORD(v50) = 2 * v49;
      LODWORD(v51) = sub_8059C90(a1, v108, v44);
      v107 = v51;
      v52 = sub_8059C90(v105, v108, v44);
      if ( v44 < (unsigned int)v50 )
        goto LABEL_45;
      if ( v44 > (unsigned int)v50 || v108 > HIDWORD(v50) )
      {
        v53 = v50 != 0;
        goto LABEL_68;
      }
      if ( __PAIR64__(v44, v108) >= __PAIR64__(v50, HIDWORD(v50)) )
        v53 = 2;
      else
LABEL_45:
        v53 = 3;
LABEL_68:
      v61 = (char *)(a2 + 648);
      v98 = -1;
      if ( (a3 & 0x10) != 0 )
      {
        if ( HIDWORD(v107) || (v98 = 0, (unsigned int)v107 >= v99) )
        {
          v62 = HIDWORD(v107);
          v63 = v107;
          v109 = decimal_point;
          v64 = v52;
          v98 = 0;
          do
          {
            v65 = sub_8059DC0(__PAIR64__(v62, v63), v99);
            v106 = (v64 + 10 * v65) / v99;
            v97 = (v53 >> 1) + 2 * ((v64 + 10 * v65) % v99);
            LODWORD(v66) = sub_8059C90(__PAIR64__(v62, v63), v99, 0);
            v64 = v106;
            v62 = HIDWORD(v66);
            v63 = v66;
            if ( v99 <= v97 )
              v53 = 3 - (v99 >= v53 + v97);
            else
              v53 = v53 + v97 != 0;
            ++v98;
          }
          while ( v98 <= 7 && v99 <= v66 );
          v52 = v106;
          v107 = v66;
          decimal_point = v109;
          if ( v66 > 9 )
          {
            v61 = (char *)(a2 + 648);
            goto LABEL_81;
          }
          if ( v104 == 1 )
            v67 = (int)(v53 + (v106 & 1)) > 2;
          else
            v67 = v53 > 0 && v104 == 0;
          if ( v67 )
          {
            LOBYTE(v52) = v106 + 1;
            if ( v106 != 9 )
            {
LABEL_80:
              *(_BYTE *)(a2 + 647) = v52 + 48;
              v53 = 0;
              v61 = (char *)(a2 + 647 - v103);
              memcpy(v61, v109, v103);
              v52 = 0;
              goto LABEL_81;
            }
            if ( ++v107 == 10 )
            {
              v61 = (char *)(a2 + 648);
              v53 = 0;
              v52 = 0;
              goto LABEL_81;
            }
            v53 = 0;
          }
          else if ( v106 )
          {
            goto LABEL_80;
          }
          v52 = 0;
          v61 = (char *)(a2 + 648);
          if ( (a3 & 8) == 0 )
            goto LABEL_80;
        }
      }
LABEL_81:
      if ( v104 == 1 )
      {
        v68 = (int)(v52 + ((v107 & 1) + v53 != 0)) > 5;
      }
      else
      {
        if ( (a3 & 3) != 0 )
          goto LABEL_90;
        v68 = (int)(v53 + v52) > 0;
      }
      if ( v68 )
      {
        ++v107;
        if ( (a3 & 0x10) != 0 && v107 == v99 && v98 <= 7 )
        {
          ++v98;
          v107 = 1LL;
          if ( (a3 & 8) == 0 )
          {
            *(v61 - 1) = 48;
            v61 = &v61[-v103 - 1];
            memcpy(v61, decimal_point, v103);
          }
        }
      }
LABEL_90:
      v69 = v61;
      v70 = v61;
      v71 = HIDWORD(v107);
      v72 = v107;
      do
      {
        *--v70 = sub_8059DC0(__PAIR64__(v71, v72), 10LL) + 48;
        LODWORD(v73) = sub_8059C90(__PAIR64__(v71, v72), 0xAu, 0);
        v71 = HIDWORD(v73);
        v72 = v73;
      }
      while ( v73 );
      v54 = v70;
      v55 = v69;
      if ( (a3 & 4) == 0 )
        goto LABEL_50;
      goto LABEL_93;
    }
  }
  v110 = a4;
  v14 = (long double)a4;
  if ( a4 < 0 )
  {
    v14 = v14 + 1.8446744e19;
    v15 = (long double)a5;
    if ( a5 >= 0 )
      goto LABEL_11;
  }
  else
  {
    v15 = (long double)a5;
    if ( a5 >= 0 )
      goto LABEL_11;
  }
  v15 = v15 + 1.8446744e19;
LABEL_11:
  v16 = (long double)a1 * (v14 / v15);
  if ( (a3 & 0x10) != 0 )
  {
    v110 = v99;
    v17 = 0LL;
    v18 = (long double)v99;
    v19 = v18;
    while ( 1 )
    {
      LODWORD(v17) = v17 + 1;
      v20 = v16;
      v21 = v19 * v18;
      if ( v20 < v21 )
        break;
      if ( (int)v17 > 7 )
      {
        v22 = v20;
        v23 = v19;
        goto LABEL_18;
      }
      v19 = v21;
      v16 = v20;
    }
    v22 = v20;
    v23 = v19;
LABEL_18:
    v24 = v22 / v23;
    v98 = v17;
    v25 = v24;
    if ( v104 != 1 )
    {
      if ( v24 >= 1.8446744073709551615e19 )
      {
        v25 = v24;
      }
      else
      {
        if ( v24 >= 9.223372e18 )
        {
          v26 = (__int64)(v24 - 9.223372e18);
          HIDWORD(v26) += 0x80000000;
        }
        else
        {
          v110 = (__int64)v24;
          v26 = (__int64)v24;
        }
        v27 = 0LL;
        if ( (a3 & 3) == 0 )
        {
          v110 = v26;
          v28 = (long double)(unsigned __int64)v26;
          if ( v26 < 0 )
          {
            v89 = v28;
            v30 = v24;
            v31 = v89;
          }
          else
          {
            v29 = v28;
            v30 = v24;
            v31 = v29;
          }
          v27 = 1LL;
          v32 = v30 == v31;
          v24 = v30;
          if ( v32 )
            v27 = 0LL;
        }
        v17 = v27 + v26;
        v110 = v17;
        v25 = (long double)v17;
      }
    }
    v94 = v25;
    __sprintf_chk(a2, HIDWORD(v17), a2, 1, -1, "%.1Lf", LODWORD(v94));
    v33 = v103 + 1;
    v35 = strlen((const char *)a2);
    if ( v35 > v103 + 1 + ((a3 & 0x20) == 0) + 1 || (a3 & 8) != 0 && *(_BYTE *)(a2 + v35 - 1) == 48 )
    {
      v36 = v24 * 10.0;
      if ( v104 != 1 && v36 < 1.8446744073709551615e19 )
      {
        if ( v36 >= 9.223372e18 )
        {
          v37 = (__int64)(v36 - 9.223372e18);
          HIDWORD(v37) += 0x80000000;
        }
        else
        {
          v110 = (__int64)v36;
          v37 = (__int64)v36;
        }
        v38 = 0LL;
        if ( (a3 & 3) == 0 )
        {
          v110 = v37;
          v39 = (long double)(unsigned __int64)v37;
          if ( v37 < 0 )
          {
            v90 = v39;
            v41 = v36;
            v42 = v90;
          }
          else
          {
            v40 = v39;
            v41 = v36;
            v42 = v40;
          }
          v38 = v41 != v42;
        }
        v34 = v38 + v37;
        v110 = v34;
        v36 = (long double)v34;
      }
      v33 = 0;
      v95 = v36 / 10.0;
      __sprintf_chk(a2, HIDWORD(v34), a2, 1, -1, "%.0Lf", LODWORD(v95));
      v35 = strlen((const char *)a2);
    }
  }
  else
  {
    if ( v104 != 1 && v16 < 1.8446744073709551615e19 )
    {
      if ( v16 >= 9.223372e18 )
      {
        v79 = (__int64)(v16 - 9.223372e18);
        HIDWORD(v79) += 0x80000000;
      }
      else
      {
        v110 = (__int64)v16;
        v79 = (__int64)v16;
      }
      v80 = 0LL;
      if ( (a3 & 3) == 0 )
      {
        v110 = v79;
        v81 = (long double)(unsigned __int64)v79;
        if ( v79 < 0 )
        {
          v88 = v81;
          v83 = v16;
          v84 = v88;
        }
        else
        {
          v82 = v81;
          v83 = v16;
          v84 = v82;
        }
        v80 = v83 != v84;
      }
      v13 = v80 + v79;
      v110 = v13;
      v16 = (long double)v13;
    }
    v33 = 0;
    v96 = v16;
    __sprintf_chk(a2, HIDWORD(v13), a2, 1, -1, "%.0Lf", LODWORD(v96));
    v98 = -1;
    v35 = strlen((const char *)a2);
  }
  n = v35;
  v54 = &v102[-v35];
  v55 = &v102[-v33];
  memmove(v54, (const void *)a2, n);
  if ( (a3 & 4) != 0 )
  {
LABEL_93:
    v74 = v55 - v54;
    v75 = -1;
    s_4 = v54;
    v76 = &v54[v74];
    v77 = strlen(v101);
    __memcpy_chk(v111, s_4, v74, 41);
    while ( 1 )
    {
      v78 = *v100;
      if ( *v100 )
      {
        v75 = v78;
        if ( v78 > 0x7Eu )
          v75 = v74;
        ++v100;
      }
      if ( v75 > v74 )
        v75 = v74;
      v74 -= v75;
      v54 = &v76[-v75];
      memcpy(v54, &v111[v74], v75);
      if ( !v74 )
        break;
      v76 = &v54[-v77];
      memcpy(v76, v101, v77);
    }
  }
LABEL_50:
  if ( (a3 & 0x80u) != 0 )
  {
    if ( v98 == -1 )
    {
      if ( HIDWORD(a5) || (v98 = 0, (unsigned int)a5 > 1) )
      {
        v85 = 1LL;
        for ( i = 1; i != 8; ++i )
        {
          v87 = HIDWORD(v85) * v99;
          v85 = v99 * (unsigned __int64)(unsigned int)v85;
          HIDWORD(v85) += v87;
          if ( a5 <= v85 )
            break;
        }
        v98 = i;
      }
    }
    if ( a3 & 0x100 | v98 )
    {
      if ( (a3 & 0x40) != 0 )
      {
        *(_BYTE *)(a2 + 648) = 32;
        v102 = (char *)(a2 + 649);
      }
      if ( v98 )
      {
        if ( v98 != 1 || (v56 = 107, (a3 & 0x20) != 0) )
          v56 = byte_805D46C[v98];
        *v102++ = v56;
      }
      if ( (a3 & 0x100) != 0 )
      {
        if ( v98 && (a3 & 0x20) != 0 )
          *v102++ = 105;
        *v102++ = 66;
      }
    }
  }
  result = v54;
  *v102 = 0;
  return result;
}
// 8053968: variable 'v13' is possibly undefined
// 8053C5B: variable 'v34' is possibly undefined
// 8053CD1: variable 'v43' is possibly undefined
// 8053CFF: variable 'v46' is possibly undefined
// 8053D36: variable 'v49' is possibly undefined
// 8053D58: variable 'v51' is possibly undefined
// 8053F0E: variable 'v58' is possibly undefined
// 805400A: variable 'v66' is possibly undefined
// 80541AE: variable 'v73' is possibly undefined
// 8049840: using guessed type int __cdecl __memcpy_chk(_DWORD, _DWORD, _DWORD, _DWORD);
// 8049B70: using guessed type int __fastcall __sprintf_chk(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (08054660) --------------------------------------------------------
int __cdecl sub_8054660(char *a1, int a2, int a3)
{
  char *v3; // edx
  int v4; // esi
  int v5; // eax
  int v6; // edx
  unsigned int v7; // ecx
  int v8; // edi
  int v10; // esi
  int v11; // eax
  char *v12; // edx
  char *v13; // eax
  char *v14; // [esp+2Ch] [ebp-30h]
  char *v15; // [esp+3Ch] [ebp-20h] BYREF

  v3 = a1;
  if ( !a1 )
  {
    v3 = getenv("BLOCK_SIZE");
    if ( !v3 )
    {
      v3 = getenv("BLOCKSIZE");
      if ( !v3 )
      {
        v13 = getenv("POSIXLY_CORRECT");
        v7 = 0;
        v6 = 1024;
        if ( v13 )
        {
          v6 = 512;
          v7 = 0;
        }
        *(_DWORD *)a3 = v6;
        v4 = 0;
        *(_DWORD *)(a3 + 4) = 0;
        goto LABEL_6;
      }
    }
  }
  v4 = 0;
  if ( *v3 == 39 )
  {
    ++v3;
    LOWORD(v4) = 4;
  }
  v14 = v3;
  v5 = sub_8051C00(v3, (int)off_805D478, dword_805D484, 4u);
  if ( v5 >= 0 )
  {
    v4 |= dword_805D484[v5];
    v6 = 1;
    *(_DWORD *)a3 = 1;
    v7 = 0;
    *(_DWORD *)(a3 + 4) = 0;
    goto LABEL_6;
  }
  v11 = sub_8059230(v14, &v15, 0, a3, "eEgGkKmMpPtTyYzZ0");
  v12 = v14;
  v8 = v11;
  if ( !v11 )
  {
    if ( (unsigned __int8)(*v14 - 48) > 9u )
    {
      if ( v14 == v15 )
      {
LABEL_25:
        v4 |= 0x80u;
        if ( *(v15 - 1) != 66 || (v4 |= 0x100u, *(v15 - 2) == 105) )
        {
          v4 |= 0x20u;
          v6 = *(_DWORD *)a3;
          v7 = *(_DWORD *)(a3 + 4);
          goto LABEL_6;
        }
      }
      else
      {
        while ( (unsigned __int8)(v12[1] - 48) > 9u )
        {
          if ( ++v12 == v15 )
            goto LABEL_25;
        }
      }
    }
    v6 = *(_DWORD *)a3;
    v7 = *(_DWORD *)(a3 + 4);
LABEL_6:
    *(_DWORD *)a2 = v4;
    v8 = 0;
    goto LABEL_7;
  }
  *(_DWORD *)a2 = 0;
  v6 = *(_DWORD *)a3;
  v7 = *(_DWORD *)(a3 + 4);
LABEL_7:
  if ( !__PAIR64__(v7, v6) )
  {
    v10 = 1024;
    if ( getenv("POSIXLY_CORRECT") )
      v10 = 512;
    *(_DWORD *)(a3 + 4) = 0;
    v8 = 4;
    *(_DWORD *)a3 = v10;
  }
  return v8;
}
// 805D478: using guessed type char *off_805D478[2];
// 805D484: using guessed type int dword_805D484[];

//----- (08054860) --------------------------------------------------------
int __cdecl sub_8054860(__uid_t uid)
{
  _DWORD *v1; // eax
  int v2; // esi
  struct passwd *v3; // eax
  const char *src; // edi
  size_t v5; // eax
  char *v6; // eax
  int v7; // eax
  int result; // eax

  v1 = (_DWORD *)dword_8062DAC;
  if ( dword_8062DAC )
  {
    v2 = dword_8062DAC;
    if ( *(_DWORD *)dword_8062DAC == uid )
      goto LABEL_9;
    while ( 1 )
    {
      v1 = (_DWORD *)v1[1];
      if ( !v1 )
        break;
      if ( *v1 == uid )
      {
        v2 = (int)v1;
        goto LABEL_9;
      }
    }
  }
  v3 = getpwuid(uid);
  if ( v3 )
  {
    src = v3->pw_name;
    v5 = strlen(v3->pw_name) + 9;
  }
  else
  {
    v5 = 9;
    src = "";
  }
  v6 = (char *)sub_8058A70(v5);
  *(_DWORD *)v6 = uid;
  v2 = (int)v6;
  strcpy(v6 + 8, src);
  v7 = dword_8062DAC;
  dword_8062DAC = v2;
  *(_DWORD *)(v2 + 4) = v7;
LABEL_9:
  result = 0;
  if ( *(_BYTE *)(v2 + 8) )
    return v2 + 8;
  return result;
}
// 8062DAC: using guessed type int dword_8062DAC;

//----- (080549F0) --------------------------------------------------------
int __cdecl sub_80549F0(__gid_t gid)
{
  _DWORD *v1; // eax
  int v2; // esi
  struct group *v3; // eax
  const char *src; // edi
  size_t v5; // eax
  char *v6; // eax
  int v7; // eax
  int result; // eax

  v1 = (_DWORD *)dword_8062DB4;
  if ( dword_8062DB4 )
  {
    v2 = dword_8062DB4;
    if ( *(_DWORD *)dword_8062DB4 == gid )
      goto LABEL_9;
    while ( 1 )
    {
      v1 = (_DWORD *)v1[1];
      if ( !v1 )
        break;
      if ( *v1 == gid )
      {
        v2 = (int)v1;
        goto LABEL_9;
      }
    }
  }
  v3 = getgrgid(gid);
  if ( v3 )
  {
    src = v3->gr_name;
    v5 = strlen(v3->gr_name) + 9;
  }
  else
  {
    v5 = 9;
    src = "";
  }
  v6 = (char *)sub_8058A70(v5);
  *(_DWORD *)v6 = gid;
  v2 = (int)v6;
  strcpy(v6 + 8, src);
  v7 = dword_8062DB4;
  dword_8062DB4 = v2;
  *(_DWORD *)(v2 + 4) = v7;
LABEL_9:
  result = 0;
  if ( *(_BYTE *)(v2 + 8) )
    return v2 + 8;
  return result;
}
// 8062DB4: using guessed type int dword_8062DB4;

//----- (08054B80) --------------------------------------------------------
int __cdecl sub_8054B80(unsigned int a1, int a2, int a3)
{
  int v3; // ebx
  int v5; // edi
  __int64 v6; // rax
  int v8; // ebp
  __int64 v9; // rax

  v3 = a2;
  v5 = a3 + 20;
  *(_BYTE *)(a3 + 20) = 0;
  if ( a2 < 0 )
  {
    do
    {
      v8 = v5--;
      *(_BYTE *)(v8 - 1) = 48 - sub_8059AC0(__SPAIR64__(v3, a1), 10LL);
      LODWORD(v9) = sub_8059950(__SPAIR64__(v3, a1), 10LL);
      v3 = HIDWORD(v9);
      a1 = v9;
    }
    while ( v9 );
    *(_BYTE *)(v8 - 2) = 45;
    return v8 - 2;
  }
  else
  {
    do
    {
      *(_BYTE *)--v5 = sub_8059AC0(__SPAIR64__(v3, a1), 10LL) + 48;
      LODWORD(v6) = sub_8059950(__SPAIR64__(v3, a1), 10LL);
      v3 = HIDWORD(v6);
      a1 = v6;
    }
    while ( v6 );
    return v5;
  }
}
// 8054BE2: variable 'v6' is possibly undefined
// 8054C45: variable 'v9' is possibly undefined

//----- (08054C60) --------------------------------------------------------
int __cdecl sub_8054C60(unsigned int a1, unsigned int a2, int a3)
{
  int v5; // edi
  __int64 v6; // rax

  v5 = a3 + 20;
  *(_BYTE *)(a3 + 20) = 0;
  do
  {
    *(_BYTE *)--v5 = sub_8059DC0(__PAIR64__(a2, a1), 10LL) + 48;
    LODWORD(v6) = sub_8059C90(__PAIR64__(a2, a1), 0xAu, 0);
    a2 = HIDWORD(v6);
    a1 = v6;
  }
  while ( v6 );
  return v5;
}
// 8054CC6: variable 'v6' is possibly undefined

//----- (08054CE0) --------------------------------------------------------
int __cdecl sub_8054CE0(char *s, int a2, int a3, int a4, int a5, char a6)
{
  _BYTE *v6; // ebx
  size_t v7; // esi
  size_t v8; // eax
  wchar_t *v9; // eax
  wchar_t *pwcs; // ebp
  size_t v11; // edx
  size_t v12; // eax
  unsigned int v13; // ecx
  unsigned int v14; // edi
  int v15; // esi
  unsigned int v16; // eax
  _BYTE *v17; // eax
  size_t v19; // ecx
  wint_t v20; // eax
  wchar_t *v21; // esi
  char v22; // bl
  char *v23; // eax
  wchar_t v24; // edx
  wchar_t *v25; // edi
  unsigned int v26; // ebx
  unsigned int v27; // eax
  int v28; // eax
  size_t v29; // [esp+18h] [ebp-34h]
  char v30; // [esp+18h] [ebp-34h]
  int v31; // [esp+1Ch] [ebp-30h]
  unsigned int v32; // [esp+20h] [ebp-2Ch]
  size_t n; // [esp+24h] [ebp-28h]
  char *v34; // [esp+24h] [ebp-28h]
  size_t v35; // [esp+28h] [ebp-24h]
  char *v36; // [esp+28h] [ebp-24h]
  _BYTE *v37; // [esp+28h] [ebp-24h]
  size_t size; // [esp+2Ch] [ebp-20h]

  v6 = (_BYTE *)a2;
  v7 = strlen(s);
  v35 = v7;
  if ( __ctype_get_mb_cur_max() <= 1 )
  {
    pwcs = 0;
    goto LABEL_5;
  }
  v8 = mbstowcs(0, s, 0);
  if ( v8 == -1 )
  {
    if ( (a6 & 1) == 0 )
    {
      pwcs = 0;
      v34 = 0;
      v31 = -1;
      goto LABEL_25;
    }
    v11 = v7;
    pwcs = 0;
    v36 = s;
    v34 = 0;
  }
  else
  {
    v29 = v8;
    n = v8 + 1;
    v9 = (wchar_t *)malloc(4 * (v8 + 1));
    pwcs = v9;
    if ( v9 )
    {
      if ( !mbstowcs(v9, s, n) )
      {
LABEL_5:
        v11 = v7;
        v34 = 0;
        v36 = s;
        goto LABEL_6;
      }
      pwcs[v29] = 0;
      v20 = *pwcs;
      if ( *pwcs )
      {
        v21 = pwcs;
        v22 = 0;
        do
        {
          if ( !iswprint(v20) )
          {
            *v21 = 65533;
            v22 = 1;
          }
          v20 = *++v21;
        }
        while ( *v21 );
        v30 = v22;
        v6 = (_BYTE *)a2;
        v7 = wcswidth(pwcs, n);
        if ( v30 )
        {
          size = wcstombs(0, pwcs, 0) + 1;
          v23 = (char *)malloc(size);
LABEL_39:
          v34 = v23;
          if ( v23 )
          {
            v24 = *pwcs;
            v7 = 0;
            v25 = pwcs;
            if ( *pwcs )
            {
              v37 = v6;
              v26 = *(_DWORD *)a4;
              while ( 1 )
              {
                v28 = wcwidth(v24);
                if ( v28 == -1 )
                {
                  v27 = v7 + 1;
                  *v25 = 65533;
                  if ( v26 < v7 + 1 )
                  {
LABEL_47:
                    v6 = v37;
                    goto LABEL_48;
                  }
                }
                else
                {
                  v27 = v7 + v28;
                  if ( v26 < v27 )
                    goto LABEL_47;
                }
                v24 = *++v25;
                if ( !*v25 )
                  break;
                v7 = v27;
              }
              v6 = v37;
              v7 = v27;
            }
LABEL_48:
            *v25 = 0;
            v11 = wcstombs(v34, pwcs, size);
            v36 = v34;
          }
          else
          {
            if ( (a6 & 1) == 0 )
            {
              v31 = -1;
              goto LABEL_25;
            }
            v11 = v35;
            v36 = s;
          }
          goto LABEL_6;
        }
      }
      else
      {
        v7 = wcswidth(pwcs, n);
      }
      v12 = *(_DWORD *)a4;
      if ( *(_DWORD *)a4 >= v7 )
      {
        v11 = v35;
        v34 = 0;
        v36 = s;
        goto LABEL_30;
      }
      size = v35 + 1;
      v23 = (char *)malloc(v35 + 1);
      goto LABEL_39;
    }
    if ( (a6 & 1) == 0 )
    {
      v34 = 0;
      v31 = -1;
      goto LABEL_25;
    }
    v11 = v7;
    v36 = s;
    v34 = 0;
  }
LABEL_6:
  v12 = *(_DWORD *)a4;
  if ( v7 > *(_DWORD *)a4 )
  {
    v11 = *(_DWORD *)a4;
    v13 = 0;
    goto LABEL_8;
  }
LABEL_30:
  if ( v7 >= v12 )
  {
    v12 = v7;
    v13 = 0;
  }
  else
  {
    v19 = v12;
    v12 = v7;
    v13 = v19 - v7;
  }
LABEL_8:
  *(_DWORD *)a4 = v12;
  v31 = v11 + v13;
  if ( a3 )
  {
    v32 = v13;
    v14 = (unsigned int)&v6[a3 - 1];
    v15 = v13 - 1;
    if ( a5 )
    {
      if ( a5 == 1 )
      {
        v16 = v13 - 1;
        v15 = -1;
        v32 = 0;
      }
      else
      {
        v32 = v13 >> 1;
        v13 = (v13 >> 1) + (v13 & 1);
        v15 = v32 - 1;
        v16 = v13 - 1;
      }
      if ( v13 && (unsigned int)v6 < v14 )
      {
        do
        {
          *v6++ = 32;
          if ( !v16 )
            break;
          --v16;
        }
        while ( v6 != (_BYTE *)v14 );
      }
    }
    if ( v14 - (unsigned int)v6 <= v11 )
      v11 = v14 - (_DWORD)v6;
    *v6 = 0;
    v17 = (_BYTE *)mempcpy(v6, v36, v11);
    if ( v32 && v14 > (unsigned int)v17 )
    {
      do
      {
        *v17++ = 32;
        if ( !v15 )
          break;
        --v15;
      }
      while ( v17 != (_BYTE *)v14 );
    }
    *v17 = 0;
  }
LABEL_25:
  free(pwcs);
  free(v34);
  return v31;
}
// 8049590: using guessed type int __cdecl wcwidth(_DWORD);
// 8049990: using guessed type int __cdecl mempcpy(_DWORD, _DWORD, _DWORD);
// 80499A0: using guessed type int __cdecl wcswidth(_DWORD, _DWORD);

//----- (08055160) --------------------------------------------------------
__int64 __cdecl sub_8055160(char *a1, int a2, int a3)
{
  char *s; // esi
  int v4; // edi
  char v5; // al
  size_t v6; // eax
  int v7; // ebx
  int v8; // eax
  __int64 result; // rax
  const unsigned __int16 *v10; // edx
  unsigned __int16 v11; // ax
  char *v12; // [esp+18h] [ebp-34h]
  wchar_t pwc; // [esp+20h] [ebp-2Ch] BYREF
  mbstate_t ps; // [esp+24h] [ebp-28h] BYREF
  unsigned int v15; // [esp+2Ch] [ebp-20h]

  s = a1;
  v15 = __readgsdword(0x14u);
  v12 = &a1[a2];
  if ( __ctype_get_mb_cur_max() > 1 )
  {
    v4 = 0;
    if ( a1 >= v12 )
      goto LABEL_24;
    while ( 1 )
    {
      v5 = *s;
      if ( *s > 95 )
      {
        if ( (unsigned __int8)(v5 - 97) > 0x1Du )
          goto LABEL_8;
      }
      else if ( v5 < 65 && (v5 < 32 || v5 > 35 && (unsigned __int8)(v5 - 37) > 0x1Au) )
      {
LABEL_8:
        ps.__count = 0;
        ps.__wch = 0;
        while ( 1 )
        {
          v6 = mbrtowc(&pwc, s, v12 - s, &ps);
          v7 = v6;
          if ( v6 == -1 )
          {
            if ( (a3 & 1) != 0 )
              goto LABEL_39;
            goto LABEL_22;
          }
          if ( v6 == -2 )
            break;
          if ( !v6 )
            v7 = 1;
          v8 = wcwidth(pwc);
          if ( v8 >= 0 )
          {
            if ( v8 > 0x7FFFFFFF - v4 )
            {
              v4 = 0x7FFFFFFF;
              goto LABEL_24;
            }
            v4 += v8;
          }
          else
          {
            if ( (a3 & 2) != 0 )
              goto LABEL_39;
            if ( !iswcntrl(pwc) )
            {
              if ( v4 == 0x7FFFFFFF )
                goto LABEL_24;
              ++v4;
            }
          }
          s += v7;
          if ( mbsinit(&ps) )
            goto LABEL_23;
        }
        if ( (a3 & 1) != 0 )
          goto LABEL_39;
        ++v4;
        goto LABEL_24;
      }
LABEL_22:
      ++s;
      ++v4;
LABEL_23:
      if ( v12 <= s )
        goto LABEL_24;
    }
  }
  v4 = 0;
  if ( a1 < v12 )
  {
    v4 = 0;
    v10 = *__ctype_b_loc();
    do
    {
      v11 = v10[(unsigned __int8)*s];
      if ( (v11 & 0x4000) != 0 )
        goto LABEL_35;
      if ( (a3 & 2) != 0 )
      {
LABEL_39:
        v4 = -1;
        break;
      }
      if ( (v11 & 2) == 0 )
      {
LABEL_35:
        if ( v4 == 0x7FFFFFFF )
          break;
        ++v4;
      }
      ++s;
    }
    while ( s != v12 );
  }
LABEL_24:
  HIDWORD(result) = __readgsdword(0x14u) ^ v15;
  LODWORD(result) = v4;
  return result;
}
// 8049590: using guessed type int __cdecl wcwidth(_DWORD);

//----- (08055350) --------------------------------------------------------
__int64 __cdecl sub_8055350(char *s, int a2)
{
  int v2; // eax

  v2 = strlen(s);
  return sub_8055160(s, v2, a2);
}

//----- (08055380) --------------------------------------------------------
_DWORD *__usercall sub_8055380@<eax>(
        _DWORD *result@<eax>,
        unsigned int a2@<edx>,
        int *a3@<ecx>,
        int (__cdecl *a4)(int, int))
{
  int *v4; // ebx
  int v5; // ebp
  unsigned int v6; // edi
  int v7; // ebx
  int *dest; // esi
  unsigned int v9; // edi
  int v10; // ebp
  int i; // esi
  int v12; // esi
  int v13; // edi
  unsigned int v14; // [esp+14h] [ebp-38h]
  int v15; // [esp+14h] [ebp-38h]
  int *v16; // [esp+18h] [ebp-34h]
  int v17; // [esp+18h] [ebp-34h]
  unsigned int v19; // [esp+20h] [ebp-2Ch]
  unsigned int v21; // [esp+28h] [ebp-24h]
  int *v22; // [esp+2Ch] [ebp-20h]

  v4 = result;
  if ( a2 > 2 )
  {
    v22 = &result[a2 >> 1];
    v19 = a2 >> 1;
    sub_8055380(v22, a2 - (a2 >> 1), a3, a4);
    if ( a2 >> 1 != 1 )
    {
      v21 = a2 >> 2;
      sub_8055380(&v4[a2 >> 2], v19 - (a2 >> 2), a3, a4);
      sub_8055380(v4, a2 >> 2, a3, a4);
      v5 = v4[a2 >> 2];
      v16 = v4;
      v6 = a2 >> 2;
      v14 = 0;
      v7 = *v4;
      for ( dest = a3 + 1; ; ++dest )
      {
        if ( a4(v7, v5) > 0 )
        {
          ++v6;
          *(dest - 1) = v5;
          if ( v19 == v6 )
          {
            v4 = v16;
            goto LABEL_24;
          }
          v5 = v16[v6];
        }
        else
        {
          ++v14;
          *(dest - 1) = v7;
          if ( v21 == v14 )
          {
            v4 = v16;
            v14 = v6;
            v21 = v19;
LABEL_24:
            memcpy(dest, &v4[v14], 4 * (v21 - v14));
            v15 = *a3;
LABEL_13:
            v9 = v19;
            v17 = 0;
            v10 = *v22;
            for ( i = 1; ; ++i )
            {
              result = (_DWORD *)a4(v15, v10);
              if ( (int)result > 0 )
              {
                ++v9;
                v4[i - 1] = v10;
                if ( a2 == v9 )
                  return memcpy(&v4[i], &a3[v17], 4 * (v19 - v17));
                v10 = v4[v9];
              }
              else
              {
                ++v17;
                v4[i - 1] = v15;
                if ( v19 == v17 )
                  return result;
                v15 = a3[v17];
              }
            }
          }
          v7 = v16[v14];
        }
      }
    }
    v15 = *v4;
    *a3 = *v4;
    goto LABEL_13;
  }
  if ( a2 == 2 )
  {
    v12 = *result;
    v13 = result[1];
    result = (_DWORD *)a4(*result, v13);
    if ( (int)result > 0 )
    {
      *v4 = v13;
      v4[1] = v12;
    }
  }
  return result;
}

//----- (080555B0) --------------------------------------------------------
_DWORD *__cdecl sub_80555B0(_DWORD *a1, unsigned int a2, int (__cdecl *a3)(int, int))
{
  return sub_8055380(a1, a2, &a1[a2], a3);
}

//----- (080555D0) --------------------------------------------------------
char *__cdecl sub_80555D0(char *s)
{
  char *v1; // ebx
  char *result; // eax

  v1 = s;
  if ( !s )
  {
    fwrite("A NULL argv[0] was passed through an exec system call.\n", 1u, 0x37u, stderr);
    abort();
  }
  result = strrchr(s, 47);
  if ( result )
  {
    if ( result + 1 - s > 6 && !memcmp(result - 6, "/.libs/", 7u) )
    {
      v1 = result + 1;
      if ( !memcmp(result + 1, "lt-", 3u) )
      {
        v1 = result + 4;
        program_invocation_short_name = (int)(result + 4);
      }
    }
  }
  dword_8062DBC = (int)v1;
  program_invocation_name = (int)v1;
  return result;
}
// 80622E0: using guessed type int program_invocation_short_name;
// 8062300: using guessed type int program_invocation_name;
// 8062DBC: using guessed type int dword_8062DBC;

//----- (08055690) --------------------------------------------------------
_BYTE *__cdecl sub_8055690(int a1, int a2)
{
  return sub_80567D0(a1, 6, a2);
}

//----- (080556C0) --------------------------------------------------------
_BYTE *__cdecl sub_80556C0(int a1)
{
  return sub_8055690(0, a1);
}

//----- (080556E0) --------------------------------------------------------
_DWORD *__usercall sub_80556E0@<eax>(_DWORD *a1@<eax>, int a2@<edx>)
{
  int v3; // eax
  int v5[12]; // [esp+0h] [ebp-3Ch] BYREF

  memset(v5, 0, sizeof(v5));
  if ( a2 == 8 )
    abort();
  v3 = v5[1];
  *a1 = a2;
  a1[1] = v3;
  a1[2] = v5[2];
  a1[3] = v5[3];
  a1[4] = v5[4];
  a1[5] = v5[5];
  a1[6] = v5[6];
  a1[7] = v5[7];
  a1[8] = v5[8];
  a1[9] = v5[9];
  a1[10] = v5[10];
  a1[11] = v5[11];
  return a1;
}

//----- (08055760) --------------------------------------------------------
__int64 __usercall sub_8055760@<edx:eax>(
        _BYTE *a1@<eax>,
        unsigned int a2@<edx>,
        int a3@<ecx>,
        unsigned int a4,
        int a5,
        int a6,
        int a7,
        char *a8,
        char *a9)
{
  char v9; // bp
  unsigned int v10; // ebx
  int v11; // esi
  char v12; // dl
  unsigned __int8 *v13; // edi
  unsigned __int8 v14; // bp
  unsigned __int8 v15; // al
  const unsigned __int16 **v16; // eax
  unsigned int v17; // eax
  unsigned __int8 v18; // cl
  char v19; // al
  char i; // al
  char v21; // cl
  int v22; // edi
  unsigned __int8 v23; // cl
  bool v24; // al
  __int64 result; // rax
  char v26; // al
  char v27; // al
  char *v28; // edx
  int v29; // eax
  unsigned int v30; // esi
  const char *v31; // edi
  size_t v32; // eax
  size_t v33; // ebx
  int v34; // eax
  bool v35; // dl
  int v36; // eax
  unsigned int v37; // eax
  char *v38; // eax
  char *v39; // eax
  bool v40; // cf
  unsigned int v41; // eax
  char v42; // [esp+2Ch] [ebp-80h]
  char v43; // [esp+2Ch] [ebp-80h]
  char v44; // [esp+2Ch] [ebp-80h]
  char v45; // [esp+30h] [ebp-7Ch]
  bool v49; // [esp+40h] [ebp-6Ch]
  bool v50; // [esp+53h] [ebp-59h]
  size_t n; // [esp+58h] [ebp-54h]
  char *s2; // [esp+5Ch] [ebp-50h]
  unsigned int v53; // [esp+60h] [ebp-4Ch]
  unsigned int v54; // [esp+64h] [ebp-48h]
  int v55; // [esp+64h] [ebp-48h]
  size_t mb_cur_max; // [esp+6Ch] [ebp-40h]
  unsigned int v59; // [esp+74h] [ebp-38h]
  char v60; // [esp+7Ah] [ebp-32h]
  unsigned __int8 *v61; // [esp+7Ch] [ebp-30h]
  wchar_t pwc; // [esp+80h] [ebp-2Ch] BYREF
  mbstate_t ps; // [esp+84h] [ebp-28h] BYREF
  unsigned int v64; // [esp+8Ch] [ebp-20h]

  v64 = __readgsdword(0x14u);
  v50 = (a6 & 2) != 0;
  mb_cur_max = __ctype_get_mb_cur_max();
  switch ( a5 )
  {
    case 0:
      v50 = 0;
      v9 = 0;
      v10 = 0;
      n = 0;
      s2 = 0;
      break;
    case 1:
      v50 = 1;
      v9 = 0;
      v10 = 0;
      n = 1;
      s2 = ", `%s'" + 5;
      a5 = 2;
      break;
    case 2:
      if ( (a6 & 2) != 0 )
      {
        v9 = 0;
        v10 = 0;
        n = 1;
        s2 = ", `%s'" + 5;
      }
      else
      {
        v9 = 0;
        v10 = 1;
        n = 1;
        s2 = ", `%s'" + 5;
        if ( a2 )
          *a1 = 39;
      }
      break;
    case 3:
      if ( (a6 & 2) != 0 )
      {
        v9 = 1;
        v10 = 0;
        n = 1;
        s2 = "\"";
      }
      else
      {
        v9 = 1;
        v10 = 1;
        n = 1;
        s2 = "\"";
        if ( a2 )
          *a1 = 34;
      }
      break;
    case 4:
      v50 = 1;
      v9 = 1;
      v10 = 0;
      n = 1;
      s2 = "\"";
      a5 = 3;
      break;
    case 5:
      v50 = 0;
      v9 = 1;
      v10 = 0;
      n = 0;
      s2 = 0;
      break;
    case 6:
    case 7:
    case 8:
      if ( (a6 & 2) != 0 )
      {
        a8 = dcgettext(0, "`", 5);
        if ( a8 == "`" )
        {
          v39 = "\"";
          if ( a5 != 7 )
            v39 = a8;
          a8 = v39;
        }
        a9 = dcgettext(0, "'", 5);
        if ( a9 == "'" )
        {
          v38 = "\"";
          if ( a5 != 7 )
            v38 = ", `%s'" + 5;
          a9 = v38;
        }
      }
      v10 = 0;
      if ( (a6 & 2) == 0 )
      {
        for ( i = *a8; i; i = a8[v10] )
        {
          if ( a2 > v10 )
            a1[v10] = i;
          ++v10;
        }
      }
      v9 = 1;
      n = strlen(a9);
      s2 = a9;
      break;
    default:
      abort();
      return result;
  }
  v11 = 0;
  v12 = v9;
  while ( a4 != -1 )
  {
    if ( v11 == a4 )
      goto LABEL_135;
LABEL_10:
    if ( !v12 || !n )
    {
      v45 = 0;
      v13 = (unsigned __int8 *)(v11 + a3);
      v14 = *(_BYTE *)(v11 + a3);
      v15 = v14;
      goto LABEL_80;
    }
    v13 = (unsigned __int8 *)(v11 + a3);
    if ( a4 >= v11 + n )
    {
      v43 = v12;
      v29 = memcmp((const void *)(v11 + a3), s2, n);
      v12 = v43;
      v45 = 0;
      if ( !v29 )
      {
        if ( v50 )
          goto LABEL_107;
        v45 = 1;
      }
    }
    else
    {
      v45 = 0;
    }
    v14 = *v13;
    v15 = *v13;
    if ( *v13 <= 0x7Eu )
    {
LABEL_80:
      switch ( v15 )
      {
        case 0u:
          if ( v12 )
          {
            if ( v50 )
              goto LABEL_107;
            if ( v10 < a2 )
              a1[v10] = 92;
            v14 = 48;
            v17 = v10 + 1;
            if ( a4 > v11 + 1 )
            {
              v21 = *(_BYTE *)(a3 + v11 + 1);
              if ( v21 > 47 && v21 <= 57 )
              {
                if ( a2 > v17 )
                  a1[v17] = 48;
                if ( a2 > v10 + 2 )
                  a1[v10 + 2] = 48;
                v17 = v10 + 3;
                v14 = 48;
              }
            }
            goto LABEL_67;
          }
          if ( (a6 & 1) == 0 )
            goto LABEL_99;
          ++v11;
          break;
        case 7u:
          v26 = 97;
          goto LABEL_110;
        case 8u:
          v26 = 98;
          goto LABEL_110;
        case 9u:
          v26 = 116;
          goto LABEL_114;
        case 0xAu:
          v26 = 110;
          goto LABEL_114;
        case 0xBu:
          v26 = 118;
          goto LABEL_110;
        case 0xCu:
          v26 = 102;
          goto LABEL_110;
        case 0xDu:
          v26 = 114;
          goto LABEL_114;
        case 0x20u:
        case 0x21u:
        case 0x22u:
        case 0x24u:
        case 0x26u:
        case 0x28u:
        case 0x29u:
        case 0x2Au:
        case 0x3Bu:
        case 0x3Cu:
        case 0x3Du:
        case 0x3Eu:
        case 0x5Bu:
        case 0x5Eu:
        case 0x60u:
        case 0x7Cu:
          goto LABEL_105;
        case 0x23u:
        case 0x7Eu:
          goto LABEL_104;
        case 0x25u:
        case 0x2Bu:
        case 0x2Cu:
        case 0x2Du:
        case 0x2Eu:
        case 0x2Fu:
        case 0x30u:
        case 0x31u:
        case 0x32u:
        case 0x33u:
        case 0x34u:
        case 0x35u:
        case 0x36u:
        case 0x37u:
        case 0x38u:
        case 0x39u:
        case 0x3Au:
        case 0x41u:
        case 0x42u:
        case 0x43u:
        case 0x44u:
        case 0x45u:
        case 0x46u:
        case 0x47u:
        case 0x48u:
        case 0x49u:
        case 0x4Au:
        case 0x4Bu:
        case 0x4Cu:
        case 0x4Du:
        case 0x4Eu:
        case 0x4Fu:
        case 0x50u:
        case 0x51u:
        case 0x52u:
        case 0x53u:
        case 0x54u:
        case 0x55u:
        case 0x56u:
        case 0x57u:
        case 0x58u:
        case 0x59u:
        case 0x5Au:
        case 0x5Du:
        case 0x5Fu:
        case 0x61u:
        case 0x62u:
        case 0x63u:
        case 0x64u:
        case 0x65u:
        case 0x66u:
        case 0x67u:
        case 0x68u:
        case 0x69u:
        case 0x6Au:
        case 0x6Bu:
        case 0x6Cu:
        case 0x6Du:
        case 0x6Eu:
        case 0x6Fu:
        case 0x70u:
        case 0x71u:
        case 0x72u:
        case 0x73u:
        case 0x74u:
        case 0x75u:
        case 0x76u:
        case 0x77u:
        case 0x78u:
        case 0x79u:
        case 0x7Au:
          goto LABEL_98;
        case 0x27u:
          if ( a5 != 2 )
            goto LABEL_98;
          if ( v50 )
            goto LABEL_107;
          if ( v10 < a2 )
            a1[v10] = 39;
          if ( a2 > v10 + 1 )
            a1[v10 + 1] = 92;
          if ( a2 > v10 + 2 )
            a1[v10 + 2] = 39;
          v10 += 3;
          goto LABEL_98;
        case 0x3Fu:
          if ( a5 == 2 )
            goto LABEL_106;
          if ( a5 != 3 )
            goto LABEL_98;
          if ( (a6 & 4) == 0 )
            goto LABEL_98;
          v22 = v11 + 2;
          if ( a4 <= v11 + 2 )
            goto LABEL_98;
          if ( *(_BYTE *)(a3 + v11 + 1) != 63 )
            goto LABEL_98;
          v23 = *(_BYTE *)(a3 + v22) - 33;
          if ( v23 > 0x1Du || ((1 << v23) & 0x380051C1) == 0 )
            goto LABEL_98;
          if ( v50 )
            goto LABEL_107;
          v14 = *(_BYTE *)(a3 + v22);
          if ( v10 < a2 )
            a1[v10] = 63;
          if ( a2 > v10 + 1 )
            a1[v10 + 1] = 34;
          if ( a2 > v10 + 2 )
            a1[v10 + 2] = 34;
          if ( a2 > v10 + 3 )
            a1[v10 + 3] = 63;
          v10 += 4;
          v11 += 2;
          goto LABEL_98;
        case 0x5Cu:
          v26 = 92;
          if ( v12 && v50 && n )
            goto LABEL_75;
LABEL_114:
          if ( a5 == 2 && v50 )
            goto LABEL_107;
LABEL_110:
          if ( !v12 )
            goto LABEL_99;
          v14 = v26;
          goto LABEL_71;
        case 0x7Bu:
        case 0x7Du:
          v24 = a4 != 1;
          if ( a4 == -1 )
            v24 = *(_BYTE *)(a3 + 1) != 0;
          if ( v24 )
            goto LABEL_98;
LABEL_104:
          if ( v11 )
            goto LABEL_98;
LABEL_105:
          if ( a5 != 2 )
            goto LABEL_98;
LABEL_106:
          if ( v50 )
            goto LABEL_107;
LABEL_98:
          if ( !v12 )
            goto LABEL_99;
          goto LABEL_68;
        default:
          goto LABEL_15;
      }
    }
    else
    {
LABEL_15:
      if ( mb_cur_max == 1 )
      {
        v42 = v12;
        v16 = __ctype_b_loc();
        v12 = v42;
        v53 = 1;
        v49 = ((*v16)[v14] & 0x4000) != 0;
        goto LABEL_17;
      }
      ps.__count = 0;
      ps.__wch = 0;
      if ( a4 == -1 )
      {
        v44 = v12;
        v37 = strlen((const char *)a3);
        v12 = v44;
        a4 = v37;
      }
      v60 = v12;
      v55 = v11;
      v30 = 0;
      v49 = 1;
      v59 = v10;
      v61 = v13;
      while ( 1 )
      {
        v31 = (const char *)(v30 + v55 + a3);
        v32 = mbrtowc(&pwc, v31, a4 - (v30 + v55), &ps);
        v33 = v32;
        if ( !v32 )
        {
LABEL_161:
          v53 = v30;
          v10 = v59;
          v12 = v60;
          v11 = v55;
          goto LABEL_162;
        }
        if ( v32 == -1 )
        {
          v53 = v30;
          v10 = v59;
          v12 = v60;
          v11 = v55;
          v49 = 0;
          goto LABEL_162;
        }
        if ( v32 == -2 )
          break;
        if ( v50 && a5 == 2 && v32 > 1 )
        {
          v36 = 1;
          while ( 2 )
          {
            switch ( v31[v36] )
            {
              case '[':
              case '\\':
              case '^':
              case '`':
              case '|':
                goto LABEL_107;
              default:
                if ( ++v36 == v33 )
                  break;
                continue;
            }
            break;
          }
        }
        v34 = iswprint(pwc);
        v35 = 0;
        if ( v34 )
          v35 = v49;
        v30 += v33;
        v49 = v35;
        if ( mbsinit(&ps) )
          goto LABEL_161;
      }
      v10 = v59;
      v40 = v30 + v55 < a4;
      v53 = v30;
      v12 = v60;
      v11 = v55;
      v49 = 0;
      if ( v40 && *v31 )
      {
        v41 = v53;
        do
          ++v41;
        while ( v41 + v55 < a4 && v61[v41] );
        v10 = v59;
        v53 = v41;
        v49 = 0;
      }
LABEL_162:
      if ( v53 > 1 )
      {
LABEL_19:
        v18 = v14;
        v54 = v11 + v53;
        v19 = v45;
        while ( !v12 || v49 )
        {
          if ( !v19 )
            goto LABEL_29;
          if ( v10 < a2 )
            a1[v10] = 92;
          ++v10;
          v19 = 0;
          if ( v54 <= ++v11 )
          {
LABEL_38:
            v14 = v18;
            goto LABEL_76;
          }
LABEL_30:
          if ( v10 < a2 )
            a1[v10] = v18;
          ++v10;
          v18 = *(_BYTE *)(a3 + v11);
        }
        if ( v50 )
          goto LABEL_107;
        if ( v10 < a2 )
          a1[v10] = 92;
        if ( a2 > v10 + 1 )
          a1[v10 + 1] = (v18 >> 6) + 48;
        if ( a2 > v10 + 2 )
          a1[v10 + 2] = ((v18 >> 3) & 7) + 48;
        v10 += 3;
        v18 = (v18 & 7) + 48;
LABEL_29:
        if ( v54 <= ++v11 )
          goto LABEL_38;
        goto LABEL_30;
      }
LABEL_17:
      if ( v12 )
      {
        v17 = v10;
        if ( !v49 )
          goto LABEL_19;
LABEL_67:
        v10 = v17;
      }
      else
      {
LABEL_99:
        if ( !v50 )
          goto LABEL_70;
      }
LABEL_68:
      if ( !a7 || ((1 << v14) & *(_DWORD *)(a7 + 4 * (v14 >> 5))) == 0 )
      {
LABEL_70:
        if ( !v45 )
          goto LABEL_75;
      }
LABEL_71:
      if ( v50 )
        goto LABEL_107;
      if ( v10 < a2 )
        a1[v10] = 92;
      ++v10;
LABEL_75:
      ++v11;
LABEL_76:
      if ( v10 < a2 )
        a1[v10] = v14;
      ++v10;
    }
  }
  if ( *(_BYTE *)(a3 + v11) )
    goto LABEL_10;
LABEL_135:
  if ( !v10 && a5 == 2 && v50 )
  {
LABEL_107:
    v10 = sub_8055760(a1, a2, a3, a4, a5, a6 & 0xFFFFFFFD, 0, a8, a9);
  }
  else
  {
    if ( s2 )
    {
      if ( !v50 )
      {
        v27 = *s2;
        if ( *s2 )
        {
          v28 = &s2[-v10];
          do
          {
            if ( a2 > v10 )
              a1[v10] = v27;
            v27 = v28[++v10];
          }
          while ( v27 );
        }
      }
    }
    if ( v10 < a2 )
      a1[v10] = 0;
  }
  HIDWORD(result) = __readgsdword(0x14u) ^ v64;
  LODWORD(result) = v10;
  return result;
}

//----- (08056220) --------------------------------------------------------
_BYTE *__usercall sub_8056220@<eax>(unsigned int a1@<eax>, int a2@<edx>, unsigned int a3@<ecx>, int a4)
{
  int *v5; // eax
  _DWORD *v6; // edi
  unsigned int v7; // ebp
  unsigned int *v8; // edi
  _BYTE *v9; // esi
  int v10; // ebp
  unsigned int v11; // eax
  size_t v12; // edx
  _BYTE *v13; // eax
  int v15; // eax
  int c; // [esp+4h] [ebp-58h]
  size_t v17; // [esp+24h] [ebp-38h]
  unsigned int v18; // [esp+24h] [ebp-38h]
  int *v19; // [esp+28h] [ebp-34h]
  unsigned int v20; // [esp+2Ch] [ebp-30h]
  int v23; // [esp+3Ch] [ebp-20h]

  v5 = __errno_location();
  v6 = off_80622D0;
  v19 = v5;
  v23 = *v5;
  if ( (a1 & 0x80000000) != 0 )
    abort();
  if ( a1 >= dword_80622D4 )
  {
    v7 = a1 + 1;
    if ( a1 + 1 > 0x1FFFFFFF )
      sub_8058C00();
    c = 8 * v7;
    if ( off_80622D0 == &dword_80622D8 )
    {
      v6 = sub_8058AA0(0, c);
      off_80622D0 = v6;
      v15 = dword_80622D8;
      v6[1] = off_80622DC;
      *v6 = v15;
    }
    else
    {
      v6 = sub_8058AA0(off_80622D0, c);
      off_80622D0 = v6;
    }
    memset(&v6[2 * dword_80622D4], 0, 8 * (v7 - dword_80622D4));
    dword_80622D4 = a1 + 1;
  }
  v8 = &v6[2 * a1];
  v9 = (_BYTE *)v8[1];
  v10 = *(_DWORD *)(a4 + 4) | 1;
  v20 = *v8;
  v11 = sub_8055760(
          v9,
          *v8,
          a2,
          a3,
          *(_DWORD *)a4,
          v10,
          a4 + 8,
          (char *)*(_DWORD *)(a4 + 40),
          (char *)*(_DWORD *)(a4 + 44));
  if ( v20 <= v11 )
  {
    v12 = v11 + 1;
    *v8 = v11 + 1;
    if ( v9 != (_BYTE *)&unk_8062E00 )
    {
      v17 = v11 + 1;
      free(v9);
      v12 = v17;
    }
    v18 = v12;
    v13 = sub_8058A70(v12);
    v8[1] = (unsigned int)v13;
    v9 = v13;
    sub_8055760(v13, v18, a2, a3, *(_DWORD *)a4, v10, a4 + 8, *(char **)(a4 + 40), *(char **)(a4 + 44));
  }
  *v19 = v23;
  return v9;
}
// 80622D4: using guessed type int dword_80622D4;
// 80622D8: using guessed type int dword_80622D8;
// 80622DC: using guessed type void *off_80622DC;

//----- (080563C0) --------------------------------------------------------
void *__cdecl sub_80563C0(int *a1)
{
  int *v1; // ebx
  int *v2; // eax
  int v3; // edi
  int *v4; // esi
  void *result; // eax

  v1 = a1;
  v2 = __errno_location();
  v3 = *v2;
  v4 = v2;
  if ( !a1 )
    v1 = &dword_8062DC0;
  result = sub_8058BA0(v1, 0x30u);
  *v4 = v3;
  return result;
}
// 8062DC0: using guessed type int dword_8062DC0;

//----- (08056410) --------------------------------------------------------
int __cdecl sub_8056410(int *a1)
{
  int *v1; // eax

  v1 = a1;
  if ( !a1 )
    v1 = &dword_8062DC0;
  return *v1;
}
// 8062DC0: using guessed type int dword_8062DC0;

//----- (08056430) --------------------------------------------------------
int *__cdecl sub_8056430(int *a1, int a2)
{
  int *result; // eax

  result = a1;
  if ( !a1 )
    result = &dword_8062DC0;
  *result = a2;
  return result;
}
// 8062DC0: using guessed type int dword_8062DC0;

//----- (08056450) --------------------------------------------------------
unsigned int __cdecl sub_8056450(int *a1, unsigned __int8 a2, char a3)
{
  int *v3; // ebx
  int v4; // esi
  unsigned int result; // eax

  v3 = a1;
  if ( !a1 )
    v3 = &dword_8062DC0;
  v4 = a2 >> 5;
  result = ((unsigned int)v3[v4 + 2] >> (a2 & 0x1F)) & 1;
  v3[v4 + 2] ^= (result ^ a3 & 1) << (a2 & 0x1F);
  return result;
}
// 8062DC0: using guessed type int dword_8062DC0;

//----- (080564D0) --------------------------------------------------------
int *__cdecl sub_80564D0(int *a1, int a2, int a3)
{
  int *result; // eax

  result = a1;
  if ( !a1 )
    result = &dword_8062DC0;
  *result = 8;
  if ( !a3 || !a2 )
    abort();
  result[10] = a2;
  result[11] = a3;
  return result;
}
// 8062DC0: using guessed type int dword_8062DC0;

//----- (08056510) --------------------------------------------------------
__int64 __cdecl sub_8056510(_BYTE *a1, unsigned int a2, int a3, unsigned int a4, int *a5)
{
  int *v5; // edi
  int *v6; // eax
  int v7; // esi
  int *v8; // ebx
  __int64 result; // rax

  v5 = &dword_8062DC0;
  if ( a5 )
    v5 = a5;
  v6 = __errno_location();
  v7 = *v6;
  v8 = v6;
  result = sub_8055760(a1, a2, a3, a4, *v5, v5[1], (int)(v5 + 2), (char *)v5[10], (char *)v5[11]);
  *v8 = v7;
  return result;
}
// 8062DC0: using guessed type int dword_8062DC0;

//----- (08056590) --------------------------------------------------------
_BYTE *__cdecl sub_8056590(int a1, unsigned int a2, _DWORD *a3, int *a4)
{
  int *v4; // ebx
  int v5; // esi
  int v6; // eax
  unsigned int v7; // edi
  int *v9; // [esp+20h] [ebp-2Ch]
  _BYTE *v10; // [esp+24h] [ebp-28h]
  int v11; // [esp+28h] [ebp-24h]
  int v12; // [esp+2Ch] [ebp-20h]

  v4 = &dword_8062DC0;
  if ( a4 )
    v4 = a4;
  v9 = __errno_location();
  v12 = *v9;
  v5 = (a3 == 0) | v4[1];
  v6 = sub_8055760(0, 0, a1, a2, *v4, v5, (int)(v4 + 2), (char *)v4[10], (char *)v4[11]);
  v7 = v6 + 1;
  v11 = v6;
  v10 = sub_8058A70(v6 + 1);
  sub_8055760(v10, v7, a1, a2, *v4, v5, (int)(v4 + 2), (char *)v4[10], (char *)v4[11]);
  *v9 = v12;
  if ( a3 )
    *a3 = v11;
  return v10;
}
// 8062DC0: using guessed type int dword_8062DC0;

//----- (08056740) --------------------------------------------------------
_BYTE *__cdecl sub_8056740(int a1, int a2)
{
  return sub_8056220(a1, a2, 0xFFFFFFFF, (int)&dword_8062DC0);
}
// 8062DC0: using guessed type int dword_8062DC0;

//----- (08056760) --------------------------------------------------------
_BYTE *__cdecl sub_8056760(int a1, int a2, unsigned int a3)
{
  return sub_8056220(a1, a2, a3, (int)&dword_8062DC0);
}
// 8062DC0: using guessed type int dword_8062DC0;

//----- (08056780) --------------------------------------------------------
_BYTE *__cdecl sub_8056780(int a1)
{
  return sub_8056740(0, a1);
}

//----- (080567D0) --------------------------------------------------------
_BYTE *__cdecl sub_80567D0(int a1, int a2, int a3)
{
  int v4[15]; // [esp+10h] [ebp-3Ch] BYREF

  sub_80556E0(v4, a2);
  return sub_8056220(a1, a3, 0xFFFFFFFF, (int)v4);
}
// 80567D0: using guessed type _DWORD var_3C[15];

//----- (08056800) --------------------------------------------------------
_BYTE *__cdecl sub_8056800(int a1, int a2, int a3, unsigned int a4)
{
  int v5[15]; // [esp+10h] [ebp-3Ch] BYREF

  sub_80556E0(v5, a2);
  return sub_8056220(a1, a3, a4, (int)v5);
}
// 8056800: using guessed type _DWORD var_3C[15];

//----- (08056890) --------------------------------------------------------
_BYTE *__cdecl sub_8056890(int a1, unsigned int a2, unsigned __int8 a3)
{
  int v4[2]; // [esp+10h] [ebp-3Ch] BYREF
  int v5[13]; // [esp+18h] [ebp-34h]

  v4[0] = dword_8062DC0;
  v4[1] = dword_8062DC4;
  v5[0] = dword_8062DC8;
  v5[1] = dword_8062DCC;
  v5[2] = dword_8062DD0;
  v5[3] = dword_8062DD4;
  v5[4] = dword_8062DD8;
  v5[5] = dword_8062DDC;
  v5[6] = dword_8062DE0;
  v5[7] = dword_8062DE4;
  v5[8] = dword_8062DE8;
  v5[9] = dword_8062DEC;
  v5[a3 >> 5] ^= !(((unsigned int)v5[a3 >> 5] >> (a3 & 0x1F)) & 1) << (a3 & 0x1F);
  return sub_8056220(0, a1, a2, (int)v4);
}
// 8062DC0: using guessed type int dword_8062DC0;
// 8062DC4: using guessed type int dword_8062DC4;
// 8062DC8: using guessed type int dword_8062DC8;
// 8062DCC: using guessed type int dword_8062DCC;
// 8062DD0: using guessed type int dword_8062DD0;
// 8062DD4: using guessed type int dword_8062DD4;
// 8062DD8: using guessed type int dword_8062DD8;
// 8062DDC: using guessed type int dword_8062DDC;
// 8062DE0: using guessed type int dword_8062DE0;
// 8062DE4: using guessed type int dword_8062DE4;
// 8062DE8: using guessed type int dword_8062DE8;
// 8062DEC: using guessed type int dword_8062DEC;

//----- (08056950) --------------------------------------------------------
_BYTE *__cdecl sub_8056950(int a1, unsigned __int8 a2)
{
  return sub_8056890(a1, 0xFFFFFFFF, a2);
}

//----- (08056980) --------------------------------------------------------
_BYTE *__cdecl sub_8056980(int a1)
{
  return sub_8056950(a1, 0x3Au);
}

//----- (080569D0) --------------------------------------------------------
_BYTE *__cdecl sub_80569D0(int a1, int a2, int a3, int a4, unsigned int a5)
{
  int v6[15]; // [esp+10h] [ebp-3Ch] BYREF

  v6[0] = dword_8062DC0;
  v6[1] = dword_8062DC4;
  v6[2] = dword_8062DC8;
  v6[3] = dword_8062DCC;
  v6[4] = dword_8062DD0;
  v6[5] = dword_8062DD4;
  v6[6] = dword_8062DD8;
  v6[7] = dword_8062DDC;
  v6[8] = dword_8062DE0;
  v6[9] = dword_8062DE4;
  v6[10] = dword_8062DE8;
  v6[11] = dword_8062DEC;
  sub_80564D0(v6, a2, a3);
  return sub_8056220(a1, a4, a5, (int)v6);
}
// 8062DC0: using guessed type int dword_8062DC0;
// 8062DC4: using guessed type int dword_8062DC4;
// 8062DC8: using guessed type int dword_8062DC8;
// 8062DCC: using guessed type int dword_8062DCC;
// 8062DD0: using guessed type int dword_8062DD0;
// 8062DD4: using guessed type int dword_8062DD4;
// 8062DD8: using guessed type int dword_8062DD8;
// 8062DDC: using guessed type int dword_8062DDC;
// 8062DE0: using guessed type int dword_8062DE0;
// 8062DE4: using guessed type int dword_8062DE4;
// 8062DE8: using guessed type int dword_8062DE8;
// 8062DEC: using guessed type int dword_8062DEC;

//----- (08056A80) --------------------------------------------------------
_BYTE *__cdecl sub_8056A80(int a1, int a2, int a3, int a4)
{
  return sub_80569D0(a1, a2, a3, a4, 0xFFFFFFFF);
}

//----- (08056B30) --------------------------------------------------------
int __usercall sub_8056B30@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>)
{
  int v3; // edi
  const __int32_t **v6; // eax

  v3 = a3;
  if ( a3 )
  {
    v6 = __ctype_toupper_loc();
    do
    {
      *(_BYTE *)(a1 + v3 - 1) = (*v6)[*(unsigned __int8 *)(a2 + v3 - 1)];
      --v3;
    }
    while ( v3 );
  }
  return a1;
}

//----- (08056B70) --------------------------------------------------------
__int64 __usercall sub_8056B70@<edx:eax>(
        char a1@<al>,
        char *a2@<edx>,
        int a3@<ecx>,
        char *a4,
        const struct tm *tp,
        int a6,
        int a7)
{
  char *v7; // ebx
  char v8; // al
  char *v9; // ebp
  char v10; // dl
  char v11; // cl
  int v12; // edi
  int v13; // esi
  char v14; // al
  char *v15; // edi
  __int64 result; // rax
  int v17; // eax
  char v18; // cl
  char v19; // al
  char *v20; // edx
  size_t v21; // eax
  size_t v22; // ebx
  size_t v23; // edi
  unsigned int v24; // eax
  unsigned int v25; // edx
  size_t v26; // esi
  char *v27; // eax
  int v28; // edx
  unsigned int v29; // eax
  unsigned int v30; // ebx
  size_t v31; // esi
  char *p_IO_save_base; // ebp
  unsigned int v33; // edi
  unsigned int v34; // eax
  unsigned int v35; // edx
  int v36; // ecx
  size_t v37; // esi
  char v38; // cl
  char v39; // cl
  int tm_gmtoff; // ebp
  int v41; // edx
  int v42; // ecx
  char *p_format; // edi
  char *v44; // ecx
  unsigned int v45; // edx
  bool v46; // zf
  int v47; // ecx
  int v48; // edx
  signed int v49; // ecx
  unsigned int v50; // eax
  unsigned int v51; // eax
  unsigned int v52; // ebx
  size_t v53; // esi
  unsigned int v54; // ebx
  char *v55; // edx
  size_t v56; // esi
  char v57; // al
  char *v58; // ecx
  int tm_min; // ecx
  int v60; // eax
  int v61; // ebp
  char v62; // cl
  int tm_year; // edi
  int k; // ebp
  int v65; // ebp
  __int64 v66; // rax
  int v67; // ebp
  int v68; // eax
  int v69; // eax
  unsigned int v70; // eax
  unsigned int v71; // edi
  size_t v72; // esi
  int tm_mon; // eax
  unsigned int v74; // eax
  size_t v75; // esi
  time_t v76; // ecx
  bool v77; // bl
  int v78; // eax
  char v79; // dl
  char v80; // al
  unsigned int v81; // eax
  char v82; // dl
  size_t v83; // esi
  char v84; // cl
  bool v85; // bp
  size_t v86; // edi
  unsigned int v87; // eax
  unsigned int v88; // edx
  size_t v89; // esi
  int v90; // eax
  unsigned int v91; // ecx
  size_t v92; // eax
  const __int32_t **v93; // eax
  size_t j; // ebx
  char *v95; // edx
  int v96; // ebp
  const __int32_t **v97; // eax
  size_t v98; // edx
  int v99; // eax
  int v100; // ebp
  signed int v101; // [esp+1Ch] [ebp-4D0h]
  signed int v102; // [esp+1Ch] [ebp-4D0h]
  unsigned int v103; // [esp+1Ch] [ebp-4D0h]
  signed int v104; // [esp+1Ch] [ebp-4D0h]
  unsigned int v105; // [esp+1Ch] [ebp-4D0h]
  char v106; // [esp+20h] [ebp-4CCh]
  char v107; // [esp+20h] [ebp-4CCh]
  char v108; // [esp+20h] [ebp-4CCh]
  char v109; // [esp+20h] [ebp-4CCh]
  size_t n; // [esp+28h] [ebp-4C4h]
  char na; // [esp+28h] [ebp-4C4h]
  size_t nb; // [esp+28h] [ebp-4C4h]
  char nc; // [esp+28h] [ebp-4C4h]
  size_t nd; // [esp+28h] [ebp-4C4h]
  int ne; // [esp+28h] [ebp-4C4h]
  size_t nf; // [esp+28h] [ebp-4C4h]
  size_t ng; // [esp+28h] [ebp-4C4h]
  size_t nh; // [esp+28h] [ebp-4C4h]
  int v120; // [esp+30h] [ebp-4BCh]
  char *v121; // [esp+34h] [ebp-4B8h]
  unsigned int v122; // [esp+34h] [ebp-4B8h]
  int v123; // [esp+34h] [ebp-4B8h]
  int v125; // [esp+3Ch] [ebp-4B0h]
  unsigned int v126; // [esp+3Ch] [ebp-4B0h]
  char i; // [esp+40h] [ebp-4ACh]
  char v128; // [esp+40h] [ebp-4ACh]
  int v129; // [esp+50h] [ebp-49Ch]
  int tm_hour; // [esp+58h] [ebp-494h]
  int v131; // [esp+58h] [ebp-494h]
  bool v133; // [esp+60h] [ebp-48Ch]
  int v134; // [esp+60h] [ebp-48Ch]
  int v135; // [esp+70h] [ebp-47Ch]
  int tm_yday; // [esp+70h] [ebp-47Ch]
  char *tm_zone; // [esp+74h] [ebp-478h]
  unsigned __int8 v138; // [esp+78h] [ebp-474h]
  int tm_wday; // [esp+78h] [ebp-474h]
  struct tm v140; // [esp+8Ch] [ebp-460h] BYREF
  char s; // [esp+B9h] [ebp-433h] BYREF
  char src[1037]; // [esp+BAh] [ebp-432h] BYREF
  char format; // [esp+4C7h] [ebp-25h] BYREF
  char v144; // [esp+4C8h] [ebp-24h]
  char v145; // [esp+4C9h] [ebp-23h] BYREF
  char v146; // [esp+4CAh] [ebp-22h] BYREF
  unsigned int v147; // [esp+4CCh] [ebp-20h]

  v7 = a4;
  v147 = __readgsdword(0x14u);
  tm_hour = tp->tm_hour;
  tm_zone = (char *)tp->tm_zone;
  if ( tm_hour <= 12 )
  {
    v17 = 12;
    if ( tm_hour )
      v17 = tp->tm_hour;
    v131 = v17;
  }
  else
  {
    v131 = tm_hour - 12;
  }
  v8 = *a4;
  v120 = 0;
  if ( !*a4 )
  {
LABEL_62:
    if ( a2 && a3 )
      *a2 = 0;
    goto LABEL_36;
  }
  while ( 2 )
  {
    while ( v8 != 37 )
    {
      if ( (unsigned int)(a3 - v120) <= 1 )
        goto LABEL_35;
      if ( a2 )
        *a2++ = v8;
      ++v120;
      v9 = v7;
LABEL_9:
      v8 = v9[1];
      v7 = v9 + 1;
      if ( !v8 )
        goto LABEL_62;
    }
    v10 = 0;
    v129 = 0;
    for ( i = a1; ; i = 1 )
    {
      while ( 1 )
      {
        v11 = *++v7;
        if ( *v7 == 48 )
          goto LABEL_25;
        if ( v11 > 48 )
          break;
        if ( v11 == 35 )
        {
          v10 = 1;
        }
        else
        {
          if ( v11 != 45 )
            goto LABEL_16;
LABEL_25:
          v129 = v11;
        }
      }
      if ( v11 != 94 )
        break;
    }
    if ( v11 == 95 )
      goto LABEL_25;
LABEL_16:
    v12 = v11;
    v13 = -1;
    if ( (unsigned int)(v11 - 48) <= 9 )
    {
      v13 = 0;
      do
      {
        if ( v13 <= 214748364 )
        {
          v14 = *v7;
          if ( v13 == 214748364 && v14 > 55 )
            v13 = 0x7FFFFFFF;
          else
            v13 = v14 + 10 * v13 - 48;
        }
        else
        {
          v13 = 0x7FFFFFFF;
        }
        v11 = *++v7;
        v12 = *v7;
      }
      while ( (unsigned int)(v12 - 48) <= 9 );
    }
    if ( v11 == 69 || v11 == 79 )
    {
      v11 = *++v7;
      v125 = v12;
      LOBYTE(v12) = v11;
    }
    else
    {
      v125 = 0;
    }
    switch ( v11 )
    {
      case 0:
        v15 = v7 - 1;
        v11 = *(v7 - 1);
        goto LABEL_30;
      case 37:
        if ( v125 )
        {
          v9 = v7;
          v15 = v7;
          n = 1;
          goto LABEL_76;
        }
        v81 = 0;
        v71 = 1;
        if ( v13 >= 0 )
          v81 = v13;
        if ( v81 )
          v71 = v81;
        if ( v71 < a3 - v120 )
        {
          if ( a2 )
          {
            v82 = 37;
            if ( v81 > 1 )
            {
              v83 = v13 - 1;
              if ( v129 == 48 )
                memset(a2, 48, v83);
              else
                memset(a2, 32, v83);
              v82 = *v7;
              a2 += v83;
            }
            *a2++ = v82;
          }
LABEL_226:
          v120 += v71;
          v9 = v7;
          goto LABEL_9;
        }
        goto LABEL_35;
      case 58:
        v57 = v7[1];
        if ( v57 == 58 )
        {
          v95 = v7 + 2;
          v96 = 1;
          do
          {
            v58 = v95++;
            v57 = *(v95 - 1);
            ++v96;
          }
          while ( v57 == 58 );
          nd = v96;
        }
        else
        {
          v58 = v7 + 1;
          nd = 1;
        }
        if ( v57 != 122 )
          goto LABEL_73;
        v7 = v58;
        goto LABEL_114;
      case 65:
      case 66:
      case 97:
        if ( v125 )
          goto LABEL_73;
        v18 = i;
        if ( v10 )
          v18 = 1;
        i = v18;
        goto LABEL_47;
      case 67:
        if ( v125 == 79 )
          goto LABEL_73;
        if ( v125 != 69 )
        {
          ne = 0;
          v138 = 0;
          v135 = 2;
          tm_year = tp->tm_year;
          v133 = tm_year < -1900;
          v122 = tm_year / 100 + 19 - (((unsigned int)(tm_year % 100) >> 31) & (tm_year / 100 + 19 > 0));
LABEL_119:
          v9 = v7;
          if ( v133 )
          {
LABEL_295:
            v122 = -v122;
            v9 = v7;
          }
          p_format = &format;
          do
          {
            v44 = p_format;
            if ( (ne & 1) != 0 )
            {
              v44 = p_format - 1;
              *(p_format - 1) = 58;
            }
            p_format = v44 - 1;
            v45 = v122 / 0xA;
            v46 = ne >> 1 == 0;
            ne >>= 1;
            *(v44 - 1) = v122 % 0xA + 48;
            v122 /= 0xAu;
          }
          while ( !v46 || v45 );
LABEL_125:
          v47 = v135;
          LOBYTE(v48) = 45;
          if ( v13 >= v135 )
            v47 = v13;
          v126 = v47;
          if ( !v133 )
            v48 = -v138 & 0x2B;
          if ( v129 == 45 )
          {
            v54 = 0;
            if ( v13 >= 0 )
              v54 = v13;
            if ( (_BYTE)v48 )
            {
LABEL_300:
              v91 = 1;
              if ( v54 )
                v91 = v54;
              if ( v91 >= a3 - v120 )
                goto LABEL_35;
              if ( !a2 )
                goto LABEL_309;
              if ( v54 <= 1 || v126 )
              {
LABEL_308:
                *a2++ = v48;
LABEL_309:
                v120 += v91;
                goto LABEL_149;
              }
              v92 = v13 - 1;
              nh = v13 - 1;
LABEL_307:
              v107 = v48;
              v103 = v91;
              memset(a2, 32, v92);
              a2 += nh;
              v91 = v103;
              LOBYTE(v48) = v107;
              goto LABEL_308;
            }
          }
          else
          {
            v49 = v47 + p_format - &format - ((_BYTE)v48 != 0);
            if ( v49 <= 0 )
            {
              v54 = 0;
              if ( v13 >= 0 )
                v54 = v13;
              if ( (_BYTE)v48 )
              {
                v91 = 1;
                if ( v54 )
                  v91 = v54;
                if ( v91 >= a3 - v120 )
                  goto LABEL_35;
                if ( !a2 )
                  goto LABEL_309;
                if ( v54 <= 1 || v126 )
                  goto LABEL_308;
                nh = v13 - 1;
                if ( v129 == 48 )
                {
                  v109 = v48;
                  v105 = v91;
                  memset(a2, 48, v13 - 1);
                  a2 += nh;
                  LOBYTE(v48) = v109;
                  v91 = v105;
                  goto LABEL_308;
                }
                v92 = v13 - 1;
                goto LABEL_307;
              }
            }
            else
            {
              v50 = a3 - v120;
              if ( v129 != 95 )
              {
                if ( v126 >= v50 )
                  goto LABEL_35;
                if ( (_BYTE)v48 )
                {
                  v51 = 0;
                  if ( v13 >= 0 )
                    v51 = v13;
                  v52 = 1;
                  if ( v51 )
                    v52 = v51;
                  if ( a3 - v120 <= v52 )
                    goto LABEL_35;
                  if ( a2 )
                  {
                    if ( v51 > 1 && !v126 )
                    {
                      v53 = v13 - 1;
                      v106 = v48;
                      v101 = v49;
                      if ( v129 == 48 )
                      {
                        memset(a2, 48, v53);
                        LOBYTE(v48) = v106;
                        a2 += v53;
                        v49 = v101;
                      }
                      else
                      {
                        memset(a2, 32, v53);
                        v49 = v101;
                        a2 += v53;
                        LOBYTE(v48) = v106;
                      }
                    }
                    *a2++ = v48;
                  }
                  v120 += v52;
                }
                if ( a2 )
                {
                  v102 = v49;
                  memset(a2, 48, v49);
                  v49 = v102;
                  a2 += v102;
                }
                v120 += v49;
                v54 = 0;
                v13 = 0;
                goto LABEL_149;
              }
              if ( v49 >= v50 )
                goto LABEL_35;
              if ( a2 )
              {
                v108 = v48;
                v104 = v49;
                memset(a2, 32, v49);
                v49 = v104;
                a2 += v104;
                LOBYTE(v48) = v108;
              }
              v120 += v49;
              v54 = 0;
              if ( v13 <= v49 )
              {
                v13 = 0;
              }
              else
              {
                v13 -= v49;
                if ( v13 >= 0 )
                  v54 = v13;
              }
              if ( (_BYTE)v48 )
                goto LABEL_300;
            }
          }
LABEL_149:
          v55 = (char *)(&format - p_format);
          nf = &format - p_format;
          if ( &format - p_format < v54 )
            v55 = (char *)v54;
          v121 = v55;
          if ( (unsigned int)v55 < a3 - v120 )
          {
            if ( a2 )
            {
              if ( v54 > nf && !v126 )
              {
                v56 = v13 - nf;
                if ( v129 == 48 )
                  memset(a2, 48, v56);
                else
                  memset(a2, 32, v56);
                a2 += v56;
              }
              if ( i )
                sub_8056B30((int)a2, (int)p_format, nf);
              else
                memcpy(a2, p_format, nf);
              a2 += nf;
            }
            goto LABEL_61;
          }
          goto LABEL_35;
        }
        format = 32;
        v19 = v12;
        v9 = v7;
        v144 = 37;
        na = 0;
        v135 = 0;
LABEL_68:
        v145 = v125;
        v20 = &v146;
LABEL_48:
        *v20 = v19;
        v20[1] = 0;
        v21 = strftime(&s, 0x400u, &format, tp);
        v22 = v21;
        if ( !v21 )
          goto LABEL_9;
        v23 = v21 - 1;
        v24 = 0;
        v25 = v23;
        if ( v13 >= 0 )
          v24 = v13;
        if ( v24 >= v23 )
          v25 = v24;
        v121 = (char *)v25;
        if ( v25 < a3 - v120 )
        {
          if ( a2 )
          {
            if ( v23 < v24 && !v135 )
            {
              v26 = v13 - v23;
              if ( v129 == 48 )
                memset(a2, 48, v26);
              else
                memset(a2, 32, v26);
              a2 += v26;
            }
            if ( na )
            {
              if ( v23 )
              {
                v93 = __ctype_tolower_loc();
                for ( j = v22 - 2; ; --j )
                {
                  a2[j] = (*v93)[(unsigned __int8)src[j]];
                  if ( !j )
                    break;
                }
              }
            }
            else if ( i )
            {
              sub_8056B30((int)a2, (int)src, v23);
            }
            else
            {
              memcpy(a2, src, v23);
            }
            a2 += v23;
          }
LABEL_61:
          v8 = v9[1];
          v7 = v9 + 1;
          v120 += (int)v121;
          if ( !v8 )
            goto LABEL_62;
          continue;
        }
LABEL_35:
        v120 = 0;
LABEL_36:
        HIDWORD(result) = __readgsdword(0x14u) ^ v147;
        LODWORD(result) = v120;
        return result;
      case 68:
        p_IO_save_base = (char *)&stru_805D800._IO_save_base;
        if ( v125 )
          goto LABEL_73;
        goto LABEL_94;
      case 70:
        p_IO_save_base = (char *)&stru_805D800._IO_save_end + 1;
        if ( v125 )
          goto LABEL_73;
        goto LABEL_94;
      case 71:
      case 86:
      case 103:
        if ( v125 == 69 )
          goto LABEL_73;
        v123 = tp->tm_year;
        v134 = ((v123 >> 31) & 0x190) + v123 - 100;
        tm_yday = tp->tm_yday;
        tm_wday = tp->tm_wday;
        v67 = tm_wday - 382 + 7 * ((tm_yday - tm_wday + 382) / 7) + 3;
        if ( v67 < 0 )
        {
          v99 = 365;
          v100 = ((tp->tm_year >> 31) & 0x190) + tp->tm_year - 101;
          if ( (v100 & 3) == 0 )
          {
            v99 = 366;
            if ( v100 == 100 * (v100 / 100) )
              v99 = 366 - (v100 != 400 * (v100 / 400));
          }
          ng = -1;
          v67 = tm_wday - 382 + 7 * ((tm_yday + v99 - tm_wday + 382) / 7) + 3;
        }
        else
        {
          v68 = -365;
          if ( (v134 & 3) == 0 )
          {
            v68 = -366;
            if ( v134 == 100 * (v134 / 100) )
              v68 = -(v134 == 400 * (v134 / 400)) - 365;
          }
          v69 = tm_wday - 382 + 7 * ((tm_yday + v68 - tm_wday + 382) / 7) + 3;
          ng = (v69 >> 31) + 1;
          if ( v69 >= 0 )
            v67 = v69;
        }
        if ( v11 == 71 )
        {
          v138 = 0;
          v133 = v123 < (int)(-1900 - ng);
          v122 = ng + v123 + 1900;
          ne = 0;
          v135 = 4;
          goto LABEL_118;
        }
        if ( v11 == 103 )
        {
          v135 = 2;
          tm_min = (int)(ng + v123 % 100) % 100;
          if ( tm_min < 0 )
          {
            tm_min += 100;
            if ( v123 < (int)(-1900 - ng) )
              tm_min = -((int)(ng + v123 % 100) % 100);
          }
        }
        else
        {
          v135 = 2;
          tm_min = v67 / 7 + 1;
        }
        goto LABEL_171;
      case 72:
        if ( v125 == 69 )
          goto LABEL_73;
        v135 = 2;
        tm_min = tp->tm_hour;
        goto LABEL_171;
      case 73:
        if ( v125 == 69 )
          goto LABEL_73;
        tm_min = v131;
        v135 = 2;
        goto LABEL_171;
      case 77:
        if ( v125 == 69 )
          goto LABEL_73;
        tm_min = tp->tm_min;
        goto LABEL_200;
      case 78:
        if ( v125 == 69 )
          goto LABEL_73;
        tm_min = a7;
        if ( v13 == -1 )
        {
          v13 = 9;
          v135 = 9;
        }
        else
        {
          v135 = v13;
          if ( v13 <= 8 )
          {
            for ( k = v13; k != 9; ++k )
              tm_min /= 10;
            v135 = v13;
          }
        }
        goto LABEL_171;
      case 80:
        v19 = 112;
        nc = 1;
        goto LABEL_107;
      case 82:
        p_IO_save_base = "%m-%d %H:%M" + 6;
        goto LABEL_94;
      case 83:
        if ( v125 == 69 )
          goto LABEL_73;
        v135 = 2;
        tm_min = tp->tm_sec;
        goto LABEL_171;
      case 84:
        p_IO_save_base = (char *)&stru_805D800._chain + 2;
LABEL_94:
        v33 = sub_8056B70(i, 0, -1, p_IO_save_base, tp, a6, a7);
        v34 = 0;
        if ( v13 >= 0 )
          v34 = v13;
        v35 = v34;
        if ( v33 >= v34 )
          v35 = v33;
        v36 = a3 - v120;
        nb = v35;
        if ( v35 >= a3 - v120 )
          goto LABEL_35;
        if ( a2 )
        {
          if ( v33 < v34 )
          {
            v37 = v13 - v33;
            if ( v129 == 48 )
              memset(a2, 48, v37);
            else
              memset(a2, 32, v37);
            v36 = a3 - v120;
            a2 += v37;
          }
          sub_8056B70(i, a2, v36, p_IO_save_base, tp, a6, a7);
          a2 += v33;
        }
LABEL_105:
        v9 = v7;
        v120 += nb;
        goto LABEL_9;
      case 85:
        if ( v125 == 69 )
          goto LABEL_73;
        v65 = tp->tm_yday - tp->tm_wday + 7;
        v66 = -1840700269LL * v65;
        goto LABEL_199;
      case 87:
        if ( v125 == 69 )
          goto LABEL_73;
        v65 = 7 * ((tp->tm_wday + 6) / 7) - (tp->tm_wday + 6) + tp->tm_yday + 7;
        v66 = -1840700269LL * v65;
LABEL_199:
        tm_min = ((HIDWORD(v66) + v65) >> 2) - (v65 >> 31);
        goto LABEL_200;
      case 88:
      case 99:
      case 120:
        if ( v125 != 79 )
          goto LABEL_66;
        goto LABEL_73;
      case 89:
        if ( v125 == 69 )
          goto LABEL_337;
        if ( v125 == 79 )
          goto LABEL_73;
        ne = 0;
        v138 = 0;
        v135 = 4;
        v90 = tp->tm_year;
        v133 = v90 < -1900;
        v122 = v90 + 1900;
        goto LABEL_119;
      case 90:
        v84 = i;
        v85 = v10 != 0;
        if ( v10 )
          v84 = 0;
        v128 = v84;
        if ( tm_zone )
        {
          v86 = strlen(tm_zone);
        }
        else
        {
          v86 = 0;
          tm_zone = (char *)"";
        }
        v87 = 0;
        if ( v13 >= 0 )
          v87 = v13;
        v88 = v87;
        if ( v86 >= v87 )
          v88 = v86;
        nb = v88;
        if ( v88 >= a3 - v120 )
          goto LABEL_35;
        if ( a2 )
        {
          if ( v87 > v86 )
          {
            v89 = v13 - v86;
            if ( v129 == 48 )
              memset(a2, 48, v89);
            else
              memset(a2, 32, v89);
            a2 += v89;
          }
          if ( v85 )
          {
            if ( v86 )
            {
              v97 = __ctype_tolower_loc();
              v98 = v86;
              do
              {
                a2[v98 - 1] = (*v97)[(unsigned __int8)tm_zone[v98 - 1]];
                --v98;
              }
              while ( v98 );
            }
          }
          else if ( v128 )
          {
            sub_8056B30((int)a2, (int)tm_zone, v86);
          }
          else
          {
            memcpy(a2, tm_zone, v86);
          }
          a2 += v86;
        }
        goto LABEL_105;
      case 98:
      case 104:
        v62 = i;
        if ( v10 )
          v62 = 1;
        i = v62;
        if ( v125 )
          goto LABEL_73;
LABEL_47:
        format = 32;
        v19 = v12;
        v9 = v7;
        v144 = 37;
        v20 = &v145;
        na = 0;
        v135 = 0;
        goto LABEL_48;
      case 100:
        if ( v125 == 69 )
          goto LABEL_73;
        v135 = 2;
        tm_min = tp->tm_mday;
        goto LABEL_171;
      case 101:
        if ( v125 == 69 )
          goto LABEL_73;
        tm_min = tp->tm_mday;
        goto LABEL_168;
      case 106:
        if ( v125 == 69 )
          goto LABEL_73;
        ne = 0;
        v138 = 0;
        v135 = 3;
        v60 = tp->tm_yday;
        v133 = v60 < -1;
        v122 = v60 + 1;
        goto LABEL_118;
      case 107:
        if ( v125 == 69 )
          goto LABEL_73;
        tm_min = tp->tm_hour;
LABEL_168:
        if ( v129 == 45 || v129 == 48 )
        {
LABEL_200:
          v135 = 2;
        }
        else
        {
          v135 = 2;
          v129 = 95;
        }
        goto LABEL_171;
      case 108:
        tm_min = v131;
        if ( v125 == 69 )
          goto LABEL_73;
        goto LABEL_168;
      case 109:
        if ( v125 == 69 )
          goto LABEL_73;
        ne = 0;
        v138 = 0;
        v135 = 2;
        tm_mon = tp->tm_mon;
        v133 = tm_mon < -1;
        v122 = tm_mon + 1;
        goto LABEL_118;
      case 110:
        v70 = 0;
        if ( v13 >= 0 )
          v70 = v13;
        v71 = 1;
        if ( v70 )
          v71 = v70;
        if ( v71 >= a3 - v120 )
          goto LABEL_35;
        if ( a2 )
        {
          if ( v70 > 1 )
          {
            v72 = v13 - 1;
            if ( v129 == 48 )
              memset(a2, 48, v72);
            else
              memset(a2, 32, v72);
            a2 += v72;
          }
          *a2++ = 10;
        }
        goto LABEL_226;
      case 112:
        v19 = v12;
        nc = 0;
LABEL_107:
        v38 = i;
        if ( v10 )
          v38 = 0;
        i = v38;
        v39 = nc;
        if ( v10 )
          v39 = 1;
        na = v39;
        goto LABEL_67;
      case 114:
LABEL_66:
        v19 = v12;
        na = 0;
LABEL_67:
        v9 = v7;
        format = 32;
        v20 = &v145;
        v144 = 37;
        v135 = 0;
        if ( v125 )
          goto LABEL_68;
        goto LABEL_48;
      case 115:
        v9 = v7;
        p_format = &format;
        v140 = *tp;
        v76 = mktime(&v140);
        v133 = v76 < 0;
        v77 = v76 < 0;
        do
        {
          --p_format;
          v78 = v76 % 10;
          v76 /= 10;
          v79 = 48 - v78;
          v80 = v78 + 48;
          if ( !v77 )
            v79 = v80;
          *p_format = v79;
        }
        while ( v76 );
        v138 = 0;
        v135 = 1;
        goto LABEL_125;
      case 116:
        v74 = 0;
        if ( v13 >= 0 )
          v74 = v13;
        v71 = 1;
        if ( v74 )
          v71 = v74;
        if ( v71 >= a3 - v120 )
          goto LABEL_35;
        if ( a2 )
        {
          if ( v74 > 1 )
          {
            v75 = v13 - 1;
            if ( v129 == 48 )
              memset(a2, 48, v75);
            else
              memset(a2, 32, v75);
            a2 += v75;
          }
          *a2++ = 9;
        }
        goto LABEL_226;
      case 117:
        v135 = 1;
        tm_min = (tp->tm_wday + 6) % 7 + 1;
        goto LABEL_171;
      case 119:
        if ( v125 == 69 )
          goto LABEL_73;
        v135 = 1;
        tm_min = tp->tm_wday;
        goto LABEL_171;
      case 121:
        if ( v125 == 69 )
        {
LABEL_337:
          v135 = 0;
          goto LABEL_173;
        }
        v135 = 2;
        v61 = tp->tm_year;
        tm_min = v61 % 100;
        if ( v61 % 100 < 0 )
        {
          tm_min += 100;
          if ( v61 <= -1901 )
            tm_min = -(v61 % 100);
        }
LABEL_171:
        v133 = tm_min < 0;
        v122 = tm_min;
        ne = 0;
        v138 = 0;
        if ( v125 != 79 )
          goto LABEL_119;
        goto LABEL_172;
      case 122:
        nd = 0;
LABEL_114:
        if ( tp->tm_isdst < 0 )
        {
          v9 = v7;
          goto LABEL_9;
        }
        tm_gmtoff = tp->tm_gmtoff;
        v122 = tm_gmtoff / 3600;
        v41 = tm_gmtoff / 60 % 60;
        v42 = tm_gmtoff % 60;
        if ( nd == 1 )
          goto LABEL_359;
        if ( nd )
        {
          if ( nd == 2 )
            goto LABEL_349;
          if ( nd != 3 )
          {
            v11 = *v7;
            v15 = v7;
LABEL_30:
            if ( v11 == 37 )
            {
              v9 = v15;
              n = 1;
            }
            else
            {
              v7 = v15;
LABEL_73:
              v27 = v7 - 1;
              v28 = 1;
              do
              {
                v15 = v27;
                ++v28;
                --v27;
              }
              while ( v27[1] != 37 );
              n = v28;
              v9 = v7;
            }
LABEL_76:
            v29 = 0;
            v30 = n;
            if ( v13 >= 0 )
              v29 = v13;
            if ( n < v29 )
              v30 = v29;
            if ( v30 < a3 - v120 )
            {
              if ( a2 )
              {
                if ( v29 > n )
                {
                  v31 = v13 - n;
                  if ( v129 == 48 )
                    memset(a2, 48, v31);
                  else
                    memset(a2, 32, v31);
                  a2 += v31;
                }
                if ( i )
                  sub_8056B30((int)a2, (int)v15, n);
                else
                  memcpy(a2, v15, n);
                a2 += n;
              }
              v120 += v30;
              goto LABEL_9;
            }
            goto LABEL_35;
          }
          if ( v42 )
          {
LABEL_349:
            v133 = tm_gmtoff < 0;
            ne = 20;
            v138 = 1;
            v135 = 9;
            v122 = v42 + 10000 * v122 + 100 * v41;
          }
          else if ( v41 )
          {
LABEL_359:
            v133 = tm_gmtoff < 0;
            ne = 4;
            v122 = v41 + 100 * v122;
            v138 = 1;
            v135 = 6;
          }
          else
          {
            v133 = tm_gmtoff < 0;
            ne = 0;
            v138 = 1;
            v135 = 3;
          }
        }
        else
        {
          v133 = tm_gmtoff < 0;
          ne = 0;
          v122 = v41 + 100 * v122;
          v138 = 1;
          v135 = 5;
        }
LABEL_118:
        if ( v125 != 79 )
          goto LABEL_119;
LABEL_172:
        if ( v133 )
          goto LABEL_295;
LABEL_173:
        format = 32;
        v19 = v12;
        v9 = v7;
        v144 = 37;
        na = 0;
        goto LABEL_68;
      default:
        v15 = v7;
        goto LABEL_30;
    }
  }
}
// 8056B70: using guessed type char src[1037];

//----- (08058320) --------------------------------------------------------
__int64 __cdecl sub_8058320(char *a1, int a2, char *a3, const struct tm *a4, int a5, int a6)
{
  return sub_8056B70(0, a1, a2, a3, a4, a5, a6);
}

//----- (08058370) --------------------------------------------------------
int __cdecl sub_8058370(int a1, const char *a2, const char *a3, const char *a4, int *a5, int a6)
{
  char *v6; // eax
  char *v7; // eax
  int v8; // edx
  int v9; // ebp
  int v10; // edi
  int v11; // ecx
  int v12; // ebx
  char *v13; // eax
  int result; // eax
  int v15; // ebx
  char *v16; // eax
  int v17; // edi
  int v18; // ebx
  char *v19; // eax
  int v20; // ebp
  int v21; // edi
  int v22; // ebx
  char *v23; // eax
  int v24; // ebp
  int v25; // edi
  int v26; // ebx
  char *v27; // eax
  int v28; // ebp
  int v29; // edi
  int v30; // ebx
  char *v31; // eax
  int v32; // ebp
  int v33; // edi
  int v34; // ebx
  char *v35; // eax
  int v36; // ebp
  int v37; // edi
  int v38; // ebx
  char *v39; // eax
  int v40; // ebp
  int v41; // edi
  int v42; // ebx
  char *v43; // eax
  char *msgid; // [esp+4h] [ebp-68h]
  int v45; // [esp+38h] [ebp-34h]
  int v46; // [esp+38h] [ebp-34h]
  int v47; // [esp+38h] [ebp-34h]
  int v48; // [esp+38h] [ebp-34h]
  int v49; // [esp+38h] [ebp-34h]
  int v50; // [esp+38h] [ebp-34h]
  int v51; // [esp+3Ch] [ebp-30h]
  int v52; // [esp+3Ch] [ebp-30h]
  int v53; // [esp+3Ch] [ebp-30h]
  int v54; // [esp+3Ch] [ebp-30h]
  int v55; // [esp+3Ch] [ebp-30h]
  int v56; // [esp+40h] [ebp-2Ch]
  int v57; // [esp+40h] [ebp-2Ch]
  int v58; // [esp+40h] [ebp-2Ch]
  int v59; // [esp+40h] [ebp-2Ch]
  int v60; // [esp+44h] [ebp-28h]
  int v61; // [esp+44h] [ebp-28h]
  int v62; // [esp+44h] [ebp-28h]
  int v63; // [esp+48h] [ebp-24h]
  int v64; // [esp+48h] [ebp-24h]
  int v65; // [esp+4Ch] [ebp-20h]

  if ( a2 )
    __fprintf_chk(a1, 1, "%s (%s) %s\n", a2, a3, a4);
  else
    __fprintf_chk(a1, 1, "%s %s\n", a3, a4);
  v6 = dcgettext(0, "(C)", 5);
  __fprintf_chk(a1, 1, "Copyright %s %d Free Software Foundation, Inc.", v6, 2011);
  v7 = dcgettext(
         0,
         "\n"
         "License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>.\n"
         "This is free software: you are free to change and redistribute it.\n"
         "There is NO WARRANTY, to the extent permitted by law.\n"
         "\n",
         5);
  fputs_unlocked(v7, a1);
  switch ( a6 )
  {
    case 0:
      abort();
      return result;
    case 1:
      v15 = *a5;
      v16 = dcgettext(0, "Written by %s.\n", 5);
      return __fprintf_chk(a1, 1, v16, v15);
    case 2:
      v17 = a5[1];
      v18 = *a5;
      v19 = dcgettext(0, "Written by %s and %s.\n", 5);
      return __fprintf_chk(a1, 1, v19, v18, v17);
    case 3:
      v20 = a5[2];
      v21 = a5[1];
      v22 = *a5;
      v23 = dcgettext(0, "Written by %s, %s, and %s.\n", 5);
      return __fprintf_chk(a1, 1, v23, v22, v21, v20);
    case 4:
      v24 = a5[2];
      v25 = a5[1];
      v26 = *a5;
      v46 = a5[3];
      v27 = dcgettext(0, "Written by %s, %s, %s,\nand %s.\n", 5);
      return __fprintf_chk(a1, 1, v27, v26, v25, v24, v46);
    case 5:
      v28 = a5[3];
      v29 = a5[2];
      v30 = *a5;
      v47 = a5[4];
      v52 = a5[1];
      v31 = dcgettext(0, "Written by %s, %s, %s,\n%s, and %s.\n", 5);
      return __fprintf_chk(a1, 1, v31, v30, v52, v29, v28, v47);
    case 6:
      v32 = a5[4];
      v33 = a5[3];
      v34 = *a5;
      v57 = a5[1];
      v48 = a5[5];
      v53 = a5[2];
      v35 = dcgettext(0, "Written by %s, %s, %s,\n%s, %s, and %s.\n", 5);
      return __fprintf_chk(a1, 1, v35, v34, v57, v53, v33, v32, v48);
    case 7:
      v36 = a5[5];
      v58 = a5[2];
      v37 = a5[4];
      v38 = *a5;
      v49 = a5[6];
      v54 = a5[3];
      v61 = a5[1];
      v39 = dcgettext(0, "Written by %s, %s, %s,\n%s, %s, %s, and %s.\n", 5);
      return __fprintf_chk(a1, 1, v39, v38, v61, v58, v54, v37, v36, v49);
    case 8:
      v40 = a5[6];
      v59 = a5[3];
      v41 = a5[5];
      v62 = a5[2];
      v42 = *a5;
      v50 = a5[7];
      v55 = a5[4];
      v64 = a5[1];
      v43 = dcgettext(0, "Written by %s, %s, %s,\n%s, %s, %s, %s,\nand %s.\n", 5);
      return __fprintf_chk(a1, 1, v43, v42, v64, v62, v59, v55, v41, v40, v50);
    case 9:
      v8 = a5[8];
      v9 = a5[7];
      v10 = a5[6];
      v56 = a5[4];
      v11 = a5[5];
      v60 = a5[3];
      v63 = a5[2];
      v12 = *a5;
      msgid = "Written by %s, %s, %s,\n%s, %s, %s, %s,\n%s, and %s.\n";
      v65 = a5[1];
      goto LABEL_5;
    default:
      v8 = a5[8];
      v9 = a5[7];
      v10 = a5[6];
      v56 = a5[4];
      v11 = a5[5];
      v60 = a5[3];
      v63 = a5[2];
      v12 = *a5;
      msgid = "Written by %s, %s, %s,\n%s, %s, %s, %s,\n%s, %s, and others.\n";
      v65 = a5[1];
LABEL_5:
      v45 = v8;
      v51 = v11;
      v13 = dcgettext(0, msgid, 5);
      return __fprintf_chk(a1, 1, v13, v12, v65, v63, v60, v56, v51, v10, v9, v45);
  }
}
// 8049870: using guessed type int __cdecl fputs_unlocked(_DWORD, _DWORD);
// 8049A60: using guessed type int __fprintf_chk(_DWORD, _DWORD, const char *, ...);

//----- (08058920) --------------------------------------------------------
int __cdecl sub_8058920(int a1, const char *a2, const char *a3, const char *a4, int a5)
{
  int i; // eax
  int v6; // edx
  int v8[13]; // [esp+28h] [ebp-34h] BYREF

  for ( i = 0; i != 10; ++i )
  {
    v6 = *(_DWORD *)(a5 + 4 * i);
    v8[i] = v6;
    if ( !v6 )
      break;
  }
  return sub_8058370(a1, a2, a3, a4, v8, i);
}
// 8058920: using guessed type int var_34[13];

//----- (08058980) --------------------------------------------------------
int sub_8058980(int a1, const char *a2, const char *a3, const char *a4, ...)
{
  va_list va; // [esp+40h] [ebp+14h] BYREF

  va_start(va, a4);
  return sub_8058920(a1, a2, a3, a4, (int)va);
}

//----- (08058A70) --------------------------------------------------------
void *__cdecl sub_8058A70(size_t size)
{
  void *result; // eax

  result = malloc(size);
  if ( !result )
  {
    if ( size )
      sub_8058C00();
  }
  return result;
}

//----- (08058AA0) --------------------------------------------------------
void *__cdecl sub_8058AA0(void *ptr, size_t size)
{
  void *result; // eax

  if ( size || !ptr )
  {
    result = realloc(ptr, size);
    if ( !result )
    {
      if ( size )
        sub_8058C00();
    }
  }
  else
  {
    free(ptr);
    return 0;
  }
  return result;
}

//----- (08058BA0) --------------------------------------------------------
void *__cdecl sub_8058BA0(void *src, size_t n)
{
  void *dest; // eax

  dest = sub_8058A70(n);
  return memcpy(dest, src, n);
}

//----- (08058BD0) --------------------------------------------------------
void *__cdecl sub_8058BD0(char *s)
{
  size_t v1; // eax

  v1 = strlen(s);
  return sub_8058BA0(s, v1 + 1);
}

//----- (08058C00) --------------------------------------------------------
void __noreturn sub_8058C00()
{
  char *v0; // eax

  v0 = dcgettext(0, "memory exhausted", 5);
  error(dword_80622CC, 0, "%s", v0);
  abort();
}

//----- (08058C50) --------------------------------------------------------
int __cdecl sub_8058C50(char *nptr, char **a2, int base, int a4, char *s)
{
  char **endptr; // ebx
  const unsigned __int16 **v6; // eax
  unsigned __int8 v7; // dl
  const unsigned __int16 *v8; // esi
  char *v9; // eax
  int v10; // esi
  int result; // eax
  int *v12; // eax
  unsigned int v13; // eax
  char *v14; // ecx
  unsigned int v15; // edi
  char v16; // bp
  char *v17; // eax
  char *v18; // ecx
  char v19; // al
  char *v20; // eax
  int v21; // eax
  int v22; // edx
  int v23; // ebp
  int v24; // edx
  int v25; // ebp
  int v26; // ebp
  int v27; // edx
  int v28; // ebp
  int v29; // edx
  int v30; // edx
  int v31; // ebp
  unsigned int v32; // eax
  int v33; // edx
  unsigned int v34; // edi
  unsigned int v35; // edi
  char v36; // [esp+10h] [ebp-3Ch]
  int *v37; // [esp+10h] [ebp-3Ch]
  char *v38; // [esp+10h] [ebp-3Ch]
  char *v39; // [esp+10h] [ebp-3Ch]
  char *v40; // [esp+10h] [ebp-3Ch]
  unsigned int v41; // [esp+14h] [ebp-38h]
  int v42; // [esp+1Ch] [ebp-30h]
  char v43; // [esp+2Ch] [ebp-20h] BYREF

  if ( (unsigned int)base > 0x24 )
    __assert_fail("0 <= strtol_base && strtol_base <= 36", "xstrtol.c", 0x53u, "xstrtoul");
  endptr = (char **)&v43;
  if ( a2 )
    endptr = a2;
  v36 = *nptr;
  v6 = __ctype_b_loc();
  v7 = v36;
  v8 = *v6;
  v9 = nptr;
  while ( (v8[v7] & 0x2000) != 0 )
    v7 = *++v9;
  v10 = 4;
  if ( v7 == 45 )
    return v10;
  v12 = __errno_location();
  *v12 = 0;
  v37 = v12;
  v13 = strtoul(nptr, endptr, base);
  v14 = *endptr;
  v15 = v13;
  if ( *endptr == nptr )
  {
    if ( s )
    {
      v16 = *nptr;
      if ( *nptr )
      {
        LOWORD(v10) = 0;
        v15 = 1;
        v40 = *endptr;
        v20 = strchr(s, v16);
        v18 = v40;
        if ( v20 )
          goto LABEL_17;
        LOWORD(v10) = 4;
      }
    }
    return v10;
  }
  v10 = 0;
  if ( *v37 )
  {
    LOWORD(v10) = 4;
    if ( *v37 != 34 )
      return v10;
    LOWORD(v10) = 1;
  }
  if ( s )
  {
    v16 = *v14;
    if ( *v14 )
    {
      v38 = *endptr;
      v17 = strchr(s, *v14);
      v18 = v38;
      if ( v17 )
      {
LABEL_17:
        v39 = v18;
        v42 = 1;
        v41 = 1024;
        if ( !strchr(s, 48) )
          goto LABEL_21;
        v19 = v39[1];
        if ( v19 != 68 )
        {
          if ( v19 == 105 )
          {
            v42 = 2 * (v39[2] == 66) + 1;
            goto LABEL_21;
          }
          if ( v19 != 66 )
          {
LABEL_21:
            switch ( v16 )
            {
              case 'B':
                if ( v15 > 0x3FFFFF )
                  goto LABEL_59;
                v15 <<= 10;
                v21 = 0;
                break;
              case 'E':
                v30 = 6;
                v21 = 0;
                do
                {
                  if ( 0xFFFFFFFF / v41 >= v15 )
                  {
                    v15 *= v41;
                    v31 = 0;
                  }
                  else
                  {
                    v15 = -1;
                    v31 = 1;
                  }
                  v21 |= v31;
                  --v30;
                }
                while ( v30 );
                break;
              case 'G':
              case 'g':
                v32 = 0xFFFFFFFF / v41;
                v33 = 1;
                if ( 0xFFFFFFFF / v41 < v15 )
                  goto LABEL_75;
                v34 = v41 * v15;
                if ( v34 > v32 )
                {
                  v33 = 0;
LABEL_75:
                  v15 = -1;
                  v21 = v33 | 1;
                }
                else
                {
                  v35 = v41 * v34;
                  if ( v35 > v32 )
                  {
                    v15 = -1;
                    v21 = 1;
                  }
                  else
                  {
                    LOBYTE(v33) = 0;
                    v15 = v41 * v35;
                    v21 = v33;
                  }
                }
                break;
              case 'K':
              case 'k':
                if ( v15 > 0xFFFFFFFF / v41 )
                  goto LABEL_59;
                goto LABEL_57;
              case 'M':
              case 'm':
                if ( 0xFFFFFFFF / v41 < v15 || (v15 *= v41, 0xFFFFFFFF / v41 < v15) )
                {
                  v21 = 1;
                  v15 = -1;
                }
                else
                {
LABEL_57:
                  v15 *= v41;
                  v21 = 0;
                }
                break;
              case 'P':
                v28 = 5;
                v21 = 0;
                do
                {
                  if ( v15 <= 0xFFFFFFFF / v41 )
                  {
                    v15 *= v41;
                    v29 = 0;
                  }
                  else
                  {
                    v15 = -1;
                    v29 = 1;
                  }
                  v21 |= v29;
                  --v28;
                }
                while ( v28 );
                break;
              case 'T':
              case 't':
                v26 = 4;
                v21 = 0;
                do
                {
                  if ( 0xFFFFFFFF / v41 < v15 )
                  {
                    v15 = -1;
                    v27 = 1;
                  }
                  else
                  {
                    v15 *= v41;
                    v27 = 0;
                  }
                  v21 |= v27;
                  --v26;
                }
                while ( v26 );
                break;
              case 'Y':
                v24 = 8;
                v21 = 0;
                do
                {
                  if ( v15 <= 0xFFFFFFFF / v41 )
                  {
                    v15 *= v41;
                    v25 = 0;
                  }
                  else
                  {
                    v15 = -1;
                    v25 = 1;
                  }
                  v21 |= v25;
                  --v24;
                }
                while ( v24 );
                break;
              case 'Z':
                v22 = 7;
                v21 = 0;
                do
                {
                  if ( v15 <= 0xFFFFFFFF / v41 )
                  {
                    v15 *= v41;
                    v23 = 0;
                  }
                  else
                  {
                    v15 = -1;
                    v23 = 1;
                  }
                  v21 |= v23;
                  --v22;
                }
                while ( v22 );
                break;
              case 'b':
                if ( v15 > 0x7FFFFF )
                  goto LABEL_59;
                v15 <<= 9;
                v21 = 0;
                break;
              case 'c':
                v21 = 0;
                break;
              case 'w':
                if ( v15 > 0x7FFFFFFF )
                {
LABEL_59:
                  v15 = -1;
                  v21 = 1;
                }
                else
                {
                  v15 *= 2;
                  v21 = 0;
                }
                break;
              default:
                goto LABEL_26;
            }
            v10 |= v21;
            *endptr = &v39[v42];
            if ( v39[v42] )
              v10 |= 2u;
            goto LABEL_13;
          }
        }
        v42 = 2;
        v41 = 1000;
        goto LABEL_21;
      }
LABEL_26:
      v10 |= 2u;
      *(_DWORD *)a4 = v15;
      return v10;
    }
  }
LABEL_13:
  result = v10;
  *(_DWORD *)a4 = v15;
  return result;
}

//----- (08059090) --------------------------------------------------------
void __cdecl __noreturn sub_8059090(unsigned int a1, int a2, char a3, int a4, int a5)
{
  int v5; // esi
  const char *msgid; // ecx
  char *v7; // ebx
  char *v8; // edi
  char *v9; // eax
  char v10[14]; // [esp+2Eh] [ebp-Eh] BYREF

  v5 = dword_80622CC;
  if ( a1 > 3 )
  {
    msgid = "invalid %s%s argument `%s'";
    if ( a1 != 4 )
      goto LABEL_6;
  }
  else
  {
    msgid = "invalid suffix in %s%s argument `%s'";
    if ( a1 < 2 )
    {
      if ( a1 != 1 )
        goto LABEL_6;
      msgid = "%s%s argument `%s' too large";
    }
  }
  if ( a2 < 0 )
  {
    v7 = &asc_805DE6D[-a2];
    v10[0] = a3;
    v8 = v10;
    v10[1] = 0;
  }
  else
  {
    v7 = "--";
    v8 = *(char **)(a4 + 16 * a2);
  }
  v9 = dcgettext(0, msgid, 5);
  error(v5, 0, v9, v7, v8, a5);
LABEL_6:
  abort();
}

//----- (08059140) --------------------------------------------------------
int __usercall sub_8059140@<eax>(unsigned int *a1@<eax>, signed int a2@<edx>)
{
  signed int v3; // edi
  unsigned __int64 v5; // rax
  int result; // eax
  unsigned int v7; // [esp+18h] [ebp-24h]
  unsigned int v8; // [esp+1Ch] [ebp-20h]

  v3 = a2 >> 31;
  v7 = a1[1];
  v8 = *a1;
  LODWORD(v5) = sub_8059C90(0xFFFFFFFFFFFFFFFFLL, a2, a2 >> 31);
  if ( v5 < __PAIR64__(v7, v8) )
  {
    *a1 = -1;
    result = 1;
    a1[1] = -1;
  }
  else
  {
    *a1 = v8 * a2;
    result = 0;
    a1[1] = (__PAIR64__(v7, v8) * __PAIR64__(v3, a2)) >> 32;
  }
  return result;
}
// 80591AC: variable 'v5' is possibly undefined

//----- (080591F0) --------------------------------------------------------
int __usercall sub_80591F0@<eax>(unsigned int *a1@<eax>, signed int a2@<edx>, int a3@<ecx>)
{
  int v4; // edi
  int v6; // esi

  v4 = 0;
  if ( a3 )
  {
    v6 = a3;
    do
    {
      v4 |= sub_8059140(a1, a2);
      --v6;
    }
    while ( v6 );
  }
  return v4;
}

//----- (08059230) --------------------------------------------------------
int __cdecl sub_8059230(char *nptr, char **a2, int base, int a4, char *s)
{
  char **endptr; // ebx
  const unsigned __int16 **v6; // eax
  unsigned __int8 v7; // dl
  const unsigned __int16 *v8; // edi
  char *v9; // eax
  int v10; // edi
  int *v12; // eax
  unsigned __int64 v13; // rax
  char *v14; // ebp
  bool v15; // zf
  char v16; // si
  char *v17; // eax
  signed int v18; // edx
  char v19; // al
  int v20; // eax
  char *v21; // ebp
  char v22; // [esp+18h] [ebp-34h]
  int *v23; // [esp+18h] [ebp-34h]
  int v24; // [esp+1Ch] [ebp-30h]
  unsigned __int64 v25; // [esp+20h] [ebp-2Ch] BYREF
  char v26; // [esp+2Ch] [ebp-20h] BYREF

  if ( (unsigned int)base > 0x24 )
    __assert_fail("0 <= strtol_base && strtol_base <= 36", "xstrtol.c", 0x53u, "xstrtoumax");
  endptr = (char **)&v26;
  if ( a2 )
    endptr = a2;
  v22 = *nptr;
  v6 = __ctype_b_loc();
  v7 = v22;
  v8 = *v6;
  v9 = nptr;
  while ( (v8[v7] & 0x2000) != 0 )
    v7 = *++v9;
  v10 = 4;
  if ( v7 == 45 )
    return v10;
  v12 = __errno_location();
  *v12 = 0;
  v23 = v12;
  v13 = __strtoull_internal(nptr, endptr, base, 0);
  v14 = *endptr;
  v15 = *endptr == nptr;
  v25 = v13;
  if ( v15 )
  {
    if ( !s || !*nptr || !strchr(s, *nptr) )
      return v10;
    v25 = 1LL;
    LOWORD(v10) = 0;
    goto LABEL_12;
  }
  v10 = 0;
  if ( *v23 )
  {
    LOWORD(v10) = 4;
    if ( *v23 != 34 )
      return v10;
    LOWORD(v10) = 1;
  }
  if ( s )
  {
LABEL_12:
    v16 = *v14;
    if ( !*v14 )
    {
LABEL_24:
      v13 = v25;
      goto LABEL_25;
    }
    if ( strchr(s, *v14) )
    {
      v17 = strchr(s, 48);
      v18 = 1024;
      v24 = 1;
      if ( !v17 )
        goto LABEL_18;
      v19 = v14[1];
      if ( v19 != 68 )
      {
        if ( v19 == 105 )
        {
          v24 = 2 * (v14[2] == 66) + 1;
          goto LABEL_18;
        }
        if ( v19 != 66 )
        {
LABEL_18:
          switch ( v16 )
          {
            case 'B':
              v20 = sub_8059140((unsigned int *)&v25, 1024);
              v14 = *endptr;
              break;
            case 'E':
              v20 = sub_80591F0((unsigned int *)&v25, v18, 6);
              v14 = *endptr;
              break;
            case 'G':
            case 'g':
              v20 = sub_80591F0((unsigned int *)&v25, v18, 3);
              v14 = *endptr;
              break;
            case 'K':
            case 'k':
              v20 = sub_80591F0((unsigned int *)&v25, v18, 1);
              v14 = *endptr;
              break;
            case 'M':
            case 'm':
              v20 = sub_80591F0((unsigned int *)&v25, v18, 2);
              v14 = *endptr;
              break;
            case 'P':
              v20 = sub_80591F0((unsigned int *)&v25, v18, 5);
              v14 = *endptr;
              break;
            case 'T':
            case 't':
              v20 = sub_80591F0((unsigned int *)&v25, v18, 4);
              v14 = *endptr;
              break;
            case 'Y':
              v20 = sub_80591F0((unsigned int *)&v25, v18, 8);
              v14 = *endptr;
              break;
            case 'Z':
              v20 = sub_80591F0((unsigned int *)&v25, v18, 7);
              v14 = *endptr;
              break;
            case 'b':
              v20 = sub_8059140((unsigned int *)&v25, 512);
              v14 = *endptr;
              break;
            case 'c':
              v20 = 0;
              break;
            case 'w':
              v20 = sub_8059140((unsigned int *)&v25, 2);
              v14 = *endptr;
              break;
            default:
              goto LABEL_30;
          }
          v21 = &v14[v24];
          v10 |= v20;
          *endptr = v21;
          if ( *v21 )
            v10 |= 2u;
          goto LABEL_24;
        }
      }
      v24 = 2;
      v18 = 1000;
      goto LABEL_18;
    }
LABEL_30:
    v10 |= 2u;
    *(_QWORD *)a4 = v25;
    return v10;
  }
LABEL_25:
  *(_QWORD *)a4 = v13;
  return v10;
}
// 8059230: using guessed type unsigned __int64 var_2C;

//----- (08059550) --------------------------------------------------------
int __cdecl sub_8059550(int a1, const char **a2)
{
  int result; // eax

  result = getfilecon(a1, a2);
  if ( result )
  {
    if ( result == 10 && !strcmp(*a2, "unlabeled") )
    {
      freecon(*a2);
      *__errno_location() = 61;
      return -1;
    }
  }
  else
  {
    *__errno_location() = 95;
    return -1;
  }
  return result;
}
// 80498A0: using guessed type int __cdecl getfilecon(_DWORD, _DWORD);
// 8049A30: using guessed type int __cdecl freecon(_DWORD);

//----- (080595E0) --------------------------------------------------------
int __cdecl sub_80595E0(int a1, const char **a2)
{
  int result; // eax

  result = lgetfilecon(a1, a2);
  if ( result )
  {
    if ( result == 10 && !strcmp(*a2, "unlabeled") )
    {
      freecon(*a2);
      *__errno_location() = 61;
      return -1;
    }
  }
  else
  {
    *__errno_location() = 95;
    return -1;
  }
  return result;
}
// 8049810: using guessed type int __cdecl lgetfilecon(_DWORD, _DWORD);
// 8049A30: using guessed type int __cdecl freecon(_DWORD);

//----- (08059700) --------------------------------------------------------
int __cdecl sub_8059700(FILE *fp)
{
  size_t v1; // eax
  int v2; // ebx
  size_t v3; // edi
  bool v4; // al

  v1 = __fpending(fp);
  v2 = fp->_flags & 0x20;
  v3 = v1;
  v4 = sub_8059790(fp) != 0;
  if ( v2 )
  {
    v2 = -1;
    if ( !v4 )
      *__errno_location() = 0;
  }
  else if ( v4 )
  {
    v2 = -1;
    if ( !v3 )
      return (*__errno_location() == 9) - 1;
  }
  return v2;
}

//----- (08059790) --------------------------------------------------------
int __cdecl sub_8059790(FILE *fp)
{
  int *v1; // eax
  int v2; // edi
  int *v3; // esi
  int result; // eax
  int v5; // eax
  __int64 v6; // rax

  if ( fileno(fp) < 0 )
    return fclose(fp);
  if ( __freading(fp) )
  {
    v5 = fileno(fp);
    v6 = lseek64(v5, 0, 0, 1);
    if ( (HIDWORD(v6) & (unsigned int)v6) == -1 )
      return fclose(fp);
  }
  if ( !sub_8059840(fp) )
    return fclose(fp);
  v1 = __errno_location();
  v2 = *v1;
  v3 = v1;
  result = fclose(fp);
  if ( v2 )
  {
    *v3 = v2;
    return -1;
  }
  return result;
}
// 8049A40: using guessed type __int64 __cdecl lseek64(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (08059840) --------------------------------------------------------
int __cdecl sub_8059840(FILE *stream)
{
  if ( !stream || !__freading(stream) || (stream->_flags & 0x100) == 0 )
    return fflush(stream);
  sub_80598A0(stream, 0, 0, 1);
  return fflush(stream);
}

//----- (080598A0) --------------------------------------------------------
int __cdecl sub_80598A0(FILE *stream, int a2, int a3, int a4)
{
  int v5; // eax
  __off64_t v6; // rax

  if ( stream->_IO_read_end != stream->_IO_read_ptr
    || stream->_IO_write_ptr != stream->_IO_write_base
    || stream->_IO_save_base )
  {
    return fseeko64();
  }
  v5 = fileno(stream);
  v6 = lseek64(v5, a2, a3, a4);
  if ( (HIDWORD(v6) & (unsigned int)v6) == -1 )
    return -1;
  stream->_flags &= ~0x10u;
  stream->_offset = v6;
  return 0;
}
// 8049610: using guessed type int fseeko64(void);
// 8049A40: using guessed type __int64 __cdecl lseek64(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (08059950) --------------------------------------------------------
int __cdecl sub_8059950(__int64 a1, __int64 a2)
{
  unsigned int v2; // edi
  __int64 v3; // rax
  int v4; // esi
  unsigned int v5; // ecx
  int v6; // ecx
  int v7; // esi
  unsigned __int64 v8; // rax
  unsigned int v9; // ecx
  int v10; // eax
  unsigned __int64 v11; // rtt
  unsigned int v12; // edi
  unsigned __int64 v13; // rax
  char v15; // [esp+Ch] [ebp-20h]
  int v16; // [esp+10h] [ebp-1Ch]
  unsigned int v17; // [esp+18h] [ebp-14h]
  unsigned int v18; // [esp+1Ch] [ebp-10h]

  v2 = HIDWORD(a1);
  v3 = a2;
  v4 = a1;
  v16 = 0;
  if ( a1 < 0 )
  {
    v4 = -(int)a1;
    v2 = (unsigned __int64)-a1 >> 32;
    v16 = -1;
  }
  if ( a2 < 0 )
  {
    v16 = ~v16;
    v3 = -a2;
  }
  v17 = v4;
  v5 = v3;
  if ( HIDWORD(v3) )
  {
    v6 = 0;
    v7 = 0;
    if ( HIDWORD(v3) <= v2 )
    {
      _BitScanReverse(&v9, HIDWORD(v3));
      v15 = v9 ^ 0x1F;
      if ( v9 != 0x1F )
      {
        v18 = (HIDWORD(v3) << v15) | ((unsigned int)v3 >> (32 - v15));
        LODWORD(v11) = (v2 << v15) | (v17 >> (32 - v15));
        HIDWORD(v11) = v2 >> (32 - v15);
        v12 = v11 % v18;
        v7 = v11 / v18;
        v13 = (unsigned int)((_DWORD)v3 << v15) * (unsigned __int64)(unsigned int)v7;
        if ( v12 < HIDWORD(v13) || v17 << v15 < (unsigned int)v13 && v12 == HIDWORD(v13) )
        {
          --v7;
          v6 = 0;
        }
        else
        {
          v6 = 0;
        }
      }
      else if ( (unsigned int)v3 <= v17 || (v6 = 0, HIDWORD(v3) < v2) )
      {
        v6 = 0;
        v7 = 1;
      }
    }
  }
  else if ( (unsigned int)v3 <= v2 )
  {
    if ( !(_DWORD)v3 )
      v5 = 1 / (unsigned int)v3;
    v10 = __PAIR64__(v2 % v5, v4) / v5;
    v6 = v2 / v5;
    v7 = v10;
  }
  else
  {
    v6 = 0;
    v7 = __PAIR64__(v2, v4) / (unsigned int)v3;
  }
  v8 = __PAIR64__(v6, v7);
  if ( v16 )
    return -__SPAIR64__(v6, v7);
  return v8;
}

//----- (08059AC0) --------------------------------------------------------
int __cdecl sub_8059AC0(signed __int64 a1, __int64 a2)
{
  unsigned int v2; // edi
  unsigned int v3; // esi
  unsigned int v4; // eax
  unsigned int v5; // ecx
  bool v6; // zf
  unsigned int v7; // edi
  unsigned int v8; // esi
  unsigned __int64 v9; // rax
  unsigned int v10; // esi
  unsigned int v11; // esi
  unsigned __int64 v12; // rtt
  unsigned __int64 v13; // rtt
  unsigned int v14; // ecx
  unsigned __int64 v15; // rax
  unsigned int v16; // ebp
  unsigned int v17; // edi
  unsigned int v18; // ecx
  unsigned __int64 v20; // [esp+8h] [ebp-24h]
  unsigned int v21; // [esp+10h] [ebp-1Ch]
  unsigned int v22; // [esp+10h] [ebp-1Ch]
  int v23; // [esp+14h] [ebp-18h]
  unsigned int v24; // [esp+18h] [ebp-14h]
  int v25; // [esp+18h] [ebp-14h]
  unsigned int v26; // [esp+1Ch] [ebp-10h]

  v2 = HIDWORD(a2);
  v3 = a2;
  v20 = a1;
  v23 = 0;
  if ( a1 < 0 )
  {
    v20 = -a1;
    v23 = -1;
  }
  if ( a2 < 0 )
  {
    v3 = -(int)a2;
    v2 = (unsigned __int64)-a2 >> 32;
  }
  v4 = v2;
  v5 = v3;
  v6 = v2 == 0;
  v21 = v3;
  v24 = HIDWORD(v20);
  v7 = v20;
  if ( v6 )
  {
    if ( v3 <= HIDWORD(v20) )
    {
      if ( !v3 )
        v5 = 1 / 0u;
      LODWORD(v12) = v20;
      HIDWORD(v12) = HIDWORD(v20) % v5;
      v8 = v12 % v5;
    }
    else
    {
      v8 = v20 % v3;
    }
    v9 = v8;
  }
  else if ( v4 <= HIDWORD(v20) )
  {
    _BitScanReverse(&v10, v4);
    v11 = v10 ^ 0x1F;
    if ( v11 )
    {
      v25 = (v4 << v11) | (v21 >> (32 - v11));
      v22 = v21 << v11;
      v26 = (_DWORD)v20 << v11;
      LODWORD(v13) = (HIDWORD(v20) << v11) | ((unsigned int)v20 >> (32 - v11));
      HIDWORD(v13) = HIDWORD(v20) >> (32 - v11);
      v14 = v13 % (unsigned int)v25;
      v15 = v22 * (unsigned __int64)(unsigned int)(v13 / (unsigned int)v25);
      v17 = HIDWORD(v15);
      v16 = v15;
      if ( v14 < HIDWORD(v15) || v26 < (unsigned int)v15 && v14 == HIDWORD(v15) )
      {
        v17 = (v15 - __PAIR64__(v25, v22)) >> 32;
        v16 = v15 - v22;
      }
      v18 = (__PAIR64__(v14, v26) - __PAIR64__(v17, v16)) >> 32;
      LODWORD(v9) = (v18 << (32 - v11)) | ((v26 - v16) >> v11);
      HIDWORD(v9) = v18 >> v11;
    }
    else
    {
      if ( v5 <= (unsigned int)v20 || v4 < HIDWORD(v20) )
      {
        v24 = (v20 - __PAIR64__(v4, v5)) >> 32;
        v7 = v20 - v5;
      }
      v9 = __PAIR64__(v24, v7);
    }
  }
  else
  {
    v9 = v20;
  }
  if ( v23 )
    return -(__int64)v9;
  return v9;
}

//----- (08059C90) --------------------------------------------------------
unsigned int __cdecl sub_8059C90(unsigned __int64 a1, unsigned int a2, unsigned int a3)
{
  unsigned int v3; // ecx
  unsigned int result; // eax
  unsigned int v5; // ecx
  unsigned __int64 v6; // rtt
  unsigned int v7; // edi
  unsigned int v8; // esi
  unsigned __int64 v9; // rax
  char v10; // [esp+4h] [ebp-18h]
  unsigned int v11; // [esp+Ch] [ebp-10h]

  v3 = a2;
  if ( a3 )
  {
    result = 0;
    if ( a3 <= HIDWORD(a1) )
    {
      _BitScanReverse(&v5, a3);
      v10 = v5 ^ 0x1F;
      if ( v5 != 0x1F )
      {
        v11 = (a3 << v10) | (a2 >> (32 - v10));
        LODWORD(v6) = (HIDWORD(a1) << v10) | ((unsigned int)a1 >> (32 - v10));
        HIDWORD(v6) = HIDWORD(a1) >> (32 - v10);
        v7 = v6 % v11;
        v8 = v6 / v11;
        v9 = (a2 << v10) * (unsigned __int64)v8;
        if ( v7 < HIDWORD(v9) || (_DWORD)a1 << v10 < (unsigned int)v9 && v7 == HIDWORD(v9) )
          return v8 - 1;
        else
          return v8;
      }
      else if ( a2 <= (unsigned int)a1 || a3 < HIDWORD(a1) )
      {
        return 1;
      }
    }
  }
  else if ( a2 > HIDWORD(a1) )
  {
    return a1 / a2;
  }
  else
  {
    if ( !a2 )
      v3 = 1 / 0u;
    return __PAIR64__(HIDWORD(a1) % v3, a1) / v3;
  }
  return result;
}

//----- (08059DC0) --------------------------------------------------------
int __cdecl sub_8059DC0(unsigned __int64 a1, __int64 a2)
{
  int result; // eax
  unsigned int v3; // ecx
  unsigned int v5; // eax
  unsigned __int64 v6; // rtt
  unsigned __int64 v7; // rax
  unsigned int v8; // esi
  unsigned __int64 v9; // rax
  unsigned int v10; // ecx
  unsigned int v11; // edi
  int v12; // [esp+0h] [ebp-1Ch]
  unsigned int v13; // [esp+0h] [ebp-1Ch]
  char v14; // [esp+4h] [ebp-18h]
  unsigned int v15; // [esp+8h] [ebp-14h]

  result = a1;
  v3 = a2;
  v12 = a1;
  if ( HIDWORD(a2) )
  {
    if ( HIDWORD(a2) <= HIDWORD(a1) )
    {
      _BitScanReverse(&v5, HIDWORD(a2));
      v14 = v5 ^ 0x1F;
      if ( v5 != 0x1F )
      {
        v13 = (HIDWORD(a2) << v14) | ((unsigned int)a2 >> (32 - v14));
        HIDWORD(v7) = HIDWORD(a1) >> (32 - v14);
        LODWORD(v7) = (HIDWORD(a1) << v14) | ((unsigned int)a1 >> (32 - v14));
        v15 = (_DWORD)a1 << v14;
        v8 = v7 % v13;
        v9 = (unsigned int)((_DWORD)a2 << v14) * (unsigned __int64)(unsigned int)(v7 / v13);
        v11 = HIDWORD(v9);
        v10 = v9;
        if ( v8 < HIDWORD(v9) || v15 < (unsigned int)v9 && v8 == HIDWORD(v9) )
        {
          v11 = (v9 - __PAIR64__(v13, (_DWORD)a2 << v14)) >> 32;
          v10 = v9 - ((_DWORD)a2 << v14);
        }
        return ((__PAIR64__(v8, v15) - __PAIR64__(v11, v10)) >> 32 << (32 - v14)) | ((v15 - v10) >> v14);
      }
      else
      {
        if ( (unsigned int)a2 <= (unsigned int)a1 || HIDWORD(a2) < HIDWORD(a1) )
          return a1 - a2;
        return v12;
      }
    }
  }
  else
  {
    if ( (unsigned int)a2 > HIDWORD(a1) )
      return a1 % (unsigned int)a2;
    if ( !(_DWORD)a2 )
      v3 = 1 / 0u;
    LODWORD(v6) = a1;
    HIDWORD(v6) = HIDWORD(a1) % v3;
    return v6 % v3;
  }
  return result;
}

//----- (08059F40) --------------------------------------------------------
void __cdecl init(int a1, int a2, int a3)
{
  int v3; // edi
  int i; // esi

  init_proc();
  v3 = (134619124 - (int)&off_8061FF4) >> 2;
  if ( v3 )
  {
    for ( i = 0; i != v3; ++i )
      ((void (__cdecl *)(int, int, int))dword_8061EF8[i])(a1, a2, a3);
  }
}
// 8061EF8: using guessed type int dword_8061EF8[];
// 8061FF4: using guessed type Elf32_Dyn *off_8061FF4;

//----- (08059FB2) --------------------------------------------------------
void sub_8059FB2()
{
  ;
}

//----- (08059FC0) --------------------------------------------------------
int __cdecl sub_8059FC0(void (__cdecl *lpfunc)(void *))
{
  void *lpdso_handle; // eax

  if ( off_8061FF0 )
    lpdso_handle = *(void **)off_8061FF0;
  else
    lpdso_handle = 0;
  return __cxa_atexit(lpfunc, 0, lpdso_handle);
}
// 8061FF0: using guessed type void *off_8061FF0;

//----- (0805A000) --------------------------------------------------------
void (*sub_805A000())(void)
{
  void (*result)(void); // eax
  void (**v1)(void); // ebx

  result = (void (*)(void))dword_8061EF8[0];
  if ( dword_8061EF8[0] != -1 )
  {
    v1 = (void (**)(void))dword_8061EF8;
    do
    {
      --v1;
      result();
      result = *v1;
    }
    while ( *v1 != (void (*)(void))-1 );
  }
  return result;
}
// 8061EF8: using guessed type int dword_8061EF8[];

// nfuncs=402 queued=186 decompiled=186 lumina nreq=0 worse=0 better=0
// ALL OK, 186 function(s) have been successfully decompiled
