/* This file was generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2020 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

// void __usercall __noreturn sub_401000(const WCHAR *a1@<eax>, int a2);
// int __usercall sub_4010A0@<eax>(const WCHAR *a1@<edi>);
int __stdcall start(int a1, int a2, int a3, int a4);
// void __stdcall __noreturn ExitProcess(UINT uExitCode);
// LPWSTR __stdcall GetCommandLineW();
// HANDLE __stdcall FindFirstFileW(LPCWSTR lpFileName, LPWIN32_FIND_DATAW lpFindFileData);
// BOOL __stdcall CreateProcessW(LPCWSTR lpApplicationName, LPWSTR lpCommandLine, LPSECURITY_ATTRIBUTES lpProcessAttributes, LPSECURITY_ATTRIBUTES lpThreadAttributes, BOOL bInheritHandles, DWORD dwCreationFlags, LPVOID lpEnvironment, LPCWSTR lpCurrentDirectory, LPSTARTUPINFOW lpStartupInfo, LPPROCESS_INFORMATION lpProcessInformation);
// HANDLE __stdcall OpenProcess(DWORD dwDesiredAccess, BOOL bInheritHandle, DWORD dwProcessId);
// void __stdcall Sleep(DWORD dwMilliseconds);
// DWORD __stdcall FormatMessageW(DWORD dwFlags, LPCVOID lpSource, DWORD dwMessageId, DWORD dwLanguageId, LPWSTR lpBuffer, DWORD nSize, va_list *Arguments);
// BOOL __stdcall TerminateProcess(HANDLE hProcess, UINT uExitCode);
// int __stdcall lstrlenW(LPCWSTR lpString);
// DWORD __stdcall GetLastError();
// BOOL __stdcall MoveFileW(LPCWSTR lpExistingFileName, LPCWSTR lpNewFileName);
// BOOL __stdcall FindClose(HANDLE hFindFile);
// HLOCAL __stdcall LocalAlloc(UINT uFlags, SIZE_T uBytes);
// BOOL __stdcall CloseHandle(HANDLE hObject);
// BOOL __stdcall DeleteFileW(LPCWSTR lpFileName);
// HLOCAL __stdcall LocalFree(HLOCAL hMem);
// BOOL __stdcall SetFileAttributesW(LPCWSTR lpFileName, DWORD dwFileAttributes);
// LPWSTR *__stdcall CommandLineToArgvW(LPCWSTR lpCmdLine, int *pNumArgs);
// int wsprintfW(LPWSTR, LPCWSTR, ...);
// int __stdcall MessageBoxW(HWND hWnd, LPCWSTR lpText, LPCWSTR lpCaption, UINT uType);

//-------------------------------------------------------------------------
// Data declarations

_UNKNOWN unk_40207C; // weak
const WCHAR word_402080 = 1055u; // idb


//----- (00401000) --------------------------------------------------------
void __usercall __noreturn sub_401000(const WCHAR *a1@<eax>, int a2)
{
  DWORD v3; // edi
  int v4; // eax
  WCHAR *v5; // esi
  int v6; // [esp+Ch] [ebp-8h]
  WCHAR Buffer[2]; // [esp+10h] [ebp-4h] BYREF

  v3 = GetLastError();
  FormatMessageW(0x1300u, 0, v3, 0x400u, Buffer, 0, 0);
  v6 = lstrlenW(*(LPCWSTR *)Buffer);
  v4 = lstrlenW(a1);
  v5 = (WCHAR *)LocalAlloc(0x40u, 2 * (v4 + v6) + 0x2000);
  wsprintfW(v5, &word_402080, a1, a2, v3, *(_DWORD *)Buffer);
  v5[1024] = 0;
  MessageBoxW(0, v5, L"Error", 0);
  LocalFree(*(HLOCAL *)Buffer);
  LocalFree(v5);
  ExitProcess(v3);
}

//----- (004010A0) --------------------------------------------------------
int __usercall sub_4010A0@<eax>(const WCHAR *a1@<edi>)
{
  int v1; // esi
  HANDLE v3; // eax
  struct _WIN32_FIND_DATAW FindFileData; // [esp+8h] [ebp-250h] BYREF

  v1 = 0;
  if ( !DeleteFileW(a1) )
  {
    SetFileAttributesW(a1, 0x80u);
    if ( !DeleteFileW(a1) )
    {
      while ( !DeleteFileW(a1) )
      {
        v3 = FindFirstFileW(a1, &FindFileData);
        if ( v3 == (HANDLE)-1 )
        {
          if ( GetLastError() == 2 )
            return 1;
        }
        else
        {
          FindClose(v3);
        }
        Sleep(0x64u);
        if ( ++v1 >= 10 )
          return 0;
      }
    }
  }
  return 1;
}

//----- (00401130) --------------------------------------------------------
int __stdcall start(int a1, int a2, int a3, int a4)
{
  const WCHAR *v4; // eax
  LPWSTR *v5; // ebx
  LPWSTR v7; // edi
  DWORD v8; // ecx
  int v9; // esi
  LPWSTR v10; // eax
  unsigned int v11; // edx
  unsigned int i; // eax
  int v13; // esi
  HANDLE v14; // eax
  void *v15; // esi
  WCHAR *v16; // esi
  int v17; // ecx
  struct _STARTUPINFOW *v18; // eax
  int v19; // ecx
  struct _PROCESS_INFORMATION *v20; // eax
  int v21; // esi
  int pNumArgs; // [esp+Ch] [ebp-5Ch] BYREF
  struct _PROCESS_INFORMATION ProcessInformation; // [esp+10h] [ebp-58h] BYREF
  struct _STARTUPINFOW StartupInfo; // [esp+20h] [ebp-48h] BYREF

  v4 = GetCommandLineW();
  v5 = CommandLineToArgvW(v4, &pNumArgs);
  if ( !v5 )
    sub_401000(L"CommandLineToArgvW", (int)&unk_40207C);
  if ( pNumArgs != 5 )
    return pNumArgs + 1000;
  v7 = v5[1];
  v8 = 0;
  if ( v7 )
  {
    v9 = 20;
    v10 = v5[1];
    while ( *v10 )
    {
      ++v10;
      if ( !--v9 )
        goto LABEL_9;
    }
    v11 = 20 - v9;
  }
  else
  {
LABEL_9:
    v11 = 0;
  }
  for ( i = 0; i < v11; v8 = v13 + 10 * v8 - 48 )
    v13 = v7[i++];
  v14 = OpenProcess(1u, 0, v8);
  v15 = v14;
  if ( !v14 )
    sub_401000(L"OpenProcess", (int)v5[1]);
  if ( !TerminateProcess(v14, 0) )
    sub_401000(L"TerminateProcess", (int)&unk_40207C);
  CloseHandle(v15);
  if ( sub_4010A0(v5[3]) )
    v16 = v5[3];
  else
    v16 = v5[4];
  if ( !MoveFileW(v5[2], v16) )
    sub_401000(L"MoveFileW", (int)v5[2]);
  v17 = 68;
  v18 = &StartupInfo;
  do
  {
    LOBYTE(v18->cb) = 0;
    v18 = (struct _STARTUPINFOW *)((char *)v18 + 1);
    --v17;
  }
  while ( v17 );
  StartupInfo.cb = 68;
  v19 = 16;
  v20 = &ProcessInformation;
  do
  {
    LOBYTE(v20->hProcess) = 0;
    v20 = (struct _PROCESS_INFORMATION *)((char *)v20 + 1);
    --v19;
  }
  while ( v19 );
  if ( !CreateProcessW(0, v16, 0, 0, 0, 0, 0, 0, &StartupInfo, &ProcessInformation) )
    sub_401000(L"CreateProcessW", (int)v16);
  if ( v16 != v5[3] )
  {
    v21 = 100;
    do
    {
      sub_4010A0(v5[3]);
      --v21;
    }
    while ( v21 );
  }
  return 0;
}
// 4011D1: conditional instruction was optimized away because of 'esi.4!=0'
// 402240: using guessed type wchar_t aCommandlinetoa[19];
// 402268: using guessed type wchar_t aOpenprocess[12];
// 402280: using guessed type wchar_t aTerminateproce[17];
// 4022A4: using guessed type wchar_t aMovefilew[10];
// 4022B8: using guessed type wchar_t aCreateprocessw[15];

// nfuncs=3 queued=3 decompiled=3 lumina nreq=0 worse=0 better=0
// ALL OK, 3 function(s) have been successfully decompiled
