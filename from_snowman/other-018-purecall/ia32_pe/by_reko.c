// subject_PE_header.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

Eq_519 g_t400000 = // 00400000
	{
		23117,
		0xF0,
	};
// subject_data.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

ui32 g_dw405058 = 0xBB40E64E; // 00405058
ui32 g_dw40505C = 1153374641; // 0040505C
word32 g_dw405170 = 0x00; // 00405170
Eq_65 g_t405174 = // 00405174
	{
		0x00
	};
word32 g_dw405178 = 0x00; // 00405178
word32 g_dw40517C = 0x00; // 0040517C
Eq_65 g_t405188 = // 00405188
	{
		0x00
	};
word32 g_dw40518C = 0x00; // 0040518C
word32 g_dw4054C4 = 0x00; // 004054C4
Eq_151 g_t4054D4 = 0; // 004054D4
word32 g_dw4054EC = 0x00; // 004054EC
<anonymous> * g_ptr4054F0 = null; // 004054F0
// subject_idata.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

word32 g_dw40603C = 0x656A; // 0040603C
word32 g_dw406040 = 0x6556; // 00406040
word32 g_dw406044 = 25922; // 00406044
word32 g_dw406048 = 0x6528; // 00406048
word32 g_dw40604C = 0x6512; // 0040604C
word32 g_dw406050 = 25852; // 00406050
word32 g_dw406054 = 0x64EC; // 00406054
word32 g_dw406058 = 0x64D2; // 00406058
word32 g_dw40605C = 0x64C2; // 0040605C
word32 g_dw406060 = 0x64A4; // 00406060
word32 g_dw406064 = 0x6494; // 00406064
word32 g_dw406068 = 25726; // 00406068
word32 g_dw40606C = 0x6460; // 0040606C
word32 g_dw406070 = 25688; // 00406070
word32 g_dw406074 = 25666; // 00406074
word32 g_dw406078 = 0x6586; // 00406078
word32 g_dw4060B4 = 0x637C; // 004060B4
word32 g_dw4060B8 = 0x6390; // 004060B8
word32 g_dw4060BC = 25542; // 004060BC
word32 g_dw4060C0 = 25552; // 004060C0
word32 g_dw4060C4 = 0x636A; // 004060C4
word32 g_dw4060C8 = 0x63E6; // 004060C8
word32 g_dw4060CC = 0x63F0; // 004060CC
word32 g_dw4060D0 = 0x640A; // 004060D0
word32 g_dw4060D4 = 25628; // 004060D4
word32 g_dw4060D8 = 25644; // 004060D8
word32 g_dw4060DC = 0x6360; // 004060DC
word32 g_dw4060E0 = 25428; // 004060E0
word32 g_dw4060E4 = 0x6340; // 004060E4
word32 g_dw4060E8 = 0x632A; // 004060E8
word32 g_dw4060EC = 25372; // 004060EC
word32 g_dw4060F0 = 0x6310; // 004060F0
word32 g_dw4060F4 = 0x6304; // 004060F4
word32 g_dw4060F8 = 0x62FC; // 004060F8
word32 g_dw4060FC = 0x62EE; // 004060FC
word32 g_dw406100 = 0x62E6; // 00406100
word32 g_dw406104 = 0x62DC; // 00406104
word32 g_dw406108 = 25292; // 00406108
word32 g_dw40610C = 25278; // 0040610C
word32 g_dw406110 = 0x62A0; // 00406110
word32 g_dw406114 = 25232; // 00406114
word32 g_dw406118 = 25566; // 00406118
word32 g_dw40611C = 25220; // 0040611C
<anonymous> * __imp__UnhandledExceptionFilter = &g_t656A; // 00406160
<anonymous> * __imp__GetCurrentProcess = &g_t6556; // 00406164
<anonymous> * __imp__TerminateProcess = &g_t6542; // 00406168
<anonymous> * __imp__GetSystemTimeAsFileTime = &g_t6528; // 0040616C
<anonymous> * __imp__GetCurrentProcessId = &g_t6512; // 00406170
<anonymous> * __imp__GetCurrentThreadId = &g_t64FC; // 00406174
<anonymous> * __imp__GetTickCount = &g_t64EC; // 00406178
<anonymous> * __imp__QueryPerformanceCounter = &g_t64D2; // 0040617C
<anonymous> * __imp__DecodePointer = &g_t64C2; // 00406180
<anonymous> * __imp__SetUnhandledExceptionFilter = &g_t64A4; // 00406184
<anonymous> * __imp__EncodePointer = &g_t6494; // 00406188
<anonymous> * __imp__HeapSetInformation = &g_t647E; // 0040618C
<anonymous> * __imp__InterlockedCompareExchange = &g_t6460; // 00406190
<anonymous> * __imp__Sleep = &g_t6458; // 00406194
<anonymous> * __imp__InterlockedExchange = &g_t6442; // 00406198
<anonymous> * __imp__IsDebuggerPresent = &g_t6586; // 0040619C
<anonymous> * __imp__?terminate@@YAXXZ = &g_t637C; // 004061D8
<anonymous> * __imp__?_type_info_dtor_internal_method@type_info@@QAEXXZ = &g_t6390; // 004061DC
<anonymous> * __imp___unlock = &g_t63C6; // 004061E0
<anonymous> * __imp____dllonexit = &g_t63D0; // 004061E4
<anonymous> * __imp____set_app_type = &g_t636A; // 004061E8
<anonymous> * __imp___onexit = &g_t63E6; // 004061EC
<anonymous> * __imp___except_handler4_common = &g_t63F0; // 004061F0
<anonymous> * __imp___invoke_watson = &g_t640A; // 004061F4
<anonymous> * __imp___controlfp_s = &g_t641C; // 004061F8
<anonymous> * __imp___crt_debugger_hook = &g_t642C; // 004061FC
<anonymous> * __imp___fmode = &g_t6360; // 00406200
<anonymous> * __imp___commode = &g_t6354; // 00406204
<anonymous> * __imp____setusermatherr = &g_t6340; // 00406208
<anonymous> * __imp___configthreadlocale = &g_t632A; // 0040620C
<anonymous> * __imp___initterm_e = &g_t631C; // 00406210
<anonymous> * __imp___initterm = &g_t6310; // 00406214
<anonymous> * __imp____initenv = &g_t6304; // 00406218
<anonymous> * __imp__exit = &g_t62FC; // 0040621C
<anonymous> * __imp___XcptFilter = &g_t62EE; // 00406220
<anonymous> * __imp___exit = &g_t62E6; // 00406224
<anonymous> * __imp___cexit = &g_t62DC; // 00406228
<anonymous> * __imp____getmainargs = &g_t62CC; // 0040622C
<anonymous> * __imp___amsg_exit = &g_t62BE; // 00406230
<anonymous> * __imp__??3@YAXPAX@Z = &g_t62A0; // 00406234
<anonymous> * __imp__??2@YAPAXI@Z = &g_t6290; // 00406238
<anonymous> * __imp___lock = &g_t63DE; // 0040623C
<anonymous> * __imp___purecall = &g_t6284; // 00406240
// subject_rdata.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

Eq_247 g_t403000 = null; // 00403000
Eq_243 g_t403208 = null; // 00403208
<anonymous> * ??_7AAAAA@@6B@[1] = // 00403740
	{
		fn004010E4,
	};
<anonymous> * g_ptr40374C = &g_t401005; // 0040374C
<anonymous> * ??_7type_info@@6B@[1] = // 00403758
	{
		fn00401093,
	};
// subject_text.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

<anonymous> g_t401005 = <code>; // 00401005
// 0040100A: Register word32 fn0040100A()
// Called from:
//      Win32CrtStartup
word32 fn0040100A()
{
	<anonymous> *** eax_12 = operator new(0x04);
	if (eax_12 != null)
		*eax_12 = (<anonymous> ***) &g_ptr40374C;
	else
		eax_12 = null;
	<anonymous> ** edx_19 = *eax_12;
	word32 eax_25;
	(*edx_19)();
	return eax_25;
}

// 00401093: void fn00401093(Register (ptr32 Eq_24) ecx, Register word32 ebx, Stack byte bArg04)
void fn00401093(struct type_info * ecx, word32 ebx, byte bArg04)
{
	if ((bArg04 & 0x02) != 0x00)
	{
		void * esi_48;
		if ((fn0040144C(ebx, ecx - 4, ecx, out esi_48)->b0008 & 0x01) != 0x00)
			operator delete(esi_48);
	}
	else
	{
		_type_info_dtor_internal_method(ecx);
		if ((bArg04 & 0x01) != 0x00)
			operator delete(ecx);
	}
}

// 004010E4: void fn004010E4()
void fn004010E4()
{
}

// 004013CC: Register Eq_65 Win32CrtStartup()
Eq_65 Win32CrtStartup()
{
	ptr32 fp;
	struct Eq_67 * fs;
	word32 ebx;
	Eq_43 esi;
	struct type_info * edi;
	word32 dwLoc0C;
	Eq_72 tLoc14;
	fn00401870();
	ptr32 esp_12 = fp - 8;
	struct Eq_79 * ebp_19 = fn00401790(ebx, esi, edi, dwLoc0C, 0x10);
	if (g_dw4054EC == 0x00)
	{
		HeapSetInformation(null, tLoc14, (void *) 0x01, 0x00);
		esp_12 = fp - 0x0C;
	}
	ebp_19->dwFFFFFFFC = 0x00;
	Eq_65 esi_42 = fs->ptr0018->t0004.u0;
	ebp_19->dwFFFFFFE4 = 0x00;
	while (true)
	{
		struct Eq_123 * esp_46 = esp_12 - 4;
		esp_46->t0000.u0 = 0x00;
		esp_46->tFFFFFFFC.u0 = (DWORD) esi_42;
		esp_46->ptrFFFFFFF8 = &g_t4054D4;
		Eq_65 eax_55 = InterlockedCompareExchange(esp_46->ptrFFFFFFF8, esp_46->tFFFFFFFC.u1, esp_46->t0000.u1);
		if (eax_55 == 0x00)
			break;
		if (eax_55 == esi_42)
		{
			ebp_19->dwFFFFFFE4 = 0x01;
			break;
		}
		esp_46->t0000.u0 = 1000;
		Sleep(esp_46->t0000.u0);
	}
	if (g_dw4054C4 == 0x01)
	{
		esp_46->t0000.u0 = 0x1F;
		_amsg_exit(esp_46->t0000.u1);
	}
	struct Eq_172 * esp_203;
	Eq_65 eax_224;
	if (g_dw4054C4 == 0x00)
	{
		g_dw4054C4 = 0x01;
		esp_46->t0000.u0 = 0x00403618;
		esp_46->tFFFFFFFC.u0 = 0x0040330C;
		esp_203 = (struct Eq_172 *) ((char *) &esp_46->t0000 + 4);
		if (_initterm_e(esp_46->tFFFFFFFC.u0, esp_46->t0000.u0) != 0x00)
		{
			ebp_19->dwFFFFFFFC = ~0x01;
			eax_224.u0 = 0xFF;
			goto l004012C5;
		}
	}
	else
		g_dw40518C = 0x01;
	if (g_dw4054C4 == 0x01)
	{
		struct Eq_240 * esp_106 = esp_12 - 4;
		esp_106->ptr0000 = &g_t403208;
		esp_106->ptrFFFFFFFC = &g_t403000;
		_initterm(esp_106->ptrFFFFFFFC, esp_106->ptr0000);
		g_dw4054C4 = 0x02;
	}
	if (ebp_19->dwFFFFFFE4 == 0x00)
	{
		struct Eq_269 * esp_125 = esp_12 - 4;
		esp_125->t0000.u0 = 0x00;
		esp_125->ptrFFFFFFFC = (LONG *) &g_t4054D4;
		InterlockedExchange(esp_125->ptrFFFFFFFC, esp_125->t0000.u1);
	}
	ptr32 esp_138 = esp_12;
	if (g_ptr4054F0 != null)
	{
		struct Eq_327 * esp_139 = esp_12 - 4;
		esp_139->dw0000 = 0x004054F0;
		esp_138 = &esp_139->dw0000 + 1;
		if (fn004016C0(esp_139->dw0000) != 0x00)
		{
			esp_139->dw0000 = 0x00;
			esp_139->dwFFFFFFFC = 0x02;
			esp_139->dwFFFFFFF8 = 0x00;
			word32 edx_179;
			g_ptr4054F0();
		}
	}
	_initenv->u0 = g_t405174.u0;
	struct Eq_298 * esp_187 = esp_138 - 4;
	esp_187->t0000.u0 = g_t405174.u0;
	esp_187->dwFFFFFFFC = g_dw405178;
	esp_187->dwFFFFFFF8 = g_dw405170;
	Eq_65 eax_195 = fn0040100A();
	g_t405188.u0 = (DWORD) eax_195;
	esp_203 = (struct Eq_172 *) ((char *) &esp_187->t0000 + 4);
	if (g_dw40517C == 0x00)
	{
		esp_187->t0000.u0 = (DWORD) eax_195;
		exit(esp_187->t0000.u1);
	}
	if (g_dw40518C == 0x00)
		cexit();
	ebp_19->dwFFFFFFFC = ~0x01;
	eax_224.u0 = g_t405188.u0;
l004012C5:
	word32 esi_239;
	fn004017D5(ebp_19, esp_203->ptrFFFFFFFC, out esi_239);
	return eax_224;
}

// 004013EE: Register word32 fn004013EE(Register word32 ebx, Register Eq_43 esi, Register (ptr32 Eq_24) edi)
// Called from:
//      fn00401497
word32 fn004013EE(word32 ebx, Eq_43 esi, struct type_info * edi)
{
	ptr32 fp;
	word32 dwLoc0C;
	struct Eq_79 * ebp_13 = fn00401790(ebx, esi, edi, dwLoc0C, 0x14);
	ebp_13->dwFFFFFFFC = 0x00;
	struct Eq_394 * esp_31 = fp - 8;
	while (true)
	{
		int32 v9_25 = ebp_13->dw0010 - 0x01;
		ebp_13->dw0010 = v9_25;
		if (v9_25 < 0x00)
			break;
		word32 ecx_39 = ebp_13->dw0008 - (ebp_13->t000C).u0;
		ebp_13->dw0008 = ecx_39;
		ebp_13->ptr0014();
	}
	ebp_13->dwFFFFFFFC = ~0x01;
	word32 esi_60;
	return fn004017D5(ebp_13, esp_31->ptrFFFFFFFC, out esi_60);
}

// 0040144C: Register word32 fn0040144C(Register word32 ebx, Register Eq_43 esi, Register (ptr32 Eq_24) edi, Register out ptr32 esiOut)
// Called from:
//      fn00401093
word32 fn0040144C(word32 ebx, Eq_43 esi, struct type_info * edi, ptr32 & esiOut)
{
	ptr32 fp;
	word32 dwLoc0C;
	struct Eq_79 * ebp_13 = fn00401790(ebx, esi, edi, dwLoc0C, 0x0C);
	ebp_13->dwFFFFFFE4 = 0x00;
	Eq_43 esi_21 = ebp_13->t000C.u0;
	ebp_13->dw0008 += esi_21 *s ebp_13->dw0010;
	ebp_13->dwFFFFFFFC = 0x00;
	struct Eq_463 * esp_53 = fp - 8;
	while (true)
	{
		int32 v14_33 = ebp_13->dw0010 - 0x01;
		ebp_13->dw0010 = v14_33;
		if (v14_33 < 0x00)
			break;
		ebp_13->dw0008 -= esi_21;
		ebp_13->ptr0014();
	}
	ebp_13->dwFFFFFFE4 = 0x01;
	ebp_13->dwFFFFFFFC = ~0x01;
	ptr32 esi_58;
	word32 ebp_54 = fn004017D5(fn00401497(ebx, ebp_13, esi_21, edi), esp_53->ptrFFFFFFFC, out esi_58);
	esiOut = esi_58;
	return ebp_54;
}

// 00401497: Register (ptr32 Eq_79) fn00401497(Register word32 ebx, Register (ptr32 Eq_79) ebp, Register Eq_43 esi, Register (ptr32 Eq_24) edi)
// Called from:
//      fn0040144C
struct Eq_79 * fn00401497(word32 ebx, struct Eq_79 * ebp, Eq_43 esi, struct type_info * edi)
{
	if (ebp->dwFFFFFFE4 == 0x00)
		ebp = fn004013EE(ebx, esi, edi);
	return ebp;
}

// 00401630: Register uint32 fn00401630(Stack (ptr32 Eq_519) dwArg04)
// Called from:
//      fn004016C0
uint32 fn00401630(struct Eq_519 * dwArg04)
{
	if (dwArg04->w0000 != 23117)
		return 0x00;
	struct Eq_525 * eax_16 = dwArg04 + dwArg04->dw003C / 64;
	if (eax_16->dw0000 != 0x4550)
		return 0x00;
	return (uint32) (int8) (eax_16->w0018 == 0x010B);
}

// 00401670: Register (ptr32 Eq_543) fn00401670(Stack (ptr32 Eq_544) dwArg04, Stack uint32 dwArg08)
// Called from:
//      fn004016C0
struct Eq_543 * fn00401670(struct Eq_544 * dwArg04, uint32 dwArg08)
{
	struct Eq_546 * ecx_12 = dwArg04 + dwArg04->dw003C / 64;
	up32 esi_20 = (word32) ecx_12->w0006;
	up32 edx_21 = 0x00;
	struct Eq_543 * eax_24 = ecx_12 + ((word32) ecx_12->w0014 + 24) / 22;
	if (esi_20 != 0x00)
	{
		do
		{
			uint32 ecx_32 = eax_24->dw000C;
			if (dwArg08 >= ecx_32 && dwArg08 < eax_24->dw0008 + ecx_32)
				return eax_24;
			++edx_21;
			++eax_24;
		} while (edx_21 < esi_20);
	}
	eax_24 = null;
	return eax_24;
}

// 004016C0: Register ui32 fn004016C0(Stack ui32 dwArg04)
// Called from:
//      Win32CrtStartup
ui32 fn004016C0(ui32 dwArg04)
{
	ptr32 fp;
	struct Eq_586 * fs;
	ptr32 eax_17 = fs->ptr0000;
	fs->ptr0000 = fp - 20;
	if (fn00401630(&g_t400000) != 0x00)
	{
		struct Eq_606 * eax_64 = fn00401670(&g_t400000, dwArg04 - 0x00400000);
		if (eax_64 != null)
		{
			ui32 eax_100 = ~(eax_64->dw0024 >> 0x1F) & 0x01;
			fs->ptr0000 = eax_17;
			return eax_100;
		}
	}
	fs->ptr0000 = eax_17;
	return 0x00;
}

// 00401790: Register ptr32 fn00401790(Register word32 ebx, Register Eq_43 esi, Register (ptr32 Eq_24) edi, Stack word32 dwArg00, Stack ui32 dwArg08)
// Called from:
//      Win32CrtStartup
//      fn004013EE
//      fn0040144C
ptr32 fn00401790(word32 ebx, Eq_43 esi, struct type_info * edi, word32 dwArg00, ui32 dwArg08)
{
	ptr32 fp;
	struct Eq_629 * fs;
	struct Eq_630 * esp_14 = fp - 8 - dwArg08;
	esp_14->dwFFFFFFFC = ebx;
	esp_14->tFFFFFFF8.u0 = (int32) esi;
	esp_14->ptrFFFFFFF4 = edi;
	esp_14->dwFFFFFFF0 = g_dw405058 ^ fp + 8;
	esp_14->dwFFFFFFEC = dwArg00;
	fs->ptr0000 = fp - 8;
	return fp + 8;
}

// 004017D5: Register (ptr32 Eq_79) fn004017D5(Register (ptr32 Eq_79) ebp, Stack (ptr32 Eq_79) dwArg00, Register out ptr32 esiOut)
// Called from:
//      Win32CrtStartup
//      fn004013EE
//      fn0040144C
struct Eq_79 * fn004017D5(struct Eq_79 * ebp, struct Eq_79 * dwArg00, ptr32 & esiOut)
{
	struct Eq_660 * fs;
	ptr32 dwArg0C;
	fs->dw0000 = ebp->dwFFFFFFF0;
	struct Eq_79 * ebp_19 = ebp->ptr0000;
	ebp->ptr0000 = dwArg00;
	esiOut = dwArg0C;
	return ebp_19;
}

// 00401870: void fn00401870()
// Called from:
//      Win32CrtStartup
void fn00401870()
{
	Eq_675 tLoc14;
	Eq_676 tLoc0C;
	ui32 eax_11 = g_dw405058;
	tLoc0C.dwLowDateTime = (DWORD) 0x00;
	tLoc0C.dwHighDateTime = (DWORD) 0x00;
	if (eax_11 != 0xBB40E64E && (eax_11 & 0xFFFF0000) != 0x00)
		g_dw40505C = ~eax_11;
	else
	{
		GetSystemTimeAsFileTime(&tLoc0C);
		ui32 esi_48 = tLoc0C.dwHighDateTime ^ tLoc0C.dwLowDateTime ^ GetCurrentProcessId() ^ GetCurrentThreadId() ^ GetTickCount();
		QueryPerformanceCounter(&tLoc14);
		ui32 esi_56 = esi_48 ^ (tLoc14.dw0004 ^ (tLoc14.u).LowPart);
		if (esi_56 == 0xBB40E64E)
			esi_56 = ~0x44BF19B0;
		else if ((esi_56 & 0xFFFF0000) == 0x00)
			esi_56 |= (esi_56 | 0x4711) << 0x10;
		g_dw405058 = esi_56;
		g_dw40505C = ~esi_56;
	}
}

