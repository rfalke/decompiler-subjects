// subject_bss.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

byte g_b12060 = 0x00; // 0000000000012060
byte g_b12067 = 0x00; // 0000000000012067
struct Eq_189 * g_a12068[] = // 0000000000012068
	{
	};
int32 g_dw12080 = 0; // 0000000000012080
// subject_data.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

word64 g_qw12058 = 0x00012058; // 0000000000012058
// subject_fini.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 0000000000001044: void _fini()
void _fini()
{
}

// subject_got.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

<anonymous> * __libc_csu_fini_GOT = __libc_csu_fini; // 0000000000011F90
<anonymous> * g_ptr11F98 = null; // 0000000000011F98
word64 g_qw11FA0 = 0x00; // 0000000000011FA0
struct Eq_189 * (* g_ptr11FA8)[] = &g_a12068; // 0000000000011FA8
FILE ** g_ptr11FB0 = null; // 0000000000011FB0
word64 g_qw11FB8 = 0x00; // 0000000000011FB8
<anonymous> * __libc_csu_init_GOT = __libc_csu_init; // 0000000000011FC0
<anonymous> * main_GOT = main; // 0000000000011FC8
int32 * g_ptr11FD0 = &g_dw12080; // 0000000000011FD0
<anonymous> * g_ptr11FD8 = null; // 0000000000011FD8
<anonymous> * g_ptr11FE0 = null; // 0000000000011FE0
// subject_got_plt.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

struct Eq_292 g_t12000 = // 0000000000012000
	{
		0x00,
	};
// subject_init.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 0000000000000820: void _init()
// Called from:
//      __libc_csu_init
void _init()
{
	call_weak_fn();
}

// subject_init_array.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

<anonymous> * g_a11D90[] = // 0000000000011D90
	{
	};
// subject_jcr.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

word64 g_qw11DA0 = 0x00; // 0000000000011DA0
// subject_text.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 0000000000000900: void main(Register int32 w0, Register (ptr64 Eq_6) x1)
void main(int32 w0, struct Eq_6 * x1)
{
	ptr64 fp;
	word64 x21;
	word32 x21_32_32_286 = SLICE(x21, word32, 32);
	puts("\x1B[H\x1B[J");
	struct Eq_16 * x29_190 = fp + -112;
	if (w0 > 0x01)
	{
		int32 w0_51 = strtol(x1->ptr0008);
		*g_ptr11FD0 = w0_51;
		if (w0_51 > 0x00)
			goto l0000000000000964;
	}
	*g_ptr11FD0 = 0x08;
l0000000000000964:
	int32 w21_69 = *g_ptr11FD0;
	ptr64 x19_66;
	struct Eq_189 * x23_67[] = g_ptr11FA8;
	Eq_51 x20_72 = (int64) w21_69 + 0x04 << 2;
	for (x19_66 = 0x00; x19_66 != 0x18; x19_66 += 0x08)
	{
		ptr64 * x0_76 = calloc(0x01, x20_72);
		x23_67[x19_66 /64 8] = (struct Eq_189 *) x0_76;
		*x0_76 = x0_76 + 2;
	}
	if (w21_69 != 0x00)
	{
		struct Eq_189 * x22_91[] = g_ptr11FA8;
		char * x23_102 = "\x1B[%d;%dH";
		ptr64 x28_135 = 0x1000;
		int32 * x24_111 = g_ptr11FD0;
		word64 x21_402 = SEQ(x21_32_32_286, w21_69);
		do
		{
			while (true)
			{
				struct Eq_189 * x2_101 = x22_91[0];
				word32 w1_104 = x2_101->dw0008;
				word32 x3_105[] = x2_101->ptr0000;
				x2_101->dw0008 = w1_104 + 0x01;
				word32 w21_108 = (word32) x21_402;
				x3_105[(int64) w1_104] = w21_108;
				int32 w1_112 = *x24_111;
				printf(x23_102, w1_112 - x2_101->dw0008 + 0x01, w1_112 + 0x01 - w21_108);
				if (w21_108 != 0x00)
					break;
				usleep();
				fflush(*x29_138->ptr0060);
				x22_91 = x22_145;
				x23_102 = x23_146;
				x24_111 = x24_147;
				x28_135 = x28_152;
				x21_402 = x21_144;
			}
			word32 w27_160 = w21_108;
			char * x20_161 = x28_135 + 0x78;
			do
			{
				printf("%s", x20_161);
				--w27_160;
			} while (w27_160 != 0x00);
			usleep();
			fflush(*x25_201->ptr0FB0);
			word32 w21_212 = (word32) x21_196;
			x21_402 = SEQ(SLICE(x21_196, word32, 32), w21_212 - 0x01);
			x22_91 = x22_197;
			x23_102 = x23_198;
			x24_111 = x24_199;
			x28_135 = x28_204;
		} while (w21_212 != 0x01);
	}
	word32 w23_406;
	word64 x28_409;
	word64 x29_410;
	word32 w26_407;
	word64 x27_408;
	word64 x22_405;
	move(*x29_190->ptr0068->ptr0FD0, out x22_405, out w23_406, out w26_407, out x27_408, out x28_409, out x29_410);
	text(0x01, 0x00, 0x01, "\n");
}

// 0000000000000AE4: void _start(Register (ptr64 Eq_231) x0, Stack word32 dwArg00, Stack (ptr64 char) ptrArg08)
void _start(void (* x0)(), word32 dwArg00, char * ptrArg08)
{
	void * fp;
	word64 qwArg00;
	__libc_start_main(main_GOT, (int32) qwArg00, &ptrArg08, __libc_csu_init_GOT, __libc_csu_fini_GOT, x0, fp);
	abort();
}

// 0000000000000B1C: void call_weak_fn()
// Called from:
//      _init
void call_weak_fn()
{
	if (g_qw11FB8 == 0x00)
		return;
	__gmon_start__();
}

// 0000000000000B30: void deregister_tm_clones()
// Called from:
//      __do_global_dtors_aux
void deregister_tm_clones()
{
	if (&g_b12067 - &g_b12060 <= 0x0E)
		return;
	<anonymous> * x1_13 = g_ptr11F98;
	if (x1_13 == null)
		return;
	x1_13();
}

// 0000000000000B68: void register_tm_clones()
// Called from:
//      frame_dummy
void register_tm_clones()
{
	byte * x1_7 = &g_b12060 - &g_b12060;
	if ((x1_7 >> 3) + ((x1_7 >> 3) >>u 63) >> 1 == 0x00)
		return;
	<anonymous> * x2_13 = g_ptr11FE0;
	if (x2_13 == null)
		return;
	word64 x2_17;
	x2_13();
}

// 0000000000000BA8: void __do_global_dtors_aux()
void __do_global_dtors_aux()
{
	struct Eq_292 * x19_11 = &g_t12000;
	if ((word32) g_b12060 == 0x00)
	{
		if (g_qw11FA0 != 0x00)
			__cxa_finalize(&g_t12000, g_qw12058);
		deregister_tm_clones();
		x19_11->b0060 = 0x01;
	}
}

// 0000000000000BF0: void frame_dummy(Register word64 x29, Register word64 x30)
void frame_dummy(word64 x29, word64 x30)
{
	ptr64 fp;
	if (g_qw11DA0 != 0x00)
	{
		<anonymous> * x1_8 = g_ptr11FD8;
		if (x1_8 != null)
		{
			x1_8();
			register_tm_clones();
			return;
		}
	}
	register_tm_clones();
}

// 0000000000000C28: void new_tower(Register word32 w0)
void new_tower(word32 w0)
{
	ptr64 * x0_13 = calloc(0x01, (int64) w0 + 0x04 << 2);
	*x0_13 = x0_13 + 2;
}

// 0000000000000C58: void text(Register word32 w0, Register ui32 w1, Register word32 w2, Register (ptr64 char) x3)
// Called from:
//      main
void text(word32 w0, ui32 w1, word32 w2, char * x3)
{
	int32 w4_21 = *g_ptr11FD0;
	printf("\x1B[%d;%dH", w4_21 - w0 + 0x01, w4_21 + 0x01 + (w1 << 1) * (w4_21 + 0x01) - w2);
	word32 w19_20 = w2;
	if (w2 != 0x00)
	{
		do
		{
			printf("%s", x3);
			--w19_20;
		} while (w19_20 != 0x00);
	}
}

// 0000000000000CD0: void add_disk(Register ui32 w0, Register word32 w1)
void add_disk(ui32 w0, word32 w1)
{
	struct Eq_383 * x3_25 = g_ptr11FA8[(int64) w0];
	int32 * x1_22 = g_ptr11FD0;
	word32 w4_26 = x3_25->dw0008;
	word32 x2_27[] = x3_25->ptr0000;
	x3_25->dw0008 = w4_26 + 0x01;
	x2_27[(int64) w4_26] = w1;
	int32 w1_33 = *x1_22;
	printf("\x1B[%d;%dH", w1_33 - x3_25->dw0008 + 0x01, w1_33 + 0x01 + (w0 << 1) * (w1_33 + 0x01) - w1);
	word32 w19_21 = w1;
	if (w1 != 0x00)
	{
		do
		{
			printf("%s", "==");
			--w19_21;
		} while (w19_21 != 0x00);
	}
	usleep();
	fflush(*g_ptr11FB0);
}

// 0000000000000D90: void remove_disk(Register ui32 w0)
void remove_disk(ui32 w0)
{
	struct Eq_456 * x3_28 = g_ptr11FA8[(int64) w0];
	int32 w1_29 = *g_ptr11FD0;
	word32 w5_31 = x3_28->dw0008;
	word32 x6_33[] = x3_28->ptr0000;
	x3_28->dw0008 = w5_31 - 0x01;
	word32 w22_38 = x6_33[(int64) (w5_31 - 0x01)];
	printf("\x1B[%d;%dH", w1_29 - w5_31 + 0x01, w1_29 + 0x01 + (w0 << 1) * (w1_29 + 0x01) - w22_38);
	if (w22_38 != 0x00)
	{
		word32 w19_47 = w22_38;
		do
		{
			printf("%s", "  ");
			--w19_47;
		} while (w19_47 != 0x00);
	}
}

// 0000000000000E38: Register word64 move(Register word32 w0, Register out Eq_86 x22Out, Register out Eq_86 w23Out, Register out Eq_86 w26Out, Register out Eq_86 x27Out, Register out Eq_86 x28Out, Register out Eq_86 x29Out)
// Called from:
//      main
//      move
word64 move(word32 w0, union Eq_86 & x22Out, union Eq_86 & w23Out, union Eq_86 & w26Out, union Eq_86 & x27Out, union Eq_86 & x28Out, union Eq_86 & x29Out)
{
	word32 w24_15 = w0;
	if (w0 != 0x00)
	{
		do
		{
			word64 x23_82 = <invalid>;
			struct Eq_525 * x29_80;
			char * x22_89;
			char * x27_92;
			struct Eq_521 * x28_93;
			word32 w26_433;
			word32 w23_432;
			char * x21_88 = move(w24_15 - 0x01, out x22_89, out w23_432, out w26_433, out x27_92, out x28_93, out x29_80);
			ui32 w23_102 = (word32) x23_82;
			struct Eq_520 * x3_106 = x28_93->ptr0FA8[(int64) w23_102];
			int32 w1_107 = *g_ptr11FD0;
			word32 w5_108 = x3_106->dw0008;
			word32 x6_110[] = x3_106->ptr0000;
			x3_106->dw0008 = w5_108 - 0x01;
			word32 w19_116 = x6_110[(int64) (w5_108 - 0x01)];
			printf(x27_92, w1_107 - w5_108 + 0x01, w1_107 + 0x01 + (w23_102 << 1) * (w1_107 + 0x01) - w19_116);
			word64 x26_91 = <invalid>;
			ui32 w26_161 = (word32) x26_91;
			word32 w20_118 = w19_116;
			if (w19_116 != 0x00)
			{
				do
				{
					printf(x21_88, x22_89);
					--w20_118;
				} while (w20_118 != 0x00);
			}
			struct Eq_520 * x1_148 = x28_93->ptr0FA8[x29_80->qw0060];
			int32 * x2_144 = g_ptr11FD0;
			word32 w3_149 = x1_148->dw0008;
			word32 x4_150[] = x1_148->ptr0000;
			x1_148->dw0008 = w3_149 + 0x01;
			x4_150[(int64) w3_149] = w19_116;
			int32 w2_156 = *x2_144;
			printf(x27_92, w2_156 - x1_148->dw0008 + 0x01, w26_161 + w2_156 * w26_161 - w19_116);
			for (; w19_116 != 0x00; --w19_116)
				printf(x21_88, "==");
			usleep();
			fflush(*g_ptr11FB0);
			w24_15 = (word32) x24_236;
		} while (w24_15 != 0x00);
	}
	x22Out.u0 = <invalid>;
	w23Out.u0 = <invalid>;
	w26Out.u0 = <invalid>;
	x27Out.u0 = <invalid>;
	x28Out.u0 = <invalid>;
	x29Out.u0 = <invalid>;
	return <invalid>;
}

// 0000000000000FC8: void __libc_csu_init(Register word32 w0, Register word64 x1, Register word64 x2, Register word64 x24, Register word64 x30)
void __libc_csu_init(word32 w0, word64 x1, word64 x2, word64 x24, word64 x30)
{
	ptr64 fp;
	word32 x24_32_32_89 = SLICE(x24, word32, 32);
	_init();
	int64 x20_23 = 0x00011D98 - g_a11D90;
	ptr64 x29_49 = fp + -64;
	<anonymous> * x21_21[] = g_a11D90;
	word64 x22_30 = x2;
	word64 x23_34 = x1;
	int64 x20_36 = x20_23 >> 3;
	if (x20_23 >> 3 != 0x00)
	{
		int64 x19_37 = 0x00;
		word64 x24_133 = SEQ(x24_32_32_89, w0);
		do
		{
			word64 x3_67;
			x21_21[x19_37]();
			int64 x31_70 = x20_36 - x19_37;
		} while (x31_70 != 0x00);
	}
}

// 0000000000001040: void __libc_csu_fini()
void __libc_csu_fini()
{
}

