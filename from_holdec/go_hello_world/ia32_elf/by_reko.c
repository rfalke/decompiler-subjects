// subject_bss_0000.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

<anonymous> * _cgo_init = null; // 08144F80
<anonymous> * _cgo_notify_runtime_init_done = null; // 08144F84
<anonymous> * _cgo_thread_start = null; // 08144F88
word32 _cgo_yield = 0x00; // 08144F8C
Eq_4 os.Stderr = // 08144F90
	{
		0
	};
Eq_4 os.Stdin = // 08144F94
	{
		0
	};
Eq_4 os.Stdout = // 08144F98
	{
		0
	};
Eq_4 reflect.uint8Type = // 08144F9C
	{
		0
	};
word32 runtime._cgo_setenv = 0x00; // 08144FA0
word32 runtime._cgo_unsetenv = 0x00; // 08144FA4
struct Eq_19457 * runtime.allfin = null; // 08144FA8
Eq_4 runtime.allm = // 08144FAC
	{
		0
	};
Eq_4 runtime.argv = // 08144FB0
	{
		0
	};
Eq_4 runtime.bbuckets = // 08144FB4
	{
		0
	};
Eq_4 runtime.buckhash = // 08144FB8
	{
		0
	};
<anonymous> * runtime.cgoSymbolizer = null; // 08144FBC
<anonymous> * runtime.cgoTraceback = null; // 08144FC0
Eq_4 runtime.deferType = // 08144FC4
	{
		0
	};
struct Eq_19457 * runtime.finc = null; // 08144FC8
Eq_4 runtime.fing = // 08144FCC
	{
		0
	};
struct Eq_19457 * runtime.finq = null; // 08144FD0
Eq_4 runtime.main_init_done = // 08144FD4
	{
		0
	};
Eq_4 runtime.mbuckets = // 08144FD8
	{
		0
	};
word32 runtime.modulesSlice = 0x00; // 08144FDC
Eq_4 runtime.poolcleanup = // 08144FE0
	{
		0
	};
Eq_4 runtime.xbuckets = // 08144FE4
	{
		0
	};
Eq_4 sync.expunged = // 08144FE8
	{
		0
	};
Eq_4 time.unitMap = // 08144FEC
	{
		0
	};
Eq_4 unicode.Categories = // 08144FF0
	{
		0
	};
Eq_4 unicode.FoldCategory = // 08144FF4
	{
		0
	};
Eq_4 unicode.FoldScript = // 08144FF8
	{
		0
	};
Eq_4 unicode.Properties = // 08144FFC
	{
		0
	};
Eq_4 unicode.Scripts = // 08145000
	{
		0
	};
word32 g_dw8145008 = 0x00; // 08145008
Eq_4 g_t814500C = // 0814500C
	{
		0
	};
word32 g_dw8145010 = 0x00; // 08145010
Eq_4 g_t8145014 = // 08145014
	{
		0
	};
Eq_4 g_t8145018 = // 08145018
	{
		0
	};
Eq_4 g_t814501C = // 0814501C
	{
		0
	};
Eq_4 g_t8145020 = // 08145020
	{
		0
	};
Eq_4 g_t8145024 = // 08145024
	{
		0
	};
Eq_4 g_t8145028 = // 08145028
	{
		0
	};
Eq_4 g_t814502C = // 0814502C
	{
		0
	};
Eq_4 g_t8145030 = // 08145030
	{
		0
	};
Eq_4 g_t8145034 = // 08145034
	{
		0
	};
Eq_4 g_t8145038 = // 08145038
	{
		0
	};
Eq_4 g_t814503C = // 0814503C
	{
		0
	};
Eq_4 g_t8145040 = // 08145040
	{
		0
	};
Eq_4 g_t8145044 = // 08145044
	{
		0
	};
Eq_4 g_t8145048 = // 08145048
	{
		0
	};
Eq_4 g_t814504C = // 0814504C
	{
		0
	};
Eq_4 g_t8145050 = // 08145050
	{
		0
	};
Eq_4 g_t8145054 = // 08145054
	{
		0
	};
Eq_4 g_t8145058 = // 08145058
	{
		0
	};
Eq_4 g_t814505C = // 0814505C
	{
		0
	};
Eq_4 g_t8145060 = // 08145060
	{
		0
	};
Eq_4 g_t8145064 = // 08145064
	{
		0
	};
Eq_4 g_t8145068 = // 08145068
	{
		0
	};
Eq_4 g_t814506C = // 0814506C
	{
		0
	};
Eq_4 g_t8145070 = // 08145070
	{
		0
	};
Eq_4 g_t8145074 = // 08145074
	{
		0
	};
Eq_4 g_t8145078 = // 08145078
	{
		0
	};
Eq_4 g_t814507C = // 0814507C
	{
		0
	};
Eq_4 g_t8145080 = // 08145080
	{
		0
	};
Eq_4 g_t8145084 = // 08145084
	{
		0
	};
Eq_4 g_t8145088 = // 08145088
	{
		0
	};
Eq_4 g_t814508C = // 0814508C
	{
		0
	};
Eq_4 g_t8145090 = // 08145090
	{
		0
	};
Eq_4 g_t8145094 = // 08145094
	{
		0
	};
Eq_4 g_t8145098 = // 08145098
	{
		0
	};
Eq_4 g_t814509C = // 0814509C
	{
		0
	};
Eq_4 g_t81450A0 = // 081450A0
	{
		0
	};
Eq_4 g_t81450A4 = // 081450A4
	{
		0
	};
word32 g_dw81450B0 = 0x00; // 081450B0
Eq_4 g_t81450B4 = // 081450B4
	{
		0
	};
word32 g_dw81450B8 = 0x00; // 081450B8
Eq_4 g_t81450BC = // 081450BC
	{
		0
	};
word32 g_dw81450C0 = 0x00; // 081450C0
Eq_4 g_t81450C4 = // 081450C4
	{
		0
	};
ptr32 g_ptr81450C8 = 0x00; // 081450C8
word32 g_dw81450CC = 0x00; // 081450CC
word32 g_dw81450D0 = 0x00; // 081450D0
Eq_4 g_t81450D4 = // 081450D4
	{
		0
	};
word32 g_dw81450D8 = 0x00; // 081450D8
Eq_4 g_t81450DC = // 081450DC
	{
		0
	};
ptr32 g_ptr81450E0 = 0x00; // 081450E0
word32 g_dw81450E4 = 0x00; // 081450E4
Eq_4 g_t81450E8 = // 081450E8
	{
		0
	};
word32 g_dw81450EC = 0x00; // 081450EC
word32 g_dw81450F0 = 0x00; // 081450F0
byte g_b81450F8 = 0x00; // 081450F8
Eq_4 g_t81450FC = // 081450FC
	{
		0
	};
Eq_4 g_t8145100 = // 08145100
	{
		0
	};
Eq_4 g_t8145108 = // 08145108
	{
		0
	};
Eq_4 g_t814510C = // 0814510C
	{
		0
	};
Eq_4 g_t8145110 = // 08145110
	{
		0
	};
Eq_4 g_t8145118 = // 08145118
	{
		0
	};
Eq_4 g_t814511C = // 0814511C
	{
		0
	};
word32 g_dw8145120 = 0x00; // 08145120
Eq_4 g_t8145128 = // 08145128
	{
		0
	};
Eq_4 g_t814512C = // 0814512C
	{
		0
	};
word32 g_dw8145130 = 0x00; // 08145130
Eq_4 g_t814513C = // 0814513C
	{
		0
	};
word32 g_dw8145140 = 0x00; // 08145140
Eq_4 g_t8145158 = // 08145158
	{
		0
	};
Eq_4 g_t814515C = // 0814515C
	{
		0
	};
Eq_4 g_t8145160 = // 08145160
	{
		0
	};
Eq_4 g_t8145168 = // 08145168
	{
		0
	};
Eq_4 g_t814516C = // 0814516C
	{
		0
	};
word32 g_dw8145170 = 0x00; // 08145170
Eq_4 g_t8145178 = // 08145178
	{
		0
	};
Eq_4 g_t814517C = // 0814517C
	{
		0
	};
Eq_4 g_t8145180 = // 08145180
	{
		0
	};
Eq_4 g_t8145188 = // 08145188
	{
		0
	};
word32 g_dw814518C = 0x00; // 0814518C
word32 g_dw8145190 = 0x00; // 08145190
Eq_4 g_t81451A4 = // 081451A4
	{
		0
	};
Eq_4 g_t81451A8 = // 081451A8
	{
		0
	};
Eq_4 g_t81451AC = // 081451AC
	{
		0
	};
ui32 g_dw81451B0 = 0x00; // 081451B0
word32 (* g_ptr81451B4)[] = null; // 081451B4
Eq_4 g_t81451B8 = // 081451B8
	{
		0
	};
Eq_4 g_t81451C4 = // 081451C4
	{
		0
	};
Eq_4 g_t81451C8 = // 081451C8
	{
		0
	};
Eq_4 g_t81451CC = // 081451CC
	{
		0
	};
Eq_4 g_t81451D0 = // 081451D0
	{
		0
	};
Eq_4 g_t81451E4 = // 081451E4
	{
		0
	};
byte g_b81451E8 = 0x00; // 081451E8
word32 g_dw81451EC = 0x00; // 081451EC
word32 g_dw81451F0 = 0x00; // 081451F0
Eq_138780 g_a8145280[] = // 08145280
	{
	};
Eq_138781 g_a8145284[] = // 08145284
	{
	};
Eq_4 g_t81452A4 = // 081452A4
	{
		0
	};
byte g_b81452A8 = 0x00; // 081452A8
byte g_b81452A9 = 0x00; // 081452A9
byte g_b81452AA = 0x00; // 081452AA
word32 g_dw81452AC = 0x00; // 081452AC
word32 g_dw81452B0 = 0x00; // 081452B0
word32 g_dw81452B4 = 0x00; // 081452B4
Eq_4 g_t81452B8 = // 081452B8
	{
		0
	};
Eq_4 g_t81452BC = // 081452BC
	{
		0
	};
Eq_71428 g_t81452C0 = // 081452C0
	{
		0
	};
Eq_138782 g_a8145344[] = // 08145344
	{
	};
Eq_138783 g_a8145348[] = // 08145348
	{
	};
Eq_4 g_t81453E8 = // 081453E8
	{
		0
	};
word32 g_dw81453EC = 0x00; // 081453EC
Eq_4 g_t81453F4 = // 081453F4
	{
		0
	};
Eq_4 g_t81453F8 = // 081453F8
	{
		0
	};
Eq_4 g_t81453FC = // 081453FC
	{
		0
	};
Eq_4 g_t8145400 = // 08145400
	{
		0
	};
Eq_4 g_t8145404 = // 08145404
	{
		0
	};
Eq_4 g_t814540C = // 0814540C
	{
		0
	};
word32 g_dw8145410 = 0x00; // 08145410
word32 g_dw8145414 = 0x00; // 08145414
Eq_4 g_t8145418 = // 08145418
	{
		0
	};
Eq_4 g_t814541C = // 0814541C
	{
		0
	};
Eq_49232 g_t8145420 = // 08145420
	{
		0
	};
Eq_4 g_t8145428 = // 08145428
	{
		0
	};
Eq_4 g_t814542C = // 0814542C
	{
		0
	};
word32 g_dw8145430 = 0x00; // 08145430
Eq_4 g_t8145438 = // 08145438
	{
		0
	};
word32 g_a8145440[] = // 08145440
	{
	};
word32 g_dw8145454 = 0x00; // 08145454
Eq_4 g_t8145458 = // 08145458
	{
		0
	};
word32 g_dw814545C = 0x00; // 0814545C
word32 g_dw8145460 = 0x00; // 08145460
word32 g_dw8145464 = 0x00; // 08145464
Eq_4 g_t8145468 = // 08145468
	{
		0
	};
int32 g_dw814546C = 0; // 0814546C
word32 g_dw8145470 = 0x00; // 08145470
Eq_4 g_t8145474 = // 08145474
	{
		0
	};
Eq_4 g_t8145478 = // 08145478
	{
		0
	};
Eq_4 g_t814547C = // 0814547C
	{
		0
	};
uint32 g_dw8145480 = 0x00; // 08145480
ui32 g_dw8145484 = 0x00; // 08145484
ptr32 g_ptr81454A0 = 0x00; // 081454A0
ptr32 g_ptr81454A4 = 0x00; // 081454A4
ptr32 g_ptr81454A8 = 0x00; // 081454A8
ptr32 g_ptr81454AC = 0x00; // 081454AC
ptr32 g_ptr81454B8 = 0x00; // 081454B8
word32 g_dw8145580 = 0x00; // 08145580
word32 g_dw8145584 = 0x00; // 08145584
word32 g_dw8145588 = 0x00; // 08145588
word32 g_dw814558C = 0x00; // 0814558C
Eq_4 g_t81455D4 = // 081455D4
	{
		0
	};
Eq_33496 g_t81455DC = // 081455DC
	{
		null,
		null,
	};
Eq_4 g_t81455E8 = // 081455E8
	{
		0
	};
Eq_4 g_t81455EC = // 081455EC
	{
		0
	};
Eq_4 g_t81455F0 = // 081455F0
	{
		0
	};
Eq_4 g_t81455F4 = // 081455F4
	{
		0
	};
Eq_4 g_t81455F8 = // 081455F8
	{
		0
	};
Eq_4 g_t81455FC = // 081455FC
	{
		0
	};
Eq_4 g_t8145600 = // 08145600
	{
		0
	};
Eq_4 g_t8145604 = // 08145604
	{
		0
	};
word32 g_dw8145608 = 0x00; // 08145608
word32 g_dw814560C = 0x00; // 0814560C
byte g_b8145610 = 0x00; // 08145610
Eq_4 g_t8145614 = // 08145614
	{
		0
	};
Eq_4 g_t8145618 = // 08145618
	{
		0
	};
Eq_4 g_t814561C = // 0814561C
	{
		0
	};
Eq_4 g_t8145620 = // 08145620
	{
		0
	};
Eq_4 g_t8145624 = // 08145624
	{
		0
	};
byte g_b8145628 = 0x00; // 08145628
word32 g_dw814562C = 0x00; // 0814562C
word32 g_dw8145630 = 0x00; // 08145630
word32 g_dw8145634 = 0x00; // 08145634
Eq_4 g_t814563C = // 0814563C
	{
		0
	};
int8 g_b8145640 = 0; // 08145640
Eq_4 g_t8145644 = // 08145644
	{
		0
	};
ui32 g_dw8145648 = 0x00; // 08145648
Eq_4 g_t814564C = // 0814564C
	{
		0
	};
Eq_4 g_t8145650 = // 08145650
	{
		0
	};
Eq_4 g_t8145658 = // 08145658
	{
		0
	};
Eq_4 g_t814565C = // 0814565C
	{
		0
	};
Eq_4 g_t8145664 = // 08145664
	{
		0
	};
word32 g_dw8145668 = 0x00; // 08145668
Eq_22592 g_t814566C = // 0814566C
	{
		0
	};
Eq_4 g_t8145670 = // 08145670
	{
		0
	};
Eq_22616 g_t8145674 = // 08145674
	{
		0x00
	};
Eq_4 g_t8145678 = // 08145678
	{
		0
	};
Eq_22654 g_t814567C = // 0814567C
	{
		0x00
	};
Eq_4 g_t8145680 = // 08145680
	{
		0
	};
Eq_22659 g_t8145684 = // 08145684
	{
		0x00
	};
Eq_4 g_t8145688 = // 08145688
	{
		0
	};
uint32 g_dw814568C = 0x00; // 0814568C
int32 g_dw8145690 = 0; // 08145690
Eq_22606 g_t8145694 = // 08145694
	{
		0
	};
ui32 g_dw8145698 = 0x00; // 08145698
Eq_22621 g_t814569C = // 0814569C
	{
		0x00
	};
Eq_4 g_t81456A0 = // 081456A0
	{
		0
	};
Eq_4 g_t81456A4 = // 081456A4
	{
		0
	};
Eq_4 g_t81456A8 = // 081456A8
	{
		0
	};
Eq_4 g_t81456AC = // 081456AC
	{
		0
	};
Eq_4 g_t81456B0 = // 081456B0
	{
		0
	};
Eq_4 g_t81456B4 = // 081456B4
	{
		0
	};
Eq_4 g_t81456B8 = // 081456B8
	{
		0
	};
Eq_4 g_t81456BC = // 081456BC
	{
		0
	};
Eq_4 g_t81456C0 = // 081456C0
	{
		0
	};
ptr32 g_ptr81456E0 = 0x00; // 081456E0
Eq_4 g_t8145718 = // 08145718
	{
		0
	};
Eq_4530 g_t8145920 = // 08145920
	{

		{
			0
		},

		{
		},

		{
			0
		},
		0x00,
		0x00,
	};
Eq_4 g_t8145928 = // 08145928
	{
		0
	};
word32 g_a814592C[] = // 0814592C
	{
	};
uint32 g_dw81468CC = 0x00; // 081468CC
up32 g_dw81468D0 = 0x00; // 081468D0
word32 g_dw81468D4 = 0x00; // 081468D4
Eq_4 g_a81468E0[] = // 081468E0
	{
	};
Eq_4 g_a81478C0[] = // 081478C0
	{
	};
Eq_4 g_t81490F0 = // 081490F0
	{
		0
	};
Eq_4 g_t81490F4 = // 081490F4
	{
		0
	};
word32 * g_ptr81490FC = null; // 081490FC
int32 g_dw8149100 = 0; // 08149100
Eq_4 g_t8149108 = // 08149108
	{
		0
	};
Eq_4 g_t814910C = // 0814910C
	{
		0
	};
Eq_138597 g_a8149124[] = // 08149124
	{
	};
uint32 g_dw8149140 = 0x00; // 08149140
ui32 g_dw8149144 = 0x00; // 08149144
word32 g_dw8149148 = 0x00; // 08149148
Eq_4 g_t814914C = // 0814914C
	{
		0
	};
Eq_4 g_t8149158 = // 08149158
	{
		0
	};
Eq_4 g_t814915C = // 0814915C
	{
		0
	};
real64 g_r8149160 = 0.0; // 08149160
up32 g_dw8149168 = 0x00; // 08149168
word32 g_dw814916C = 0x00; // 0814916C
up32 g_dw8149170 = 0x00; // 08149170
word32 g_dw8149174 = 0x00; // 08149174
up32 g_dw8149178 = 0x00; // 08149178
word32 g_dw814917C = 0x00; // 0814917C
up32 g_dw8149180 = 0x00; // 08149180
word32 g_dw8149184 = 0x00; // 08149184
Eq_138673 g_a8149188[] = // 08149188
	{
	};
Eq_4 g_t81493A0 = // 081493A0
	{
		0
	};
Eq_4 g_t81493A8 = // 081493A8
	{
		0
	};
Eq_4 g_t81493AC = // 081493AC
	{
		0
	};
Eq_4 g_t81493B0 = // 081493B0
	{
		0
	};
word32 g_dw81493B4 = 0x00; // 081493B4
byte g_b81493B8 = 0x00; // 081493B8
word32 g_dw814B564 = 0x00; // 0814B564
Eq_4 g_t814B570 = // 0814B570
	{
		0
	};
word32 g_dw814B57C = 0x00; // 0814B57C
word32 g_dw814B588 = 0x00; // 0814B588
struct Eq_25380 * g_ptr814B594 = null; // 0814B594
word32 g_dw814B5A0 = 0x00; // 0814B5A0
word32 g_dw814B5AC = 0x00; // 0814B5AC
Eq_4 g_t814B5B8 = // 0814B5B8
	{
		0
	};
word32 g_dw814B5C4 = 0x00; // 0814B5C4
word32 g_dw814B5D0 = 0x00; // 0814B5D0
Eq_4 g_t814B5DC = // 0814B5DC
	{
		0
	};
word32 g_dw814B5E8 = 0x00; // 0814B5E8
Eq_4 g_t814F4C4 = // 0814F4C4
	{
		0
	};
byte g_b814F4C8 = 0x00; // 0814F4C8
byte g_b814F4C9 = 0x00; // 0814F4C9
Eq_4 g_t814F4D8 = // 0814F4D8
	{
		0
	};
Eq_4 g_t814F4DC = // 0814F4DC
	{
		0
	};
up32 g_dw814F4F8 = 0x00; // 0814F4F8
word32 g_dw814F4FC = 0x00; // 0814F4FC
struct Eq_72801 * g_ptr814F504 = null; // 0814F504
struct Eq_72250 * g_ptr814F508 = null; // 0814F508
struct Eq_72250 * g_ptr814F50C = null; // 0814F50C
word32 g_dw814F510 = 0x00; // 0814F510
// subject_data.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

<anonymous> ** internal/poll.CloseFunc = &g_ptr80E7D14; // 081422A0
<anonymous> ** runtime.cgo_yield = &g_ptr8144F8C; // 081422A4
Eq_4 unicode.ASCII_Hex_Digit = // 081422A8
	{
		80
	};
Eq_4 unicode.Adlam = // 081422AC
	{
		48
	};
Eq_4 unicode.Ahom = // 081422B0
	{
		80
	};
Eq_4 unicode.Anatolian_Hieroglyphs = // 081422B4
	{
		-48
	};
Eq_4 unicode.Arabic = // 081422B8
	{
		-16
	};
Eq_4 unicode.Armenian = // 081422BC
	{
		16
	};
Eq_4 unicode.Avestan = // 081422C0
	{
		48
	};
Eq_4 unicode.Balinese = // 081422C4
	{
		80
	};
Eq_4 unicode.Bamum = // 081422C8
	{
		112
	};
Eq_4 unicode.Bassa_Vah = // 081422CC
	{
		-112
	};
Eq_4 unicode.Batak = // 081422D0
	{
		-80
	};
Eq_4 unicode.Bengali = // 081422D4
	{
		-48
	};
Eq_4 unicode.Bhaiksuki = // 081422D8
	{
		-16
	};
Eq_4 unicode.Bidi_Control = // 081422DC
	{
		112
	};
Eq_4 unicode.Bopomofo = // 081422E0
	{
		16
	};
Eq_4 unicode.Brahmi = // 081422E4
	{
		80
	};
Eq_4 unicode.Braille = // 081422E8
	{
		112
	};
Eq_4 unicode.Buginese = // 081422EC
	{
		-112
	};
Eq_4 unicode.Buhid = // 081422F0
	{
		-80
	};
Eq_4 unicode.C = // 081422F4
	{
		-16
	};
Eq_4 unicode.Canadian_Aboriginal = // 081422F8
	{
		-48
	};
Eq_4 unicode.Carian = // 081422FC
	{
		-16
	};
Eq_4 unicode.Caucasian_Albanian = // 08142300
	{
		16
	};
Eq_4 unicode.Cc = // 08142304
	{
		112
	};
Eq_4 unicode.Cf = // 08142308
	{
		-112
	};
Eq_4 unicode.Chakma = // 0814230C
	{
		48
	};
Eq_4 unicode.Cham = // 08142310
	{
		80
	};
Eq_4 unicode.Cherokee = // 08142314
	{
		112
	};
Eq_4 unicode.Co = // 08142318
	{
		48
	};
Eq_4 unicode.Common = // 0814231C
	{
		-112
	};
Eq_4 unicode.Coptic = // 08142320
	{
		-80
	};
Eq_4 unicode.Cs = // 08142324
	{
		-80
	};
Eq_4 unicode.Cuneiform = // 08142328
	{
		-48
	};
Eq_4 unicode.Cypriot = // 0814232C
	{
		16
	};
Eq_4 unicode.Cyrillic = // 08142330
	{
		48
	};
Eq_4 unicode.Dash = // 08142334
	{
		-112
	};
Eq_4 unicode.Deprecated = // 08142338
	{
		-80
	};
Eq_4 unicode.Deseret = // 0814233C
	{
		80
	};
Eq_4 unicode.Devanagari = // 08142340
	{
		112
	};
Eq_4 unicode.Diacritic = // 08142344
	{
		-48
	};
Eq_4 unicode.Duployan = // 08142348
	{
		-112
	};
Eq_4 unicode.Egyptian_Hieroglyphs = // 0814234C
	{
		-80
	};
Eq_4 unicode.Elbasan = // 08142350
	{
		-48
	};
Eq_4 unicode.Ethiopic = // 08142354
	{
		-16
	};
Eq_4 unicode.Extender = // 08142358
	{
		-16
	};
Eq_4 unicode.Georgian = // 0814235C
	{
		16
	};
Eq_4 unicode.Glagolitic = // 08142360
	{
		48
	};
Eq_4 unicode.Gothic = // 08142364
	{
		80
	};
Eq_4 unicode.Grantha = // 08142368
	{
		112
	};
Eq_4 unicode.Greek = // 0814236C
	{
		-112
	};
Eq_4 unicode.Gujarati = // 08142370
	{
		-80
	};
Eq_4 unicode.Gurmukhi = // 08142374
	{
		-48
	};
Eq_4 unicode.Han = // 08142378
	{
		16
	};
Eq_4 unicode.Hangul = // 0814237C
	{
		48
	};
Eq_4 unicode.Hanunoo = // 08142380
	{
		80
	};
Eq_4 unicode.Hatran = // 08142384
	{
		112
	};
Eq_4 unicode.Hebrew = // 08142388
	{
		-112
	};
Eq_4 unicode.Hex_Digit = // 0814238C
	{
		16
	};
Eq_4 unicode.Hiragana = // 08142390
	{
		-80
	};
Eq_4 unicode.Hyphen = // 08142394
	{
		48
	};
Eq_4 unicode.IDS_Binary_Operator = // 08142398
	{
		80
	};
Eq_4 unicode.IDS_Trinary_Operator = // 0814239C
	{
		112
	};
Eq_4 unicode.Ideographic = // 081423A0
	{
		-80
	};
Eq_4 unicode.Imperial_Aramaic = // 081423A4
	{
		-48
	};
Eq_4 unicode.Inherited = // 081423A8
	{
		-16
	};
Eq_4 unicode.Inscriptional_Pahlavi = // 081423AC
	{
		16
	};
Eq_4 unicode.Inscriptional_Parthian = // 081423B0
	{
		48
	};
Eq_4 unicode.Javanese = // 081423B4
	{
		80
	};
Eq_4 unicode.Join_Control = // 081423B8
	{
		-48
	};
Eq_4 unicode.Kaithi = // 081423BC
	{
		-112
	};
Eq_4 unicode.Kannada = // 081423C0
	{
		-80
	};
Eq_4 unicode.Katakana = // 081423C4
	{
		-48
	};
Eq_4 unicode.Kayah_Li = // 081423C8
	{
		-16
	};
Eq_4 unicode.Kharoshthi = // 081423CC
	{
		16
	};
Eq_4 unicode.Khmer = // 081423D0
	{
		48
	};
Eq_4 unicode.Khojki = // 081423D4
	{
		80
	};
Eq_4 unicode.Khudawadi = // 081423D8
	{
		112
	};
Eq_4 unicode.L = // 081423DC
	{
		-112
	};
Eq_4 unicode.Lao = // 081423E0
	{
		-80
	};
Eq_4 unicode.Latin = // 081423E4
	{
		-48
	};
Eq_4 unicode.Lepcha = // 081423E8
	{
		-16
	};
Eq_4 unicode.Limbu = // 081423EC
	{
		16
	};
Eq_4 unicode.Linear_A = // 081423F0
	{
		48
	};
Eq_4 unicode.Linear_B = // 081423F4
	{
		80
	};
Eq_4 unicode.Lisu = // 081423F8
	{
		112
	};
Eq_4 unicode.Ll = // 081423FC
	{
		-48
	};
Eq_4 unicode.Lm = // 08142400
	{
		48
	};
Eq_4 unicode.Lo = // 08142404
	{
		-48
	};
Eq_4 unicode.Logical_Order_Exception = // 08142408
	{
		-16
	};
Eq_4 unicode.Lt = // 0814240C
	{
		-80
	};
Eq_4 unicode.Lu = // 08142410
	{
		-48
	};
Eq_4 unicode.Lycian = // 08142414
	{
		-112
	};
Eq_4 unicode.Lydian = // 08142418
	{
		-80
	};
Eq_4 unicode.M = // 0814241C
	{
		80
	};
Eq_4 unicode.Mahajani = // 08142420
	{
		-48
	};
Eq_4 unicode.Malayalam = // 08142424
	{
		-16
	};
Eq_4 unicode.Mandaic = // 08142428
	{
		16
	};
Eq_4 unicode.Manichaean = // 0814242C
	{
		80
	};
Eq_4 unicode.Marchen = // 08142430
	{
		112
	};
Eq_4 unicode.Mc = // 08142434
	{
		-112
	};
Eq_4 unicode.Me = // 08142438
	{
		48
	};
Eq_4 unicode.Meetei_Mayek = // 0814243C
	{
		-112
	};
Eq_4 unicode.Mende_Kikakui = // 08142440
	{
		-80
	};
Eq_4 unicode.Meroitic_Cursive = // 08142444
	{
		-48
	};
Eq_4 unicode.Meroitic_Hieroglyphs = // 08142448
	{
		-16
	};
Eq_4 unicode.Miao = // 0814244C
	{
		16
	};
Eq_4 unicode.Mn = // 08142450
	{
		80
	};
Eq_4 unicode.Modi = // 08142454
	{
		48
	};
Eq_4 unicode.Mongolian = // 08142458
	{
		80
	};
Eq_4 unicode.Mro = // 0814245C
	{
		112
	};
Eq_4 unicode.Multani = // 08142460
	{
		-112
	};
Eq_4 unicode.Myanmar = // 08142464
	{
		-48
	};
Eq_4 unicode.N = // 08142468
	{
		-80
	};
Eq_4 unicode.Nabataean = // 0814246C
	{
		-16
	};
Eq_4 unicode.Nd = // 08142470
	{
		-16
	};
Eq_4 unicode.New_Tai_Lue = // 08142474
	{
		16
	};
Eq_4 unicode.Newa = // 08142478
	{
		48
	};
Eq_4 unicode.Nko = // 0814247C
	{
		80
	};
Eq_4 unicode.Nl = // 08142480
	{
		16
	};
Eq_4 unicode.No = // 08142484
	{
		48
	};
Eq_4 unicode.Noncharacter_Code_Point = // 08142488
	{
		16
	};
Eq_4 unicode.Ogham = // 0814248C
	{
		112
	};
Eq_4 unicode.Ol_Chiki = // 08142490
	{
		-112
	};
Eq_4 unicode.Old_Hungarian = // 08142494
	{
		-80
	};
Eq_4 unicode.Old_Italic = // 08142498
	{
		-16
	};
Eq_4 unicode.Old_North_Arabian = // 0814249C
	{
		16
	};
Eq_4 unicode.Old_Permic = // 081424A0
	{
		48
	};
Eq_4 unicode.Old_Persian = // 081424A4
	{
		80
	};
Eq_4 unicode.Old_South_Arabian = // 081424A8
	{
		112
	};
Eq_4 unicode.Old_Turkic = // 081424AC
	{
		-112
	};
Eq_4 unicode.Oriya = // 081424B0
	{
		-80
	};
Eq_4 unicode.Osage = // 081424B4
	{
		-48
	};
Eq_4 unicode.Osmanya = // 081424B8
	{
		-16
	};
Eq_4 unicode.Other_Alphabetic = // 081424BC
	{
		48
	};
Eq_4 unicode.Other_Default_Ignorable_Code_Point = // 081424C0
	{
		80
	};
Eq_4 unicode.Other_Grapheme_Extend = // 081424C4
	{
		112
	};
Eq_4 unicode.Other_ID_Continue = // 081424C8
	{
		-112
	};
Eq_4 unicode.Other_ID_Start = // 081424CC
	{
		-80
	};
Eq_4 unicode.Other_Lowercase = // 081424D0
	{
		-48
	};
Eq_4 unicode.Other_Math = // 081424D4
	{
		-16
	};
Eq_4 unicode.Other_Uppercase = // 081424D8
	{
		16
	};
Eq_4 unicode.P = // 081424DC
	{
		-80
	};
Eq_4 unicode.Pahawh_Hmong = // 081424E0
	{
		16
	};
Eq_4 unicode.Palmyrene = // 081424E4
	{
		80
	};
Eq_4 unicode.Pattern_Syntax = // 081424E8
	{
		80
	};
Eq_4 unicode.Pattern_White_Space = // 081424EC
	{
		112
	};
Eq_4 unicode.Pau_Cin_Hau = // 081424F0
	{
		112
	};
Eq_4 unicode.Pc = // 081424F4
	{
		80
	};
Eq_4 unicode.Pd = // 081424F8
	{
		112
	};
Eq_4 unicode.Pe = // 081424FC
	{
		-112
	};
Eq_4 unicode.Pf = // 08142500
	{
		-48
	};
Eq_4 unicode.Phags_Pa = // 08142504
	{
		-112
	};
Eq_4 unicode.Phoenician = // 08142508
	{
		-80
	};
Eq_4 unicode.Pi = // 0814250C
	{
		-16
	};
Eq_4 unicode.Po = // 08142510
	{
		16
	};
Eq_4 unicode.Prepended_Concatenation_Mark = // 08142514
	{
		-112
	};
Eq_4 unicode.Ps = // 08142518
	{
		48
	};
Eq_4 unicode.Psalter_Pahlavi = // 0814251C
	{
		-48
	};
Eq_4 unicode.Quotation_Mark = // 08142520
	{
		-80
	};
Eq_4 unicode.Radical = // 08142524
	{
		-48
	};
Eq_4 unicode.Rejang = // 08142528
	{
		-16
	};
Eq_4 unicode.Runic = // 0814252C
	{
		16
	};
Eq_4 unicode.S = // 08142530
	{
		48
	};
Eq_4 unicode.Samaritan = // 08142534
	{
		48
	};
Eq_4 unicode.Saurashtra = // 08142538
	{
		80
	};
Eq_4 unicode.Sc = // 0814253C
	{
		80
	};
Eq_4 unicode.Sentence_Terminal = // 08142540
	{
		-16
	};
Eq_4 unicode.Sharada = // 08142544
	{
		112
	};
Eq_4 unicode.Shavian = // 08142548
	{
		-112
	};
Eq_4 unicode.Siddham = // 0814254C
	{
		-80
	};
Eq_4 unicode.SignWriting = // 08142550
	{
		-16
	};
Eq_4 unicode.Sinhala = // 08142554
	{
		16
	};
Eq_4 unicode.Sk = // 08142558
	{
		112
	};
Eq_4 unicode.Sm = // 0814255C
	{
		-112
	};
Eq_4 unicode.So = // 08142560
	{
		-80
	};
Eq_4 unicode.Soft_Dotted = // 08142564
	{
		16
	};
Eq_4 unicode.Sora_Sompeng = // 08142568
	{
		48
	};
Eq_4 unicode.Sundanese = // 0814256C
	{
		112
	};
Eq_4 unicode.Syloti_Nagri = // 08142570
	{
		-112
	};
Eq_4 unicode.Syriac = // 08142574
	{
		-80
	};
Eq_4 unicode.Tagalog = // 08142578
	{
		-48
	};
Eq_4 unicode.Tagbanwa = // 0814257C
	{
		-16
	};
Eq_4 unicode.Tai_Le = // 08142580
	{
		16
	};
Eq_4 unicode.Tai_Tham = // 08142584
	{
		48
	};
Eq_4 unicode.Tai_Viet = // 08142588
	{
		80
	};
Eq_4 unicode.Takri = // 0814258C
	{
		112
	};
Eq_4 unicode.Tamil = // 08142590
	{
		-112
	};
Eq_4 unicode.Tangut = // 08142594
	{
		-48
	};
Eq_4 unicode.Telugu = // 08142598
	{
		-16
	};
Eq_4 unicode.Terminal_Punctuation = // 0814259C
	{
		48
	};
Eq_4 unicode.Thaana = // 081425A0
	{
		16
	};
Eq_4 unicode.Thai = // 081425A4
	{
		48
	};
Eq_4 unicode.Tibetan = // 081425A8
	{
		80
	};
Eq_4 unicode.Tifinagh = // 081425AC
	{
		112
	};
Eq_4 unicode.Tirhuta = // 081425B0
	{
		-112
	};
Eq_4 unicode.Ugaritic = // 081425B4
	{
		-80
	};
Eq_4 unicode.Unified_Ideograph = // 081425B8
	{
		112
	};
Eq_4 unicode.Vai = // 081425BC
	{
		-16
	};
Eq_4 unicode.Variation_Selector = // 081425C0
	{
		-112
	};
Eq_4 unicode.Warang_Citi = // 081425C4
	{
		16
	};
Eq_4 unicode.White_Space = // 081425C8
	{
		-80
	};
Eq_4 unicode.Yi = // 081425CC
	{
		48
	};
Eq_4 unicode.Z = // 081425D0
	{
		-48
	};
Eq_4 unicode.Zl = // 081425D4
	{
		-16
	};
Eq_4 unicode.Zp = // 081425D8
	{
		16
	};
Eq_4 unicode.Zs = // 081425DC
	{
		-16
	};
Eq_4 unicode.foldCommon = // 081425E0
	{
		-112
	};
Eq_4 unicode.foldGreek = // 081425E4
	{
		-80
	};
Eq_4 unicode.foldInherited = // 081425E8
	{
		-48
	};
Eq_4 unicode.foldL = // 081425EC
	{
		-48
	};
Eq_4 unicode.foldLl = // 081425F0
	{
		-16
	};
Eq_4 unicode.foldLt = // 081425F4
	{
		16
	};
Eq_4 unicode.foldLu = // 081425F8
	{
		48
	};
Eq_4 unicode.foldM = // 081425FC
	{
		80
	};
Eq_4 unicode.foldMn = // 08142600
	{
		112
	};
ptr32 g_ptr8142620 = 135140150; // 08142620
word32 g_dw8142624 = 0x07; // 08142624
Eq_4 g_t8142628 = // 08142628
	{
		-112
	};
Eq_4 g_t8142630 = // 08142630
	{
		-112
	};
Eq_4 g_t8142638 = // 08142638
	{
		-112
	};
Eq_4 g_t8142640 = // 08142640
	{
		-112
	};
Eq_4 g_t8142648 = // 08142648
	{
		-112
	};
Eq_4 g_t8142650 = // 08142650
	{
		-112
	};
Eq_99008 g_t81426B4 = // 081426B4
	{
		27
	};
struct Eq_59635 * g_ptr81426C0 = &g_t81443A0; // 081426C0
int32 g_dw81426C4 = 0x0E; // 081426C4
struct Eq_48512 * g_ptr81426D0 = &g_t81371E0; // 081426D0
up32 g_dw81426D4 = 0x2A; // 081426D4
Eq_4 g_t81426E4 = // 081426E4
	{
		4
	};
up32 g_dw81426F4 = 0x10; // 081426F4
up32 g_dw8142704 = 0x0D; // 08142704
cup16 (* g_ptr8142710)[] = &g_a8136C40; // 08142710
Eq_100711 g_t8142714 = // 08142714
	{
		16
	};
cup16 (* g_ptr8142720)[] = &g_a8139F60; // 08142720
Eq_100711 g_t8142724 = // 08142724
	{
		0x008B
	};
cup16 (* g_ptr8142730)[] = &g_a8138D20; // 08142730
Eq_100711 g_t8142734 = // 08142734
	{
		82
	};
cup16 (* g_ptr8142740)[] = &g_a813E980; // 08142740
Eq_100711 g_t8142744 = // 08142744
	{
		462
	};
Eq_4 (* g_ptr8142750)[] = &g_a813FE80; // 08142750
Eq_100711 g_t8142754 = // 08142754
	{
		378
	};
Eq_138949 (* g_ptr8142760)[] = &g_a8144540; // 08142760
Eq_4 g_t8142764 = // 08142764
	{
		61
	};
Eq_4 g_t8142778 = // 08142778
	{
		0
	};
Eq_4 g_t81442B8 = // 081442B8
	{
		0
	};
word32 g_dw81442BC = 0x00; // 081442BC
Eq_138863 g_a81442C0[] = // 081442C0
	{
	};
ptr32 g_ptr8144340 = 0x080E7C68; // 08144340
ptr32 g_ptr8144348 = 0x080E7C6C; // 08144348
ptr32 g_ptr8144358 = 0x080E7CE4; // 08144358
Eq_59635 g_t81443A0 = // 081443A0
	{
		0x080E20D2,
		0x0E,
		0x08157720,
	};
Eq_138949 g_a8144540[] = // 08144540
	{
	};
Eq_138759 g_a8144820[] = // 08144820
	{
	};
Eq_138703 g_a8144828[] = // 08144828
	{
	};
Eq_139010 g_a8144B44[] = // 08144B44
	{
	};
// subject_noptrbss.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

cu8 g_b8157560 = 0x00; // 08157560
cu8 g_b8157561 = 0x00; // 08157561
cu8 g_b8157562 = 0x00; // 08157562
cu8 g_b8157563 = 0x00; // 08157563
cu8 g_b8157564 = 0x00; // 08157564
cu8 g_b8157565 = 0x00; // 08157565
byte g_b8157567 = 0x00; // 08157567
byte g_b8157568 = 0x00; // 08157568
byte g_b8157569 = 0x00; // 08157569
byte g_b815756A = 0x00; // 0815756A
byte g_b815756B = 0x00; // 0815756B
byte g_b815756C = 0x00; // 0815756C
Eq_4 g_t815756D = // 0815756D
	{
		0
	};
cu8 g_b815756E = 0x00; // 0815756E
byte g_b8157570 = 0x00; // 08157570
byte g_b8157571 = 0x00; // 08157571
byte g_b8157572 = 0x00; // 08157572
byte g_b8157573 = 0x00; // 08157573
byte g_b8157574 = 0x00; // 08157574
byte g_b8157575 = 0x00; // 08157575
byte g_b8157576 = 0x00; // 08157576
byte g_b8157577 = 0x00; // 08157577
byte g_b8157578 = 0x00; // 08157578
byte g_b815757B = 0x00; // 0815757B
byte g_b815757E = 0x00; // 0815757E
byte g_b815757F = 0x00; // 0815757F
byte g_b8157581 = 0x00; // 08157581
byte g_b8157582 = 0x00; // 08157582
byte g_b8157583 = 0x00; // 08157583
cu8 g_b8157584 = 0x00; // 08157584
cu8 g_b8157585 = 0x00; // 08157585
cu8 g_b8157586 = 0x00; // 08157586
cu8 g_b8157587 = 0x00; // 08157587
cu8 g_b8157588 = 0x00; // 08157588
Eq_4 runtime.allglen = // 0815758C
	{
		0
	};
word32 runtime.allglock = 0x00; // 08157590
Eq_4 runtime.argc = // 08157594
	{
		0
	};
Eq_4 runtime.bgsweepPC = // 08157598
	{
		0
	};
word32 runtime.bucketmem = 0x00; // 0815759C
Eq_4 runtime.cgocallback_gofuncPC = // 081575A0
	{
		0
	};
word32 runtime.chanrecvpc = 0x00; // 081575A4
word32 runtime.chansendpc = 0x00; // 081575A8
int32 runtime.crashing = 0; // 081575AC
word32 runtime.deadlock = 0x00; // 081575B0
word32 runtime.debuglock = 0x00; // 081575B4
Eq_4 runtime.externalthreadhandlerp = // 081575B8
	{
		0
	};
int32 runtime.extraMCount = 0; // 081575BC
word32 runtime.extraMWaiters = 0x00; // 081575C0
word32 runtime.extram = 0x00; // 081575C4
word32 runtime.fingCreate = 0x00; // 081575C8
word32 runtime.finlock = 0x00; // 081575CC
Eq_4 runtime.forcegchelperPC = // 081575D0
	{
		0
	};
word32 runtime.freezing = 0x00; // 081575D4
Eq_4 runtime.gcBgMarkWorkerPC = // 081575D8
	{
		0
	};
word32 runtime.gcBlackenEnabled = 0x00; // 081575DC
Eq_20602 runtime.gcpercent = // 081575E0
	{
		0
	};
word32 runtime.gcphase = 0x00; // 081575E4
Eq_4 runtime.goexitPC = // 081575E8
	{
		0
	};
Eq_4 runtime.gogoPC = // 081575EC
	{
		0
	};
Eq_4 runtime.gomaxprocs = // 081575F0
	{
		0
	};
word32 runtime.ifaceLock = 0x00; // 081575F4
word32 runtime.jmpdeferPC = 0x00; // 081575F8
Eq_4 runtime.mcallPC = // 081575FC
	{
		0
	};
Eq_4 runtime.morestackPC = // 08157600
	{
		0
	};
Eq_43114 g_t8157601 = // 08157601
	{

		{
			0
		},
	};
Eq_4 runtime.mstartPC = // 08157604
	{
		0
	};
Eq_4 runtime.ncpu = // 08157608
	{
		0
	};
word32 runtime.netpollInited = 0x00; // 0815760C
word32 runtime.netpollWaiters = 0x00; // 08157610
Eq_4 runtime.newprocs = // 08157614
	{
		0
	};
up32 runtime.panicking = 0x00; // 08157618
word32 runtime.paniclk = 0x00; // 0815761C
Eq_4 runtime.physPageSize = // 08157620
	{
		0
	};
uint32 runtime.printBacklogIndex = 0x00; // 08157624
word32 runtime.processorVersionInfo = 0x00; // 08157628
word32 runtime.proflock = 0x00; // 0815762C
Eq_4 runtime.rt0_goPC = // 08157630
	{
		0
	};
Eq_4 runtime.runfinqPC = // 08157634
	{
		0
	};
word32 runtime.runningPanicDefers = 0x00; // 08157638
Eq_4 runtime.sigpanicPC = // 0815763C
	{
		0
	};
up32 runtime.skipPC = 0x00; // 08157640
word32 runtime.stackpoolmu = 0x00; // 08157644
Eq_4 runtime.systemstackPC = // 08157648
	{
		0
	};
Eq_4 runtime.systemstack_switchPC = // 0815764C
	{
		0
	};
Eq_4 runtime.timerprocPC = // 08157650
	{
		0
	};
ui32 runtime.traceback_env = 0x00; // 08157654
word32 runtime.tracelock = 0x00; // 08157658
word32 runtime.zerobase = 0x00; // 0815765C
int32 syscall.Stdin = 0; // 08157660
word32 syscall._zero = 0x00; // 08157664
up32 g_dw8157668 = 0x00; // 08157668
up32 g_dw815766C = 0x00; // 0815766C
up32 g_dw8157670 = 0x00; // 08157670
int32 g_dw8157674 = 0; // 08157674
real64 g_r8157678 = 0.0; // 08157678
Eq_4 g_t8157680 = // 08157680
	{
		0
	};
Eq_4 g_t8157684 = // 08157684
	{
		0
	};
uint32 g_dw8157688 = 0x00; // 08157688
byte g_b815768C = 0x00; // 0815768C
up32 g_dw8157690 = 0x00; // 08157690
up32 g_dw8157694 = 0x00; // 08157694
Eq_4530 g_t8157698 = // 08157698
	{

		{
			0
		},

		{
		},

		{
			0
		},
		0x00,
		0x00,
	};
word32 g_dw815769C = 0x00; // 0815769C
Eq_23285 g_t81576A0 = // 081576A0
	{
		0x00
	};
ptr32 g_ptr81576A4 = 0x00; // 081576A4
ptr32 g_ptr81576A8 = 0x00; // 081576A8
ptr32 g_ptr81576AC = 0x00; // 081576AC
Eq_57041 g_t81576B0 = // 081576B0
	{
		0x00
	};
word32 g_dw81576B4 = 0x00; // 081576B4
Eq_4 g_t81576B8 = // 081576B8
	{
		0
	};
word32 g_dw81576BC = 0x00; // 081576BC
word32 g_dw81576C0 = 0x00; // 081576C0
word32 g_dw81576C4 = 0x00; // 081576C4
ui32 g_dw81576E0 = 0x00; // 081576E0
ui32 g_dw81576E4 = 0x00; // 081576E4
ui32 g_dw81576E8 = 0x00; // 081576E8
ui32 g_dw81576EC = 0x00; // 081576EC
Eq_4 g_t81576F0 = // 081576F0
	{
		0
	};
int8 g_b81576F4 = 0; // 081576F4
byte g_b81576F5 = 0x00; // 081576F5
int32 g_dw8157720 = 0; // 08157720
int32 g_dw8157724 = 0; // 08157724
int32 g_dw8157728 = 0; // 08157728
int32 g_dw815772C = 0; // 0815772C
int32 g_dw8157730 = 0; // 08157730
int32 g_dw8157734 = 0; // 08157734
int32 g_dw8157738 = 0; // 08157738
word32 g_dw815773C = 0x00; // 0815773C
int32 g_dw8157740 = 0; // 08157740
Eq_4 g_t8157744 = // 08157744
	{
		0
	};
word32 g_dw8157748 = 0x00; // 08157748
int32 g_dw815774C = 0; // 0815774C
int32 g_dw8157750 = 0; // 08157750
Eq_43135 g_t8157754 = // 08157754
	{
		0
	};
Eq_4 g_a8157764[] = // 08157764
	{
	};
byte g_b8157798 = 0x00; // 08157798
Eq_43806 g_t81577A0 = // 081577A0
	{

		{
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		}
	};
Eq_43806 g_t81577B0 = // 081577B0
	{

		{
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		}
	};
Eq_43806 g_t81577C0 = // 081577C0
	{

		{
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		}
	};
Eq_43806 g_t81577D0 = // 081577D0
	{

		{
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		}
	};
byte g_a81577E0[128] = // 081577E0
	{
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
		0x00,
	};
uint32 g_dw8157860 = 0x00; // 08157860
uint32 g_dw8157864 = 0x00; // 08157864
uint32 g_dw8157870 = 0x00; // 08157870
ui32 g_dw8157874 = 0x00; // 08157874
uint32 g_dw8157878 = 0x00; // 08157878
ui32 g_dw815787C = 0x00; // 0815787C
uint32 g_dw8157880 = 0x00; // 08157880
ui32 g_dw8157884 = 0x00; // 08157884
Eq_21818 g_t8157890 = // 08157890
	{
		0x00
	};
Eq_4 g_t8157894 = // 08157894
	{
		0
	};
real64 g_r81578A0 = 0.0; // 081578A0
real64 g_r81578A8 = 0.0; // 081578A8
word32 g_a8157940[] = // 08157940
	{
	};
word32 g_a8157A60[] = // 08157A60
	{
	};
up32 g_dw8158198 = 0x00; // 08158198
word32 g_dw815819C = 0x00; // 0815819C
Eq_4 g_t81581B8 = // 081581B8
	{
		0
	};
Eq_4 g_t81581BC = // 081581BC
	{
		0
	};
uint32 g_dw81581C0 = 0x00; // 081581C0
uint32 g_dw81581C4 = 0x00; // 081581C4
Eq_4 g_t81581C8 = // 081581C8
	{
		0
	};
uint32 g_dw81581CC = 0x00; // 081581CC
uint32 g_dw81581D0 = 0x00; // 081581D0
uint32 g_dw81581D4 = 0x00; // 081581D4
up32 g_dw81581D8 = 0x00; // 081581D8
word32 g_dw81581DC = 0x00; // 081581DC
Eq_35501 g_t81581E0 = // 081581E0
	{
		0x00,
		0x00,
	};
Eq_35501 g_t8158218 = // 08158218
	{
		0x00,
		0x00,
	};
Eq_4 g_t8158228 = // 08158228
	{
		0
	};
Eq_4 g_t815822C = // 0815822C
	{
		0
	};
word32 g_dw8158238 = 0x00; // 08158238
ui32 g_dw815823C = 0x00; // 0815823C
Eq_4 g_t8159240 = // 08159240
	{
		0
	};
word32 g_dw8159244 = 0x00; // 08159244
real64 g_r8159248 = 0.0; // 08159248
byte g_b8159250 = 0x00; // 08159250
Eq_138557 g_a8159254[] = // 08159254
	{
	};
up32 g_dw8159798 = 0x00; // 08159798
word32 g_dw815979C = 0x00; // 0815979C
real64 g_r81597A0 = 0.0; // 081597A0
Eq_4 g_t81597A8 = // 081597A8
	{
		0
	};
word24 g_n81597A9 = 0x00; // 081597A9
Eq_4 g_t81597AC = // 081597AC
	{
		0
	};
Eq_4 g_t81597B0 = // 081597B0
	{
		0
	};
Eq_4 g_t81597B4 = // 081597B4
	{
		0
	};
uint32 g_dw81597B8 = 0x00; // 081597B8
uint32 g_dw81597BC = 0x00; // 081597BC
Eq_4 g_t81597C0 = // 081597C0
	{
		0
	};
Eq_4 g_t81597C4 = // 081597C4
	{
		0
	};
// subject_noptrdata.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

byte g_b8136001 = 0x01; // 08136001
Eq_83748 g_t8136002 = // 08136002
	{
		575
	};
Eq_4 runtime.MemProfileRate = // 08136004
	{
		0
	};
Eq_83748 runtime.controlWord64trunc = // 08136008
	{
		0x0E3F
	};
Eq_4 runtime.epfd = // 0813600C
	{
		-1
	};
word32 runtime.lastmoduledatap = 135500832; // 08136010
Eq_4 runtime.maxstacksize = // 08136014
	{
		0
	};
word32 runtime.sizeof_C_MStats = 5528; // 08136018
word32 runtime.tls_entry_number = ~0x00; // 0813601C
ui32 runtime.traceback_cache = 0x08; // 08136020
word32 runtime.worldsema = 0x01; // 08136024
int32 syscall.Stderr = 2; // 08136028
int32 syscall.Stdout = 1; // 0813602C
word32 syscall.fcntl64Syscall = 55; // 08136030
word32 syscall.statictmp_48 = 11; // 08136034
word32 syscall.statictmp_49 = 22; // 08136038
word32 syscall.statictmp_50 = 0x02; // 0813603C
up32 g_dw81360F0 = 0xF08EB000; // 081360F0
int32 g_dw81360F4 = 27; // 081360F4
Eq_4 g_t81360F8 = // 081360F8
	{
		0
	};
Eq_4 g_t81360FC = // 081360FC
	{
		0
	};
Eq_23322 g_t8136118 = // 08136118
	{
		0x17,
		0x08,
		~0x7E,
	};
Eq_23322 g_t8136128 = // 08136128
	{
		0x34,
		11,
		~0x03FE,
	};
Eq_131703 g_t8136650 = // 08136650
	{
		null,
	};
Eq_12279 g_t81366B0 = // 081366B0
	{

		{
			96
		},
	};
cup16 g_a8136C40[] = // 08136C40
	{
	};
Eq_48512 g_t81371E0 = // 081371E0
	{

		{
			0x0066
		},

		{
			-2
		},

		{
			0
		},
		-76,
	};
Eq_4 g_a81386E0[] = // 081386E0
	{
	};
word16 g_a8138820[] = // 08138820
	{
	};
word16 g_w8138824 = 0x10; // 08138824
Eq_132166 g_t8138A00 = // 08138A00
	{
		null,
	};
up32 g_a8138AA0[] = // 08138AA0
	{
	};
cup16 g_a8138D20[] = // 08138D20
	{
	};
Eq_20279 g_t8139420 = // 08139420
	{

		{
			0
		},

		{
			-0x007C
		},

		{
			-96
		},

		{
			0x0068
		},

		{
			-0x0080
		},

		{
			80
		},

		{
			96
		},

		{
			-56
		},
		null,
	};
Eq_4 g_t8139454 = // 08139454
	{
		3
	};
word32 g_dw8139478 = 0x081597C8; // 08139478
word32 g_dw81394F8 = 0x00; // 081394F8
byte g_a81399E0[] = // 081399E0
	{
	};
real64 g_a8139C00[] = // 08139C00
	{
	};
cup16 g_a8139F60[] = // 08139F60
	{
	};
Eq_138634 g_a813A9C0[] = // 0813A9C0
	{
	};
Eq_138636 g_a813A9C1[] = // 0813A9C1
	{
	};
Eq_138635 g_a813A9C2[] = // 0813A9C2
	{
	};
Eq_138637 g_a813A9C4[] = // 0813A9C4
	{
	};
cup16 g_a813E980[] = // 0813E980
	{
	};
Eq_138953 g_a813F900[] = // 0813F900
	{
	};
Eq_138954 g_a813F904[] = // 0813F904
	{
	};
Eq_138952 g_a813F908[] = // 0813F908
	{
	};
Eq_4 g_a813FE80[] = // 0813FE80
	{
	};
// subject_rodata_0000.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

Eq_4 g_t80C7160 = // 080C7160
	{
		96
	};
word32 g_dw80C8F40 = 0x04; // 080C8F40
word32 g_dw80CA340 = 0x04; // 080CA340
Eq_2666 g_t80CA640 = // 080CA640
	{

		{
			96
		},
	};
Eq_2666 g_t80CA680 = // 080CA680
	{

		{
			96
		},
	};
// subject_rodata_0001.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

Eq_9673 g_t80CEBE0 = // 080CEBE0
	{
		&g_ptr8144340,
	};
Eq_10691 g_t80CF1A0 = // 080CF1A0
	{
		&g_ptr8144358,
	};
Eq_9673 g_t80CF3A0 = // 080CF3A0
	{
		&g_ptr8144340,
	};
Eq_9633 g_t80CFA40 = // 080CFA40
	{
		&g_t80CEBE0,
		0x4C,
	};
Eq_9769 g_t80CFAC0 = // 080CFAC0
	{
		&g_t80D3740,
		0x4C,
	};
Eq_10656 g_t80CFB40 = // 080CFB40
	{
		&g_t80CF1A0,

		{
			-32
		},
	};
Eq_10656 g_t80CFB80 = // 080CFB80
	{
		&g_t80CF1A0,

		{
			64
		},
	};
struct Eq_77582 * g_ptr80CFC00 = &g_t0004; // 080CFC00
Eq_9633 g_t80CFC40 = // 080CFC40
	{
		&g_t80CF3A0,
		0x4C,
	};
uint32 g_dw80D3500 = 0x08; // 080D3500
Eq_4 g_t80D3504 = // 080D3504
	{
		8
	};
Eq_4 g_t80D3508 = // 080D3508
	{
		77
	};
Eq_4 g_t80D350C = // 080D350C
	{
		7
	};
Eq_9812 g_t80D3740 = // 080D3740
	{
		&g_ptr8144348,
	};
word16 g_w80DDF44 = 0x04; // 080DDF44
word32 g_dw80DDF48 = 3811822038; // 080DDF48
// subject_rodata_0002.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

word32 g_dw80E0F22 = 0x656C6966; // 080E0F22
Eq_23744 g_t80E207E = // 080E207E
	{

		{
			71
		},
		&g_t656B726F,
	};
Eq_129732 g_t80E26DB = // 080E26DB
	{

		{
		},

		{

			{
				88
			},
		},
	};
Eq_129732 g_t80E26EC = // 080E26EC
	{

		{
		},

		{

			{
				0x78
			},
		},
	};
word32 g_dw80E30AB = 0x61706F67; // 080E30AB
Eq_138987 g_a80E7A41[] = // 080E7A41
	{
	};
Eq_138986 g_a80E7A42[] = // 080E7A42
	{
	};
<anonymous> * g_ptr80E7B18 = internal/poll.runtime_pollServerInit; // 080E7B18
Eq_4 g_t80E7B64 = // 080E7B64
	{
		64
	};
word24 g_n80E7B69 = 0x000808C2; // 080E7B69
Eq_4 g_t80E7B94 = // 080E7B94
	{
		48
	};
word32 g_dw80E7BA8 = 0x0808D400; // 080E7BA8
Eq_4 g_t80E7BB8 = // 080E7BB8
	{
		-64
	};
word32 g_dw80E7BDC = 0x080734D0; // 080E7BDC
Eq_4 g_t80E7BF0 = // 080E7BF0
	{
		-32
	};
Eq_4 g_t80E7BFC = // 080E7BFC
	{
		32
	};
word32 g_dw80E7C10 = 0x08072700; // 080E7C10
Eq_4 g_t80E7C14 = // 080E7C14
	{
		112
	};
Eq_4 g_t80E7C18 = // 080E7C18
	{
		16
	};
word32 g_dw80E7C1C = 0x08072640; // 080E7C1C
word32 g_dw80E7C28 = 134804448; // 080E7C28
Eq_4 g_t80E7C38 = // 080E7C38
	{
		96
	};
Eq_4 g_t80E7C40 = // 080E7C40
	{
		112
	};
Eq_4 g_t80E7C7C = // 080E7C7C
	{
		96
	};
Eq_4 g_t80E7C84 = // 080E7C84
	{
		-0x0080
	};
word32 g_dw80E7C9C = 0x08072350; // 080E7C9C
word32 g_dw80E7CAC = 0x0806BE50; // 080E7CAC
Eq_4 g_t80E7CB0 = // 080E7CB0
	{
		-0x0080
	};
Eq_4 g_t80E7CB8 = // 080E7CB8
	{
		64
	};
word32 g_dw80E7CBC = 0x0807BA40; // 080E7CBC
Eq_4 g_t80E7CC0 = // 080E7CC0
	{
		-48
	};
up32 g_dw80E7CD0 = 0x0808DC80; // 080E7CD0
Eq_4 g_t80E7CEC = // 080E7CEC
	{
		-64
	};
Eq_4 g_t80E7CF0 = // 080E7CF0
	{
		-48
	};
Eq_4 g_t80E7CF4 = // 080E7CF4
	{
		-0x0080
	};
<anonymous> * g_ptr80E7D14 = syscall.Close; // 080E7D14
// subject_rodata_0003.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

byte g_b80F1803 = 118; // 080F1803
byte g_b80F1804 = 0x2E; // 080F1804
real32 $f32.40d00000 = 6.5F; // 080F1808
word32 os.statictmp_4 = 22; // 080F180C
word32 reflect.statictmp_23 = 0x00; // 080F1810
word32 reflect.statictmp_36 = 0x00; // 080F1814
word32 runtime.mainPC = 0x0806D0E0; // 080F1818
word32 runtime.statictmp_15 = 0x01; // 080F181C
word32 runtime.statictmp_17 = 0x00; // 080F1820
word32 syscall.statictmp_24 = 22; // 080F1824
word32 syscall.statictmp_40 = 22; // 080F1828
real64 g_r80F1830 = 9.5367431640625e-07; // 080F1830
real64 g_r80F1838 = 0.25; // 080F1838
real64 g_r80F1848 = 0.875; // 080F1848
real64 g_r80F1850 = 0.95; // 080F1850
real64 g_r80F1858 = 1.0; // 080F1858
real64 g_r80F1860 = 4.0; // 080F1860
real64 g_r80F1868 = 5.0; // 080F1868
real64 g_r80F1870 = 10.0; // 080F1870
real64 g_r80F1878 = 26.0; // 080F1878
real64 g_r80F1880 = 100.0; // 080F1880
real64 g_r80F1890 = -0.0; // 080F1890
Eq_13241 g_t80F1E40 = // 080F1E40
	{
		0x20000000,
		0x10000000,
		0x08000000,
		0x00,
	};
Eq_88616 g_t80F1F40 = // 080F1F40
	{
		0x00,
		0x00,
	};
Eq_88616 g_t80F1F80 = // 080F1F80
	{
		0x00,
		0x00,
	};
Eq_4984 g_t80F1FC0 = // 080F1FC0
	{
		0x080E35E3,
		22,
	};
Eq_4984 g_t80F2000 = // 080F2000
	{
		0x080E35E3,
		22,
	};
Eq_5705 g_t80F20C0 = // 080F20C0
	{
		135143385,
		0x0D,
		0x00,
		0x00,
		0x080E0D8B,
	};
Eq_138924 g_a80F2120[] = // 080F2120
	{
	};
word128 g_a80F2220[] = // 080F2220
	{
	};
// subject_text_0000.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 08049000: void sync/atomic.(*Value).Load(Register (ptr32 Eq_2) gs, Stack ptr32 dwArg04)
// Called from:
//      sync.(*Map).Load
//      sync.(*Map).Store
//      sync.(*Map).LoadOrStore
//      sync.(*Map).dirtyLocked
void sync/atomic.(*Value).Load(struct Eq_2 * gs, ptr32 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	sync/atomic.LoadPointer();
	if (dwLoc08 == 0x00 || dwLoc08 == ~0x00)
		return;
	sync/atomic.LoadPointer();
}

// 08049090: void sync/atomic.(*Value).Store(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C)
// Called from:
//      sync.(*Map).Store
//      sync.(*Map).LoadOrStore
//      sync.(*Map).missLocked
void sync/atomic.(*Value).Store(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (dwArg08 == 0x00)
		runtime.gopanic(gs);
	else
	{
		do
		{
			sync/atomic.LoadPointer();
			if (dwLoc0C == 0x00)
			{
				sync/atomic.runtime_procPin(gs);
				sync/atomic.CompareAndSwapPointer(dwArg04, 0x00, ~0x00);
				dwLoc0C.u0 = 0x00;
				if (bLoc04 != 0x00)
				{
					sync/atomic.StorePointer((word32) dwArg04 + 4, dwArg0C);
					sync/atomic.StorePointer(dwArg04, dwArg08);
					sync/atomic.runtime_procUnpin(gs);
					return;
				}
				else
				{
					sync/atomic.runtime_procUnpin(gs);
					continue;
				}
			}
		} while (dwLoc0C == ~0x00);
		if (dwLoc0C != dwArg08)
			runtime.gopanic(gs);
		else
			sync/atomic.StorePointer((word32) dwArg04 + 4, dwArg0C);
	}
}

// 080491A0: Register word32 sync/atomic.CompareAndSwapInt32(Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C, Register out ptr32 ebpOut)
// Called from:
//      sync.(*Mutex).Lock
//      sync.(*Mutex).Unlock
word32 sync/atomic.CompareAndSwapInt32(Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C, ptr32 & ebpOut)
{
	ptr32 ebp_6;
	word32 ecx_7 = sync/atomic.CompareAndSwapUint32(dwArg04, dwArg08, dwArg0C, out ebp_6);
	ebpOut = ebp_6;
	return ecx_7;
}

// 080491B0: Register Eq_4 sync/atomic.CompareAndSwapUint32(Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C, Register out Eq_4 ebpOut)
// Called from:
//      sync/atomic.CompareAndSwapInt32
//      sync/atomic.CompareAndSwapUintptr
Eq_4 sync/atomic.CompareAndSwapUint32(Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C, union Eq_4 & ebpOut)
{
	__lock();
	word32 eax_8;
	__cmpxchg(*dwArg04, dwArg0C, dwArg08, out eax_8);
	ebpOut = dwArg04;
	return dwArg0C;
}

// 080491D0: void sync/atomic.CompareAndSwapUintptr(Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C)
// Called from:
//      sync/atomic.CompareAndSwapPointer
void sync/atomic.CompareAndSwapUintptr(Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C)
{
	word32 ebp_12;
	sync/atomic.CompareAndSwapUint32(dwArg04, dwArg08, dwArg0C, out ebp_12);
}

// 080491E0: Register word32 sync/atomic.CompareAndSwapUint64(Stack Eq_4 dwArg04, Stack Eq_4 qwArg08, Stack Eq_4 qwArg10, Register out ptr32 ebxOut)
// Called from:
//      internal/poll.(*fdMutex).increfAndClose
//      internal/poll.(*fdMutex).decref
//      internal/poll.(*fdMutex).rwlock
//      internal/poll.(*fdMutex).rwunlock
word32 sync/atomic.CompareAndSwapUint64(Eq_4 dwArg04, Eq_4 qwArg08, Eq_4 qwArg10, ptr32 & ebxOut)
{
	ptr32 dwArg10 = (word32) qwArg10;
	__lock();
	word64 edx_eax_19;
	__cmpxchg8b(qwArg08, *dwArg04, qwArg10, out edx_eax_19);
	ebxOut = dwArg10;
	return SLICE(edx_eax_19, word32, 32);
}

// 08049210: Register word32 sync/atomic.AddInt32(Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
// Called from:
//      sync.(*Mutex).Lock
//      sync.(*Mutex).Unlock
word32 sync/atomic.AddInt32(Eq_4 dwArg04, Eq_4 dwArg08)
{
	return sync/atomic.AddUint32(dwArg04, dwArg08);
}

// 08049220: Register Eq_4 sync/atomic.AddUint32(Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
// Called from:
//      sync/atomic.AddInt32
Eq_4 sync/atomic.AddUint32(Eq_4 dwArg04, Eq_4 dwArg08)
{
	__lock();
	*dwArg04 = __xadd(*dwArg04, dwArg08);
	return dwArg04;
}

// 08049240: void sync/atomic.LoadUint32()
// Called from:
//      sync/atomic.LoadUintptr
//      sync/atomic.LoadPointer
//      sync.(*Once).Do
void sync/atomic.LoadUint32()
{
}

// 08049250: void sync/atomic.LoadUint64(Stack Eq_4 dwArg04)
// Called from:
//      internal/poll.(*fdMutex).increfAndClose
//      internal/poll.(*fdMutex).decref
//      internal/poll.(*fdMutex).rwlock
//      internal/poll.(*fdMutex).rwunlock
void sync/atomic.LoadUint64(Eq_4 dwArg04)
{
	__emms();
}

// 08049270: void sync/atomic.LoadUintptr()
// Called from:
//      sync.(*Pool).getSlow
//      sync.(*Pool).pin
void sync/atomic.LoadUintptr()
{
	sync/atomic.LoadUint32();
}

// 08049280: void sync/atomic.LoadPointer()
// Called from:
//      sync/atomic.(*Value).Load
//      sync/atomic.(*Value).Store
//      sync.(*entry).load
//      sync.(*entry).tryStore
//      sync.(*entry).tryLoadOrStore
//      sync.(*entry).tryExpungeLocked
void sync/atomic.LoadPointer()
{
	sync/atomic.LoadUint32();
}

// 08049290: void sync/atomic.StoreUint32(Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
// Called from:
//      sync/atomic.StoreUintptr
void sync/atomic.StoreUint32(Eq_4 dwArg04, Eq_4 dwArg08)
{
	*dwArg04 = dwArg08;
}

// 080492A0: void sync/atomic.StoreUintptr(Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
// Called from:
//      sync/atomic.StorePointer
//      sync.(*Pool).pinSlow
void sync/atomic.StoreUintptr(Eq_4 dwArg04, Eq_4 dwArg08)
{
	sync/atomic.StoreUint32(dwArg04, dwArg08);
}

// 080492B0: void type..hash.sync/atomic.Value(Register (ptr32 Eq_2) gs, Register Eq_4 mm0, Stack (ptr32 Eq_205) dwArg04, Stack (ptr32 Eq_205) dwArg08)
void type..hash.sync/atomic.Value(struct Eq_2 * gs, Eq_4 mm0, union Eq_205 * dwArg04, union Eq_205 * dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	word128 xmm1_79;
	runtime.memhash(gs, mm0, dwArg04, dwArg08, 0x00, out xmm1_79);
	runtime.nilinterhash(gs, dwArg04, dwLoc04);
}

// 08049310: void type..eq.sync/atomic.Value(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_239) dwArg04, Stack (ptr32 Eq_240) dwArg08)
void type..eq.sync/atomic.Value(struct Eq_2 * gs, struct Eq_239 * dwArg04, struct Eq_240 * dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	word32 ecx_18 = dwArg04->dw0004;
	Eq_4 eax_19 = dwArg04->t0000;
	Eq_4 ebx_21 = dwArg08->t0004;
	if (eax_19 == dwArg08->t0000)
		runtime.efaceeq(gs, eax_19, ecx_18, ebx_21);
}

// 08049370: void runtime/internal/sys.Ctz64(Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
// Called from:
//      runtime.nextFreeFast
//      runtime.(*mspan).nextFreeIndex
void runtime/internal/sys.Ctz64(Eq_4 dwArg04, Eq_4 dwArg08)
{
	if (Test(NE,dwArg04 == 0x00))
		return;
	if (Test(EQ,dwArg08 == 0x00))
		;
}

// 080493A0: void runtime/internal/atomic.Load()
// Called from:
//      runtime/internal/atomic.Loaduintptr
//      runtime/internal/atomic.Loaduint
//      runtime.cgocallbackg1
//      runtime.chanrecv
//      runtime.notesleep
//      runtime.notetsleep_internal
//      runtime.gchelper
//      runtime.markroot
//      runtime.gcAssistAlloc1
//      runtime.gcParkAssist
//      runtime.sweepone
//      runtime.(*mspan).ensureSwept
//      runtime.(*gcSweepBuf).numBlocks
//      runtime.(*gcSweepBuf).block
//      runtime.netpollinited
//      runtime.recordForPanic
//      runtime.main
//      runtime.ready
//      runtime.readgstatus
//      runtime.stopTheWorldWithSema
//      runtime.startTheWorldWithSema
//      runtime.handoffp
//      runtime.findrunnable
//      runtime.pollWork
//      runtime.resetspinning
//      runtime.reentersyscall
//      runtime.entersyscall_sysmon
//      runtime.exitsyscallfast_pidle
//      runtime.exitsyscall0
//      runtime.newproc1
//      runtime.sigprof
//      runtime.sysmon
//      runtime.retake
//      runtime.schedtrace
//      runtime.runqempty
//      runtime.runqput
//      runtime.runqget
//      runtime.runqgrab
//      runtime.runqsteal
//      runtime.gotraceback
//      runtime.semrelease1
//      runtime.cansemacquire
//      runtime.sigfwdgo
//      runtime.sigsend
//      runtime.signal_ignored
void runtime/internal/atomic.Load()
{
}

// 080493B0: void runtime/internal/atomic.Loadp()
// Called from:
//      runtime.getitab
//      runtime.(*gcSweepBuf).push
//      runtime.(*gcSweepBuf).block
//      runtime.newMarkBits
//      runtime.activeModules
void runtime/internal/atomic.Loadp()
{
}

// 080493C0: Register word32 runtime/internal/atomic.Xadd64(Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C, Register out ptr32 ebxOut, Register out ptr32 ebpOut)
// Called from:
//      runtime/internal/atomic.Xaddint64
//      runtime.(*mcentral).cacheSpan
//      runtime.(*mcentral).uncacheSpan
//      runtime.(*mspan).sweep
//      runtime.(*gcWork).dispose
//      runtime.(*mheap).alloc_m
//      runtime.oneNewExtraM
//      runtime.newproc1
//      runtime.testAtomic64
word32 runtime/internal/atomic.Xadd64(Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C, ptr32 & ebxOut, ptr32 & ebpOut)
{
	do
	{
		Eq_4 ecx_9 = *dwArg04;
		Eq_4 ebp_14 = *((word32) dwArg04 + 4);
		ptr32 ebp_26;
		ptr32 ebx_27;
		word32 edx_29 = runtime/internal/atomic.Cas64(dwArg04, SEQ(ebp_14, ecx_9), SEQ(ebp_14, dwArg08) + SEQ(dwArg0C, ecx_9), out ebx_27, out ebp_26);
	} while (bLoc0C == 0x00);
	ebxOut = ebx_27;
	ebpOut = ebp_26;
	return edx_29;
}

// 08049420: void runtime/internal/atomic.Xchg64(Stack Eq_4 dwArg04, Stack Eq_4 qwArg08)
// Called from:
//      runtime.findrunnable
//      runtime.testAtomic64
void runtime/internal/atomic.Xchg64(Eq_4 dwArg04, Eq_4 qwArg08)
{
	do
	{
		word32 ebx_66;
		word32 ebp_67;
		runtime/internal/atomic.Cas64(dwArg04, *dwArg04, qwArg08, out ebx_66, out ebp_67);
	} while (bLoc0C == 0x00);
}

// 08049480: Register Eq_4 runtime/internal/atomic.Cas(Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C)
// Called from:
//      runtime/internal/atomic.Casuintptr
//      runtime.(*waitq).dequeue
//      runtime.(*cpuProfile).add
//      runtime.(*cpuProfile).addNonGo
//      runtime.lock
//      runtime.(*mcentral).cacheSpan
//      runtime.createfing
//      runtime.sweepone
//      runtime.(*mspan).ensureSwept
//      runtime.(*mheap).reclaimList
//      runtime.casfrom_Gscanstatus
//      runtime.castogscanstatus
//      runtime.casgstatus
//      runtime.stopTheWorldWithSema
//      runtime.forEachP
//      runtime.runSafePointFn
//      runtime.handoffp
//      runtime.wakep
//      runtime.entersyscall_gcwait
//      runtime.exitsyscallfast
//      runtime.retake
//      runtime.runqputslow
//      runtime.runqget
//      runtime.runqgrab
//      runtime.check
//      runtime.cansemacquire
//      runtime.sigsend
Eq_4 runtime/internal/atomic.Cas(Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C)
{
	__lock();
	word32 eax_8;
	__cmpxchg(*dwArg04, dwArg0C, dwArg08, out eax_8);
	return dwArg04;
}

// 080494A0: void runtime/internal/atomic.Casuintptr(Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C)
// Called from:
//      runtime.netpollblockcommit
//      runtime.netpollblock
//      runtime.netpollunblock
//      runtime.lockextra
//      runtime.(*guintptr).cas
void runtime/internal/atomic.Casuintptr(Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C)
{
	runtime/internal/atomic.Cas(dwArg04, dwArg08, dwArg0C);
}

// 080494B0: void runtime/internal/atomic.Loaduintptr()
// Called from:
//      runtime.gcMarkRootPrepare
//      runtime.(*gcSweepBuf).push
//      runtime.(*gcSweepBuf).block
//      runtime.(*gcBitsArena).tryAlloc
//      runtime.lockextra
//      runtime.runqempty
//      runtime.sigInstallGoHandler
//      runtime.raisebadsignal
//      runtime.sigfwdgo
//      runtime.newstack
void runtime/internal/atomic.Loaduintptr()
{
	runtime/internal/atomic.Load();
}

// 080494C0: void runtime/internal/atomic.Loaduint()
// Called from:
//      runtime.chanrecv
void runtime/internal/atomic.Loaduint()
{
	runtime/internal/atomic.Load();
}

// 080494D0: void runtime/internal/atomic.Storeuintptr(Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
// Called from:
//      runtime.(*gcSweepBuf).push
//      runtime.unlockextra
void runtime/internal/atomic.Storeuintptr(Eq_4 dwArg04, Eq_4 dwArg08)
{
	runtime/internal/atomic.Store(dwArg04, dwArg08);
}

// 080494E0: void runtime/internal/atomic.Xadduintptr(Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
// Called from:
//      runtime.(*gcBitsArena).tryAlloc
//      runtime.mSysStatInc
//      runtime.mSysStatDec
void runtime/internal/atomic.Xadduintptr(Eq_4 dwArg04, Eq_4 dwArg08)
{
	runtime/internal/atomic.Xadd(dwArg04, dwArg08);
}

// 080494F0: Register word32 runtime/internal/atomic.Loadint64(Stack Eq_4 dwArg04)
// Called from:
//      runtime.gcAssistAlloc
//      runtime.gcParkAssist
word32 runtime/internal/atomic.Loadint64(Eq_4 dwArg04)
{
	word64 mm0_13;
	return runtime/internal/atomic.Load64(dwArg04, out mm0_13);
}

// 08049500: Register word32 runtime/internal/atomic.Xaddint64(Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C, Register out ptr32 ebxOut, Register out ptr32 ebpOut)
// Called from:
//      runtime.(*gcControllerState).findRunnableGCWorker
//      runtime.gcMarkDone
//      runtime.gcBgMarkWorker
//      runtime.gcAssistAlloc
//      runtime.gcAssistAlloc1
//      runtime.gcFlushBgCredit
//      runtime.gcDrain
//      runtime.gcDrainN
//      runtime.(*gcWork).dispose
//      runtime.(*gcControllerState).findRunnableGCWorker.func1
word32 runtime/internal/atomic.Xaddint64(Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C, ptr32 & ebxOut, ptr32 & ebpOut)
{
	ptr32 ebp_6;
	ptr32 ebx_7;
	word32 edx_9 = runtime/internal/atomic.Xadd64(dwArg04, dwArg08, dwArg0C, out ebx_7, out ebp_6);
	ebxOut = ebx_7;
	ebpOut = ebp_6;
	return edx_9;
}

// 08049510: Register word32 runtime/internal/atomic.Cas64(Stack Eq_4 dwArg04, Stack Eq_4 qwArg08, Stack Eq_4 qwArg10, Register out ptr32 ebxOut, Register out Eq_4 ebpOut)
// Called from:
//      runtime/internal/atomic.Xadd64
//      runtime/internal/atomic.Xchg64
//      runtime.(*lfstack).push
//      runtime.(*lfstack).pop
//      runtime.sysmon
//      runtime.(*profAtomic).cas
//      runtime.(*profBuf).takeOverflow
//      runtime.(*profBuf).incrementOverflow
//      runtime.testAtomic64
word32 runtime/internal/atomic.Cas64(Eq_4 dwArg04, Eq_4 qwArg08, Eq_4 qwArg10, ptr32 & ebxOut, union Eq_4 & ebpOut)
{
	ptr32 dwArg10 = (word32) qwArg10;
	Eq_4 ebp_17 = dwArg04;
	if ((dwArg04 & 0x07) != 0x00)
		ebp_17 = null;
	__lock();
	word64 edx_eax_19;
	__cmpxchg8b(qwArg08, *ebp_17, qwArg10, out edx_eax_19);
	ebxOut = dwArg10;
	ebpOut = ebp_17;
	return SLICE(edx_eax_19, word32, 32);
}

// 08049540: void runtime/internal/atomic.Casp1(Stack (ptr32 Eq_4) dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C)
// Called from:
//      runtime.casp
//      runtime.adjustpointers
void runtime/internal/atomic.Casp1(union Eq_4 * dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C)
{
	__lock();
	word32 eax_8;
	__cmpxchg(*dwArg04, dwArg0C, dwArg08, out eax_8);
}

// 08049560: Register Eq_4 runtime/internal/atomic.Xadd(Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
// Called from:
//      runtime/internal/atomic.Xadduintptr
//      runtime.queuefinalizer
//      runtime.gcMarkDone
//      runtime.gcBgMarkWorker
//      runtime.gchelper
//      runtime.gcAssistAlloc1
//      runtime.gcDrain
//      runtime.gcDrainN
//      runtime.sweepone
//      runtime.(*gcSweepBuf).push
//      runtime.(*gcSweepBuf).pop
//      runtime.getfull
//      runtime.netpollblockcommit
//      runtime.netpollgoready
//      runtime.gopanic
//      runtime.startpanic_m
//      runtime.dopanic_m
//      runtime.needm
//      runtime.oneNewExtraM
//      runtime.dropm
//      runtime.lockextra
//      runtime.startm
//      runtime.gcstopm
//      runtime.findrunnable
//      runtime.resetspinning
//      runtime.goexit0
//      runtime.newproc1
//      runtime.pidleput
//      runtime.pidleget
//      runtime.(*rwmutex).rlock
//      runtime.(*rwmutex).runlock
//      runtime.semacquire1
//      runtime.semrelease1
Eq_4 runtime/internal/atomic.Xadd(Eq_4 dwArg04, Eq_4 dwArg08)
{
	__lock();
	*dwArg04 = __xadd(*dwArg04, dwArg08);
	return dwArg04;
}

// 08049580: Register Eq_4 runtime/internal/atomic.Xchg(Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
// Called from:
//      runtime/internal/atomic.Xchguintptr
//      runtime.lock
//      runtime.unlock
//      runtime.notewakeup
//      runtime.newextram
Eq_4 runtime/internal/atomic.Xchg(Eq_4 dwArg04, Eq_4 dwArg08)
{
	*dwArg04 = dwArg08;
	return dwArg04;
}

// 08049590: Register ptr32 runtime/internal/atomic.Xchguintptr(Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
// Called from:
//      runtime.netpollblock
ptr32 runtime/internal/atomic.Xchguintptr(Eq_4 dwArg04, Eq_4 dwArg08)
{
	return runtime/internal/atomic.Xchg(dwArg04, dwArg08);
}

// 080495A0: Register Eq_4 runtime/internal/atomic.StorepNoWB(Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
// Called from:
//      runtime.atomicstorep
//      runtime.(*gcSweepBuf).push
//      runtime.newMarkBits
//      runtime.nextMarkBitArenaEpoch
Eq_4 runtime/internal/atomic.StorepNoWB(Eq_4 dwArg04, Eq_4 dwArg08)
{
	*dwArg04 = dwArg08;
	return dwArg04;
}

// 080495B0: void runtime/internal/atomic.Store(Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
// Called from:
//      runtime/internal/atomic.Storeuintptr
//      runtime.(*cpuProfile).add
//      runtime.(*cpuProfile).addNonGo
//      runtime.(*mcentral).freeSpan
//      runtime.runfinq
//      runtime.setGCPhase
//      runtime.gcStart
//      runtime.gcMarkDone
//      runtime.gcMarkTermination
//      runtime.sweepone
//      runtime.(*mspan).sweep
//      runtime.(*mheap).alloc_m
//      runtime.(*mheap).grow
//      internal/poll.runtime_pollServerInit
//      runtime.forcegchelper
//      runtime.freezetheworld
//      runtime.stopTheWorldWithSema
//      runtime.forEachP
//      runtime.reentersyscall
//      runtime.entersyscall_sysmon
//      runtime.exitsyscallfast_pidle
//      runtime.exitsyscall0
//      runtime.procresize
//      runtime.sysmon
//      runtime.runqput
//      runtime.runqsteal
//      runtime/debug.SetTraceback
//      runtime.traceback1
void runtime/internal/atomic.Store(Eq_4 dwArg04, Eq_4 dwArg08)
{
	*dwArg04 = dwArg08;
}

// 080495C0: Register ptr32 runtime/internal/atomic.Load64(Stack Eq_4 dwArg04, Register out Eq_4 mm0Out)
// Called from:
//      runtime/internal/atomic.Loadint64
//      runtime.(*lfstack).push
//      runtime.(*lfstack).pop
//      runtime.(*lfstack).empty
//      runtime.(*gcControllerState).revise
//      runtime.gcSetTriggerRatio
//      runtime.gcTrigger.test
//      runtime.gcStart
//      runtime.gcResetMarkState
//      runtime.deductSweepCredit
//      runtime.blocksampled
//      sync.event
//      runtime.handoffp
//      runtime.sysmon
//      runtime.(*profAtomic).load
//      runtime.(*profBuf).hasOverflow
//      runtime.(*profBuf).takeOverflow
//      runtime.(*profBuf).incrementOverflow
//      runtime.testAtomic64
ptr32 runtime/internal/atomic.Load64(Eq_4 dwArg04, union Eq_4 & mm0Out)
{
	Eq_4 eax_12 = dwArg04;
	if ((dwArg04 & 0x07) != 0x00)
		eax_12 = null;
	Eq_4 mm0_14 = *eax_12;
	__emms();
	mm0Out = mm0_14;
	return fp + 0x08;
}

// 080495E0: void runtime/internal/atomic.Store64(Stack Eq_4 dwArg00, Stack Eq_4 dwArg04, Stack Eq_4 qwArg08)
// Called from:
//      runtime.gcSetTriggerRatio
//      runtime.gcMarkTermination
//      runtime.findrunnable
//      runtime.(*profBuf).incrementOverflow
//      runtime.testAtomic64
void runtime/internal/atomic.Store64(Eq_4 dwArg00, Eq_4 dwArg04, Eq_4 qwArg08)
{
	Eq_4 eax_13 = dwArg04;
	if ((dwArg04 & 0x07) != 0x00)
		eax_13 = null;
	*eax_13 = qwArg08;
	__emms();
	__lock();
	__xadd(dwArg00, 0x00);
}

// 08049610: void runtime/internal/atomic.Or8(Stack Eq_4 dwArg04, Stack ui8 bArg08)
// Called from:
//      runtime.mapiterinit
//      runtime.markBits.setMarked
//      runtime.heapBits.setCheckmarked
//      runtime.greyobject
//      runtime.check
void runtime/internal/atomic.Or8(Eq_4 dwArg04, ui8 bArg08)
{
	__lock();
	*dwArg04 |= bArg08;
}

// 08049620: void runtime/internal/atomic.And8(Stack (ptr32 byte) dwArg04, Stack byte bArg08)
// Called from:
//      runtime.check
void runtime/internal/atomic.And8(byte * dwArg04, byte bArg08)
{
	__lock();
	*dwArg04 &= bArg08;
}

// 08049630: void runtime.memhash0(Register (ptr32 Eq_516) gs)
void runtime.memhash0(struct Eq_516 * gs)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
}

// 08049660: void runtime.memhash8(Register (ptr32 Eq_2) gs, Register Eq_4 mm0, Stack (ptr32 Eq_205) dwArg04, Stack (ptr32 Eq_205) dwArg08)
void runtime.memhash8(struct Eq_2 * gs, Eq_4 mm0, union Eq_205 * dwArg04, union Eq_205 * dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	word128 xmm1_65;
	runtime.memhash(gs, mm0, dwArg04, dwArg08, 0x01, out xmm1_65);
}

// 080496B0: void runtime.memhash16(Register (ptr32 Eq_2) gs, Register Eq_4 mm0, Stack (ptr32 Eq_205) dwArg04, Stack (ptr32 Eq_205) dwArg08)
void runtime.memhash16(struct Eq_2 * gs, Eq_4 mm0, union Eq_205 * dwArg04, union Eq_205 * dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	word128 xmm1_65;
	runtime.memhash(gs, mm0, dwArg04, dwArg08, 0x02, out xmm1_65);
}

// 08049700: void runtime.memhash32(Register (ptr32 Eq_2) gs, Register Eq_4 mm0, Stack (ptr32 Eq_205) dwArg04, Stack (ptr32 Eq_205) dwArg08)
void runtime.memhash32(struct Eq_2 * gs, Eq_4 mm0, union Eq_205 * dwArg04, union Eq_205 * dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	word128 xmm1_65;
	runtime.memhash(gs, mm0, dwArg04, dwArg08, 0x04, out xmm1_65);
}

// 08049750: void runtime.memhash64(Register (ptr32 Eq_2) gs, Register Eq_4 mm0, Stack (ptr32 Eq_205) dwArg04, Stack (ptr32 Eq_205) dwArg08)
void runtime.memhash64(struct Eq_2 * gs, Eq_4 mm0, union Eq_205 * dwArg04, union Eq_205 * dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	word128 xmm1_65;
	runtime.memhash(gs, mm0, dwArg04, dwArg08, 0x08, out xmm1_65);
}

// 080497A0: void runtime.memhash128(Register (ptr32 Eq_2) gs, Register Eq_4 mm0, Stack (ptr32 Eq_205) dwArg04, Stack (ptr32 Eq_205) dwArg08)
void runtime.memhash128(struct Eq_2 * gs, Eq_4 mm0, union Eq_205 * dwArg04, union Eq_205 * dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	word128 xmm1_65;
	runtime.memhash(gs, mm0, dwArg04, dwArg08, 0x10, out xmm1_65);
}

// 080497F0: Register Eq_4 runtime.strhash(Register (ptr32 Eq_2) gs, Register Eq_4 mm0, Stack (ptr32 Eq_636) dwArg04, Stack (ptr32 Eq_205) dwArg08)
// Called from:
//      type..hash.runtime.modulehash
//      type..hash.runtime.Frame
//      type..hash.runtime.TypeAssertionError
//      type..hash.runtime.dbgVar
//      type..hash.runtime.sigTabT
//      type..hash.[2]string
//      type..hash.[3]string
//      type..hash.[4]string
//      type..hash.[5]string
//      type..hash.[6]string
//      type..hash.[9]string
//      type..hash.strconv.leftCheat
//      type..hash.[133]string
//      type..hash.os.file
//      type..hash.os.PathError
//      type..hash.reflect.Method
//      type..hash.reflect.ValueError
//      type..hash.[27]string
//      type..hash.struct { F uintptr; reflect.name string }
Eq_4 runtime.strhash(struct Eq_2 * gs, Eq_4 mm0, struct Eq_636 * dwArg04, union Eq_205 * dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	word128 xmm1_67;
	return runtime.memhash(gs, mm0, dwArg04->ptr0000, dwArg08, dwArg04->t0004, out xmm1_67);
}

// 08049840: Register Eq_4 runtime.f32hash(Register (ptr32 Eq_2) gs, Register Eq_4 mm0, Register Eq_662 xmm1, Stack (ptr32 Eq_205) dwArg04, Stack (ptr32 Eq_205) dwArg08, Register out Eq_662 xmm1Out)
// Called from:
//      runtime.c64hash
Eq_4 runtime.f32hash(struct Eq_2 * gs, Eq_4 mm0, Eq_662 xmm1, union Eq_205 * dwArg04, union Eq_205 * dwArg08, union Eq_662 & xmm1Out)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	uint128 xmm0_18 = (uint128) *dwArg04;
	Eq_662 xmm1_23 = __xorps(xmm1, xmm1);
	if ((real32) xmm0_18 != (real32) xmm1_23 || PARITY_EVEN((real32) xmm0_18 - (real32) xmm1_23))
	{
		if ((real32) xmm0_18 != (real32) xmm0_18 || PARITY_EVEN((real32) xmm0_18 - (real32) xmm0_18))
		{
			Eq_4 eax_79 = *((word32) gs->ptr0000->tFFFFFFFC + 24);
			int32 ecx_80 = *((word32) eax_79 + 0x0094);
			*((word32) eax_79 + 0x0094) = ecx_80 << 0x01 ^ ecx_80 >> 0x1F & 0xA8888EEF;
			xmm1Out = xmm1_23;
			return mm0;
		}
		else
		{
			Eq_662 xmm1_57;
			Eq_4 mm0_55 = runtime.memhash(gs, mm0, dwArg04, dwArg08, 0x04, out xmm1_57);
			xmm1Out = xmm1_57;
			return mm0_55;
		}
	}
	else
	{
		xmm1Out = xmm1_23;
		return mm0;
	}
}

// 08049900: Register Eq_4 runtime.f64hash(Register (ptr32 Eq_2) gs, Register Eq_4 mm0, Register Eq_662 xmm1, Stack (ptr32 Eq_205) dwArg04, Stack (ptr32 Eq_205) dwArg08, Register out Eq_662 xmm1Out)
// Called from:
//      runtime.c128hash
//      type..hash.runtime.MemStats
//      type..hash.runtime.gcControllerState
//      type..hash.runtime.mstats
//      type..hash.[33]float64
Eq_4 runtime.f64hash(struct Eq_2 * gs, Eq_4 mm0, Eq_662 xmm1, union Eq_205 * dwArg04, union Eq_205 * dwArg08, union Eq_662 & xmm1Out)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	uint128 xmm0_18 = (uint128) *dwArg04;
	Eq_662 xmm1_23 = __xorps(xmm1, xmm1);
	if ((real64) xmm0_18 != (real64) xmm1_23 || PARITY_EVEN((real64) xmm0_18 - (real64) xmm1_23))
	{
		if ((real64) xmm0_18 != (real64) xmm0_18 || PARITY_EVEN((real64) xmm0_18 - (real64) xmm0_18))
		{
			Eq_4 eax_79 = *((word32) gs->ptr0000->tFFFFFFFC + 24);
			int32 ecx_80 = *((word32) eax_79 + 0x0094);
			*((word32) eax_79 + 0x0094) = ecx_80 << 0x01 ^ ecx_80 >> 0x1F & 0xA8888EEF;
			xmm1Out = xmm1_23;
			return mm0;
		}
		else
		{
			Eq_662 xmm1_57;
			Eq_4 mm0_55 = runtime.memhash(gs, mm0, dwArg04, dwArg08, 0x08, out xmm1_57);
			xmm1Out = xmm1_57;
			return mm0_55;
		}
	}
	else
	{
		xmm1Out = xmm1_23;
		return mm0;
	}
}

// 080499C0: void runtime.c64hash(Register (ptr32 Eq_2) gs, Register Eq_4 mm0, Register Eq_662 xmm1, Stack (ptr32 Eq_205) dwArg04, Stack (ptr32 Eq_205) dwArg08)
void runtime.c64hash(struct Eq_2 * gs, Eq_4 mm0, Eq_662 xmm1, union Eq_205 * dwArg04, union Eq_205 * dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_662 xmm1_32;
	word128 xmm1_96;
	runtime.f32hash(gs, runtime.f32hash(gs, mm0, xmm1, dwArg04, dwArg08, out xmm1_32), xmm1_32, (char *) dwArg04 + 4, dwLoc04, out xmm1_96);
}

// 08049A20: void runtime.c128hash(Register (ptr32 Eq_2) gs, Register Eq_4 mm0, Register Eq_662 xmm1, Stack (ptr32 Eq_205) dwArg04, Stack (ptr32 Eq_205) dwArg08)
void runtime.c128hash(struct Eq_2 * gs, Eq_4 mm0, Eq_662 xmm1, union Eq_205 * dwArg04, union Eq_205 * dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_662 xmm1_32;
	word128 xmm1_96;
	runtime.f64hash(gs, runtime.f64hash(gs, mm0, xmm1, dwArg04, dwArg08, out xmm1_32), xmm1_32, (char *) dwArg04 + 8, dwLoc04, out xmm1_96);
}

// 08049A80: void runtime.interhash(Register (ptr32 Eq_2) gs, Stack (ptr32 (ptr32 Eq_890)) dwArg04, Stack (ptr32 Eq_205) dwArg08)
// Called from:
//      type..hash.os.PathError
//      type..hash.reflect.Method
void runtime.interhash(struct Eq_2 * gs, struct Eq_890 ** dwArg04, union Eq_205 * dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	struct Eq_890 * ecx_18 = *dwArg04;
	if (ecx_18 == null)
		return;
	Eq_4 ecx_26 = ecx_18->t0004;
	Eq_4 edx_28 = **((word32) ecx_26 + 16);
	if (edx_28 == 0x00)
	{
		runtime.(*_type).string(gs, ecx_26);
		runtime.concatstring2(gs, 0x00);
		runtime.convT2Estring(gs, 0x080D1E80, fp - 0x08);
		runtime.gopanic(gs);
	}
	else if ((*((word32) ecx_26 + 0x0F) & 0x20) == 0x00)
	{
		Eq_4 eax_109 = *edx_28;
		word32 edx_113;
		eax_109();
	}
	else
	{
		Eq_4 eax_127 = *edx_28;
		word32 edx_130;
		eax_127();
	}
}

// 08049BA0: void runtime.nilinterhash(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_205) dwArg04, Stack word32 dwArg08)
// Called from:
//      type..hash.sync/atomic.Value
//      type..hash.runtime._panic
//      type..hash.struct { reflect.b bool; reflect.x interface {} }
void runtime.nilinterhash(struct Eq_2 * gs, union Eq_205 * dwArg04, word32 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 ecx_18 = *dwArg04;
	if (ecx_18 == 0x00)
		return;
	Eq_4 edx_27 = **((word32) ecx_18 + 16);
	if (edx_27 == 0x00)
	{
		runtime.(*_type).string(gs, ecx_18);
		runtime.concatstring2(gs, 0x00);
		runtime.convT2Estring(gs, 0x080D1E80, fp - 0x08);
		runtime.gopanic(gs);
	}
	else if ((*((word32) ecx_18 + 0x0F) & 0x20) == 0x00)
	{
		Eq_4 eax_108 = *edx_27;
		word32 edx_112;
		eax_108();
	}
	else
	{
		Eq_4 eax_126 = *edx_27;
		word32 edx_129;
		eax_126();
	}
}

// 08049CB0: void runtime.memequal0(Register (ptr32 Eq_1004) gs)
void runtime.memequal0(struct Eq_1004 * gs)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
}

// 08049CD0: void runtime.memequal8(Register (ptr32 Eq_1017) gs)
void runtime.memequal8(struct Eq_1017 * gs)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
}

// 08049D10: void runtime.memequal16(Register (ptr32 Eq_1030) gs)
void runtime.memequal16(struct Eq_1030 * gs)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
}

// 08049D50: void runtime.memequal32(Register (ptr32 Eq_1043) gs)
void runtime.memequal32(struct Eq_1043 * gs)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
}

// 08049D80: void runtime.memequal64(Register (ptr32 Eq_1056) gs)
void runtime.memequal64(struct Eq_1056 * gs)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
}

// 08049DC0: void runtime.memequal128(Register (ptr32 Eq_1069) gs, Stack (ptr32 Eq_1070) dwArg04, Stack (ptr32 Eq_1071) dwArg08)
// Called from:
//      type..eq.runtime.traceStack
void runtime.memequal128(struct Eq_1069 * gs, struct Eq_1070 * dwArg04, struct Eq_1071 * dwArg08)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	word32 ecx_17 = dwArg04->dw0004;
	word32 edx_18 = dwArg04->dw0000;
	((int8) (ecx_17 == dwArg08->dw0004) & (int8) (edx_18 == dwArg08->dw0000)) == 0x00;
}

// 08049E20: void runtime.f32equal(Register (ptr32 Eq_1105) gs)
void runtime.f32equal(struct Eq_1105 * gs)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
}

// 08049E60: void runtime.f64equal(Register (ptr32 Eq_1118) gs)
void runtime.f64equal(struct Eq_1118 * gs)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
}

// 08049EA0: void runtime.c64equal(Register (ptr32 Eq_1131) gs)
void runtime.c64equal(struct Eq_1131 * gs)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
}

// 08049EF0: void runtime.c128equal(Register (ptr32 Eq_1144) gs)
void runtime.c128equal(struct Eq_1144 * gs)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
}

// 08049F50: void runtime.strequal(Register (ptr32 Eq_1157) gs, Stack (ptr32 Eq_1158) dwArg04, Stack (ptr32 Eq_1159) dwArg08)
void runtime.strequal(struct Eq_1157 * gs, struct Eq_1158 * dwArg04, struct Eq_1159 * dwArg08)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	Eq_4 ecx_18 = dwArg04->t0004;
	Eq_4 eax_19 = dwArg04->t0000;
	Eq_4 edx_22 = dwArg08->t0000;
	if (ecx_18 == dwArg08->t0004)
	{
		word32 esi_85;
		word32 ebx_84;
		word32 edi_86;
		runtime.eqstring(edx_22, eax_19, ecx_18, edx_22, out ebx_84, out esi_85, out edi_86);
	}
}

// 08049FB0: void runtime.interequal(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_1205) dwArg04, Stack (ptr32 Eq_1206) dwArg08)
void runtime.interequal(struct Eq_2 * gs, struct Eq_1205 * dwArg04, struct Eq_1206 * dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 ecx_18 = dwArg04->t0004;
	Eq_4 eax_19 = dwArg04->t0000;
	Eq_4 edx_22 = dwArg08->t0004;
	if (eax_19 == dwArg08->t0000)
		runtime.ifaceeq(gs, eax_19, ecx_18, edx_22);
}

// 0804A010: void runtime.nilinterequal(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_1243) dwArg04, Stack (ptr32 Eq_1244) dwArg08)
void runtime.nilinterequal(struct Eq_2 * gs, struct Eq_1243 * dwArg04, struct Eq_1244 * dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	word32 ecx_18 = dwArg04->dw0004;
	Eq_4 eax_19 = dwArg04->t0000;
	Eq_4 edx_22 = dwArg08->t0004;
	if (eax_19 == dwArg08->t0000)
		runtime.efaceeq(gs, eax_19, ecx_18, edx_22);
}

// 0804A070: void runtime.efaceeq(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack word32 dwArg08, Stack Eq_4 dwArg0C)
// Called from:
//      type..eq.sync/atomic.Value
//      runtime.nilinterequal
//      type..eq.runtime._panic
//      type..eq.struct { reflect.b bool; reflect.x interface {} }
void runtime.efaceeq(struct Eq_2 * gs, Eq_4 dwArg04, word32 dwArg08, Eq_4 dwArg0C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (dwArg04 == 0x00)
		return;
	Eq_4 edx_25 = *((word32) *((word32) dwArg04 + 16) + 4);
	if (edx_25 == 0x00)
	{
		runtime.(*_type).string(gs, dwArg04);
		runtime.concatstring2(gs, 0x00);
		runtime.convT2Estring(gs, 0x080D1E80, fp - 0x08);
		runtime.gopanic(gs);
	}
	else if ((*((word32) dwArg04 + 0x0F) & 0x20) == 0x00)
	{
		Eq_4 eax_103 = *edx_25;
		word32 edx_107;
		eax_103();
	}
	else
	{
		Eq_4 eax_118 = *edx_25;
		word32 edx_121;
		eax_118();
	}
}

// 0804A170: void runtime.ifaceeq(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C)
// Called from:
//      runtime.interequal
//      os.(*File).Write
//      os.(*file).close
//      type..eq.os.PathError
//      reflect.haveIdenticalType
//      type..eq.reflect.Method
void runtime.ifaceeq(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (dwArg04 == 0x00)
		return;
	Eq_4 eax_24 = *((word32) dwArg04 + 4);
	Eq_4 edx_26 = *((word32) *((word32) eax_24 + 16) + 4);
	if (edx_26 == 0x00)
	{
		runtime.(*_type).string(gs, eax_24);
		runtime.concatstring2(gs, 0x00);
		runtime.convT2Estring(gs, 0x080D1E80, fp - 0x08);
		runtime.gopanic(gs);
	}
	else if ((*((word32) eax_24 + 0x0F) & 0x20) == 0x00)
	{
		Eq_4 eax_104 = *edx_26;
		word32 edx_108;
		eax_104();
	}
	else
	{
		Eq_4 eax_119 = *edx_26;
		word32 edx_122;
		eax_119();
	}
}

// 0804A270: void runtime.alginit(Register (ptr32 Eq_2) gs, Register Eq_4 mm0)
// Called from:
//      runtime.schedinit
void runtime.alginit(struct Eq_2 * gs, Eq_4 mm0)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (g_b8157576 == 0x00 || (g_b8157581 == 0x00 || g_b815757F == 0x00))
	{
		runtime.getRandomData(gs, mm0, 135624416, 0x10);
		g_dw81576E0 |= 0x01;
		g_dw81576E4 |= 0x01;
		g_dw81576E8 |= 0x01;
		g_dw81576EC |= 0x01;
	}
	else
	{
		g_b8157582 = 0x01;
		if (g_t81576F0 == 0x00)
		{
			g_ptr8144340 = 0x080E7B80;
			g_ptr8144348 = 0x080E7B84;
			g_ptr8144358 = 0x080E7B88;
		}
		else
		{
			runtime.writebarrierptr(0x08144340, 0x080E7B80);
			runtime.writebarrierptr(0x08144348, 0x080E7B84);
			runtime.writebarrierptr(135545688, 0x080E7B88);
		}
		runtime.getRandomData(gs, mm0, 0x081577A0, 0x40);
	}
}

// 0804A3C0: Register word32 runtime.atomicstorep(Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
// Called from:
//      runtime.cgocallbackg1
//      runtime.additab
//      internal/poll.runtime_pollUnblock
//      runtime.mcommoninit
//      runtime.procresize
//      runtime.modulesinit
//      runtime.(*traceStackTable).put
word32 runtime.atomicstorep(Eq_4 dwArg04, Eq_4 dwArg08)
{
	runtime.writebarrierptr_prewrite(dwArg08);
	return runtime/internal/atomic.StorepNoWB(dwArg04, dwArg08);
}

// 0804A400: void runtime.casp(Stack (ptr32 Eq_4) dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C)
// Called from:
//      runtime.check
void runtime.casp(union Eq_4 * dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C)
{
	runtime.writebarrierptr_prewrite(dwArg0C);
	runtime/internal/atomic.Casp1(dwArg04, dwArg08, dwArg0C);
}

// 0804A450: void sync/atomic.StorePointer(Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
// Called from:
//      sync/atomic.(*Value).Store
//      sync.(*entry).storeLocked
//      sync.(*Pool).pinSlow
void sync/atomic.StorePointer(Eq_4 dwArg04, Eq_4 dwArg08)
{
	runtime.writebarrierptr_prewrite(dwArg08);
	sync/atomic.StoreUintptr(dwArg04, dwArg08);
}

// 0804A490: void sync/atomic.CompareAndSwapPointer(Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C)
// Called from:
//      sync/atomic.(*Value).Store
//      sync.(*entry).tryStore
//      sync.(*entry).unexpungeLocked
//      sync.(*entry).tryLoadOrStore
//      sync.(*entry).tryExpungeLocked
void sync/atomic.CompareAndSwapPointer(Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C)
{
	runtime.writebarrierptr_prewrite(dwArg0C);
	sync/atomic.CompareAndSwapUintptr(dwArg04, dwArg08, dwArg0C);
}

// 0804A4E0: void runtime.cgocall(Register (ptr32 Eq_2) gs, Stack (ptr32 code) dwArg04, Stack ptr32 dwArg08)
// Called from:
//      runtime.main
void runtime.cgocall(struct Eq_2 * gs, <anonymous> * dwArg04, ptr32 dwArg08)
{
	if (g_b8157571 == 0x00)
		runtime.throw(gs);
	else if (dwArg04 == null)
		runtime.throw(gs);
	else
	{
		Eq_4 ecx_36 = *((word32) gs->ptr0000->tFFFFFFFC + 24);
		*((word32) ecx_36 + 452) = (word32) *((word32) ecx_36 + 452) + 2;
		Eq_4 ecx_41 = gs->ptr0000->tFFFFFFFC;
		Eq_4 edx_42 = *((word32) ecx_41 + 24);
		if (g_t81576F0 == 0x00)
			*((word32) edx_42 + 188) = ecx_41;
		else
			runtime.writebarrierptr((word32) edx_42 + 188, ecx_41);
		Eq_4 ebp_68 = *((word32) ecx_41 + 24);
		if (g_t81576F0 == 0x00)
			*((word32) ecx_41 + 0x0088) = ebp_68;
		else
			runtime.writebarrierptr((word32) ecx_41 + 0x0088, ebp_68);
		Eq_4 eax_89 = *((word32) gs->ptr0000->tFFFFFFFC + 24);
		up32 ecx_92 = *((word32) eax_89 + 0x0098);
		word32 edx_95 = *((word32) eax_89 + 0x009C);
		*((word32) eax_89 + 0x0098) = ecx_92 + 0x01;
		*((word32) eax_89 + 0x009C) = (bool) (ecx_92 < 0x01) + edx_95;
		*((word32) eax_89 + 0x00A0) = (word32) *((word32) eax_89 + 0x00A0) + 1;
		*((word32) eax_89 + 0x0091) = 0x01;
		**((word32) eax_89 + 0x00A8) = 0x00;
		runtime.entersyscall(gs);
		word32 edi_198;
		runtime.asmcgocall(gs, dwArg04, dwArg08, out edi_198);
		word32 esi_199;
		runtime.exitsyscall(gs, out esi_199);
		runtime.endcgo(gs, eax_89);
	}
}

// 0804A670: void runtime.endcgo(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      runtime.cgocall
//      runtime.unwindm
void runtime.endcgo(struct Eq_2 * gs, Eq_4 dwArg04)
{
	*((word32) dwArg04 + 0x0091) = 0x00;
	--*((word32) dwArg04 + 0x00A0);
	runtime.unlockOSThread(gs);
}

// 0804A690: void runtime.cgocallbackg(Register Eq_4 ebp, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg00)
// Called from:
//      runtime.cgocallback_gofunc
void runtime.cgocallbackg(Eq_4 ebp, struct Eq_2 * gs, Eq_4 dwArg00)
{
	Eq_4 eax_8 = gs->ptr0000->tFFFFFFFC;
	if (eax_8 != *((word32) (*((word32) eax_8 + 24)) + 84))
	{
		runtime.printlock(gs);
		runtime.printstring(gs);
		runtime.printnl(gs);
		runtime.printunlock(gs);
		runtime.exit();
	}
	fn08090264((word32) *((word32) eax_8 + 24) + 528, fp - 0x20);
	Eq_4 ecx_65 = *((word32) eax_8 + 56);
	Eq_4 edx_67 = *((word32) eax_8 + 60);
	Eq_4 esi_75;
	runtime.exitsyscall(gs, out esi_75);
	dwLoc08->ptr0018->b0091 = 0x00;
	runtime.cgocallbackg1(ebp, esi_75, gs, dwArg00);
	dwLoc08->ptr0018->b0091 = 0x01;
	runtime.reentersyscall(gs, edx_67, ecx_65);
	fn08090264(fp - 0x24, &dwLoc08->ptr0018->b0091 + 383);
}

// 0804A780: void runtime.cgocallbackg1(Register Eq_4 ebp, Register Eq_4 esi, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      runtime.cgocallbackg
void runtime.cgocallbackg1(Eq_4 ebp, Eq_4 esi, struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 eax_35;
	Eq_4 eax_18 = gs->ptr0000->tFFFFFFFC;
	union Eq_4 * esp_16 = fp - 0x38;
	eax_35 = eax_18;
	if (*((word32) *((word32) eax_18 + 24) + 0x01CC) == 0x00)
	{
		runtime/internal/atomic.Load();
		esp_16 = fp - 0x34;
		if (dwLoc30 <= 0x00)
			goto l0804A7D4;
		eax_35 = dwLoc04;
	}
	*((word32) *((word32) eax_35 + 24) + 0x01CC) = 0x00;
	*esp_16 = (union Eq_4 *) 135167116;
	word32 edi_421;
	runtime.systemstack(gs, *esp_16, out ebp, out edi_421);
l0804A7D4:
	if (dwArg04 != 0x00)
	{
		Eq_4 edx_62 = *((word32) eax_18 + 188);
		Eq_4 ebx_101 = (word32) edx_62 + 1;
		Eq_4 ebp_107 = *((word32) eax_18 + 0x00B8);
		Eq_4 esi_100 = *((word32) eax_18 + 0x00C0);
		if ((word32) edx_62 + 1 > esi_100)
		{
			word128 xmm1_424;
			word128 xmm0_423;
			word32 esi_422;
			runtime.growslice(gs, 0x080CF360, ebp_107, edx_62, esi_100, (word32) edx_62 + 1, out esi_422, out xmm0_423, out xmm1_424);
			ebp_107 = dwLoc24;
			esi_100 = dwLoc1C;
			ebx_101 = dwLoc20 + 0x01;
		}
		*((word32) ebp_107 + edx_62 * 0x04) = dwArg04;
		if (ebx_101 <= 0x00)
			runtime.panicindex(gs);
		runtime.atomicstorep((word32) eax_18 + 0x00B8, ebp_107);
		*((word32) eax_18 + 0x00C0) = esi_100;
		*((word32) eax_18 + 188) = ebx_101;
		word32 edi_425;
		if (runtime.deferproc(gs, 0x04, 0x080E7BBC, eax_18, out ebp, out esi, out edi_425) != 0x00)
		{
			word128 xmm1_427;
			word128 xmm0_426;
			runtime.deferreturn(gs, out xmm0_426, out xmm1_427);
			return;
		}
	}
	if (*((word32) *((word32) eax_18 + 24) + 0x00A0) == 0x00)
	{
		word32 edi_428;
		runtime.chanrecv1(ebp, esi, gs, runtime.main_init_done, 0x00, out edi_428);
	}
	word32 esi_430;
	word32 edi_431;
	word32 ebp_429;
	if (runtime.deferproc(gs, 0x04, 0x080E7D00, fp - 0x15, out ebp_429, out esi_430, out edi_431) != 0x00)
	{
		word128 xmm1_433;
		word128 xmm0_432;
		runtime.deferreturn(gs, out xmm0_432, out xmm1_433);
	}
	else
	{
		runtime.reflectcall(*((word32) *((word32) **((word32) eax_18 + 24) + 28) + 24));
		word128 xmm1_435;
		word128 xmm0_434;
		runtime.deferreturn(gs, out xmm0_434, out xmm1_435);
	}
}

// 0804A9A0: void runtime.unwindm(Register (ptr32 Eq_2) gs, Stack (ptr32 byte) dwArg04)
void runtime.unwindm(struct Eq_2 * gs, byte * dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (*dwArg04 == 0x00)
		return;
	Eq_4 eax_26 = gs->ptr0000->tFFFFFFFC;
	Eq_4 ecx_27 = *((word32) eax_26 + 24);
	*((word32) ecx_27 + 0x0078) = (word32) *((word32) ecx_27 + 0x0078) + 1;
	Eq_4 ecx_31 = *((word32) eax_26 + 24);
	Eq_4 edx_32 = *ecx_31;
	*((word32) edx_32 + 28) = **((word32) edx_32 + 28);
	if (*((word32) ecx_31 + 0x00A0) > 0x00)
		runtime.endcgo(gs, ecx_31);
	Eq_4 eax_61 = gs->ptr0000->tFFFFFFFC;
	Eq_4 edx_63 = *((word32) ecx_31 + 0x0078);
	*((word32) ecx_31 + 0x0078) = edx_63 - 0x01;
	if (edx_63 == 0x01 && *((word32) eax_61 + 0x006C) != 0x00)
		((word32) eax_61 + 8)->u0 = ~0x0521;
}

// 0804AA50: Register Eq_4 runtime.cgoIsGoPointer(Stack Eq_4 dwArg04)
// Called from:
//      runtime.cgoCheckWriteBarrier
//      runtime.cgoCheckMemmove
//      runtime.cgoCheckSliceCopy
//      runtime.cgoCheckTypedBlock
//      runtime.cgoCheckBits
Eq_4 runtime.cgoIsGoPointer(Eq_4 dwArg04)
{
	if (dwArg04 == 0x00)
		return esi;
	if (dwArg04 != 0x00)
	{
		Eq_4 edx_17 = g_t81493A8;
		if (dwArg04 >= edx_17 && dwArg04 < g_t81493AC)
		{
			Eq_4 ebx_23 = g_t8149108;
			esi = dwArg04;
			uint32 ecx_26 = dwArg04 - edx_17;
			if (ecx_26 >> 0x0D >= g_t814910C)
				runtime.panicindex(gs);
			Eq_4 ecx_34 = *((word32) ebx_23 + (ecx_26 >> 0x0D) * 0x04);
			if (ecx_34 != 0x00 && (dwArg04 >= *((word32) ecx_34 + 0x0C) && ((*((word32) ecx_34 + 60) <= 0x02 && *((word32) ecx_34 + 60) >= 0x01) && dwArg04 < *((word32) ecx_34 + 80))))
				return dwArg04;
		}
	}
	runtime.activeModules();
	word32 * ecx_129 = dwLoc0C;
	int32 ebx_133 = 0x00;
	while (true)
	{
		word24 edx_24_8_188 = SLICE(dwArg04, word24, 8);
		if (ebx_133 >= dwLoc08)
			break;
		Eq_4 esi_83;
		struct Eq_2085 * ebp_77 = *ecx_129;
		Eq_4 esi_78 = ebp_77->t0040;
		Eq_4 edi_79 = ebp_77->t0044;
		if (esi_78 <= dwArg04)
			esi_83 = SEQ(SLICE(esi_78, word24, 8), (int8) (dwArg04 < edi_79));
		else
			esi_83.u0 = 0x00;
		esi = esi_83;
		if ((byte) esi_83 != 0x00)
			return esi;
		uip32 edx_219;
		esi = ebp_77->t0048;
		Eq_4 ebp_112 = ebp_77->t004C;
		if (esi <= dwArg04)
			edx_219 = SEQ(edx_24_8_188, (int8) (dwArg04 < ebp_112));
		else
			edx_219 = 0x00;
		if ((byte) edx_219 != 0x00)
			return esi;
		++ecx_129;
		++ebx_133;
	}
	return esi;
}

// 0804AB50: void runtime.cgoCheckWriteBarrier(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.writebarrierptr
//      runtime.writebarrierptr_prewrite
void runtime.cgoCheckWriteBarrier(struct Eq_2 * gs)
{
	runtime.cgoIsGoPointer(dwArg08);
	if (bLoc10 == 0x00)
		return;
	runtime.cgoIsGoPointer(dwArg04);
	if (bLoc10 != 0x00)
		return;
	Eq_4 eax_36 = gs->ptr0000->tFFFFFFFC;
	Eq_4 ecx_37 = *((word32) eax_36 + 24);
	if (*ecx_37 == eax_36 || *((word32) ecx_37 + 44) == eax_36)
		return;
	if (*((word32) ecx_37 + 0x0068) != 0x00)
		return;
	word32 ebp_109;
	word32 edi_110;
	runtime.systemstack(gs, fp - 0x0C, out ebp_109, out edi_110);
}

// 0804ABE0: void runtime.cgoCheckMemmove(Stack Eq_4 dwArg04)
// Called from:
//      runtime.typedmemmove
//      reflect.typedmemmovepartial
void runtime.cgoCheckMemmove(Eq_4 dwArg04)
{
	if ((*((word32) dwArg04 + 0x0F) & 0x80) != 0x00)
		return;
	runtime.cgoIsGoPointer(dwArg0C);
	if (bLoc0C == 0x00)
		return;
	runtime.cgoIsGoPointer(dwArg08);
	if (bLoc0C != 0x00)
		return;
	runtime.cgoCheckTypedBlock(dwArg04, dwArg0C, dwArg10, dwArg14);
}

// 0804AC50: Register word32 runtime.cgoCheckSliceCopy(Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg14, Stack Eq_4 dwArg20)
// Called from:
//      runtime.typedslicecopy
word32 runtime.cgoCheckSliceCopy(Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg14, Eq_4 dwArg20)
{
	if ((*((word32) dwArg04 + 0x0F) & 0x80) != 0x00)
		return esi;
	word32 esi_21 = runtime.cgoIsGoPointer(dwArg14);
	if (bLoc14 == 0x00)
		return esi_21;
	word32 esi_129 = runtime.cgoIsGoPointer(dwArg08);
	if (bLoc14 != 0x00)
		return esi_129;
	Eq_4 eax_54 = 0x00;
	Eq_4 ecx_57 = dwArg14;
	while (eax_54 < dwArg20)
	{
		esi_129 = runtime.cgoCheckTypedBlock(dwArg04, ecx_57, 0x00, *dwArg04);
		eax_54 = (word32) eax_54 + 1;
		ecx_57 = Mem72[dwArg04 + 0x00:word32] + ecx_57;
	}
	return esi_129;
}

// 0804ACF0: Register Eq_4 runtime.cgoCheckTypedBlock(Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C, Stack Eq_4 dwArg10)
// Called from:
//      runtime.cgoCheckMemmove
//      runtime.cgoCheckSliceCopy
Eq_4 runtime.cgoCheckTypedBlock(Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C, Eq_4 dwArg10)
{
	Eq_4 ecx_7 = *((word32) dwArg04 + 4);
	if (ecx_7 <= dwArg0C)
		return esi;
	Eq_4 ecx_13 = ecx_7 - dwArg0C;
	if (dwArg10 <= ecx_13)
		ecx_13 = dwArg10;
	if ((*((word32) dwArg04 + 0x0F) & 0x40) == 0x00)
	{
		runtime.cgoCheckBits(dwArg08, *((word32) dwArg04 + 20), dwArg0C, ecx_13);
		return esi;
	}
	else
	{
		runtime.activeModules();
		word32 * eax_189 = dwLoc30;
		int32 ebx_267;
		for (ebx_267 = 0x00; ebx_267 < dwLoc2C; ++ebx_267)
		{
			int8 bl_201;
			struct Eq_2327 * ebp_190 = *eax_189;
			Eq_4 esi_191 = ebp_190->t0040;
			Eq_4 ebx_193 = ebp_190->t0044;
			if (esi_191 <= dwArg08)
				bl_201 = (int8) (dwArg08 < ebx_193);
			else
				bl_201 = 0x00;
			if (bl_201 != 0x00)
			{
				Eq_4 esi_210 = esi_191 - dwArg08;
				runtime.cgoCheckBits(esi_210 + dwArg08, Mem41[ebp_190 + 200:word32], dwArg0C + (dwArg08 - esi_191), ecx_13);
				return esi_210;
			}
			Eq_4 esi_236;
			Eq_4 ebx_232 = ebp_190->t0048;
			Eq_4 esi_233 = ebp_190->t004C;
			if (ebx_232 <= dwArg08)
				esi_236 = SEQ(SLICE(esi_233, word24, 8), (int8) (dwArg08 < esi_233));
			else
				esi_236.u0 = 0x00;
			if ((byte) esi_236 != 0x00)
			{
				runtime.cgoCheckBits((word32) dwArg08 + (ebx_232 - dwArg08), ebp_190->t00D0, (word32) dwArg0C + (dwArg08 - ebx_232), ecx_13);
				return esi_236;
			}
			++eax_189;
		}
		uint32 ebx_63 = dwArg08 - g_t81493A8;
		Eq_4 esi_66 = g_t814910C;
		Eq_4 edx_68 = g_t8149108;
		if (ebx_63 >> 0x0D >= esi_66)
			runtime.panicindex(gs);
		else if (*((word32) *((word32) edx_68 + (ebx_63 >> 0x0D) * 0x04) + 60) == 0x02)
		{
			fn0808FD8B(0x00, fp - 0x14);
			word32 ebp_427;
			word32 edi_428;
			runtime.systemstack(gs, fp - 0x14, out ebp_427, out edi_428);
			return esi_66;
		}
		else
		{
			byte * edx_110 = g_t81493A0 - (ebx_63 >> 0x04) - 0x01;
			uint32 ebp_111 = ebx_63 >> 0x02 & 0x03;
			Eq_4 ecx_112 = 0x00;
			while (true)
			{
				byte bLoc2C_340 = (byte) dwLoc2C;
				if (ecx_112 >=u ecx_13 + dwArg0C)
					break;
				uint32 edi_131 = (word32) *edx_110 >> (byte) ebp_111;
				if (ecx_112 >= dwArg0C && (edi_131 & 0x01) != 0x00)
				{
					runtime.cgoIsGoPointer(Mem139[dwArg08 + ecx_112:word32]);
					if (bLoc2C_340 != 0x00)
					{
						word32 edi_430;
						word32 ebp_429;
						runtime.systemstack(gs, 0x080E7BB0, out ebp_429, out edi_430);
					}
				}
				if (ebp_111 < 0x03)
					++ebp_111;
				else
				{
					--edx_110;
					ebp_111 = 0x00;
				}
				ecx_112 = (word32) ecx_112 + 4;
			}
			return ecx_13;
		}
	}
}

// 0804AF50: void runtime.cgoCheckBits(Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C, Stack Eq_4 dwArg10)
// Called from:
//      runtime.cgoCheckTypedBlock
//      runtime.cgoCheckUsingType
void runtime.cgoCheckBits(Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C, Eq_4 dwArg10)
{
	word32 eax_10 = __align(dwArg0C, 32);
	up32 ecx_103 = dwArg0C - eax_10;
	Eq_2477 ebx_13 = (word32) dwArg10 + ecx_103;
	byte * edx_100 = (word32) dwArg08 + (dwArg0C >> 0x05);
	Eq_4 (* eax_18)[] = (word32) dwArg04 + eax_10;
	Eq_2477 ebp_20 = 0x00;
	uint32 esi_21 = 0x00;
	ebx_25 = ebx_13;
	eax_104 = eax_18;
	while (true)
	{
		Eq_4 (* eax_104)[];
		Eq_2477 ebx_25;
		if (ebp_20 >= ebx_25)
			break;
		uint32 esi_35;
		if ((ebp_20 & 0x1F) == 0x00)
		{
			esi_35 = (word32) *edx_100;
			++edx_100;
		}
		else
			esi_35 = esi_21 >> 0x01;
		if (ecx_103 > 0x00)
			ecx_103 += ~0x03;
		else if ((esi_35 & 0x01) != 0x00)
		{
			runtime.cgoIsGoPointer(Mem58[eax_104 + ebp_20:word32]);
			if (bLoc18 != 0x00)
			{
				word32 ebp_153;
				word32 edi_154;
				runtime.systemstack(gs, 0x080E7BAC, out ebp_153, out edi_154);
			}
			eax_104 = eax_18;
			ebx_25 = ebx_13;
		}
		esi_21 = esi_35;
		ebp_20 = (word32) ebp_20 + 4;
	}
}

// 0804B000: void runtime.cgoCheckUsingType(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C, Stack Eq_4 dwArg10)
// Called from:
//      runtime.cgoCheckUsingType
//      runtime.cgoCheckTypedBlock.func1
void runtime.cgoCheckUsingType(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C, Eq_4 dwArg10)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 0x0C))
		runtime.morestackc();
	word32 ecx_19 = (word32) *((word32) dwArg04 + 0x0F);
	Eq_4 eax_159 = dwArg04;
	byte cl_20 = (byte) ecx_19;
	if ((cl_20 & 0x80) != 0x00)
		return;
	Eq_4 edx_26 = *((word32) dwArg04 + 4);
	Eq_4 ebx_136 = dwArg0C;
	if (edx_26 <= dwArg0C)
		return;
	Eq_4 edx_100 = edx_26 - dwArg0C;
	if (dwArg10 <= edx_100)
		edx_100 = dwArg10;
	if ((cl_20 & 0x40) == 0x00)
		runtime.cgoCheckBits(dwArg08, *((word32) dwArg04 + 20), dwArg0C, edx_100);
	else
	{
		byte cl_64 = (byte) ecx_19 & 0x1F;
		if (cl_64 != 0x11)
		{
			if (cl_64 != 0x19)
				runtime.throw(gs);
			else
			{
				struct Eq_2620 * ecx_143 = (word32) *((word32) dwArg04 + 36) + 4;
				Eq_4 eax_80 = *((word32) dwArg04 + 40);
				Eq_4 ebp_146 = 0x00;
				Eq_4 esi_102 = dwArg08;
				while (ebp_146 < eax_80)
				{
					Eq_4 edi_92 = ecx_143->dw0000;
					if (ebx_136 < *edi_92)
						runtime.cgoCheckUsingType(gs, edi_92, esi_102, ebx_136, edx_100);
					Eq_4 eax_130;
					Eq_4 eax_123 = *edi_92;
					esi_102 += eax_123;
					if (ebx_136 > eax_123)
						eax_130 = eax_123;
					else
						eax_130 = ebx_136;
					Eq_4 edi_134 = eax_123 - eax_130;
					ebx_136 -= eax_130;
					if (edx_100 <= edi_134)
						return;
					++ecx_143;
					ebp_146 = (word32) ebp_146 + 1;
					edx_100 -= edi_134;
				}
			}
		}
		else
		{
			Eq_4 ecx_155 = 0x00;
			Eq_4 ebp_158 = dwArg08;
			while (ecx_155 < *((word32) eax_159 + 40))
			{
				Eq_4 esi_169 = *((word32) eax_159 + 32);
				if (ebx_136 < *esi_169)
				{
					runtime.cgoCheckUsingType(gs, esi_169, ebp_158, ebx_136, edx_100);
					eax_159 = dwArg04;
				}
				Eq_4 esi_204;
				Eq_4 esi_197 = **((word32) eax_159 + 32);
				ebp_158 += esi_197;
				if (ebx_136 > esi_197)
					esi_204 = esi_197;
				else
					esi_204 = ebx_136;
				Eq_4 edi_208 = esi_197 - esi_204;
				ebx_136 -= esi_204;
				if (edx_100 <= edi_208)
					return;
				ecx_155 = (word32) ecx_155 + 1;
				edx_100 -= edi_208;
			}
		}
	}
}

// 0804B1C0: Register Eq_4 runtime.makechan(Register Eq_4 ebp, Register word32 edi, Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_2666) dwArg04, Stack Eq_4 dwArg08, Stack int32 dwArg0C, Register out ptr32 esiOut)
// Called from:
//      runtime.gcenable
//      runtime.main
Eq_4 runtime.makechan(Eq_4 ebp, word32 edi, struct Eq_2 * gs, struct Eq_2666 * dwArg04, Eq_4 dwArg08, int32 dwArg0C, ptr32 & esiOut)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 ecx_18 = dwArg04->t0020;
	Eq_4 edx_19 = *ecx_18;
	if (edx_19 >= 0x00010000)
		runtime.throw(gs);
	else if (*((word32) ecx_18 + 0x0D) > 0x08)
		runtime.throw(gs);
	else
	{
		int8 bl_52 = (int8) (dwArg0C == 0x00);
		if (((int8) (dwArg0C < 0x00) | (int8) Test(ULT,false) & bl_52) != 0x00 || (dwArg0C != 0x00 || edx_19 > 0x00 && dwArg08 > (uint32) (0xFFFFFFC7 /u edx_19)))
			runtime.gopanic(gs);
		else
		{
			ptr32 esi_182;
			Eq_4 eax_236;
			word32 eax_144 = (word32) *((word32) ecx_18 + 0x0F);
			if (((byte) eax_144 & 0x80) != 0x00 || ((int8) (dwArg08 == 0x00) & bl_52) != 0x00)
			{
				eax_236 = dwLoc14;
				if (((int8) (dwArg0C > 0x00) | bl_52 & (int8) (dwArg08 > 0x00)) != 0x00 && *ecx_18 != 0x00)
				{
					esi_182 = (word32) dwLoc14 + 56;
					if (g_t81576F0 == 0x00)
						*((word32) dwLoc14 + 8) = (word32) dwLoc14 + 56;
					else
					{
						runtime.writebarrierptr((word32) dwLoc14 + 8, (word32) dwLoc14 + 56);
						eax_236 = dwLoc14;
					}
				}
				else if (g_t81576F0 == 0x00)
					*((word32) dwLoc14 + 8) = dwLoc14;
				else
				{
					runtime.writebarrierptr((word32) dwLoc14 + 8, dwLoc14);
					eax_236 = dwLoc14;
				}
			}
			else
			{
				runtime.newobject(gs, 0x080DAD80);
				word32 edi_428;
				esi_182 = runtime.newarray(gs, ecx_18, dwArg08, out edi_428);
				if (g_t81576F0 == 0x00)
					*((word32) dwLoc1C + 8) = dwLoc18;
				else
					runtime.writebarrierptr((word32) dwLoc1C + 8, dwLoc18);
				eax_236 = dwLoc1C;
			}
			*((word32) eax_236 + 0x0C) = *ecx_18;
			Eq_4 ebp_319 = (word32) eax_236 + 20;
			if (g_t81576F0 == 0x00)
				*((word32) eax_236 + 20) = ecx_18;
			else
				runtime.writebarrierptr(ebp_319, ecx_18);
			*((word32) eax_236 + 4) = dwArg08;
			esiOut = esi_182;
			return ebp_319;
		}
	}
}

// 0804B430: Register Eq_4 runtime.chansend1(Register Eq_4 ebp, Register Eq_4 esi, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
// Called from:
//      runtime.bgsweep
Eq_4 runtime.chansend1(Eq_4 ebp, Eq_4 esi, struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08)
{
	runtime.getcallerpc();
	return runtime.chansend(ebp, esi, gs, dwArg04, dwArg08, 0x01);
}

// 0804B470: Register Eq_4 runtime.chansend(Register Eq_4 ebp, Register Eq_4 esi, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack byte bArg0C)
// Called from:
//      runtime.chansend1
Eq_4 runtime.chansend(Eq_4 ebp, Eq_4 esi, struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, byte bArg0C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (dwArg04 == 0x00)
	{
		if (bArg0C == 0x00)
			return esi;
		runtime.gopark(gs);
		runtime.throw(gs);
	}
	else
	{
		if (bArg0C == 0x00 && *((word32) dwArg04 + 16) == 0x00)
		{
			Eq_4 edx_65 = *((word32) dwArg04 + 4);
			if (edx_65 == 0x00 && *((word32) dwArg04 + 32) == 0x00 || edx_65 > 0x00 && *dwArg04 == edx_65)
				return esi;
		}
		ui64 ebx_edx_1226;
		up32 edx_87 = g_dw8157668;
		up32 ebx_88 = g_dw815766C;
		if (((int8) (edx_87 > 0x00) & (int8) (ebx_88 == 0x00) | (int8) (ebx_88 > 0x00)) == 0x00)
			ebx_edx_1226 = 0x00;
		else
		{
			runtime.cputicks();
			ebx_edx_1226 = SEQ(dwLoc48, dwLoc4C);
		}
		Eq_4 esi_163;
		word32 edi_1242;
		runtime.lock(esi, gs, (word32) dwArg04 + 48, out esi_163, out edi_1242);
		word32 ebx_142 = SLICE(ebx_edx_1226, word32, 32);
		word32 edx_139 = (word32) ebx_edx_1226;
		if (*((word32) dwArg04 + 16) != 0x00)
		{
			word32 edx_1235;
			word32 ebx_1236;
			runtime.unlock(gs, (word32) dwArg04 + 48, out edx_1235, out ebx_1236);
			runtime.gopanic(gs);
		}
		else
		{
			runtime.(*waitq).dequeue(gs, (word32) dwArg04 + 32);
			if (dwLoc48 != 0x00)
				return runtime.send(gs, dwArg04, dwLoc48, dwArg08, fp - 0x08, 0x03);
			if (*dwArg04 < *((word32) dwArg04 + 4))
			{
				Eq_4 esi_272;
				word32 edi_1237;
				word128 xmm1_1239;
				word128 xmm0_1238;
				runtime.typedmemmove(*((word32) dwArg04 + 20), (word32) *((word32) dwArg04 + 8) + *((word32) dwArg04 + 24) *s (word32) (*((word32) dwArg04 + 0x0C)), dwArg08, out esi_272, out edi_1237, out xmm0_1238, out xmm1_1239);
				Eq_4 ecx_288 = *((word32) dwArg04 + 24);
				*((word32) dwArg04 + 24) = (word32) ecx_288 + 1;
				if ((word32) ecx_288 + 1 == *((word32) dwArg04 + 4))
					((word32) dwArg04 + 24)->u0 = 0x00;
				*dwArg04 = (word32) *dwArg04 + 1;
				word32 edx_1243;
				word32 ebx_1244;
				runtime.unlock(gs, (word32) dwArg04 + 48, out edx_1243, out ebx_1244);
				return esi_272;
			}
			else if (bArg0C != 0x00)
			{
				Eq_4 eax_323 = gs->ptr0000->tFFFFFFFC;
				runtime.acquireSudog(gs);
				((word32) dwArg04 + 60)->u0 = 0x00;
				*((word32) dwArg04 + 64) = 0x00;
				byte al_458 = (byte) dwArg04 + 0x20;
				word24 eax_24_8_468 = SLICE((word32) dwArg04 + 32, word24, 8);
				if (((int8) (ebx_142 != 0x00) | (int8) (edx_139 != 0x00)) != 0x00)
				{
					((word32) dwArg04 + 60)->u0 = ~0x00;
					*((word32) dwArg04 + 64) = ~0x00;
				}
				Eq_4 eax_1232;
				if (g_t81576F0 == 0x00)
				{
					*((word32) dwArg04 + 48) = dwArg08;
					*((word32) dwArg04 + 76) = 0x00;
					*((word32) dwArg04 + 32) = eax_323;
					((word32) dwArg04 + 36)->u0 = 0x00;
					*((word32) dwArg04 + 84) = dwArg04;
					eax_1232 = SEQ(eax_24_8_468, al_458);
				}
				else
				{
					runtime.writebarrierptr((word32) dwArg04 + 48, dwArg08);
					runtime.writebarrierptr((word32) dwArg04 + 76, 0x00);
					runtime.writebarrierptr((word32) dwArg04 + 32, eax_323);
					runtime.writebarrierptr((word32) dwArg04 + 36, 0x00);
					runtime.writebarrierptr((word32) dwArg04 + 84, dwArg04);
					eax_1232 = SEQ(SLICE((word32) dwArg04 + 32, word24, 8), (byte) dwArg04 + 0x20);
				}
				Eq_4 eax_1229;
				if (g_t81576F0 == 0x00)
				{
					*((word32) eax_323 + 0x00B4) = eax_1232;
					((word32) eax_323 + 0x0044)->u0 = 0x00;
					((word32) eax_1232 + 8)->u0 = 0x00;
					eax_1229 = eax_1232;
				}
				else
				{
					runtime.writebarrierptr((word32) eax_323 + 0x00B4, eax_1232);
					runtime.writebarrierptr((word32) eax_323 + 0x0044, 0x00);
					runtime.writebarrierptr((word32) eax_1232 + 8, 0x00);
					eax_1229 = SEQ(SLICE((word32) dwArg04 + 32, word24, 8), (byte) dwArg04 + 0x20);
				}
				ui24 ebx_24_8_750;
				Eq_4 ecx_523 = *((word32) dwArg04 + 44);
				if (ecx_523 != 0x00)
				{
					ebx_24_8_750 = SLICE((word32) eax_1229 + 0x0C, word24, 8);
					if (g_t81576F0 == 0x00)
					{
						*((word32) eax_1229 + 0x0C) = ecx_523;
						*((word32) ecx_523 + 8) = eax_1229;
						*((word32) dwArg04 + 44) = eax_1229;
					}
					else
					{
						runtime.writebarrierptr((word32) eax_1229 + 0x0C, ecx_523);
						runtime.writebarrierptr((word32) ecx_523 + 8, (word32) dwArg04 + 32);
						runtime.writebarrierptr((word32) dwArg04 + 44, (word32) dwArg04 + 32);
					}
				}
				else
				{
					ebx_24_8_750 = SLICE((word32) dwArg04 + 40, word24, 8);
					if (g_t81576F0 == 0x00)
					{
						((word32) eax_1229 + 0x0C)->u0 = 0x00;
						*((word32) dwArg04 + 40) = eax_1229;
						*((word32) dwArg04 + 44) = eax_1229;
					}
					else
					{
						runtime.writebarrierptr((word32) eax_1229 + 0x0C, 0x00);
						runtime.writebarrierptr((word32) dwArg04 + 40, (word32) dwArg04 + 32);
						runtime.writebarrierptr((word32) dwArg04 + 44, (word32) dwArg04 + 32);
					}
				}
				runtime.goparkunlock(gs);
				if ((word32) dwArg04 + 32 != *((word32) eax_323 + 0x00B4))
					runtime.throw(gs);
				else
				{
					if (g_t81576F0 == 0x00)
						((word32) eax_323 + 0x00B4)->u0 = 0x00;
					else
						runtime.writebarrierptr((word32) eax_323 + 0x00B4, 0x00);
					if (*((word32) eax_323 + 0x0044) == 0x00)
					{
						if (*((word32) dwArg04 + 16) == 0x00)
							runtime.throw(gs);
						else
							runtime.gopanic(gs);
					}
					else
					{
						if (g_t81576F0 == 0x00)
							((word32) eax_323 + 0x0044)->u0 = 0x00;
						else
							runtime.writebarrierptr((word32) eax_323 + 0x0044, 0x00);
						int32 ecx_738 = *((word32) dwArg04 + 64);
						Eq_4 eax_737 = *((word32) dwArg04 + 60);
						ui32 ebx_769 = SEQ(ebx_24_8_750, (int8) (ecx_738 > 0x00)) | SEQ(SLICE(dwArg04, word24, 8), (int8) (eax_737 > 0x00)) & SEQ(ebx_24_8_750, (int8) (ecx_738 == 0x00));
						word24 ebx_24_8_785 = SLICE(ebx_769, word24, 8);
						if ((byte) ebx_769 != 0x00)
						{
							ui64 ecx_eax_858 = SEQ(ecx_738, eax_737) - ebx_edx_1226;
							runtime.blockevent(ebx_24_8_785, gs, (word32) ecx_eax_858, SLICE(ecx_eax_858, word32, 32));
						}
						if (g_t81576F0 == 0x00)
							((word32) dwArg04 + 84)->u0 = 0x00;
						else
							runtime.writebarrierptr((word32) dwArg04 + 84, 0x00);
						Eq_4 esi_827;
						word32 edi_1245;
						runtime.releaseSudog(gs, (word32) dwArg04 + 32, out esi_827, out edi_1245);
						return esi_827;
					}
				}
			}
			else
			{
				word32 edx_1240;
				word32 ebx_1241;
				runtime.unlock(gs, (word32) dwArg04 + 48, out edx_1240, out ebx_1241);
				return esi_163;
			}
		}
	}
}

// 0804BAD0: Register word32 runtime.send(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C, Stack (ptr32 (ptr32 code)) dwArg10, Stack word32 dwArg14)
// Called from:
//      runtime.chansend
word32 runtime.send(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C, <anonymous> ** dwArg10, word32 dwArg14)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (*((word32) dwArg08 + 16) != 0x00)
	{
		Eq_4 ecx_25 = *((word32) dwArg04 + 20);
		esi = runtime.sendDirect(gs, ecx_25, dwArg08, dwArg0C);
		dwLoc14 = ecx_25;
		dwLoc10 = dwArg08;
		if (g_t81576F0 == 0x00)
			((word32) dwArg08 + 16)->u0 = 0x00;
		else
		{
			runtime.writebarrierptr((word32) dwArg08 + 16, 0x00);
			dwLoc14 = (word32) dwArg08 + 16;
			dwLoc10.u0 = 0x00;
		}
	}
	Eq_4 ecx_70 = *dwArg08;
	(*dwArg10)();
	if (g_t81576F0 == 0x00)
		*((word32) ecx_70 + 0x0044) = dwArg08;
	else
	{
		runtime.writebarrierptr((word32) ecx_70 + 0x0044, dwArg08);
		dwLoc14 = (word32) ecx_70 + 0x0044;
		dwLoc10 = dwArg08;
	}
	Eq_4 edx_106 = *((word32) dwArg08 + 28);
	Eq_4 ebx_107 = *((word32) dwArg08 + 32);
	if (((int8) (ebx_107 != 0x00) | (int8) (edx_106 != 0x00)) != 0x00)
	{
		runtime.cputicks();
		*((word32) dwArg08 + 28) = dwLoc14;
		*((word32) dwArg08 + 32) = dwLoc10;
	}
	runtime.goready(gs);
	return esi;
}

// 0804BBF0: Register word32 runtime.sendDirect(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C)
// Called from:
//      runtime.send
word32 runtime.sendDirect(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 eax_19 = *((word32) dwArg08 + 16);
	runtime.typeBitsBulkBarrier(dwArg0C, gs, dwArg04, dwArg0C, *dwArg04);
	word32 esi_48;
	word32 ebp_89;
	word32 edi_90;
	word128 xmm0_91;
	word128 xmm1_92;
	word128 xmm2_93;
	runtime.memmove(eax_19, dwArg0C, *dwArg04, out ebp_89, out esi_48, out edi_90, out xmm0_91, out xmm1_92, out xmm2_93);
	return esi_48;
}

// 0804BC60: Register word32 runtime.recvDirect(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C, Register out ptr32 ediOut)
// Called from:
//      runtime.recv
word32 runtime.recvDirect(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C, ptr32 & ediOut)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 eax_19 = *((word32) dwArg08 + 16);
	runtime.typeBitsBulkBarrier(eax_19, gs, dwArg04, eax_19, *dwArg04);
	ptr32 edi_47;
	word32 ebp_51;
	word32 esi_90;
	word128 xmm0_91;
	word128 xmm1_92;
	word128 xmm2_93;
	runtime.memmove(dwArg0C, eax_19, *dwArg04, out ebp_51, out esi_90, out edi_47, out xmm0_91, out xmm1_92, out xmm2_93);
	ediOut = edi_47;
	return ebp_51;
}

// 0804BCD0: void runtime.closechan(Register Eq_4 esi, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      runtime.main
void runtime.closechan(Eq_4 esi, struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (dwArg04 == 0x00)
		runtime.gopanic(gs);
	else
	{
		word32 esi_463;
		word32 edi_464;
		runtime.lock(esi, gs, (word32) dwArg04 + 48, out esi_463, out edi_464);
		if (*((word32) dwArg04 + 16) != 0x00)
		{
			word32 edx_465;
			word32 ebx_466;
			runtime.unlock(gs, (word32) dwArg04 + 48, out edx_465, out ebx_466);
			runtime.gopanic(gs);
		}
		else
		{
			((word32) dwArg04 + 16)->u0 = 0x01;
			Eq_4 eax_352 = 0x00;
			while (true)
			{
				runtime.(*waitq).dequeue(gs, (word32) dwArg04 + 32);
				Eq_4 dwLoc28_379 = (word32) dwArg04 + 32;
				if (dwLoc24 == 0x00)
					break;
				Eq_4 ecx_259 = *((word32) dwLoc24 + 16);
				if (ecx_259 != 0x00)
				{
					Eq_4 eax_266 = *((word32) dwArg04 + 20);
					runtime.typedmemclr(eax_266, ecx_259);
					Eq_4 dwLoc04_402 = (word32) dwLoc24 + 16;
					dwLoc24 = ecx_259;
					dwLoc28_379 = eax_266;
					if (g_t81576F0 == 0x00)
						((byte) dwLoc24.u0 + 16)->u0 = 0x00;
					else
					{
						runtime.writebarrierptr(dwLoc04_402, 0x00);
						dwLoc28_379 = dwLoc04_402;
						dwLoc24.u0 = 0x00;
					}
				}
				Eq_4 ecx_298 = *((word32) dwLoc24 + 28);
				Eq_4 edx_299 = *((word32) dwLoc24 + 32);
				if (((int8) (ecx_298 != 0x00) | (int8) (edx_299 != 0x00)) != 0x00)
				{
					runtime.cputicks();
					*((word32) dwLoc24 + 28) = dwLoc28_379;
					*((word32) dwLoc24 + 32) = dwLoc24;
				}
				Eq_4 eax_330 = *dwLoc24;
				if (g_t81576F0 == 0x00)
					((word32) eax_330 + 0x0044)->u0 = 0x00;
				else
				{
					runtime.writebarrierptr((word32) eax_330 + 0x0044, 0x00);
					dwLoc24.u0 = 0x00;
				}
				*((word32) eax_330 + 0x0068) = eax_352;
				eax_352 = eax_330;
			}
			Eq_4 eax_113 = eax_352;
			while (true)
			{
				runtime.(*waitq).dequeue(gs, (word32) dwArg04 + 40);
				Eq_4 dwLoc28_383 = (word32) dwArg04 + 40;
				if (dwLoc24 == 0x00)
					break;
				if (g_t81576F0 == 0x00)
					((byte) dwLoc24.u0 + 16)->u0 = 0x00;
				else
				{
					dwLoc28_383 = (byte) dwLoc24.u0 + 16;
					runtime.writebarrierptr(dwLoc28_383, 0x00);
					dwLoc24.u0 = 0x00;
				}
				Eq_4 ecx_195 = *((byte) dwLoc24.u0 + 32);
				Eq_4 edx_196 = *((byte) dwLoc24.u0 + 28);
				if (((int8) (edx_196 != 0x00) | (int8) (ecx_195 != 0x00)) != 0x00)
				{
					runtime.cputicks();
					*((byte) dwLoc24.u0 + 28) = dwLoc28_383;
					*((byte) dwLoc24.u0 + 32) = dwLoc24;
				}
				Eq_4 eax_227 = *dwLoc24.u0;
				if (g_t81576F0 == 0x00)
					((word32) eax_227 + 0x0044)->u0 = 0x00;
				else
				{
					runtime.writebarrierptr((word32) eax_227 + 0x0044, 0x00);
					dwLoc24.u0 = 0x00;
				}
				*((word32) eax_227 + 0x0068) = eax_113;
				eax_113 = eax_227;
			}
			word32 ebx_468;
			word32 edx_467;
			runtime.unlock(gs, (word32) dwArg04 + 48, out edx_467, out ebx_468);
			Eq_4 eax_152 = eax_113;
			while (eax_152 != 0x00)
			{
				Eq_4 ecx_158 = *((word32) eax_152 + 0x0068);
				((word32) eax_152 + 0x0068)->u0 = 0x00;
				runtime.goready(gs);
				eax_152 = ecx_158;
			}
		}
	}
}

// 0804BF60: Register Eq_4 runtime.chanrecv1(Register Eq_4 ebp, Register Eq_4 esi, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Register out ptr32 ediOut)
// Called from:
//      runtime.cgocallbackg1
//      runtime.gcenable
Eq_4 runtime.chanrecv1(Eq_4 ebp, Eq_4 esi, struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, ptr32 & ediOut)
{
	ptr32 edi_22;
	Eq_4 ebp_20 = runtime.chanrecv(ebp, esi, gs, dwArg04, dwArg08, 0x01, out edi_22);
	ediOut = edi_22;
	return ebp_20;
}

// 0804BF80: Register Eq_4 runtime.chanrecv(Register Eq_4 ebp, Register Eq_4 esi, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack byte bArg0C, Register out ptr32 ediOut)
// Called from:
//      runtime.chanrecv1
Eq_4 runtime.chanrecv(Eq_4 ebp, Eq_4 esi, struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, byte bArg0C, ptr32 & ediOut)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 eax_102 = dwArg04;
	if (dwArg04 == 0x00)
	{
		if (bArg0C != 0x00)
		{
			runtime.gopark(gs);
			runtime.throw(gs);
		}
		else
		{
			ediOut = edi;
			return ebp;
		}
	}
	if (bArg0C == 0x00)
	{
		Eq_4 edx_62 = *((word32) dwArg04 + 4);
		if (edx_62 != 0x00 || *((word32) dwArg04 + 40) != 0x00)
		{
			if (edx_62 <= 0x00)
				goto l0804BFB2;
			runtime/internal/atomic.Loaduint();
			dwLoc54 = dwArg04;
			if (dwLoc50 != 0x00)
			{
				eax_102 = dwArg04;
				goto l0804BFB2;
			}
		}
		runtime/internal/atomic.Load();
		dwLoc54 = (word32) dwArg04 + 16;
		if (dwLoc4C == 0x00)
		{
			ediOut = edi;
			return ebp;
		}
		eax_102 = dwArg08;
	}
l0804BFB2:
	Eq_4 ebx_158;
	Eq_4 edx_157;
	up32 edx_106 = g_dw8157668;
	up32 ebx_107 = g_dw815766C;
	Eq_4 eax_148 = eax_102;
	if (((int8) (ebx_107 == 0x00) & (int8) (edx_106 > 0x00) | (int8) (ebx_107 > 0x00)) == 0x00)
	{
		edx_157.u0 = 0x00;
		ebx_158.u0 = 0x00;
	}
	else
	{
		runtime.cputicks();
		edx_157 = dwLoc54;
		ebx_158 = dwLoc50;
		eax_148 = dwArg04;
	}
	Eq_4 ecx_170 = (word32) eax_148 + 48;
	word32 esi_1337;
	ptr32 edi_188;
	Eq_4 ebp_187 = runtime.lock(esi, gs, ecx_170, out esi_1337, out edi_188);
	if (*((word32) dwArg04 + 16) == 0x00 || *dwArg04 != 0x00)
	{
		runtime.(*waitq).dequeue(gs, (word32) dwArg04 + 40);
		if (dwLoc50 != 0x00)
		{
			ptr32 edi_269;
			Eq_4 ebp_266 = runtime.recv(gs, dwArg04, dwLoc50, dwArg08, fp - 0x08, 0x03, out edi_269);
			ediOut = edi_269;
			return ebp_266;
		}
		else if (*dwArg04 <= 0x00)
		{
			if (bArg0C != 0x00)
			{
				Eq_4 eax_302 = gs->ptr0000->tFFFFFFFC;
				runtime.acquireSudog(gs);
				((word32) dwArg04 + 0x0044)->u0 = 0x00;
				*((word32) dwArg04 + 72) = 0x00;
				if (((int8) (ebx_158 != 0x00) | (int8) (edx_157 != 0x00)) != 0x00)
				{
					((word32) dwArg04 + 0x0044)->u0 = ~0x00;
					*((word32) dwArg04 + 72) = ~0x00;
				}
				if (g_t81576F0 == 0x00)
				{
					*((word32) dwArg04 + 56) = dwArg08;
					((word32) dwArg04 + 84)->u0 = 0x00;
				}
				else
				{
					runtime.writebarrierptr((word32) dwArg04 + 56, dwArg08);
					runtime.writebarrierptr((word32) dwArg04 + 84, 0x00);
				}
				if (g_t81576F0 == 0x00)
				{
					*((word32) eax_302 + 0x00B4) = (word32) dwArg04 + 40;
					*((word32) dwArg04 + 40) = eax_302;
					((word32) dwArg04 + 44)->u0 = 0x00;
					*((word32) dwArg04 + 92) = dwArg04;
					((word32) eax_302 + 0x0044)->u0 = 0x00;
					((word32) dwArg04 + 48)->u0 = 0x00;
				}
				else
				{
					runtime.writebarrierptr((word32) eax_302 + 0x00B4, (word32) dwArg04 + 40);
					runtime.writebarrierptr((word32) dwArg04 + 40, eax_302);
					runtime.writebarrierptr((word32) dwArg04 + 44, 0x00);
					runtime.writebarrierptr((word32) dwArg04 + 92, dwArg04);
					runtime.writebarrierptr((word32) eax_302 + 0x0044, 0x00);
					runtime.writebarrierptr((word32) dwArg04 + 48, 0x00);
				}
				Eq_4 edi_499 = *((word32) dwArg04 + 36);
				if (edi_499 != 0x00)
				{
					if (g_t81576F0 == 0x00)
					{
						*((word32) dwArg04 + 52) = edi_499;
						*((word32) edi_499 + 8) = (word32) dwArg04 + 40;
						*((word32) dwArg04 + 36) = (word32) dwArg04 + 40;
					}
					else
					{
						runtime.writebarrierptr((word32) dwArg04 + 52, edi_499);
						runtime.writebarrierptr((word32) edi_499 + 8, (word32) dwArg04 + 40);
						runtime.writebarrierptr((word32) dwArg04 + 36, (word32) dwArg04 + 40);
					}
				}
				else if (g_t81576F0 == 0x00)
				{
					((word32) dwArg04 + 52)->u0 = 0x00;
					*((word32) dwArg04 + 32) = (word32) dwArg04 + 40;
					*((word32) dwArg04 + 36) = (word32) dwArg04 + 40;
				}
				else
				{
					runtime.writebarrierptr((word32) dwArg04 + 52, 0x00);
					runtime.writebarrierptr((word32) dwArg04 + 32, (word32) dwArg04 + 40);
					runtime.writebarrierptr((word32) dwArg04 + 36, (word32) dwArg04 + 40);
				}
				runtime.goparkunlock(gs);
				if ((word32) dwArg04 + 40 != *((word32) eax_302 + 0x00B4))
					runtime.throw(gs);
				else
				{
					if (g_t81576F0 == 0x00)
						((word32) eax_302 + 0x00B4)->u0 = 0x00;
					else
						runtime.writebarrierptr((word32) eax_302 + 0x00B4, 0x00);
					Eq_4 ecx_655 = *((word32) dwArg04 + 0x0044);
					int32 ebx_656 = *((word32) dwArg04 + 72);
					if (((int8) (ebx_656 > 0x00) | (int8) (ebx_656 == 0x00) & (int8) (ecx_655 > 0x00)) != 0x00)
					{
						ui64 ebx_ecx_896 = SEQ(ebx_656, ecx_655) - SEQ(ebx_158, edx_157);
						int32 ebx_716 = SLICE(ebx_ecx_896, word32, 32);
						runtime.blockevent(SLICE(ebx_716, word24, 8), gs, (word32) ebx_ecx_896, ebx_716);
					}
					if (g_t81576F0 == 0x00)
					{
						((word32) eax_302 + 0x0044)->u0 = 0x00;
						((word32) dwArg04 + 92)->u0 = 0x00;
					}
					else
					{
						runtime.writebarrierptr((word32) eax_302 + 0x0044, 0x00);
						runtime.writebarrierptr((word32) dwArg04 + 92, 0x00);
					}
					ptr32 edi_776;
					word32 esi_1338;
					Eq_4 ebp_773 = runtime.releaseSudog(gs, (word32) dwArg04 + 40, out esi_1338, out edi_776);
					ediOut = edi_776;
					return ebp_773;
				}
			}
			else
			{
				word32 edx_1335;
				word32 ebx_1336;
				runtime.unlock(gs, ecx_170, out edx_1335, out ebx_1336);
				ediOut = edi_188;
				return ebp_187;
			}
		}
		else
		{
			Eq_4 ecx_811 = (word32) *((word32) dwArg04 + 8) + *((word32) dwArg04 + 28) *s (word32) (*((word32) dwArg04 + 0x0C));
			if (dwArg08 != 0x00)
			{
				word128 xmm0_1331;
				word32 esi_1329;
				word32 edi_1330;
				word128 xmm1_1332;
				ebp_187 = runtime.typedmemmove(*((word32) dwArg04 + 20), dwArg08, ecx_811, out esi_1329, out edi_1330, out xmm0_1331, out xmm1_1332);
			}
			ptr32 edi_854 = runtime.typedmemclr(*((word32) dwArg04 + 20), ecx_811);
			Eq_4 ecx_861 = *((word32) dwArg04 + 28);
			*((word32) dwArg04 + 28) = (word32) ecx_861 + 1;
			if ((word32) ecx_861 + 1 == *((word32) dwArg04 + 4))
				((word32) dwArg04 + 28)->u0 = 0x00;
			--*dwArg04;
			word32 ebx_1334;
			word32 edx_1333;
			runtime.unlock(gs, ecx_170, out edx_1333, out ebx_1334);
			ediOut = edi_854;
			return ebp_187;
		}
	}
	else
	{
		word32 edx_1327;
		word32 ebx_1328;
		runtime.unlock(gs, ecx_170, out edx_1327, out ebx_1328);
		if (dwArg08 != 0x00)
			edi_188 = runtime.typedmemclr(*((word32) dwArg04 + 20), dwArg08);
		ediOut = edi_188;
		return ebp_187;
	}
}

// 0804C610: Register Eq_4 runtime.recv(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C, Stack (ptr32 (ptr32 code)) dwArg10, Stack word32 dwArg14, Register out ptr32 ediOut)
// Called from:
//      runtime.chanrecv
Eq_4 runtime.recv(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C, <anonymous> ** dwArg10, word32 dwArg14, ptr32 & ediOut)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (*((word32) dwArg04 + 4) == 0x00)
	{
		if (dwArg0C != 0x00)
		{
			Eq_4 eax_106 = *((word32) dwArg04 + 20);
			dwLoc14 = eax_106;
			dwLoc10 = dwArg08;
			ebp = runtime.recvDirect(gs, eax_106, dwArg08, dwArg0C, out edi);
		}
	}
	else
	{
		Eq_4 ecx_26 = (word32) *((word32) dwArg04 + 8) + *((word32) dwArg04 + 28) *s (word32) (*((word32) dwArg04 + 0x0C));
		if (dwArg0C != 0x00)
		{
			word32 esi_399;
			word32 edi_400;
			word128 xmm1_402;
			word128 xmm0_401;
			runtime.typedmemmove(*((word32) dwArg04 + 20), dwArg0C, ecx_26, out esi_399, out edi_400, out xmm0_401, out xmm1_402);
		}
		Eq_4 edx_61 = *((word32) dwArg04 + 20);
		word32 esi_403;
		word128 xmm0_404;
		word128 xmm1_405;
		ebp = runtime.typedmemmove(edx_61, ecx_26, *((word32) dwArg08 + 16), out esi_403, out edi, out xmm0_404, out xmm1_405);
		Eq_4 ecx_91 = *((word32) dwArg04 + 28);
		*((word32) dwArg04 + 28) = (word32) ecx_91 + 1;
		dwLoc14 = edx_61;
		dwLoc10 = ecx_26;
		if ((word32) ecx_91 + 1 == *((word32) dwArg04 + 4))
			((word32) dwArg04 + 28)->u0 = 0x00;
		*((word32) dwArg04 + 24) = *((word32) dwArg04 + 28);
	}
	if (g_t81576F0 == 0x00)
		((word32) dwArg08 + 16)->u0 = 0x00;
	else
	{
		runtime.writebarrierptr((word32) dwArg08 + 16, 0x00);
		dwLoc14 = (word32) dwArg08 + 16;
		dwLoc10.u0 = 0x00;
	}
	struct Eq_4326 * ecx_156 = *dwArg08;
	(*dwArg10)();
	if (g_t81576F0 == 0x00)
		ecx_156->t0044 = dwArg08;
	else
	{
		runtime.writebarrierptr(&ecx_156->t0044, dwArg08);
		dwLoc14 = &ecx_156->t0044;
		dwLoc10 = dwArg08;
	}
	Eq_4 edx_194 = *((word32) dwArg08 + 32);
	Eq_4 ebx_195 = *((word32) dwArg08 + 28);
	if (((int8) (edx_194 != 0x00) | (int8) (ebx_195 != 0x00)) != 0x00)
	{
		runtime.cputicks();
		*((word32) dwArg08 + 28) = dwLoc14;
		*((word32) dwArg08 + 32) = dwLoc10;
	}
	runtime.goready(gs);
	ediOut = edi;
	return ebp;
}

// 0804C7A0: void reflect.chanlen(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      reflect.Value.Len
void reflect.chanlen(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (dwArg04 == 0x00)
		;
}

// 0804C7E0: void runtime.(*waitq).dequeue(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      runtime.chansend
//      runtime.closechan
//      runtime.chanrecv
void runtime.(*waitq).dequeue(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	do
	{
		Eq_4 ecx_21 = *dwArg04;
		if (ecx_21 == 0x00)
			return;
		Eq_4 edx_29 = *((word32) ecx_21 + 8);
		if (edx_29 != 0x00)
		{
			if (g_t81576F0 == 0x00)
			{
				((word32) edx_29 + 0x0C)->u0 = 0x00;
				*dwArg04 = edx_29;
				((word32) ecx_21 + 8)->u0 = 0x00;
			}
			else
			{
				runtime.writebarrierptr((word32) edx_29 + 0x0C, 0x00);
				runtime.writebarrierptr(dwArg04, edx_29);
				runtime.writebarrierptr((word32) ecx_21 + 8, 0x00);
			}
		}
		else if (g_t81576F0 == 0x00)
		{
			dwArg04->u0 = 0x00;
			((word32) dwArg04 + 4)->u0 = 0x00;
		}
		else
		{
			runtime.writebarrierptr(dwArg04, 0x00);
			runtime.writebarrierptr((word32) dwArg04 + 4, 0x00);
		}
		Eq_4 edx_112 = *((word32) ecx_21 + 4);
		if (edx_112 == 0x00)
			return;
		if (*edx_112 != 0x00)
			continue;
		runtime/internal/atomic.Cas(edx_112, 0x00, 0x01);
	} while (bLoc10 == 0x00);
}

// 0804C930: void runtime.(*cpuProfile).add(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_4530) dwArg04, Stack Eq_4 dwArg08, Stack ptr32 dwArg0C, Stack Eq_4 dwArg10)
// Called from:
//      runtime.sigprof
void runtime.(*cpuProfile).add(struct Eq_2 * gs, struct Eq_4530 * dwArg04, Eq_4 dwArg08, ptr32 dwArg0C, Eq_4 dwArg10)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	while (true)
	{
		struct Eq_4530 * dwLoc30_163 = &g_t8157698;
		ui24 ebx_24_8_51 = SLICE(runtime/internal/atomic.Cas(135624344, 0x00, 0x01), word24, 8);
		if (bLoc24 != 0x00)
			break;
		runtime.osyield();
	}
	if (g_dw815769C == 0x00)
	{
l0804CA20:
		runtime/internal/atomic.Store(135624344, 0x00);
		return;
	}
	if (dwArg04->t0FAC <= 0x00)
	{
		up32 ecx_41 = dwArg04->dw0FB4;
		up32 edx_42 = dwArg04->dw0FB0;
		ui32 ebx_55 = SEQ(ebx_24_8_51, (int8) (ecx_41 == 0x00)) & SEQ(SLICE(edx_42, word24, 8), (int8) (edx_42 > 0x00));
		ebx_24_8_51 = SLICE(ebx_55, word24, 8);
		if (((int8) (ecx_41 > 0x00) | (byte) ebx_55) == 0x00)
			goto l0804C99F;
	}
	runtime.(*cpuProfile).addExtra(ebx_24_8_51, gs, dwArg04);
	dwLoc30_163 = dwArg04;
l0804C99F:
	runtime.nanotime();
	runtime.(*profBuf).write(gs, g_t8145928, (word32) dwArg08 + 0x00C4, (uint64) dwLoc30_163, fp - 0x08, 0x01, dwArg0C, dwArg10);
	goto l0804CA20;
}

// 0804CA70: void runtime.(*cpuProfile).addNonGo(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg08, Stack Eq_4631 dwArg0C)
// Called from:
//      runtime.sigprofNonGoPC
void runtime.(*cpuProfile).addNonGo(struct Eq_2 * gs, Eq_4 dwArg08, Eq_4631 dwArg0C)
{
	while (true)
	{
		runtime/internal/atomic.Cas(135624344, 0x00, 0x01);
		if (bLoc04 != 0x00)
			break;
		runtime.osyield();
	}
	uint32 eax_21 = g_dw81468CC;
	Eq_4631 ecx_22 = dwArg0C;
	if ((word32) dwArg0C.u0 + 1 + eax_21 < 1000)
	{
		if (eax_21 >= 1000)
			runtime.panicindex(gs);
		g_a814592C[eax_21 * 0x04] = (word32) dwArg0C.u0 + 1;
		if (eax_21 > 999)
			runtime.panicslice(gs);
		Eq_4631 eax_48 = -(eax_21 + ~0x03E6);
		ui32 edx_53 = eax_21 + 0x01 << 0x02 & -eax_48 >> 0x1F;
		if (eax_48 <= dwArg0C)
			ecx_22 = eax_48;
		word128 xmm2_165;
		word128 xmm1_164;
		word128 xmm0_163;
		word32 edi_162;
		word32 esi_161;
		word32 ebp_160;
		runtime.memmove(edx_53 + 135551276, dwArg08, ecx_22 << 0x02, out ebp_160, out esi_161, out edi_162, out xmm0_163, out xmm1_164, out xmm2_165);
		g_dw81468CC = (word32) dwArg0C.u0 + (g_dw81468CC + 0x01);
	}
	else
	{
		up32 eax_26 = g_dw81468D0;
		word32 ecx_29 = g_dw81468D4;
		g_dw81468D0 = eax_26 + 0x01;
		g_dw81468D4 = (word32) ((bool) (eax_26 < 0x01) + ecx_29);
	}
	runtime/internal/atomic.Store(135624344, 0x00);
}

// 0804CB80: void runtime.(*cpuProfile).addExtra(Register ui24 ebx_24_8, Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_4530) dwArg04)
// Called from:
//      runtime.(*cpuProfile).add
void runtime.(*cpuProfile).addExtra(ui24 ebx_24_8, struct Eq_2 * gs, struct Eq_4530 * dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4571 eax_205;
	for (eax_205 = 0x00; eax_205 < dwArg04->t0FAC; eax_205 += (dwArg04 + 0x0C)[eax_205 * 0x04])
	{
		if (eax_205 >= 1000)
			runtime.panicindex(gs);
		Eq_4772 edx_137 = (word32) eax_205 + 1;
		word32 ebx_139 = (dwArg04 + 0x0C)[eax_205 * 0x04] + eax_205;
		if (edx_137 > ebx_139 || ebx_139 > 1000)
			runtime.panicslice(gs);
		runtime.(*profBuf).write(gs, dwArg04->t0008, 0x00, 0x00, fp - 0x18, 0x01, dwArg04->a000C + (edx_137 << 0x02 & eax_205 - 999 >> 0x1F) / 4, ebx_139 - edx_137);
	}
	dwArg04->t0FAC.u0 = 0x00;
	up32 eax_32 = dwArg04->dw0FB0;
	up32 edx_33 = dwArg04->dw0FB4;
	if (((int8) (edx_33 > 0x00) | (int8) (edx_33 == 0x00) & (int8) (eax_32 > 0x00)) != 0x00)
	{
		runtime.(*profBuf).write(gs, g_t8145928, 0x00, 0x00, fp - 0x20, 0x01, fp - 0x28, 0x02);
		dwArg04->dw0FB0 = 0x00;
		dwArg04->dw0FB4 = 0x00;
	}
}

// 0804CDC0: void runtime.GOMAXPROCS(Register Eq_4 esi, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      sync.(*Pool).pinSlow
void runtime.GOMAXPROCS(Eq_4 esi, struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 eax_17 = dwArg04;
	if (dwArg04 > 0x0400)
		eax_17.u0 = 0x0400;
	word32 edi_139;
	word32 esi_138;
	runtime.lock(esi, gs, 135549936, out esi_138, out edi_139);
	Eq_4 eax_41 = runtime.gomaxprocs;
	word32 ebx_141;
	word32 edx_140;
	runtime.unlock(gs, 135549936, out edx_140, out ebx_141);
	if (eax_17 <= 0x00 || eax_17 == eax_41)
		return;
	runtime.stopTheWorld(gs, 135141561, 0x0A);
	runtime.newprocs = eax_17;
	runtime.startTheWorld(gs);
}

// 0804CE70: Register Eq_4 runtime.gogetenv(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
// Called from:
//      runtime.GOROOT
//      runtime.readgogc
//      runtime.schedinit
//      runtime.parsedebugvars
Eq_4 runtime.gogetenv(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 eax_17 = g_t814512C;
	Eq_4 ecx_107 = g_t8145128;
	if (ecx_107 == 0x00)
		runtime.throw(gs);
	else
	{
		Eq_4 edx_110 = 0x00;
		eax_102 = eax_17;
		while (true)
		{
			Eq_4 eax_102;
			if (edx_110 >= eax_102)
				break;
			Eq_4 ebx_46 = *((word32) ecx_107 + 4);
			Eq_4 ebp_47 = *ecx_107;
			if (ebx_46 > dwArg08 && Mem45[ebp_47 + dwArg08:byte] == 0x3D)
			{
				Eq_4 esi_71;
				word32 ebx_187;
				word32 edi_188;
				runtime.eqstring(edx_110, ebp_47, dwArg08, dwArg04, out ebx_187, out esi_71, out edi_188);
				if (bLoc18 != 0x00)
				{
					if ((word32) dwArg08 + 1 > ebx_46)
						runtime.panicslice(gs);
					else
						return esi_71;
				}
				eax_102 = eax_17;
			}
			esi = dwArg08;
			ecx_107 = (word32) ecx_107 + 8;
			edx_110 = (word32) edx_110 + 1;
		}
		return esi;
	}
}

// 0804CF80: void runtime.(*TypeAssertionError).Error(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_4951) dwArg04)
void runtime.(*TypeAssertionError).Error(struct Eq_2 * gs, struct Eq_4951 * dwArg04)
{
	while (fp - 0x10 <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	dwArg04->dw0004 != 0x00;
	if (dwArg04->dw000C == 0x00)
		runtime.concatstring4(gs, 0x00);
	else if (dwArg04->dw001C != 0x00)
	{
		fn08090228(&g_t80F2000, fp - 0x60);
		runtime.concatstrings(gs, 0x00, fp - 100, 0x06);
	}
	else
	{
		fn08090228(&g_t80F1FC0, fp - 0x30);
		runtime.concatstrings(gs, 0x00, fp - 0x34, 0x06);
	}
}

// 0804D150: void runtime.errorString.Error(Register (ptr32 Eq_2) gs)
void runtime.errorString.Error(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.concatstring2(gs, 0x00);
}

// 0804D1B0: void runtime.plainError.Error(Register (ptr32 Eq_5033) gs)
void runtime.plainError.Error(struct Eq_5033 * gs)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
}

// 0804D1E0: void runtime.typestring(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.printany
void runtime.typestring(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.(*_type).string(gs, dwArg04);
}

// 0804D220: void runtime.printany(Register (ptr32 Eq_2) gs, Register Eq_662 xmm0, Register Eq_662 xmm1, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
// Called from:
//      runtime.printpanics
//      runtime.gopanic
void runtime.printany(struct Eq_2 * gs, Eq_662 xmm0, Eq_662 xmm1, Eq_4 dwArg04, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (dwArg04 == 0x00)
	{
		runtime.printlock(gs);
		runtime.printstring(gs);
		runtime.printunlock(gs);
	}
	else
	{
		Eq_4 ecx_36 = *((word32) dwArg04 + 8);
		runtime.assertE2I2(gs, dwArg04);
		if (bLoc68 == 0x00)
		{
			runtime.assertE2I2(gs, dwArg04);
			if (bLoc68 != 0x00)
			{
				dwLoc70->ptr0014();
				runtime.printlock(gs);
				runtime.printstring(gs);
				runtime.printunlock(gs);
			}
			else
			{
				if (ecx_36 <= 3004847213)
				{
					if (ecx_36 <= 2032468620)
					{
						if (ecx_36 <= 0x2EA27FFB)
						{
							if (ecx_36 == 0x13FF06C5)
							{
								uip32 ebx_1323;
								if (dwArg04 == 0x080CE760)
									ebx_1323 = (word32) *dwArg08;
								else
									ebx_1323 = 0x00;
								Eq_4 bl_739 = (byte) ebx_1323;
								if (dwArg04 == 0x080CE760)
								{
									runtime.printlock(gs);
									runtime.printbool(gs, bl_739);
									runtime.printunlock(gs);
									return;
								}
							}
							if (ecx_36 == 0x2EA27FFB)
							{
								Eq_662 xmm0_775;
								if (dwArg04 == 0x080CE860)
									xmm0_775.u0 = (uint128) *dwArg08;
								else
									xmm0_775 = __xorps(xmm0, xmm0);
								if (dwArg04 == 0x080CE860)
								{
									runtime.printlock(gs);
									word128 xmm2_1334;
									runtime.printfloat(gs, xmm2, (real64) (uint128) (real64) xmm0_775, out xmm2_1334);
									runtime.printunlock(gs);
									return;
								}
							}
						}
						else
						{
							if (ecx_36 == 1715356255)
							{
								uip32 ebx_1325;
								if (dwArg04 == 0x080CF320)
									ebx_1325 = (word32) *dwArg08;
								else
									ebx_1325 = 0x00;
								byte bl_647 = (byte) ebx_1325;
								if (dwArg04 == 0x080CF320)
								{
									runtime.printlock(gs);
									runtime.printint(SLICE(ebx_1325, word24, 8), gs, (word32) bl_647);
									runtime.printunlock(gs);
									return;
								}
							}
							if (ecx_36 == 2032468620)
							{
								Eq_662 xmm0_689;
								Eq_662 xmm1_685;
								if (dwArg04 == 0x080CE7E0)
								{
									xmm0_689.u0 = (uint128) *((word32) dwArg08 + 4);
									xmm1_685.u0 = (uint128) *dwArg08;
								}
								else
								{
									xmm1_685 = __xorps(xmm1, xmm1);
									xmm0_689 = __xorps(xmm0, xmm0);
								}
								if (dwArg04 == 0x080CE7E0)
								{
									runtime.printlock(gs);
									runtime.printcomplex(gs, (real64) (real32) (uint128) (real32) xmm1_685, (real64) (real32) (uint128) (real32) xmm0_689);
									runtime.printunlock(gs);
									return;
								}
							}
						}
					}
					else if (ecx_36 <= ~0x69C06400)
					{
						if (ecx_36 == 2251394350)
						{
							Eq_4 ebp_555;
							Eq_4 ebx_554;
							if (dwArg04 == 135066336)
							{
								ebx_554 = *((word32) dwArg08 + 4);
								ebp_555 = *dwArg08;
							}
							else
							{
								ebx_554.u0 = 0x00;
								ebp_555.u0 = 0x00;
							}
							if (dwArg04 == 135066336)
							{
								runtime.printlock(gs);
								runtime.printuint(ebp_555, gs, ebp_555, ebx_554);
								runtime.printunlock(gs);
								return;
							}
						}
						if (ecx_36 == ~0x69C06400)
						{
							Eq_4 ebx_595;
							Eq_4 eax_594;
							if (dwArg04 == 0x080CEC20)
							{
								eax_594 = *dwArg08;
								ebx_595 = *((word32) dwArg08 + 4);
							}
							else
							{
								eax_594.u0 = 0x00;
								ebx_595.u0 = 0x00;
							}
							if (dwArg04 == 0x080CEC20)
							{
								runtime.printlock(gs);
								runtime.printint(SLICE(ebx_595, word24, 8), gs, eax_594);
								runtime.printunlock(gs);
								return;
							}
						}
					}
					else
					{
						if (ecx_36 == 0xB0C23ED3)
						{
							if (dwArg04 == 0x080CE820)
								xmm0.u0 = (uint128) *dwArg08;
							else
								xmm0 = __xorps(xmm0, xmm0);
							if (dwArg04 == 0x080CE820)
							{
								runtime.printlock(gs);
								word128 xmm2_1335;
								runtime.printfloat(gs, xmm2, (real64) (real32) (uint128) (real32) xmm0, out xmm2_1335);
								runtime.printunlock(gs);
								return;
							}
						}
						if (ecx_36 == 3004847213)
						{
							Eq_662 xmm1_512;
							Eq_662 xmm0_505;
							if (dwArg04 == 0x080CE7A0)
							{
								xmm0_505.u0 = (uint128) *dwArg08;
								xmm1_512.u0 = (uint128) *((word32) dwArg08 + 8);
							}
							else
							{
								xmm0_505 = __xorps(xmm0, xmm0);
								xmm1_512 = __xorps(xmm1, xmm1);
							}
							if (dwArg04 == 0x080CE7A0)
							{
								runtime.printlock(gs);
								runtime.printcomplex(gs, (real64) (uint128) (real64) xmm0_505, (real64) (uint128) (real64) xmm1_512);
								runtime.printunlock(gs);
								return;
							}
						}
					}
				}
				else if (ecx_36 <= 3494570045)
				{
					if (ecx_36 <= 3175798674)
					{
						if (ecx_36 == 0xBBAD4102)
						{
							if (dwArg04 == 0x080CEBE0)
								ebx = *dwArg08;
							else
								ebx.u0 = 0x00;
							if (dwArg04 == 0x080CEBE0)
							{
								runtime.printlock(gs);
								runtime.printint(SLICE(ebx, word24, 8), gs, ebx);
								runtime.printunlock(gs);
								return;
							}
						}
						if (ecx_36 == 3175798674)
						{
							Eq_4 eax_422;
							if (dwArg04 == 0x080CF360)
								eax_422 = *dwArg08;
							else
								eax_422.u0 = 0x00;
							if (dwArg04 == 0x080CF360)
							{
								runtime.printlock(gs);
								runtime.printint(SLICE(ebx, word24, 8), gs, eax_422);
								runtime.printunlock(gs);
								return;
							}
						}
					}
					else
					{
						if (ecx_36 == 0xCC06C027)
						{
							Eq_4 ebx_1327;
							if (dwArg04 == 0x080CEC60)
								ebx_1327 = (word32) *dwArg08;
							else
								ebx_1327.u0 = 0x00;
							byte bl_314 = (byte) ebx_1327;
							ebx = ebx_1327;
							if (dwArg04 == 0x080CEC60)
							{
								runtime.printlock(gs);
								runtime.printint(SLICE(ebx_1327, word24, 8), gs, (int32) bl_314);
								runtime.printunlock(gs);
								return;
							}
						}
						if (ecx_36 == 3494570045)
						{
							Eq_4 eax_349;
							if (dwArg04 == 0x080CF2A0)
								eax_349 = *dwArg08;
							else
								eax_349.u0 = 0x00;
							if (dwArg04 == 0x080CF2A0)
							{
								runtime.printlock(gs);
								runtime.printint(SLICE(ebx, word24, 8), gs, eax_349);
								runtime.printunlock(gs);
								return;
							}
						}
					}
				}
				else if (ecx_36 <= ~0x1F00A34B)
				{
					if (ecx_36 == 3585636114)
					{
						Eq_4 ebx_232;
						if (dwArg04 == 0x080CF220)
							ebx_232 = *dwArg08;
						else
							ebx_232.u0 = 0x00;
						if (dwArg04 == 0x080CF220)
						{
							runtime.printlock(gs);
							runtime.printint(SLICE(ebx_232, word24, 8), gs, ebx_232);
							runtime.printunlock(gs);
							return;
						}
					}
					if (ecx_36 == ~0x1F00A34B && dwArg04 == 135066016)
					{
						runtime.printlock(gs);
						runtime.printstring(gs);
						runtime.printunlock(gs);
						return;
					}
				}
				else
				{
					if (ecx_36 == 0xECD580CE)
					{
						Eq_4 ebx_115;
						if (dwArg04 == 0x080CEBA0)
							ebx_115 = (word32) *dwArg08;
						else
							ebx_115.u0 = 0x00;
						word16 bx_117 = (word16) ebx_115;
						ebx = ebx_115;
						if (dwArg04 == 0x080CEBA0)
						{
							runtime.printlock(gs);
							runtime.printint(SLICE(ebx_115, word24, 8), gs, (int32) bx_117);
							runtime.printunlock(gs);
							return;
						}
					}
					if (ecx_36 == ~0x100DF15F)
					{
						Eq_4 ebx_1331;
						if (dwArg04 == 0x080CF260)
							ebx_1331 = (word32) *dwArg08;
						else
							ebx_1331.u0 = 0x00;
						word16 bx_158 = (word16) ebx_1331;
						ebx = ebx_1331;
						if (dwArg04 == 0x080CF260)
						{
							runtime.printlock(gs);
							runtime.printint(SLICE(ebx_1331, word24, 8), gs, (word32) bx_158);
							runtime.printunlock(gs);
							return;
						}
					}
					if (ecx_36 == 4149441018)
					{
						Eq_4 eax_192;
						if (dwArg04 == 0x080CEB60)
							eax_192 = *dwArg08;
						else
							eax_192.u0 = 0x00;
						if (dwArg04 == 0x080CEB60)
						{
							runtime.printlock(gs);
							runtime.printint(SLICE(ebx, word24, 8), gs, eax_192);
							runtime.printunlock(gs);
							return;
						}
					}
				}
				runtime.typestring(gs);
				runtime.printlock(gs);
				runtime.printstring(gs);
				runtime.printstring(gs);
				runtime.printstring(gs);
				runtime.printeface(gs);
				runtime.printunlock(gs);
			}
		}
		else
		{
			dwLoc70->ptr0014();
			runtime.printlock(gs);
			runtime.printstring(gs);
			runtime.printunlock(gs);
		}
	}
}

// 0804DB10: void runtime.panicwrap(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.(*errorString).Error
//      runtime.(*plainError).Error
//      syscall.(*Errno).Error
//      reflect.(*ChanDir).String
//      reflect.(*Kind).String
//      reflect.(*Value).Kind
//      reflect.(*Value).Len
//      reflect.(*Value).NumMethod
//      reflect.(*Value).NumField
//      reflect.(*Value).String
void runtime.panicwrap(struct Eq_2 * gs)
{
	while (fp - 0x9C <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	word32 edi_558;
	runtime.makeslice(gs, 0x080CF360, 0x01, 0x01, out edi_558);
	runtime.Callers(gs, dwLoc010C);
	if (dwLoc010C == 0x00)
		runtime.throw(gs);
	else
	{
		runtime.CallersFrames(gs, dwLoc0110, dwLoc010C, dwLoc0108);
		fn0808FD88(0x00, fp - 0x68);
		runtime.(*Frames).Next(gs, dwLoc0110);
		fn08090250(fp - 0x011C, fp - 0x6C);
		fn08090250(fp - 0x70, fp - 0x90);
		strings.IndexByte(dwLoc8C, dwLoc88, 0x28);
		if (dwLoc0110 < 0x00)
		{
			runtime.concatstring2(gs, fp - 0xCC);
			runtime.throw(gs);
		}
		else if (dwLoc0110 - 0x01 > dwLoc88)
			runtime.panicslice(gs);
		else
		{
			if ((word32) dwLoc0110 + 2 < dwLoc88)
			{
				if (dwLoc0110 - 0x01 > (word32) dwLoc0110 + 2 || (word32) dwLoc0110 + 2 > dwLoc88)
					runtime.panicslice(gs);
				Eq_5639 eax_202 = (word32) dwLoc0110 + 2 - (dwLoc0110 - 0x01);
				Eq_5643 eax_206 = -eax_202 >> 0x1F & dwLoc0110 - 0x01;
				if (eax_202 == 0x03 && (Mem137[eax_206 + dwLoc8C:word16] == 0x282E && Mem137[(dwLoc8C + 0x02) + eax_206:byte] == 0x2A))
				{
					Eq_4 edx_258 = dwLoc88 - ((word32) dwLoc0110 + 2);
					Eq_5606 (* ecx_266)[] = dwLoc8C + ((word32) dwLoc0110 + 2 & -edx_258 >> 0x1F) / 4;
					strings.IndexByte(ecx_266, edx_258, 0x29);
					if (dwLoc0110 < 0x00)
					{
						runtime.concatstring2(gs, fp - 0xEC);
						runtime.throw(gs);
					}
					else
					{
						if (dwLoc0110 + 0x02 < edx_258)
						{
							if (dwLoc0110 >u dwLoc0110 + 0x02 || dwLoc0110 + 0x02 >u edx_258)
								runtime.panicslice(gs);
							if (Mem270[dwLoc0110 + ecx_266:word16] == 11817)
							{
								if (dwLoc0110 > edx_258)
									runtime.panicslice(gs);
								else
								{
									fn080901EC(&g_t80F20C0, fp - 0x54);
									runtime.concatstrings(gs, 0x00, fp - 88, 0x09);
									runtime.convT2Estring(gs, 0x080D1EE0, fp - 0xA0);
									runtime.gopanic(gs);
								}
							}
						}
						runtime.concatstring2(gs, 0x00);
						runtime.throw(gs);
					}
				}
			}
			runtime.concatstring2(gs, 0x00);
			runtime.throw(gs);
		}
	}
}

// 0804DF50: void runtime.Caller(Register (ptr32 Eq_2) gs)
// Called from:
//      reflect.methodName
void runtime.Caller(struct Eq_2 * gs)
{
	while (fp - 0x4C <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.callers(gs);
	if (dwLocBC < 0x02)
		return;
	Eq_4 edx_67;
	Eq_4 ecx_66;
	fn0808FD82(0x00, fp - 0x38);
	up32 edx_55 = runtime.skipPC;
	if (dwLoc8C - edx_55 < 0x0100)
	{
		ecx_66 = fp - 0x88;
		edx_67.u0 = 0x02;
	}
	else
	{
		ecx_66 = fp - 0x8C;
		edx_67.u0 = 0x03;
	}
	runtime.(*stackExpander).next(gs, dwLocD4, fp - 0x3C, ecx_66, edx_67);
	if (bLoc90 == 0x00)
		return;
	fn0808FD88(0x00, fp - 88);
	runtime.(*stackExpander).next(gs, dwLocD4, fp - 0x3C, 0x00, dwLocB8);
	fn08090250(fp - 0xA8, fp - 0x50);
	fn08090250(fp - 0x54, fp - 116);
}

// 0804E160: void runtime.Callers(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg0C)
// Called from:
//      runtime.panicwrap
void runtime.Callers(struct Eq_2 * gs, Eq_4 dwArg0C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (dwArg0C == 0x00)
		return;
	runtime.callers(gs);
}

// 0804E1C0: void runtime.GOROOT(Register (ptr32 Eq_2) gs)
// Called from:
//      time.init
void runtime.GOROOT(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.gogetenv(gs, 0x080E10E8, 0x06);
	if (dwLoc04 == 0x00)
		;
}

// 0804E220: void runtime.float64frombits(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.init
void runtime.float64frombits(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
}

// 0804E250: Register Eq_4 runtime.memhash(Register (ptr32 Eq_2) gs, Register Eq_4 mm0, Stack (ptr32 Eq_205) dwArg04, Stack (ptr32 Eq_205) dwArg08, Stack Eq_4 dwArg0C, Register out Eq_227 xmm1Out)
// Called from:
//      type..hash.sync/atomic.Value
//      runtime.memhash8
//      runtime.memhash16
//      runtime.memhash32
//      runtime.memhash64
//      runtime.memhash128
//      runtime.strhash
//      runtime.f32hash
//      runtime.f64hash
//      runtime.extendRandom
//      runtime.(*traceStackTable).put
//      runtime.memhash_varlen
//      type..hash.runtime._func
//      type..hash.runtime.uncommontype
//      type..hash.runtime.modulehash
//      type..hash.runtime.Frame
//      type..hash.runtime.MemStats
//      type..hash.runtime._panic
//      type..hash.runtime._defer
//      type..hash.runtime.special
//      type..hash.runtime.markBits
//      type..hash.runtime.hchan
//      type..hash.runtime.cpuProfile
//      type..hash.runtime.dbgVar
//      type..hash.runtime.finblock
//      type..hash.runtime.gcControllerState
//      type..hash.runtime.mcentral
//      type..hash.struct { runtime.mcentral runtime.mcentral; runtime.pad [32]uint8 }
//      type..hash.runtime.mstats
//      type..hash.runtime.sigTabT
//      type..hash.runtime.stackmap
//      type..hash.runtime.sweepdata
//      type..hash.runtime.traceStack
//      type..hash.struct { runtime.cycle uint32; runtime.flushed bool }
//      type..hash.struct { runtime.enabled bool; runtime.pad [3]uint8; runtime.needed bool; runtime.cgo bool; runtime.alignme uint64 }
//      type..hash.struct { runtime.full runtime.lfstack; runtime.empty runtime.lfstack; runtime.pad0 [64]uint8; runtime.wbufSpans struct { runtime.lock runtime.mutex; runtime.free runtime.mSpanList; runtime.busy runtime.mSpanList }; _ uint32; runtime.bytesMarked uint64; runtime.markrootNext uint32; runtime.markrootJobs uint32; runtime.nproc uint32; runtime.tstart int64; runtime.nwait uint32; runtime.ndone uint32; runtime.alldone runtime.note; runtime.helperDrainBlock bool; runtime.nFlushCacheRoots int; runtime.nDataRoots int; runtime.nBSSRoots int; runtime.nSpanRoots int; runtime.nStackRoots int; runtime.markrootDone bool; runtime.startSema uint32; runtime.markDoneSema uint32; runtime.bgMarkReady runtime.note; runtime.bgMarkDone uint32; runtime.mode runtime.gcMode; runtime.userForced bool; runtime.totaltime int64; runtime.initialHeapLive uint64; runtime.assistQueue struct { runtime.lock runtime.mutex; runtime.head runtime.guintptr; runtime.tail runtime.guintptr }; runtime.sweepWaiters struct { runtime.lock runtime.mutex; runtime.head runtime.guintptr }; runtime.cycles uint32; runtime.stwprocs int32; runtime.maxprocs int32; runtime.tSweepTerm int64; runtime.tMark int64; runtime.tMarkTerm int64; runtime.tEnd int64; runtime.pauseNS int64; runtime.pauseStart int64; runtime.heap0 uint64; runtime.heap1 uint64; runtime.heap2 uint64; runtime.heapGoal uint64 }
//      type..hash.struct { runtime.note runtime.note; runtime.mask [3]uint32; runtime.wanted [3]uint32; runtime.ignored [3]uint32; runtime.recv [3]uint32; runtime.state uint32; runtime.inuse bool }
//      type..hash.struct { F uintptr; runtime.c *runtime.mcache; runtime.spc runtime.spanClass }
//      type..hash.struct { F uintptr; runtime.preemptible bool }
//      type..hash.struct { F uintptr; runtime.s **runtime.mspan; runtime.h *runtime.mheap; runtime.npage uintptr; runtime.spanclass runtime.spanClass; runtime.large bool }
//      type..hash.struct { F uintptr; runtime.s **runtime.mspan; runtime.size *uintptr; runtime.needzero bool; runtime.noscan bool }
//      type..hash.strconv.decimal
//      type..hash.strconv.extFloat
//      type..hash.strconv.leftCheat
//      type..hash.internal/poll.FD
//      type..hash.os.file
//      type..hash.reflect.uncommonType
//      type..hash.reflect.Method
//      type..hash.reflect.ValueError
//      type..hash.struct { reflect.b bool; reflect.x interface {} }
//      type..hash.struct { F uintptr; reflect.name string }
//      type..hash.fmt.fmt
Eq_4 runtime.memhash(struct Eq_2 * gs, Eq_4 mm0, union Eq_205 * dwArg04, union Eq_205 * dwArg08, Eq_4 dwArg0C, union Eq_227 & xmm1Out)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (g_b8157582 != 0x00)
	{
		Eq_227 xmm1_35;
		Eq_4 mm0_33 = runtime.aeshash(mm0, dwArg04, dwArg08, dwArg0C, out xmm1_35);
		xmm1Out = xmm1_35;
		return mm0_33;
	}
	else
	{
		Eq_4 ecx_166 = dwArg0C;
		while (ecx_166 != 0x00 && (ecx_166 >= 0x04 && (ecx_166 != 0x04 && (ecx_166 > 0x08 && ecx_166 > 0x10))))
		{
			while (ecx_166 >= 0x10)
				ecx_166 = (word32) ecx_166 - 16;
		}
		xmm1Out = xmm1;
		return mm0;
	}
}

// 0804E4A0: Register Eq_4 runtime.(*hmap).newoverflow(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C)
// Called from:
//      runtime.mapassign
//      runtime.evacuate
//      runtime.mapassign_fast32
//      runtime.mapassign_fast64
//      runtime.mapassign_faststr
Eq_4 runtime.(*hmap).newoverflow(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 edx_120;
	Eq_4 edx_18 = *((word32) dwArg04 + 24);
	if (edx_18 != 0x00)
	{
		Eq_4 ebp_24 = *((word32) edx_18 + 8);
		esi = (word32) edx_18 + 8;
		if (ebp_24 != 0x00)
		{
			word32 ebx_49 = (word32) *((word32) dwArg08 + 52);
			Eq_4 ebp_51 = (word32) ebp_24 + (ebx_49 - 0x04);
			esi = ebp_24;
			Eq_4 ebx_55 = (word32) ebp_24 + ebx_49;
			if (*ebp_51 != 0x00)
			{
				if (g_t81576F0 == 0x00)
					*ebp_51 = 0x00;
				else
				{
					runtime.writebarrierptr(ebp_51, 0x00);
					dwLoc38.u0 = 0x00;
				}
				Eq_4 edx_96 = *((word32) dwArg04 + 24);
				if (g_t81576F0 == 0x00)
					((word32) edx_96 + 8)->u0 = 0x00;
				else
				{
					runtime.writebarrierptr((word32) edx_96 + 8, 0x00);
					dwLoc38.u0 = 0x00;
				}
			}
			else if (g_t81576F0 == 0x00)
				*((word32) edx_18 + 8) = ebx_55;
			else
			{
				runtime.writebarrierptr((word32) edx_18 + 8, ebx_55);
				dwLoc38 = ebx_55;
			}
			edx_120 = ebp_24;
l0804E53A:
			word32 ebx_124 = (word32) *((word32) dwArg04 + 5);
			if ((byte) ebx_124 < 0x10)
				*((word32) dwArg04 + 6) = (word32) *((word32) dwArg04 + 6) + 1;
			else
			{
				Eq_4 ebp_133 = *((word32) gs->ptr0000->tFFFFFFFC + 24);
				int32 esi_134 = *((word32) ebp_133 + 0x0094);
				int32 edi_139 = esi_134 << 0x01 ^ esi_134 >> 0x1F & 0xA8888EEF;
				*((word32) ebp_133 + 0x0094) = edi_139;
				cu8 cl_148 = (byte) ebx_124 + ~0x0E;
				esi = 0x01 << cl_148 & 0x00 - (cl_148 < 0x20);
				if ((esi - (word32 *) 0x01 & edi_139) == 0x00)
					*((word32) dwArg04 + 6) = (word32) *((word32) dwArg04 + 6) + 1;
			}
			if ((*((word32) *((word32) dwArg08 + 40) + 0x0F) & 0x80) != 0x00)
			{
				if (*((word32) dwArg04 + 24) == 0x00)
				{
					runtime.newobject(gs, 135085088);
					if (g_t81576F0 == 0x00)
						*((word32) dwArg04 + 24) = dwLoc38;
					else
						runtime.writebarrierptr((word32) dwArg04 + 24, dwLoc38);
				}
				if (**((word32) dwArg04 + 24) == 0x00)
				{
					runtime.newobject(gs, 0x080C9100);
					Eq_4 ecx_251 = *((word32) dwArg04 + 24);
					if (g_t81576F0 == 0x00)
						*ecx_251 = dwLoc38;
					else
						runtime.writebarrierptr(ecx_251, dwLoc38);
				}
				Eq_4 ecx_279 = **((word32) dwArg04 + 24);
				Eq_4 eax_282 = *((word32) ecx_279 + 8);
				Eq_4 ebp_283 = *ecx_279;
				esi = *((word32) ecx_279 + 4);
				if (esi + 0x01 > eax_282)
				{
					word32 esi_736;
					word128 xmm1_738;
					word128 xmm0_737;
					runtime.growslice(gs, 0x080D2120, ebp_283, esi, eax_282, esi + 0x01, out esi_736, out xmm0_737, out xmm1_738);
					*((word32) ecx_279 + 8) = dwLoc20;
					if (g_t81576F0 == 0x00)
						*ecx_279 = dwLoc28;
					else
						runtime.writebarrierptr(ecx_279, dwLoc28);
					esi = dwLoc24;
					ebp_283 = dwLoc28;
				}
				Mem356[ecx_279 + 0x04:word32] = esi + 0x01;
				Eq_4 ecx_359 = (word32) ebp_283 + esi * 0x04;
				if (g_t81576F0 == 0x00)
					*((word32) ebp_283 + esi * 0x04) = edx_120;
				else
					runtime.writebarrierptr(ecx_359, edx_120);
			}
			Eq_4 eax_388 = dwArg0C - 0x04 + (word32) (*((word32) dwArg08 + 52));
			if (g_t81576F0 == 0x00)
				*eax_388 = edx_120;
			else
				runtime.writebarrierptr(eax_388, edx_120);
			return esi;
		}
	}
	runtime.newobject(gs, *((word32) dwArg08 + 40));
	edx_120 = dwLoc38;
	goto l0804E53A;
}

// 0804E7F0: Register Eq_4 runtime.makemap(Register word24 ebx_24_8, Register Eq_4 esi, Register Eq_4 edi, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C, Stack Eq_4 dwArg10, Stack Eq_4 dwArg14, Register out ptr32 ediOut)
// Called from:
//      reflect.addReflectOff
//      runtime.typelinksinit
//      sync.(*Map).dirtyLocked
//      syscall.init
//      time.init
//      unicode.init
//      reflect.(*structType).FieldByNameFunc
Eq_4 runtime.makemap(word24 ebx_24_8, Eq_4 esi, Eq_4 edi, struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C, Eq_4 dwArg10, Eq_4 dwArg14, ptr32 & ediOut)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	word32 edx_19 = **((word32) dwArg04 + 44);
	if (edx_19 != 0x1C)
	{
		runtime.printlock(gs);
		runtime.printstring(gs);
		runtime.printsp(gs);
		runtime.printint(ebx_24_8, gs, 0x1C);
		runtime.printsp(gs);
		runtime.printstring(gs);
		runtime.printsp(gs);
		runtime.printint(ebx_24_8, gs, (uint64) edx_19);
		runtime.printnl(gs);
		runtime.printunlock(gs);
		runtime.throw(gs);
	}
	Eq_4 edx_195;
	Eq_4 eax_194;
	if (((int8) (dwArg0C < 0x00) | (int8) Test(ULT,false) & (int8) (dwArg0C == 0x00)) == 0x00)
	{
		Eq_4 ebx_166;
		uint32 ebx_156 = **((word32) dwArg04 + 40);
		if (ebx_156 < 33)
			ebx_166 = *((char *) g_a81386E0 + ebx_156 * 0x04);
		else
			ebx_166 = (uint32) (0xFFFFFFFF /u ebx_156);
		if (((int8) (dwArg0C == 0x00) & (int8) (dwArg08 > ebx_166) | (int8) (dwArg0C > 0x00)) == 0x00)
		{
			eax_194 = dwArg08;
			edx_195 = dwArg0C;
l0804E84C:
			Eq_4 ebx_206 = *((word32) dwArg04 + 32);
			if (**((word32) ebx_206 + 16) == 0x00)
				runtime.throw(gs);
			else
			{
				up32 ebp_227 = *ebx_206;
				if ((ebp_227 <= 0x80 || *((word32) dwArg04 + 49) != 0x00 && *((word32) dwArg04 + 48) == 0x04) && (ebp_227 > 0x80 || *((word32) dwArg04 + 49) == 0x00 && (byte) ebp_227 == *((word32) dwArg04 + 48)))
				{
					Eq_4 esi_307 = *((word32) dwArg04 + 36);
					ptr32 edi_308 = *esi_307;
					if ((edi_308 <= 0x80 || *((word32) dwArg04 + 0x0033) != 0x00 && *((word32) dwArg04 + 50) == 0x04) && (edi_308 > 0x80 || *((word32) dwArg04 + 0x0033) == 0x00 && (byte) edi_308 == *((word32) dwArg04 + 50)))
					{
						ptr32 edi_424 = edi_308;
						cu8 dl_363 = *((word32) ebx_206 + 0x0D);
						if (dl_363 > 0x08)
							runtime.throw(gs);
						else
						{
							cu8 bl_380 = *((word32) esi_307 + 0x0D);
							if (bl_380 > 0x08)
								runtime.throw(gs);
							else
							{
								ui32 edx_392 = (word32) dl_363;
								if (edx_392 == 0x00)
									runtime.panicdivide(gs);
								else
								{
									Eq_4 esi_397 = eax_194;
									if ((uint32) ((uint64) ebp_227 % edx_392) != 0x00)
										runtime.throw(gs);
									else
									{
										ui32 edx_420 = (word32) bl_380;
										if (edx_420 == 0x00)
											runtime.panicdivide(gs);
										else
										{
											word24 ebx_24_8_497 = SLICE(edx_420, word24, 8);
											if ((uint32) ((uint64) edi_308 % edx_420) != 0x00)
												runtime.throw(gs);
											else if ((uint32) (0x08 % edx_392) != 0x00)
												runtime.throw(gs);
											else if ((uint32) (0x08 % edx_420) != 0x00)
												runtime.throw(gs);
											else
											{
												uip32 eax_1058 = 0x00;
												while (true)
												{
													int8 cl_580;
													Eq_4 dwLoc30_865 = (word32) rLoc30;
													Eq_4 dwLoc2C_867 = SLICE(rLoc30, word32, 32);
													cu8 al_484 = (byte) eax_1058;
													uip32 eax_581 = eax_1058;
													if (((int8) (esi_397 >= 0x08) & (int8) (edx_195 == 0x00) | (int8) (edx_195 > 0x00)) == 0x00)
														cl_580 = 0x00;
													else
													{
														runtime.int64tofloat64(ebx_24_8_497, gs, SEQ(edx_195, esi_397));
														word32 ecx_524 = (word32) al_484;
														ui32 ebx_542 = 0x01 << (byte) ecx_524 - 0x20 & 0x00 - ((byte) ecx_524 < 0x40);
														word32 eax_543 = 0x20 - ecx_524;
														Eq_4 ebp_553 = 0x01 >> (byte) eax_543 & 0x00 - ((byte) eax_543 < 0x20) | ebx_542;
														runtime.uint64tofloat64(gs, ebp_553);
														ebx_24_8_497 = SLICE(ebx_542, word24, 8);
														nLoc33 = SLICE(ebp_553, word24, 8);
														cl_580 = (int8) ((real32) (real64) (uint128) (real64) (uint128) rLoc30 >= (real32) ((uint128) $f32.40d00000) * (real32) ((real64) ((uint128) rLoc30)));
														eax_581 = (word32) al_484;
														esi_397 = eax_194;
													}
													cu8 al_597 = (byte) eax_581;
													if (cl_580 == 0x00)
														break;
													eax_1058 = eax_581 + 0x01;
												}
												Eq_4 dwLoc34_883;
												Eq_4 ecx_657;
												Eq_4 edx_665;
												if (al_597 == 0x00)
												{
													ecx_657.u0 = 0x00;
													edx_665 = dwArg14;
												}
												else
												{
													esi_397 = runtime.makeBucketArray(gs, dwArg04, al_597, out edi_424);
													dwLoc34_883 = SEQ(nLoc33, al_597);
													if (dwLoc2C_867 == 0x00)
														ecx_657.u0 = 0x00;
													else
													{
														runtime.newobject(gs, 135085088);
														if (g_t81576F0 == 0x00)
															*((word32) dwLoc34_883 + 8) = dwLoc2C_867;
														else
														{
															runtime.writebarrierptr((word32) dwLoc34_883 + 8, dwLoc2C_867);
															dwLoc34_883 = dwLoc2C_867;
														}
														ecx_657 = dwLoc34_883;
													}
													edx_665 = dwLoc30_865;
													al_597 = al_484;
												}
												Eq_4 ebx_676 = dwArg10;
												if (dwArg10 == 0x00)
												{
													runtime.newobject(gs, *((word32) dwArg04 + 44));
													ebx_676 = dwLoc34_883;
													al_597 = al_484;
												}
												*ebx_676 = 0x00;
												((word32) ebx_676 + 5)->u1 = al_597;
												Eq_4 ebp_710 = (word32) ebx_676 + 24;
												if (g_t81576F0 == 0x00)
													*((word32) ebx_676 + 24) = ecx_657;
												else
													runtime.writebarrierptr(ebp_710, ecx_657);
												*((word32) ebx_676 + 4) = 0x00;
												Eq_4 eax_734 = *((word32) gs->ptr0000->tFFFFFFFC + 24);
												Eq_4 ecx_735 = *((word32) eax_734 + 0x0094);
												Eq_4 ebp_740 = ecx_735 << 0x01 ^ ecx_735 >> 0x1F & 0xA8888EEF;
												*((word32) eax_734 + 0x0094) = ebp_740;
												*((word32) ebx_676 + 8) = ebp_740;
												Eq_4 ecx_744 = (word32) ebx_676 + 0x0C;
												Eq_4 ebp_745 = (word32) ebx_676 + 16;
												if (g_t81576F0 == 0x00)
												{
													*((word32) ebx_676 + 0x0C) = edx_665;
													((word32) ebx_676 + 16)->u0 = 0x00;
												}
												else
												{
													runtime.writebarrierptr(ecx_744, edx_665);
													runtime.writebarrierptr(ebp_745, 0x00);
												}
												((word32) ebx_676 + 20)->u0 = 0x00;
												*((word32) ebx_676 + 6) = 0x00;
												ediOut = edi_424;
												return esi_397;
											}
										}
									}
								}
							}
						}
					}
					else
						runtime.throw(gs);
				}
				else
					runtime.throw(gs);
			}
		}
	}
	eax_194.u0 = 0x00;
	edx_195.u0 = 0x00;
	goto l0804E84C;
}

// 0804ED80: Register Eq_4 runtime.mapaccess2(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack ptr32 dwArg0C, Register out Eq_6649 esiOut)
// Called from:
//      reflect.mapaccess
//      sync.(*Map).Load
//      sync.(*Map).Store
//      sync.(*Map).LoadOrStore
Eq_4 runtime.mapaccess2(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, ptr32 dwArg0C, union Eq_6649 & esiOut)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (dwArg08 == 0x00 || *dwArg08 == 0x00)
	{
		esiOut = esi;
		return ebx;
	}
	else if ((*((word32) dwArg08 + 4) & 0x04) != 0x00)
		runtime.throw(gs);
	else
	{
		Eq_4 ecx_47 = *((word32) *((word32) dwArg04 + 32) + 16);
		<anonymous> ** edx_49 = *ecx_47;
		(*edx_49)();
		cu8 cl_67 = *((word32) dwArg08 + 5);
		uint32 esi_72 = 0x01 << cl_67 & 0x00 - (cl_67 < 0x20);
		int32 eax_77 = (word32) *((word32) dwArg04 + 52);
		Eq_6649 esi_156 = esi_72 - 0x01;
		Eq_6649 ecx_105 = (word32) *((word32) dwArg08 + 0x0C) + (esi_72 - 0x01 & dwLoc14) *s eax_77;
		Eq_4 ebp_80 = *((word32) dwArg08 + 16);
		if (ebp_80 != 0x00)
		{
			if ((*((word32) dwArg08 + 4) & 0x08) == 0x00)
				esi_156 = esi_72 - 0x01 >> 0x01;
			esi_156 = (esi_156 & dwLoc14) *s eax_77;
			word32 eax_98 = esi_156 + ebp_80;
			if (*eax_98 >= 0x04)
				ecx_105 = eax_98;
		}
		Eq_6649 al_113;
		if ((byte) (dwLoc14 >> 0x18) < 0x04)
			al_113 = (byte) (dwLoc14 >> 0x18) + 0x04;
		else
			al_113 = (byte) (dwLoc14 >> 0x18);
		al_135 = al_113;
		do
		{
			Eq_6649 al_135;
			Eq_6760 edx_123 = 0x00;
			ecx_133 = ecx_105;
			while (true)
			{
				Eq_6649 ecx_133;
				byte bLoc14_261 = (byte) dwLoc14;
				if (edx_123 >= 0x08)
					break;
				if (al_135 == Mem130[ecx_133 + edx_123:byte])
				{
					struct Eq_6782 * ebx_162;
					esi_156 = ecx_133;
					struct Eq_6782 * ebp_157 = (word32) ecx_133 + ((word32) (*((word32) dwArg04 + 48)) *s edx_123 + 0x08);
					if (*((word32) dwArg04 + 49) != 0x00)
						ebx_162 = ebp_157->ptr0000;
					else
						ebx_162 = ebp_157;
					<anonymous> ** edx_167 = *((word32) ecx_47 + 4);
					(*edx_167)();
					if (bLoc14_261 != 0x00)
					{
						Eq_4 ebx_188 = edx_123 *s (word32) (*((word32) dwArg04 + 50));
						*((word32) dwArg04 + 0x0033) == 0x00;
						esiOut = ecx_133;
						return ebx_188;
					}
					al_135 = al_113;
					ecx_133 = ecx_105;
				}
				edx_123 = (word32) edx_123 + 1;
			}
			ecx_105 = *((word32) (ecx_133 - 0x04) + (word32) (*((word32) dwArg04 + 52)));
		} while (ecx_105 != 0x00);
		esiOut = esi_156;
		return dwArg04;
	}
}

// 0804EF80: void runtime.mapaccessK(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C)
// Called from:
//      runtime.mapiternext
void runtime.mapaccessK(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (dwArg08 == 0x00 || *dwArg08 == 0x00)
		return;
	Eq_4 ebx_32 = *((word32) *((word32) dwArg04 + 32) + 16);
	<anonymous> ** edx_34 = *ebx_32;
	(*edx_34)();
	cu8 cl_51 = *((word32) dwArg08 + 5);
	uint32 ebp_56 = 0x01 << cl_51 & 0x00 - (cl_51 < 0x20);
	int32 edi_62 = (word32) *((word32) dwArg04 + 52);
	uint32 ebp_59 = ebp_56 - 0x01;
	cu8 * ecx_101 = (word32) *((word32) dwArg08 + 0x0C) + (ebp_56 - 0x01 & dwLoc18) *s edi_62;
	Eq_4 ebx_65 = *((word32) dwArg08 + 16);
	if (ebx_65 != 0x00)
	{
		if ((*((word32) dwArg08 + 4) & 0x08) == 0x00)
			ebp_59 = ebp_56 - 0x01 >> 0x01;
		cu8 * ebx_88 = (word32) ebx_65 + (ebp_59 & dwLoc18) *s edi_62;
		if (*ebx_88 >= 0x04)
			ecx_101 = ebx_88;
	}
	uint32 eax_379 = dwLoc18 >> 0x18;
	if ((byte) (dwLoc18 >> 0x18) < 0x04)
		eax_379 = SEQ(SLICE((dwLoc18 >> 0x18) + 0x04, word24, 8), (byte) (dwLoc18 >> 0x18) + 0x04);
	byte al_109 = (byte) eax_379;
	uint32 eax_207 = eax_379;
	do
	{
		Eq_6930 edx_118 = 0x00;
		ecx_128 = ecx_101;
		while (true)
		{
			cu8 * ecx_128;
			byte bLoc18_268 = (byte) dwLoc18;
			byte al_138 = (byte) eax_207;
			if (edx_118 >= 0x08)
				break;
			if (al_138 == Mem125[ecx_128 + edx_118:byte])
			{
				struct Eq_6954 * ebp_150 = ecx_128 + ((word32) (*((word32) dwArg04 + 48)) *s edx_118 + 0x08);
				if (*((word32) dwArg04 + 49) != 0x00)
					ebp_150 = ebp_150->ptr0000;
				<anonymous> ** edx_168 = *((word32) ebx_32 + 4);
				(*edx_168)();
				if (bLoc18_268 != 0x00)
				{
					*((word32) dwArg04 + 0x0033) == 0x00;
					return;
				}
				eax_207 = (word32) al_109;
				ecx_128 = ecx_101;
			}
			edx_118 = (word32) edx_118 + 1;
		}
		ecx_101 = (cu8 *) (ecx_128 - 0x04 + (word32) (*((word32) dwArg04 + 52)));
	} while (ecx_101 != null);
}

// 0804F150: Register word128 runtime.mapassign(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C, Register out Eq_6991 xmm1Out)
// Called from:
//      sync.(*Map).Store
//      sync.(*Map).LoadOrStore
//      sync.(*Map).dirtyLocked
word128 runtime.mapassign(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C, union Eq_6991 & xmm1Out)
{
	Eq_4 dwLoc50 = (word32) rLoc50;
	word32 dwLoc4C = SLICE(rLoc50, word32, 32);
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (dwArg08 == 0x00)
		runtime.gopanic(gs);
	else if ((*((word32) dwArg08 + 4) & 0x04) != 0x00)
		runtime.throw(gs);
	else
	{
		Eq_4 ecx_53 = *((word32) *((word32) dwArg04 + 32) + 16);
		Eq_4 ebx_56 = *((word32) dwArg08 + 8);
		<anonymous> ** edx_55 = *ecx_53;
		(*edx_55)();
		*((word32) dwArg08 + 4) |= 0x04;
		Eq_4 dwLoc54_1019 = ebx_56;
		real64 rLoc50_1003 = rLoc50;
		if (*((word32) dwArg08 + 0x0C) == 0x00)
		{
			word32 edi_1223;
			runtime.newarray(gs, *((word32) dwArg04 + 40), 0x01, out edi_1223);
			dwLoc54_1019.u0 = 0x01;
			if (g_t81576F0 == 0x00)
				*((word32) dwArg08 + 0x0C) = dwLoc50;
			else
			{
				runtime.writebarrierptr((word32) dwArg08 + 0x0C, dwLoc50);
				dwLoc54_1019 = dwLoc50;
			}
		}
		while (true)
		{
			cu8 cl_123 = *((word32) dwArg08 + 5);
			word32 dwLoc4C_1012 = SLICE(rLoc50_1003, word32, 32);
			int32 ebx_131 = (0x00 - (cl_123 < 0x20) & 0x01 << cl_123) - 0x01 & dwLoc50;
			if (*((word32) dwArg08 + 16) != 0x00)
			{
				dwLoc54_1019 = dwArg08;
				xmm0 = runtime.growWork(gs, dwArg04, dwArg08, ebx_131, out xmm1);
				rLoc50_1003 = SEQ(dwLoc4C_1012, ebx_131);
			}
			Eq_4 edx_170 = dwArg08;
			Eq_4 ebx_175 = (word32) *((word32) dwArg08 + 0x0C) + ebx_131 *s (word32) (*((word32) dwArg04 + 52));
			Eq_4 al_179 = (byte) (dwLoc50 >> 0x18);
			if (al_179 < 0x04)
				al_179 = (byte) (dwLoc50 >> 0x18) + 0x04;
			Eq_7125 ecx_188 = 0x00;
			Eq_4 esi_189 = 0x00;
			Eq_4 edi_190 = 0x00;
			while (true)
			{
				union Eq_4 * dwLoc44_861 = null;
				word32 eax_1216 = (word32) al_179;
				while (true)
				{
					word32 dwLoc50_971 = (word32) rLoc50_1003;
					Eq_7125 dwLoc4C_887 = SLICE(rLoc50_1003, word32, 32);
					byte bLoc50_972 = (byte) dwLoc50_971;
					word32 dwLoc4C_1214 = SLICE(rLoc50_1003, word32, 32);
					byte al_614 = (byte) eax_1216;
					if (dwLoc44_861 >= (union Eq_4 *) 0x08)
						break;
					word32 eax_1218;
					Eq_4 ebx_744;
					word32 esi_616 = CONVERT(Mem209[ebx_175 + dwLoc44_861:byte], byte, word32);
					word32 ebx_617 = ebx_175 + dwLoc44_861;
					if (al_614 != (byte) esi_616)
					{
						if ((byte) esi_616 == 0x00)
						{
							if (ecx_188 != 0x00)
							{
								ebx_744 = esi_189;
								eax_1218 = eax_1216;
							}
							else
							{
								int32 esi_764 = (word32) *((word32) dwArg04 + 48);
								ecx_188 = ebx_617;
								ebx_744 = (word32) ebx_175 + (dwLoc44_861 *s esi_764 + 0x08);
								edi_190 = (word32) ebx_175 + (((word32) (*((word32) dwArg04 + 50)) *s dwLoc44_861 + esi_764 * 0x08) + 0x08);
								eax_1218 = eax_1216;
							}
						}
						else
						{
							ebx_744 = esi_189;
							eax_1218 = eax_1216;
						}
					}
					else
					{
						Eq_4 eax_632 = (word32) ebx_175 + ((word32) (*((word32) dwArg04 + 48)) *s dwLoc44_861 + 0x08);
						if (*((word32) dwArg04 + 49) != 0x00)
							eax_632 = *eax_632;
						<anonymous> ** edx_642 = *((word32) ecx_53 + 4);
						(*edx_642)();
						dwLoc54_1019 = eax_632;
						if (bLoc50_972 != 0x00)
						{
							if (*((word32) dwArg04 + 55) != 0x00)
							{
								word32 esi_1226;
								word32 edi_1227;
								runtime.typedmemmove(*((word32) dwArg04 + 32), eax_632, dwArg0C, out esi_1226, out edi_1227, out xmm0, out xmm1);
							}
							goto l0804F2EF;
						}
						eax_1218 = (word32) al_179;
						edx_170 = dwArg08;
						ebx_744 = esi_189;
					}
					++dwLoc44_861;
					esi_189 = ebx_744;
					eax_1216 = eax_1218;
				}
				Eq_4 eax_219 = *((word32) (ebx_175 - (union Eq_4 *) 0x04) + (word32) (*((word32) dwArg04 + 52)));
				if (eax_219 == 0x00)
					break;
				ebx_175 = eax_219;
			}
			if (*((word32) edx_170 + 16) != 0x00)
				break;
			int8 al_357;
			word32 ebp_232 = (word32) *((word32) edx_170 + 5);
			Eq_4 eax_229 = *edx_170;
			ui24 ebx_24_8_248 = SLICE(ebp_232, word24, 8);
			Eq_7248 esi_263 = SEQ(SLICE(esi_189, word24, 8), (int8) (eax_229 >> 0x1F == 0x00)) & SEQ(ebx_24_8_248, (int8) (eax_229 >= 0x08));
			Eq_7125 ebp_274 = SEQ(ebx_24_8_248, (int8) (eax_229 >> 0x1F > 0x00)) | esi_263;
			byte al_236 = (byte) ebp_232;
			word24 ebx_24_8_287 = SLICE(eax_229, word24, 8);
			Eq_7125 ebp_282 = ebp_274;
			if ((byte) ebp_274 == 0x00)
				al_357 = 0x00;
			else
			{
				runtime.int64tofloat64(ebx_24_8_287, gs, SEQ(eax_229 >> 0x1F, eax_229));
				word32 ecx_302 = (word32) al_236;
				cu8 cl_315 = (byte) -(ecx_302 + ~0x1F);
				Eq_4 edx_330 = 0x01 >> cl_315 & 0x00 - (cl_315 < 0x20) | 0x01 << (byte) ecx_302 + 0xE0 & 0x00 - ((byte) ecx_302 < 0xC0);
				runtime.uint64tofloat64(gs, edx_330);
				dwLoc54_1019 = edx_330;
				al_357 = (int8) ((real32) (real64) (uint128) (real64) (uint128) rLoc50_1003 >= (real32) ((uint128) $f32.40d00000) * (real32) ((real64) ((uint128) rLoc50_1003)));
				edx_170 = dwArg08;
			}
			if (al_357 == 0x00)
			{
				int8 al_379;
				word32 ebx_372 = (word32) *((word32) edx_170 + 5);
				cup16 ax_376 = *((word32) edx_170 + 6);
				if ((byte) ebx_372 < 0x10)
				{
					cu8 cl_385 = (byte) ebx_372;
					esi_263 = 0x01 << cl_385 & 0x00 - (cl_385 < 0x20);
					al_379 = (int8) (ax_376 >= (word16) esi_263);
				}
				else
					al_379 = (int8) (ax_376 >= 0x8000);
				ebp_282 = ecx_188;
				if (al_379 == 0x00)
					break;
			}
			dwLoc54_1019 = edx_170;
			xmm0 = runtime.hashGrow(ebp_282, esi_263, gs, dwArg04, edx_170, out xmm1);
		}
		Eq_4 eax_438;
		Eq_4 edi_437 = edi_190;
		Eq_7125 ebp_399 = ecx_188;
		if (ecx_188 != 0x00)
			eax_438 = esi_189;
		else
		{
			runtime.(*hmap).newoverflow(gs, edx_170, dwArg04, ebx_175);
			dwLoc54_1019 = dwArg04;
			ebp_399 = dwLoc4C_887;
			edi_437 = (word32) dwLoc4C_887 + 8 + (word32) (*((word32) dwArg04 + 48)) * 0x08;
			eax_438 = (word32) dwLoc4C_887 + 8;
		}
		if (*((word32) dwArg04 + 49) != 0x00)
		{
			runtime.newobject(gs, *((word32) dwArg04 + 32));
			if (g_t81576F0 == 0x00)
				*eax_438 = dwLoc54_1019;
			else
				runtime.writebarrierptr(eax_438, dwLoc54_1019);
			eax_438 = dwLoc54_1019;
		}
		if (*((word32) dwArg04 + 0x0033) != 0x00)
		{
			runtime.newobject(gs, *((word32) dwArg04 + 36));
			if (g_t81576F0 == 0x00)
				*edi_437 = dwLoc54_1019;
			else
				runtime.writebarrierptr(edi_437, dwLoc54_1019);
		}
		word32 edi_1225;
		word32 esi_1224;
		runtime.typedmemmove(*((word32) dwArg04 + 32), eax_438, dwArg0C, out esi_1224, out edi_1225, out xmm0, out xmm1);
		*ebp_399 = al_179;
		*dwArg08 = (word32) *dwArg08 + 1;
l0804F2EF:
		word32 edx_705 = (word32) *((word32) dwArg08 + 4);
		if (((byte) edx_705 & 0x04) == 0x00)
			runtime.throw(gs);
		else
		{
			*((word32) dwArg08 + 4) = (byte) edx_705 & ~0x04;
			*((word32) dwArg04 + 0x0033) == 0x00;
			xmm1Out = xmm1;
			return xmm0;
		}
	}
}

// 0804F700: Register (ptr32 word32) runtime.mapiterinit(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C)
// Called from:
//      reflect.mapiterinit
//      sync.(*Map).dirtyLocked
word32 * runtime.mapiterinit(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (g_t81576F0 == 0x00)
	{
		*dwArg0C = 0x00;
		*((word32) dwArg0C + 4) = 0x00;
		((word32) dwArg0C + 8)->u0 = 0x00;
		((word32) dwArg0C + 0x0C)->u0 = 0x00;
		((word32) dwArg0C + 16)->u0 = 0x00;
		((word32) dwArg0C + 20)->u0 = 0x00;
		((word32) dwArg0C + 24)->u0 = 0x00;
		((word32) dwArg0C + 28)->u0 = 0x00;
	}
	else
	{
		runtime.writebarrierptr(dwArg0C, 0x00);
		runtime.writebarrierptr((word32) dwArg0C + 4, 0x00);
		runtime.writebarrierptr((word32) dwArg0C + 8, 0x00);
		runtime.writebarrierptr((word32) dwArg0C + 0x0C, 0x00);
		runtime.writebarrierptr((word32) dwArg0C + 16, 0x00);
		runtime.writebarrierptr((word32) dwArg0C + 20, 0x00);
		runtime.writebarrierptr((word32) dwArg0C + 24, 0x00);
		runtime.writebarrierptr((word32) dwArg0C + 28, 0x00);
		dwLoc28.u0 = 0x00;
	}
	if (dwArg08 == 0x00 || *dwArg08 == 0x00)
	{
		if (g_t81576F0 == 0x00)
		{
			*dwArg0C = 0x00;
			*((word32) dwArg0C + 4) = 0x00;
		}
		else
		{
			runtime.writebarrierptr(dwArg0C, 0x00);
			runtime.writebarrierptr((word32) dwArg0C + 4, 0x00);
		}
		return (word32) dwArg0C + 4;
	}
	else
	{
		if (g_t81576F0 == 0x00)
		{
			*((word32) dwArg0C + 8) = dwArg04;
			*((word32) dwArg0C + 0x0C) = dwArg08;
		}
		else
		{
			runtime.writebarrierptr((word32) dwArg0C + 8, dwArg04);
			runtime.writebarrierptr((word32) dwArg0C + 0x0C, dwArg08);
			dwLoc28 = dwArg08;
		}
		*((word32) dwArg0C + 38) = *((word32) dwArg08 + 5);
		Eq_4 ebp_190 = *((word32) dwArg08 + 0x0C);
		if (g_t81576F0 == 0x00)
			*((word32) dwArg0C + 16) = ebp_190;
		else
		{
			runtime.writebarrierptr((word32) dwArg0C + 16, ebp_190);
			dwLoc28 = ebp_190;
		}
		if ((*((word32) *((word32) dwArg04 + 40) + 0x0F) & 0x80) != 0x00)
		{
			if (*((word32) dwArg08 + 24) == 0x00)
			{
				runtime.newobject(gs, 135085088);
				if (g_t81576F0 == 0x00)
					*((word32) dwArg08 + 24) = dwLoc28;
				else
					runtime.writebarrierptr((word32) dwArg08 + 24, dwLoc28);
			}
			if (**((word32) dwArg08 + 24) == 0x00)
			{
				runtime.newobject(gs, 0x080C9100);
				Eq_4 ecx_281 = *((word32) dwArg08 + 24);
				if (g_t81576F0 == 0x00)
					*ecx_281 = dwLoc28;
				else
					runtime.writebarrierptr(ecx_281, dwLoc28);
			}
			Eq_4 ebx_307 = *((word32) dwArg08 + 24);
			if (g_t81576F0 == 0x00)
			{
				Eq_4 ebp_357 = *((word32) ebx_307 + 4);
				*((word32) dwArg0C + 24) = *ebx_307;
				*((word32) dwArg0C + 28) = ebp_357;
			}
			else
			{
				word32 edi_802;
				word128 xmm1_804;
				word128 xmm0_803;
				word32 esi_801;
				runtime.typedmemmove(0x080CC320, (word32) dwArg0C + 24, ebx_307, out esi_801, out edi_802, out xmm0_803, out xmm1_804);
			}
		}
		Eq_7621 ebx_380;
		Eq_4 ebx_367 = *((word32) gs->ptr0000->tFFFFFFFC + 24);
		Eq_7621 ebp_368 = *((word32) ebx_367 + 0x0094);
		Eq_7621 esi_373 = ebp_368 << 0x01 ^ ebp_368 >> 0x1F & 0xA8888EEF;
		*((word32) ebx_367 + 0x0094) = esi_373;
		if (*((word32) dwArg08 + 5) > 0x1C)
		{
			Eq_4 ebx_383 = *((word32) gs->ptr0000->tFFFFFFFC + 24);
			int32 ebp_384 = *((word32) ebx_383 + 0x0094);
			int32 edi_389 = ebp_384 << 0x01 ^ ebp_384 >> 0x1F & 0xA8888EEF;
			*((word32) ebx_383 + 0x0094) = edi_389;
			ebx_380 = (word32) esi_373 + (edi_389 << 0x1F);
		}
		else
			ebx_380 = esi_373;
		cu8 cl_398 = *((word32) dwArg08 + 5);
		*((word32) dwArg0C + 32) = (0x01 << cl_398 & 0x00 - (cl_398 < 0x20)) - 0x01 & ebx_380;
		cu8 cl_412 = *((word32) dwArg08 + 5);
		*((word32) dwArg0C + 36) = (byte) (ebx_380 >> cl_412) & 0x00 - (byte) (cl_412 < 0x20) & 0x07;
		*((word32) dwArg0C + 40) = *((word32) dwArg0C + 32);
		*((word32) dwArg0C + 37) = 0x00;
		if (g_t81576F0 == 0x00)
			((word32) dwArg0C + 20)->u0 = 0x00;
		else
			runtime.writebarrierptr((word32) dwArg0C + 20, 0x00);
		if ((*((word32) dwArg08 + 4) & 0x03) != 0x03)
			runtime/internal/atomic.Or8((word32) dwArg08 + 4, 0x03);
		return runtime.mapiternext(gs, dwArg0C);
	}
}

// 0804FB30: Register Eq_4 runtime.mapiternext(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      runtime.mapiterinit
//      reflect.mapiternext
//      sync.(*Map).dirtyLocked
Eq_4 runtime.mapiternext(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 ebx_18 = *((word32) dwArg04 + 0x0C);
	if ((*((word32) ebx_18 + 4) & 0x04) != 0x00)
		runtime.throw(gs);
	else
	{
		Eq_4 ebp_40 = *((word32) dwArg04 + 8);
		Eq_4 edi_229 = *((word32) dwArg04 + 40);
		Eq_4 ecx_138 = ebp_40;
		Eq_4 ebp_232 = *((word32) dwArg04 + 20);
		Eq_4 edx_107 = ebx_18;
		uip32 ebx_1170 = (word32) *((word32) dwArg04 + 39);
		Eq_4 eax_236 = *((word32) dwArg04 + 44);
		Eq_4 esi_49 = *((word32) *((word32) ebp_40 + 32) + 16);
		Eq_4 dwLoc44_1159 = dwLoc44;
		while (true)
		{
			uip32 ebx_1163 = ebx_1170;
			if (ebp_232 == 0x00)
			{
				if (edi_229 == *((word32) dwArg04 + 32))
				{
					Eq_4 ebx_62 = (word32) *((word32) dwArg04 + 37);
					if ((byte) ebx_62 != 0x00)
					{
						if (g_t81576F0 == 0x00)
							dwArg04->u0 = 0x00;
						else
							runtime.writebarrierptr(dwArg04, 0x00);
						if (g_t81576F0 == 0x00)
							((word32) dwArg04 + 4)->u0 = 0x00;
						else
							runtime.writebarrierptr((word32) dwArg04 + 4, 0x00);
						return ebx_62;
					}
				}
				Eq_4 ebx_147;
				Eq_4 ecx_149;
				Eq_4 ebx_109 = *((word32) edx_107 + 16);
				if (ebx_109 != 0x00 && *((word32) dwArg04 + 38) == *((word32) edx_107 + 5))
				{
					Eq_4 ebp_150 = *((word32) dwArg04 + 0x0C);
					word32 esi_151 = (word32) *((word32) ebp_150 + 5);
					if ((*((word32) ebp_150 + 4) & 0x08) == 0x00)
						--esi_151;
					cu8 cl_174 = (byte) esi_151;
					int32 esi_183 = (word32) *((word32) ecx_138 + 52);
					Eq_4 eax_186 = (word32) ebx_109 + ((0x01 << cl_174 & 0x00 - (cl_174 < 0x20)) - 0x01 & edi_229) *s esi_183;
					if (*eax_186 < 0x04)
					{
						ebx_147 = (word32) *((word32) dwArg04 + 16) + esi_183 *s edi_229;
						ecx_149.u0 = ~0x00;
					}
					else
					{
						ecx_149 = edi_229;
						ebx_147 = eax_186;
					}
				}
				else
				{
					ebx_147 = (word32) *((word32) dwArg04 + 16) + (word32) (*((word32) ecx_138 + 52)) *s edi_229;
					ecx_149.u0 = ~0x00;
				}
				Eq_4 eax_219;
				cu8 cl_211 = *((word32) dwArg04 + 38);
				Eq_4 esi_206 = (word32) edi_229 + 1;
				if (esi_206 == (0x00 - (cl_211 < 0x20) & 0x01 << cl_211))
				{
					*((word32) dwArg04 + 37) = 0x01;
					eax_219.u0 = 0x00;
				}
				else
					eax_219 = esi_206;
				ecx_138 = ebp_40;
				edi_229 = eax_219;
				ebp_232 = ebx_147;
				eax_236 = ecx_149;
				ebx_1163 = 0x00;
			}
			uip32 ebx_1155 = ebx_1163;
			while (true)
			{
				word24 nLoc43_866 = SLICE(dwLoc44_1159, word24, 8);
				byte bLoc44_850 = (byte) dwLoc44_1159;
				cu8 bl_245 = (byte) ebx_1155;
				if (bl_245 >= 0x08)
					break;
				ui32 edi_264 = (word32) *((word32) dwArg04 + 36) + ebx_1155;
				ui32 edi_282 = (word32) (byte) edi_264;
				int32 esi_275 = (word32) *((word32) ecx_138 + 48);
				word32 edi_285 = (word32) *((word32) ebp_232 + (edi_282 & 0x07));
				Eq_4 esi_286 = (word32) ebp_232 + (esi_275 *s (edi_264 & 0x07) + 0x08);
				Eq_4 eax_1162 = (word32) ebp_232 + (((word32) (*((word32) ecx_138 + 50)) *s (edi_264 & 0x07) + esi_275 * 0x08) + 0x08);
				uip32 ebx_388 = ebx_1155;
				if ((byte) edi_285 != 0x00)
				{
					ebx_388 = ebx_1155;
					if ((byte) edi_285 == 0x01)
						goto l0804FB8A;
					word24 nLoc43_1058;
					if (eax_236 != ~0x00 && (*((word32) edx_107 + 4) & 0x08) == 0x00)
					{
						Eq_4 edi_338;
						if (*((word32) ecx_138 + 49) != 0x00)
							edi_338 = *esi_286;
						else
							edi_338 = esi_286;
						nLoc43_1058 = nLoc43_866;
						byte bLoc44_1149 = (byte) dwLoc44_1159;
						nLoc43_1058 = SLICE(dwLoc44_1159, word24, 8);
						if (*((word32) ecx_138 + 54) == 0x00)
						{
							<anonymous> ** edx_351 = *((word32) esi_49 + 4);
							(*edx_351)();
							if (bLoc44_850 == 0x00)
							{
								cu8 cl_373 = *((word32) dwArg04 + 38) - 0x01;
								if ((eax_236 >> cl_373 & 0x00 - (cl_373 < 0x20)) == ((word32) (*((word32) ebp_232 + (edi_282 & 0x07))) & 0x01))
									goto l0804FC90;
								ecx_138 = ebp_40;
								edx_107 = ebx_18;
								ebx_388 = (word32) bl_245;
								goto l0804FB8A;
							}
							edx_107 = ebx_18;
						}
						<anonymous> ** ecx_392 = *esi_49;
						(*ecx_392)();
						word32 eax_408 = (word32) *((word32) dwArg04 + 38);
						if ((dwLoc44_1159 & (0x01 << (byte) eax_408 & 0x00 - ((byte) eax_408 < 0x20)) - 0x01) == eax_236)
							goto l0804FC90;
						ecx_138 = ebp_40;
						edx_107 = ebx_18;
						ebx_388 = (word32) bl_245;
						goto l0804FB8A;
					}
l0804FC90:
					byte cl_431 = *((word32) ebp_232 + (edi_282 & 0x07));
					if (cl_431 != 0x02 && cl_431 != 0x03)
					{
						Eq_4 edx_442;
						if (*((word32) ebp_40 + 49) != 0x00)
							edx_442 = *esi_286;
						else
							edx_442 = esi_286;
						if (g_t81576F0 == 0x00)
							*dwArg04 = edx_442;
						else
							runtime.writebarrierptr(dwArg04, edx_442);
						Eq_4 ecx_482;
						if (*((word32) ebp_40 + 0x0033) != 0x00)
							ecx_482 = *eax_1162;
						else
							ecx_482 = eax_1162;
						if (g_t81576F0 == 0x00)
							*((word32) dwArg04 + 4) = ecx_482;
						else
							runtime.writebarrierptr((word32) dwArg04 + 4, ecx_482);
						goto l0804FD2B;
					}
					if (*((word32) ebp_40 + 49) != 0x00)
						dwLoc44_1159 = *esi_286;
					else
						dwLoc44_1159 = esi_286;
					if (*((word32) ebp_40 + 54) == 0x00)
					{
						<anonymous> ** edx_553 = *((word32) esi_49 + 4);
						(*edx_553)();
						if (bLoc44_850 == 0x00)
						{
							if (g_t81576F0 == 0x00)
								*dwArg04 = dwLoc44_1159;
							else
								runtime.writebarrierptr(dwArg04, dwLoc44_1159);
							if (*((word32) ebp_40 + 0x0033) != 0x00)
								eax_1162 = *eax_1162;
							if (g_t81576F0 == 0x00)
								*((word32) dwArg04 + 4) = eax_1162;
							else
								runtime.writebarrierptr((word32) dwArg04 + 4, eax_1162);
l0804FD2B:
							*((word32) dwArg04 + 40) = edi_229;
							if (*((word32) dwArg04 + 20) != ebp_232)
							{
								if (g_t81576F0 == 0x00)
									*((word32) dwArg04 + 20) = ebp_232;
								else
									runtime.writebarrierptr((word32) dwArg04 + 20, ebp_232);
							}
							((word32) dwArg04 + 39)->u1 = bl_245 + 0x01;
							*((word32) dwArg04 + 44) = eax_236;
							return ebp_232;
						}
					}
					runtime.mapaccessK(gs, ebp_40, ebx_18, dwLoc44_1159);
					if (dwLoc40 == 0x00)
					{
						ecx_138 = ebp_40;
						edx_107 = ebx_18;
						ebx_388 = (word32) bl_245;
						goto l0804FB8A;
					}
					if (g_t81576F0 == 0x00)
						*dwArg04 = dwLoc40;
					else
						runtime.writebarrierptr(dwArg04, dwLoc40);
					if (g_t81576F0 == 0x00)
						*((word32) dwArg04 + 4) = dwLoc3C;
					else
						runtime.writebarrierptr((word32) dwArg04 + 4, dwLoc3C);
					goto l0804FD2B;
				}
l0804FB8A:
				ebx_1155 = ebx_388 + 0x01;
			}
			ebp_232 = ebp_232 - 0x04 + (word32) (*((word32) ecx_138 + 52));
			ebx_1170 = 0x00;
		}
	}
}

// 080500F0: Register ptr32 runtime.makeBucketArray(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack cu8 bArg08, Register out ptr32 ediOut)
// Called from:
//      runtime.makemap
//      runtime.hashGrow
ptr32 runtime.makeBucketArray(struct Eq_2 * gs, Eq_4 dwArg04, cu8 bArg08, ptr32 & ediOut)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 eax_100;
	word32 ecx_17 = (word32) bArg08;
	cu8 cl_19 = (byte) ecx_17;
	Eq_4 ebx_24 = 0x00 - (cl_19 < 0x20) & 0x01 << cl_19;
	if (cl_19 < 0x04)
	{
		eax_100 = ebx_24;
		goto l080501AC;
	}
	Eq_8374 ecx_49;
	cu8 cl_33 = (byte) ecx_17 + 252;
	Eq_4 esi_39 = (word32) ebx_24 + (0x01 << cl_33 & 0x00 - (cl_33 < 0x20));
	Eq_8388 ebp_40 = **((word32) dwArg04 + 40);
	Eq_8374 ebp_42 = ebp_40 *s esi_39;
	if (ebp_42 >= 0x8000)
	{
		if ((word32) ebp_42 + 0x00002000 < ebp_42)
			ecx_49 = ebp_42;
		else
			ecx_49 = (word32) ebp_42 + 0x00001FFF & ~0x1FFF;
l08050194:
		if (ecx_49 != ebp_42)
		{
			if (ebp_40 == 0x00)
				runtime.panicdivide(gs);
			eax_100 = (uint32) ((uint64) ecx_49 /u ebp_40);
		}
		else
			eax_100 = esi_39;
l080501AC:
		ptr32 edi_115;
		ptr32 esi_117 = runtime.newarray(gs, *((word32) dwArg04 + 40), eax_100, out edi_115);
		if (eax_100 != ebx_24)
		{
			int32 ebx_131 = (word32) *((word32) dwArg04 + 52);
			Eq_4 ecx_136 = (word32) dwLoc14 + (eax_100 - 0x01) *s ebx_131 - 0x04 + ebx_131;
			if (g_t81576F0 == 0x00)
				*ecx_136 = dwLoc14;
			else
				runtime.writebarrierptr(ecx_136, dwLoc14);
		}
		ediOut = edi_115;
		return esi_117;
	}
	else
	{
		if (ebp_42 <= 1016)
		{
			struct Eq_8411 * ecx_70 = (word32) ebp_42 + 7 >> 0x03;
			if (ecx_70 < (struct Eq_8411 *) 0x81)
			{
				uint32 ecx_75 = (word32) ecx_70->b8138640;
				if (ecx_75 < 0x43)
				{
					ecx_49 = (word32) g_a8138820[ecx_75 * 0x02];
					goto l08050194;
				}
			}
			runtime.panicindex(gs);
		}
		struct Eq_8404 * ecx_58 = ebp_42 - 0x0381 >> 0x07;
		if (ecx_58 < (struct Eq_8404 *) 0xF9)
		{
			uint32 ecx_63 = (word32) ecx_58->b81396E0;
			if (ecx_63 < 0x43)
			{
				ecx_49 = (word32) g_a8138820[ecx_63 * 0x02];
				goto l08050194;
			}
		}
		runtime.panicindex(gs);
	}
}

// 080502B0: Register word128 runtime.hashGrow(Register Eq_7125 ebp, Register Eq_7248 esi, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Register out Eq_7345 xmm1Out)
// Called from:
//      runtime.mapassign
//      runtime.mapassign_fast32
//      runtime.mapassign_fast64
//      runtime.mapassign_faststr
word128 runtime.hashGrow(Eq_7125 ebp, Eq_7248 esi, struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, union Eq_7345 & xmm1Out)
{
	Eq_4 dwLoc28_440 = (word32) rLoc28;
	Eq_4 dwLoc24_443 = SLICE(rLoc28, word32, 32);
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	uip32 ecx_565;
	word32 ebx_21 = (word32) *((word32) dwArg08 + 5);
	Eq_8514 ecx_18 = *dwArg08;
	byte bl_70 = (byte) ebx_21;
	word24 ebx_24_8_74 = SLICE(ebx_21, word24, 8);
	if (((int8) (ecx_18 >> 0x1F > 0x00) | (int8) (ecx_18 >> 0x1F == 0x00) & (int8) (ecx_18 >= 0x08)) == 0x00)
		ecx_565 = 0x00;
	else
	{
		runtime.int64tofloat64(ebx_24_8_74, gs, SEQ(ecx_18 >> 0x1F, ecx_18));
		word32 ecx_88 = (word32) bl_70;
		cu8 cl_99 = (byte) ecx_88 + 0xE0;
		cu8 cl_107 = (byte) -(ecx_88 + ~0x1F);
		uint128 xmm0_126 = (uint128) (real64) (uint128) rLoc28;
		uint128 xmm1_129 = (uint128) rLoc28;
		Eq_4 eax_113 = 0x01 >> cl_107 & 0x00 - (cl_107 < 0x20) | 0x00 - (cl_99 < 0x20) & 0x01 << cl_99;
		Eq_8575 v35_127 = (real32) (real64) xmm0_126;
		real32 v37_130 = (real32) (real64) xmm1_129;
		nLoc2B = SLICE(eax_113, word24, 8);
		xmm0 = SEQ(SLICE(xmm0_126, word96, 32), v35_127);
		xmm1 = SEQ(SLICE(xmm1_129, word96, 32), v37_130);
		ecx_565 = SEQ(SLICE(runtime.uint64tofloat64(gs, eax_113), word24, 8), (int8) (v35_127 >= (real32) ((uint128) $f32.40d00000) * v37_130));
	}
	byte cl_145 = (byte) ecx_565;
	if (cl_145 == 0x00)
		*((word32) dwArg08 + 4) |= 0x08;
	Eq_4 edx_163 = *((word32) dwArg08 + 0x0C);
	cu8 bl_173 = (word32) *((word32) dwArg08 + 5) + (byte) ecx_565;
	word32 edi_569;
	runtime.makeBucketArray(gs, dwArg04, bl_173, out edi_569);
	ui32 ebp_195 = (word32) *((word32) dwArg08 + 4);
	ui32 ebp_197 = ebp_195 & ~0x03;
	Eq_4 dwLoc2C_452 = SEQ(nLoc2B, bl_173);
	if (((byte) ebp_195 & 0x01) != 0x00)
		ebp_197 = ebp_195 & ~0x03 | 0x02;
	*((word32) dwArg08 + 5) = (word32) *((word32) dwArg08 + 5) + cl_145;
	*((word32) dwArg08 + 4) = (byte) ebp_197;
	if (g_t81576F0 == 0x00)
	{
		*((word32) dwArg08 + 16) = edx_163;
		*((word32) dwArg08 + 0x0C) = dwLoc28_440;
	}
	else
	{
		runtime.writebarrierptr((word32) dwArg08 + 16, edx_163);
		runtime.writebarrierptr((word32) dwArg08 + 0x0C, dwLoc28_440);
		dwLoc2C_452 = dwLoc28_440;
	}
	((word32) dwArg08 + 20)->u0 = 0x00;
	*((word32) dwArg08 + 6) = 0x00;
	Eq_4 ecx_273 = *((word32) dwArg08 + 24);
	if (ecx_273 != 0x00)
	{
		Eq_4 ebp_280 = *ecx_273;
		if (ebp_280 != 0x00)
		{
			if (*((word32) ecx_273 + 4) != 0x00)
				runtime.throw(gs);
			if (g_t81576F0 == 0x00)
				*((word32) ecx_273 + 4) = ebp_280;
			else
			{
				runtime.writebarrierptr((word32) ecx_273 + 4, ebp_280);
				dwLoc2C_452 = ebp_280;
			}
			Eq_4 ecx_320 = *((word32) dwArg08 + 24);
			if (g_t81576F0 == 0x00)
				*ecx_320 = 0x00;
			else
			{
				runtime.writebarrierptr(ecx_320, 0x00);
				dwLoc2C_452.u0 = 0x00;
			}
		}
	}
	if (dwLoc24_443 != 0x00)
	{
		if (*((word32) dwArg08 + 24) == 0x00)
		{
			runtime.newobject(gs, 135085088);
			if (g_t81576F0 == 0x00)
				*((word32) dwArg08 + 24) = dwLoc2C_452;
			else
				runtime.writebarrierptr((word32) dwArg08 + 24, dwLoc2C_452);
		}
		Eq_4 eax_391 = *((word32) dwArg08 + 24);
		if (g_t81576F0 == 0x00)
			*((word32) eax_391 + 8) = dwLoc24_443;
		else
			runtime.writebarrierptr((word32) eax_391 + 8, dwLoc24_443);
	}
	xmm1Out = xmm1;
	return xmm0;
}

// 08050590: Register word128 runtime.growWork(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack int32 dwArg0C, Register out Eq_7103 xmm1Out)
// Called from:
//      runtime.mapassign
//      runtime.mapassign_fast32
//      runtime.mapassign_fast64
//      runtime.mapassign_faststr
word128 runtime.growWork(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, int32 dwArg0C, union Eq_7103 & xmm1Out)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	word32 edx_18 = (word32) *((word32) dwArg08 + 5);
	if ((*((word32) dwArg08 + 4) & 0x08) == 0x00)
		--edx_18;
	cu8 cl_35 = (byte) edx_18;
	Eq_7103 xmm1_133;
	word128 xmm0_132 = runtime.evacuate(gs, dwArg04, dwArg08, (0x01 << cl_35 & 0x00 - (cl_35 < 0x20)) - 0x01 & dwArg0C, out xmm1_133);
	if (*((word32) dwArg08 + 16) != 0x00)
		xmm0_132 = runtime.evacuate(gs, dwArg04, dwArg08, *((word32) dwArg08 + 20), out xmm1_133);
	xmm1Out = xmm1_133;
	return xmm0_132;
}

// 08050620: Register word128 runtime.evacuate(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C, Register out Eq_8800 xmm1Out)
// Called from:
//      runtime.growWork
word128 runtime.evacuate(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C, union Eq_8800 & xmm1Out)
{
	while (fp - 0x1C <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	int32 edi_22 = (word32) *((word32) dwArg04 + 52);
	int32 edi_26 = edi_22 *s dwArg0C;
	word32 edi_30 = (word32) *((word32) dwArg08 + 4);
	cu8 * ebx_28 = (word32) *((word32) dwArg08 + 16) + edi_26;
	word32 ebp_29 = (word32) *((word32) dwArg08 + 5);
	if (((byte) edi_30 & 0x08) == 0x00)
		--ebp_29;
	cu8 cl_62 = (byte) ebp_29;
	byte al_51 = (byte) edi_30;
	Eq_4 edi_57 = *((word32) *((word32) dwArg04 + 32) + 16);
	Eq_4 edi_67 = 0x01 << cl_62 & 0x00 - (cl_62 < 0x20);
	if (*ebx_28 >= 0x04)
	{
		Eq_4 edx_108;
		Eq_4 ecx_105;
		Eq_4 eax_109;
		Eq_4 ecx_81 = *((word32) dwArg08 + 0x0C);
		Eq_4 esi_84 = (word32) ecx_81 + edi_26;
		ui32 ebp_82 = (word32) *((word32) dwArg04 + 48);
		Eq_4 ebx_260 = esi_84;
		Eq_4 eax_86 = (word32) ecx_81 + 8 + edi_26;
		Eq_4 esi_257 = (word32) esi_84 + 8 + ebp_82 * 0x08;
		if ((al_51 & 0x08) != 0x00)
		{
			eax_109.u0 = 0x00;
			ecx_105.u0 = 0x00;
			edx_108.u0 = 0x00;
		}
		else
		{
			word32 ebp_98 = (dwArg0C + edi_67) *s edi_22;
			Eq_4 ebp_100 = (word32) ecx_81 + ebp_98;
			ecx_105 = (word32) ecx_81 + (ebp_98 + 0x08);
			edx_108 = (word32) ebp_100 + 8 + ebp_82 * 0x08;
			eax_109 = ebp_100;
		}
		Eq_9018 dwLoc84_1026 = 0x00;
		Eq_4 dwLoc44_1029 = eax_86;
		Eq_9021 dwLoc88_1030 = 0x00;
		Eq_4 eax_128 = eax_109;
		cu8 * ebp_129 = ebx_28;
		while (ebp_129 != null)
		{
			Eq_4 dwLoc4C_1045 = eax_128;
			Eq_4 eax_197 = ebp_129 + 8;
			Eq_4 ebp_198 = ebp_129 + 8 + (word32) (*((word32) dwArg04 + 48)) * 0x08;
			Eq_9045 edi_199 = 0x00;
			while (true)
			{
				byte bLoc94_1077 = (byte) dwLoc94;
				if (edi_199 >= 0x08)
					break;
				if (edi_199 >= 0x08)
					runtime.panicindex(gs);
				Eq_9018 eax_832;
				byte al_222 = Mem219[ebp_129 + edi_199:byte];
				if (al_222 == 0x00)
				{
					Mem845[ebp_129 + edi_199:byte] = 0x01;
					eax_832 = dwLoc84_1026;
					goto l080507EB;
				}
				if (al_222 < 0x04)
					runtime.throw(gs);
				Eq_4 ecx_245;
				if (*((word32) dwArg04 + 49) != 0x00)
					ecx_245 = *eax_197;
				else
					ecx_245 = eax_197;
				int8 cl_386;
				if ((*((word32) dwArg08 + 4) & 0x08) != 0x00)
				{
					cl_386 = 0x01;
					goto l080508A0;
				}
				uint32 edx_292;
				<anonymous> ** edx_271 = *edi_57;
				(*edx_271)();
				Eq_4 eax_284 = dwLoc94;
				if ((*((word32) dwArg08 + 4) & 0x01) != 0x00)
				{
					if (*((word32) dwArg04 + 54) != 0x00)
					{
l08050CE2:
						eax_284 = dwLoc94;
						edx_292 = (word32) al_222;
						goto l08050CE7;
					}
					<anonymous> ** edx_307 = *((word32) edi_57 + 4);
					(*edx_307)();
					if (bLoc94_1077 != 0x00)
						goto l08050CE2;
					Eq_4 eax_330;
					if ((al_222 & 0x01) != 0x00)
						eax_330 = dwLoc94 | edi_67;
					else
						eax_330 = ~edi_67 & dwLoc94;
					uint32 eax_340 = eax_330 >> 0x18;
					if ((byte) eax_340 < 0x04)
						eax_340 += 0x04;
					edx_292 = eax_340;
					eax_284 = eax_330;
				}
				else
					edx_292 = (word32) al_222;
l08050CE7:
				cl_386 = (int8) ((edi_67 & eax_284) == 0x00);
				al_222 = (byte) edx_292;
l080508A0:
				Eq_4 dwLoc50_1199;
				Eq_4 ebp_608;
				Eq_4 esi_607;
				Eq_9021 edi_609;
				Eq_4 ebx_612;
				Eq_9018 ecx_611;
				Eq_4 esi_640 = esi_257;
				Eq_4 ebx_621 = ebx_260;
				Eq_4 edx_427 = edx_108;
				if (cl_386 != 0x00)
				{
					Eq_4 dwLoc28_1224;
					Mem613[ebp_129 + edi_199:byte] = 0x02;
					Eq_9018 ecx_614 = dwLoc84_1026;
					if (dwLoc84_1026 != 0x08)
						dwLoc28_1224 = dwLoc44_1029;
					else
					{
						runtime.(*hmap).newoverflow(gs, dwArg08, dwArg04, ebx_260);
						dwLoc94 = ebx_260;
						ebx_621 = dwLoc90;
						esi_640 = (word32) dwLoc90 + 8 + (word32) (*((word32) dwArg04 + 48)) * 0x08;
						ecx_614.u0 = 0x00;
						dwLoc28_1224 = (word32) dwLoc90 + 8;
					}
					if (ecx_614 >= 0x08)
						runtime.panicindex(gs);
					Mem669[ebx_621 + ecx_614:byte] = al_222;
					if (*((word32) dwArg04 + 49) != 0x00)
					{
						if (g_t81576F0 == 0x00)
							*dwLoc28_1224 = ecx_245;
						else
							runtime.writebarrierptr(dwLoc28_1224, ecx_245);
					}
					else
					{
						word32 esi_1721;
						word32 edi_1722;
						runtime.typedmemmove(*((word32) dwArg04 + 32), dwLoc28_1224, eax_197, out esi_1721, out edi_1722, out xmm0, out xmm1);
						dwLoc94 = eax_197;
					}
					if (*((word32) dwArg04 + 0x0033) != 0x00)
					{
						Eq_4 ebx_791 = *ebp_198;
						if (g_t81576F0 == 0x00)
							*esi_640 = ebx_791;
						else
							runtime.writebarrierptr(esi_640, ebx_791);
					}
					else
					{
						word32 edi_1724;
						word32 esi_1723;
						runtime.typedmemmove(*((word32) dwArg04 + 36), esi_640, ebp_198, out esi_1723, out edi_1724, out xmm0, out xmm1);
						dwLoc94 = ebp_198;
					}
					ecx_611 = (word32) ecx_614.u0 + 1;
					ebx_612 = (word32) dwLoc28_1224 + (word32) (*((word32) dwArg04 + 48));
					ebp_608 = (word32) esi_640 + (word32) (*((word32) dwArg04 + 50));
					edi_609 = dwLoc88_1030;
					dwLoc50_1199 = ecx_105;
					esi_607 = ebx_621;
				}
				else
				{
					Eq_4 dwLoc34_1143;
					Mem395[ebp_129 + edi_199:byte] = 0x03;
					Eq_9021 ecx_396 = dwLoc88_1030;
					if (dwLoc88_1030 != 0x08)
						dwLoc34_1143 = ecx_105;
					else
					{
						runtime.(*hmap).newoverflow(gs, dwArg08, dwArg04, dwLoc4C_1045);
						dwLoc94 = dwLoc4C_1045;
						edx_427 = (word32) dwLoc90 + 8 + (word32) (*((word32) dwArg04 + 48)) * 0x08;
						dwLoc4C_1045 = dwLoc90;
						ecx_396.u0 = 0x00;
						dwLoc34_1143 = (word32) dwLoc90 + 8;
					}
					if (ecx_396 >= 0x08)
						runtime.panicindex(gs);
					Mem457[dwLoc4C_1045 + ecx_396:byte] = al_222;
					if (*((word32) dwArg04 + 49) != 0x00)
					{
						if (g_t81576F0 == 0x00)
							*dwLoc34_1143 = ecx_245;
						else
							runtime.writebarrierptr(dwLoc34_1143, ecx_245);
					}
					else
					{
						word32 esi_1725;
						word32 edi_1726;
						runtime.typedmemmove(*((word32) dwArg04 + 32), dwLoc34_1143, eax_197, out esi_1725, out edi_1726, out xmm0, out xmm1);
						dwLoc94 = eax_197;
					}
					if (*((word32) dwArg04 + 0x0033) != 0x00)
					{
						Eq_4 ebp_573 = *ebp_198;
						if (g_t81576F0 == 0x00)
							*edx_427 = ebp_573;
						else
							runtime.writebarrierptr(edx_427, ebp_573);
					}
					else
					{
						word32 esi_1727;
						word32 edi_1728;
						runtime.typedmemmove(*((word32) dwArg04 + 36), edx_427, ebp_198, out esi_1727, out edi_1728, out xmm0, out xmm1);
						dwLoc94 = ebp_198;
					}
					edx_108 = (word32) edx_427 + (word32) (*((word32) dwArg04 + 50));
					esi_607 = ebx_260;
					ebp_608 = esi_257;
					edi_609 = (word32) ecx_396.u0 + 1;
					dwLoc50_1199 = (word32) dwLoc34_1143 + (word32) (*((word32) dwArg04 + 48));
					ecx_611 = dwLoc84_1026;
					ebx_612 = dwLoc44_1029;
				}
				eax_832 = ecx_611;
				dwLoc44_1029 = ebx_612;
				dwLoc88_1030 = edi_609;
				ecx_105 = dwLoc50_1199;
				ebx_260 = esi_607;
				esi_257 = ebp_608;
l080507EB:
				dwLoc84_1026 = eax_832;
				edi_199 = (word32) edi_199 + 1;
				eax_197 = (word32) eax_197 + (word32) (*((word32) dwArg04 + 48));
				ebp_198 = (word32) ebp_198 + (word32) (*((word32) dwArg04 + 50));
			}
			ebp_129 = (cu8 *) (ebp_129 - 0x04 + (word32) (*((word32) dwArg04 + 52)));
			eax_128 = dwLoc4C_1045;
		}
		if ((*((word32) dwArg08 + 4) & 0x02) == 0x00)
		{
			int32 ebp_145 = (word32) *((word32) dwArg04 + 52);
			Eq_4 ebx_144 = *((word32) dwArg08 + 16);
			int32 ebp_148 = ebp_145 *s dwArg0C;
			if ((*((word32) *((word32) dwArg04 + 40) + 0x0F) & 0x80) == 0x00)
				runtime.memclrHasPointers(gs, (word32) ebx_144 + 8 + ebp_148, ebp_145 + ~0x07);
			else
				runtime.memclrNoHeapPointers((word32) ebx_144 + 8 + ebp_148, ebp_145 + ~0x07);
		}
	}
	Eq_4 edi_875 = edi_67;
	if (dwArg0C == *((word32) dwArg08 + 20))
	{
		*((word32) dwArg08 + 20) = (word32) dwArg0C + 1;
		if ((word32) dwArg0C + 0x0401 <= edi_67)
			edi_875 = (word32) dwArg0C + 0x0401;
		while (true)
		{
			Eq_4 edx_886 = *((word32) dwArg08 + 20);
			if (edx_886 == edi_875 || *((word32) (*((word32) dwArg08 + 16)) + (word32) (*((word32) dwArg04 + 52)) *s edx_886) >= 0x04)
				break;
			*((word32) dwArg08 + 20) = (word32) edx_886 + 1;
		}
		if (edi_67 == edx_886)
		{
			if (g_t81576F0 == 0x00)
				((word32) dwArg08 + 16)->u0 = 0x00;
			else
				runtime.writebarrierptr((word32) dwArg08 + 16, 0x00);
			Eq_4 ecx_931 = *((word32) dwArg08 + 24);
			if (ecx_931 != 0x00)
			{
				if (g_t81576F0 == 0x00)
					*((word32) ecx_931 + 4) = 0x00;
				else
					runtime.writebarrierptr((word32) ecx_931 + 4, 0x00);
			}
			*((word32) dwArg08 + 4) &= ~0x08;
		}
	}
	xmm1Out = xmm1;
	return xmm0;
}

// 08050EF0: void reflect.mapaccess(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack ptr32 dwArg0C)
// Called from:
//      reflect.Value.MapIndex
void reflect.mapaccess(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, ptr32 dwArg0C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	word32 esi_75;
	runtime.mapaccess2(gs, dwArg04, dwArg08, dwArg0C, out esi_75);
}

// 08050F50: void reflect.mapiterinit(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
// Called from:
//      reflect.Value.MapKeys
void reflect.mapiterinit(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.newobject(gs, 0x080DB6A0);
	runtime.mapiterinit(gs, dwArg04, dwArg08, dwLoc0C);
}

// 08050FB0: void reflect.mapiternext(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      reflect.Value.MapKeys
void reflect.mapiternext(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.mapiternext(gs, dwArg04);
}

// 08050FE0: void reflect.mapiterkey(Register (ptr32 Eq_2) gs)
// Called from:
//      reflect.Value.MapKeys
void reflect.mapiterkey(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
}

// 08051010: void reflect.maplen(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      reflect.Value.Len
//      reflect.Value.MapKeys
void reflect.maplen(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (dwArg04 == 0x00)
		;
}

// 08051050: Register Eq_4 runtime.mapaccess1_fast32(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C, Register out Eq_9495 esiOut, Register out Eq_4 ediOut)
// Called from:
//      runtime.resolveTypeOff
//      runtime.(*_type).textOff
//      runtime.typelinksinit
//      reflect.(*structType).FieldByNameFunc
Eq_4 runtime.mapaccess1_fast32(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C, union Eq_9495 & esiOut, union Eq_4 & ediOut)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (dwArg08 == 0x00 || *dwArg08 == 0x00)
	{
		esiOut = esi;
		ediOut = edi;
		return ebx;
	}
	else if ((*((word32) dwArg08 + 4) & 0x04) != 0x00)
		runtime.throw(gs);
	else
	{
		Eq_4 eax_108;
		if (*((word32) dwArg08 + 5) == 0x00)
			eax_108 = *((word32) dwArg08 + 0x0C);
		else
		{
			<anonymous> ** edx_50 = **((word32) *((word32) dwArg04 + 32) + 16);
			<anonymous> * ecx_55 = *edx_50;
			ecx_55();
			cu8 cl_67 = *((word32) dwArg08 + 5);
			uint32 esi_72 = 0x01 << cl_67 & 0x00 - (cl_67 < 0x20);
			int32 eax_77 = (word32) *((word32) dwArg04 + 52);
			ebx = dwArg08;
			esi = esi_72 - 0x01;
			edi = *((word32) dwArg08 + 16);
			Eq_4 ecx_105 = (word32) *((word32) dwArg08 + 0x0C) + (esi_72 - 0x01 & dwLoc04) *s eax_77;
			if (edi != 0x00)
			{
				ebx = (word32) *((word32) dwArg08 + 4);
				if (((byte) ebx & 0x08) == 0x00)
					esi = esi_72 - 0x01 >> 0x01;
				esi = (esi & dwLoc04) *s eax_77;
				word32 eax_98 = edi + esi;
				if (*eax_98 >= 0x04)
					ecx_105 = eax_98;
			}
			eax_108 = ecx_105;
		}
		do
		{
			Eq_9583 ecx_110 = 0x00;
			while (ecx_110 < 0x08)
			{
				ebx = *((word32) eax_108 + (ecx_110 * 0x04 + 8));
				if (ebx == dwArg0C)
				{
					ebx = CONVERT(Mem160[ecx_110 + eax_108:byte], byte, word32);
					if ((byte) ebx != 0x00)
					{
						esiOut = esi;
						ediOut = edi;
						return ebx;
					}
				}
				ecx_110 = (word32) ecx_110 + 1;
			}
			eax_108 = *((word32) (eax_108 - 0x04) + (word32) (*((word32) dwArg04 + 52)));
		} while (eax_108 != 0x00);
		esiOut = esi;
		ediOut = edi;
		return ebx;
	}
}

// 080511B0: void runtime.mapaccess2_fast32(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_9633) dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C)
// Called from:
//      reflect.addReflectOff
//      runtime.resolveNameOff
void runtime.mapaccess2_fast32(struct Eq_2 * gs, struct Eq_9633 * dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (dwArg08 == 0x00 || *dwArg08 == 0x00)
		return;
	if ((*((word32) dwArg08 + 4) & 0x04) != 0x00)
		runtime.throw(gs);
	else
	{
		Eq_4 eax_109;
		if (*((word32) dwArg08 + 5) == 0x00)
			eax_109 = *((word32) dwArg08 + 0x0C);
		else
		{
			<anonymous> ** edx_51 = *dwArg04->ptr0020->ptr0010;
			<anonymous> * ecx_56 = *edx_51;
			ecx_56();
			cu8 cl_68 = *((word32) dwArg08 + 5);
			uint32 esi_73 = 0x01 << cl_68 & 0x00 - (cl_68 < 0x20);
			int32 eax_78 = (word32) dwArg04->w0034;
			uint32 esi_76 = esi_73 - 0x01;
			Eq_4 edi_80 = *((word32) dwArg08 + 16);
			Eq_4 ecx_106 = (word32) *((word32) dwArg08 + 0x0C) + (esi_73 - 0x01 & dwLoc04) *s eax_78;
			if (edi_80 != 0x00)
			{
				if ((*((word32) dwArg08 + 4) & 0x08) == 0x00)
					esi_76 = esi_73 - 0x01 >> 0x01;
				Eq_4 eax_99 = (word32) edi_80 + (esi_76 & dwLoc04) *s eax_78;
				if (*eax_99 >= 0x04)
					ecx_106 = eax_99;
			}
			eax_109 = ecx_106;
		}
		do
		{
			Eq_9722 ecx_111 = 0x00;
			while (ecx_111 < 0x08)
			{
				if (*((word32) eax_109 + (ecx_111 * 0x04 + 8)) == dwArg0C && Mem163[ecx_111 + eax_109:byte] != 0x00)
					return;
				ecx_111 = (word32) ecx_111 + 1;
			}
			eax_109 = *((word32) (eax_109 - 0x04) + (word32) dwArg04->w0034);
		} while (eax_109 != 0x00);
	}
}

// 08051320: Register Eq_4 runtime.mapaccess2_fast64(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_9769) dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C, Stack Eq_4 dwArg10, Register out Eq_4 ediOut)
// Called from:
//      runtime.typesEqual
Eq_4 runtime.mapaccess2_fast64(struct Eq_2 * gs, struct Eq_9769 * dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C, Eq_4 dwArg10, union Eq_4 & ediOut)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (dwArg08 == 0x00 || *dwArg08 == 0x00)
	{
		ediOut = edi;
		return esi;
	}
	else if ((*((word32) dwArg08 + 4) & 0x04) != 0x00)
		runtime.throw(gs);
	else
	{
		Eq_4 eax_112;
		if (*((word32) dwArg08 + 5) == 0x00)
			eax_112 = *((word32) dwArg08 + 0x0C);
		else
		{
			<anonymous> ** edx_53 = *dwArg04->ptr0020->ptr0010;
			<anonymous> * ecx_58 = *edx_53;
			ecx_58();
			cu8 cl_71 = *((word32) dwArg08 + 5);
			uint32 esi_76 = 0x01 << cl_71 & 0x00 - (cl_71 < 0x20);
			int32 eax_81 = (word32) dwArg04->w0034;
			esi = esi_76 - 0x01;
			edi = *((word32) dwArg08 + 16);
			Eq_4 ecx_109 = (word32) *((word32) dwArg08 + 0x0C) + (esi_76 - 0x01 & dwLoc04) *s eax_81;
			if (edi != 0x00)
			{
				if ((*((word32) dwArg08 + 4) & 0x08) == 0x00)
					esi = esi_76 - 0x01 >> 0x01;
				esi = (esi & dwLoc04) *s eax_81;
				word32 eax_102 = edi + esi;
				if (*eax_102 >= 0x04)
					ecx_109 = eax_102;
			}
			eax_112 = ecx_109;
		}
		do
		{
			Eq_9859 ecx_114 = 0x00;
			while (ecx_114 < 0x08)
			{
				word32 ebx_138 = eax_112 + 0x08 + ecx_114 * 0x08;
				Eq_4 ebx_140 = ebx_138->t0000;
				Eq_4 ebp_139 = ebx_138->t0004;
				esi = dwArg0C;
				edi = dwArg10;
				if (((int8) (ebp_139 != dwArg10) | (int8) (ebx_140 != dwArg0C)) == 0x00 && Mem193[ecx_114 + eax_112:byte] != 0x00)
				{
					ediOut = dwArg10;
					return dwArg0C;
				}
				ecx_114 = (word32) ecx_114 + 1;
			}
			eax_112 = *((word32) (eax_112 - (struct Eq_9882 *) 0x04) + (word32) dwArg04->w0034);
		} while (eax_112 != 0x00);
		ediOut = edi;
		return esi;
	}
}

// 080514B0: Register int32 runtime.mapassign_fast32(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C)
// Called from:
//      reflect.addReflectOff
//      runtime.typelinksinit
//      reflect.(*structType).FieldByNameFunc
int32 runtime.mapassign_fast32(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C)
{
	Eq_4 dwLoc58 = (word32) rLoc58;
	word32 dwLoc54 = SLICE(rLoc58, word32, 32);
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (dwArg08 == 0x00)
		runtime.gopanic(gs);
	else if ((*((word32) dwArg08 + 4) & 0x04) != 0x00)
		runtime.throw(gs);
	else
	{
		<anonymous> ** edx_54 = **((word32) *((word32) dwArg04 + 32) + 16);
		(*edx_54)();
		*((word32) dwArg08 + 4) |= 0x04;
		real64 rLoc58_724 = rLoc58;
		if (*((word32) dwArg08 + 0x0C) == 0x00)
		{
			word32 edi_900;
			runtime.newarray(gs, *((word32) dwArg04 + 40), 0x01, out edi_900);
			if (g_t81576F0 == 0x00)
				*((word32) dwArg08 + 0x0C) = dwLoc58;
			else
				runtime.writebarrierptr((word32) dwArg08 + 0x0C, dwLoc58);
		}
		while (true)
		{
			cu8 cl_122 = *((word32) dwArg08 + 5);
			word32 dwLoc54_734 = SLICE(rLoc58_724, word32, 32);
			int32 edx_130 = (0x01 << cl_122 & 0x00 - (cl_122 < 0x20)) - 0x01 & dwLoc58;
			if (*((word32) dwArg08 + 16) != 0x00)
			{
				word128 xmm1_901;
				runtime.growWork(gs, dwArg04, dwArg08, edx_130, out xmm1_901);
				rLoc58_724 = SEQ(dwLoc54_734, edx_130);
			}
			int32 edi_171 = (word32) *((word32) dwArg04 + 52);
			Eq_4 ebx_169 = dwArg08;
			Eq_4 ebp_168 = dwArg04;
			Eq_4 edx_174 = (word32) *((word32) dwArg08 + 0x0C) + edx_130 *s edi_171;
			Eq_4 al_178 = (byte) (dwLoc58 >> 0x18);
			if (al_178 < 0x04)
				al_178 = (byte) (dwLoc58 >> 0x18) + 0x04;
			Eq_7125 ecx_188 = 0x00;
			Eq_4 dwLoc14_645 = 0x00;
			Eq_4 edx_200 = edx_174;
			Eq_4 al_202 = al_178;
			edi_217 = edi_171;
			while (true)
			{
				int32 edi_217;
				word32 eax_209 = (word32) al_202;
				Eq_10059 dwLoc4C_649 = 0x00;
				Eq_4 al_597 = (byte) eax_209;
				while (true)
				{
					int32 esi_439;
					Eq_7125 dwLoc54_674 = SLICE(rLoc58_724, word32, 32);
					word24 ebx_24_8_267 = SLICE(ebx_169, word24, 8);
					al_202 = al_597;
					if (dwLoc4C_649 >= 0x08)
						break;
					Eq_4 ebx_548;
					word32 edi_498 = CONVERT(Mem211[edx_200 + dwLoc4C_649:byte], byte, word32);
					word32 ebx_499 = edx_200 + dwLoc4C_649;
					if (al_597 != (byte) edi_498)
					{
						if ((byte) edi_498 == 0x00)
						{
							if (ecx_188 != 0x00)
								ebx_548 = dwLoc14_645;
							else
							{
								ecx_188 = ebx_499;
								ebx_548 = edx_200 + 0x08 + dwLoc4C_649 * 0x04;
								ebp_168 = dwArg04;
							}
						}
						else
							ebx_548 = dwLoc14_645;
					}
					else
					{
						if (*((word32) edx_200 + (dwLoc4C_649 * 0x04 + 8)) == dwArg0C)
						{
							esi_439 = dwLoc4C_649 *s (word32) (*((word32) ebp_168 + 50));
							goto l080515CB;
						}
						ebx_548 = dwLoc14_645;
					}
					++dwLoc4C_649;
					dwLoc14_645 = ebx_548;
					ebx_169 = dwArg08;
					edi_217 = edi_171;
				}
				Eq_4 esi_219 = (edx_200 - 0x04)[edi_217 / 4];
				if (esi_219 == 0x00)
					break;
				edx_200 = esi_219;
			}
			if (*((word32) ebx_169 + 16) != 0x00)
				break;
			int8 al_337;
			Eq_7248 ebp_233 = *ebx_169;
			Eq_7248 esi_234 = ebp_233;
			Eq_7125 ebp_235 = ebp_233 >> 0x1F;
			word32 edi_236 = (word32) *((word32) ebx_169 + 5);
			if (((int8) (ebp_233 >> 0x1F > 0x00) | (int8) (ebp_233 >> 0x1F == 0x00) & (int8) (ebp_233 >= 0x08)) == 0x00)
				al_337 = 0x00;
			else
			{
				runtime.int64tofloat64(ebx_24_8_267, gs, SEQ(ebp_233 >> 0x1F, ebp_233));
				word32 ecx_282 = (word32) (byte) edi_236;
				cu8 cl_295 = (byte) -(ecx_282 + ~0x1F);
				runtime.uint64tofloat64(gs, 0x01 >> cl_295 & 0x00 - (cl_295 < 0x20) | 0x01 << (byte) ecx_282 + 0xE0 & 0x00 - ((byte) ecx_282 < 0xC0));
				al_337 = (int8) ((real32) (real64) (uint128) (real64) (uint128) rLoc58_724 >= (real32) ((uint128) $f32.40d00000) * (real32) ((real64) ((uint128) rLoc58_724)));
				ebx_169 = dwArg08;
			}
			if (al_337 == 0x00)
			{
				int8 al_358;
				word32 edx_351 = (word32) *((word32) ebx_169 + 5);
				cup16 ax_355 = *((word32) ebx_169 + 6);
				if ((byte) edx_351 < 0x10)
				{
					cu8 cl_364 = (byte) edx_351;
					esi_234 = 0x01 << cl_364 & 0x00 - (cl_364 < 0x20);
					al_358 = (int8) (ax_355 >= (word16) esi_234);
				}
				else
					al_358 = (int8) (ax_355 >= 0x8000);
				ebp_235 = ecx_188;
				if (al_358 == 0x00)
					break;
			}
			word128 xmm1_902;
			runtime.hashGrow(ebp_235, esi_234, gs, dwArg04, ebx_169, out xmm1_902);
		}
		Eq_4 eax_415;
		Eq_7125 ebp_378 = ecx_188;
		if (ecx_188 != 0x00)
			eax_415 = dwLoc14_645;
		else
		{
			runtime.(*hmap).newoverflow(gs, ebx_169, dwArg04, edx_200);
			ebp_378 = dwLoc54_674;
			eax_415 = (word32) dwLoc54_674 + 8;
		}
		word32 edi_903;
		word128 xmm1_905;
		word128 xmm0_904;
		runtime.typedmemmove(*((word32) dwArg04 + 32), eax_415, (word32) fp + 0x0C, out esi_439, out edi_903, out xmm0_904, out xmm1_905);
		*ebp_378 = al_597;
		*dwArg08 = (word32) *dwArg08 + 1;
l080515CB:
		word32 edx_525 = (word32) *((word32) dwArg08 + 4);
		if (((byte) edx_525 & 0x04) == 0x00)
			runtime.throw(gs);
		else
		{
			*((word32) dwArg08 + 4) = (byte) edx_525 & ~0x04;
			return esi_439;
		}
	}
}

// 08051910: Register int32 runtime.mapassign_fast64(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C, Stack Eq_4 dwArg10, Register out Eq_4 ediOut)
// Called from:
//      runtime.typesEqual
int32 runtime.mapassign_fast64(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C, Eq_4 dwArg10, union Eq_4 & ediOut)
{
	Eq_4 dwLoc58 = (word32) rLoc58;
	word32 dwLoc54 = SLICE(rLoc58, word32, 32);
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (dwArg08 == 0x00)
		runtime.gopanic(gs);
	else if ((*((word32) dwArg08 + 4) & 0x04) != 0x00)
		runtime.throw(gs);
	else
	{
		<anonymous> ** edx_54 = **((word32) *((word32) dwArg04 + 32) + 16);
		(*edx_54)();
		*((word32) dwArg08 + 4) |= 0x04;
		real64 rLoc58_751 = rLoc58;
		if (*((word32) dwArg08 + 0x0C) == 0x00)
		{
			word32 edi_947;
			runtime.newarray(gs, *((word32) dwArg04 + 40), 0x01, out edi_947);
			if (g_t81576F0 == 0x00)
				*((word32) dwArg08 + 0x0C) = dwLoc58;
			else
				runtime.writebarrierptr((word32) dwArg08 + 0x0C, dwLoc58);
		}
		while (true)
		{
			cu8 cl_122 = *((word32) dwArg08 + 5);
			word32 dwLoc54_761 = SLICE(rLoc58_751, word32, 32);
			int32 edx_130 = (0x01 << cl_122 & 0x00 - (cl_122 < 0x20)) - 0x01 & dwLoc58;
			if (*((word32) dwArg08 + 16) != 0x00)
			{
				word128 xmm1_948;
				runtime.growWork(gs, dwArg04, dwArg08, edx_130, out xmm1_948);
				rLoc58_751 = SEQ(dwLoc54_761, edx_130);
			}
			int32 edi_171 = (word32) *((word32) dwArg04 + 52);
			Eq_4 ebx_169 = dwArg08;
			Eq_4 edx_174 = (word32) *((word32) dwArg08 + 0x0C) + edx_130 *s edi_171;
			Eq_4 al_178 = (byte) (dwLoc58 >> 0x18);
			if (al_178 < 0x04)
				al_178 = (byte) (dwLoc58 >> 0x18) + 0x04;
			Eq_7125 ecx_191 = 0x00;
			Eq_4 dwLoc14_671 = 0x00;
			Eq_4 edx_201 = edx_174;
			Eq_4 al_203 = al_178;
			edi_218 = edi_171;
			while (true)
			{
				int32 edi_218;
				struct Eq_10418 * dwLoc4C_675 = null;
				word32 eax_210 = (word32) al_203;
				while (true)
				{
					Eq_4 edi_435;
					int32 esi_437;
					Eq_7125 dwLoc54_699 = SLICE(rLoc58_751, word32, 32);
					al_203 = (byte) eax_210;
					word24 ebx_24_8_266 = SLICE(ebx_169, word24, 8);
					if (dwLoc4C_675 >= (struct Eq_10418 *) 0x08)
						break;
					word32 eax_568;
					Eq_4 ebx_570;
					word32 edi_497 = CONVERT(Mem212[edx_201 + dwLoc4C_675:byte], byte, word32);
					word32 ebx_498 = edx_201 + dwLoc4C_675;
					if (al_203 != (byte) edi_497)
					{
						if ((byte) edi_497 == 0x00)
						{
							if (ecx_191 != 0x00)
							{
								ebx_570 = dwLoc14_671;
								eax_568 = eax_210;
							}
							else
							{
								ecx_191 = ebx_498;
								ebx_570 = edx_201 + 0x08 + dwLoc4C_675 * 0x08;
								eax_568 = eax_210;
							}
						}
						else
						{
							ebx_570 = dwLoc14_671;
							eax_568 = eax_210;
						}
					}
					else
					{
						word32 edi_510 = edx_201 + 0x08 + dwLoc4C_675 * 0x08;
						edi_435 = edi_510->t0000;
						if (((int8) (edi_510->t0004 != dwArg10) | (int8) (edi_435 != dwArg0C)) == 0x00)
						{
							esi_437 = dwLoc4C_675 *s (word32) (*((word32) dwArg04 + 50));
							goto l08051A4F;
						}
						eax_568 = (word32) al_178;
						ebx_570 = dwLoc14_671;
					}
					++dwLoc4C_675;
					dwLoc14_671 = ebx_570;
					ebx_169 = dwArg08;
					edi_218 = edi_171;
					eax_210 = eax_568;
				}
				Eq_4 esi_220 = (edx_201 - 0x04)[edi_218 / 4];
				if (esi_220 == 0x00)
					break;
				edx_201 = esi_220;
			}
			if (*((word32) ebx_169 + 16) != 0x00)
				break;
			int8 al_335;
			Eq_7248 ebp_232 = *ebx_169;
			Eq_7248 esi_233 = ebp_232;
			Eq_7125 ebp_234 = ebp_232 >> 0x1F;
			word32 edi_235 = (word32) *((word32) ebx_169 + 5);
			if (((int8) (ebp_232 >> 0x1F == 0x00) & (int8) (ebp_232 >= 0x08) | (int8) (ebp_232 >> 0x1F > 0x00)) == 0x00)
				al_335 = 0x00;
			else
			{
				runtime.int64tofloat64(ebx_24_8_266, gs, SEQ(ebp_232 >> 0x1F, ebp_232));
				word32 ecx_281 = (word32) (byte) edi_235;
				cu8 cl_297 = (byte) -(ecx_281 + ~0x1F);
				runtime.uint64tofloat64(gs, 0x01 >> cl_297 & 0x00 - (cl_297 < 0x20) | 0x01 << (byte) ecx_281 + 0xE0 & 0x00 - ((byte) ecx_281 < 0xC0));
				al_335 = (int8) ((real32) (real64) (uint128) (real64) (uint128) rLoc58_751 >= (real32) ((uint128) $f32.40d00000) * (real32) ((real64) ((uint128) rLoc58_751)));
				ebx_169 = dwArg08;
			}
			if (al_335 == 0x00)
			{
				int8 al_356;
				word32 edx_349 = (word32) *((word32) ebx_169 + 5);
				cup16 ax_353 = *((word32) ebx_169 + 6);
				if ((byte) edx_349 < 0x10)
				{
					cu8 cl_362 = (byte) edx_349;
					esi_233 = 0x01 << cl_362 & 0x00 - (cl_362 < 0x20);
					al_356 = (int8) (ax_353 >= (word16) esi_233);
				}
				else
					al_356 = (int8) (ax_353 >= 0x8000);
				ebp_234 = ecx_191;
				if (al_356 == 0x00)
					break;
			}
			word128 xmm1_949;
			runtime.hashGrow(ebp_234, esi_233, gs, dwArg04, ebx_169, out xmm1_949);
		}
		Eq_4 eax_413;
		Eq_7125 ebp_376 = ecx_191;
		if (ecx_191 != 0x00)
			eax_413 = dwLoc14_671;
		else
		{
			runtime.(*hmap).newoverflow(gs, ebx_169, dwArg04, edx_201);
			ebp_376 = dwLoc54_699;
			eax_413 = (word32) dwLoc54_699 + 8;
		}
		word128 xmm1_951;
		word128 xmm0_950;
		runtime.typedmemmove(*((word32) dwArg04 + 32), eax_413, (word32) fp + 0x0C, out esi_437, out edi_435, out xmm0_950, out xmm1_951);
		*ebp_376 = al_178;
		*dwArg08 = (word32) *dwArg08 + 1;
l08051A4F:
		word32 edx_545 = (word32) *((word32) dwArg08 + 4);
		if (((byte) edx_545 & 0x04) == 0x00)
			runtime.throw(gs);
		else
		{
			*((word32) dwArg08 + 4) = (byte) edx_545 & ~0x04;
			ediOut = edi_435;
			return esi_437;
		}
	}
}

// 08051D90: Register Eq_4 runtime.mapassign_faststr(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_10656) dwArg04, Stack Eq_4 dwArg08, Register out Eq_7248 esiOut, Register out Eq_10659 ediOut)
// Called from:
//      time.init
//      unicode.init
Eq_4 runtime.mapassign_faststr(struct Eq_2 * gs, struct Eq_10656 * dwArg04, Eq_4 dwArg08, union Eq_7248 & esiOut, union Eq_10659 & ediOut)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	struct Eq_10672 * esp_135 = fp - 0x54;
	if (dwArg08 == 0x00)
		runtime.gopanic(gs);
	else if ((*((word32) dwArg08 + 4) & 0x04) != 0x00)
		runtime.throw(gs);
	else
	{
		<anonymous> ** edx_54 = *dwArg04->ptr0020->ptr0010;
		<anonymous> * ecx_59 = *edx_54;
		ecx_59();
		*((word32) dwArg08 + 4) |= 0x04;
		Eq_4 eax_114 = dwLoc4C;
		Eq_4 ecx_115 = dwArg08;
		if (*((word32) dwArg08 + 0x0C) == 0x00)
		{
			word32 edi_860;
			runtime.newarray(gs, dwArg04->t0028, 0x01, out edi_860);
			if (g_t81576F0 == 0x00)
				*((word32) dwArg08 + 0x0C) = dwLoc4C;
			else
				runtime.writebarrierptr((word32) dwArg08 + 0x0C, dwLoc4C);
			eax_114 = dwLoc4C;
			ecx_115 = dwArg08;
		}
		while (true)
		{
			cu8 cl_122 = *((word32) ecx_115 + 5);
			Eq_4 ebx_119 = ecx_115;
			int32 edx_130 = (0x01 << cl_122 & 0x00 - (cl_122 < 0x20)) - 0x01 & eax_114;
			if (*((word32) ecx_115 + 16) != 0x00)
			{
				esp_135[7] = (struct Eq_10672) edx_130;
				esp_135->dw0000 = (word32) esp_135[22];
				esp_135[1] = (struct Eq_10672) ecx_115;
				esp_135[2] = (struct Eq_10672) edx_130;
				word128 xmm1_861;
				runtime.growWork(gs, esp_135->dw0000, esp_135[1], esp_135[2], out xmm1_861);
				eax_114 = esp_135[6];
				edx_130 = (int32) esp_135[7];
				ebx_119 = esp_135[23];
			}
			uint32 eax_177 = eax_114 >> 0x18;
			Eq_4 edx_174 = (word32) *((word32) ebx_119 + 0x0C) + edx_130 *s (word32) (*((word64) (esp_135)[22].r0030 + 4));
			Eq_4 al_178 = (byte) eax_177;
			if (al_178 < 0x04)
				al_178 = (byte) eax_177 + 0x04;
			esp_135->b0012 = (byte) al_178;
			Eq_7125 ecx_187 = 0x00;
			Eq_7248 esi_188 = 0x00;
			Eq_10659 edi_189 = 0x00;
			do
			{
				esp_135[0x0011] = (struct Eq_10672) edx_174;
				esp_135[0x0A] = (struct Eq_10672) al_178;
				esp_135[5] = (struct Eq_10672) 0x00;
				al_178 = esp_135[0x0A];
				while (true)
				{
					Eq_4 ebx_415;
					esp_135[0x0E] = (struct Eq_10672) edi_189;
					esp_135[0x0F] = (struct Eq_10672) esi_188;
					esp_135[16] = (struct Eq_10672) ecx_187;
					struct Eq_10850 * ebp_209 = esp_135[5];
					if (ebp_209 >= (struct Eq_10850 *) 0x08)
						break;
					Eq_7248 ebx_567;
					byte bl_492 = Mem208[edx_174 + ebp_209:byte];
					word32 esi_491 = edx_174 + ebp_209;
					if (al_178 != bl_492)
					{
						if (bl_492 == 0x00)
						{
							if (ecx_187 != 0x00)
								ebx_567 = esp_135[0x0F];
							else
							{
								struct Eq_10899 * esi_578 = esp_135[22];
								int32 esi_580 = (word32) esi_578->b0030;
								esp_135[9] = (struct Eq_10672) (esi_580 *s ebp_209);
								int32 esi_587 = (word32) esi_578->b0032 *s ebp_209 + esi_580 * 0x08;
								esp_135[8] = (struct Eq_10672) edx_174;
								ecx_187 = esi_491;
								ebx_567 = Mem590[esp_135 + 0x24:word32] + 0x08 + edx_174;
								edi_189 = (word32) esp_135[8].dw0000 + (esi_587 + 0x08);
							}
						}
						else
							ebx_567 = esp_135[0x0F];
						goto l08051E09;
					}
					word32 ebx_496 = edx_174 + 0x08 + ebp_209 * 0x08;
					esp_135[20] = (struct Eq_10672) ebx_496;
					ebx_415 = esp_135[25];
					if (ebx_496->t0004 != ebx_415)
					{
						ebx_567 = esp_135[0x0F];
						goto l08051E09;
					}
					esi_188 = *esp_135[20].dw0000;
					Eq_7248 eax_504 = esp_135[24];
					if (esi_188 == eax_504)
					{
l08051EFA:
						goto l08051F11;
					}
					esp_135[2] = (struct Eq_10672) ebx_415;
					esp_135->dw0000 = (word32) esi_188;
					esp_135[1] = (struct Eq_10672) eax_504;
					runtime.memequal(edx_174, esp_135->dw0000, esp_135[1], esp_135[2], out ebx_415, out esi_188, out edi_189);
					++esp_135;
					if (esp_135[3] != 0x00)
						goto l08051EFA;
					al_178 = esp_135->b0012;
					edx_174 = esp_135[0x0011];
					ebp_209 = (struct Eq_10850 *) esp_135[5];
					ecx_187 = esp_135[16];
					ebx_567 = esp_135[0x0F];
					edi_189 = esp_135[0x0E];
l08051E09:
					Mem603[esp_135 + 0x14:word32] = ebp_209 + 0x01;
					esi_188 = ebx_567;
				}
				edx_174 = *((word32) (edx_174 - (struct Eq_10856 *) 0x04) + (word32) (*((word64) (esp_135)[22].r0030 + 4)));
			} while (edx_174 != 0x00);
			Eq_7125 ebp_227;
			struct Eq_10945 * edx_222 = esp_135[23];
			if (edx_222->dw0010 != 0x00)
				break;
			int8 al_328;
			Eq_7125 ebx_228 = edx_222->t0000;
			word32 eax_231 = (word32) edx_222->b0005;
			esp_135->b0013 = (byte) eax_231;
			ui24 eax_24_8_248 = SLICE(eax_231, word24, 8);
			esi_188 = SEQ(SLICE(esi_188, word24, 8), (int8) (ebx_228 >> 0x1F == 0x00)) & SEQ(eax_24_8_248, (int8) (ebx_228 >= 0x08));
			ebp_227 = ebx_228;
			word24 ebx_24_8_261 = SLICE(ebx_228 >> 0x1F, word24, 8);
			if (((int8) (ebx_228 >> 0x1F > 0x00) | (byte) esi_188) == 0x00)
				al_328 = 0x00;
			else
			{
				esp_135->dw0000 = (word32) ebx_228;
				esp_135[1] = (struct Eq_10672) (ebx_228 >> 0x1F);
				runtime.int64tofloat64(ebx_24_8_261, gs, esp_135->dw0000);
				esp_135[0x0C] = (struct Eq_10672) (real64) (uint128) esp_135[2];
				word32 ecx_276 = (word32) esp_135->b0013;
				cu8 cl_278 = (byte) ecx_276;
				esp_135->dw0000 = 0x01 << cl_278 & 0x00 - (cl_278 < 0x20);
				cu8 cl_287 = (byte) ecx_276 + 0xE0;
				cu8 cl_295 = (byte) -(ecx_276 + ~0x1F);
				esp_135[1] = (struct Eq_10672) (0x01 >> cl_295 & 0x00 - (cl_295 < 0x20) | 0x01 << cl_287 & 0x00 - (cl_287 < 0x20));
				runtime.uint64tofloat64(gs, esp_135[1]);
				al_328 = (int8) ((real32) (real64) (uint128) esp_135[0x0C] >= (real32) ((uint128) $f32.40d00000) * (real32) ((real64) ((uint128) esp_135[2])));
				ecx_187 = esp_135[16];
				edx_222 = (struct Eq_10945 *) esp_135[23];
				edi_189 = esp_135[0x0E];
			}
			if (al_328 == 0x00)
			{
				int8 al_350;
				word32 ebx_343 = (word32) edx_222->b0005;
				cup16 ax_347 = edx_222->w0006;
				if ((byte) ebx_343 < 0x10)
				{
					cu8 cl_356 = (byte) ebx_343;
					esi_188 = 0x01 << cl_356 & 0x00 - (cl_356 < 0x20);
					al_350 = (int8) (ax_347 >= (word16) esi_188);
				}
				else
					al_350 = (int8) (ax_347 >= 0x8000);
				ebp_227 = ecx_187;
				if (al_350 == 0x00)
					goto l08052044;
			}
			esp_135->dw0000 = (word32) esp_135[22];
			esp_135[1] = (struct Eq_10672) edx_222;
			word128 xmm1_862;
			runtime.hashGrow(ebp_227, esi_188, gs, esp_135->dw0000, esp_135[1], out xmm1_862);
			eax_114 = esp_135[6];
			ecx_115 = esp_135[23];
		}
		ebp_227 = ecx_187;
l08052044:
		Eq_11199 eax_408;
		if (ebp_227 != 0x00)
			eax_408 = esp_135[0x0F];
		else
		{
			esp_135->dw0000 = edx_222;
			esp_135[1] = esp_135[22];
			esp_135[2] = esp_135[0x0011];
			esi_188 = runtime.(*hmap).newoverflow(gs, esp_135->dw0000, esp_135[1], esp_135[2]);
			ebp_227 = esp_135[3];
			edi_189 = (word32) ebp_227 + 72;
			edx_222 = (struct Eq_10945 *) esp_135[23];
			eax_408 = (word32) ebp_227 + 8;
		}
		ebx_415 = esp_135[24];
		*((word32) eax_408 + 4) = esp_135[25];
		if (g_t81576F0 == 0x00)
			*eax_408 = ebx_415;
		else
		{
			esp_135[16] = (struct Eq_10672) ebp_227;
			esp_135[19] = (struct Eq_10672) edi_189;
			esp_135->dw0000 = (word32) eax_408;
			esp_135[1] = (struct Eq_10672) ebx_415;
			runtime.writebarrierptr(esp_135->dw0000, esp_135[1]);
			edx_222 = (struct Eq_10945 *) esp_135[23];
			ebp_227 = esp_135[16];
			edi_189 = esp_135[19];
		}
		ebp_227->u0 = esp_135->b0012;
		edx_222->t0000 = (word32) edx_222->t0000 + 1;
l08051F11:
		word32 edx_538 = (word32) *((word32) dwArg08 + 4);
		if (((byte) edx_538 & 0x04) == 0x00)
			runtime.throw(gs);
		else
		{
			*((word32) dwArg08 + 4) = (byte) edx_538 & ~0x04;
			esiOut = esi_188;
			ediOut = edi_189;
			return ebx_415;
		}
	}
}

// 08052240: void runtime.getitab(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack byte bArg0C)
// Called from:
//      runtime.assertE2I
//      runtime.assertE2I2
void runtime.getitab(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, byte bArg0C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 edx_18 = *((word32) dwArg04 + 36);
	if (*((word32) dwArg04 + 40) == 0x00)
		runtime.throw(gs);
	else if ((*((word32) dwArg08 + 0x0C) & 0x01) == 0x00)
	{
		if (bArg0C != 0x00)
			return;
		Eq_4 eax_49 = *edx_18;
		runtime.(*_type).nameOff(gs);
		runtime.(*_type).string(gs, dwArg08);
		runtime.(*_type).string(gs, dwArg04);
		runtime.name.name(gs, dwLoc40);
		runtime.newobject(gs, 0x080D6BA0);
		*((word32) eax_49 + 0x0C) = dwLoc40;
		if (g_t81576F0 == 0x00)
			*((word32) eax_49 + 8) = eax_49;
		else
			runtime.writebarrierptr((word32) eax_49 + 8, eax_49);
		*((word32) eax_49 + 20) = dwLoc40;
		if (g_t81576F0 == 0x00)
			*((word32) eax_49 + 16) = eax_49;
		else
			runtime.writebarrierptr((word32) eax_49 + 16, eax_49);
		*((word32) eax_49 + 28) = dwLoc40;
		if (g_t81576F0 == 0x00)
			*((word32) eax_49 + 24) = eax_49;
		else
			runtime.writebarrierptr((word32) eax_49 + 24, eax_49);
		runtime.gopanic(gs);
	}
	else
	{
		Eq_4 ebp_168 = *((word32) dwArg08 + 8);
		uint32 edx_172 = (word32) *((word32) dwArg04 + 8) + ebp_168 * 0x11;
		word32 edx_177 = SLICE(edx_172 *64 63849861, word32, 32) + edx_172;
		Eq_4 esi_169 = ebp_168;
		uint32 ebp_184 = edx_172 - (__rcr(edx_177, 0x01, SLICE(cond(edx_177), bool, 1)) >> 0x09) *s 1009;
		Eq_4 eax_186 = 0x00;
		while (eax_186 < 0x02)
		{
			int8 dl_273 = (int8) (eax_186 != 0x00);
			if (eax_186 != 0x00)
			{
				word32 edi_604;
				word32 esi_603;
				runtime.lock(esi_169, gs, 0x081575F4, out esi_603, out edi_604);
			}
			if (ebp_184 >= 1009)
				runtime.panicindex(gs);
			runtime/internal/atomic.Loadp();
			Eq_4 eax_301 = dwLoc44;
			while (eax_301 != 0x00)
			{
				if (*eax_301 == dwArg04 && *((word32) eax_301 + 4) == dwArg08)
				{
					bool v24_384;
					if (*((word32) eax_301 + 16) != 0x00)
					{
						if (bArg0C != 0x00)
							v24_384 = eax_186 != 0x00;
						else
						{
							runtime.additab(gs, eax_301, dl_273, 0x00);
							v24_384 = eax_186 != 0x00;
						}
					}
					else
						v24_384 = eax_186 != 0x00;
					if (v24_384)
					{
						word32 edx_605;
						word32 ebx_606;
						runtime.unlock(gs, 0x081575F4, out edx_605, out ebx_606);
					}
					return;
				}
				eax_301 = *((word32) eax_301 + 8);
			}
			esi_169 = eax_186;
			eax_186 = (word32) eax_186 + 1;
		}
		runtime.persistentalloc(gs);
		if (g_t81576F0 == 0x00)
		{
			*dwLoc3C = dwArg04;
			*((word32) dwLoc3C + 4) = dwArg08;
		}
		else
		{
			runtime.writebarrierptr(dwLoc3C, dwArg04);
			runtime.writebarrierptr((word32) dwLoc3C + 4, dwArg08);
		}
		runtime.additab(gs, dwLoc3C, 0x01, bArg0C);
		word32 ebx_608;
		word32 edx_607;
		runtime.unlock(gs, 0x081575F4, out edx_607, out ebx_608);
		if (*((word32) dwLoc3C + 16) == 0x00)
			;
	}
}

// 080525C0: void runtime.additab(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack int8 bArg08, Stack byte bArg09)
// Called from:
//      runtime.getitab
//      runtime.itabsinit
void runtime.additab(struct Eq_2 * gs, Eq_4 dwArg04, int8 bArg08, byte bArg09)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 ecx_19 = *dwArg04;
	Eq_4 edx_21 = *((word32) dwArg04 + 4);
	runtime.(*_type).uncommon(gs, edx_21);
	struct Eq_11601 * ecx_31 = dwLoc64 + dwLoc64->dw0008 / 0x0C;
	Eq_4 ebx_35 = *((word32) ecx_19 + 40);
	Eq_11611 ebp_36 = (word32) dwLoc64->w0004;
	if (ebp_36 > 0x00010000)
		runtime.panicslice(gs);
	else
	{
		Eq_4 esi_47 = 0x00;
		Eq_11611 edi_496 = 0x00;
l080527AC:
		if (esi_47 < ebx_35)
		{
			Eq_4 ebx_59 = *((word32) ecx_19 + 36);
			if (esi_47 >= *((word32) ecx_19 + 40))
				runtime.panicindex(gs);
			runtime.(*_type).typeOff(gs);
			Eq_4 edx_85 = *((word32) ebx_59 + esi_47 * 0x08);
			runtime.(*_type).nameOff(gs);
			runtime.name.name(gs, dwLoc60);
			word32 edi_805;
			runtime.name.pkgPath(gs, dwLoc60, out edi_805);
			Eq_4 dwLoc64_536 = edx_85;
			if (dwLoc60 == 0x00)
				runtime.name.name(gs, *((word32) ecx_19 + 32));
			Eq_11611 edx_129 = edi_496;
			dwLoc60_562 = dwLoc60;
			while (true)
			{
				Eq_4 dwLoc60_562;
				if (edx_129 >= ebp_36)
					break;
				if (edx_129 >= ebp_36)
					runtime.panicindex(gs);
				runtime.(*_type).nameOff(gs);
				Eq_4 ebx_349 = ecx_31->a0004[edx_129].t0000;
				runtime.(*_type).typeOff(gs);
				dwLoc64_536 = ebx_349;
				if (dwLoc60_562 == dwLoc60)
				{
					runtime.name.name(gs, dwLoc60_562);
					if (dwLoc60_562 != dwLoc60)
						goto l0805262F;
					word32 esi_807;
					word32 ebx_806;
					word32 edi_808;
					runtime.eqstring(dwLoc60, ebx_349, dwLoc60_562, edx_85, out ebx_806, out esi_807, out edi_808);
					dwLoc64_536 = dwLoc60_562;
					dwLoc60_562 = edx_85;
					if (bLoc58 == 0x00)
						goto l0805262F;
					word32 edi_809;
					runtime.name.pkgPath(gs, dwLoc60_562, out edi_809);
					Eq_4 eax_398 = dwLoc60_562;
					if (edx_85 == 0x00)
					{
						Eq_4 ecx_404 = dwLoc64->t0000;
						runtime.(*_type).nameOff(gs);
						runtime.name.name(gs, edx_85);
						dwLoc64_536 = ecx_404;
						eax_398 = ecx_404;
					}
					if ((*dwLoc60_562 & 0x01) == 0x00)
					{
						if (dwLoc60 != edx_85)
						{
l08052721:
							dwLoc60_562 = edx_85;
							goto l0805262F;
						}
						word32 ebx_810;
						word32 edi_812;
						word32 esi_811;
						runtime.eqstring(dwLoc60, eax_398, edx_85, edx_85, out ebx_810, out esi_811, out edi_812);
						dwLoc64_536 = edx_85;
						if (bLoc58 == 0x00)
							goto l08052721;
					}
					runtime.(*_type).textOff(gs, edx_21, ecx_31->a0004[edx_129].t0004);
					dwLoc60 = edx_85;
					Eq_4 ecx_470 = (word32) dwArg04 + 20 + esi_47 * 0x04;
					if (g_t81576F0 == 0x00)
						*ecx_470 = edx_85;
					else
						runtime.writebarrierptr(ecx_470, edx_85);
					esi_47 = (word32) esi_47 + 1;
					edi_496 = edx_129;
					goto l080527AC;
				}
l0805262F:
				edx_129 = (word32) edx_129 + 1;
			}
			if (bArg09 == 0x00)
			{
				if (bArg08 != 0x00)
				{
					word32 edx_813;
					word32 ebx_814;
					runtime.unlock(gs, 0x081575F4, out edx_813, out ebx_814);
				}
				runtime.(*_type).string(gs, edx_21);
				runtime.(*_type).string(gs, ecx_19);
				runtime.newobject(gs, 0x080D6BA0);
				*((word32) dwLoc64_536 + 0x0C) = dwLoc60_562;
				if (g_t81576F0 == 0x00)
					*((word32) dwLoc64_536 + 8) = dwLoc64_536;
				else
					runtime.writebarrierptr((word32) dwLoc64_536 + 8, dwLoc64_536);
				*((word32) dwLoc64_536 + 20) = dwLoc60_562;
				Eq_4 edx_207 = (word32) dwLoc64_536 + 16;
				if (g_t81576F0 == 0x00)
					*((word32) dwLoc64_536 + 16) = dwLoc64_536;
				else
					runtime.writebarrierptr(edx_207, dwLoc64_536);
				*((word32) dwLoc64_536 + 28) = dwLoc60;
				Eq_4 edx_228 = (word32) dwLoc64_536 + 24;
				if (g_t81576F0 == 0x00)
					*((word32) dwLoc64_536 + 24) = edx_85;
				else
					runtime.writebarrierptr(edx_228, edx_85);
				runtime.gopanic(gs);
			}
			((word32) dwArg04 + 16)->u0 = 0x01;
		}
		if (bArg08 == 0x00)
			runtime.throw(gs);
		else
		{
			uint32 edx_276 = (word32) *((word32) ecx_19 + 8) + *((word32) edx_21 + 8) * 0x11;
			word32 edx_281 = SLICE(edx_276 *64 63849861, word32, 32) + edx_276;
			uint32 ebx_288 = edx_276 - (__rcr(edx_281, 0x01, SLICE(cond(edx_281), bool, 1)) >> 0x09) *s 1009;
			if (ebx_288 >= 1009)
				runtime.panicindex(gs);
			else
			{
				Eq_4 esi_299 = *((char *) g_a81468E0 + ebx_288 * 0x04);
				Eq_4 ebx_300 = ebx_288 * 0x04 + 135555296;
				if (g_t81576F0 == 0x00)
					*((word32) dwArg04 + 8) = esi_299;
				else
					runtime.writebarrierptr((word32) dwArg04 + 8, esi_299);
				*((word32) dwArg04 + 0x0011) = 0x01;
				runtime.atomicstorep(ebx_300, dwArg04);
			}
		}
	}
}

// 08052AC0: void runtime.itabsinit(Register Eq_4 esi, Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.schedinit
void runtime.itabsinit(Eq_4 esi, struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	word32 esi_163;
	word32 edi_164;
	runtime.lock(esi, gs, 0x081575F4, out esi_163, out edi_164);
	runtime.activeModules();
	word32 * eax_40 = &runtime.ifaceLock;
	int32 ecx_123 = dwLoc20;
	int32 edx_43 = 0x00;
	while (edx_43 < ecx_123)
	{
		struct Eq_11924 * ebx_68 = *eax_40;
		word32 * ebp_116 = ebx_68->ptr0084;
		int32 ebx_70 = ebx_68->dw0088;
		int32 esi_119 = 0x00;
		ebx_112 = ebx_70;
		eax_110 = eax_40;
		edx_111 = edx_43;
		while (true)
		{
			int32 edx_111;
			word32 * eax_110;
			int32 ebx_112;
			if (esi_119 >= ebx_112)
				break;
			Eq_4 edi_87 = *ebp_116;
			if (*((word32) edi_87 + 0x0011) == 0x00)
			{
				runtime.additab(gs, edi_87, 0x01, 0x00);
				eax_110 = eax_40;
				edx_111 = edx_43;
				ebx_112 = ebx_70;
			}
			++ebp_116;
			++esi_119;
			ecx_123 = dwLoc20;
		}
		eax_40 = eax_110 + 1;
		edx_43 = edx_111 + 0x01;
	}
	word32 edx_165;
	word32 ebx_166;
	runtime.unlock(gs, 0x081575F4, out edx_165, out ebx_166);
}

// 08052B90: void runtime.panicdottypeE(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      runtime.panicdottypeI
//      reflect.(*rtype).exportedMethods
//      reflect.(*rtype).ptrTo
//      reflect.FuncOf
//      reflect.funcLayout
//      reflect.callMethod
//      reflect.FuncOf.func1
//      fmt.newPrinter
void runtime.panicdottypeE(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 ecx_27;
	Eq_4 eax_26;
	if (dwArg04 == 0x00)
	{
		eax_26.u0 = 0x00;
		ecx_27.u0 = 0x00;
	}
	else
	{
		runtime.(*_type).string(gs, dwArg04);
		eax_26 = dwLoc24;
		ecx_27 = dwLoc20;
	}
	runtime.(*_type).string(gs, dwArg0C);
	runtime.(*_type).string(gs, dwArg08);
	runtime.newobject(gs, 0x080D6BA0);
	*((word32) dwLoc24 + 4) = dwLoc20;
	if (g_t81576F0 == 0x00)
		*dwLoc24 = dwLoc24;
	else
		runtime.writebarrierptr(dwLoc24, dwLoc24);
	*((word32) dwLoc24 + 0x0C) = ecx_27;
	if (g_t81576F0 == 0x00)
		*((word32) dwLoc24 + 8) = eax_26;
	else
		runtime.writebarrierptr((word32) dwLoc24 + 8, eax_26);
	*((word32) dwLoc24 + 20) = dwLoc20;
	if (g_t81576F0 == 0x00)
		*((word32) dwLoc24 + 16) = dwLoc24;
	else
		runtime.writebarrierptr((word32) dwLoc24 + 16, dwLoc24);
	((word32) dwLoc24 + 28)->u0 = 0x00;
	if (g_t81576F0 == 0x00)
		((word32) dwLoc24 + 24)->u0 = 0x00;
	else
		runtime.writebarrierptr((word32) dwLoc24 + 24, 0x00);
	runtime.gopanic(gs);
}

// 08052D10: void runtime.panicdottypeI(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      runtime.panicCheckMalloc
//      reflect.makeMethodValue
//      reflect.(*rtype).Method
//      reflect.FuncOf
//      reflect.Zero
//      reflect.New
//      reflect.cvtT2I
//      reflect.init
//      reflect.(*sliceType).Implements
//      reflect.(*sliceType).AssignableTo
//      reflect.(*sliceType).ConvertibleTo
void runtime.panicdottypeI(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 eax_20;
	if (dwArg04 != 0x00)
		eax_20 = *((word32) dwArg04 + 4);
	else
		eax_20.u0 = 0x00;
	runtime.panicdottypeE(gs, eax_20);
}

// 08052D60: Register word128 runtime.convT2E(Register Eq_4 ebx, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Register out Eq_12084 xmm1Out)
// Called from:
//      sync.(*Map).Store
//      sync.(*Map).LoadOrStore
//      sync.(*Map).missLocked
//      reflect.funcLayout
word128 runtime.convT2E(Eq_4 ebx, struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, union Eq_12084 & xmm1Out)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	word32 ebx_93;
	word32 esi_94;
	word32 edi_95;
	runtime.mallocgc(ebx, gs, *dwArg04, dwArg04, 0x01, out ebx_93, out esi_94, out edi_95);
	word128 xmm0_52;
	Eq_12084 xmm1_53;
	word32 esi_96;
	word32 edi_97;
	runtime.typedmemmove(dwArg04, dwLoc08, dwArg08, out esi_96, out edi_97, out xmm0_52, out xmm1_53);
	xmm1Out = xmm1_53;
	return xmm0_52;
}

// 08052DD0: Register Eq_4 runtime.convT2E32(Register Eq_4 ebx, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack (ptr32 word32) dwArg08)
// Called from:
//      reflect.FuncOf.func1
Eq_4 runtime.convT2E32(Eq_4 ebx, struct Eq_2 * gs, Eq_4 dwArg04, word32 * dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (*dwArg08 != 0x00)
	{
		word32 esi_85;
		word32 edi_86;
		runtime.mallocgc(ebx, gs, 0x04, dwArg04, 0x00, out ebx, out esi_85, out edi_86);
		*dwLoc04 = *dwArg08;
	}
	return ebx;
}

// 08052E40: void runtime.convT2Estring(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack (ptr32 Eq_924) dwArg08)
// Called from:
//      runtime.interhash
//      runtime.nilinterhash
//      runtime.efaceeq
//      runtime.ifaceeq
//      runtime.panicwrap
//      runtime.preprintpanics
//      runtime.sigpanic
//      reflect.newName
//      reflect.funcLayout
//      reflect.flag.mustBeAssignable
//      reflect.methodReceiver
//      reflect.Value.assignTo
//      reflect.(*sliceType).Bits
void runtime.convT2Estring(struct Eq_2 * gs, Eq_4 dwArg04, struct Eq_924 * dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (dwArg08->dw0004 != 0x00)
	{
		word32 ebx_85;
		word32 esi_86;
		word32 edi_87;
		runtime.mallocgc(ebx, gs, *dwArg04, dwArg04, 0x01, out ebx_85, out esi_86, out edi_87);
		Eq_4 ecx_35 = dwArg08->t0000;
		*((word32) dwLoc08 + 4) = dwArg08->dw0004;
		if (g_t81576F0 == 0x00)
			*dwLoc08 = ecx_35;
		else
			runtime.writebarrierptr(dwLoc08, ecx_35);
	}
}

// 08052ED0: void runtime.convT2Eslice(Register Eq_4 ebx, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack (ptr32 Eq_12219) dwArg08)
// Called from:
//      reflect.(*rtype).exportedMethods
//      reflect.FuncOf.func1
//      fmt.(*pp).fmtBytes
void runtime.convT2Eslice(Eq_4 ebx, struct Eq_2 * gs, Eq_4 dwArg04, struct Eq_12219 * dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (dwArg08->t0000 != 0x00)
	{
		word32 edi_112;
		word32 esi_111;
		word32 ebx_110;
		runtime.mallocgc(ebx, gs, *dwArg04, dwArg04, 0x01, out ebx_110, out esi_111, out edi_112);
		Eq_4 ebx_44 = dwArg08->t0000;
		Eq_4 ecx_45 = dwArg08->t0008;
		*((word32) dwLoc08 + 4) = dwArg08->dw0004;
		*((word32) dwLoc08 + 8) = ecx_45;
		if (g_t81576F0 == 0x00)
			*dwLoc08 = ebx_44;
		else
			runtime.writebarrierptr(dwLoc08, ebx_44);
	}
}

// 08052F70: Register word32 runtime.convT2I32(Register Eq_4 ebx, Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_12279) dwArg04, Stack (ptr32 word32) dwArg08)
// Called from:
//      syscall.readlinkat
//      syscall.Close
//      syscall.fcntl
//      syscall.write
//      syscall.munmap
//      syscall.mmap2
//      internal/poll.(*pollDesc).init
word32 runtime.convT2I32(Eq_4 ebx, struct Eq_2 * gs, struct Eq_12279 * dwArg04, word32 * dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 eax_18 = dwArg04->t0004;
	if (*dwArg08 != 0x00)
	{
		word32 ebx_84;
		word32 edi_85;
		runtime.mallocgc(ebx, gs, 0x04, eax_18, 0x00, out ebx_84, out esi, out edi_85);
		*dwLoc04 = *dwArg08;
	}
	return esi;
}

// 08052FE0: void runtime.assertE2I(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
// Called from:
//      reflect.ifaceE2I
//      runtime.runfinq
void runtime.assertE2I(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (dwArg08 == 0x00)
	{
		runtime.(*_type).string(gs, dwArg04);
		runtime.newobject(gs, 0x080D6BA0);
		*((word32) dwLoc18 + 20) = dwLoc14;
		if (g_t81576F0 == 0x00)
			*((word32) dwLoc18 + 16) = dwLoc18;
		else
			runtime.writebarrierptr((word32) dwLoc18 + 16, dwLoc18);
		((word32) dwLoc18 + 28)->u0 = 0x00;
		if (g_t81576F0 == 0x00)
			((word32) dwLoc18 + 24)->u0 = 0x00;
		else
			runtime.writebarrierptr((word32) dwLoc18 + 24, 0x00);
		runtime.gopanic(gs);
	}
	else
		runtime.getitab(gs, dwArg04, dwArg08, 0x00);
}

// 080530E0: void runtime.assertE2I2(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg08)
// Called from:
//      runtime.printany
//      runtime.SetFinalizer
//      runtime.preprintpanics
//      fmt.(*pp).handleMethods
void runtime.assertE2I2(struct Eq_2 * gs, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (dwArg08 == 0x00)
		return;
	runtime.getitab(gs, dwArg04, dwArg08, 0x01);
	if (dwLoc04 == 0x00)
		;
}

// 08053170: void reflect.ifaceE2I(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg10)
// Called from:
//      reflect.Value.assignTo
//      reflect.cvtT2I
void reflect.ifaceE2I(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg10)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.assertE2I(gs, dwArg04, dwArg08);
	if (g_t81576F0 == 0x00)
	{
		*dwArg10 = dwLoc10;
		*((word32) dwArg10 + 4) = dwLoc0C;
	}
	else
	{
		runtime.writebarrierptr(dwArg10, dwLoc10);
		runtime.writebarrierptr((word32) dwArg10 + 4, dwLoc0C);
	}
}

// 08053200: void runtime.(*lfstack).push(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack (ptr32 Eq_12439) dwArg08)
// Called from:
//      runtime.putempty
//      runtime.putfull
void runtime.(*lfstack).push(struct Eq_2 * gs, Eq_4 dwArg04, struct Eq_12439 * dwArg08)
{
	word32 dwLoc18 = SLICE(qwLoc1C, word32, 32);
	word32 dwLoc1C = (word32) qwLoc1C;
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	word32 ecx_18 = dwArg08->dw0008;
	dwArg08->dw0008 = ecx_18 + 0x01;
	do
	{
		word64 mm0_199;
		runtime/internal/atomic.Load64(dwArg04, out mm0_199);
		dwArg08->dw0000 = dwLoc1C;
		dwArg08->dw0004 = dwLoc18;
		word32 ebx_200;
		word32 ebp_201;
		runtime/internal/atomic.Cas64(dwArg04, qwLoc1C, ecx_18 + 0x01, out ebx_200, out ebp_201);
	} while (bLoc0C == 0x00);
}

// 08053360: void runtime.(*lfstack).pop(Register word24 edx_24_8, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      runtime.getempty
//      runtime.trygetfull
//      runtime.getfull
void runtime.(*lfstack).pop(word24 edx_24_8, struct Eq_2 * gs, Eq_4 dwArg04)
{
	word32 dwLoc20 = (word32) qwLoc20;
	Eq_4 dwLoc1C = SLICE(qwLoc20, word32, 32);
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	do
	{
		if (((int8) (dwLoc1C == 0x00) & (int8) (dwLoc20 == 0x00)) != 0x00)
			return;
		word64 mm0_149;
		runtime/internal/atomic.Load64(dwLoc1C, out mm0_149);
		word32 ebx_150;
		word32 ebp_151;
		runtime/internal/atomic.Cas64(dwArg04, qwLoc20, qwLoc20, out ebx_150, out ebp_151);
	} while (bLoc10 == 0x00);
}

// 08053410: void runtime.(*lfstack).empty(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      runtime.gcMarkWorkAvailable
void runtime.(*lfstack).empty(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	word64 mm0_57;
	runtime/internal/atomic.Load64(dwArg04, out mm0_57);
}

// 08053460: Register Eq_4 runtime.lock(Register Eq_4 esi, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Register out Eq_4 esiOut, Register out ptr32 ediOut)
// Called from:
//      runtime.chansend
//      runtime.closechan
//      runtime.chanrecv
//      runtime.GOMAXPROCS
//      runtime.getitab
//      runtime.itabsinit
//      runtime.persistentalloc1
//      runtime.allocmcache
//      runtime.(*mcentral).cacheSpan
//      runtime.(*mcentral).uncacheSpan
//      runtime.(*mcentral).freeSpan
//      runtime.queuefinalizer
//      runtime.wakefing
//      runtime.runfinq
//      runtime.findObject
//      runtime/debug.setGCPercent
//      runtime.gcMarkTermination
//      runtime.gcSweep
//      runtime.gcResetMarkState
//      runtime.clearpools
//      runtime.gcMarkRootCheck
//      runtime.markrootFreeGStacks
//      runtime.markrootSpans
//      runtime.gcWakeAllAssists
//      runtime.gcParkAssist
//      runtime.gcFlushBgCredit
//      runtime.bgsweep
//      runtime.(*gcSweepBuf).push
//      runtime.getempty
//      runtime.prepareFreeWorkbufs
//      runtime.freeSomeWbufs
//      runtime.(*mheap).reclaimList
//      runtime.(*mheap).reclaim
//      runtime.(*mheap).alloc_m
//      runtime.(*mheap).allocManual
//      runtime.(*mheap).freeManual
//      runtime.(*mheap).scavenge
//      runtime.addspecial
//      runtime.removespecial
//      runtime.addfinalizer
//      runtime.removefinalizer
//      runtime.setprofilebucket
//      runtime.freespecial
//      runtime.newMarkBits
//      runtime.nextMarkBitArenaEpoch
//      runtime.newArenaMayUnlock
//      runtime.mProf_NextCycle
//      runtime.mProf_Flush
//      runtime.mProf_Malloc
//      runtime.mProf_Free
//      runtime.saveblockevent
//      runtime.tracealloc
//      runtime.tracefree
//      runtime.tracegc
//      internal/poll.runtime_pollOpen
//      runtime.(*pollCache).free
//      internal/poll.runtime_pollUnblock
//      runtime.(*pollCache).alloc
//      runtime.startpanic_m
//      runtime.dopanic_m
//      runtime.printlock
//      runtime.forcegchelper
//      runtime.acquireSudog
//      runtime.releaseSudog
//      runtime.allgadd
//      runtime.mcommoninit
//      runtime.gcprocs
//      runtime.needaddgcproc
//      runtime.helpgc
//      runtime.stopTheWorldWithSema
//      runtime.startTheWorldWithSema
//      runtime.forEachP
//      runtime.runSafePointFn
//      runtime.stopm
//      runtime.startm
//      runtime.handoffp
//      runtime.gcstopm
//      runtime.findrunnable
//      runtime.injectglist
//      runtime.schedule
//      runtime.goschedImpl
//      runtime.entersyscall_sysmon
//      runtime.entersyscall_gcwait
//      runtime.exitsyscallfast_pidle
//      runtime.exitsyscall0
//      runtime.gfput
//      runtime.gfget
//      runtime.gfpurge
//      runtime.incidlelocked
//      runtime.checkdead
//      runtime.sysmon
//      runtime.schedtrace
//      runtime.runqputslow
//      runtime.(*rwmutex).runlock
//      runtime.semacquire1
//      runtime.semrelease1
//      runtime.stackcacherefill
//      runtime.stackcacherelease
//      runtime.stackcache_clear
//      runtime.stackalloc
//      runtime.stackfree
//      runtime.syncadjustsudogs
//      runtime.freeStackSpans
//      runtime.deltimer
//      runtime.timerproc
//      runtime.timejump
//      runtime.traceReader
//      runtime.traceProcFree
//      runtime.traceAcquireBuffer
//      runtime.traceFlush
//      runtime.(*traceStackTable).put
//      runtime.tracebackothers
//      runtime.reflectOffsLock
//      runtime.freemcache.func1
//      runtime.gcBgMarkWorker.func2
//      runtime.(*mheap).freeSpan.func1
//      runtime.newdefer.func1
//      runtime.freedefer.func1
//      runtime.(*rwmutex).rlock.func1
Eq_4 runtime.lock(Eq_4 esi, struct Eq_2 * gs, Eq_4 dwArg04, union Eq_4 & esiOut, ptr32 & ediOut)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 eax_19 = *((word32) gs->ptr0000->tFFFFFFFC + 24);
	Eq_4 ecx_20 = *((word32) eax_19 + 0x0078);
	if (ecx_20 < 0x00)
		runtime.throw(gs);
	else
	{
		*((word32) eax_19 + 0x0078) = (word32) ecx_20 + 1;
		runtime/internal/atomic.Xchg(dwArg04, 0x01);
		Eq_4 eax_106 = dwLoc18;
		if (dwLoc18 == 0x00)
		{
			esiOut = esi;
			ediOut = edi;
			return ebp;
		}
		else
		{
			int32 ecx_50;
			if (runtime.ncpu > 0x01)
				ecx_50 = 0x04;
			else
				ecx_50 = 0x00;
			while (true)
			{
				int32 edx_154 = 0x00;
l08053529:
				if (edx_154 < ecx_50)
					break;
				int32 edx_117 = 0x00;
l08053582:
				word24 ecx_24_8_92 = SLICE(ecx_50, word24, 8);
				if (edx_117 < 0x01)
				{
					do
					{
						ebp = *dwArg04;
						if (ebp != 0x00)
						{
							runtime.osyield();
							++edx_117;
							goto l08053582;
						}
						runtime/internal/atomic.Cas(dwArg04, 0x00, eax_106);
						dwLoc18 = eax_106;
					} while (bLoc14 == 0x00);
					esiOut = esi;
					ediOut = edi;
					return ebp;
				}
				word24 ebx_24_8_91 = SLICE(runtime/internal/atomic.Xchg(dwArg04, 0x02), word24, 8);
				if (dwLoc18 == 0x00)
				{
					esiOut = esi;
					ediOut = edi;
					return ebp;
				}
				dwLoc18.u0 = ~0x00;
				bLoc14 = ~0x00;
				ebp = runtime.futexsleep(ecx_24_8_92, ebx_24_8_91, esi, (struct Eq_12643 *) ~0x00, (struct Eq_12643 *) ~0x00, out esi, out edi);
				eax_106.u0 = 0x02;
			}
			do
			{
				ebp = *dwArg04;
				if (ebp != 0x00)
				{
					runtime.procyield(0x1E);
					++edx_154;
					goto l08053529;
				}
				runtime/internal/atomic.Cas(dwArg04, 0x00, eax_106);
				dwLoc18 = eax_106;
			} while (bLoc14 == 0x00);
			esiOut = esi;
			ediOut = edi;
			return ebp;
		}
	}
}

// 08053620: Register Eq_4 runtime.unlock(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Register out ptr32 edxOut, Register out ptr32 ebxOut)
// Called from:
//      runtime.chansend
//      runtime.closechan
//      runtime.chanrecv
//      runtime.GOMAXPROCS
//      runtime.getitab
//      runtime.additab
//      runtime.itabsinit
//      runtime.persistentalloc1
//      runtime.allocmcache
//      runtime.(*mcentral).cacheSpan
//      runtime.(*mcentral).uncacheSpan
//      runtime.(*mcentral).freeSpan
//      runtime.queuefinalizer
//      runtime.wakefing
//      runtime.runfinq
//      runtime.findObject
//      runtime/debug.setGCPercent
//      runtime.gcMarkTermination
//      runtime.gcSweep
//      runtime.gcResetMarkState
//      runtime.clearpools
//      runtime.gcMarkRootCheck
//      runtime.markrootFreeGStacks
//      runtime.markrootSpans
//      runtime.gcWakeAllAssists
//      runtime.gcParkAssist
//      runtime.gcFlushBgCredit
//      runtime.bgsweep
//      runtime.(*gcSweepBuf).push
//      runtime.getempty
//      runtime.prepareFreeWorkbufs
//      runtime.freeSomeWbufs
//      runtime.(*mheap).reclaimList
//      runtime.(*mheap).reclaim
//      runtime.(*mheap).alloc_m
//      runtime.(*mheap).allocManual
//      runtime.(*mheap).freeManual
//      runtime.(*mheap).scavenge
//      runtime.addspecial
//      runtime.removespecial
//      runtime.addfinalizer
//      runtime.removefinalizer
//      runtime.setprofilebucket
//      runtime.freespecial
//      runtime.newMarkBits
//      runtime.nextMarkBitArenaEpoch
//      runtime.newArenaMayUnlock
//      runtime.mProf_NextCycle
//      runtime.mProf_Flush
//      runtime.mProf_Malloc
//      runtime.mProf_Free
//      runtime.saveblockevent
//      runtime.tracealloc
//      runtime.tracefree
//      runtime.tracegc
//      internal/poll.runtime_pollOpen
//      runtime.(*pollCache).free
//      internal/poll.runtime_pollUnblock
//      runtime.(*pollCache).alloc
//      runtime.dopanic_m
//      runtime.printunlock
//      runtime.acquireSudog
//      runtime.releaseSudog
//      runtime.allgadd
//      runtime.mcommoninit
//      runtime.gcprocs
//      runtime.needaddgcproc
//      runtime.helpgc
//      runtime.stopTheWorldWithSema
//      runtime.startTheWorldWithSema
//      runtime.forEachP
//      runtime.runSafePointFn
//      runtime.stopm
//      runtime.startm
//      runtime.handoffp
//      runtime.gcstopm
//      runtime.findrunnable
//      runtime.injectglist
//      runtime.schedule
//      runtime.parkunlock_c
//      runtime.goschedImpl
//      runtime.entersyscall_sysmon
//      runtime.entersyscall_gcwait
//      runtime.exitsyscallfast_pidle
//      runtime.exitsyscall0
//      runtime.gfput
//      runtime.gfget
//      runtime.gfpurge
//      runtime.incidlelocked
//      runtime.checkdead
//      runtime.sysmon
//      runtime.schedtrace
//      runtime.runqputslow
//      runtime.(*rwmutex).runlock
//      runtime.semacquire1
//      runtime.semrelease1
//      runtime.stackcacherefill
//      runtime.stackcacherelease
//      runtime.stackcache_clear
//      runtime.stackalloc
//      runtime.stackfree
//      runtime.syncadjustsudogs
//      runtime.freeStackSpans
//      runtime.deltimer
//      runtime.timerproc
//      runtime.timejump
//      runtime.traceReader
//      runtime.traceProcFree
//      runtime.traceReleaseBuffer
//      runtime.traceFlush
//      runtime.(*traceStackTable).put
//      runtime.tracebackothers
//      runtime.reflectOffsUnlock
//      runtime.chansend.func1
//      runtime.chanrecv.func1
//      runtime.freemcache.func1
//      runtime.gcBgMarkWorker.func2
//      runtime.(*mheap).freeSpan.func1
//      runtime.newdefer.func1
//      runtime.freedefer.func1
//      runtime.(*rwmutex).rlock.func1
Eq_4 runtime.unlock(struct Eq_2 * gs, Eq_4 dwArg04, ptr32 & edxOut, ptr32 & ebxOut)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	ptr32 ebx_24 = runtime/internal/atomic.Xchg(dwArg04, 0x00);
	if (dwLoc04 == 0x00)
		runtime.throw(gs);
	else
	{
		if (dwLoc04 == 0x02)
			runtime.futexwakeup();
		Eq_4 eax_48 = gs->ptr0000->tFFFFFFFC;
		Eq_4 ecx_49 = *((word32) eax_48 + 24);
		Eq_4 edx_50 = *((word32) ecx_49 + 0x0078);
		*((word32) ecx_49 + 0x0078) = edx_50 - 0x01;
		Eq_4 ecx_54 = *((word32) *((word32) eax_48 + 24) + 0x0078);
		if (ecx_54 < 0x00)
			runtime.throw(gs);
		else
		{
			if (ecx_54 == 0x00)
			{
				ecx_54 = (word32) *((word32) eax_48 + 0x006C);
				if ((byte) ecx_54 != 0x00)
					((word32) eax_48 + 8)->u0 = ~0x0521;
			}
			edxOut = edx_50 - 0x01;
			ebxOut = ebx_24;
			return ecx_54;
		}
	}
}

// 080536F0: Register ptr32 runtime.notewakeup(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      runtime.gcBgMarkWorker
//      runtime.gchelper
//      runtime.helpgc
//      runtime.startTheWorldWithSema
//      runtime.runSafePointFn
//      runtime.startm
//      runtime.handoffp
//      runtime.startlockedm
//      runtime.gcstopm
//      runtime.entersyscall_sysmon
//      runtime.entersyscall_gcwait
//      runtime.exitsyscallfast_pidle
//      runtime.exitsyscall0
//      runtime.checkdead
//      runtime.(*profBuf).write
//      runtime.(*profBuf).wakeupExtra
//      runtime.(*rwmutex).runlock
//      runtime.sigsend
ptr32 runtime.notewakeup(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	ptr32 ebx_23 = runtime/internal/atomic.Xchg(dwArg04, 0x01);
	if (dwLoc08 != 0x00)
	{
		runtime.printlock(gs);
		runtime.printstring(gs);
		runtime.printint(ebx_24_8, gs, dwLoc08);
		runtime.printstring(gs);
		runtime.printunlock(gs);
		runtime.throw(gs);
	}
	else
	{
		runtime.futexwakeup();
		return ebx_23;
	}
}

// 080537B0: void runtime.notesleep(Register Eq_4 esi, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg00, Stack Eq_12773 nArg04)
// Called from:
//      runtime.gcMark
//      runtime.stopm
//      runtime.stoplockedm
//      runtime.(*rwmutex).rlock.func1
void runtime.notesleep(Eq_4 esi, struct Eq_2 * gs, Eq_4 dwArg00, Eq_12773 nArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 eax_18 = gs->ptr0000->tFFFFFFFC;
	if (eax_18 != *(*((word32) eax_18 + 24)))
		runtime.throw(gs);
	else
	{
		struct Eq_12643 * edx_36;
		struct Eq_12643 * ecx_35;
		if (*runtime.cgo_yield != null)
		{
			ecx_35 = (struct Eq_12643 *) 10000000;
			edx_36 = null;
		}
		else
		{
			ecx_35 = (struct Eq_12643 *) ~0x00;
			edx_36 = (struct Eq_12643 *) ~0x00;
		}
		while (true)
		{
			runtime/internal/atomic.Load();
			if (dwLoc18 != 0x00)
				break;
			*((word32) *((word32) eax_18 + 24) + 141) = 0x01;
			word32 edi_170;
			runtime.futexsleep(SLICE(dwArg04, word24, 8), SLICE(edx_36, word24, 8), esi, ecx_35, edx_36, out esi, out edi_170);
			<anonymous> * eax_88 = *runtime.cgo_yield;
			if (eax_88 != null)
			{
				word32 edi_171;
				runtime.asmcgocall(gs, eax_88, 0x00, out edi_171);
			}
			*((word32) *((word32) eax_18 + 24) + 141) = 0x00;
			dwLoc18 = 0x00;
		}
	}
}

// 080538C0: Register Eq_4 runtime.notetsleep_internal(Register word24 edx_24_8, Register (ptr32 word32) ebp, Register Eq_4 esi, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg00, Stack ptr32 dwArg04, Stack (ptr32 Eq_12643) dwArg08, Stack Eq_12862 qwArg0C)
// Called from:
//      runtime.notetsleep
//      runtime.notetsleepg
Eq_4 runtime.notetsleep_internal(word24 edx_24_8, word32 * ebp, Eq_4 esi, struct Eq_2 * gs, Eq_4 dwArg00, ptr32 dwArg04, struct Eq_12643 * dwArg08, Eq_12862 qwArg0C)
{
	struct Eq_12643 * dwArg0C = (word32) qwArg0C;
	word32 dwLoc14 = SLICE(qwLoc18, word32, 32);
	word32 dwLoc18 = (word32) qwLoc18;
	struct Eq_12643 * dwArg10 = SLICE(qwArg0C, word32, 32);
	Eq_4 eax_8 = gs->ptr0000->tFFFFFFFC;
	struct Eq_12643 * ecx_10 = dwArg08;
	if (((int8) (dwArg0C < null) | (int8) Test(ULT,false) & (int8) (dwArg0C == null)) == 0x00)
	{
		runtime/internal/atomic.Load();
		if (dwLoc14 != 0x00)
			return esi;
		runtime.nanotime();
		struct Eq_12643 * ecx_102 = dwArg0C;
		struct Eq_12643 * ebx_125 = dwArg10;
		while (true)
		{
			<anonymous> * ebp_86 = *runtime.cgo_yield;
			if (ebp_86 != null)
			{
				ui24 ebx_24_8_98 = SLICE(ebp_86, word24, 8);
				Eq_4 esi_126 = SEQ(SLICE(esi, word24, 8), (int8) (ecx_102 > (struct Eq_12643 *) 10000000)) & SEQ(ebx_24_8_98, (int8) (ebx_125 == null)) | SEQ(ebx_24_8_98, (int8) (ebx_125 > null));
				esi = esi_126;
				if ((byte) esi_126 != 0x00)
				{
					ecx_102 = (struct Eq_12643 *) 10000000;
					ebx_125 = null;
				}
			}
			dwLoc0C->ptr0018->b008D = 0x01;
			word32 edi_499;
			Eq_4 esi_164;
			runtime.futexsleep(SLICE(ecx_102, word24, 8), SLICE(ebx_125, word24, 8), esi, ecx_102, ebx_125, out esi_164, out edi_499);
			<anonymous> * eax_170 = *runtime.cgo_yield;
			if (eax_170 != null)
			{
				word32 edi_500;
				runtime.asmcgocall(gs, eax_170, dwArg04, out edi_500);
			}
			dwLoc0C->ptr0018->b008D = 0x00;
			runtime/internal/atomic.Load();
			if (ecx_102 != null)
				break;
			ui24 ebx_24_8_216 = SLICE(runtime.nanotime(), word24, 8);
			Eq_4 esi_233 = SEQ(SLICE(esi_164, word24, 8), (int8) (dwLoc10 <= 0x00)) & SEQ(ebx_24_8_216, (int8) (ecx_102 == dwLoc0C)) | SEQ(ebx_24_8_216, (int8) (ecx_102 > dwLoc0C));
			esi_164 = esi_233;
			if ((byte) esi_233 != 0x00)
				break;
			ui64 ebx_ebp_354 = dwLoc10 - ecx_102;
			esi = dwLoc10;
			ebx_125 = SLICE(ebx_ebp_354, word32, 32);
			ecx_102 = (word32) ebx_ebp_354;
		}
		runtime/internal/atomic.Load();
		return esi_164;
	}
	else
	{
		struct Eq_12643 * edx_271;
		if (*runtime.cgo_yield != null)
		{
			ecx_10 = (struct Eq_12643 *) 10000000;
			edx_271 = null;
		}
		else
			edx_271 = dwArg0C;
		while (true)
		{
			runtime/internal/atomic.Load();
			if (dwLoc18 != 0x00)
				break;
			*((word32) *((word32) eax_8 + 24) + 141) = 0x01;
			word32 edi_497;
			runtime.futexsleep(SLICE(dwArg04, word24, 8), SLICE(edx_271, word24, 8), esi, ecx_10, edx_271, out esi, out edi_497);
			<anonymous> * eax_322 = *runtime.cgo_yield;
			if (eax_322 != null)
			{
				word32 edi_498;
				runtime.asmcgocall(gs, eax_322, dwArg04, out edi_498);
			}
			*((word32) *((word32) eax_8 + 24) + 141) = 0x00;
		}
		return esi;
	}
}

// 08053B00: Register Eq_4 runtime.notetsleep(Register (ptr32 word32) ebp, Register Eq_4 esi, Register (ptr32 Eq_2) gs, Stack ptr32 dwArg04, Stack (ptr32 Eq_12643) dwArg08, Stack word32 dwArg0C)
// Called from:
//      runtime.stopTheWorldWithSema
//      runtime.forEachP
//      runtime.sysmon
Eq_4 runtime.notetsleep(word32 * ebp, Eq_4 esi, struct Eq_2 * gs, ptr32 dwArg04, struct Eq_12643 * dwArg08, word32 dwArg0C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 eax_18 = gs->ptr0000->tFFFFFFFC;
	Eq_4 ecx_19 = *((word32) eax_18 + 24);
	Eq_4 edx_20 = *ecx_19;
	word24 edx_24_8_49 = SLICE(edx_20, word24, 8);
	if (eax_18 == edx_20 || *((word32) ecx_19 + 116) == 0x00)
		return runtime.notetsleep_internal(edx_24_8_49, ebp, esi, gs, dwLoc14, dwArg04, dwArg08, SEQ(dwLoc04, dwArg0C));
	runtime.throw(gs);
}

// 08053B80: void runtime.notetsleepg(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.gcBgMarkStartWorkers
//      runtime.timerproc
void runtime.notetsleepg(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 eax_17 = gs->ptr0000->tFFFFFFFC;
	if (eax_17 == *(*((word32) eax_17 + 24)))
		runtime.throw(gs);
	else
	{
		runtime.entersyscallblock(gs);
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_4 stackArg0 = <invalid>;
		runtime.notetsleep_internal(edx_24_8, ebp, esi, gs, stackArg0, dwArg04, dwArg08, dwArg0C);
		word32 esi_80;
		runtime.exitsyscall(gs, out esi_80);
	}
}

// 08053C20: void runtime.mallocinit(Register word24 ebx_24_8, Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.schedinit
void runtime.mallocinit(word24 ebx_24_8, struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (g_w8138824 != 0x10)
		runtime.throw(gs);
	else
	{
		runtime.testdefersizes(gs);
		Eq_13166 eax_38 = 0x00;
		while (eax_38 < 0x43)
		{
			if (eax_38 >= 0x43)
				runtime.panicindex(gs);
			word32 ebx_524 = (word32) g_a8138820[eax_38 * 0x02];
			g_a8159254[eax_38] = (struct Eq_138557) ebx_524;
			ebx_24_8 = SLICE(ebx_524, word24, 8);
			eax_38 = (word32) eax_38 + 1;
		}
		Eq_4 eax_45 = runtime.physPageSize;
		if (eax_45 == 0x00)
			runtime.throw(gs);
		else if (eax_45 < 0x1000)
		{
			runtime.printlock(gs);
			runtime.printstring(gs);
			runtime.printint(ebx_24_8, gs, (uint64) runtime.physPageSize);
			runtime.printstring(gs);
			runtime.printint(ebx_24_8, gs, 0x1000);
			runtime.printstring(gs);
			runtime.printunlock(gs);
			runtime.throw(gs);
		}
		else if ((eax_45 & eax_45 - 0x01) != 0x00)
		{
			runtime.printlock(gs);
			runtime.printstring(gs);
			runtime.printint(ebx_24_8, gs, (uint64) runtime.physPageSize);
			runtime.printstring(gs);
			runtime.printunlock(gs);
			runtime.throw(gs);
		}
		else
		{
			runtime.sbrk0();
			Eq_4 esi_203 = fn08090278(&g_t80F1E40, fp - 0x18);
			Eq_4 ecx_208 = 0x00;
			word32 * edx_209 = fp - 0x18;
			Eq_4 ebx_210 = 0x00;
			word32 ebp_211 = 0x00;
			while (true)
			{
				word32 ecx_220;
				Eq_4 eax_218;
				if (ecx_208 >= 0x04)
					break;
				word32 ebx_225 = *edx_209;
				uint32 ebp_228 = g_dw8139478 + 0x0013FFFF & 0xFFF00000;
				esi_203 = runtime.sysReserve(gs, fp - 0x31);
				eax_218 = dwLoc38;
				if (dwLoc38 != 0x00)
				{
					ecx_220 = ebx_225 + 0x10202000;
					goto l08053D4E;
				}
				++edx_209;
				esi_203 = ecx_208;
				ecx_208 = (word32) ecx_208 + 1;
				ebx_210 = dwLoc38;
				ebp_211 = ebx_225 + 0x10202000;
			}
			eax_218 = ebx_210;
			ecx_220 = ebp_211;
l08053D4E:
			if (eax_218 == 0x00)
				runtime.throw(gs);
			else
			{
				ui32 edx_289 = (word32) eax_218 + 0x00001FFF;
				Eq_4 ebx_291 = (edx_289 & ~0x1FFF) + 0x10200000;
				g_t81493A0 = ebx_291;
				g_t81493A8.u0 = 0x00;
				g_dw81493B4 = (word32) eax_218 + (ecx_220 - ((edx_289 & ~0x1FFF) - eax_218));
				g_t81493AC = ebx_291;
				g_t81493B0 = ebx_291;
				g_b81493B8 = 0x00;
				Eq_4 ecx_305 = g_t81493A8;
				if ((ecx_305 & 0x1FFF) != 0x00)
				{
					runtime.printlock(gs);
					runtime.printstring(gs);
					runtime.printsp(gs);
					Eq_4 esi_345;
					runtime.printhex(esi_203, gs, eax_218, 0x00, out esi_345);
					runtime.printsp(gs);
					Eq_4 esi_365;
					runtime.printhex(esi_345, gs, ebx_291, 0x00, out esi_365);
					runtime.printsp(gs);
					Eq_4 esi_384;
					runtime.printhex(esi_365, gs, 0x00200000, 0x00, out esi_384);
					runtime.printsp(gs);
					Eq_4 esi_403;
					runtime.printhex(esi_384, gs, 0x10000000, 0x00, out esi_403);
					runtime.printsp(gs);
					Eq_4 esi_422;
					runtime.printhex(esi_403, gs, 0x2000, 0x00, out esi_422);
					runtime.printsp(gs);
					runtime.printstring(gs);
					runtime.printsp(gs);
					word32 esi_615;
					runtime.printhex(esi_422, gs, ecx_305, 0x00, out esi_615);
					runtime.printnl(gs);
					runtime.printunlock(gs);
					runtime.throw(gs);
				}
				else
				{
					runtime.(*mheap).init(gs, 0x081488E0, edx_289 & ~0x1FFF, 0x00200000);
					Eq_4 eax_500 = gs->ptr0000->tFFFFFFFC;
					runtime.allocmcache(esi_203, gs);
					((word32) *((word32) eax_500 + 24) + 0x00B8)->u0 = 0x081488E0;
				}
			}
		}
	}
}

// 08054040: void runtime.(*mheap).sysAlloc(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
// Called from:
//      runtime.(*mheap).grow
void runtime.(*mheap).sysAlloc(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 ecx_18 = *((word32) dwArg04 + 2772);
	if (dwArg08 <= ecx_18 - *((word32) dwArg04 + 0x0AD0))
	{
l0805409E:
		uint32 ebx_109 = *((word32) dwArg04 + 0x0AD0);
		if (dwArg08 <= *((word32) dwArg04 + 2772) - ebx_109)
		{
			runtime.sysMap(gs, ebx_109, *((word32) dwArg04 + 2776));
			word32 ecx_133 = Mem123[dwArg04 + 0x0AD0:word32] + dwArg08;
			*((word32) dwArg04 + 0x0AD0) = ecx_133;
			if (ecx_133 > *((word32) dwArg04 + 0x0ACC))
				runtime.(*mheap).setArenaUsed(gs, dwArg04, ecx_133);
			if ((ebx_109 & 0x1FFF) == 0x00)
				return;
			runtime.throw(gs);
		}
		goto l080540B4;
	}
	ui32 ecx_26 = (word32) dwArg08 + 0x10001FFF & 0xF0000000;
	Eq_4 ebp_27 = (word32) ecx_18 + ecx_26;
	if (ecx_18 > ebp_27)
		goto l0805409E;
	esi = ebp_27;
	if (ebp_27 - *((word32) dwArg04 + 0x0AC8) > 0x00)
		goto l0805409E;
	runtime.sysReserve(gs, fp - 33);
	dwLoc2C = fp - 33;
	if (dwLoc28 == 0x00)
	{
l080540B4:
		runtime.sysAlloc();
		int32 dwLoc20_359 = (word32) dwArg08 + 0x00001FFF & ~0x1FFF;
		if (dwLoc2C == 0x00)
			return;
		Eq_4 edx_188 = *((word32) dwArg04 + 0x0AC8);
		if (dwLoc2C >= edx_188 && (((word32) dwLoc2C + 0x00002000) + dwLoc20_359) - edx_188 <= ~0x00)
		{
			uint32 eax_199 = (word32) dwLoc2C + (-dwLoc2C & 0x1FFF);
			uint32 edx_201 = (word32) dwArg08 + eax_199;
			if (edx_201 > *((word32) dwArg04 + 0x0ACC))
				runtime.(*mheap).setArenaUsed(gs, dwArg04, edx_201);
			if ((eax_199 & 0x1FFF) == 0x00)
				return;
			runtime.throw(gs);
		}
		else
		{
			runtime.printlock(gs);
			runtime.printstring(gs);
			word32 esi_483;
			runtime.printhex(esi, gs, dwLoc2C, 0x00, out esi_483);
			runtime.printstring(gs);
			word32 esi_484;
			runtime.printhex(esi, gs, edx_188, 0x00, out esi_484);
			runtime.printstring(gs);
			word32 esi_485;
			runtime.printhex(esi, gs, (word32) edx_188 - 1, SLICE(cond((word32) edx_188 - 1), bool, 1), out esi_485);
			runtime.printstring(gs);
			runtime.printunlock(gs);
			runtime.sysFree();
			return;
		}
	}
	Eq_4 edx_53 = *((word32) dwArg04 + 2772);
	if (dwLoc28 == edx_53)
	{
		*((word32) dwArg04 + 2772) = ebp_27;
		*((word32) dwArg04 + 2776) = 0x00;
		goto l08054316;
	}
	Eq_4 ebx_56 = *((word32) dwArg04 + 0x0AC8);
	if (ebx_56 <= dwLoc28)
	{
		Eq_4 esi_61 = (word32) dwLoc28 + ecx_26;
		esi = esi_61 - ebx_56;
		if (esi <= 0x00 && edx_53 - *((word32) dwArg04 + 0x0AD0) < 0x01000000)
		{
			*((word32) dwArg04 + 2772) = esi_61;
			*((word32) dwArg04 + 0x0AD0) = (word32) dwLoc28 + 0x00001FFF & ~0x1FFF;
			*((word32) dwArg04 + 2776) = 0x00;
l08054316:
			goto l0805409E;
		}
	}
	runtime.sysFree();
	dwLoc2C = fp - 0x08;
	goto l08054316;
}

// 080543E0: void runtime.nextFreeFast(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      runtime.mallocgc
void runtime.nextFreeFast(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime/internal/sys.Ctz64(*((word32) dwArg04 + 32), *((word32) dwArg04 + 36));
	if (dwLoc10 >= 0x40)
		return;
	Eq_4 ebx_32 = *((word32) dwArg04 + 24);
	Eq_4 esi_34 = *((word32) dwArg04 + 28);
	if (ebx_32 + dwLoc10 >=u esi_34)
		return;
	Eq_4 ebx_41 = (word32) ebx_32 + ((word32) dwLoc10 + 1);
	if ((ebx_41 & 0x3F) == 0x00 && ebx_41 != esi_34)
		return;
	Eq_4 edi_55 = *((word32) dwArg04 + 36);
	Eq_13683 eax_70 = -((word32) dwLoc10 - 31);
	ui32 eax_82 = 0x00 - (dwLoc10 < ~0x1E);
	*((word32) dwArg04 + 32) = edi_55 >> (byte) dwLoc10 + 225 & 0x00 - (dwLoc10 < 0x3F) | (*((word32) dwArg04 + 32) >> (byte) dwLoc10 + 0x01 & eax_82 | edi_55 << (byte) eax_70 & 0x00 - (eax_70 < 0x20));
	*((word32) dwArg04 + 36) = edi_55 >> (byte) dwLoc10 + 0x01 & eax_82;
	*((word32) dwArg04 + 24) = ebx_41;
	*((word32) dwArg04 + 56) = (word32) *((word32) dwArg04 + 56) + 1;
}

// 080544E0: void runtime.(*mcache).nextFree(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack byte bArg08)
// Called from:
//      runtime.mallocgc
void runtime.(*mcache).nextFree(struct Eq_2 * gs, Eq_4 dwArg04, byte bArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	uint32 edx_22 = (word32) bArg08;
	if (edx_22 >= 0x86)
		runtime.panicindex(gs);
	else
	{
		Eq_4 ecx_30 = *((word32) dwArg04 + (edx_22 * 0x04 + 20));
		runtime.(*mspan).nextFreeIndex(gs, ecx_30);
		Eq_4 ecx_136 = ecx_30;
		Eq_4 edx_39 = *((word32) ecx_30 + 28);
		if (dwLoc20 == edx_39)
		{
			Eq_4 ax_46 = *((word32) ecx_30 + 56);
			if ((word32) ax_46 != edx_39)
			{
				runtime.printlock(gs);
				runtime.printstring(gs);
				runtime.printsp(gs);
				runtime.printint(ebx_24_8, gs, (word32) ax_46);
				runtime.printsp(gs);
				runtime.printstring(gs);
				runtime.printsp(gs);
				runtime.printint(ebx_24_8, gs, edx_39);
				runtime.printnl(gs);
				runtime.printunlock(gs);
				runtime.throw(gs);
			}
			word32 ebp_295;
			word32 edi_296;
			runtime.systemstack(gs, fp - 0x0C, out ebp_295, out edi_296);
			Eq_4 eax_128 = *((word32) dwArg04 + (edx_22 * 0x04 + 20));
			runtime.(*mspan).nextFreeIndex(gs, eax_128);
			ecx_136 = eax_128;
		}
		if (dwLoc20 >= *((word32) ecx_136 + 28))
			runtime.throw(gs);
		else
		{
			Eq_4 bp_157 = (word32) *((word32) ecx_136 + 56) + 1;
			*((word32) ecx_136 + 56) = bp_157;
			Eq_4 esi_162 = *((word32) ecx_136 + 28);
			if ((word32) bp_157 <= esi_162)
				return;
			runtime.printlock(gs);
			runtime.printstring(gs);
			runtime.printsp(gs);
			runtime.printint(ebx_24_8, gs, (word32) bp_157);
			runtime.printsp(gs);
			runtime.printstring(gs);
			runtime.printsp(gs);
			runtime.printint(ebx_24_8, gs, esi_162);
			runtime.printnl(gs);
			runtime.printunlock(gs);
			runtime.throw(gs);
		}
	}
}

// 08054730: Register Eq_4 runtime.mallocgc(Register Eq_4 ebx, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack byte bArg0C, Register out Eq_4 ebxOut, Register out ptr32 esiOut, Register out Eq_4 ediOut)
// Called from:
//      runtime.makechan
//      runtime.convT2E
//      runtime.convT2E32
//      runtime.convT2Estring
//      runtime.convT2Eslice
//      runtime.convT2I32
//      runtime.newobject
//      runtime.newarray
//      runtime.runfinq
//      runtime.makeslice
//      runtime.growslice
//      runtime.slicebytetostring
//      runtime.rawstring
//      runtime.rawbyteslice
//      runtime.rawruneslice
//      runtime.newdefer.func2
Eq_4 runtime.mallocgc(Eq_4 ebx, struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, byte bArg0C, union Eq_4 & ebxOut, ptr32 & esiOut, union Eq_4 & ediOut)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		edx = runtime.morestack_noctxt();
	if (runtime.gcphase == 0x02)
		runtime.throw(gs);
	if (dwArg04 == 0x00)
	{
		ebxOut = ebx;
		esiOut = esi;
		ediOut = edi;
		return edx;
	}
	if (g_dw8157748 != 0x00)
	{
		Eq_4 edx_798 = runtime.persistentalloc(gs);
		ebxOut = ebx;
		esiOut = esi;
		ediOut = edi;
		return edx_798;
	}
	Eq_4 edx_186;
	if (runtime.gcBlackenEnabled != 0x00)
	{
		Eq_4 ecx_49 = gs->ptr0000->tFFFFFFFC;
		edx_186 = *((word32) *((word32) ecx_49 + 24) + 84);
		if (edx_186 == 0x00)
			edx_186 = ecx_49;
		Eq_13922 ecx_60 = *((byte) edx_186.u0 + 0x00CC) - dwArg04;
		Eq_4 eax_62 = *((byte) edx_186.u0 + 0x00D0);
		*((byte) edx_186.u0 + 0x00CC) = ecx_60;
		Eq_4 eax_65 = eax_62 - (ecx_60 < 0x00);
		*((byte) edx_186.u0 + 0x00D0) = eax_65;
		if (((int8) (eax_65 < 0x00) | (int8) (eax_65 == 0x00) & (int8) Test(ULT,false)) != 0x00)
			runtime.gcAssistAlloc(esi, gs, edx_186, dwLoc4C);
	}
	else
		edx_186.u0 = 0x00;
	Eq_4 eax_103 = gs->ptr0000->tFFFFFFFC;
	Eq_4 ecx_104 = *((word32) eax_103 + 24);
	*((word32) ecx_104 + 0x0078) = (word32) *((word32) ecx_104 + 0x0078) + 1;
	Eq_4 ecx_108 = *((word32) eax_103 + 24);
	if (*((word32) ecx_108 + 0x0068) != 0x00)
		runtime.throw(gs);
	if (*((word32) ecx_108 + 44) == (gs->ptr0000)->tFFFFFFFC)
		runtime.throw(gs);
	ptr32 esi_148;
	((word32) ecx_108 + 0x0068)->u0 = 0x01;
	Eq_4 eax_143 = *((word32) *((word32) gs->ptr0000->tFFFFFFFC + 24) + 0x00B8);
	if (dwArg08 != 0x00)
	{
		word32 esi_149 = (word32) *((word32) dwArg08 + 0x0F);
		esi_148 = SEQ(SLICE(esi_149, word24, 8), (int8) (((byte) esi_149 & 0x80) != 0x00));
	}
	else
		esi_148 = 0x01;
	Eq_4 dwArg04_847;
	byte cl_484;
	Eq_4 eax_228;
	byte al_180 = (byte) esi_148;
	if (dwArg04 <= 0x8000)
	{
		if ((byte) esi_148 != 0x00 && dwArg04 < 0x10)
		{
			edi = *((word32) eax_143 + 0x0C);
			if ((dwArg04 & 0x07) == 0x00)
				edi = (word32) edi + 7 & ~0x07;
			else if ((dwArg04 & 0x03) == 0x00)
				edi = (word32) edi + 3 & ~0x03;
			else if ((dwArg04 & 0x01) == 0x00)
				edi = (word32) edi + 1 & ~0x01;
			word32 edx_416 = edi + dwArg04;
			if (edx_416 <= 0x10)
			{
				Eq_4 ebx_421 = *((word32) eax_143 + 8);
				if (ebx_421 != 0x00)
				{
					*((word32) eax_143 + 0x0C) = edx_416;
					*((word32) eax_143 + 16) = (word32) *((word32) eax_143 + 16) + 1;
					((word32) ecx_108 + 0x0068)->u0 = 0x00;
					Eq_4 eax_764 = gs->ptr0000->tFFFFFFFC;
					Eq_4 edx_765 = *((word32) ecx_108 + 0x0078);
					*((word32) ecx_108 + 0x0078) = edx_765 - 0x01;
					word32 ebx_756 = ebx_421 + edi;
					if (edx_765 == 0x01 && *((word32) eax_764 + 0x006C) != 0x00)
						((word32) eax_764 + 8)->u0 = ~0x0521;
					ebxOut = ebx_756;
					esiOut = esi_148;
					ediOut = edi;
					return edx_765;
				}
			}
			runtime.nextFreeFast(gs, *((word32) eax_143 + 40));
			eax_228 = dwLoc4C;
			if (dwLoc4C != 0x00)
				cl_484 = 0x00;
			else
			{
				runtime.(*mcache).nextFree(gs, eax_143, 0x05);
				eax_228 = dwLoc48;
				cl_484 = bLoc40;
			}
			*eax_228 = 0x00;
			*((word32) eax_228 + 4) = 0x00;
			((word32) eax_228 + 8)->u0 = 0x00;
			((word32) eax_228 + 0x0C)->u0 = 0x00;
			if (dwArg04 < *((word32) eax_143 + 0x0C) || *((word32) eax_143 + 8) == 0x00)
			{
				*((word32) eax_143 + 8) = eax_228;
				*((word32) eax_143 + 0x0C) = dwArg04;
			}
			dwArg04_847.u0 = 0x10;
		}
		else
		{
			word32 edx_1262;
			if (dwArg04 <= 1016)
			{
				if ((word32) dwArg04 + 7 >> 0x03 >= 0x81)
					runtime.panicindex(gs);
				edx_1262 = (word32) ((word32) dwArg04 + 7 >> 0x03)->b8138640;
			}
			else
			{
				if (dwArg04 - 0x0381 >> 0x07 >= 0xF9)
					runtime.panicindex(gs);
				edx_1262 = (word32) (dwArg04 - 0x0381 >> 0x07)->b81396E0;
			}
			edi = (word32) (byte) edx_1262;
			if (edi >= 0x43)
				runtime.panicindex(gs);
			Eq_4 ecx_285 = (word32) g_a8138820[edi * 0x02];
			byte dl_315 = (byte) edx_1262 << 0x01 | (byte) esi_148;
			dwArg04_847 = ecx_285;
			uint32 ecx_316 = (word32) dl_315;
			if (ecx_316 >= 0x86)
				runtime.panicindex(gs);
			uip32 edx_1260;
			Eq_4 ecx_345;
			Eq_4 ecx_324 = *((word32) eax_143 + (ecx_316 * 0x04 + 20));
			runtime.nextFreeFast(gs, ecx_324);
			Eq_4 eax_331 = dwLoc4C;
			if (dwLoc4C != 0x00)
			{
				ecx_345 = ecx_324;
				edx_1260 = 0x00;
			}
			else
			{
				runtime.(*mcache).nextFree(gs, eax_143, dl_315);
				eax_331 = dwLoc48;
				ecx_345 = dwLoc44;
				edx_1260 = (word32) bLoc40;
			}
			byte dl_366 = (byte) edx_1260;
			uip32 edx_381 = edx_1260;
			if (bArg0C != 0x00)
			{
				edx_381 = edx_1260;
				if (*((word32) ecx_345 + 61) != 0x00)
				{
					edi = runtime.memclrNoHeapPointers(eax_331, ecx_285);
					edx_381 = (word32) dl_366;
				}
			}
			eax_228 = eax_331;
			cl_484 = (byte) edx_381;
		}
	}
	else
	{
		word32 edi_1275;
		word32 ebp_1274;
		runtime.systemstack(gs, fp - 0x10, out ebp_1274, out edi_1275);
		((union Eq_4 *) 0x18)->u0 = 0x01;
		((union Eq_4 *) 0x38)->u2 = 0x01;
		dwArg04_847 = *(union Eq_4 *) 0x40;
		eax_228 = *(union Eq_4 *) 0x0C;
		cl_484 = 0x01;
	}
	Eq_4 ebp_563;
	uint32 edx_559;
	ptr32 esi_1206 = esi_148;
	if (al_180 != 0x00)
	{
		edx_559 = 0x00;
		ebp_563 = dwArg04;
	}
	else
	{
		Eq_4 edx_502;
		if (runtime.deferType == dwArg08)
			edx_502.u0 = 0x1C;
		else
			edx_502 = dwArg04;
		uint32 ecx_537;
		runtime.heapBitsSetType(gs, eax_228, dwArg04_847, edx_502, dwArg08);
		Eq_4 ecx_533 = *dwArg08;
		if (edx_502 > ecx_533)
		{
			uint32 ebx_539 = *((word32) dwArg08 + 4);
			if (ebx_539 != 0x00)
				ecx_537 = edx_502 - ecx_533 + ebx_539;
			else
				ecx_537 = 0x00;
		}
		else
			ecx_537 = (uint32) *((word32) dwArg08 + 4);
		esi_1206 = (word32) *((word32) eax_143 + 4) + ecx_537;
		*((word32) eax_143 + 4) = esi_1206;
		ebp_563 = edx_502;
		edx_559 = ecx_537;
	}
	runtime.publicationBarrier();
	if (runtime.gcphase != 0x00)
		runtime.gcmarknewobject(gs, dwArg04_847, edx_559);
	((word32) ecx_108 + 0x0068)->u0 = 0x00;
	Eq_4 edx_1189 = *((word32) ecx_108 + 0x0078);
	Eq_4 ecx_609 = gs->ptr0000->tFFFFFFFC;
	*((word32) ecx_108 + 0x0078) = edx_1189 - 0x01;
	word24 ebx_24_8_634 = SLICE(edx_1189 - 0x01, word24, 8);
	byte bl_1147 = (byte) edx_1189 - 0x01;
	if (edx_1189 == 0x01 && *((word32) ecx_609 + 0x006C) != 0x00)
		((word32) ecx_609 + 8)->u0 = ~0x0521;
	if (g_dw8157720 != 0x00)
		edx_1189 = runtime.tracealloc(gs, dwArg08);
	Eq_4 eax_642 = runtime.MemProfileRate;
	Eq_4 ebx_1265 = SEQ(ebx_24_8_634, bl_1147);
	if (eax_642 <= 0x00)
	{
l08054A20:
		ebp_563 = ebx_1265;
		if (edx_186 != 0x00)
		{
			Eq_13922 ecx_707 = *((byte) edx_186.u0 + 0x00CC) - (dwArg04_847 - ebp_563);
			Eq_4 edx_709 = *((byte) edx_186.u0 + 0x00D0);
			*((byte) edx_186.u0 + 0x00CC) = ecx_707;
			edx_1189 = edx_709 - (ecx_707 < 0x00);
			*((byte) edx_186.u0 + 0x00D0) = edx_1189;
		}
		if (cl_484 != 0x00)
		{
			edx_1189 = runtime.gcTrigger.test(edx_1189, gs, 0x01, 0x00);
			if (bLoc40 != 0x00)
			{
				word32 esi_1276;
				edx_1189 = runtime.gcStart(gs, 0x00, 0x01, 0x00, 0x00, out esi_1276);
			}
		}
		ebxOut = ebp_563;
		esiOut = esi_1206;
		ediOut = edi;
		return edx_1189;
	}
	else
	{
		if (dwArg04_847 < eax_642)
		{
			Eq_4 edx_650 = *eax_143;
			if (dwArg04_847 < edx_650)
			{
				edx_1189 = edx_650 - dwArg04_847;
				*eax_143 = edx_1189;
				ebx_1265 = SEQ(ebx_24_8_634, bl_1147);
				goto l08054A20;
			}
		}
		Eq_4 eax_658 = gs->ptr0000->tFFFFFFFC;
		Eq_4 ecx_659 = *((word32) eax_658 + 24);
		*((word32) ecx_659 + 0x0078) = (word32) *((word32) ecx_659 + 0x0078) + 1;
		Eq_4 eax_664 = *((word32) eax_658 + 24);
		runtime.profilealloc(gs, eax_664);
		edx_1189 = *((word32) eax_664 + 0x0078);
		Eq_4 eax_681 = gs->ptr0000->tFFFFFFFC;
		*((word32) eax_664 + 0x0078) = edx_1189 - 0x01;
		word24 ebx_24_8_728 = SLICE(edx_1189 - 0x01, word24, 8);
		byte bl_1148 = (byte) edx_1189 - 0x01;
		ebx_1265 = SEQ(ebx_24_8_728, bl_1148);
		if (edx_1189 == 0x01)
		{
			ebx_1265 = SEQ(ebx_24_8_728, bl_1148);
			if (*((word32) eax_681 + 0x006C) != 0x00)
			{
				((word32) eax_681 + 8)->u0 = ~0x0521;
				ebx_1265 = SEQ(ebx_24_8_728, bl_1148);
			}
		}
		goto l08054A20;
	}
}

// 08054E90: void runtime.largeAlloc(Register Eq_4 esi, Register (ptr32 Eq_2) gs, Register Eq_662 xmm1, Stack uint32 dwArg04, Stack Eq_4 bArg08)
// Called from:
//      runtime.mallocgc.func1
void runtime.largeAlloc(Eq_4 esi, struct Eq_2 * gs, Eq_662 xmm1, uint32 dwArg04, Eq_4 bArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (dwArg04 + 0x2000 < dwArg04)
		runtime.throw(gs);
	else
	{
		uint32 eax_31 = dwArg04 >> 0x0D;
		if ((dwArg04 & 0x1FFF) != 0x00)
			eax_31 = (dwArg04 >> 0x0D) + 0x01;
		Eq_4 esi_58 = runtime.deductSweepCredit(esi, gs, xmm1, eax_31 << 0x0D, eax_31);
		runtime.(*mheap).alloc(gs, bArg08);
		if (dwLoc10 == null)
			runtime.throw(gs);
		else
		{
			dwLoc10->dw0050 = (word32) dwLoc10->t000C + dwArg04;
			runtime.heapBitsForSpan(esi_58, gs, dwLoc10->t000C);
			runtime.heapBits.initSpan(esi_58, gs, eax_31, dwLoc10);
		}
	}
}

// 08054FA0: void runtime.newobject(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      runtime.makechan
//      runtime.(*hmap).newoverflow
//      runtime.makemap
//      runtime.mapassign
//      runtime.mapiterinit
//      runtime.hashGrow
//      reflect.mapiterinit
//      runtime.getitab
//      runtime.additab
//      runtime.panicdottypeE
//      runtime.assertE2I
//      reflect.unsafe_New
//      runtime.gcBgMarkWorker
//      runtime.acquireSudog
//      runtime.mcommoninit
//      runtime.allocm
//      runtime.malg
//      runtime.procresize
//      syscall.runtime_envs
//      os.runtime_args
//      reflect.typelinks
//      runtime.CallersFrames
//      runtime.modulesinit
//      runtime.traceGoCreate
//      errors.New
//      sync.(*Map).Store
//      sync.(*Map).LoadOrStore
//      sync.(*entry).tryLoadOrStore
//      sync.poolCleanup
//      sync.init
//      internal/poll.(*pollDesc).wait
//      os.(*File).Write
//      os.Readlink
//      os.newFile
//      os.(*file).close
//      reflect.makeMethodValue
//      reflect.(*rtype).Method
//      reflect.(*structType).Field
//      reflect.(*rtype).ptrTo
//      reflect.FuncOf
//      reflect.funcLayout
//      reflect.flag.mustBe
//      reflect.flag.mustBeAssignable
//      reflect.methodReceiver
//      reflect.Value.Complex
//      reflect.Value.Elem
//      reflect.Value.Field
//      reflect.Value.Float
//      reflect.Value.Index
//      reflect.Value.Int
//      reflect.Value.CanInterface
//      reflect.valueInterface
//      reflect.Value.IsNil
//      reflect.Value.Len
//      reflect.Value.NumMethod
//      reflect.Value.Pointer
//      reflect.Value.Slice
//      reflect.Value.Type
//      reflect.Value.Uint
//      fmt.glob..func1
void runtime.newobject(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	word32 ebx_44;
	word32 esi_45;
	word32 edi_46;
	runtime.mallocgc(ebx, gs, *dwArg04, dwArg04, 0x01, out ebx_44, out esi_45, out edi_46);
}

// 08054FE0: void reflect.unsafe_New(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      reflect.packEface
//      reflect.Value.MapIndex
//      reflect.Value.MapKeys
//      reflect.Zero
//      reflect.New
//      reflect.Value.assignTo
//      reflect.makeInt
//      reflect.makeFloat
//      reflect.makeComplex
//      reflect.cvtDirect
//      reflect.cvtT2I
//      reflect.funcLayout.func1
void reflect.unsafe_New(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.newobject(gs, dwArg04);
}

// 08055020: Register word32 runtime.newarray(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Register out ptr32 ediOut)
// Called from:
//      runtime.makechan
//      runtime.mapassign
//      runtime.makeBucketArray
//      runtime.mapassign_fast32
//      runtime.mapassign_fast64
//      runtime.mapassign_faststr
word32 runtime.newarray(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, ptr32 & ediOut)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (dwArg08 >= 0x00)
	{
		Eq_4 eax_29;
		Eq_4 ebx_22 = *dwArg04;
		if (ebx_22 < 33)
			eax_29 = *((char *) g_a81386E0 + ebx_22 * 0x04);
		else
			eax_29 = (uint32) (0xFFFFFFFF /u ebx_22);
		if (dwArg08 <= eax_29)
		{
			Eq_4 ebx_59 = ebx_22 *s dwArg08;
			ptr32 edi_69;
			word32 esi_71;
			word32 ebx_102;
			runtime.mallocgc(ebx_59, gs, ebx_59, dwArg04, 0x01, out ebx_102, out esi_71, out edi_69);
			ediOut = edi_69;
			return esi_71;
		}
	}
	runtime.gopanic(gs);
}

// 080550B0: void runtime.profilealloc(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      runtime.mallocgc
void runtime.profilealloc(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.nextSample(gs);
	**((word32) dwArg04 + 0x00B8) = dwLoc08;
	runtime.mProf_Malloc(gs, dwArg08);
}

// 08055100: void runtime.nextSample(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.profilealloc
//      runtime.allocmcache
void runtime.nextSample(struct Eq_2 * gs)
{
	word32 dwLoc30_177 = SLICE(rLoc34, word32, 32);
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 eax_17 = runtime.MemProfileRate;
	if (eax_17 <= 0x07000000 && eax_17 == 0x00)
		return;
	Eq_4 ecx_33 = *((word32) gs->ptr0000->tFFFFFFFC + 24);
	int32 edx_34 = *((word32) ecx_33 + 0x0094);
	*((word32) ecx_33 + 0x0094) = edx_34 << 0x01 ^ edx_34 >> 0x1F & 0xA8888EEF;
	runtime.uint32tofloat64();
	uint32 dwLoc1C_165 = SLICE((real64) (uint128) rLoc34, word32, 32);
	uint32 ecx_61 = dwLoc1C_165 >> 0x0F & 0x1F;
	ui32 eax_56 = dwLoc1C_165 >> 0x14 & 0x07FF;
	if (SLICE(cond(ecx_61 + 0x01), bool, 1) == false)
	{
		real64 rLoc30_178 = SEQ(dwLoc2C, dwLoc30_177);
		if (ecx_61 < 0x20)
		{
			real64 rLoc08_170 = (real64) (uint128) g_a8139C00[ecx_61 * 0x08];
			real64 rLoc10_171 = (real64) (uint128) g_a8139C00[(ecx_61 + 0x01) * 0x08];
			runtime.int64tofloat64(ebx_24_8, gs, eax_56 + ~0x03FE);
			runtime.uint64tofloat64(gs, 0x00);
			uint128 xmm1_117 = (uint128) rLoc08_170;
			Eq_662 xmm1_136 = (uint128) g_r80F1878;
		}
	}
	runtime.panicindex(gs);
}

// 080552C0: Register Eq_4 runtime.persistentalloc(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.getitab
//      runtime.mallocgc
//      runtime.progToPointerMask
//      runtime.queuefinalizer
//      runtime.(*fixalloc).alloc
//      runtime.(*gcSweepBuf).push
//      runtime.newBucket
//      runtime.(*pollCache).alloc
Eq_4 runtime.persistentalloc(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	fn0808FD8B(0x00, fp - 0x14);
	word32 ebp_61;
	word32 edi_62;
	runtime.systemstack(gs, fp - 0x14, out ebp_61, out edi_62);
	return <invalid>;
}

// 08055340: void runtime.persistentalloc1(Register Eq_4 esi, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C)
// Called from:
//      runtime.persistentalloc.func1
void runtime.persistentalloc1(Eq_4 esi, struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 0x0C))
		runtime.morestackc();
	if (dwArg04 == 0x00)
		runtime.throw(gs);
	Eq_4 ecx_31 = dwArg08;
	if (dwArg08 != 0x00)
	{
		if ((dwArg08 & dwArg08 - 0x01) != 0x00)
			runtime.throw(gs);
		if (dwArg08 > 0x2000)
			runtime.throw(gs);
	}
	else
		ecx_31.u0 = 0x08;
	if (dwArg04 >= 0x00010000)
	{
		runtime.sysAlloc();
		return;
	}
	Eq_4 ebx_122;
	Eq_4 edx_86 = gs->ptr0000->tFFFFFFFC;
	Eq_4 ebx_87 = *((word32) edx_86 + 24);
	*((word32) ebx_87 + 0x0078) = (word32) *((word32) ebx_87 + 0x0078) + 1;
	Eq_4 edx_91 = *((word32) edx_86 + 24);
	if (edx_91 != 0x00)
	{
		Eq_4 ebx_96 = *((word32) edx_91 + 92);
		if (ebx_96 != 0x00)
		{
			ebx_122 = (word32) ebx_96 + 0x0938;
l080553D0:
			uint32 ecx_135 = ~(ecx_31 - 0x01) & (word32) (*((word32) ebx_122 + 4)) + (ecx_31 - 0x01);
			*((word32) ebx_122 + 4) = ecx_135;
			if ((word32) dwArg04 + ecx_135 > 0x00040000 || *ebx_122 == 0x00)
			{
				runtime.sysAlloc();
				if (g_t81576F0 == 0x00)
					*ebx_122 = dwLoc18;
				else
					runtime.writebarrierptr(ebx_122, dwLoc18);
				if (dwLoc18 == 0x00)
				{
					if (ebx_122 == 0x0814514C)
					{
						word32 ebx_416;
						word32 edx_415;
						runtime.unlock(gs, 0x08145148, out edx_415, out ebx_416);
					}
					runtime.throw(gs);
				}
				*((word32) ebx_122 + 4) = 0x00;
			}
			Mem225[ebx_122 + 0x04:word32] = dwArg04 + Mem218[ebx_122 + 0x04:word32];
			Eq_4 edx_228 = gs->ptr0000->tFFFFFFFC;
			Eq_4 esi_230 = *((word32) edx_91 + 0x0078);
			*((word32) edx_91 + 0x0078) = esi_230 - 0x01;
			if (esi_230 == 0x01 && *((word32) edx_228 + 0x006C) != 0x00)
				((word32) edx_228 + 8)->u0 = ~0x0521;
			if (ebx_122 == 0x0814514C)
			{
				word32 edx_413;
				word32 ebx_414;
				runtime.unlock(gs, 0x08145148, out edx_413, out ebx_414);
			}
			if (dwArg0C != 0x08158220)
			{
				runtime.mSysStatInc(dwArg0C, dwArg04);
				Eq_4 esp_281 = <invalid>;
				esp_281->u0 = 0x08158220;
				*((word32) esp_281 + 4) = *((word32) esp_281 + 36);
				runtime.mSysStatDec(*esp_281, *((word32) esp_281 + 4));
			}
			return;
		}
	}
	word32 esi_411;
	word32 edi_412;
	runtime.lock(esi, gs, 0x08145148, out esi_411, out edi_412);
	ebx_122.u0 = 0x0814514C;
	goto l080553D0;
}

// 080555E0: void runtime.gcmarkwb_m(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
// Called from:
//      runtime.writebarrierptr_prewrite1.func1
void runtime.gcmarkwb_m(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 0x0C))
		runtime.morestackc();
	if (g_b81576F4 == 0x00)
		return;
	if (dwArg04 >= 0x1000)
	{
		Eq_4 eax_27 = *dwArg04;
		if (eax_27 != 0x00)
			runtime.shade(gs, eax_27);
	}
	if (dwArg08 == 0x00)
		return;
	Eq_4 ecx_49 = g_t81493A8;
	if (dwArg08 < ecx_49 || dwArg08 >= g_t81493AC)
		return;
	Eq_4 edx_55 = g_t8149108;
	uint32 eax_58 = dwArg08 - ecx_49;
	if (eax_58 >> 0x0D >= g_t814910C)
		runtime.panicindex(gs);
	else
	{
		struct Eq_15113 * eax_63 = *((word32) edx_55 + (eax_58 >> 0x0D) * 0x04);
		if (eax_63 != null && (dwArg08 >= eax_63->t000C && (dwArg08 < eax_63->t0050 && eax_63->b003C == 0x01)))
			runtime.shade(gs, dwArg08);
	}
}

// 080556A0: void runtime.writebarrierptr_prewrite1(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.writebarrierptr
//      runtime.writebarrierptr_prewrite
//      runtime.bulkBarrierPreWrite
//      runtime.bulkBarrierBitmap
void runtime.writebarrierptr_prewrite1(struct Eq_2 * gs)
{
	Eq_4 eax_8 = gs->ptr0000->tFFFFFFFC;
	Eq_4 ecx_9 = *((word32) eax_8 + 24);
	*((word32) ecx_9 + 0x0078) = (word32) *((word32) ecx_9 + 0x0078) + 1;
	Eq_4 ecx_13 = *((word32) eax_8 + 24);
	if (*((word32) ecx_13 + 0x008E) == 0x00 && *((word32) ecx_13 + 0x0080) <= 0x00)
	{
		word32 ebp_113;
		word32 edi_114;
		runtime.systemstack(gs, fp - 0x10, out ebp_113, out edi_114);
		*((word32) ecx_13 + 0x008E) = 0x00;
		Eq_4 ecx_41 = gs->ptr0000->tFFFFFFFC;
		Eq_4 edx_42 = *((word32) ecx_13 + 0x0078);
		*((word32) ecx_13 + 0x0078) = edx_42 - 0x01;
		if (edx_42 == 0x01 && *((word32) ecx_41 + 0x006C) != 0x00)
			((word32) ecx_41 + 8)->u0 = ~0x0521;
	}
	else
	{
		Eq_4 eax_59 = gs->ptr0000->tFFFFFFFC;
		Eq_4 edx_61 = *((word32) ecx_13 + 0x0078);
		*((word32) ecx_13 + 0x0078) = edx_61 - 0x01;
		if (edx_61 == 0x01 && *((word32) eax_59 + 0x006C) != 0x00)
			((word32) eax_59 + 8)->u0 = ~0x0521;
	}
}

// 08055770: void runtime.writebarrierptr(Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
// Called from:
//      runtime.alginit
//      runtime.cgocall
//      runtime.makechan
//      runtime.chansend
//      runtime.send
//      runtime.closechan
//      runtime.chanrecv
//      runtime.recv
//      runtime.(*waitq).dequeue
//      runtime.(*hmap).newoverflow
//      runtime.makemap
//      runtime.mapassign
//      runtime.mapiterinit
//      runtime.mapiternext
//      runtime.makeBucketArray
//      runtime.hashGrow
//      runtime.evacuate
//      runtime.mapassign_fast32
//      runtime.mapassign_fast64
//      runtime.mapassign_faststr
//      runtime.getitab
//      runtime.additab
//      runtime.panicdottypeE
//      runtime.convT2Estring
//      runtime.convT2Eslice
//      runtime.assertE2I
//      reflect.ifaceE2I
//      runtime.persistentalloc1
//      runtime.queuefinalizer
//      runtime.runfinq
//      runtime.gcMarkDone
//      runtime.gcMarkTermination
//      runtime.gcBgMarkWorker
//      sync.runtime_registerPoolCleanup
//      runtime.clearpools
//      runtime.markrootFreeGStacks
//      runtime.gcAssistAlloc
//      runtime.gcAssistAlloc1
//      runtime.bgsweep
//      runtime.recordspan
//      runtime.(*mheap).init
//      runtime.addfinalizer
//      runtime.stkbucket
//      internal/poll.runtime_pollUnblock
//      runtime.sysauxv
//      runtime.mpreinit
//      runtime.deferproc
//      runtime.init.2
//      runtime.newdefer
//      runtime.freedefer
//      runtime.deferreturn
//      runtime.preprintpanics
//      runtime.gopanic
//      runtime.startpanic_m
//      runtime.main
//      runtime.forcegchelper
//      runtime.gopark
//      runtime.acquireSudog
//      runtime.releaseSudog
//      runtime.allgadd
//      runtime.schedinit
//      runtime.mcommoninit
//      runtime.stopTheWorld
//      runtime.startTheWorld
//      runtime.forEachP
//      runtime.allocm
//      runtime.oneNewExtraM
//      runtime.execute
//      runtime.park_m
//      runtime.goexit0
//      runtime.newproc1
//      runtime.gfput
//      runtime.gfget
//      runtime.gfpurge
//      runtime.unlockOSThread
//      runtime.procresize
//      runtime.(*randomOrder).reset
//      runtime.args
//      runtime.goargs
//      runtime.goenvs_unix
//      reflect.typelinks
//      reflect.addReflectOff
//      runtime.(*semaRoot).queue
//      runtime.(*semaRoot).dequeue
//      runtime.(*semaRoot).rotateLeft
//      runtime.(*semaRoot).rotateRight
//      runtime.newstack
//      runtime.CallersFrames
//      runtime.(*Frames).Next
//      runtime.(*pcExpander).init
//      runtime.(*pcExpander).next
//      runtime.modulesinit
//      runtime.deltimer
//      runtime.timerproc
//      runtime.siftupTimer
//      runtime.siftdownTimer
//      runtime.typelinksinit
//      runtime.persistentalloc.func1
//      runtime.typedslicecopy.func1
//      runtime.markroot.func1
//      runtime.newdefer.func1
//      runtime.newdefer.func2
//      runtime.freedefer.func1
//      errors.New
//      strconv.init
//      sync.(*Map).Store
//      sync.(*Map).LoadOrStore
//      sync.(*entry).tryLoadOrStore
//      sync.(*Map).missLocked
//      sync.(*Map).dirtyLocked
//      sync.(*Pool).Put
//      sync.(*Pool).Get
//      sync.(*Pool).pinSlow
//      sync.poolCleanup
//      sync.init
//      io.init
//      syscall.init
//      time.init
//      internal/poll.(*pollDesc).wait
//      internal/poll.init
//      os.(*File).Write
//      os.Readlink
//      os.newFile
//      os.(*file).close
//      os.init.0
//      os.init
//      unicode.init
//      reflect.makeMethodValue
//      reflect.(*rtype).Method
//      reflect.(*structType).FieldByNameFunc
//      reflect.(*rtype).ptrTo
//      reflect.typesByString
//      reflect.FuncOf
//      reflect.funcLayout
//      reflect.addTypeBits
//      reflect.flag.mustBe
//      reflect.flag.mustBeAssignable
//      reflect.methodReceiver
//      reflect.callMethod
//      reflect.Value.Complex
//      reflect.Value.Elem
//      reflect.Value.Field
//      reflect.Value.Float
//      reflect.Value.Index
//      reflect.Value.Int
//      reflect.Value.CanInterface
//      reflect.valueInterface
//      reflect.Value.IsNil
//      reflect.Value.Len
//      reflect.Value.MapKeys
//      reflect.Value.NumMethod
//      reflect.Value.Pointer
//      reflect.Value.SetBytes
//      reflect.Value.setRunes
//      reflect.Value.SetString
//      reflect.Value.Slice
//      reflect.Value.Type
//      reflect.Value.Uint
//      reflect.ValueOf
//      reflect.Value.assignTo
//      reflect.cvtT2I
//      reflect.FuncOf.func1
//      reflect.init
//      fmt.(*fmt).writePadding
//      fmt.(*fmt).pad
//      fmt.(*fmt).padString
//      fmt.(*fmt).fmt_sbx
//      fmt.(*fmt).fmt_float
//      fmt.(*buffer).WriteRune
//      fmt.newPrinter
//      fmt.(*pp).free
//      fmt.(*pp).Write
//      fmt.(*pp).unknownType
//      fmt.(*pp).badVerb
//      fmt.(*pp).fmtComplex
//      fmt.(*pp).fmtBytes
//      fmt.(*pp).fmtPointer
//      fmt.(*pp).catchPanic
//      fmt.(*pp).printArg
//      fmt.(*pp).printValue
//      fmt.(*pp).doPrintln
//      fmt.init
void runtime.writebarrierptr(Eq_4 dwArg04, Eq_4 dwArg08)
{
	if (g_b81576F5 != 0x00)
		runtime.cgoCheckWriteBarrier(gs);
	if (g_b81576F4 == 0x00)
		*dwArg04 = dwArg08;
	else
	{
		if (dwArg08 != 0x00 && dwArg08 < 0x1000)
		{
			word32 ebp_100;
			word32 edi_101;
			runtime.systemstack(gs, fp - 0x0C, out ebp_100, out edi_101);
		}
		runtime.writebarrierptr_prewrite1(gs);
		*dwArg04 = dwArg08;
	}
}

// 08055810: void runtime.writebarrierptr_prewrite(Stack Eq_4 dwArg08)
// Called from:
//      runtime.atomicstorep
//      runtime.casp
//      sync/atomic.StorePointer
//      sync/atomic.CompareAndSwapPointer
//      runtime.typeBitsBulkBarrier
//      runtime.gogo
void runtime.writebarrierptr_prewrite(Eq_4 dwArg08)
{
	if (g_b81576F5 != 0x00)
		runtime.cgoCheckWriteBarrier(gs);
	if (g_b81576F4 == 0x00)
		return;
	if (dwArg08 != 0x00 && dwArg08 < 0x1000)
	{
		word32 ebp_82;
		word32 edi_83;
		runtime.systemstack(gs, 0x080E7D04, out ebp_82, out edi_83);
	}
	runtime.writebarrierptr_prewrite1(gs);
}

// 08055880: Register word32 runtime.typedmemmove(Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C, Register out Eq_2971 esiOut, Register out ptr32 ediOut, Register out Eq_2973 xmm0Out, Register out Eq_2974 xmm1Out)
// Called from:
//      runtime.chansend
//      runtime.chanrecv
//      runtime.recv
//      runtime.mapassign
//      runtime.mapiterinit
//      runtime.evacuate
//      runtime.mapassign_fast32
//      runtime.mapassign_fast64
//      runtime.convT2E
//      reflect.typedmemmove
//      runtime.growslice
//      runtime.expandCgoFrames
//      runtime.typedslicecopy.func1
//      reflect.(*rtype).ptrTo
//      reflect.FuncOf
word32 runtime.typedmemmove(Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C, union Eq_2971 & esiOut, ptr32 & ediOut, union Eq_2973 & xmm0Out, union Eq_2974 & xmm1Out)
{
	if ((*((word32) dwArg04 + 0x0F) & 0x80) == 0x00)
		runtime.bulkBarrierPreWrite(gs, dwArg08, dwArg0C, *dwArg04);
	ptr32 edi_35;
	Eq_2971 esi_36;
	word32 ebp_39;
	Eq_2973 xmm0_41;
	Eq_2974 xmm1_42;
	word128 xmm2_121;
	runtime.memmove(dwArg08, dwArg0C, *dwArg04, out ebp_39, out esi_36, out edi_35, out xmm0_41, out xmm1_42, out xmm2_121);
	if (g_b81576F5 != 0x00)
		runtime.cgoCheckMemmove(dwArg04);
	esiOut = esi_36;
	ediOut = edi_35;
	xmm0Out = xmm0_41;
	xmm1Out = xmm1_42;
	return ebp_39;
}

// 08055910: Register word128 reflect.typedmemmove(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C, Register out Eq_15339 xmm1Out)
// Called from:
//      reflect.packEface
//      reflect.Value.MapIndex
//      reflect.Value.MapKeys
//      reflect.cvtDirect
word128 reflect.typedmemmove(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C, union Eq_15339 & xmm1Out)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	word128 xmm0_32;
	Eq_15339 xmm1_33;
	word32 esi_63;
	word32 edi_64;
	runtime.typedmemmove(dwArg04, dwArg08, dwArg0C, out esi_63, out edi_64, out xmm0_32, out xmm1_33);
	xmm1Out = xmm1_33;
	return xmm0_32;
}

// 08055950: void reflect.typedmemmovepartial(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C, Stack int32 dwArg10, Stack Eq_4 dwArg14)
// Called from:
//      reflect.callMethod
void reflect.typedmemmovepartial(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C, int32 dwArg10, Eq_4 dwArg14)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (g_b81576F4 != 0x00 && (*((word32) dwArg04 + 0x0F) & 0x80) == 0x00)
	{
		Eq_4 ecx_31 = dwArg14;
		if (dwArg14 >= 0x04)
		{
			Eq_4 eax_42;
			Eq_4 edi_41;
			ui32 edx_35 = -dwArg10;
			if ((edx_35 & 0x03) != 0x00)
			{
				ecx_31 = dwArg14 - (edx_35 & 0x03);
				edi_41 = (word32) dwArg08 + (edx_35 & 0x03);
				eax_42 = (word32) dwArg0C + (edx_35 & 0x03);
			}
			else
			{
				edi_41 = dwArg08;
				eax_42 = dwArg0C;
			}
			runtime.bulkBarrierPreWrite(gs, edi_41, eax_42, ecx_31 & ~0x03);
		}
	}
	word128 xmm2_188;
	word128 xmm1_187;
	word128 xmm0_186;
	word32 edi_185;
	word32 esi_184;
	word32 ebp_183;
	runtime.memmove(dwArg08, dwArg0C, dwArg14, out ebp_183, out esi_184, out edi_185, out xmm0_186, out xmm1_187, out xmm2_188);
	if (g_b81576F5 != 0x00)
		runtime.cgoCheckMemmove(dwArg04);
}

// 08055A50: void runtime.reflectcallmove(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_15434) dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C, Stack Eq_4 dwArg10)
// Called from:
//      callRet
void runtime.reflectcallmove(struct Eq_2 * gs, struct Eq_15434 * dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C, Eq_4 dwArg10)
{
	if (g_b81576F4 != 0x00 && (dwArg04 != null && ((dwArg04->b000F & 0x80) == 0x00 && dwArg10 >= 0x04)))
		runtime.bulkBarrierPreWrite(gs, dwArg08, dwArg0C, dwArg10);
	word32 ebp_93;
	word32 esi_94;
	word32 edi_95;
	word128 xmm0_96;
	word128 xmm1_97;
	word128 xmm2_98;
	runtime.memmove(dwArg08, dwArg0C, dwArg10, out ebp_93, out esi_94, out edi_95, out xmm0_96, out xmm1_97, out xmm2_98);
}

// 08055AD0: Register Eq_4 runtime.typedslicecopy(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C, Stack Eq_4 dwArg14, Stack Eq_4 dwArg18, Register out ptr32 esiOut, Register out ptr32 ediOut)
// Called from:
//      runtime.recordspan
//      syscall.runtime_envs
//      os.runtime_args
Eq_4 runtime.typedslicecopy(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C, Eq_4 dwArg14, Eq_4 dwArg18, ptr32 & esiOut, ptr32 & ediOut)
{
	Eq_4 edx_11 = dwArg18;
	if (dwArg0C <= dwArg18)
		edx_11 = dwArg0C;
	if (edx_11 == 0x00)
	{
		esiOut = esi;
		ediOut = edi;
		return ebx;
	}
	else
	{
		ptr32 esi_26 = (word32) g_b81576F5;
		ptr32 esi_196 = esi_26;
		if ((byte) esi_26 != 0x00)
			esi_196 = runtime.cgoCheckSliceCopy(dwArg04, dwArg08, dwArg14, edx_11);
		if (g_b81576F4 == 0x00)
		{
			ptr32 edi_80;
			ptr32 esi_81;
			word128 xmm2_253;
			word128 xmm0_251;
			word128 xmm1_252;
			word32 ebp_250;
			Eq_4 ebx_79 = runtime.memmove(dwArg08, dwArg14, *dwArg04 *s edx_11, out ebp_250, out esi_81, out edi_80, out xmm0_251, out xmm1_252, out xmm2_253);
			esiOut = esi_81;
			ediOut = edi_80;
			return ebx_79;
		}
		else
		{
			fn0808FD8B(0x00, fp - 0x14);
			ptr32 edi_125;
			word32 ebp_254;
			Eq_4 ebx_123 = runtime.systemstack(gs, fp - 0x14, out ebp_254, out edi_125);
			esiOut = esi_196;
			ediOut = edi_125;
			return ebx_123;
		}
	}
}

// 08055BF0: Register Eq_4 runtime.typedmemclr(Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
// Called from:
//      runtime.closechan
//      runtime.chanrecv
//      runtime.freedefer
Eq_4 runtime.typedmemclr(Eq_4 dwArg04, Eq_4 dwArg08)
{
	if ((*((word32) dwArg04 + 0x0F) & 0x80) == 0x00)
		runtime.bulkBarrierPreWrite(gs, dwArg08, 0x00, *dwArg04);
	return runtime.memclrNoHeapPointers(dwArg08, *dwArg04);
}

// 08055C40: Register word32 runtime.memclrHasPointers(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
// Called from:
//      runtime.evacuate
//      runtime.procresize
//      sync.poolCleanup
word32 runtime.memclrHasPointers(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08)
{
	word32 esi_20 = runtime.bulkBarrierPreWrite(gs, dwArg04, 0x00, dwArg08);
	runtime.memclrNoHeapPointers(dwArg04, dwArg08);
	return esi_20;
}

// 08055C80: void runtime.(*mheap).mapBits(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack uint32 dwArg08)
// Called from:
//      runtime.(*mheap).setArenaUsed
void runtime.(*mheap).mapBits(struct Eq_2 * gs, Eq_4 dwArg04, uint32 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 ebx_25 = runtime.physPageSize;
	uint32 ebx_29 = ~(ebx_25 - 0x01) & (word32) ebx_25 + (((dwArg08 - g_t81493A8 >> 0x04) + 0x1FFF & ~0x1FFF) - 0x01);
	if (*((word32) dwArg04 + 0x0AC4) >= ebx_29)
		return;
	runtime.sysMap(gs, *((word32) dwArg04 + 2752) - ebx_29, *((word32) dwArg04 + 2776));
	*((word32) dwArg04 + 0x0AC4) = ebx_29;
}

// 08055D30: Register ui32 runtime.(*mspan).refillAllocCache(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack uint32 dwArg08, Register out Eq_15615 esiOut)
// Called from:
//      runtime.(*mspan).nextFreeIndex
//      runtime.(*mcentral).cacheSpan
//      runtime.(*mspan).sweep
ui32 runtime.(*mspan).refillAllocCache(struct Eq_2 * gs, Eq_4 dwArg04, uint32 dwArg08, union Eq_15615 & esiOut)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	struct Eq_15628 * ecx_20 = (word32) *((word32) dwArg04 + 40) + dwArg08;
	uint32 ebx_22 = (word32) ecx_20->b0001;
	uint32 ebx_26 = (word32) ecx_20->b0002;
	uint32 edx_30 = (word32) ecx_20->b0003;
	ui32 ebx_34 = (word32) ecx_20->b0004;
	ui32 ebx_36 = (word32) ecx_20->b0005;
	ui32 ebx_38 = (word32) ecx_20->b0006;
	ui32 ecx_39 = (word32) ecx_20->b0007;
	*((word32) dwArg04 + 32) = ~(edx_30 << 0x18 | (ebx_26 << 0x10 | ((word32) ecx_20->b0000 | ebx_22 << 0x08)));
	Eq_15615 esi_44 = ebx_26 >> 0x10 | ebx_22 >> 0x18;
	*((word32) dwArg04 + 36) = ~(ebx_34 | (edx_30 >> 0x08 | esi_44) | ebx_36 << 0x08 | ebx_38 << 0x10 | ecx_39 << 0x18);
	esiOut = esi_44;
	return ebx_38 << 0x10;
}

// 08055DD0: Register Eq_4 runtime.(*mspan).nextFreeIndex(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      runtime.(*mcache).nextFree
//      runtime.(*mcentral).cacheSpan
//      runtime.(*mspan).sweep
Eq_4 runtime.(*mspan).nextFreeIndex(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 ecx_18 = *((word32) dwArg04 + 24);
	Eq_4 edx_19 = *((word32) dwArg04 + 28);
	if (edx_19 == ecx_18)
		return esi;
	if (ecx_18 > edx_19)
		runtime.throw(gs);
	else
	{
		runtime/internal/sys.Ctz64(*((word32) dwArg04 + 32), *((word32) dwArg04 + 36));
		Eq_4 ecx_156 = ecx_18;
		while (dwLoc18 == 0x40)
		{
			uint32 eax_130 = (word32) ecx_156 + 64;
			if ((eax_130 & ~0x3F) >= edx_19)
			{
				*((word32) dwArg04 + 24) = edx_19;
				return esi;
			}
			word32 esi_243;
			runtime.(*mspan).refillAllocCache(gs, dwArg04, (eax_130 & ~0x3F) >> 0x03, out esi_243);
			runtime/internal/sys.Ctz64(*((word32) dwArg04 + 32), *((word32) dwArg04 + 36));
			ecx_156 = eax_130 & ~0x3F;
		}
		if ((word32) ecx_156 + dwLoc18 >= edx_19)
		{
			*((word32) dwArg04 + 24) = edx_19;
			return esi;
		}
		else
		{
			up32 edx_70 = 0x1F - dwLoc18;
			Eq_4 edi_66 = *((word32) dwArg04 + 36);
			byte cl_84 = (byte) dwLoc18 + 0x01;
			ui32 edx_92 = 0x00 - (dwLoc18 < ~0x1E);
			*((word32) dwArg04 + 32) = edi_66 << (byte) edx_70 & 0x00 - (edx_70 < 0x20) | *((word32) dwArg04 + 32) >> cl_84 & edx_92 | edi_66 >> (byte) dwLoc18 - 0x1F & 0x00 - (dwLoc18 < 0x3F);
			Eq_4 esi_100 = edi_66 >> cl_84 & edx_92;
			*((word32) dwArg04 + 36) = esi_100;
			Eq_4 eax_103 = (word32) ecx_156 + 1 + dwLoc18;
			if ((eax_103 & 0x3F) == 0x00 && eax_103 != edx_19)
			{
				word32 esi_244;
				runtime.(*mspan).refillAllocCache(gs, dwArg04, eax_103 >> 0x03, out esi_244);
			}
			*((word32) dwArg04 + 24) = eax_103;
			return esi_100;
		}
	}
}

// 08055F70: void runtime.markBitsForAddr(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      runtime.gcmarknewobject
void runtime.markBitsForAddr(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	struct Eq_15857 * eax_38;
	if (dwArg04 != 0x00)
	{
		Eq_4 ebx_21 = g_t81493A8;
		if (dwArg04 >= ebx_21 && dwArg04 < g_t81493AC)
		{
			Eq_4 ebp_27 = g_t8149108;
			uint32 edx_30 = dwArg04 - ebx_21;
			if (edx_30 >> 0x0D >= g_t814910C)
				runtime.panicindex(gs);
			eax_38 = (struct Eq_15857 *) *((word32) ebp_27 + (edx_30 >> 0x0D) * 0x04);
l08055F97:
			if (dwArg04 - eax_38->dw000C != 0x00)
				eax_38->w0036 == 0x00;
			return;
		}
	}
	eax_38 = null;
	goto l08055F97;
}

// 08056090: void runtime.markBits.setMarked(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack ui8 bArg08)
// Called from:
//      runtime.gcmarknewobject
void runtime.markBits.setMarked(struct Eq_2 * gs, Eq_4 dwArg04, ui8 bArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime/internal/atomic.Or8(dwArg04, bArg08);
}

// 080560D0: void runtime.heapBitsForSpan(Register Eq_4 esi, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      runtime.largeAlloc
//      runtime.(*mcentral).grow
//      runtime.initCheckmarks
//      runtime.clearCheckmarks
void runtime.heapBitsForSpan(Eq_4 esi, struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 eax_17 = g_t81493A8;
	if (dwArg04 >= eax_17 && dwArg04 < g_t81493AC)
		return;
	Eq_4 eax_26 = g_t81493AC;
	runtime.printlock(gs);
	runtime.printstring(gs);
	Eq_4 esi_58;
	runtime.printhex(esi, gs, dwArg04, 0x00, out esi_58);
	runtime.printstring(gs);
	Eq_4 esi_82;
	runtime.printhex(esi_58, gs, eax_17, 0x00, out esi_82);
	runtime.printstring(gs);
	word32 esi_180;
	runtime.printhex(esi_82, gs, eax_26, 0x00, out esi_180);
	runtime.printstring(gs);
	runtime.printunlock(gs);
	runtime.throw(gs);
}

// 08056200: void runtime.heapBitsForObject(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
// Called from:
//      runtime.scanblock
//      runtime.scanobject
//      runtime.shade
//      runtime.gcMarkTinyAllocs
void runtime.heapBitsForObject(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 eax_17 = g_t81493A8;
	if (dwArg04 < eax_17 || dwArg04 >= g_t81493AC)
		return;
	uint32 edx_25 = dwArg04 - eax_17;
	Eq_4 esi_28 = g_t8149108;
	if (edx_25 >> 0x0D >= g_t814910C)
		runtime.panicindex(gs);
	else
	{
		struct Eq_15997 * ebp_35 = *((word32) esi_28 + (edx_25 >> 0x0D) * 0x04);
		if (ebp_35 != null)
		{
			esi_28 = ebp_35->t000C;
			if (dwArg04 >= esi_28 && (dwArg04 < ebp_35->t0050 && ebp_35->b003C == 0x01))
			{
				if (ebp_35->w0036 == 0x00)
					dwArg04 - esi_28 < ebp_35->dw0040;
				return;
			}
		}
		if (ebp_35 == null || ebp_35->b003C == 0x02)
			return;
		if (g_t8157744 == 0x00)
			return;
		runtime.printlock(gs);
		runtime.printlock(gs);
		runtime.printstring(gs);
		word32 esi_557;
		runtime.printhex(esi_28, gs, dwArg04, 0x00, out esi_557);
		runtime.printunlock(gs);
		if (ebp_35->b003C != 0x01)
		{
			runtime.printlock(gs);
			runtime.printstring(gs);
			runtime.printunlock(gs);
		}
		else
		{
			runtime.printlock(gs);
			runtime.printstring(gs);
			runtime.printunlock(gs);
		}
		Eq_4 ecx_220 = (word32) ebp_35->b003C;
		Eq_4 edx_222 = ebp_35->t0050;
		Eq_4 eax_224 = ebp_35->t000C;
		runtime.printlock(gs);
		runtime.printstring(gs);
		word32 esi_560;
		runtime.printhex(esi_28, gs, edx_25 >> 0x0D, 0x00, out esi_560);
		runtime.printstring(gs);
		word32 esi_561;
		runtime.printhex(esi_28, gs, eax_224, 0x00, out esi_561);
		runtime.printstring(gs);
		word32 esi_562;
		runtime.printhex(esi_28, gs, edx_222, 0x00, out esi_562);
		runtime.printstring(gs);
		runtime.printint(SLICE(dwArg04, word24, 8), gs, ecx_220);
		runtime.printstring(gs);
		runtime.printunlock(gs);
		if (dwArg08 != 0x00)
		{
			runtime.printlock(gs);
			runtime.printstring(gs);
			word32 esi_558;
			runtime.printhex(esi_28, gs, dwArg08, 0x00, out esi_558);
			runtime.printstring(gs);
			word32 esi_559;
			runtime.printhex(esi_28, gs, dwArg0C, 0x00, out esi_559);
			runtime.printstring(gs);
			runtime.printunlock(gs);
			runtime.gcDumpObject(gs, dwArg08, dwArg0C);
		}
		*((word32) *((word32) gs->ptr0000->tFFFFFFFC + 24) + 461) = 0x02;
		runtime.throw(gs);
	}
}

// 08056610: void runtime.heapBits.setCheckmarked(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C)
// Called from:
//      runtime.greyobject
void runtime.heapBits.setCheckmarked(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (dwArg0C != 0x04)
		runtime/internal/atomic.Or8(dwArg04, 0x10 << (byte) dwArg08 + 0x01 & 0x00 - (byte) (dwArg08 < 0x1F));
	else
		runtime/internal/atomic.Or8(dwArg04, 0x00 - (byte) (dwArg08 < 0x20) & 0x01 << (byte) dwArg08);
}

// 08056690: Register Eq_4 runtime.bulkBarrierPreWrite(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C)
// Called from:
//      runtime.typedmemmove
//      reflect.typedmemmovepartial
//      runtime.reflectcallmove
//      runtime.typedmemclr
//      runtime.memclrHasPointers
Eq_4 runtime.bulkBarrierPreWrite(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C)
{
	Eq_4 ebp_10 = dwArg0C;
	if (((dwArg08 | dwArg04 | dwArg0C) & 0x03) != 0x00)
		runtime.throw(gs);
	if (g_b81576F4 == 0x00)
		return esi;
	if (dwArg04 != 0x00)
	{
		Eq_4 eax_32 = g_t81493A8;
		if (dwArg04 >= eax_32)
		{
			esi = g_t81493AC;
			if (dwArg04 < esi)
			{
				esi = g_t814910C;
				Eq_4 edi_41 = g_t8149108;
				uint32 edx_43 = dwArg04 - eax_32;
				if (edx_43 >> 0x0D >= esi)
					runtime.panicindex(gs);
				struct Eq_16234 * edx_52 = *((word32) edi_41 + (edx_43 >> 0x0D) * 0x04);
				if (edx_52 != null)
				{
					esi = edx_52->t000C;
					if (dwArg04 >= esi)
					{
						esi = edx_52->t0050;
						if (dwArg04 < esi && edx_52->b003C == 0x01)
						{
							Eq_4 esi_203 = g_t81493A0 - (edx_43 >> 0x04);
							Eq_4 edx_204 = esi_203 - 0x01;
							uint32 eax_205 = edx_43 >> 0x02 & 0x03;
							if (dwArg08 == 0x00)
							{
								Eq_4 ebx_270 = 0x00;
								while (ebx_270 < ebp_10)
								{
									esi_203 = (word32) *edx_204 >> (byte) eax_205;
									if ((esi_203 & 0x01) != 0x00)
									{
										runtime.writebarrierptr_prewrite1(gs);
										ebp_10 = dwArg0C;
									}
									if (eax_205 < 0x03)
										++eax_205;
									else
									{
										esi_203 = edx_204 - 0x01;
										edx_204 = esi_203;
										eax_205 = 0x00;
									}
									ebx_270 = (word32) ebx_270 + 4;
								}
							}
							else
							{
								esi_203.u0 = 0x00;
								for (; esi_203 < ebp_10; esi_203 += 0x04)
								{
									if (((word32) *edx_204 >> (byte) eax_205 & 0x01) != 0x00)
									{
										runtime.writebarrierptr_prewrite1(gs);
										ebp_10 = dwArg0C;
									}
									if (eax_205 < 0x03)
										++eax_205;
									else
									{
										edx_204 -= (byte *) 0x01;
										eax_205 = 0x00;
									}
								}
							}
							return esi_203;
						}
					}
				}
l0805681D:
				Eq_4 eax_74 = *((word32) *((word32) gs->ptr0000->tFFFFFFFC + 24) + 84);
				if (eax_74 != 0x00 && (*eax_74 <= dwArg04 && dwArg04 < *((word32) eax_74 + 4)))
					return esi;
				runtime.activeModules();
				word32 * eax_168 = dwLoc2C;
				int32 ebx_101;
				for (ebx_101 = 0x00; ebx_101 < dwLoc28; ++ebx_101)
				{
					struct Eq_16352 * ebp_169 = *eax_168;
					esi = ebp_169->t0040;
					if (esi <= dwArg04 && dwArg04 < ebp_169->t0044)
					{
						runtime.bulkBarrierBitmap(dwArg08, dwArg0C, dwArg04 - esi, ebp_169->t00C8);
						return esi;
					}
					++eax_168;
				}
				runtime.activeModules();
				word32 * ecx_118 = dwLoc2C;
				int32 ebx_120;
				for (ebx_120 = 0x00; ebx_120 < dwLoc28; ++ebx_120)
				{
					struct Eq_16380 * ebp_132 = *ecx_118;
					esi = ebp_132->t0048;
					if (esi <= dwArg04 && dwArg04 < ebp_132->t004C)
					{
						runtime.bulkBarrierBitmap(dwArg08, dwArg0C, dwArg04 - esi, ebp_132->t00D0);
						return esi;
					}
					++ecx_118;
				}
				return esi;
			}
		}
	}
	goto l0805681D;
}

// 08056930: void runtime.bulkBarrierBitmap(Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C, Stack Eq_4 dwArg10, Stack Eq_4 dwArg14)
// Called from:
//      runtime.bulkBarrierPreWrite
//      runtime.newproc1
void runtime.bulkBarrierBitmap(Eq_4 dwArg08, Eq_4 dwArg0C, Eq_4 dwArg10, Eq_4 dwArg14)
{
	ui32 edx_13 = 0x01 << ((byte) (dwArg10 >> 0x02) & 0x07);
	byte * eax_113 = (word32) dwArg14 + (dwArg10 >> 0x05);
	Eq_4 ecx_104 = 0x00;
	while (true)
	{
		byte dl_27 = (byte) edx_13;
		if (ecx_104 >= dwArg0C)
			break;
		Eq_4 ecx_100;
		if (dl_27 == 0x00)
		{
			byte * eax_32 = eax_113 + 1;
			eax_113 = eax_32;
			if (*eax_32 == 0x00)
			{
				ecx_100 = (word32) ecx_104 + 28 + 0x04;
				goto l08056953;
			}
			edx_13 = 0x01;
		}
		byte dl_52 = (byte) edx_13;
		ui32 edx_91 = edx_13;
		if ((*eax_113 & dl_52) != 0x00)
		{
			if (dwArg08 == 0x00)
				runtime.writebarrierptr_prewrite1(gs);
			else
				runtime.writebarrierptr_prewrite1(gs);
			edx_91 = (word32) dl_52;
		}
		ecx_100 = ecx_104;
		edx_13 = edx_91 << 0x01;
l08056953:
		ecx_104 = ecx_100;
	}
}

// 080569E0: void runtime.typeBitsBulkBarrier(Register Eq_4 ebx, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg0C, Stack Eq_4 dwArg10)
// Called from:
//      runtime.sendDirect
//      runtime.recvDirect
void runtime.typeBitsBulkBarrier(Eq_4 ebx, struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg0C, Eq_4 dwArg10)
{
	word24 ebx_24_8 = SLICE(ebx, word24, 8);
	Eq_4 eax_257 = dwArg04;
	if (dwArg04 == 0x00)
		runtime.throw(gs);
	else if (dwArg10 != *dwArg04)
	{
		runtime.(*_type).string(gs, dwArg04);
		Eq_4 edx_36 = *dwArg04;
		runtime.printlock(gs);
		runtime.printstring(gs);
		runtime.printsp(gs);
		runtime.printstring(gs);
		runtime.printsp(gs);
		runtime.printstring(gs);
		runtime.printsp(gs);
		runtime.printint(ebx_24_8, gs, (uint64) edx_36);
		runtime.printsp(gs);
		runtime.printstring(gs);
		runtime.printsp(gs);
		runtime.printint(ebx_24_8, gs, (uint64) dwArg10);
		runtime.printnl(gs);
		runtime.printunlock(gs);
		runtime.throw(gs);
	}
	else if ((*((word32) dwArg04 + 0x0F) & 0x40) != 0x00)
	{
		runtime.(*_type).string(gs, dwArg04);
		runtime.printlock(gs);
		runtime.printstring(gs);
		runtime.printsp(gs);
		runtime.printstring(gs);
		runtime.printsp(gs);
		runtime.printstring(gs);
		runtime.printnl(gs);
		runtime.printunlock(gs);
		runtime.throw(gs);
	}
	else
	{
		if (g_b81576F4 == 0x00)
			return;
		Eq_4 ecx_252 = *((word32) dwArg04 + 20);
		Eq_4 edx_253 = 0x00;
		uint32 ebx_254 = 0x00;
		while (edx_253 < *((word32) eax_257 + 4))
		{
			uint32 ebx_270;
			if ((edx_253 & 0x1F) == 0x00)
			{
				ebx_270 = (word32) *ecx_252;
				ecx_252 = (word32) ecx_252 + 1;
			}
			else
				ebx_270 = ebx_254 >> 0x01;
			if ((ebx_270 & 0x01) != 0x00)
			{
				runtime.writebarrierptr_prewrite(Mem285[edx_253 + dwArg0C:word32]);
				eax_257 = dwArg04;
			}
			ebx_254 = ebx_270;
			edx_253 = (word32) edx_253 + 4;
		}
	}
}

// 08056C00: Register Eq_4 runtime.heapBits.initSpan(Register Eq_4 esi, Register (ptr32 Eq_2) gs, Stack uint32 dwArg04, Stack (ptr32 Eq_14557) dwArg0C)
// Called from:
//      runtime.largeAlloc
//      runtime.(*mcentral).grow
Eq_4 runtime.heapBits.initSpan(Eq_4 esi, struct Eq_2 * gs, uint32 dwArg04, struct Eq_14557 * dwArg0C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 eax_26;
	ui32 eax_18 = dwArg0C->dw0010;
	uint32 edx_21 = dwArg0C->dw0040;
	if (edx_21 > 0x00)
		eax_26 = (uint32) ((uint64) (eax_18 << 0x0D) /u edx_21);
	else
		eax_26.u0 = 0x00;
	dwArg0C->dw0018 = 0x00;
	dwArg0C->dw0020 = ~0x00;
	dwArg0C->dw0024 = ~0x00;
	dwArg0C->t001C = eax_26;
	dwArg0C->dw0028 = 0x00;
	dwArg0C->dw002C = 0x00;
	Eq_4 esi_58 = runtime.newMarkBits(esi, gs, dwArg0C->t001C);
	dwArg0C->dw002C = dwLoc08;
	Eq_4 esi_74 = runtime.newAllocBits(esi_58, gs, dwArg0C->t001C);
	dwArg0C->dw0028 = dwLoc08;
	if ((eax_18 << 0x0D & 0x0F) != 0x00)
		runtime.throw(gs);
	else
	{
		runtime.memclrNoHeapPointers(dwArg04 - (((eax_18 << 0x0D) >> 0x04) - 0x01), eax_18 << 0x0D >> 0x04);
		return esi_74;
	}
}

// 08056CE0: Register (ptr32 byte) runtime.heapBits.initCheckmarkSpan(Register (ptr32 Eq_2) gs, Stack (ptr32 byte) dwArg04, Stack (ptr32 byte) dwArg08, Stack (ptr32 byte) dwArg0C, Stack uint32 dwArg10)
// Called from:
//      runtime.initCheckmarks
byte * runtime.heapBits.initCheckmarkSpan(struct Eq_2 * gs, byte * dwArg04, byte * dwArg08, byte * dwArg0C, uint32 dwArg10)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	byte * ebx_19 = dwArg04;
	byte * ebp_20 = dwArg08;
	uint32 ecx_21;
	for (ecx_21 = 0x00; ecx_21 < dwArg10; ++ecx_21)
	{
		up32 edi_40 = ebp_20 + 1;
		*ebx_19 = (byte) ~(0x00 - (edi_40 < 0x20) & 0x10 << (byte) edi_40) & *ebx_19;
		uint32 ebp_70 = ebp_20 + (dwArg0C >> 0x02);
		esi = ebx_19 - (ebp_70 >> 0x02);
		ebx_19 = esi;
		ebp_20 = ebp_70 & 0x03;
	}
	return esi;
}

// 08056D70: void runtime.heapBits.clearCheckmarkSpan(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.clearCheckmarks
void runtime.heapBits.clearCheckmarkSpan(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
}

// 08056D90: void runtime.(*mspan).countAlloc(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      runtime.(*mspan).sweep
void runtime.(*mspan).countAlloc(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 ecx_17 = *((word32) dwArg04 + 28);
	uint32 ebx_20;
	for (ebx_20 = 0x00; ebx_20 < ecx_17 >> 0x03; ++ebx_20)
		;
}

// 08056E10: void runtime.heapBitsSetType(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C, Stack Eq_4 dwArg10)
// Called from:
//      runtime.mallocgc
void runtime.heapBitsSetType(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C, Eq_4 dwArg10)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	uint32 ecx_21 = dwArg04 - g_t81493A8;
	uint32 ecx_29 = ecx_21 >> 0x02 & 0x03;
	Eq_4 ebx_18 = *((word32) dwArg10 + 20);
	struct Eq_16788 * esi_26 = g_t81493A0 - (ecx_21 >> 0x04);
	byte cl_41 = (byte) ecx_29;
	if (dwArg08 == 0x08)
	{
		if (*dwArg10 != 0x04)
			esi_26->bFFFFFFFF = (*ebx_18 & 0x03 | 0x10) << cl_41 | (byte) (~(0x33 << cl_41)) & esi_26->bFFFFFFFF;
		else if (dwArg0C == 0x04)
			esi_26->bFFFFFFFF = (byte) ~(0x33 << cl_41) & esi_26->bFFFFFFFF | 0x11 << cl_41;
		else
			esi_26->bFFFFFFFF = 0x13 << cl_41 | esi_26->bFFFFFFFF;
	}
	else if ((*((word32) dwArg10 + 0x0F) & 0x40) != 0x00)
		runtime.heapBitsSetTypeGCProg(gs, esi_26 - 0x01, ecx_29, *((word32) dwArg10 + 4), *dwArg10, dwArg0C, dwArg08);
	else
	{
		Eq_16828 ecx_117;
		Eq_4 ebx_118;
		Eq_4 edx_116;
		Eq_16828 esi_122;
		uint32 ebp_121;
		Eq_4 ecx_110 = *dwArg10;
		if (ecx_110 < dwArg0C)
		{
			Eq_4 ebp_123 = *((word32) dwArg10 + 4);
			if (ebp_123 >> 0x02 <= 0x19)
			{
				uint32 dwLoc48_710 = 0x00;
				uint32 dwLoc50_712 = 0x00;
				ebx_161 = ebx_18;
				while (true)
				{
					Eq_4 ebx_161;
					if (dwLoc48_710 >= ebp_123 >> 0x02)
						break;
					ebx_161 = (word32) ebx_161 + 1;
					dwLoc48_710 += 0x08;
					dwLoc50_712 |= (word32) *ebx_161 << (byte) dwLoc48_710 & 0x00 - (dwLoc48_710 < 0x20);
				}
				ecx_117 = ecx_110 >> 0x02;
				if ((ecx_110 >> 0x02) * 0x02 <= 0x19)
				{
					uint32 ebp_192 = dwLoc50_712;
					while (true)
					{
						byte cl_200 = (byte) ecx_117;
						if (ecx_117 > 0x20)
							break;
						ebp_192 = ebp_192 << cl_200 & 0x00 - (ecx_117 < 0x20) | ebp_192;
						ecx_117 *= 0x02;
					}
					if ((byte) (ecx_110 >> 0x02) == 0x00)
						runtime.panicdivide(gs);
					Eq_16828 edx_253 = (word32) (byte) (0x00 /u (word16) ((word32) ((byte) (ecx_110 >> 0x02)))) *s (ecx_110 >> 0x02);
					ecx_117 = edx_253;
					ebp_121 = ebp_192 & (0x00 - (edx_253 < 0x20) & 0x01 << (byte) edx_253) - 0x01;
				}
				else
					ebp_121 = dwLoc50_712;
				edx_116.u0 = 0x00;
				ebx_118.u0 = 0x00;
				esi_122 = ecx_117;
			}
			else
			{
				uint32 edi_127 = (ebp_123 >> 0x02) + 0x07;
				edx_116 = ebx_18;
				ebx_118 = (word32) ebx_18 + ((edi_127 >> 0x03) - 0x01);
				ebp_121 = 0x00;
				esi_122 = (ecx_110 >> 0x02) - ((edi_127 >> 0x03) - 0x01 << 0x03);
				ecx_117.u0 = 0x00;
			}
		}
		else
		{
			edx_116 = ebx_18;
			ecx_117.u0 = 0x00;
			ebx_118.u0 = 0x00;
			ebp_121 = 0x00;
			esi_122.u0 = 0x00;
		}
		uint32 edi_279;
		if (edx_116 != 0x00)
		{
			edi_279 = (word32) *edx_116;
			edx_116 = (word32) edx_116 + 1;
			ecx_117.u0 = 0x08;
		}
		else
			edi_279 = ebp_121;
		uint32 ebp_321;
		if (dwArg0C == ecx_110)
			ebp_321 = *((word32) dwArg10 + 4) >> 0x02;
		else
		{
			if (ecx_110 == 0x00)
				runtime.panicdivide(gs);
			ebp_321 = (CONVERT(CONVERT(dwArg0C, word32, uint64) /u ecx_110, word32, uint32) - 0x01) *s ecx_110 + Mem310[dwArg10 + 0x04:word32] >>u 0x02;
		}
		Eq_4 edx_465 = edx_116;
		if (ebp_321 == 0x00)
		{
			runtime.(*_type).string(gs, dwArg10);
			runtime.printlock(gs);
			runtime.printstring(gs);
			runtime.printsp(gs);
			runtime.printstring(gs);
			runtime.printnl(gs);
			runtime.printunlock(gs);
			runtime.throw(gs);
		}
		else
		{
			uint32 eax_386;
			if (ebp_321 < 0x02)
				eax_386 = 0x02;
			else
				eax_386 = ebp_321;
			if ((ecx_21 >> 0x02 & 0x03) != 0x00)
				runtime.throw(gs);
			else
			{
				byte * edx_590;
				uint32 ecx_594;
				ui32 edi_407 = edi_279 & 0x0F;
				ui32 edi_408 = edi_407 | 0xD0;
				if (eax_386 <= 0x04)
				{
					ecx_594 = 0x04;
					edx_590 = esi_26 - 0x01;
				}
				else
				{
					esi_26->bFFFFFFFF = (byte) edi_407 | 0xD0;
					uint32 ebp_425 = edi_279 >> 0x04;
					Eq_17000 edi_431 = ecx_117 - 0x08;
					byte * esi_432 = esi_26 - 0x02;
					up32 dwLoc54_807 = 0x04;
					while (true)
					{
						uint32 esi_453;
						byte * ecx_452;
						ui32 ebp_444 = ebp_425 & 0x0F;
						ui32 ebp_445 = ebp_444 | 0xF0;
						if (dwLoc54_807 + 0x04 >= eax_386)
							break;
						Eq_17000 ecx_492;
						*esi_432 = (byte) ebp_444 | 0xF0;
						uint32 ebp_462 = ebp_425 >> 0x04;
						byte * esi_463 = esi_432 - 0x01;
						if (edx_465 != ebx_118)
						{
							if (edi_431 < 0x08)
							{
								ecx_492 = edi_431;
								ebp_462 = ebp_425 >> 0x04 | (word32) (*edx_465) << (byte) edi_431 & 0x00 - (edi_431 < 0x20);
								edx_465 = (word32) edx_465 + 1;
							}
							else
								ecx_492 = (word32) edi_431 - 8;
						}
						else
						{
							Eq_4 ebx_496;
							if (edx_465 != 0x00)
							{
								ebp_462 = ebp_425 >> 0x04 | (word32) (*edx_465) << (byte) edi_431 & 0x00 - (edi_431 < 0x20);
								word32 edi_510 = edi_431 + esi_122;
								if (edi_510 < 0x08)
								{
									ecx_492 = edi_510;
									ebp_462 |= (word32) *ebx_18 << (byte) edi_510 & 0x00 - (edi_510 < 0x20);
									ebx_496 = (word32) ebx_18 + 1;
								}
								else
								{
									ecx_492 = edi_431 - 0x08 + esi_122;
									ebx_496 = ebx_18;
								}
							}
							else
							{
								uint32 ebx_476;
								Eq_17000 esi_475;
								if (edi_431 < 0x08)
								{
									ebx_476 = ebp_121 << (byte) edi_431 & 0x00 - (edi_431 < 0x20) | ebp_425 >> 0x04;
									esi_475 = edi_431 + esi_122;
								}
								else
								{
									esi_475 = edi_431;
									ebx_476 = ebp_425 >> 0x04;
								}
								ecx_492 = esi_475 - 0x08;
								ebp_462 = ebx_476;
								ebx_496 = edx_465;
							}
							edx_465 = ebx_496;
						}
						ui32 ebp_553 = ebp_462 & 0x0F;
						ebp_445 = ebp_553 | 0xF0;
						esi_453 = dwLoc54_807 + 0x08;
						if (dwLoc54_807 + 0x08 >= eax_386)
						{
							ecx_452 = esi_463;
							goto l0805710D;
						}
						*esi_463 = (byte) ebp_553 | 0xF0;
						dwLoc54_807 += 0x08;
						edi_431 = ecx_492;
						esi_432 = esi_463 - 0x01;
						ebp_425 = ebp_462 >> 0x04;
					}
					ecx_452 = esi_432;
					esi_453 = dwLoc54_807 + 0x04;
l0805710D:
					edx_590 = ecx_452;
					edi_408 = ebp_445;
					ecx_594 = esi_453;
				}
				if (ecx_594 > eax_386)
				{
					up32 ecx_606 = -(ecx_594 - eax_386 + ~0x03);
					ui32 eax_613 = 0x01 << (byte) ecx_606 & 0x00 - (ecx_606 < 0x20);
					edi_408 &= eax_613 - 0x01 << 0x04 | eax_613 - 0x01;
				}
				ui32 ebx_635;
				uint32 ecx_633;
				if (ecx_594 <= dwArg08 >> 0x02)
				{
					*edx_590 = (byte) edi_408;
					--edx_590;
					for (ecx_633 = ecx_594 + 0x04; ecx_633 <= dwArg08 >> 0x02; ecx_633 += 0x04)
					{
						*edx_590 = 0x00;
						--edx_590;
					}
					ebx_635 = 0x00;
				}
				else
				{
					ecx_633 = ecx_594;
					ebx_635 = edi_408;
				}
				if ((dwArg08 >> 0x02) + 0x02 == ecx_633)
					*edx_590 = (byte) ebx_635 | *edx_590 & 0xCC;
			}
		}
	}
}

// 08057360: void runtime.heapBitsSetTypeGCProg(Register (ptr32 Eq_2) gs, Stack Eq_16813 dwArg04, Stack uint32 dwArg08, Stack Eq_4 dwArg0C, Stack Eq_4 dwArg10, Stack Eq_4 dwArg14, Stack Eq_4 dwArg18)
// Called from:
//      runtime.heapBitsSetType
void runtime.heapBitsSetTypeGCProg(struct Eq_2 * gs, Eq_16813 dwArg04, uint32 dwArg08, Eq_4 dwArg0C, Eq_4 dwArg10, Eq_4 dwArg14, Eq_4 dwArg18)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 eax_231;
	if (dwArg10 != dwArg14)
	{
		if (dwArg10 == 0x00)
			runtime.panicdivide(gs);
		Eq_17292 ecx_128;
		fn0808FD86(0x00, fp - 0x28);
		Eq_17301 eax_116 = (uint32) ((uint64) dwArg14 /u dwArg0C);
		uint32 esi_122 = dwArg0C >> 0x02;
		uint32 ecx_123 = (dwArg0C >> 0x02) - (dwArg08 >> 0x02);
		if (ecx_123 > 0x00)
		{
			if (ecx_123 > 0x01)
			{
				uint32 ecx_136 = ecx_123 - 0x01;
				Eq_17322 ebx_138 = 0x03;
				while (true)
				{
					byte cl_151 = (byte) ecx_136;
					if (ecx_136 < 0x80)
						break;
					if (ebx_138 >= 0x28)
						runtime.panicindex(gs);
					*((word32) ebx_138 + (fp - 44)) = (byte) ecx_136 | 0x80;
					ebx_138 = (word32) ebx_138 + 1;
					ecx_136 >>= 0x07;
				}
				if (ebx_138 >= 0x28)
					runtime.panicindex(gs);
				Mem152[fp - 44 + ebx_138:byte] = cl_151;
				ecx_128 = (word32) ebx_138 + 1;
			}
			else
				ecx_128.u0 = 0x02;
		}
		else
			ecx_128.u0 = 0x00;
		if (ecx_128 >= 0x28)
			runtime.panicindex(gs);
		*((word32) ecx_128.u0 + (fp - 44)) = 0x80;
		byte * ecx_164 = (word32) ecx_128.u0 + 1;
		for (; esi_122 >= 0x80; esi_122 >>= 0x07)
		{
			if (ecx_164 >= (byte *) 0x28)
				runtime.panicindex(gs);
			Mem283[fp - 44 + ecx_164:byte] = SLICE(esi_122, byte, 0) | 0x80;
			++ecx_164;
		}
		if (ecx_164 >= (byte *) 0x28)
			runtime.panicindex(gs);
		Mem183[fp - 44 + ecx_164:byte] = SLICE(esi_122, byte, 0);
		byte * ecx_187 = ecx_164 + 1;
		uint32 eax_188 = eax_116 - 0x01;
		while (true)
		{
			byte al_203 = (byte) eax_188;
			if (eax_188 < 0x80)
				break;
			if (ecx_187 >= (byte *) 0x28)
				runtime.panicindex(gs);
			Mem265[fp - 44 + ecx_187:byte] = SLICE(eax_188, byte, 0) | 0x80;
			++ecx_187;
			eax_188 >>= 0x07;
		}
		if (ecx_187 >= (byte *) 0x28)
			runtime.panicindex(gs);
		Mem204[fp - 44 + ecx_187:byte] = al_203;
		if (ecx_187 >= (byte *) ~0x26)
			runtime.panicindex(gs);
		Mem214[fp - 0x2B + ecx_187:byte] = 0x00;
		runtime.runGCProg(gs, dwArg18, fp - (byte *) 44, dwArg00, 0x02);
		eax_231 = dwArg0C *s (eax_116 - 0x01) + dwArg08 >> 0x02;
	}
	else
	{
		runtime.runGCProg(gs, dwArg1C, 0x00, dwArg04, 0x02);
		if (dwLoc30 << 0x02 != dwArg0C)
		{
			runtime.printlock(gs);
			runtime.printstring(gs);
			runtime.printsp(gs);
			runtime.printint(ebx_24_8, gs, dwLoc30);
			runtime.printsp(gs);
			runtime.printstring(gs);
			runtime.printsp(gs);
			runtime.printint(ebx_24_8, gs, dwArg0C);
			runtime.printnl(gs);
			runtime.printunlock(gs);
			runtime.throw(gs);
		}
		eax_231 = dwLoc30;
	}
	word32 ebx_244 = dwArg04 - (dwArg18 >> 0x04);
	runtime.memclrNoHeapPointers(ebx_244 + 0x01, dwArg04 - ((word32) eax_231 + 3 >> 0x02) - ebx_244);
}

// 08057630: void runtime.progToPointerMask(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack uint32 dwArg08)
// Called from:
//      runtime.modulesinit
void runtime.progToPointerMask(struct Eq_2 * gs, Eq_4 dwArg04, uint32 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	uint32 eax_19 = (dwArg08 >> 0x02) + 0x07;
	runtime.persistentalloc(gs);
	uint32 ecx_23 = (eax_19 >> 0x03) + 0x01;
	if (ecx_23 > 0x40000000)
		runtime.panicslice(gs);
	else if (eax_19 >> 0x03 >= ecx_23)
		runtime.panicindex(gs);
	else
	{
		Mem46[(eax_19 >>u 0x03) + dwLoc14:byte] = 161;
		if (ecx_23 <= 0x00)
			runtime.panicindex(gs);
		else
		{
			runtime.runGCProg(gs, dwArg04, 0x00, dwLoc14, 0x01);
			if (Mem56[(eax_19 >>u 0x03) + dwLoc14:byte] == 161)
				return;
			runtime.throw(gs);
		}
	}
}

// 08057720: void runtime.runGCProg(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_16813 dwArg0C, Stack word32 dwArg10)
// Called from:
//      runtime.heapBitsSetTypeGCProg
//      runtime.progToPointerMask
void runtime.runGCProg(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, Eq_16813 dwArg0C, word32 dwArg10)
{
	while (fp - 0x04 <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_16813 edx_18 = dwArg0C;
	Eq_4 ebp_20 = dwArg08;
	Eq_4 esi_21 = dwArg04;
	Eq_17553 ecx_23 = 0x00;
	uint32 edi_1019 = 0x00;
	while (true)
	{
		while (ecx_23 >= 0x08)
		{
			if (dwArg10 == 0x01)
			{
				*edx_18 = (byte) edi_1019;
				edi_1019 >>= 0x08;
				edx_18 = (word32) edx_18 + 1;
			}
			else
			{
				*edx_18 = (byte) edi_1019 & 0x0F | 0xF0;
				byte * edx_919 = edx_18 - 0x01;
				*edx_919 = (byte) (edi_1019 >> 0x04) & 0x0F | 0xF0;
				edi_1019 >>= 0x08;
				edx_18 = edx_919 - 0x01;
			}
			ecx_23 = (word32) ecx_23 - 8;
		}
		Eq_16813 ebx_373;
		Eq_4 edx_378;
		ui32 ebx_38 = (word32) *esi_21;
		Eq_17553 ebx_40 = ebx_38 & 0x7F;
		Eq_4 esi_41 = (word32) esi_21 + 1;
		if ((ebx_38 & 0x80) == 0x00)
		{
			if ((ebx_38 & 0x7F) == 0x00)
			{
				if (ebp_20 == 0x00)
				{
					if (dwArg10 == 0x01)
					{
						Eq_16813 edx_854 = edx_18;
						uint32 ecx_861;
						for (ecx_861 = (word32) ecx_23 + (-ecx_23 & 0x07); ecx_861 > 0x00; ecx_861 += ~0x07)
						{
							*edx_854 = (byte) edi_1019;
							edi_1019 >>= 0x08;
							edx_854 = (word32) edx_854 + 1;
						}
					}
					else
					{
						Eq_16813 edx_819 = edx_18;
						uint32 ecx_826;
						for (ecx_826 = (word32) ecx_23 + (-ecx_23 & 0x03); ecx_826 > 0x00; ecx_826 += ~0x03)
						{
							*edx_819 = (byte) edi_1019 & 0x0F | 0xF0;
							--edx_819;
							edi_1019 >>= 0x04;
						}
					}
					return;
				}
				edx_378.u0 = 0x00;
				ebx_373 = edx_18;
			}
			else
			{
				uint32 ebx_694 = (ebx_38 & 0x7F) >> 0x03;
				uint32 dwLoc68_1183 = 0x00;
				Eq_16813 dwLoc10_1185 = edx_18;
				while (true)
				{
					byte cl_724 = (byte) ecx_23;
					if (dwLoc68_1183 >= ebx_694)
						break;
					Eq_16813 esi_784;
					ui32 edx_750 = (word32) *esi_41 << cl_724 & 0x00 - (ecx_23 < 0x20);
					uint32 edi_751 = edi_1019 | edx_750;
					Eq_4 edx_753 = (word32) esi_41 + 1;
					if (dwArg10 == 0x01)
					{
						*dwLoc10_1185 = (byte) edi_751;
						esi_784 = (word32) dwLoc10_1185 + 1;
					}
					else
					{
						*dwLoc10_1185 = (byte) edi_751 & 0x0F | 0xF0;
						*((word32) dwLoc10_1185 - 1) = (byte) (edi_751 >> 0x04) & 0x0F | 0xF0;
						esi_784 = dwLoc10_1185 - 0x02;
					}
					edi_1019 = (edi_1019 | edx_750) >> 0x08;
					++dwLoc68_1183;
					dwLoc10_1185 = esi_784;
					esi_41 = edx_753;
				}
				Eq_4 ebx_722;
				Eq_17553 edx_720;
				if ((ebx_38 & 0x07) > 0x00)
				{
					edi_1019 |= (word32) *esi_41 << cl_724 & 0x00 - (ecx_23 < 0x20);
					edx_720 = (word32) ecx_23 + (ebx_38 & 0x07);
					ebx_722 = (word32) esi_41 + 1;
				}
				else
				{
					edx_720 = ecx_23;
					ebx_722 = esi_41;
				}
				ecx_23 = edx_720;
				ebp_20 = ebx_722;
				edx_378 = ebp_20;
				ebx_373 = dwLoc10_1185;
			}
		}
		else
		{
			Eq_4 ebp_105;
			if ((ebx_38 & 0x7F) == 0x00)
			{
				up32 edx_51 = 0x00;
				while (true)
				{
					ui32 ebp_56 = (word32) *esi_41;
					ebx_40 |= 0x00 - (edx_51 < 0x20) & (ebp_56 & 0x7F) << (byte) edx_51;
					ebp_105 = (word32) esi_41 + 1;
					if ((ebp_56 & 0x80) == 0x00)
						break;
					edx_51 += 0x07;
					esi_41 = ebp_105;
				}
			}
			else
				ebp_105 = esi_41;
			int32 ecx_110 = 0x00;
			up32 edx_109 = 0x00;
			while (true)
			{
				ui32 esi_92 = (word32) *ebp_105;
				int32 ebx_104 = ecx_110 | (esi_92 & 0x7F) << (byte) edx_109 & 0x00 - (edx_109 < 0x20);
				ebp_105 = (word32) ebp_105 + 1;
				if ((esi_92 & 0x80) == 0x00)
					break;
				edx_109 += 0x07;
				ecx_110 = ebx_104;
			}
			Eq_17553 edx_113 = ebx_40;
			Eq_17553 ebx_114 = ebx_104 *s ebx_40;
			if (ebx_40 <= 0x19)
			{
				uint32 ebp_420;
				Eq_17553 esi_401;
				if (dwArg10 == 0x01)
				{
					byte * ebp_424 = edx_18 - 0x01;
					Eq_17553 dwLoc58_1098 = ecx_23;
					uint32 dwLoc5C_1100 = edi_1019;
					while (true)
					{
						esi_401 = dwLoc58_1098;
						if (dwLoc58_1098 >= ebx_40)
							break;
						--ebp_424;
						dwLoc58_1098 = (word32) dwLoc58_1098 + 8;
						dwLoc5C_1100 = dwLoc5C_1100 << 0x08 | (word32) (*ebp_424);
					}
					ebp_420 = dwLoc5C_1100;
				}
				else
				{
					byte * ebp_385 = (word32) edx_18 + 1;
					Eq_17553 dwLoc58_1087 = ecx_23;
					uint32 dwLoc5C_1089 = edi_1019;
					while (true)
					{
						esi_401 = dwLoc58_1087;
						if (dwLoc58_1087 >= ebx_40)
							break;
						++ebp_385;
						dwLoc58_1087 = (word32) dwLoc58_1087 + 4;
						dwLoc5C_1089 = dwLoc5C_1089 << 0x04 | (word32) (*ebp_385) & 0x0F;
					}
					ebp_420 = dwLoc5C_1089;
				}
				Eq_16813 edi_1008 = edx_18;
				if (esi_401 > ebx_40)
				{
					Eq_17807 esi_460 = esi_401 - ebx_40;
					ebp_420 = ebp_420 >> (byte) esi_460 & 0x00 - (esi_460 < 0x20);
				}
				else
					edx_113 = esi_401;
				Eq_17553 ecx_477;
				uint32 edx_543;
				if (edx_113 == 0x01)
				{
					if (ebp_420 == 0x01)
					{
						ecx_477.u0 = 0x19;
						edx_543 = 0x01FFFFFF;
					}
					else
					{
						ecx_477 = ebx_114;
						edx_543 = ebp_420;
					}
				}
				else
				{
					if (edx_113 * 0x02 <= 0x19)
					{
						edx_482 = edx_113;
						while (true)
						{
							Eq_17553 edx_482;
							if (edx_482 > 0x20)
								break;
							ebp_420 = ebp_420 << (byte) edx_482 & 0x00 - (edx_482 < 0x20) | ebp_420;
							edx_482 *= 0x02;
						}
						if (edx_113 == 0x00)
							runtime.panicdivide(gs);
						ecx_477 = edx_113 *s (uint32) (0x19 /u edx_113);
						ebp_420 &= (0x01 << (byte) ecx_477 & 0x00 - (ecx_477 < 0x20)) - 0x01;
					}
					else
						ecx_477 = edx_113;
					edx_543 = ebp_420;
				}
				uint32 esi_1014 = edi_1019;
				Eq_17553 dwLoc74_1160 = ecx_23;
				for (; ebx_114 >= ecx_477; ebx_114 -= ecx_477)
				{
					esi_1014 |= edx_543 << (byte) dwLoc74_1160 & 0x00 - (dwLoc74_1160 < 0x20);
					word32 ebx_625 = ecx_477 + dwLoc74_1160;
					if (dwArg10 != 0x01)
					{
						while (ebx_625 >= 0x04)
						{
							*edi_1008 = (byte) esi_1014 & 0x0F | 0xF0;
							ebx_625 = (word32) ebx_625 - 4;
							--edi_1008;
							esi_1014 >>= 0x04;
						}
					}
					else
					{
						while (ebx_625 >= 0x08)
						{
							*edi_1008 = (byte) esi_1014;
							esi_1014 >>= 0x08;
							ebx_625 = (word32) ebx_625 - 8;
							edi_1008 = (word32) edi_1008 + 1;
						}
					}
					dwLoc74_1160 = ebx_625;
				}
				Eq_17553 edx_582;
				if (ebx_114 > 0x00)
				{
					esi_1014 |= (edx_543 & (0x01 << (byte) ebx_114 & 0x00 - (ebx_114 < 0x20)) - 0x01) << (byte) dwLoc74_1160 & 0x00 - (dwLoc74_1160 < 0x20);
					edx_582 = dwLoc74_1160 + ebx_114;
				}
				else
					edx_582 = dwLoc74_1160;
				ecx_23 = edx_582;
				ebp_20 = ebp_105;
				edx_378 = ebp_20;
				ebx_373 = edi_1008;
				edi_1019 = esi_1014;
			}
			else
			{
				Eq_17553 edx_228;
				Eq_16813 ecx_248;
				Eq_17777 edx_118 = ebx_40 - ecx_23;
				if (dwArg10 == 0x01)
				{
					Eq_17553 ebp_261;
					byte * edx_260;
					byte * ebp_253 = edx_18 - ((word32) edx_118 + 7 >> 0x03);
					if ((edx_118 & 0x07) != 0x00)
					{
						up32 ebx_268 = 0x08 - (edx_118 & 0x07);
						edi_1019 |= ((word32) *ebp_253 >> (byte) ebx_268 & 0x00 - (ebx_268 < 0x20)) << (byte) ecx_23 & 0x00 - (ecx_23 < 0x20);
						ebp_261 = (word32) ecx_23 + (edx_118 & 0x07);
						ebx_114 -= edx_118 & 0x07;
						edx_260 = ebp_253 + 1;
					}
					else
					{
						edx_260 = ebp_253;
						ebp_261 = ecx_23;
					}
					uint32 ebx_298;
					Eq_16813 esi_300 = edx_18;
					for (ebx_298 = ebx_114 >> 0x03; ebx_298 > 0x00; --ebx_298)
					{
						uint32 edi_318 = edi_1019 | (word32) (*edx_260) << (byte) ebp_261 & 0x00 - (ebp_261 < 0x20);
						*esi_300 = (byte) edi_318;
						++edx_260;
						edi_1019 = edi_318 >> 0x08;
						esi_300 = (word32) esi_300 + 1;
					}
					ui32 ecx_343 = ebx_114 & 0x07;
					byte cl_351 = (byte) ecx_343;
					if ((ebx_114 & 0x07) > 0x00)
					{
						edi_1019 |= ((0x01 << cl_351) - 0x01 & (word32) (*edx_260)) << (byte) ebp_261 & 0x00 - (ebp_261 < 0x20);
						edx_228 = (word32) ebp_261 + ecx_343;
					}
					else
						edx_228 = ebp_261;
					ecx_248 = esi_300;
				}
				else
				{
					Eq_17553 ebp_135;
					Eq_17829 edx_134;
					struct Eq_17830 * edi_124 = (word32) edx_118 + 3 >> 0x02;
					word32 ebp_129 = edx_18 + edi_124;
					if ((edx_118 & 0x03) != 0x00)
					{
						up32 ebx_143 = 0x04 - (edx_118 & 0x03);
						edi_1019 |= (((word32) *ebp_129 & 0x0F) >> (byte) ebx_143 & 0x00 - (ebx_143 < 0x20)) << (byte) ecx_23 & 0x00 - (ecx_23 < 0x20);
						ebp_135 = (word32) ecx_23 + (edx_118 & 0x03);
						ebx_114 -= edx_118 & 0x03;
						edx_134 = edi_124 - 0x01 + edx_18;
					}
					else
					{
						edx_134 = ebp_129;
						ebp_135 = ecx_23;
					}
					uint32 ebx_173;
					Eq_16813 esi_175 = edx_18;
					for (ebx_173 = ebx_114 >> 0x02; ebx_173 > 0x00; --ebx_173)
					{
						uint32 edi_194 = edi_1019 | ((word32) (*edx_134) & 0x0F) << (byte) ebp_135 & 0x00 - (ebp_135 < 0x20);
						*esi_175 = (byte) edi_194 & 0x0F | 0xF0;
						--edx_134;
						--esi_175;
						edi_1019 = edi_194 >> 0x04;
					}
					ui32 ecx_223 = ebx_114 & 0x03;
					byte cl_231 = (byte) ecx_223;
					if ((ebx_114 & 0x03) > 0x00)
					{
						edi_1019 |= ((0x01 << cl_231) - 0x01 & (word32) (*edx_134)) << (byte) ebp_135 & 0x00 - (ebp_135 < 0x20);
						edx_228 = (word32) ebp_135 + ecx_223;
					}
					else
						edx_228 = ebp_135;
					ecx_248 = esi_175;
				}
				ebp_20 = ebp_105;
				ebx_373 = ecx_248;
				ecx_23 = edx_228;
				edx_378 = ebp_20;
			}
		}
		esi_21 = ebp_20;
		ebp_20 = edx_378;
		edx_18 = ebx_373;
	}
}

// 08057E90: Register Eq_4 runtime.allocmcache(Register Eq_4 esi, Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.mallocinit
//      runtime.startpanic_m
//      runtime.procresize
Eq_4 runtime.allocmcache(Eq_4 esi, struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 esi_28;
	word32 edi_110;
	runtime.lock(esi, gs, 0x081488E0, out esi_28, out edi_110);
	runtime.(*fixalloc).alloc(gs, &g_dw814B564);
	word32 ebx_112;
	word32 edx_111;
	runtime.unlock(gs, 0x081488E0, out edx_111, out ebx_112);
	Eq_18217 ecx_58 = 0x00;
	while (ecx_58 < 0x86)
	{
		if (ecx_58 >= 0x86)
			runtime.panicindex(gs);
		dwLoc08->a0014[ecx_58] = 135549664;
		ecx_58 = (word32) ecx_58 + 1;
	}
	runtime.nextSample(gs);
	dwLoc08->ptr0000 = 0x081488E0;
	return esi_28;
}

// 08057F30: void runtime.freemcache(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.procresize
void runtime.freemcache(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	word32 ebp_49;
	word32 edi_50;
	runtime.systemstack(gs, fp - 0x08, out ebp_49, out edi_50);
}

// 08057F70: void runtime.(*mcache).refill(Register (ptr32 Eq_2) gs, Register Eq_662 xmm1, Stack Eq_4 dwArg04, Stack Eq_4 bArg08)
// Called from:
//      runtime.(*mcache).nextFree.func1
void runtime.(*mcache).refill(struct Eq_2 * gs, Eq_662 xmm1, Eq_4 dwArg04, Eq_4 bArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 eax_18 = gs->ptr0000->tFFFFFFFC;
	Eq_4 ecx_19 = *((word32) eax_18 + 24);
	*((word32) ecx_19 + 0x0078) = (word32) *((word32) ecx_19 + 0x0078) + 1;
	uint32 edx_28 = (word32) bArg08;
	if (edx_28 >= 0x86)
		runtime.panicindex(gs);
	else
	{
		Eq_4 ebx_31 = *((word32) dwArg04 + (edx_28 * 0x04 + 20));
		Eq_4 esi_33 = *((word32) ebx_31 + 28);
		if ((word32) *((word32) ebx_31 + 56) != esi_33)
			runtime.throw(gs);
		else
		{
			if (ebx_31 != 135549664)
				((word32) ebx_31 + 59)->u0 = 0x00;
			runtime.(*mcentral).cacheSpan(esi_33, gs, xmm1, (edx_28 << 0x06) + 135566272);
			if (dwLoc0C == 0x00)
				runtime.throw(gs);
			else if ((word32) *((word32) dwLoc0C + 56) == *((word32) dwLoc0C + 28))
				runtime.throw(gs);
			else
			{
				*((word32) dwArg04 + (edx_28 * 0x04 + 20)) = dwLoc0C;
				Eq_4 ecx_109 = *((word32) eax_18 + 24);
				--*((word32) ecx_109 + 0x0078);
			}
		}
	}
}

// 08058090: void runtime.(*mcache).releaseAll(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      runtime.flushmcache
//      runtime.freemcache.func1
void runtime.(*mcache).releaseAll(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_18381 eax_17 = 0x00;
	while (eax_17 < 0x86)
	{
		if (eax_17 >= 0x86)
			runtime.panicindex(gs);
		Eq_4 edx_40 = *((word32) dwArg04 + (eax_17 * 0x04 + 20));
		if (edx_40 != 135549664)
		{
			runtime.(*mcentral).uncacheSpan(gs, (eax_17 << 0x06) + 135566272, edx_40);
			((word32) dwArg04 + (eax_17 * 0x04 + 20))->u0 = 135549664;
		}
		eax_17 = (word32) eax_17 + 1;
	}
	((word32) dwArg04 + 8)->u0 = 0x00;
	((word32) dwArg04 + 0x0C)->u0 = 0x00;
}

// 08058130: void runtime.(*mcentral).cacheSpan(Register Eq_4 esi, Register (ptr32 Eq_2) gs, Register Eq_662 xmm1, Stack Eq_4 dwArg04)
// Called from:
//      runtime.(*mcache).refill
void runtime.(*mcentral).cacheSpan(Eq_4 esi, struct Eq_2 * gs, Eq_662 xmm1, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	struct Eq_18435 * ecx_21 = (int32) (*((word32) dwArg04 + 4) >> 0x01);
	if (ecx_21 >= (struct Eq_18435 *) 0x43)
		runtime.panicindex(gs);
	else
	{
		ui32 eax_25 = (word32) ecx_21->b8137B00;
		word32 edi_967;
		Eq_4 esi_208;
		runtime.lock(runtime.deductSweepCredit(esi, gs, xmm1, eax_25 << 0x0D, 0x00), gs, dwArg04, out esi_208, out edi_967);
		Eq_4 dwLoc24_689 = 0x00;
		if (g_b814F4C8 != 0x00)
			runtime.traceGCSweepStart(gs);
		Eq_4 eax_77 = g_t81490F0;
		eax_213 = eax_77;
l08058538:
		Eq_4 eax_213;
		Eq_4 ecx_215 = dwArg04;
		Eq_4 edx_425 = *((word32) dwArg04 + 8);
		while (true)
		{
			byte al_475;
			Eq_4 ecx_192;
			if (edx_425 == 0x00)
				break;
			Eq_4 ebp_332 = (word32) edx_425 + 48;
			esi_208 = eax_213 - 0x02;
			if (*((word32) edx_425 + 48) == esi_208)
			{
				runtime/internal/atomic.Cas(ebp_332, esi_208, eax_213 - 0x01);
				dwLoc24_689 = esi_208;
				if (bLoc1C != 0x00)
				{
					runtime.(*mSpanList).remove(gs, (word32) dwArg04 + 8, edx_425);
					runtime.(*mSpanList).insertBack(gs, (word32) dwArg04 + 16, edx_425);
					word32 edx_975;
					word32 ebx_976;
					runtime.unlock(gs, dwArg04, out edx_975, out ebx_976);
					word128 xmm2_978;
					word128 xmm0_977;
					runtime.(*mspan).sweep(gs, dwLoc2C, (byte) edx_425, out xmm0_977, out xmm2_978);
					Eq_4 esp_397 = <invalid>;
					al_475 = 0x00;
					ecx_192 = *((word32) esp_397 + 32);
					goto l0805820B;
				}
				eax_213 = eax_77;
				ecx_215 = dwArg04;
			}
			if (*((word32) edx_425 + 48) != eax_213 - 0x01)
			{
				runtime.(*mSpanList).remove(gs, (word32) ecx_215 + 8, edx_425);
				runtime.(*mSpanList).insertBack(gs, (word32) dwArg04 + 16, edx_425);
				word32 ebx_969;
				word32 edx_968;
				runtime.unlock(gs, dwArg04, out edx_968, out ebx_969);
				al_475 = 0x00;
				ecx_192 = edx_425;
				goto l0805820B;
			}
			edx_425 = *edx_425;
		}
		Eq_4 edx_224 = *((word32) ecx_215 + 16);
		while (edx_224 != 0x00)
		{
			Eq_4 ebp_97 = (word32) edx_224 + 48;
			esi_208 = eax_213 - 0x02;
			if (*((word32) edx_224 + 48) == esi_208)
			{
				runtime/internal/atomic.Cas(ebp_97, esi_208, eax_213 - 0x01);
				dwLoc24_689 = esi_208;
				if (bLoc1C != 0x00)
				{
					runtime.(*mSpanList).remove(gs, (word32) dwArg04 + 16, edx_224);
					runtime.(*mSpanList).insertBack(gs, (word32) dwArg04 + 16, edx_224);
					word32 ebx_986;
					word32 edx_985;
					runtime.unlock(gs, dwArg04, out edx_985, out ebx_986);
					word128 xmm2_988;
					word128 xmm0_987;
					runtime.(*mspan).sweep(gs, dwLoc2C, (byte) edx_224, out xmm0_987, out xmm2_988);
					Eq_4 esp_164 = <invalid>;
					*esp_164 = *((word32) esp_164 + 32);
					Eq_4 esi_186 = runtime.(*mspan).nextFreeIndex(gs, *esp_164);
					ecx_192 = *((word32) esp_164 + 32);
					Eq_4 eax_191 = *((word32) esp_164 + 4);
					dwLoc24_689 = SEQ(SLICE(edx_224, word24, 8), 0x01);
					if (eax_191 != *((word32) ecx_192 + 28))
					{
						*((word32) ecx_192 + 24) = eax_191;
						al_475 = 0x00;
						goto l0805820B;
					}
					else
					{
						*esp_164 = *((word32) esp_164 + 44);
						word32 edi_989;
						runtime.lock(esi_186, gs, *esp_164, out esi_208, out edi_989);
						eax_213 = *((word32) esp_164 + 28);
						goto l08058538;
					}
				}
				eax_213 = eax_77;
				ecx_215 = dwArg04;
			}
			if (*((word32) edx_224 + 48) != eax_213 - 0x01)
				break;
			edx_224 = *edx_224;
		}
		byte al_227 = g_b814F4C8;
		if (al_227 != 0x00)
		{
			esi_208 = runtime.traceGCSweepDone(gs);
			ecx_215 = dwArg04;
		}
		word32 edx_979;
		word32 ebx_980;
		runtime.unlock(gs, ecx_215, out edx_979, out ebx_980);
		Eq_4 esi_278 = runtime.(*mcentral).grow(esi_208, gs, dwArg04);
		if (dwLoc24_689 == 0x00)
			return;
		word32 esi_981;
		word32 edi_982;
		runtime.lock(esi_278, gs, dwArg04, out esi_981, out edi_982);
		runtime.(*mSpanList).insertBack(gs, (word32) dwArg04 + 16, dwLoc24_689);
		word32 ebx_984;
		word32 edx_983;
		runtime.unlock(gs, dwArg04, out edx_983, out ebx_984);
		al_475 = al_227;
		ecx_192 = dwLoc24_689;
l0805820B:
		if (g_b814F4C8 != 0x00 && al_475 == 0x00)
			runtime.traceGCSweepDone(gs);
		Eq_4 eax_498 = *((word32) ecx_192 + 16);
		Eq_4 edx_499 = *((word32) ecx_192 + 64);
		if (edx_499 == 0x00)
			runtime.panicdivide(gs);
		else
		{
			Eq_4 dx_511 = *((word32) ecx_192 + 56);
			Eq_4 eax_513 = (uint32) ((uint64) (eax_498 << 0x0D) /u edx_499) - (word32) dx_511;
			if (eax_513 != 0x00)
			{
				Eq_4 ebp_518 = *((word32) ecx_192 + 28);
				if (*((word32) ecx_192 + 24) != ebp_518 && ebp_518 != (word32) dx_511)
				{
					word32 ebp_971;
					word32 ebx_970;
					runtime/internal/atomic.Xadd64((word32) dwArg04 + 24, eax_513, eax_513 >> 0x1F, out ebx_970, out ebp_971);
					Eq_4 edx_557 = (eax_25 << 0x0D) - (word32) (*((word32) ecx_192 + 56)) *s *((word32) ecx_192 + 64);
					word32 ebx_972;
					Eq_4 ebp_568;
					runtime/internal/atomic.Xadd64(135632816, edx_557, 0x00 - (edx_557 < 0x00), out ebx_972, out ebp_568);
					if (g_b814F4C8 != 0x00)
					{
						word32 esi_973;
						ebp_568 = runtime.traceHeapAlloc(gs, out esi_973);
					}
					if (runtime.gcBlackenEnabled != 0x00)
						runtime.(*gcControllerState).revise(ebp_568, gs, &g_dw8157860);
					((word32) ecx_192 + 59)->u0 = 0x01;
					word32 esi_974;
					runtime.(*mspan).refillAllocCache(gs, ecx_192, (*((word32) ecx_192 + 24) & ~0x3F) >> 0x03, out esi_974);
					Eq_4 ebx_640 = *((word32) ecx_192 + 24);
					uint32 ebp_642 = (ebx_640 & 0x3F) - 0x20;
					Eq_4 edx_639 = *((word32) ecx_192 + 36);
					uint32 ecx_652 = -ebp_642;
					byte cl_661 = (byte) ebx_640 & 0x3F;
					ui32 ebp_665 = 0x00 - ((ebx_640 & 0x3F) < 0x20);
					*((word32) ecx_192 + 32) = edx_639 << (byte) ecx_652 & 0x00 - (ecx_652 < 0x20) | *((word32) ecx_192 + 32) >> cl_661 & ebp_665 | edx_639 >> (byte) ebp_642 & 0x00 - (ebp_642 < 0x20);
					*((word32) ecx_192 + 36) = edx_639 >> cl_661 & ebp_665;
					return;
				}
			}
			runtime.throw(gs);
		}
	}
}

// 08058590: void runtime.(*mcentral).uncacheSpan(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
// Called from:
//      runtime.(*mcache).releaseAll
void runtime.(*mcentral).uncacheSpan(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	word32 esi_179;
	word32 edi_180;
	runtime.lock(esi, gs, dwArg04, out esi_179, out edi_180);
	((word32) dwArg08 + 59)->u0 = 0x00;
	Eq_4 cx_29 = *((word32) dwArg08 + 56);
	if (cx_29 == 0x00)
		runtime.throw(gs);
	else
	{
		Eq_4 edx_40 = *((word32) dwArg08 + 16);
		Eq_4 ebx_41 = *((word32) dwArg08 + 64);
		if (ebx_41 == 0x00)
			runtime.panicdivide(gs);
		else
		{
			Eq_18916 eax_58 = (uint32) ((uint64) (edx_40 << 0x0D) /u ebx_41) - (word32) cx_29;
			if (eax_58 > 0x00)
			{
				runtime.(*mSpanList).remove(gs, (word32) dwArg04 + 16, dwArg08);
				runtime.(*mSpanList).insert(gs, (word32) dwArg04 + 8, dwArg08);
				Eq_4 ecx_63 = 0x00 - eax_58;
				Eq_4 eax_84 = *((word32) dwArg08 + 64);
				uint64 edx_eax_87 = eax_84 *64 ecx_63;
				Eq_4 ebp_98 = SLICE(0x00 - SEQ(eax_58 >> 0x1F, eax_58), word32, 32);
				word32 ebx_181;
				word32 ebp_182;
				runtime/internal/atomic.Xadd64(135632816, (word32) edx_eax_87, eax_84 *s ebp_98 + SLICE(edx_eax_87, word32, 32), out ebx_181, out ebp_182);
				word32 ebx_183;
				word32 ebp_184;
				runtime/internal/atomic.Xadd64((word32) dwArg04 + 24, ecx_63, ebp_98, out ebx_183, out ebp_184);
			}
			word32 edx_185;
			word32 ebx_186;
			runtime.unlock(gs, dwArg04, out edx_185, out ebx_186);
		}
	}
}

// 080586D0: Register Eq_4 runtime.(*mcentral).freeSpan(Register Eq_4 esi, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack byte bArg0C, Stack int8 bArg0D)
// Called from:
//      runtime.(*mspan).sweep
Eq_4 runtime.(*mcentral).freeSpan(Eq_4 esi, struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, byte bArg0C, int8 bArg0D)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (*((word32) dwArg08 + 59) != 0x00)
		runtime.throw(gs);
	else
	{
		*((word32) dwArg08 + 61) = 0x01;
		if (bArg0C == 0x00)
		{
			Eq_4 esi_51;
			word32 edi_250;
			runtime.lock(esi, gs, dwArg04, out esi_51, out edi_250);
			if (bArg0D != 0x00)
			{
				runtime.(*mSpanList).remove(gs, (word32) dwArg04 + 16, dwArg08);
				runtime.(*mSpanList).insert(gs, (word32) dwArg04 + 8, dwArg08);
			}
			runtime/internal/atomic.Store((word32) dwArg08 + 48, g_t81490F0);
			if (*((word32) dwArg08 + 56) == 0x00)
			{
				runtime.(*mSpanList).remove(gs, (word32) dwArg04 + 8, dwArg08);
				word32 ebx_252;
				word32 edx_251;
				runtime.unlock(gs, dwArg04, out edx_251, out ebx_252);
				runtime.(*mheap).freeSpan(gs);
				return esi_51;
			}
			else
			{
				word32 ebx_254;
				word32 edx_253;
				runtime.unlock(gs, dwArg04, out edx_253, out ebx_254);
				return esi_51;
			}
		}
		else if (*((word32) dwArg08 + 8) == 0x00)
			runtime.throw(gs);
		else
		{
			runtime/internal/atomic.Store((word32) dwArg08 + 48, g_t81490F0);
			return esi;
		}
	}
}

// 08058840: Register Eq_4 runtime.(*mcentral).grow(Register Eq_4 esi, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      runtime.(*mcentral).cacheSpan
Eq_4 runtime.(*mcentral).grow(Eq_4 esi, struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	struct Eq_19082 * eax_22 = (int32) (*((word32) dwArg04 + 4) >> 0x01);
	if (eax_22 >= (struct Eq_19082 *) 0x43)
		runtime.panicindex(gs);
	else
	{
		uint32 edx_26 = (word32) eax_22->b8137B00;
		Eq_19098 eax_28 = (word32) g_a8138820[eax_22 * 0x02];
		if (eax_28 == 0x00)
			runtime.panicdivide(gs);
		else
		{
			runtime.(*mheap).alloc(gs, 0x01);
			Eq_19111 eax_56 = (uint32) ((uint64) (edx_26 << 0x0D) /u eax_28);
			if (dwLoc10 == null)
				return esi;
			dwLoc10->dw0050 = (word32) dwLoc10->t000C + eax_28 *s eax_56;
			runtime.heapBitsForSpan(esi, gs, dwLoc10->t000C);
			return runtime.heapBits.initSpan(esi, gs, edx_26, dwLoc10);
		}
	}
}

// 08058930: void runtime.addrspace_free(Register (ptr32 Eq_2) gs, Stack up32 dwArg08)
// Called from:
//      runtime.mmap_fixed
void runtime.addrspace_free(struct Eq_2 * gs, up32 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	up32 eax_17 = 0x00;
	while (eax_17 < dwArg08)
	{
		runtime.mincore();
		if (dwLoc08 != ~0x15 && dwLoc08 != ~0x0B)
			return;
		eax_17 = (word32) runtime.physPageSize + eax_17;
	}
}

// 080589B0: void runtime.mmap_fixed(Register (ptr32 Eq_2) gs, Stack uint32 dwArg04, Stack Eq_19165 bArg0C)
// Called from:
//      runtime.sysMap
void runtime.mmap_fixed(struct Eq_2 * gs, uint32 dwArg04, Eq_19165 bArg0C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.mmap();
	byte bLoc18_132 = (byte) dwArg0C;
	if (dwLoc08 != dwArg04)
	{
		runtime.addrspace_free(gs, dwArg08);
		if (bLoc18_132 != 0x00)
		{
			if (dwLoc08 > 0x1000)
				runtime.munmap();
			runtime.mmap();
		}
	}
}

// 08058AA0: Register word32 runtime.sysAlloc()
// Called from:
//      runtime.(*mheap).sysAlloc
//      runtime.persistentalloc1
//      runtime.recordspan
//      runtime.newArenaMayUnlock
//      runtime.stkbucket
//      runtime.stackalloc
//      runtime.traceFlush
//      runtime.(*traceAlloc).alloc
word32 runtime.sysAlloc()
{
	runtime.mmap();
	if (dwLoc08 >= 0x1000)
	{
		runtime.mSysStatInc(dwArg08, dwArg04);
		return;
	}
	else
	{
		if (dwLoc08 == 0x0D)
		{
			runtime.printlock(gs);
			runtime.printstring(gs);
			runtime.printunlock(gs);
			runtime.exit();
		}
		if (dwLoc08 == 11)
		{
			runtime.printlock(gs);
			runtime.printstring(gs);
			runtime.printunlock(gs);
			runtime.exit();
		}
		return;
	}
}

// 08058B80: void runtime.sysUnused(Register (ptr32 Eq_2) gs, Stack uint32 dwArg04, Stack uint32 dwArg08)
// Called from:
//      runtime.scavengeTreapNode
//      runtime.scavengelist
void runtime.sysUnused(struct Eq_2 * gs, uint32 dwArg04, uint32 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	ui32 ecx_23;
	if ((dwArg04 & 0x001FFFFF) != 0x00)
		ecx_23 = dwArg04 & 0xFFE00000;
	else
		ecx_23 = 0x00;
	ui32 edx_38;
	if ((dwArg08 + dwArg04 & 0x001FFFFF) != 0x00)
		edx_38 = dwArg08 - 0x01 + dwArg04 & 0xFFE00000;
	else
		edx_38 = 0x00;
	bool v17_154 = ecx_23 != 0x00;
	if (ecx_23 != 0x00)
	{
		if (ecx_23 + 0x00200000 == edx_38)
		{
			runtime.madvise();
			goto l08058BEE;
		}
		v17_154 = ecx_23 != 0x00;
	}
	if (v17_154)
		runtime.madvise();
	if (edx_38 != 0x00 && ecx_23 != edx_38)
		runtime.madvise();
l08058BEE:
	Eq_4 edx_114 = runtime.physPageSize;
	if ((dwArg04 & edx_114 - 0x01) != 0x00 || (dwArg08 & edx_114 - 0x01) != 0x00)
		runtime.throw(gs);
	else
		runtime.madvise();
}

// 08058CE0: void runtime.sysUsed(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack ui32 dwArg08)
// Called from:
//      runtime.(*mheap).allocSpanLocked
void runtime.sysUsed(struct Eq_2 * gs, Eq_4 dwArg04, ui32 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (((word32) dwArg04 + 0x001FFFFF & 0xFFE00000) < ((word32) dwArg04 + dwArg08 & 0xFFE00000))
		runtime.madvise();
}

// 08058D40: void runtime.sysFree()
// Called from:
//      runtime.(*mheap).sysAlloc
//      runtime.recordspan
void runtime.sysFree()
{
	runtime.mSysStatDec(dwArg0C, dwArg08);
	runtime.munmap();
}

// 08058D70: Register word32 runtime.sysFault(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.(*mspan).sweep
//      runtime.stackfree
word32 runtime.sysFault(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	return runtime.mmap();
}

// 08058DD0: Register word32 runtime.sysReserve(Register (ptr32 Eq_2) gs, Stack (ptr32 byte) dwArg0C)
// Called from:
//      runtime.mallocinit
//      runtime.(*mheap).sysAlloc
word32 runtime.sysReserve(struct Eq_2 * gs, byte * dwArg0C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.mmap();
	if (dwLoc04 < 0x1000)
		return;
	*dwArg0C = 0x01;
	return;
}

// 08058E50: void runtime.sysMap(Register (ptr32 Eq_2) gs, Stack uint32 dwArg04, Stack byte bArg0C)
// Called from:
//      runtime.(*mheap).sysAlloc
//      runtime.(*mheap).mapBits
//      runtime.(*mheap).mapSpans
void runtime.sysMap(struct Eq_2 * gs, uint32 dwArg04, byte bArg0C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.mSysStatInc(dwArg10, dwArg08);
	if (bArg0C == 0x00)
	{
		runtime.mmap_fixed(gs, dwArg04, 0x03);
		if (dwLoc08 == 0x0C)
			runtime.throw(gs);
		else
		{
			if (dwLoc08 == dwArg04)
				return;
			runtime.printlock(gs);
			runtime.printstring(gs);
			runtime.printpointer(gs);
			runtime.printstring(gs);
			runtime.printpointer(gs);
			runtime.printstring(gs);
			runtime.printunlock(gs);
			runtime.throw(gs);
		}
	}
	else
	{
		runtime.mmap();
		if (dwLoc08 == 0x0C)
			runtime.throw(gs);
		else
		{
			if (dwLoc08 == dwArg04)
				return;
			runtime.throw(gs);
		}
	}
}

// subject_text_0001.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 08059000: Register Eq_4 runtime.queuefinalizer(Register Eq_4 esi, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C, Stack Eq_4 dwArg10, Stack Eq_4 dwArg14)
// Called from:
//      runtime.freespecial
Eq_4 runtime.queuefinalizer(Eq_4 esi, struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C, Eq_4 dwArg10, Eq_4 dwArg14)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (runtime.gcphase != 0x00)
		runtime.throw(gs);
	else
	{
		word32 esi_312;
		word32 edi_313;
		runtime.lock(esi, gs, 0x081575CC, out esi_312, out edi_313);
		struct Eq_19457 * eax_45 = runtime.finq;
		if (eax_45 == null || eax_45->t0008 == 0xCC)
		{
			if (runtime.finc == null)
			{
				runtime.persistentalloc(gs);
				runtime.finc = dwLoc18;
				dwLoc18->ptr0000 = runtime.allfin;
				runtime.allfin = runtime.finc;
				if (g_a81577E0[0] == 0x00)
				{
					struct Eq_19513 * eax_237;
					for (eax_237 = null; eax_237 < (struct Eq_19513 *) 0x80; ++eax_237)
					{
						struct Eq_19517 * ebx_227 = eax_237 - ((eax_237 + SLICE(eax_237 *s64 ~0x33333332, word32, 32) >> 0x02) - (eax_237 >> 0x1F)) * 0x05;
						if (ebx_227 >= (struct Eq_19517 *) 0x05)
						{
l08059222:
							runtime.panicindex(gs);
						}
						byte bl_235 = ebx_227->b8136040;
						if (eax_237 >= (struct Eq_19513 *) 0x80)
							goto l08059222;
						eax_237[0x081577E0] = (struct Eq_19513) bl_235;
					}
				}
			}
			struct Eq_19457 * eax_90 = runtime.finc;
			runtime.finc = eax_90->ptr0004;
			eax_90->ptr0004 = runtime.finq;
			runtime.finq = eax_90;
		}
		struct Eq_19457 * eax_97 = runtime.finq;
		Eq_4 ecx_98 = eax_97->t0008;
		if (ecx_98 >= 0xCC)
			runtime.panicindex(gs);
		else
		{
			runtime/internal/atomic.Xadd(&eax_97->t0008, 0x01);
			Eq_4 edx_122 = eax_97->a0010 + ecx_98 * 5;
			if (g_t81576F0 == 0x00)
				eax_97->a0010[ecx_98 * 5] = dwArg08;
			else
				runtime.writebarrierptr(edx_122, dwArg08);
			eax_97->a0018[ecx_98 * 5] = dwArg0C;
			Eq_4 ebx_150 = eax_97->a001C + ecx_98 * 5;
			Eq_4 ebp_151 = eax_97->a0020 + ecx_98 * 5;
			Eq_4 esi_152 = eax_97->a0014 + ecx_98 * 5;
			if (g_t81576F0 == 0x00)
			{
				eax_97->a001C[ecx_98 * 5].u0 = dwArg10;
				eax_97->a0020[ecx_98 * 5].u0 = dwArg14;
				eax_97->a0014[ecx_98 * 5].u0 = dwArg04;
			}
			else
			{
				runtime.writebarrierptr(ebx_150, dwArg10);
				runtime.writebarrierptr(ebp_151, dwArg14);
				runtime.writebarrierptr(esi_152, dwArg04);
			}
			g_b815756B = 0x01;
			word32 ebx_315;
			word32 edx_314;
			runtime.unlock(gs, 0x081575CC, out edx_314, out ebx_315);
			return esi_152;
		}
	}
}

// 08059250: void runtime.wakefing(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.findrunnable
void runtime.wakefing(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	word32 esi_66;
	word32 edi_67;
	runtime.lock(esi, gs, 0x081575CC, out esi_66, out edi_67);
	if (g_b815756A != 0x00 && g_b815756B != 0x00)
	{
		g_b815756A = 0x00;
		g_b815756B = 0x00;
	}
	word32 edx_68;
	word32 ebx_69;
	runtime.unlock(gs, 0x081575CC, out edx_68, out ebx_69);
}

// 080592D0: void runtime.createfing(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.SetFinalizer
void runtime.createfing(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (runtime.fingCreate == 0x00)
	{
		runtime/internal/atomic.Cas(0x081575C8, 0x00, 0x01);
		if (bLoc04 != 0x00)
			runtime.newproc();
	}
}

// 08059340: void runtime.runfinq(Register Eq_4 esi, Register (ptr32 Eq_2) gs)
void runtime.runfinq(Eq_4 esi, struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	up32 eax_17 = 0x00;
	Eq_4 ecx_18 = 0x00;
	while (true)
	{
		while (true)
		{
			word32 edi_606;
			runtime.lock(esi, gs, 0x081575CC, out esi, out edi_606);
			struct Eq_19457 * eax_41 = runtime.finq;
			runtime.finq = null;
			word24 nLoc3F_596 = SLICE(dwLoc40, word24, 8);
			if (eax_41 != null)
				break;
			Eq_4 eax_431 = gs->ptr0000->tFFFFFFFC;
			if (g_t81576F0 == 0x00)
				runtime.fing = eax_431;
			else
				runtime.writebarrierptr(0x08144FCC, eax_431);
			g_b815756A = 0x01;
			runtime.goparkunlock(gs);
			dwLoc3C.u0 = 0x01;
			dwLoc40 = SEQ(nLoc3F_596, 0x14);
		}
		word32 ebx_605;
		word32 edx_604;
		runtime.unlock(gs, 0x081575CC, out edx_604, out ebx_605);
		struct Eq_19457 * eax_117 = eax_41;
		up32 ecx_118 = eax_17;
		Eq_4 edx_119 = ecx_18;
		while (eax_117 != null)
		{
			Eq_4 ebx_427 = eax_117->t0008;
			Eq_4 ebp_72 = &eax_117->t0008;
			while (ebx_427 > 0x00)
			{
				Eq_4 esi_120 = ebx_427 - 0x01;
				if (esi_120 >= 0xCC)
					runtime.panicindex(gs);
				Eq_4 ebx_124 = ebx_427 - 0x05 + ebx_427 * 0x04;
				up32 edi_126 = eax_117->a0018[ebx_124];
				if (ecx_118 < edi_126 + 0x08)
				{
					word32 ebx_610;
					word32 edi_612;
					word32 esi_611;
					runtime.mallocgc(ebx_124, gs, edi_126 + 0x08, 0x00, 0x01, out ebx_610, out esi_611, out edi_612);
					edx_119 = dwLoc40;
					ecx_118 = edi_126 + 0x08;
				}
				if (eax_117->a001C[ebx_124] == 0x00)
					runtime.throw(gs);
				edx_119->u0 = 0x00;
				((word32) edx_119 + 4)->u0 = 0x00;
				Eq_4 ecx_175 = eax_117->a001C[ebx_124];
				word32 esi_176 = (word32) *((word32) ecx_175 + 0x0F);
				if (((byte) esi_176 & 0x1F) == 0x14)
				{
					Eq_4 esi_227 = eax_117->a0020[ebx_124];
					if (g_t81576F0 == 0x00)
						*edx_119 = esi_227;
					else
						runtime.writebarrierptr(edx_119, esi_227);
					Eq_4 esi_253 = (word32) edx_119 + 4;
					Eq_4 esi_258 = eax_117->a0014[ebx_124];
					if (g_t81576F0 == 0x00)
						*((word32) edx_119 + 4) = esi_258;
					else
						runtime.writebarrierptr(esi_253, esi_258);
					if (*((word32) ecx_175 + 40) != 0x00)
					{
						runtime.assertE2I(gs, ecx_175, *edx_119);
						if (g_t81576F0 == 0x00)
						{
							*edx_119 = dwLoc40;
							*((word32) edx_119 + 4) = dwLoc3C;
						}
						else
						{
							runtime.writebarrierptr(edx_119, dwLoc40);
							runtime.writebarrierptr(esi_253, dwLoc3C);
						}
					}
				}
				else
				{
					if (((byte) esi_176 & 0x1F) != 22)
						runtime.throw(gs);
					Eq_4 esi_206 = eax_117->a0014[ebx_124];
					if (g_t81576F0 == 0x00)
						*edx_119 = esi_206;
					else
						runtime.writebarrierptr(edx_119, esi_206);
				}
				g_b8157569 = 0x01;
				runtime.reflectcall(edi_126 + 0x08);
				g_b8157569 = 0x00;
				dwLoc40 = edi_126 + 0x08;
				dwLoc3C = edi_126 + 0x08;
				Eq_4 edx_373 = eax_117->a0010 + ebx_124;
				Eq_4 ebp_375 = eax_117->a0014 + ebx_124;
				esi = eax_117->a0020 + ebx_124;
				if (g_t81576F0 == 0x00)
				{
					eax_117->a0010[ebx_124].u0 = 0x00;
					eax_117->a0014[ebx_124] = 0x00;
					eax_117->a0020[ebx_124] = 0x00;
				}
				else
				{
					runtime.writebarrierptr(edx_373, 0x00);
					runtime.writebarrierptr(ebp_375, 0x00);
					runtime.writebarrierptr(esi, 0x00);
				}
				runtime/internal/atomic.Store(ebp_72, esi_120);
				ebx_427 = esi_120;
			}
			struct Eq_19457 * ecx_85 = eax_117->ptr0004;
			word32 edi_607;
			runtime.lock(esi, gs, 0x081575CC, out esi, out edi_607);
			eax_117->ptr0004 = runtime.finc;
			runtime.finc = eax_117;
			word32 ebx_609;
			word32 edx_608;
			runtime.unlock(gs, 0x081575CC, out edx_608, out ebx_609);
			eax_117 = ecx_85;
		}
		eax_17 = ecx_118;
		ecx_18 = edx_119;
	}
}

// 08059790: void runtime.SetFinalizer(Register Eq_4 esi, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C)
// Called from:
//      os.newFile
//      os.(*file).close
void runtime.SetFinalizer(Eq_4 esi, struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (g_dw8157748 != 0x00)
		return;
	if (dwArg04 == 0x00)
		runtime.throw(gs);
	if ((*((word32) dwArg04 + 0x0F) & 0x1F) != 22)
	{
		runtime.(*_type).string(gs, dwArg04);
		runtime.concatstring3(gs, 0x00);
		runtime.throw(gs);
	}
	if (*((word32) dwArg04 + 32) == 0x00)
		runtime.throw(gs);
	runtime.findObject(esi, gs, dwArg08);
	if (dwLoc70 == 0x00)
	{
		if (dwArg08 == 0x0815765C)
			return;
		struct Eq_20279 * ecx_128;
		for (ecx_128 = &g_t8139420; ecx_128 != null; ecx_128 = ecx_128->ptr00D8)
		{
			if (ecx_128->t0038 <= dwArg08 && dwArg08 < ecx_128->t003C || (ecx_128->t0040 <= dwArg08 && dwArg08 < ecx_128->t0044 || (ecx_128->t0048 <= dwArg08 && dwArg08 < ecx_128->t004C || ecx_128->t0050 <= dwArg08 && dwArg08 < ecx_128->t0054)))
				return;
		}
		runtime.throw(gs);
	}
	if (dwArg08 != dwLoc70)
	{
		Eq_4 edx_194 = *((word32) dwArg04 + 32);
		if (edx_194 == 0x00 || ((*((word32) edx_194 + 0x0F) & 0x80) == 0x00 || *edx_194 >= 0x10))
			runtime.throw(gs);
	}
	if (dwArg0C == 0x00)
	{
		word32 edi_1022;
		word32 ebp_1021;
		runtime.systemstack(gs, fp - 0x20, out ebp_1021, out edi_1022);
		return;
	}
	if ((*((word32) dwArg0C + 0x0F) & 0x1F) != 0x13)
	{
		runtime.(*_type).string(gs, dwArg0C);
		runtime.concatstring3(gs, 0x00);
		runtime.throw(gs);
	}
	if ((*((word32) dwArg0C + 0x0022) & 0x8000) != 0x00)
	{
		runtime.(*_type).string(gs, dwArg04);
		runtime.(*_type).string(gs, dwArg0C);
		runtime.concatstring5(gs, 0x00);
		runtime.throw(gs);
	}
	Eq_4 bx_369 = *((word32) dwArg0C + 32);
	if (bx_369 != 0x01)
	{
		runtime.(*_type).string(gs, dwArg04);
		runtime.(*_type).string(gs, dwArg0C);
		runtime.concatstring4(gs, 0x00);
		runtime.throw(gs);
	}
	word32 ebp_446;
	if ((*((word32) dwArg0C + 0x0C) & 0x01) != 0x00)
		ebp_446 = 0x34;
	else
		ebp_446 = 0x24;
	union Eq_4 * ebp_451 = (word32) dwArg0C + ebp_446;
	up32 ebx_457 = (word32) bx_369;
	if (ebx_457 > 0x00100000)
		runtime.panicslice(gs);
	if (ebx_457 <= 0x00)
		runtime.panicindex(gs);
	Eq_4 ebx_465 = *ebp_451;
	if (ebx_465 == dwArg04)
	{
l080598B4:
		(*((word32) dwArg0C + 0x0C) & 0x01) == 0x00;
		word32 edx_643 = (word32) *((word32) dwArg0C + 32);
		up32 esi_645 = (word32) (word16) edx_643;
		up32 edx_648 = (word32) ((word16) edx_643 + (*((word32) dwArg0C + 0x0022) & 0x7FFF));
		if (esi_645 > edx_648 || edx_648 > 0x00100000)
			runtime.panicslice(gs);
		else
		{
			Eq_20192 edx_656 = edx_648 - esi_645;
			Eq_20192 ebp_678 = 0x00;
			while (ebp_678 < edx_656)
				ebp_678 = (word32) ebp_678.u0 + 1;
			runtime.createfing(gs);
			fn0808FD8A(0x00, fp - 0x18);
			word32 ebp_1023;
			word32 edi_1024;
			runtime.systemstack(gs, fp - 0x1C, out ebp_1023, out edi_1024);
			return;
		}
	}
	word32 ebp_473 = (word32) *((word32) ebx_465 + 0x0F);
	if (((byte) ebp_473 & 0x1F) != 22)
	{
		if (((byte) ebp_473 & 0x1F) == 0x14)
		{
			if (*((word32) ebx_465 + 40) == 0x00)
				goto l080598B4;
			runtime.assertE2I2(gs, dwArg04);
			if (bLoc64 != 0x00)
				goto l080598B4;
		}
		goto l08059B1B;
	}
	runtime.(*_type).uncommon(gs, ebx_465);
	if (dwLoc74 != 0x00)
	{
		runtime.(*_type).uncommon(gs, dwArg04);
		if (dwLoc74 != 0x00)
			goto l08059B1B;
	}
	if (*((word32) ebx_465 + 32) == *((word32) dwArg04 + 32))
		goto l080598B4;
l08059B1B:
	runtime.(*_type).string(gs, dwArg04);
	runtime.(*_type).string(gs, dwArg0C);
	runtime.concatstring4(gs, 0x00);
	runtime.throw(gs);
}

// 08059E00: void runtime.findObject(Register Eq_4 esi, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      runtime.SetFinalizer
//      runtime.addfinalizer
void runtime.findObject(Eq_4 esi, struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 edx_20 = *((word32) *((word32) gs->ptr0000->tFFFFFFFC + 24) + 0x00B8);
	up32 ecx_24 = *((word32) edx_20 + 588);
	*((word32) edx_20 + 588) = ecx_24 + 0x01;
	if (ecx_24 >= 0x3FFFFFFF)
	{
		word32 esi_246;
		word32 edi_247;
		runtime.lock(esi, gs, 0x081488E0, out esi_246, out edi_247);
		runtime.purgecachedstats(gs, edx_20);
		word32 ebx_249;
		word32 edx_248;
		runtime.unlock(gs, 0x081488E0, out edx_248, out ebx_249);
	}
	Eq_4 ecx_66 = g_t81493A8;
	Eq_4 edx_67 = g_t81493AC;
	if (dwArg04 < ecx_66 || dwArg04 >= edx_67)
		return;
	Eq_4 eax_78 = (dwArg04 >> 0x0D) - (ecx_66 >> 0x0D);
	Eq_4 ebx_80 = g_t8149108;
	if (eax_78 >= g_t814910C)
		runtime.panicindex(gs);
	else
	{
		struct Eq_20396 * ecx_84 = *((word32) ebx_80 + eax_78 * 0x04);
		if (ecx_84 == null)
			return;
		if (dwArg04 < ecx_84->t000C || (dwArg04 >= ecx_84->t0050 || ecx_84->b003C != 0x01))
			return;
		word32 esi_110 = ecx_84->dw0040;
		if (ecx_84->b003A >> 0x01 == 0x00 || esi_110 != 0x00)
			return;
		runtime.panicdivide(gs);
	}
}

// 08059F80: void runtime.(*fixalloc).alloc(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_18207) dwArg04)
// Called from:
//      runtime.allocmcache
//      runtime.(*mTreap).insert
//      runtime.(*mheap).allocSpanLocked
//      runtime.(*mheap).grow
//      runtime.addfinalizer
//      runtime.setprofilebucket
void runtime.(*fixalloc).alloc(struct Eq_2 * gs, struct Eq_18207 * dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 ecx_18 = dwArg04->t0000;
	if (ecx_18 == 0x00)
	{
		runtime.printlock(gs);
		runtime.printstring(gs);
		runtime.printunlock(gs);
		runtime.throw(gs);
	}
	else
	{
		Eq_4 ebx_44 = dwArg04->t000C;
		if (ebx_44 == 0x00)
		{
			if (dwArg04->t0014 < ecx_18)
			{
				runtime.persistentalloc(gs);
				dwArg04->dw0010 = dwLoc0C;
				dwArg04->t0014.u0 = 0x4000;
			}
			word32 ecx_66 = dwArg04->dw0010;
			<anonymous> ** edx_67 = dwArg04->ptr0004;
			if (edx_67 != null)
				(*edx_67)();
			dwArg04->dw0010 = (word32) dwArg04->t0000 + dwArg04->dw0010;
			dwArg04->t0014 -= dwArg04->t0000;
			dwArg04->dw0018 = (word32) dwArg04->t0000 + dwArg04->dw0018;
		}
		else
		{
			dwArg04->t000C = *ebx_44;
			dwArg04->dw0018 = (word32) dwArg04->t0000 + dwArg04->dw0018;
			if (dwArg04->b0020 != 0x00)
				runtime.memclrNoHeapPointers(ebx_44, dwArg04->t0000);
		}
	}
}

// 0805A0B0: void runtime.gcinit(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.schedinit
void runtime.gcinit(struct Eq_2 * gs)
{
	Eq_4 dwLoc04_94 = SLICE(rLoc08, word32, 32);
	Eq_4 dwLoc08_95 = (word32) rLoc08;
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	g_t81490F4.u0 = 0x01;
	g_r81597A0 = (real64) (uint128) g_r80F1848;
	runtime.uint64tofloat64(gs, g_t81360FC);
	real64 v13_40 = (real64) (uint128) rLoc08 / ((real64) ((uint128) g_r80F1858) + (real64) ((uint128) g_r81597A0));
	runtime.float64touint64(gs, v13_40);
	g_t81597C0 = dwLoc08_95;
	g_t81597C4 = dwLoc04_94;
	runtime/debug.setGCPercent(runtime.readgogc(gs), gs, (word32) v13_40);
	g_dw814562C = 0x01;
	g_dw8145630 = 0x01;
}

// 0805A170: Register word32 runtime.readgogc(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.gcinit
word32 runtime.readgogc(struct Eq_2 * gs)
{
	byte bLoc04_89 = (byte) dwLoc04;
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	word32 esi_27 = runtime.gogetenv(gs, 0x080E0ED6, 0x04);
	if (dwLoc04 == 0x03 && (*dwLoc08 == 0x666F && *((word32) dwLoc08 + 2) == 0x66))
		return esi_27;
	word32 esi_59;
	runtime.atoi32(gs, dwLoc08, dwLoc04, out esi_59);
	if (bLoc04_89 == 0x00)
		return esi_59;
	return esi_59;
}

// 0805A200: Register Eq_4 runtime.gcenable(Register Eq_4 ebp, Register word32 edi, Register (ptr32 Eq_2) gs, Register out ptr32 ediOut)
// Called from:
//      runtime.main
Eq_4 runtime.gcenable(Eq_4 ebp, word32 edi, struct Eq_2 * gs, ptr32 & ediOut)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 esi_32;
	Eq_4 ebp_27 = runtime.makechan(ebp, edi, gs, &g_t80CA680, 0x01, 0x00, out esi_32);
	runtime.newproc();
	ptr32 edi_60;
	Eq_4 ebp_57 = runtime.chanrecv1(ebp_27, esi_32, gs, dwLoc08, 0x00, out edi_60);
	g_b8159250 = 0x01;
	ediOut = edi_60;
	return ebp_57;
}

// 0805A280: void runtime/debug.setGCPercent(Register Eq_4 esi, Register (ptr32 Eq_2) gs, Stack Eq_20602 dwArg04)
// Called from:
//      runtime.gcinit
void runtime/debug.setGCPercent(Eq_4 esi, struct Eq_2 * gs, Eq_20602 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	ui32 edi_27;
	Eq_4 esi_28;
	runtime.lock(esi, gs, 0x081488E0, out esi_28, out edi_27);
	Eq_20602 ecx_35 = dwArg04;
	if (dwArg04 < 0x00)
		ecx_35.u0 = ~0x00;
	runtime.gcpercent = ecx_35;
	runtime.uint64div(gs, ecx_35 << 22, ecx_35 >> 0x1F << 22 | ecx_35 >> 0x0A, 100, 0x00);
	g_t81360F8 = dwLoc0C;
	g_t81360FC = dwLoc08;
	Eq_662 xmm0_68 = (uint128) g_r81597A0;
	runtime.gcSetTriggerRatio(esi_28, edi_27, gs, xmm0_68, (real64) xmm0_68);
	word32 ebx_130;
	word32 edx_129;
	runtime.unlock(gs, 0x081488E0, out edx_129, out ebx_130);
}

// 0805A340: void runtime.setGCPhase(Stack Eq_4 dwArg04)
// Called from:
//      runtime.gcStart
//      runtime.gcMarkTermination
//      runtime.gcMarkTermination.func2
void runtime.setGCPhase(Eq_4 dwArg04)
{
	int8 al_17;
	runtime/internal/atomic.Store(135624164, dwArg04);
	word32 eax_12 = runtime.gcphase;
	if (eax_12 == 0x01)
		al_17 = 0x01;
	else
		al_17 = (int8) (eax_12 == 0x02);
	uip32 eax_25;
	g_b81576F4 = al_17;
	if (al_17 != 0x00)
		eax_25 = 0x01;
	else
		eax_25 = (word32) g_b81576F5;
	g_t81576F0 = (byte) eax_25;
}

// 0805A3A0: void runtime.(*gcControllerState).startCycle(Register Eq_4 edi, Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_18632) dwArg04)
// Called from:
//      runtime.gcStart
void runtime.(*gcControllerState).startCycle(Eq_4 edi, struct Eq_2 * gs, struct Eq_18632 * dwArg04)
{
	Eq_4 dwLoc3C_459 = SLICE(rLoc40, word32, 32);
	Eq_4 dwLoc40_460 = (word32) rLoc40;
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	dwArg04->dw0000 = 0x00;
	dwArg04->dw0004 = 0x00;
	dwArg04->dw0008 = 0x00;
	dwArg04->dw000C = 0x00;
	dwArg04->dw0010 = 0x00;
	dwArg04->dw0014 = 0x00;
	dwArg04->dw0018 = 0x00;
	dwArg04->dw001C = 0x00;
	dwArg04->dw0020 = 0x00;
	dwArg04->dw0024 = 0x00;
	dwArg04->dw0028 = 0x00;
	dwArg04->dw002C = 0x00;
	Eq_4 edx_30 = g_t81597AC;
	Eq_4 ebp_32 = g_t81360FC;
	Eq_4 esi_33 = g_t81360F8;
	if (((int8) (g_t81597A8 <= esi_33) & (int8) (edx_30 == ebp_32) | (int8) (edx_30 < ebp_32)) != 0x00)
	{
		runtime.uint64tofloat64(gs, edx_30);
		uint128 xmm2_91 = (uint128) g_r80F1858;
		real64 v37_92 = (real64) xmm2_91 + (real64) ((uint128) g_r81597A0);
		runtime.float64touint64(gs, (real64) (uint128) rLoc40 / v37_92);
		g_t81597C0 = dwLoc40_460;
		g_t81597C4 = dwLoc3C_459;
		xmm2 = SEQ(SLICE(xmm2_91, word64, 64), v37_92);
	}
	Eq_4 eax_108 = g_t81597C0;
	Eq_20602 ecx_111 = runtime.gcpercent;
	uint64 edx_eax_113 = ecx_111 *64 eax_108;
	Eq_4 ebp_114 = g_t81597C4;
	runtime.uint64div(gs, (word32) edx_eax_113, (ecx_111 >> 0x1F) *s eax_108 + (SLICE(edx_eax_113, word32, 32) + ecx_111 *s ebp_114), 100, 0x00);
	int64 ecx_ecx_451 = SEQ(ebp_114, dwLoc38) + SEQ(dwLoc34, eax_108);
	g_t8158228 = (word32) ecx_ecx_451;
	g_t815822C = SLICE(ecx_ecx_451, word32, 32);
	if (runtime.gcpercent < 0x00)
	{
		g_t8158228.u0 = ~0x00;
		g_t815822C.u0 = ~0x00;
	}
	Eq_4 eax_152 = g_t81597B0;
	Eq_4 ecx_155 = g_t815822C;
	Eq_4 edx_156 = g_t8158228;
	word32 ebx_159 = Mem151[0x081597B4<p32>:word32] + (eax_152 <u 0x00100000);
	if (((int8) (ecx_155 == ebx_159) & (int8) (edx_156 < (word32) eax_152 + 0x00100000) | (int8) (ecx_155 < ebx_159)) != 0x00)
	{
		g_t8158228 = (word32) eax_152 + 0x00100000;
		g_t815822C = ebx_159;
	}
	real64 v42_206 = (real64) runtime.gomaxprocs * (real64) ((uint128) g_r80F1838);
	word128 xmm0_588;
	runtime.float64toint64(gs, v42_206, out xmm0_588);
	dwArg04->t0038.u0 = 100;
	dwArg04->dw003C = 0x00;
	runtime.int64tofloat64(ebx_24_8, gs, 100);
	Eq_662 xmm0_232 = (uint128) 4.94e-322;
	Eq_21011 v44_234 = (real64) (uint128) v42_206 - (real64) xmm0_232;
	dwArg04->t0050 = v44_234;
	if (v44_234 > (real64) __xorps(xmm0_232, xmm0_232))
	{
		dwArg04->t0098.u0 = 0x01;
		dwArg04->dw009C = 0x00;
	}
	else
	{
		dwArg04->t0098.u0 = 0x00;
		dwArg04->dw009C = 0x00;
	}
	int32 ecx_250;
	word32 * edx_253 = g_a81478C0;
	for (ecx_250 = 0x00; ecx_250 < 0x0401; ++ecx_250)
	{
		Eq_4 ebx_259 = *edx_253;
		if (ebx_259 == 0x00)
			break;
		*((word32) ebx_259 + 0x0940) = 0x00;
		*((word32) ebx_259 + 0x0944) = 0x00;
		++edx_253;
	}
	runtime.(*gcControllerState).revise(ebp, gs, dwArg04);
	if (g_dw8157730 > 0x00)
	{
		real64 rLoc08_508 = (real64) (uint128) dwArg04->r0040;
		uint32 ecx_295 = g_dw81597BC;
		uint32 edx_297 = g_dw81597B8;
		Eq_4 ebx_299 = g_t8145650;
		Eq_4 ebp_301 = g_t814564C;
		Eq_4 esi_303 = g_t815822C;
		Eq_4 edi_305 = g_t8158228;
		Eq_4 esi_309 = dwArg04->t0038;
		Eq_4 eax_313 = dwArg04->t0098;
		runtime.printlock(gs);
		runtime.printstring(gs);
		word128 xmm2_591;
		runtime.printfloat(gs, xmm2, (real64) (uint128) rLoc08_508, out xmm2_591);
		runtime.printstring(gs);
		runtime.printuint(ebp, gs, ecx_295 << 0x0C | edx_297 >> 0x14, ecx_295 >> 0x14);
		runtime.printstring(gs);
		runtime.printuint(ebp, gs, ebx_299 << 0x0C | ebp_301 >> 0x14, ebx_299 >> 0x14);
		runtime.printstring(gs);
		runtime.printuint(ebp, gs, esi_303 << 0x0C | edi_305 >> 0x14, esi_303 >> 0x14);
		runtime.printstring(gs);
		runtime.printstring(gs);
		runtime.printint(ebx_24_8, gs, esi_309);
		runtime.printstring(gs);
		runtime.printint(ebx_24_8, gs, eax_313);
		runtime.printstring(gs);
		runtime.printunlock(gs);
	}
}

// 0805A820: void runtime.(*gcControllerState).revise(Register Eq_4 ebp, Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_18632) dwArg04)
// Called from:
//      runtime.(*mcentral).cacheSpan
//      runtime.(*gcControllerState).startCycle
//      runtime.gcSetTriggerRatio
//      runtime.(*mheap).alloc_m
//      runtime.(*mheap).freeSpan.func1
void runtime.(*gcControllerState).revise(Eq_4 ebp, struct Eq_2 * gs, struct Eq_18632 * dwArg04)
{
	word32 dwLoc20 = SLICE(qwLoc24, word32, 32);
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	ui32 ebx_23 = dwArg04->dw0004;
	ui64 edx_eax_178 = SEQ(edx_22, g_dw81597B8) - SEQ(ebx_23, dwArg04->dw0000);
	Eq_4 eax_20 = (word32) edx_eax_178;
	int32 edx_25 = SLICE(edx_eax_178, word32, 32);
	uint32 edx_22 = g_dw81597BC;
	Eq_4 eax_59 = eax_20;
	if (((int8) (eax_20 < 1000) & (int8) (edx_25 == 0x00) | (int8) (edx_25 < 0x00)) != 0x00)
	{
		eax_59.u0 = 1000;
		edx_25 = 0x00;
	}
	word64 mm0_223;
	runtime/internal/atomic.Load64(135632816, out mm0_223);
	ui64 ecx_eax_181 = SEQ(ecx_83, g_t8158228) - qwLoc24;
	int32 ecx_86 = SLICE(ecx_eax_181, word32, 32);
	Eq_4 eax_109 = (word32) ecx_eax_181;
	Eq_4 ecx_83 = g_t815822C;
	if (((int8) (eax_109 <= 0x00) & (int8) (ecx_86 == 0x00) | (int8) (ecx_86 < 0x00)) != 0x00)
		eax_109.u0 = 0x01;
	runtime.int64tofloat64(SLICE(edx_25, word24, 8), gs, eax_59);
	runtime.int64tofloat64(ebx_24_8, gs, eax_109);
	real64 rLoc20_208 = SEQ(dwLoc1C, dwLoc20);
	dwArg04->r0040 = (real64) (uint128) (real64) (uint128) rLoc20_208 / (real64) ((uint128) rLoc20_208);
	runtime.int64tofloat64(ebx_24_8, gs, eax_109);
	runtime.int64tofloat64(ebx_24_8, gs, eax_59);
	dwArg04->r0048 = (real64) (uint128) (real64) (uint128) rLoc20_208 / (real64) ((uint128) rLoc20_208);
}

// 0805A980: void runtime.(*gcControllerState).endCycle(Register word32 ebp, Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_21282) dwArg04)
// Called from:
//      runtime.gcMarkDone
void runtime.(*gcControllerState).endCycle(word32 ebp, struct Eq_2 * gs, struct Eq_21282 * dwArg04)
{
	Eq_4 dwLoc7C_500 = (word32) rLoc7C;
	while (fp - 0x04 <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (g_b8145640 != 0x00)
		return;
	uint128 xmm3_167;
	Eq_20602 eax_27 = runtime.gcpercent;
	runtime.uint64tofloat64(gs, g_t81597B4);
	Eq_4 eax_39 = g_t81597C4;
	Eq_4 ecx_40 = g_t81597C0;
	runtime.uint64tofloat64(gs, eax_39);
	runtime.nanotime();
	uint128 xmm0_47 = (uint128) rLoc7C;
	uint128 xmm1_70 = (uint128) (real64) (uint128) rLoc7C;
	ui32 ebx_81 = dwArg04->dw0034;
	word64 edx_eax_457 = SEQ(eax_39, ecx_40) - SEQ(ebx_81, dwArg04->dw0030);
	real64 v16_66 = (real64) eax_27 / (real64) ((uint128) g_r80F1880);
	real64 v21_76 = (real64) xmm1_70 / (real64) ((uint128) ((real64) xmm0_47)) - (real64) ((uint128) g_r80F1858);
	int32 edx_83 = SLICE(edx_eax_457, word32, 32);
	uint32 eax_60 = (word32) edx_eax_457;
	uint128 xmm0_169 = SEQ(SLICE(xmm0_47, word64, 64), v16_66);
	uint128 xmm1_170 = SEQ(SLICE(xmm1_70, word64, 64), v21_76);
	if (((int8) (edx_83 > 0x00) | (int8) (edx_83 == 0x00) & (int8) (eax_60 > 0x00)) == 0x00)
		xmm3_167 = (uint128) g_r80F1838;
	else
	{
		runtime.int64tofloat64(SLICE(ebx_149, word24, 8), gs, dwArg04->t0010);
		Eq_4 eax_136 = runtime.gomaxprocs;
		int32 ebx_149 = edx_83 *s eax_136;
		runtime.int64tofloat64(SLICE(ebx_149, word24, 8), gs, eax_136 * eax_60);
		uint128 xmm3_160 = (uint128) (real64) (uint128) rLoc7C;
		xmm3_167 = SEQ(SLICE(xmm3_160, word64, 64), (real64) xmm3_160 / (real64) ((uint128) rLoc7C) + (real64) ((uint128) g_r80F1838));
		xmm0_169 = (uint128) v16_66;
		xmm1_170 = (uint128) v21_76;
	}
	uint128 xmm4_174 = (uint128) g_r81597A0;
	real64 v34_176 = (real64) xmm0_169 - (real64) xmm4_174;
	real64 v37_183 = (real64) (uint128) g_r80F1860 * (real64) xmm3_167;
	real64 v39_187 = (real64) xmm1_170 - (real64) xmm4_174;
	if (g_dw8157730 > 0x00)
	{
		real64 rLoc28_481 = g_r81597A0;
		Eq_4 eax_211 = g_t81597C4;
		Eq_4 ecx_213 = g_t81597C0;
		Eq_4 edx_215 = g_t81597AC;
		Eq_4 ebx_217 = g_t81597A8;
		Eq_4 ebp_219 = g_t81597B4;
		Eq_4 esi_221 = g_t81597B0;
		runtime.uint64tofloat64(gs, eax_211);
		Eq_662 xmm2_232 = (uint128) v16_66;
		word128 xmm0_612;
		runtime.float64toint64(gs, ((real64) (uint128) g_r80F1858 + (real64) xmm2_232) * (real64) ((uint128) rLoc7C), out xmm0_612);
		word32 ebx_249 = dwArg04->dw0004;
		Eq_4 edx_251 = dwArg04->t0000;
		runtime.printlock(gs);
		runtime.printstring(gs);
		runtime.printuint(ebp_219, gs, ecx_213, eax_211);
		runtime.printstring(gs);
		word128 xmm2_613;
		runtime.printfloat(gs, xmm2_232, (real64) (uint128) rLoc28_481, out xmm2_613);
		runtime.printstring(gs);
		runtime.printuint(ebp_219, gs, ebx_217, edx_215);
		runtime.printstring(gs);
		word128 xmm2_614;
		runtime.printfloat(gs, xmm2_232, (real64) (uint128) v21_76, out xmm2_614);
		runtime.printstring(gs);
		runtime.printuint(ebp_219, gs, esi_221, ebp_219);
		runtime.printstring(gs);
		word128 xmm2_615;
		runtime.printfloat(gs, xmm2_232, (real64) (uint128) v16_66, out xmm2_615);
		runtime.printstring(gs);
		runtime.printint(SLICE(ebx_249, word24, 8), gs, dwLoc7C_500);
		runtime.printstring(gs);
		word128 xmm2_616;
		runtime.printfloat(gs, xmm2_232, (real64) (uint128) (real64) xmm3_167, out xmm2_616);
		runtime.printstring(gs);
		word128 xmm2_617;
		runtime.printfloat(gs, xmm2_232, (real64) (uint128) g_r80F1838, out xmm2_617);
		runtime.printstring(gs);
		runtime.printint(SLICE(ebx_249, word24, 8), gs, edx_251);
		runtime.printstring(gs);
		word128 xmm2_618;
		runtime.printfloat(gs, xmm2_232, (real64) (uint128) v34_176, out xmm2_618);
		runtime.printstring(gs);
		word128 xmm2_619;
		runtime.printfloat(gs, xmm2_232, (real64) (uint128) v39_187, out xmm2_619);
		runtime.printstring(gs);
		word128 xmm2_620;
		runtime.printfloat(gs, xmm2_232, (real64) (uint128) v37_183, out xmm2_620);
		runtime.printstring(gs);
		runtime.printunlock(gs);
	}
}

// 0805AE70: void runtime.(*gcControllerState).enlistWorker(Register word24 ebx_24_8, Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_21580) dwArg04)
// Called from:
//      runtime.(*gcWork).put
//      runtime.(*gcWork).balance
void runtime.(*gcControllerState).enlistWorker(word24 ebx_24_8, struct Eq_2 * gs, struct Eq_21580 * dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	up32 ecx_18 = dwArg04->dw0038;
	int32 edx_17 = dwArg04->dw003C;
	if (((int8) (edx_17 < 0x00) | (int8) (edx_17 == 0x00) & (int8) (ecx_18 <= 0x00)) != 0x00)
		return;
	if (runtime.gomaxprocs <= 0x01)
		return;
	Eq_4 ecx_46 = gs->ptr0000->tFFFFFFFC;
	if (ecx_46 == 0x00)
		return;
	Eq_4 ecx_50 = *((word32) ecx_46 + 24);
	if (ecx_50 == 0x00)
		return;
	Eq_4 ecx_54 = *((word32) ecx_50 + 92);
	if (ecx_54 == 0x00)
		return;
	Eq_4 ecx_58 = *((word32) ecx_54 + 4);
	int32 eax_159;
	for (eax_159 = 0x00; eax_159 < 0x05; ++eax_159)
	{
		Eq_4 edx_69 = *((word32) gs->ptr0000->tFFFFFFFC + 24);
		int32 ebp_71 = *((word32) edx_69 + 0x0094);
		Eq_4 ebx_70 = runtime.gomaxprocs;
		int32 esi_76 = ebp_71 << 0x01 ^ ebp_71 >> 0x1F & 0xA8888EEF;
		*((word32) edx_69 + 0x0094) = esi_76;
		if (ebx_70 == 0x01)
			runtime.panicdivide(gs);
		Eq_4 edx_100 = (uint32) ((uint64) esi_76 % (ebx_70 - 0x01));
		if (edx_100 >= ecx_58)
			edx_100 = (word32) edx_100 + 1;
		if (edx_100 >= 0x0401)
			runtime.panicindex(gs);
		struct Eq_21689 * edx_115 = *((char *) g_a81478C0 + edx_100 * 0x04);
		if (edx_115->dw0008 == 0x01)
		{
			byte al_145;
			Eq_4 edx_119 = edx_115->t0030;
			if (edx_119 != 0x00 && edx_119 != *((word32) (gs->ptr0000)->tFFFFFFFC + 24))
			{
				struct Eq_21718 * esi_129 = *((word32) edx_119 + 84);
				if (esi_129 != null && esi_129 != *edx_119)
				{
					esi_129->b006C = 0x01;
					esi_129->dw0008 = ~0x0521;
					al_145 = 0x01;
				}
				else
					al_145 = 0x00;
			}
			else
				al_145 = 0x00;
			if (al_145 != 0x00)
				return;
		}
	}
}

// 0805AFC0: void runtime.(*gcControllerState).findRunnableGCWorker(Register Eq_4 esi, Register word32 edi, Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_21743) dwArg04, Stack Eq_4 dwArg08)
// Called from:
//      runtime.schedule
void runtime.(*gcControllerState).findRunnableGCWorker(Eq_4 esi, word32 edi, struct Eq_2 * gs, struct Eq_21743 * dwArg04, Eq_4 dwArg08)
{
	byte bLoc28 = (byte) dwLoc28;
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (runtime.gcBlackenEnabled == 0x00)
		runtime.throw(gs);
	else
	{
		if (*((word32) dwArg08 + 0x0948) == 0x00)
			return;
		runtime.gcMarkWorkAvailable(gs, dwArg08);
		if (bLoc28 == 0x00)
			return;
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_4 stackArg0 = <invalid>;
		runtime.(*gcControllerState).findRunnableGCWorker.func1(SLICE(ebx, word24, 8), gs, stackArg0, (char *) &dwArg04->t0020 + 24);
		if (bLoc28 != 0x00)
			((word32) dwArg08 + 0x094C)->u0 = 0x00;
		else
		{
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_4 stackArg0 = <invalid>;
			runtime.(*gcControllerState).findRunnableGCWorker.func1(g_n80E7B69, gs, stackArg0, &dwArg04->r0050 + 9);
			if (bLoc28 == 0x00)
				return;
			runtime.nanotime();
			ui64 ecx_eax_245 = SEQ(dwLoc28, &dwArg04->r0050 + 9) - SEQ(edx_97, g_t8157890);
			Eq_4 eax_94 = (word32) ecx_eax_245;
			int32 ecx_99 = SLICE(ecx_eax_245, word32, 32);
			Eq_4 edx_97 = g_t8157894;
			Eq_4 ebx_101 = dwArg04->t0020;
			if (((int8) (ecx_99 > 0x00) | (int8) (ecx_99 == 0x00) & (int8) (eax_94 > 0x00)) != 0x00)
			{
				runtime.int64tofloat64(SLICE(ebx_101, word24, 8), gs, ebx_101);
				runtime.int64tofloat64(SLICE(ebx_101, word24, 8), gs, eax_94);
				if ((real64) (uint128) (real64) (uint128) rLoc24 / (real64) ((uint128) rLoc24) > (real64) ((uint128) dwArg04->r0050))
				{
					word32 ebx_375;
					word32 ebp_376;
					runtime/internal/atomic.Xaddint64(&dwArg04->r0050 + 9, 0x01, 0x00, out ebx_375, out ebp_376);
					return;
				}
			}
			((word32) dwArg08 + 0x094C)->u0 = 0x01;
		}
		Eq_4 eax_207 = *((word32) dwArg08 + 0x0948);
		runtime.casgstatus(eax_207, 0x04, 0x01);
		if (g_b814F4C8 != 0x00)
			runtime.traceGoUnpark(gs, eax_207);
	}
}

// 0805B1E0: void runtime.gcSetTriggerRatio(Register Eq_4 esi, Register ui32 edi, Register (ptr32 Eq_2) gs, Register Eq_662 xmm0, Stack Eq_4 rArg04)
// Called from:
//      runtime/debug.setGCPercent
//      runtime.gcMarkTermination
void runtime.gcSetTriggerRatio(Eq_4 esi, ui32 edi, struct Eq_2 * gs, Eq_662 xmm0, Eq_4 rArg04)
{
	word32 dwLoc68 = (word32) qwLoc68;
	ui32 dwLoc64 = SLICE(qwLoc68, word32, 32);
	Eq_4 dwLoc6C_834 = SLICE(rLoc70, word32, 32);
	Eq_4 dwLoc70_835 = (word32) rLoc70;
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_662 xmm1_51;
	Eq_662 xmm0_21 = __xorps(xmm0, xmm0);
	Eq_662 xmm1_22 = (uint128) rArg04;
	if ((real64) xmm0_21 > (real64) xmm1_22)
		xmm1_51 = __xorps(xmm1_22, xmm1_22);
	else
	{
		word128 xmm2_33;
		Eq_20602 ecx_27 = runtime.gcpercent;
		if (ecx_27 >= 0x00)
		{
			word64 v88_38 = SLICE(xmm2, word64, 64);
			Eq_22326 v89_41 = (real64) ecx_27 * (real64) ((uint128) g_r80F1850) / (real64) ((uint128) g_r80F1880);
			xmm2_33 = SEQ(v88_38, v89_41);
			if ((real64) xmm1_22 <= v89_41)
				xmm2_33 = SEQ(v88_38, (real64) xmm1_22);
		}
		else
			xmm2_33 = SEQ(SLICE(xmm2, word64, 64), (real64) xmm1_22);
		xmm1_51 = SEQ(SLICE(xmm1_22, word64, 64), (real64) xmm2_33);
	}
	word64 ecx_eax_1104;
	g_r81597A0 = (real64) xmm1_51;
	if (runtime.gcpercent < 0x00)
		ecx_eax_1104 = ~0x00;
	else
	{
		runtime.uint64tofloat64(gs, g_t81597C4);
		real64 rLoc08_822 = (real64) xmm1_51;
		Eq_662 xmm2_79 = (uint128) rLoc08_822;
		Eq_662 xmm0_77 = (uint128) rLoc70;
		real64 v59_83 = ((real64) (uint128) g_r80F1858 + (real64) xmm2_79) * (real64) xmm0_77;
		runtime.float64touint64(gs, v59_83);
		dwLoc74 = SLICE(v59_83, word32, 32);
		Eq_4 edx_141 = g_t81360FC;
		Eq_4 ebx_187 = g_t81360F8;
		Eq_4 ebp_146 = g_t81490F4;
		if (ebp_146 == 0x00)
		{
			word64 mm0_1110;
			runtime/internal/atomic.Load64(135632816, out mm0_1110);
			Eq_20602 edx_116 = runtime.gcpercent;
			Eq_4 ebx_124 = edx_116 >> 0x1F << 0x14 | edx_116 >> 0x0C;
			runtime.uint64div(gs, edx_116 << 0x14, ebx_124, 100, 0x00);
			word64 edx_eax_819 = SEQ(dwLoc70_835, dwLoc68) + SEQ(dwLoc64, dwLoc74);
			edx_141 = SLICE(edx_eax_819, word32, 32);
			word24 ebx_24_8_160 = SLICE(esi, word24, 8);
			Eq_4 ebx_173 = SEQ(ebx_24_8_160, (int8) (edx_141 > edx_141));
			Eq_4 eax_136 = (word32) edx_eax_819;
			dwLoc74 = ebx_124;
			ebp_146 = ebx_187;
			esi = ebx_173;
			rLoc70 = 4.94e-322;
			if (((int8) (edx_141 == edx_141) & (int8) (eax_136 > ebx_187) | (int8) (edx_141 > edx_141)) == 0x00)
				eax_136 = ebx_187;
			ebx_187 = eax_136;
		}
		Eq_4 edx_247;
		ui24 ebx_24_8_202 = SLICE(ebp_146, word24, 8);
		Eq_4 ebx_229 = SEQ(ebx_24_8_202, (int8) (dwLoc6C_834 < edx_141));
		ui32 esi_232 = SEQ(SLICE(esi, word24, 8), (int8) (dwLoc70_835 < ebx_187)) & SEQ(ebx_24_8_202, (int8) (dwLoc6C_834 == edx_141)) | ebx_229;
		Eq_4 ebp_230 = ebx_229;
		Eq_4 ebx_231 = ebx_187;
		if ((byte) esi_232 != 0x00)
			edx_247 = edx_141;
		else
		{
			ebp_230 = dwLoc6C_834;
			ebx_231 = dwLoc70_835;
			edx_247 = dwLoc6C_834;
		}
		ui24 ebx_24_8_260 = SLICE(ebp_230, word24, 8);
		esi = SEQ(SLICE(esi_232, word24, 8), (int8) Test(ULT,false)) & SEQ(ebx_24_8_260, (int8) (edx_247 == 0x00));
		Eq_4 ebp_287 = SEQ(ebx_24_8_260, (int8) (edx_247 < 0x00)) | esi;
		ebp = ebp_287;
		if ((byte) ebp_287 != 0x00)
		{
			Eq_4 eax_304 = g_t815822C;
			Eq_4 ecx_306 = g_t8158228;
			Eq_4 edx_308 = g_t81597C4;
			Eq_4 ebx_310 = g_t81597C0;
			Eq_4 ebp_312 = g_t81597B4;
			Eq_4 esi_314 = g_t81597B0;
			Eq_4 edi_316 = g_t8145650;
			Eq_4 edi_318 = g_t814564C;
			runtime.printlock(gs);
			runtime.printstring(gs);
			runtime.printuint(ebp_312, gs, ecx_306, eax_304);
			runtime.printstring(gs);
			runtime.printuint(ebp_312, gs, ebx_310, edx_308);
			runtime.printstring(gs);
			runtime.printuint(ebp_312, gs, esi_314, ebp_312);
			runtime.printstring(gs);
			runtime.printuint(ebp_312, gs, edi_318, edi_316);
			runtime.printstring(gs);
			word128 xmm2_1111;
			runtime.printfloat(gs, xmm2_79, (real64) (uint128) rLoc08_822, out xmm2_1111);
			runtime.printstring(gs);
			runtime.printuint(ebp_312, gs, ebx_187, edx_141);
			runtime.printstring(gs);
			runtime.printunlock(gs);
			runtime.throw(gs);
		}
		xmm0_21 = __xorps(xmm0_77, xmm0_77);
		ecx_eax_1104 = SEQ(edx_247, ebx_231);
	}
	Eq_4 edx_558;
	Eq_4 ebx_560;
	Eq_4 eax_446 = (word32) ecx_eax_1104;
	g_t81597A8 = eax_446;
	Eq_4 ecx_449 = SLICE(ecx_eax_1104, word32, 32);
	g_t81597AC = ecx_449;
	Eq_20602 edx_453 = runtime.gcpercent;
	if (edx_453 < 0x00)
	{
		edx_558.u0 = ~0x00;
		ebx_560.u0 = ~0x00;
	}
	else
	{
		Eq_4 eax_457 = g_t81597C0;
		uint64 edx_eax_461 = edx_453 *64 eax_457;
		Eq_4 ebp_462 = g_t81597C4;
		Eq_4 ecx_472 = (edx_453 >> 0x1F) *s eax_457 + (SLICE(edx_eax_461, word32, 32) + edx_453 *s ebp_462);
		runtime.uint64div(gs, (word32) edx_eax_461, ecx_472, 100, 0x00);
		ui64 edx_ecx_810 = qwLoc68 + SEQ(ebp_462, eax_457);
		Eq_4 edx_491 = SLICE(edx_ecx_810, word32, 32);
		word24 ebx_24_8_500 = SLICE(ebp_462, word24, 8);
		Eq_4 ebx_533 = SEQ(ebx_24_8_500, (int8) (edx_491 < ecx_449));
		Eq_4 ecx_486 = (word32) edx_ecx_810;
		dwLoc74 = ecx_472;
		esi = eax_446;
		ebp = ebx_533;
		Eq_4 ebx_535 = ecx_449;
		rLoc70 = 4.94e-322;
		if (((int8) (ecx_486 < eax_446) & (int8) (edx_491 == ecx_449) | (int8) (edx_491 < ecx_449)) == 0x00)
		{
			esi = ecx_486;
			ebx_535 = edx_491;
		}
		xmm0_21 = __xorps(xmm0_21, xmm0_21);
		edx_558 = ebx_535;
		ebx_560 = esi;
	}
	g_t8158228 = ebx_560;
	g_t815822C = edx_558;
	Eq_4 dwLoc70_966 = (word32) rLoc70;
	if (g_b814F4C8 != 0x00)
	{
		runtime.traceNextGC(gs);
		xmm0_21 = __xorps(xmm0_21, xmm0_21);
	}
	if (runtime.gcphase != 0x00)
	{
		runtime.(*gcControllerState).revise(ebp, gs, &g_dw8157860);
		xmm0_21 = __xorps(xmm0_21, xmm0_21);
	}
	if (g_t81490F4 != 0x00)
		g_r8149160 = (real64) xmm0_21;
	else
	{
		word64 mm0_1107;
		runtime/internal/atomic.Load64(135632816, out mm0_1107);
		up32 ecx_633 = eax_446 - dwLoc74;
		int32 edx_646 = (bool) (ecx_633 < 0xFFF00000) + (SLICE(ecx_eax_1104 - SEQ(dwLoc70_966, dwLoc74), word32, 32) + ~0x00);
		ui24 ebx_24_8_653 = SLICE(ecx_633 + 0xFFF00000, word24, 8);
		ui32 esi_664 = SEQ(SLICE(esi, word24, 8), (int8) (ecx_633 < ~0x00101FFF)) & SEQ(ebx_24_8_653, (int8) (edx_646 == 0x00));
		Eq_4 ecx_635 = ecx_633 + 0xFFF00000;
		if (((int8) (edx_646 < 0x00) | (byte) esi_664) != 0x00)
			ecx_635.u0 = 0x2000;
		word64 mm0_1108;
		runtime/internal/atomic.Load64(0x08149148, out mm0_1108);
		ui64 ebx_ecx_816 = SEQ(ebx_698, g_dw8149140) - SEQ(dwLoc70_966, dwLoc74);
		int32 ebx_700 = SLICE(ebx_ecx_816, word32, 32);
		Eq_4 ecx_695 = (word32) ebx_ecx_816;
		ui32 ebx_698 = g_dw8149144;
		if (((int8) (ecx_695 <= 0x00) & (int8) (ebx_700 == 0x00) | (int8) (ebx_700 < 0x00)) != 0x00)
			g_r8149160 = (real64) __xorps(xmm0_21, xmm0_21);
		else
		{
			runtime.int64tofloat64(ebx_24_8, gs, ecx_695);
			runtime.int64tofloat64(ebx_24_8, gs, ecx_635);
			g_r8149160 = (real64) (uint128) (real64) (uint128) rLoc70 / (real64) ((uint128) rLoc70);
			g_t8149158 = dwLoc74;
			g_t814915C = dwLoc70_966;
			runtime/internal/atomic.Store64(dwLoc7C, 135565648, SEQ(dwLoc70_966, dwLoc74));
		}
	}
}

// 0805B810: Register Eq_4 runtime.gcTrigger.test(Register Eq_4 edx, Register (ptr32 Eq_2) gs, Stack word32 dwArg04, Stack Eq_4 qwArg08)
// Called from:
//      runtime.mallocgc
//      runtime.gcStart
//      runtime.sysmon
Eq_4 runtime.gcTrigger.test(Eq_4 edx, struct Eq_2 * gs, word32 dwArg04, Eq_4 qwArg08)
{
	word32 dwLoc04 = SLICE(qwLoc08, word32, 32);
	word32 dwLoc08 = (word32) qwLoc08;
	Eq_4 edx_14 = edx;
	while (true)
	{
		ui24 edx_24_8_106 = SLICE(edx_14, word24, 8);
		if (fp > *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
			break;
		edx_14 = runtime.morestack_noctxt();
	}
	if (g_b8159250 == 0x00 || runtime.panicking != 0x00)
		return edx_14;
	if (dwArg04 == 0x00)
		return edx_14;
	if (runtime.gcphase != 0x00)
		return edx_14;
	if (dwArg04 == 0x01)
		return SEQ(g_n81597A9, (int8) (g_t81597B4 == g_t81597AC));
	if (dwArg04 != 0x02)
	{
		if (dwArg04 != 0x03)
			return edx_14;
		return edx_14;
	}
	else
	{
		if (runtime.gcpercent < 0x00)
			return edx_14;
		word64 mm0_274;
		Eq_4 edx_112 = SEQ(edx_24_8_106, (int8) (dwLoc04 != 0x00)) | SEQ(SLICE(runtime/internal/atomic.Load64(0x08159790, out mm0_274), word24, 8), (int8) (dwLoc08 != 0x00));
		if ((byte) edx_112 != 0x00)
		{
			up32 edx_121 = (word32) (qwArg08 - qwLoc08);
			edx_112 = SEQ(SLICE(edx_121, word24, 8), (int8) (edx_121 > g_dw81360F0));
		}
		return edx_112;
	}
}

// 0805B960: Register Eq_4 runtime.gcStart(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack word32 dwArg08, Stack Eq_4 dwArg0C, Stack Eq_4 dwArg10, Register out Eq_14502 esiOut)
// Called from:
//      runtime.mallocgc
//      runtime.forcegchelper
Eq_4 runtime.gcStart(struct Eq_2 * gs, Eq_4 dwArg04, word32 dwArg08, Eq_4 dwArg0C, Eq_4 dwArg10, union Eq_14502 & esiOut)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 eax_18 = gs->ptr0000->tFFFFFFFC;
	Eq_4 ecx_19 = *((word32) eax_18 + 24);
	*((word32) ecx_19 + 0x0078) = (word32) *((word32) ecx_19 + 0x0078) + 1;
	Eq_4 ecx_23 = *((word32) eax_18 + 24);
	Eq_4 eax_27 = gs->ptr0000->tFFFFFFFC;
	if (eax_27 != *ecx_23)
	{
		Eq_4 edx_31 = *((word32) ecx_23 + 0x0078);
		if (edx_31 <= 0x01 && *((word32) ecx_23 + 116) == 0x00)
		{
			*((word32) ecx_23 + 0x0078) = edx_31 - 0x01;
			if (edx_31 == 0x01 && *((word32) eax_27 + 0x006C) != 0x00)
				((word32) eax_27 + 8)->u0 = ~0x0521;
			while (true)
			{
				runtime.gcTrigger.test(edx, gs, dwArg08, dwArg0C);
				if (bLoc10 == 0x00)
					break;
				runtime.gosweepone(gs);
				if (dwArg08 == ~0x00)
					break;
				++g_dw81451EC;
			}
			runtime.semacquire(gs);
			runtime.gcTrigger.test(edx, gs, dwArg08, dwArg0C);
			if (bLoc10 == 0x00)
			{
				Eq_4 edx_126 = runtime.semrelease(gs);
				esiOut = esi;
				return edx_126;
			}
			else
			{
				int8 al_136;
				if (dwArg08 == 0x00)
					al_136 = 0x01;
				else
					al_136 = (int8) (dwArg08 == 0x03);
				g_b8145640 = al_136;
				Eq_4 eax_142 = dwArg04;
				if (dwArg04 == 0x00)
				{
					word32 ecx_146 = g_dw815773C;
					if (ecx_146 == 0x01)
						eax_142.u0 = 0x01;
					else if (ecx_146 == 0x02)
						eax_142.u0 = 0x02;
				}
				runtime.semacquire(gs);
				if (g_b814F4C8 != 0x00)
					runtime.traceGCStart(gs);
				if (eax_142 == 0x00)
					runtime.gcBgMarkStartWorkers(gs);
				runtime.gcResetMarkState(gs);
				runtime.gcprocs(gs);
				Eq_4 eax_195 = runtime.gomaxprocs;
				g_t814566C.u2 = 0x08136024;
				g_t8145670 = eax_195;
				word64 mm0_560;
				runtime/internal/atomic.Load64(135632816, out mm0_560);
				g_t81456A4 = dwArg0C;
				g_t81456A8 = dwArg10;
				g_t8145694.u0 = 0x00;
				g_dw8145698 = 0x00;
				g_t814563C = eax_142;
				runtime.nanotime();
				g_t8145674.u2 = 135632816;
				g_t8145678 = dwArg0C;
				g_t814569C.u1 = 135632816;
				g_t81456A0 = dwArg0C;
				word32 edi_562;
				word32 ebp_561;
				runtime.systemstack(gs, 0x080E7CDC, out ebp_561, out edi_562);
				word32 edi_564;
				word32 ebp_563;
				runtime.systemstack(gs, 0x080E7C0C, out ebp_563, out edi_564);
				runtime.clearpools(gs);
				++g_dw8145668;
				if (eax_142 == 0x00)
				{
					runtime.(*gcControllerState).startCycle(edi_339, gs, &g_dw8157860);
					Eq_4 eax_285 = g_t815822C;
					g_t81456BC = g_t8158228;
					g_t81456C0 = eax_285;
					runtime.setGCPhase(0x01);
					g_t81455F8.u0 = ~0x00;
					g_t8145604.u0 = ~0x00;
					runtime.gcMarkRootPrepare(gs);
					runtime.gcMarkTinyAllocs(gs);
					runtime/internal/atomic.Store(135624156, 0x01);
					g_t8157890.u1 = 135632816;
					g_t8157894 = dwArg0C;
					word32 ebp_565;
					word32 edi_566;
					runtime.systemstack(gs, 135167188, out ebp_565, out edi_566);
					runtime.nanotime();
					Eq_22621 ecx_330 = g_t814569C;
					Eq_22735 eax_332 = 135167188 - ecx_330;
					Eq_22606 ebx_333 = g_t8145694;
					ui32 edi_337 = g_dw8145698;
					Eq_4 edi_339 = g_t81456A0;
					Mem340[0x08145694<p32>:word32] = eax_332 + ebx_333;
					esi = SLICE(4430134484 - SEQ(edi_339, ecx_330), word32, 32);
					g_dw8145698 = SLICE(SEQ(edi_337, eax_332) + SEQ(esi, ebx_333), word32, 32);
					g_t814567C.u1 = 135167188;
					g_t8145680.u0 = 0x01;
				}
				else
				{
					runtime.nanotime();
					g_t814567C.u1 = 0x080E7C0C;
					g_t8145680 = dwArg0C;
					g_t8145684.u1 = 0x080E7C0C;
					g_t8145688 = dwArg0C;
					Eq_4 eax_269 = g_t81456A8;
					g_t81456BC = g_t81456A4;
					g_t81456C0 = eax_269;
					runtime.gcMarkTermination(gs, (real64) (uint128) g_r81597A0);
				}
				Eq_4 edx_362 = runtime.semrelease(gs);
				esiOut = esi;
				return edx_362;
			}
		}
	}
	Eq_4 edx_40 = *((word32) ecx_23 + 0x0078);
	*((word32) ecx_23 + 0x0078) = edx_40 - 0x01;
	if (edx_40 == 0x01 && *((word32) eax_27 + 0x006C) != 0x00)
		((word32) eax_27 + 8)->u0 = ~0x0521;
	esiOut = esi;
	return edx_40;
}

// 0805BD40: void runtime.gcMarkDone(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.gcBgMarkWorker
//      runtime.gcAssistAlloc
void runtime.gcMarkDone(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
}

// 0805BF90: void runtime.gcMarkTermination(Register (ptr32 Eq_2) gs, Stack real64 rArg04)
// Called from:
//      runtime.gcStart
//      runtime.gcMarkDone
void runtime.gcMarkTermination(struct Eq_2 * gs, real64 rArg04)
{
	while (fp - 0x0130 <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime/internal/atomic.Store(135624156, 0x00);
	g_t815756D.u0 = 0x00;
	runtime.setGCPhase(0x02);
	Eq_4 eax_32 = g_t81597B4;
	g_t81456AC = g_t81597B0;
	g_t81456B0 = eax_32;
	runtime.nanotime();
	Eq_4 eax_49 = gs->ptr0000->tFFFFFFFC;
	Eq_4 ecx_50 = *((word32) eax_49 + 24);
	*((word32) ecx_50 + 0x0078) = (word32) *((word32) ecx_50 + 0x0078) + 1;
	Eq_4 ecx_54 = *((word32) eax_49 + 24);
	((word32) ecx_54 + 116)->u0 = 0x05;
	Eq_4 dwLoc28_1230 = ecx_54;
	if (g_t81576F0 == 0x00)
		((word32) ecx_54 + 112)->u0 = 135139389;
	else
		runtime.writebarrierptr((word32) ecx_54 + 112, 135139389);
	Eq_4 eax_77 = gs->ptr0000->tFFFFFFFC;
	*((word32) *((word32) eax_77 + 24) + 461) = 0x02;
	Eq_4 ecx_83 = *((word32) *((word32) eax_77 + 24) + 84);
	runtime.casgstatus(ecx_83, 0x02, 0x04);
	((word32) ecx_83 + 100)->u0 = 0x12;
	if (g_t81576F0 == 0x00)
		((word32) ecx_83 + 96)->u0 = 0x080E29E2;
	else
		runtime.writebarrierptr((word32) ecx_83 + 96, 0x080E29E2);
	word32 edi_1673;
	word32 ebp_1672;
	runtime.systemstack(gs, fp - 0x08, out ebp_1672, out edi_1673);
	word32 edi_1675;
	word32 ebp_1674;
	runtime.systemstack(gs, fp - 0x10, out ebp_1674, out edi_1675);
	*((word32) *((word32) eax_77 + 24) + 461) = 0x00;
	runtime.casgstatus(ecx_83, 0x04, 0x02);
	if (g_b814F4C8 != 0x00)
		runtime.traceGCDone(gs);
	((word32) ecx_54 + 116)->u0 = 0x00;
	if (g_t81576F0 == 0x00)
		((word32) ecx_54 + 112)->u0 = 0x00;
	else
		runtime.writebarrierptr((word32) ecx_54 + 112, 0x00);
	if (runtime.gcphase != 0x00)
		runtime.throw(gs);
	else
	{
		Eq_662 xmm0_183 = (uint128) rArg04;
		Eq_4 rLoc01B0_1268 = (real64) xmm0_183;
		runtime.gcSetTriggerRatio(esi, edi, gs, xmm0_183, rLoc01B0_1268);
		runtime.nanotime();
		time.now(gs);
		uint32 dwLoc01B0_1271 = (word32) rLoc01B0_1268;
		Eq_22621 ebp_216 = g_t814569C;
		uint32 esi_219 = dwLoc01B0_1271 - ebp_216;
		Eq_22606 ebx_221 = g_t8145694;
		ui32 edx_225 = g_dw8145698;
		Eq_4 ecx_226 = g_t81456A0;
		g_t8145694 = (word32) ebx_221.u1 + esi_219;
		g_dw8145698 = SLICE(SEQ(SLICE(rLoc01B0_1268 - SEQ(ecx_226, ebp_216), word32, 32), esi_219) + SEQ(edx_225, ebx_221), word32, 32);
		g_dw814568C = dwLoc01B0_1271;
		int32 dwLoc01AC_1269 = SLICE(rLoc01B0_1268, word32, 32);
		g_dw8145690 = dwLoc01AC_1269;
		uint32 eax_214 = dwLoc01B0_1271 * 1000000000 + 0x02;
		word32 ecx_257 = SLICE(SEQ(dwLoc01AC_1269 *s 1000000000 + SLICE(dwLoc01B0_1271 *64 1000000000, word32, 32), dwLoc01B0_1271 * 1000000000) + 0x02, word32, 32);
		runtime/internal/atomic.Store64(dwLoc01B4, 0x08158230, SEQ(ecx_257, eax_214));
		runtime/internal/atomic.Store64(dwLoc01B4, 0x08159790, rLoc01B0_1268);
		struct Eq_22973 * eax_282 = (g_t8159240 & 0xFF) * 0x08 + 0x08158240;
		ui32 ecx_283 = g_dw8145698;
		eax_282->t0000 = g_t8145694;
		eax_282->dw0004 = ecx_283;
		struct Eq_22993 * eax_290 = (g_t8159240 & 0xFF) * 0x08 + 0x08158A40;
		eax_290->dw0000 = eax_214;
		eax_290->dw0004 = ecx_257;
		ui64 eax_ecx_1188 = SEQ(g_dw815823C, g_t8145694) + SEQ(g_dw8145698, g_dw8158238);
		g_dw8158238 = (word32) eax_ecx_1188;
		g_dw815823C = SLICE(eax_ecx_1188, word32, 32);
		Eq_22654 eax_305 = g_t814567C;
		Eq_22616 ecx_306 = g_t8145674;
		uint32 edx_329 = g_dw814568C;
		Eq_22659 ecx_331 = g_t8145684;
		Eq_23038 eax_309 = eax_305 - ecx_306;
		Eq_22592 ebx_310 = g_t814566C;
		uint32 edi_319 = g_dw8157870;
		uint32 edx_321 = g_dw8157878;
		Eq_23049 edx_333 = edx_329 - ecx_331;
		uint64 edx_eax_314 = ebx_310 *64 eax_309;
		uint32 edx_323 = edx_321 + edi_319;
		uint32 edi_325 = g_dw8157880;
		uint64 edx_eax_336 = ebx_310 *64 edx_333;
		uint32 eax_317 = (word32) edx_eax_314;
		uint32 edi_327 = edi_325 + edx_323;
		uint32 eax_339 = (word32) edx_eax_336;
		uint32 edi_342 = edi_327 + eax_317;
		uint32 edi_344 = edi_342 + eax_339;
		Eq_4 eax_346 = g_t8145644;
		Eq_4 eax_348 = (word32) eax_346 + edi_344;
		Eq_4 edi_350 = g_t8145680;
		Eq_4 edx_351 = g_t8145678;
		ui32 ecx_352 = g_dw8157874;
		ui32 ecx_354 = g_dw815787C;
		ui32 ecx_356 = g_dw8157884;
		int32 ecx_358 = g_dw8145690;
		Eq_4 ecx_360 = g_t8145688;
		ui32 ecx_362 = g_dw8145648;
		g_t8145644 = eax_348;
		g_dw8145648 = SLICE(SEQ(ecx_362, eax_346) + SEQ(SLICE(SEQ(SLICE(SEQ(SLICE(SEQ(SLICE(SEQ(ecx_352, edx_321) + SEQ(ecx_354, edi_319), word32, 32), edi_325) + SEQ(ecx_356, edx_323), word32, 32), edi_327) + SEQ((SLICE(edx_eax_314, word32, 32) + SLICE(SEQ(edi_350, eax_305) - SEQ(edx_351, ecx_306), word32, 32) *s ebx_310) + eax_309 *s (ebx_310 >> 0x1F), eax_317), word32, 32), edi_342) + SEQ((SLICE(edx_eax_336, word32, 32) + SLICE(SEQ(ecx_358, edx_329) - SEQ(ecx_360, ecx_331), word32, 32) *s ebx_310) + edx_333 *s (ebx_310 >> 0x1F), eax_339), word32, 32), edi_344), word32, 32);
		uint32 ebx_429 = dwLoc01B0_1271 - g_t8145478;
		Eq_4 eax_441 = runtime.gomaxprocs * ebx_429 + g_dw8145480;
		runtime.int64tofloat64(SLICE(ebx_429, word24, 8), gs, eax_348);
		runtime.int64tofloat64(ebx_24_8, gs, eax_441);
		real64 rLoc01A8_1338 = SEQ(dwLoc01A4, dwLoc01AC_1269);
		g_r8159248 = (real64) (uint128) (real64) (uint128) rLoc01A8_1338 / (real64) ((uint128) rLoc01A8_1338);
		g_dw81451EC = 0x00;
		g_dw81451F0 = 0x00;
		if (g_b8145640 != 0x00)
			++g_dw8159244;
		word32 edi_1662;
		word32 esi_1661;
		runtime.lock(esi, gs, 135550560, out esi_1661, out edi_1662);
		g_t8159240 = (word32) g_t8159240 + 1;
		runtime.injectglist(gs, g_t8145664);
		g_t8145664.u0 = 0x00;
		word32 edx_1663;
		word32 ebx_1664;
		runtime.unlock(gs, 135550560, out edx_1663, out ebx_1664);
		runtime.mProf_NextCycle(gs);
		word32 edi_1666;
		word32 ebp_1665;
		runtime.systemstack(gs, 135167188, out ebp_1665, out edi_1666);
		runtime.mProf_Flush(gs);
		runtime.prepareFreeWorkbufs(gs);
		word32 ebp_1667;
		word32 edi_1668;
		runtime.systemstack(gs, 135166964, out ebp_1667, out edi_1668);
		if (g_dw8157740 > 0x00)
		{
			word32 dwLocE8_1411 = (word32) (real64) (uint128) g_r8159248;
			fn0808FD8A(0x00, fp - 0xE0);
			runtime.printlock(gs);
			ui64 edx_ecx_1218 = g_t8145674 - g_t81576A0;
			runtime.uint64div(gs, (word32) edx_ecx_1218, SLICE(edx_ecx_1218, word32, 32), 1000000, 0x00);
			runtime.itoaDiv(esi, edi, gs, fp - 228, (Eq_25271 (*)[]) 0x18, dwLoc01A4, dwLoc01A0, 0x03);
			Eq_4 ecx_599 = g_t8159240;
			runtime.slicebytetostring(gs, fp - 116, dwLoc019C, dwLoc0198);
			runtime.printlock(gs);
			runtime.printstring(gs);
			runtime.printint(ebx_24_8, gs, ecx_599);
			runtime.printstring(gs);
			runtime.printstring(gs);
			runtime.printstring(gs);
			runtime.printint(ebx_24_8, gs, (int32) ((real64) (uint128) SEQ(dwLocE8_1411, 0x00) * (real64) ((uint128) g_r80F1880)));
			runtime.printstring(gs);
			runtime.printunlock(gs);
			Eq_22616 edx_684 = g_t8145674;
			fn0808FD8A(0x00, fp - 0xCC);
			Eq_4 dwLoc01A8_1393 = dwLoc0194;
			int32 ecx_1166;
			struct Eq_23364 * ebx_1078 = fp - 0xD0;
			int64 ebp_edx_1655 = SEQ(dwLoc01AC_1269, edx_684);
			for (ecx_1166 = 0x00; ecx_1166 < 0x03; ++ecx_1166)
			{
				Eq_4 esi_1080 = ebx_1078->dw0004;
				uint32 edi_1082 = ebx_1078->dw0000;
				if (ecx_1166 != 0x00)
				{
					runtime.printlock(gs);
					runtime.printstring(gs);
					runtime.printunlock(gs);
				}
				ui64 esi_edi_1224 = SEQ(esi_1080, edi_1082) - ebp_edx_1655;
				Eq_4 esi_1123 = SLICE(esi_edi_1224, word32, 32);
				runtime.fmtNSAsMS(ebx_24_8, esi_1080, gs, fp - 232, (Eq_25271 (*)[]) 0x18, (word32) esi_edi_1224, esi_1123);
				runtime.slicebytetostring(gs, fp - 0x98, dwLoc01A0, 0x03);
				runtime.printlock(gs);
				runtime.printstring(gs);
				runtime.printunlock(gs);
				dwLoc01A8_1393 = esi_1123;
				++ebx_1078;
				ebp_edx_1655 = SEQ(esi_1080, edi_1082);
			}
			runtime.printlock(gs);
			runtime.printstring(gs);
			runtime.printunlock(gs);
			fn0808FD86(0x00, fp - 88);
			int32 eax_1075;
			Eq_4 ecx_1073 = fp - 0x5C;
			for (eax_1075 = 0x00; eax_1075 < 0x05; ++eax_1075)
			{
				dwLoc28_1230 = ecx_1073;
				Eq_4 edx_979 = *((word32) ecx_1073 + 4);
				Eq_4 ebx_981 = *ecx_1073;
				if (eax_1075 == 0x02 || eax_1075 == 0x03)
				{
					runtime.printlock(gs);
					runtime.printstring(gs);
					runtime.printunlock(gs);
				}
				else if (eax_1075 != 0x00)
				{
					runtime.printlock(gs);
					runtime.printstring(gs);
					runtime.printunlock(gs);
				}
				runtime.fmtNSAsMS(ebx_24_8, ebp, gs, fp - 0xEC, (Eq_25271 (*)[]) 0x18, ebx_981, edx_979);
				runtime.slicebytetostring(gs, fp - 188, dwLoc01A8_1393, dwLoc01A0);
				runtime.printlock(gs);
				runtime.printstring(gs);
				runtime.printunlock(gs);
				ecx_1073 = (word32) ecx_1073 + 8;
			}
			Eq_4 eax_768 = g_t81456A8;
			Eq_4 ecx_771 = g_t81456A4;
			Eq_4 edx_773 = g_t81456B0;
			Eq_4 ebx_775 = g_t81456AC;
			Eq_4 ebp_777 = g_t81456B8;
			Eq_4 esi_779 = g_t81456B4;
			Eq_4 edi_781 = g_t81456C0;
			Eq_4 edi_783 = g_t81456BC;
			Eq_4 edi_785 = g_t8145670;
			runtime.printlock(gs);
			runtime.printstring(gs);
			runtime.printuint(ebp, gs, eax_768 << 0x0C | ecx_771 >> 0x14, eax_768 >> 0x14);
			runtime.printstring(gs);
			runtime.printuint(ebp, gs, edx_773 << 0x0C | ebx_775 >> 0x14, edx_773 >> 0x14);
			runtime.printstring(gs);
			runtime.printuint(ebp, gs, ebp_777 << 0x0C | esi_779 >> 0x14, ebp_777 >> 0x14);
			runtime.printstring(gs);
			runtime.printuint(ebp, gs, edi_781 << 0x0C | edi_783 >> 0x14, edi_781 >> 0x14);
			runtime.printstring(gs);
			runtime.printint(ebx_24_8, gs, edi_785);
			runtime.printstring(gs);
			runtime.printunlock(gs);
			if (g_b8145640 != 0x00)
			{
				runtime.printlock(gs);
				runtime.printstring(gs);
				runtime.printunlock(gs);
			}
			runtime.printlock(gs);
			runtime.printstring(gs);
			runtime.printunlock(gs);
			runtime.printunlock(gs);
		}
		runtime.semrelease(gs);
		Eq_4 eax_960 = gs->ptr0000->tFFFFFFFC;
		Eq_4 edx_962 = *((word32) dwLoc28_1230 + 0x0078);
		*((word32) dwLoc28_1230 + 0x0078) = edx_962 - 0x01;
		if (edx_962 == 0x01 && *((word32) eax_960 + 0x006C) != 0x00)
			((word32) eax_960 + 8)->u0 = ~0x0521;
	}
}

// 0805CE70: void runtime.gcBgMarkStartWorkers(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.gcStart
void runtime.gcBgMarkStartWorkers(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	int32 eax_17;
	word32 * ecx_20 = g_a81478C0;
	for (eax_17 = 0x00; eax_17 < 0x0401; ++eax_17)
	{
		Eq_4 edx_26 = *ecx_20;
		if (edx_26 == 0x00 || *((word32) edx_26 + 8) == 0x04)
			return;
		if (*((word32) edx_26 + 0x0948) == 0x00)
		{
			runtime.newproc();
			runtime.notetsleepg(gs);
			g_dw8145634 = 0x00;
		}
		++ecx_20;
	}
}

// 0805CF20: void runtime.gcBgMarkWorker(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_23708) dwArg04)
void runtime.gcBgMarkWorker(struct Eq_2 * gs, struct Eq_23708 * dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 eax_18 = gs->ptr0000->tFFFFFFFC;
	Eq_4 ecx_20 = *((word32) eax_18 + 24);
	((word32) ecx_20 + 116)->u0 = 0x0E;
	if (g_t81576F0 == 0x00)
		((word32) ecx_20 + 112)->u0 = 0x080E207E;
	else
	{
		runtime.writebarrierptr((word32) ecx_20 + 112, 0x080E207E);
		dwLoc44 = &g_t80E207E;
	}
	runtime.newobject(gs, 0x080D3CE0);
	Eq_4 ecx_52 = *((word32) eax_18 + 24);
	((word32) ecx_52 + 116)->u0 = 0x00;
	if (g_t81576F0 == 0x00)
		((word32) ecx_52 + 112)->u0 = 0x00;
	else
		runtime.writebarrierptr((word32) ecx_52 + 112, 0x00);
	Eq_4 eax_76 = gs->ptr0000->tFFFFFFFC;
	Eq_4 ecx_77 = *((word32) eax_76 + 24);
	*((word32) ecx_77 + 0x0078) = (word32) *((word32) ecx_77 + 0x0078) + 1;
	dwLoc44->t0000 = *((word32) eax_76 + 24);
	dwLoc44->ptr0004 = dwArg04;
	runtime.notewakeup(gs, 135550516);
	while (true)
	{
		runtime.gopark(gs);
		if (dwArg04->t0948 != eax_18)
			break;
		Eq_4 ecx_135 = gs->ptr0000->tFFFFFFFC;
		Eq_4 ebp_136 = *((word32) ecx_135 + 24);
		*((word32) ebp_136 + 0x0078) = (word32) *((word32) ebp_136 + 0x0078) + 1;
		dwLoc44->t0000 = *((word32) ecx_135 + 24);
		if (runtime.gcBlackenEnabled == 0x00)
			runtime.throw(gs);
		runtime.nanotime();
		word24 ebx_24_8_210 = SLICE(runtime/internal/atomic.Xadd(0x08145604, ~0x00), word24, 8);
		Eq_4 ecx_180 = g_t81455F8;
		if (ecx_180 == 0x080E2499)
		{
			runtime.printlock(gs);
			runtime.printstring(gs);
			runtime.printsp(gs);
			runtime.printint(ebx_24_8_210, gs, 0x080E2499);
			runtime.printsp(gs);
			runtime.printstring(gs);
			runtime.printsp(gs);
			runtime.printint(ebx_24_8_210, gs, (uint64) ecx_180);
			runtime.printnl(gs);
			runtime.printunlock(gs);
			runtime.throw(gs);
		}
		Eq_4 ebp_285;
		word32 edi_691;
		ui24 ebx_24_8_299 = SLICE(runtime.systemstack(gs, fp - 0x0C, out ebp_285, out edi_691), word24, 8);
		Eq_4 esp_286 = <invalid>;
		if (g_t815756D != 0x00)
		{
			*esp_286 = (word32) *((word32) esp_286 + 76) + 0x0950;
			runtime.(*gcWork).dispose(ebx_24_8_299, ebp_285, gs, *((word32) esp_286 - 4), *esp_286);
		}
		runtime.nanotime();
		ui64 ecx_eax_614 = SEQ(ecx_323, *esp_286) - SEQ(edx_324, *((word32) esp_286 + 24));
		Eq_4 eax_321 = (word32) ecx_eax_614;
		Eq_4 ecx_326 = SLICE(ecx_eax_614, word32, 32);
		Eq_4 ecx_323 = *((word32) esp_286 + 4);
		Eq_4 edx_324 = *((word32) esp_286 + 28);
		Eq_4 ebx_328 = *((word32) *((word32) esp_286 + 76) + 0x094C);
		if (ebx_328 != 0x00)
		{
			if (ebx_328 != 0x01)
			{
				if (ebx_328 == 0x02)
				{
					esp_286->u0 = 0x08157888;
					*((word32) esp_286 + 4) = eax_321;
					*((word32) esp_286 + 8) = ecx_326;
					word32 ebx_700;
					word32 ebp_701;
					runtime/internal/atomic.Xaddint64(*esp_286, *((word32) esp_286 + 4), *((word32) esp_286 + 8), out ebx_700, out ebp_701);
					esp_286 = (word32) esp_286 - 4;
				}
			}
			else
			{
				esp_286->u0 = 0x08157880;
				*((word32) esp_286 + 4) = eax_321;
				*((word32) esp_286 + 8) = ecx_326;
				word32 ebx_696;
				word32 ebp_697;
				runtime/internal/atomic.Xaddint64(*esp_286, *((word32) esp_286 + 4), *((word32) esp_286 + 8), out ebx_696, out ebp_697);
				((word32) esp_286 - 4)->u0 = 0x081578F8;
				esp_286->u0 = 0x01;
				((word32) esp_286 + 4)->u0 = 0x00;
				word32 ebx_698;
				word32 ebp_699;
				runtime/internal/atomic.Xaddint64(*((word32) esp_286 - 4), *esp_286, *((word32) esp_286 + 4), out ebx_698, out ebp_699);
				esp_286 = (word32) esp_286 - 8;
			}
		}
		else
		{
			esp_286->u0 = 0x08157878;
			*((word32) esp_286 + 4) = eax_321;
			*((word32) esp_286 + 8) = ecx_326;
			word32 ebp_693;
			word32 ebx_692;
			runtime/internal/atomic.Xaddint64(*esp_286, *((word32) esp_286 + 4), *((word32) esp_286 + 8), out ebx_692, out ebp_693);
			((word32) esp_286 - 4)->u0 = 0x08157898;
			esp_286->u0 = 0x01;
			((word32) esp_286 + 4)->u0 = 0x00;
			word32 ebx_694;
			word32 ebp_695;
			runtime/internal/atomic.Xaddint64(*((word32) esp_286 - 4), *esp_286, *((word32) esp_286 + 4), out ebx_694, out ebp_695);
			esp_286 = (word32) esp_286 - 8;
		}
		*esp_286 = 0x08145604;
		((word32) esp_286 + 4)->u0 = 0x01;
		word24 ebx_24_8_455 = SLICE(runtime/internal/atomic.Xadd(*esp_286, *((word32) esp_286 + 4)), word24, 8);
		Eq_4 eax_417 = *((word32) esp_286 + 8);
		Eq_4 ecx_418 = g_t81455F8;
		if (eax_417 > ecx_418)
		{
			*((word32) esp_286 + 32) = eax_417;
			*((word32) esp_286 + 44) = ecx_418;
			*((word32) esp_286 + 40) = *((word32) *((word32) esp_286 + 76) + 0x094C);
			runtime.printlock(gs);
			*esp_286 = 0x080E49C8;
			((word32) esp_286 + 4)->u0 = 0x1C;
			runtime.printstring(gs);
			runtime.printsp(gs);
			Eq_4 eax_450 = *((word32) esp_286 + 40);
			*esp_286 = eax_450;
			*((word32) esp_286 + 4) = eax_450 >> 0x1F;
			runtime.printint(ebx_24_8_455, gs, *esp_286);
			runtime.printsp(gs);
			*esp_286 = 0x080E1BF8;
			((word32) esp_286 + 4)->u0 = 11;
			runtime.printstring(gs);
			runtime.printsp(gs);
			*esp_286 = *((word32) esp_286 + 32);
			((word32) esp_286 + 4)->u0 = 0x00;
			runtime.printint(ebx_24_8_455, gs, *esp_286);
			runtime.printsp(gs);
			*esp_286 = 0x080E1BED;
			((word32) esp_286 + 4)->u0 = 11;
			runtime.printstring(gs);
			runtime.printsp(gs);
			*esp_286 = *((word32) esp_286 + 44);
			((word32) esp_286 + 4)->u0 = 0x00;
			runtime.printint(ebx_24_8_455, gs, *esp_286);
			runtime.printnl(gs);
			runtime.printunlock(gs);
			*esp_286 = 135150409;
			((word32) esp_286 + 4)->u0 = 0x17;
			runtime.throw(gs);
		}
		if (eax_417 == ecx_418)
		{
			*esp_286 = 0x00;
			runtime.gcMarkWorkAvailable(gs, *esp_286);
			if (*((word32) esp_286 + 4) == 0x00)
			{
				((word32) *((word32) esp_286 + 76) + 0x0948)->u0 = 0x00;
				Eq_4 ebx_570 = **((word32) esp_286 + 48);
				Eq_4 ebp_572 = gs->ptr0000->tFFFFFFFC;
				Eq_4 esi_573 = *((word32) ebx_570 + 0x0078);
				*((word32) ebx_570 + 0x0078) = esi_573 - 0x01;
				if (esi_573 == 0x01 && *((word32) ebp_572 + 0x006C) != 0x00)
					((word32) ebp_572 + 8)->u0 = ~0x0521;
				runtime.gcMarkDone(gs);
				Eq_4 eax_597 = gs->ptr0000->tFFFFFFFC;
				Eq_4 ecx_598 = *((word32) eax_597 + 24);
				*((word32) ecx_598 + 0x0078) = (word32) *((word32) ecx_598 + 0x0078) + 1;
				Eq_4 ecx_605 = *((word32) esp_286 + 48);
				*ecx_605 = *((word32) eax_597 + 24);
				*((word32) ecx_605 + 4) = *((word32) esp_286 + 76);
			}
		}
	}
}

// 0805D440: void runtime.gcMarkWorkAvailable(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      runtime.(*gcControllerState).findRunnableGCWorker
//      runtime.gcMarkDone
//      runtime.gcBgMarkWorker
//      runtime.gcAssistAlloc1
//      runtime.handoffp
//      runtime.findrunnable
void runtime.gcMarkWorkAvailable(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (dwArg04 != 0x00)
	{
		uip32 eax_124;
		struct Eq_24343 * ecx_23 = *((word32) dwArg04 + 0x0950);
		if (ecx_23 != null)
		{
			if (ecx_23->dw000C == 0x00)
			{
				word32 eax_36 = *((word32) *((word32) dwArg04 + 2388) + 0x0C);
				eax_124 = SEQ(SLICE(eax_36, word24, 8), (int8) (eax_36 == 0x00));
			}
			else
				eax_124 = 0x00;
		}
		else
			eax_124 = 0x01;
		if ((byte) eax_124 == 0x00)
			return;
	}
	runtime.(*lfstack).empty(gs, 135550336);
	if (bLoc04 == 0x00)
		return;
	if (g_t81455F0 >= g_t81455F4)
		;
}

// 0805D4F0: Register Eq_4 runtime.gcMark(Register Eq_4 esi, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
// Called from:
//      runtime.gcMarkTermination.func1
//      runtime.gcMarkTermination.func2
Eq_4 runtime.gcMark(Eq_4 esi, struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (g_dw8157720 > 0x00)
		esi = runtime.tracegc(esi, gs);
	if (runtime.gcphase != 0x02)
		runtime.throw(gs);
	else
	{
		g_t81455FC = dwArg04;
		g_t8145600 = dwArg08;
		runtime.gcMarkRootPrepare(gs);
		g_t8145604.u0 = 0x00;
		g_dw8145608 = 0x00;
		runtime.gcprocs(gs);
		g_t81455F8 = dwLoc0C;
		word32 eax_71 = g_dw8145580;
		word32 ecx_72 = g_dw8145584;
		if (((int8) (ecx_72 == 0x00) & (int8) (eax_71 == 0x00)) != 0x00 && ((Mem70[0x08145618<p32>:word32] + Mem70[0x0814561C<p32>:word32]) + Mem70[0x08145620<p32>:word32]) + Mem70[0x08145624<p32>:word32] == 0x00)
			g_b8145610 = 0x00;
		else
			g_b8145610 = 0x01;
		if (g_b814F4C8 != 0x00)
			runtime.traceGCScanStart(gs);
		if (g_t81455F8 > 0x01)
		{
			g_dw814560C = 0x00;
			runtime.helpgc(esi, gs, g_t81455F8);
		}
		Eq_4 esi_177;
		ui24 ebx_24_8_202;
		Eq_4 ebp_172;
		runtime.gchelperstart(gs);
		Eq_4 ecx_157 = *((word32) *((word32) gs->ptr0000->tFFFFFFFC + 24) + 92);
		if (g_b8145610 != 0x00)
			ebx_24_8_202 = SLICE(runtime.gcDrain(gs, (word32) ecx_157 + 0x0950, 0x00, out ebp_172, out esi_177), word24, 8);
		else
			ebx_24_8_202 = SLICE(runtime.gcDrain(gs, (word32) ecx_157 + 0x0950, 0x02, out ebp_172, out esi_177), word24, 8);
		runtime.(*gcWork).dispose(ebx_24_8_202, ebp_172, gs, dwLoc10, (word32) ecx_157 + 0x0950);
		if (g_dw815772C > 0x00)
			runtime.gcMarkRootCheck(gs);
		word32 eax_227 = g_dw8145580;
		word32 ecx_228 = g_dw8145584;
		if (((int8) (ecx_228 != 0x00) | (int8) (eax_227 != 0x00)) != 0x00)
			runtime.throw(gs);
		else
		{
			if (g_t81455F8 > 0x01)
				runtime.notesleep(esi_177, gs, dwLoc10, 135550476);
			g_b8145628 = 0x01;
			Eq_4 eax_270 = 0x00;
			while (eax_270 < runtime.gomaxprocs)
			{
				if (eax_270 >= 0x0401)
					runtime.panicindex(gs);
				int8 bl_357;
				struct Eq_24568 * edx_336 = *((char *) g_a81478C0 + eax_270 * 0x04);
				struct Eq_24573 * ebx_340 = edx_336->ptr0950;
				if (ebx_340 != null)
				{
					if (ebx_340->dw000C == 0x00)
						bl_357 = (int8) (edx_336->ptr0954->dw000C == 0x00);
					else
						bl_357 = 0x00;
				}
				else
					bl_357 = 0x01;
				if (bl_357 == 0x00)
					runtime.throw(gs);
				word32 ebp_378 = edx_336->dw0964;
				word32 ebx_377 = edx_336->dw0960;
				if (((int8) (ebx_377 != 0x00) | (int8) (ebp_378 != 0x00)) != 0x00)
				{
l0805D7F7:
					runtime.throw(gs);
				}
				word32 ebx_400 = edx_336->dw095C;
				word32 edx_401 = edx_336->dw0958;
				if (((int8) (edx_401 != 0x00) | (int8) (ebx_400 != 0x00)) != 0x00)
					goto l0805D7F7;
				eax_270 = (word32) eax_270 + 1;
			}
			if (g_b814F4C8 != 0x00)
				runtime.traceGCScanDone(gs);
			runtime.cachestats(gs);
			Eq_4 eax_299 = g_t81455EC;
			g_t81597C0 = g_t81455E8;
			g_t81597C4 = eax_299;
			Eq_4 eax_303 = g_t81455EC;
			g_t81597B0 = g_t81455E8;
			g_t81597B4 = eax_303;
			uint32 eax_307 = g_dw8157864;
			g_dw81597B8 = g_dw8157860;
			g_dw81597BC = eax_307;
			if (g_b814F4C8 != 0x00)
				runtime.traceHeapAlloc(gs, out esi_177);
			return esi_177;
		}
	}
}

// 0805D870: Register Eq_662 runtime.gcSweep(Register Eq_4 esi, Register (ptr32 Eq_2) gs, Register Eq_662 xmm0, Register Eq_662 xmm2, Stack Eq_4 dwArg04)
// Called from:
//      runtime.gcMarkTermination.func2
Eq_662 runtime.gcSweep(Eq_4 esi, struct Eq_2 * gs, Eq_662 xmm0, Eq_662 xmm2, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (runtime.gcphase != 0x00)
		runtime.throw(gs);
	else
	{
		Eq_4 esi_40;
		word32 edi_324;
		runtime.lock(esi, gs, 0x081488E0, out esi_40, out edi_324);
		g_t81490F0 = (word32) g_t81490F0 + 2;
		g_t81490F4.u0 = 0x00;
		if (g_a8149124[g_t81490F0 >> 0x01 & 0x01] != 0x00)
			runtime.throw(gs);
		else
		{
			g_dw8149148 = 0x00;
			g_t814914C.u0 = 0x00;
			word32 edx_325;
			word32 ebx_326;
			runtime.unlock(gs, 0x081488E0, out edx_325, out ebx_326);
			if (dwArg04 != 0x02)
			{
				word32 edi_328;
				word32 esi_327;
				runtime.lock(esi_40, gs, 0x081451E0, out esi_327, out edi_328);
				if (g_b81451E8 != 0x00)
				{
					g_b81451E8 = 0x00;
					runtime.ready(gs, g_t81451E4);
				}
				word32 ebx_335;
				word32 edx_334;
				runtime.unlock(gs, 0x081451E0, out edx_334, out ebx_335);
				return xmm2;
			}
			else
			{
				word32 edi_330;
				word32 esi_329;
				runtime.lock(esi_40, gs, 0x081488E0, out esi_329, out edi_330);
				g_r8149160 = (real64) __xorps(xmm0, xmm0);
				word32 ebx_332;
				word32 edx_331;
				runtime.unlock(gs, 0x081488E0, out edx_331, out ebx_332);
				while (true)
				{
					word128 xmm0_333;
					runtime.sweepone(gs, xmm2, dwLoc10, out xmm0_333, out xmm2);
					++g_dw81451F0;
				}
			}
		}
	}
}

// 0805DA00: void runtime.gcResetMarkState(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.gcStart
//      runtime.gcMarkTermination.func2
void runtime.gcResetMarkState(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	word32 esi_86;
	word32 edi_87;
	runtime.lock(esi, gs, 0x08157590, out esi_86, out edi_87);
	Eq_4 eax_24 = g_t8145108;
	Eq_4 ecx_25 = g_t814510C;
	Eq_4 edx_26 = 0x00;
	while (edx_26 < ecx_25)
	{
		struct Eq_24852 * ebx_35 = *eax_24;
		ebx_35->w006F = 0x00;
		ebx_35->dw00CC = 0x00;
		ebx_35->dw00D0 = 0x00;
		eax_24 = (word32) eax_24 + 4;
		edx_26 = (word32) edx_26 + 1;
	}
	word32 edx_88;
	word32 ebx_89;
	runtime.unlock(gs, 0x08157590, out edx_88, out ebx_89);
	g_t81455E8.u0 = 0x00;
	g_t81455EC.u0 = 0x00;
	word64 mm0_90;
	runtime/internal/atomic.Load64(135632816, out mm0_90);
	g_t814564C = dwLoc08;
	g_t8145650 = dwLoc04;
	g_b8145628 = 0x00;
}

// 0805DAC0: void sync.runtime_registerPoolCleanup(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      sync.init.0
void sync.runtime_registerPoolCleanup(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (g_t81576F0 == 0x00)
		runtime.poolcleanup = dwArg04;
	else
		runtime.writebarrierptr(0x08144FE0, dwArg04);
}

// 0805DB10: void runtime.clearpools(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.gcStart
void runtime.clearpools(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 edx_17 = runtime.poolcleanup;
	if (edx_17 != 0x00)
		(*edx_17)();
	word32 esi_238;
	word32 edi_239;
	runtime.lock(esi, gs, 135550004, out esi_238, out edi_239);
	Eq_4 eax_155 = g_t8145438;
	while (eax_155 != 0x00)
	{
		Eq_4 ecx_139 = *((word32) eax_155 + 8);
		Eq_4 edx_140 = (word32) eax_155 + 8;
		if (g_t81576F0 == 0x00)
			((word32) eax_155 + 8)->u0 = 0x00;
		else
			runtime.writebarrierptr(edx_140, 0x00);
		eax_155 = ecx_139;
	}
	if (g_t81576F0 == 0x00)
		g_t8145438.u0 = 0x00;
	else
		runtime.writebarrierptr(135550008, 0x00);
	word32 ebx_243;
	word32 edx_242;
	runtime.unlock(gs, 135550004, out edx_242, out ebx_243);
	word32 edi_245;
	word32 esi_244;
	runtime.lock(esi, gs, 135550012, out esi_244, out edi_245);
	Eq_24984 eax_117 = 0x00;
	while (eax_117 < 0x05)
	{
		if (eax_117 >= 0x05)
			runtime.panicindex(gs);
		word32 ecx_113[] = g_a8145440;
		struct Eq_24999 * edx_138 = g_a8145440[eax_117 * 0x04];
		Eq_4 ebx_92 = eax_117 * 0x04 + 0x08145440;
		ebx_103 = ebx_92;
		eax_112 = eax_117;
		while (true)
		{
			Eq_24984 eax_112;
			Eq_4 ebx_103;
			if (edx_138 == null)
				break;
			struct Eq_24999 * ebp_119 = edx_138->ptr0018;
			Eq_4 esi_120 = &edx_138->ptr0018;
			if (g_t81576F0 == 0x00)
				edx_138->ptr0018 = null;
			else
			{
				runtime.writebarrierptr(esi_120, 0x00);
				eax_112 = eax_117;
				ecx_113 = g_a8145440;
				ebx_103 = ebx_92;
			}
			edx_138 = ebp_119;
		}
		if (g_t81576F0 == 0x00)
			ecx_113[eax_112] = 0x00;
		else
		{
			runtime.writebarrierptr(ebx_103, 0x00);
			eax_112 = eax_117;
		}
		eax_117 = (word32) eax_112 + 1;
	}
	word32 edx_240;
	word32 ebx_241;
	runtime.unlock(gs, 135550012, out edx_240, out ebx_241);
}

// 0805DCA0: void runtime.gchelper(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg00)
// Called from:
//      runtime.stopm
void runtime.gchelper(struct Eq_2 * gs, Eq_4 dwArg00)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 eax_19 = gs->ptr0000->tFFFFFFFC;
	*((word32) *((word32) eax_19 + 24) + 461) = 0x02;
	runtime.gchelperstart(gs);
	if (g_b814F4C8 != 0x00)
		runtime.traceGCScanStart(gs);
	if (runtime.gcphase == 0x02)
	{
		Eq_4 edx_43 = *((word32) *((word32) eax_19 + 24) + 92);
		if (g_b8145610 != 0x00)
		{
			word32 esi_178;
			word32 ebp_177;
			runtime.gcDrain(gs, (word32) edx_43 + 0x0950, 0x00, out ebp_177, out esi_178);
		}
		else
		{
			word32 ebp_175;
			word32 esi_176;
			runtime.gcDrain(gs, (word32) edx_43 + 0x0950, 0x02, out ebp_175, out esi_176);
		}
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_4 stackArg0 = <invalid>;
		runtime.(*gcWork).dispose(ebx_24_8, ebp, gs, stackArg0, (word32) edx_43 + 0x0950);
	}
	if (g_b814F4C8 != 0x00)
		runtime.traceGCScanDone(gs);
	runtime/internal/atomic.Load();
	runtime/internal/atomic.Xadd(0x08145608, 0x01);
	if (dwLoc10 - 0x01 == dwLoc0C)
		runtime.notewakeup(gs, 135550476);
	*((word32) *((word32) dwArg00 + 24) + 461) = 0x00;
}

// 0805DDD0: void runtime.gchelperstart(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.gcMark
//      runtime.gchelper
void runtime.gchelperstart(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 eax_18 = gs->ptr0000->tFFFFFFFC;
	Eq_4 ecx_19 = *((word32) eax_18 + 24);
	if (*((word32) ecx_19 + 0x0088) >= 0x20)
		runtime.throw(gs);
	else
	{
		if (eax_18 == *ecx_19)
			return;
		runtime.throw(gs);
	}
}

// 0805DE50: void runtime.itoaDiv(Register Eq_4 esi, Register ui32 edi, Register (ptr32 Eq_2) gs, Stack Eq_23298 dwArg04, Stack (ptr32 (arr Eq_25271)) dwArg08, Stack Eq_4 dwArg10, Stack Eq_4 dwArg14, Stack word32 dwArg18)
// Called from:
//      runtime.gcMarkTermination
//      runtime.fmtNSAsMS
void runtime.itoaDiv(Eq_4 esi, ui32 edi, struct Eq_2 * gs, Eq_23298 dwArg04, Eq_25271 (* dwArg08)[], Eq_4 dwArg10, Eq_4 dwArg14, word32 dwArg18)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_25271 (* ebx_170)[] = dwArg08 - 0x01;
	Eq_25271 (* ecx_21)[] = dwArg08 - 0x01 - dwArg18;
	Eq_4 edx_166 = dwArg14;
	Eq_4 ebp_167 = dwArg10;
	while (true)
	{
		ui24 ebx_24_8_51 = SLICE(edi, word24, 8);
		esi = SEQ(SLICE(esi, word24, 8), (int8) (edx_166 == 0x00)) & SEQ(ebx_24_8_51, (int8) (ebp_167 >= 0x0A));
		ui32 edi_69 = SEQ(ebx_24_8_51, (int8) (edx_166 > 0x00)) | esi;
		edi = edi_69;
		if ((byte) edi_69 == 0x00 && ebx_170 < ecx_21)
			break;
		runtime.uint64mod(gs, ebp_167, edx_166, 0x0A, 0x00);
		byte al_138 = (byte) dwLoc10 + 0x30;
		if (ebx_170 >= dwArg08)
			runtime.panicindex(gs);
		Mem139[dwArg04 + ebx_170:byte] = al_138;
		Eq_25271 (* eax_140)[] = ebx_170 - (Eq_25271 (*)[]) 0x01;
		if (ebx_170 - (Eq_25271 (*)[]) 0x01 == ecx_21)
		{
			if (ebx_170 - (Eq_25271 (*)[]) 0x01 >= dwArg08)
				runtime.panicindex(gs);
			Mem150[ebx_170 - 0x01 + dwArg04:byte] = 0x2E;
			eax_140 = ebx_170 - (Eq_25271 (*)[]) 0x02;
		}
		runtime.uint64div(gs, ebp_167, edx_166, 0x0A, 0x00);
		edx_166 = dwLoc0C;
		ebp_167 = dwLoc10;
		ebx_170 = eax_140;
	}
	up32 ebp_84 = (word32) ebp_167 + 48;
	if (ebx_170 >= dwArg08)
		runtime.panicindex(gs);
	else
		Mem97[dwArg04 + ebx_170:byte] = SLICE(ebp_84, byte, 0);
}

// 0805DFA0: void runtime.fmtNSAsMS(Register ui24 ebx_24_8, Register Eq_4 ebp, Register (ptr32 Eq_2) gs, Stack Eq_23298 dwArg04, Stack (ptr32 (arr Eq_25271)) dwArg08, Stack Eq_4 dwArg10, Stack Eq_4 dwArg14)
// Called from:
//      runtime.gcMarkTermination
void runtime.fmtNSAsMS(ui24 ebx_24_8, Eq_4 ebp, struct Eq_2 * gs, Eq_23298 dwArg04, Eq_25271 (* dwArg08)[], Eq_4 dwArg10, Eq_4 dwArg14)
{
	while (true)
	{
		Eq_4 ecx_7 = gs->ptr0000->tFFFFFFFC;
		ui24 ecx_24_8_28 = SLICE(ecx_7, word24, 8);
		if (fp > *((word32) ecx_7 + 8))
			break;
		runtime.morestack_noctxt();
	}
	ui32 ebx_37 = SEQ(ebx_24_8, (int8) (dwArg10 >= 10000000)) & SEQ(ecx_24_8_28, (int8) (dwArg14 == 0x00)) | SEQ(ecx_24_8_28, (int8) (dwArg14 > 0x00));
	ui24 ebx_24_8_46 = SLICE(ebx_37, word24, 8);
	if ((byte) ebx_37 != 0x00)
	{
		runtime.uint64div(gs, dwArg10, dwArg14, 1000000, 0x00);
		runtime.itoaDiv(esi, edi, gs, dwArg04, dwArg08, dwLoc18, dwLoc14, 0x00);
	}
	else if (((int8) (dwLoc14 == 0x00) & (int8) (dwLoc18 == 0x00)) != 0x00)
	{
		if (dwArg08 <= null)
			runtime.panicindex(gs);
		else
			*dwArg04 = 0x30;
	}
	else
	{
		word32 edx_115 = 0x03;
		while (true)
		{
			Eq_4 ebp_143 = SEQ(SLICE(ebp, word24, 8), (int8) (dwLoc18 >= 100)) & SEQ(ebx_24_8_46, (int8) (dwLoc14 == 0x00)) | SEQ(ebx_24_8_46, (int8) (dwLoc14 > 0x00));
			ebp = ebp_143;
			if ((byte) ebp_143 == 0x00)
				break;
			runtime.uint64div(gs, dwLoc18, dwLoc14, 0x0A, 0x00);
			--edx_115;
		}
		runtime.itoaDiv(esi, edi, gs, dwArg04, dwArg08, dwLoc18, dwLoc14, edx_115);
	}
}

// 0805E160: void runtime.(*mTreap).insert(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_25380) dwArg04, Stack Eq_4 dwArg08)
// Called from:
//      runtime.(*mheap).freeSpanLocked
void runtime.(*mTreap).insert(struct Eq_2 * gs, struct Eq_25380 * dwArg04, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 ecx_18 = *((word32) dwArg08 + 16);
	struct Eq_25380 * edx_19 = dwArg04;
	struct Eq_25380 * ebx_20 = dwArg04->dw0000;
	struct Eq_25380 * esi_22 = null;
	while (ebx_20 != null)
	{
		struct Eq_25380 * ebx_269;
		Eq_4 edx_237 = ebx_20[3];
		if (edx_237 < ecx_18)
			ebx_269 = ebx_20;
		else
		{
			struct Eq_25380 * edx_263;
			if (edx_237 > ecx_18)
				edx_263 = ebx_20 + 1;
			else
			{
				struct Eq_25380 * ebx_257;
				Eq_4 edx_242 = ebx_20[4];
				if (edx_242 < dwArg08)
					ebx_257 = ebx_20;
				else
				{
					if (edx_242 <= dwArg08)
						runtime.throw(gs);
					ebx_257 = ebx_20 + 1;
				}
				edx_263 = ebx_257;
			}
			ebx_269 = edx_263;
		}
		esi_22 = ebx_20;
		edx_19 = ebx_269;
		ebx_20 = ebx_269->dw0000;
	}
	runtime.(*fixalloc).alloc(gs, &g_dw814B588);
	dwLoc18->dw0000 = null;
	dwLoc18[1] = (struct Eq_25380) null;
	dwLoc18[2] = (struct Eq_25380) null;
	dwLoc18[4] = (struct Eq_25380) 0x00;
	dwLoc18[3] = (struct Eq_25380) 0x00;
	dwLoc18[5] = (struct Eq_25380) 0x00;
	dwLoc18[3] = (struct Eq_25380) *((word32) dwArg08 + 16);
	Eq_4 edx_55 = *((word32) gs->ptr0000->tFFFFFFFC + 24);
	Eq_25431 ebx_56 = *((word32) edx_55 + 0x0094);
	Eq_25431 ebp_61 = ebx_56 << 0x01 ^ ebx_56 >> 0x1F & 0xA8888EEF;
	*((word32) edx_55 + 0x0094) = ebp_61;
	dwLoc18[5] = (struct Eq_25380) ebp_61;
	dwLoc18[4] = (struct Eq_25380) dwArg08;
	dwLoc18[2] = (struct Eq_25380) esi_22;
	edx_19->dw0000 = dwLoc18;
	while (true)
	{
		struct Eq_25380 * ecx_73 = dwLoc18[2];
		if (ecx_73 == null || ecx_73[5] <= dwLoc18[5])
			break;
		Eq_4 ebx_87 = dwLoc18[3];
		if (*dwLoc18[4].dw0010 != ebx_87)
		{
			runtime.printlock(gs);
			runtime.printstring(gs);
			runtime.printsp(gs);
			runtime.printpointer(gs);
			runtime.printsp(gs);
			runtime.printstring(gs);
			runtime.printsp(gs);
			runtime.printint(ebx_24_8, gs, ebx_87);
			runtime.printnl(gs);
			runtime.printunlock(gs);
			Eq_4 ecx_146 = *dwLoc18[4].dw0010;
			runtime.printlock(gs);
			runtime.printstring(gs);
			runtime.printsp(gs);
			runtime.printpointer(gs);
			runtime.printsp(gs);
			runtime.printstring(gs);
			runtime.printsp(gs);
			runtime.printint(ebx_24_8, gs, ecx_146);
			runtime.printnl(gs);
			runtime.printunlock(gs);
			runtime.throw(gs);
		}
		if (ecx_73[1] != dwLoc18)
		{
			if (ecx_73->dw0000 != dwLoc18)
				runtime.throw(gs);
			runtime.(*mTreap).rotateLeft(gs, dwArg04, ecx_73);
		}
		else
			runtime.(*mTreap).rotateRight(gs, dwArg04, ecx_73);
	}
}

// 0805E400: void runtime.(*mTreap).removeNode(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_25380) dwArg04, Stack (ptr32 Eq_25380) dwArg08)
// Called from:
//      runtime.(*mTreap).remove
//      runtime.(*mTreap).removeSpan
void runtime.(*mTreap).removeNode(struct Eq_2 * gs, struct Eq_25380 * dwArg04, struct Eq_25380 * dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (*dwArg08[4].dw0010 != dwArg08[3])
		runtime.throw(gs);
	else
	{
		while (true)
		{
			struct Eq_25380 * edx_33 = dwArg08->dw0000;
			if (edx_33 == null && dwArg08[1] == null)
				break;
			if (edx_33 != null)
			{
				struct Eq_25380 * ebx_78 = dwArg08[1];
				if (ebx_78 != null && ebx_78[5] < edx_33[5])
					goto l0805E455;
				runtime.(*mTreap).rotateLeft(gs, dwArg04, dwArg08);
			}
			else
			{
l0805E455:
				runtime.(*mTreap).rotateRight(gs, dwArg04, dwArg08);
			}
		}
		struct Eq_25380 * edx_41 = dwArg08[2];
		if (edx_41 != null)
		{
			if (edx_41[1] == dwArg08)
				edx_41[1] = (struct Eq_25380) null;
			else
				edx_41->dw0000 = 0x00;
		}
		else
			dwArg04->dw0000 = 0x00;
		dwArg08[4] = (struct Eq_25380) null;
		dwArg08[3] = (struct Eq_25380) 0x00;
		g_dw814B5A0 -= g_dw814B588;
		dwArg08->dw0000 = g_ptr814B594;
		g_ptr814B594 = dwArg08;
	}
}

// 0805E510: void runtime.(*mTreap).remove(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_25380) dwArg04, Stack up32 dwArg08)
// Called from:
//      runtime.(*mheap).allocLarge
void runtime.(*mTreap).remove(struct Eq_2 * gs, struct Eq_25380 * dwArg04, up32 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	struct Eq_25380 * ecx_19;
	for (ecx_19 = dwArg04->dw0000; ecx_19 != null; ecx_19 = ecx_19->dw0000)
	{
		if (ecx_19[4] == 0x00)
			runtime.throw(gs);
		if (ecx_19[3] >= dwArg08)
		{
			struct Eq_25380 * ebp_47 = ecx_19[1];
			if (ebp_47 == null || ebp_47[3] < dwArg08)
			{
				runtime.(*mTreap).removeNode(gs, dwArg04, ecx_19);
				return;
			}
			else
			{
				ecx_19 = ebp_47;
				continue;
			}
		}
	}
}

// 0805E5B0: void runtime.(*mTreap).removeSpan(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_25380) dwArg04, Stack Eq_4 dwArg08)
// Called from:
//      runtime.(*mheap).freeSpanLocked
void runtime.(*mTreap).removeSpan(struct Eq_2 * gs, struct Eq_25380 * dwArg04, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 ecx_19 = *((word32) dwArg08 + 16);
	struct Eq_25380 * ebx_21 = dwArg04->dw0000;
	while (true)
	{
		Eq_4 ebp_24 = ebx_21[4];
		if (ebp_24 == dwArg08)
			break;
		Eq_4 esi_39 = ebx_21[3];
		if (esi_39 < ecx_19)
			ebx_21 = ebx_21->dw0000;
		else if (esi_39 > ecx_19)
			ebx_21 = (struct Eq_25380 *) ebx_21[1];
		else if (ebp_24 < dwArg08)
			ebx_21 = ebx_21->dw0000;
		else if (ebp_24 > dwArg08)
			ebx_21 = (struct Eq_25380 *) ebx_21[1];
	}
	runtime.(*mTreap).removeNode(gs, dwArg04, ebx_21);
}

// 0805E620: void runtime.scavengetreap(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_25797) dwArg04, Stack Eq_25798 qwArg08, Stack up32 dwArg10, Stack up32 dwArg14)
// Called from:
//      runtime.scavengetreap
//      runtime.(*mheap).scavenge
void runtime.scavengetreap(struct Eq_2 * gs, struct Eq_25797 * dwArg04, Eq_25798 qwArg08, up32 dwArg10, up32 dwArg14)
{
	Eq_25798 dwArg08 = (word32) qwArg08;
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (dwArg04 == null)
		return;
	runtime.scavengeTreapNode(dwArg14, gs, dwArg04, qwArg08, dwArg10, dwArg14);
	runtime.scavengetreap(gs, dwArg04->ptr0004, dwArg08, dwArg10, dwArg14);
	runtime.scavengetreap(gs, dwArg04->ptr0000, dwArg08, dwArg10, dwArg14);
}

// 0805E710: void runtime.(*mTreap).rotateLeft(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_25380) dwArg04, Stack (ptr32 Eq_25380) dwArg08)
// Called from:
//      runtime.(*mTreap).insert
//      runtime.(*mTreap).removeNode
void runtime.(*mTreap).rotateLeft(struct Eq_2 * gs, struct Eq_25380 * dwArg04, struct Eq_25380 * dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	struct Eq_25380 * ecx_18 = dwArg08->dw0000;
	struct Eq_25380 * edx_19 = dwArg08[2];
	struct Eq_25380 * ebx_20 = dwArg08[1];
	struct Eq_25380 * ebp_21 = ecx_18[1];
	struct Eq_25865 * esi_22 = ecx_18->dw0000;
	ecx_18[1] = (struct Eq_25380) dwArg08;
	dwArg08[2] = (struct Eq_25380) ecx_18;
	ecx_18->dw0000 = esi_22;
	if (esi_22 != null)
		esi_22->ptr0008 = ecx_18;
	dwArg08[1] = (struct Eq_25380) ebx_20;
	if (ebx_20 != null)
		ebx_20[2] = (struct Eq_25380) dwArg08;
	dwArg08->dw0000 = ebp_21;
	if (ebp_21 != null)
		ebp_21[2] = (struct Eq_25380) dwArg08;
	ecx_18[2] = (struct Eq_25380) edx_19;
	if (edx_19 == null)
		dwArg04->dw0000 = ecx_18;
	else if (edx_19[1] != dwArg08)
	{
		if (edx_19->dw0000 != dwArg08)
			runtime.throw(gs);
		else
			edx_19->dw0000 = ecx_18;
	}
	else
		edx_19[1] = (struct Eq_25380) ecx_18;
}

// 0805E7B0: void runtime.(*mTreap).rotateRight(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_25380) dwArg04, Stack (ptr32 Eq_25380) dwArg08)
// Called from:
//      runtime.(*mTreap).insert
//      runtime.(*mTreap).removeNode
void runtime.(*mTreap).rotateRight(struct Eq_2 * gs, struct Eq_25380 * dwArg04, struct Eq_25380 * dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	struct Eq_25380 * ecx_18 = dwArg08[1];
	struct Eq_25380 * edx_19 = dwArg08[2];
	struct Eq_25943 * ebx_20 = dwArg08->dw0000;
	struct Eq_25380 * ebp_21 = ecx_18[1];
	struct Eq_25380 * esi_22 = ecx_18->dw0000;
	if (ebp_21 != null)
		ebp_21[2] = (struct Eq_25380) ecx_18;
	ecx_18->dw0000 = dwArg08;
	dwArg08[2] = (struct Eq_25380) ecx_18;
	dwArg08[1] = (struct Eq_25380) esi_22;
	if (esi_22 != null)
		esi_22[2] = (struct Eq_25380) dwArg08;
	dwArg08->dw0000 = ebx_20;
	if (ebx_20 != null)
		ebx_20->ptr0008 = dwArg08;
	ecx_18[2] = (struct Eq_25380) edx_19;
	if (edx_19 == null)
		dwArg04->dw0000 = ecx_18;
	else if (edx_19[1] != dwArg08)
	{
		if (edx_19->dw0000 != dwArg08)
			runtime.throw(gs);
		else
			edx_19->dw0000 = ecx_18;
	}
	else
		edx_19[1] = (struct Eq_25380) ecx_18;
}

// 0805E840: void runtime.gcMarkRootPrepare(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.gcStart
//      runtime.gcMark
void runtime.gcMarkRootPrepare(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (runtime.gcphase == 0x02)
		g_t8145614 = runtime.gomaxprocs;
	else
		g_t8145614.u0 = 0x00;
	g_t8145618.u0 = 0x00;
	g_t814561C.u0 = 0x00;
	if (g_b8145628 == 0x00)
	{
		runtime.activeModules();
		Eq_4 edx_176 = 0x00;
		while (edx_176 < dwLoc18)
		{
			runtime.gcMarkRootPrepare.func1(gs);
			if (dwLoc18 > g_t8145618)
				g_t8145618 = dwLoc18;
			edx_176 = (word32) edx_176 + 1;
		}
		runtime.activeModules();
		Eq_4 edx_148 = 0x00;
		while (edx_148 < dwLoc18)
		{
			runtime.gcMarkRootPrepare.func1(gs);
			if (dwLoc18 > g_t814561C)
				g_t814561C = dwLoc18;
			edx_148 = (word32) edx_148 + 1;
		}
	}
	if (g_b8145628 != 0x00)
	{
		g_t8145620.u0 = 0x00;
		g_t8145624.u0 = 0x00;
		if (g_dw8157738 > 0x00)
		{
			runtime/internal/atomic.Loaduintptr();
			g_t8145624 = dwLoc18;
		}
	}
	else
	{
		runtime.(*gcSweepBuf).numBlocks(gs, (g_t81490F0 >> 0x01 & 0x01) * 0x14 + 135565588);
		g_t8145620 = dwLoc18;
		runtime/internal/atomic.Loaduintptr();
		g_t8145624 = dwLoc18;
	}
	g_t81455F0.u0 = 0x00;
	Mem119[0x081455F4<p32>:word32] = Mem109[0x08145624<p32>:word32] + 0x02 + (((Mem109[0x08145614<p32>:word32] + Mem109[0x08145618<p32>:word32]) + Mem109[0x0814561C<p32>:word32]) + Mem109[0x08145620<p32>:word32]);
}

// 0805EA40: void runtime.gcMarkRootCheck(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.gcMarkDone
//      runtime.gcMark
void runtime.gcMarkRootCheck(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 esp_115 = fp - 0x20;
	Eq_4 eax_17 = g_t81455F0;
	Eq_4 ecx_18 = g_t81455F4;
	if (eax_17 < ecx_18)
	{
		runtime.printlock(gs);
		runtime.printint(ebx_24_8, gs, eax_17);
		runtime.printstring(gs);
		runtime.printint(ebx_24_8, gs, ecx_18);
		runtime.printstring(gs);
		runtime.printunlock(gs);
		runtime.throw(gs);
	}
	else
	{
		Eq_4 ecx_155;
		word32 esi_363;
		word32 edi_364;
		runtime.lock(esi, gs, 0x08157590, out esi_363, out edi_364);
		if (runtime.gcphase == 0x02 && g_dw8157738 > 0x00)
		{
			Eq_4 eax_104 = 0x00;
			while (true)
			{
				Eq_4 ecx_108 = g_t8145108;
				Eq_4 edx_109 = g_t814510C;
				if (eax_104 >= edx_109)
					break;
				if (eax_104 >= edx_109)
					runtime.panicindex(gs);
				*((word32) esp_115 + 0x0C) = eax_104;
				Eq_4 ecx_131 = *((word32) ecx_108 + eax_104 * 0x04);
				if (*((word32) ecx_131 + 111) == 0x00 || *((word32) ecx_131 + 112) == 0x00)
				{
					*((word32) esp_115 + 28) = ecx_131;
					*esp_115 = ecx_131;
					runtime.readgstatus(*esp_115);
					esp_115.u0 = <invalid>;
					if (*((byte) esp_115.u0 + 4) != 0x06)
					{
						ecx_155 = *((byte) esp_115.u0 + 28);
						goto l0805EB28;
					}
					eax_104 = *((byte) esp_115.u0 + 0x0C);
				}
				eax_104 = (word32) eax_104 + 1;
			}
		}
		else
		{
			Eq_4 eax_102 = 0x00;
			while (eax_102 < g_t8145624)
			{
				Eq_4 ecx_86 = g_t8145108;
				if (eax_102 >= g_t814510C)
					runtime.panicindex(gs);
				ecx_155 = *((word32) ecx_86 + eax_102 * 0x04);
				if (*((word32) ecx_155 + 111) == 0x00)
				{
l0805EB28:
					*((byte) esp_115.u0 + 28) = ecx_155;
					*esp_115.u0 = ecx_155;
					runtime.readgstatus(*esp_115.u0);
					Eq_4 esp_161 = <invalid>;
					Eq_4 eax_166 = *((word32) esp_161 + 28);
					*((word32) esp_161 + 24) = *((word32) eax_166 + 84);
					*((word32) esp_161 + 20) = *((word32) eax_166 + 80);
					*((word32) esp_161 + 16) = *((word32) esp_161 + 4);
					*((word32) esp_161 + 11) = *((word32) eax_166 + 111);
					*((word32) esp_161 + 0x0A) = *((word32) eax_166 + 112);
					runtime.printlock(gs);
					esp_161->u0 = 0x080E0E11;
					((word32) esp_161 + 4)->u0 = 0x02;
					runtime.printstring(gs);
					runtime.printsp(gs);
					*esp_161 = *((word32) esp_161 + 28);
					runtime.printpointer(gs);
					runtime.printsp(gs);
					esp_161->u0 = 135139114;
					((word32) esp_161 + 4)->u0 = 0x04;
					runtime.printstring(gs);
					runtime.printsp(gs);
					*esp_161 = *((word32) esp_161 + 20);
					*((word32) esp_161 + 4) = *((word32) esp_161 + 24);
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					Eq_4 stackArg4 = <invalid>;
					runtime.printint(ebx_24_8, gs, stackArg4);
					runtime.printsp(gs);
					esp_161->u0 = 0x080E1184;
					((word32) esp_161 + 4)->u0 = 0x06;
					runtime.printstring(gs);
					runtime.printsp(gs);
					*esp_161 = *((word32) esp_161 + 16);
					((word32) esp_161 + 4)->u0 = 0x00;
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					Eq_4 stackArg4 = <invalid>;
					runtime.printint(ebx_24_8, gs, stackArg4);
					runtime.printsp(gs);
					esp_161->u0 = 135141731;
					((word32) esp_161 + 4)->u0 = 0x0A;
					runtime.printstring(gs);
					runtime.printsp(gs);
					*esp_161 = *((word32) esp_161 + 11);
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					Eq_4 stackArg4 = <invalid>;
					runtime.printbool(gs, stackArg4);
					runtime.printsp(gs);
					esp_161->u0 = 0x080E1B8A;
					((word32) esp_161 + 4)->u0 = 11;
					runtime.printstring(gs);
					runtime.printsp(gs);
					*esp_161 = *((word32) esp_161 + 0x0A);
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					Eq_4 stackArg4 = <invalid>;
					runtime.printbool(gs, stackArg4);
					runtime.printnl(gs);
					runtime.printunlock(gs);
					esp_161->u0 = 0x08157590;
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					Eq_4 stackArg4 = <invalid>;
					word32 edx_372;
					word32 ebx_373;
					runtime.unlock(gs, stackArg4, out edx_372, out ebx_373);
					esp_161->u0 = 0x080E23EC;
					((word32) esp_161 + 4)->u0 = 0x0F;
					runtime.throw(gs);
				}
				eax_102 = (word32) eax_102 + 1;
			}
		}
		word32 edx_365;
		word32 ebx_366;
		runtime.unlock(gs, 0x08157590, out edx_365, out ebx_366);
	}
}

// 0805ED10: void runtime.markroot(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg08)
// Called from:
//      runtime.gcDrain
//      runtime.gcDrainN
void runtime.markroot(struct Eq_2 * gs, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 eax_17 = g_t8145614;
	Eq_4 edx_19 = g_t8145618;
	word32 ebx_20 = edx_19 + eax_17;
	Eq_4 ebp_21 = g_t814561C;
	word32 esi_22 = (word32) ebp_21 + ebx_20;
	Eq_4 edi_24 = g_t8145620;
	struct Eq_26497 * esp_16 = fp - 0x48;
	up32 esi_25 = (word32) edi_24 + esi_22;
	Eq_4 esi_27 = g_t8145624;
	if (dwArg08 < 0x02 || dwArg08 >= (word32) eax_17 + 2)
	{
		Eq_4 eax_42 = (word32) eax_17 + ((word32) edx_19 + 2);
		if ((word32) eax_17 + 2 > dwArg08 || dwArg08 >= eax_42)
		{
			Eq_4 ecx_102 = (word32) ebp_21 + (ebx_20 + 0x02);
			if (eax_42 > dwArg08 || dwArg08 >= ecx_102)
			{
				if (dwArg08 != 0x00)
				{
					if (dwArg08 != 0x01)
					{
						Eq_4 eax_172 = (word32) edi_24 + (esi_22 + 0x02);
						if (ecx_102 > dwArg08 || dwArg08 >= eax_172)
						{
							if (eax_172 > dwArg08 || dwArg08 >= (word32) esi_27 + (esi_25 + 0x02))
								runtime.throw(gs);
							else
							{
								Eq_4 edx_212 = g_t8145108;
								Eq_4 esi_213 = dwArg08 - eax_172;
								if (esi_213 >= g_t814510C)
									runtime.panicindex(gs);
								else
								{
									Eq_4 eax_234;
									runtime.readgstatus(*((word32) edx_212 + esi_213 * 0x04));
									Eq_4 esp_224 = <invalid>;
									Eq_4 eax_229 = *((word32) esp_224 + 4);
									if (eax_229 == 0x04 || eax_229 == 0x03)
									{
										eax_234 = *((word32) esp_224 + 44);
										Eq_4 ecx_238 = *((word32) eax_234 + 88);
										Eq_4 edx_239 = *((word32) eax_234 + 92);
										if (((int8) (edx_239 == 0x00) & (int8) (ecx_238 == 0x00)) != 0x00)
										{
											Eq_4 ecx_255 = g_t8145600;
											*((word32) eax_234 + 88) = g_t81455FC;
											*((word32) eax_234 + 92) = ecx_255;
										}
									}
									else
										eax_234 = *((word32) esp_224 + 44);
									((word32) esp_224 + 60)->u0 = 0x0808C740;
									*((word32) esp_224 + 64) = eax_234;
									*((word32) esp_224 + 0x0044) = *((word32) esp_224 + 76);
									*esp_224 = (word32) esp_224 + 60;
									// Failed to bind call argument.
									// Please report this issue at https://github.com/uxmal/reko
									Eq_4 stackArg4 = <invalid>;
									word32 ebp_469;
									word32 edi_470;
									runtime.systemstack(gs, stackArg4, out ebp_469, out edi_470);
								}
							}
						}
						else
							runtime.markrootSpans(gs);
					}
					else if (g_b8145628 == 0x00)
					{
						word32 ebp_466;
						word32 edi_467;
						runtime.systemstack(gs, 0x080E7C3C, out ebp_466, out edi_467);
					}
				}
				else if (g_b8145628 == 0x00)
				{
					struct Eq_19457 * eax_290 = runtime.allfin;
					while (eax_290 != null)
					{
						esp_16[0x0C] = (struct Eq_26497) eax_290;
						esp_16->dw0000 = &eax_290->t0008;
						runtime/internal/atomic.Load();
						++esp_16;
						ui32 eax_301 = esp_16[1];
						word32 ecx_302 = esp_16[0x0C];
						esp_16[2] = (struct Eq_26497) 0x081577E0;
						esp_16->dw0000 = ecx_302 + 0x10;
						esp_16[1] = (struct Eq_26497) (eax_301 * 0x14);
						esp_16[3] = esp_16[19];
						// Failed to bind call argument.
						// Please report this issue at https://github.com/uxmal/reko
						// Failed to bind call argument.
						// Please report this issue at https://github.com/uxmal/reko
						Eq_4 stackArg4 = <invalid>;
						Eq_4 stackArg16 = <invalid>;
						word32 ebp_464;
						word32 esi_465;
						runtime.scanblock(gs, stackArg4, dwArg04, dwArg08, stackArg16, out ebp_464, out esi_465);
						eax_290 = (struct Eq_19457 *) *esp_16[0x0C].dw0000;
					}
				}
			}
			else
			{
				runtime.activeModules();
				word32 * eax_118 = dwLoc48;
				int32 edx_121;
				for (edx_121 = 0x00; edx_121 < dwLoc44; ++edx_121)
				{
					struct Eq_26665 * ecx_132 = *eax_118;
					up32 edx_133 = ecx_132->dw0048;
					runtime.markrootBlock(gs, edx_133, ecx_132->dw004C - edx_133, ecx_132->dw00D0, dwArg08 - eax_42);
					++eax_118;
				}
			}
		}
		else
		{
			runtime.activeModules();
			word32 * eax_58 = dwLoc48;
			int32 edx_61;
			for (edx_61 = 0x00; edx_61 < dwLoc44; ++edx_61)
			{
				struct Eq_26619 * ecx_72 = *eax_58;
				up32 edx_73 = ecx_72->dw0040;
				runtime.markrootBlock(gs, edx_73, ecx_72->dw0044 - edx_73, ecx_72->dw00C8, dwArg08 - ((word32) eax_17 + 2));
				++eax_58;
			}
		}
	}
	else
		runtime.flushmcache(gs, dwArg08 - 0x02);
}

// 0805F010: void runtime.markrootBlock(Register (ptr32 Eq_2) gs, Stack up32 dwArg04, Stack word32 dwArg08, Stack word32 dwArg0C, Stack uint32 dwArg14)
// Called from:
//      runtime.markroot
void runtime.markrootBlock(struct Eq_2 * gs, up32 dwArg04, word32 dwArg08, word32 dwArg0C, uint32 dwArg14)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 ebx_21 = (dwArg14 << 0x12) + dwArg04;
	Eq_4 ebp_23 = dwArg08 + dwArg04;
	if (ebx_21 >= ebp_23)
		return;
	Eq_26604 ebp_34;
	Eq_4 ecx_31 = (dwArg14 << 0x0D) + dwArg0C;
	if (dwArg04 + 0x00040000 + (dwArg14 << 0x12) > ebp_23)
		ebp_34 = ebp_23 - ebx_21;
	else
		ebp_34.u0 = 0x00040000;
	word32 esi_95;
	word32 ebp_94;
	runtime.scanblock(gs, ebx_21, ebp_34, ecx_31, dwArg10, out ebp_94, out esi_95);
}

// 0805F090: void runtime.markrootFreeGStacks(Register Eq_4 esi, Register (ptr32 Eq_2) gs)
void runtime.markrootFreeGStacks(Eq_4 esi, struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 esi_28;
	word32 edi_190;
	runtime.lock(esi, gs, 0x08145424, out esi_28, out edi_190);
	Eq_4 eax_33 = g_t8145428;
	if (g_t81576F0 == 0x00)
		g_t8145428.u0 = 0x00;
	else
		runtime.writebarrierptr(135549992, 0x00);
	word32 edx_195;
	word32 ebx_196;
	runtime.unlock(gs, 0x08145424, out edx_195, out ebx_196);
	Eq_4 eax_64 = eax_33;
	if (eax_33 == 0x00)
		return;
	Eq_4 edx_71 = eax_33;
	while (eax_64 != 0x00)
	{
		runtime.shrinkstack(gs, eax_64);
		edx_71 = eax_64;
		eax_64 = *((word32) eax_64 + 0x0068);
	}
	word32 edi_192;
	word32 esi_191;
	runtime.lock(esi_28, gs, 0x08145424, out esi_191, out edi_192);
	*((word32) edx_71 + 0x0068) = g_t814542C;
	if (g_t81576F0 == 0x00)
		g_t814542C = eax_33;
	else
		runtime.writebarrierptr(135549996, eax_33);
	word32 ebx_194;
	word32 edx_193;
	runtime.unlock(gs, 0x08145424, out edx_193, out ebx_194);
}

// 0805F1A0: void runtime.markrootSpans(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.markroot
void runtime.markrootSpans(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (g_b8145628 != 0x00)
		runtime.throw(gs);
	else
	{
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_4 eax_29 = g_t81490F0;
		Eq_4 stackArg0 = <invalid>;
		runtime.(*gcSweepBuf).block(gs, stackArg0, (eax_29 >> 0x01 & 0x01) * 0x14 + 135565588, dwArg08, dwLoc2C);
		int32 eax_173 = dwLoc28;
		word32 * ecx_177 = dwLoc2C;
		int32 edx_180;
		for (edx_180 = 0x00; edx_180 < eax_173; ++edx_180)
		{
			struct Eq_26951 * ebx_60 = *ecx_177;
			if (ebx_60->b003C == 0x01)
			{
				if (g_b8157583 == 0x00)
				{
					Eq_4 ebp_82 = ebx_60->t0030;
					esi = eax_29;
					if (ebp_82 != eax_29)
					{
						runtime.printlock(gs);
						runtime.printstring(gs);
						runtime.printint(SLICE(ebx_60, word24, 8), gs, ebp_82);
						runtime.printstring(gs);
						runtime.printint(SLICE(ebx_60, word24, 8), gs, eax_29);
						runtime.printstring(gs);
						runtime.printunlock(gs);
						runtime.throw(gs);
					}
				}
				if (ebx_60->ptr0058 != null)
				{
					word32 esi_348;
					word32 edi_349;
					runtime.lock(esi, gs, (char *) &ebx_60->t0040 + 20, out esi_348, out edi_349);
					struct Eq_26951 * eax_158 = ebx_60;
					struct Eq_26976 * ecx_159;
					for (ecx_159 = ebx_60->ptr0058; ecx_159 != null; ecx_159 = ecx_159->ptr0000)
					{
						if (ecx_159->b0006 == 0x01)
						{
							word32 edx_186 = (word32) ecx_159->w0004;
							Eq_27014 ebx_188 = eax_158->t0040;
							word32 ebp_189 = eax_158->dw000C;
							if (ebx_188 == 0x00)
								runtime.panicdivide(gs);
							word32 ebp_352;
							runtime.scanobject(gs, ebp_189 + (uint32) ((uint64) edx_186 /u ebx_188) *s ebx_188, dwArg04, out ebp_352);
							word32 esi_354;
							word32 ebp_353;
							runtime.scanblock(gs, &ecx_159->b0006 + 2, 0x04, 0x08136000, dwArg04, out ebp_353, out esi_354);
							eax_158 = ebx_60;
						}
					}
					word32 edx_350;
					word32 ebx_351;
					runtime.unlock(gs, (char *) &ebx_60->t0040 + 20, out edx_350, out ebx_351);
					eax_173 = dwLoc28;
				}
			}
			++ecx_177;
		}
	}
}

// 0805F3C0: void runtime.gcAssistAlloc(Register ptr32 esi, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
// Called from:
//      runtime.mallocgc
void runtime.gcAssistAlloc(ptr32 esi, struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 edx_20 = gs->ptr0000->tFFFFFFFC;
	if (edx_20 == *(*((word32) dwArg04 + 24)))
		return;
	Eq_4 ecx_26 = *((word32) edx_20 + 24);
	if (*((word32) ecx_26 + 0x0078) > 0x00 || *((word32) ecx_26 + 116) != 0x00)
		return;
	byte cl_37 = 0x00;
	while (true)
	{
		Eq_4 ebx_112;
		int32 edx_111;
		ui64 ebp_ebx_502 = 0x00 - SEQ(edx_46, *((word32) dwArg04 + 0x00CC));
		Eq_4 ebx_43 = (word32) ebp_ebx_502;
		Eq_4 edx_46 = *((word32) dwArg04 + 0x00D0);
		real64 rLoc14_639 = (real64) (uint128) g_r81578A0;
		runtime.int64tofloat64(SLICE(ebx_43, word24, 8), gs, ebx_43);
		real64 v17_63 = (real64) (uint128) rLoc14_639 * (real64) ((uint128) rLoc4C);
		Eq_4 dwLoc4C_647 = (word32) rLoc4C;
		int32 dwLoc48_646 = SLICE(rLoc4C, word32, 32);
		word128 xmm0_770;
		runtime.float64toint64(gs, v17_63, out xmm0_770);
		byte bLoc45_695 = SLICE(rLoc4C, byte, 56);
		int32 ebp_52 = SLICE(ebp_ebx_502, word32, 32);
		Eq_4 dwLoc50_657 = SLICE(v17_63, word32, 32);
		Eq_4 ecx_113 = dwLoc4C_647;
		Eq_27155 dwLoc40_662 = SEQ(cl_37, nLoc40);
		if (((int8) (dwLoc4C_647 < 0x00010000) & (int8) (dwLoc48_646 == 0x00) | (int8) (dwLoc48_646 < 0x00)) == 0x00)
		{
			edx_111 = ebp_52;
			ebx_112 = ebx_43;
		}
		else
		{
			real64 rLoc14_648 = (real64) (uint128) g_r81578A8;
			runtime.int64tofloat64(SLICE(dwLoc4C_647, word24, 8), gs, 0x00010000);
			real64 v22_103 = (real64) (uint128) rLoc4C * (real64) ((uint128) rLoc14_648);
			word128 xmm0_771;
			runtime.float64toint64(gs, v22_103, out xmm0_771);
			dwLoc50_657 = SLICE(v22_103, word32, 32);
			edx_111 = dwLoc48_646;
			ebx_112 = dwLoc4C_647;
			ecx_113.u0 = 0x00010000;
		}
		ui24 edx_24_8_150 = SLICE(edx_111, word24, 8);
		ui32 ebx_156 = SEQ(SLICE(runtime/internal/atomic.Loadint64(0x08157868), word24, 8), (int8) false) & SEQ(edx_24_8_150, (int8) (dwLoc50_657 == 0x00)) | SEQ(edx_24_8_150, (int8) (dwLoc50_657 > 0x00));
		real64 rLoc50_673 = SEQ(dwLoc4C_647, dwLoc50_657);
		word56 nLoc4C_726 = (word56) rLoc4C;
		if ((byte) ebx_156 != 0x00)
		{
			int64 edx_ebp_767;
			nLoc4C_726 = (word56) rLoc4C;
			if (((int8) (dwLoc40_662 > 0x08157868) & (int8) (dwLoc50_657 == ecx_113) | (int8) (dwLoc50_657 < ecx_113)) == 0x00)
			{
				ui64 ecx_ebx_508 = SEQ(*((word32) dwArg08 + 0x00D0), dwLoc30) + SEQ(ebx_112, *((word32) dwArg08 + 0x00CC));
				*((word32) dwArg08 + 0x00CC) = (word32) ecx_ebx_508;
				*((word32) dwArg08 + 0x00D0) = SLICE(ecx_ebx_508, word32, 32);
				edx_ebp_767 = SEQ(ecx_113, dwLoc40_662);
			}
			else
			{
				Eq_4 ebx_201 = *((word32) dwArg08 + 0x00D0);
				Eq_13922 ebp_203 = *((word32) dwArg08 + 0x00CC);
				real64 rLoc18_669 = (real64) (uint128) g_r81578A8;
				runtime.int64tofloat64(SLICE(ebx_201, word24, 8), gs, 0x08157868);
				word128 xmm0_774;
				runtime.float64toint64(gs, (real64) (uint128) rLoc50_673 * (real64) ((uint128) rLoc18_669), out xmm0_774);
				word32 eax_227 = dwLoc50_657 + ebp_203;
				*((word32) dwArg08 + 0x00CC) = (word32) eax_227 + 1;
				*((word32) dwArg08 + 0x00D0) = (bool) (eax_227 < 0x01) + SLICE(SEQ(dwLoc4C_647, dwLoc50_657) + SEQ(ebx_201, ebp_203), word32, 32);
				dwLoc24 = ebx_201;
				nLoc4C_726 = (word56) rLoc4C;
				edx_ebp_767 = SEQ(dwLoc50_657, 0x08157868);
			}
			word32 ebx_283;
			word32 ebp_775;
			runtime/internal/atomic.Xaddint64(0x08157868, 0x00 - (word32) edx_ebp_767, SLICE(0x00 - edx_ebp_767, word32, 32), out ebx_283, out ebp_775);
			if (((int8) (SLICE(SEQ(dwLoc40_662, dwLoc44) - SEQ(dwLoc24, SLICE(edx_ebp_767, word32, 32)), word32, 32) == 0x00) & (int8) (ecx_113 == 0x00)) != 0x00)
			{
				if (bLoc45_695 != 0x00)
					runtime.traceGCMarkAssistDone(gs);
				return;
			}
		}
		byte dl_358;
		if (g_b814F4C8 != 0x00)
		{
			if (bLoc45_695 != 0x00)
				dl_358 = 0x01;
			else
			{
				runtime.traceGCMarkAssistStart(gs);
				dl_358 = 0x01;
			}
		}
		else
			dl_358 = bLoc45_695;
		word32 ebp_772;
		word32 edi_773;
		runtime.systemstack(gs, fp - 0x10, out ebp_772, out edi_773);
		Eq_4 ebx_383 = g_t81576F0;
		byte bLoc5C_715 = (byte) fp - 0x10;
		Eq_4 ecx_381 = *((word32) dwArg04 + 0x0044);
		if (ebx_383 == 0x00)
			((word32) dwArg04 + 0x0044)->u0 = 0x00;
		else
		{
			runtime.writebarrierptr((word32) dwArg04 + 0x0044, dwArg04);
			bLoc5C_715 = (byte) dwArg04 + 0x44;
		}
		if (ecx_381 != 0x00)
			runtime.gcMarkDone(gs);
		Eq_4 ecx_412 = *((word32) dwArg04 + 0x00D0);
		if (((int8) Test(ULT,false) & (int8) (ecx_412 == 0x00) | (int8) (ecx_412 < 0x00)) == 0x00)
			break;
		if (*((word32) dwArg04 + 0x006C) == 0x00)
		{
			runtime.gcParkAssist(gs);
			if (bLoc5C_715 != 0x00)
				break;
			cl_37 = dl_358;
			continue;
		}
		runtime.Gosched(gs);
		cl_37 = dl_358;
		rLoc4C = SEQ(dl_358, nLoc4C_726);
	}
	if (dl_358 != 0x00)
		runtime.traceGCMarkAssistDone(gs);
}

// 0805F7E0: void runtime.gcAssistAlloc1(Register (ptr32 Eq_2) gs, Stack word32 dwArg00, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C, Stack int32 dwArg10)
// Called from:
//      runtime.gcAssistAlloc.func1
void runtime.gcAssistAlloc1(struct Eq_2 * gs, word32 dwArg00, Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C, int32 dwArg10)
{
	word32 dwLoc38 = SLICE(qwLoc3C, word32, 32);
	ui32 dwLoc3C = (word32) qwLoc3C;
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 0x0C))
		runtime.morestackc();
	if (g_t81576F0 == 0x00)
		((word32) dwArg04 + 0x0044)->u0 = 0x00;
	else
	{
		runtime.writebarrierptr((word32) dwArg04 + 0x0044, 0x00);
		dwLoc48 = 0x00;
	}
	runtime/internal/atomic.Load();
	if (dwLoc44 != 0x00)
	{
		runtime.nanotime();
		word24 ebx_24_8_101 = SLICE(runtime/internal/atomic.Xadd(0x08145604, ~0x00), word24, 8);
		Eq_4 ecx_70 = g_t81455F8;
		if (dwLoc40 == ecx_70)
		{
			runtime.printlock(gs);
			runtime.printstring(gs);
			runtime.printsp(gs);
			runtime.printint(ebx_24_8_101, gs, (uint64) dwLoc40);
			runtime.printsp(gs);
			runtime.printstring(gs);
			runtime.printsp(gs);
			runtime.printint(ebx_24_8_101, gs, (uint64) ecx_70);
			runtime.printnl(gs);
			runtime.printunlock(gs);
			runtime.throw(gs);
		}
		else
		{
			runtime.casgstatus(dwArg08, 0x02, 0x04);
			((word32) dwArg08 + 100)->u0 = 0x11;
			if (g_t81576F0 == 0x00)
				((word32) dwArg08 + 96)->u0 = 0x080E2730;
			else
				runtime.writebarrierptr((word32) dwArg08 + 96, 0x080E2730);
			Eq_4 ecx_204 = *((word32) *((word32) gs->ptr0000->tFFFFFFFC + 24) + 92);
			Eq_4 ebp_218;
			ui24 ebx_24_8_240 = SLICE(runtime.gcDrainN(gs, &runtime.gcBlackenEnabled, (word32) ecx_204 + 0x0950, dwArg0C, dwArg10, out ebp_218), word24, 8);
			if (g_t815756D != 0x00)
				runtime.(*gcWork).dispose(ebx_24_8_240, ebp_218, gs, 135624156, (word32) ecx_204 + 0x0950);
			runtime.casgstatus(dwArg08, 0x04, 0x02);
			Eq_4 ecx_269 = *((word32) dwArg08 + 0x00D0);
			Eq_4 edx_271 = *((word32) dwArg08 + 0x00CC);
			real64 rLoc10_656 = (real64) (uint128) g_r81578A8;
			runtime.int64tofloat64(SLICE(dwLoc38, word24, 8), gs, qwLoc3C);
			word128 xmm0_781;
			runtime.float64toint64(gs, (real64) (uint128) rLoc10_656 * (real64) ((uint128) SEQ(dwLoc3C, 0x02)), out xmm0_781);
			*((word32) dwArg08 + 0x00CC) = (word32) edx_271 + 3;
			*((word32) dwArg08 + 0x00D0) = (bool) (edx_271 < 0x01) + SLICE(SEQ(dwLoc3C, 0x02) + SEQ(ecx_269, edx_271), word32, 32);
			word24 ebx_24_8_366 = SLICE(runtime/internal/atomic.Xadd(0x08145604, 0x01), word24, 8);
			Eq_4 ecx_336 = g_t81455F8;
			if (ecx_336 < 0x02)
			{
				runtime.printlock(gs);
				runtime.printstring(gs);
				runtime.printsp(gs);
				runtime.printint(ebx_24_8_366, gs, 0x02);
				runtime.printsp(gs);
				runtime.printstring(gs);
				runtime.printsp(gs);
				runtime.printint(ebx_24_8_366, gs, (uint64) ecx_336);
				runtime.printsp(gs);
				runtime.printstring(gs);
				runtime.printsp(gs);
				runtime.printbool(gs, g_t815756D);
				runtime.printnl(gs);
				runtime.printunlock(gs);
				runtime.throw(gs);
			}
			else
			{
				uip64 qwLoc48_776 = 0x108145604;
				if (ecx_336 == 0x02)
				{
					runtime.gcMarkWorkAvailable(gs, 0x00);
					qwLoc48_776 = 0x100000000;
				}
				runtime.nanotime();
				Eq_4 ecx_503 = *((word32) *((word32) dwArg08 + 24) + 92);
				uint32 eax_509 = (word32) qwLoc48_776 - dwLoc48;
				Eq_4 ebp_511 = *((word32) ecx_503 + 0x0940);
				Eq_4 ebp_513 = (word32) ebp_511 + eax_509;
				Eq_4 eax_515 = *((word32) ecx_503 + 0x0944);
				*((word32) ecx_503 + 0x0940) = ebp_513;
				ui64 edi_ebx_580 = qwLoc48_776 - SEQ(dwLoc44, dwLoc48);
				Eq_4 eax_526 = SLICE(SEQ(eax_515, ebp_511) + SEQ(SLICE(edi_ebx_580, word32, 32), eax_509), word32, 32);
				*((word32) ecx_503 + 0x0944) = eax_526;
				if (((int8) (eax_526 > 0x00) | (int8) (eax_526 == 0x00) & (int8) (ebp_513 > 5000)) != 0x00)
				{
					word32 ebp_783;
					word32 ebx_782;
					runtime/internal/atomic.Xaddint64(0x08157870, ebp_513, eax_526, out ebx_782, out ebp_783);
					*((word32) ecx_204 + 4752) = 0x00;
					*((word32) ecx_204 + 4756) = 0x00;
				}
			}
		}
	}
	else
	{
		((word32) dwArg08 + 0x00CC)->u0 = 0x00;
		((word32) dwArg08 + 0x00D0)->u0 = 0x00;
	}
}

// 0805FC80: void runtime.gcWakeAllAssists(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.gcMarkDone
void runtime.gcWakeAllAssists(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	word32 esi_55;
	word32 edi_56;
	runtime.lock(esi, gs, 135550548, out esi_55, out edi_56);
	runtime.injectglist(gs, g_t8145658);
	g_t8145658.u0 = 0x00;
	g_t814565C.u0 = 0x00;
	word32 edx_57;
	word32 ebx_58;
	runtime.unlock(gs, 135550548, out edx_57, out ebx_58);
}

// 0805FCF0: void runtime.gcParkAssist(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.gcAssistAlloc
void runtime.gcParkAssist(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	word32 edi_216;
	word32 esi_215;
	runtime.lock(esi, gs, 135550548, out esi_215, out edi_216);
	runtime/internal/atomic.Load();
	if (dwLoc14 == 0x00)
	{
		word32 ebx_218;
		word32 edx_217;
		runtime.unlock(gs, 135550548, out edx_217, out ebx_218);
	}
	else
	{
		Eq_4 eax_42 = gs->ptr0000->tFFFFFFFC;
		Eq_4 edx_45 = g_t814565C;
		if (g_t8145658 == 0x00)
			g_t8145658 = eax_42;
		else
			*((word32) edx_45 + 0x0068) = eax_42;
		g_t814565C = eax_42;
		((word32) eax_42 + 0x0068)->u0 = 0x00;
		runtime/internal/atomic.Loadint64(0x08157868);
		if (((int8) (dwLoc14 > 0x00) | (byte) ((uint32) ((int8) (dwLoc14 == 0x00))) & (int8) false) == 0x00)
			runtime.goparkunlock(gs);
		else
		{
			g_t8145658 = edx_45;
			g_t814565C = dwLoc08;
			if (dwLoc08 != 0x00)
				((word32) dwLoc08 + 0x0068)->u0 = 0x00;
			word32 ebx_220;
			word32 edx_219;
			runtime.unlock(gs, 135550548, out edx_219, out ebx_220);
		}
	}
}

// 0805FE60: void runtime.gcFlushBgCredit(Register ui24 ebx_24_8, Register ui32 ebp, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
// Called from:
//      runtime.gcDrain
void runtime.gcFlushBgCredit(ui24 ebx_24_8, ui32 ebp, struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (g_t8145658 == 0x00)
	{
		word32 ebx_414;
		word32 ebp_415;
		runtime/internal/atomic.Xaddint64(0x08157868, dwArg04, dwArg08, out ebx_414, out ebp_415);
	}
	else
	{
		runtime.int64tofloat64(ebx_24_8, gs, dwArg04);
		word128 xmm0_417;
		runtime.float64toint64(gs, (real64) (uint128) g_r81578A8 * (real64) ((uint128) rLoc20), out xmm0_417);
		word32 esi_419;
		word32 edi_420;
		runtime.lock(esi, gs, 135550548, out esi_419, out edi_420);
		Eq_4 eax_172 = g_t8145658;
		Eq_27898 edx_ecx_408 = rLoc20;
		while (true)
		{
			Eq_4 edx_117;
			Eq_4 ecx_118;
			word56 nLoc1F_349 = SLICE(rLoc20, word56, 8);
			Eq_4 ecx_77 = (word32) edx_ecx_408;
			int32 eax_411 = SLICE(edx_ecx_408, word32, 32);
			if (eax_172 == 0x00)
				break;
			ui32 ebp_104 = SEQ(SLICE(ebp, word24, 8), (int8) (ecx_77 > 0x00)) & SEQ(ebx_24_8, (int8) (eax_411 == 0x00)) | SEQ(ebx_24_8, (int8) (eax_411 > 0x00));
			if ((byte) ebp_104 == 0x00)
			{
				edx_117 = ecx_77;
				ecx_118 = eax_172;
				goto l0805FFC3;
			}
			Eq_4 ebx_123 = *((word32) eax_172 + 0x00D0);
			ui64 edx_ecx_307 = edx_ecx_408 + SEQ(ebx_123, Mem119[eax_172 + 0xCC:word32]);
			Eq_4 edx_125 = SLICE(edx_ecx_307, word32, 32);
			ui24 ebx_24_8_131 = SLICE(ebx_123, word24, 8);
			ui32 ebp_146 = SEQ(SLICE(ebp_104, word24, 8), (int8) Test(UGE,false)) & SEQ(ebx_24_8_131, (int8) (edx_125 == 0x00)) | SEQ(ebx_24_8_131, (int8) (edx_125 > 0x00));
			Eq_4 ecx_121 = (word32) edx_ecx_307;
			ebx_24_8 = ebx_24_8_131;
			ebp = ebp_146;
			if ((byte) ebp_146 == 0x00)
			{
				*((word32) eax_172 + 0x00CC) = ecx_121;
				*((word32) eax_172 + 0x00D0) = edx_125;
				ecx_118 = *((word32) eax_172 + 0x0068);
				if (ecx_118 != 0x00)
				{
					((word32) eax_172 + 0x0068)->u0 = 0x00;
					*((word32) g_t814565C + 0x0068) = eax_172;
					g_t814565C = eax_172;
				}
				else
					ecx_118 = eax_172;
				edx_117.u0 = 0x00;
				eax_411 = 0x00;
				goto l0805FFC3;
			}
			((word32) eax_172 + 0x00CC)->u0 = 0x00;
			((word32) eax_172 + 0x00D0)->u0 = 0x00;
			Eq_4 ecx_162 = *((word32) eax_172 + 0x0068);
			runtime.ready(gs, eax_172);
			eax_172 = ecx_162;
			rLoc20 = SEQ(nLoc1F_349, 0x00);
			edx_ecx_408 = edx_ecx_307;
		}
		edx_117 = ecx_77;
		ecx_118 = eax_172;
l0805FFC3:
		g_t8145658 = ecx_118;
		Eq_4 dwLoc1C_353 = SLICE(rLoc20, word32, 32);
		Eq_4 dwLoc20_354 = (word32) rLoc20;
		if (ecx_118 == 0x00)
			g_t814565C.u0 = 0x00;
		if (((int8) (edx_117 > 0x00) & (int8) (eax_411 == 0x00) | (int8) (eax_411 > 0x00)) != 0x00)
		{
			runtime.int64tofloat64(ebx_24_8, gs, edx_117);
			word128 xmm0_421;
			runtime.float64toint64(gs, (real64) (uint128) g_r81578A0 * (real64) ((uint128) rLoc20), out xmm0_421);
			word32 ebx_422;
			word32 ebp_423;
			runtime/internal/atomic.Xaddint64(0x08157868, dwLoc20_354, dwLoc1C_353, out ebx_422, out ebp_423);
		}
		word32 edx_424;
		word32 ebx_425;
		runtime.unlock(gs, 135550548, out edx_424, out ebx_425);
	}
}

// 080600B0: void runtime.scanstack(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
// Called from:
//      runtime.scang
//      runtime.newstack
void runtime.scanstack(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08)
{
	while (fp - 0x84 <= *((word32) (gs->ptr0000)->tFFFFFFFC + 0x0C))
		runtime.morestackc();
	if (*((word32) dwArg04 + 112) != 0x00)
		return;
	runtime.readgstatus(dwArg04);
	Eq_4 esp_26 = <invalid>;
	if ((*((word32) esp_26 + 4) & 0x1000) == 0x00)
	{
		*esp_26 = *((word32) esp_26 + 264);
		runtime.readgstatus(*esp_26);
		Eq_4 esp_38 = <invalid>;
		Eq_4 eax_43 = *((word32) esp_38 + 264);
		*((word32) esp_38 + 52) = *((word32) eax_43 + 84);
		*((word32) esp_38 + 48) = *((word32) eax_43 + 80);
		*((word32) esp_38 + 44) = *((word32) esp_38 + 4);
		runtime.printlock(gs);
		esp_38->u0 = 135149313;
		((word32) esp_38 + 4)->u0 = 22;
		runtime.printstring(gs);
		*esp_38 = *((word32) esp_38 + 264);
		runtime.printpointer(gs);
		esp_38->u0 = 0x080E11ED;
		((word32) esp_38 + 4)->u0 = 0x07;
		runtime.printstring(gs);
		*esp_38 = *((word32) esp_38 + 48);
		*((word32) esp_38 + 4) = *((word32) esp_38 + 52);
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_4 stackArg4 = <invalid>;
		runtime.printint(ebx_24_8, gs, stackArg4);
		esp_38->u0 = 135146316;
		((word32) esp_38 + 4)->u0 = 0x13;
		runtime.printstring(gs);
		*esp_38 = *((word32) esp_38 + 44);
		((word32) esp_38 + 4)->u0 = 0x00;
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_4 stackArg4 = <invalid>;
		word32 esi_466;
		runtime.printhex(esi, gs, stackArg4, dwArg04, out esi_466);
		esp_38->u0 = 0x080E0D9C;
		((word32) esp_38 + 4)->u0 = 0x01;
		runtime.printstring(gs);
		runtime.printunlock(gs);
		esp_38->u0 = 135149357;
		((word32) esp_38 + 4)->u0 = 22;
		runtime.throw(gs);
	}
	*esp_26 = *((word32) esp_26 + 264);
	runtime.readgstatus(*esp_26);
	if ((dwLocFC & ~0x1000) <= 0x02)
	{
		if ((dwLocFC & ~0x1000) == 0x01)
		{
l0806012A:
			if (dwArg08 == (gs->ptr0000)->tFFFFFFFC)
				runtime.throw(gs);
			else
			{
				Eq_4 ecx_314 = *((word32) dwArg08 + 24);
				if (ecx_314 == 0x00 || *((word32) ecx_314 + 0x0088) == 0x00)
				{
					if (g_b8145628 == 0x00)
						runtime.shrinkstack(gs, dwArg08);
					fn0808FD60(0x00, fp - 200);
					runtime.gentraceback(gs, dwArg04, 0x00, dwArg08, 0x00, 0x00, 0x7FFFFFFF, fp - 0x0C, 0x00);
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					Eq_4 stackArg0 = <invalid>;
					runtime.tracebackdefers(gs, stackArg0, dwArg04, dwArg04);
					((word32) dwArg04 + 112)->u0 = 0x01;
					return;
				}
				else
					runtime.throw(gs);
			}
		}
		if ((dwLocFC & ~0x1000) == 0x02)
		{
			runtime.readgstatus(dwArg08);
			Eq_4 esp_140 = <invalid>;
			Eq_4 eax_145 = *((word32) esp_140 + 264);
			*((word32) esp_140 + 52) = *((word32) eax_145 + 84);
			*((word32) esp_140 + 48) = *((word32) eax_145 + 80);
			*((word32) esp_140 + 44) = *((word32) esp_140 + 4);
			runtime.printlock(gs);
			esp_140->u0 = 0x080E1DFB;
			((word32) esp_140 + 4)->u0 = 0x0C;
			runtime.printstring(gs);
			*esp_140 = *((word32) esp_140 + 264);
			runtime.printpointer(gs);
			esp_140->u0 = 0x080E11ED;
			((word32) esp_140 + 4)->u0 = 0x07;
			runtime.printstring(gs);
			*esp_140 = *((word32) esp_140 + 48);
			*((word32) esp_140 + 4) = *((word32) esp_140 + 52);
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_4 stackArg4 = <invalid>;
			runtime.printint(ebx_24_8, gs, stackArg4);
			esp_140->u0 = 135146316;
			((word32) esp_140 + 4)->u0 = 0x13;
			runtime.printstring(gs);
			*esp_140 = *((word32) esp_140 + 44);
			((word32) esp_140 + 4)->u0 = 0x00;
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_4 stackArg4 = <invalid>;
			runtime.printint(ebx_24_8, gs, stackArg4);
			esp_140->u0 = 0x080E0D9C;
			((word32) esp_140 + 4)->u0 = 0x01;
			runtime.printstring(gs);
			runtime.printunlock(gs);
			esp_140->u0 = 135156963;
			((word32) esp_140 + 4)->u0 = 0x20;
			runtime.throw(gs);
		}
	}
	else
	{
		if ((dwLocFC & ~0x1000) <= 0x04)
			goto l0806012A;
		if ((dwLocFC & ~0x1000) == 0x06)
			return;
	}
	runtime.readgstatus(dwArg08);
	Eq_4 esp_221 = <invalid>;
	Eq_4 eax_226 = *((word32) esp_221 + 264);
	*((word32) esp_221 + 52) = *((word32) eax_226 + 84);
	*((word32) esp_221 + 48) = *((word32) eax_226 + 80);
	*((word32) esp_221 + 44) = *((word32) esp_221 + 4);
	runtime.printlock(gs);
	esp_221->u0 = 0x080E1DFB;
	((word32) esp_221 + 4)->u0 = 0x0C;
	runtime.printstring(gs);
	*esp_221 = *((word32) esp_221 + 264);
	runtime.printpointer(gs);
	esp_221->u0 = 0x080E11ED;
	((word32) esp_221 + 4)->u0 = 0x07;
	runtime.printstring(gs);
	*esp_221 = *((word32) esp_221 + 48);
	*((word32) esp_221 + 4) = *((word32) esp_221 + 52);
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	Eq_4 stackArg4 = <invalid>;
	runtime.printint(ebx_24_8, gs, stackArg4);
	esp_221->u0 = 135146316;
	((word32) esp_221 + 4)->u0 = 0x13;
	runtime.printstring(gs);
	*esp_221 = *((word32) esp_221 + 44);
	((word32) esp_221 + 4)->u0 = 0x00;
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	Eq_4 stackArg4 = <invalid>;
	runtime.printint(ebx_24_8, gs, stackArg4);
	esp_221->u0 = 0x080E0D9C;
	((word32) esp_221 + 4)->u0 = 0x01;
	runtime.printstring(gs);
	runtime.printunlock(gs);
	esp_221->u0 = 0x080E281E;
	((word32) esp_221 + 4)->u0 = 0x11;
	runtime.throw(gs);
}

// 08060530: void runtime.scanframeworker(Register Eq_4 esi, Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_28557) dwArg04, Stack Eq_4 dwArg0C)
// Called from:
//      runtime.scanstack.func1
void runtime.scanframeworker(Eq_4 esi, struct Eq_2 * gs, struct Eq_28557 * dwArg04, Eq_4 dwArg0C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 ecx_18 = dwArg04->t0004;
	Eq_4 edx_19 = dwArg04->t0000;
	Eq_4 ebx_20 = dwArg04->t000C;
	if (ebx_20 == 0x00)
		return;
	if (ebx_20 != *edx_19)
		--ebx_20;
	runtime.pcdatavalue(gs, edx_19, 0x00);
	Eq_4 dwLoc38_760 = ebx_20;
	Eq_4 eax_52 = dwLoc30;
	if (dwLoc30 == ~0x00)
		eax_52.u0 = 0x00;
	Eq_4 edx_64 = dwArg04->dw001C - dwArg04->dw0014;
	if (edx_64 > 0x00)
	{
		word24 ebx_24_8_271 = SLICE(runtime.funcdata(gs, edx_19, 0x01), word24, 8);
		if (ebx_20 != 0x00)
		{
			Eq_4 ecx_88 = *ebx_20;
			if (ecx_88 > 0x00)
			{
				if (eax_52 < 0x00 || eax_52 >= ecx_88)
				{
					runtime.funcname(gs, edx_19, ecx_18);
					Eq_4 eax_243 = *ebx_20;
					runtime.printlock(gs);
					runtime.printstring(gs);
					runtime.printint(ebx_24_8_271, gs, SEQ(eax_52 >> 0x1F, eax_52));
					runtime.printstring(gs);
					runtime.printint(ebx_24_8_271, gs, SEQ(eax_243 >> 0x1F, eax_243));
					runtime.printstring(gs);
					runtime.printstring(gs);
					runtime.printstring(gs);
					runtime.printint(ebx_24_8_271, gs, (uint64) ebx_20);
					runtime.printstring(gs);
					runtime.printunlock(gs);
					runtime.throw(gs);
				}
				runtime.stackmapdata(gs, ebx_20, eax_52);
				word32 ebp_978;
				runtime.scanblock(gs, dwArg04->dw001C - 0x04, 0x04, ebx_20, dwArg0C, out ebp_978, out esi);
				dwLoc38_760 = dwArg0C;
				goto l080605B3;
			}
		}
		runtime.funcname(gs, edx_19, ecx_18);
		word32 edx_110 = dwArg04->dw001C;
		runtime.printlock(gs);
		runtime.printstring(gs);
		runtime.printstring(gs);
		runtime.printstring(gs);
		Eq_4 esi_166;
		runtime.printhex(esi, gs, edx_110 - edx_64, 0x00, out esi_166);
		runtime.printstring(gs);
		word32 esi_977;
		runtime.printhex(esi_166, gs, edx_64, 0x00, out esi_977);
		runtime.printstring(gs);
		runtime.printunlock(gs);
		runtime.throw(gs);
	}
	else
	{
l080605B3:
		if (dwArg04->t0024 <= 0x00)
			return;
		Eq_4 edx_719;
		ui32 eax_718;
		struct Eq_28632 * edx_409 = dwArg04->ptr0028;
		if (edx_409 == null)
		{
			word24 ebx_24_8_611 = SLICE(runtime.funcdata(gs, edx_19, 0x00), word24, 8);
			if (dwLoc38_760 != 0x00)
			{
				Eq_4 ecx_432 = *dwLoc38_760;
				if (ecx_432 > 0x00)
				{
					if (eax_52 < 0x00 || eax_52 >= ecx_432)
					{
						runtime.funcname(gs, edx_19, ecx_18);
						Eq_4 eax_583 = *dwLoc38_760;
						runtime.printlock(gs);
						runtime.printstring(gs);
						runtime.printint(ebx_24_8_611, gs, SEQ(eax_52 >> 0x1F, eax_52));
						runtime.printstring(gs);
						runtime.printint(ebx_24_8_611, gs, SEQ(eax_583 >> 0x1F, eax_583));
						runtime.printstring(gs);
						runtime.printstring(gs);
						runtime.printstring(gs);
						runtime.printint(ebx_24_8_611, gs, (uint64) ebx_20);
						runtime.printstring(gs);
						runtime.printunlock(gs);
						runtime.throw(gs);
					}
					runtime.stackmapdata(gs, dwLoc38_760, eax_52);
					eax_718 = 0x00;
					edx_719 = dwLoc38_760;
l080605C6:
					word32 esi_981;
					word32 ebp_980;
					runtime.scanblock(gs, dwArg04->t0020, eax_718 << 0x02, edx_719, dwArg0C, out ebp_980, out esi_981);
					return;
				}
			}
			runtime.funcname(gs, edx_19, ecx_18);
			Eq_4 ebx_454 = dwArg04->t0020;
			Eq_4 edx_456 = dwArg04->t0024;
			runtime.printlock(gs);
			runtime.printstring(gs);
			runtime.printstring(gs);
			runtime.printstring(gs);
			Eq_4 esi_506;
			runtime.printhex(esi, gs, ebx_454, 0x00, out esi_506);
			runtime.printstring(gs);
			word32 esi_979;
			runtime.printhex(esi_506, gs, edx_456, 0x00, out esi_979);
			runtime.printstring(gs);
			runtime.printunlock(gs);
			runtime.throw(gs);
		}
		else
		{
			eax_718 = edx_409->dw0000;
			edx_719 = edx_409->t0004;
			goto l080605C6;
		}
	}
}

// 08060AE0: Register up32 runtime.gcDrain(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack ui32 dwArg08, Register out Eq_24505 ebpOut, Register out ptr32 esiOut)
// Called from:
//      runtime.gcMark
//      runtime.gchelper
//      runtime.gcBgMarkWorker.func2
up32 runtime.gcDrain(struct Eq_2 * gs, Eq_4 dwArg04, ui32 dwArg08, union Eq_24505 & ebpOut, ptr32 & esiOut)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	struct Eq_28860 * esp_16 = fp - 0x40;
	if (g_b81576F4 == 0x00)
		runtime.throw(gs);
	Eq_4 ecx_118;
	Eq_4 eax_116;
	Eq_4 esi_102;
	Eq_4 edx_33 = *((word32) dwArg04 + 16);
	Eq_4 ebp_41 = *((word32) dwArg04 + 20);
	Eq_4 eax_39 = *((word32) *((word32) gs->ptr0000->tFFFFFFFC + 24) + 84);
	word32 ebp_45 = ebp_41 + (edx_33 <u 100000);
	Eq_4 edi_47 = g_t81455F0;
	if (edi_47 < g_t81455F4)
	{
		bool v63_633 = (dwArg08 & 0x01) == 0x00;
		while (true)
		{
			esi_102 = ebp_41;
			if (!v63_633 && *((word32) eax_39 + 0x006C) != 0x00)
				break;
			runtime/internal/atomic.Xadd(0x081455F0, 0x01);
			if (dwLoc38 - 0x01 >= g_t81455F4)
				break;
			runtime.markroot(gs, dwLoc38 - 0x01);
			byte bLoc40_702 = (byte) dwArg04;
			if ((dwArg08 & 0x08) == 0x00)
				v63_633 = (dwArg08 & 0x01) == 0x00;
			else
			{
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				Eq_4 stackArg0 = <invalid>;
				runtime.pollWork(gs, stackArg0);
				if (bLoc40_702 != 0x00)
				{
					eax_116 = ebp_41;
					ecx_118 = edx_33;
					goto l08060C08;
				}
				v63_633 = (dwArg08 & 0x01) == 0x00;
			}
		}
	}
	ui32 eax_105 = dwArg08;
	bool v68_638 = (dwArg08 & 0x01) == 0x00;
	up32 ecx_120 = (word32) edx_33 + 100000;
	int32 edx_128 = ebp_45;
	Eq_4 ebx_115 = ebp_41;
	Eq_4 ebp_117 = edx_33;
l08060CC7:
	if (!v68_638)
	{
		esi_102 = esp_16[0x0F];
		word32 edi_103 = (word32) *((word32) esi_102 + 0x006C);
		if ((byte) edi_103 != 0x00)
		{
			eax_116 = ebx_115;
			ecx_118 = ebp_117;
			goto l08060C08;
		}
	}
	bool v76_646;
	esp_16[7] = (struct Eq_28860) ecx_120;
	esp_16[0x0E] = (struct Eq_28860) ebx_115;
	esp_16[0x0D] = (struct Eq_28860) ebp_117;
	esp_16[8] = (struct Eq_28860) edx_128;
	word32 edi_130 = g_dw8145580;
	word32 esi_131 = g_dw8145584;
	Eq_4 ebx_153 = ebx_115;
	if (((int8) (esi_131 == 0x00) & (int8) (edi_130 == 0x00)) == 0x00)
		v76_646 = (eax_105 & 11) == 0x00;
	else
	{
		esp_16->dw0000 = (word32) esp_16[0x0011];
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_4 stackArg4 = <invalid>;
		runtime.(*gcWork).balance(gs, stackArg4);
		v76_646 = (esp_16[18] & 11) == 0x00;
		ebx_153 = esp_16[0x0E];
		ebp_117 = esp_16[0x0D];
	}
	word32 ecx_195;
	if (!v76_646)
	{
		esi_102 = esp_16[0x0011];
		struct Eq_29057 * edi_202 = *esi_102;
		if (edi_202 != null)
		{
			uint32 ecx_209 = edi_202->a000C[0];
			if (ecx_209 == 0x00)
				ecx_195 = 0x00;
			else
			{
				edi_202->a000C[0] = ecx_209 - 0x01;
				if (ecx_209 >= 0x01FD)
					runtime.panicindex(gs);
				ecx_195 = edi_202->a000C[ecx_209];
			}
		}
		else
			ecx_195 = 0x00;
		if (ecx_195 == 0x00)
		{
			esp_16->dw0000 = (word32) esi_102;
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_4 stackArg4 = <invalid>;
			runtime.(*gcWork).tryGet(gs, stackArg4);
			ecx_195 = (word32) esp_16[1];
			ebx_153 = esp_16[0x0E];
			ebp_117 = esp_16[0x0D];
			esi_102 = esp_16[0x0011];
		}
	}
	else
	{
		esp_16->dw0000 = (word32) esp_16[0x0011];
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_4 stackArg4 = <invalid>;
		runtime.(*gcWork).get(gs, stackArg4);
		ecx_195 = (word32) esp_16[1];
		ebx_153 = esp_16[0x0E];
		ebp_117 = esp_16[0x0D];
		esi_102 = esp_16[0x0011];
	}
	if (ecx_195 != 0x00)
	{
		Eq_4 esi_440;
		up32 ebx_436;
		ui32 ecx_441;
		esp_16->dw0000 = ecx_195;
		esp_16[1] = (struct Eq_28860) esi_102;
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_4 stackArg4 = <invalid>;
		word32 ebp_764;
		runtime.scanobject(gs, stackArg4, dwArg04, out ebp_764);
		struct Eq_29115 * eax_265 = esp_16[0x0011];
		int32 ecx_266 = eax_265->dw0014;
		up32 edx_267 = eax_265->dw0010;
		if (((int8) (ecx_266 == 0x00) & (int8) (edx_267 >= 2000) | (int8) (ecx_266 > 0x00)) == 0x00)
		{
			ecx_441 = (ui32) esp_16[18];
			v68_638 = (ecx_441 & 0x01) == 0x00;
			edx_128 = (int32) esp_16[8];
			ebx_436 = (up32) esp_16[7];
			ebp_117 = esp_16[0x0D];
			esi_440 = esp_16[0x0E];
			goto l08060CC1;
		}
		Eq_4 edx_336;
		Eq_4 ecx_335;
		esp_16[1] = (struct Eq_28860) edx_267;
		esp_16[2] = (struct Eq_28860) ecx_266;
		esp_16->dw0000 = 0x08157860;
		word32 ebp_766;
		word32 ebx_765;
		runtime/internal/atomic.Xaddint64(esp_16->dw0000, esp_16[1], esp_16[2], out ebx_765, out ebp_766);
		esp_16 = (struct Eq_28860 *) ((char *) esp_16 - 4);
		ui32 eax_314 = esp_16[18];
		if ((eax_314 & 0x04) == 0x00)
		{
			ecx_335 = esp_16[0x0D];
			edx_336 = esp_16[0x0E];
		}
		else
		{
			struct Eq_29282 * eax_318 = esp_16[0x0011];
			ui64 edx_ecx_629 = eax_318->qw0010 - SEQ(ecx_325, esp_16[0x0D]);
			esp_16->dw0000 = (word32) edx_ecx_629;
			ui32 ecx_325 = esp_16[0x0E];
			esp_16[1] = (struct Eq_28860) SLICE(edx_ecx_629, word32, 32);
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_4 stackArg4 = <invalid>;
			runtime.gcFlushBgCredit(ebx_24_8, ebp, gs, stackArg4, dwArg04);
			eax_314 = (ui32) esp_16[18];
			ecx_335.u0 = 0x00;
			edx_336.u0 = 0x00;
		}
		struct Eq_29433 * ebx_343 = esp_16[0x0011];
		ui32 ebp_348 = ebx_343->dw0014;
		ui64 edi_esi_632 = SEQ(edi_351, esp_16[7]) - SEQ(ebp_348, ebx_343->dw0010);
		ebx_343->dw0010 = 0x00;
		ebx_343->dw0014 = 0x00;
		up32 esi_346 = (word32) edi_esi_632;
		int32 edi_353 = SLICE(edi_esi_632, word32, 32);
		ui32 edi_351 = esp_16[8];
		if ((eax_314 & 0x08) == 0x00)
		{
			v68_638 = (eax_314 & 0x01) == 0x00;
			goto l08060E27;
		}
		if (((int8) (esi_346 <= 0x00) & (int8) (edi_353 == 0x00) | (int8) (edi_353 < 0x00)) == 0x00)
		{
			v68_638 = (eax_314 & 0x01) == 0x00;
			goto l08060E27;
		}
		esp_16[0x0C] = (struct Eq_28860) edi_353;
		esp_16[11] = (struct Eq_28860) ecx_335;
		esp_16[0x0A] = (struct Eq_28860) edx_336;
		esp_16[9] = (struct Eq_28860) esi_346;
		esp_16[7] = (struct Eq_28860) (esi_346 + 100000);
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_4 stackArg0 = <invalid>;
		runtime.pollWork(gs, stackArg0);
		esi_102 = esi_346 + 100000;
		word32 eax_414 = Mem403[esp_16 + 0x30:word32] + (Mem403[esp_16 + 0x24:word32] <u 100000);
		if (esp_16->dw0000 == 0x00)
		{
			v68_638 = (esp_16[18] & 0x01) == 0x00;
			ecx_335 = esp_16[11];
			edx_336 = esp_16[0x0A];
			esi_346 = (up32) esp_16[7];
			edi_353 = eax_414;
l08060E27:
			ebx_436 = esi_346;
			ebp_117 = ecx_335;
			esi_440 = edx_336;
			ecx_441 = (ui32) esp_16[18];
			edx_128 = edi_353;
l08060CC1:
			eax_105 = ecx_441;
			ecx_120 = ebx_436;
			ebx_115 = esi_440;
			goto l08060CC7;
		}
		eax_116 = esp_16[0x0A];
		ecx_118 = esp_16[11];
	}
	else
	{
		eax_116 = ebx_153;
		ecx_118 = ebp_117;
	}
l08060C08:
	struct Eq_29380 * edx_485 = esp_16[0x0011];
	Eq_24505 ebp_487 = edx_485->t0014;
	word24 ebx_24_8_498 = SLICE(esi_102, word24, 8);
	ptr32 ebx_529 = SEQ(ebx_24_8_498, (int8) (ebp_487 > 0x00));
	up32 ebx_486 = edx_485->dw0010;
	up32 ebx_531 = ebx_486;
	if (((int8) (ebx_486 > 0x00) & (int8) (ebp_487 == 0x00) | (int8) (ebp_487 > 0x00)) != 0x00)
	{
		esp_16[6] = (struct Eq_28860) eax_116;
		esp_16[5] = (struct Eq_28860) ecx_118;
		esp_16[1] = (struct Eq_28860) ebx_486;
		esp_16[2] = (struct Eq_28860) ebp_487;
		esp_16->dw0000 = 0x08157860;
		runtime/internal/atomic.Xaddint64(esp_16->dw0000, esp_16[1], esp_16[2], out ebx_531, out ebp_487);
		struct Eq_29228 * esp_560 = (char *) esp_16 - 4;
		if ((esp_560->dw0048 & 0x04) != 0x00)
		{
			struct Eq_29239 * eax_565 = esp_560->ptr0044;
			ui64 edx_ecx_626 = eax_565->t0010 - SEQ(ecx_572, esp_560->dw0014);
			esp_560->dw0000 = (word32) edx_ecx_626;
			ui32 ecx_572 = esp_560->dw0018;
			esp_560->dw0004 = SLICE(edx_ecx_626, word32, 32);
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_4 stackArg4 = <invalid>;
			runtime.gcFlushBgCredit(ebx_24_8, ebp, gs, stackArg4, dwArg04);
		}
		struct Eq_29239 * eax_584 = esp_560->ptr0044;
		eax_584->t0010.u1 = 0x00;
		eax_584->dw0014 = 0x00;
	}
	ebpOut = ebp_487;
	esiOut = ebx_529;
	return ebx_531;
}

// 08060FD0: Register uint32 runtime.gcDrainN(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_27716) dwArg00, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack int32 dwArg0C, Register out Eq_4 ebpOut)
// Called from:
//      runtime.gcAssistAlloc1
uint32 runtime.gcDrainN(struct Eq_2 * gs, struct Eq_27716 * dwArg00, Eq_4 dwArg04, Eq_4 dwArg08, int32 dwArg0C, union Eq_4 & ebpOut)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 0x0C))
		runtime.morestackc();
	if (g_b81576F4 == 0x00)
		runtime.throw(gs);
	else
	{
		Eq_4 ecx_114 = dwArg04;
		ui64 ebp_ebx_315 = 0x00 - *((word32) dwArg04 + 16);
		Eq_4 eax_308 = *((word32) *((word32) gs->ptr0000->tFFFFFFFC + 24) + 84);
		while (true)
		{
			uint32 ebx_257 = (word32) ebp_ebx_315;
			struct Eq_29518 * esp_230 = fp - 32;
			Eq_4 ebp_331 = SLICE(ebp_ebx_315, word32, 32);
			if (*((word32) eax_308 + 0x006C) != 0x00)
				break;
			ui64 esi_edx_321 = SEQ(esi_62, *((word32) ecx_114 + 16)) + ebp_ebx_315;
			Eq_4 edx_60 = (word32) esi_edx_321;
			int32 esi_64 = SLICE(esi_edx_321, word32, 32);
			Eq_4 esi_62 = *((word32) ecx_114 + 20);
			ebp_331 = dwArg08;
			if (((int8) (esi_64 == dwArg0C) & (int8) (edx_60 < dwArg08) | (int8) (esi_64 < dwArg0C)) == 0x00)
				break;
			word32 eax_87 = g_dw8145584;
			word32 edx_88 = g_dw8145580;
			if (((int8) (eax_87 == 0x00) & (int8) (edx_88 == 0x00)) != 0x00)
			{
				runtime.(*gcWork).balance(gs, ecx_114);
				ecx_114 = dwArg04;
			}
			Eq_4 eax_124;
			struct Eq_29570 * eax_120 = *ecx_114;
			if (eax_120 != null)
			{
				uint32 edx_127 = eax_120->a000C[0];
				if (edx_127 == 0x00)
					eax_124.u0 = 0x00;
				else
				{
					eax_120->a000C[0] = edx_127 - 0x01;
					if (edx_127 >= 0x01FD)
						runtime.panicindex(gs);
					eax_124 = eax_120->a000C[edx_127];
				}
			}
			else
				eax_124.u0 = 0x00;
			if (eax_124 == 0x00)
			{
				runtime.(*gcWork).tryGet(gs, ecx_114);
				eax_124 = dwLoc1C;
				ecx_114 = dwArg04;
			}
			uint32 ecx_234;
			Eq_4 eax_246;
			ebp_331 = dwArg08;
			if (eax_124 == 0x00)
			{
				if (g_t81455F0 >= g_t81455F4)
					break;
				ebx_257 = runtime/internal/atomic.Xadd(0x081455F0, 0x01);
				if (dwLoc18 - 0x01 >= g_t81455F4)
					break;
				dwLoc1C = dwLoc18 - 0x01;
				runtime.markroot(gs, dwLoc1C);
				eax_246 = ebp_331;
				ecx_234 = ebx_257;
			}
			else
			{
				Eq_4 edx_241;
				word32 ebp_172;
				runtime.scanobject(gs, eax_124, ecx_114, out ebp_172);
				Eq_4 ecx_183 = *((word32) dwArg04 + 20);
				Eq_4 edx_184 = *((word32) dwArg04 + 16);
				dwLoc1C = ecx_114;
				if (((int8) (edx_184 >= 2000) & (int8) (ecx_183 == 0x00) | (int8) (ecx_183 > 0x00)) == 0x00)
				{
					ecx_234 = ebx_257;
					edx_241 = ebp_331;
				}
				else
				{
					word32 ebp_449;
					word32 ebx_448;
					runtime/internal/atomic.Xaddint64(0x08157860, edx_184, ecx_183, out ebx_448, out ebp_449);
					ui64 edx_ecx_324 = (word32) dwArg00->t0010 + SEQ(ebx_257, dwLoc10);
					dwArg00->t0010.u1 = 0x00;
					dwArg00->dw0014 = 0x00;
					dwLoc1C = edx_184;
					dwLoc18 = ecx_183;
					esp_230 = fp - 0x24;
					ecx_234 = (word32) edx_ecx_324;
					edx_241 = SLICE(edx_ecx_324, word32, 32);
				}
				eax_246 = edx_241;
			}
			eax_308 = esp_230->t001C;
			ecx_114 = esp_230->t0024;
			ebp_ebx_315 = SEQ(eax_246, ecx_234);
		}
		ebpOut = ebp_331;
		return ebx_257;
	}
}

// 08061240: Register Eq_26604 runtime.scanblock(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_26604 dwArg08, Stack Eq_4 dwArg0C, Stack Eq_4 dwArg10, Register out Eq_26604 ebpOut, Register out Eq_4 esiOut)
// Called from:
//      runtime.markroot
//      runtime.markrootBlock
//      runtime.markrootSpans
//      runtime.scanframeworker
//      runtime.addfinalizer
Eq_26604 runtime.scanblock(struct Eq_2 * gs, Eq_4 dwArg04, Eq_26604 dwArg08, Eq_4 dwArg0C, Eq_4 dwArg10, union Eq_26604 & ebpOut, union Eq_4 & esiOut)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 eax_17 = g_t81493A8;
	Eq_4 ecx_19 = g_t81493AC;
	Eq_26604 edx_124 = 0x00;
	eax_108 = eax_17;
	ecx_109 = ecx_19;
	while (true)
	{
		Eq_4 ecx_109;
		Eq_4 eax_108;
		Eq_26604 ebx_111 = dwArg08;
		if (edx_124 >= dwArg08)
			break;
		ebp = edx_124;
		esi = dwArg0C;
		word32 edx_117 = CONVERT(Mem25[(edx_124 >>u 0x05) + dwArg0C:byte], byte, word32);
		if (edx_117 == 0x00)
			edx_124 = (word32) edx_124.u1 + 32;
		else
		{
			int32 edi_115 = 0x00;
			while (true)
			{
				esi = dwArg0C;
				if (edi_115 >= 0x08 || ebp >= ebx_111)
					break;
				if ((edx_117 & 0x01) != 0x00)
				{
					word32 esi_61 = Mem58[dwArg04 + ebp:word32];
					if (esi_61 != 0x00 && (eax_108 <= esi_61 && esi_61 < ecx_109))
					{
						runtime.heapBitsForObject(gs, esi_61, dwArg04);
						if (dwLoc28 != 0x00)
						{
							word32 ebp_255;
							runtime.greyobject(gs, dwLoc28, dwLoc24, dwLoc20, dwLoc1C, dwArg10, dwLoc18, out ebp_255);
							dwLoc28 = dwLoc24;
							dwLoc24 = dwLoc20;
							dwLoc20 = dwLoc1C;
							dwLoc1C = dwArg10;
						}
						eax_108 = eax_17;
						ecx_109 = ecx_19;
						ebx_111 = dwArg08;
					}
				}
				++edi_115;
				edx_117 >>= 0x01;
				ebp = (word32) ebp + 4;
			}
			edx_124 = ebp;
		}
	}
	ebpOut = ebp;
	esiOut = esi;
	return dwArg08;
}

// 08061370: Register (ptr32 byte) runtime.scanobject(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Register out Eq_4 ebpOut)
// Called from:
//      runtime.markrootSpans
//      runtime.gcDrain
//      runtime.gcDrainN
//      runtime.addfinalizer
byte * runtime.scanobject(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, union Eq_4 & ebpOut)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 eax_17 = g_t81493A8;
	uint32 ebx_21 = dwArg04 - eax_17;
	Eq_4 esi_23 = g_t81493A0;
	Eq_4 edx_18 = g_t81493AC;
	Eq_4 ebp_179 = dwArg04;
	byte * ebx_123 = esi_23 - (ebx_21 >> 0x04) - 0x01;
	Eq_4 esi_28 = g_t8149108;
	if (ebx_21 >> 0x0D >= g_t814910C)
		runtime.panicindex(gs);
	else
	{
		struct Eq_29807 * edx_305 = *((word32) esi_28 + (ebx_21 >> 0x0D) * 0x04);
		ptr32 esi_39 = edx_305->ptr0040;
		if (esi_39 == 0x00)
			runtime.throw(gs);
		else
		{
			ptr32 eax_101;
			if (esi_39 > 0x00020000)
			{
				if (dwArg04 == edx_305->t000C)
				{
					if ((edx_305->b003A & 0x01) != 0x00)
					{
						Eq_4 ecx_71 = (word32) *((word32) dwArg08 + 8) + esi_39;
						Eq_4 edx_73 = *((word32) dwArg08 + 0x0C);
						*((word32) dwArg08 + 8) = ecx_71;
						Mem77[dwArg08 + 0x0C:word32] = edx_73 + (ecx_71 <u 0x00);
						ebpOut = dwArg04;
						return ebx_123;
					}
					Eq_4 esi_309 = (word32) dwArg04 + 0x00020000;
					while (true)
					{
						ebx_123 = esi_23 - (ebx_21 >> 0x04) - 0x01;
						if (esi_309 >= (word32) edx_305->t000C + edx_305->ptr0040)
							break;
						byte bl_285;
						struct Eq_29877 * edi_259 = *dwArg08;
						if (edi_259 != null)
						{
							uint32 ebx_266 = edi_259->dw000C;
							if (ebx_266 == 0x01FC)
								bl_285 = 0x00;
							else
							{
								if (ebx_266 >= 0x01FC)
									runtime.panicindex(gs);
								edi_259->a0010[ebx_266].t0000 = esi_309;
								++edi_259->dw000C;
								bl_285 = 0x01;
							}
						}
						else
							bl_285 = 0x00;
						if (bl_285 == 0x00)
						{
							runtime.(*gcWork).put(gs, dwArg08, esi_309);
							ebp_179 = dwArg04;
						}
						esi_309 = (word32) esi_309 + 0x00020000;
					}
				}
				eax_101 = (word32) edx_305->t000C + edx_305->ptr0040 - ebp_179;
				if (eax_101 > 0x00020000)
					eax_101 = 0x00020000;
			}
			else
				eax_101 = esi_39;
			uint32 edx_109 = ebx_21 >> 0x02 & 0x03;
			ptr32 esi_110 = 0x00;
			eax_114 = eax_101;
			while (true)
			{
				ptr32 eax_114;
				if (esi_110 >= eax_114)
					break;
				if (esi_110 != 0x00)
				{
					if (edx_109 < 0x03)
						++edx_109;
					else
					{
						--ebx_123;
						edx_109 = 0x00;
					}
				}
				uint32 edi_139 = (word32) *ebx_123 >> (byte) edx_109;
				if (esi_110 != 0x04 && (edi_139 & 0x10) == 0x00)
					break;
				if ((edi_139 & 0x01) != 0x00)
				{
					Eq_4 edi_182 = *((word32) ebp_179 + esi_110);
					if (edi_182 != 0x00 && (eax_17 <= edi_182 && (edi_182 < edx_18 && edi_182 - ebp_179 >= eax_114)))
					{
						runtime.heapBitsForObject(gs, edi_182, ebp_179);
						if (dwLoc40 != 0x00)
						{
							word32 ebp_543;
							runtime.greyobject(gs, dwLoc40, dwLoc3C, dwLoc38, dwLoc34, dwArg08, dwLoc30, out ebp_543);
							dwLoc40 = dwLoc3C;
							dwLoc3C = dwLoc38;
							dwLoc38 = dwLoc34;
							dwLoc34 = dwArg08;
						}
						eax_114 = eax_101;
						ebp_179 = dwArg04;
					}
				}
				esi_110 += 0x04;
			}
			Eq_4 eax_154 = (word32) *((word32) dwArg08 + 8) + eax_114;
			Eq_4 edx_156 = *((word32) dwArg08 + 0x0C);
			*((word32) dwArg08 + 8) = eax_154;
			Mem160[dwArg08 + 0x0C:word32] = edx_156 + (eax_154 <u 0x00);
			Eq_4 eax_163 = (word32) *((word32) dwArg08 + 16) + esi_110;
			Eq_4 edx_165 = *((word32) dwArg08 + 20);
			*((word32) dwArg08 + 16) = eax_163;
			Mem169[dwArg08 + 0x14:word32] = edx_165 + (eax_163 <u 0x00);
			ebpOut = ebp_179;
			return ebx_123;
		}
	}
}

// 08061640: void runtime.shade(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      runtime.gcmarkwb_m
void runtime.shade(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.heapBitsForObject(gs, dwArg04, 0x00);
	if (dwLoc18 != 0x00)
	{
		Eq_4 edi_44 = *((word32) *((word32) gs->ptr0000->tFFFFFFFC + 24) + 92);
		Eq_4 ebp_59;
		ui24 ebx_24_8_84 = SLICE(runtime.greyobject(gs, dwLoc18, dwLoc14, dwLoc10, dwLoc0C, (word32) edi_44 + 0x0950, dwLoc08, out ebp_59), word24, 8);
		if (runtime.gcphase == 0x02 || g_t815756D != 0x00)
			runtime.(*gcWork).dispose(ebx_24_8_84, ebp_59, gs, dwLoc28, (word32) edi_44 + 0x0950);
	}
}

// 08061710: Register Eq_4 runtime.greyobject(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg10, Stack Eq_4 dwArg14, Stack Eq_4 dwArg18, Stack Eq_4 dwArg1C, Stack Eq_4 dwArg20, Register out Eq_4 ebpOut)
// Called from:
//      runtime.scanblock
//      runtime.scanobject
//      runtime.shade
//      runtime.gcMarkTinyAllocs
Eq_4 runtime.greyobject(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg10, Eq_4 dwArg14, Eq_4 dwArg18, Eq_4 dwArg1C, Eq_4 dwArg20, union Eq_4 & ebpOut)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if ((dwArg04 & 0x03) != 0x00)
		runtime.throw(gs);
	else
	{
		Eq_4 ebx_417;
		word24 ebx_24_8_654 = SLICE(dwArg18, word24, 8);
		ui8 al_56 = 0x01 << ((byte) dwArg20 & 0x07);
		Eq_4 ebp_388 = (word32) *((word32) dwArg18 + 44) + (dwArg20 >> 0x03);
		if (g_b8157583 != 0x00)
		{
			if ((*ebp_388 & al_56) == 0x00)
			{
				runtime.printlock(gs);
				runtime.printlock(gs);
				runtime.printstring(gs);
				word32 esi_706;
				runtime.printhex(esi, gs, dwArg04, 0x00, out esi_706);
				runtime.printstring(gs);
				runtime.printunlock(gs);
				runtime.printlock(gs);
				runtime.printstring(gs);
				word32 esi_707;
				runtime.printhex(esi, gs, dwArg08, 0x00, out esi_707);
				runtime.printstring(gs);
				word32 esi_708;
				runtime.printhex(esi, gs, dwArg0C, 0x00, out esi_708);
				runtime.printstring(gs);
				runtime.printunlock(gs);
				runtime.gcDumpObject(gs, dwArg08, dwArg0C);
				runtime.gcDumpObject(gs, dwArg04, ~0x00);
				*((word32) *((word32) gs->ptr0000->tFFFFFFFC + 24) + 461) = 0x02;
				runtime.throw(gs);
			}
			Eq_4 ebp_340;
			Eq_4 eax_300 = *((word32) dwArg18 + 64);
			if (eax_300 == 0x04)
			{
				word32 ebp_343 = (word32) *dwArg10;
				ui32 ebp_359 = SEQ(SLICE(ebp_343, word24, 8), (byte) ebp_343 >> (byte) dwArg14) & 0x00 - (dwArg14 < 0x08);
				ebp_340 = SEQ(SLICE(ebp_359, word24, 8), (int8) (((byte) ebp_359 & 0x01) != 0x00));
			}
			else
			{
				word32 esi_304 = (word32) *dwArg10;
				ebp_340 = SEQ(SLICE(ebp_388, word24, 8), (int8) (((byte) esi_304 >> (byte) dwArg14 + 0x01 & 0x00 - (byte) (dwArg14 < 0x07) & 0x10) != 0x00));
			}
			ebx_417 = dwArg18;
			ebp_388 = ebp_340;
			if ((byte) ebp_340 != 0x00)
			{
				ebpOut = ebp_340;
				return dwArg18;
			}
			int8 al_425;
			runtime.heapBits.setCheckmarked(gs, dwArg10, dwArg14, eax_300);
			if (*((word32) dwArg18 + 64) == 0x04)
			{
				word32 eax_427 = (word32) *dwArg10;
				al_425 = (int8) (((byte) eax_427 >> (byte) dwArg14 & 0x00 - (byte) (dwArg14 < 0x08) & 0x01) != 0x00);
			}
			else
			{
				word32 edx_409 = (word32) *dwArg10;
				ebx_417 = 0x00 - (dwArg14 < 0x07);
				al_425 = (int8) (((byte) edx_409 >> (byte) dwArg14 + 0x01 & (byte) ebx_417 & 0x10) != 0x00);
			}
			if (al_425 == 0x00)
				runtime.throw(gs);
		}
		else
		{
			if (g_dw815772C > 0x00 && (dwArg20 >= *((word32) dwArg18 + 24) && (al_56 & Mem34[Mem34[dwArg18 + 0x28:word32] + (dwArg20 >>u 0x03):byte]) == 0x00))
			{
				runtime.printlock(gs);
				runtime.printstring(gs);
				word32 esi_709;
				runtime.printhex(esi, gs, dwArg04, 0x00, out esi_709);
				runtime.printstring(gs);
				word32 esi_710;
				runtime.printhex(esi, gs, dwArg08, 0x00, out esi_710);
				runtime.printstring(gs);
				word32 esi_711;
				runtime.printhex(esi, gs, dwArg0C, 0x00, out esi_711);
				runtime.printstring(gs);
				runtime.printunlock(gs);
				runtime.gcDumpObject(gs, dwArg08, dwArg0C);
				runtime.gcDumpObject(gs, dwArg04, ~0x00);
				*((word32) *((word32) gs->ptr0000->tFFFFFFFC + 24) + 461) = 0x02;
				runtime.throw(gs);
			}
			if ((*ebp_388 & al_56) != 0x00)
			{
				ebpOut = ebp_388;
				return dwArg18;
			}
			runtime/internal/atomic.Or8(ebp_388, al_56);
			ebx_417 = SEQ(ebx_24_8_654, bl_163);
			if ((*((word32) dwArg18 + 58) & 0x01) != 0x00)
			{
				word32 edx_178 = Mem162[dwArg1C + 0x08:word32] + Mem162[dwArg18 + 0x40:word32];
				Eq_4 eax_180 = *((word32) dwArg1C + 0x0C);
				*((word32) dwArg1C + 8) = edx_178;
				Mem184[dwArg1C + 0x0C:word32] = eax_180 + (edx_178 <u 0x00);
				ebpOut = ebp_388;
				return ebx_417;
			}
		}
		byte cl_487;
		struct Eq_30280 * ecx_460 = *dwArg1C;
		if (ecx_460 != null)
		{
			uint32 edx_467 = ecx_460->dw000C;
			if (edx_467 == 0x01FC)
				cl_487 = 0x00;
			else
			{
				if (edx_467 >= 0x01FC)
					runtime.panicindex(gs);
				ecx_460->a0010[edx_467].t0000 = dwArg04;
				++ecx_460->dw000C;
				ebx_417 = dwArg04;
				cl_487 = 0x01;
			}
		}
		else
			cl_487 = 0x00;
		if (cl_487 == 0x00)
			runtime.(*gcWork).put(gs, dwArg1C, dwArg04);
		ebpOut = ebp_388;
		return ebx_417;
	}
}

// 08061B90: void runtime.gcDumpObject(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg0C, Stack Eq_4 dwArg10)
// Called from:
//      runtime.heapBitsForObject
//      runtime.greyobject
void runtime.gcDumpObject(struct Eq_2 * gs, Eq_4 dwArg0C, Eq_4 dwArg10)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 eax_17 = g_t81493A8;
	if (dwArg0C < eax_17 || dwArg0C >= g_t81493AC)
	{
		runtime.printlock(gs);
		runtime.printstring(gs);
		runtime.printstring(gs);
		word32 esi_721;
		runtime.printhex(esi, gs, dwArg0C, 0x00, out esi_721);
		runtime.printstring(gs);
		runtime.printunlock(gs);
		return;
	}
	Eq_4 ecx_69 = (dwArg0C >> 0x0D) - (eax_17 >> 0x0D);
	Eq_4 ebp_71 = g_t8149108;
	if (ecx_69 >= g_t814910C)
		runtime.panicindex(gs);
	struct Eq_30466 * eax_79 = *((word32) ebp_71 + ecx_69 * 0x04);
	runtime.printlock(gs);
	runtime.printstring(gs);
	runtime.printstring(gs);
	word32 esi_722;
	runtime.printhex(esi, gs, dwArg0C, 0x00, out esi_722);
	runtime.printstring(gs);
	word32 esi_723;
	runtime.printhex(esi, gs, dwArg0C >> 0x0D, 0x00, out esi_723);
	runtime.printunlock(gs);
	if (eax_79 == null)
	{
		runtime.printlock(gs);
		runtime.printstring(gs);
		runtime.printunlock(gs);
		return;
	}
	Eq_4 ecx_146 = (word32) eax_79->b003A;
	Eq_4 edx_148 = eax_79->t0050;
	Eq_4 ebx_150 = eax_79->t0040;
	Eq_4 ebp_152 = eax_79->t000C;
	runtime.printlock(gs);
	runtime.printstring(gs);
	word32 esi_724;
	runtime.printhex(esi, gs, ebp_152, 0x00, out esi_724);
	runtime.printstring(gs);
	word32 esi_725;
	runtime.printhex(esi, gs, edx_148, 0x00, out esi_725);
	runtime.printstring(gs);
	runtime.printint(SLICE(ebx_150, word24, 8), gs, ecx_146);
	runtime.printstring(gs);
	runtime.printint(SLICE(ebx_150, word24, 8), gs, ebx_150);
	runtime.printstring(gs);
	runtime.printunlock(gs);
	byte cl_227 = eax_79->b003C;
	if (Test(UGE,false))
	{
		Eq_4 edx_231 = (word32) cl_227;
		ebx_150 = g_t81426E4;
		if (edx_231 < ebx_150)
		{
			if (edx_231 >= ebx_150)
				runtime.panicindex(gs);
			runtime.printlock(gs);
			runtime.printstring(gs);
			runtime.printstring(gs);
			runtime.printunlock(gs);
l08061DCC:
			Eq_4 ecx_305 = eax_79->t0040;
			if (eax_79->b003C == 0x02 && ecx_305 == 0x00)
				ecx_305 = (word32) dwArg10 + 4;
			Eq_4 eax_356 = dwArg10;
			Eq_4 edx_322 = 0x00;
			byte bl_330 = 0x00;
			ecx_327 = ecx_305;
			while (true)
			{
				Eq_4 ecx_327;
				if (edx_322 >= ecx_327)
					break;
				if (edx_322 >= 0x0200 && (eax_356 - 0x40 >= edx_322 || edx_322 >= (word32) eax_356 + 64))
					bl_330 = 0x01;
				else
				{
					uint32 ebx_718 = (uint32) bl_330;
					if (bl_330 != 0x00)
					{
						runtime.printlock(gs);
						runtime.printstring(gs);
						runtime.printunlock(gs);
					}
					word32 ecx_392 = Mem388[edx_322 + dwArg0C:word32];
					runtime.printlock(gs);
					runtime.printstring(gs);
					runtime.printstring(gs);
					runtime.printstring(gs);
					runtime.printint(SLICE(ebx_718, word24, 8), gs, edx_322);
					runtime.printstring(gs);
					word32 esi_726;
					runtime.printhex(esi, gs, ecx_392, 0x00, out esi_726);
					runtime.printunlock(gs);
					if (edx_322 == dwArg10)
					{
						runtime.printlock(gs);
						runtime.printstring(gs);
						runtime.printunlock(gs);
					}
					runtime.printlock(gs);
					runtime.printstring(gs);
					runtime.printunlock(gs);
					eax_356 = dwArg10;
					ecx_327 = ecx_305;
					bl_330 = 0x00;
				}
				edx_322 = (word32) edx_322 + 4;
			}
			if (bl_330 != 0x00)
			{
				runtime.printlock(gs);
				runtime.printstring(gs);
				runtime.printunlock(gs);
			}
			return;
		}
	}
	runtime.printlock(gs);
	runtime.printstring(gs);
	runtime.printint(SLICE(ebx_150, word24, 8), gs, (word32) cl_227);
	runtime.printstring(gs);
	runtime.printunlock(gs);
	goto l08061DCC;
}

// 08062070: void runtime.gcmarknewobject(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg08, Stack uint32 dwArg0C)
// Called from:
//      runtime.mallocgc
void runtime.gcmarknewobject(struct Eq_2 * gs, Eq_4 dwArg08, uint32 dwArg0C)
{
	if (g_b8157583 == 0x00 || g_t815756D != 0x00)
	{
		runtime.markBitsForAddr(gs, dwArg04);
		runtime.markBits.setMarked(gs, dwLoc0C, bLoc08);
		Eq_4 ecx_48 = *((word32) *((word32) gs->ptr0000->tFFFFFFFC + 24) + 92);
		word32 eax_55 = Mem38[ecx_48 + 2392:word32] + dwArg08;
		word32 ebx_57 = *((word32) ecx_48 + 0x095C);
		*((word32) ecx_48 + 2392) = eax_55;
		*((word32) ecx_48 + 0x095C) = (bool) (eax_55 < 0x00) + ebx_57;
		up32 eax_64 = (word32) *((word32) ecx_48 + 2400) + dwArg0C;
		word32 ebx_66 = *((word32) ecx_48 + 2404);
		*((word32) ecx_48 + 2400) = eax_64;
		*((word32) ecx_48 + 2404) = (bool) (eax_64 < 0x00) + ebx_66;
		if (g_t815756D != 0x00)
		{
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_4 stackArg0 = <invalid>;
			runtime.(*gcWork).dispose(ebx_24_8, ebp, gs, stackArg0, (word32) ecx_48 + 0x0950);
		}
	}
	else
		runtime.throw(gs);
}

// 08062150: void runtime.gcMarkTinyAllocs(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.gcStart
void runtime.gcMarkTinyAllocs(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	int32 eax_17;
	word32 * ecx_20 = g_a81478C0;
	for (eax_17 = 0x00; eax_17 < 0x0401; ++eax_17)
	{
		Eq_4 edx_26 = *ecx_20;
		if (edx_26 == 0x00 || *((word32) edx_26 + 8) == 0x04)
			return;
		Eq_4 ebx_37 = *((word32) edx_26 + 52);
		if (ebx_37 != 0x00)
		{
			Eq_4 ebp_41 = *((word32) ebx_37 + 8);
			if (ebp_41 != 0x00)
			{
				runtime.heapBitsForObject(gs, ebp_41, 0x00);
				Eq_4 ebp_62 = *((word32) ebx_37 + 8);
				word32 ebp_173;
				runtime.greyobject(gs, ebp_62, dwLoc24, dwLoc20, dwLoc1C, (word32) edx_26 + 0x0950, dwLoc18, out ebp_173);
				dwLoc24 = dwLoc20;
				dwLoc20 = dwLoc1C;
				dwLoc1C = (word32) edx_26 + 0x0950;
				if (g_t815756D != 0x00)
				{
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					Eq_4 stackArg0 = <invalid>;
					runtime.(*gcWork).dispose(SLICE(dwLoc18, word24, 8), ebp_62, gs, stackArg0, (word32) edx_26 + 0x0950);
				}
			}
		}
		++ecx_20;
	}
}

// 08062260: void runtime.initCheckmarks(Register Eq_4 esi, Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.gcMarkTermination.func2
void runtime.initCheckmarks(Eq_4 esi, struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	g_b8157583 = 0x01;
	word32 * eax_109 = g_ptr81490FC;
	int32 ecx_19 = g_dw8149100;
	int32 edx_112 = 0x00;
	ecx_106 = ecx_19;
	while (true)
	{
		int32 ecx_106;
		if (edx_112 >= ecx_106)
			break;
		struct Eq_30843 * ebx_33 = *eax_109;
		if (ebx_33->b003C == 0x01)
		{
			uint32 eax_70;
			runtime.heapBitsForSpan(esi, gs, ebx_33->t000C);
			ui32 ebx_61 = ebx_33->dw0010;
			byte * edx_63 = ebx_33->ptr0040;
			if (edx_63 > null)
				eax_70 = (uint32) ((uint64) (ebx_61 << 0x0D) /u edx_63);
			else
				eax_70 = 0x00;
			dwLoc20 = dwLoc1C;
			dwLoc1C = edx_63;
			esi = runtime.heapBits.initCheckmarkSpan(gs, dwLoc20, dwLoc1C, edx_63, eax_70);
			ecx_106 = ecx_19;
		}
		++eax_109;
		++edx_112;
	}
}

// 08062320: void runtime.clearCheckmarks(Register Eq_4 esi, Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.gcMarkTermination.func2
void runtime.clearCheckmarks(Eq_4 esi, struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	g_b8157583 = 0x00;
	word32 * eax_104 = g_ptr81490FC;
	int32 ecx_19 = g_dw8149100;
	int32 edx_107 = 0x00;
	ecx_101 = ecx_19;
	while (true)
	{
		int32 ecx_101;
		if (edx_107 >= ecx_101)
			break;
		struct Eq_30910 * ebx_33 = *eax_104;
		if (ebx_33->b003C == 0x01)
		{
			runtime.heapBitsForSpan(esi, gs, ebx_33->t000C);
			Eq_4 edx_63 = ebx_33->t0040;
			runtime.heapBits.clearCheckmarkSpan(gs);
			esi = edx_63;
			ecx_101 = ecx_19;
		}
		++eax_104;
		++edx_107;
	}
}

// 080623E0: Register word32 runtime.finishsweep_m(Register (ptr32 Eq_2) gs, Register Eq_662 xmm2, Register out Eq_30940 xmm0Out, Register out Eq_662 xmm2Out)
// Called from:
//      runtime.gcStart.func1
//      runtime.gcMarkTermination.func2
word32 runtime.finishsweep_m(struct Eq_2 * gs, Eq_662 xmm2, union Eq_30940 & xmm0Out, union Eq_662 & xmm2Out)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	while (true)
	{
		Eq_30940 xmm0_27;
		Eq_4 esi_31 = runtime.sweepone(gs, xmm2, dwLoc08, out xmm0_27, out xmm2);
		if (dwLoc04 == ~0x00)
			break;
		++g_dw81451F0;
	}
	word32 esi_56 = runtime.nextMarkBitArenaEpoch(esi_31, gs);
	xmm0Out = xmm0_27;
	xmm2Out = xmm2;
	return esi_56;
}

// 08062430: void runtime.bgsweep(Register Eq_4 esi, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void runtime.bgsweep(Eq_4 esi, struct Eq_2 * gs, Eq_4 dwArg04)
{
	ptr32 fp;
	Eq_4 esi;
	struct Eq_2 * gs;
	<type-error> Mem0;
	Eq_4 dwArg04;
	while (true)
	{
		ecx_6 = gs->ptr0000;
		ecx_7 = ecx_6->tFFFFFFFC;
		if (fp > *((word32) ecx_7 + 8))
			break;
		runtime.morestack_noctxt();
	}
	eax_17 = g_t81576F0;
	ecx_18 = gs->ptr0000;
	ecx_19 = ecx_18->tFFFFFFFC;
	if (eax_17 == 0x00)
		g_t81451E4 = ecx_19;
	else
		runtime.writebarrierptr(135549412, ecx_19);
	ebp_46 = runtime.lock(esi, gs, 0x081451E0, out esi_48, out edi_218);
	g_b81451E8 = 0x01;
	esi_64 = runtime.chansend1(ebp_46, esi_48, gs, dwArg04, 0x080F181C);
	runtime.goparkunlock(gs);
	while (true)
	{
		esi_191 = (esi_64, esi_112, esi_155, esi_155);
		Mem100 = (Mem84, Mem107, Mem182, Mem165);
		runtime.gosweepone(gs);
		eax_104 = g_dw81451EC;
		g_dw81451EC = eax_104 + 0x01;
		esi_112 = runtime.Gosched(gs);
	}
}

// 08062580: Register Eq_4 runtime.sweepone(Register (ptr32 Eq_2) gs, Register Eq_662 xmm2, Stack (ptr32 Eq_24793) dwArg00, Register out Eq_5194 xmm0Out, Register out Eq_662 xmm2Out)
// Called from:
//      runtime.gcSweep
//      runtime.finishsweep_m
//      runtime.(*mheap).reclaim
//      runtime.gosweepone.func1
Eq_4 runtime.sweepone(struct Eq_2 * gs, Eq_662 xmm2, struct Eq_24793 * dwArg00, union Eq_5194 & xmm0Out, union Eq_662 & xmm2Out)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 eax_19 = gs->ptr0000->tFFFFFFFC;
	Eq_4 ecx_21 = *((word32) eax_19 + 24);
	Eq_5194 xmm0_125 = (uint128) g_r8149160;
	*((word32) ecx_21 + 0x0078) = (word32) *((word32) ecx_21 + 0x0078) + 1;
	runtime/internal/atomic.Load();
	Eq_4 dwLoc04_461 = eax_19;
	Eq_4 esp_123 = fp - 0x44;
	if (dwLoc40 != 0x00)
	{
		struct Eq_31105 * eax_37 = dwArg00->ptr0018;
		--eax_37->dw0078;
		xmm0Out = xmm0_125;
		xmm2Out = xmm2;
		return esi;
	}
	else
	{
		runtime/internal/atomic.Xadd(135565560, 0x01);
		Eq_4 dwLoc40_470 = 0x01;
		Eq_4 eax_54 = g_t81490F0;
		while (true)
		{
			uint32 eax_60 = 0x01 - (eax_54 >> 0x01 & 0x01);
			if (eax_60 >= 0x02)
				break;
			Eq_4 eax_142;
			word24 ebx_24_8_372 = SLICE(runtime.(*gcSweepBuf).pop(gs, eax_60 * 0x14 + 135565588), word24, 8);
			if (dwLoc40_470 == 0x00)
			{
				runtime/internal/atomic.Store(135565556, 0x01);
				eax_142.u0 = ~0x00;
				goto l080626B3;
			}
			Eq_4 cl_88 = *((word32) dwLoc40_470 + 60);
			if (cl_88 != 0x01)
			{
				Eq_4 eax_345 = *((word32) dwLoc40_470 + 48);
				if (eax_345 != eax_54)
				{
					runtime.printlock(gs);
					runtime.printstring(gs);
					runtime.printint(ebx_24_8_372, gs, (uint64) cl_88);
					runtime.printstring(gs);
					runtime.printint(ebx_24_8_372, gs, (uint64) eax_345);
					runtime.printstring(gs);
					runtime.printint(ebx_24_8_372, gs, (uint64) eax_54);
					runtime.printstring(gs);
					runtime.printunlock(gs);
					runtime.throw(gs);
				}
				goto l080625FE;
			}
			if (*((word32) dwLoc40_470 + 48) == eax_54 - 0x02)
			{
				runtime/internal/atomic.Cas((word32) dwLoc40_470 + 48, eax_54 - 0x02, eax_54 - 0x01);
				dwLoc04_461 = dwLoc40_470;
				dwLoc40_470 = eax_54 - 0x02;
				if (bLoc38 == 0x00)
					goto l08062660;
				esi = runtime.(*mspan).sweep(gs, 135565556, (byte) dwLoc40_470, out xmm0_125, out xmm2);
				esp_123.u0 = <invalid>;
				if (*((byte) esp_123.u0 + 8) != 0x00)
					eax_142 = *((byte) esp_123.u0 + 24);
				else
					eax_142.u0 = 0x00;
l080626B3:
				*((word32) esp_123 + 24) = eax_142;
				esp_123->u0 = 135565560;
				((word32) esp_123 + 4)->u0 = ~0x00;
				runtime/internal/atomic.Xadd(*esp_123, *((word32) esp_123 + 4));
				if (*((word32) esp_123 + 8) == 0x00)
				{
					esp_123->u0 = 135565556;
					runtime/internal/atomic.Load();
					struct Eq_31226 * esp_166 = (word32) esp_123 + 4;
					if (esp_166->t0004 != 0x00 && g_dw8157730 > 0x00)
					{
						Eq_4 eax_174 = g_t81597B0;
						esp_166->t0034 = eax_174;
						Eq_4 ecx_176 = g_t8149158;
						esp_166->t0030 = ecx_176;
						esp_166->dw002C = eax_174 - ecx_176;
						esp_166->t0028 = g_t81597B4;
						Eq_4 ebp_183 = g_t814915C;
						esp_166->t0024 = ebp_183;
						esi = g_t814914C;
						esp_166->t0020 = esi;
						esp_166->dw001C = g_dw8149148;
						runtime.printlock(gs);
						esp_166->dw0000 = 135156169;
						esp_166->t0004.u0 = 0x1F;
						runtime.printstring(gs);
						Eq_4 edx_208 = esp_166->t0028;
						esp_166->dw0000 = edx_208 << 0x0C | esp_166->t0034 >> 0x14;
						esp_166->t0004 = edx_208 >> 0x14;
						Eq_4 ebp_217 = runtime.printuint(ebp_183, gs, esp_166->dw0000, esp_166->t0004);
						esp_166->dw0000 = 0x080E208C;
						esp_166->t0004.u0 = 0x0E;
						runtime.printstring(gs);
						uint32 eax_243 = SLICE(SEQ(esp_166->t0028, esp_166->t0034) - SEQ(esp_166->t0024, esp_166->t0030), word32, 32);
						esp_166->dw0000 = eax_243 << 0x0C | esp_166->dw002C >> 0x14;
						esp_166->t0004 = eax_243 >> 0x14;
						Eq_4 ebp_254 = runtime.printuint(ebp_217, gs, esp_166->dw0000, esp_166->t0004);
						esp_166->dw0000 = 0x080E383B;
						esp_166->t0004.u0 = 0x17;
						runtime.printstring(gs);
						esp_166->dw0000 = esp_166->dw001C;
						esp_166->t0004 = esp_166->t0020;
						runtime.printuint(ebp_254, gs, esp_166->dw0000, esp_166->t0004);
						esp_166->dw0000 = 0x080E180F;
						esp_166->t0004.u0 = 0x0A;
						runtime.printstring(gs);
						esp_166->dw0000 = (word32) (real64) (uint128) esp_166->r0038;
						xmm0_125 = runtime.printfloat(gs, xmm2, esp_166->dw0000, out xmm2);
						esp_166->dw0000 = 135142463;
						esp_166->t0004.u0 = 0x0C;
						runtime.printstring(gs);
						runtime.printunlock(gs);
					}
				}
				Eq_4 eax_334 = *((word32) dwLoc04_461 + 24);
				--*((word32) eax_334 + 0x0078);
				xmm0Out = xmm0_125;
				xmm2Out = xmm2;
				return esi;
			}
l080625FE:
		}
		runtime.panicindex(gs);
	}
}

// 08062960: void runtime.gosweepone(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.gcStart
//      runtime.bgsweep
//      runtime.deductSweepCredit
void runtime.gosweepone(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	word32 ebp_42;
	word32 edi_43;
	runtime.systemstack(gs, fp - 0x08, out ebp_42, out edi_43);
}

// 080629B0: Register Eq_4 runtime.(*mspan).ensureSwept(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg00, Stack (ptr32 Eq_31495) dwArg04, Stack Eq_31496 bArg08)
// Called from:
//      runtime.addspecial
//      runtime.removespecial
Eq_4 runtime.(*mspan).ensureSwept(struct Eq_2 * gs, Eq_4 dwArg00, struct Eq_31495 * dwArg04, Eq_31496 bArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 eax_18 = gs->ptr0000->tFFFFFFFC;
	Eq_4 ecx_19 = *((word32) eax_18 + 24);
	if (*((word32) ecx_19 + 0x0078) != 0x00 || (*((word32) ecx_19 + 0x0068) != 0x00 || eax_18 == *ecx_19))
	{
		Eq_4 ecx_46 = g_t81490F0;
		runtime/internal/atomic.Load();
		byte bLoc08_133 = (byte) ecx_46;
		if (dwLoc10 == (char *) (&dwArg04->t000C) + 36)
			return esi;
		runtime/internal/atomic.Cas(dwArg00, (char *) &dwArg04->t000C + 0x0022, (char *) &dwArg04->t000C + 35);
		if (bLoc08_133 != 0x00)
		{
			word128 xmm2_231;
			word128 xmm0_230;
			return runtime.(*mspan).sweep(gs, (char *) &dwArg04->t000C + 36, (byte) dwArg08, out xmm0_230, out xmm2_231);
		}
		else
		{
			while (true)
			{
				runtime/internal/atomic.Load();
				if (dwArg00 == ecx_46)
					break;
				runtime.osyield();
			}
			return esi;
		}
	}
	else
		runtime.throw(gs);
}

// 08062AA0: Register Eq_4 runtime.(*mspan).sweep(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg00, Stack byte bArg04, Register out Eq_18727 xmm0Out, Register out Eq_18728 xmm2Out)
// Called from:
//      runtime.(*mcentral).cacheSpan
//      runtime.sweepone
//      runtime.(*mspan).ensureSwept
//      runtime.(*mheap).reclaimList
Eq_4 runtime.(*mspan).sweep(struct Eq_2 * gs, Eq_4 dwArg00, byte bArg04, union Eq_18727 & xmm0Out, union Eq_18728 & xmm2Out)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	fn0808FD8A(0x00, fp - 0x18);
	Eq_4 eax_24 = gs->ptr0000->tFFFFFFFC;
	Eq_4 ecx_25 = *((word32) eax_24 + 24);
	if (*((word32) ecx_25 + 0x0078) == 0x00 && (*((word32) ecx_25 + 0x0068) == 0x00 && eax_24 != *ecx_25))
		runtime.throw(gs);
	word32 ebx_51 = (word32) *((word32) dwArg00 + 60);
	Eq_4 ecx_47 = g_t81490F0;
	byte bl_52 = (byte) ebx_51;
	word24 ebx_24_8_90 = SLICE(ebx_51, word24, 8);
	if (bl_52 != 0x01 || ecx_47 - 0x01 != *((word32) dwArg00 + 48))
	{
		Eq_4 eax_63 = *((word32) dwArg00 + 48);
		runtime.printlock(gs);
		runtime.printstring(gs);
		runtime.printint(ebx_24_8_90, gs, (uint64) bl_52);
		runtime.printstring(gs);
		runtime.printint(ebx_24_8_90, gs, (uint64) eax_63);
		runtime.printstring(gs);
		runtime.printint(ebx_24_8_90, gs, (uint64) ecx_47);
		runtime.printstring(gs);
		runtime.printunlock(gs);
		runtime.throw(gs);
	}
	if (g_b814F4C8 != 0x00)
		runtime.traceGCSweepSpan(gs, *((word32) dwArg00 + 16) << 0x0D);
	Eq_4 eax_191 = *((word32) dwArg00 + 16);
	word32 ebp_1851;
	word32 ebx_1850;
	runtime/internal/atomic.Xadd64(0x08149148, eax_191, 0x00, out ebx_1850, out ebp_1851);
	Eq_4 dwLoc70_1211 = eax_191;
	Eq_4 edx_1138 = (word32) dwArg00 + 88;
	Eq_4 bl_214 = *((word32) dwArg00 + 58);
	Eq_4 ebp_216 = *((word32) dwArg00 + 64);
	Eq_4 eax_218 = *((word32) *((word32) eax_24 + 24) + 0x00B8);
	Eq_4 esi_1007 = *((word32) dwArg00 + 88);
	ebp_1065 = ebp_216;
	while (true)
	{
		Eq_4 ebp_1065;
		Eq_4 ecx_1143 = dwArg00;
		if (esi_1007 == 0x00)
			break;
		word32 edi_974 = (word32) *((word32) esi_1007 + 4);
		if (ebp_1065 == 0x00)
			runtime.panicdivide(gs);
		Eq_4 edx_1070;
		Eq_31726 eax_985 = (uint32) ((uint64) edi_974 /u ebp_1065);
		byte * edx_989 = (word32) *((word32) dwArg00 + 44) + (eax_985 >> 0x03);
		ui32 ebx_996 = 0x01 << ((byte) eax_985 & 0x07);
		ui32 edx_998 = (word32) *edx_989;
		int32 edi_991 = eax_985 *s ebp_1065;
		if (((byte) edx_998 & (byte) ebx_996) != 0x00)
			edx_1070 = *esi_1007;
		else
		{
			Eq_31755 edi_1004 = (word32) ebp_1065 + edi_991;
			Eq_4 ecx_1006 = esi_1007;
			while (true)
			{
				byte al_1047;
				if (esi_1007 == 0x00)
					break;
				if ((word32) *((word32) esi_1007 + 4) >= edi_1004)
				{
					al_1047 = 0x00;
					goto l08062C0F;
				}
				if (*((word32) esi_1007 + 6) == 0x01)
				{
					*edx_989 = (byte) (edx_998 | ebx_996);
					al_1047 = 0x01;
					goto l08062C0F;
				}
				esi_1007 = *esi_1007;
			}
			al_1047 = 0x00;
l08062C0F:
			Eq_4 edx_1052 = edx_1138;
			uint32 eax_1076 = (uint32) al_1047;
			edi_1059 = edi_1004;
			while (true)
			{
				Eq_31755 edi_1059;
				if (ecx_1006 == 0x00)
					break;
				Eq_31755 ebx_1058 = (word32) *((word32) ecx_1006 + 4);
				if (ebx_1058 >= edi_1059)
					break;
				Eq_4 edx_1120;
				Eq_4 esi_1074 = (word32) *((word32) ecx_1006 + 6);
				word32 ebx_1073 = ebx_1058 + Mem1057[dwArg00 + 0x0C:word32];
				byte al_1085 = (byte) eax_1076;
				if ((byte) esi_1074 != 0x01 && al_1085 != 0x00)
					edx_1120 = *ecx_1006;
				else
				{
					Eq_4 eax_1093 = *ecx_1006;
					*edx_1052 = eax_1093;
					runtime.freespecial(esi_1074, gs, ecx_1006, ebx_1073, ebp_216);
					dwLoc70_1211 = ebx_1073;
					eax_1076 = (word32) al_1047;
					edi_1059 = edi_1004;
					edx_1120 = eax_1093;
					ecx_1006 = edx_1052;
				}
				ecx_1006 = edx_1120;
				edx_1052 = ecx_1006;
			}
			ebp_1065 = ebp_216;
			esi_1007 = edx_1052;
			edx_1070 = ecx_1006;
		}
		esi_1007 = edx_1070;
		edx_1138 = esi_1007;
	}
	if (g_dw8157720 != 0x00)
	{
		Eq_4 dwLoc1C_1219 = *((word32) dwArg00 + 44);
		ui8 bLoc18_1220 = 0x01;
		Eq_4 dwLoc10_1222 = *((word32) dwArg00 + 40);
		ui8 bLoc0C_1223 = 0x01;
		Eq_4 dwLoc08_1224 = 0x00;
		Eq_4 edx_240 = 0x00;
		while (edx_240 < *((word32) ecx_1143 + 28))
		{
			if ((bLoc18_1220 & *dwLoc1C_1219) == 0x00 && (dwLoc08_1224 < *((word32) ecx_1143 + 24) || (bLoc0C_1223 & *dwLoc10_1222) != 0x00))
			{
				Eq_4 esi_874 = (word32) *((word32) ecx_1143 + 0x0C) + *((word32) ecx_1143 + 64) *s edx_240;
				if (g_dw8157720 != 0x00)
				{
					runtime.tracefree(esi_874, gs, ebp_1065);
					dwLoc70_1211 = ebp_1065;
					ecx_1143 = dwArg00;
					ebp_1065 = ebp_216;
				}
			}
			word32 esi_906 = (word32) bLoc18_1220;
			if ((byte) esi_906 == 0x80)
			{
				dwLoc1C_1219 = (word32) dwLoc1C_1219 + 1;
				bLoc18_1220 = 0x01;
			}
			else
				bLoc18_1220 = (byte) esi_906 << 0x01;
			word32 esi_938 = (word32) bLoc0C_1223;
			if ((byte) esi_938 == 0x80)
			{
				dwLoc10_1222 = (word32) dwLoc10_1222 + 1;
				bLoc0C_1223 = 0x01;
			}
			else
				bLoc0C_1223 = (byte) esi_938 << 0x01;
			dwLoc08_1224 = (word32) dwLoc08_1224 + 1;
			edx_240 = (word32) edx_240 + 1;
		}
	}
	word32 ebp_276;
	runtime.(*mspan).countAlloc(gs, ecx_1143);
	cup16 ax_279 = (word16) dwLoc70_1211;
	if (bl_214 >> 0x01 == 0x00)
	{
		if (ax_279 == 0x00)
		{
			*((word32) dwArg00 + 61) = 0x01;
			ebp_276 = 0x01;
		}
		else
			ebp_276 = 0x00;
	}
	else
		ebp_276 = 0x00;
	word32 esi_292 = (word32) *((word32) dwArg00 + 56);
	word24 ebx_24_8_326 = SLICE(dwArg00, word24, 8);
	cup16 di_299 = (word16) esi_292;
	cup16 si_296 = (word16) (esi_292 - dwLoc70_1211);
	if (ax_279 > di_299)
	{
		Eq_4 eax_304 = *((word32) dwArg00 + 28);
		runtime.printlock(gs);
		runtime.printstring(gs);
		runtime.printint(ebx_24_8_326, gs, (uint64) eax_304);
		runtime.printstring(gs);
		runtime.printint(ebx_24_8_326, gs, (uint64) (word16) dwLoc70_1211);
		runtime.printstring(gs);
		runtime.printint(ebx_24_8_326, gs, (uint64) di_299);
		runtime.printstring(gs);
		runtime.printint(ebx_24_8_326, gs, (uint64) si_296);
		runtime.printstring(gs);
		runtime.printunlock(gs);
		runtime.throw(gs);
	}
	*((word32) dwArg00 + 56) = (word16) dwLoc70_1211;
	Eq_4 esi_446 = runtime.(*mspan).nextFreeIndex(gs, dwArg00);
	Eq_4 edx_454 = *((word32) dwArg00 + 28);
	((word32) dwArg00 + 24)->u0 = 0x00;
	byte al_432 = (byte) ebp_276;
	if (g_b814F4C8 != 0x00)
	{
		Eq_4 ebp_465 = *((word32) *((word32) gs->ptr0000->tFFFFFFFC + 24) + 92);
		esi_446 = (word32) si_296;
		*((word32) ebp_465 + 0x0934) = (word32) *((word32) ebp_465 + 0x0934) + *((word32) dwArg00 + 64) *s (word32) ((word16) esi_446);
	}
	*((word32) dwArg00 + 40) = *((word32) dwArg00 + 44);
	runtime.newMarkBits(esi_446, gs, *((word32) dwArg00 + 28));
	*((word32) dwArg00 + 44) = dwLoc70_1211;
	Eq_4 esi_1625;
	word24 ebx_24_8_564 = SLICE(runtime.(*mspan).refillAllocCache(gs, dwArg00, 0x00, out esi_1625), word24, 8);
	if (al_432 == 0x00 && si_296 != 0x00)
	{
l08062EE4:
		uip32 eax_1845;
		if (si_296 > 0x00 && bl_214 >> 0x01 != 0x00)
		{
			Eq_32070 ecx_728 = (int32) (bl_214 >> 0x01);
			if (ecx_728 >= 0x43)
				runtime.panicindex(gs);
			*((word32) eax_218 + (ecx_728 * 0x04 + 600)) = (word32) *((word32) eax_218 + (ecx_728 * 0x04 + 600)) + (word32) si_296;
			uint32 eax_737 = (word32) bl_214;
			if (eax_737 >= 0x86)
				runtime.panicindex(gs);
			esi_1625 = runtime.(*mcentral).freeSpan(esi_1625, gs, (eax_737 << 0x06) + 135566272, dwArg00, bArg04, (int8) (dwLoc70_1211 == edx_454));
			eax_1845 = (word32) bLoc68;
		}
		else if (al_432 != 0x00)
		{
			if (g_dw8157728 > 0x00)
			{
				((word32) dwArg00 + 80)->u0 = 0x00;
				esi_1625 = runtime.sysFault(gs);
			}
			else
				runtime.(*mheap).freeSpan(gs);
			*((word32) eax_218 + 596) = (word32) *((word32) eax_218 + 596) + 1;
			Mem723[eax_218 + 0x0250:word32] = Mem718[eax_218 + 0x0250:word32] + ebp_216;
			eax_1845 = 0x01;
		}
		else
			eax_1845 = 0x00;
		if ((byte) eax_1845 == 0x00)
			esi_1625 = runtime.(*gcSweepBuf).push(esi_1625, gs, dwLoc78, (ecx_47 >> 0x01 & 0x01) * 0x14 + 135565588, dwArg00, out xmm0, out xmm2);
		xmm0Out = xmm0;
		xmm2Out = xmm2;
		return esi_1625;
	}
	else
	{
		Eq_4 dl_528 = *((word32) dwArg00 + 60);
		if (dl_528 == 0x01)
		{
			Eq_4 ebx_532 = *((word32) dwArg00 + 48);
			ebx_24_8_564 = SLICE(ebx_532, word24, 8);
			if (ecx_47 - 0x01 == ebx_532)
			{
				runtime/internal/atomic.Store((word32) dwArg00 + 48, ecx_47);
				goto l08062EE4;
			}
		}
		Eq_4 eax_538 = *((word32) dwArg00 + 48);
		runtime.printlock(gs);
		runtime.printstring(gs);
		runtime.printint(ebx_24_8_564, gs, (uint64) dl_528);
		runtime.printstring(gs);
		runtime.printint(ebx_24_8_564, gs, (uint64) eax_538);
		runtime.printstring(gs);
		runtime.printint(ebx_24_8_564, gs, (uint64) ecx_47);
		runtime.printstring(gs);
		runtime.printunlock(gs);
		runtime.throw(gs);
	}
}

// 08063340: Register Eq_4 runtime.deductSweepCredit(Register Eq_4 esi, Register (ptr32 Eq_2) gs, Register Eq_662 xmm1, Stack ui32 dwArg04, Stack uint32 dwArg08)
// Called from:
//      runtime.largeAlloc
//      runtime.(*mcentral).cacheSpan
Eq_4 runtime.deductSweepCredit(Eq_4 esi, struct Eq_2 * gs, Eq_662 xmm1, ui32 dwArg04, uint32 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	uint128 xmm0_17 = (uint128) g_r8149160;
	Eq_662 xmm1_22 = __xorps(xmm1, xmm1);
	if ((real64) xmm0_17 == (real64) xmm1_22 && !PARITY_EVEN((real64) xmm0_17 - (real64) xmm1_22))
		return esi;
	if (g_b814F4C8 != 0x00)
		runtime.traceGCSweepStart(gs);
	while (true)
	{
		word64 mm0_348;
		runtime/internal/atomic.Load64(135565648, out mm0_348);
		word64 mm0_349;
		runtime/internal/atomic.Load64(135632816, out mm0_349);
		real64 rLoc08_245 = (real64) (uint128) g_r8149160;
		runtime.uint32tofloat64();
		real64 v21_87 = (real64) (uint128) rLoc08_245 * (real64) ((uint128) SEQ(dwLoc20, dwLoc24_352));
		word128 xmm0_94;
		runtime.float64toint64(gs, v21_87, out xmm0_94);
		up32 eax_101 = dwLoc20 - dwArg08;
		dwLoc24 = SLICE(v21_87, word32, 32);
		int32 edx_106 = dwLoc1C - (eax_101 < 0x00);
		do
		{
			word64 mm0_350;
			runtime/internal/atomic.Load64(0x08149148, out mm0_350);
			ui64 edx_eax_237 = SEQ(dwLoc20, dwLoc24) - SEQ(dwLoc20, dwLoc24_352);
			up32 eax_121 = (word32) edx_eax_237;
			int32 edx_126 = SLICE(edx_eax_237, word32, 32);
			ui24 eax_24_8_144 = SLICE(eax_121, word24, 8);
			Eq_4 esi_151 = SEQ(SLICE(esi, word24, 8), (int8) (edx_106 == edx_126)) & SEQ(eax_24_8_144, (int8) (eax_101 > eax_121)) | SEQ(eax_24_8_144, (int8) (edx_106 > edx_126));
			esi = esi_151;
			if ((byte) esi_151 == 0x00)
			{
				if (g_b814F4C8 != 0x00)
					esi = runtime.traceGCSweepDone(gs);
				return esi;
			}
			runtime.gosweepone(gs);
			word64 mm0_351;
			runtime/internal/atomic.Load64(135565648, out mm0_351);
			dwLoc24_352 = dwLoc24;
		} while (((int8) (dwLoc20 != dwLoc20) | (int8) (dwLoc24 != dwLoc24_352)) == 0x00);
	}
}

// 080634E0: Register Eq_4 runtime.(*gcSweepBuf).push(Register Eq_4 esi, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg00, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Register out Eq_32114 xmm0Out, Register out Eq_32115 xmm2Out)
// Called from:
//      runtime.(*mspan).sweep
//      runtime.(*mheap).alloc_m
Eq_4 runtime.(*gcSweepBuf).push(Eq_4 esi, struct Eq_2 * gs, Eq_4 dwArg00, Eq_4 dwArg04, Eq_4 dwArg08, union Eq_32114 & xmm0Out, union Eq_32115 & xmm2Out)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime/internal/atomic.Xadd((word32) dwArg04 + 16, 0x01);
	runtime/internal/atomic.Loaduintptr();
	uint32 eax_42 = dwLoc24 - 0x01 >> 0x09;
	while (true)
	{
		Eq_4 eax_218;
		if (eax_42 < 0x01)
			break;
		word32 edi_406;
		runtime.lock(esi, gs, dwArg04, out esi, out edi_406);
		runtime/internal/atomic.Loaduintptr();
		if (eax_42 >= 0x01)
		{
			Eq_4 ebx_101 = *((word32) dwArg04 + 0x0C);
			if (ebx_101 == 0x01)
			{
				Eq_4 ebx_104 = ebx_101 << 0x01;
				if (ebx_101 << 0x01 == 0x00)
					ebx_104.u0 = 0x0100;
				runtime.persistentalloc(gs);
				Eq_4 edx_129 = *((word32) dwArg04 + 0x0C);
				if (edx_129 != 0x00)
				{
					word128 xmm1_413;
					word32 ebp_411;
					word32 edi_412;
					runtime.memmove(dwLoc20, *((word32) dwArg04 + 4), edx_129 << 0x02, out ebp_411, out esi, out edi_412, out xmm0, out xmm1_413, out xmm2);
					dwLoc0C = dwLoc20;
				}
				runtime/internal/atomic.StorepNoWB((word32) dwArg04 + 4, dwLoc20);
				*((word32) dwArg04 + 0x0C) = ebx_104;
			}
			runtime.persistentalloc(gs);
			runtime/internal/atomic.StorepNoWB((word32) *((word32) dwArg04 + 4) + eax_42 * 0x04, dwLoc20);
			runtime/internal/atomic.Storeuintptr((word32) dwArg04 + 8, 0x02);
			word32 edx_409;
			word32 ebx_410;
			runtime.unlock(gs, dwArg00, out edx_409, out ebx_410);
			eax_218 = dwLoc0C;
			goto l08063656;
		}
		word32 edx_407;
		word32 ebx_408;
		runtime.unlock(gs, dwArg04, out edx_407, out ebx_408);
	}
	runtime/internal/atomic.Loadp();
	runtime/internal/atomic.Loadp();
	eax_218.u0 = 0x01;
l08063656:
	*((byte) eax_218.u0 + (dwLoc24 - 0x01 & 0x01FF) * 0x04) = dwArg08;
	xmm0Out = xmm0;
	xmm2Out = xmm2;
	return esi;
}

// 080636D0: Register uint32 runtime.(*gcSweepBuf).pop(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_31142) dwArg04)
// Called from:
//      runtime.sweepone
uint32 runtime.(*gcSweepBuf).pop(struct Eq_2 * gs, struct Eq_31142 * dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	uint32 ebx_26 = runtime/internal/atomic.Xadd((char *) &dwArg04->ptr0004 + 0x0C, ~0x00);
	if (dwLoc08 < 0x00)
		return runtime/internal/atomic.Xadd((char *) &dwArg04->ptr0004 + 0x0C, 0x01);
	*((word32) (&dwArg04->ptr0004[dwLoc08 >> 0x09])[0] + (dwLoc08 & 0x01FF) * 0x04) = 0x00;
	return ebx_26;
}

// 08063760: void runtime.(*gcSweepBuf).numBlocks(Register (ptr32 Eq_2) gs, Stack ui32 dwArg04)
// Called from:
//      runtime.gcMarkRootPrepare
void runtime.(*gcSweepBuf).numBlocks(struct Eq_2 * gs, ui32 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime/internal/atomic.Load();
}

// 080637B0: void runtime.(*gcSweepBuf).block(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg00, Stack ui32 dwArg04, Stack Eq_26932 dwArg08, Stack (ptr32 word32) dwArg0C)
// Called from:
//      runtime.markrootSpans
void runtime.(*gcSweepBuf).block(struct Eq_2 * gs, Eq_4 dwArg00, ui32 dwArg04, Eq_26932 dwArg08, word32 * dwArg0C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (dwArg08 >= 0x00)
	{
		runtime/internal/atomic.Loaduintptr();
		if (dwArg08 < dwLoc08)
		{
			Eq_32520 ecx_67;
			runtime/internal/atomic.Loadp();
			runtime/internal/atomic.Loadp();
			runtime/internal/atomic.Load();
			if (dwArg0C < dwLoc08 >> 0x09)
				ecx_67.u0 = 0x0200;
			else
				ecx_67 = dwLoc08 & 0x01FF;
			while (ecx_67 > 0x00)
			{
				Eq_32520 edx_78 = ecx_67 - 0x01;
				if (edx_78 >= ecx_67)
					runtime.panicindex(gs);
				if ((dwArg00 - 0x04)[ecx_67] != 0x00)
					return;
				ecx_67 = edx_78;
			}
			return;
		}
	}
	runtime.throw(gs);
}

// 080638B0: void runtime.init.0(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.init
void runtime.init.0(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
}

// 080638D0: void runtime.(*gcWork).init(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      runtime.(*gcWork).put
//      runtime.(*gcWork).tryGet
//      runtime.(*gcWork).get
void runtime.(*gcWork).init(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.getempty(gs);
	*dwArg04 = dwLoc04;
	runtime.trygetfull(gs);
	if (dwLoc04 == 0x00)
		runtime.getempty(gs);
	*((word32) dwArg04 + 4) = dwLoc04;
}

// 08063920: void runtime.(*gcWork).put(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
// Called from:
//      runtime.scanobject
//      runtime.greyobject
void runtime.(*gcWork).put(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	uip32 edx_123;
	Eq_4 ecx_18 = *dwArg04;
	if (ecx_18 != 0x00)
	{
		if (*((word32) ecx_18 + 0x0C) == 0x01FC)
		{
			*dwArg04 = *((word32) dwArg04 + 4);
			*((word32) dwArg04 + 4) = ecx_18;
			ecx_18 = *dwArg04;
			Eq_4 edx_42 = *((word32) ecx_18 + 0x0C);
			int8 dl_45 = (int8) (edx_42 == 0x01FC);
			edx_123 = SEQ(SLICE(edx_42, word24, 8), dl_45);
			if (edx_42 == 0x01FC)
			{
				runtime.putfull(gs);
				runtime.getempty(gs);
				*dwArg04 = ecx_18;
				edx_123 = (word32) dl_45;
			}
		}
		else
			edx_123 = 0x00;
	}
	else
	{
		runtime.(*gcWork).init(gs, dwArg04);
		ecx_18 = *dwArg04;
		edx_123 = 0x00;
	}
	byte dl_76 = (byte) edx_123;
	Eq_4 eax_62 = *((word32) ecx_18 + 0x0C);
	if (eax_62 >= 0x01FC)
		runtime.panicindex(gs);
	else
	{
		*((word32) ecx_18 + (eax_62 * 0x04 + 16)) = dwArg08;
		*((word32) ecx_18 + 0x0C) = (word32) *((word32) ecx_18 + 0x0C) + 1;
		if (dl_76 != 0x00 && runtime.gcphase == 0x01)
			runtime.(*gcControllerState).enlistWorker(ebx_24_8, gs, &g_dw8157860);
	}
}

// 080639F0: void runtime.(*gcWork).tryGet(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      runtime.gcDrain
//      runtime.gcDrainN
void runtime.(*gcWork).tryGet(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 ecx_18 = *dwArg04;
	if (ecx_18 == 0x00)
	{
		runtime.(*gcWork).init(gs, dwArg04);
		dwLoc0C = dwArg04;
		ecx_18 = *dwArg04;
	}
	if (*((word32) ecx_18 + 0x0C) == 0x00)
	{
		Eq_4 edx_37 = *dwArg04;
		*dwArg04 = *((word32) dwArg04 + 4);
		*((word32) dwArg04 + 4) = edx_37;
		ecx_18 = *dwArg04;
		if (*((word32) ecx_18 + 0x0C) == 0x00)
		{
			runtime.trygetfull(gs);
			if (dwLoc0C == 0x00)
				return;
			runtime.putempty(gs);
			*dwArg04 = dwLoc0C;
			ecx_18 = dwLoc0C;
		}
	}
	Eq_4 eax_71 = *((word32) ecx_18 + 0x0C);
	*((word32) ecx_18 + 0x0C) = eax_71 - 0x01;
	if (eax_71 < 0x01FD)
		return;
	runtime.panicindex(gs);
}

// 08063AB0: void runtime.(*gcWork).get(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      runtime.gcDrain
void runtime.(*gcWork).get(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 ecx_18 = *dwArg04;
	if (ecx_18 == 0x00)
	{
		runtime.(*gcWork).init(gs, dwArg04);
		dwLoc0C = dwArg04;
		ecx_18 = *dwArg04;
	}
	if (*((word32) ecx_18 + 0x0C) == 0x00)
	{
		Eq_4 edx_37 = *dwArg04;
		*dwArg04 = *((word32) dwArg04 + 4);
		*((word32) dwArg04 + 4) = edx_37;
		ecx_18 = *dwArg04;
		if (*((word32) ecx_18 + 0x0C) == 0x00)
		{
			runtime.getfull(gs);
			if (dwLoc0C == 0x00)
				return;
			runtime.putempty(gs);
			*dwArg04 = dwLoc0C;
			ecx_18 = dwLoc0C;
		}
	}
	Eq_4 eax_71 = *((word32) ecx_18 + 0x0C);
	*((word32) ecx_18 + 0x0C) = eax_71 - 0x01;
	if (eax_71 < 0x01FD)
		return;
	runtime.panicindex(gs);
}

// 08063B70: void runtime.(*gcWork).dispose(Register ui24 ebx_24_8, Register Eq_4 ebp, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg00, Stack Eq_4 dwArg04)
// Called from:
//      runtime.gcBgMarkWorker
//      runtime.gcMark
//      runtime.gchelper
//      runtime.gcAssistAlloc1
//      runtime.shade
//      runtime.gcmarknewobject
//      runtime.gcMarkTinyAllocs
//      runtime.addfinalizer
//      runtime.newstack
//      runtime.gcMarkDone.func1.1
void runtime.(*gcWork).dispose(ui24 ebx_24_8, Eq_4 ebp, struct Eq_2 * gs, Eq_4 dwArg00, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	struct Eq_32853 * ecx_18 = *dwArg04;
	if (ecx_18 != null)
	{
		if (ecx_18->dw000C == 0x00)
			runtime.putempty(gs);
		else
			runtime.putfull(gs);
		*dwArg04 = null;
		if (*((word32) *((word32) dwArg04 + 4) + 0x0C) == 0x00)
			runtime.putempty(gs);
		else
			runtime.putfull(gs);
		((word32) dwArg04 + 4)->u0 = 0x00;
	}
	Eq_4 edx_63 = *((word32) dwArg04 + 0x0C);
	Eq_4 ecx_62 = *((word32) dwArg04 + 8);
	ui32 ebp_89 = SEQ(SLICE(ebp, word24, 8), (int8) (ecx_62 != 0x00)) | SEQ(ebx_24_8, (int8) (edx_63 != 0x00));
	if ((byte) ebp_89 != 0x00)
	{
		word32 ebp_106;
		word32 ebx_107;
		runtime/internal/atomic.Xadd64(135550440, ecx_62, edx_63, out ebx_107, out ebp_106);
		((word32) dwArg04 + 8)->u0 = 0x00;
		((word32) dwArg04 + 0x0C)->u0 = 0x00;
	}
	Eq_4 ecx_119 = *((word32) dwArg04 + 20);
	Eq_4 edx_120 = *((word32) dwArg04 + 16);
	if (((int8) (edx_120 != 0x00) | (int8) (ecx_119 != 0x00)) != 0x00)
	{
		word32 ebp_210;
		word32 ebx_209;
		runtime/internal/atomic.Xaddint64(0x08157860, edx_120, ecx_119, out ebx_209, out ebp_210);
		((word32) dwArg00 + 16)->u0 = 0x00;
		((word32) dwArg00 + 20)->u0 = 0x00;
	}
}

// 08063C90: void runtime.(*gcWork).balance(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      runtime.gcDrain
//      runtime.gcDrainN
void runtime.(*gcWork).balance(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	struct Eq_32969 * ecx_18 = *dwArg04;
	if (ecx_18 == null)
		return;
	Eq_4 edx_24 = *((word32) dwArg04 + 4);
	Eq_4 ebx_25 = *((word32) edx_24 + 0x0C);
	if (ebx_25 == 0x00)
	{
		if (ecx_18->t000C <= 0x04)
			return;
		runtime.handoff(gs, ecx_18);
		*dwArg04 = dwLoc04;
	}
	else
	{
		runtime.putfull(gs);
		runtime.getempty(gs);
		*((word32) dwArg04 + 4) = edx_24;
	}
	if (runtime.gcphase == 0x01)
		runtime.(*gcControllerState).enlistWorker(SLICE(ebx_25, word24, 8), gs, &g_dw8157860);
}

// 08063D20: void runtime.(*workbuf).checknonempty(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_12439) dwArg04)
// Called from:
//      runtime.putfull
//      runtime.trygetfull
//      runtime.getfull
void runtime.(*workbuf).checknonempty(struct Eq_2 * gs, struct Eq_12439 * dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (dwArg04->dw000C != 0x00)
		return;
	runtime.throw(gs);
}

// 08063D70: void runtime.(*workbuf).checkempty(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_12439) dwArg04)
// Called from:
//      runtime.getempty
//      runtime.putempty
void runtime.(*workbuf).checkempty(struct Eq_2 * gs, struct Eq_12439 * dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (dwArg04->dw000C == 0x00)
		return;
	runtime.throw(gs);
}

// 08063DC0: void runtime.getempty(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.(*gcWork).init
//      runtime.(*gcWork).put
//      runtime.(*gcWork).balance
//      runtime.handoff
void runtime.getempty(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	struct Eq_12439 * eax_40;
	word32 eax_17 = g_dw8145588;
	word32 ecx_18 = g_dw814558C;
	if (((int8) (ecx_18 != 0x00) | (int8) (eax_17 != 0x00)) == 0x00)
		eax_40 = null;
	else
	{
		runtime.(*lfstack).pop(SLICE(edx_38, word24, 8), gs, 0x08145588);
		eax_40 = dwLoc20;
		if (dwLoc20 != null)
		{
			runtime.(*workbuf).checkempty(gs, dwLoc20);
			eax_40 = dwLoc20;
		}
	}
	if (eax_40 != null)
		return;
	Eq_4 dwLoc18_205 = 0x00;
	if (g_t81455D4 != 0x00)
	{
		word32 edi_275;
		word32 esi_274;
		runtime.lock(esi, gs, 0x081455D0, out esi_274, out edi_275);
		Eq_4 eax_72 = g_t81455D4;
		dwLoc18_205 = eax_72;
		if (eax_72 != 0x00)
		{
			runtime.(*mSpanList).remove(gs, 135550420, eax_72);
			runtime.(*mSpanList).insert(gs, 135550428, eax_72);
		}
		word32 edx_282;
		word32 ebx_283;
		runtime.unlock(gs, 0x081455D0, out edx_282, out ebx_283);
	}
	if (dwLoc18_205 == 0x00)
	{
		word32 ebp_276;
		word32 edi_277;
		runtime.systemstack(gs, fp - 0x08, out ebp_276, out edi_277);
		if (dwLoc18_205 == 0x00)
			runtime.throw(gs);
		word32 esi_278;
		word32 edi_279;
		runtime.lock(esi, gs, 0x081455D0, out esi_278, out edi_279);
		runtime.(*mSpanList).insert(gs, 135550428, dwLoc18_205);
		word32 ebx_281;
		word32 edx_280;
		runtime.unlock(gs, 0x081455D0, out edx_280, out ebx_281);
	}
	Eq_33125 ecx_151 = 0x00;
	while (true)
	{
		Eq_33125 edx_155 = (word32) ecx_151 + 0x0800;
		if (edx_155 > 0x8000)
			break;
		Mem171[Mem165[dwLoc18_205 + 0x0C:word32] + ecx_151 + 0x0C:word32] = 0x00;
		if (ecx_151 != 0x00)
			runtime.putempty(gs);
		ecx_151 = edx_155;
	}
}

// 08063F90: void runtime.putempty(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.(*gcWork).tryGet
//      runtime.(*gcWork).get
//      runtime.(*gcWork).dispose
//      runtime.getempty
void runtime.putempty(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.(*workbuf).checkempty(gs, dwArg04);
	runtime.(*lfstack).push(gs, 0x08145588, dwArg04);
}

// 08063FE0: void runtime.putfull(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.(*gcWork).put
//      runtime.(*gcWork).dispose
//      runtime.(*gcWork).balance
//      runtime.handoff
void runtime.putfull(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.(*workbuf).checknonempty(gs, dwArg04);
	runtime.(*lfstack).push(gs, 135550336, dwArg04);
}

// 08064030: void runtime.trygetfull(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.(*gcWork).init
//      runtime.(*gcWork).tryGet
void runtime.trygetfull(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.(*lfstack).pop(edx_24_8, gs, 135550336);
	if (dwLoc08 == null)
		return;
	runtime.(*workbuf).checknonempty(gs, dwLoc08);
}

// 08064090: void runtime.getfull(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.(*gcWork).get
void runtime.getfull(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.(*lfstack).pop(edx_24_8, gs, 135550336);
	if (dwLoc20 == null)
	{
		uint32 ebx_32 = runtime/internal/atomic.Xadd(0x08145604, 0x01);
		Eq_4 ecx_39 = g_t81455F8;
		if (dwLoc1C > ecx_39)
		{
			runtime.printlock(gs);
			runtime.printstring(gs);
			runtime.printsp(gs);
			runtime.printint(SLICE(ebx_32, word24, 8), gs, dwLoc1C);
			runtime.printsp(gs);
			runtime.printstring(gs);
			runtime.printsp(gs);
			runtime.printint(SLICE(ebx_32, word24, 8), gs, ecx_39);
			runtime.printnl(gs);
			runtime.printunlock(gs);
			runtime.throw(gs);
		}
		else
		{
			int32 eax_103 = 0x00;
			while (true)
			{
				word32 ecx_109 = g_dw8145584;
				word32 edx_110 = g_dw8145580;
				if (((int8) (ecx_109 != 0x00) | (int8) (edx_110 != 0x00)) != 0x00)
					break;
				Mem298 = Mem108;
				if (g_t81455F8 == g_t8145604 && g_t81455F0 >= g_t81455F4)
					return;
				if (eax_103 >= 0x0A)
				{
					if (eax_103 < 0x14)
						runtime.osyield();
					else
					{
						word32 edi_476;
						runtime.usleep(out edi_476);
					}
				}
				else
					runtime.procyield(0x14);
				++eax_103;
			}
			uint32 ebx_130 = runtime/internal/atomic.Xadd(0x08145604, ~0x00);
			Eq_4 ecx_137 = g_t81455F8;
			if (dwLoc1C == ecx_137)
			{
				runtime.printlock(gs);
				runtime.printstring(gs);
				runtime.printsp(gs);
				runtime.printint(SLICE(ebx_130, word24, 8), gs, dwLoc1C);
				runtime.printsp(gs);
				runtime.printstring(gs);
				runtime.printsp(gs);
				runtime.printint(SLICE(ebx_130, word24, 8), gs, ecx_137);
				runtime.printnl(gs);
				runtime.printunlock(gs);
				runtime.throw(gs);
			}
			else
			{
				runtime.(*lfstack).pop(edx_24_8, gs, 135550336);
				runtime.(*workbuf).checknonempty(gs, (struct Eq_12439 *) ~0x00);
			}
		}
	}
	else
		runtime.(*workbuf).checknonempty(gs, dwLoc20);
}

// 080643D0: void runtime.handoff(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_32969) dwArg04)
// Called from:
//      runtime.(*gcWork).balance
void runtime.handoff(struct Eq_2 * gs, struct Eq_32969 * dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.getempty(gs);
	Eq_32994 edx_24 = dwArg04->t000C;
	Eq_33398 edx_28 = (word32) edx_24.u0 + ((edx_24 >> 0x1F) >> 0x1F);
	dwArg04->t000C = edx_24 - (edx_28 >> 0x01);
	dwLoc10->dw000C = edx_28 >> 0x01;
	Eq_32994 ebx_33 = dwArg04->t000C;
	if (ebx_33 >= 0x01FC)
		runtime.panicindex(gs);
	else
	{
		word32 ebp_98;
		word32 esi_99;
		word32 edi_100;
		word128 xmm0_101;
		word128 xmm1_102;
		word128 xmm2_103;
		runtime.memmove(&dwLoc10->dw000C + 1, (char *) &dwArg04->t000C + 4 + ebx_33 * 0x04, edx_28 >> 0x01 << 0x02, out ebp_98, out esi_99, out edi_100, out xmm0_101, out xmm1_102, out xmm2_103);
		runtime.putfull(gs);
	}
}

// 08064460: void runtime.prepareFreeWorkbufs(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.gcMarkTermination
//      runtime.gcSweep
void runtime.prepareFreeWorkbufs(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	word32 esi_74;
	word32 edi_75;
	runtime.lock(esi, gs, 0x081455D0, out esi_74, out edi_75);
	word32 eax_22 = g_dw8145580;
	word32 ecx_23 = g_dw8145584;
	if (((int8) (ecx_23 != 0x00) | (int8) (eax_22 != 0x00)) != 0x00)
		runtime.throw(gs);
	else
	{
		g_dw8145588 = 0x00;
		g_dw814558C = 0x00;
		runtime.(*mSpanList).takeAll(gs, &g_t81455D4, &g_t81455DC);
		word32 edx_76;
		word32 ebx_77;
		runtime.unlock(gs, 0x081455D0, out edx_76, out ebx_77);
	}
}

// 08064510: Register Eq_4 runtime.freeSomeWbufs(Register Eq_4 esi, Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.gcSweep
//      runtime.bgsweep
Eq_4 runtime.freeSomeWbufs(Eq_4 esi, struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	word32 esi_28;
	word32 edi_137;
	runtime.lock(esi, gs, 0x081455D0, out esi_28, out edi_137);
	if (runtime.gcphase == 0x00 && g_t81455D4 != 0x00)
	{
		word32 ebp_140;
		word32 edi_141;
		runtime.systemstack(gs, fp - 0x0C, out ebp_140, out edi_141);
		word32 edx_142;
		word32 ebx_143;
		runtime.unlock(gs, 0x081455D0, out edx_142, out ebx_143);
		return;
	}
	else
	{
		word32 edx_138;
		word32 ebx_139;
		runtime.unlock(gs, 0x081455D0, out edx_138, out ebx_139);
		return;
	}
}

// 080645C0: void runtime.recordspan(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_33559) dwArg04, Stack word32 dwArg08)
void runtime.recordspan(struct Eq_2 * gs, struct Eq_33559 * dwArg04, word32 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 edx_23 = dwArg04->t0824;
	if (dwArg04->t0820 >= edx_23)
	{
		Eq_33596 ecx_32 = (edx_23 * 0x03 >> 0x1F >> 0x1F) + edx_23 * 0x03;
		Eq_4 ecx_33 = ecx_32 >> 0x01;
		if (ecx_32 >> 0x01 <= 0x4000)
			ecx_33.u0 = 0x4000;
		runtime.sysAlloc();
		if (dwLoc40 == 0x00)
			runtime.throw(gs);
		Eq_4 ecx_75 = dwArg04->t0820;
		Eq_4 ecx_79 = dwArg04->t081C;
		Eq_4 edx_80 = dwArg04->t0820;
		Eq_4 ebx_81 = dwArg04->t0824;
		if (edx_80 > 0x00)
		{
			word32 edi_435;
			word32 esi_434;
			runtime.typedslicecopy(gs, 0x080DB9C0, dwLoc40, ecx_75, ecx_79, edx_80, out esi_434, out edi_435);
			dwLoc34 = edx_80;
			dwLoc30 = ebx_81;
		}
		Eq_4 edx_118 = dwArg04->t0820;
		dwArg04->t0820 = ecx_75;
		dwArg04->t0824 = ecx_33;
		if (g_t81576F0 == 0x00)
			dwArg04->t081C = dwLoc40;
		else
			runtime.writebarrierptr(&dwArg04->t081C, dwLoc40);
		if (edx_118 != 0x00)
			runtime.sysFree();
	}
	Eq_4 ecx_174 = dwArg04->t081C;
	Eq_4 edx_175 = dwArg04->t0824;
	Eq_4 ebx_176 = dwArg04->t0820;
	if ((word32) ebx_176 + 1 > edx_175)
	{
		word128 xmm1_438;
		word128 xmm0_437;
		word32 esi_436;
		runtime.growslice(gs, 0x080DB9C0, ecx_174, ebx_176, edx_175, (word32) ebx_176 + 1, out esi_436, out xmm0_437, out xmm1_438);
		dwArg04->t0824 = dwLoc2C;
		if (g_t81576F0 == 0x00)
			dwArg04->t081C = dwLoc34;
		else
			runtime.writebarrierptr(&dwArg04->t081C, dwLoc34);
		ebx_176 = dwLoc30;
		ecx_174 = dwLoc34;
	}
	dwArg04->t0820 = (word32) ebx_176 + 1;
	*((word32) ecx_174 + ebx_176 * 0x04) = dwArg08;
}

// 08064840: void runtime.(*mheap).init(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack uint32 dwArg0C)
// Called from:
//      runtime.mallocinit
void runtime.(*mheap).init(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, uint32 dwArg0C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	*((word32) dwArg04 + 11432) = 0x18;
	if (g_t81576F0 == 0x00)
	{
		*((word32) dwArg04 + 0x00002CAC) = 0x00;
		*((word32) dwArg04 + 11440) = 0x00;
	}
	else
	{
		runtime.writebarrierptr((word32) dwArg04 + 0x00002CAC, 0x00);
		runtime.writebarrierptr((word32) dwArg04 + 11440, 0x00);
	}
	*((word32) dwArg04 + 11444) = 0x00;
	*((word32) dwArg04 + 11448) = 0x00;
	*((word32) dwArg04 + 0x00002CBC) = 0x00;
	*((word32) dwArg04 + 0x00002CC0) = 0x00;
	if (g_t81576F0 == 0x00)
		*((word32) dwArg04 + 0x00002CC4) = 0x08158220;
	else
		runtime.writebarrierptr((word32) dwArg04 + 0x00002CC4, 0x08158220);
	*((word32) dwArg04 + 0x00002CC8) = 0x01;
	*((word32) dwArg04 + 11360) = 0x5C;
	if (g_t81576F0 == 0x00)
	{
		*((word32) dwArg04 + 11364) = 0x080E7CA8;
		*((word32) dwArg04 + 11368) = dwArg04;
	}
	else
	{
		runtime.writebarrierptr((word32) dwArg04 + 11364, 0x080E7CA8);
		runtime.writebarrierptr((word32) dwArg04 + 11368, dwArg04);
	}
	*((word32) dwArg04 + 0x00002C6C) = 0x00;
	*((word32) dwArg04 + 11376) = 0x00;
	*((word32) dwArg04 + 11380) = 0x00;
	*((word32) dwArg04 + 11384) = 0x00;
	if (g_t81576F0 == 0x00)
		*((word32) dwArg04 + 0x00002C7C) = 0x081581F8;
	else
		runtime.writebarrierptr((word32) dwArg04 + 0x00002C7C, 0x081581F8);
	*((word32) dwArg04 + 11392) = 0x01;
	*((word32) dwArg04 + 11396) = 868;
	if (g_t81576F0 == 0x00)
	{
		*((word32) dwArg04 + 0x00002C88) = 0x00;
		*((word32) dwArg04 + 0x00002C8C) = 0x00;
	}
	else
	{
		runtime.writebarrierptr((word32) dwArg04 + 0x00002C88, 0x00);
		runtime.writebarrierptr((word32) dwArg04 + 0x00002C8C, 0x00);
	}
	*((word32) dwArg04 + 11408) = 0x00;
	*((word32) dwArg04 + 11412) = 0x00;
	*((word32) dwArg04 + 11416) = 0x00;
	*((word32) dwArg04 + 0x00002C9C) = 0x00;
	if (g_t81576F0 == 0x00)
		*((word32) dwArg04 + 11424) = 0x08158208;
	else
		runtime.writebarrierptr((word32) dwArg04 + 11424, 0x08158208);
	*((word32) dwArg04 + 11428) = 0x01;
	*((word32) dwArg04 + 0x00002CCC) = 0x18;
	if (g_t81576F0 == 0x00)
	{
		*((word32) dwArg04 + 11472) = 0x00;
		*((word32) dwArg04 + 11476) = 0x00;
	}
	else
	{
		runtime.writebarrierptr((word32) dwArg04 + 11472, 0x00);
		runtime.writebarrierptr((word32) dwArg04 + 11476, 0x00);
	}
	*((word32) dwArg04 + 11480) = 0x00;
	*((word32) dwArg04 + 0x00002CDC) = 0x00;
	*((word32) dwArg04 + 11488) = 0x00;
	*((word32) dwArg04 + 11492) = 0x00;
	if (g_t81576F0 == 0x00)
		*((word32) dwArg04 + 11496) = 0x08158220;
	else
		runtime.writebarrierptr((word32) dwArg04 + 11496, 0x08158220);
	*((word32) dwArg04 + 0x00002CEC) = 0x01;
	*((word32) dwArg04 + 11504) = 0x0C;
	if (g_t81576F0 == 0x00)
	{
		*((word32) dwArg04 + 11508) = 0x00;
		*((word32) dwArg04 + 11512) = 0x00;
	}
	else
	{
		runtime.writebarrierptr((word32) dwArg04 + 11508, 0x00);
		runtime.writebarrierptr((word32) dwArg04 + 11512, 0x00);
	}
	*((word32) dwArg04 + 11516) = 0x00;
	*((word32) dwArg04 + 0x00002D00) = 0x00;
	*((word32) dwArg04 + 11524) = 0x00;
	*((word32) dwArg04 + 11528) = 0x00;
	if (g_t81576F0 == 0x00)
		*((word32) dwArg04 + 11532) = 0x08158220;
	else
		runtime.writebarrierptr((word32) dwArg04 + 11532, 0x08158220);
	*((word32) dwArg04 + 11536) = 0x01;
	*((word32) dwArg04 + 11392) = 0x00;
	Eq_33857 ecx_349 = 0x00;
	while (ecx_349 < 0x80)
	{
		if (ecx_349 >= 0x80)
			runtime.panicindex(gs);
		*((word32) dwArg04 + (ecx_349 * 0x08 + 4)) = 0x00;
		((word32) dwArg04 + (ecx_349 * 0x08 + 8))->u0 = 0x00;
		*((word32) dwArg04 + (ecx_349 * 0x08 + 0x0408)) = 0x00;
		*((word32) dwArg04 + (ecx_349 * 0x08 + 0x040C)) = 0x00;
		ecx_349 = (word32) ecx_349 + 1;
	}
	*((word32) dwArg04 + 0x0808) = 0x00;
	*((word32) dwArg04 + 2060) = 0x00;
	Eq_33868 ecx_362 = 0x00;
	while (ecx_362 < 0x86)
	{
		if (ecx_362 >= 0x86)
			runtime.panicindex(gs);
		*((word32) dwArg04 + (ecx_362 * 0x40 + 2788)) = (byte) ecx_362;
		*((word32) dwArg04 + (ecx_362 * 0x40 + 2792)) = 0x00;
		*((word32) dwArg04 + (ecx_362 * 0x40 + 0x0AEC)) = 0x00;
		*((word32) dwArg04 + (ecx_362 * 0x40 + 2800)) = 0x00;
		*((word32) dwArg04 + (ecx_362 * 0x40 + 0x0AF4)) = 0x00;
		ecx_362 = (word32) ecx_362 + 1;
	}
	if (g_t81576F0 == 0x00)
		*((word32) dwArg04 + 0x0828) = dwArg08;
	else
		runtime.writebarrierptr((word32) dwArg04 + 0x0828, dwArg08);
	*((word32) dwArg04 + 2092) = 0x00;
	*((word32) dwArg04 + 0x0830) = dwArg0C >> 0x02;
	runtime.(*mheap).setArenaUsed(gs, dwArg04, *((word32) dwArg04 + 0x0ACC));
}

// 08064E10: void runtime.(*mheap).setArenaUsed(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack uint32 dwArg08)
// Called from:
//      runtime.(*mheap).sysAlloc
//      runtime.(*mheap).init
void runtime.(*mheap).setArenaUsed(struct Eq_2 * gs, Eq_4 dwArg04, uint32 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.(*mheap).mapBits(gs, dwArg04, dwArg08);
	runtime.(*mheap).mapSpans(gs, dwArg04, dwArg08);
	*((word32) dwArg04 + 0x0ACC) = dwArg08;
}

// 08064E70: void runtime.(*mheap).mapSpans(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack uint32 dwArg08)
// Called from:
//      runtime.(*mheap).setArenaUsed
void runtime.(*mheap).mapSpans(struct Eq_2 * gs, Eq_4 dwArg04, uint32 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 ecx_22 = runtime.physPageSize;
	uint32 edx_26 = ecx_22 - 0x01 + (dwArg08 - *((word32) dwArg04 + 0x0AC8) >> 0x0D) * 0x04 & ~(ecx_22 - 0x01);
	uint32 ecx_28 = *((word32) dwArg04 + 2092);
	uint32 ebx_29 = *((word32) dwArg04 + 0x0830);
	if (ecx_28 >= edx_26 >> 0x02)
		return;
	if (edx_26 >> 0x02 > ebx_29)
		runtime.panicslice(gs);
	else
	{
		*((word32) dwArg04 + 2092) = edx_26 >> 0x02;
		struct Eq_34192 * ebx_41 = *((word32) dwArg04 + 0x0828);
		if (ecx_28 >= edx_26 >> 0x02)
			runtime.panicindex(gs);
		else
			runtime.sysMap(gs, ebx_41 + ecx_28 * 0x04, *((word32) dwArg04 + 2776));
	}
}

// 08064F20: Register word128 runtime.(*mheap).reclaimList(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C)
// Called from:
//      runtime.(*mheap).reclaim
word128 runtime.(*mheap).reclaimList(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 eax_17 = g_t81490F0;
	Eq_4 ecx_153 = 0x00;
l08065026:
	Eq_4 eax_154 = eax_17;
	Eq_4 ebx_165 = *dwArg08;
	while (ebx_165 != 0x00)
	{
		Eq_4 esi_33 = (word32) ebx_165 + 48;
		Eq_4 edi_35 = eax_154 - 0x02;
		if (*((word32) ebx_165 + 48) == edi_35)
		{
			Eq_4 ecx_42 = eax_154 - 0x01;
			runtime/internal/atomic.Cas(esi_33, edi_35, ecx_42);
			byte bLoc18_311 = (byte) ecx_42;
			if (bLoc14 != 0x00)
			{
				Eq_4 eax_122;
				runtime.(*mSpanList).remove(gs, dwArg08, ebx_165);
				runtime.(*mSpanList).insertBack(gs, dwArg08, ebx_165);
				word32 edx_347;
				word32 ebx_348;
				runtime.unlock(gs, dwArg04, out edx_347, out ebx_348);
				Eq_4 ecx_92 = *((word32) ebx_165 + 16);
				word128 xmm0_349;
				Eq_4 esi_102 = runtime.(*mspan).sweep(gs, dwLoc24, (byte) ebx_165, out xmm0_349, out xmm2);
				if (bLoc18_311 != 0x00)
					eax_122 = ecx_92 + ecx_153;
				else
					eax_122 = ecx_153;
				word32 esi_350;
				word32 edi_351;
				runtime.lock(esi_102, gs, dwArg04, out esi_350, out edi_351);
				if (eax_122 >= dwArg0C)
					return xmm2;
				else
				{
					ecx_153 = eax_122;
					goto l08065026;
				}
			}
			eax_154 = eax_17;
		}
		if (*((word32) ebx_165 + 48) != eax_154 - 0x01)
			return xmm2;
		ebx_165 = *ebx_165;
	}
	return xmm2;
}

// 08065050: void runtime.(*mheap).reclaim(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
// Called from:
//      runtime.(*mheap).alloc_m
void runtime.(*mheap).reclaim(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 eax_18 = dwArg08;
	while (eax_18 < 0x80)
	{
		if (eax_18 >= 0x80)
			runtime.panicindex(gs);
		runtime.(*mheap).reclaimList(gs, dwArg04, (word32) dwArg04 + 0x0408 + eax_18 * 0x08, dwArg08);
		if (dwLoc10 != 0x00)
			return;
		eax_18 = (word32) eax_18 + 1;
	}
	Eq_662 xmm2_105 = runtime.(*mheap).reclaimList(gs, dwArg04, (word32) dwArg04 + 0x0808, dwArg08);
	if (dwLoc10 != 0x00)
		return;
	Eq_4 eax_181 = 0x00;
	Eq_4 ecx_180 = 0x00;
	while (eax_181 < dwArg08 && eax_181 < 0x80)
	{
		if (eax_181 >= 0x80)
			runtime.panicindex(gs);
		xmm2_105 = runtime.(*mheap).reclaimList(gs, dwArg04, (word32) dwArg04 + 0x0408 + eax_181 * 0x08, dwArg08 - ecx_180);
		Eq_4 eax_173 = (word32) ecx_180 + dwLoc10;
		if (eax_173 >= dwArg08)
			return;
		ecx_180 = eax_173;
		eax_181 = (word32) eax_181 + 1;
	}
	word32 edx_313;
	word32 ebx_314;
	runtime.unlock(gs, dwArg04, out edx_313, out ebx_314);
	Eq_4 eax_119 = ecx_180;
	do
	{
		word128 xmm0_317;
		Eq_4 esi_103 = runtime.sweepone(gs, xmm2_105, dwLoc20, out xmm0_317, out xmm2_105);
		if (dwArg04 == ~0x00)
			break;
		eax_119 = dwArg04 + eax_119;
	} while (eax_119 < dwArg08);
	word32 esi_315;
	word32 edi_316;
	runtime.lock(esi_103, gs, dwArg04, out esi_315, out edi_316);
}

// 080651A0: void runtime.(*mheap).alloc_m(Register Eq_4 esi, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 bArg0C, Stack byte bArg0D)
// Called from:
//      runtime.(*mheap).alloc.func1
void runtime.(*mheap).alloc_m(Eq_4 esi, struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 bArg0C, byte bArg0D)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 eax_18 = gs->ptr0000->tFFFFFFFC;
	if (eax_18 != *(*((word32) eax_18 + 24)))
		runtime.throw(gs);
	else
	{
		word32 esi_556;
		word32 edi_557;
		runtime.lock(esi, gs, dwArg04, out esi_556, out edi_557);
		if (*((word32) dwArg04 + 0x0814) == 0x00)
		{
			if (g_b814F4C8 != 0x00)
				runtime.traceGCSweepStart(gs);
			runtime.(*mheap).reclaim(gs, dwArg04, dwArg08);
			if (g_b814F4C8 != 0x00)
				runtime.traceGCSweepDone(gs);
		}
		uint32 edx_118 = (word32) *((word32) *((word32) *((word32) eax_18 + 24) + 0x00B8) + 4) + g_dw81597B8;
		uint32 ecx_120 = g_dw81597BC;
		g_dw81597B8 = edx_118;
		g_dw81597BC = (uint32) ((bool) (edx_118 < 0x00) + ecx_120);
		((word32) *((word32) *((word32) eax_18 + 24) + 0x00B8) + 4)->u0 = 0x00;
		up32 edx_132 = (word32) *((word32) *((word32) *((word32) eax_18 + 24) + 0x00B8) + 16) + g_dw8159798;
		word32 ecx_134 = g_dw815979C;
		g_dw8159798 = edx_132;
		g_dw815979C = (word32) ((bool) (edx_132 < 0x00) + ecx_134);
		((word32) *((word32) *((word32) eax_18 + 24) + 0x00B8) + 16)->u0 = 0x00;
		Eq_4 esi_156;
		Eq_4 ebp_151 = runtime.(*mheap).allocSpanLocked(gs, dwArg04, dwArg08, &g_t81581C8, out esi_156);
		if (dwLoc10 != 0x00)
		{
			runtime/internal/atomic.Store((word32) dwLoc10 + 48, *((word32) dwArg04 + 0x0810));
			word128 xmm0_558;
			word128 xmm2_559;
			runtime.(*gcSweepBuf).push(esi_156, gs, dwLoc20, (word32) dwArg04 + 2100 + (*((word32) dwArg04 + 0x0810) >> 0x01 & 0x01) * 0x14, dwLoc10, out xmm0_558, out xmm2_559);
			((word32) dwLoc10 + 60)->u0 = 0x01;
			((word32) dwLoc10 + 56)->u2 = 0x00;
			*((word32) dwLoc10 + 58) = bArg0C;
			if (bArg0C >> 0x01 == 0x00)
			{
				*((word32) dwLoc10 + 64) = *((word32) dwLoc10 + 16) << 0x0D;
				*((word32) dwLoc10 + 62) = 0x00;
				((word32) dwLoc10 + 52)->u2 = 0x00;
				*((word32) dwLoc10 + 63) = 0x00;
				((word32) dwLoc10 + 54)->u2 = 0x00;
			}
			else
			{
				Eq_34590 ecx_215 = (int32) (bArg0C >> 0x01);
				if (ecx_215 >= 0x43)
					runtime.panicindex(gs);
				*((word32) dwLoc10 + 64) = (word32) g_a8138820[ecx_215 * 0x02];
				*((word32) dwLoc10 + 62) = g_a813A9C0[ecx_215];
				*((word32) dwLoc10 + 52) = g_a813A9C2[ecx_215];
				*((word32) dwLoc10 + 63) = g_a813A9C1[ecx_215];
				*((word32) dwLoc10 + 54) = g_a813A9C4[ecx_215];
			}
			word32 edx_256 = Mem252[dwArg04 + 0x0860:word32] + dwArg08;
			Eq_4 ebp_258 = *((word32) dwArg04 + 0x0864);
			*((word32) dwArg04 + 2144) = edx_256;
			ebp_151 = ebp_258 + (edx_256 <u 0x00);
			*((word32) dwArg04 + 0x0864) = ebp_151;
			if (bArg0D != 0x00)
			{
				up32 ecx_268 = g_dw81581D8;
				word32 edx_271 = g_dw81581DC;
				g_dw81581D8 = ecx_268 + 0x01;
				g_dw81581DC = (word32) ((bool) (ecx_268 < 0x01) + edx_271);
				up32 ecx_279 = (word32) *((word32) dwLoc10 + 64) + g_dw8149168;
				word32 edx_281 = g_dw814916C;
				g_dw8149168 = ecx_279;
				g_dw814916C = (word32) ((bool) (ecx_279 < 0x00) + edx_281);
				up32 ecx_286 = g_dw8149170;
				word32 edx_289 = g_dw8149174;
				g_dw8149170 = ecx_286 + 0x01;
				g_dw8149174 = (word32) ((bool) (ecx_286 < 0x01) + edx_289);
				word32 ebx_563;
				runtime/internal/atomic.Xadd64(135632816, dwArg08 << 0x0D, 0x00, out ebx_563, out ebp_151);
				Eq_4 ecx_310 = *((word32) dwLoc10 + 16);
				if (ecx_310 < 0x80)
					runtime.(*mSpanList).insertBack(gs, (word32) dwArg04 + 0x0408 + ecx_310 * 0x08, dwLoc10);
				else
					runtime.(*mSpanList).insertBack(gs, (word32) dwArg04 + 0x0808, dwLoc10);
			}
		}
		if (runtime.gcBlackenEnabled != 0x00)
			runtime.(*gcControllerState).revise(ebp_151, gs, &g_dw8157860);
		if (g_b814F4C8 != 0x00)
		{
			word32 esi_560;
			runtime.traceHeapAlloc(gs, out esi_560);
		}
		word32 edx_561;
		word32 ebx_562;
		runtime.unlock(gs, dwArg04, out edx_561, out ebx_562);
	}
}

// 08065510: void runtime.(*mheap).alloc(Register (ptr32 Eq_2) gs, Stack Eq_4 bArg0E)
// Called from:
//      runtime.largeAlloc
//      runtime.(*mcentral).grow
void runtime.(*mheap).alloc(struct Eq_2 * gs, Eq_4 bArg0E)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	fn0808FD8B(0x00, fp - 0x14);
	word32 ebp_130;
	word32 edi_131;
	runtime.systemstack(gs, fp - 0x14, out ebp_130, out edi_131);
}

// 080655D0: void runtime.(*mheap).allocManual(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.stackpoolalloc
//      runtime.stackalloc
//      runtime.getempty.func1
void runtime.(*mheap).allocManual(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 0x0C))
		runtime.morestackc();
	word32 edi_105;
	word32 esi_104;
	runtime.lock(esi, gs, dwArg04, out esi_104, out edi_105);
	word32 esi_106;
	runtime.(*mheap).allocSpanLocked(gs, dwArg04, dwArg08, dwArg0C, out esi_106);
	if (dwLoc08 != null)
	{
		dwLoc08->b003C = 0x02;
		dwLoc08->dw0014 = 0x00;
		dwLoc08->w0038 = 0x00;
		dwLoc08->b003A = 0x00;
		dwLoc08->dw001C = 0x00;
		dwLoc08->dw0040 = 0x00;
		dwLoc08->dw0050 = (dwLoc08->dw0010 << 0x0D) + dwLoc08->dw000C;
		Eq_4 ecx_55 = g_t81581B8 - (dwLoc08->dw0010 << 0x0D);
		Eq_4 edx_57 = g_t81581BC;
		g_t81581B8 = ecx_55;
		g_t81581BC = edx_57 - (ecx_55 < 0x00);
	}
	word32 ebx_108;
	word32 edx_107;
	runtime.unlock(gs, dwArg04, out edx_107, out ebx_108);
}

// 080656A0: Register Eq_4 runtime.(*mheap).allocSpanLocked(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack (ptr32 Eq_34505) dwArg0C, Register out (ptr32 Eq_34192) esiOut)
// Called from:
//      runtime.(*mheap).alloc_m
//      runtime.(*mheap).allocManual
Eq_4 runtime.(*mheap).allocSpanLocked(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, struct Eq_34505 * dwArg0C, struct Eq_34192 & esiOut)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 eax_18 = dwArg08;
	while (true)
	{
		Eq_4 dwLoc1C_339;
		Eq_4 eax_34;
		byte bLoc18_346 = (byte) dwLoc18;
		if (eax_18 >= 0x80)
			break;
		if (eax_18 >= 0x80)
			runtime.panicindex(gs);
		Eq_4 ebx_78 = (word32) dwArg04 + 4 + eax_18 * 0x08;
		ebp = *((word32) dwArg04 + (eax_18 * 0x08 + 4));
		if (ebp != 0x00)
		{
			runtime.(*mSpanList).remove(gs, ebx_78, ebp);
			dwLoc1C_339 = ebp;
			eax_34 = ebp;
			goto l08065701;
		}
		eax_18 = (word32) eax_18 + 1;
	}
	runtime.(*mheap).allocLarge(gs);
	dwLoc1C_339 = dwArg08;
	eax_34 = dwLoc18;
	if (dwLoc18 == 0x00)
	{
		runtime.(*mheap).grow(gs, dwArg04, dwArg08);
		if (bLoc18_346 == 0x00)
		{
			esiOut = esi;
			return ebp;
		}
		runtime.(*mheap).allocLarge(gs);
		dwLoc1C_339 = dwArg08;
		eax_34 = dwLoc18;
		if (dwLoc18 == 0x00)
		{
			esiOut = esi;
			return ebp;
		}
	}
l08065701:
	if (*((word32) eax_34 + 60) != 0x03)
		runtime.throw(gs);
	else
	{
		Eq_4 ecx_109 = *((word32) eax_34 + 16);
		if (ecx_109 < dwArg08)
			runtime.throw(gs);
		else
		{
			if (*((word32) eax_34 + 76) > 0x00)
			{
				runtime.sysUsed(gs, *((word32) eax_34 + 0x0C), ecx_109 << 0x0D);
				uint32 eax_140 = g_dw81581D0 - (*((word32) eax_34 + 76) << 0x0D);
				uint32 edx_142 = g_dw81581D4;
				g_dw81581D0 = eax_140;
				g_dw81581D4 = edx_142 - (eax_140 < 0x00);
				((word32) eax_34 + 76)->u0 = 0x00;
				dwLoc1C_339 = ecx_109 << 0x0D;
			}
			if (*((word32) eax_34 + 16) > dwArg08)
			{
				runtime.(*fixalloc).alloc(gs, (word32) dwArg04 + 11360);
				Eq_4 edx_171 = *((word32) eax_34 + 16);
				Eq_4 ebx_172 = *((word32) eax_34 + 0x0C);
				*dwLoc1C_339 = 0x00;
				((word32) dwLoc1C_339 + 4)->u0 = 0x00;
				((word32) dwLoc1C_339 + 8)->u0 = 0x00;
				*((word32) dwLoc1C_339 + 0x0C) = (word32) ebx_172 + (dwArg08 << 0x0D);
				*((word32) dwLoc1C_339 + 16) = edx_171 - dwArg08;
				((word32) dwLoc1C_339 + 56)->u0 = 0x00;
				((word32) dwLoc1C_339 + 64)->u0 = 0x00;
				((word32) dwLoc1C_339 + 60)->u0 = 0x00;
				((word32) dwLoc1C_339 + 0x0044)->u0 = 0x00;
				((word32) dwLoc1C_339 + 72)->u0 = 0x00;
				((word32) dwLoc1C_339 + 76)->u0 = 0x00;
				((word32) dwLoc1C_339 + 84)->u0 = 0x00;
				((word32) dwLoc1C_339 + 88)->u0 = 0x00;
				*((word32) dwLoc1C_339 + 61) = 0x00;
				((word32) dwLoc1C_339 + 24)->u0 = 0x00;
				((word32) dwLoc1C_339 + 40)->u0 = 0x00;
				((word32) dwLoc1C_339 + 44)->u0 = 0x00;
				*((word32) eax_34 + 16) = dwArg08;
				uint32 ebp_199 = *((word32) dwLoc1C_339 + 0x0C) - *((word32) dwArg04 + 0x0AC8);
				if (ebp_199 >> 0x0D > 0x00)
				{
					struct Eq_34192 * edi_206 = *((word32) dwArg04 + 0x0828);
					if ((ebp_199 >> 0x0D) - 0x01 >= *((word32) dwArg04 + 2092))
						runtime.panicindex(gs);
					(edi_206 - 0x04)[ebp_199 >> 0x0D] = eax_34;
				}
				struct Eq_34192 * ebx_217 = *((word32) dwArg04 + 0x0828);
				if (ebp_199 >> 0x0D >= *((word32) dwArg04 + 2092))
					runtime.panicindex(gs);
				ebx_217[(ebp_199 >> 0x0D) * 0x04] = (struct Eq_34192) dwLoc1C_339;
				esi = (struct Eq_34192 *) *((word32) dwArg04 + 0x0828);
				uint32 ebp_233 = (word32) *((word32) dwLoc1C_339 + 16) + ((ebp_199 >> 0x0D) - 0x01);
				if (ebp_233 >= *((word32) dwArg04 + 2092))
					runtime.panicindex(gs);
				esi[ebp_233 * 0x04] = (struct Eq_34192) dwLoc1C_339;
				*((word32) dwLoc1C_339 + 61) = *((word32) eax_34 + 61);
				((word32) eax_34 + 60)->u0 = 0x02;
				((word32) dwLoc1C_339 + 60)->u0 = 0x02;
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				Eq_4 stackArg13 = <invalid>;
				runtime.(*mheap).freeSpanLocked(gs, dwArg04, dwLoc1C_339, 0x00, stackArg13, *((word32) eax_34 + 0x0044), *((word32) eax_34 + 72));
				((word32) eax_34 + 60)->u0 = 0x03;
			}
			((word32) eax_34 + 0x0044)->u0 = 0x00;
			((word32) eax_34 + 72)->u0 = 0x00;
			uint32 ebx_266 = *((word32) dwArg04 + 0x0AC8);
			Eq_4 ebp_267 = *((word32) eax_34 + 0x0C);
			uint32 ebp_268 = ebp_267 - ebx_266;
			Eq_4 ebx_271 = 0x00;
			while (true)
			{
				uint32 ebp_317 = ebp_267 - ebx_266 >> 0x0D;
				if (ebx_271 >= dwArg08)
					break;
				struct Eq_34192 * esi_315 = *((word32) dwArg04 + 0x0828);
				uint32 ebp_318 = (word32) ebx_271 + ebp_317;
				if (ebp_318 >= *((word32) dwArg04 + 2092))
					runtime.panicindex(gs);
				esi_315[ebp_318 * 0x04] = (struct Eq_34192) eax_34;
				ebx_271 = (word32) ebx_271 + 1;
				esi = ebp_268 >> 0x0D;
			}
			up32 ebx_283 = dwArg0C->dw0000 + (dwArg08 << 0x0D);
			Eq_4 ebp_285 = dwArg0C->t0004;
			dwArg0C->dw0000 = ebx_283;
			word32 ebp_288 = ebp_285 + (ebx_283 <u 0x00);
			dwArg0C->t0004 = ebp_288;
			uint32 ecx_291 = g_dw81581C0 - (dwArg08 << 0x0D);
			uint32 edx_293 = g_dw81581C4;
			g_dw81581C0 = ecx_291;
			g_dw81581C4 = edx_293 - (ecx_291 < 0x00);
			if (*((word32) eax_34 + 8) != 0x00)
				runtime.throw(gs);
			else
			{
				esiOut = esi;
				return ebp_288;
			}
		}
	}
}

// 08065A40: void runtime.(*mheap).allocLarge(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.(*mheap).allocSpanLocked
void runtime.(*mheap).allocLarge(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.(*mTreap).remove(gs, dwArg04 + 0x0404, dwArg08);
}

// 08065A90: void runtime.(*mheap).grow(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
// Called from:
//      runtime.(*mheap).allocSpanLocked
void runtime.(*mheap).grow(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 ecx_24;
	ui32 eax_19 = (word32) dwArg08 + 7 & ~0x07;
	if (eax_19 << 0x0D < 0x00100000)
		ecx_24.u0 = 0x00100000;
	else
		ecx_24 = eax_19 << 0x0D;
	Eq_4 ecx_113;
	runtime.(*mheap).sysAlloc(gs, dwArg04, ecx_24);
	Eq_4 dwLoc2C_222 = ecx_24;
	if (dwLoc28 != 0x00)
		ecx_113 = ecx_24;
	else
	{
		ecx_113 = ecx_24;
		if (ecx_24 > eax_19 << 0x0D)
		{
			runtime.(*mheap).sysAlloc(gs, dwArg04, eax_19 << 0x0D);
			dwLoc2C_222 = eax_19 << 0x0D;
			ecx_113 = eax_19 << 0x0D;
		}
		if (dwLoc28 == 0x00)
		{
			Eq_4 eax_61 = g_t81581B8;
			Eq_4 ecx_63 = g_t81581BC;
			runtime.printlock(gs);
			runtime.printstring(gs);
			runtime.printint(SLICE(ebx, word24, 8), gs, ecx_113);
			runtime.printstring(gs);
			runtime.printuint(ebp, gs, eax_61, ecx_63);
			runtime.printstring(gs);
			runtime.printunlock(gs);
			return;
		}
	}
	runtime.(*fixalloc).alloc(gs, (word32) dwArg04 + 11360);
	*dwLoc2C_222 = 0x00;
	((word32) dwLoc2C_222 + 4)->u0 = 0x00;
	((word32) dwLoc2C_222 + 8)->u0 = 0x00;
	*((word32) dwLoc2C_222 + 0x0C) = dwLoc28;
	*((word32) dwLoc2C_222 + 16) = ecx_113 >> 0x0D;
	((word32) dwLoc2C_222 + 56)->u0 = 0x00;
	((word32) dwLoc2C_222 + 64)->u0 = 0x00;
	((word32) dwLoc2C_222 + 60)->u0 = 0x00;
	((word32) dwLoc2C_222 + 0x0044)->u0 = 0x00;
	((word32) dwLoc2C_222 + 72)->u0 = 0x00;
	((word32) dwLoc2C_222 + 76)->u0 = 0x00;
	((word32) dwLoc2C_222 + 84)->u0 = 0x00;
	((word32) dwLoc2C_222 + 88)->u0 = 0x00;
	*((word32) dwLoc2C_222 + 61) = 0x00;
	((word32) dwLoc2C_222 + 24)->u0 = 0x00;
	((word32) dwLoc2C_222 + 40)->u0 = 0x00;
	((word32) dwLoc2C_222 + 44)->u0 = 0x00;
	uint32 ebx_154 = *((word32) dwLoc2C_222 + 0x0C) - *((word32) dwArg04 + 0x0AC8);
	uint32 ebx_155;
	for (ebx_155 = ebx_154 >> 0x0D; ebx_155 < (word32) (*((word32) dwLoc2C_222 + 16)) + (ebx_154 >> 0x0D); ++ebx_155)
	{
		struct Eq_34192 * ebp_201 = *((word32) dwArg04 + 0x0828);
		if (ebx_155 >= *((word32) dwArg04 + 2092))
			runtime.panicindex(gs);
		ebp_201[ebx_155 * 0x04] = (struct Eq_34192) dwLoc2C_222;
	}
	runtime/internal/atomic.Store((word32) dwLoc2C_222 + 48, *((word32) dwArg04 + 0x0810));
	((word32) dwLoc2C_222 + 60)->u0 = 0x01;
	word32 ebx_180 = Mem176[dwLoc2C_222 + 0x10:word32] + Mem176[dwArg04 + 0x0860:word32];
	Eq_4 edx_182 = *((word32) dwArg04 + 0x0864);
	*((word32) dwArg04 + 2144) = ebx_180;
	Mem187[dwArg04 + 0x0864:word32] = edx_182 + (ebx_180 <u 0x00);
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	Eq_4 stackArg13 = <invalid>;
	runtime.(*mheap).freeSpanLocked(gs, dwArg04, dwLoc2C_222, 0x0100, stackArg13, 0x00, 0x00);
}

// 08065D10: void runtime.(*mheap).freeSpan(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.(*mcentral).freeSpan
//      runtime.(*mspan).sweep
void runtime.(*mheap).freeSpan(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	word32 ebp_59;
	word32 edi_60;
	runtime.systemstack(gs, fp - 0x10, out ebp_59, out edi_60);
}

// 08065D60: void runtime.(*mheap).freeManual(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg08, Stack (ptr32 Eq_35501) dwArg0C)
// Called from:
//      runtime.stackpoolfree
//      runtime.stackfree
//      runtime.freeStackSpans
//      runtime.freeSomeWbufs.func1
void runtime.(*mheap).freeManual(struct Eq_2 * gs, Eq_4 dwArg08, struct Eq_35501 * dwArg0C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 0x0C))
		runtime.morestackc();
	*((word32) dwArg08 + 61) = 0x01;
	word32 esi_89;
	word32 edi_90;
	runtime.lock(esi, gs, dwArg04, out esi_89, out edi_90);
	up32 ecx_33 = dwArg0C->dw0000 - (*((word32) dwArg08 + 16) << 0x0D);
	word32 ebx_35 = dwArg0C->dw0004;
	dwArg0C->dw0000 = ecx_33;
	dwArg0C->dw0004 = ebx_35 - (ecx_33 < 0x00);
	Eq_4 eax_43 = (word32) g_t81581B8 + (*((word32) dwArg08 + 16) << 0x0D);
	Eq_4 ecx_45 = g_t81581BC;
	g_t81581B8 = eax_43;
	Mem50[0x081581BC<p32>:word32] = ecx_45 + (eax_43 <u 0x00);
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	Eq_4 stackArg13 = <invalid>;
	runtime.(*mheap).freeSpanLocked(gs, dwArg04, dwArg08, 0x0100, stackArg13, 0x00, 0x00);
	word32 edx_92;
	word32 ebx_93;
	runtime.unlock(gs, dwArg04, out edx_92, out ebx_93);
}

// 08065E10: void runtime.(*mheap).freeSpanLocked(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_35238 bArg0C, Stack Eq_4 bArg0D, Stack Eq_4 dwArg10, Stack Eq_4 dwArg14)
// Called from:
//      runtime.(*mheap).allocSpanLocked
//      runtime.(*mheap).grow
//      runtime.(*mheap).freeManual
//      runtime.(*mheap).freeSpan.func1
void runtime.(*mheap).freeSpanLocked(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, Eq_35238 bArg0C, Eq_4 bArg0D, Eq_4 dwArg10, Eq_4 dwArg14)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 cl_19 = *((word32) dwArg08 + 60);
	if (cl_19 == 0x01)
	{
		Eq_4 cx_45 = *((word32) dwArg08 + 56);
		if (cx_45 != 0x00 || *((word32) dwArg08 + 48) != *((word32) dwArg04 + 0x0810))
		{
			Eq_4 ecx_57 = *((word32) dwArg08 + 48);
			Eq_4 edx_61 = *((word32) dwArg04 + 0x0810);
			Eq_4 ebx_63 = *((word32) dwArg08 + 0x0C);
			runtime.printlock(gs);
			runtime.printstring(gs);
			runtime.printpointer(gs);
			runtime.printstring(gs);
			word32 esi_681;
			runtime.printhex(esi, gs, ebx_63, 0x00, out esi_681);
			runtime.printstring(gs);
			runtime.printint(ebx_24_8, gs, (word32) cx_45);
			runtime.printstring(gs);
			runtime.printint(ebx_24_8, gs, ecx_57);
			runtime.printstring(gs);
			runtime.printint(ebx_24_8, gs, edx_61);
			runtime.printstring(gs);
			runtime.printunlock(gs);
			runtime.throw(gs);
		}
		up32 ecx_161 = *((word32) dwArg04 + 2144) - *((word32) dwArg08 + 16);
		Eq_4 edx_163 = *((word32) dwArg04 + 0x0864);
		*((word32) dwArg04 + 2144) = ecx_161;
		*((word32) dwArg04 + 0x0864) = edx_163 - (ecx_161 < 0x00);
	}
	else
	{
		if (cl_19 != 0x02)
			runtime.throw(gs);
		if (*((word32) dwArg08 + 56) != 0x00)
			runtime.throw(gs);
	}
	if (bArg0C != 0x00)
	{
		Eq_4 ecx_180 = g_t81581C8 - (*((word32) dwArg08 + 16) << 0x0D);
		uint32 edx_182 = g_dw81581CC;
		g_t81581C8 = ecx_180;
		g_dw81581CC = edx_182 - (ecx_180 < 0x00);
	}
	if (bArg0D != 0x00)
	{
		uint32 ecx_199 = g_dw81581C0 + (*((word32) dwArg08 + 16) << 0x0D);
		uint32 edx_201 = g_dw81581C4;
		g_dw81581C0 = ecx_199;
		g_dw81581C4 = (uint32) ((bool) (ecx_199 < 0x00) + edx_201);
	}
	((word32) dwArg08 + 60)->u0 = 0x03;
	if (*((word32) dwArg08 + 8) != 0x00)
	{
		Eq_4 ecx_222;
		Eq_4 ecx_213 = *((word32) dwArg08 + 16);
		if (ecx_213 < 0x80)
			ecx_222 = (word32) dwArg04 + 0x0408 + ecx_213 * 0x08;
		else
			ecx_222 = (word32) dwArg04 + 0x0808;
		runtime.(*mSpanList).remove(gs, ecx_222, dwArg08);
		dwLoc20 = ecx_222;
		dwLoc1C = dwArg08;
	}
	*((word32) dwArg08 + 0x0044) = dwArg10;
	*((word32) dwArg08 + 72) = dwArg14;
	if (((int8) (dwArg14 == 0x00) & (int8) (dwArg10 == 0x00)) != 0x00)
	{
		runtime.nanotime();
		*((word32) dwArg08 + 0x0044) = dwLoc20;
		*((word32) dwArg08 + 72) = dwLoc1C;
	}
	uint32 eax_289;
	((word32) dwArg08 + 76)->u0 = 0x00;
	uint32 ebx_282 = *((word32) dwArg08 + 0x0C) - *((word32) dwArg04 + 0x0AC8);
	if (ebx_282 >> 0x0D > 0x00)
	{
		struct Eq_34192 * edx_290 = *((word32) dwArg04 + 0x0828);
		if ((ebx_282 >> 0x0D) - 0x01 >= *((word32) dwArg04 + 2092))
			runtime.panicindex(gs);
		Eq_4 edx_301 = (edx_290 - 0x04)[ebx_282 >> 0x0D];
		if (edx_301 != 0x00)
		{
			if (*((word32) edx_301 + 60) == 0x03)
			{
				*((word32) dwArg08 + 0x0C) = *((word32) edx_301 + 0x0C);
				Mem324[dwArg08 + 0x10:word32] = Mem320[dwArg08 + 0x10:word32] + Mem320[edx_301 + 0x10:word32];
				*((word32) dwArg08 + 76) = *((word32) edx_301 + 76);
				*((word32) dwArg08 + 61) = *((word32) edx_301 + 61) | *((word32) dwArg08 + 61);
				uint32 ebx_338 = (ebx_282 >> 0x0D) - *((word32) edx_301 + 16);
				struct Eq_34192 * esi_340 = *((word32) dwArg04 + 0x0828);
				if (ebx_338 >= *((word32) dwArg04 + 2092))
					runtime.panicindex(gs);
				esi_340[ebx_338 * 0x04] = (struct Eq_34192) dwArg08;
				Eq_4 ebp_350 = *((word32) edx_301 + 16);
				if (ebp_350 >= 0x80)
					runtime.(*mTreap).removeSpan(gs, (word32) dwArg04 + 0x0404, edx_301);
				else
					runtime.(*mSpanList).remove(gs, (word32) dwArg04 + 4 + ebp_350 * 0x08, edx_301);
				((word32) edx_301 + 60)->u0 = 0x00;
				*((word32) dwArg04 + 11384) -= *((word32) dwArg04 + 11360);
				*edx_301 = *((word32) dwArg04 + 0x00002C6C);
				*((word32) dwArg04 + 0x00002C6C) = edx_301;
				eax_289 = ebx_338;
			}
			else
				eax_289 = ebx_282 >> 0x0D;
		}
		else
			eax_289 = ebx_282 >> 0x0D;
	}
	else
		eax_289 = ebx_282 >> 0x0D;
	Eq_4 ebx_387 = *((word32) dwArg08 + 16);
	uint32 ebp_389 = (word32) ebx_387 + eax_289;
	struct Eq_34192 * esi_391 = *((word32) dwArg04 + 0x0828);
	if (ebp_389 < *((word32) dwArg04 + 2092))
	{
		Eq_4 ebp_395 = esi_391[ebp_389 * 0x04];
		if (ebp_395 != 0x00 && *((word32) ebp_395 + 60) == 0x03)
		{
			Mem411[dwArg08 + 0x10:word32] = ebx_387 + Mem385[ebp_395 + 0x10:word32];
			Mem415[dwArg08 + 0x4C:word32] = Mem411[dwArg08 + 0x4C:word32] + Mem411[ebp_395 + 0x4C:word32];
			*((word32) dwArg08 + 61) = *((word32) ebp_395 + 61) | *((word32) dwArg08 + 61);
			struct Eq_34192 * esi_427 = *((word32) dwArg04 + 0x0828);
			uint32 eax_429 = *((word32) dwArg08 + 16) - 0x01 + eax_289;
			if (eax_429 >= *((word32) dwArg04 + 2092))
				runtime.panicindex(gs);
			esi_427[eax_429 * 0x04] = (struct Eq_34192) dwArg08;
			Eq_4 eax_440 = *((word32) ebp_395 + 16);
			if (eax_440 >= 0x80)
				runtime.(*mTreap).removeSpan(gs, (word32) dwArg04 + 0x0404, ebp_395);
			else
				runtime.(*mSpanList).remove(gs, (word32) dwArg04 + 4 + eax_440 * 0x08, ebp_395);
			((word32) ebp_395 + 60)->u0 = 0x00;
			*((word32) dwArg04 + 11384) -= *((word32) dwArg04 + 11360);
			*ebp_395 = *((word32) dwArg04 + 0x00002C6C);
			*((word32) dwArg04 + 0x00002C6C) = ebp_395;
		}
	}
	Eq_4 edx_476 = *((word32) dwArg08 + 16);
	if (edx_476 >= 0x80)
		runtime.(*mTreap).insert(gs, (word32) dwArg04 + 0x0404, dwArg08);
	else
		runtime.(*mSpanList).insert(gs, (word32) dwArg04 + 4 + edx_476 * 0x08, dwArg08);
}

// 08066330: void runtime.scavengeTreapNode(Register up32 ebp, Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_25797) dwArg04, Stack Eq_25798 qwArg08, Stack up32 dwArg10, Stack up32 dwArg14)
// Called from:
//      runtime.scavengetreap
void runtime.scavengeTreapNode(up32 ebp, struct Eq_2 * gs, struct Eq_25797 * dwArg04, Eq_25798 qwArg08, up32 dwArg10, up32 dwArg14)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	struct Eq_36062 * eax_18 = dwArg04->ptr0010;
	ui64 ebx_edx_150 = qwArg08 - SEQ(ecx_23, eax_18->dw0044);
	up32 ebx_26 = SLICE(ebx_edx_150, word32, 32);
	ui32 ecx_23 = eax_18->dw0048;
	if (((int8) (ebx_26 > dwArg14) | (int8) (ebx_26 == dwArg14) & (int8) ((word32) ebx_edx_150 > dwArg10)) == 0x00)
		return;
	uint32 ecx_60 = eax_18->dw004C;
	uint32 edx_61 = eax_18->dw0010;
	if (ecx_60 == edx_61)
		return;
	uint32 esi_73;
	uint32 ebx_68 = eax_18->dw000C;
	uint32 edx_69 = (edx_61 << 0x0D) + ebx_68;
	Eq_4 ebp_70 = runtime.physPageSize;
	if (ebp_70 > 0x2000)
	{
		uint32 ebx_79 = ~(ebp_70 - 0x01);
		ebx_68 = (word32) ebp_70 + (ebx_68 - 0x01) & ebx_79;
		esi_73 = ebx_79 & edx_69;
		if (esi_73 <= ebx_68)
			return;
	}
	else
		esi_73 = edx_69;
	uint32 esi_92 = esi_73 - ebx_68;
	uint32 esi_96 = esi_92 - (ecx_60 << 0x0D);
	if (ebp_70 > 0x2000 && esi_96 == 0x00)
		return;
	uint32 ecx_111 = g_dw81581D0 + esi_96;
	uint32 ebp_113 = g_dw81581D4;
	g_dw81581D0 = ecx_111;
	g_dw81581D4 = (uint32) ((bool) (ecx_111 < 0x00) + ebp_113);
	eax_18->dw004C = esi_92 >> 0x0D;
	runtime.sysUnused(gs, ebx_68, esi_92);
}

// 08066450: Register uint32 runtime.scavengelist(Register uint32 edi, Register (ptr32 Eq_2) gs, Stack (ptr32 (ptr32 Eq_36172)) dwArg04, Stack Eq_25798 qwArg08, Stack up32 dwArg10, Stack up32 dwArg14)
// Called from:
//      runtime.(*mheap).scavenge
uint32 runtime.scavengelist(uint32 edi, struct Eq_2 * gs, struct Eq_36172 ** dwArg04, Eq_25798 qwArg08, up32 dwArg10, up32 dwArg14)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	struct Eq_36172 * eax_156 = *dwArg04;
	if (eax_156 == null)
		return edi;
	for (; eax_156 != null; eax_156 = eax_156->ptr0000)
	{
		ui64 esi_ebx_169 = qwArg08 - SEQ(edx_42, eax_156->dw0044);
		up32 ebx_40 = (word32) esi_ebx_169;
		up32 esi_45 = SLICE(esi_ebx_169, word32, 32);
		ui24 ebx_24_8_63 = SLICE(ebx_40, word24, 8);
		edi = SEQ(SLICE(edi, word24, 8), (int8) (esi_45 == dwArg14)) & SEQ(ebx_24_8_63, (int8) (ebx_40 > dwArg10));
		ui32 edx_42 = eax_156->dw0048;
		if (((int8) (esi_45 > dwArg14) | (byte) edi) != 0x00)
		{
			uint32 ebx_76 = eax_156->dw004C;
			uint32 esi_77 = eax_156->dw0010;
			if (ebx_76 == esi_77)
				goto l08066555;
			uint32 edx_87;
			edi = eax_156->dw000C;
			uint32 esi_83 = (esi_77 << 0x0D) + edi;
			Eq_4 ebp_84 = runtime.physPageSize;
			if (ebp_84 > 0x2000)
			{
				uint32 edx_90 = ~(ebp_84 - 0x01);
				edi = (word32) ebp_84 + (edi - 0x01) & edx_90;
				edx_87 = edx_90 & esi_83;
				if (edx_87 > edi)
					goto l080664F7;
				goto l0806647B;
			}
			edx_87 = esi_83;
l080664F7:
			uint32 edx_100 = edx_87 - edi;
			uint32 edx_104 = edx_100 - (ebx_76 << 0x0D);
			if (ebp_84 > 0x2000 && edx_104 == 0x00)
				goto l0806647B;
			uint32 ecx_115 = g_dw81581D0 + edx_104;
			uint32 ebx_117 = g_dw81581D4;
			g_dw81581D0 = ecx_115;
			g_dw81581D4 = (uint32) ((bool) (ecx_115 < 0x00) + ebx_117);
			eax_156->dw004C = edx_100 >> 0x0D;
			runtime.sysUnused(gs, edi, edx_100);
		}
l08066555:
l0806647B:
	}
	return edi;
}

// 08066590: void runtime.(*mheap).scavenge(Register Eq_4 esi, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_36279 dwArg08, Stack Eq_25798 qwArg0C, Stack up32 dwArg14, Stack up32 dwArg18)
// Called from:
//      runtime.sysmon
void runtime.(*mheap).scavenge(Eq_4 esi, struct Eq_2 * gs, Eq_4 dwArg04, Eq_36279 dwArg08, Eq_25798 qwArg0C, up32 dwArg14, up32 dwArg18)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 eax_18 = gs->ptr0000->tFFFFFFFC;
	Eq_4 ecx_20 = *((word32) eax_18 + 24);
	*((word32) ecx_20 + 0x0068) = (word32) *((word32) ecx_20 + 0x0068) + 1;
	word32 esi_539;
	uint32 edi_36;
	runtime.lock(esi, gs, dwArg04, out esi_539, out edi_36);
	Eq_36319 eax_42 = 0x00;
	word32 ecx_428 = 0x00;
	while (eax_42 < 0x80)
	{
		if (eax_42 >= 0x80)
			runtime.panicindex(gs);
		edi_36 = runtime.scavengelist(edi_36, gs, (word32) dwArg04 + 4 + eax_42 * 0x08, qwArg0C, dwArg14, dwArg18);
		eax_42 = (word32) eax_42 + 1;
		ecx_428 = dwLoc38 + ecx_428;
	}
	runtime.scavengetreap(gs, *((word32) dwArg04 + 0x0404), qwArg0C, dwArg14, dwArg18);
	word32 edx_540;
	word32 ebx_79;
	runtime.unlock(gs, dwArg04, out edx_540, out ebx_79);
	Eq_4 eax_88 = *((word32) eax_18 + 24);
	--*((word32) eax_88 + 0x0068);
	word24 ebx_24_8_124 = SLICE(ebx_79, word24, 8);
	uint32 eax_94 = dwLoc38 + ecx_428;
	if (g_dw8157740 > 0x00)
	{
		if (eax_94 > 0x00)
		{
			runtime.printlock(gs);
			runtime.printstring(gs);
			runtime.printint(ebx_24_8_124, gs, SEQ(dwArg08 >> 0x1F, dwArg08));
			runtime.printstring(gs);
			runtime.printint(ebx_24_8_124, gs, (uint64) (eax_94 >> 0x14));
			runtime.printstring(gs);
			runtime.printunlock(gs);
		}
		Eq_4 eax_172 = g_t81581B8;
		uint32 ecx_175 = g_dw81581D0;
		uint32 ebx_180 = g_dw81581CC;
		Eq_4 ebp_182 = g_t81581C8;
		uint32 esi_184 = g_dw81581C4;
		uint32 edi_186 = g_dw81581C0;
		Eq_4 eax_188 = g_t81581BC;
		uint32 ecx_190 = g_dw81581D4;
		runtime.printlock(gs);
		runtime.printstring(gs);
		runtime.printint(SLICE(ebx_180, word24, 8), gs, SEQ(dwArg08 >> 0x1F, dwArg08));
		runtime.printstring(gs);
		Eq_4 ebp_243 = runtime.printuint(ebp_182, gs, ebx_180 << 0x0C | ebp_182 >> 0x14, ebx_180 >> 0x14);
		runtime.printstring(gs);
		Eq_4 ebp_273 = runtime.printuint(ebp_243, gs, esi_184 << 0x0C | edi_186 >> 0x14, esi_184 >> 0x14);
		runtime.printstring(gs);
		Eq_4 ebp_303 = runtime.printuint(ebp_273, gs, eax_188 << 0x0C | eax_172 >> 0x14, eax_188 >> 0x14);
		runtime.printstring(gs);
		Eq_4 ebp_333 = runtime.printuint(ebp_303, gs, ecx_190 << 0x0C | ecx_175 >> 0x14, ecx_190 >> 0x14);
		runtime.printstring(gs);
		uint32 eax_359 = SLICE(SEQ(eax_188, eax_172) - SEQ(ecx_190, ecx_175), word32, 32);
		runtime.printuint(ebp_333, gs, eax_359 << 0x0C | eax_172 - ecx_175 >> 0x14, eax_359 >> 0x14);
		runtime.printstring(gs);
		runtime.printunlock(gs);
	}
}

// 08066900: void runtime.(*mSpanList).remove(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
// Called from:
//      runtime.(*mcentral).cacheSpan
//      runtime.(*mcentral).uncacheSpan
//      runtime.(*mcentral).freeSpan
//      runtime.getempty
//      runtime.(*mheap).reclaimList
//      runtime.(*mheap).allocSpanLocked
//      runtime.(*mheap).freeSpanLocked
//      runtime.stackpoolalloc
//      runtime.stackpoolfree
//      runtime.stackalloc
//      runtime.freeStackSpans
//      runtime.freeSomeWbufs.func1
void runtime.(*mSpanList).remove(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (*((word32) dwArg08 + 8) != dwArg04)
	{
		Eq_4 ecx_23 = *((word32) dwArg08 + 16);
		runtime.printlock(gs);
		runtime.printstring(gs);
		runtime.printint(SLICE(ebx, word24, 8), gs, ecx_23);
		runtime.printstring(gs);
		runtime.printpointer(gs);
		runtime.printstring(gs);
		runtime.printpointer(gs);
		runtime.printstring(gs);
		runtime.printpointer(gs);
		runtime.printstring(gs);
		runtime.printpointer(gs);
		runtime.printstring(gs);
		runtime.printunlock(gs);
		runtime.throw(gs);
	}
	else
	{
		if (*dwArg04 == dwArg08)
			*dwArg04 = *dwArg08;
		else
			**((word32) dwArg08 + 4) = *dwArg08;
		if (dwArg08 == *((word32) dwArg04 + 4))
			*((word32) dwArg04 + 4) = *((word32) dwArg08 + 4);
		else
			*((word32) *dwArg08 + 4) = *((word32) dwArg08 + 4);
		dwArg08->u0 = 0x00;
		((word32) dwArg08 + 4)->u0 = 0x00;
		((word32) dwArg08 + 8)->u0 = 0x00;
	}
}

// 08066A70: void runtime.(*mSpanList).insert(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
// Called from:
//      runtime.(*mcentral).uncacheSpan
//      runtime.(*mcentral).freeSpan
//      runtime.getempty
//      runtime.(*mheap).freeSpanLocked
//      runtime.stackpoolalloc
//      runtime.stackpoolfree
//      runtime.stackfree
void runtime.(*mSpanList).insert(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (*dwArg08 != 0x00 || (*((word32) dwArg08 + 4) != 0x00 || *((word32) dwArg08 + 8) != 0x00))
	{
		runtime.printlock(gs);
		runtime.printstring(gs);
		runtime.printsp(gs);
		runtime.printpointer(gs);
		runtime.printsp(gs);
		runtime.printpointer(gs);
		runtime.printsp(gs);
		runtime.printpointer(gs);
		runtime.printsp(gs);
		runtime.printpointer(gs);
		runtime.printnl(gs);
		runtime.printunlock(gs);
		runtime.throw(gs);
	}
	else
	{
		*dwArg08 = *dwArg04;
		Eq_4 edx_108 = *dwArg04;
		if (edx_108 != 0x00)
			*((word32) edx_108 + 4) = dwArg08;
		else
			*((word32) dwArg04 + 4) = dwArg08;
		*dwArg04 = dwArg08;
		*((word32) dwArg08 + 8) = dwArg04;
	}
}

// 08066B60: void runtime.(*mSpanList).insertBack(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
// Called from:
//      runtime.(*mcentral).cacheSpan
//      runtime.(*mheap).reclaimList
//      runtime.(*mheap).alloc_m
void runtime.(*mSpanList).insertBack(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (*dwArg08 != 0x00 || (*((word32) dwArg08 + 4) != 0x00 || *((word32) dwArg08 + 8) != 0x00))
	{
		runtime.printlock(gs);
		runtime.printstring(gs);
		runtime.printsp(gs);
		runtime.printpointer(gs);
		runtime.printsp(gs);
		runtime.printpointer(gs);
		runtime.printsp(gs);
		runtime.printpointer(gs);
		runtime.printsp(gs);
		runtime.printpointer(gs);
		runtime.printnl(gs);
		runtime.printunlock(gs);
		runtime.throw(gs);
	}
	else
	{
		*((word32) dwArg08 + 4) = *((word32) dwArg04 + 4);
		Eq_4 edx_136 = *((word32) dwArg04 + 4);
		if (edx_136 != 0x00)
			*edx_136 = dwArg08;
		else
			*dwArg04 = dwArg08;
		*((word32) dwArg04 + 4) = dwArg08;
		*((word32) dwArg08 + 8) = dwArg04;
	}
}

// 08066C50: void runtime.(*mSpanList).takeAll(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_33495) dwArg04, Stack (ptr32 Eq_33496) dwArg08)
// Called from:
//      runtime.prepareFreeWorkbufs
void runtime.(*mSpanList).takeAll(struct Eq_2 * gs, struct Eq_33495 * dwArg04, struct Eq_33496 * dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	struct Eq_36762 * ecx_17 = dwArg08->ptr0000;
	if (ecx_17 == null)
		return;
	for (; ecx_17 != null; ecx_17 = ecx_17->ptr0000)
		ecx_17->ptr0008 = dwArg04;
	struct Eq_36762 * ecx_30 = dwArg04->ptr0000;
	if (ecx_30 != null)
	{
		dwArg08->ptr0004->ptr0000 = ecx_30;
		dwArg04->ptr0000->ptr0004 = dwArg08->ptr0004;
		dwArg04->ptr0000 = dwArg08->ptr0000;
	}
	else
	{
		struct Eq_36782 * ecx_35 = dwArg08->ptr0004;
		dwArg04->ptr0000 = dwArg08->ptr0000;
		dwArg04->ptr0004 = ecx_35;
	}
	dwArg08->ptr0000 = null;
	dwArg08->ptr0004 = null;
}

// 08066CC0: Register word32 runtime.addspecial(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
// Called from:
//      runtime.addfinalizer
//      runtime.setprofilebucket
word32 runtime.addspecial(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	struct Eq_31495 * ecx_32;
	Eq_4 edx_19 = g_t81493A8;
	if (dwArg04 < edx_19 || dwArg04 >= g_t81493AC)
		ecx_32 = null;
	else
	{
		Eq_4 ebx_25 = g_t8149108;
		uint32 ecx_28 = dwArg04 - edx_19;
		if (ecx_28 >> 0x0D >= g_t814910C)
			runtime.panicindex(gs);
		ecx_32 = (struct Eq_31495 *) *((word32) ebx_25 + (ecx_28 >> 0x0D) * 0x04);
		if (ecx_32 == null || (dwArg04 < ecx_32->t000C || (dwArg04 >= ecx_32->t0050 || ecx_32->b003C != 0x01)))
			ecx_32 = null;
	}
	if (ecx_32 == null)
		runtime.throw(gs);
	else
	{
		Eq_4 eax_73 = gs->ptr0000->tFFFFFFFC;
		Eq_4 edx_74 = *((word32) eax_73 + 24);
		*((word32) edx_74 + 0x0078) = (word32) *((word32) edx_74 + 0x0078) + 1;
		Eq_4 eax_79 = *((word32) eax_73 + 24);
		runtime.(*mspan).ensureSwept(gs, dwLoc24, ecx_32, dwLoc1C);
		cu8 dl_107 = *((word32) dwArg08 + 6);
		Eq_4 esi_112 = ecx_32->t000C;
		word32 edi_417;
		word32 esi_121;
		runtime.lock(esi_112, gs, (char *) &ecx_32->t0050 + 4, out esi_121, out edi_417);
		Eq_4 dwLoc04_398 = (char *) &ecx_32->t0050 + 4;
		up32 eax_128 = dwArg04 - esi_112;
		Eq_4 ecx_130 = (char *) &ecx_32->t0050 + 8;
		while (true)
		{
			Eq_4 ax_211 = (word16) eax_128;
			Eq_4 ebx_135 = *ecx_130;
			if (ebx_135 == 0x00)
				break;
			up32 ebp_139 = (word32) *((word32) ebx_135 + 4);
			bool v35_260 = eax_128 != ebp_139;
			bool v38_263 = eax_128 < ebp_139;
			if (eax_128 == ebp_139)
			{
				word32 esi_143 = (word32) *((word32) ebx_135 + 6);
				esi_121 = esi_143;
				if (dl_107 == (byte) esi_143)
				{
					word32 ebx_421;
					word32 edx_420;
					runtime.unlock(gs, dwLoc04_398, out edx_420, out ebx_421);
					Eq_4 eax_168 = gs->ptr0000->tFFFFFFFC;
					Eq_4 edx_170 = *((word32) eax_79 + 0x0078);
					*((word32) eax_79 + 0x0078) = edx_170 - 0x01;
					if (edx_170 == 0x01 && *((word32) eax_168 + 0x006C) != 0x00)
						((word32) eax_168 + 8)->u0 = ~0x0521;
					return esi_143;
				}
				v38_263 = eax_128 < ebp_139;
				v35_260 = eax_128 != ebp_139;
			}
			ax_211 = (word16) eax_128;
			if (v38_263)
				break;
			if (!v35_260)
			{
				ax_211 = (word16) eax_128;
				if (dl_107 < *((word32) ebx_135 + 6))
					break;
			}
			ecx_130 = ebx_135;
		}
		*((word32) dwArg08 + 4) = ax_211;
		*dwArg08 = *ecx_130;
		*ecx_130 = dwArg08;
		word32 edx_418;
		word32 ebx_419;
		runtime.unlock(gs, dwLoc04_398, out edx_418, out ebx_419);
		Eq_4 eax_235 = gs->ptr0000->tFFFFFFFC;
		Eq_4 edx_237 = *((word32) eax_79 + 0x0078);
		*((word32) eax_79 + 0x0078) = edx_237 - 0x01;
		if (edx_237 == 0x01 && *((word32) eax_235 + 0x006C) != 0x00)
			((word32) eax_235 + 8)->u0 = ~0x0521;
		return esi_121;
	}
}

// 08066EA0: Register word32 runtime.removespecial(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack byte bArg08)
// Called from:
//      runtime.removefinalizer
word32 runtime.removespecial(struct Eq_2 * gs, Eq_4 dwArg04, byte bArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	struct Eq_31495 * ecx_32;
	Eq_4 edx_19 = g_t81493A8;
	if (dwArg04 < edx_19 || dwArg04 >= g_t81493AC)
		ecx_32 = null;
	else
	{
		Eq_4 ebx_25 = g_t8149108;
		uint32 ecx_28 = dwArg04 - edx_19;
		if (ecx_28 >> 0x0D >= g_t814910C)
			runtime.panicindex(gs);
		ecx_32 = (struct Eq_31495 *) *((word32) ebx_25 + (ecx_28 >> 0x0D) * 0x04);
		if (ecx_32 == null || (dwArg04 < ecx_32->t000C || (dwArg04 >= ecx_32->t0050 || ecx_32->b003C != 0x01)))
			ecx_32 = null;
	}
	if (ecx_32 == null)
		runtime.throw(gs);
	else
	{
		Eq_4 eax_73 = gs->ptr0000->tFFFFFFFC;
		Eq_4 edx_74 = *((word32) eax_73 + 24);
		*((word32) edx_74 + 0x0078) = (word32) *((word32) edx_74 + 0x0078) + 1;
		Eq_4 eax_79 = *((word32) eax_73 + 24);
		Eq_4 esi_90 = runtime.(*mspan).ensureSwept(gs, dwLoc24, ecx_32, dwLoc1C);
		Eq_4 ebx_108 = ecx_32->t000C;
		word32 esi_117;
		word32 edi_346;
		runtime.lock(esi_90, gs, (char *) &ecx_32->t0050 + 4, out esi_117, out edi_346);
		Eq_4 dwLoc04_328 = (char *) &ecx_32->t0050 + 4;
		up32 eax_124 = dwArg04 - ebx_108;
		struct Eq_37114 * ecx_126 = (char *) &ecx_32->t0050 + 8;
		while (true)
		{
			struct Eq_37114 * ebx_131 = ecx_126->ptr0000;
			if (ebx_131 == null)
				break;
			if ((word32) ebx_131->w0004 == eax_124 && bArg08 == ebx_131->b0006)
			{
				ecx_126->ptr0000 = ebx_131->ptr0000;
				word32 edx_349;
				word32 ebx_350;
				runtime.unlock(gs, dwLoc04_328, out edx_349, out ebx_350);
				Eq_4 eax_198 = gs->ptr0000->tFFFFFFFC;
				Eq_4 edx_200 = *((word32) eax_79 + 0x0078);
				*((word32) eax_79 + 0x0078) = edx_200 - 0x01;
				if (edx_200 == 0x01 && *((word32) eax_198 + 0x006C) != 0x00)
					((word32) eax_198 + 8)->u0 = ~0x0521;
				return;
			}
			ecx_126 = ebx_131;
		}
		word32 edx_347;
		word32 ebx_348;
		runtime.unlock(gs, dwLoc04_328, out edx_347, out ebx_348);
		Eq_4 eax_149 = gs->ptr0000->tFFFFFFFC;
		Eq_4 edx_151 = *((word32) eax_79 + 0x0078);
		*((word32) eax_79 + 0x0078) = edx_151 - 0x01;
		if (edx_151 == 0x01 && *((word32) eax_149 + 0x006C) != 0x00)
			((word32) eax_149 + 8)->u0 = ~0x0521;
		return;
	}
}

// 08067070: void runtime.addfinalizer(Register Eq_4 esi, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C, Stack Eq_4 dwArg10, Stack Eq_4 dwArg14)
// Called from:
//      runtime.SetFinalizer.func2
void runtime.addfinalizer(Eq_4 esi, struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C, Eq_4 dwArg10, Eq_4 dwArg14)
{
	byte bLoc1C = (byte) dwLoc1C;
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	word32 esi_418;
	word32 edi_419;
	runtime.lock(esi, gs, 135575028, out esi_418, out edi_419);
	runtime.(*fixalloc).alloc(gs, &g_dw814B5AC);
	word32 edx_420;
	word32 ebx_421;
	runtime.unlock(gs, 135575028, out edx_420, out ebx_421);
	((word32) dwLoc20 + 6)->u1 = 0x01;
	if (g_t81576F0 == 0x00)
		*((word32) dwLoc20 + 8) = dwArg08;
	else
		runtime.writebarrierptr((word32) dwLoc20 + 8, dwArg08);
	*((word32) dwLoc20 + 0x0C) = dwArg0C;
	if (g_t81576F0 == 0x00)
	{
		*((word32) dwLoc20 + 16) = dwArg10;
		*((word32) dwLoc20 + 20) = dwArg14;
	}
	else
	{
		runtime.writebarrierptr((word32) dwLoc20 + 16, dwArg10);
		runtime.writebarrierptr((word32) dwLoc20 + 20, dwArg14);
	}
	Eq_4 esi_133 = runtime.addspecial(gs, dwArg04, dwLoc20);
	if (bLoc1C == 0x00)
	{
		word32 edi_423;
		word32 esi_422;
		runtime.lock(esi_133, gs, 135575028, out esi_422, out edi_423);
		g_dw814B5C4 -= g_dw814B5AC;
		*dwLoc20 = g_t814B5B8;
		g_t814B5B8 = dwLoc20;
		word32 edx_424;
		word32 ebx_425;
		runtime.unlock(gs, 135575028, out edx_424, out ebx_425);
	}
	else if (runtime.gcphase != 0x00)
	{
		runtime.findObject(esi_133, gs, dwArg04);
		Eq_4 eax_210 = gs->ptr0000->tFFFFFFFC;
		Eq_4 ecx_211 = *((word32) eax_210 + 24);
		*((word32) ecx_211 + 0x0078) = (word32) *((word32) ecx_211 + 0x0078) + 1;
		Eq_4 ecx_216 = *((word32) eax_210 + 24);
		Eq_4 ebx_218 = *((word32) ecx_216 + 92);
		word32 ebp_426;
		runtime.scanobject(gs, dwLoc1C, (word32) ebx_218 + 0x0950, out ebp_426);
		Eq_4 ebp_247;
		word32 esi_427;
		ui24 ebx_24_8_264 = SLICE(runtime.scanblock(gs, (word32) dwLoc20 + 8, 0x04, 0x08136000, (word32) ebx_218 + 0x0950, out ebp_247, out esi_427), word24, 8);
		if (g_t815756D != 0x00)
			runtime.(*gcWork).dispose(ebx_24_8_264, ebp_247, gs, dwLoc28, (word32) ebx_218 + 0x0950);
		Eq_4 eax_277 = gs->ptr0000->tFFFFFFFC;
		Eq_4 edx_280 = *((word32) ecx_216 + 0x0078);
		*((word32) ecx_216 + 0x0078) = edx_280 - 0x01;
		if (edx_280 == 0x01 && *((word32) eax_277 + 0x006C) != 0x00)
			((word32) eax_277 + 8)->u0 = ~0x0521;
	}
}

// 080672B0: void runtime.removefinalizer(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      runtime.SetFinalizer.func1
void runtime.removefinalizer(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 esi_27 = runtime.removespecial(gs, dwArg04, 0x01);
	if (dwLoc08 == 0x00)
		return;
	word32 edi_127;
	word32 esi_126;
	runtime.lock(esi_27, gs, 135575028, out esi_126, out edi_127);
	g_dw814B5C4 -= g_dw814B5AC;
	*dwLoc08 = g_t814B5B8;
	g_t814B5B8 = dwLoc08;
	word32 ebx_129;
	word32 edx_128;
	runtime.unlock(gs, 135575028, out edx_128, out ebx_129);
}

// 08067340: void runtime.setprofilebucket(Register Eq_4 esi, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
// Called from:
//      runtime.mProf_Malloc.func1
void runtime.setprofilebucket(Eq_4 esi, struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	word32 esi_122;
	word32 edi_123;
	runtime.lock(esi, gs, 135575028, out esi_122, out edi_123);
	runtime.(*fixalloc).alloc(gs, &g_dw814B5D0);
	word32 edx_124;
	word32 ebx_125;
	runtime.unlock(gs, 135575028, out edx_124, out ebx_125);
	((word32) dwLoc0C + 6)->u1 = 0x02;
	*((word32) dwLoc0C + 8) = dwArg08;
	runtime.addspecial(gs, dwArg04, dwLoc0C);
	if (bLoc08 != 0x00)
		return;
	runtime.throw(gs);
}

// 080673E0: void runtime.freespecial(Register Eq_4 esi, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C)
// Called from:
//      runtime.(*mspan).sweep
void runtime.freespecial(Eq_4 esi, struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	cu8 cl_19 = *((word32) dwArg04 + 6);
	if (cl_19 == 0x01)
	{
		word32 esi_181;
		word32 edi_182;
		runtime.lock(runtime.queuefinalizer(esi, gs, dwArg08, *((word32) dwArg04 + 8), *((word32) dwArg04 + 0x0C), *((word32) dwArg04 + 16), *((word32) dwArg04 + 20)), gs, 135575028, out esi_181, out edi_182);
		g_dw814B5C4 -= g_dw814B5AC;
		*dwArg04 = g_t814B5B8;
		g_t814B5B8 = dwArg04;
		word32 edx_183;
		word32 ebx_184;
		runtime.unlock(gs, 135575028, out edx_183, out ebx_184);
	}
	else if (cl_19 != 0x02)
		runtime.throw(gs);
	else
	{
		word32 esi_185;
		word32 edi_186;
		runtime.lock(runtime.mProf_Free(esi, gs, *((word32) dwArg04 + 8), dwArg0C), gs, 135575028, out esi_185, out edi_186);
		g_dw814B5E8 -= g_dw814B5D0;
		*dwArg04 = g_t814B5DC;
		g_t814B5DC = dwArg04;
		word32 edx_187;
		word32 ebx_188;
		runtime.unlock(gs, 135575028, out edx_187, out ebx_188);
	}
}

// 08067510: void runtime.(*gcBitsArena).tryAlloc(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
// Called from:
//      runtime.newMarkBits
void runtime.(*gcBitsArena).tryAlloc(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (dwArg04 == 0x00)
		return;
	runtime/internal/atomic.Loaduintptr();
	if ((word32) dwArg08 + dwLoc08 > 0xFFF8)
		return;
	runtime/internal/atomic.Xadduintptr(dwArg04, dwArg08);
	if (dwArg08 > 0xFFF8)
		return;
	if (dwArg08 - dwArg04 < 0xFFF8)
		return;
	runtime.panicindex(gs);
}

// 080675B0: Register Eq_4 runtime.newMarkBits(Register Eq_4 esi, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      runtime.heapBits.initSpan
//      runtime.(*mspan).sweep
//      runtime.newAllocBits
Eq_4 runtime.newMarkBits(Eq_4 esi, struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime/internal/atomic.Loadp();
	uint32 eax_25 = (word32) dwArg04 + 63 >> 0x06;
	runtime.(*gcBitsArena).tryAlloc(gs, dwLoc1C, eax_25 << 0x03);
	if (dwLoc18 != 0x00)
		return esi;
	Eq_4 esi_56;
	word32 edi_265;
	runtime.lock(esi, gs, 0x081451C0, out esi_56, out edi_265);
	Eq_4 eax_61 = g_t81451C8;
	runtime.(*gcBitsArena).tryAlloc(gs, eax_61, eax_25 << 0x03);
	if (dwLoc18 != 0x00)
	{
		word32 edx_266;
		word32 ebx_267;
		runtime.unlock(gs, 0x081451C0, out edx_266, out ebx_267);
		return esi_56;
	}
	else
	{
		Eq_4 esi_100 = runtime.newArenaMayUnlock(gs);
		runtime.(*gcBitsArena).tryAlloc(gs, g_t81451C8, eax_25 << 0x03);
		if (dwLoc18 != 0x00)
		{
			*((word32) eax_61 + 4) = g_t81451C4;
			g_t81451C4 = eax_61;
			word32 edx_268;
			word32 ebx_269;
			runtime.unlock(gs, 0x081451C0, out edx_268, out ebx_269);
			return esi_100;
		}
		else
		{
			runtime.(*gcBitsArena).tryAlloc(gs, eax_61, eax_25 << 0x03);
			if (dwLoc18 == 0x00)
				runtime.throw(gs);
			else
			{
				*((word32) eax_61 + 4) = g_t81451C8;
				runtime/internal/atomic.StorepNoWB(0x081451C8, eax_61);
				word32 edx_270;
				word32 ebx_271;
				runtime.unlock(gs, 0x081451C0, out edx_270, out ebx_271);
				return esi_100;
			}
		}
	}
}

// 08067740: Register Eq_4 runtime.newAllocBits(Register Eq_4 esi, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      runtime.heapBits.initSpan
Eq_4 runtime.newAllocBits(Eq_4 esi, struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	return runtime.newMarkBits(esi, gs, dwArg04);
}

// 08067780: Register Eq_4 runtime.nextMarkBitArenaEpoch(Register Eq_4 esi, Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.finishsweep_m
Eq_4 runtime.nextMarkBitArenaEpoch(Eq_4 esi, struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	word32 edi_96;
	Eq_4 esi_28;
	runtime.lock(esi, gs, 0x081451C0, out esi_28, out edi_96);
	Eq_4 eax_33 = g_t81451D0;
	if (eax_33 != 0x00)
	{
		Eq_4 ecx_37 = g_t81451C4;
		if (ecx_37 == 0x00)
			g_t81451C4 = eax_33;
		else
		{
			while (true)
			{
				Eq_4 edx_43 = *((word32) eax_33 + 4);
				if (edx_43 == 0x00)
					break;
				eax_33 = edx_43;
			}
			*((word32) eax_33 + 4) = ecx_37;
			g_t81451C4 = g_t81451D0;
		}
	}
	g_t81451D0 = g_t81451CC;
	g_t81451CC = g_t81451C8;
	runtime/internal/atomic.StorepNoWB(0x081451C8, 0x00);
	word32 ebx_98;
	word32 edx_97;
	runtime.unlock(gs, 0x081451C0, out edx_97, out ebx_98);
	return esi_28;
}

// 08067830: Register word32 runtime.newArenaMayUnlock(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.newMarkBits
word32 runtime.newArenaMayUnlock(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 eax_73;
	Eq_4 eax_17 = g_t81451C4;
	if (eax_17 != 0x00)
	{
		g_t81451C4 = *((word32) eax_17 + 4);
		runtime.memclrNoHeapPointers(eax_17, 0x00010000);
		eax_73 = eax_17;
	}
	else
	{
		word32 ebx_128;
		word32 edx_127;
		runtime.unlock(gs, 0x081451C0, out edx_127, out ebx_128);
		Eq_4 esi_41 = runtime.sysAlloc();
		if (dwLoc0C == 0x00)
			runtime.throw(gs);
		word32 edi_129;
		runtime.lock(esi_41, gs, 0x081451C0, out esi, out edi_129);
		eax_73 = dwLoc0C;
	}
	((word32) eax_73 + 4)->u0 = 0x00;
	*eax_73 = 0x00;
	return esi;
}

// 080678F0: void runtime.newBucket(Register (ptr32 Eq_2) gs, Stack up32 dwArg04, Stack Eq_4 dwArg08)
// Called from:
//      runtime.stkbucket
void runtime.newBucket(struct Eq_2 * gs, up32 dwArg04, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	ui32 eax_32;
	if (dwArg04 == 0x01)
		eax_32 = (dwArg08 << 0x02) + 88;
	else
	{
		if (dwArg04 > 0x03)
			runtime.throw(gs);
		eax_32 = (dwArg08 << 0x02) + 0x28;
	}
	runtime.persistentalloc(gs);
	runtime.bucketmem += eax_32;
	dwLoc08->dw0008 = dwArg04;
	dwLoc08->t0014 = dwArg08;
}

// 080679A0: void runtime.(*bucket).mp(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      runtime.mProf_FlushLocked
//      runtime.mProf_Malloc
//      runtime.mProf_Free
void runtime.(*bucket).mp(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (*((word32) dwArg04 + 8) == 0x01)
		return;
	runtime.throw(gs);
}

// 080679F0: void runtime.(*bucket).bp(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_37960) dwArg04)
// Called from:
//      runtime.saveblockevent
void runtime.(*bucket).bp(struct Eq_2 * gs, struct Eq_37960 * dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	word32 ecx_17 = dwArg04->dw0008;
	if (ecx_17 == 0x02 || ecx_17 == 0x03)
		return;
	runtime.throw(gs);
}

// 08067A50: void runtime.stkbucket(Register (ptr32 Eq_2) gs, Stack up32 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C, Stack Eq_4 dwArg10, Stack byte bArg18)
// Called from:
//      runtime.mProf_Malloc
//      runtime.saveblockevent
void runtime.stkbucket(struct Eq_2 * gs, up32 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C, Eq_4 dwArg10, byte bArg18)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (runtime.buckhash == 0x00)
	{
		runtime.sysAlloc();
		if (g_t81576F0 == 0x00)
			runtime.buckhash = dwLoc20;
		else
			runtime.writebarrierptr(135548856, dwLoc20);
		if (runtime.buckhash == 0x00)
			runtime.throw(gs);
	}
	Eq_4 ecx_144 = dwArg10;
	Eq_4 edx_58 = dwArg0C;
	Eq_4 ebx_60 = 0x00;
	ui32 ebp_61 = 0x00;
	while (ebx_60 < dwArg10)
	{
		ui32 esi_74 = (word32) *edx_58 + ebp_61;
		edx_58 = (word32) edx_58 + 4;
		ebx_60 = (word32) ebx_60 + 1;
		ebp_61 = esi_74 * 0x0401 >> 0x06 ^ esi_74 * 0x0401;
	}
	ui32 ebp_89 = (word32) dwArg08 + ebp_61;
	ui32 esi_95 = ebp_89 * 0x0401 ^ ebp_89 * 0x0401 >> 0x06;
	Eq_4 ebp_99 = esi_95 * 0x09 >> 11 ^ esi_95 * 0x09;
	word32 edx_108 = (word32) ebp_99 + SLICE(ebp_99 *64 1960066937, word32, 32);
	Eq_4 edx_83 = runtime.buckhash;
	Eq_4 ebx_240 = dwArg08;
	Eq_4 esi_103 = dwArg0C;
	Eq_4 eax_115 = ebp_99;
	uint32 ebp_116 = ebp_99 - (__rcr(edx_108, 0x01, SLICE(cond(edx_108), bool, 1)) >> 0x11) *s 179999;
	if (ebp_116 >= 179999)
		runtime.panicindex(gs);
	else
	{
		struct Eq_38075 * edx_127;
		for (edx_127 = *((word32) edx_83 + ebp_116 * 0x04); edx_127 != null; edx_127 = edx_127->ptr0000)
		{
			if (edx_127->dw0008 == dwArg04 && (eax_115 == edx_127->t000C && ebx_240 == edx_127->t0010))
			{
				word32 * edi_244 = (char *) &edx_127->t0014 + 4;
				Eq_4 ebx_247 = edx_127->t0014;
				if (ebx_247 > 0x20)
					runtime.panicslice(gs);
				runtime.eqslice(gs, edi_244, ebx_247, esi_103, ecx_144);
				dwLoc20 = ebx_247;
				if (bLoc10 != 0x00)
					return;
				eax_115 = ebp_99;
				ecx_144 = dwArg10;
				ebx_240 = dwArg08;
				esi_103 = dwArg0C;
			}
		}
		if (bArg18 == 0x00)
			return;
		runtime.newBucket(gs, dwArg04, ecx_144);
		Eq_4 edx_156 = *((word32) dwLoc20 + 20);
		if (edx_156 > 0x20)
			runtime.panicslice(gs);
		else
		{
			Eq_4 ebx_164 = dwArg10;
			if (edx_156 <= dwArg10)
				ebx_164 = edx_156;
			word32 esi_518;
			word128 xmm0_520;
			word128 xmm1_521;
			word128 xmm2_522;
			word32 edi_519;
			word32 ebp_517;
			runtime.memmove((word32) dwLoc20 + 24, dwArg0C, ebx_164 << 0x02, out ebp_517, out esi_518, out edi_519, out xmm0_520, out xmm1_521, out xmm2_522);
			*((word32) dwLoc20 + 0x0C) = ebp_99;
			*((word32) dwLoc20 + 16) = dwArg08;
			*dwLoc20 = *((word32) runtime.buckhash + ebp_116 * 0x04);
			*((word32) runtime.buckhash + ebp_116 * 0x04) = dwLoc20;
			if (dwArg04 == 0x01)
			{
				*((word32) dwLoc20 + 4) = runtime.mbuckets;
				runtime.mbuckets = dwLoc20;
			}
			else if (dwArg04 == 0x03)
			{
				*((word32) dwLoc20 + 4) = runtime.xbuckets;
				runtime.xbuckets = dwLoc20;
			}
			else
			{
				*((word32) dwLoc20 + 4) = runtime.bbuckets;
				runtime.bbuckets = dwLoc20;
			}
		}
	}
}

// 08067CF0: void runtime.eqslice(Register (ptr32 Eq_2) gs, Stack (ptr32 word32) dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg10, Stack Eq_4 dwArg14)
// Called from:
//      runtime.stkbucket
void runtime.eqslice(struct Eq_2 * gs, word32 * dwArg04, Eq_4 dwArg08, Eq_4 dwArg10, Eq_4 dwArg14)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (dwArg08 != dwArg14)
		return;
	word32 * ebx_22 = dwArg04;
	Eq_4 ebp_23 = 0x00;
	while (ebp_23 < dwArg08)
	{
		word32 esi_34 = *ebx_22;
		if (ebp_23 >= dwArg14)
			runtime.panicindex(gs);
		if (esi_34 != *((word32) dwArg10 + ebp_23 * 0x04))
			return;
		++ebx_22;
		ebp_23 = (word32) ebp_23 + 1;
	}
}

// 08067D50: void runtime.mProf_NextCycle(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.gcMarkTermination
//      runtime.gcSweep
void runtime.mProf_NextCycle(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	word32 esi_54;
	word32 edi_55;
	runtime.lock(esi, gs, 135624236, out esi_54, out edi_55);
	uint32 eax_24 = g_dw8157688;
	uint32 edx_29 = SLICE((eax_24 + 0x01) *64 ~0x55555554, word32, 32);
	g_dw8157688 = eax_24 + 0x01 - ((edx_29 >> 0x1A) + (edx_29 >> 0x1A) * 0x02 << 0x19);
	g_b815768C = 0x00;
	word32 edx_56;
	word32 ebx_57;
	runtime.unlock(gs, 135624236, out edx_56, out ebx_57);
}

// 08067DC0: void runtime.mProf_Flush(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.gcMarkTermination
//      runtime.gcSweep
void runtime.mProf_Flush(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	word32 esi_50;
	word32 edi_51;
	runtime.lock(esi, gs, 135624236, out esi_50, out edi_51);
	if (g_b815768C == 0x00)
	{
		runtime.mProf_FlushLocked(gs);
		g_b815768C = 0x01;
	}
	word32 edx_52;
	word32 ebx_53;
	runtime.unlock(gs, 135624236, out edx_52, out ebx_53);
}

// 08067E20: void runtime.mProf_FlushLocked(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.mProf_Flush
void runtime.mProf_FlushLocked(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	uint32 eax_18 = g_dw8157688;
	Eq_4 ecx_20 = runtime.mbuckets;
	while (ecx_20 != 0x00)
	{
		runtime.(*bucket).mp(gs, ecx_20);
		uint32 edx_39 = SLICE(eax_18 *64 ~0x55555554, word32, 32);
		uint32 ebx_43 = eax_18 - ((edx_39 >> 0x01) + (edx_39 >> 0x01) * 0x02);
		dwLoc0C->dw0000 += dwLoc0C->a0010[ebx_43].dw0000;
		dwLoc0C->dw0004 += dwLoc0C->a0010[ebx_43].dw0004;
		dwLoc0C->dw0008 += dwLoc0C->a0010[ebx_43].dw0008;
		dwLoc0C->dw000C += dwLoc0C->a0010[ebx_43].dw000C;
		dwLoc0C->a0010[ebx_43].dw0000 = 0x00;
		dwLoc0C->a0010[ebx_43].dw0004 = 0x00;
		dwLoc0C->a0010[ebx_43].dw0008 = 0x00;
		dwLoc0C->a0010[ebx_43].dw000C = 0x00;
		ecx_20 = *((word32) ecx_20 + 4);
	}
}

// 08067EF0: void runtime.mProf_Malloc(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      runtime.profilealloc
void runtime.mProf_Malloc(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp - 0x34 <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	fn0808FD70(0x00, fp - 0x90);
	runtime.callers(gs);
	word32 esi_146;
	word32 edi_147;
	runtime.lock(esi, gs, 135624236, out esi_146, out edi_147);
	if (dwLocA8 > 0x20)
		runtime.panicslice(gs);
	else
	{
		runtime.stkbucket(gs, 0x01, dwArg04, fp - 0x94, dwLocA8, 0x01);
		uint32 ecx_62 = g_dw8157688;
		runtime.(*bucket).mp(gs, dwLocA0);
		uint32 edx_78 = SLICE((ecx_62 + 0x02) *64 ~0x55555554, word32, 32);
		ui32 ecx_81 = ecx_62 + 0x02 - ((edx_78 >> 0x01) + (edx_78 >> 0x01) * 0x02);
		*((word32) dwArg04 + (ecx_81 * 0x10 + 16)) = (word32) *((word32) dwArg04 + (ecx_81 * 0x10 + 16)) + 1;
		(dwArg04 + 0x18)[ecx_81 * 0x10] += dwArg04;
		word32 edx_148;
		word32 ebx_149;
		runtime.unlock(gs, 135624236, out edx_148, out ebx_149);
		word32 ebp_150;
		word32 edi_151;
		runtime.systemstack(gs, fp - 0x10, out ebp_150, out edi_151);
	}
}

// 08068050: Register Eq_4 runtime.mProf_Free(Register Eq_4 esi, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
// Called from:
//      runtime.freespecial
Eq_4 runtime.mProf_Free(Eq_4 esi, struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 esi_28;
	word32 edi_94;
	runtime.lock(esi, gs, 135624236, out esi_28, out edi_94);
	uint32 eax_33 = g_dw8157688;
	runtime.(*bucket).mp(gs, dwArg04);
	uint32 edx_52 = SLICE((eax_33 + 0x01) *64 ~0x55555554, word32, 32);
	ui32 ecx_55 = eax_33 + 0x01 - ((edx_52 >> 0x01) + (edx_52 >> 0x01) * 0x02);
	++dwLoc08->a0014[ecx_55].dw0000;
	dwLoc08->a0014[ecx_55].dw0008 = (word32) dwArg08 + ((dwLoc08->a0014))[ecx_55].dw0008;
	word32 edx_95;
	word32 ebx_96;
	runtime.unlock(gs, 135624236, out edx_95, out ebx_96);
	return esi_28;
}

// 080680E0: void runtime.blockevent(Register word24 ebx_24_8, Register (ptr32 Eq_2) gs, Stack Eq_3266 dwArg04, Stack int32 dwArg08)
// Called from:
//      runtime.chansend
//      runtime.chanrecv
//      runtime.semacquire1
void runtime.blockevent(word24 ebx_24_8, struct Eq_2 * gs, Eq_3266 dwArg04, int32 dwArg08)
{
	while (true)
	{
		Eq_4 ecx_7 = gs->ptr0000->tFFFFFFFC;
		if (fp > *((word32) ecx_7 + 8))
			break;
		runtime.morestack_noctxt();
	}
	int32 ecx_43;
	Eq_3266 eax_42;
	if (((int8) (dwArg08 < 0x00) | (int8) (dwArg08 == 0x00) & (int8) (dwArg04 <= 0x00)) != 0x00)
	{
		eax_42.u0 = 0x01;
		ecx_43 = 0x00;
	}
	else
	{
		eax_42 = dwArg04;
		ecx_43 = dwArg08;
	}
	runtime.blocksampled(edx_24_8, esi, gs, eax_42, ecx_43);
	if (bLoc08 != 0x00)
	{
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_4 stackArg0 = <invalid>;
		runtime.saveblockevent(gs, stackArg0, eax_42);
	}
}

// 08068180: void runtime.blocksampled(Register ui24 edx_24_8, Register word32 esi, Register (ptr32 Eq_2) gs, Stack Eq_3266 dwArg04, Stack int32 dwArg08)
// Called from:
//      runtime.blockevent
void runtime.blocksampled(ui24 edx_24_8, word32 esi, struct Eq_2 * gs, Eq_3266 dwArg04, int32 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		edx_24_8 = SLICE(runtime.morestack_noctxt(), word24, 8);
	word64 mm0_203;
	ui32 ebx_48 = SEQ(SLICE(runtime/internal/atomic.Load64(0x08157668, out mm0_203), word24, 8), (int8) (dwLoc14 <= 0x00)) & SEQ(edx_24_8, (int8) (dwLoc10 == 0x00)) | SEQ(edx_24_8, (int8) (dwLoc10 < 0x00));
	if ((byte) ebx_48 != 0x00)
		return;
	if (((int8) (dwLoc14 > dwArg04) & (int8) (dwLoc10 == dwArg08) | (int8) (dwLoc10 > dwArg08)) != 0x00)
	{
		Eq_4 edx_92 = *((word32) gs->ptr0000->tFFFFFFFC + 24);
		Eq_38720 ebx_93 = *((word32) edx_92 + 0x0094);
		ui32 ebx_96 = ebx_93 >> 0x1F & 0xA8888EEF;
		Eq_38720 ebp_98 = ebx_93 << 0x01 ^ ebx_96;
		*((word32) edx_92 + 0x0094) = ebp_98;
		runtime.int64mod(edi, gs, ebp_98, dwLoc14);
		if (((int8) (dwLoc08 > dwArg04) & (int8) (dwLoc04 == dwArg08) | (int8) (dwLoc04 > dwArg08)) != 0x00)
			;
	}
}

// 08068280: void runtime.saveblockevent(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg00, Stack Eq_3266 dwArg04)
// Called from:
//      runtime.blockevent
//      sync.event
void runtime.saveblockevent(struct Eq_2 * gs, Eq_4 dwArg00, Eq_3266 dwArg04)
{
	while (fp - 0x28 <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 eax_46;
	fn0808FD70(0x00, fp - 0x88);
	struct Eq_38776 * edx_29 = dwLoc0C->ptr0018->ptr0054;
	if (edx_29 != null && edx_29 != dwLoc0C)
	{
		runtime.gcallers(gs, 0x20);
		eax_46 = dwLoc98;
	}
	else
	{
		runtime.callers(gs);
		eax_46 = dwLoc9C;
	}
	word32 esi_205;
	word32 edi_206;
	runtime.lock(esi, gs, 135624236, out esi_205, out edi_206);
	if (eax_46 > 0x20)
		runtime.panicslice(gs);
	else
	{
		runtime.stkbucket(gs, dwArg0C, 0x00, fp - 0x8C, eax_46, 0x01);
		runtime.(*bucket).bp(gs, dwLoc94);
		Eq_4 ecx_98 = null;
		Eq_4 edx_101 = *(union Eq_4 *) 0x04;
		null = (word32) ecx_98 + 1;
		Mem106[0x04:word32] = edx_101 + (ecx_98 <u 0x01);
		runtime.(*bucket).bp(gs, dwLoc94);
		ui64 ecx_ecx_137 = SEQ(dwArg04, *(union Eq_4 *) 0x08) + SEQ(*((union Eq_4 *) 0x0C), dwArg00);
		*(union Eq_4 *) 0x08 = (word32) ecx_ecx_137;
		*(union Eq_4 *) 0x0C = SLICE(ecx_ecx_137, word32, 32);
		word32 edx_202;
		word32 ebx_203;
		runtime.unlock(gs, 135624236, out edx_202, out ebx_203);
	}
}

// 08068410: void sync.event(Register word24 ebx_24_8, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg08)
// Called from:
//      runtime.semrelease1
void sync.event(word24 ebx_24_8, struct Eq_2 * gs, Eq_4 dwArg08)
{
	while (true)
	{
		Eq_4 ecx_7 = gs->ptr0000->tFFFFFFFC;
		if (fp > *((word32) ecx_7 + 8))
			break;
		runtime.morestack_noctxt();
	}
	Eq_3266 ecx_39;
	if (((int8) Test(ULT,false) & (int8) (dwArg08 == 0x00) | (int8) (dwArg08 < 0x00)) != 0x00)
		ecx_39.u0 = 0x00;
	else
		ecx_39 = dwArg04;
	if (((int8) (dwLoc14 > 0x00) & (int8) (dwLoc10 == 0x00) | (int8) (dwLoc10 > 0x00)) != 0x00)
	{
		Eq_4 edx_84 = *((word32) gs->ptr0000->tFFFFFFFC + 24);
		Eq_38720 ebx_85 = *((word32) edx_84 + 0x0094);
		Eq_38720 ebp_90 = ebx_85 << 0x01 ^ ebx_85 >> 0x1F & 0xA8888EEF;
		*((word32) edx_84 + 0x0094) = ebp_90;
		runtime.int64mod(edi, gs, ebp_90, dwLoc14);
		if (((int8) (dwLoc04 == 0x00) & (int8) (dwLoc08 == 0x00)) != 0x00)
		{
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_4 stackArg0 = <invalid>;
			runtime.saveblockevent(gs, stackArg0, ecx_39);
		}
	}
}

// 08068520: Register word32 runtime.tracealloc(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg0C)
// Called from:
//      runtime.mallocgc
word32 runtime.tracealloc(struct Eq_2 * gs, Eq_4 dwArg0C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	word32 edi_306;
	word32 esi_305;
	runtime.lock(esi, gs, 0x08157658, out esi_305, out edi_306);
	Eq_4 eax_25 = gs->ptr0000->tFFFFFFFC;
	*((word32) *((word32) eax_25 + 24) + 461) = 0x02;
	if (dwArg0C != 0x00)
	{
		runtime.(*_type).string(gs, dwArg0C);
		runtime.printlock(gs);
		runtime.printstring(gs);
		runtime.printpointer(gs);
		runtime.printstring(gs);
		word32 esi_308;
		runtime.printhex(esi, gs, dwArg08, 0x00, out esi_308);
		runtime.printstring(gs);
		runtime.printstring(gs);
		runtime.printstring(gs);
		runtime.printunlock(gs);
	}
	else
	{
		runtime.printlock(gs);
		runtime.printstring(gs);
		runtime.printpointer(gs);
		runtime.printstring(gs);
		word32 esi_307;
		runtime.printhex(esi, gs, dwArg08, 0x00, out esi_307);
		runtime.printstring(gs);
		runtime.printunlock(gs);
	}
	Eq_4 ecx_145 = *((word32) *((word32) eax_25 + 24) + 84);
	if (ecx_145 != 0x00 && eax_25 != ecx_145)
	{
		runtime.goroutineheader(gs, ecx_145);
		runtime.traceback(gs);
	}
	else
	{
		runtime.goroutineheader(gs, eax_25);
		runtime.getcallerpc();
		word32 edi_310;
		word32 ebp_309;
		runtime.systemstack(gs, fp - 0x10, out ebp_309, out edi_310);
	}
	runtime.printlock(gs);
	runtime.printstring(gs);
	runtime.printunlock(gs);
	*((word32) *((word32) eax_25 + 24) + 461) = 0x00;
	word32 edx_221;
	word32 ebx_311;
	runtime.unlock(gs, 0x08157658, out edx_221, out ebx_311);
	return edx_221;
}

// 08068770: void runtime.tracefree(Register Eq_4 esi, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg08)
// Called from:
//      runtime.(*mspan).sweep
void runtime.tracefree(Eq_4 esi, struct Eq_2 * gs, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 esi_28;
	word32 edi_215;
	runtime.lock(esi, gs, 0x08157658, out esi_28, out edi_215);
	Eq_4 eax_34 = gs->ptr0000->tFFFFFFFC;
	*((word32) *((word32) eax_34 + 24) + 461) = 0x02;
	runtime.printlock(gs);
	runtime.printstring(gs);
	runtime.printpointer(gs);
	runtime.printstring(gs);
	word32 esi_216;
	runtime.printhex(esi_28, gs, dwArg08, 0x00, out esi_216);
	runtime.printstring(gs);
	runtime.printunlock(gs);
	runtime.goroutineheader(gs, eax_34);
	runtime.getcallerpc();
	word32 ebp_217;
	word32 edi_218;
	runtime.systemstack(gs, fp - 0x10, out ebp_217, out edi_218);
	runtime.printlock(gs);
	runtime.printstring(gs);
	runtime.printunlock(gs);
	*((word32) *((word32) eax_34 + 24) + 461) = 0x00;
	word32 edx_219;
	word32 ebx_220;
	runtime.unlock(gs, 0x08157658, out edx_219, out ebx_220);
}

// 080688B0: Register Eq_4 runtime.tracegc(Register Eq_4 esi, Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.gcMark
Eq_4 runtime.tracegc(Eq_4 esi, struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 esi_28;
	word32 edi_153;
	runtime.lock(esi, gs, 0x08157658, out esi_28, out edi_153);
	Eq_4 eax_34 = gs->ptr0000->tFFFFFFFC;
	*((word32) *((word32) eax_34 + 24) + 461) = 0x02;
	runtime.printlock(gs);
	runtime.printstring(gs);
	runtime.printunlock(gs);
	Eq_4 esi_69 = runtime.tracebackothers(esi_28, gs, eax_34);
	runtime.printlock(gs);
	runtime.printstring(gs);
	runtime.printunlock(gs);
	runtime.printlock(gs);
	runtime.printstring(gs);
	runtime.printunlock(gs);
	*((word32) *((word32) eax_34 + 24) + 461) = 0x00;
	word32 edx_154;
	word32 ebx_155;
	runtime.unlock(gs, 0x08157658, out edx_154, out ebx_155);
	return esi_69;
}

// 08068990: Register Eq_4 runtime.init.1(Register word24 ebx_24_8, Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.init
Eq_4 runtime.init.1(word24 ebx_24_8, struct Eq_2 * gs)
{
	while (true)
	{
		Eq_4 esi_8 = *((word32) gs->ptr0000->tFFFFFFFC + 8);
		if (esi_8 != ~0x0521 && (fp + 880) - esi_8 > 6288)
			break;
		runtime.morestack_noctxt();
	}
	word32 * edi_22 = fp - 5528;
	word32 ecx_23;
	for (ecx_23 = 0x0566; ecx_23 != 0x00; --ecx_23)
	{
		*edi_22 = 0x00;
		++edi_22;
	}
	if (runtime.sizeof_C_MStats == 5528)
		return esi_8;
	runtime.printlock(gs);
	runtime.printint(ebx_24_8, gs, (uint64) runtime.sizeof_C_MStats);
	runtime.printsp(gs);
	runtime.printint(ebx_24_8, gs, 5528);
	runtime.printnl(gs);
	runtime.printunlock(gs);
	runtime.throw(gs);
}

// 08068A50: void runtime.cachestats(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.gcMark
void runtime.cachestats(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	int32 eax_17;
	word32 * ecx_20 = g_a81478C0;
	for (eax_17 = 0x00; eax_17 < 0x0401; ++eax_17)
	{
		Eq_4 edx_26 = *ecx_20;
		if (edx_26 == 0x00)
			return;
		Eq_4 edx_34 = *((word32) edx_26 + 52);
		if (edx_34 != 0x00)
			runtime.purgecachedstats(gs, edx_34);
		++ecx_20;
	}
}

// 08068AB0: void runtime.flushmcache(Register (ptr32 Eq_2) gs, Stack uint32 dwArg04)
// Called from:
//      runtime.markroot
void runtime.flushmcache(struct Eq_2 * gs, uint32 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (dwArg04 >= 0x0401)
		runtime.panicindex(gs);
	else
	{
		struct Eq_39337 * eax_23 = *((char *) g_a81478C0 + dwArg04 * 0x04);
		if (eax_23 == null)
			return;
		Eq_4 eax_29 = eax_23->t0034;
		if (eax_29 == 0x00)
			return;
		runtime.(*mcache).releaseAll(gs, eax_29);
		runtime.stackcache_clear(gs, eax_29);
	}
}

// 08068B20: void runtime.purgecachedstats(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      runtime.findObject
//      runtime.cachestats
//      runtime.freemcache.func1
void runtime.purgecachedstats(struct Eq_2 * gs, Eq_4 dwArg04)
{
	uint32 eax_9 = (word32) *((word32) dwArg04 + 4) + g_dw81597B8;
	uint32 edx_11 = g_dw81597BC;
	g_dw81597B8 = eax_9;
	g_dw81597BC = (uint32) ((bool) (eax_9 < 0x00) + edx_11);
	((word32) dwArg04 + 4)->u0 = 0x00;
	up32 eax_19 = (word32) *((word32) dwArg04 + 16) + g_dw8159798;
	word32 edx_21 = g_dw815979C;
	g_dw8159798 = eax_19;
	g_dw815979C = (word32) ((bool) (eax_19 < 0x00) + edx_21);
	((word32) dwArg04 + 16)->u0 = 0x00;
	up32 eax_29 = (word32) *((word32) dwArg04 + 588) + g_dw8158198;
	word32 edx_31 = g_dw815819C;
	g_dw8158198 = eax_29;
	g_dw815819C = (word32) ((bool) (eax_29 < 0x00) + edx_31);
	*((word32) dwArg04 + 588) = 0x00;
	up32 eax_39 = (word32) *((word32) dwArg04 + 592) + g_dw8149178;
	word32 edx_41 = g_dw814917C;
	g_dw8149178 = eax_39;
	g_dw814917C = (word32) ((bool) (eax_39 < 0x00) + edx_41);
	*((word32) dwArg04 + 592) = 0x00;
	up32 eax_49 = (word32) *((word32) dwArg04 + 596) + g_dw8149180;
	word32 edx_51 = g_dw8149184;
	g_dw8149180 = eax_49;
	g_dw8149184 = (word32) ((bool) (eax_49 < 0x00) + edx_51);
	*((word32) dwArg04 + 596) = 0x00;
	Eq_39463 eax_57 = 0x00;
	while (eax_57 < 0x43)
	{
		if (eax_57 >= 0x43)
			runtime.panicindex(gs);
		struct Eq_39468 * ebx_69 = eax_57 * 0x08 + 0x08149188;
		up32 ebp_71 = ebx_69->dw0000;
		up32 esi_73 = *((word32) dwArg04 + (eax_57 * 0x04 + 600));
		word32 ebx_76 = ebx_69->dw0004;
		g_a8149188[eax_57] = (struct Eq_138673) (ebp_71 + esi_73);
		ebx_69->dw0004 = (word32) ((bool) (ebp_71 + esi_73 < 0x00) + ebx_76);
		*((word32) dwArg04 + (eax_57 * 0x04 + 600)) = 0x00;
		eax_57 = (word32) eax_57 + 1;
	}
}

// 08068C60: void runtime.mSysStatInc(Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
// Called from:
//      runtime.persistentalloc1
//      runtime.sysAlloc
//      runtime.sysMap
void runtime.mSysStatInc(Eq_4 dwArg04, Eq_4 dwArg08)
{
	runtime/internal/atomic.Xadduintptr(dwArg04, dwArg08);
	if (dwArg08 < dwArg04)
	{
		runtime.printlock(gs);
		runtime.printstring(gs);
		runtime.printint(ebx_24_8, gs, dwArg08);
		runtime.printstring(gs);
		runtime.printint(ebx_24_8, gs, dwArg04);
		runtime.printstring(gs);
		runtime.printunlock(gs);
		runtime.exit();
	}
}

// 08068D10: void runtime.mSysStatDec(Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
// Called from:
//      runtime.persistentalloc1
//      runtime.sysFree
void runtime.mSysStatDec(Eq_4 dwArg04, Eq_4 dwArg08)
{
	Eq_4 eax_8 = 0x00 - dwArg08;
	runtime/internal/atomic.Xadduintptr(dwArg04, eax_8);
	if (eax_8 + dwArg04 <u dwArg04)
	{
		runtime.printlock(gs);
		runtime.printstring(gs);
		runtime.printint(ebx_24_8, gs, eax_8);
		runtime.printstring(gs);
		runtime.printint(ebx_24_8, gs, dwArg04);
		runtime.printstring(gs);
		runtime.printunlock(gs);
		runtime.exit();
	}
}

// 08068DD0: void internal/poll.runtime_pollServerInit(Register (ptr32 Eq_2) gs)
void internal/poll.runtime_pollServerInit(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.netpollinit(gs);
	runtime/internal/atomic.Store(0x0815760C, 0x01);
}

// 08068E10: void runtime.netpollinited(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.findrunnable
//      runtime.pollWork
void runtime.netpollinited(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime/internal/atomic.Load();
}

// 08068E50: Register word32 internal/poll.runtime_pollOpen(Register Eq_4 esi, Register (ptr32 Eq_2) gs, Stack word32 dwArg04, Register out ptr32 esiOut)
// Called from:
//      internal/poll.(*pollDesc).init
word32 internal/poll.runtime_pollOpen(Eq_4 esi, struct Eq_2 * gs, word32 dwArg04, ptr32 & esiOut)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	word32 esi_172;
	word32 edi_173;
	runtime.lock(runtime.(*pollCache).alloc(esi, gs, 0x081450A8), gs, (char *) dwLoc10 + 4, out esi_172, out edi_173);
	word32 ecx_53 = dwLoc10->dw0044;
	if (ecx_53 == 0x00 || ecx_53 == 0x01)
	{
		word32 ecx_70 = dwLoc10->dw0014;
		if (ecx_70 == 0x00 || ecx_70 == 0x01)
		{
			dwLoc10->dw0008 = dwArg04;
			dwLoc10->b000C = 0x00;
			++dwLoc10->dw0010;
			dwLoc10->dw0014 = 0x00;
			dwLoc10->dw003C = 0x00;
			dwLoc10->dw0040 = 0x00;
			dwLoc10->dw0044 = 0x00;
			dwLoc10->dw006C = 0x00;
			dwLoc10->dw0070 = 0x00;
			word32 ebx_175;
			word32 edx_174;
			runtime.unlock(gs, (char *) dwLoc10 + 4, out edx_174, out ebx_175);
			ptr32 esi_123;
			word32 ebx_120 = runtime.netpollopen(gs, out esi_123);
			esiOut = esi_123;
			return ebx_120;
		}
		else
			runtime.throw(gs);
	}
	else
		runtime.throw(gs);
}

// 08068F60: Register word32 internal/poll.runtime_pollClose(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Register out ptr32 esiOut)
// Called from:
//      internal/poll.(*pollDesc).init
//      internal/poll.(*pollDesc).close
word32 internal/poll.runtime_pollClose(struct Eq_2 * gs, Eq_4 dwArg04, ptr32 & esiOut)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (*((word32) dwArg04 + 0x0C) == 0x00)
		runtime.throw(gs);
	else
	{
		Eq_4 ecx_32 = *((word32) dwArg04 + 0x0044);
		if (ecx_32 == 0x00 || ecx_32 == 0x01)
		{
			Eq_4 ecx_49 = *((word32) dwArg04 + 20);
			if (ecx_49 == 0x00 || ecx_49 == 0x01)
			{
				ptr32 esi_91;
				word32 ebx_87 = runtime.(*pollCache).free(runtime.netpollclose(gs), gs, 0x081450A8, dwArg04, out esi_91);
				esiOut = esi_91;
				return ebx_87;
			}
			else
				runtime.throw(gs);
		}
		else
			runtime.throw(gs);
	}
}

// subject_text_0002.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 08069020: Register word32 runtime.(*pollCache).free(Register Eq_4 esi, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Register out ptr32 esiOut)
// Called from:
//      internal/poll.runtime_pollClose
word32 runtime.(*pollCache).free(Eq_4 esi, struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, ptr32 & esiOut)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	ptr32 esi_30;
	word32 edi_65;
	runtime.lock(esi, gs, dwArg04, out esi_30, out edi_65);
	*dwArg08 = *((word32) dwArg04 + 4);
	*((word32) dwArg04 + 4) = dwArg08;
	word32 ebx_42;
	word32 edx_66;
	runtime.unlock(gs, dwArg04, out edx_66, out ebx_42);
	esiOut = esi_30;
	return ebx_42;
}

// 08069070: Register word32 internal/poll.runtime_pollReset(Register word32 ebp, Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_39794) dwArg04, Stack word32 dwArg08)
// Called from:
//      internal/poll.(*pollDesc).prepare
word32 internal/poll.runtime_pollReset(word32 ebp, struct Eq_2 * gs, struct Eq_39794 * dwArg04, word32 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	word32 ecx_89;
	if (dwArg04->b000C != 0x00)
	{
		ecx_89 = 0x01;
		goto l08069097;
	}
	if (dwArg08 == 114)
	{
		int32 ebx_26 = dwArg04->dw0040;
		if (((int8) (ebx_26 < 0x00) | (int8) Test(ULT,false) & (int8) (ebx_26 == 0x00)) != 0x00)
			goto l080690F1;
	}
	if (dwArg08 == 0x77)
	{
		int32 edx_60 = dwArg04->dw0070;
		if (((int8) (edx_60 < 0x00) | (int8) (edx_60 == 0x00) & (int8) Test(ULT,false)) != 0x00)
		{
l080690F1:
			ecx_89 = 0x02;
			goto l08069097;
		}
	}
	ecx_89 = 0x00;
l08069097:
	if (ecx_89 != 0x00)
		return;
	if (dwArg08 == 114)
		dwArg04->dw0014 = 0x00;
	else if (dwArg08 == 0x77)
		dwArg04->dw0044 = 0x00;
	return;
}

// 08069130: Register int32 internal/poll.runtime_pollWait(Register (ptr32 Eq_39870) ebp, Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_39872) dwArg04, Stack (ptr32 Eq_39873) dwArg08)
// Called from:
//      internal/poll.(*pollDesc).wait
int32 internal/poll.runtime_pollWait(struct Eq_39870 * ebp, struct Eq_2 * gs, struct Eq_39872 * dwArg04, struct Eq_39873 * dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	word32 ecx_90;
	if (dwArg04->b000C != 0x00)
	{
		ecx_90 = 0x01;
		goto l0806915E;
	}
	if (dwArg08 == (struct Eq_39873 *) 114)
	{
		int32 ebx_27 = dwArg04->dw0040;
		struct Eq_39870 * ebx_38 = SEQ(SLICE(ebp, word24, 8), (int8) (ebx_27 == 0x00));
		ebx = SEQ(SLICE(ebx_27, word24, 8), (int8) (ebx_27 < 0x00));
		ebp = ebx_38;
		if (((int8) Test(ULT,false) & (int8) (ebx_27 == 0x00) | (int8) (ebx_27 < 0x00)) != 0x00)
			goto l0806923A;
	}
	if (dwArg08 == (struct Eq_39873 *) 0x77)
	{
		int32 edx_61 = dwArg04->dw0070;
		int32 ebx_69 = SEQ(dwArg04->n006D, (int8) Test(ULT,false));
		ebp = SEQ(SLICE(ebp, word24, 8), (int8) (edx_61 == 0x00)) & ebx_69;
		ebx = ebx_69;
		if (((int8) (edx_61 < 0x00) | (byte) ebp) != 0x00)
		{
l0806923A:
			ecx_90 = 0x02;
			goto l0806915E;
		}
	}
	ecx_90 = 0x00;
l0806915E:
	if (ecx_90 != 0x00)
		return ebx;
	do
	{
		int32 ebx_115 = runtime.netpollblock(ebp, gs, dwLoc14, dwArg04, dwArg08, SEQ(nLoc07, 0x00), bLoc04);
		if (bLoc04 != 0x00)
			return ebx_115;
		word32 ecx_200;
		if (dwArg04->b000C != 0x00)
		{
			ecx_200 = 0x01;
			goto l08069195;
		}
		if (dwArg08 == (struct Eq_39873 *) 114)
		{
			int32 edx_139 = dwArg04->dw0040;
			int32 ebx_146 = SEQ(dwArg04->n003D, (int8) Test(ULT,false));
			ebp = SEQ(SLICE(ebp, word24, 8), (int8) (edx_139 == 0x00)) & ebx_146;
			ebx_115 = ebx_146;
			if (((int8) (edx_139 < 0x00) | (byte) ebp) != 0x00)
				goto l080691CB;
		}
		if (dwArg08 == (struct Eq_39873 *) 0x77)
		{
			int32 ebx_173 = dwArg04->dw0070;
			ui24 edx_24_8_188 = dwArg04->n006D;
			ebp = SEQ(SLICE(ebp, word24, 8), (int8) (ebx_173 == 0x00)) & SEQ(edx_24_8_188, (int8) Test(ULT,false));
			ebx_115 = ebx_173;
			if (((int8) (ebx_173 < 0x00) | (byte) ebp) == 0x00)
				goto l080691F8;
l080691CB:
			ecx_200 = 0x02;
		}
		else
		{
l080691F8:
			ecx_200 = 0x00;
		}
l08069195:
	} while (ecx_200 == 0x00);
	return ebx_115;
}

// 08069280: void internal/poll.runtime_pollUnblock(Register Eq_4 esi, Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_40037) dwArg04)
// Called from:
//      internal/poll.(*pollDesc).init
//      internal/poll.(*pollDesc).evict
void internal/poll.runtime_pollUnblock(Eq_4 esi, struct Eq_2 * gs, struct Eq_40037 * dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	word32 edi_307;
	Eq_4 esi_113;
	runtime.lock(esi, gs, (char *) dwArg04 + 4, out esi_113, out edi_307);
	if (dwArg04->b000C != 0x00)
		runtime.throw(gs);
	else
	{
		dwArg04->b000C = 0x01;
		++dwArg04->dw0010;
		runtime.atomicstorep(fp - 0x0C, 0x00);
		runtime.netpollunblock(gs, dwArg04, 114, 0x00);
		runtime.netpollunblock(gs, dwArg04, 0x77, 0x00);
		if (dwArg04->dw002C != 0x00)
		{
			esi_113 = runtime.deltimer(esi_113, gs, &dwArg04->dw0010 + 2);
			if (g_t81576F0 == 0x00)
				dwArg04->dw002C = 0x00;
			else
				runtime.writebarrierptr(&dwArg04->dw002C, 0x00);
		}
		if (dwArg04->dw005C != 0x00)
		{
			runtime.deltimer(esi_113, gs, &dwArg04->dw002C + 7);
			if (g_t81576F0 == 0x00)
				dwArg04->dw005C = 0x00;
			else
				runtime.writebarrierptr(&dwArg04->dw005C, 0x00);
		}
		word32 ebx_309;
		word32 edx_308;
		runtime.unlock(gs, (char *) dwArg04 + 4, out edx_308, out ebx_309);
		if (dwLoc14 != 0x00)
			runtime.netpollgoready(gs);
		if (dwLoc14 != 0x00)
			runtime.netpollgoready(gs);
	}
}

// 08069430: void runtime.netpollready(Register (ptr32 Eq_2) gs, Stack (ptr32 (ptr32 Eq_40176)) dwArg04, Stack word32 dwArg0C)
// Called from:
//      runtime.netpoll
void runtime.netpollready(struct Eq_2 * gs, struct Eq_40176 ** dwArg04, word32 dwArg0C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	struct Eq_40176 * dwLoc04_101 = null;
	struct Eq_40176 * dwLoc08_113 = null;
	if (dwArg0C == 114 || dwArg0C == 233)
	{
		runtime.netpollunblock(gs, dwArg08, 114, 0x01);
		dwLoc04_101 = dwLoc0C;
	}
	if (dwArg0C == 0x77 || dwArg0C == 233)
	{
		runtime.netpollunblock(gs, dwArg08, 0x77, 0x01);
		dwLoc08_113 = dwLoc0C;
	}
	if (dwLoc04_101 != null)
	{
		dwLoc04_101->ptr0068 = (struct Eq_40176 *) *dwArg04;
		*dwArg04 = (struct Eq_40176 **) dwLoc04_101;
	}
	if (dwLoc08_113 != null)
	{
		dwLoc08_113->ptr0068 = (struct Eq_40176 *) *dwArg04;
		*dwArg04 = (struct Eq_40176 **) dwLoc08_113;
	}
}

// 08069510: void runtime.netpollblockcommit(Register (ptr32 Eq_40220) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
void runtime.netpollblockcommit(struct Eq_40220 * gs, Eq_4 dwArg04, Eq_4 dwArg08)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	runtime/internal/atomic.Casuintptr(dwArg08, 0x02, dwArg04);
	if ((byte) dwArg04 != 0x00)
		runtime/internal/atomic.Xadd(0x08157610, 0x01);
}

// 08069590: void runtime.netpollgoready(Register (ptr32 Eq_2) gs)
// Called from:
//      internal/poll.runtime_pollUnblock
void runtime.netpollgoready(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime/internal/atomic.Xadd(0x08157610, ~0x00);
	runtime.goready(gs);
}

// 080695E0: Register word32 runtime.netpollblock(Register (ptr32 Eq_39870) ebp, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg00, Stack (ptr32 Eq_39872) dwArg04, Stack (ptr32 Eq_39873) dwArg08, Stack word32 dwArg0C, Stack byte bArg10)
// Called from:
//      internal/poll.runtime_pollWait
word32 runtime.netpollblock(struct Eq_39870 * ebp, struct Eq_2 * gs, Eq_4 dwArg00, struct Eq_39872 * dwArg04, struct Eq_39873 * dwArg08, word32 dwArg0C, byte bArg10)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 ecx_20 = &dwArg04->b000C + 8;
	if (dwArg08 == (struct Eq_39873 *) 0x77)
		ecx_20 = &dwArg04->dw0040 + 1;
	word32 ebx_30 = *ecx_20;
	if (ebx_30 == 0x01)
	{
		*ecx_20 = 0x00;
		return ebx_30;
	}
	if (ebx_30 != 0x00)
		runtime.throw(gs);
	runtime/internal/atomic.Casuintptr(ecx_20, 0x00, 0x02);
	if (bArg10 != 0x00)
	{
l0806965D:
		runtime.gopark(gs);
		goto l08069692;
	}
	word32 eax_147;
	if (dwArg08->b000C != 0x00)
	{
		eax_147 = 0x01;
		goto l080696D2;
	}
	if (dwArg0C == 114)
	{
		int32 ebx_83 = dwArg08->dw0040;
		ui32 edx_109 = SEQ(dwArg08->n003D, (int8) Test(ULT,false)) & SEQ(SLICE(ebp, word24, 8), (int8) (ebx_83 == 0x00)) | SEQ(SLICE(ebx_83, word24, 8), (int8) (ebx_83 < 0x00));
		if ((byte) edx_109 != 0x00)
			goto l08069702;
	}
	if (dwArg0C == 0x77)
	{
		int32 eax_121 = dwArg08->dw0070;
		if (((int8) Test(ULT,false) & (int8) (eax_121 == 0x00) | (int8) (eax_121 < 0x00)) != 0x00)
		{
l08069702:
			eax_147 = 0x02;
			goto l080696D2;
		}
	}
	eax_147 = 0x00;
l080696D2:
	if (eax_147 != 0x00)
	{
l08069692:
		runtime/internal/atomic.Xchguintptr(dwArg00, 0x00);
		runtime.throw(gs);
	}
	goto l0806965D;
}

// 08069780: void runtime.netpollunblock(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_40037) dwArg04, Stack word32 dwArg08, Stack byte bArg0C)
// Called from:
//      internal/poll.runtime_pollUnblock
//      runtime.netpollready
void runtime.netpollunblock(struct Eq_2 * gs, struct Eq_40037 * dwArg04, word32 dwArg08, byte bArg0C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 eax_24;
	if (dwArg08 == 0x77)
		eax_24 = &dwArg04->dw002C + 6;
	else
		eax_24 = &dwArg04->dw0010 + 1;
	do
	{
		Eq_4 ecx_32 = *eax_24;
		if (ecx_32 == 0x01)
			return;
		word32 edx_148;
		if (ecx_32 == 0x00)
		{
			edx_148 = (word32) bArg0C;
			if ((byte) edx_148 == 0x00)
				return;
		}
		else
			edx_148 = (word32) bArg0C;
		runtime/internal/atomic.Casuintptr(eax_24, ecx_32, (word32) (byte) edx_148);
	} while (bLoc0C == 0x00);
}

// 08069830: Register Eq_4 runtime.(*pollCache).alloc(Register Eq_4 esi, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      internal/poll.runtime_pollOpen
Eq_4 runtime.(*pollCache).alloc(Eq_4 esi, struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	word32 edi_120;
	Eq_4 esi_115;
	runtime.lock(esi, gs, dwArg04, out esi_115, out edi_120);
	if (*((word32) dwArg04 + 4) == 0x00)
	{
		runtime.persistentalloc(gs);
		Eq_40438 edx_55 = 0x00;
		while (edx_55 < 0x22)
		{
			Eq_4 ebp_65 = dwLoc08 + edx_55 *s 0x78;
			esi_115 = *((word32) dwArg04 + 4);
			*ebp_65 = esi_115;
			*((word32) dwArg04 + 4) = ebp_65;
			edx_55 = (word32) edx_55 + 1;
		}
	}
	*((word32) dwArg04 + 4) = **((word32) dwArg04 + 4);
	word32 edx_121;
	word32 ebx_122;
	runtime.unlock(gs, dwArg04, out edx_121, out ebx_122);
	return esi_115;
}

// 080698E0: void runtime.netpollinit(Register (ptr32 Eq_2) gs)
// Called from:
//      internal/poll.runtime_pollServerInit
void runtime.netpollinit(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.epollcreate1();
	runtime.epfd = dwLoc08;
	if (dwLoc08 >= 0x00)
		return;
	word24 ebx_24_8_65 = SLICE(runtime.epollcreate(), word24, 8);
	runtime.epfd = dwLoc08;
	if (dwLoc08 < 0x00)
	{
		runtime.printlock(gs);
		runtime.printstring(gs);
		runtime.printsp(gs);
		Eq_40508 eax_60 = -dwLoc08;
		runtime.printint(ebx_24_8_65, gs, SEQ(eax_60 >> 0x1F, eax_60));
		runtime.printnl(gs);
		runtime.printunlock(gs);
		runtime.throw(gs);
	}
	else
		runtime.closeonexec();
}

// 080699B0: Register word32 runtime.netpollopen(Register (ptr32 Eq_2) gs, Register out ptr32 esiOut)
// Called from:
//      internal/poll.runtime_pollOpen
word32 runtime.netpollopen(struct Eq_2 * gs, ptr32 & esiOut)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	ptr32 esi_38;
	word32 ebx_35 = runtime.epollctl(out esi_38);
	esiOut = esi_38;
	return ebx_35;
}

// 08069A30: Register word32 runtime.netpollclose(Register (ptr32 Eq_2) gs)
// Called from:
//      internal/poll.runtime_pollClose
word32 runtime.netpollclose(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	word32 esi_32;
	runtime.epollctl(out esi_32);
	return esi_32;
}

// 08069AA0: Register word32 runtime.netpoll(Register (ptr32 Eq_2) gs, Stack Eq_40563 bArg04)
// Called from:
//      runtime.startTheWorldWithSema
//      runtime.findrunnable
//      runtime.pollWork
//      runtime.sysmon
word32 runtime.netpoll(struct Eq_2 * gs, Eq_40563 bArg04)
{
runtime.netpoll_entry:
l08069AA0:
	branch fp - 1444 <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8) l08069C89
l08069ABD:
	branch runtime.epfd == ~0x00 l08069BE4
l08069AD2:
	word32 * edi_213 = fp - 0x0600
	word32 ecx_216 = 0x0180
	goto l08069AF8
l08069AE7:
l08069AF8:
	branch ecx_216 == 0x00 l08069AFA
l08069AF8_1:
	*edi_213 = 0x00
	edi_213 = edi_213 + 1
	ecx_216 = ecx_216 - 0x01
	goto l08069AF8
l08069AFF:
	ecx_142 = (word32) ecx_142 + 1
l08069B00:
	branch ecx_142 >= eax_139 l08069B6B
l08069B04:
	branch ecx_142 >= 0x80 l08069BF6
l08069B10:
	ui32 ebx_95 = (fp - 0x0600)[ecx_142].dw0000
	branch ebx_95 == 0x00 l08069AFF
l08069B1B:
	word32 ebp_102
	branch (ebx_95 & 0x2019) == 0x00 l08069B67
l08069B23:
	ebp_102 = 114
l08069B28:
	word32 ebx_111
	branch (ebx_95 & 0x1C) == 0x00 l08069B63
l08069B30:
	ebx_111 = ebp_102 + 0x77
l08069B33:
	branch ebx_111 == 0x00 l08069AFF
l08069B37:
	runtime.netpollready(gs, fp - 0x0604, ebx_111)
	eax_139 = dwLoc0614
	goto l08069AFF
l08069B63:
	ebx_111 = ebp_102
	goto l08069B33
l08069B67:
	ebp_102 = 0x00
	goto l08069B28
l08069B6B:
	branch bArg04 == 0x00 l08069BCB
	goto l08069B83
l08069B77:
l08069B7F:
l08069B83:
	runtime.epollwait()
	Eq_40599 eax_139 = dwLoc0614
	branch dwLoc0614 >= 0x00 l08069BBC
l08069BB1:
	branch dwLoc0614 != ~0x03 l08069BFD
	goto l08069B83
l08069BBC:
	Eq_40599 ecx_142 = 0x00
	goto l08069B00
l08069BE4:
	return esi
l08069BF6:
	runtime.panicindex(gs)
l08069BFD:
	runtime.printlock(gs)
	runtime.printstring(gs)
	runtime.printsp(gs)
	runtime.printint(SLICE(ebx_52, word24, 8), gs, runtime.epfd)
	runtime.printsp(gs)
	runtime.printstring(gs)
	runtime.printsp(gs)
	runtime.printint(SLICE(ebx_52, word24, 8), gs, -dwLoc0614)
	runtime.printnl(gs)
	runtime.printunlock(gs)
	runtime.throw(gs)
l08069C89:
	runtime.morestack_noctxt()
	goto l08069AA0
runtime.netpoll_exit:
}

// 08069CA0: Register word32 runtime.futexsleep(Register word24 ecx_24_8, Register word24 ebx_24_8, Register Eq_4 esi, Stack (ptr32 Eq_12643) dwArg0C, Stack (ptr32 Eq_12643) dwArg10, Register out ptr32 esiOut, Register out ptr32 ediOut)
// Called from:
//      runtime.lock
//      runtime.notesleep
//      runtime.notetsleep_internal
word32 runtime.futexsleep(word24 ecx_24_8, word24 ebx_24_8, Eq_4 esi, struct Eq_12643 * dwArg0C, struct Eq_12643 * dwArg10, ptr32 & esiOut, ptr32 & ediOut)
{
	if (((int8) (dwArg10 < null) | (int8) (dwArg10 == null) & (int8) Test(ULT,false)) == 0x00)
	{
		runtime.timediv(esi, dwArg0C, dwArg10, 1000000000, fp - 0x04);
		ptr32 edi_59;
		ptr32 esi_61;
		word32 ebp_56 = runtime.futex(out esi_61, out edi_59);
		esiOut = esi_61;
		ediOut = edi_59;
		return ebp_56;
	}
	else
	{
		ptr32 edi_76;
		ptr32 esi_78;
		word32 ebp_73 = runtime.futex(out esi_78, out edi_76);
		esiOut = esi_78;
		ediOut = edi_76;
		return ebp_73;
	}
}

// 08069D70: void runtime.futexwakeup()
// Called from:
//      runtime.unlock
//      runtime.notewakeup
void runtime.futexwakeup()
{
	word32 edi_78;
	word32 esi_77;
	runtime.futex(out esi_77, out edi_78);
	if (dwLoc10 >= 0x00)
		return;
	word32 edi_81;
	word32 ebp_80;
	runtime.systemstack(gs, fp - 0x0C, out ebp_80, out edi_81);
	*(word32 *) 0x1006 = 0x1006;
}

// 08069DF0: Register Eq_4 runtime.getproccount(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.osinit
Eq_4 runtime.getproccount(struct Eq_2 * gs)
{
	while (true)
	{
		Eq_4 esi_138 = *((word32) gs->ptr0000->tFFFFFFFC + 8);
		if (esi_138 != ~0x0521 && (fp + 880) - esi_138 > 0x2300)
			break;
		runtime.morestack_noctxt();
	}
	word32 * edi_22 = fp - 0x2000;
	word32 ecx_23;
	for (ecx_23 = 0x0800; ecx_23 != 0x00; --ecx_23)
	{
		*edi_22 = 0x00;
		++edi_22;
	}
	runtime.sched_getaffinity();
	if (dwLoc2004 < 0x00)
		return esi_138;
	Eq_40783 eax_47 = dwLoc2004 + ((dwLoc2004 >> 0x1F) >> 0x1E);
	if (eax_47 >> 0x02 > 0x0800)
		runtime.panicslice(gs);
	else
	{
		int32 ecx_52;
		word32 * edx_53 = fp - 0x2000;
		word32 ebx_54 = 0x00;
		for (ecx_52 = 0x00; ecx_52 < eax_47 >> 0x02; ++ecx_52)
		{
			Eq_4 ebp_75 = *edx_53;
			while (ebp_75 != 0x00)
			{
				esi_138 = ebp_75 >> 0x01;
				ebx_54 += ebp_75 & 0x01;
				ebp_75 = esi_138;
			}
			++edx_53;
		}
		return esi_138;
	}
}

// 08069ED0: void runtime.newosproc(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_40822) dwArg04)
// Called from:
//      runtime.newm
void runtime.newosproc(struct Eq_2 * gs, struct Eq_40822 * dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.sigprocmask();
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	Eq_4 stackArg0 = <invalid>;
	runtime.clone(stackArg0, 0x00050F00, dwArg08, dwArg04, dwArg04->dw0000, g_t80E7C84);
	runtime.sigprocmask();
	if (dwLoc1C >= 0x00)
		return;
	Eq_4 eax_78 = g_t8145400;
	runtime.printlock(gs);
	runtime.printstring(gs);
	runtime.printint(ebx_24_8, gs, eax_78);
	runtime.printstring(gs);
	runtime.printint(ebx_24_8, gs, -dwLoc1C);
	runtime.printstring(gs);
	runtime.printunlock(gs);
	if (dwLoc1C == ~0x0A)
	{
		runtime.printlock(gs);
		runtime.printstring(gs);
		runtime.printnl(gs);
		runtime.printunlock(gs);
	}
	runtime.throw(gs);
}

// 0806A070: void runtime.sysargs(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
// Called from:
//      runtime.args
void runtime.sysargs(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08)
{
	while (fp - 0x01AC <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	ui32 eax_20 = (word32) dwArg04 + 1;
	while (*((word32) dwArg08 + eax_20 * 0x04) != 0x00)
		++eax_20;
	runtime.sysauxv(gs, (word32) dwArg08 + 4 + eax_20 * 0x04, 0x10000000);
	if (dwLoc0220 != 0x00)
		return;
	if (g_dw81426F4 <= 0x00)
		runtime.panicindex(gs);
	else
	{
		runtime.open();
		if (dwLoc0220 >= 0x00)
		{
			runtime.duffzero(0x00, fp - 0x0204);
			runtime.read();
			runtime.closefd();
			runtime.sysauxv(gs, fp - 0x0208, 0x80);
		}
		else
		{
			runtime.mmap();
			if (dwLoc0214 < 0x1000)
				return;
			uint32 ecx_152;
			for (ecx_152 = 0x1000; ecx_152 < 0x00040000; ecx_152 <<= 0x01)
				runtime.mincore();
			if (runtime.physPageSize == 0x00)
				runtime.physPageSize.u0 = 0x00040000;
			runtime.munmap();
		}
	}
}

// 0806A280: void runtime.sysauxv(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_40921) dwArg04, Stack uint32 dwArg08)
// Called from:
//      runtime.sysargs
void runtime.sysauxv(struct Eq_2 * gs, struct Eq_40921 * dwArg04, uint32 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	uint32 eax_17;
	for (eax_17 = 0x00; eax_17 < dwArg08; eax_17 += 0x02)
	{
		word32 ebx_28 = dwArg04[eax_17];
		if (ebx_28 == 0x00)
			return;
		if (eax_17 + 0x01 >= dwArg08)
			runtime.panicindex(gs);
		Eq_4 ebp_43 = dwArg04->a0004[eax_17];
		if (ebx_28 == 0x06)
			runtime.physPageSize = ebp_43;
		else if (ebx_28 == 0x19)
		{
			g_t814516C.u0 = 0x10;
			g_dw8145170 = 0x10;
			if (g_t81576F0 == 0x00)
				g_t8145168 = ebp_43;
			else
				runtime.writebarrierptr(0x08145168, ebp_43);
		}
	}
	runtime.panicindex(gs);
}

// 0806A360: Register word32 runtime.osinit(Register (ptr32 Eq_2) gs)
// Called from:
//      main
word32 runtime.osinit(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	word32 esi_23 = runtime.getproccount(gs);
	runtime.ncpu = dwLoc04;
	return esi_23;
}

// 0806A390: void runtime.getRandomData(Register (ptr32 Eq_2) gs, Register Eq_4 mm0, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
// Called from:
//      runtime.alginit
void runtime.getRandomData(struct Eq_2 * gs, Eq_4 mm0, Eq_4 dwArg04, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 eax_17 = g_t8145168;
	Eq_4 ecx_18 = g_t814516C;
	if (eax_17 == 0x00)
	{
		if (g_dw8142704 <= 0x00)
			runtime.panicindex(gs);
		else
		{
			runtime.open();
			if (dwArg08 <= 0x00)
				runtime.panicindex(gs);
			else
			{
				runtime.read();
				runtime.closefd();
				runtime.extendRandom(gs, mm0, dwArg04, dwArg08, dwLoc10);
			}
		}
	}
	else
	{
		if (dwArg08 <= ecx_18)
			ecx_18 = dwArg08;
		word128 xmm2_233;
		word128 xmm1_232;
		word128 xmm0_231;
		word32 edi_230;
		word32 esi_229;
		word32 ebp_228;
		runtime.memmove(dwArg04, eax_17, ecx_18, out ebp_228, out esi_229, out edi_230, out xmm0_231, out xmm1_232, out xmm2_233);
		runtime.extendRandom(gs, mm0, dwArg04, dwArg08, ecx_18);
	}
}

// 0806A4B0: void runtime.goenvs(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.schedinit
void runtime.goenvs(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.goenvs_unix(gs);
}

// 0806A4D0: void runtime.mpreinit(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      runtime.mcommoninit
void runtime.mpreinit(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.malg(gs, 0x8000);
	if (g_t81576F0 == 0x00)
		*((word32) dwArg04 + 44) = dwLoc08;
	else
		runtime.writebarrierptr((word32) dwArg04 + 44, dwLoc08);
	if (g_t81576F0 == 0x00)
		*((word32) dwLoc08 + 24) = dwArg04;
	else
		runtime.writebarrierptr((word32) dwLoc08 + 24, dwArg04);
}

// 0806A550: void runtime.minit(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.mstart1
//      runtime.needm
void runtime.minit(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.minitSignals(gs);
	runtime.gettid();
	Eq_4 eax_30 = *((word32) gs->ptr0000->tFFFFFFFC + 24);
	*((word32) eax_30 + 36) = dwLoc04;
	((word32) eax_30 + 40)->u0 = 0x00;
}

// 0806A5A0: void runtime.unminit(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.dropm
void runtime.unminit(struct Eq_2 * gs)
{
	runtime.unminitSignals(gs);
}

// 0806A5B0: Register word32 runtime.sigprocmask()
// Called from:
//      runtime.newosproc
//      runtime.msigsave
//      runtime.msigrestore
//      runtime.sigblock
//      runtime.unblocksig
//      runtime.minitSignalMask
word32 runtime.sigprocmask()
{
	return runtime.rtsigprocmask();
}

// 0806A5E0: void runtime.setsig(Stack word32 dwArg08)
// Called from:
//      runtime.initsig
//      runtime.dieFromSignal
//      runtime.raisebadsignal
void runtime.setsig(word32 dwArg08)
{
	fn0808FD8B(0x00, fp - 0x34);
	runtime.rt_sigaction();
}

// 0806A6F0: void runtime.setsigstack()
// Called from:
//      runtime.initsig
void runtime.setsigstack()
{
	fn0808FD8B(0x00, fp - 0x14);
	runtime.rt_sigaction();
	if ((dwLoc10 & 0x08000000) != 0x00)
		return;
	runtime.rt_sigaction();
}

// 0806A770: void runtime.getsig(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.initsig
void runtime.getsig(struct Eq_2 * gs)
{
	fn0808FD8B(0x00, fp - 0x14);
	runtime.rt_sigaction();
	if (dwLoc18 == 0x00)
		return;
	runtime.throw(gs);
}

// 0806A7D0: void runtime.panicCheckMalloc(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      runtime.panicindex
//      runtime.panicslice
//      runtime.panicdivide
//      runtime.panicoverflow
//      runtime.panicfloat
//      runtime.panicmem
void runtime.panicCheckMalloc(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 eax_17 = gs->ptr0000->tFFFFFFFC;
	if (eax_17 == 0x00)
		return;
	Eq_4 eax_21 = *((word32) eax_17 + 24);
	if (eax_21 == 0x00 || *((word32) eax_21 + 0x0068) == 0x00)
		return;
	if (dwArg04 != 0x08136690)
		runtime.panicdottypeI(gs, dwArg04);
	else
		runtime.throw(gs);
}

// 0806A860: void runtime.panicindex(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.cgocallbackg1
//      runtime.cgoIsGoPointer
//      runtime.cgoCheckTypedBlock
//      runtime.(*cpuProfile).addNonGo
//      runtime.(*cpuProfile).addExtra
//      runtime.makeBucketArray
//      runtime.evacuate
//      runtime.getitab
//      runtime.additab
//      runtime.mallocinit
//      runtime.(*mcache).nextFree
//      runtime.mallocgc
//      runtime.nextSample
//      runtime.gcmarkwb_m
//      runtime.markBitsForAddr
//      runtime.heapBitsForObject
//      runtime.bulkBarrierPreWrite
//      runtime.heapBitsSetTypeGCProg
//      runtime.progToPointerMask
//      runtime.allocmcache
//      runtime.(*mcache).refill
//      runtime.(*mcache).releaseAll
//      runtime.(*mcentral).cacheSpan
//      runtime.(*mcentral).grow
//      runtime.queuefinalizer
//      runtime.runfinq
//      runtime.SetFinalizer
//      runtime.findObject
//      runtime.(*gcControllerState).enlistWorker
//      runtime.gcMark
//      runtime.clearpools
//      runtime.itoaDiv
//      runtime.fmtNSAsMS
//      runtime.gcMarkRootCheck
//      runtime.markroot
//      runtime.gcDrain
//      runtime.gcDrainN
//      runtime.scanobject
//      runtime.greyobject
//      runtime.gcDumpObject
//      runtime.sweepone
//      runtime.(*mspan).sweep
//      runtime.(*gcSweepBuf).block
//      runtime.(*gcWork).put
//      runtime.(*gcWork).tryGet
//      runtime.(*gcWork).get
//      runtime.handoff
//      runtime.(*mheap).init
//      runtime.(*mheap).mapSpans
//      runtime.(*mheap).reclaim
//      runtime.(*mheap).alloc_m
//      runtime.(*mheap).allocSpanLocked
//      runtime.(*mheap).grow
//      runtime.(*mheap).freeSpanLocked
//      runtime.(*mheap).scavenge
//      runtime.addspecial
//      runtime.removespecial
//      runtime.(*gcBitsArena).tryAlloc
//      runtime.stkbucket
//      runtime.eqslice
//      runtime.flushmcache
//      runtime.purgecachedstats
//      runtime.netpoll
//      runtime.sysargs
//      runtime.sysauxv
//      runtime.getRandomData
//      runtime.testdefersizes
//      runtime.newdefer
//      runtime.printfloat
//      runtime.printuint
//      runtime.printhex
//      runtime.acquireSudog
//      runtime.releaseSudog
//      runtime.helpgc
//      runtime.stopTheWorldWithSema
//      runtime.forEachP
//      runtime.needm
//      runtime.findrunnable
//      runtime.sigprof
//      runtime.procresize
//      runtime.checkdead
//      runtime.retake
//      runtime.preemptall
//      runtime.schedtrace
//      runtime.runqputslow
//      runtime.(*profBuf).write
//      runtime.goargs
//      runtime.goenvs_unix
//      reflect.typelinks
//      runtime.extendRandom
//      runtime.sigInstallGoHandler
//      runtime.unblocksig
//      runtime.minitSignalMask
//      runtime.sigsend
//      runtime.signal_ignored
//      runtime.growslice
//      runtime.stackinit
//      runtime.stackpoolalloc
//      runtime.stackpoolfree
//      runtime.stackcacherefill
//      runtime.stackcacherelease
//      runtime.stackcache_clear
//      runtime.stackalloc
//      runtime.stackfree
//      runtime.adjustpointers
//      runtime.freeStackSpans
//      runtime.concatstrings
//      runtime.stringtoslicerune
//      runtime.rawbyteslice
//      runtime.rawruneslice
//      runtime.gostring
//      runtime.index
//      runtime.atoi
//      runtime.findnull
//      runtime.(*pcExpander).next
//      runtime.modulesinit
//      runtime.moduledataverify1
//      runtime.findfunc
//      runtime.pcvalue
//      runtime.funcname
//      runtime.funcnameFromNameoff
//      runtime.funcfile
//      runtime.funcline1
//      runtime.step
//      runtime.readvarint
//      runtime.deltimer
//      runtime.timerproc
//      runtime.siftupTimer
//      runtime.siftdownTimer
//      runtime.traceEvent
//      runtime.(*traceBuf).varint
//      runtime.(*traceStackTable).put
//      runtime.(*traceStackTable).find
//      runtime.(*traceAlloc).alloc
//      runtime.traceGoStart
//      runtime.gentraceback
//      runtime.tracebackCgoContext
//      runtime.gcallers
//      runtime.cgoContextPCs
//      runtime.(*_type).textOff
//      runtime.typelinksinit
//      runtime.typesEqual
//      runtime.decoderune
//      runtime.encoderune
//      runtime.writeErr
//      runtime.writebarrierptr_prewrite1.func1
//      runtime.newdefer.func1
//      runtime.newdefer.func2
//      runtime.freedefer.func1
//      runtime.callers.func1
//      unicode/utf8.DecodeRuneInString
//      unicode/utf8.EncodeRune
//      unicode/utf8.RuneCount
//      unicode/utf8.RuneCountInString
//      strconv.(*decimal).String
//      strconv.digitZero
//      strconv.trim
//      strconv.(*decimal).Assign
//      strconv.rightShift
//      strconv.prefixIsLessThan
//      strconv.leftShift
//      strconv.(*decimal).Round
//      strconv.(*decimal).RoundUp
//      strconv.(*extFloat).frexp10
//      strconv.frexp10Many
//      strconv.(*extFloat).FixedDecimal
//      strconv.adjustLastDigitFixed
//      strconv.(*extFloat).ShortestDecimal
//      strconv.adjustLastDigit
//      strconv.roundShortest
//      strconv.fmtE
//      strconv.fmtF
//      strconv.formatBits
//      strconv.appendQuotedWith
//      strconv.appendEscapedRune
//      strconv.bsearch16
//      strconv.bsearch32
//      strconv.IsPrint
//      strconv.isInGraphicList
//      sync.(*Pool).Get
//      sync.(*Pool).getSlow
//      sync.(*Pool).pinSlow
//      sync.poolCleanup
//      syscall.uitoa
//      syscall.ByteSliceFromString
//      syscall.BytePtrFromString
//      reflect.newName
//      reflect.Kind.String
//      reflect.(*rtype).Name
//      reflect.(*rtype).In
//      reflect.(*rtype).Out
//      reflect.(*interfaceType).MethodByName
//      reflect.(*structType).FieldByNameFunc
//      reflect.(*structType).FieldByName
//      reflect.implements
//      reflect.haveIdenticalUnderlyingType
//      reflect.typesByString
//      reflect.FuncOf
//      reflect.funcLayout
//      reflect.addTypeBits
//      reflect.methodReceiver
//      reflect.Value.MapKeys
//      reflect.Value.Type
//      reflect.(*sliceType).MethodByName
//      fmt.(*fmt).writePadding
//      fmt.(*fmt).fmt_unicode
//      fmt.(*fmt).fmt_integer
//      fmt.(*fmt).fmt_sbx
//      fmt.(*fmt).fmt_float
//      fmt.(*pp).printValue
void runtime.panicindex(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.panicCheckMalloc(gs, g_t8142638);
	runtime.gopanic(gs);
}

// 0806A8C0: void runtime.panicslice(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.(*cpuProfile).addNonGo
//      runtime.(*cpuProfile).addExtra
//      runtime.gogetenv
//      runtime.panicwrap
//      runtime.additab
//      runtime.progToPointerMask
//      runtime.SetFinalizer
//      runtime.(*mheap).mapSpans
//      runtime.stkbucket
//      runtime.mProf_Malloc
//      runtime.saveblockevent
//      runtime.getproccount
//      runtime.newdefer
//      runtime.recordForPanic
//      runtime.gwrite
//      runtime.printuint
//      runtime.acquireSudog
//      runtime.releaseSudog
//      runtime.forEachP
//      runtime.sigprof
//      runtime.(*profBuf).write
//      syscall.runtime_envs
//      os.runtime_args
//      runtime.parsedebugvars
//      runtime.adjustpointers
//      runtime.concatstrings
//      runtime.rawstringtmp
//      runtime.stringtoslicerune
//      runtime.slicerunetostring
//      runtime.intstring
//      runtime.(*stackExpander).next
//      runtime.(*pcExpander).next
//      runtime.pcvalue
//      runtime.step
//      runtime.deltimer
//      runtime.timerproc
//      runtime.traceStackID
//      runtime.(*traceStackTable).put
//      runtime.(*traceStackTable).find
//      runtime.(*_type).string
//      runtime.typesEqual
//      runtime.decoderune
//      runtime.freedefer.func1
//      strconv.(*decimal).String
//      strconv.leftShift
//      strconv.genericFtoa
//      strconv.fmtE
//      strconv.fmtF
//      strconv.FormatInt
//      strconv.formatBits
//      strconv.appendQuotedWith
//      strconv.appendEscapedRune
//      strconv.CanBackquote
//      internal/poll.(*FD).Write
//      os.Readlink
//      reflect.newName
//      reflect.(*rtype).String
//      reflect.(*rtype).exportedMethods
//      reflect.(*rtype).Method
//      reflect.(*rtype).Name
//      reflect.(*rtype).In
//      reflect.(*rtype).NumOut
//      reflect.(*rtype).Out
//      reflect.(*structType).FieldByNameFunc
//      reflect.implements
//      reflect.funcStr
//      reflect.funcLayout
//      reflect.methodReceiver
//      reflect.Value.MapKeys
//      reflect.Value.Type
//      reflect.(*sliceType).MethodByName
//      fmt.(*fmt).writePadding
//      fmt.(*fmt).pad
//      fmt.(*fmt).padString
//      fmt.(*fmt).fmt_unicode
//      fmt.(*fmt).fmt_integer
//      fmt.(*fmt).truncate
//      fmt.(*fmt).fmt_c
//      fmt.(*fmt).fmt_float
//      fmt.(*buffer).WriteRune
//      fmt.(*pp).Write
//      fmt.(*pp).unknownType
//      fmt.(*pp).badVerb
//      fmt.(*pp).fmtComplex
//      fmt.(*pp).fmtBytes
//      fmt.(*pp).fmtPointer
//      fmt.(*pp).catchPanic
//      fmt.(*pp).printValue
void runtime.panicslice(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.panicCheckMalloc(gs, g_t8142650);
	runtime.gopanic(gs);
}

// 0806A920: void runtime.panicdivide(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.makemap
//      runtime.makeBucketArray
//      runtime.heapBitsSetType
//      runtime.heapBitsSetTypeGCProg
//      runtime.runGCProg
//      runtime.(*mcentral).cacheSpan
//      runtime.(*mcentral).uncacheSpan
//      runtime.(*mcentral).grow
//      runtime.findObject
//      runtime.(*gcControllerState).enlistWorker
//      runtime.markrootSpans
//      runtime.(*mspan).sweep
//      runtime.findrunnable
//      runtime.globrunqget
//      runtime.(*profBuf).canWriteRecord
//      runtime.(*profBuf).canWriteTwoRecords
//      runtime.(*profBuf).write
//      runtime.sigpanic
//      runtime.uint64div
//      runtime.uint64mod
//      runtime.int64div
//      runtime.int64mod
//      runtime.dodiv
//      runtime.slowdodiv
//      strconv.(*extFloat).FixedDecimal
//      strconv.(*extFloat).ShortestDecimal
//      sync.(*Pool).getSlow
void runtime.panicdivide(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.panicCheckMalloc(gs, g_t8142628);
	runtime.gopanic(gs);
}

// 0806A980: void runtime.panicoverflow(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.sigpanic
void runtime.panicoverflow(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.panicCheckMalloc(gs, g_t8142648);
	runtime.gopanic(gs);
}

// 0806A9E0: void runtime.panicfloat(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.sigpanic
void runtime.panicfloat(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.panicCheckMalloc(gs, g_t8142630);
	runtime.gopanic(gs);
}

// 0806AA40: void runtime.panicmem(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.sigpanic
void runtime.panicmem(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.panicCheckMalloc(gs, g_t8142640);
	runtime.gopanic(gs);
}

// 0806AAA0: void runtime.throwinit(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.init
//      strconv.init
//      sync.init
//      io.init
//      syscall.init
//      time.init
//      internal/poll.init
//      os.init
//      unicode.init
//      reflect.init
//      fmt.init
//      main.init
void runtime.throwinit(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.throw(gs);
}

// 0806AAE0: Register word32 runtime.deferproc(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C, Register out ptr32 ebpOut, Register out ptr32 esiOut, Register out ptr32 ediOut)
// Called from:
//      runtime.cgocallbackg1
//      runtime.preprintpanics
//      runtime.main
//      sync.(*Once).Do
//      sync.(*Pool).pinSlow
//      internal/poll.(*FD).Write
//      reflect.FuncOf
//      fmt.(*pp).handleMethods
word32 runtime.deferproc(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C, ptr32 & ebpOut, ptr32 & esiOut, ptr32 & ediOut)
{
	Eq_4 eax_8 = gs->ptr0000->tFFFFFFFC;
	if (*((word32) *((word32) eax_8 + 24) + 84) != eax_8)
		runtime.throw(gs);
	else
	{
		runtime.getcallerpc();
		runtime.newdefer(gs, dwArg04);
		if (dwLoc18->dw0014 != 0x00)
			runtime.throw(gs);
		else
		{
			if (g_t81576F0 == 0x00)
				dwLoc18->t0010 = dwArg08;
			else
				runtime.writebarrierptr(&dwLoc18->t0010, dwArg08);
			dwLoc18->ptr000C = dwLoc18;
			dwLoc18->ptr0008 = fp + 0x04;
			if (dwArg04 != 0x00)
			{
				if (dwArg04 == 0x04)
				{
					union Eq_4 * eax_127;
					if (dwLoc18->dw0000 == 0x00)
						eax_127 = null;
					else
						eax_127 = (union Eq_4 *) (&dwLoc18->dw0014 + 2);
					*eax_127 = (union Eq_4 *) dwArg0C;
				}
				else
				{
					Eq_4 eax_88;
					if (dwLoc18->dw0000 == 0x00)
						eax_88.u0 = 0x00;
					else
						eax_88 = &dwLoc18->dw0014 + 2;
					word128 xmm2_244;
					word128 xmm1_243;
					word128 xmm0_242;
					runtime.memmove(eax_88, fp + 0x0C, dwArg04, out ebp, out esi, out edi, out xmm0_242, out xmm1_243, out xmm2_244);
				}
			}
			word32 eax_137 = runtime.return0();
			ebpOut = ebp;
			esiOut = esi;
			ediOut = edi;
			return eax_137;
		}
	}
}

// 0806AC10: void runtime.testdefersizes(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.mallocinit
void runtime.testdefersizes(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	fn0808FD8B(0x00, fp - 0x14);
	Eq_41581 eax_22 = 0x00;
	while (eax_22 < 0x05)
	{
		if (eax_22 >= 0x05)
			runtime.panicindex(gs);
		(fp - 0x14)[eax_22] = ~0x00;
		eax_22 = (word32) eax_22 + 1;
	}
	up32 eax_215 = 0x00;
	while (true)
	{
		uint32 ecx_35;
		if (eax_215 <= 0x04)
			ecx_35 = 0x00;
		else
			ecx_35 = eax_215 + 11 >> 0x04;
		if (ecx_35 >= 0x05)
			break;
		Eq_41606 edx_107;
		if (eax_215 <= 0x04)
			edx_107.u0 = 0x20;
		else
			edx_107 = eax_215 + 0x1C;
		if (edx_107 < 0x8000)
		{
			if (edx_107 <= 1016)
			{
				uint32 edx_86 = (word32) edx_107.u0 + 7;
				if (edx_86 >> 0x03 >= 0x81)
				{
l0806AE25:
					runtime.panicindex(gs);
				}
				uint32 edx_91 = (word32) (edx_86 >> 0x03)->b8138640;
				if (edx_91 >= 0x43)
					goto l0806AE25;
				edx_107 = (word32) g_a8138820[edx_91 * 0x02];
				goto l0806ACB8;
			}
			uint32 edx_68 = (word32) edx_107.u0 - 897;
			if (edx_68 >> 0x07 >= 0xF9)
			{
l0806AE1E:
				runtime.panicindex(gs);
			}
			uint32 edx_76 = (word32) (edx_68 >> 0x07)->b81396E0;
			if (edx_76 >= 0x43)
				goto l0806AE1E;
			edx_107 = (word32) g_a8138820[edx_76 * 0x02];
		}
		else if ((word32) edx_107.u0 + 0x00002000 >= edx_107)
			edx_107 = (word32) edx_107 + 0x00001FFF & ~0x1FFF;
l0806ACB8:
		Eq_41606 edi_103 = (fp - 0x14)[ecx_35];
		if (edi_103 < 0x00)
			(fp - 0x14)[ecx_35] = edx_107;
		else if (edi_103 != edx_107)
		{
			runtime.printlock(gs);
			runtime.printstring(gs);
			runtime.printint(0x00081386, gs, (uint64) eax_215);
			runtime.printstring(gs);
			runtime.printint(0x00081386, gs, (uint64) edx_107);
			runtime.printstring(gs);
			runtime.printint(0x00081386, gs, (uint64) ecx_35);
			runtime.printstring(gs);
			runtime.printunlock(gs);
			runtime.throw(gs);
		}
		++eax_215;
	}
}

// 0806AE40: void runtime.init.2(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.init
void runtime.init.2(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 eax_24 = g_t80C7160;
	if (g_t81576F0 == 0x00)
		runtime.deferType = eax_24;
	else
		runtime.writebarrierptr(0x08144FC4, eax_24);
}

// 0806AEB0: void runtime.newdefer(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      runtime.deferproc
void runtime.newdefer(struct Eq_2 * gs, Eq_4 dwArg04)
{
	uint32 ecx_10;
	Eq_4 dwLoc24_197 = 0x00;
	if (dwArg04 <= 0x04)
		ecx_10 = 0x00;
	else
		ecx_10 = (word32) dwArg04 + 11 >> 0x04;
	Eq_4 edx_19 = gs->ptr0000->tFFFFFFFC;
	if (ecx_10 < 0x05)
	{
		Eq_4 ebp_26 = *((word32) *((word32) edx_19 + 24) + 92);
		ui32 ebx_32 = ecx_10 * 0x03;
		if (*((word32) ebp_26 + (ebx_32 * 0x04 + 64)) == 0x00 && g_a8145440[ecx_10 * 0x04] != 0x00)
		{
			word32 edi_260;
			word32 ebp_259;
			runtime.systemstack(gs, fp - 0x0C, out ebp_259, out edi_260);
		}
		Eq_4 ecx_61 = *((word32) ebp_26 + (ebx_32 * 0x04 + 60));
		Eq_4 esi_62 = *((word32) ebp_26 + (ebx_32 * 0x04 + 64));
		if (esi_62 > 0x00)
		{
			if (esi_62 - 0x01 >= esi_62)
				runtime.panicindex(gs);
			dwLoc24_197 = (ecx_61 - 0x04)[esi_62];
			Eq_4 ecx_77 = *((word32) ebp_26 + (ebx_32 * 0x04 + 60));
			if (esi_62 - 0x01 >= *((word32) ebp_26 + (ebx_32 * 0x04 + 64)))
				runtime.panicindex(gs);
			Eq_4 edx_85 = ecx_77 - 0x04 + esi_62 * 0x04;
			if (g_t81576F0 == 0x00)
				(ecx_77 - 0x04)[esi_62] = 0x00;
			else
				runtime.writebarrierptr(edx_85, 0x00);
			if (esi_62 - 0x01 > *((word32) ebp_26 + (ebx_32 * 0x04 + 0x0044)))
				runtime.panicslice(gs);
			*((word32) ebp_26 + (ebx_32 * 0x04 + 64)) = esi_62 - 0x01;
		}
	}
	if (dwLoc24_197 == 0x00)
	{
		word32 ebp_261;
		word32 edi_262;
		runtime.systemstack(gs, fp - 0x18, out ebp_261, out edi_262);
	}
	*dwLoc24_197 = dwArg04;
	Eq_4 ebp_156 = *((word32) edx_19 + 20);
	if (g_t81576F0 == 0x00)
		*((word32) dwLoc24_197 + 24) = ebp_156;
	else
		runtime.writebarrierptr((word32) dwLoc24_197 + 24, ebp_156);
	if (g_t81576F0 == 0x00)
		*((word32) edx_19 + 20) = dwLoc24_197;
	else
		runtime.writebarrierptr((word32) edx_19 + 20, dwLoc24_197);
}

// 0806B090: void runtime.freedefer(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      runtime.deferreturn
//      runtime.gopanic
void runtime.freedefer(struct Eq_2 * gs, Eq_4 dwArg04)
{
	struct Eq_41900 * esp_105 = fp - 0x40;
	if (*((word32) dwArg04 + 20) != 0x00)
		runtime.freedeferpanic(gs);
	if (*((word32) dwArg04 + 16) != 0x00)
		runtime.freedeferfn(gs);
	uint32 eax_35;
	up32 ecx_31 = *dwArg04;
	if (ecx_31 <= 0x04)
		eax_35 = 0x00;
	else
		eax_35 = ecx_31 + 11 >> 0x04;
	if (eax_35 < 0x05)
	{
		Eq_4 edx_51 = *((word32) *((word32) gs->ptr0000->tFFFFFFFC + 24) + 92);
		ui32 ecx_58 = eax_35 * 0x03;
		if (*((word32) edx_51 + (ecx_58 * 0x04 + 64)) == *((word32) edx_51 + (ecx_58 * 0x04 + 0x0044)))
		{
			word32 edi_246;
			word32 ebp_245;
			runtime.systemstack(gs, fp - 0x0C, out ebp_245, out edi_246);
		}
		if (g_t81576F0 == 0x00)
		{
			fn0808FD89(0x00, dwArg04);
			esp_105 = fp - 0x44;
		}
		else
			runtime.typedmemclr(0x080D9160, dwArg04);
		ui32 eax_108 = esp_105->dw0024;
		Eq_4 edx_109 = edx_51;
		Eq_4 ecx_111 = *((word32) edx_51 + (eax_108 * 0x04 + 0x0044));
		Eq_4 ebx_112 = *((word32) edx_51 + (eax_108 * 0x04 + 64));
		Eq_4 ebp_113 = *((word32) edx_51 + (eax_108 * 0x04 + 60));
		if ((word32) ebx_112 + 1 > ecx_111)
		{
			esp_105->ptr0000 = 135033152;
			esp_105->t0004 = ebp_113;
			esp_105->t0008 = ebx_112;
			esp_105->t000C = ecx_111;
			esp_105->dw0010 = (word32) ebx_112 + 1;
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_4 stackArg4 = <invalid>;
			Eq_4 stackArg12 = <invalid>;
			Eq_4 stackArg16 = <invalid>;
			Eq_4 stackArg20 = <invalid>;
			word128 xmm0_252;
			word128 xmm1_253;
			word32 esi_251;
			runtime.growslice(gs, stackArg4, dwArg04, stackArg12, stackArg16, stackArg20, out esi_251, out xmm0_252, out xmm1_253);
			Eq_4 eax_129 = esp_105->t0014;
			Eq_4 ecx_130 = esp_105->t0018;
			ui32 ebx_132 = esp_105->dw0024;
			Eq_4 ebp_133 = esp_105->t0030;
			*((word32) ebp_133 + (ebx_132 * 0x04 + 0x0044)) = esp_105->t001C;
			if (g_t81576F0 == 0x00)
				*((word32) ebp_133 + (ebx_132 * 0x04 + 60)) = eax_129;
			else
			{
				esp_105->t0028 = eax_129;
				esp_105->t0020 = ecx_130;
				esp_105->ptr0000 = esp_105->ptr002C;
				esp_105->t0004 = eax_129;
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				Eq_4 stackArg4 = <invalid>;
				runtime.writebarrierptr(stackArg4, dwArg04);
				eax_129 = esp_105->t0028;
				ecx_130 = esp_105->t0020;
				ebx_132 = esp_105->dw0024;
				ebp_133 = esp_105->t0030;
			}
			edx_109 = ebp_133;
			ebp_113 = eax_129;
			eax_108 = ebx_132;
			ebx_112 = ecx_130;
		}
		*((word32) edx_109 + (eax_108 * 0x04 + 64)) = (word32) ebx_112 + 1;
		ptr32 ecx_168 = (word32) ebp_113 + ebx_112 * 0x04;
		if (g_t81576F0 == 0x00)
			*((word32) ebp_113 + ebx_112 * 0x04) = esp_105->t0044;
		else
		{
			esp_105->ptr0000 = ecx_168;
			esp_105->t0004 = esp_105->t0044;
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_4 stackArg4 = <invalid>;
			runtime.writebarrierptr(stackArg4, dwArg04);
		}
	}
}

// 0806B250: void runtime.freedeferpanic(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.freedefer
void runtime.freedeferpanic(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.throw(gs);
}

// 0806B290: void runtime.freedeferfn(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.freedefer
void runtime.freedeferfn(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.throw(gs);
}

// 0806B2D0: Register Eq_4 runtime.deferreturn(Register (ptr32 Eq_2) gs, Register out Eq_1912 xmm0Out, Register out Eq_1912 xmm1Out)
// Called from:
//      runtime.cgocallbackg1
//      runtime.preprintpanics
//      runtime.main
//      sync.(*Once).Do
//      sync.(*Pool).pinSlow
//      internal/poll.(*FD).Write
//      reflect.FuncOf
//      fmt.(*pp).handleMethods
Eq_4 runtime.deferreturn(struct Eq_2 * gs, union Eq_1912 & xmm0Out, union Eq_1912 & xmm1Out)
{
	Eq_4 eax_8 = gs->ptr0000->tFFFFFFFC;
	Eq_4 ecx_9 = *((word32) eax_8 + 20);
	if (ecx_9 == 0x00)
	{
		xmm0Out.u2 = <invalid>;
		xmm1Out.u2 = <invalid>;
		return esi;
	}
	else if (*((word32) ecx_9 + 8) != fp + 0x04)
	{
		xmm0Out.u2 = <invalid>;
		xmm1Out.u2 = <invalid>;
		return fp + 0x04;
	}
	else
	{
		Eq_4 ebx_26 = *ecx_9;
		if (ebx_26 != 0x00 && ebx_26 != 0x04)
		{
			word128 xmm2_246;
			word128 xmm0_244;
			word128 xmm1_245;
			word32 esi_242;
			word32 edi_243;
			word32 ebp_241;
			runtime.memmove(fp + 0x04, (word32) ecx_9 + 28, ebx_26, out ebp_241, out esi_242, out edi_243, out xmm0_244, out xmm1_245, out xmm2_246);
		}
		Eq_4 ebx_69 = *((word32) ecx_9 + 16);
		if (g_t81576F0 == 0x00)
			((word32) ecx_9 + 16)->u0 = 0x00;
		else
			runtime.writebarrierptr((word32) ecx_9 + 16, 0x00);
		Eq_4 esi_96 = g_t81576F0;
		Eq_4 edi_98 = *((word32) ecx_9 + 24);
		if (esi_96 == 0x00)
			*((word32) eax_8 + 20) = edi_98;
		else
			runtime.writebarrierptr((word32) eax_8 + 20, edi_98);
		runtime.freedefer(gs, ecx_9);
		runtime.jmpdefer(ebx_69, fp + 0x04);
		xmm0Out.u2 = <invalid>;
		xmm1Out.u2 = <invalid>;
		return esi_96;
	}
}

// 0806B3F0: void runtime.preprintpanics(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      runtime.gopanic
void runtime.preprintpanics(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	Eq_4 stackArg12 = <invalid>;
	word32 esi_258;
	word32 edi_259;
	word32 ebp_257;
	if (runtime.deferproc(gs, 0x00, 0x080E7CA4, stackArg12, out ebp_257, out esi_258, out edi_259) != 0x00)
	{
		word128 xmm0_260;
		word128 xmm1_261;
		runtime.deferreturn(gs, out xmm0_260, out xmm1_261);
	}
	else
	{
		Eq_4 eax_169 = dwArg04;
		while (eax_169 != 0x00)
		{
			Eq_4 ecx_48 = *((word32) eax_169 + 8);
			Eq_4 edx_49 = *((word32) eax_169 + 4);
			Eq_4 ebx_50 = (word32) eax_169 + 8;
			if (edx_49 != 0x00)
			{
				runtime.assertE2I2(gs, edx_49);
				if (bLoc20 != 0x00)
				{
					(*((word32) dwLoc28 + 20))();
					runtime.convT2Estring(gs, 135066016, fp - 0x08);
					*((word32) eax_169 + 4) = ecx_48;
					if (g_t81576F0 == 0x00)
						*((word32) eax_169 + 8) = dwLoc28;
					else
						runtime.writebarrierptr(ebx_50, dwLoc28);
				}
				else
				{
					runtime.assertE2I2(gs, edx_49);
					if (bLoc20 != 0x00)
					{
						(*((word32) dwLoc28 + 20))();
						runtime.convT2Estring(gs, 135066016, fp - 0x10);
						*((word32) eax_169 + 4) = ecx_48;
						if (g_t81576F0 == 0x00)
							*((word32) eax_169 + 8) = dwLoc28;
						else
							runtime.writebarrierptr(ebx_50, dwLoc28);
					}
				}
			}
			eax_169 = *((word32) eax_169 + 0x0C);
		}
		word128 xmm0_262;
		word128 xmm1_263;
		runtime.deferreturn(gs, out xmm0_262, out xmm1_263);
	}
}

// 0806B5A0: void runtime.printpanics(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      runtime.printpanics
//      runtime.gopanic
void runtime.printpanics(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 ecx_18 = *((word32) dwArg04 + 0x0C);
	if (ecx_18 != 0x00)
	{
		runtime.printpanics(gs, ecx_18);
		runtime.printlock(gs);
		runtime.printstring(gs);
		runtime.printunlock(gs);
	}
	runtime.printlock(gs);
	runtime.printstring(gs);
	runtime.printunlock(gs);
	runtime.printany(gs, xmm0, xmm1, *((word32) dwArg04 + 4), *((word32) dwArg04 + 8));
	if (*((word32) dwArg04 + 16) != 0x00)
	{
		runtime.printlock(gs);
		runtime.printstring(gs);
		runtime.printunlock(gs);
	}
	runtime.printlock(gs);
	runtime.printstring(gs);
	runtime.printunlock(gs);
}

// 0806B690: void runtime.gopanic(Register (ptr32 Eq_2) gs)
// Called from:
//      sync/atomic.(*Value).Store
//      runtime.interhash
//      runtime.nilinterhash
//      runtime.efaceeq
//      runtime.ifaceeq
//      runtime.makechan
//      runtime.chansend
//      runtime.closechan
//      runtime.panicwrap
//      runtime.mapassign
//      runtime.mapassign_fast32
//      runtime.mapassign_fast64
//      runtime.mapassign_faststr
//      runtime.getitab
//      runtime.additab
//      runtime.panicdottypeE
//      runtime.assertE2I
//      runtime.newarray
//      runtime.panicindex
//      runtime.panicslice
//      runtime.panicdivide
//      runtime.panicoverflow
//      runtime.panicfloat
//      runtime.panicmem
//      runtime.badreflectcall
//      runtime.(*semaRoot).queue
//      runtime.sigpanic
//      runtime.makeslice
//      runtime.growslice
//      strconv.(*extFloat).FixedDecimal
//      strconv.adjustLastDigitFixed
//      strconv.genericFtoa
//      strconv.formatBits
//      sync.(*Mutex).Lock
//      sync.(*Mutex).Unlock
//      internal/poll.(*fdMutex).increfAndClose
//      internal/poll.(*fdMutex).decref
//      internal/poll.(*fdMutex).rwlock
//      internal/poll.(*fdMutex).rwunlock
//      internal/poll.convertErr
//      reflect.makeMethodValue
//      reflect.newName
//      reflect.(*rtype).Method
//      reflect.(*rtype).ChanDir
//      reflect.(*rtype).Elem
//      reflect.(*rtype).In
//      reflect.(*rtype).Key
//      reflect.(*rtype).Len
//      reflect.(*rtype).NumIn
//      reflect.(*rtype).NumOut
//      reflect.(*rtype).Out
//      reflect.(*structType).Field
//      reflect.FuncOf
//      reflect.funcLayout
//      reflect.Value.pointer
//      reflect.packEface
//      reflect.flag.mustBe
//      reflect.flag.mustBeAssignable
//      reflect.Value.Bytes
//      reflect.Value.runes
//      reflect.methodReceiver
//      reflect.Value.Complex
//      reflect.Value.Elem
//      reflect.Value.Field
//      reflect.Value.Float
//      reflect.Value.Index
//      reflect.Value.Int
//      reflect.Value.CanInterface
//      reflect.valueInterface
//      reflect.Value.IsNil
//      reflect.Value.Len
//      reflect.Value.NumMethod
//      reflect.Value.Pointer
//      reflect.Value.SetBytes
//      reflect.Value.setRunes
//      reflect.Value.Slice
//      reflect.Value.Type
//      reflect.Value.Uint
//      reflect.Zero
//      reflect.New
//      reflect.Value.assignTo
//      reflect.(*sliceType).Bits
//      reflect.(*sliceType).IsVariadic
//      reflect.(*sliceType).Field
//      reflect.(*sliceType).FieldByIndex
//      reflect.(*sliceType).FieldByName
//      reflect.(*sliceType).FieldByNameFunc
//      reflect.(*sliceType).NumField
//      reflect.(*sliceType).Implements
//      reflect.(*sliceType).AssignableTo
//      reflect.(*sliceType).ConvertibleTo
//      fmt.(*fmt).fmt_integer
//      fmt.(*pp).catchPanic
void runtime.gopanic(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 ecx_18 = gs->ptr0000->tFFFFFFFC;
	Eq_4 edx_19 = *((word32) ecx_18 + 24);
	if (*((word32) edx_19 + 84) != ecx_18)
	{
		runtime.printlock(gs);
		runtime.printstring(gs);
		runtime.printunlock(gs);
		runtime.printany(gs, xmm0, xmm1, dwArg04, dwArg08);
		runtime.printlock(gs);
		runtime.printstring(gs);
		runtime.printunlock(gs);
		runtime.throw(gs);
	}
	else if (*((word32) edx_19 + 0x007C) != 0x00)
	{
		--*((word32) edx_19 + 0x0078);
		((word32) *((word32) ecx_18 + 24) + 0x007C)->u0 = 0x00;
		runtime.throw(gs);
	}
	else if (*((word32) edx_19 + 0x0068) != 0x00)
	{
		runtime.printlock(gs);
		runtime.printstring(gs);
		runtime.printunlock(gs);
		runtime.printany(gs, xmm0, xmm1, dwArg04, dwArg08);
		runtime.printlock(gs);
		runtime.printstring(gs);
		runtime.printunlock(gs);
		runtime.throw(gs);
	}
	else if (*((word32) edx_19 + 116) != 0x00)
	{
		runtime.printlock(gs);
		runtime.printstring(gs);
		runtime.printunlock(gs);
		runtime.printany(gs, xmm0, xmm1, dwArg04, dwArg08);
		runtime.printlock(gs);
		runtime.printstring(gs);
		runtime.printunlock(gs);
		runtime.printlock(gs);
		runtime.printstring(gs);
		runtime.printunlock(gs);
		runtime.printlock(gs);
		runtime.printstring(gs);
		runtime.printunlock(gs);
		runtime.printlock(gs);
		runtime.printstring(gs);
		runtime.printunlock(gs);
		runtime.throw(gs);
	}
	else if (*((word32) edx_19 + 0x0078) != 0x00)
	{
		runtime.printlock(gs);
		runtime.printstring(gs);
		runtime.printunlock(gs);
		runtime.printany(gs, xmm0, xmm1, dwArg04, dwArg08);
		runtime.printlock(gs);
		runtime.printstring(gs);
		runtime.printunlock(gs);
		runtime.throw(gs);
	}
	else
	{
		fn0808FD8B(0x00, fp - 0x14);
		Eq_4 edx_295 = *((word32) ecx_18 + 16);
		if (g_t81576F0 == 0x00)
			*((word32) ecx_18 + 16) = fp - 0x14;
		else
			runtime.writebarrierptr((word32) ecx_18 + 16, fp - 0x14);
		runtime/internal/atomic.Xadd(0x08157638, 0x01);
		while (true)
		{
			Eq_4 ecx_326 = *((word32) ecx_18 + 20);
			if (ecx_326 == 0x00)
				break;
			if (*((word32) ecx_326 + 4) == 0x00)
			{
				((word32) ecx_326 + 4)->u0 = 0x01;
				if (g_t81576F0 == 0x00)
					*((word32) ecx_326 + 20) = fp - 0x14;
				else
					runtime.writebarrierptr((word32) ecx_326 + 20, fp - 0x14);
				runtime.getargp();
				Eq_4 ecx_397 = *ecx_326;
				runtime.reflectcall(ecx_397);
				if (*((word32) ecx_18 + 20) != ecx_326)
					runtime.throw(gs);
				else
				{
					if (g_t81576F0 == 0x00)
					{
						((word32) ecx_326 + 20)->u0 = 0x00;
						((word32) ecx_326 + 16)->u0 = 0x00;
					}
					else
					{
						runtime.writebarrierptr((word32) ecx_326 + 20, 0x00);
						runtime.writebarrierptr((word32) ecx_326 + 16, 0x00);
					}
					Eq_4 ebx_467 = *((word32) ecx_326 + 24);
					if (g_t81576F0 == 0x00)
						*((word32) ecx_18 + 20) = ebx_467;
					else
						runtime.writebarrierptr((word32) ecx_18 + 20, ebx_467);
					Eq_4 ecx_485 = *((word32) ecx_326 + 0x0C);
					Eq_4 edx_488 = *((word32) ecx_326 + 8);
					runtime.freedefer(gs, ecx_326);
					if (bLoc04 == 0x00)
						continue;
					runtime/internal/atomic.Xadd(0x08157638, ~0x00);
					if (g_t81576F0 == 0x00)
						*((word32) ecx_18 + 16) = edx_295;
					else
						runtime.writebarrierptr((word32) ecx_18 + 16, edx_295);
					while (true)
					{
						Eq_4 ecx_528 = *((word32) ecx_18 + 16);
						if (ecx_528 == 0x00 || *((word32) ecx_528 + 0x0011) == 0x00)
							break;
						Eq_4 ecx_579 = *((word32) ecx_528 + 0x0C);
						if (g_t81576F0 == 0x00)
							*((word32) ecx_18 + 16) = ecx_579;
						else
							runtime.writebarrierptr((word32) ecx_18 + 16, ecx_579);
					}
					if (ecx_528 == 0x00)
						((word32) ecx_18 + 0x008C)->u0 = 0x00;
					*((word32) ecx_18 + 0x009C) = edx_488;
					*((word32) ecx_18 + 0x00A0) = ecx_485;
					word32 esi_914;
					runtime.mcall(gs, dwLoc54, &g_dw80E7CAC, out esi_914);
					Eq_4 esp_563 = <invalid>;
					*esp_563 = 0x080E23B0;
					((word32) esp_563 + 4)->u0 = 0x0F;
					runtime.throw(gs);
				}
			}
			Eq_4 ebx_592 = *((word32) ecx_326 + 20);
			if (ebx_592 != 0x00)
				*((word32) ebx_592 + 0x0011) = 0x01;
			if (g_t81576F0 == 0x00)
			{
				((word32) ecx_326 + 20)->u0 = 0x00;
				((word32) ecx_326 + 16)->u0 = 0x00;
			}
			else
			{
				runtime.writebarrierptr((word32) ecx_326 + 20, 0x00);
				runtime.writebarrierptr((word32) ecx_326 + 16, 0x00);
			}
			Eq_4 ebp_630 = *((word32) ecx_326 + 24);
			if (g_t81576F0 == 0x00)
				*((word32) ecx_18 + 20) = ebp_630;
			else
				runtime.writebarrierptr((word32) ecx_18 + 20, ebp_630);
			runtime.freedefer(gs, ecx_326);
		}
		runtime.preprintpanics(gs, *((word32) ecx_18 + 16));
		runtime.startpanic();
		runtime/internal/atomic.Xadd(0x08157638, ~0x00);
		runtime.printpanics(gs, *((word32) ecx_18 + 16));
		runtime.dopanic(gs);
		null = (union Eq_4 *) 0x00;
	}
}

// 0806BCE0: void runtime.getargp()
// Called from:
//      runtime.gopanic
void runtime.getargp()
{
}

// 0806BCF0: void runtime.gorecover(Register (ptr32 Eq_2) gs, Stack ptr32 dwArg04)
// Called from:
//      runtime.preprintpanics.func1
//      fmt.(*pp).catchPanic
void runtime.gorecover(struct Eq_2 * gs, ptr32 dwArg04)
{
	Eq_4 eax_8 = *((word32) gs->ptr0000->tFFFFFFFC + 16);
	if (eax_8 == 0x00 || (*((word32) eax_8 + 16) != 0x00 || dwArg04 != *eax_8))
		return;
	((word32) eax_8 + 16)->u0 = 0x01;
}

// 0806BD40: void runtime.startpanic()
// Called from:
//      runtime.gopanic
//      runtime.throw
//      runtime.sighandler
void runtime.startpanic()
{
	word32 ebp_18;
	word32 edi_19;
	runtime.systemstack(gs, 0x080E7CD8, out ebp_18, out edi_19);
}

// 0806BD60: void runtime.dopanic(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.gopanic
//      runtime.throw
//      runtime.startpanic_m
void runtime.dopanic(struct Eq_2 * gs)
{
	runtime.getcallerpc();
	word32 ebp_44;
	word32 edi_45;
	runtime.systemstack(gs, fp - 0x10, out ebp_44, out edi_45);
	null = (union Eq_4 *) 0x00;
}

// 0806BDC0: void runtime.throw(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.cgocall
//      runtime.cgoCheckUsingType
//      runtime.makechan
//      runtime.chansend
//      runtime.chanrecv
//      runtime.gogetenv
//      runtime.panicwrap
//      runtime.makemap
//      runtime.mapaccess2
//      runtime.mapassign
//      runtime.mapiternext
//      runtime.hashGrow
//      runtime.evacuate
//      runtime.mapaccess1_fast32
//      runtime.mapaccess2_fast32
//      runtime.mapaccess2_fast64
//      runtime.mapassign_fast32
//      runtime.mapassign_fast64
//      runtime.mapassign_faststr
//      runtime.getitab
//      runtime.additab
//      runtime.(*lfstack).push
//      runtime.lock
//      runtime.unlock
//      runtime.notewakeup
//      runtime.notesleep
//      runtime.notetsleep
//      runtime.notetsleepg
//      runtime.mallocinit
//      runtime.(*mheap).sysAlloc
//      runtime.(*mcache).nextFree
//      runtime.mallocgc
//      runtime.largeAlloc
//      runtime.persistentalloc1
//      runtime.(*mspan).nextFreeIndex
//      runtime.heapBitsForSpan
//      runtime.heapBitsForObject
//      runtime.bulkBarrierPreWrite
//      runtime.typeBitsBulkBarrier
//      runtime.heapBits.initSpan
//      runtime.heapBitsSetType
//      runtime.heapBitsSetTypeGCProg
//      runtime.progToPointerMask
//      runtime.(*mcache).refill
//      runtime.(*mcentral).cacheSpan
//      runtime.(*mcentral).uncacheSpan
//      runtime.(*mcentral).freeSpan
//      runtime.sysUnused
//      runtime.sysMap
//      runtime.queuefinalizer
//      runtime.runfinq
//      runtime.SetFinalizer
//      runtime.(*fixalloc).alloc
//      runtime.(*gcControllerState).findRunnableGCWorker
//      runtime.gcSetTriggerRatio
//      runtime.gcMarkTermination
//      runtime.gcBgMarkWorker
//      runtime.gcMark
//      runtime.gcSweep
//      runtime.gchelperstart
//      runtime.(*mTreap).insert
//      runtime.(*mTreap).removeNode
//      runtime.(*mTreap).remove
//      runtime.(*mTreap).rotateLeft
//      runtime.(*mTreap).rotateRight
//      runtime.gcMarkRootCheck
//      runtime.markroot
//      runtime.markrootSpans
//      runtime.gcAssistAlloc1
//      runtime.scanstack
//      runtime.scanframeworker
//      runtime.gcDrain
//      runtime.gcDrainN
//      runtime.scanobject
//      runtime.greyobject
//      runtime.gcmarknewobject
//      runtime.sweepone
//      runtime.(*mspan).ensureSwept
//      runtime.(*mspan).sweep
//      runtime.(*gcSweepBuf).block
//      runtime.(*workbuf).checknonempty
//      runtime.(*workbuf).checkempty
//      runtime.getempty
//      runtime.getfull
//      runtime.prepareFreeWorkbufs
//      runtime.recordspan
//      runtime.(*mheap).alloc_m
//      runtime.(*mheap).allocSpanLocked
//      runtime.(*mheap).freeSpanLocked
//      runtime.(*mSpanList).remove
//      runtime.(*mSpanList).insert
//      runtime.(*mSpanList).insertBack
//      runtime.addspecial
//      runtime.removespecial
//      runtime.setprofilebucket
//      runtime.freespecial
//      runtime.newMarkBits
//      runtime.newArenaMayUnlock
//      runtime.newBucket
//      runtime.(*bucket).mp
//      runtime.(*bucket).bp
//      runtime.stkbucket
//      runtime.init.1
//      internal/poll.runtime_pollOpen
//      internal/poll.runtime_pollClose
//      internal/poll.runtime_pollUnblock
//      runtime.netpollblock
//      runtime.netpollinit
//      runtime.netpoll
//      runtime.newosproc
//      runtime.getsig
//      runtime.panicCheckMalloc
//      runtime.throwinit
//      runtime.deferproc
//      runtime.testdefersizes
//      runtime.freedeferpanic
//      runtime.freedeferfn
//      runtime.gopanic
//      runtime.recovery
//      runtime.main
//      runtime.forcegchelper
//      runtime.gopark
//      runtime.acquireSudog
//      runtime.releaseSudog
//      runtime.badmcall
//      runtime.badmcall2
//      runtime.badctxt
//      runtime.allgadd
//      runtime.schedinit
//      runtime.checkmcount
//      runtime.ready
//      runtime.helpgc
//      runtime.casfrom_Gscanstatus
//      runtime.castogscanstatus
//      runtime.casgstatus
//      runtime.scang
//      runtime.restartg
//      runtime.stopTheWorldWithSema
//      runtime.startTheWorldWithSema
//      runtime.mstart1
//      runtime.forEachP
//      runtime.newm
//      runtime.stopm
//      runtime.startm
//      runtime.stoplockedm
//      runtime.startlockedm
//      runtime.gcstopm
//      runtime.findrunnable
//      runtime.resetspinning
//      runtime.schedule
//      runtime.goschedImpl
//      runtime.goexit0
//      runtime.exitsyscall
//      runtime.newproc1
//      runtime.gfput
//      runtime.badunlockosthread
//      runtime.procresize
//      runtime.acquirep1
//      runtime.releasep
//      runtime.checkdead
//      runtime.pidleput
//      runtime.runqputslow
//      runtime.runqsteal
//      runtime.(*profBuf).write
//      runtime.testAtomic64
//      runtime.check
//      runtime.(*rwmutex).runlock
//      runtime.semacquire1
//      runtime.semrelease1
//      runtime.(*semaRoot).rotateLeft
//      runtime.(*semaRoot).rotateRight
//      sync.runtime_notifyListCheck
//      runtime.sigpanic
//      runtime.noSignalStack
//      runtime.sigNotOnStack
//      runtime.signalDuringFork
//      runtime.sigsend
//      runtime.stackpoolalloc
//      runtime.stackpoolfree
//      runtime.stackalloc
//      runtime.stackfree
//      runtime.adjustpointers
//      runtime.adjustframe
//      runtime.copystack
//      runtime.newstack
//      runtime.shrinkstack
//      runtime.concatstrings
//      runtime.rawruneslice
//      runtime.badsystemstack
//      runtime.moduledataverify1
//      runtime.findfunc
//      runtime.pcvalue
//      runtime.stackmapdata
//      runtime.traceEvent
//      runtime.traceFlush
//      runtime.(*traceAlloc).alloc
//      runtime.traceGCSweepStart
//      runtime.traceGCSweepDone
//      runtime.tracebackdefers
//      runtime.gentraceback
//      runtime.getArgInfo
//      runtime.resolveNameOff
//      runtime.resolveTypeOff
//      runtime.(*_type).textOff
//      runtime.typesEqual
//      runtime.cgoCheckWriteBarrier.func1
//      runtime.cgoCheckTypedBlock.func2
//      runtime.cgoCheckBits.func1
//      runtime.writebarrierptr_prewrite1.func1
//      runtime.writebarrierptr.func1
//      runtime.writebarrierptr_prewrite.func1
//      runtime.SetFinalizer.func2
//      runtime.gcBgMarkWorker.func2
//      runtime.preprintpanics.func1
//      runtime.casgstatus.func1
//      runtime.casgstatus.func2
//      runtime.reentersyscall.func1
//      runtime.entersyscallblock.func1
//      runtime.entersyscallblock.func2
//      runtime.exitsyscall.func1
//      runtime.morestackc.func1
void runtime.throw(struct Eq_2 * gs)
{
	runtime.printlock(gs);
	runtime.printstring(gs);
	runtime.printstring(gs);
	runtime.printstring(gs);
	runtime.printunlock(gs);
	Eq_4 eax_34 = *((word32) gs->ptr0000->tFFFFFFFC + 24);
	if (*((word32) eax_34 + 0x006C) == 0x00)
		((word32) eax_34 + 0x006C)->u0 = 0x01;
	runtime.startpanic();
	runtime.dopanic(gs);
	null = (union Eq_4 *) 0x00;
}

// 0806BE50: void runtime.recovery(Register Eq_4 esi, Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_42929) dwArg04)
void runtime.recovery(Eq_4 esi, struct Eq_2 * gs, struct Eq_42929 * dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 ecx_18 = dwArg04->t009C;
	word32 edx_19 = dwArg04->dw00A0;
	if (ecx_18 != 0x00)
	{
		Eq_4 ebx_24 = dwArg04->t0000;
		if (ecx_18 < ebx_24 || dwArg04->t0004 < ecx_18)
		{
			Eq_4 eax_33 = dwArg04->t0004;
			runtime.printlock(gs);
			runtime.printstring(gs);
			Eq_4 esi_65;
			runtime.printhex(esi, gs, ecx_18, 0x00, out esi_65);
			runtime.printstring(gs);
			Eq_4 esi_89;
			runtime.printhex(esi_65, gs, ebx_24, 0x00, out esi_89);
			runtime.printstring(gs);
			word32 esi_202;
			runtime.printhex(esi_89, gs, eax_33, 0x00, out esi_202);
			runtime.printstring(gs);
			runtime.printunlock(gs);
			runtime.throw(gs);
		}
	}
	dwArg04->t001C = ecx_18;
	dwArg04->dw0020 = edx_19;
	dwArg04->dw0030 = 0x00;
	dwArg04->dw002C = 0x01;
	runtime.gogo(gs, &dwArg04->t001C);
}

// 0806BF80: void runtime.startpanic_m(Register Eq_4 esi, Register (ptr32 Eq_2) gs)
void runtime.startpanic_m(Eq_4 esi, struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 eax_18 = gs->ptr0000->tFFFFFFFC;
	if (g_dw814B564 != 0x00)
	{
		if (*((word32) *((word32) eax_18 + 24) + 0x00B8) == 0x00)
		{
			esi = runtime.allocmcache(esi, gs);
			*((word32) *((word32) eax_18 + 24) + 0x00B8) = dwLoc10;
		}
	}
	else
	{
		runtime.printlock(gs);
		runtime.printstring(gs);
		runtime.printunlock(gs);
		((word32) *((word32) eax_18 + 24) + 0x0068)->u0 = 0x01;
	}
	Eq_4 ecx_76 = *((word32) eax_18 + 24);
	struct Eq_43073 * edx_77 = *((word32) ecx_76 + 0x0080);
	if (edx_77 == null)
	{
		*((word32) ecx_76 + 0x0080) = (struct Eq_43073 *) 0x01;
		((word32) eax_18 + 0x0094)->u0 = 0x00;
		((word32) eax_18 + 0x0098)->u0 = 0x00;
		if (g_t81576F0 == 0x00)
			*((word32) eax_18 + 144) = 0x00;
		else
			runtime.writebarrierptr((word32) eax_18 + 144, 0x00);
		runtime/internal/atomic.Xadd(0x08157618, 0x01);
		Eq_4 esi_204;
		word32 edi_326;
		runtime.lock(esi, gs, 135624220, out esi_204, out edi_326);
		if (g_t8157754 > 0x00 || g_dw8157750 > 0x00)
			runtime.schedtrace(esi_204, gs, &g_t8157601, bLoc08);
		runtime.freezetheworld(gs);
		return;
	}
	if (edx_77 != (struct Eq_43073 *) 0x01)
	{
		if (edx_77 != (struct Eq_43073 *) 0x02)
			goto l0806C0B3;
	}
	else
	{
		*((word32) ecx_76 + 0x0080) = (struct Eq_43073 *) 0x02;
		runtime.printlock(gs);
		runtime.printstring(gs);
		runtime.printunlock(gs);
		runtime.dopanic(gs);
		runtime.exit();
	}
	*((word32) *((word32) eax_18 + 24) + 0x0080) = (struct Eq_43073 *) 0x03;
	runtime.printlock(gs);
	runtime.printstring(gs);
	runtime.printunlock(gs);
	runtime.exit();
l0806C0B3:
	runtime.exit();
}

// 0806C170: void runtime.dopanic_m(Register Eq_4 esi, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      runtime.dopanic.func1
void runtime.dopanic_m(Eq_4 esi, struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 ecx_18 = *((word32) dwArg04 + 0x008C);
	if (ecx_18 != 0x00)
	{
		word32 ebx_26;
		if (ecx_18 >= 0x41)
			ebx_26 = 0x00;
		else
		{
			esi.u0 = 0x08144820;
			ebx_26 = (word32) g_a8144828[ecx_18];
		}
		if (ebx_26 != 0x00)
		{
			runtime.printlock(gs);
			runtime.printstring(gs);
			runtime.printstring(gs);
			runtime.printunlock(gs);
		}
		else
		{
			runtime.printlock(gs);
			runtime.printstring(gs);
			runtime.printhex(esi, gs, ecx_18, 0x00, out esi);
			runtime.printunlock(gs);
		}
		Eq_4 ecx_120 = *((word32) dwArg04 + 0x009C);
		Eq_4 edx_122 = *((word32) dwArg04 + 0x00A0);
		Eq_4 ebx_124 = *((word32) dwArg04 + 0x00A4);
		runtime.printlock(gs);
		runtime.printstring(gs);
		Eq_4 esi_153;
		runtime.printhex(esi, gs, ecx_120, 0x00, out esi_153);
		runtime.printstring(gs);
		Eq_4 esi_177;
		runtime.printhex(esi_153, gs, edx_122, 0x00, out esi_177);
		runtime.printstring(gs);
		runtime.printhex(esi_177, gs, ebx_124, 0x00, out esi);
		runtime.printstring(gs);
		runtime.printunlock(gs);
		dwLoc30.u1 = 0x080E0E0F;
		bLoc2C = 0x02;
		bLoc2B = 0x00;
	}
	runtime.gotraceback(dwLoc34);
	Eq_4 ebx_240 = gs->ptr0000->tFFFFFFFC;
	if (dwLoc30 > 0x00)
	{
		Eq_4 esi_246 = *((word32) dwArg04 + 24);
		Eq_4 edi_247 = *((word32) esi_246 + 84);
		esi = *esi_246;
		if (esi == dwArg04)
		{
			if (dwLoc30 >= 0x02 || *((word32) (*((word32) ebx_240 + 24)) + 0x006C) > 0x00)
			{
				runtime.printlock(gs);
				runtime.printstring(gs);
				runtime.printunlock(gs);
				runtime.traceback(gs);
				dwLoc28 = 0x00;
			}
		}
		else
		{
			runtime.printlock(gs);
			runtime.printstring(gs);
			runtime.printunlock(gs);
			esi = runtime.goroutineheader(gs, dwArg04);
			runtime.traceback(gs);
			dwLoc28 = 0x00;
		}
		if (g_b8157568 == 0x00 && ((int8) (edi_247 != dwArg04) | bLoc2C) != 0x00)
		{
			g_b8157568 = 0x01;
			esi = runtime.tracebackothers(esi, gs, dwArg04);
		}
	}
	word32 edx_594;
	word32 ebx_595;
	runtime.unlock(gs, 135624220, out edx_594, out ebx_595);
	runtime/internal/atomic.Xadd(0x08157618, ~0x00);
	if (dwLoc28 != 0x00)
	{
		Eq_4 esi_420;
		word32 edi_596;
		runtime.lock(esi, gs, 0x081575B0, out esi_420, out edi_596);
		word32 edi_598;
		word32 esi_597;
		runtime.lock(esi_420, gs, 0x081575B0, out esi_597, out edi_598);
	}
	if (bLoc2B != 0x00)
		runtime.crash(gs);
	runtime.exit();
}

// 0806C4B0: void runtime.canpanic(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      runtime.sigpanic
void runtime.canpanic(struct Eq_2 * gs, Eq_4 dwArg04)
{
	Eq_4 eax_9 = *((word32) gs->ptr0000->tFFFFFFFC + 24);
	if (dwArg04 == 0x00 || dwArg04 != *((word32) eax_9 + 84))
		return;
	if (*((word32) eax_9 + 0x0078) - *((word32) eax_9 + 0x007C) != 0x00 || (*((word32) eax_9 + 0x0068) != 0x00 || (*((word32) eax_9 + 0x006C) != 0x00 || (*((word32) eax_9 + 116) != 0x00 || *((word32) eax_9 + 0x0080) != null))))
		return;
	runtime.readgstatus(dwArg04);
	if ((dwLoc04 & ~0x1000) == 0x02 && *((word32) dwArg04 + 56) == 0x00)
		;
}

// 0806C550: void runtime.recordForPanic(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg08, Stack Eq_43430 dwArg0C, Stack Eq_4 dwArg10)
// Called from:
//      runtime.gwrite
void runtime.recordForPanic(struct Eq_2 * gs, Eq_4 dwArg08, Eq_43430 dwArg0C, Eq_4 dwArg10)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.printlock(gs);
	runtime/internal/atomic.Load();
	if (dwLoc0C == 0x00)
	{
		Eq_43430 eax_125;
		for (eax_125 = 0x00; eax_125 < dwArg0C; eax_125 += ecx_66)
		{
			uint32 edx_48 = runtime.printBacklogIndex;
			if (edx_48 > 0x0200)
			{
l0806C633:
				runtime.panicslice(gs);
			}
			Eq_4 ebx_52 = 0x0200 - edx_48;
			ui32 ebx_56 = -ebx_52 >> 0x1F & edx_48;
			if (eax_125 > dwArg0C)
				goto l0806C633;
			Eq_4 ecx_66 = dwArg0C - eax_125;
			Eq_4 esi_79 = (word32) dwArg08 + (eax_125 - dwArg10 >> 0x1F & eax_125);
			if (ebx_52 <= ecx_66)
				ecx_66 = ebx_52;
			word128 xmm2_238;
			word128 xmm1_237;
			word128 xmm0_236;
			word32 edi_235;
			word32 esi_234;
			word32 ebp_233;
			runtime.memmove(ebx_56 + 0x08157B80, esi_79, ecx_66, out ebp_233, out esi_234, out edi_235, out xmm0_236, out xmm1_237, out xmm2_238);
			int32 eax_115 = (word32) ecx_66 + runtime.printBacklogIndex;
			runtime.printBacklogIndex = eax_115 - __align(((eax_115 >> 0x1F) >> 0x17) + eax_115, 0x0200);
		}
	}
	runtime.printunlock(gs);
}

// 0806C650: void runtime.printlock(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.cgocallbackg
//      runtime.printany
//      runtime.makemap
//      runtime.(*lfstack).push
//      runtime.notewakeup
//      runtime.mallocinit
//      runtime.(*mheap).sysAlloc
//      runtime.(*mcache).nextFree
//      runtime.heapBitsForSpan
//      runtime.heapBitsForObject
//      runtime.typeBitsBulkBarrier
//      runtime.heapBitsSetType
//      runtime.heapBitsSetTypeGCProg
//      runtime.sysAlloc
//      runtime.sysMap
//      runtime.(*fixalloc).alloc
//      runtime.(*gcControllerState).startCycle
//      runtime.(*gcControllerState).endCycle
//      runtime.gcSetTriggerRatio
//      runtime.gcMarkTermination
//      runtime.gcBgMarkWorker
//      runtime.(*mTreap).insert
//      runtime.gcMarkRootCheck
//      runtime.markrootSpans
//      runtime.gcAssistAlloc1
//      runtime.scanstack
//      runtime.scanframeworker
//      runtime.greyobject
//      runtime.gcDumpObject
//      runtime.sweepone
//      runtime.(*mspan).sweep
//      runtime.getfull
//      runtime.(*mheap).grow
//      runtime.(*mheap).freeSpanLocked
//      runtime.(*mheap).scavenge
//      runtime.(*mSpanList).remove
//      runtime.(*mSpanList).insert
//      runtime.(*mSpanList).insertBack
//      runtime.tracealloc
//      runtime.tracefree
//      runtime.tracegc
//      runtime.init.1
//      runtime.mSysStatInc
//      runtime.mSysStatDec
//      runtime.netpollinit
//      runtime.netpoll
//      runtime.newosproc
//      runtime.testdefersizes
//      runtime.printpanics
//      runtime.gopanic
//      runtime.throw
//      runtime.recovery
//      runtime.startpanic_m
//      runtime.dopanic_m
//      runtime.recordForPanic
//      runtime.printsp
//      runtime.printnl
//      runtime.printbool
//      runtime.printfloat
//      runtime.printcomplex
//      runtime.printint
//      runtime.printslice
//      runtime.printeface
//      runtime.forcegchelper
//      runtime.dumpgstatus
//      runtime.checkmcount
//      runtime.casfrom_Gscanstatus
//      runtime.castogscanstatus
//      runtime.casgstatus
//      runtime.stoplockedm
//      runtime.goexit0
//      runtime.acquirep1
//      runtime.releasep
//      runtime.checkdead
//      runtime.schedtrace
//      sync.runtime_notifyListCheck
//      runtime.dumpregs
//      runtime.sighandler
//      runtime.sigpanic
//      runtime.noSignalStack
//      runtime.sigNotOnStack
//      runtime.signalDuringFork
//      runtime.stackfree
//      runtime.adjustpointers
//      runtime.adjustframe
//      runtime.newstack
//      runtime.moduledataverify1
//      runtime.pcvalue
//      runtime.funcspdelta
//      runtime.tracebackdefers
//      runtime.gentraceback
//      runtime.getArgInfo
//      runtime.tracebackCgoContext
//      runtime.printcreatedby
//      runtime.traceback1
//      runtime.goroutineheader
//      runtime.tracebackothers
//      runtime.printCgoTraceback
//      runtime.printOneCgoTraceback
//      runtime.resolveNameOff
//      runtime.resolveTypeOff
//      runtime.(*_type).textOff
//      runtime.typesEqual
//      runtime.cgoCheckWriteBarrier.func1
//      runtime.writebarrierptr.func1
//      runtime.futexwakeup.func1
//      runtime.casgstatus.func1
//      runtime.reentersyscall.func1
//      runtime.entersyscallblock.func1
//      runtime.entersyscallblock.func2
//      internal/poll.convertErr
void runtime.printlock(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 eax_19 = *((word32) gs->ptr0000->tFFFFFFFC + 24);
	*((word32) eax_19 + 0x0078) = (word32) *((word32) eax_19 + 0x0078) + 1;
	word32 ecx_23 = (word32) *((word32) eax_19 + 144);
	*((word32) eax_19 + 144) = (byte) ecx_23 + 0x01;
	if ((byte) ecx_23 == 0x00)
	{
		word32 esi_58;
		word32 edi_59;
		runtime.lock(esi, gs, 135624116, out esi_58, out edi_59);
	}
	--*((word32) eax_19 + 0x0078);
}

// 0806C6C0: Register word32 runtime.printunlock(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.cgocallbackg
//      runtime.printany
//      runtime.makemap
//      runtime.(*lfstack).push
//      runtime.notewakeup
//      runtime.mallocinit
//      runtime.(*mheap).sysAlloc
//      runtime.(*mcache).nextFree
//      runtime.heapBitsForSpan
//      runtime.heapBitsForObject
//      runtime.typeBitsBulkBarrier
//      runtime.heapBitsSetType
//      runtime.heapBitsSetTypeGCProg
//      runtime.sysAlloc
//      runtime.sysMap
//      runtime.(*fixalloc).alloc
//      runtime.(*gcControllerState).startCycle
//      runtime.(*gcControllerState).endCycle
//      runtime.gcSetTriggerRatio
//      runtime.gcMarkTermination
//      runtime.gcBgMarkWorker
//      runtime.(*mTreap).insert
//      runtime.gcMarkRootCheck
//      runtime.markrootSpans
//      runtime.gcAssistAlloc1
//      runtime.scanstack
//      runtime.scanframeworker
//      runtime.greyobject
//      runtime.gcDumpObject
//      runtime.sweepone
//      runtime.(*mspan).sweep
//      runtime.getfull
//      runtime.(*mheap).grow
//      runtime.(*mheap).freeSpanLocked
//      runtime.(*mheap).scavenge
//      runtime.(*mSpanList).remove
//      runtime.(*mSpanList).insert
//      runtime.(*mSpanList).insertBack
//      runtime.tracealloc
//      runtime.tracefree
//      runtime.tracegc
//      runtime.init.1
//      runtime.mSysStatInc
//      runtime.mSysStatDec
//      runtime.netpollinit
//      runtime.netpoll
//      runtime.newosproc
//      runtime.testdefersizes
//      runtime.printpanics
//      runtime.gopanic
//      runtime.throw
//      runtime.recovery
//      runtime.startpanic_m
//      runtime.dopanic_m
//      runtime.recordForPanic
//      runtime.printsp
//      runtime.printnl
//      runtime.printbool
//      runtime.printfloat
//      runtime.printcomplex
//      runtime.printint
//      runtime.printslice
//      runtime.printeface
//      runtime.forcegchelper
//      runtime.dumpgstatus
//      runtime.checkmcount
//      runtime.casfrom_Gscanstatus
//      runtime.castogscanstatus
//      runtime.casgstatus
//      runtime.stoplockedm
//      runtime.goexit0
//      runtime.acquirep1
//      runtime.releasep
//      runtime.checkdead
//      runtime.schedtrace
//      sync.runtime_notifyListCheck
//      runtime.dumpregs
//      runtime.sighandler
//      runtime.sigpanic
//      runtime.noSignalStack
//      runtime.sigNotOnStack
//      runtime.signalDuringFork
//      runtime.stackfree
//      runtime.adjustpointers
//      runtime.adjustframe
//      runtime.newstack
//      runtime.moduledataverify1
//      runtime.pcvalue
//      runtime.funcspdelta
//      runtime.tracebackdefers
//      runtime.gentraceback
//      runtime.getArgInfo
//      runtime.tracebackCgoContext
//      runtime.printcreatedby
//      runtime.traceback1
//      runtime.goroutineheader
//      runtime.tracebackothers
//      runtime.printCgoTraceback
//      runtime.printOneCgoTraceback
//      runtime.resolveNameOff
//      runtime.resolveTypeOff
//      runtime.(*_type).textOff
//      runtime.typesEqual
//      runtime.cgoCheckWriteBarrier.func1
//      runtime.writebarrierptr.func1
//      runtime.futexwakeup.func1
//      runtime.casgstatus.func1
//      runtime.reentersyscall.func1
//      runtime.entersyscallblock.func1
//      runtime.entersyscallblock.func2
//      internal/poll.convertErr
word32 runtime.printunlock(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 eax_19 = *((word32) gs->ptr0000->tFFFFFFFC + 24);
	word32 ecx_20 = (word32) *((word32) eax_19 + 144);
	*((word32) eax_19 + 144) = (byte) ecx_20 - 0x01;
	if ((byte) ecx_20 == 0x01)
	{
		word32 edx_47;
		word32 ebx_48;
		ecx_20 = runtime.unlock(gs, 135624116, out edx_47, out ebx_48);
	}
	return ecx_20;
}

// 0806C720: void runtime.gwrite(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
// Called from:
//      runtime.printfloat
//      runtime.printuint
//      runtime.printhex
//      runtime.printstring
void runtime.gwrite(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (dwArg08 == 0x00)
		return;
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	Eq_4 stackArg16 = <invalid>;
	runtime.recordForPanic(gs, dwArg08, dwArg0C, stackArg16);
	Eq_4 eax_33 = gs->ptr0000->tFFFFFFFC;
	if (eax_33 != 0x00)
	{
		Eq_4 ecx_37 = *((word32) eax_33 + 0x0098);
		Eq_4 edx_38 = *((word32) eax_33 + 0x0094);
		Eq_43102 ebx_39 = *((word32) eax_33 + 144);
		if (ebx_39 != 0x00)
		{
			if (edx_38 > ecx_37)
				runtime.panicslice(gs);
			else
			{
				Eq_4 ecx_65 = ecx_37 - edx_38;
				Eq_4 ecx_70 = (word32) ebx_39.u1 + (edx_38 & -ecx_65 >> 0x1F);
				Eq_4 edx_71 = dwArg08;
				if (ecx_65 <= dwArg08)
					edx_71 = ecx_65;
				word128 xmm2_232;
				word128 xmm0_230;
				word128 xmm1_231;
				word32 esi_228;
				word32 edi_229;
				word32 ebp_227;
				runtime.memmove(ecx_70, dwArg04, edx_71, out ebp_227, out esi_228, out edi_229, out xmm0_230, out xmm1_231, out xmm2_232);
				word32 ecx_107 = Mem82[eax_33 + 0x94:word32] + edx_71;
				if (ecx_107 > *((word32) eax_33 + 0x0098))
					runtime.panicslice(gs);
				else
				{
					*((word32) eax_33 + 0x0094) = ecx_107;
					return;
				}
			}
		}
	}
	runtime.writeErr(gs, dwArg08);
}

// 0806C830: void runtime.printsp(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.makemap
//      runtime.mallocinit
//      runtime.(*mcache).nextFree
//      runtime.typeBitsBulkBarrier
//      runtime.heapBitsSetType
//      runtime.heapBitsSetTypeGCProg
//      runtime.gcBgMarkWorker
//      runtime.(*mTreap).insert
//      runtime.gcMarkRootCheck
//      runtime.gcAssistAlloc1
//      runtime.getfull
//      runtime.(*mSpanList).insert
//      runtime.(*mSpanList).insertBack
//      runtime.init.1
//      runtime.netpollinit
//      runtime.netpoll
//      runtime.noSignalStack
//      runtime.sigNotOnStack
//      runtime.signalDuringFork
//      runtime.stackfree
//      runtime.moduledataverify1
//      runtime.resolveNameOff
//      runtime.resolveTypeOff
//      runtime.(*_type).textOff
//      runtime.typesEqual
//      runtime.cgoCheckWriteBarrier.func1
//      internal/poll.convertErr
void runtime.printsp(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.printlock(gs);
	runtime.printstring(gs);
	runtime.printunlock(gs);
}

// 0806C870: void runtime.printnl(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.cgocallbackg
//      runtime.makemap
//      runtime.mallocinit
//      runtime.(*mcache).nextFree
//      runtime.typeBitsBulkBarrier
//      runtime.heapBitsSetType
//      runtime.heapBitsSetTypeGCProg
//      runtime.gcBgMarkWorker
//      runtime.(*mTreap).insert
//      runtime.gcMarkRootCheck
//      runtime.gcAssistAlloc1
//      runtime.getfull
//      runtime.(*mSpanList).insert
//      runtime.(*mSpanList).insertBack
//      runtime.init.1
//      runtime.netpollinit
//      runtime.netpoll
//      runtime.newosproc
//      runtime.forcegchelper
//      runtime.noSignalStack
//      runtime.sigNotOnStack
//      runtime.signalDuringFork
//      runtime.stackfree
//      runtime.moduledataverify1
//      runtime.printOneCgoTraceback
//      runtime.resolveNameOff
//      runtime.resolveTypeOff
//      runtime.(*_type).textOff
//      runtime.typesEqual
//      runtime.cgoCheckWriteBarrier.func1
//      internal/poll.convertErr
void runtime.printnl(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.printlock(gs);
	runtime.printstring(gs);
	runtime.printunlock(gs);
}

// 0806C8B0: void runtime.printbool(Register (ptr32 Eq_2) gs, Stack Eq_4 bArg04)
// Called from:
//      runtime.printany
//      runtime.gcMarkRootCheck
//      runtime.gcAssistAlloc1
//      runtime.schedtrace
void runtime.printbool(struct Eq_2 * gs, Eq_4 bArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (bArg04 != 0x00)
	{
		runtime.printlock(gs);
		runtime.printstring(gs);
		runtime.printunlock(gs);
	}
	else
	{
		runtime.printlock(gs);
		runtime.printstring(gs);
		runtime.printunlock(gs);
	}
}

// 0806C920: Register uint128 runtime.printfloat(Register (ptr32 Eq_2) gs, Register Eq_662 xmm2, Stack Eq_5187 rArg04, Register out Eq_662 xmm2Out)
// Called from:
//      runtime.printany
//      runtime.(*gcControllerState).startCycle
//      runtime.(*gcControllerState).endCycle
//      runtime.gcSetTriggerRatio
//      runtime.sweepone
//      runtime.printcomplex
uint128 runtime.printfloat(struct Eq_2 * gs, Eq_662 xmm2, Eq_5187 rArg04, union Eq_662 & xmm2Out)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	uint128 xmm0_17 = (uint128) rArg04;
	if ((real64) xmm0_17 != (real64) xmm0_17 || PARITY_EVEN((real64) xmm0_17 - (real64) xmm0_17))
	{
		runtime.printlock(gs);
		runtime.printstring(gs);
		runtime.printunlock(gs);
		xmm2Out = xmm2;
		return xmm0_17;
	}
	else
	{
		Eq_662 xmm2_187;
		real64 v14_45 = (real64) xmm0_17 + (real64) xmm0_17;
		Eq_43806 xmm1_139 = SEQ(SLICE(xmm1, word64, 64), (real64) xmm0_17);
		uint128 xmm0_47 = SEQ(SLICE(xmm0_17, word64, 64), v14_45);
		bool v51_348 = (real64) xmm0_17 != v14_45;
		bool v54_351 = PARITY_EVEN((real64) xmm0_17 - v14_45);
		if ((real64) xmm0_17 == v14_45 && !PARITY_EVEN((real64) xmm0_17 - v14_45))
		{
			xmm2_187 = __xorps(xmm2, xmm2);
			if ((real64) xmm0_17 > (real64) xmm2_187)
			{
				runtime.printlock(gs);
				runtime.printstring(gs);
				runtime.printunlock(gs);
				xmm2Out = xmm2_187;
				return xmm0_47;
			}
			v51_348 = (real64) xmm0_17 != v14_45;
			v54_351 = PARITY_EVEN((real64) xmm0_17 - v14_45);
		}
		else
			xmm2_187 = __xorps(xmm2, xmm2);
		if (v51_348 || (v54_351 || (real64) xmm2_187 <= (real64) xmm0_17))
		{
			uint128 xmm0_144;
			int32 eax_202;
			if ((real64) xmm2_187 == (real64) xmm0_17 && !PARITY_EVEN((real64) xmm2_187 - (real64) xmm0_17))
			{
				uint128 xmm0_203 = (uint128) g_r80F1858;
				Eq_43881 v19_204 = (real64) xmm0_203 / (real64) xmm0_17;
				xmm0_144 = SEQ(SLICE(xmm0_203, word64, 64), v19_204);
				eax_202 = 0x00;
			}
			else
			{
				if ((real64) xmm2_187 > (real64) xmm0_17)
					xmm1_139 = __pxor(xmm1_139, (uint128) g_r80F1890);
				int32 eax_140 = 0x00;
				while (true)
				{
					xmm0_144 = (uint128) g_r80F1870;
					if ((real64) xmm1_139 < (real64) xmm0_144)
						break;
					++eax_140;
					xmm1_139 = SEQ(SLICE(xmm1_139, word64, 64), (real64) xmm1_139 / (real64) xmm0_144);
				}
				while ((real64) (uint128) g_r80F1858 > (real64) xmm1_139)
				{
					--eax_140;
					xmm1_139 = SEQ(SLICE(xmm1_139, word64, 64), (real64) xmm1_139 * (real64) xmm0_144);
				}
				int32 ecx_170;
				uint128 xmm2_173 = (uint128) g_r80F1868;
				for (ecx_170 = 0x00; ecx_170 < 0x07; ++ecx_170)
					xmm2_173 = SEQ(SLICE(xmm2_173, word64, 64), (real64) xmm2_173 / (real64) xmm0_144);
				int32 ecx_193;
				Eq_43981 v39_185 = (real64) xmm2_173 + (real64) xmm1_139;
				word64 v40_186 = SLICE(xmm2_173, word64, 64);
				xmm2_187 = SEQ(v40_186, v39_185);
				if (v39_185 >= (real64) xmm0_144)
				{
					ecx_193 = eax_140 + 0x01;
					xmm2_187 = SEQ(v40_186, v39_185 /64 (real64) xmm0_144);
				}
				else
					ecx_193 = eax_140;
				xmm1_139 = SEQ(SLICE(xmm1_139, word64, 64), (real64) xmm2_187);
				eax_202 = ecx_193;
			}
			byte * ecx_215;
			for (ecx_215 = null; ecx_215 < (byte *) 0x07; ++ecx_215)
			{
				if (ecx_215 >= (byte *) ~0x0B)
					runtime.panicindex(gs);
				int32 edx_294 = (int32) (real64) xmm1_139;
				Mem298[ecx_215 + 0x02 + (fp - 0x0E):byte] = SLICE(edx_294, byte, 0) + 0x30;
				xmm0_144 = (uint128) g_r80F1870;
				xmm1_139 = SEQ(SLICE(xmm1_139, word64, 64), ((real64) xmm1_139 - (real64) edx_294) * (real64) xmm0_144);
			}
			runtime.gwrite(gs, fp - (byte *) 0x0E, 0x0E);
			xmm2Out = xmm2_187;
			return xmm0_144;
		}
		else
		{
			runtime.printlock(gs);
			runtime.printstring(gs);
			runtime.printunlock(gs);
			xmm2Out = xmm2_187;
			return xmm0_47;
		}
	}
}

// 0806CBB0: void runtime.printcomplex(Register (ptr32 Eq_2) gs, Stack real64 rArg04, Stack real64 rArg0C)
// Called from:
//      runtime.printany
void runtime.printcomplex(struct Eq_2 * gs, real64 rArg04, real64 rArg0C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.printlock(gs);
	runtime.printstring(gs);
	word128 xmm2_64;
	runtime.printfloat(gs, xmm2, (real64) (uint128) rArg04, out xmm2_64);
	word128 xmm2_65;
	runtime.printfloat(gs, xmm2, (real64) (uint128) rArg0C, out xmm2_65);
	runtime.printstring(gs);
	runtime.printunlock(gs);
}

// 0806CC30: Register Eq_4 runtime.printuint(Register Eq_4 ebp, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
// Called from:
//      runtime.printany
//      runtime.(*gcControllerState).startCycle
//      runtime.(*gcControllerState).endCycle
//      runtime.gcSetTriggerRatio
//      runtime.gcMarkTermination
//      runtime.sweepone
//      runtime.(*mheap).grow
//      runtime.(*mheap).scavenge
//      runtime.printint
Eq_4 runtime.printuint(Eq_4 ebp, struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	fn0808FD77(0x00, fp - 100);
	Eq_44052 eax_105;
	Eq_4 ecx_108 = dwArg04;
	Eq_4 edx_107 = dwArg08;
	for (eax_105 = 99; eax_105 > 0x00; --eax_105)
	{
		ui24 edx_24_8_72 = SLICE(runtime.uint64mod(gs, ecx_108, edx_107, 0x0A, 0x00), word24, 8);
		byte al_53 = (byte) dwLoc70 + 0x30;
		if (eax_105 >= 100)
			runtime.panicindex(gs);
		Mem54[fp - 100 + eax_105:byte] = al_53;
		ui24 ebx_24_8_68 = SLICE(ebp, word24, 8);
		Eq_4 ebp_85 = SEQ(ebx_24_8_68, (int8) Test(ULT,false)) | SEQ(edx_24_8_72, (int8) (edx_107 == 0x00)) & SEQ(ebx_24_8_68, (int8) (ecx_108 < 0x0A));
		ebp = ebp_85;
		if ((byte) ebp_85 != 0x00)
			break;
		runtime.uint64div(gs, ecx_108, edx_107, 0x0A, 0x00);
		edx_107 = dwLoc6C;
		ecx_108 = dwLoc70;
	}
	if (eax_105 > 100)
		runtime.panicslice(gs);
	else
	{
		Eq_4 eax_119 = 100 - eax_105;
		runtime.gwrite(gs, fp - 100 + (eax_105 & -eax_119 >> 0x1F), eax_119);
		return <invalid>;
	}
}

// 0806CD60: void runtime.printint(Register word24 ebx_24_8, Register (ptr32 Eq_2) gs, Stack Eq_4 qwArg04)
// Called from:
//      runtime.printany
//      runtime.makemap
//      runtime.notewakeup
//      runtime.mallocinit
//      runtime.(*mcache).nextFree
//      runtime.heapBitsForObject
//      runtime.typeBitsBulkBarrier
//      runtime.heapBitsSetTypeGCProg
//      runtime.(*gcControllerState).startCycle
//      runtime.(*gcControllerState).endCycle
//      runtime.gcMarkTermination
//      runtime.gcBgMarkWorker
//      runtime.(*mTreap).insert
//      runtime.gcMarkRootCheck
//      runtime.markrootSpans
//      runtime.gcAssistAlloc1
//      runtime.scanstack
//      runtime.scanframeworker
//      runtime.gcDumpObject
//      runtime.sweepone
//      runtime.(*mspan).sweep
//      runtime.getfull
//      runtime.(*mheap).grow
//      runtime.(*mheap).freeSpanLocked
//      runtime.(*mheap).scavenge
//      runtime.(*mSpanList).remove
//      runtime.init.1
//      runtime.mSysStatInc
//      runtime.mSysStatDec
//      runtime.netpollinit
//      runtime.netpoll
//      runtime.newosproc
//      runtime.testdefersizes
//      runtime.printslice
//      runtime.dumpgstatus
//      runtime.checkmcount
//      runtime.goexit0
//      runtime.acquirep1
//      runtime.releasep
//      runtime.checkdead
//      runtime.schedtrace
//      sync.runtime_notifyListCheck
//      runtime.sighandler
//      runtime.noSignalStack
//      runtime.sigNotOnStack
//      runtime.signalDuringFork
//      runtime.adjustframe
//      runtime.newstack
//      runtime.pcvalue
//      runtime.funcspdelta
//      runtime.gentraceback
//      runtime.printcreatedby
//      runtime.goroutineheader
//      runtime.printOneCgoTraceback
//      runtime.typesEqual
//      runtime.futexwakeup.func1
//      internal/poll.convertErr
void runtime.printint(word24 ebx_24_8, struct Eq_2 * gs, Eq_4 qwArg04)
{
	Eq_4 dwArg08 = SLICE(qwArg04, word32, 32);
	Eq_4 dwArg04 = (word32) qwArg04;
	while (true)
	{
		Eq_4 ecx_7 = gs->ptr0000->tFFFFFFFC;
		if (fp > *((word32) ecx_7 + 8))
			break;
		runtime.morestack_noctxt();
	}
	Eq_4 eax_17 = dwArg08;
	Eq_4 edx_21 = dwArg04;
	if (((int8) (dwArg08 < 0x00) | (int8) (dwArg08 == 0x00) & (int8) Test(ULT,false)) != 0x00)
	{
		runtime.printlock(gs);
		runtime.printstring(gs);
		runtime.printunlock(gs);
		eax_17 = SLICE(0x00 - qwArg04, word32, 32);
		edx_21 = 0x00 - dwArg04;
	}
	runtime.printuint(ebp, gs, edx_21, eax_17);
}

// 0806CDF0: Register Eq_4 runtime.printhex(Register Eq_4 esi, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Register out Eq_1912 esiOut)
// Called from:
//      runtime.(*lfstack).push
//      runtime.mallocinit
//      runtime.(*mheap).sysAlloc
//      runtime.heapBitsForSpan
//      runtime.heapBitsForObject
//      runtime.scanstack
//      runtime.scanframeworker
//      runtime.greyobject
//      runtime.gcDumpObject
//      runtime.(*mheap).freeSpanLocked
//      runtime.tracealloc
//      runtime.tracefree
//      runtime.recovery
//      runtime.dopanic_m
//      runtime.printpointer
//      runtime.casfrom_Gscanstatus
//      runtime.castogscanstatus
//      runtime.casgstatus
//      runtime.dumpregs
//      runtime.sighandler
//      runtime.sigpanic
//      runtime.stackfree
//      runtime.adjustpointers
//      runtime.adjustframe
//      runtime.newstack
//      runtime.moduledataverify1
//      runtime.pcvalue
//      runtime.funcspdelta
//      runtime.tracebackdefers
//      runtime.gentraceback
//      runtime.tracebackCgoContext
//      runtime.printcreatedby
//      runtime.printCgoTraceback
//      runtime.printOneCgoTraceback
//      runtime.resolveNameOff
//      runtime.resolveTypeOff
//      runtime.(*_type).textOff
//      runtime.cgoCheckWriteBarrier.func1
//      runtime.writebarrierptr.func1
//      runtime.casgstatus.func1
//      runtime.reentersyscall.func1
//      runtime.entersyscallblock.func1
//      runtime.entersyscallblock.func2
Eq_4 runtime.printhex(Eq_4 esi, struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, union Eq_1912 & esiOut)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	fn0808FD77(0x00, fp - 100);
	Eq_4 ecx_22 = dwArg08;
	Eq_4 edx_23 = dwArg04;
	byte * eax_24;
	for (eax_24 = (byte *) 99; eax_24 > null; --eax_24)
	{
		word32 edx_33 = (word32) (edx_23 & 0x0F)->b80E2469;
		byte dl_42 = (byte) edx_33;
		ui24 edx_24_8_60 = SLICE(edx_33, word24, 8);
		if (eax_24 >= (byte *) 100)
			runtime.panicindex(gs);
		Mem43[fp - 100 + eax_24:byte] = dl_42;
		ui24 ebx_24_8_56 = SLICE(esi, word24, 8);
		Eq_4 esi_73 = SEQ(ebx_24_8_56, (int8) Test(ULT,false)) | SEQ(edx_24_8_60, (int8) (ecx_22 == 0x00)) & SEQ(ebx_24_8_56, (int8) (edx_23 < 0x10));
		esi = esi_73;
		if ((byte) esi_73 != 0x00)
			break;
		edx_23 = ecx_22 << 0x1C | edx_23 >> 0x04;
		ecx_22 >>= 0x04;
	}
	if (eax_24 >= (byte *) 101)
		runtime.panicindex(gs);
	else
	{
		Mem101[fp - 101 + eax_24:byte] = 0x78;
		byte * ecx_102 = eax_24 - (byte *) 0x02;
		if (ecx_102 >= (byte *) 100)
			runtime.panicindex(gs);
		else
		{
			Mem109[fp - 0x66 + eax_24:byte] = 0x30;
			Eq_4 eax_111 = -(eax_24 + -0x0066);
			runtime.gwrite(gs, fp - 100 + (ecx_102 & -eax_111 >> 0x1F), eax_111);
			esiOut.u2 = <invalid>;
			return <invalid>;
		}
	}
}

// 0806CED0: void runtime.printpointer(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.(*lfstack).push
//      runtime.sysMap
//      runtime.(*mTreap).insert
//      runtime.gcMarkRootCheck
//      runtime.scanstack
//      runtime.(*mheap).freeSpanLocked
//      runtime.(*mSpanList).remove
//      runtime.(*mSpanList).insert
//      runtime.(*mSpanList).insertBack
//      runtime.tracealloc
//      runtime.tracefree
//      runtime.printslice
//      runtime.printeface
//      runtime.dumpgstatus
//      runtime.casfrom_Gscanstatus
//      runtime.releasep
//      runtime.stackfree
//      runtime.adjustpointers
//      runtime.newstack
//      runtime.gentraceback
//      runtime.writebarrierptr.func1
//      runtime.futexwakeup.func1
void runtime.printpointer(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	word32 esi_36;
	runtime.printhex(esi, gs, dwArg04, 0x00, out esi_36);
}

// 0806CF10: void runtime.printstring(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.cgocallbackg
//      runtime.printany
//      runtime.makemap
//      runtime.(*lfstack).push
//      runtime.notewakeup
//      runtime.mallocinit
//      runtime.(*mheap).sysAlloc
//      runtime.(*mcache).nextFree
//      runtime.heapBitsForSpan
//      runtime.heapBitsForObject
//      runtime.typeBitsBulkBarrier
//      runtime.heapBitsSetType
//      runtime.heapBitsSetTypeGCProg
//      runtime.sysAlloc
//      runtime.sysMap
//      runtime.(*fixalloc).alloc
//      runtime.(*gcControllerState).startCycle
//      runtime.(*gcControllerState).endCycle
//      runtime.gcSetTriggerRatio
//      runtime.gcMarkTermination
//      runtime.gcBgMarkWorker
//      runtime.(*mTreap).insert
//      runtime.gcMarkRootCheck
//      runtime.markrootSpans
//      runtime.gcAssistAlloc1
//      runtime.scanstack
//      runtime.scanframeworker
//      runtime.greyobject
//      runtime.gcDumpObject
//      runtime.sweepone
//      runtime.(*mspan).sweep
//      runtime.getfull
//      runtime.(*mheap).grow
//      runtime.(*mheap).freeSpanLocked
//      runtime.(*mheap).scavenge
//      runtime.(*mSpanList).remove
//      runtime.(*mSpanList).insert
//      runtime.(*mSpanList).insertBack
//      runtime.tracealloc
//      runtime.tracefree
//      runtime.tracegc
//      runtime.mSysStatInc
//      runtime.mSysStatDec
//      runtime.netpollinit
//      runtime.netpoll
//      runtime.newosproc
//      runtime.testdefersizes
//      runtime.printpanics
//      runtime.gopanic
//      runtime.throw
//      runtime.recovery
//      runtime.startpanic_m
//      runtime.dopanic_m
//      runtime.printsp
//      runtime.printnl
//      runtime.printbool
//      runtime.printfloat
//      runtime.printcomplex
//      runtime.printint
//      runtime.printslice
//      runtime.printeface
//      runtime.forcegchelper
//      runtime.dumpgstatus
//      runtime.checkmcount
//      runtime.casfrom_Gscanstatus
//      runtime.castogscanstatus
//      runtime.casgstatus
//      runtime.stoplockedm
//      runtime.goexit0
//      runtime.acquirep1
//      runtime.releasep
//      runtime.checkdead
//      runtime.schedtrace
//      sync.runtime_notifyListCheck
//      runtime.dumpregs
//      runtime.sighandler
//      runtime.sigpanic
//      runtime.noSignalStack
//      runtime.sigNotOnStack
//      runtime.signalDuringFork
//      runtime.adjustpointers
//      runtime.adjustframe
//      runtime.newstack
//      runtime.moduledataverify1
//      runtime.pcvalue
//      runtime.funcspdelta
//      runtime.tracebackdefers
//      runtime.gentraceback
//      runtime.getArgInfo
//      runtime.tracebackCgoContext
//      runtime.printcreatedby
//      runtime.traceback1
//      runtime.goroutineheader
//      runtime.tracebackothers
//      runtime.printCgoTraceback
//      runtime.printOneCgoTraceback
//      runtime.resolveNameOff
//      runtime.resolveTypeOff
//      runtime.(*_type).textOff
//      runtime.typesEqual
//      runtime.cgoCheckWriteBarrier.func1
//      runtime.writebarrierptr.func1
//      runtime.futexwakeup.func1
//      runtime.casgstatus.func1
//      runtime.reentersyscall.func1
//      runtime.entersyscallblock.func1
//      runtime.entersyscallblock.func2
//      internal/poll.convertErr
void runtime.printstring(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.gwrite(gs, dwArg04, dwArg08);
}

// 0806CF90: void runtime.printslice(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.pcvalue
void runtime.printslice(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.printlock(gs);
	runtime.printstring(gs);
	runtime.printint(ebx_24_8, gs, dwArg08);
	runtime.printstring(gs);
	runtime.printint(ebx_24_8, gs, dwArg0C);
	runtime.printstring(gs);
	runtime.printunlock(gs);
	runtime.printpointer(gs);
}

// 0806D050: void runtime.printeface(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.printany
void runtime.printeface(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.printlock(gs);
	runtime.printstring(gs);
	runtime.printpointer(gs);
	runtime.printstring(gs);
	runtime.printpointer(gs);
	runtime.printstring(gs);
	runtime.printunlock(gs);
}

// 0806D0E0: void runtime.main(Register (ptr32 Eq_2) gs)
void runtime.main(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 eax_19 = gs->ptr0000->tFFFFFFFC;
	*((word32) **((word32) eax_19 + 24) + 0x00B0) = 0x00;
	runtime.maxstacksize.u0 = 250000000;
	g_b8157574 = 0x01;
	word32 ebp_601;
	word32 edi_602;
	runtime.systemstack(gs, 0x080E7C2C, out ebp_601, out edi_602);
	Eq_4 eax_41 = *((word32) gs->ptr0000->tFFFFFFFC + 24);
	*((word32) eax_41 + 452) = (word32) *((word32) eax_41 + 452) + 2;
	Eq_4 eax_46 = gs->ptr0000->tFFFFFFFC;
	ptr32 dwLoc28_524 = 0x080E7C2C;
	Eq_4 ecx_47 = *((word32) eax_46 + 24);
	if (g_t81576F0 == 0x00)
		*((word32) ecx_47 + 188) = eax_46;
	else
	{
		runtime.writebarrierptr((word32) ecx_47 + 188, eax_46);
		dwLoc28_524 = (word32) ecx_47 + 188;
		dwLoc24 = eax_46;
	}
	Eq_4 ebx_72 = *((word32) eax_46 + 24);
	if (g_t81576F0 == 0x00)
		*((word32) eax_46 + 0x0088) = ebx_72;
	else
	{
		runtime.writebarrierptr((word32) eax_46 + 0x0088, ebx_72);
		dwLoc28_524 = (word32) eax_46 + 0x0088;
		dwLoc24 = ebx_72;
	}
	if (*((word32) eax_19 + 24) != 135550688)
		runtime.throw(gs);
	else
	{
		word32 esi_603;
		word32 edi_604;
		runtime.init(gs, out esi_603, out edi_604);
		runtime.nanotime();
		if (((int8) (dwLoc24 == 0x00) & (int8) (dwLoc28_524 == 0x00)) != 0x00)
			runtime.throw(gs);
		else
		{
			Eq_4 ebp_159;
			word32 edi_162;
			word32 esi_605;
			if (runtime.deferproc(gs, 0x04, 0x080E7C30, fp - 0x0D, out ebp_159, out esi_605, out edi_162) != 0x00)
			{
				word128 xmm1_607;
				word128 xmm0_606;
				runtime.deferreturn(gs, out xmm0_606, out xmm1_607);
			}
			else
			{
				runtime.nanotime();
				g_t81576A0.u1 = 0x04;
				g_ptr81576A4 = 0x080E7C30;
				word32 edi_219;
				word32 esi_608;
				runtime.makechan(runtime.gcenable(ebp_159, edi_162, gs, out edi_219), edi_219, gs, &g_t80CA640, 0x00, 0x00, out esi_608);
				if (g_t81576F0 == 0x00)
					runtime.main_init_done = dwLoc1C;
				else
					runtime.writebarrierptr(135548884, dwLoc1C);
				if (g_b8157571 != 0x00)
				{
					if (_cgo_thread_start == null)
						runtime.throw(gs);
					if (runtime._cgo_setenv == 0x00)
						runtime.throw(gs);
					if (runtime._cgo_unsetenv == 0x00)
						runtime.throw(gs);
					<anonymous> * eax_315 = _cgo_notify_runtime_init_done;
					if (eax_315 == null)
						runtime.throw(gs);
					runtime.cgocall(gs, eax_315, 0x00);
				}
				runtime.closechan(main.init(gs), gs, runtime.main_init_done);
				runtime.unlockOSThread(gs);
				if (g_b8157570 != 0x00 || g_b8157572 != 0x00)
				{
					word128 xmm0_609;
					word128 xmm1_610;
					runtime.deferreturn(gs, out xmm0_609, out xmm1_610);
				}
				else
				{
					main.main(gs);
					runtime/internal/atomic.Load();
					*((word32) fp - 36) = 0x08157618;
					runtime/internal/atomic.Load();
					if (*((word32) fp - 28) != 0x00)
					{
						*((word32) fp - 32) = 0x00;
						*((word32) fp - 28) = 0x00;
						*((word32) fp - 24) = 0x080E16A4;
						*((word32) fp - 20) = 0x09;
						*((word32) fp - 16) = 0x10;
						*((word32) fp - 0x0C) = 0x01;
						runtime.gopark(gs);
					}
					*((word32) fp - 32) = 0x00;
					runtime.exit();
					while (true)
						null = (union Eq_4 *) 0x00;
				}
			}
		}
	}
}

// 0806D4A0: Register word32 runtime.init.3(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.init
word32 runtime.init.3(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	return runtime.newproc();
}

// 0806D4E0: void runtime.forcegchelper(Register Eq_4 esi, Register (ptr32 Eq_2) gs)
void runtime.forcegchelper(Eq_4 esi, struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 ecx_19 = gs->ptr0000->tFFFFFFFC;
	if (g_t81576F0 == 0x00)
		g_t814513C = ecx_19;
	else
		runtime.writebarrierptr(135549244, ecx_19);
	while (true)
	{
		word32 esi_170;
		word32 edi_171;
		runtime.lock(esi, gs, 0x08145138, out esi_170, out edi_171);
		if (g_dw8145140 != 0x00)
			break;
		runtime/internal/atomic.Store(0x08145140, 0x01);
		runtime.goparkunlock(gs);
		Eq_4 dwLoc14_156 = 0x08145138;
		Eq_4 dwLoc10_157 = 135144218;
		if (g_dw8157740 > 0x00)
		{
			runtime.printlock(gs);
			runtime.printstring(gs);
			runtime.printnl(gs);
			runtime.printunlock(gs);
			dwLoc14_156.u0 = 0x080E15F0;
			dwLoc10_157.u0 = 0x09;
		}
		runtime.nanotime();
		runtime.gcStart(gs, 0x00, 0x02, dwLoc14_156, dwLoc10_157, out esi);
	}
	runtime.throw(gs);
}

// 0806D620: Register word32 runtime.Gosched(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.gcAssistAlloc
//      runtime.bgsweep
//      runtime.main
word32 runtime.Gosched(struct Eq_2 * gs)
{
	word32 esi_13;
	runtime.mcall(gs, dwLoc08, &g_dw80E7C1C, out esi_13);
	return esi_13;
}

// 0806D640: void runtime.gopark(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.chansend
//      runtime.chanrecv
//      runtime.gcBgMarkWorker
//      runtime.netpollblock
//      runtime.main
//      runtime.goparkunlock
void runtime.gopark(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 eax_18 = gs->ptr0000->tFFFFFFFC;
	Eq_4 ecx_19 = *((word32) eax_18 + 24);
	*((word32) ecx_19 + 0x0078) = (word32) *((word32) ecx_19 + 0x0078) + 1;
	runtime.readgstatus(*((word32) *((word32) eax_18 + 24) + 84));
	Eq_4 esp_32 = <invalid>;
	Eq_4 eax_37 = *((word32) esp_32 + 4);
	if (eax_37 == 0x02 || eax_37 == 0x1002)
	{
		Eq_4 ecx_104 = *((word32) esp_32 + 8);
		if (g_t81576F0 == 0x00)
			*((word32) ecx_104 + 468) = *((word32) esp_32 + 24);
		else
		{
			*esp_32 = (word32) ecx_104 + 468;
			*((word32) esp_32 + 4) = *((word32) esp_32 + 24);
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_4 stackArg4 = <invalid>;
			Eq_4 stackArg8 = <invalid>;
			runtime.writebarrierptr(stackArg4, stackArg8);
			ecx_104 = *((word32) esp_32 + 8);
		}
		word32 * edx_71 = (word32) ecx_104 + 464;
		Eq_4 ebx_73 = *((word32) esp_32 + 20);
		if (g_t81576F0 == 0x00)
			*((word32) ecx_104 + 464) = ebx_73;
		else
		{
			*esp_32 = edx_71;
			*((word32) esp_32 + 4) = ebx_73;
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_4 stackArg4 = <invalid>;
			Eq_4 stackArg8 = <invalid>;
			runtime.writebarrierptr(stackArg4, stackArg8);
			ecx_104 = *((word32) esp_32 + 8);
		}
		Eq_4 edx_89 = *((word32) esp_32 + 0x0C);
		*((word32) edx_89 + 100) = *((word32) esp_32 + 32);
		if (g_t81576F0 == 0x00)
			*((word32) edx_89 + 96) = *((word32) esp_32 + 28);
		else
		{
			*esp_32 = (word32) edx_89 + 96;
			*((word32) esp_32 + 4) = *((word32) esp_32 + 28);
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_4 stackArg4 = <invalid>;
			Eq_4 stackArg8 = <invalid>;
			runtime.writebarrierptr(stackArg4, stackArg8);
			ecx_104 = *((word32) esp_32 + 8);
		}
		*((word32) ecx_104 + 472) = *((word32) esp_32 + 36);
		*((word32) ecx_104 + 476) = *((word32) esp_32 + 40);
		Eq_4 eax_121 = gs->ptr0000->tFFFFFFFC;
		Eq_4 edx_122 = *((word32) ecx_104 + 0x0078);
		*((word32) ecx_104 + 0x0078) = edx_122 - 0x01;
		if (edx_122 == 0x01 && *((word32) eax_121 + 0x006C) != 0x00)
			((word32) eax_121 + 8)->u0 = ~0x0521;
		*esp_32 = &g_dw80E7C9C;
		word32 esi_167;
		runtime.mcall(gs, *((word32) esp_32 - 4), *esp_32, out esi_167);
	}
	else
	{
		*esp_32 = &g_dw80E30AB;
		((word32) esp_32 + 4)->u0 = 0x14;
		runtime.throw(gs);
	}
}

// 0806D7C0: void runtime.goparkunlock(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.chansend
//      runtime.chanrecv
//      runtime.runfinq
//      runtime.gcParkAssist
//      runtime.bgsweep
//      runtime.forcegchelper
//      runtime.semacquire1
//      runtime.timerproc
void runtime.goparkunlock(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.gopark(gs);
}

// 0806D820: void runtime.goready(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.send
//      runtime.closechan
//      runtime.recv
//      runtime.netpollgoready
//      runtime.readyWithTime
void runtime.goready(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	word32 ebp_44;
	word32 edi_45;
	runtime.systemstack(gs, fp - 0x0C, out ebp_44, out edi_45);
}

// 0806D870: Register Eq_4 runtime.acquireSudog(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.chansend
//      runtime.chanrecv
//      runtime.semacquire1
Eq_4 runtime.acquireSudog(struct Eq_2 * gs)
{
	Eq_4 eax_8 = gs->ptr0000->tFFFFFFFC;
	Eq_4 ecx_9 = *((word32) eax_8 + 24);
	*((word32) ecx_9 + 0x0078) = (word32) *((word32) ecx_9 + 0x0078) + 1;
	Eq_4 ecx_13 = *((word32) eax_8 + 24);
	Eq_4 edx_15 = *((word32) ecx_13 + 92);
	if (*((word32) edx_15 + 0x0720) == 0x00)
	{
		word32 edi_445;
		word32 esi_444;
		runtime.lock(esi, gs, 135550004, out esi_444, out edi_445);
		while (true)
		{
			Eq_4 ecx_36 = *((word32) edx_15 + 1828);
			if (Mem34[edx_15 + 0x0720:word32] >= ((ecx_36 >> 0x1F) >>u 0x1F) + ecx_36 >> 0x01)
				break;
			Eq_4 ecx_45 = g_t8145438;
			if (ecx_45 == 0x00)
				break;
			Eq_4 ebx_223 = *((word32) ecx_45 + 8);
			if (g_t81576F0 == 0x00)
			{
				g_t8145438 = ebx_223;
				((word32) ecx_45 + 8)->u0 = 0x00;
			}
			else
			{
				runtime.writebarrierptr(135550008, ebx_223);
				runtime.writebarrierptr((word32) ecx_45 + 8, 0x00);
				dwLoc44.u0 = 0x00;
			}
			Eq_4 edx_249 = *((word32) edx_15 + 1828);
			Eq_4 ebx_250 = *((word32) edx_15 + 0x0720);
			Eq_4 ebp_251 = *((word32) edx_15 + 0x071C);
			if ((word32) ebx_250 + 1 > edx_249)
			{
				word128 xmm1_450;
				word32 esi_448;
				word128 xmm0_449;
				runtime.growslice(gs, 0x080C8440, ebp_251, ebx_250, edx_249, (word32) ebx_250 + 1, out esi_448, out xmm0_449, out xmm1_450);
				*((word32) edx_15 + 1828) = dwLoc2C;
				dwLoc44 = ebp_251;
				if (g_t81576F0 == 0x00)
					*((word32) edx_15 + 0x071C) = dwLoc34;
				else
				{
					runtime.writebarrierptr((word32) edx_15 + 0x071C, dwLoc34);
					dwLoc44 = dwLoc34;
				}
				ebx_250 = dwLoc30;
				ebp_251 = dwLoc34;
			}
			*((word32) edx_15 + 0x0720) = (word32) ebx_250 + 1;
			Eq_4 esi_304 = (word32) ebp_251 + ebx_250 * 0x04;
			if (g_t81576F0 == 0x00)
				*((word32) ebp_251 + ebx_250 * 0x04) = ecx_45;
			else
			{
				runtime.writebarrierptr(esi_304, ecx_45);
				dwLoc44 = ecx_45;
			}
		}
		word32 ebx_447;
		word32 edx_446;
		runtime.unlock(gs, 135550004, out edx_446, out ebx_447);
		if (*((word32) edx_15 + 0x0720) == 0x00)
		{
			runtime.newobject(gs, 135115232);
			Eq_4 ecx_118 = *((word32) edx_15 + 0x071C);
			Eq_4 edx_73 = *((word32) edx_15 + 1828);
			Eq_4 ebx_116 = *((word32) edx_15 + 0x0720);
			if ((word32) ebx_116 + 1 > edx_73)
			{
				word32 esi_451;
				word128 xmm1_453;
				word128 xmm0_452;
				runtime.growslice(gs, 0x080C8440, ecx_118, ebx_116, edx_73, (word32) ebx_116 + 1, out esi_451, out xmm0_452, out xmm1_453);
				*((word32) edx_15 + 1828) = dwLoc2C;
				if (g_t81576F0 == 0x00)
					*((word32) edx_15 + 0x071C) = dwLoc34;
				else
					runtime.writebarrierptr((word32) edx_15 + 0x071C, dwLoc34);
				ebx_116 = dwLoc30;
				ecx_118 = dwLoc34;
			}
			*((word32) edx_15 + 0x0720) = (word32) ebx_116 + 1;
			Eq_4 edx_125 = (word32) ecx_118 + ebx_116 * 0x04;
			if (g_t81576F0 == 0x00)
				*((word32) ecx_118 + ebx_116 * 0x04) = dwLoc44;
			else
				runtime.writebarrierptr(edx_125, dwLoc44);
		}
	}
	Eq_4 ecx_146 = *((word32) edx_15 + 0x0720);
	Eq_4 edx_147 = *((word32) edx_15 + 0x071C);
	if (ecx_146 - 0x01 >= ecx_146)
		runtime.panicindex(gs);
	else
	{
		struct Eq_45148 * ebp_158 = (edx_147 - 0x04)[ecx_146];
		Eq_4 esi_159 = edx_147 - 0x04 + ecx_146 * 0x04;
		if (g_t81576F0 == 0x00)
			(edx_147 - 0x04)[ecx_146] = 0x00;
		else
			runtime.writebarrierptr(esi_159, 0x00);
		if (ecx_146 - 0x01 > *((word32) edx_15 + 1828))
			runtime.panicslice(gs);
		else
		{
			*((word32) edx_15 + 0x0720) = ecx_146 - 0x01;
			if (ebp_158->dw0010 != 0x00)
				runtime.throw(gs);
			else
			{
				Eq_4 eax_203 = gs->ptr0000->tFFFFFFFC;
				Eq_4 edx_205 = *((word32) ecx_13 + 0x0078);
				*((word32) ecx_13 + 0x0078) = edx_205 - 0x01;
				if (edx_205 == 0x01 && *((word32) eax_203 + 0x006C) != 0x00)
					((word32) eax_203 + 8)->u0 = ~0x0521;
				return edx_205;
			}
		}
	}
}

// 0806DC00: Register word32 runtime.releaseSudog(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Register out Eq_4 esiOut, Register out Eq_3291 ediOut)
// Called from:
//      runtime.chansend
//      runtime.chanrecv
//      runtime.semacquire1
word32 runtime.releaseSudog(struct Eq_2 * gs, Eq_4 dwArg04, union Eq_4 & esiOut, union Eq_3291 & ediOut)
{
	if (*((word32) dwArg04 + 16) != 0x00)
		runtime.throw(gs);
	else if (*((word32) dwArg04 + 4) != 0x00)
		runtime.throw(gs);
	else if (*((word32) dwArg04 + 8) != 0x00)
		runtime.throw(gs);
	else if (*((word32) dwArg04 + 0x0C) != 0x00)
		runtime.throw(gs);
	else if (*((word32) dwArg04 + 44) != 0x00)
		runtime.throw(gs);
	else if (*((word32) dwArg04 + 52) != 0x00)
		runtime.throw(gs);
	else
	{
		Eq_4 ecx_75 = gs->ptr0000->tFFFFFFFC;
		if (*((word32) ecx_75 + 0x0044) != 0x00)
			runtime.throw(gs);
		else
		{
			Eq_4 edx_87 = *((word32) ecx_75 + 24);
			*((word32) edx_87 + 0x0078) = (word32) *((word32) edx_87 + 0x0078) + 1;
			Eq_4 edx_91 = *((word32) ecx_75 + 24);
			Eq_4 ebx_93 = *((word32) edx_91 + 92);
			Eq_4 esi_101 = *((word32) ebx_93 + 1828);
			if (esi_101 == *((word32) ebx_93 + 0x0720))
			{
				Eq_4 ebp_104 = 0x00;
				esi_101.u0 = 0x00;
				ebx_113 = ebx_93;
				while (true)
				{
					Eq_4 ebx_113;
					Eq_4 edi_114 = *((word32) ebx_113 + 1828);
					edi = edi_114 >> 0x1F >> 0x1F;
					Eq_4 ecx_116 = *((word32) ebx_113 + 0x0720);
					Eq_4 edx_117 = *((word32) ebx_113 + 0x071C);
					if (ecx_116 <= edi_114 + edi >> 0x01)
						break;
					if (ecx_116 - 0x01 >= ecx_116)
						runtime.panicindex(gs);
					Eq_4 edi_269 = (edx_117 - 0x04)[ecx_116];
					Eq_4 edi_271 = edx_117 - 0x04 + ecx_116 * 0x04;
					if (g_t81576F0 == 0x00)
						(edx_117 - 0x04)[ecx_116] = 0x00;
					else
					{
						runtime.writebarrierptr(edi_271, 0x00);
						ebx_113 = ebx_93;
					}
					if (ecx_116 - 0x01 > *((word32) ebx_113 + 1828))
						runtime.panicslice(gs);
					*((word32) ebx_113 + 0x0720) = ecx_116 - 0x01;
					if (ebp_104 != 0x00)
					{
						Eq_4 ecx_314 = (byte) esi_101.u0 + 8;
						if (g_t81576F0 == 0x00)
							*((byte) esi_101.u0 + 8) = edi_269;
						else
						{
							runtime.writebarrierptr(ecx_314, edi_269);
							ebx_113 = ebx_93;
						}
					}
					else
						ebp_104 = edi_269;
					esi_101 = edi_269;
				}
				word32 esi_468;
				word32 edi_469;
				runtime.lock(esi, gs, 135550004, out esi_468, out edi_469);
				Eq_4 ebx_138 = g_t8145438;
				if (g_t81576F0 == 0x00)
				{
					*((byte) esi_101.u0 + 8) = ebx_138;
					g_t8145438 = ebp_104;
				}
				else
				{
					runtime.writebarrierptr((byte) esi_101.u0 + 8, ebx_138);
					runtime.writebarrierptr(135550008, ebp_104);
				}
				word32 edx_473;
				word32 ebx_474;
				runtime.unlock(gs, 135550004, out edx_473, out ebx_474);
			}
			Eq_4 edx_212;
			Eq_4 edx_172 = *((word32) ebx_93 + 0x0720);
			Eq_4 ecx_171 = *((word32) ebx_93 + 0x071C);
			Eq_4 ebx_173 = *((word32) ebx_93 + 1828);
			edx_212 = edx_172;
			if ((word32) edx_172 + 1 > ebx_173)
			{
				word32 esi_470;
				word128 xmm0_471;
				word128 xmm1_472;
				runtime.growslice(gs, 0x080C8440, ecx_171, edx_172, ebx_173, (word32) edx_172 + 1, out esi_470, out xmm0_471, out xmm1_472);
				*((word32) ebx_93 + 1828) = dwLoc2C;
				if (g_t81576F0 == 0x00)
					*((word32) ebx_93 + 0x071C) = dwLoc34;
				else
					runtime.writebarrierptr((word32) ebx_93 + 0x071C, dwLoc34);
				edx_212 = dwLoc30;
				ecx_171 = dwLoc34;
			}
			*((word32) ebx_93 + 0x0720) = (word32) edx_212 + 1;
			Eq_4 ebx_223 = (word32) ecx_171 + edx_212 * 0x04;
			if (g_t81576F0 == 0x00)
				*((word32) ecx_171 + edx_212 * 0x04) = dwArg04;
			else
				runtime.writebarrierptr(ebx_223, dwArg04);
			Eq_4 eax_245 = gs->ptr0000->tFFFFFFFC;
			Eq_4 edx_248 = *((word32) edx_91 + 0x0078);
			*((word32) edx_91 + 0x0078) = edx_248 - 0x01;
			if (edx_248 == 0x01 && *((word32) eax_245 + 0x006C) != 0x00)
				((word32) eax_245 + 8)->u0 = ~0x0521;
			esiOut = esi_101;
			ediOut = edi;
			return (word32) edx_172 + 1;
		}
	}
}

// 0806DFC0: void runtime.funcPC()
// Called from:
//      runtime.init
void runtime.funcPC()
{
}

// 0806DFE0: void runtime.badmcall(Register (ptr32 Eq_2) gs)
void runtime.badmcall(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.throw(gs);
}

// 0806E020: void runtime.badmcall2(Register (ptr32 Eq_2) gs)
void runtime.badmcall2(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.throw(gs);
}

// 0806E060: void runtime.badreflectcall(Register (ptr32 Eq_2) gs)
void runtime.badreflectcall(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.gopanic(gs);
}

// 0806E0A0: Register word32 runtime.badmorestackg0(Register out ptr32 edxOut, Register out (ptr32 Eq_45621) ebxOut)
// Called from:
//      runtime.morestack
word32 runtime.badmorestackg0(ptr32 & edxOut, struct Eq_45621 & ebxOut)
{
	struct Eq_45621 * ebx_13;
	ptr32 edx_15;
	word32 ecx_14 = runtime.write(out edx_15, out ebx_13);
	edxOut = edx_15;
	ebxOut = ebx_13;
	return ecx_14;
}

// 0806E0D0: Register word32 runtime.badmorestackgsignal(Register out (ptr32 Eq_45633) ebxOut)
// Called from:
//      runtime.morestack
word32 runtime.badmorestackgsignal(struct Eq_45633 & ebxOut)
{
	struct Eq_45633 * ebx_13;
	word32 edx_15;
	runtime.write(out edx_15, out ebx_13);
	ebxOut = ebx_13;
	return edx_15;
}

// 0806E100: void runtime.badctxt()
// Called from:
//      runtime.save
//      runtime.gosave
//      gosave
void runtime.badctxt()
{
	runtime.throw(gs);
}

// 0806E120: void runtime.allgadd(Register Eq_4 esi, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      runtime.oneNewExtraM
//      runtime.newproc1
void runtime.allgadd(Eq_4 esi, struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.readgstatus(dwArg04);
	if (dwLoc24 == 0x00)
		runtime.throw(gs);
	else
	{
		word32 edi_228;
		word32 esi_227;
		runtime.lock(esi, gs, 0x08157590, out esi_227, out edi_228);
		Eq_4 eax_107 = g_t8145108;
		Eq_4 ecx_108 = g_t814510C;
		Eq_4 edx_56 = g_t8145110;
		if ((word32) ecx_108 + 1 > edx_56)
		{
			word32 esi_229;
			word128 xmm0_230;
			word128 xmm1_231;
			runtime.growslice(gs, 0x080C76C0, eax_107, ecx_108, edx_56, (word32) ecx_108 + 1, out esi_229, out xmm0_230, out xmm1_231);
			g_t8145110 = dwLoc0C;
			eax_107 = dwLoc14;
			ecx_108 = dwLoc10;
			if (g_t81576F0 == 0x00)
				g_t8145108 = dwLoc14;
			else
			{
				runtime.writebarrierptr(0x08145108, dwLoc14);
				eax_107 = dwLoc14;
				ecx_108 = dwLoc10;
			}
		}
		g_t814510C = (word32) ecx_108 + 1;
		Eq_4 edx_114 = (word32) eax_107 + ecx_108 * 0x04;
		if (g_t81576F0 == 0x00)
			*((word32) eax_107 + ecx_108 * 0x04) = dwArg04;
		else
			runtime.writebarrierptr(edx_114, dwArg04);
		runtime.allglen = g_t814510C;
		word32 edx_232;
		word32 ebx_233;
		runtime.unlock(gs, 0x08157590, out edx_232, out ebx_233);
	}
}

// 0806E260: void runtime.schedinit(Register Eq_4 esi, Register (ptr32 Eq_2) gs, Register Eq_4 mm0)
// Called from:
//      main
void runtime.schedinit(Eq_4 esi, struct Eq_2 * gs, Eq_4 mm0)
{
	byte bLoc0C_400 = (byte) dwLoc0C;
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 eax_19 = gs->ptr0000->tFFFFFFFC;
	g_t8145404.u0 = 10000;
	runtime.tracebackinit(gs);
	word24 ebx_24_8_49 = SLICE(runtime.moduledataverify(esi, gs), word24, 8);
	runtime.stackinit(gs);
	runtime.mallocinit(ebx_24_8_49, gs);
	runtime.mcommoninit(gs, *((word32) eax_19 + 24));
	runtime.alginit(gs, mm0);
	Eq_4 esi_102;
	runtime.itabsinit(runtime.typelinksinit(runtime.modulesinit(gs, out esi_102), esi_102, gs), gs);
	Eq_4 ecx_138 = *((word32) eax_19 + 24);
	runtime.msigsave();
	Eq_4 eax_150 = *((word32) eax_19 + 24);
	Eq_4 ecx_151 = *((word32) eax_150 + 52);
	g_t8157680 = *((word32) eax_150 + 48);
	g_t8157684 = ecx_151;
	runtime.goargs(gs);
	runtime.goenvs(gs);
	runtime.parsedebugvars(gs);
	runtime.gcinit(gs);
	runtime.nanotime();
	g_t81453E8 = ecx_138;
	g_dw81453EC = dwLoc14;
	Eq_4 eax_222 = runtime.ncpu;
	runtime.gogetenv(gs, 135141561, 0x0A);
	word32 esi_248;
	Eq_4 ebp_243 = runtime.atoi32(gs, dwLoc10, dwLoc0C, out esi_248);
	Eq_4 eax_253 = dwLoc10;
	if (bLoc0C_400 == 0x00 || dwLoc10 <= 0x00)
		eax_253 = eax_222;
	if (eax_253 > 0x0400)
		eax_253.u0 = 0x0400;
	runtime.procresize(ebp_243, esi_248, gs, eax_253);
	if (dwLoc0C != 0x00)
		runtime.throw(gs);
	else if (g_dw8142624 == 0x00)
	{
		g_dw8142624 = 0x07;
		if (g_t81576F0 == 0x00)
			g_ptr8142620 = 135140199;
		else
			runtime.writebarrierptr(0x08142620, 135140199);
	}
}

// 0806E3F0: void runtime.dumpgstatus(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      runtime.ready
//      runtime.casfrom_Gscanstatus
//      runtime.scang
//      runtime.restartg
//      runtime.stoplockedm
//      runtime.goschedImpl
void runtime.dumpgstatus(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 eax_19 = gs->ptr0000->tFFFFFFFC;
	runtime.readgstatus(dwArg04);
	Eq_4 esp_24 = <invalid>;
	Eq_4 eax_29 = *((word32) esp_24 + 28);
	*((word32) esp_24 + 16) = *((word32) eax_29 + 84);
	*((word32) esp_24 + 0x0C) = *((word32) eax_29 + 80);
	*((word32) esp_24 + 8) = *((word32) esp_24 + 4);
	runtime.printlock(gs);
	esp_24->u0 = 135145001;
	((word32) esp_24 + 4)->u0 = 0x10;
	runtime.printstring(gs);
	*esp_24 = *((word32) esp_24 + 28);
	runtime.printpointer(gs);
	esp_24->u0 = 0x080E11ED;
	((word32) esp_24 + 4)->u0 = 0x07;
	runtime.printstring(gs);
	*esp_24 = *((word32) esp_24 + 0x0C);
	*((word32) esp_24 + 4) = *((word32) esp_24 + 16);
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	Eq_4 stackArg4 = <invalid>;
	runtime.printint(ebx_24_8, gs, stackArg4);
	esp_24->u0 = 135146316;
	((word32) esp_24 + 4)->u0 = 0x13;
	runtime.printstring(gs);
	*esp_24 = *((word32) esp_24 + 8);
	((word32) esp_24 + 4)->u0 = 0x00;
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	Eq_4 stackArg4 = <invalid>;
	runtime.printint(ebx_24_8, gs, stackArg4);
	esp_24->u0 = 0x080E0D9C;
	((word32) esp_24 + 4)->u0 = 0x01;
	runtime.printstring(gs);
	runtime.printunlock(gs);
	*esp_24 = *((word32) esp_24 + 20);
	runtime.readgstatus(*esp_24);
	Eq_4 edx_104 = *((word32) eax_19 + 80);
	runtime.printlock(gs);
	runtime.printstring(gs);
	runtime.printpointer(gs);
	runtime.printstring(gs);
	runtime.printint(ebx_24_8, gs, edx_104);
	runtime.printstring(gs);
	runtime.printint(ebx_24_8, gs, dwLoc14);
	runtime.printstring(gs);
	runtime.printunlock(gs);
}

// 0806E5A0: void runtime.checkmcount(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.mcommoninit
void runtime.checkmcount(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 ecx_17 = g_t8145404;
	if (g_t8145400 <= ecx_17)
		return;
	runtime.printlock(gs);
	runtime.printstring(gs);
	runtime.printint(ebx_24_8, gs, ecx_17);
	runtime.printstring(gs);
	runtime.printunlock(gs);
	runtime.throw(gs);
}

// 0806E640: void runtime.mcommoninit(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      runtime.schedinit
//      runtime.allocm
void runtime.mcommoninit(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 eax_18 = gs->ptr0000->tFFFFFFFC;
	if (eax_18 != *(*((word32) eax_18 + 24)))
	{
		runtime.callers(gs);
		dwLoc14 = 0x01;
	}
	runtime.cputicks();
	Eq_4 ecx_46 = *((word32) dwArg04 + 100);
	*((word32) dwArg04 + 0x0094) = (word32) ecx_46 + (dwLoc14 + 0x49F6428A);
	if ((word32) ecx_46 + dwLoc14 == ~0x49F64289)
		((word32) dwArg04 + 0x0094)->u0 = 0x49F6428A;
	word32 esi_191;
	word32 edi_192;
	runtime.lock(esi, gs, 135549936, out esi_191, out edi_192);
	*((word32) dwArg04 + 100) = g_t8145400;
	g_t8145400 = (word32) g_t8145400 + 1;
	runtime.checkmcount(gs);
	runtime.mpreinit(gs, dwArg04);
	Eq_4 ecx_81 = *((word32) dwArg04 + 44);
	if (ecx_81 != 0x00)
		*((word32) ecx_81 + 0x0C) = (word32) *ecx_81 + 880;
	Eq_4 edx_91 = runtime.allm;
	if (g_t81576F0 == 0x00)
		*((word32) dwArg04 + 0x00B0) = edx_91;
	else
		runtime.writebarrierptr((word32) dwArg04 + 0x00B0, edx_91);
	runtime.atomicstorep(135548844, dwArg04);
	word32 edx_193;
	word32 ebx_194;
	runtime.unlock(gs, 135549936, out edx_193, out ebx_194);
	if (g_b8157571 != 0x00)
	{
		runtime.newobject(gs, 0x080CFEE0);
		if (g_t81576F0 == 0x00)
			*((word32) dwArg04 + 0x00A8) = dwArg04;
		else
			runtime.writebarrierptr((word32) dwArg04 + 0x00A8, dwArg04);
	}
}

// 0806E7D0: void runtime.ready(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      runtime.gcSweep
//      runtime.gcFlushBgCredit
//      runtime.findrunnable
//      runtime.goready.func1
void runtime.ready(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (g_b814F4C8 != 0x00)
		runtime.traceGoUnpark(gs, dwArg04);
	runtime.readgstatus(dwArg04);
	Eq_4 eax_42 = gs->ptr0000->tFFFFFFFC;
	Eq_4 esp_35 = <invalid>;
	Eq_4 ecx_43 = *((word32) eax_42 + 24);
	Eq_4 edx_44 = *((word32) esp_35 + 4);
	*((word32) ecx_43 + 0x0078) = (word32) *((word32) ecx_43 + 0x0078) + 1;
	if ((edx_44 & ~0x1000) != 0x04)
	{
		*esp_35 = *((word32) esp_35 + 20);
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_4 stackArg4 = <invalid>;
		runtime.dumpgstatus(gs, stackArg4);
		esp_35->u0 = 0x080E3575;
		((word32) esp_35 + 4)->u0 = 22;
		runtime.throw(gs);
	}
	else
	{
		*((word32) esp_35 + 0x0C) = eax_42;
		*esp_35 = *((word32) esp_35 + 20);
		((word32) esp_35 + 4)->u0 = 0x04;
		((word32) esp_35 + 8)->u0 = 0x01;
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_4 stackArg4 = <invalid>;
		runtime.casgstatus(stackArg4, dwArg04, dwArg08);
		*esp_35 = *((word32) *((word32) *((word32) esp_35 + 0x0C) + 24) + 92);
		*((word32) esp_35 + 4) = *((word32) esp_35 + 20);
		*((word32) esp_35 + 8) = *((word32) esp_35 + 28);
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_4 stackArg0 = <invalid>;
		Eq_4 stackArg4 = <invalid>;
		runtime.runqput(gs, stackArg0, stackArg4, dwArg04, dwArg08);
		esp_35->u0 = 0x08145410;
		runtime/internal/atomic.Load();
		if (*((word32) esp_35 + 8) != 0x00)
		{
			((word32) esp_35 + 4)->u0 = 0x08145414;
			runtime/internal/atomic.Load();
			if (*((word32) esp_35 + 0x0C) == 0x00)
				runtime.wakep(gs);
		}
		struct Eq_46366 * ecx_110 = dwLoc04->ptr0018;
		--ecx_110->dw0078;
		if (dwLoc04->ptr0018->dw0078 == 0x00 && dwLoc04->b006C != 0x00)
			dwLoc04->dw0008 = ~0x0521;
	}
}

// 0806E920: void runtime.gcprocs(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.gcStart
//      runtime.gcMark
void runtime.gcprocs(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	word32 edi_72;
	word32 esi_71;
	runtime.lock(esi, gs, 135549936, out esi_71, out edi_72);
	Eq_4 eax_22 = runtime.gomaxprocs;
	Eq_4 ecx_23 = runtime.ncpu;
	if (eax_22 <= ecx_23)
		ecx_23 = eax_22;
	Eq_4 eax_30;
	if (ecx_23 > 0x20)
		eax_30.u0 = 0x20;
	else
		eax_30 = ecx_23;
	word32 edx_73;
	word32 ebx_74;
	runtime.unlock(gs, 135549936, out edx_73, out ebx_74);
}

// 0806E9A0: Register Eq_4 runtime.needaddgcproc(Register Eq_4 esi, Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.startTheWorldWithSema
Eq_4 runtime.needaddgcproc(Eq_4 esi, struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 esi_28;
	word32 edi_90;
	runtime.lock(esi, gs, 135549936, out esi_28, out edi_90);
	Eq_4 eax_33 = runtime.gomaxprocs;
	Eq_4 ecx_34 = runtime.ncpu;
	if (eax_33 <= ecx_34)
		ecx_34 = eax_33;
	word32 ebx_92;
	word32 edx_91;
	runtime.unlock(gs, 135549936, out edx_91, out ebx_92);
	return esi_28;
}

// 0806EA20: void runtime.helpgc(Register Eq_4 esi, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      runtime.gcMark
void runtime.helpgc(Eq_4 esi, struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 eax_19 = gs->ptr0000->tFFFFFFFC;
	word32 esi_168;
	word32 edi_169;
	runtime.lock(esi, gs, 135549936, out esi_168, out edi_169);
	Eq_4 eax_132 = 0x01;
	uint32 ecx_105 = 0x00;
	while (eax_132 < dwArg04)
	{
		if (ecx_105 >= 0x0401)
			runtime.panicindex(gs);
		if (*((char *) *((char *) g_a81478C0 + ecx_105 * 0x04) + 52) == *((word32) (*((word32) eax_19 + 24)) + 0x00B8))
			++ecx_105;
		Eq_4 ebp_74 = g_t81453F4;
		if (ebp_74 != 0x00)
		{
			g_t81453F4 = *((word32) ebp_74 + 0x00B4);
			--g_t81453F8;
		}
		if (ebp_74 == 0x00)
			runtime.throw(gs);
		*((word32) ebp_74 + 0x0088) = eax_132;
		if (ecx_105 >= 0x0401)
			runtime.panicindex(gs);
		*((word32) ebp_74 + 92) = *((char *) g_a81478C0 + ecx_105 * 0x04);
		*((word32) ebp_74 + 0x00B8) = *((char *) *((char *) g_a81478C0 + ecx_105 * 0x04) + 52);
		runtime.notewakeup(gs, (word32) ebp_74 + 0x00AC);
		eax_132 = (word32) eax_132 + 1;
		++ecx_105;
	}
	word32 edx_170;
	word32 ebx_171;
	runtime.unlock(gs, 135549936, out edx_170, out ebx_171);
}

// 0806EB50: void runtime.freezetheworld(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.startpanic_m
void runtime.freezetheworld(struct Eq_2 * gs)
{
}

// 0806EC00: void runtime.readgstatus(Stack Eq_4 dwArg04)
// Called from:
//      runtime.gcMarkRootCheck
//      runtime.markroot
//      runtime.scanstack
//      runtime.canpanic
//      runtime.gopark
//      runtime.allgadd
//      runtime.dumpgstatus
//      runtime.ready
//      runtime.scang
//      runtime.restartg
//      runtime.stoplockedm
//      runtime.goschedImpl
//      runtime.newproc1
//      runtime.gfput
//      runtime.checkdead
//      runtime.schedtrace
//      runtime.sighandler
//      runtime.newstack
//      runtime.shrinkstack
//      runtime.traceback1
//      runtime.goroutineheader
//      runtime.tracebackothers
//      runtime.markroot.func1
void runtime.readgstatus(Eq_4 dwArg04)
{
	runtime/internal/atomic.Load();
}

// 0806EC20: void runtime.casfrom_Gscanstatus(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C)
// Called from:
//      runtime.scang
//      runtime.restartg
//      runtime.newstack
void runtime.casfrom_Gscanstatus(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (dwArg08 > ~0x1003)
	{
		runtime.printlock(gs);
		runtime.printstring(gs);
		runtime.printpointer(gs);
		runtime.printstring(gs);
		word32 esi_258;
		runtime.printhex(esi, gs, dwArg08, 0x00, out esi_258);
		runtime.printstring(gs);
		word32 esi_259;
		runtime.printhex(esi, gs, dwArg0C, 0x00, out esi_259);
		runtime.printstring(gs);
		runtime.printunlock(gs);
		runtime.dumpgstatus(gs, dwArg04);
		runtime.throw(gs);
	}
	else
	{
		uip32 eax_107;
		if (dwArg0C != (dwArg08 & ~0x1000))
			eax_107 = 0x00;
		else
		{
			runtime/internal/atomic.Cas((word32) dwArg04 + 72, dwArg08, dwArg0C);
			eax_107 = (word32) bLoc04;
		}
		if ((byte) eax_107 != 0x00)
			return;
		runtime.printlock(gs);
		runtime.printstring(gs);
		runtime.printpointer(gs);
		runtime.printstring(gs);
		word32 esi_260;
		runtime.printhex(esi, gs, dwArg08, 0x00, out esi_260);
		runtime.printstring(gs);
		word32 esi_261;
		runtime.printhex(esi, gs, dwArg0C, 0x00, out esi_261);
		runtime.printstring(gs);
		runtime.printunlock(gs);
		runtime.dumpgstatus(gs, dwArg04);
		runtime.throw(gs);
	}
}

// 0806EE10: void runtime.castogscanstatus(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C)
// Called from:
//      runtime.scang
//      runtime.newstack
void runtime.castogscanstatus(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (dwArg08 > 0x04 || dwArg0C != (dwArg08 | 0x1000))
	{
		runtime.printlock(gs);
		runtime.printstring(gs);
		word32 esi_131;
		runtime.printhex(esi, gs, dwArg08, 0x00, out esi_131);
		runtime.printstring(gs);
		word32 esi_132;
		runtime.printhex(esi, gs, dwArg0C, 0x00, out esi_132);
		runtime.printstring(gs);
		runtime.printunlock(gs);
		runtime.throw(gs);
	}
	else
		runtime/internal/atomic.Cas((word32) dwArg04 + 72, dwArg08, dwArg0C);
}

// 0806EF00: Register Eq_4 runtime.casgstatus(Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C)
// Called from:
//      runtime.(*gcControllerState).findRunnableGCWorker
//      runtime.gcMarkTermination
//      runtime.gcAssistAlloc1
//      runtime.ready
//      runtime.needm
//      runtime.oneNewExtraM
//      runtime.dropm
//      runtime.execute
//      runtime.findrunnable
//      runtime.injectglist
//      runtime.schedule
//      runtime.park_m
//      runtime.goschedImpl
//      runtime.goexit0
//      runtime.reentersyscall
//      runtime.entersyscallblock
//      runtime.exitsyscall
//      runtime.exitsyscall0
//      runtime.newproc1
//      runtime.procresize
//      runtime.checkdead
//      runtime.newstack
//      runtime.gcBgMarkWorker.func2
//      runtime.markroot.func1
Eq_4 runtime.casgstatus(Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C)
{
	if ((dwArg08 & 0x1000) != 0x00 || ((dwArg0C & 0x1000) != 0x00 || dwArg0C == dwArg08))
	{
		word32 edi_401;
		word32 ebp_400;
		runtime.systemstack(gs, fp - 0x0C, out ebp_400, out edi_401);
	}
	if (dwArg08 != 0x02 || *((word32) dwArg04 + 112) == 0x00)
	{
		word32 edx_109 = 0x00;
		Eq_4 ebx_110 = 0x00;
		word32 * ebp_111 = null;
		while (true)
		{
			runtime/internal/atomic.Cas((word32) dwArg04 + 72, dwArg08, dwArg0C);
			word32 * dwLoc30_334 = (word32) dwArg04 + 72;
			if (bLoc24 != 0x00)
				break;
			if (dwArg08 == 0x04 && *((word32) dwArg04 + 72) == 0x01)
			{
				word32 edi_407;
				word32 ebp_406;
				runtime.systemstack(gs, 135166888, out ebp_406, out edi_407);
				dwLoc30_334 = &g_dw80E7BA8;
			}
			word32 * ebp_187;
			Eq_4 ebx_185;
			if (edx_109 != 0x00)
			{
				ebx_185 = ebx_110;
				ebp_187 = ebp_111;
			}
			else
			{
				runtime.nanotime();
				ebx_185 = (word32) dwArg08 + (dwLoc30_334 < (word32 *) 5000);
				ebp_187 = dwLoc30_334 + 0x04E2;
			}
			Eq_4 edx_242;
			if (((int8) (dwArg08 < ebx_185) | (int8) (dwArg08 == ebx_185) & (int8) (dwLoc30_334 < ebp_187)) != 0x00)
			{
				int32 eax_247 = 0x00;
				while (true)
				{
					ebp_111 = ebp_187;
					edx_242 = ebx_185;
					if (eax_247 >= 0x0A || dwArg08 == *((word32) dwArg04 + 72))
						break;
					runtime.procyield(0x01);
					++eax_247;
				}
			}
			else
			{
				runtime.osyield();
				runtime.nanotime();
				edx_242 = (word32) dwArg08 + (dwLoc30_334 < (word32 *) 2500);
				ebp_111 = dwLoc30_334 + 625;
			}
			ebx_110 = edx_242;
			++edx_109;
		}
		if (dwArg0C == 0x02)
			((word32) dwArg04 + 112)->u0 = 0x00;
		return dwArg0C;
	}
	else
	{
		Eq_4 eax_42 = *((word32) dwArg04 + 72);
		runtime.printlock(gs);
		runtime.printstring(gs);
		word32 esi_403;
		runtime.printhex(esi, gs, dwArg08, 0x00, out esi_403);
		runtime.printstring(gs);
		word32 esi_404;
		runtime.printhex(esi, gs, dwArg0C, 0x00, out esi_404);
		runtime.printstring(gs);
		word32 esi_405;
		runtime.printhex(esi, gs, eax_42, 0x00, out esi_405);
		runtime.printstring(gs);
		runtime.printunlock(gs);
		runtime.throw(gs);
	}
}

// 0806F1A0: void runtime.scang(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      runtime.markroot.func1
void runtime.scang(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	((word32) dwArg04 + 111)->u0 = 0x00;
	Eq_4 esp_16 = fp - 0x1C;
	Eq_4 eax_17 = dwArg04;
	Eq_4 ecx_19 = 0x00;
	Eq_4 edx_20 = 0x00;
	Eq_4 ebx_21 = 0x00;
	while (true)
	{
		word32 ebp_26 = (word32) *((word32) eax_17 + 111);
		if ((byte) ebp_26 != 0x00)
			break;
		*((word32) esp_16 + 20) = edx_20;
		*((word32) esp_16 + 16) = ebx_21;
		*((word32) esp_16 + 24) = ecx_19;
		*esp_16 = eax_17;
		runtime.readgstatus(*esp_16);
		esp_16.u0 = <invalid>;
		Eq_4 eax_51 = *((byte) esp_16.u0 + 4);
		if (eax_51 <= 0x04)
		{
			if (eax_51 == 0x01)
			{
l0806F34E:
				*esp_16.u0 = *((byte) esp_16.u0 + 32);
				*((byte) esp_16.u0 + 8) = eax_51 | 0x1000;
				runtime.castogscanstatus(gs, *esp_16.u0, *((byte) esp_16.u0 + 4), *((byte) esp_16.u0 + 8));
				if (*((byte) esp_16.u0 + 0x0C) != 0x00)
				{
					Eq_4 eax_117 = *((byte) esp_16.u0 + 32);
					if (*((word32) eax_117 + 111) == 0x00)
					{
						*esp_16.u0 = eax_117;
						*((byte) esp_16.u0 + 4) = *((byte) esp_16.u0 + 36);
						runtime.scanstack(gs, *esp_16.u0, *((byte) esp_16.u0 + 4));
						eax_117 = *((byte) esp_16.u0 + 32);
						((word32) eax_117 + 111)->u0 = 0x01;
					}
					*esp_16.u0 = eax_117;
					runtime.restartg(gs, *esp_16.u0);
					break;
				}
				goto l0806F244;
			}
			if (eax_51 == 0x02)
			{
				Eq_4 eax_155 = *((byte) esp_16.u0 + 32);
				if (*((word32) eax_155 + 110) == 0x00 || (*((word32) eax_155 + 0x006C) == 0x00 || *((word32) eax_155 + 8) != ~0x0521))
				{
					*esp_16.u0 = eax_155;
					((byte) esp_16.u0 + 4)->u0 = 0x02;
					((byte) esp_16.u0 + 8)->u0 = 0x1002;
					runtime.castogscanstatus(gs, *esp_16.u0, *((byte) esp_16.u0 + 4), *((byte) esp_16.u0 + 8));
					if (*((byte) esp_16.u0 + 0x0C) != 0x00)
					{
						Eq_4 eax_188 = *((byte) esp_16.u0 + 32);
						if (*((word32) eax_188 + 111) == 0x00)
						{
							*((word32) eax_188 + 110) = 0x01;
							((word32) eax_188 + 0x006C)->u0 = 0x01;
							((word32) eax_188 + 8)->u0 = ~0x0521;
						}
						*esp_16.u0 = eax_188;
						((byte) esp_16.u0 + 4)->u0 = 0x1002;
						((byte) esp_16.u0 + 8)->u0 = 0x02;
						runtime.casfrom_Gscanstatus(gs, *esp_16.u0, *((byte) esp_16.u0 + 4), *((byte) esp_16.u0 + 8));
					}
				}
				goto l0806F244;
			}
			if (eax_51 <= 0x04)
				goto l0806F34E;
l0806F3DC:
			*esp_16.u0 = *((byte) esp_16.u0 + 32);
			runtime.dumpgstatus(gs, *esp_16.u0);
			esp_16.u0->u0 = 0x080E34B0;
			((byte) esp_16.u0 + 4)->u0 = 0x15;
			runtime.throw(gs);
		}
		if (eax_51 == 0x06)
		{
			((word32) *((byte) esp_16.u0 + 32) + 111)->u0 = 0x01;
			break;
		}
		if (eax_51 != 0x08 && eax_51 != 0x1004)
			goto l0806F3DC;
l0806F244:
		Eq_4 ebx_235;
		Eq_4 edx_233;
		if (*((byte) esp_16.u0 + 24) != 0x00)
		{
			edx_233 = *((byte) esp_16.u0 + 20);
			ebx_235 = *((byte) esp_16.u0 + 16);
		}
		else
		{
			runtime.nanotime();
			Eq_4 eax_228 = *esp_16.u0;
			edx_233 = Mem215[esp_16 + 0x04:word32] + (eax_228 <u 10000);
			ebx_235 = (word32) eax_228 + 10000;
		}
		Eq_4 ecx_306;
		Eq_4 eax_305;
		*((byte) esp_16.u0 + 20) = edx_233;
		*((byte) esp_16.u0 + 16) = ebx_235;
		runtime.nanotime();
		Eq_4 eax_251 = *((byte) esp_16.u0 + 4);
		Eq_4 ecx_252 = *esp_16.u0;
		Eq_4 ebx_257 = *((byte) esp_16.u0 + 20);
		if (((int8) (eax_251 < ebx_257) | (int8) (eax_251 == ebx_257) & (int8) (ecx_252 < *((byte) esp_16.u0 + 16))) != 0x00)
		{
			esp_16.u0->u0 = 0x0A;
			runtime.procyield(*esp_16.u0);
			eax_305 = *((byte) esp_16.u0 + 20);
			ecx_306 = *((byte) esp_16.u0 + 16);
		}
		else
		{
			runtime.osyield();
			runtime.nanotime();
			Eq_4 eax_297 = *esp_16.u0;
			eax_305 = Mem242[esp_16 + 0x04:word32] + (eax_297 <u 5000);
			ecx_306 = (word32) eax_297 + 5000;
		}
		edx_20 = eax_305;
		ebx_21 = ecx_306;
		eax_17 = *((byte) esp_16.u0 + 32);
		ecx_19 = (word32) *((byte) esp_16.u0 + 24) + 1;
	}
	*((word32) dwArg04 + 110) = 0x00;
}

// 0806F410: void runtime.restartg(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      runtime.scang
void runtime.restartg(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.readgstatus(dwArg04);
	if (dwLoc08 == 0x06)
		return;
	if (dwLoc08 != 0x1001 && dwLoc08 > ~0x1003)
	{
		runtime.dumpgstatus(gs, dwArg04);
		runtime.throw(gs);
	}
	else
		runtime.casfrom_Gscanstatus(gs, dwArg04, dwLoc08, dwLoc08 & ~0x1000);
}

// 0806F4A0: void runtime.stopTheWorld(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
// Called from:
//      runtime.GOMAXPROCS
void runtime.stopTheWorld(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.semacquire(gs);
	Eq_4 eax_29 = *((word32) gs->ptr0000->tFFFFFFFC + 24);
	*((word32) eax_29 + 116) = dwArg08;
	if (g_t81576F0 == 0x00)
		*((word32) eax_29 + 112) = dwArg04;
	else
		runtime.writebarrierptr((word32) eax_29 + 112, dwArg04);
	word32 ebp_82;
	word32 edi_83;
	runtime.systemstack(gs, 0x080E7CDC, out ebp_82, out edi_83);
}

// 0806F520: void runtime.startTheWorld(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.GOMAXPROCS
void runtime.startTheWorld(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	word32 ebp_80;
	word32 edi_81;
	runtime.systemstack(gs, 135167188, out ebp_80, out edi_81);
	runtime.semrelease(gs);
	Eq_4 eax_42 = *((word32) gs->ptr0000->tFFFFFFFC + 24);
	((word32) eax_42 + 116)->u0 = 0x00;
	if (g_t81576F0 == 0x00)
		((word32) eax_42 + 112)->u0 = 0x00;
	else
		runtime.writebarrierptr((word32) eax_42 + 112, 0x00);
}

// 0806F5A0: void runtime.stopTheWorldWithSema(Register Eq_4 esi, Register (ptr32 Eq_2) gs)
void runtime.stopTheWorldWithSema(Eq_4 esi, struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 eax_18 = gs->ptr0000->tFFFFFFFC;
	if (*((word32) *((word32) eax_18 + 24) + 0x0078) > 0x00)
		runtime.throw(gs);
	else
	{
		word32 edi_435;
		Eq_4 esi_122;
		runtime.lock(esi, gs, 135549936, out esi_122, out edi_435);
		g_t8145458 = runtime.gomaxprocs;
		runtime/internal/atomic.Store(0x08145454, 0x01);
		word32 * ebp_121 = runtime.preemptall(gs);
		((word32) *((word32) *((word32) eax_18 + 24) + 92) + 8)->u0 = 0x03;
		--g_t8145458;
		Eq_4 dwLoc28_345 = 0x08145454;
		Eq_4 eax_321 = 0x00;
		while (eax_321 < runtime.gomaxprocs)
		{
			if (eax_321 >= 0x0401)
				runtime.panicindex(gs);
			Eq_4 edx_256 = *((char *) g_a81478C0 + eax_321 * 0x04);
			Eq_4 ebx_257 = *((word32) edx_256 + 8);
			ebp_121 = (word32) edx_256 + 8;
			if (ebx_257 == 0x02)
			{
				runtime/internal/atomic.Cas((word32) edx_256 + 8, ebx_257, 0x03);
				dwLoc28_345 = (word32) edx_256 + 8;
				dwLoc20 = 0x03;
				if (bLoc1C != 0x00)
				{
					if (g_b814F4C8 != 0x00)
					{
						runtime.traceGoSysBlock(gs, edx_256, out ebp_121, out esi_122);
						runtime.traceProcStop(gs, edx_256);
						dwLoc28_345 = edx_256;
					}
					*((word32) edx_256 + 20) = (word32) *((word32) edx_256 + 20) + 1;
					--g_t8145458;
				}
			}
			eax_321 = (word32) eax_321 + 1;
		}
		while (true)
		{
			runtime.pidleget(gs);
			if (dwLoc28_345 == 0x00)
				break;
			((word32) dwLoc28_345 + 8)->u0 = 0x03;
			--g_t8145458;
		}
		Eq_4 eax_100 = g_t8145458;
		word32 edx_436;
		word32 ebx_437;
		runtime.unlock(gs, 135549936, out edx_436, out ebx_437);
		if (eax_100 > 0x00)
		{
			while (true)
			{
				dwLoc20 = 0x00;
				esi_122 = runtime.notetsleep(ebp_121, esi_122, gs, 135550044, (struct Eq_12643 *) 100000, 0x00);
				if (bLoc1C != 0x00)
					break;
				ebp_121 = runtime.preemptall(gs);
			}
			g_dw814545C = 0x00;
		}
		if (g_t8145458 == 0x00)
		{
			Eq_4 eax_161 = 0x00;
			while (eax_161 < runtime.gomaxprocs)
			{
				if (eax_161 >= 0x0401)
					runtime.panicindex(gs);
				*((char *) *((char *) g_a81478C0 + eax_161 * 0x04) + 8) == 0x03;
				eax_161 = (word32) eax_161 + 1;
			}
		}
		runtime/internal/atomic.Load();
		if (dwLoc20 != 0x00)
		{
			Eq_4 esi_204;
			word32 edi_438;
			runtime.lock(esi_122, gs, 0x081575B0, out esi_204, out edi_438);
			word32 edi_440;
			word32 esi_439;
			runtime.lock(esi_204, gs, 0x081575B0, out esi_439, out edi_440);
		}
		if (eax_100 == 0x00)
			return;
		runtime.throw(gs);
	}
}

// 0806F850: void runtime.mhelpgc(Register (ptr32 Eq_47617) gs)
void runtime.mhelpgc(struct Eq_47617 * gs)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	gs->ptr0000->ptrFFFFFFFC->ptr0018->dw0088 = ~0x00;
}

// 0806F890: void runtime.startTheWorldWithSema(Register (ptr32 Eq_2) gs)
void runtime.startTheWorldWithSema(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 eax_19 = gs->ptr0000->tFFFFFFFC;
	Eq_4 ecx_21 = *((word32) eax_19 + 24);
	*((word32) ecx_21 + 0x0078) = (word32) *((word32) ecx_21 + 0x0078) + 1;
	Eq_4 esi_32 = runtime.netpoll(gs, 0x00);
	runtime.injectglist(gs, dwLoc14);
	word32 esi_69;
	word32 edi_340;
	Eq_4 ebp_67 = runtime.lock(runtime.needaddgcproc(esi_32, gs), gs, 135549936, out esi_69, out edi_340);
	byte al_59 = (byte) dwLoc14;
	Eq_4 eax_74 = runtime.gomaxprocs;
	Eq_4 ecx_75 = runtime.newprocs;
	if (ecx_75 != 0x00)
		runtime.newprocs.u0 = 0x00;
	else
		ecx_75 = eax_74;
	runtime.procresize(ebp_67, esi_69, gs, ecx_75);
	g_dw8145454 = 0x00;
	if (g_dw8145460 != 0x00)
	{
		g_dw8145460 = 0x00;
		runtime.notewakeup(gs, 135550052);
	}
	word32 edx_341;
	word32 ebx_342;
	runtime.unlock(gs, 135549936, out edx_341, out ebx_342);
	Eq_4 eax_130 = dwLoc14;
	byte cl_132 = al_59;
	while (true)
	{
		word32 dwLoc10_279 = SEQ(cl_132, nLoc10);
		if (eax_130 == 0x00)
			break;
		word32 eax_217;
		Eq_4 edx_202 = *((word32) eax_130 + 48);
		Eq_4 ebx_203 = *((word32) eax_130 + 0x0C);
		if (edx_202 != 0x00)
		{
			((word32) eax_130 + 48)->u0 = 0x00;
			if (*((word32) edx_202 + 96) != 0x00)
				runtime.throw(gs);
			*((word32) edx_202 + 96) = eax_130;
			runtime.notewakeup(gs, (word32) edx_202 + 0x00AC);
			eax_217 = (word32) cl_132;
		}
		else
		{
			runtime.newm(gs, eax_130);
			eax_217 = 0x00;
		}
		cl_132 = (byte) eax_217;
		eax_130 = ebx_203;
	}
	runtime/internal/atomic.Load();
	if (dwLoc10_279 != 0x00)
	{
		runtime/internal/atomic.Load();
		if (dwLoc14 == 0x00)
			runtime.wakep(gs);
	}
	if (cl_132 != 0x00)
		runtime.newm(gs, 0x00);
	Eq_4 ecx_184 = *((word32) eax_19 + 24);
	--*((word32) ecx_184 + 0x0078);
	if (*((word32) *((word32) eax_19 + 24) + 0x0078) == 0x00 && *((word32) eax_19 + 0x006C) != 0x00)
		((word32) eax_19 + 8)->u0 = ~0x0521;
}

// 0806FA80: void runtime.mstart(Register (ptr32 Eq_2) gs)
// Called from:
//      main
void runtime.mstart(struct Eq_2 * gs)
{
	Eq_4 eax_8 = gs->ptr0000->tFFFFFFFC;
	if (*eax_8 == 0x00)
	{
		Eq_4 ecx_13 = *((word32) eax_8 + 4);
		Eq_4 dwLoc04_51 = ecx_13;
		if (ecx_13 == 0x00)
			dwLoc04_51.u0 = 0x2000;
		*((word32) eax_8 + 4) = fp - 0x04;
		*eax_8 = fp - 0x04 - dwLoc04_51 + 0x0400;
	}
	ptr32 ecx_30 = *eax_8;
	*((word32) eax_8 + 8) = ecx_30 + 880;
	*((word32) eax_8 + 0x0C) = ecx_30 + 880;
	runtime.mstart1(gs);
}

// 0806FAE0: void runtime.mstart1(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.mstart
void runtime.mstart1(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 eax_18 = gs->ptr0000->tFFFFFFFC;
	Eq_4 ecx_20 = **((word32) eax_18 + 24);
	if (eax_18 != ecx_20)
		runtime.throw(gs);
	else
	{
		runtime.gosave(gs, dwLoc10, (word32) ecx_20 + 28);
		((word32) **((word32) eax_18 + 24) + 32)->u0 = ~0x00;
		runtime.asminit();
		runtime.minit(gs);
		if (*((word32) eax_18 + 24) == 135550688)
		{
			if (g_b8157571 != 0x00 && g_b8157567 == 0x00)
			{
				g_b8157567 = 0x01;
				runtime.newextram(gs);
			}
			runtime.initsig(gs, 0x00);
		}
		Eq_4 edx_112 = *((word32) *((word32) eax_18 + 24) + 80);
		if (edx_112 != 0x00)
			(*edx_112)();
		Eq_4 ecx_127 = *((word32) eax_18 + 24);
		if (*((word32) ecx_127 + 0x0088) == 0x00)
		{
			if (ecx_127 != 135550688)
			{
				runtime.acquirep(gs, *((word32) ecx_127 + 96));
				((word32) *((word32) eax_18 + 24) + 96)->u0 = 0x00;
			}
		}
		else
		{
			((word32) ecx_127 + 0x0088)->u0 = 0x00;
			runtime.stopm(gs);
		}
		runtime.schedule(gs);
	}
}

// 0806FC10: void runtime.forEachP(Register Eq_4 esi, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      runtime.gcMarkDone.func1
void runtime.forEachP(Eq_4 esi, struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 0x0C))
		runtime.morestackc();
	Eq_4 eax_20 = gs->ptr0000->tFFFFFFFC;
	Eq_4 ecx_21 = *((word32) eax_20 + 24);
	*((word32) ecx_21 + 0x0078) = (word32) *((word32) ecx_21 + 0x0078) + 1;
	Eq_4 eax_29 = *((word32) eax_20 + 24);
	Eq_4 ecx_31 = *((word32) *((word32) gs->ptr0000->tFFFFFFFC + 24) + 92);
	word32 edi_580;
	Eq_4 esi_157;
	runtime.lock(esi, gs, 135549936, out esi_157, out edi_580);
	if (g_dw814546C != 0x00)
		runtime.throw(gs);
	else
	{
		g_dw814546C = runtime.gomaxprocs - 0x01;
		if (g_t81576F0 == 0x00)
			g_t8145468 = dwArg04;
		else
			runtime.writebarrierptr(135550056, dwArg04);
		Eq_4 ecx_84 = runtime.gomaxprocs;
		if (ecx_84 > 0x0401)
			runtime.panicslice(gs);
		else
		{
			Eq_4 edx_434 = 0x00;
			word32 * ebx_409 = g_a81478C0;
			ecx_426 = ecx_84;
			while (true)
			{
				Eq_4 ecx_426;
				if (edx_434 >= ecx_426)
					break;
				Eq_4 ebp_410 = *ebx_409;
				if (ebp_410 != ecx_31)
				{
					runtime/internal/atomic.Store((word32) ebp_410 + 0x0968, 0x01);
					ecx_426 = ecx_84;
				}
				esi_157 = ecx_31;
				++ebx_409;
				edx_434 = (word32) edx_434 + 1;
			}
			word32 * ebp_102 = runtime.preemptall(gs);
			Eq_4 eax_109 = g_t814540C;
			while (eax_109 != 0x00)
			{
				runtime/internal/atomic.Cas((word32) eax_109 + 0x0968, 0x01, 0x00);
				if (bLoc24 != 0x00)
				{
					(*dwArg04)();
					--g_dw814546C;
				}
				eax_109 = *((word32) eax_109 + 0x0C);
			}
			int32 eax_115 = g_dw814546C;
			word32 edx_581;
			word32 ebx_582;
			runtime.unlock(gs, 135549936, out edx_581, out ebx_582);
			<anonymous> * eax_133 = *dwArg04;
			eax_133();
			Eq_4 eax_139 = 0x00;
			while (eax_139 < runtime.gomaxprocs)
			{
				if (eax_139 >= 0x0401)
					runtime.panicindex(gs);
				Eq_4 edx_298 = *((char *) g_a81478C0 + eax_139 * 0x04);
				Eq_4 ebx_299 = *((word32) edx_298 + 8);
				ebp_102 = (word32) edx_298 + 8;
				if (ebx_299 == 0x02)
				{
					esi_157 = *((word32) edx_298 + 0x0968);
					if (esi_157 == 0x01)
					{
						runtime/internal/atomic.Cas((word32) edx_298 + 8, ebx_299, 0x00);
						if (bLoc24 != 0x00)
						{
							if (g_b814F4C8 != 0x00)
							{
								runtime.traceGoSysBlock(gs, edx_298, out ebp_102, out esi_157);
								runtime.traceProcStop(gs, edx_298);
							}
							*((word32) edx_298 + 20) = (word32) *((word32) edx_298 + 20) + 1;
							runtime.handoffp(gs, edx_298, 0x00);
							Eq_4 esp_363 = <invalid>;
							eax_139 = *((word32) esp_363 + 16);
						}
					}
				}
				eax_139 = (word32) eax_139 + 1;
			}
			if (eax_115 > 0x00)
			{
				while (true)
				{
					esi_157 = runtime.notetsleep(ebp_102, esi_157, gs, 0x08145470, (struct Eq_12643 *) 100000, 0x00);
					if (bLoc24 != 0x00)
						break;
					ebp_102 = runtime.preemptall(gs);
				}
				g_dw8145470 = 0x00;
			}
			if (g_dw814546C != 0x00)
				runtime.throw(gs);
			else
			{
				Eq_4 eax_206 = 0x00;
				while (eax_206 < runtime.gomaxprocs)
				{
					if (eax_206 >= 0x0401)
						runtime.panicindex(gs);
					if (*((char *) *((char *) g_a81478C0 + eax_206 * 0x04) + 0x0968) != 0x00)
						runtime.throw(gs);
					eax_206 = (word32) eax_206 + 1;
				}
				word32 esi_583;
				word32 edi_584;
				runtime.lock(esi_157, gs, 135549936, out esi_583, out edi_584);
				if (g_t81576F0 == 0x00)
					g_t8145468.u0 = 0x00;
				else
					runtime.writebarrierptr(135550056, 0x00);
				word32 ebx_586;
				word32 edx_585;
				runtime.unlock(gs, 135549936, out edx_585, out ebx_586);
				Eq_4 eax_260 = gs->ptr0000->tFFFFFFFC;
				Eq_4 edx_262 = *((word32) eax_29 + 0x0078);
				*((word32) eax_29 + 0x0078) = edx_262 - 0x01;
				if (edx_262 == 0x01 && *((word32) eax_260 + 0x006C) != 0x00)
					((word32) eax_260 + 8)->u0 = ~0x0521;
			}
		}
	}
}

// 0806FFE0: void runtime.runSafePointFn(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.findrunnable
//      runtime.schedule
void runtime.runSafePointFn(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 ecx_20 = *((word32) *((word32) gs->ptr0000->tFFFFFFFC + 24) + 92);
	runtime/internal/atomic.Cas((word32) ecx_20 + 0x0968, 0x01, 0x00);
	if (bLoc08 == 0x00)
		return;
	Eq_4 edx_41 = g_t8145468;
	<anonymous> * eax_44 = *edx_41;
	eax_44();
	word32 esi_112;
	word32 edi_113;
	runtime.lock(esi, gs, 135549936, out esi_112, out edi_113);
	int32 eax_55 = g_dw814546C;
	g_dw814546C = eax_55 - 0x01;
	if (eax_55 == 0x01)
		runtime.notewakeup(gs, 0x08145470);
	word32 edx_114;
	word32 ebx_115;
	runtime.unlock(gs, 135549936, out edx_114, out ebx_115);
}

// 080700A0: void runtime.allocm(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
// Called from:
//      runtime.oneNewExtraM
//      runtime.newm
void runtime.allocm(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 eax_18 = gs->ptr0000->tFFFFFFFC;
	Eq_4 ecx_20 = *((word32) eax_18 + 24);
	*((word32) ecx_20 + 0x0078) = (word32) *((word32) ecx_20 + 0x0078) + 1;
	if (*((word32) *((word32) eax_18 + 24) + 92) == 0x00)
		runtime.acquirep(gs, dwArg04);
	Eq_4 dwLoc0C_192;
	runtime.newobject(gs, 0x080DFD60);
	if (g_t81576F0 == 0x00)
	{
		*((word32) dwLoc0C + 80) = dwArg08;
		dwLoc0C_192 = dwLoc0C;
	}
	else
	{
		runtime.writebarrierptr((word32) dwLoc0C + 80, dwArg08);
		dwLoc0C_192 = dwArg08;
	}
	runtime.mcommoninit(gs, dwLoc0C);
	if (g_b8157571 != 0x00)
	{
		runtime.malg(gs, ~0x00);
		if (g_t81576F0 == 0x00)
			*dwLoc0C = dwLoc0C_192;
		else
			runtime.writebarrierptr(dwLoc0C, dwLoc0C_192);
	}
	else
	{
		runtime.malg(gs, 0x2000);
		if (g_t81576F0 == 0x00)
			*dwLoc0C = dwLoc0C_192;
		else
			runtime.writebarrierptr(dwLoc0C, dwLoc0C_192);
	}
	Eq_4 ecx_117 = *dwLoc0C;
	if (g_t81576F0 == 0x00)
		*((word32) ecx_117 + 24) = dwLoc0C;
	else
		runtime.writebarrierptr((word32) ecx_117 + 24, dwLoc0C);
	if (dwArg04 == *((word32) (*((word32) eax_18 + 24)) + 92))
		runtime.releasep(gs);
	Eq_4 edx_152 = *((word32) eax_18 + 24);
	--*((word32) edx_152 + 0x0078);
	if (*((word32) *((word32) eax_18 + 24) + 0x0078) == 0x00 && *((word32) eax_18 + 0x006C) != 0x00)
		((word32) eax_18 + 8)->u0 = ~0x0521;
}

// 08070240: Register uint32 runtime.needm(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.sigtrampgo
//      runtime.badsignal
//      runtime.cgocallback_gofunc
uint32 runtime.needm(struct Eq_2 * gs)
{
	struct Eq_48512 * dwLoc10_168 = dwLoc10;
	if (g_b8157571 != 0x00)
	{
		dwLoc10_168 = dwLoc10;
		if (g_b8157567 == 0x00)
		{
			dwLoc10_168 = g_ptr81426D0;
			if (g_dw81426D4 <= 0x00)
				runtime.panicindex(gs);
			word32 edx_172;
			word32 ebx_173;
			runtime.write(out edx_172, out ebx_173);
			runtime.exit();
		}
	}
	runtime.lockextra((byte) dwLoc10_168);
	dwLoc10_168->b01CC = (int8) (dwLoc10_168->t00B4 == 0x00);
	--runtime.extraMCount;
	runtime.unlockextra(dwLoc10_168->t00B4);
	runtime.msigsave();
	runtime.sigblock();
	runtime.setg(gs, dwLoc10_168->t0000);
	Eq_4 eax_95 = gs->ptr0000->tFFFFFFFC;
	*((word32) eax_95 + 4) = fp + 0x0404;
	*eax_95 = fp + ~0x7FFB;
	*((word32) eax_95 + 8) = fp + ~0x7C8B;
	runtime.asminit();
	runtime.minit(gs);
	runtime.casgstatus(dwLoc10_168->t0054, 0x06, 0x03);
	return runtime/internal/atomic.Xadd(0x08145408, ~0x00);
}

// 08070370: void runtime.newextram(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.mstart1
void runtime.newextram(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime/internal/atomic.Xchg(0x081575C0, 0x00);
	if (dwLoc10 > 0x00)
	{
		up32 ecx_103;
		for (ecx_103 = 0x00; ecx_103 < dwLoc10; ++ecx_103)
			runtime.oneNewExtraM(gs);
	}
	else
	{
		runtime.lockextra(0x00);
		runtime.unlockextra(0x00);
		Eq_4 esp_42 = <invalid>;
		if (*((word32) esp_42 + 20) == 0x00)
			runtime.oneNewExtraM(gs);
	}
}

// 08070400: void runtime.oneNewExtraM(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.newextram
void runtime.oneNewExtraM(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.allocm(gs, 0x00, 0x00);
	runtime.malg(gs, 0x1000);
	*(word32 *) 0x20 = (word32) g_t80E7C14 + 1;
	*(union Eq_4 *) 0x1C = (word32) *(union Eq_4 *) 0x04 - 16;
	*(word32 *) 0x30 = 0x00;
	*(word32 *) 0x24 = 0x00;
	*(word32 *) 0x3C = *(word32 *) 0x20;
	*(union Eq_4 *) 0x38 = *(union Eq_4 *) 0x1C;
	*(union Eq_4 *) 0x40 = *(union Eq_4 *) 0x1C;
	*(byte *) 0x70 = 0x01;
	*(byte *) 111 = 0x01;
	Eq_4 esi_75 = runtime.casgstatus(0x00, 0x00, 0x06);
	if (g_t81576F0 == 0x00)
		*(union Eq_4 *) 0x18 = dwLoc20;
	else
		runtime.writebarrierptr(0x18, dwLoc20);
	if (g_t81576F0 == 0x00)
		((word32) dwLoc20 + 84)->u0 = 0x00;
	else
		runtime.writebarrierptr((word32) dwLoc20 + 84, 0x00);
	*((word32) dwLoc20 + 452) = 0x02;
	if (g_t81576F0 == 0x00)
	{
		((word32) dwLoc20 + 188)->u0 = 0x00;
		*(union Eq_4 *) 0x88 = dwLoc20;
	}
	else
	{
		runtime.writebarrierptr((word32) dwLoc20 + 188, 0x00);
		runtime.writebarrierptr(0x88, dwLoc20);
	}
	word32 ebx_300;
	word32 ebp_301;
	runtime/internal/atomic.Xadd64(0x081453E0, 0x01, 0x00, out ebx_300, out ebp_301);
	*(word32 *) 0x50 = dwLoc1C;
	*(word32 *) 0x54 = dwLoc18;
	runtime.allgadd(esi_75, gs, 0x00);
	runtime/internal/atomic.Xadd(0x08145408, 0x01);
	runtime.lockextra(0x01);
	((word32) dwLoc20 + 0x00B4)->u0 = 0x01;
	++runtime.extraMCount;
	runtime.unlockextra(dwLoc20);
}

// 08070610: void runtime.dropm(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.sigtrampgo
//      runtime.badsignal
//      runtime.cgocallback_gofunc
void runtime.dropm(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 eax_20 = *((word32) gs->ptr0000->tFFFFFFFC + 24);
	runtime.casgstatus(*((word32) eax_20 + 84), 0x03, 0x06);
	runtime/internal/atomic.Xadd(0x08145408, 0x01);
	runtime.sigblock();
	runtime.unminit(gs);
	runtime.lockextra(0x01);
	++runtime.extraMCount;
	((word32) eax_20 + 0x00B4)->u0 = 0x01;
	runtime.setg(gs, 0x00);
	runtime.unlockextra(eax_20);
	runtime.msigrestore();
}

// 080706F0: void runtime.lockextra(Stack byte bArg08)
// Called from:
//      runtime.needm
//      runtime.newextram
//      runtime.oneNewExtraM
//      runtime.dropm
void runtime.lockextra(byte bArg08)
{
	byte al_8 = 0x00;
	while (true)
	{
		while (true)
		{
			runtime/internal/atomic.Loaduintptr();
			if (dwLoc10 != 0x01)
				break;
			runtime.osyield();
		}
		if (dwLoc10 != 0x00 || bArg08 != 0x00)
			break;
		if (al_8 == 0x00)
		{
			runtime/internal/atomic.Xadd(0x081575C0, 0x01);
			dwLoc10.u0 = 0x01;
		}
		word32 edi_133;
		runtime.usleep(out edi_133);
		al_8 = 0x01;
	}
	runtime/internal/atomic.Casuintptr(135624132, dwLoc10, 0x01);
}

// 080707C0: void runtime.unlockextra(Stack Eq_4 dwArg04)
// Called from:
//      runtime.needm
//      runtime.newextram
//      runtime.oneNewExtraM
//      runtime.dropm
void runtime.unlockextra(Eq_4 dwArg04)
{
	runtime/internal/atomic.Storeuintptr(135624132, dwArg04);
}

// 080707F0: void runtime.newm(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg08)
// Called from:
//      runtime.startTheWorldWithSema
//      runtime.startm
//      runtime.main.func1
void runtime.newm(struct Eq_2 * gs, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.allocm(gs, dwArg08, dwArg04);
	dwLoc1C->t0060 = dwArg08;
	Eq_4 edx_33 = g_t8157684;
	dwLoc1C->t0030 = g_t8157680;
	dwLoc1C->t0034 = edx_33;
	if (g_b8157571 == 0x00)
	{
		runtime.(*rwmutex).rlock(gs, 0x08157700);
		runtime.newosproc(gs, dwLoc1C);
		runtime.(*rwmutex).runlock(gs, 0x08157700);
	}
	else if (_cgo_thread_start == null)
		runtime.throw(gs);
	else
	{
		runtime.(*rwmutex).rlock(gs, 0x08157700);
		word32 edi_167;
		runtime.asmcgocall(gs, _cgo_thread_start, fp - 0x0C, out edi_167);
		runtime.(*rwmutex).runlock(gs, 0x08157700);
	}
}

// 08070940: void runtime.stopm(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.mstart1
//      runtime.startlockedm
//      runtime.gcstopm
//      runtime.findrunnable
//      runtime.exitsyscall0
void runtime.stopm(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 eax_18 = gs->ptr0000->tFFFFFFFC;
	Eq_4 ecx_19 = *((word32) eax_18 + 24);
	if (*((word32) ecx_19 + 0x0078) != 0x00)
		runtime.throw(gs);
	else if (*((word32) ecx_19 + 92) != 0x00)
		runtime.throw(gs);
	else if (*((word32) ecx_19 + 0x008C) != 0x00)
		runtime.throw(gs);
	else
	{
		while (true)
		{
			word32 esi_141;
			word32 edi_142;
			runtime.lock(esi, gs, 135549936, out esi_141, out edi_142);
			runtime.mput(gs, *((word32) eax_18 + 24));
			word32 edx_143;
			word32 ebx_144;
			runtime.unlock(gs, 135549936, out edx_143, out ebx_144);
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_4 stackArg0 = <invalid>;
			runtime.notesleep(esi, gs, stackArg0, (word32) *((word32) eax_18 + 24) + 0x00AC);
			((word32) *((word32) eax_18 + 24) + 0x00AC)->u0 = 0x00;
			Eq_4 ecx_93 = *((word32) eax_18 + 24);
			if (*((word32) ecx_93 + 0x0088) == 0x00)
				break;
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_4 stackArg0 = <invalid>;
			runtime.gchelper(gs, stackArg0);
			((word32) *((word32) eax_18 + 24) + 0x0088)->u0 = 0x00;
			((word32) *((word32) eax_18 + 24) + 0x00B8)->u0 = 0x00;
			((word32) *((word32) eax_18 + 24) + 92)->u0 = 0x00;
		}
		runtime.acquirep(gs, *((word32) ecx_93 + 96));
		((word32) *((word32) eax_18 + 24) + 96)->u0 = 0x00;
	}
}

// 08070AA0: void runtime.mspinning(Register (ptr32 Eq_49089) gs)
void runtime.mspinning(struct Eq_49089 * gs)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	gs->ptr0000->ptrFFFFFFFC->ptr0018->b008C = 0x01;
}

// 08070AE0: void runtime.startm(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 bArg08)
// Called from:
//      runtime.handoffp
//      runtime.wakep
//      runtime.injectglist
void runtime.startm(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 bArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	word32 edi_278;
	word32 esi_277;
	runtime.lock(esi, gs, 135549936, out esi_277, out edi_278);
	Eq_4 eax_24 = dwArg04;
	if (dwArg04 == 0x00)
	{
		runtime.pidleget(gs);
		eax_24.u0 = 135549936;
	}
	Eq_4 ecx_74 = g_t81453F4;
	if (ecx_74 != 0x00)
	{
		g_t81453F4 = *((word32) ecx_74 + 0x00B4);
		--g_t81453F8;
	}
	word32 edx_279;
	word32 ebx_280;
	runtime.unlock(gs, 135549936, out edx_279, out ebx_280);
	if (ecx_74 == 0x00)
		runtime.newm(gs, eax_24);
	else if (*((word32) ecx_74 + 0x008C) != 0x00)
		runtime.throw(gs);
	else if (*((word32) ecx_74 + 96) != 0x00)
		runtime.throw(gs);
	else
	{
		if (bArg08 != 0x00)
		{
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_4 stackArg0 = <invalid>;
			runtime.runqempty(gs, stackArg0);
			if (bLoc14 == 0x00)
				runtime.throw(gs);
		}
		*((word32) ecx_74 + 0x008C) = bArg08;
		*((word32) ecx_74 + 96) = eax_24;
		runtime.notewakeup(gs, (word32) ecx_74 + 0x00AC);
	}
}

// 08070CB0: void runtime.handoffp(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg0C)
// Called from:
//      runtime.forEachP
//      runtime.stoplockedm
//      runtime.entersyscallblock_handoff
//      runtime.retake
void runtime.handoffp(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg0C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	Eq_4 stackArg0 = <invalid>;
	runtime.runqempty(gs, stackArg0);
	if (bLoc10 == 0x00 || g_t8145420 != 0x00)
		runtime.startm(gs, dwArg04, 0x00);
	else
	{
		if (runtime.gcBlackenEnabled != 0x00)
		{
			runtime.gcMarkWorkAvailable(gs, dwArg04);
			if (bLoc10 != 0x00)
			{
				runtime.startm(gs, dwArg04, 0x00);
				return;
			}
		}
		runtime/internal/atomic.Load();
		runtime/internal/atomic.Load();
		byte bArg00_295 = (byte) dwLoc0C;
		if ((word32) dwArg04 + dwLoc08 == 0x00)
		{
			runtime/internal/atomic.Cas(0x08145414, 0x00, 0x01);
			dwLoc08 = 0x00;
			dwLoc04 = 0x01;
			if (bArg00_295 != 0x00)
			{
				runtime.startm(gs, dwArg0C, 0x01);
				return;
			}
		}
		word32 esi_421;
		word32 edi_422;
		runtime.lock(esi, gs, 135549936, out esi_421, out edi_422);
		if (g_dw8145454 == 0x00)
		{
			if (*((word32) dwArg0C + 0x0968) != 0x00)
			{
				runtime/internal/atomic.Cas((word32) dwArg0C + 0x0968, 0x01, 0x00);
				dwLoc08 = 0x01;
				dwLoc04 = 0x00;
				if (bArg00_295 != 0x00)
				{
					Eq_4 edx_127 = g_t8145468;
					(*edx_127)();
					int32 eax_135 = g_dw814546C;
					g_dw814546C = eax_135 - 0x01;
					if (eax_135 == 0x01)
						runtime.notewakeup(gs, 0x08145470);
				}
			}
			if (g_t8145420 != 0x00)
			{
				word32 edx_425;
				word32 ebx_426;
				runtime.unlock(gs, 135549936, out edx_425, out ebx_426);
				runtime.startm(gs, dwArg0C, 0x00);
			}
			else
			{
				if (runtime.gomaxprocs - 0x01 == g_dw8145410)
				{
					word64 mm0_427;
					runtime/internal/atomic.Load64(135549928, out mm0_427);
					if (((int8) (dwLoc04 != 0x00) | (int8) (dwLoc08 != 0x00)) != 0x00)
					{
						word32 ebx_431;
						word32 edx_430;
						runtime.unlock(gs, 135549936, out edx_430, out ebx_431);
						runtime.startm(gs, dwArg0C, 0x00);
						return;
					}
				}
				runtime.pidleput(gs, dwArg0C);
				word32 ebx_429;
				word32 edx_428;
				runtime.unlock(gs, 135549936, out edx_428, out ebx_429);
			}
		}
		else
		{
			((word32) dwArg0C + 8)->u0 = 0x03;
			Eq_4 eax_239 = g_t8145458;
			g_t8145458 = eax_239 - 0x01;
			if (eax_239 == 0x01)
				runtime.notewakeup(gs, 135550044);
			word32 edx_423;
			word32 ebx_424;
			runtime.unlock(gs, 135549936, out edx_423, out ebx_424);
		}
	}
}

// 08070F40: void runtime.wakep(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.ready
//      runtime.startTheWorldWithSema
//      runtime.resetspinning
//      runtime.newproc1
void runtime.wakep(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime/internal/atomic.Cas(0x08145414, 0x00, 0x01);
	if (bLoc04 == 0x00)
		return;
	runtime.startm(gs, 0x00, 0x01);
}

// 08070FA0: void runtime.stoplockedm(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.schedule
//      runtime.exitsyscall0
void runtime.stoplockedm(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 eax_18 = gs->ptr0000->tFFFFFFFC;
	Eq_4 ecx_19 = *((word32) eax_18 + 24);
	Eq_4 edx_20 = *((word32) ecx_19 + 188);
	if (edx_20 == 0x00 || *((word32) edx_20 + 0x0088) != ecx_19)
		runtime.throw(gs);
	else
	{
		if (*((word32) ecx_19 + 92) != 0x00)
		{
			runtime.releasep(gs);
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_4 stackArg4 = <invalid>;
			Eq_4 stackArg12 = <invalid>;
			runtime.handoffp(gs, stackArg4, stackArg12);
		}
		runtime.incidlelocked(gs, 0x01);
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_4 stackArg0 = <invalid>;
		runtime.notesleep(esi, gs, stackArg0, (word32) *((word32) eax_18 + 24) + 0x00AC);
		((word32) *((word32) eax_18 + 24) + 0x00AC)->u0 = 0x00;
		runtime.readgstatus(*((word32) *((word32) eax_18 + 24) + 188));
		if ((dwLoc08 & ~0x1000) != 0x01)
		{
			runtime.printlock(gs);
			runtime.printstring(gs);
			runtime.printunlock(gs);
			runtime.dumpgstatus(gs, eax_18);
			runtime.throw(gs);
		}
		else
		{
			runtime.acquirep(gs, *((word32) *((word32) eax_18 + 24) + 96));
			((word32) *((word32) eax_18 + 24) + 96)->u0 = 0x00;
		}
	}
}

// 080710F0: void runtime.startlockedm(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      runtime.schedule
void runtime.startlockedm(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 ecx_20 = *((word32) dwArg04 + 0x0088);
	if (ecx_20 == *((word32) (gs->ptr0000)->tFFFFFFFC + 24))
		runtime.throw(gs);
	else if (*((word32) ecx_20 + 96) != 0x00)
		runtime.throw(gs);
	else
	{
		runtime.incidlelocked(gs, ~0x00);
		runtime.releasep(gs);
		((word32) ecx_20 + 96)->u0 = ~0x00;
		runtime.notewakeup(gs, (word32) ecx_20 + 0x00AC);
		runtime.stopm(gs);
	}
}

// 080711B0: void runtime.gcstopm(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.findrunnable
//      runtime.schedule
void runtime.gcstopm(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 eax_17 = gs->ptr0000->tFFFFFFFC;
	if (g_dw8145454 == 0x00)
		runtime.throw(gs);
	else
	{
		Eq_4 eax_28 = *((word32) eax_17 + 24);
		if (*((word32) eax_28 + 0x008C) != 0x00)
		{
			((word32) eax_28 + 0x008C)->u0 = 0x00;
			runtime/internal/atomic.Xadd(0x08145414, ~0x00);
			dwLoc10 = (struct Eq_49618 *) &g_dw8145414;
			if (dwLoc08 < 0x00)
				runtime.throw(gs);
		}
		runtime.releasep(gs);
		word32 esi_122;
		word32 edi_123;
		runtime.lock(esi, gs, 135549936, out esi_122, out edi_123);
		dwLoc10->dw0008 = 0x03;
		Eq_4 eax_70 = g_t8145458;
		g_t8145458 = eax_70 - 0x01;
		if (eax_70 == 0x01)
			runtime.notewakeup(gs, 135550044);
		word32 edx_124;
		word32 ebx_125;
		runtime.unlock(gs, 135549936, out edx_124, out ebx_125);
		runtime.stopm(gs);
	}
}

// 080712C0: void runtime.execute(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack byte bArg08)
// Called from:
//      runtime.schedule
//      runtime.park_m
//      runtime.exitsyscall0
void runtime.execute(struct Eq_2 * gs, Eq_4 dwArg04, byte bArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 eax_19 = gs->ptr0000->tFFFFFFFC;
	runtime.casgstatus(dwArg04, 0x01, 0x02);
	((word32) dwArg04 + 88)->u0 = 0x00;
	((word32) dwArg04 + 92)->u0 = 0x00;
	((word32) dwArg04 + 0x006C)->u0 = 0x00;
	*((word32) dwArg04 + 8) = (word32) *dwArg04 + 880;
	if (bArg08 == 0x00)
	{
		Eq_4 ebx_43 = *((word32) *((word32) eax_19 + 24) + 92);
		*((word32) ebx_43 + 16) = (word32) *((word32) ebx_43 + 16) + 1;
	}
	Eq_4 edx_55 = *((word32) eax_19 + 24);
	if (g_t81576F0 == 0x00)
		*((word32) edx_55 + 84) = dwArg04;
	else
		runtime.writebarrierptr((word32) edx_55 + 84, dwArg04);
	Eq_4 ebp_81 = *((word32) eax_19 + 24);
	if (g_t81576F0 == 0x00)
		*((word32) dwArg04 + 24) = ebp_81;
	else
		runtime.writebarrierptr((word32) dwArg04 + 24, ebp_81);
	Eq_4 edx_99 = g_t8145474;
	if (*((word32) *((word32) eax_19 + 24) + 0x0084) != edx_99)
		runtime.setThreadCPUProfiler(gs, edx_99);
	if (g_b814F4C8 != 0x00)
	{
		if (*((word32) dwArg04 + 56) != 0x00 && *((word32) dwArg04 + 115) != 0x00)
		{
			Eq_4 edx_129 = *((word32) dwArg04 + 116);
			runtime.traceGoSysExit(SLICE(edx_129, word24, 8), ebp, gs, edx_129, *((word32) dwArg04 + 0x0078));
		}
		runtime.traceGoStart(gs);
	}
	runtime.gogo(gs, (word32) dwArg04 + 28);
}

// 08071420: void runtime.findrunnable(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg00, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
// Called from:
//      runtime.schedule
void runtime.findrunnable(struct Eq_2 * gs, Eq_4 dwArg00, Eq_4 dwArg04, Eq_4 dwArg08)
{
	ptr32 fp;
	struct Eq_2 * gs;
	<type-error> Mem0;
	word32 esi;
	word32 dwLoc58;
	word32 dwLoc54;
	byte bLoc50;
	word24 nLoc4F;
	word32 dwLoc30;
	Eq_4 dwArg00;
	word32 dwLoc4C;
	word32 dwLoc48;
	word32 dwLoc28;
	Eq_4 dwArg04;
	Eq_4 dwArg08;
	word32 dwLoc0C;
	while (true)
	{
		ecx_6 = gs->ptr0000;
		ecx_7 = ecx_6->tFFFFFFFC;
		if (fp > *((word32) ecx_7 + 8))
			break;
		runtime.morestack_noctxt();
	}
	eax_18 = gs->ptr0000;
	eax_19 = eax_18->tFFFFFFFC;
l08071766:
	while (true)
	{
l08071766:
		while (true)
		{
			dwLoc28_1238 = (dwLoc28, dwLoc28_1238, dwLoc28_1560, dwLoc28_1560, dwLoc28_1384, dwLoc28_1560);
			dwLoc48_1231 = (dwLoc48, dwLoc48_1231, dwLoc48_1332, dwLoc48_1332, dwLoc48_1231, dwLoc48_1548);
			dwLoc30_1205 = (dwLoc30, dwLoc30_1205, dwLoc30_1500, dwLoc30_1500, dwLoc30_1381, dwLoc30_1500);
			nLoc4F_1174 = (nLoc4F, nLoc4F_1174, nLoc4F_1472, nLoc4F_1478, nLoc4F_1485, nLoc4F_1478);
			bLoc50_1163 = (bLoc50, bLoc50_1163, bLoc50_1450, bLoc50_1456, bLoc50_1464, bLoc50_1456);
			dwLoc54_1158 = (dwLoc54, dwLoc54_1158, dwLoc54_1440, dwLoc54_1283, dwLoc54_1442, dwLoc54_1283);
			dwLoc58_1144 = (dwLoc58, dwLoc58_1144, dwLoc58_1406, dwLoc58_1426, dwLoc58_1434, dwLoc58_1437);
			esi_1068 = (esi, esi_1068, esi_1062, esi_1062, esi_810, esi_1062);
			Mem22 = (Mem20, Mem22, Mem761, Mem523, Mem848, Mem357);
			eax_21 = (eax_19, eax_916, eax_762, eax_524, eax_860, eax_363);
			ecx_23 = *((word32) eax_21 + 24);
			edx_24 = g_dw8145454;
			ecx_25 = *((word32) ecx_23 + 92);
			if (edx_24 == 0x00)
				break;
			runtime.gcstopm(gs);
			eax_916 = eax_19;
		}
		edx_31 = *((word32) ecx_25 + 0x0968);
		if (edx_31 != 0x00)
			runtime.runSafePointFn(gs);
		edx_43 = (word32) g_b815756A;
		dl_44 = (byte) edx_43;
		if (dl_44 != 0x00)
		{
			edx_48 = (word32) g_b815756B;
			dl_49 = (byte) edx_48;
			if (dl_49 != 0x00)
			{
				runtime.wakefing(gs);
				if (dwLoc58_1144 != 0x00)
				{
					dwLoc54_1145.u0 = 0x00;
					bLoc50_1146 = 0x01;
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					stackArg4.u0 = <invalid>;
					runtime.ready(gs, stackArg4);
				}
				bLoc50_1164 = (bLoc50_1163, bLoc50_1146);
				dwLoc54_1159 = (dwLoc54_1158, dwLoc54_1145);
				Mem70 = (Mem30, Mem64);
			}
		}
		bLoc50_1161 = (bLoc50_1163, bLoc50_1163, bLoc50_1164);
		dwLoc54_1156 = (dwLoc54_1158, dwLoc54_1158, dwLoc54_1159);
		Mem73 = (Mem30, Mem30, Mem70);
		edx_74 = runtime.cgo_yield;
		edx_75 = (<anonymous> *) *edx_74;
		if (edx_75 != null)
		{
			dwLoc54_1152.u0 = 0x00;
			runtime.asmcgocall(gs, edx_75, 0x00, out edi_1657);
		}
		dwLoc54_1155 = (dwLoc54_1156, dwLoc54_1152);
		bLoc58_1182 = (byte) ecx_25;
		runtime.runqget(gs, ecx_25);
		dwLoc50_1176 = SEQ(nLoc4F_1174, bLoc50_1161);
		bLoc50_1457 = bLoc50_1161;
		nLoc4F_1479 = nLoc4F_1174;
		if (dwLoc54_1155 != 0x00)
			break;
		eax_109 = g_t8145420;
		if (eax_109 != 0x00)
		{
			runtime.lock(esi_1068, gs, 135549936, out esi_1658, out edi_1659);
			dwLoc54_1170.u0 = 0x00;
			runtime.globrunqget(gs, 0x00);
			bLoc58_1183 = 0xF0;
			runtime.unlock(gs, 135549936, out edx_1660, out ebx_1661);
			if (dwLoc50_1176 != 0x00)
				return;
		}
		dwLoc54_1185 = (dwLoc54_1155, dwLoc54_1170);
		bLoc58_1181 = (bLoc58_1182, bLoc58_1183);
		Mem148 = (Mem93, Mem129);
		runtime.netpollinited(gs);
		eax_149 = (word32) bLoc58_1181;
		al_150 = (byte) eax_149;
		if (al_150 != 0x00)
		{
			eax_154 = g_t81453E8;
			eax_24_8_164 = SLICE(eax_154, word24, 8);
			ecx_155 = g_dw81453EC;
			ecx_24_8_162 = SLICE(ecx_155, word24, 8);
			al_158 = (int8) (eax_154 != 0x00);
			cl_161 = (int8) (ecx_155 != 0x00);
			ecx_163 = SEQ(ecx_24_8_162, cl_161);
			eax_165 = SEQ(eax_24_8_164, al_158);
			ecx_166 = ecx_163 | eax_165;
			cl_167 = (byte) ecx_166;
			if (cl_167 != 0x00)
			{
				runtime.netpoll(gs, 0x00);
				if (dwLoc54_1185 != 0x00)
				{
					ecx_181 = *((word32) dwLoc54_1185 + 0x0068);
					runtime.injectglist(gs, ecx_181);
					runtime.casgstatus(dwLoc54_1185, 0x04, 0x01);
					eax_195 = (word32) g_b814F4C8;
					al_196 = (byte) eax_195;
					if (al_196 != 0x00)
						runtime.traceGoUnpark(gs, dwLoc54_1185);
					return;
				}
			}
		}
		dwLoc58_1197.u0 = 0x08145410;
		runtime/internal/atomic.Load();
		if (dwLoc30_1205 - 0x01 != dwLoc50_1176)
		{
			edx_229 = ecx_25;
			ebx_230 = *((word32) ecx_25 + 24);
			ebx_231 = (word32) *((word32) ebx_230 + 0x008C);
			bl_232 = (byte) ebx_231;
			if (bl_232 == 0x00)
			{
				dwLoc54_1216.u0 = 0x08145414;
				runtime/internal/atomic.Load();
				bLoc50_1460 = 0x10;
				nLoc4F_1482 = 529492;
				runtime/internal/atomic.Load();
				edx_250 = dwLoc28_1238 - dwLoc48_1231;
				if (dwLoc30_1205 << 0x01 >= edx_250)
				{
					eax_254 = dwArg08;
					goto l08071680;
				}
				edx_255 = dwArg04;
			}
			nLoc4F_1485 = (nLoc4F_1479, nLoc4F_1482);
			bLoc50_1463 = (bLoc50_1457, bLoc50_1460);
			dwLoc54_1445 = (dwLoc54_1185, dwLoc54_1216);
			Mem257 = (Mem219, Mem243);
			edx_256 = (edx_229, edx_255);
			ecx_258 = *((word32) edx_256 + 24);
			ebx_259 = (word32) *((word32) ecx_258 + 0x008C);
			bl_260 = (byte) ebx_259;
			if (bl_260 == 0x00)
			{
				((word32) ecx_258 + 0x008C)->u0 = 0x01;
				dwLoc58_1254.u0 = 0x08145414;
				dwLoc54_1255.u0 = 0x01;
				runtime/internal/atomic.Xadd(0x08145414, 0x01);
			}
			dwLoc58_1656 = (dwLoc58_1197, dwLoc58_1254);
			dwLoc54_1444 = (dwLoc54_1445, dwLoc54_1255);
			Mem921 = (Mem257, Mem268);
			eax_277 = 0x00;
			dwLoc58_1653 = dwLoc58_1656;
			while (true)
			{
				dwLoc58_1654 = (dwLoc58_1653, dwLoc58_1648);
				dwLoc28_1563 = (dwLoc28_1238, dwLoc28_1384);
				dwLoc30_1503 = (dwLoc30_1205, dwLoc30_1381);
				bLoc50_1461 = (bLoc50_1463, bLoc50_1464);
				dwLoc54_1443 = (dwLoc54_1444, dwLoc54_1442);
				esi_1077 = (esi_1068, esi_810);
				Mem284 = (Mem921, Mem848);
				eax_280 = (eax_277, eax_854);
				if (eax_280 >= 0x04)
					break;
				ecx_798 = gs->ptr0000;
				ecx_799 = ecx_798->tFFFFFFFC;
				ecx_800 = *((word32) ecx_799 + 24);
				ebx_801 = *((word32) ecx_800 + 0x0094);
				ebx_804 = ebx_801 >> 0x1F & 0xA8888EEF;
				ebp_806 = ebx_801 << 0x01 ^ ebx_804;
				*((word32) ecx_800 + 0x0094) = ebp_806;
				ecx_808 = g_dw81451B0;
				ebx_809 = g_ptr81451B4;
				esi_810 = g_t81451B8;
				if (ecx_808 == 0x00)
					runtime.panicdivide(gs);
				edx_eax_822 = (uint64) ebp_806;
				edx_824 = (uint32) (edx_eax_822 % ecx_808);
				if (esi_810 == 0x00)
					runtime.panicdivide(gs);
				edx_eax_837 = (uint64) ebp_806;
				edx_839 = (uint32) (edx_eax_837 % esi_810);
				edx_842 = ebx_809[edx_839];
				dwLoc30_1377 = 0x00;
				dwLoc28_1379 = edx_824;
				dwLoc58_1647 = dwLoc58_1654;
				while (true)
				{
					dwLoc58_1648 = (dwLoc58_1647, dwLoc58_1387);
					bLoc50_1464 = (bLoc50_1461, bLoc50_1388);
					dwLoc54_1442 = (dwLoc54_1443, dwLoc54_1385);
					dwLoc28_1384 = (dwLoc28_1379, dwLoc28_1394);
					dwLoc30_1381 = (dwLoc30_1377, dwLoc30_1392);
					Mem848 = (Mem846, Mem906);
					dwLoc58_1434 = dwLoc58_1648;
					if (dwLoc30_1381 == ecx_808)
						break;
					eax_856 = g_dw8145454;
					if (eax_856 != 0x00)
					{
						eax_860 = eax_19;
						goto l08071766;
					}
					if (dwLoc28_1384 >= 0x0401)
						runtime.panicindex(gs);
					eax_870 = *((char *) g_a81478C0 + dwLoc28_1384 * 0x04);
					dwLoc54_1385 = eax_870;
					dwLoc58_1387 = ecx_25;
					dl_876 = (int8) (eax_280 > 0x02);
					bLoc50_1388 = dl_876;
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					stackArg0.u0 = <invalid>;
					runtime.runqsteal(gs, stackArg0, ecx_25, dl_876);
					if (dwLoc4C != 0x00)
						return;
					dwLoc30_1392 = dwLoc30_1381 + 0x01;
					eax_895 = dwLoc28_1384 + edx_842;
					if (ecx_808 == 0x00)
						runtime.panicdivide(gs);
					edx_eax_901 = (uint64) eax_895;
					edx_903 = (uint32) (edx_eax_901 % ecx_808);
					dwLoc28_1394 = edx_903;
				}
				eax_854 = eax_280 + 0x01;
			}
			eax_285 = ecx_25;
			dwLoc58_1650 = dwLoc58_1654;
			goto l08071680;
		}
		eax_228 = dwArg00;
l08071680:
		dwLoc58_1651 = (dwLoc58_1197, dwLoc58_1197, dwLoc58_1650);
		dwLoc28_1560 = (dwLoc28_1238, dwLoc28_1238, dwLoc28_1563);
		dwLoc48_1548 = (dwLoc48_1231, dwLoc48_1551, dwLoc48_1231, dwLoc48_1231);
		nLoc48_1641 = (word24) dwLoc48_1548;
		dwLoc30_1500 = (dwLoc30_1205, dwLoc30_1500, dwLoc30_1205, dwLoc30_1503);
		nLoc4F_1478 = (nLoc4F_1479, nLoc4F_1478, nLoc4F_1482, nLoc4F_1485);
		bLoc50_1456 = (bLoc50_1457, bLoc50_1456, bLoc50_1460, bLoc50_1461);
		dwLoc54_1283 = (dwLoc54_1185, dwLoc54_1283, dwLoc54_1216, dwLoc54_1443);
		bLoc58_1264 = (byte) dwLoc58_1651;
		esi_1062 = (esi_1068, esi_1062, esi_1068, esi_1077);
		esp_287 = fp - 92;
		eax_286 = (eax_228, eax_789, eax_254, eax_285);
		ecx_289 = runtime.gcBlackenEnabled;
		if (ecx_289 != 0x00)
		{
			ecx_293 = *((word32) eax_286 + 0x0948);
			if (ecx_293 != 0x00)
			{
				runtime.gcMarkWorkAvailable(gs, eax_286);
				eax_303 = (word32) bLoc58_1264;
				al_304 = (byte) eax_303;
				if (al_304 != 0x00)
				{
					((word32) eax_286 + 0x094C)->u0 = 0x02;
					eax_310 = *((word32) eax_286 + 0x0948);
					runtime.casgstatus(eax_310, 0x04, 0x01);
					eax_319 = (word32) g_b814F4C8;
					al_320 = (byte) eax_319;
					if (al_320 != 0x00)
						runtime.traceGoUnpark(gs, eax_310);
					return;
				}
			}
		}
		runtime.lock(esi_1062, gs, 135549936, out esi_1662, out edi_1663);
		eax_346 = g_dw8145454;
		dwLoc58_1437 = dwLoc58_1651;
		if (eax_346 == 0x00)
		{
			ecx_351 = *((word32) eax_286 + 0x0968);
			if (ecx_351 == 0x00)
			{
				ecx_364 = g_t8145420;
				if (ecx_364 != 0x00)
				{
					runtime.globrunqget(gs, 0x00);
					runtime.unlock(gs, 135549936, out edx_1666, out ebx_1667);
					return;
				}
				runtime.releasep(gs);
				if (eax_286 != 135549936)
					runtime.throw(gs);
				runtime.pidleput(gs, eax_286);
				bLoc5C_1634 = 0xF0;
				runtime.unlock(gs, 135549936, out edx_1668, out ebx_1669);
				ecx_414 = *((word32) dwLoc0C + 24);
				edx_415 = (word32) *((word32) ecx_414 + 0x008C);
				dl_416 = (byte) edx_415;
				if (dl_416 != 0x00)
				{
					((word32) ecx_414 + 0x008C)->u0 = 0x00;
					bLoc5C_1635 = 0x14;
					dwLoc58_1294.u0 = ~0x00;
					runtime/internal/atomic.Xadd(0x08145414, ~0x00);
					if (dwLoc54_1283 < 0x00)
						runtime.throw(gs);
				}
				dwLoc58_1652 = (dwLoc58_1651, dwLoc58_1294);
				bLoc5C_1633 = (bLoc5C_1634, bLoc5C_1635);
				bLoc58_1626 = (byte) dwLoc58_1652;
				Mem924 = (Mem417, Mem424);
				ecx_445.u0 = 0x00;
				while (true)
				{
					bLoc5C_1316 = (bLoc5C_1633, bLoc5C_1636);
					ecx_450 = (ecx_445, ecx_795);
					Mem448 = (Mem924, Mem925);
					ebx_449 = runtime.gomaxprocs;
					dwLoc48_1332 = SEQ(dl_416, nLoc48_1641);
					if (ecx_450 >= 0x0401)
						break;
					ebp_462 = *((char *) g_a81478C0 + ecx_450 * 0x04);
					if (ebp_462 != 0x00)
					{
						bLoc5C_1637 = (byte) ebp_462;
						// Failed to bind call argument.
						// Please report this issue at https://github.com/uxmal/reko
						stackArg0.u0 = <invalid>;
						runtime.runqempty(gs, stackArg0);
						eax_472 = (word32) bLoc58_1626;
						al_473 = (byte) eax_472;
						if (al_473 == 0x00)
						{
							runtime.lock(esi_1062, gs, 135549936, out esi_1672, out edi_1673);
							runtime.pidleget(gs);
							bLoc5C_1317 = 0xF0;
							runtime.unlock(gs, 135549936, out edx_1674, out ebx_1675);
							runtime.acquirep(gs, 135549936);
							eax_504 = (word32) dl_416;
							al_505 = (byte) eax_504;
							if (al_505 != 0x00)
							{
								ecx_510 = *((word32) dwLoc0C + 24);
								((word32) ecx_510 + 0x008C)->u0 = 0x01;
								dwLoc58_1307.u0 = 0x01;
								runtime/internal/atomic.Xadd(0x08145414, 0x01);
							}
							dwLoc58_1426 = (dwLoc58_1425, dwLoc58_1307);
							Mem523 = (Mem499, Mem514);
							eax_524 = dwLoc0C;
							goto l08071766;
						}
					}
					bLoc5C_1636 = (bLoc5C_1316, bLoc5C_1637);
					Mem925 = (Mem448, Mem467);
					ecx_795 = (word32) ecx_450 + 1;
				}
				runtime.panicindex(gs);
			}
		}
		runtime.unlock(gs, 135549936, out edx_1664, out ebx_1665);
		eax_363 = dwLoc0C;
	}
}

// 08071D50: void runtime.pollWork(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg00)
// Called from:
//      runtime.gcDrain
void runtime.pollWork(struct Eq_2 * gs, Eq_4 dwArg00)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (g_t8145420 != 0x00)
		return;
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	Eq_4 bLoc08_99 = *((word32) *((word32) gs->ptr0000->tFFFFFFFC + 24) + 92);
	Eq_4 stackArg0 = <invalid>;
	runtime.runqempty(gs, stackArg0);
	if (bLoc04 == 0x00)
		return;
	runtime.netpollinited(gs);
	if (bLoc08_99 == 0x00)
		return;
	runtime/internal/atomic.Load();
	if (dwArg00 <= 0x00)
		return;
	Eq_4 eax_56 = g_t81453E8;
	word32 ecx_57 = g_dw81453EC;
	if (((int8) (ecx_57 != 0x00) | (int8) (eax_56 != 0x00)) == 0x00)
		return;
	runtime.netpoll(gs, 0x00);
	if (dwArg00 == 0x00)
		return;
	runtime.injectglist(gs, dwArg00);
}

// 08071E30: void runtime.resetspinning(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.schedule
void runtime.resetspinning(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 eax_18 = *((word32) gs->ptr0000->tFFFFFFFC + 24);
	if (*((word32) eax_18 + 0x008C) == 0x00)
		runtime.throw(gs);
	else
	{
		((word32) eax_18 + 0x008C)->u0 = 0x00;
		runtime/internal/atomic.Xadd(0x08145414, ~0x00);
		if (dwLoc04 < 0x00)
			runtime.throw(gs);
		else if (dwLoc04 == 0x00)
		{
			runtime/internal/atomic.Load();
			if (dwLoc04 > 0x00)
				runtime.wakep(gs);
		}
	}
}

// 08071EF0: void runtime.injectglist(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      runtime.gcMarkTermination
//      runtime.gcWakeAllAssists
//      runtime.startTheWorldWithSema
//      runtime.findrunnable
//      runtime.pollWork
//      runtime.sysmon
void runtime.injectglist(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 eax_17 = dwArg04;
	if (dwArg04 == 0x00)
		return;
	if (g_b814F4C8 != 0x00)
	{
		while (eax_17 != 0x00)
		{
			runtime.traceGoUnpark(gs, eax_17);
			eax_17 = *((word32) eax_17 + 0x0068);
		}
	}
	word32 edi_199;
	word32 esi_198;
	runtime.lock(esi, gs, 135549936, out esi_198, out edi_199);
	Eq_4 eax_140 = dwArg04;
	word32 ecx_139 = 0x00;
	while (eax_140 != 0x00)
	{
		Eq_4 ecx_97 = *((word32) eax_140 + 0x0068);
		runtime.casgstatus(eax_140, 0x04, 0x01);
		((word32) eax_140 + 0x0068)->u0 = 0x00;
		Eq_4 ecx_108 = g_t814541C;
		if (ecx_108 != 0x00)
			*((word32) ecx_108 + 0x0068) = eax_140;
		else
			g_t8145418 = eax_140;
		g_t814541C = eax_140;
		g_t8145420 = (word32) g_t8145420 + 1;
		++ecx_139;
		eax_140 = ecx_97;
	}
	word32 edx_200;
	word32 ebx_201;
	runtime.unlock(gs, 135549936, out edx_200, out ebx_201);
	word32 eax_71 = ecx_139;
	while (eax_71 != 0x00 && g_dw8145410 != 0x00)
	{
		runtime.startm(gs, 0x00, 0x00);
		--eax_71;
	}
}

// 08072040: void runtime.schedule(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.mstart1
//      runtime.park_m
//      runtime.goschedImpl
//      runtime.goexit0
//      runtime.exitsyscall0
void runtime.schedule(struct Eq_2 * gs)
{
	word24 nLoc17_395 = SLICE(dwLoc18, word24, 8);
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 ecx_18 = gs->ptr0000->tFFFFFFFC;
	Eq_4 edx_19 = *((word32) ecx_18 + 24);
	if (*((word32) edx_19 + 0x0078) != 0x00)
		runtime.throw(gs);
	else
	{
		if (*((word32) edx_19 + 188) != 0x00)
		{
			runtime.stoplockedm(gs);
			Eq_4 ecx_42 = *((word32) *((word32) ecx_18 + 24) + 188);
			runtime.execute(gs, ecx_42, 0x00);
			dwLoc1C = ecx_42;
			dwLoc18 = SEQ(nLoc17_395, 0x00);
		}
		while (true)
		{
			while (g_dw8145454 != 0x00)
				runtime.gcstopm(gs);
			if (*((word32) *((word32) *((word32) ecx_18 + 24) + 92) + 0x0968) != 0x00)
				runtime.runSafePointFn(gs);
			Eq_4 eax_100;
			if (g_b814F4C8 != 0x00 || g_b814F4C9 != 0x00)
			{
				runtime.traceReader(gs);
				eax_100 = dwLoc1C;
				if (dwLoc1C != 0x00)
				{
					runtime.casgstatus(dwLoc1C, 0x04, 0x01);
					runtime.traceGoUnpark(gs, dwLoc1C);
					dwLoc14.u0 = 0x01;
					dwLoc18.u0 = 0x00;
					eax_100 = dwLoc1C;
				}
			}
			else
				eax_100.u0 = 0x00;
			Eq_4 dwLoc1C_329 = dwLoc1C;
			byte bLoc14_357 = (byte) dwLoc14;
			if (eax_100 == 0x00 && runtime.gcBlackenEnabled != 0x00)
			{
				Eq_4 ecx_131 = *((word32) *((word32) ecx_18 + 24) + 92);
				runtime.(*gcControllerState).findRunnableGCWorker(esi, edi, gs, &g_dw8157860, ecx_131);
				dwLoc1C_329.u0 = 0x08157860;
				dwLoc18 = ecx_131;
				eax_100 = dwLoc14;
			}
			if (eax_100 == 0x00)
			{
				Eq_4 edx_152 = *((word32) *((word32) *((word32) ecx_18 + 24) + 92) + 16);
				Eq_4 ebx_153 = eax_100;
				if (edx_152 - (SLICE(edx_152 *64 2253097598, word32, 32) >> 0x05) *s 0x3D == 0x00 && g_t8145420 > 0x00)
				{
					word32 esi_423;
					word32 edi_424;
					runtime.lock(esi, gs, 135549936, out esi_423, out edi_424);
					runtime.globrunqget(gs, 0x01);
					word32 edx_425;
					word32 ebx_426;
					runtime.unlock(gs, 135549936, out edx_425, out ebx_426);
					dwLoc18.u0 = 0x01;
					dwLoc1C_329.u0 = 135549936;
					ebx_153 = dwLoc14;
				}
				eax_100 = ebx_153;
			}
			byte cl_258;
			byte bLoc18_369 = (byte) dwLoc18;
			if (eax_100 != 0x00)
				cl_258 = 0x00;
			else
			{
				Eq_4 ecx_205 = *((word32) *((word32) ecx_18 + 24) + 92);
				runtime.runqget(gs, ecx_205);
				dwLoc1C_329 = ecx_205;
				eax_100 = dwLoc18;
				cl_258 = bLoc14_357;
				if (dwLoc18 != 0x00 && *((word32) (*((word32) ecx_18 + 24)) + 0x008C) != 0x00)
					runtime.throw(gs);
			}
			if (eax_100 == 0x00)
			{
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				Eq_4 stackArg0 = <invalid>;
				runtime.findrunnable(gs, stackArg0, dwLoc1C_329, dwLoc18);
				eax_100 = dwLoc1C_329;
				cl_258 = bLoc18_369;
			}
			if (*((word32) *((word32) ecx_18 + 24) + 0x008C) != 0x00)
				runtime.resetspinning(gs);
			if (*((word32) eax_100 + 0x0088) == 0x00)
			{
				runtime.execute(gs, eax_100, cl_258);
				return;
			}
			runtime.startlockedm(gs, eax_100);
			dwLoc1C = eax_100;
		}
	}
}

// 08072310: void runtime.parkunlock_c(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg08)
void runtime.parkunlock_c(struct Eq_2 * gs, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	word32 edx_42;
	word32 ebx_43;
	runtime.unlock(gs, dwArg08, out edx_42, out ebx_43);
}

// 08072350: void runtime.park_m(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void runtime.park_m(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 eax_18 = gs->ptr0000->tFFFFFFFC;
	if (g_b814F4C8 != 0x00)
	{
		Eq_4 ecx_25 = *((word32) eax_18 + 24);
		runtime.traceGoPark(gs, *((word32) ecx_25 + 472), *((word32) ecx_25 + 476));
	}
	runtime.casgstatus(dwArg04, 0x02, 0x04);
	Eq_4 eax_63 = gs->ptr0000->tFFFFFFFC;
	((word32) *((word32) *((word32) eax_63 + 24) + 84) + 24)->u0 = 0x00;
	((word32) *((word32) eax_63 + 24) + 84)->u0 = 0x00;
	Eq_4 ecx_80 = *((word32) eax_18 + 24);
	if (*((word32) ecx_80 + 464) != 0x00)
	{
		Eq_4 edx_89 = *((word32) ecx_80 + 464);
		(*edx_89)();
		Eq_4 ecx_100 = *((word32) eax_18 + 24);
		if (g_t81576F0 == 0x00)
			((word32) ecx_100 + 464)->u0 = 0x00;
		else
			runtime.writebarrierptr((word32) ecx_100 + 464, 0x00);
		Eq_4 eax_126 = *((word32) eax_18 + 24);
		if (g_t81576F0 == 0x00)
			((word32) eax_126 + 468)->u0 = 0x00;
		else
			runtime.writebarrierptr((word32) eax_126 + 468, 0x00);
	}
	runtime.schedule(gs);
}

// 08072520: void runtime.goschedImpl(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      runtime.gosched_m
//      runtime.gopreempt_m
void runtime.goschedImpl(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.readgstatus(dwArg04);
	if ((dwLoc08 & ~0x1000) != 0x02)
	{
		runtime.dumpgstatus(gs, dwArg04);
		runtime.throw(gs);
	}
	else
	{
		runtime.casgstatus(dwArg04, dwArg04, 0x01);
		Eq_4 eax_52 = gs->ptr0000->tFFFFFFFC;
		((word32) *((word32) *((word32) eax_52 + 24) + 84) + 24)->u0 = 0x00;
		((word32) *((word32) eax_52 + 24) + 84)->u0 = 0x00;
		word32 esi_142;
		word32 edi_143;
		runtime.lock(esi, gs, 135549936, out esi_142, out edi_143);
		((word32) dwArg04 + 0x0068)->u0 = 0x00;
		Eq_4 ecx_78 = g_t814541C;
		if (ecx_78 != 0x00)
			*((word32) ecx_78 + 0x0068) = dwArg04;
		else
			g_t8145418 = dwArg04;
		g_t814541C = dwArg04;
		g_t8145420 = (word32) g_t8145420 + 1;
		word32 edx_144;
		word32 ebx_145;
		runtime.unlock(gs, 135549936, out edx_144, out ebx_145);
		runtime.schedule(gs);
	}
}

// 08072640: void runtime.gosched_m(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void runtime.gosched_m(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (g_b814F4C8 != 0x00)
		runtime.traceGoSched(gs);
	runtime.goschedImpl(gs, dwArg04);
}

// 08072680: void runtime.gopreempt_m(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.newstack
void runtime.gopreempt_m(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (g_b814F4C8 != 0x00)
		runtime.traceGoPreempt(gs);
	runtime.goschedImpl(gs, dwArg04);
}

// 080726C0: void runtime.goexit1(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.goexit
void runtime.goexit1(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (g_b814F4C8 != 0x00)
		runtime.traceGoEnd(gs);
	word32 esi_66;
	runtime.mcall(gs, dwLoc08, &g_dw80E7C10, out esi_66);
}

// 08072700: void runtime.goexit0(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void runtime.goexit0(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	int8 cl_62;
	Eq_4 eax_19 = gs->ptr0000->tFFFFFFFC;
	runtime.casgstatus(dwArg04, 0x02, 0x06);
	Eq_4 ecx_38 = *((word32) dwArg04 + 0x00AC);
	if (runtime.runfinqPC == ecx_38 && g_b8157569 == 0x00)
		cl_62 = 0x01;
	else if (runtime.bgsweepPC == ecx_38)
		cl_62 = 0x01;
	else if (runtime.forcegchelperPC == ecx_38)
		cl_62 = 0x01;
	else if (runtime.timerprocPC == ecx_38)
		cl_62 = 0x01;
	else
		cl_62 = (int8) (runtime.gcBgMarkWorkerPC == ecx_38);
	if (cl_62 != 0x00)
		runtime/internal/atomic.Xadd(0x08145408, ~0x00);
	if (g_t81576F0 == 0x00)
	{
		((word32) dwArg04 + 24)->u0 = 0x00;
		((word32) dwArg04 + 0x0088)->u0 = 0x00;
	}
	else
	{
		runtime.writebarrierptr((word32) dwArg04 + 24, 0x00);
		runtime.writebarrierptr((word32) dwArg04 + 0x0088, 0x00);
	}
	Eq_4 edx_127 = *((word32) eax_19 + 24);
	if (g_t81576F0 == 0x00)
		((word32) edx_127 + 188)->u0 = 0x00;
	else
		runtime.writebarrierptr((word32) edx_127 + 188, 0x00);
	*((word32) dwArg04 + 0x006D) = 0x00;
	if (g_t81576F0 == 0x00)
	{
		((word32) dwArg04 + 20)->u0 = 0x00;
		((word32) dwArg04 + 16)->u0 = 0x00;
	}
	else
	{
		runtime.writebarrierptr((word32) dwArg04 + 20, 0x00);
		runtime.writebarrierptr((word32) dwArg04 + 16, 0x00);
	}
	((word32) dwArg04 + 0x0094)->u0 = 0x00;
	((word32) dwArg04 + 0x0098)->u0 = 0x00;
	if (g_t81576F0 == 0x00)
		*((word32) dwArg04 + 144) = 0x00;
	else
		runtime.writebarrierptr((word32) dwArg04 + 144, 0x00);
	((word32) dwArg04 + 100)->u0 = 0x00;
	if (g_t81576F0 == 0x00)
	{
		((word32) dwArg04 + 96)->u0 = 0x00;
		((word32) dwArg04 + 0x0044)->u0 = 0x00;
		((word32) dwArg04 + 0x00C4)->u0 = 0x00;
		((word32) dwArg04 + 200)->u0 = 0x00;
	}
	else
	{
		runtime.writebarrierptr((word32) dwArg04 + 96, 0x00);
		runtime.writebarrierptr((word32) dwArg04 + 0x0044, 0x00);
		runtime.writebarrierptr((word32) dwArg04 + 0x00C4, 0x00);
		runtime.writebarrierptr((word32) dwArg04 + 200, 0x00);
	}
	((word32) dwArg04 + 112)->u0 = 0x01;
	Eq_4 edx_285 = gs->ptr0000->tFFFFFFFC;
	((word32) *((word32) *((word32) edx_285 + 24) + 84) + 24)->u0 = 0x00;
	((word32) *((word32) edx_285 + 24) + 84)->u0 = 0x00;
	Eq_4 edx_304 = *((word32) eax_19 + 24);
	uint32 ebx_305 = *((word32) edx_304 + 452);
	word24 ebx_24_8_330 = SLICE(ebx_305, word24, 8);
	if ((ebx_305 & ~0x01) != 0x00)
	{
		runtime.printlock(gs);
		runtime.printstring(gs);
		runtime.printint(ebx_24_8_330, gs, (uint64) ebx_305);
		runtime.printstring(gs);
		runtime.printunlock(gs);
		runtime.throw(gs);
	}
	else
	{
		*((word32) edx_304 + 452) = 0x00;
		runtime.gfput((word32) dwArg04 + 0x00C4, gs, *((word32) *((word32) eax_19 + 24) + 92), dwArg04);
		runtime.schedule(gs);
	}
}

// 08072AC0: void runtime.save(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
// Called from:
//      runtime.reentersyscall
//      runtime.entersyscallblock
void runtime.save(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08)
{
	Eq_4 eax_7 = gs->ptr0000->tFFFFFFFC;
	*((word32) eax_7 + 32) = dwArg04;
	*((word32) eax_7 + 28) = dwArg08;
	((word32) eax_7 + 48)->u0 = 0x00;
	((word32) eax_7 + 44)->u0 = 0x00;
	*((word32) eax_7 + 36) = eax_7;
	if (*((word32) eax_7 + 40) != 0x00)
		runtime.badctxt();
}

// 08072B00: void runtime.reentersyscall(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
// Called from:
//      runtime.cgocallbackg
//      runtime.entersyscall
void runtime.reentersyscall(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08)
{
	Eq_4 eax_9 = gs->ptr0000->tFFFFFFFC;
	Eq_4 ecx_11 = *((word32) eax_9 + 24);
	*((word32) ecx_11 + 0x0078) = (word32) *((word32) ecx_11 + 0x0078) + 1;
	((word32) eax_9 + 8)->u0 = ~0x0521;
	*((word32) eax_9 + 113) = 0x01;
	runtime.save(gs, dwArg04, dwArg08);
	*((word32) eax_9 + 56) = dwArg08;
	*((word32) eax_9 + 60) = dwArg04;
	runtime.casgstatus(eax_9, 0x02, 0x03);
	Eq_4 esp_107 = fp - 0x18;
	Eq_4 ecx_49 = *((word32) eax_9 + 56);
	if (ecx_49 < *eax_9 || *((word32) eax_9 + 4) < ecx_49)
	{
		word32 ebp_283;
		word32 edi_284;
		runtime.systemstack(gs, fp - 0x08, out ebp_283, out edi_284);
		esp_107.u0 = <invalid>;
	}
	if (g_b814F4C8 != 0x00)
	{
		esp_107.u0->u0 = 0x080E7CFC;
		word32 ebp_285;
		word32 edi_286;
		runtime.systemstack(gs, *esp_107.u0, out ebp_285, out edi_286);
		esp_107.u0 = <invalid>;
		*esp_107.u0 = *((byte) esp_107.u0 + 28);
		*((byte) esp_107.u0 + 4) = *((byte) esp_107.u0 + 32);
		runtime.save(gs, *esp_107.u0, *((byte) esp_107.u0 + 4));
	}
	esp_107.u0->u0 = 0x08145460;
	runtime/internal/atomic.Load();
	Eq_4 esp_110 = (byte) esp_107.u0 + 4;
	if (*((word32) esp_110 + 4) != 0x00)
	{
		*esp_110 = 0x080E7BD0;
		word32 ebp_287;
		word32 edi_288;
		runtime.systemstack(gs, *esp_110, out ebp_287, out edi_288);
		esp_110.u0 = <invalid>;
		*esp_110.u0 = *((byte) esp_110.u0 + 28);
		*((byte) esp_110.u0 + 4) = *((byte) esp_110.u0 + 32);
		runtime.save(gs, *esp_110.u0, *((byte) esp_110.u0 + 4));
	}
	Eq_4 eax_141 = *((byte) esp_110.u0 + 0x0C);
	if (*((word32) *((word32) *((word32) eax_141 + 24) + 92) + 0x0968) != 0x00)
	{
		*esp_110.u0 = 135167156;
		word32 ebp_289;
		word32 edi_290;
		runtime.systemstack(gs, *esp_110.u0, out ebp_289, out edi_290);
		esp_110.u0 = <invalid>;
		*esp_110.u0 = *((byte) esp_110.u0 + 28);
		*((byte) esp_110.u0 + 4) = *((byte) esp_110.u0 + 32);
		runtime.save(gs, *esp_110.u0, *((byte) esp_110.u0 + 4));
		eax_141 = *((byte) esp_110.u0 + 0x0C);
	}
	Eq_4 ecx_177 = *((word32) eax_141 + 24);
	*((word32) ecx_177 + 484) = *((word32) *((word32) ecx_177 + 92) + 20);
	*((word32) eax_141 + 115) = 0x01;
	((word32) *((word32) eax_141 + 24) + 0x00B8)->u0 = 0x00;
	((word32) *((word32) *((word32) eax_141 + 24) + 92) + 48)->u0 = 0x00;
	*esp_110.u0 = (word32) *((word32) *((word32) eax_141 + 24) + 92) + 8;
	((byte) esp_110.u0 + 4)->u0 = 0x02;
	runtime/internal/atomic.Store(*esp_110.u0, *((byte) esp_110.u0 + 4));
	if (g_dw8145454 != 0x00)
	{
		*esp_110.u0 = 0x080E7BCC;
		word32 ebp_291;
		word32 edi_292;
		runtime.systemstack(gs, *esp_110.u0, out ebp_291, out edi_292);
		Eq_4 esp_213 = <invalid>;
		*esp_213 = *((word32) esp_213 + 28);
		*((word32) esp_213 + 4) = *((word32) esp_213 + 32);
		runtime.save(gs, *esp_213, *((word32) esp_213 + 4));
	}
	((word32) eax_9 + 8)->u0 = ~0x0521;
	Eq_4 eax_232 = *((word32) eax_9 + 24);
	--*((word32) eax_232 + 0x0078);
}

// 08072D00: void runtime.entersyscall(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.cgocall
//      syscall.Syscall
//      syscall.Syscall6
void runtime.entersyscall(struct Eq_2 * gs)
{
	runtime.getcallerpc();
	runtime.reentersyscall(gs, dwLoc04, fp + 0x04);
}

// 08072D30: void runtime.entersyscall_sysmon(Register Eq_4 esi, Register (ptr32 Eq_2) gs, Stack word32 dwArg00)
void runtime.entersyscall_sysmon(Eq_4 esi, struct Eq_2 * gs, word32 dwArg00)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	word32 edi_89;
	word32 esi_88;
	runtime.lock(esi, gs, 135549936, out esi_88, out edi_89);
	runtime/internal/atomic.Load();
	if (dwArg00 != 0x00)
	{
		runtime/internal/atomic.Store(0x08145460, 0x00);
		runtime.notewakeup(gs, 135550052);
	}
	word32 edx_90;
	word32 ebx_91;
	runtime.unlock(gs, 135549936, out edx_90, out ebx_91);
}

// 08072DB0: void runtime.entersyscall_gcwait(Register Eq_4 esi, Register (ptr32 Eq_2) gs)
void runtime.entersyscall_gcwait(Eq_4 esi, struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 eax_21 = *((word32) *((word32) gs->ptr0000->tFFFFFFFC + 24) + 92);
	word32 esi_149;
	word32 edi_150;
	runtime.lock(esi, gs, 135549936, out esi_149, out edi_150);
	if (g_t8145458 > 0x00)
	{
		runtime/internal/atomic.Cas((word32) eax_21 + 8, 0x02, 0x03);
		if (bLoc08 != 0x00)
		{
			if (g_b814F4C8 != 0x00)
			{
				word32 ebp_153;
				word32 esi_154;
				runtime.traceGoSysBlock(gs, eax_21, out ebp_153, out esi_154);
				runtime.traceProcStop(gs, eax_21);
			}
			*((word32) eax_21 + 20) = (word32) *((word32) eax_21 + 20) + 1;
			Eq_4 eax_94 = g_t8145458;
			g_t8145458 = eax_94 - 0x01;
			if (eax_94 == 0x01)
				runtime.notewakeup(gs, 135550044);
		}
	}
	word32 edx_151;
	word32 ebx_152;
	runtime.unlock(gs, 135549936, out edx_151, out ebx_152);
}

// 08072EA0: void runtime.entersyscallblock(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.notetsleepg
void runtime.entersyscallblock(struct Eq_2 * gs)
{
	Eq_4 eax_8 = gs->ptr0000->tFFFFFFFC;
	Eq_4 ecx_10 = *((word32) eax_8 + 24);
	*((word32) ecx_10 + 0x0078) = (word32) *((word32) ecx_10 + 0x0078) + 1;
	*((word32) eax_8 + 113) = 0x01;
	((word32) eax_8 + 8)->u0 = ~0x0521;
	Eq_4 ecx_16 = *((word32) eax_8 + 24);
	*((word32) ecx_16 + 484) = *((word32) *((word32) ecx_16 + 92) + 20);
	*((word32) eax_8 + 115) = 0x01;
	Eq_4 edx_22 = *((word32) *((word32) eax_8 + 24) + 92);
	*((word32) edx_22 + 20) = (word32) *((word32) edx_22 + 20) + 1;
	runtime.getcallerpc();
	runtime.save(gs, dwLoc34, fp + 0x04);
	*((word32) eax_8 + 56) = *((word32) eax_8 + 28);
	*((word32) eax_8 + 60) = *((word32) eax_8 + 32);
	Eq_4 ecx_52 = *((word32) eax_8 + 56);
	if (ecx_52 < *eax_8 || *((word32) eax_8 + 4) < ecx_52)
	{
		fn0808FD8B(0x00, fp - 0x14);
		word32 edi_199;
		word32 ebp_198;
		runtime.systemstack(gs, fp - 0x14, out ebp_198, out edi_199);
	}
	runtime.casgstatus(eax_8, 0x02, 0x03);
	Eq_4 ecx_99 = *((word32) eax_8 + 56);
	if (ecx_99 < *eax_8 || *((word32) eax_8 + 4) < ecx_99)
	{
		word32 edi_201;
		word32 ebp_200;
		runtime.systemstack(gs, fp - 0x20, out ebp_200, out edi_201);
	}
	word32 ebp_202;
	word32 edi_203;
	runtime.systemstack(gs, 135166932, out ebp_202, out edi_203);
	runtime.getcallerpc();
	runtime.save(gs, 0x02, fp + 0x04);
	Eq_4 eax_146 = *((word32) eax_8 + 24);
	--*((word32) eax_146 + 0x0078);
}

// 08073020: void runtime.entersyscallblock_handoff(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void runtime.entersyscallblock_handoff(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (g_b814F4C8 != 0x00)
	{
		runtime.traceGoSysCall(gs);
		Eq_4 eax_37 = *((word32) *((word32) gs->ptr0000->tFFFFFFFC + 24) + 92);
		word32 ebp_92;
		word32 esi_93;
		runtime.traceGoSysBlock(gs, eax_37, out ebp_92, out esi_93);
		dwLoc04 = eax_37;
	}
	runtime.releasep(gs);
	runtime.handoffp(gs, dwLoc04, dwArg04);
}

// 08073080: Register Eq_4 runtime.exitsyscall(Register (ptr32 Eq_2) gs, Register out ptr32 esiOut)
// Called from:
//      runtime.cgocall
//      runtime.cgocallbackg
//      runtime.notetsleepg
//      syscall.Syscall
//      syscall.Syscall6
Eq_4 runtime.exitsyscall(struct Eq_2 * gs, ptr32 & esiOut)
{
	Eq_4 eax_8 = gs->ptr0000->tFFFFFFFC;
	Eq_4 ecx_10 = *((word32) eax_8 + 24);
	*((word32) ecx_10 + 0x0078) = (word32) *((word32) ecx_10 + 0x0078) + 1;
	Eq_4 dwLoc14_292 = dwLoc14;
	if (fp + 0x04 > *((word32) eax_8 + 56))
	{
		word32 ebp_297;
		word32 edi_298;
		runtime.systemstack(gs, 135166936, out ebp_297, out edi_298);
		dwLoc14_292.u0 = 135166936;
	}
	((word32) eax_8 + 88)->u0 = 0x00;
	((word32) eax_8 + 92)->u0 = 0x00;
	Eq_4 ecx_29 = *((word32) *((word32) eax_8 + 24) + 92);
	runtime.exitsyscallfast(gs);
	if ((byte) dwLoc14_292 != 0x00)
	{
		Eq_4 ecx_44 = *((word32) eax_8 + 24);
		if (*((word32) ecx_44 + 0x00B8) == 0x00)
			runtime.throw(gs);
		else
		{
			if (g_b814F4C8 != 0x00)
			{
				Eq_4 edx_61 = *((word32) ecx_44 + 92);
				ebx = ecx_29;
				if (ecx_29 != edx_61 || *((word32) ecx_44 + 484) != *((word32) edx_61 + 20))
				{
					word32 ebp_299;
					word32 edi_300;
					runtime.systemstack(gs, 0x080E7CF8, out ebp_299, out edi_300);
				}
			}
			Eq_4 edx_82 = *((word32) *((word32) eax_8 + 24) + 92);
			*((word32) edx_82 + 20) = (word32) *((word32) edx_82 + 20) + 1;
			runtime.casgstatus(eax_8, 0x03, 0x02);
			((word32) eax_8 + 56)->u0 = 0x00;
			Eq_4 ecx_101 = *((word32) eax_8 + 24);
			--*((word32) ecx_101 + 0x0078);
			if (*((word32) eax_8 + 0x006C) != 0x00)
				((word32) eax_8 + 8)->u0 = ~0x0521;
			else
				*((word32) eax_8 + 8) = (word32) *eax_8 + 880;
			*((word32) eax_8 + 113) = 0x00;
			esiOut = esi;
			return ebx;
		}
	}
	else
	{
		((word32) eax_8 + 116)->u0 = 0x00;
		((word32) eax_8 + 0x0078)->u0 = 0x00;
		if (g_b814F4C8 != 0x00)
		{
			while (ecx_29 != 0x00 && *((word32) ecx_29 + 20) == *((word32) (*((word32) eax_8 + 24)) + 484))
				runtime.osyield();
			runtime.cputicks();
			*((word32) eax_8 + 116) = dwLoc14_292;
			*((word32) eax_8 + 0x0078) = dwLoc10;
		}
		Eq_4 eax_158 = *((word32) eax_8 + 24);
		--*((word32) eax_158 + 0x0078);
		ptr32 esi_173;
		Eq_4 ebx_170 = runtime.mcall(gs, dwLoc18, &g_dw80E7BDC, out esi_173);
		if (*((word32) *((word32) eax_8 + 24) + 0x00B8) == 0x00)
			runtime.throw(gs);
		else
		{
			((word32) eax_8 + 56)->u0 = 0x00;
			Eq_4 edx_197 = *((word32) *((word32) eax_8 + 24) + 92);
			*((word32) edx_197 + 20) = (word32) *((word32) edx_197 + 20) + 1;
			*((word32) eax_8 + 113) = 0x00;
			esiOut = esi_173;
			return ebx_170;
		}
	}
}

// 08073280: void runtime.exitsyscallfast(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.exitsyscall
void runtime.exitsyscallfast(struct Eq_2 * gs)
{
	Eq_4 eax_8 = gs->ptr0000->tFFFFFFFC;
	if (g_t8145458 == 0x7FFFFFFF)
	{
		((word32) *((word32) eax_8 + 24) + 0x00B8)->u0 = 0x00;
		((word32) *((word32) eax_8 + 24) + 92)->u0 = 0x00;
	}
	else
	{
		Eq_4 ecx_20 = *((word32) *((word32) eax_8 + 24) + 92);
		if (ecx_20 != 0x00 && *((word32) ecx_20 + 8) == 0x02)
		{
			runtime/internal/atomic.Cas((word32) ecx_20 + 8, 0x02, 0x01);
			if (bLoc1C != 0x00)
			{
				runtime.exitsyscallfast_reacquired(gs);
				return;
			}
		}
		((word32) *((word32) eax_8 + 24) + 0x00B8)->u0 = 0x00;
		((word32) *((word32) eax_8 + 24) + 92)->u0 = 0x00;
		if (g_t814540C != 0x00)
		{
			word32 ebp_138;
			word32 edi_139;
			runtime.systemstack(gs, fp - 0x10, out ebp_138, out edi_139);
		}
	}
}

// 08073380: void runtime.exitsyscallfast_reacquired(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.exitsyscallfast
void runtime.exitsyscallfast_reacquired(struct Eq_2 * gs)
{
	Eq_4 eax_8 = gs->ptr0000->tFFFFFFFC;
	Eq_4 ecx_9 = *((word32) eax_8 + 24);
	*((word32) ecx_9 + 0x00B8) = *((word32) *((word32) ecx_9 + 92) + 52);
	Eq_4 ecx_13 = *((word32) eax_8 + 24);
	*((word32) *((word32) ecx_13 + 92) + 48) = ecx_13;
	Eq_4 ecx_21 = *((word32) eax_8 + 24);
	if (*((word32) ecx_21 + 484) != *((word32) (*((word32) ecx_21 + 92)) + 20))
	{
		if (g_b814F4C8 != 0x00)
		{
			word32 ebp_74;
			word32 edi_75;
			runtime.systemstack(gs, fp - 0x08, out ebp_74, out edi_75);
		}
		Eq_4 ecx_46 = *((word32) *((word32) eax_8 + 24) + 92);
		*((word32) ecx_46 + 20) = (word32) *((word32) ecx_46 + 20) + 1;
	}
}

// 08073410: Register word32 runtime.exitsyscallfast_pidle(Register Eq_4 esi, Register (ptr32 Eq_2) gs, Register out ptr32 ebpOut)
// Called from:
//      runtime.exitsyscallfast.func1
word32 runtime.exitsyscallfast_pidle(Eq_4 esi, struct Eq_2 * gs, ptr32 & ebpOut)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	word32 edi_139;
	word32 esi_138;
	runtime.lock(esi, gs, 135549936, out esi_138, out edi_139);
	runtime.pidleget(gs);
	runtime/internal/atomic.Load();
	runtime/internal/atomic.Store(0x08145460, 0x00);
	runtime.notewakeup(gs, 135550052);
}

// 080734D0: void runtime.exitsyscall0(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void runtime.exitsyscall0(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 esi_31 = runtime.casgstatus(dwArg04, 0x03, 0x01);
	Eq_4 eax_38 = gs->ptr0000->tFFFFFFFC;
	((word32) *((word32) *((word32) eax_38 + 24) + 84) + 24)->u0 = 0x00;
	((word32) *((word32) eax_38 + 24) + 84)->u0 = 0x00;
	word32 edi_262;
	word32 esi_261;
	runtime.lock(esi_31, gs, 135549936, out esi_261, out edi_262);
	runtime.pidleget(gs);
	runtime/internal/atomic.Load();
	runtime/internal/atomic.Store(0x08145460, 0x00);
	runtime.notewakeup(gs, 135550052);
}

// 08073670: void runtime.malg(Register (ptr32 Eq_2) gs, Stack int32 dwArg04)
// Called from:
//      runtime.mpreinit
//      runtime.allocm
//      runtime.oneNewExtraM
//      runtime.newproc1
void runtime.malg(struct Eq_2 * gs, int32 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.newobject(gs, 0x080DD7C0);
	if (dwArg04 >= 0x00)
	{
		runtime.round2(gs, dwArg04);
		word32 ebp_74;
		word32 edi_75;
		runtime.systemstack(gs, fp - 0x0C, out ebp_74, out edi_75);
		dwLoc14->dw0008 = dwLoc14->dw0000 + 880;
		dwLoc14->dw000C = ~0x00;
	}
}

// 08073700: Register Eq_4 runtime.newproc()
// Called from:
//      runtime.createfing
//      runtime.gcenable
//      runtime.gcBgMarkStartWorkers
//      runtime.init.3
//      main
Eq_4 runtime.newproc()
{
	runtime.getcallerpc();
	Eq_4 edi_23 = fn0808FD8B(0x00, fp - 0x14);
	word32 ebp_57;
	word32 edi_58;
	runtime.systemstack(gs, fp - 0x14, out ebp_57, out edi_58);
	return edi_23;
}

// 08073770: void runtime.newproc1(Register Eq_4 esi, Register (ptr32 Eq_2) gs, Stack word32 dwArg04, Stack word32 dwArg0C, Stack word32 dwArg10)
// Called from:
//      runtime.newproc.func1
void runtime.newproc1(Eq_4 esi, struct Eq_2 * gs, word32 dwArg04, word32 dwArg0C, word32 dwArg10)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 eax_18 = gs->ptr0000->tFFFFFFFC;
	if (dwArg04 == 0x00)
	{
		((word32) *((word32) eax_18 + 24) + 0x006C)->u0 = ~0x00;
		runtime.throw(gs);
	}
	else
	{
		Eq_4 edx_34 = *((word32) eax_18 + 24);
		*((word32) edx_34 + 0x0078) = (word32) *((word32) edx_34 + 0x0078) + 1;
		if ((dwArg10 + 0x07 + dwArg0C & ~0x07) >= 2028)
			runtime.throw(gs);
		else
		{
			runtime.gfget(esi, gs, *((word32) *((word32) eax_18 + 24) + 92));
			if (dwLoc34 == 0x00)
			{
				runtime.malg(gs, 0x0800);
				runtime.allgadd(runtime.casgstatus(dwLoc34, 0x00, 0x06), gs, dwLoc34);
			}
			if (*((word32) dwLoc34 + 4) == 0x00)
				runtime.throw(gs);
			else
			{
				runtime.readgstatus(dwLoc34);
				Eq_4 esp_143 = <invalid>;
				if (*((word32) esp_143 + 4) != 0x06)
				{
					esp_143->u0 = 0x080E48CC;
					((word32) esp_143 + 4)->u0 = 0x1C;
					runtime.throw(gs);
				}
				else
				{
					Eq_4 ecx_162 = *((word32) esp_143 + 32);
					Eq_4 edx_164 = *((word32) ecx_162 + 4) - ((word32) (*((word32) esp_143 + 24)) + 16);
					*((word32) esp_143 + 20) = edx_164;
					Eq_4 eax_166 = *((word32) esp_143 + 0x0044);
					if (eax_166 > 0x00)
					{
						*esp_143 = edx_164;
						*((word32) esp_143 + 4) = *((word32) esp_143 + 64);
						*((word32) esp_143 + 8) = eax_166;
						word32 ebp_805;
						word32 esi_806;
						word32 edi_807;
						word128 xmm0_808;
						word128 xmm1_809;
						word128 xmm2_810;
						runtime.memmove(*esp_143, *((word32) esp_143 + 4), *((word32) esp_143 + 8), out ebp_805, out esi_806, out edi_807, out xmm0_808, out xmm1_809, out xmm2_810);
						if (g_b81576F4 != 0x00 && *((word32) (*((word32) (*((word32) (*((word32) esp_143 + 36)) + 24)) + 84)) + 111) == 0x00)
						{
							*esp_143 = **((word32) esp_143 + 60);
							runtime.findfunc(gs, *esp_143);
							Eq_4 ecx_222 = *((word32) esp_143 + 8);
							*esp_143 = *((word32) esp_143 + 4);
							*((word32) esp_143 + 4) = ecx_222;
							((word32) esp_143 + 8)->u0 = 0x00;
							runtime.funcdata(gs, *esp_143, *((word32) esp_143 + 8));
							*esp_143 = *((word32) esp_143 + 0x0C);
							((word32) esp_143 + 4)->u0 = 0x00;
							runtime.stackmapdata(gs, *esp_143, *((word32) esp_143 + 4));
							Eq_4 eax_245 = *((word32) esp_143 + 0x0C);
							Eq_4 ecx_246 = *((word32) esp_143 + 20);
							*esp_143 = ecx_246;
							*((word32) esp_143 + 4) = ecx_246;
							*((word32) esp_143 + 8) = *((word32) esp_143 + 0x0044);
							((word32) esp_143 + 0x0C)->u0 = 0x00;
							*((word32) esp_143 + 16) = eax_245;
							runtime.bulkBarrierBitmap(*((word32) esp_143 + 4), *((word32) esp_143 + 8), *((word32) esp_143 + 0x0C), *((word32) esp_143 + 16));
						}
						ecx_162 = *((word32) esp_143 + 32);
					}
					Eq_4 eax_269 = (word32) ecx_162 + 28;
					*((word32) esp_143 + 40) = eax_269;
					*esp_143 = eax_269;
					((word32) esp_143 + 4)->u0 = 0x1C;
					runtime.memclrNoHeapPointers(*esp_143, *((word32) esp_143 + 4));
					Eq_4 eax_281 = *((word32) esp_143 + 20);
					Eq_4 ecx_282 = *((word32) esp_143 + 32);
					*((word32) ecx_282 + 28) = eax_281;
					*((word32) ecx_282 + 64) = eax_281;
					((word32) esp_143 + 48)->u0 = 0x080CAAC0;
					((word32) esp_143 + 52)->u0 = 135166996;
					*((word32) ecx_282 + 32) = (word32) **((word32) esp_143 + 52) + 1;
					*((word32) ecx_282 + 36) = ecx_282;
					Eq_4 ebx_305 = *((word32) esp_143 + 60);
					Eq_4 eax_302 = *((word32) ecx_282 + 28);
					Eq_4 ebp_306 = *ebx_305;
					*((word32) eax_302 - 4) = *((word32) ecx_282 + 32);
					*((word32) ecx_282 + 28) = (word32) eax_302 - 4;
					*((word32) ecx_282 + 32) = ebp_306;
					if (g_t81576F0 == 0x00)
						*((word32) ecx_282 + 40) = ebx_305;
					else
					{
						*esp_143 = (word32) ecx_282 + 40;
						*((word32) esp_143 + 4) = ebx_305;
						runtime.writebarrierptr(*esp_143, *((word32) esp_143 + 4));
						ecx_282 = *((word32) esp_143 + 32);
						ebx_305 = *((word32) esp_143 + 60);
					}
					*((word32) ecx_282 + 0x00A8) = *((word32) esp_143 + 76);
					*((word32) ecx_282 + 0x00AC) = *ebx_305;
					Eq_4 edx_340 = *((word32) *((word32) *((word32) esp_143 + 36) + 24) + 84);
					if (edx_340 != 0x00)
					{
						Eq_4 ebp_345 = (word32) ecx_282 + 0x00C4;
						Eq_4 edx_346 = *((word32) edx_340 + 0x00C4);
						if (g_t81576F0 == 0x00)
							*((word32) ecx_282 + 0x00C4) = edx_346;
						else
						{
							*esp_143 = ebp_345;
							*((word32) esp_143 + 4) = edx_346;
							runtime.writebarrierptr(*esp_143, *((word32) esp_143 + 4));
							ecx_282 = *((word32) esp_143 + 32);
						}
					}
					int8 dl_389;
					Eq_4 edx_365 = *((word32) ecx_282 + 0x00AC);
					if (runtime.runfinqPC == edx_365 && g_b8157569 == 0x00)
						dl_389 = 0x01;
					else if (runtime.bgsweepPC == edx_365)
						dl_389 = 0x01;
					else if (runtime.forcegchelperPC == edx_365)
						dl_389 = 0x01;
					else if (runtime.timerprocPC == edx_365)
						dl_389 = 0x01;
					else
						dl_389 = (int8) (runtime.gcBgMarkWorkerPC == edx_365);
					if (dl_389 != 0x00)
					{
						esp_143->u0 = 0x08145408;
						((word32) esp_143 + 4)->u0 = 0x01;
						runtime/internal/atomic.Xadd(*esp_143, *((word32) esp_143 + 4));
						ecx_282 = *((word32) esp_143 + 32);
					}
					((word32) ecx_282 + 112)->u0 = 0x00;
					*esp_143 = ecx_282;
					((word32) esp_143 + 4)->u0 = 0x06;
					((word32) esp_143 + 8)->u0 = 0x01;
					runtime.casgstatus(*esp_143, *((word32) esp_143 + 4), *((word32) esp_143 + 8));
					Eq_4 eax_435 = *((word32) esp_143 + 44);
					Eq_4 ecx_436 = *((word32) eax_435 + 764);
					Eq_4 edx_437 = *((word32) eax_435 + 760);
					if (((int8) (ecx_436 == *((word32) eax_435 + 772)) & (int8) (edx_437 == *((word32) eax_435 + 0x0300))) != 0x00)
					{
						esp_143->u0 = 0x081453E0;
						((word32) esp_143 + 4)->u0 = 0x10;
						((word32) esp_143 + 8)->u0 = 0x00;
						word32 ebx_811;
						word32 ebp_812;
						runtime/internal/atomic.Xadd64(*esp_143, *((word32) esp_143 + 4), *((word32) esp_143 + 8), out ebx_811, out ebp_812);
						Eq_4 eax_468 = *((word32) esp_143 + 0x0C);
						Eq_4 ebx_473 = *((word32) esp_143 + 16);
						Eq_4 ebp_474 = *((word32) esp_143 + 44);
						*((word32) ebp_474 + 764) = ebx_473;
						*((word32) ebp_474 + 760) = (word32) eax_468 - 0x0F;
						*((word32) ebp_474 + 764) = (bool) (eax_468 < ~0x0E) + ((word32) ebx_473 - 1);
						*((word32) ebp_474 + 0x0300) = (word32) eax_468 + 1;
						Mem490[ebp_474 + 772:word32] = ebx_473 + (eax_468 <u 0x01);
						eax_435 = ebp_474;
					}
					Eq_4 edx_495 = *((word32) eax_435 + 764);
					Eq_4 ebx_497 = *((word32) esp_143 + 32);
					*((word32) ebx_497 + 80) = *((word32) eax_435 + 760);
					*((word32) ebx_497 + 84) = edx_495;
					Eq_4 ecx_500 = *((word32) eax_435 + 760);
					Eq_4 edx_503 = *((word32) eax_435 + 764);
					*((word32) eax_435 + 760) = (word32) ecx_500 + 1;
					Mem507[eax_435 + 0x02FC:word32] = edx_503 + (ecx_500 <u 0x01);
					if (g_b814F4C8 != 0x00)
					{
						*((word32) esp_143 + 4) = *((word32) ebx_497 + 0x00AC);
						*esp_143 = ebx_497;
						runtime.traceGoCreate(gs, *esp_143, *((word32) esp_143 + 4));
						eax_435 = *((word32) esp_143 + 44);
						ebx_497 = *((word32) esp_143 + 32);
					}
					*esp_143 = eax_435;
					*((word32) esp_143 + 4) = ebx_497;
					((word32) esp_143 + 8)->u0 = 0x01;
					runtime.runqput(gs, *((word32) esp_143 - 4), *esp_143, *((word32) esp_143 + 4), *((word32) esp_143 + 8));
					esp_143->u0 = 0x08145410;
					runtime/internal/atomic.Load();
					if (*((word32) esp_143 + 8) != 0x00)
					{
						((word32) esp_143 + 4)->u0 = 0x08145414;
						runtime/internal/atomic.Load();
						if (*((word32) esp_143 + 0x0C) == 0x00 && g_b8157574 != 0x00)
							runtime.wakep(gs);
					}
					Eq_4 ecx_585 = *((word32) eax_18 + 24);
					--*((word32) ecx_585 + 0x0078);
					if (*((word32) *((word32) eax_18 + 24) + 0x0078) == 0x00 && *((word32) eax_18 + 0x006C) != 0x00)
						((word32) eax_18 + 8)->u0 = ~0x0521;
				}
			}
		}
	}
}

// 08073CD0: void runtime.gfput(Register Eq_4 esi, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
// Called from:
//      runtime.goexit0
void runtime.gfput(Eq_4 esi, struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.readgstatus(dwArg08);
	if (dwLoc0C != 0x06)
		runtime.throw(gs);
	else
	{
		Eq_4 ecx_39 = *((word32) dwArg08 + 4);
		Eq_4 edx_40 = *dwArg08;
		if (ecx_39 - edx_40 != 0x0800)
		{
			esi = runtime.stackfree(gs, edx_40, ecx_39);
			dwArg08->u0 = 0x00;
			((word32) dwArg08 + 4)->u0 = 0x00;
			((word32) dwArg08 + 8)->u0 = 0x00;
		}
		*((word32) dwArg08 + 0x0068) = *((word32) dwArg04 + 1812);
		if (g_t81576F0 == 0x00)
			*((word32) dwArg04 + 1812) = dwArg08;
		else
			runtime.writebarrierptr((word32) dwArg04 + 1812, dwArg08);
		int32 eax_92 = *((word32) dwArg04 + 1816);
		*((word32) dwArg04 + 1816) = eax_92 + 0x01;
		if (eax_92 >= 0x3F)
		{
			word32 esi_291;
			word32 edi_292;
			runtime.lock(esi, gs, 0x08145424, out esi_291, out edi_292);
			while (true)
			{
				int32 ecx_120 = *((word32) dwArg04 + 1816);
				if (ecx_120 < 0x20)
					break;
				*((word32) dwArg04 + 1816) = ecx_120 - 0x01;
				Eq_4 ecx_140 = *((word32) dwArg04 + 1812);
				Eq_4 ebx_142 = *((word32) ecx_140 + 0x0068);
				if (g_t81576F0 == 0x00)
					*((word32) dwArg04 + 1812) = ebx_142;
				else
					runtime.writebarrierptr((word32) dwArg04 + 1812, ebx_142);
				if (*ecx_140 == 0x00)
				{
					*((word32) ecx_140 + 0x0068) = g_t814542C;
					if (g_t81576F0 == 0x00)
						g_t814542C = ecx_140;
					else
						runtime.writebarrierptr(135549996, ecx_140);
				}
				else
				{
					*((word32) ecx_140 + 0x0068) = g_t8145428;
					if (g_t81576F0 == 0x00)
						g_t8145428 = ecx_140;
					else
						runtime.writebarrierptr(135549992, ecx_140);
				}
				++g_dw8145430;
			}
			word32 ebx_294;
			word32 edx_293;
			runtime.unlock(gs, 0x08145424, out edx_293, out ebx_294);
		}
	}
}

// 08073ED0: void runtime.gfget(Register Eq_4 esi, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      runtime.newproc1
void runtime.gfget(Eq_4 esi, struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	while (true)
	{
		Eq_4 ecx_21 = *((word32) dwArg04 + 1812);
		if (ecx_21 != 0x00 || g_t8145428 == 0x00 && g_t814542C == 0x00)
			break;
		word32 edi_297;
		runtime.lock(esi, gs, 0x08145424, out esi, out edi_297);
		while (*((word32) dwArg04 + 1816) < 0x20)
		{
			Eq_4 ecx_125 = g_t8145428;
			if (ecx_125 != 0x00)
			{
				Eq_4 ebx_168 = *((word32) ecx_125 + 0x0068);
				if (g_t81576F0 == 0x00)
					g_t8145428 = ebx_168;
				else
					runtime.writebarrierptr(135549992, ebx_168);
			}
			else
			{
				ecx_125 = g_t814542C;
				if (ecx_125 == 0x00)
					break;
				Eq_4 ebx_148 = *((word32) ecx_125 + 0x0068);
				if (g_t81576F0 == 0x00)
					g_t814542C = ebx_148;
				else
					runtime.writebarrierptr(135549996, ebx_148);
			}
			*((word32) dwArg04 + 1816) = (word32) *((word32) dwArg04 + 1816) + 1;
			--g_dw8145430;
			*((word32) ecx_125 + 0x0068) = *((word32) dwArg04 + 1812);
			if (g_t81576F0 == 0x00)
				*((word32) dwArg04 + 1812) = ecx_125;
			else
				runtime.writebarrierptr((word32) dwArg04 + 1812, ecx_125);
		}
		word32 ebx_301;
		word32 edx_300;
		runtime.unlock(gs, 0x08145424, out edx_300, out ebx_301);
	}
	if (ecx_21 != 0x00)
	{
		Eq_4 ebp_43 = *((word32) ecx_21 + 0x0068);
		if (g_t81576F0 == 0x00)
			*((word32) dwArg04 + 1812) = ebp_43;
		else
			runtime.writebarrierptr((word32) dwArg04 + 1812, ebp_43);
		--*((word32) dwArg04 + 1816);
		if (*ecx_21 == 0x00)
		{
			word32 ebp_298;
			word32 edi_299;
			runtime.systemstack(gs, fp - 0x08, out ebp_298, out edi_299);
			Eq_4 esp_87 = <invalid>;
			Eq_4 ecx_92 = *((word32) esp_87 + 8);
			*((word32) ecx_92 + 8) = (word32) *ecx_92 + 880;
		}
	}
}

// 080740B0: Register Eq_4 runtime.gfpurge(Register Eq_4 esi, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      runtime.procresize
Eq_4 runtime.gfpurge(Eq_4 esi, struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	word32 edi_168;
	Eq_4 esi_163;
	runtime.lock(esi, gs, 0x08145424, out esi_163, out edi_168);
	while (true)
	{
		int32 ecx_36 = *((word32) dwArg04 + 1816);
		if (ecx_36 == 0x00)
			break;
		*((word32) dwArg04 + 1816) = ecx_36 - 0x01;
		Eq_4 ecx_56 = *((word32) dwArg04 + 1812);
		Eq_4 ebp_59 = *((word32) ecx_56 + 0x0068);
		if (g_t81576F0 == 0x00)
			*((word32) dwArg04 + 1812) = ebp_59;
		else
			runtime.writebarrierptr((word32) dwArg04 + 1812, ebp_59);
		esi_163 = (word32) ecx_56 + 0x0068;
		if (*ecx_56 == 0x00)
		{
			*((word32) ecx_56 + 0x0068) = g_t814542C;
			if (g_t81576F0 == 0x00)
				g_t814542C = ecx_56;
			else
				runtime.writebarrierptr(135549996, ecx_56);
		}
		else
		{
			*((word32) ecx_56 + 0x0068) = g_t8145428;
			if (g_t81576F0 == 0x00)
				g_t8145428 = ecx_56;
			else
				runtime.writebarrierptr(135549992, ecx_56);
		}
		++g_dw8145430;
	}
	word32 edx_169;
	word32 ebx_170;
	runtime.unlock(gs, 0x08145424, out edx_169, out ebx_170);
	return esi_163;
}

// 080741E0: void runtime.unlockOSThread(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.endcgo
//      runtime.main
//      runtime.main.func2
void runtime.unlockOSThread(struct Eq_2 * gs)
{
	Eq_4 eax_27 = gs->ptr0000->tFFFFFFFC;
	if (*((word32) *((word32) eax_27 + 24) + 452) < 0x02)
	{
		word32 ebp_114;
		word32 edi_115;
		runtime.systemstack(gs, 0x080E7B90, out ebp_114, out edi_115);
		Eq_4 esp_22 = <invalid>;
		eax_27 = *((word32) esp_22 + 0x0C);
	}
	Eq_4 eax_30 = *((word32) eax_27 + 24);
	*((word32) eax_30 + 452) = (word32) *((word32) eax_30 + 452) - 2;
	Eq_4 eax_36 = gs->ptr0000->tFFFFFFFC;
	Eq_4 ecx_37 = *((word32) eax_36 + 24);
	if (*((word32) ecx_37 + 452) == 0x00)
	{
		if (g_t81576F0 == 0x00)
			((word32) ecx_37 + 188)->u0 = 0x00;
		else
			runtime.writebarrierptr((word32) ecx_37 + 188, 0x00);
		if (g_t81576F0 == 0x00)
			((word32) eax_36 + 0x0088)->u0 = 0x00;
		else
			runtime.writebarrierptr((word32) eax_36 + 0x0088, 0x00);
	}
}

// 080742C0: void runtime.badunlockosthread(Register (ptr32 Eq_2) gs)
void runtime.badunlockosthread(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.throw(gs);
}

// 08074300: void runtime._System(Register (ptr32 Eq_54195) gs)
// Called from:
//      runtime._System
void runtime._System(struct Eq_54195 * gs)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	runtime._System(gs);
}

// 08074320: void runtime._ExternalCode(Register (ptr32 Eq_54211) gs)
// Called from:
//      runtime._ExternalCode
void runtime._ExternalCode(struct Eq_54211 * gs)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	runtime._ExternalCode(gs);
}

// 08074340: void runtime._LostExternalCode(Register (ptr32 Eq_54227) gs)
// Called from:
//      runtime._LostExternalCode
void runtime._LostExternalCode(struct Eq_54227 * gs)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	runtime._LostExternalCode(gs);
}

// 08074360: void runtime._GC(Register (ptr32 Eq_54243) gs)
// Called from:
//      runtime._GC
void runtime._GC(struct Eq_54243 * gs)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	runtime._GC(gs);
}

// 08074380: void runtime.sigprof(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg00, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack (ptr32 Eq_54263) dwArg0C, Stack Eq_4 dwArg10, Stack Eq_4 dwArg14)
// Called from:
//      runtime.sighandler
void runtime.sigprof(struct Eq_2 * gs, Eq_4 dwArg00, Eq_4 dwArg04, Eq_4 dwArg08, struct Eq_54263 * dwArg0C, Eq_4 dwArg10, Eq_4 dwArg14)
{
	byte bLoc0148 = (byte) dwLoc0148;
	while (fp - 200 <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	fn0808FD8A(0x00, fp - 0x18);
	if (g_dw815769C == 0x00)
		return;
	word32 eax_67;
	Eq_4 ecx_32 = *((word32) gs->ptr0000->tFFFFFFFC + 24);
	*((word32) ecx_32 + 0x0068) = (word32) *((word32) ecx_32 + 0x0068) + 1;
	if (dwArg0C != null && (dwArg04 >= dwArg0C->t0000 && dwArg0C->t0004 >= dwArg04))
	{
		runtime.setsSP(gs, dwArg00);
		if (bLoc0148 == 0x00)
		{
			eax_67 = 0x01;
l080743F8:
			Eq_4 eax_138;
			fn0808FD50(0x00, fp - 0x011C);
			byte dl_102 = (byte) eax_67;
			if (dwArg0C->dw00A0 > 0x00)
			{
				struct Eq_54324 * eax_89 = dwArg0C->ptr0054;
				if (eax_89 != null && (eax_89->dw003C != 0x00 && eax_89->dw0038 != 0x00))
				{
					Eq_54340 ecx_161;
					runtime/internal/atomic.Load();
					if (dwLoc0148 == 0x00)
					{
						Eq_4 ecx_153 = *((word32) dwArg10 + 0x00A8);
						if (ecx_153 != 0x00 && *ecx_153 != 0x00)
						{
							Eq_54340 edx_164 = 0x00;
							while (true)
							{
								bool v32_392 = edx_164 > 0x20;
								if (edx_164 >= 0x20)
									break;
								if (edx_164 >= 0x20)
									runtime.panicindex(gs);
								if (*((word32) ecx_153 + edx_164 * 0x04) == 0x00)
								{
									v32_392 = edx_164 > 0x20;
									break;
								}
								edx_164 = (word32) edx_164 + 1;
							}
							if (v32_392)
								runtime.panicslice(gs);
							Eq_54340 edx_191;
							edx_191 = edx_164;
							if (edx_164 >= 0x40)
								edx_191.u0 = 0x40;
							word128 xmm2_745;
							word128 xmm1_744;
							word32 ebp_740;
							word32 esi_741;
							word32 edi_742;
							word128 xmm0_743;
							runtime.memmove(fp - 0x011C, ecx_153, edx_191 << 0x02, out ebp_740, out esi_741, out edi_742, out xmm0_743, out xmm1_744, out xmm2_745);
							**((word32) dwArg10 + 0x00A8) = 0x00;
							ecx_161 = edx_164;
l080744CF:
							Eq_4 edx_230 = *((word32) dwArg10 + 84);
							Eq_4 ebp_232 = *((word32) edx_230 + 56);
							if (ecx_161 >= 0x40)
								runtime.panicindex(gs);
							runtime.gentraceback(gs, ebp_232, 0x00, edx_230, 0x00, fp - 0x011C + ecx_161 * 0x04, 0x40 - ecx_161, 0x00, 0x00);
							eax_138 = dwLoc0124;
l0807452E:
							if (eax_138 <= 0x00)
							{
								if (*((word32) dwArg14 + 116) != 0x00 || *((word32) dwArg14 + 0x0088) != 0x00)
									;
								eax_138.u0 = 0x02;
							}
							if (g_dw815769C != 0x00)
							{
								if (eax_138 > 0x40)
									runtime.panicslice(gs);
								runtime.(*cpuProfile).add(gs, &g_t8145920, dwArg10, fp - 0x0118, eax_138);
							}
							Eq_4 eax_383 = *((word32) gs->ptr0000->tFFFFFFFC + 24);
							--*((word32) eax_383 + 0x0068);
							return;
						}
					}
					ecx_161.u0 = 0x00;
					goto l080744CF;
				}
			}
			if (dl_102 == 0x00)
				eax_138.u0 = 0x00;
			else
			{
				runtime.gentraceback(gs, dwArg04, dwArg04, dwArg08, 0x00, fp - 288, 0x40, 0x00, 0x00);
				eax_138 = dwLoc0128;
			}
			goto l0807452E;
		}
	}
	eax_67 = 0x00;
	goto l080743F8;
}

// 08074780: void runtime.sigprofNonGoPC(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.sigtrampgo
void runtime.sigprofNonGoPC(struct Eq_2 * gs)
{
	if (g_dw815769C != 0x00)
		runtime.(*cpuProfile).addNonGo(gs, fp - 0x10, 0x02);
}

// 08074800: void runtime.setsSP(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      runtime.sigprof
void runtime.setsSP(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.findfunc(gs, dwArg04);
	if (dwLoc08 == null)
		return;
	Eq_4 eax_37 = *dwLoc08;
	if (runtime.gogoPC != eax_37 && (runtime.systemstackPC != eax_37 && (runtime.mcallPC != eax_37 && runtime.morestackPC != eax_37)))
		;
}

// 08074880: void runtime.procresize(Register Eq_4 ebp, Register word32 esi, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      runtime.schedinit
//      runtime.startTheWorldWithSema
void runtime.procresize(Eq_4 ebp, word32 esi, struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 eax_17 = runtime.gomaxprocs;
	if (eax_17 > 0x0400 || (dwArg04 <= 0x00 || dwArg04 > 0x0400))
		runtime.throw(gs);
	else
	{
		if (g_b814F4C8 != 0x00)
		{
			dwLoc58 = dwArg04;
			word32 esi_49;
			runtime.traceGomaxprocs(gs, out esi_49);
		}
		runtime.nanotime();
		Eq_4 ebx_69 = g_t814547C;
		Eq_4 edx_68 = g_t8145478;
		if (((int8) (ebx_69 != 0x00) | (int8) (edx_68 != 0x00)) != 0x00)
		{
			Eq_54609 ecx_114 = dwLoc58 - edx_68;
			uint64 edx_eax_118 = eax_17 *64 ecx_114;
			uint32 eax_123 = (word32) edx_eax_118;
			uint32 edx_121 = g_dw8145480;
			ui32 ebx_125 = g_dw8145484;
			g_dw8145480 = edx_121 + eax_123;
			g_dw8145484 = SLICE(SEQ(ebx_125, edx_121) + SEQ((ecx_114 *s (eax_17 >> 0x1F) + SLICE(edx_eax_118, word32, 32)) + SLICE(SEQ(dwLoc54, dwLoc58) - SEQ(ebx_69, edx_68), word32, 32) *s eax_17, eax_123), word32, 32);
		}
		g_t8145478 = dwLoc58;
		g_t814547C = dwLoc54;
		Eq_4 edx_165 = eax_17;
		Eq_4 eax_154 = 0x00;
		while (true)
		{
			byte bLoc54_1056 = (byte) dwLoc54;
			Eq_4 ecx_159 = dwArg04;
			if (eax_154 >= dwArg04)
				break;
			if (eax_154 >= 0x0401)
				runtime.panicindex(gs);
			Eq_4 ebp_686 = *((char *) g_a81478C0 + eax_154 * 0x04);
			Eq_4 esi_687 = eax_154 * 0x04 + 0x081478C0;
			if (ebp_686 == 0x00)
			{
				runtime.newobject(gs, 0x080DC7A0);
				*((word32) dwLoc54 + 4) = eax_154;
				((word32) dwLoc54 + 8)->u0 = 0x03;
				*((word32) dwLoc54 + 0x0720) = 0x00;
				*((word32) dwLoc54 + 1828) = 0x80;
				if (g_t81576F0 == 0x00)
					*((word32) dwLoc54 + 0x071C) = (word32) dwLoc54 + 0x0728;
				else
					runtime.writebarrierptr((word32) dwLoc54 + 0x071C, (word32) dwLoc54 + 0x0728);
				Eq_4 eax_739 = dwLoc54;
				Eq_54737 edx_729 = 0x00;
				while (edx_729 < 0x05)
				{
					if (edx_729 >= 0x05)
						runtime.panicindex(gs);
					ui32 ebx_757 = edx_729 * 0x03;
					((word32) eax_739 + (ebx_757 * 0x04 + 64))->u0 = 0x00;
					((word32) eax_739 + (ebx_757 * 0x04 + 0x0044))->u0 = 0x20;
					Eq_4 ebp_760 = (word32) eax_739 + 60 + ebx_757 * 0x04;
					Eq_4 edx_764 = (word32) eax_739 + 0x0078 + (edx_729 << 0x07);
					if (g_t81576F0 == 0x00)
						*((word32) eax_739 + (ebx_757 * 0x04 + 60)) = edx_764;
					else
					{
						runtime.writebarrierptr(ebp_760, edx_764);
						eax_739 = dwLoc54;
					}
					edx_729 = (word32) edx_729 + 1;
				}
				runtime.atomicstorep(esi_687, eax_739);
				dwLoc58 = esi_687;
				dwLoc54 = eax_739;
				edx_165 = eax_17;
				ebp_686 = dwLoc54;
			}
			Eq_4 esi_787 = *((word32) ebp_686 + 52);
			if (esi_787 == 0x00)
			{
				if (edx_165 == 0x00 && eax_154 == 0x00)
				{
					Eq_4 esi_830 = *((word32) *((word32) gs->ptr0000->tFFFFFFFC + 24) + 0x00B8);
					if (esi_830 == 0x00)
						runtime.throw(gs);
					*((word32) ebp_686 + 52) = esi_830;
				}
				else
				{
					runtime.allocmcache(esi_787, gs);
					*((word32) ebp_686 + 52) = dwLoc58;
					edx_165 = eax_17;
				}
			}
			eax_154 = (word32) eax_154 + 1;
		}
		while (ecx_159 < edx_165)
		{
			if (ecx_159 >= 0x0401)
				runtime.panicindex(gs);
			Eq_4 ebp_344 = *((char *) g_a81478C0 + ecx_159 * 0x04);
			if (g_b814F4C8 != 0x00 && ebp_344 == *((word32) (*((word32) (gs->ptr0000)->tFFFFFFFC + 24)) + 92))
			{
				runtime.traceGoSched(gs);
				runtime.traceProcStop(gs, ebp_344);
			}
			while (true)
			{
				Eq_4 edi_394 = *((word32) ebp_344 + 780);
				if (*((word32) ebp_344 + 776) == edi_394)
					break;
				*((word32) ebp_344 + 780) = edi_394 - 0x01;
				Eq_4 esi_661 = *((word32) ebp_344 + ((edi_394 - 0x01 & 0xFF) * 0x04 + 784));
				*((word32) esi_661 + 0x0068) = g_t8145418;
				g_t8145418 = esi_661;
				if (g_t814541C == 0x00)
					g_t814541C = esi_661;
				g_t8145420 = (word32) g_t8145420 + 1;
			}
			Eq_4 esi_397 = *((word32) ebp_344 + 1808);
			if (esi_397 != 0x00)
			{
				*((word32) esi_397 + 0x0068) = g_t8145418;
				g_t8145418 = esi_397;
				if (g_t814541C == 0x00)
					g_t814541C = esi_397;
				g_t8145420 = (word32) g_t8145420 + 1;
				((word32) ebp_344 + 1808)->u0 = 0x00;
			}
			Eq_4 esi_425 = *((word32) ebp_344 + 0x0948);
			if (esi_425 != 0x00)
			{
				runtime.casgstatus(esi_425, 0x04, 0x01);
				if (g_b814F4C8 != 0x00)
					runtime.traceGoUnpark(gs, esi_425);
				((word32) esi_425 + 0x0068)->u0 = 0x00;
				Eq_4 ecx_474 = g_t814541C;
				if (ecx_474 != 0x00)
					*((word32) ecx_474 + 0x0068) = esi_425;
				else
					g_t8145418 = esi_425;
				g_t814541C = esi_425;
				g_t8145420 = (word32) g_t8145420 + 1;
				((word32) ebp_344 + 0x0948)->u0 = 0x00;
			}
			Eq_4 esi_524 = runtime.memclrHasPointers(gs, (word32) ebp_344 + 0x0728, 0x0200);
			*((word32) ebp_344 + 0x0720) = 0x00;
			*((word32) ebp_344 + 1828) = 0x80;
			bLoc54_1056 = 0x00;
			if (g_t81576F0 == 0x00)
				*((word32) ebp_344 + 0x071C) = (word32) ebp_344 + 0x0728;
			else
			{
				runtime.writebarrierptr((word32) ebp_344 + 0x071C, (word32) ebp_344 + 0x0728);
				bLoc54_1056 = (byte) ebp_344 + 0x28;
			}
			Eq_55066 ecx_552 = 0x00;
			while (ecx_552 < 0x05)
			{
				if (ecx_552 >= 0x05)
					runtime.panicindex(gs);
				int32 ecx_612 = ecx_552 << 0x07;
				runtime.memclrHasPointers(gs, (word32) ebp_344 + 0x0078 + ecx_612, 0x80);
				((word32) ebp_344 + (ecx_552 * 0x0C + 64))->u0 = 0x00;
				((word32) ebp_344 + (ecx_552 * 0x0C + 0x0044))->u0 = 0x20;
				bLoc54_1056 = 0x80;
				Eq_4 ebx_635 = (word32) ebp_344 + 0x0078 + ecx_612;
				esi_524 = (word32) ebp_344 + 60 + ecx_552 * 0x0C;
				if (g_t81576F0 == 0x00)
					*((word32) ebp_344 + (ecx_552 * 0x0C + 60)) = ebx_635;
				else
				{
					runtime.writebarrierptr(esi_524, ebx_635);
					bLoc54_1056 = (byte) ebx_635;
				}
				ecx_552 = (word32) ecx_552 + 1;
			}
			runtime.freemcache(gs);
			((word32) ebp_344 + 52)->u0 = 0x00;
			runtime.traceProcFree(runtime.gfpurge(esi_524, gs, ebp_344), gs, ebp_344);
			((word32) ebp_344 + 8)->u0 = 0x04;
			ecx_159 = (word32) ecx_159 + 1;
			edx_165 = eax_17;
		}
		Eq_4 ecx_171 = gs->ptr0000->tFFFFFFFC;
		Eq_4 edx_175 = *((word32) *((word32) ecx_171 + 24) + 92);
		if (edx_175 != 0x00 && *((word32) edx_175 + 4) < dwArg04)
			((word32) edx_175 + 8)->u0 = 0x01;
		else
		{
			if (edx_175 != 0x00)
				((word32) edx_175 + 48)->u0 = 0x00;
			((word32) *((word32) ecx_171 + 24) + 92)->u0 = 0x00;
			((word32) *((word32) ecx_171 + 24) + 0x00B8)->u0 = 0x00;
			Eq_4 eax_198 = g_a81478C0[0];
			((word32) eax_198 + 48)->u0 = 0x00;
			((word32) eax_198 + 8)->u0 = 0x00;
			runtime.acquirep(gs, eax_198);
			if (g_b814F4C8 != 0x00)
				runtime.traceGoStart(gs);
		}
		Eq_4 ecx_269 = ecx_171;
		Eq_4 eax_233 = dwArg04;
		Eq_54918 edx_234;
		Eq_4 ebx_235 = 0x00;
		for (edx_234 = dwArg04 - 0x01; edx_234 >= 0x00; --edx_234)
		{
			if (edx_234 >= 0x0401)
				runtime.panicindex(gs);
			Eq_4 edi_272 = *((char *) g_a81478C0 + edx_234 * 0x04);
			if (*((word32) *((word32) ecx_269 + 24) + 92) != edi_272)
			{
				Eq_4 ecx_301;
				((word32) edi_272 + 8)->u0 = 0x00;
				runtime.runqempty(gs, dwLoc5C);
				if (bLoc54_1056 == 0x00)
				{
					Eq_4 eax_302 = g_t81453F4;
					if (eax_302 != 0x00)
					{
						g_t81453F4 = *((word32) eax_302 + 0x00B4);
						--g_t81453F8;
					}
					*((word32) edi_272 + 48) = eax_302;
					*((word32) edi_272 + 0x0C) = ebx_235;
					ecx_301 = edi_272;
				}
				else
				{
					runtime.pidleput(gs, edi_272);
					ecx_301 = ebx_235;
				}
				eax_233 = dwArg04;
				ebx_235 = ecx_301;
				ecx_269 = ecx_171;
			}
		}
		runtime.(*randomOrder).reset(gs, &g_dw81451B0, eax_233);
		runtime/internal/atomic.Store(0x081575F0, dwArg04);
	}
}

// 08075030: void runtime.acquirep(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      runtime.mstart1
//      runtime.allocm
//      runtime.stopm
//      runtime.stoplockedm
//      runtime.findrunnable
//      runtime.exitsyscallfast_pidle
//      runtime.exitsyscall0
//      runtime.procresize
void runtime.acquirep(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.acquirep1(gs, dwArg04);
	*((word32) *((word32) gs->ptr0000->tFFFFFFFC + 24) + 0x00B8) = *((word32) dwArg04 + 52);
	if (g_b814F4C8 != 0x00)
		runtime.traceProcStart(gs);
}

// 08075090: void runtime.acquirep1(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      runtime.acquirep
void runtime.acquirep1(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 eax_18 = gs->ptr0000->tFFFFFFFC;
	Eq_4 ecx_19 = *((word32) eax_18 + 24);
	if (*((word32) ecx_19 + 92) != 0x00 || *((word32) ecx_19 + 0x00B8) != 0x00)
		runtime.throw(gs);
	else
	{
		Eq_4 ebp_39 = *((word32) dwArg04 + 48);
		if (ebp_39 != 0x00 || *((word32) dwArg04 + 8) != 0x00)
		{
			Eq_4 eax_55;
			if (ebp_39 != 0x00)
				eax_55 = *((word32) ebp_39 + 100);
			else
				eax_55.u0 = 0x00;
			Eq_4 ecx_65 = *((word32) dwArg04 + 8);
			runtime.printlock(gs);
			runtime.printstring(gs);
			runtime.printint(ebx_24_8, gs, ebp_39);
			runtime.printstring(gs);
			runtime.printint(ebx_24_8, gs, eax_55);
			runtime.printstring(gs);
			runtime.printint(ebx_24_8, gs, ecx_65);
			runtime.printstring(gs);
			runtime.printunlock(gs);
			runtime.throw(gs);
		}
		else
		{
			*((word32) ecx_19 + 92) = dwArg04;
			*((word32) dwArg04 + 48) = *((word32) eax_18 + 24);
			((word32) dwArg04 + 8)->u0 = 0x01;
		}
	}
}

// 08075200: void runtime.releasep(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.allocm
//      runtime.stoplockedm
//      runtime.startlockedm
//      runtime.gcstopm
//      runtime.findrunnable
//      runtime.entersyscallblock_handoff
void runtime.releasep(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 eax_18 = gs->ptr0000->tFFFFFFFC;
	Eq_4 ecx_19 = *((word32) eax_18 + 24);
	Eq_4 edx_20 = *((word32) ecx_19 + 92);
	if (edx_20 != 0x00)
	{
		Eq_4 ebx_24 = *((word32) ecx_19 + 0x00B8);
		if (ebx_24 != 0x00)
		{
			Eq_4 ebp_40 = *((word32) edx_20 + 48);
			if (ebp_40 != ecx_19 || (*((word32) edx_20 + 52) != ebx_24 || *((word32) edx_20 + 8) != 0x01))
			{
				Eq_4 ecx_56 = *((word32) edx_20 + 8);
				runtime.printlock(gs);
				runtime.printstring(gs);
				runtime.printpointer(gs);
				runtime.printstring(gs);
				runtime.printpointer(gs);
				runtime.printstring(gs);
				runtime.printint(ebx_24_8, gs, ebp_40);
				runtime.printstring(gs);
				runtime.printpointer(gs);
				runtime.printstring(gs);
				runtime.printpointer(gs);
				runtime.printstring(gs);
				runtime.printint(ebx_24_8, gs, ecx_56);
				runtime.printstring(gs);
				runtime.printunlock(gs);
				runtime.throw(gs);
			}
			else
			{
				if (g_b814F4C8 != 0x00)
					runtime.traceProcStop(gs, edx_20);
				((word32) *((word32) eax_18 + 24) + 92)->u0 = 0x00;
				((word32) *((word32) eax_18 + 24) + 0x00B8)->u0 = 0x00;
				((word32) edx_20 + 48)->u0 = 0x00;
				((word32) edx_20 + 8)->u0 = 0x00;
				return;
			}
		}
	}
	runtime.throw(gs);
}

// 08075400: void runtime.incidlelocked(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      runtime.stoplockedm
//      runtime.startlockedm
//      runtime.sysmon
//      runtime.retake
void runtime.incidlelocked(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	word32 esi_53;
	word32 edi_54;
	runtime.lock(esi, gs, 135549936, out esi_53, out edi_54);
	Mem25[0x081453FC<p32>:word32] = Mem18[0x081453FC<p32>:word32] + dwArg04;
	if (dwArg04 > 0x00)
		runtime.checkdead(gs);
	word32 edx_55;
	word32 ebx_56;
	runtime.unlock(gs, 135549936, out edx_55, out ebx_56);
}

// 08075460: void runtime.checkdead(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.incidlelocked
//      runtime.mput
void runtime.checkdead(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (g_b8157572 != 0x00 || g_b8157570 != 0x00)
		return;
	if (runtime.panicking > 0x00)
		return;
	Eq_4 eax_37 = g_t8145400;
	Eq_4 ecx_38 = g_t81453F8;
	Eq_4 ebx_41 = g_t81453FC;
	int32 eax_42 = eax_37 - ecx_38 - ebx_41;
	if (eax_42 > 0x01)
		return;
	if (eax_42 < 0x01)
	{
		runtime.printlock(gs);
		runtime.printstring(gs);
		runtime.printint(SLICE(ebx_41, word24, 8), gs, ecx_38);
		runtime.printstring(gs);
		runtime.printint(SLICE(ebx_41, word24, 8), gs, ebx_41);
		runtime.printstring(gs);
		runtime.printint(SLICE(ebx_41, word24, 8), gs, eax_37);
		runtime.printstring(gs);
		runtime.printunlock(gs);
		runtime.throw(gs);
	}
	else
	{
		word32 esi_537;
		word32 edi_538;
		runtime.lock(esi, gs, 0x08157590, out esi_537, out edi_538);
		Eq_4 eax_128 = 0x00;
		Eq_4 ecx_131 = 0x00;
		while (true)
		{
			Eq_4 edx_135 = g_t814510C;
			Eq_4 ebx_136 = g_t8145108;
			if (eax_128 >= edx_135)
				break;
			if (eax_128 >= edx_135)
				runtime.panicindex(gs);
			uip32 ebx_530;
			Eq_4 edx_278 = *((word32) ebx_136 + eax_128 * 0x04);
			Eq_4 ebx_279 = *((word32) edx_278 + 0x00AC);
			word24 ebx_24_8_528 = SLICE(ebx_279, word24, 8);
			if (runtime.runfinqPC == ebx_279)
			{
				Eq_4 ebp_283 = (word32) g_b8157569;
				ebp = ebp_283;
				if ((byte) ebp_283 != 0x00)
					goto l08075523;
				ebx_530 = 0x01;
			}
			else
			{
l08075523:
				ebp = runtime.bgsweepPC;
				if (ebp == ebx_279)
					ebx_530 = 0x01;
				else
				{
					ebp = runtime.forcegchelperPC;
					if (ebp == ebx_279)
						ebx_530 = 0x01;
					else
					{
						ebp = runtime.timerprocPC;
						if (ebp == ebx_279)
							ebx_530 = 0x01;
						else
						{
							ebp = runtime.gcBgMarkWorkerPC;
							ebx_530 = SEQ(ebx_24_8_528, (int8) (ebp == ebx_279));
						}
					}
				}
			}
			Eq_4 eax_321 = eax_128;
			if ((byte) ebx_530 == 0x00)
			{
				runtime.readgstatus(edx_278);
				Eq_4 esp_331 = <invalid>;
				Eq_4 eax_336 = *((word32) esp_331 + 4);
				if ((eax_336 & ~0x1000) <= 0x03)
				{
					*((word32) esp_331 + 36) = eax_336;
					esp_331->u0 = 0x08157590;
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					Eq_4 stackArg4 = <invalid>;
					word32 edx_542;
					word32 ebx_543;
					runtime.unlock(gs, stackArg4, out edx_542, out ebx_543);
					Eq_4 eax_351 = *((word32) esp_331 + 40);
					*((word32) esp_331 + 32) = *((word32) eax_351 + 80);
					*((word32) esp_331 + 28) = *((word32) eax_351 + 84);
					runtime.printlock(gs);
					esp_331->u0 = 0x080E44E9;
					((word32) esp_331 + 4)->u0 = 0x1B;
					runtime.printstring(gs);
					*esp_331 = *((word32) esp_331 + 32);
					*((word32) esp_331 + 4) = *((word32) esp_331 + 28);
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					Eq_4 stackArg4 = <invalid>;
					runtime.printint(SLICE(ebx_530, word24, 8), gs, stackArg4);
					esp_331->u0 = 0x080E19FE;
					((word32) esp_331 + 4)->u0 = 11;
					runtime.printstring(gs);
					*esp_331 = *((word32) esp_331 + 36);
					((word32) esp_331 + 4)->u0 = 0x00;
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					Eq_4 stackArg4 = <invalid>;
					runtime.printint(SLICE(ebx_530, word24, 8), gs, stackArg4);
					esp_331->u0 = 0x080E0D9C;
					((word32) esp_331 + 4)->u0 = 0x01;
					runtime.printstring(gs);
					runtime.printunlock(gs);
					esp_331->u0 = 0x080E3321;
					((word32) esp_331 + 4)->u0 = 0x15;
					runtime.throw(gs);
				}
				Eq_4 eax_409;
				if ((eax_336 & ~0x1000) == 0x04)
					eax_409 = (word32) *((word32) esp_331 + 16) + 1;
				else
					eax_409 = *((word32) esp_331 + 16);
				ecx_131 = eax_409;
				eax_321 = *((word32) esp_331 + 0x0C);
			}
			eax_128 = (word32) eax_321 + 1;
		}
		word32 edx_539;
		word32 ebx_540;
		runtime.unlock(gs, 0x08157590, out edx_539, out ebx_540);
		if (ecx_131 == 0x00)
			runtime.throw(gs);
		else
		{
			runtime.timejump(ebp, gs);
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_4 stackArg4 = <invalid>;
			runtime.casgstatus(stackArg4, 0x04, 0x01);
			runtime.jmpdeferPC = 0x00;
			Eq_4 ecx_187 = g_t814541C;
			if (ecx_187 != 0x00)
				((word32) ecx_187 + 0x0068)->u0 = 0x08157590;
			else
				g_t8145418.u0 = 0x08157590;
			g_t814541C.u0 = 0x08157590;
			g_t8145420 = (word32) g_t8145420 + 1;
			runtime.pidleget(gs);
			Eq_4 ecx_232 = g_t81453F4;
			if (ecx_232 != 0x00)
			{
				g_t81453F4 = *((word32) ecx_232 + 0x00B4);
				--g_t81453F8;
			}
			if (ecx_232 == 0x00)
				runtime.throw(gs);
			else
			{
				((word32) ecx_232 + 96)->u0 = 0x08157590;
				runtime.notewakeup(gs, (word32) ecx_232 + 0x00AC);
			}
		}
	}
}

// 08075890: void runtime.sysmon(Register (ptr32 Eq_2) gs)
void runtime.sysmon(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 esp_108 = fp - 0x50;
	if (g_dw815774C > 0x00)
	{
		g_dw81360F0 = 10000000;
		g_dw81360F4 = 0x00;
	}
	runtime.nanotime();
	word32 eax_41 = dwLoc50;
	word32 ecx_42 = dwLoc4C;
	int32 edx_43 = 0x00;
	uint32 ebx_44 = 0x00;
	word32 ebp_45 = 0x00;
	uint32 esi_46 = 0x00;
	Eq_4 edi_47 = 0x00;
l0807590A:
	if (edx_43 == 0x00)
		ebx_44 = 0x14;
	else if (edx_43 > 0x32)
		ebx_44 <<= 0x01;
	*((word32) esp_108 + 44) = esi_46;
	*((word32) esp_108 + 48) = edi_47;
	*((word32) esp_108 + 56) = ecx_42;
	*((word32) esp_108 + 40) = ebp_45;
	*((word32) esp_108 + 52) = eax_41;
	*((word32) esp_108 + 64) = edx_43;
	if (ebx_44 > 10000)
		ebx_44 = 10000;
	word32 eax_115;
	word32 ecx_116;
	*((word32) esp_108 + 0x0044) = ebx_44;
	*esp_108 = ebx_44;
	word32 edi_91;
	Eq_4 esi_93 = runtime.usleep(out edi_91);
	if (g_t8157754 <= 0x00)
	{
		if (g_dw8145454 != 0x00)
		{
l08075964:
			uint32 eax_152;
			word32 ecx_153;
			*esp_108 = 135549936;
			word32 edi_130;
			word32 esi_131;
			runtime.lock(esi_93, gs, *esp_108, out esi_131, out edi_130);
			*esp_108 = 0x08145454;
			runtime/internal/atomic.Load();
			esp_108 = (word32) esp_108 + 4;
			if (*((word32) esp_108 + 4) == 0x00)
			{
				*esp_108 = 0x08145410;
				runtime/internal/atomic.Load();
				esp_108 = (word32) esp_108 + 4;
				if (runtime.gomaxprocs != *((word32) esp_108 + 8))
				{
					eax_152 = (uint32) *((word32) esp_108 + 72);
					ecx_153 = (word32) *((word32) esp_108 + 0x0044);
					goto l08075A68;
				}
			}
			int32 ebx_217;
			ui32 eax_218;
			*esp_108 = 0x08145460;
			*((word32) esp_108 + 4) = 0x01;
			runtime/internal/atomic.Store(*esp_108, *((word32) esp_108 + 4));
			*esp_108 = 135549936;
			word32 ebx_775;
			word32 edx_774;
			runtime.unlock(gs, *esp_108, out edx_774, out ebx_775);
			up32 eax_172 = g_dw81360F0;
			int32 ecx_173 = g_dw81360F4;
			uint32 ecx_177 = (ecx_173 >> 0x1F >> 0x1F) + eax_172;
			int32 ecx_187 = *((word32) esp_108 + 36);
			int32 edx_181 = ecx_173 + (ecx_177 < 0x00);
			up32 edi_200 = *((word32) esp_108 + 32);
			Eq_4 ebx_197 = SEQ(SLICE(esi_131, word24, 8), (int8) (ecx_187 == ecx_173));
			ui32 edx_185 = edx_181 << 0x1F | ecx_177 >> 0x01;
			if (((int8) (edi_200 < eax_172) & (int8) (ecx_187 == ecx_173) | (int8) (ecx_187 < ecx_173)) != 0x00)
			{
				uint32 ecx_222 = (ecx_187 >> 0x1F >> 0x1F) + edi_200;
				int32 eax_225 = ecx_187 + (ecx_222 < 0x00);
				eax_218 = eax_225 << 0x1F | ecx_222 >> 0x01;
				ebx_217 = eax_225 >> 0x01;
			}
			else
			{
				ebx_217 = edx_181 >> 0x01;
				eax_218 = edx_185;
			}
			*esp_108 = 135550052;
			*((word32) esp_108 + 4) = eax_218;
			*((word32) esp_108 + 8) = ebx_217;
			Eq_4 esi_248 = runtime.notetsleep(edx_181 >> 0x01, ebx_197, gs, *esp_108, *((word32) esp_108 + 4), *((word32) esp_108 + 8));
			*esp_108 = 135549936;
			word32 edi_260;
			word32 esi_261;
			runtime.lock(esi_248, gs, *esp_108, out esi_261, out edi_260);
			*esp_108 = 0x08145460;
			*((word32) esp_108 + 4) = 0x00;
			runtime/internal/atomic.Store(*esp_108, *((word32) esp_108 + 4));
			g_dw8145464 = 0x00;
			eax_152 = 0x14;
			ecx_153 = 0x00;
l08075A68:
			*((word32) esp_108 + 64) = ecx_153;
			*((word32) esp_108 + 0x0044) = eax_152;
			*esp_108 = 135549936;
			word32 ebx_784;
			word32 edx_783;
			runtime.unlock(gs, *esp_108, out edx_783, out ebx_784);
			eax_115 = (word32) *((word32) esp_108 + 0x0044);
			ecx_116 = (word32) *((word32) esp_108 + 64);
l08075A86:
			*((word32) esp_108 + 64) = ecx_116;
			*((word32) esp_108 + 0x0044) = eax_115;
			<anonymous> * edx_304 = *runtime.cgo_yield;
			if (edx_304 != null)
			{
				*esp_108 = edx_304;
				*((word32) esp_108 + 4) = 0x00;
				word32 edi_316;
				runtime.asmcgocall(gs, *esp_108, *((word32) esp_108 + 4), out edi_316);
				esp_108.u0 = <invalid>;
			}
			*esp_108.u0 = 135549928;
			word64 mm0_776;
			runtime/internal/atomic.Load64(*esp_108.u0, out mm0_776);
			*((byte) esp_108.u0 + 72) = *((byte) esp_108.u0 + 8);
			*((byte) esp_108.u0 + 60) = *((byte) esp_108.u0 + 4);
			runtime.nanotime();
			up32 eax_346 = *esp_108.u0;
			*((byte) esp_108.u0 + 24) = eax_346;
			int32 ecx_348 = *((byte) esp_108.u0 + 4);
			*((byte) esp_108.u0 + 28) = ecx_348;
			word32 edx_350 = *((byte) esp_108.u0 + 72);
			up32 ebp_354 = *((byte) esp_108.u0 + 60);
			if (((int8) (edx_350 != 0x00) | (int8) (ebp_354 != 0x00)) != 0x00)
			{
				int32 edx_382 = (bool) (ebp_354 < 10000000) + edx_350;
				if (((int8) (ebp_354 + 10000000 < eax_346) & (int8) (edx_382 == ecx_348) | (int8) (edx_382 < ecx_348)) != 0x00)
				{
					*esp_108.u0 = 135549928;
					*((byte) esp_108.u0 + 4) = ebp_354;
					*((byte) esp_108.u0 + 8) = edx_350;
					*((byte) esp_108.u0 + 0x0C) = eax_346;
					*((byte) esp_108.u0 + 16) = ecx_348;
					word32 ebp_778;
					word32 ebx_777;
					runtime/internal/atomic.Cas64(*esp_108.u0, *((byte) esp_108.u0 + 4), *((byte) esp_108.u0 + 0x0C), out ebx_777, out ebp_778);
					*esp_108.u0 = 0x00;
					runtime.netpoll(gs, *esp_108.u0);
					word32 eax_453 = *((byte) esp_108.u0 + 4);
					if (eax_453 != 0x00)
					{
						*((word32) esp_108 + 76) = eax_453;
						*esp_108 = ~0x00;
						runtime.incidlelocked(gs, *esp_108);
						*esp_108 = *((word32) esp_108 + 76);
						runtime.injectglist(gs, *esp_108);
						*esp_108 = 0x01;
						runtime.incidlelocked(gs, *esp_108);
					}
					eax_346 = (up32) *((word32) esp_108 + 24);
					ecx_348 = (int32) *((word32) esp_108 + 28);
				}
			}
			word32 eax_510;
			*esp_108.u0 = eax_346;
			*((byte) esp_108.u0 + 4) = ecx_348;
			Eq_4 esi_500;
			runtime.retake(gs, *((byte) esp_108.u0 - 4), *esp_108.u0, *((byte) esp_108.u0 + 4), *((byte) esp_108.u0 + 8), *((byte) esp_108.u0 + 0x0C), out esi_500);
			if (*((byte) esp_108.u0 + 8) != 0x00)
				eax_510 = 0x00;
			else
				eax_510 = (word32) *((byte) esp_108.u0 + 64) + 1;
			*((word32) esp_108 + 64) = eax_510;
			*esp_108 = 0x02;
			*((word32) esp_108 + 4) = *((word32) esp_108 + 24);
			Eq_4 edx_520 = *((word32) esp_108 + 28);
			*((word32) esp_108 + 8) = edx_520;
			*((word32) esp_108 + 0x0C) = 0x00;
			runtime.gcTrigger.test(edx_520, gs, *esp_108, *((word32) esp_108 + 4));
			if (*((word32) esp_108 + 16) != 0x00)
			{
				*esp_108.u0 = 0x08145140;
				runtime/internal/atomic.Load();
				esp_108 = (byte) esp_108.u0 + 4;
				if (*((word32) esp_108 + 4) != 0x00)
				{
					*esp_108 = 0x08145138;
					word32 edi_780;
					word32 esi_779;
					runtime.lock(esi_500, gs, *esp_108, out esi_779, out edi_780);
					g_dw8145140 = 0x00;
					((word32) g_t814513C + 0x0068)->u0 = 0x00;
					*esp_108 = g_t814513C;
					runtime.injectglist(gs, *esp_108);
					*esp_108 = 0x08145138;
					word32 edx_781;
					word32 ebx_782;
					runtime.unlock(gs, *esp_108, out edx_781, out ebx_782);
				}
			}
			word32 ebx_656;
			int32 ecx_660;
			int32 ecx_587 = *((word32) esp_108 + 36);
			word32 ebx_591 = *((word32) esp_108 + 32);
			uint32 ecx_592 = (ecx_587 >> 0x1F >> 0x1F) + ebx_591;
			int32 edx_596 = ecx_587 + (ecx_592 < 0x00);
			word32 ecx_601 = *((word32) esp_108 + 52);
			ui32 edx_600 = edx_596 << 0x1F | ecx_592 >> 0x01;
			up32 ecx_603 = ecx_601 + edx_600;
			int32 esi_609 = (word32) *((word32) esp_108 + 56) + (edx_596 >> 0x01) + (edx_600 + ecx_601 < 0x00);
			int32 ebp_611 = *((word32) esp_108 + 28);
			up32 edx_615 = *((word32) esp_108 + 24);
			word32 edi_602 = ecx_601;
			if (((int8) (ecx_603 < edx_615) & (int8) (esi_609 == ebp_611) | (int8) (esi_609 < ebp_611)) == 0x00)
			{
				ecx_660 = (int32) *((word32) esp_108 + 56);
				ebx_656 = (word32) *((word32) esp_108 + 40);
			}
			else
			{
				*esp_108 = 0x081488E0;
				*((word32) esp_108 + 4) = *((word32) esp_108 + 40);
				*((word32) esp_108 + 8) = edx_615;
				*((word32) esp_108 + 0x0C) = ebp_611;
				Eq_4 esi_639 = *((word32) esp_108 + 32);
				*((word32) esp_108 + 16) = esi_639;
				*((word32) esp_108 + 20) = ecx_587;
				runtime.(*mheap).scavenge(esi_639, gs, *esp_108, *((word32) esp_108 + 4), *((word32) esp_108 + 8), *((word32) esp_108 + 16), *((word32) esp_108 + 20));
				ebp_611 = (int32) *((word32) esp_108 + 28);
				ebx_656 = (word32) *((word32) esp_108 + 40) + 1;
				ecx_660 = ebp_611;
				edi_602 = (word32) *((word32) esp_108 + 24);
			}
			uint32 ecx_675;
			Eq_4 esi_674;
			*((word32) esp_108 + 56) = ecx_660;
			*((word32) esp_108 + 52) = edi_602;
			*((word32) esp_108 + 40) = ebx_656;
			Eq_43135 esi_671 = g_t8157754;
			if (esi_671 > 0x00)
			{
				*((word32) esp_108 + 72) = esi_671 * 1000000;
				ecx_675 = (uint32) *((word32) esp_108 + 44);
				esi_674 = *((word32) esp_108 + 48);
				int32 edx_692 = SLICE(SEQ(SLICE(esi_671 *64 1000000, word32, 32) + (esi_671 >> 0x1F) *s 1000000, *((word32) esp_108 + 72)) + SEQ(esi_674, ecx_675), word32, 32);
				uint32 edi_697 = *((word32) esp_108 + 24);
				if (((int8) (esi_671 * 1000000 + ecx_675 <= edi_697) & (int8) (edx_692 == ebp_611) | (int8) (edx_692 < ebp_611)) != 0x00)
				{
					esp_108->u0 = (int8) (g_dw8157750 > 0x00);
					runtime.schedtrace(esi_674, gs, *esp_108, *((word32) esp_108 + 8));
					esi_674 = *((word32) esp_108 + 28);
					ecx_675 = (uint32) *((word32) esp_108 + 24);
				}
			}
			else
			{
				esi_674 = *((word32) esp_108 + 48);
				ecx_675 = (uint32) *((word32) esp_108 + 44);
			}
			edx_43 = (int32) *((word32) esp_108 + 64);
			ebx_44 = (uint32) *((word32) esp_108 + 0x0044);
			eax_41 = (word32) *((word32) esp_108 + 52);
			ebp_45 = (word32) *((word32) esp_108 + 40);
			edi_47 = esi_674;
			esi_46 = ecx_675;
			ecx_42 = (word32) *((word32) esp_108 + 56);
			goto l0807590A;
		}
		*esp_108 = 0x08145410;
		runtime/internal/atomic.Load();
		esp_108 = (word32) esp_108 + 4;
		if (runtime.gomaxprocs == *((word32) esp_108 + 4))
			goto l08075964;
	}
	eax_115 = (word32) *((word32) esp_108 + 0x0044);
	ecx_116 = (word32) *((word32) esp_108 + 64);
	goto l08075A86;
}

// 08075E20: Register Eq_4 runtime.retake(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_56118) dwArg00, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C, Stack Eq_4 dwArg10, Register out Eq_4 esiOut)
// Called from:
//      runtime.sysmon
Eq_4 runtime.retake(struct Eq_2 * gs, struct Eq_56118 * dwArg00, Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C, Eq_4 dwArg10, union Eq_4 & esiOut)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 eax_101 = 0x00;
	while (true)
	{
		Eq_4 esp_162 = fp - 44;
		if (eax_101 >= runtime.gomaxprocs)
			break;
		if (eax_101 >= 0x0401)
			runtime.panicindex(gs);
		struct Eq_56698 * ebx_35 = *((char *) g_a81478C0 + eax_101 * 0x04);
		if (ebx_35 != null)
		{
			word32 esi_43 = ebx_35->dw0008;
			if (esi_43 == 0x02)
			{
				word32 ebp_133 = ebx_35->dw0014;
				if (ebx_35->dw0024 != ebp_133)
				{
					ebx_35->dw0024 = ebp_133;
					ebx_35->t0028 = dwArg04;
					ebx_35->t002C = dwArg08;
					ebp = dwArg04;
					esi = dwArg08;
					goto l08075E3F;
				}
				runtime.runqempty(gs, dwLoc30);
				if (bLoc28 == 0x00)
				{
l08075EC5:
					Eq_4 eax_238;
					esp_162->u0 = ~0x00;
					runtime.incidlelocked(gs, *esp_162);
					*esp_162 = *((word32) esp_162 + 40);
					*((word32) esp_162 + 4) = *((word32) esp_162 + 16);
					((word32) esp_162 + 8)->u0 = 0x00;
					runtime/internal/atomic.Cas(*esp_162, *((word32) esp_162 + 4), *((word32) esp_162 + 8));
					if (*((word32) esp_162 + 0x0C) != 0x00)
					{
						if (g_b814F4C8 != 0x00)
						{
							*esp_162 = *((word32) esp_162 + 36);
							word32 ebp_474;
							word32 esi_475;
							runtime.traceGoSysBlock(gs, *esp_162, out ebp_474, out esi_475);
							*esp_162 = *((word32) esp_162 + 36);
							runtime.traceProcStop(gs, *esp_162);
						}
						Eq_4 eax_271 = *((word32) esp_162 + 36);
						*((word32) eax_271 + 20) = (word32) *((word32) eax_271 + 20) + 1;
						*esp_162 = eax_271;
						runtime.handoffp(gs, *esp_162, *((word32) esp_162 + 8));
						esp_162.u0 = <invalid>;
						eax_238 = (word32) *((byte) esp_162.u0 + 20) + 1;
					}
					else
						eax_238 = *((word32) esp_162 + 20);
					*((byte) esp_162.u0 + 32) = eax_238;
					esp_162.u0->u0 = 0x01;
					runtime.incidlelocked(gs, *esp_162.u0);
					goto l08075F2D;
				}
				runtime/internal/atomic.Load();
				runtime/internal/atomic.Load();
				bLoc28 = 0x10;
				esp_162 = fp - 0x24;
				if (ebx_35 + dwLoc20 / 52 <= 0x00)
					goto l08075EC5;
				up32 ecx_174 = dwArg00->dw0028;
				Eq_4 edx_179 = (bool) (ecx_174 < 10000000) + dwArg00->dw002C;
				if (((int8) (edx_179 > dwArg10) | (int8) (ecx_174 + 10000000 > dwArg0C) & (int8) (edx_179 == dwArg10)) == 0x00)
					goto l08075EC5;
				eax_101 = dwLoc24;
				ebp = dwArg0C;
				esi = dwArg10;
				goto l08075E3F;
			}
			if (esi_43 == 0x01)
			{
				word32 ebp_52 = ebx_35->dw0010;
				if (ebx_35->dw0018 != ebp_52)
				{
					ebx_35->dw0018 = ebp_52;
					ebx_35->t001C = dwArg04;
					ebx_35->t0020 = dwArg08;
					ebp = dwArg04;
					esi = dwArg08;
					goto l08075E3F;
				}
				Eq_4 ebp_56 = ebx_35->t001C;
				word32 esi_61 = Mem41[ebx_35 + 0x20:word32] + (ebp_56 <u 10000000);
				if (((int8) (esi_61 > dwArg08) | (int8) (esi_61 == dwArg08) & (int8) ((word32) ebp_56 + 10000000 > dwArg04)) != 0x00)
				{
					ebp = dwArg04;
					esi = dwArg08;
					goto l08075E3F;
				}
				Eq_4 edx_103 = ebx_35->t0030;
				if (edx_103 != 0x00 && *((word32) (gs->ptr0000)->tFFFFFFFC + 24) != edx_103)
				{
					Eq_4 ebx_112 = *((word32) edx_103 + 84);
					if (ebx_112 != 0x00 && ebx_112 != *edx_103)
					{
						((word32) ebx_112 + 0x006C)->u0 = 0x01;
						((word32) ebx_112 + 8)->u0 = ~0x0521;
					}
				}
			}
l08075F2D:
			ebp = *((byte) esp_162.u0 + 48);
			esi = *((byte) esp_162.u0 + 52);
			eax_101 = *((byte) esp_162.u0 + 24);
		}
		else
		{
			ebp = dwArg04;
			esi = dwArg08;
		}
l08075E3F:
		eax_101 = (word32) eax_101 + 1;
	}
	esiOut = esi;
	return ebp;
}

// 080760E0: Register Eq_4 runtime.preemptall(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.freezetheworld
//      runtime.stopTheWorldWithSema
//      runtime.forEachP
Eq_4 runtime.preemptall(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 eax_16 = 0x00;
	while (eax_16 < runtime.gomaxprocs)
	{
		if (eax_16 >= 0x0401)
			runtime.panicindex(gs);
		struct Eq_56992 * ebx_32 = *((char *) g_a81478C0 + eax_16 * 0x04);
		if (ebx_32 != null)
		{
			ebp = ebx_32->t0008;
			if (ebp != 0x01)
				goto l080760F8;
			Eq_4 ebx_39 = ebx_32->t0030;
			if (ebx_39 != 0x00)
			{
				ebp = *((word32) gs->ptr0000->tFFFFFFFC + 24);
				if (ebp == ebx_39)
					goto l0807613A;
				ebp = *((word32) ebx_39 + 84);
				if (ebp != 0x00 && ebp != *ebx_39)
				{
					((word32) ebp + 0x006C)->u0 = 0x01;
					((word32) ebp + 8)->u0 = ~0x0521;
				}
			}
			else
			{
l0807613A:
			}
		}
l080760F8:
		eax_16 = (word32) eax_16 + 1;
	}
	return ebp;
}

// 08076180: void runtime.schedtrace(Register Eq_4 esi, Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_43114) dwArg04, Stack Eq_43115 bArg0C)
// Called from:
//      runtime.startpanic_m
//      runtime.sysmon
void runtime.schedtrace(Eq_4 esi, struct Eq_2 * gs, struct Eq_43114 * dwArg04, Eq_43115 bArg0C)
{
	word32 dwLoc8C = SLICE(qwLoc90, word32, 32);
	Eq_57041 dwLoc90 = (word32) qwLoc90;
	Eq_43115 bArg04 = (byte) dwArg04;
	while (fp - 0x10 <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.nanotime();
	word32 edx_31 = g_dw81576B4;
	Eq_57041 ebx_32 = g_t81576B0;
	if (((int8) (edx_31 == 0x00) & (int8) (ebx_32 == 0x00)) != 0x00)
	{
		g_t81576B0 = dwLoc90;
		g_dw81576B4 = dwLoc8C;
	}
	ui32 edi_62;
	word32 esi_1693;
	runtime.lock(esi, gs, 135549936, out esi_1693, out edi_62);
	runtime.int64div(edi_62, gs, qwLoc90 - g_t81576B0, 1000000);
	Eq_4 ebx_98 = g_t8145400;
	word32 edx_96 = g_dw8145410;
	word32 ebp_100 = g_dw8145414;
	Eq_4 esi_102 = g_t81453F8;
	Eq_49232 edi_104 = g_t8145420;
	runtime.printlock(gs);
	runtime.printstring(gs);
	word24 ebx_24_8_126 = SLICE(ebx_98, word24, 8);
	runtime.printint(ebx_24_8_126, gs, qwLoc80);
	runtime.printstring(gs);
	Eq_4 eax_144 = runtime.gomaxprocs;
	runtime.printint(ebx_24_8_126, gs, SEQ(eax_144 >> 0x1F, eax_144));
	runtime.printstring(gs);
	runtime.printint(ebx_24_8_126, gs, (uint64) edx_96);
	runtime.printstring(gs);
	runtime.printint(ebx_24_8_126, gs, SEQ(ebx_98 >> 0x1F, ebx_98));
	runtime.printstring(gs);
	runtime.printint(ebx_24_8_126, gs, (uint64) ebp_100);
	runtime.printstring(gs);
	runtime.printint(ebx_24_8_126, gs, SEQ(esi_102 >> 0x1F, esi_102));
	runtime.printstring(gs);
	runtime.printint(ebx_24_8_126, gs, SEQ(edi_104 >> 0x1F, edi_104));
	runtime.printunlock(gs);
	Eq_4 dwLoc88_1376 = 1000000;
	word32 dwLoc84_1377 = 0x00;
	if (bArg04 != 0x00)
	{
		word32 ebx_280 = g_dw8145460;
		word32 eax_274 = g_dw8145454;
		Eq_4 ecx_276 = g_t81453FC;
		Eq_4 edx_278 = g_t8145458;
		runtime.printlock(gs);
		runtime.printstring(gs);
		word24 ebx_24_8_301 = SLICE(ebx_280, word24, 8);
		runtime.printint(ebx_24_8_301, gs, (uint64) eax_274);
		runtime.printstring(gs);
		runtime.printint(ebx_24_8_301, gs, SEQ(ecx_276 >> 0x1F, ecx_276));
		runtime.printstring(gs);
		runtime.printint(ebx_24_8_301, gs, SEQ(edx_278 >> 0x1F, edx_278));
		runtime.printstring(gs);
		runtime.printint(ebx_24_8_301, gs, (uint64) ebx_280);
		runtime.printstring(gs);
		runtime.printunlock(gs);
	}
	Eq_43115 al_1347 = bArg04;
	Eq_4 ecx_1338 = 0x00;
	while (ecx_1338 < runtime.gomaxprocs)
	{
		if (ecx_1338 >= 0x0401)
			runtime.panicindex(gs);
		struct Eq_57227 * ebx_1007 = *((char *) g_a81478C0 + ecx_1338 * 0x04);
		word24 ebx_24_8_1099 = SLICE(ebx_1007, word24, 8);
		if (ebx_1007 != null)
		{
			struct Eq_57238 * ecx_1014 = ebx_1007->ptr0030;
			runtime/internal/atomic.Load();
			runtime/internal/atomic.Load();
			if (bArg0C != 0x00)
			{
				Eq_57256 edx_1147;
				if (dwArg04 != null)
					edx_1147 = dwArg04->t0064;
				else
					edx_1147.u0 = ~0x00;
				word32 ebx_1155 = ecx_1014->dw0010;
				word32 ecx_1153 = ecx_1014->dw0008;
				word32 ebp_1157 = ecx_1014->dw0014;
				Eq_57452 eax_1159 = ecx_1014->t0718;
				runtime.printlock(gs);
				runtime.printstring(gs);
				word24 ebx_24_8_1183 = SLICE(ebx_1155, word24, 8);
				runtime.printint(ebx_24_8_1183, gs, SEQ(dwLoc88_1376 >> 0x1F, dwLoc88_1376));
				runtime.printstring(gs);
				runtime.printint(ebx_24_8_1183, gs, (uint64) ecx_1153);
				runtime.printstring(gs);
				runtime.printint(ebx_24_8_1183, gs, (uint64) ebx_1155);
				runtime.printstring(gs);
				runtime.printint(ebx_24_8_1183, gs, (uint64) ebp_1157);
				runtime.printstring(gs);
				runtime.printint(ebx_24_8_1183, gs, SEQ(edx_1147 >> 0x1F, edx_1147));
				runtime.printstring(gs);
				runtime.printint(ebx_24_8_1183, gs, (uint64) (dwLoc84_1377 - dwLoc3C));
				runtime.printstring(gs);
				runtime.printint(ebx_24_8_1183, gs, SEQ(eax_1159 >> 0x1F, eax_1159));
				runtime.printstring(gs);
				runtime.printunlock(gs);
				dwLoc88_1376.u0 = 0x080E0D9C;
				dwLoc84_1377 = 0x01;
			}
			else
			{
				runtime.printlock(gs);
				runtime.printstring(gs);
				runtime.printunlock(gs);
				if (dwLoc88_1376 == 0x00)
				{
					runtime.printlock(gs);
					runtime.printstring(gs);
					runtime.printunlock(gs);
				}
				runtime.printlock(gs);
				Eq_4 eax_1094 = dwLoc84_1377 - dwLoc3C;
				runtime.printint(ebx_24_8_1099, gs, (uint64) eax_1094);
				runtime.printunlock(gs);
				dwLoc88_1376 = eax_1094;
				dwLoc84_1377 = 0x00;
				if (runtime.gomaxprocs - 0x01 == dwLoc88_1376)
				{
					runtime.printlock(gs);
					runtime.printstring(gs);
					runtime.printunlock(gs);
					dwLoc88_1376.u0 = 0x080E0E0F;
					dwLoc84_1377 = 0x02;
				}
			}
			al_1347 = bArg0C;
			ecx_1338 = dwLoc88_1376;
		}
		ecx_1338 = (word32) ecx_1338 + 1;
	}
	if (al_1347 == 0x00)
	{
		word32 ebx_1695;
		word32 edx_1694;
		runtime.unlock(gs, 135549936, out edx_1694, out ebx_1695);
	}
	else
	{
		Eq_4 eax_1003 = runtime.allm;
		while (eax_1003 != 0x00)
		{
			Eq_4 ebx_660;
			Eq_4 ecx_654 = *((word32) eax_1003 + 84);
			Eq_4 edx_655 = *((word32) eax_1003 + 188);
			Eq_4 ebx_656 = *((word32) eax_1003 + 92);
			if (ebx_656 != 0x00)
				ebx_660 = *((word32) ebx_656 + 4);
			else
				ebx_660.u0 = ~0x00;
			Eq_4 ebp_667;
			Eq_4 ecx_666;
			if (ecx_654 != 0x00)
			{
				ebp_667 = *((word32) ecx_654 + 84);
				ecx_666 = *((word32) ecx_654 + 80);
			}
			else
			{
				ecx_666.u0 = ~0x00;
				ebp_667.u0 = ~0x00;
			}
			Eq_4 esi_686;
			Eq_4 edx_685;
			if (edx_655 != 0x00)
			{
				esi_686 = *((word32) edx_655 + 84);
				edx_685 = *((word32) edx_655 + 80);
			}
			else
			{
				edx_685.u0 = ~0x00;
				esi_686.u0 = ~0x00;
			}
			Eq_4 ebx_700 = *((word32) eax_1003 + 0x0068);
			Eq_4 ecx_698 = *((word32) eax_1003 + 100);
			Eq_4 ebp_702 = *((word32) eax_1003 + 0x006C);
			esi_102 = *((word32) eax_1003 + 112);
			Eq_4 edx_708 = *((word32) eax_1003 + 0x0078);
			struct Eq_43073 * edx_710 = *((word32) eax_1003 + 0x0080);
			Eq_4 edx_712 = *((word32) eax_1003 + 0x0088);
			Eq_4 dl_715 = *((word32) eax_1003 + 0x008C);
			Eq_4 al_718 = *((word32) eax_1003 + 141);
			runtime.printlock(gs);
			runtime.printstring(gs);
			word24 ebx_24_8_744 = SLICE(ebx_700, word24, 8);
			runtime.printint(ebx_24_8_744, gs, SEQ(ecx_698 >> 0x1F, ecx_698));
			runtime.printstring(gs);
			runtime.printint(ebx_24_8_744, gs, SEQ(ebx_660 >> 0x1F, ebx_660));
			runtime.printstring(gs);
			runtime.printint(ebx_24_8_744, gs, SEQ(ebp_667, ecx_666));
			runtime.printstring(gs);
			runtime.printint(ebx_24_8_744, gs, SEQ(ebx_700 >> 0x1F, ebx_700));
			runtime.printstring(gs);
			runtime.printint(ebx_24_8_744, gs, SEQ(ebp_702 >> 0x1F, ebp_702));
			runtime.printstring(gs);
			runtime.printstring(gs);
			runtime.printstring(gs);
			runtime.printint(ebx_24_8_744, gs, SEQ(edx_708 >> 0x1F, edx_708));
			runtime.printstring(gs);
			runtime.printint(ebx_24_8_744, gs, SEQ(edx_710 >> 0x1F, edx_710));
			runtime.printstring(gs);
			runtime.printint(ebx_24_8_744, gs, SEQ(edx_712 >> 0x1F, edx_712));
			runtime.printstring(gs);
			runtime.printbool(gs, dl_715);
			runtime.printstring(gs);
			runtime.printbool(gs, al_718);
			runtime.printstring(gs);
			runtime.printint(ebx_24_8_744, gs, SEQ(esi_686, edx_685));
			runtime.printstring(gs);
			runtime.printunlock(gs);
			eax_1003 = *((word32) eax_1003 + 0x00B0);
		}
		word32 esi_1696;
		word32 edi_1697;
		runtime.lock(esi_102, gs, 0x08157590, out esi_1696, out edi_1697);
		Eq_4 eax_439 = 0x00;
		while (true)
		{
			Eq_4 ecx_443 = g_t8145108;
			Eq_4 edx_444 = g_t814510C;
			if (eax_439 >= edx_444)
				break;
			if (eax_439 >= edx_444)
				runtime.panicindex(gs);
			Eq_4 ecx_475 = *((word32) ecx_443 + eax_439 * 0x04);
			Eq_4 ebx_477 = *((word32) ecx_475 + 0x0088);
			*((word32) ecx_475 + 24) == 0x00;
			runtime.readgstatus(ecx_475);
			Eq_4 esp_502 = <invalid>;
			struct Eq_43073 * eax_507 = *((word32) esp_502 + 0x0080);
			*((word32) esp_502 + 0x0078) = eax_507->t0054;
			*((word32) esp_502 + 116) = eax_507->t0050;
			Eq_4 ebx_512 = *((word32) esp_502 + 4);
			*((word32) esp_502 + 112) = ebx_512;
			*((word32) esp_502 + 0x0088) = eax_507->t0060;
			*((word32) esp_502 + 92) = eax_507->t0064;
			runtime.printlock(gs);
			esp_502->u0 = 0x080E0E1F;
			((word32) esp_502 + 4)->u0 = 0x03;
			runtime.printstring(gs);
			*esp_502 = *((word32) esp_502 + 116);
			*((word32) esp_502 + 4) = *((word32) esp_502 + 0x0078);
			word24 ebx_24_8_540 = SLICE(ebx_512, word24, 8);
			runtime.printint(ebx_24_8_540, gs, *esp_502);
			esp_502->u0 = 135140803;
			((word32) esp_502 + 4)->u0 = 0x09;
			runtime.printstring(gs);
			*esp_502 = *((word32) esp_502 + 112);
			((word32) esp_502 + 4)->u0 = 0x00;
			runtime.printint(ebx_24_8_540, gs, *esp_502);
			esp_502->u0 = 0x080E0D85;
			((word32) esp_502 + 4)->u0 = 0x01;
			runtime.printstring(gs);
			*esp_502 = *((word32) esp_502 + 0x0088);
			*((word32) esp_502 + 4) = *((word32) esp_502 + 92);
			runtime.printstring(gs);
			esp_502->u0 = 0x080E0EB2;
			((word32) esp_502 + 4)->u0 = 0x04;
			runtime.printstring(gs);
			Eq_4 eax_599 = *((word32) esp_502 + 64);
			*esp_502 = eax_599;
			*((word32) esp_502 + 4) = eax_599 >> 0x1F;
			runtime.printint(ebx_24_8_540, gs, *esp_502);
			esp_502->u0 = 0x080E1533;
			((word32) esp_502 + 4)->u0 = 0x09;
			runtime.printstring(gs);
			Eq_4 eax_621 = *((word32) esp_502 + 56);
			*esp_502 = eax_621;
			*((word32) esp_502 + 4) = eax_621 >> 0x1F;
			runtime.printint(ebx_24_8_540, gs, *esp_502);
			esp_502->u0 = 0x080E0D9C;
			((word32) esp_502 + 4)->u0 = 0x01;
			runtime.printstring(gs);
			runtime.printunlock(gs);
			eax_439 = (word32) *((word32) esp_502 + 80) + 1;
		}
		word32 edx_1698;
		word32 ebx_1699;
		runtime.unlock(gs, 0x08157590, out edx_1698, out ebx_1699);
		word32 ebx_1701;
		word32 edx_1700;
		runtime.unlock(gs, 135549936, out edx_1700, out ebx_1701);
	}
}

// 08076C40: void runtime.mput(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      runtime.stopm
void runtime.mput(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	*((word32) dwArg04 + 0x00B4) = g_t81453F4;
	g_t81453F4 = dwArg04;
	g_t81453F8 = (word32) g_t81453F8 + 1;
	runtime.checkdead(gs);
}

// 08076C90: void runtime.globrunqget(Register (ptr32 Eq_2) gs, Stack Eq_49232 dwArg08)
// Called from:
//      runtime.findrunnable
//      runtime.schedule
void runtime.globrunqget(struct Eq_2 * gs, Eq_49232 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_49232 eax_17 = g_t8145420;
	if (eax_17 == 0x00)
		return;
	Eq_4 ecx_24 = runtime.gomaxprocs;
	if (ecx_24 == 0x00)
		runtime.panicdivide(gs);
	else
	{
		int32 eax_35;
		Eq_49232 ebx_32 = eax_17;
		if (ecx_24 != ~0x00)
			eax_35 = (int32) ((int64) eax_17 /32 ecx_24);
		else
			eax_35 = -eax_17;
		Eq_49232 ecx_46 = eax_35 + 0x01;
		if (ecx_46 <= eax_17)
			ebx_32 = ecx_46;
		Eq_49232 ecx_57 = dwArg08;
		if (dwArg08 <= 0x00 || ebx_32 <= dwArg08)
			ecx_57 = ebx_32;
		if (ecx_57 > 0x80)
			ecx_57.u0 = 0x80;
		Eq_49232 eax_74 = eax_17 - ecx_57;
		g_t8145420 = eax_74;
		if (eax_74 == 0x00)
			g_t814541C.u0 = 0x00;
		g_t8145418 = *((word32) g_t8145418 + 0x0068);
		int32 ecx_110;
		for (ecx_110 = ecx_57 - 0x01; ecx_110 > 0x00; --ecx_110)
		{
			Eq_4 eax_97 = g_t8145418;
			g_t8145418 = *((word32) eax_97 + 0x0068);
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_4 stackArg0 = <invalid>;
			runtime.runqput(gs, stackArg0, dwArg04, eax_97, 0x00);
		}
	}
}

// 08076D90: void runtime.pidleput(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      runtime.handoffp
//      runtime.findrunnable
//      runtime.procresize
void runtime.pidleput(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	Eq_4 stackArg0 = <invalid>;
	runtime.runqempty(gs, stackArg0);
	if (bLoc08 == 0x00)
		runtime.throw(gs);
	else
	{
		*((word32) dwArg04 + 0x0C) = g_t814540C;
		g_t814540C = dwArg04;
		runtime/internal/atomic.Xadd(0x08145410, 0x01);
	}
}

// 08076E10: void runtime.pidleget(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.stopTheWorldWithSema
//      runtime.startm
//      runtime.findrunnable
//      runtime.exitsyscallfast_pidle
//      runtime.exitsyscall0
//      runtime.checkdead
void runtime.pidleget(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 eax_16 = g_t814540C;
	if (eax_16 != 0x00)
	{
		g_t814540C = *((word32) eax_16 + 0x0C);
		runtime/internal/atomic.Xadd(0x08145410, ~0x00);
	}
}

// 08076E70: void runtime.runqempty(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg00)
// Called from:
//      runtime.startm
//      runtime.handoffp
//      runtime.findrunnable
//      runtime.pollWork
//      runtime.procresize
//      runtime.retake
//      runtime.pidleput
//      sync.runtime_canSpin
void runtime.runqempty(struct Eq_2 * gs, Eq_4 dwArg00)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	do
	{
		runtime/internal/atomic.Load();
		runtime/internal/atomic.Load();
		runtime/internal/atomic.Loaduintptr();
		runtime/internal/atomic.Load();
	} while (dwLoc18 != dwLoc18);
}

// 08076F20: void runtime.runqput(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg00, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 bArg0C)
// Called from:
//      runtime.ready
//      runtime.newproc1
//      runtime.globrunqget
void runtime.runqput(struct Eq_2 * gs, Eq_4 dwArg00, Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 bArg0C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 eax_22;
	if (bArg0C != 0x00)
	{
		do
		{
			Eq_4 ecx_26 = *((word32) dwArg04 + 1808);
			runtime.(*guintptr).cas((word32) dwArg04 + 1808, ecx_26, dwArg08);
			dwLoc18 = ecx_26;
		} while (bLoc10 == 0x00);
		eax_22 = ecx_26;
		if (ecx_26 == 0x00)
			return;
	}
	else
		eax_22 = dwArg08;
	do
	{
		runtime/internal/atomic.Load();
		Eq_4 edx_68 = *((word32) dwArg04 + 780);
		if (edx_68 - dwLoc18 < 0x0100)
		{
			*((word32) dwArg04 + ((edx_68 & 0xFF) * 0x04 + 784)) = eax_22;
			runtime/internal/atomic.Store((word32) dwArg04 + 780, (word32) edx_68 + 1);
			return;
		}
		runtime.runqputslow(gs, dwArg04, eax_22, dwArg08, bArg0C);
		dwLoc18 = eax_22;
	} while (bLoc0C == 0x00);
}

// 08077020: void runtime.runqputslow(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C, Stack Eq_4 dwArg10)
// Called from:
//      runtime.runqput
void runtime.runqputslow(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C, Eq_4 dwArg10)
{
	while (fp - 0x0198 <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	word32 * edi_174 = fp - 0x0204;
	word32 ecx_177;
	for (ecx_177 = 0x81; ecx_177 != 0x00; --ecx_177)
	{
		*edi_174 = 0x00;
		++edi_174;
	}
	uint32 edx_28 = dwArg10 - dwArg0C;
	if (edx_28 >> 0x01 != 0x80)
		runtime.throw(gs);
	else
	{
		uint32 ecx_166;
		for (ecx_166 = 0x00; ecx_166 < edx_28 >> 0x01; ++ecx_166)
		{
			Eq_4 ebp_161 = *((word32) dwArg04 + (((word32) dwArg0C + ecx_166 & 0xFF) * 0x04 + 784));
			if (ecx_166 >= 0x81)
				runtime.panicindex(gs);
			(fp - 0x0204)[ecx_166] = ebp_161;
			esi = fp - 0x0204;
		}
		runtime/internal/atomic.Cas((word32) dwArg04 + 776, dwArg0C, (word32) dwArg0C + (edx_28 >> 0x01));
		if (bLoc020C == 0x00)
			return;
		(fp - 0x0204)[edx_28 >> 0x01] = dwArg08;
		uint32 ecx_152 = 0x00;
		while (ecx_152 < edx_28 >> 0x01)
		{
			if (ecx_152 >= 0x81)
				runtime.panicindex(gs);
			struct Eq_58132 * ebx_141 = (fp - 0x0204)[ecx_152];
			uint32 ebp_144 = ecx_152 + 0x01;
			if (ebp_144 >= 0x81)
				runtime.panicindex(gs);
			esi = (fp - 0x0200)[ecx_152];
			ebx_141->t0068 = esi;
			ecx_152 = ebp_144;
		}
		word32 esi_268;
		word32 edi_269;
		runtime.lock(esi, gs, 135549936, out esi_268, out edi_269);
		Eq_4 ecx_93 = (fp - 0x0204)[edx_28 >> 0x01];
		((word32) ecx_93 + 0x0068)->u0 = 0x00;
		Eq_4 ebx_96 = g_t814541C;
		if (ebx_96 != 0x00)
			*((word32) ebx_96 + 0x0068) = dwLoc0204;
		else
			g_t8145418 = dwLoc0204;
		g_t814541C = ecx_93;
		g_t8145420 = (word32) g_t8145420 + 1 + (edx_28 >> 0x01);
		word32 edx_270;
		word32 ebx_271;
		runtime.unlock(gs, 135549936, out edx_270, out ebx_271);
	}
}

// 080771E0: void runtime.runqget(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      runtime.findrunnable
//      runtime.schedule
//      runtime.gcBgMarkWorker.func2
void runtime.runqget(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	do
	{
		Eq_4 ecx_21 = *((word32) dwArg04 + 1808);
		if (ecx_21 == 0x00)
		{
			do
			{
				runtime/internal/atomic.Load();
				if (*((word32) dwArg04 + 780) == dwLoc18)
					return;
				runtime/internal/atomic.Cas(dwLoc04, dwLoc18, (word32) dwLoc18 + 1);
			} while (bLoc10 == 0x00);
			return;
		}
		runtime.(*guintptr).cas((word32) dwArg04 + 1808, ecx_21, 0x00);
		dwLoc18 = ecx_21;
	} while (bLoc10 == 0x00);
}

// 080772C0: void runtime.runqgrab(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg00, Stack (ptr32 Eq_58217) dwArg04, Stack (arr Eq_4) dwArg08, Stack Eq_4 dwArg0C, Stack int8 bArg10)
// Called from:
//      runtime.runqsteal
void runtime.runqgrab(struct Eq_2 * gs, Eq_4 dwArg00, struct Eq_58217 * dwArg04, Eq_4 dwArg08[], Eq_4 dwArg0C, int8 bArg10)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	do
	{
		runtime/internal/atomic.Load();
		runtime/internal/atomic.Load();
		uint32 eax_38 = dwLoc24 - dwLoc10;
		up32 edx_41 = eax_38 - (eax_38 >> 0x01);
		if (edx_41 != 0x00)
		{
			if (edx_41 > 0x80)
				continue;
			up32 esi_107;
			for (esi_107 = 0x00; esi_107 < edx_41; ++esi_107)
				dwArg08[(word32) dwArg0C + esi_107 & 0xFF] = dwArg04->a0310[(word32) dwLoc10 + esi_107 & 0xFF];
			runtime/internal/atomic.Cas(dwLoc04, dwLoc10, (word32) dwLoc10 + edx_41);
			dwLoc24 = dwLoc10;
			if (bLoc1C == 0x00)
				continue;
			return;
		}
		if (bArg10 == 0x00)
			return;
		Eq_4 edx_51 = dwArg04->t0710;
		if (edx_51 == 0x00)
			return;
		word32 edi_260;
		runtime.usleep(out edi_260);
		runtime.(*guintptr).cas(&dwArg04->t0710, edx_51, 0x00);
		dwLoc24 = edx_51;
	} while (bLoc1C == 0x00);
	dwArg08[dwArg0C & 0xFF] = edx_51;
}

// 08077430: void runtime.runqsteal(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg00, Stack Eq_4 dwArg04, Stack int8 bArg0C)
// Called from:
//      runtime.findrunnable
void runtime.runqsteal(struct Eq_2 * gs, Eq_4 dwArg00, Eq_4 dwArg04, int8 bArg0C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	Eq_4 ecx_19 = *((word32) dwArg04 + 780);
	Eq_4 stackArg0 = <invalid>;
	runtime.runqgrab(gs, stackArg0, dwArg08, (word32) dwArg04 + 784, ecx_19, bArg0C);
	if (dwLoc18 == 0x00)
		return;
	uint32 ebp_43 = (word32) ecx_19 + (dwLoc18 - 0x01);
	Eq_4 ebp_46 = *((word32) dwArg04 + ((ebp_43 & 0xFF) * 0x04 + 784));
	if (dwLoc18 == 0x01)
		return;
	runtime/internal/atomic.Load();
	if (dwLoc18 - ecx_19 - 0x01 + ebp_43 >= 0x0100)
		runtime.throw(gs);
	else
		runtime/internal/atomic.Store(dwArg00, ebp_46);
}

// 08077540: void sync.runtime_procPin(Register (ptr32 Eq_2) gs)
// Called from:
//      sync.(*Pool).getSlow
//      sync.(*Pool).pin
//      sync.(*Pool).pinSlow
void sync.runtime_procPin(struct Eq_2 * gs)
{
	Eq_4 eax_8 = *((word32) gs->ptr0000->tFFFFFFFC + 24);
	*((word32) eax_8 + 0x0078) = (word32) *((word32) eax_8 + 0x0078) + 1;
}

// 08077570: void sync.runtime_procUnpin(Register (ptr32 Eq_2) gs)
// Called from:
//      sync.(*Pool).Put
//      sync.(*Pool).Get
//      sync.(*Pool).getSlow
//      sync.(*Pool).pinSlow
void sync.runtime_procUnpin(struct Eq_2 * gs)
{
	Eq_4 eax_8 = *((word32) gs->ptr0000->tFFFFFFFC + 24);
	--*((word32) eax_8 + 0x0078);
}

// 08077590: void sync/atomic.runtime_procPin(Register (ptr32 Eq_2) gs)
// Called from:
//      sync/atomic.(*Value).Store
void sync/atomic.runtime_procPin(struct Eq_2 * gs)
{
	Eq_4 eax_8 = *((word32) gs->ptr0000->tFFFFFFFC + 24);
	*((word32) eax_8 + 0x0078) = (word32) *((word32) eax_8 + 0x0078) + 1;
}

// 080775C0: void sync/atomic.runtime_procUnpin(Register (ptr32 Eq_2) gs)
// Called from:
//      sync/atomic.(*Value).Store
void sync/atomic.runtime_procUnpin(struct Eq_2 * gs)
{
	Eq_4 eax_8 = *((word32) gs->ptr0000->tFFFFFFFC + 24);
	--*((word32) eax_8 + 0x0078);
}

// 080775E0: void sync.runtime_canSpin(Register (ptr32 Eq_2) gs, Stack int32 dwArg04)
// Called from:
//      sync.(*Mutex).Lock
void sync.runtime_canSpin(struct Eq_2 * gs, int32 dwArg04)
{
	if (dwArg04 >= 0x04 || (runtime.ncpu <= 0x01 || runtime.gomaxprocs <= (g_dw8145410 + 0x01) + g_dw8145414))
		return;
	runtime.runqempty(gs, dwLoc0C);
	if (bLoc04 == 0x00)
		;
}

// 08077650: void sync.runtime_doSpin()
// Called from:
//      sync.(*Mutex).Lock
void sync.runtime_doSpin()
{
	runtime.procyield(0x1E);
}

// 08077670: void runtime.(*randomOrder).reset(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_54924) dwArg04, Stack Eq_4 dwArg08)
// Called from:
//      runtime.procresize
void runtime.(*randomOrder).reset(struct Eq_2 * gs, struct Eq_54924 * dwArg04, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	dwArg04->t0000 = dwArg08;
	dwArg04->t0008.u0 = 0x00;
	Eq_4 edx_124 = 0x01;
	while (edx_124 <= dwArg08)
	{
		runtime.gcd(gs, edx_124, dwArg08);
		if (dwLoc28 == 0x01)
		{
			Eq_4 ecx_48 = dwArg04->t000C;
			Eq_4 edx_111 = dwArg04->t0004;
			Eq_4 ebx_109 = dwArg04->t0008;
			if ((word32) ebx_109 + 1 > ecx_48)
			{
				word128 xmm1_273;
				word128 xmm0_272;
				word32 esi_271;
				runtime.growslice(gs, 0x080CF2A0, edx_111, ebx_109, ecx_48, (word32) ebx_109 + 1, out esi_271, out xmm0_272, out xmm1_273);
				dwArg04->t000C = dwLoc14;
				dwLoc28 = ebx_109;
				if (g_t81576F0 == 0x00)
					dwArg04->t0004 = dwLoc1C;
				else
					runtime.writebarrierptr(&dwArg04->t0004, dwLoc1C);
				ebx_109 = dwLoc18;
				edx_111 = dwLoc1C;
			}
			dwArg04->t0008 = (word32) ebx_109 + 1;
			*((word32) edx_111 + ebx_109 * 0x04) = edx_124;
		}
		edx_124 = (word32) edx_124 + 1;
	}
}

// 08077790: void runtime.gcd(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
// Called from:
//      runtime.(*randomOrder).reset
void runtime.gcd(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 ecx_16 = dwArg04;
	Eq_4 edx_17 = dwArg08;
	while (edx_17 != 0x00)
	{
		edx_17 = (uint32) ((uint64) ecx_16 % edx_17);
		ecx_16 = edx_17;
	}
}

// 080777D0: void runtime.(*profAtomic).load(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      runtime.(*profBuf).canWriteRecord
//      runtime.(*profBuf).canWriteTwoRecords
//      runtime.(*profBuf).write
//      runtime.(*profBuf).wakeupExtra
void runtime.(*profAtomic).load(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	word64 mm0_51;
	runtime/internal/atomic.Load64(dwArg04, out mm0_51);
}

// 08077810: Register word32 runtime.(*profAtomic).cas(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 qwArg08, Stack Eq_4 qwArg10)
// Called from:
//      runtime.(*profBuf).write
//      runtime.(*profBuf).wakeupExtra
word32 runtime.(*profAtomic).cas(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 qwArg08, Eq_4 qwArg10)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	word32 ebx_30;
	word32 ebp_71;
	runtime/internal/atomic.Cas64(dwArg04, qwArg08, qwArg10, out ebx_30, out ebp_71);
	return ebx_30;
}

// 08077870: void runtime.(*profBuf).hasOverflow(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      runtime.(*profBuf).write
void runtime.(*profBuf).hasOverflow(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	word64 mm0_56;
	runtime/internal/atomic.Load64((word32) dwArg04 + 16, out mm0_56);
}

// 080778B0: void runtime.(*profBuf).takeOverflow(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      runtime.(*profBuf).write
void runtime.(*profBuf).takeOverflow(struct Eq_2 * gs, Eq_4 dwArg04)
{
	word32 dwLoc28 = SLICE(qwLoc2C, word32, 32);
	word32 dwLoc2C = (word32) qwLoc2C;
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	word64 mm0_179;
	runtime/internal/atomic.Load64((word32) dwArg04 + 16, out mm0_179);
	word64 mm0_180;
	runtime/internal/atomic.Load64((word32) dwArg04 + 24, out mm0_180);
	while (dwLoc2C != 0x00)
	{
		word32 ebx_181;
		word32 ebp_182;
		runtime/internal/atomic.Cas64((word32) dwArg04 + 16, qwLoc2C, SEQ(dwLoc28 + 0x01, 0x00), out ebx_181, out ebp_182);
		if (bLoc1C != 0x00)
			return;
		word64 mm0_183;
		runtime/internal/atomic.Load64((word32) dwArg04 + 16, out mm0_183);
		word64 mm0_184;
		runtime/internal/atomic.Load64((word32) dwArg04 + 24, out mm0_184);
	}
}

// 080779C0: void runtime.(*profBuf).incrementOverflow(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 qwArg08)
// Called from:
//      runtime.(*profBuf).write
void runtime.(*profBuf).incrementOverflow(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 qwArg08)
{
	up32 dwLoc20 = (word32) qwLoc20;
	word32 dwLoc1C = SLICE(qwLoc20, word32, 32);
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	do
	{
		word64 mm0_169;
		runtime/internal/atomic.Load64((word32) dwArg04 + 16, out mm0_169);
		if (dwLoc20 == 0x00)
		{
			runtime/internal/atomic.Store64(dwLoc28, (word32) dwArg04 + 24, qwArg08);
			runtime/internal/atomic.Store64(dwLoc28, (word32) dwArg04 + 16, SEQ(dwLoc1C + 0x01, 0x01));
			return;
		}
		if (dwLoc20 == ~0x00)
			return;
		word32 ebp_168;
		word32 ebx_167;
		runtime/internal/atomic.Cas64((word32) dwArg04 + 16, qwLoc20, SEQ((bool) (dwLoc20 < 0x01) + dwLoc1C, dwLoc20 + 0x01), out ebx_167, out ebp_168);
	} while (bLoc10 == 0x00);
}

// 08077A90: void runtime.(*profBuf).canWriteRecord(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
// Called from:
//      runtime.(*profBuf).write
void runtime.(*profBuf).canWriteRecord(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.(*profAtomic).load(gs, dwArg04);
	runtime.(*profAtomic).load(gs, (word32) dwArg04 + 8);
	if ((word32) *((word32) dwArg04 + 56) + (int32) ((word30) ((dwLoc0C >> 0x02) - (dwLoc0C >> 0x02))) < 0x01)
		return;
	Eq_4 ebx_63 = *((word32) dwArg04 + 44);
	word32 edi_71 = Mem37[dwArg04 + 0x24:word32] + dwArg08;
	if (ebx_63 != 0x00)
		return;
	runtime.panicdivide(gs);
}

// 08077B60: void runtime.(*profBuf).canWriteTwoRecords(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack word32 dwArg08, Stack Eq_4 dwArg0C)
// Called from:
//      runtime.(*profBuf).write
void runtime.(*profBuf).canWriteTwoRecords(struct Eq_2 * gs, Eq_4 dwArg04, word32 dwArg08, Eq_4 dwArg0C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.(*profAtomic).load(gs, dwArg04);
	runtime.(*profAtomic).load(gs, (word32) dwArg04 + 8);
	if ((word32) *((word32) dwArg04 + 56) + (int32) ((word30) ((dwLoc10 >> 0x02) - (dwLoc10 >> 0x02))) < 0x02)
		return;
	Eq_4 edx_69 = *((word32) dwArg04 + 36);
	Eq_4 ebx_63 = *((word32) dwArg04 + 44);
	word32 edi_71 = (word32) edx_69 + dwArg08;
	if (ebx_63 == 0x00)
		runtime.panicdivide(gs);
	else
	{
		uint32 edx_80 = (uint32) ((uint64) dwLoc14 % ebx_63);
		if (edi_71 + 0x02 + edx_80 > ebx_63)
			edx_80 = 0x00;
	}
}

// 08077C60: Register word32 runtime.(*profBuf).write(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack word32 dwArg08, Stack Eq_4 qwArg0C, Stack ptr32 dwArg14, Stack Eq_4 dwArg18, Stack ptr32 dwArg20, Stack Eq_4 dwArg24)
// Called from:
//      runtime.(*cpuProfile).add
//      runtime.(*cpuProfile).addExtra
//      runtime.(*profBuf).write
word32 runtime.(*profBuf).write(struct Eq_2 * gs, Eq_4 dwArg04, word32 dwArg08, Eq_4 qwArg0C, ptr32 dwArg14, Eq_4 dwArg18, ptr32 dwArg20, Eq_4 dwArg24)
{
runtime.(*profBuf).write_entry:
	byte bLoc44 = (byte) dwLoc44
l08077C60:
	branch fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8) l0807804A
l08077C76:
	branch dwArg04 == 0x00 l08077FF6
l08077C85:
	branch dwArg18 > *((word32) dwArg04 + 36) l08078032
l08077C94:
	runtime.(*profBuf).hasOverflow(gs, dwArg04)
	Eq_4 dwLoc48_769 = dwLoc48
	branch bLoc4C != 0x00 l08077F44
l08077CA9:
	byte bLoc48_509 = (byte) dwLoc48_769
	branch bLoc4C != 0x00 l08077F18
l08077CAF:
	runtime.(*profBuf).canWriteRecord(gs, dwArg04, dwArg24)
	branch bLoc48_509 == 0x00 l08077F18
l08077F18:
	runtime.(*profBuf).incrementOverflow(gs, dwArg04, qwArg0C)
	return runtime.(*profBuf).wakeupExtra(gs, dwArg04)
l08077F44:
	runtime.(*profBuf).canWriteTwoRecords(gs, dwArg04, 0x01, dwArg24)
	branch bLoc44 != 0x00 l08077F79
l08077F6D:
	dwLoc48_769 = dwArg24
	goto l08077CA9
l08077F79:
	runtime.(*profBuf).takeOverflow(gs, dwArg04)
	runtime.(*profBuf).write(gs, dwArg04, 0x00, dwArg24, 0x00, 0x00, fp - 0x20, 0x01)
l08077F99:
l08077FF6:
	return ebx
l08078032:
	runtime.throw(gs)
l0807804A:
	runtime.morestack_noctxt()
	goto l08077C60
runtime.(*profBuf).write_exit:
}

// 08078060: Register word32 runtime.(*profBuf).wakeupExtra(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      runtime.(*profBuf).write
word32 runtime.(*profBuf).wakeupExtra(struct Eq_2 * gs, Eq_4 dwArg04)
{
	ui32 dwLoc18 = SLICE(qwLoc1C, word32, 32);
	uint32 dwLoc1C = (word32) qwLoc1C;
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	do
	{
		runtime.(*profAtomic).load(gs, (word32) dwArg04 + 8);
		word32 ebx_106 = runtime.(*profAtomic).cas(gs, (word32) dwArg04 + 8, qwLoc1C, SEQ(dwLoc18 | 0x02, dwLoc1C));
	} while (bLoc0C == 0x00);
	if ((dwLoc18 & 0x01) != 0x00)
		ebx_106 = runtime.notewakeup(gs, (word32) dwArg04 + 84);
	return ebx_106;
}

// 080780E0: Register word32 syscall.runtime_envs(Register (ptr32 Eq_2) gs, Register out ptr32 esiOut, Register out ptr32 ediOut)
// Called from:
//      syscall.init
word32 syscall.runtime_envs(struct Eq_2 * gs, ptr32 & esiOut, ptr32 & ediOut)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 edx_59;
	runtime.newobject(gs, 0x080CAE20);
	Eq_4 eax_27 = dwLoc28;
	Eq_4 ecx_28 = g_t814512C;
	if (ecx_28 <= 0x00)
		edx_59.u0 = 0x00;
	else
	{
		word32 esi_149;
		word128 xmm0_150;
		word128 xmm1_151;
		runtime.growslice(gs, 135066016, dwLoc28, 0x00, 0x00, ecx_28, out esi_149, out xmm0_150, out xmm1_151);
		edx_59 = dwLoc10;
		eax_27 = dwLoc18;
	}
	if (ecx_28 > edx_59)
		runtime.panicslice(gs);
	else
	{
		ptr32 edi_90;
		ptr32 esi_91;
		word32 ebx_89 = runtime.typedslicecopy(gs, 135066016, eax_27, ecx_28, g_t8145128, g_t814512C, out esi_91, out edi_90);
		esiOut = esi_91;
		ediOut = edi_90;
		return ebx_89;
	}
}

// 080781D0: void os.runtime_args(Register (ptr32 Eq_2) gs)
// Called from:
//      os.init.0
void os.runtime_args(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 edx_59;
	runtime.newobject(gs, 0x080CAE20);
	Eq_4 eax_27 = dwLoc28;
	Eq_4 ecx_28 = g_t814511C;
	if (ecx_28 <= 0x00)
		edx_59.u0 = 0x00;
	else
	{
		word128 xmm0_148;
		word32 esi_147;
		word128 xmm1_149;
		runtime.growslice(gs, 135066016, dwLoc28, 0x00, 0x00, ecx_28, out esi_147, out xmm0_148, out xmm1_149);
		edx_59 = dwLoc10;
		eax_27 = dwLoc18;
	}
	if (ecx_28 > edx_59)
		runtime.panicslice(gs);
	else
	{
		word32 esi_150;
		word32 edi_151;
		runtime.typedslicecopy(gs, 135066016, eax_27, ecx_28, g_t8145118, g_t814511C, out esi_150, out edi_151);
	}
}

// 080782C0: void runtime.gotraceback(Stack Eq_4 dwArg00)
// Called from:
//      runtime.dopanic_m
//      runtime.sighandler
//      runtime.gentraceback
//      runtime.showframe
//      runtime.tracebackothers
void runtime.gotraceback(Eq_4 dwArg00)
{
	runtime/internal/atomic.Load();
	Eq_4 eax_16 = *((word32) dwArg00 + 24);
	*((word32) eax_16 + 0x006C) <= 0x00;
	*((word32) eax_16 + 461) == 0x00;
}

// 08078340: void runtime.args(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
// Called from:
//      main
void runtime.args(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.argc = dwArg04;
	if (g_t81576F0 == 0x00)
		runtime.argv = dwArg08;
	else
		runtime.writebarrierptr(135548848, dwArg08);
	runtime.sysargs(gs, dwArg04, dwArg08);
}

// 080783B0: void runtime.goargs(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.schedinit
void runtime.goargs(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 eax_20 = runtime.argc;
	Eq_4 eax_22 = runtime.argc;
	word32 edi_158;
	runtime.makeslice(gs, 135066016, eax_20, eax_22, out edi_158);
	g_t814511C = dwLoc0C;
	g_dw8145120 = dwLoc08;
	Eq_4 dwLoc18_116 = eax_20;
	if (g_t81576F0 == 0x00)
		g_t8145118 = dwLoc10;
	else
	{
		runtime.writebarrierptr(0x08145118, dwLoc10);
		dwLoc18_116 = dwLoc10;
	}
	Eq_4 eax_106 = 0x00;
	while (eax_106 < runtime.argc)
	{
		runtime.gostringnocopy();
		Eq_4 eax_78 = g_t8145118;
		if (eax_106 >= g_t814511C)
			runtime.panicindex(gs);
		*((word32) eax_78 + (eax_106 * 0x08 + 4)) = eax_22;
		Eq_4 eax_89 = (word32) eax_78 + eax_106 * 0x08;
		if (g_t81576F0 == 0x00)
			*eax_89 = dwLoc18_116;
		else
			runtime.writebarrierptr(eax_89, dwLoc18_116);
		eax_106 = (word32) eax_106 + 1;
	}
}

// 080784B0: void runtime.goenvs_unix(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.goenvs
void runtime.goenvs_unix(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 eax_17 = 0x00;
	while (*((word32) runtime.argv + ((word32) runtime.argc + ((word32) eax_17 + 1)) * 0x04) != 0x00)
		eax_17 = (word32) eax_17 + 1;
	word32 edi_244;
	Eq_4 ebx_113 = runtime.makeslice(gs, 135066016, eax_17, eax_17, out edi_244);
	g_t814512C = dwLoc10;
	g_dw8145130 = dwLoc0C;
	Eq_4 dwLoc1C_150 = eax_17;
	if (g_t81576F0 == 0x00)
		g_t8145128 = dwLoc14;
	else
	{
		runtime.writebarrierptr(0x08145128, dwLoc14);
		dwLoc1C_150 = dwLoc14;
	}
	Eq_4 eax_137 = 0x00;
	while (eax_137 < eax_17)
	{
		runtime.gostring(ebx_113, gs, *((word32) runtime.argv + ((word32) eax_137 + ((word32) runtime.argc + 1)) * 0x04));
		Eq_4 eax_110 = g_t8145128;
		ebx_113 = eax_17;
		if (eax_137 >= g_t814512C)
			runtime.panicindex(gs);
		*((word32) eax_110 + (eax_137 * 0x08 + 4)) = eax_17;
		Eq_4 eax_119 = (word32) eax_110 + eax_137 * 0x08;
		if (g_t81576F0 == 0x00)
			*eax_119 = dwLoc1C_150;
		else
			runtime.writebarrierptr(eax_119, dwLoc1C_150);
		eax_137 = (word32) eax_137 + 1;
	}
}

// 080785D0: Register word64 runtime.testAtomic64(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.check
word64 runtime.testAtomic64(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	g_dw81576C0 = 0x2A;
	g_dw81576C4 = 0x00;
	g_t81576B8.u0 = 0x00;
	g_dw81576BC = 0x00;
	runtime.prefetcht0();
	runtime.prefetcht1();
	runtime.prefetcht2();
	runtime.prefetchnta();
	word32 ebx_471;
	word32 ebp_472;
	runtime/internal/atomic.Cas64(0x081576C0, g_t81576B8, 0x01, out ebx_471, out ebp_472);
	if (bLoc14 != 0x00)
		runtime.throw(gs);
	else
	{
		word32 eax_69 = g_dw81576BC;
		Eq_4 ecx_70 = g_t81576B8;
		if (((int8) (ecx_70 != 0x00) | (int8) (eax_69 != 0x00)) != 0x00)
			runtime.throw(gs);
		else
		{
			g_t81576B8.u0 = 0x2A;
			g_dw81576BC = 0x00;
			word32 ecx_99 = g_dw81576BC;
			Eq_4 edx_100 = g_t81576B8;
			word32 ebx_473;
			word32 ebp_474;
			runtime/internal/atomic.Cas64(0x081576C0, SEQ(ecx_99, edx_100), 0x01, out ebx_473, out ebp_474);
			if (bLoc14 == 0x00)
				runtime.throw(gs);
			else
			{
				word32 eax_128 = g_dw81576BC;
				Eq_4 ecx_129 = g_t81576B8;
				if (((int8) (ecx_129 != 0x2A) | (int8) (eax_128 != 0x00)) == 0x00)
				{
					word32 eax_145 = g_dw81576C4;
					word32 ecx_146 = g_dw81576C0;
					if (((int8) (ecx_146 != 0x01) | (int8) (eax_145 != 0x00)) == 0x00)
					{
						word64 mm0_475;
						runtime/internal/atomic.Load64(0x081576C0, out mm0_475);
						if (((int8) (ecx_99 != 0x00) | (int8) (edx_100 != 0x01)) != 0x00)
							runtime.throw(gs);
						else
						{
							runtime/internal/atomic.Store64(dwLoc2C, 0x081576C0, 0x10000000001);
							word64 mm0_476;
							runtime/internal/atomic.Load64(0x081576C0, out mm0_476);
							if (((int8) false | (byte) ((uint32) ((int8) false))) != 0x00)
								runtime.throw(gs);
							else
							{
								word32 ebx_477;
								word32 ebp_478;
								runtime/internal/atomic.Xadd64(0x081576C0, 0x01, 0x0100, out ebx_477, out ebp_478);
								if ((byte) ((uint32) (int8) true | (uint32) ((int8) true)) != 0x00)
									runtime.throw(gs);
								else
								{
									word64 mm0_479;
									runtime/internal/atomic.Load64(0x081576C0, out mm0_479);
									if (((byte) (uint32) (int8) true | (int8) true) != 0x00)
										runtime.throw(gs);
									else
									{
										runtime/internal/atomic.Xchg64(0x081576C0, 0x30000000003);
										if ((byte) ((uint32) (int8) true | (uint32) ((int8) true)) != 0x00)
											runtime.throw(gs);
										else
										{
											word64 mm0_370;
											runtime/internal/atomic.Load64(0x081576C0, out mm0_370);
											if (((byte) (uint32) (int8) false | (int8) false) == 0x00)
												return mm0_370;
											runtime.throw(gs);
										}
									}
								}
							}
						}
					}
				}
				runtime.throw(gs);
			}
		}
	}
}

// 080789A0: Register word64 runtime.check(Register Eq_4 esi, Register (ptr32 Eq_2) gs)
// Called from:
//      main
word64 runtime.check(Eq_4 esi, struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.timediv(esi, (struct Eq_12643 *) 1264045617, (struct Eq_12643 *) 0x0B3A, 1000000000, fp - 0x1C);
	runtime.throw(gs);
}

// 08078EC0: void runtime.parsedebugvars(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.schedinit
void runtime.parsedebugvars(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	g_dw8157724 = 0x01;
	g_t8157744.u0 = 0x01;
	runtime.gogetenv(gs, 135139898, 0x07);
	byte bLoc30_364 = (byte) dwLoc30;
	if (dwLoc34 == 0x00)
	{
		runtime.gogetenv(gs, 0x080E1A82, 11);
		runtime/debug.SetTraceback(gs, dwLoc38, dwLoc34);
		runtime.traceback_env = runtime.traceback_cache;
		if (g_dw8157724 > 0x01)
		{
			g_b81576F5 = 0x01;
			g_t81576F0.u0 = 0x01;
		}
	}
	else
	{
		Eq_4 edx_123;
		runtime.index(gs, dwLoc38, dwLoc34, 0x080E0D89, 0x01);
		if (dwLoc30 < 0x00)
			edx_123 = dwLoc34;
		else
		{
			if (dwLoc30 > dwLoc34 || (word32) dwLoc30 + 1 > dwLoc34)
				runtime.panicslice(gs);
			edx_123 = dwLoc30;
		}
		runtime.index(gs, dwLoc38, edx_123, 0x080E0D91, 0x01);
		if (dwLoc30 > edx_123 || (word32) dwLoc30 + 1 > edx_123)
			runtime.panicslice(gs);
		else
		{
			Eq_4 ecx_167 = edx_123 - ((word32) dwLoc30 + 1);
			Eq_4 ecx_174 = (word32) dwLoc38 + (-ecx_167 >> 0x1F & (word32) dwLoc30 + 1);
			if (dwLoc30 == 0x0E)
			{
				word32 edi_461;
				word32 ebx_459;
				word32 esi_460;
				runtime.eqstring(dwLoc38, dwLoc38, dwLoc30, 0x080E2188, out ebx_459, out esi_460, out edi_461);
				if (bLoc30_364 != 0x00)
				{
					word32 esi_466;
					runtime.atoi(gs, ecx_174, ecx_167, out esi_466);
					runtime.MemProfileRate.u0 = 0x080E2188;
				}
			}
			Eq_4 edx_254 = dwLoc38;
			Eq_4 eax_247 = dwLoc30;
			struct Eq_59635 * ebp_225 = g_ptr81426C0;
			int32 esi_226 = g_dw81426C4;
			int32 edi_229 = 0x00;
			esi_233 = esi_226;
			while (true)
			{
				int32 esi_233;
				union Eq_4 * ebx_243 = ebp_225->dw0008;
				Eq_4 ebx_245 = ebp_225->dw0000;
				Eq_4 ecx_246 = ebp_225->dw0004;
				if (ecx_246 == eax_247)
				{
					word32 esi_463;
					word32 edi_464;
					word32 ebx_462;
					runtime.eqstring(edx_254, ebx_245, ecx_246, edx_254, out ebx_462, out esi_463, out edi_464);
					byte bLoc34_385 = (byte) eax_247;
					if (bLoc30_364 == 0x00)
					{
						eax_247 = dwLoc30;
						edx_254 = dwLoc38;
						esi_233 = esi_226;
					}
					else
					{
						word32 esi_465;
						runtime.atoi32(gs, ecx_174, ecx_167, out esi_465);
						if (bLoc34_385 != 0x00)
							*ebx_243 = (union Eq_4 *) edx_254;
						eax_247 = dwLoc30;
						edx_254 = dwLoc38;
						esi_233 = esi_226;
					}
				}
				++ebp_225;
				++edi_229;
			}
		}
	}
}

// subject_text_0003.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 08079190: void runtime/debug.SetTraceback(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
// Called from:
//      runtime.parsedebugvars
void runtime/debug.SetTraceback(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	ui32 eax_150;
	if (dwArg08 >= 0x04)
	{
		if (dwArg08 == 0x04)
		{
			runtime.cmpstring(dwArg04, dwArg08, 0x080E0F3E, 0x04);
			dwLoc0C.u1 = 0x080E0F3E;
			bLoc08 = 0x04;
			if (dwLoc04 <= 0x00)
				goto l080791B6;
		}
		if (dwArg08 == 0x05 && (*dwArg04 == 1935766115 && *((word32) dwArg04 + 4) == 0x68))
		{
			eax_150 = 11;
			goto l080791BF;
		}
		if (dwArg08 == 0x06 && (*dwArg04 == 0x676E6973 && *((word32) dwArg04 + 4) == 0x656C))
		{
l080791BA:
			eax_150 = 0x04;
			goto l080791BF;
		}
		if (dwArg08 == 0x06 && (*dwArg04 == 0x74737973 && *((word32) dwArg04 + 4) == 0x6D65))
		{
			eax_150 = 0x0A;
			goto l080791BF;
		}
l0807922E:
		word32 esi_310;
		runtime.atoi(gs, dwArg04, dwArg08, out esi_310);
		if (bLoc08 != 0x00)
			eax_150 = dwLoc0C << 0x02 | 0x02;
		else
			eax_150 = 0x02;
l080791BF:
		if (g_b8157572 != 0x00 || g_b8157570 != 0x00)
			eax_150 |= 0x01;
		runtime/internal/atomic.Store(0x08136020, runtime.traceback_env | eax_150);
	}
	else
	{
l080791B6:
		if (dwArg08 == 0x00)
			goto l080791BA;
		if (dwArg08 == 0x03 && (*dwArg04 == 0x6C61 && *((word32) dwArg04 + 2) == 0x6C))
		{
			eax_150 = 0x06;
			goto l080791BF;
		}
		if (dwArg08 == 0x04 && *dwArg04 == 0x656E6F6E)
		{
			eax_150 = 0x00;
			goto l080791BF;
		}
		goto l0807922E;
	}
}

// 08079340: void runtime.timediv(Register Eq_4 esi, Stack (ptr32 Eq_12643) dwArg04, Stack (ptr32 Eq_12643) dwArg08, Stack Eq_40695 dwArg0C, Stack (ptr32 Eq_40695) dwArg10)
// Called from:
//      runtime.futexsleep
//      runtime.check
void runtime.timediv(Eq_4 esi, struct Eq_12643 * dwArg04, struct Eq_12643 * dwArg08, Eq_40695 dwArg0C, union Eq_40695 * dwArg10)
{
	Eq_59832 ecx_13 = 0x1E;
	int64 edx_ebx_237 = dwArg04;
	while (true)
	{
		Eq_40695 ebx_24 = (word32) edx_ebx_237;
		int32 edx_20 = SLICE(edx_ebx_237, word32, 32);
		if (ecx_13 < 0x00)
			break;
		Eq_59855 edi_83 = ecx_13 - 0x20;
		Eq_59858 ebx_88 = -edi_83;
		ui32 edi_104 = 0x00 - (ecx_13 < 0x20);
		ui32 ebx_115 = 0x00 - (edi_83 < 0x20);
		int32 esi_117 = dwArg0C >> (byte) ebx_88 & 0x00 - (ebx_88 < 0x20) | (dwArg0C >> 0x1F) << (byte) ecx_13 & edi_104 | dwArg0C << (byte) edi_83 & ebx_115;
		Eq_40695 edx_126 = dwArg0C << (byte) ecx_13 & edi_104;
		Eq_40695 ebp_121 = ebx_24;
		int32 edi_141 = edx_20;
		if (((int8) (edx_20 == esi_117) & (int8) (ebx_24 >= edx_126) | (int8) (edx_20 > esi_117)) != 0x00)
		{
			ui64 edi_ebp_182 = edx_ebx_237 - SEQ(esi_117, edx_126);
			ebp_121 = (word32) edi_ebp_182;
			edi_141 = SLICE(edi_ebp_182, word32, 32);
		}
		--ecx_13;
		edx_ebx_237 = SEQ(edi_141, ebp_121);
	}
	if (((int8) (edx_20 == dwArg0C >> 0x1F) & (int8) (ebx_24 >= dwArg0C) | (int8) (edx_20 > dwArg0C >> 0x1F)) == 0x00)
	{
		if (dwArg10 != null)
			*dwArg10 = (union Eq_40695 *) ebx_24;
	}
	else if (dwArg10 != null)
		*dwArg10 = 0x00;
}

// 08079460: void reflect.typelinks(Register (ptr32 Eq_2) gs)
// Called from:
//      reflect.typesByString
void reflect.typelinks(struct Eq_2 * gs)
{
	while (fp - 0x0C <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.activeModules();
	runtime.newobject(gs, 0x080CBE60);
	if (dwLoc88 <= 0x00)
		runtime.panicindex(gs);
	else
	{
		Eq_4 dwLoc88_369;
		Eq_4 ebx_50 = *((char *) *dwLoc8C + 100);
		word32 * esi_63 = (char *) dwLoc8C + (0x01 - dwLoc84 >> 0x1F & 0x04);
		if (g_t81576F0 == 0x00)
		{
			*dwLoc88 = ebx_50;
			dwLoc88_369 = dwLoc88;
		}
		else
		{
			runtime.writebarrierptr(dwLoc88, ebx_50);
			dwLoc88_369 = ebx_50;
		}
		runtime.newobject(gs, 0x080CBC20);
		struct Eq_59953 * eax_97 = *dwLoc8C;
		Eq_4 edx_99 = eax_97->t0080;
		Eq_4 eax_101 = eax_97->t0078;
		*((word32) dwLoc88_369 + 4) = eax_97->t007C;
		*((word32) dwLoc88_369 + 8) = edx_99;
		if (g_t81576F0 == 0x00)
			*dwLoc88_369 = eax_101;
		else
			runtime.writebarrierptr(dwLoc88_369, eax_101);
		Eq_4 ecx_121 = dwLoc88_369;
		Eq_59981 edx_131 = 0x00;
		Eq_4 ebp_135 = 0x01;
		Eq_4 esi_136 = 0x01;
		Eq_4 edi_137 = 0x01;
		Eq_4 dwLoc6C_381 = 0x01;
		Eq_4 dwLoc0C_384 = dwLoc88;
		word32 * ebx_141 = esi_63;
		while (edx_131 < dwLoc88 - (Eq_4 (*)[]) 0x01)
		{
			Eq_4 dwLoc30_408;
			struct Eq_59986 * eax_168 = *ebx_141;
			Eq_4 ebx_171 = (word32) dwLoc6C_381 + 1;
			Eq_4 ecx_172 = eax_168->t0064;
			if ((word32) dwLoc6C_381 + 1 <= edi_137)
				dwLoc30_408 = dwLoc0C_384;
			else
			{
				word128 xmm1_580;
				word32 esi_578;
				word128 xmm0_579;
				runtime.growslice(gs, 0x080CF3A0, dwLoc0C_384, dwLoc6C_381, edi_137, (word32) dwLoc6C_381 + 1, out esi_578, out xmm0_579, out xmm1_580);
				edi_137 = dwLoc70;
				ebx_171 = dwLoc74 + 0x01;
				dwLoc30_408 = dwLoc78;
			}
			dwLoc6C_381 = ebx_171;
			Eq_4 esi_226 = (word32) dwLoc30_408 + dwLoc6C_381 * 0x04;
			if (g_t81576F0 == 0x00)
				*((word32) dwLoc30_408 + dwLoc6C_381 * 0x04) = ecx_172;
			else
				runtime.writebarrierptr(esi_226, ecx_172);
			Eq_4 dwLoc2C_438;
			Eq_4 ecx_247 = (word32) ebp_135 + 1;
			Eq_4 edx_251 = eax_168->t0078;
			Eq_4 ebx_252 = eax_168->t007C;
			Eq_4 eax_253 = eax_168->t0080;
			Eq_4 esi_255 = esi_136;
			if (ecx_247 <= esi_136)
				dwLoc2C_438 = ecx_121;
			else
			{
				word128 xmm1_583;
				word32 esi_581;
				word128 xmm0_582;
				runtime.growslice(gs, 0x080C9640, ecx_121, ebp_135, esi_136, ecx_247, out esi_581, out xmm0_582, out xmm1_583);
				esi_255 = dwLoc70;
				ecx_247 = dwLoc74 + 0x01;
				dwLoc2C_438 = dwLoc78;
			}
			ui32 ebp_309 = ebp_135 * 0x03;
			*((word32) dwLoc2C_438 + (ebp_309 * 0x04 + 4)) = ebx_252;
			*((word32) dwLoc2C_438 + (ebp_309 * 0x04 + 8)) = eax_253;
			Eq_4 ebx_316 = (word32) dwLoc2C_438 + ebp_309 * 0x04;
			if (g_t81576F0 == 0x00)
				*((word32) dwLoc2C_438 + ebp_309 * 0x04) = edx_251;
			else
				runtime.writebarrierptr(ebx_316, edx_251);
			esi_136 = esi_255;
			ecx_121 = dwLoc2C_438;
			++ebx_141;
			edx_131 = (word32) edx_131.u0 + 1;
			ebp_135 = ecx_247;
			dwLoc0C_384 = dwLoc30_408;
		}
	}
}

// 080797C0: Register word32 reflect.resolveNameOff(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
// Called from:
//      reflect.(*rtype).nameOff
word32 reflect.resolveNameOff(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	return runtime.resolveNameOff(gs, dwArg04, dwArg08);
}

// 08079800: void reflect.resolveTypeOff(Register (ptr32 Eq_2) gs)
// Called from:
//      reflect.name.pkgPath
//      reflect.(*rtype).typeOff
void reflect.resolveTypeOff(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.(*_type).typeOff(gs);
}

// 08079840: void reflect.resolveTextOff(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
// Called from:
//      reflect.(*rtype).textOff
void reflect.resolveTextOff(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.(*_type).textOff(gs, dwArg04, dwArg08);
}

// 08079880: void reflect.addReflectOff(Register word24 ebx_24_8, Register Eq_4 esi, Register Eq_4 edi, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      reflect.resolveReflectName
void reflect.addReflectOff(word24 ebx_24_8, Eq_4 esi, Eq_4 edi, struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.reflectOffsLock(gs);
	if (g_t81451A8 == 0x00)
	{
		Eq_4 edi_44;
		Eq_4 esi_46 = runtime.makemap(ebx_24_8, esi, edi, gs, 0x080CFA40, 0x00, 0x00, 0x00, 0x00, out edi_44);
		if (g_t81576F0 == 0x00)
			g_t81451A8 = dwLoc0C;
		else
			runtime.writebarrierptr(135549352, dwLoc0C);
		word32 edi_362;
		runtime.makemap(ebx_24_8, esi_46, edi_44, gs, 0x080CFC40, 0x00, 0x00, 0x00, 0x00, out edi_362);
		dwLoc14.u0 = 0x00;
		bLoc10 = 0x00;
		if (g_t81576F0 == 0x00)
			g_t81451AC = dwLoc0C;
		else
			runtime.writebarrierptr(135549356, dwLoc0C);
		g_t81451A4.u0 = ~0x00;
	}
	runtime.mapaccess2_fast32(gs, &g_t80CFC40, g_t81451AC, dwArg04);
	if (bLoc10 == 0x00)
	{
		Eq_4 eax_145 = g_t81451A4;
		g_t81451A4 = eax_145 - 0x01;
		runtime.mapassign_fast32(gs, 0x080CFA40, g_t81451A8, eax_145);
		if (g_t81576F0 == 0x00)
			*dwLoc14 = dwArg04;
		else
			runtime.writebarrierptr(dwLoc14, dwArg04);
		runtime.mapassign_fast32(gs, 0x080CFC40, g_t81451AC, dwArg04);
		*dwLoc14 = eax_145;
	}
	runtime.reflectOffsUnlock(gs);
}

// 08079A40: void runtime.(*guintptr).cas(Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C)
// Called from:
//      runtime.runqput
//      runtime.runqget
//      runtime.runqgrab
//      runtime.gcBgMarkWorker.func1
void runtime.(*guintptr).cas(Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C)
{
	runtime/internal/atomic.Casuintptr(dwArg04, dwArg08, dwArg0C);
}

// 08079A70: void runtime.extendRandom(Register (ptr32 Eq_2) gs, Register Eq_4 mm0, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg10)
// Called from:
//      runtime.getRandomData
void runtime.extendRandom(struct Eq_2 * gs, Eq_4 mm0, Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg10)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 eax_17 = dwArg10;
	if (dwArg10 < 0x00)
		eax_17.u0 = 0x00;
	while (eax_17 < dwArg08)
	{
		Eq_4 edx_35;
		if (eax_17 > 0x10)
			edx_35.u0 = 0x10;
		else
			edx_35 = eax_17;
		runtime.nanotime();
		Eq_4 eax_50 = eax_17 - edx_35;
		if (eax_50 >= dwArg08)
			runtime.panicindex(gs);
		word32 eax_58 = eax_50 + dwArg04;
		dwLoc18 = eax_58;
		word128 xmm1_225;
		mm0 = runtime.memhash(gs, mm0, eax_58, dwLoc18, edx_35, out xmm1_225);
		Eq_4 ebx_105 = eax_17;
		int32 ebp_104 = 0x00;
		eax_223 = dwLoc0C;
		while (true)
		{
			uint32 eax_223;
			byte al_101 = (byte) eax_223;
			if (ebp_104 >= 0x04 || ebx_105 >= dwArg08)
				break;
			if (ebx_105 >= dwArg08)
				runtime.panicindex(gs);
			Mem103[dwArg04 + ebx_105:byte] = al_101;
			++ebp_104;
			ebx_105 = (word32) ebx_105 + 1;
			eax_223 >>= 0x08;
		}
		eax_17 = ebx_105;
	}
}

// 08079B30: void runtime.(*rwmutex).rlock(Register (ptr32 Eq_2) gs, Stack ptr32 dwArg04)
// Called from:
//      runtime.newm
void runtime.(*rwmutex).rlock(struct Eq_2 * gs, ptr32 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 ecx_19 = *((word32) gs->ptr0000->tFFFFFFFC + 24);
	*((word32) ecx_19 + 0x0078) = (word32) *((word32) ecx_19 + 0x0078) + 1;
	runtime/internal/atomic.Xadd(dwArg04 + 0x14, 0x01);
	if (dwLoc0C < 0x00)
	{
		word32 edi_76;
		word32 ebp_75;
		runtime.systemstack(gs, fp - 0x08, out ebp_75, out edi_76);
	}
}

// 08079BB0: void runtime.(*rwmutex).runlock(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      runtime.newm
void runtime.(*rwmutex).runlock(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime/internal/atomic.Xadd((word32) dwArg04 + 20, ~0x00);
	if (dwLoc04 < 0x00)
	{
		if (dwLoc04 == ~0x00 || dwLoc04 == ~0x40000000)
			runtime.throw(gs);
		runtime/internal/atomic.Xadd((word32) dwArg04 + 24, ~0x00);
		if (dwLoc04 == 0x00)
		{
			word32 edi_142;
			word32 esi_141;
			runtime.lock(esi, gs, dwArg04, out esi_141, out edi_142);
			Eq_4 ecx_70 = *((word32) dwArg04 + 16);
			if (ecx_70 != 0x00)
				runtime.notewakeup(gs, (word32) ecx_70 + 0x00AC);
			word32 edx_143;
			word32 ebx_144;
			runtime.unlock(gs, dwArg04, out edx_143, out ebx_144);
		}
	}
	Eq_4 eax_93 = gs->ptr0000->tFFFFFFFC;
	Eq_4 ecx_94 = *((word32) eax_93 + 24);
	Eq_4 edx_95 = *((word32) ecx_94 + 0x0078);
	*((word32) ecx_94 + 0x0078) = edx_95 - 0x01;
	if (edx_95 == 0x01 && *((word32) eax_93 + 0x006C) != 0x00)
		((word32) eax_93 + 8)->u0 = ~0x0521;
}

// 08079CB0: Register ui32 internal/poll.runtime_Semacquire(Register ui32 edi, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      internal/poll.(*fdMutex).rwlock
ui32 internal/poll.runtime_Semacquire(ui32 edi, struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	ui32 edi_28;
	runtime.semacquire1(edi, gs, dwArg04, 0x00, 0x01, out edi_28);
	return edi_28;
}

// 08079CF0: void sync.runtime_Semrelease(Register word32 ebp, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg00, Stack Eq_4 dwArg04)
// Called from:
//      sync.(*Mutex).Unlock
void sync.runtime_Semrelease(word32 ebp, struct Eq_2 * gs, Eq_4 dwArg00, Eq_4 dwArg04)
{
	Eq_4 bArg04_49 = (byte) dwArg04;
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.semrelease1(ebp, gs, dwLoc0C, dwArg04, dwArg00, bArg04_49);
}

// 08079D30: Register word32 sync.runtime_SemacquireMutex(Register ui32 edi, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack byte bArg08, Register out ptr32 ediOut)
// Called from:
//      sync.(*Mutex).Lock
word32 sync.runtime_SemacquireMutex(ui32 edi, struct Eq_2 * gs, Eq_4 dwArg04, byte bArg08, ptr32 & ediOut)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	ptr32 edi_30;
	word32 ebp_27 = runtime.semacquire1(edi, gs, dwArg04, bArg08, 0x03, out edi_30);
	ediOut = edi_30;
	return ebp_27;
}

// 08079D70: Register Eq_4 internal/poll.runtime_Semrelease(Register (ptr32 Eq_2) gs)
// Called from:
//      internal/poll.(*fdMutex).increfAndClose
//      internal/poll.(*fdMutex).rwunlock
Eq_4 internal/poll.runtime_Semrelease(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		edx = runtime.morestack_noctxt();
	runtime.semrelease(gs);
	return edx;
}

// 08079DA0: void runtime.readyWithTime(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_60578) dwArg04)
// Called from:
//      runtime.semrelease1
void runtime.readyWithTime(struct Eq_2 * gs, struct Eq_60578 * dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	word32 ecx_18 = dwArg04->dw001C;
	word32 edx_19 = dwArg04->dw0020;
	if (((int8) (edx_19 != 0x00) | (int8) (ecx_18 != 0x00)) != 0x00)
	{
		runtime.cputicks();
		dwArg04->dw001C = dwLoc08;
		dwArg04->dw0020 = dwLoc04;
	}
	runtime.goready(gs);
}

// 08079E10: void runtime.semacquire(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.gcStart
//      runtime.gcMarkDone
//      runtime.stopTheWorld
void runtime.semacquire(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	word32 edi_38;
	runtime.semacquire1(edi, gs, dwArg04, 0x00, 0x00, out edi_38);
}

// 08079E50: Register ui32 runtime.semacquire1(Register ui32 edi, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack byte bArg08, Stack ui32 dwArg0C, Register out Eq_1912 ediOut)
// Called from:
//      internal/poll.runtime_Semacquire
//      sync.runtime_SemacquireMutex
//      runtime.semacquire
ui32 runtime.semacquire1(ui32 edi, struct Eq_2 * gs, Eq_4 dwArg04, byte bArg08, ui32 dwArg0C, union Eq_1912 & ediOut)
{
	word32 dwLoc30;
	ptr32 fp;
	ui32 edi;
	struct Eq_2 * gs;
	<type-error> Mem0;
	Eq_4 dwArg04;
	bLoc30 = (byte) dwLoc30;
	ui32 dwArg0C;
	byte bArg08;
	ui32 ebp;
	while (true)
	{
		ecx_6 = gs->ptr0000;
		ecx_7 = ecx_6->tFFFFFFFC;
		if (fp > *((word32) ecx_7 + 8))
			break;
		runtime.morestack_noctxt();
	}
	eax_17 = gs->ptr0000;
	eax_18 = eax_17->tFFFFFFFC;
	ecx_19 = *((word32) eax_18 + 24);
	ecx_20 = *((word32) ecx_19 + 84);
	if (eax_18 != ecx_20)
		runtime.throw(gs);
	else
	{
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		stackArg0.u0 = <invalid>;
		runtime.cansemacquire(gs, stackArg0, dwArg04);
		eax_36 = (word32) bLoc30;
		al_37 = (byte) eax_36;
		if (al_37 != 0x00)
		{
			ediOut.u2 = <invalid>;
			return ebp;
		}
		else
		{
			runtime.acquireSudog(gs);
			ecx_24_8_164 = SLICE(dwArg04, word24, 8);
			((word32) dwArg04 + 28)->u0 = 0x00;
			((word32) dwArg04 + 32)->u0 = 0x00;
			((word32) dwArg04 + 20)->u0 = 0x00;
			((word32) dwArg04 + 24)->u0 = 0x00;
			((word32) dwArg04 + 36)->u0 = 0x00;
			edx_eax_60 = (dwArg04 >> 0x03) *64 2190262207;
			edx_61 = SLICE(edx_eax_60, word32, 32);
			edx_63 = (edx_61 >> 0x07) *s 0xFB;
			ebp_64 = (dwArg04 >> 0x03) - edx_63;
			if ((dwArg0C & 0x01) != 0x00)
			{
				edx_74 = g_dw815766C;
				edx_24_8_108 = SLICE(edx_74, word24, 8);
				esi_75 = g_dw8157668;
				ebx_24_8_85 = SLICE(edi, word24, 8);
				bl_83 = (int8) (edx_74 == 0x00);
				ebx_86 = SEQ(ebx_24_8_85, bl_83);
				ebx_24_8_98 = SLICE(esi_75, word24, 8);
				bl_96 = (int8) (esi_75 > 0x00);
				ebx_99 = SEQ(ebx_24_8_98, bl_96);
				esi_102 = ebx_99 & ebx_86;
				dl_107 = (int8) (edx_74 > 0x00);
				edx_109 = SEQ(edx_24_8_108, dl_107);
				esi_110 = esi_102 | edx_109;
				al_114 = (byte) esi_110;
				if (al_114 == 0x00)
					edx_esi_553 = 0x00;
				else
				{
					runtime.cputicks();
					((word32) dwArg04 + 28)->u0 = ~0x00;
					((word32) dwArg04 + 32)->u0 = ~0x00;
					ecx_24_8_165 = SLICE(dwArg04, word24, 8);
					edx_esi_554 = SEQ(dwLoc30, dwArg04);
				}
			}
			else
				edx_esi_555 = 0x00;
			edx_esi_556 = (edx_esi_553, edx_esi_554, edx_esi_555);
			esi_190 = (word32) edx_esi_556;
			edx_186 = SLICE(edx_esi_556, word32, 32);
			ecx_24_8_163 = (ecx_24_8_164, ecx_24_8_165, ecx_24_8_164);
			Mem143 = (Mem65, Mem131, Mem65);
			edx_esi_551 = edx_esi_556;
			if ((dwArg0C & 0x02) != 0x00)
			{
				eax_144 = g_dw8157694;
				eax_24_8_173 = SLICE(eax_144, word24, 8);
				edi_145 = g_dw8157690;
				cl_148 = (int8) (eax_144 == 0x00);
				ebx_24_8_159 = SLICE(edi_145, word24, 8);
				bl_157 = (int8) (edi_145 > 0x00);
				ebx_160 = SEQ(ebx_24_8_159, bl_157);
				ecx_166 = SEQ(ecx_24_8_163, cl_148);
				edi_167 = ebx_160 & ecx_166;
				al_172 = (int8) (eax_144 > 0x00);
				eax_174 = SEQ(eax_24_8_173, al_172);
				edi_175 = edi_167 | eax_174;
				al_179 = (byte) edi_175;
				edx_esi_549 = edx_esi_556;
				if (al_179 != 0x00)
				{
					al_189 = (int8) (edx_186 == 0x00);
					cl_193 = (int8) (esi_190 == 0x00);
					eax_195 = SEQ(eax_24_8_173, al_189);
					ecx_196 = SEQ(ecx_24_8_163, cl_193);
					eax_197 = eax_195 & ecx_196;
					al_198 = (byte) eax_197;
					if (al_198 != 0x00)
					{
						runtime.cputicks();
						edx_esi_557 = SEQ(dwLoc30, dwArg04);
					}
					edx_esi_558 = (edx_esi_556, edx_esi_557);
					edx_216 = SLICE(edx_esi_558, word32, 32);
					esi_213 = (word32) edx_esi_558;
					*((word32) dwArg04 + 20) = esi_213;
					*((word32) dwArg04 + 24) = edx_216;
					edx_esi_550 = edx_esi_558;
				}
			}
			edx_esi_552 = (edx_esi_549, edx_esi_550, edx_esi_551);
			esi_218 = (word32) edx_esi_552;
			runtime.lock(esi_218, gs, (ebp_64 << 0x06) + 0x0814B600, out esi_561, out edi_562);
			runtime/internal/atomic.Xadd((ebp_64 << 0x06) + 0x0814B608, 0x01);
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			stackArg0.u0 = <invalid>;
			runtime.cansemacquire(gs, stackArg0, dwArg04);
			ebx_279 = runtime/internal/atomic.Xadd((ebp_64 << 0x06) + 0x0814B608, ~0x00);
			ebx_24_8_348 = SLICE(ebx_279, word24, 8);
			runtime.unlock(gs, (ebp_64 << 0x06) + 0x0814B600, out edx_564, out ebx_565);
			ebx_24_8_346 = (ebx_24_8_347, ebx_24_8_348);
			Mem335 = (Mem321, Mem286);
			ecx_337 = *((word32) dwArg04 + 32);
			edx_338 = *((word32) dwArg04 + 28);
			bl_341 = (int8) (ecx_337 == 0x00);
			ebx_349 = SEQ(ebx_24_8_346, bl_341);
			ebx_24_8_356 = SLICE(ebp_64 << 0x06, word24, 8);
			bl_354 = (int8) (edx_338 > 0x00);
			ebx_357 = SEQ(ebx_24_8_356, bl_354);
			ebp_360 = ebx_357 & ebx_349;
			bl_362 = (int8) (ecx_337 > 0x00);
			ebx_364 = SEQ(ebx_24_8_346, bl_362);
			ebx_365 = ebx_364 | ebp_360;
			bl_366 = (byte) ebx_365;
			if (bl_366 != 0x00)
			{
				ecx_edx_410 = SEQ(ecx_337, edx_338);
				ecx_edx_412 = ecx_edx_410 - edx_esi_552;
				edx_371 = (word32) ecx_edx_412;
				ecx_376 = SLICE(ecx_edx_412, word32, 32);
				runtime.blockevent(SLICE(ebx_365, word24, 8), gs, edx_371, ecx_376);
			}
			runtime.releaseSudog(gs, dwArg04, out esi_567, out edi_568);
			ediOut.u2 = <invalid>;
			return ebp_360;
		}
	}
}

// 0807A160: Register Eq_4 runtime.semrelease(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.gcStart
//      runtime.gcMarkDone
//      runtime.gcMarkTermination
//      runtime.startTheWorld
//      internal/poll.runtime_Semrelease
Eq_4 runtime.semrelease(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	Eq_4 stackArg0 = <invalid>;
	Eq_4 stackArg12 = <invalid>;
	runtime.semrelease1(ebp, gs, stackArg0, dwArg04, stackArg12, dwArg04);
	return <invalid>;
}

// 0807A1A0: void runtime.semrelease1(Register word32 ebp, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg00, Stack Eq_4 dwArg04, Stack Eq_4 bArg0C, Stack Eq_4 bArg10)
// Called from:
//      sync.runtime_Semrelease
//      runtime.semrelease
void runtime.semrelease1(word32 ebp, struct Eq_2 * gs, Eq_4 dwArg00, Eq_4 dwArg04, Eq_4 bArg0C, Eq_4 bArg10)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime/internal/atomic.Xadd(dwArg04, 0x01);
	runtime/internal/atomic.Load();
	if (dwLoc2C == 0x00)
		return;
	word32 edi_340;
	word32 esi_339;
	runtime.lock(esi, gs, (word32) dwArg04 + 135575040, out esi_339, out edi_340);
	runtime/internal/atomic.Load();
	if (dwLoc28 == 0x00)
	{
		word32 edx_341;
		word32 ebx_342;
		runtime.unlock(gs, dwArg00, out edx_341, out ebx_342);
	}
	else
	{
		runtime.(*semaRoot).dequeue(gs, (word32) dwArg04 + 135575040, dwArg0C);
		Eq_4 dwLoc28_247 = dwArg0C;
		if (dwLoc24 != null)
		{
			dwLoc28_247.u0 = ~0x00;
			runtime/internal/atomic.Xadd(dwArg04, ~0x00);
		}
		word32 edx_343;
		word32 ebx_344;
		runtime.unlock(gs, dwArg00, out edx_343, out ebx_344);
		if (dwLoc24 == null)
			return;
		uint32 ecx_123 = dwLoc24->dw0014;
		ui32 edx_124 = dwLoc24->dw0018;
		if (((int8) (edx_124 != 0x00) | (int8) (ecx_123 != 0x00)) != 0x00)
		{
			Eq_4 eax_163 = SLICE(qwLoc20 - SEQ(edx_124, ecx_123), word32, 32);
			sync.event(ebx_24_8, gs, eax_163);
			dwLoc28_247 = eax_163;
		}
		byte bLoc28_289 = (byte) dwLoc28_247;
		if (dwLoc24->dw0024 != 0x00)
			runtime.throw(gs);
		else
		{
			if (bArg10 != 0x00)
			{
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				Eq_4 stackArg0 = <invalid>;
				runtime.cansemacquire(gs, stackArg0, dwArg0C);
				if (bLoc28_289 != 0x00)
					dwLoc24->dw0024 = 0x01;
			}
			runtime.readyWithTime(gs, dwLoc24);
		}
	}
}

// 0807A380: void runtime.cansemacquire(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg00, Stack Eq_4 dwArg04)
// Called from:
//      runtime.semacquire1
//      runtime.semrelease1
void runtime.cansemacquire(struct Eq_2 * gs, Eq_4 dwArg00, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	do
	{
		runtime/internal/atomic.Load();
		if (dwLoc0C == 0x00)
			return;
		runtime/internal/atomic.Cas(dwArg04, dwLoc0C, dwLoc0C - 0x01);
	} while (bLoc04 == 0x00);
}

// 0807A3E0: void runtime.(*semaRoot).queue(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_61042) dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C, Stack byte bArg10)
// Called from:
//      runtime.semacquire1
void runtime.(*semaRoot).queue(struct Eq_2 * gs, struct Eq_61042 * dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C, byte bArg10)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 edx_22 = gs->ptr0000->tFFFFFFFC;
	if (g_t81576F0 == 0x00)
	{
		*dwArg0C = edx_22;
		*((word32) dwArg0C + 16) = dwArg08;
		((word32) dwArg0C + 8)->u0 = 0x00;
		((word32) dwArg0C + 0x0C)->u0 = 0x00;
	}
	else
	{
		runtime.writebarrierptr(dwArg0C, edx_22);
		runtime.writebarrierptr((word32) dwArg0C + 16, dwArg08);
		runtime.writebarrierptr((word32) dwArg0C + 8, 0x00);
		runtime.writebarrierptr((word32) dwArg0C + 0x0C, 0x00);
	}
	Eq_4 ebx_110 = &dwArg04->t0004;
	Eq_4 edi_550 = dwArg04->t0004;
	Eq_4 dwLoc20_586 = 0x00;
	while (edi_550 != 0x00)
	{
		Eq_4 ebp_197 = *((word32) edi_550 + 16);
		if (dwArg08 == ebp_197)
		{
			if (bArg10 != 0x00)
			{
				if (g_t81576F0 == 0x00)
					*ebx_110 = dwArg0C;
				else
					runtime.writebarrierptr(ebx_110, dwArg0C);
				*((word32) dwArg0C + 36) = *((word32) edi_550 + 36);
				Eq_4 ecx_290 = *((word32) edi_550 + 24);
				*((word32) dwArg0C + 20) = *((word32) edi_550 + 20);
				*((word32) dwArg0C + 24) = ecx_290;
				Eq_4 ebx_296 = *((word32) edi_550 + 40);
				Eq_4 ebp_297 = (word32) edi_550 + 40;
				if (g_t81576F0 == 0x00)
					*((word32) dwArg0C + 40) = ebx_296;
				else
					runtime.writebarrierptr((word32) dwArg0C + 40, ebx_296);
				Eq_4 edx_318 = *((word32) edi_550 + 0x0C);
				Eq_4 ebx_319 = (word32) edi_550 + 0x0C;
				if (g_t81576F0 == 0x00)
					*((word32) dwArg0C + 0x0C) = edx_318;
				else
					runtime.writebarrierptr((word32) dwArg0C + 0x0C, edx_318);
				Eq_4 edx_344 = *((word32) edi_550 + 8);
				Eq_4 esi_345 = (word32) edi_550 + 8;
				if (g_t81576F0 == 0x00)
					*((word32) dwArg0C + 8) = edx_344;
				else
					runtime.writebarrierptr((word32) dwArg0C + 8, edx_344);
				Eq_4 ecx_368 = *((word32) dwArg0C + 0x0C);
				if (ecx_368 != 0x00)
				{
					if (g_t81576F0 == 0x00)
						*((word32) ecx_368 + 40) = dwArg0C;
					else
						runtime.writebarrierptr((word32) ecx_368 + 40, dwArg0C);
				}
				Eq_4 ecx_392 = *((word32) dwArg0C + 8);
				if (ecx_392 != 0x00)
				{
					if (g_t81576F0 == 0x00)
						*((word32) ecx_392 + 40) = dwArg0C;
					else
						runtime.writebarrierptr((word32) ecx_392 + 40, dwArg0C);
				}
				if (g_t81576F0 == 0x00)
					*((word32) dwArg0C + 44) = edi_550;
				else
					runtime.writebarrierptr((word32) dwArg0C + 44, edi_550);
				Eq_4 esi_442 = *((word32) edi_550 + 48);
				Eq_4 ebx_443 = (word32) edi_550 + 48;
				if (g_t81576F0 == 0x00)
					*((word32) dwArg0C + 48) = esi_442;
				else
					runtime.writebarrierptr((word32) dwArg0C + 48, esi_442);
				if (esi_442 == 0x00)
				{
					if (g_t81576F0 == 0x00)
						*((word32) dwArg0C + 48) = edi_550;
					else
						runtime.writebarrierptr((word32) dwArg0C + 48, edi_550);
				}
				if (g_t81576F0 == 0x00)
				{
					*((word32) edi_550 + 40) = 0x00;
					*((word32) edi_550 + 0x0C) = 0x00;
					*((word32) edi_550 + 8) = 0x00;
					*((word32) edi_550 + 48) = 0x00;
				}
				else
				{
					runtime.writebarrierptr(ebp_297, 0x00);
					runtime.writebarrierptr(ebx_319, 0x00);
					runtime.writebarrierptr(esi_345, 0x00);
					runtime.writebarrierptr(ebx_443, 0x00);
				}
			}
			else
			{
				struct Eq_61268 * ecx_207 = *((word32) edi_550 + 48);
				Eq_4 edx_208 = (word32) edi_550 + 48;
				if (ecx_207 != null)
				{
					if (g_t81576F0 == 0x00)
						ecx_207->t002C = dwArg0C;
					else
						runtime.writebarrierptr(&ecx_207->t002C, dwArg0C);
				}
				else
				{
					Eq_4 ebx_214 = (word32) edi_550 + 44;
					if (g_t81576F0 == 0x00)
						*((word32) edi_550 + 44) = dwArg0C;
					else
						runtime.writebarrierptr(ebx_214, dwArg0C);
				}
				if (g_t81576F0 == 0x00)
				{
					*((word32) edi_550 + 48) = dwArg0C;
					((word32) dwArg0C + 44)->u0 = 0x00;
				}
				else
				{
					runtime.writebarrierptr(edx_208, dwArg0C);
					runtime.writebarrierptr((word32) dwArg0C + 44, 0x00);
				}
			}
			return;
		}
		if (dwArg08 < ebp_197)
			ebx_110 = (word32) edi_550 + 0x0C;
		else
			ebx_110 = (word32) edi_550 + 8;
		dwLoc20_586 = edi_550;
		edi_550 = *ebx_110;
	}
	Eq_4 ecx_95 = *((word32) gs->ptr0000->tFFFFFFFC + 24);
	Eq_4 ebp_96 = *((word32) ecx_95 + 0x0094);
	Eq_4 esi_101 = ebp_96 << 0x01 ^ ebp_96 >> 0x1F & 0xA8888EEF;
	*((word32) ecx_95 + 0x0094) = esi_101;
	*((word32) dwArg0C + 36) = esi_101;
	if (g_t81576F0 == 0x00)
		*((word32) dwArg0C + 40) = dwLoc20_586;
	else
		runtime.writebarrierptr((word32) dwArg0C + 40, dwLoc20_586);
	if (g_t81576F0 == 0x00)
		*ebx_110 = dwArg0C;
	else
		runtime.writebarrierptr(ebx_110, dwArg0C);
	while (true)
	{
		Eq_4 ecx_153 = *((word32) dwArg0C + 40);
		if (ecx_153 == 0x00 || *((word32) ecx_153 + 36) <= *((word32) dwArg0C + 36))
			break;
		if (dwArg0C != *((word32) ecx_153 + 0x0C))
		{
			if (*((word32) ecx_153 + 8) != dwArg0C)
				runtime.gopanic(gs);
			runtime.(*semaRoot).rotateLeft(gs, dwArg04, ecx_153);
		}
		else
			runtime.(*semaRoot).rotateRight(gs, dwArg04, ecx_153);
	}
}

// 0807A950: void runtime.(*semaRoot).dequeue(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_61042) dwArg04, Stack Eq_4 dwArg08)
// Called from:
//      runtime.semrelease1
void runtime.(*semaRoot).dequeue(struct Eq_2 * gs, struct Eq_61042 * dwArg04, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 ecx_18 = &dwArg04->t0004;
	Eq_4 edx_22 = dwArg04->t0004;
	while (edx_22 != 0x00)
	{
		Eq_4 esi_36 = *((word32) edx_22 + 16);
		Eq_4 edi_37 = (word32) edx_22 + 16;
		if (dwArg08 == esi_36)
		{
			Eq_4 esi_84;
			Eq_4 ebx_83;
			word32 esi_46 = *((word32) edx_22 + 24);
			word32 ebx_45 = *((word32) edx_22 + 20);
			if (((int8) (esi_46 != 0x00) | (int8) (ebx_45 != 0x00)) == 0x00)
			{
				ebx_83.u0 = 0x00;
				esi_84.u0 = 0x00;
			}
			else
			{
				runtime.cputicks();
				ebx_83 = dwLoc2C;
				esi_84 = dwLoc28;
			}
			Eq_4 edi_100 = *((word32) edx_22 + 44);
			Eq_4 ebp_101 = (word32) edx_22 + 44;
			if (edi_100 == 0x00)
			{
				while (true)
				{
					struct Eq_61604 * ecx_341 = *((word32) edx_22 + 8);
					if (ecx_341 == null && *((word32) edx_22 + 0x0C) == 0x00)
						break;
					if (ecx_341 != null)
					{
						struct Eq_61628 * ebp_471 = *((word32) edx_22 + 0x0C);
						if (ebp_471 != null && ebp_471->dw0024 < ecx_341->dw0024)
							goto l0807AA13;
						runtime.(*semaRoot).rotateLeft(gs, dwArg04, edx_22);
					}
					else
					{
l0807AA13:
						runtime.(*semaRoot).rotateRight(gs, dwArg04, edx_22);
					}
				}
				struct Eq_61830 * ecx_349 = *((word32) edx_22 + 40);
				if (ecx_349 != null)
				{
					if (edx_22 == ecx_349->t000C)
					{
						if (g_t81576F0 == 0x00)
							ecx_349->t000C.u0 = 0x00;
						else
							runtime.writebarrierptr(&ecx_349->t000C, 0x00);
					}
					else if (g_t81576F0 == 0x00)
						ecx_349->dw0008 = 0x00;
					else
						runtime.writebarrierptr(&ecx_349->dw0008, 0x00);
				}
				else if (g_t81576F0 == 0x00)
					dwArg04->t0004.u0 = 0x00;
				else
					runtime.writebarrierptr(&dwArg04->t0004, 0x00);
			}
			else
			{
				if (g_t81576F0 == 0x00)
					*ecx_18 = edi_100;
				else
					runtime.writebarrierptr(ecx_18, edi_100);
				*((word32) edi_100 + 36) = *((word32) edx_22 + 36);
				Eq_4 ebp_137 = *((word32) edx_22 + 40);
				if (g_t81576F0 == 0x00)
					*((word32) edi_100 + 40) = ebp_137;
				else
					runtime.writebarrierptr((word32) edi_100 + 40, ebp_137);
				Eq_4 ebp_159 = *((word32) edx_22 + 0x0C);
				if (g_t81576F0 == 0x00)
					*((word32) edi_100 + 0x0C) = ebp_159;
				else
					runtime.writebarrierptr((word32) edi_100 + 0x0C, ebp_159);
				if (ebp_159 != 0x00)
				{
					if (g_t81576F0 == 0x00)
						*((word32) ebp_159 + 40) = edi_100;
					else
						runtime.writebarrierptr((word32) ebp_159 + 40, edi_100);
				}
				Eq_4 ebp_208 = *((word32) edx_22 + 8);
				if (g_t81576F0 == 0x00)
					*((word32) edi_100 + 8) = ebp_208;
				else
					runtime.writebarrierptr((word32) edi_100 + 8, ebp_208);
				if (ebp_208 != 0x00)
				{
					if (g_t81576F0 == 0x00)
						*((word32) ebp_208 + 40) = edi_100;
					else
						runtime.writebarrierptr((word32) ebp_208 + 40, edi_100);
				}
				if (*((word32) edi_100 + 44) != 0x00)
				{
					Eq_4 ebp_279 = *((word32) edx_22 + 48);
					if (g_t81576F0 == 0x00)
						*((word32) edi_100 + 48) = ebp_279;
					else
						runtime.writebarrierptr((word32) edi_100 + 48, ebp_279);
				}
				else if (g_t81576F0 == 0x00)
					((word32) edi_100 + 48)->u0 = 0x00;
				else
					runtime.writebarrierptr((word32) edi_100 + 48, 0x00);
				*((word32) edi_100 + 20) = ebx_83;
				*((word32) edi_100 + 24) = esi_84;
				Eq_4 ecx_313 = (word32) edx_22 + 48;
				if (g_t81576F0 == 0x00)
				{
					*((word32) edx_22 + 44) = 0x00;
					*((word32) edx_22 + 48) = 0x00;
				}
				else
				{
					runtime.writebarrierptr(ebp_101, 0x00);
					runtime.writebarrierptr(ecx_313, 0x00);
				}
			}
			Eq_4 ecx_407 = (word32) edx_22 + 40;
			Eq_4 ebp_408 = (word32) edx_22 + 8;
			Eq_4 edi_409 = (word32) edx_22 + 0x0C;
			if (g_t81576F0 == 0x00)
			{
				*((word32) edx_22 + 40) = 0x00;
				*((word32) edx_22 + 16) = 0x00;
				*((word32) edx_22 + 8) = 0x00;
				*((word32) edx_22 + 0x0C) = 0x00;
			}
			else
			{
				runtime.writebarrierptr(ecx_407, 0x00);
				runtime.writebarrierptr(edi_37, 0x00);
				runtime.writebarrierptr(ebp_408, 0x00);
				runtime.writebarrierptr(edi_409, 0x00);
			}
			*((word32) edx_22 + 36) = 0x00;
			return;
		}
		if (dwArg08 < esi_36)
			ecx_18 = (word32) edx_22 + 0x0C;
		else
			ecx_18 = (word32) edx_22 + 8;
		edx_22 = *ecx_18;
	}
}

// 0807AE50: void runtime.(*semaRoot).rotateLeft(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_61042) dwArg04, Stack Eq_4 dwArg08)
// Called from:
//      runtime.(*semaRoot).queue
//      runtime.(*semaRoot).dequeue
void runtime.(*semaRoot).rotateLeft(struct Eq_2 * gs, struct Eq_61042 * dwArg04, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 ecx_18 = *((word32) dwArg08 + 8);
	Eq_4 edx_20 = *((word32) dwArg08 + 40);
	Eq_4 ebp_24 = *((word32) dwArg08 + 0x0C);
	Eq_4 ebx_30 = *((word32) ecx_18 + 0x0C);
	Eq_4 esi_33 = *((word32) ecx_18 + 8);
	if (g_t81576F0 == 0x00)
	{
		*((word32) ecx_18 + 0x0C) = dwArg08;
		*((word32) dwArg08 + 40) = ecx_18;
		*((word32) ecx_18 + 8) = esi_33;
	}
	else
	{
		runtime.writebarrierptr((word32) ecx_18 + 0x0C, dwArg08);
		runtime.writebarrierptr((word32) dwArg08 + 40, ecx_18);
		runtime.writebarrierptr((word32) ecx_18 + 8, esi_33);
	}
	if (esi_33 != 0x00)
	{
		if (g_t81576F0 == 0x00)
			*((word32) esi_33 + 40) = ecx_18;
		else
			runtime.writebarrierptr((word32) esi_33 + 40, ecx_18);
	}
	if (g_t81576F0 == 0x00)
		*((word32) dwArg08 + 0x0C) = ebp_24;
	else
		runtime.writebarrierptr((word32) dwArg08 + 0x0C, ebp_24);
	if (ebp_24 != 0x00)
	{
		if (g_t81576F0 == 0x00)
			*((word32) ebp_24 + 40) = dwArg08;
		else
			runtime.writebarrierptr((word32) ebp_24 + 40, dwArg08);
	}
	if (g_t81576F0 == 0x00)
		*((word32) dwArg08 + 8) = ebx_30;
	else
		runtime.writebarrierptr((word32) dwArg08 + 8, ebx_30);
	if (ebx_30 != 0x00)
	{
		if (g_t81576F0 == 0x00)
			*((word32) ebx_30 + 40) = dwArg08;
		else
			runtime.writebarrierptr((word32) ebx_30 + 40, dwArg08);
	}
	if (g_t81576F0 == 0x00)
		*((word32) ecx_18 + 40) = edx_20;
	else
		runtime.writebarrierptr((word32) ecx_18 + 40, edx_20);
	if (edx_20 == 0x00)
	{
		if (g_t81576F0 == 0x00)
			dwArg04->t0004 = ecx_18;
		else
			runtime.writebarrierptr(&dwArg04->t0004, ecx_18);
	}
	else if (*((word32) edx_20 + 0x0C) != dwArg08)
	{
		if (*((word32) edx_20 + 8) != dwArg08)
			runtime.throw(gs);
		else if (g_t81576F0 == 0x00)
			*((word32) edx_20 + 8) = ecx_18;
		else
			runtime.writebarrierptr((word32) edx_20 + 8, ecx_18);
	}
	else if (g_t81576F0 == 0x00)
		*((word32) edx_20 + 0x0C) = ecx_18;
	else
		runtime.writebarrierptr((word32) edx_20 + 0x0C, ecx_18);
}

// 0807B100: void runtime.(*semaRoot).rotateRight(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_61042) dwArg04, Stack Eq_4 dwArg08)
// Called from:
//      runtime.(*semaRoot).queue
//      runtime.(*semaRoot).dequeue
void runtime.(*semaRoot).rotateRight(struct Eq_2 * gs, struct Eq_61042 * dwArg04, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 ecx_18 = *((word32) dwArg08 + 0x0C);
	Eq_4 edx_20 = *((word32) dwArg08 + 40);
	Eq_4 esi_26 = *((word32) dwArg08 + 8);
	Eq_4 ebp_30 = *((word32) ecx_18 + 0x0C);
	Eq_4 ebx_31 = *((word32) ecx_18 + 8);
	if (ebp_30 != 0x00)
	{
		if (g_t81576F0 == 0x00)
			*((word32) ebp_30 + 40) = ecx_18;
		else
			runtime.writebarrierptr((word32) ebp_30 + 40, ecx_18);
	}
	if (g_t81576F0 == 0x00)
	{
		*((word32) ecx_18 + 8) = dwArg08;
		*((word32) dwArg08 + 40) = ecx_18;
		*((word32) dwArg08 + 0x0C) = ebx_31;
	}
	else
	{
		runtime.writebarrierptr((word32) ecx_18 + 8, dwArg08);
		runtime.writebarrierptr((word32) dwArg08 + 40, ecx_18);
		runtime.writebarrierptr((word32) dwArg08 + 0x0C, ebx_31);
	}
	if (ebx_31 != 0x00)
	{
		if (g_t81576F0 == 0x00)
			*((word32) ebx_31 + 40) = dwArg08;
		else
			runtime.writebarrierptr((word32) ebx_31 + 40, dwArg08);
	}
	if (g_t81576F0 == 0x00)
		*((word32) dwArg08 + 8) = esi_26;
	else
		runtime.writebarrierptr((word32) dwArg08 + 8, esi_26);
	if (esi_26 != 0x00)
	{
		if (g_t81576F0 == 0x00)
			*((word32) esi_26 + 40) = dwArg08;
		else
			runtime.writebarrierptr((word32) esi_26 + 40, dwArg08);
	}
	if (g_t81576F0 == 0x00)
		*((word32) ecx_18 + 40) = edx_20;
	else
		runtime.writebarrierptr((word32) ecx_18 + 40, edx_20);
	if (edx_20 == 0x00)
	{
		if (g_t81576F0 == 0x00)
			dwArg04->t0004 = ecx_18;
		else
			runtime.writebarrierptr(&dwArg04->t0004, ecx_18);
	}
	else if (*((word32) edx_20 + 0x0C) != dwArg08)
	{
		if (*((word32) edx_20 + 8) != dwArg08)
			runtime.throw(gs);
		else if (g_t81576F0 == 0x00)
			*((word32) edx_20 + 8) = ecx_18;
		else
			runtime.writebarrierptr((word32) edx_20 + 8, ecx_18);
	}
	else if (g_t81576F0 == 0x00)
		*((word32) edx_20 + 0x0C) = ecx_18;
	else
		runtime.writebarrierptr((word32) edx_20 + 0x0C, ecx_18);
}

// 0807B370: void sync.runtime_notifyListCheck(Register word24 ebx_24_8, Register (ptr32 Eq_2) gs, Stack word32 dwArg04)
// Called from:
//      sync.init.1
void sync.runtime_notifyListCheck(word24 ebx_24_8, struct Eq_2 * gs, word32 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (dwArg04 == 0x14)
		return;
	runtime.printlock(gs);
	runtime.printstring(gs);
	runtime.printint(ebx_24_8, gs, (uint64) dwArg04);
	runtime.printstring(gs);
	runtime.printint(ebx_24_8, gs, 0x14);
	runtime.printstring(gs);
	runtime.printunlock(gs);
	runtime.throw(gs);
}

// 0807B430: void sync.runtime_nanotime(Register (ptr32 Eq_2) gs)
// Called from:
//      sync.(*Mutex).Lock
void sync.runtime_nanotime(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.nanotime();
}

// 0807B470: void runtime.dumpregs(Register Eq_4 esi, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      runtime.sighandler
void runtime.dumpregs(Eq_4 esi, struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 ecx_24 = *((word32) *((word32) dwArg04 + 4) + 64);
	runtime.printlock(gs);
	runtime.printstring(gs);
	Eq_4 esi_53;
	runtime.printhex(esi, gs, ecx_24, 0x00, out esi_53);
	runtime.printstring(gs);
	runtime.printunlock(gs);
	Eq_4 ecx_81 = *((word32) *((word32) dwArg04 + 4) + 52);
	runtime.printlock(gs);
	runtime.printstring(gs);
	Eq_4 esi_108;
	runtime.printhex(esi_53, gs, ecx_81, 0x00, out esi_108);
	runtime.printstring(gs);
	runtime.printunlock(gs);
	Eq_4 ecx_136 = *((word32) *((word32) dwArg04 + 4) + 60);
	runtime.printlock(gs);
	runtime.printstring(gs);
	Eq_4 esi_163;
	runtime.printhex(esi_108, gs, ecx_136, 0x00, out esi_163);
	runtime.printstring(gs);
	runtime.printunlock(gs);
	Eq_4 ecx_191 = *((word32) *((word32) dwArg04 + 4) + 56);
	runtime.printlock(gs);
	runtime.printstring(gs);
	Eq_4 esi_218;
	runtime.printhex(esi_163, gs, ecx_191, 0x00, out esi_218);
	runtime.printstring(gs);
	runtime.printunlock(gs);
	Eq_4 ecx_246 = *((word32) *((word32) dwArg04 + 4) + 36);
	runtime.printlock(gs);
	runtime.printstring(gs);
	Eq_4 esi_273;
	runtime.printhex(esi_218, gs, ecx_246, 0x00, out esi_273);
	runtime.printstring(gs);
	runtime.printunlock(gs);
	Eq_4 ecx_301 = *((word32) *((word32) dwArg04 + 4) + 40);
	runtime.printlock(gs);
	runtime.printstring(gs);
	Eq_4 esi_328;
	runtime.printhex(esi_273, gs, ecx_301, 0x00, out esi_328);
	runtime.printstring(gs);
	runtime.printunlock(gs);
	Eq_4 ecx_356 = *((word32) *((word32) dwArg04 + 4) + 44);
	runtime.printlock(gs);
	runtime.printstring(gs);
	Eq_4 esi_383;
	runtime.printhex(esi_328, gs, ecx_356, 0x00, out esi_383);
	runtime.printstring(gs);
	runtime.printunlock(gs);
	Eq_4 ecx_411 = *((word32) *((word32) dwArg04 + 4) + 48);
	runtime.printlock(gs);
	runtime.printstring(gs);
	Eq_4 esi_438;
	runtime.printhex(esi_383, gs, ecx_411, 0x00, out esi_438);
	runtime.printstring(gs);
	runtime.printunlock(gs);
	Eq_4 ecx_466 = *((word32) *((word32) dwArg04 + 4) + 76);
	runtime.printlock(gs);
	runtime.printstring(gs);
	Eq_4 esi_493;
	runtime.printhex(esi_438, gs, ecx_466, 0x00, out esi_493);
	runtime.printstring(gs);
	runtime.printunlock(gs);
	Eq_4 ecx_521 = *((word32) *((word32) dwArg04 + 4) + 84);
	runtime.printlock(gs);
	runtime.printstring(gs);
	Eq_4 esi_548;
	runtime.printhex(esi_493, gs, ecx_521, 0x00, out esi_548);
	runtime.printstring(gs);
	runtime.printunlock(gs);
	Eq_4 ecx_576 = (word32) *((word32) *((word32) dwArg04 + 4) + 80);
	runtime.printlock(gs);
	runtime.printstring(gs);
	Eq_4 esi_603;
	runtime.printhex(esi_548, gs, ecx_576, 0x00, out esi_603);
	runtime.printstring(gs);
	runtime.printunlock(gs);
	Eq_4 ecx_631 = (word32) *((word32) *((word32) dwArg04 + 4) + 24);
	runtime.printlock(gs);
	runtime.printstring(gs);
	Eq_4 esi_658;
	runtime.printhex(esi_603, gs, ecx_631, 0x00, out esi_658);
	runtime.printstring(gs);
	runtime.printunlock(gs);
	Eq_4 eax_686 = (word32) *((word32) *((word32) dwArg04 + 4) + 20);
	runtime.printlock(gs);
	runtime.printstring(gs);
	word32 esi_837;
	runtime.printhex(esi_658, gs, eax_686, 0x00, out esi_837);
	runtime.printstring(gs);
	runtime.printunlock(gs);
}

// 0807B960: void runtime.(*sigctxt).preparePanic(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_62544) dwArg04)
// Called from:
//      runtime.sighandler
void runtime.(*sigctxt).preparePanic(struct Eq_2 * gs, struct Eq_62544 * dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	struct Eq_62557 * ecx_18 = dwArg04->ptr0004;
	Eq_4 edx_23 = ecx_18->t004C;
	struct Eq_62565 * ecx_24 = ecx_18->ptr0030;
	if (edx_23 != 0x00)
	{
		runtime.findfunc(gs, edx_23);
		if (dwLoc18 == 0x00)
		{
			runtime.findfunc(gs, ecx_24->dw0000);
			if (dwLoc18 != 0x00)
				edx_23.u0 = 0x00;
		}
	}
	if (edx_23 != 0x00)
	{
		ecx_24->tFFFFFFFC = edx_23;
		dwArg04->ptr0004->ptr0030 = (struct Eq_62565 *) &ecx_24->tFFFFFFFC;
	}
	dwArg04->ptr0004->t004C = g_t80E7CC0;
}

// 0807BA40: void runtime.sighandler(Register Eq_4 esi, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack (ptr32 Eq_62608) dwArg0C, Stack Eq_4 dwArg10)
// Called from:
//      runtime.sigtrampgo
void runtime.sighandler(Eq_4 esi, struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, struct Eq_62608 * dwArg0C, Eq_4 dwArg10)
{
	byte bLoc38_1037 = (byte) dwLoc38;
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 eax_18 = gs->ptr0000->tFFFFFFFC;
	if (dwArg04 == 0x1B)
	{
		runtime.sigprof(gs, dwLoc40, dwArg0C->t004C, dwArg0C->t0030, null, dwArg10, *((word32) eax_18 + 24));
		return;
	}
	ui32 ecx_66;
	if (dwArg04 < 0x41)
		ecx_66 = (ui32) g_a8144820[dwArg04];
	else
		ecx_66 = 0x04;
	Eq_4 ebp_73 = *((word32) dwArg08 + 8);
	if (ebp_73 != 0x00 && (ecx_66 & 0x08) != 0x00)
	{
		*((word32) dwArg10 + 0x008C) = dwArg04;
		*((word32) dwArg10 + 0x009C) = *((word32) dwArg08 + 8);
		*((word32) dwArg10 + 0x00A0) = *((word32) dwArg08 + 0x0C);
		*((word32) dwArg10 + 0x00A4) = dwArg0C->t004C;
		runtime.(*sigctxt).preparePanic(gs, fp - 0x08);
		return;
	}
	if (ebp_73 == 0x00 || (ecx_66 & 0x01) != 0x00)
	{
		runtime.sigsend(gs, dwLoc40, dwArg04, dwLoc38);
		if (bLoc38_1037 != 0x00)
			return;
	}
	if (*((word32) dwArg08 + 8) == 0x00)
	{
		runtime.signal_ignored(gs, dwArg04);
		if (bLoc38_1037 != 0x00)
			return;
	}
	if ((ecx_66 & 0x02) != 0x00)
		esi = runtime.dieFromSignal(gs, dwArg04);
	if ((ecx_66 & 0x04) == 0x00)
		return;
	((word32) *((word32) eax_18 + 24) + 0x006C)->u0 = 0x01;
	*((word32) *((word32) eax_18 + 24) + 88) = dwArg10;
	word24 ebx_24_8_256 = SLICE(dwArg10, word24, 8);
	if (runtime.crashing == 0x00)
		runtime.startpanic();
	if (dwArg04 < 0x41)
	{
		runtime.printlock(gs);
		runtime.printstring(gs);
		runtime.printstring(gs);
		runtime.printunlock(gs);
	}
	else
	{
		runtime.printlock(gs);
		runtime.printstring(gs);
		runtime.printint(ebx_24_8_256, gs, (uint64) dwArg04);
		runtime.printstring(gs);
		runtime.printunlock(gs);
	}
	Eq_4 ecx_333 = *((word32) *((word32) eax_18 + 24) + 100);
	Eq_4 edx_335 = dwArg0C->t004C;
	Eq_4 ebx_337 = *((word32) dwArg08 + 8);
	runtime.printlock(gs);
	runtime.printstring(gs);
	word32 esi_1128;
	word24 ebx_24_8_395 = SLICE(runtime.printhex(esi, gs, edx_335, 0x00, out esi_1128), word24, 8);
	runtime.printstring(gs);
	runtime.printint(ebx_24_8_395, gs, SEQ(ecx_333 >> 0x1F, ecx_333));
	runtime.printstring(gs);
	runtime.printint(ebx_24_8_395, gs, (uint64) ebx_337);
	runtime.printstring(gs);
	runtime.printunlock(gs);
	Eq_4 ecx_441 = *((word32) eax_18 + 24);
	if (*((word32) ecx_441 + 188) != 0x00 && (*((word32) ecx_441 + 0x00A0) > 0x00 && dwArg10 == *ecx_441))
	{
		runtime.printlock(gs);
		runtime.printstring(gs);
		runtime.printunlock(gs);
	}
	runtime.printlock(gs);
	runtime.printstring(gs);
	runtime.printunlock(gs);
	runtime.gotraceback(dwLoc40);
	Eq_4 esp_511 = <invalid>;
	word32 ecx_1126 = (word32) *((word32) esp_511 + 5);
	byte cl_520 = (byte) ecx_1126;
	if (*esp_511 <= 0x00)
	{
l0807BCB0:
		if ((byte) ecx_1126 != 0x00)
		{
			int32 eax_679 = runtime.crashing;
			runtime.crashing = eax_679 + 0x01;
			if (eax_679 + 0x01 < g_t8145400 - runtime.extraMCount)
			{
				runtime.printlock(gs);
				runtime.printstring(gs);
				runtime.printunlock(gs);
				runtime.raiseproc();
				word32 edi_1127;
				runtime.usleep(out edi_1127);
			}
			runtime.crash(gs);
		}
		runtime.exit();
		return;
	}
	Eq_4 edx_560;
	*((word32) esp_511 + 23) = cl_520;
	*esp_511 = *((word32) esp_511 + 76);
	Eq_4 esi_530 = runtime.goroutineheader(gs, *esp_511);
	Eq_4 eax_536 = *((word32) esp_511 + 56);
	Eq_4 eax_542 = *((word32) eax_536 + 48);
	*esp_511 = *((word32) eax_536 + 76);
	*((word32) esp_511 + 4) = eax_542;
	((word32) esp_511 + 8)->u0 = 0x00;
	*((word32) esp_511 + 0x0C) = *((word32) esp_511 + 76);
	runtime.tracebacktrap(gs, *((word32) esp_511 + 8), *((word32) esp_511 + 0x0C));
	if (runtime.crashing > 0x00)
	{
		Eq_4 ecx_563 = *((word32) *((word32) *((word32) esp_511 + 44) + 24) + 84);
		edx_560 = *((word32) esp_511 + 76);
		if (edx_560 != ecx_563 && ecx_563 != 0x00)
		{
			*esp_511 = ecx_563;
			runtime.readgstatus(*esp_511);
			esp_511.u0 = <invalid>;
			if ((*((byte) esp_511.u0 + 4) & ~0x1000) == 0x02)
			{
				*esp_511.u0 = *((word32) *((word32) *((byte) esp_511.u0 + 44) + 24) + 84);
				esi_530 = runtime.goroutineheader(gs, *esp_511.u0);
				*((byte) esp_511.u0 + 0x0C) = *((word32) *((word32) *((byte) esp_511.u0 + 44) + 24) + 84);
				esp_511.u0->u0 = ~0x00;
				((byte) esp_511.u0 + 4)->u0 = ~0x00;
				((byte) esp_511.u0 + 8)->u0 = 0x00;
				runtime.traceback(gs);
l0807BD8B:
				*esp_511.u0 = (byte) esp_511.u0 + 52;
				runtime.dumpregs(esi_530, gs, *esp_511.u0);
				ecx_1126 = (word32) *((byte) esp_511.u0 + 23);
				goto l0807BCB0;
			}
			edx_560 = *((byte) esp_511.u0 + 76);
		}
	}
	else
		edx_560 = *((word32) esp_511 + 76);
	if (runtime.crashing == 0x00)
	{
		*esp_511.u0 = edx_560;
		esi_530 = runtime.tracebackothers(esi_530, gs, *esp_511.u0);
		runtime.printlock(gs);
		esp_511.u0->u0 = 0x080E0D9C;
		((byte) esp_511.u0 + 4)->u0 = 0x01;
		runtime.printstring(gs);
		runtime.printunlock(gs);
	}
	goto l0807BD8B;
}

// 0807BFD0: void os.sigpipe(Register (ptr32 Eq_2) gs)
// Called from:
//      os.epipecheck
void os.sigpipe(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	word32 ebp_41;
	word32 edi_42;
	runtime.systemstack(gs, 0x080E7CC4, out ebp_41, out edi_42);
}

// 0807C000: void runtime.init.4(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.init
void runtime.init.4(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
}

// 0807C020: void runtime.initsig(Register (ptr32 Eq_2) gs, Stack byte bArg04)
// Called from:
//      runtime.mstart1
void runtime.initsig(struct Eq_2 * gs, byte bArg04)
{
	if (bArg04 == 0x00)
		g_b8157575 = 0x01;
	if ((g_b8157570 != 0x00 || g_b8157572 != 0x00) && bArg04 == 0x00)
		return;
	uint32 eax_138 = 0x00;
	while (true)
	{
		byte bLoc10_163 = (byte) dwLoc10;
		if (eax_138 >= 0x41)
			break;
		ui32 ecx_49 = g_a8144820[eax_138];
		if (ecx_49 != 0x00 && (ecx_49 & 0x10) == 0x00)
		{
			runtime.getsig(gs);
			g_a8157940[eax_138 * 0x04] = dwLoc10;
			runtime.sigInstallGoHandler(gs, eax_138);
			if (bLoc10_163 == 0x00)
			{
				word32 edx_116 = g_a8157940[eax_138 * 0x04];
				if (edx_116 != 0x00 && edx_116 != 0x01)
					runtime.setsigstack();
			}
			else
			{
				g_a8157A60[eax_138 * 0x04] = 0x01;
				word32 ebp_99 = g_dw80E7CBC;
				runtime.setsig(ebp_99);
				dwLoc10 = ebp_99;
			}
		}
		++eax_138;
	}
}

// 0807C150: void runtime.sigInstallGoHandler(Register (ptr32 Eq_2) gs, Stack uint32 dwArg04)
// Called from:
//      runtime.initsig
void runtime.sigInstallGoHandler(struct Eq_2 * gs, uint32 dwArg04)
{
	if (dwArg04 <= 0x02)
	{
		if (dwArg04 >= 0x41)
			runtime.panicindex(gs);
		runtime/internal/atomic.Loaduintptr();
		if (dwLoc04 == 0x01)
			return;
	}
	if (dwArg04 >= 0x41)
		runtime.panicindex(gs);
	else
	{
		ui32 ecx_31 = g_a8144820[dwArg04];
		if ((ecx_31 & 0x40) != 0x00)
			return;
		if (g_b8157570 == 0x00 && g_b8157572 == 0x00 || ((ecx_31 & 0x08) != 0x00 || dwArg04 == 0x0D))
			;
	}
}

// 0807C200: void runtime.setThreadCPUProfiler(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      runtime.execute
void runtime.setThreadCPUProfiler(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (dwArg04 == 0x00)
		runtime.setitimer();
	else
		runtime.setitimer();
	*((word32) *((word32) gs->ptr0000->tFFFFFFFC + 24) + 0x0084) = dwArg04;
}

// 0807C2E0: void runtime.sigpipe(Register (ptr32 Eq_2) gs)
void runtime.sigpipe(struct Eq_2 * gs)
{
	byte bLoc04_84 = (byte) dwLoc04;
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.sigsend(gs, dwLoc0C, 0x0D, dwLoc04);
	if (bLoc04_84 != 0x00)
		return;
	runtime.dieFromSignal(gs, 0x0D);
}

// 0807C330: void runtime.sigtrampgo(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg00, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack (ptr32 Eq_62608) dwArg0C)
// Called from:
//      runtime.cgoSigtramp
void runtime.sigtrampgo(struct Eq_2 * gs, Eq_4 dwArg00, Eq_4 dwArg04, Eq_4 dwArg08, struct Eq_62608 * dwArg0C)
{
	fn0808FD8A(0x00, fp - 0x18);
	runtime.sigfwdgo(gs, dwArg00, dwArg04, dwArg08, dwLoc50);
	if (bLoc4C != 0x00)
		return;
	Eq_4 ecx_39 = gs->ptr0000->tFFFFFFFC;
	if (ecx_39 == 0x00)
	{
		if (dwArg04 != 0x1B)
			runtime.badsignal(gs, dwArg04, fp - 0x20);
		else
			runtime.sigprofNonGoPC(gs);
	}
	else
	{
		byte al_294;
		fn0808FD8B(0x00, fp - 0x40);
		Eq_4 edx_101 = *((word32) ecx_39 + 24);
		Eq_4 ebx_102 = *((word32) edx_101 + 44);
		if (fp + 0x04 < *ebx_102 || fp + 0x04 >= *((word32) ebx_102 + 4))
		{
			struct Eq_63333 * eax_118 = *edx_101;
			if (fp + 0x04 >= eax_118->ptr0000 && fp + 0x04 < eax_118->ptr0004)
			{
				Eq_4 eax_253 = gs->ptr0000->tFFFFFFFC;
				struct Eq_63358 * eax_240 = **((word32) ecx_39 + 24);
				Eq_4 edx_255 = *((word32) *((word32) eax_253 + 24) + 44);
				word32 edx_243 = eax_240->dw0004 - eax_240->dw0000;
				ptr32 eax_250 = ***((word32) ecx_39 + 24);
				dwLoc40 = (word32) *edx_255;
				dwLoc3C = *((word32) edx_255 + 4);
				dwLoc38 = *((word32) *((word32) *((word32) eax_253 + 24) + 44) + 8);
				dwLoc34 = *((word32) *((word32) *((word32) eax_253 + 24) + 44) + 0x0C);
				dwLoc30 = *((word32) *((word32) *((word32) eax_253 + 24) + 44) + 64);
				**((word32) *((word32) eax_253 + 24) + 44) = eax_250;
				*((word32) *((word32) *((word32) eax_253 + 24) + 44) + 4) = edx_243 + eax_250;
				*((word32) *((word32) *((word32) eax_253 + 24) + 44) + 8) = eax_250 + 880;
				*((word32) *((word32) *((word32) eax_253 + 24) + 44) + 0x0C) = eax_250 + 880;
				*((word32) *((word32) *((word32) ecx_39 + 24) + 44) + 64) = fp + 0x04;
			}
			else
			{
				runtime.sigaltstack();
				if (fp < 0x04 || fp >= 0x04)
				{
					runtime.setg(gs, 0x00);
					runtime.sigNotOnStack(SLICE(runtime.needm(gs), word24, 8), gs, dwArg04);
				}
				Eq_4 eax_194 = gs->ptr0000->tFFFFFFFC;
				Eq_4 edx_196 = *((word32) *((word32) eax_194 + 24) + 44);
				dwLoc40 = (word32) *edx_196;
				dwLoc3C = *((word32) edx_196 + 4);
				dwLoc38 = *((word32) *((word32) *((word32) eax_194 + 24) + 44) + 8);
				dwLoc34 = *((word32) *((word32) *((word32) eax_194 + 24) + 44) + 0x0C);
				dwLoc30 = *((word32) *((word32) *((word32) eax_194 + 24) + 44) + 64);
				**((word32) *((word32) eax_194 + 24) + 44) = 0x00;
				((word32) *((word32) *((word32) eax_194 + 24) + 44) + 4)->u0 = 0x00;
				((word32) *((word32) *((word32) eax_194 + 24) + 44) + 8)->u0 = 880;
				((word32) *((word32) *((word32) eax_194 + 24) + 44) + 0x0C)->u0 = 880;
				*((word32) *((word32) *((word32) ecx_39 + 24) + 44) + 64) = fp + 0x04;
			}
			al_294 = 0x01;
		}
		else
			al_294 = 0x00;
		word24 ebx_24_8_315 = SLICE(runtime.setg(gs, *((word32) *((word32) ecx_39 + 24) + 44)), word24, 8);
		if (*((word32) ecx_39 + 8) == ~0x04D1)
			runtime.signalDuringFork(ebx_24_8_315, gs, dwArg04);
		else
		{
			runtime.sighandler(fp + 0x04, gs, dwArg04, dwArg08, dwArg0C, ecx_39);
			runtime.setg(gs, ecx_39);
			if (al_294 != 0x00)
			{
				Eq_4 eax_361 = *((word32) *((word32) gs->ptr0000->tFFFFFFFC + 24) + 44);
				*eax_361 = dwLoc40;
				*((word32) eax_361 + 4) = dwLoc3C;
				*((word32) eax_361 + 8) = dwLoc38;
				*((word32) eax_361 + 0x0C) = dwLoc34;
				*((word32) eax_361 + 64) = dwLoc30;
			}
		}
	}
}

// 0807C6D0: void runtime.sigpanic(Register Eq_4 esi, Register (ptr32 Eq_2) gs)
void runtime.sigpanic(Eq_4 esi, struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 eax_19 = gs->ptr0000->tFFFFFFFC;
	runtime.canpanic(gs, eax_19);
	if (bLoc1C == 0x00)
		runtime.throw(gs);
	else
	{
		Eq_4 ecx_45 = *((word32) eax_19 + 0x008C);
		if (ecx_45 != 0x07)
		{
			if (ecx_45 != 0x08)
			{
				if (ecx_45 != 11)
				{
					if (*((word32) eax_19 + 0x008C) >= 0x41)
						runtime.throw(gs);
					else
					{
						runtime.convT2Estring(gs, 0x080D1E80, fp - 0x08);
						runtime.gopanic(gs);
					}
				}
				else
				{
					Eq_4 ecx_52 = *((word32) eax_19 + 0x009C);
					if (ecx_52 != 0x00 && (ecx_52 != 0x01 && ecx_52 != 0x02) || *((word32) eax_19 + 0x00A0) >= 0x1000)
					{
						if (*((word32) eax_19 + 0x006D) == 0x00)
						{
							Eq_4 eax_77 = *((word32) eax_19 + 0x00A0);
							runtime.printlock(gs);
							runtime.printstring(gs);
							word32 esi_307;
							runtime.printhex(esi, gs, eax_77, 0x00, out esi_307);
							runtime.printstring(gs);
							runtime.printunlock(gs);
							runtime.throw(gs);
						}
						else
							runtime.panicmem(gs);
					}
					else
						runtime.panicmem(gs);
				}
			}
			else
			{
				Eq_4 ecx_139 = *((word32) eax_19 + 0x009C);
				if (ecx_139 == 0x01)
					runtime.panicdivide(gs);
				else if (ecx_139 == 0x02)
					runtime.panicoverflow(gs);
				else
					runtime.panicfloat(gs);
			}
		}
		else if (*((word32) eax_19 + 0x009C) != 0x02 || *((word32) eax_19 + 0x00A0) >= 0x1000)
		{
			if (*((word32) eax_19 + 0x006D) == 0x00)
			{
				Eq_4 eax_206 = *((word32) eax_19 + 0x00A0);
				runtime.printlock(gs);
				runtime.printstring(gs);
				word32 esi_306;
				runtime.printhex(esi, gs, eax_206, 0x00, out esi_306);
				runtime.printstring(gs);
				runtime.printunlock(gs);
				runtime.throw(gs);
			}
			else
				runtime.panicmem(gs);
		}
		else
			runtime.panicmem(gs);
	}
}

// 0807C940: Register word32 runtime.dieFromSignal(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      runtime.sighandler
//      runtime.sigpipe
//      runtime.crash
//      runtime.sigfwdgo
word32 runtime.dieFromSignal(struct Eq_2 * gs, Eq_4 dwArg04)
{
	runtime.setsig(0x00);
	word32 esi_28 = runtime.unblocksig(gs, dwArg04);
	runtime.raise();
	runtime.osyield();
	runtime.osyield();
	runtime.osyield();
	runtime.exit();
	return esi_28;
}

// 0807C990: void runtime.raisebadsignal(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack (ptr32 (ptr32 Eq_63875)) dwArg08)
// Called from:
//      runtime.badsignal
void runtime.raisebadsignal(struct Eq_2 * gs, Eq_4 dwArg04, struct Eq_63875 ** dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (dwArg04 == 0x1B)
		return;
	word32 ecx_28;
	if (dwArg04 >= 0x41)
		ecx_28 = 0x00;
	else
	{
		runtime/internal/atomic.Loaduintptr();
		ecx_28 = dwLoc10;
	}
	runtime.unblocksig(gs, dwArg04);
	runtime.setsig(ecx_28);
	if ((g_b8157570 != 0x00 || g_b8157572 != 0x00) && (ecx_28 == 0x00 && *((char *) (*dwArg08) + 8) != 0x00))
		return;
	runtime.raise();
	word32 edi_207;
	runtime.usleep(out edi_207);
	runtime.setsig(g_dw80E7CBC);
}

// 0807CA90: void runtime.crash(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.dopanic_m
//      runtime.sighandler
void runtime.crash(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.dieFromSignal(gs, 0x06);
}

// 0807CAC0: void runtime.noSignalStack(Register word24 ebx_24_8, Register (ptr32 Eq_2) gs, Stack word32 dwArg04)
// Called from:
//      runtime.sigtrampgo
void runtime.noSignalStack(word24 ebx_24_8, struct Eq_2 * gs, word32 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.printlock(gs);
	runtime.printstring(gs);
	runtime.printsp(gs);
	runtime.printint(ebx_24_8, gs, (uint64) dwArg04);
	runtime.printsp(gs);
	runtime.printstring(gs);
	runtime.printnl(gs);
	runtime.printunlock(gs);
	runtime.throw(gs);
}

// 0807CB50: void runtime.sigNotOnStack(Register word24 ebx_24_8, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      runtime.sigtrampgo
void runtime.sigNotOnStack(word24 ebx_24_8, struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.printlock(gs);
	runtime.printstring(gs);
	runtime.printsp(gs);
	runtime.printint(ebx_24_8, gs, (uint64) dwArg04);
	runtime.printsp(gs);
	runtime.printstring(gs);
	runtime.printnl(gs);
	runtime.printunlock(gs);
	runtime.throw(gs);
}

// 0807CBE0: void runtime.signalDuringFork(Register word24 ebx_24_8, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      runtime.sigtrampgo
void runtime.signalDuringFork(word24 ebx_24_8, struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.printlock(gs);
	runtime.printstring(gs);
	runtime.printsp(gs);
	runtime.printint(ebx_24_8, gs, (uint64) dwArg04);
	runtime.printsp(gs);
	runtime.printstring(gs);
	runtime.printnl(gs);
	runtime.printunlock(gs);
	runtime.throw(gs);
}

// 0807CC70: void runtime.badsignal(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack (ptr32 (ptr32 Eq_63875)) dwArg08)
// Called from:
//      runtime.sigtrampgo
void runtime.badsignal(struct Eq_2 * gs, Eq_4 dwArg04, struct Eq_63875 ** dwArg08)
{
	byte bLoc04_77 = (byte) dwLoc04;
	runtime.needm(gs);
	runtime.sigsend(gs, dwLoc0C, dwArg04, dwLoc04);
	if (bLoc04_77 == 0x00)
		runtime.raisebadsignal(gs, dwArg04, dwArg08);
	runtime.dropm(gs);
}

// 0807CCB0: void runtime.sigfwdgo(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C, Stack Eq_4 dwArg10)
// Called from:
//      runtime.sigtrampgo
void runtime.sigfwdgo(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C, Eq_4 dwArg10)
{
	if (dwArg04 >= 0x41)
		return;
	runtime/internal/atomic.Loaduintptr();
	if (g_b8157575 == 0x00)
	{
		if (dwLoc18 == null)
			runtime.dieFromSignal(gs, dwArg04);
		else
			runtime.sigfwd(dwLoc18, dwArg04, dwArg08, dwArg0C);
	}
	else
	{
		if (dwLoc18 == null)
			return;
		runtime/internal/atomic.Load();
		if (dwLoc14 == 0x00)
			runtime.sigfwd(dwLoc08, dwArg08, dwArg0C, dwArg10);
		else
		{
			ui32 ecx_99 = g_a8144820[dwArg08];
			if ((*((word32) dwArg0C + 8) == 0x00 || (ecx_99 & 0x08) == 0x00) && dwArg08 != 0x0D)
				return;
			Eq_4 ecx_124 = gs->ptr0000->tFFFFFFFC;
			if (ecx_124 != 0x00)
			{
				Eq_4 ecx_128 = *((word32) ecx_124 + 24);
				if (ecx_128 != 0x00 && (*((word32) ecx_128 + 84) != 0x00 && *((word32) ecx_128 + 0x0091) == 0x00))
					return;
			}
			if (dwLoc08 != (<anonymous> *) 0x01)
				runtime.sigfwd(dwLoc08, dwArg08, dwArg0C, dwArg10);
		}
	}
}

// 0807CE30: void runtime.msigsave()
// Called from:
//      runtime.schedinit
//      runtime.needm
void runtime.msigsave()
{
	runtime.sigprocmask();
}

// 0807CE60: void runtime.msigrestore()
// Called from:
//      runtime.dropm
void runtime.msigrestore()
{
	runtime.sigprocmask();
}

// 0807CE90: void runtime.sigblock()
// Called from:
//      runtime.needm
//      runtime.dropm
void runtime.sigblock()
{
	runtime.sigprocmask();
}

// 0807CEC0: Register word32 runtime.unblocksig(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      runtime.dieFromSignal
//      runtime.raisebadsignal
word32 runtime.unblocksig(struct Eq_2 * gs, Eq_4 dwArg04)
{
	Eq_64097 edx_11 = (word32) dwArg04 + (((dwArg04 - 0x01 >> 0x1F) >> 0x1B) - 0x01);
	if (edx_11 >> 0x05 >= 0x02)
		runtime.panicindex(gs);
	else
	{
		(fp - 0x08)[edx_11 >> 0x05] |= 0x01 << (byte) dwArg04 - 0x01;
		return runtime.sigprocmask();
	}
}

// 0807CF30: void runtime.minitSignals(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.minit
void runtime.minitSignals(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.minitSignalStack(gs);
	runtime.minitSignalMask(gs);
}

// 0807CF60: void runtime.minitSignalStack(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.minitSignals
void runtime.minitSignalStack(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 eax_19 = gs->ptr0000->tFFFFFFFC;
	runtime.sigaltstack();
	Eq_4 eax_59 = gs->ptr0000->tFFFFFFFC;
	**((word32) *((word32) eax_59 + 24) + 44) = 0x00;
	((word32) *((word32) *((word32) eax_59 + 24) + 44) + 4)->u0 = 0x00;
	((word32) *((word32) *((word32) eax_59 + 24) + 44) + 8)->u0 = 880;
	((word32) *((word32) *((word32) eax_59 + 24) + 44) + 0x0C)->u0 = 880;
	*((word32) *((word32) eax_19 + 24) + 0x008F) = 0x00;
}

// 0807D050: void runtime.minitSignalMask(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.minitSignals
void runtime.minitSignalMask(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_64237 eax_24 = 0x00;
	while (eax_24 < 0x41)
	{
		if (eax_24 >= 0x41)
			runtime.panicindex(gs);
		if ((g_a8144820[eax_24] & 0x80) != 0x00)
		{
			Eq_64254 edx_59 = (word32) eax_24 + (((eax_24 - 0x01 >> 0x1F) >> 0x1B) - 0x01);
			if (edx_59 >> 0x05 >= 0x02)
				runtime.panicindex(gs);
			(fp - 0x08)[edx_59 >> 0x05] = ~(0x01 << (byte) eax_24 - 0x01) & (fp - 0x08)[edx_59 >> 0x05];
		}
		eax_24 = (word32) eax_24 + 1;
	}
	runtime.sigprocmask();
}

// 0807D120: void runtime.unminitSignals(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.unminit
void runtime.unminitSignals(struct Eq_2 * gs)
{
	if (*((word32) *((word32) gs->ptr0000->tFFFFFFFC + 24) + 0x008F) != 0x00)
		runtime.sigaltstack();
}

// 0807D170: void runtime.signalstack()
// Called from:
//      runtime.minitSignalStack
void runtime.signalstack()
{
	runtime.sigaltstack();
}

// 0807D1C0: void runtime.sigsend(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg00, Stack Eq_4 dwArg04, Stack Eq_62611 bArg08)
// Called from:
//      runtime.sighandler
//      runtime.sigpipe
//      runtime.badsignal
void runtime.sigsend(struct Eq_2 * gs, Eq_4 dwArg00, Eq_4 dwArg04, Eq_62611 bArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (g_b8157798 == 0x00 || dwArg04 >= 0x60)
		return;
	if (dwArg04 >> 0x05 >= 0x03)
		runtime.panicindex(gs);
	else
	{
		runtime/internal/atomic.Load();
		ui32 eax_37 = 0x01 << (byte) dwArg08;
		if ((dwLoc10 & eax_37) == 0x00)
			return;
		do
		{
			Eq_4 ebx_50 = *((char *) g_a8157764 + dwArg00 * 0x04);
			Eq_4 edx_51 = dwArg00 * 0x04 + 135624548;
			if ((ebx_50 & eax_37) != 0x00)
				return;
			Eq_4 ebx_61 = ebx_50 | eax_37;
			runtime/internal/atomic.Cas(edx_51, ebx_50, ebx_61);
			Eq_4 dwLoc14_157 = edx_51;
			byte bLoc0C_226 = (byte) ebx_61;
		} while (bLoc08 == 0x00);
		do
		{
			runtime/internal/atomic.Load();
			if (dwLoc14_157 != 0x00)
			{
				if (dwLoc14_157 != 0x01)
				{
					if (dwLoc14_157 == 0x02)
						return;
					runtime.throw(gs);
				}
				else
				{
					runtime/internal/atomic.Cas(135624596, 0x01, 0x00);
					dwLoc14_157.u0 = 0x01;
					if (bLoc0C_226 == 0x00)
						continue;
					runtime.notewakeup(gs, 135624544);
					return;
				}
			}
			runtime/internal/atomic.Cas(135624596, 0x00, 0x02);
			dwLoc14_157.u0 = 0x00;
		} while (bLoc0C_226 == 0x00);
	}
}

// 0807D340: void runtime.signal_ignored(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      runtime.sighandler
void runtime.signal_ignored(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (dwArg04 >> 0x05 >= 0x03)
		runtime.panicindex(gs);
	else
		runtime/internal/atomic.Load();
}

// 0807D3A0: Register word32 runtime.makeslice(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C, Register out ptr32 ediOut)
// Called from:
//      runtime.panicwrap
//      runtime.goargs
//      runtime.goenvs_unix
//      strconv.(*decimal).String
//      sync.(*Pool).pinSlow
//      syscall.ByteSliceFromString
//      os.Readlink
//      reflect.newName
//      reflect.(*rtype).exportedMethods
//      reflect.(*rtype).Method
//      reflect.Value.MapKeys
//      fmt.(*fmt).writePadding
//      fmt.(*fmt).fmt_unicode
//      fmt.(*fmt).fmt_integer
//      fmt.(*pp).printValue
word32 runtime.makeslice(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C, ptr32 & ediOut)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 eax_26;
	Eq_64428 edx_18 = *dwArg04;
	if (edx_18 < 33)
		eax_26 = *((char *) g_a81386E0 + edx_18 * 0x04);
	else
		eax_26 = (uint32) (0xFFFFFFFF /u edx_18);
	if (dwArg08 < 0x00 || dwArg08 > eax_26)
		runtime.gopanic(gs);
	else if (dwArg0C < dwArg08 || dwArg0C > eax_26)
		runtime.gopanic(gs);
	else
	{
		word32 esi_138;
		word32 ebx_91;
		ptr32 edi_93;
		runtime.mallocgc(dwArg08, gs, edx_18 *s dwArg0C, dwArg04, 0x01, out ebx_91, out esi_138, out edi_93);
		ediOut = edi_93;
		return ebx_91;
	}
}

// 0807D470: Register Eq_4 runtime.growslice(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C, Stack Eq_4 dwArg10, Stack Eq_4 dwArg14, Register out Eq_4 esiOut, Register out Eq_1856 xmm0Out, Register out Eq_1857 xmm1Out)
// Called from:
//      runtime.cgocallbackg1
//      runtime.(*hmap).newoverflow
//      runtime.recordspan
//      runtime.freedefer
//      runtime.acquireSudog
//      runtime.releaseSudog
//      runtime.allgadd
//      runtime.(*randomOrder).reset
//      syscall.runtime_envs
//      os.runtime_args
//      reflect.typelinks
//      runtime.expandCgoFrames
//      runtime.modulesinit
//      runtime.typelinksinit
//      runtime.newdefer.func1
//      strconv.genericFtoa
//      strconv.formatDigits
//      strconv.fmtE
//      strconv.fmtF
//      strconv.fmtB
//      strconv.formatBits
//      strconv.appendQuotedWith
//      strconv.appendQuotedRuneWith
//      strconv.appendEscapedRune
//      sync.(*Pool).Put
//      sync.(*Pool).pinSlow
//      reflect.(*rtype).exportedMethods
//      reflect.(*rtype).Method
//      reflect.(*structType).FieldByNameFunc
//      reflect.typesByString
//      reflect.FuncOf
//      reflect.funcStr
//      reflect.funcLayout
//      reflect.addTypeBits
//      reflect.FuncOf.func1
//      fmt.(*fmt).pad
//      fmt.(*fmt).padString
//      fmt.(*fmt).fmt_sbx
//      fmt.(*fmt).fmt_float
//      fmt.(*buffer).WriteRune
//      fmt.(*pp).Write
//      fmt.(*pp).unknownType
//      fmt.(*pp).badVerb
//      fmt.(*pp).fmtComplex
//      fmt.(*pp).fmtBytes
//      fmt.(*pp).fmtPointer
//      fmt.(*pp).catchPanic
//      fmt.(*pp).printValue
//      fmt.(*pp).doPrintln
Eq_4 runtime.growslice(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C, Eq_4 dwArg10, Eq_4 dwArg14, union Eq_4 & esiOut, union Eq_1856 & xmm0Out, union Eq_1857 & xmm1Out)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 edx_18 = *dwArg04;
	if (edx_18 == 0x00)
	{
		if (dwArg14 < dwArg10)
			runtime.gopanic(gs);
		else
		{
			esiOut = esi;
			xmm0Out = xmm0;
			xmm1Out = xmm1;
			return ebp;
		}
	}
	Eq_4 ebx_152 = dwArg10;
	Eq_4 esi_206 = dwArg14;
	if (dwArg14 <= dwArg10 * 0x02)
	{
		if (dwArg0C >= 0x0400)
		{
			while (ebx_152 < dwArg14)
				ebx_152 = (ebx_152 + ((ebx_152 >> 0x1F) >>u 0x1E) >> 0x02) + ebx_152;
		}
		else
			ebx_152 = dwArg10 * 0x02;
	}
	else
		ebx_152 = dwArg14;
	Eq_4 dwLoc18_498;
	Eq_4 edi_204 = dwArg0C;
	if (edx_18 == 0x01)
	{
		if (ebx_152 >= 0x8000)
		{
			if ((word32) ebx_152 + 0x00002000 >= ebx_152)
				ebx_152 = (word32) ebx_152 + 0x00001FFF & ~0x1FFF;
			goto l0807D52C;
		}
		if (ebx_152 > 1016)
		{
			Eq_64510 ebx_225 = (word32) ebx_152 - 897;
			if (ebx_225 >> 0x07 < 0xF9)
			{
				uint32 ebx_230 = (word32) (ebx_225 >> 0x07)->b81396E0;
				if (ebx_230 < 0x43)
				{
					ebx_152 = (word32) g_a8138820[ebx_230 * 0x02];
l0807D52C:
					dwLoc18_498 = ebx_152;
					goto l0807D532;
				}
			}
			runtime.panicindex(gs);
		}
		else
		{
			Eq_64517 ebx_241 = (word32) ebx_152 + 7;
			if (ebx_241 >> 0x03 < 0x81)
			{
				uint32 ebx_246 = (word32) (ebx_241 >> 0x03)->b8138640;
				if (ebx_246 < 0x43)
				{
					ebx_152 = (word32) g_a8138820[ebx_246 * 0x02];
					goto l0807D52C;
				}
			}
			runtime.panicindex(gs);
		}
	}
	if (edx_18 == 0x04)
	{
		Eq_4 ebx_155 = ebx_152 << 0x02;
		if (ebx_155 >= 0x8000)
		{
			if ((word32) ebx_155 + 0x00002000 >= ebx_155)
				ebx_155 = (word32) ebx_155 + 0x00001FFF & ~0x1FFF;
			goto l0807D72A;
		}
		if (ebx_155 > 1016)
		{
			struct Eq_64666 * ebx_168 = (word32) ebx_155 - 897 >> 0x07;
			if (ebx_168 < (struct Eq_64666 *) 0xF9)
			{
				uint32 ebx_172 = (word32) ebx_168->b81396E0;
				if (ebx_172 < 0x43)
				{
					ebx_155 = (word32) g_a8138820[ebx_172 * 0x02];
l0807D72A:
					edi_204 = dwArg0C << 0x02;
					esi_206 = dwArg14 << 0x02;
					ebx_152 = ebx_155 >> 0x02;
					dwLoc18_498 = ebx_155;
					goto l0807D532;
				}
			}
			runtime.panicindex(gs);
		}
		else
		{
			struct Eq_64673 * ebx_184 = (word32) ebx_155 + 7 >> 0x03;
			if (ebx_184 < (struct Eq_64673 *) 0x81)
			{
				uint32 ebx_188 = (word32) ebx_184->b8138640;
				if (ebx_188 < 0x43)
				{
					ebx_155 = (word32) g_a8138820[ebx_188 * 0x02];
					goto l0807D72A;
				}
			}
			runtime.panicindex(gs);
		}
	}
	edi_204 = dwArg0C *s edx_18;
	esi_206 = dwArg14 *s edx_18;
	Eq_4 ebx_114 = ebx_152 *s edx_18;
	if (ebx_114 >= 0x8000)
	{
		if ((word32) ebx_114 + 0x00002000 >= ebx_114)
			ebx_114 = (word32) ebx_114 + 0x00001FFF & ~0x1FFF;
		goto l0807D7E8;
	}
	if (ebx_114 > 1016)
	{
		struct Eq_64724 * ebx_95 = (word32) ebx_114 - 897 >> 0x07;
		if (ebx_95 < (struct Eq_64724 *) 0xF9)
		{
			uint32 ebx_101 = (word32) ebx_95->b81396E0;
			if (ebx_101 < 0x43)
			{
				ebx_114 = (word32) g_a8138820[ebx_101 * 0x02];
l0807D7E8:
				dwLoc18_498 = ebx_114;
				ebx_152 = (uint32) ((uint64) ebx_114 /u edx_18);
l0807D532:
				Eq_4 ebp_342 = dwArg0C;
				Eq_4 esi_267 = dwArg14;
				if (dwArg14 >= dwArg10)
				{
					Eq_4 eax_283;
					if (edx_18 < 33)
						eax_283 = *((char *) g_a81386E0 + edx_18 * 0x04);
					else
					{
						esi_267 = edx_18;
						eax_283 = (uint32) (0xFFFFFFFF /u edx_18);
					}
					if (ebx_152 <= eax_283)
					{
						if ((*((word32) dwArg04 + 0x0F) & 0x80) == 0x00)
						{
							word32 edi_878;
							word32 esi_877;
							word32 ebx_876;
							runtime.mallocgc(ebx_152, gs, dwLoc18_498, dwArg04, 0x01, out ebx_876, out esi_877, out edi_878);
							if (g_t81576F0 != 0x00)
							{
								Eq_4 ecx_416;
								for (ecx_416 = 0x00; ecx_416 < edi_204; ecx_416 += Mem436[dwArg04 + 0x00:word32])
								{
									esi_267 = dwArg08 + ecx_416;
									word128 xmm1_884;
									word128 xmm0_883;
									word32 edi_882;
									word32 esi_881;
									runtime.typedmemmove(dwArg04, dwLoc30 + ecx_416, esi_267, out esi_881, out edi_882, out xmm0_883, out xmm1_884);
									ebp_342 = dwArg08;
								}
							}
							else
							{
								word128 xmm2_880;
								word32 edi_879;
								runtime.memmove(dwLoc30, dwArg08, edi_204, out ebp_342, out esi_267, out edi_879, out xmm0, out xmm1, out xmm2_880);
							}
						}
						else
						{
							word32 edi_873;
							word32 esi_872;
							word32 ebx_871;
							runtime.mallocgc(ebx_367, gs, dwLoc18_498, 0x00, 0x00, out ebx_871, out esi_872, out edi_873);
							word128 xmm2_875;
							word32 edi_874;
							runtime.memmove(dwLoc30, dwArg08, edi_204, out ebp_342, out esi_267, out edi_874, out xmm0, out xmm1, out xmm2_875);
							runtime.memclrNoHeapPointers(dwLoc30 + esi_206, dwLoc18_498 - esi_206);
						}
						esiOut = esi_267;
						xmm0Out = xmm0;
						xmm1Out = xmm1;
						return ebp_342;
					}
				}
				runtime.gopanic(gs);
			}
		}
		runtime.panicindex(gs);
	}
	else
	{
		struct Eq_64731 * ebx_116 = (word32) ebx_114 + 7 >> 0x03;
		if (ebx_116 < (struct Eq_64731 *) 0x81)
		{
			uint32 ebx_120 = (word32) ebx_116->b8138640;
			if (ebx_120 < 0x43)
			{
				ebx_114 = (word32) g_a8138820[ebx_120 * 0x02];
				goto l0807D7E8;
			}
		}
		runtime.panicindex(gs);
	}
}

// 0807D900: void runtime.stackinit(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.schedinit
void runtime.stackinit(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_64788 eax_16 = 0x00;
	while (eax_16 < 0x04)
	{
		if (eax_16 >= 0x04)
			runtime.panicindex(gs);
		g_a8145280[eax_16] = (struct Eq_138780) 0x00;
		g_a8145284[eax_16] = (struct Eq_138781) 0x00;
		eax_16 = (word32) eax_16 + 1;
	}
	Eq_64792 eax_22 = 0x00;
	while (eax_22 < 0x13)
	{
		if (eax_22 >= 0x13)
			runtime.panicindex(gs);
		g_a8145344[eax_22] = (struct Eq_138782) 0x00;
		g_a8145348[eax_22] = (struct Eq_138783) 0x00;
		eax_22 = (word32) eax_22 + 1;
	}
}

// 0807D980: void runtime.stacklog2(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      runtime.stackalloc
//      runtime.stackfree
void runtime.stacklog2(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 eax_15;
	for (eax_15 = dwArg04; eax_15 > 0x01; eax_15 >>= 0x01)
		;
}

// 0807D9B0: void runtime.stackpoolalloc(Register (ptr32 Eq_2) gs, Stack cu8 bArg04)
// Called from:
//      runtime.stackcacherefill
//      runtime.stackalloc
void runtime.stackpoolalloc(struct Eq_2 * gs, cu8 bArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	uint32 ecx_19 = (word32) bArg04;
	if (ecx_19 >= 0x04)
		runtime.panicindex(gs);
	else
	{
		Eq_4 eax_114;
		Eq_4 ebx_27 = ecx_19 * 0x08 + 0x08145280;
		Eq_4 ecx_30 = g_a8145280[ecx_19];
		if (ecx_30 == 0x00)
		{
			runtime.(*mheap).allocManual(gs);
			if (dwLoc10 == 0x00)
				runtime.throw(gs);
			if (*((word32) dwLoc10 + 56) != 0x00)
				runtime.throw(gs);
			if (*((word32) dwLoc10 + 20) != 0x00)
				runtime.throw(gs);
			*((word32) dwLoc10 + 64) = 0x0800 << bArg04 & 0x00 - (bArg04 < 0x20);
			up32 ecx_102 = 0x00;
			while (ecx_102 < 0x8000)
			{
				Eq_4 edx_96 = (word32) *((word32) dwLoc10 + 0x0C) + ecx_102;
				*edx_96 = *((word32) dwLoc10 + 20);
				*((word32) dwLoc10 + 20) = edx_96;
				ecx_102 = (word32) *((word32) dwLoc10 + 64) + ecx_102;
			}
			runtime.(*mSpanList).insert(gs, ebx_27, dwLoc10);
			eax_114 = dwLoc10;
		}
		else
			eax_114 = ecx_30;
		Eq_4 ecx_117 = *((word32) eax_114 + 20);
		if (ecx_117 == 0x00)
			runtime.throw(gs);
		else
		{
			*((word32) eax_114 + 20) = *ecx_117;
			*((word32) eax_114 + 56) = (word32) *((word32) eax_114 + 56) + 1;
			if (*((word32) eax_114 + 20) == 0x00)
				runtime.(*mSpanList).remove(gs, ebx_27, eax_114);
		}
	}
}

// 0807DB40: void runtime.stackpoolfree(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack cu8 bArg08)
// Called from:
//      runtime.stackcacherelease
//      runtime.stackcache_clear
//      runtime.stackfree
void runtime.stackpoolfree(struct Eq_2 * gs, Eq_4 dwArg04, cu8 bArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	uint32 ecx_20 = dwArg04 - g_t81493A8;
	Eq_4 ebx_22 = g_t8149108;
	if (ecx_20 >> 0x0D >= g_t814910C)
		runtime.panicindex(gs);
	else
	{
		Eq_4 eax_30 = *((word32) ebx_22 + (ecx_20 >> 0x0D) * 0x04);
		if (*((word32) eax_30 + 60) != 0x02)
			runtime.throw(gs);
		else
		{
			if (*((word32) eax_30 + 20) == 0x00)
			{
				uint32 ebx_49 = (word32) bArg08;
				if (ebx_49 >= 0x04)
					runtime.panicindex(gs);
				runtime.(*mSpanList).insert(gs, ebx_49 * 0x08 + 0x08145280, eax_30);
			}
			*dwArg04 = *((word32) eax_30 + 20);
			*((word32) eax_30 + 20) = dwArg04;
			word32 ecx_73 = (word32) *((word32) eax_30 + 56);
			*((word32) eax_30 + 56) = (word16) ecx_73 - 0x01;
			word16 cx_81 = (word16) ecx_73;
			if (runtime.gcphase != 0x00 || cx_81 != 0x01)
				return;
			uint32 ecx_87 = (word32) bArg08;
			if (ecx_87 >= 0x04)
				runtime.panicindex(gs);
			else
			{
				runtime.(*mSpanList).remove(gs, ecx_87 * 0x08 + 0x08145280, eax_30);
				((word32) eax_30 + 20)->u0 = 0x00;
				runtime.(*mheap).freeManual(gs, eax_30, &g_t81581E0);
			}
		}
	}
}

// 0807DC80: void runtime.stackcacherefill(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack cu8 bArg08)
// Called from:
//      runtime.stackalloc
void runtime.stackcacherefill(struct Eq_2 * gs, Eq_4 dwArg04, cu8 bArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 0x0C))
		runtime.morestackc();
	word32 esi_108;
	word32 edi_109;
	runtime.lock(esi, gs, 0x08157644, out esi_108, out edi_109);
	uint32 eax_24 = 0x00;
	struct Eq_65094 * ecx_25 = null;
	while (eax_24 < 0x4000)
	{
		runtime.stackpoolalloc(gs, bArg08);
		dwLoc0C->ptr0000 = ecx_25;
		ecx_25 = dwLoc0C;
		eax_24 = (0x0800 << bArg08 & 0x00 - (bArg08 < 0x20)) + eax_24;
	}
	word32 edx_110;
	word32 ebx_111;
	runtime.unlock(gs, 0x08157644, out edx_110, out ebx_111);
	uint32 ecx_71 = (word32) bArg08;
	if (ecx_71 >= 0x04)
		runtime.panicindex(gs);
	else
	{
		*((word32) dwArg04 + (ecx_71 * 0x08 + 556)) = ecx_25;
		*((word32) dwArg04 + (ecx_71 * 0x08 + 560)) = eax_24;
	}
}

// 0807DD50: void runtime.stackcacherelease(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack cu8 bArg08)
// Called from:
//      runtime.stackfree
void runtime.stackcacherelease(struct Eq_2 * gs, Eq_4 dwArg04, cu8 bArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 0x0C))
		runtime.morestackc();
	uint32 edx_22 = (word32) bArg08;
	if (edx_22 >= 0x04)
		runtime.panicindex(gs);
	else
	{
		struct Eq_65157 * ecx_30 = (word32) dwArg04 + 556 + edx_22 * 0x08;
		Eq_4 ebx_31 = ecx_30->t0000;
		up32 ecx_33 = ecx_30->dw0004;
		word32 esi_127;
		word32 edi_128;
		runtime.lock(esi, gs, 0x08157644, out esi_127, out edi_128);
		union Eq_4 * edx_43 = (word32) dwArg04 + 556 + edx_22 * 0x08;
		up32 ebx_48;
		Eq_4 ebp_49 = ebx_31;
		for (ebx_48 = ecx_33; ebx_48 > 0x4000; ebx_48 -= 0x0800 << bArg08 & 0x00 - (bArg08 < 0x20))
		{
			Eq_4 eax_57 = *ebp_49;
			runtime.stackpoolfree(gs, ebp_49, bArg08);
			ebp_49 = eax_57;
		}
		word32 edx_129;
		word32 ebx_130;
		runtime.unlock(gs, 0x08157644, out edx_129, out ebx_130);
		*edx_43 = (union Eq_4 *) ebp_49;
		*((word32) dwArg04 + (edx_22 * 0x08 + 560)) = ebx_48;
	}
}

// 0807DE60: Register Eq_4 runtime.stackcache_clear(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      runtime.flushmcache
//      runtime.freemcache.func1
Eq_4 runtime.stackcache_clear(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 0x0C))
		runtime.morestackc();
	word32 esi_132;
	word32 edi_133;
	runtime.lock(esi, gs, 0x08157644, out esi_132, out edi_133);
	uip32 eax_129 = 0x00;
	while (true)
	{
		cu8 al_27 = (byte) eax_129;
		if (al_27 >= 0x04)
			break;
		uint32 edx_43 = (word32) al_27;
		if (edx_43 >= 0x04)
			runtime.panicindex(gs);
		union Eq_4 * ebx_51 = (word32) dwArg04 + 556 + edx_43 * 0x08;
		Eq_4 ebp_53 = *ebx_51;
		uip32 eax_127 = eax_129;
		while (true)
		{
			cu8 al_67 = (byte) eax_127;
			esi = ebp_53;
			if (ebp_53 == 0x00)
				break;
			Eq_4 ecx_63 = *ebp_53;
			runtime.stackpoolfree(gs, ebp_53, al_67);
			eax_127 = (word32) al_27;
			ebp_53 = ecx_63;
		}
		*ebx_51 = (union Eq_4 *) 0x00;
		*((word32) dwArg04 + (edx_43 * 0x08 + 560)) = 0x00;
		eax_129 = SEQ(SLICE(eax_127 + 0x01, word24, 8), al_67 + 0x01);
	}
	word32 edx_134;
	word32 ebx_135;
	runtime.unlock(gs, 0x08157644, out edx_134, out ebx_135);
	return esi;
}

// 0807DF20: void runtime.stackalloc(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      runtime.copystack
//      runtime.malg.func1
//      runtime.gfget.func1
void runtime.stackalloc(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 0x0C))
		runtime.morestackc();
	Eq_4 eax_18 = gs->ptr0000->tFFFFFFFC;
	Eq_4 ecx_19 = *((word32) eax_18 + 24);
	if (eax_18 != *ecx_19)
		runtime.throw(gs);
	else
	{
		Eq_4 eax_166 = dwArg04;
		if ((dwArg04 & dwArg04 - 0x01) != 0x00)
			runtime.throw(gs);
		else if (g_dw8157728 != 0x00)
		{
			runtime.sysAlloc();
			if (dwLoc2C != 0x00)
				return;
			runtime.throw(gs);
		}
		else if (dwArg04 >= 0x8000)
		{
			runtime.stacklog2(gs, dwArg04 >> 0x0D);
			word32 esi_384;
			word32 edi_385;
			runtime.lock(esi, gs, 0x08145340, out esi_384, out edi_385);
			if (dwLoc30 >= 0x13)
				runtime.panicindex(gs);
			else
			{
				Eq_4 eax_117;
				Eq_4 edx_104 = dwLoc30 * 0x08 + 0x08145344;
				Eq_4 eax_106 = g_a8145344[dwLoc30];
				if (eax_106 == 0x00)
					eax_117.u0 = 0x00;
				else
				{
					runtime.(*mSpanList).remove(gs, edx_104, eax_106);
					eax_117 = eax_106;
				}
				word32 edx_390;
				word32 ebx_391;
				runtime.unlock(gs, 0x08145340, out edx_390, out ebx_391);
				if (eax_117 != 0x00)
					return;
				runtime.(*mheap).allocManual(gs);
				if (dwLoc28 == null)
					runtime.throw(gs);
				else
					dwLoc28->t0040 = dwArg04;
			}
		}
		else
		{
			word32 ebx_163 = 0x00;
			while (true)
			{
				cu8 bl_173 = (byte) ebx_163;
				if (eax_166 <= 0x0800)
					break;
				++ebx_163;
				eax_166 >>= 0x01;
			}
			Eq_4 eax_177 = *((word32) ecx_19 + 0x00B8);
			if (eax_177 == 0x00 || (*((word32) ecx_19 + 116) != 0x00 || *((word32) ecx_19 + 0x0088) != 0x00))
			{
				word32 edi_387;
				word32 esi_386;
				runtime.lock(esi, gs, 0x08157644, out esi_386, out edi_387);
				runtime.stackpoolalloc(gs, bl_173);
				word32 edx_388;
				word32 ebx_389;
				runtime.unlock(gs, 0x08157644, out edx_388, out ebx_389);
			}
			else
			{
				uint32 ecx_189 = (word32) bl_173;
				if (ecx_189 >= 0x04)
					runtime.panicindex(gs);
				else
				{
					struct Eq_65434 * ebp_197 = (word32) eax_177 + 556 + ecx_189 * 0x08;
					struct Eq_65440 * esi_198 = ebp_197->ptr0000;
					struct Eq_65440 ** ecx_199 = (word32) eax_177 + 556 + ecx_189 * 0x08;
					if (esi_198 == null)
					{
						runtime.stackcacherefill(gs, eax_177, bl_173);
						esi_198 = (struct Eq_65440 *) *ecx_199;
					}
					*ecx_199 = (struct Eq_65440 **) esi_198->ptr0000;
					ebp_197->dw0004 -= dwArg04;
				}
			}
		}
	}
}

// 0807E1C0: Register Eq_4 runtime.stackfree(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
// Called from:
//      runtime.gfput
//      runtime.copystack
//      runtime.shrinkstack
Eq_4 runtime.stackfree(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 0x0C))
		runtime.morestackc();
	Eq_4 eax_18 = gs->ptr0000->tFFFFFFFC;
	uint32 ebx_23 = dwArg08 - dwArg04;
	if ((ebx_23 & ebx_23 - 0x01) != 0x00)
		runtime.throw(gs);
	else
	{
		Eq_4 esi_190 = (word32) dwArg04 + ebx_23;
		if (esi_190 < dwArg08)
			runtime.throw(gs);
		else if (g_dw8157728 != 0x00)
		{
			runtime.sysFault(gs);
			return esi_190;
		}
		else if (ebx_23 >= 0x8000)
		{
			uint32 ecx_60 = dwArg04 - g_t81493A8;
			Eq_4 ebx_62 = g_t8149108;
			if (ecx_60 >> 0x0D >= g_t814910C)
				runtime.panicindex(gs);
			else
			{
				Eq_4 eax_70 = *((word32) ebx_62 + (ecx_60 >> 0x0D) * 0x04);
				if (*((word32) eax_70 + 60) != 0x02)
				{
					Eq_4 eax_76 = *((word32) eax_70 + 0x0C);
					runtime.printlock(gs);
					word32 esi_376;
					runtime.printhex(esi, gs, eax_76, 0x00, out esi_376);
					runtime.printsp(gs);
					runtime.printpointer(gs);
					runtime.printnl(gs);
					runtime.printunlock(gs);
					runtime.throw(gs);
				}
				else if (runtime.gcphase != 0x00)
				{
					runtime.stacklog2(gs, *((word32) eax_70 + 16));
					word32 esi_377;
					word32 edi_378;
					runtime.lock(esi, gs, 0x08145340, out esi_377, out edi_378);
					if (dwLoc28 >= 0x13)
						runtime.panicindex(gs);
					else
					{
						runtime.(*mSpanList).insert(gs, dwLoc28 * 0x08 + 0x08145344, eax_70);
						word32 edx_379;
						word32 ebx_380;
						runtime.unlock(gs, 0x08145340, out edx_379, out ebx_380);
						return esi_190;
					}
				}
				else
				{
					runtime.(*mheap).freeManual(gs, eax_70, &g_t81581E0);
					return esi_190;
				}
			}
		}
		else
		{
			word32 ebp_165 = 0x00;
			ebx_168 = ebx_23;
			while (true)
			{
				uint32 ebx_168;
				if (ebx_168 <= 0x0800)
					break;
				++ebp_165;
				ebx_168 >>= 0x01;
			}
			Eq_4 eax_185 = *((word32) eax_18 + 24);
			cu8 al_179 = (byte) ebp_165;
			Eq_4 ebx_186 = *((word32) eax_185 + 0x00B8);
			if (ebx_186 != 0x00)
			{
				esi_190 = *((word32) eax_185 + 116);
				if (esi_190 == 0x00 && *((word32) eax_185 + 0x0088) == 0x00)
				{
					uint32 eax_202 = (word32) (byte) ebp_165;
					if (eax_202 >= 0x04)
						runtime.panicindex(gs);
					else
					{
						up32 * eax_214 = (word32) ebx_186 + 560 + eax_202 * 0x08;
						Eq_4 esi_213 = (word32) ebx_186 + 556 + eax_202 * 0x08;
						if (*eax_214 >= 0x8000)
							runtime.stackcacherelease(gs, ebx_186, (byte) ebp_165);
						*dwArg04 = *esi_213;
						*esi_213 = dwArg04;
						*eax_214 += ebx_23;
						esi_190 = esi_213;
						return esi_190;
					}
				}
			}
			word32 esi_372;
			word32 edi_373;
			runtime.lock(esi, gs, 0x08157644, out esi_372, out edi_373);
			runtime.stackpoolfree(gs, dwArg04, al_179);
			word32 ebx_375;
			word32 edx_374;
			runtime.unlock(gs, 0x08157644, out edx_374, out ebx_375);
			return esi_190;
		}
	}
}

// 0807E460: void runtime.adjustpointers(Register (ptr32 Eq_2) gs, Stack up32 dwArg04, Stack (ptr32 Eq_65701) dwArg08, Stack (ptr32 Eq_65702) dwArg0C, Stack Eq_4 dwArg10, Stack Eq_4 dwArg14)
// Called from:
//      runtime.adjustframe
void runtime.adjustpointers(struct Eq_2 * gs, up32 dwArg04, struct Eq_65701 * dwArg08, struct Eq_65702 * dwArg0C, Eq_4 dwArg10, Eq_4 dwArg14)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	uint32 eax_21 = dwArg08->dw0000;
	bcu8 (* edx_18)[] = dwArg08->ptr0004;
	Eq_65725 ebx_25 = (eax_21 + 0x07 >> 0x1F >> 0x1D) + 0x07 + eax_21;
	if (ebx_25 >> 0x03 > 0x40000000)
		runtime.panicslice(gs);
	else
	{
		Eq_4 edx_34 = dwArg0C->t0000;
		Eq_4 ebx_36 = dwArg0C->t0004;
		up32 ebp_38 = dwArg0C->dw0008;
		up32 eax_46 = dwArg0C->dw00CC;
		uint32 dwLoc40_296;
		for (dwLoc40_296 = 0x00; dwLoc40_296 < eax_21; ++dwLoc40_296)
		{
			if (dwLoc40_296 >> 0x03 >= ebx_25 >> 0x03)
				runtime.panicindex(gs);
			if ((Mem55[edx_18 + (dwLoc40_296 >>u 0x03):byte] >>u (SLICE(dwLoc40_296, byte, 0) & 0x07) & 0x01) == 0x01)
			{
				union Eq_4 * eax_84 = dwArg04 + dwLoc40_296 * 0x04;
				do
				{
					byte bLoc48_338 = (byte) dwLoc48;
					Eq_4 ebx_88 = *eax_84;
					if (dwArg10 != 0x00 && (ebx_88 > 0x00 && ebx_88 < 0x1000))
					{
						Eq_4 esi_102 = g_t8157744;
						if (esi_102 != 0x00)
						{
							*((word32) *((word32) gs->ptr0000->tFFFFFFFC + 24) + 461) = 0x02;
							runtime.funcname(gs, dwArg10, dwArg14);
							runtime.printlock(gs);
							runtime.printstring(gs);
							runtime.printstring(gs);
							runtime.printstring(gs);
							runtime.printpointer(gs);
							runtime.printstring(gs);
							word32 esi_404;
							runtime.printhex(esi_102, gs, ebx_88, 0x00, out esi_404);
							runtime.printstring(gs);
							runtime.printunlock(gs);
							runtime.throw(gs);
						}
					}
					if (edx_34 > ebx_88 || ebx_88 >= ebx_36)
						break;
					if (dwArg04 >= eax_46)
					{
						*eax_84 = (word32) ebx_88 + ebp_38;
						break;
					}
					runtime/internal/atomic.Casp1(eax_84, ebx_88, (word32) ebx_88 + ebp_38);
				} while (bLoc48_338 == 0x00);
			}
		}
	}
}

// 0807E700: void runtime.adjustframe(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_65851) dwArg04, Stack (ptr32 Eq_65702) dwArg08)
void runtime.adjustframe(struct Eq_2 * gs, struct Eq_65851 * dwArg04, struct Eq_65702 * dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 ecx_21 = dwArg04->t000C;
	if (ecx_21 == 0x00)
		return;
	Eq_4 edx_28 = dwArg04->t0000;
	Eq_4 ebx_29 = dwArg04->t0004;
	Eq_4 ebp_30 = *edx_28;
	Eq_4 esi_31 = runtime.systemstack_switchPC;
	if (ebp_30 == esi_31)
		return;
	if (ecx_21 != ebp_30)
		--ecx_21;
	runtime.pcdatavalue(gs, edx_28, 0x00);
	Eq_4 dwLoc48_784 = ecx_21;
	Eq_4 eax_66 = dwLoc40;
	if (dwLoc40 == ~0x00)
		eax_66.u0 = 0x00;
	Eq_4 edx_78 = dwArg04->dw001C - dwArg04->dw0014;
	if (edx_78 > 0x00)
	{
		word24 ebx_24_8_285 = SLICE(runtime.funcdata(gs, edx_28, 0x01), word24, 8);
		if (ecx_21 != 0x00)
		{
			Eq_4 ecx_104 = *ecx_21;
			if (ecx_104 > 0x00)
			{
				if (eax_66 < 0x00 || eax_66 >= ecx_104)
				{
					runtime.funcname(gs, edx_28, ebx_29);
					Eq_4 eax_257 = *ecx_21;
					runtime.printlock(gs);
					runtime.printstring(gs);
					runtime.printint(ebx_24_8_285, gs, SEQ(eax_66 >> 0x1F, eax_66));
					runtime.printstring(gs);
					runtime.printint(ebx_24_8_285, gs, SEQ(eax_257 >> 0x1F, eax_257));
					runtime.printstring(gs);
					runtime.printstring(gs);
					runtime.printstring(gs);
					runtime.printint(ebx_24_8_285, gs, (uint64) ecx_21);
					runtime.printstring(gs);
					runtime.printunlock(gs);
					runtime.throw(gs);
				}
				runtime.stackmapdata(gs, ecx_21, eax_66);
				runtime.adjustpointers(gs, dwArg04->dw001C - 0x04, fp - 0x10, dwArg08, edx_28, ebx_29);
				dwLoc48_784 = edx_28;
				goto l0807E7A0;
			}
		}
		runtime.funcname(gs, edx_28, ebx_29);
		word32 edx_126 = dwArg04->dw001C;
		runtime.printlock(gs);
		runtime.printstring(gs);
		runtime.printstring(gs);
		runtime.printstring(gs);
		Eq_4 esi_180;
		runtime.printhex(esi_31, gs, edx_126 - edx_78, 0x00, out esi_180);
		runtime.printstring(gs);
		word32 esi_1022;
		runtime.printhex(esi_180, gs, edx_78, 0x00, out esi_1022);
		runtime.printstring(gs);
		runtime.printunlock(gs);
		runtime.throw(gs);
	}
	else
	{
l0807E7A0:
		if (dwArg04->dw0024 <= 0x00)
			return;
		if (dwArg04->dw0028 == 0x00)
		{
			word24 ebx_24_8_625 = SLICE(runtime.funcdata(gs, edx_28, 0x00), word24, 8);
			if (dwLoc48_784 != 0x00)
			{
				Eq_4 ecx_455 = *dwLoc48_784;
				if (ecx_455 > 0x00)
				{
					if (eax_66 < 0x00 || eax_66 >= ecx_455)
					{
						runtime.funcname(gs, edx_28, ebx_29);
						Eq_4 eax_597 = *dwLoc48_784;
						runtime.printlock(gs);
						runtime.printstring(gs);
						runtime.printint(ebx_24_8_625, gs, SEQ(eax_66 >> 0x1F, eax_66));
						runtime.printstring(gs);
						runtime.printint(ebx_24_8_625, gs, SEQ(eax_597 >> 0x1F, eax_597));
						runtime.printstring(gs);
						runtime.printstring(gs);
						runtime.printstring(gs);
						runtime.printint(ebx_24_8_625, gs, (uint64) ecx_21);
						runtime.printstring(gs);
						runtime.printunlock(gs);
						runtime.throw(gs);
					}
					runtime.stackmapdata(gs, dwLoc48_784, eax_66);
					goto l0807E7CB;
				}
			}
			runtime.funcname(gs, edx_28, ebx_29);
			up32 ebx_477 = dwArg04->dw0020;
			up32 edx_479 = dwArg04->dw0024;
			runtime.printlock(gs);
			runtime.printstring(gs);
			runtime.printstring(gs);
			runtime.printstring(gs);
			word24 ebx_24_8_521 = SLICE(ebx_477, word24, 8);
			runtime.printint(ebx_24_8_521, gs, (uint64) ebx_477);
			runtime.printstring(gs);
			runtime.printint(ebx_24_8_521, gs, (uint64) edx_479);
			runtime.printstring(gs);
			runtime.printunlock(gs);
			runtime.throw(gs);
		}
		else
		{
l0807E7CB:
			runtime.adjustpointers(gs, dwArg04->dw0020, fp - 0x08, dwArg08, 0x00, 0x00);
		}
	}
}

// 0807ED40: void runtime.adjustctxt(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack (ptr32 Eq_66117) dwArg08)
// Called from:
//      runtime.copystack
void runtime.adjustctxt(struct Eq_2 * gs, Eq_4 dwArg04, struct Eq_66117 * dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 ecx_20 = *((word32) dwArg04 + 40);
	if (dwArg08->t0000 <= ecx_20 && ecx_20 < dwArg08->t0004)
		*((word32) dwArg04 + 40) = (word32) ecx_20 + dwArg08->dw0008;
	if (g_b815756C == 0x00)
		return;
	Eq_4 ecx_41 = *((word32) dwArg04 + 52);
	if (dwArg08->t0000 <= ecx_41 && ecx_41 < dwArg08->t0004)
		*((word32) dwArg04 + 52) = (word32) ecx_41 + dwArg08->dw0008;
}

// 0807EDB0: void runtime.adjustdefers(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack (ptr32 Eq_66174) dwArg08)
// Called from:
//      runtime.copystack
void runtime.adjustdefers(struct Eq_2 * gs, Eq_4 dwArg04, struct Eq_66174 * dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	Eq_4 stackArg0 = <invalid>;
	runtime.tracebackdefers(gs, stackArg0, dwArg04, 0x080E7B7C);
	Eq_4 eax_29 = *((word32) dwArg04 + 20);
	while (eax_29 != 0x00)
	{
		Eq_4 edx_42 = *((word32) eax_29 + 16);
		if (dwArg08->t0000 <= edx_42 && edx_42 < dwArg08->t0004)
			*((word32) eax_29 + 16) = (word32) edx_42 + dwArg08->dw0008;
		Eq_4 edx_58 = *((word32) eax_29 + 8);
		if (dwArg08->t0000 <= edx_58 && edx_58 < dwArg08->t0004)
			*((word32) eax_29 + 8) = (word32) edx_58 + dwArg08->dw0008;
		Eq_4 edx_74 = *((word32) eax_29 + 20);
		if (dwArg08->t0000 <= edx_74 && edx_74 < dwArg08->t0004)
			*((word32) eax_29 + 20) = (word32) edx_74 + dwArg08->dw0008;
		eax_29 = *((word32) eax_29 + 24);
	}
}

// 0807EE70: void runtime.adjustsudogs(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack (ptr32 Eq_66259) dwArg08)
// Called from:
//      runtime.syncadjustsudogs
//      runtime.copystack
void runtime.adjustsudogs(struct Eq_2 * gs, Eq_4 dwArg04, struct Eq_66259 * dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 eax_17 = *((word32) dwArg04 + 0x00B4);
	while (eax_17 != 0x00)
	{
		Eq_4 edx_27 = *((word32) eax_17 + 16);
		if (dwArg08->t0000 <= edx_27 && edx_27 < dwArg08->t0004)
			*((word32) eax_17 + 16) = (word32) edx_27 + dwArg08->dw0008;
		Eq_4 edx_43 = *((word32) eax_17 + 4);
		if (dwArg08->t0000 <= edx_43 && edx_43 < dwArg08->t0004)
			*((word32) eax_17 + 4) = (word32) edx_43 + dwArg08->dw0008;
		eax_17 = *((word32) eax_17 + 44);
	}
}

// 0807EEE0: void runtime.findsghi(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C)
// Called from:
//      runtime.copystack
void runtime.findsghi(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 eax_17 = *((word32) dwArg04 + 0x00B4);
	Eq_4 ebx_20 = 0x00;
	while (eax_17 != 0x00)
	{
		Eq_4 ebp_34 = (word32) *((word32) eax_17 + 16) + (word32) (*((word32) (*((word32) eax_17 + 52)) + 0x0C));
		if (dwArg08 > ebp_34 || (ebp_34 >= dwArg0C || ebp_34 <= ebx_20))
			ebp_34 = ebx_20;
		Eq_4 ebx_49 = *((word32) eax_17 + 4);
		ebx_20 = (word32) ebx_49 + 4;
		if (dwArg08 > (word32) ebx_49 + 4 || ((word32) ebx_49 + 4 >= dwArg0C || (word32) ebx_49 + 4 <= ebp_34))
			ebx_20 = ebp_34;
		eax_17 = *((word32) eax_17 + 44);
	}
}

// 0807EF50: void runtime.syncadjustsudogs(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack (ptr32 Eq_66259) dwArg0C)
// Called from:
//      runtime.copystack
void runtime.syncadjustsudogs(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, struct Eq_66259 * dwArg0C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 eax_138 = dwArg04;
	Eq_4 ecx_144 = *((word32) dwArg04 + 0x00B4);
	if (ecx_144 == 0x00)
		return;
	Eq_4 edx_125 = 0x00;
	while (ecx_144 != 0x00)
	{
		Eq_4 ebx_124 = *((word32) ecx_144 + 52);
		if (edx_125 != ebx_124)
		{
			word32 edi_320;
			word32 esi_319;
			runtime.lock(esi, gs, (word32) ebx_124 + 48, out esi_319, out edi_320);
			eax_138 = dwArg04;
		}
		edx_125 = *((word32) ecx_144 + 52);
		ecx_144 = *((word32) ecx_144 + 44);
	}
	runtime.adjustsudogs(gs, eax_138, dwArg0C);
	word32 ecx_43 = dwArg0C->dw00CC;
	if (ecx_43 != 0x00)
	{
		Eq_4 edx_49 = dwArg0C->t0004 - dwArg08;
		word128 xmm2_326;
		word128 xmm1_325;
		word32 ebp_321;
		word32 esi_322;
		word128 xmm0_324;
		word32 edi_323;
		runtime.memmove((word32) edx_49 + dwArg0C->dw0008, edx_49, ecx_43 - edx_49, out ebp_321, out esi_322, out edi_323, out xmm0_324, out xmm1_325, out xmm2_326);
	}
	Eq_4 ecx_122 = *((word32) dwArg04 + 0x00B4);
	Eq_4 edx_102 = 0x00;
	while (ecx_122 != 0x00)
	{
		Eq_4 ebx_101 = *((word32) ecx_122 + 52);
		if (edx_102 != ebx_101)
		{
			word32 ebx_328;
			word32 edx_327;
			runtime.unlock(gs, (word32) ebx_101 + 48, out edx_327, out ebx_328);
		}
		edx_102 = *((word32) ecx_122 + 52);
		ecx_122 = *((word32) ecx_122 + 44);
	}
}

// 0807F060: void runtime.copystack(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg00, Stack Eq_4 dwArg04, Stack Eq_4 bArg08)
// Called from:
//      runtime.newstack
//      runtime.shrinkstack
void runtime.copystack(struct Eq_2 * gs, Eq_4 dwArg00, Eq_4 dwArg04, Eq_4 bArg08)
{
	byte bArg08_263 = (byte) dwArg08;
	while (fp - 0x94 <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (*((word32) dwArg04 + 56) != 0x00)
		runtime.throw(gs);
	else
	{
		Eq_4 ecx_30 = *((word32) dwArg04 + 4);
		Eq_4 edx_31 = *dwArg04;
		if (edx_31 == 0x00)
			runtime.throw(gs);
		else
		{
			Eq_4 eax_102;
			runtime.stackalloc(gs, dwArg08);
			fn0808FD5C(0x00, fp - 0xD0);
			up32 edx_67 = dwLoc010C - edx_31;
			Eq_4 ecx_71 = edx_31 - dwLocD8;
			if (bArg08_263 != 0x00)
			{
				runtime.adjustsudogs(gs, dwArg00, fp - 212);
				eax_102 = ecx_71;
			}
			else
			{
				runtime.findsghi(gs, dwArg00, dwLocEC, edx_31);
				runtime.syncadjustsudogs(gs, dwArg00, ecx_71, fp - 212);
				dwLoc08 = dwLoc010C;
				eax_102 = ecx_71 - dwLoc010C;
			}
			word32 esi_369;
			word32 ebp_368;
			word32 edi_370;
			word128 xmm0_371;
			word128 xmm2_373;
			word128 xmm1_372;
			runtime.memmove(dwLoc0110 - eax_102, edx_31 - eax_102, eax_102, out ebp_368, out esi_369, out edi_370, out xmm0_371, out xmm1_372, out xmm2_373);
			runtime.adjustctxt(gs, dwArg00, fp - 212);
			runtime.adjustdefers(gs, dwArg00, fp - 212);
			Eq_4 ecx_164 = *((word32) dwArg00 + 16);
			if (dwLocEC <= ecx_164 && ecx_164 < edx_31)
				*((word32) dwArg00 + 16) = (word32) ecx_164 + edx_67;
			*dwArg00 = ecx_30;
			*((word32) dwArg00 + 4) = dwLoc0110;
			*((word32) dwArg00 + 8) = (word32) ecx_30 + 880;
			*((word32) dwArg00 + 28) = dwLoc0110 - ecx_71;
			*((word32) dwArg00 + 64) = (word32) *((word32) dwArg00 + 64) + edx_67;
			runtime.gentraceback(gs, ~0x00, 0x00, dwArg00, 0x00, 0x00, 0x7FFFFFFF, 0x080E7B7C, fp - 212);
			runtime.stackfree(gs, dwLocEC, edx_31);
		}
	}
}

// 0807F2E0: void runtime.round2(Register (ptr32 Eq_2) gs, Stack int32 dwArg04)
// Called from:
//      runtime.malg
//      runtime.check
void runtime.round2(struct Eq_2 * gs, int32 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	up32 ecx_50 = 0x00;
	while (true)
	{
		byte cl_21 = (byte) ecx_50;
		if ((0x01 << cl_21 & 0x00 - (ecx_50 < 0x20)) >= dwArg04)
			break;
		ecx_50 = SEQ(SLICE(ecx_50 + 0x01, word24, 8), cl_21 + 0x01);
	}
}

// 0807F320: void runtime.newstack(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      runtime.morestack
void runtime.newstack(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp - 0x34 <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 eax_19 = gs->ptr0000->tFFFFFFFC;
	Eq_4 ecx_20 = *((word32) eax_19 + 24);
	Eq_4 edx_21 = *((word32) ecx_20 + 0x0C);
	if (*((word32) edx_21 + 8) == ~0x04D1)
		runtime.throw(gs);
	else
	{
		Eq_4 ebp_36 = *((word32) ecx_20 + 84);
		if (edx_21 != ebp_36)
		{
			runtime.printlock(gs);
			runtime.printstring(gs);
			word32 esi_1429;
			runtime.printhex(esi, gs, edx_21, 0x00, out esi_1429);
			runtime.printstring(gs);
			runtime.printpointer(gs);
			runtime.printstring(gs);
			runtime.printpointer(gs);
			runtime.printstring(gs);
			runtime.printpointer(gs);
			runtime.printstring(gs);
			runtime.printpointer(gs);
			runtime.printstring(gs);
			runtime.printunlock(gs);
			fn0809025A((word32) *((word32) eax_19 + 24) + 4, fp - 0x54);
			runtime.traceback(gs);
			runtime.throw(gs);
		}
		else
		{
			if (g_t81576F0 == 0x00)
				*((word32) ebp_36 + 40) = dwArg04;
			else
			{
				runtime.writebarrierptr((word32) ebp_36 + 40, dwArg04);
				dwLocB0 = dwArg04;
			}
			Eq_4 ecx_180 = *((word32) eax_19 + 24);
			if (*((word32) *((word32) ecx_180 + 84) + 113) != 0x00)
			{
				fn0809025A((word32) ecx_180 + 4, fp - 0x38);
				*((word32) ebp_36 + 56) = dwLoc38;
				*((word32) ebp_36 + 60) = dwLoc34;
				Eq_4 eax_202 = *ebp_36;
				Eq_4 ecx_204 = *((word32) ebp_36 + 4);
				Eq_4 ebx_212 = *((word32) ebp_36 + 32);
				Eq_4 ebx_214 = *((word32) ebp_36 + 28);
				Eq_4 edx_216 = *((word32) ebp_36 + 48);
				runtime.printlock(gs);
				runtime.printstring(gs);
				word32 esi_1430;
				runtime.printhex(esi, gs, ebx_214, 0x00, out esi_1430);
				runtime.printstring(gs);
				word32 esi_1431;
				runtime.printhex(esi, gs, eax_202, 0x00, out esi_1431);
				runtime.printstring(gs);
				word32 esi_1432;
				runtime.printhex(esi, gs, ecx_204, 0x00, out esi_1432);
				runtime.printstring(gs);
				runtime.printstring(gs);
				word32 esi_1433;
				runtime.printhex(esi, gs, dwLoc34, 0x00, out esi_1433);
				runtime.printstring(gs);
				word32 esi_1434;
				runtime.printhex(esi, gs, dwLoc38, 0x00, out esi_1434);
				runtime.printstring(gs);
				word32 esi_1435;
				runtime.printhex(esi, gs, dwLoc24, 0x00, out esi_1435);
				runtime.printstring(gs);
				runtime.printstring(gs);
				word32 esi_1436;
				runtime.printhex(esi, gs, ebx_212, 0x00, out esi_1436);
				runtime.printstring(gs);
				word32 esi_1437;
				runtime.printhex(esi, gs, ebx_214, 0x00, out esi_1437);
				runtime.printstring(gs);
				word32 esi_1438;
				runtime.printhex(esi, gs, edx_216, 0x00, out esi_1438);
				runtime.printstring(gs);
				runtime.printpointer(gs);
				runtime.printstring(gs);
				runtime.printunlock(gs);
				runtime.traceback(gs);
				runtime.throw(gs);
			}
			else
			{
				fn0809025A((word32) ecx_180 + 4, fp - 0x1C);
				((word32) *((word32) eax_19 + 24) + 8)->u0 = 0x00;
				((word32) *((word32) eax_19 + 24) + 24)->u0 = 0x00;
				((word32) *((word32) eax_19 + 24) + 4)->u0 = 0x00;
				((word32) *((word32) eax_19 + 24) + 0x0C)->u0 = 0x00;
				runtime/internal/atomic.Loaduintptr();
				if (dwLocB0 == ~0x0521)
				{
					Eq_4 edx_433 = *((word32) eax_19 + 24);
					if (*((word32) edx_433 + 0x0078) != 0x00 || (*((word32) edx_433 + 0x0068) != 0x00 || (*((word32) edx_433 + 116) != 0x00 || *((word32) (*((word32) edx_433 + 92)) + 8) != 0x01)))
					{
						*((word32) ebp_36 + 8) = (word32) *ebp_36 + 880;
						runtime.gogo(gs, (word32) ebp_36 + 28);
					}
				}
				Eq_4 ecx_467 = *ebp_36;
				if (ecx_467 == 0x00)
					runtime.throw(gs);
				else
				{
					Eq_4 edx_479 = *((word32) ebp_36 + 28);
					if (edx_479 - 0x04 < ecx_467)
					{
						Eq_4 ecx_486 = *((word32) ebp_36 + 4);
						Eq_4 esi_494 = *((word32) ebp_36 + 32);
						Eq_4 edi_496 = *((word32) ebp_36 + 48);
						runtime.printlock(gs);
						runtime.printstring(gs);
						word32 esi_1439;
						runtime.printhex(esi, gs, edx_479 - 0x04, 0x00, out esi_1439);
						runtime.printstring(gs);
						word32 esi_1440;
						runtime.printhex(esi, gs, ecx_467, 0x00, out esi_1440);
						runtime.printstring(gs);
						word32 esi_1441;
						runtime.printhex(esi, gs, ecx_486, 0x00, out esi_1441);
						runtime.printstring(gs);
						runtime.printstring(gs);
						word32 esi_1442;
						runtime.printhex(esi, gs, dwLoc18, 0x00, out esi_1442);
						runtime.printstring(gs);
						word32 esi_1443;
						runtime.printhex(esi, gs, dwLoc1C, 0x00, out esi_1443);
						runtime.printstring(gs);
						word32 esi_1444;
						runtime.printhex(esi, gs, dwLoc08, 0x00, out esi_1444);
						runtime.printstring(gs);
						runtime.printstring(gs);
						word32 esi_1445;
						runtime.printhex(esi, gs, esi_494, 0x00, out esi_1445);
						runtime.printstring(gs);
						word32 esi_1446;
						runtime.printhex(esi, gs, edx_479, 0x00, out esi_1446);
						runtime.printstring(gs);
						word32 esi_1447;
						runtime.printhex(esi, gs, edi_496, 0x00, out esi_1447);
						runtime.printstring(gs);
						runtime.printpointer(gs);
						runtime.printstring(gs);
						runtime.printunlock(gs);
					}
					if (edx_479 - 0x04 < *ebp_36)
					{
						runtime.readgstatus(ebp_36);
						Eq_4 esp_679 = <invalid>;
						*((word32) esp_679 + 28) = *((word32) esp_679 + 4);
						runtime.printlock(gs);
						esp_679->u0 = 0x080E1DFB;
						((word32) esp_679 + 4)->u0 = 0x0C;
						runtime.printstring(gs);
						*esp_679 = *((word32) esp_679 + 92);
						runtime.printpointer(gs);
						esp_679->u0 = 0x080E1E94;
						((word32) esp_679 + 4)->u0 = 0x0D;
						runtime.printstring(gs);
						*esp_679 = *((word32) esp_679 + 28);
						((word32) esp_679 + 4)->u0 = 0x00;
						// Failed to bind call argument.
						// Please report this issue at https://github.com/uxmal/reko
						Eq_4 stackArg4 = <invalid>;
						word32 esi_1449;
						runtime.printhex(esi, gs, stackArg4, dwArg04, out esi_1449);
						esp_679->u0 = 0x080E0E0D;
						((word32) esp_679 + 4)->u0 = 0x02;
						runtime.printstring(gs);
						runtime.printunlock(gs);
						*((word32) esp_679 + 64) = **((word32) esp_679 + 92);
						runtime.printlock(gs);
						esp_679->u0 = 135156324;
						((word32) esp_679 + 4)->u0 = 0x1F;
						runtime.printstring(gs);
						*esp_679 = *((word32) esp_679 + 16);
						((word32) esp_679 + 4)->u0 = 0x00;
						// Failed to bind call argument.
						// Please report this issue at https://github.com/uxmal/reko
						Eq_4 stackArg4 = <invalid>;
						word32 esi_1451;
						runtime.printhex(esi, gs, stackArg4, dwArg04, out esi_1451);
						esp_679->u0 = 0x080E0E2B;
						((word32) esp_679 + 4)->u0 = 0x03;
						runtime.printstring(gs);
						*esp_679 = *((word32) esp_679 + 64);
						((word32) esp_679 + 4)->u0 = 0x00;
						// Failed to bind call argument.
						// Please report this issue at https://github.com/uxmal/reko
						Eq_4 stackArg4 = <invalid>;
						word32 esi_1453;
						runtime.printhex(esi, gs, stackArg4, dwArg04, out esi_1453);
						esp_679->u0 = 0x080E0D9C;
						((word32) esp_679 + 4)->u0 = 0x01;
						runtime.printstring(gs);
						runtime.printunlock(gs);
						esp_679->u0 = 0x080E4C60;
						((word32) esp_679 + 4)->u0 = 0x1D;
						runtime.throw(gs);
					}
					else
					{
						if (dwLocB0 == ~0x0521)
						{
							Eq_4 ecx_786 = *((word32) eax_19 + 24);
							if (ebp_36 == *ecx_786)
								runtime.throw(gs);
							if (*((word32) ecx_786 + 92) == 0x00 && *((word32) ecx_786 + 0x0078) == 0x00)
								runtime.throw(gs);
							runtime.casgstatus(ebp_36, 0x02, 0x04);
							if (*((word32) ebp_36 + 110) != 0x00)
							{
								do
									runtime.castogscanstatus(gs, ebp_36, 0x04, 0x1004);
								while (bLocA8 == 0x00);
								if (*((word32) ebp_36 + 111) == 0x00)
								{
									Eq_4 edx_851 = *((word32) *((word32) ebp_36 + 24) + 92);
									runtime.scanstack(gs, ebp_36, (word32) edx_851 + 0x0950);
									if (g_t815756D != 0x00)
									{
										// Failed to bind call argument.
										// Please report this issue at https://github.com/uxmal/reko
										Eq_4 stackArg0 = <invalid>;
										runtime.(*gcWork).dispose(ebx_24_8, ebp, gs, stackArg0, (word32) edx_851 + 0x0950);
									}
									((word32) ebp_36 + 111)->u0 = 0x01;
								}
								*((word32) ebp_36 + 110) = 0x00;
								((word32) ebp_36 + 0x006C)->u0 = 0x00;
								runtime.casfrom_Gscanstatus(gs, ebp_36, 0x1004, 0x04);
								runtime.casgstatus(ebp_36, 0x04, 0x02);
								*((word32) ebp_36 + 8) = (word32) *ebp_36 + 880;
								runtime.gogo(gs, (word32) ebp_36 + 28);
							}
							runtime.casgstatus(ebp_36, 0x04, 0x02);
							runtime.gopreempt_m(gs);
						}
						ui32 ecx_933 = *((word32) ebp_36 + 4) - *ebp_36;
						if (ecx_933 << 0x01 > runtime.maxstacksize)
						{
							runtime.printlock(gs);
							runtime.printstring(gs);
							runtime.printint(ebx_24_8, gs, runtime.maxstacksize);
							runtime.printstring(gs);
							runtime.printunlock(gs);
							runtime.throw(gs);
						}
						else
						{
							runtime.casgstatus(ebp_36, 0x02, 0x08);
							// Failed to bind call argument.
							// Please report this issue at https://github.com/uxmal/reko
							Eq_4 stackArg0 = <invalid>;
							runtime.copystack(gs, stackArg0, ebp_36, ecx_933 << 0x01);
							runtime.casgstatus(ebp_36, 0x08, 0x02);
							runtime.gogo(gs, (word32) ebp_36 + 28);
						}
					}
				}
			}
		}
	}
}

// 0807FE60: void runtime.shrinkstack(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      runtime.markrootFreeGStacks
//      runtime.scanstack
void runtime.shrinkstack(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.readgstatus(dwArg04);
	if ((dwLoc08 & ~0x1000) != 0x06)
	{
		Eq_4 edx_32 = *dwArg04;
		if (edx_32 == 0x00)
			runtime.throw(gs);
		else if ((dwLoc08 & 0x1000) == 0x00)
			runtime.throw(gs);
		else
		{
			if (g_dw8157734 > 0x00)
				return;
			if (*((word32) dwArg04 + 0x00AC) == runtime.gcBgMarkWorkerPC)
				return;
			Eq_4 ecx_64 = *((word32) dwArg04 + 4);
			uint32 ecx_66 = ecx_64 - edx_32;
			if (ecx_66 >> 0x01 < 0x0800)
				return;
			if (ecx_64 - *((word32) dwArg04 + 28) + 0x02F0 >= ecx_66 >> 0x02)
				return;
			if (*((word32) dwArg04 + 56) != 0x00)
				return;
			// Failed to bind call argument.
			// Please report this issue at https://github.com/uxmal/reko
			Eq_4 stackArg0 = <invalid>;
			runtime.copystack(gs, stackArg0, dwArg04, dwArg04);
		}
	}
	else
	{
		Eq_4 ecx_97 = *dwArg04;
		if (ecx_97 != 0x00)
		{
			runtime.stackfree(gs, ecx_97, dwArg04);
			dwArg04->u0 = 0x00;
			((word32) dwArg04 + 4)->u0 = 0x00;
		}
	}
}

// 0807FF90: void runtime.freeStackSpans(Register Eq_4 esi, Register (ptr32 Eq_2) gs)
void runtime.freeStackSpans(Eq_4 esi, struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	word32 edi_237;
	Eq_4 esi_149;
	runtime.lock(esi, gs, 0x08157644, out esi_149, out edi_237);
	Eq_67482 eax_145 = 0x00;
	while (eax_145 < 0x04)
	{
		if (eax_145 >= 0x04)
			runtime.panicindex(gs);
		Eq_4 edx_136 = eax_145 * 0x08 + 0x08145280;
		Eq_4 ebx_139 = g_a8145280[eax_145];
		eax_144 = eax_145;
		edx_157 = edx_136;
		while (true)
		{
			Eq_4 edx_157;
			Eq_67482 eax_144;
			if (ebx_139 == 0x00)
				break;
			esi_149 = (word32) *((word32) ebx_139 + 56);
			Eq_4 ebp_148 = *ebx_139;
			if ((word16) esi_149 == 0x00)
			{
				runtime.(*mSpanList).remove(gs, edx_157, ebx_139);
				((word32) ebx_139 + 20)->u0 = 0x00;
				runtime.(*mheap).freeManual(gs, ebx_139, &g_t81581E0);
				eax_144 = eax_145;
				edx_157 = edx_136;
			}
			ebx_139 = ebp_148;
		}
		eax_145 = (word32) eax_144 + 1;
	}
	word32 ebx_239;
	word32 edx_238;
	runtime.unlock(gs, 0x08157644, out edx_238, out ebx_239);
	word32 esi_240;
	word32 edi_241;
	runtime.lock(esi_149, gs, 0x08145340, out esi_240, out edi_241);
	Eq_67500 eax_131 = 0x00;
	while (eax_131 < 0x13)
	{
		if (eax_131 >= 0x13)
			runtime.panicindex(gs);
		Eq_4 ecx_90 = eax_131 * 0x08 + 0x08145344;
		Eq_4 edx_129 = *ecx_90;
		while (edx_129 != 0x00)
		{
			Eq_4 eax_99 = *edx_129;
			runtime.(*mSpanList).remove(gs, ecx_90, edx_129);
			runtime.(*mheap).freeManual(gs, edx_129, &g_t81581E0);
			edx_129 = eax_99;
		}
		eax_131 = (word32) eax_131 + 1;
	}
	word32 edx_242;
	word32 ebx_243;
	runtime.unlock(gs, 0x08145340, out edx_242, out ebx_243);
}

// 080800F0: void runtime.morestackc()
// Called from:
//      runtime.cgoCheckUsingType
//      runtime.persistentalloc1
//      runtime.gcmarkwb_m
//      runtime.gcAssistAlloc1
//      runtime.scanstack
//      runtime.gcDrainN
//      runtime.(*mheap).allocManual
//      runtime.(*mheap).freeManual
//      runtime.forEachP
//      runtime.stackcacherefill
//      runtime.stackcacherelease
//      runtime.stackcache_clear
//      runtime.stackalloc
//      runtime.stackfree
void runtime.morestackc()
{
	word32 ebp_18;
	word32 edi_19;
	runtime.systemstack(gs, 0x080E7C78, out ebp_18, out edi_19);
}

// 08080110: Register Eq_4 runtime.concatstrings(Register (ptr32 Eq_2) gs, Stack ptr32 dwArg04, Stack (ptr32 Eq_4994) dwArg08, Stack Eq_4 dwArg0C)
// Called from:
//      runtime.(*TypeAssertionError).Error
//      runtime.panicwrap
//      runtime.concatstring2
//      runtime.concatstring3
//      runtime.concatstring4
//      runtime.concatstring5
Eq_4 runtime.concatstrings(struct Eq_2 * gs, ptr32 dwArg04, struct Eq_4994 * dwArg08, Eq_4 dwArg0C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	struct Eq_67596 * eax_20 = &dwArg08->dw0004;
	Eq_4 ebx_106 = 0x00;
	word32 ebp_233 = 0x00;
	Eq_4 esi_235 = 0x00;
	Eq_4 edi_103 = 0x00;
	while (ebx_106 < dwArg0C)
	{
		word32 edx_217 = eax_20->dw0000;
		if (edx_217 != 0x00)
		{
			Eq_4 edx_221 = (word32) edi_103 + edx_217;
			if (edx_221 < edi_103)
				runtime.throw(gs);
			++ebp_233;
			esi_235 = ebx_106;
			edi_103 = edx_221;
		}
		++eax_20;
		ebx_106 = (word32) ebx_106 + 1;
	}
	if (ebp_233 == 0x00)
		return ebx_106;
	if (ebp_233 != 0x01)
	{
l080801CC:
		runtime.rawstringtmp(ebx_106, gs, dwArg04, edi_103);
		Eq_4 eax_120 = dwLoc30;
		Eq_4 ecx_121 = dwLoc34;
		word32 ebp_126 = dwLoc2C;
		Eq_4 esi_127 = 0x00;
		struct Eq_4994 * edi_130 = dwArg08;
		while (esi_127 < dwArg0C)
		{
			Eq_4 edx_154;
			Eq_4 edx_149 = edi_130->dw0004;
			Eq_4 ebx_151 = edi_130->a0000[0];
			edx_154 = edx_149;
			if (eax_120 <= edx_149)
				edx_154 = eax_120;
			word128 xmm1_466;
			word128 xmm2_467;
			word128 xmm0_465;
			word32 ebp_462;
			word32 edi_464;
			word32 esi_463;
			runtime.memmove(ecx_121, ebx_151, edx_154, out ebp_462, out esi_463, out edi_464, out xmm0_465, out xmm1_466, out xmm2_467);
			if (edx_149 > eax_120)
				runtime.panicslice(gs);
			word32 ebp_194 = ebp_126 - edx_149;
			++edi_130;
			esi_127 = (word32) esi_127 + 1;
			ebp_126 = ebp_194;
			ecx_121 = (word32) ecx_121 + (edx_149 & -ebp_194 >> 0x1F);
			eax_120 -= edx_149;
		}
		return dwLoc3C;
	}
	else
	{
		if (dwArg04 == 0x00)
		{
			if (esi_235 >= dwArg0C)
				runtime.panicindex(gs);
			uip32 edx_459;
			Eq_4 ebp_62 = gs->ptr0000->tFFFFFFFC;
			Eq_4 ebx_57 = dwArg08[esi_235];
			Eq_4 edx_63 = *((word32) ebp_62 + 4);
			ebx_106 = ebx_57;
			word24 edx_24_8_361 = SLICE(edx_63, word24, 8);
			if (*ebp_62 <= ebx_57)
				edx_459 = SEQ(edx_24_8_361, (int8) (ebx_57 < edx_63));
			else
				edx_459 = 0x00;
			if ((byte) edx_459 != 0x00)
				goto l080801CC;
		}
		if (esi_235 < dwArg0C)
			return ebx_106;
		runtime.panicindex(gs);
	}
}

// 08080310: void runtime.concatstring2(Register (ptr32 Eq_2) gs, Stack ptr32 dwArg04)
// Called from:
//      runtime.interhash
//      runtime.nilinterhash
//      runtime.efaceeq
//      runtime.ifaceeq
//      runtime.errorString.Error
//      runtime.panicwrap
//      runtime.(*errorString).Error
//      syscall.itoa
//      syscall.Errno.Error
//      time.init
//      reflect.newName
//      reflect.Kind.String
//      reflect.ChanDir.String
//      reflect.(*rtype).ptrTo
//      reflect.funcLayout
//      reflect.(*sliceType).Bits
void runtime.concatstring2(struct Eq_2 * gs, ptr32 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.concatstrings(gs, dwArg04, (word32) fp + 8, 0x02);
}

// 08080370: Register word32 runtime.concatstring3(Register (ptr32 Eq_2) gs, Stack ptr32 dwArg04)
// Called from:
//      runtime.SetFinalizer
//      reflect.funcLayout
//      reflect.(*ValueError).Error
//      reflect.flag.mustBeAssignable
//      reflect.methodReceiver
//      reflect.Value.String
//      fmt.(*fmt).fmt_q
word32 runtime.concatstring3(struct Eq_2 * gs, ptr32 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	return runtime.concatstrings(gs, dwArg04, (word32) fp + 8, 0x03);
}

// 080803D0: void runtime.concatstring4(Register (ptr32 Eq_2) gs, Stack ptr32 dwArg04)
// Called from:
//      runtime.(*TypeAssertionError).Error
//      runtime.SetFinalizer
void runtime.concatstring4(struct Eq_2 * gs, ptr32 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.concatstrings(gs, dwArg04, (word32) fp + 8, 0x04);
}

// 08080430: void runtime.concatstring5(Register (ptr32 Eq_2) gs, Stack ptr32 dwArg04)
// Called from:
//      runtime.SetFinalizer
//      os.(*PathError).Error
//      reflect.funcLayout
//      reflect.(*ValueError).Error
//      reflect.Value.assignTo
void runtime.concatstring5(struct Eq_2 * gs, ptr32 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.concatstrings(gs, dwArg04, (word32) fp + 8, 0x05);
}

// 08080490: Register word32 runtime.slicebytetostring(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C)
// Called from:
//      runtime.gcMarkTermination
//      strconv.(*decimal).String
//      strconv.formatBits
//      syscall.uitoa
//      os.Readlink
//      reflect.funcStr
//      reflect.cvtBytesString
//      fmt.(*pp).fmtBytes
word32 runtime.slicebytetostring(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (dwArg0C == 0x00)
		return esi;
	Eq_4 ecx_27 = dwArg04;
	if (dwArg04 == 0x00 || dwArg0C > 0x20)
	{
		word32 ebx_179;
		word32 esi_180;
		word32 edi_181;
		runtime.mallocgc(ebx, gs, dwArg0C, 0x00, 0x00, out ebx_179, out esi_180, out edi_181);
		ecx_27 = dwLoc04;
	}
	word32 esi_56;
	word32 ebp_182;
	word32 edi_183;
	word128 xmm0_184;
	word128 xmm1_185;
	word128 xmm2_186;
	runtime.memmove(ecx_27, dwArg08, dwArg0C, out ebp_182, out esi_56, out edi_183, out xmm0_184, out xmm1_185, out xmm2_186);
	return esi_56;
}

// 08080530: void runtime.rawstringtmp(Register Eq_4 ebx, Register (ptr32 Eq_2) gs, Stack ptr32 dwArg04, Stack Eq_4 dwArg08)
// Called from:
//      runtime.concatstrings
//      runtime.slicerunetostring
void runtime.rawstringtmp(Eq_4 ebx, struct Eq_2 * gs, ptr32 dwArg04, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (dwArg04 == 0x00 || dwArg08 > 0x20)
		runtime.rawstring(ebx, gs, dwArg08);
	else
	{
		if (dwArg08 <= 0x20)
			return;
		runtime.panicslice(gs);
	}
}

// 080805B0: void runtime.stringtoslicebyte(Register Eq_4 ebx, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg00, Stack (ptr32 Eq_4) dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C)
// Called from:
//      reflect.cvtStringBytes
void runtime.stringtoslicebyte(Eq_4 ebx, struct Eq_2 * gs, Eq_4 dwArg00, union Eq_4 * dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 edx_43;
	Eq_4 ecx_42;
	if (dwArg04 != null && dwArg0C <= 0x20)
	{
		fn0808FD88(0x00, dwArg04);
		ecx_42 = dwArg08;
		edx_43 = dwArg00;
	}
	else
	{
		runtime.rawbyteslice(ebx, gs, dwArg0C);
		ecx_42 = dwLoc14;
		edx_43 = dwLoc18;
	}
	Eq_4 ebx_58 = dwArg0C;
	if (ecx_42 <= dwArg0C)
		ebx_58 = ecx_42;
	word128 xmm2_148;
	word32 edi_145;
	word128 xmm0_146;
	word128 xmm1_147;
	word32 esi_144;
	word32 ebp_143;
	runtime.memmove(edx_43, dwArg08, ebx_58, out ebp_143, out esi_144, out edi_145, out xmm0_146, out xmm1_147, out xmm2_148);
}

// 08080660: void runtime.stringtoslicerune(Register Eq_4 ebx, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg00, Stack (ptr32 Eq_38456) dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C)
// Called from:
//      reflect.cvtStringRunes
void runtime.stringtoslicerune(Eq_4 ebx, struct Eq_2 * gs, Eq_4 dwArg00, struct Eq_38456 * dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 eax_157 = 0x00;
	Eq_67933 ecx_154 = 0x00;
	while (eax_157 < dwArg0C)
	{
		Eq_4 ebp_148;
		if (CONVERT(Mem23[dwArg08 + eax_157:byte], byte, word32) < 0x80)
			ebp_148 = (word32) eax_157 + 1;
		else
		{
			runtime.decoderune(gs, dwArg08, dwArg0C, eax_157);
			dwLoc20 = dwArg0C;
			dwLoc1C = eax_157;
			ebp_148 = dwLoc14;
		}
		ebx = dwArg08;
		ecx_154 = (word32) ecx_154 + 1;
		eax_157 = ebp_148;
	}
	Eq_4 ebx_53;
	Eq_4 eax_54;
	if (dwArg04 != null && ecx_154 <= 0x20)
	{
		fn0808FD70(0x00, dwArg04);
		if (ecx_154 > 0x20)
			runtime.panicslice(gs);
		eax_54 = dwLoc10;
		ebx_53 = dwArg00;
	}
	else
	{
		runtime.rawruneslice(ebx, gs, ecx_154);
		ebx_53 = dwLoc20;
		eax_54 = dwLoc1C;
	}
	Eq_4 edx_112 = dwArg0C;
	Eq_4 ebp_110 = 0x00;
	Eq_4 esi_125 = 0x00;
	ebx_113 = ebx_53;
	eax_111 = eax_54;
	while (true)
	{
		Eq_4 eax_111;
		Eq_4 ebx_113;
		if (ebp_110 >= edx_112)
			break;
		word32 ecx_109 = CONVERT(Mem87[dwArg08 + ebp_110:byte], byte, word32);
		if (ecx_109 < 0x80)
			ebp_110 = (word32) ebp_110 + 1;
		else
		{
			runtime.decoderune(gs, dwArg08, edx_112, ebp_110);
			ecx_109 = dwLoc18;
			ebp_110 = dwLoc14;
			eax_111 = eax_54;
			edx_112 = dwArg0C;
			ebx_113 = ebx_53;
		}
		if (esi_125 >= eax_111)
			runtime.panicindex(gs);
		*((word32) ebx_113 + esi_125 * 0x04) = ecx_109;
		esi_125 = (word32) esi_125 + 1;
	}
}

// 080807B0: void runtime.slicerunetostring(Register (ptr32 Eq_2) gs, Stack ptr32 dwArg04, Stack (ptr32 word32) dwArg08, Stack Eq_4 dwArg0C)
// Called from:
//      reflect.cvtRunesString
void runtime.slicerunetostring(struct Eq_2 * gs, ptr32 dwArg04, word32 * dwArg08, Eq_4 dwArg0C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 eax_18 = 0x00;
	word32 * ecx_21 = dwArg08;
	Eq_4 edx_22 = 0x00;
	while (eax_18 < dwArg0C)
	{
		Eq_4 eax_33 = *ecx_21;
		runtime.encoderune(gs, fp - 0x1C, 0x04, eax_33);
		dwLoc38 = eax_33;
		++ecx_21;
		eax_18 = (word32) eax_18 + 1;
		edx_22 = (word32) edx_22 + dwLoc34;
	}
	runtime.rawstringtmp(dwArg0C, gs, dwArg04, (word32) edx_22 + 3);
	Eq_4 esi_143 = 0x00;
	Eq_4 dwLoc28_191 = 0x00;
	word32 * edi_141 = dwArg08;
	while (esi_143 < dwArg0C)
	{
		Eq_4 ebx_97 = *edi_141;
		if (dwLoc28_191 >= edx_22)
			break;
		if (dwLoc28_191 > dwLoc30)
			runtime.panicslice(gs);
		runtime.encoderune(gs, (dwLoc28_191 - dwLoc2C >> 0x1F & dwLoc28_191) + dwLoc34, dwLoc30 - dwLoc28_191, ebx_97);
		++edi_141;
		esi_143 = (word32) esi_143 + 1;
		dwLoc28_191 = (word32) dwLoc28_191 + dwLoc34;
	}
	if (dwLoc28_191 <= dwLoc38)
		return;
	runtime.panicslice(gs);
}

// 08080920: void runtime.intstring(Register Eq_4 ebx, Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_68031) dwArg04, Stack Eq_4 dwArg08, Stack int32 dwArg0C)
// Called from:
//      reflect.cvtIntString
//      reflect.cvtUintString
void runtime.intstring(Eq_4 ebx, struct Eq_2 * gs, struct Eq_68031 * dwArg04, Eq_4 dwArg08, int32 dwArg0C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	up32 ecx_38;
	up32 ebx_36;
	struct Eq_68031 * eax_17 = dwArg04;
	if (dwArg04 != null)
	{
		ecx_38 = 0x04;
		ebx_36 = 0x04;
	}
	else
	{
		runtime.rawstring(ebx, gs, 0x04);
		ebx_36 = dwLoc18;
		eax_17 = dwLoc14;
		ecx_38 = dwLoc10;
	}
	Eq_4 ebp_55;
	if (dwArg08 >> 0x1F != dwArg0C)
		ebp_55.u0 = 0xFFFD;
	else
		ebp_55 = dwArg08;
	runtime.encoderune(gs, eax_17, ecx_38, ebp_55);
	if (dwLoc10 <= ebx_36)
		return;
	runtime.panicslice(gs);
}

// 080809E0: void runtime.rawstring(Register Eq_4 ebx, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      runtime.rawstringtmp
//      runtime.intstring
//      runtime.gostring
void runtime.rawstring(Eq_4 ebx, struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	word32 ebx_73;
	word32 esi_74;
	word32 edi_75;
	runtime.mallocgc(ebx, gs, dwArg04, 0x00, 0x00, out ebx_73, out esi_74, out edi_75);
}

// 08080A60: void runtime.rawbyteslice(Register Eq_4 ebx, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      runtime.stringtoslicebyte
void runtime.rawbyteslice(Eq_4 ebx, struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 ecx_27;
	if (dwArg04 >= 0x8000)
	{
		if ((word32) dwArg04 + 0x00002000 < dwArg04)
			ecx_27 = dwArg04;
		else
			ecx_27 = (word32) dwArg04 + 0x00001FFF & ~0x1FFF;
l08080ADA:
		word32 ebx_139;
		word32 esi_140;
		word32 edi_141;
		runtime.mallocgc(ebx, gs, ecx_27, 0x00, 0x00, out ebx_139, out esi_140, out edi_141);
		if (ecx_27 != dwArg04)
			runtime.memclrNoHeapPointers((word32) dwArg04 + dwLoc0C, ecx_27 - dwArg04);
	}
	else
	{
		if (dwArg04 <= 1016)
		{
			struct Eq_68170 * ecx_45 = (word32) dwArg04 + 7 >> 0x03;
			if (ecx_45 < (struct Eq_68170 *) 0x81)
			{
				uint32 ecx_49 = (word32) ecx_45->b8138640;
				if (ecx_49 < 0x43)
				{
					ecx_27 = (word32) g_a8138820[ecx_49 * 0x02];
					goto l08080ADA;
				}
			}
			runtime.panicindex(gs);
		}
		struct Eq_68163 * ecx_34 = dwArg04 - 0x0381 >> 0x07;
		if (ecx_34 < (struct Eq_68163 *) 0xF9)
		{
			uint32 ecx_38 = (word32) ecx_34->b81396E0;
			if (ecx_38 < 0x43)
			{
				ecx_27 = (word32) g_a8138820[ecx_38 * 0x02];
				goto l08080ADA;
			}
		}
		runtime.panicindex(gs);
	}
}

// 08080BA0: void runtime.rawruneslice(Register Eq_4 ebx, Register (ptr32 Eq_2) gs, Stack Eq_67933 dwArg04)
// Called from:
//      runtime.stringtoslicerune
void runtime.rawruneslice(Eq_4 ebx, struct Eq_2 * gs, Eq_67933 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (dwArg04 > 0x3FFFFFFF)
		runtime.throw(gs);
	Eq_4 edx_40;
	if (dwArg04 << 0x02 >= 0x8000)
	{
		if ((dwArg04 << 0x02) + 0x2000 < dwArg04 << 0x02)
			edx_40 = dwArg04 << 0x02;
		else
			edx_40 = (dwArg04 << 0x02) + 0x1FFF & ~0x1FFF;
l08080C2C:
		word32 ebx_159;
		word32 esi_160;
		word32 edi_161;
		runtime.mallocgc(ebx, gs, edx_40, 0x00, 0x00, out ebx_159, out esi_160, out edi_161);
		if (edx_40 != dwArg04 << 0x02)
			runtime.memclrNoHeapPointers(dwLoc10 + dwArg04 * 0x04, edx_40 - (dwArg04 << 0x02));
	}
	else
	{
		if (dwArg04 << 0x02 <= 1016)
		{
			uint32 edx_57 = (dwArg04 << 0x02) + 0x07;
			if (edx_57 >> 0x03 < 0x81)
			{
				uint32 edx_62 = (word32) (edx_57 >> 0x03)->b8138640;
				if (edx_62 < 0x43)
				{
					ebx.u0 = 0x08138820;
					edx_40 = (word32) g_a8138820[edx_62 * 0x02];
					goto l08080C2C;
				}
			}
			runtime.panicindex(gs);
		}
		uint32 edx_46 = (dwArg04 << 0x02) - 0x0381;
		if (edx_46 >> 0x07 < 0xF9)
		{
			uint32 edx_51 = (word32) (edx_46 >> 0x07)->b81396E0;
			if (edx_51 < 0x43)
			{
				ebx.u0 = 0x08138820;
				edx_40 = (word32) g_a8138820[edx_51 * 0x02];
				goto l08080C2C;
			}
		}
		runtime.panicindex(gs);
	}
}

// 08080D20: Register Eq_4 runtime.gostring(Register Eq_4 ebx, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      runtime.goenvs_unix
//      runtime.expandCgoFrames
Eq_4 runtime.gostring(Eq_4 ebx, struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.findnull(dwArg04);
	if (dwLoc20 == 0x00)
		return ebx;
	runtime.rawstring(ebx, gs, dwLoc20);
	if (dwLoc14 <= 0x00)
		runtime.panicindex(gs);
	else
	{
		word128 xmm2_175;
		word128 xmm1_174;
		word128 xmm0_173;
		word32 edi_172;
		word32 esi_171;
		word32 ebp_170;
		return runtime.memmove(dwLoc18, dwArg04, dwLoc20, out ebp_170, out esi_171, out edi_172, out xmm0_173, out xmm1_174, out xmm2_175);
	}
}

// 08080DD0: void runtime.index(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C, Stack Eq_4 dwArg10)
// Called from:
//      runtime.parsedebugvars
//      runtime.contains
void runtime.index(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C, Eq_4 dwArg10)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 eax_118 = dwArg10;
	if (dwArg10 == 0x00)
		return;
	Eq_4 ecx_105 = 0x00;
	while (ecx_105 < dwArg08)
	{
		if (ecx_105 >= dwArg08)
			runtime.panicindex(gs);
		if (Mem28[dwArg04 + ecx_105:byte] == Mem28[dwArg0C + 0x00:byte])
		{
			uip32 edx_207;
			Eq_4 edx_65 = dwArg08 - ecx_105;
			Eq_4 edx_70 = (word32) dwArg04 + (-edx_65 >> 0x1F & ecx_105);
			if (edx_65 < eax_118)
				edx_207 = 0x00;
			else
			{
				word32 ebx_209;
				word32 esi_210;
				word32 edi_211;
				runtime.eqstring(edx_70, edx_70, eax_118, dwArg0C, out ebx_209, out esi_210, out edi_211);
				edx_207 = (word32) bLoc08;
				eax_118 = dwArg10;
			}
			if ((byte) edx_207 != 0x00)
				return;
		}
		ecx_105 = (word32) ecx_105 + 1;
	}
}

// 08080EB0: void runtime.contains(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.showframe
void runtime.contains(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.index(gs, dwArg04, dwArg08, dwArg0C, dwArg10);
}

// 08080F10: Register Eq_59692 runtime.atoi(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Register out Eq_59692 esiOut)
// Called from:
//      runtime.parsedebugvars
//      runtime/debug.SetTraceback
//      runtime.atoi32
Eq_59692 runtime.atoi(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, union Eq_59692 & esiOut)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (dwArg08 == 0x00)
	{
		esiOut = esi;
		return ebp;
	}
	else
	{
		Eq_4 eax_138;
		byte cl_133;
		Eq_4 edx_132;
		if (*dwArg04 == 0x2D)
		{
			edx_132 = dwArg08 - 0x01;
			eax_138 = (word32) dwArg04 + (0x01 - dwArg08 >> 0x1F & 0x01);
			cl_133 = 0x01;
		}
		else
		{
			eax_138 = dwArg04;
			edx_132 = dwArg08;
			cl_133 = 0x00;
		}
		Eq_4 ebx_125 = 0x00;
		Eq_59692 ebp_127 = 0x00;
		while (ebx_125 < edx_132)
		{
			if (ebx_125 >= edx_132)
				runtime.panicindex(gs);
			word32 esi_94 = CONVERT(Mem0[eax_138 + ebx_125:byte], byte, word32);
			if ((byte) esi_94 > 0x39 || (byte) esi_94 < 0x30)
			{
				esiOut = esi_94;
				return ebp_127;
			}
			if (ebp_127 > 0x19999999)
			{
				esiOut = esi_94;
				return ebp_127;
			}
			ui32 ebp_111 = ebp_127 * 0x05;
			esi = (word32) (byte) esi_94 - 0x30 + ebp_111 * 0x02;
			if (esi < ebp_111 << 0x01)
			{
				esiOut = esi;
				return ebp_111 << 0x01;
			}
			ebx_125 = (word32) ebx_125 + 1;
			ebp_127 = esi;
		}
		bool v29_140 = cl_133 == 0x00;
		if (cl_133 == 0x00)
		{
			if (ebp_127 > 0x7FFFFFFF)
			{
				esiOut = esi;
				return ebp_127;
			}
			v29_140 = cl_133 == 0x00;
		}
		if (!v29_140)
		{
			if (ebp_127 > 0x80000000)
			{
				esiOut = esi;
				return ebp_127;
			}
			v29_140 = cl_133 == 0x00;
		}
		if (!v29_140)
			ebp_127 = -ebp_127;
		esiOut = esi;
		return ebp_127;
	}
}

// 08081040: Register word32 runtime.atoi32(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Register out ptr32 esiOut)
// Called from:
//      runtime.readgogc
//      runtime.schedinit
//      runtime.parsedebugvars
word32 runtime.atoi32(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, ptr32 & esiOut)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	ptr32 esi_28;
	word32 ebp_25 = runtime.atoi(gs, dwArg04, dwArg08, out esi_28);
	esiOut = esi_28;
	return ebp_25;
}

// 08081090: void runtime.findnull(Stack Eq_4 dwArg04)
// Called from:
//      runtime.gostring
//      runtime.gostringnocopy
void runtime.findnull(Eq_4 dwArg04)
{
	if (dwArg04 == 0x00)
		return;
	Eq_68546 ecx_10 = 0x00;
	while (ecx_10 < 0x7FFFFFFE)
	{
		if (Mem0[dwArg04 + ecx_10:byte] == 0x00)
			return;
		ecx_10 = (word32) ecx_10 + 1;
	}
	runtime.panicindex(gs);
}

// 080810D0: Register Eq_4 runtime.gostringnocopy()
// Called from:
//      runtime.goargs
//      runtime.funcname
//      runtime.funcnameFromNameoff
//      runtime.funcfile
//      runtime.funcline1
//      runtime.printOneCgoTraceback
Eq_4 runtime.gostringnocopy()
{
	runtime.findnull(dwArg04);
	return <invalid>;
}

// 08081100: Register word32 runtime.badsystemstack(Register (ptr32 Eq_2) gs, Register out (ptr32 Eq_68565) edxOut)
// Called from:
//      runtime.systemstack
word32 runtime.badsystemstack(struct Eq_2 * gs, struct Eq_68565 & edxOut)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.throw(gs);
}

// 08081140: void reflect.memclrNoHeapPointers(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
// Called from:
//      reflect.callMethod
void reflect.memclrNoHeapPointers(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.memclrNoHeapPointers(dwArg04, dwArg08);
}

// 08081180: void runtime.CallersFrames(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C)
// Called from:
//      runtime.panicwrap
void runtime.CallersFrames(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 edx_41;
	Eq_4 ebp_54;
	runtime.newobject(gs, 0x080D36E0);
	Eq_4 ecx_28 = dwArg08;
	if (dwArg08 >= 0x01 && *dwArg04 - runtime.skipPC < 0x0100)
	{
		ebp_54 = dwArg0C - 0x01;
		edx_41 = (word32) dwArg04 + (0x01 - dwArg0C >> 0x1F & 0x04);
		ecx_28 = dwArg08 - 0x01;
	}
	else
	{
		edx_41 = dwArg04;
		if (dwArg08 >= 0x02)
		{
			Eq_4 ebx_45 = *((word32) dwArg04 + 4) - runtime.skipPC;
			if (ebx_45 < 0x0100)
				*((word32) dwLoc08 + 64) = ebx_45;
		}
		ebp_54 = dwArg0C;
	}
	*((word32) dwLoc08 + 4) = ecx_28;
	*((word32) dwLoc08 + 8) = ebp_54;
	if (g_t81576F0 == 0x00)
		*dwLoc08 = edx_41;
	else
		runtime.writebarrierptr(dwLoc08, edx_41);
}

// 08081240: void runtime.(*Frames).Next(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg08)
// Called from:
//      runtime.panicwrap
void runtime.(*Frames).Next(struct Eq_2 * gs, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	fn0808FD88(0x00, (word32) fp + 8);
	fn0808FD88(0x00, fp - 0x24);
	runtime.(*stackExpander).next(gs, dwLoc74, (char *) &dwLoc04->t0004 + 8, dwLoc04->t0000, dwLoc04->t0004);
	fn08090250(fp - 0x44, fp - 0x18);
	*((word32) dwArg08 + 4) = dwLoc4C;
	*((word32) dwArg08 + 8) = dwLoc48;
	if (g_t81576F0 == 0x00)
		*dwArg08 = dwLoc20;
	else
		runtime.writebarrierptr(dwArg08, dwLoc20);
	fn08090250(fp - 0x1C, (word32) fp + 0x0C);
}

// 08081310: void runtime.(*stackExpander).next(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg00, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C)
// Called from:
//      runtime.Caller
//      runtime.(*Frames).Next
void runtime.(*stackExpander).next(struct Eq_2 * gs, Eq_4 dwArg00, Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 ebx_122;
	Eq_4 edx_159;
	Eq_4 ecx_119;
	Eq_4 eax_180;
	fn0808FD88(0x00, (word32) fp + 32);
	Eq_4 esp_127 = fp - 0x38;
	if (*dwArg00 == 0x00)
	{
		if (dwArg08 == 0x00)
		{
			((word32) dwArg00 + 48)->u0 = 0x00;
			fn08090250(0x080F1E80, (word32) fp + 28);
			return;
		}
		Eq_4 al_105;
		runtime.(*pcExpander).init(gs, dwArg00, *dwArg04, *((word32) dwArg00 + 48));
		edx_159 = dwArg0C - 0x01;
		Eq_4 ecx_148 = (word32) dwArg04 + (0x01 - dwArg0C >> 0x1F & 0x04);
		ebx_122 = dwArg00;
		Eq_4 ebp_92 = *((word32) dwArg00 + 20);
		if (ebp_92 != 0x00)
			al_105.u0 = (int8) (*ebp_92 == runtime.sigpanicPC);
		else
			al_105.u0 = 0x00;
		Eq_4 eax_118;
		*((word32) dwArg00 + 48) = al_105;
		Eq_4 esi_150 = dwArg0C;
		Eq_4 ebp_112 = dwArg08 - 0x01;
		Eq_4 edi_113 = dwArg08;
		if (*((word32) dwArg00 + 52) > 0x00)
		{
			while (*((word32) ebx_122 + 52) > 0x00)
			{
				*esp_127 = ebx_122;
				runtime.(*pcExpander).next(gs, *((word32) esp_127 - 4));
				esp_127.u0 = <invalid>;
				ebx_122 = *((byte) esp_127.u0 + 56);
				--*((word32) ebx_122 + 52);
				ecx_148 = *((byte) esp_127.u0 + 48);
				ebp_112 = *((byte) esp_127.u0 + 40);
				esi_150 = *((byte) esp_127.u0 + 0x0044);
				edi_113 = *((byte) esp_127.u0 + 64);
			}
			((word32) ebx_122 + 52)->u0 = 0x00;
			if (ebp_112 < 0x01)
				runtime.panicslice(gs);
			Eq_4 eax_158 = esi_150 - 0x02;
			edx_159 = eax_158;
			eax_118 = (word32) ecx_148 + (-eax_158 >> 0x1F & 0x04);
			ecx_119 = edi_113 - 0x02;
		}
		else
		{
			eax_118 = ecx_148;
			ecx_119 = dwArg08 - 0x01;
		}
		esp_127 = fp - 48;
		eax_180 = eax_118;
		if (*ebx_122 == 0x00)
		{
			fn08090250(0x080F1EA0, (word32) fp + 36);
			return;
		}
	}
	else
	{
		ebx_122 = dwArg00;
		eax_180 = dwArg04;
		ecx_119 = dwArg08;
		edx_159 = dwArg0C;
	}
	*((byte) esp_127.u0 + 44) = eax_180;
	*((byte) esp_127.u0 + 40) = ecx_119;
	*((byte) esp_127.u0 + 36) = edx_159;
	*esp_127.u0 = ebx_122;
	runtime.(*pcExpander).next(gs, *((byte) esp_127.u0 - 4));
	fn08090250(fp - 44, (word32) fp + 36);
	*dwArg04 == 0x00;
}

// 08081510: void runtime.(*pcExpander).init(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 bArg0C)
// Called from:
//      runtime.(*stackExpander).next
void runtime.(*pcExpander).init(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 bArg0C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	*dwArg04 = 0x00;
	runtime.findfunc(gs, dwArg08);
	if (g_t81576F0 == 0x00)
	{
		*((word32) dwArg04 + 20) = dwLoc24;
		*((word32) dwArg04 + 24) = dwLoc20;
	}
	else
	{
		runtime.writebarrierptr((word32) dwArg04 + 20, dwLoc24);
		runtime.writebarrierptr((word32) dwArg04 + 24, dwLoc20);
	}
	if (*((word32) dwArg04 + 20) == 0x00)
	{
		if (runtime.cgoSymbolizer != null)
		{
			runtime.expandCgoFrames(gs);
			Eq_4 esp_86 = <invalid>;
			Eq_4 eax_103 = *((word32) esp_86 + 0x0C);
			Eq_4 edx_105 = *((word32) esp_86 + 4);
			Eq_4 ebx_106 = *((word32) esp_86 + 44);
			*((word32) ebx_106 + 0x0C) = *((word32) esp_86 + 8);
			*((word32) ebx_106 + 16) = eax_103;
			if (g_t81576F0 == 0x00)
				*((word32) ebx_106 + 8) = edx_105;
			else
			{
				*esp_86 = (word32) ebx_106 + 8;
				*((word32) esp_86 + 4) = edx_105;
				runtime.writebarrierptr(*esp_86, *((word32) esp_86 + 4));
				ebx_106 = *((word32) esp_86 + 44);
			}
			ebx_106->u0 = (int8) (*((word32) ebx_106 + 0x0C) > 0x00);
		}
	}
	else
	{
		*dwArg04 = 0x01;
		Eq_4 eax_139 = **((word32) dwArg04 + 20);
		*((word32) dwArg04 + 4) = dwArg08;
		if (dwArg08 > eax_139 && bArg0C == 0x00)
			*((word32) dwArg04 + 4) = dwArg08 - 0x01;
		runtime.funcline1(gs, *((word32) dwArg04 + 20), *((word32) dwArg04 + 24), 0x00);
		*((word32) dwArg04 + 36) = dwLoc14;
		Eq_4 dwLoc1C_332 = SEQ(nLoc1B, 0x00);
		if (g_t81576F0 == 0x00)
			*((word32) dwArg04 + 32) = dwLoc18;
		else
			runtime.writebarrierptr((word32) dwArg04 + 32, dwLoc18);
		*((word32) dwArg04 + 40) = dwLoc10;
		runtime.funcdata(gs, *((word32) dwArg04 + 20), 0x02);
		if (dwLoc1C_332 != 0x00)
		{
			if (g_t81576F0 == 0x00)
				*((word32) dwArg04 + 28) = dwLoc1C_332;
			else
				runtime.writebarrierptr((word32) dwArg04 + 28, dwLoc1C_332);
			runtime.pcdatavalue(gs, *((word32) dwArg04 + 20), 0x01);
			*((word32) dwArg04 + 44) = dwLoc14;
		}
		else
		{
			if (g_t81576F0 == 0x00)
				((word32) dwArg04 + 28)->u0 = 0x00;
			else
				runtime.writebarrierptr((word32) dwArg04 + 28, 0x00);
			((word32) dwArg04 + 44)->u0 = ~0x00;
		}
	}
}

// 08081750: void runtime.(*pcExpander).next(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg00)
// Called from:
//      runtime.(*stackExpander).next
void runtime.(*pcExpander).next(struct Eq_2 * gs, Eq_4 dwArg00)
{
	while (fp - 0x08 <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	fn0808FD88(0x00, (word32) fp + 8);
	if (*dwArg00 == 0x00)
		fn08090250(0x080F1EC0, (word32) fp + 4);
	else
	{
		Eq_4 esi_43 = *((word32) dwArg00 + 8);
		if (*((word32) dwArg00 + 0x0C) <= 0x00)
		{
			Eq_4 eax_47 = *((word32) dwArg00 + 44);
			if (eax_47 < 0x00)
			{
				*dwArg00 = 0x00;
				runtime.funcname(gs, *((word32) dwArg00 + 20), *((word32) dwArg00 + 24));
				fn08090250(0x080F1F00, fp - 0x24);
				fn08090250(fp - 0x28, fp);
			}
			else
			{
				Eq_4 edx_106 = *((word32) dwArg00 + 28);
				if (eax_47 >= 0x00100000)
					runtime.panicindex(gs);
				else
				{
					Eq_4 ebp_115 = *((word32) edx_106 + (eax_47 * 0x10 + 8));
					word32 esi_117 = *((word32) edx_106 + eax_47 * 0x10);
					Eq_4 eax_119 = *((word32) edx_106 + (eax_47 * 0x10 + 0x0C));
					runtime.funcnameFromNameoff(gs, *((word32) dwArg00 + 20), *((word32) dwArg00 + 24), eax_119);
					fn08090250(0x080F1EE0, fp - 100);
					runtime.funcfile(gs, dwLoc04->t0014, dwLoc04->t0018, ebp_115);
					dwLoc04->dw0024 = dwLoc80;
					if (g_t81576F0 == 0x00)
						dwLoc04->t0020 = eax_119;
					else
						runtime.writebarrierptr(&dwLoc04->t0020, eax_119);
					dwLoc04->dw0028 = esi_117;
					dwLoc04->dw002C = dwLoc7C;
					fn08090250(fp - 0x68, fp);
				}
			}
		}
		else
		{
			fn08090250(esi_43, fp - 0x44);
			int32 ecx_226 = dwLoc04->dw0010;
			Eq_4 ebx_227 = dwLoc04->t0008;
			Eq_69189 ebp_228 = dwLoc04->t000C;
			if (ebp_228 < 0x01)
				runtime.panicslice(gs);
			else
			{
				dwLoc04->t000C = ebp_228 - 0x01;
				dwLoc04->dw0010 = ecx_226 - 0x01;
				Eq_4 ecx_239 = (word32) ebx_227 + (0x01 - ecx_226 >> 0x1F & 0x20);
				if (g_t81576F0 == 0x00)
					dwLoc04->t0008 = ecx_239;
				else
					runtime.writebarrierptr((word32) dwArg00 + 8, ecx_239);
				dwLoc04->b0000 = (int8) (dwLoc04->t000C > 0x00);
				fn08090250(fp - 0x48, fp);
			}
		}
	}
}

// 08081A00: void runtime.expandCgoFrames(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.(*pcExpander).init
void runtime.expandCgoFrames(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	fn0808FD89(0x00, fp - 0x3C);
	runtime.callCgoSymbolizer(gs);
	struct Eq_69361 * esp_22 = fp - 0x7C;
	if (dwLoc3C == 0x00 && dwLoc34 == 0x00)
		return;
	word32 eax_241 = 0x00;
	word32 ecx_242 = 0x00;
	word32 edx_243 = 0x00;
	while (true)
	{
		Eq_4 ebp_165;
		esp_22->dw0024 = eax_241;
		esp_22->dw0020 = ecx_242;
		esp_22->dw0038 = edx_243;
		Eq_4 ebx_59 = esp_22->t0048;
		esp_22->t0000 = ebx_59;
		Eq_4 ebx_66 = runtime.gostring(ebx_59, gs, esp_22->t0000);
		esp_22->dw0034 = esp_22->dw0004;
		esp_22->dw002C = esp_22->dw0008;
		esp_22->t0000 = esp_22->t0040;
		runtime.gostring(ebx_66, gs, esp_22->t0000);
		word32 eax_106 = esp_22->dw0004;
		esp_22->dw0028 = esp_22->dw0008;
		fn08090250(0x080F1F20, (char *) &esp_22->t0048 + 16);
		struct Eq_69437 * esp_118 = (char *) esp_22 - 4;
		esp_118->dw0058 = esp_118->dw007C;
		esp_118->dw005C = 0x00;
		esp_118->dw0060 = esp_118->dw0034;
		esp_118->dw0064 = esp_118->dw002C;
		esp_118->dw0068 = eax_106;
		esp_118->dw006C = esp_118->dw0028;
		esp_118->dw0070 = esp_118->dw0044;
		esp_118->dw0074 = esp_118->dw004C;
		Eq_4 eax_133 = esp_118->t0020;
		Eq_4 edx_134 = (word32) eax_133 + 1;
		Eq_4 ebx_135 = esp_118->t0024;
		if ((word32) eax_133 + 1 <= ebx_135)
			ebp_165 = esp_118->t0038;
		else
		{
			esp_118->t0000.u0 = 0x080D88A0;
			esp_118->t0004 = esp_118->t0038;
			esp_118->t0008 = eax_133;
			esp_118->t000C = ebx_135;
			esp_118->t0010 = (word32) eax_133 + 1;
			word32 esi_390;
			word128 xmm0_391;
			word128 xmm1_392;
			runtime.growslice(gs, esp_118->t0000, esp_118->t0004, esp_118->t0008, esp_118->t000C, esp_118->t0010, out esi_390, out xmm0_391, out xmm1_392);
			ebp_165 = esp_118->t0014;
			ebx_135 = esp_118->t001C;
			edx_134 = esp_118->dw0018 + 0x01;
			eax_133 = esp_118->t0020;
		}
		esp_118->t0030 = ebp_165;
		esp_118->t0020 = edx_134;
		esp_118->t0024 = ebx_135;
		Eq_4 edi_181 = (word32) ebp_165 + (eax_133 << 0x05);
		if (g_t81576F0 == 0x00)
			fn08090250(&esp_118->dw0058, edi_181);
		else
		{
			esp_118->t0000.u0 = 0x080D88A0;
			esp_118->t0004 = edi_181;
			esp_118->t0008 = &esp_118->dw0058;
			word32 esi_393;
			word128 xmm1_396;
			word32 edi_394;
			word128 xmm0_395;
			runtime.typedmemmove(esp_118->t0000, esp_118->t0004, esp_118->t0008, out esi_393, out edi_394, out xmm0_395, out xmm1_396);
		}
		esp_22 = fp - 0x0078;
		if (dwLoc28 == 0x00)
			break;
		runtime.callCgoSymbolizer(gs);
		eax_241 = dwLoc54;
		ecx_242 = dwLoc58;
		edx_243 = dwLoc48;
	}
	runtime.callCgoSymbolizer(gs);
}

// 08081C20: void runtime.(*Func).funcInfo(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      runtime.(*Func).Name
void runtime.(*Func).funcInfo(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.findmoduledatap(gs, *dwArg04);
}

// 08081C60: void runtime.activeModules()
// Called from:
//      runtime.cgoIsGoPointer
//      runtime.cgoCheckTypedBlock
//      runtime.itabsinit
//      runtime.bulkBarrierPreWrite
//      runtime.gcMarkRootPrepare
//      runtime.markroot
//      reflect.typelinks
//      runtime.typelinksinit
void runtime.activeModules()
{
	runtime/internal/atomic.Loadp();
	if (dwLoc04 == 0x00)
		;
}

// 08081CB0: Register word32 runtime.modulesinit(Register (ptr32 Eq_2) gs, Register out Eq_4 esiOut)
// Called from:
//      runtime.schedinit
word32 runtime.modulesinit(struct Eq_2 * gs, union Eq_4 & esiOut)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.newobject(gs, 0x080C9200);
	Eq_4 ecx_29 = 135500832;
	eax_598 = dwLoc3C;
	while (true)
	{
		Eq_4 eax_598;
		Eq_4 eax_149 = eax_598;
		if (ecx_29 == 0x00)
			break;
		Eq_4 edx_150 = *((word32) eax_598 + 4);
		Eq_4 ebx_151 = *((word32) eax_598 + 8);
		Eq_4 ebp_152 = *eax_598;
		if ((word32) edx_150 + 1 > ebx_151)
		{
			word128 xmm1_607;
			word32 esi_605;
			word128 xmm0_606;
			runtime.growslice(gs, 0x080C7CC0, ebp_152, edx_150, ebx_151, (word32) edx_150 + 1, out esi_605, out xmm0_606, out xmm1_607);
			*((word32) dwLoc3C + 8) = dwLoc24;
			dwLoc38 = edx_150;
			dwLoc34 = ebx_151;
			if (g_t81576F0 == 0x00)
				*dwLoc3C = dwLoc2C;
			else
				runtime.writebarrierptr(dwLoc3C, dwLoc2C);
			edx_150 = dwLoc28;
			ebp_152 = dwLoc2C;
			eax_149 = dwLoc3C;
		}
		*((word32) eax_149 + 4) = (word32) edx_150 + 1;
		Eq_4 ebx_221 = (word32) ebp_152 + edx_150 * 0x04;
		if (g_t81576F0 == 0x00)
			*((word32) ebp_152 + edx_150 * 0x04) = ecx_29;
		else
		{
			runtime.writebarrierptr(ebx_221, ecx_29);
			eax_149 = dwLoc3C;
		}
		Eq_4 eax_600 = eax_149;
		if (*((word32) ecx_29 + 0x00C4) == 0x00)
		{
			Eq_4 ebx_248 = (word32) ecx_29 + 200;
			eax_600 = eax_149;
			if (*((word32) ecx_29 + 200) == 0x00)
			{
				runtime.progToPointerMask(gs, *((word32) ecx_29 + 92), *((word32) ecx_29 + 0x0044) - *((word32) ecx_29 + 64));
				*((word32) ecx_29 + 0x00C4) = dwLoc38;
				if (g_t81576F0 == 0x00)
					*((word32) ecx_29 + 200) = dwLoc34;
				else
					runtime.writebarrierptr(ebx_248, dwLoc34);
				runtime.progToPointerMask(gs, *((word32) ecx_29 + 96), *((word32) ecx_29 + 76) - *((word32) ecx_29 + 72));
				*((word32) ecx_29 + 0x00CC) = dwLoc38;
				if (g_t81576F0 == 0x00)
					*((word32) ecx_29 + 0x00D0) = dwLoc34;
				else
					runtime.writebarrierptr((word32) ecx_29 + 0x00D0, dwLoc34);
				eax_600 = dwLoc3C;
			}
		}
		ecx_29 = *((word32) ecx_29 + 0x00D8);
		eax_598 = eax_600;
	}
	Eq_4 eax_105 = eax_598;
	Eq_4 ecx_46 = *((word32) eax_598 + 4);
	Eq_4 ebx_47 = *eax_598;
	Eq_4 edx_48 = g_t80E7C38;
	Eq_4 esi_50 = 0x00;
	ebx_57 = ebx_47;
	while (true)
	{
		Eq_4 ebx_57;
		if (esi_50 >= ecx_46)
			break;
		Eq_4 edi_59 = *ebx_57;
		if (*((word32) edi_59 + 48) <= edx_48 && edx_48 <= *((word32) edi_59 + 52))
		{
			if (ecx_46 <= 0x00)
				runtime.panicindex(gs);
			if (g_t81576F0 == 0x00)
				*ebx_47 = edi_59;
			else
				runtime.writebarrierptr(ebx_47, edi_59);
			eax_105 = dwLoc3C;
			Eq_4 edx_107 = *dwLoc3C;
			if (esi_50 >= *((word32) dwLoc3C + 4))
				runtime.panicindex(gs);
			else
			{
				Eq_4 ebx_113 = (word32) edx_107 + esi_50 * 0x04;
				if (g_t81576F0 == 0x00)
					*((word32) edx_107 + esi_50 * 0x04) = 135500832;
				else
				{
					runtime.writebarrierptr(ebx_113, 135500832);
					eax_105 = dwLoc3C;
				}
				break;
			}
		}
		ebx_57 = (word32) ebx_57 + 4;
		esi_50 = (word32) esi_50 + 1;
		eax_105 = dwLoc3C;
	}
	word32 ebx_138 = runtime.atomicstorep(135548892, eax_105);
	esiOut = esi_50;
	return ebx_138;
}

// 08081F50: Register word32 runtime.moduledataverify(Register Eq_4 esi, Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.schedinit
word32 runtime.moduledataverify(Eq_4 esi, struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 eax_18 = 135500832;
	while (eax_18 != 0x00)
	{
		ebx = runtime.moduledataverify1(esi, gs, dwLoc0C, eax_18, out esi);
		Eq_4 esp_34 = <invalid>;
		eax_18 = *((word32) *((word32) esp_34 + 4) + 0x00D8);
	}
	return ebx;
}

// 08081FA0: Register Eq_4 runtime.moduledataverify1(Register Eq_4 esi, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg00, Stack Eq_4 dwArg04, Register out Eq_4 esiOut)
// Called from:
//      runtime.moduledataverify
Eq_4 runtime.moduledataverify1(Eq_4 esi, struct Eq_2 * gs, Eq_4 dwArg00, Eq_4 dwArg04, union Eq_4 & esiOut)
{
	while (fp - 0xD8 <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	struct Eq_69921 * ebx_20 = *dwArg04;
	Eq_4 edx_21 = **dwArg04;
	if (edx_21 != ~0x04 || (ebx_20->b0004 != 0x00 || (ebx_20->b0005 != 0x00 || (ebx_20->b0006 != 0x01 || ebx_20->b0007 != 0x04))))
	{
		Eq_4 eax_69 = (word32) ebx_20->b0004;
		Eq_4 ecx_72 = (word32) ebx_20->b0005;
		Eq_4 edx_74 = (word32) ebx_20->b0006;
		Eq_4 ebx_76 = (word32) ebx_20->b0007;
		runtime.printlock(gs);
		runtime.printstring(gs);
		runtime.printsp(gs);
		Eq_4 esi_113;
		runtime.printhex(esi, gs, edx_21, 0x00, out esi_113);
		runtime.printsp(gs);
		Eq_4 esi_133;
		runtime.printhex(esi_113, gs, eax_69, 0x00, out esi_133);
		runtime.printsp(gs);
		Eq_4 esi_153;
		runtime.printhex(esi_133, gs, ecx_72, 0x00, out esi_153);
		runtime.printsp(gs);
		Eq_4 esi_173;
		runtime.printhex(esi_153, gs, edx_74, 0x00, out esi_173);
		runtime.printsp(gs);
		word32 esi_1094;
		runtime.printhex(esi_173, gs, ebx_76, 0x00, out esi_1094);
		runtime.printnl(gs);
		runtime.printunlock(gs);
		runtime.throw(gs);
	}
	else
	{
		Eq_4 edx_220 = *((word32) dwArg04 + 16);
		fn0808FD60(0x00, fp - 0x0104);
		Eq_4 eax_230 = 0x00;
		edx_242 = edx_220;
		while (true)
		{
			Eq_4 edx_242;
			if (eax_230 >= edx_220 - 0x01)
				break;
			Eq_4 ebp_445 = *((word32) dwArg00 + 16);
			Eq_4 esi_446 = edx_242;
			Eq_4 edx_447 = *((word32) dwArg00 + 0x0C);
			if (eax_230 >= ebp_445)
			{
l0808265A:
				runtime.panicindex(gs);
			}
			struct Eq_70061 * ebx_451 = (word32) edx_447 + eax_230 * 0x08;
			up32 ebx_453 = ebx_451->dw0000;
			Eq_4 ecx_454 = (word32) eax_230 + 1;
			if (ecx_454 >= ebp_445)
				goto l0808265A;
			struct Eq_70073 * edx_459 = (word32) edx_447 + 8 + eax_230 * 0x08;
			if (ebx_453 > edx_459->dw0000)
			{
				Eq_4 ebx_463 = *((word32) dwArg00 + 4);
				struct Eq_70087 * ebp_464 = *dwArg00;
				Eq_4 esi_466 = ebx_451->t0004;
				if (esi_466 >= ebx_463)
					runtime.panicindex(gs);
				word32 esi_469 = esi_466 + ebp_464;
				Eq_4 edx_470 = edx_459->t0004;
				if (edx_470 >= ebx_463)
					runtime.panicindex(gs);
				word32 edx_474 = edx_470 + ebp_464;
				if (ecx_454 < edx_220 - 0x01)
					runtime.funcname(gs, edx_474, dwArg00);
				runtime.funcname(gs, esi_469, dwArg00);
				Eq_4 ecx_512 = *((word32) dwArg00 + 0x0C);
				Eq_4 edx_513 = *((word32) dwArg00 + 16);
				if (eax_230 < edx_513)
				{
					Eq_4 edi_520 = *((word32) ecx_512 + eax_230 * 0x08);
					if (ecx_454 < edx_513)
					{
						Eq_4 eax_529 = *((word32) ecx_512 + (eax_230 * 0x08 + 8));
						runtime.printlock(gs);
						runtime.printstring(gs);
						runtime.printsp(gs);
						Eq_4 esi_562;
						runtime.printhex(eax_230, gs, edi_520, 0x00, out esi_562);
						runtime.printsp(gs);
						runtime.printstring(gs);
						runtime.printsp(gs);
						runtime.printstring(gs);
						runtime.printsp(gs);
						word32 esi_1095;
						runtime.printhex(esi_562, gs, eax_529, 0x00, out esi_1095);
						runtime.printsp(gs);
						runtime.printstring(gs);
						runtime.printnl(gs);
						runtime.printunlock(gs);
						Eq_4 eax_650 = 0x00;
						while (eax_650 <= eax_230)
						{
							struct Eq_70087 * ebx_670 = *dwArg00;
							Eq_4 ebp_671 = *((word32) dwArg00 + 4);
							Eq_4 esi_672 = *((word32) dwArg00 + 0x0C);
							if (eax_650 >= *((word32) dwArg00 + 16))
							{
l08082626:
								runtime.panicindex(gs);
							}
							Eq_4 esi_677 = (word32) esi_672 + eax_650 * 0x08 + 0x04;
							if (esi_677 >= ebp_671)
								goto l08082626;
							runtime.funcname(gs, ebx_670 + esi_677, dwArg00);
							Eq_4 ecx_692 = *((word32) dwArg00 + 0x0C);
							if (eax_650 >= *((word32) dwArg00 + 16))
								goto l08082626;
							Eq_4 eax_702 = *((word32) ecx_692 + eax_650 * 0x08);
							runtime.printlock(gs);
							runtime.printstring(gs);
							word32 esi_1096;
							runtime.printhex(eax_650, gs, eax_702, 0x00, out esi_1096);
							runtime.printstring(gs);
							runtime.printstring(gs);
							runtime.printstring(gs);
							runtime.printunlock(gs);
							eax_650 = (word32) eax_650 + 1;
						}
						runtime.throw(gs);
					}
				}
				runtime.panicindex(gs);
			}
			if (edx_220 - 0x01 - eax_230 < 0x05)
			{
				struct Eq_70087 * eax_781 = *dwArg00;
				Eq_4 ebx_782 = *((word32) dwArg00 + 4);
				Eq_4 esi_784 = ebx_451->t0004;
				if (esi_784 >= ebx_782)
					runtime.panicindex(gs);
				word32 edi_787 = eax_781 + esi_784;
				word32 edi_789 = Mem788[eax_781 + esi_784:word32];
				if (ecx_454 < edx_220 - 0x01)
				{
					Eq_4 edx_792 = edx_459->t0004;
					if (edx_792 >= ebx_782)
						runtime.panicindex(gs);
					if (Mem788[eax_781 + 0x18 + edx_792:word32] != 0x00)
					{
						word32 edx_799 = Mem788[eax_781 + edx_792:word32];
						if ((word32) edx_799 - 16 >= edi_789)
							edi_789 = (word32) edx_799 - 16;
					}
				}
				runtime.pcvalue(gs, edi_787, dwArg00, Mem810[eax_781 + 0x14 + esi_784:word32], edi_789, fp - 0x0108, 0x01);
				runtime.pcvalue(gs, edi_787, dwArg00, Mem820[eax_781 + 0x18 + esi_784:word32], edi_789, fp - 0x0108, 0x01);
				runtime.pcvalue(gs, edi_787, dwArg00, Mem845[eax_781 + 0x10 + esi_784:word32], edi_789, fp - 0x0108, 0x01);
				bLoc014C = (byte) fp - 0x08;
				esi_446 = dwLoc0110;
			}
			edx_242 = esi_446;
			eax_230 = ecx_454;
		}
		Eq_4 ebx_240 = *((word32) dwArg00 + 40);
		Eq_4 ebp_241 = *((word32) dwArg00 + 16);
		Eq_4 esi_1084 = edx_242;
		Eq_4 edx_244 = *((word32) dwArg00 + 0x0C);
		if (ebp_241 <= 0x00)
			runtime.panicindex(gs);
		else
		{
			if (*edx_244 == ebx_240)
			{
				Eq_4 edx_254 = *((word32) dwArg00 + 44);
				if (edx_220 - 0x01 >= ebp_241)
					runtime.panicindex(gs);
				if (edx_254 == ((edx_244 - 0x08))[edx_242].t0000)
				{
					Eq_4 ecx_272 = *((word32) dwArg00 + 188);
					Eq_4 edx_274 = *((word32) dwArg00 + 0x00B8);
					Eq_4 ebx_275 = 0x00;
					while (ebx_275 < ecx_272)
					{
						fn0809026E(edx_274, fp - 0x18);
						fn0809026E(fp - 0x18, fp - 44);
						Eq_4 ecx_312 = dwLoc1C->t0000;
						if (dwLoc20 != dwLoc1C->t0004)
						{
l08082532:
							runtime.printlock(gs);
							runtime.printstring(gs);
							runtime.printsp(gs);
							runtime.printstring(gs);
							runtime.printsp(gs);
							runtime.printstring(gs);
							runtime.printsp(gs);
							runtime.printstring(gs);
							runtime.printnl(gs);
							runtime.printunlock(gs);
							runtime.throw(gs);
						}
						word32 edi_1098;
						word32 ebx_1097;
						runtime.eqstring(edx_274, dwLoc24, dwLoc20, ecx_312, out ebx_1097, out esi_1084, out edi_1098);
						if (bLoc014C == 0x00)
							goto l08082532;
						edx_274 = (word32) edx_274 + 20;
						ebx_275 = (word32) ebx_275 + 1;
					}
					esiOut = esi_1084;
					return ebx_275;
				}
			}
			runtime.throw(gs);
		}
	}
}

// 08082750: void runtime.FuncForPC(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      reflect.methodName
void runtime.FuncForPC(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.findfunc(gs, dwArg04);
}

// 08082790: void runtime.(*Func).Name(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      reflect.methodName
void runtime.(*Func).Name(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (dwArg04 == 0x00)
		return;
	runtime.(*Func).funcInfo(gs, dwArg04);
	runtime.funcname(gs, dwLoc0C, dwLoc08);
}

// 08082800: void runtime.findmoduledatap(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      runtime.(*Func).funcInfo
//      runtime.findfunc
void runtime.findmoduledatap(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	struct Eq_70465 * ecx_17;
	for (ecx_17 = &g_t8139420; ecx_17 != null; ecx_17 = ecx_17->ptr00D8)
	{
		if (ecx_17->t0028 <= dwArg04 && dwArg04 < ecx_17->t002C)
			return;
	}
}

// 08082850: void runtime.findfunc(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      runtime.newproc1
//      runtime.setsSP
//      runtime.(*sigctxt).preparePanic
//      runtime.(*pcExpander).init
//      runtime.FuncForPC
//      runtime.tracebackdefers
//      runtime.gentraceback
//      runtime.printcreatedby
void runtime.findfunc(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.findmoduledatap(gs, dwArg04);
	if (dwLoc04 == null)
		return;
	uint32 edx_35 = dwArg04 - dwLoc04->dw0028;
	struct Eq_70502 * edx_40 = dwLoc04->dw0024 + ((edx_35 >> 0x0C) + (edx_35 >> 0x0C) * 0x04) * 0x04;
	Eq_70515 ecx_42 = (edx_35 & 0x0FFF) >> 0x08;
	word32 ebp_43 = edx_40->dw0000;
	if (ecx_42 >= 0x10)
		runtime.panicindex(gs);
	else
	{
		word32 ecx_110 = CONVERT(Mem19[edx_40 + 0x04 + ecx_42:byte], byte, word32) + ebp_43;
		struct Eq_70535 * edx_52 = dwLoc04->ptr000C;
		uint32 ebp_53 = dwLoc04->dw0010;
		if (ecx_110 >= ebp_53)
			ecx_110 = ebp_53 - 0x01;
		if (ecx_110 >= ebp_53)
			runtime.panicindex(gs);
		else if (dwArg04 < edx_52[ecx_110])
		{
			for (; ecx_110 < ebp_53; --ecx_110)
			{
				if (edx_52[ecx_110] <= dwArg04 || ecx_110 <= 0x00)
				{
					if (ecx_110 == 0x00)
						runtime.throw(gs);
l080828F0:
					up32 esi_137 = dwLoc04->dw0004;
					if (ecx_110 >= ebp_53 || *((word32) (&(((edx_52 + ecx_110)->a0000))[0].t0000) + 4) >= esi_137)
						runtime.panicindex(gs);
					else
						return;
				}
			}
			runtime.panicindex(gs);
		}
		else
		{
			while (true)
			{
				uint32 esi_111 = ecx_110 + 0x01;
				if (esi_111 >= ebp_53)
					break;
				if (edx_52->a0008[ecx_110].t0000 > dwArg04)
					goto l080828F0;
				ecx_110 = esi_111;
			}
			runtime.panicindex(gs);
		}
	}
}

// 08082980: void runtime.pcvalue(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C, Stack Eq_4 dwArg10, Stack (ptr32 Eq_70129) dwArg14, Stack byte bArg18)
// Called from:
//      runtime.moduledataverify1
//      runtime.funcline1
//      runtime.funcspdelta
//      runtime.pcdatavalue
void runtime.pcvalue(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C, Eq_4 dwArg10, struct Eq_70129 * dwArg14, byte bArg18)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (dwArg0C == 0x00)
		return;
	if (dwArg14 != null)
	{
		Eq_70610 ebx_30 = 0x00;
		while (ebx_30 < 0x10)
		{
			if (ebx_30 >= 0x10)
				runtime.panicindex(gs);
			ui32 ebp_424 = ebx_30 * 0x03;
			esi = dwArg14->a0004[ebp_424];
			if (dwArg0C == esi)
			{
				esi = dwArg14[ebp_424 * 0x04 / 8];
				if (dwArg10 == esi)
					return;
			}
			ebx_30 = (word32) ebx_30 + 1;
		}
	}
	if (dwArg04 == 0x00)
	{
		if (bArg18 == 0x00 || runtime.panicking != 0x00)
			return;
		Eq_4 eax_53 = *dwArg04;
		runtime.printlock(gs);
		runtime.printstring(gs);
		word32 esi_677;
		runtime.printhex(esi, gs, eax_53, 0x00, out esi_677);
		runtime.printstring(gs);
		runtime.printunlock(gs);
		runtime.throw(gs);
	}
	else
	{
		Eq_4 esi_98 = *((word32) dwArg08 + 8);
		Eq_4 edi_99 = *((word32) dwArg08 + 4);
		word32 ebp_100 = *dwArg08;
		if (dwArg0C > edi_99)
			runtime.panicslice(gs);
		else
		{
			Eq_4 esi_113 = esi_98 - dwArg0C;
			Eq_4 esi_123 = -esi_113 >> 0x1F & dwArg0C;
			Eq_4 ecx_109 = *dwArg04;
			Eq_70663 edi_112 = edi_99 - dwArg0C;
			Eq_4 ecx_114 = esi_113;
			byte (* ebp_124)[] = (word32) esi_123 + ebp_100;
			while (true)
			{
				runtime.step(gs, ebp_124, edi_112, ecx_114, fp - 0x1C, fp - 0x20, (int8) (*dwArg04 == ecx_109));
				if (bLoc24 == 0x00)
					break;
				if (dwArg10 < ecx_109)
				{
					if (dwArg14 != null)
					{
						Eq_4 ecx_396 = *((word32) gs->ptr0000->tFFFFFFFC + 24);
						Eq_4 edx_397 = *((word32) ecx_396 + 0x0094);
						Eq_4 ebx_402 = edx_397 << 0x01 ^ edx_397 >> 0x1F & 0xA8888EEF;
						*((word32) ecx_396 + 0x0094) = ebx_402;
						ui32 ecx_407 = (ebx_402 & 0x0F) + (ebx_402 & 0x0F) * 0x02;
						dwArg14[ecx_407 * 0x04 / 8] = (struct Eq_70129) dwArg10;
						dwArg14->a0004[ecx_407] = dwArg0C;
						dwArg14->a0008[ecx_407] = ~0x00;
					}
					return;
				}
				edi_112 = dwLoc2C;
				ebp_124 = dwLoc30;
				ecx_114 = dwLoc28;
			}
			if (runtime.panicking != 0x00 || bArg18 == 0x00)
				return;
			runtime.funcname(gs, dwArg04, dwArg08);
			runtime.printlock(gs);
			runtime.printstring(gs);
			runtime.printstring(gs);
			runtime.printstring(gs);
			word32 esi_678;
			runtime.printhex(esi_123, gs, ecx_109, 0x00, out esi_678);
			runtime.printstring(gs);
			word32 esi_679;
			runtime.printhex(esi_123, gs, dwArg10, 0x00, out esi_679);
			runtime.printstring(gs);
			runtime.printslice(gs);
			runtime.printstring(gs);
			runtime.printunlock(gs);
			Eq_4 ecx_264 = *((word32) dwArg08 + 8);
			Eq_4 edx_265 = *((word32) dwArg08 + 4);
			word32 eax_266 = *dwArg08;
			if (dwArg0C > edx_265)
				runtime.panicslice(gs);
			else
			{
				Eq_4 ecx_279 = ecx_264 - dwArg0C;
				Eq_4 esi_275 = *dwArg04;
				Eq_70663 edx_278 = edx_265 - dwArg0C;
				Eq_4 esi_280 = ecx_279;
				byte (* eax_284)[] = eax_266 + (-ecx_279 >> 0x1F & dwArg0C);
				while (true)
				{
					runtime.step(gs, eax_284, edx_278, esi_280, fp - 0x1C, fp - 0x20, (int8) (*dwArg04 == esi_275));
					if (bLoc24 == 0x00)
						break;
					runtime.printlock(gs);
					runtime.printstring(gs);
					runtime.printint(SLICE(dwLoc30, word24, 8), gs, ~0x00);
					runtime.printstring(gs);
					word32 esi_680;
					runtime.printhex(dwLoc28, gs, esi_275, 0x00, out esi_680);
					runtime.printstring(gs);
					runtime.printunlock(gs);
					esi_280 = dwLoc28;
					edx_278 = dwLoc2C;
					eax_284 = dwLoc30;
				}
				runtime.throw(gs);
			}
		}
	}
}

// 08082E00: Register word32 runtime.funcname(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
// Called from:
//      runtime.scanframeworker
//      runtime.adjustpointers
//      runtime.adjustframe
//      runtime.(*pcExpander).next
//      runtime.moduledataverify1
//      runtime.(*Func).Name
//      runtime.pcvalue
//      runtime.funcspdelta
//      runtime.gentraceback
//      runtime.getArgInfo
//      runtime.printcreatedby
//      runtime.showframe
word32 runtime.funcname(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (dwArg04 == 0x00)
		return runtime.gostringnocopy();
	Eq_4 eax_21 = *((word32) dwArg04 + 4);
	if (eax_21 == 0x00)
		return runtime.gostringnocopy();
	if (eax_21 < *((word32) dwArg08 + 4))
		return runtime.gostringnocopy();
	runtime.panicindex(gs);
}

// 08082E70: void runtime.funcnameFromNameoff(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C)
// Called from:
//      runtime.(*pcExpander).next
//      runtime.gentraceback
void runtime.funcnameFromNameoff(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (dwArg04 == 0x00)
		return;
	if (dwArg0C >= *((word32) dwArg08 + 4))
		runtime.panicindex(gs);
	else
		runtime.gostringnocopy();
}

// 08082EE0: void runtime.funcfile(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C)
// Called from:
//      runtime.(*pcExpander).next
//      runtime.gentraceback
void runtime.funcfile(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (dwArg04 == 0x00)
		return;
	Eq_4 edx_28 = *((word32) dwArg08 + 4);
	Eq_4 eax_30 = *((word32) dwArg08 + 24);
	if (dwArg0C >= *((word32) dwArg08 + 28) || *((word32) eax_30 + dwArg0C * 0x04) >= edx_28)
		runtime.panicindex(gs);
	else
		runtime.gostringnocopy();
}

// 08082F60: void runtime.funcline1(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack byte bArg10)
// Called from:
//      runtime.(*pcExpander).init
//      runtime.funcline
void runtime.funcline1(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, byte bArg10)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (dwArg04 == 0x00)
		return;
	runtime.pcvalue(gs, dwArg04, dwArg08, *((word32) dwArg04 + 20), dwArg0C, null, bArg10);
	runtime.pcvalue(gs, dwArg04, dwArg08, *((word32) dwArg04 + 24), dwArg0C, null, bArg10);
	if (dwLoc08 == ~0x00 || dwLoc08 == ~0x00)
		return;
	Eq_4 ebx_67 = *((word32) dwArg08 + 28);
	Eq_4 ebp_68 = *((word32) dwArg08 + 24);
	if (dwLoc08 >= ebx_67)
		return;
	Eq_4 ebx_71 = *((word32) dwArg08 + 4);
	if (dwLoc08 >= ebx_67 || *((word32) ebp_68 + dwLoc08 * 0x04) >= ebx_71)
		runtime.panicindex(gs);
	else
		runtime.gostringnocopy();
}

// 080830A0: void runtime.funcline(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.gentraceback
//      runtime.printcreatedby
void runtime.funcline(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.funcline1(gs, dwArg04, dwArg08, 0x01);
}

// 08083100: void runtime.funcspdelta(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      runtime.gentraceback
void runtime.funcspdelta(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.pcvalue(gs, dwArg04, dwArg08, *((word32) dwArg04 + 16), dwArg0C, dwArg10, 0x01);
	if ((dwLoc18 & 0x03) != 0x00)
	{
		runtime.funcname(gs, dwArg04, dwArg08);
		Eq_4 ebx_51 = *dwArg04;
		Eq_4 edx_53 = *((word32) dwArg04 + 16);
		runtime.printlock(gs);
		runtime.printstring(gs);
		runtime.printstring(gs);
		runtime.printstring(gs);
		word32 esi_208;
		runtime.printhex(esi, gs, ebx_51, 0x00, out esi_208);
		runtime.printstring(gs);
		word32 esi_209;
		runtime.printhex(esi, gs, dwArg0C, 0x00, out esi_209);
		runtime.printstring(gs);
		word32 esi_210;
		runtime.printhex(esi, gs, edx_53, edx_53 >> 0x1F, out esi_210);
		runtime.printstring(gs);
		runtime.printint(ebx_24_8, gs, dwLoc18);
		runtime.printstring(gs);
		runtime.printunlock(gs);
	}
}

// 080832A0: void runtime.pcdatavalue(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg0C)
// Called from:
//      runtime.scanframeworker
//      runtime.adjustframe
//      runtime.(*pcExpander).init
//      runtime.gentraceback
void runtime.pcdatavalue(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg0C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (dwArg0C < 0x00 || dwArg0C >= *((word32) dwArg04 + 28))
		return;
	runtime.pcvalue(gs, dwArg04, dwArg08, *((word32) dwArg04 + (dwArg0C * 0x04 + 36)), dwArg10, dwArg14, 0x01);
}

// 08083320: Register (ptr32 int32) runtime.funcdata(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg0C)
// Called from:
//      runtime.scanframeworker
//      runtime.newproc1
//      runtime.adjustframe
//      runtime.(*pcExpander).init
//      runtime.gentraceback
int32 * runtime.funcdata(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg0C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (dwArg0C < 0x00)
		return ebx;
	ebx = (word32) dwArg04 + 32;
	if (dwArg0C >= *((word32) dwArg04 + 32))
		return ebx;
	return (word32) dwArg04 + 32;
}

// 08083370: void runtime.step(Register (ptr32 Eq_2) gs, Stack (arr byte) dwArg04, Stack Eq_70663 dwArg08, Stack Eq_4 dwArg0C, Stack (ptr32 word32) dwArg10, Stack (ptr32 word32) dwArg14, Stack int8 bArg18)
// Called from:
//      runtime.pcvalue
void runtime.step(struct Eq_2 * gs, byte dwArg04[], Eq_70663 dwArg08, Eq_4 dwArg0C, word32 * dwArg10, word32 * dwArg14, int8 bArg18)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (dwArg08 <= 0x00)
		runtime.panicindex(gs);
	else
	{
		uint32 edx_27 = (word32) dwArg04[0];
		if (edx_27 == 0x00 && bArg18 == 0x00)
			return;
		Eq_70663 ebx_58;
		if ((edx_27 & 0x80) == 0x00)
			ebx_58.u0 = 0x01;
		else
		{
			runtime.readvarint(gs, dwArg04, dwArg08);
			ebx_58 = dwLoc10;
			edx_27 = dwLoc0C;
		}
		if (ebx_58 > dwArg08)
			runtime.panicslice(gs);
		else
		{
			uint32 edx_121;
			int32 ebx_87 = ebx_58 & ebx_58 - dwArg0C >> 0x1F;
			Eq_70663 eax_73 = dwArg08 - ebx_58;
			byte (* ebp_89)[] = dwArg04 + ebx_87;
			if ((edx_27 & 0x01) != 0x00)
				edx_121 = ~(edx_27 >> 0x01);
			else
				edx_121 = edx_27 >> 0x01;
			if (eax_73 <= 0x00)
				runtime.panicindex(gs);
			else
			{
				Eq_70663 ebx_130;
				uint32 ecx_113 = (word32) dwArg04[ebx_87];
				if ((ecx_113 & 0x80) == 0x00)
					ebx_130.u0 = 0x01;
				else
				{
					runtime.readvarint(gs, ebp_89, eax_73);
					ebx_130 = dwLoc10;
					ecx_113 = dwLoc0C;
				}
				if (ebx_130 > eax_73)
					runtime.panicslice(gs);
				else
				{
					*dwArg10 += ecx_113;
					*dwArg14 += edx_121;
				}
			}
		}
	}
}

// 08083510: void runtime.readvarint(Register (ptr32 Eq_2) gs, Stack (ptr32 (arr byte)) dwArg04, Stack Eq_70663 dwArg08)
// Called from:
//      runtime.step
void runtime.readvarint(struct Eq_2 * gs, byte (* dwArg04)[], Eq_70663 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_70663 ecx_19 = 0x00;
	while (ecx_19 < dwArg08)
	{
		Eq_70663 edi_45 = (word32) ecx_19 + 1;
		if ((Mem35[dwArg04 + ecx_19:byte] & 0x80) == 0x00)
			return;
		ecx_19 = edi_45;
	}
	runtime.panicindex(gs);
}

// 08083580: void runtime.stackmapdata(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
// Called from:
//      runtime.scanframeworker
//      runtime.newproc1
//      runtime.adjustframe
void runtime.stackmapdata(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (dwArg08 >= 0x00 && dwArg08 < *dwArg04)
		return;
	runtime.throw(gs);
}

// 080835F0: Register Eq_4 runtime.deltimer(Register Eq_4 esi, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      internal/poll.runtime_pollUnblock
Eq_4 runtime.deltimer(Eq_4 esi, struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	word32 edi_239;
	Eq_4 esi_225;
	runtime.lock(esi, gs, 0x081452A0, out esi_225, out edi_239);
	Eq_4 ecx_37 = *dwArg04;
	Eq_4 edx_38 = g_t81452B8;
	Eq_4 ebx_39 = g_t81452BC;
	if (ecx_37 >= 0x00 && ecx_37 <= ebx_39 - 0x01)
	{
		if (ecx_37 >= ebx_39)
			runtime.panicindex(gs);
		esi_225 = *((word32) edx_38 + ecx_37 * 0x04);
		Eq_4 edi_49 = (word32) edx_38 + ecx_37 * 0x04;
		if (esi_225 == dwArg04)
		{
			if (ebx_39 - 0x01 != ecx_37)
			{
				if (ebx_39 - 0x01 >= ebx_39)
					runtime.panicindex(gs);
				Eq_4 esi_59 = (edx_38 - 0x04)[ebx_39];
				if (g_t81576F0 == 0x00)
					*((word32) edx_38 + ecx_37 * 0x04) = esi_59;
				else
					runtime.writebarrierptr(edi_49, esi_59);
				Eq_4 eax_79 = g_t81452B8;
				if (ecx_37 >= g_t81452BC)
					runtime.panicindex(gs);
				**((word32) eax_79 + ecx_37 * 0x04) = ecx_37;
			}
			Eq_4 edx_89 = g_t81452B8;
			if (ebx_39 - 0x01 >= g_t81452BC)
				runtime.panicindex(gs);
			else
			{
				Eq_4 esi_148 = edx_89 - 0x04 + ebx_39 * 0x04;
				if (g_t81576F0 == 0x00)
					(edx_89 - 0x04)[ebx_39] = 0x00;
				else
					runtime.writebarrierptr(esi_148, 0x00);
				if (ebx_39 - 0x01 > g_t81452C0)
					runtime.panicslice(gs);
				else
				{
					g_t81452BC = ebx_39 - 0x01;
					if (ebx_39 - 0x01 != ecx_37)
					{
						runtime.siftupTimer(gs, ecx_37);
						esi_148 = runtime.siftdownTimer(gs, ecx_37);
					}
					word32 edx_242;
					word32 ebx_243;
					runtime.unlock(gs, 0x081452A0, out edx_242, out ebx_243);
					return esi_148;
				}
			}
		}
	}
	word32 edx_240;
	word32 ebx_241;
	runtime.unlock(gs, 0x081452A0, out edx_240, out ebx_241);
	return esi_225;
}

// 08083780: void runtime.timerproc(Register Eq_4 esi, Register (ptr32 Eq_2) gs)
void runtime.timerproc(Eq_4 esi, struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 ecx_19 = gs->ptr0000->tFFFFFFFC;
	if (g_t81576F0 == 0x00)
		g_t81452A4 = ecx_19;
	else
	{
		runtime.writebarrierptr(135549604, ecx_19);
		dwLoc50 = ecx_19;
	}
	while (true)
	{
l08083A59:
		word32 esi_601;
		word32 edi_45;
		runtime.lock(esi, gs, 0x081452A0, out esi_601, out edi_45);
		g_b81452A9 = 0x00;
		runtime.nanotime();
		while (true)
		{
			ui64 ecx_esi_501;
			Eq_4 edx_65 = g_t81452BC;
			Eq_4 ebx_66 = g_t81452B8;
			ui24 eax_24_8_101 = SLICE(dwLoc50, word24, 8);
			if (edx_65 == 0x00)
				break;
			Eq_4 ebp_72 = *ebx_66;
			Eq_4 esi_73 = *((word32) ebp_72 + 4);
			ecx_esi_501 = SEQ(ecx_79, esi_73) - SEQ(dwLoc50, 0x081452A0);
			int32 ecx_83 = SLICE(ecx_esi_501, word32, 32);
			up32 esi_77 = (word32) ecx_esi_501;
			ui32 edi_107 = SEQ(SLICE(edi_45, word24, 8), (int8) (esi_77 > 0x00)) & SEQ(eax_24_8_101, (int8) (ecx_83 == 0x00)) | SEQ(eax_24_8_101, (int8) (ecx_83 > 0x00));
			Eq_4 ecx_79 = *((word32) ebp_72 + 8);
			if ((byte) edi_107 != 0x00)
				goto l08083A0E;
			Eq_4 esi_340;
			Eq_4 eax_227 = *((word32) ebp_72 + 16);
			ui24 ebx_24_8_236 = SLICE(esi_77, word24, 8);
			Eq_4 ecx_228 = *((word32) ebp_72 + 0x0C);
			ui32 edi_264 = SEQ(SLICE(edi_107, word24, 8), (int8) (ecx_228 > 0x00)) & SEQ(ebx_24_8_236, (int8) (eax_227 == 0x00)) | SEQ(ebx_24_8_236, (int8) (eax_227 > 0x00));
			if ((byte) edi_264 == 0x00)
			{
				if (edx_65 > 0x01)
				{
					if (edx_65 - 0x01 >= edx_65)
						runtime.panicindex(gs);
					Eq_4 esi_353 = (ebx_66 - 0x04)[edx_65];
					if (g_t81576F0 == 0x00)
						*ebx_66 = esi_353;
					else
						runtime.writebarrierptr(ebx_66, esi_353);
					Eq_4 ebx_374 = g_t81452B8;
					if (g_t81452BC <= 0x00)
						runtime.panicindex(gs);
					**ebx_374 = 0x00;
				}
				Eq_4 ebx_384 = g_t81452B8;
				if (edx_65 - 0x01 >= g_t81452BC)
					runtime.panicindex(gs);
				esi_340 = ebx_384 - 0x04 + edx_65 * 0x04;
				if (g_t81576F0 == 0x00)
					(ebx_384 - 0x04)[edx_65] = 0x00;
				else
					runtime.writebarrierptr(esi_340, 0x00);
				if (edx_65 - 0x01 > g_t81452C0)
					runtime.panicslice(gs);
				g_t81452BC = edx_65 - 0x01;
				if (edx_65 > 0x01)
					esi_340 = runtime.siftdownTimer(gs, 0x00);
				*ebp_72 = ~0x00;
			}
			else
			{
				runtime.int64div(edi_264, gs, SEQ(dwLoc50, 0x081452A0) - SEQ(ecx_79, esi_73), SEQ(eax_227, ecx_228));
				uint64 edx_eax_307 = ecx_228 *64 (dwLoc44 + 0x01);
				uint32 eax_308 = (word32) edx_eax_307;
				*((word32) ebp_72 + 4) = (word32) esi_73 + eax_308;
				*((word32) ebp_72 + 8) = SLICE(SEQ((dwLoc44 + 0x01) *s eax_227 + SLICE(edx_eax_307, word32, 32) + (dwLoc40 + (dwLoc44 < 0x01)) *s ecx_228, eax_308) + SEQ(ecx_79, esi_73), word32, 32);
				esi_340 = runtime.siftdownTimer(gs, 0x00);
			}
			Eq_4 eax_441 = *((word32) ebp_72 + 20);
			Eq_4 ecx_445 = *((word32) ebp_72 + 28);
			Eq_4 edx_447 = *((word32) ebp_72 + 24);
			Eq_4 ebx_449 = *((word32) ebp_72 + 32);
			word32 edx_602;
			word32 ebx_603;
			runtime.unlock(gs, 0x081452A0, out edx_602, out ebx_603);
			<anonymous> * eax_471 = *eax_441;
			eax_471();
			word32 esi_604;
			runtime.lock(esi_340, gs, 0x081452A0, out esi_604, out edi_45);
		}
		ecx_esi_501 = ~0x00;
l08083A0E:
		int32 ecx_118 = SLICE(ecx_esi_501, word32, 32);
		esi = (word32) ecx_esi_501;
		if (((int8) (ecx_118 == 0x00) & (int8) Test(ULT,false) | (int8) (ecx_118 < 0x00)) != 0x00)
			break;
		int32 eax_141 = g_dw8157674;
		up32 edx_142 = g_dw8157670;
		if (((int8) (edx_142 > 0x00) & (int8) (eax_141 == 0x00) | (int8) (eax_141 > 0x00)) != 0x00)
			break;
		g_b81452A9 = 0x01;
		ui64 eax_eax_510 = SEQ(dwLoc50, 0x081452A0) + ecx_esi_501;
		g_dw81452AC = (word32) eax_eax_510;
		g_dw81452B0 = SLICE(eax_eax_510, word32, 32);
		g_dw81452B4 = 0x00;
		word32 ebx_606;
		word32 edx_605;
		runtime.unlock(gs, 0x081452A0, out edx_605, out ebx_606);
		runtime.notetsleepg(gs);
		dwLoc50 = esi;
	}
	g_b81452AA = 0x01;
	runtime.goparkunlock(gs);
	dwLoc50.u0 = 135149445;
	dwLoc44 = 0x01;
	goto l08083A59;
}

// 08083B70: void runtime.timejump(Register Eq_4 ebp, Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.checkdead
void runtime.timejump(Eq_4 ebp, struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	int32 eax_17 = g_dw8157674;
	up32 ecx_18 = g_dw8157670;
	if (((int8) (eax_17 == 0x00) & (int8) (ecx_18 == 0x00)) != 0x00)
		return;
	word32 edi_171;
	word32 esi_170;
	runtime.lock(esi, gs, 0x081452A0, out esi_170, out edi_171);
	if (g_b81452A8 != 0x00)
	{
		Eq_4 eax_48 = g_t81452B8;
		if (g_t81452BC != 0x00)
		{
			struct Eq_71828 * eax_53 = *eax_48;
			int32 ecx_54 = g_dw8157674;
			up32 edx_55 = g_dw8157670;
			int32 ebx_56 = eax_53->dw0008;
			up32 eax_70 = eax_53->dw0004;
			if (((int8) (ecx_54 < ebx_56) | (int8) (edx_55 < eax_70) & (int8) (ecx_54 == ebx_56)) != 0x00)
			{
				g_dw8157670 = eax_70;
				g_dw8157674 = ebx_56;
				if (g_b81452AA != 0x00)
					g_b81452AA = 0x00;
			}
			word32 edx_174;
			word32 ebx_175;
			runtime.unlock(gs, 0x081452A0, out edx_174, out ebx_175);
			return;
		}
	}
	word32 edx_172;
	word32 ebx_173;
	runtime.unlock(gs, 0x081452A0, out edx_172, out ebx_173);
}

// 08083C80: void runtime.siftupTimer(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      runtime.deltimer
void runtime.siftupTimer(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 eax_17 = g_t81452B8;
	Eq_4 ecx_18 = g_t81452BC;
	Eq_4 edx_147 = dwArg04;
	if (dwArg04 >= ecx_18)
		runtime.panicindex(gs);
	else
	{
		Eq_4 ebx_24 = *((word32) eax_17 + dwArg04 * 0x04);
		Eq_4 ebp_26 = *((word32) ebx_24 + 4);
		Eq_4 esi_28 = *((word32) ebx_24 + 8);
		eax_100 = eax_17;
		esi_105 = esi_28;
		ebp_104 = ebp_26;
		while (true)
		{
			Eq_4 ebp_104;
			Eq_4 esi_105;
			Eq_4 eax_100;
			if (edx_147 <= 0x00)
				break;
			Eq_71913 edi_35 = edx_147 - 0x01 >> 0x1F >> 0x1E;
			Eq_71920 edi_36 = (word32) edx_147 + (edi_35 - 0x01);
			if (edi_36 >> 0x02 >= ecx_18)
				runtime.panicindex(gs);
			Eq_4 ebx_45 = *((word32) eax_100 + (edi_36 >> 0x02) * 0x04);
			Eq_4 ecx_47 = *((word32) ebx_45 + 8);
			Eq_4 ebx_52 = *((word32) ebx_45 + 4);
			Eq_4 edx_68 = (word32) eax_100 + (edi_36 >> 0x02) * 0x04;
			if (((int8) (esi_105 > ecx_47) | (int8) (esi_105 == ecx_47) & (int8) (ebp_104 >= ebx_52)) != 0x00)
				return;
			if (edx_147 >= ecx_18)
				runtime.panicindex(gs);
			Eq_4 edx_82 = (word32) eax_100 + edx_147 * 0x04;
			if (g_t81576F0 == 0x00)
				*((word32) eax_100 + edx_147 * 0x04) = ebx_45;
			else
			{
				runtime.writebarrierptr(edx_82, ebx_45);
				eax_100 = eax_17;
				ebp_104 = ebp_26;
				esi_105 = esi_28;
			}
			*ebx_45 = edx_147;
			word32 edi_134 = edi_35 - 0x01 + edx_147 >> 0x02;
			if (g_t81576F0 == 0x00)
				*((word32) eax_100 + edi_134 * 0x04) = ebx_24;
			else
			{
				runtime.writebarrierptr(edx_68, ebx_24);
				eax_100 = eax_17;
				ebp_104 = ebp_26;
				esi_105 = esi_28;
				edi_134 = edi_36 >> 0x02;
			}
			*ebx_24 = edi_134;
			edx_147 = edi_134;
		}
	}
}

// 08083E00: Register Eq_4 runtime.siftdownTimer(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      runtime.deltimer
//      runtime.timerproc
Eq_4 runtime.siftdownTimer(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 eax_17 = g_t81452B8;
	Eq_4 ecx_18 = g_t81452BC;
	Eq_4 edx_19 = dwArg04;
	if (dwArg04 >= ecx_18)
		runtime.panicindex(gs);
	else
	{
		Eq_4 ebx_24 = *((word32) eax_17 + dwArg04 * 0x04);
		Eq_4 ebp_26 = *((word32) ebx_24 + 4);
		Eq_4 esi_28 = *((word32) ebx_24 + 8);
		while (true)
		{
			ui32 edx_32 = edx_19 << 0x02;
			Eq_4 esi_190 = esi_28;
			if (edx_32 + 0x01 >= ecx_18)
				break;
			if (edx_32 + 0x01 >= ecx_18)
				runtime.panicindex(gs);
			Eq_4 ecx_50;
			Eq_4 eax_49;
			Eq_4 edi_43 = *((word32) eax_17 + (edx_32 * 0x04 + 4));
			Eq_4 ebp_44 = *((word32) edi_43 + 4);
			Eq_4 edi_45 = *((word32) edi_43 + 8);
			esi_190 = edx_32 + 0x02;
			if (edx_32 + 0x02 < ecx_18)
			{
				if (edx_32 + 0x02 >= ecx_18)
					runtime.panicindex(gs);
				Eq_4 eax_53 = *((word32) eax_17 + (edx_32 * 0x04 + 8));
				Eq_4 ecx_54 = *((word32) eax_53 + 4);
				eax_49 = *((word32) eax_53 + 8);
				if (((int8) (eax_49 < edi_45) | (int8) (eax_49 == edi_45) & (int8) (ecx_54 < ebp_44)) != 0x00)
					ecx_50 = ecx_54;
				else
				{
					eax_49 = edi_45;
					ecx_50 = ebp_44;
					esi_190 = edx_32 + 0x01;
				}
			}
			else
			{
				eax_49 = edi_45;
				ecx_50 = ebp_44;
				esi_190 = edx_32 + 0x01;
			}
			Eq_4 eax_191;
			Eq_4 edx_106;
			Eq_4 edi_107;
			ui24 ebx_24_8_162 = SLICE(edx_32 + 0x03, word24, 8);
			if (edx_32 + 0x03 < ecx_18)
			{
				if (edx_32 + 0x03 >= ecx_18)
					runtime.panicindex(gs);
				Eq_4 eax_108;
				Eq_4 esi_100 = *((word32) eax_17 + (edx_32 * 0x04 + 0x0C));
				Eq_4 ecx_101 = *((word32) esi_100 + 8);
				Eq_4 esi_102 = *((word32) esi_100 + 4);
				if (edx_32 + 0x04 < ecx_18)
				{
					if (edx_32 + 0x04 >= ecx_18)
						runtime.panicindex(gs);
					Eq_4 edx_111 = *((word32) eax_17 + (edx_32 * 0x04 + 16));
					edi_107 = *((word32) edx_111 + 8);
					edx_106 = *((word32) edx_111 + 4);
					ebx_24_8_162 = SLICE(edx_32 + 0x03, word24, 8);
					if (((int8) (edi_107 == ecx_101) & (int8) (edx_106 < esi_102) | (int8) (edi_107 < ecx_101)) != 0x00)
						eax_108 = edx_32 + 0x04;
					else
					{
						edx_106 = esi_102;
						edi_107 = ecx_101;
						eax_108 = edx_32 + 0x03;
					}
				}
				else
				{
					edx_106 = esi_102;
					edi_107 = ecx_101;
					eax_108 = edx_32 + 0x03;
				}
				Eq_4 esi_181 = SEQ(SLICE(esi_102, word24, 8), (int8) (edx_106 < ecx_50)) & SEQ(ebx_24_8_162, (int8) (edi_107 == eax_49)) | SEQ(ebx_24_8_162, (int8) (edi_107 < eax_49));
				esi_190 = esi_181;
				eax_191 = eax_108;
				if ((byte) esi_181 == 0x00)
				{
					edi_107 = eax_49;
					edx_106 = ecx_50;
					eax_191 = esi_190;
				}
			}
			else
			{
				edi_107 = eax_49;
				edx_106 = ecx_50;
				eax_191 = esi_190;
			}
			if (((int8) (edi_107 > esi_28) | (int8) (edx_106 >= ebp_26) & (int8) (edi_107 == esi_28)) != 0x00)
				return esi_190;
			if (eax_191 >= ecx_18)
			{
l08084078:
				runtime.panicindex(gs);
			}
			Eq_4 esi_230 = *((word32) eax_17 + eax_191 * 0x04);
			Eq_4 edi_231 = (word32) eax_17 + eax_191 * 0x04;
			if (edx_19 >= ecx_18)
				goto l08084078;
			Eq_4 ebp_240 = (word32) eax_17 + edx_19 * 0x04;
			if (g_t81576F0 == 0x00)
				*((word32) eax_17 + edx_19 * 0x04) = esi_230;
			else
				runtime.writebarrierptr(ebp_240, esi_230);
			*esi_230 = edx_19;
			if (g_t81576F0 == 0x00)
				*((word32) eax_17 + eax_191 * 0x04) = ebx_24;
			else
				runtime.writebarrierptr(edi_231, ebx_24);
			*ebx_24 = eax_191;
			edx_19 = eax_191;
		}
		return esi_190;
	}
}

// 080840B0: void time.now(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.gcMarkTermination
void time.now(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.walltime();
	runtime.nanotime();
}

// 08084130: void runtime.traceReader(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.schedule
void runtime.traceReader(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (g_dw814F510 == 0x00 || g_ptr814F508 == null && g_b814F4C9 == 0x00)
		return;
	word32 edi_124;
	word32 esi_123;
	runtime.lock(esi, gs, 0x0814F4C0, out esi_123, out edi_124);
	if (g_dw814F510 != 0x00 && (g_ptr814F508 != null || g_b814F4C9 != 0x00))
	{
		g_dw814F510 = 0x00;
		word32 edx_127;
		word32 ebx_128;
		runtime.unlock(gs, 0x0814F4C0, out edx_127, out ebx_128);
	}
	else
	{
		word32 edx_125;
		word32 ebx_126;
		runtime.unlock(gs, 0x0814F4C0, out edx_125, out ebx_126);
	}
}

// 08084200: void runtime.traceProcFree(Register Eq_4 esi, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      runtime.procresize
void runtime.traceProcFree(Eq_4 esi, struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	struct Eq_72250 * ecx_18 = *((word32) dwArg04 + 2344);
	*((word32) dwArg04 + 2344) = null;
	if (ecx_18 == null)
		return;
	word32 edi_109;
	word32 esi_108;
	runtime.lock(esi, gs, 0x0814F4C0, out esi_108, out edi_109);
	ecx_18->ptr0000 = null;
	if (g_ptr814F508 == null)
		g_ptr814F508 = ecx_18;
	else
		g_ptr814F50C->ptr0000 = ecx_18;
	g_ptr814F50C = ecx_18;
	word32 ebx_111;
	word32 edx_110;
	runtime.unlock(gs, 0x0814F4C0, out edx_110, out ebx_111);
}

// 08084290: Register Eq_72347 runtime.traceEvent(Register (ptr32 Eq_2) gs, Stack byte bArg04, Stack Eq_4 dwArg08, Stack (ptr32 Eq_72351) dwArg0C, Stack Eq_72347 dwArg10, Register out Eq_72347 esiOut)
// Called from:
//      runtime.traceGomaxprocs
//      runtime.traceProcStart
//      runtime.traceProcStop
//      runtime.traceGCStart
//      runtime.traceGCDone
//      runtime.traceGCScanStart
//      runtime.traceGCScanDone
//      runtime.traceGCSweepSpan
//      runtime.traceGCSweepDone
//      runtime.traceGCMarkAssistStart
//      runtime.traceGCMarkAssistDone
//      runtime.traceGoCreate
//      runtime.traceGoStart
//      runtime.traceGoEnd
//      runtime.traceGoSched
//      runtime.traceGoPreempt
//      runtime.traceGoPark
//      runtime.traceGoUnpark
//      runtime.traceGoSysCall
//      runtime.traceGoSysExit
//      runtime.traceGoSysBlock
//      runtime.traceHeapAlloc
//      runtime.traceNextGC
Eq_72347 runtime.traceEvent(struct Eq_2 * gs, byte bArg04, Eq_4 dwArg08, struct Eq_72351 * dwArg0C, Eq_72347 dwArg10, union Eq_72347 & esiOut)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.traceAcquireBuffer(gs);
	if (g_b814F4C8 == 0x00 && dwLoc4C->b01E0 == 0x00)
	{
		runtime.traceReleaseBuffer(gs, dwLoc48);
		esiOut = esi;
		return ebp;
	}
	else
	{
		struct Eq_72250 * dwLoc4C_362;
		struct Eq_72250 * ecx_65;
		struct Eq_72250 * ebx_49 = *dwLoc44;
		if (ebx_49 != null && -((word32) ebx_49->t000C - 0x0000FDF0) >= 0x34)
		{
			ecx_65 = ebx_49;
			dwLoc4C_362 = dwLoc4C;
		}
		else
		{
			runtime.traceFlush(gs, ebx_49);
			*dwLoc44 = (struct Eq_72250 **) dwLoc48;
			dwLoc4C_362 = ebx_49;
			ecx_65 = dwLoc48;
		}
		runtime.cputicks();
		struct Eq_72250 * ecx_93 = dwLoc4C_362 >> 0x06 | dwLoc48 << 0x1A;
		struct Eq_72250 * ebx_95 = ecx_65->ptr0004;
		Eq_72347 esi_99 = ecx_65->t0008;
		struct Eq_72250 * ecx_141 = ecx_93 - ebx_95;
		Eq_72427 edx_105 = (dwLoc48 >> 0x06) - esi_99 - (ecx_93 - ebx_95 < 0x00);
		Eq_72347 ebp_106 = ecx_65->t000C;
		if (ebp_106 == 0x00)
		{
			Mem112[ecx_65 + 0x0210 + ebp_106:byte] = 0x41;
			ecx_65->t000C = (word32) ecx_65->t000C + 1;
			runtime.(*traceBuf).varint(ebp_106, esi_99, gs, ecx_65, dwLoc48, dwLoc48 >> 0x1F);
			runtime.(*traceBuf).varint(ebp_106, esi_99, gs, ecx_65, ecx_93, dwLoc48 >> 0x06);
			edx_105.u0 = 0x00;
			ecx_141 = null;
		}
		Eq_72347 esi_155;
		ecx_65->ptr0004 = ecx_93;
		ecx_65->t0008 = dwLoc48 >> 0x06;
		if (dwArg08 >= 0x00)
			esi_155 = (word32) dwArg10.u0 + 1;
		else
			esi_155 = dwArg10;
		Eq_72347 esi_166 = esi_155;
		if ((byte) esi_155 > 0x03)
			esi_166.u0 = 0x03;
		byte bl_191 = bArg04 | (byte) esi_166 << 0x06;
		Eq_72347 esi_180 = ecx_65->t000C;
		if (esi_180 >= 0xFDF0)
			runtime.panicindex(gs);
		else
		{
			byte * ebx_229;
			Mem192[ecx_65 + 0x0210 + esi_180:byte] = bl_191;
			ecx_65->t000C = (word32) ecx_65->t000C + 1;
			if ((byte) esi_166 != 0x03)
				ebx_229 = null;
			else
			{
				runtime.(*traceBuf).varint(dwArg10, esi_180, gs, ecx_65, null, 0x00);
				Eq_72347 ecx_221 = ecx_65->t000C;
				if (ecx_221 >= 0xFDF1)
					runtime.panicindex(gs);
				ebx_229 = (byte *) (ecx_65 + ((word32) ecx_221 + 527) / 0x01E1);
			}
			runtime.(*traceBuf).varint(dwArg10, esi_180, gs, ecx_65, ecx_141, edx_105);
			Eq_72347 eax_249 = 0x00;
			struct Eq_72351 * ecx_252 = dwArg0C;
			while (eax_249 < dwArg10)
			{
				runtime.(*traceBuf).varint(dwArg10, esi_180, gs, ecx_65, ecx_252->dw0000, ecx_252->dw0004);
				++ecx_252;
				eax_249 = (word32) eax_249.u0 + 1;
			}
			if (dwArg08 != 0x00)
			{
				if (dwArg08 > 0x00)
				{
					runtime.traceStackID(gs, dwLoc4C, 0x80);
					runtime.(*traceBuf).varint(dwArg10, esi_180, gs, ecx_65, dwLoc38, dwLoc34);
				}
			}
			else
				runtime.(*traceBuf).varint(dwArg10, esi_180, gs, ecx_65, null, 0x00);
			int32 eax_320 = ecx_65->t000C - esi_180;
			if (eax_320 > 0x34)
				runtime.throw(gs);
			else
			{
				if (ebx_229 != null)
					*ebx_229 = (byte) eax_320 + ~0x01;
				runtime.traceReleaseBuffer(gs, dwLoc48);
				esiOut = esi_180;
				return dwArg10;
			}
		}
	}
}

// 080845B0: void runtime.traceStackID(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_72250) dwArg04, Stack Eq_4 dwArg10)
// Called from:
//      runtime.traceEvent
void runtime.traceStackID(struct Eq_2 * gs, struct Eq_72250 * dwArg04, Eq_4 dwArg10)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 eax_38;
	Eq_4 ecx_20 = dwArg04->t0054;
	if (ecx_20 != (gs->ptr0000)->tFFFFFFFC)
	{
		if (ecx_20 == 0x00)
			eax_38.u0 = 0x00;
		else
		{
			runtime.gcallers(gs, dwArg0C);
			eax_38 = dwLoc08;
		}
	}
	else
	{
		runtime.callers(gs);
		eax_38 = dwLoc0C;
	}
	if (eax_38 > 0x00)
		--eax_38;
	if (eax_38 > 0x00)
	{
		Eq_4 edx_73 = *((word32) ecx_20 + 80);
		Eq_4 ecx_74 = *((word32) ecx_20 + 84);
		if (((int8) (ecx_74 == 0x00) & (int8) (edx_73 == 0x01)) != 0x00)
			--eax_38;
	}
	if (eax_38 > dwArg10)
		runtime.panicslice(gs);
	else
		runtime.(*traceStackTable).put(gs, 135591188, dwArg08, eax_38);
}

// 080846D0: void runtime.traceAcquireBuffer(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.traceEvent
void runtime.traceAcquireBuffer(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 eax_18 = gs->ptr0000->tFFFFFFFC;
	Eq_4 ecx_19 = *((word32) eax_18 + 24);
	*((word32) ecx_19 + 0x0078) = (word32) *((word32) ecx_19 + 0x0078) + 1;
	if (*((word32) *((word32) eax_18 + 24) + 92) != 0x00)
		return;
	word32 esi_77;
	word32 edi_78;
	runtime.lock(esi, gs, 0x08157548, out esi_77, out edi_78);
}

// 08084760: void runtime.traceReleaseBuffer(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_72250) dwArg04)
// Called from:
//      runtime.traceEvent
void runtime.traceReleaseBuffer(struct Eq_2 * gs, struct Eq_72250 * dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (dwArg04 == (struct Eq_72250 *) ~0x00)
	{
		word32 edx_61;
		word32 ebx_62;
		runtime.unlock(gs, 0x08157548, out edx_61, out ebx_62);
	}
	Eq_4 eax_29 = gs->ptr0000->tFFFFFFFC;
	Eq_4 ecx_30 = *((word32) eax_29 + 24);
	Eq_4 edx_31 = *((word32) ecx_30 + 0x0078);
	*((word32) ecx_30 + 0x0078) = edx_31 - 0x01;
	if (edx_31 == 0x01 && *((word32) eax_29 + 0x006C) != 0x00)
		((word32) eax_29 + 8)->u0 = ~0x0521;
}

// 080847D0: void runtime.traceFlush(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_72250) dwArg04)
// Called from:
//      runtime.traceEvent
void runtime.traceFlush(struct Eq_2 * gs, struct Eq_72250 * dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	int8 al_28;
	Eq_4 eax_17 = g_t814F4C4;
	if (eax_17 != 0x00)
		al_28 = (int8) (eax_17 != *((word32) (*((word32) (gs->ptr0000)->tFFFFFFFC + 24)) + 84));
	else
		al_28 = 0x01;
	if (al_28 != 0x00)
	{
		word32 edi_173;
		word32 esi_172;
		runtime.lock(esi, gs, 0x0814F4C0, out esi_172, out edi_173);
	}
	if (dwArg04 != null)
	{
		dwArg04->ptr0000 = null;
		if (g_ptr814F508 == null)
			g_ptr814F508 = dwArg04;
		else
			g_ptr814F50C->ptr0000 = dwArg04;
		g_ptr814F50C = dwArg04;
	}
	bool v15_130;
	struct Eq_72801 * ecx_103 = g_ptr814F504;
	if (ecx_103 != null)
	{
		g_ptr814F504 = ecx_103->ptr0000;
		v15_130 = al_28 != 0x00;
	}
	else
	{
		runtime.sysAlloc();
		if (dwLoc0C == null)
			runtime.throw(gs);
		v15_130 = al_28 != 0x00;
		ecx_103 = dwLoc0C;
	}
	ecx_103->ptr0000 = null;
	ecx_103->dw000C = 0x00;
	ecx_103->dw0004 = 0x00;
	ecx_103->dw0008 = 0x00;
	if (v15_130)
	{
		word32 edx_174;
		word32 ebx_175;
		runtime.unlock(gs, 0x0814F4C0, out edx_174, out ebx_175);
	}
}

// 08084920: void runtime.(*traceBuf).varint(Register Eq_72347 ebp, Register Eq_72347 esi, Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_72250) dwArg04, Stack (ptr32 Eq_72250) dwArg08, Stack Eq_72427 dwArg0C)
// Called from:
//      runtime.traceEvent
void runtime.(*traceBuf).varint(Eq_72347 ebp, Eq_72347 esi, struct Eq_2 * gs, struct Eq_72250 * dwArg04, struct Eq_72250 * dwArg08, Eq_72427 dwArg0C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_72347 ecx_17 = dwArg04->t000C;
	struct Eq_72250 * edx_18 = dwArg08;
	Eq_72427 ebx_19 = dwArg0C;
	while (true)
	{
		ui24 ebx_24_8_42 = SLICE(esi, word24, 8);
		Eq_72347 esi_60 = SEQ(ebx_24_8_42, (int8) (ebx_19 > 0x00)) | SEQ(SLICE(ebp, word24, 8), (int8) (ebx_19 == 0x00)) & SEQ(ebx_24_8_42, (int8) (edx_18 >= (struct Eq_72250 *) 0x80));
		byte dl_81 = (byte) edx_18;
		esi = esi_60;
		if ((byte) esi_60 == 0x00)
			break;
		if (ecx_17 >= 0xFDF0)
			runtime.panicindex(gs);
		Mem91[dwArg04 + 0x0210 + ecx_17:byte] = SLICE(edx_18, byte, 0) | 0x80;
		ebp = edx_18 >> 0x07;
		edx_18 = ebx_19 << 0x19 | ebp;
		ebx_19 >>= 0x07;
		ecx_17 = (word32) ecx_17 + 1;
	}
	if (ecx_17 >= 0xFDF0)
		runtime.panicindex(gs);
	else
	{
		Mem82[dwArg04 + 0x0210 + ecx_17:byte] = dl_81;
		dwArg04->t000C = (word32) ecx_17 + 1;
	}
}

// 080849C0: void runtime.(*traceStackTable).put(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack (ptr32 Eq_205) dwArg08, Stack Eq_4 dwArg0C)
// Called from:
//      runtime.traceStackID
//      runtime.traceGoCreate
void runtime.(*traceStackTable).put(struct Eq_2 * gs, Eq_4 dwArg04, union Eq_205 * dwArg08, Eq_4 dwArg0C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (dwArg0C == 0x00)
		return;
	word128 xmm1_262;
	runtime.memhash(gs, mm0, dwArg08, null, dwArg0C << 0x02, out xmm1_262);
	runtime.(*traceStackTable).find(gs, dwArg04, dwArg08, dwArg0C, dwLoc18);
	if (dwLoc10 != 0x00)
		return;
	word32 edi_264;
	word32 esi_263;
	runtime.lock(esi, gs, dwArg04, out esi_263, out edi_264);
	runtime.(*traceStackTable).find(gs, dwArg04, dwArg08, dwArg0C, dwLoc18);
	if (dwLoc10 != 0x00)
	{
		word32 edx_265;
		word32 ebx_266;
		runtime.unlock(gs, dwArg04, out edx_265, out ebx_266);
	}
	else
	{
		*((word32) dwArg04 + 4) = (word32) *((word32) dwArg04 + 4) + 1;
		runtime.(*traceStackTable).newStack(gs, dwArg0C);
		*((word32) dwArg0C + 4) = dwLoc18;
		*((word32) dwArg0C + 8) = *((word32) dwArg04 + 4);
		*((word32) dwArg0C + 0x0C) = dwArg0C;
		if (dwArg0C > 0x80)
			runtime.panicslice(gs);
		else
		{
			union Eq_205 * ebp_123 = dwArg08;
			Eq_4 esi_124 = 0x00;
			while (esi_124 < dwArg0C)
			{
				Eq_4 edi_162 = *ebp_123;
				if (esi_124 >= dwArg0C)
					runtime.panicindex(gs);
				*((word32) dwArg0C + (esi_124 * 0x04 + 16)) = edi_162;
				ebp_123 = (union Eq_205 *) ((char *) ebp_123 + 4);
				esi_124 = (word32) esi_124 + 1;
			}
			*dwArg0C = *((word32) dwArg04 + ((dwLoc18 & 0x1FFF) * 0x04 + 16));
			runtime.atomicstorep((word32) dwArg04 + 16 + (dwLoc18 & 0x1FFF) * 0x04, dwArg0C);
			word32 edx_267;
			word32 ebx_268;
			runtime.unlock(gs, dwArg04, out edx_267, out ebx_268);
		}
	}
}

// 08084B70: void runtime.(*traceStackTable).find(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack (ptr32 Eq_205) dwArg08, Stack Eq_4 dwArg0C, Stack Eq_4 dwArg14)
// Called from:
//      runtime.(*traceStackTable).put
void runtime.(*traceStackTable).find(struct Eq_2 * gs, Eq_4 dwArg04, union Eq_205 * dwArg08, Eq_4 dwArg0C, Eq_4 dwArg14)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 eax_25 = *((word32) dwArg04 + ((dwArg14 & 0x1FFF) * 0x04 + 16));
	while (eax_25 != 0x00)
	{
		if (dwArg14 == *((word32) eax_25 + 4))
		{
			Eq_4 ebp_41 = *((word32) eax_25 + 0x0C);
			if (ebp_41 == dwArg0C)
			{
				word32 * esi_45 = (word32) eax_25 + 16;
				if (ebp_41 > 0x80)
					runtime.panicslice(gs);
				else
				{
					Eq_4 edi_55 = 0x00;
					while (edi_55 < ebp_41)
					{
						Eq_4 edx_70 = *esi_45;
						if (edi_55 >= dwArg0C)
							runtime.panicindex(gs);
						if (edx_70 != *((char *) dwArg08 + edi_55 * 0x04))
							goto l08084BC5;
						++esi_45;
						edi_55 = (word32) edi_55 + 1;
					}
					return;
				}
			}
		}
l08084BC5:
		eax_25 = *eax_25;
	}
}

// 08084C30: void runtime.(*traceStackTable).newStack(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg08)
// Called from:
//      runtime.(*traceStackTable).put
void runtime.(*traceStackTable).newStack(struct Eq_2 * gs, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.(*traceAlloc).alloc(gs, dwArg04 + 0x08, (dwArg08 << 0x02) + 0x14);
}

// 08084C80: void runtime.(*traceAlloc).alloc(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_73136) dwArg04, Stack ui32 dwArg08)
// Called from:
//      runtime.(*traceStackTable).newStack
void runtime.(*traceAlloc).alloc(struct Eq_2 * gs, struct Eq_73136 * dwArg04, ui32 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	uint32 edx_21 = dwArg08 + 0x03 & ~0x03;
	if (dwArg04->ptr0000 == null || dwArg04->dw0004 + edx_21 > 0xFFFC)
	{
		if (edx_21 > 0xFFFC)
			runtime.throw(gs);
		runtime.sysAlloc();
		if (dwLoc04 == null)
			runtime.throw(gs);
		dwLoc04->ptr0000 = dwArg04->ptr0000;
		dwArg04->ptr0000 = dwLoc04;
		dwArg04->dw0004 = 0x00;
	}
	uint32 edx_71 = dwArg04->dw0004;
	if (edx_71 >= 0xFFFC)
		runtime.panicindex(gs);
	else
		dwArg04->dw0004 = edx_21 + edx_71;
}

// 08084D70: Register (ptr32 word32) runtime.traceGomaxprocs(Register (ptr32 Eq_2) gs, Register out ptr32 esiOut)
// Called from:
//      runtime.procresize
word32 * runtime.traceGomaxprocs(struct Eq_2 * gs, ptr32 & esiOut)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	ptr32 esi_36;
	word32 * ebp_31 = runtime.traceEvent(gs, 0x04, 0x01, fp - 0x08, 0x01, out esi_36);
	esiOut = esi_36;
	return ebp_31;
}

// 08084DE0: void runtime.traceProcStart(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.acquirep
void runtime.traceProcStart(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	word32 esi_52;
	runtime.traceEvent(gs, 0x05, ~0x00, fp - 0x08, 0x01, out esi_52);
}

// 08084E60: void runtime.traceProcStop(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      runtime.stopTheWorldWithSema
//      runtime.forEachP
//      runtime.entersyscall_gcwait
//      runtime.procresize
//      runtime.releasep
//      runtime.retake
void runtime.traceProcStop(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 eax_18 = gs->ptr0000->tFFFFFFFC;
	Eq_4 ecx_19 = *((word32) eax_18 + 24);
	*((word32) ecx_19 + 0x0078) = (word32) *((word32) ecx_19 + 0x0078) + 1;
	Eq_4 ecx_23 = *((word32) eax_18 + 24);
	Eq_4 eax_31 = *((word32) ecx_23 + 92);
	*((word32) ecx_23 + 92) = dwArg04;
	word32 esi_83;
	runtime.traceEvent(gs, 0x06, ~0x00, null, 0x00, out esi_83);
	*((word32) ecx_23 + 92) = eax_31;
	Eq_4 eax_48 = gs->ptr0000->tFFFFFFFC;
	Eq_4 edx_49 = *((word32) ecx_23 + 0x0078);
	*((word32) ecx_23 + 0x0078) = edx_49 - 0x01;
	if (edx_49 == 0x01 && *((word32) eax_48 + 0x006C) != 0x00)
		((word32) eax_48 + 8)->u0 = ~0x0521;
}

// 08084F20: void runtime.traceGCStart(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.gcStart
void runtime.traceGCStart(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	word32 esi_57;
	runtime.traceEvent(gs, 0x07, 0x03, fp - 0x08, 0x01, out esi_57);
	up32 eax_32 = g_dw814F4F8;
	word32 ecx_35 = g_dw814F4FC;
	g_dw814F4F8 = eax_32 + 0x01;
	g_dw814F4FC = (word32) ((bool) (eax_32 < 0x01) + ecx_35);
}

// 08084FB0: void runtime.traceGCDone(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.gcMarkTermination
void runtime.traceGCDone(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	word32 esi_36;
	runtime.traceEvent(gs, 0x08, ~0x00, null, 0x00, out esi_36);
}

// 08085000: void runtime.traceGCScanStart(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.gcMark
//      runtime.gchelper
void runtime.traceGCScanStart(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	word32 esi_36;
	runtime.traceEvent(gs, 0x09, ~0x00, null, 0x00, out esi_36);
}

// 08085050: void runtime.traceGCScanDone(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.gcMark
//      runtime.gchelper
void runtime.traceGCScanDone(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	word32 esi_36;
	runtime.traceEvent(gs, 0x0A, ~0x00, null, 0x00, out esi_36);
}

// 080850A0: void runtime.traceGCSweepStart(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.(*mcentral).cacheSpan
//      runtime.deductSweepCredit
//      runtime.(*mheap).alloc_m
void runtime.traceGCSweepStart(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 ecx_20 = *((word32) *((word32) gs->ptr0000->tFFFFFFFC + 24) + 92);
	if (*((word32) ecx_20 + 0x092C) != 0x00)
		runtime.throw(gs);
	else
	{
		*((word32) ecx_20 + 0x092C) = 0x01;
		*((word32) ecx_20 + 2352) = 0x00;
		*((word32) ecx_20 + 0x0934) = 0x00;
	}
}

// 08085120: void runtime.traceGCSweepSpan(Register (ptr32 Eq_2) gs, Stack ui32 dwArg04)
// Called from:
//      runtime.(*mspan).sweep
void runtime.traceGCSweepSpan(struct Eq_2 * gs, ui32 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 ecx_20 = *((word32) *((word32) gs->ptr0000->tFFFFFFFC + 24) + 92);
	if (*((word32) ecx_20 + 0x092C) != 0x00)
	{
		if (*((word32) ecx_20 + 2352) == 0x00)
		{
			word32 esi_101;
			runtime.traceEvent(gs, 11, 0x01, null, 0x00, out esi_101);
		}
		*((word32) ecx_20 + 2352) = (word32) *((word32) ecx_20 + 2352) + dwArg04;
	}
}

// 080851C0: Register word32 runtime.traceGCSweepDone(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.(*mcentral).cacheSpan
//      runtime.deductSweepCredit
//      runtime.(*mheap).alloc_m
word32 runtime.traceGCSweepDone(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 ecx_20 = *((word32) *((word32) gs->ptr0000->tFFFFFFFC + 24) + 92);
	if (*((word32) ecx_20 + 0x092C) == 0x00)
		runtime.throw(gs);
	else
	{
		if (*((word32) ecx_20 + 2352) != 0x00)
			runtime.traceEvent(gs, 0x0C, ~0x00, fp - 0x14, 0x02, out esi);
		*((word32) ecx_20 + 0x092C) = 0x00;
		return esi;
	}
}

// 080852B0: void runtime.traceGCMarkAssistStart(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.gcAssistAlloc
void runtime.traceGCMarkAssistStart(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	word32 esi_36;
	runtime.traceEvent(gs, 0x2B, 0x01, null, 0x00, out esi_36);
}

// 08085300: void runtime.traceGCMarkAssistDone(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.gcAssistAlloc
void runtime.traceGCMarkAssistDone(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	word32 esi_36;
	runtime.traceEvent(gs, 44, ~0x00, null, 0x00, out esi_36);
}

// 08085350: void runtime.traceGoCreate(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
// Called from:
//      runtime.newproc1
void runtime.traceGoCreate(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	((word32) dwArg04 + 0x007C)->u0 = 0x00;
	*((word32) dwArg04 + 0x0080) = null;
	*((word32) dwArg04 + 0x0084) = *((word32) *((word32) gs->ptr0000->tFFFFFFFC + 24) + 92);
	runtime.newobject(gs, 0x080CBDA0);
	*dwLoc20 = (word32) dwArg08 + 1;
	runtime.(*traceStackTable).put(gs, 135591188, dwLoc20, 0x01);
	word32 esi_122;
	runtime.traceEvent(gs, 0x0D, 0x02, fp - 0x10, 0x02, out esi_122);
}

// 08085450: void runtime.traceGoStart(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.execute
//      runtime.procresize
void runtime.traceGoStart(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 ecx_20 = *((word32) *((word32) gs->ptr0000->tFFFFFFFC + 24) + 84);
	Eq_4 ebx_22 = *((word32) ecx_20 + 0x007C);
	Eq_4 edx_25 = *((word32) *((word32) ecx_20 + 24) + 92);
	struct Eq_43073 * ebp_26 = *((word32) ecx_20 + 0x0080);
	*((word32) ecx_20 + 0x007C) = (word32) ebx_22 + 1;
	Mem30[ecx_20 + 0x80:word32] = ebp_26 + (ebx_22 <u 0x01);
	if (ecx_20 != *((word32) edx_25 + 0x0948))
	{
		if (*((word32) ecx_20 + 0x0084) == edx_25)
		{
			word32 esi_172;
			runtime.traceEvent(gs, 0x26, ~0x00, fp - 0x34, 0x01, out esi_172);
		}
		else
		{
			*((word32) ecx_20 + 0x0084) = edx_25;
			word32 esi_171;
			runtime.traceEvent(gs, 0x0E, ~0x00, fp - 44, 0x02, out esi_171);
		}
	}
	else
	{
		fn0808FD8A(0x00, fp - 0x1C);
		if (*((word32) edx_25 + 0x094C) >= 0x03)
			runtime.panicindex(gs);
		else
		{
			word32 esi_170;
			runtime.traceEvent(gs, 0x29, ~0x00, fp - 0x20, 0x03, out esi_170);
		}
	}
}

// 08085610: void runtime.traceGoEnd(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.goexit1
void runtime.traceGoEnd(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	word32 esi_48;
	runtime.traceEvent(gs, 0x0F, ~0x00, null, 0x00, out esi_48);
}

// 08085660: void runtime.traceGoSched(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.gosched_m
//      runtime.procresize
void runtime.traceGoSched(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 eax_19 = gs->ptr0000->tFFFFFFFC;
	*((word32) eax_19 + 0x0084) = *((word32) *((word32) eax_19 + 24) + 92);
	word32 esi_53;
	runtime.traceEvent(gs, 0x11, 0x01, null, 0x00, out esi_53);
}

// 080856D0: void runtime.traceGoPreempt(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.gopreempt_m
void runtime.traceGoPreempt(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 eax_18 = gs->ptr0000->tFFFFFFFC;
	*((word32) eax_18 + 0x0084) = *((word32) *((word32) eax_18 + 24) + 92);
	word32 esi_43;
	runtime.traceEvent(gs, 0x12, 0x01, null, 0x00, out esi_43);
}

// 08085740: void runtime.traceGoPark(Register (ptr32 Eq_2) gs, Stack Eq_4 bArg04, Stack Eq_4 dwArg08)
// Called from:
//      runtime.park_m
void runtime.traceGoPark(struct Eq_2 * gs, Eq_4 bArg04, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	word32 eax_17 = (word32) bArg04;
	if (((byte) eax_17 & 0x80) != 0x00)
	{
		word32 esi_88;
		runtime.traceEvent(gs, 0x24, ~0x00, null, 0x00, out esi_88);
		eax_17 = (word32) bArg04;
	}
	word32 esi_89;
	runtime.traceEvent(gs, (byte) eax_17 & 0x7F, dwArg08, null, 0x00, out esi_89);
}

// 080857D0: void runtime.traceGoUnpark(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      runtime.(*gcControllerState).findRunnableGCWorker
//      runtime.ready
//      runtime.findrunnable
//      runtime.injectglist
//      runtime.schedule
//      runtime.park_m
//      runtime.procresize
void runtime.traceGoUnpark(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 edx_21 = *((word32) dwArg04 + 0x007C);
	Eq_4 eax_24 = *((word32) *((word32) gs->ptr0000->tFFFFFFFC + 24) + 92);
	struct Eq_43073 * ebx_25 = *((word32) dwArg04 + 0x0080);
	*((word32) dwArg04 + 0x007C) = (word32) edx_21 + 1;
	Mem29[dwArg04 + 0x80:word32] = ebx_25 + (edx_21 <u 0x01);
	if (*((word32) dwArg04 + 0x0084) == eax_24)
	{
		word32 esi_115;
		runtime.traceEvent(gs, 0x27, dwArg08, fp - 0x18, 0x01, out esi_115);
	}
	else
	{
		*((word32) dwArg04 + 0x0084) = eax_24;
		word32 esi_114;
		runtime.traceEvent(gs, 0x15, dwArg08, fp - 0x10, 0x02, out esi_114);
	}
}

// 080858F0: void runtime.traceGoSysCall(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.entersyscallblock_handoff
void runtime.traceGoSysCall(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	word32 esi_48;
	runtime.traceEvent(gs, 0x1C, 0x01, null, 0x00, out esi_48);
}

// 08085940: void runtime.traceGoSysExit(Register word24 edx_24_8, Register word32 ebp, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
// Called from:
//      runtime.execute
//      runtime.exitsyscallfast.func1
//      runtime.exitsyscallfast_reacquired.func1
void runtime.traceGoSysExit(word24 edx_24_8, word32 ebp, struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (((int8) (dwArg08 != 0x00) | (int8) (dwArg04 != 0x00)) != 0x00)
	{
		Eq_4 edx_46 = g_t814F4DC;
		Eq_4 esi_58 = g_t814F4D8;
	}
	Eq_4 edx_102 = *((word32) *((word32) gs->ptr0000->tFFFFFFFC + 24) + 84);
	Eq_4 ebx_103 = *((word32) edx_102 + 0x007C);
	struct Eq_43073 * ebp_106 = *((word32) edx_102 + 0x0080);
	*((word32) edx_102 + 0x007C) = (word32) ebx_103 + 1;
	Mem110[edx_102 + 0x80:word32] = ebp_106 + (ebx_103 <u 0x01);
	*((word32) edx_102 + 0x0084) = *((word32) *((word32) edx_102 + 24) + 92);
	fn0808FD8A(0x00, fp - 0x18);
	word32 esi_181;
	runtime.traceEvent(gs, 0x1D, ~0x00, fp - 0x1C, 0x03, out esi_181);
}

// 08085A80: Register Eq_4 runtime.traceGoSysBlock(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Register out (ptr32 word32) ebpOut, Register out ptr32 esiOut)
// Called from:
//      runtime.stopTheWorldWithSema
//      runtime.forEachP
//      runtime.entersyscall_gcwait
//      runtime.entersyscallblock_handoff
//      runtime.retake
//      runtime.exitsyscallfast_reacquired.func1
Eq_4 runtime.traceGoSysBlock(struct Eq_2 * gs, Eq_4 dwArg04, word32 & ebpOut, ptr32 & esiOut)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 eax_18 = gs->ptr0000->tFFFFFFFC;
	Eq_4 ecx_19 = *((word32) eax_18 + 24);
	*((word32) ecx_19 + 0x0078) = (word32) *((word32) ecx_19 + 0x0078) + 1;
	Eq_4 ecx_23 = *((word32) eax_18 + 24);
	Eq_4 eax_31 = *((word32) ecx_23 + 92);
	*((word32) ecx_23 + 92) = dwArg04;
	ptr32 esi_46;
	word32 * ebp_41 = runtime.traceEvent(gs, 0x1E, ~0x00, null, 0x00, out esi_46);
	*((word32) ecx_23 + 92) = eax_31;
	Eq_4 eax_56 = gs->ptr0000->tFFFFFFFC;
	Eq_4 edx_57 = *((word32) ecx_23 + 0x0078);
	*((word32) ecx_23 + 0x0078) = edx_57 - 0x01;
	if (edx_57 == 0x01 && *((word32) eax_56 + 0x006C) != 0x00)
		((word32) eax_56 + 8)->u0 = ~0x0521;
	ebpOut = ebp_41;
	esiOut = esi_46;
	return edx_57;
}

// 08085B40: Register (ptr32 word32) runtime.traceHeapAlloc(Register (ptr32 Eq_2) gs, Register out ptr32 esiOut)
// Called from:
//      runtime.(*mcentral).cacheSpan
//      runtime.gcMark
//      runtime.(*mheap).alloc_m
word32 * runtime.traceHeapAlloc(struct Eq_2 * gs, ptr32 & esiOut)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	ptr32 esi_36;
	word32 * ebp_31 = runtime.traceEvent(gs, 33, ~0x00, fp - 0x08, 0x01, out esi_36);
	esiOut = esi_36;
	return ebp_31;
}

// 08085BB0: void runtime.traceNextGC(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.gcSetTriggerRatio
void runtime.traceNextGC(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 eax_16 = g_t8158228;
	Eq_4 ecx_17 = g_t815822C;
	if (((int8) (ecx_17 == ~0x00) & (int8) (eax_16 == ~0x00)) != 0x00)
	{
		word32 esi_90;
		runtime.traceEvent(gs, 0x22, ~0x00, fp - 0x08, 0x01, out esi_90);
	}
	else
	{
		word32 esi_89;
		runtime.traceEvent(gs, 0x22, ~0x00, fp - 0x10, 0x01, out esi_89);
	}
}

// 08085C90: void runtime.tracebackinit(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.schedinit
void runtime.tracebackinit(struct Eq_2 * gs)
{
	while (fp - 0x08 <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.goexitPC = g_t80E7C14;
	runtime.jmpdeferPC = g_dw80E7C28;
	runtime.mcallPC = g_t80E7C40;
	runtime.morestackPC = g_t80E7C7C;
	runtime.mstartPC = g_t80E7C84;
	runtime.rt0_goPC = g_t80E7CB0;
	runtime.sigpanicPC = g_t80E7CC0;
	runtime.runfinqPC = g_t80E7CB8;
	runtime.bgsweepPC = g_t80E7B94;
	runtime.forcegchelperPC = g_t80E7BF0;
	runtime.timerprocPC = g_t80E7CF4;
	runtime.gcBgMarkWorkerPC = g_t80E7BFC;
	runtime.systemstack_switchPC = g_t80E7CEC;
	runtime.systemstackPC = g_t80E7CF0;
	runtime.cgocallback_gofuncPC = g_t80E7BB8;
	runtime.skipPC = g_dw80E7CD0;
	runtime.gogoPC = g_t80E7C18;
}

// 08085F30: void runtime.tracebackdefers(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg00, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
// Called from:
//      runtime.scanstack
//      runtime.adjustdefers
void runtime.tracebackdefers(struct Eq_2 * gs, Eq_4 dwArg00, Eq_4 dwArg04, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	fn0808FD85(0x00, fp - 44);
	Eq_4 ecx_152 = *((word32) dwArg00 + 20);
	while (ecx_152 != 0x00)
	{
		Eq_4 dwLoc28_161;
		Eq_4 eax_33 = *((word32) ecx_152 + 16);
		if (eax_33 == 0x00)
			dwLoc28_161.u0 = 0x00;
		else
		{
			Eq_4 ecx_38 = *eax_33;
			runtime.findfunc(gs, ecx_38);
			dwLoc28_161 = ecx_38;
			if (dwLoc54 == 0x00)
			{
				runtime.printlock(gs);
				runtime.printstring(gs);
				word32 esi_273;
				runtime.printhex(esi, gs, ecx_38, 0x00, out esi_273);
				runtime.printstring(gs);
				runtime.printunlock(gs);
				runtime.throw(gs);
			}
			*ecx_152 != 0x00;
			runtime.getArgInfo(gs, fp - 0x30, dwLoc54, 0x01, eax_33);
		}
		(*dwArg04)();
		dwLoc54 = dwArg08;
		if ((byte) dwLoc50 == 0x00)
			return;
		ecx_152 = *((word32) ecx_152 + 24);
	}
}

// 080860D0: void runtime.gentraceback(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C, Stack Eq_4 dwArg10, Stack Eq_4 dwArg14, Stack Eq_4 dwArg18, Stack Eq_4 dwArg1C, Stack Eq_4 dwArg20, Stack Eq_28301 dwArg24)
// Called from:
//      runtime.scanstack
//      runtime.sigprof
//      runtime.copystack
//      runtime.traceback1
//      runtime.gcallers
//      runtime.callers.func1
void runtime.gentraceback(struct Eq_2 * gs, Eq_4 dwArg08, Eq_4 dwArg0C, Eq_4 dwArg10, Eq_4 dwArg14, Eq_4 dwArg18, Eq_4 dwArg1C, Eq_4 dwArg20, Eq_28301 dwArg24)
{
	while (fp - 0x0140 <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 dwLoc30_1979 = 0x00;
	if (dwArg14 <= 0x00 || dwArg20 == 0x00)
	{
		if (runtime.goexitPC == 0x00)
			runtime.throw(gs);
		else
		{
			Eq_4 edx_52 = gs->ptr0000->tFFFFFFFC;
			if (edx_52 != dwArg10 || edx_52 != *((word32) (*((word32) edx_52 + 24)) + 84))
			{
				Eq_4 edx_111;
				Eq_4 ebx_109;
				runtime.gotraceback(dwLoc01C4);
				if (dwArg08 == ~0x00)
				{
					edx_111 = dwArg0C;
					if (dwArg0C == ~0x00)
					{
						edx_111 = *((word32) dwArg14 + 56);
						if (edx_111 != 0x00)
							ebx_109 = *((word32) dwArg14 + 60);
						else
						{
							ebx_109 = *((word32) dwArg14 + 32);
							edx_111 = *((word32) dwArg14 + 28);
						}
					}
					else
						ebx_109 = dwArg08;
				}
				else
				{
					ebx_109 = dwArg08;
					edx_111 = dwArg0C;
				}
				fn0808FD85(0x00, fp - 0x28);
				Eq_4 dwLoc24_2298 = ebx_109;
				Eq_4 dwLoc18_2299 = edx_111;
				Eq_4 esi_115 = *((word32) dwArg10 + 0x00B8);
				Eq_4 edi_153 = *((word32) dwArg10 + 20);
				while (edi_153 != 0x00 && *((word32) edi_153 + 8) == ~0x00)
					edi_153 = *((word32) edi_153 + 24);
				if (ebx_109 == 0x00)
				{
					dwLoc24_2298 = *edx_111;
					dwLoc18_2299 = (word32) edx_111 + 4;
				}
				runtime.findfunc(gs, dwLoc24_2298);
				Eq_4 dwLoc01C0_2325 = dwLoc24_2298;
				if (dwLoc01BC == 0x00)
				{
					if (dwArg20 == 0x00)
						return;
					runtime.printlock(gs);
					runtime.printstring(gs);
					word32 esi_3992;
					runtime.printhex(esi, gs, dwLoc24_2298, 0x00, out esi_3992);
					runtime.printstring(gs);
					runtime.printunlock(gs);
					runtime.throw(gs);
				}
				else
				{
					fn0808FD60(0x00, fp - 0x0130);
					Eq_4 dwLoc2C_2366 = dwLoc01BC;
					Eq_4 dwLoc28_2367 = dwLoc01B8;
					Eq_4 eax_1949 = 0x00;
					int8 cl_1948 = 0x00;
					Eq_4 edx_1961 = dwLoc54;
					Eq_4 ebx_1954 = dwLoc0174;
					Eq_4 esi_1955 = 0x00;
					Eq_4 edi_1956 = esi_115;
					while (true)
					{
						Eq_4 eax_1581;
						Eq_4 edi_1591;
						Eq_4 ecx_1582;
						if (eax_1949 >= dwArg18)
							break;
						if (*((word32) dwLoc30_1979 + 16) == 0x00)
						{
							eax_1581 = edi_1956;
							ecx_1582 = eax_1949;
							edi_1591 = esi_1955;
							goto l08086500;
						}
						if (dwLoc18_2299 == 0x00)
						{
							Eq_4 ebx_312;
							Eq_4 edx_311;
							Eq_4 eax_302 = dwLoc1C;
							if ((dwArg24 & 0x04) != 0x00)
							{
								if (runtime.systemstackPC == *dwLoc30_1979)
								{
									if (dwLoc6C->ptr0018->t0000 == dwArg0C)
									{
										Eq_4 edi_331 = *((word32) *((word32) dwArg0C + 24) + 84);
										if (edi_331 != 0x00)
										{
											eax_302 = *((word32) edi_331 + 28);
											Eq_4 edx_341 = *((word32) *((word32) dwArg0C + 24) + 84);
											dwLoc1C = eax_302;
											ebx_312 = *((word32) edx_341 + 0x00B8);
											edx_311 = *((word32) edx_341 + 188);
										}
										else
										{
											edx_311 = ebx_1954;
											ebx_312 = edx_1961;
										}
									}
									else
									{
										edx_311 = ebx_1954;
										ebx_312 = edx_1961;
									}
								}
								else
								{
									edx_311 = ebx_1954;
									ebx_312 = edx_1961;
								}
							}
							else
							{
								edx_311 = ebx_1954;
								ebx_312 = edx_1961;
								eax_302 = dwLoc1C;
							}
							runtime.funcspdelta(gs, dwLoc30_1979);
							dwLoc01C0_2325 = dwLoc2C_2366;
							dwLoc01BC = dwLoc28_2367;
							dwLoc01B8 = fp - 0x0134;
							dwLoc18_2299 = (byte) dwLoc01B4.u0 + ((word32) eax_302 + 4);
							ebx_1954 = edx_311;
							edx_1961 = ebx_312;
						}
						int8 al_404;
						word24 nLoc01B7_2639 = SLICE(dwLoc01B8, word24, 8);
						Eq_4 eax_379 = *dwLoc30_1979;
						if (runtime.goexitPC == eax_379)
							al_404 = 0x01;
						else if (runtime.mstartPC == eax_379)
							al_404 = 0x01;
						else if (runtime.mcallPC == eax_379)
							al_404 = 0x01;
						else if (runtime.morestackPC == eax_379)
							al_404 = 0x01;
						else if (runtime.rt0_goPC == eax_379)
							al_404 = 0x01;
						else
						{
							Eq_4 ebx_395 = runtime.externalthreadhandlerp;
							if (ebx_395 != 0x00)
								al_404 = (int8) (eax_379 == ebx_395);
							else
								al_404 = 0x00;
						}
						Eq_4 ebx_525;
						Eq_4 eax_444;
						if (al_404 != 0x00)
						{
							dwLoc20.u0 = 0x00;
							eax_444.u0 = 0x00;
							ebx_525.u0 = 0x00;
						}
						else
						{
							if (dwLoc20 == 0x00)
								dwLoc20 = *((byte) dwLoc18_2299.u0 - 4);
							runtime.findfunc(gs, dwLoc20);
							eax_444 = dwLoc01BC;
							if (dwLoc01C0_2325 == 0x00 && dwArg1C != 0x00)
							{
								runtime.funcname(gs, dwLoc30_1979, dwLoc2C_2366);
								runtime.printlock(gs);
								runtime.printstring(gs);
								runtime.printstring(gs);
								runtime.printstring(gs);
								word32 esi_4002;
								runtime.printhex(esi, gs, dwLoc20, 0x00, out esi_4002);
								runtime.printstring(gs);
								runtime.printunlock(gs);
								runtime.throw(gs);
							}
							ebx_525 = dwLoc01C0_2325;
						}
						word32 esi_554;
						int8 bl_545 = (int8) (dwArg1C != 0x00);
						if (dwArg1C == 0x00)
						{
							word32 esi_546 = (word32) bLoc01A5;
							esi_554 = esi_546;
							if ((byte) esi_546 == 0x00)
								goto l080864B3;
						}
						runtime.getArgInfo(gs, fp - 0x30, dwLoc30_1979, bl_545, dwArg10);
						dwLoc10 = dwLoc18_2299;
						dwLoc01C0_2325 = dwLoc30_1979;
						dwLoc01BC = dwLoc2C_2366;
						dwLoc01B4.u0 = 0x00;
						dwLoc0C = dwLoc01B0;
						esi_554 = (word32) bLoc01A5;
						dwLoc01B8 = SEQ(nLoc01B7_2639, bl_545);
l080864B3:
						byte bLoc01BC_2653 = (byte) dwLoc01BC;
						Eq_4 edi_603 = edi_1956;
						if (cl_1948 != 0x00 && (edi_1956 == 0x00 || dwLoc1C != *((word32) edi_1956 + 8)))
							;
						while (edi_603 != 0x00)
						{
							Eq_4 ecx_626 = *((word32) edi_603 + 8);
							if (dwLoc1C != ecx_626 && ecx_626 != ~0x00)
								break;
							edi_603 = *((word32) edi_603 + 24);
						}
						if (dwArg1C != 0x00)
						{
							(*dwArg1C)();
							dwLoc01C0_2325 = dwArg20;
							if (bLoc01BC_2653 == 0x00)
								return;
							esi_554 = (word32) bLoc01A5;
						}
						Eq_4 eax_1490;
						Eq_4 edi_1435;
						Eq_4 ebx_1531;
						Eq_4 ebx_686;
						Eq_4 eax_685;
						if (dwArg14 != 0x00)
						{
							ebx_686 = dwArg10;
							if (dwArg10 == 0x00)
							{
								eax_685 = eax_1949;
								if (eax_1949 >= 0x00100000)
									runtime.panicindex(gs);
								*((word32) dwArg14 + eax_1949 * 0x04) = dwLoc28_2367;
								goto l080862FC;
							}
							Eq_4 esi_691 = dwLoc28_2367;
							if ((eax_1949 > 0x00 || (dwArg24 & 0x02) == 0x00) && (dwLoc28_2367 > *dwLoc30_1979 && cl_1948 == 0x00))
								esi_691 = dwLoc28_2367 - 0x01;
							runtime.funcdata(gs, dwLoc30_1979, 0x02);
							dwLoc01C0_2325 = dwLoc2C_2366;
							dwLoc01BC.u0 = 0x02;
							if (dwLoc01B8 == 0x00)
							{
								ebx_1531 = dwArg10 - 0x01;
								edi_1435 = esi_1955;
								eax_1490 = eax_1949;
								goto l0808630B;
							}
							runtime.pcdatavalue(gs, dwLoc30_1979, 0x01);
							dwLoc01C0_2325 = dwLoc2C_2366;
							dwLoc01BC.u0 = 0x01;
							dwLoc01B8 = esi_691;
							dwLoc01B4 = fp - 0x0134;
							Eq_4 eax_763 = dwLoc01B0;
							Eq_4 edx_765 = dwArg10;
							word32 ebx_766 = 0x00;
							while (eax_763 >= 0x00 && edx_765 > 0x00)
							{
								if (eax_763 >= 0x00100000)
									runtime.panicindex(gs);
								--edx_765;
								++ebx_766;
								eax_763 = *((byte) dwLoc01B8.u0 + eax_763 * 0x10);
							}
							dwLoc01B4 = fp - 0x0134;
							if (edx_765 > 0x00)
							{
								ebx_1531 = edx_765 - 0x01;
								edi_1435 = esi_1955;
								eax_1490 = eax_1949;
								goto l0808630B;
							}
							if (eax_1949 >= 0x00100000)
								runtime.panicindex(gs);
							*((word32) dwArg14 + eax_1949 * 0x04) = dwLoc28_2367;
							eax_685 = (word32) eax_1949 + 1;
							if ((word32) eax_1949 + 1 < dwArg18)
							{
								Eq_4 ebx_812 = ebx_766 + g_dw80E7CD0;
								if (eax_1949 >= 0x000FFFFF)
									runtime.panicindex(gs);
								*((word32) dwArg14 + (eax_1949 * 0x04 + 4)) = ebx_812;
							}
							else
								eax_685 = eax_1949;
							esi_554 = (word32) bLoc01A5;
							ebx_686 = edx_765;
						}
						else
						{
							eax_685 = eax_1949;
							ebx_686 = dwArg10;
						}
l080862FC:
						word24 nLoc01B7_2902 = SLICE(dwLoc01B8, word24, 8);
						byte bLoc01B4_2847 = (byte) dwLoc01B4;
						if ((byte) esi_554 == 0x00)
						{
							edi_1435 = esi_1955;
							dwLoc01B4 = dwLoc01B4_2931;
							goto l0808630A;
						}
						Eq_4 eax_1425;
						dwLoc01B4_2931 = dwLoc01B4;
						if ((dwArg24 & 0x01) != 0x00)
						{
l080867B6:
							Eq_4 esi_926 = dwLoc28_2367;
							if ((eax_685 > 0x00 || (dwArg24 & 0x02) == 0x00) && (dwLoc28_2367 > *dwLoc30_1979 && cl_1948 == 0x00))
								esi_926 = dwLoc28_2367 - 0x01;
							Eq_4 dwLoc01B4_2953;
							Eq_4 edx_1013;
							runtime.funcline(gs);
							runtime.funcdata(gs, dwLoc30_1979, 0x02);
							dwLoc01BC.u0 = 0x02;
							if (dwLoc01B8 == 0x00)
							{
								edx_1013 = dwLoc01B0;
								dwLoc01B4_2953 = dwLoc01B4_2931;
							}
							else
							{
								runtime.pcdatavalue(gs, dwLoc30_1979, 0x01);
								dwLoc01BC.u0 = 0x01;
								dwLoc01B8 = esi_926;
								dwLoc01B4_2953.u0 = 0x00;
								Eq_4 eax_1003 = dwLoc01B0;
								Eq_4 ebx_1006 = dwLoc01B0;
								while (eax_1003 != ~0x00)
								{
									if (eax_1003 >= 0x00100000)
										runtime.panicindex(gs);
									runtime.funcnameFromNameoff(gs, dwLoc30_1979, dwLoc2C_2366, *((byte) dwLoc01B8.u0 + eax_1003 * 0x10));
									runtime.printlock(gs);
									runtime.printstring(gs);
									runtime.printstring(gs);
									runtime.printunlock(gs);
									runtime.printlock(gs);
									runtime.printstring(gs);
									runtime.printstring(gs);
									runtime.printstring(gs);
									runtime.printint(ebx_24_8, gs, ebx_1006);
									runtime.printstring(gs);
									runtime.printunlock(gs);
									Eq_4 edx_1111 = *((byte) dwLoc01B8.u0 + (eax_1003 * 0x10 + 4));
									runtime.funcfile(gs, dwLoc30_1979, dwLoc2C_2366, edx_1111);
									dwLoc01BC = edx_1111;
									eax_1003 = *((byte) dwLoc01B8.u0 + eax_1003 * 0x10);
									ebx_1006 = *((byte) dwLoc01B8.u0 + (eax_1003 * 0x10 + 8));
								}
								edx_1013 = ebx_1006;
							}
							runtime.funcname(gs, dwLoc30_1979, dwLoc2C_2366);
							byte bLoc01B4_3013 = (byte) dwLoc01B4_2953;
							if (dwLoc01B8 == 0x0F)
							{
								word32 ebx_4003;
								word32 esi_4004;
								word32 edi_4005;
								runtime.eqstring(0x080E23CE, dwLoc01BC, dwLoc01B8, 0x080E23CE, out ebx_4003, out esi_4004, out edi_4005);
								dwLoc01BC.u0 = 0x080E23CE;
								dwLoc01B8.u0 = 0x0F;
								dwLoc01B4_3704 = dwLoc01B4_2953;
							}
							runtime.printlock(gs);
							runtime.printstring(gs);
							runtime.printstring(gs);
							runtime.printunlock(gs);
							uint32 ecx_1212;
							for (ecx_1212 = 0x00; ecx_1212 < dwLoc0C >> 0x02; ++ecx_1212)
							{
								if (ecx_1212 >= 0x0A)
								{
									runtime.printlock(gs);
									runtime.printstring(gs);
									runtime.printunlock(gs);
									break;
								}
								dwLoc0180 = ecx_1212;
								if (ecx_1212 != 0x00)
								{
									runtime.printlock(gs);
									runtime.printstring(gs);
									runtime.printunlock(gs);
								}
								Eq_4 edx_1465 = *((word32) dwLoc10 + ecx_1212 * 0x04);
								runtime.printlock(gs);
								word32 esi_4006;
								runtime.printhex(esi, gs, edx_1465, 0x00, out esi_4006);
								runtime.printunlock(gs);
							}
							runtime.printlock(gs);
							runtime.printstring(gs);
							runtime.printunlock(gs);
							runtime.printlock(gs);
							runtime.printstring(gs);
							runtime.printstring(gs);
							runtime.printstring(gs);
							runtime.printint(ebx_24_8, gs, edx_1013);
							runtime.printunlock(gs);
							Eq_4 edx_1298 = *dwLoc30_1979;
							if (dwLoc28_2367 > edx_1298)
							{
								runtime.printlock(gs);
								runtime.printstring(gs);
								word32 esi_4007;
								runtime.printhex(esi, gs, dwLoc28_2367 - edx_1298, 0x00, out esi_4007);
								runtime.printunlock(gs);
							}
							struct Eq_74612 * edx_1332 = dwLoc6C->ptr0018;
							if (edx_1332->dw006C > 0x00 && edx_1332->t0054 == dwArg0C || dwLoc0184 >= 0x02)
							{
								runtime.printlock(gs);
								runtime.printstring(gs);
								word32 esi_4008;
								runtime.printhex(esi, gs, dwLoc18_2299, 0x00, out esi_4008);
								runtime.printstring(gs);
								word32 esi_4009;
								runtime.printhex(esi, gs, dwLoc1C, 0x00, out esi_4009);
								runtime.printstring(gs);
								word32 esi_4010;
								runtime.printhex(esi, gs, dwLoc28_2367, 0x00, out esi_4010);
								runtime.printunlock(gs);
							}
							runtime.printlock(gs);
							runtime.printstring(gs);
							runtime.printunlock(gs);
							dwLoc01C0_2325.u0 = 0x01;
							eax_1425 = (word32) esi_1955 + 1;
							dwLoc01B4 = dwLoc01B4_3704;
							goto l08086B06;
						}
						int8 bl_903 = (int8) (esi_1955 == 0x00);
						runtime.showframe(gs, dwLoc30_1979, dwArg0C, bl_903);
						dwLoc01C0_2325 = dwLoc2C_2366;
						dwLoc01BC = dwArg0C;
						dwLoc01B8 = SEQ(nLoc01B7_2902, bl_903);
						if (bLoc01B4_2847 != 0x00)
							goto l080867B6;
						eax_1425 = esi_1955;
						dwLoc01B4 = dwLoc01B4_2931;
l08086B06:
						edi_1435 = eax_1425;
l0808630A:
						ebx_1531 = ebx_686;
						eax_1490 = (word32) eax_685 + 1;
l0808630B:
						Eq_4 esi_1509;
						word24 nLoc01BF_3734 = SLICE(dwLoc01C0_2325, word24, 8);
						if (runtime.cgocallback_gofuncPC == *dwLoc30_1979 && ebx_1954 > 0x00)
						{
							esi_1509 = ebx_1954 - 0x01;
							if (ebx_1954 - 0x01 >= ebx_1954)
								runtime.panicindex(gs);
							Eq_4 ecx_1530 = (edx_1961 - 0x04)[ebx_1954];
							if (ebx_1531 == 0x00 && dwArg1C == 0x00)
							{
								runtime.tracebackCgoContext(gs, dwArg14, bLoc01A5);
								dwLoc01BC = ecx_1530;
								dwLoc01B8 = eax_1490;
								dwLoc01B4 = dwArg18;
								eax_1490 = dwLoc01B0;
								esi_1509 = ebx_1954 - 0x01;
								dwLoc01C0_2325 = SEQ(nLoc01BF_3734, bLoc01A5);
							}
						}
						else
							esi_1509 = ebx_1954;
						edi_1591 = edi_1435;
						Eq_4 ebp_1575 = *dwLoc30_1979;
						Eq_4 ecx_1576 = runtime.sigpanicPC;
						if (ebx_525 == 0x00)
						{
							eax_1581 = edi_603;
							ecx_1582 = eax_1490;
							goto l08086500;
						}
						dwLoc30_1979 = ebx_525;
						dwLoc2C_2366 = eax_444;
						dwLoc28_2367 = dwLoc20;
						dwLoc20.u0 = 0x00;
						dwLoc1C = dwLoc18_2299;
						dwLoc18_2299.u0 = 0x00;
						cl_1948 = (int8) (ecx_1576 == ebp_1575);
						eax_1949 = eax_1490;
						ebx_1954 = esi_1509;
						esi_1955 = edi_1435;
						edi_1956 = edi_603;
					}
					ecx_1582 = eax_1949;
					eax_1581 = edi_1956;
					edi_1591 = esi_1955;
l08086500:
					if (bLoc01A5 == 0x00)
						edi_1591 = ecx_1582;
					if (dwArg1C == 0x00 || (edi_1591 >= dwArg18 || eax_1581 == 0x00))
					{
						if (dwArg1C == 0x00 || edi_1591 >= dwArg18)
							return;
						Eq_4 ebx_1626 = *((word32) dwArg0C + 64);
						if (dwLoc1C == ebx_1626)
							return;
						Eq_4 edx_1634 = *((word32) dwArg0C + 80);
						runtime.printlock(gs);
						runtime.printstring(gs);
						runtime.printint(ebx_24_8, gs, edx_1634);
						runtime.printstring(gs);
						word32 esi_3998;
						runtime.printhex(esi, gs, dwLoc1C, 0x00, out esi_3998);
						runtime.printstring(gs);
						word32 esi_3999;
						runtime.printhex(esi, gs, ebx_1626, 0x00, out esi_3999);
						runtime.printstring(gs);
						runtime.printunlock(gs);
						Eq_4 ecx_1700 = *dwArg0C;
						Eq_4 eax_1702 = *((word32) dwArg0C + 4);
						runtime.printlock(gs);
						runtime.printstring(gs);
						word32 esi_4000;
						runtime.printhex(esi, gs, ecx_1700, 0x00, out esi_4000);
						runtime.printstring(gs);
						word32 esi_4001;
						runtime.printhex(esi, gs, eax_1702, 0x00, out esi_4001);
						runtime.printstring(gs);
						runtime.printint(ebx_24_8, gs, edi_1591);
						runtime.printstring(gs);
						runtime.printint(ebx_24_8, gs, dwArg18);
						runtime.printstring(gs);
						runtime.printunlock(gs);
						runtime.throw(gs);
					}
					else
					{
						Eq_4 ebx_1794 = *((word32) dwArg0C + 80);
						Eq_4 ebp_1796 = *((word32) eax_1581 + 8);
						Eq_4 eax_1798 = *((word32) eax_1581 + 0x0C);
						runtime.printlock(gs);
						runtime.printstring(gs);
						runtime.printint(ebx_24_8, gs, ebx_1794);
						runtime.printstring(gs);
						word32 esi_3994;
						runtime.printhex(esi, gs, ebp_1796, 0x00, out esi_3994);
						runtime.printstring(gs);
						word32 esi_3995;
						runtime.printhex(esi, gs, eax_1798, 0x00, out esi_3995);
						runtime.printstring(gs);
						runtime.printunlock(gs);
						Eq_4 eax_1859 = *((word32) dwArg0C + 20);
						while (eax_1859 != 0x00)
						{
							Eq_4 ecx_1866 = *((word32) eax_1859 + 8);
							Eq_4 edx_1868 = *((word32) eax_1859 + 0x0C);
							runtime.printlock(gs);
							runtime.printstring(gs);
							runtime.printpointer(gs);
							runtime.printstring(gs);
							word32 esi_3996;
							runtime.printhex(esi, gs, ecx_1866, 0x00, out esi_3996);
							runtime.printstring(gs);
							word32 esi_3997;
							runtime.printhex(esi, gs, edx_1868, 0x00, out esi_3997);
							runtime.printstring(gs);
							runtime.printunlock(gs);
							eax_1859 = *((word32) eax_1859 + 24);
						}
						runtime.throw(gs);
					}
				}
			}
			else
				runtime.throw(gs);
		}
	}
	else
		runtime.throw(gs);
}

// 08087730: void runtime.getArgInfo(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_74378) dwArg04, Stack Eq_4 dwArg08, Stack int8 bArg10, Stack Eq_4 dwArg14)
// Called from:
//      runtime.tracebackdefers
//      runtime.gentraceback
void runtime.getArgInfo(struct Eq_2 * gs, struct Eq_74378 * dwArg04, Eq_4 dwArg08, int8 bArg10, Eq_4 dwArg14)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 ecx_18 = *((word32) dwArg08 + 8);
	if (bArg10 == 0x00 || ecx_18 != 0x80000000)
		return;
	Eq_4 edx_35 = runtime.funcname(gs, dwArg08, dwArg0C);
	if (dwLoc14 == 0x14)
	{
		word32 esi_280;
		word32 ebx_279;
		word32 edi_281;
		edx_35 = runtime.eqstring(135147931, dwLoc18, dwLoc14, 135147931, out ebx_279, out esi_280, out edi_281);
		if (bLoc10 != 0x00)
			goto l080877C8;
	}
	if (dwLoc14 != 0x17)
		return;
	word32 ebx_282;
	word32 esi_283;
	word32 edi_284;
	runtime.eqstring(edx_35, dwLoc18, dwLoc14, 135150179, out ebx_282, out esi_283, out edi_284);
	if (bLoc10 == 0x00)
		return;
l080877C8:
	Eq_4 eax_100 = dwArg14;
	if (dwArg14 == 0x00)
		eax_100 = *dwArg04->ptr0014;
	if (*eax_100 == *dwArg08)
		return;
	runtime.funcname(gs, dwArg08, dwArg0C);
	runtime.printlock(gs);
	runtime.printstring(gs);
	runtime.printstring(gs);
	runtime.printstring(gs);
	runtime.printunlock(gs);
	runtime.throw(gs);
}

// 080878C0: void runtime.tracebackCgoContext(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
// Called from:
//      runtime.gentraceback
void runtime.tracebackCgoContext(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08)
{
	while (fp - 188 <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	fn0808FD70(0x00, fp - 288);
	runtime.cgoContextPCs(gs, 0x20);
	fn0808FD89(0x00, fp - 0x20);
	fn08090160(fp - 0x0128, fp - 0xA8);
	int32 eax_209 = 0x00;
	word32 * ecx_206 = fp - 0xAC;
	Eq_4 ebx_203 = dwArg04;
	ui32 edx_195 = 0x00;
	while (true)
	{
		byte dl_71 = (byte) edx_195;
		if (eax_209 >= 0x20)
			break;
		Eq_4 ebp_63 = *ecx_206;
		if (ebp_63 == 0x00 || ebx_203 >= dwArg08)
			break;
		if (dwLoc08 != null)
		{
			if (ebx_203 >= 0x00100000)
				runtime.panicindex(gs);
			dwLoc08[ebx_203] = ebp_63;
		}
		if (bLoc04 != 0x00)
		{
			Eq_4 eax_175;
			<anonymous> * ebp_123 = runtime.cgoSymbolizer;
			int8 bl_131 = (int8) (ebp_123 != null);
			if (ebp_123 != null)
			{
				runtime.printOneCgoTraceback(gs, ebp_63, dwArg08 - ebx_203, fp - 0x28);
				eax_175 = fp - 0x0125 + ebx_203;
			}
			else
			{
				runtime.printlock(gs);
				runtime.printstring(gs);
				word32 esi_318;
				runtime.printhex(esi, gs, ebp_63, 0x00, out esi_318);
				runtime.printstring(gs);
				runtime.printunlock(gs);
				eax_175 = ebx_203;
			}
			edx_195 = (word32) bl_131 | (word32) dl_71;
			ebx_203 = eax_175;
		}
		++ecx_206;
		++eax_209;
		ebx_203 = (word32) ebx_203 + 1;
	}
	if (dl_71 != 0x00)
		runtime.callCgoSymbolizer(gs);
}

// 08087AD0: void runtime.printcreatedby(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      runtime.traceback1
//      runtime.tracebackothers
void runtime.printcreatedby(struct Eq_2 * gs, Eq_4 dwArg04)
{
	byte bLoc2C = (byte) dwLoc2C;
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 ecx_19 = *((word32) dwArg04 + 0x00A8);
	runtime.findfunc(gs, ecx_19);
	if (dwLoc38 != 0x00)
	{
		runtime.showframe(gs, dwLoc38, dwArg04, 0x00);
		if (bLoc2C != 0x00)
		{
			Eq_4 ecx_48 = *((word32) dwArg04 + 84);
			Eq_4 eax_49 = *((word32) dwArg04 + 80);
			if (((int8) (ecx_48 != 0x00) | (int8) (eax_49 != 0x01)) != 0x00)
			{
				runtime.funcname(gs, dwLoc38, dwLoc34);
				runtime.printlock(gs);
				runtime.printstring(gs);
				runtime.printstring(gs);
				runtime.printstring(gs);
				runtime.printunlock(gs);
				ecx_19 <= *dwLoc38;
				runtime.funcline(gs);
				runtime.printlock(gs);
				runtime.printstring(gs);
				runtime.printstring(gs);
				runtime.printstring(gs);
				runtime.printint(ebx_24_8, gs, dwLoc28);
				runtime.printunlock(gs);
				Eq_4 eax_172 = *dwLoc38;
				if (ecx_19 > eax_172)
				{
					runtime.printlock(gs);
					runtime.printstring(gs);
					word32 esi_311;
					runtime.printhex(esi, gs, ecx_19 - eax_172, 0x00, out esi_311);
					runtime.printunlock(gs);
				}
				runtime.printlock(gs);
				runtime.printstring(gs);
				runtime.printunlock(gs);
			}
		}
	}
}

// 08087CF0: void runtime.traceback(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.tracealloc
//      runtime.dopanic_m
//      runtime.sighandler
//      runtime.newstack
//      runtime.tracebackothers
//      runtime.tracealloc.func1
//      runtime.tracefree.func1
void runtime.traceback(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.traceback1(gs, dwArg0C, dwArg10, 0x00);
}

// 08087D40: void runtime.tracebacktrap(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg0C, Stack Eq_4 dwArg10)
// Called from:
//      runtime.sighandler
void runtime.tracebacktrap(struct Eq_2 * gs, Eq_4 dwArg0C, Eq_4 dwArg10)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.traceback1(gs, dwArg0C, dwArg10, 0x02);
}

// 08087D90: void runtime.traceback1(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg0C, Stack Eq_4 dwArg10, Stack ui32 dwArg14)
// Called from:
//      runtime.traceback
//      runtime.tracebacktrap
void runtime.traceback1(struct Eq_2 * gs, Eq_4 dwArg0C, Eq_4 dwArg10, ui32 dwArg14)
{
	while (fp - 44 <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 eax_23;
	union Eq_4 * esp_17 = fp - 0xAC;
	if (g_b8157571 != 0x00)
	{
		eax_23 = dwArg10;
		Eq_4 ecx_25 = *((word32) dwArg10 + 24);
		if (ecx_25 != 0x00 && (*((word32) ecx_25 + 0x00A0) > 0x00 && *((word32) dwArg10 + 56) != 0x00))
		{
			Eq_4 edx_36 = *((word32) ecx_25 + 0x00A8);
			if (edx_36 != 0x00 && *edx_36 != 0x00)
			{
				runtime/internal/atomic.Store((word32) ecx_25 + 0x00A4, 0x01);
				fn08090160(*((word32) *((word32) dwArg10 + 24) + 0x00A8), fp - 0x80);
				**((word32) *((word32) dwArg10 + 24) + 0x00A8) = 0x00;
				runtime/internal/atomic.Store((word32) *((word32) dwArg10 + 24) + 0x00A4, 0x00);
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				Eq_4 stackArg0 = <invalid>;
				runtime.printCgoTraceback(gs, stackArg0, fp - 0x84);
				dwLocA8 = 0x01;
				esp_17 = fp - 0xB0;
				eax_23 = dwArg0C;
			}
		}
	}
	else
		eax_23 = dwArg10;
	ui32 ebx_103;
	Eq_4 edx_101;
	*esp_17 = (union Eq_4 *) eax_23;
	runtime.readgstatus(*esp_17);
	if ((dwLocA8 & ~0x1000) == 0x03)
	{
		edx_101 = *((word32) dwArg10 + 56);
		ebx_103 = dwArg14 & ~0x02;
	}
	else
	{
		edx_101 = dwArg08;
		ebx_103 = dwArg14;
	}
	runtime.gentraceback(gs, edx_101, dwArg0C, dwArg0C, dwArg10, 0x00, 100, 0x00, 0x00);
	if (dwLoc84 == 0x00 && (ebx_103 & 0x01) == 0x00)
		runtime.gentraceback(gs, edx_101, dwArg0C, dwArg0C, dwArg10, 0x00, 100, 0x00, 0x00);
	if (dwLoc84 == 100)
	{
		runtime.printlock(gs);
		runtime.printstring(gs);
		runtime.printunlock(gs);
	}
	runtime.printcreatedby(gs, dwArg10);
}

// 08087FF0: void runtime.callers(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.Caller
//      runtime.Callers
//      runtime.mProf_Malloc
//      runtime.saveblockevent
//      runtime.mcommoninit
//      runtime.traceStackID
void runtime.callers(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.getcallerpc();
	fn0808FD87(0x00, fp - 0x24);
	word32 ebp_95;
	word32 edi_96;
	runtime.systemstack(gs, fp - 0x28, out ebp_95, out edi_96);
}

// 080880B0: void runtime.gcallers(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg10)
// Called from:
//      runtime.saveblockevent
//      runtime.traceStackID
void runtime.gcallers(struct Eq_2 * gs, Eq_4 dwArg10)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (dwArg10 <= 0x00)
		runtime.panicindex(gs);
	else
		runtime.gentraceback(gs, ~0x00, 0x00, dwArg04, dwArg08, dwArg0C, dwArg10, 0x00, 0x00);
}

// 08088140: void runtime.showframe(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg0C, Stack int8 bArg10)
// Called from:
//      runtime.gentraceback
//      runtime.printcreatedby
void runtime.showframe(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg0C, int8 bArg10)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 eax_19 = *((word32) gs->ptr0000->tFFFFFFFC + 24);
	if (*((word32) eax_19 + 0x006C) > 0x00 && (dwArg0C != 0x00 && (*((word32) eax_19 + 84) == dwArg0C || *((word32) eax_19 + 88) == dwArg0C)))
		return;
	runtime.gotraceback(dwLoc24);
	runtime.funcname(gs, dwArg04, dwArg08);
	if (dwLoc14 == 0x0F)
	{
		word32 edi_395;
		word32 esi_394;
		word32 ebx_393;
		runtime.eqstring(0x080E23CE, dwLoc18, dwLoc14, 0x080E23CE, out ebx_393, out esi_394, out edi_395);
		if (bLoc10 != 0x00 && bArg10 == 0x00)
			return;
	}
	if (dwLoc20 <= 0x01)
	{
		Eq_4 edx_115;
		if (dwArg04 == 0x00)
			edx_115.u0 = 0x00;
		else
		{
			runtime.contains(gs);
			edx_115 = (word32) bLoc10;
		}
		if ((byte) edx_115 != 0x00)
		{
			uip32 edx_154;
			if (dwLoc14 < 0x08)
				edx_154 = 0x00;
			else
			{
				word32 edi_398;
				word32 esi_397;
				word32 ebx_396;
				runtime.eqstring(edx_115, dwLoc18, 0x08, 0x080E14E5, out ebx_396, out esi_397, out edi_398);
				edx_154 = (word32) bLoc10;
			}
			if ((byte) edx_154 != 0x00 && dwLoc14 > 0x08)
			{
				uip32 ecx_388;
				if (*dwLoc18 == 0x746E7572)
				{
					Eq_4 ecx_182 = *((word32) dwLoc18 + 4);
					ecx_388 = SEQ(SLICE(ecx_182, word24, 8), (int8) (ecx_182 == 778399081));
				}
				else
					ecx_388 = 0x00;
				if ((byte) ecx_388 != 0x00)
					*((word32) dwLoc18 + 8) < 0x41;
			}
		}
	}
}

// 08088300: Register Eq_4 runtime.goroutineheader(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      runtime.tracealloc
//      runtime.tracefree
//      runtime.dopanic_m
//      runtime.sighandler
//      runtime.tracebackothers
Eq_4 runtime.goroutineheader(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 ebx_31;
	runtime.readgstatus(dwArg04);
	if ((dwLoc30 & ~0x1000) < 0x09)
		ebx_31 = g_a81442C0[dwLoc30 & ~0x1000];
	else
		ebx_31.u0 = 135138883;
	Eq_4 esi_46;
	bool v32_304 = (dwLoc30 & ~0x1000) != 0x04;
	if ((dwLoc30 & ~0x1000) == 0x04)
	{
		esi_46 = *((word32) dwArg04 + 96);
		if (*((word32) dwArg04 + 100) != 0x00)
			v32_304 = (dwLoc30 & ~0x1000) != 0x04;
		else
		{
			v32_304 = (dwLoc30 & ~0x1000) != 0x04;
			esi_46 = ebx_31;
		}
	}
	else
		esi_46 = ebx_31;
	int32 edx_125;
	Eq_4 eax_126;
	if (!v32_304 || (dwLoc30 & ~0x1000) == 0x03)
	{
		Eq_4 eax_78 = *((word32) dwArg04 + 92);
		Eq_4 edx_79 = *((word32) dwArg04 + 88);
		if (((int8) (eax_78 != 0x00) | (int8) (edx_79 != 0x00)) == 0x00)
		{
			eax_126.u0 = 0x00;
			edx_125 = 0x00;
		}
		else
		{
			runtime.nanotime();
			runtime.int64div(edi, gs, dwArg04 - *((word32) dwArg04 + 88), 4165425152);
			edx_125 = dwLoc20;
			eax_126 = dwLoc24;
		}
	}
	else
	{
		eax_126.u0 = 0x00;
		edx_125 = 0x00;
	}
	Eq_4 ebx_140 = *((word32) dwArg04 + 80);
	runtime.printlock(gs);
	runtime.printstring(gs);
	runtime.printint(ebx_24_8, gs, ebx_140);
	runtime.printstring(gs);
	runtime.printstring(gs);
	runtime.printunlock(gs);
	if ((dwLoc30 & 0x1000) != 0x00)
	{
		runtime.printlock(gs);
		runtime.printstring(gs);
		runtime.printunlock(gs);
	}
	if (((int8) (edx_125 == 0x00) & (int8) (eax_126 >= 0x01) | (int8) (edx_125 > 0x00)) != 0x00)
	{
		runtime.printlock(gs);
		runtime.printstring(gs);
		runtime.printint(ebx_24_8, gs, eax_126);
		runtime.printstring(gs);
		runtime.printunlock(gs);
	}
	if (*((word32) dwArg04 + 0x0088) != 0x00)
	{
		runtime.printlock(gs);
		runtime.printstring(gs);
		runtime.printunlock(gs);
	}
	runtime.printlock(gs);
	runtime.printstring(gs);
	runtime.printunlock(gs);
	return esi_46;
}

// 08088590: Register Eq_4 runtime.tracebackothers(Register Eq_4 esi, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      runtime.tracegc
//      runtime.dopanic_m
//      runtime.sighandler
Eq_4 runtime.tracebackothers(Eq_4 esi, struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.gotraceback(dwLoc30);
	Eq_4 esp_21 = <invalid>;
	Eq_4 eax_27 = gs->ptr0000->tFFFFFFFC;
	*((word32) esp_21 + 36) = eax_27;
	Eq_4 ecx_29 = *((word32) eax_27 + 24);
	*((word32) esp_21 + 16) = *esp_21;
	Eq_4 ecx_32 = *((word32) ecx_29 + 84);
	if (ecx_32 != 0x00 && *((word32) esp_21 + 48) != ecx_32)
	{
		*((word32) esp_21 + 28) = ecx_32;
		runtime.printlock(gs);
		esp_21->u0 = 0x080E0D9C;
		((word32) esp_21 + 4)->u0 = 0x01;
		runtime.printstring(gs);
		runtime.printunlock(gs);
		*esp_21 = *((word32) esp_21 + 28);
		esi = runtime.goroutineheader(gs, *esp_21);
		esp_21->u0 = ~0x00;
		((word32) esp_21 + 4)->u0 = ~0x00;
		((word32) esp_21 + 8)->u0 = 0x00;
		*((word32) esp_21 + 0x0C) = *((word32) esp_21 + 28);
		runtime.traceback(gs);
	}
	esp_21->u0 = 0x08157590;
	word32 edi_379;
	Eq_4 esi_102;
	runtime.lock(esi, gs, *esp_21, out esi_102, out edi_379);
	Eq_4 eax_107 = g_t814510C;
	*((word32) esp_21 + 24) = eax_107;
	Eq_4 ecx_109 = g_t8145108;
	Eq_4 edx_110 = 0x00;
	while (edx_110 < eax_107)
	{
		Eq_4 ebx_134 = *ecx_109;
		if (dwArg04 != ebx_134)
		{
			esi_102 = dwLoc08;
			if (ebx_134 == *((word32) (*((word32) dwLoc08 + 24)) + 84))
				goto l08088602;
			runtime.readgstatus(ebx_134);
			Eq_4 esp_148 = <invalid>;
			if (*((word32) esp_148 + 4) == 0x06)
			{
l08088643:
				eax_107 = *((word32) esp_148 + 24);
				ecx_109 = *((word32) esp_148 + 40);
				edx_110 = *((word32) esp_148 + 20);
				goto l08088602;
			}
			int8 cl_181;
			Eq_4 ecx_157 = *((word32) *((word32) esp_148 + 32) + 0x00AC);
			if (runtime.runfinqPC == ecx_157 && g_b8157569 == 0x00)
				cl_181 = 0x01;
			else if (runtime.bgsweepPC == ecx_157)
				cl_181 = 0x01;
			else if (runtime.forcegchelperPC == ecx_157)
				cl_181 = 0x01;
			else if (runtime.timerprocPC == ecx_157)
				cl_181 = 0x01;
			else
				cl_181 = (int8) (runtime.gcBgMarkWorkerPC == ecx_157);
			if (cl_181 != 0x00 && *((word32) esp_148 + 16) < 0x02)
				goto l08088643;
			runtime.printlock(gs);
			esp_148->u0 = 0x080E0D9C;
			((word32) esp_148 + 4)->u0 = 0x01;
			runtime.printstring(gs);
			runtime.printunlock(gs);
			*esp_148 = *((word32) esp_148 + 32);
			esi_102 = runtime.goroutineheader(gs, *esp_148);
			Eq_4 eax_240 = *((word32) esp_148 + 32);
			if (*((word32) eax_240 + 24) != *((word32) (*((word32) esp_148 + 36)) + 24))
			{
				*esp_148 = eax_240;
				runtime.readgstatus(*esp_148);
				esp_148.u0 = <invalid>;
				if ((*((byte) esp_148.u0 + 4) & ~0x1000) == 0x02)
				{
					runtime.printlock(gs);
					esp_148.u0->u0 = 135165165;
					((byte) esp_148.u0 + 4)->u0 = 0x36;
					runtime.printstring(gs);
					runtime.printunlock(gs);
					*esp_148.u0 = *((byte) esp_148.u0 + 32);
					runtime.printcreatedby(gs, *esp_148.u0);
l080886F6:
					eax_107 = *((byte) esp_148.u0 + 24);
					ecx_109 = *((byte) esp_148.u0 + 40);
					edx_110 = *((byte) esp_148.u0 + 20);
					goto l08088602;
				}
				eax_240 = *((byte) esp_148.u0 + 32);
			}
			esp_148.u0->u0 = ~0x00;
			((byte) esp_148.u0 + 4)->u0 = ~0x00;
			((byte) esp_148.u0 + 8)->u0 = 0x00;
			*((byte) esp_148.u0 + 0x0C) = eax_240;
			runtime.traceback(gs);
			goto l080886F6;
		}
l08088602:
		ecx_109 = (word32) ecx_109 + 4;
		edx_110 = (word32) edx_110 + 1;
	}
	word32 edx_380;
	word32 ebx_381;
	runtime.unlock(gs, 0x08157590, out edx_380, out ebx_381);
	return esi_102;
}

// 08088820: void runtime.printCgoTraceback(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg00, Stack (ptr32 word32) dwArg04)
// Called from:
//      runtime.traceback1
void runtime.printCgoTraceback(struct Eq_2 * gs, Eq_4 dwArg00, word32 * dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (runtime.cgoSymbolizer == null)
	{
		word32 * eax_21 = dwArg04;
		int32 ecx_24;
		for (ecx_24 = 0x00; ecx_24 < 0x20; ++ecx_24)
		{
			Eq_4 edx_32 = *eax_21;
			if (edx_32 == 0x00)
				return;
			runtime.printlock(gs);
			runtime.printstring(gs);
			word32 esi_191;
			runtime.printhex(esi, gs, edx_32, 0x00, out esi_191);
			runtime.printstring(gs);
			runtime.printunlock(gs);
			++eax_21;
		}
	}
	else
	{
		fn0808FD89(0x00, fp - 0x1C);
		Eq_4 ecx_113 = dwArg00;
		int32 eax_115;
		for (eax_115 = 0x00; eax_115 < 0x20; ++eax_115)
		{
			Eq_4 edx_96 = *ecx_113;
			if (edx_96 == 0x00)
				break;
			runtime.printOneCgoTraceback(gs, edx_96, 0x7FFFFFFF, fp - 0x20);
			ecx_113 = (word32) ecx_113 + 4;
		}
		runtime.callCgoSymbolizer(gs);
	}
}

// 08088930: void runtime.printOneCgoTraceback(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack int32 dwArg08, Stack (ptr32 Eq_75485) dwArg0C)
// Called from:
//      runtime.tracebackCgoContext
//      runtime.printCgoTraceback
void runtime.printOneCgoTraceback(struct Eq_2 * gs, Eq_4 dwArg04, int32 dwArg08, struct Eq_75485 * dwArg0C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	dwArg0C->t0000 = dwArg04;
	int32 edx_20;
	for (edx_20 = 0x00; edx_20 <= dwArg08; ++edx_20)
	{
		runtime.callCgoSymbolizer(gs);
		if (dwArg0C->dw000C != 0x00)
		{
			runtime.gostringnocopy();
			runtime.printlock(gs);
			runtime.printstring(gs);
			runtime.printnl(gs);
			runtime.printunlock(gs);
		}
		else
		{
			runtime.printlock(gs);
			runtime.printstring(gs);
			runtime.printnl(gs);
			runtime.printunlock(gs);
		}
		runtime.printlock(gs);
		runtime.printstring(gs);
		runtime.printunlock(gs);
		if (dwArg0C->dw0004 != 0x00)
		{
			runtime.gostringnocopy();
			Eq_4 ebx_123 = dwArg0C->t0008;
			runtime.printlock(gs);
			runtime.printstring(gs);
			runtime.printstring(gs);
			runtime.printint(ebx_24_8, gs, ebx_123);
			runtime.printstring(gs);
			runtime.printunlock(gs);
		}
		runtime.printlock(gs);
		runtime.printstring(gs);
		word32 esi_279;
		runtime.printhex(esi, gs, dwArg04, 0x00, out esi_279);
		runtime.printstring(gs);
		runtime.printunlock(gs);
		if (dwArg0C->dw0014 == 0x00)
			return;
	}
}

// 08088B20: void runtime.callCgoSymbolizer(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.expandCgoFrames
//      runtime.tracebackCgoContext
//      runtime.printCgoTraceback
//      runtime.printOneCgoTraceback
void runtime.callCgoSymbolizer(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (runtime.panicking <= 0x00)
	{
		Eq_4 eax_23 = gs->ptr0000->tFFFFFFFC;
		if (*((word32) *((word32) eax_23 + 24) + 84) == eax_23)
			goto l08088B45;
	}
l08088B45:
	word32 edi_63;
	runtime.asmcgocall(gs, runtime.cgoSymbolizer, dwArg04, out edi_63);
}

// 08088B90: void runtime.cgoContextPCs(Register (ptr32 Eq_2) gs, Stack up32 dwArg0C)
// Called from:
//      runtime.tracebackCgoContext
void runtime.cgoContextPCs(struct Eq_2 * gs, up32 dwArg0C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (runtime.cgoTraceback == null)
		return;
	if (runtime.panicking <= 0x00)
	{
		Eq_4 eax_29 = gs->ptr0000->tFFFFFFFC;
		if (*((word32) *((word32) eax_29 + 24) + 84) == eax_29)
			goto l08088BC3;
	}
l08088BC3:
	if (dwArg0C <= 0x00)
		runtime.panicindex(gs);
	else
	{
		word32 edi_116;
		runtime.asmcgocall(gs, runtime.cgoTraceback, fp - 0x10, out edi_116);
	}
}

// 08088C40: void runtime.(*_type).string(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      runtime.interhash
//      runtime.nilinterhash
//      runtime.efaceeq
//      runtime.ifaceeq
//      runtime.typestring
//      runtime.getitab
//      runtime.additab
//      runtime.panicdottypeE
//      runtime.assertE2I
//      runtime.typeBitsBulkBarrier
//      runtime.heapBitsSetType
//      runtime.SetFinalizer
//      runtime.tracealloc
//      runtime.typesEqual
void runtime.(*_type).string(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.(*_type).nameOff(gs);
	runtime.name.name(gs, dwLoc04);
	if ((*((word32) dwArg04 + 0x0C) & 0x02) == 0x00)
		return;
	if (dwLoc04 >= 0x01)
		return;
	runtime.panicslice(gs);
}

// 08088CD0: void runtime.(*_type).uncommon(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      runtime.additab
//      runtime.SetFinalizer
//      runtime.typesEqual
void runtime.(*_type).uncommon(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if ((*((word32) dwArg04 + 0x0C) & 0x01) == 0x00)
		return;
	cu8 cl_24 = *((word32) dwArg04 + 0x0F) & 0x1F;
	if (cl_24 > 0x14)
	{
		if (cl_24 > 22)
		{
			if (cl_24 == 0x17)
				return;
			if (cl_24 != 0x19)
				;
		}
		else if (cl_24 != 0x15)
			;
	}
	else if (cl_24 > 0x12)
	{
		if (cl_24 != 0x13)
			;
	}
	else
	{
		if (cl_24 == 0x11)
			return;
		if (cl_24 == 0x12)
			;
	}
}

// 08088D90: void runtime.reflectOffsLock(Register (ptr32 Eq_2) gs)
// Called from:
//      reflect.addReflectOff
//      runtime.resolveNameOff
//      runtime.resolveTypeOff
//      runtime.(*_type).textOff
void runtime.reflectOffsLock(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	word32 esi_32;
	word32 edi_33;
	runtime.lock(esi, gs, 135549344, out esi_32, out edi_33);
}

// 08088DC0: void runtime.reflectOffsUnlock(Register (ptr32 Eq_2) gs)
// Called from:
//      reflect.addReflectOff
//      runtime.resolveNameOff
//      runtime.resolveTypeOff
//      runtime.(*_type).textOff
void runtime.reflectOffsUnlock(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	word32 edx_31;
	word32 ebx_32;
	runtime.unlock(gs, 135549344, out edx_31, out ebx_32);
}

// 08088DF0: Register Eq_4 runtime.resolveNameOff(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
// Called from:
//      reflect.resolveNameOff
//      runtime.(*_type).nameOff
//      runtime.name.pkgPath
//      runtime.typesEqual
Eq_4 runtime.resolveNameOff(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (dwArg08 == 0x00)
		return ebx;
	struct Eq_76788 * edx_214;
	for (edx_214 = &g_t8139420; edx_214 != null; edx_214 = edx_214->ptr00D8)
	{
		ebx = edx_214->t0064;
		if (dwArg04 >= ebx)
		{
			Eq_4 ebp_209 = edx_214->t0068;
			if (dwArg04 < ebp_209)
			{
				if (ebx + dwArg08 >u ebp_209)
				{
					runtime.printlock(gs);
					runtime.printstring(gs);
					runtime.printsp(gs);
					word32 esi_421;
					runtime.printhex(esi, gs, dwArg08, dwArg08 >> 0x1F, out esi_421);
					runtime.printsp(gs);
					runtime.printstring(gs);
					runtime.printsp(gs);
					word32 esi_422;
					runtime.printhex(esi, gs, ebx, 0x00, out esi_422);
					runtime.printsp(gs);
					runtime.printstring(gs);
					runtime.printsp(gs);
					word32 esi_423;
					runtime.printhex(esi, gs, ebp_209, 0x00, out esi_423);
					runtime.printnl(gs);
					runtime.printunlock(gs);
					runtime.throw(gs);
				}
				else
					return ebx;
			}
		}
	}
	runtime.reflectOffsLock(gs);
	runtime.mapaccess2_fast32(gs, &g_t80CFA40, g_t81451A8, dwArg08);
	runtime.reflectOffsUnlock(gs);
	if (bLoc1C != 0x00)
		return ebx;
	runtime.printlock(gs);
	runtime.printstring(gs);
	runtime.printsp(gs);
	word32 esi_424;
	runtime.printhex(esi, gs, dwArg08, dwArg08 >> 0x1F, out esi_424);
	runtime.printsp(gs);
	runtime.printstring(gs);
	runtime.printsp(gs);
	word32 esi_425;
	runtime.printhex(esi, gs, dwArg04, 0x00, out esi_425);
	runtime.printsp(gs);
	runtime.printstring(gs);
	runtime.printnl(gs);
	runtime.printunlock(gs);
	struct Eq_76890 * eax_132;
	for (eax_132 = &g_t8139420; eax_132 != null; eax_132 = eax_132->ptr00D8)
	{
		Eq_4 ecx_139 = eax_132->t0064;
		Eq_4 edx_141 = eax_132->t0068;
		runtime.printlock(gs);
		runtime.printstring(gs);
		runtime.printsp(gs);
		word32 esi_426;
		runtime.printhex(esi, gs, ecx_139, 0x00, out esi_426);
		runtime.printsp(gs);
		runtime.printstring(gs);
		runtime.printsp(gs);
		word32 esi_427;
		runtime.printhex(esi, gs, edx_141, 0x00, out esi_427);
		runtime.printnl(gs);
		runtime.printunlock(gs);
	}
	runtime.throw(gs);
}

// subject_text_0004.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 080890D0: void runtime.(*_type).nameOff(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.getitab
//      runtime.additab
//      runtime.(*_type).string
//      runtime.typesEqual
void runtime.(*_type).nameOff(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.resolveNameOff(gs, dwArg04, dwArg08);
}

// 08089110: void runtime.resolveTypeOff(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
// Called from:
//      runtime.(*_type).typeOff
//      runtime.typesEqual
void runtime.resolveTypeOff(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (dwArg08 == 0x00)
		return;
	struct Eq_76966 * edx_25;
	for (edx_25 = &g_t8139420; edx_25 != null; edx_25 = edx_25->ptr00D8)
	{
		if (dwArg04 >= edx_25->t0064 && dwArg04 < edx_25->t0068)
			goto l0808915D;
	}
	edx_25 = null;
l0808915D:
	if (edx_25 == null)
	{
		runtime.reflectOffsLock(gs);
		word32 edi_451;
		word32 esi_450;
		runtime.mapaccess1_fast32(gs, 0x080CFA40, g_t81451A8, dwArg08, out esi_450, out edi_451);
		word32 eax_71 = *dwLoc1C;
		runtime.reflectOffsUnlock(gs);
		if (eax_71 != 0x00)
			return;
		runtime.printlock(gs);
		runtime.printstring(gs);
		runtime.printsp(gs);
		word32 esi_458;
		runtime.printhex(esi, gs, dwArg08, dwArg08 >> 0x1F, out esi_458);
		runtime.printsp(gs);
		runtime.printstring(gs);
		runtime.printsp(gs);
		word32 esi_459;
		runtime.printhex(esi, gs, dwArg04, 0x00, out esi_459);
		runtime.printsp(gs);
		runtime.printstring(gs);
		runtime.printnl(gs);
		runtime.printunlock(gs);
		struct Eq_77102 * eax_149;
		for (eax_149 = &g_t8139420; eax_149 != null; eax_149 = eax_149->ptr00D8)
		{
			Eq_4 ecx_156 = eax_149->t0064;
			Eq_4 edx_158 = eax_149->t0068;
			runtime.printlock(gs);
			runtime.printstring(gs);
			runtime.printsp(gs);
			word32 esi_460;
			runtime.printhex(esi, gs, ecx_156, 0x00, out esi_460);
			runtime.printsp(gs);
			runtime.printstring(gs);
			runtime.printsp(gs);
			word32 esi_461;
			runtime.printhex(esi, gs, edx_158, 0x00, out esi_461);
			runtime.printnl(gs);
			runtime.printunlock(gs);
		}
		runtime.throw(gs);
	}
	else
	{
		word32 esi_452;
		word32 edi_453;
		runtime.mapaccess1_fast32(gs, 0x080CFB00, edx_25->t00D4, dwArg08, out esi_452, out edi_453);
		if (*dwLoc1C != 0x00)
			return;
		Eq_4 ecx_244 = edx_25->t0064;
		Eq_4 eax_247 = edx_25->t0068;
		if (ecx_244 + dwArg08 <=u eax_247)
			return;
		runtime.printlock(gs);
		runtime.printstring(gs);
		runtime.printsp(gs);
		word32 esi_455;
		runtime.printhex(esi, gs, dwArg08, dwArg08 >> 0x1F, out esi_455);
		runtime.printsp(gs);
		runtime.printstring(gs);
		runtime.printsp(gs);
		word32 esi_456;
		runtime.printhex(esi, gs, ecx_244, 0x00, out esi_456);
		runtime.printsp(gs);
		runtime.printstring(gs);
		runtime.printsp(gs);
		word32 esi_457;
		runtime.printhex(esi, gs, eax_247, 0x00, out esi_457);
		runtime.printnl(gs);
		runtime.printunlock(gs);
		runtime.throw(gs);
	}
}

// 08089430: void runtime.(*_type).typeOff(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.additab
//      reflect.resolveTypeOff
void runtime.(*_type).typeOff(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.resolveTypeOff(gs, dwArg04, dwArg08);
}

// 08089470: void runtime.(*_type).textOff(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
// Called from:
//      runtime.additab
//      reflect.resolveTextOff
void runtime.(*_type).textOff(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	struct Eq_77174 * ecx_19;
	for (ecx_19 = &g_t8139420; ecx_19 != null; ecx_19 = ecx_19->ptr00D8)
	{
		if (dwArg04 >= ecx_19->t0064 && dwArg04 < ecx_19->t0068)
			goto l080894B1;
	}
	ecx_19 = null;
l080894B1:
	if (ecx_19 == null)
	{
		runtime.reflectOffsLock(gs);
		word32 edi_505;
		word32 esi_504;
		runtime.mapaccess1_fast32(gs, 0x080CFA40, g_t81451A8, dwArg08, out esi_504, out edi_505);
		word32 eax_65 = *dwLoc1C;
		runtime.reflectOffsUnlock(gs);
		if (eax_65 != 0x00)
			return;
		runtime.printlock(gs);
		runtime.printstring(gs);
		runtime.printsp(gs);
		word32 esi_509;
		runtime.printhex(esi, gs, dwArg08, dwArg08 >> 0x1F, out esi_509);
		runtime.printsp(gs);
		runtime.printstring(gs);
		runtime.printsp(gs);
		word32 esi_510;
		runtime.printhex(esi, gs, dwArg04, 0x00, out esi_510);
		runtime.printsp(gs);
		runtime.printstring(gs);
		runtime.printnl(gs);
		runtime.printunlock(gs);
		struct Eq_77339 * eax_143;
		for (eax_143 = &g_t8139420; eax_143 != null; eax_143 = eax_143->ptr00D8)
		{
			Eq_4 ecx_150 = eax_143->t0064;
			Eq_4 edx_152 = eax_143->t0068;
			runtime.printlock(gs);
			runtime.printstring(gs);
			runtime.printsp(gs);
			word32 esi_511;
			runtime.printhex(esi, gs, ecx_150, 0x00, out esi_511);
			runtime.printsp(gs);
			runtime.printstring(gs);
			runtime.printsp(gs);
			word32 esi_512;
			runtime.printhex(esi, gs, edx_152, 0x00, out esi_512);
			runtime.printnl(gs);
			runtime.printunlock(gs);
		}
		runtime.throw(gs);
	}
	else
	{
		Eq_4 eax_223;
		struct Eq_77213 * eax_217 = ecx_19->ptr006C;
		Eq_77217 edx_218 = ecx_19->t0070;
		if (edx_218 > 0x01)
		{
			Eq_77217 ebp_225 = 0x00;
			while (ebp_225 < edx_218)
			{
				if (ebp_225 >= edx_218)
					runtime.panicindex(gs);
				esi = ebp_225 * 0x03;
				Eq_4 edi_245 = eax_217[esi * 0x04 / 8];
				up32 ecx_246 = eax_217->a0004[esi];
				if (dwArg08 >= edi_245 && dwArg08 <= (word32) edi_245 + ecx_246)
				{
					eax_223 = (word32) dwArg08 + (eax_217->a0008)[esi] - edi_245;
					goto l080894F8;
				}
				ebp_225 = (word32) ebp_225 + 1;
			}
			eax_223.u0 = 0x00;
		}
		else
			eax_223 = dwArg08 + Mem216[ecx_19 + 0x30:word32];
l080894F8:
		Eq_4 edx_266 = ecx_19->t0034;
		if (eax_223 <= edx_266)
			return;
		Eq_4 eax_271 = ecx_19->t0030;
		runtime.printlock(gs);
		runtime.printstring(gs);
		runtime.printsp(gs);
		word32 esi_506;
		runtime.printhex(esi, gs, dwArg08, dwArg08 >> 0x1F, out esi_506);
		runtime.printsp(gs);
		runtime.printstring(gs);
		runtime.printsp(gs);
		word32 esi_507;
		runtime.printhex(esi, gs, eax_271, 0x00, out esi_507);
		runtime.printsp(gs);
		runtime.printstring(gs);
		runtime.printsp(gs);
		word32 esi_508;
		runtime.printhex(esi, gs, edx_266, 0x00, out esi_508);
		runtime.printnl(gs);
		runtime.printunlock(gs);
		runtime.throw(gs);
	}
}

// 080897A0: void runtime.name.tagLen(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      runtime.name.tag
//      runtime.name.pkgPath
void runtime.name.tagLen(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if ((*dwArg04 & 0x02) != 0x00)
		;
}

// 08089810: void runtime.name.name(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      runtime.getitab
//      runtime.additab
//      runtime.(*_type).string
//      runtime.name.pkgPath
//      runtime.typesEqual
void runtime.name.name(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (dwArg04 == 0x00)
		return;
	if ((word32) ((word16) (word32) *((word32) dwArg04 + 1) << 0x08 | (word16) ((word32) (*((word32) dwArg04 + 2)))) != 0x00)
		;
}

// 08089890: void runtime.name.tag(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      runtime.typesEqual
void runtime.name.tag(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.name.tagLen(gs, dwArg04);
	if (dwLoc04 != 0x00)
		;
}

// 08089910: Register word32 runtime.name.pkgPath(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Register out ptr32 ediOut)
// Called from:
//      runtime.additab
//      runtime.typesEqual
word32 runtime.name.pkgPath(struct Eq_2 * gs, Eq_4 dwArg04, ptr32 & ediOut)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (dwArg04 == 0x00 || (*dwArg04 & 0x04) == 0x00)
	{
		ediOut = edi;
		return esi;
	}
	else
	{
		int32 eax_51;
		cui16 dx_31 = (word16) (word32) *((word32) dwArg04 + 1);
		cui16 cx_34 = (word16) (word32) *((word32) dwArg04 + 2);
		runtime.name.tagLen(gs, dwArg04);
		word32 eax_46 = (word32) (dx_31 << 0x08 | cx_34);
		if (dwLoc10 > 0x00)
			eax_51 = dwLoc10 + 0x05 + eax_46;
		else
			eax_51 = eax_46 + 0x03;
		ptr32 edi_67;
		word32 esi_68;
		word128 xmm2_217;
		word128 xmm0_215;
		word128 xmm1_216;
		word32 ebp_214;
		runtime.memmove(fp - 0x04, (word32) dwArg04 + eax_51, 0x04, out ebp_214, out esi_68, out edi_67, out xmm0_215, out xmm1_216, out xmm2_217);
		runtime.resolveNameOff(gs, dwArg04, 0x00);
		runtime.name.name(gs, 0x04);
		ediOut = edi_67;
		return esi_68;
	}
}

// 08089A00: Register Eq_4 runtime.typelinksinit(Register word32 ebx, Register Eq_4 esi, Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.schedinit
Eq_4 runtime.typelinksinit(word32 ebx, Eq_4 esi, struct Eq_2 * gs)
{
	word24 ebx_24_8 = SLICE(ebx, word24, 8);
	while (fp - 0xA8 <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (g_dw81394F8 == 0x00)
		return esi;
	fn0808FD89(0x00, fp - 0xA8);
	word32 edi_1151;
	Eq_4 esi_106 = runtime.makemap(ebx_24_8, esi, fn0808FD6D(0x00, fp - 0x90), gs, 0x080CFC00, dwLocF0, dwLocF0 >> 0x1F, fp - 0xB0, fp - 0x94, out edi_1151);
	runtime.activeModules();
	Eq_4 dwLoc0124_688 = fp - 0xB0;
	if (dwLocF0 <= 0x00)
		runtime.panicindex(gs);
	else
	{
		struct Eq_77582 * eax_100 = g_ptr80CFC00;
		word32 * ecx_102 = (0x01 - (dwLocF0 >> 0x1F) >> 0x1F & 0x04) + 0x080CFC00;
		Eq_77595 ebx_454 = 0x00;
		while (ebx_454 < dwLocF0 - 0x01)
		{
			struct Eq_77582 * ebp_104 = *ecx_102;
			esi_106 = eax_100->t0078;
			Eq_4 edi_107 = eax_100->t007C;
			Eq_4 dwLocFC_700 = 0x00;
			while (true)
			{
				word24 ebx_24_8_137 = SLICE(ebx_454, word24, 8);
				if (dwLocFC_700 >= edi_107)
					break;
				Eq_4 ecx_484;
				Eq_4 ebx_462 = *esi_106;
				Eq_4 ecx_464 = eax_100->t00D4;
				if (ecx_464 == 0x00)
					ecx_484 = (word32) ebx_462 + eax_100->dw0064;
				else
				{
					word32 esi_1152;
					word32 edi_1153;
					runtime.mapaccess1_fast32(gs, 0x080CFB00, ecx_464, ebx_462, out esi_1152, out edi_1153);
					ecx_484 = *dwLoc0124_688;
				}
				word32 edi_1155;
				word32 esi_1154;
				runtime.mapaccess1_fast32(gs, 0x080CFC00, dwLoc011C, *((word32) ecx_484 + 8), out esi_1154, out edi_1155);
				Eq_4 edx_511 = *dwLoc0124_688;
				Eq_4 ecx_510 = *((word32) dwLoc0124_688 + 8);
				Eq_4 eax_512 = *((word32) dwLoc0124_688 + 4);
				Eq_4 ebp_514 = edx_511;
				Eq_4 esi_515 = 0x00;
				edx_644 = edx_511;
				while (true)
				{
					Eq_4 edx_644;
					if (esi_515 >= eax_512)
						break;
					if (*edx_644 == ecx_484)
						goto l08089AD5;
					edx_644 = (word32) edx_644 + 4;
					esi_515 = (word32) esi_515 + 1;
				}
				Eq_4 edx_522 = (word32) eax_512 + 1;
				if ((word32) eax_512 + 1 > ecx_510)
				{
					word128 xmm1_1158;
					word32 esi_1156;
					word128 xmm0_1157;
					runtime.growslice(gs, 0x080D8DA0, edx_511, eax_512, ecx_510, (word32) eax_512 + 1, out esi_1156, out xmm0_1157, out xmm1_1158);
					dwLoc0124_688 = ecx_510;
					ebp_514 = dwLoc011C;
					ecx_510 = dwLoc0114;
					edx_522 = (word32) dwLoc0118 + 1;
				}
				Eq_4 esi_570 = (word32) ebp_514 + eax_512 * 0x04;
				if (g_t81576F0 == 0x00)
					*((word32) ebp_514 + eax_512 * 0x04) = ecx_484;
				else
					runtime.writebarrierptr(esi_570, ecx_484);
				runtime.mapassign_fast32(gs, 0x080CFC00, dwLoc011C, *((word32) ecx_484 + 8));
				*((word32) dwLoc0124_688 + 4) = edx_522;
				*((word32) dwLoc0124_688 + 8) = ecx_510;
				if (g_t81576F0 == 0x00)
					*dwLoc0124_688 = ebp_514;
				else
					runtime.writebarrierptr(dwLoc0124_688, ebp_514);
l08089AD5:
				esi_106 = (word32) esi_106 + 4;
				dwLocFC_700 = (word32) dwLocFC_700 + 1;
			}
			if (ebp_104->t00D4 == 0x00)
			{
				Eq_4 eax_128 = ebp_104->t007C;
				word32 edi_1159;
				esi_106 = runtime.makemap(ebx_24_8_137, esi_106, edi_107, gs, 0x080CFB00, eax_128, eax_128 >> 0x1F, 0x00, 0x00, out edi_1159);
				dwLoc0124_688.u0 = 0x00;
				Eq_4 ecx_157 = g_t8145160;
				Eq_4 edx_158 = g_t814515C;
				Eq_4 ebx_159 = g_t8145158;
				if ((word32) edx_158 + 1 > ecx_157)
				{
					word128 xmm0_1160;
					word128 xmm1_1161;
					runtime.growslice(gs, 0x080CFB00, ebx_159, edx_158, ecx_157, (word32) edx_158 + 1, out esi_106, out xmm0_1160, out xmm1_1161);
					g_t8145160 = dwLoc0114;
					dwLoc0124_688 = ecx_157;
					if (g_t81576F0 == 0x00)
						g_t8145158 = dwLoc011C;
					else
						runtime.writebarrierptr(0x08145158, dwLoc011C);
					edx_158 = dwLoc0118;
					ebx_159 = dwLoc011C;
				}
				g_t814515C = (word32) edx_158 + 1;
				Eq_4 ecx_224 = (word32) ebx_159 + edx_158 * 0x04;
				if (g_t81576F0 == 0x00)
				{
					*((word32) ebx_159 + edx_158 * 0x04) = dwLoc011C;
					ebp_104->t00D4 = dwLoc011C;
				}
				else
				{
					runtime.writebarrierptr(ecx_224, dwLoc011C);
					runtime.writebarrierptr(&ebp_104->t00D4, dwLoc011C);
				}
				Eq_4 eax_259 = ebp_104->t007C;
				Eq_4 edx_262 = ebp_104->t0078;
				Eq_4 ebx_263 = 0x00;
				while (ebx_263 < eax_259)
				{
					Eq_4 eax_278 = *edx_262;
					Eq_4 ebx_282 = (word32) eax_278 + ebp_104->dw0064;
					Eq_4 esi_298;
					Eq_4 edi_297;
					word24 ebx_24_8_328 = SLICE(runtime.mapaccess1_fast32(gs, 0x080CFC00, dwLoc011C, *((word32) ebx_282 + 8), out esi_298, out edi_297), word24, 8);
					Eq_4 ecx_304 = *((byte) dwLoc0124_688.u0 + 4);
					Eq_4 eax_306 = *dwLoc0124_688.u0;
					Eq_4 edx_307 = 0x00;
					while (edx_307 < ecx_304)
					{
						Eq_4 ecx_320 = *eax_306;
						word32 edi_1162;
						runtime.makemap(ebx_24_8_328, esi_298, edi_297, gs, 0x080CFAC0, 0x00, 0x00, 0x00, 0x00, out edi_1162);
						dwLoc0124_688.u0 = 0x00;
						esi_298 = runtime.typesEqual(gs, ebx_282, ecx_320, dwLoc011C, out edi_297);
						eax_306 = (word32) eax_306 + 4;
						ebx_24_8_328 = SLICE(edx_307, word24, 8);
						edx_307 = (word32) edx_307 + 1;
					}
					esi_106 = runtime.mapassign_fast32(gs, 0x080CFB00, ebp_104->t00D4, eax_278);
					if (g_t81576F0 == 0x00)
						*dwLoc0124_688.u0 = ebx_282;
					else
						runtime.writebarrierptr(dwLoc0124_688, ebx_282);
					edx_262 = (word32) edx_262 + 4;
					ebx_263 = (word32) ebx_263 + 1;
				}
			}
			++ecx_102;
			ebx_454 = (word32) ebx_454.u0 + 1;
			eax_100 = ebp_104;
		}
		return esi_106;
	}
}

// 08089F40: Register Eq_4 runtime.typesEqual(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C, Register out Eq_4 ediOut)
// Called from:
//      runtime.typelinksinit
//      runtime.typesEqual
Eq_4 runtime.typesEqual(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C, union Eq_4 & ediOut)
{
	byte bLoc80_1394 = (byte) dwLoc80;
	while (fp - 0x10 <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 edi_32;
	Eq_4 esi_33 = runtime.mapaccess2_fast64(gs, &g_t80CFAC0, dwArg0C, dwArg04, dwArg08, out edi_32);
	if (bLoc7C != 0x00)
	{
		ediOut = edi_32;
		return esi_33;
	}
	Eq_4 edi_1000;
	Eq_4 esi_1001 = runtime.mapassign_fast64(gs, 0x080CFAC0, dwArg0C, dwArg04, dwArg08, out edi_1000);
	if (dwArg04 == dwArg08)
	{
		ediOut = edi_1000;
		return esi_1001;
	}
	word32 edx_86 = (word32) *((word32) dwArg04 + 0x0F);
	byte bl_104 = (byte) edx_86;
	byte dl_94 = (byte) edx_86 & 0x1F;
	if (dl_94 != (*((word32) dwArg08 + 0x0F) & 0x1F))
	{
		ediOut = edi_1000;
		return esi_1001;
	}
	runtime.(*_type).string(gs, dwArg04);
	runtime.(*_type).string(gs, dwArg08);
	if (dwArg04 != dwArg04)
	{
l0808A043:
		ediOut = edi_1000;
		return esi_1001;
	}
	word32 ebx_139;
	runtime.eqstring(dwArg04, dwArg0C, dwArg04, dwArg0C, out ebx_139, out esi_1001, out edi_1000);
	Eq_4 dwLoc8C_1391 = dwArg04;
	Eq_4 dwLoc88_1392 = dwArg0C;
	byte bLoc84_1484 = (byte) dwArg04;
	if (bLoc80_1394 == 0x00)
		goto l0808A043;
	byte bLoc80_1527;
	runtime.(*_type).uncommon(gs, dwArg04);
	runtime.(*_type).uncommon(gs, dwArg08);
	if (dwArg04 == 0x00)
	{
		bLoc80_1527 = (byte) dwLoc80;
		if (dwArg04 == 0x00)
			goto l0808A0B4;
	}
	if (dwArg04 == 0x00 || dwArg04 == 0x00)
	{
		ediOut = edi_1000;
		return esi_1001;
	}
	Eq_4 eax_188 = *dwArg04;
	runtime.(*_type).nameOff(gs);
	runtime.name.name(gs, dwArg0C);
	Eq_4 edx_213 = *dwArg04;
	runtime.(*_type).nameOff(gs);
	runtime.name.name(gs, dwArg0C);
	if (dwArg0C == dwArg0C)
	{
		runtime.eqstring(dwArg0C, eax_188, dwArg0C, edx_213, out ebx_139, out esi_1001, out edi_1000);
		dwLoc8C_1391 = dwArg0C;
		dwLoc88_1392 = edx_213;
		bLoc84_1484 = (byte) dwArg0C;
		if (bLoc80_1394 != 0x00)
		{
l0808A0B4:
			word32 eax_267 = (word32) dl_94;
			word24 ebx_24_8_667 = SLICE(ebx_139, word24, 8);
			cu8 al_275 = (byte) eax_267;
			if ((byte) eax_267 <= 0x10)
			{
				ediOut = edi_1000;
				return esi_1001;
			}
			if (al_275 > 0x15)
			{
				if (al_275 <= 0x17)
				{
					if (al_275 != 22)
					{
						word32 edi_2240;
						runtime.typesEqual(gs, *((word32) dwArg04 + 32), *((word32) dwArg08 + 32), dwArg0C, out edi_2240);
						ediOut = edi_1000;
						return esi_1001;
					}
					else
					{
						word32 edi_2241;
						runtime.typesEqual(gs, *((word32) dwArg04 + 32), *((word32) dwArg08 + 32), dwArg0C, out edi_2241);
						ediOut = edi_1000;
						return esi_1001;
					}
				}
				if (al_275 != 0x18)
				{
					if (al_275 == 0x19)
					{
						Eq_4 ecx_287 = *((word32) dwArg04 + 40);
						if (ecx_287 != *((word32) dwArg08 + 40))
						{
							ediOut = edi_1000;
							return esi_1001;
						}
						else
						{
							Eq_4 ebx_296 = 0x00;
							while (ebx_296 < ecx_287)
							{
								Eq_4 esi_1852 = *((word32) dwArg04 + 36);
								if (ebx_296 >= *((word32) dwArg04 + 40))
									runtime.panicindex(gs);
								ui32 ebp_314 = ebx_296 * 0x03;
								Eq_4 edi_1815 = *((word32) dwArg08 + 40);
								Eq_4 edx_317 = *((word32) dwArg08 + 36);
								if (ebx_296 >= edi_1815)
									runtime.panicindex(gs);
								runtime.name.name(gs, *((word32) esi_1852 + ebp_314 * 0x04));
								runtime.name.name(gs, *((word32) edx_317 + ebp_314 * 0x04));
								if (dwLoc88_1392 != dwLoc88_1392)
								{
l0808AA59:
									ediOut = edi_1815;
									return esi_1852;
								}
								word32 ebx_2242;
								runtime.eqstring(dwLoc88_1392, dwLoc8C_1391, dwLoc88_1392, dwLoc8C_1391, out ebx_2242, out esi_1852, out edi_1815);
								if (bLoc80_1527 == 0x00)
									goto l0808AA59;
								word32 edi_2243;
								runtime.name.pkgPath(gs, *((word32) esi_1852 + ebp_314 * 0x04), out edi_2243);
								esi_1001 = runtime.name.pkgPath(gs, *((word32) edx_317 + ebp_314 * 0x04), out edi_1000);
								if (dwLoc8C_1391 != dwLoc8C_1391)
								{
l0808AA4A:
									ediOut = edi_1000;
									return esi_1001;
								}
								word32 ebx_2244;
								runtime.eqstring(dwLoc8C_1391, dwLoc88_1392, dwLoc8C_1391, dwLoc88_1392, out ebx_2244, out esi_1001, out edi_1000);
								byte bLoc84_1459 = (byte) dwLoc8C_1391;
								if (bLoc80_1527 == 0x00)
									goto l0808AA4A;
								Eq_4 ebp_462 = *((word32) edx_317 + (ebp_314 * 0x04 + 4));
								word32 edi_2245;
								runtime.typesEqual(gs, *((word32) esi_1852 + (ebp_314 * 0x04 + 4)), ebp_462, dwArg0C, out edi_2245);
								if (bLoc84_1459 == 0x00)
								{
									ediOut = edi_1000;
									return esi_1001;
								}
								runtime.name.tag(gs, *((word32) esi_1852 + ebp_314 * 0x04));
								runtime.name.tag(gs, *((word32) edx_317 + ebp_314 * 0x04));
								if (dwArg0C != dwArg0C)
								{
l0808AA2C:
									ediOut = edi_1000;
									return esi_1001;
								}
								word32 ebx_2246;
								runtime.eqstring(dwArg0C, ebp_462, dwArg0C, ebp_462, out ebx_2246, out esi_1001, out edi_1000);
								dwLoc8C_1391 = dwArg0C;
								dwLoc88_1392 = ebp_462;
								if (bLoc80_1527 == 0x00)
									goto l0808AA2C;
								if (*((word32) esi_1852 + (ebp_314 * 0x04 + 8)) != *((word32) edx_317 + (ebp_314 * 0x04 + 8)))
								{
									ediOut = edi_1000;
									return esi_1001;
								}
								ebx_296 = (word32) ebx_296 + 1;
							}
							ediOut = edi_1000;
							return esi_1001;
						}
					}
					if (al_275 != 0x1A)
					{
l0808ABCB:
						runtime.printlock(gs);
						runtime.printstring(gs);
						runtime.printsp(gs);
						runtime.printint(ebx_24_8_667, gs, (uint64) ((word32) bl_104 & 0x1F));
						runtime.printnl(gs);
						runtime.printunlock(gs);
						runtime.throw(gs);
					}
				}
				ediOut = edi_1000;
				return esi_1001;
			}
			else
			{
				if (al_275 > 0x12)
				{
					if (al_275 != 0x13)
					{
						if (al_275 != 0x14)
						{
							word32 edi_2229;
							runtime.typesEqual(gs, *((word32) dwArg04 + 32), *((word32) dwArg08 + 32), dwArg0C, out edi_2229);
							if (bLoc84_1484 != 0x00)
							{
								word32 edi_2232;
								runtime.typesEqual(gs, *((word32) dwArg04 + 36), *((word32) dwArg08 + 36), dwArg0C, out edi_2232);
							}
							ediOut = edi_1000;
							return esi_1001;
						}
						else
						{
							runtime.name.name(gs, *((word32) dwArg04 + 32));
							runtime.name.name(gs, *((word32) dwArg08 + 32));
							if (dwLoc88_1392 == dwLoc88_1392)
							{
								word32 ebx_2230;
								runtime.eqstring(dwLoc88_1392, dwLoc8C_1391, dwLoc88_1392, dwLoc8C_1391, out ebx_2230, out esi_1001, out edi_1000);
								Eq_4 dwLoc88_1525 = dwLoc8C_1391;
								if (bLoc80_1527 != 0x00)
								{
									Eq_4 ecx_820 = *((word32) dwArg04 + 40);
									if (ecx_820 != *((word32) dwArg08 + 40))
									{
										ediOut = edi_1000;
										return esi_1001;
									}
									else
									{
										Eq_4 ebx_1068 = 0x00;
										while (ebx_1068 < ecx_820)
										{
											Eq_4 ebp_842 = *((word32) dwArg04 + 36);
											if (ebx_1068 >= *((word32) dwArg04 + 40))
												runtime.panicindex(gs);
											Eq_4 esi_1843 = (word32) ebp_842 + ebx_1068 * 0x08;
											Eq_4 edi_1807 = *((word32) dwArg08 + 40);
											Eq_4 edx_850 = *((word32) dwArg08 + 36);
											if (ebx_1068 >= edi_1807)
												runtime.panicindex(gs);
											runtime.resolveNameOff(gs, esi_1843, *((word32) ebp_842 + ebx_1068 * 0x08));
											Eq_4 ebx_875 = *((word32) edx_850 + ebx_1068 * 0x08);
											Eq_4 ebx_877 = (word32) edx_850 + ebx_1068 * 0x08;
											runtime.resolveNameOff(gs, ebx_877, ebx_875);
											runtime.name.name(gs, dwLoc88_1525);
											runtime.name.name(gs, dwLoc88_1525);
											if (dwLoc88_1525 != dwLoc88_1525)
											{
l0808A603:
												ediOut = edi_1807;
												return esi_1843;
											}
											word32 ebx_2234;
											runtime.eqstring(dwLoc88_1525, ebx_875, dwLoc88_1525, ebx_875, out ebx_2234, out esi_1843, out edi_1807);
											if (bLoc80_1527 == 0x00)
												goto l0808A603;
											word32 edi_2235;
											runtime.name.pkgPath(gs, dwLoc88_1525, out edi_2235);
											esi_1001 = runtime.name.pkgPath(gs, dwLoc88_1525, out edi_1000);
											if (ebx_875 != ebx_875)
											{
l0808A5F4:
												ediOut = edi_1000;
												return esi_1001;
											}
											word32 ebx_2236;
											runtime.eqstring(ebx_875, dwLoc88_1525, ebx_875, dwLoc88_1525, out ebx_2236, out esi_1001, out edi_1000);
											byte bLoc84_1576 = (byte) ebx_875;
											if (bLoc80_1527 == 0x00)
												goto l0808A5F4;
											runtime.resolveTypeOff(gs, esi_1843, *((word32) ebp_842 + (ebx_1068 * 0x08 + 4)));
											runtime.resolveTypeOff(gs, ebx_877, *((word32) edx_850 + (ebx_1068 * 0x08 + 4)));
											word32 edi_2237;
											runtime.typesEqual(gs, dwLoc88_1525, dwLoc88_1525, dwArg0C, out edi_2237);
											dwLoc88_1525 = dwArg0C;
											if (bLoc84_1576 == 0x00)
											{
												ediOut = edi_1000;
												return esi_1001;
											}
											ebx_1068 = (word32) ebx_1068 + 1;
										}
										ediOut = edi_1000;
										return esi_1001;
									}
								}
							}
							ediOut = edi_1000;
							return esi_1001;
						}
					}
					else
					{
						if (*((word32) dwArg04 + 0x0022) == *((word32) dwArg08 + 0x0022))
						{
							Eq_4 cx_1090 = *((word32) dwArg04 + 32);
							Eq_4 bx_1089 = *((word32) dwArg08 + 32);
							if (bx_1089 == cx_1090)
							{
								word32 ebp_1108;
								if ((*((word32) dwArg04 + 0x0C) & 0x01) != 0x00)
									ebp_1108 = 0x34;
								else
									ebp_1108 = 0x24;
								Eq_4 (* ebp_1113)[] = (word32) dwArg04 + ebp_1108;
								Eq_4 ecx_1118 = (word32) cx_1090;
								if (ecx_1118 > 0x00100000)
									runtime.panicslice(gs);
								else
								{
									word32 esi_1134;
									if ((*((word32) dwArg08 + 0x0C) & 0x01) != 0x00)
										esi_1134 = 0x34;
									else
										esi_1134 = 0x24;
									Eq_4 esi_1139 = (word32) dwArg08 + esi_1134;
									Eq_4 ebx_1146 = (word32) bx_1089;
									if (ebx_1146 > 0x00100000)
										runtime.panicslice(gs);
									else
									{
										Eq_4 edi_1158 = 0x00;
										while (edi_1158 < ecx_1118)
										{
											if (edi_1158 >= ecx_1118)
											{
l0808ABB6:
												runtime.panicindex(gs);
											}
											Eq_4 edx_1314 = ebp_1113[edi_1158];
											if (edi_1158 >= ebx_1146)
												goto l0808ABB6;
											word32 edi_2231;
											runtime.typesEqual(gs, edx_1314, *((word32) esi_1139 + edi_1158 * 0x04), dwArg0C, out edi_2231);
											if (bLoc84_1484 == 0x00)
											{
												ediOut = edi_1158;
												return esi_1139;
											}
											edi_1158 = (word32) edi_1158 + 1;
										}
										word32 ecx_1172;
										if ((*((word32) dwArg04 + 0x0C) & 0x01) != 0x00)
											ecx_1172 = 0x34;
										else
											ecx_1172 = 0x24;
										word32 eax_1183 = (word32) *((word32) dwArg04 + 32);
										word32 ecx_1177 = (word32) dwArg04 + ecx_1172;
										uint32 ebp_1185 = (word32) (word16) eax_1183;
										uint32 eax_1188 = (word32) ((word16) eax_1183 + (*((word32) dwArg04 + 0x0022) & 0x7FFF));
										if (ebp_1185 > eax_1188 || eax_1188 > 0x00100000)
											runtime.panicslice(gs);
										else
										{
											word32 ebx_1211;
											Eq_4 eax_1196 = eax_1188 - ebp_1185;
											Eq_4 ecx_1203[] = ecx_1177 + (-(-(ebp_1185 + 0xFFF00000)) >> 0x1F & ebp_1185 << 0x02);
											if ((*((word32) dwArg08 + 0x0C) & 0x01) != 0x00)
												ebx_1211 = 0x34;
											else
												ebx_1211 = 0x24;
											word32 edx_1223 = (word32) *((word32) dwArg08 + 32);
											word32 ebx_1216 = (word32) dwArg08 + ebx_1211;
											uint32 esi_1225 = (word32) (word16) edx_1223;
											uint32 edx_1228 = (word32) ((word16) edx_1223 + (*((word32) dwArg08 + 0x0022) & 0x7FFF));
											if (esi_1225 > edx_1228 || edx_1228 > 0x00100000)
												runtime.panicslice(gs);
											else
											{
												Eq_4 edx_1244 = edx_1228 - esi_1225;
												Eq_4 esi_1261 = esi_1225 << 0x02;
												Eq_4 ebx_1264[] = ebx_1216 + (-(-(esi_1225 + 0xFFF00000)) >> 0x1F & esi_1225 << 0x02);
												Eq_4 ebp_1266 = 0x00;
												while (ebp_1266 < eax_1196)
												{
													if (ebp_1266 >= eax_1196)
													{
l0808ABA1:
														runtime.panicindex(gs);
													}
													Eq_4 esi_1280 = ecx_1203[ebp_1266];
													if (ebp_1266 >= edx_1244)
														goto l0808ABA1;
													word32 edi_2233;
													runtime.typesEqual(gs, esi_1280, ebx_1264[ebp_1266], dwArg0C, out edi_2233);
													if (bLoc84_1484 == 0x00)
													{
														ediOut = edi_1158;
														return esi_1280;
													}
													esi_1261 = ebp_1266;
													ebp_1266 = (word32) ebp_1266 + 1;
												}
												ediOut = edi_1158;
												return esi_1261;
											}
										}
									}
								}
							}
						}
						ediOut = edi_1000;
						return esi_1001;
					}
				}
				if (al_275 == 0x11)
				{
					word32 edi_2238;
					runtime.typesEqual(gs, *((word32) dwArg04 + 32), *((word32) dwArg08 + 32), dwArg0C, out edi_2238);
					ediOut = edi_1000;
					return esi_1001;
				}
				if (al_275 == 0x12)
				{
					if (*((word32) dwArg04 + 36) == *((word32) dwArg08 + 36))
					{
						word32 edi_2239;
						runtime.typesEqual(gs, *((word32) dwArg04 + 32), *((word32) dwArg08 + 32), dwArg0C, out edi_2239);
					}
					ediOut = edi_1000;
					return esi_1001;
				}
				goto l0808ABCB;
			}
		}
	}
	ediOut = edi_1000;
	return esi_1001;
}

// 0808AC30: void runtime.decoderune(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C)
// Called from:
//      runtime.stringtoslicerune
//      fmt.(*fmt).truncate
void runtime.decoderune(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (dwArg0C >= dwArg08)
		return;
	if (dwArg0C > dwArg08)
		runtime.panicslice(gs);
	else
	{
		Eq_78592 ecx_25 = dwArg08 - dwArg0C;
		int32 ecx_29 = -ecx_25 >> 0x1F & dwArg0C;
		if (ecx_25 <= 0x00)
			runtime.panicindex(gs);
		else
		{
			ui32 ebp_35 = (word32) *((word32) dwArg04 + ecx_29);
			if ((byte) ebp_35 >= 0x20)
			{
				if ((byte) ebp_35 >= 0x10)
				{
					if ((byte) ebp_35 >= 0x08 || ecx_25 <= 0x03)
						return;
					ui32 edx_68 = (word32) ((word32) dwArg04 + 1 + ecx_29);
					if ((byte) edx_68 > 191 || (byte) edx_68 < 0x80)
						return;
					ui32 esi_79 = (word32) ((word32) dwArg04 + 2 + ecx_29);
					if ((byte) esi_79 > 191 || (byte) esi_79 < 0x80)
						return;
					ui32 ecx_90 = (word32) ((word32) dwArg04 + 3 + ecx_29);
					if ((byte) ecx_90 > 191 || (byte) ecx_90 < 0x80 || (ecx_90 & 0x3F | (((ebp_35 & 0x07) << 0x12 | (edx_68 & 0x3F) << 0x0C) | (esi_79 & 0x3F) << 0x06)) > 1114111)
						;
				}
				else
				{
					if (ecx_25 <= 0x02)
						return;
					ui32 edx_114 = (word32) ((word32) dwArg04 + 1 + ecx_29);
					if ((byte) edx_114 > 191 || (byte) edx_114 < 0x80)
						return;
					ui32 ecx_125 = (word32) ((word32) dwArg04 + 2 + ecx_29);
					if ((byte) ecx_125 > 191 || (byte) ecx_125 < 0x80)
						return;
					Eq_78668 edx_136 = (edx_114 & 0x3F) << 0x06 | (ebp_35 & 0x0F) << 0x0C | ecx_125 & 0x3F;
					if (edx_136 <= 0x07FF || edx_136 <= ~0xDFFE)
						;
				}
			}
			else
			{
				if (ecx_25 <= 0x01)
					return;
				ui32 ecx_148 = (word32) ((word32) dwArg04 + 1 + ecx_29);
				if ((byte) ecx_148 > 191 || (byte) ecx_148 < 0x80 || ((ebp_35 & 0x1F) << 0x06 | ecx_148 & 0x3F) <= 0x7F)
					;
			}
		}
	}
}

// 0808ADD0: void runtime.encoderune(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_68031) dwArg04, Stack up32 dwArg08, Stack Eq_4 dwArg10)
// Called from:
//      runtime.slicerunetostring
//      runtime.intstring
void runtime.encoderune(struct Eq_2 * gs, struct Eq_68031 * dwArg04, up32 dwArg08, Eq_4 dwArg10)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 eax_16 = dwArg10;
	byte al_108 = (byte) dwArg10;
	if (dwArg10 > 0x7F)
	{
		if (dwArg10 > 0x07FF)
		{
			if (dwArg10 > 1114111 || dwArg10 <= ~0xDFFE)
				eax_16.u0 = 0xFFFD;
			else if (dwArg10 > 0xFFFF)
			{
				if (dwArg08 <= 0x03)
					runtime.panicindex(gs);
				else
				{
					dwArg04->b0000 = (byte) (dwArg10 >> 0x12) | 0xF0;
					dwArg04->b0001 = (byte) (dwArg10 >> 0x0C) & 0x3F | 0x80;
					dwArg04->b0002 = (byte) (dwArg10 >> 0x06) & 0x3F | 0x80;
					dwArg04->b0003 = (byte) dwArg10 & 0x3F | 0x80;
					return;
				}
			}
			if (dwArg08 <= 0x02)
				runtime.panicindex(gs);
			else
			{
				dwArg04->b0000 = (byte) (eax_16 >> 0x0C) | 0xE0;
				dwArg04->b0001 = (byte) (eax_16 >> 0x06) & 0x3F | 0x80;
				dwArg04->b0002 = (byte) eax_16 & 0x3F | 0x80;
			}
		}
		else if (dwArg08 <= 0x01)
			runtime.panicindex(gs);
		else
		{
			dwArg04->b0000 = (byte) (dwArg10 >> 0x06) | 0xC0;
			dwArg04->b0001 = (byte) dwArg10 & 0x3F | 0x80;
		}
	}
	else if (dwArg08 <= 0x00)
		runtime.panicindex(gs);
	else
		dwArg04->b0000 = al_108;
}

// 0808AF10: Register Eq_4 runtime.float64toint64(Register (ptr32 Eq_2) gs, Stack real64 rArg04, Register out Eq_20993 xmm0Out)
// Called from:
//      runtime.(*gcControllerState).startCycle
//      runtime.(*gcControllerState).endCycle
//      runtime.gcAssistAlloc
//      runtime.gcAssistAlloc1
//      runtime.gcFlushBgCredit
//      runtime.deductSweepCredit
//      reflect.cvtFloatInt
Eq_4 runtime.float64toint64(struct Eq_2 * gs, real64 rArg04, union Eq_20993 & xmm0Out)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_20993 xmm0_21 = (uint128) rArg04;
	runtime._d2v(gs, (word32) fp + 0x0C, (real64) xmm0_21);
	xmm0Out = xmm0_21;
	return <invalid>;
}

// 0808AF60: void runtime.float64touint64(Register (ptr32 Eq_2) gs, Stack real64 rArg04)
// Called from:
//      runtime.gcinit
//      runtime.(*gcControllerState).startCycle
//      runtime.gcSetTriggerRatio
//      reflect.cvtFloatUint
void runtime.float64touint64(struct Eq_2 * gs, real64 rArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime._d2v(gs, (word32) fp + 0x0C, (real64) (uint128) rArg04);
}

// 0808AFB0: void runtime.int64tofloat64(Register word24 ebx_24_8, Register (ptr32 Eq_2) gs, Stack Eq_4 qwArg04)
// Called from:
//      runtime.makemap
//      runtime.mapassign
//      runtime.hashGrow
//      runtime.mapassign_fast32
//      runtime.mapassign_fast64
//      runtime.mapassign_faststr
//      runtime.nextSample
//      runtime.(*gcControllerState).startCycle
//      runtime.(*gcControllerState).revise
//      runtime.(*gcControllerState).endCycle
//      runtime.(*gcControllerState).findRunnableGCWorker
//      runtime.gcSetTriggerRatio
//      runtime.gcMarkTermination
//      runtime.gcAssistAlloc
//      runtime.gcAssistAlloc1
//      runtime.gcFlushBgCredit
//      reflect.cvtIntFloat
void runtime.int64tofloat64(word24 ebx_24_8, struct Eq_2 * gs, Eq_4 qwArg04)
{
	int32 dwArg08 = SLICE(qwArg04, word32, 32);
	while (true)
	{
		Eq_4 ecx_7 = gs->ptr0000->tFFFFFFFC;
		if (fp > *((word32) ecx_7 + 8))
			break;
		runtime.morestack_noctxt();
	}
	if (((int8) (dwArg08 < 0x00) | (int8) (dwArg08 == 0x00) & (int8) Test(ULT,false)) == 0x00)
	{
		runtime.uint32tofloat64();
		runtime.uint32tofloat64();
	}
	else
	{
		runtime.uint32tofloat64();
		runtime.uint32tofloat64();
	}
}

// 0808B0A0: Register Eq_4 runtime.uint64tofloat64(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg08)
// Called from:
//      runtime.makemap
//      runtime.mapassign
//      runtime.hashGrow
//      runtime.mapassign_fast32
//      runtime.mapassign_fast64
//      runtime.mapassign_faststr
//      runtime.nextSample
//      runtime.gcinit
//      runtime.(*gcControllerState).startCycle
//      runtime.(*gcControllerState).endCycle
//      runtime.gcSetTriggerRatio
//      reflect.cvtUintFloat
Eq_4 runtime.uint64tofloat64(struct Eq_2 * gs, Eq_4 dwArg08)
{
	while (true)
	{
		Eq_4 ecx_7 = gs->ptr0000->tFFFFFFFC;
		if (fp > *((word32) ecx_7 + 8))
			break;
		runtime.morestack_noctxt();
	}
	runtime.uint32tofloat64();
	runtime.uint32tofloat64();
	return ecx_7;
}

// 0808B110: void runtime._d2v(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_78886) dwArg04, Stack real64 rArg08)
// Called from:
//      runtime.float64toint64
//      runtime.float64touint64
void runtime._d2v(struct Eq_2 * gs, struct Eq_78886 * dwArg04, real64 rArg08)
{
	uint32 dwArg0C = SLICE(rArg08, word32, 32);
	uint32 dwArg08 = (word32) rArg08;
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	uint32 ebx_24 = dwArg0C >> 0x14 & 0x07FF;
	Eq_78985 ecx_27 = 0x0433 - ebx_24;
	uint32 edx_119 = dwArg08;
	uint32 eax_124 = dwArg0C & 0x000FFFFF | 0x00100000;
	byte cl_97 = (byte) ecx_27;
	if (ecx_27 >= 0x00)
	{
		if (ecx_27 < 0x20)
		{
			if (ecx_27 != 0x00)
			{
				ui32 ebx_101 = 0x00 - (ecx_27 < 0x20);
				up32 ebx_107 = 0x20 - ecx_27;
				edx_119 = dwArg08 >> cl_97 & ebx_101 | eax_124 << (byte) ebx_107 & 0x00 - (ebx_107 < 0x20);
				eax_124 = eax_124 >> (byte) ecx_27 & ebx_101;
			}
		}
		else
		{
			if (ecx_27 != 0x20)
			{
				uint32 edx_74;
				if (ecx_27 < 0x40)
					edx_74 = 0x00 - (ecx_27 < 0x40) & eax_124 >> (byte) ecx_27 + 0xE0;
				else
					edx_74 = 0x00;
				eax_124 = edx_74;
			}
			edx_119 = eax_124;
			eax_124 = 0x00;
		}
	}
	else if (ebx_24 <= 0x043E)
	{
		byte cl_47 = (byte) ebx_24 - 0x33;
		ui32 ebp_51 = 0x00 - (ebx_24 < 1107);
		up32 ecx_56 = 1107 - ebx_24;
		edx_119 = dwArg08 << cl_47 & ebp_51;
		eax_124 = eax_124 << cl_47 & ebp_51 | dwArg08 >> (byte) ecx_56 & 0x00 - (ecx_56 < 0x20);
	}
	else
	{
		runtime.float64touint32();
		eax_124 = dwLoc0C;
		edx_119 = 0x00;
	}
	if (__align(dwArg0C, -0x80000000) != 0x00)
	{
		if (edx_119 != 0x00)
		{
			edx_119 = -edx_119;
			eax_124 = ~eax_124;
		}
		else
			eax_124 = -eax_124;
	}
	dwArg04->dw0000 = edx_119;
	dwArg04->dw0004 = eax_124;
}

// 0808B230: Register uint32 runtime.uint64div(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C, Stack Eq_4 dwArg10)
// Called from:
//      runtime/debug.setGCPercent
//      runtime.(*gcControllerState).startCycle
//      runtime.gcSetTriggerRatio
//      runtime.gcMarkTermination
//      runtime.itoaDiv
//      runtime.fmtNSAsMS
//      runtime.printuint
//      strconv.(*decimal).Assign
//      strconv.(*extFloat).ShortestDecimal
//      strconv.formatBits
//      fmt.(*fmt).fmt_integer
uint32 runtime.uint64div(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C, Eq_4 dwArg10)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (dwArg08 != 0x00 || dwArg10 != 0x00)
		return runtime.dodiv(ebx_24_8, esi, gs, dwArg04, dwArg0C, dwArg10);
	if (dwArg0C == 0x00)
		runtime.panicdivide(gs);
	if (dwArg0C != 0x00)
		return (uint32) ((uint64) dwArg04 % dwArg0C);
	runtime.panicdivide(gs);
}

// 0808B2D0: Register uint32 runtime.uint64mod(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C, Stack Eq_4 dwArg10)
// Called from:
//      runtime.itoaDiv
//      runtime.printuint
uint32 runtime.uint64mod(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C, Eq_4 dwArg10)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (dwArg08 != 0x00 || dwArg10 != 0x00)
		return runtime.dodiv(ebx_24_8, esi, gs, dwArg04, dwArg0C, dwArg10);
	if (dwArg0C == 0x00)
		runtime.panicdivide(gs);
	if (dwArg0C != 0x00)
		return (uint32) ((uint64) dwArg04 % dwArg0C);
	runtime.panicdivide(gs);
}

// 0808B370: void runtime.int64div(Register ui32 edi, Register (ptr32 Eq_2) gs, Stack Eq_57087 qwArg04, Stack Eq_57088 qwArg0C)
// Called from:
//      runtime.schedtrace
//      runtime.timerproc
//      runtime.goroutineheader
void runtime.int64div(ui32 edi, struct Eq_2 * gs, Eq_57087 qwArg04, Eq_57088 qwArg0C)
{
	Eq_4 dwArg04 = (word32) qwArg04;
	int32 dwArg08 = SLICE(qwArg04, word32, 32);
	Eq_4 dwArg0C = (word32) qwArg0C;
	Eq_4 dwArg10 = SLICE(qwArg0C, word32, 32);
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	ui24 edx_24_8_108 = SLICE(dwArg08, word24, 8);
	if (((int8) (dwArg04 >> 0x1F == dwArg08) & 0x01) == 0x00 || ((int8) (dwArg0C >> 0x1F == dwArg10) & 0x01) == 0x00)
	{
		Eq_4 eax_117;
		byte bl_67 = (byte) (uint32) (int8) Test(ULT,false) & (int8) (dwArg08 == 0x00) | (int8) (dwArg08 < 0x00);
		if (bl_67 != 0x00)
			eax_117 = 0x00 - (word32) qwArg04;
		else
			eax_117 = dwArg04;
		Eq_4 ebp_138;
		Eq_4 edx_137;
		ui32 edi_115 = SEQ(SLICE(edi, word24, 8), (int8) Test(ULT,false)) & SEQ(edx_24_8_108, (int8) (dwArg10 == 0x00)) | SEQ(edx_24_8_108, (int8) (dwArg10 < 0x00));
		byte al_120 = (byte) edi_115;
		if ((byte) edi_115 != 0x00)
		{
			ui64 ebp_edx_253 = 0x00 - qwArg0C;
			edx_137 = (word32) ebp_edx_253;
			ebp_138 = SLICE(ebp_edx_253, word32, 32);
		}
		else
		{
			edx_137 = dwArg0C;
			ebp_138 = dwArg10;
		}
		runtime.dodiv(ebx_24_8, esi, gs, eax_117, edx_137, ebp_138);
	}
	else
	{
		if (dwArg04 == 0x80000000 && dwArg0C == ~0x00)
			return;
		if (dwArg0C == 0x00)
			runtime.panicdivide(gs);
		if (dwArg0C != 0x00)
			return;
		runtime.panicdivide(gs);
	}
}

// 0808B4F0: void runtime.int64mod(Register word32 edi, Register (ptr32 Eq_2) gs, Stack Eq_38720 qwArg04, Stack Eq_3266 qwArg0C)
// Called from:
//      runtime.blocksampled
//      sync.event
void runtime.int64mod(word32 edi, struct Eq_2 * gs, Eq_38720 qwArg04, Eq_3266 qwArg0C)
{
	Eq_4 dwArg04 = (word32) qwArg04;
	int32 dwArg08 = SLICE(qwArg04, word32, 32);
	Eq_4 dwArg0C = (word32) qwArg0C;
	Eq_4 dwArg10 = SLICE(qwArg0C, word32, 32);
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (((int8) (dwArg08 == dwArg04 >> 0x1F) & 0x01) == 0x00 || ((int8) (dwArg10 == dwArg0C >> 0x1F) & 0x01) == 0x00)
	{
		Eq_4 eax_117;
		byte bl_67 = (byte) (uint32) (int8) Test(ULT,false) & (int8) (dwArg08 == 0x00) | (int8) (dwArg08 < 0x00);
		if (bl_67 != 0x00)
			eax_117 = 0x00 - (word32) qwArg04;
		else
			eax_117 = dwArg04;
		Eq_4 ebp_130;
		Eq_4 edx_129;
		if (((int8) Test(ULT,false) & (int8) (dwArg10 == 0x00) | (int8) (dwArg10 < 0x00)) != 0x00)
		{
			ui64 ebp_edx_229 = 0x00 - qwArg0C;
			edx_129 = (word32) ebp_edx_229;
			ebp_130 = SLICE(ebp_edx_229, word32, 32);
		}
		else
		{
			edx_129 = dwArg0C;
			ebp_130 = dwArg10;
		}
		runtime.dodiv(ebx_24_8, esi, gs, eax_117, edx_129, ebp_130);
	}
	else
	{
		if (dwArg0C == 0x00)
			runtime.panicdivide(gs);
		if (dwArg0C != 0x00)
			return;
		runtime.panicdivide(gs);
	}
}

// 0808B640: Register Eq_4 runtime.dodiv(Register ui24 ebx_24_8, Register word32 esi, Register (ptr32 Eq_2) gs, Stack Eq_4 qwArg04, Stack Eq_4 dwArg0C, Stack Eq_4 dwArg10)
// Called from:
//      runtime.uint64div
//      runtime.uint64mod
//      runtime.int64div
//      runtime.int64mod
Eq_4 runtime.dodiv(ui24 ebx_24_8, word32 esi, struct Eq_2 * gs, Eq_4 qwArg04, Eq_4 dwArg0C, Eq_4 dwArg10)
{
	Eq_4 dwArg04 = (word32) qwArg04;
	Eq_4 dwArg08 = SLICE(qwArg04, word32, 32);
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	ui32 esi_120 = SEQ(SLICE(esi, word24, 8), (int8) (dwArg10 == dwArg08)) & SEQ(ebx_24_8, (int8) (dwArg0C > dwArg04));
	if (((int8) (dwArg10 > dwArg08) | (byte) esi_120) != 0x00)
		return dwArg04;
	if (dwArg10 != 0x00)
	{
		ui24 ebx_24_8_95 = SLICE(runtime._mul64by32(fp - 0x08, dwArg0C, dwArg10, (uint32) ((uint64) dwArg08 /u dwArg10)), word24, 8);
		if (dwLoc24 == 0x00)
		{
			ui32 esi_112 = SEQ(SLICE(esi_120, word24, 8), (int8) (dwArg04 < 0x00)) & SEQ(ebx_24_8_95, (int8) (dwArg08 == 0x00)) | SEQ(ebx_24_8_95, (int8) (dwArg08 < 0x00));
			esi_120 = esi_112;
			if ((byte) esi_112 == 0x00)
				return dwArg08;
		}
		runtime.slowdodiv(ebx_24_8, esi_120, gs, dwArg04, dwArg08, dwArg0C, dwArg10);
		return dwLoc18;
	}
	else
	{
		Eq_4 ebp_165;
		if (dwArg08 < dwArg0C)
		{
			ebp_165 = dwArg08;
			return runtime._div64by32(SEQ(ebp_165, dwArg04), dwArg0C, fp - 0x10);
		}
		else
		{
			if (dwArg0C == 0x00)
				runtime.panicdivide(gs);
			if (dwArg0C == 0x00)
				runtime.panicdivide(gs);
			else
			{
				ebp_165 = dwArg08 - dwArg0C *s (uint32) ((uint64) dwArg08 /u dwArg0C) - (dwArg04 < 0x00);
				return runtime._div64by32(SEQ(ebp_165, dwArg04), dwArg0C, fp - 0x10);
			}
		}
	}
}

// 0808B830: void runtime.slowdodiv(Register word24 ebx_24_8, Register ui32 esi, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C, Stack Eq_4 dwArg10)
// Called from:
//      runtime.dodiv
void runtime.slowdodiv(word24 ebx_24_8, ui32 esi, struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C, Eq_4 dwArg10)
{
	while (true)
	{
		Eq_4 ecx_7 = gs->ptr0000->tFFFFFFFC;
		if (fp > *((word32) ecx_7 + 8))
			break;
		runtime.morestack_noctxt();
	}
	if (((int8) (dwArg10 == 0x00) & (int8) (dwArg0C == 0x00)) != 0x00)
		runtime.panicdivide(gs);
	Eq_4 esi_248;
	Eq_4 ebx_245;
	if (((int8) Test(UGE,false) & (int8) (dwArg08 == 0x80000000) | (int8) (dwArg08 > 0x80000000)) != 0x00)
	{
		ebx_245.u0 = 0x80000000;
		esi_248.u0 = 0x00;
	}
	else
	{
		ebx_245 = dwArg08;
		esi_248 = dwArg04;
	}
	int32 edi_134 = 0x00;
	uint64 eax_edx_300 = SEQ(dwArg10, dwArg0C);
	while (true)
	{
		Eq_4 eax_90 = SLICE(eax_edx_300, word32, 32);
		Eq_4 edx_95 = (word32) eax_edx_300;
		if (((int8) (eax_90 == ebx_245) & (int8) (edx_95 < esi_248) | (int8) (eax_90 < ebx_245)) == 0x00)
			break;
		++edi_134;
		eax_edx_300 = SEQ(eax_90 << 0x01 | edx_95 >> 0x1F, edx_95 << 0x01);
	}
	ui64 ecx_ebx_292 = SEQ(dwArg08, dwArg04);
	uint64 eax_edx_295 = eax_edx_300;
	while (true)
	{
		uint32 edx_183 = (word32) eax_edx_295;
		uint32 eax_171 = SLICE(eax_edx_295, word32, 32);
		uint32 ecx_159 = SLICE(ecx_ebx_292, word32, 32);
		uint32 ebx_157 = (word32) ecx_ebx_292;
		if (edi_134 < 0x00)
			break;
		ui64 ecx_ebx_259 = ecx_ebx_292;
		if (((int8) (ebx_157 >= edx_183) & (int8) (ecx_159 == eax_171) | (int8) (ecx_159 > eax_171)) != 0x00)
			ecx_ebx_259 = ecx_ebx_292 - eax_edx_295;
		--edi_134;
		ecx_ebx_292 = ecx_ebx_259;
		eax_edx_295 = SEQ(eax_171 >> 0x01, edx_183 >> 0x01 | eax_171 << 0x1F);
	}
}

// 0808B990: void runtime.writeErr(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg08)
// Called from:
//      runtime.gwrite
void runtime.writeErr(struct Eq_2 * gs, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (dwArg08 <= 0x00)
		runtime.panicindex(gs);
	else
	{
		word32 edx_53;
		word32 ebx_54;
		runtime.write(out edx_53, out ebx_54);
	}
}

// 0808B9E0: void runtime.cgocallbackg1.func1(Register (ptr32 Eq_79591) gs, Stack (ptr32 Eq_79592) dwArg04)
void runtime.cgocallbackg1.func1(struct Eq_79591 * gs, struct Eq_79592 * dwArg04)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	--dwArg04->dw00BC;
}

// 0808BA20: void runtime.cgoCheckWriteBarrier.func1(Register Eq_4 edx, Register Eq_4 esi, Register (ptr32 Eq_2) gs)
void runtime.cgoCheckWriteBarrier.func1(Eq_4 edx, Eq_4 esi, struct Eq_2 * gs)
{
	Eq_4 esp_19 = fp;
	while (esp_19 <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
	{
		word32 ebx_129;
		edx = runtime.morestack(edx, gs, *((word32) esp_19 - 4), *esp_19, out ebx_129, out esi);
		esp_19.u0 = <invalid>;
	}
	struct Eq_79645 * esp_24 = esp_19 - 0x10;
	esp_24->t0008 = *((word32) edx + 4);
	esp_24->t000C = *((word32) edx + 8);
	runtime.printlock(gs);
	esp_24->t0000.u0 = 0x080E2E90;
	esp_24->t0004.u0 = 0x13;
	runtime.printstring(gs);
	runtime.printsp(gs);
	esp_24->t0000 = esp_24->t0008;
	esp_24->t0004.u0 = 0x00;
	Eq_4 esi_63;
	runtime.printhex(esi, gs, esp_24->t0000, esp_24->t0004, out esi_63);
	runtime.printsp(gs);
	esp_24->t0000.u0 = 0x080E2689;
	esp_24->t0004.u0 = 0x10;
	runtime.printstring(gs);
	runtime.printsp(gs);
	esp_24->t0000 = esp_24->t000C;
	esp_24->t0004.u0 = 0x00;
	word32 esi_130;
	runtime.printhex(esi_63, gs, esp_24->t0000, esp_24->t0004, out esi_130);
	runtime.printnl(gs);
	runtime.printunlock(gs);
	esp_24->t0000.u0 = 135159152;
	esp_24->t0004.u0 = 0x24;
	runtime.throw(gs);
}

// 0808BAE0: void runtime.cgoCheckTypedBlock.func1(Register Eq_4 edx, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg00)
void runtime.cgoCheckTypedBlock.func1(Eq_4 edx, struct Eq_2 * gs, Eq_4 dwArg00)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
	{
		word32 esi_64;
		word32 ebx_63;
		edx = runtime.morestack(edx, gs, dwLoc04, dwArg00, out ebx_63, out esi_64);
	}
	runtime.cgoCheckUsingType(gs, *((word32) edx + 4), *((word32) edx + 8), *((word32) edx + 0x0C), *((word32) edx + 16));
}

// 0808BB20: void runtime.cgoCheckTypedBlock.func2(Register (ptr32 Eq_2) gs)
void runtime.cgoCheckTypedBlock.func2(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.throw(gs);
}

// 0808BB60: void runtime.cgoCheckBits.func1(Register (ptr32 Eq_2) gs)
void runtime.cgoCheckBits.func1(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.throw(gs);
}

// 0808BBA0: void runtime.chansend.func1(Register Eq_4 edx, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg00)
void runtime.chansend.func1(Eq_4 edx, struct Eq_2 * gs, Eq_4 dwArg00)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
	{
		word32 esi_61;
		word32 ebx_60;
		edx = runtime.morestack(edx, gs, dwLoc04, dwArg00, out ebx_60, out esi_61);
	}
	word32 edx_62;
	word32 ebx_63;
	runtime.unlock(gs, (word32) *((word32) edx + 4) + 48, out edx_62, out ebx_63);
}

// 0808BBD0: void runtime.chanrecv.func1(Register Eq_4 edx, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg00)
void runtime.chanrecv.func1(Eq_4 edx, struct Eq_2 * gs, Eq_4 dwArg00)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
	{
		word32 esi_61;
		word32 ebx_60;
		edx = runtime.morestack(edx, gs, dwLoc04, dwArg00, out ebx_60, out esi_61);
	}
	word32 edx_62;
	word32 ebx_63;
	runtime.unlock(gs, (word32) *((word32) edx + 4) + 48, out edx_62, out ebx_63);
}

// 0808BC00: void runtime.(*mcache).nextFree.func1(Register Eq_4 edx, Register (ptr32 Eq_2) gs, Register Eq_662 xmm1, Stack Eq_4 dwArg00)
void runtime.(*mcache).nextFree.func1(Eq_4 edx, struct Eq_2 * gs, Eq_662 xmm1, Eq_4 dwArg00)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
	{
		word32 esi_65;
		word32 ebx_64;
		edx = runtime.morestack(edx, gs, dwLoc04, dwArg00, out ebx_64, out esi_65);
	}
	runtime.(*mcache).refill(gs, xmm1, *((word32) edx + 4), *((word32) edx + 8));
}

// 0808BC40: void runtime.mallocgc.func1(Register Eq_4 edx, Register Eq_4 esi, Register (ptr32 Eq_2) gs, Register Eq_662 xmm1, Stack Eq_4 dwArg00)
void runtime.mallocgc.func1(Eq_4 edx, Eq_4 esi, struct Eq_2 * gs, Eq_662 xmm1, Eq_4 dwArg00)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
	{
		word32 ebx_79;
		edx = runtime.morestack(edx, gs, dwLoc04, dwArg00, out ebx_79, out esi);
	}
	Eq_4 eax_26 = *((word32) edx + 4);
	runtime.largeAlloc(esi, gs, xmm1, **((word32) edx + 8), *((word32) edx + 0x0C));
	*eax_26 = dwLoc08;
}

// 0808BC90: void runtime.persistentalloc.func1(Register Eq_4 edx, Register Eq_4 esi, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg00)
void runtime.persistentalloc.func1(Eq_4 edx, Eq_4 esi, struct Eq_2 * gs, Eq_4 dwArg00)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
	{
		word32 ebx_96;
		edx = runtime.morestack(edx, gs, dwLoc04, dwArg00, out ebx_96, out esi);
	}
	Eq_4 eax_26 = *((word32) edx + 4);
	runtime.persistentalloc1(esi, gs, *((word32) edx + 8), *((word32) edx + 0x0C), *((word32) edx + 16));
	if (g_t81576F0 == 0x00)
		*eax_26 = dwLoc08;
	else
		runtime.writebarrierptr(eax_26, dwLoc08);
}

// 0808BD00: void runtime.writebarrierptr_prewrite1.func1(Register Eq_4 edx, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg00)
void runtime.writebarrierptr_prewrite1.func1(Eq_4 edx, struct Eq_2 * gs, Eq_4 dwArg00)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
	{
		word32 esi_125;
		word32 ebx_124;
		edx = runtime.morestack(edx, gs, dwLoc04, dwArg00, out ebx_124, out esi_125);
	}
	Eq_4 eax_25 = *((word32) edx + 4);
	Eq_4 ecx_26 = *((word32) edx + 8);
	Eq_4 edx_27 = *((word32) edx + 0x0C);
	if (*((word32) eax_25 + 92) == 0x00 && (g_b8159250 != 0x00 && (*((word32) eax_25 + 0x008E) == 0x00 && ecx_26 != 0x00)))
	{
		Eq_4 ebx_45 = g_t81493A8;
		if (ecx_26 >= ebx_45 && ecx_26 < g_t81493AC)
		{
			Eq_4 esi_52 = g_t8149108;
			uint32 ecx_54 = ecx_26 - ebx_45;
			if (ecx_54 >> 0x0D >= g_t814910C)
				runtime.panicindex(gs);
			struct Eq_80059 * ecx_58 = *((word32) esi_52 + (ecx_54 >> 0x0D) * 0x04);
			if (ecx_58 != null && (ecx_26 >= ecx_58->t000C && (ecx_26 < ecx_58->t0050 && ecx_58->b003C == 0x01)))
				runtime.throw(gs);
		}
	}
	*((word32) eax_25 + 0x008E) = 0x01;
	runtime.gcmarkwb_m(gs, edx_27, ecx_26);
}

// 0808BDE0: void runtime.writebarrierptr.func1(Register Eq_4 edx, Register Eq_4 esi, Register (ptr32 Eq_2) gs)
void runtime.writebarrierptr.func1(Eq_4 edx, Eq_4 esi, struct Eq_2 * gs)
{
	Eq_4 esp_19 = fp;
	while (esp_19 <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
	{
		word32 ebx_109;
		edx = runtime.morestack(edx, gs, *((word32) esp_19 - 4), *esp_19, out ebx_109, out esi);
		esp_19.u0 = <invalid>;
	}
	struct Eq_80106 * esp_24 = esp_19 - 0x10;
	esp_24->t000C = *((word32) edx + 4);
	esp_24->t0008 = *((word32) edx + 8);
	runtime.printlock(gs);
	esp_24->t0000.u0 = 135152254;
	esp_24->t0004.u0 = 0x1A;
	runtime.printstring(gs);
	esp_24->t0000 = esp_24->t000C;
	runtime.printpointer(gs);
	esp_24->t0000.u0 = 0x080E0E2E;
	esp_24->t0004.u0 = 0x03;
	runtime.printstring(gs);
	esp_24->t0000 = esp_24->t0008;
	esp_24->t0004.u0 = 0x00;
	word32 esi_110;
	runtime.printhex(esi, gs, esp_24->t0000, esp_24->t0004, out esi_110);
	esp_24->t0000.u0 = 0x080E0D9C;
	esp_24->t0004.u0 = 0x01;
	runtime.printstring(gs);
	runtime.printunlock(gs);
	esp_24->t0000.u0 = 135153504;
	esp_24->t0004.u0 = 0x1C;
	runtime.throw(gs);
}

// 0808BEA0: void runtime.writebarrierptr_prewrite.func1(Register (ptr32 Eq_2) gs)
void runtime.writebarrierptr_prewrite.func1(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.throw(gs);
}

// 0808BEE0: void runtime.typedslicecopy.func1(Register Eq_4 edx, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg00)
void runtime.typedslicecopy.func1(Eq_4 edx, struct Eq_2 * gs, Eq_4 dwArg00)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
	{
		word32 ebx_409;
		word32 esi_410;
		edx = runtime.morestack(edx, gs, dwLoc04, dwArg00, out ebx_409, out esi_410);
	}
	Eq_4 eax_25 = *((word32) edx + 4);
	Eq_4 ecx_27 = *((word32) edx + 8);
	Eq_4 ebx_29 = *((word32) edx + 0x0C);
	Eq_4 edx_31 = *((word32) edx + 16);
	Eq_4 ebp_33 = *eax_25;
	Eq_4 esi_34 = *ecx_27;
	if (ebp_33 < esi_34)
	{
		int32 edi_38 = **edx_31;
		if (ebx_29 *s edi_38 + ebp_33 >u esi_34)
		{
			word32 esi_149 = esi_34 + edi_38 *s (ebx_29 - 0x01);
			if (g_t81576F0 == 0x00)
				*ecx_27 = esi_149;
			else
				runtime.writebarrierptr(ecx_27, esi_149);
			Eq_4 ebx_178 = (word32) *eax_25 + *(*edx_31) *s (ebx_29 - 0x01);
			if (g_t81576F0 == 0x00)
				*eax_25 = ebx_178;
			else
				runtime.writebarrierptr(eax_25, ebx_178);
			word32 ebx_197 = 0x01;
			while (true)
			{
				word32 edi_412;
				word128 xmm1_414;
				word128 xmm0_413;
				word32 esi_411;
				runtime.typedmemmove(*edx_31, *ecx_27, *eax_25, out esi_411, out edi_412, out xmm0_413, out xmm1_414);
				if (ebx_197 + 0x00 >= ebx_29)
					break;
				word32 dwLoc18_375 = ebx_197 + 0x01;
				Eq_4 edi_248 = *ecx_27 - *(*edx_31);
				if (g_t81576F0 == 0x00)
					*ecx_27 = edi_248;
				else
					runtime.writebarrierptr(ecx_27, edi_248);
				Eq_4 ecx_276 = *eax_25 - *(*edx_31);
				if (g_t81576F0 == 0x00)
					*eax_25 = ecx_276;
				else
					runtime.writebarrierptr(eax_25, ecx_276);
				ebx_197 = dwLoc18_375;
			}
			return;
		}
	}
	word32 ebx_144 = 0x01;
	while (true)
	{
		word128 xmm1_418;
		word32 esi_415;
		word128 xmm0_417;
		word32 edi_416;
		runtime.typedmemmove(*edx_31, *ecx_27, *eax_25, out esi_415, out edi_416, out xmm0_417, out xmm1_418);
		if (ebx_144 + 0x00 >= ebx_29)
			break;
		word32 dwLoc14_349 = ebx_144 + 0x01;
		word32 ebx_91 = Mem84[Mem84[edx_31 + 0x00:word32] + 0x00:word32] + Mem84[ecx_27 + 0x00:word32];
		if (g_t81576F0 == 0x00)
			*ecx_27 = ebx_91;
		else
			runtime.writebarrierptr(ecx_27, ebx_91);
		word32 ecx_118 = Mem111[eax_25 + 0x00:word32] + Mem111[Mem111[edx_31 + 0x00:word32] + 0x00:word32];
		if (g_t81576F0 == 0x00)
			*eax_25 = ecx_118;
		else
			runtime.writebarrierptr(eax_25, ecx_118);
		ebx_144 = dwLoc14_349;
	}
}

// 0808C120: void runtime.freemcache.func1(Register Eq_4 edx, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg00)
void runtime.freemcache.func1(Eq_4 edx, struct Eq_2 * gs, Eq_4 dwArg00)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
	{
		word32 esi_114;
		word32 ebx_113;
		edx = runtime.morestack(edx, gs, dwLoc04, dwArg00, out ebx_113, out esi_114);
	}
	Eq_4 eax_26 = *((word32) edx + 4);
	runtime.(*mcache).releaseAll(gs, eax_26);
	word32 esi_115;
	word32 edi_116;
	runtime.lock(runtime.stackcache_clear(gs, eax_26), gs, 0x081488E0, out esi_115, out edi_116);
	runtime.purgecachedstats(gs, eax_26);
	g_dw814B57C -= g_dw814B564;
	*eax_26 = g_t814B570;
	g_t814B570 = eax_26;
	word32 edx_117;
	word32 ebx_118;
	runtime.unlock(gs, 0x081488E0, out edx_117, out ebx_118);
}

// 0808C1C0: void runtime.SetFinalizer.func1(Register Eq_4 edx, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg00)
void runtime.SetFinalizer.func1(Eq_4 edx, struct Eq_2 * gs, Eq_4 dwArg00)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
	{
		word32 esi_64;
		word32 ebx_63;
		edx = runtime.morestack(edx, gs, dwLoc04, dwArg00, out ebx_63, out esi_64);
	}
	runtime.removefinalizer(gs, *((word32) *((word32) edx + 4) + 4));
}

// 0808C1F0: void runtime.SetFinalizer.func2(Register Eq_4 edx, Register Eq_4 esi, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg00)
void runtime.SetFinalizer.func2(Eq_4 edx, Eq_4 esi, struct Eq_2 * gs, Eq_4 dwArg00)
{
	while (true)
	{
		byte bLoc04_90 = (byte) dwLoc04;
		if (fp > *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
			break;
		word32 ebx_95;
		edx = runtime.morestack(edx, gs, dwLoc04, dwArg00, out ebx_95, out esi);
	}
	runtime.addfinalizer(esi, gs, *((word32) *((word32) edx + 4) + 4), *((word32) *((word32) edx + 8) + 4), *((word32) edx + 0x0C), *((word32) edx + 16), *((word32) edx + 20));
	if (bLoc04_90 != 0x00)
		return;
	runtime.throw(gs);
}

// 0808C260: void runtime.(*gcControllerState).findRunnableGCWorker.func1(Register word24 ebx_24_8, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg00, Stack (ptr32 Eq_21784) dwArg04)
// Called from:
//      runtime.(*gcControllerState).findRunnableGCWorker
void runtime.(*gcControllerState).findRunnableGCWorker.func1(word24 ebx_24_8, struct Eq_2 * gs, Eq_4 dwArg00, struct Eq_21784 * dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	int32 ecx_18 = dwArg04->dw0004;
	up32 edx_19 = dwArg04->dw0000;
	if (((int8) (edx_19 > 0x00) & (int8) (ecx_18 == 0x00) | (int8) (ecx_18 > 0x00)) == 0x00)
		return;
	if (((int8) Test(UGE,false) & (int8) (dwLoc08 == 0x00) | (int8) (dwLoc08 > 0x00)) != 0x00)
		return;
	word32 ebx_143;
	word32 ebp_144;
	runtime/internal/atomic.Xaddint64(dwArg00, 0x01, 0x00, out ebx_143, out ebp_144);
}

// 0808C310: void runtime.gcStart.func1(Register (ptr32 Eq_2) gs, Register Eq_662 xmm2)
void runtime.gcStart.func1(struct Eq_2 * gs, Eq_662 xmm2)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	word128 xmm2_41;
	word128 xmm0_40;
	runtime.finishsweep_m(gs, xmm2, out xmm0_40, out xmm2_41);
}

// 0808C330: void runtime.gcMarkDone.func1.1(Register ui24 ebx_24_8, Register Eq_4 ebp, Register (ptr32 Eq_2) gs, Stack word32 dwArg04)
void runtime.gcMarkDone.func1.1(ui24 ebx_24_8, Eq_4 ebp, struct Eq_2 * gs, word32 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.(*gcWork).dispose(ebx_24_8, ebp, gs, dwLoc08, dwArg04 + 0x0950);
}

// 0808C370: void runtime.gcMarkDone.func1(Register Eq_4 esi, Register (ptr32 Eq_2) gs)
void runtime.gcMarkDone.func1(Eq_4 esi, struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.forEachP(esi, gs, 0x080E7C00);
}

// 0808C3A0: void runtime.gcMarkTermination.func1(Register Eq_4 edx, Register Eq_4 esi, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg00)
void runtime.gcMarkTermination.func1(Eq_4 edx, Eq_4 esi, struct Eq_2 * gs, Eq_4 dwArg00)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
	{
		word32 ebx_60;
		edx = runtime.morestack(edx, gs, dwLoc04, dwArg00, out ebx_60, out esi);
	}
	Eq_4 eax_26 = *((word32) edx + 4);
	runtime.gcMark(esi, gs, *eax_26, *((word32) eax_26 + 4));
}

// 0808C3E0: void runtime.gcMarkTermination.func2(Register Eq_4 edx, Register Eq_4 esi, Register (ptr32 Eq_2) gs, Register Eq_662 xmm0, Register Eq_662 xmm2, Stack Eq_4 dwArg00)
void runtime.gcMarkTermination.func2(Eq_4 edx, Eq_4 esi, struct Eq_2 * gs, Eq_662 xmm0, Eq_662 xmm2, Eq_4 dwArg00)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
	{
		word32 ebx_262;
		edx = runtime.morestack(edx, gs, dwLoc04, dwArg00, out ebx_262, out esi);
	}
	Eq_4 eax_25 = *((word32) edx + 4);
	Eq_4 ecx_27 = g_t81455EC;
	g_t81456B4 = g_t81455E8;
	g_t81456B8 = ecx_27;
	if (g_dw815772C > 0x00)
	{
		runtime.gcResetMarkState(gs);
		runtime.initCheckmarks(esi, gs);
		Eq_4 ecx_54 = *((word32) eax_25 + 4);
		esi = runtime.gcMark(esi, gs, *eax_25, ecx_54);
		runtime.clearCheckmarks(esi, gs);
		dwLoc08 = ecx_54;
	}
	runtime.setGCPhase(0x00);
	Eq_4 eax_85 = g_t814563C;
	Eq_662 xmm2_105 = runtime.gcSweep(esi, gs, xmm0, xmm2, eax_85);
	if (g_dw8157740 > 0x01)
	{
		runtime.nanotime();
		*eax_25 = eax_85;
		*((word32) eax_25 + 4) = dwLoc08;
		runtime.gcResetMarkState(gs);
		Eq_662 xmm0_149;
		Eq_662 xmm2_151;
		Eq_4 esi_147 = runtime.finishsweep_m(gs, xmm2_105, out xmm0_149, out xmm2_151);
		runtime.setGCPhase(0x02);
		Eq_4 esi_179 = runtime.gcMark(esi_147, gs, *eax_25, *((word32) eax_25 + 4));
		runtime.setGCPhase(0x00);
		runtime.gcSweep(esi_179, gs, xmm0_149, xmm2_151, g_t814563C);
	}
}

// 0808C4E0: void runtime.gcBgMarkWorker.func1(Register (ptr32 Eq_80825) gs, Stack Eq_4 dwArg04, Stack (ptr32 Eq_80827) dwArg08)
void runtime.gcBgMarkWorker.func1(struct Eq_80825 * gs, Eq_4 dwArg04, struct Eq_80827 * dwArg08)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	struct Eq_80840 * ecx_18 = dwArg08->ptr0000;
	struct Eq_80833 * edx_20 = gs->ptr0000->ptrFFFFFFFC;
	word32 ebx_21 = ecx_18->dw0078;
	ecx_18->dw0078 = ebx_21 - 0x01;
	if (ebx_21 == 0x01 && edx_20->b006C != 0x00)
		edx_20->ptr0008 = ~0x0521;
	word32 ecx_34 = dwArg08->dw0004;
	if (ecx_34 == 0x00)
		return;
	dwArg08->dw0004 = 0x00;
	runtime.(*guintptr).cas(ecx_34 + 0x0948, 0x00, dwArg04);
	if (bLoc04 != 0x00)
		;
}

// 0808C580: void runtime.gcBgMarkWorker.func2(Register Eq_4 edx, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg00)
void runtime.gcBgMarkWorker.func2(Eq_4 edx, struct Eq_2 * gs, Eq_4 dwArg00)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
	{
		word32 esi_272;
		word32 ebx_271;
		edx = runtime.morestack(edx, gs, dwLoc04, dwArg00, out ebx_271, out esi_272);
	}
	Eq_4 eax_26 = *((word32) edx + 4);
	Eq_4 ecx_28 = *((word32) edx + 8);
	runtime.casgstatus(eax_26, 0x02, 0x04);
	Eq_4 ecx_46 = *((word32) ecx_28 + 0x094C);
	if (ecx_46 == 0x00)
	{
		Eq_4 esi_105;
		word32 ebp_273;
		runtime.gcDrain(gs, (word32) ecx_28 + 0x0950, 0x05, out ebp_273, out esi_105);
		if (*((word32) eax_26 + 0x006C) != 0x00)
		{
			word32 esi_276;
			word32 edi_277;
			runtime.lock(esi_105, gs, 135549936, out esi_276, out edi_277);
			while (true)
			{
				runtime.runqget(gs, ecx_28);
				*(word32 *) 0x6D = 0x00;
				Eq_4 ecx_197 = g_t814541C;
				if (ecx_197 != 0x00)
					((word32) ecx_197 + 0x0068)->u0 = 0x05;
				else
					g_t8145418.u0 = 0x05;
				g_t814541C.u0 = 0x05;
				g_t8145420 = (word32) g_t8145420 + 1;
			}
		}
		word32 esi_275;
		word32 ebp_274;
		runtime.gcDrain(gs, (word32) ecx_28 + 0x0950, 0x06, out ebp_274, out esi_275);
	}
	else if (ecx_46 != 0x01)
	{
		if (ecx_46 != 0x02)
			runtime.throw(gs);
		word32 esi_283;
		word32 ebp_282;
		runtime.gcDrain(gs, (word32) ecx_28 + 0x0950, 0x0D, out ebp_282, out esi_283);
	}
	else
	{
		word32 ebp_280;
		word32 esi_281;
		runtime.gcDrain(gs, (word32) ecx_28 + 0x0950, 0x05, out ebp_280, out esi_281);
	}
	runtime.casgstatus(eax_26, 0x04, 0x02);
}

// 0808C710: void runtime.gcMarkRootPrepare.func1(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.gcMarkRootPrepare
void runtime.gcMarkRootPrepare.func1(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
}

// 0808C740: void runtime.markroot.func1(Register Eq_4 edx, Register (ptr32 Eq_2) gs)
void runtime.markroot.func1(Eq_4 edx, struct Eq_2 * gs)
{
	Eq_4 esp_19 = fp;
	while (esp_19 <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
	{
		word32 ebx_199;
		word32 esi_200;
		edx = runtime.morestack(edx, gs, *((word32) esp_19 - 4), *esp_19, out ebx_199, out esi_200);
		esp_19.u0 = <invalid>;
	}
	int8 bl_46;
	struct Eq_81047 * esp_24 = esp_19 - 0x1C;
	Eq_4 eax_27 = *((word32) gs->ptr0000->tFFFFFFFC + 24);
	Eq_4 ecx_101 = *((word32) edx + 4);
	esp_24->t0014 = ecx_101;
	esp_24->t0018 = *((word32) edx + 8);
	Eq_4 eax_32 = *((word32) eax_27 + 84);
	esp_24->t0010 = eax_32;
	if (ecx_101 != eax_32)
		bl_46 = 0x00;
	else
	{
		esp_24->t0000 = eax_32;
		runtime.readgstatus(esp_24->t0000);
		Eq_4 esp_38 = <invalid>;
		bl_46 = (int8) (*((word32) esp_38 + 4) == 0x02);
		eax_32 = *((word32) esp_38 + 16);
		ecx_101 = *((word32) esp_38 + 20);
	}
	if (bl_46 != 0x00)
	{
		runtime.casgstatus(eax_32, 0x02, 0x04);
		((word32) dwLoc0C + 100)->u0 = 0x17;
		if (g_t81576F0 == 0x00)
			((word32) dwLoc0C + 96)->u0 = 0x080E390A;
		else
			runtime.writebarrierptr((word32) dwLoc0C + 96, 0x080E390A);
		ecx_101 = dwLoc08;
	}
	runtime.scang(gs, ecx_101);
	if (bl_46 != 0x00)
		runtime.casgstatus(dwLoc0C, 0x04, 0x02);
}

// 0808C850: void runtime.gcAssistAlloc.func1(Register Eq_4 edx, Register (ptr32 Eq_2) gs)
void runtime.gcAssistAlloc.func1(Eq_4 edx, struct Eq_2 * gs)
{
	Eq_4 esp_19 = fp;
	while (esp_19 <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
	{
		word32 ebx_57;
		word32 esi_58;
		edx = runtime.morestack(edx, gs, *((word32) esp_19 - 4), *esp_19, out ebx_57, out esi_58);
		esp_19.u0 = <invalid>;
	}
	struct Eq_81161 * esp_24 = esp_19 - 0x0C;
	Eq_4 ecx_27 = *((word32) edx + 0x0C);
	Eq_4 edx_28 = *((word32) edx + 8);
	esp_24->t0000 = *((word32) edx + 4);
	esp_24->t0004 = edx_28;
	esp_24->t0008 = ecx_27;
	runtime.gcAssistAlloc1(gs, esp_24->dwFFFFFFFC, esp_24->t0000, esp_24->t0004, esp_24->t0008, esp_24->dw000C);
}

// 0808C890: void runtime.scanstack.func1(Register Eq_4 edx, Register Eq_4 esi, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg00, Stack (ptr32 Eq_28557) dwArg04)
void runtime.scanstack.func1(Eq_4 edx, Eq_4 esi, struct Eq_2 * gs, Eq_4 dwArg00, struct Eq_28557 * dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
	{
		word32 ebx_66;
		edx = runtime.morestack(edx, gs, dwLoc04, dwArg00, out ebx_66, out esi);
	}
	runtime.scanframeworker(esi, gs, dwArg04, *((word32) edx + 8));
}

// 0808C8D0: void runtime.gosweepone.func1(Register Eq_4 edx, Register (ptr32 Eq_2) gs, Register Eq_662 xmm2)
void runtime.gosweepone.func1(Eq_4 edx, struct Eq_2 * gs, Eq_662 xmm2)
{
	Eq_4 esp_19 = fp;
	while (esp_19 <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
	{
		word32 esi_68;
		word32 ebx_67;
		edx = runtime.morestack(edx, gs, *((word32) esp_19 - 4), *esp_19, out ebx_67, out esi_68);
		esp_19.u0 = <invalid>;
	}
	struct Eq_81255 * esp_24 = esp_19 - 0x08;
	esp_24->t0004 = *((word32) edx + 4);
	word128 xmm0_69;
	word128 xmm2_70;
	runtime.sweepone(gs, xmm2, esp_24->ptrFFFFFFFC, out xmm0_69, out xmm2_70);
	*dwLoc04 = dwLoc08;
}

// 0808C910: void runtime.getempty.func1(Register Eq_4 edx, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg00)
void runtime.getempty.func1(Eq_4 edx, struct Eq_2 * gs, Eq_4 dwArg00)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
	{
		word32 esi_72;
		word32 ebx_71;
		edx = runtime.morestack(edx, gs, dwLoc04, dwArg00, out ebx_71, out esi_72);
	}
	Eq_4 eax_26 = *((word32) edx + 4);
	runtime.(*mheap).allocManual(gs);
	*eax_26 = dwLoc08;
}

// 0808C970: void runtime.freeSomeWbufs.func1(Register Eq_4 edx, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg00)
void runtime.freeSomeWbufs.func1(Eq_4 edx, struct Eq_2 * gs, Eq_4 dwArg00)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
	{
		word32 ebx_153;
		word32 esi_154;
		edx = runtime.morestack(edx, gs, dwLoc04, dwArg00, out ebx_153, out esi_154);
	}
	word32 ecx_152 = (word32) *((word32) edx + 4);
	byte cl_29 = (byte) ecx_152;
	Eq_4 eax_31 = *((word32) *((word32) gs->ptr0000->tFFFFFFFC + 24) + 84);
	int32 edx_33 = 0x00;
	while (true)
	{
		byte cl_39 = (byte) ecx_152;
		if (edx_33 >= 0x40 || cl_39 != 0x00 && *((word32) eax_31 + 0x006C) != 0x00)
			break;
		Eq_4 ebx_51 = g_t81455D4;
		if (ebx_51 == 0x00)
			return;
		runtime.(*mSpanList).remove(gs, 135550420, ebx_51);
		runtime.(*mheap).freeManual(gs, ebx_51, &g_t8158218);
		++edx_33;
		ecx_152 = (word32) cl_29;
	}
}

// 0808CA20: void runtime.(*mheap).alloc.func1(Register Eq_4 edx, Register Eq_4 esi, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg00)
void runtime.(*mheap).alloc.func1(Eq_4 edx, Eq_4 esi, struct Eq_2 * gs, Eq_4 dwArg00)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
	{
		word32 ebx_90;
		edx = runtime.morestack(edx, gs, dwLoc04, dwArg00, out ebx_90, out esi);
	}
	Eq_4 eax_26 = *((word32) edx + 4);
	runtime.(*mheap).alloc_m(esi, gs, *((word32) edx + 8), *((word32) edx + 0x0C), *((word32) edx + 16), *((word32) edx + 0x0011));
	*eax_26 = dwLoc08;
}

// 0808CA80: void runtime.(*mheap).freeSpan.func1(Register Eq_4 edx, Register Eq_4 esi, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg00)
void runtime.(*mheap).freeSpan.func1(Eq_4 edx, Eq_4 esi, struct Eq_2 * gs, Eq_4 dwArg00)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
	{
		word32 ebx_187;
		edx = runtime.morestack(edx, gs, dwLoc04, dwArg00, out ebx_187, out esi);
	}
	Eq_4 eax_25 = *((word32) edx + 4);
	Eq_4 ecx_30 = *((word32) edx + 8);
	Eq_4 edx_32 = *((word32) edx + 0x0C);
	Eq_4 ebx_36 = *((word32) gs->ptr0000->tFFFFFFFC + 24);
	word32 esi_188;
	word32 edi_189;
	Eq_4 ebp_45 = runtime.lock(esi, gs, eax_25, out esi_188, out edi_189);
	uint32 edx_56 = (word32) *((word32) *((word32) ebx_36 + 0x00B8) + 4) + g_dw81597B8;
	uint32 ecx_58 = g_dw81597BC;
	g_dw81597B8 = edx_56;
	g_dw81597BC = (uint32) ((bool) (edx_56 < 0x00) + ecx_58);
	((word32) *((word32) ebx_36 + 0x00B8) + 4)->u0 = 0x00;
	up32 edx_68 = (word32) *((word32) *((word32) ebx_36 + 0x00B8) + 16) + g_dw8159798;
	word32 ecx_70 = g_dw815979C;
	g_dw8159798 = edx_68;
	g_dw815979C = (word32) ((bool) (edx_68 < 0x00) + ecx_70);
	((word32) *((word32) ebx_36 + 0x00B8) + 16)->u0 = 0x00;
	if (edx_32 != 0x00)
	{
		up32 eax_81 = g_dw81581D8;
		word32 ecx_84 = g_dw81581DC;
		g_dw81581D8 = eax_81 + ~0x00;
		g_dw81581DC = (word32) ((bool) (eax_81 < ~0x00) + (ecx_84 + ~0x00));
	}
	if (runtime.gcBlackenEnabled != 0x00)
		runtime.(*gcControllerState).revise(ebp_45, gs, &g_dw8157860);
	runtime.(*mheap).freeSpanLocked(gs, eax_25, ecx_30, 0x01, 0x01, 0x00, 0x00);
	word32 ebx_191;
	word32 edx_190;
	runtime.unlock(gs, eax_25, out edx_190, out ebx_191);
}

// 0808CBC0: void runtime.mProf_Malloc.func1(Register Eq_4 edx, Register Eq_4 esi, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg00)
void runtime.mProf_Malloc.func1(Eq_4 edx, Eq_4 esi, struct Eq_2 * gs, Eq_4 dwArg00)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
	{
		word32 ebx_67;
		edx = runtime.morestack(edx, gs, dwLoc04, dwArg00, out ebx_67, out esi);
	}
	runtime.setprofilebucket(esi, gs, *((word32) edx + 4), *((word32) edx + 8));
}

// 0808CC00: void runtime.tracealloc.func1(Register Eq_4 edx, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg00)
void runtime.tracealloc.func1(Eq_4 edx, struct Eq_2 * gs, Eq_4 dwArg00)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
	{
		word32 esi_66;
		word32 ebx_65;
		edx = runtime.morestack(edx, gs, dwLoc04, dwArg00, out ebx_65, out esi_66);
	}
	runtime.traceback(gs);
}

// 0808CC50: void runtime.tracefree.func1(Register Eq_4 edx, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg00)
void runtime.tracefree.func1(Eq_4 edx, struct Eq_2 * gs, Eq_4 dwArg00)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
	{
		word32 esi_66;
		word32 ebx_65;
		edx = runtime.morestack(edx, gs, dwLoc04, dwArg00, out ebx_65, out esi_66);
	}
	runtime.traceback(gs);
}

// 0808CCA0: void runtime.futexwakeup.func1(Register Eq_4 edx, Register word32 ebx, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg00)
void runtime.futexwakeup.func1(Eq_4 edx, word32 ebx, struct Eq_2 * gs, Eq_4 dwArg00)
{
	word32 ebx_132 = ebx;
	while (true)
	{
		word24 ebx_24_8_69 = SLICE(ebx_132, word24, 8);
		if (fp > *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
			break;
		word32 esi_135;
		edx = runtime.morestack(edx, gs, dwLoc04, dwArg00, out ebx_132, out esi_135);
	}
	Eq_4 ecx_28 = *((word32) edx + 8);
	runtime.printlock(gs);
	runtime.printstring(gs);
	runtime.printpointer(gs);
	runtime.printstring(gs);
	runtime.printint(ebx_24_8_69, gs, SEQ(ecx_28 >> 0x1F, ecx_28));
	runtime.printstring(gs);
	runtime.printunlock(gs);
}

// 0808CD40: void runtime.newdefer.func1(Register Eq_4 edx, Register Eq_4 esi, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg00)
void runtime.newdefer.func1(Eq_4 edx, Eq_4 esi, struct Eq_2 * gs, Eq_4 dwArg00)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
	{
		word32 ebx_358;
		edx = runtime.morestack(edx, gs, dwLoc04, dwArg00, out ebx_358, out esi);
	}
	Eq_4 eax_26 = *((word32) edx + 4);
	Eq_4 ecx_28 = *((word32) edx + 8);
	word32 esi_359;
	word32 edi_360;
	runtime.lock(esi, gs, 135550012, out esi_359, out edi_360);
	while (ecx_28 < 0x05)
	{
		Eq_4 ebx_55 = *((word32) eax_26 + (ecx_28 * 0x0C + 0x0044));
		Eq_4 esi_57 = (word32) eax_26 + 60 + ecx_28 * 0x0C;
		if ((eax_26 + 0x40)[ecx_28 * 0x0C] >= ((ebx_55 >> 0x1F) >>u 0x1F) + ebx_55 >> 0x01)
		{
l0808CEEF:
			word32 ebx_362;
			word32 edx_361;
			runtime.unlock(gs, 135550012, out edx_361, out ebx_362);
			return;
		}
		Eq_4 ebp_66 = g_a8145440[ecx_28 * 0x04];
		Eq_4 edi_67 = ecx_28 * 0x04 + 0x08145440;
		if (ebp_66 == 0x00)
			goto l0808CEEF;
		Eq_4 edi_91 = *((word32) ebp_66 + 24);
		if (g_t81576F0 == 0x00)
		{
			g_a8145440[ecx_28 * 0x04] = (word32) edi_91;
			((word32) ebp_66 + 24)->u0 = 0x00;
		}
		else
		{
			runtime.writebarrierptr(edi_67, edi_91);
			runtime.writebarrierptr((word32) ebp_66 + 24, 0x00);
		}
		Eq_4 ebx_128 = *((word32) eax_26 + (ecx_28 * 0x0C + 0x0044));
		Eq_4 esi_129 = *((word32) eax_26 + (ecx_28 * 0x0C + 64));
		Eq_4 edi_130 = *((word32) eax_26 + (ecx_28 * 0x0C + 60));
		if ((word32) esi_129 + 1 > ebx_128)
		{
			word128 xmm1_365;
			word32 esi_363;
			word128 xmm0_364;
			runtime.growslice(gs, 135033152, edi_130, esi_129, ebx_128, (word32) esi_129 + 1, out esi_363, out xmm0_364, out xmm1_365);
			*((word32) eax_26 + (ecx_28 * 0x0C + 0x0044)) = dwLoc28;
			if (g_t81576F0 == 0x00)
				*((word32) eax_26 + (ecx_28 * 0x0C + 60)) = dwLoc30;
			else
				runtime.writebarrierptr(esi_57, dwLoc30);
			esi_129 = dwLoc2C;
			edi_130 = dwLoc30;
		}
		*((word32) eax_26 + (ecx_28 * 0x0C + 64)) = (word32) esi_129 + 1;
		Eq_4 edx_206 = (word32) edi_130 + esi_129 * 0x04;
		if (g_t81576F0 == 0x00)
			*((word32) edi_130 + esi_129 * 0x04) = ebp_66;
		else
			runtime.writebarrierptr(edx_206, ebp_66);
	}
	runtime.panicindex(gs);
}

// 0808CF20: void runtime.newdefer.func2(Register Eq_4 edx, Register Eq_4 ebx, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg00)
void runtime.newdefer.func2(Eq_4 edx, Eq_4 ebx, struct Eq_2 * gs, Eq_4 dwArg00)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
	{
		word32 esi_146;
		edx = runtime.morestack(edx, gs, dwLoc04, dwArg00, out ebx, out esi_146);
	}
	Eq_4 eax_29;
	Eq_4 eax_25 = *((word32) edx + 4);
	Eq_4 ecx_26 = *((word32) edx + 8);
	if (eax_25 <= 0x04)
		eax_29.u0 = 0x20;
	else
		eax_29 = (word32) eax_25 + 28;
	if (eax_29 >= 0x8000)
	{
		if ((byte) eax_29.u0 + 0x00002000 >= eax_29)
			eax_29 = (word32) eax_29 + 0x00001FFF & ~0x1FFF;
		goto l0808CF91;
	}
	if (eax_29 > 1016)
	{
		uint32 eax_47 = (byte) eax_29.u0 - 897;
		if (eax_47 >> 0x07 < 0xF9)
		{
			uint32 eax_52 = (word32) (eax_47 >> 0x07)->b81396E0;
			if (eax_52 < 0x43)
			{
				eax_29 = (word32) g_a8138820[eax_52 * 0x02];
l0808CF91:
				word32 ebx_147;
				word32 edi_149;
				word32 esi_148;
				runtime.mallocgc(ebx, gs, eax_29, runtime.deferType, 0x01, out ebx_147, out esi_148, out edi_149);
				if (g_t81576F0 == 0x00)
					*ecx_26 = dwLoc08;
				else
					runtime.writebarrierptr(ecx_26, dwLoc08);
				return;
			}
		}
		runtime.panicindex(gs);
	}
	else
	{
		uint32 eax_59 = (byte) eax_29.u0 + 7;
		if (eax_59 >> 0x03 < 0x81)
		{
			uint32 eax_64 = (word32) (eax_59 >> 0x03)->b8138640;
			if (eax_64 < 0x43)
			{
				eax_29 = (word32) g_a8138820[eax_64 * 0x02];
				goto l0808CF91;
			}
		}
		runtime.panicindex(gs);
	}
}

// 0808D040: void runtime.freedefer.func1(Register Eq_4 edx, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg00)
void runtime.freedefer.func1(Eq_4 edx, struct Eq_2 * gs, Eq_4 dwArg00)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
	{
		word32 ebx_243;
		word32 esi_244;
		edx = runtime.morestack(edx, gs, dwLoc04, dwArg00, out ebx_243, out esi_244);
	}
	Eq_4 eax_25 = *((word32) edx + 4);
	Eq_4 ecx_27 = *((word32) edx + 8);
	Eq_4 edx_202 = 0x00;
	Eq_4 ebx_162 = 0x00;
	eax_148 = eax_25;
	while (true)
	{
		Eq_4 eax_148;
		if (ecx_27 >= 0x05)
			break;
		Eq_4 ecx_49 = *((word32) eax_148 + (ecx_27 * 0x0C + 0x0044));
		Eq_4 esi_47 = *((word32) eax_148 + (ecx_27 * 0x0C + 60));
		Eq_4 edi_48 = *((word32) eax_148 + (ecx_27 * 0x0C + 64));
		if (edi_48 <= ((ecx_49 >> 0x1F) >>u 0x1F) + ecx_49 >> 0x01)
		{
			word32 edi_246;
			word32 esi_245;
			runtime.lock(esi_47, gs, 135550012, out esi_245, out edi_246);
			Eq_4 esi_78 = g_a8145440[ecx_27 * 0x04];
			Eq_4 edi_79 = ecx_27 * 0x04 + 0x08145440;
			if (g_t81576F0 == 0x00)
			{
				*((word32) edx_202 + 24) = esi_78;
				g_a8145440[ecx_27 * 0x04] = (word32) ebx_162;
			}
			else
			{
				runtime.writebarrierptr((word32) edx_202 + 24, esi_78);
				runtime.writebarrierptr(edi_79, ebx_162);
			}
			word32 edx_247;
			word32 ebx_248;
			runtime.unlock(gs, 135550012, out edx_247, out ebx_248);
			return;
		}
		if (edi_48 - 0x01 >= edi_48)
			runtime.panicindex(gs);
		Eq_4 edx_127 = (esi_47 - 0x04)[edi_48];
		Eq_4 edx_129 = esi_47 - 0x04 + edi_48 * 0x04;
		if (g_t81576F0 == 0x00)
			(esi_47 - 0x04)[edi_48] = 0x00;
		else
		{
			runtime.writebarrierptr(edx_129, 0x00);
			eax_148 = eax_25;
		}
		if (edi_48 - 0x01 > *((word32) eax_148 + (ecx_27 * 0x0C + 0x0044)))
			runtime.panicslice(gs);
		*((word32) eax_148 + (ecx_27 * 0x0C + 64)) = edi_48 - 0x01;
		if (ebx_162 != 0x00)
		{
			if (g_t81576F0 == 0x00)
				*((word32) edx_202 + 24) = edx_127;
			else
			{
				runtime.writebarrierptr((word32) edx_202 + 24, edx_127);
				eax_148 = eax_25;
			}
		}
		else
			ebx_162 = edx_127;
		edx_202 = edx_127;
	}
	runtime.panicindex(gs);
}

// 0808D200: void runtime.preprintpanics.func1(Register (ptr32 Eq_2) gs)
void runtime.preprintpanics.func1(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.gorecover(gs, (word32) fp + 4);
	if (dwLoc08 == 0x00)
		return;
	runtime.throw(gs);
}

// 0808D250: void runtime.dopanic.func1(Register Eq_4 edx, Register Eq_4 esi, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg00)
void runtime.dopanic.func1(Eq_4 edx, Eq_4 esi, struct Eq_2 * gs, Eq_4 dwArg00)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
	{
		word32 ebx_62;
		edx = runtime.morestack(edx, gs, dwLoc04, dwArg00, out ebx_62, out esi);
	}
	runtime.dopanic_m(esi, gs, *((word32) edx + 4));
}

// 0808D290: void runtime.main.func1(Register (ptr32 Eq_2) gs)
void runtime.main.func1(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.newm(gs, 0x00);
}

// 0808D2D0: void runtime.main.func2(Register (ptr32 Eq_2) gs, Stack (ptr32 byte) dwArg04)
void runtime.main.func2(struct Eq_2 * gs, byte * dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (*dwArg04 != 0x00)
		runtime.unlockOSThread(gs);
}

// 0808D300: void runtime.goready.func1(Register Eq_4 edx, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg00)
void runtime.goready.func1(Eq_4 edx, struct Eq_2 * gs, Eq_4 dwArg00)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
	{
		word32 esi_63;
		word32 ebx_62;
		edx = runtime.morestack(edx, gs, dwLoc04, dwArg00, out ebx_62, out esi_63);
	}
	runtime.ready(gs, *((word32) edx + 4));
}

// 0808D340: void runtime.casgstatus.func1(Register Eq_4 edx, Register Eq_4 esi, Register (ptr32 Eq_2) gs)
void runtime.casgstatus.func1(Eq_4 edx, Eq_4 esi, struct Eq_2 * gs)
{
	Eq_4 esp_19 = fp;
	while (esp_19 <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
	{
		word32 ebx_115;
		edx = runtime.morestack(edx, gs, *((word32) esp_19 - 4), *esp_19, out ebx_115, out esi);
		esp_19.u0 = <invalid>;
	}
	struct Eq_82258 * esp_24 = esp_19 - 0x10;
	esp_24->t0008 = *((word32) edx + 4);
	esp_24->t000C = *((word32) edx + 8);
	runtime.printlock(gs);
	esp_24->t0000.u0 = 0x080E4990;
	esp_24->t0004.u0 = 0x1C;
	runtime.printstring(gs);
	esp_24->t0000 = esp_24->t0008;
	esp_24->t0004.u0 = 0x00;
	Eq_4 esi_57;
	runtime.printhex(esi, gs, esp_24->t0000, esp_24->t0004, out esi_57);
	esp_24->t0000.u0 = 0x080E13A5;
	esp_24->t0004.u0 = 0x08;
	runtime.printstring(gs);
	esp_24->t0000 = esp_24->t000C;
	esp_24->t0004.u0 = 0x00;
	word32 esi_116;
	runtime.printhex(esi_57, gs, esp_24->t0000, esp_24->t0004, out esi_116);
	esp_24->t0000.u0 = 0x080E0D9C;
	esp_24->t0004.u0 = 0x01;
	runtime.printstring(gs);
	runtime.printunlock(gs);
	esp_24->t0000.u0 = 135155921;
	esp_24->t0004.u0 = 0x1F;
	runtime.throw(gs);
}

// 0808D400: void runtime.casgstatus.func2(Register (ptr32 Eq_2) gs)
void runtime.casgstatus.func2(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.throw(gs);
}

// 0808D440: void runtime.reentersyscall.func1(Register Eq_4 edx, Register Eq_4 esi, Register (ptr32 Eq_2) gs)
void runtime.reentersyscall.func1(Eq_4 edx, Eq_4 esi, struct Eq_2 * gs)
{
	Eq_4 esp_19 = fp;
	while (esp_19 <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
	{
		word32 ebx_142;
		edx = runtime.morestack(edx, gs, *((word32) esp_19 - 4), *esp_19, out ebx_142, out esi);
		esp_19.u0 = <invalid>;
	}
	Eq_4 eax_26 = *((word32) edx + 4);
	struct Eq_82401 * esp_24 = esp_19 - 0x14;
	esp_24->t0010 = *((word32) eax_26 + 56);
	esp_24->t000C = *eax_26;
	esp_24->t0008 = *((word32) eax_26 + 4);
	runtime.printlock(gs);
	esp_24->t0000.u0 = 0x080E40F8;
	esp_24->t0004.u0 = 0x1A;
	runtime.printstring(gs);
	esp_24->t0000 = esp_24->t0010;
	esp_24->t0004.u0 = 0x00;
	Eq_4 esi_60;
	runtime.printhex(esi, gs, esp_24->t0000, esp_24->t0004, out esi_60);
	esp_24->t0000.u0 = 135138731;
	esp_24->t0004.u0 = 0x02;
	runtime.printstring(gs);
	esp_24->t0000 = esp_24->t000C;
	esp_24->t0004.u0 = 0x00;
	Eq_4 esi_84;
	runtime.printhex(esi_60, gs, esp_24->t0000, esp_24->t0004, out esi_84);
	esp_24->t0000.u0 = 0x080E0D89;
	esp_24->t0004.u0 = 0x01;
	runtime.printstring(gs);
	esp_24->t0000 = esp_24->t0008;
	esp_24->t0004.u0 = 0x00;
	word32 esi_143;
	runtime.printhex(esi_84, gs, esp_24->t0000, esp_24->t0004, out esi_143);
	esp_24->t0000.u0 = 0x080E0E0F;
	esp_24->t0004.u0 = 0x02;
	runtime.printstring(gs);
	runtime.printunlock(gs);
	esp_24->t0000.u0 = 135142811;
	esp_24->t0004.u0 = 0x0C;
	runtime.throw(gs);
}

// 0808D530: void runtime.entersyscallblock.func1(Register Eq_4 edx, Register Eq_4 esi, Register (ptr32 Eq_2) gs)
void runtime.entersyscallblock.func1(Eq_4 edx, Eq_4 esi, struct Eq_2 * gs)
{
	Eq_4 esp_19 = fp;
	while (esp_19 <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
	{
		word32 ebx_194;
		edx = runtime.morestack(edx, gs, *((word32) esp_19 - 4), *esp_19, out ebx_194, out esi);
		esp_19.u0 = <invalid>;
	}
	struct Eq_82561 * esp_24 = esp_19 - 0x1C;
	Eq_4 eax_26 = *((word32) edx + 16);
	esp_24->t0010 = *((word32) edx + 4);
	esp_24->t000C = *((word32) edx + 8);
	esp_24->t0008 = *((word32) edx + 0x0C);
	esp_24->t0014 = *eax_26;
	esp_24->t0018 = *((word32) eax_26 + 4);
	runtime.printlock(gs);
	esp_24->t0000.u0 = 135155983;
	esp_24->t0004.u0 = 0x1F;
	runtime.printstring(gs);
	esp_24->t0000 = esp_24->t0010;
	esp_24->t0004.u0 = 0x00;
	Eq_4 esi_64;
	runtime.printhex(esi, gs, esp_24->t0000, esp_24->t0004, out esi_64);
	esp_24->t0000.u0 = 0x080E0D84;
	esp_24->t0004.u0 = 0x01;
	runtime.printstring(gs);
	esp_24->t0000 = esp_24->t000C;
	esp_24->t0004.u0 = 0x00;
	Eq_4 esi_88;
	runtime.printhex(esi_64, gs, esp_24->t0000, esp_24->t0004, out esi_88);
	esp_24->t0000.u0 = 0x080E0D84;
	esp_24->t0004.u0 = 0x01;
	runtime.printstring(gs);
	esp_24->t0000 = esp_24->t0008;
	esp_24->t0004.u0 = 0x00;
	Eq_4 esi_112;
	runtime.printhex(esi_88, gs, esp_24->t0000, esp_24->t0004, out esi_112);
	esp_24->t0000.u0 = 135138731;
	esp_24->t0004.u0 = 0x02;
	runtime.printstring(gs);
	esp_24->t0000 = esp_24->t0014;
	esp_24->t0004.u0 = 0x00;
	Eq_4 esi_136;
	runtime.printhex(esi_112, gs, esp_24->t0000, esp_24->t0004, out esi_136);
	esp_24->t0000.u0 = 0x080E0D89;
	esp_24->t0004.u0 = 0x01;
	runtime.printstring(gs);
	esp_24->t0000 = esp_24->t0018;
	esp_24->t0004.u0 = 0x00;
	word32 esi_195;
	runtime.printhex(esi_136, gs, esp_24->t0000, esp_24->t0004, out esi_195);
	esp_24->t0000.u0 = 0x080E0E0F;
	esp_24->t0004.u0 = 0x02;
	runtime.printstring(gs);
	runtime.printunlock(gs);
	esp_24->t0000.u0 = 135145434;
	esp_24->t0004.u0 = 0x11;
	runtime.throw(gs);
}

// 0808D690: void runtime.entersyscallblock.func2(Register Eq_4 edx, Register Eq_4 esi, Register (ptr32 Eq_2) gs)
void runtime.entersyscallblock.func2(Eq_4 edx, Eq_4 esi, struct Eq_2 * gs)
{
	Eq_4 esp_19 = fp;
	while (esp_19 <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
	{
		word32 ebx_194;
		edx = runtime.morestack(edx, gs, *((word32) esp_19 - 4), *esp_19, out ebx_194, out esi);
		esp_19.u0 = <invalid>;
	}
	struct Eq_82797 * esp_24 = esp_19 - 0x1C;
	Eq_4 eax_26 = *((word32) edx + 8);
	esp_24->t0008 = *((word32) edx + 4);
	esp_24->t0014 = *((word32) eax_26 + 28);
	esp_24->t0010 = *((word32) eax_26 + 56);
	esp_24->t000C = *eax_26;
	esp_24->t0018 = *((word32) eax_26 + 4);
	runtime.printlock(gs);
	esp_24->t0000.u0 = 135155983;
	esp_24->t0004.u0 = 0x1F;
	runtime.printstring(gs);
	esp_24->t0000 = esp_24->t0008;
	esp_24->t0004.u0 = 0x00;
	Eq_4 esi_64;
	runtime.printhex(esi, gs, esp_24->t0000, esp_24->t0004, out esi_64);
	esp_24->t0000.u0 = 0x080E0D84;
	esp_24->t0004.u0 = 0x01;
	runtime.printstring(gs);
	esp_24->t0000 = esp_24->t0014;
	esp_24->t0004.u0 = 0x00;
	Eq_4 esi_88;
	runtime.printhex(esi_64, gs, esp_24->t0000, esp_24->t0004, out esi_88);
	esp_24->t0000.u0 = 0x080E0D84;
	esp_24->t0004.u0 = 0x01;
	runtime.printstring(gs);
	esp_24->t0000 = esp_24->t0010;
	esp_24->t0004.u0 = 0x00;
	Eq_4 esi_112;
	runtime.printhex(esi_88, gs, esp_24->t0000, esp_24->t0004, out esi_112);
	esp_24->t0000.u0 = 135138731;
	esp_24->t0004.u0 = 0x02;
	runtime.printstring(gs);
	esp_24->t0000 = esp_24->t000C;
	esp_24->t0004.u0 = 0x00;
	Eq_4 esi_136;
	runtime.printhex(esi_112, gs, esp_24->t0000, esp_24->t0004, out esi_136);
	esp_24->t0000.u0 = 0x080E0D89;
	esp_24->t0004.u0 = 0x01;
	runtime.printstring(gs);
	esp_24->t0000 = esp_24->t0018;
	esp_24->t0004.u0 = 0x00;
	word32 esi_195;
	runtime.printhex(esi_136, gs, esp_24->t0000, esp_24->t0004, out esi_195);
	esp_24->t0000.u0 = 0x080E0E0F;
	esp_24->t0004.u0 = 0x02;
	runtime.printstring(gs);
	runtime.printunlock(gs);
	esp_24->t0000.u0 = 135145434;
	esp_24->t0004.u0 = 0x11;
	runtime.throw(gs);
}

// 0808D7F0: void runtime.exitsyscall.func1(Register (ptr32 Eq_2) gs)
void runtime.exitsyscall.func1(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.throw(gs);
}

// 0808D830: void runtime.exitsyscallfast.func1(Register Eq_4 edx, Register Eq_4 esi, Register (ptr32 Eq_2) gs)
void runtime.exitsyscallfast.func1(Eq_4 edx, Eq_4 esi, struct Eq_2 * gs)
{
	Eq_4 esp_19 = fp;
	while (esp_19 <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
	{
		word32 ebx_115;
		edx = runtime.morestack(edx, gs, *((word32) esp_19 - 4), *esp_19, out ebx_115, out esi);
		esp_19.u0 = <invalid>;
	}
	struct Eq_83048 * esp_24 = esp_19 - 0x14;
	esp_24->t0010 = *((word32) edx + 4);
	esp_24->t0008 = *((word32) edx + 8);
	esp_24->t000C = *((word32) edx + 0x0C);
	word32 ebp_35;
	word24 edx_24_8_78 = SLICE(runtime.exitsyscallfast_pidle(esi, gs, out ebp_35), word24, 8);
	Eq_4 al_48 = esp_24->t0000;
	*esp_24->t0010 = al_48;
	if (al_48 != 0x00 && g_b814F4C8 != 0x00)
	{
		Eq_4 eax_58 = esp_24->t0008;
		if (eax_58 != 0x00)
		{
			while (true)
			{
				Eq_4 edx_68 = *((word32) *((word32) esp_24->t000C + 24) + 484);
				edx_24_8_78 = SLICE(edx_68, word24, 8);
				if (*((word32) eax_58 + 20) != edx_68)
					break;
				runtime.osyield();
				eax_58 = esp_24->t0008;
			}
		}
		esp_24->t0000.u0 = 0x00;
		esp_24->t0004.u0 = 0x00;
		runtime.traceGoSysExit(edx_24_8_78, ebp_35, gs, esp_24->t0000, esp_24->t0004);
	}
}

// 0808D8D0: void runtime.exitsyscallfast_reacquired.func1(Register Eq_4 edx, Register (ptr32 Eq_2) gs)
void runtime.exitsyscallfast_reacquired.func1(Eq_4 edx, struct Eq_2 * gs)
{
	Eq_4 esp_19 = fp;
	while (esp_19 <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
	{
		word32 ebx_66;
		word32 esi_67;
		edx = runtime.morestack(edx, gs, *((word32) esp_19 - 4), *esp_19, out ebx_66, out esi_67);
		esp_19.u0 = <invalid>;
	}
	struct Eq_83159 * esp_24 = esp_19 - 0x08;
	esp_24->t0000 = *((word32) *((word32) *((word32) edx + 4) + 24) + 92);
	word32 ebp_31;
	word32 esi_68;
	word24 edx_24_8_44 = SLICE(runtime.traceGoSysBlock(gs, esp_24->t0000, out ebp_31, out esi_68), word24, 8);
	esp_24->t0000.u0 = 0x00;
	esp_24->t0004.u0 = 0x00;
	runtime.traceGoSysExit(edx_24_8_44, ebp_31, gs, esp_24->t0000, esp_24->t0004);
}

// 0808D920: void runtime.malg.func1(Register Eq_4 edx, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg00)
void runtime.malg.func1(Eq_4 edx, struct Eq_2 * gs, Eq_4 dwArg00)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
	{
		word32 esi_67;
		word32 ebx_66;
		edx = runtime.morestack(edx, gs, dwLoc04, dwArg00, out ebx_66, out esi_67);
	}
	Eq_4 eax_26 = *((word32) edx + 4);
	runtime.stackalloc(gs, *((word32) edx + 8));
	*eax_26 = dwLoc0C;
	*((word32) eax_26 + 4) = dwLoc08;
}

// 0808D970: void runtime.newproc.func1(Register Eq_4 edx, Register Eq_4 esi, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg00)
void runtime.newproc.func1(Eq_4 edx, Eq_4 esi, struct Eq_2 * gs, Eq_4 dwArg00)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
	{
		word32 ebx_77;
		edx = runtime.morestack(edx, gs, dwLoc04, dwArg00, out ebx_77, out esi);
	}
	runtime.newproc1(esi, gs, **((word32) edx + 4), **((word32) edx + 0x0C), 0x00);
}

// 0808D9C0: void runtime.gfget.func1(Register Eq_4 edx, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg00)
void runtime.gfget.func1(Eq_4 edx, struct Eq_2 * gs, Eq_4 dwArg00)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
	{
		word32 esi_66;
		word32 ebx_65;
		edx = runtime.morestack(edx, gs, dwLoc04, dwArg00, out ebx_65, out esi_66);
	}
	Eq_4 eax_26 = *((word32) edx + 4);
	runtime.stackalloc(gs, 0x0800);
	*eax_26 = dwLoc0C;
	*((word32) eax_26 + 4) = dwLoc08;
}

// 0808DA10: void runtime.(*rwmutex).rlock.func1(Register Eq_4 edx, Register Eq_4 esi, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg00)
void runtime.(*rwmutex).rlock.func1(Eq_4 edx, Eq_4 esi, struct Eq_2 * gs, Eq_4 dwArg00)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
	{
		word32 ebx_133;
		edx = runtime.morestack(edx, gs, dwLoc04, dwArg00, out ebx_133, out esi);
	}
	Eq_4 eax_25 = *((word32) edx + 4);
	Eq_4 esi_39;
	word32 edi_134;
	runtime.lock(esi, gs, eax_25, out esi_39, out edi_134);
	Eq_4 ecx_45 = *((word32) eax_25 + 8);
	if (ecx_45 > 0x00)
	{
		*((word32) eax_25 + 8) = ecx_45 - 0x01;
		word32 edx_137;
		word32 ebx_138;
		runtime.unlock(gs, eax_25, out edx_137, out ebx_138);
	}
	else
	{
		Eq_4 ecx_52 = *((word32) gs->ptr0000->tFFFFFFFC + 24);
		*((word32) ecx_52 + 0x00B4) = *((word32) eax_25 + 4);
		*((word32) eax_25 + 4) = ecx_52;
		word32 edx_135;
		word32 ebx_136;
		runtime.unlock(gs, eax_25, out edx_135, out ebx_136);
		runtime.notesleep(esi_39, gs, dwLoc14, (word32) ecx_52 + 0x00AC);
		((word32) ecx_52 + 0x00AC)->u0 = 0x00;
	}
}

// 0808DAC0: void runtime.morestackc.func1(Register (ptr32 Eq_2) gs)
void runtime.morestackc.func1(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.throw(gs);
}

// 0808DB00: void runtime.callers.func1(Register Eq_4 edx, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg00)
void runtime.callers.func1(Eq_4 edx, struct Eq_2 * gs, Eq_4 dwArg00)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
	{
		word32 esi_90;
		word32 ebx_89;
		edx = runtime.morestack(edx, gs, dwLoc04, dwArg00, out ebx_89, out esi_90);
	}
	Eq_4 eax_25 = *((word32) edx + 4);
	Eq_4 ebx_27 = *((word32) edx + 0x0C);
	Eq_4 ebp_28 = *((word32) edx + 16);
	Eq_4 esi_30 = **((word32) edx + 20);
	Eq_4 edi_31 = *((word32) edx + 24);
	Eq_4 edx_32 = *((word32) edx + 28);
	if (edx_32 <= 0x00)
		runtime.panicindex(gs);
	else
	{
		runtime.gentraceback(gs, ebx_27, 0x00, ebp_28, esi_30, edi_31, edx_32, 0x00, 0x00);
		*eax_25 = dwLoc08;
	}
}

// 0808DB90: Register word32 runtime.init(Register (ptr32 Eq_2) gs, Register out ptr32 esiOut, Register out ptr32 ediOut)
// Called from:
//      runtime.main
//      sync.init
//      syscall.init
//      time.init
//      os.init
//      reflect.init
word32 runtime.init(struct Eq_2 * gs, ptr32 & esiOut, ptr32 & ediOut)
{
	word32 dwLoc08_128 = (word32) rLoc08;
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	cu8 al_18 = g_b815756E;
	if (al_18 <= 0x01)
	{
		if (al_18 != 0x01)
		{
			g_b815756E = 0x01;
			runtime.float64frombits(gs);
			g_r8157678 = (real64) (uint128) rLoc08;
			runtime.funcPC();
			runtime.chansendpc = dwLoc08_128;
			runtime.funcPC();
			runtime.chanrecvpc = dwLoc08_128;
			word32 ebx_59 = runtime.nanotime();
			g_ptr81576A8 = 0x080CF8FF;
			g_ptr81576AC = 135166916;
			runtime.init.0(gs);
			ptr32 esi_86 = runtime.init.1(SLICE(ebx_59, word24, 8), gs);
			runtime.init.2(gs);
			ptr32 edi_101 = runtime.init.3(gs);
			runtime.init.4(gs);
			g_b815756E = 0x02;
			esiOut = esi_86;
			ediOut = edi_101;
			return ebx_59;
		}
		else
			runtime.throwinit(gs);
	}
	else
	{
		esiOut = esi;
		ediOut = edi;
		return ebx;
	}
}

// 0808DC80: void runtime.skipPleaseUseCallersFrames(Register word32 ecx, Register word32 edx, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
void runtime.skipPleaseUseCallersFrames(word32 ecx, word32 edx, struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08)
{
	word32 edx_34;
	runtime.rt0_go(ecx, edx, gs, dwArg04, dwArg08, out edx_34);
}

// 0808DD80: Register word32 runtime.rt0_go(Register word32 ecx, Register word32 edx, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Register out ptr32 edxOut)
// Called from:
//      runtime.skipPleaseUseCallersFrames
//      main
word32 runtime.rt0_go(word32 ecx, word32 edx, struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, ptr32 & edxOut)
{
	ptr32 fp;
	byte SCZDOP;
	word32 ecx;
	word32 edx;
	struct Eq_2 * gs;
	Eq_4 dwArg04;
	Eq_4 dwArg08;
	SCZO_8 = cond(fp - 0x80);
	__align(fp - 0x80);
	ebx_12 = fp + ~0x00010017;
	g_ptr81454A8 = fp + ~0x00010017;
	g_ptr81454AC = fp + ~0x00010017;
	g_ptr81454A0 = fp + ~0x00010017;
	g_ptr81454A4 = fp - 0x80;
	SCZDOP_19 = SCZO_8 | SCZDOP;
	eax_32 = SCZDOP ^ 0x00200000 ^ SCZDOP_19;
	if ((eax_32 & 0x00200000) == 0x00)
	{
		ecx_44 = runtime.write(out edx_45, out ebx_341);
		ebx_52 = runtime.exit();
		__syscall(0x03);
	}
	Mem133 = (Mem29, Mem50);
	edx_57 = (edx, edx_45);
	ebx_56 = (ebx_12, ebx_52);
	ecx_54 = (ecx, ecx_44);
	__cpuid(0x00, ecx_54, &0x00, &ebx_56, &ecx_54, &edx_57);
	edx_168 = (edx_57, edx_170);
	ecx_165 = (ecx_54, ecx_166);
	Mem132 = (Mem133, Mem121, Mem131);
	eax_134 = _cgo_init;
	if (eax_134 != null)
	{
		eax_134();
		eax_183 = g_ptr81454A0;
		g_ptr81454A8 = eax_183 + 880;
		g_ptr81454AC = eax_183 + 880;
	}
	else
	{
		runtime.ldt0setup();
		ebx_145 = gs->ptr0000;
		ebx_145->tFFFFFFFC.u0 = 0x0123;
		eax_147 = g_t8145718;
		if (eax_147 != 0x0123)
			null = (union Eq_4 *) eax_147;
	}
	Mem189 = (Mem187, Mem146, Mem150);
	ebx_190 = gs->ptr0000;
	ebx_190->tFFFFFFFC.u0 = 135550112;
	g_ptr81456E0 = 135550112;
	g_ptr81454B8 = 135550688;
	runtime.emptyfunc(gs);
	mm0_211 = runtime.check(0x00, gs);
	runtime.args(gs, dwArg04, dwArg08);
	esi_241 = runtime.osinit(gs);
	runtime.schedinit(esi_241, gs, mm0_211);
	runtime.newproc();
	runtime.mstart(gs);
	__syscall(0x03);
	edxOut = edx_289;
	return ecx_288;
}

// 0808DFC0: void runtime.asminit()
// Called from:
//      runtime.mstart1
//      runtime.needm
void runtime.asminit()
{
	__fldcw(g_t8136002);
}

// 0808DFD0: void runtime.gosave(Register (ptr32 Eq_2) gs, Stack word32 dwArg00, Stack (ptr32 Eq_47897) dwArg04)
// Called from:
//      runtime.mstart1
void runtime.gosave(struct Eq_2 * gs, word32 dwArg00, struct Eq_47897 * dwArg04)
{
	dwArg04->ptr0000 = fp + 0x04;
	dwArg04->dw0004 = dwArg00;
	dwArg04->dw0010 = 0x00;
	if (dwArg04->dw000C == 0x00)
		dwArg04->t0008 = gs->ptr0000->tFFFFFFFC;
	else
		runtime.badctxt();
}

// 0808E010: void runtime.gogo(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_42969) dwArg04)
// Called from:
//      runtime.recovery
//      runtime.execute
//      runtime.newstack
void runtime.gogo(struct Eq_2 * gs, struct Eq_42969 * dwArg04)
{
	if (dwArg04->dw000C != 0x00)
		runtime.writebarrierptr_prewrite(0x00);
	struct Eq_6 * ecx_25 = gs->ptr0000;
	ecx_25->tFFFFFFFC = dwArg04->t0008;
	word32 eax_28 = dwArg04->dw0010;
	word32 edx_29 = dwArg04->dw000C;
	dwArg04->dw0000 = 0x00;
	dwArg04->dw0010 = 0x00;
	dwArg04->dw000C = 0x00;
	dwArg04->ptr0004();
}

// 0808E070: Register Eq_4 runtime.mcall(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg00, Stack (ptr32 word32) dwArg04, Register out Eq_1912 esiOut)
// Called from:
//      runtime.gopanic
//      runtime.Gosched
//      runtime.gopark
//      runtime.goexit1
//      runtime.exitsyscall
Eq_4 runtime.mcall(struct Eq_2 * gs, Eq_4 dwArg00, word32 * dwArg04, union Eq_1912 & esiOut)
{
	struct Eq_6 * edx_7 = gs->ptr0000;
	Eq_4 eax_8 = edx_7->tFFFFFFFC;
	*((word32) eax_8 + 32) = dwArg00;
	*((word32) eax_8 + 28) = fp + 0x04;
	*((word32) eax_8 + 36) = eax_8;
	Eq_4 esi_16 = **((word32) edx_7->tFFFFFFFC + 24);
	if (esi_16 != eax_8)
	{
		edx_7->tFFFFFFFC = esi_16;
		*((word32) *((word32) esi_16 + 28) - 4) = eax_8;
		(*dwArg04)();
		g_t806E020();
		esiOut.u2 = <invalid>;
		return <invalid>;
	}
	else
	{
		word32 eax_36;
		g_t806DFE0();
		esiOut.u2 = <invalid>;
		return <invalid>;
	}
}

// 0808E0C0: void runtime.systemstack_switch()
void runtime.systemstack_switch()
{
}

// 0808E0D0: Register Eq_4 runtime.systemstack(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Register out Eq_4 ebpOut, Register out Eq_4 ediOut)
// Called from:
//      runtime.cgocallbackg1
//      runtime.cgoCheckWriteBarrier
//      runtime.cgoCheckTypedBlock
//      runtime.cgoCheckBits
//      runtime.(*mcache).nextFree
//      runtime.mallocgc
//      runtime.persistentalloc
//      runtime.writebarrierptr_prewrite1
//      runtime.writebarrierptr
//      runtime.writebarrierptr_prewrite
//      runtime.typedslicecopy
//      runtime.freemcache
//      runtime.SetFinalizer
//      runtime.gcStart
//      runtime.gcMarkDone
//      runtime.gcMarkTermination
//      runtime.gcBgMarkWorker
//      runtime.markroot
//      runtime.gcAssistAlloc
//      runtime.gosweepone
//      runtime.getempty
//      runtime.freeSomeWbufs
//      runtime.(*mheap).alloc
//      runtime.(*mheap).freeSpan
//      runtime.mProf_Malloc
//      runtime.tracealloc
//      runtime.tracefree
//      runtime.futexwakeup
//      runtime.newdefer
//      runtime.freedefer
//      runtime.startpanic
//      runtime.dopanic
//      runtime.main
//      runtime.goready
//      runtime.casgstatus
//      runtime.stopTheWorld
//      runtime.startTheWorld
//      runtime.reentersyscall
//      runtime.entersyscallblock
//      runtime.exitsyscall
//      runtime.exitsyscallfast
//      runtime.exitsyscallfast_reacquired
//      runtime.malg
//      runtime.newproc
//      runtime.gfget
//      runtime.unlockOSThread
//      runtime.(*rwmutex).rlock
//      os.sigpipe
//      runtime.morestackc
//      runtime.callers
Eq_4 runtime.systemstack(struct Eq_2 * gs, Eq_4 dwArg04, union Eq_4 & ebpOut, union Eq_4 & ediOut)
{
	Eq_4 eax_32 = gs->ptr0000->tFFFFFFFC;
	Eq_4 ebx_9 = *((word32) eax_32 + 24);
	if (eax_32 != *((word32) ebx_9 + 44))
	{
		Eq_4 edx_13 = *ebx_9;
		if (eax_32 != edx_13)
		{
			Eq_4 ebp_27 = *((word32) ebx_9 + 84);
			if (eax_32 != ebp_27)
				eax_32 = runtime.badsystemstack(gs, out edx_13);
			((word32) eax_32 + 32)->u0 = 0x0808E0C0;
			*((word32) eax_32 + 28) = fp;
			*((word32) eax_32 + 36) = eax_32;
			struct Eq_6 * ecx_41 = gs->ptr0000;
			ecx_41->tFFFFFFFC = edx_13;
			((word32) *((word32) edx_13 + 28) - 4)->u0 = 0x0806FA80;
			Eq_4 edi_52 = *dwArg04;
			edi_52();
			struct Eq_6 * ecx_58 = gs->ptr0000;
			Eq_4 ebx_60 = *((word32) ecx_58->tFFFFFFFC + 24);
			Eq_4 eax_61 = *((word32) ebx_60 + 84);
			ecx_58->tFFFFFFFC = eax_61;
			((word32) eax_61 + 28)->u0 = 0x00;
			ebpOut = ebp_27;
			ediOut = edi_52;
			return ebx_60;
		}
	}
	Eq_4 edi_19 = *dwArg04;
	edi_19();
	ebpOut = ebp;
	ediOut = edi_19;
	return ebx_9;
}

// 0808E160: Register Eq_4 runtime.morestack(Register Eq_4 edx, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg00, Stack Eq_4 dwArg04, Register out Eq_4 ebxOut, Register out Eq_4 esiOut)
// Called from:
//      runtime.cgoCheckWriteBarrier.func1
//      runtime.cgoCheckTypedBlock.func1
//      runtime.chansend.func1
//      runtime.chanrecv.func1
//      runtime.(*mcache).nextFree.func1
//      runtime.mallocgc.func1
//      runtime.persistentalloc.func1
//      runtime.writebarrierptr_prewrite1.func1
//      runtime.writebarrierptr.func1
//      runtime.typedslicecopy.func1
//      runtime.freemcache.func1
//      runtime.SetFinalizer.func1
//      runtime.SetFinalizer.func2
//      runtime.gcMarkTermination.func1
//      runtime.gcMarkTermination.func2
//      runtime.gcBgMarkWorker.func2
//      runtime.markroot.func1
//      runtime.gcAssistAlloc.func1
//      runtime.scanstack.func1
//      runtime.gosweepone.func1
//      runtime.getempty.func1
//      runtime.freeSomeWbufs.func1
//      runtime.(*mheap).alloc.func1
//      runtime.(*mheap).freeSpan.func1
//      runtime.mProf_Malloc.func1
//      runtime.tracealloc.func1
//      runtime.tracefree.func1
//      runtime.futexwakeup.func1
//      runtime.newdefer.func1
//      runtime.newdefer.func2
//      runtime.freedefer.func1
//      runtime.dopanic.func1
//      runtime.goready.func1
//      runtime.casgstatus.func1
//      runtime.reentersyscall.func1
//      runtime.entersyscallblock.func1
//      runtime.entersyscallblock.func2
//      runtime.exitsyscallfast.func1
//      runtime.exitsyscallfast_reacquired.func1
//      runtime.malg.func1
//      runtime.newproc.func1
//      runtime.gfget.func1
//      runtime.(*rwmutex).rlock.func1
//      runtime.callers.func1
//      runtime.morestack_noctxt
//      reflect.(*structType).FieldByName.func1
//      reflect.FuncOf.func1
//      reflect.funcLayout.func1
Eq_4 runtime.morestack(Eq_4 edx, struct Eq_2 * gs, Eq_4 dwArg00, Eq_4 dwArg04, union Eq_4 & ebxOut, union Eq_4 & esiOut)
{
	struct Eq_6 * ecx_14 = gs->ptr0000;
	Eq_4 ebx_13 = *((word32) ecx_14->tFFFFFFFC + 24);
	if (ecx_14->tFFFFFFFC == *ebx_13)
	{
		ecx_14 = runtime.badmorestackg0(out edx, out ebx_13);
		__syscall(0x03);
	}
	if (ecx_14->tFFFFFFFC == *((word32) ebx_13 + 44))
	{
		edx = runtime.badmorestackgsignal(out ebx_13);
		__syscall(0x03);
	}
	*((word32) ebx_13 + 8) = dwArg04;
	*((word32) ebx_13 + 4) = fp + 0x08;
	struct Eq_6 * ecx_44 = gs->ptr0000;
	Eq_4 esi_45 = ecx_44->tFFFFFFFC;
	*((word32) ebx_13 + 0x0C) = esi_45;
	*((word32) esi_45 + 32) = dwArg00;
	*((word32) esi_45 + 36) = esi_45;
	*((word32) esi_45 + 28) = fp + 0x04;
	Eq_4 ebp_52 = *ebx_13;
	ecx_44->tFFFFFFFC = ebp_52;
	Eq_4 eax_54 = *((word32) ebp_52 + 28);
	Eq_4 ebx_55 = *((word32) eax_54 - 4);
	*((word32) eax_54 - 4) = edx;
	runtime.newstack(gs, dwArg00);
	*(word32 *) 0x1003 = 0x00;
	Eq_4 edx_69 = *((word32) eax_54 - 4);
	ebxOut = ebx_55;
	esiOut = esi_45;
	return edx_69;
}

// 0808E1F0: Register Eq_4 runtime.morestack_noctxt()
// Called from:
//      sync/atomic.(*Value).Load
//      sync/atomic.(*Value).Store
//      type..hash.sync/atomic.Value
//      type..eq.sync/atomic.Value
//      runtime.memhash0
//      runtime.memhash8
//      runtime.memhash16
//      runtime.memhash32
//      runtime.memhash64
//      runtime.memhash128
//      runtime.strhash
//      runtime.f32hash
//      runtime.f64hash
//      runtime.c64hash
//      runtime.c128hash
//      runtime.interhash
//      runtime.nilinterhash
//      runtime.memequal0
//      runtime.memequal8
//      runtime.memequal16
//      runtime.memequal32
//      runtime.memequal64
//      runtime.memequal128
//      runtime.f32equal
//      runtime.f64equal
//      runtime.c64equal
//      runtime.c128equal
//      runtime.strequal
//      runtime.interequal
//      runtime.nilinterequal
//      runtime.efaceeq
//      runtime.ifaceeq
//      runtime.alginit
//      runtime.cgocallbackg1
//      runtime.unwindm
//      runtime.makechan
//      runtime.chansend
//      runtime.send
//      runtime.sendDirect
//      runtime.recvDirect
//      runtime.closechan
//      runtime.chanrecv
//      runtime.recv
//      reflect.chanlen
//      runtime.(*waitq).dequeue
//      runtime.(*cpuProfile).add
//      runtime.(*cpuProfile).addExtra
//      runtime.GOMAXPROCS
//      runtime.gogetenv
//      runtime.(*TypeAssertionError).Error
//      runtime.errorString.Error
//      runtime.plainError.Error
//      runtime.typestring
//      runtime.printany
//      runtime.panicwrap
//      runtime.Caller
//      runtime.Callers
//      runtime.GOROOT
//      runtime.float64frombits
//      runtime.memhash
//      runtime.(*hmap).newoverflow
//      runtime.makemap
//      runtime.mapaccess2
//      runtime.mapaccessK
//      runtime.mapassign
//      runtime.mapiterinit
//      runtime.mapiternext
//      runtime.makeBucketArray
//      runtime.hashGrow
//      runtime.growWork
//      runtime.evacuate
//      reflect.mapaccess
//      reflect.mapiterinit
//      reflect.mapiternext
//      reflect.mapiterkey
//      reflect.maplen
//      runtime.mapaccess1_fast32
//      runtime.mapaccess2_fast32
//      runtime.mapaccess2_fast64
//      runtime.mapassign_fast32
//      runtime.mapassign_fast64
//      runtime.mapassign_faststr
//      runtime.getitab
//      runtime.additab
//      runtime.itabsinit
//      runtime.panicdottypeE
//      runtime.panicdottypeI
//      runtime.convT2E
//      runtime.convT2E32
//      runtime.convT2Estring
//      runtime.convT2Eslice
//      runtime.convT2I32
//      runtime.assertE2I
//      runtime.assertE2I2
//      reflect.ifaceE2I
//      runtime.(*lfstack).push
//      runtime.(*lfstack).pop
//      runtime.(*lfstack).empty
//      runtime.lock
//      runtime.unlock
//      runtime.notewakeup
//      runtime.notesleep
//      runtime.notetsleep
//      runtime.notetsleepg
//      runtime.mallocinit
//      runtime.(*mheap).sysAlloc
//      runtime.nextFreeFast
//      runtime.(*mcache).nextFree
//      runtime.mallocgc
//      runtime.largeAlloc
//      runtime.newobject
//      reflect.unsafe_New
//      runtime.newarray
//      runtime.profilealloc
//      runtime.nextSample
//      runtime.persistentalloc
//      reflect.typedmemmove
//      reflect.typedmemmovepartial
//      runtime.(*mheap).mapBits
//      runtime.(*mspan).refillAllocCache
//      runtime.(*mspan).nextFreeIndex
//      runtime.markBitsForAddr
//      runtime.markBits.setMarked
//      runtime.heapBitsForSpan
//      runtime.heapBitsForObject
//      runtime.heapBits.setCheckmarked
//      runtime.heapBits.initSpan
//      runtime.heapBits.initCheckmarkSpan
//      runtime.heapBits.clearCheckmarkSpan
//      runtime.(*mspan).countAlloc
//      runtime.heapBitsSetType
//      runtime.heapBitsSetTypeGCProg
//      runtime.progToPointerMask
//      runtime.runGCProg
//      runtime.allocmcache
//      runtime.freemcache
//      runtime.(*mcache).refill
//      runtime.(*mcache).releaseAll
//      runtime.(*mcentral).cacheSpan
//      runtime.(*mcentral).uncacheSpan
//      runtime.(*mcentral).freeSpan
//      runtime.(*mcentral).grow
//      runtime.addrspace_free
//      runtime.mmap_fixed
//      runtime.sysUnused
//      runtime.sysUsed
//      runtime.sysFault
//      runtime.sysReserve
//      runtime.sysMap
//      runtime.queuefinalizer
//      runtime.wakefing
//      runtime.createfing
//      runtime.runfinq
//      runtime.SetFinalizer
//      runtime.findObject
//      runtime.(*fixalloc).alloc
//      runtime.gcinit
//      runtime.readgogc
//      runtime.gcenable
//      runtime/debug.setGCPercent
//      runtime.(*gcControllerState).startCycle
//      runtime.(*gcControllerState).revise
//      runtime.(*gcControllerState).endCycle
//      runtime.(*gcControllerState).enlistWorker
//      runtime.(*gcControllerState).findRunnableGCWorker
//      runtime.gcSetTriggerRatio
//      runtime.gcTrigger.test
//      runtime.gcStart
//      runtime.gcMarkDone
//      runtime.gcMarkTermination
//      runtime.gcBgMarkStartWorkers
//      runtime.gcBgMarkWorker
//      runtime.gcMarkWorkAvailable
//      runtime.gcMark
//      runtime.gcSweep
//      runtime.gcResetMarkState
//      sync.runtime_registerPoolCleanup
//      runtime.clearpools
//      runtime.gchelper
//      runtime.gchelperstart
//      runtime.itoaDiv
//      runtime.fmtNSAsMS
//      runtime.(*mTreap).insert
//      runtime.(*mTreap).removeNode
//      runtime.(*mTreap).remove
//      runtime.(*mTreap).removeSpan
//      runtime.scavengetreap
//      runtime.(*mTreap).rotateLeft
//      runtime.(*mTreap).rotateRight
//      runtime.gcMarkRootPrepare
//      runtime.gcMarkRootCheck
//      runtime.markroot
//      runtime.markrootBlock
//      runtime.markrootFreeGStacks
//      runtime.markrootSpans
//      runtime.gcAssistAlloc
//      runtime.gcWakeAllAssists
//      runtime.gcParkAssist
//      runtime.gcFlushBgCredit
//      runtime.scanframeworker
//      runtime.gcDrain
//      runtime.scanblock
//      runtime.scanobject
//      runtime.shade
//      runtime.greyobject
//      runtime.gcDumpObject
//      runtime.gcMarkTinyAllocs
//      runtime.initCheckmarks
//      runtime.clearCheckmarks
//      runtime.finishsweep_m
//      runtime.bgsweep
//      runtime.sweepone
//      runtime.gosweepone
//      runtime.(*mspan).ensureSwept
//      runtime.(*mspan).sweep
//      runtime.deductSweepCredit
//      runtime.(*gcSweepBuf).push
//      runtime.(*gcSweepBuf).pop
//      runtime.(*gcSweepBuf).numBlocks
//      runtime.(*gcSweepBuf).block
//      runtime.init.0
//      runtime.(*gcWork).init
//      runtime.(*gcWork).put
//      runtime.(*gcWork).tryGet
//      runtime.(*gcWork).get
//      runtime.(*gcWork).dispose
//      runtime.(*gcWork).balance
//      runtime.(*workbuf).checknonempty
//      runtime.(*workbuf).checkempty
//      runtime.getempty
//      runtime.putempty
//      runtime.putfull
//      runtime.trygetfull
//      runtime.getfull
//      runtime.handoff
//      runtime.prepareFreeWorkbufs
//      runtime.freeSomeWbufs
//      runtime.recordspan
//      runtime.(*mheap).init
//      runtime.(*mheap).setArenaUsed
//      runtime.(*mheap).mapSpans
//      runtime.(*mheap).reclaimList
//      runtime.(*mheap).reclaim
//      runtime.(*mheap).alloc_m
//      runtime.(*mheap).alloc
//      runtime.(*mheap).allocSpanLocked
//      runtime.(*mheap).allocLarge
//      runtime.(*mheap).grow
//      runtime.(*mheap).freeSpan
//      runtime.(*mheap).freeSpanLocked
//      runtime.scavengeTreapNode
//      runtime.scavengelist
//      runtime.(*mheap).scavenge
//      runtime.(*mSpanList).remove
//      runtime.(*mSpanList).insert
//      runtime.(*mSpanList).insertBack
//      runtime.(*mSpanList).takeAll
//      runtime.addspecial
//      runtime.removespecial
//      runtime.addfinalizer
//      runtime.removefinalizer
//      runtime.setprofilebucket
//      runtime.freespecial
//      runtime.(*gcBitsArena).tryAlloc
//      runtime.newMarkBits
//      runtime.newAllocBits
//      runtime.nextMarkBitArenaEpoch
//      runtime.newArenaMayUnlock
//      runtime.newBucket
//      runtime.(*bucket).mp
//      runtime.(*bucket).bp
//      runtime.stkbucket
//      runtime.eqslice
//      runtime.mProf_NextCycle
//      runtime.mProf_Flush
//      runtime.mProf_FlushLocked
//      runtime.mProf_Malloc
//      runtime.mProf_Free
//      runtime.blockevent
//      runtime.blocksampled
//      runtime.saveblockevent
//      sync.event
//      runtime.tracealloc
//      runtime.tracefree
//      runtime.tracegc
//      runtime.init.1
//      runtime.cachestats
//      runtime.flushmcache
//      internal/poll.runtime_pollServerInit
//      runtime.netpollinited
//      internal/poll.runtime_pollOpen
//      internal/poll.runtime_pollClose
//      runtime.(*pollCache).free
//      internal/poll.runtime_pollReset
//      internal/poll.runtime_pollWait
//      internal/poll.runtime_pollUnblock
//      runtime.netpollready
//      runtime.netpollblockcommit
//      runtime.netpollgoready
//      runtime.netpollblock
//      runtime.netpollunblock
//      runtime.(*pollCache).alloc
//      runtime.netpollinit
//      runtime.netpollopen
//      runtime.netpollclose
//      runtime.netpoll
//      runtime.getproccount
//      runtime.newosproc
//      runtime.sysargs
//      runtime.sysauxv
//      runtime.osinit
//      runtime.getRandomData
//      runtime.goenvs
//      runtime.mpreinit
//      runtime.minit
//      runtime.panicCheckMalloc
//      runtime.panicindex
//      runtime.panicslice
//      runtime.panicdivide
//      runtime.panicoverflow
//      runtime.panicfloat
//      runtime.panicmem
//      runtime.throwinit
//      runtime.testdefersizes
//      runtime.init.2
//      runtime.freedeferpanic
//      runtime.freedeferfn
//      runtime.preprintpanics
//      runtime.printpanics
//      runtime.gopanic
//      runtime.recovery
//      runtime.startpanic_m
//      runtime.dopanic_m
//      runtime.recordForPanic
//      runtime.printlock
//      runtime.printunlock
//      runtime.gwrite
//      runtime.printsp
//      runtime.printnl
//      runtime.printbool
//      runtime.printfloat
//      runtime.printcomplex
//      runtime.printuint
//      runtime.printint
//      runtime.printhex
//      runtime.printpointer
//      runtime.printstring
//      runtime.printslice
//      runtime.printeface
//      runtime.main
//      runtime.init.3
//      runtime.forcegchelper
//      runtime.gopark
//      runtime.goparkunlock
//      runtime.goready
//      runtime.badmcall
//      runtime.badmcall2
//      runtime.badreflectcall
//      runtime.allgadd
//      runtime.schedinit
//      runtime.dumpgstatus
//      runtime.checkmcount
//      runtime.mcommoninit
//      runtime.ready
//      runtime.gcprocs
//      runtime.needaddgcproc
//      runtime.helpgc
//      runtime.freezetheworld
//      runtime.casfrom_Gscanstatus
//      runtime.castogscanstatus
//      runtime.scang
//      runtime.restartg
//      runtime.stopTheWorld
//      runtime.startTheWorld
//      runtime.stopTheWorldWithSema
//      runtime.mhelpgc
//      runtime.startTheWorldWithSema
//      runtime.mstart1
//      runtime.runSafePointFn
//      runtime.allocm
//      runtime.newextram
//      runtime.oneNewExtraM
//      runtime.dropm
//      runtime.newm
//      runtime.stopm
//      runtime.mspinning
//      runtime.startm
//      runtime.handoffp
//      runtime.wakep
//      runtime.stoplockedm
//      runtime.startlockedm
//      runtime.gcstopm
//      runtime.execute
//      runtime.findrunnable
//      runtime.pollWork
//      runtime.resetspinning
//      runtime.injectglist
//      runtime.schedule
//      runtime.parkunlock_c
//      runtime.park_m
//      runtime.goschedImpl
//      runtime.gosched_m
//      runtime.gopreempt_m
//      runtime.goexit1
//      runtime.goexit0
//      runtime.entersyscall_sysmon
//      runtime.entersyscall_gcwait
//      runtime.entersyscallblock_handoff
//      runtime.exitsyscallfast_pidle
//      runtime.exitsyscall0
//      runtime.malg
//      runtime.newproc1
//      runtime.gfput
//      runtime.gfget
//      runtime.gfpurge
//      runtime.badunlockosthread
//      runtime._System
//      runtime._ExternalCode
//      runtime._LostExternalCode
//      runtime._GC
//      runtime.sigprof
//      runtime.setsSP
//      runtime.procresize
//      runtime.acquirep
//      runtime.acquirep1
//      runtime.releasep
//      runtime.incidlelocked
//      runtime.checkdead
//      runtime.sysmon
//      runtime.retake
//      runtime.preemptall
//      runtime.schedtrace
//      runtime.mput
//      runtime.globrunqget
//      runtime.pidleput
//      runtime.pidleget
//      runtime.runqempty
//      runtime.runqput
//      runtime.runqputslow
//      runtime.runqget
//      runtime.runqgrab
//      runtime.runqsteal
//      runtime.(*randomOrder).reset
//      runtime.gcd
//      runtime.(*profAtomic).load
//      runtime.(*profAtomic).cas
//      runtime.(*profBuf).hasOverflow
//      runtime.(*profBuf).takeOverflow
//      runtime.(*profBuf).incrementOverflow
//      runtime.(*profBuf).canWriteRecord
//      runtime.(*profBuf).canWriteTwoRecords
//      runtime.(*profBuf).write
//      runtime.(*profBuf).wakeupExtra
//      syscall.runtime_envs
//      os.runtime_args
//      runtime.args
//      runtime.goargs
//      runtime.goenvs_unix
//      runtime.testAtomic64
//      runtime.check
//      runtime.parsedebugvars
//      runtime/debug.SetTraceback
//      reflect.typelinks
//      reflect.resolveNameOff
//      reflect.resolveTypeOff
//      reflect.resolveTextOff
//      reflect.addReflectOff
//      runtime.extendRandom
//      runtime.(*rwmutex).rlock
//      runtime.(*rwmutex).runlock
//      internal/poll.runtime_Semacquire
//      sync.runtime_Semrelease
//      sync.runtime_SemacquireMutex
//      internal/poll.runtime_Semrelease
//      runtime.readyWithTime
//      runtime.semacquire
//      runtime.semacquire1
//      runtime.semrelease
//      runtime.semrelease1
//      runtime.cansemacquire
//      runtime.(*semaRoot).queue
//      runtime.(*semaRoot).dequeue
//      runtime.(*semaRoot).rotateLeft
//      runtime.(*semaRoot).rotateRight
//      sync.runtime_notifyListCheck
//      sync.runtime_nanotime
//      runtime.dumpregs
//      runtime.(*sigctxt).preparePanic
//      runtime.sighandler
//      os.sigpipe
//      runtime.init.4
//      runtime.setThreadCPUProfiler
//      runtime.sigpipe
//      runtime.sigpanic
//      runtime.raisebadsignal
//      runtime.crash
//      runtime.noSignalStack
//      runtime.sigNotOnStack
//      runtime.signalDuringFork
//      runtime.minitSignals
//      runtime.minitSignalStack
//      runtime.minitSignalMask
//      runtime.sigsend
//      runtime.signal_ignored
//      runtime.makeslice
//      runtime.growslice
//      runtime.stackinit
//      runtime.stacklog2
//      runtime.stackpoolalloc
//      runtime.stackpoolfree
//      runtime.adjustpointers
//      runtime.adjustframe
//      runtime.adjustctxt
//      runtime.adjustdefers
//      runtime.adjustsudogs
//      runtime.findsghi
//      runtime.syncadjustsudogs
//      runtime.copystack
//      runtime.round2
//      runtime.newstack
//      runtime.shrinkstack
//      runtime.freeStackSpans
//      runtime.concatstrings
//      runtime.concatstring2
//      runtime.concatstring3
//      runtime.concatstring4
//      runtime.concatstring5
//      runtime.slicebytetostring
//      runtime.rawstringtmp
//      runtime.stringtoslicebyte
//      runtime.stringtoslicerune
//      runtime.slicerunetostring
//      runtime.intstring
//      runtime.rawstring
//      runtime.rawbyteslice
//      runtime.rawruneslice
//      runtime.gostring
//      runtime.index
//      runtime.contains
//      runtime.atoi
//      runtime.atoi32
//      runtime.badsystemstack
//      reflect.memclrNoHeapPointers
//      runtime.CallersFrames
//      runtime.(*Frames).Next
//      runtime.(*stackExpander).next
//      runtime.(*pcExpander).init
//      runtime.(*pcExpander).next
//      runtime.expandCgoFrames
//      runtime.(*Func).funcInfo
//      runtime.modulesinit
//      runtime.moduledataverify
//      runtime.moduledataverify1
//      runtime.FuncForPC
//      runtime.(*Func).Name
//      runtime.findmoduledatap
//      runtime.findfunc
//      runtime.pcvalue
//      runtime.funcname
//      runtime.funcnameFromNameoff
//      runtime.funcfile
//      runtime.funcline1
//      runtime.funcline
//      runtime.funcspdelta
//      runtime.pcdatavalue
//      runtime.funcdata
//      runtime.step
//      runtime.readvarint
//      runtime.stackmapdata
//      runtime.deltimer
//      runtime.timerproc
//      runtime.timejump
//      runtime.siftupTimer
//      runtime.siftdownTimer
//      time.now
//      runtime.traceReader
//      runtime.traceProcFree
//      runtime.traceEvent
//      runtime.traceStackID
//      runtime.traceAcquireBuffer
//      runtime.traceReleaseBuffer
//      runtime.traceFlush
//      runtime.(*traceBuf).varint
//      runtime.(*traceStackTable).put
//      runtime.(*traceStackTable).find
//      runtime.(*traceStackTable).newStack
//      runtime.(*traceAlloc).alloc
//      runtime.traceGomaxprocs
//      runtime.traceProcStart
//      runtime.traceProcStop
//      runtime.traceGCStart
//      runtime.traceGCDone
//      runtime.traceGCScanStart
//      runtime.traceGCScanDone
//      runtime.traceGCSweepStart
//      runtime.traceGCSweepSpan
//      runtime.traceGCSweepDone
//      runtime.traceGCMarkAssistStart
//      runtime.traceGCMarkAssistDone
//      runtime.traceGoCreate
//      runtime.traceGoStart
//      runtime.traceGoEnd
//      runtime.traceGoSched
//      runtime.traceGoPreempt
//      runtime.traceGoPark
//      runtime.traceGoUnpark
//      runtime.traceGoSysCall
//      runtime.traceGoSysExit
//      runtime.traceGoSysBlock
//      runtime.traceHeapAlloc
//      runtime.traceNextGC
//      runtime.tracebackinit
//      runtime.tracebackdefers
//      runtime.gentraceback
//      runtime.getArgInfo
//      runtime.tracebackCgoContext
//      runtime.printcreatedby
//      runtime.traceback
//      runtime.tracebacktrap
//      runtime.traceback1
//      runtime.callers
//      runtime.gcallers
//      runtime.showframe
//      runtime.goroutineheader
//      runtime.tracebackothers
//      runtime.printCgoTraceback
//      runtime.printOneCgoTraceback
//      runtime.callCgoSymbolizer
//      runtime.cgoContextPCs
//      runtime.(*_type).string
//      runtime.(*_type).uncommon
//      runtime.reflectOffsLock
//      runtime.reflectOffsUnlock
//      runtime.resolveNameOff
//      runtime.(*_type).nameOff
//      runtime.resolveTypeOff
//      runtime.(*_type).typeOff
//      runtime.(*_type).textOff
//      runtime.name.tagLen
//      runtime.name.name
//      runtime.name.tag
//      runtime.name.pkgPath
//      runtime.typelinksinit
//      runtime.typesEqual
//      runtime.decoderune
//      runtime.encoderune
//      runtime.float64toint64
//      runtime.float64touint64
//      runtime.int64tofloat64
//      runtime.uint64tofloat64
//      runtime._d2v
//      runtime.uint64div
//      runtime.uint64mod
//      runtime.int64div
//      runtime.int64mod
//      runtime.dodiv
//      runtime.slowdodiv
//      runtime.writeErr
//      runtime.cgocallbackg1.func1
//      runtime.cgoCheckTypedBlock.func2
//      runtime.cgoCheckBits.func1
//      runtime.writebarrierptr_prewrite.func1
//      runtime.(*gcControllerState).findRunnableGCWorker.func1
//      runtime.gcStart.func1
//      runtime.gcMarkDone.func1.1
//      runtime.gcMarkDone.func1
//      runtime.gcBgMarkWorker.func1
//      runtime.gcMarkRootPrepare.func1
//      runtime.preprintpanics.func1
//      runtime.main.func1
//      runtime.main.func2
//      runtime.casgstatus.func2
//      runtime.exitsyscall.func1
//      runtime.morestackc.func1
//      runtime.init
//      runtime.call16
//      runtime.call32
//      runtime.call64
//      runtime.call128
//      runtime.call256
//      runtime.call512
//      runtime.call1024
//      runtime.call2048
//      runtime.call4096
//      runtime.call8192
//      runtime.call16384
//      runtime.call32768
//      runtime.call65536
//      runtime.call131072
//      runtime.call262144
//      runtime.call524288
//      runtime.call1048576
//      runtime.call2097152
//      runtime.call4194304
//      runtime.call8388608
//      runtime.call16777216
//      runtime.call33554432
//      runtime.call67108864
//      runtime.call134217728
//      runtime.call268435456
//      runtime.call536870912
//      runtime.call1073741824
//      runtime.emptyfunc
//      type..hash.runtime._func
//      type..eq.runtime._func
//      type..hash.runtime.uncommontype
//      type..eq.runtime.uncommontype
//      type..hash.runtime.modulehash
//      type..eq.runtime.modulehash
//      type..hash.runtime.Frame
//      type..eq.runtime.Frame
//      type..hash.runtime.MemStats
//      type..eq.runtime.MemStats
//      type..hash.runtime.TypeAssertionError
//      type..eq.runtime.TypeAssertionError
//      type..hash.runtime._panic
//      type..eq.runtime._panic
//      type..hash.runtime._defer
//      type..eq.runtime._defer
//      type..hash.runtime.special
//      type..eq.runtime.special
//      type..hash.runtime.markBits
//      type..eq.runtime.markBits
//      type..hash.runtime.hchan
//      type..eq.runtime.hchan
//      type..hash.runtime.cpuProfile
//      type..eq.runtime.cpuProfile
//      type..hash.runtime.dbgVar
//      type..eq.runtime.dbgVar
//      runtime.(*errorString).Error
//      type..hash.runtime.finblock
//      type..eq.runtime.finblock
//      type..hash.runtime.gcControllerState
//      type..eq.runtime.gcControllerState
//      type..hash.runtime.mcentral
//      type..eq.runtime.mcentral
//      type..hash.struct { runtime.mcentral runtime.mcentral; runtime.pad [32]uint8 }
//      type..eq.struct { runtime.mcentral runtime.mcentral; runtime.pad [32]uint8 }
//      type..hash.[134]struct { runtime.mcentral runtime.mcentral; runtime.pad [32]uint8 }
//      type..eq.[134]struct { runtime.mcentral runtime.mcentral; runtime.pad [32]uint8 }
//      type..hash.runtime.mstats
//      type..eq.runtime.mstats
//      runtime.(*plainError).Error
//      type..hash.runtime.sigTabT
//      type..eq.runtime.sigTabT
//      type..hash.runtime.stackmap
//      type..eq.runtime.stackmap
//      type..hash.runtime.sweepdata
//      type..eq.runtime.sweepdata
//      type..hash.runtime.traceStack
//      type..eq.runtime.traceStack
//      type..hash.[14]runtime.dbgVar
//      type..eq.[14]runtime.dbgVar
//      type..hash.[2]string
//      type..eq.[2]string
//      type..hash.[33]float64
//      type..eq.[33]float64
//      type..hash.[3]string
//      type..eq.[3]string
//      type..hash.[4]string
//      type..eq.[4]string
//      type..hash.[5]string
//      type..eq.[5]string
//      type..hash.[65]runtime.sigTabT
//      type..eq.[65]runtime.sigTabT
//      type..hash.[6]string
//      type..eq.[6]string
//      type..hash.[9]string
//      type..eq.[9]string
//      type..hash.struct { runtime.cycle uint32; runtime.flushed bool }
//      type..eq.struct { runtime.cycle uint32; runtime.flushed bool }
//      type..hash.struct { runtime.enabled bool; runtime.pad [3]uint8; runtime.needed bool; runtime.cgo bool; runtime.alignme uint64 }
//      type..eq.struct { runtime.enabled bool; runtime.pad [3]uint8; runtime.needed bool; runtime.cgo bool; runtime.alignme uint64 }
//      type..hash.struct { runtime.full runtime.lfstack; runtime.empty runtime.lfstack; runtime.pad0 [64]uint8; runtime.wbufSpans struct { runtime.lock runtime.mutex; runtime.free runtime.mSpanList; runtime.busy runtime.mSpanList }; _ uint32; runtime.bytesMarked uint64; runtime.markrootNext uint32; runtime.markrootJobs uint32; runtime.nproc uint32; runtime.tstart int64; runtime.nwait uint32; runtime.ndone uint32; runtime.alldone runtime.note; runtime.helperDrainBlock bool; runtime.nFlushCacheRoots int; runtime.nDataRoots int; runtime.nBSSRoots int; runtime.nSpanRoots int; runtime.nStackRoots int; runtime.markrootDone bool; runtime.startSema uint32; runtime.markDoneSema uint32; runtime.bgMarkReady runtime.note; runtime.bgMarkDone uint32; runtime.mode runtime.gcMode; runtime.userForced bool; runtime.totaltime int64; runtime.initialHeapLive uint64; runtime.assistQueue struct { runtime.lock runtime.mutex; runtime.head runtime.guintptr; runtime.tail runtime.guintptr }; runtime.sweepWaiters struct { runtime.lock runtime.mutex; runtime.head runtime.guintptr }; runtime.cycles uint32; runtime.stwprocs int32; runtime.maxprocs int32; runtime.tSweepTerm int64; runtime.tMark int64; runtime.tMarkTerm int64; runtime.tEnd int64; runtime.pauseNS int64; runtime.pauseStart int64; runtime.heap0 uint64; runtime.heap1 uint64; runtime.heap2 uint64; runtime.heapGoal uint64 }
//      type..eq.struct { runtime.full runtime.lfstack; runtime.empty runtime.lfstack; runtime.pad0 [64]uint8; runtime.wbufSpans struct { runtime.lock runtime.mutex; runtime.free runtime.mSpanList; runtime.busy runtime.mSpanList }; _ uint32; runtime.bytesMarked uint64; runtime.markrootNext uint32; runtime.markrootJobs uint32; runtime.nproc uint32; runtime.tstart int64; runtime.nwait uint32; runtime.ndone uint32; runtime.alldone runtime.note; runtime.helperDrainBlock bool; runtime.nFlushCacheRoots int; runtime.nDataRoots int; runtime.nBSSRoots int; runtime.nSpanRoots int; runtime.nStackRoots int; runtime.markrootDone bool; runtime.startSema uint32; runtime.markDoneSema uint32; runtime.bgMarkReady runtime.note; runtime.bgMarkDone uint32; runtime.mode runtime.gcMode; runtime.userForced bool; runtime.totaltime int64; runtime.initialHeapLive uint64; runtime.assistQueue struct { runtime.lock runtime.mutex; runtime.head runtime.guintptr; runtime.tail runtime.guintptr }; runtime.sweepWaiters struct { runtime.lock runtime.mutex; runtime.head runtime.guintptr }; runtime.cycles uint32; runtime.stwprocs int32; runtime.maxprocs int32; runtime.tSweepTerm int64; runtime.tMark int64; runtime.tMarkTerm int64; runtime.tEnd int64; runtime.pauseNS int64; runtime.pauseStart int64; runtime.heap0 uint64; runtime.heap1 uint64; runtime.heap2 uint64; runtime.heapGoal uint64 }
//      type..hash.struct { runtime.note runtime.note; runtime.mask [3]uint32; runtime.wanted [3]uint32; runtime.ignored [3]uint32; runtime.recv [3]uint32; runtime.state uint32; runtime.inuse bool }
//      type..eq.struct { runtime.note runtime.note; runtime.mask [3]uint32; runtime.wanted [3]uint32; runtime.ignored [3]uint32; runtime.recv [3]uint32; runtime.state uint32; runtime.inuse bool }
//      type..hash.struct { F uintptr; runtime.c *runtime.mcache; runtime.spc runtime.spanClass }
//      type..eq.struct { F uintptr; runtime.c *runtime.mcache; runtime.spc runtime.spanClass }
//      type..hash.struct { F uintptr; runtime.preemptible bool }
//      type..eq.struct { F uintptr; runtime.preemptible bool }
//      type..hash.struct { F uintptr; runtime.s **runtime.mspan; runtime.h *runtime.mheap; runtime.npage uintptr; runtime.spanclass runtime.spanClass; runtime.large bool }
//      type..eq.struct { F uintptr; runtime.s **runtime.mspan; runtime.h *runtime.mheap; runtime.npage uintptr; runtime.spanclass runtime.spanClass; runtime.large bool }
//      type..hash.struct { F uintptr; runtime.s **runtime.mspan; runtime.size *uintptr; runtime.needzero bool; runtime.noscan bool }
//      type..eq.struct { F uintptr; runtime.s **runtime.mspan; runtime.size *uintptr; runtime.needzero bool; runtime.noscan bool }
//      errors.New
//      errors.(*errorString).Error
//      unicode/utf8.DecodeRuneInString
//      unicode/utf8.EncodeRune
//      unicode/utf8.RuneCount
//      unicode/utf8.RuneCountInString
//      strconv.(*decimal).String
//      strconv.digitZero
//      strconv.trim
//      strconv.(*decimal).Assign
//      strconv.rightShift
//      strconv.prefixIsLessThan
//      strconv.leftShift
//      strconv.(*decimal).Shift
//      strconv.(*decimal).Round
//      strconv.(*decimal).RoundDown
//      strconv.(*decimal).RoundUp
//      strconv.(*extFloat).AssignComputeBounds
//      strconv.(*extFloat).Normalize
//      strconv.(*extFloat).Multiply
//      strconv.(*extFloat).frexp10
//      strconv.frexp10Many
//      strconv.(*extFloat).FixedDecimal
//      strconv.adjustLastDigitFixed
//      strconv.(*extFloat).ShortestDecimal
//      strconv.adjustLastDigit
//      strconv.AppendFloat
//      strconv.genericFtoa
//      strconv.bigFtoa
//      strconv.formatDigits
//      strconv.roundShortest
//      strconv.fmtE
//      strconv.fmtF
//      strconv.fmtB
//      strconv.FormatInt
//      strconv.Itoa
//      strconv.formatBits
//      strconv.appendQuotedWith
//      strconv.appendQuotedRuneWith
//      strconv.appendEscapedRune
//      strconv.AppendQuote
//      strconv.AppendQuoteToASCII
//      strconv.AppendQuoteRune
//      strconv.AppendQuoteRuneToASCII
//      strconv.CanBackquote
//      strconv.bsearch16
//      strconv.bsearch32
//      strconv.IsPrint
//      strconv.isInGraphicList
//      strconv.init
//      type..hash.strconv.decimal
//      type..eq.strconv.decimal
//      type..hash.strconv.extFloat
//      type..eq.strconv.extFloat
//      type..hash.strconv.leftCheat
//      type..eq.strconv.leftCheat
//      type..hash.[61]strconv.leftCheat
//      type..eq.[61]strconv.leftCheat
//      type..hash.[87]strconv.extFloat
//      type..eq.[87]strconv.extFloat
//      sync.(*Map).Load
//      sync.(*entry).load
//      sync.(*Map).Store
//      sync.(*entry).tryStore
//      sync.(*entry).unexpungeLocked
//      sync.(*entry).storeLocked
//      sync.(*Map).LoadOrStore
//      sync.(*entry).tryLoadOrStore
//      sync.(*Map).missLocked
//      sync.(*Map).dirtyLocked
//      sync.(*entry).tryExpungeLocked
//      sync.(*Mutex).Lock
//      sync.(*Mutex).Unlock
//      sync.(*Once).Do
//      sync.(*Pool).Put
//      sync.(*Pool).Get
//      sync.(*Pool).getSlow
//      sync.(*Pool).pin
//      sync.(*Pool).pinSlow
//      sync.poolCleanup
//      sync.init.0
//      sync.init.1
//      sync.init
//      io.init
//      syscall.SetNonblock
//      syscall.init.0
//      syscall.itoa
//      syscall.uitoa
//      syscall.ByteSliceFromString
//      syscall.BytePtrFromString
//      syscall.Readlink
//      syscall.mmap
//      syscall.Errno.Error
//      syscall.Write
//      syscall.readlinkat
//      syscall.Close
//      syscall.fcntl
//      syscall.write
//      syscall.munmap
//      syscall.mmap2
//      syscall.init
//      syscall.(*Errno).Error
//      type..hash.[133]string
//      type..eq.[133]string
//      time.init
//      internal/poll.(*TimeoutError).Error
//      internal/poll.(*fdMutex).increfAndClose
//      internal/poll.(*fdMutex).decref
//      internal/poll.(*fdMutex).rwlock
//      internal/poll.(*fdMutex).rwunlock
//      internal/poll.(*FD).decref
//      internal/poll.(*FD).writeLock
//      internal/poll.(*FD).writeUnlock
//      internal/poll.(*pollDesc).init
//      internal/poll.(*pollDesc).close
//      internal/poll.(*pollDesc).evict
//      internal/poll.(*pollDesc).prepare
//      internal/poll.(*pollDesc).prepareWrite
//      internal/poll.(*pollDesc).wait
//      internal/poll.(*pollDesc).waitWrite
//      internal/poll.convertErr
//      internal/poll.(*FD).Init
//      internal/poll.(*FD).destroy
//      internal/poll.(*FD).Close
//      internal/poll.(*FD).Write
//      internal/poll.init
//      type..hash.internal/poll.FD
//      type..eq.internal/poll.FD
//      os.(*PathError).Error
//      os.(*File).Name
//      os.(*File).Write
//      os.Readlink
//      os.NewFile
//      os.newFile
//      os.epipecheck
//      os.(*file).close
//      os.(*File).write
//      os.init.0
//      os.glob..func1
//      os.init
//      type..hash.os.file
//      type..eq.os.file
//      type..hash.os.PathError
//      type..eq.os.PathError
//      unicode.init
//      reflect.makeMethodValue
//      reflect.name.tagLen
//      reflect.name.tag
//      reflect.name.pkgPath
//      reflect.newName
//      reflect.Kind.String
//      reflect.resolveReflectName
//      reflect.(*rtype).nameOff
//      reflect.(*rtype).typeOff
//      reflect.(*rtype).textOff
//      reflect.(*rtype).uncommon
//      reflect.(*rtype).String
//      reflect.(*rtype).exportedMethods
//      reflect.(*rtype).NumMethod
//      reflect.(*rtype).Method
//      reflect.(*rtype).Name
//      reflect.(*rtype).ChanDir
//      reflect.(*rtype).Elem
//      reflect.(*rtype).In
//      reflect.(*rtype).Key
//      reflect.(*rtype).Len
//      reflect.(*rtype).NumIn
//      reflect.(*rtype).NumOut
//      reflect.(*rtype).Out
//      reflect.ChanDir.String
//      reflect.(*interfaceType).Method
//      reflect.(*interfaceType).NumMethod
//      reflect.(*interfaceType).MethodByName
//      reflect.(*structType).Field
//      reflect.(*structType).FieldByIndex
//      reflect.(*structType).FieldByNameFunc
//      reflect.(*structType).FieldByName
//      reflect.TypeOf
//      reflect.(*rtype).ptrTo
//      reflect.fnv1
//      reflect.implements
//      reflect.directlyAssignable
//      reflect.haveIdenticalType
//      reflect.haveIdenticalUnderlyingType
//      reflect.typesByString
//      reflect.FuncOf
//      reflect.funcStr
//      reflect.funcLayout
//      reflect.addTypeBits
//      reflect.Value.pointer
//      reflect.packEface
//      reflect.(*ValueError).Error
//      reflect.methodName
//      reflect.flag.mustBe
//      reflect.flag.mustBeAssignable
//      reflect.Value.Bool
//      reflect.Value.Bytes
//      reflect.Value.runes
//      reflect.methodReceiver
//      reflect.callMethod
//      reflect.Value.Complex
//      reflect.Value.Elem
//      reflect.Value.Field
//      reflect.Value.Float
//      reflect.Value.Index
//      reflect.Value.Int
//      reflect.Value.CanInterface
//      reflect.Value.Interface
//      reflect.valueInterface
//      reflect.Value.IsNil
//      reflect.Value.Kind
//      reflect.Value.Len
//      reflect.Value.MapIndex
//      reflect.Value.MapKeys
//      reflect.Value.NumMethod
//      reflect.Value.NumField
//      reflect.Value.Pointer
//      reflect.Value.SetBytes
//      reflect.Value.setRunes
//      reflect.Value.SetString
//      reflect.Value.Slice
//      reflect.Value.String
//      reflect.Value.Type
//      reflect.Value.Uint
//      reflect.ValueOf
//      reflect.Zero
//      reflect.New
//      reflect.Value.assignTo
//      reflect.convertOp
//      reflect.makeInt
//      reflect.makeFloat
//      reflect.makeComplex
//      reflect.makeString
//      reflect.makeBytes
//      reflect.makeRunes
//      reflect.cvtInt
//      reflect.cvtUint
//      reflect.cvtFloatInt
//      reflect.cvtFloatUint
//      reflect.cvtIntFloat
//      reflect.cvtUintFloat
//      reflect.cvtFloat
//      reflect.cvtComplex
//      reflect.cvtIntString
//      reflect.cvtUintString
//      reflect.cvtBytesString
//      reflect.cvtStringBytes
//      reflect.cvtRunesString
//      reflect.cvtStringRunes
//      reflect.cvtDirect
//      reflect.cvtT2I
//      reflect.cvtI2I
//      reflect.init
//      reflect.(*ChanDir).String
//      reflect.(*Kind).String
//      type..hash.reflect.uncommonType
//      type..eq.reflect.uncommonType
//      reflect.(*Value).Kind
//      reflect.(*Value).Len
//      reflect.(*Value).NumMethod
//      reflect.(*Value).NumField
//      reflect.(*Value).String
//      type..hash.reflect.Method
//      type..eq.reflect.Method
//      type..hash.reflect.ValueError
//      type..eq.reflect.ValueError
//      reflect.(*structType).uncommon
//      reflect.(*structType).String
//      reflect.(*structType).Size
//      reflect.(*structType).Bits
//      reflect.(*structType).Align
//      reflect.(*structType).FieldAlign
//      reflect.(*structType).Kind
//      reflect.(*structType).common
//      reflect.(*structType).NumMethod
//      reflect.(*structType).Method
//      reflect.(*structType).MethodByName
//      reflect.(*structType).PkgPath
//      reflect.(*structType).Name
//      reflect.(*structType).ChanDir
//      reflect.(*structType).IsVariadic
//      reflect.(*structType).Elem
//      reflect.(*structType).In
//      reflect.(*structType).Key
//      reflect.(*structType).Len
//      reflect.(*structType).NumField
//      reflect.(*structType).NumIn
//      reflect.(*structType).NumOut
//      reflect.(*structType).Out
//      reflect.(*structType).Implements
//      reflect.(*structType).AssignableTo
//      reflect.(*structType).ConvertibleTo
//      reflect.(*structType).Comparable
//      reflect.(*funcType).uncommon
//      reflect.(*funcType).String
//      reflect.(*funcType).Size
//      reflect.(*funcType).Bits
//      reflect.(*funcType).Align
//      reflect.(*funcType).FieldAlign
//      reflect.(*funcType).Kind
//      reflect.(*funcType).common
//      reflect.(*funcType).NumMethod
//      reflect.(*funcType).Method
//      reflect.(*funcType).MethodByName
//      reflect.(*funcType).PkgPath
//      reflect.(*funcType).Name
//      reflect.(*funcType).ChanDir
//      reflect.(*funcType).IsVariadic
//      reflect.(*funcType).Elem
//      reflect.(*funcType).Field
//      reflect.(*funcType).FieldByIndex
//      reflect.(*funcType).FieldByName
//      reflect.(*funcType).FieldByNameFunc
//      reflect.(*funcType).In
//      reflect.(*funcType).Key
//      reflect.(*funcType).Len
//      reflect.(*funcType).NumField
//      reflect.(*funcType).NumIn
//      reflect.(*funcType).NumOut
//      reflect.(*funcType).Out
//      reflect.(*funcType).Implements
//      reflect.(*funcType).AssignableTo
//      reflect.(*funcType).ConvertibleTo
//      reflect.(*funcType).Comparable
//      reflect.(*funcTypeFixed128).uncommon
//      reflect.(*funcTypeFixed128).String
//      reflect.(*funcTypeFixed128).Size
//      reflect.(*funcTypeFixed128).Bits
//      reflect.(*funcTypeFixed128).Align
//      reflect.(*funcTypeFixed128).FieldAlign
//      reflect.(*funcTypeFixed128).Kind
//      reflect.(*funcTypeFixed128).common
//      reflect.(*funcTypeFixed128).NumMethod
//      reflect.(*funcTypeFixed128).Method
//      reflect.(*funcTypeFixed128).MethodByName
//      reflect.(*funcTypeFixed128).PkgPath
//      reflect.(*funcTypeFixed128).Name
//      reflect.(*funcTypeFixed128).ChanDir
//      reflect.(*funcTypeFixed128).IsVariadic
//      reflect.(*funcTypeFixed128).Elem
//      reflect.(*funcTypeFixed128).Field
//      reflect.(*funcTypeFixed128).FieldByIndex
//      reflect.(*funcTypeFixed128).FieldByName
//      reflect.(*funcTypeFixed128).FieldByNameFunc
//      reflect.(*funcTypeFixed128).In
//      reflect.(*funcTypeFixed128).Key
//      reflect.(*funcTypeFixed128).Len
//      reflect.(*funcTypeFixed128).NumField
//      reflect.(*funcTypeFixed128).NumIn
//      reflect.(*funcTypeFixed128).NumOut
//      reflect.(*funcTypeFixed128).Out
//      reflect.(*funcTypeFixed128).Implements
//      reflect.(*funcTypeFixed128).AssignableTo
//      reflect.(*funcTypeFixed128).ConvertibleTo
//      reflect.(*funcTypeFixed128).Comparable
//      reflect.(*funcTypeFixed16).uncommon
//      reflect.(*funcTypeFixed16).String
//      reflect.(*funcTypeFixed16).Size
//      reflect.(*funcTypeFixed16).Bits
//      reflect.(*funcTypeFixed16).Align
//      reflect.(*funcTypeFixed16).FieldAlign
//      reflect.(*funcTypeFixed16).Kind
//      reflect.(*funcTypeFixed16).common
//      reflect.(*funcTypeFixed16).NumMethod
//      reflect.(*funcTypeFixed16).Method
//      reflect.(*funcTypeFixed16).MethodByName
//      reflect.(*funcTypeFixed16).PkgPath
//      reflect.(*funcTypeFixed16).Name
//      reflect.(*funcTypeFixed16).ChanDir
//      reflect.(*funcTypeFixed16).IsVariadic
//      reflect.(*funcTypeFixed16).Elem
//      reflect.(*funcTypeFixed16).Field
//      reflect.(*funcTypeFixed16).FieldByIndex
//      reflect.(*funcTypeFixed16).FieldByName
//      reflect.(*funcTypeFixed16).FieldByNameFunc
//      reflect.(*funcTypeFixed16).In
//      reflect.(*funcTypeFixed16).Key
//      reflect.(*funcTypeFixed16).Len
//      reflect.(*funcTypeFixed16).NumField
//      reflect.(*funcTypeFixed16).NumIn
//      reflect.(*funcTypeFixed16).NumOut
//      reflect.(*funcTypeFixed16).Out
//      reflect.(*funcTypeFixed16).Implements
//      reflect.(*funcTypeFixed16).AssignableTo
//      reflect.(*funcTypeFixed16).ConvertibleTo
//      reflect.(*funcTypeFixed16).Comparable
//      reflect.(*funcTypeFixed32).uncommon
//      reflect.(*funcTypeFixed32).String
//      reflect.(*funcTypeFixed32).Size
//      reflect.(*funcTypeFixed32).Bits
//      reflect.(*funcTypeFixed32).Align
//      reflect.(*funcTypeFixed32).FieldAlign
//      reflect.(*funcTypeFixed32).Kind
//      reflect.(*funcTypeFixed32).common
//      reflect.(*funcTypeFixed32).NumMethod
//      reflect.(*funcTypeFixed32).Method
//      reflect.(*funcTypeFixed32).MethodByName
//      reflect.(*funcTypeFixed32).PkgPath
//      reflect.(*funcTypeFixed32).Name
//      reflect.(*funcTypeFixed32).ChanDir
//      reflect.(*funcTypeFixed32).IsVariadic
//      reflect.(*funcTypeFixed32).Elem
//      reflect.(*funcTypeFixed32).Field
//      reflect.(*funcTypeFixed32).FieldByIndex
//      reflect.(*funcTypeFixed32).FieldByName
//      reflect.(*funcTypeFixed32).FieldByNameFunc
//      reflect.(*funcTypeFixed32).In
//      reflect.(*funcTypeFixed32).Key
//      reflect.(*funcTypeFixed32).Len
//      reflect.(*funcTypeFixed32).NumField
//      reflect.(*funcTypeFixed32).NumIn
//      reflect.(*funcTypeFixed32).NumOut
//      reflect.(*funcTypeFixed32).Out
//      reflect.(*funcTypeFixed32).Implements
//      reflect.(*funcTypeFixed32).AssignableTo
//      reflect.(*funcTypeFixed32).ConvertibleTo
//      reflect.(*funcTypeFixed32).Comparable
//      reflect.(*funcTypeFixed4).uncommon
//      reflect.(*funcTypeFixed4).String
//      reflect.(*funcTypeFixed4).Size
//      reflect.(*funcTypeFixed4).Bits
//      reflect.(*funcTypeFixed4).Align
//      reflect.(*funcTypeFixed4).FieldAlign
//      reflect.(*funcTypeFixed4).Kind
//      reflect.(*funcTypeFixed4).common
//      reflect.(*funcTypeFixed4).NumMethod
//      reflect.(*funcTypeFixed4).Method
//      reflect.(*funcTypeFixed4).MethodByName
//      reflect.(*funcTypeFixed4).PkgPath
//      reflect.(*funcTypeFixed4).Name
//      reflect.(*funcTypeFixed4).ChanDir
//      reflect.(*funcTypeFixed4).IsVariadic
//      reflect.(*funcTypeFixed4).Elem
//      reflect.(*funcTypeFixed4).Field
//      reflect.(*funcTypeFixed4).FieldByIndex
//      reflect.(*funcTypeFixed4).FieldByName
//      reflect.(*funcTypeFixed4).FieldByNameFunc
//      reflect.(*funcTypeFixed4).In
//      reflect.(*funcTypeFixed4).Key
//      reflect.(*funcTypeFixed4).Len
//      reflect.(*funcTypeFixed4).NumField
//      reflect.(*funcTypeFixed4).NumIn
//      reflect.(*funcTypeFixed4).NumOut
//      reflect.(*funcTypeFixed4).Out
//      reflect.(*funcTypeFixed4).Implements
//      reflect.(*funcTypeFixed4).AssignableTo
//      reflect.(*funcTypeFixed4).ConvertibleTo
//      reflect.(*funcTypeFixed4).Comparable
//      reflect.(*funcTypeFixed64).uncommon
//      reflect.(*funcTypeFixed64).String
//      reflect.(*funcTypeFixed64).Size
//      reflect.(*funcTypeFixed64).Bits
//      reflect.(*funcTypeFixed64).Align
//      reflect.(*funcTypeFixed64).FieldAlign
//      reflect.(*funcTypeFixed64).Kind
//      reflect.(*funcTypeFixed64).common
//      reflect.(*funcTypeFixed64).NumMethod
//      reflect.(*funcTypeFixed64).Method
//      reflect.(*funcTypeFixed64).MethodByName
//      reflect.(*funcTypeFixed64).PkgPath
//      reflect.(*funcTypeFixed64).Name
//      reflect.(*funcTypeFixed64).ChanDir
//      reflect.(*funcTypeFixed64).IsVariadic
//      reflect.(*funcTypeFixed64).Elem
//      reflect.(*funcTypeFixed64).Field
//      reflect.(*funcTypeFixed64).FieldByIndex
//      reflect.(*funcTypeFixed64).FieldByName
//      reflect.(*funcTypeFixed64).FieldByNameFunc
//      reflect.(*funcTypeFixed64).In
//      reflect.(*funcTypeFixed64).Key
//      reflect.(*funcTypeFixed64).Len
//      reflect.(*funcTypeFixed64).NumField
//      reflect.(*funcTypeFixed64).NumIn
//      reflect.(*funcTypeFixed64).NumOut
//      reflect.(*funcTypeFixed64).Out
//      reflect.(*funcTypeFixed64).Implements
//      reflect.(*funcTypeFixed64).AssignableTo
//      reflect.(*funcTypeFixed64).ConvertibleTo
//      reflect.(*funcTypeFixed64).Comparable
//      reflect.(*funcTypeFixed8).uncommon
//      reflect.(*funcTypeFixed8).String
//      reflect.(*funcTypeFixed8).Size
//      reflect.(*funcTypeFixed8).Bits
//      reflect.(*funcTypeFixed8).Align
//      reflect.(*funcTypeFixed8).FieldAlign
//      reflect.(*funcTypeFixed8).Kind
//      reflect.(*funcTypeFixed8).common
//      reflect.(*funcTypeFixed8).NumMethod
//      reflect.(*funcTypeFixed8).Method
//      reflect.(*funcTypeFixed8).MethodByName
//      reflect.(*funcTypeFixed8).PkgPath
//      reflect.(*funcTypeFixed8).Name
//      reflect.(*funcTypeFixed8).ChanDir
//      reflect.(*funcTypeFixed8).IsVariadic
//      reflect.(*funcTypeFixed8).Elem
//      reflect.(*funcTypeFixed8).Field
//      reflect.(*funcTypeFixed8).FieldByIndex
//      reflect.(*funcTypeFixed8).FieldByName
//      reflect.(*funcTypeFixed8).FieldByNameFunc
//      reflect.(*funcTypeFixed8).In
//      reflect.(*funcTypeFixed8).Key
//      reflect.(*funcTypeFixed8).Len
//      reflect.(*funcTypeFixed8).NumField
//      reflect.(*funcTypeFixed8).NumIn
//      reflect.(*funcTypeFixed8).NumOut
//      reflect.(*funcTypeFixed8).Out
//      reflect.(*funcTypeFixed8).Implements
//      reflect.(*funcTypeFixed8).AssignableTo
//      reflect.(*funcTypeFixed8).ConvertibleTo
//      reflect.(*funcTypeFixed8).Comparable
//      reflect.(*interfaceType).uncommon
//      reflect.(*interfaceType).String
//      reflect.(*interfaceType).Size
//      reflect.(*interfaceType).Bits
//      reflect.(*interfaceType).Align
//      reflect.(*interfaceType).FieldAlign
//      reflect.(*interfaceType).Kind
//      reflect.(*interfaceType).common
//      reflect.(*interfaceType).PkgPath
//      reflect.(*interfaceType).Name
//      reflect.(*interfaceType).ChanDir
//      reflect.(*interfaceType).IsVariadic
//      reflect.(*interfaceType).Elem
//      reflect.(*interfaceType).Field
//      reflect.(*interfaceType).FieldByIndex
//      reflect.(*interfaceType).FieldByName
//      reflect.(*interfaceType).FieldByNameFunc
//      reflect.(*interfaceType).In
//      reflect.(*interfaceType).Key
//      reflect.(*interfaceType).Len
//      reflect.(*interfaceType).NumField
//      reflect.(*interfaceType).NumIn
//      reflect.(*interfaceType).NumOut
//      reflect.(*interfaceType).Out
//      reflect.(*interfaceType).Implements
//      reflect.(*interfaceType).AssignableTo
//      reflect.(*interfaceType).ConvertibleTo
//      reflect.(*interfaceType).Comparable
//      reflect.(*ptrType).uncommon
//      reflect.(*ptrType).String
//      reflect.(*ptrType).Size
//      reflect.(*ptrType).Bits
//      reflect.(*ptrType).Align
//      reflect.(*ptrType).FieldAlign
//      reflect.(*ptrType).Kind
//      reflect.(*ptrType).common
//      reflect.(*ptrType).NumMethod
//      reflect.(*ptrType).Method
//      reflect.(*ptrType).MethodByName
//      reflect.(*ptrType).PkgPath
//      reflect.(*ptrType).Name
//      reflect.(*ptrType).ChanDir
//      reflect.(*ptrType).IsVariadic
//      reflect.(*ptrType).Elem
//      reflect.(*ptrType).Field
//      reflect.(*ptrType).FieldByIndex
//      reflect.(*ptrType).FieldByName
//      reflect.(*ptrType).FieldByNameFunc
//      reflect.(*ptrType).In
//      reflect.(*ptrType).Key
//      reflect.(*ptrType).Len
//      reflect.(*ptrType).NumField
//      reflect.(*ptrType).NumIn
//      reflect.(*ptrType).NumOut
//      reflect.(*ptrType).Out
//      reflect.(*ptrType).Implements
//      reflect.(*ptrType).AssignableTo
//      reflect.(*ptrType).ConvertibleTo
//      reflect.(*ptrType).Comparable
//      reflect.(*sliceType).uncommon
//      reflect.(*sliceType).String
//      reflect.(*sliceType).Size
//      reflect.(*sliceType).Bits
//      reflect.(*sliceType).Align
//      reflect.(*sliceType).FieldAlign
//      reflect.(*sliceType).Kind
//      reflect.(*sliceType).common
//      reflect.(*sliceType).NumMethod
//      reflect.(*sliceType).Method
//      reflect.(*sliceType).MethodByName
//      reflect.(*sliceType).PkgPath
//      reflect.(*sliceType).Name
//      reflect.(*sliceType).ChanDir
//      reflect.(*sliceType).IsVariadic
//      reflect.(*sliceType).Elem
//      reflect.(*sliceType).Field
//      reflect.(*sliceType).FieldByIndex
//      reflect.(*sliceType).FieldByName
//      reflect.(*sliceType).FieldByNameFunc
//      reflect.(*sliceType).In
//      reflect.(*sliceType).Key
//      reflect.(*sliceType).Len
//      reflect.(*sliceType).NumField
//      reflect.(*sliceType).NumIn
//      reflect.(*sliceType).NumOut
//      reflect.(*sliceType).Out
//      reflect.(*sliceType).Implements
//      reflect.(*sliceType).AssignableTo
//      reflect.(*sliceType).ConvertibleTo
//      reflect.(*sliceType).Comparable
//      type..hash.[27]string
//      type..eq.[27]string
//      type..hash.struct { reflect.b bool; reflect.x interface {} }
//      type..eq.struct { reflect.b bool; reflect.x interface {} }
//      type..hash.struct { F uintptr; reflect.name string }
//      type..eq.struct { F uintptr; reflect.name string }
//      fmt.(*fmt).writePadding
//      fmt.(*fmt).pad
//      fmt.(*fmt).padString
//      fmt.(*fmt).fmt_boolean
//      fmt.(*fmt).fmt_unicode
//      fmt.(*fmt).fmt_integer
//      fmt.(*fmt).truncate
//      fmt.(*fmt).fmt_s
//      fmt.(*fmt).fmt_sbx
//      fmt.(*fmt).fmt_sx
//      fmt.(*fmt).fmt_bx
//      fmt.(*fmt).fmt_q
//      fmt.(*fmt).fmt_c
//      fmt.(*fmt).fmt_qc
//      fmt.(*fmt).fmt_float
//      fmt.(*buffer).WriteRune
//      fmt.newPrinter
//      fmt.(*pp).free
//      fmt.(*pp).Width
//      fmt.(*pp).Precision
//      fmt.(*pp).Flag
//      fmt.(*pp).Write
//      fmt.Fprintln
//      fmt.Println
//      fmt.getField
//      fmt.(*pp).unknownType
//      fmt.(*pp).badVerb
//      fmt.(*pp).fmtBool
//      fmt.(*pp).fmt0x64
//      fmt.(*pp).fmtInteger
//      fmt.(*pp).fmtFloat
//      fmt.(*pp).fmtComplex
//      fmt.(*pp).fmtString
//      fmt.(*pp).fmtBytes
//      fmt.(*pp).fmtPointer
//      fmt.(*pp).catchPanic
//      fmt.(*pp).handleMethods
//      fmt.(*pp).printArg
//      fmt.(*pp).printValue
//      fmt.(*pp).doPrintln
//      fmt.glob..func1
//      fmt.init
//      type..hash.fmt.fmt
//      type..eq.fmt.fmt
//      main.main
//      main.init
Eq_4 runtime.morestack_noctxt()
{
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	Eq_4 stackArg0 = <invalid>;
	Eq_4 stackArg4 = <invalid>;
	word32 ebx_17;
	word32 esi_18;
	return runtime.morestack(edx, gs, stackArg0, stackArg4, out ebx_17, out esi_18);
}

// 0808E200: void reflect.call(Stack Eq_4 dwArg10)
// Called from:
//      reflect.callMethod
void reflect.call(Eq_4 dwArg10)
{
	runtime.reflectcall(dwArg10);
}

// 0808E210: void runtime.reflectcall(Stack Eq_4 dwArg10)
// Called from:
//      runtime.cgocallbackg1
//      runtime.runfinq
//      runtime.gopanic
//      reflect.call
void runtime.reflectcall(Eq_4 dwArg10)
{
	if (dwArg10 > 0x10)
	{
		if (dwArg10 > 0x20)
		{
			if (dwArg10 > 0x40)
			{
				if (dwArg10 > 0x80)
				{
					if (dwArg10 > 0x0100)
					{
						if (dwArg10 > 0x0200)
						{
							if (dwArg10 > 0x0400)
							{
								if (dwArg10 > 0x0800)
								{
									if (dwArg10 > 0x1000)
									{
										if (dwArg10 > 0x2000)
										{
											if (dwArg10 > 0x4000)
											{
												if (dwArg10 > 0x8000)
												{
													if (dwArg10 > 0x00010000)
													{
														if (dwArg10 > 0x00020000)
														{
															if (dwArg10 > 0x00040000)
															{
																if (dwArg10 > 0x00080000)
																{
																	if (dwArg10 > 0x00100000)
																	{
																		if (dwArg10 > 0x00200000)
																		{
																			if (dwArg10 > 0x00400000)
																			{
																				if (dwArg10 > 0x00800000)
																				{
																					if (dwArg10 > 0x01000000)
																					{
																						if (dwArg10 > 0x02000000)
																						{
																							if (dwArg10 > 0x04000000)
																							{
																								if (dwArg10 > 0x08000000)
																								{
																									if (dwArg10 > 0x10000000)
																									{
																										if (dwArg10 > 0x20000000)
																										{
																											if (dwArg10 > 0x40000000)
																											{
																												word32 eax_62;
																												g_t806E060();
																											}
																											else
																											{
																												word32 eax_66;
																												g_t808F320();
																											}
																										}
																										else
																										{
																											word32 eax_70;
																											g_t808F280();
																										}
																									}
																									else
																									{
																										word32 eax_74;
																										g_t808F1E0();
																									}
																								}
																								else
																								{
																									word32 eax_78;
																									g_t808F140();
																								}
																							}
																							else
																							{
																								word32 eax_82;
																								g_t808F0A0();
																							}
																						}
																						else
																						{
																							word32 eax_86;
																							g_t808F000();
																						}
																					}
																					else
																					{
																						word32 eax_90;
																						g_t808EF60();
																					}
																				}
																				else
																				{
																					word32 eax_94;
																					g_t808EEC0();
																				}
																			}
																			else
																			{
																				word32 eax_98;
																				g_t808EE20();
																			}
																		}
																		else
																		{
																			word32 eax_102;
																			g_t808ED80();
																		}
																	}
																	else
																	{
																		word32 eax_106;
																		g_t808ECE0();
																	}
																}
																else
																{
																	word32 eax_110;
																	g_t808EC40();
																}
															}
															else
															{
																word32 eax_114;
																g_t808EBA0();
															}
														}
														else
														{
															word32 eax_118;
															g_t808EB00();
														}
													}
													else
													{
														word32 eax_122;
														g_t808EA60();
													}
												}
												else
												{
													word32 eax_126;
													g_t808E9C0();
												}
											}
											else
											{
												word32 eax_130;
												g_t808E920();
											}
										}
										else
										{
											word32 eax_134;
											g_t808E880();
										}
									}
									else
									{
										word32 eax_138;
										g_t808E7F0();
									}
								}
								else
								{
									word32 eax_142;
									g_t808E760();
								}
							}
							else
							{
								word32 eax_146;
								g_t808E6D0();
							}
						}
						else
						{
							word32 eax_150;
							g_t808E640();
						}
					}
					else
					{
						word32 eax_154;
						g_t808E5B0();
					}
				}
				else
				{
					word32 eax_158;
					g_t808E520();
				}
			}
			else
			{
				word32 eax_162;
				g_t808E4B0();
			}
		}
		else
		{
			word32 eax_166;
			g_t808E440();
		}
	}
	else
	{
		word32 eax_170;
		g_t808E3D0();
	}
}

// 0808E3B0: void callRet(Register Eq_4 ecx, Register (ptr32 Eq_15434) edx, Register Eq_4 esi, Register Eq_4 edi, Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.call16
//      runtime.call32
//      runtime.call64
//      runtime.call128
//      runtime.call256
//      runtime.call512
//      runtime.call1024
//      runtime.call2048
//      runtime.call4096
//      runtime.call8192
//      runtime.call16384
//      runtime.call32768
//      runtime.call65536
//      runtime.call131072
//      runtime.call262144
//      runtime.call524288
//      runtime.call1048576
//      runtime.call2097152
//      runtime.call4194304
//      runtime.call8388608
//      runtime.call16777216
//      runtime.call33554432
//      runtime.call67108864
//      runtime.call134217728
//      runtime.call268435456
//      runtime.call536870912
//      runtime.call1073741824
void callRet(Eq_4 ecx, struct Eq_15434 * edx, Eq_4 esi, Eq_4 edi, struct Eq_2 * gs)
{
	runtime.reflectcallmove(gs, edx, edi, esi, ecx);
}

// 0808E3D0: void runtime.call16(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_15434) dwArg04, Stack (ptr32 (ptr32 code)) dwArg08, Stack (ptr32 byte) dwArg0C, Stack word32 dwArg10, Stack int32 dwArg14)
void runtime.call16(struct Eq_2 * gs, struct Eq_15434 * dwArg04, <anonymous> ** dwArg08, byte * dwArg0C, word32 dwArg10, int32 dwArg14)
{
	while (true)
	{
		Eq_4 ecx_7 = gs->ptr0000->tFFFFFFFC;
		if (fp > *((word32) ecx_7 + 8))
			break;
		runtime.morestack_noctxt();
	}
	Eq_4 ebx_17 = *((word32) ecx_7 + 16);
	if (ebx_17 != 0x00 && *ebx_17 == (word32) fp + 4)
		*ebx_17 = fp - 0x10;
	byte * esi_27 = dwArg0C;
	word32 ecx_28;
	byte * edi_29 = fp - 0x10;
	for (ecx_28 = dwArg10; ecx_28 != 0x00; --ecx_28)
	{
		*edi_29 = *esi_27;
		++esi_27;
		++edi_29;
	}
	(*dwArg08)();
	callRet(dwArg10 - dwArg14, dwArg04, fp - 0x10 + dwArg14, dwArg0C + dwArg14, gs);
}

// 0808E440: void runtime.call32(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_15434) dwArg04, Stack (ptr32 (ptr32 code)) dwArg08, Stack (ptr32 byte) dwArg0C, Stack word32 dwArg10, Stack int32 dwArg14)
void runtime.call32(struct Eq_2 * gs, struct Eq_15434 * dwArg04, <anonymous> ** dwArg08, byte * dwArg0C, word32 dwArg10, int32 dwArg14)
{
	while (true)
	{
		Eq_4 ecx_7 = gs->ptr0000->tFFFFFFFC;
		if (fp > *((word32) ecx_7 + 8))
			break;
		runtime.morestack_noctxt();
	}
	Eq_4 ebx_17 = *((word32) ecx_7 + 16);
	if (ebx_17 != 0x00 && *ebx_17 == (word32) fp + 4)
		*ebx_17 = fp - 0x20;
	byte * esi_27 = dwArg0C;
	word32 ecx_28;
	byte * edi_29 = fp - 0x20;
	for (ecx_28 = dwArg10; ecx_28 != 0x00; --ecx_28)
	{
		*edi_29 = *esi_27;
		++esi_27;
		++edi_29;
	}
	(*dwArg08)();
	callRet(dwArg10 - dwArg14, dwArg04, fp - 0x20 + dwArg14, dwArg0C + dwArg14, gs);
}

// 0808E4B0: void runtime.call64(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_15434) dwArg04, Stack (ptr32 (ptr32 code)) dwArg08, Stack (ptr32 byte) dwArg0C, Stack word32 dwArg10, Stack int32 dwArg14)
void runtime.call64(struct Eq_2 * gs, struct Eq_15434 * dwArg04, <anonymous> ** dwArg08, byte * dwArg0C, word32 dwArg10, int32 dwArg14)
{
	while (true)
	{
		Eq_4 ecx_7 = gs->ptr0000->tFFFFFFFC;
		if (fp > *((word32) ecx_7 + 8))
			break;
		runtime.morestack_noctxt();
	}
	Eq_4 ebx_17 = *((word32) ecx_7 + 16);
	if (ebx_17 != 0x00 && *ebx_17 == (word32) fp + 4)
		*ebx_17 = fp - 0x40;
	byte * esi_27 = dwArg0C;
	word32 ecx_28;
	byte * edi_29 = fp - 0x40;
	for (ecx_28 = dwArg10; ecx_28 != 0x00; --ecx_28)
	{
		*edi_29 = *esi_27;
		++esi_27;
		++edi_29;
	}
	(*dwArg08)();
	callRet(dwArg10 - dwArg14, dwArg04, fp - 0x40 + dwArg14, dwArg0C + dwArg14, gs);
}

// 0808E520: void runtime.call128(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_15434) dwArg04, Stack (ptr32 (ptr32 code)) dwArg08, Stack (ptr32 byte) dwArg0C, Stack word32 dwArg10, Stack int32 dwArg14)
void runtime.call128(struct Eq_2 * gs, struct Eq_15434 * dwArg04, <anonymous> ** dwArg08, byte * dwArg0C, word32 dwArg10, int32 dwArg14)
{
	while (true)
	{
		Eq_4 ecx_7 = gs->ptr0000->tFFFFFFFC;
		if (fp > *((word32) ecx_7 + 8))
			break;
		runtime.morestack_noctxt();
	}
	Eq_4 ebx_17 = *((word32) ecx_7 + 16);
	if (ebx_17 != 0x00 && *ebx_17 == (word32) fp + 4)
		*ebx_17 = fp - 0x80;
	byte * esi_27 = dwArg0C;
	word32 ecx_28;
	byte * edi_29 = fp - 0x80;
	for (ecx_28 = dwArg10; ecx_28 != 0x00; --ecx_28)
	{
		*edi_29 = *esi_27;
		++esi_27;
		++edi_29;
	}
	(*dwArg08)();
	callRet(dwArg10 - dwArg14, dwArg04, fp - 0x80 + dwArg14, dwArg0C + dwArg14, gs);
}

// 0808E5B0: void runtime.call256(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_15434) dwArg04, Stack (ptr32 (ptr32 code)) dwArg08, Stack (ptr32 byte) dwArg0C, Stack word32 dwArg10, Stack int32 dwArg14)
void runtime.call256(struct Eq_2 * gs, struct Eq_15434 * dwArg04, <anonymous> ** dwArg08, byte * dwArg0C, word32 dwArg10, int32 dwArg14)
{
	while (true)
	{
		Eq_4 ecx_7 = gs->ptr0000->tFFFFFFFC;
		if (fp - 0x80 > *((word32) ecx_7 + 8))
			break;
		runtime.morestack_noctxt();
	}
	Eq_4 ebx_18 = *((word32) ecx_7 + 16);
	if (ebx_18 != 0x00 && *ebx_18 == fp + 0x04)
		*ebx_18 = fp - 0x0100;
	byte * esi_28 = dwArg0C;
	word32 ecx_29;
	byte * edi_30 = fp - 0x0100;
	for (ecx_29 = dwArg10; ecx_29 != 0x00; --ecx_29)
	{
		*edi_30 = *esi_28;
		++esi_28;
		++edi_30;
	}
	(*dwArg08)();
	callRet(dwArg10 - dwArg14, dwArg04, fp - 0x0100 + dwArg14, dwArg0C + dwArg14, gs);
}

// 0808E640: void runtime.call512(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_15434) dwArg04, Stack (ptr32 (ptr32 code)) dwArg08, Stack (ptr32 byte) dwArg0C, Stack word32 dwArg10, Stack int32 dwArg14)
void runtime.call512(struct Eq_2 * gs, struct Eq_15434 * dwArg04, <anonymous> ** dwArg08, byte * dwArg0C, word32 dwArg10, int32 dwArg14)
{
	while (true)
	{
		Eq_4 ecx_7 = gs->ptr0000->tFFFFFFFC;
		if (fp - 0x0180 > *((word32) ecx_7 + 8))
			break;
		runtime.morestack_noctxt();
	}
	Eq_4 ebx_18 = *((word32) ecx_7 + 16);
	if (ebx_18 != 0x00 && *ebx_18 == fp + 0x04)
		*ebx_18 = fp - 0x0200;
	byte * esi_28 = dwArg0C;
	word32 ecx_29;
	byte * edi_30 = fp - 0x0200;
	for (ecx_29 = dwArg10; ecx_29 != 0x00; --ecx_29)
	{
		*edi_30 = *esi_28;
		++esi_28;
		++edi_30;
	}
	(*dwArg08)();
	callRet(dwArg10 - dwArg14, dwArg04, fp - 0x0200 + dwArg14, dwArg0C + dwArg14, gs);
}

// 0808E6D0: void runtime.call1024(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_15434) dwArg04, Stack (ptr32 (ptr32 code)) dwArg08, Stack (ptr32 byte) dwArg0C, Stack word32 dwArg10, Stack int32 dwArg14)
void runtime.call1024(struct Eq_2 * gs, struct Eq_15434 * dwArg04, <anonymous> ** dwArg08, byte * dwArg0C, word32 dwArg10, int32 dwArg14)
{
	while (true)
	{
		Eq_4 ecx_7 = gs->ptr0000->tFFFFFFFC;
		if (fp - 0x0380 > *((word32) ecx_7 + 8))
			break;
		runtime.morestack_noctxt();
	}
	Eq_4 ebx_18 = *((word32) ecx_7 + 16);
	if (ebx_18 != 0x00 && *ebx_18 == fp + 0x04)
		*ebx_18 = fp - 0x0400;
	byte * esi_28 = dwArg0C;
	word32 ecx_29;
	byte * edi_30 = fp - 0x0400;
	for (ecx_29 = dwArg10; ecx_29 != 0x00; --ecx_29)
	{
		*edi_30 = *esi_28;
		++esi_28;
		++edi_30;
	}
	(*dwArg08)();
	callRet(dwArg10 - dwArg14, dwArg04, fp - 0x0400 + dwArg14, dwArg0C + dwArg14, gs);
}

// 0808E760: void runtime.call2048(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_15434) dwArg04, Stack (ptr32 (ptr32 code)) dwArg08, Stack (ptr32 byte) dwArg0C, Stack word32 dwArg10, Stack int32 dwArg14)
void runtime.call2048(struct Eq_2 * gs, struct Eq_15434 * dwArg04, <anonymous> ** dwArg08, byte * dwArg0C, word32 dwArg10, int32 dwArg14)
{
	while (true)
	{
		Eq_4 ecx_7 = gs->ptr0000->tFFFFFFFC;
		if (fp - 0x0780 > *((word32) ecx_7 + 8))
			break;
		runtime.morestack_noctxt();
	}
	Eq_4 ebx_18 = *((word32) ecx_7 + 16);
	if (ebx_18 != 0x00 && *ebx_18 == fp + 0x04)
		*ebx_18 = fp - 0x0800;
	byte * esi_28 = dwArg0C;
	word32 ecx_29;
	byte * edi_30 = fp - 0x0800;
	for (ecx_29 = dwArg10; ecx_29 != 0x00; --ecx_29)
	{
		*edi_30 = *esi_28;
		++esi_28;
		++edi_30;
	}
	(*dwArg08)();
	callRet(dwArg10 - dwArg14, dwArg04, fp - 0x0800 + dwArg14, dwArg0C + dwArg14, gs);
}

// 0808E7F0: void runtime.call4096(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_15434) dwArg04, Stack (ptr32 (ptr32 code)) dwArg08, Stack (ptr32 byte) dwArg0C, Stack word32 dwArg10, Stack int32 dwArg14)
void runtime.call4096(struct Eq_2 * gs, struct Eq_15434 * dwArg04, <anonymous> ** dwArg08, byte * dwArg0C, word32 dwArg10, int32 dwArg14)
{
	while (true)
	{
		Eq_4 ecx_7 = gs->ptr0000->tFFFFFFFC;
		if (fp + ~0x0F7F > *((word32) ecx_7 + 8))
			break;
		runtime.morestack_noctxt();
	}
	Eq_4 ebx_18 = *((word32) ecx_7 + 16);
	if (ebx_18 != 0x00 && *ebx_18 == fp + 0x04)
		*ebx_18 = fp - 0x1000;
	byte * esi_28 = dwArg0C;
	word32 ecx_29;
	byte * edi_30 = fp - 0x1000;
	for (ecx_29 = dwArg10; ecx_29 != 0x00; --ecx_29)
	{
		*edi_30 = *esi_28;
		++esi_28;
		++edi_30;
	}
	(*dwArg08)();
	callRet(dwArg10 - dwArg14, dwArg04, fp - 0x1000 + dwArg14, dwArg0C + dwArg14, gs);
}

// 0808E880: void runtime.call8192(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_15434) dwArg04, Stack (ptr32 (ptr32 code)) dwArg08, Stack (ptr32 byte) dwArg0C, Stack word32 dwArg10, Stack int32 dwArg14)
void runtime.call8192(struct Eq_2 * gs, struct Eq_15434 * dwArg04, <anonymous> ** dwArg08, byte * dwArg0C, word32 dwArg10, int32 dwArg14)
{
	while (true)
	{
		Eq_4 ecx_7 = gs->ptr0000->tFFFFFFFC;
		Eq_4 esi_8 = *((word32) ecx_7 + 8);
		if (esi_8 != ~0x0521 && (fp + 880) - esi_8 > 0x22F0)
			break;
		runtime.morestack_noctxt();
	}
	Eq_4 ebx_22 = *((word32) ecx_7 + 16);
	if (ebx_22 != 0x00 && *ebx_22 == fp + 0x04)
		*ebx_22 = fp - 0x2000;
	byte * esi_32 = dwArg0C;
	word32 ecx_33;
	byte * edi_34 = fp - 0x2000;
	for (ecx_33 = dwArg10; ecx_33 != 0x00; --ecx_33)
	{
		*edi_34 = *esi_32;
		++esi_32;
		++edi_34;
	}
	(*dwArg08)();
	callRet(dwArg10 - dwArg14, dwArg04, fp - 0x2000 + dwArg14, dwArg0C + dwArg14, gs);
}

// 0808E920: void runtime.call16384(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_15434) dwArg04, Stack (ptr32 (ptr32 code)) dwArg08, Stack (ptr32 byte) dwArg0C, Stack word32 dwArg10, Stack int32 dwArg14)
void runtime.call16384(struct Eq_2 * gs, struct Eq_15434 * dwArg04, <anonymous> ** dwArg08, byte * dwArg0C, word32 dwArg10, int32 dwArg14)
{
	while (true)
	{
		Eq_4 ecx_7 = gs->ptr0000->tFFFFFFFC;
		Eq_4 esi_8 = *((word32) ecx_7 + 8);
		if (esi_8 != ~0x0521 && (fp + 880) - esi_8 > 0x42F0)
			break;
		runtime.morestack_noctxt();
	}
	Eq_4 ebx_22 = *((word32) ecx_7 + 16);
	if (ebx_22 != 0x00 && *ebx_22 == fp + 0x04)
		*ebx_22 = fp - 0x4000;
	byte * esi_32 = dwArg0C;
	word32 ecx_33;
	byte * edi_34 = fp - 0x4000;
	for (ecx_33 = dwArg10; ecx_33 != 0x00; --ecx_33)
	{
		*edi_34 = *esi_32;
		++esi_32;
		++edi_34;
	}
	(*dwArg08)();
	callRet(dwArg10 - dwArg14, dwArg04, fp - 0x4000 + dwArg14, dwArg0C + dwArg14, gs);
}

// 0808E9C0: void runtime.call32768(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_15434) dwArg04, Stack (ptr32 (ptr32 code)) dwArg08, Stack (ptr32 byte) dwArg0C, Stack word32 dwArg10, Stack int32 dwArg14)
void runtime.call32768(struct Eq_2 * gs, struct Eq_15434 * dwArg04, <anonymous> ** dwArg08, byte * dwArg0C, word32 dwArg10, int32 dwArg14)
{
	while (true)
	{
		Eq_4 ecx_7 = gs->ptr0000->tFFFFFFFC;
		Eq_4 esi_8 = *((word32) ecx_7 + 8);
		if (esi_8 != ~0x0521 && (fp + 880) - esi_8 > 0x82F0)
			break;
		runtime.morestack_noctxt();
	}
	Eq_4 ebx_22 = *((word32) ecx_7 + 16);
	if (ebx_22 != 0x00 && *ebx_22 == fp + 0x04)
		*ebx_22 = fp - 0x8000;
	byte * esi_32 = dwArg0C;
	word32 ecx_33;
	byte * edi_34 = fp - 0x8000;
	for (ecx_33 = dwArg10; ecx_33 != 0x00; --ecx_33)
	{
		*edi_34 = *esi_32;
		++esi_32;
		++edi_34;
	}
	(*dwArg08)();
	callRet(dwArg10 - dwArg14, dwArg04, fp - 0x8000 + dwArg14, dwArg0C + dwArg14, gs);
}

// 0808EA60: void runtime.call65536(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_15434) dwArg04, Stack (ptr32 (ptr32 code)) dwArg08, Stack (ptr32 byte) dwArg0C, Stack word32 dwArg10, Stack int32 dwArg14)
void runtime.call65536(struct Eq_2 * gs, struct Eq_15434 * dwArg04, <anonymous> ** dwArg08, byte * dwArg0C, word32 dwArg10, int32 dwArg14)
{
	while (true)
	{
		Eq_4 ecx_7 = gs->ptr0000->tFFFFFFFC;
		Eq_4 esi_8 = *((word32) ecx_7 + 8);
		if (esi_8 != ~0x0521 && (fp + 880) - esi_8 > 66288)
			break;
		runtime.morestack_noctxt();
	}
	Eq_4 ebx_22 = *((word32) ecx_7 + 16);
	if (ebx_22 != 0x00 && *ebx_22 == fp + 0x04)
		*ebx_22 = fp - 0x00010000;
	byte * esi_32 = dwArg0C;
	word32 ecx_33;
	byte * edi_34 = fp - 0x00010000;
	for (ecx_33 = dwArg10; ecx_33 != 0x00; --ecx_33)
	{
		*edi_34 = *esi_32;
		++esi_32;
		++edi_34;
	}
	(*dwArg08)();
	callRet(dwArg10 - dwArg14, dwArg04, fp - 0x00010000 + dwArg14, dwArg0C + dwArg14, gs);
}

// 0808EB00: void runtime.call131072(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_15434) dwArg04, Stack (ptr32 (ptr32 code)) dwArg08, Stack (ptr32 byte) dwArg0C, Stack word32 dwArg10, Stack int32 dwArg14)
void runtime.call131072(struct Eq_2 * gs, struct Eq_15434 * dwArg04, <anonymous> ** dwArg08, byte * dwArg0C, word32 dwArg10, int32 dwArg14)
{
	while (true)
	{
		Eq_4 ecx_7 = gs->ptr0000->tFFFFFFFC;
		Eq_4 esi_8 = *((word32) ecx_7 + 8);
		if (esi_8 != ~0x0521 && (fp + 880) - esi_8 > 0x000202F0)
			break;
		runtime.morestack_noctxt();
	}
	Eq_4 ebx_22 = *((word32) ecx_7 + 16);
	if (ebx_22 != 0x00 && *ebx_22 == fp + 0x04)
		*ebx_22 = fp - 0x00020000;
	byte * esi_32 = dwArg0C;
	word32 ecx_33;
	byte * edi_34 = fp - 0x00020000;
	for (ecx_33 = dwArg10; ecx_33 != 0x00; --ecx_33)
	{
		*edi_34 = *esi_32;
		++esi_32;
		++edi_34;
	}
	(*dwArg08)();
	callRet(dwArg10 - dwArg14, dwArg04, fp - 0x00020000 + dwArg14, dwArg0C + dwArg14, gs);
}

// 0808EBA0: void runtime.call262144(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_15434) dwArg04, Stack (ptr32 (ptr32 code)) dwArg08, Stack (ptr32 byte) dwArg0C, Stack word32 dwArg10, Stack int32 dwArg14)
void runtime.call262144(struct Eq_2 * gs, struct Eq_15434 * dwArg04, <anonymous> ** dwArg08, byte * dwArg0C, word32 dwArg10, int32 dwArg14)
{
	while (true)
	{
		Eq_4 ecx_7 = gs->ptr0000->tFFFFFFFC;
		Eq_4 esi_8 = *((word32) ecx_7 + 8);
		if (esi_8 != ~0x0521 && (fp + 880) - esi_8 > 0x000402F0)
			break;
		runtime.morestack_noctxt();
	}
	Eq_4 ebx_22 = *((word32) ecx_7 + 16);
	if (ebx_22 != 0x00 && *ebx_22 == fp + 0x04)
		*ebx_22 = fp - 0x00040000;
	byte * esi_32 = dwArg0C;
	word32 ecx_33;
	byte * edi_34 = fp - 0x00040000;
	for (ecx_33 = dwArg10; ecx_33 != 0x00; --ecx_33)
	{
		*edi_34 = *esi_32;
		++esi_32;
		++edi_34;
	}
	(*dwArg08)();
	callRet(dwArg10 - dwArg14, dwArg04, fp - 0x00040000 + dwArg14, dwArg0C + dwArg14, gs);
}

// 0808EC40: void runtime.call524288(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_15434) dwArg04, Stack (ptr32 (ptr32 code)) dwArg08, Stack (ptr32 byte) dwArg0C, Stack word32 dwArg10, Stack int32 dwArg14)
void runtime.call524288(struct Eq_2 * gs, struct Eq_15434 * dwArg04, <anonymous> ** dwArg08, byte * dwArg0C, word32 dwArg10, int32 dwArg14)
{
	while (true)
	{
		Eq_4 ecx_7 = gs->ptr0000->tFFFFFFFC;
		Eq_4 esi_8 = *((word32) ecx_7 + 8);
		if (esi_8 != ~0x0521 && (fp + 880) - esi_8 > 0x000802F0)
			break;
		runtime.morestack_noctxt();
	}
	Eq_4 ebx_22 = *((word32) ecx_7 + 16);
	if (ebx_22 != 0x00 && *ebx_22 == fp + 0x04)
		*ebx_22 = fp - 0x00080000;
	byte * esi_32 = dwArg0C;
	word32 ecx_33;
	byte * edi_34 = fp - 0x00080000;
	for (ecx_33 = dwArg10; ecx_33 != 0x00; --ecx_33)
	{
		*edi_34 = *esi_32;
		++esi_32;
		++edi_34;
	}
	(*dwArg08)();
	callRet(dwArg10 - dwArg14, dwArg04, fp - 0x00080000 + dwArg14, dwArg0C + dwArg14, gs);
}

// 0808ECE0: void runtime.call1048576(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_15434) dwArg04, Stack (ptr32 (ptr32 code)) dwArg08, Stack (ptr32 byte) dwArg0C, Stack word32 dwArg10, Stack int32 dwArg14)
void runtime.call1048576(struct Eq_2 * gs, struct Eq_15434 * dwArg04, <anonymous> ** dwArg08, byte * dwArg0C, word32 dwArg10, int32 dwArg14)
{
	while (true)
	{
		Eq_4 ecx_7 = gs->ptr0000->tFFFFFFFC;
		Eq_4 esi_8 = *((word32) ecx_7 + 8);
		if (esi_8 != ~0x0521 && (fp + 880) - esi_8 > 0x001002F0)
			break;
		runtime.morestack_noctxt();
	}
	Eq_4 ebx_22 = *((word32) ecx_7 + 16);
	if (ebx_22 != 0x00 && *ebx_22 == fp + 0x04)
		*ebx_22 = fp - 0x00100000;
	byte * esi_32 = dwArg0C;
	word32 ecx_33;
	byte * edi_34 = fp - 0x00100000;
	for (ecx_33 = dwArg10; ecx_33 != 0x00; --ecx_33)
	{
		*edi_34 = *esi_32;
		++esi_32;
		++edi_34;
	}
	(*dwArg08)();
	callRet(dwArg10 - dwArg14, dwArg04, fp - 0x00100000 + dwArg14, dwArg0C + dwArg14, gs);
}

// 0808ED80: void runtime.call2097152(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_15434) dwArg04, Stack (ptr32 (ptr32 code)) dwArg08, Stack (ptr32 byte) dwArg0C, Stack word32 dwArg10, Stack int32 dwArg14)
void runtime.call2097152(struct Eq_2 * gs, struct Eq_15434 * dwArg04, <anonymous> ** dwArg08, byte * dwArg0C, word32 dwArg10, int32 dwArg14)
{
	while (true)
	{
		Eq_4 ecx_7 = gs->ptr0000->tFFFFFFFC;
		Eq_4 esi_8 = *((word32) ecx_7 + 8);
		if (esi_8 != ~0x0521 && (fp + 880) - esi_8 > 0x002002F0)
			break;
		runtime.morestack_noctxt();
	}
	Eq_4 ebx_22 = *((word32) ecx_7 + 16);
	if (ebx_22 != 0x00 && *ebx_22 == fp + 0x04)
		*ebx_22 = fp - 0x00200000;
	byte * esi_32 = dwArg0C;
	word32 ecx_33;
	byte * edi_34 = fp - 0x00200000;
	for (ecx_33 = dwArg10; ecx_33 != 0x00; --ecx_33)
	{
		*edi_34 = *esi_32;
		++esi_32;
		++edi_34;
	}
	(*dwArg08)();
	callRet(dwArg10 - dwArg14, dwArg04, fp - 0x00200000 + dwArg14, dwArg0C + dwArg14, gs);
}

// 0808EE20: void runtime.call4194304(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_15434) dwArg04, Stack (ptr32 (ptr32 code)) dwArg08, Stack (ptr32 byte) dwArg0C, Stack word32 dwArg10, Stack int32 dwArg14)
void runtime.call4194304(struct Eq_2 * gs, struct Eq_15434 * dwArg04, <anonymous> ** dwArg08, byte * dwArg0C, word32 dwArg10, int32 dwArg14)
{
	while (true)
	{
		Eq_4 ecx_7 = gs->ptr0000->tFFFFFFFC;
		Eq_4 esi_8 = *((word32) ecx_7 + 8);
		if (esi_8 != ~0x0521 && (fp + 880) - esi_8 > 0x004002F0)
			break;
		runtime.morestack_noctxt();
	}
	Eq_4 ebx_22 = *((word32) ecx_7 + 16);
	if (ebx_22 != 0x00 && *ebx_22 == fp + 0x04)
		*ebx_22 = fp - 0x00400000;
	byte * esi_32 = dwArg0C;
	word32 ecx_33;
	byte * edi_34 = fp - 0x00400000;
	for (ecx_33 = dwArg10; ecx_33 != 0x00; --ecx_33)
	{
		*edi_34 = *esi_32;
		++esi_32;
		++edi_34;
	}
	(*dwArg08)();
	callRet(dwArg10 - dwArg14, dwArg04, fp - 0x00400000 + dwArg14, dwArg0C + dwArg14, gs);
}

// 0808EEC0: void runtime.call8388608(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_15434) dwArg04, Stack (ptr32 (ptr32 code)) dwArg08, Stack (ptr32 byte) dwArg0C, Stack word32 dwArg10, Stack int32 dwArg14)
void runtime.call8388608(struct Eq_2 * gs, struct Eq_15434 * dwArg04, <anonymous> ** dwArg08, byte * dwArg0C, word32 dwArg10, int32 dwArg14)
{
	while (true)
	{
		Eq_4 ecx_7 = gs->ptr0000->tFFFFFFFC;
		Eq_4 esi_8 = *((word32) ecx_7 + 8);
		if (esi_8 != ~0x0521 && (fp + 880) - esi_8 > 0x008002F0)
			break;
		runtime.morestack_noctxt();
	}
	Eq_4 ebx_22 = *((word32) ecx_7 + 16);
	if (ebx_22 != 0x00 && *ebx_22 == fp + 0x04)
		*ebx_22 = fp - 0x00800000;
	byte * esi_32 = dwArg0C;
	word32 ecx_33;
	byte * edi_34 = fp - 0x00800000;
	for (ecx_33 = dwArg10; ecx_33 != 0x00; --ecx_33)
	{
		*edi_34 = *esi_32;
		++esi_32;
		++edi_34;
	}
	(*dwArg08)();
	callRet(dwArg10 - dwArg14, dwArg04, fp - 0x00800000 + dwArg14, dwArg0C + dwArg14, gs);
}

// 0808EF60: void runtime.call16777216(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_15434) dwArg04, Stack (ptr32 (ptr32 code)) dwArg08, Stack (ptr32 byte) dwArg0C, Stack word32 dwArg10, Stack int32 dwArg14)
void runtime.call16777216(struct Eq_2 * gs, struct Eq_15434 * dwArg04, <anonymous> ** dwArg08, byte * dwArg0C, word32 dwArg10, int32 dwArg14)
{
	while (true)
	{
		Eq_4 ecx_7 = gs->ptr0000->tFFFFFFFC;
		Eq_4 esi_8 = *((word32) ecx_7 + 8);
		if (esi_8 != ~0x0521 && (fp + 880) - esi_8 > 0x010002F0)
			break;
		runtime.morestack_noctxt();
	}
	Eq_4 ebx_22 = *((word32) ecx_7 + 16);
	if (ebx_22 != 0x00 && *ebx_22 == fp + 0x04)
		*ebx_22 = fp - 0x01000000;
	byte * esi_32 = dwArg0C;
	word32 ecx_33;
	byte * edi_34 = fp - 0x01000000;
	for (ecx_33 = dwArg10; ecx_33 != 0x00; --ecx_33)
	{
		*edi_34 = *esi_32;
		++esi_32;
		++edi_34;
	}
	(*dwArg08)();
	callRet(dwArg10 - dwArg14, dwArg04, fp - 0x01000000 + dwArg14, dwArg0C + dwArg14, gs);
}

// 0808F000: void runtime.call33554432(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_15434) dwArg04, Stack (ptr32 (ptr32 code)) dwArg08, Stack (ptr32 byte) dwArg0C, Stack word32 dwArg10, Stack int32 dwArg14)
void runtime.call33554432(struct Eq_2 * gs, struct Eq_15434 * dwArg04, <anonymous> ** dwArg08, byte * dwArg0C, word32 dwArg10, int32 dwArg14)
{
	while (true)
	{
		Eq_4 ecx_7 = gs->ptr0000->tFFFFFFFC;
		Eq_4 esi_8 = *((word32) ecx_7 + 8);
		if (esi_8 != ~0x0521 && (fp + 880) - esi_8 > 0x020002F0)
			break;
		runtime.morestack_noctxt();
	}
	Eq_4 ebx_22 = *((word32) ecx_7 + 16);
	if (ebx_22 != 0x00 && *ebx_22 == fp + 0x04)
		*ebx_22 = fp - 0x02000000;
	byte * esi_32 = dwArg0C;
	word32 ecx_33;
	byte * edi_34 = fp - 0x02000000;
	for (ecx_33 = dwArg10; ecx_33 != 0x00; --ecx_33)
	{
		*edi_34 = *esi_32;
		++esi_32;
		++edi_34;
	}
	(*dwArg08)();
	callRet(dwArg10 - dwArg14, dwArg04, fp - 0x02000000 + dwArg14, dwArg0C + dwArg14, gs);
}

// 0808F0A0: void runtime.call67108864(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_15434) dwArg04, Stack (ptr32 (ptr32 code)) dwArg08, Stack (ptr32 byte) dwArg0C, Stack word32 dwArg10, Stack int32 dwArg14)
void runtime.call67108864(struct Eq_2 * gs, struct Eq_15434 * dwArg04, <anonymous> ** dwArg08, byte * dwArg0C, word32 dwArg10, int32 dwArg14)
{
	while (true)
	{
		Eq_4 ecx_7 = gs->ptr0000->tFFFFFFFC;
		Eq_4 esi_8 = *((word32) ecx_7 + 8);
		if (esi_8 != ~0x0521 && (fp + 880) - esi_8 > 0x040002F0)
			break;
		runtime.morestack_noctxt();
	}
	Eq_4 ebx_22 = *((word32) ecx_7 + 16);
	if (ebx_22 != 0x00 && *ebx_22 == fp + 0x04)
		*ebx_22 = fp - 0x04000000;
	byte * esi_32 = dwArg0C;
	word32 ecx_33;
	byte * edi_34 = fp - 0x04000000;
	for (ecx_33 = dwArg10; ecx_33 != 0x00; --ecx_33)
	{
		*edi_34 = *esi_32;
		++esi_32;
		++edi_34;
	}
	(*dwArg08)();
	callRet(dwArg10 - dwArg14, dwArg04, fp - 0x04000000 + dwArg14, dwArg0C + dwArg14, gs);
}

// 0808F140: void runtime.call134217728(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_15434) dwArg04, Stack (ptr32 (ptr32 code)) dwArg08, Stack (ptr32 byte) dwArg0C, Stack word32 dwArg10, Stack int32 dwArg14)
void runtime.call134217728(struct Eq_2 * gs, struct Eq_15434 * dwArg04, <anonymous> ** dwArg08, byte * dwArg0C, word32 dwArg10, int32 dwArg14)
{
	while (true)
	{
		Eq_4 ecx_7 = gs->ptr0000->tFFFFFFFC;
		Eq_4 esi_8 = *((word32) ecx_7 + 8);
		if (esi_8 != ~0x0521 && (fp + 880) - esi_8 > 0x080002F0)
			break;
		runtime.morestack_noctxt();
	}
	Eq_4 ebx_22 = *((word32) ecx_7 + 16);
	if (ebx_22 != 0x00 && *ebx_22 == fp + 0x04)
		*ebx_22 = fp - 0x08000000;
	byte * esi_32 = dwArg0C;
	word32 ecx_33;
	byte * edi_34 = fp - 0x08000000;
	for (ecx_33 = dwArg10; ecx_33 != 0x00; --ecx_33)
	{
		*edi_34 = *esi_32;
		++esi_32;
		++edi_34;
	}
	(*dwArg08)();
	callRet(dwArg10 - dwArg14, dwArg04, fp - 0x08000000 + dwArg14, dwArg0C + dwArg14, gs);
}

// 0808F1E0: void runtime.call268435456(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_15434) dwArg04, Stack (ptr32 (ptr32 code)) dwArg08, Stack (ptr32 byte) dwArg0C, Stack word32 dwArg10, Stack int32 dwArg14)
void runtime.call268435456(struct Eq_2 * gs, struct Eq_15434 * dwArg04, <anonymous> ** dwArg08, byte * dwArg0C, word32 dwArg10, int32 dwArg14)
{
	while (true)
	{
		Eq_4 ecx_7 = gs->ptr0000->tFFFFFFFC;
		Eq_4 esi_8 = *((word32) ecx_7 + 8);
		if (esi_8 != ~0x0521 && (fp + 880) - esi_8 > 0x100002F0)
			break;
		runtime.morestack_noctxt();
	}
	Eq_4 ebx_22 = *((word32) ecx_7 + 16);
	if (ebx_22 != 0x00 && *ebx_22 == fp + 0x04)
		*ebx_22 = fp - 0x10000000;
	byte * esi_32 = dwArg0C;
	word32 ecx_33;
	byte * edi_34 = fp - 0x10000000;
	for (ecx_33 = dwArg10; ecx_33 != 0x00; --ecx_33)
	{
		*edi_34 = *esi_32;
		++esi_32;
		++edi_34;
	}
	(*dwArg08)();
	callRet(dwArg10 - dwArg14, dwArg04, fp - 0x10000000 + dwArg14, dwArg0C + dwArg14, gs);
}

// 0808F280: void runtime.call536870912(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_15434) dwArg04, Stack (ptr32 (ptr32 code)) dwArg08, Stack (ptr32 byte) dwArg0C, Stack word32 dwArg10, Stack int32 dwArg14)
void runtime.call536870912(struct Eq_2 * gs, struct Eq_15434 * dwArg04, <anonymous> ** dwArg08, byte * dwArg0C, word32 dwArg10, int32 dwArg14)
{
	while (true)
	{
		Eq_4 ecx_7 = gs->ptr0000->tFFFFFFFC;
		Eq_4 esi_8 = *((word32) ecx_7 + 8);
		if (esi_8 != ~0x0521 && (fp + 880) - esi_8 > 0x200002F0)
			break;
		runtime.morestack_noctxt();
	}
	Eq_4 ebx_22 = *((word32) ecx_7 + 16);
	if (ebx_22 != 0x00 && *ebx_22 == fp + 0x04)
		*ebx_22 = fp - 0x20000000;
	byte * esi_32 = dwArg0C;
	word32 ecx_33;
	byte * edi_34 = fp - 0x20000000;
	for (ecx_33 = dwArg10; ecx_33 != 0x00; --ecx_33)
	{
		*edi_34 = *esi_32;
		++esi_32;
		++edi_34;
	}
	(*dwArg08)();
	callRet(dwArg10 - dwArg14, dwArg04, fp - 0x20000000 + dwArg14, dwArg0C + dwArg14, gs);
}

// 0808F320: void runtime.call1073741824(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_15434) dwArg04, Stack (ptr32 (ptr32 code)) dwArg08, Stack (ptr32 byte) dwArg0C, Stack word32 dwArg10, Stack int32 dwArg14)
void runtime.call1073741824(struct Eq_2 * gs, struct Eq_15434 * dwArg04, <anonymous> ** dwArg08, byte * dwArg0C, word32 dwArg10, int32 dwArg14)
{
	while (true)
	{
		Eq_4 ecx_7 = gs->ptr0000->tFFFFFFFC;
		Eq_4 esi_8 = *((word32) ecx_7 + 8);
		if (esi_8 != ~0x0521 && (fp + 880) - esi_8 > 0x400002F0)
			break;
		runtime.morestack_noctxt();
	}
	Eq_4 ebx_22 = *((word32) ecx_7 + 16);
	if (ebx_22 != 0x00 && *ebx_22 == fp + 0x04)
		*ebx_22 = fp - 0x40000000;
	byte * esi_32 = dwArg0C;
	word32 ecx_33;
	byte * edi_34 = fp - 0x40000000;
	for (ecx_33 = dwArg10; ecx_33 != 0x00; --ecx_33)
	{
		*edi_34 = *esi_32;
		++esi_32;
		++edi_34;
	}
	(*dwArg08)();
	callRet(dwArg10 - dwArg14, dwArg04, fp - 0x40000000 + dwArg14, dwArg0C + dwArg14, gs);
}

// 0808F3C0: void runtime.procyield(Stack Eq_4 dwArg04)
// Called from:
//      runtime.lock
//      runtime.getfull
//      runtime.casgstatus
//      runtime.scang
//      sync.runtime_doSpin
void runtime.procyield(Eq_4 dwArg04)
{
	Eq_4 eax_5 = dwArg04;
	do
	{
		__pause();
		--eax_5;
	} while (eax_5 != 0x00);
}

// 0808F3D0: void runtime.publicationBarrier()
// Called from:
//      runtime.mallocgc
void runtime.publicationBarrier()
{
}

// 0808F3E0: void runtime.jmpdefer(Stack Eq_4 dwArg04, Stack (ptr32 Eq_42225) dwArg08)
// Called from:
//      runtime.deferreturn
void runtime.jmpdefer(Eq_4 dwArg04, struct Eq_42225 * dwArg08)
{
	dwArg08->dwFFFFFFFC -= 0x05;
	(*dwArg04)();
}

// 0808F400: Register Eq_4 gosave(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg00, Register out Eq_1912 edxOut)
// Called from:
//      runtime.asmcgocall
Eq_4 gosave(struct Eq_2 * gs, Eq_4 dwArg00, union Eq_1912 & edxOut)
{
	Eq_4 ebx_12 = gs->ptr0000->tFFFFFFFC;
	*((word32) ebx_12 + 28) = fp + 0x04;
	*((word32) ebx_12 + 32) = dwArg00;
	((word32) ebx_12 + 44)->u0 = 0x00;
	if (*((word32) ebx_12 + 40) != 0x00)
		runtime.badctxt();
	edxOut.u2 = <invalid>;
	return <invalid>;
}

// 0808F440: Register (ptr32 Eq_86064) runtime.asmcgocall(Register (ptr32 Eq_2) gs, Stack (ptr32 code) dwArg04, Stack ptr32 dwArg08, Register out Eq_4 ediOut)
// Called from:
//      runtime.cgocall
//      runtime.notesleep
//      runtime.notetsleep_internal
//      runtime.newm
//      runtime.findrunnable
//      runtime.sysmon
//      runtime.callCgoSymbolizer
//      runtime.cgoContextPCs
struct Eq_86064 * runtime.asmcgocall(struct Eq_2 * gs, <anonymous> * dwArg04, ptr32 dwArg08, union Eq_4 & ediOut)
{
	Eq_4 esp_2 = fp;
	struct Eq_6 * ecx_9 = gs->ptr0000;
	<anonymous> * eax_16 = dwArg04;
	Eq_4 edx_17 = fp;
	Eq_4 esi_12 = **((word32) ecx_9->tFFFFFFFC + 24);
	Eq_4 edi_13 = ecx_9->tFFFFFFFC;
	if (esi_12 != edi_13)
	{
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_4 stackArg0 = <invalid>;
		eax_16 = gosave(gs, stackArg0, out edx_17);
		gs->ptr0000->tFFFFFFFC = esi_12;
		esp_2 = *((word32) esi_12 + 28);
	}
	struct Eq_83563 * esp_24 = esp_2 - 0x20;
	__align(esp_24);
	esp_24->t0008 = edi_13;
	esp_24->dw0004 = *((word32) edi_13 + 4) - edx_17;
	esp_24->ptr0000 = dwArg08;
	word32 eax_37;
	eax_16();
	Eq_4 edi_42 = esp_24->t0008;
	struct Eq_86064 * esi_44 = *((word32) edi_42 + 4) - esp_24->dw0004;
	gs->ptr0000->tFFFFFFFC = edi_42;
	esi_44->dw000C = eax_37;
	ediOut = edi_42;
	return esi_44;
}

// 0808F4C0: void runtime.cgocallback_gofunc(Register (ptr32 Eq_2) gs, Stack word32 dwArg10)
void runtime.cgocallback_gofunc(struct Eq_2 * gs, word32 dwArg10)
{
	Eq_4 edx_25;
	Eq_4 ebp_28;
	struct Eq_6 * ecx_26 = gs->ptr0000;
	Eq_4 ebp_8 = ecx_26->tFFFFFFFC;
	if (ebp_8 != 0x00)
	{
		ebp_28 = *((word32) ebp_8 + 24);
		edx_25 = ebp_28;
	}
	else
	{
		runtime.needm(gs);
		ecx_26 = gs->ptr0000;
		ebp_28 = *((word32) ecx_26->tFFFFFFFC + 24);
		*((word32) *ebp_28 + 28) = fp - 0x0C;
		edx_25.u0 = 0x00;
	}
	*((word32) *ebp_28 + 28) = fp - 0x0C;
	Eq_4 esi_40 = *((word32) ebp_28 + 84);
	ecx_26->tFFFFFFFC = esi_40;
	Eq_4 edi_43 = *((word32) esi_40 + 28);
	Eq_4 ebp_44 = *((word32) esi_40 + 32);
	*((word32) edi_43 - 4) = ebp_44;
	*((word32) edi_43 - 0x0C) = edx_25;
	*((word32) edi_43 - 16) = dwArg10;
	runtime.cgocallbackg(ebp_44, gs, *((word32) edi_43 - 20));
	Eq_4 esp_59 = <invalid>;
	struct Eq_6 * ecx_75 = gs->ptr0000;
	Eq_4 edx_74 = *((word32) esp_59 + 4);
	Eq_4 esi_76 = ecx_75->tFFFFFFFC;
	*((word32) esi_76 + 32) = *((word32) esp_59 + 0x0C);
	*((word32) esi_76 + 28) = (word32) esp_59 + 16;
	Eq_4 esi_83 = **((word32) ecx_75->tFFFFFFFC + 24);
	ecx_75->tFFFFFFFC = esi_83;
	*((word32) esi_83 + 28) = **((word32) esi_83 + 28);
	if (edx_74 == 0x00)
		runtime.dropm(gs);
}

// 0808F580: Register Eq_4 runtime.setg(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      runtime.needm
//      runtime.dropm
//      runtime.sigtrampgo
Eq_4 runtime.setg(struct Eq_2 * gs, Eq_4 dwArg04)
{
	gs->ptr0000->tFFFFFFFC = dwArg04;
	return dwArg04;
}

// 0808F5A0: void setg_gcc(Register (ptr32 Eq_86267) gs, Stack word32 dwArg04)
void setg_gcc(struct Eq_86267 * gs, word32 dwArg04)
{
	gs->ptr0000->dwFFFFFFFC = dwArg04;
}

// 0808F5C0: void runtime.stackcheck(Register (ptr32 Eq_86274) gs)
// Called from:
//      runtime.clone
void runtime.stackcheck(struct Eq_86274 * gs)
{
	struct Eq_86275 * eax_7 = gs->ptr0000->ptrFFFFFFFC;
	if (eax_7->ptr0004 <= fp)
		__syscall(0x03);
	if (fp <= eax_7->ptr0000)
		__syscall(0x03);
}

// 0808F5E0: void runtime.getcallerpc()
// Called from:
//      runtime.chansend1
//      runtime.tracealloc
//      runtime.tracefree
//      runtime.deferproc
//      runtime.dopanic
//      runtime.entersyscall
//      runtime.entersyscallblock
//      runtime.newproc
//      runtime.callers
void runtime.getcallerpc()
{
}

// 0808F600: void runtime.cputicks()
// Called from:
//      runtime.chansend
//      runtime.send
//      runtime.closechan
//      runtime.chanrecv
//      runtime.recv
//      runtime.mcommoninit
//      runtime.exitsyscall
//      runtime.readyWithTime
//      runtime.semacquire1
//      runtime.(*semaRoot).dequeue
//      runtime.traceEvent
void runtime.cputicks()
{
	if (g_b815757E == 0x01)
	{
		if (g_b8157573 == 0x01)
			__lfence();
		else
			__mfence();
	}
	__rdtsc();
}

// 0808F630: void runtime.ldt0setup()
// Called from:
//      main
void runtime.ldt0setup()
{
	runtime.setldt(&g_t8145718);
}

// 0808F660: void runtime.emptyfunc(Register (ptr32 Eq_2) gs)
// Called from:
//      main
//      runtime.clone
void runtime.emptyfunc(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
}

// 0808F680: void runtime.memhash_varlen(Register (ptr32 Eq_86330) edx, Register (ptr32 Eq_2) gs, Register Eq_4 mm0, Stack (ptr32 Eq_205) dwArg04, Stack (ptr32 Eq_205) dwArg08)
void runtime.memhash_varlen(struct Eq_86330 * edx, struct Eq_2 * gs, Eq_4 mm0, union Eq_205 * dwArg04, union Eq_205 * dwArg08)
{
	word128 xmm1_50;
	runtime.memhash(gs, mm0, dwArg04, dwArg08, edx->t0004, out xmm1_50);
}

// 0808F6B0: Register Eq_4 runtime.aeshash(Register Eq_4 mm0, Stack (ptr32 Eq_205) dwArg04, Stack (ptr32 Eq_205) dwArg08, Stack Eq_4 dwArg0C, Register out Eq_5884 xmm1Out)
// Called from:
//      runtime.memhash
Eq_4 runtime.aeshash(Eq_4 mm0, union Eq_205 * dwArg04, union Eq_205 * dwArg08, Eq_4 dwArg0C, union Eq_5884 & xmm1Out)
{
	byte al_8 = (byte) dwArg04;
	word24 eax_24_8_10 = SLICE(dwArg04, word24, 8);
	Eq_5884 xmm1_14;
	Eq_4 mm0_12 = runtime.aeshashbody(al_8, eax_24_8_10, fp + 0x10, dwArg0C, mm0, dwArg08, out xmm1_14);
	xmm1Out = xmm1_14;
	return mm0_12;
}

// 0808F6D0: void runtime.aeshashstr(Register Eq_4 mm0, Stack (ptr32 Eq_86363) dwArg04, Stack (ptr32 Eq_205) dwArg08)
void runtime.aeshashstr(Eq_4 mm0, struct Eq_86363 * dwArg04, union Eq_205 * dwArg08)
{
	word32 eax_7 = dwArg04->dw0000;
	Eq_4 ebx_6 = dwArg04->t0004;
	byte al_9 = (byte) eax_7;
	word24 eax_24_8_11 = SLICE(eax_7, word24, 8);
	word128 xmm1_29;
	runtime.aeshashbody(al_9, eax_24_8_11, fp + 0x0C, ebx_6, mm0, dwArg08, out xmm1_29);
}

// 0808F6F0: Register Eq_4 runtime.aeshashbody(Register byte al, Register word24 eax_24_8, Register (ptr32 word32) edx, Register Eq_4 ebx, Register Eq_4 mm0, Stack (ptr32 Eq_205) dwArg08, Register out Eq_43806 xmm1Out)
// Called from:
//      runtime.aeshash
//      runtime.aeshashstr
Eq_4 runtime.aeshashbody(byte al, word24 eax_24_8, word32 * edx, Eq_4 ebx, Eq_4 mm0, union Eq_205 * dwArg08, union Eq_43806 & xmm1Out)
{
	Eq_43806 xmm1_36;
	word128 xmm0_5 = (word128) dwArg08;
	Eq_43806 xmm0_7 = __pinsrw(xmm0_5, xmm0_5, ebx);
	Eq_43806 xmm0_13 = __pxor(xmm0_7, g_t81577A0);
	Eq_43806 xmm0_14 = __aesenc(xmm0_13, xmm0_13);
	struct Eq_86405 * eax_116 = SEQ(eax_24_8, al + ~0x0C);
	if (ebx >= 0x10)
	{
		if (ebx != 0x10)
		{
			if (ebx <= 0x20)
			{
				Eq_43806 xmm1_53 = __pxor(xmm0_7, g_t81577B0);
				Eq_43806 xmm1_54 = __aesenc(xmm1_53, xmm1_53);
				word128 xmm3_56 = Mem0[eax_116 - 0x10 + ebx:word128];
				Eq_43806 xmm2_57 = __aesenc(eax_116->ow0000, xmm0_14);
				Eq_43806 xmm3_58 = __aesenc(xmm3_56, xmm1_54);
				Eq_43806 xmm2_59 = __aesenc(xmm2_57, xmm2_57);
				Eq_43806 xmm3_60 = __aesenc(xmm3_58, xmm3_58);
				*edx = (word32) __pxor(__aesenc(xmm2_59, xmm2_59), __aesenc(xmm3_60, xmm3_60));
				xmm1Out = xmm1_54;
				return <invalid>;
			}
			else if (ebx <= 0x40)
			{
				Eq_43806 xmm1_70 = __pxor(xmm0_7, g_t81577B0);
				Eq_43806 xmm2_71 = __pxor(xmm0_7, g_t81577C0);
				Eq_43806 xmm3_72 = __pxor(xmm0_7, g_t81577D0);
				Eq_43806 xmm1_73 = __aesenc(xmm1_70, xmm1_70);
				Eq_43806 xmm2_74 = __aesenc(xmm2_71, xmm2_71);
				Eq_43806 xmm3_75 = __aesenc(xmm3_72, xmm3_72);
				Eq_43806 xmm5_77 = eax_116->ow0010;
				word128 xmm6_78 = Mem0[eax_116 - 0x20 + ebx:word128];
				word128 xmm7_79 = Mem0[eax_116 - 0x10 + ebx:word128];
				Eq_43806 xmm4_80 = __aesenc(eax_116->ow0000, xmm0_14);
				Eq_43806 xmm5_81 = __aesenc(xmm5_77, xmm1_73);
				Eq_43806 xmm6_82 = __aesenc(xmm6_78, xmm2_74);
				Eq_43806 xmm7_83 = __aesenc(xmm7_79, xmm3_75);
				Eq_43806 xmm4_84 = __aesenc(xmm4_80, xmm4_80);
				Eq_43806 xmm5_85 = __aesenc(xmm5_81, xmm5_81);
				Eq_43806 xmm6_86 = __aesenc(xmm6_82, xmm6_82);
				Eq_43806 xmm7_87 = __aesenc(xmm7_83, xmm7_83);
				*edx = (word32) __pxor(__pxor(__aesenc(xmm4_84, xmm4_84), __aesenc(xmm6_86, xmm6_86)), __pxor(__aesenc(xmm5_85, xmm5_85), __aesenc(xmm7_87, xmm7_87)));
				xmm1Out = xmm1_73;
				return <invalid>;
			}
			else
			{
				Eq_43806 xmm1_99 = __pxor(xmm0_7, g_t81577B0);
				Eq_43806 xmm2_100 = __pxor(xmm0_7, g_t81577C0);
				Eq_43806 xmm3_101 = __pxor(xmm0_7, g_t81577D0);
				Eq_43806 xmm1_102 = __aesenc(xmm1_99, xmm1_99);
				Eq_43806 xmm2_103 = __aesenc(xmm2_100, xmm2_100);
				Eq_43806 xmm3_104 = __aesenc(xmm3_101, xmm3_101);
				Eq_43806 xmm5_106 = *((word32) ebx + (eax_116 - 0x30));
				word128 xmm6_107 = Mem0[eax_116 - 0x20 + ebx:word128];
				word128 xmm7_108 = Mem0[eax_116 - 0x10 + ebx:word128];
				word128 xmm4_109 = __aesenc(Mem0[eax_116 - 0x40 + ebx:word128], xmm0_14);
				Eq_43806 xmm5_110 = __aesenc(xmm5_106, xmm1_102);
				Eq_43806 xmm6_111 = __aesenc(xmm6_107, xmm2_103);
				Eq_43806 xmm7_112 = __aesenc(xmm7_108, xmm3_104);
				uint32 ebx_114 = ebx - (union Eq_43806 *) 0x01 >> 0x06;
				do
				{
					Eq_43806 xmm1_119 = eax_116->ow0010;
					Eq_43806 xmm2_120 = eax_116->ow0020;
					Eq_43806 xmm3_121 = eax_116->ow0030;
					Eq_43806 xmm4_123 = __aesenc(xmm4_109, eax_116->ow0000);
					Eq_43806 xmm5_125 = __aesenc(xmm5_110, xmm1_119);
					Eq_43806 xmm6_127 = __aesenc(xmm6_111, xmm2_120);
					Eq_43806 xmm7_129 = __aesenc(xmm7_112, xmm3_121);
					xmm4_109 = __aesenc(xmm4_123, xmm4_123);
					xmm5_110 = __aesenc(xmm5_125, xmm5_125);
					xmm6_111 = __aesenc(xmm6_127, xmm6_127);
					xmm7_112 = __aesenc(xmm7_129, xmm7_129);
					eax_116 += 0x40;
					--ebx_114;
				} while (ebx_114 != 0x00);
				Eq_43806 xmm4_140 = __aesenc(xmm4_109, xmm4_109);
				Eq_43806 xmm5_141 = __aesenc(xmm5_110, xmm5_110);
				Eq_43806 xmm6_142 = __aesenc(xmm6_111, xmm6_111);
				Eq_43806 xmm7_143 = __aesenc(xmm7_112, xmm7_112);
				*edx = (word32) __pxor(__pxor(__aesenc(xmm4_140, xmm4_140), __aesenc(xmm6_142, xmm6_142)), __pxor(__aesenc(xmm5_141, xmm5_141), __aesenc(xmm7_143, xmm7_143)));
				xmm1Out = xmm1_119;
				return <invalid>;
			}
		}
		xmm1_36 = eax_116->ow0000;
	}
	else
	{
		if (ebx == 0x00)
		{
			*edx = (word32) __aesenc(xmm0_14, xmm0_14);
			xmm1Out = xmm0_7;
			return <invalid>;
		}
		if (((word16) eax_116 + 0x10 & 0x0FF0) != 0x00)
			xmm1_36 = __pand(eax_116->ow0000, g_a80F2120[ebx]);
		else
		{
			word128 xmm1_31 = Mem0[eax_116 - 0x10 + ebx:word128];
			xmm1_36 = __pshufb(xmm1_31, xmm1_31, g_a80F2220[ebx * 0x10]);
		}
	}
	Eq_43806 xmm1_45 = __aesenc(xmm1_36, xmm0_14);
	Eq_43806 xmm1_46 = __aesenc(xmm1_45, xmm1_45);
	Eq_43806 xmm1_47 = __aesenc(xmm1_46, xmm1_46);
	*edx = (word32) xmm1_47;
	xmm1Out = xmm1_47;
	return <invalid>;
}

// 0808F930: void runtime.aeshash32(Stack (ptr32 word32) dwArg04, Stack word32 dwArg08)
void runtime.aeshash32(word32 * dwArg04, word32 dwArg08)
{
	__aesenc(__aesenc(__aesenc(__pinsrd((word128) dwArg08, *dwArg04, 0x01), g_t81577A0), g_t81577B0), g_t81577C0);
}

// 0808F970: void runtime.aeshash64(Stack (ptr32 word128) dwArg04, Stack word32 dwArg08)
void runtime.aeshash64(word128 * dwArg04, word32 dwArg08)
{
	__aesenc(__aesenc(__aesenc(__pinsrd(*dwArg04, dwArg08, 0x02), g_t81577A0), g_t81577B0), g_t81577C0);
}

// 0808F9B0: void runtime.checkASM()
// Called from:
//      runtime.check
void runtime.checkASM()
{
}

// 0808F9D0: Register Eq_4 runtime.memequal(Register Eq_4 edx, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C, Register out Eq_4 ebxOut, Register out Eq_4 esiOut, Register out Eq_4 ediOut)
// Called from:
//      runtime.mapassign_faststr
//      type..eq.runtime._func
//      type..eq.runtime.MemStats
//      type..eq.runtime._panic
//      type..eq.runtime._defer
//      type..eq.runtime.special
//      type..eq.runtime.hchan
//      type..eq.runtime.cpuProfile
//      type..eq.runtime.finblock
//      type..eq.runtime.gcControllerState
//      type..eq.runtime.mcentral
//      type..eq.struct { runtime.mcentral runtime.mcentral; runtime.pad [32]uint8 }
//      type..eq.[134]struct { runtime.mcentral runtime.mcentral; runtime.pad [32]uint8 }
//      type..eq.runtime.mstats
//      type..eq.runtime.stackmap
//      type..eq.runtime.sweepdata
//      type..eq.struct { runtime.enabled bool; runtime.pad [3]uint8; runtime.needed bool; runtime.cgo bool; runtime.alignme uint64 }
//      type..eq.struct { runtime.full runtime.lfstack; runtime.empty runtime.lfstack; runtime.pad0 [64]uint8; runtime.wbufSpans struct { runtime.lock runtime.mutex; runtime.free runtime.mSpanList; runtime.busy runtime.mSpanList }; _ uint32; runtime.bytesMarked uint64; runtime.markrootNext uint32; runtime.markrootJobs uint32; runtime.nproc uint32; runtime.tstart int64; runtime.nwait uint32; runtime.ndone uint32; runtime.alldone runtime.note; runtime.helperDrainBlock bool; runtime.nFlushCacheRoots int; runtime.nDataRoots int; runtime.nBSSRoots int; runtime.nSpanRoots int; runtime.nStackRoots int; runtime.markrootDone bool; runtime.startSema uint32; runtime.markDoneSema uint32; runtime.bgMarkReady runtime.note; runtime.bgMarkDone uint32; runtime.mode runtime.gcMode; runtime.userForced bool; runtime.totaltime int64; runtime.initialHeapLive uint64; runtime.assistQueue struct { runtime.lock runtime.mutex; runtime.head runtime.guintptr; runtime.tail runtime.guintptr }; runtime.sweepWaiters struct { runtime.lock runtime.mutex; runtime.head runtime.guintptr }; runtime.cycles uint32; runtime.stwprocs int32; runtime.maxprocs int32; runtime.tSweepTerm int64; runtime.tMark int64; runtime.tMarkTerm int64; runtime.tEnd int64; runtime.pauseNS int64; runtime.pauseStart int64; runtime.heap0 uint64; runtime.heap1 uint64; runtime.heap2 uint64; runtime.heapGoal uint64 }
//      type..eq.struct { runtime.note runtime.note; runtime.mask [3]uint32; runtime.wanted [3]uint32; runtime.ignored [3]uint32; runtime.recv [3]uint32; runtime.state uint32; runtime.inuse bool }
//      type..eq.struct { F uintptr; runtime.c *runtime.mcache; runtime.spc runtime.spanClass }
//      type..eq.struct { F uintptr; runtime.s **runtime.mspan; runtime.h *runtime.mheap; runtime.npage uintptr; runtime.spanclass runtime.spanClass; runtime.large bool }
//      type..eq.struct { F uintptr; runtime.s **runtime.mspan; runtime.size *uintptr; runtime.needzero bool; runtime.noscan bool }
//      type..eq.strconv.decimal
//      type..eq.strconv.extFloat
//      type..eq.internal/poll.FD
//      type..eq.fmt.fmt
Eq_4 runtime.memequal(Eq_4 edx, Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C, union Eq_4 & ebxOut, union Eq_4 & esiOut, union Eq_4 & ediOut)
{
	if (dwArg04 == dwArg08)
	{
		ebxOut = ebx;
		esiOut = dwArg04;
		ediOut = dwArg08;
		return edx;
	}
	else
	{
		Eq_4 edi_14;
		Eq_4 esi_16;
		Eq_4 edx_15 = runtime.memeqbody(fp + 0x10, edx, dwArg0C, dwArg04, dwArg08, out esi_16, out edi_14);
		ebxOut = dwArg0C;
		esiOut = esi_16;
		ediOut = edi_14;
		return edx_15;
	}
}

// 0808F9F0: void runtime.memequal_varlen(Register Eq_4 edx, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
void runtime.memequal_varlen(Eq_4 edx, Eq_4 dwArg04, Eq_4 dwArg08)
{
	if (dwArg04 == dwArg08)
		return;
	Eq_4 ebx_11 = *((word32) edx + 4);
	word32 edi_43;
	word32 esi_42;
	runtime.memeqbody(fp + 0x0C, edx, ebx_11, dwArg04, dwArg08, out esi_42, out edi_43);
}

// 0808FA10: Register Eq_4 runtime.eqstring(Register Eq_4 edx, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C, Register out Eq_4 ebxOut, Register out Eq_4 esiOut, Register out Eq_4 ediOut)
// Called from:
//      runtime.strequal
//      runtime.gogetenv
//      runtime.additab
//      runtime.parsedebugvars
//      runtime.index
//      runtime.moduledataverify1
//      runtime.gentraceback
//      runtime.getArgInfo
//      runtime.showframe
//      runtime.typesEqual
//      type..eq.runtime.modulehash
//      type..eq.runtime.Frame
//      type..eq.runtime.TypeAssertionError
//      type..eq.runtime.dbgVar
//      type..eq.runtime.sigTabT
//      type..eq.[14]runtime.dbgVar
//      type..eq.[2]string
//      type..eq.[3]string
//      type..eq.[4]string
//      type..eq.[5]string
//      type..eq.[65]runtime.sigTabT
//      type..eq.[6]string
//      type..eq.[9]string
//      type..eq.strconv.leftCheat
//      type..eq.[61]strconv.leftCheat
//      type..eq.[133]string
//      type..eq.os.file
//      type..eq.os.PathError
//      reflect.(*interfaceType).MethodByName
//      reflect.(*structType).FieldByName
//      reflect.implements
//      reflect.haveIdenticalType
//      reflect.haveIdenticalUnderlyingType
//      reflect.typesByString
//      reflect.(*structType).FieldByName.func1
//      type..eq.reflect.Method
//      type..eq.reflect.ValueError
//      reflect.(*sliceType).MethodByName
//      type..eq.[27]string
//      type..eq.struct { F uintptr; reflect.name string }
Eq_4 runtime.eqstring(Eq_4 edx, Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C, union Eq_4 & ebxOut, union Eq_4 & esiOut, union Eq_4 & ediOut)
{
	if (dwArg04 == dwArg0C)
	{
		ebxOut = ebx;
		esiOut = dwArg04;
		ediOut = dwArg0C;
		return edx;
	}
	else
	{
		Eq_4 edi_14;
		Eq_4 esi_16;
		Eq_4 edx_15 = runtime.memeqbody(fp + 0x14, edx, dwArg08, dwArg04, dwArg0C, out esi_16, out edi_14);
		ebxOut = dwArg08;
		esiOut = esi_16;
		ediOut = edi_14;
		return edx_15;
	}
}

// 0808FA30: Register Eq_4 runtime.memeqbody(Register (ptr32 int8) eax, Register Eq_4 edx, Register Eq_4 ebx, Register Eq_4 esi, Register Eq_4 edi, Register out Eq_4 esiOut, Register out Eq_4 ediOut)
// Called from:
//      runtime.memequal
//      runtime.memequal_varlen
//      runtime.eqstring
Eq_4 runtime.memeqbody(int8 * eax, Eq_4 edx, Eq_4 ebx, Eq_4 esi, Eq_4 edi, union Eq_4 & esiOut, union Eq_4 & ediOut)
{
	if (ebx < 0x04)
	{
		bool v33_111 = ebx == 0x00;
		if (ebx != 0x00)
		{
			byte cl_18 = (byte) -(ebx * 0x08);
			if ((byte) esi <= 252)
				esi = *esi;
			else
				esi = Mem0[esi - 0x04 + ebx:word32] >>u cl_18;
			Eq_86938 edi_32;
			edx = edi;
			if ((byte) edi <= 252)
				edi_32 = *edi;
			else
				edi_32 = Mem0[edi - 0x04 + ebx:word32] >>u cl_18;
			edi = edi_32 - esi << cl_18;
			v33_111 = edi == 0x00;
		}
		*eax = (int8) v33_111;
		esiOut = esi;
		ediOut = edi;
		return edx;
	}
	else
	{
		do
		{
			if (ebx < 0x40 || g_b815757E != 0x01)
			{
				do
				{
					if (ebx <= 0x04)
					{
						Eq_4 edx_62 = *((word32) ebx + (edi - 0x04));
						Mem66[eax + 0x00:byte] = CONVERT(Mem0[esi_224 - 0x04 + ebx:word32] == edx_62, bool, int8);
						esiOut = esi_224;
						ediOut = edi;
						return edx_62;
					}
					Eq_4 edx_68 = *edi;
					esi = (word32) esi_224 + 4;
					edi = (word32) edi + 4;
					ebx -= 0x04;
					esi_224 = esi;
				} while (*esi_224 == edx_68);
				*eax = 0x00;
				esiOut = esi;
				ediOut = edi;
				return edx_68;
			}
			edx = SEQ(SLICE(edx, word24, 8), __pmovmskb(__pand(__pand(__pcmpeqb(*esi, *edi), __pcmpeqb(*((word32) esi + 16), *((word32) edi + 16))), __pand(__pcmpeqb(*((word32) esi + 32), *((word32) edi + 32)), __pcmpeqb(*((word32) esi + 48), *((word32) edi + 48))))));
			esi = (word32) esi + 64;
			edi = (word32) edi + 64;
			ebx -= 0x40;
		} while (edx == 0xFFFF);
		*eax = 0x00;
		esiOut = esi;
		ediOut = edi;
		return edx;
	}
}

// 0808FB10: void runtime.cmpstring(Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C, Stack Eq_4 dwArg10)
// Called from:
//      runtime/debug.SetTraceback
//      reflect.typesByString
void runtime.cmpstring(Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C, Eq_4 dwArg10)
{
	runtime.cmpbody(fp + 0x14, dwArg10, dwArg08, dwArg04, dwArg0C);
}

// 0808FB30: void strings.IndexByte(Stack (ptr32 (arr Eq_5606)) dwArg04, Stack Eq_4 dwArg08, Stack Eq_5606 bArg0C)
// Called from:
//      runtime.panicwrap
void strings.IndexByte(Eq_5606 (* dwArg04)[], Eq_4 dwArg08, Eq_5606 bArg0C)
{
	Eq_4 ecx_10 = dwArg08;
	Eq_5606 (* edi_12)[] = dwArg04;
	while (ecx_10 != 0x00)
	{
		v11_31 = bArg0C == edi_72[0];
		edi_12 = (Eq_5606 (*)[]) ((char *) edi_72 + 1);
		--ecx_10;
		edi_72 = edi_12;
		if (bArg0C != edi_72[0])
			break;
	}
	if (v11_31)
		;
}

// 0808FB60: void runtime.cmpbody(Register (ptr32 uint32) eax, Register Eq_4 edx, Register Eq_4 ebx, Register Eq_4 esi, Register Eq_4 edi)
// Called from:
//      runtime.cmpstring
void runtime.cmpbody(uint32 * eax, Eq_4 edx, Eq_4 ebx, Eq_4 esi, Eq_4 edi)
{
	Eq_4 ebp_10 = edx;
	int32 edx_7 = edx - ebx;
	if (edx_7 > 0x00)
		ebp_10 = ebx;
	if (esi != edi)
	{
		if (ebp_10 >= 0x04)
		{
			if (g_b815757E == 0x01)
			{
				for (; ebp_10 >= 0x10; ebp_10 -= 0x10)
				{
					word32 ebx_150 = SEQ(SLICE(ebx, word24, 8), __pmovmskb(__pcmpeqb(*edi, *esi)));
					ebx = ebx_150 ^ 0xFFFF;
					if ((ebx_150 ^ 0xFFFF) != 0x00)
					{
						int32 ebx_155 = __bsf(ebx_150 ^ 0xFFFF);
						*eax = (uint32) (int8) (*((word32) esi + ebx_155) > *((word32) edi + ebx_155)) * 0x02 + ~0x00;
						return;
					}
					esi = (word32) esi + 16;
					edi = (word32) edi + 16;
				}
			}
			while (true)
			{
				Eq_87050 ecx_119;
				Eq_87050 ebx_118;
				if (ebp_10 <= 0x04)
					break;
				ebx_118 = *esi;
				ecx_119 = *edi;
				if (ebx_118 != ecx_119)
					goto l0808FBE6;
				esi = (word32) esi + 4;
				edi = (word32) edi + 4;
				ebp_10 -= 0x04;
			}
			ebx_118 = *((word32) ebp_10 + (esi - 0x04));
			ecx_119 = Mem0[edi - 0x04 + ebp_10:word32];
			if (ebx_118 != ecx_119)
			{
l0808FBE6:
				uint32 ebx_123 = __bswap(ebx_118);
				*eax = (ebx_123 >> (byte) __bsr(__bswap(ecx_119) ^ ebx_123) & 0x01) * 0x02 + ~0x00;
				return;
			}
		}
		else
		{
			ui32 ecx_21 = -(ebp_10 * 0x08);
			byte cl_39 = (byte) ecx_21;
			if (ecx_21 != 0x00)
			{
				Eq_87123 esi_40;
				if ((byte) esi <= 252)
					esi_40 = *esi;
				else
					esi_40 = Mem0[esi - 0x04 + ebp_10:word32] >>u cl_39;
				uint32 edi_60;
				Eq_87050 esi_45 = esi_40 << cl_39;
				if ((byte) edi <= 252)
					edi_60 = (uint32) *edi;
				else
					edi_60 = Mem0[edi - 0x04 + ebp_10:word32] >>u cl_39;
				uint32 esi_67 = __bswap(esi_45);
				ui32 edi_69 = __bswap(edi_60 << cl_39) ^ esi_67;
				if (edi_69 != 0x00)
				{
					*eax = (esi_67 >> (byte) __bsr(edi_69) & 0x01) * 0x02 + ~0x00;
					return;
				}
			}
		}
	}
	*eax = (uint32) (int8) (edx_7 == 0x00) - 0x01 + (uint32) ((int8) (edx_7 < 0x00)) * 0x02;
}

// 0808FC60: Register word32 runtime.return0()
// Called from:
//      runtime.deferproc
word32 runtime.return0()
{
	return 0x00;
}

// 0808FC70: void runtime.goexit(Register (ptr32 Eq_2) gs)
void runtime.goexit(struct Eq_2 * gs)
{
	runtime.goexit1(gs);
	__syscall(0x03);
	__syscall(0x03);
	__syscall(0x03);
	__syscall(0x03);
	__syscall(0x03);
	__syscall(0x03);
	__syscall(0x03);
	__syscall(0x03);
	__syscall(0x03);
	runtime.prefetcht0();
}

// 0808FC80: void runtime.prefetcht0()
// Called from:
//      runtime.testAtomic64
//      runtime.goexit
void runtime.prefetcht0()
{
}

// 0808FC90: void runtime.prefetcht1()
// Called from:
//      runtime.testAtomic64
void runtime.prefetcht1()
{
}

// 0808FCA0: void runtime.prefetcht2()
// Called from:
//      runtime.testAtomic64
void runtime.prefetcht2()
{
}

// 0808FCB0: void runtime.prefetchnta()
// Called from:
//      runtime.testAtomic64
void runtime.prefetchnta()
{
}

// 0808FCC0: void runtime.uint32tofloat64()
// Called from:
//      runtime.nextSample
//      runtime.deductSweepCredit
//      runtime.int64tofloat64
//      runtime.uint64tofloat64
void runtime.uint32tofloat64()
{
}

// 0808FCE0: void runtime.float64touint32()
// Called from:
//      runtime._d2v
void runtime.float64touint32()
{
	Eq_83748 wLoc0C_17 = __fstcw();
	__fldcw(runtime.controlWord64trunc);
	__fldcw(wLoc0C_17);
}

// 0808FD10: void runtime.duffzero(Register word32 eax, Register (ptr32 Eq_40947) edi)
// Called from:
//      runtime.sysargs
void runtime.duffzero(word32 eax, struct Eq_40947 * edi)
{
	edi->dw0000 = eax;
	edi->dw0004 = eax;
	edi->dw0008 = eax;
	edi->dw000C = eax;
	edi->dw0010 = eax;
	edi->dw0014 = eax;
	edi->dw0018 = eax;
	edi->dw001C = eax;
	edi->dw0020 = eax;
	edi->dw0024 = eax;
	edi->dw0028 = eax;
	edi->dw002C = eax;
	edi->dw0030 = eax;
	edi->dw0034 = eax;
	edi->dw0038 = eax;
	edi->dw003C = eax;
	edi->dw0040 = eax;
	edi->dw0044 = eax;
	edi->dw0048 = eax;
	edi->dw004C = eax;
	edi->dw0050 = eax;
	edi->dw0054 = eax;
	edi->dw0058 = eax;
	edi->dw005C = eax;
	edi->dw0060 = eax;
	edi->dw0064 = eax;
	edi->dw0068 = eax;
	edi->dw006C = eax;
	edi->dw0070 = eax;
	edi->dw0074 = eax;
	edi->dw0078 = eax;
	edi->dw007C = eax;
	edi->dw0080 = eax;
	edi->dw0084 = eax;
	edi->dw0088 = eax;
	edi->dw008C = eax;
	edi->dw0090 = eax;
	edi->dw0094 = eax;
	edi->dw0098 = eax;
	edi->dw009C = eax;
	edi->dw00A0 = eax;
	edi->dw00A4 = eax;
	edi->dw00A8 = eax;
	edi->dw00AC = eax;
	edi->dw00B0 = eax;
	edi->dw00B4 = eax;
	edi->dw00B8 = eax;
	edi->dw00BC = eax;
	edi->dw00C0 = eax;
	edi->dw00C4 = eax;
	edi->dw00C8 = eax;
	edi->dw00CC = eax;
	edi->dw00D0 = eax;
	edi->dw00D4 = eax;
	edi->dw00D8 = eax;
	edi->dw00DC = eax;
	edi->dw00E0 = eax;
	edi->dw00E4 = eax;
	edi->dw00E8 = eax;
	edi->dw00EC = eax;
	edi->dw00F0 = eax;
	edi->dw00F4 = eax;
	edi->dw00F8 = eax;
	edi->dw00FC = eax;
	edi->dw0100 = eax;
	edi->dw0104 = eax;
	edi->dw0108 = eax;
	edi->dw010C = eax;
	edi->dw0110 = eax;
	edi->dw0114 = eax;
	edi->dw0118 = eax;
	edi->dw011C = eax;
	edi->dw0120 = eax;
	edi->dw0124 = eax;
	edi->dw0128 = eax;
	edi->dw012C = eax;
	fn0808FD5C(eax, &edi->dw012C + 1);
}

// 0808FD50: void fn0808FD50(Register word32 eax, Register (ptr32 Eq_54501) edi)
// Called from:
//      runtime.sigprof
void fn0808FD50(word32 eax, struct Eq_54501 * edi)
{
	edi->dw0000 = eax;
	edi->dw0004 = eax;
	edi->dw0008 = eax;
	edi->dw000C = eax;
	edi->dw0010 = eax;
	edi->dw0014 = eax;
	edi->dw0018 = eax;
	edi->dw001C = eax;
	edi->dw0020 = eax;
	edi->dw0024 = eax;
	edi->dw0028 = eax;
	edi->dw002C = eax;
	fn0808FD5C(eax, &edi->dw002C + 1);
}

// 0808FD5C: void fn0808FD5C(Register word32 eax, Register (ptr32 Eq_66527) edi)
// Called from:
//      runtime.copystack
//      runtime.duffzero
//      fn0808FD50
void fn0808FD5C(word32 eax, struct Eq_66527 * edi)
{
	edi->dw0000 = eax;
	edi->dw0004 = eax;
	edi->dw0008 = eax;
	edi->dw000C = eax;
	fn0808FD60(eax, &edi->dw000C + 1);
}

// 0808FD60: void fn0808FD60(Register word32 eax, Register (ptr32 Eq_28286) edi)
// Called from:
//      runtime.scanstack
//      runtime.moduledataverify1
//      runtime.gentraceback
//      fn0808FD5C
void fn0808FD60(word32 eax, struct Eq_28286 * edi)
{
	edi->dw0000 = eax;
	edi->dw0004 = eax;
	edi->dw0008 = eax;
	edi->dw000C = eax;
	edi->dw0010 = eax;
	edi->dw0014 = eax;
	edi->dw0018 = eax;
	edi->dw001C = eax;
	edi->dw0020 = eax;
	edi->dw0024 = eax;
	edi->dw0028 = eax;
	edi->dw002C = eax;
	edi->dw0030 = eax;
	edi->dw0034 = eax;
	edi->dw0038 = eax;
	edi->dw003C = eax;
	fn0808FD70(eax, &edi->dw003C + 1);
}

// 0808FD6D: Register (ptr32 Eq_38460) fn0808FD6D(Register word32 eax, Register (ptr32 Eq_38460) edi)
// Called from:
//      runtime.typelinksinit
struct Eq_38460 * fn0808FD6D(word32 eax, struct Eq_38460 * edi)
{
	edi->dw0000 = eax;
	edi->dw0004 = eax;
	edi->dw0008 = eax;
	return fn0808FD70(eax, &edi->dw0008 + 1);
}

// 0808FD70: Register (ptr32 Eq_38456) fn0808FD70(Register word32 eax, Register (ptr32 Eq_38456) edi)
// Called from:
//      runtime.mProf_Malloc
//      runtime.saveblockevent
//      runtime.stringtoslicerune
//      runtime.tracebackCgoContext
//      fn0808FD60
//      fn0808FD6D
struct Eq_38456 * fn0808FD70(word32 eax, struct Eq_38456 * edi)
{
	edi->dw0000 = eax;
	edi->dw0004 = eax;
	edi->dw0008 = eax;
	edi->dw000C = eax;
	edi->dw0010 = eax;
	edi->dw0014 = eax;
	edi->dw0018 = eax;
	return fn0808FD77(eax, &edi->dw0018 + 1);
}

// 0808FD77: Register (ptr32 Eq_44047) fn0808FD77(Register word32 eax, Register (ptr32 Eq_44047) edi)
// Called from:
//      runtime.printuint
//      runtime.printhex
//      fn0808FD70
struct Eq_44047 * fn0808FD77(word32 eax, struct Eq_44047 * edi)
{
	edi->dw0000 = eax;
	edi->dw0004 = eax;
	edi->dw0008 = eax;
	edi->dw000C = eax;
	edi->dw0010 = eax;
	edi->dw0014 = eax;
	edi->dw0018 = eax;
	edi->dw001C = eax;
	edi->dw0020 = eax;
	edi->dw0024 = eax;
	edi->dw0028 = eax;
	edi->dw002C = eax;
	edi->dw0030 = eax;
	edi->dw0034 = eax;
	edi->dw0038 = eax;
	edi->dw003C = eax;
	edi->dw0040 = eax;
	edi->dw0044 = eax;
	edi->dw0048 = eax;
	edi->dw004C = eax;
	edi->dw0050 = eax;
	edi->dw0054 = eax;
	edi->dw0058 = eax;
	edi->dw005C = eax;
	edi->dw0060 = eax;
	return &edi->dw0060 + 1;
}

// 0808FD80: Register (ptr32 Eq_5755) fn0808FD80(Register Eq_4 eax, Register (ptr32 Eq_5755) edi)
// Called from:
//      strconv.formatBits
//      reflect.implements
//      reflect.funcStr
struct Eq_5755 * fn0808FD80(Eq_4 eax, struct Eq_5755 * edi)
{
	edi->t0000 = eax;
	edi->t0004 = eax;
	return fn0808FD82(eax, (char *) &edi->t0004 + 4);
}

// 0808FD82: Register (ptr32 Eq_5751) fn0808FD82(Register Eq_4 eax, Register (ptr32 Eq_5751) edi)
// Called from:
//      runtime.Caller
//      fn0808FD80
struct Eq_5751 * fn0808FD82(Eq_4 eax, struct Eq_5751 * edi)
{
	edi->t0000 = eax;
	edi->t0004 = eax;
	edi->t0008 = eax;
	return fn0808FD85(eax, (char *) &edi->t0008 + 4);
}

// 0808FD83: Register (ptr32 Eq_4) fn0808FD83(Register Eq_4 eax, Register (ptr32 Eq_4) edi)
// Called from:
//      reflect.(*structType).Field
//      reflect.(*structType).FieldByIndex
//      reflect.(*structType).FieldByNameFunc
//      reflect.(*structType).FieldByName
//      reflect.(*funcType).Field
//      reflect.(*funcType).FieldByIndex
//      reflect.(*funcType).FieldByName
//      reflect.(*funcType).FieldByNameFunc
//      reflect.(*funcTypeFixed128).Field
//      reflect.(*funcTypeFixed128).FieldByIndex
//      reflect.(*funcTypeFixed128).FieldByName
//      reflect.(*funcTypeFixed128).FieldByNameFunc
//      reflect.(*funcTypeFixed16).Field
//      reflect.(*funcTypeFixed16).FieldByIndex
//      reflect.(*funcTypeFixed16).FieldByName
//      reflect.(*funcTypeFixed16).FieldByNameFunc
//      reflect.(*funcTypeFixed32).Field
//      reflect.(*funcTypeFixed32).FieldByIndex
//      reflect.(*funcTypeFixed32).FieldByName
//      reflect.(*funcTypeFixed32).FieldByNameFunc
//      reflect.(*funcTypeFixed4).Field
//      reflect.(*funcTypeFixed4).FieldByIndex
//      reflect.(*funcTypeFixed4).FieldByName
//      reflect.(*funcTypeFixed4).FieldByNameFunc
//      reflect.(*funcTypeFixed64).Field
//      reflect.(*funcTypeFixed64).FieldByIndex
//      reflect.(*funcTypeFixed64).FieldByName
//      reflect.(*funcTypeFixed64).FieldByNameFunc
//      reflect.(*funcTypeFixed8).Field
//      reflect.(*funcTypeFixed8).FieldByIndex
//      reflect.(*funcTypeFixed8).FieldByName
//      reflect.(*funcTypeFixed8).FieldByNameFunc
//      reflect.(*interfaceType).Field
//      reflect.(*interfaceType).FieldByIndex
//      reflect.(*interfaceType).FieldByName
//      reflect.(*interfaceType).FieldByNameFunc
//      reflect.(*ptrType).Field
//      reflect.(*ptrType).FieldByIndex
//      reflect.(*ptrType).FieldByName
//      reflect.(*ptrType).FieldByNameFunc
//      reflect.(*sliceType).Field
//      reflect.(*sliceType).FieldByIndex
//      reflect.(*sliceType).FieldByName
//      reflect.(*sliceType).FieldByNameFunc
union Eq_4 * fn0808FD83(Eq_4 eax, union Eq_4 * edi)
{
	*edi = (union Eq_4 *) eax;
	return fn0808FD84(eax, (char *) edi + 4);
}

// 0808FD84: Register (ptr32 Eq_5751) fn0808FD84(Register Eq_4 eax, Register (ptr32 Eq_5751) edi)
// Called from:
//      fn0808FD83
//      sync.(*Map).dirtyLocked
struct Eq_5751 * fn0808FD84(Eq_4 eax, struct Eq_5751 * edi)
{
	edi->t0000 = eax;
	return fn0808FD85(eax, &edi->t0004);
}

// 0808FD85: Register (ptr32 Eq_4) fn0808FD85(Register Eq_4 eax, Register (ptr32 Eq_4) edi)
// Called from:
//      runtime.tracebackdefers
//      runtime.gentraceback
//      fn0808FD82
//      fn0808FD84
union Eq_4 * fn0808FD85(Eq_4 eax, union Eq_4 * edi)
{
	*edi = (union Eq_4 *) eax;
	return fn0808FD86(eax, (char *) edi + 4);
}

// 0808FD86: Register (ptr32 Eq_17296) fn0808FD86(Register Eq_4 eax, Register (ptr32 Eq_17296) edi)
// Called from:
//      runtime.heapBitsSetTypeGCProg
//      runtime.gcMarkTermination
//      fn0808FD85
//      reflect.(*rtype).Method
//      reflect.(*interfaceType).Method
//      reflect.(*interfaceType).MethodByName
//      reflect.(*structType).Method
//      reflect.(*structType).MethodByName
//      reflect.(*funcType).Method
//      reflect.(*funcType).MethodByName
//      reflect.(*funcTypeFixed128).Method
//      reflect.(*funcTypeFixed128).MethodByName
//      reflect.(*funcTypeFixed16).Method
//      reflect.(*funcTypeFixed16).MethodByName
//      reflect.(*funcTypeFixed32).Method
//      reflect.(*funcTypeFixed32).MethodByName
//      reflect.(*funcTypeFixed4).Method
//      reflect.(*funcTypeFixed4).MethodByName
//      reflect.(*funcTypeFixed64).Method
//      reflect.(*funcTypeFixed64).MethodByName
//      reflect.(*funcTypeFixed8).Method
//      reflect.(*funcTypeFixed8).MethodByName
//      reflect.(*ptrType).Method
//      reflect.(*ptrType).MethodByName
//      reflect.(*sliceType).Method
//      reflect.(*sliceType).MethodByName
struct Eq_17296 * fn0808FD86(Eq_4 eax, struct Eq_17296 * edi)
{
	edi->t0000 = eax;
	edi->t0004 = eax;
	edi->t0008 = eax;
	return fn0808FD89(eax, (char *) &edi->t0008 + 4);
}

// 0808FD87: void fn0808FD87(Register Eq_4 eax, Register (ptr32 Eq_75800) edi)
// Called from:
//      runtime.callers
void fn0808FD87(Eq_4 eax, struct Eq_75800 * edi)
{
	edi->t0000 = eax;
	edi->t0004 = eax;
	fn0808FD89(eax, (char *) &edi->t0004 + 4);
}

// 0808FD88: void fn0808FD88(Register Eq_4 eax, Register (ptr32 Eq_4) edi)
// Called from:
//      runtime.panicwrap
//      runtime.Caller
//      runtime.stringtoslicebyte
//      runtime.(*Frames).Next
//      runtime.(*stackExpander).next
//      runtime.(*pcExpander).next
//      strconv.(*extFloat).FixedDecimal
//      strconv.genericFtoa
//      syscall.uitoa
//      reflect.haveIdenticalUnderlyingType
void fn0808FD88(Eq_4 eax, union Eq_4 * edi)
{
	*edi = (union Eq_4 *) eax;
	fn0808FD89(eax, (char *) edi + 4);
}

// 0808FD89: Register Eq_4 fn0808FD89(Register Eq_4 eax, Register Eq_4 edi)
// Called from:
//      runtime.freedefer
//      runtime.expandCgoFrames
//      runtime.tracebackCgoContext
//      runtime.printCgoTraceback
//      runtime.typelinksinit
//      fn0808FD86
//      fn0808FD87
//      fn0808FD88
Eq_4 fn0808FD89(Eq_4 eax, Eq_4 edi)
{
	*edi = eax;
	*((word32) edi + 4) = eax;
	return fn0808FD8B(eax, (word32) edi + 8);
}

// 0808FD8A: void fn0808FD8A(Register Eq_4 eax, Register (ptr32 word32) edi)
// Called from:
//      runtime.SetFinalizer
//      runtime.gcMarkTermination
//      runtime.(*mspan).sweep
//      runtime.sigprof
//      runtime.sigtrampgo
//      runtime.traceGoStart
//      runtime.traceGoSysExit
//      strconv.(*decimal).Assign
//      strconv.(*extFloat).ShortestDecimal
//      strconv.genericFtoa
//      strconv.bigFtoa
void fn0808FD8A(Eq_4 eax, word32 * edi)
{
	*edi = (word32) eax;
	fn0808FD8B(eax, edi + 1);
}

// 0808FD8B: Register (ptr32 Eq_2396) fn0808FD8B(Register Eq_4 eax, Register (ptr32 Eq_2396) edi)
// Called from:
//      runtime.cgoCheckTypedBlock
//      runtime.persistentalloc
//      runtime.typedslicecopy
//      runtime.(*mheap).alloc
//      runtime.setsig
//      runtime.setsigstack
//      runtime.getsig
//      runtime.testdefersizes
//      runtime.gopanic
//      runtime.entersyscallblock
//      runtime.newproc
//      runtime.sigtrampgo
//      fn0808FD89
//      fn0808FD8A
//      sync.init.1
//      reflect.funcLayout
struct Eq_2396 * fn0808FD8B(Eq_4 eax, struct Eq_2396 * edi)
{
	edi->t0000 = eax;
	edi->t0004 = eax;
	edi->t0008 = eax;
	edi->t000C = eax;
	edi->t0010 = eax;
	return (char *) &edi->t0010 + 4;
}

// 0808FDA0: void runtime.duffcopy(Register (ptr32 Eq_87787) esi, Register (ptr32 Eq_87788) edi)
void runtime.duffcopy(struct Eq_87787 * esi, struct Eq_87788 * edi)
{
	edi->dw0000 = esi->dw0000;
	edi->dw0004 = esi->dw0004;
	edi->dw0008 = esi->dw0008;
	edi->dw000C = esi->dw000C;
	edi->dw0010 = esi->dw0010;
	edi->dw0014 = esi->dw0014;
	edi->dw0018 = esi->dw0018;
	edi->dw001C = esi->dw001C;
	edi->dw0020 = esi->dw0020;
	edi->dw0024 = esi->dw0024;
	edi->dw0028 = esi->dw0028;
	edi->dw002C = esi->dw002C;
	edi->dw0030 = esi->dw0030;
	edi->dw0034 = esi->dw0034;
	edi->dw0038 = esi->dw0038;
	edi->dw003C = esi->dw003C;
	edi->dw0040 = esi->dw0040;
	edi->dw0044 = esi->dw0044;
	edi->dw0048 = esi->dw0048;
	edi->dw004C = esi->dw004C;
	edi->dw0050 = esi->dw0050;
	edi->dw0054 = esi->dw0054;
	edi->dw0058 = esi->dw0058;
	edi->dw005C = esi->dw005C;
	edi->dw0060 = esi->dw0060;
	edi->dw0064 = esi->dw0064;
	edi->dw0068 = esi->dw0068;
	edi->dw006C = esi->dw006C;
	edi->dw0070 = esi->dw0070;
	edi->dw0074 = esi->dw0074;
	edi->dw0078 = esi->dw0078;
	edi->dw007C = esi->dw007C;
	edi->dw0080 = esi->dw0080;
	edi->dw0084 = esi->dw0084;
	edi->dw0088 = esi->dw0088;
	edi->dw008C = esi->dw008C;
	edi->dw0090 = esi->dw0090;
	edi->dw0094 = esi->dw0094;
	edi->dw0098 = esi->dw0098;
	edi->dw009C = esi->dw009C;
	edi->dw00A0 = esi->dw00A0;
	edi->dw00A4 = esi->dw00A4;
	edi->dw00A8 = esi->dw00A8;
	edi->dw00AC = esi->dw00AC;
	edi->dw00B0 = esi->dw00B0;
	edi->dw00B4 = esi->dw00B4;
	edi->dw00B8 = esi->dw00B8;
	edi->dw00BC = esi->dw00BC;
	edi->dw00C0 = esi->dw00C0;
	edi->dw00C4 = esi->dw00C4;
	edi->dw00C8 = esi->dw00C8;
	edi->dw00CC = esi->dw00CC;
	edi->dw00D0 = esi->dw00D0;
	edi->dw00D4 = esi->dw00D4;
	edi->dw00D8 = esi->dw00D8;
	edi->dw00DC = esi->dw00DC;
	edi->dw00E0 = esi->dw00E0;
	edi->dw00E4 = esi->dw00E4;
	edi->dw00E8 = esi->dw00E8;
	edi->dw00EC = esi->dw00EC;
	edi->dw00F0 = esi->dw00F0;
	edi->dw00F4 = esi->dw00F4;
	edi->dw00F8 = esi->dw00F8;
	edi->dw00FC = esi->dw00FC;
	edi->dw0100 = esi->dw0100;
	edi->dw0104 = esi->dw0104;
	edi->dw0108 = esi->dw0108;
	edi->dw010C = esi->dw010C;
	edi->dw0110 = esi->dw0110;
	edi->dw0114 = esi->dw0114;
	edi->dw0118 = esi->dw0118;
	edi->dw011C = esi->dw011C;
	edi->dw0120 = esi->dw0120;
	edi->dw0124 = esi->dw0124;
	edi->dw0128 = esi->dw0128;
	edi->dw012C = esi->dw012C;
	edi->dw0130 = esi->dw0130;
	edi->dw0134 = esi->dw0134;
	edi->dw0138 = esi->dw0138;
	edi->dw013C = esi->dw013C;
	edi->dw0140 = esi->dw0140;
	edi->dw0144 = esi->dw0144;
	edi->dw0148 = esi->dw0148;
	edi->dw014C = esi->dw014C;
	edi->dw0150 = esi->dw0150;
	edi->dw0154 = esi->dw0154;
	edi->dw0158 = esi->dw0158;
	edi->dw015C = esi->dw015C;
	edi->dw0160 = esi->dw0160;
	edi->dw0164 = esi->dw0164;
	edi->dw0168 = esi->dw0168;
	edi->dw016C = esi->dw016C;
	edi->dw0170 = esi->dw0170;
	edi->dw0174 = esi->dw0174;
	edi->dw0178 = esi->dw0178;
	edi->dw017C = esi->dw017C;
	fn08090160(&esi->dw017C + 1, &edi->dw017C + 1);
}

// 08090160: void fn08090160(Register Eq_4 esi, Register (ptr32 Eq_75408) edi)
// Called from:
//      runtime.tracebackCgoContext
//      runtime.traceback1
//      runtime.duffcopy
void fn08090160(Eq_4 esi, struct Eq_75408 * edi)
{
	edi->dw0000 = (word32) *esi;
	edi->t0004 = *((word32) esi + 4);
	edi->t0008 = *((word32) esi + 8);
	edi->t000C = *((word32) esi + 0x0C);
	edi->t0010 = *((word32) esi + 16);
	edi->t0014 = *((word32) esi + 20);
	edi->t0018 = *((word32) esi + 24);
	edi->t001C = *((word32) esi + 28);
	edi->t0020 = *((word32) esi + 32);
	edi->t0024 = *((word32) esi + 36);
	edi->t0028 = *((word32) esi + 40);
	edi->t002C = *((word32) esi + 44);
	edi->t0030 = *((word32) esi + 48);
	edi->t0034 = *((word32) esi + 52);
	edi->t0038 = *((word32) esi + 56);
	edi->t003C = *((word32) esi + 60);
	edi->t0040 = *((word32) esi + 64);
	edi->t0044 = *((word32) esi + 0x0044);
	edi->t0048 = *((word32) esi + 72);
	edi->t004C = *((word32) esi + 76);
	edi->t0050 = *((word32) esi + 80);
	edi->t0054 = *((word32) esi + 84);
	edi->t0058 = *((word32) esi + 88);
	edi->t005C = *((word32) esi + 92);
	edi->t0060 = *((word32) esi + 96);
	fn0809025A((word32) esi + 100, (char *) &edi->t0060 + 4);
}

// 080901EC: void fn080901EC(Register (ptr32 Eq_5705) esi, Register (ptr32 Eq_5706) edi)
// Called from:
//      runtime.panicwrap
void fn080901EC(struct Eq_5705 * esi, struct Eq_5706 * edi)
{
	edi->dw0000 = esi->dw0000;
	edi->dw0004 = esi->dw0004;
	edi->dw0008 = esi->dw0008;
	edi->dw000C = esi->dw000C;
	edi->dw0010 = esi->dw0010;
	fn0809021E(&esi->dw0010 + 1, &edi->dw0010 + 1);
}

// 0809021E: void fn0809021E(Register Eq_4 esi, Register (ptr32 Eq_88560) edi)
// Called from:
//      fn080901EC
//      reflect.(*structType).FieldByIndex
//      reflect.(*structType).FieldByNameFunc
//      reflect.(*structType).FieldByName
//      reflect.(*sliceType).Field
//      reflect.(*sliceType).FieldByIndex
//      reflect.(*sliceType).FieldByName
//      reflect.(*sliceType).FieldByNameFunc
//      fmt.(*pp).printValue
void fn0809021E(Eq_4 esi, struct Eq_88560 * edi)
{
	edi->dw0000 = (word32) *esi;
	edi->dw0004 = (word32) *((word32) esi + 4);
	edi->t0008 = *((word32) esi + 8);
	edi->t000C = *((word32) esi + 0x0C);
	edi->dw0010 = (word32) *((word32) esi + 16);
	fn08090250((word32) esi + 20, &edi->dw0010 + 1);
}

// 08090228: void fn08090228(Register (ptr32 Eq_4984) esi, Register (ptr32 Eq_4985) edi)
// Called from:
//      runtime.(*TypeAssertionError).Error
void fn08090228(struct Eq_4984 * esi, struct Eq_4985 * edi)
{
	edi->dw0000 = esi->dw0000;
	edi->dw0004 = esi->dw0004;
	fn0809023C(&esi->dw0004 + 1, &edi->dw0004 + 1);
}

// 0809023C: void fn0809023C(Register (ptr32 Eq_88616) esi, Register (ptr32 Eq_88617) edi)
// Called from:
//      fn08090228
//      reflect.(*rtype).Method
//      reflect.(*interfaceType).MethodByName
//      reflect.(*sliceType).MethodByName
void fn0809023C(struct Eq_88616 * esi, struct Eq_88617 * edi)
{
	edi->dw0000 = esi->dw0000;
	edi->dw0004 = esi->dw0004;
	fn08090250(&esi->dw0004 + 1, &edi->dw0004 + 1);
}

// 08090246: void fn08090246(Register (ptr32 word32) esi, Register Eq_4 edi)
// Called from:
//      reflect.(*rtype).ptrTo
//      reflect.FuncOf
void fn08090246(word32 * esi, Eq_4 edi)
{
	*edi = *esi;
	fn08090250(esi + 1, (word32) edi + 4);
}

// 08090250: void fn08090250(Register Eq_4 esi, Register Eq_4 edi)
// Called from:
//      runtime.panicwrap
//      runtime.Caller
//      runtime.(*Frames).Next
//      runtime.(*stackExpander).next
//      runtime.(*pcExpander).next
//      runtime.expandCgoFrames
//      fn0809021E
//      fn0809023C
//      fn08090246
void fn08090250(Eq_4 esi, Eq_4 edi)
{
	*edi = *esi;
	fn0809025A((word32) esi + 4, (word32) edi + 4);
}

// 0809025A: void fn0809025A(Register (ptr32 Eq_66732) esi, Register (ptr32 Eq_66733) edi)
// Called from:
//      runtime.newstack
//      fn08090160
//      fn08090250
void fn0809025A(struct Eq_66732 * esi, struct Eq_66733 * edi)
{
	edi->dw0000 = esi->dw0000;
	edi->dw0004 = esi->dw0004;
	edi->dw0008 = esi->dw0008;
	edi->dw000C = esi->dw000C;
	edi->dw0010 = esi->dw0010;
	edi->dw0014 = esi->dw0014;
	edi->dw0018 = esi->dw0018;
}

// 08090264: void fn08090264(Register (ptr32 word32) esi, Register (ptr32 word32) edi)
// Called from:
//      runtime.cgocallbackg
//      strconv.genericFtoa
//      strconv.bigFtoa
//      strconv.formatDigits
void fn08090264(word32 * esi, word32 * edi)
{
	*edi = *esi;
	fn0809026E(esi + 1, edi + 1);
}

// 0809026E: void fn0809026E(Register Eq_4 esi, Register (ptr32 Eq_70358) edi)
// Called from:
//      runtime.moduledataverify1
//      fn08090264
//      reflect.funcLayout
void fn0809026E(Eq_4 esi, struct Eq_70358 * edi)
{
	edi->dw0000 = (word32) *esi;
	edi->t0004 = *((word32) esi + 4);
	edi->t0008 = *((word32) esi + 8);
	edi->t000C = *((word32) esi + 0x0C);
	edi->t0010 = *((word32) esi + 16);
}

// 08090278: Register (ptr32 Eq_13241) fn08090278(Register (ptr32 Eq_13241) esi, Register (ptr32 Eq_13242) edi)
// Called from:
//      runtime.mallocinit
struct Eq_13241 * fn08090278(struct Eq_13241 * esi, struct Eq_13242 * edi)
{
	edi->dw0000 = esi->dw0000;
	edi->dw0004 = esi->dw0004;
	edi->dw0008 = esi->dw0008;
	edi->dw000C = esi->dw000C;
	return &esi->dw000C + 1;
}

// 080902B0: Register Eq_4 runtime.memclrNoHeapPointers(Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
// Called from:
//      runtime.evacuate
//      runtime.mallocgc
//      runtime.typedmemclr
//      runtime.memclrHasPointers
//      runtime.heapBits.initSpan
//      runtime.heapBitsSetTypeGCProg
//      runtime.(*fixalloc).alloc
//      runtime.(*mheap).alloc
//      runtime.newArenaMayUnlock
//      runtime.newproc1
//      runtime.growslice
//      runtime.rawbyteslice
//      runtime.rawruneslice
//      reflect.memclrNoHeapPointers
Eq_4 runtime.memclrNoHeapPointers(Eq_4 dwArg04, Eq_4 dwArg08)
{
	Eq_4 edi_117 = dwArg04;
	Eq_4 ebx_10 = dwArg08;
	while (ebx_10 != 0x00)
	{
		if (ebx_10 <= 0x02)
		{
			*edi_117 = 0x00;
			*((word32) ebx_10 + (edi_117 - 0x01)) = 0x00;
			return edi_117;
		}
		if (ebx_10 < 0x04)
		{
			*edi_117 = 0x00;
			*((word32) edi_117 + 2) = 0x00;
			return edi_117;
		}
		if (ebx_10 == 0x04)
		{
			*edi_117 = 0x00;
			return edi_117;
		}
		if (ebx_10 <= 0x08)
		{
			*edi_117 = 0x00;
			Mem34[edi_117 - 0x04 + ebx_10:word32] = 0x00;
			return edi_117;
		}
		if (ebx_10 <= 0x10)
		{
			*edi_117 = 0x00;
			*((word32) edi_117 + 4) = 0x00;
			Mem39[edi_117 - 0x08 + ebx_10:word32] = 0x00;
			Mem40[edi_117 - 0x04 + ebx_10:word32] = 0x00;
			return edi_117;
		}
		if (g_b815757E != 0x01)
		{
			uint32 ecx_45;
			for (ecx_45 = ebx_10 >> 0x02; ecx_45 != 0x00; --ecx_45)
			{
				*edi_117 = 0x00;
				edi_117 += 4;
			}
			ebx_10 &= 0x03;
			if (ebx_10 != 0x00)
				continue;
			return edi_117;
		}
		if (ebx_10 <= 0x20)
		{
			*edi_117 = 0x00;
			Mem62[edi_117 - 0x10 + ebx_10:word128] = 0x00;
			return edi_117;
		}
		if (ebx_10 <= 0x40)
		{
			*edi_117 = 0x00;
			*((word32) edi_117 + 16) = 0x00;
			Mem67[edi_117 - 0x20 + ebx_10:word128] = 0x00;
			Mem68[edi_117 - 0x10 + ebx_10:word128] = 0x00;
			return edi_117;
		}
		if (ebx_10 <= 0x80)
		{
			*edi_117 = 0x00;
			*((word32) edi_117 + 16) = 0x00;
			*((word32) edi_117 + 32) = 0x00;
			*((word32) edi_117 + 48) = 0x00;
			Mem75[edi_117 - 0x40 + ebx_10:word128] = 0x00;
			Mem76[edi_117 - 0x30 + ebx_10:word128] = 0x00;
			Mem77[edi_117 - 0x20 + ebx_10:word128] = 0x00;
			Mem78[edi_117 - 0x10 + ebx_10:word128] = 0x00;
			return edi_117;
		}
		if (ebx_10 <= 0x0100)
		{
			*edi_117 = 0x00;
			*((word32) edi_117 + 16) = 0x00;
			*((word32) edi_117 + 32) = 0x00;
			*((word32) edi_117 + 48) = 0x00;
			*((word32) edi_117 + 64) = 0x00;
			*((word32) edi_117 + 80) = 0x00;
			*((word32) edi_117 + 96) = 0x00;
			*((word32) edi_117 + 112) = 0x00;
			Mem89[edi_117 - 0x80 + ebx_10:word128] = 0x00;
			Mem90[edi_117 - 0x70 + ebx_10:word128] = 0x00;
			Mem91[edi_117 - 0x60 + ebx_10:word128] = 0x00;
			Mem92[edi_117 - 0x50 + ebx_10:word128] = 0x00;
			Mem93[edi_117 - 0x40 + ebx_10:word128] = 0x00;
			Mem94[edi_117 - 0x30 + ebx_10:word128] = 0x00;
			Mem95[edi_117 - 0x20 + ebx_10:word128] = 0x00;
			Mem96[edi_117 - 0x10 + ebx_10:word128] = 0x00;
			return edi_117;
		}
		do
		{
			*edi_117 = 0x00;
			*((word32) edi_117 + 16) = 0x00;
			*((word32) edi_117 + 32) = 0x00;
			*((word32) edi_117 + 48) = 0x00;
			*((word32) edi_117 + 64) = 0x00;
			*((word32) edi_117 + 80) = 0x00;
			*((word32) edi_117 + 96) = 0x00;
			*((word32) edi_117 + 112) = 0x00;
			*((word32) edi_117 + 0x0080) = 0x00;
			*((word32) edi_117 + 144) = 0x00;
			*((word32) edi_117 + 0x00A0) = 0x00;
			*((word32) edi_117 + 0x00B0) = 0x00;
			*((word32) edi_117 + 0x00C0) = 0x00;
			*((word32) edi_117 + 0x00D0) = 0x00;
			*((word32) edi_117 + 224) = 0x00;
			*((word32) edi_117 + 0x00F0) = 0x00;
			ebx_10 -= (struct Eq_89051 *) 0x0100;
			edi_117 += 0x0100;
		} while (ebx_10 >= 0x0100);
	}
	return edi_117;
}

// 08090490: Register Eq_4 runtime.memmove(Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C, Register out ptr32 ebpOut, Register out Eq_4 esiOut, Register out Eq_4 ediOut, Register out Eq_3508 xmm0Out, Register out Eq_3509 xmm1Out, Register out Eq_3510 xmm2Out)
// Called from:
//      runtime.sendDirect
//      runtime.recvDirect
//      runtime.(*cpuProfile).addNonGo
//      runtime.typedmemmove
//      reflect.typedmemmovepartial
//      runtime.reflectcallmove
//      runtime.typedslicecopy
//      runtime.(*gcSweepBuf).push
//      runtime.handoff
//      runtime.stkbucket
//      runtime.getRandomData
//      runtime.deferproc
//      runtime.deferreturn
//      runtime.recordForPanic
//      runtime.gwrite
//      runtime.newproc1
//      runtime.sigprof
//      runtime.(*profBuf).write
//      runtime.growslice
//      runtime.syncadjustsudogs
//      runtime.copystack
//      runtime.concatstrings
//      runtime.slicebytetostring
//      runtime.stringtoslicebyte
//      runtime.gostring
//      runtime.name.pkgPath
//      strconv.(*decimal).String
//      strconv.genericFtoa
//      strconv.fmtE
//      strconv.fmtF
//      strconv.formatBits
//      strconv.appendQuotedWith
//      strconv.appendEscapedRune
//      syscall.ByteSliceFromString
//      reflect.name.pkgPath
//      reflect.newName
//      reflect.(*structType).FieldByNameFunc
//      reflect.funcStr
//      fmt.(*fmt).writePadding
//      fmt.(*fmt).pad
//      fmt.(*fmt).padString
//      fmt.(*fmt).fmt_float
//      fmt.(*pp).Write
//      fmt.(*pp).unknownType
//      fmt.(*pp).badVerb
//      fmt.(*pp).fmtComplex
//      fmt.(*pp).fmtBytes
//      fmt.(*pp).fmtPointer
//      fmt.(*pp).catchPanic
//      fmt.(*pp).printValue
Eq_4 runtime.memmove(Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C, ptr32 & ebpOut, union Eq_4 & esiOut, union Eq_4 & ediOut, union Eq_3508 & xmm0Out, union Eq_3509 & xmm1Out, union Eq_3510 & xmm2Out)
{
	Eq_4 edi_107 = dwArg04;
	Eq_4 esi_108 = dwArg08;
	Eq_4 ebx_131 = dwArg0C;
	while (ebx_131 != 0x00)
	{
		if (ebx_131 <= 0x02)
		{
			byte cl_17 = *((word32) ebx_131 + (esi_108 - 0x01));
			*edi_107 = *esi_108;
			Mem20[edi_107 - 0x01 + ebx_131:byte] = cl_17;
			ebpOut = ebp;
			esiOut = esi_108;
			ediOut = edi_107;
			xmm0Out = xmm0;
			xmm1Out = xmm1;
			xmm2Out = xmm2;
			return <invalid>;
		}
		if (ebx_131 < 0x04)
		{
			byte cl_24 = *((word32) esi_108 + 2);
			*edi_107 = *esi_108;
			*((word32) edi_107 + 2) = cl_24;
			ebpOut = ebp;
			esiOut = esi_108;
			ediOut = edi_107;
			xmm0Out = xmm0;
			xmm1Out = xmm1;
			xmm2Out = xmm2;
			return <invalid>;
		}
		if (ebx_131 == 0x04)
		{
			*edi_107 = *esi_108;
			ebpOut = ebp;
			esiOut = esi_108;
			ediOut = edi_107;
			xmm0Out = xmm0;
			xmm1Out = xmm1;
			xmm2Out = xmm2;
			return <invalid>;
		}
		if (ebx_131 <= 0x08)
		{
			word32 ecx_33 = Mem15[esi_108 - 0x04 + ebx_131:word32];
			*edi_107 = *esi_108;
			Mem35[edi_107 - 0x04 + ebx_131:word32] = ecx_33;
			ebpOut = ebp;
			esiOut = esi_108;
			ediOut = edi_107;
			xmm0Out = xmm0;
			xmm1Out = xmm1;
			xmm2Out = xmm2;
			return <invalid>;
		}
		if (ebx_131 <= 0x10)
		{
			word32 ecx_39 = *((word32) esi_108 + 4);
			word32 edx_40 = Mem15[esi_108 - 0x08 + ebx_131:word32];
			word32 ebp_41 = Mem15[esi_108 - 0x04 + ebx_131:word32];
			*edi_107 = *esi_108;
			*((word32) edi_107 + 4) = ecx_39;
			Mem44[edi_107 - 0x08 + ebx_131:word32] = edx_40;
			Mem45[edi_107 - 0x04 + ebx_131:word32] = ebp_41;
			ebpOut = ebp_41;
			esiOut = esi_108;
			ediOut = edi_107;
			xmm0Out = xmm0;
			xmm1Out = xmm1;
			xmm2Out = xmm2;
			return <invalid>;
		}
		if (g_b815757E == 0x01)
		{
			if (ebx_131 <= 0x20)
			{
				Eq_3508 xmm0_50 = *esi_108;
				word128 xmm1_51 = Mem15[esi_108 - 0x10 + ebx_131:word128];
				*edi_107 = xmm0_50;
				Mem53[edi_107 - 0x10 + ebx_131:word128] = xmm1_51;
				ebpOut = ebp;
				esiOut = esi_108;
				ediOut = edi_107;
				xmm0Out = xmm0_50;
				xmm1Out = xmm1_51;
				xmm2Out = xmm2;
				return <invalid>;
			}
			if (ebx_131 <= 0x40)
			{
				Eq_3508 xmm0_56 = *esi_108;
				Eq_3509 xmm1_57 = *((word32) esi_108 + 16);
				word128 xmm2_58 = Mem15[esi_108 - 0x20 + ebx_131:word128];
				word128 xmm3_59 = Mem15[esi_108 - 0x10 + ebx_131:word128];
				*edi_107 = xmm0_56;
				*((word32) edi_107 + 16) = xmm1_57;
				Mem62[edi_107 - 0x20 + ebx_131:word128] = xmm2_58;
				Mem63[edi_107 - 0x10 + ebx_131:word128] = xmm3_59;
				ebpOut = ebp;
				esiOut = esi_108;
				ediOut = edi_107;
				xmm0Out = xmm0_56;
				xmm1Out = xmm1_57;
				xmm2Out = xmm2_58;
				return <invalid>;
			}
			if (ebx_131 <= 0x80)
			{
				Eq_3508 xmm0_66 = *esi_108;
				Eq_3509 xmm1_67 = *((word32) esi_108 + 16);
				Eq_3510 xmm2_68 = *((word32) esi_108 + 32);
				word128 xmm3_69 = *((word32) esi_108 + 48);
				word128 xmm4_70 = Mem15[esi_108 - 0x40 + ebx_131:word128];
				word128 xmm5_71 = Mem15[esi_108 - 0x30 + ebx_131:word128];
				word128 xmm6_72 = Mem15[esi_108 - 0x20 + ebx_131:word128];
				word128 xmm7_73 = Mem15[esi_108 - 0x10 + ebx_131:word128];
				*edi_107 = xmm0_66;
				*((word32) edi_107 + 16) = xmm1_67;
				*((word32) edi_107 + 32) = xmm2_68;
				*((word32) edi_107 + 48) = xmm3_69;
				Mem78[edi_107 - 0x40 + ebx_131:word128] = xmm4_70;
				Mem79[edi_107 - 0x30 + ebx_131:word128] = xmm5_71;
				Mem80[edi_107 - 0x20 + ebx_131:word128] = xmm6_72;
				Mem81[edi_107 - 0x10 + ebx_131:word128] = xmm7_73;
				ebpOut = ebp;
				esiOut = esi_108;
				ediOut = edi_107;
				xmm0Out = xmm0_66;
				xmm1Out = xmm1_67;
				xmm2Out = xmm2_68;
				return <invalid>;
			}
		}
		if (esi_108 <= edi_107 && esi_108 + ebx_131 >u edi_107)
		{
			uint32 ecx_100;
			ebx_131 &= 0x03;
			word32 edi_102 = edi_107 + ebx_131 - 0x04;
			word32 esi_104 = esi_108 + ebx_131 - 0x04;
			for (ecx_100 = ebx_131 >> 0x02; ecx_100 != 0x00; --ecx_100)
			{
				*edi_102 = *esi_104;
				esi_104 -= 4;
				edi_102 -= 4;
			}
			edi_107 = edi_102 + 0x04 - ebx_131;
			esi_108 = esi_104 + 0x04 - ebx_131;
			continue;
		}
		if (g_b815757B == 0x01 && ((esi_108 | edi_107) & 0x03) != 0x00)
		{
			Eq_4 ecx_143;
			for (ecx_143 = ebx_131; ecx_143 != 0x00; --ecx_143)
			{
				*edi_107 = *esi_108;
				++esi_108;
				++edi_107;
			}
			ebpOut = ebp;
			esiOut = esi_108;
			ediOut = edi_107;
			xmm0Out = xmm0;
			xmm1Out = xmm1;
			xmm2Out = xmm2;
			return <invalid>;
		}
		uint32 ecx_130;
		ebx_131 &= 0x03;
		for (ecx_130 = ebx_131 >> 0x02; ecx_130 != 0x00; --ecx_130)
		{
			*edi_107 = *esi_108;
			esi_108 += 4;
			edi_107 += 4;
		}
	}
	ebpOut = ebp;
	esiOut = esi_108;
	ediOut = edi_107;
	xmm0Out = xmm0;
	xmm1Out = xmm1;
	xmm2Out = xmm2;
	return <invalid>;
}

// 08090630: void _rt0_386_linux(Register word32 ecx, Register word32 edx, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg00)
void _rt0_386_linux(word32 ecx, word32 edx, struct Eq_2 * gs, Eq_4 dwArg00)
{
	word32 edx_19;
	word32 ecx_17 = main(ecx, edx, gs, dwArg00, fp + 0x04, out edx_19);
	__syscall(0x03);
	__syscall(0x03);
	__syscall(0x03);
	__syscall(0x03);
	__syscall(0x03);
	__syscall(0x03);
	__syscall(0x03);
	__syscall(0x03);
	word32 edx_63;
	main(ecx_17, edx_19, gs, fp + 0x04, dwArg00, out edx_63);
}

// 08090650: Register word32 main(Register word32 ecx, Register word32 edx, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Register out ptr32 edxOut)
// Called from:
//      _rt0_386_linux
word32 main(word32 ecx, word32 edx, struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, ptr32 & edxOut)
{
	ptr32 edx_13;
	word32 ecx_11 = runtime.rt0_go(ecx, edx, gs, dwArg04, dwArg08, out edx_13);
	edxOut = edx_13;
	return ecx_11;
}

// 08090660: Register word32 runtime.exit()
// Called from:
//      runtime.cgocallbackg
//      runtime.sysAlloc
//      runtime.mSysStatInc
//      runtime.mSysStatDec
//      runtime.startpanic_m
//      runtime.dopanic_m
//      runtime.main
//      runtime.needm
//      runtime.sighandler
//      runtime.dieFromSignal
//      main
word32 runtime.exit()
{
	__syscall(0x80);
	__syscall(0x03);
	return dwArg04;
}

// 08090670: void runtime.exit1()
// Called from:
//      runtime.clone
void runtime.exit1()
{
	__syscall(0x80);
	__syscall(0x03);
}

// 08090680: void runtime.open()
// Called from:
//      runtime.sysargs
//      runtime.getRandomData
void runtime.open()
{
	__syscall(0x80);
}

// 080906B0: void runtime.closefd()
// Called from:
//      runtime.sysargs
//      runtime.getRandomData
void runtime.closefd()
{
	__syscall(0x80);
}

// 080906D0: Register word32 runtime.write(Register out ptr32 edxOut, Register out ptr32 ebxOut)
// Called from:
//      runtime.badmorestackg0
//      runtime.badmorestackgsignal
//      runtime.needm
//      runtime.writeErr
//      main
word32 runtime.write(ptr32 & edxOut, ptr32 & ebxOut)
{
	__syscall(0x80);
}

// 08090700: void runtime.read()
// Called from:
//      runtime.sysargs
//      runtime.getRandomData
void runtime.read()
{
	__syscall(0x80);
}

// 08090730: Register word32 runtime.usleep(Register out ptr32 ediOut)
// Called from:
//      runtime.getfull
//      runtime.freezetheworld
//      runtime.lockextra
//      runtime.sysmon
//      runtime.runqgrab
//      runtime.sighandler
//      runtime.raisebadsignal
word32 runtime.usleep(ptr32 & ediOut)
{
	__syscall(0x80);
	ediOut = fp - 0x08;
	return 0x00;
}

// 08090770: void runtime.gettid()
// Called from:
//      runtime.minit
void runtime.gettid()
{
	__syscall(0x80);
}

// 08090780: void runtime.raise()
// Called from:
//      runtime.dieFromSignal
//      runtime.raisebadsignal
void runtime.raise()
{
	__syscall(0x80);
	__syscall(0x80);
}

// 080907A0: void runtime.raiseproc()
// Called from:
//      runtime.sighandler
void runtime.raiseproc()
{
	__syscall(0x80);
	__syscall(0x80);
}

// 080907C0: void runtime.setitimer()
// Called from:
//      runtime.setThreadCPUProfiler
void runtime.setitimer()
{
	__syscall(0x80);
}

// 080907E0: void runtime.mincore()
// Called from:
//      runtime.addrspace_free
//      runtime.sysargs
void runtime.mincore()
{
	__syscall(0x80);
}

// 08090800: void runtime.walltime()
// Called from:
//      time.now
void runtime.walltime()
{
	__syscall(0x80);
}

// 08090830: Register word32 runtime.nanotime()
// Called from:
//      runtime.(*cpuProfile).add
//      runtime.notetsleep_internal
//      runtime.(*gcControllerState).endCycle
//      runtime.(*gcControllerState).findRunnableGCWorker
//      runtime.gcStart
//      runtime.gcMarkDone
//      runtime.gcMarkTermination
//      runtime.gcBgMarkWorker
//      runtime.gcAssistAlloc1
//      runtime.(*mheap).freeSpanLocked
//      runtime.main
//      runtime.forcegchelper
//      runtime.schedinit
//      runtime.casgstatus
//      runtime.scang
//      runtime.findrunnable
//      runtime.procresize
//      runtime.sysmon
//      runtime.schedtrace
//      runtime.extendRandom
//      sync.runtime_nanotime
//      runtime.timerproc
//      time.now
//      runtime.goroutineheader
//      runtime.gcMarkTermination.func2
//      runtime.init
word32 runtime.nanotime()
{
	__syscall(0x80);
	return dwLoc14;
}

// 08090870: Register word32 runtime.rtsigprocmask()
// Called from:
//      runtime.sigprocmask
word32 runtime.rtsigprocmask()
{
	__syscall(0x80);
	__syscall(0x03);
}

// 080908A0: void runtime.rt_sigaction()
// Called from:
//      runtime.setsig
//      runtime.setsigstack
//      runtime.getsig
void runtime.rt_sigaction()
{
	__syscall(0x80);
}

// 080908C0: void runtime.sigfwd(Stack (ptr32 code) dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C, Stack Eq_4 dwArg10)
// Called from:
//      runtime.sigfwdgo
void runtime.sigfwd(<anonymous> * dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C, Eq_4 dwArg10)
{
	__align(fp - 44);
	dwArg04();
}

// 08090900: void runtime.sigtramp(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack (ptr32 Eq_62608) dwArg0C)
// Called from:
//      runtime.cgoSigtramp
void runtime.sigtramp(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, struct Eq_62608 * dwArg0C)
{
	runtime.sigtrampgo(gs, dwLoc20, dwArg04, dwArg08, dwArg0C);
}

// 08090950: void runtime.cgoSigtramp(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack (ptr32 Eq_62608) dwArg0C)
void runtime.cgoSigtramp(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, struct Eq_62608 * dwArg0C)
{
	runtime.sigtramp(gs, dwArg04, dwArg08, dwArg0C);
}

// 08090960: void runtime.sigreturn()
void runtime.sigreturn()
{
	__syscall(0x80);
	__syscall(0x03);
}

// 08090970: Register word32 runtime.mmap()
// Called from:
//      runtime.mmap_fixed
//      runtime.sysAlloc
//      runtime.sysFault
//      runtime.sysReserve
//      runtime.sysMap
//      runtime.sysargs
word32 runtime.mmap()
{
	__syscall(0x80);
}

// 080909B0: void runtime.munmap()
// Called from:
//      runtime.mmap_fixed
//      runtime.sysFree
//      runtime.sysargs
void runtime.munmap()
{
	__syscall(0x80);
	__syscall(0x03);
}

// 080909D0: void runtime.madvise()
// Called from:
//      runtime.sysUnused
//      runtime.sysUsed
void runtime.madvise()
{
	__syscall(0x80);
}

// 080909F0: Register word32 runtime.futex(Register out ptr32 esiOut, Register out ptr32 ediOut)
// Called from:
//      runtime.futexsleep
//      runtime.futexwakeup
word32 runtime.futex(ptr32 & esiOut, ptr32 & ediOut)
{
	__syscall(0x80);
	esiOut = dwArg10;
	ediOut = dwArg14;
	return dwArg18;
}

// 08090A20: void runtime.clone(Stack Eq_4 dwArg00, Stack word32 dwArg04, Stack (ptr32 Eq_40843) dwArg08, Stack (ptr32 Eq_40822) dwArg0C, Stack word32 dwArg10, Stack Eq_4 dwArg14)
// Called from:
//      runtime.newosproc
void runtime.clone(Eq_4 dwArg00, word32 dwArg04, struct Eq_40843 * dwArg08, struct Eq_40822 * dwArg0C, word32 dwArg10, Eq_4 dwArg14)
{
	dwArg08->ptrFFFFFFF0 = dwArg0C;
	dwArg08->dwFFFFFFF4 = dwArg10;
	dwArg08->tFFFFFFF8 = dwArg14;
	dwArg08->dwFFFFFFFC = 0x04D2;
	__syscall(0x80);
}

// 08090AD0: void runtime.sigaltstack()
// Called from:
//      runtime.sigtrampgo
//      runtime.minitSignalStack
//      runtime.unminitSignals
//      runtime.signalstack
//      runtime.clone
void runtime.sigaltstack()
{
	__syscall(0x80);
	__syscall(0x03);
}

// 08090AF0: Register (ptr16 Eq_89568) runtime.setldt(Stack (ptr32 Eq_86315) dwArg08)
// Called from:
//      runtime.ldt0setup
//      runtime.clone
struct Eq_89568 * runtime.setldt(struct Eq_86315 * dwArg08)
{
	dwArg08->dw0004 = &dwArg08->dw0004;
	__syscall(0x80);
	__syscall(0x03);
}

// 08090B50: void runtime.osyield()
// Called from:
//      runtime.(*cpuProfile).add
//      runtime.(*cpuProfile).addNonGo
//      runtime.lock
//      runtime.(*mspan).ensureSwept
//      runtime.getfull
//      runtime.casgstatus
//      runtime.scang
//      runtime.lockextra
//      runtime.exitsyscall
//      runtime.dieFromSignal
//      runtime.exitsyscallfast.func1
void runtime.osyield()
{
	__syscall(0x80);
}

// 08090B60: void runtime.sched_getaffinity()
// Called from:
//      runtime.getproccount
void runtime.sched_getaffinity()
{
	__syscall(0x80);
}

// 08090B80: Register word32 runtime.epollcreate()
// Called from:
//      runtime.netpollinit
word32 runtime.epollcreate()
{
	__syscall(0x80);
	return dwArg04;
}

// 08090B90: void runtime.epollcreate1()
// Called from:
//      runtime.netpollinit
void runtime.epollcreate1()
{
	__syscall(0x80);
}

// 08090BA0: Register word32 runtime.epollctl(Register out ptr32 esiOut)
// Called from:
//      runtime.netpollopen
//      runtime.netpollclose
word32 runtime.epollctl(ptr32 & esiOut)
{
	__syscall(0x80);
	esiOut = dwArg10;
	return dwArg04;
}

// 08090BC0: Register word32 runtime.epollwait()
// Called from:
//      runtime.netpoll
word32 runtime.epollwait()
{
	__syscall(0x80);
	return dwArg10;
}

// 08090BE0: void runtime.closeonexec()
// Called from:
//      runtime.netpollinit
void runtime.closeonexec()
{
	__syscall(0x80);
}

// 08090C00: void runtime.sbrk0()
// Called from:
//      runtime.mallocinit
void runtime.sbrk0()
{
	__syscall(0x80);
}

// 08090C10: Register word32 runtime._mul64by32(Stack (ptr32 Eq_79393) dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C, Stack uint32 dwArg10)
// Called from:
//      runtime.dodiv
word32 runtime._mul64by32(struct Eq_79393 * dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C, uint32 dwArg10)
{
	uint64 edx_eax_7 = dwArg10 *64 dwArg08;
	dwArg04->dw0000 = (word32) edx_eax_7;
	word32 ebx_15 = SLICE(edx_eax_7, word32, 32) + dwArg10 * dwArg0C;
	dwArg04->dw0004 = ebx_15;
	return ebx_15;
}

// 08090C40: Register uint32 runtime._div64by32(Stack ui64 qwArg04, Stack Eq_4 dwArg0C, Stack (ptr32 uint32) dwArg10)
// Called from:
//      runtime.dodiv
uint32 runtime._div64by32(ui64 qwArg04, Eq_4 dwArg0C, uint32 * dwArg10)
{
	uint32 edx_10 = (uint32) (qwArg04 % dwArg0C);
	*dwArg10 = edx_10;
	return edx_10;
}

// 08090C60: void type..hash.runtime._func(Register (ptr32 Eq_2) gs, Register Eq_4 mm0, Stack (ptr32 Eq_205) dwArg04, Stack (ptr32 Eq_205) dwArg08)
void type..hash.runtime._func(struct Eq_2 * gs, Eq_4 mm0, union Eq_205 * dwArg04, union Eq_205 * dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	word128 xmm1_94;
	word128 xmm1_95;
	runtime.memhash(gs, runtime.memhash(gs, mm0, dwArg04, dwArg08, 0x0C, out xmm1_94), (char *) dwArg04 + 16, dwLoc04, 0x14, out xmm1_95);
}

// 08090CD0: void type..eq.runtime._func(Register Eq_4 edx, Register (ptr32 Eq_89661) gs, Stack byte bArg00, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack word32 dwArg0C)
void type..eq.runtime._func(Eq_4 edx, struct Eq_89661 * gs, byte bArg00, Eq_4 dwArg04, Eq_4 dwArg08, word32 dwArg0C)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		edx = runtime.morestack_noctxt();
	word32 ebx_106;
	word32 esi_107;
	word32 edi_108;
	Eq_4 edx_30 = runtime.memequal(edx, dwArg04, dwArg08, 0x0C, out ebx_106, out esi_107, out edi_108);
	if (bArg00 != 0x00)
	{
		word32 ebx_109;
		word32 esi_110;
		word32 edi_111;
		runtime.memequal(edx_30, (word32) dwArg08 + 16, dwArg0C + 0x10, 0x14, out ebx_109, out esi_110, out edi_111);
	}
}

// 08090D50: void type..hash.runtime.uncommontype(Register (ptr32 Eq_2) gs, Register Eq_4 mm0, Stack (ptr32 Eq_205) dwArg04, Stack (ptr32 Eq_205) dwArg08)
void type..hash.runtime.uncommontype(struct Eq_2 * gs, Eq_4 mm0, union Eq_205 * dwArg04, union Eq_205 * dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	word128 xmm1_94;
	word128 xmm1_95;
	runtime.memhash(gs, runtime.memhash(gs, mm0, dwArg04, dwArg08, 0x06, out xmm1_94), (char *) dwArg04 + 8, dwLoc04, 0x04, out xmm1_95);
}

// 08090DC0: void type..eq.runtime.uncommontype(Register (ptr32 Eq_89732) gs, Stack (ptr32 Eq_89733) dwArg04, Stack (ptr32 Eq_89734) dwArg08)
void type..eq.runtime.uncommontype(struct Eq_89732 * gs, struct Eq_89733 * dwArg04, struct Eq_89734 * dwArg08)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	if (dwArg04->dw0000 == dwArg08->dw0000)
		dwArg04->w0004 != dwArg08->w0004;
}

// 08090E10: void type..hash.runtime.modulehash(Register (ptr32 Eq_2) gs, Register Eq_4 mm0, Stack (ptr32 Eq_636) dwArg04, Stack (ptr32 Eq_205) dwArg08)
void type..hash.runtime.modulehash(struct Eq_2 * gs, Eq_4 mm0, struct Eq_636 * dwArg04, union Eq_205 * dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	word128 xmm1_120;
	runtime.memhash(gs, runtime.strhash(gs, runtime.strhash(gs, mm0, dwArg04, dwArg08), (char *) &dwArg04->t0004 + 4, dwLoc08), (char *) &dwArg04->t0004 + 0x0C, dwLoc08, 0x04, out xmm1_120);
}

// 08090E90: void type..eq.runtime.modulehash(Register (ptr32 Eq_89792) gs, Stack (ptr32 Eq_89793) dwArg04, Stack (ptr32 Eq_89794) dwArg08)
void type..eq.runtime.modulehash(struct Eq_89792 * gs, struct Eq_89793 * dwArg04, struct Eq_89794 * dwArg08)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	byte cl_45;
	Eq_4 ecx_18 = dwArg04->t0004;
	Eq_4 edx_19 = dwArg04->t0000;
	Eq_4 esi_22 = dwArg08->t0000;
	if (dwArg08->t0004 != ecx_18)
		cl_45 = 0x00;
	else
	{
		word32 edi_170;
		word32 ebx_168;
		word32 esi_169;
		runtime.eqstring(edx_19, edx_19, ecx_18, esi_22, out ebx_168, out esi_169, out edi_170);
		cl_45 = bLoc04;
	}
	uip32 ecx_165;
	if (cl_45 != 0x00)
	{
		Eq_4 ecx_56 = dwArg04->t000C;
		Eq_4 edx_57 = dwArg04->t0008;
		Eq_4 esi_60 = dwArg08->t0008;
		if (dwArg08->t000C != ecx_56)
			ecx_165 = 0x00;
		else
		{
			word32 ebx_171;
			word32 esi_172;
			word32 edi_173;
			runtime.eqstring(edx_57, edx_57, ecx_56, esi_60, out ebx_171, out esi_172, out edi_173);
			ecx_165 = (word32) bLoc04;
		}
	}
	else
		ecx_165 = 0x00;
}

// 08090F50: void type..hash.runtime.Frame(Register (ptr32 Eq_2) gs, Register Eq_4 mm0, Stack (ptr32 Eq_205) dwArg04, Stack (ptr32 Eq_205) dwArg08)
void type..hash.runtime.Frame(struct Eq_2 * gs, Eq_4 mm0, union Eq_205 * dwArg04, union Eq_205 * dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	word128 xmm1_146;
	word128 xmm1_147;
	runtime.memhash(gs, runtime.strhash(gs, runtime.strhash(gs, runtime.memhash(gs, mm0, dwArg04, dwArg08, 0x08, out xmm1_146), (char *) dwArg04 + 8, dwLoc04), (char *) dwArg04 + 16, (union Eq_205 *) 0x08), (char *) dwArg04 + 24, (union Eq_205 *) 0x08, 0x08, out xmm1_147);
}

// 08090FF0: void type..eq.runtime.Frame(Register (ptr32 Eq_89906) gs, Stack (ptr32 Eq_89907) dwArg04, Stack Eq_4 dwArg08)
void type..eq.runtime.Frame(struct Eq_89906 * gs, struct Eq_89907 * dwArg04, Eq_4 dwArg08)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	byte cl_59;
	if (dwArg04->dw0000 == *dwArg08)
	{
		if (dwArg04->dw0004 == *((word32) dwArg08 + 4))
		{
			Eq_4 ecx_33 = dwArg04->t000C;
			Eq_4 ebx_34 = dwArg04->t0008;
			Eq_4 esi_36 = *((word32) dwArg08 + 8);
			if (*((word32) dwArg08 + 0x0C) != ecx_33)
				cl_59 = 0x00;
			else
			{
				word32 edi_200;
				word32 ebx_198;
				word32 esi_199;
				runtime.eqstring(dwArg08, ebx_34, ecx_33, esi_36, out ebx_198, out esi_199, out edi_200);
				cl_59 = bLoc04;
			}
		}
		else
			cl_59 = 0x00;
	}
	else
		cl_59 = 0x00;
	uip32 ecx_195;
	if (cl_59 != 0x00)
	{
		Eq_4 ebx_73 = *((word32) dwArg08 + 16);
		Eq_4 ebp_75 = dwArg04->t0010;
		Eq_4 esi_76 = dwArg04->t0014;
		if (esi_76 != *((word32) dwArg08 + 20))
			ecx_195 = 0x00;
		else
		{
			word32 ebx_201;
			word32 esi_202;
			word32 edi_203;
			runtime.eqstring(dwArg08, ebp_75, esi_76, ebx_73, out ebx_201, out esi_202, out edi_203);
			ecx_195 = (word32) bLoc04;
		}
	}
	else
		ecx_195 = 0x00;
	if ((byte) ecx_195 != 0x00)
		dwArg04->t0018 != *((word32) dwArg08 + 24);
}

// 080910F0: void type..hash.runtime.MemStats(Register (ptr32 Eq_2) gs, Register Eq_4 mm0, Stack (ptr32 Eq_205) dwArg04, Stack (ptr32 Eq_205) dwArg08)
void type..hash.runtime.MemStats(struct Eq_2 * gs, Eq_4 mm0, union Eq_205 * dwArg04, union Eq_205 * dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_662 xmm1_31;
	word128 xmm1_149;
	word128 xmm1_150;
	word128 xmm1_151;
	runtime.memhash(gs, runtime.memhash(gs, runtime.f64hash(gs, runtime.memhash(gs, mm0, dwArg04, dwArg08, 0x10C8, out xmm1_31), xmm1_31, (char *) dwArg04 + 4296, dwLoc04, out xmm1_149), (char *) dwArg04 + 4304, (union Eq_205 *) 0x10C8, 0x02, out xmm1_150), (char *) dwArg04 + 4308, dwLoc04, 0x04C4, out xmm1_151);
}

// 080911A0: void type..eq.runtime.MemStats(Register Eq_4 edx, Register (ptr32 Eq_90048) gs, Stack byte bArg00, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack (ptr32 Eq_90052) dwArg0C)
void type..eq.runtime.MemStats(Eq_4 edx, struct Eq_90048 * gs, byte bArg00, Eq_4 dwArg04, Eq_4 dwArg08, struct Eq_90052 * dwArg0C)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		edx = runtime.morestack_noctxt();
	word32 edi_164;
	word32 esi_163;
	word32 ebx_162;
	runtime.memequal(edx, dwArg04, dwArg08, 0x10C8, out ebx_162, out esi_163, out edi_164);
	if (bArg00 != 0x00)
	{
		uint128 xmm0_45 = (uint128) *((word32) dwArg08 + 4296);
		uint128 xmm1_47 = (uint128) dwArg0C->r10C8;
		if ((real64) xmm0_45 == (real64) xmm1_47 && !PARITY_EVEN((real64) xmm0_45 - (real64) xmm1_47))
		{
			if (*((word32) dwArg08 + 4304) == dwArg0C->b10D0)
			{
				Eq_4 edx_65 = (word32) *((word32) dwArg08 + 0x000010D1);
				if ((byte) edx_65 == dwArg0C->b10D1)
				{
					word32 edi_167;
					word32 esi_166;
					word32 ebx_165;
					runtime.memequal(edx_65, (word32) dwArg08 + 4308, &dwArg0C->b10D1 + 3, 0x04C4, out ebx_165, out esi_166, out edi_167);
				}
			}
		}
	}
}

// 08091270: void type..hash.runtime.TypeAssertionError(Register (ptr32 Eq_2) gs, Register Eq_4 mm0, Stack (ptr32 Eq_636) dwArg04, Stack (ptr32 Eq_205) dwArg08)
void type..hash.runtime.TypeAssertionError(struct Eq_2 * gs, Eq_4 mm0, struct Eq_636 * dwArg04, union Eq_205 * dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.strhash(gs, runtime.strhash(gs, runtime.strhash(gs, runtime.strhash(gs, mm0, dwArg04, dwArg08), (char *) &dwArg04->t0004 + 4, dwLoc04), (char *) &dwArg04->t0004 + 0x0C, dwLoc04), (char *) &dwArg04->t0004 + 20, dwLoc04);
}

// 08091300: void type..eq.runtime.TypeAssertionError(Register (ptr32 Eq_90157) gs, Stack (ptr32 Eq_90158) dwArg04, Stack (ptr32 Eq_90159) dwArg08)
void type..eq.runtime.TypeAssertionError(struct Eq_90157 * gs, struct Eq_90158 * dwArg04, struct Eq_90159 * dwArg08)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	byte cl_45;
	Eq_4 edx_19 = dwArg08->t0000;
	Eq_4 ebp_21 = dwArg04->t0004;
	Eq_4 esi_22 = dwArg04->t0000;
	if (dwArg08->t0004 != ebp_21)
		cl_45 = 0x00;
	else
	{
		word32 esi_248;
		word32 ebx_247;
		word32 edi_249;
		runtime.eqstring(edx_19, esi_22, ebp_21, edx_19, out ebx_247, out esi_248, out edi_249);
		cl_45 = bLoc04;
	}
	byte cl_84;
	if (cl_45 != 0x00)
	{
		Eq_4 edx_57 = dwArg08->t0008;
		Eq_4 ebp_59 = dwArg04->t000C;
		Eq_4 esi_60 = dwArg04->t0008;
		if (dwArg08->t000C != ebp_59)
			cl_84 = 0x00;
		else
		{
			word32 ebx_250;
			word32 esi_251;
			word32 edi_252;
			runtime.eqstring(edx_57, esi_60, ebp_59, edx_57, out ebx_250, out esi_251, out edi_252);
			cl_84 = bLoc04;
		}
	}
	else
		cl_84 = 0x00;
	uip32 ecx_118;
	if (cl_84 != 0x00)
	{
		Eq_4 edx_97 = dwArg08->t0010;
		Eq_4 ebp_99 = dwArg04->t0014;
		Eq_4 esi_100 = dwArg04->t0010;
		if (ebp_99 != dwArg08->t0014)
			ecx_118 = 0x00;
		else
		{
			word32 ebx_253;
			word32 esi_254;
			word32 edi_255;
			runtime.eqstring(edx_97, esi_100, ebp_99, edx_97, out ebx_253, out esi_254, out edi_255);
			ecx_118 = (word32) bLoc04;
		}
	}
	else
		ecx_118 = 0x00;
	if ((byte) ecx_118 != 0x00)
	{
		Eq_4 ecx_136 = dwArg08->t0018;
		Eq_4 edx_138 = dwArg04->t001C;
		Eq_4 ebx_139 = dwArg04->t0018;
		if (dwArg08->t001C == edx_138)
		{
			word32 ebx_256;
			word32 esi_257;
			word32 edi_258;
			runtime.eqstring(edx_138, ebx_139, edx_138, ecx_136, out ebx_256, out esi_257, out edi_258);
		}
	}
}

// 08091430: void type..hash.runtime._panic(Register (ptr32 Eq_2) gs, Register Eq_4 mm0, Stack (ptr32 Eq_205) dwArg04, Stack (ptr32 Eq_205) dwArg08)
void type..hash.runtime._panic(struct Eq_2 * gs, Eq_4 mm0, union Eq_205 * dwArg04, union Eq_205 * dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	word128 xmm1_109;
	Eq_4 mm0_29 = runtime.memhash(gs, mm0, dwArg04, dwArg08, 0x04, out xmm1_109);
	runtime.nilinterhash(gs, (char *) dwArg04 + 4, dwLoc04);
	word128 xmm1_110;
	runtime.memhash(gs, mm0_29, (char *) dwArg04 + 0x0C, (union Eq_205 *) 0x04, 0x06, out xmm1_110);
}

// 080914B0: void type..eq.runtime._panic(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_90321) dwArg04, Stack Eq_4 dwArg08)
void type..eq.runtime._panic(struct Eq_2 * gs, struct Eq_90321 * dwArg04, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	uip32 ecx_138;
	if (dwArg04->dw0000 == *dwArg08)
	{
		Eq_4 ecx_26 = *((word32) dwArg08 + 8);
		word32 ebp_28 = dwArg04->dw0008;
		Eq_4 esi_29 = dwArg04->t0004;
		if (esi_29 != *((word32) dwArg08 + 4))
			ecx_138 = 0x00;
		else
		{
			runtime.efaceeq(gs, esi_29, ebp_28, ecx_26);
			ecx_138 = (word32) bLoc04;
		}
	}
	else
		ecx_138 = 0x00;
	if ((byte) ecx_138 != 0x00)
	{
		word32 ebx_141;
		word32 esi_142;
		word32 edi_143;
		runtime.memequal(dwArg08, &dwArg04->dw0008 + 1, (word32) dwArg08 + 0x0C, 0x06, out ebx_141, out esi_142, out edi_143);
	}
}

// 08091550: void type..hash.runtime._defer(Register (ptr32 Eq_2) gs, Register Eq_4 mm0, Stack (ptr32 Eq_205) dwArg04, Stack (ptr32 Eq_205) dwArg08)
void type..hash.runtime._defer(struct Eq_2 * gs, Eq_4 mm0, union Eq_205 * dwArg04, union Eq_205 * dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	word128 xmm1_94;
	word128 xmm1_95;
	runtime.memhash(gs, runtime.memhash(gs, mm0, dwArg04, dwArg08, 0x05, out xmm1_94), (char *) dwArg04 + 8, dwLoc04, 0x14, out xmm1_95);
}

// 080915C0: void type..eq.runtime._defer(Register (ptr32 Eq_90410) gs, Stack (ptr32 Eq_90411) dwArg04, Stack Eq_4 dwArg08)
void type..eq.runtime._defer(struct Eq_90410 * gs, struct Eq_90411 * dwArg04, Eq_4 dwArg08)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	if (dwArg04->dw0000 == *dwArg08 && dwArg04->b0004 == *((word32) dwArg08 + 4))
	{
		word32 ebx_96;
		word32 esi_97;
		word32 edi_98;
		runtime.memequal(dwArg08, &dwArg04->b0004 + 4, (word32) dwArg08 + 8, 0x14, out ebx_96, out esi_97, out edi_98);
	}
}

// 08091630: void type..hash.runtime.special(Register (ptr32 Eq_2) gs, Register Eq_4 mm0, Stack (ptr32 Eq_205) dwArg04, Stack (ptr32 Eq_205) dwArg08)
void type..hash.runtime.special(struct Eq_2 * gs, Eq_4 mm0, union Eq_205 * dwArg04, union Eq_205 * dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	word128 xmm1_65;
	runtime.memhash(gs, mm0, dwArg04, dwArg08, 0x07, out xmm1_65);
}

// 08091680: void type..eq.runtime.special(Register Eq_4 edx, Register (ptr32 Eq_90474) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
void type..eq.runtime.special(Eq_4 edx, struct Eq_90474 * gs, Eq_4 dwArg04, Eq_4 dwArg08)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		edx = runtime.morestack_noctxt();
	word32 ebx_58;
	word32 esi_59;
	word32 edi_60;
	runtime.memequal(edx, dwArg04, dwArg08, 0x07, out ebx_58, out esi_59, out edi_60);
}

// 080916D0: void type..hash.runtime.markBits(Register (ptr32 Eq_2) gs, Register Eq_4 mm0, Stack (ptr32 Eq_205) dwArg04, Stack (ptr32 Eq_205) dwArg08)
void type..hash.runtime.markBits(struct Eq_2 * gs, Eq_4 mm0, union Eq_205 * dwArg04, union Eq_205 * dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	word128 xmm1_94;
	word128 xmm1_95;
	runtime.memhash(gs, runtime.memhash(gs, mm0, dwArg04, dwArg08, 0x05, out xmm1_94), (char *) dwArg04 + 8, dwLoc04, 0x04, out xmm1_95);
}

// 08091740: void type..eq.runtime.markBits(Register (ptr32 Eq_90527) gs, Stack (ptr32 Eq_90528) dwArg04, Stack (ptr32 Eq_90529) dwArg08)
void type..eq.runtime.markBits(struct Eq_90527 * gs, struct Eq_90528 * dwArg04, struct Eq_90529 * dwArg08)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	if (dwArg04->dw0000 == dwArg08->dw0000)
		dwArg04->b0004 != dwArg08->b0004;
}

// 08091790: void type..hash.runtime.hchan(Register (ptr32 Eq_2) gs, Register Eq_4 mm0, Stack (ptr32 Eq_205) dwArg04, Stack (ptr32 Eq_205) dwArg08)
void type..hash.runtime.hchan(struct Eq_2 * gs, Eq_4 mm0, union Eq_205 * dwArg04, union Eq_205 * dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	word128 xmm1_94;
	word128 xmm1_95;
	runtime.memhash(gs, runtime.memhash(gs, mm0, dwArg04, dwArg08, 0x0E, out xmm1_94), (char *) dwArg04 + 16, dwLoc04, 0x24, out xmm1_95);
}

// 08091800: void type..eq.runtime.hchan(Register Eq_4 edx, Register (ptr32 Eq_90586) gs, Stack byte bArg00, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack word32 dwArg0C)
void type..eq.runtime.hchan(Eq_4 edx, struct Eq_90586 * gs, byte bArg00, Eq_4 dwArg04, Eq_4 dwArg08, word32 dwArg0C)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		edx = runtime.morestack_noctxt();
	word32 ebx_106;
	word32 esi_107;
	word32 edi_108;
	Eq_4 edx_30 = runtime.memequal(edx, dwArg04, dwArg08, 0x0E, out ebx_106, out esi_107, out edi_108);
	if (bArg00 != 0x00)
	{
		word32 ebx_109;
		word32 esi_110;
		word32 edi_111;
		runtime.memequal(edx_30, (word32) dwArg08 + 16, dwArg0C + 0x10, 0x24, out ebx_109, out esi_110, out edi_111);
	}
}

// 08091880: void type..hash.runtime.cpuProfile(Register (ptr32 Eq_2) gs, Register Eq_4 mm0, Stack (ptr32 Eq_205) dwArg04, Stack (ptr32 Eq_205) dwArg08)
void type..hash.runtime.cpuProfile(struct Eq_2 * gs, Eq_4 mm0, union Eq_205 * dwArg04, union Eq_205 * dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	word128 xmm1_94;
	word128 xmm1_95;
	runtime.memhash(gs, runtime.memhash(gs, mm0, dwArg04, dwArg08, 0x05, out xmm1_94), (char *) dwArg04 + 8, dwLoc04, 0x0FB0, out xmm1_95);
}

// 080918F0: void type..eq.runtime.cpuProfile(Register (ptr32 Eq_90657) gs, Stack Eq_4 dwArg04, Stack (ptr32 Eq_90659) dwArg08)
void type..eq.runtime.cpuProfile(struct Eq_90657 * gs, Eq_4 dwArg04, struct Eq_90659 * dwArg08)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	if (*dwArg04 == dwArg08->dw0000 && *((word32) dwArg04 + 4) == dwArg08->b0004)
	{
		word32 ebx_96;
		word32 esi_97;
		word32 edi_98;
		runtime.memequal(dwArg04, (word32) dwArg04 + 8, &dwArg08->b0004 + 4, 0x0FB0, out ebx_96, out esi_97, out edi_98);
	}
}

// 08091960: Register Eq_4 type..hash.runtime.dbgVar(Register (ptr32 Eq_2) gs, Register Eq_4 mm0, Stack (ptr32 Eq_636) dwArg04, Stack (ptr32 Eq_205) dwArg08)
// Called from:
//      type..hash.[14]runtime.dbgVar
Eq_4 type..hash.runtime.dbgVar(struct Eq_2 * gs, Eq_4 mm0, struct Eq_636 * dwArg04, union Eq_205 * dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	word128 xmm1_94;
	return runtime.memhash(gs, runtime.strhash(gs, mm0, dwArg04, dwArg08), (char *) &dwArg04->t0004 + 4, dwLoc08, 0x04, out xmm1_94);
}

// 080919C0: void type..eq.runtime.dbgVar(Register (ptr32 Eq_90725) gs, Stack (ptr32 Eq_90726) dwArg04, Stack (ptr32 Eq_90727) dwArg08)
void type..eq.runtime.dbgVar(struct Eq_90725 * gs, struct Eq_90726 * dwArg04, struct Eq_90727 * dwArg08)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	uip32 ecx_112;
	Eq_4 ecx_18 = dwArg04->t0004;
	Eq_4 edx_19 = dwArg04->t0000;
	Eq_4 esi_22 = dwArg08->t0000;
	if (ecx_18 != dwArg08->t0004)
		ecx_112 = 0x00;
	else
	{
		word32 edi_116;
		word32 ebx_114;
		word32 esi_115;
		runtime.eqstring(edx_19, edx_19, ecx_18, esi_22, out ebx_114, out esi_115, out edi_116);
		ecx_112 = (word32) bLoc04;
	}
}

// 08091A40: void runtime.(*errorString).Error(Register (ptr32 Eq_2) gs, Stack word32 dwArg04)
void runtime.(*errorString).Error(struct Eq_2 * gs, word32 dwArg04)
{
	while (true)
	{
		Eq_4 ecx_7 = gs->ptr0000->tFFFFFFFC;
		if (fp > *((word32) ecx_7 + 8))
			break;
		runtime.morestack_noctxt();
	}
	ptr32 * ebx_17 = *((word32) ecx_7 + 16);
	if (ebx_17 != null && *ebx_17 == (word32) fp + 4)
		*ebx_17 = fp - 0x1C;
	if (dwArg04 == 0x00)
		runtime.panicwrap(gs);
	else
		runtime.concatstring2(gs, 0x00);
}

// 08091AC0: void type..hash.runtime.finblock(Register (ptr32 Eq_2) gs, Register Eq_4 mm0, Stack (ptr32 Eq_205) dwArg04, Stack (ptr32 Eq_205) dwArg08)
void type..hash.runtime.finblock(struct Eq_2 * gs, Eq_4 mm0, union Eq_205 * dwArg04, union Eq_205 * dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	word128 xmm1_94;
	word128 xmm1_95;
	runtime.memhash(gs, runtime.memhash(gs, mm0, dwArg04, dwArg08, 0x0C, out xmm1_94), (char *) dwArg04 + 16, dwLoc04, 0x0FF0, out xmm1_95);
}

// 08091B30: void type..eq.runtime.finblock(Register Eq_4 edx, Register (ptr32 Eq_90841) gs, Stack byte bArg00, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack word32 dwArg0C)
void type..eq.runtime.finblock(Eq_4 edx, struct Eq_90841 * gs, byte bArg00, Eq_4 dwArg04, Eq_4 dwArg08, word32 dwArg0C)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		edx = runtime.morestack_noctxt();
	word32 ebx_106;
	word32 esi_107;
	word32 edi_108;
	Eq_4 edx_30 = runtime.memequal(edx, dwArg04, dwArg08, 0x0C, out ebx_106, out esi_107, out edi_108);
	if (bArg00 != 0x00)
	{
		word32 ebx_109;
		word32 esi_110;
		word32 edi_111;
		runtime.memequal(edx_30, (word32) dwArg08 + 16, dwArg0C + 0x10, 0x0FF0, out ebx_109, out esi_110, out edi_111);
	}
}

// 08091BB0: void type..hash.runtime.gcControllerState(Register (ptr32 Eq_2) gs, Register Eq_4 mm0, Stack (ptr32 Eq_205) dwArg04, Stack (ptr32 Eq_205) dwArg08)
void type..hash.runtime.gcControllerState(struct Eq_2 * gs, Eq_4 mm0, union Eq_205 * dwArg04, union Eq_205 * dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_662 xmm1_31;
	Eq_662 xmm1_53;
	Eq_662 xmm1_78;
	word128 xmm1_175;
	word128 xmm1_176;
	runtime.memhash(gs, runtime.f64hash(gs, runtime.f64hash(gs, runtime.f64hash(gs, runtime.memhash(gs, mm0, dwArg04, dwArg08, 0x40, out xmm1_31), xmm1_31, (char *) dwArg04 + 64, dwLoc04, out xmm1_53), xmm1_53, (char *) dwArg04 + 72, (union Eq_205 *) 0x40, out xmm1_78), xmm1_78, (char *) dwArg04 + 80, (union Eq_205 *) 0x40, out xmm1_175), (char *) dwArg04 + 0x0098, (union Eq_205 *) 0x40, 0x08, out xmm1_176);
}

// 08091C70: void type..eq.runtime.gcControllerState(Register Eq_4 edx, Register (ptr32 Eq_90934) gs, Stack byte bArg00, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack (ptr32 Eq_90938) dwArg0C)
void type..eq.runtime.gcControllerState(Eq_4 edx, struct Eq_90934 * gs, byte bArg00, Eq_4 dwArg04, Eq_4 dwArg08, struct Eq_90938 * dwArg0C)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		edx = runtime.morestack_noctxt();
	word32 edi_181;
	word32 esi_180;
	word32 ebx_179;
	runtime.memequal(edx, dwArg04, dwArg08, 0x40, out ebx_179, out esi_180, out edi_181);
	if (bArg00 != 0x00)
	{
		uint128 xmm0_45 = (uint128) *((word32) dwArg08 + 64);
		uint128 xmm1_47 = (uint128) dwArg0C->r0040;
		if ((real64) xmm1_47 == (real64) xmm0_45 && !PARITY_EVEN((real64) xmm1_47 - (real64) xmm0_45))
		{
			uint128 xmm0_56 = (uint128) *((word32) dwArg08 + 72);
			uint128 xmm1_57 = (uint128) dwArg0C->r0048;
			if ((real64) xmm0_56 == (real64) xmm1_57 && !PARITY_EVEN((real64) xmm0_56 - (real64) xmm1_57))
			{
				uint128 xmm0_66 = (uint128) *((word32) dwArg08 + 80);
				uint128 xmm1_67 = (uint128) dwArg0C->r0050;
				if ((real64) xmm0_66 != (real64) xmm1_67 || PARITY_EVEN((real64) xmm0_66 - (real64) xmm1_67))
					;
			}
		}
	}
}

// 08091D40: Register Eq_4 type..hash.runtime.mcentral(Register (ptr32 Eq_2) gs, Register Eq_4 mm0, Stack (ptr32 Eq_205) dwArg04, Stack (ptr32 Eq_205) dwArg08)
// Called from:
//      type..hash.struct { runtime.mcentral runtime.mcentral; runtime.pad [32]uint8 }
Eq_4 type..hash.runtime.mcentral(struct Eq_2 * gs, Eq_4 mm0, union Eq_205 * dwArg04, union Eq_205 * dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	word128 xmm1_94;
	word128 xmm1_95;
	return runtime.memhash(gs, runtime.memhash(gs, mm0, dwArg04, dwArg08, 0x05, out xmm1_94), (char *) dwArg04 + 8, dwLoc04, 0x18, out xmm1_95);
}

// 08091DB0: Register Eq_4 type..eq.runtime.mcentral(Register (ptr32 Eq_91052) gs, Stack Eq_4 dwArg04, Stack (ptr32 Eq_91054) dwArg08)
// Called from:
//      type..eq.struct { runtime.mcentral runtime.mcentral; runtime.pad [32]uint8 }
//      type..eq.[134]struct { runtime.mcentral runtime.mcentral; runtime.pad [32]uint8 }
Eq_4 type..eq.runtime.mcentral(struct Eq_91052 * gs, Eq_4 dwArg04, struct Eq_91054 * dwArg08)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	Eq_4 edx_19 = dwArg04;
	if (*dwArg04 == dwArg08->dw0000 && *((word32) dwArg04 + 4) == dwArg08->b0004)
	{
		word32 ebx_96;
		word32 esi_97;
		word32 edi_98;
		edx_19 = runtime.memequal(dwArg04, (word32) dwArg04 + 8, &dwArg08->b0004 + 4, 0x18, out ebx_96, out esi_97, out edi_98);
	}
	return edx_19;
}

// 08091E20: Register Eq_4 type..hash.struct { runtime.mcentral runtime.mcentral; runtime.pad [32]uint8 }(Register (ptr32 Eq_2) gs, Register Eq_4 mm0, Stack (ptr32 Eq_205) dwArg04, Stack (ptr32 Eq_205) dwArg08)
// Called from:
//      type..hash.[134]struct { runtime.mcentral runtime.mcentral; runtime.pad [32]uint8 }
Eq_4 type..hash.struct { runtime.mcentral runtime.mcentral; runtime.pad [32]uint8 }(struct Eq_2 * gs, Eq_4 mm0, union Eq_205 * dwArg04, union Eq_205 * dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	word128 xmm1_94;
	return runtime.memhash(gs, type..hash.runtime.mcentral(gs, mm0, dwArg04, dwArg08), (char *) dwArg04 + 32, dwLoc08, 0x20, out xmm1_94);
}

// 08091E80: void type..eq.struct { runtime.mcentral runtime.mcentral; runtime.pad [32]uint8 }(Register (ptr32 Eq_91052) gs, Stack Eq_4 dwArg04, Stack (ptr32 Eq_91054) dwArg08)
void type..eq.struct { runtime.mcentral runtime.mcentral; runtime.pad [32]uint8 }(struct Eq_91052 * gs, Eq_4 dwArg04, struct Eq_91054 * dwArg08)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	Eq_4 edx_25 = type..eq.runtime.mcentral(gs, dwArg04, dwArg08);
	if (bLoc08 != 0x00)
	{
		word32 ebx_102;
		word32 esi_103;
		word32 edi_104;
		runtime.memequal(edx_25, (word32) dwArg04 + 32, &dwArg08->b0004 + 28, 0x20, out ebx_102, out esi_103, out edi_104);
	}
}

// 08091EF0: void type..hash.[134]struct { runtime.mcentral runtime.mcentral; runtime.pad [32]uint8 }(Register (ptr32 Eq_2) gs, Register Eq_4 mm0, Stack word32 dwArg04, Stack (ptr32 Eq_205) dwArg08)
void type..hash.[134]struct { runtime.mcentral runtime.mcentral; runtime.pad [32]uint8 }(struct Eq_2 * gs, Eq_4 mm0, word32 dwArg04, union Eq_205 * dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	int32 eax_17;
	union Eq_205 * ecx_20 = dwArg08;
	for (eax_17 = 0x00; eax_17 < 0x86; ++eax_17)
	{
		mm0 = type..hash.struct { runtime.mcentral runtime.mcentral; runtime.pad [32]uint8 }(gs, mm0, (eax_17 << 0x06) + dwArg04, ecx_20);
		ecx_20 = dwLoc08;
	}
}

// 08091F50: void type..eq.[134]struct { runtime.mcentral runtime.mcentral; runtime.pad [32]uint8 }(Register (ptr32 Eq_91052) gs, Stack word32 dwArg04, Stack Eq_4 dwArg08)
void type..eq.[134]struct { runtime.mcentral runtime.mcentral; runtime.pad [32]uint8 }(struct Eq_91052 * gs, word32 dwArg04, Eq_4 dwArg08)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	int32 eax_17 = 0x00;
	while (eax_17 < 0x86)
	{
		ui32 eax_28 = eax_17 << 0x06;
		type..eq.runtime.mcentral(gs, eax_28 + dwArg04, (word32) dwArg08 + eax_28);
		byte bLoc08_144 = (byte) eax_17;
		if (bLoc10 == 0x00)
			return;
		word32 esi_156;
		word32 edi_157;
		word32 ebx_155;
		runtime.memequal(dwArg08, eax_28 + 0x20 + dwArg04, (word32) dwArg08 + (eax_28 + 0x20), 0x20, out ebx_155, out esi_156, out edi_157);
		bLoc10 = 0x20;
		if (bLoc08_144 == 0x00)
			return;
		eax_17 = eax_28 + 0x01;
	}
}

// 08092000: void type..hash.runtime.mstats(Register (ptr32 Eq_2) gs, Register Eq_4 mm0, Stack (ptr32 Eq_205) dwArg04, Stack (ptr32 Eq_205) dwArg08)
void type..hash.runtime.mstats(struct Eq_2 * gs, Eq_4 mm0, union Eq_205 * dwArg04, union Eq_205 * dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_662 xmm1_31;
	Eq_662 xmm1_106;
	word128 xmm1_204;
	word128 xmm1_205;
	word128 xmm1_206;
	word128 xmm1_207;
	runtime.memhash(gs, runtime.f64hash(gs, runtime.memhash(gs, runtime.memhash(gs, runtime.f64hash(gs, runtime.memhash(gs, mm0, dwArg04, dwArg08, 0x10C8, out xmm1_31), xmm1_31, (char *) dwArg04 + 4296, dwLoc04, out xmm1_204), (char *) dwArg04 + 4304, (union Eq_205 *) 0x10C8, 0x02, out xmm1_205), (char *) dwArg04 + 4308, dwLoc04, 0x054C, out xmm1_106), xmm1_106, (char *) dwArg04 + 5664, dwLoc04, out xmm1_206), (char *) dwArg04 + 5672, (union Eq_205 *) 0x054C, 0x20, out xmm1_207);
}

// 080920F0: void type..eq.runtime.mstats(Register Eq_4 edx, Register (ptr32 Eq_91296) gs, Stack byte bArg00, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C, Stack Eq_4 dwArg10)
void type..eq.runtime.mstats(Eq_4 edx, struct Eq_91296 * gs, byte bArg00, Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C, Eq_4 dwArg10)
{
	byte bArg04_175 = (byte) dwArg04;
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		edx = runtime.morestack_noctxt();
	Eq_4 edx_227;
	Eq_4 ecx_112;
	Eq_4 eax_107;
	word32 edi_237;
	word32 esi_236;
	word32 ebx_235;
	runtime.memequal(edx, dwArg04, dwArg08, 0x10C8, out ebx_235, out esi_236, out edi_237);
	struct Eq_91328 * esp_121 = fp - 0x0C;
	if (bArg00 != 0x00)
	{
		eax_107 = dwArg08;
		uint128 xmm0_47 = (uint128) *((word32) dwArg08 + 4296);
		ecx_112 = dwArg0C;
		uint128 xmm1_49 = (uint128) *((word32) dwArg0C + 4296);
		if ((real64) xmm0_47 == (real64) xmm1_49 && !PARITY_EVEN((real64) xmm0_47 - (real64) xmm1_49))
		{
			if (*((word32) dwArg0C + 4304) == *((word32) dwArg08 + 4304))
			{
				if (*((word32) dwArg0C + 0x000010D1) != *((word32) dwArg08 + 0x000010D1))
					edx_227.u0 = 0x00;
				else
				{
					word32 edi_240;
					word32 esi_239;
					word32 ebx_238;
					runtime.memequal((word32) dwArg08 + 4308, (word32) dwArg08 + 4308, (word32) dwArg0C + 4308, 0x054C, out ebx_238, out esi_239, out edi_240);
					esp_121 = fp - 0x08;
					edx_227 = (word32) bArg04_175;
					eax_107 = dwArg0C;
					ecx_112 = dwArg10;
				}
			}
			else
				edx_227.u0 = 0x00;
		}
		else
			edx_227.u0 = 0x00;
	}
	else
	{
		eax_107 = dwArg08;
		ecx_112 = dwArg0C;
		edx_227.u0 = 0x00;
	}
	if ((byte) edx_227 != 0x00)
	{
		uint128 xmm0_111 = (uint128) *((word32) eax_107 + 5664);
		uint128 xmm1_114 = (uint128) *((word32) ecx_112 + 5664);
		if ((real64) xmm0_111 == (real64) xmm1_114 && !PARITY_EVEN((real64) xmm0_111 - (real64) xmm1_114))
		{
			esp_121->t0004 = (word32) ecx_112 + 5672;
			esp_121->t0000 = (word32) eax_107 + 5672;
			esp_121->t0008.u0 = 0x20;
			word32 edi_243;
			word32 esi_242;
			word32 ebx_241;
			runtime.memequal(edx_227, esp_121->t0000, esp_121->t0004, esp_121->t0008, out ebx_241, out esi_242, out edi_243);
		}
	}
}

// 08092230: void runtime.(*plainError).Error(Register (ptr32 Eq_2) gs, Stack word32 dwArg04)
void runtime.(*plainError).Error(struct Eq_2 * gs, word32 dwArg04)
{
	while (true)
	{
		Eq_4 ecx_7 = gs->ptr0000->tFFFFFFFC;
		if (fp > *((word32) ecx_7 + 8))
			break;
		runtime.morestack_noctxt();
	}
	struct Eq_91458 * ebx_16 = *((word32) ecx_7 + 16);
	if (ebx_16 != null && ebx_16->t0000 == (word32) fp + 4)
		ebx_16->t0000 = fp;
	if (dwArg04 != 0x00)
		return;
	runtime.panicwrap(gs);
}

// 08092280: Register Eq_4 type..hash.runtime.sigTabT(Register (ptr32 Eq_2) gs, Register Eq_4 mm0, Stack (ptr32 Eq_205) dwArg04, Stack (ptr32 Eq_205) dwArg08)
// Called from:
//      type..hash.[65]runtime.sigTabT
Eq_4 type..hash.runtime.sigTabT(struct Eq_2 * gs, Eq_4 mm0, union Eq_205 * dwArg04, union Eq_205 * dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	word128 xmm1_92;
	return runtime.strhash(gs, runtime.memhash(gs, mm0, dwArg04, dwArg08, 0x04, out xmm1_92), (char *) dwArg04 + 4, dwLoc04);
}

// 080922E0: void type..eq.runtime.sigTabT(Register (ptr32 Eq_91503) gs, Stack (ptr32 Eq_91504) dwArg04, Stack (ptr32 Eq_91505) dwArg08)
void type..eq.runtime.sigTabT(struct Eq_91503 * gs, struct Eq_91504 * dwArg04, struct Eq_91505 * dwArg08)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	if (dwArg04->dw0000 == dwArg08->dw0000)
	{
		Eq_4 edx_27 = dwArg08->t0004;
		Eq_4 ebx_28 = dwArg04->t0008;
		Eq_4 eax_29 = dwArg04->t0004;
		if (ebx_28 == dwArg08->t0008)
		{
			word32 ebx_94;
			word32 esi_95;
			word32 edi_96;
			runtime.eqstring(edx_27, eax_29, ebx_28, edx_27, out ebx_94, out esi_95, out edi_96);
		}
	}
}

// 08092350: void type..hash.runtime.stackmap(Register (ptr32 Eq_2) gs, Register Eq_4 mm0, Stack (ptr32 Eq_205) dwArg04, Stack (ptr32 Eq_205) dwArg08)
void type..hash.runtime.stackmap(struct Eq_2 * gs, Eq_4 mm0, union Eq_205 * dwArg04, union Eq_205 * dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	word128 xmm1_65;
	runtime.memhash(gs, mm0, dwArg04, dwArg08, 0x09, out xmm1_65);
}

// 080923A0: void type..eq.runtime.stackmap(Register Eq_4 edx, Register (ptr32 Eq_91571) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
void type..eq.runtime.stackmap(Eq_4 edx, struct Eq_91571 * gs, Eq_4 dwArg04, Eq_4 dwArg08)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		edx = runtime.morestack_noctxt();
	word32 ebx_58;
	word32 esi_59;
	word32 edi_60;
	runtime.memequal(edx, dwArg04, dwArg08, 0x09, out ebx_58, out esi_59, out edi_60);
}

// 080923F0: void type..hash.runtime.sweepdata(Register (ptr32 Eq_2) gs, Register Eq_4 mm0, Stack (ptr32 Eq_205) dwArg04, Stack (ptr32 Eq_205) dwArg08)
void type..hash.runtime.sweepdata(struct Eq_2 * gs, Eq_4 mm0, union Eq_205 * dwArg04, union Eq_205 * dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	word128 xmm1_94;
	word128 xmm1_95;
	runtime.memhash(gs, runtime.memhash(gs, mm0, dwArg04, dwArg08, 0x0A, out xmm1_94), (char *) dwArg04 + 0x0C, dwLoc04, 0x08, out xmm1_95);
}

// 08092460: void type..eq.runtime.sweepdata(Register Eq_4 edx, Register (ptr32 Eq_91625) gs, Stack byte bArg00, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack (ptr32 Eq_91629) dwArg0C)
void type..eq.runtime.sweepdata(Eq_4 edx, struct Eq_91625 * gs, byte bArg00, Eq_4 dwArg04, Eq_4 dwArg08, struct Eq_91629 * dwArg0C)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		edx = runtime.morestack_noctxt();
	word32 ebx_99;
	word32 esi_100;
	word32 edi_101;
	runtime.memequal(edx, dwArg04, dwArg08, 0x0A, out ebx_99, out esi_100, out edi_101);
	if (bArg00 != 0x00)
		*((word32) dwArg08 + 0x0C) != dwArg0C->t000C;
}

// 080924D0: void type..hash.runtime.traceStack(Register (ptr32 Eq_2) gs, Register Eq_4 mm0, Stack (ptr32 Eq_205) dwArg04, Stack (ptr32 Eq_205) dwArg08)
void type..hash.runtime.traceStack(struct Eq_2 * gs, Eq_4 mm0, union Eq_205 * dwArg04, union Eq_205 * dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	word128 xmm1_65;
	runtime.memhash(gs, mm0, dwArg04, dwArg08, 0x10, out xmm1_65);
}

// 08092520: void type..eq.runtime.traceStack(Register (ptr32 Eq_1069) gs, Stack (ptr32 Eq_1070) dwArg04, Stack (ptr32 Eq_1071) dwArg08)
void type..eq.runtime.traceStack(struct Eq_1069 * gs, struct Eq_1070 * dwArg04, struct Eq_1071 * dwArg08)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	runtime.memequal128(gs, dwArg04, dwArg08);
}

// 08092560: void type..hash.[14]runtime.dbgVar(Register (ptr32 Eq_2) gs, Register Eq_4 mm0, Stack word32 dwArg04, Stack (ptr32 Eq_205) dwArg08)
void type..hash.[14]runtime.dbgVar(struct Eq_2 * gs, Eq_4 mm0, word32 dwArg04, union Eq_205 * dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	int32 eax_17;
	union Eq_205 * ecx_20 = dwArg08;
	for (eax_17 = 0x00; eax_17 < 0x0E; ++eax_17)
	{
		mm0 = type..hash.runtime.dbgVar(gs, mm0, dwArg04 + eax_17 * 0x0C, ecx_20);
		ecx_20 = dwLoc08;
	}
}

// 080925C0: void type..eq.[14]runtime.dbgVar(Register (ptr32 Eq_91729) gs, Stack (ptr32 Eq_91730) dwArg04, Stack Eq_4 dwArg08)
void type..eq.[14]runtime.dbgVar(struct Eq_91729 * gs, struct Eq_91730 * dwArg04, Eq_4 dwArg08)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	int32 eax_17;
	for (eax_17 = 0x00; eax_17 < 0x0E; ++eax_17)
	{
		ui32 ecx_28 = eax_17 * 0x03;
		Eq_4 ebx_30 = *((word32) dwArg08 + ecx_28 * 0x04);
		Eq_4 edi_33 = dwArg04->a0004[ecx_28];
		Eq_4 eax_34 = dwArg04[ecx_28 * 0x04 / 8];
		if (edi_33 != *((word32) dwArg08 + (ecx_28 * 0x04 + 4)))
			return;
		word32 ebx_136;
		word32 esi_137;
		word32 edi_138;
		runtime.eqstring(dwArg08, eax_34, edi_33, ebx_30, out ebx_136, out esi_137, out edi_138);
		if (bLoc0C == 0x00 || (dwArg04->a0008)[ecx_28] != *((word32) dwArg08 + (ecx_28 * 0x04 + 8)))
			return;
	}
}

// 08092660: void type..hash.[2]string(Register (ptr32 Eq_2) gs, Register Eq_4 mm0, Stack word32 dwArg04, Stack (ptr32 Eq_205) dwArg08)
void type..hash.[2]string(struct Eq_2 * gs, Eq_4 mm0, word32 dwArg04, union Eq_205 * dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	int32 eax_17;
	union Eq_205 * ecx_20 = dwArg08;
	for (eax_17 = 0x00; eax_17 < 0x02; ++eax_17)
	{
		mm0 = runtime.strhash(gs, mm0, dwArg04 + eax_17 * 0x08, ecx_20);
		ecx_20 = dwLoc08;
	}
}

// 080926C0: void type..eq.[2]string(Register (ptr32 Eq_91824) gs, Stack word32 dwArg04, Stack word32 dwArg08)
void type..eq.[2]string(struct Eq_91824 * gs, word32 dwArg04, word32 dwArg08)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	int32 eax_17;
	for (eax_17 = 0x00; eax_17 < 0x02; ++eax_17)
	{
		struct Eq_91843 * edx_29 = dwArg08 + eax_17 * 0x08;
		struct Eq_91847 * esi_32 = dwArg04 + eax_17 * 0x08;
		Eq_4 edx_33 = edx_29->t0000;
		Eq_4 edi_34 = esi_32->t0004;
		Eq_4 esi_35 = esi_32->t0000;
		if (edi_34 != edx_29->t0004)
			return;
		word32 ebx_129;
		word32 esi_130;
		word32 edi_131;
		runtime.eqstring(edx_33, esi_35, edi_34, edx_33, out ebx_129, out esi_130, out edi_131);
		if (bLoc08 == 0x00)
			return;
	}
}

// 08092740: void type..hash.[33]float64(Register (ptr32 Eq_2) gs, Register Eq_4 mm0, Register Eq_662 xmm1, Stack word32 dwArg04, Stack (ptr32 Eq_205) dwArg08)
void type..hash.[33]float64(struct Eq_2 * gs, Eq_4 mm0, Eq_662 xmm1, word32 dwArg04, union Eq_205 * dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	int32 eax_17;
	union Eq_205 * ecx_20 = dwArg08;
	for (eax_17 = 0x00; eax_17 < 33; ++eax_17)
	{
		mm0 = runtime.f64hash(gs, mm0, xmm1, dwArg04 + eax_17 * 0x08, ecx_20, out xmm1);
		ecx_20 = dwLoc08;
	}
}

// 080927A0: void type..eq.[33]float64(Register (ptr32 Eq_91911) gs, Stack (arr real64) dwArg04, Stack (arr real64) dwArg08)
void type..eq.[33]float64(struct Eq_91911 * gs, real64 dwArg04[], real64 dwArg08[])
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	int32 edx_18;
	for (edx_18 = 0x00; edx_18 < 33; ++edx_18)
	{
		uint128 xmm0_28 = (uint128) dwArg04[edx_18];
		uint128 xmm1_30 = (uint128) dwArg08[edx_18];
		if ((real64) xmm0_28 != (real64) xmm1_30 || PARITY_EVEN((real64) xmm0_28 - (real64) xmm1_30))
			return;
	}
}

// 080927F0: void type..hash.[3]string(Register (ptr32 Eq_2) gs, Register Eq_4 mm0, Stack word32 dwArg04, Stack (ptr32 Eq_205) dwArg08)
void type..hash.[3]string(struct Eq_2 * gs, Eq_4 mm0, word32 dwArg04, union Eq_205 * dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	int32 eax_17;
	union Eq_205 * ecx_20 = dwArg08;
	for (eax_17 = 0x00; eax_17 < 0x03; ++eax_17)
	{
		mm0 = runtime.strhash(gs, mm0, dwArg04 + eax_17 * 0x08, ecx_20);
		ecx_20 = dwLoc08;
	}
}

// 08092850: void type..eq.[3]string(Register (ptr32 Eq_91982) gs, Stack word32 dwArg04, Stack word32 dwArg08)
void type..eq.[3]string(struct Eq_91982 * gs, word32 dwArg04, word32 dwArg08)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	int32 eax_17;
	for (eax_17 = 0x00; eax_17 < 0x03; ++eax_17)
	{
		struct Eq_92001 * edx_29 = dwArg08 + eax_17 * 0x08;
		struct Eq_92005 * esi_32 = dwArg04 + eax_17 * 0x08;
		Eq_4 edx_33 = edx_29->t0000;
		Eq_4 edi_34 = esi_32->t0004;
		Eq_4 esi_35 = esi_32->t0000;
		if (edi_34 != edx_29->t0004)
			return;
		word32 ebx_129;
		word32 esi_130;
		word32 edi_131;
		runtime.eqstring(edx_33, esi_35, edi_34, edx_33, out ebx_129, out esi_130, out edi_131);
		if (bLoc08 == 0x00)
			return;
	}
}

// 080928D0: void type..hash.[4]string(Register (ptr32 Eq_2) gs, Register Eq_4 mm0, Stack word32 dwArg04, Stack (ptr32 Eq_205) dwArg08)
void type..hash.[4]string(struct Eq_2 * gs, Eq_4 mm0, word32 dwArg04, union Eq_205 * dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	int32 eax_17;
	union Eq_205 * ecx_20 = dwArg08;
	for (eax_17 = 0x00; eax_17 < 0x04; ++eax_17)
	{
		mm0 = runtime.strhash(gs, mm0, dwArg04 + eax_17 * 0x08, ecx_20);
		ecx_20 = dwLoc08;
	}
}

// 08092930: void type..eq.[4]string(Register (ptr32 Eq_92067) gs, Stack word32 dwArg04, Stack word32 dwArg08)
void type..eq.[4]string(struct Eq_92067 * gs, word32 dwArg04, word32 dwArg08)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	int32 eax_17;
	for (eax_17 = 0x00; eax_17 < 0x04; ++eax_17)
	{
		struct Eq_92086 * edx_29 = dwArg08 + eax_17 * 0x08;
		struct Eq_92090 * esi_32 = dwArg04 + eax_17 * 0x08;
		Eq_4 edx_33 = edx_29->t0000;
		Eq_4 edi_34 = esi_32->t0004;
		Eq_4 esi_35 = esi_32->t0000;
		if (edi_34 != edx_29->t0004)
			return;
		word32 ebx_129;
		word32 esi_130;
		word32 edi_131;
		runtime.eqstring(edx_33, esi_35, edi_34, edx_33, out ebx_129, out esi_130, out edi_131);
		if (bLoc08 == 0x00)
			return;
	}
}

// 080929B0: void type..hash.[5]string(Register (ptr32 Eq_2) gs, Register Eq_4 mm0, Stack word32 dwArg04, Stack (ptr32 Eq_205) dwArg08)
void type..hash.[5]string(struct Eq_2 * gs, Eq_4 mm0, word32 dwArg04, union Eq_205 * dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	int32 eax_17;
	union Eq_205 * ecx_20 = dwArg08;
	for (eax_17 = 0x00; eax_17 < 0x05; ++eax_17)
	{
		mm0 = runtime.strhash(gs, mm0, dwArg04 + eax_17 * 0x08, ecx_20);
		ecx_20 = dwLoc08;
	}
}

// 08092A10: void type..eq.[5]string(Register (ptr32 Eq_92152) gs, Stack word32 dwArg04, Stack word32 dwArg08)
void type..eq.[5]string(struct Eq_92152 * gs, word32 dwArg04, word32 dwArg08)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	int32 eax_17;
	for (eax_17 = 0x00; eax_17 < 0x05; ++eax_17)
	{
		struct Eq_92171 * edx_29 = dwArg08 + eax_17 * 0x08;
		struct Eq_92175 * esi_32 = dwArg04 + eax_17 * 0x08;
		Eq_4 edx_33 = edx_29->t0000;
		Eq_4 edi_34 = esi_32->t0004;
		Eq_4 esi_35 = esi_32->t0000;
		if (edi_34 != edx_29->t0004)
			return;
		word32 ebx_129;
		word32 esi_130;
		word32 edi_131;
		runtime.eqstring(edx_33, esi_35, edi_34, edx_33, out ebx_129, out esi_130, out edi_131);
		if (bLoc08 == 0x00)
			return;
	}
}

// 08092A90: void type..hash.[65]runtime.sigTabT(Register (ptr32 Eq_2) gs, Register Eq_4 mm0, Stack word32 dwArg04, Stack (ptr32 Eq_205) dwArg08)
void type..hash.[65]runtime.sigTabT(struct Eq_2 * gs, Eq_4 mm0, word32 dwArg04, union Eq_205 * dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	int32 eax_17;
	union Eq_205 * ecx_20 = dwArg08;
	for (eax_17 = 0x00; eax_17 < 0x41; ++eax_17)
	{
		mm0 = type..hash.runtime.sigTabT(gs, mm0, dwArg04 + eax_17 * 0x0C, ecx_20);
		ecx_20 = dwLoc08;
	}
}

// 08092AF0: void type..eq.[65]runtime.sigTabT(Register (ptr32 Eq_92238) gs, Stack Eq_4 dwArg04, Stack (ptr32 Eq_92240) dwArg08)
void type..eq.[65]runtime.sigTabT(struct Eq_92238 * gs, Eq_4 dwArg04, struct Eq_92240 * dwArg08)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	int32 eax_17;
	for (eax_17 = 0x00; eax_17 < 0x41; ++eax_17)
	{
		ui32 ecx_27 = eax_17 * 0x03;
		if (*((word32) dwArg04 + ecx_27 * 0x04) != dwArg08[(ecx_27 * 0x04) / 8])
			return;
		Eq_4 ebx_35 = dwArg08->a0004[ecx_27];
		Eq_4 edi_37 = *((word32) dwArg04 + (ecx_27 * 0x04 + 8));
		Eq_4 ecx_38 = *((word32) dwArg04 + (ecx_27 * 0x04 + 4));
		if (edi_37 != (dwArg08->a0008)[ecx_27])
			return;
		word32 ebx_132;
		word32 esi_133;
		word32 edi_134;
		runtime.eqstring(dwArg04, ecx_38, edi_37, ebx_35, out ebx_132, out esi_133, out edi_134);
		if (bLoc08 == 0x00)
			return;
	}
}

// 08092B80: void type..hash.[6]string(Register (ptr32 Eq_2) gs, Register Eq_4 mm0, Stack word32 dwArg04, Stack (ptr32 Eq_205) dwArg08)
void type..hash.[6]string(struct Eq_2 * gs, Eq_4 mm0, word32 dwArg04, union Eq_205 * dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	int32 eax_17;
	union Eq_205 * ecx_20 = dwArg08;
	for (eax_17 = 0x00; eax_17 < 0x06; ++eax_17)
	{
		mm0 = runtime.strhash(gs, mm0, dwArg04 + eax_17 * 0x08, ecx_20);
		ecx_20 = dwLoc08;
	}
}

// 08092BE0: void type..eq.[6]string(Register (ptr32 Eq_92333) gs, Stack word32 dwArg04, Stack word32 dwArg08)
void type..eq.[6]string(struct Eq_92333 * gs, word32 dwArg04, word32 dwArg08)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	int32 eax_17;
	for (eax_17 = 0x00; eax_17 < 0x06; ++eax_17)
	{
		struct Eq_92352 * edx_29 = dwArg08 + eax_17 * 0x08;
		struct Eq_92356 * esi_32 = dwArg04 + eax_17 * 0x08;
		Eq_4 edx_33 = edx_29->t0000;
		Eq_4 edi_34 = esi_32->t0004;
		Eq_4 esi_35 = esi_32->t0000;
		if (edi_34 != edx_29->t0004)
			return;
		word32 ebx_129;
		word32 esi_130;
		word32 edi_131;
		runtime.eqstring(edx_33, esi_35, edi_34, edx_33, out ebx_129, out esi_130, out edi_131);
		if (bLoc08 == 0x00)
			return;
	}
}

// 08092C60: void type..hash.[9]string(Register (ptr32 Eq_2) gs, Register Eq_4 mm0, Stack word32 dwArg04, Stack (ptr32 Eq_205) dwArg08)
void type..hash.[9]string(struct Eq_2 * gs, Eq_4 mm0, word32 dwArg04, union Eq_205 * dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	int32 eax_17;
	union Eq_205 * ecx_20 = dwArg08;
	for (eax_17 = 0x00; eax_17 < 0x09; ++eax_17)
	{
		mm0 = runtime.strhash(gs, mm0, dwArg04 + eax_17 * 0x08, ecx_20);
		ecx_20 = dwLoc08;
	}
}

// 08092CC0: void type..eq.[9]string(Register (ptr32 Eq_92418) gs, Stack word32 dwArg04, Stack word32 dwArg08)
void type..eq.[9]string(struct Eq_92418 * gs, word32 dwArg04, word32 dwArg08)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	int32 eax_17;
	for (eax_17 = 0x00; eax_17 < 0x09; ++eax_17)
	{
		struct Eq_92437 * edx_29 = dwArg08 + eax_17 * 0x08;
		struct Eq_92441 * esi_32 = dwArg04 + eax_17 * 0x08;
		Eq_4 edx_33 = edx_29->t0000;
		Eq_4 edi_34 = esi_32->t0004;
		Eq_4 esi_35 = esi_32->t0000;
		if (edi_34 != edx_29->t0004)
			return;
		word32 ebx_129;
		word32 esi_130;
		word32 edi_131;
		runtime.eqstring(edx_33, esi_35, edi_34, edx_33, out ebx_129, out esi_130, out edi_131);
		if (bLoc08 == 0x00)
			return;
	}
}

// 08092D40: void type..hash.struct { runtime.cycle uint32; runtime.flushed bool }(Register (ptr32 Eq_2) gs, Register Eq_4 mm0, Stack (ptr32 Eq_205) dwArg04, Stack (ptr32 Eq_205) dwArg08)
void type..hash.struct { runtime.cycle uint32; runtime.flushed bool }(struct Eq_2 * gs, Eq_4 mm0, union Eq_205 * dwArg04, union Eq_205 * dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	word128 xmm1_65;
	runtime.memhash(gs, mm0, dwArg04, dwArg08, 0x05, out xmm1_65);
}

// 08092D90: void type..eq.struct { runtime.cycle uint32; runtime.flushed bool }(Register (ptr32 Eq_92495) gs, Stack (ptr32 word32) dwArg04, Stack (ptr32 word32) dwArg08)
void type..eq.struct { runtime.cycle uint32; runtime.flushed bool }(struct Eq_92495 * gs, word32 * dwArg04, word32 * dwArg08)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	*dwArg04 != *dwArg08;
}

// 08092DD0: void type..hash.struct { runtime.enabled bool; runtime.pad [3]uint8; runtime.needed bool; runtime.cgo bool; runtime.alignme uint64 }(Register (ptr32 Eq_2) gs, Register Eq_4 mm0, Stack (ptr32 Eq_205) dwArg04, Stack (ptr32 Eq_205) dwArg08)
void type..hash.struct { runtime.enabled bool; runtime.pad [3]uint8; runtime.needed bool; runtime.cgo bool; runtime.alignme uint64 }(struct Eq_2 * gs, Eq_4 mm0, union Eq_205 * dwArg04, union Eq_205 * dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	word128 xmm1_94;
	word128 xmm1_95;
	runtime.memhash(gs, runtime.memhash(gs, mm0, dwArg04, dwArg08, 0x06, out xmm1_94), (char *) dwArg04 + 8, dwLoc04, 0x08, out xmm1_95);
}

// 08092E40: void type..eq.struct { runtime.enabled bool; runtime.pad [3]uint8; runtime.needed bool; runtime.cgo bool; runtime.alignme uint64 }(Register Eq_4 edx, Register (ptr32 Eq_92547) gs, Stack byte bArg00, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
void type..eq.struct { runtime.enabled bool; runtime.pad [3]uint8; runtime.needed bool; runtime.cgo bool; runtime.alignme uint64 }(Eq_4 edx, struct Eq_92547 * gs, byte bArg00, Eq_4 dwArg04, Eq_4 dwArg08)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		edx = runtime.morestack_noctxt();
	word32 esi_102;
	word32 ebx_101;
	word32 edi_103;
	runtime.memequal(edx, dwArg04, dwArg08, 0x06, out ebx_101, out esi_102, out edi_103);
}

// 08092EB0: void type..hash.struct { runtime.full runtime.lfstack; runtime.empty runtime.lfstack; runtime.pad0 [64]uint8; runtime.wbufSpans struct { runtime.lock runtime.mutex; runtime.free runtime.mSpanList; runtime.busy runtime.mSpanList }; _ uint32; runtime.bytesMarked uint64; runtime.markrootNext uint32; runtime.markrootJobs uint32; runtime.nproc uint32; runtime.tstart int64; runtime.nwait uint32; runtime.ndone uint32; runtime.alldone runtime.note; runtime.helperDrainBlock bool; runtime.nFlushCacheRoots int; runtime.nDataRoots int; runtime.nBSSRoots int; runtime.nSpanRoots int; runtime.nStackRoots int; runtime.markrootDone bool; runtime.startSema uint32; runtime.markDoneSema uint32; runtime.bgMarkReady runtime.note; runtime.bgMarkDone uint32; runtime.mode runtime.gcMode; runtime.userForced bool; runtime.totaltime int64; runtime.initialHeapLive uint64; runtime.assistQueue struct { runtime.lock runtime.mutex; runtime.head runtime.guintptr; runtime.tail runtime.guintptr }; runtime.sweepWaiters struct { runtime.lock runtime.mutex; runtime.head runtime.guintptr }; runtime.cycles uint32; runtime.stwprocs int32; runtime.maxprocs int32; runtime.tSweepTerm int64; runtime.tMark int64; runtime.tMarkTerm int64; runtime.tEnd int64; runtime.pauseNS int64; runtime.pauseStart int64; runtime.heap0 uint64; runtime.heap1 uint64; runtime.heap2 uint64; runtime.heapGoal uint64 }(Register (ptr32 Eq_2) gs, Register Eq_4 mm0, Stack (ptr32 Eq_205) dwArg04, Stack (ptr32 Eq_205) dwArg08)
void type..hash.struct { runtime.full runtime.lfstack; runtime.empty runtime.lfstack; runtime.pad0 [64]uint8; runtime.wbufSpans struct { runtime.lock runtime.mutex; runtime.free runtime.mSpanList; runtime.busy runtime.mSpanList }; _ uint32; runtime.bytesMarked uint64; runtime.markrootNext uint32; runtime.markrootJobs uint32; runtime.nproc uint32; runtime.tstart int64; runtime.nwait uint32; runtime.ndone uint32; runtime.alldone runtime.note; runtime.helperDrainBlock bool; runtime.nFlushCacheRoots int; runtime.nDataRoots int; runtime.nBSSRoots int; runtime.nSpanRoots int; runtime.nStackRoots int; runtime.markrootDone bool; runtime.startSema uint32; runtime.markDoneSema uint32; runtime.bgMarkReady runtime.note; runtime.bgMarkDone uint32; runtime.mode runtime.gcMode; runtime.userForced bool; runtime.totaltime int64; runtime.initialHeapLive uint64; runtime.assistQueue struct { runtime.lock runtime.mutex; runtime.head runtime.guintptr; runtime.tail runtime.guintptr }; runtime.sweepWaiters struct { runtime.lock runtime.mutex; runtime.head runtime.guintptr }; runtime.cycles uint32; runtime.stwprocs int32; runtime.maxprocs int32; runtime.tSweepTerm int64; runtime.tMark int64; runtime.tMarkTerm int64; runtime.tEnd int64; runtime.pauseNS int64; runtime.pauseStart int64; runtime.heap0 uint64; runtime.heap1 uint64; runtime.heap2 uint64; runtime.heapGoal uint64 }(struct Eq_2 * gs, Eq_4 mm0, union Eq_205 * dwArg04, union Eq_205 * dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	word128 xmm1_178;
	word128 xmm1_179;
	word128 xmm1_180;
	word128 xmm1_181;
	word128 xmm1_182;
	runtime.memhash(gs, runtime.memhash(gs, runtime.memhash(gs, runtime.memhash(gs, runtime.memhash(gs, mm0, dwArg04, dwArg08, 100, out xmm1_178), (char *) dwArg04 + 0x0068, dwLoc04, 0x29, out xmm1_179), (char *) dwArg04 + 0x0094, dwLoc04, 0x15, out xmm1_180), (char *) dwArg04 + 0x00AC, dwLoc04, 0x15, out xmm1_181), (char *) dwArg04 + 0x00C4, dwLoc04, 0x80, out xmm1_182);
}

// 08092F80: void type..eq.struct { runtime.full runtime.lfstack; runtime.empty runtime.lfstack; runtime.pad0 [64]uint8; runtime.wbufSpans struct { runtime.lock runtime.mutex; runtime.free runtime.mSpanList; runtime.busy runtime.mSpanList }; _ uint32; runtime.bytesMarked uint64; runtime.markrootNext uint32; runtime.markrootJobs uint32; runtime.nproc uint32; runtime.tstart int64; runtime.nwait uint32; runtime.ndone uint32; runtime.alldone runtime.note; runtime.helperDrainBlock bool; runtime.nFlushCacheRoots int; runtime.nDataRoots int; runtime.nBSSRoots int; runtime.nSpanRoots int; runtime.nStackRoots int; runtime.markrootDone bool; runtime.startSema uint32; runtime.markDoneSema uint32; runtime.bgMarkReady runtime.note; runtime.bgMarkDone uint32; runtime.mode runtime.gcMode; runtime.userForced bool; runtime.totaltime int64; runtime.initialHeapLive uint64; runtime.assistQueue struct { runtime.lock runtime.mutex; runtime.head runtime.guintptr; runtime.tail runtime.guintptr }; runtime.sweepWaiters struct { runtime.lock runtime.mutex; runtime.head runtime.guintptr }; runtime.cycles uint32; runtime.stwprocs int32; runtime.maxprocs int32; runtime.tSweepTerm int64; runtime.tMark int64; runtime.tMarkTerm int64; runtime.tEnd int64; runtime.pauseNS int64; runtime.pauseStart int64; runtime.heap0 uint64; runtime.heap1 uint64; runtime.heap2 uint64; runtime.heapGoal uint64 }(Register Eq_4 edx, Register (ptr32 Eq_92625) gs, Stack byte bArg00, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack word32 dwArg0C)
void type..eq.struct { runtime.full runtime.lfstack; runtime.empty runtime.lfstack; runtime.pad0 [64]uint8; runtime.wbufSpans struct { runtime.lock runtime.mutex; runtime.free runtime.mSpanList; runtime.busy runtime.mSpanList }; _ uint32; runtime.bytesMarked uint64; runtime.markrootNext uint32; runtime.markrootJobs uint32; runtime.nproc uint32; runtime.tstart int64; runtime.nwait uint32; runtime.ndone uint32; runtime.alldone runtime.note; runtime.helperDrainBlock bool; runtime.nFlushCacheRoots int; runtime.nDataRoots int; runtime.nBSSRoots int; runtime.nSpanRoots int; runtime.nStackRoots int; runtime.markrootDone bool; runtime.startSema uint32; runtime.markDoneSema uint32; runtime.bgMarkReady runtime.note; runtime.bgMarkDone uint32; runtime.mode runtime.gcMode; runtime.userForced bool; runtime.totaltime int64; runtime.initialHeapLive uint64; runtime.assistQueue struct { runtime.lock runtime.mutex; runtime.head runtime.guintptr; runtime.tail runtime.guintptr }; runtime.sweepWaiters struct { runtime.lock runtime.mutex; runtime.head runtime.guintptr }; runtime.cycles uint32; runtime.stwprocs int32; runtime.maxprocs int32; runtime.tSweepTerm int64; runtime.tMark int64; runtime.tMarkTerm int64; runtime.tEnd int64; runtime.pauseNS int64; runtime.pauseStart int64; runtime.heap0 uint64; runtime.heap1 uint64; runtime.heap2 uint64; runtime.heapGoal uint64 }(Eq_4 edx, struct Eq_92625 * gs, byte bArg00, Eq_4 dwArg04, Eq_4 dwArg08, word32 dwArg0C)
{
	byte bArg04_180 = (byte) dwArg04;
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		edx = runtime.morestack_noctxt();
	byte al_63;
	word32 ebx_214;
	word32 esi_215;
	word32 edi_216;
	Eq_4 edx_113 = runtime.memequal(edx, dwArg04, dwArg08, 100, out ebx_214, out esi_215, out edi_216);
	struct Eq_92655 * esp_118 = fp - 0x0C;
	if (bArg00 == 0x00)
		al_63 = 0x00;
	else
	{
		word32 ebx_217;
		word32 esi_218;
		word32 edi_219;
		edx_113 = runtime.memequal((word32) dwArg08 + 0x0068, (word32) dwArg08 + 0x0068, dwArg0C + 0x68, 0x29, out ebx_217, out esi_218, out edi_219);
		esp_118 = fp - 0x08;
		al_63 = bArg04_180;
	}
	byte al_93;
	if (al_63 == 0x00)
		al_93 = 0x00;
	else
	{
		esp_118->t0004 = esp_118->dw0018 + 0x94;
		word32 ecx_74 = esp_118->dw0014;
		esp_118->dw0000 = (word32) (ecx_74 + 0x94);
		esp_118->t0008.u0 = 0x15;
		word32 ebx_220;
		word32 esi_221;
		word32 edi_222;
		edx_113 = runtime.memequal(ecx_74 + 0x94, esp_118->dw0000, esp_118->t0004, esp_118->t0008, out ebx_220, out esi_221, out edi_222);
		esp_118 = (struct Eq_92655 *) &esp_118->t0004;
		al_93 = esp_118->b000C;
	}
	byte al_123;
	if (al_93 == 0x00)
		al_123 = 0x00;
	else
	{
		esp_118->t0004 = esp_118->dw0018 + 0xAC;
		word32 ecx_104 = esp_118->dw0014;
		esp_118->dw0000 = ecx_104 + 0xAC;
		esp_118->t0008.u0 = 0x15;
		word32 ebx_223;
		word32 esi_224;
		word32 edi_225;
		edx_113 = runtime.memequal(ecx_104 + 0xAC, esp_118->dw0000, esp_118->t0004, esp_118->t0008, out ebx_223, out esi_224, out edi_225);
		esp_118 = (struct Eq_92655 *) &esp_118->t0004;
		al_123 = esp_118->b000C;
	}
	if (al_123 != 0x00)
	{
		esp_118->t0004 = esp_118->dw0018 + 0xC4;
		esp_118->dw0000 = esp_118->dw0014 + 0xC4;
		esp_118->t0008.u0 = 0x80;
		word32 ebx_226;
		word32 esi_227;
		word32 edi_228;
		runtime.memequal(edx_113, esp_118->dw0000, esp_118->t0004, esp_118->t0008, out ebx_226, out esi_227, out edi_228);
	}
}

// 080930B0: void type..hash.struct { runtime.note runtime.note; runtime.mask [3]uint32; runtime.wanted [3]uint32; runtime.ignored [3]uint32; runtime.recv [3]uint32; runtime.state uint32; runtime.inuse bool }(Register (ptr32 Eq_2) gs, Register Eq_4 mm0, Stack (ptr32 Eq_205) dwArg04, Stack (ptr32 Eq_205) dwArg08)
void type..hash.struct { runtime.note runtime.note; runtime.mask [3]uint32; runtime.wanted [3]uint32; runtime.ignored [3]uint32; runtime.recv [3]uint32; runtime.state uint32; runtime.inuse bool }(struct Eq_2 * gs, Eq_4 mm0, union Eq_205 * dwArg04, union Eq_205 * dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	word128 xmm1_65;
	runtime.memhash(gs, mm0, dwArg04, dwArg08, 0x39, out xmm1_65);
}

// 08093100: void type..eq.struct { runtime.note runtime.note; runtime.mask [3]uint32; runtime.wanted [3]uint32; runtime.ignored [3]uint32; runtime.recv [3]uint32; runtime.state uint32; runtime.inuse bool }(Register Eq_4 edx, Register (ptr32 Eq_92834) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
void type..eq.struct { runtime.note runtime.note; runtime.mask [3]uint32; runtime.wanted [3]uint32; runtime.ignored [3]uint32; runtime.recv [3]uint32; runtime.state uint32; runtime.inuse bool }(Eq_4 edx, struct Eq_92834 * gs, Eq_4 dwArg04, Eq_4 dwArg08)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		edx = runtime.morestack_noctxt();
	word32 ebx_58;
	word32 esi_59;
	word32 edi_60;
	runtime.memequal(edx, dwArg04, dwArg08, 0x39, out ebx_58, out esi_59, out edi_60);
}

// 08093150: void type..hash.struct { F uintptr; runtime.c *runtime.mcache; runtime.spc runtime.spanClass }(Register (ptr32 Eq_2) gs, Register Eq_4 mm0, Stack (ptr32 Eq_205) dwArg04, Stack (ptr32 Eq_205) dwArg08)
void type..hash.struct { F uintptr; runtime.c *runtime.mcache; runtime.spc runtime.spanClass }(struct Eq_2 * gs, Eq_4 mm0, union Eq_205 * dwArg04, union Eq_205 * dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	word128 xmm1_65;
	runtime.memhash(gs, mm0, dwArg04, dwArg08, 0x09, out xmm1_65);
}

// 080931A0: void type..eq.struct { F uintptr; runtime.c *runtime.mcache; runtime.spc runtime.spanClass }(Register Eq_4 edx, Register (ptr32 Eq_92880) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
void type..eq.struct { F uintptr; runtime.c *runtime.mcache; runtime.spc runtime.spanClass }(Eq_4 edx, struct Eq_92880 * gs, Eq_4 dwArg04, Eq_4 dwArg08)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		edx = runtime.morestack_noctxt();
	word32 ebx_58;
	word32 esi_59;
	word32 edi_60;
	runtime.memequal(edx, dwArg04, dwArg08, 0x09, out ebx_58, out esi_59, out edi_60);
}

// 080931F0: void type..hash.struct { F uintptr; runtime.preemptible bool }(Register (ptr32 Eq_2) gs, Register Eq_4 mm0, Stack (ptr32 Eq_205) dwArg04, Stack (ptr32 Eq_205) dwArg08)
void type..hash.struct { F uintptr; runtime.preemptible bool }(struct Eq_2 * gs, Eq_4 mm0, union Eq_205 * dwArg04, union Eq_205 * dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	word128 xmm1_65;
	runtime.memhash(gs, mm0, dwArg04, dwArg08, 0x05, out xmm1_65);
}

// 08093240: void type..eq.struct { F uintptr; runtime.preemptible bool }(Register (ptr32 Eq_92925) gs, Stack (ptr32 word32) dwArg04, Stack (ptr32 word32) dwArg08)
void type..eq.struct { F uintptr; runtime.preemptible bool }(struct Eq_92925 * gs, word32 * dwArg04, word32 * dwArg08)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	*dwArg04 != *dwArg08;
}

// 08093280: void type..hash.struct { F uintptr; runtime.s **runtime.mspan; runtime.h *runtime.mheap; runtime.npage uintptr; runtime.spanclass runtime.spanClass; runtime.large bool }(Register (ptr32 Eq_2) gs, Register Eq_4 mm0, Stack (ptr32 Eq_205) dwArg04, Stack (ptr32 Eq_205) dwArg08)
void type..hash.struct { F uintptr; runtime.s **runtime.mspan; runtime.h *runtime.mheap; runtime.npage uintptr; runtime.spanclass runtime.spanClass; runtime.large bool }(struct Eq_2 * gs, Eq_4 mm0, union Eq_205 * dwArg04, union Eq_205 * dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	word128 xmm1_65;
	runtime.memhash(gs, mm0, dwArg04, dwArg08, 0x12, out xmm1_65);
}

// 080932D0: void type..eq.struct { F uintptr; runtime.s **runtime.mspan; runtime.h *runtime.mheap; runtime.npage uintptr; runtime.spanclass runtime.spanClass; runtime.large bool }(Register Eq_4 edx, Register (ptr32 Eq_92969) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
void type..eq.struct { F uintptr; runtime.s **runtime.mspan; runtime.h *runtime.mheap; runtime.npage uintptr; runtime.spanclass runtime.spanClass; runtime.large bool }(Eq_4 edx, struct Eq_92969 * gs, Eq_4 dwArg04, Eq_4 dwArg08)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		edx = runtime.morestack_noctxt();
	word32 ebx_58;
	word32 esi_59;
	word32 edi_60;
	runtime.memequal(edx, dwArg04, dwArg08, 0x12, out ebx_58, out esi_59, out edi_60);
}

// 08093320: void type..hash.struct { F uintptr; runtime.s **runtime.mspan; runtime.size *uintptr; runtime.needzero bool; runtime.noscan bool }(Register (ptr32 Eq_2) gs, Register Eq_4 mm0, Stack (ptr32 Eq_205) dwArg04, Stack (ptr32 Eq_205) dwArg08)
void type..hash.struct { F uintptr; runtime.s **runtime.mspan; runtime.size *uintptr; runtime.needzero bool; runtime.noscan bool }(struct Eq_2 * gs, Eq_4 mm0, union Eq_205 * dwArg04, union Eq_205 * dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	word128 xmm1_65;
	runtime.memhash(gs, mm0, dwArg04, dwArg08, 0x0E, out xmm1_65);
}

// 08093370: void type..eq.struct { F uintptr; runtime.s **runtime.mspan; runtime.size *uintptr; runtime.needzero bool; runtime.noscan bool }(Register Eq_4 edx, Register (ptr32 Eq_93015) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
void type..eq.struct { F uintptr; runtime.s **runtime.mspan; runtime.size *uintptr; runtime.needzero bool; runtime.noscan bool }(Eq_4 edx, struct Eq_93015 * gs, Eq_4 dwArg04, Eq_4 dwArg08)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		edx = runtime.morestack_noctxt();
	word32 ebx_58;
	word32 esi_59;
	word32 edi_60;
	runtime.memequal(edx, dwArg04, dwArg08, 0x0E, out ebx_58, out esi_59, out edi_60);
}

// 080933C0: void errors.New(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack word32 dwArg08)
// Called from:
//      strconv.init
//      io.init
//      time.init
//      internal/poll.init
//      os.init
//      fmt.init
void errors.New(struct Eq_2 * gs, Eq_4 dwArg04, word32 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.newobject(gs, 0x080D1920);
	*((word32) dwLoc08 + 4) = dwArg08;
	if (g_t81576F0 == 0x00)
		*dwLoc08 = dwArg04;
	else
		runtime.writebarrierptr(dwLoc08, dwArg04);
}

// 08093440: void errors.(*errorString).Error(Register (ptr32 Eq_93070) gs)
void errors.(*errorString).Error(struct Eq_93070 * gs)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
}

// 08093470: void unicode/utf8.DecodeRuneInString(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_93084) dwArg04, Stack Eq_4 dwArg08)
// Called from:
//      strconv.appendQuotedWith
//      strconv.CanBackquote
void unicode/utf8.DecodeRuneInString(struct Eq_2 * gs, struct Eq_93084 * dwArg04, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (dwArg08 < 0x01)
		return;
	ui32 ebx_26 = (word32) g_a81399E0[(word32) dwArg04->b0000];
	cu8 bl_27 = (byte) ebx_26;
	if (bl_27 >= 0xF0)
		return;
	uint32 ebx_45 = (word32) (bl_27 >> 0x04);
	if (ebx_45 >= 0x05)
		runtime.panicindex(gs);
	else
	{
		struct Eq_93121 * ebx_51 = ebx_45 * 0x02 + 0x08136108;
		word32 edi_52 = (word32) ebx_51->b0001;
		cu8 bl_66 = ebx_51->b0000;
		if (dwArg08 < (ebx_26 & 0x07))
			return;
		if (dwArg08 <= 0x01)
			runtime.panicindex(gs);
		else
		{
			word32 esi_61 = (word32) dwArg04->b0001;
			if ((byte) esi_61 < bl_66 || (byte) edi_52 < (byte) esi_61)
				return;
			if (((byte) ebx_26 & 0x07) == 0x02)
				return;
			if (dwArg08 <= 0x02)
				runtime.panicindex(gs);
			else
			{
				if (dwArg04->b0002 > 191 || dwArg04->b0002 < 0x80)
					return;
				if (((byte) ebx_26 & 0x07) == 0x03)
					return;
				if (dwArg08 <= 0x03)
					runtime.panicindex(gs);
				else if (dwArg04->b0003 <= 191)
					;
			}
		}
	}
}

// 08093640: void unicode/utf8.EncodeRune(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_93186) dwArg04, Stack ptr32 dwArg08, Stack Eq_4 dwArg10)
// Called from:
//      strconv.appendEscapedRune
//      fmt.(*fmt).fmt_unicode
//      fmt.(*fmt).fmt_c
//      fmt.(*buffer).WriteRune
void unicode/utf8.EncodeRune(struct Eq_2 * gs, struct Eq_93186 * dwArg04, ptr32 dwArg08, Eq_4 dwArg10)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 eax_16 = dwArg10;
	byte al_108 = (byte) dwArg10;
	if (dwArg10 > 0x7F)
	{
		if (dwArg10 > 0x07FF)
		{
			if (dwArg10 > 1114111 || dwArg10 <= ~0xDFFE)
				eax_16.u0 = 0xFFFD;
			else if (dwArg10 > 0xFFFF)
			{
				if (dwArg08 <= 0x03)
					runtime.panicindex(gs);
				else
				{
					dwArg04->b0000 = (byte) (dwArg10 >> 0x12) | 0xF0;
					dwArg04->b0001 = (byte) (dwArg10 >> 0x0C) & 0x3F | 0x80;
					dwArg04->b0002 = (byte) (dwArg10 >> 0x06) & 0x3F | 0x80;
					dwArg04->b0003 = (byte) dwArg10 & 0x3F | 0x80;
					return;
				}
			}
			if (dwArg08 <= 0x02)
				runtime.panicindex(gs);
			else
			{
				dwArg04->b0000 = (byte) (eax_16 >> 0x0C) | 0xE0;
				dwArg04->b0001 = (byte) (eax_16 >> 0x06) & 0x3F | 0x80;
				dwArg04->b0002 = (byte) eax_16 & 0x3F | 0x80;
			}
		}
		else if (dwArg08 <= 0x01)
			runtime.panicindex(gs);
		else
		{
			dwArg04->b0000 = (byte) (dwArg10 >> 0x06) | 0xC0;
			dwArg04->b0001 = (byte) dwArg10 & 0x3F | 0x80;
		}
	}
	else if (dwArg08 <= 0x00)
		runtime.panicindex(gs);
	else
		dwArg04->b0000 = al_108;
}

// 08093780: void unicode/utf8.RuneCount(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
// Called from:
//      fmt.(*fmt).pad
void unicode/utf8.RuneCount(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 edx_157 = 0x00;
	while (edx_157 < dwArg08)
	{
		if (edx_157 >= dwArg08)
			runtime.panicindex(gs);
		word32 ebp_36 = CONVERT(Mem35[dwArg04 + edx_157:byte], byte, word32);
		if ((byte) ebp_36 < 0x80)
			++edx_157;
		else
		{
			ui32 ebp_55 = (word32) g_a81399E0[(word32) (byte) ebp_36];
			if ((byte) ebp_55 == ~0x0E)
				++edx_157;
			else
			{
				struct Eq_93352 * ebp_141 = ebp_55 & 0x07;
				if ((word32) edx_157 + (ebp_55 & 0x07) > dwArg08)
					++edx_157;
				else
				{
					uint32 esi_84 = (word32) ((byte) ebp_55 >> 0x04);
					if (esi_84 >= 0x05)
						runtime.panicindex(gs);
					struct Eq_93371 * esi_92 = esi_84 * 0x02 + 0x08136108;
					word32 edi_93 = (word32) esi_92->b0001;
					word32 esi_94 = (word32) esi_92->b0000;
					if (edx_157 + 0x01 >=u dwArg08)
						runtime.panicindex(gs);
					struct Eq_93352 * ebx_148;
					byte bl_102 = Mem90[edx_157 + 0x01 + dwArg04:byte];
					if (bl_102 < (byte) esi_94 || (byte) edi_93 < bl_102)
						ebx_148 = (struct Eq_93352 *) 0x01;
					else
					{
						if ((ebp_55 & 0x07) != 0x02)
						{
							if (edx_157 + 0x02 >=u dwArg08)
								runtime.panicindex(gs);
							struct Eq_93352 * ebx_143;
							if (Mem90[edx_157 + 0x02 + dwArg04:byte] >u 0x41)
								ebx_143 = (struct Eq_93352 *) 0x01;
							else
							{
								if ((ebp_55 & 0x07) != 0x03)
								{
									if (edx_157 + 0x03 >=u dwArg08)
										runtime.panicindex(gs);
									struct Eq_93352 * ebx_138;
									if (Mem90[edx_157 + 0x03 + dwArg04:byte] >u 0x41)
										ebx_138 = (struct Eq_93352 *) 0x01;
									else
										ebx_138 = ebp_55 & 0x07;
									ebp_141 = ebx_138;
								}
								ebx_143 = ebp_141;
							}
							ebp_141 = ebx_143;
						}
						ebx_148 = ebp_141;
					}
					edx_157 += ebx_148;
				}
			}
		}
	}
}

// 080938D0: void unicode/utf8.RuneCountInString(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
// Called from:
//      fmt.(*fmt).padString
void unicode/utf8.RuneCountInString(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 edx_157 = 0x00;
	while (edx_157 < dwArg08)
	{
		if (edx_157 >= dwArg08)
			runtime.panicindex(gs);
		word32 ebp_36 = CONVERT(Mem35[dwArg04 + edx_157:byte], byte, word32);
		if ((byte) ebp_36 < 0x80)
			++edx_157;
		else
		{
			ui32 ebp_55 = (word32) g_a81399E0[(word32) (byte) ebp_36];
			if ((byte) ebp_55 == ~0x0E)
				++edx_157;
			else
			{
				struct Eq_93476 * ebp_141 = ebp_55 & 0x07;
				if ((word32) edx_157 + (ebp_55 & 0x07) > dwArg08)
					++edx_157;
				else
				{
					uint32 esi_84 = (word32) ((byte) ebp_55 >> 0x04);
					if (esi_84 >= 0x05)
						runtime.panicindex(gs);
					struct Eq_93495 * esi_92 = esi_84 * 0x02 + 0x08136108;
					word32 edi_93 = (word32) esi_92->b0000;
					word32 esi_94 = (word32) esi_92->b0001;
					if (edx_157 + 0x01 >=u dwArg08)
						runtime.panicindex(gs);
					struct Eq_93476 * ebx_148;
					byte bl_102 = Mem90[edx_157 + 0x01 + dwArg04:byte];
					if (bl_102 < (byte) edi_93 || (byte) esi_94 < bl_102)
						ebx_148 = (struct Eq_93476 *) 0x01;
					else
					{
						if ((ebp_55 & 0x07) != 0x02)
						{
							if (edx_157 + 0x02 >=u dwArg08)
								runtime.panicindex(gs);
							struct Eq_93476 * ebx_143;
							if (Mem90[edx_157 + 0x02 + dwArg04:byte] >u 0x41)
								ebx_143 = (struct Eq_93476 *) 0x01;
							else
							{
								if ((ebp_55 & 0x07) != 0x03)
								{
									if (edx_157 + 0x03 >=u dwArg08)
										runtime.panicindex(gs);
									struct Eq_93476 * ebx_138;
									if (Mem90[edx_157 + 0x03 + dwArg04:byte] >u 0x41)
										ebx_138 = (struct Eq_93476 *) 0x01;
									else
										ebx_138 = ebp_55 & 0x07;
									ebp_141 = ebx_138;
								}
								ebx_143 = ebp_141;
							}
							ebp_141 = ebx_143;
						}
						ebx_148 = ebp_141;
					}
					edx_157 += ebx_148;
				}
			}
		}
	}
}

// 08093A20: void strconv.(*decimal).String(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void strconv.(*decimal).String(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 ecx_23;
	Eq_4 ecx_18 = *((word32) dwArg04 + 800);
	Eq_4 ebx_20 = *((word32) dwArg04 + 804);
	if (ebx_20 > 0x00)
		ecx_23 = (word32) ebx_20 + ((word32) ecx_18 + 0x0A);
	else
		ecx_23 = (word32) ecx_18 + 0x0A;
	if (ebx_20 < 0x00)
		ecx_23 -= ebx_20;
	word32 edi_548;
	runtime.makeslice(gs, 0x080CF320, ecx_23, ecx_23, out edi_548);
	Eq_4 ebp_55 = *((word32) dwArg04 + 800);
	if (ebp_55 == 0x00)
		return;
	Eq_4 eax_141;
	Eq_4 esi_148 = *((word32) dwArg04 + 804);
	if (esi_148 <= 0x00)
	{
		if (dwLoc1C <= 0x00)
			runtime.panicindex(gs);
		*dwLoc20 = 0x30;
		if (dwLoc1C <= 0x01)
			runtime.panicindex(gs);
		((word32) dwLoc20 + 1)->u1 = 0x2E;
		Eq_93628 ebx_273 = -*((word32) dwArg04 + 804);
		if (ebx_273 < 0x00 || (word32) ebx_273 + 2 > dwLoc18)
			runtime.panicslice(gs);
		strconv.digitZero(gs, (word32) dwLoc20 + (0x02 - dwLoc18 >> 0x1F & 0x02), ebx_273);
		if (dwLoc20 + 0x02 <=u dwLoc1C)
		{
			word32 edx_305 = dwLoc1C - (dwLoc20 + 0x02);
			word32 ecx_312 = (dwLoc20 + 0x02 & (dwLoc20 + 0x02) - dwLoc18 >> 0x1F) + dwLoc20;
			Eq_4 edi_314 = *((word32) dwArg04 + 800);
			if (edi_314 <= 800)
			{
				if (edx_305 <= edi_314)
					edi_314 = edx_305;
				word128 xmm2_554;
				word32 edi_551;
				word128 xmm0_552;
				word128 xmm1_553;
				word32 ebp_549;
				word32 esi_550;
				runtime.memmove(ecx_312, dwArg04, edi_314, out ebp_549, out esi_550, out edi_551, out xmm0_552, out xmm1_553, out xmm2_554);
				eax_141 = (word32) dwLoc20 + ((word32) edi_314 + 2);
				goto l08093B67;
			}
		}
		runtime.panicslice(gs);
	}
	if (esi_148 >= ebp_55)
	{
		if (ebp_55 > 800)
			runtime.panicslice(gs);
		if (dwLoc1C <= ebp_55)
			ebp_55 = dwLoc1C;
		word128 xmm0_570;
		word32 edi_569;
		word128 xmm1_571;
		word128 xmm2_572;
		word32 ebp_567;
		word32 esi_568;
		runtime.memmove(dwLoc20, dwArg04, ebp_55, out ebp_567, out esi_568, out edi_569, out xmm0_570, out xmm1_571, out xmm2_572);
		word32 ecx_112 = Mem86[dwArg04 + 0x0324:word32] + ebp_55 - Mem86[dwArg04 + 800:word32];
		if (ebp_55 > ecx_112 || ecx_112 > dwLoc18)
			runtime.panicslice(gs);
		strconv.digitZero(gs, (word32) dwLoc20 + (ebp_55 - dwLoc18 >> 0x1F & ebp_55), ecx_112 - ebp_55);
		eax_141 = dwLoc20 + ebp_55;
l08093B67:
		if (eax_141 > dwLoc18)
			runtime.panicslice(gs);
		else
			runtime.slicebytetostring(gs, 0x00, dwLoc20, eax_141);
	}
	else
	{
		if (esi_148 > 800)
			runtime.panicslice(gs);
		if (dwLoc1C <= esi_148)
			esi_148 = dwLoc1C;
		word128 xmm2_560;
		word32 edi_557;
		word128 xmm0_558;
		word128 xmm1_559;
		word32 ebp_555;
		word32 esi_556;
		runtime.memmove(dwLoc20, dwArg04, esi_148, out ebp_555, out esi_556, out edi_557, out xmm0_558, out xmm1_559, out xmm2_560);
		if (esi_148 >= dwLoc1C)
			runtime.panicindex(gs);
		Mem183[dwLoc20 + esi_148:byte] = 0x2E;
		if ((word32) esi_148 + 1 <= dwLoc1C)
		{
			Eq_4 ecx_187 = dwLoc1C - ((word32) esi_148 + 1);
			Eq_4 ebx_199 = (word32) dwLoc20 + ((word32) esi_148 + 1 & ((word32) esi_148 + 1) - dwLoc18 >> 0x1F);
			Eq_4 edi_201 = *((word32) dwArg04 + 804);
			Eq_4 edx_202 = *((word32) dwArg04 + 800);
			if (edi_201 <= edx_202 && edx_202 <= 800)
			{
				Eq_4 edx_208 = edx_202 - edi_201;
				Eq_4 ebp_226 = (word32) dwArg04 + (edi_201 & edi_201 - 800 >> 0x1F);
				if (ecx_187 <= edx_208)
					edx_208 = ecx_187;
				word128 xmm2_566;
				word32 edi_563;
				word128 xmm0_564;
				word128 xmm1_565;
				word32 ebp_561;
				word32 esi_562;
				runtime.memmove(ebx_199, ebp_226, edx_208, out ebp_561, out esi_562, out edi_563, out xmm0_564, out xmm1_565, out xmm2_566);
				eax_141 = (word32) esi_148 + ((word32) edx_208 + 1);
				goto l08093B67;
			}
		}
		runtime.panicslice(gs);
	}
}

// 08093D80: void strconv.digitZero(Register (ptr32 Eq_2) gs, Stack int32 dwArg04, Stack Eq_93628 dwArg08)
// Called from:
//      strconv.(*decimal).String
void strconv.digitZero(struct Eq_2 * gs, int32 dwArg04, Eq_93628 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_93628 edx_18 = 0x00;
	while (edx_18 < dwArg08)
	{
		if (edx_18 >= dwArg08)
			runtime.panicindex(gs);
		*((word32) edx_18 + dwArg04) = 0x30;
		edx_18 = (word32) edx_18 + 1;
	}
}

// 08093DC0: void strconv.trim(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      strconv.(*decimal).Assign
//      strconv.rightShift
//      strconv.leftShift
//      strconv.(*decimal).RoundDown
void strconv.trim(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	while (true)
	{
		Eq_4 ecx_19 = *((word32) dwArg04 + 800);
		if (ecx_19 <= 0x00)
			break;
		if (ecx_19 >= 0x0321)
			runtime.panicindex(gs);
		if (Mem18[ecx_19 - 0x01 + dwArg04:byte] != 0x30)
			break;
		*((word32) dwArg04 + 800) = ecx_19 - 0x01;
	}
	if (ecx_19 == 0x00)
		((word32) dwArg04 + 804)->u0 = 0x00;
}

// 08093E20: void strconv.(*decimal).Assign(Register ui24 ebx_24_8, Register Eq_4 ebp, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg00, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
// Called from:
//      strconv.bigFtoa
//      strconv.roundShortest
void strconv.(*decimal).Assign(ui24 ebx_24_8, Eq_4 ebp, struct Eq_2 * gs, Eq_4 dwArg00, Eq_4 dwArg04, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	fn0808FD8A(0x00, fp - 0x18);
	Eq_4 eax_136 = dwArg08;
	Eq_4 ecx_129 = dwArg04;
	Eq_93911 edx_142 = 0x00;
	while (true)
	{
		ui24 ebx_24_8_45 = SLICE(ebp, word24, 8);
		Eq_4 ebp_63 = SEQ(ebx_24_8_45, (int8) (eax_136 > 0x00)) | SEQ(ebx_24_8, (int8) (eax_136 == 0x00)) & SEQ(ebx_24_8_45, (int8) (ecx_129 > 0x00));
		ebp = ebp_63;
		if ((byte) ebp_63 == 0x00)
			break;
		runtime.uint64div(gs, ecx_129, eax_136, 0x0A, 0x00);
		ecx_129 = dwLoc28;
		byte dl_140 = (byte) ecx_129 - (byte) dwLoc28 * 0x0A + 0x30;
		eax_136 = dwLoc24;
		ebx_24_8 = SLICE(edx_142, word24, 8);
		if (edx_142 >= 0x18)
			runtime.panicindex(gs);
		*((word32) edx_142 + (fp - 0x1C)) = dl_140;
		edx_142 = (word32) edx_142 + 1;
	}
	((word32) dwArg00 + 800)->u0 = 0x00;
	Eq_93937 ecx_111;
	for (ecx_111 = edx_142 - 0x01; ecx_111 >= 0x00; --ecx_111)
	{
		if (ecx_111 >= 0x18)
		{
l08093F1B:
			runtime.panicindex(gs);
		}
		Eq_4 edx_102 = *((word32) dwArg00 + 800);
		byte bl_106 = Mem85[fp - 0x1C + ecx_111:byte];
		if (edx_102 >= 800)
			goto l08093F1B;
		Mem107[dwArg00 + edx_102:byte] = bl_106;
		*((word32) dwArg00 + 800) = (word32) *((word32) dwArg00 + 800) + 1;
	}
	*((word32) dwArg00 + 804) = *((word32) dwArg00 + 800);
	strconv.trim(gs, dwArg00);
}

// 08093F40: Register Eq_4 strconv.rightShift(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_94006 dwArg08, Register out Eq_4 esiOut)
// Called from:
//      strconv.(*decimal).Shift
Eq_4 strconv.rightShift(struct Eq_2 * gs, Eq_4 dwArg04, Eq_94006 dwArg08, union Eq_4 & esiOut)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 ecx_19 = 0x00;
	Eq_4 ebx_20 = 0x00;
	while (true)
	{
		Eq_4 ebp_156;
		byte cl_28 = (byte) dwArg08;
		Eq_4 esi_27 = ecx_19;
		ui32 edi_32 = 0x00 - (dwArg08 < 0x20);
		if ((edi_32 & ecx_19 >> cl_28) != 0x00)
			break;
		if (ebx_20 >= *((word32) dwArg04 + 800))
		{
			if (ecx_19 == 0x00)
			{
				((word32) dwArg04 + 800)->u0 = 0x00;
				esiOut = ecx_19;
				return ebx_20;
			}
			else
			{
				while (true)
				{
					ebp_156 = esi_27;
					if ((edi_32 & esi_27 >> cl_28) != 0x00)
						break;
					esi_27 *= 0x0A;
					++ebx_20;
				}
				goto l08093FBE;
			}
		}
		if (ebx_20 >= 800)
			runtime.panicindex(gs);
		ecx_19 = CONVERT(Mem0[ebx_20 + dwArg04:byte], byte, word32) - 0x30 + ecx_19 * 0x0A;
		++ebx_20;
	}
	ebp_156 = ecx_19;
l08093FBE:
	*((word32) dwArg04 + 804) -= ebx_20 - (struct Eq_94060 *) 0x01;
	ui32 ebx_79 = 0x01 << cl_28 & edi_32;
	Eq_4 esi_187;
	Eq_4 dwLoc14_233 = 0x00;
	byte cl_224 = (byte) dwArg08;
	for (esi_187 = ebx_20; esi_187 < *((word32) dwArg04 + 800); ++esi_187)
	{
		if (esi_187 >= 800)
			runtime.panicindex(gs);
		word32 ebx_167 = CONVERT(Mem166[esi_187 + dwArg04:byte], byte, word32);
		ui32 ebp_171 = ebp_156 >> cl_224 & edi_32;
		ui32 edi_174 = ebp_156 & ebx_79 - 0x01;
		if (dwLoc14_233 >= 800)
			runtime.panicindex(gs);
		Mem184[dwArg04 + dwLoc14_233:byte] = SLICE(ebp_171, byte, 0) + 0x30;
		ebp_156 = ebx_167 - 0x30 + edi_174 * 0x0A;
		++dwLoc14_233;
	}
	Eq_4 esi_104 = dwLoc14_233;
	while (ebp_156 > 0x00)
	{
		Eq_4 ebp_137;
		uint32 ebp_121 = ebp_156 >> cl_224;
		ui32 ebp_124 = ebp_121 & edi_32;
		ui32 edx_127 = ebp_156 & ebx_79 - 0x01;
		if (esi_104 < 800)
		{
			if (esi_104 >= 800)
				runtime.panicindex(gs);
			Mem145[dwArg04 + esi_104:byte] = SLICE(ebp_124, byte, 0) + 0x30;
			ebp_137 = esi_104 + 0x01;
		}
		else
		{
			if ((edi_32 & ebp_121) > 0x00)
				*((word32) dwArg04 + 809) = 0x01;
			ebp_137 = esi_104;
		}
		esi_104 = ebp_137;
		ebp_156 = edx_127 * 0x0A;
	}
	*((word32) dwArg04 + 800) = esi_104;
	strconv.trim(gs, dwArg04);
	esiOut = esi_104;
	return ebx_79 - 0x01;
}

// 08094100: void strconv.prefixIsLessThan(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack int32 dwArg10, Stack Eq_4 dwArg14)
// Called from:
//      strconv.leftShift
void strconv.prefixIsLessThan(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, int32 dwArg10, Eq_4 dwArg14)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 ebp_20 = 0x00;
	while (ebp_20 < dwArg14)
	{
		if (ebp_20 >= dwArg08)
			return;
		if (ebp_20 >= dwArg08)
		{
l0809415B:
			runtime.panicindex(gs);
		}
		word32 esi_36 = CONVERT(Mem0[dwArg04 + ebp_20:byte], byte, word32);
		if (ebp_20 >= dwArg14)
			goto l0809415B;
		if ((byte) esi_36 != *((word32) ebp_20 + dwArg10))
			return;
		ebp_20 = (word32) ebp_20 + 1;
	}
}

// 08094170: Register Eq_4 strconv.leftShift(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Register out (ptr32 Eq_94201) esiOut)
// Called from:
//      strconv.(*decimal).Shift
Eq_4 strconv.leftShift(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, struct Eq_94201 & esiOut)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_138949 ecx_18[] = g_ptr8142760;
	if (dwArg08 >= g_t8142764)
		runtime.panicindex(gs);
	else
	{
		Eq_94222 ebx_23 = ecx_18[dwArg08].t0000;
		Eq_4 esi_25 = *((word32) dwArg04 + 800);
		if (esi_25 > 800)
			runtime.panicslice(gs);
		else
		{
			Eq_94222 edx_52;
			strconv.prefixIsLessThan(gs, dwArg04, esi_25, ecx_18[dwArg08].dw0004, ecx_18[dwArg08].t0008);
			if (bLoc0C != 0x00)
				edx_52 = ebx_23 - 0x01;
			else
				edx_52 = ebx_23;
			Eq_4 ebp_60 = *((word32) dwArg04 + 800);
			word32 esi_115 = edx_52 + ebp_60;
			Eq_94253 ebp_180;
			uint32 eax_129 = 0x00;
			for (ebp_180 = ebp_60 - 0x01; ebp_180 >= 0x00; --ebp_180)
			{
				if (ebp_180 >= 800)
					runtime.panicindex(gs);
				word32 edx_150 = (CONVERT(Mem138[dwArg04 + ebp_180:byte], byte, word32) + ~0x2F << SLICE(dwArg08, byte, 0) & 0x00 - (dwArg08 <u 0x20)) + eax_129;
				uint32 edx_154 = SLICE(edx_150 *64 ~0x33333332, word32, 32);
				uint32 edi_159 = edx_150 - ((edx_154 >> 0x03) + (edx_154 >> 0x03) * 0x04 << 0x01);
				struct Eq_94201 * edx_161 = esi_115 - 0x01;
				if (edx_161 < (struct Eq_94201 *) 800)
				{
					if (edx_161 >= (struct Eq_94201 *) 800)
						runtime.panicindex(gs);
					*((word32) dwArg04 + (esi_115 - 0x01)) = (byte) edi_159 + 0x30;
				}
				else if (edi_159 != 0x00)
					*((word32) dwArg04 + 809) = 0x01;
				eax_129 = edx_154 >> 0x03;
				esi_115 = edx_161;
			}
			while (eax_129 > 0x00)
			{
				uint32 edx_110 = SLICE(eax_129 *64 ~0x33333332, word32, 32);
				uint32 ecx_114 = eax_129 - ((edx_110 >> 0x03) + (edx_110 >> 0x03) * 0x04 << 0x01);
				struct Eq_94201 * edi_116 = esi_115 - (struct Eq_94349 *) 0x01;
				if (edi_116 < (struct Eq_94201 *) 800)
				{
					if (edi_116 >= (struct Eq_94201 *) 800)
						runtime.panicindex(gs);
					Mem127[esi_115 - 0x01 + dwArg04:byte] = SLICE(ecx_114, byte, 0) + 0x30;
				}
				else if (ecx_114 != 0x00)
					*((word32) dwArg04 + 809) = 0x01;
				eax_129 = edx_110 >> 0x03;
				esi_115 = edi_116;
			}
			word32 eax_80 = Mem77[dwArg04 + 800:word32] + edx_52;
			*((word32) dwArg04 + 800) = eax_80;
			if (eax_80 >= 800)
				((word32) dwArg04 + 800)->u0 = 800;
			Mem91[dwArg04 + 0x0324:word32] = Mem86[dwArg04 + 0x0324:word32] + edx_52;
			strconv.trim(gs, dwArg04);
			esiOut = esi_115;
			return dwArg04;
		}
	}
}

// 08094330: Register word32 strconv.(*decimal).Shift(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Register out ptr32 esiOut)
// Called from:
//      strconv.bigFtoa
//      strconv.roundShortest
word32 strconv.(*decimal).Shift(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, ptr32 & esiOut)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (*((word32) dwArg04 + 800) != 0x00)
	{
		Eq_4 ecx_22 = dwArg08;
		if (dwArg08 <= 0x00)
		{
			if (dwArg08 < 0x00)
			{
				while (ecx_22 < ~0x1B)
				{
					word32 esi_148;
					strconv.rightShift(gs, dwArg04, 0x1C, out esi_148);
					ecx_22 = (word32) ecx_22 + 28;
				}
				ebx = strconv.rightShift(gs, dwArg04, -ecx_22, out esi);
			}
		}
		else
		{
			for (; ecx_22 > 0x1C; ecx_22 -= 0x1C)
			{
				word32 esi_147;
				strconv.leftShift(gs, dwArg04, 0x1C, out esi_147);
			}
			ebx = strconv.leftShift(gs, dwArg04, ecx_22, out esi);
		}
	}
	esiOut = esi;
	return ebx;
}

// 080943E0: void strconv.(*decimal).Round(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
// Called from:
//      strconv.bigFtoa
//      strconv.roundShortest
void strconv.(*decimal).Round(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (dwArg08 < 0x00)
		return;
	Eq_4 edx_22 = *((word32) dwArg04 + 800);
	if (dwArg08 >= edx_22)
		return;
	if (dwArg08 >= 800)
		runtime.panicindex(gs);
	int8 dl_38;
	byte bl_28 = Mem0[dwArg04 + dwArg08:byte];
	if (bl_28 == 0x35 && dwArg08 + 0x01 == edx_22)
	{
		if (*((word32) dwArg04 + 809) != 0x00)
			goto l08094435;
		if (dwArg08 > 0x00)
		{
			if (dwArg08 >= 0x0321)
				runtime.panicindex(gs);
			dl_38 = CONVERT((Mem0[dwArg08 - 0x01 + dwArg04:byte] + 0xD0 & 0x01) != 0x00, bool, int8);
		}
		else
			dl_38 = 0x00;
	}
	else
		dl_38 = (int8) (bl_28 >= 0x35);
	if (dl_38 == 0x00)
	{
		strconv.(*decimal).RoundDown(gs, dwArg04, dwArg08);
		return;
	}
l08094435:
	strconv.(*decimal).RoundUp(gs, dwArg04, dwArg08);
}

// 080944A0: void strconv.(*decimal).RoundDown(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
// Called from:
//      strconv.(*decimal).Round
//      strconv.roundShortest
void strconv.(*decimal).RoundDown(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (dwArg08 < 0x00 || dwArg08 >= *((word32) dwArg04 + 800))
		return;
	*((word32) dwArg04 + 800) = dwArg08;
	strconv.trim(gs, dwArg04);
}

// 080944F0: void strconv.(*decimal).RoundUp(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
// Called from:
//      strconv.(*decimal).Round
//      strconv.roundShortest
void strconv.(*decimal).RoundUp(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (dwArg08 < 0x00 || dwArg08 >= *((word32) dwArg04 + 800))
		return;
	Eq_94553 eax_24;
	for (eax_24 = dwArg08 - 0x01; eax_24 >= 0x00; --eax_24)
	{
		if (eax_24 >= 800)
			runtime.panicindex(gs);
		word32 edx_41 = CONVERT(Mem0[dwArg04 + eax_24:byte], byte, word32);
		if ((byte) edx_41 < 0x39)
		{
			Mem49[dwArg04 + eax_24:byte] = SLICE(edx_41, byte, 0) + 0x01;
			*((word32) dwArg04 + 800) = (word32) eax_24 + 1;
			return;
		}
	}
	*dwArg04 = 0x31;
	((word32) dwArg04 + 800)->u0 = 0x01;
	*((word32) dwArg04 + 804) = (word32) *((word32) dwArg04 + 804) + 1;
}

// 08094570: void strconv.(*extFloat).AssignComputeBounds(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_94598) dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C, Stack Eq_94601 dwArg10, Stack byte bArg14, Stack (ptr32 Eq_23322) dwArg18)
// Called from:
//      strconv.genericFtoa
void strconv.(*extFloat).AssignComputeBounds(struct Eq_2 * gs, struct Eq_94598 * dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C, Eq_94601 dwArg10, byte bArg14, struct Eq_23322 * dwArg18)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	dwArg04->t0000 = dwArg08;
	dwArg04->t0004 = dwArg0C;
	dwArg04->dw0008 = dwArg10 - dwArg18->dw0000;
	dwArg04->b000C = bArg14;
	int32 edi_36 = dwArg04->dw0008;
	if (edi_36 <= 0x00)
	{
		Eq_94638 ebx_44 = -edi_36;
		up32 ecx_54 = 0x20 - ebx_44;
		byte cl_61 = (byte) ebx_44;
		ui32 ebx_65 = 0x00 - (ebx_44 < 0x20);
		ui32 edx_74 = 0x00 - (ecx_54 < 0x20);
		ui32 eax_80 = 0x00 - (ebx_44 < 0x40);
		uint32 edx_84 = dwArg0C >> (byte) ebx_44 - 0x20 & eax_80 | (dwArg0C << (byte) ecx_54 & edx_74 | dwArg08 >> cl_61 & ebx_65);
		byte cl_95 = (byte) ebx_44;
		Eq_4 ebp_103 = edx_84 >> (byte) ecx_54 & edx_74 | (dwArg0C >> cl_61 & ebx_65) << cl_95 & ebx_65 | edx_84 << (byte) ebx_44 - 0x20 & eax_80;
		Eq_4 esi_119 = edx_84 << cl_95 & ebx_65;
		if (((int8) (dwArg0C == ebp_103) & (int8) (dwArg08 == esi_119)) != 0x00)
		{
			Eq_4 ebp_145 = dwArg04->t0004;
			dwArg04->t0000 = ebp_145 >> (byte) ebx_44 - 0x20 & eax_80 | (dwArg04->t0000 >> (byte) ebx_44 & ebx_65 | ebp_145 << (byte) ecx_54 & edx_74);
			dwArg04->t0004 = ebp_145 >> (byte) ebx_44 & ebx_65;
			dwArg04->dw0008 = 0x00;
			return;
		}
	}
	up32 ebp_216 = dwArg18->dw0000;
	up32 ebx_222 = 0x20 - ebp_216;
	word32 edx_200 = dwArg10 - dwArg18->dw0008;
	if (((int8) (dwArg0C != (0x01 << (byte) ebp_216 - 0x20 & 0x00 - (ebp_216 < 0x40) | 0x01 >> (byte) ebx_222 & 0x00 - (ebx_222 < 0x20))) | (int8) (dwArg08 != (0x01 << (byte) ebp_216 & 0x00 - (ebp_216 < 0x20)))) != 0x00 || edx_200 == 0x01)
		;
}

// 08094830: void strconv.(*extFloat).Normalize(Register Eq_4 ebp, Register (ptr32 Eq_94782) esi, Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_94782) dwArg04)
// Called from:
//      strconv.(*extFloat).FixedDecimal
//      strconv.(*extFloat).ShortestDecimal
void strconv.(*extFloat).Normalize(Eq_4 ebp, struct Eq_94782 * esi, struct Eq_2 * gs, struct Eq_94782 * dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 ecx_17 = dwArg04->t0004;
	int8 bl_27 = (int8) (ecx_17 == 0x00);
	Eq_4 edx_18 = dwArg04->t0000;
	Eq_4 ebx_19 = dwArg04->t0008;
	if (((int8) (edx_18 == 0x00) & bl_27) != 0x00)
		return;
	Eq_4 ecx_135;
	Eq_4 ebp_69;
	if ((bl_27 & 0x01) != 0x00)
	{
		ecx_135 = ebx_19 - 0x20;
		ebp_69.u0 = 0x00;
	}
	else
	{
		ebp_69 = edx_18;
		edx_18 = ecx_17;
		ecx_135 = ebx_19;
	}
	Eq_4 edx_128;
	Eq_4 esi_77 = edx_18;
	if (((int8) (edx_18 >> 0x10 == 0x00) & 0x01) != 0x00)
	{
		esi_77 = edx_18 << 0x10 | ebp_69 >> 0x10;
		edx_128 = ebp_69 << 0x10;
		ecx_135 = (word32) ecx_135 - 16;
	}
	else
		edx_128 = ebp_69;
	Eq_4 esi_129;
	Eq_4 ebp_100 = esi_77;
	if (((int8) (esi_77 >> 0x18 == 0x00) & 0x01) != 0x00)
	{
		ebp_100 = esi_77 << 0x08 | edx_128 >> 0x18;
		esi_129 = edx_128 << 0x08;
		ecx_135 = (word32) ecx_135 - 8;
	}
	else
		esi_129 = edx_128;
	Eq_4 ebp_166;
	Eq_4 edx_139 = ebp_100;
	if (((int8) (ebp_100 >> 0x1C == 0x00) & 0x01) != 0x00)
	{
		edx_139 = ebp_100 << 0x04 | esi_129 >> 0x1C;
		ebp_166 = esi_129 << 0x04;
		ecx_135 = (word32) ecx_135 - 4;
	}
	else
		ebp_166 = esi_129;
	Eq_4 edx_189;
	Eq_4 esi_176 = edx_139;
	if (((int8) (edx_139 >> 0x1E == 0x00) & 0x01) != 0x00)
	{
		esi_176 = edx_139 << 0x02 | ebp_166 >> 0x1E;
		edx_189 = ebp_166 << 0x02;
		ecx_135 = (word32) ecx_135 - 2;
	}
	else
		edx_189 = ebp_166;
	Eq_4 esi_228;
	Eq_4 ebp_199 = esi_176;
	if (((int8) (esi_176 >> 0x1F == 0x00) & 0x01) != 0x00)
	{
		ebp_199 = esi_176 << 0x01 | edx_189 >> 0x1F;
		esi_228 = edx_189 << 0x01;
		--ecx_135;
	}
	else
		esi_228 = edx_189;
	dwArg04->t0000 = esi_228;
	dwArg04->t0004 = ebp_199;
	dwArg04->t0008 = ecx_135;
}

// 08094990: void strconv.(*extFloat).Multiply(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_94782) dwArg04, Stack uint32 dwArg08, Stack uint32 dwArg0C, Stack word32 dwArg10)
// Called from:
//      strconv.(*extFloat).frexp10
//      strconv.frexp10Many
void strconv.(*extFloat).Multiply(struct Eq_2 * gs, struct Eq_94782 * dwArg04, uint32 dwArg08, uint32 dwArg0C, word32 dwArg10)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 eax_18 = dwArg04->t0004;
	Eq_4 esi_25 = dwArg04->t0000;
	uint64 edx_eax_22 = dwArg08 *64 eax_18;
	uint64 edx_eax_37 = dwArg0C *64 eax_18;
	uint64 edx_eax_30 = dwArg0C *64 esi_25;
	up32 edx_23 = SLICE(edx_eax_22, word32, 32);
	up32 eax_38 = (word32) edx_eax_37;
	word32 eax_26 = (word32) edx_eax_22;
	word32 eax_33 = (word32) edx_eax_30;
	up32 edx_31 = SLICE(edx_eax_30, word32, 32);
	up32 eax_41 = eax_38 + edx_23;
	up32 ebp_46 = eax_33 + eax_26;
	up32 edx_51 = SLICE(dwArg08 *64 esi_25, word32, 32);
	Eq_4 esi_83 = (bool) (eax_41 + edx_31 < 0x00) + ((bool) (eax_38 + edx_23 < 0x00) + SLICE(edx_eax_37, word32, 32));
	dwArg04->t0004 = esi_83;
	Eq_94998 eax_43 = eax_41 + edx_31;
	Eq_95000 edx_69 = SLICE(cond(eax_33 + eax_26), bool, 1) + (edx_51 + ebp_46 < 0x00) + (edx_51 + ebp_46 < 0x80000000);
	Mem86[dwArg04 + 0x00:word32] = edx_69 + eax_43;
	Mem91[dwArg04 + 0x04:word32] = esi_83 + (edx_69 + eax_43 <u 0x00);
	dwArg04->t0008 = (word32) dwArg04->t0008 + 64 + dwArg10;
}

// 08094A70: void strconv.(*extFloat).frexp10(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_94782) dwArg04)
// Called from:
//      strconv.frexp10Many
//      strconv.(*extFloat).FixedDecimal
void strconv.(*extFloat).frexp10(struct Eq_2 * gs, struct Eq_94782 * dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 edx_18 = dwArg04->t0008;
	int32 ebx_20 = -((word32) edx_18 + 46);
	Eq_95054 edx_29 = (SLICE(ebx_20 *s 0x1C *s64 0xB02C0B03, word32, 32) + ebx_20 *s 0x1C >> 0x06) - (ebx_20 *s 0x1C >> 0x1F);
	Eq_95068 edx_34 = (word32) edx_29 + ((word32) (((word32) edx_29 + 348 >> 0x1F) >> 0x1D) + 348) >> 0x03;
	while (edx_34 < 0x57)
	{
		Eq_95068 eax_83;
		word32 esi_44 = g_a813F908[edx_34];
		int32 edi_46 = (word32) edx_18 + 64 + esi_44;
		if (edi_46 < ~0x3B)
			eax_83 = (word32) edx_34 + 1;
		else
		{
			if (edi_46 <= ~0x1F)
			{
				strconv.(*extFloat).Multiply(gs, dwArg04, g_a813F900[edx_34], g_a813F904[edx_34], esi_44);
				return;
			}
			eax_83 = edx_34 - 0x01;
		}
		edx_34 = eax_83;
	}
	runtime.panicindex(gs);
}

// 08094B50: void strconv.frexp10Many(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_94782) dwArg04, Stack (ptr32 Eq_94782) dwArg08, Stack (ptr32 Eq_94782) dwArg0C)
// Called from:
//      strconv.(*extFloat).ShortestDecimal
void strconv.frexp10Many(struct Eq_2 * gs, struct Eq_94782 * dwArg04, struct Eq_94782 * dwArg08, struct Eq_94782 * dwArg0C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	strconv.(*extFloat).frexp10(gs, dwArg0C);
	if (dwLoc14 >= 0x57)
		runtime.panicindex(gs);
	else
	{
		strconv.(*extFloat).Multiply(gs, dwArg04, g_a813F900[dwLoc14], g_a813F904[dwLoc14], g_a813F908[dwLoc14]);
		strconv.(*extFloat).Multiply(gs, dwArg08, g_a813F900[dwLoc14], g_a813F904[dwLoc14], g_a813F908[dwLoc14]);
	}
}

// 08094C20: void strconv.(*extFloat).FixedDecimal(Register Eq_4 ebp, Register (ptr32 Eq_94782) esi, Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_94782) dwArg04, Stack (ptr32 Eq_95169) dwArg08, Stack Eq_4 dwArg0C)
// Called from:
//      strconv.genericFtoa
void strconv.(*extFloat).FixedDecimal(Eq_4 ebp, struct Eq_94782 * esi, struct Eq_2 * gs, struct Eq_94782 * dwArg04, struct Eq_95169 * dwArg08, Eq_4 dwArg0C)
{
	while (fp - 0x48 <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 ecx_19 = dwArg04->t0000;
	Eq_4 edx_20 = dwArg04->t0004;
	if (((int8) (edx_20 == 0x00) & (int8) (ecx_19 == 0x00)) != 0x00)
	{
		dwArg08->dw000C = 0x00;
		dwArg08->dw0010 = 0x00;
		dwArg08->t0014 = dwArg04->t000C;
		return;
	}
	if (dwArg0C == 0x00)
		runtime.gopanic(gs);
	strconv.(*extFloat).Normalize(ebp, esi, gs, dwArg04);
	strconv.(*extFloat).frexp10(gs, dwArg04);
	up32 ecx_95 = -dwArg04->t0008;
	uint32 ebx_114 = 0x20 - ecx_95;
	Eq_4 edx_97 = dwArg04->t0000;
	ui32 ebp_106 = 0x00 - (ecx_95 < 0x20);
	Eq_4 eax_99 = dwArg04->t0004;
	ui32 ecx_124 = 0x00 - (ebx_114 < 0x20);
	ui32 esi_134 = 0x00 - (ecx_95 < 0x40);
	Eq_95256 eax_137 = eax_99 << (byte) ebx_114 & ecx_124 | edx_97 >> (byte) ecx_95 & ebp_106 | eax_99 >> (byte) ecx_95 - 0x20 & esi_134;
	Eq_4 esi_166 = 0x00;
	uint32 dwLoc8C_752 = 0x00;
	Eq_95256 dwLoc90_754 = 0x01;
	while (esi_166 < 0x14)
	{
		if (((int8) (dwLoc90_754 > eax_137) & (int8) (dwLoc8C_752 == 0x00) | (int8) (dwLoc8C_752 > 0x00)) != 0x00)
			goto l08094DB0;
		esi_166 = (byte) esi_166.u0 + 1;
		dwLoc8C_752 = SLICE(dwLoc90_754 *64 0x0A, word32, 32) + dwLoc8C_752 * 0x0A;
		dwLoc90_754 *= 0x0A;
	}
	esi_166.u0 = 0x00;
l08094DB0:
	uint32 esi_241;
	ui32 ebp_239;
	Eq_95256 edx_238;
	Eq_4 dwLoc80_764 = esi_166;
	if (esi_166 > dwArg0C)
	{
		Eq_95307 esi_244 = esi_166 - dwArg0C;
		if (esi_244 >= 0x14)
			runtime.panicindex(gs);
		struct Eq_95313 * ebx_250 = esi_244 * 0x08 + 0x08138C80;
		ebp_239 = ebx_250->dw0004;
		Eq_95321 ebx_252 = ebx_250->t0000;
		if (ebx_252 == 0x00)
			runtime.panicdivide(gs);
		Eq_95256 eax_260 = (uint32) ((uint64) eax_137 /u ebx_252);
		edx_238 = eax_260;
		esi_241 = eax_137 - eax_260 *s ebx_252;
	}
	else
	{
		edx_238 = eax_137;
		ebp_239 = 0x00;
		esi_241 = 0x00;
	}
	fn0808FD88(0x00, fp - 0x20);
	struct Eq_95342 * eax_279 = (struct Eq_95342 *) 0x20;
	while (edx_238 > 0x00)
	{
		uint32 edx_695 = SLICE(edx_238 *64 ~0x33333332, word32, 32);
		edx_238 = edx_695 >> 0x03;
		uint32 edi_699 = edx_238 - ((edx_695 >> 0x03) + (edx_695 >> 0x03) * 0x04 << 0x01);
		struct Eq_95342 * ebx_700 = eax_279 - 0x01;
		if (ebx_700 >= (struct Eq_95342 *) 0x20)
			runtime.panicindex(gs);
		eax_279 - 0x01 + (fp - 0x24) = (byte *) ((byte) edi_699 + 0x30);
		eax_279 = ebx_700;
	}
	eax_293 = eax_279;
	while (true)
	{
		struct Eq_95342 * eax_293;
		if (eax_293 >= (struct Eq_95342 *) 0x20)
			break;
		Eq_4 eax_671 = eax_293 - eax_279;
		if (eax_293 >= (struct Eq_95342 *) 0x20)
		{
l08095237:
			runtime.panicindex(gs);
		}
		Eq_4 ebp_676 = dwArg04->t0000;
		word32 esi_677 = CONVERT(Mem674[fp - 0x24 + eax_293:byte], byte, word32);
		if (eax_671 >= dwArg04->t0004)
			goto l08095237;
		Mem684[ebp_676 + eax_671:byte] = SLICE(esi_677, byte, 0);
		eax_293 = (struct Eq_95342 *) ((char *) eax_293 + 1);
	}
	word64 ebx_eax_962;
	ui32 dwLoc7C_779;
	Eq_4 ebx_302 = 0x20 - eax_279;
	dwArg04->t000C = ebx_302;
	dwArg04->t0010 = dwLoc84 + dwLoc78;
	word32 ebx_314 = eax_279 - 0x20 + dwArg08;
	if (ebx_314 <= null)
	{
		dwLoc7C_779 = dwLoc70;
		ebx_eax_962 = 0x01;
		goto l080950F4;
	}
	else
	{
		if (esi_241 == 0x00)
		{
			struct Eq_95392 * ebx_354 = ebx_314;
			if (((int8) (ebp_239 != 0x00) | (int8) (dwLoc9C != 0x01)) == 0x00)
			{
				dwLoc7C_779 = dwLoc70;
				uint32 dwLocA8_787 = 0x01;
				ui32 dwLocA4_789 = 0x00;
				Eq_4 eax_398 = ebx_302;
				for (; ebx_354 > null; ebx_354 -= (struct Eq_95541 *) 0x01)
				{
					ui32 edx_525 = SLICE(dwLocA8_787 *64 0x0A, word32, 32) + dwLocA4_789 * 0x0A;
					ui32 ebp_541 = 0x01 >> (byte) ecx_124 & esi_134;
					dwLocA8_787 *= 0x0A;
					uint32 eax_529 = dwLocA8_787 * 0x0A >> 0x1F | edx_525 << 0x01;
					uint32 esi_543 = 0x01 << (byte) eax_99 & eax_137 | ebp_541;
					uint32 dwLoc80_837 = dwLoc80_764 * 0x0A;
					uint32 ebx_520 = SLICE(dwLoc80_764 *64 0x0A, word32, 32) + dwLoc7C_779 * 0x0A;
					dwLocA4_789 = edx_525;
					if (((int8) (dwLocA8_787 << 0x01 > (0x01 << (byte) ecx_95 - 0x20 & ebx_114)) & (int8) (eax_529 == esi_543) | (int8) (eax_529 > esi_543)) != 0x00)
						return;
					byte cl_610 = (byte) ecx_95 - 0x20;
					uint32 ebp_604 = ebx_520 >> (byte) eax_99 & eax_137 | (ebx_520 << (byte) ecx_124 & esi_134 | dwLoc80_837 >> (byte) ecx_95 - 0x20 & ebx_114);
					ui32 edi_612 = ebx_520 >> cl_610 & ebx_114;
					Eq_4 edi_615 = dwArg04->t0000;
					if (eax_398 >= dwArg04->t0004)
						runtime.panicindex(gs);
					Mem628[edi_615 + eax_398:byte] = SLICE(ebp_604, byte, 0) + 0x30;
					uint32 edx_622 = ebp_604 << cl_610 & ebx_114;
					dwLoc80_764 = dwLoc80_837 - edx_622;
					dwLoc7C_779 = SLICE(SEQ(ebx_520, dwLoc80_837) - SEQ((edi_612 << (byte) ecx_95 - 0x20 & ebx_114 | ebp_604 >> (byte) ecx_124 & esi_134) | ebp_604 << (byte) eax_99 & eax_137, edx_622), word32, 32);
					eax_398 = (word32) eax_398 + 1;
				}
				dwArg04->t000C = eax_398;
				ebx_eax_962 = SEQ(dwLocA4_789, dwLocA8_787);
l080950F4:
				ui32 esi_443 = esi_241 << (byte) eax_99 & eax_137 | esi_241 >> (byte) ecx_124 & esi_134 | dwLoc7C_779;
				strconv.adjustLastDigitFixed(esi_443, gs, dwArg04, SEQ(esi_443, dwLoc80_764 | esi_241 << (byte) ecx_95 - 0x20 & ebx_114), dwLoc9C, ebp_239, ecx_95 - 0x20, ebx_eax_962);
				if (bLocAC == 0x00)
					return;
				Eq_4 ecx_477;
				for (ecx_477 = dwArg04->t000C - 0x01; ecx_477 >= 0x00; --ecx_477)
				{
					Eq_4 edx_485 = dwArg04->t0000;
					if (ecx_477 >= dwArg04->t0004)
						runtime.panicindex(gs);
					if (Mem454[edx_485 + ecx_477:byte] != 0x30)
					{
						dwArg04->t000C = (word32) ecx_477 + 1;
						return;
					}
				}
				return;
			}
		}
		runtime.gopanic(gs);
	}
}

// 08095280: void strconv.adjustLastDigitFixed(Register ui32 esi, Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_94782) dwArg04, Stack ui64 qwArg08, Stack uint32 dwArg10, Stack ui32 dwArg14, Stack up32 dwArg18, Stack word64 qwArg1C)
// Called from:
//      strconv.(*extFloat).FixedDecimal
void strconv.adjustLastDigitFixed(ui32 esi, struct Eq_2 * gs, struct Eq_94782 * dwArg04, ui64 qwArg08, uint32 dwArg10, ui32 dwArg14, up32 dwArg18, word64 qwArg1C)
{
	uint32 dwArg08 = (word32) qwArg08;
	uint32 dwArg0C = SLICE(qwArg08, word32, 32);
	ui32 dwArg20 = SLICE(qwArg1C, word32, 32);
	uint32 dwArg1C = (word32) qwArg1C;
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	ui32 ebx_24 = 0x00 - (dwArg18 < 0x20);
	up32 ecx_48 = 0x20 - dwArg18;
	ui32 ebp_47 = 0x00 - (dwArg18 < 0x40) & dwArg10 << (byte) dwArg18 - 0x20;
	uint32 eax_25 = dwArg10 << (byte) dwArg18 & ebx_24;
	uint32 edx_62 = dwArg10 >> (byte) ecx_48 & 0x00 - (ecx_48 < 0x20) | dwArg14 << (byte) dwArg18 & ebx_24 | ebp_47;
	if (((int8) (dwArg0C > edx_62) | (int8) (dwArg0C == edx_62) & (int8) (dwArg08 > eax_25)) != 0x00)
		runtime.gopanic(gs);
	else
	{
		uint32 esi_120 = dwArg1C >> 0x1F | dwArg20 << 0x01;
		if (((int8) (dwArg1C << 0x01 > eax_25) & (int8) (esi_120 == edx_62) | (int8) (esi_120 > edx_62)) != 0x00)
			runtime.gopanic(gs);
		else
		{
			ui64 edi_ebx_324 = qwArg08 + qwArg1C;
			uint32 ebx_174 = (word32) edi_ebx_324;
			uint32 ebx_182 = ebx_174 >> 0x1F | SLICE(edi_ebx_324, word32, 32) << 0x01;
			if (((int8) (ebx_182 == edx_62) & (int8) (ebx_174 << 0x01 < eax_25) | (int8) (ebx_182 < edx_62)) != 0x00)
				return;
			ui64 ecx_esi_327 = qwArg08 - qwArg1C;
			ui32 ecx_232 = SLICE(ecx_esi_327, word32, 32);
			uint32 esi_227 = (word32) ecx_esi_327;
			uint32 esi_236 = esi_227 >> 0x1F | ecx_232 << 0x01;
			if (((int8) (esi_227 << 0x01 > eax_25) & (int8) (esi_236 == edx_62) | (int8) (esi_236 > edx_62)) == 0x00)
				return;
			Eq_4 ecx_263 = dwArg04->t000C - 0x01;
			while (true)
			{
				bool v59_328 = ecx_263 >= 0x00;
				if (ecx_263 < 0x00)
					break;
				Eq_4 edx_271 = dwArg04->t0000;
				if (ecx_263 >= dwArg04->t0004)
					runtime.panicindex(gs);
				if (Mem270[ecx_263 + edx_271:byte] != 0x39)
				{
					v59_328 = ecx_263 >= 0x00;
					break;
				}
				--dwArg04->t000C;
				ecx_263 -= (byte *) 0x01;
			}
			if (v59_328)
			{
				Eq_4 eax_292 = dwArg04->t0000;
				if (ecx_263 >= dwArg04->t0004)
					runtime.panicindex(gs);
				else
					Mem301[eax_292 + ecx_263:byte] = Mem270[ecx_263 + eax_292:byte] + 0x01;
			}
			else
			{
				Eq_4 edx_303 = dwArg04->t0000;
				if (dwArg04->t0004 <= 0x00)
					runtime.panicindex(gs);
				else
				{
					*edx_303 = 0x31;
					dwArg04->t000C.u0 = 0x01;
					dwArg04->t0010 = (word32) dwArg04->t0010 + 1;
				}
			}
		}
	}
}

// 08095480: void strconv.(*extFloat).ShortestDecimal(Register word32 ebp, Register Eq_4 esi, Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_95842) dwArg00, Stack (ptr32 Eq_94782) dwArg04, Stack (ptr32 Eq_95844) dwArg08, Stack (ptr32 Eq_94782) dwArg0C, Stack (ptr32 Eq_94782) dwArg10)
// Called from:
//      strconv.genericFtoa
void strconv.(*extFloat).ShortestDecimal(word32 ebp, Eq_4 esi, struct Eq_2 * gs, struct Eq_95842 * dwArg00, struct Eq_94782 * dwArg04, struct Eq_95844 * dwArg08, struct Eq_94782 * dwArg0C, struct Eq_94782 * dwArg10)
{
	while (fp - 0x70 <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 edx_19 = dwArg04->t0000;
	Eq_4 ebx_20 = dwArg04->t0004;
	if (((int8) (ebx_20 == 0x00) & (int8) (edx_19 == 0x00)) != 0x00)
	{
		dwArg08->t000C.u0 = 0x00;
		dwArg08->dw0010 = 0x00;
		dwArg08->t0014 = dwArg04->t000C;
	}
	else
	{
		Eq_4 ebp_116 = dwArg04->t0008;
		if (ebp_116 == 0x00)
		{
			Eq_4 ecx_74 = dwArg0C->t0004;
			ebp_116 = dwArg0C->t0000;
			if (((int8) (ecx_74 == ebx_20) & (int8) (ebp_116 == edx_19)) != 0x00)
			{
				Eq_4 edx_93 = dwArg0C->t0008;
				if (edx_93 == ebp_116)
				{
					Eq_4 bl_103 = dwArg0C->t000C;
					if (dwArg04->t000C == bl_103)
					{
						Eq_4 ebx_112 = dwArg10->t0000;
						ebp_116 = dwArg10->t0004;
						if (((int8) (ebp_116 == ecx_74) & (int8) (ebx_112 == ebp_116)) != 0x00 && (dwArg10->t0008 == edx_93 && dwArg10->t000C == bl_103))
						{
							fn0808FD8A(0x00, fp - 0x1C);
							Eq_4 edx_1127 = dwArg00->t0000;
							Eq_4 ebx_1128 = dwArg00->t0004;
							byte * eax_1004 = (byte *) 0x17;
							while (((int8) (ebx_1128 == 0x00) & (int8) (edx_1127 > 0x00) | (int8) (ebx_1128 > 0x00)) != 0x00)
							{
								runtime.uint64div(gs, edx_1127, ebx_1128, 0x0A, 0x00);
								byte dl_1122 = (byte) edx_1127 - (byte) dwLocE4 * 0x0A + 0x30;
								if (eax_1004 >= (byte *) 0x18)
									runtime.panicindex(gs);
								eax_1004[fp - 0x20] = dl_1122;
								edx_1127 = dwLocE4;
								ebx_1128 = dwLocE0;
								eax_1004 -= (byte *) 0x01;
							}
							Eq_4 edx_1015 = 0x17 - eax_1004;
							Eq_4 ebp_1019;
							for (ebp_1019 = 0x00; ebp_1019 < edx_1015; ++ebp_1019)
							{
								word32 edi_1071 = eax_1004 + ebp_1019;
								if (eax_1004 + 0x01 + ebp_1019 >=u 0x18)
								{
l08095F89:
									runtime.panicindex(gs);
								}
								Eq_4 ecx_1076 = dwArg04->t0000;
								word32 edi_1078 = CONVERT(Mem1074[edi_1071 + 0x01 + (fp - 0x20):byte], byte, word32);
								if (ebp_1019 >= dwArg04->t0004)
									goto l08095F89;
								Mem1085[ecx_1076 + ebp_1019:byte] = SLICE(edi_1078, byte, 0);
							}
							dwArg04->t000C = edx_1015;
							dwArg04->t0010 = edx_1015;
							while (true)
							{
								Eq_4 eax_1031 = dwArg04->t000C;
								if (eax_1031 <= 0x00)
									break;
								Eq_4 edx_1034 = dwArg04->t0000;
								if (eax_1031 - (byte *) 0x01 >= dwArg04->t0004)
									runtime.panicindex(gs);
								if (Mem1030[eax_1031 - 0x01 + edx_1034:byte] != 0x30)
									break;
								dwArg04->t000C = eax_1031 - (byte *) 0x01;
							}
							if (eax_1031 == 0x00)
								dwArg04->t0010.u0 = 0x00;
							dwArg04->b0014 = dwArg00->b000C;
							return;
						}
					}
				}
			}
		}
		strconv.(*extFloat).Normalize(ebp_116, dwArg10, gs, dwArg10);
		Eq_4 ecx_154 = dwArg04->t0008;
		Eq_4 ebx_156 = dwArg10->t0008;
		if (ecx_154 > ebx_156)
		{
			Eq_96024 ecx_162 = ecx_154 - ebx_156;
			Eq_4 ebp_159 = dwArg04->t0000;
			ui32 edi_169 = 0x00 - (ecx_162 < 0x20);
			Eq_4 esi_161 = dwArg04->t0004;
			dwArg04->t0000 = ebp_159 << (byte) ecx_162 & edi_169;
			up32 ebx_177 = 0x20 - ecx_162;
			dwArg04->t0004 = ebp_159 << (byte) ecx_162 - 0x20 & 0x00 - (ecx_162 < 0x40) | (esi_161 << (byte) ecx_162 & edi_169 | ebp_159 >> (byte) ebx_177 & 0x00 - (ebx_177 < 0x20));
			dwArg04->t0008 = dwArg10->t0008;
		}
		Eq_4 ecx_210 = dwArg0C->t0008;
		Eq_4 ebp_212 = dwArg10->t0008;
		if (ecx_210 > ebp_212)
		{
			Eq_96078 ecx_219 = ecx_210 - ebp_212;
			Eq_4 edi_217 = dwArg0C->t0000;
			ui32 eax_226 = 0x00 - (ecx_219 < 0x20);
			Eq_4 esi_216 = dwArg0C->t0004;
			dwArg0C->t0000 = edi_217 << (byte) ecx_219 & eax_226;
			up32 ecx_233 = 0x20 - ecx_219;
			dwArg0C->t0004 = edi_217 << (byte) ecx_219 - 0x20 & 0x00 - (ecx_219 < 0x40) | (edi_217 >> (byte) ecx_233 & 0x00 - (ecx_233 < 0x20) | esi_216 << (byte) ecx_219 & eax_226);
			dwArg0C->t0008 = dwArg10->t0008;
		}
		strconv.frexp10Many(gs, dwArg0C, dwArg04, dwArg10);
		Eq_4 ecx_280 = dwArg10->t0000;
		Eq_4 ebx_285 = dwArg10->t0004;
		dwArg10->t0000 = (word32) ecx_280 + 1;
		Mem289[dwArg10 + 0x04:word32] = ebx_285 + (ecx_280 <u 0x01);
		Eq_4 ebx_291 = dwArg0C->t0000;
		Eq_4 ebp_295 = dwArg0C->t0004;
		dwArg0C->t0000 = (word32) ebx_291 - 1;
		Eq_4 ebp_298 = (bool) (ebx_291 < ~0x00) + ((word32) ebp_295 - 1);
		dwArg0C->t0004 = ebp_298;
		up32 ecx_302 = -dwArg10->t0008;
		up32 ebx_319 = 0x20 - ecx_302;
		Eq_4 esi_304 = dwArg10->t0004;
		Eq_4 eax_306 = dwArg10->t0000;
		ui32 ebx_331 = 0x00 - (ecx_302 < 0x20);
		ui32 ecx_336 = 0x00 - (ebx_319 < 0x20);
		ui32 eax_343 = 0x00 - (ecx_302 < 0x40);
		uint32 esi_345 = esi_304 >> (byte) ecx_302 - 0x20 & eax_343 | (esi_304 << (byte) ebx_319 & ecx_336 | eax_306 >> (byte) ecx_302 & ebx_331);
		uint32 esi_351 = esi_345 << (byte) ecx_302 & ebx_331;
		uint32 ebx_353 = eax_306 - esi_351;
		Eq_4 ebp_360 = dwArg04->t0000;
		uint32 dwLoc90_1200 = ebx_353;
		Eq_96301 ebx_357 = eax_306 - ((word32) ebx_291 - 1);
		Eq_96304 ebx_362 = eax_306 - ebp_360;
		Eq_96306 ebx_381 = SLICE(SEQ(esi_304, eax_306) - SEQ(esi_345 << (byte) ecx_302 - 0x20 & eax_343 | esi_345 >> (byte) ebx_319 & ecx_336, esi_351), word32, 32);
		Eq_96320 esi_390 = SLICE(SEQ(esi_304, eax_306) - SEQ(ebp_298, (word32) ebx_291 - 1), word32, 32);
		Eq_96326 ebx_398 = SLICE(SEQ(esi_304, eax_306) - SEQ(dwArg04->t0004, ebp_360), word32, 32);
		Eq_95878 ebp_401 = 0x00;
		uint32 esi_402 = 0x01;
		uint32 dwLocAC_1207 = 0x00;
		while (ebp_401 < 0x14)
		{
			if (((int8) (esi_402 > esi_345) & (int8) (dwLocAC_1207 == 0x00) | (int8) (dwLocAC_1207 > 0x00)) != 0x00)
				goto l080959BB;
			uint64 edx_eax_460 = esi_402 *64 0x0A;
			ebp_401 = (word32) ebp_401.u0 + 1;
			esi_402 = (word32) edx_eax_460;
			dwLocAC_1207 = SLICE(edx_eax_460, word32, 32) + dwLocAC_1207 * 0x0A;
		}
		ebp_401.u0 = 0x00;
l080959BB:
		Eq_95878 dwLoc94_1223 = 0x00;
		uint32 dwLoc98_1226 = esi_345;
		while (dwLoc94_1223 < ebp_401)
		{
			Eq_96359 ebp_769 = ebp_401 - dwLoc94_1223;
			if (ebp_769 >= 0x15)
				runtime.panicindex(gs);
			struct Eq_96365 * ebp_775 = ebp_769 * 0x08 + 0x08138C78;
			ui32 edx_776 = ebp_775->dw0004;
			Eq_96374 ebp_777 = ebp_775->t0000;
			if (ebp_777 == 0x00)
				runtime.panicdivide(gs);
			Eq_96382 eax_786 = (uint32) ((uint64) dwLoc98_1226 /u ebp_777);
			byte * edi_788 = dwArg08->ptr0000;
			if (dwLoc94_1223 >= dwArg08->t0004)
				runtime.panicindex(gs);
			uint32 ebp_796 = dwLoc98_1226 - eax_786 *s ebp_777;
			Mem811[edi_788 + dwLoc94_1223:byte] = SLICE(eax_786, byte, 0) + 0x30;
			uint32 ebp_804 = ebp_796 << (byte) ecx_302 & ebx_331;
			Eq_96320 edi_830 = SLICE(SEQ(ebp_796 << (byte) ecx_302 - 0x20 & eax_343 | ebp_796 >> (byte) ebx_319 & ecx_336, ebp_804) + SEQ(ebx_381, ebx_353), word32, 32);
			Eq_96301 ebp_807 = ebp_804 + ebx_353;
			dwLoc98_1226 = ebp_796;
			if (((int8) (ebp_807 < ebx_357) & (int8) (edi_830 == esi_390) | (int8) (edi_830 < esi_390)) != 0x00)
			{
				dwArg08->t000C = (word32) dwLoc94_1223 + 1;
				Mem886[dwArg08 + 0x10:word32] = ebp_401 + dwLocE4;
				dwArg08->t0014 = dwArg04->t000C;
				strconv.adjustLastDigit(ebx_331, gs, dwArg08, SEQ(edi_830, ebp_807), ebx_362, ebx_398, SEQ(esi_390, ebx_357), SEQ(ebp_777 << (byte) ecx_302 - 0x20 & eax_343 | (ebp_777 >> (byte) ebx_319 & ecx_336 | edx_776 << (byte) ecx_302 & ebx_331), ebp_777 << (byte) ecx_302 & ebx_331), 0x02);
				return;
			}
			dwLoc94_1223 = (word32) dwLoc94_1223 + 1;
		}
		dwArg08->t000C = ebp_401;
		Mem506[dwArg08 + 0x10:word32] = ebp_401 + dwLocE4;
		dwArg08->t0014 = dwArg04->t000C;
		Eq_96306 dwLoc8C_1235 = ebx_381;
		int32 dwLocA0_1237 = 0x00;
		Eq_96353 dwLocA4_1239 = 0x01;
		byte cl_1132 = (byte) ecx_302 - 0x20;
		while (true)
		{
			int32 edx_554 = SLICE(dwLocA4_1239 *64 0x0A, word32, 32) + dwLocA0_1237 * 0x0A;
			uint32 ebx_549 = SLICE(dwLoc90_1200 *64 0x0A, word32, 32) + dwLoc8C_1235 * 0x0A;
			uint32 dwLoc90_1242 = dwLoc90_1200 * 0x0A;
			byte cl_565 = (byte) ecx_302;
			dwLocA0_1237 = edx_554;
			Eq_96501 ebx_574 = ebx_549 >> cl_1132 & eax_343 | (ebx_549 << (byte) ebx_319 & ecx_336 | dwLoc90_1242 >> cl_565 & ebx_331);
			byte * edx_576 = dwArg08->ptr0000;
			Eq_95878 ebp_578 = dwArg08->t000C;
			if (ebp_578 >= dwArg08->t0004)
				break;
			Mem599[edx_576 + ebp_578:byte] = SLICE(ebx_574, byte, 0) + 0x30;
			dwArg08->t000C = (word32) dwArg08->t000C + 1;
			dwLocA4_1239 *= 0x0A;
			uint32 ebx_588 = ebx_574 << cl_565 & ebx_331;
			byte cl_615 = (byte) ecx_302;
			uint64 edx_eax_593 = ebx_357 *64 (dwLocA4_1239 * 0x0A);
			int32 ebp_633 = esi_390 *s dwLocA4_1239;
			Eq_96306 ebx_630 = SLICE(SEQ(ebx_549, dwLoc90_1242) - SEQ(((ebx_574 >> 0x1F) << cl_615 & ebx_331 | ebx_574 >> (byte) ebx_319 & ecx_336) | ebx_574 << (byte) ecx_302 - 0x20 & eax_343, ebx_588), word32, 32);
			Eq_96306 edx_639 = ebx_357 *s edx_554 + SLICE(edx_eax_593, word32, 32) + ebp_633;
			uint32 esi_590 = dwLoc90_1242 - ebx_588;
			uint32 eax_652 = (word32) edx_eax_593;
			if (((int8) (esi_590 < eax_652) & (int8) (ebx_630 == edx_639) | (int8) (ebx_630 < edx_639)) != 0x00)
			{
				uint64 edx_eax_705 = ebx_362 *64 dwLocA4_1239;
				ui32 ebp_739 = 0x01 >> (byte) ebx_319 & ecx_336;
				strconv.adjustLastDigit(ebp_739, gs, dwArg08, SEQ(ebx_630, esi_590), (word32) edx_eax_705, SLICE(edx_eax_705, word32, 32) + ebx_398 *s dwLocA4_1239 + ebx_362 *s edx_554, SEQ(edx_639, eax_652), SEQ(0x01 << (byte) ecx_302 - 0x20 & eax_343 | ebp_739, 0x01 << cl_615 & ebx_331), SEQ(dwLocA4_1239 >> 0x1F | edx_554 << 0x01, dwLocA4_1239 << 0x01));
				return;
			}
			dwLoc8C_1235 = ebx_630;
			dwLoc90_1200 = esi_590;
			cl_1132 = (byte) ecx_302 - 0x20;
		}
		runtime.panicindex(gs);
	}
}

// 08095FB0: void strconv.adjustLastDigit(Register ui32 ebp, Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_95844) dwArg04, Stack word64 qwArg08, Stack Eq_96304 dwArg10, Stack Eq_96326 dwArg14, Stack word64 qwArg18, Stack ui64 qwArg20, Stack ui64 qwArg28)
// Called from:
//      strconv.(*extFloat).ShortestDecimal
void strconv.adjustLastDigit(ui32 ebp, struct Eq_2 * gs, struct Eq_95844 * dwArg04, word64 qwArg08, Eq_96304 dwArg10, Eq_96326 dwArg14, word64 qwArg18, ui64 qwArg20, ui64 qwArg28)
{
	uint32 dwArg2C = SLICE(qwArg28, word32, 32);
	uint32 dwArg28 = (word32) qwArg28;
	uint32 dwArg24 = SLICE(qwArg20, word32, 32);
	uint32 dwArg20 = (word32) qwArg20;
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	uint32 edx_23 = dwArg28 >> 0x1F | dwArg2C << 0x01;
	if (((int8) (dwArg24 < edx_23) | (int8) (dwArg20 < dwArg28 << 0x01) & (int8) (dwArg24 == edx_23)) != 0x00)
		return;
	word64 qwArg08_403 = qwArg08;
	while (true)
	{
		uint32 dwArg08_327 = (word32) qwArg08_403;
		uint32 eax_67 = dwArg24 << 0x1F | dwArg20 >> 0x01;
		uint32 eax_71 = eax_67 + dwArg08_327;
		uint32 dwArg0C_332 = SLICE(qwArg08_403, word32, 32);
		uint64 ebp_eax_295 = SEQ((dwArg24 >> 0x01) + dwArg0C_332 + (eax_67 + dwArg08_327 < 0x00), eax_71) + qwArg28;
		Eq_96326 ebp_90 = SLICE(ebp_eax_295, word32, 32);
		Eq_96304 eax_74 = eax_71 + dwArg28;
		ui24 ebx_24_8_144 = SLICE(dwArg10, word24, 8);
		if (((int8) (eax_74 < dwArg10) & (int8) (ebp_90 == dwArg14) | (int8) (ebp_90 < dwArg14)) == 0x00)
			break;
		byte * ecx_262 = dwArg04->ptr0000;
		Eq_95878 eax_264 = dwArg04->t000C;
		if (eax_264 - 0x01 >= dwArg04->t0004)
			runtime.panicindex(gs);
		Mem274[eax_264 - 0x01 + ecx_262:byte] = Mem78[eax_264 - 0x01 + ecx_262:byte] - 0x01;
		qwArg08_403 = SEQ(SLICE(qwArg08_403 + qwArg20, word32, 32), dwArg08_327 + dwArg20);
	}
	uint32 ebp_118 = (word32) dwArg10.u1 + eax_67;
	up32 ecx_126 = SLICE(qwArg20 + qwArg08_403, word32, 32);
	up32 edx_138 = SLICE(SEQ(SLICE(SEQ(dwArg14, eax_67) + SEQ(dwArg24 >> 0x01, dwArg10), word32, 32), ebp_118) + qwArg28, word32, 32);
	uint32 ebp_120 = ebp_118 + dwArg28;
	ui32 ebp_161 = SEQ(SLICE(ebp_120, word24, 8), (int8) (dwArg08_327 + dwArg20 <= ebp_120)) & SEQ(ebx_24_8_144, (int8) (ecx_126 == edx_138)) | SEQ(SLICE(ecx_126, word24, 8), (int8) (ecx_126 < edx_138));
	if ((byte) ebp_161 != 0x00)
		return;
	if (((int8) (dwArg08_327 < dwArg28) & (int8) (dwArg0C_332 == dwArg2C) | (int8) (dwArg0C_332 < dwArg2C)) != 0x00)
		return;
	ui64 ebp_edx_310 = qwArg18 - qwArg28;
	uint32 edx_210 = (word32) ebp_edx_310;
	uint32 ebp_214 = SLICE(ebp_edx_310, word32, 32);
	if (((int8) (dwArg0C_332 == ebp_214) & (int8) (dwArg08_327 > edx_210) | (int8) (dwArg0C_332 > ebp_214)) != 0x00)
		return;
	if (dwArg04->t000C != 0x01)
		return;
	byte * edx_241 = dwArg04->ptr0000;
	if (dwArg04->t0004 <= 0x00)
		runtime.panicindex(gs);
	else if (*edx_241 == 0x30)
	{
		dwArg04->t000C.u0 = 0x00;
		dwArg04->dw0010 = 0x00;
	}
}

// 080961D0: void strconv.AppendFloat(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C, Stack real64 rArg10, Stack byte bArg18, Stack Eq_4 dwArg20)
// Called from:
//      fmt.(*fmt).fmt_float
void strconv.AppendFloat(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C, real64 rArg10, byte bArg18, Eq_4 dwArg20)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	strconv.genericFtoa(gs, dwArg04, dwArg08, dwArg0C, (real64) (uint128) rArg10, SEQ(nLoc17, (byte) (word32) bArg18), dwArg20);
}

// 08096250: void strconv.genericFtoa(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C, Stack real64 rArg10, Stack Eq_4 dwArg18, Stack Eq_4 dwArg20)
// Called from:
//      strconv.AppendFloat
void strconv.genericFtoa(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C, real64 rArg10, Eq_4 dwArg18, Eq_4 dwArg20)
{
	Eq_4 bArg18 = (byte) dwArg18;
	while (fp - 0xAC <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	struct Eq_23322 * ecx_43;
	Eq_94601 edx_41;
	uint32 eax_42;
	if (dwArg20 == 0x20)
	{
		Eq_94601 v11_45 = (real32) (real64) (uint128) rArg10;
		rLocE0 = v11_45;
		edx_41 = v11_45;
		eax_42 = 0x00;
		ecx_43 = &g_t8136118;
	}
	else
	{
		if (dwArg20 != 0x40)
			runtime.gopanic(gs);
		real64 rLocA4_909 = (real64) (uint128) rArg10;
		edx_41 = (word32) rLocA4_909;
		eax_42 = SLICE(rLocA4_909, word32, 32);
		ecx_43 = &g_t8136128;
	}
	up32 ebx_59 = ecx_43->dw0000;
	up32 edx_75 = ecx_43->dw0004;
	up32 edx_79 = edx_75 + ebx_59;
	up32 ebp_77 = edx_75 - 0x20 + ebx_59;
	ui32 ebx_85 = 0x00 - (edx_79 < 0x20);
	up32 ebx_90 = -ebp_77;
	up32 ecx_141 = 0x20 - ebx_59;
	ui32 ebp_63 = 0x00 - (ebx_59 < 0x20);
	ui32 ebx_138 = 0x00 - (ebx_59 < 0x40);
	ui32 edx_154 = 0x00 - (ecx_141 < 0x20);
	uint32 edx_71 = 0x01 << (byte) ebx_59 & ebp_63;
	ui32 edx_190 = 0x01 >> (byte) ecx_141 & edx_154 | 0x01 << (byte) ebx_59 - 0x20 & ebx_138;
	ui32 ebx_112 = 0x00 - (ebp_77 < 0x20) & eax_42 >> (byte) ebp_77 | (edx_41 >> (byte) edx_79 & ebx_85 | eax_42 << (byte) ebx_90 & 0x00 - (ebx_90 < 0x20));
	ui32 ebx_160 = edx_41 >> (byte) ebx_59 & ebp_63 | eax_42 << (byte) ecx_141 & edx_154 | eax_42 >> (byte) ebx_59 - 0x20 & ebx_138;
	ui32 ebp_171 = 0x01 << (byte) edx_75 & 0x00 - (edx_75 < 0x20);
	ui32 edx_196 = edx_190 + ~0x00 + (edx_71 < ~0x00);
	byte al_236 = (int8) ((ebx_85 & eax_42 >> (byte) edx_79) != 0x00) | (int8) (ebx_112 != 0x00);
	Eq_4 edx_174 = ebp_171 - 0x01 & ebx_160;
	Eq_4 ebx_198 = eax_42 & edx_196;
	Eq_4 edi_201 = edx_41 & edx_71 + ~0x00;
	if (edx_174 == ebp_171 - 0x01)
	{
		Eq_4 ecx_801;
		Eq_4 eax_800;
		if (((int8) ((edx_71 + ~0x00 & edx_41) != 0x00) | (int8) ((edx_196 & eax_42) != 0x00)) != 0x00)
		{
			eax_800.u0 = 0x03;
			ecx_801.u0 = 0x080E0E52;
		}
		else if (al_236 != 0x00)
		{
			eax_800.u0 = 0x04;
			ecx_801.u0 = 0x080E0EBE;
		}
		else
		{
			eax_800.u0 = 0x04;
			ecx_801.u0 = 0x080E0EB6;
		}
		Eq_4 esi_847;
		word32 ebx_810 = dwArg08 + eax_800;
		Eq_4 ebp_812 = dwArg0C;
		if (ebx_810 <= dwArg0C)
			esi_847 = dwArg04;
		else
		{
			word128 xmm1_1462;
			word128 xmm0_1461;
			word32 esi_1460;
			runtime.growslice(gs, 0x080CF320, dwArg04, dwArg08, dwArg0C, ebx_810, out esi_1460, out xmm0_1461, out xmm1_1462);
			ebp_812 = dwLoc0110;
			esi_847 = dwLoc0118;
		}
		if (ebx_810 > ebp_812)
			runtime.panicslice(gs);
		else
		{
			word128 xmm0_1466;
			word128 xmm1_1467;
			word128 xmm2_1468;
			word32 edi_1465;
			word32 ebp_1463;
			word32 esi_1464;
			runtime.memmove(dwArg08 + esi_847, ecx_801, eax_800, out ebp_1463, out esi_1464, out edi_1465, out xmm0_1466, out xmm1_1467, out xmm2_1468);
			return;
		}
	}
	Eq_4 edx_213;
	if ((ebx_160 & ebp_171 - 0x01) == 0x00)
		edx_213 = ebx_198;
	else
	{
		edi_201 |= edx_71;
		edx_213 = ebx_198 | edx_190;
	}
	Eq_4 bl_226 = bArg18;
	byte bArg18_1204 = (byte) dwArg18;
	if (bArg18 == 0x62)
	{
		strconv.fmtB(edx_174, ecx_43, gs, dwArg04, dwArg08, dwArg0C, al_236, edi_201, edx_213);
		return;
	}
	if (g_b8136001 == 0x00)
	{
		strconv.bigFtoa(gs, edi_201, edx_213);
		return;
	}
	Eq_4 al_432;
	fn0808FD8A(0x00, fp - 0x18);
	Eq_4 ecx_343 = dwArg18;
	Eq_4 edi_346 = edx_213;
	if (dwArg18 >= 0x00)
	{
		if (bArg18 == 0x66)
		{
			al_432.u0 = 0x00;
			goto l080965AF;
		}
		Eq_4 ebp_552;
		if (bArg18 <= 0x47)
		{
			if (bArg18 == 0x45)
			{
l080965A1:
				ebp_552 = (word32) dwArg18 + 1;
				goto l080965A4;
			}
			if (bArg18 == 0x47)
			{
l0809677B:
				if (dwArg18 == 0x00)
					ecx_343.u0 = 0x01;
				ebp_552 = ecx_343;
l080965A4:
				if (ebp_552 > 0x0F)
					al_432.u0 = 0x00;
				else
				{
					fn0808FD8A(0x00, fp - 0x60);
					strconv.(*extFloat).FixedDecimal(ebp_552, fp - 0x20, gs, fp - 0x84, fp - 0x20, ebp_552);
					Eq_4 esp_623 = <invalid>;
					dwLoc0130 = fp - 0x20;
					al_432 = *((word32) esp_623 + 0x0C);
					bl_226 = *((word32) esp_623 + 0x0144);
					edi_346 = *((word32) esp_623 + 72);
				}
l080965AF:
				if (al_432 == 0x00)
				{
					strconv.bigFtoa(gs, edi_201, edi_346);
					return;
				}
				else
				{
					fn08090264(fp - 0x18, fp - 0x011C);
					strconv.formatDigits(gs, dwLoc0130, dwArg04, dwArg08, (byte) dwArg0C, SLICE(dwArg0C, byte, 8), dwLoc0114, dwLoc0110, dwLoc010C, dwArg18, bl_226);
					return;
				}
			}
		}
		else
		{
			if (bArg18 == 101)
				goto l080965A1;
			if (bArg18 == 0x67)
				goto l0809677B;
		}
		ebp_552 = dwArg18;
		goto l080965A4;
	}
	strconv.(*extFloat).AssignComputeBounds(gs, fp - 0x70, edi_201, edx_213, rLocE0, bLocF1, ecx_43);
	fn0808FD88(0x00, fp - 0x48);
	strconv.(*extFloat).ShortestDecimal(dwLoc0104, dwLoc0118, gs, dwLoc0138, fp - 116, fp - 0x20, fp - 0x94, fp - 0xA4);
	dwLoc0130 = fp - 0x20;
	al_432 = (byte) ecx_43;
	if (al_432 == 0x00)
	{
		strconv.bigFtoa(gs, edi_201, edx_213);
		return;
	}
	word32 ecx_485 = (word32) bArg18_1204;
	cu8 cl_486 = (byte) ecx_485;
	if (cl_486 <= 0x47)
	{
		if (cl_486 == 0x45)
		{
l080968E0:
			goto l080968EC;
		}
		if (cl_486 == 0x47)
			goto l0809690E;
	}
	else
	{
		if (cl_486 == 101)
			goto l080968E0;
		if (cl_486 == 0x66)
		{
l080968EC:
			bl_226 = (byte) ecx_485;
			edi_346 = edx_213;
			goto l080965AF;
		}
		if (cl_486 == 0x67)
		{
l0809690E:
			goto l080968EC;
		}
	}
	goto l080968EC;
}

// 08096B20: void strconv.bigFtoa(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg18, Stack Eq_4 dwArg1C)
// Called from:
//      strconv.genericFtoa
void strconv.bigFtoa(struct Eq_2 * gs, Eq_4 dwArg18, Eq_4 dwArg1C)
{
	while (fp - 772 <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	word32 * edi_18 = fp - 0x0344;
	word32 ecx_19;
	for (ecx_19 = 0xCB; ecx_19 != 0x00; --ecx_19)
	{
		*edi_18 = 0x00;
		++edi_18;
	}
	Eq_4 edx_147;
	strconv.(*decimal).Assign(SLICE(dwArg18, word24, 8), dwArg1C, gs, dwLoc0388, fp - 0x0344, dwArg18);
	Eq_4 esp_37 = <invalid>;
	*((word32) esp_37 + 4) = *((word32) esp_37 + 932) - *(*((word32) esp_37 + 936));
	*esp_37 = (word32) esp_37 + 64;
	word32 esi_56;
	word24 ebx_24_8_83 = SLICE(strconv.(*decimal).Shift(gs, *esp_37, *((word32) esp_37 + 4), out esi_56), word24, 8);
	fn0808FD8A(0x00, (word32) esp_37 + 876);
	Eq_4 eax_171 = *((word32) esp_37 + 912);
	((word32) esp_37 + 59)->u0 = (int8) (eax_171 < 0x00);
	if (eax_171 >= 0x00)
	{
		cu8 cl_149 = *((word32) esp_37 + 916);
		if (cl_149 <= 0x47)
		{
			if (cl_149 == 0x45)
			{
l08096BD2:
				*((word32) esp_37 - 4) = (word32) esp_37 + 60;
				*esp_37 = (word32) eax_171 + 1;
				strconv.(*decimal).Round(gs, *((word32) esp_37 - 4), *esp_37);
				eax_171 = *((word32) esp_37 + 912);
				goto l08096BEC;
			}
			if (cl_149 == 0x47)
				goto l08096CC8;
		}
		else
		{
			if (cl_149 == 101)
				goto l08096BD2;
			if (cl_149 == 0x66)
			{
				Mem159[esp_37 + 0x00:word32] = Mem72[esp_37 + 0x0360:word32] + eax_171;
				*((word32) esp_37 - 4) = (word32) esp_37 + 60;
				strconv.(*decimal).Round(gs, *((word32) esp_37 - 4), *esp_37);
				eax_171 = *((word32) esp_37 + 912);
				goto l08096BEC;
			}
			if (cl_149 == 0x67)
			{
l08096CC8:
				if (eax_171 == 0x00)
					eax_171.u0 = 0x01;
				*((word32) esp_37 + 912) = eax_171;
				*((word32) esp_37 - 4) = (word32) esp_37 + 60;
				*esp_37 = eax_171;
				strconv.(*decimal).Round(gs, *((word32) esp_37 - 4), *esp_37);
				eax_171 = *((word32) esp_37 + 912);
l08096BEC:
				fn0808FD8A(0x00, (word32) esp_37 + 872);
				*((word32) esp_37 + 868) = (word32) esp_37 + 56;
				*((word32) esp_37 + 872) = 800;
				*((word32) esp_37 + 876) = 800;
				*((word32) esp_37 + 880) = *((word32) esp_37 + 856);
				*((word32) esp_37 + 884) = *((word32) esp_37 + 860);
				edx_147 = eax_171;
l08096C3F:
				*((word32) esp_37 - 8) = *((word32) esp_37 + 896);
				*((word32) esp_37 - 4) = *((word32) esp_37 + 900);
				*esp_37 = *((word32) esp_37 + 0x0388);
				*((word32) esp_37 + 4) = *((word32) esp_37 + 55);
				*((word32) esp_37 + 5) = *((word32) esp_37 + 913);
				fn08090264((word32) esp_37 + 868, (word32) esp_37 + 8);
				*((word32) esp_37 + 28) = edx_147;
				*((word32) esp_37 + 32) = *((word32) esp_37 + 908);
				strconv.formatDigits(gs, *((word32) esp_37 - 0x0C), *((word32) esp_37 - 8), *((word32) esp_37 - 4), *esp_37, *((word32) esp_37 + 1), *((word32) esp_37 + 16), *((word32) esp_37 + 20), *((word32) esp_37 + 24), *((word32) esp_37 + 28), *((word32) esp_37 + 32));
				return;
			}
		}
		goto l08096BEC;
	}
	Eq_4 eax_130;
	*((word32) esp_37 - 4) = (word32) esp_37 + 60;
	*esp_37 = *((word32) esp_37 + 920);
	*((word32) esp_37 + 4) = *((word32) esp_37 + 924);
	*((word32) esp_37 + 8) = *((word32) esp_37 + 928);
	*((word32) esp_37 + 0x0C) = *((word32) esp_37 + 932);
	strconv.roundShortest(ebx_24_8_83, esi_56, gs, *((word32) esp_37 - 4), *esp_37, *((word32) esp_37 + 4), *((word32) esp_37 + 8), *((word32) esp_37 + 0x0C));
	fn0808FD8A(0x00, (word32) esp_37 + 872);
	*((word32) esp_37 + 868) = (word32) esp_37 + 56;
	*((word32) esp_37 + 872) = 800;
	*((word32) esp_37 + 876) = 800;
	*((word32) esp_37 + 880) = *((word32) esp_37 + 856);
	word32 eax_110 = *((word32) esp_37 + 860);
	*((word32) esp_37 + 884) = eax_110;
	Eq_4 cl_113 = *((word32) esp_37 + 912);
	if (cl_113 <= 0x47)
	{
		if (cl_113 == 0x45)
		{
l08096DD0:
			eax_130 = *((word32) esp_37 + 880) - 0x01;
			goto l08096DD8;
		}
		if (cl_113 == 0x47)
			goto l08096DE4;
	}
	else
	{
		if (cl_113 == 101)
			goto l08096DD0;
		if (cl_113 == 0x66)
		{
			Eq_4 edx_123 = *((word32) esp_37 + 880) - eax_110;
			if (edx_123 <= 0x00)
				edx_123.u0 = 0x00;
			eax_130 = edx_123;
l08096DD8:
			edx_147 = eax_130;
			goto l08096C3F;
		}
		if (cl_113 == 0x67)
		{
l08096DE4:
			eax_130 = *((word32) esp_37 + 880);
			goto l08096DD8;
		}
	}
	eax_130 = *((word32) esp_37 + 908);
	goto l08096DD8;
}

// 08096E30: void strconv.formatDigits(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C, Stack Eq_4 bArg10, Stack Eq_93392 bArg11, Stack Eq_4 dwArg20, Stack Eq_4 dwArg24, Stack Eq_4 dwArg28, Stack Eq_4 dwArg2C, Stack Eq_4 bArg30)
// Called from:
//      strconv.genericFtoa
//      strconv.bigFtoa
void strconv.formatDigits(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C, Eq_4 bArg10, Eq_93392 bArg11, Eq_4 dwArg20, Eq_4 dwArg24, Eq_4 dwArg28, Eq_4 dwArg2C, Eq_4 bArg30)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	word32 eax_118 = (word32) bArg30;
	cu8 al_19 = (byte) eax_118;
	if (al_19 <= 0x47)
	{
		if (al_19 == 0x45)
		{
l08096E60:
			fn08090264((word32) fp + 20, fp - 44);
			strconv.fmtE(gs, dwLoc40, dwArg04, dwArg08, (byte) dwArg0C, SEQ(nLoc2F, (byte) (word32) bArg11), dwLoc2C, dwLoc28, dwLoc24, dwLoc20, dwArg28, al_19);
			return;
		}
		if (al_19 == 0x47)
		{
l08096EBF:
			Eq_4 ecx_138 = dwArg20;
			if (dwArg2C <= dwArg20 || dwArg20 < dwArg24)
				ecx_138 = dwArg2C;
			Eq_4 ebx_185 = dwArg20;
			if (bArg10 != 0x00)
				ecx_138.u0 = 0x06;
			bool v33_385;
			if (dwArg24 < ~0x02)
				v33_385 = dwArg2C <= dwArg20;
			else
			{
				if (dwArg24 - 0x01 < ecx_138)
				{
					if (dwArg2C <= dwArg24)
						ebx_185 = dwArg2C;
					Eq_4 ebx_190 = ebx_185 - dwArg24;
					if (ebx_190 <= 0x00)
						ebx_190.u0 = 0x00;
					fn08090264((word32) fp + 20, fp - 44);
					strconv.fmtF(gs, dwLoc40, dwArg04, dwArg08, (byte) dwArg0C, SEQ(nLoc2F, (byte) (word32) bArg11), dwLoc2C, dwLoc28, dwLoc24, dwLoc20, ebx_190);
					return;
				}
				v33_385 = dwArg2C <= dwArg20;
			}
			if (v33_385)
				ebx_185 = dwArg2C;
			fn08090264((word32) fp + 20, fp - 44);
			strconv.fmtE(gs, dwLoc40, dwArg04, dwArg08, (byte) dwArg0C, SEQ(nLoc2F, (byte) (word32) bArg11), dwLoc2C, dwLoc28, dwLoc24, dwLoc20, ebx_185 - 0x01, (byte) eax_118 + ~0x01);
			return;
		}
	}
	else
	{
		if (al_19 == 101)
			goto l08096E60;
		if (al_19 == 0x66)
		{
			fn08090264((word32) fp + 20, fp - 44);
			strconv.fmtF(gs, dwLoc40, dwArg04, dwArg08, (byte) dwArg0C, SEQ(nLoc2F, (byte) (word32) bArg11), dwLoc2C, dwLoc28, dwLoc24, dwLoc20, dwArg28);
			return;
		}
		if (al_19 == 0x67)
			goto l08096EBF;
	}
	Eq_4 ebp_114;
	if ((word32) dwArg08 + 2 <= dwArg0C)
		ebp_114 = dwArg04;
	else
	{
		word32 esi_727;
		word128 xmm0_728;
		word128 xmm1_729;
		runtime.growslice(gs, 0x080CF320, dwArg04, dwArg08, dwArg0C, (word32) dwArg08 + 2, out esi_727, out xmm0_728, out xmm1_729);
		ebp_114 = dwLoc28;
		eax_118 = (word32) bArg30;
	}
	Mem123[ebp_114 + dwArg08:byte] = 0x25;
	*((word32) dwArg08 + ((word32) ebp_114 + 1)) = (byte) eax_118;
}

// 080970B0: void strconv.roundShortest(Register word24 ebx_24_8, Register word32 esi, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C, Stack Eq_4 dwArg10, Stack Eq_4 dwArg14)
// Called from:
//      strconv.bigFtoa
void strconv.roundShortest(word24 ebx_24_8, word32 esi, struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C, Eq_4 dwArg10, Eq_4 dwArg14)
{
	while (fp - 0x05F4 <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (((int8) (dwArg0C == 0x00) & (int8) (dwArg08 == 0x00)) != 0x00)
	{
		((word32) dwArg04 + 800)->u0 = 0x00;
		return;
	}
	if (dwArg10 > (word32) (*((word32) dwArg14 + 8)) + 1 && (*((word32) dwArg04 + 804) - *((word32) dwArg04 + 800)) *s 332 >= (dwArg10 - *dwArg14) *s 100)
		return;
	Eq_4 edi_82 = (dwArg08 << 0x01) + 0x01;
	word32 * edi_502 = fp - 0x032C;
	word32 ecx_505;
	for (ecx_505 = 0xCB; ecx_505 != 0x00; --ecx_505)
	{
		*edi_502 = 0x00;
		++edi_502;
	}
	uint32 ebx_216;
	uint32 eax_219;
	Eq_4 ecx_218;
	strconv.(*decimal).Assign(SLICE(fp - 0x032C, word24, 8), edi_82, gs, dwLoc0678, fp - 0x032C, edi_82);
	Eq_4 esp_118 = <invalid>;
	*((word32) esp_118 + 4) = *((word32) esp_118 + 1668) - *(*((word32) esp_118 + 0x0688)) - 0x01;
	*esp_118 = (word32) esp_118 + 840;
	word32 esi_683;
	strconv.(*decimal).Shift(gs, *esp_118, *((word32) esp_118 + 4), out esi_683);
	up32 ecx_144 = **((word32) esp_118 + 0x0688);
	up32 ecx_169 = -(ecx_144 + ~0x1F);
	ui32 esi_181 = 0x00 - (ecx_169 < 0x20);
	uint32 ebp_151 = 0x00 - (ecx_144 < 0x20) & 0x01 << (byte) ecx_144;
	uint32 ebx_152 = *((word32) esp_118 + 1660);
	uint32 edx_183 = 0x01 >> (byte) ecx_169 & esi_181 | 0x00 - (ecx_144 < 0x40) & 0x01 << (byte) ecx_144 + 0xE0;
	uint32 ebx_184 = *((word32) esp_118 + 1664);
	if (((int8) (ebx_184 > edx_183) | (int8) (ebx_184 == edx_183) & (int8) (ebx_152 > ebp_151)) == 0x00)
	{
		Eq_4 ebp_208 = *((word32) esp_118 + 1668);
		if (*((word32) esp_118 + 0x0C) != ebp_208)
		{
			Eq_4 edx_211 = *((word32) esp_118 + 24);
			ebx_216 = (uint32) ((bool) (edx_211 < ~0x00) + ((word32) (*((word32) esp_118 + 20)) - 1));
			ecx_218 = ebp_208 - 0x01;
			eax_219 = (word32) edx_211 - 1;
l0809723A:
			*((word32) esp_118 + 16) = ecx_218;
			uint32 eax_235 = eax_219 << 0x01;
			*((word32) esp_118 + 24) = eax_235 + 0x01;
			word32 * edi_239 = (word32) esp_118 + 28;
			word32 ecx_240;
			for (ecx_240 = 0xCB; ecx_240 != 0x00; --ecx_240)
			{
				*edi_239 = 0x00;
				++edi_239;
			}
			*esp_118 = (word32) esp_118 + 28;
			*((word32) esp_118 + 4) = *((word32) esp_118 + 24);
			ui32 ebx_251 = ebx_216 << 0x01;
			*((word32) esp_118 + 8) = (eax_219 >> 0x1F | ebx_251) + (eax_235 < 0x01);
			strconv.(*decimal).Assign(SLICE(ebx_251, word24, 8), eax_235 + 0x01, gs, *((word32) esp_118 - 4), *esp_118, *((word32) esp_118 + 4));
			word32 esi_684;
			strconv.(*decimal).Shift(gs, fp - 0x0658, dwLoc0664 - *dwArg14 - 0x01, out esi_684);
			int8 dl_296 = (int8) ((dwArg08 & 0x01) == 0x00);
			Eq_4 eax_301;
			for (eax_301 = 0x00; eax_301 < *((word32) dwArg04 + 800); ++eax_301)
			{
				word32 esi_317;
				if (eax_301 < dwLoc0338)
				{
					if (eax_301 >= 800)
						runtime.panicindex(gs);
					esi_317 = CONVERT(Mem281[eax_301 + (fp - 0x0658):byte], byte, word32);
				}
				else
					esi_317 = 0x30;
				if (eax_301 >= 800)
					runtime.panicindex(gs);
				word32 ebx_334;
				word32 edi_329 = CONVERT(Mem281[eax_301 + dwArg04:byte], byte, word32);
				if (eax_301 < dwLoc0C)
					ebx_334 = CONVERT(Mem281[eax_301 + (fp - 0x032C):byte], byte, word32);
				else
					ebx_334 = 0x30;
				int8 cl_372;
				cu8 bl_380 = (byte) ebx_334;
				word24 ebx_24_8_557 = SLICE(ebx_334, word24, 8);
				if ((byte) esi_317 != (byte) edi_329)
					cl_372 = 0x01;
				else if ((dl_296 & 0x01) != 0x00)
					cl_372 = CONVERT(dwLoc0338 == eax_301 + 0x01, bool, int8);
				else
					cl_372 = 0x00;
				uip32 ebx_678;
				if (bl_380 != (byte) edi_329)
				{
					if ((dl_296 & 0x01) != 0x00)
						ebx_678 = 0x01;
					else if ((byte) edi_329 + 0x01 < bl_380)
						ebx_678 = 0x01;
					else
						ebx_678 = SEQ(ebx_24_8_557, CONVERT(eax_301 + 0x01 < dwLoc0C, bool, int8));
				}
				else
					ebx_678 = 0x00;
				byte bl_419 = (byte) ebx_678;
				bool v48_515 = cl_372 != 0x00;
				if (cl_372 != 0x00)
				{
					if (bl_419 != 0x00)
					{
						strconv.(*decimal).Round(gs, dwArg04, eax_301 + 0x01);
						return;
					}
					v48_515 = cl_372 != 0x00;
				}
				if (v48_515)
				{
					strconv.(*decimal).RoundDown(gs, dwArg04, eax_301 + 0x01);
					return;
				}
				if (bl_419 != 0x00)
				{
					strconv.(*decimal).RoundUp(gs, dwArg04, eax_301 + 0x01);
					return;
				}
			}
			return;
		}
	}
	eax_219 = ebx_152 + ~0x00;
	ebx_216 = (uint32) ((bool) (ebx_152 < ~0x00) + (ebx_184 + ~0x00));
	ecx_218 = *((word32) esp_118 + 1668);
	goto l0809723A;
}

// 08097470: void strconv.fmtE(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C, Stack byte bArg10, Stack (ptr32 byte) dwArg14, Stack Eq_4 dwArg18, Stack Eq_4 dwArg1C, Stack Eq_4 dwArg20, Stack Eq_4 dwArg24, Stack Eq_4 dwArg2C, Stack cu8 bArg30)
// Called from:
//      strconv.formatDigits
void strconv.fmtE(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C, byte bArg10, byte * dwArg14, Eq_4 dwArg18, Eq_4 dwArg1C, Eq_4 dwArg20, Eq_4 dwArg24, Eq_4 dwArg2C, cu8 bArg30)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 ebx_129;
	Eq_4 eax_101;
	Eq_4 edx_24;
	if (bArg10 != 0x00)
	{
		edx_24 = (word32) dwArg08 + 1;
		ebx_129 = dwArg0C;
		if ((word32) dwArg08 + 1 <= dwArg0C)
			eax_101 = dwArg04;
		else
		{
			word32 esi_1164;
			word128 xmm0_1165;
			word128 xmm1_1166;
			runtime.growslice(gs, 0x080CF320, dwArg04, dwArg08, dwArg0C, (word32) dwArg08 + 1, out esi_1164, out xmm0_1165, out xmm1_1166);
			eax_101 = dwLoc2C;
			ebx_129 = dwLoc24;
			edx_24 = dwLoc28 + 0x01;
		}
		Mem65[eax_101 + dwArg08:byte] = 0x2D;
	}
	else
	{
		ebx_129 = dwArg0C;
		eax_101 = dwArg04;
		edx_24 = dwArg08;
	}
	byte cl_94;
	if (dwArg20 != 0x00)
	{
		if (dwArg18 <= 0x00)
			runtime.panicindex(gs);
		cl_94 = *dwArg14;
	}
	else
		cl_94 = 0x30;
	Eq_4 ebp_130 = (word32) edx_24 + 1;
	if (ebp_130 > ebx_129)
	{
		word128 xmm1_1169;
		word32 esi_1167;
		word128 xmm0_1168;
		runtime.growslice(gs, 0x080CF320, eax_101, edx_24, ebx_129, ebp_130, out esi_1167, out xmm0_1168, out xmm1_1169);
		eax_101 = dwLoc2C;
		ebx_129 = dwLoc24;
		ebp_130 = dwLoc28 + 0x01;
	}
	Eq_4 edx_143;
	Mem137[eax_101 + edx_24:byte] = cl_94;
	if (dwArg2C <= 0x00)
	{
		edx_143 = ebp_130;
		goto l0809756D;
	}
	edx_143 = (word32) ebp_130 + 1;
	if (edx_143 > ebx_129)
	{
		word32 esi_1170;
		word128 xmm0_1171;
		word128 xmm1_1172;
		runtime.growslice(gs, 0x080CF320, eax_101, ebp_130, ebx_129, edx_143, out esi_1170, out xmm0_1171, out xmm1_1172);
		eax_101 = dwLoc2C;
		ebx_129 = dwLoc24;
		edx_143 = dwLoc28 + 0x01;
	}
	Mem184[eax_101 + ebp_130:byte] = 0x2E;
	Eq_4 ecx_187 = dwArg2C;
	Eq_4 ebp_186 = dwArg20;
	if (dwArg20 >= (word32) dwArg2C + 1)
		ebp_186 = (word32) dwArg2C + 1;
	Eq_4 ebp_297;
	if (ebp_186 > 0x01)
	{
		if (ebp_186 <= dwArg1C)
		{
			word32 ecx_204 = ebp_186 - 0x01 + edx_143;
			Eq_4 ebx_215 = ebx_129;
			Eq_4 esi_218 = dwArg14 + (0x01 - dwArg1C >> 0x1F & 0x01);
			if (ecx_204 > ebx_129)
			{
				word32 esi_1176;
				word128 xmm0_1177;
				word128 xmm1_1178;
				runtime.growslice(gs, 0x080CF320, eax_101, edx_143, ebx_129, ecx_204, out esi_1176, out xmm0_1177, out xmm1_1178);
				eax_101 = dwLoc2C;
				ebx_215 = dwLoc24;
			}
			if (ecx_204 <= ebx_215)
			{
				word128 xmm2_1184;
				word32 ebp_1179;
				word32 esi_1180;
				word32 edi_1181;
				word128 xmm0_1182;
				word128 xmm1_1183;
				runtime.memmove(eax_101 + edx_143, esi_218, ebp_186 - 0x01, out ebp_1179, out esi_1180, out edi_1181, out xmm0_1182, out xmm1_1183, out xmm2_1184);
				ecx_187 = dwArg2C;
				ebp_297 = ebp_186;
				ebx_129 = ebx_215;
				edx_143 = ecx_204;
l0809751F:
				while (ebp_297 <= ecx_187)
				{
					Eq_4 esi_686 = (word32) edx_143 + 1;
					if (esi_686 > ebx_129)
					{
						word128 xmm0_1174;
						word128 xmm1_1175;
						word32 esi_1173;
						runtime.growslice(gs, 0x080CF320, eax_101, edx_143, ebx_129, esi_686, out esi_1173, out xmm0_1174, out xmm1_1175);
						eax_101 = dwLoc2C;
						ebx_129 = dwLoc24;
						esi_686 = dwLoc28 + 0x01;
						ecx_187 = dwArg2C;
					}
					Mem726[eax_101 + edx_143:byte] = 0x30;
					ebp_297 = (byte) ebp_297.u0 + 1;
					edx_143 = esi_686;
				}
l0809756D:
				Eq_4 ecx_308 = (word32) edx_143 + 1;
				if (ecx_308 > ebx_129)
				{
					word32 esi_1185;
					word128 xmm0_1186;
					word128 xmm1_1187;
					runtime.growslice(gs, 0x080CF320, eax_101, edx_143, ebx_129, ecx_308, out esi_1185, out xmm0_1186, out xmm1_1187);
					eax_101 = dwLoc2C;
					ebx_129 = dwLoc24;
					ecx_308 = dwLoc28 + 0x01;
				}
				Mem364[eax_101 + edx_143:byte] = bArg30;
				Eq_4 ebx_366 = ebx_129;
				int32 edx_368 = dwArg24 - 0x01;
				if (dwArg20 == 0x00)
					edx_368 = 0x00;
				word32 ebp_380;
				if (edx_368 < 0x00)
				{
					edx_368 = -edx_368;
					ebp_380 = 0x2D;
				}
				else
					ebp_380 = 0x2B;
				Eq_4 esi_392 = (word32) ecx_308 + 1;
				if (esi_392 > ebx_129)
				{
					word128 xmm0_1189;
					word128 xmm1_1190;
					word32 esi_1188;
					runtime.growslice(gs, 0x080CF320, eax_101, ecx_308, ebx_129, esi_392, out esi_1188, out xmm0_1189, out xmm1_1190);
					eax_101 = dwLoc2C;
					ebx_366 = dwLoc24;
					esi_392 = dwLoc28 + 0x01;
					ebp_380 = (word32) (byte) ebp_380;
				}
				Mem456[eax_101 + ecx_308:byte] = SLICE(ebp_380, byte, 0);
				if (edx_368 < 0x0A)
				{
					Eq_4 ecx_625 = (word32) esi_392 + 2;
					if (ecx_625 > ebx_366)
					{
						word32 esi_1191;
						word128 xmm0_1192;
						word128 xmm1_1193;
						runtime.growslice(gs, 0x080CF320, eax_101, esi_392, ebx_366, ecx_625, out esi_1191, out xmm0_1192, out xmm1_1193);
						eax_101 = dwLoc2C;
					}
					Mem663[eax_101 + esi_392:byte] = 0x30;
					*((word32) esi_392 + ((word32) eax_101 + 1)) = (byte) edx_368 + 0x30;
				}
				else if (edx_368 < 100)
				{
					int32 edx_572 = (SLICE(edx_368 *s64 ~0x33333332, word32, 32) + edx_368 >> 0x03) - (edx_368 >> 0x1F);
					Eq_4 ecx_561 = (word32) esi_392 + 2;
					Eq_4 ebp_562 = eax_101;
					int32 eax_575 = edx_368 - edx_572 * 0x0A;
					if (ecx_561 > ebx_366)
					{
						word128 xmm1_1196;
						word128 xmm0_1195;
						word32 esi_1194;
						runtime.growslice(gs, 0x080CF320, eax_101, esi_392, ebx_366, ecx_561, out esi_1194, out xmm0_1195, out xmm1_1196);
						ebp_562 = dwLoc2C;
					}
					Mem619[ebp_562 + esi_392:byte] = SLICE(edx_572, byte, 0) + 0x30;
					*((word32) esi_392 + ((word32) ebp_562 + 1)) = (byte) eax_575 + 0x30;
				}
				else
				{
					int32 edx_485 = (SLICE(edx_368 *s64 ~0x33333332, word32, 32) + edx_368 >> 0x03) - (edx_368 >> 0x1F);
					int32 edx_493 = edx_485 - ((word32) ((byte) edx_485) *s 0x019A >> 0x0C) * 0x0A;
					Eq_4 ecx_465 = (word32) esi_392 + 3;
					Eq_4 ebp_466 = eax_101;
					int32 edx_476 = (SLICE(edx_368 *s64 1374389535, word32, 32) >> 0x05) - (edx_368 >> 0x1F);
					byte dl_499 = (byte) edx_493;
					int32 edi_496 = edx_368 - edx_485 * 0x0A;
					if (ecx_465 > ebx_366)
					{
						word32 esi_1197;
						word128 xmm0_1198;
						word128 xmm1_1199;
						runtime.growslice(gs, 0x080CF320, eax_101, esi_392, ebx_366, ecx_465, out esi_1197, out xmm0_1198, out xmm1_1199);
						ebp_466 = dwLoc2C;
						edx_493 = (word32) dl_499;
					}
					Mem548[ebp_466 + esi_392:byte] = SLICE(edx_476, byte, 0) + 0x30;
					*((word32) esi_392 + ((word32) ebp_466 + 1)) = (byte) edx_493 + 0x30;
					*((word32) esi_392 + ((word32) ebp_466 + 2)) = (byte) edi_496 + 0x30;
				}
				return;
			}
		}
		runtime.panicslice(gs);
	}
	else
	{
		ebp_297.u0 = 0x01;
		goto l0809751F;
	}
}

// 080979A0: void strconv.fmtF(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C, Stack byte bArg10, Stack Eq_4 dwArg14, Stack Eq_4 dwArg18, Stack Eq_4 dwArg1C, Stack Eq_4 dwArg20, Stack Eq_4 dwArg24, Stack Eq_4 dwArg2C)
// Called from:
//      strconv.formatDigits
void strconv.fmtF(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C, byte bArg10, Eq_4 dwArg14, Eq_4 dwArg18, Eq_4 dwArg1C, Eq_4 dwArg20, Eq_4 dwArg24, Eq_4 dwArg2C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 edx_127;
	Eq_4 ebx_126;
	Eq_4 ecx_23;
	if (bArg10 != 0x00)
	{
		ecx_23 = (word32) dwArg08 + 1;
		edx_127 = dwArg0C;
		if ((word32) dwArg08 + 1 <= dwArg0C)
			ebx_126 = dwArg04;
		else
		{
			word128 xmm1_770;
			word128 xmm0_769;
			word32 esi_768;
			runtime.growslice(gs, 0x080CF320, dwArg04, dwArg08, dwArg0C, (word32) dwArg08 + 1, out esi_768, out xmm0_769, out xmm1_770);
			ebx_126 = dwLoc2C;
			edx_127 = dwLoc24;
			ecx_23 = dwLoc28 + 0x01;
		}
		Mem65[ebx_126 + dwArg08:byte] = 0x2D;
	}
	else
	{
		ebx_126 = dwArg04;
		ecx_23 = dwArg08;
		edx_127 = dwArg0C;
	}
	Eq_4 eax_181;
	if (dwArg24 > 0x00)
	{
		Eq_4 ebp_74 = dwArg20;
		if (dwArg20 >= dwArg24)
			ebp_74 = dwArg24;
		if (ebp_74 <= dwArg1C)
		{
			word32 esi_87 = ebp_74 + ecx_23;
			if (esi_87 > edx_127)
			{
				word32 esi_780;
				word128 xmm0_781;
				word128 xmm1_782;
				runtime.growslice(gs, 0x080CF320, ebx_126, ecx_23, edx_127, esi_87, out esi_780, out xmm0_781, out xmm1_782);
				ebx_126 = dwLoc2C;
				edx_127 = dwLoc24;
			}
			if (esi_87 <= edx_127)
			{
				word128 xmm0_786;
				word32 edi_785;
				word32 ebp_783;
				word128 xmm1_787;
				word128 xmm2_788;
				word32 esi_784;
				runtime.memmove(ecx_23 + ebx_126, dwArg14, ebp_74, out ebp_783, out esi_784, out edi_785, out xmm0_786, out xmm1_787, out xmm2_788);
				Eq_4 eax_170;
				Eq_4 ecx_171 = esi_87;
				for (eax_170 = ebp_74; eax_170 < dwArg24; ++eax_170)
				{
					word32 ebp_182 = ecx_171 + 0x01;
					if (ebp_182 > edx_127)
					{
						word128 xmm1_791;
						word128 xmm0_790;
						word32 esi_789;
						runtime.growslice(gs, 0x080CF320, ebx_126, ecx_171, edx_127, ebp_182, out esi_789, out xmm0_790, out xmm1_791);
						ebx_126 = dwLoc2C;
						edx_127 = dwLoc24;
						ebp_182 = dwLoc28 + 0x01;
					}
					Mem224[ebx_126 + ecx_171:byte] = 0x30;
					ecx_171 = ebp_182;
				}
				eax_181 = ecx_171;
l08097A00:
				if (dwArg2C > 0x00)
				{
					Eq_4 ebp_277 = (word32) eax_181 + 1;
					if (ebp_277 > edx_127)
					{
						word128 xmm1_776;
						word128 xmm0_775;
						word32 esi_774;
						runtime.growslice(gs, 0x080CF320, ebx_126, eax_181, edx_127, ebp_277, out esi_774, out xmm0_775, out xmm1_776);
						ebx_126 = dwLoc2C;
						edx_127 = dwLoc24;
						ebp_277 = dwLoc28 + 0x01;
					}
					Mem320[ebx_126 + eax_181:byte] = 0x2E;
					Eq_4 eax_321 = 0x00;
					while (eax_321 < dwArg2C)
					{
						byte cl_366;
						word32 esi_343 = dwArg24 + eax_321;
						if (esi_343 >= 0x00)
						{
							if (esi_343 < dwArg20)
							{
								if (esi_343 >= dwArg18)
									runtime.panicindex(gs);
								cl_366 = Mem341[dwArg14 + esi_343:byte];
							}
							else
								cl_366 = 0x30;
						}
						else
							cl_366 = 0x30;
						Eq_4 esi_359 = (word32) ebp_277 + 1;
						if (esi_359 > edx_127)
						{
							word128 xmm0_778;
							word32 esi_777;
							word128 xmm1_779;
							runtime.growslice(gs, 0x080CF320, ebx_126, ebp_277, edx_127, esi_359, out esi_777, out xmm0_778, out xmm1_779);
							ebx_126 = dwLoc2C;
							edx_127 = dwLoc24;
							esi_359 = dwLoc28 + 0x01;
						}
						Mem411[ebx_126 + ebp_277:byte] = cl_366;
						eax_321 = (word32) eax_321 + 1;
						ebp_277 = esi_359;
					}
				}
				return;
			}
		}
		runtime.panicslice(gs);
	}
	else
	{
		eax_181 = (word32) ecx_23 + 1;
		if (eax_181 > edx_127)
		{
			word128 xmm1_773;
			word128 xmm0_772;
			word32 esi_771;
			runtime.growslice(gs, 0x080CF320, ebx_126, ecx_23, edx_127, eax_181, out esi_771, out xmm0_772, out xmm1_773);
			ebx_126 = dwLoc2C;
			edx_127 = dwLoc24;
			eax_181 = dwLoc28 + 0x01;
		}
		Mem267[ebx_126 + ecx_23:byte] = 0x30;
		goto l08097A00;
	}
}

// 08097CB0: void strconv.fmtB(Register Eq_4 ebp, Register (ptr32 Eq_23322) esi, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C, Stack byte bArg10, Stack Eq_4 dwArg14, Stack Eq_4 dwArg18)
// Called from:
//      strconv.genericFtoa
void strconv.fmtB(Eq_4 ebp, struct Eq_23322 * esi, struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C, byte bArg10, Eq_4 dwArg14, Eq_4 dwArg18)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 edx_24;
	Eq_4 ecx_23;
	Eq_4 ebx_22;
	if (bArg10 != 0x00)
	{
		ecx_23 = (word32) dwArg08 + 1;
		edx_24 = dwArg0C;
		if ((word32) dwArg08 + 1 <= dwArg0C)
			ebx_22 = dwArg04;
		else
		{
			word128 xmm0_337;
			word128 xmm1_338;
			ebp = runtime.growslice(gs, 0x080CF320, dwArg04, dwArg08, dwArg0C, (word32) dwArg08 + 1, out esi, out xmm0_337, out xmm1_338);
			ebx_22 = dwLoc20;
			edx_24 = dwLoc18;
			ecx_23 = dwLoc1C + 0x01;
		}
		Mem65[ebx_22 + dwArg08:byte] = 0x2D;
	}
	else
	{
		ebx_22 = dwArg04;
		ecx_23 = dwArg08;
		edx_24 = dwArg0C;
	}
	struct Eq_23322 * esi_132 = strconv.formatBits(ebp, esi, gs, dwLoc38, ebx_22, ecx_23, SEQ(dwArg14, edx_24), dwArg18, 0x0A);
	Eq_4 esp_99 = <invalid>;
	Eq_4 ecx_114 = *((word32) esp_99 + 32);
	Eq_4 eax_113 = *((word32) esp_99 + 28);
	Eq_4 edx_115 = *((word32) esp_99 + 36);
	Eq_4 ebx_116 = (word32) ecx_114 + 1;
	if ((word32) ecx_114 + 1 > edx_115)
	{
		*((word32) esp_99 + 60) = ecx_114;
		esp_99->u0 = 0x080CF320;
		*((word32) esp_99 + 4) = eax_113;
		*((word32) esp_99 + 8) = ecx_114;
		*((word32) esp_99 + 0x0C) = edx_115;
		*((word32) esp_99 + 16) = (word32) ecx_114 + 1;
		word128 xmm0_339;
		word128 xmm1_340;
		runtime.growslice(gs, *esp_99, *((word32) esp_99 + 4), *((word32) esp_99 + 8), *((word32) esp_99 + 0x0C), *((word32) esp_99 + 16), out esi_132, out xmm0_339, out xmm1_340);
		eax_113 = *((word32) esp_99 + 20);
		edx_115 = *((word32) esp_99 + 28);
		ebx_116 = (word32) *((word32) esp_99 + 24) + 1;
		ecx_114 = *((word32) esp_99 + 60);
	}
	Eq_4 ecx_163;
	Mem153[eax_113 + ecx_114:byte] = 0x70;
	Eq_4 ebp_158 = *((word32) esp_99 + 80) - *(*((word32) esp_99 + 84));
	if (ebp_158 >= 0x00)
	{
		ecx_163 = (word32) ebx_116 + 1;
		if (ecx_163 > edx_115)
		{
			*((word32) esp_99 + 48) = ebx_116;
			*((word32) esp_99 + 80) = ebp_158;
			esp_99->u0 = 0x080CF320;
			*((word32) esp_99 + 4) = eax_113;
			*((word32) esp_99 + 8) = ebx_116;
			*((word32) esp_99 + 0x0C) = edx_115;
			*((word32) esp_99 + 16) = ecx_163;
			word128 xmm0_341;
			word128 xmm1_342;
			runtime.growslice(gs, *esp_99, *((word32) esp_99 + 4), *((word32) esp_99 + 8), *((word32) esp_99 + 0x0C), *((word32) esp_99 + 16), out esi_132, out xmm0_341, out xmm1_342);
			eax_113 = *((word32) esp_99 + 20);
			edx_115 = *((word32) esp_99 + 28);
			ecx_163 = (word32) *((word32) esp_99 + 24) + 1;
			ebx_116 = *((word32) esp_99 + 48);
			ebp_158 = *((word32) esp_99 + 80);
		}
		Mem206[eax_113 + ebx_116:byte] = 0x2B;
	}
	else
		ecx_163 = ebx_116;
	*esp_99 = eax_113;
	*((word32) esp_99 + 4) = ecx_163;
	*((word32) esp_99 + 8) = edx_115;
	*((word32) esp_99 + 0x0C) = ebp_158;
	Eq_4 ebp_221 = ebp_158 >> 0x1F;
	*((word32) esp_99 + 16) = ebp_221;
	((word32) esp_99 + 20)->u0 = 0x0A;
	((word32) esp_99 + 24)->u0 = (int8) (ebp_158 < 0x00);
	*((word32) esp_99 + 25) = 0x01;
	strconv.formatBits(ebp_221, esi_132, gs, *((word32) esp_99 - 4), *esp_99, *((word32) esp_99 + 4), *((word32) esp_99 + 8), *((word32) esp_99 + 16), *((word32) esp_99 + 20));
}

// 08097E80: void strconv.FormatInt(Register ui24 ebx_24_8, Register word32 ebp, Register (ptr32 Eq_23322) esi, Register (ptr32 Eq_2) gs, Stack Eq_99008 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C)
// Called from:
//      strconv.Itoa
void strconv.FormatInt(ui24 ebx_24_8, word32 ebp, struct Eq_23322 * esi, struct Eq_2 * gs, Eq_99008 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C)
{
	while (true)
	{
		Eq_4 ecx_7 = gs->ptr0000->tFFFFFFFC;
		word24 ecx_24_8_27 = SLICE(ecx_7, word24, 8);
		if (fp > *((word32) ecx_7 + 8))
			break;
		runtime.morestack_noctxt();
	}
	word24 ebx_24_8_38 = SLICE(ebp, word24, 8);
	ui32 ecx_28 = SEQ(ecx_24_8_27, (int8) (dwArg08 == 0x00));
	Eq_4 ebx_39 = SEQ(ebx_24_8_38, (int8) (dwArg08 > 0x00));
	ui32 ebx_42 = SEQ(ebx_24_8, (int8) Test(UGE,false)) & ecx_28 | ebx_39;
	Eq_4 ebp_108 = ebx_39;
	if ((byte) ebx_42 != 0x00)
	{
		Eq_4 ebx_64 = SEQ(ebx_24_8_38, (int8) (dwArg08 < 0x00));
		ebp_108 = ebx_64;
		if (((int8) (dwArg04 < 100) & (int8) (dwArg08 == 0x00) | (int8) (dwArg08 < 0x00)) != 0x00 && dwArg0C == 0x0A)
		{
			uint32 ecx_146 = (dwArg04 << 0x01) + 0x02;
			if ((word32) (dwArg04 < 0x0A) + dwArg04 * 0x02 <= ecx_146 && ecx_146 <= 200)
				return;
			runtime.panicslice(gs);
		}
	}
	strconv.formatBits(ebp_108, esi, gs, dwLoc34, 0x00, 0x00, SEQ(dwArg04, 0x00), dwArg08, dwArg0C);
}

// 08097FA0: void strconv.Itoa(Register ui24 ebx_24_8, Register word32 ebp, Register (ptr32 Eq_23322) esi, Register (ptr32 Eq_2) gs, Stack Eq_99008 dwArg04)
// Called from:
//      reflect.Kind.String
//      reflect.ChanDir.String
void strconv.Itoa(ui24 ebx_24_8, word32 ebp, struct Eq_23322 * esi, struct Eq_2 * gs, Eq_99008 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	strconv.FormatInt(ebx_24_8, ebp, esi, gs, dwArg04, dwArg04 >> 0x1F, 0x0A);
}

// 08097FF0: Register (ptr32 Eq_23322) strconv.formatBits(Register Eq_4 ebp, Register (ptr32 Eq_23322) esi, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg00, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 qwArg0C, Stack Eq_4 dwArg14, Stack Eq_4 dwArg18)
// Called from:
//      strconv.fmtB
//      strconv.FormatInt
struct Eq_23322 * strconv.formatBits(Eq_4 ebp, struct Eq_23322 * esi, struct Eq_2 * gs, Eq_4 dwArg00, Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 qwArg0C, Eq_4 dwArg14, Eq_4 dwArg18)
{
	byte bArg19_815 = SLICE(dwArg18, byte, 8);
	Eq_4 dwArg10 = SLICE(qwArg0C, word32, 32);
	Eq_4 dwArg0C = (word32) qwArg0C;
	byte bArg18_775 = (byte) dwArg18;
	while (fp - 0x1C <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (dwArg18 > 0x24)
		runtime.gopanic(gs);
	Eq_4 edx_170;
	Eq_4 eax_171;
	word32 ecx_45 = (word32) bArg18_775;
	fn0808FD80(0x00, fp - 0x44);
	byte cl_251 = (byte) ecx_45;
	if (cl_251 != 0x00)
	{
		ui64 edx_eax_763 = 0x00 - qwArg0C;
		eax_171 = (word32) edx_eax_763;
		edx_170 = SLICE(edx_eax_763, word32, 32);
	}
	else
	{
		edx_170 = dwArg10;
		eax_171 = dwArg0C;
	}
	byte * eax_255;
	bool v76_764;
	if (dwArg14 == 0x0A)
	{
		byte * ebx_322 = (byte *) 0x41;
		while (true)
		{
			byte cl_756 = (byte) ecx_45;
			byte * ebx_363 = ebx_322;
			Eq_4 eax_373 = eax_171;
			if (((int8) (edx_170 > 0x00) | (int8) (edx_170 == 0x00) & (int8) (eax_171 >= 1000000000)) == 0x00)
				break;
			runtime.uint64div(gs, eax_171, edx_170, 1000000000, 0x00);
			uint32 edx_662 = eax_171 - dwLoc90 * 1000000000;
			byte * ebx_666 = ebx_322;
			int32 ebp_667;
			for (ebp_667 = 0x04; ebp_667 > 0x00; --ebp_667)
			{
				uint32 edx_696 = SLICE((edx_662 >> 0x01) *64 2748779070, word32, 32);
				uint32 esi_700 = edx_662 - (edx_696 >> 0x05) *s 100;
				if (esi_700 << 0x01 >= ~0xC6)
				{
l080986D5:
					runtime.panicindex(gs);
				}
				word32 ebp_709 = (word32) g_a80E7A42[esi_700];
				if (ebx_666 >= (byte *) 66)
					goto l080986D5;
				Mem718[ebx_666 - 0x01 + (fp - 0x49):byte] = SLICE(ebp_709, byte, 0);
				if (esi_700 << 0x01 >= 200)
				{
l080986CE:
					runtime.panicindex(gs);
				}
				byte * ebp_724 = ebx_666 - (byte *) 0x02;
				byte dl_729 = g_a80E7A41[esi_700];
				if (ebp_724 >= (byte *) 0x41)
					goto l080986CE;
				Mem730[fp - 0x4B + ebx_666:byte] = dl_729;
				ebx_666 = ebp_724;
				edx_662 = edx_696 >> 0x05;
			}
			if (edx_662 << 0x01 >= 199)
			{
l080986C7:
				runtime.panicindex(gs);
			}
			byte * ebp_677 = ebx_666 - 0x01;
			byte dl_685 = g_a80E7A42[edx_662];
			if (ebp_677 >= (byte *) 0x41)
				goto l080986C7;
			Mem687[fp - 0x4A + ebx_666:byte] = dl_685;
			ecx_45 = (word32) bArg18_775;
			eax_171 = dwLoc90;
			edx_170 = dwLoc8C;
			ebx_322 = ebp_677;
		}
		while (eax_373 >= 100)
		{
			uint32 edx_597 = SLICE((eax_373 >> 0x01) *64 2748779070, word32, 32);
			uint32 esi_601 = eax_373 - (edx_597 >> 0x05) *s 100;
			if (esi_601 << 0x01 >= ~0xC6)
			{
l080986C0:
				runtime.panicindex(gs);
			}
			word32 edi_613 = (word32) g_a80E7A42[esi_601];
			if (ebx_363 >= (byte *) 66)
				goto l080986C0;
			Mem622[ebx_363 - 0x01 + (fp - 0x49):byte] = SLICE(edi_613, byte, 0);
			if (esi_601 << 0x01 >= 200)
			{
l080986B9:
				runtime.panicindex(gs);
			}
			byte * esi_628 = ebx_363 - (byte *) 0x02;
			byte dl_633 = g_a80E7A41[esi_601];
			if (esi_628 >= (byte *) 0x41)
				goto l080986B9;
			Mem634[fp - 0x4B + ebx_363:byte] = dl_633;
			eax_373 = edx_597 >> 0x05;
			ebx_363 = esi_628;
		}
		uint32 eax_379 = eax_373 << 0x01;
		if (eax_379 < 199)
		{
			byte * ebp_384 = ebx_363 - 0x01;
			word32 edi_387 = (word32) g_a80E7A42[eax_373];
			if (ebp_384 < (byte *) 0x41)
			{
				Mem399[ebx_363 - 0x01 + (fp - 0x49):byte] = SLICE(edi_387, byte, 0);
				if (eax_373 < 0x0A)
				{
					v76_764 = cl_756 == 0x00;
					eax_255 = ebp_384;
					goto l080982A1;
				}
				if (eax_379 < 200)
				{
					eax_255 = ebx_363 - (byte *) 0x02;
					byte dl_417 = g_a80E7A41[eax_373];
					if (eax_255 < (byte *) 0x41)
					{
						Mem418[ebx_363 - 0x02 + (fp - 0x49):byte] = dl_417;
						v76_764 = cl_756 == 0x00;
						goto l080982A1;
					}
				}
				runtime.panicindex(gs);
			}
		}
		runtime.panicindex(gs);
	}
	if (dwArg14 >= 0x25)
		runtime.panicindex(gs);
	byte * ebx_136;
	up32 ebp_69 = g_a8138AA0[dwArg14 * 0x04];
	if (ebp_69 <= 0x00)
	{
		byte * esi_119 = (byte *) 0x41;
		while (((int8) (edx_170 == dwArg14 >> 0x1F) & (int8) (eax_171 >= dwArg14) | (int8) (edx_170 > dwArg14 >> 0x1F)) != 0x00)
		{
			runtime.uint64div(gs, eax_171, edx_170, dwArg14, dwArg14 >> 0x1F);
			struct Eq_99476 * edx_156 = eax_171 - dwLoc90 * dwArg14;
			if (edx_156 >= (struct Eq_99476 *) 0x24)
			{
l0809868F:
				runtime.panicindex(gs);
			}
			--esi_119;
			byte dl_166 = edx_156->b80E5D28;
			if (esi_119 >= (byte *) 66)
				goto l0809868F;
			Mem167[fp - 0x4A + esi_119:byte] = dl_166;
			edx_170 = dwLoc8C;
			eax_171 = dwLoc90;
		}
		if (eax_171 < 0x24)
		{
			byte * ecx_120 = esi_119 - (byte *) 0x01;
			byte al_130 = *((word32) eax_171 + 135159080);
			if (ecx_120 < (byte *) 0x41)
			{
				Mem131[esi_119 - 0x01 + (fp - 0x49):byte] = al_130;
				v76_764 = bArg18_775 == 0x00;
				ebx_136 = ecx_120;
l08098583:
				eax_255 = ebx_136;
l080982A1:
				byte * ecx_428;
				if (!v76_764)
				{
					ecx_428 = eax_255 - 0x01;
					if (ecx_428 >= (byte *) 0x41)
						runtime.panicindex(gs);
					Mem436[fp - 0x4A + eax_255:byte] = 0x2D;
				}
				else
					ecx_428 = eax_255;
				if (bArg19_815 == 0x00)
				{
					if (ecx_428 > (byte *) 0x41)
						runtime.panicslice(gs);
					else
					{
						Eq_4 eax_452 = 0x41 - ecx_428;
						return runtime.slicebytetostring(gs, 0x00, fp - 0x49 + (ecx_428 & -eax_452 >> 0x1F), eax_452);
					}
				}
				else
				{
					if (ecx_428 <= (byte *) 0x41)
					{
						Eq_4 esi_537;
						Eq_4 ebx_500 = 0x41 - ecx_428;
						up32 eax_496 = dwArg04 - ecx_428;
						byte * ecx_504 = ecx_428 & -ebx_500 >> 0x1F;
						Eq_4 ebx_505 = dwArg08;
						if (eax_496 + 0x41 <= dwArg08)
							esi_537 = dwArg00;
						else
						{
							word128 xmm1_971;
							word32 esi_969;
							word128 xmm0_970;
							runtime.growslice(gs, 0x080CF320, dwArg00, dwArg04, dwArg08, eax_496 + 0x41, out esi_969, out xmm0_970, out xmm1_971);
							esi_537 = dwLoc8C;
							ebx_505 = dwLoc84;
						}
						if (dwArg04 - ecx_428 + 0x41 <= ebx_505)
						{
							struct Eq_23322 * esi_564;
							word32 ebp_972;
							word32 edi_973;
							word128 xmm2_976;
							word128 xmm1_975;
							word128 xmm0_974;
							runtime.memmove(esi_537 + dwArg04, fp - 0x49 + ecx_504, ebx_500, out ebp_972, out esi_564, out edi_973, out xmm0_974, out xmm1_975, out xmm2_976);
							return esi_564;
						}
					}
					runtime.panicslice(gs);
				}
			}
		}
		runtime.panicindex(gs);
	}
	else
	{
		byte * dwLoc6C_799 = (byte *) 0x41;
		Eq_4 eax_185 = eax_171;
		while (((int8) (edx_170 > dwArg14 >> 0x1F) | (int8) (eax_185 >= dwArg14) & (int8) (edx_170 == dwArg14 >> 0x1F)) != 0x00)
		{
			struct Eq_99288 * eax_258 = eax_185 & dwArg14 - 0x01;
			if (eax_258 >= (struct Eq_99288 *) 0x24)
			{
l0809869D:
				runtime.panicindex(gs);
			}
			byte al_269 = eax_258->b80E5D28;
			if (dwLoc6C_799 >= (byte *) 66)
				goto l0809869D;
			Mem270[fp - 0x4A + dwLoc6C_799:byte] = al_269;
			ui32 esi_304 = 0x00 - (ebp_69 < 0x20);
			up32 ebx_287 = 0x20 - ebp_69;
			dwLoc6C_799 -= (byte *) 0x01;
			cl_251 = bArg18_775;
			edx_170 = edx_170 >> (byte) ebp_69 & esi_304;
			eax_185 = edx_170 << (byte) ebx_287 & 0x00 - (ebx_287 < 0x20) | eax_185 >> (byte) ebp_69 & esi_304 | edx_170 >> (byte) ebp_69 - 0x20 & 0x00 - (ebp_69 < 0x40);
		}
		if (eax_185 < 0x24)
		{
			ebx_136 = dwLoc6C_799 - (byte *) 0x01;
			byte al_249 = *((word32) eax_185 + 135159080);
			if (dwLoc6C_799 < (byte *) 66)
			{
				Mem250[dwLoc6C_799 - 0x01 + (fp - 0x49):byte] = al_249;
				v76_764 = cl_251 == 0x00;
				goto l08098583;
			}
		}
		runtime.panicindex(gs);
	}
}

// 08098700: void strconv.appendQuotedWith(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C, Stack (ptr32 Eq_93084) dwArg10, Stack Eq_4 dwArg14, Stack byte bArg18, Stack byte bArg19, Stack byte bArg1A)
// Called from:
//      strconv.AppendQuote
//      strconv.AppendQuoteToASCII
void strconv.appendQuotedWith(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C, struct Eq_93084 * dwArg10, Eq_4 dwArg14, byte bArg18, byte bArg19, byte bArg1A)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 ebx_109;
	Eq_4 ecx_18 = (word32) dwArg08 + 1;
	Eq_4 edx_19 = dwArg0C;
	if ((word32) dwArg08 + 1 <= dwArg0C)
		ebx_109 = dwArg04;
	else
	{
		word128 xmm0_705;
		word128 xmm1_706;
		word32 esi_704;
		runtime.growslice(gs, 0x080CF320, dwArg04, dwArg08, dwArg0C, (word32) dwArg08 + 1, out esi_704, out xmm0_705, out xmm1_706);
		dwLoc34 = dwArg08;
		dwLoc30 = dwArg0C;
		ebx_109 = dwLoc28;
		edx_19 = dwLoc20;
		ecx_18 = (word32) dwLoc24 + 1;
	}
	word32 ebp_57 = (word32) bArg18;
	Mem65[ebx_109 + dwArg08:byte] = SLICE(ebp_57, byte, 0);
	word32 ebp_115 = ebp_57;
	Eq_4 ecx_228 = ecx_18;
	struct Eq_93084 * eax_136 = dwArg10;
	Eq_4 esi_439 = dwArg14;
	while (esi_439 > 0x00)
	{
		Eq_4 dwLoc18_495;
		Eq_4 edi_139 = (word32) eax_136->b0000;
		if (edi_139 < 0x80)
			dwLoc18_495.u0 = 0x01;
		else
		{
			unicode/utf8.DecodeRuneInString(gs, eax_136, esi_439);
			edi_139 = dwLoc34;
			ebp_115 = (word32) bArg18;
			dwLoc18_495 = dwLoc30;
		}
		Eq_4 esi_230;
		Eq_4 edi_229;
		Eq_4 edx_186 = edx_19;
		Eq_4 ebx_179 = ebx_109;
		if (dwLoc18_495 == 0x01 && edi_139 == 0xFFFD)
		{
			Eq_4 edi_233 = (word32) ecx_228 + 2;
			if (edi_233 > edx_19)
			{
				word32 esi_707;
				word128 xmm0_708;
				word128 xmm1_709;
				runtime.growslice(gs, 0x080CF320, ebx_109, ecx_228, edx_19, edi_233, out esi_707, out xmm0_708, out xmm1_709);
				dwLoc30 = edx_19;
				edx_186 = dwLoc20;
				ebx_179 = dwLoc28;
			}
			if (edi_233 > edx_186)
				runtime.panicslice(gs);
			word32 ebp_710;
			word32 esi_711;
			word128 xmm2_715;
			word128 xmm1_714;
			word32 edi_712;
			word128 xmm0_713;
			runtime.memmove(ebx_179 + ecx_228, 0x080E0E0B, 0x02, out ebp_710, out esi_711, out edi_712, out xmm0_713, out xmm1_714, out xmm2_715);
			dwLoc34.u0 = 0x02;
			struct Eq_99736 * ecx_309 = (word32) (eax_136->b0000 >> 0x04);
			if (ecx_309 >= (struct Eq_99736 *) 0x10)
				runtime.panicindex(gs);
			Eq_4 ebx_313 = (word32) ecx_228 + 3;
			byte cl_319 = ecx_309->b80E2469;
			esi_230 = edx_186;
			if ((word32) ecx_228 + 3 <= edx_186)
				edi_229 = ebx_179;
			else
			{
				word128 xmm1_718;
				word128 xmm0_717;
				word32 esi_716;
				runtime.growslice(gs, 0x080CF320, ebx_179, edi_233, edx_186, (word32) ecx_228 + 3, out esi_716, out xmm0_717, out xmm1_718);
				dwLoc34 = edi_233;
				dwLoc30 = edx_186;
				edi_229 = dwLoc28;
				esi_230 = dwLoc20;
				ebx_313 = (word32) dwLoc24 + 1;
			}
			*((word32) edi_229 + ((word32) ecx_228 + 2)) = cl_319;
			ecx_228 = (word32) ebx_313 + 1;
			byte dl_375 = ((word32) eax_136->b0000 & 0x0F)->b80E2469;
			if (ecx_228 > esi_230)
			{
				word128 xmm1_721;
				word32 esi_719;
				word128 xmm0_720;
				runtime.growslice(gs, 0x080CF320, edi_229, ebx_313, esi_230, ecx_228, out esi_719, out xmm0_720, out xmm1_721);
				dwLoc34 = ebx_313;
				dwLoc30 = esi_230;
				edi_229 = dwLoc28;
				esi_230 = dwLoc20;
				ecx_228 = (word32) dwLoc24 + 1;
			}
			Mem416[edi_229 + ebx_313:byte] = dl_375;
		}
		else
		{
			strconv.appendEscapedRune(gs, ebx_109, ecx_228, edx_19, edi_139, (byte) ebp_115, bArg19, bArg1A);
			dwLoc34 = edx_19;
			dwLoc30 = edi_139;
			ecx_228 = dwLoc24;
			edi_229 = dwLoc28;
			esi_230 = dwLoc20;
		}
		if (dwLoc18_495 > esi_439)
			runtime.panicslice(gs);
		Eq_4 ebx_424 = esi_439 - dwLoc18_495;
		eax_136 += (dwLoc18_495 & -ebx_424 >> 0x1F) / 4;
		ebp_115 = (word32) bArg18;
		ebx_109 = edi_229;
		edx_19 = esi_230;
		esi_439 = ebx_424;
	}
	Eq_4 eax_77 = (word32) ecx_228 + 1;
	if (eax_77 > edx_19)
	{
		word32 esi_722;
		word128 xmm0_723;
		word128 xmm1_724;
		runtime.growslice(gs, 0x080CF320, ebx_109, ecx_228, edx_19, eax_77, out esi_722, out xmm0_723, out xmm1_724);
		ebx_109 = dwLoc28;
		ebp_115 = (word32) bArg18;
	}
	Mem125[ebx_109 + ecx_228:byte] = SLICE(ebp_115, byte, 0);
}

// 08098A60: void strconv.appendQuotedRuneWith(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C, Stack Eq_4 dwArg10, Stack byte bArg14, Stack byte bArg15, Stack byte bArg16)
// Called from:
//      strconv.AppendQuoteRune
//      strconv.AppendQuoteRuneToASCII
void strconv.appendQuotedRuneWith(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C, Eq_4 dwArg10, byte bArg14, byte bArg15, byte bArg16)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 ebx_49;
	Eq_4 ecx_18 = (word32) dwArg08 + 1;
	Eq_4 edx_19 = dwArg0C;
	if ((word32) dwArg08 + 1 <= dwArg0C)
		ebx_49 = dwArg04;
	else
	{
		word128 xmm0_261;
		word128 xmm1_262;
		word32 esi_260;
		runtime.growslice(gs, 0x080CF320, dwArg04, dwArg08, dwArg0C, (word32) dwArg08 + 1, out esi_260, out xmm0_261, out xmm1_262);
		ebx_49 = dwLoc0C;
		edx_19 = dwLoc04;
		ecx_18 = (word32) dwLoc08 + 1;
	}
	word32 ebp_57 = (word32) bArg14;
	Mem65[ebx_49 + dwArg08:byte] = SLICE(ebp_57, byte, 0);
	Eq_4 eax_69 = dwArg10;
	if (dwArg10 >= 0xD800 && dwArg10 > 1114111)
		eax_69.u0 = 0xFFFD;
	strconv.appendEscapedRune(gs, ebx_49, ecx_18, edx_19, eax_69, (byte) ebp_57, bArg15, bArg16);
	if ((word32) dwLoc08 + 1 > dwLoc04)
	{
		word32 esi_263;
		word128 xmm1_265;
		word128 xmm0_264;
		runtime.growslice(gs, 0x080CF320, dwLoc0C, dwLoc08, dwLoc04, (word32) dwLoc08 + 1, out esi_263, out xmm0_264, out xmm1_265);
	}
	Mem170[dwLoc0C + dwLoc08:byte] = bArg14;
}

// 08098BA0: void strconv.appendEscapedRune(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C, Stack Eq_4 dwArg10, Stack byte bArg14, Stack byte bArg15, Stack byte bArg16)
// Called from:
//      strconv.appendQuotedWith
//      strconv.appendQuotedRuneWith
void strconv.appendEscapedRune(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C, Eq_4 dwArg10, byte bArg14, byte bArg15, byte bArg16)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if ((word32) bArg14 == dwArg10 || dwArg10 == 0x5C)
	{
		Eq_4 ebp_105;
		word32 edx_29 = dwArg08 + 0x01;
		Eq_4 ebx_30 = dwArg0C;
		if (dwArg08 + 0x01 <= dwArg0C)
			ebp_105 = dwArg04;
		else
		{
			word32 esi_2085;
			word128 xmm0_2086;
			word128 xmm1_2087;
			runtime.growslice(gs, 0x080CF320, dwArg04, dwArg08, dwArg0C, dwArg08 + 0x01, out esi_2085, out xmm0_2086, out xmm1_2087);
			ebp_105 = dwLoc28;
			ebx_30 = dwLoc20;
			edx_29 = dwLoc24 + 0x01;
		}
		Mem70[ebp_105 + dwArg08:byte] = 0x5C;
		Eq_4 eax_72 = (word32) edx_29 + 1;
		if (eax_72 > ebx_30)
		{
			word32 esi_2088;
			word128 xmm0_2089;
			word128 xmm1_2090;
			runtime.growslice(gs, 0x080CF320, ebp_105, edx_29, ebx_30, eax_72, out esi_2088, out xmm0_2089, out xmm1_2090);
			ebp_105 = dwLoc28;
		}
		Mem120[ebp_105 + edx_29:byte] = SLICE(dwArg10, byte, 0);
		return;
	}
	if (bArg15 != 0x00)
	{
		if (dwArg10 < 0x80)
		{
			strconv.IsPrint(gs, dwArg10);
			if (bLoc38 != 0x00)
			{
				Eq_4 ebx_332;
				if (dwArg08 + 0x01 <= dwArg0C)
					ebx_332 = dwArg04;
				else
				{
					word128 xmm1_2003;
					word128 xmm0_2002;
					word32 esi_2001;
					runtime.growslice(gs, 0x080CF320, dwArg04, dwArg08, dwArg0C, dwArg08 + 0x01, out esi_2001, out xmm0_2002, out xmm1_2003);
					ebx_332 = dwLoc28;
				}
				Mem348[ebx_332 + dwArg08:byte] = SLICE(dwArg10, byte, 0);
				return;
			}
		}
		goto l08098BF7;
	}
	strconv.IsPrint(gs, dwArg10);
	if (bLoc38 == 0x00)
	{
		if (bArg16 == 0x00)
		{
l08098BF7:
			if (dwArg10 <= 0x09)
			{
				if (dwArg10 == 0x07)
				{
					Eq_4 ebx_717;
					Eq_4 edx_687 = dwArg0C;
					if (dwArg08 + 0x02 <=u dwArg0C)
						ebx_717 = dwArg04;
					else
					{
						word32 esi_2040;
						word128 xmm0_2041;
						word128 xmm1_2042;
						runtime.growslice(gs, 0x080CF320, dwArg04, dwArg08, dwArg0C, dwArg08 + 0x02, out esi_2040, out xmm0_2041, out xmm1_2042);
						ebx_717 = dwLoc28;
						edx_687 = dwLoc20;
					}
					if (dwArg08 + 0x02 >u edx_687)
						runtime.panicslice(gs);
					else
					{
						word32 ebp_2043;
						word32 esi_2044;
						word32 edi_2045;
						word128 xmm0_2046;
						word128 xmm1_2047;
						word128 xmm2_2048;
						runtime.memmove(dwArg08 + ebx_717, 135138811, 0x02, out ebp_2043, out esi_2044, out edi_2045, out xmm0_2046, out xmm1_2047, out xmm2_2048);
						return;
					}
				}
				if (dwArg10 == 0x08)
				{
					Eq_4 ebx_797;
					Eq_4 edx_766 = dwArg0C;
					if (dwArg08 + 0x02 <=u dwArg0C)
						ebx_797 = dwArg04;
					else
					{
						word32 esi_2031;
						word128 xmm0_2032;
						word128 xmm1_2033;
						runtime.growslice(gs, 0x080CF320, dwArg04, dwArg08, dwArg0C, dwArg08 + 0x02, out esi_2031, out xmm0_2032, out xmm1_2033);
						edx_766 = dwLoc20;
						ebx_797 = dwLoc28;
					}
					if (dwArg08 + 0x02 >u edx_766)
						runtime.panicslice(gs);
					else
					{
						word32 ebp_2034;
						word32 esi_2035;
						word32 edi_2036;
						word128 xmm0_2037;
						word128 xmm1_2038;
						word128 xmm2_2039;
						runtime.memmove(dwArg08 + ebx_797, 135138813, 0x02, out ebp_2034, out esi_2035, out edi_2036, out xmm0_2037, out xmm1_2038, out xmm2_2039);
						return;
					}
				}
				if (dwArg10 == 0x09)
				{
					Eq_4 ebx_875;
					Eq_4 edx_845 = dwArg0C;
					if (dwArg08 + 0x02 <=u dwArg0C)
						ebx_875 = dwArg04;
					else
					{
						word128 xmm1_1991;
						word128 xmm0_1990;
						word32 esi_1989;
						runtime.growslice(gs, 0x080CF320, dwArg04, dwArg08, dwArg0C, dwArg08 + 0x02, out esi_1989, out xmm0_1990, out xmm1_1991);
						ebx_875 = dwLoc28;
						edx_845 = dwLoc20;
					}
					if (dwArg08 + 0x02 >u edx_845)
						runtime.panicslice(gs);
					else
					{
						word128 xmm2_1997;
						word128 xmm1_1996;
						word32 edi_1994;
						word128 xmm0_1995;
						word32 esi_1993;
						word32 ebp_1992;
						runtime.memmove(dwArg08 + ebx_875, 0x080E0E05, 0x02, out ebp_1992, out esi_1993, out edi_1994, out xmm0_1995, out xmm1_1996, out xmm2_1997);
						return;
					}
				}
			}
			else
			{
				if (dwArg10 <= 11)
				{
					if (dwArg10 != 0x0A)
					{
						Eq_4 ebx_403;
						Eq_4 edx_371 = dwArg0C;
						if (dwArg08 + 0x02 <=u dwArg0C)
							ebx_403 = dwArg04;
						else
						{
							word32 esi_2067;
							word128 xmm0_2068;
							word128 xmm1_2069;
							runtime.growslice(gs, 0x080CF320, dwArg04, dwArg08, dwArg0C, dwArg08 + 0x02, out esi_2067, out xmm0_2068, out xmm1_2069);
							ebx_403 = dwLoc28;
							edx_371 = dwLoc20;
						}
						if (dwArg08 + 0x02 >u edx_371)
							runtime.panicslice(gs);
						else
						{
							word32 ebp_2070;
							word32 esi_2071;
							word32 edi_2072;
							word128 xmm0_2073;
							word128 xmm1_2074;
							word128 xmm2_2075;
							runtime.memmove(dwArg08 + ebx_403, 0x080E0E09, 0x02, out ebp_2070, out esi_2071, out edi_2072, out xmm0_2073, out xmm1_2074, out xmm2_2075);
							return;
						}
					}
					else
					{
						Eq_4 ebx_480;
						Eq_4 edx_450 = dwArg0C;
						if (dwArg08 + 0x02 <=u dwArg0C)
							ebx_480 = dwArg04;
						else
						{
							word32 esi_2058;
							word128 xmm0_2059;
							word128 xmm1_2060;
							runtime.growslice(gs, 0x080CF320, dwArg04, dwArg08, dwArg0C, dwArg08 + 0x02, out esi_2058, out xmm0_2059, out xmm1_2060);
							ebx_480 = dwLoc28;
							edx_450 = dwLoc20;
						}
						if (dwArg08 + 0x02 >u edx_450)
							runtime.panicslice(gs);
						else
						{
							word32 ebp_2061;
							word32 esi_2062;
							word32 edi_2063;
							word128 xmm0_2064;
							word128 xmm1_2065;
							word128 xmm2_2066;
							runtime.memmove(dwArg08 + ebx_480, 0x080E0E01, 0x02, out ebp_2061, out esi_2062, out edi_2063, out xmm0_2064, out xmm1_2065, out xmm2_2066);
							return;
						}
					}
				}
				if (dwArg10 == 0x0C)
				{
					Eq_4 ebx_559;
					Eq_4 edx_529 = dwArg0C;
					if (dwArg08 + 0x02 <=u dwArg0C)
						ebx_559 = dwArg04;
					else
					{
						word32 esi_2076;
						word128 xmm0_2077;
						word128 xmm1_2078;
						runtime.growslice(gs, 0x080CF320, dwArg04, dwArg08, dwArg0C, dwArg08 + 0x02, out esi_2076, out xmm0_2077, out xmm1_2078);
						ebx_559 = dwLoc28;
						edx_529 = dwLoc20;
					}
					if (dwArg08 + 0x02 >u edx_529)
						runtime.panicslice(gs);
					else
					{
						word32 ebp_2079;
						word32 esi_2080;
						word32 edi_2081;
						word128 xmm0_2082;
						word128 xmm1_2083;
						word128 xmm2_2084;
						runtime.memmove(dwArg08 + ebx_559, 135138815, 0x02, out ebp_2079, out esi_2080, out edi_2081, out xmm0_2082, out xmm1_2083, out xmm2_2084);
						return;
					}
				}
				if (dwArg10 == 0x0D)
				{
					Eq_4 ebx_638;
					Eq_4 edx_608 = dwArg0C;
					if (dwArg08 + 0x02 <=u dwArg0C)
						ebx_638 = dwArg04;
					else
					{
						word32 esi_2049;
						word128 xmm0_2050;
						word128 xmm1_2051;
						runtime.growslice(gs, 0x080CF320, dwArg04, dwArg08, dwArg0C, dwArg08 + 0x02, out esi_2049, out xmm0_2050, out xmm1_2051);
						ebx_638 = dwLoc28;
						edx_608 = dwLoc20;
					}
					if (dwArg08 + 0x02 >u edx_608)
						runtime.panicslice(gs);
					else
					{
						word32 ebp_2052;
						word32 esi_2053;
						word32 edi_2054;
						word128 xmm0_2055;
						word128 xmm1_2056;
						word128 xmm2_2057;
						runtime.memmove(dwArg08 + ebx_638, 0x080E0E03, 0x02, out ebp_2052, out esi_2053, out edi_2054, out xmm0_2055, out xmm1_2056, out xmm2_2057);
						return;
					}
				}
			}
			if (dwArg10 < 0x20)
			{
				Eq_4 ebp_958;
				Eq_4 ebx_927 = dwArg0C;
				if (dwArg08 + 0x02 <=u dwArg0C)
					ebp_958 = dwArg04;
				else
				{
					word128 xmm0_2014;
					word128 xmm1_2015;
					word32 esi_2013;
					runtime.growslice(gs, 0x080CF320, dwArg04, dwArg08, dwArg0C, dwArg08 + 0x02, out esi_2013, out xmm0_2014, out xmm1_2015);
					ebp_958 = dwLoc28;
					ebx_927 = dwLoc20;
				}
				if (dwArg08 + 0x02 >u ebx_927)
					runtime.panicslice(gs);
				else
				{
					word32 esi_2017;
					word32 ebp_2016;
					word128 xmm1_2020;
					word128 xmm2_2021;
					word128 xmm0_2019;
					word32 edi_2018;
					runtime.memmove(dwArg08 + ebp_958, 0x080E0E0B, 0x02, out ebp_2016, out esi_2017, out edi_2018, out xmm0_2019, out xmm1_2020, out xmm2_2021);
					struct Eq_100177 * eax_1003 = (word32) ((byte) dwArg10 >> 0x04);
					if (eax_1003 >= (struct Eq_100177 *) 0x10)
						runtime.panicindex(gs);
					else
					{
						Eq_4 edi_1043;
						word32 ebx_1007 = dwArg08 + 0x03;
						byte al_1013 = eax_1003->b80E2469;
						Eq_4 esi_1010 = ebx_927;
						if (dwArg08 + 0x03 <= ebx_927)
							edi_1043 = ebp_958;
						else
						{
							word128 xmm0_2023;
							word32 esi_2022;
							word128 xmm1_2024;
							runtime.growslice(gs, 0x080CF320, ebp_958, dwArg08 + 0x02, ebx_927, dwArg08 + 0x03, out esi_2022, out xmm0_2023, out xmm1_2024);
							edi_1043 = dwLoc28;
							esi_1010 = dwLoc20;
							ebx_1007 = dwLoc24 + 0x01;
						}
						Mem1056[dwArg08 + 0x02 + edi_1043:byte] = al_1013;
						word32 eax_1058 = ebx_1007 + 0x01;
						byte cl_1068 = (dwArg10 & 0x0F)->b80E2469;
						if (eax_1058 > esi_1010)
						{
							word32 esi_2025;
							word128 xmm0_2026;
							word128 xmm1_2027;
							runtime.growslice(gs, 0x080CF320, edi_1043, ebx_1007, esi_1010, eax_1058, out esi_2025, out xmm0_2026, out xmm1_2027);
							edi_1043 = dwLoc28;
						}
						Mem1108[edi_1043 + ebx_1007:byte] = cl_1068;
						return;
					}
				}
			}
			else
			{
				Eq_4 eax_1280;
				if (dwArg10 > 1114111)
					eax_1280.u0 = 0xFFFD;
				else
				{
					if (dwArg10 >= 0x00010000)
					{
						Eq_4 ebp_1151;
						Eq_4 ebx_1121 = dwArg0C;
						if (dwArg08 + 0x02 <=u dwArg0C)
							ebp_1151 = dwArg04;
						else
						{
							word128 xmm1_2006;
							word128 xmm0_2005;
							word32 esi_2004;
							runtime.growslice(gs, 0x080CF320, dwArg04, dwArg08, dwArg0C, dwArg08 + 0x02, out esi_2004, out xmm0_2005, out xmm1_2006);
							ebp_1151 = dwLoc28;
							ebx_1121 = dwLoc20;
						}
						if (dwArg08 + 0x02 >u ebx_1121)
							runtime.panicslice(gs);
						else
						{
							word128 xmm1_2011;
							word128 xmm0_2010;
							word128 xmm2_2012;
							word32 ebp_2007;
							word32 edi_2009;
							word32 esi_2008;
							runtime.memmove(dwArg08 + ebp_1151, 0x080E0DF9, 0x02, out ebp_2007, out esi_2008, out edi_2009, out xmm0_2010, out xmm1_2011, out xmm2_2012);
							Eq_100140 eax_1193;
							Eq_4 ecx_1194 = ebx_1121;
							Eq_4 edx_1195 = ebp_1151;
							word32 ebx_1196 = dwArg08 + 0x02;
							for (eax_1193 = 0x1C; eax_1193 >= 0x00; eax_1193 -= 0x04)
							{
								word32 ebp_1204 = ebx_1196 + 0x01;
								Eq_4 edi_1217 = ecx_1194;
								byte al_1230 = (dwArg10 >> (byte) (~(0x00 - (eax_1193 < 0x20)) | eax_1193) & 0x0F)->b80E2469;
								if (ebp_1204 > ecx_1194)
								{
									word32 esi_2028;
									word128 xmm0_2029;
									word128 xmm1_2030;
									runtime.growslice(gs, 0x080CF320, edx_1195, ebx_1196, ecx_1194, ebp_1204, out esi_2028, out xmm0_2029, out xmm1_2030);
									edx_1195 = dwLoc28;
									edi_1217 = dwLoc20;
									ebp_1204 = dwLoc24 + 0x01;
								}
								Mem1272[edx_1195 + ebx_1196:byte] = al_1230;
								ecx_1194 = edi_1217;
								ebx_1196 = ebp_1204;
							}
							return;
						}
					}
					eax_1280 = dwArg10;
				}
				Eq_4 ebp_1319;
				Eq_4 ebx_1288 = dwArg0C;
				if (dwArg08 + 0x02 <=u dwArg0C)
					ebp_1319 = dwArg04;
				else
				{
					word128 xmm1_1982;
					word128 xmm0_1981;
					word32 esi_1980;
					runtime.growslice(gs, 0x080CF320, dwArg04, dwArg08, dwArg0C, dwArg08 + 0x02, out esi_1980, out xmm0_1981, out xmm1_1982);
					ebp_1319 = dwLoc28;
					ebx_1288 = dwLoc20;
				}
				if (dwArg08 + 0x02 >u ebx_1288)
					runtime.panicslice(gs);
				else
				{
					word128 xmm2_1988;
					word128 xmm1_1987;
					word128 xmm0_1986;
					word32 edi_1985;
					word32 esi_1984;
					word32 ebp_1983;
					runtime.memmove(dwArg08 + ebp_1319, 0x080E0E07, 0x02, out ebp_1983, out esi_1984, out edi_1985, out xmm0_1986, out xmm1_1987, out xmm2_1988);
					Eq_100011 eax_1360;
					Eq_4 ecx_1361 = ebx_1288;
					Eq_4 edx_1362 = ebp_1319;
					word32 ebx_1363 = dwArg08 + 0x02;
					for (eax_1360 = 0x0C; eax_1360 >= 0x00; eax_1360 -= 0x04)
					{
						Eq_4 ebp_1383 = (word32) ebx_1363 + 1;
						Eq_4 edi_1395 = ecx_1361;
						byte al_1407 = (eax_1280 >> (byte) (~(0x00 - (eax_1360 < 0x20)) | eax_1360) & 0x0F)->b80E2469;
						if (ebp_1383 > ecx_1361)
						{
							word128 xmm0_1999;
							word32 esi_1998;
							word128 xmm1_2000;
							runtime.growslice(gs, 0x080CF320, edx_1362, ebx_1363, ecx_1361, ebp_1383, out esi_1998, out xmm0_1999, out xmm1_2000);
							edx_1362 = dwLoc28;
							edi_1395 = dwLoc20;
							ebp_1383 = dwLoc24 + 0x01;
						}
						Mem1449[edx_1362 + ebx_1363:byte] = al_1407;
						ecx_1361 = edi_1395;
						ebx_1363 = ebp_1383;
					}
					return;
				}
			}
		}
		strconv.isInGraphicList(gs, dwArg10);
		if (bLoc38 == 0x00)
			goto l0809948A;
	}
	unicode/utf8.EncodeRune(gs, fp - 0x10, 0x04, dwArg10);
	if (dwLoc2C <= 0x04)
	{
		Eq_4 ebp_227;
		word32 edx_193 = dwArg08 + dwLoc2C;
		Eq_4 ebx_195 = dwArg0C;
		if (edx_193 <= dwArg0C)
			ebp_227 = dwArg04;
		else
		{
			word32 esi_2091;
			word128 xmm0_2092;
			word128 xmm1_2093;
			runtime.growslice(gs, 0x080CF320, dwArg04, dwArg08, dwArg0C, edx_193, out esi_2091, out xmm0_2092, out xmm1_2093);
			ebx_195 = dwLoc20;
			ebp_227 = dwLoc28;
		}
		if (edx_193 <= ebx_195)
		{
			word32 ebp_2094;
			word32 esi_2095;
			word32 edi_2096;
			word128 xmm0_2097;
			word128 xmm1_2098;
			word128 xmm2_2099;
			runtime.memmove(dwArg08 + ebp_227, fp - 0x10, dwLoc2C, out ebp_2094, out esi_2095, out edi_2096, out xmm0_2097, out xmm1_2098, out xmm2_2099);
			return;
		}
	}
	runtime.panicslice(gs);
}

// subject_text_0005.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 08099680: void strconv.AppendQuote(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C, Stack (ptr32 Eq_93084) dwArg10, Stack Eq_4 dwArg14)
// Called from:
//      fmt.(*fmt).fmt_q
void strconv.AppendQuote(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C, struct Eq_93084 * dwArg10, Eq_4 dwArg14)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	strconv.appendQuotedWith(gs, dwArg04, dwArg08, dwArg0C, dwArg10, dwArg14, 0x22, 0x00, 0x00);
}

// 080996F0: void strconv.AppendQuoteToASCII(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C, Stack (ptr32 Eq_93084) dwArg10, Stack Eq_4 dwArg14)
// Called from:
//      fmt.(*fmt).fmt_q
void strconv.AppendQuoteToASCII(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C, struct Eq_93084 * dwArg10, Eq_4 dwArg14)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	strconv.appendQuotedWith(gs, dwArg04, dwArg08, dwArg0C, dwArg10, dwArg14, 0x22, 0x01, 0x00);
}

// 08099760: void strconv.AppendQuoteRune(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C, Stack Eq_4 dwArg10)
// Called from:
//      fmt.(*fmt).fmt_qc
void strconv.AppendQuoteRune(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C, Eq_4 dwArg10)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	strconv.appendQuotedRuneWith(gs, dwArg04, dwArg08, dwArg0C, dwArg10, 0x27, 0x00, 0x00);
}

// 080997D0: void strconv.AppendQuoteRuneToASCII(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C, Stack Eq_4 dwArg10)
// Called from:
//      fmt.(*fmt).fmt_qc
void strconv.AppendQuoteRuneToASCII(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C, Eq_4 dwArg10)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	strconv.appendQuotedRuneWith(gs, dwArg04, dwArg08, dwArg0C, dwArg10, 0x27, 0x01, 0x00);
}

// 08099840: void strconv.CanBackquote(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_93084) dwArg04, Stack Eq_4 dwArg08)
// Called from:
//      fmt.(*fmt).fmt_q
void strconv.CanBackquote(struct Eq_2 * gs, struct Eq_93084 * dwArg04, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	struct Eq_93084 * eax_18 = dwArg04;
	Eq_4 ecx_19 = dwArg08;
	while (ecx_19 > 0x00)
	{
		unicode/utf8.DecodeRuneInString(gs, eax_18, ecx_19);
		if (dwLoc04 > ecx_19)
			runtime.panicslice(gs);
		Eq_4 edx_49 = ecx_19 - dwLoc04;
		struct Eq_93084 * edx_55 = eax_18 + (-edx_49 >> 0x1F & dwLoc04) / 4;
		if (dwLoc04 > 0x01)
		{
			if (dwLoc08 == 0xFEFF)
				return;
		}
		else
		{
			if (dwLoc08 == 0xFFFD)
				return;
			if (dwLoc08 < 0x20 && dwLoc08 != 0x09 || (dwLoc08 == 0x60 || dwLoc08 == 0x7F))
				return;
		}
		eax_18 = edx_55;
		ecx_19 = edx_49;
	}
}

// 08099900: Register (ptr32 (arr cup16)) strconv.bsearch16(Register (ptr32 Eq_2) gs, Stack (arr cup16) dwArg04, Stack Eq_100711 dwArg08, Stack cup16 wArg10)
// Called from:
//      strconv.IsPrint
//      strconv.isInGraphicList
cup16 (* strconv.bsearch16)[](struct Eq_2 * gs, cup16 dwArg04[], Eq_100711 dwArg08, cup16 wArg10)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_100711 edx_18 = dwArg08;
	Eq_100711 ebp_20 = 0x00;
	while (ebp_20 < edx_18)
	{
		int32 edx_30 = edx_18 - ebp_20;
		Eq_100731 edx_34 = (edx_30 >> 0x1F >> 0x1F) + edx_30;
		Eq_100711 esi_29 = edx_18;
		Eq_100711 edi_36 = (word32) ebp_20.u0 + (edx_34 >> 0x01);
		if (edi_36 >= dwArg08)
			runtime.panicindex(gs);
		Eq_100711 ecx_49;
		if (dwArg04[edi_36] < wArg10)
			ecx_49 = (word32) ebp_20.u0 + ((edx_34 >> 0x01) + 0x01);
		else
		{
			esi_29 = edi_36;
			ecx_49 = ebp_20;
		}
		edi = dwArg04;
		ebp_20 = ecx_49;
		edx_18 = esi_29;
	}
	return edi;
}

// 08099980: Register (ptr32 (arr Eq_4)) strconv.bsearch32(Register (ptr32 Eq_2) gs, Stack (arr Eq_4) dwArg04, Stack Eq_100711 dwArg08, Stack Eq_4 dwArg10)
// Called from:
//      strconv.IsPrint
Eq_4 (* strconv.bsearch32)[](struct Eq_2 * gs, Eq_4 dwArg04[], Eq_100711 dwArg08, Eq_4 dwArg10)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_100711 edx_18 = dwArg08;
	Eq_100711 ebp_20 = 0x00;
	while (ebp_20 < edx_18)
	{
		int32 edx_30 = edx_18 - ebp_20;
		Eq_100777 edx_34 = (edx_30 >> 0x1F >> 0x1F) + edx_30;
		Eq_100711 esi_29 = edx_18;
		Eq_100711 edi_36 = (word32) ebp_20.u0 + (edx_34 >> 0x01);
		if (edi_36 >= dwArg08)
			runtime.panicindex(gs);
		Eq_100711 ecx_48;
		if (dwArg04[edi_36] < dwArg10)
			ecx_48 = (word32) ebp_20.u0 + ((edx_34 >> 0x01) + 0x01);
		else
		{
			esi_29 = edi_36;
			ecx_48 = ebp_20;
		}
		edi = dwArg04;
		ebp_20 = ecx_48;
		edx_18 = esi_29;
	}
	return edi;
}

// 080999F0: Register word32 strconv.IsPrint(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      strconv.appendEscapedRune
//      fmt.(*fmt).fmt_unicode
word32 strconv.IsPrint(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	cup16 ax_131 = (word16) dwArg04;
	if (dwArg04 > 0xFF)
	{
		if (dwArg04 >= 0x00010000)
		{
			Eq_100711 ecx_22 = g_t8142754;
			Eq_4 edx_24[] = g_ptr8142750;
			Eq_100711 ebp_27 = g_t8142734;
			cup16 (* esi_29)[] = g_ptr8142730;
			word32 edi_42 = strconv.bsearch32(gs, edx_24, ecx_22, dwArg04);
			if (dwLoc2C >= ecx_22)
				return edi_42;
			if ((dwLoc2C & ~0x01) < ecx_22)
			{
				if (dwArg04 < edx_24[dwLoc2C & ~0x01])
					return edi_42;
				if ((dwLoc2C | 0x01) < ecx_22)
				{
					if (edx_24[dwLoc2C | 0x01] < dwArg04)
						return edi_42;
					if (dwArg04 >= 0x00020000)
						return edi_42;
					word32 edi_87 = strconv.bsearch16(gs, esi_29, ebp_27, (word16) dwArg04);
					if (dwLoc2C >= ebp_27 || dwLoc2C < ebp_27)
						return edi_87;
					runtime.panicindex(gs);
				}
			}
			runtime.panicindex(gs);
		}
		else
		{
			Eq_100711 ecx_117 = g_t8142744;
			cup16 edx_119[] = g_ptr8142740;
			cup16 (* esi_124)[] = g_ptr8142720;
			Eq_100711 edi_126 = g_t8142724;
			word32 edi_137 = strconv.bsearch16(gs, edx_119, ecx_117, ax_131);
			if (dwLoc2C >= ecx_117)
				return edi_137;
			if ((dwLoc2C & ~0x01) < ecx_117)
			{
				cup16 bp_154 = (word16) dwArg04;
				if (bp_154 < edx_119[dwLoc2C & ~0x01])
					return edi_137;
				if ((dwLoc2C | 0x01) < ecx_117)
				{
					if (edx_119[dwLoc2C | 0x01] < bp_154)
						return edi_137;
					word32 edi_177 = strconv.bsearch16(gs, esi_124, edi_126, bp_154);
					if (dwLoc2C >= edi_126 || dwLoc2C < edi_126)
						return edi_177;
					runtime.panicindex(gs);
				}
			}
			runtime.panicindex(gs);
		}
	}
	else
	{
		if (dwArg04 <= 0x7E)
			return edi;
		if (dwArg04 > 0xFF)
			return edi;
		return edi;
	}
}

// 08099C60: void strconv.isInGraphicList(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      strconv.appendEscapedRune
void strconv.isInGraphicList(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	cup16 ax_29 = (word16) dwArg04;
	if (dwArg04 > 0xFFFF)
		return;
	strconv.bsearch16(gs, g_ptr8142710, g_t8142714, ax_29);
	Eq_100711 edx_43 = g_t8142714;
	if (dwLoc04 >= edx_43 || dwLoc04 < edx_43)
		return;
	runtime.panicindex(gs);
}

// 08099D00: void strconv.init(Register (ptr32 Eq_2) gs)
// Called from:
//      reflect.init
//      fmt.init
void strconv.init(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	cu8 al_18 = g_b8157584;
	if (al_18 > 0x01)
		return;
	if (al_18 != 0x01)
	{
		g_b8157584 = 0x01;
		errors.New(gs, 0x080E2B14, 0x12);
		g_dw81450B0 = dwLoc08;
		if (g_t81576F0 == 0x00)
			g_t81450B4 = dwLoc04;
		else
			runtime.writebarrierptr(0x081450B4, dwLoc04);
		errors.New(gs, 0x080E2142, 0x0E);
		g_dw81450B8 = dwLoc08;
		if (g_t81576F0 == 0x00)
			g_t81450BC = dwLoc04;
		else
			runtime.writebarrierptr(135549116, dwLoc04);
		g_b8157584 = 0x02;
	}
	else
		runtime.throwinit(gs);
}

// 08099DE0: void type..hash.strconv.decimal(Register (ptr32 Eq_2) gs, Register Eq_4 mm0, Stack (ptr32 Eq_205) dwArg04, Stack (ptr32 Eq_205) dwArg08)
void type..hash.strconv.decimal(struct Eq_2 * gs, Eq_4 mm0, union Eq_205 * dwArg04, union Eq_205 * dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	word128 xmm1_65;
	runtime.memhash(gs, mm0, dwArg04, dwArg08, 0x032A, out xmm1_65);
}

// 08099E30: void type..eq.strconv.decimal(Register Eq_4 edx, Register (ptr32 Eq_101025) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
void type..eq.strconv.decimal(Eq_4 edx, struct Eq_101025 * gs, Eq_4 dwArg04, Eq_4 dwArg08)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		edx = runtime.morestack_noctxt();
	word32 ebx_58;
	word32 esi_59;
	word32 edi_60;
	runtime.memequal(edx, dwArg04, dwArg08, 0x032A, out ebx_58, out esi_59, out edi_60);
}

// 08099E80: Register Eq_4 type..hash.strconv.extFloat(Register (ptr32 Eq_2) gs, Register Eq_4 mm0, Stack (ptr32 Eq_205) dwArg04, Stack (ptr32 Eq_205) dwArg08)
// Called from:
//      type..hash.[87]strconv.extFloat
Eq_4 type..hash.strconv.extFloat(struct Eq_2 * gs, Eq_4 mm0, union Eq_205 * dwArg04, union Eq_205 * dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	word128 xmm1_65;
	return runtime.memhash(gs, mm0, dwArg04, dwArg08, 0x0D, out xmm1_65);
}

// 08099ED0: void type..eq.strconv.extFloat(Register Eq_4 edx, Register (ptr32 Eq_101071) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
void type..eq.strconv.extFloat(Eq_4 edx, struct Eq_101071 * gs, Eq_4 dwArg04, Eq_4 dwArg08)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		edx = runtime.morestack_noctxt();
	word32 ebx_58;
	word32 esi_59;
	word32 edi_60;
	runtime.memequal(edx, dwArg04, dwArg08, 0x0D, out ebx_58, out esi_59, out edi_60);
}

// 08099F20: Register Eq_4 type..hash.strconv.leftCheat(Register (ptr32 Eq_2) gs, Register Eq_4 mm0, Stack (ptr32 Eq_205) dwArg04, Stack (ptr32 Eq_205) dwArg08)
// Called from:
//      type..hash.[61]strconv.leftCheat
Eq_4 type..hash.strconv.leftCheat(struct Eq_2 * gs, Eq_4 mm0, union Eq_205 * dwArg04, union Eq_205 * dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	word128 xmm1_92;
	return runtime.strhash(gs, runtime.memhash(gs, mm0, dwArg04, dwArg08, 0x04, out xmm1_92), (char *) dwArg04 + 4, dwLoc04);
}

// 08099F80: void type..eq.strconv.leftCheat(Register (ptr32 Eq_101121) gs, Stack (ptr32 Eq_101122) dwArg04, Stack (ptr32 Eq_101123) dwArg08)
void type..eq.strconv.leftCheat(struct Eq_101121 * gs, struct Eq_101122 * dwArg04, struct Eq_101123 * dwArg08)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	if (dwArg04->dw0000 == dwArg08->dw0000)
	{
		Eq_4 edx_27 = dwArg08->t0004;
		Eq_4 ebx_28 = dwArg04->t0008;
		Eq_4 eax_29 = dwArg04->t0004;
		if (ebx_28 == dwArg08->t0008)
		{
			word32 ebx_94;
			word32 esi_95;
			word32 edi_96;
			runtime.eqstring(edx_27, eax_29, ebx_28, edx_27, out ebx_94, out esi_95, out edi_96);
		}
	}
}

// 08099FF0: void type..hash.[61]strconv.leftCheat(Register (ptr32 Eq_2) gs, Register Eq_4 mm0, Stack word32 dwArg04, Stack (ptr32 Eq_205) dwArg08)
void type..hash.[61]strconv.leftCheat(struct Eq_2 * gs, Eq_4 mm0, word32 dwArg04, union Eq_205 * dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	int32 eax_17;
	union Eq_205 * ecx_20 = dwArg08;
	for (eax_17 = 0x00; eax_17 < 0x3D; ++eax_17)
	{
		mm0 = type..hash.strconv.leftCheat(gs, mm0, dwArg04 + eax_17 * 0x0C, ecx_20);
		ecx_20 = dwLoc08;
	}
}

// 0809A050: void type..eq.[61]strconv.leftCheat(Register (ptr32 Eq_101197) gs, Stack Eq_4 dwArg04, Stack (ptr32 Eq_101199) dwArg08)
void type..eq.[61]strconv.leftCheat(struct Eq_101197 * gs, Eq_4 dwArg04, struct Eq_101199 * dwArg08)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	int32 eax_17;
	for (eax_17 = 0x00; eax_17 < 0x3D; ++eax_17)
	{
		ui32 ecx_27 = eax_17 * 0x03;
		if (*((word32) dwArg04 + ecx_27 * 0x04) != dwArg08[(ecx_27 * 0x04) / 8])
			return;
		Eq_4 ebx_35 = dwArg08->a0004[ecx_27];
		Eq_4 edi_37 = *((word32) dwArg04 + (ecx_27 * 0x04 + 8));
		Eq_4 ecx_38 = *((word32) dwArg04 + (ecx_27 * 0x04 + 4));
		if (edi_37 != (dwArg08->a0008)[ecx_27])
			return;
		word32 ebx_132;
		word32 esi_133;
		word32 edi_134;
		runtime.eqstring(dwArg04, ecx_38, edi_37, ebx_35, out ebx_132, out esi_133, out edi_134);
		if (bLoc08 == 0x00)
			return;
	}
}

// 0809A0E0: void type..hash.[87]strconv.extFloat(Register (ptr32 Eq_2) gs, Register Eq_4 mm0, Stack word32 dwArg04, Stack (ptr32 Eq_205) dwArg08)
void type..hash.[87]strconv.extFloat(struct Eq_2 * gs, Eq_4 mm0, word32 dwArg04, union Eq_205 * dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	int32 eax_17;
	union Eq_205 * ecx_20 = dwArg08;
	for (eax_17 = 0x00; eax_17 < 0x57; ++eax_17)
	{
		mm0 = type..hash.strconv.extFloat(gs, mm0, (eax_17 << 0x04) + dwArg04, ecx_20);
		ecx_20 = dwLoc08;
	}
}

// 0809A140: void type..eq.[87]strconv.extFloat(Register (ptr32 Eq_101293) gs, Stack (ptr32 (arr Eq_101319)) dwArg04, Stack (arr Eq_101319) dwArg08)
void type..eq.[87]strconv.extFloat(struct Eq_101293 * gs, Eq_101319 (* dwArg04)[], Eq_101319 dwArg08[])
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	int32 edx_19;
	for (edx_19 = 0x00; edx_19 < 0x57; ++edx_19)
	{
		Eq_101319 (* edx_30)[] = edx_19 << 0x04;
		word32 ebp_32 = dwArg08[edx_19 * 4];
		word32 ebx_36 = Mem29[edx_30 + 0x04 + dwArg04:word32];
		if ((CONVERT(ebx_36 != Mem29[(edx_30 + 0x04) + dwArg08:word32], bool, int8) | CONVERT(dwArg04[edx_19 * 0x10] != ebp_32, bool, int8)) != 0x00 || (Mem29[(edx_30 + 0x08) + dwArg04:word32] != Mem29[(edx_30 + 0x08) + dwArg08:word32] || Mem29[(edx_30 + 0x0C) + dwArg04:byte] != Mem29[(edx_30 + 0x0C) + dwArg08:byte]))
			return;
	}
}

// 0809A1D0: void sync.(*Map).Load(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 bArg0C)
// Called from:
//      reflect.(*rtype).exportedMethods
//      reflect.(*rtype).ptrTo
//      reflect.FuncOf
//      reflect.funcLayout
//      reflect.FuncOf.func1
void sync.(*Map).Load(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 bArg0C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 ecx_37;
	byte al_42;
	sync/atomic.(*Value).Load(gs, (word32) dwArg04 + 8);
	if (dwLoc34 == 0x080D4580)
	{
		al_42 = dwLoc30->b0004;
		ecx_37 = dwLoc30->t0000;
	}
	else
	{
		al_42 = 0x00;
		ecx_37.u0 = 0x00;
	}
	word32 esi_426;
	runtime.mapaccess2(gs, 0x080CFA80, ecx_37, fp - 0x18, out esi_426);
	uip32 ecx_222 = (word32) bLoc28;
	byte bLoc14_423 = (byte) dwArg0C;
	if ((byte) ecx_222 != 0x00)
		ecx_222 = 0x01;
	else if (al_42 != 0x00)
	{
		Eq_4 ecx_107;
		byte al_113;
		sync.(*Mutex).Lock(gs, dwArg04);
		sync/atomic.(*Value).Load(gs, (word32) dwArg04 + 8);
		if (ecx_37 == 0x080D4580)
		{
			ecx_107 = dwArg08;
			al_113 = bLoc14_423;
		}
		else
		{
			ecx_107.u0 = 0x00;
			al_113 = 0x00;
		}
		word32 esi_427;
		runtime.mapaccess2(gs, 0x080CFA80, ecx_107, fp - 0x08, out esi_427);
		byte cl_142 = bLoc28;
		if (bLoc28 != 0x00)
			cl_142 = 0x01;
		else if (al_113 != 0x00)
		{
			word32 esi_428;
			runtime.mapaccess2(gs, 0x080CFA80, *((word32) dwArg04 + 16), fp - 0x10, out esi_428);
			word128 xmm1_429;
			sync.(*Map).missLocked(gs, dwArg04, out xmm1_429);
			cl_142 = bLoc28;
		}
		sync.(*Mutex).Unlock(gs, dwArg04);
		ecx_222 = (word32) cl_142;
	}
	if ((byte) ecx_222 == 0x00)
		return;
	sync.(*entry).load(gs);
}

// 0809A3D0: void sync.(*entry).load(Register (ptr32 Eq_2) gs)
// Called from:
//      sync.(*Map).Load
void sync.(*entry).load(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	sync/atomic.LoadPointer();
	if (dwLoc04 == 0x00 || dwLoc04 == sync.expunged)
		;
}

// 0809A440: void sync.(*Map).Store(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 bArg0C, Stack Eq_4 dwArg10, Stack Eq_4 dwArg14)
// Called from:
//      reflect.FuncOf.func1
void sync.(*Map).Store(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 bArg0C, Eq_4 dwArg10, Eq_4 dwArg14)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 dwLoc5C_529;
	runtime.newobject(gs, 0x080CECA0);
	*dwLoc5C = dwArg10;
	Eq_4 esp_16 = fp - 0x60;
	if (g_t81576F0 == 0x00)
	{
		*((word32) dwLoc5C + 4) = dwArg14;
		dwLoc5C_529 = dwLoc5C;
	}
	else
	{
		runtime.writebarrierptr((word32) dwLoc5C + 4, dwArg14);
		dwLoc5C_529 = dwArg14;
	}
	Eq_4 eax_71;
	sync/atomic.(*Value).Load(gs, (word32) dwArg04 + 8);
	if (dwLoc5C_529 == 0x080D4580)
		eax_71 = *dwLoc58;
	else
		eax_71.u0 = 0x00;
	word32 esi_759;
	runtime.mapaccess2(gs, 0x080CFA80, eax_71, fp - 0x08, out esi_759);
	byte bLoc04_748 = (byte) dwArg0C;
	Eq_4 dwLoc5C_550 = eax_71;
	byte bLoc58_564 = (byte) fp - 0x08;
	Eq_4 eax_100 = *dwLoc54;
	if (bLoc50 != 0x00)
	{
		sync.(*entry).tryStore(gs, eax_100, dwLoc5C);
		dwLoc5C_550 = dwLoc5C;
		if (bLoc58_564 != 0x00)
			return;
	}
	Eq_4 ecx_154;
	byte al_159;
	Eq_4 edi_133 = sync.(*Mutex).Lock(gs, dwArg04);
	sync/atomic.(*Value).Load(gs, (word32) dwArg04 + 8);
	if (dwLoc5C_550 == 0x080D4580)
	{
		ecx_154 = dwArg08;
		al_159 = bLoc04_748;
	}
	else
	{
		al_159 = 0x00;
		ecx_154.u0 = 0x00;
	}
	word32 esi_757;
	runtime.mapaccess2(gs, 0x080CFA80, ecx_154, fp - 0x10, out esi_757);
	byte bLoc5C_609 = (byte) ecx_154;
	Eq_4 eax_188 = *dwLoc54;
	if (bLoc50 != 0x00)
	{
		sync.(*entry).unexpungeLocked(gs, eax_188);
		if (bLoc5C_609 != 0x00)
		{
			word128 xmm1_755;
			runtime.mapassign(gs, 0x080CFA80, *((word32) dwArg04 + 16), fp - 0x18, out xmm1_755);
			if (g_t81576F0 == 0x00)
				*dwLoc54 = eax_188;
			else
				runtime.writebarrierptr(dwLoc54, eax_188);
		}
		sync.(*entry).storeLocked(gs, eax_188, dwLoc5C);
	}
	else
	{
		Eq_4 esi_209;
		word32 * ebx_208 = runtime.mapaccess2(gs, 0x080CFA80, *((word32) dwArg04 + 16), fp - 0x20, out esi_209);
		Eq_4 eax_216 = *dwLoc54;
		if (bLoc50 == 0x00)
		{
			if (al_159 == 0x00)
			{
				Eq_4 ebx_241 = sync.(*Map).dirtyLocked(ebx_208, esi_209, edi_133, gs, dwLoc64, dwArg04);
				esp_16.u0 = <invalid>;
				*((byte) esp_16.u0 + 56) = *((byte) esp_16.u0 + 28);
				((byte) esp_16.u0 + 60)->u0 = 0x01;
				esp_16.u0->u0 = 0x080D4580;
				*((byte) esp_16.u0 + 4) = (byte) esp_16.u0 + 56;
				word128 xmm1_756;
				runtime.convT2E(ebx_241, gs, *esp_16.u0, *((byte) esp_16.u0 + 4), out xmm1_756);
				Eq_4 eax_284 = *((byte) esp_16.u0 + 0x0C);
				*((byte) esp_16.u0 + 4) = *((byte) esp_16.u0 + 8);
				*((byte) esp_16.u0 + 8) = eax_284;
				*esp_16.u0 = *((byte) esp_16.u0 + 36);
				sync/atomic.(*Value).Store(gs, *esp_16.u0, *((byte) esp_16.u0 + 4), *((byte) esp_16.u0 + 8));
			}
			*((byte) esp_16.u0 + 48) = *((byte) esp_16.u0 + 0x0068);
			*((byte) esp_16.u0 + 52) = *((byte) esp_16.u0 + 0x006C);
			esp_16.u0->u0 = 0x080CECA0;
			runtime.newobject(gs, *esp_16.u0);
			Eq_4 eax_314 = *((byte) esp_16.u0 + 40);
			word32 ecx_315 = *eax_314;
			Eq_4 eax_316 = *((word32) eax_314 + 4);
			Eq_4 edx_317 = *((byte) esp_16.u0 + 4);
			*((byte) esp_16.u0 + 44) = edx_317;
			*edx_317 = ecx_315;
			if (g_t81576F0 == 0x00)
				*((word32) edx_317 + 4) = eax_316;
			else
			{
				*esp_16.u0 = (word32) edx_317 + 4;
				*((byte) esp_16.u0 + 4) = eax_316;
				runtime.writebarrierptr(*esp_16.u0, *((byte) esp_16.u0 + 4));
			}
			esp_16.u0->u0 = 0x080D1CE0;
			runtime.newobject(gs, *esp_16.u0);
			Eq_4 eax_347 = *((byte) esp_16.u0 + 4);
			*((byte) esp_16.u0 + 24) = eax_347;
			if (g_t81576F0 == 0x00)
				*eax_347 = *((byte) esp_16.u0 + 44);
			else
			{
				*esp_16.u0 = eax_347;
				*((byte) esp_16.u0 + 4) = *((byte) esp_16.u0 + 44);
				runtime.writebarrierptr(*esp_16.u0, *((byte) esp_16.u0 + 4));
			}
			*((byte) esp_16.u0 + 4) = *((word32) *((byte) esp_16.u0 + 100) + 16);
			esp_16.u0->u0 = 0x080CFA80;
			*((byte) esp_16.u0 + 8) = (byte) esp_16.u0 + 48;
			word128 xmm1_758;
			runtime.mapassign(gs, *esp_16.u0, *((byte) esp_16.u0 + 4), *((byte) esp_16.u0 + 8), out xmm1_758);
			Eq_4 eax_398 = *((byte) esp_16.u0 + 0x0C);
			if (g_t81576F0 == 0x00)
				*eax_398 = *((byte) esp_16.u0 + 24);
			else
			{
				*esp_16.u0 = eax_398;
				*((byte) esp_16.u0 + 4) = *((byte) esp_16.u0 + 24);
				runtime.writebarrierptr(*esp_16.u0, *((byte) esp_16.u0 + 4));
			}
		}
		else
			sync.(*entry).storeLocked(gs, eax_216, dwLoc5C);
	}
	sync.(*Mutex).Unlock(gs, dwArg04);
}

// 0809A7F0: void sync.(*entry).tryStore(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
// Called from:
//      sync.(*Map).Store
void sync.(*entry).tryStore(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	sync/atomic.LoadPointer();
	if (sync.expunged == dwLoc0C)
		return;
	do
	{
		sync/atomic.CompareAndSwapPointer(dwArg04, dwLoc0C, dwArg08);
		if (bLoc04 != 0x00)
			return;
		sync/atomic.LoadPointer();
	} while (sync.expunged != dwLoc0C);
}

// 0809A890: void sync.(*entry).unexpungeLocked(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      sync.(*Map).Store
//      sync.(*Map).LoadOrStore
void sync.(*entry).unexpungeLocked(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	sync/atomic.CompareAndSwapPointer(dwArg04, sync.expunged, 0x00);
}

// 0809A8E0: void sync.(*entry).storeLocked(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
// Called from:
//      sync.(*Map).Store
void sync.(*entry).storeLocked(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	sync/atomic.StorePointer(dwArg04, dwArg08);
}

// 0809A920: Register word128 sync.(*Map).LoadOrStore(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg10, Stack Eq_4 dwArg14, Register out Eq_101963 xmm1Out)
// Called from:
//      reflect.(*rtype).exportedMethods
//      reflect.(*rtype).ptrTo
//      reflect.funcLayout
word128 sync.(*Map).LoadOrStore(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg10, Eq_4 dwArg14, union Eq_101963 & xmm1Out)
{
	byte bLoc58 = (byte) dwLoc58;
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 eax_36;
	sync/atomic.(*Value).Load(gs, (word32) dwArg04 + 8);
	Eq_4 esp_16 = fp - 0x68;
	if (dwLoc64 == 0x080D4580)
		eax_36 = *dwLoc60;
	else
		eax_36.u0 = 0x00;
	word32 esi_841;
	runtime.mapaccess2(gs, 0x080CFA80, eax_36, fp - 0x08, out esi_841);
	Eq_4 dwLoc64_586 = eax_36;
	Eq_4 dwLoc60_587 = fp - 0x08;
	Eq_4 eax_65 = *dwLoc5C;
	if (bLoc58 != 0x00)
	{
		sync.(*entry).tryLoadOrStore(gs, eax_65, dwArg10, dwArg14);
		dwLoc64_586 = dwArg10;
		dwLoc60_587 = dwArg14;
		if (bLoc53 != 0x00)
		{
			xmm1Out = xmm1;
			return xmm0;
		}
	}
	Eq_4 ecx_130;
	byte al_135;
	Eq_4 edi_109 = sync.(*Mutex).Lock(gs, dwArg04);
	sync/atomic.(*Value).Load(gs, (word32) dwArg04 + 8);
	if (dwLoc64_586 == 0x080D4580)
	{
		ecx_130 = *dwLoc60_587;
		al_135 = (byte) *((word32) dwLoc60_587 + 4);
	}
	else
	{
		al_135 = 0x00;
		ecx_130.u0 = 0x00;
	}
	word32 esi_840;
	runtime.mapaccess2(gs, 0x080CFA80, ecx_130, fp - 0x10, out esi_840);
	byte bLoc64_671 = (byte) ecx_130;
	Eq_4 eax_164 = *dwLoc5C;
	if (bLoc58 != 0x00)
	{
		sync.(*entry).unexpungeLocked(gs, eax_164);
		if (bLoc64_671 != 0x00)
		{
			xmm0 = runtime.mapassign(gs, 0x080CFA80, *((word32) dwArg04 + 16), fp - 0x18, out xmm1);
			if (g_t81576F0 == 0x00)
				*dwLoc5C = eax_164;
			else
				runtime.writebarrierptr(dwLoc5C, eax_164);
		}
		sync.(*entry).tryLoadOrStore(gs, eax_164, dwArg10, dwArg14);
	}
	else
	{
		Eq_4 esi_185;
		word32 * ebx_184 = runtime.mapaccess2(gs, 0x080CFA80, *((word32) dwArg04 + 16), fp - 0x20, out esi_185);
		Eq_4 eax_192 = *dwLoc5C;
		if (bLoc58 == 0x00)
		{
			if (al_135 == 0x00)
			{
				Eq_4 ebx_253 = sync.(*Map).dirtyLocked(ebx_184, esi_185, edi_109, gs, dwLoc6C, dwArg04);
				esp_16.u0 = <invalid>;
				*((byte) esp_16.u0 + 64) = *((byte) esp_16.u0 + 32);
				((byte) esp_16.u0 + 0x0044)->u0 = 0x01;
				esp_16.u0->u0 = 0x080D4580;
				*((byte) esp_16.u0 + 4) = (byte) esp_16.u0 + 64;
				word128 xmm1_839;
				runtime.convT2E(ebx_253, gs, *esp_16.u0, *((byte) esp_16.u0 + 4), out xmm1_839);
				Eq_4 eax_296 = *((byte) esp_16.u0 + 0x0C);
				*((byte) esp_16.u0 + 4) = *((byte) esp_16.u0 + 8);
				*((byte) esp_16.u0 + 8) = eax_296;
				*esp_16.u0 = *((byte) esp_16.u0 + 48);
				sync/atomic.(*Value).Store(gs, *esp_16.u0, *((byte) esp_16.u0 + 4), *((byte) esp_16.u0 + 8));
			}
			*((byte) esp_16.u0 + 56) = *((byte) esp_16.u0 + 112);
			*((byte) esp_16.u0 + 60) = *((byte) esp_16.u0 + 116);
			esp_16.u0->u0 = 0x080CECA0;
			runtime.newobject(gs, *esp_16.u0);
			Eq_4 eax_326 = *((byte) esp_16.u0 + 4);
			*((byte) esp_16.u0 + 52) = eax_326;
			*eax_326 = *((byte) esp_16.u0 + 0x0078);
			if (g_t81576F0 == 0x00)
				*((word32) eax_326 + 4) = *((byte) esp_16.u0 + 0x007C);
			else
			{
				*esp_16.u0 = (word32) eax_326 + 4;
				*((byte) esp_16.u0 + 4) = *((byte) esp_16.u0 + 0x007C);
				runtime.writebarrierptr(*esp_16.u0, *((byte) esp_16.u0 + 4));
			}
			esp_16.u0->u0 = 0x080D1CE0;
			runtime.newobject(gs, *esp_16.u0);
			Eq_4 eax_359 = *((byte) esp_16.u0 + 4);
			*((byte) esp_16.u0 + 28) = eax_359;
			if (g_t81576F0 == 0x00)
				*eax_359 = *((byte) esp_16.u0 + 52);
			else
			{
				*esp_16.u0 = eax_359;
				*((byte) esp_16.u0 + 4) = *((byte) esp_16.u0 + 52);
				runtime.writebarrierptr(*esp_16.u0, *((byte) esp_16.u0 + 4));
			}
			*((byte) esp_16.u0 + 4) = *((word32) *((byte) esp_16.u0 + 0x006C) + 16);
			esp_16.u0->u0 = 0x080CFA80;
			*((byte) esp_16.u0 + 8) = (byte) esp_16.u0 + 56;
			xmm0 = runtime.mapassign(gs, *esp_16.u0, *((byte) esp_16.u0 + 4), *((byte) esp_16.u0 + 8), out xmm1);
			Eq_4 eax_410 = *((byte) esp_16.u0 + 0x0C);
			if (g_t81576F0 == 0x00)
				*eax_410 = *((byte) esp_16.u0 + 28);
			else
			{
				*esp_16.u0 = eax_410;
				*((byte) esp_16.u0 + 4) = *((byte) esp_16.u0 + 28);
				runtime.writebarrierptr(*esp_16.u0, *((byte) esp_16.u0 + 4));
			}
		}
		else
		{
			sync.(*entry).tryLoadOrStore(gs, eax_192, dwArg10, dwArg14);
			xmm0 = sync.(*Map).missLocked(gs, dwArg04, out xmm1);
		}
	}
	sync.(*Mutex).Unlock(gs, dwArg04);
	xmm1Out = xmm1;
	return xmm0;
}

// 0809AD50: void sync.(*entry).tryLoadOrStore(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C)
// Called from:
//      sync.(*Map).LoadOrStore
void sync.(*entry).tryLoadOrStore(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	sync/atomic.LoadPointer();
	if (sync.expunged == dwLoc10)
		return;
	if (dwLoc10 != 0x00)
		return;
	runtime.newobject(gs, 0x080CECA0);
	*dwLoc10 = dwArg08;
	if (g_t81576F0 == 0x00)
		*((word32) dwLoc10 + 4) = dwArg0C;
	else
		runtime.writebarrierptr((word32) dwLoc10 + 4, dwArg0C);
	do
	{
		sync/atomic.CompareAndSwapPointer(dwArg04, 0x00, dwLoc10);
		if (bLoc08 != 0x00)
			return;
		sync/atomic.LoadPointer();
	} while (sync.expunged != 0x00);
}

// 0809AED0: Register word128 sync.(*Map).missLocked(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Register out Eq_101467 xmm1Out)
// Called from:
//      sync.(*Map).Load
//      sync.(*Map).LoadOrStore
word128 sync.(*Map).missLocked(struct Eq_2 * gs, Eq_4 dwArg04, union Eq_101467 & xmm1Out)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	int32 edx_26;
	Eq_4 ecx_18 = *((word32) dwArg04 + 20);
	*((word32) dwArg04 + 20) = (word32) ecx_18 + 1;
	int32 * edx_21 = *((word32) dwArg04 + 16);
	if (edx_21 != null)
		edx_26 = *edx_21;
	else
		edx_26 = 0x00;
	if ((word32) ecx_18 + 1 < edx_26)
	{
		xmm1Out = xmm1;
		return xmm0;
	}
	else
	{
		Eq_101467 xmm1_58;
		word128 xmm0_57 = runtime.convT2E((word32) dwArg04 + 16, gs, 0x080D4580, fp - 0x08, out xmm1_58);
		sync/atomic.(*Value).Store(gs, (word32) dwArg04 + 8, dwLoc14, dwLoc10);
		if (g_t81576F0 == 0x00)
			*((word32) dwArg04 + 16) = null;
		else
			runtime.writebarrierptr((word32) dwArg04 + 16, 0x00);
		((word32) dwArg04 + 20)->u0 = 0x00;
		xmm1Out = xmm1_58;
		return xmm0_57;
	}
}

// 0809AFB0: Register (ptr32 word32) sync.(*Map).dirtyLocked(Register (ptr32 word32) ebx, Register Eq_4 esi, Register Eq_4 edi, Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_101626) dwArg00, Stack Eq_4 dwArg04)
// Called from:
//      sync.(*Map).Store
//      sync.(*Map).LoadOrStore
word32 * sync.(*Map).dirtyLocked(word32 * ebx, Eq_4 esi, Eq_4 edi, struct Eq_2 * gs, struct Eq_101626 * dwArg00, Eq_4 dwArg04)
{
	word24 ebx_24_8 = SLICE(ebx, word24, 8);
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (*((word32) dwArg04 + 16) != 0x00)
		return ebx;
	union Eq_4 * eax_40;
	sync/atomic.(*Value).Load(gs, (word32) dwArg04 + 8);
	if (dwLoc60 == 0x080D4580)
		eax_40 = (union Eq_4 *) *dwLoc5C;
	else
		eax_40 = null;
	Eq_4 ecx_50;
	if (eax_40 != null)
		ecx_50 = *eax_40;
	else
		ecx_50.u0 = 0x00;
	Eq_4 ecx_59 = ecx_50 >> 0x1F;
	word32 edi_415;
	runtime.makemap(ebx_24_8, esi, edi, gs, 0x080CFA80, ecx_50, ecx_59, 0x00, 0x00, out edi_415);
	if (g_t81576F0 == 0x00)
		*((word32) dwArg04 + 16) = dwLoc50;
	else
		runtime.writebarrierptr((word32) dwArg04 + 16, dwLoc50);
	fn0808FD84(0x00, fp - 0x30);
	byte bLoc64_272 = (byte) dwLoc50;
	word32 * ebx_127 = runtime.mapiterinit(gs, 0x080CFA80, dwLoc50, fp - 0x34);
	while (dwLoc34 != 0x00)
	{
		Eq_4 ecx_150 = *dwLoc30;
		sync.(*entry).tryExpungeLocked(gs, ecx_150);
		if (bLoc64_272 == 0x00)
		{
			Eq_4 ecx_172 = dwArg00->t0010;
			word128 xmm1_414;
			runtime.mapassign(gs, 0x080CFA80, ecx_172, fp - 0x3C, out xmm1_414);
			bLoc64_272 = (byte) ecx_172;
			if (g_t81576F0 == 0x00)
				*ecx_59 = ecx_150;
			else
			{
				runtime.writebarrierptr(ecx_59, ecx_150);
				bLoc64_272 = (byte) ecx_150;
			}
		}
		ebx_127 = runtime.mapiternext(gs, fp - 0x34);
	}
	return ebx_127;
}

// 0809B160: void sync.(*entry).tryExpungeLocked(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      sync.(*Map).dirtyLocked
void sync.(*entry).tryExpungeLocked(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	sync/atomic.LoadPointer();
	word32 eax_23 = dwLoc0C;
	while (eax_23 == 0x00)
	{
		sync/atomic.CompareAndSwapPointer(dwArg04, 0x00, sync.expunged);
		if (bLoc04 != 0x00)
			return;
		sync/atomic.LoadPointer();
		eax_23 = 0x00;
	}
}

// 0809B1F0: Register ui32 sync.(*Mutex).Lock(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      sync.(*Map).Load
//      sync.(*Map).Store
//      sync.(*Map).LoadOrStore
//      sync.(*Once).Do
//      sync.(*Pool).Put
//      sync.(*Pool).Get
//      sync.(*Pool).getSlow
//      sync.(*Pool).pinSlow
//      reflect.FuncOf
ui32 sync.(*Mutex).Lock(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	word32 ebp_634;
	sync/atomic.CompareAndSwapInt32(dwArg04, 0x00, 0x01, out ebp_634);
	byte bLoc20_474 = 0x00;
	if (bLoc18 != 0x00)
		return edi;
	Eq_4 ecx_133 = *dwArg04;
	int32 edx_131 = 0x00;
	word32 ebp_135 = 0x00;
	uint32 esi_136 = 0x00;
	ui32 edi_137 = 0x00;
	ui32 ebx_134 = 0x00;
	while (true)
	{
l0809B244:
		byte bl_59 = (byte) ebx_134;
		byte al_54 = (byte) ebp_135;
		word32 ebp_174 = ebp_135;
		ui32 ebx_624 = ebx_134;
		if ((ecx_133 & 0x05) != 0x01)
			break;
		sync.runtime_canSpin(gs, edx_131);
		if (bLoc20_474 == 0x00)
		{
			ebx_624 = (word32) bl_59;
			ebp_174 = (word32) al_54;
			break;
		}
		byte al_120 = al_54;
		if (al_54 == 0x00 && ((ecx_133 & 0x02) == 0x00 && ecx_133 >> 0x03 != 0x00))
		{
			word32 ebp_636;
			sync/atomic.CompareAndSwapInt32(dwArg04, ecx_133, ecx_133 | 0x02, out ebp_636);
			bLoc20_474 = (byte) ecx_133;
			if (bLoc18 != 0x00)
				al_120 = 0x01;
			else
				al_120 = al_54;
		}
		sync.runtime_doSpin();
		++edx_131;
		ecx_133 = *dwArg04;
		ebx_134 = (word32) bl_59;
		ebp_135 = (word32) al_120;
	}
	ui32 edi_307 = edi_137;
	byte bl_158 = (byte) ebx_624;
	Eq_4 ecx_140 = ecx_133;
	if ((ecx_133 & 0x04) == 0x00)
		ecx_140 = ecx_133 | 0x01;
	if ((ecx_133 & 0x05) != 0x00)
		ecx_140 = (word32) ecx_140 + 8;
	if (bl_158 != 0x00 && (ecx_133 & 0x01) != 0x00)
		ecx_140 |= 0x04;
	if ((byte) ebp_174 != 0x00)
	{
		if ((ecx_140 & 0x02) == 0x00)
			runtime.gopanic(gs);
		ecx_140 &= ~0x02;
	}
	word24 nLoc1F_528 = SLICE(ecx_133, word24, 8);
	bLoc20_474 = (byte) ecx_133;
	word32 ebp_635;
	sync/atomic.CompareAndSwapInt32(dwArg04, ecx_133, ecx_140, out ebp_635);
	if (bLoc18 == 0x00)
	{
		ecx_133 = *dwArg04;
		ebx_134 = (word32) bl_59;
		ebp_135 = (word32) al_54;
	}
	else
	{
		if ((ecx_133 & 0x05) == 0x00)
			return edi_307;
		int64 edx_eax_626;
		if (((int8) (edi_137 == 0x00) & (int8) (esi_136 == 0x00)) == 0x00)
			edx_eax_626 = SEQ(edi_137, esi_136);
		else
		{
			sync.runtime_nanotime(gs);
			edx_eax_626 = SEQ(ecx_133, dwArg04);
		}
		ui32 eax_362;
		byte bl_300 = (int8) (edi_137 != 0x00) | (int8) (esi_136 != 0x00);
		ui32 edx_280 = SLICE(edx_eax_626, word32, 32);
		uint32 eax_277 = (word32) edx_eax_626;
		word32 ebp_310 = sync.runtime_SemacquireMutex(edi_137, gs, dwArg04 + 0x04, bl_300, out edi_307);
		ui32 dwLoc20_529 = SEQ(nLoc1F_528, bl_300);
		if (bl_59 != 0x00)
			eax_362 = 0x01;
		else
		{
			sync.runtime_nanotime(gs);
			ui64 edx_eax_459 = SEQ(dwLoc20_529, dwArg04 + 0x04) - edx_eax_626;
			up32 eax_335 = (word32) edx_eax_459;
			int32 edx_340 = SLICE(edx_eax_459, word32, 32);
			eax_362 = SEQ(SLICE(eax_335, word24, 8), (int8) (eax_335 > 1000000)) & SEQ(SLICE(ebp_310, word24, 8), (int8) (edx_340 == 0x00)) | SEQ(SLICE(edx_340, word24, 8), (int8) (edx_340 > 0x00));
		}
		bLoc20_474 = bl_300;
		byte al_399 = (byte) eax_362;
		Eq_4 edx_369 = *dwArg04;
		if ((edx_369 & 0x04) != 0x00)
		{
			if ((edx_369 & 0x03) != 0x00 || edx_369 >> 0x03 == 0x00)
				runtime.gopanic(gs);
			else
			{
				Eq_4 eax_407;
				if (al_399 != 0x00 && edx_369 >> 0x03 != 0x01)
					eax_407.u0 = ~0x06;
				else
					eax_407.u0 = ~0x0A;
				sync/atomic.AddInt32(dwArg04, eax_407);
				return edi_307;
			}
		}
		ecx_133 = edx_369;
		edx_131 = 0x00;
		ebp_135 = 0x01;
		esi_136 = eax_277;
		edi_137 = edx_280;
		ebx_134 = eax_362;
	}
	goto l0809B244;
}

// 0809B4F0: void sync.(*Mutex).Unlock(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      sync.(*Map).Load
//      sync.(*Map).Store
//      sync.(*Map).LoadOrStore
//      sync.(*Pool).Put
//      sync.(*Pool).Get
//      sync.(*Pool).getSlow
void sync.(*Mutex).Unlock(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	word32 ebp_24 = sync/atomic.AddInt32(dwArg04, ~0x00);
	Eq_4 eax_30 = dwLoc08;
	if (((word32) dwLoc08 + 1 & 0x01) == 0x00)
		runtime.gopanic(gs);
	else if ((dwLoc08 & 0x04) == 0x00)
	{
		while (eax_30 >> 0x03 != 0x00 && (eax_30 & 0x07) == 0x00)
		{
			word32 ebp_77;
			sync/atomic.CompareAndSwapInt32(dwArg04, eax_30, (word32) eax_30 - 8 | 0x02, out ebp_77);
			if (bLoc04 != 0x00)
			{
				sync.runtime_Semrelease(ebp_77, gs, dwLoc14, (word32) dwArg04 + 4);
				return;
			}
			eax_30 = *dwArg04;
		}
	}
	else
		sync.runtime_Semrelease(ebp_24, gs, dwLoc14, (word32) dwArg04 + 4);
}

// 0809B5D0: Register word32 sync.(*Once).Do(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack (ptr32 (ptr32 code)) dwArg08)
// Called from:
//      internal/poll.(*pollDesc).init
word32 sync.(*Once).Do(struct Eq_2 * gs, Eq_4 dwArg04, <anonymous> ** dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	sync/atomic.LoadUint32();
	if (dwLoc10 == 0x01)
	{
		word128 xmm0_257;
		word128 xmm1_258;
		return runtime.deferreturn(gs, out xmm0_257, out xmm1_258);
	}
	else
	{
		sync.(*Mutex).Lock(gs, dwArg04);
		word32 ebp_259;
		word32 esi_260;
		word32 edi_261;
		if (runtime.deferproc(gs, 0x04, 0x080E7D08, dwArg04, out ebp_259, out esi_260, out edi_261) != 0x00)
		{
			word128 xmm0_262;
			word128 xmm1_263;
			return runtime.deferreturn(gs, out xmm0_262, out xmm1_263);
		}
		else
		{
			if (*((word32) dwArg04 + 8) == 0x00)
			{
				word32 ebp_264;
				word32 esi_265;
				word32 edi_266;
				if (runtime.deferproc(gs, 0x08, 0x080E7D10, (word32) dwArg04 + 8, out ebp_264, out esi_265, out edi_266) != 0x00)
				{
					word128 xmm0_269;
					word128 xmm1_270;
					return runtime.deferreturn(gs, out xmm0_269, out xmm1_270);
				}
				(*dwArg08)();
			}
			word128 xmm0_267;
			word128 xmm1_268;
			return runtime.deferreturn(gs, out xmm0_267, out xmm1_268);
		}
	}
}

// 0809B6B0: void sync.(*Pool).Put(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack ptr32 dwArg08, Stack Eq_4 dwArg0C)
// Called from:
//      reflect.callMethod
//      fmt.(*pp).free
void sync.(*Pool).Put(struct Eq_2 * gs, Eq_4 dwArg04, ptr32 dwArg08, Eq_4 dwArg0C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (dwArg08 == 0x00)
		return;
	ptr32 edx_76;
	Eq_4 ecx_73;
	word128 xmm1_419;
	sync.(*Pool).pin(gs, dwLoc38, dwArg04, out xmm1_419);
	if (dwLoc30->ptr0000 != 0x00)
	{
		ecx_73 = dwArg0C;
		edx_76 = dwArg08;
	}
	else
	{
		dwLoc30->ptr0000 = dwArg08;
		if (g_t81576F0 == 0x00)
			dwLoc30->t0004 = dwArg0C;
		else
			runtime.writebarrierptr(&dwLoc30->t0004, dwArg0C);
		ecx_73.u0 = 0x00;
		edx_76 = 0x00;
	}
	sync.runtime_procUnpin(gs);
	if (edx_76 != 0x00)
	{
		sync.(*Mutex).Lock(gs, (char *) &dwLoc30->t0010 + 4);
		Eq_4 ecx_112 = dwLoc30->t0008;
		Eq_4 edx_113 = dwLoc30->t000C;
		Eq_4 ebx_114 = dwLoc30->t0010;
		if ((word32) edx_113 + 1 > ebx_114)
		{
			word32 esi_420;
			word128 xmm0_421;
			word128 xmm1_422;
			runtime.growslice(gs, 0x080CECA0, ecx_112, edx_113, ebx_114, (word32) edx_113 + 1, out esi_420, out xmm0_421, out xmm1_422);
			dwLoc30->t0010 = dwLoc18;
			if (g_t81576F0 == 0x00)
				dwLoc30->t0008 = dwLoc20;
			else
				runtime.writebarrierptr(&dwLoc30->t0008, dwLoc20);
			edx_113 = dwLoc1C;
			ecx_112 = dwLoc20;
		}
		dwLoc30->t000C = (word32) edx_113 + 1;
		*((word32) ecx_112 + edx_113 * 0x08) = edx_76;
		Eq_4 ecx_189 = (word32) ecx_112 + 4 + edx_113 * 0x08;
		if (g_t81576F0 == 0x00)
			*ecx_189 = ecx_73;
		else
			runtime.writebarrierptr(ecx_189, ecx_73);
		sync.(*Mutex).Unlock(gs, (char *) &dwLoc30->t0010 + 4);
	}
}

// 0809B840: Register word128 sync.(*Pool).Get(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Register out Eq_103112 xmm1Out)
// Called from:
//      reflect.callMethod
//      fmt.newPrinter
word128 sync.(*Pool).Get(struct Eq_2 * gs, Eq_4 dwArg04, union Eq_103112 & xmm1Out)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_103112 xmm1_30;
	word128 xmm0_29 = sync.(*Pool).pin(gs, dwLoc20, dwArg04, out xmm1_30);
	Eq_4 esp_27 = <invalid>;
	Eq_4 eax_41 = *((word32) esp_27 + 4);
	*((word32) esp_27 + 20) = eax_41;
	*((word32) esp_27 + 0x0C) = *eax_41;
	*((word32) esp_27 + 16) = *((word32) eax_41 + 4);
	eax_41->u0 = 0x00;
	if (g_t81576F0 == 0x00)
		*((word32) eax_41 + 4) = 0x00;
	else
	{
		*esp_27 = (word32) eax_41 + 4;
		((word32) esp_27 + 4)->u0 = 0x00;
		runtime.writebarrierptr(*esp_27, *((word32) esp_27 + 4));
	}
	sync.runtime_procUnpin(gs);
	Eq_4 eax_123 = *((word32) esp_27 + 0x0C);
	if (eax_123 == 0x00)
	{
		Eq_4 edx_103;
		word32 ecx_104;
		Eq_4 eax_76 = *((word32) esp_27 + 20);
		*((word32) esp_27 + 24) = (word32) eax_76 + 20;
		*esp_27 = (word32) eax_76 + 20;
		sync.(*Mutex).Lock(gs, *esp_27);
		Eq_4 eax_91 = *((word32) esp_27 + 20);
		Eq_4 ecx_92 = *((word32) eax_91 + 8);
		Eq_4 edx_93 = *((word32) eax_91 + 0x0C);
		if (edx_93 >= 0x01)
		{
			if (edx_93 - 0x01 >= edx_93)
				runtime.panicindex(gs);
			struct Eq_103233 * ecx_102 = ecx_92 - 0x08 + edx_93 * 0x08;
			edx_103 = ecx_102->t0000;
			ecx_104 = ecx_102->dw0004;
			*((word32) eax_91 + 0x0C) = edx_93 - 0x01;
		}
		else
		{
			ecx_104 = (word32) *((word32) esp_27 + 16);
			edx_103 = *((word32) esp_27 + 0x0C);
		}
		*((word32) esp_27 + 16) = ecx_104;
		*((word32) esp_27 + 0x0C) = edx_103;
		*esp_27 = *((word32) esp_27 + 24);
		sync.(*Mutex).Unlock(gs, *esp_27);
		eax_123 = *((word32) esp_27 + 0x0C);
		if (eax_123 == 0x00)
		{
			*esp_27 = *((word32) esp_27 + 32);
			sync.(*Pool).getSlow(gs, *((word32) esp_27 - 4), *esp_27);
			Eq_4 esp_132 = <invalid>;
			eax_123 = *((word32) esp_132 + 4);
		}
	}
	if (eax_123 == 0x00)
	{
		Eq_4 edx_152 = *((word32) dwArg04 + 8);
		if (edx_152 != 0x00)
			(*edx_152)();
	}
	xmm1Out = xmm1_30;
	return xmm0_29;
}

// 0809B970: void sync.(*Pool).getSlow(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg00, Stack Eq_4 dwArg04)
// Called from:
//      sync.(*Pool).Get
void sync.(*Pool).getSlow(struct Eq_2 * gs, Eq_4 dwArg00, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	sync/atomic.LoadUintptr();
	word32 ecx_28 = *dwArg00;
	sync.runtime_procPin(gs);
	sync.runtime_procUnpin(gs);
	int32 eax_122;
	for (eax_122 = 0x01; eax_122 < (word32) dwArg04 + 4; ++eax_122)
	{
		if (dwArg04 == 0x04)
			runtime.panicdivide(gs);
		int32 edx_65;
		int32 ebx_61 = eax_122 + 0x00 + dwLoc2C;
		if (dwArg04 != 0x05)
			edx_65 = (int32) ((int64) ebx_61 % ((word32) dwArg04 + 4));
		else
			edx_65 = 0x00;
		struct Eq_103349 * edx_81 = (edx_65 << 0x07) + ecx_28;
		sync.(*Mutex).Lock(gs, (char *) &edx_81->t000C + 8);
		Eq_103357 edx_104 = edx_81->t000C;
		if (edx_104 >= 0x01)
		{
			if (edx_104 - 0x01 >= edx_104)
				runtime.panicindex(gs);
			else
			{
				edx_81->t000C = edx_104 - 0x01;
				sync.(*Mutex).Unlock(gs, (char *) &edx_81->t000C + 8);
				return;
			}
		}
		sync.(*Mutex).Unlock(gs, (char *) &edx_81->t000C + 8);
	}
}

// 0809BA90: Register word128 sync.(*Pool).pin(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg00, Stack Eq_4 dwArg04, Register out Eq_103006 xmm1Out)
// Called from:
//      sync.(*Pool).Put
//      sync.(*Pool).Get
word128 sync.(*Pool).pin(struct Eq_2 * gs, Eq_4 dwArg00, Eq_4 dwArg04, union Eq_103006 & xmm1Out)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	sync.runtime_procPin(gs);
	sync/atomic.LoadUintptr();
	if (dwLoc08 >= (word32) dwArg04 + 4)
	{
		Eq_103006 xmm1_49;
		word128 xmm0_48 = sync.(*Pool).pinSlow(gs, dwArg00, out xmm1_49);
		xmm1Out = xmm1_49;
		return xmm0_48;
	}
	else
	{
		xmm1Out = xmm1;
		return xmm0;
	}
}

// 0809BB00: Register word128 sync.(*Pool).pinSlow(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Register out Eq_103406 xmm1Out)
// Called from:
//      sync.(*Pool).pin
word128 sync.(*Pool).pinSlow(struct Eq_2 * gs, Eq_4 dwArg04, union Eq_103406 & xmm1Out)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	sync.runtime_procUnpin(gs);
	sync.(*Mutex).Lock(gs, 0x081576C8);
	Eq_4 dwLoc38_316 = 0x080E7D08;
	word32 ebp_408;
	word32 edi_409;
	Eq_4 esi_133;
	if (runtime.deferproc(gs, 0x04, 0x080E7D08, 0x081576C8, out ebp_408, out esi_133, out edi_409) != 0x00)
	{
		word128 xmm0_72;
		Eq_103406 xmm1_73;
		runtime.deferreturn(gs, out xmm0_72, out xmm1_73);
		xmm1Out = xmm1_73;
		return xmm0_72;
	}
	else
	{
		sync.runtime_procPin(gs);
		word32 ebp_96 = *dwArg04;
		if (*((word32) dwArg04 + 4) > 0x04)
		{
			word128 xmm0_111;
			Eq_103406 xmm1_112;
			runtime.deferreturn(gs, out xmm0_111, out xmm1_112);
			xmm1Out = xmm1_112;
			return xmm0_111;
		}
		else
		{
			if (ebp_96 == 0x00)
			{
				Eq_4 edx_131 = g_t8145180;
				Eq_4 ebp_132 = g_t814517C;
				esi_133 = g_t8145178;
				if ((word32) ebp_132 + 1 > edx_131)
				{
					word32 esi_411;
					word128 xmm0_412;
					word128 xmm1_413;
					runtime.growslice(gs, 0x080D86C0, esi_133, ebp_132, edx_131, (word32) ebp_132 + 1, out esi_411, out xmm0_412, out xmm1_413);
					g_t8145180 = dwLoc20;
					dwLoc38_316 = esi_133;
					dwLoc30 = edx_131;
					dwLoc2C = (word32) ebp_132 + 1;
					if (g_t81576F0 == 0x00)
						g_t8145178 = dwLoc28;
					else
					{
						runtime.writebarrierptr(0x08145178, dwLoc28);
						dwLoc38_316 = dwLoc28;
					}
					ebp_132 = dwLoc24;
					esi_133 = dwLoc28;
				}
				g_t814517C = (word32) ebp_132 + 1;
				Eq_4 edx_200 = (word32) esi_133 + ebp_132 * 0x04;
				if (g_t81576F0 == 0x00)
					*((word32) esi_133 + ebp_132 * 0x04) = dwArg04;
				else
				{
					runtime.writebarrierptr(edx_200, dwArg04);
					dwLoc38_316 = dwArg04;
				}
			}
			runtime.GOMAXPROCS(esi_133, gs, 0x00);
			word32 edi_410;
			runtime.makeslice(gs, 0x080D4520, dwLoc38_316, dwLoc38_316, out edi_410);
			if (dwLoc2C <= 0x00)
				runtime.panicindex(gs);
			else
			{
				sync/atomic.StorePointer(dwArg04, dwLoc30);
				sync/atomic.StoreUintptr((word32) dwArg04 + 4, dwLoc38_316);
				if (dwLoc2C <= 0x04)
					runtime.panicindex(gs);
				else
				{
					word128 xmm0_295;
					Eq_103406 xmm1_296;
					runtime.deferreturn(gs, out xmm0_295, out xmm1_296);
					xmm1Out = xmm1_296;
					return xmm0_295;
				}
			}
		}
	}
}

// 0809BD20: void sync.poolCleanup(Register (ptr32 Eq_2) gs)
void sync.poolCleanup(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 eax_123 = g_t8145178;
	Eq_4 ecx_18 = g_t814517C;
	Eq_4 edx_127 = 0x00;
	ecx_115 = ecx_18;
	while (true)
	{
		Eq_4 ecx_115;
		if (edx_127 >= ecx_115)
			break;
		Eq_4 ebx_62 = *eax_123;
		Eq_4 esi_64 = g_t8145178;
		if (edx_127 >= g_t814517C)
			runtime.panicindex(gs);
		Eq_4 ebp_70 = (word32) esi_64 + edx_127 * 0x04;
		if (g_t81576F0 == 0x00)
			*((word32) esi_64 + edx_127 * 0x04) = 0x00;
		else
		{
			runtime.writebarrierptr(ebp_70, 0x00);
			dwLoc20.u0 = 0x00;
			ecx_115 = ecx_18;
		}
		Eq_4 eax_114 = eax_123;
		Eq_4 ebx_117 = ebx_62;
		int32 ebp_215;
		for (ebp_215 = 0x00; ebp_215 < *((word32) ebx_117 + 4); ++ebp_215)
		{
			struct Eq_103632 * ebp_133 = (word32) *ebx_117 + (ebp_215 << 0x07);
			ebp_133->dw0000 = 0x00;
			if (g_t81576F0 == 0x00)
				ebp_133->dw0004 = 0x00;
			else
			{
				runtime.writebarrierptr(&ebp_133->dw0004, 0x00);
				dwLoc20.u0 = 0x00;
				eax_114 = eax_123;
				ebx_117 = ebx_62;
			}
			ui32 ecx_159 = ebp_133->dw000C;
			Eq_4 esi_160 = ebp_133->t0008;
			if (ecx_159 != 0x00)
			{
				runtime.memclrHasPointers(gs, esi_160, ecx_159 << 0x03);
				dwLoc20 = ecx_159 << 0x03;
				eax_114 = eax_123;
				ebx_117 = ebx_62;
			}
			ebp_133->dw000C = 0x00;
			ebp_133->dw0010 = 0x00;
			if (g_t81576F0 == 0x00)
				ebp_133->t0008.u0 = 0x00;
			else
			{
				runtime.writebarrierptr(&ebp_133->t0008, 0x00);
				dwLoc20.u0 = 0x00;
				eax_114 = eax_123;
				ebx_117 = ebx_62;
			}
			ecx_115 = ecx_18;
		}
		if (g_t81576F0 == 0x00)
			*ebx_117 = 0x00;
		else
		{
			runtime.writebarrierptr(ebx_117, 0x00);
			dwLoc20.u0 = 0x00;
			eax_114 = eax_123;
			ecx_115 = ecx_18;
			ebx_117 = ebx_62;
		}
		*((word32) ebx_117 + 4) = 0x00;
		eax_123 = (word32) eax_114 + 4;
		edx_127 = (word32) edx_127 + 1;
	}
	runtime.newobject(gs, 0x080CADA0);
	g_t814517C.u0 = 0x00;
	g_t8145180.u0 = 0x00;
	if (g_t81576F0 == 0x00)
		g_t8145178 = dwLoc20;
	else
		runtime.writebarrierptr(0x08145178, dwLoc20);
}

// 0809BF40: void sync.init.0(Register (ptr32 Eq_2) gs)
// Called from:
//      sync.init
void sync.init.0(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	sync.runtime_registerPoolCleanup(gs, 0x080E7D0C);
}

// 0809BF70: Register Eq_4 sync.init.1(Register word24 ebx_24_8, Register (ptr32 Eq_2) gs)
// Called from:
//      sync.init
Eq_4 sync.init.1(word24 ebx_24_8, struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 edi_21 = fn0808FD8B(0x00, fp - 0x14);
	sync.runtime_notifyListCheck(ebx_24_8, gs, 0x14);
	return edi_21;
}

// 0809BFB0: Register word32 sync.init(Register (ptr32 Eq_2) gs, Register out ptr32 esiOut, Register out ptr32 ediOut)
// Called from:
//      io.init
//      syscall.init
//      time.init
//      internal/poll.init
//      os.init
//      reflect.init
//      fmt.init
word32 sync.init(struct Eq_2 * gs, ptr32 & esiOut, ptr32 & ediOut)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	cu8 al_18 = g_b8157585;
	if (al_18 <= 0x01)
	{
		if (al_18 != 0x01)
		{
			g_b8157585 = 0x01;
			ptr32 esi_28;
			word32 edi_132;
			word32 ebx_24 = runtime.init(gs, out esi_28, out edi_132);
			runtime.newobject(gs, 0x080CECA0);
			word24 ebx_24_8_71 = SLICE(ebx_24, word24, 8);
			if (g_t81576F0 == 0x00)
				sync.expunged = dwLoc04;
			else
				runtime.writebarrierptr(0x08144FE8, dwLoc04);
			sync.init.0(gs);
			ptr32 edi_74 = sync.init.1(ebx_24_8_71, gs);
			g_b8157585 = 0x02;
			esiOut = esi_28;
			ediOut = edi_74;
			return ebx_24;
		}
		else
			runtime.throwinit(gs);
	}
	else
	{
		esiOut = esi;
		ediOut = edi;
		return ebx;
	}
}

// 0809C040: void io.init(Register (ptr32 Eq_2) gs)
// Called from:
//      internal/poll.init
//      os.init
//      fmt.init
void io.init(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	cu8 al_18 = g_b8157562;
	if (al_18 > 0x01)
		return;
	if (al_18 != 0x01)
	{
		g_b8157562 = 0x01;
		word32 esi_415;
		word32 edi_416;
		sync.init(gs, out esi_415, out edi_416);
		errors.New(gs, 0x080E1BCC, 11);
		g_t8145048 = dwLoc08;
		if (g_t81576F0 == 0x00)
			g_t814504C = dwLoc04;
		else
			runtime.writebarrierptr(0x0814504C, dwLoc04);
		errors.New(gs, 0x080E1E07, 0x0C);
		g_t8145040 = dwLoc08;
		if (g_t81576F0 == 0x00)
			g_t8145044 = dwLoc04;
		else
			runtime.writebarrierptr(0x08145044, dwLoc04);
		errors.New(gs, 0x080E0E46, 0x03);
		g_t8145028 = dwLoc08;
		if (g_t81576F0 == 0x00)
			g_t814502C = dwLoc04;
		else
			runtime.writebarrierptr(0x0814502C, dwLoc04);
		errors.New(gs, 135144012, 0x0E);
		g_t8145050 = dwLoc08;
		if (g_t81576F0 == 0x00)
			g_t8145054 = dwLoc04;
		else
			runtime.writebarrierptr(0x08145054, dwLoc04);
		errors.New(gs, 0x080E6B63, 0x2B);
		g_t8145038 = dwLoc08;
		if (g_t81576F0 == 0x00)
			g_t814503C = dwLoc04;
		else
			runtime.writebarrierptr(135548988, dwLoc04);
		errors.New(gs, 135147411, 0x14);
		g_t8145060 = dwLoc08;
		if (g_t81576F0 == 0x00)
			g_t8145064 = dwLoc04;
		else
			runtime.writebarrierptr(0x08145064, dwLoc04);
		errors.New(gs, 0x080E2F7F, 0x14);
		g_t8145058 = dwLoc08;
		if (g_t81576F0 == 0x00)
			g_t814505C = dwLoc04;
		else
			runtime.writebarrierptr(0x0814505C, dwLoc04);
		errors.New(gs, 0x080E4B04, 0x1D);
		g_t8145030 = dwLoc08;
		if (g_t81576F0 == 0x00)
			g_t8145034 = dwLoc04;
		else
			runtime.writebarrierptr(0x08145034, dwLoc04);
		g_b8157562 = 0x02;
	}
	else
		runtime.throwinit(gs);
}

// 0809C300: Register word32 syscall.SetNonblock(Register (ptr32 Eq_2) gs, Stack byte bArg08)
// Called from:
//      os.newFile
word32 syscall.SetNonblock(struct Eq_2 * gs, byte bArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	word32 esi_28 = syscall.fcntl(gs);
	if (dwLoc08 != 0x00)
		return esi_28;
	return syscall.fcntl(gs);
}

// 0809C3A0: void syscall.init.0(Register (ptr32 Eq_2) gs)
// Called from:
//      syscall.init
void syscall.init.0(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	syscall.fcntl64Syscall = 0xDD;
}

// 0809C3D0: void syscall.itoa(Register (ptr32 Eq_2) gs, Stack Eq_104017 dwArg04)
// Called from:
//      syscall.Errno.Error
void syscall.itoa(struct Eq_2 * gs, Eq_104017 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (dwArg04 >= 0x00)
		syscall.uitoa(gs, dwLoc20);
	else
	{
		syscall.uitoa(gs, dwLoc20);
		runtime.concatstring2(gs, 0x00);
	}
}

// 0809C460: void syscall.uitoa(Register (ptr32 Eq_2) gs, Stack uint32 dwArg00)
// Called from:
//      syscall.itoa
void syscall.uitoa(struct Eq_2 * gs, uint32 dwArg00)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	fn0808FD88(0x00, fp - 0x20);
	uint32 ecx_23 = dwArg00;
	Eq_104061 eax_24 = 0x1F;
	while (ecx_23 >= 0x0A)
	{
		uint32 edx_79 = SLICE(ecx_23 *64 ~0x33333332, word32, 32);
		uint32 ecx_83 = ecx_23 - ((edx_79 >> 0x03) + (edx_79 >> 0x03) * 0x04 << 0x01);
		if (eax_24 >= 0x20)
			runtime.panicindex(gs);
		*((word32) eax_24 + (fp - 0x24)) = (byte) ecx_83 + 0x30;
		--eax_24;
		ecx_23 = edx_79 >> 0x03;
	}
	if (eax_24 >= 0x20)
		runtime.panicindex(gs);
	else
	{
		Mem35[fp - 0x24 + eax_24:byte] = SLICE(ecx_23, byte, 0) + 0x30;
		Eq_4 ecx_38 = 0x20 - eax_24;
		runtime.slicebytetostring(gs, 0x00, fp - 0x24 + (eax_24 & -ecx_38 >> 0x1F), ecx_38);
	}
}

// 0809C520: void syscall.ByteSliceFromString(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
// Called from:
//      syscall.BytePtrFromString
void syscall.ByteSliceFromString(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 edx_19 = 0x00;
	while (edx_19 < dwArg08)
	{
		if (edx_19 >= dwArg08)
			runtime.panicindex(gs);
		if (Mem0[dwArg04 + edx_19:byte] == 0x00)
			return;
		edx_19 = (word32) edx_19 + 1;
	}
	word32 edi_218;
	runtime.makeslice(gs, 0x080CF320, (word32) dwArg08 + 1, (word32) dwArg08 + 1, out edi_218);
	Eq_4 ebx_49 = dwArg08;
	if (dwLoc14 <= dwArg08)
		ebx_49 = dwLoc14;
	word128 xmm2_224;
	word128 xmm0_222;
	word128 xmm1_223;
	word32 esi_220;
	word32 edi_221;
	word32 ebp_219;
	runtime.memmove(dwLoc18, dwArg04, ebx_49, out ebp_219, out esi_220, out edi_221, out xmm0_222, out xmm1_223, out xmm2_224);
}

// 0809C620: void syscall.BytePtrFromString(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
// Called from:
//      syscall.readlinkat
void syscall.BytePtrFromString(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	syscall.ByteSliceFromString(gs, dwArg04, dwArg08);
	if (dwLoc08 != 0x00)
		return;
	if (dwLoc10 > 0x00)
		return;
	runtime.panicindex(gs);
}

// 0809C6A0: void syscall.Readlink(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg10)
// Called from:
//      os.Readlink
void syscall.Readlink(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg10)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	syscall.readlinkat(gs, dwArg04, dwArg08, dwArg10);
}

// 0809C710: void syscall.mmap(Register (ptr32 Eq_2) gs, Stack ui32 dwArg18, Stack Eq_104221 dwArg1C)
void syscall.mmap(struct Eq_2 * gs, ui32 dwArg18, Eq_104221 dwArg1C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	uint32 eax_22 = (dwArg1C >> 0x1F >> 0x14) + dwArg18;
	uint32 eax_29 = eax_22 >> 0x0C | (word32) dwArg1C.u0 + (eax_22 < 0x00) << 0x14;
	if (((int8) (dwArg1C != eax_29 >> 0x14) | (int8) (dwArg18 != eax_29 << 0x0C)) != 0x00)
		return;
	syscall.mmap2(gs);
}

// 0809C7E0: void syscall.Errno.Error(Register (ptr32 Eq_2) gs, Stack Eq_104017 dwArg04)
// Called from:
//      syscall.(*Errno).Error
void syscall.Errno.Error(struct Eq_2 * gs, Eq_104017 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (dwArg04 < 133 && g_a8144B44[dwArg04] != 0x00)
		return;
	syscall.itoa(gs, dwArg04);
	runtime.concatstring2(gs, 0x00);
}

// 0809C880: void syscall.Write(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_104293) dwArg0C)
// Called from:
//      internal/poll.(*FD).Write
void syscall.Write(struct Eq_2 * gs, struct Eq_104293 * dwArg0C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	syscall.write(gs, dwArg0C);
}

// 0809C8E0: void syscall.readlinkat(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C, Stack Eq_4 dwArg14)
// Called from:
//      syscall.Readlink
void syscall.readlinkat(struct Eq_2 * gs, Eq_4 dwArg08, Eq_4 dwArg0C, Eq_4 dwArg14)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	syscall.BytePtrFromString(gs, dwArg08, dwArg0C);
	if (dwLoc30 != 0x00)
		return;
	Eq_4 ebx_77 = syscall.Syscall6(gs, 0x0131);
	if (dwLoc18 == 0x00)
		return;
	if (dwLoc18 <= 0x02)
	{
		if (dwLoc18 == 0x02)
			return;
	}
	else if (dwLoc18 == 11 || dwLoc18 == 22)
		return;
	runtime.convT2I32(ebx_77, gs, &g_t81366B0, fp - 0x10);
}

// 0809CA30: void syscall.Close(Register (ptr32 Eq_2) gs)
void syscall.Close(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	word32 esi_113;
	Eq_4 ebx_25 = syscall.Syscall(gs, 0x06, out esi_113);
	if (dwLoc08 == 0x00)
		return;
	if (dwLoc08 <= 0x02)
	{
		if (dwLoc08 == 0x02)
			return;
	}
	else if (dwLoc08 == 11 || dwLoc08 == 22)
		return;
	runtime.convT2I32(ebx_25, gs, &g_t81366B0, fp - 0x04);
}

// 0809CAF0: Register word32 syscall.fcntl(Register (ptr32 Eq_2) gs)
// Called from:
//      syscall.SetNonblock
word32 syscall.fcntl(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	word32 esi_122;
	Eq_4 ebx_27 = syscall.Syscall(gs, 55, out esi_122);
	if (dwLoc0C == 0x00)
		return esi_122;
	if (dwLoc0C <= 0x02)
	{
		if (dwLoc0C == 0x02)
			return esi_122;
	}
	else if (dwLoc0C == 11 || dwLoc0C == 22)
		return esi_122;
	esi_122 = runtime.convT2I32(ebx_27, gs, &g_t81366B0, fp - 0x04);
	return esi_122;
}

// 0809CBC0: void syscall.write(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_104293) dwArg0C)
// Called from:
//      syscall.Write
void syscall.write(struct Eq_2 * gs, struct Eq_104293 * dwArg0C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	word32 esi_137;
	Eq_4 ebx_33 = syscall.Syscall(gs, 0x04, out esi_137);
	if (dwLoc0C == 0x00)
		return;
	if (dwLoc0C <= 0x02)
	{
		if (dwLoc0C == 0x02)
			return;
	}
	else if (dwLoc0C == 11 || dwLoc0C == 22)
		return;
	runtime.convT2I32(ebx_33, gs, &g_t81366B0, fp - 0x04);
}

// 0809CCB0: void syscall.munmap(Register (ptr32 Eq_2) gs)
void syscall.munmap(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	word32 esi_116;
	Eq_4 ebx_26 = syscall.Syscall(gs, 0x5B, out esi_116);
	if (dwLoc08 == 0x00)
		return;
	if (dwLoc08 <= 0x02)
	{
		if (dwLoc08 == 0x02)
			return;
	}
	else if (dwLoc08 == 11 || dwLoc08 == 22)
		return;
	runtime.convT2I32(ebx_26, gs, &g_t81366B0, fp - 0x04);
}

// 0809CD70: void syscall.mmap2(Register (ptr32 Eq_2) gs)
// Called from:
//      syscall.mmap
void syscall.mmap2(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 ebx_33 = syscall.Syscall6(gs, 0xC0);
	if (dwLoc0C == 0x00)
		return;
	if (dwLoc0C <= 0x02)
	{
		if (dwLoc0C == 0x02)
			return;
	}
	else if (dwLoc0C == 11 || dwLoc0C == 22)
		return;
	runtime.convT2I32(ebx_33, gs, &g_t81366B0, fp - 0x04);
}

// 0809CE60: void syscall.init(Register (ptr32 Eq_2) gs)
// Called from:
//      time.init
//      internal/poll.init
//      os.init
void syscall.init(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	cu8 al_18 = g_b8157586;
	if (al_18 > 0x01)
		return;
	if (al_18 != 0x01)
	{
		g_b8157586 = 0x01;
		word32 esi_247;
		word32 edi_248;
		sync.init(gs, out esi_247, out edi_248);
		word32 edi_250;
		word32 esi_249;
		runtime.init(gs, out esi_249, out edi_250);
		Eq_4 edi_51;
		Eq_4 esi_53;
		word24 ebx_24_8_96 = SLICE(syscall.runtime_envs(gs, out esi_53, out edi_51), word24, 8);
		g_dw814518C = dwLoc14;
		g_dw8145190 = dwLoc10;
		if (g_t81576F0 == 0x00)
			g_t8145188 = dwLoc18;
		else
			runtime.writebarrierptr(0x08145188, dwLoc18);
		word32 edi_251;
		runtime.makemap(ebx_24_8_96, esi_53, edi_51, gs, 0x080CFA00, 0x00, 0x00, 0x00, 0x00, out edi_251);
		if (g_t81576F0 == 0x00)
			g_t8142778 = dwLoc04;
		else
			runtime.writebarrierptr(135538552, dwLoc04);
		syscall.init.0(gs);
		g_b8157586 = 0x02;
	}
	else
		runtime.throwinit(gs);
}

// 0809CF60: Register word32 syscall.Syscall(Register (ptr32 Eq_2) gs, Stack up32 dwArg04, Register out ptr32 esiOut)
// Called from:
//      syscall.Close
//      syscall.fcntl
//      syscall.write
//      syscall.munmap
word32 syscall.Syscall(struct Eq_2 * gs, up32 dwArg04, ptr32 & esiOut)
{
	runtime.entersyscall(gs);
	__syscall(0x80);
	if (dwArg04 <= ~0x0FFE)
	{
		ptr32 esi_33;
		word32 ebx_29 = runtime.exitsyscall(gs, out esi_33);
		esiOut = esi_33;
		return ebx_29;
	}
	else
	{
		ptr32 esi_50;
		word32 ebx_46 = runtime.exitsyscall(gs, out esi_50);
		esiOut = esi_50;
		return ebx_46;
	}
}

// 0809CFC0: Register word32 syscall.Syscall6(Register (ptr32 Eq_2) gs, Stack up32 dwArg04)
// Called from:
//      syscall.readlinkat
//      syscall.mmap2
word32 syscall.Syscall6(struct Eq_2 * gs, up32 dwArg04)
{
	runtime.entersyscall(gs);
	__syscall(0x80);
	if (dwArg04 <= ~0x0FFE)
	{
		word32 esi_84;
		return runtime.exitsyscall(gs, out esi_84);
	}
	else
	{
		word32 esi_85;
		return runtime.exitsyscall(gs, out esi_85);
	}
}

// 0809D020: void syscall.(*Errno).Error(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_104017) dwArg04)
void syscall.(*Errno).Error(struct Eq_2 * gs, union Eq_104017 * dwArg04)
{
	while (true)
	{
		Eq_4 ecx_7 = gs->ptr0000->tFFFFFFFC;
		if (fp > *((word32) ecx_7 + 8))
			break;
		runtime.morestack_noctxt();
	}
	ptr32 * ebx_17 = *((word32) ecx_7 + 16);
	if (ebx_17 != null && *ebx_17 == (word32) fp + 4)
		*ebx_17 = fp - 0x0C;
	if (dwArg04 == null)
		runtime.panicwrap(gs);
	else
		syscall.Errno.Error(gs, *dwArg04);
}

// 0809D080: void type..hash.[133]string(Register (ptr32 Eq_2) gs, Register Eq_4 mm0, Stack word32 dwArg04, Stack (ptr32 Eq_205) dwArg08)
void type..hash.[133]string(struct Eq_2 * gs, Eq_4 mm0, word32 dwArg04, union Eq_205 * dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	int32 eax_17;
	union Eq_205 * ecx_20 = dwArg08;
	for (eax_17 = 0x00; eax_17 < 133; ++eax_17)
	{
		mm0 = runtime.strhash(gs, mm0, dwArg04 + eax_17 * 0x08, ecx_20);
		ecx_20 = dwLoc08;
	}
}

// 0809D0E0: void type..eq.[133]string(Register (ptr32 Eq_104717) gs, Stack word32 dwArg04, Stack word32 dwArg08)
void type..eq.[133]string(struct Eq_104717 * gs, word32 dwArg04, word32 dwArg08)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	int32 eax_17;
	for (eax_17 = 0x00; eax_17 < 133; ++eax_17)
	{
		struct Eq_104736 * edx_29 = dwArg08 + eax_17 * 0x08;
		struct Eq_104740 * esi_32 = dwArg04 + eax_17 * 0x08;
		Eq_4 edx_33 = edx_29->t0000;
		Eq_4 edi_34 = esi_32->t0004;
		Eq_4 esi_35 = esi_32->t0000;
		if (edi_34 != edx_29->t0004)
			return;
		word32 ebx_129;
		word32 esi_130;
		word32 edi_131;
		runtime.eqstring(edx_33, esi_35, edi_34, edx_33, out ebx_129, out esi_130, out edi_131);
		if (bLoc08 == 0x00)
			return;
	}
}

// 0809D160: void time.init(Register (ptr32 Eq_2) gs)
// Called from:
//      internal/poll.init
//      os.init
void time.init(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	cu8 al_18 = g_b8157587;
	if (al_18 > 0x01)
		return;
	if (al_18 != 0x01)
	{
		g_b8157587 = 0x01;
		syscall.init(gs);
		word32 edi_786;
		word32 esi_785;
		sync.init(gs, out esi_785, out edi_786);
		Eq_4 edi_58;
		Eq_4 esi_60;
		word24 ebx_24_8_171 = SLICE(runtime.init(gs, out esi_60, out edi_58), word24, 8);
		errors.New(gs, 0x080E3213, 0x14);
		g_dw81450C0 = dwLoc18;
		if (g_t81576F0 == 0x00)
			g_t81450C4 = dwLoc14;
		else
			runtime.writebarrierptr(0x081450C4, dwLoc14);
		errors.New(gs, 0x080E2C56, 0x13);
		g_dw81450D0 = dwLoc18;
		if (g_t81576F0 == 0x00)
			g_t81450D4 = dwLoc14;
		else
			runtime.writebarrierptr(0x081450D4, dwLoc14);
		errors.New(gs, 135145081, 0x10);
		g_dw81450D8 = dwLoc18;
		if (g_t81576F0 == 0x00)
			g_t81450DC = dwLoc14;
		else
			runtime.writebarrierptr(135549148, dwLoc14);
		word32 edi_787;
		runtime.makemap(ebx_24_8_171, esi_60, edi_58, gs, 0x080CFB80, 0x08, 0x00, 0x00, 0x00, out edi_787);
		word32 edi_789;
		word32 esi_788;
		runtime.mapassign_faststr(gs, &g_t80CFB80, dwLoc0C, out esi_788, out edi_789);
		null = (union Eq_4 *) 0x01;
		((union Eq_4 *) 0x04)->u0 = 0x00;
		word32 edi_791;
		word32 esi_790;
		runtime.mapassign_faststr(gs, &g_t80CFB80, dwLoc0C, out esi_790, out edi_791);
		null = (union Eq_4 *) 1000;
		((union Eq_4 *) 0x04)->u0 = 0x00;
		word32 edi_793;
		word32 esi_792;
		runtime.mapassign_faststr(gs, &g_t80CFB80, dwLoc0C, out esi_792, out edi_793);
		null = (union Eq_4 *) 1000;
		((union Eq_4 *) 0x04)->u0 = 0x00;
		word32 edi_795;
		word32 esi_794;
		runtime.mapassign_faststr(gs, &g_t80CFB80, dwLoc0C, out esi_794, out edi_795);
		null = (union Eq_4 *) 1000;
		((union Eq_4 *) 0x04)->u0 = 0x00;
		word32 edi_797;
		word32 esi_796;
		runtime.mapassign_faststr(gs, &g_t80CFB80, dwLoc0C, out esi_796, out edi_797);
		null = (union Eq_4 *) 1000000;
		((union Eq_4 *) 0x04)->u0 = 0x00;
		word32 edi_799;
		word32 esi_798;
		runtime.mapassign_faststr(gs, &g_t80CFB80, dwLoc0C, out esi_798, out edi_799);
		null = (union Eq_4 *) 1000000000;
		((union Eq_4 *) 0x04)->u0 = 0x00;
		word32 edi_801;
		word32 esi_800;
		runtime.mapassign_faststr(gs, &g_t80CFB80, dwLoc0C, out esi_800, out edi_801);
		null = (union Eq_4 *) 4165425152;
		((union Eq_4 *) 0x04)->u0 = 0x0D;
		word32 esi_802;
		word32 edi_803;
		runtime.mapassign_faststr(gs, &g_t80CFB80, dwLoc0C, out esi_802, out edi_803);
		null = (union Eq_4 *) 0x30B8A000;
		((union Eq_4 *) 0x04)->u0 = 838;
		if (g_t81576F0 == 0x00)
			time.unitMap = dwLoc0C;
		else
			runtime.writebarrierptr(135548908, dwLoc0C);
		errors.New(gs, 135153170, 0x1B);
		g_ptr81450E0 = 0x080E0DA0;
		if (g_t81576F0 == 0x00)
			g_dw81450E4 = 0x01;
		else
			runtime.writebarrierptr(0x081450E4, 0x01);
		errors.New(gs, 0x080E518B, 0x1F);
		g_ptr81450C8 = 0x080E0DA0;
		if (g_t81576F0 == 0x00)
			g_dw81450CC = 0x01;
		else
			runtime.writebarrierptr(0x081450CC, 0x01);
		runtime.GOROOT(gs);
		runtime.concatstring2(gs, 0x00);
		g_dw81442BC = dwLoc08;
		if (g_t81576F0 == 0x00)
			g_t81442B8 = dwLoc0C;
		else
			runtime.writebarrierptr(135545528, dwLoc0C);
		g_b8157587 = 0x02;
	}
	else
		runtime.throwinit(gs);
}

// 0809D5E0: void internal/poll.(*TimeoutError).Error(Register (ptr32 Eq_105042) gs)
void internal/poll.(*TimeoutError).Error(struct Eq_105042 * gs)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
}

// 0809D610: void internal/poll.(*fdMutex).increfAndClose(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      internal/poll.(*FD).Close
void internal/poll.(*fdMutex).increfAndClose(struct Eq_2 * gs, Eq_4 dwArg04)
{
	ui32 dwLoc20 = SLICE(qwLoc24, word32, 32);
	uint32 dwLoc24 = (word32) qwLoc24;
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	do
	{
		sync/atomic.LoadUint64(dwArg04);
		if ((dwLoc24 & 0x01) != 0x00)
			return;
		uint32 ecx_41 = (dwLoc24 | 0x01) + 0x08;
		ui32 eax_45 = (bool) (ecx_41 < 0x00) + dwLoc20;
		if (((int8) ((ecx_41 & 0x007FFFF8) == 0x00) & 0x01) != 0x00)
			runtime.gopanic(gs);
		word32 ebx_98;
		sync/atomic.CompareAndSwapUint64(dwArg04, qwLoc24, SEQ(eax_45 & 0x80000000, ecx_41 & 0x007FFFFF), out ebx_98);
	} while (bLoc14 == 0x00);
	uint32 eax_110 = dwLoc24;
	ui32 ecx_111 = dwLoc20;
	while (((int8) ((ecx_111 & 0x07FF) != 0x00) | (int8) ((eax_110 & 0xFF800000) != 0x00)) != 0x00)
	{
		internal/poll.runtime_Semrelease(gs);
		ecx_111 = ecx_111 + ~0x00 + (eax_110 < 0xFF800000);
		eax_110 += 0xFF800000;
	}
	while ((ecx_111 & 0x7FFFF800) != 0x00)
	{
		internal/poll.runtime_Semrelease(gs);
		ecx_111 = ecx_111 + ~0x07FF + (eax_110 < 0x00);
	}
}

// 0809D770: void internal/poll.(*fdMutex).decref(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      internal/poll.(*FD).decref
void internal/poll.(*fdMutex).decref(struct Eq_2 * gs, Eq_4 dwArg04)
{
	word32 dwLoc14 = SLICE(qwLoc18, word32, 32);
	uint32 dwLoc18 = (word32) qwLoc18;
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	do
	{
		sync/atomic.LoadUint64(dwArg04);
		if (((int8) ((dwLoc18 & 0x007FFFF8) == 0x00) & 0x01) != 0x00)
			runtime.gopanic(gs);
		word32 ebx_133;
		sync/atomic.CompareAndSwapUint64(dwArg04, qwLoc18, SEQ((bool) (dwLoc18 < ~0x07) + (dwLoc14 + ~0x00), dwLoc18 + ~0x07), out ebx_133);
	} while (bLoc08 == 0x00);
}

// 0809D820: void internal/poll.(*fdMutex).rwlock(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack byte bArg08)
// Called from:
//      internal/poll.(*FD).writeLock
void internal/poll.(*fdMutex).rwlock(struct Eq_2 * gs, Eq_4 dwArg04, byte bArg08)
{
	word32 dwLoc2C = SLICE(qwLoc30, word32, 32);
	ui32 dwLoc30 = (word32) qwLoc30;
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	word64 ebp_ebx_363;
	Eq_4 ecx_25;
	ui32 edi_32;
	ui32 esi_31;
	ui32 edx_26;
	if (bArg08 != 0x00)
	{
		ecx_25 = (word32) dwArg04 + 8;
		edx_26 = 0x02;
		esi_31 = 0x07FF;
		edi_32 = 0xFF800000;
		ebp_ebx_363 = 0x00800000;
	}
	else
	{
		ecx_25 = (word32) dwArg04 + 0x0C;
		edx_26 = 0x04;
		esi_31 = 0x7FFFF800;
		edi_32 = 0x00;
		ebp_ebx_363 = 0x80000000000;
	}
	edi_128 = edi_32;
	while (true)
	{
		ui32 edi_128;
		sync/atomic.LoadUint64(dwArg04);
		if ((dwLoc30 & 0x01) != 0x00)
			break;
		Eq_4 eax_ecx_366;
		int8 bl_81 = (int8) ((edx_26 & dwLoc30) == 0x00);
		if ((bl_81 & 0x01) != 0x00)
		{
			uint32 ecx_148 = dwLoc30 | edx_26;
			eax_ecx_366 = SEQ(dwLoc2C + (ecx_148 < 0x08), ecx_148 + 0x08);
			if (((int8) ((ecx_148 + 0x08 & 0x007FFFF8) == 0x00) & 0x01) != 0x00)
				runtime.gopanic(gs);
		}
		else
		{
			Eq_4 eax_ecx_254 = (word64) qwLoc30 + ebp_ebx_363;
			ui32 edi_120 = SEQ(SLICE(esi_31, word24, 8), (int8) ((esi_31 & SLICE(eax_ecx_254, word32, 32)) == 0x00)) & SEQ(SLICE(edi_32, word24, 8), (int8) ((edi_32 & (word32) eax_ecx_254) == 0x00));
			edi_128 = edi_120;
			if ((byte) edi_120 != 0x00)
				runtime.gopanic(gs);
			eax_ecx_366 = eax_ecx_254;
		}
		word32 ebx_370;
		sync/atomic.CompareAndSwapUint64(dwArg04, qwLoc30, eax_ecx_366, out ebx_370);
		if (bLoc20 != 0x00)
		{
			if ((bl_81 & 0x01) != 0x00)
				return;
			edi_128 = internal/poll.runtime_Semacquire(edi_128, gs, ecx_25);
		}
	}
}

// 0809D9B0: void internal/poll.(*fdMutex).rwunlock(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack byte bArg08)
// Called from:
//      internal/poll.(*FD).writeUnlock
void internal/poll.(*fdMutex).rwunlock(struct Eq_2 * gs, Eq_4 dwArg04, byte bArg08)
{
	ui32 dwLoc30 = SLICE(qwLoc34, word32, 32);
	ui32 dwLoc34 = (word32) qwLoc34;
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	ui32 ebp_30;
	ui32 ebx_27;
	uint32 edi_32;
	ui32 edx_26;
	ui32 esi_31;
	if (bArg08 != 0x00)
	{
		edx_26 = 0x02;
		ebx_27 = 0xFF800000;
		ebp_30 = 0x07FF;
		esi_31 = 0x00;
		edi_32 = 0x00800000;
	}
	else
	{
		edx_26 = 0x04;
		ebx_27 = 0x00;
		ebp_30 = 0x7FFFF800;
		esi_31 = 0x0800;
		edi_32 = 0x00;
	}
	do
	{
		sync/atomic.LoadUint64(dwArg04);
		ui24 ecx_24_8_135 = SLICE(dwLoc34, word24, 8);
		if (((int8) ((edx_26 & dwLoc34) == 0x00) & 0x01) != 0x00 || ((int8) ((dwLoc34 & 0x007FFFF8) == 0x00) & 0x01) != 0x00)
			runtime.gopanic(gs);
		uint32 edx_113 = ~edx_26 & dwLoc34;
		ui32 ebp_137 = SEQ(SLICE(dwLoc30, word24, 8), (int8) ((ebp_30 & dwLoc30) != 0x00)) | SEQ(ecx_24_8_135, (int8) ((ebx_27 & dwLoc34) != 0x00));
		ui32 eax_118 = dwLoc30 + ~0x00 + (edx_113 < ~0x07);
		byte al_141 = (byte) ebp_137;
		Eq_4 eax_edx_297 = SEQ(eax_118, edx_113 + ~0x07);
		if ((byte) ebp_137 != 0x00)
		{
			uint32 edx_157 = edx_113 + ~0x07 - edi_32;
			eax_edx_297 = SEQ(eax_118 - esi_31 - (edx_157 < 0x00), edx_157);
		}
		word32 ebx_300;
		sync/atomic.CompareAndSwapUint64(dwArg04, qwLoc34, eax_edx_297, out ebx_300);
	} while (bLoc24 == 0x00);
	if (al_141 != 0x00)
		internal/poll.runtime_Semrelease(gs);
}

// 0809DB30: Register word32 internal/poll.(*FD).decref(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      internal/poll.(*FD).Close
word32 internal/poll.(*FD).decref(struct Eq_2 * gs, Eq_4 dwArg04)
{
	byte bLoc08 = (byte) dwLoc08;
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	internal/poll.(*fdMutex).decref(gs, dwArg04);
	if (bLoc08 == 0x00)
		return esi;
	return internal/poll.(*FD).destroy(gs, dwArg04);
}

// 0809DBA0: void internal/poll.(*FD).writeLock(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      internal/poll.(*FD).Write
void internal/poll.(*FD).writeLock(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	internal/poll.(*fdMutex).rwlock(gs, dwArg04, 0x00);
	if (bLoc04 != 0x00)
		return;
	*((word32) dwArg04 + 30) == 0x00;
}

// 0809DC20: void internal/poll.(*FD).writeUnlock(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void internal/poll.(*FD).writeUnlock(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	internal/poll.(*fdMutex).rwunlock(gs, dwArg04, 0x00);
	if (bLoc04 != 0x00)
		internal/poll.(*FD).destroy(gs, dwArg04);
}

// 0809DC70: Register Eq_4 internal/poll.(*pollDesc).init(Register (ptr32 Eq_2) gs, Stack (ptr32 ptr32) dwArg04, Stack Eq_4 dwArg08)
// Called from:
//      internal/poll.(*FD).Init
Eq_4 internal/poll.(*pollDesc).init(struct Eq_2 * gs, ptr32 * dwArg04, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 esi_51;
	internal/poll.runtime_pollOpen(sync.(*Once).Do(gs, 0x081576D0, &g_ptr80E7B18), gs, *((word32) dwArg08 + 16), out esi_51);
	if (dwLoc14 == 0x00)
	{
		*dwArg04 = 0x080E7B18;
		return esi_51;
	}
	else
	{
		internal/poll.runtime_pollUnblock(esi_51, gs, &g_ptr80E7B18);
		word32 esi_193;
		internal/poll.runtime_pollClose(gs, 0x080E7B18, out esi_193);
	}
}

// 0809DD40: Register word32 internal/poll.(*pollDesc).close(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_4) dwArg04)
// Called from:
//      internal/poll.(*FD).destroy
word32 internal/poll.(*pollDesc).close(struct Eq_2 * gs, union Eq_4 * dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 ecx_18 = *dwArg04;
	if (ecx_18 == 0x00)
		return esi;
	word32 esi_29;
	internal/poll.runtime_pollClose(gs, ecx_18, out esi_29);
	*dwArg04 = (union Eq_4 *) 0x00;
	return esi_29;
}

// 0809DD80: void internal/poll.(*pollDesc).evict(Register Eq_4 esi, Register (ptr32 Eq_2) gs, Stack (ptr32 (ptr32 Eq_40037)) dwArg04)
// Called from:
//      internal/poll.(*FD).Close
void internal/poll.(*pollDesc).evict(Eq_4 esi, struct Eq_2 * gs, struct Eq_40037 ** dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	struct Eq_40037 * eax_18 = *dwArg04;
	if (eax_18 == null)
		return;
	internal/poll.runtime_pollUnblock(esi, gs, eax_18);
}

// 0809DDC0: void internal/poll.(*pollDesc).prepare(Register word32 ebp, Register (ptr32 Eq_2) gs, Stack (ptr32 (ptr32 Eq_39794)) dwArg04, Stack word32 dwArg08, Stack byte bArg0C)
// Called from:
//      internal/poll.(*pollDesc).prepareWrite
void internal/poll.(*pollDesc).prepare(word32 ebp, struct Eq_2 * gs, struct Eq_39794 ** dwArg04, word32 dwArg08, byte bArg0C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	struct Eq_39794 * eax_18 = *dwArg04;
	if (eax_18 == null)
		return;
	internal/poll.convertErr(SLICE(internal/poll.runtime_pollReset(ebp, gs, eax_18, dwArg08), word24, 8), gs, dwLoc08, bArg0C);
}

// 0809DE40: void internal/poll.(*pollDesc).prepareWrite(Register word32 ebp, Register (ptr32 Eq_2) gs, Stack (ptr32 (ptr32 Eq_39794)) dwArg04, Stack byte bArg08)
// Called from:
//      internal/poll.(*FD).Write
void internal/poll.(*pollDesc).prepareWrite(word32 ebp, struct Eq_2 * gs, struct Eq_39794 ** dwArg04, byte bArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	internal/poll.(*pollDesc).prepare(ebp, gs, dwArg04, 0x77, bArg08);
}

// 0809DE90: void internal/poll.(*pollDesc).wait(Register (ptr32 Eq_39870) ebp, Register (ptr32 Eq_2) gs, Stack (ptr32 word32) dwArg04, Stack (ptr32 Eq_39873) dwArg08, Stack byte bArg0C)
// Called from:
//      internal/poll.(*pollDesc).waitWrite
void internal/poll.(*pollDesc).wait(struct Eq_39870 * ebp, struct Eq_2 * gs, word32 * dwArg04, struct Eq_39873 * dwArg08, byte bArg0C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	struct Eq_39872 * eax_18 = *dwArg04;
	if (eax_18 != null)
		internal/poll.convertErr(SLICE(internal/poll.runtime_pollWait(ebp, gs, eax_18, dwArg08), word24, 8), gs, dwLoc0C, bArg0C);
	else
	{
		runtime.newobject(gs, 0x080D1920);
		*((word32) dwLoc10 + 4) = 33;
		if (g_t81576F0 == 0x00)
			*dwLoc10 = 0x080E58FE;
		else
			runtime.writebarrierptr(dwLoc10, 0x080E58FE);
	}
}

// 0809DF50: void internal/poll.(*pollDesc).waitWrite(Register (ptr32 Eq_39870) ebp, Register (ptr32 Eq_2) gs, Stack (ptr32 word32) dwArg04, Stack byte bArg08)
// Called from:
//      internal/poll.(*FD).Write
void internal/poll.(*pollDesc).waitWrite(struct Eq_39870 * ebp, struct Eq_2 * gs, word32 * dwArg04, byte bArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	internal/poll.(*pollDesc).wait(ebp, gs, dwArg04, (struct Eq_39873 *) 0x77, bArg08);
}

// 0809DFA0: void internal/poll.convertErr(Register word24 ebx_24_8, Register (ptr32 Eq_2) gs, Stack Eq_105621 dwArg04, Stack byte bArg08)
// Called from:
//      internal/poll.(*pollDesc).prepare
//      internal/poll.(*pollDesc).wait
void internal/poll.convertErr(word24 ebx_24_8, struct Eq_2 * gs, Eq_105621 dwArg04, byte bArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (dwArg04 == 0x00)
		return;
	if (dwArg04 == 0x01)
		return;
	if (dwArg04 == 0x02)
		return;
	runtime.printlock(gs);
	runtime.printstring(gs);
	runtime.printsp(gs);
	runtime.printint(ebx_24_8, gs, SEQ(dwArg04 >> 0x1F, dwArg04));
	runtime.printnl(gs);
	runtime.printunlock(gs);
	runtime.gopanic(gs);
}

// 0809E090: Register word32 internal/poll.(*FD).Init(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack (ptr32 word32) dwArg08, Stack word32 dwArg0C, Stack byte bArg10)
// Called from:
//      os.newFile
word32 internal/poll.(*FD).Init(struct Eq_2 * gs, Eq_4 dwArg04, word32 * dwArg08, word32 dwArg0C, byte bArg10)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (dwArg0C == 0x04 && *dwArg08 == 0x656C6966)
		*((word32) dwArg04 + 30) = 0x01;
	if (bArg10 == 0x00)
		return esi;
	return internal/poll.(*pollDesc).init(gs, (word32) dwArg04 + 20, dwArg04);
}

// 0809E120: Register word32 internal/poll.(*FD).destroy(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      internal/poll.(*FD).decref
//      internal/poll.(*FD).writeUnlock
word32 internal/poll.(*FD).destroy(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	word32 esi_29 = internal/poll.(*pollDesc).close(gs, (word32) dwArg04 + 20);
	<anonymous> ** edx_35 = internal/poll.CloseFunc;
	<anonymous> * ecx_39 = *edx_35;
	ecx_39();
	*((word32) dwArg04 + 16) = ~0x00;
	return esi_29;
}

// 0809E180: Register Eq_4 internal/poll.(*FD).Close(Register Eq_4 esi, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      os.(*file).close
Eq_4 internal/poll.(*FD).Close(Eq_4 esi, struct Eq_2 * gs, Eq_4 dwArg04)
{
	byte bLoc08 = (byte) dwLoc08;
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	internal/poll.(*fdMutex).increfAndClose(gs, dwArg04);
	if (bLoc08 != 0x00)
	{
		internal/poll.(*pollDesc).evict(esi, gs, (word32) dwArg04 + 20);
		return internal/poll.(*FD).decref(gs, dwArg04);
	}
	else
	{
		*((word32) dwArg04 + 30) == 0x00;
		return esi;
	}
}

// 0809E220: void internal/poll.(*FD).Write(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack (ptr32 Eq_39870) dwArg0C, Stack (ptr32 Eq_39870) dwArg10)
// Called from:
//      os.(*File).write
void internal/poll.(*FD).Write(struct Eq_2 * gs, Eq_4 dwArg04, struct Eq_39870 * dwArg0C, struct Eq_39870 * dwArg10)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	internal/poll.(*FD).writeLock(gs, dwArg04);
	if (dwLoc28 != 0x00)
	{
		word128 xmm0_561;
		word128 xmm1_562;
		runtime.deferreturn(gs, out xmm0_561, out xmm1_562);
	}
	else
	{
		word32 ebp_71;
		word32 edi_564;
		word32 esi_563;
		if (runtime.deferproc(gs, 0x04, 0x080E7B14, dwArg04, out ebp_71, out esi_563, out edi_564) != 0x00)
		{
			word128 xmm1_566;
			word128 xmm0_565;
			runtime.deferreturn(gs, out xmm0_565, out xmm1_566);
		}
		else
		{
			internal/poll.(*pollDesc).prepareWrite(ebp_71, gs, (word32) dwArg04 + 20, *((word32) dwArg04 + 30));
			if (dwArg04 != 0x00)
			{
				word128 xmm0_567;
				word128 xmm1_568;
				runtime.deferreturn(gs, out xmm0_567, out xmm1_568);
			}
			else
			{
				struct Eq_39870 * eax_161 = null;
				while (true)
				{
					struct Eq_39870 * edx_180;
					if (*((word32) dwArg04 + 28) != 0x00 && dwArg0C - eax_161 > 0x40000000)
						edx_180 = &eax_161->ptr0004 + 0x0FFFFFFF;
					else
						edx_180 = dwArg0C;
					if (eax_161 > edx_180 || edx_180 > dwArg10)
						break;
					struct Eq_39870 * ebx_238;
					struct Eq_104293 * edx_217 = edx_180 - eax_161;
					syscall.Write(gs, edx_217);
					struct Eq_104293 * eax_233 = dwLoc18;
					if (dwLoc1C > null)
						ebx_238 = eax_161 + dwLoc1C;
					else
						ebx_238 = eax_161;
					if (ebx_238 == dwArg0C)
					{
						word128 xmm1_570;
						word128 xmm0_569;
						runtime.deferreturn(gs, out xmm0_569, out xmm1_570);
						return;
					}
					if (dwLoc18 != null && (dwLoc18->ptr0004 == 0x080D5060 && (*dwLoc14 == 11 && *((word32) dwArg04 + 20) != 0x00)))
					{
						internal/poll.(*pollDesc).waitWrite(dwArg0C, gs, (word32) dwArg04 + 20, *((word32) dwArg04 + 30));
						if (edx_217 == null)
							goto l0809E2C2;
						eax_233 = edx_217;
					}
					if (eax_233 != null)
					{
						word128 xmm1_572;
						word128 xmm0_571;
						runtime.deferreturn(gs, out xmm0_571, out xmm1_572);
						return;
					}
					if (dwLoc1C == null)
					{
						word128 xmm0_573;
						word128 xmm1_574;
						runtime.deferreturn(gs, out xmm0_573, out xmm1_574);
						return;
					}
l0809E2C2:
					eax_161 = ebx_238;
				}
				runtime.panicslice(gs);
			}
		}
	}
}

// 0809E4C0: void internal/poll.init(Register (ptr32 Eq_2) gs)
// Called from:
//      os.init
void internal/poll.init(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	cu8 al_18 = g_b8157561;
	if (al_18 > 0x01)
		return;
	if (al_18 != 0x01)
	{
		g_b8157561 = 0x01;
		word32 esi_255;
		word32 edi_256;
		sync.init(gs, out esi_255, out edi_256);
		syscall.init(gs);
		time.init(gs);
		io.init(gs);
		errors.New(gs, 0x080E5563, 0x20);
		g_t8145020 = dwLoc08;
		if (g_t81576F0 == 0x00)
			g_t8145024 = dwLoc04;
		else
			runtime.writebarrierptr(0x08145024, dwLoc04);
		errors.New(gs, 0x080E2B02, 0x12);
		g_t8145018 = dwLoc08;
		if (g_t81576F0 == 0x00)
			g_t814501C = dwLoc04;
		else
			runtime.writebarrierptr(0x0814501C, dwLoc04);
		g_b8157561 = 0x02;
	}
	else
		runtime.throwinit(gs);
}

// 0809E5C0: Register Eq_4 type..hash.internal/poll.FD(Register (ptr32 Eq_2) gs, Register Eq_4 mm0, Stack (ptr32 Eq_205) dwArg04, Stack (ptr32 Eq_205) dwArg08)
// Called from:
//      type..hash.os.file
Eq_4 type..hash.internal/poll.FD(struct Eq_2 * gs, Eq_4 mm0, union Eq_205 * dwArg04, union Eq_205 * dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	word128 xmm1_65;
	return runtime.memhash(gs, mm0, dwArg04, dwArg08, 0x1F, out xmm1_65);
}

// 0809E610: void type..eq.internal/poll.FD(Register Eq_4 edx, Register (ptr32 Eq_106093) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
// Called from:
//      type..eq.os.file
void type..eq.internal/poll.FD(Eq_4 edx, struct Eq_106093 * gs, Eq_4 dwArg04, Eq_4 dwArg08)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		edx = runtime.morestack_noctxt();
	word32 ebx_58;
	word32 esi_59;
	word32 edi_60;
	runtime.memequal(edx, dwArg04, dwArg08, 0x1F, out ebx_58, out esi_59, out edi_60);
}

// 0809E660: void os.(*PathError).Error(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_106118) dwArg04)
void os.(*PathError).Error(struct Eq_2 * gs, struct Eq_106118 * dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	word32 edx_20 = dwArg04->dw0014;
	<anonymous> * ecx_21 = dwArg04->ptr0010->ptr0014;
	ecx_21();
	word32 ecx_29 = dwArg04->dw0000;
	word32 edx_30 = dwArg04->dw0004;
	runtime.concatstring5(gs, 0x00);
}

// 0809E710: void os.(*File).Name(Register (ptr32 Eq_106153) gs)
void os.(*File).Name(struct Eq_106153 * gs)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
}

// 0809E740: void os.(*File).Write(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_4) dwArg04, Stack (ptr32 Eq_39870) dwArg0C, Stack (ptr32 Eq_39870) dwArg10)
void os.(*File).Write(struct Eq_2 * gs, union Eq_4 * dwArg04, struct Eq_39870 * dwArg0C, struct Eq_39870 * dwArg10)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 edx_21;
	if (dwArg04 != null)
		edx_21.u0 = 0x00;
	else
		edx_21 = g_t8145078;
	if (edx_21 != 0x00)
		return;
	os.(*File).write(gs, dwArg04, dwArg0C, dwArg10);
	byte bLoc30_320 = (byte) dwArg10;
	struct Eq_39870 * eax_69 = dwLoc2C;
	if (dwLoc2C < null)
		eax_69 = null;
	os.epipecheck(gs, dwArg04, dwLoc28, dwLoc24);
	Eq_4 dwLoc38_313 = dwLoc28;
	if (dwLoc28 == 0x00)
		return;
	if (g_t8145028 == dwLoc28)
	{
		runtime.ifaceeq(gs, dwLoc28, dwLoc24, g_t814502C);
		dwLoc38_313 = dwLoc24;
		if (bLoc30_320 != 0x00)
			return;
	}
	Eq_4 ecx_170;
	Eq_4 eax_148 = dwLoc28;
	if (g_t8145018 != dwLoc28)
		ecx_170 = dwLoc24;
	else
	{
		runtime.ifaceeq(gs, dwLoc28, dwLoc24, g_t814501C);
		dwLoc38_313 = dwLoc24;
		if (bLoc30_320 != 0x00)
		{
			eax_148 = g_t8145068;
			ecx_170 = g_t814506C;
		}
		else
		{
			ecx_170 = dwLoc24;
			eax_148 = dwLoc28;
		}
	}
	runtime.newobject(gs, 0x080D57C0);
	*((word32) dwLoc38_313 + 4) = 0x05;
	if (g_t81576F0 == 0x00)
		*dwLoc38_313 = 0x080E1065;
	else
		runtime.writebarrierptr(dwLoc38_313, 0x080E1065);
	Eq_4 ecx_214 = *dwArg04;
	Eq_4 edx_215 = *((word32) ecx_214 + 32);
	*((word32) dwLoc38_313 + 0x0C) = *((word32) ecx_214 + 36);
	Eq_4 ebx_220 = (word32) dwLoc38_313 + 8;
	if (g_t81576F0 == 0x00)
		*((word32) dwLoc38_313 + 8) = edx_215;
	else
		runtime.writebarrierptr(ebx_220, edx_215);
	*((word32) dwLoc38_313 + 16) = eax_148;
	Eq_4 edx_242 = (word32) dwLoc38_313 + 20;
	if (g_t81576F0 == 0x00)
		*((word32) dwLoc38_313 + 20) = ecx_170;
	else
		runtime.writebarrierptr(edx_242, ecx_170);
}

// 0809E9A0: void os.Readlink(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
// Called from:
//      os.glob..func1
void os.Readlink(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 eax_18 = 0x80;
	while (true)
	{
		word32 edi_383;
		runtime.makeslice(gs, 0x080CF320, eax_18, eax_18, out edi_383);
		syscall.Readlink(gs, dwArg04, dwArg08, dwLoc28);
		dwLoc2C = dwLoc28;
		dwLoc28 = dwLoc24;
		Eq_4 ecx_177 = dwLoc24;
		if (dwLoc24 < 0x00)
			ecx_177.u0 = 0x00;
		if (dwLoc20 != 0x00)
			break;
		if (ecx_177 < eax_18)
		{
			if (ecx_177 > dwLoc24)
				runtime.panicslice(gs);
			else
			{
				runtime.slicebytetostring(gs, 0x00, dwLoc2C, ecx_177);
				return;
			}
		}
		eax_18 <<= 0x01;
	}
	runtime.newobject(gs, 0x080D57C0);
	*((word32) dwArg08 + 4) = 0x08;
	if (g_t81576F0 == 0x00)
		*dwArg08 = 135140565;
	else
		runtime.writebarrierptr(dwArg08, 135140565);
	*((word32) dwArg08 + 0x0C) = dwArg08;
	if (g_t81576F0 == 0x00)
		*((word32) dwArg08 + 8) = dwArg04;
	else
		runtime.writebarrierptr((word32) dwArg08 + 8, dwArg04);
	*((word32) dwArg08 + 16) = dwLoc20;
	if (g_t81576F0 == 0x00)
		*((word32) dwArg08 + 20) = dwLoc1C;
	else
		runtime.writebarrierptr((word32) dwArg08 + 20, dwLoc1C);
}

// 0809EB70: void os.NewFile(Register (ptr32 Eq_2) gs, Stack int32 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C)
// Called from:
//      os.init
void os.NewFile(struct Eq_2 * gs, int32 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	os.newFile(gs, dwArg04, dwArg08, dwArg0C, 0x00);
}

// 0809EBC0: void os.newFile(Register (ptr32 Eq_2) gs, Stack int32 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C, Stack byte bArg10)
// Called from:
//      os.NewFile
void os.newFile(struct Eq_2 * gs, int32 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C, byte bArg10)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (dwArg04 < 0x00)
		return;
	runtime.newobject(gs, 0x080D4820);
	runtime.newobject(gs, 0x080D69A0);
	*((word32) dwLoc1C + 16) = dwArg04;
	((word32) dwLoc1C + 28)->u2 = 0x0101;
	*((word32) dwLoc1C + 36) = dwArg0C;
	if (g_t81576F0 == 0x00)
		*((word32) dwLoc1C + 32) = dwArg08;
	else
		runtime.writebarrierptr((word32) dwLoc1C + 32, dwArg08);
	if (g_t81576F0 == 0x00)
		*dwLoc1C = dwLoc1C;
	else
		runtime.writebarrierptr(dwLoc1C, dwLoc1C);
	Eq_4 esi_116 = internal/poll.(*FD).Init(gs, dwLoc1C, &g_dw80E0F22, 0x04, bArg10);
	if (dwLoc10 == 0x00 && bArg10 != 0x00)
		esi_116 = syscall.SetNonblock(gs, 0x01);
	runtime.SetFinalizer(esi_116, gs, 0x080D0640, *dwLoc1C, 0x080CDEA0);
}

// 0809ED30: void os.epipecheck(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_4) dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C)
// Called from:
//      os.(*File).Write
void os.epipecheck(struct Eq_2 * gs, union Eq_4 * dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (dwArg08 != 0x00 && (*((word32) dwArg08 + 4) == 0x080D5060 && *dwArg0C == 0x20))
	{
		word32 eax_30 = *((char *) *dwArg04 + 16);
		if (eax_30 == 0x01 || eax_30 == 0x02)
			os.sigpipe(gs);
	}
}

// 0809ED90: void os.(*file).close(Register Eq_4 esi, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void os.(*file).close(Eq_4 esi, struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (dwArg04 == 0x00)
		return;
	Eq_4 esi_36 = internal/poll.(*FD).Close(esi, gs, dwArg04);
	Eq_4 eax_43 = dwLoc20;
	Eq_4 ecx_44 = dwLoc1C;
	if (dwLoc20 != 0x00)
	{
		if (dwLoc20 == g_t8145018)
		{
			runtime.ifaceeq(gs, dwLoc20, dwLoc1C, g_t814501C);
			dwLoc20 = dwLoc1C;
			if (bLoc18 != 0x00)
			{
				eax_43 = g_t8145068;
				ecx_44 = g_t814506C;
			}
			else
			{
				ecx_44 = dwLoc1C;
				eax_43 = dwLoc20;
			}
		}
		runtime.newobject(gs, 0x080D57C0);
		*((word32) dwLoc20 + 4) = 0x05;
		if (g_t81576F0 == 0x00)
			*dwLoc20 = 135139369;
		else
			runtime.writebarrierptr(dwLoc20, 135139369);
		Eq_4 edx_117 = *((word32) dwArg04 + 32);
		*((word32) dwLoc20 + 0x0C) = *((word32) dwArg04 + 36);
		Eq_4 ebp_122 = (word32) dwLoc20 + 8;
		if (g_t81576F0 == 0x00)
			*((word32) dwLoc20 + 8) = edx_117;
		else
			runtime.writebarrierptr(ebp_122, edx_117);
		*((word32) dwLoc20 + 16) = eax_43;
		Eq_4 ebx_145 = (word32) dwLoc20 + 20;
		if (g_t81576F0 == 0x00)
			*((word32) dwLoc20 + 20) = ecx_44;
		else
			runtime.writebarrierptr(ebx_145, ecx_44);
	}
	runtime.SetFinalizer(esi_36, gs, 0x080D0640, dwArg04, 0x00);
}

// 0809EF60: void os.(*File).write(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_4) dwArg04, Stack (ptr32 Eq_39870) dwArg0C, Stack (ptr32 Eq_39870) dwArg10)
// Called from:
//      os.(*File).Write
void os.(*File).write(struct Eq_2 * gs, union Eq_4 * dwArg04, struct Eq_39870 * dwArg0C, struct Eq_39870 * dwArg10)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	internal/poll.(*FD).Write(gs, *dwArg04, dwArg0C, dwArg10);
}

// 0809EFC0: void os.init.0(Register (ptr32 Eq_2) gs)
// Called from:
//      os.init
void os.init.0(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	os.runtime_args(gs);
	g_dw81450EC = dwLoc08;
	g_dw81450F0 = dwLoc04;
	if (g_t81576F0 == 0x00)
		g_t81450E8 = dwLoc0C;
	else
		runtime.writebarrierptr(0x081450E8, dwLoc0C);
}

// 0809F020: void os.glob..func1(Register (ptr32 Eq_2) gs)
// Called from:
//      os.init
void os.glob..func1(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	os.Readlink(gs, 135143494, 0x0E);
}

// 0809F080: void os.init(Register (ptr32 Eq_2) gs)
// Called from:
//      fmt.init
void os.init(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	cu8 al_18 = g_b8157564;
	if (al_18 > 0x01)
		return;
	if (al_18 != 0x01)
	{
		g_b8157564 = 0x01;
		io.init(gs);
		word32 edi_666;
		word32 esi_665;
		runtime.init(gs, out esi_665, out edi_666);
		syscall.init(gs);
		word32 edi_668;
		word32 esi_667;
		sync.init(gs, out esi_667, out edi_668);
		time.init(gs);
		internal/poll.init(gs);
		errors.New(gs, 135144825, 0x10);
		g_t8145078 = dwLoc10;
		if (g_t81576F0 == 0x00)
			g_t814507C = dwLoc0C;
		else
			runtime.writebarrierptr(135549052, dwLoc0C);
		errors.New(gs, 0x080E2862, 0x11);
		g_t8145088 = dwLoc10;
		if (g_t81576F0 == 0x00)
			g_t814508C = dwLoc0C;
		else
			runtime.writebarrierptr(0x0814508C, dwLoc0C);
		errors.New(gs, 0x080E2CC8, 0x13);
		g_t8145070 = dwLoc10;
		if (g_t81576F0 == 0x00)
			g_t8145074 = dwLoc0C;
		else
			runtime.writebarrierptr(135549044, dwLoc0C);
		errors.New(gs, 135146715, 0x13);
		g_t8145080 = dwLoc10;
		if (g_t81576F0 == 0x00)
			g_t8145084 = dwLoc0C;
		else
			runtime.writebarrierptr(0x08145084, dwLoc0C);
		errors.New(gs, 135146677, 0x13);
		g_t8145068 = dwLoc10;
		if (g_t81576F0 == 0x00)
			g_t814506C = dwLoc0C;
		else
			runtime.writebarrierptr(0x0814506C, dwLoc0C);
		errors.New(gs, 135153952, 0x1C);
		g_t8145090 = dwLoc10;
		Eq_4 dwLoc18_574 = 135153952;
		Eq_4 dwLoc14_575 = 0x1C;
		if (g_t81576F0 == 0x00)
			g_t8145094 = dwLoc0C;
		else
		{
			runtime.writebarrierptr(0x08145094, dwLoc0C);
			dwLoc18_574.u0 = 0x08145094;
			dwLoc14_575 = dwLoc0C;
		}
		os.glob..func1(gs);
		g_t814509C = dwLoc14_575;
		if (g_t81576F0 == 0x00)
			g_t8145098 = dwLoc18_574;
		else
			runtime.writebarrierptr(0x08145098, dwLoc18_574);
		g_t81450A0 = dwLoc10;
		if (g_t81576F0 == 0x00)
			g_t81450A4 = dwLoc0C;
		else
			runtime.writebarrierptr(0x081450A4, dwLoc0C);
		os.NewFile(gs, syscall.Stdin, 135141511, 0x0A);
		if (g_t81576F0 == 0x00)
			os.Stdin = dwLoc0C;
		else
			runtime.writebarrierptr(0x08144F94, dwLoc0C);
		os.NewFile(gs, syscall.Stdout, 135141985, 11);
		if (g_t81576F0 == 0x00)
			os.Stdout = dwLoc0C;
		else
			runtime.writebarrierptr(135548824, dwLoc0C);
		os.NewFile(gs, syscall.Stderr, 135141974, 11);
		if (g_t81576F0 == 0x00)
			os.Stderr = dwLoc0C;
		else
			runtime.writebarrierptr(0x08144F90, dwLoc0C);
		os.init.0(gs);
		g_b8157564 = 0x02;
	}
	else
		runtime.throwinit(gs);
}

// 0809F430: void type..hash.os.file(Register (ptr32 Eq_2) gs, Register Eq_4 mm0, Stack (ptr32 Eq_205) dwArg04, Stack (ptr32 Eq_205) dwArg08)
void type..hash.os.file(struct Eq_2 * gs, Eq_4 mm0, union Eq_205 * dwArg04, union Eq_205 * dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	word128 xmm1_120;
	runtime.memhash(gs, runtime.strhash(gs, type..hash.internal/poll.FD(gs, mm0, dwArg04, dwArg08), (char *) dwArg04 + 32, dwLoc08), (char *) dwArg04 + 40, dwLoc08, 0x05, out xmm1_120);
}

// 0809F4B0: void type..eq.os.file(Register Eq_4 edx, Register (ptr32 Eq_106093) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
void type..eq.os.file(Eq_4 edx, struct Eq_106093 * gs, Eq_4 dwArg04, Eq_4 dwArg08)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		edx = runtime.morestack_noctxt();
	uip32 ecx_160;
	type..eq.internal/poll.FD(edx, gs, dwArg04, dwArg08);
	if (bLoc0C != 0x00)
	{
		Eq_4 ecx_46 = *((word32) dwArg04 + 32);
		Eq_4 ebx_48 = *((word32) dwArg08 + 32);
		Eq_4 ebp_49 = *((word32) dwArg04 + 36);
		if (ebp_49 != *((word32) dwArg08 + 36))
			ecx_160 = 0x00;
		else
		{
			word32 ebx_163;
			word32 esi_164;
			word32 edi_165;
			runtime.eqstring(dwArg08, ecx_46, ebp_49, ebx_48, out ebx_163, out esi_164, out edi_165);
			ecx_160 = (word32) bLoc04;
		}
	}
	else
		ecx_160 = 0x00;
	if ((byte) ecx_160 != 0x00)
		*((word32) dwArg04 + 40) != *((word32) dwArg08 + 40);
}

// 0809F570: void type..hash.os.PathError(Register (ptr32 Eq_2) gs, Register Eq_4 mm0, Stack (ptr32 Eq_636) dwArg04, Stack (ptr32 Eq_205) dwArg08)
void type..hash.os.PathError(struct Eq_2 * gs, Eq_4 mm0, struct Eq_636 * dwArg04, union Eq_205 * dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.strhash(gs, runtime.strhash(gs, mm0, dwArg04, dwArg08), (char *) &dwArg04->t0004 + 4, dwLoc04);
	runtime.interhash(gs, (char *) &dwArg04->t0004 + 0x0C, dwLoc04);
}

// 0809F5E0: void type..eq.os.PathError(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_107036) dwArg04, Stack (ptr32 Eq_107037) dwArg08)
void type..eq.os.PathError(struct Eq_2 * gs, struct Eq_107036 * dwArg04, struct Eq_107037 * dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	byte cl_45;
	Eq_4 edx_19 = dwArg08->t0000;
	Eq_4 ebp_21 = dwArg04->t0004;
	Eq_4 esi_22 = dwArg04->t0000;
	if (dwArg08->t0004 != ebp_21)
		cl_45 = 0x00;
	else
	{
		word32 esi_198;
		word32 edi_199;
		word32 ebx_197;
		runtime.eqstring(edx_19, esi_22, ebp_21, edx_19, out ebx_197, out esi_198, out edi_199);
		cl_45 = bLoc04;
	}
	uip32 ecx_194;
	if (cl_45 != 0x00)
	{
		Eq_4 edx_57 = dwArg08->t0008;
		Eq_4 ebp_59 = dwArg04->t000C;
		Eq_4 esi_60 = dwArg04->t0008;
		if (ebp_59 != dwArg08->t000C)
			ecx_194 = 0x00;
		else
		{
			word32 ebx_200;
			word32 esi_201;
			word32 edi_202;
			runtime.eqstring(edx_57, esi_60, ebp_59, edx_57, out ebx_200, out esi_201, out edi_202);
			ecx_194 = (word32) bLoc04;
		}
	}
	else
		ecx_194 = 0x00;
	if ((byte) ecx_194 != 0x00)
	{
		Eq_4 ecx_96 = dwArg04->t0010;
		Eq_4 edx_98 = dwArg08->t0014;
		Eq_4 ebx_100 = dwArg04->t0014;
		if (ecx_96 == dwArg08->t0010)
			runtime.ifaceeq(gs, ecx_96, ebx_100, edx_98);
	}
}

// 0809F6C0: void unicode.init(Register word32 ebx, Register Eq_4 esi, Register Eq_4 edi, Register (ptr32 Eq_2) gs)
// Called from:
//      reflect.init
void unicode.init(word32 ebx, Eq_4 esi, Eq_4 edi, struct Eq_2 * gs)
{
	word24 ebx_24_8 = SLICE(ebx, word24, 8);
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	cu8 al_18 = g_b8157588;
	if (al_18 > 0x01)
		return;
	if (al_18 != 0x01)
	{
		g_b8157588 = 0x01;
		word32 edi_14157;
		runtime.makemap(ebx_24_8, esi, edi, gs, 0x080CFB40, 0x24, 0x00, 0x00, 0x00, out edi_14157);
		Eq_4 ecx_52 = unicode.C;
		word32 esi_14158;
		word32 edi_14159;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_14158, out edi_14159);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) ecx_52;
		else
			runtime.writebarrierptr(0x00, ecx_52);
		Eq_4 eax_103 = unicode.Cc;
		word32 esi_14160;
		word32 edi_14161;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_14160, out edi_14161);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_103;
		else
			runtime.writebarrierptr(0x00, eax_103);
		Eq_4 eax_157 = unicode.Cf;
		word32 esi_14162;
		word32 edi_14163;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_14162, out edi_14163);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_157;
		else
			runtime.writebarrierptr(0x00, eax_157);
		Eq_4 eax_211 = unicode.Co;
		word32 edi_14585;
		word32 esi_14584;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_14584, out edi_14585);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_211;
		else
			runtime.writebarrierptr(0x00, eax_211);
		Eq_4 eax_265 = unicode.Cs;
		word32 esi_14164;
		word32 edi_14165;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_14164, out edi_14165);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_265;
		else
			runtime.writebarrierptr(0x00, eax_265);
		Eq_4 eax_319 = unicode.L;
		word32 edi_14583;
		word32 esi_14582;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_14582, out edi_14583);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_319;
		else
			runtime.writebarrierptr(0x00, eax_319);
		Eq_4 eax_373 = unicode.Ll;
		word32 edi_14581;
		word32 esi_14580;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_14580, out edi_14581);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_373;
		else
			runtime.writebarrierptr(0x00, eax_373);
		Eq_4 eax_427 = unicode.Lm;
		word32 edi_14579;
		word32 esi_14578;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_14578, out edi_14579);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_427;
		else
			runtime.writebarrierptr(0x00, eax_427);
		Eq_4 eax_481 = unicode.Lo;
		word32 edi_14167;
		word32 esi_14166;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_14166, out edi_14167);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_481;
		else
			runtime.writebarrierptr(0x00, eax_481);
		Eq_4 eax_535 = unicode.Lt;
		word32 edi_14577;
		word32 esi_14576;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_14576, out edi_14577);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_535;
		else
			runtime.writebarrierptr(0x00, eax_535);
		Eq_4 eax_589 = unicode.Lu;
		word32 edi_14575;
		word32 esi_14574;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_14574, out edi_14575);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_589;
		else
			runtime.writebarrierptr(0x00, eax_589);
		Eq_4 eax_643 = unicode.M;
		word32 edi_14573;
		word32 esi_14572;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_14572, out edi_14573);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_643;
		else
			runtime.writebarrierptr(0x00, eax_643);
		Eq_4 eax_697 = unicode.Mc;
		word32 edi_14571;
		word32 esi_14570;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_14570, out edi_14571);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_697;
		else
			runtime.writebarrierptr(0x00, eax_697);
		Eq_4 eax_751 = unicode.Me;
		word32 edi_14569;
		word32 esi_14568;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_14568, out edi_14569);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_751;
		else
			runtime.writebarrierptr(0x00, eax_751);
		Eq_4 eax_805 = unicode.Mn;
		word32 edi_14567;
		word32 esi_14566;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_14566, out edi_14567);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_805;
		else
			runtime.writebarrierptr(0x00, eax_805);
		Eq_4 eax_859 = unicode.N;
		word32 edi_14565;
		word32 esi_14564;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_14564, out edi_14565);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_859;
		else
			runtime.writebarrierptr(0x00, eax_859);
		Eq_4 eax_913 = unicode.Nd;
		word32 edi_14169;
		word32 esi_14168;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_14168, out edi_14169);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_913;
		else
			runtime.writebarrierptr(0x00, eax_913);
		Eq_4 eax_967 = unicode.Nl;
		word32 edi_14563;
		word32 esi_14562;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_14562, out edi_14563);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_967;
		else
			runtime.writebarrierptr(0x00, eax_967);
		Eq_4 eax_1021 = unicode.No;
		word32 edi_14561;
		word32 esi_14560;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_14560, out edi_14561);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_1021;
		else
			runtime.writebarrierptr(0x00, eax_1021);
		Eq_4 eax_1075 = unicode.P;
		word32 edi_14559;
		word32 esi_14558;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_14558, out edi_14559);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_1075;
		else
			runtime.writebarrierptr(0x00, eax_1075);
		Eq_4 eax_1129 = unicode.Pc;
		word32 edi_14557;
		word32 esi_14556;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_14556, out edi_14557);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_1129;
		else
			runtime.writebarrierptr(0x00, eax_1129);
		Eq_4 eax_1183 = unicode.Pd;
		word32 edi_14555;
		word32 esi_14554;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_14554, out edi_14555);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_1183;
		else
			runtime.writebarrierptr(0x00, eax_1183);
		Eq_4 eax_1237 = unicode.Pe;
		word32 edi_14553;
		word32 esi_14552;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_14552, out edi_14553);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_1237;
		else
			runtime.writebarrierptr(0x00, eax_1237);
		Eq_4 eax_1291 = unicode.Pf;
		word32 edi_14551;
		word32 esi_14550;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_14550, out edi_14551);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_1291;
		else
			runtime.writebarrierptr(0x00, eax_1291);
		Eq_4 eax_1345 = unicode.Pi;
		word32 edi_14549;
		word32 esi_14548;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_14548, out edi_14549);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_1345;
		else
			runtime.writebarrierptr(0x00, eax_1345);
		Eq_4 eax_1399 = unicode.Po;
		word32 edi_14547;
		word32 esi_14546;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_14546, out edi_14547);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_1399;
		else
			runtime.writebarrierptr(0x00, eax_1399);
		Eq_4 eax_1453 = unicode.Ps;
		word32 edi_14545;
		word32 esi_14544;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_14544, out edi_14545);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_1453;
		else
			runtime.writebarrierptr(0x00, eax_1453);
		Eq_4 eax_1507 = unicode.S;
		word32 edi_14543;
		word32 esi_14542;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_14542, out edi_14543);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_1507;
		else
			runtime.writebarrierptr(0x00, eax_1507);
		Eq_4 eax_1561 = unicode.Sc;
		word32 edi_14541;
		word32 esi_14540;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_14540, out edi_14541);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_1561;
		else
			runtime.writebarrierptr(0x00, eax_1561);
		Eq_4 eax_1615 = unicode.Sk;
		word32 edi_14539;
		word32 esi_14538;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_14538, out edi_14539);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_1615;
		else
			runtime.writebarrierptr(0x00, eax_1615);
		Eq_4 eax_1669 = unicode.Sm;
		word32 edi_14537;
		word32 esi_14536;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_14536, out edi_14537);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_1669;
		else
			runtime.writebarrierptr(0x00, eax_1669);
		Eq_4 eax_1723 = unicode.So;
		word32 edi_14535;
		word32 esi_14534;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_14534, out edi_14535);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_1723;
		else
			runtime.writebarrierptr(0x00, eax_1723);
		Eq_4 eax_1777 = unicode.Z;
		word32 edi_14171;
		word32 esi_14170;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_14170, out edi_14171);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_1777;
		else
			runtime.writebarrierptr(0x00, eax_1777);
		Eq_4 eax_1831 = unicode.Zl;
		word32 edi_14533;
		word32 esi_14532;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_14532, out edi_14533);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_1831;
		else
			runtime.writebarrierptr(0x00, eax_1831);
		Eq_4 eax_1885 = unicode.Zp;
		word32 edi_14531;
		word32 esi_14530;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_14530, out edi_14531);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_1885;
		else
			runtime.writebarrierptr(0x00, eax_1885);
		Eq_4 eax_1939 = unicode.Zs;
		Eq_4 edi_1954;
		Eq_4 esi_1956;
		word24 ebx_24_8_2014 = SLICE(runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_1956, out edi_1954), word24, 8);
		if (g_t81576F0 == 0x00)
		{
			null = (union Eq_4 *) eax_1939;
			unicode.Categories = dwLoc1C;
		}
		else
		{
			runtime.writebarrierptr(0x00, eax_1939);
			runtime.writebarrierptr(0x08144FF0, dwLoc1C);
		}
		word32 edi_14527;
		runtime.makemap(ebx_24_8_2014, esi_1956, edi_1954, gs, 0x080CFB40, 0x89, 0x00, 0x00, 0x00, out edi_14527);
		Eq_4 ecx_2035 = unicode.Adlam;
		word32 edi_14529;
		word32 esi_14528;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_14528, out edi_14529);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) ecx_2035;
		else
			runtime.writebarrierptr(0x00, ecx_2035);
		Eq_4 eax_2086 = unicode.Ahom;
		word32 edi_14526;
		word32 esi_14525;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_14525, out edi_14526);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_2086;
		else
			runtime.writebarrierptr(0x00, eax_2086);
		Eq_4 eax_2140 = unicode.Anatolian_Hieroglyphs;
		word32 edi_14524;
		word32 esi_14523;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_14523, out edi_14524);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_2140;
		else
			runtime.writebarrierptr(0x00, eax_2140);
		Eq_4 eax_2194 = unicode.Arabic;
		word32 edi_14522;
		word32 esi_14521;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_14521, out edi_14522);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_2194;
		else
			runtime.writebarrierptr(0x00, eax_2194);
		Eq_4 eax_2248 = unicode.Armenian;
		word32 edi_14520;
		word32 esi_14519;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_14519, out edi_14520);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_2248;
		else
			runtime.writebarrierptr(0x00, eax_2248);
		Eq_4 eax_2302 = unicode.Avestan;
		word32 edi_14518;
		word32 esi_14517;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_14517, out edi_14518);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_2302;
		else
			runtime.writebarrierptr(0x00, eax_2302);
		Eq_4 eax_2356 = unicode.Balinese;
		word32 edi_14516;
		word32 esi_14515;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_14515, out edi_14516);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_2356;
		else
			runtime.writebarrierptr(0x00, eax_2356);
		Eq_4 eax_2410 = unicode.Bamum;
		word32 edi_14514;
		word32 esi_14513;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_14513, out edi_14514);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_2410;
		else
			runtime.writebarrierptr(0x00, eax_2410);
		Eq_4 eax_2464 = unicode.Bassa_Vah;
		word32 edi_14512;
		word32 esi_14511;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_14511, out edi_14512);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_2464;
		else
			runtime.writebarrierptr(0x00, eax_2464);
		Eq_4 eax_2518 = unicode.Batak;
		word32 edi_14510;
		word32 esi_14509;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_14509, out edi_14510);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_2518;
		else
			runtime.writebarrierptr(0x00, eax_2518);
		Eq_4 eax_2572 = unicode.Bengali;
		word32 edi_14508;
		word32 esi_14507;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_14507, out edi_14508);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_2572;
		else
			runtime.writebarrierptr(0x00, eax_2572);
		Eq_4 eax_2626 = unicode.Bhaiksuki;
		word32 edi_14506;
		word32 esi_14505;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_14505, out edi_14506);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_2626;
		else
			runtime.writebarrierptr(0x00, eax_2626);
		Eq_4 eax_2680 = unicode.Bopomofo;
		word32 edi_14504;
		word32 esi_14503;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_14503, out edi_14504);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_2680;
		else
			runtime.writebarrierptr(0x00, eax_2680);
		Eq_4 eax_2734 = unicode.Brahmi;
		word32 edi_14502;
		word32 esi_14501;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_14501, out edi_14502);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_2734;
		else
			runtime.writebarrierptr(0x00, eax_2734);
		Eq_4 eax_2788 = unicode.Braille;
		word32 edi_14500;
		word32 esi_14499;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_14499, out edi_14500);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_2788;
		else
			runtime.writebarrierptr(0x00, eax_2788);
		Eq_4 eax_2842 = unicode.Buginese;
		word32 edi_14498;
		word32 esi_14497;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_14497, out edi_14498);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_2842;
		else
			runtime.writebarrierptr(0x00, eax_2842);
		Eq_4 eax_2896 = unicode.Buhid;
		word32 edi_14496;
		word32 esi_14495;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_14495, out edi_14496);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_2896;
		else
			runtime.writebarrierptr(0x00, eax_2896);
		Eq_4 eax_2950 = unicode.Canadian_Aboriginal;
		word32 edi_14494;
		word32 esi_14493;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_14493, out edi_14494);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_2950;
		else
			runtime.writebarrierptr(0x00, eax_2950);
		Eq_4 eax_3004 = unicode.Carian;
		word32 edi_14492;
		word32 esi_14491;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_14491, out edi_14492);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_3004;
		else
			runtime.writebarrierptr(0x00, eax_3004);
		Eq_4 eax_3058 = unicode.Caucasian_Albanian;
		word32 edi_14490;
		word32 esi_14489;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_14489, out edi_14490);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_3058;
		else
			runtime.writebarrierptr(0x00, eax_3058);
		Eq_4 eax_3112 = unicode.Chakma;
		word32 edi_14488;
		word32 esi_14487;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_14487, out edi_14488);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_3112;
		else
			runtime.writebarrierptr(0x00, eax_3112);
		Eq_4 eax_3166 = unicode.Cham;
		word32 edi_14486;
		word32 esi_14485;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_14485, out edi_14486);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_3166;
		else
			runtime.writebarrierptr(0x00, eax_3166);
		Eq_4 eax_3220 = unicode.Cherokee;
		word32 edi_14484;
		word32 esi_14483;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_14483, out edi_14484);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_3220;
		else
			runtime.writebarrierptr(0x00, eax_3220);
		Eq_4 eax_3274 = unicode.Common;
		word32 edi_14482;
		word32 esi_14481;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_14481, out edi_14482);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_3274;
		else
			runtime.writebarrierptr(0x00, eax_3274);
		Eq_4 eax_3328 = unicode.Coptic;
		word32 edi_14480;
		word32 esi_14479;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_14479, out edi_14480);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_3328;
		else
			runtime.writebarrierptr(0x00, eax_3328);
		Eq_4 eax_3382 = unicode.Cuneiform;
		word32 edi_14478;
		word32 esi_14477;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_14477, out edi_14478);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_3382;
		else
			runtime.writebarrierptr(0x00, eax_3382);
		Eq_4 eax_3436 = unicode.Cypriot;
		word32 edi_14476;
		word32 esi_14475;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_14475, out edi_14476);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_3436;
		else
			runtime.writebarrierptr(0x00, eax_3436);
		Eq_4 eax_3490 = unicode.Cyrillic;
		word32 edi_14474;
		word32 esi_14473;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_14473, out edi_14474);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_3490;
		else
			runtime.writebarrierptr(0x00, eax_3490);
		Eq_4 eax_3544 = unicode.Deseret;
		word32 edi_14173;
		word32 esi_14172;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_14172, out edi_14173);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_3544;
		else
			runtime.writebarrierptr(0x00, eax_3544);
		Eq_4 eax_3598 = unicode.Devanagari;
		word32 edi_14472;
		word32 esi_14471;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_14471, out edi_14472);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_3598;
		else
			runtime.writebarrierptr(0x00, eax_3598);
		Eq_4 eax_3652 = unicode.Duployan;
		word32 edi_14470;
		word32 esi_14469;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_14469, out edi_14470);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_3652;
		else
			runtime.writebarrierptr(0x00, eax_3652);
		Eq_4 eax_3706 = unicode.Egyptian_Hieroglyphs;
		word32 edi_14468;
		word32 esi_14467;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_14467, out edi_14468);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_3706;
		else
			runtime.writebarrierptr(0x00, eax_3706);
		Eq_4 eax_3760 = unicode.Elbasan;
		word32 edi_14466;
		word32 esi_14465;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_14465, out edi_14466);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_3760;
		else
			runtime.writebarrierptr(0x00, eax_3760);
		Eq_4 eax_3814 = unicode.Ethiopic;
		word32 edi_14464;
		word32 esi_14463;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_14463, out edi_14464);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_3814;
		else
			runtime.writebarrierptr(0x00, eax_3814);
		Eq_4 eax_3868 = unicode.Georgian;
		word32 edi_14462;
		word32 esi_14461;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_14461, out edi_14462);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_3868;
		else
			runtime.writebarrierptr(0x00, eax_3868);
		Eq_4 eax_3922 = unicode.Glagolitic;
		word32 edi_14460;
		word32 esi_14459;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_14459, out edi_14460);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_3922;
		else
			runtime.writebarrierptr(0x00, eax_3922);
		Eq_4 eax_3976 = unicode.Gothic;
		word32 edi_14458;
		word32 esi_14457;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_14457, out edi_14458);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_3976;
		else
			runtime.writebarrierptr(0x00, eax_3976);
		Eq_4 eax_4030 = unicode.Grantha;
		word32 edi_14456;
		word32 esi_14455;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_14455, out edi_14456);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_4030;
		else
			runtime.writebarrierptr(0x00, eax_4030);
		Eq_4 eax_4084 = unicode.Greek;
		word32 edi_14454;
		word32 esi_14453;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_14453, out edi_14454);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_4084;
		else
			runtime.writebarrierptr(0x00, eax_4084);
		Eq_4 eax_4138 = unicode.Gujarati;
		word32 edi_14452;
		word32 esi_14451;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_14451, out edi_14452);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_4138;
		else
			runtime.writebarrierptr(0x00, eax_4138);
		Eq_4 eax_4192 = unicode.Gurmukhi;
		word32 edi_14450;
		word32 esi_14449;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_14449, out edi_14450);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_4192;
		else
			runtime.writebarrierptr(0x00, eax_4192);
		Eq_4 eax_4246 = unicode.Han;
		word32 edi_14448;
		word32 esi_14447;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_14447, out edi_14448);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_4246;
		else
			runtime.writebarrierptr(0x00, eax_4246);
		Eq_4 eax_4300 = unicode.Hangul;
		word32 edi_14446;
		word32 esi_14445;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_14445, out edi_14446);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_4300;
		else
			runtime.writebarrierptr(0x00, eax_4300);
		Eq_4 eax_4354 = unicode.Hanunoo;
		word32 edi_14444;
		word32 esi_14443;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_14443, out edi_14444);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_4354;
		else
			runtime.writebarrierptr(0x00, eax_4354);
		Eq_4 eax_4408 = unicode.Hatran;
		word32 edi_14442;
		word32 esi_14441;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_14441, out edi_14442);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_4408;
		else
			runtime.writebarrierptr(0x00, eax_4408);
		Eq_4 eax_4462 = unicode.Hebrew;
		word32 edi_14440;
		word32 esi_14439;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_14439, out edi_14440);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_4462;
		else
			runtime.writebarrierptr(0x00, eax_4462);
		Eq_4 eax_4516 = unicode.Hiragana;
		word32 edi_14438;
		word32 esi_14437;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_14437, out edi_14438);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_4516;
		else
			runtime.writebarrierptr(0x00, eax_4516);
		Eq_4 eax_4570 = unicode.Imperial_Aramaic;
		word32 edi_14436;
		word32 esi_14435;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_14435, out edi_14436);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_4570;
		else
			runtime.writebarrierptr(0x00, eax_4570);
		Eq_4 eax_4624 = unicode.Inherited;
		word32 edi_14434;
		word32 esi_14433;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_14433, out edi_14434);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_4624;
		else
			runtime.writebarrierptr(0x00, eax_4624);
		Eq_4 eax_4678 = unicode.Inscriptional_Pahlavi;
		word32 edi_14432;
		word32 esi_14431;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_14431, out edi_14432);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_4678;
		else
			runtime.writebarrierptr(0x00, eax_4678);
		Eq_4 eax_4732 = unicode.Inscriptional_Parthian;
		word32 edi_14430;
		word32 esi_14429;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_14429, out edi_14430);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_4732;
		else
			runtime.writebarrierptr(0x00, eax_4732);
		Eq_4 eax_4786 = unicode.Javanese;
		word32 edi_14428;
		word32 esi_14427;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_14427, out edi_14428);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_4786;
		else
			runtime.writebarrierptr(0x00, eax_4786);
		Eq_4 eax_4840 = unicode.Kaithi;
		word32 edi_14426;
		word32 esi_14425;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_14425, out edi_14426);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_4840;
		else
			runtime.writebarrierptr(0x00, eax_4840);
		Eq_4 eax_4894 = unicode.Kannada;
		word32 edi_14424;
		word32 esi_14423;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_14423, out edi_14424);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_4894;
		else
			runtime.writebarrierptr(0x00, eax_4894);
		Eq_4 eax_4948 = unicode.Katakana;
		word32 edi_14422;
		word32 esi_14421;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_14421, out edi_14422);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_4948;
		else
			runtime.writebarrierptr(0x00, eax_4948);
		Eq_4 eax_5002 = unicode.Kayah_Li;
		word32 edi_14420;
		word32 esi_14419;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_14419, out edi_14420);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_5002;
		else
			runtime.writebarrierptr(0x00, eax_5002);
		Eq_4 eax_5056 = unicode.Kharoshthi;
		word32 edi_14418;
		word32 esi_14417;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_14417, out edi_14418);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_5056;
		else
			runtime.writebarrierptr(0x00, eax_5056);
		Eq_4 eax_5110 = unicode.Khmer;
		word32 edi_14416;
		word32 esi_14415;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_14415, out edi_14416);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_5110;
		else
			runtime.writebarrierptr(0x00, eax_5110);
		Eq_4 eax_5164 = unicode.Khojki;
		word32 edi_14414;
		word32 esi_14413;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_14413, out edi_14414);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_5164;
		else
			runtime.writebarrierptr(0x00, eax_5164);
		Eq_4 eax_5218 = unicode.Khudawadi;
		word32 edi_14412;
		word32 esi_14411;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_14411, out edi_14412);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_5218;
		else
			runtime.writebarrierptr(0x00, eax_5218);
		Eq_4 eax_5272 = unicode.Lao;
		word32 edi_14410;
		word32 esi_14409;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_14409, out edi_14410);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_5272;
		else
			runtime.writebarrierptr(0x00, eax_5272);
		Eq_4 eax_5326 = unicode.Latin;
		word32 edi_14408;
		word32 esi_14407;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_14407, out edi_14408);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_5326;
		else
			runtime.writebarrierptr(0x00, eax_5326);
		Eq_4 eax_5380 = unicode.Lepcha;
		word32 edi_14406;
		word32 esi_14405;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_14405, out edi_14406);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_5380;
		else
			runtime.writebarrierptr(0x00, eax_5380);
		Eq_4 eax_5434 = unicode.Limbu;
		word32 edi_14404;
		word32 esi_14403;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_14403, out edi_14404);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_5434;
		else
			runtime.writebarrierptr(0x00, eax_5434);
		Eq_4 eax_5488 = unicode.Linear_A;
		word32 edi_14402;
		word32 esi_14401;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_14401, out edi_14402);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_5488;
		else
			runtime.writebarrierptr(0x00, eax_5488);
		Eq_4 eax_5542 = unicode.Linear_B;
		word32 edi_14400;
		word32 esi_14399;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_14399, out edi_14400);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_5542;
		else
			runtime.writebarrierptr(0x00, eax_5542);
		Eq_4 eax_5596 = unicode.Lisu;
		word32 edi_14398;
		word32 esi_14397;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_14397, out edi_14398);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_5596;
		else
			runtime.writebarrierptr(0x00, eax_5596);
		Eq_4 eax_5650 = unicode.Lycian;
		word32 edi_14396;
		word32 esi_14395;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_14395, out edi_14396);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_5650;
		else
			runtime.writebarrierptr(0x00, eax_5650);
		Eq_4 eax_5704 = unicode.Lydian;
		word32 edi_14394;
		word32 esi_14393;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_14393, out edi_14394);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_5704;
		else
			runtime.writebarrierptr(0x00, eax_5704);
		Eq_4 eax_5758 = unicode.Mahajani;
		word32 edi_14392;
		word32 esi_14391;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_14391, out edi_14392);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_5758;
		else
			runtime.writebarrierptr(0x00, eax_5758);
		Eq_4 eax_5812 = unicode.Malayalam;
		word32 edi_14390;
		word32 esi_14389;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_14389, out edi_14390);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_5812;
		else
			runtime.writebarrierptr(0x00, eax_5812);
		Eq_4 eax_5866 = unicode.Mandaic;
		word32 edi_14388;
		word32 esi_14387;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_14387, out edi_14388);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_5866;
		else
			runtime.writebarrierptr(0x00, eax_5866);
		Eq_4 eax_5920 = unicode.Manichaean;
		word32 edi_14386;
		word32 esi_14385;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_14385, out edi_14386);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_5920;
		else
			runtime.writebarrierptr(0x00, eax_5920);
		Eq_4 eax_5974 = unicode.Marchen;
		word32 edi_14384;
		word32 esi_14383;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_14383, out edi_14384);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_5974;
		else
			runtime.writebarrierptr(0x00, eax_5974);
		Eq_4 eax_6028 = unicode.Meetei_Mayek;
		word32 edi_14382;
		word32 esi_14381;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_14381, out edi_14382);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_6028;
		else
			runtime.writebarrierptr(0x00, eax_6028);
		Eq_4 eax_6082 = unicode.Mende_Kikakui;
		word32 edi_14380;
		word32 esi_14379;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_14379, out edi_14380);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_6082;
		else
			runtime.writebarrierptr(0x00, eax_6082);
		Eq_4 eax_6136 = unicode.Meroitic_Cursive;
		word32 edi_14378;
		word32 esi_14377;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_14377, out edi_14378);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_6136;
		else
			runtime.writebarrierptr(0x00, eax_6136);
		Eq_4 eax_6190 = unicode.Meroitic_Hieroglyphs;
		word32 edi_14376;
		word32 esi_14375;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_14375, out edi_14376);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_6190;
		else
			runtime.writebarrierptr(0x00, eax_6190);
		Eq_4 eax_6244 = unicode.Miao;
		word32 edi_14374;
		word32 esi_14373;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_14373, out edi_14374);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_6244;
		else
			runtime.writebarrierptr(0x00, eax_6244);
		Eq_4 eax_6298 = unicode.Modi;
		word32 edi_14372;
		word32 esi_14371;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_14371, out edi_14372);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_6298;
		else
			runtime.writebarrierptr(0x00, eax_6298);
		Eq_4 eax_6352 = unicode.Mongolian;
		word32 edi_14370;
		word32 esi_14369;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_14369, out edi_14370);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_6352;
		else
			runtime.writebarrierptr(0x00, eax_6352);
		Eq_4 eax_6406 = unicode.Mro;
		word32 edi_14368;
		word32 esi_14367;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_14367, out edi_14368);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_6406;
		else
			runtime.writebarrierptr(0x00, eax_6406);
		Eq_4 eax_6460 = unicode.Multani;
		word32 edi_14366;
		word32 esi_14365;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_14365, out edi_14366);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_6460;
		else
			runtime.writebarrierptr(0x00, eax_6460);
		Eq_4 eax_6514 = unicode.Myanmar;
		word32 edi_14364;
		word32 esi_14363;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_14363, out edi_14364);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_6514;
		else
			runtime.writebarrierptr(0x00, eax_6514);
		Eq_4 eax_6568 = unicode.Nabataean;
		word32 esi_14361;
		word32 edi_14362;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_14361, out edi_14362);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_6568;
		else
			runtime.writebarrierptr(0x00, eax_6568);
		Eq_4 eax_6622 = unicode.New_Tai_Lue;
		word32 esi_14359;
		word32 edi_14360;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_14359, out edi_14360);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_6622;
		else
			runtime.writebarrierptr(0x00, eax_6622);
		Eq_4 eax_6676 = unicode.Newa;
		word32 esi_14357;
		word32 edi_14358;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_14357, out edi_14358);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_6676;
		else
			runtime.writebarrierptr(0x00, eax_6676);
		Eq_4 eax_6730 = unicode.Nko;
		word32 esi_14355;
		word32 edi_14356;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_14355, out edi_14356);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_6730;
		else
			runtime.writebarrierptr(0x00, eax_6730);
		Eq_4 eax_6784 = unicode.Ogham;
		word32 esi_14353;
		word32 edi_14354;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_14353, out edi_14354);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_6784;
		else
			runtime.writebarrierptr(0x00, eax_6784);
		Eq_4 eax_6838 = unicode.Ol_Chiki;
		word32 esi_14351;
		word32 edi_14352;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_14351, out edi_14352);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_6838;
		else
			runtime.writebarrierptr(0x00, eax_6838);
		Eq_4 eax_6892 = unicode.Old_Hungarian;
		word32 esi_14349;
		word32 edi_14350;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_14349, out edi_14350);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_6892;
		else
			runtime.writebarrierptr(0x00, eax_6892);
		Eq_4 eax_6946 = unicode.Old_Italic;
		word32 esi_14347;
		word32 edi_14348;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_14347, out edi_14348);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_6946;
		else
			runtime.writebarrierptr(0x00, eax_6946);
		Eq_4 eax_7000 = unicode.Old_North_Arabian;
		word32 edi_14175;
		word32 esi_14174;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_14174, out edi_14175);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_7000;
		else
			runtime.writebarrierptr(0x00, eax_7000);
		Eq_4 eax_7054 = unicode.Old_Permic;
		word32 esi_14345;
		word32 edi_14346;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_14345, out edi_14346);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_7054;
		else
			runtime.writebarrierptr(0x00, eax_7054);
		Eq_4 eax_7108 = unicode.Old_Persian;
		word32 esi_14343;
		word32 edi_14344;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_14343, out edi_14344);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_7108;
		else
			runtime.writebarrierptr(0x00, eax_7108);
		Eq_4 eax_7162 = unicode.Old_South_Arabian;
		word32 esi_14341;
		word32 edi_14342;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_14341, out edi_14342);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_7162;
		else
			runtime.writebarrierptr(0x00, eax_7162);
		Eq_4 eax_7216 = unicode.Old_Turkic;
		word32 esi_14339;
		word32 edi_14340;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_14339, out edi_14340);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_7216;
		else
			runtime.writebarrierptr(0x00, eax_7216);
		Eq_4 eax_7270 = unicode.Oriya;
		word32 esi_14337;
		word32 edi_14338;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_14337, out edi_14338);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_7270;
		else
			runtime.writebarrierptr(0x00, eax_7270);
		Eq_4 eax_7324 = unicode.Osage;
		word32 esi_14335;
		word32 edi_14336;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_14335, out edi_14336);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_7324;
		else
			runtime.writebarrierptr(0x00, eax_7324);
		Eq_4 eax_7378 = unicode.Osmanya;
		word32 esi_14333;
		word32 edi_14334;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_14333, out edi_14334);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_7378;
		else
			runtime.writebarrierptr(0x00, eax_7378);
		Eq_4 eax_7432 = unicode.Pahawh_Hmong;
		word32 esi_14331;
		word32 edi_14332;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_14331, out edi_14332);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_7432;
		else
			runtime.writebarrierptr(0x00, eax_7432);
		Eq_4 eax_7486 = unicode.Palmyrene;
		word32 esi_14329;
		word32 edi_14330;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_14329, out edi_14330);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_7486;
		else
			runtime.writebarrierptr(0x00, eax_7486);
		Eq_4 eax_7540 = unicode.Pau_Cin_Hau;
		word32 esi_14327;
		word32 edi_14328;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_14327, out edi_14328);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_7540;
		else
			runtime.writebarrierptr(0x00, eax_7540);
		Eq_4 eax_7594 = unicode.Phags_Pa;
		word32 esi_14325;
		word32 edi_14326;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_14325, out edi_14326);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_7594;
		else
			runtime.writebarrierptr(0x00, eax_7594);
		Eq_4 eax_7648 = unicode.Phoenician;
		word32 esi_14323;
		word32 edi_14324;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_14323, out edi_14324);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_7648;
		else
			runtime.writebarrierptr(0x00, eax_7648);
		Eq_4 eax_7702 = unicode.Psalter_Pahlavi;
		word32 esi_14321;
		word32 edi_14322;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_14321, out edi_14322);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_7702;
		else
			runtime.writebarrierptr(0x00, eax_7702);
		Eq_4 eax_7756 = unicode.Rejang;
		word32 esi_14319;
		word32 edi_14320;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_14319, out edi_14320);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_7756;
		else
			runtime.writebarrierptr(0x00, eax_7756);
		Eq_4 eax_7810 = unicode.Runic;
		word32 esi_14317;
		word32 edi_14318;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_14317, out edi_14318);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_7810;
		else
			runtime.writebarrierptr(0x00, eax_7810);
		Eq_4 eax_7864 = unicode.Samaritan;
		word32 esi_14315;
		word32 edi_14316;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_14315, out edi_14316);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_7864;
		else
			runtime.writebarrierptr(0x00, eax_7864);
		Eq_4 eax_7918 = unicode.Saurashtra;
		word32 esi_14313;
		word32 edi_14314;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_14313, out edi_14314);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_7918;
		else
			runtime.writebarrierptr(0x00, eax_7918);
		Eq_4 eax_7972 = unicode.Sharada;
		word32 esi_14311;
		word32 edi_14312;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_14311, out edi_14312);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_7972;
		else
			runtime.writebarrierptr(0x00, eax_7972);
		Eq_4 eax_8026 = unicode.Shavian;
		word32 esi_14309;
		word32 edi_14310;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_14309, out edi_14310);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_8026;
		else
			runtime.writebarrierptr(0x00, eax_8026);
		Eq_4 eax_8080 = unicode.Siddham;
		word32 esi_14307;
		word32 edi_14308;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_14307, out edi_14308);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_8080;
		else
			runtime.writebarrierptr(0x00, eax_8080);
		Eq_4 eax_8134 = unicode.SignWriting;
		word32 esi_14305;
		word32 edi_14306;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_14305, out edi_14306);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_8134;
		else
			runtime.writebarrierptr(0x00, eax_8134);
		Eq_4 eax_8188 = unicode.Sinhala;
		word32 esi_14303;
		word32 edi_14304;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_14303, out edi_14304);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_8188;
		else
			runtime.writebarrierptr(0x00, eax_8188);
		Eq_4 eax_8242 = unicode.Sora_Sompeng;
		word32 esi_14301;
		word32 edi_14302;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_14301, out edi_14302);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_8242;
		else
			runtime.writebarrierptr(0x00, eax_8242);
		Eq_4 eax_8296 = unicode.Sundanese;
		word32 esi_14299;
		word32 edi_14300;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_14299, out edi_14300);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_8296;
		else
			runtime.writebarrierptr(0x00, eax_8296);
		Eq_4 eax_8350 = unicode.Syloti_Nagri;
		word32 esi_14297;
		word32 edi_14298;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_14297, out edi_14298);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_8350;
		else
			runtime.writebarrierptr(0x00, eax_8350);
		Eq_4 eax_8404 = unicode.Syriac;
		word32 esi_14295;
		word32 edi_14296;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_14295, out edi_14296);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_8404;
		else
			runtime.writebarrierptr(0x00, eax_8404);
		Eq_4 eax_8458 = unicode.Tagalog;
		word32 esi_14293;
		word32 edi_14294;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_14293, out edi_14294);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_8458;
		else
			runtime.writebarrierptr(0x00, eax_8458);
		Eq_4 eax_8512 = unicode.Tagbanwa;
		word32 esi_14291;
		word32 edi_14292;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_14291, out edi_14292);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_8512;
		else
			runtime.writebarrierptr(0x00, eax_8512);
		Eq_4 eax_8566 = unicode.Tai_Le;
		word32 esi_14289;
		word32 edi_14290;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_14289, out edi_14290);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_8566;
		else
			runtime.writebarrierptr(0x00, eax_8566);
		Eq_4 eax_8620 = unicode.Tai_Tham;
		word32 esi_14287;
		word32 edi_14288;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_14287, out edi_14288);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_8620;
		else
			runtime.writebarrierptr(0x00, eax_8620);
		Eq_4 eax_8674 = unicode.Tai_Viet;
		word32 esi_14285;
		word32 edi_14286;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_14285, out edi_14286);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_8674;
		else
			runtime.writebarrierptr(0x00, eax_8674);
		Eq_4 eax_8728 = unicode.Takri;
		word32 esi_14283;
		word32 edi_14284;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_14283, out edi_14284);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_8728;
		else
			runtime.writebarrierptr(0x00, eax_8728);
		Eq_4 eax_8782 = unicode.Tamil;
		word32 esi_14281;
		word32 edi_14282;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_14281, out edi_14282);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_8782;
		else
			runtime.writebarrierptr(0x00, eax_8782);
		Eq_4 eax_8836 = unicode.Tangut;
		word32 esi_14279;
		word32 edi_14280;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_14279, out edi_14280);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_8836;
		else
			runtime.writebarrierptr(0x00, eax_8836);
		Eq_4 eax_8890 = unicode.Telugu;
		word32 esi_14277;
		word32 edi_14278;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_14277, out edi_14278);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_8890;
		else
			runtime.writebarrierptr(0x00, eax_8890);
		Eq_4 eax_8944 = unicode.Thaana;
		word32 esi_14275;
		word32 edi_14276;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_14275, out edi_14276);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_8944;
		else
			runtime.writebarrierptr(0x00, eax_8944);
		Eq_4 eax_8998 = unicode.Thai;
		word32 esi_14273;
		word32 edi_14274;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_14273, out edi_14274);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_8998;
		else
			runtime.writebarrierptr(0x00, eax_8998);
		Eq_4 eax_9052 = unicode.Tibetan;
		word32 esi_14271;
		word32 edi_14272;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_14271, out edi_14272);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_9052;
		else
			runtime.writebarrierptr(0x00, eax_9052);
		Eq_4 eax_9106 = unicode.Tifinagh;
		word32 esi_14269;
		word32 edi_14270;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_14269, out edi_14270);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_9106;
		else
			runtime.writebarrierptr(0x00, eax_9106);
		Eq_4 eax_9160 = unicode.Tirhuta;
		word32 esi_14267;
		word32 edi_14268;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_14267, out edi_14268);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_9160;
		else
			runtime.writebarrierptr(0x00, eax_9160);
		Eq_4 eax_9214 = unicode.Ugaritic;
		word32 esi_14265;
		word32 edi_14266;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_14265, out edi_14266);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_9214;
		else
			runtime.writebarrierptr(0x00, eax_9214);
		Eq_4 eax_9268 = unicode.Vai;
		word32 esi_14263;
		word32 edi_14264;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_14263, out edi_14264);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_9268;
		else
			runtime.writebarrierptr(0x00, eax_9268);
		Eq_4 eax_9322 = unicode.Warang_Citi;
		word32 esi_14261;
		word32 edi_14262;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_14261, out edi_14262);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_9322;
		else
			runtime.writebarrierptr(0x00, eax_9322);
		Eq_4 eax_9376 = unicode.Yi;
		Eq_4 edi_9391;
		Eq_4 esi_9393;
		word24 ebx_24_8_9451 = SLICE(runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_9393, out edi_9391), word24, 8);
		if (g_t81576F0 == 0x00)
		{
			null = (union Eq_4 *) eax_9376;
			unicode.Scripts = dwLoc1C;
		}
		else
		{
			runtime.writebarrierptr(0x00, eax_9376);
			runtime.writebarrierptr(0x08145000, dwLoc1C);
		}
		word32 edi_14258;
		runtime.makemap(ebx_24_8_9451, esi_9393, edi_9391, gs, 0x080CFB40, 0x22, 0x00, 0x00, 0x00, out edi_14258);
		Eq_4 ecx_9472 = unicode.ASCII_Hex_Digit;
		word32 esi_14259;
		word32 edi_14260;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_14259, out edi_14260);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) ecx_9472;
		else
			runtime.writebarrierptr(0x00, ecx_9472);
		Eq_4 eax_9523 = unicode.Bidi_Control;
		word32 esi_14256;
		word32 edi_14257;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_14256, out edi_14257);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_9523;
		else
			runtime.writebarrierptr(0x00, eax_9523);
		Eq_4 eax_9577 = unicode.Dash;
		word32 esi_14254;
		word32 edi_14255;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_14254, out edi_14255);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_9577;
		else
			runtime.writebarrierptr(0x00, eax_9577);
		Eq_4 eax_9631 = unicode.Deprecated;
		word32 esi_14252;
		word32 edi_14253;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_14252, out edi_14253);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_9631;
		else
			runtime.writebarrierptr(0x00, eax_9631);
		Eq_4 eax_9685 = unicode.Diacritic;
		word32 esi_14250;
		word32 edi_14251;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_14250, out edi_14251);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_9685;
		else
			runtime.writebarrierptr(0x00, eax_9685);
		Eq_4 eax_9739 = unicode.Extender;
		word32 esi_14248;
		word32 edi_14249;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_14248, out edi_14249);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_9739;
		else
			runtime.writebarrierptr(0x00, eax_9739);
		Eq_4 eax_9793 = unicode.Hex_Digit;
		word32 esi_14246;
		word32 edi_14247;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_14246, out edi_14247);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_9793;
		else
			runtime.writebarrierptr(0x00, eax_9793);
		Eq_4 eax_9847 = unicode.Hyphen;
		word32 esi_14244;
		word32 edi_14245;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_14244, out edi_14245);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_9847;
		else
			runtime.writebarrierptr(0x00, eax_9847);
		Eq_4 eax_9901 = unicode.IDS_Binary_Operator;
		word32 esi_14242;
		word32 edi_14243;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_14242, out edi_14243);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_9901;
		else
			runtime.writebarrierptr(0x00, eax_9901);
		Eq_4 eax_9955 = unicode.IDS_Trinary_Operator;
		word32 esi_14240;
		word32 edi_14241;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_14240, out edi_14241);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_9955;
		else
			runtime.writebarrierptr(0x00, eax_9955);
		Eq_4 eax_10009 = unicode.Ideographic;
		word32 esi_14238;
		word32 edi_14239;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_14238, out edi_14239);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_10009;
		else
			runtime.writebarrierptr(0x00, eax_10009);
		Eq_4 eax_10063 = unicode.Join_Control;
		word32 esi_14236;
		word32 edi_14237;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_14236, out edi_14237);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_10063;
		else
			runtime.writebarrierptr(0x00, eax_10063);
		Eq_4 eax_10117 = unicode.Logical_Order_Exception;
		word32 esi_14234;
		word32 edi_14235;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_14234, out edi_14235);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_10117;
		else
			runtime.writebarrierptr(0x00, eax_10117);
		Eq_4 eax_10171 = unicode.Noncharacter_Code_Point;
		word32 esi_14232;
		word32 edi_14233;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_14232, out edi_14233);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_10171;
		else
			runtime.writebarrierptr(0x00, eax_10171);
		Eq_4 eax_10225 = unicode.Other_Alphabetic;
		word32 esi_14230;
		word32 edi_14231;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_14230, out edi_14231);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_10225;
		else
			runtime.writebarrierptr(0x00, eax_10225);
		Eq_4 eax_10279 = unicode.Other_Default_Ignorable_Code_Point;
		word32 esi_14228;
		word32 edi_14229;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_14228, out edi_14229);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_10279;
		else
			runtime.writebarrierptr(0x00, eax_10279);
		Eq_4 eax_10333 = unicode.Other_Grapheme_Extend;
		word32 esi_14226;
		word32 edi_14227;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_14226, out edi_14227);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_10333;
		else
			runtime.writebarrierptr(0x00, eax_10333);
		Eq_4 eax_10387 = unicode.Other_ID_Continue;
		word32 edi_14225;
		word32 esi_14224;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_14224, out edi_14225);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_10387;
		else
			runtime.writebarrierptr(0x00, eax_10387);
		Eq_4 eax_10441 = unicode.Other_ID_Start;
		word32 edi_14223;
		word32 esi_14222;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_14222, out edi_14223);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_10441;
		else
			runtime.writebarrierptr(0x00, eax_10441);
		Eq_4 eax_10495 = unicode.Other_Lowercase;
		word32 edi_14221;
		word32 esi_14220;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_14220, out edi_14221);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_10495;
		else
			runtime.writebarrierptr(0x00, eax_10495);
		Eq_4 eax_10549 = unicode.Other_Math;
		word32 edi_14219;
		word32 esi_14218;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_14218, out edi_14219);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_10549;
		else
			runtime.writebarrierptr(0x00, eax_10549);
		Eq_4 eax_10603 = unicode.Other_Uppercase;
		word32 edi_14217;
		word32 esi_14216;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_14216, out edi_14217);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_10603;
		else
			runtime.writebarrierptr(0x00, eax_10603);
		Eq_4 eax_10657 = unicode.Pattern_Syntax;
		word32 edi_14215;
		word32 esi_14214;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_14214, out edi_14215);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_10657;
		else
			runtime.writebarrierptr(0x00, eax_10657);
		Eq_4 eax_10711 = unicode.Pattern_White_Space;
		word32 edi_14213;
		word32 esi_14212;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_14212, out edi_14213);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_10711;
		else
			runtime.writebarrierptr(0x00, eax_10711);
		Eq_4 eax_10765 = unicode.Prepended_Concatenation_Mark;
		word32 edi_14211;
		word32 esi_14210;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_14210, out edi_14211);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_10765;
		else
			runtime.writebarrierptr(0x00, eax_10765);
		Eq_4 eax_10819 = unicode.Quotation_Mark;
		word32 edi_14209;
		word32 esi_14208;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_14208, out edi_14209);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_10819;
		else
			runtime.writebarrierptr(0x00, eax_10819);
		Eq_4 eax_10873 = unicode.Radical;
		word32 edi_14207;
		word32 esi_14206;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_14206, out edi_14207);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_10873;
		else
			runtime.writebarrierptr(0x00, eax_10873);
		Eq_4 eax_10927 = unicode.Sentence_Terminal;
		word32 edi_14205;
		word32 esi_14204;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_14204, out edi_14205);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_10927;
		else
			runtime.writebarrierptr(0x00, eax_10927);
		Eq_4 eax_10981 = unicode.Sentence_Terminal;
		word32 edi_14203;
		word32 esi_14202;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_14202, out edi_14203);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_10981;
		else
			runtime.writebarrierptr(0x00, eax_10981);
		Eq_4 eax_11035 = unicode.Soft_Dotted;
		word32 edi_14201;
		word32 esi_14200;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_14200, out edi_14201);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_11035;
		else
			runtime.writebarrierptr(0x00, eax_11035);
		Eq_4 eax_11089 = unicode.Terminal_Punctuation;
		word32 edi_14199;
		word32 esi_14198;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_14198, out edi_14199);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_11089;
		else
			runtime.writebarrierptr(0x00, eax_11089);
		Eq_4 eax_11143 = unicode.Unified_Ideograph;
		word32 edi_14197;
		word32 esi_14196;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_14196, out edi_14197);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_11143;
		else
			runtime.writebarrierptr(0x00, eax_11143);
		Eq_4 eax_11197 = unicode.Variation_Selector;
		word32 edi_14195;
		word32 esi_14194;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_14194, out edi_14195);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_11197;
		else
			runtime.writebarrierptr(0x00, eax_11197);
		Eq_4 eax_11251 = unicode.White_Space;
		Eq_4 edi_11266;
		Eq_4 esi_11268;
		word24 ebx_24_8_11326 = SLICE(runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_11268, out edi_11266), word24, 8);
		if (g_t81576F0 == 0x00)
		{
			null = (union Eq_4 *) eax_11251;
			unicode.Properties = dwLoc1C;
		}
		else
		{
			runtime.writebarrierptr(0x00, eax_11251);
			runtime.writebarrierptr(0x08144FFC, dwLoc1C);
		}
		word32 edi_14191;
		runtime.makemap(ebx_24_8_11326, esi_11268, edi_11266, gs, 0x080CFB40, 0x06, 0x00, 0x00, 0x00, out edi_14191);
		Eq_4 ecx_11347 = unicode.foldL;
		word32 edi_14193;
		word32 esi_14192;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_14192, out edi_14193);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) ecx_11347;
		else
			runtime.writebarrierptr(0x00, ecx_11347);
		Eq_4 eax_11398 = unicode.foldLl;
		word32 edi_14190;
		word32 esi_14189;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_14189, out edi_14190);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_11398;
		else
			runtime.writebarrierptr(0x00, eax_11398);
		Eq_4 eax_11452 = unicode.foldLt;
		word32 edi_14188;
		word32 esi_14187;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_14187, out edi_14188);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_11452;
		else
			runtime.writebarrierptr(0x00, eax_11452);
		Eq_4 eax_11506 = unicode.foldLu;
		word32 edi_14186;
		word32 esi_14185;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_14185, out edi_14186);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_11506;
		else
			runtime.writebarrierptr(0x00, eax_11506);
		Eq_4 eax_11560 = unicode.foldM;
		word32 edi_14184;
		word32 esi_14183;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_14183, out edi_14184);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_11560;
		else
			runtime.writebarrierptr(0x00, eax_11560);
		Eq_4 eax_11614 = unicode.foldMn;
		Eq_4 edi_11629;
		Eq_4 esi_11631;
		word24 ebx_24_8_11689 = SLICE(runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_11631, out edi_11629), word24, 8);
		if (g_t81576F0 == 0x00)
		{
			null = (union Eq_4 *) eax_11614;
			unicode.FoldCategory = dwLoc1C;
		}
		else
		{
			runtime.writebarrierptr(0x00, eax_11614);
			runtime.writebarrierptr(0x08144FF4, dwLoc1C);
		}
		word32 edi_14180;
		runtime.makemap(ebx_24_8_11689, esi_11631, edi_11629, gs, 0x080CFB40, 0x03, 0x00, 0x00, 0x00, out edi_14180);
		Eq_4 ecx_11710 = unicode.foldCommon;
		word32 edi_14182;
		word32 esi_14181;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_14181, out edi_14182);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) ecx_11710;
		else
			runtime.writebarrierptr(0x00, ecx_11710);
		Eq_4 eax_11761 = unicode.foldGreek;
		word32 esi_14178;
		word32 edi_14179;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_14178, out edi_14179);
		if (g_t81576F0 == 0x00)
			null = (union Eq_4 *) eax_11761;
		else
			runtime.writebarrierptr(0x00, eax_11761);
		Eq_4 eax_11815 = unicode.foldInherited;
		word32 esi_14176;
		word32 edi_14177;
		runtime.mapassign_faststr(gs, &g_t80CFB40, dwLoc1C, out esi_14176, out edi_14177);
		if (g_t81576F0 == 0x00)
		{
			null = (union Eq_4 *) eax_11815;
			unicode.FoldScript = dwLoc1C;
		}
		else
		{
			runtime.writebarrierptr(0x00, eax_11815);
			runtime.writebarrierptr(0x08144FF8, dwLoc1C);
		}
		g_b8157588 = 0x02;
	}
	else
		runtime.throwinit(gs);
}

// 080A4A80: void reflect.makeMethodValue(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg0C, Stack Eq_4 dwArg10, Stack Eq_4 dwArg14)
// Called from:
//      reflect.valueInterface
//      reflect.Value.assignTo
void reflect.makeMethodValue(struct Eq_2 * gs, Eq_4 dwArg0C, Eq_4 dwArg10, Eq_4 dwArg14)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if ((dwArg14 & 0x0200) == 0x00)
		runtime.gopanic(gs);
	else
	{
		byte dl_39 = *((word32) dwArg0C + 0x0F);
		reflect.Value.Type(gs, dwArg0C, dwArg14);
		ui32 edx_57 = (word32) dl_39 & 0x1F | dwArg14 & 0x01E0;
		if (dwLoc38 != 0x08138A00)
			runtime.panicdottypeI(gs, dwLoc38);
		else
		{
			Eq_4 ecx_81 = g_t80E7B64;
			reflect.funcLayout(gs, dwLoc34, 0x00);
			runtime.newobject(gs, 0x080D6B20);
			null = (union Eq_4 *) ecx_81;
			if (g_t81576F0 == 0x00)
				*(union Eq_4 *) 0x04 = dwLoc30;
			else
				runtime.writebarrierptr(0x04, dwLoc30);
			*(union Eq_4 *) 0x08 = dwArg14 >> 0x0A;
			*(ui32 *) 0x14 = edx_57;
			if (g_t81576F0 == 0x00)
			{
				*(union Eq_4 *) 0x0C = dwArg0C;
				*(union Eq_4 *) 0x10 = dwArg10;
			}
			else
			{
				runtime.writebarrierptr(0x0C, dwArg0C);
				runtime.writebarrierptr(0x10, dwArg10);
			}
			reflect.methodReceiver(gs, *(union Eq_4 *) 0x0C, dwArg10, *(union Eq_4 *) 0x08);
		}
	}
}

// 080A4C70: void reflect.name.tagLen(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      reflect.name.tag
//      reflect.name.pkgPath
void reflect.name.tagLen(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if ((*dwArg04 & 0x02) != 0x00)
		;
}

// 080A4CE0: void reflect.name.tag(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      reflect.(*structType).Field
//      reflect.haveIdenticalUnderlyingType
void reflect.name.tag(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.name.tagLen(gs, dwArg04);
	if (dwLoc04 != 0x00)
		;
}

// 080A4D60: void reflect.name.pkgPath(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      reflect.(*interfaceType).Method
//      reflect.(*structType).Field
//      reflect.implements
//      reflect.haveIdenticalUnderlyingType
void reflect.name.pkgPath(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (dwArg04 == 0x00 || (*dwArg04 & 0x04) == 0x00)
		return;
	int32 eax_56;
	cui16 dx_31 = (word16) (word32) *((word32) dwArg04 + 1);
	cui16 cx_34 = (word16) (word32) *((word32) dwArg04 + 2);
	reflect.name.tagLen(gs, dwArg04);
	word32 eax_51 = (word32) (dx_31 << 0x08 | cx_34);
	if (dwLoc18 > 0x00)
		eax_56 = dwLoc18 + 0x05 + eax_51;
	else
		eax_56 = eax_51 + 0x03;
	word128 xmm1_253;
	word128 xmm2_254;
	word128 xmm0_252;
	word32 esi_250;
	word32 edi_251;
	word32 ebp_249;
	runtime.memmove(fp - 0x0C, (word32) dwArg04 + eax_56, 0x04, out ebp_249, out esi_250, out edi_251, out xmm0_252, out xmm1_253, out xmm2_254);
	reflect.resolveTypeOff(gs);
}

// 080A4E80: Register Eq_4 reflect.newName(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C, Stack Eq_4 dwArg10, Stack word32 dwArg18, Stack byte bArg1C, Register out ptr32 esiOut, Register out ptr32 ediOut)
// Called from:
//      reflect.(*rtype).ptrTo
//      reflect.FuncOf
//      reflect.funcLayout
Eq_4 reflect.newName(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C, Eq_4 dwArg10, word32 dwArg18, byte bArg1C, ptr32 & esiOut, ptr32 & ediOut)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (dwArg08 > 0xFFFF)
	{
		runtime.concatstring2(gs, 0x00);
		runtime.convT2Estring(gs, 135066016, fp - 0x08);
		runtime.gopanic(gs);
	}
	else if (dwArg10 > 0xFFFF)
	{
		runtime.concatstring2(gs, 0x00);
		runtime.convT2Estring(gs, 135066016, fp - 0x10);
		runtime.gopanic(gs);
	}
	else
	{
		Eq_4 ebx_140;
		ui32 ebp_141;
		if (dwArg10 > 0x00)
		{
			ebx_140 = (word32) dwArg08 + ((word32) dwArg10 + 5);
			ebp_141 = (word32) bArg1C | 0x02;
		}
		else
		{
			ebx_140 = (word32) dwArg08 + 3;
			ebp_141 = (word32) bArg1C;
		}
		if (dwArg18 != 0x00)
			ebp_141 |= 0x04;
		word32 edi_477;
		runtime.makeslice(gs, 0x080CF320, ebx_140, ebx_140, out edi_477);
		byte al_164 = (byte) ebp_141;
		if (dwLoc30 <= 0x00)
			runtime.panicindex(gs);
		else
		{
			dwLoc34->a0000[0] = al_164;
			if (dwLoc30 <= 0x01)
				runtime.panicindex(gs);
			else
			{
				dwLoc34->t0001 = (byte) (dwArg08 >> 0x08);
				if (dwLoc30 <= 0x02)
					runtime.panicindex(gs);
				else
				{
					dwLoc34->b0002 = (byte) dwArg08;
					Eq_4 ebp_216 = dwArg08;
					Eq_4 ebx_222 = dwLoc34 + (0x03 - dwLoc2C >> 0x1F & 0x03) / 3;
					if (dwLoc30 - 0x03 <= dwArg08)
						ebp_216 = dwLoc30 - 0x03;
					word128 xmm2_481;
					word128 xmm0_479;
					word128 xmm1_480;
					word32 ebp_478;
					ptr32 esi_236;
					ptr32 edi_235;
					Eq_4 ebx_234 = runtime.memmove(ebx_222, dwArg04, ebp_216, out ebp_478, out esi_236, out edi_235, out xmm0_479, out xmm1_480, out xmm2_481);
					if (dwArg10 > 0x00)
					{
						if ((word32) dwArg08 + 3 > dwLoc30)
							runtime.panicslice(gs);
						int32 ebx_267 = dwLoc2C - ((word32) dwArg08 + 3);
						int32 ebx_271 = -ebx_267 >> 0x1F & (word32) dwArg08 + 3;
						Eq_111696 edx_265 = dwLoc30 - ((word32) dwArg08 + 3);
						ui32 esi_273 = dwLoc34 + ebx_271 / 3;
						if (edx_265 <= 0x00)
							runtime.panicindex(gs);
						dwLoc34[ebx_271 / 3] = (struct Eq_111630) (byte) (dwArg10 >> 0x08);
						if (edx_265 <= 0x01)
							runtime.panicindex(gs);
						*((char *) &dwLoc34->t0001 + ebx_271) = (union Eq_111640 *) (byte) dwArg10;
						Eq_4 edi_290 = dwArg10;
						Eq_4 eax_295 = (0x02 - ebx_267 >> 0x1F & 0x02) + esi_273;
						if ((word32) edx_265 - 2 <= dwArg10)
							edi_290 = (word32) edx_265 - 2;
						word128 xmm0_483;
						word128 xmm1_484;
						word128 xmm2_485;
						word32 ebp_482;
						ebx_234 = runtime.memmove(eax_295, dwArg0C, edi_290, out ebp_482, out esi_236, out edi_235, out xmm0_483, out xmm1_484, out xmm2_485);
					}
					if (dwArg18 != 0x00)
						runtime.gopanic(gs);
					else
					{
						esiOut = esi_236;
						ediOut = edi_235;
						return ebx_234;
					}
				}
			}
		}
	}
}

// 080A5140: void reflect.Kind.String(Register (ptr32 ptr32) ebx, Register word32 ebp, Register (ptr32 Eq_23322) esi, Register (ptr32 Eq_2) gs, Stack Eq_99008 dwArg04)
// Called from:
//      reflect.(*ValueError).Error
//      reflect.(*Kind).String
void reflect.Kind.String(ptr32 * ebx, word32 ebp, struct Eq_23322 * esi, struct Eq_2 * gs, Eq_99008 dwArg04)
{
	ui24 ebx_24_8 = SLICE(ebx, word24, 8);
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_99008 eax_17 = g_t81426B4;
	if (dwArg04 >= eax_17)
	{
		strconv.Itoa(ebx_24_8, ebp, esi, gs, dwArg04);
		runtime.concatstring2(gs, 0x00);
	}
	else
	{
		if (dwArg04 < eax_17)
			return;
		runtime.panicindex(gs);
	}
}

// 080A51E0: void reflect.resolveReflectName(Register word24 ebx_24_8, Register Eq_4 esi, Register Eq_4 edi, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      reflect.(*rtype).ptrTo
//      reflect.FuncOf
//      reflect.funcLayout
void reflect.resolveReflectName(word24 ebx_24_8, Eq_4 esi, Eq_4 edi, struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.addReflectOff(ebx_24_8, esi, edi, gs, dwArg04);
}

// 080A5220: Register word32 reflect.(*rtype).nameOff(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
// Called from:
//      reflect.(*rtype).String
//      reflect.(*rtype).exportedMethods
//      reflect.(*rtype).Method
//      reflect.(*interfaceType).Method
//      reflect.(*interfaceType).MethodByName
//      reflect.implements
//      reflect.methodReceiver
//      reflect.(*sliceType).MethodByName
//      reflect.(*sliceType).PkgPath
word32 reflect.(*rtype).nameOff(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	return reflect.resolveNameOff(gs, dwArg04, dwArg08);
}

// 080A5260: void reflect.(*rtype).typeOff(Register (ptr32 Eq_2) gs)
// Called from:
//      reflect.(*rtype).Method
//      reflect.(*interfaceType).Method
//      reflect.(*rtype).ptrTo
//      reflect.implements
//      reflect.methodReceiver
//      reflect.Value.Type
void reflect.(*rtype).typeOff(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.resolveTypeOff(gs);
}

// 080A52A0: void reflect.(*rtype).textOff(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
// Called from:
//      reflect.(*rtype).Method
//      reflect.methodReceiver
void reflect.(*rtype).textOff(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.resolveTextOff(gs, dwArg04, dwArg08);
}

// 080A52E0: void reflect.(*rtype).uncommon(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      reflect.(*rtype).exportedMethods
//      reflect.implements
//      reflect.methodReceiver
//      reflect.Value.Type
//      reflect.(*structType).uncommon
//      reflect.(*funcType).uncommon
//      reflect.(*funcTypeFixed128).uncommon
//      reflect.(*funcTypeFixed16).uncommon
//      reflect.(*funcTypeFixed32).uncommon
//      reflect.(*funcTypeFixed4).uncommon
//      reflect.(*funcTypeFixed64).uncommon
//      reflect.(*funcTypeFixed8).uncommon
//      reflect.(*interfaceType).uncommon
//      reflect.(*ptrType).uncommon
//      reflect.(*sliceType).uncommon
//      reflect.(*sliceType).MethodByName
//      reflect.(*sliceType).PkgPath
void reflect.(*rtype).uncommon(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if ((*((word32) dwArg04 + 0x0C) & 0x01) == 0x00)
		return;
	ui32 ecx_23 = (word32) *((word32) dwArg04 + 0x0F);
	if ((ecx_23 & 0x1F) > 0x14)
	{
		if ((ecx_23 & 0x1F) > 22)
		{
			if ((ecx_23 & 0x1F) == 0x17)
				return;
			if ((ecx_23 & 0x1F) != 0x19)
				;
		}
		else if ((ecx_23 & 0x1F) != 0x15)
			;
	}
	else if ((ecx_23 & 0x1F) > 0x12)
	{
		if ((ecx_23 & 0x1F) != 0x13)
			;
	}
	else
	{
		if ((ecx_23 & 0x1F) == 0x11)
			return;
		if ((ecx_23 & 0x1F) == 0x12)
			;
	}
}

// 080A53A0: void reflect.(*rtype).String(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      reflect.(*rtype).Name
//      reflect.(*rtype).ptrTo
//      reflect.typesByString
//      reflect.funcStr
//      reflect.funcLayout
//      reflect.Value.assignTo
//      reflect.(*structType).String
//      reflect.(*funcType).String
//      reflect.(*funcTypeFixed128).String
//      reflect.(*funcTypeFixed16).String
//      reflect.(*funcTypeFixed32).String
//      reflect.(*funcTypeFixed4).String
//      reflect.(*funcTypeFixed64).String
//      reflect.(*funcTypeFixed8).String
//      reflect.(*interfaceType).String
//      reflect.(*ptrType).String
//      reflect.(*sliceType).String
//      reflect.(*sliceType).Bits
void reflect.(*rtype).String(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).nameOff(gs, dwArg04, *((word32) dwArg04 + 24));
	uint32 dwLoc04_82 = 0x00;
	if (dwLoc0C != null)
		dwLoc04_82 = (word32) dwLoc0C->b0001 << 0x08 | (word32) dwLoc0C->b0002;
	if ((*((word32) dwArg04 + 0x0C) & 0x02) == 0x00)
		return;
	if (dwLoc04_82 >= 0x01)
		return;
	runtime.panicslice(gs);
}

// 080A5450: void reflect.(*rtype).Size(Register (ptr32 Eq_111955) gs)
// Called from:
//      reflect.(*structType).Size
//      reflect.(*funcType).Size
//      reflect.(*funcTypeFixed128).Size
//      reflect.(*funcTypeFixed16).Size
//      reflect.(*funcTypeFixed32).Size
//      reflect.(*funcTypeFixed4).Size
//      reflect.(*funcTypeFixed64).Size
//      reflect.(*funcTypeFixed8).Size
//      reflect.(*interfaceType).Size
//      reflect.(*ptrType).Size
//      reflect.(*sliceType).Size
void reflect.(*rtype).Size(struct Eq_111955 * gs)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
}

// 080A5480: void reflect.(*rtype).Bits(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      reflect.(*structType).Bits
//      reflect.(*funcType).Bits
//      reflect.(*funcTypeFixed128).Bits
//      reflect.(*funcTypeFixed16).Bits
//      reflect.(*funcTypeFixed32).Bits
//      reflect.(*funcTypeFixed4).Bits
//      reflect.(*funcTypeFixed64).Bits
//      reflect.(*funcTypeFixed8).Bits
//      reflect.(*interfaceType).Bits
//      reflect.(*ptrType).Bits
//      reflect.(*sliceType).Bits
void reflect.(*rtype).Bits(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (dwArg04 == 0x00)
		runtime.gopanic(gs);
	else
	{
		if (((word32) *((word32) dwArg04 + 0x0F) & 0x1F) <= ~0x0F)
			return;
		reflect.(*rtype).String(gs, dwArg04);
		runtime.concatstring2(gs, 0x00);
		runtime.convT2Estring(gs, 135066016, fp - 0x08);
		runtime.gopanic(gs);
	}
}

// 080A5560: void reflect.(*rtype).Align(Register (ptr32 Eq_112007) gs)
// Called from:
//      reflect.(*structType).Align
//      reflect.(*funcType).Align
//      reflect.(*funcTypeFixed128).Align
//      reflect.(*funcTypeFixed16).Align
//      reflect.(*funcTypeFixed32).Align
//      reflect.(*funcTypeFixed4).Align
//      reflect.(*funcTypeFixed64).Align
//      reflect.(*funcTypeFixed8).Align
//      reflect.(*interfaceType).Align
//      reflect.(*ptrType).Align
//      reflect.(*sliceType).Align
void reflect.(*rtype).Align(struct Eq_112007 * gs)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
}

// 080A5590: void reflect.(*rtype).FieldAlign(Register (ptr32 Eq_112020) gs)
// Called from:
//      reflect.(*structType).FieldAlign
//      reflect.(*funcType).FieldAlign
//      reflect.(*funcTypeFixed128).FieldAlign
//      reflect.(*funcTypeFixed16).FieldAlign
//      reflect.(*funcTypeFixed32).FieldAlign
//      reflect.(*funcTypeFixed4).FieldAlign
//      reflect.(*funcTypeFixed64).FieldAlign
//      reflect.(*funcTypeFixed8).FieldAlign
//      reflect.(*interfaceType).FieldAlign
//      reflect.(*ptrType).FieldAlign
//      reflect.(*sliceType).FieldAlign
void reflect.(*rtype).FieldAlign(struct Eq_112020 * gs)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
}

// 080A55C0: void reflect.(*rtype).Kind(Register (ptr32 Eq_112033) gs)
// Called from:
//      reflect.(*structType).Kind
//      reflect.(*funcType).Kind
//      reflect.(*funcTypeFixed128).Kind
//      reflect.(*funcTypeFixed16).Kind
//      reflect.(*funcTypeFixed32).Kind
//      reflect.(*funcTypeFixed4).Kind
//      reflect.(*funcTypeFixed64).Kind
//      reflect.(*funcTypeFixed8).Kind
//      reflect.(*interfaceType).Kind
//      reflect.(*ptrType).Kind
//      reflect.(*sliceType).Kind
void reflect.(*rtype).Kind(struct Eq_112033 * gs)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
}

// 080A55F0: void reflect.(*rtype).common(Register (ptr32 Eq_112046) gs)
// Called from:
//      reflect.(*structType).common
//      reflect.(*funcType).common
//      reflect.(*funcTypeFixed128).common
//      reflect.(*funcTypeFixed16).common
//      reflect.(*funcTypeFixed32).common
//      reflect.(*funcTypeFixed4).common
//      reflect.(*funcTypeFixed64).common
//      reflect.(*funcTypeFixed8).common
//      reflect.(*interfaceType).common
//      reflect.(*ptrType).common
//      reflect.(*sliceType).common
void reflect.(*rtype).common(struct Eq_112046 * gs)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
}

// 080A5620: Register word128 reflect.(*rtype).exportedMethods(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Register out Eq_112062 xmm1Out)
// Called from:
//      reflect.(*rtype).NumMethod
//      reflect.(*rtype).Method
word128 reflect.(*rtype).exportedMethods(struct Eq_2 * gs, Eq_4 dwArg04, union Eq_112062 & xmm1Out)
{
	byte bLoc48 = (byte) dwLoc48;
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	sync.(*Map).Load(gs, 0x08145220, 0x080DDF40, dwArg04);
	Eq_4 dwLoc54_352 = dwArg04;
	if (bLoc48 != 0x00)
	{
		if (dwLoc50 != 0x080C9840)
			runtime.panicdottypeE(gs, dwLoc50);
		else
		{
			xmm1Out = xmm1;
			return xmm0;
		}
	}
	else
	{
		reflect.(*rtype).uncommon(gs, dwArg04);
		word32 ecx_74 = g_dw80DDF48;
		struct Eq_112095 * ecx_118 = ecx_74 + 0x080DDF40;
		Eq_4 eax_79 = (word32) g_w80DDF44;
		if (eax_79 > 0x00010000)
			runtime.panicslice(gs);
		else
		{
			Eq_4 ebx_104 = 0x00;
			while (true)
			{
				byte al_126;
				if (ebx_104 >= eax_79)
					break;
				ebx_104 = reflect.(*rtype).nameOff(gs, dwArg04, ecx_118->dw0000);
				if ((*dwArg04 & 0x01) == 0x00)
				{
					al_126 = 0x00;
					goto l080A56F2;
				}
				++ecx_118;
				ebx_104 = (word32) ebx_104 + 1;
			}
			al_126 = 0x01;
l080A56F2:
			if (al_126 == 0x00)
			{
				word32 edi_532;
				runtime.makeslice(gs, 0x080D6AA0, 0x00, eax_79, out edi_532);
				dwLoc54_352 = eax_79;
				Eq_4 eax_154 = dwLoc50;
				Eq_4 ecx_155 = dwLoc4C;
				Eq_4 edx_156 = dwLoc48;
				ebx_104.u0 = 0x00;
				struct Eq_112139 * ebp_160 = ecx_74 + 0x080DDF40;
				while (ebx_104 < eax_79)
				{
					Eq_4 ebx_275;
					Eq_4 eax_249 = ebp_160->dw000C;
					Eq_4 ecx_251 = ebp_160->dw0000;
					Eq_4 edx_253 = ebp_160->dw0008;
					word32 ebx_255 = ebp_160->dw0004;
					reflect.(*rtype).nameOff(gs, dwArg04, ecx_251);
					if ((*dwLoc54_352 & 0x01) != 0x00)
					{
						ecx_155 = (word32) ecx_155 + 1;
						if ((word32) ecx_155 + 1 <= edx_156)
							ebx_275 = eax_154;
						else
						{
							word32 esi_533;
							word128 xmm0_534;
							word128 xmm1_535;
							runtime.growslice(gs, 0x080D6AA0, eax_154, ecx_155, edx_156, (word32) ecx_155 + 1, out esi_533, out xmm0_534, out xmm1_535);
							dwLoc54_352 = ecx_155;
							dwLoc50 = edx_156;
							ebx_275 = dwLoc48;
							edx_156 = dwLoc40;
							ecx_155 = dwLoc44 + 0x01;
						}
						*((word32) ebx_275 + ecx_155 * 0x10) = ecx_251;
						*((word32) ebx_275 + (ecx_155 * 0x10 + 4)) = ebx_255;
						*((word32) ebx_275 + (ecx_155 * 0x10 + 8)) = edx_253;
						*((word32) ebx_275 + (ecx_155 * 0x10 + 0x0C)) = eax_249;
					}
					else
						ebx_275 = eax_154;
					++ebp_160;
					eax_154 = ebx_275;
					ebx_104 = (byte) ebx_104.u0 + 1;
				}
			}
			runtime.convT2Eslice(ebx_104, gs, 0x080C9840, fp - 0x0C);
			Eq_112062 xmm1_214;
			word128 xmm0_213 = sync.(*Map).LoadOrStore(gs, 0x08145220, dwLoc54_352, dwLoc50, out xmm1_214);
			if (dwLoc48 != 0x080C9840)
				runtime.panicdottypeE(gs, dwLoc48);
			else
			{
				xmm1Out = xmm1_214;
				return xmm0_213;
			}
		}
	}
}

// 080A5930: Register word128 reflect.(*rtype).NumMethod(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Register out Eq_112233 xmm1Out)
// Called from:
//      reflect.Value.Elem
//      reflect.Value.NumMethod
//      reflect.Value.assignTo
//      reflect.(*structType).NumMethod
//      reflect.(*funcType).NumMethod
//      reflect.(*funcTypeFixed128).NumMethod
//      reflect.(*funcTypeFixed16).NumMethod
//      reflect.(*funcTypeFixed32).NumMethod
//      reflect.(*funcTypeFixed4).NumMethod
//      reflect.(*funcTypeFixed64).NumMethod
//      reflect.(*funcTypeFixed8).NumMethod
//      reflect.(*ptrType).NumMethod
//      reflect.(*sliceType).NumMethod
word128 reflect.(*rtype).NumMethod(struct Eq_2 * gs, Eq_4 dwArg04, union Eq_112233 & xmm1Out)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (((word32) *((word32) dwArg04 + 0x0F) & 0x1F) == 0x14)
	{
		xmm1Out = xmm1;
		return xmm0;
	}
	else if ((*((word32) dwArg04 + 0x0C) & 0x01) != 0x00)
	{
		Eq_112233 xmm1_41;
		word128 xmm0_40 = reflect.(*rtype).exportedMethods(gs, dwArg04, out xmm1_41);
		xmm1Out = xmm1_41;
		return xmm0_40;
	}
	else
	{
		xmm1Out = xmm1;
		return xmm0;
	}
}

// 080A5990: void reflect.(*rtype).Method(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg00, Stack Eq_4 dwArg04)
// Called from:
//      reflect.(*structType).Method
//      reflect.(*funcType).Method
//      reflect.(*funcTypeFixed128).Method
//      reflect.(*funcTypeFixed16).Method
//      reflect.(*funcTypeFixed32).Method
//      reflect.(*funcTypeFixed4).Method
//      reflect.(*funcTypeFixed64).Method
//      reflect.(*funcTypeFixed8).Method
//      reflect.(*ptrType).Method
//      reflect.(*sliceType).Method
//      reflect.(*sliceType).MethodByName
void reflect.(*rtype).Method(struct Eq_2 * gs, Eq_4 dwArg00, Eq_4 dwArg04)
{
	while (fp - 0x4C <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	fn0808FD86(0x00, fp + 0x0C);
	if (((word32) *((word32) dwArg00 + 0x0F) & 0x1F) != 0x14)
	{
		word128 xmm1_1196;
		reflect.(*rtype).exportedMethods(gs, dwArg00, out xmm1_1196);
		if (dwArg04 < 0x00 || dwArg04 >= dwLocC8)
			runtime.gopanic(gs);
		else
		{
			Eq_4 ebp_80 = dwLocCC[dwArg04].t0004;
			reflect.(*rtype).nameOff(gs, dwArg00, dwLocCC[dwArg04].t0000);
			reflect.(*rtype).typeOff(gs);
			(*((word32) dwLocC8 + 0x0C) & 0x01) == 0x00;
			up32 ecx_143 = (word32) *((word32) dwLocC8 + 32);
			if (ecx_143 > 0x00100000)
				runtime.panicslice(gs);
			else
			{
				Eq_4 dwLocC0_843;
				word32 edi_1197;
				runtime.makeslice(gs, 135117536, 0x00, ecx_143 + 0x01, out edi_1197);
				Eq_4 eax_166 = dwLocBC;
				Eq_4 ecx_167 = dwLocC4;
				Eq_4 ebx_169 = (word32) dwLocC0 + 1;
				dwLocC0_843 = dwLocC0;
				if ((word32) dwLocC0 + 1 > dwLocBC)
				{
					word128 xmm0_1199;
					word32 esi_1198;
					word128 xmm1_1200;
					runtime.growslice(gs, 135117536, dwLocC4, dwLocC0, dwLocBC, (word32) dwLocC0 + 1, out esi_1198, out xmm0_1199, out xmm1_1200);
					dwLocC4 = dwLocBC;
					dwLocC0_843 = (word32) dwLocC0 + 1;
					ecx_167 = dwLocBC;
					ebx_169 = dwLocB8 + 0x01;
					eax_166 = dwLocB4;
				}
				*((word32) ecx_167 + dwLocC0 * 0x08) = 0x08138A00;
				Eq_4 edx_210 = (word32) ecx_167 + 4 + dwLocC0 * 0x08;
				if (g_t81576F0 == 0x00)
					*edx_210 = dwArg00;
				else
				{
					runtime.writebarrierptr(edx_210, dwArg00);
					dwLoc88 = eax_166;
				}
				int32 edi_254;
				ptr32 esi_675 = 0x08138A00;
				Eq_4 ecx_328 = ecx_167;
				Eq_4 ebx_281 = ebx_169;
				if ((*((word32) dwLocC8 + 0x0C) & 0x01) != 0x00)
					edi_254 = 0x34;
				else
					edi_254 = 0x24;
				word32 * ebp_259 = (word32) dwLocC8 + edi_254;
				Eq_112413 edi_264 = (word32) *((word32) dwLocC8 + 32);
				if (edi_264 > 0x00100000)
					runtime.panicslice(gs);
				else
				{
					Eq_112413 dwLoc78_863 = 0x00;
					Eq_4 eax_280 = eax_166;
					while (dwLoc78_863 < edi_264)
					{
						dwLoc3C = ebp_259;
						Eq_4 edi_637 = *ebp_259;
						Eq_4 edx_638 = (word32) ebx_281 + 1;
						if (edx_638 > eax_280)
						{
							word128 xmm0_1202;
							word32 esi_1201;
							word128 xmm1_1203;
							runtime.growslice(gs, 135117536, ecx_328, ebx_281, eax_280, edx_638, out esi_1201, out xmm0_1202, out xmm1_1203);
							dwLocC4 = eax_280;
							dwLocC0_843 = edx_638;
							ecx_328 = dwLocBC;
							esi_675 = 0x08138A00;
							edx_638 = dwLocB8 + 0x01;
							eax_280 = dwLocB4;
						}
						*((word32) ecx_328 + ebx_281 * 0x08) = esi_675;
						dwLoc88 = eax_280;
						Eq_4 eax_690 = (word32) ecx_328 + 4 + ebx_281 * 0x08;
						if (g_t81576F0 == 0x00)
							*eax_690 = edi_637;
						else
						{
							runtime.writebarrierptr(eax_690, edi_637);
							dwLoc7C = edx_638;
							esi_675 = 0x08138A00;
						}
						++ebp_259;
						dwLoc78_863 = (word32) dwLoc78_863.u0 + 1;
						ebx_281 = edx_638;
					}
					(*((word32) dwLocC8 + 0x0C) & 0x01) == 0x00;
					word32 edi_314 = (word32) *((word32) dwLocC8 + 32);
					up32 eax_316 = (word32) (word16) edi_314;
					up32 ebp_319 = (word32) ((*((word32) dwLocC8 + 0x0022) & 0x7FFF) + (word16) edi_314);
					if (eax_316 > ebp_319 || ebp_319 > 0x00100000)
						runtime.panicslice(gs);
					else
					{
						word32 ebp_362;
						Eq_4 ebp_333 = ebp_319 - eax_316;
						word32 edi_1204;
						runtime.makeslice(gs, 135117536, 0x00, ebp_333, out edi_1204);
						byte bLocC8_885 = (byte) ebp_333;
						Eq_4 ecx_348 = dwLocC0_843;
						Eq_4 edx_349 = dwLocC4;
						if ((*((word32) dwLocC8 + 0x0C) & 0x01) != 0x00)
							ebp_362 = 0x34;
						else
							ebp_362 = 0x24;
						word32 edi_374 = (word32) *((word32) dwLocC8 + 32);
						word32 ebp_367 = (word32) dwLocC8 + ebp_362;
						uint32 ebx_376 = (word32) (word16) edi_374;
						uint32 esi_379 = (word32) ((*((word32) dwLocC8 + 0x0022) & 0x7FFF) + (word16) edi_374);
						Eq_4 eax_420 = dwLocBC;
						if (ebx_376 > esi_379 || esi_379 > 0x00100000)
							runtime.panicslice(gs);
						else
						{
							Eq_112514 esi_386 = esi_379 - ebx_376;
							word32 * ebx_407 = ebp_367 + (-(-(ebx_376 + 0xFFF00000)) >> 0x1F & ebx_376 << 0x02);
							Eq_112514 ebp_408 = 0x00;
							while (ebp_408 < esi_386)
							{
								Eq_4 edi_550 = *ebx_407;
								Eq_4 esi_551 = (word32) ecx_348 + 1;
								if (esi_551 > eax_420)
								{
									word128 xmm0_1206;
									word32 esi_1205;
									word128 xmm1_1207;
									runtime.growslice(gs, 135117536, edx_349, ecx_348, eax_420, esi_551, out esi_1205, out xmm0_1206, out xmm1_1207);
									bLocC8_885 = (byte) ecx_348;
									edx_349 = dwLocBC;
									esi_551 = dwLocB8 + 0x01;
									eax_420 = dwLocB4;
								}
								*((word32) edx_349 + ecx_348 * 0x08) = 0x08138A00;
								dwLoc90 = eax_420;
								Eq_4 ecx_601 = (word32) edx_349 + 4 + ecx_348 * 0x08;
								if (g_t81576F0 == 0x00)
									*ecx_601 = edi_550;
								else
									runtime.writebarrierptr(ecx_601, edi_550);
								++ebx_407;
								ebp_408 = (word32) ebp_408.u0 + 1;
								ecx_348 = esi_551;
							}
							reflect.(*rtype).IsVariadic(gs, dwLocC8);
							reflect.FuncOf(gs, dwLoc3C, dwLoc88, dwLoc90, bLocC8_885);
							runtime.newobject(gs, 0x080CF3A0);
							reflect.(*rtype).textOff(gs, dwArg04, ebp_80);
							if (g_t81576F0 == 0x00)
								*dwLoc88 = dwLoc7C;
							else
								runtime.writebarrierptr(dwLoc88, dwLoc7C);
							if (dwLocB0 == 0x08138A00)
								return;
							runtime.panicdottypeI(gs, dwLocB0);
						}
					}
				}
			}
		}
	}
	else
	{
		reflect.(*interfaceType).Method(gs, dwLocD4, dwArg00);
		fn0809023C(fp - 188, fp - 0x20);
		fn0809023C(fp - 0x24, fp + 0x10);
	}
}

// 080A6060: void reflect.(*rtype).MethodByName(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg00, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
// Called from:
//      reflect.(*structType).MethodByName
//      reflect.(*funcType).MethodByName
//      reflect.(*funcTypeFixed128).MethodByName
//      reflect.(*funcTypeFixed16).MethodByName
//      reflect.(*funcTypeFixed32).MethodByName
//      reflect.(*funcTypeFixed4).MethodByName
//      reflect.(*funcTypeFixed64).MethodByName
//      reflect.(*funcTypeFixed8).MethodByName
//      reflect.(*ptrType).MethodByName
//      reflect.(*sliceType).MethodByName
void reflect.(*rtype).MethodByName(struct Eq_2 * gs, Eq_4 dwArg00, Eq_4 dwArg04, Eq_4 dwArg08)
{
	while (fp - 0x4C <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	fn0808FD86(0x00, &fp->dw0004 + 3);
	if (((word32) *((word32) dwArg00 + 0x0F) & 0x1F) == 0x14)
	{
		fn0808FD86(0x00, fp - 0x54);
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_4 stackArg0 = <invalid>;
		Eq_4 stackArg4 = <invalid>;
		Eq_4 stackArg8 = <invalid>;
		reflect.(*interfaceType).MethodByName(gs, stackArg0, stackArg4, stackArg8);
		fn0809023C(fp - 200, fp - 88);
		fn0809023C(fp - 0x5C, fp - 0x34);
		fn0809023C(fp - 0x38, fp);
	}
	else
	{
		reflect.(*rtype).uncommon(gs, dwArg00);
		if (dwLocCC == null)
			fn0809023C(&g_t80F1F40, &fp->dw0004 + 2);
		else
		{
			Eq_139024 ecx_106[] = dwLocCC + dwLocCC->dw0008 / 0x0C;
			Eq_112696 edx_109 = (word32) dwLocCC->w0004;
			if (edx_109 > 0x00010000)
				runtime.panicslice(gs);
			else
			{
				Eq_112696 ebx_115 = 0x00;
				while (ebx_115 < (word32) dwLocCC->w0004)
				{
					if (ebx_115 >= edx_109)
						runtime.panicindex(gs);
					reflect.(*rtype).nameOff(gs, dwArg00, ecx_106[ebx_115].t0000);
					if ((*dwLocC8 & 0x01) != 0x00)
					{
						Eq_4 dwLoc84_290 = (word32) dwLocC8 + 3;
						Eq_4 ecx_173 = (word32) *((word32) dwLocC8 + 1) << 0x08 | (word32) (*((word32) dwLocC8 + 2));
						if (dwArg08 == ecx_173)
						{
							word32 ebx_399;
							word32 edi_401;
							word32 esi_400;
							runtime.eqstring(dwArg08, dwLoc84_290, ecx_173, dwArg04, out ebx_399, out esi_400, out edi_401);
							dwLocC8 = dwArg04;
							if (bLocC0 != 0x00)
							{
								reflect.(*rtype).Method(gs, dwLocD4, dwArg00);
								fn0809023C(fp - 200, fp - 0x7C);
								fn0809023C(fp - 0x80, &fp->dw0004 + 1);
								return;
							}
						}
					}
					ebx_115 = (word32) ebx_115 + 1;
				}
				fn0809023C(&g_t80F1F80, &fp->dw0004 + 2);
			}
		}
	}
}

// 080A62D0: void reflect.(*rtype).PkgPath(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      reflect.(*structType).PkgPath
//      reflect.(*funcType).PkgPath
//      reflect.(*funcTypeFixed128).PkgPath
//      reflect.(*funcTypeFixed16).PkgPath
//      reflect.(*funcTypeFixed32).PkgPath
//      reflect.(*funcTypeFixed4).PkgPath
//      reflect.(*funcTypeFixed64).PkgPath
//      reflect.(*funcTypeFixed8).PkgPath
//      reflect.(*interfaceType).PkgPath
//      reflect.(*ptrType).PkgPath
//      reflect.(*sliceType).PkgPath
void reflect.(*rtype).PkgPath(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if ((*((word32) dwArg04 + 0x0C) & 0x04) == 0x00)
		return;
	reflect.(*rtype).uncommon(gs, dwArg04);
	if (dwLoc10 == null)
		return;
	reflect.(*rtype).nameOff(gs, dwArg04, *dwLoc10);
}

// 080A6390: void reflect.(*rtype).Name(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      reflect.directlyAssignable
//      reflect.convertOp
//      reflect.(*structType).Name
//      reflect.(*funcType).Name
//      reflect.(*funcTypeFixed128).Name
//      reflect.(*funcTypeFixed16).Name
//      reflect.(*funcTypeFixed32).Name
//      reflect.(*funcTypeFixed4).Name
//      reflect.(*funcTypeFixed64).Name
//      reflect.(*funcTypeFixed8).Name
//      reflect.(*interfaceType).Name
//      reflect.(*ptrType).Name
//      reflect.(*sliceType).Name
void reflect.(*rtype).Name(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if ((*((word32) dwArg04 + 0x0C) & 0x04) == 0x00)
		return;
	reflect.(*rtype).String(gs, dwArg04);
	Eq_112873 edx_39;
	for (edx_39 = dwLoc04 - 0x01; edx_39 >= 0x00; --edx_39)
	{
		if (edx_39 >= dwLoc04)
			runtime.panicindex(gs);
		if (*((word32) edx_39 + dwLoc08) == 0x2E)
			break;
	}
	if ((word32) edx_39 + 1 <= dwLoc04)
		return;
	runtime.panicslice(gs);
}

// 080A6430: void reflect.(*rtype).ChanDir(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      reflect.haveIdenticalUnderlyingType
//      reflect.(*structType).ChanDir
//      reflect.(*funcType).ChanDir
//      reflect.(*funcTypeFixed128).ChanDir
//      reflect.(*funcTypeFixed16).ChanDir
//      reflect.(*funcTypeFixed32).ChanDir
//      reflect.(*funcTypeFixed4).ChanDir
//      reflect.(*funcTypeFixed64).ChanDir
//      reflect.(*funcTypeFixed8).ChanDir
//      reflect.(*interfaceType).ChanDir
//      reflect.(*ptrType).ChanDir
//      reflect.(*sliceType).ChanDir
void reflect.(*rtype).ChanDir(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (((word32) *((word32) dwArg04 + 0x0F) & 0x1F) == 0x12)
		return;
	runtime.gopanic(gs);
}

// 080A6490: void reflect.(*rtype).IsVariadic(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      reflect.(*rtype).Method
//      reflect.funcStr
//      reflect.(*structType).IsVariadic
//      reflect.(*funcType).IsVariadic
//      reflect.(*funcTypeFixed128).IsVariadic
//      reflect.(*funcTypeFixed16).IsVariadic
//      reflect.(*funcTypeFixed32).IsVariadic
//      reflect.(*funcTypeFixed4).IsVariadic
//      reflect.(*funcTypeFixed64).IsVariadic
//      reflect.(*funcTypeFixed8).IsVariadic
//      reflect.(*interfaceType).IsVariadic
//      reflect.(*ptrType).IsVariadic
//      reflect.(*sliceType).IsVariadic
void reflect.(*rtype).IsVariadic(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (((word32) *((word32) dwArg04 + 0x0F) & 0x1F) == 0x13)
		return;
	runtime.gopanic(gs);
}

// 080A64F0: void reflect.(*rtype).Elem(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      reflect.(*structType).FieldByNameFunc
//      reflect.haveIdenticalUnderlyingType
//      reflect.Value.Bytes
//      reflect.Value.runes
//      reflect.Value.SetBytes
//      reflect.Value.setRunes
//      reflect.convertOp
//      reflect.(*structType).Elem
//      reflect.(*funcType).Elem
//      reflect.(*funcTypeFixed128).Elem
//      reflect.(*funcTypeFixed16).Elem
//      reflect.(*funcTypeFixed32).Elem
//      reflect.(*funcTypeFixed4).Elem
//      reflect.(*funcTypeFixed64).Elem
//      reflect.(*funcTypeFixed8).Elem
//      reflect.(*interfaceType).Elem
//      reflect.(*ptrType).Elem
//      reflect.(*sliceType).Elem
void reflect.(*rtype).Elem(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	ui32 ecx_18 = (word32) *((word32) dwArg04 + 0x0F);
	if ((ecx_18 & 0x1F) <= 0x12)
	{
		if ((ecx_18 & 0x1F) == 0x11)
		{
			*((word32) dwArg04 + 32) == 0x00;
			return;
		}
		if ((ecx_18 & 0x1F) == 0x12)
		{
			*((word32) dwArg04 + 32) == 0x00;
			return;
		}
	}
	else
	{
		if ((ecx_18 & 0x1F) == 0x15)
		{
			*((word32) dwArg04 + 36) == 0x00;
			return;
		}
		if ((ecx_18 & 0x1F) == 22)
		{
			*((word32) dwArg04 + 32) == 0x00;
			return;
		}
		if ((ecx_18 & 0x1F) == 0x17)
		{
			*((word32) dwArg04 + 32) == 0x00;
			return;
		}
	}
	runtime.gopanic(gs);
}

// 080A6600: void reflect.(*rtype).Field(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_113006) dwArg00)
// Called from:
//      reflect.(*funcType).Field
//      reflect.(*funcTypeFixed128).Field
//      reflect.(*funcTypeFixed16).Field
//      reflect.(*funcTypeFixed32).Field
//      reflect.(*funcTypeFixed4).Field
//      reflect.(*funcTypeFixed64).Field
//      reflect.(*funcTypeFixed8).Field
//      reflect.(*interfaceType).Field
//      reflect.(*ptrType).Field
//      reflect.(*sliceType).Field
void reflect.(*rtype).Field(struct Eq_2 * gs, struct Eq_113006 * dwArg00)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	fn0808FD83(0x00, (word32) fp + 0x0C);
	if (((word32) dwArg00->b000F & 0x1F) != 0x19)
		runtime.gopanic(gs);
	else
	{
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_4 stackArg0 = <invalid>;
		Eq_4 stackArg4 = <invalid>;
		reflect.(*structType).Field(gs, stackArg0, stackArg4);
		fn0809021E(fp - 0x6C, fp - 0x38);
		fn0809021E(fp - 0x3C, (word32) fp + 4);
	}
}

// 080A6680: void reflect.(*rtype).FieldByIndex(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_113056) dwArg00)
// Called from:
//      reflect.(*funcType).FieldByIndex
//      reflect.(*funcTypeFixed128).FieldByIndex
//      reflect.(*funcTypeFixed16).FieldByIndex
//      reflect.(*funcTypeFixed32).FieldByIndex
//      reflect.(*funcTypeFixed4).FieldByIndex
//      reflect.(*funcTypeFixed64).FieldByIndex
//      reflect.(*funcTypeFixed8).FieldByIndex
//      reflect.(*interfaceType).FieldByIndex
//      reflect.(*ptrType).FieldByIndex
//      reflect.(*sliceType).FieldByIndex
void reflect.(*rtype).FieldByIndex(struct Eq_2 * gs, struct Eq_113056 * dwArg00)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	fn0808FD83(0x00, (word32) fp + 20);
	if (((word32) dwArg00->b000F & 0x1F) != 0x19)
		runtime.gopanic(gs);
	else
	{
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_4 stackArg0 = <invalid>;
		Eq_4 stackArg4 = <invalid>;
		Eq_4 stackArg12 = <invalid>;
		Eq_4 stackArg40 = <invalid>;
		reflect.(*structType).FieldByIndex(gs, stackArg0, stackArg4, stackArg12, stackArg40);
		fn0809021E(fp - 0x6C, fp - 0x38);
		fn0809021E(fp - 0x3C, (word32) fp + 0x0C);
	}
}

// 080A6730: void reflect.(*rtype).FieldByName(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_113109) dwArg00)
// Called from:
//      reflect.(*funcType).FieldByName
//      reflect.(*funcTypeFixed128).FieldByName
//      reflect.(*funcTypeFixed16).FieldByName
//      reflect.(*funcTypeFixed32).FieldByName
//      reflect.(*funcTypeFixed4).FieldByName
//      reflect.(*funcTypeFixed64).FieldByName
//      reflect.(*funcTypeFixed8).FieldByName
//      reflect.(*interfaceType).FieldByName
//      reflect.(*ptrType).FieldByName
//      reflect.(*sliceType).FieldByName
void reflect.(*rtype).FieldByName(struct Eq_2 * gs, struct Eq_113109 * dwArg00)
{
	while (fp - 0x30 <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	fn0808FD83(0x00, &fp->dw0010);
	if (((word32) dwArg00->b000F & 0x1F) != 0x19)
		runtime.gopanic(gs);
	else
	{
		fn0808FD83(0x00, fp - 0x6C);
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_4 stackArg0 = <invalid>;
		Eq_4 stackArg4 = <invalid>;
		Eq_4 stackArg8 = <invalid>;
		reflect.(*structType).FieldByName(esi, gs, stackArg0, stackArg4, stackArg8);
		fn0809021E(fp - 0xAC, fp - 0x70);
		fn0809021E(fp - 116, fp - 0x40);
		fn0809021E(fp - 0x44, fp);
	}
}

// 080A6810: void reflect.(*rtype).FieldByNameFunc(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_113173) dwArg00)
// Called from:
//      reflect.(*funcType).FieldByNameFunc
//      reflect.(*funcTypeFixed128).FieldByNameFunc
//      reflect.(*funcTypeFixed16).FieldByNameFunc
//      reflect.(*funcTypeFixed32).FieldByNameFunc
//      reflect.(*funcTypeFixed4).FieldByNameFunc
//      reflect.(*funcTypeFixed64).FieldByNameFunc
//      reflect.(*funcTypeFixed8).FieldByNameFunc
//      reflect.(*interfaceType).FieldByNameFunc
//      reflect.(*ptrType).FieldByNameFunc
//      reflect.(*sliceType).FieldByNameFunc
void reflect.(*rtype).FieldByNameFunc(struct Eq_2 * gs, struct Eq_113173 * dwArg00)
{
	while (fp - 44 <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	fn0808FD83(0x00, fp + 0x0C);
	if (((word32) dwArg00->b000F & 0x1F) != 0x19)
		runtime.gopanic(gs);
	else
	{
		fn0808FD83(0x00, fp - 0x6C);
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_4 stackArg0 = <invalid>;
		Eq_4 stackArg12 = <invalid>;
		reflect.(*structType).FieldByNameFunc(ebx_24_8, esi, gs, stackArg0, stackArg12);
		fn0809021E(fp - 0xAC, fp - 0x70);
		fn0809021E(fp - 116, fp - 0x40);
		fn0809021E(fp - 0x44, fp - 0x04);
	}
}

// 080A68E0: void reflect.(*rtype).In(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
// Called from:
//      reflect.haveIdenticalUnderlyingType
//      reflect.(*structType).In
//      reflect.(*funcType).In
//      reflect.(*funcTypeFixed128).In
//      reflect.(*funcTypeFixed16).In
//      reflect.(*funcTypeFixed32).In
//      reflect.(*funcTypeFixed4).In
//      reflect.(*funcTypeFixed64).In
//      reflect.(*funcTypeFixed8).In
//      reflect.(*interfaceType).In
//      reflect.(*ptrType).In
//      reflect.(*sliceType).In
void reflect.(*rtype).In(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (((word32) *((word32) dwArg04 + 0x0F) & 0x1F) != 0x13)
		runtime.gopanic(gs);
	else
	{
		word32 ecx_43;
		if ((*((word32) dwArg04 + 0x0C) & 0x01) != 0x00)
			ecx_43 = 0x34;
		else
			ecx_43 = 0x24;
		word32 (* ecx_48)[] = (word32) dwArg04 + ecx_43;
		Eq_4 eax_52 = (word32) *((word32) dwArg04 + 32);
		if (eax_52 > 0x00100000)
			runtime.panicslice(gs);
		else
		{
			if (dwArg08 < eax_52)
				return;
			runtime.panicindex(gs);
		}
	}
}

// 080A6990: void reflect.(*rtype).Key(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      reflect.haveIdenticalUnderlyingType
//      reflect.(*structType).Key
//      reflect.(*funcType).Key
//      reflect.(*funcTypeFixed128).Key
//      reflect.(*funcTypeFixed16).Key
//      reflect.(*funcTypeFixed32).Key
//      reflect.(*funcTypeFixed4).Key
//      reflect.(*funcTypeFixed64).Key
//      reflect.(*funcTypeFixed8).Key
//      reflect.(*interfaceType).Key
//      reflect.(*ptrType).Key
//      reflect.(*sliceType).Key
void reflect.(*rtype).Key(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (((word32) *((word32) dwArg04 + 0x0F) & 0x1F) != 0x15)
		runtime.gopanic(gs);
	else
		*((word32) dwArg04 + 32) == 0x00;
}

// 080A6A00: void reflect.(*rtype).Len(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      reflect.haveIdenticalUnderlyingType
//      reflect.(*structType).Len
//      reflect.(*funcType).Len
//      reflect.(*funcTypeFixed128).Len
//      reflect.(*funcTypeFixed16).Len
//      reflect.(*funcTypeFixed32).Len
//      reflect.(*funcTypeFixed4).Len
//      reflect.(*funcTypeFixed64).Len
//      reflect.(*funcTypeFixed8).Len
//      reflect.(*interfaceType).Len
//      reflect.(*ptrType).Len
//      reflect.(*sliceType).Len
void reflect.(*rtype).Len(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (((word32) *((word32) dwArg04 + 0x0F) & 0x1F) == 0x11)
		return;
	runtime.gopanic(gs);
}

// 080A6A60: void reflect.(*rtype).NumField(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_113346) dwArg04)
// Called from:
//      reflect.(*structType).NumField
//      reflect.(*funcType).NumField
//      reflect.(*funcTypeFixed128).NumField
//      reflect.(*funcTypeFixed16).NumField
//      reflect.(*funcTypeFixed32).NumField
//      reflect.(*funcTypeFixed4).NumField
//      reflect.(*funcTypeFixed64).NumField
//      reflect.(*funcTypeFixed8).NumField
//      reflect.(*interfaceType).NumField
//      reflect.(*ptrType).NumField
//      reflect.(*sliceType).NumField
void reflect.(*rtype).NumField(struct Eq_2 * gs, struct Eq_113346 * dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (((word32) dwArg04->b000F & 0x1F) == 0x19)
		return;
	runtime.gopanic(gs);
}

// 080A6AC0: void reflect.(*rtype).NumIn(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      reflect.haveIdenticalUnderlyingType
//      reflect.(*structType).NumIn
//      reflect.(*funcType).NumIn
//      reflect.(*funcTypeFixed128).NumIn
//      reflect.(*funcTypeFixed16).NumIn
//      reflect.(*funcTypeFixed32).NumIn
//      reflect.(*funcTypeFixed4).NumIn
//      reflect.(*funcTypeFixed64).NumIn
//      reflect.(*funcTypeFixed8).NumIn
//      reflect.(*interfaceType).NumIn
//      reflect.(*ptrType).NumIn
//      reflect.(*sliceType).NumIn
void reflect.(*rtype).NumIn(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (((word32) *((word32) dwArg04 + 0x0F) & 0x1F) == 0x13)
		return;
	runtime.gopanic(gs);
}

// 080A6B20: void reflect.(*rtype).NumOut(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      reflect.haveIdenticalUnderlyingType
//      reflect.(*structType).NumOut
//      reflect.(*funcType).NumOut
//      reflect.(*funcTypeFixed128).NumOut
//      reflect.(*funcTypeFixed16).NumOut
//      reflect.(*funcTypeFixed32).NumOut
//      reflect.(*funcTypeFixed4).NumOut
//      reflect.(*funcTypeFixed64).NumOut
//      reflect.(*funcTypeFixed8).NumOut
//      reflect.(*interfaceType).NumOut
//      reflect.(*ptrType).NumOut
//      reflect.(*sliceType).NumOut
void reflect.(*rtype).NumOut(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (((word32) *((word32) dwArg04 + 0x0F) & 0x1F) != 0x13)
		runtime.gopanic(gs);
	else
	{
		(*((word32) dwArg04 + 0x0C) & 0x01) == 0x00;
		word32 eax_54 = (word32) *((word32) dwArg04 + 32);
		up32 eax_59 = (word32) ((word16) eax_54 + (*((word32) dwArg04 + 0x0022) & 0x7FFF));
		if ((word32) (word16) eax_54 <= eax_59 && eax_59 <= 0x00100000)
			return;
		runtime.panicslice(gs);
	}
}

// 080A6BC0: void reflect.(*rtype).Out(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
// Called from:
//      reflect.haveIdenticalUnderlyingType
//      reflect.(*structType).Out
//      reflect.(*funcType).Out
//      reflect.(*funcTypeFixed128).Out
//      reflect.(*funcTypeFixed16).Out
//      reflect.(*funcTypeFixed32).Out
//      reflect.(*funcTypeFixed4).Out
//      reflect.(*funcTypeFixed64).Out
//      reflect.(*funcTypeFixed8).Out
//      reflect.(*interfaceType).Out
//      reflect.(*ptrType).Out
//      reflect.(*sliceType).Out
void reflect.(*rtype).Out(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (((word32) *((word32) dwArg04 + 0x0F) & 0x1F) != 0x13)
		runtime.gopanic(gs);
	else
	{
		word32 ecx_43;
		if ((*((word32) dwArg04 + 0x0C) & 0x01) != 0x00)
			ecx_43 = 0x34;
		else
			ecx_43 = 0x24;
		word32 eax_54 = (word32) *((word32) dwArg04 + 32);
		word32 ecx_48 = (word32) dwArg04 + ecx_43;
		uint32 ebx_56 = (word32) (word16) eax_54;
		uint32 eax_59 = (word32) ((word16) eax_54 + (*((word32) dwArg04 + 0x0022) & 0x7FFF));
		if (ebx_56 > eax_59 || eax_59 > 0x00100000)
			runtime.panicslice(gs);
		else
		{
			word32 ecx_73[] = ecx_48 + (ebx_56 << 0x02 & -(-(ebx_56 + 0xFFF00000)) >> 0x1F);
			if (dwArg08 < eax_59 - ebx_56)
				return;
			runtime.panicindex(gs);
		}
	}
}

// 080A6CA0: void reflect.ChanDir.String(Register (ptr32 ptr32) ebx, Register word32 ebp, Register (ptr32 Eq_23322) esi, Register (ptr32 Eq_2) gs, Stack Eq_99008 dwArg04)
// Called from:
//      reflect.(*ChanDir).String
void reflect.ChanDir.String(ptr32 * ebx, word32 ebp, struct Eq_23322 * esi, struct Eq_2 * gs, Eq_99008 dwArg04)
{
	ui24 ebx_24_8 = SLICE(ebx, word24, 8);
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (dwArg04 == 0x01)
		return;
	if (dwArg04 == 0x02)
		return;
	if (dwArg04 == 0x03)
		return;
	strconv.Itoa(ebx_24_8, ebp, esi, gs, dwArg04);
	runtime.concatstring2(gs, 0x00);
}

// 080A6D70: void reflect.(*interfaceType).Method(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg00, Stack Eq_4 dwArg04)
// Called from:
//      reflect.(*rtype).Method
//      reflect.(*interfaceType).MethodByName
void reflect.(*interfaceType).Method(struct Eq_2 * gs, Eq_4 dwArg00, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	fn0808FD86(0x00, (word32) fp + 0x0C);
	if (dwArg04 < 0x00)
		return;
	Eq_4 ebx_32 = *((word32) dwArg00 + 36);
	if (dwArg04 >= *((word32) dwArg00 + 40))
		return;
	reflect.(*rtype).nameOff(gs, dwArg00, *((word32) ebx_32 + dwArg04 * 0x08));
	if ((*dwLoc1C & 0x01) == 0x00)
	{
		reflect.name.pkgPath(gs, dwLoc1C);
		if (dwLoc1C == 0x00)
			*((word32) dwArg00 + 32) == 0x00;
	}
	reflect.(*rtype).typeOff(gs);
}

// 080A6EE0: void reflect.(*interfaceType).NumMethod(Register (ptr32 Eq_113610) gs)
void reflect.(*interfaceType).NumMethod(struct Eq_113610 * gs)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
}

// 080A6F10: void reflect.(*interfaceType).MethodByName(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg00, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
// Called from:
//      reflect.(*sliceType).MethodByName
void reflect.(*interfaceType).MethodByName(struct Eq_2 * gs, Eq_4 dwArg00, Eq_4 dwArg04, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	fn0808FD86(0x00, (word32) fp + 16);
	if (dwArg00 == 0x00)
		return;
	Eq_4 eax_33 = *((word32) dwArg00 + 40);
	Eq_4 edx_165 = 0x00;
	while (edx_165 < eax_33)
	{
		Eq_4 ebp_49 = *((word32) dwArg00 + 36);
		if (edx_165 >= *((word32) dwArg00 + 40))
			runtime.panicindex(gs);
		reflect.(*rtype).nameOff(gs, dwArg00, *((word32) ebp_49 + edx_165 * 0x08));
		Eq_4 dwLoc34_180 = 0x00;
		Eq_4 dwLoc30_181 = 0x00;
		if (dwLoc64 != 0x00)
		{
			dwLoc34_180 = (word32) dwLoc64 + 3;
			dwLoc30_181 = (word32) *((word32) dwLoc64 + 1) << 0x08 | (word32) (*((word32) dwLoc64 + 2));
		}
		if (dwLoc30_181 == dwArg08)
		{
			word32 edi_322;
			word32 ebx_320;
			word32 esi_321;
			runtime.eqstring(dwArg08, dwLoc34_180, dwLoc30_181, dwArg04, out ebx_320, out esi_321, out edi_322);
			dwLoc64 = dwArg04;
			if (bLoc5C != 0x00)
			{
				reflect.(*interfaceType).Method(gs, dwLoc70, dwArg00);
				fn0809023C(fp - 88, fp - 0x20);
				fn0809023C(fp - 0x24, (word32) fp + 20);
				return;
			}
		}
		edx_165 = (word32) edx_165 + 1;
	}
}

// 080A7060: void reflect.(*structType).Field(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg00, Stack Eq_4 dwArg04)
// Called from:
//      reflect.(*structType).FieldByNameFunc
//      reflect.(*structType).FieldByName
//      reflect.(*sliceType).Field
void reflect.(*structType).Field(struct Eq_2 * gs, Eq_4 dwArg00, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	fn0808FD83(0x00, (word32) fp + 0x0C);
	if (dwArg04 >= 0x00)
	{
		Eq_4 ebx_32 = *((word32) dwArg00 + 36);
		if (dwArg04 < *((word32) dwArg00 + 40))
		{
			*((word32) ebx_32 + (dwArg04 * 0x0C + 4)) == 0x00;
			*((word32) ebx_32 + dwArg04 * 0x0C) == 0x00;
			Eq_4 ebp_115 = *((word32) ebx_32 + dwArg04 * 0x0C);
			if ((*ebp_115 & 0x01) == 0x00)
			{
				reflect.name.pkgPath(gs, ebp_115);
				if (dwLoc20 == 0x00)
					*((word32) dwArg00 + 32) == 0x00;
			}
			reflect.name.tag(gs, *((word32) ebx_32 + dwArg04 * 0x0C));
			runtime.newobject(gs, 0x080CBC60);
			*dwLoc24 = (union Eq_4 *) dwArg04;
			return;
		}
	}
	runtime.gopanic(gs);
}

// 080A7240: void reflect.(*structType).FieldByIndex(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg00, Stack Eq_4 dwArg04, Stack Eq_4 dwArg0C, Stack Eq_4 dwArg28)
// Called from:
//      reflect.(*sliceType).FieldByIndex
void reflect.(*structType).FieldByIndex(struct Eq_2 * gs, Eq_4 dwArg00, Eq_4 dwArg04, Eq_4 dwArg0C, Eq_4 dwArg28)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	fn0808FD83(0x00, (word32) fp + 20);
	Eq_4 ecx_23 = dwArg00;
	if (dwArg00 == 0x00)
		ecx_23.u0 = 0x00;
	Eq_4 dwArg24_150 = ecx_23;
	Eq_4 ecx_141 = 0x00;
	Eq_4 edx_139 = dwArg04;
	while (ecx_141 < dwArg0C)
	{
		Eq_4 ebp_56 = *edx_139;
		if (ecx_141 > 0x00)
		{
			Eq_4 eax_102;
			Eq_4 ecx_101;
			(*((word32) dwArg24_150 + 84))();
			dwLoc18 = ebp_56;
			dwLoc0C = dwArg28;
			if (dwLoc50 != 22)
			{
l080A7302:
				eax_102 = dwArg28;
				ecx_101 = dwArg24_150;
				goto l080A730A;
			}
			(*((word32) dwArg24_150 + 44))();
			Eq_4 eax_84 = *((word32) dwLoc50 + 84);
			eax_84();
			if (dwLoc50 != 0x19)
				goto l080A7302;
			Eq_4 eax_94 = *((word32) dwArg24_150 + 44);
			eax_94();
			ecx_101 = dwLoc50;
			eax_102 = dwLoc4C;
l080A730A:
			dwArg24_150 = ecx_101;
			dwArg28 = eax_102;
		}
		<anonymous> * eax_116 = *((word32) dwArg24_150 + 48);
		eax_116();
		fn0809021E(dwLoc04, (word32) fp + 20);
		dwLoc50 = ebp_56;
		edx_139 = (word32) dwLoc0C + 4;
		ecx_141 = (word32) dwLoc18 + 1;
	}
}

// 080A7380: void reflect.(*structType).FieldByNameFunc(Register word24 ebx_24_8, Register Eq_4 esi, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg00, Stack Eq_4 dwArg0C)
// Called from:
//      reflect.(*structType).FieldByName
//      reflect.(*sliceType).FieldByNameFunc
void reflect.(*structType).FieldByNameFunc(word24 ebx_24_8, Eq_4 esi, struct Eq_2 * gs, Eq_4 dwArg00, Eq_4 dwArg0C)
{
	while (fp - 0x80 <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	word32 edi_1596;
	runtime.makemap(ebx_24_8, esi, fn0808FD83(0x00, fp + 0x0C), gs, 0x080CF980, 0x00, 0x00, 0x00, 0x00, out edi_1596);
	struct Eq_113887 * esp_102 = fp - 0x0104;
	Eq_4 dwLocF8_1022 = 0x00;
	Eq_4 dwLocF4_1023 = 0x00;
	Eq_4 eax_121 = fp - 0x14;
	Eq_4 ebp_124 = 0x01;
	Eq_4 esi_120 = fp - 200;
	Eq_4 edi_123 = 0x00;
	Eq_4 ebx_105 = 0x01;
	Eq_4 ecx_101 = dwLocF0;
	while (ebx_105 > 0x00)
	{
		esp_102->t00E0 = eax_121;
		esp_102->t0044 = ebx_105;
		esp_102->t0048 = ebp_124;
		esp_102->t0080 = eax_121;
		esp_102->t0074.u0 = 0x00;
		esp_102->t0078 = esp_102->t0080;
		esp_102->t00AC.u0 = 0x00;
		esp_102->t0098 = ecx_101;
		esp_102->t0070.u0 = 0x00;
		Eq_4 eax_100 = esp_102->t0080;
		ecx_101 = esp_102->t0098;
		while (esp_102->t0074 < ebx_105)
		{
			Eq_4 edx_212;
			Eq_4 ebx_215;
			Eq_4 ebp_217;
			Eq_4 ecx_210;
			byte al_974;
			esp_102->t006C = edi_123;
			esp_102->t00DC = esi_120;
			esp_102->t00D8 = eax_100;
			esp_102->t0040 = *((word32) eax_100 + 8);
			esp_102->dw00A8 = (word32) *((word32) eax_100 + 4);
			Eq_4 ebp_138 = *eax_100;
			esp_102->t00A4 = ebp_138;
			esp_102->t0000.u0 = 0x080CF980;
			esp_102->t0004 = ecx_101;
			esp_102->t0008 = ebp_138;
			word32 esi_1597;
			word32 edi_1598;
			runtime.mapaccess1_fast32(gs, esp_102->t0000, esp_102->t0004, esp_102->t0008, out esi_1597, out edi_1598);
			if (*esp_102->ptr000C != 0x00)
			{
				al_974 = esp_102->b003F;
				ecx_210 = esp_102->t00AC;
				edx_212 = esp_102->t00DC;
				ebx_215 = esp_102->t0070;
				ebp_217 = esp_102->t006C;
			}
			else
			{
				esp_102->t0000.u0 = 0x080CF980;
				esp_102->t0004 = esp_102->t00A0;
				esp_102->t0008 = esp_102->t00A4;
				runtime.mapassign_fast32(gs, esp_102->t0000, esp_102->t0004, esp_102->t0008);
				*esp_102->ptr000C = 0x01;
				Eq_4 eax_193 = esp_102->t00A4;
				Eq_4 ecx_194 = *((word32) eax_193 + 40);
				esp_102->t0068 = ecx_194;
				Eq_4 edx_196 = 0x00;
				word32 ebx_199 = (word32) esp_102->b003F;
				Eq_4 ebp_200 = esp_102->t00AC;
				Eq_4 esi_201 = esp_102->t00DC;
				Eq_4 edi_202 = esp_102->t006C;
				while (true)
				{
					byte bLocF4_1296 = (byte) dwLocF4_1023;
					esp_102 = fp - 252;
					byte bl_248 = (byte) ebx_199;
					if (edx_196 >= ecx_194)
						break;
					Eq_4 eax_220 = *((word32) eax_193 + 36);
					if (edx_196 >= *((word32) eax_193 + 40))
						runtime.panicindex(gs);
					ui32 ecx_226 = edx_196 * 0x03;
					struct Eq_114170 * ebp_227 = *((word32) eax_220 + ecx_226 * 0x04);
					Eq_4 dwLoc10_1273 = 0x00;
					if (ebp_227 != null)
						dwLoc10_1273 = (word32) ebp_227->b0001 << 0x08 | (word32) ebp_227->b0002;
					Eq_4 eax_258;
					if ((*((word32) eax_220 + (ecx_226 * 0x04 + 8)) & 0x01) != 0x00)
					{
						eax_258 = *((word32) eax_220 + (ecx_226 * 0x04 + 4));
						if (((word32) *((byte) eax_258.u0 + 0x0F) & 0x1F) == 22)
						{
							reflect.(*rtype).Elem(gs, eax_258);
							Eq_4 ecx_279 = *((word32) dwLocF8_1022 + 0x0088);
							ecx_279();
							eax_258 = dwLocF8_1022;
						}
					}
					else
						eax_258.u0 = 0x00;
					word32 eax_516;
					Eq_4 ebx_519;
					Eq_4 ecx_517;
					Eq_4 edx_518;
					Eq_4 ebp_520;
					(*dwArg0C)();
					dwLocF8_1022 = dwLoc10_1273;
					if (bLocF4_1296 == 0x00)
					{
						eax_516 = (word32) bl_248;
						if ((byte) eax_516 != 0x00 || (eax_258 == 0x00 || ((word32) (*((byte) eax_258.u0 + 0x0F)) & 0x1F) != 0x19))
						{
							ecx_517 = ebp_200;
							edx_518 = dwLoc8C;
							ebx_519 = esi_201;
							ebp_520 = edi_202;
						}
						else
						{
							Eq_4 edi_544;
							Eq_4 esi_545;
							word24 ebx_24_8_599 = SLICE(runtime.mapaccess1_fast32(gs, 0x080CF9C0, ebp_200, eax_258, out esi_545, out edi_544), word24, 8);
							if (*dwLocF0 <= 0x00)
							{
								Eq_4 eax_589 = ebp_200;
								if (ebp_200 == 0x00)
								{
									word32 edi_1601;
									runtime.makemap(ebx_24_8_599, esi_545, edi_544, gs, 0x080CF9C0, 0x00, 0x00, 0x00, 0x00, out edi_1601);
									eax_589 = dwLocE8;
								}
								runtime.mapassign_fast32(gs, 0x080CF9C0, eax_589, eax_258);
								*dwLocF0 = 0x01;
								word32 esi_1602;
								word32 edi_1603;
								runtime.mapaccess1_fast32(gs, 0x080CF9C0, dwLoc40, dwLoc58, out esi_1602, out edi_1603);
								if (*dwLocF0 > 0x01)
								{
									runtime.mapassign_fast32(gs, 0x080CF9C0, eax_589, eax_258);
									*dwLocF0 = 0x02;
								}
								Eq_4 edx_734;
								Eq_4 ecx_735;
								if (dwLocBC <= 0x00)
								{
									ecx_735.u0 = 0x00;
									edx_734.u0 = 0x00;
								}
								else
								{
									word128 xmm1_1606;
									word128 xmm0_1605;
									word32 esi_1604;
									runtime.growslice(gs, 0x080CEB60, 0x00, 0x00, 0x00, dwLocBC, out esi_1604, out xmm0_1605, out xmm1_1606);
									edx_734 = dwLocE8;
									ecx_735 = dwLocE0;
								}
								if (dwLocBC > ecx_735)
									runtime.panicslice(gs);
								Eq_4 ebx_808;
								word32 esi_1608;
								word32 edi_1609;
								word32 ebp_1607;
								word128 xmm0_1610;
								word128 xmm1_1611;
								word128 xmm2_1612;
								runtime.memmove(edx_734, dwLoc54, dwLocBC << 0x02, out ebp_1607, out esi_1608, out edi_1609, out xmm0_1610, out xmm1_1611, out xmm2_1612);
								dwLocF8_1022 = dwLoc54;
								dwLocF4_1023 = dwLocBC << 0x02;
								word32 ecx_777 = dwLocBC + 0x01;
								Eq_4 edx_778 = ecx_735;
								if (dwLocBC + 0x01 <= ecx_735)
									ebx_808 = edx_734;
								else
								{
									word128 xmm0_1614;
									word128 xmm1_1615;
									word32 esi_1613;
									runtime.growslice(gs, 0x080CEB60, edx_734, dwLocBC, ecx_735, dwLocBC + 0x01, out esi_1613, out xmm0_1614, out xmm1_1615);
									dwLocF8_1022 = edx_734;
									dwLocF4_1023 = dwLocBC;
									ebx_808 = dwLocE8;
									edx_778 = dwLocE0;
									ecx_777 = dwLocE4 + 0x01;
								}
								Eq_4 dwLoc4C_1417;
								Eq_4 eax_866;
								*((word32) ebx_808 + dwLocBC * 0x04) = edx_196;
								Eq_4 edi_821 = (word32) dwLoc8C + 1;
								if ((word32) dwLoc8C + 1 <= edi_202)
								{
									dwLoc4C_1417 = esi_201;
									eax_866 = edi_202;
								}
								else
								{
									word128 xmm1_1618;
									word128 xmm0_1617;
									word32 esi_1616;
									runtime.growslice(gs, 0x080D3200, esi_201, dwLoc8C, edi_202, (word32) dwLoc8C + 1, out esi_1616, out xmm0_1617, out xmm1_1618);
									dwLocF8_1022 = esi_201;
									dwLocF4_1023 = dwLoc8C;
									edi_821 = dwLocE4 + 0x01;
									dwLoc4C_1417 = dwLocE8;
									eax_866 = dwLocE0;
								}
								*((word32) dwLoc4C_1417 + (dwLoc8C * 0x10 + 8)) = ecx_777;
								*((word32) dwLoc4C_1417 + (dwLoc8C * 0x10 + 0x0C)) = edx_778;
								int32 esi_873 = dwLoc8C << 0x04;
								Eq_4 eax_884 = (word32) dwLoc4C_1417 + esi_873;
								Eq_4 eax_886 = (word32) dwLoc4C_1417 + 4 + esi_873;
								if (g_t81576F0 == 0x00)
								{
									*((word32) dwLoc4C_1417 + dwLoc8C * 0x10) = eax_258;
									*((word32) dwLoc4C_1417 + (dwLoc8C * 0x10 + 4)) = ebx_808;
								}
								else
								{
									runtime.writebarrierptr(eax_884, eax_258);
									runtime.writebarrierptr(eax_886, ebx_808);
									dwLoc8C = eax_866;
									dwLocF8_1022 = ebx_808;
								}
								eax_516 = (word32) bl_248;
								ecx_517 = eax_589;
								ebx_519 = dwLoc4C_1417;
								ebp_520 = eax_866;
								edx_518 = edi_821;
							}
							else
							{
								runtime.mapassign_fast32(gs, 0x080CF9C0, ebp_200, eax_258);
								*dwLocF0 = 0x02;
								dwLocF8_1022 = ebp_200;
								dwLocF4_1023 = eax_258;
								eax_516 = (word32) bl_248;
								ecx_517 = ebp_200;
								edx_518 = dwLoc8C;
								ebx_519 = esi_201;
								ebp_520 = edi_202;
							}
						}
					}
					else
					{
						word32 esi_1599;
						word32 edi_1600;
						runtime.mapaccess1_fast32(gs, 0x080CF9C0, dwLoc40, dwLoc58, out esi_1599, out edi_1600);
						dwLocF4_1023 = dwLoc58;
						if (*dwLocF0 > 0x01 || bl_248 != 0x00)
						{
							fn0809021E(0x080F2040, fp + 0x10);
							return;
						}
						Eq_4 edx_425;
						Eq_4 ecx_426;
						reflect.(*structType).Field(gs, 0x00, dwLoc58);
						Eq_4 esp_367 = <invalid>;
						fn0809021E(*((word32) esp_367 + 228), (word32) esp_367 + 268);
						((word32) esp_367 + 300)->u0 = 0x00;
						((word32) esp_367 + 304)->u0 = 0x00;
						((word32) esp_367 + 308)->u0 = 0x00;
						dwLocF8_1022 = edx_196;
						esp_102 = (word32) esp_367 - 4;
						Eq_4 eax_394 = *((word32) esp_367 + 60);
						if (eax_394 <= 0x00)
						{
							ecx_426.u0 = 0x00;
							edx_425.u0 = 0x00;
						}
						else
						{
							((word32) esp_367 - 4)->u0 = 0x080CEB60;
							esp_367->u0 = 0x00;
							((word32) esp_367 + 4)->u0 = 0x00;
							((word32) esp_367 + 8)->u0 = 0x00;
							*((word32) esp_367 + 0x0C) = eax_394;
							word128 xmm0_1620;
							word128 xmm1_1621;
							word32 esi_1619;
							runtime.growslice(gs, *((word32) esp_367 - 4), *esp_367, *((word32) esp_367 + 4), *((word32) esp_367 + 8), *((word32) esp_367 + 0x0C), out esi_1619, out xmm0_1620, out xmm1_1621);
							edx_425 = *((word32) esp_367 + 16);
							ecx_426 = *((word32) esp_367 + 24);
							eax_394 = *((word32) esp_367 + 60);
						}
						if (eax_394 > ecx_426)
							runtime.panicslice(gs);
						*((word32) esp_367 + 92) = ecx_426;
						*((word32) esp_367 + 0x00C4) = edx_425;
						*((word32) esp_367 - 4) = edx_425;
						*esp_367 = *((word32) esp_367 + 0x00A4);
						*((word32) esp_367 + 4) = eax_394 << 0x02;
						word32 ebp_1622;
						word128 xmm2_1627;
						word128 xmm0_1625;
						word128 xmm1_1626;
						word32 esi_1623;
						word32 edi_1624;
						runtime.memmove(*((word32) esp_367 - 4), *esp_367, *((word32) esp_367 + 4), out ebp_1622, out esi_1623, out edi_1624, out xmm0_1625, out xmm1_1626, out xmm2_1627);
						Eq_4 eax_467 = *((word32) esp_367 + 0x00C4);
						*((word32) esp_367 + 300) = eax_467;
						Eq_4 ecx_469 = *((word32) esp_367 + 60);
						*((word32) esp_367 + 304) = ecx_469;
						Eq_4 edx_471 = *((word32) esp_367 + 92);
						*((word32) esp_367 + 308) = edx_471;
						if ((word32) ecx_469 + 1 > edx_471)
						{
							((word32) esp_367 - 4)->u0 = 0x080CEB60;
							*esp_367 = eax_467;
							*((word32) esp_367 + 4) = ecx_469;
							*((word32) esp_367 + 8) = edx_471;
							*((word32) esp_367 + 0x0C) = (word32) ecx_469 + 1;
							word128 xmm0_1629;
							word128 xmm1_1630;
							word32 esi_1628;
							runtime.growslice(gs, *((word32) esp_367 - 4), *esp_367, *((word32) esp_367 + 4), *((word32) esp_367 + 8), *((word32) esp_367 + 0x0C), out esi_1628, out xmm0_1629, out xmm1_1630);
							eax_467 = *((word32) esp_367 + 16);
							ecx_469 = *((word32) esp_367 + 20);
							*((word32) esp_367 + 308) = *((word32) esp_367 + 24);
							*((word32) esp_367 + 300) = eax_467;
						}
						*((word32) esp_367 + 304) = (word32) ecx_469 + 1;
						*((word32) eax_467 + ecx_469 * 0x04) = *((word32) esp_367 + 80);
						eax_516 = 0x01;
						ecx_517 = *((word32) esp_367 + 0x00CC);
						edx_518 = *((word32) esp_367 + 0x006C);
						ebx_519 = *((word32) esp_367 + 0x00D0);
						ebp_520 = *((word32) esp_367 + 96);
					}
					word32 esi_943 = esp_102->dw0054;
					esp_102->t0070 = edx_518;
					edi_202 = ebp_520;
					edx_196 = esi_943 + 0x01;
					ebp_200 = ecx_517;
					esi_201 = ebx_519;
					ecx_194 = esp_102->t0068;
					ebx_199 = eax_516;
					eax_193 = esp_102->t00A4;
				}
				al_974 = (byte) ebx_199;
				ecx_210 = ebp_200;
				edx_212 = esi_201;
				ebx_215 = dwLoc8C;
				ebp_217 = edi_202;
			}
			Eq_4 esi_967 = esp_102->t00D8;
			esp_102->t0074 = (word32) esp_102->t0074 + 1;
			esp_102->b003F = al_974;
			esp_102->t00AC = ecx_210;
			esp_102->t0070 = ebx_215;
			edi_123 = ebp_217;
			ecx_101 = esp_102->t00A0;
			ebx_105 = esp_102->t0044;
			eax_100 = (word32) esi_967 + 16;
			esi_120 = edx_212;
		}
		if (esp_102->b003F != 0x00)
			return;
		ebx_105 = esp_102->t0070;
		esi_120 = esp_102->t00E0;
		edi_123 = esp_102->t0048;
		esp_102->t00BC = esp_102->t00AC;
		eax_121 = esi_120;
		ebp_124 = edi_123;
	}
}

// 080A7CE0: void reflect.(*structType).FieldByName(Register Eq_4 esi, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg00, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
// Called from:
//      reflect.(*sliceType).FieldByName
void reflect.(*structType).FieldByName(Eq_4 esi, struct Eq_2 * gs, Eq_4 dwArg00, Eq_4 dwArg04, Eq_4 dwArg08)
{
	while (fp - 0x88 <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	ui32 edi_266;
	fn0808FD83(0x00, &fp->dw0010);
	Eq_4 eax_22 = 0x00;
	Eq_4 edx_263 = dwArg08;
	if (dwArg08 != 0x00)
	{
		Eq_4 ebp_38 = *((word32) dwArg00 + 40);
		esi.u0 = 0x00;
		edi_266 = 0x00;
		while (esi < ebp_38)
		{
			Eq_4 ebx_151 = *((word32) dwArg00 + 36);
			if (esi >= *((word32) dwArg00 + 40))
				runtime.panicindex(gs);
			ui32 ecx_154 = esi * 0x03;
			struct Eq_114740 * ebp_156 = *((word32) ebx_151 + ecx_154 * 0x04);
			Eq_4 dwLocB4_331 = 0x00;
			Eq_4 dwLocB0_332 = 0x00;
			if (ebp_156 != null)
			{
				dwLocB4_331 = &ebp_156->b0002 + 1;
				dwLocB0_332 = (word32) ebp_156->b0001 << 0x08 | (word32) ebp_156->b0002;
			}
			if (dwLocB0_332 == edx_263)
			{
				word32 edi_495;
				word32 ebx_493;
				word32 esi_494;
				runtime.eqstring(edx_263, dwLocB4_331, dwLocB0_332, dwArg04, out ebx_493, out esi_494, out edi_495);
				dwLocBC = ebx_151;
				byte al_187 = (byte) edi_266;
				dwLoc0108 = dwLocB0_332;
				if (bLocFC != 0x00)
				{
					reflect.(*structType).Field(gs, dwLoc0110, dwArg00);
					fn0809021E(0x00, fp - 44);
					fn0809021E(fp - 0x30, &fp->dw0010 + 1);
					return;
				}
				eax_22.u0 = 0x00;
				edx_263 = dwArg08;
				edi_266 = (word32) al_187;
			}
			Eq_4 ecx_273 = *((word32) ebx_151 + (ecx_154 * 0x04 + 8));
			esi = (byte) esi.u0 + 1;
			edi_266 |= SEQ(SLICE(ecx_273, word24, 8), (int8) ((ecx_273 & 0x01) != 0x00));
		}
	}
	else
		edi_266 = 0x00;
	word24 ebx_24_8_83 = SLICE(dwArg00, word24, 8);
	if ((byte) edi_266 == 0x00)
		return;
	fn0808FD83(eax_22, fp - 0xA0);
	reflect.(*structType).FieldByNameFunc(ebx_24_8_83, esi, gs, dwLoc0114, dwLoc0108);
	fn0809021E(dwLocBC, fp - 0xA4);
	fn0809021E(fp - 0xA8, fp - 116);
	fn0809021E(fp - 0x78, fp);
}

// 080A7F20: void reflect.TypeOf(Register (ptr32 Eq_2) gs, Stack ptr32 dwArg04)
// Called from:
//      reflect.init
void reflect.TypeOf(struct Eq_2 * gs, ptr32 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
}

// 080A7F60: void reflect.(*rtype).ptrTo(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      reflect.New
void reflect.(*rtype).ptrTo(struct Eq_2 * gs, Eq_4 dwArg04)
{
	byte bLoc48 = (byte) dwLoc48;
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (*((word32) dwArg04 + 28) != 0x00)
		reflect.(*rtype).typeOff(gs);
	else
	{
		sync.(*Map).Load(gs, 0x08145240, 0x080DDF40, dwArg04);
		if (bLoc48 != 0x00)
		{
			if (dwLoc50 == 0x080DDCA0)
				return;
			runtime.panicdottypeE(gs, dwLoc50);
		}
		else
		{
			reflect.(*rtype).String(gs, dwArg04);
			runtime.concatstring2(gs, fp - 0x34);
			reflect.typesByString(gs, dwLoc48, dwLoc44);
			word32 * ecx_135 = (word32 *) 0x01;
			Eq_114896 ebx_137 = 0x00;
			while (ebx_137 < 0x080DDF40)
			{
				Eq_4 ebp_353 = *ecx_135;
				if (*((word32) ebp_353 + 32) == dwArg04)
				{
					word128 xmm1_569;
					sync.(*Map).LoadOrStore(gs, 0x08145240, 0x080DDCA0, ebp_353, out xmm1_569);
					if (dwLoc48 != 0x080DDCA0)
						runtime.panicdottypeE(gs, dwLoc48);
					else
						return;
				}
				++ecx_135;
				ebx_137 = (word32) ebx_137.u0 + 1;
			}
			runtime.newobject(gs, 0x080D3560);
			if (g_t81576F0 == 0x00)
				fn08090246(&g_dw80C8F40, dwLoc44);
			else
			{
				word32 edi_571;
				word128 xmm0_572;
				word128 xmm1_573;
				word32 esi_570;
				runtime.typedmemmove(0x080D3560, dwLoc44, 0x080C8F40, out esi_570, out edi_571, out xmm0_572, out xmm1_573);
			}
			Eq_4 edi_220;
			Eq_4 esi_222;
			reflect.resolveReflectName(SLICE(reflect.newName(gs, dwLoc48, dwLoc44, 0x00, 0x00, 0x00, 0x00, out esi_222, out edi_220), word24, 8), esi_222, edi_220, gs, dwLoc40);
			*((word32) dwLoc44 + 24) = dwLoc44;
			((word32) dwLoc44 + 28)->u0 = 0x00;
			reflect.fnv1(gs, 0x01);
			((word32) dwLoc44 + 8)->u0 = 0x00;
			if (g_t81576F0 == 0x00)
				*((word32) dwLoc44 + 32) = dwArg04;
			else
				runtime.writebarrierptr((word32) dwLoc44 + 32, dwArg04);
			word128 xmm1_574;
			sync.(*Map).LoadOrStore(gs, 0x08145240, 0x080DDCA0, dwLoc44, out xmm1_574);
			runtime.panicdottypeE(gs, 0x00);
		}
	}
}

// 080A8270: void reflect.fnv1(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg0C)
// Called from:
//      reflect.(*rtype).ptrTo
//      reflect.FuncOf
void reflect.fnv1(struct Eq_2 * gs, Eq_4 dwArg0C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 ebx_19 = 0x00;
	while (ebx_19 < dwArg0C)
		ebx_19 = (word32) ebx_19 + 1;
}

// 080A82C0: void reflect.(*rtype).Implements(Register (ptr32 Eq_2) gs, Stack word32 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C)
// Called from:
//      reflect.(*structType).Implements
//      reflect.(*funcType).Implements
//      reflect.(*funcTypeFixed128).Implements
//      reflect.(*funcTypeFixed16).Implements
//      reflect.(*funcTypeFixed32).Implements
//      reflect.(*funcTypeFixed4).Implements
//      reflect.(*funcTypeFixed64).Implements
//      reflect.(*funcTypeFixed8).Implements
//      reflect.(*interfaceType).Implements
//      reflect.(*ptrType).Implements
//      reflect.(*sliceType).Implements
void reflect.(*rtype).Implements(struct Eq_2 * gs, word32 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (dwArg08 == 0x00)
		runtime.gopanic(gs);
	else
	{
		(*((word32) dwArg08 + 84))();
		if (dwLoc08 != 0x14)
			runtime.gopanic(gs);
		else if (dwArg08 != 0x08138A00)
			runtime.panicdottypeI(gs, dwArg08);
		else
			reflect.implements(gs, dwLoc10, dwArg0C);
	}
}

// 080A8390: void reflect.(*rtype).AssignableTo(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C)
// Called from:
//      reflect.(*structType).AssignableTo
//      reflect.(*funcType).AssignableTo
//      reflect.(*funcTypeFixed128).AssignableTo
//      reflect.(*funcTypeFixed16).AssignableTo
//      reflect.(*funcTypeFixed32).AssignableTo
//      reflect.(*funcTypeFixed4).AssignableTo
//      reflect.(*funcTypeFixed64).AssignableTo
//      reflect.(*funcTypeFixed8).AssignableTo
//      reflect.(*interfaceType).AssignableTo
//      reflect.(*ptrType).AssignableTo
//      reflect.(*sliceType).AssignableTo
void reflect.(*rtype).AssignableTo(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (dwArg08 == 0x00)
		runtime.gopanic(gs);
	else if (dwArg08 != 0x08138A00)
		runtime.panicdottypeI(gs, dwArg08);
	else
	{
		reflect.directlyAssignable(gs, dwArg0C, dwArg04);
		if (bLoc04 == 0x00)
			reflect.implements(gs, dwLoc10, dwArg0C);
	}
}

// 080A8450: void reflect.(*rtype).ConvertibleTo(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg08)
// Called from:
//      reflect.(*structType).ConvertibleTo
//      reflect.(*funcType).ConvertibleTo
//      reflect.(*funcTypeFixed128).ConvertibleTo
//      reflect.(*funcTypeFixed16).ConvertibleTo
//      reflect.(*funcTypeFixed32).ConvertibleTo
//      reflect.(*funcTypeFixed4).ConvertibleTo
//      reflect.(*funcTypeFixed64).ConvertibleTo
//      reflect.(*funcTypeFixed8).ConvertibleTo
//      reflect.(*interfaceType).ConvertibleTo
//      reflect.(*ptrType).ConvertibleTo
//      reflect.(*sliceType).ConvertibleTo
void reflect.(*rtype).ConvertibleTo(struct Eq_2 * gs, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (dwArg08 == 0x00)
		runtime.gopanic(gs);
	else if (dwArg08 != 0x08138A00)
		runtime.panicdottypeI(gs, dwArg08);
	else
	{
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_4 stackArg4 = <invalid>;
		Eq_4 stackArg8 = <invalid>;
		reflect.convertOp(gs, stackArg4, stackArg8);
	}
}

// 080A84E0: void reflect.(*rtype).Comparable(Register (ptr32 Eq_115122) gs, Stack (ptr32 Eq_115123) dwArg04)
// Called from:
//      reflect.(*structType).Comparable
//      reflect.(*funcType).Comparable
//      reflect.(*funcTypeFixed128).Comparable
//      reflect.(*funcTypeFixed16).Comparable
//      reflect.(*funcTypeFixed32).Comparable
//      reflect.(*funcTypeFixed4).Comparable
//      reflect.(*funcTypeFixed64).Comparable
//      reflect.(*funcTypeFixed8).Comparable
//      reflect.(*interfaceType).Comparable
//      reflect.(*ptrType).Comparable
//      reflect.(*sliceType).Comparable
void reflect.(*rtype).Comparable(struct Eq_115122 * gs, struct Eq_115123 * dwArg04)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	dwArg04->dw0010 == 0x00;
}

// 080A8520: void reflect.implements(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg00, Stack Eq_4 dwArg04)
// Called from:
//      reflect.Value.assignTo
//      reflect.convertOp
//      reflect.(*sliceType).Implements
//      reflect.(*sliceType).AssignableTo
void reflect.implements(struct Eq_2 * gs, Eq_4 dwArg00, Eq_4 dwArg04)
{
	while (fp - 0x20 <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	fn0808FD80(0x00, fp - 0x40);
	if (((word32) *((word32) dwArg00 + 0x0F) & 0x1F) != 0x14)
		return;
	if (*((word32) dwArg00 + 40) == 0x00)
		return;
	if (((word32) *((word32) dwArg04 + 0x0F) & 0x1F) != 0x14)
	{
		reflect.(*rtype).uncommon(gs, dwArg04);
		if (dwLocA0 == null)
			return;
		Eq_139048 ecx_61[] = dwLocA0 + dwLocA0->dw0008 / 0x0C;
		Eq_115255 edx_64 = (word32) dwLocA0->w0004;
		if (edx_64 > 0x00010000)
			runtime.panicslice(gs);
		else
		{
			Eq_115255 ebx_391 = 0x00;
			Eq_4 ebp_395 = 0x00;
			while (ebx_391 < (word32) dwLocA0->w0004)
			{
				Eq_4 eax_86 = *((word32) dwArg00 + 36);
				if (ebp_395 >= *((word32) dwArg00 + 40))
					runtime.panicindex(gs);
				reflect.(*rtype).nameOff(gs, dwArg00, *((word32) eax_86 + ebp_395 * 0x08));
				if (ebx_391 >= edx_64)
					runtime.panicindex(gs);
				reflect.(*rtype).nameOff(gs, dwArg04, ecx_61[ebx_391].t0000);
				Eq_4 dwLoc2C_755 = 0x00;
				Eq_4 dwLoc28_756 = 0x00;
				if (dwLoc9C != 0x00)
				{
					dwLoc2C_755 = (word32) dwLoc9C + 3;
					dwLoc28_756 = (word32) *((word32) dwLoc9C + 2) | (word32) (*((word32) dwLoc9C + 1)) << 0x08;
				}
				Eq_4 dwLoc14_759 = 0x00;
				Eq_4 dwLoc10_760 = 0x00;
				if (dwLoc9C != 0x00)
				{
					dwLoc14_759 = (word32) dwLoc9C + 3;
					dwLoc10_760 = (word32) *((word32) dwLoc9C + 2) | (word32) (*((word32) dwLoc9C + 1)) << 0x08;
				}
				Eq_4 eax_373;
				if (dwLoc10_760 != dwLoc28_756)
				{
l080A89AF:
					eax_373 = ebp_395;
					goto l080A8899;
				}
				word32 ebx_1319;
				word32 esi_1320;
				word32 edi_1321;
				runtime.eqstring(dwLoc10_760, dwLoc2C_755, dwLoc28_756, dwLoc14_759, out ebx_1319, out esi_1320, out edi_1321);
				dwLoc9C = dwLoc14_759;
				if (bLoc94 == 0x00)
					goto l080A89AF;
				reflect.(*rtype).typeOff(gs);
				Eq_4 edx_210 = *((word32) eax_86 + (ebp_395 * 0x08 + 4));
				reflect.(*rtype).typeOff(gs);
				if (dwLoc14_759 != dwLoc14_759)
					goto l080A89AF;
				if ((*dwLoc9C & 0x01) != 0x00)
				{
l080A8A31:
					eax_373 = (word32) ebp_395 + 1;
					if ((word32) ebp_395 + 1 >= *((word32) dwArg00 + 40))
						return;
					goto l080A8899;
				}
				Eq_4 ecx_257;
				Eq_4 edx_256;
				reflect.name.pkgPath(gs, dwLoc9C);
				if (dwLoc14_759 == 0x00)
				{
					struct Eq_115407 * ecx_259 = *((word32) dwArg00 + 32);
					Eq_4 dwLoc0C_795 = 0x00;
					Eq_4 dwLoc08_796 = 0x00;
					if (ecx_259 != null)
					{
						dwLoc0C_795 = &ecx_259->b0002 + 1;
						dwLoc08_796 = (word32) ecx_259->b0002 | (word32) ecx_259->b0001 << 0x08;
					}
					ecx_257 = dwLoc08_796;
					edx_256 = dwLoc0C_795;
				}
				else
				{
					edx_256 = edx_210;
					ecx_257 = dwLoc14_759;
				}
				reflect.name.pkgPath(gs, dwLoc9C);
				Eq_4 eax_306 = dwLoc14_759;
				Eq_4 ecx_307 = edx_210;
				if (dwLoc14_759 == 0x00)
				{
					reflect.(*rtype).nameOff(gs, dwArg04, dwLocA0->t0000);
					Eq_4 dwLoc24_819 = 0x00;
					Eq_4 dwLoc20_820 = 0x00;
					if (dwLoc14_759 != 0x00)
					{
						dwLoc24_819 = (word32) dwLoc14_759 + 3;
						dwLoc20_820 = (word32) *((word32) dwLoc14_759 + 2) | (word32) (*((word32) dwLoc14_759 + 1)) << 0x08;
					}
					eax_306 = dwLoc20_820;
					ecx_307 = dwLoc24_819;
				}
				if (eax_306 == ecx_257)
				{
					word32 esi_1326;
					word32 edi_1327;
					word32 ebx_1325;
					runtime.eqstring(ecx_257, edx_256, ecx_257, ecx_307, out ebx_1325, out esi_1326, out edi_1327);
					dwLoc9C = ecx_307;
					if (bLoc94 == 0x00)
						goto l080A8AE7;
					goto l080A8A31;
				}
l080A8AE7:
				eax_373 = ebp_395;
l080A8899:
				ebx_391 = (word32) ebx_391 + 1;
				ebp_395 = eax_373;
			}
		}
	}
	else
	{
		Eq_4 edx_397 = 0x00;
		Eq_4 ebx_398 = 0x00;
		while (edx_397 < *((word32) dwArg04 + 40))
		{
			Eq_4 ebp_412 = *((word32) dwArg00 + 36);
			if (ebx_398 >= *((word32) dwArg00 + 40))
				runtime.panicindex(gs);
			reflect.(*rtype).nameOff(gs, dwArg00, *((word32) ebp_412 + ebx_398 * 0x08));
			Eq_4 edx_436 = *((word32) dwArg04 + 36);
			if (edx_397 >= *((word32) dwArg04 + 40))
				runtime.panicindex(gs);
			reflect.(*rtype).nameOff(gs, dwArg04, *((word32) edx_436 + edx_397 * 0x08));
			Eq_4 dwLoc1C_898 = 0x00;
			Eq_4 dwLoc18_899 = 0x00;
			if (dwLoc9C != 0x00)
			{
				dwLoc1C_898 = (word32) dwLoc9C + 3;
				dwLoc18_899 = (word32) *((word32) dwLoc9C + 2) | (word32) (*((word32) dwLoc9C + 1)) << 0x08;
			}
			Eq_4 dwLoc44_902 = 0x00;
			Eq_4 dwLoc40_903 = 0x00;
			if (dwLoc9C != 0x00)
			{
				dwLoc44_902 = (word32) dwLoc9C + 3;
				dwLoc40_903 = (word32) *((word32) dwLoc9C + 2) | (word32) (*((word32) dwLoc9C + 1)) << 0x08;
			}
			Eq_4 eax_690;
			if (dwLoc40_903 != dwLoc18_899)
			{
l080A8694:
				eax_690 = ebx_398;
				goto l080A858A;
			}
			word32 edi_1324;
			word32 ebx_1322;
			word32 esi_1323;
			runtime.eqstring(dwLoc18_899, dwLoc1C_898, dwLoc18_899, dwLoc44_902, out ebx_1322, out esi_1323, out edi_1324);
			dwLoc9C = dwLoc44_902;
			if (bLoc94 == 0x00)
				goto l080A8694;
			reflect.(*rtype).typeOff(gs);
			Eq_4 edx_538 = *((word32) ebp_412 + (ebx_398 * 0x08 + 4));
			reflect.(*rtype).typeOff(gs);
			if (dwLoc44_902 != dwLoc44_902)
				goto l080A8694;
			if ((*dwLoc9C & 0x01) != 0x00)
			{
l080A8720:
				eax_690 = (word32) ebx_398 + 1;
				if ((word32) ebx_398 + 1 >= *((word32) dwArg00 + 40))
					return;
				goto l080A858A;
			}
			Eq_4 edx_584;
			reflect.name.pkgPath(gs, dwLoc9C);
			Eq_4 ecx_580 = edx_538;
			if (dwLoc44_902 == 0x00)
			{
				struct Eq_115407 * ecx_586 = *((word32) dwArg00 + 32);
				Eq_4 dwLoc3C_941 = 0x00;
				Eq_4 dwLoc38_942 = 0x00;
				if (ecx_586 != null)
				{
					dwLoc3C_941 = &ecx_586->b0002 + 1;
					dwLoc38_942 = (word32) ecx_586->b0002 | (word32) ecx_586->b0001 << 0x08;
				}
				ecx_580 = dwLoc3C_941;
				edx_584 = dwLoc38_942;
			}
			else
				edx_584 = dwLoc44_902;
			Eq_4 edx_638;
			reflect.name.pkgPath(gs, dwLoc9C);
			Eq_4 ecx_634 = edx_538;
			if (dwLoc44_902 == 0x00)
			{
				struct Eq_115527 * ecx_641 = *((word32) dwArg04 + 32);
				Eq_4 dwLoc34_958 = 0x00;
				Eq_4 dwLoc30_959 = 0x00;
				if (ecx_641 != null)
				{
					dwLoc34_958 = &ecx_641->b0002 + 1;
					dwLoc30_959 = (word32) ecx_641->b0002 | (word32) ecx_641->b0001 << 0x08;
				}
				ecx_634 = dwLoc34_958;
				edx_638 = dwLoc30_959;
			}
			else
				edx_638 = dwLoc44_902;
			if (edx_638 == edx_584)
			{
				word32 ebx_1328;
				word32 esi_1329;
				word32 edi_1330;
				runtime.eqstring(edx_638, ecx_580, edx_584, ecx_634, out ebx_1328, out esi_1329, out edi_1330);
				dwLoc9C = ecx_634;
				if (bLoc94 == 0x00)
					goto l080A8802;
				goto l080A8720;
			}
l080A8802:
			eax_690 = ebx_398;
l080A858A:
			edx_397 = (word32) edx_397 + 1;
			ebx_398 = eax_690;
		}
	}
}

// 080A8C00: void reflect.directlyAssignable(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
// Called from:
//      reflect.Value.assignTo
//      reflect.(*sliceType).AssignableTo
void reflect.directlyAssignable(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (dwArg04 == dwArg08)
		return;
	reflect.(*rtype).Name(gs, dwArg04);
	if (dwLoc08 != 0x00)
	{
		reflect.(*rtype).Name(gs, dwArg08);
		if (dwLoc08 != 0x00)
			return;
	}
	if (((word32) *((word32) dwArg04 + 0x0F) & 0x1F) != ((word32) (*((word32) dwArg08 + 0x0F)) & 0x1F))
		return;
	reflect.haveIdenticalUnderlyingType(gs, dwLoc14, dwArg04, (byte) dwArg08);
}

// 080A8CA0: void reflect.haveIdenticalType(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C, Stack Eq_4 dwArg10, Stack Eq_4 bArg14)
// Called from:
//      reflect.haveIdenticalUnderlyingType
void reflect.haveIdenticalType(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C, Eq_4 dwArg10, Eq_4 bArg14)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (bArg14 == 0x00)
	{
		(*((word32) dwArg04 + 100))();
		(*((word32) dwArg0C + 100))();
		if (dwLoc1C != dwLoc1C)
			return;
		word32 esi_251;
		word32 edi_252;
		word32 ebx_250;
		runtime.eqstring(dwLoc1C, dwLoc20, dwLoc1C, dwLoc20, out ebx_250, out esi_251, out edi_252);
		byte bLoc18_185 = (byte) dwLoc1C;
		if (bLoc14 == 0x00)
			return;
		(*((word32) dwArg04 + 84))();
		word32 edx_84;
		(*((word32) dwArg0C + 84))();
		if (dwLoc1C != dwLoc1C)
			return;
		Eq_4 eax_91 = *((word32) dwArg04 + 0x0088);
		eax_91();
		Eq_4 ecx_101 = *((word32) dwArg0C + 0x0088);
		ecx_101();
		// Failed to bind call argument.
		// Please report this issue at https://github.com/uxmal/reko
		Eq_4 stackArg0 = <invalid>;
		reflect.haveIdenticalUnderlyingType(gs, stackArg0, dwLoc1C, dwLoc1C);
	}
	else if (dwArg04 == dwArg0C)
		runtime.ifaceeq(gs, dwArg04, dwArg08, dwArg10);
}

// 080A8DF0: void reflect.haveIdenticalUnderlyingType(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg00, Stack Eq_4 dwArg04, Stack Eq_4 bArg08)
// Called from:
//      reflect.directlyAssignable
//      reflect.haveIdenticalType
//      reflect.FuncOf
//      reflect.convertOp
void reflect.haveIdenticalUnderlyingType(struct Eq_2 * gs, Eq_4 dwArg00, Eq_4 dwArg04, Eq_4 bArg08)
{
reflect.haveIdenticalUnderlyingType_entry:
l080A8DF0:
	branch fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8) l080A9613
l080A8E06:
	fn0808FD88(0x00, fp - 0x20)
	branch dwArg00 == dwArg04 l080A95FC
l080A8E24:
	ui32 edx_30 = (word32) *((word32) dwArg00 + 0x0F)
	branch (edx_30 & 0x1F) != ((word32) (*((word32) dwArg04 + 0x0F)) & 0x1F) l080A95F3
l080A8E3A:
	branch (edx_30 & 0x1F) <= 0x10 l080A95EA
l080A8E46:
	branch (edx_30 & 0x1F) == 0x18 l080A95EA
l080A8E4F:
	branch (edx_30 & 0x1F) == 0x1A l080A95EA
l080A8E58:
	branch (edx_30 & 0x1F) > 0x13 l080A916D
l080A8E61:
	branch (edx_30 & 0x1F) == 0x11 l080A90DF
l080A8E6A:
	branch (edx_30 & 0x1F) == 0x12 l080A8FCD
l080A8E73:
	branch (edx_30 & 0x1F) != 0x13 l080A8FC4
l080A8E7C:
	branch *((word32) dwArg00 + 0x0022) != *((word32) dwArg04 + 0x0022) || *((word32) dwArg00 + 32) != *((word32) dwArg04 + 32) l080A8FBB
	goto l080A8E9E
l080A8E8D:
l080A8E9E:
	Eq_4 edx_799 = 0x00
	goto l080A8EAD
l080A8EA2:
	edx_799 = (word32) edx_799 + 1
l080A8EAD:
	reflect.(*rtype).NumIn(gs, dwArg00)
	branch edx_799 >= dwLoc6C l080A8F28
l080A8EC5:
	reflect.(*rtype).In(gs, dwArg00, edx_799)
	reflect.(*rtype).In(gs, dwArg04, edx_799)
	reflect.haveIdenticalType(gs, dwLoc68, dwLoc64, dwLoc68, dwLoc64, bArg08)
	dwLoc6C = dwLoc64
	branch bLoc5C != 0x00 l080A8EA2
l080A8F1F:
	return
l080A8F28:
	Eq_4 eax_819 = 0x00
	goto l080A8F33
l080A8F2C:
	eax_819 = (word32) eax_819 + 1
l080A8F33:
	reflect.(*rtype).NumOut(gs, dwArg00)
	branch eax_819 >= dwLoc6C l080A8FB2
l080A8F4F:
	reflect.(*rtype).Out(gs, dwArg00, eax_819)
	reflect.(*rtype).Out(gs, dwArg04, eax_819)
	reflect.haveIdenticalType(gs, dwLoc68, dwLoc64, dwLoc68, dwLoc64, bArg08)
	dwLoc6C = dwLoc64
	branch bLoc5C != 0x00 l080A8F2C
l080A8FA9:
	return
l080A8FB2:
	return
l080A8FBB:
	return
l080A8FC4:
	return
l080A8FCD:
	reflect.(*rtype).ChanDir(gs, dwArg04)
	branch dwLoc6C == 0x03 l080A9074
l080A8FE2:
	reflect.(*rtype).ChanDir(gs, dwArg04)
	reflect.(*rtype).ChanDir(gs, dwArg00)
	branch dwLoc6C == dwLoc6C l080A9018
l080A9010:
	return
l080A9018:
	reflect.(*rtype).Elem(gs, dwArg00)
	reflect.(*rtype).Elem(gs, dwArg04)
	reflect.haveIdenticalType(gs, dwLoc6C, dwLoc68, dwLoc6C, dwLoc68, bArg08)
	goto l080A9010
l080A9074:
	reflect.(*rtype).Elem(gs, dwArg00)
	reflect.(*rtype).Elem(gs, dwArg04)
	reflect.haveIdenticalType(gs, dwLoc6C, dwLoc68, dwLoc6C, dwLoc68, bArg08)
	dwLoc6C = dwLoc68
	dwLoc68 = dwLoc6C
	branch bLoc5C == 0x00 l080A8FE2
l080A90D6:
	return
l080A90DF:
	reflect.(*rtype).Len(gs, dwArg00)
	reflect.(*rtype).Len(gs, dwArg04)
	branch dwLoc6C == dwLoc6C l080A9111
l080A9109:
	return
l080A9111:
	reflect.(*rtype).Elem(gs, dwArg00)
	reflect.(*rtype).Elem(gs, dwArg04)
	reflect.haveIdenticalType(gs, dwLoc6C, dwLoc68, dwLoc6C, dwLoc68, bArg08)
	goto l080A9109
l080A916D:
	branch (edx_30 & 0x1F) <= 0x15 l080A9505
l080A9176:
	branch (edx_30 & 0x1F) <= 0x17 l080A94A7
l080A9182:
	branch (edx_30 & 0x1F) != 0x19 l080A8FC4
l080A918B:
	Eq_4 edx_207 = *((word32) dwArg00 + 40)
	branch edx_207 != *((word32) dwArg04 + 40) l080A949E
l080A9199:
	Eq_4 ebx_215 = 0x00
	goto l080A91B4
l080A91A1:
	ebx_215 = (word32) ebx_215 + 1
l080A91B4:
	branch ebx_215 >= edx_207 l080A9495
l080A91BC:
	Eq_4 esi_229 = *((word32) dwArg00 + 36)
	branch ebx_215 >= *((word32) dwArg00 + 40) l080A960C
l080A91CA:
	ui32 ebp_233 = ebx_215 * 0x03
	Eq_4 ecx_236 = *((word32) dwArg04 + 36)
	branch ebx_215 >= *((word32) dwArg04 + 40) l080A9605
l080A91DB:
	Eq_4 edi_239 = *((word32) esi_229 + ebp_233 * 0x04)
	Eq_4 dwLoc1C_1001 = 0x00
	Eq_4 dwLoc18_1000 = 0x00
	branch edi_239 == 0x00 l080A920A
l080A91F2:
	dwLoc1C_1001 = (word32) edi_239 + 3
	dwLoc18_1000 = (word32) *((word32) edi_239 + 2) | (word32) (*((word32) edi_239 + 1)) << 0x08
l080A920A:
	Eq_4 eax_257 = *((word32) ecx_236 + ebp_233 * 0x04)
	Eq_4 dwLoc0C_1003 = 0x00
	Eq_4 dwLoc08_1004 = 0x00
	branch eax_257 == 0x00 l080A9239
l080A9221:
	dwLoc0C_1003 = (word32) eax_257 + 3
	dwLoc08_1004 = (word32) *((word32) eax_257 + 1) << 0x08 | (word32) (*((word32) eax_257 + 2))
l080A9239:
	branch dwLoc08_1004 != dwLoc18_1000 l080A948C
l080A9255:
	word32 esi_1640
	word32 edi_1641
	word32 ebx_1639
	runtime.eqstring(dwLoc08_1004, dwLoc1C_1001, dwLoc18_1000, dwLoc0C_1003, out ebx_1639, out esi_1640, out edi_1641)
	branch bLoc60 == 0x00 l080A948C
l080A9282:
	Eq_4 edx_315 = *((word32) esi_229 + (ebp_233 * 0x04 + 4))
	reflect.haveIdenticalType(gs, 0x08138A00, edx_315, 0x08138A00, *((word32) ecx_236 + (ebp_233 * 0x04 + 4)), bArg08)
	Eq_4 dwLoc68_1025 = 0x08138A00
	Eq_4 dwLoc6C_1028 = edx_315
	bLoc60 = bArg08
	branch bLoc5C == 0x00 l080A9483
l080A92C6:
	branch bArg08 != 0x00 l080A9409
l080A92D3:
	branch *((word32) esi_229 + (ebp_233 * 0x04 + 8)) != *((word32) ecx_236 + (ebp_233 * 0x04 + 8)) l080A9400
l080A92EF:
	Eq_4 edx_420 = *((word32) esi_229 + ebp_233 * 0x04)
	branch (*edx_420 & 0x01) != 0x00 l080A91A1
l080A92FE:
	Eq_4 edx_452
	reflect.name.pkgPath(gs, edx_420)
	Eq_4 ecx_448 = dwLoc6C_1028
	branch dwLoc68_1025 != 0x00 l080A93F9
l080A9316:
	Eq_115751 ecx_454 = *((word32) dwArg00 + 32)
	Eq_4 dwLoc14_1060 = 0x00
	Eq_4 dwLoc10_1061 = 0x00
	branch ecx_454 == 0x00 l080A9349
l080A9331:
	dwLoc14_1060 = (word32) ecx_454 + 3
	dwLoc10_1061 = (word32) *((word32) ecx_454 + 2) | (word32) (*((word32) ecx_454 + 1)) << 0x08
l080A9349:
	ecx_448 = dwLoc14_1060
	edx_452 = dwLoc10_1061
l080A9351:
	Eq_4 edx_508
	Eq_4 ecx_509
	reflect.name.pkgPath(gs, *((word32) ecx_236 + ebp_233 * 0x04))
	branch dwLoc68_1025 != 0x00 l080A93EF
l080A9378:
	Eq_115751 ecx_512 = *((word32) dwArg04 + 32)
	Eq_4 dwLoc24_1080 = 0x00
	Eq_4 dwLoc20_1081 = 0x00
	branch ecx_512 == 0x00 l080A93AB
l080A9393:
	dwLoc24_1080 = (word32) ecx_512 + 3
	dwLoc20_1081 = (word32) *((word32) ecx_512 + 1) << 0x08 | (word32) (*((word32) ecx_512 + 2))
l080A93AB:
	ecx_509 = dwLoc20_1081
	edx_508 = dwLoc24_1080
l080A93B3:
	branch ecx_509 != edx_452 l080A93E6
l080A93BB:
	word32 edi_1644
	word32 esi_1643
	word32 ebx_1642
	runtime.eqstring(edx_508, ecx_448, edx_452, edx_508, out ebx_1642, out esi_1643, out edi_1644)
	branch bArg08 == 0x00 l080A93E6
	goto l080A91A1
l080A93E6:
	return
l080A93EF:
	edx_508 = dwLoc6C_1028
	ecx_509 = dwLoc68_1025
	goto l080A93B3
l080A93F9:
	edx_452 = dwLoc68_1025
	goto l080A9351
l080A9400:
	return
l080A9409:
	reflect.name.tag(gs, *((word32) esi_229 + ebp_233 * 0x04))
	reflect.name.tag(gs, *((word32) ecx_236 + ebp_233 * 0x04))
	word32 edi_1647
	word32 ebx_1645
	word32 esi_1646
	runtime.eqstring(0x08138A00, edx_315, 0x08138A00, edx_315, out ebx_1645, out esi_1646, out edi_1647)
	dwLoc6C_1028.u0 = 0x08138A00
	dwLoc68_1025 = edx_315
	branch bArg08 == 0x00 l080A947A
	goto l080A92D3
l080A944F:
l080A9470:
l080A9483:
	return
l080A948C:
	return
l080A9495:
	return
l080A949E:
	return
l080A94A7:
	reflect.(*rtype).Elem(gs, dwArg00)
	reflect.(*rtype).Elem(gs, dwArg04)
	reflect.haveIdenticalType(gs, dwLoc6C, dwLoc68, dwLoc6C, dwLoc68, bArg08)
	return
l080A9505:
	branch (edx_30 & 0x1F) != 0x14 l080A952A
l080A950A:
	branch *((word32) dwArg00 + 40) != 0x00 l080A9518
l080A9511:
	branch *((word32) dwArg04 + 40) == 0x00 l080A9521
l080A9518:
	return
l080A9521:
	return
l080A952A:
	reflect.(*rtype).Key(gs, dwArg00)
	reflect.(*rtype).Key(gs, dwArg04)
	reflect.haveIdenticalType(gs, dwLoc6C, dwLoc68, dwLoc6C, dwLoc68, bArg08)
	branch bLoc5C != 0x00 l080A958E
l080A9586:
	return
l080A958E:
	reflect.(*rtype).Elem(gs, dwArg00)
	reflect.(*rtype).Elem(gs, dwArg04)
	reflect.haveIdenticalType(gs, dwLoc68, dwLoc6C, dwLoc68, dwLoc6C, bArg08)
	goto l080A9586
l080A95EA:
	return
l080A95F3:
	return
l080A95FC:
	return
l080A9605:
	runtime.panicindex(gs)
l080A960C:
	runtime.panicindex(gs)
l080A9613:
	runtime.morestack_noctxt()
	goto l080A8DF0
reflect.haveIdenticalUnderlyingType_exit:
}

// subject_text_0006.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 080A9620: void reflect.typesByString(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
// Called from:
//      reflect.(*rtype).ptrTo
//      reflect.FuncOf
void reflect.typesByString(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.typelinks(gs);
	struct Eq_116107 * ecx_152 = dwLoc68;
	Eq_4 ebp_154 = 0x00;
	Eq_4 esi_158 = 0x00;
	Eq_4 edi_159 = 0x00;
	Eq_4 dwLoc4C_337 = 0x00;
	dwLoc70_361 = dwLoc70;
	dwLoc64_385 = dwLoc64;
	while (true)
	{
		Eq_4 dwLoc64_385;
		Eq_4 dwLoc70_361;
		if (ebp_154 >= dwLoc64)
			break;
		Eq_116122 eax_66 = ecx_152->dw0004;
		word32 ecx_67[] = ecx_152->dw0000;
		if (ebp_154 >= dwLoc70)
			runtime.panicindex(gs);
		word32 ebx_78 = dwLoc74[ebp_154];
		Eq_116122 dwLoc38_350 = 0x00;
		Eq_116122 eax_304 = eax_66;
		while (true)
		{
			Eq_4 edi_237 = edi_159;
			Eq_4 esi_235 = esi_158;
			Eq_116122 edx_101 = dwLoc38_350;
			if (dwLoc38_350 >= eax_304)
				break;
			int32 eax_246 = eax_304 - dwLoc38_350;
			Eq_116148 eax_251 = (eax_246 >> 0x1F >> 0x1F) + eax_246;
			Eq_116122 ebp_253 = (word32) dwLoc38_350.u0 + (eax_251 >> 0x01);
			if (ebp_253 >= eax_66)
				runtime.panicindex(gs);
			Eq_116122 ecx_303;
			reflect.(*rtype).String(gs, ecx_67[ebp_253] + ebx_78);
			runtime.cmpstring(dwLoc70_361, dwLoc6C, dwArg04, dwArg08);
			dwLoc70_361 = dwLoc6C;
			dwLoc6C = dwArg04;
			if (dwLoc64_385 >= 0x00)
			{
				eax_304 = ebp_253;
				ecx_303 = dwLoc38_350;
			}
			else
				ecx_303 = (word32) dwLoc38_350.u0 + ((eax_251 >> 0x01) + 0x01);
			dwLoc38_350 = ecx_303;
		}
		Eq_4 eax_243 = dwLoc4C_337;
		while (true)
		{
			byte bLoc64_368 = (byte) dwLoc64_385;
			dwLoc4C_337 = eax_243;
			if (edx_101 >= eax_66)
				break;
			if (edx_101 >= eax_66)
				runtime.panicindex(gs);
			Eq_4 eax_111 = ecx_67[edx_101] + ebx_78;
			reflect.(*rtype).String(gs, eax_111);
			if (dwLoc6C != dwArg08)
				break;
			word32 ebx_597;
			word32 esi_598;
			word32 edi_599;
			runtime.eqstring(dwArg08, dwLoc70_361, dwLoc6C, dwArg04, out ebx_597, out esi_598, out edi_599);
			dwLoc70_361 = dwLoc6C;
			dwLoc6C = dwArg04;
			if (bLoc64_368 == 0x00)
				break;
			Eq_4 ebx_192;
			Eq_4 ecx_161 = (word32) edi_237 + 1;
			Eq_4 edx_162 = eax_243;
			if ((word32) edi_237 + 1 <= eax_243)
				ebx_192 = esi_235;
			else
			{
				dwLoc64_385 = (word32) edi_237 + 1;
				word128 xmm0_601;
				word32 esi_600;
				word128 xmm1_602;
				runtime.growslice(gs, 0x080DDF40, esi_235, edi_237, eax_243, dwLoc64_385, out esi_600, out xmm0_601, out xmm1_602);
				dwLoc70_361 = esi_235;
				dwLoc6C = edi_237;
				ebx_192 = dwLoc60;
				edx_162 = dwLoc58;
				ecx_161 = dwLoc5C + 0x01;
			}
			Eq_4 ebp_200 = (word32) ebx_192 + edi_237 * 0x04;
			if (g_t81576F0 == 0x00)
				*((word32) ebx_192 + edi_237 * 0x04) = eax_111;
			else
			{
				runtime.writebarrierptr(ebp_200, eax_111);
				dwLoc70_361 = eax_111;
			}
			esi_235 = ebx_192;
			edi_237 = ecx_161;
			edx_101 = (word32) edx_101 + 1;
			eax_243 = edx_162;
		}
		++ecx_152;
		ebp_154 = (word32) ebp_154 + 1;
		esi_158 = esi_235;
		edi_159 = edi_237;
	}
}

// 080A98E0: void reflect.FuncOf(Register (ptr32 Eq_2) gs, Stack (ptr32 word32) dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg14, Stack byte bArg1C)
// Called from:
//      reflect.(*rtype).Method
void reflect.FuncOf(struct Eq_2 * gs, word32 * dwArg04, Eq_4 dwArg08, Eq_4 dwArg14, byte bArg1C)
{
	while (fp - 0x18 <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	struct Eq_116256 * esp_17 = fp - 0x98;
	if (bArg1C != 0x00)
	{
		if (dwArg08 != 0x00)
		{
			if (dwArg08 - 0x01 >= dwArg08)
				runtime.panicindex(gs);
			struct Eq_117225 ** edx_33 = dwArg04 - 0x08 + dwArg08 * 0x08;
			<anonymous> * edx_36 = *((char *) *edx_33 + 84);
			edx_36();
			if (dwLoc94 == 0x17)
				goto l080A9926;
		}
		runtime.gopanic(gs);
	}
	else
	{
l080A9926:
		Eq_4 edx_104;
		word32 ebp_75 = dwArg08 + dwArg14;
		if (ebp_75 > 0x04)
		{
			if (ebp_75 > 0x08)
			{
				if (ebp_75 > 0x10)
				{
					if (ebp_75 > 0x20)
					{
						if (ebp_75 > 0x40)
						{
							if (ebp_75 > 0x80)
								runtime.gopanic(gs);
							runtime.newobject(gs, 0x080D3260);
							edx_104.u0 = 0x80;
						}
						else
						{
							runtime.newobject(gs, 0x080D33E0);
							edx_104.u0 = 0x40;
						}
					}
					else
					{
						runtime.newobject(gs, 0x080D3320);
						edx_104.u0 = 0x20;
					}
				}
				else
				{
					runtime.newobject(gs, 0x080D32C0);
					edx_104.u0 = 0x10;
				}
			}
			else
			{
				runtime.newobject(gs, 0x080D3440);
				edx_104.u0 = 0x08;
			}
		}
		else
		{
			runtime.newobject(gs, 0x080D3380);
			edx_104.u0 = 0x04;
		}
		if (g_t81576F0 == 0x00)
		{
			fn08090246(&g_dw80CA340, dwLoc94);
			esp_17 = fp - 0x9C;
		}
		else
		{
			word32 esi_1558;
			word128 xmm1_1561;
			word32 edi_1559;
			word128 xmm0_1560;
			runtime.typedmemmove(0x080D58C0, dwLoc94, 0x080CA340, out esi_1558, out edi_1559, out xmm0_1560, out xmm1_1561);
		}
		Eq_4 edx_1062 = edx_104;
		Eq_4 ecx_1137 = 0x00;
		struct Eq_116347 * ebx_1011 = esp_17->ptr009C;
		Eq_4 ebp_1066 = 0x00;
		Eq_4 esi_1060 = esp_17->t008C;
		Eq_4 edi_1067 = 0x00;
		while (true)
		{
			esp_17->t002C = edi_1067;
			if (ecx_1137 >= esp_17->t00A0)
				break;
			esp_17->t0048 = ecx_1137;
			esp_17->ptr0088 = ebx_1011;
			Eq_4 eax_1013 = ebx_1011->t0004;
			Eq_4 ecx_1014 = ebx_1011->t0000;
			if (ecx_1014 != 0x08138A00)
			{
				esp_17->t0000 = ecx_1014;
				esp_17->t0004.u0 = 0x080DDF40;
				esp_17->t0008.u0 = 135117536;
				runtime.panicdottypeI(gs, esp_17->t0000);
			}
			esp_17->t0064 = eax_1013;
			esp_17->t0028 = ebp_1066;
			Eq_4 ecx_1031 = (word32) edi_1067 + 1;
			if (ecx_1031 > edx_1062)
			{
				esp_17->t0000.u0 = 0x080DDF40;
				esp_17->t0004 = esi_1060;
				esp_17->t0008 = edi_1067;
				esp_17->t000C = edx_1062;
				esp_17->t0010 = ecx_1031;
				word32 esi_1562;
				word128 xmm0_1563;
				word128 xmm1_1564;
				runtime.growslice(gs, esp_17->t0000, esp_17->t0004, esp_17->t0008, esp_17->t000C, esp_17->t0010, out esi_1562, out xmm0_1563, out xmm1_1564);
				esi_1060 = esp_17->t0014;
				edx_1062 = esp_17->t001C;
				ecx_1031 = esp_17->dw0018 + 0x01;
				eax_1013 = esp_17->t0064;
				ebp_1066 = esp_17->t0028;
				edi_1067 = esp_17->t002C;
			}
			esp_17->t006C = esi_1060;
			esp_17->t002C = ecx_1031;
			esp_17->t0030 = edx_1062;
			Eq_4 ebx_1076 = (word32) esi_1060 + edi_1067 * 0x04;
			if (g_t81576F0 == 0x00)
				*((word32) esi_1060 + edi_1067 * 0x04) = eax_1013;
			else
			{
				esp_17->t0000 = ebx_1076;
				esp_17->t0004 = eax_1013;
				runtime.writebarrierptr(esp_17->t0000, esp_17->t0004);
				eax_1013 = esp_17->t0064;
				ebp_1066 = esp_17->t0028;
			}
			esp_17->t0040.u1 = 0x00;
			esp_17->t0040 = (byte) (*((word32) eax_1013 + 8) >> 0x18);
			esp_17->b0041 = (byte) (*((word32) eax_1013 + 8) >> 0x10);
			esp_17->b0042 = (byte) (*((word32) eax_1013 + 8) >> 0x08);
			esp_17->t0043 = *((word32) eax_1013 + 8);
			esp_17->t0000 = ebp_1066;
			esp_17->t0004 = &esp_17->t0040;
			esp_17->t0008.u0 = 0x04;
			esp_17->t000C.u0 = 0x04;
			reflect.fnv1(gs, esp_17->t0008);
			ebp_1066 = esp_17->t0010;
			ebx_1011 = (struct Eq_116347 *) ((char *) &esp_17->ptr0088->t0004 + 4);
			ecx_1137 = (word32) esp_17->t0048 + 1;
			esi_1060 = esp_17->t006C;
			edi_1067 = esp_17->t002C;
			edx_1062 = esp_17->t0030;
		}
		esp_17->t0084 = esi_1060;
		esp_17->t0044 = edx_1062;
		if (esp_17->b00B4 != 0x00)
		{
			esp_17->b0023 = g_b80F1803;
			esp_17->t0000 = ebp_1066;
			esp_17->t0004 = &esp_17->b0023;
			esp_17->t0008.u0 = 0x01;
			esp_17->t000C.u0 = 0x01;
			reflect.fnv1(gs, esp_17->t0008);
			ebp_1066 = esp_17->t0010;
		}
		esp_17->b0022 = g_b80F1804;
		esp_17->t0000 = ebp_1066;
		esp_17->t0004 = &esp_17->b0022;
		esp_17->t0008.u0 = 0x01;
		esp_17->t000C.u0 = 0x01;
		reflect.fnv1(gs, esp_17->t0008);
		Eq_4 eax_1001 = esp_17->t0010;
		Eq_4 ecx_1005 = 0x00;
		struct Eq_116637 * edx_1003 = esp_17->ptr00A8;
		Eq_4 ebx_1007 = esp_17->t0084;
		Eq_4 ebp_1008 = esp_17->t0044;
		Eq_4 esi_1009 = esp_17->t002C;
		while (true)
		{
			esp_17->t0028 = eax_1001;
			Eq_4 edi_307 = esp_17->t00AC;
			cui16 di_337 = (word16) edi_307;
			if (ecx_1005 >= edi_307)
				break;
			esp_17->t0048 = ecx_1005;
			esp_17->ptr0080 = edx_1003;
			Eq_4 edi_879 = edx_1003->t0004;
			Eq_4 ecx_880 = edx_1003->t0000;
			if (ecx_880 != 0x08138A00)
			{
				esp_17->t0000 = ecx_880;
				esp_17->t0004.u0 = 0x080DDF40;
				esp_17->t0008.u0 = 135117536;
				runtime.panicdottypeI(gs, esp_17->t0000);
			}
			esp_17->t0060 = edi_879;
			Eq_4 ecx_896 = (word32) esi_1009 + 1;
			if (ecx_896 > ebp_1008)
			{
				esp_17->t002C = esi_1009;
				esp_17->t0000.u0 = 0x080DDF40;
				esp_17->t0004 = ebx_1007;
				esp_17->t0008 = esi_1009;
				esp_17->t000C = ebp_1008;
				esp_17->t0010 = ecx_896;
				word32 esi_1565;
				word128 xmm0_1566;
				word128 xmm1_1567;
				runtime.growslice(gs, esp_17->t0000, esp_17->t0004, esp_17->t0008, esp_17->t000C, esp_17->t0010, out esi_1565, out xmm0_1566, out xmm1_1567);
				ebx_1007 = esp_17->t0014;
				ebp_1008 = esp_17->t001C;
				ecx_896 = esp_17->dw0018 + 0x01;
				eax_1001 = esp_17->t0028;
				esi_1009 = esp_17->t002C;
				edi_879 = esp_17->t0060;
			}
			esp_17->t006C = ebx_1007;
			esp_17->t002C = ecx_896;
			esp_17->t0030 = ebp_1008;
			Eq_4 edx_944 = (word32) ebx_1007 + esi_1009 * 0x04;
			if (g_t81576F0 == 0x00)
				*((word32) ebx_1007 + esi_1009 * 0x04) = edi_879;
			else
			{
				esp_17->t0000 = edx_944;
				esp_17->t0004 = edi_879;
				runtime.writebarrierptr(esp_17->t0000, esp_17->t0004);
				eax_1001 = esp_17->t0028;
				edi_879 = esp_17->t0060;
			}
			esp_17->t003C.u1 = 0x00;
			esp_17->t003C = (byte) (*((word32) edi_879 + 8) >> 0x18);
			esp_17->b003D = (byte) (*((word32) edi_879 + 8) >> 0x10);
			esp_17->b003E = (byte) (*((word32) edi_879 + 8) >> 0x08);
			esp_17->t003F = *((word32) edi_879 + 8);
			esp_17->t0000 = eax_1001;
			esp_17->t0004 = &esp_17->t003C;
			esp_17->t0008.u0 = 0x04;
			esp_17->t000C.u0 = 0x04;
			reflect.fnv1(gs, esp_17->t0008);
			eax_1001 = esp_17->t0010;
			edx_1003 = (struct Eq_116637 *) ((char *) &esp_17->ptr0080->t0004 + 4);
			ecx_1005 = (word32) esp_17->t0048 + 1;
			ebx_1007 = esp_17->t006C;
			ebp_1008 = esp_17->t0030;
			esi_1009 = esp_17->t002C;
		}
		if (esi_1009 > 0x32)
		{
			esp_17->t0000.u0 = 135066016;
			esp_17->t0004.u0 = 0x080F19B0;
			runtime.gopanic(gs);
		}
		else
		{
			Eq_4 ecx_331 = esp_17->t0068;
			((word32) ecx_331 + 0x0C)->u0 = 0x00;
			*((word32) ecx_331 + 8) = eax_1001;
			*((word32) ecx_331 + 32) = esp_17->t00A0;
			*((word32) ecx_331 + 0x0022) = di_337;
			if (esp_17->b00B4 != 0x00)
				*((word32) ecx_331 + 0x0022) = (word16) edi_307 | 0x8000;
			esp_17->t0038 = eax_1001;
			esp_17->t0000.u0 = 135549544;
			esp_17->t0004.u0 = 0x080CF2A0;
			esp_17->t0008 = &esp_17->t0038;
			sync.(*Map).Load(gs, esp_17->t0000, esp_17->t0004, esp_17->t0008);
			Eq_4 eax_369 = esp_17->t0010;
			Eq_4 ecx_370 = esp_17->t000C;
			if (esp_17->t0014 != 0x00)
			{
				if (ecx_370 != 0x080C9000)
				{
					esp_17->t0000 = ecx_370;
					esp_17->t0004.u0 = 0x080C9000;
					esp_17->t0008.u0 = 0x080CECA0;
					runtime.panicdottypeE(gs, esp_17->t0000);
				}
				Eq_4 ecx_383 = *((word32) eax_369 + 4);
				esp_17->t0048 = ecx_383;
				struct Eq_117012 * eax_385 = *eax_369;
				Eq_4 ebx_386 = 0x00;
				while (true)
				{
					byte bLoc8C_1413 = (byte) dwLoc8C;
					if (ebx_386 >= ecx_383)
						break;
					esp_17->t0044 = ebx_386;
					esp_17->ptr007C = eax_385;
					Eq_4 ecx_813 = eax_385->t0000;
					esp_17->t0050 = ecx_813;
					esp_17->t0000 = esp_17->t0068;
					esp_17->t0004 = ecx_813;
					esp_17->t0008.u0 = 0x01;
					reflect.haveIdenticalUnderlyingType(gs, esp_17->tFFFFFFFC, esp_17->t0000, esp_17->t0004);
					esp_17 = fp - 0x0098;
					if (bLoc8C_1413 != 0x00)
					{
						word128 xmm1_1574;
						word128 xmm0_1573;
						runtime.deferreturn(gs, out xmm0_1573, out xmm1_1574);
						return;
					}
					eax_385 = dwLoc1C + 0x04;
					ebx_386 = dwLoc54 + 0x01;
					ecx_383 = dwLoc50;
				}
			}
			sync.(*Mutex).Lock(gs, 135549536);
			word32 esi_1569;
			word32 edi_1570;
			word32 ebp_1568;
			if (runtime.deferproc(gs, 0x04, 0x080E7D08, 135549536, out ebp_1568, out esi_1569, out edi_1570) != 0x00)
			{
				word128 xmm0_1571;
				word128 xmm1_1572;
				runtime.deferreturn(gs, out xmm0_1571, out xmm1_1572);
			}
			else
			{
				sync.(*Map).Load(gs, 135549544, 0x080CF2A0, fp - 100);
				Eq_4 dwLoc90_1327 = fp - 100;
				if (bLoc84 != 0x00)
				{
					if (dwLoc8C != 0x080C9000)
						runtime.panicdottypeE(gs, dwLoc8C);
					int32 eax_492 = dwLoc88->dw0004;
					struct Eq_117074 * ecx_494 = dwLoc88->ptr0000;
					int32 edx_495 = 0x00;
					while (true)
					{
						byte bLoc8C_1409 = (byte) dwLoc8C;
						word24 nLoc8F_1486 = SLICE(dwLoc90_1327, word24, 8);
						if (edx_495 >= eax_492)
							break;
						reflect.haveIdenticalUnderlyingType(gs, dwLoc9C, dwLoc94, ecx_494->b0000);
						dwLoc90_1327 = SEQ(nLoc8F_1486, 0x01);
						if (bLoc8C_1409 != 0x00)
						{
							word128 xmm0_1575;
							word128 xmm1_1576;
							runtime.deferreturn(gs, out xmm0_1575, out xmm1_1576);
							return;
						}
						++ecx_494;
						++edx_495;
					}
				}
				runtime.newobject(gs, 0x080D10A0);
				*dwLoc94 = 0x080AFA50;
				*((word32) dwLoc94 + 4) = dwLoc70;
				reflect.funcStr(gs, dwLoc9C, dwLoc94, dwLoc94);
				reflect.typesByString(gs, dwLoc94, dwLoc90_1327);
				byte bLoc8C_1507 = (byte) dwLoc8C;
				Eq_4 ecx_571 = dwLoc90_1327;
				Eq_4 edx_572 = 0x00;
				while (edx_572 < dwLoc8C)
				{
					word32 eax_674 = *ecx_571;
					reflect.haveIdenticalUnderlyingType(gs, dwLoc9C, dwLoc94, (byte) eax_674);
					if (bLoc8C_1507 != 0x00)
					{
						fn00000004();
						word128 xmm0_1579;
						word128 xmm1_1580;
						runtime.deferreturn(gs, out xmm0_1579, out xmm1_1580);
						return;
					}
					ecx_571 = (word32) ecx_571 + 4;
					edx_572 = (word32) edx_572 + 1;
				}
				Eq_4 edi_595;
				Eq_4 esi_597;
				reflect.resolveReflectName(SLICE(reflect.newName(gs, dwLoc94, dwLoc90_1327, 0x00, 0x00, 0x00, 0x00, out esi_597, out edi_595), word24, 8), esi_597, edi_595, gs, dwLoc7C);
				*((word32) dwLoc94 + 24) = dwLoc90_1327;
				((word32) dwLoc94 + 28)->u0 = 0x00;
				fn00000004();
				word128 xmm1_1578;
				word128 xmm0_1577;
				runtime.deferreturn(gs, out xmm0_1577, out xmm1_1578);
			}
		}
	}
}

// 080AA210: void reflect.funcStr(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg00, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
// Called from:
//      reflect.FuncOf
void reflect.funcStr(struct Eq_2 * gs, Eq_4 dwArg00, Eq_4 dwArg04, Eq_4 dwArg08)
{
	while (fp - 0x20 <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	fn0808FD80(0x00, fp - 0x5C);
	word128 xmm2_1418;
	word128 xmm0_1416;
	word128 xmm1_1417;
	word32 esi_1414;
	word32 edi_1415;
	word32 ebp_1413;
	runtime.memmove(fp - 0x60, 0x080E1038, 0x05, out ebp_1413, out esi_1414, out edi_1415, out xmm0_1416, out xmm1_1417, out xmm2_1418);
	Eq_4 dwLoc9C_1016 = 0x05;
	Eq_4 ecx_120 = dwArg00;
	(*((word32) dwArg00 + 0x0C) & 0x01) == 0x00;
	Eq_117280 edx_64 = (word32) *((word32) dwArg00 + 32);
	if (edx_64 > 0x00100000)
		runtime.panicslice(gs);
	else
	{
		Eq_117280 ebx_70 = 0x00;
		Eq_4 ebp_1008 = fp - 0x60;
		Eq_4 esi_1006 = 0x40;
		Eq_4 edi_75 = 0x05;
		Eq_4 dwLoc98_1172 = dwLoc98;
		while (true)
		{
			Eq_4 dwLoc98_1049 = dwLoc98_1172;
			if (ebx_70 >= edx_64)
				break;
			Eq_4 edx_605;
			Eq_4 ecx_604;
			Eq_4 eax_603;
			if (ebx_70 > 0x00)
			{
				Eq_4 eax_606 = (word32) edi_75 + 2;
				if (eax_606 > esi_1006)
				{
					word128 xmm1_1421;
					word32 esi_1419;
					word128 xmm0_1420;
					runtime.growslice(gs, 0x080CF320, ebp_1008, edi_75, esi_1006, eax_606, out esi_1419, out xmm0_1420, out xmm1_1421);
					dwLoc94 = esi_1006;
					esi_1006 = dwLoc84;
					ebp_1008 = dwLoc8C;
				}
				if (eax_606 > esi_1006)
					runtime.panicslice(gs);
				word128 xmm1_1426;
				word128 xmm2_1427;
				word32 edi_1424;
				word128 xmm0_1425;
				word32 ebp_1422;
				word32 esi_1423;
				runtime.memmove(edi_75 + ebp_1008, 0x080E0DB5, 0x02, out ebp_1422, out esi_1423, out edi_1424, out xmm0_1425, out xmm1_1426, out xmm2_1427);
				dwLoc98_1172.u0 = 0x02;
				eax_603 = ebp_1008;
				ecx_604 = esi_1006;
				edx_605 = eax_606;
			}
			else
			{
				eax_603 = ebp_1008;
				ecx_604 = esi_1006;
				edx_605 = edi_75;
			}
			Eq_4 dwLoc98_1224;
			Eq_4 edx_807;
			Eq_4 eax_805;
			Eq_4 ecx_806;
			reflect.(*rtype).IsVariadic(gs, dwArg04);
			if ((byte) dwLoc98_1172 != 0x00 && (word32) (*((word32) dwArg08 + 32)) - 0x01 == dwLoc70)
			{
				Eq_4 esi_842;
				word32 ebx_809 = ecx_604 + 0x03;
				word32 dwLoc60_1227 = ecx_604 + 0x03;
				Eq_4 ebp_811 = dwLoc78;
				if (ecx_604 + 0x03 <=u dwLoc78)
					esi_842 = dwLoc10;
				else
				{
					dwLoc8C = ecx_604 + 0x03;
					word128 xmm0_1429;
					word128 xmm1_1430;
					word32 esi_1428;
					runtime.growslice(gs, 0x080CF320, dwLoc10, ecx_604, dwLoc78, dwLoc8C, out esi_1428, out xmm0_1429, out xmm1_1430);
					ebp_811 = edx_605;
					esi_842 = dwLoc88;
					ebx_809 = dwLoc60_1227;
				}
				if (ebx_809 > ebp_811)
					runtime.panicslice(gs);
				Eq_4 esi_934;
				word128 xmm2_1436;
				word32 esi_1432;
				word128 xmm0_1434;
				word128 xmm1_1435;
				word32 edi_1433;
				word32 ebp_1431;
				runtime.memmove(ecx_604 + esi_842, 0x080E0E3A, 0x03, out ebp_1431, out esi_1432, out edi_1433, out xmm0_1434, out xmm1_1435, out xmm2_1436);
				reflect.(*rtype).String(gs, *((word32) eax_603 + 32));
				word32 edx_897 = ecx_604 + 0x06;
				Eq_4 ebp_900 = ebp_811;
				if (edx_897 <= ebp_811)
					esi_934 = esi_842;
				else
				{
					word128 xmm0_1438;
					word128 xmm1_1439;
					word32 esi_1437;
					runtime.growslice(gs, 0x080CF320, esi_842, dwLoc60_1227, ebp_811, edx_897, out esi_1437, out xmm0_1438, out xmm1_1439);
					dwLoc8C = edx_897;
					ebp_900 = edx_605;
					esi_934 = dwLoc88;
				}
				if (edx_897 > ebp_900)
					runtime.panicslice(gs);
				word32 ecx_950 = ecx_604 + 0x03 + esi_934;
				word32 edi_1442;
				word128 xmm0_1443;
				word128 xmm1_1444;
				word128 xmm2_1445;
				word32 esi_1441;
				word32 ebp_1440;
				runtime.memmove(ecx_950, 0x080E0E3A, 0x03, out ebp_1440, out esi_1441, out edi_1442, out xmm0_1443, out xmm1_1444, out xmm2_1445);
				dwLoc10 = esi_934;
				dwLoc78 = ebp_900;
				dwLoc9C_1016 = ecx_950;
				dwLoc98_1224.u0 = 0x080E0E3A;
				dwLoc94.u0 = 0x03;
				eax_805 = edx_897;
				ecx_806 = ebp_900;
				edx_807 = esi_934;
			}
			else
			{
				Eq_4 esi_762;
				reflect.(*rtype).String(gs, eax_603);
				word32 edx_726 = ecx_604 + dwLoc94;
				Eq_4 ebp_729 = dwLoc78;
				if (edx_726 <= dwLoc78)
					esi_762 = dwLoc10;
				else
				{
					word128 xmm0_1483;
					word128 xmm1_1484;
					word32 esi_1482;
					runtime.growslice(gs, 0x080CF320, dwLoc10, ecx_604, dwLoc78, edx_726, out esi_1482, out xmm0_1483, out xmm1_1484);
					dwLoc8C = edx_726;
					ebp_729 = edx_605;
					esi_762 = dwLoc88;
				}
				if (edx_726 > ebp_729)
					runtime.panicslice(gs);
				word32 ecx_778 = ecx_604 + esi_762;
				word32 ebp_1485;
				word128 xmm0_1488;
				word128 xmm1_1489;
				word128 xmm2_1490;
				word32 esi_1486;
				word32 edi_1487;
				runtime.memmove(ecx_778, dwLoc98_1172, dwLoc94, out ebp_1485, out esi_1486, out edi_1487, out xmm0_1488, out xmm1_1489, out xmm2_1490);
				dwLoc78 = ebp_729;
				dwLoc10 = esi_762;
				dwLoc9C_1016 = ecx_778;
				dwLoc98_1224 = dwLoc98_1172;
				eax_805 = edx_726;
				ecx_806 = ebp_729;
				edx_807 = esi_762;
			}
			esi_1006 = ecx_806;
			edi_75 = eax_805;
			ecx_120 = dwArg08;
			ebx_70 = dwLoc70 + 0x01;
			ebp_1008 = edx_807;
			edx_64 = dwLoc5C;
			dwLoc98_1172 = dwLoc98_1224;
		}
		Eq_4 eax_1408 = (word32) edi_75 + 1;
		if (eax_1408 > esi_1006)
		{
			word32 esi_1446;
			word128 xmm0_1447;
			word128 xmm1_1448;
			runtime.growslice(gs, 0x080CF320, ebp_1008, edi_75, esi_1006, eax_1408, out esi_1446, out xmm0_1447, out xmm1_1448);
			dwLoc9C_1016 = ebp_1008;
			dwLoc98_1049 = edi_75;
			ebp_1008 = dwLoc8C;
			esi_1006 = dwLoc84;
			ecx_120 = dwArg04;
			eax_1408 = SEQ(SLICE((word32) dwLoc88 + 1, word24, 8), (byte) dwLoc88 + 0x01);
		}
		word32 edx_132;
		Mem124[ebp_1008 + edi_75:byte] = 0x29;
		if ((*((word32) ecx_120 + 0x0C) & 0x01) != 0x00)
			edx_132 = 0x34;
		else
			edx_132 = 0x24;
		word32 ecx_146 = (word32) *((word32) ecx_120 + 32);
		word32 edx_137 = (word32) ecx_120 + edx_132;
		uint32 edi_148 = (word32) (word16) ecx_146;
		uint32 ecx_151 = (word32) ((word16) ecx_146 + (*((word32) ecx_120 + 0x0022) & 0x7FFF));
		Eq_4 eax_163 = eax_1408;
		if (edi_148 > ecx_151 || ecx_151 > 0x00100000)
			runtime.panicslice(gs);
		else
		{
			Eq_4 ebx_1000;
			Eq_117482 ecx_167 = ecx_151 - edi_148;
			word32 * edx_175 = edx_137 + (edi_148 << 0x02 & -(-(edi_148 + 0xFFF00000)) >> 0x1F);
			if (ecx_167 == 0x01)
			{
				ebx_1000 = (word32) eax_1408 + 1;
				if ((word32) eax_1408 + 1 > esi_1006)
				{
					word128 xmm0_1450;
					word128 xmm1_1451;
					word32 esi_1449;
					runtime.growslice(gs, 0x080CF320, ebp_1008, eax_1408, esi_1006, (word32) eax_1408 + 1, out esi_1449, out xmm0_1450, out xmm1_1451);
					dwLoc9C_1016 = ebp_1008;
					dwLoc98_1049 = eax_1408;
					ebp_1008 = dwLoc8C;
					esi_1006 = dwLoc84;
					ebx_1000 = (word32) dwLoc88 + 1;
				}
				Mem308[ebp_1008 + eax_1408:byte] = 0x20;
			}
			else
			{
				Eq_4 edx_184;
				Eq_4 ecx_182;
				if (ecx_167 > 0x01)
				{
					word32 ebx_185 = eax_1408 + 0x02;
					word32 dwLoc60_1059 = eax_1408 + 0x02;
					if (eax_1408 + 0x02 >u esi_1006)
					{
						word128 xmm1_1472;
						word32 esi_1470;
						word128 xmm0_1471;
						runtime.growslice(gs, 0x080CF320, ebp_1008, eax_1408, esi_1006, eax_1408 + 0x02, out esi_1470, out xmm0_1471, out xmm1_1472);
						esi_1006 = dwLoc84;
						ebp_1008 = dwLoc8C;
						ebx_185 = dwLoc60_1059;
					}
					if (ebx_185 > esi_1006)
						runtime.panicslice(gs);
					word32 esi_1474;
					word128 xmm2_1478;
					word32 edi_1475;
					word128 xmm1_1477;
					word128 xmm0_1476;
					word32 ebp_1473;
					runtime.memmove(eax_1408 + ebp_1008, 0x080E0DA3, 0x02, out ebp_1473, out esi_1474, out edi_1475, out xmm0_1476, out xmm1_1477, out xmm2_1478);
					dwLoc9C_1016.u0 = 0x080E0DA3;
					dwLoc98_1049.u0 = 0x02;
					eax_163 = dwLoc60_1059;
					ecx_182 = esi_1006;
					edx_184 = ebp_1008;
				}
				else
				{
					ecx_182 = esi_1006;
					edx_184 = ebp_1008;
				}
				esi_1006 = ecx_182;
				ebx_1000 = eax_163;
				ebp_1008 = edx_184;
			}
			word32 * edx_1012 = edx_175;
			Eq_117482 eax_309 = 0x00;
			while (eax_309 < ecx_167)
			{
				Eq_4 edx_411;
				Eq_4 ecx_410;
				Eq_4 eax_409;
				Eq_4 edi_405 = *edx_1012;
				if (eax_309 > 0x00)
				{
					Eq_4 ecx_412 = (word32) ebx_1000 + 2;
					if (ecx_412 > esi_1006)
					{
						word32 esi_1452;
						word128 xmm0_1453;
						word128 xmm1_1454;
						runtime.growslice(gs, 0x080CF320, ebp_1008, ebx_1000, esi_1006, ecx_412, out esi_1452, out xmm0_1453, out xmm1_1454);
						esi_1006 = dwLoc84;
						ebp_1008 = dwLoc8C;
					}
					if (ecx_412 > esi_1006)
						runtime.panicslice(gs);
					word32 esi_1456;
					word32 edi_1457;
					word128 xmm2_1460;
					word128 xmm0_1458;
					word128 xmm1_1459;
					word32 ebp_1455;
					runtime.memmove(ebp_1008 + ebx_1000, 0x080E0DB5, 0x02, out ebp_1455, out esi_1456, out edi_1457, out xmm0_1458, out xmm1_1459, out xmm2_1460);
					dwLoc9C_1016.u0 = 0x080E0DB5;
					dwLoc98_1049.u0 = 0x02;
					eax_409 = esi_1006;
					ecx_410 = ebp_1008;
					edx_411 = ecx_412;
				}
				else
				{
					eax_409 = esi_1006;
					ecx_410 = ebp_1008;
					edx_411 = ebx_1000;
				}
				Eq_4 esi_544;
				reflect.(*rtype).String(gs, edi_405);
				word32 edx_508 = dwLoc98_1049 + edx_411;
				Eq_4 ebp_511 = eax_409;
				if (edx_508 <= eax_409)
					esi_544 = ecx_410;
				else
				{
					word128 xmm0_1462;
					word128 xmm1_1463;
					word32 esi_1461;
					runtime.growslice(gs, 0x080CF320, ecx_410, edx_411, eax_409, edx_508, out esi_1461, out xmm0_1462, out xmm1_1463);
					ebp_511 = dwLoc84;
					esi_544 = dwLoc8C;
				}
				if (edx_508 > ebp_511)
					runtime.panicslice(gs);
				word32 ebp_1464;
				word32 esi_1465;
				word128 xmm1_1468;
				word128 xmm2_1469;
				word32 edi_1466;
				word128 xmm0_1467;
				runtime.memmove(edx_411 + esi_544, dwLoc9C_1016, dwLoc98_1049, out ebp_1464, out esi_1465, out edi_1466, out xmm0_1467, out xmm1_1468, out xmm2_1469);
				++edx_1012;
				eax_309 = (word32) eax_309.u0 + 1;
				esi_1006 = ebp_511;
				ebx_1000 = edx_508;
				ebp_1008 = esi_544;
			}
			Eq_4 eax_321;
			if (ecx_167 > 0x01)
			{
				eax_321 = ebx_1000 + 0x01;
				if (eax_321 > esi_1006)
				{
					word128 xmm1_1481;
					word128 xmm0_1480;
					word32 esi_1479;
					runtime.growslice(gs, 0x080CF320, ebp_1008, ebx_1000, esi_1006, eax_321, out esi_1479, out xmm0_1480, out xmm1_1481);
					ebp_1008 = dwLoc8C;
					eax_321 = (word32) dwLoc88 + 1;
				}
				Mem362[ebp_1008 + ebx_1000:byte] = 0x29;
			}
			else
				eax_321 = ebx_1000;
			runtime.slicebytetostring(gs, 0x00, ebp_1008, eax_321);
		}
	}
}

// 080AAA10: void reflect.funcLayout(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
// Called from:
//      reflect.makeMethodValue
//      reflect.callMethod
void reflect.funcLayout(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08)
{
	byte bLoc0130_1092 = (byte) dwLoc0130;
	while (fp - 0xC4 <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (((word32) *((word32) dwArg04 + 0x0F) & 0x1F) != 0x13)
		runtime.gopanic(gs);
	else if (dwArg08 == 0x00 || ((word32) (*((word32) dwArg08 + 0x0F)) & 0x1F) != 0x14)
	{
		sync.(*Map).Load(gs, 0x08145200, 0x080D3500, fp - 0x7C);
		Eq_4 dwLoc0140_1089 = 0x080D3500;
		if (bLoc0130_1092 != 0x00)
		{
			fn0808FD8B(0x00, fp - 0x14);
			if (dwLoc0138 != 0x080D7D20)
				runtime.panicdottypeE(gs, dwLoc0138);
			else
			{
				fn0809026E(dwLoc0134, fp - 0x14);
				fn0809026E(fp - 0x14, fp - 0x50);
			}
		}
		else
		{
			word32 ecx_1052;
			runtime.newobject(gs, 0x080D31A0);
			if (dwArg08 != 0x00)
			{
				byte dl_206 = *((word32) dwArg08 + 0x0F);
				if ((dl_206 & 0x20) == 0x00 || (dl_206 & 0x80) == 0x00)
				{
					if ((g_dw80D3500 & 0x07) == 0x00)
					{
						Eq_4 edx_219 = g_t80D3508;
						Eq_4 ebx_220 = g_t80D3504;
						Eq_4 ebp_221 = g_t80D350C;
						if ((word32) edx_219 + 1 > ebp_221)
						{
							word128 xmm0_1531;
							word128 xmm1_1532;
							word32 esi_1530;
							runtime.growslice(gs, 0x080CF320, ebx_220, edx_219, ebp_221, (word32) edx_219 + 1, out esi_1530, out xmm0_1531, out xmm1_1532);
							g_t80D350C = dwLoc0128;
							dwLoc0140_1089 = ebx_220;
							if (g_t81576F0 == 0x00)
								g_t80D3504 = dwLoc0130;
							else
							{
								runtime.writebarrierptr(0x080D3504, dwLoc0130);
								dwLoc0140_1089 = dwLoc0130;
							}
							edx_219 = dwLoc012C;
							ebx_220 = dwLoc0130;
						}
						g_t80D3508 = (word32) edx_219 + 1;
						Mem294[ebx_220 + edx_219:byte] = 0x00;
					}
					Eq_4 ebx_298 = g_t80D3504;
					uint32 ebp_299 = g_dw80D3500;
					if (ebp_299 >> 0x03 >= g_t80D3508)
						runtime.panicindex(gs);
					Mem319[ebx_298 + (ebp_299 >>u 0x03):byte] = 0x01 << (SLICE(ebp_299, byte, 0) & 0x07) | Mem296[ebx_298 + (ebp_299 >>u 0x03):byte];
					++g_dw80D3500;
				}
				ecx_1052 = 0x04;
			}
			else
				ecx_1052 = 0x00;
			word32 ebx_340;
			if ((*((word32) dwArg04 + 0x0C) & 0x01) != 0x00)
				ebx_340 = 0x34;
			else
				ebx_340 = 0x24;
			word32 * ebx_345 = (word32) dwArg04 + ebx_340;
			Eq_117910 ebp_353 = (word32) *((word32) dwArg04 + 32);
			if (ebp_353 > 0x00100000)
				runtime.panicslice(gs);
			else
			{
				Eq_117910 esi_361 = 0x00;
				while (esi_361 < ebp_353)
				{
					struct Eq_117923 * edx_372 = *ebx_345;
					Eq_4 ecx_392 = ecx_1052 + ((word32) (edx_372->b000D - 0x01) & -ecx_1052);
					reflect.addTypeBits(gs, &g_dw80D3500, ecx_392, edx_372);
					dwLoc0140_1089 = ecx_392;
					++ebx_345;
					esi_361 = (word32) esi_361.u0 + 1;
					ecx_1052 = (word32) ecx_392 + edx_372->dw0000;
				}
				word32 esi_448;
				uint32 ebx_431 = g_dw80D3500;
				ui32 ecx_435 = (-ecx_1052 & 0x03) + ecx_1052;
				if ((*((word32) dwArg04 + 0x0C) & 0x01) != 0x00)
					esi_448 = 0x34;
				else
					esi_448 = 0x24;
				word32 ebp_462 = (word32) *((word32) dwArg04 + 32);
				word32 esi_456 = (word32) dwArg04 + esi_448;
				uint32 edx_464 = (word32) (word16) ebp_462;
				uint32 ebp_467 = (word32) ((word16) ebp_462 + (*((word32) dwArg04 + 0x0022) & 0x7FFF));
				if (edx_464 > ebp_467 || ebp_467 > 0x00100000)
					runtime.panicslice(gs);
				else
				{
					Eq_117976 ebp_478 = ebp_467 - edx_464;
					word32 * edx_498 = (edx_464 << 0x02 & -(-(edx_464 + 0xFFF00000)) >> 0x1F) + esi_456;
					Eq_117976 edi_500 = 0x00;
					while (edi_500 < ebp_478)
					{
						struct Eq_117923 * ebx_511 = *edx_498;
						Eq_4 ecx_531 = ecx_435 + ((word32) (ebx_511->b000D - 0x01) & -ecx_435);
						reflect.addTypeBits(gs, &g_dw80D3500, ecx_531, ebx_511);
						dwLoc0140_1089 = ecx_531;
						++edx_498;
						edi_500 = (word32) edi_500.u0 + 1;
						ecx_435 = (word32) ecx_531 + ebx_511->dw0000;
					}
					Eq_4 dwLoc0140_1205;
					runtime.newobject(gs, 135113664);
					*((word32) dwLoc0140_1089 + 0x0D) = 0x04;
					*dwLoc0140_1089 = (-ecx_435 & 0x03) + ecx_435;
					*((word32) dwLoc0140_1089 + 4) = g_dw80D3500 << 0x02;
					if (g_dw80D3500 > 0x00)
					{
						Eq_4 ebx_606 = g_t80D3504;
						if (g_t80D3508 <= 0x00)
							runtime.panicindex(gs);
						if (g_t81576F0 == 0x00)
						{
							*((word32) dwLoc0140_1089 + 20) = ebx_606;
							dwLoc0140_1205 = dwLoc0140_1089;
						}
						else
						{
							runtime.writebarrierptr(dwLoc0140_1089 + 0x14, ebx_606);
							dwLoc0140_1205 = ebx_606;
						}
					}
					else
					{
						*((word32) dwLoc0140_1089 + 0x0F) |= 0x80;
						dwLoc0140_1205 = dwLoc0140_1089;
					}
					Eq_4 eax_687;
					Eq_4 ecx_688;
					g_dw80D3500 = ebx_431;
					if (dwArg08 != 0x00)
					{
						reflect.(*rtype).String(gs, dwArg08);
						reflect.(*rtype).String(gs, dwArg04);
						runtime.concatstring5(gs, fp - 244);
						dwLoc0128 = dwLoc0140_1205;
						eax_687 = dwLoc0114;
						ecx_688 = dwLoc0118;
					}
					else
					{
						reflect.(*rtype).String(gs, dwArg04);
						runtime.concatstring3(gs, fp - 212);
						eax_687 = dwLoc0124;
						ecx_688 = dwLoc0128;
					}
					Eq_4 edi_770;
					Eq_4 esi_772;
					reflect.resolveReflectName(SLICE(reflect.newName(gs, ecx_688, eax_687, 0x00, 0x00, 0x00, 0x00, out esi_772, out edi_770), word24, 8), esi_772, edi_770, gs, dwLoc0128);
					*((word32) dwLoc0140_1089 + 24) = eax_687;
					runtime.newobject(gs, 0x080D73A0);
					runtime.newobject(gs, 0x080D1160);
					*eax_687 = 0x080AFC20;
					if (g_t81576F0 == 0x00)
						*((word32) eax_687 + 4) = dwLoc0140_1089;
					else
						runtime.writebarrierptr((word32) eax_687 + 4, dwLoc0140_1089);
					Eq_4 ebx_864 = g_t81576F0;
					if (ebx_864 == 0x00)
						*((word32) eax_687 + 8) = eax_687;
					else
						runtime.writebarrierptr((word32) eax_687 + 8, eax_687);
					fn0809026E(0x080F1E50, fp - 0x28);
					word128 xmm1_1533;
					runtime.convT2E(ebx_864, gs, 0x080D3500, fp - 116, out xmm1_1533);
					word128 xmm1_1534;
					runtime.convT2E(fp - 0x28, gs, 0x080D7D20, fp - 0x28, out xmm1_1534);
					word128 xmm1_1535;
					sync.(*Map).LoadOrStore(gs, 0x08145200, 0x00, 0x00, out xmm1_1535);
					fn0808FD8B(0x00, fp - 0x3C);
					runtime.panicdottypeE(gs, 0x00);
				}
			}
		}
	}
	else
	{
		reflect.(*rtype).String(gs, dwArg08);
		runtime.concatstring2(gs, 0x00);
		runtime.convT2Estring(gs, 135066016, fp - 0x6C);
		runtime.gopanic(gs);
	}
}

// 080AB360: void reflect.addTypeBits(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_117940) dwArg04, Stack Eq_4 dwArg08, Stack (ptr32 Eq_117923) dwArg0C)
// Called from:
//      reflect.funcLayout
//      reflect.addTypeBits
void reflect.addTypeBits(struct Eq_2 * gs, struct Eq_117940 * dwArg04, Eq_4 dwArg08, struct Eq_117923 * dwArg0C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	ui32 edx_18 = (word32) dwArg0C->b000F;
	if (((byte) edx_18 & 0x80) != 0x00)
		return;
	if ((edx_18 & 0x1F) <= 0x14)
	{
		if ((edx_18 & 0x1F) == 0x11)
		{
			Eq_118237 ecx_102 = 0x00;
			while (ecx_102 < dwArg0C->t0028)
			{
				struct Eq_117923 * edx_86 = dwArg0C->ptr0020;
				reflect.addTypeBits(gs, dwArg04, (word32) dwArg08 + edx_86->dw0000 *s ecx_102, edx_86);
				ecx_102 = (word32) ecx_102.u0 + 1;
			}
			return;
		}
		if ((edx_18 & 0x1F) > 0x13)
		{
			if ((edx_18 & 0x1F) != 0x14)
				return;
			while (true)
			{
				uint32 edx_315 = dwArg04->dw0000;
				if (edx_315 >= dwArg08 >> 0x02)
					break;
				if ((edx_315 & 0x07) == 0x00)
				{
					Eq_4 edx_530 = dwArg04->t0004;
					Eq_4 ebx_531 = dwArg04->t0008;
					Eq_4 esi_532 = dwArg04->t000C;
					if ((word32) ebx_531 + 1 > esi_532)
					{
						word128 xmm1_1052;
						word128 xmm0_1051;
						word32 esi_1050;
						runtime.growslice(gs, 0x080CF320, edx_530, ebx_531, esi_532, (word32) ebx_531 + 1, out esi_1050, out xmm0_1051, out xmm1_1052);
						dwArg04->t000C = dwLoc28;
						if (g_t81576F0 == 0x00)
							dwArg04->t0004 = dwLoc30;
						else
							runtime.writebarrierptr(&dwArg04->t0004, dwLoc30);
						ebx_531 = dwLoc2C;
						edx_530 = dwLoc30;
					}
					dwArg04->t0008 = (word32) ebx_531 + 1;
					Mem604[edx_530 + ebx_531:byte] = 0x00;
				}
				uint32 ebx_608 = dwArg04->dw0000;
				if (ebx_608 >> 0x03 >= dwArg04->t0008)
					runtime.panicindex(gs);
				dwArg04->dw0000 = ebx_608 + 0x01;
			}
			if ((edx_315 & 0x07) == 0x00)
			{
				Eq_4 edx_324 = dwArg04->t0004;
				Eq_4 ebx_325 = dwArg04->t0008;
				Eq_4 ebp_326 = dwArg04->t000C;
				if ((word32) ebx_325 + 1 > ebp_326)
				{
					word128 xmm1_1055;
					word128 xmm0_1054;
					word32 esi_1053;
					runtime.growslice(gs, 0x080CF320, edx_324, ebx_325, ebp_326, (word32) ebx_325 + 1, out esi_1053, out xmm0_1054, out xmm1_1055);
					dwArg04->t000C = dwLoc28;
					if (g_t81576F0 == 0x00)
						dwArg04->t0004 = dwLoc30;
					else
						runtime.writebarrierptr(&dwArg04->t0004, dwLoc30);
					ebx_325 = dwLoc2C;
					edx_324 = dwLoc30;
				}
				dwArg04->t0008 = (word32) ebx_325 + 1;
				Mem397[edx_324 + ebx_325:byte] = 0x00;
			}
			Eq_4 ebx_401 = dwArg04->t0004;
			uint32 ecx_403 = dwArg04->dw0000;
			if (ecx_403 >> 0x03 >= dwArg04->t0008)
				runtime.panicindex(gs);
			else
			{
				Mem423[ebx_401 + (ecx_403 >>u 0x03):byte] = Mem413[ebx_401 + (ecx_403 >>u 0x03):byte] | 0x01 << (SLICE(ecx_403, byte, 0) & 0x07);
				uint32 edx_424 = dwArg04->dw0000;
				dwArg04->dw0000 = edx_424 + 0x01;
				if ((edx_424 + 0x01 & 0x07) == 0x00)
				{
					Eq_4 edx_430 = dwArg04->t000C;
					Eq_4 ebx_431 = dwArg04->t0008;
					Eq_4 ebp_432 = dwArg04->t0004;
					if ((word32) ebx_431 + 1 > edx_430)
					{
						word128 xmm1_1058;
						word128 xmm0_1057;
						word32 esi_1056;
						runtime.growslice(gs, 0x080CF320, ebp_432, ebx_431, edx_430, (word32) ebx_431 + 1, out esi_1056, out xmm0_1057, out xmm1_1058);
						dwArg04->t000C = dwLoc28;
						if (g_t81576F0 == 0x00)
							dwArg04->t0004 = dwLoc30;
						else
							runtime.writebarrierptr(&dwArg04->t0004, dwLoc30);
						ebp_432 = dwLoc30;
						ebx_431 = dwLoc2C;
					}
					dwArg04->t0008 = (word32) ebx_431 + 1;
					Mem499[ebp_432 + ebx_431:byte] = 0x00;
				}
				Eq_4 ebx_503 = dwArg04->t0004;
				uint32 ecx_504 = dwArg04->dw0000;
				if (ecx_504 >> 0x03 >= dwArg04->t0008)
					runtime.panicindex(gs);
				else
				{
					Mem522[ebx_503 + (ecx_504 >>u 0x03):byte] = Mem501[ebx_503 + (ecx_504 >>u 0x03):byte] | 0x01 << (SLICE(ecx_504, byte, 0) & 0x07);
					++dwArg04->dw0000;
					return;
				}
			}
		}
	}
	else if ((edx_18 & 0x1F) > 0x18)
	{
		if ((edx_18 & 0x1F) == 0x19)
		{
			Eq_118237 ecx_33 = dwArg0C->t0028;
			Eq_118237 edx_35 = 0x00;
			while (edx_35 < ecx_33)
			{
				struct Eq_118691 * ebp_45 = dwArg0C->ptr0024;
				if (edx_35 >= dwArg0C->t0028)
					runtime.panicindex(gs);
				ui32 eax_50 = edx_35 * 0x03;
				reflect.addTypeBits(gs, dwArg04, (word32) dwArg08 + ((ebp_45->a0008)[eax_50] >> 0x01), ebp_45->a0004[eax_50].ptr0000.dw0000);
				edx_35 = (word32) edx_35 + 1;
			}
			return;
		}
		if ((edx_18 & 0x1F) != 0x1A)
			return;
	}
	while (true)
	{
		uint32 edx_110 = dwArg04->dw0000;
		if (edx_110 >= dwArg08 >> 0x02)
			break;
		if ((edx_110 & 0x07) == 0x00)
		{
			Eq_4 edx_222 = dwArg04->t0004;
			Eq_4 ebx_223 = dwArg04->t0008;
			Eq_4 esi_224 = dwArg04->t000C;
			if ((word32) ebx_223 + 1 > esi_224)
			{
				word32 esi_1044;
				word128 xmm0_1045;
				word128 xmm1_1046;
				runtime.growslice(gs, 0x080CF320, edx_222, ebx_223, esi_224, (word32) ebx_223 + 1, out esi_1044, out xmm0_1045, out xmm1_1046);
				dwArg04->t000C = dwLoc28;
				if (g_t81576F0 == 0x00)
					dwArg04->t0004 = dwLoc30;
				else
					runtime.writebarrierptr(&dwArg04->t0004, dwLoc30);
				ebx_223 = dwLoc2C;
				edx_222 = dwLoc30;
			}
			dwArg04->t0008 = (word32) ebx_223 + 1;
			Mem296[edx_222 + ebx_223:byte] = 0x00;
		}
		uint32 ebx_300 = dwArg04->dw0000;
		if (ebx_300 >> 0x03 >= dwArg04->t0008)
			runtime.panicindex(gs);
		dwArg04->dw0000 = ebx_300 + 0x01;
	}
	if ((edx_110 & 0x07) == 0x00)
	{
		Eq_4 edx_119 = dwArg04->t0008;
		Eq_4 ebx_120 = dwArg04->t000C;
		Eq_4 ebp_121 = dwArg04->t0004;
		if ((word32) edx_119 + 1 > ebx_120)
		{
			word32 esi_1047;
			word128 xmm0_1048;
			word128 xmm1_1049;
			runtime.growslice(gs, 0x080CF320, ebp_121, edx_119, ebx_120, (word32) edx_119 + 1, out esi_1047, out xmm0_1048, out xmm1_1049);
			dwArg04->t000C = dwLoc28;
			if (g_t81576F0 == 0x00)
				dwArg04->t0004 = dwLoc30;
			else
				runtime.writebarrierptr(&dwArg04->t0004, dwLoc30);
			edx_119 = dwLoc2C;
			ebp_121 = dwLoc30;
		}
		dwArg04->t0008 = (word32) edx_119 + 1;
		Mem191[ebp_121 + edx_119:byte] = 0x00;
	}
	Eq_4 ebx_195 = dwArg04->t0004;
	uint32 ecx_196 = dwArg04->dw0000;
	if (ecx_196 >> 0x03 >= dwArg04->t0008)
		runtime.panicindex(gs);
	else
	{
		Mem214[ebx_195 + (ecx_196 >>u 0x03):byte] = Mem193[ebx_195 + (ecx_196 >>u 0x03):byte] | 0x01 << (SLICE(ecx_196, byte, 0) & 0x07);
		++dwArg04->dw0000;
	}
}

// 080AB8B0: void reflect.Value.pointer(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg0C)
// Called from:
//      reflect.Value.Len
//      reflect.Value.MapIndex
//      reflect.Value.MapKeys
//      reflect.Value.Pointer
void reflect.Value.pointer(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg0C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (*dwArg04 != 0x04 || (*((word32) dwArg04 + 0x0F) & 0x80) != 0x00)
		runtime.gopanic(gs);
	else if ((dwArg0C & 0x80) == 0x00)
		;
}

// 080AB920: Register word128 reflect.packEface(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C, Register out Eq_118759 xmm1Out)
// Called from:
//      reflect.valueInterface
word128 reflect.packEface(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C, union Eq_118759 & xmm1Out)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if ((*((word32) dwArg04 + 0x0F) & 0x20) == 0x00)
	{
		if ((dwArg0C & 0x80) == 0x00)
			runtime.gopanic(gs);
		if ((dwArg0C & 0x0100) != 0x00)
		{
			reflect.unsafe_New(gs, dwArg04);
			xmm0 = reflect.typedmemmove(gs, dwArg04, dwLoc14, dwArg08, out xmm1);
		}
	}
	xmm1Out = xmm1;
	return xmm0;
}

// 080ABA00: void reflect.(*ValueError).Error(Register (ptr32 ptr32) ebx, Register word32 ebp, Register (ptr32 Eq_23322) esi, Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_118806) dwArg04)
void reflect.(*ValueError).Error(ptr32 * ebx, word32 ebp, struct Eq_23322 * esi, struct Eq_2 * gs, struct Eq_118806 * dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_99008 ecx_18 = dwArg04->t0008;
	if (ecx_18 != 0x00)
	{
		reflect.Kind.String(ebx, ebp, esi, gs, ecx_18);
		runtime.concatstring5(gs, 0x00);
	}
	else
		runtime.concatstring3(gs, 0x00);
}

// 080ABB00: void reflect.methodName(Register (ptr32 Eq_2) gs)
// Called from:
//      reflect.flag.mustBe
//      reflect.flag.mustBeAssignable
void reflect.methodName(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.Caller(gs);
	runtime.FuncForPC(gs, dwLoc14);
	if (dwLoc14 == 0x00)
		return;
	runtime.(*Func).Name(gs, dwLoc14);
}

// 080ABB70: void reflect.flag.mustBe(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack ui32 dwArg08)
// Called from:
//      reflect.Value.Bool
//      reflect.Value.Bytes
//      reflect.Value.runes
//      reflect.Value.MapIndex
//      reflect.Value.MapKeys
//      reflect.Value.NumField
//      reflect.Value.SetBytes
//      reflect.Value.setRunes
//      reflect.Value.SetString
void reflect.flag.mustBe(struct Eq_2 * gs, Eq_4 dwArg04, ui32 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if ((dwArg04 & 0x1F) == dwArg08)
		return;
	reflect.methodName(gs);
	runtime.newobject(gs, 0x080D3140);
	*((word32) dwLoc14 + 4) = dwLoc14;
	if (g_t81576F0 == 0x00)
		*dwLoc14 = dwLoc18;
	else
		runtime.writebarrierptr(dwLoc14, dwLoc18);
	*((word32) dwLoc14 + 8) = dwArg04 & 0x1F;
	runtime.gopanic(gs);
}

// 080ABC20: void reflect.flag.mustBeAssignable(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      reflect.Value.SetBytes
//      reflect.Value.setRunes
//      reflect.Value.SetString
void reflect.flag.mustBeAssignable(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (dwArg04 == 0x00)
	{
		reflect.methodName(gs);
		runtime.newobject(gs, 0x080D3140);
		*((word32) dwLoc3C + 4) = dwLoc3C;
		if (g_t81576F0 == 0x00)
			*dwLoc3C = dwLoc40;
		else
			runtime.writebarrierptr(dwLoc3C, dwLoc40);
		((word32) dwLoc3C + 8)->u0 = 0x00;
		runtime.gopanic(gs);
	}
	else if ((dwArg04 & 0x60) != 0x00)
	{
		reflect.methodName(gs);
		runtime.concatstring3(gs, 0x00);
		runtime.convT2Estring(gs, 135066016, fp - 0x08);
		runtime.gopanic(gs);
	}
	else
	{
		if ((dwArg04 & 0x0100) != 0x00)
			return;
		reflect.methodName(gs);
		runtime.concatstring3(gs, 0x00);
		runtime.convT2Estring(gs, 135066016, fp - 0x10);
		runtime.gopanic(gs);
	}
}

// 080ABDE0: void reflect.Value.Bool(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg0C)
// Called from:
//      fmt.(*pp).printValue
void reflect.Value.Bool(struct Eq_2 * gs, Eq_4 dwArg0C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.flag.mustBe(gs, dwArg0C, 0x01);
}

// 080ABE20: void reflect.Value.Bytes(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C)
// Called from:
//      reflect.cvtBytesString
//      fmt.(*pp).printValue
void reflect.Value.Bytes(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.flag.mustBe(gs, dwArg0C, 0x17);
	reflect.(*rtype).Elem(gs, dwArg04);
	<anonymous> * eax_39 = *(<anonymous> **) 0x6B;
	eax_39();
	runtime.gopanic(gs);
}

// 080ABEB0: void reflect.Value.runes(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack word32 dwArg08, Stack Eq_4 dwArg0C)
// Called from:
//      reflect.cvtRunesString
void reflect.Value.runes(struct Eq_2 * gs, Eq_4 dwArg04, word32 dwArg08, Eq_4 dwArg0C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.flag.mustBe(gs, dwArg0C, 0x17);
	reflect.(*rtype).Elem(gs, dwArg04);
	<anonymous> * eax_39 = *(<anonymous> **) 0x6B;
	eax_39();
	runtime.gopanic(gs);
}

// 080ABF40: void reflect.methodReceiver(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg0C, Stack Eq_4 dwArg10, Stack Eq_4 dwArg18)
// Called from:
//      reflect.makeMethodValue
//      reflect.callMethod
void reflect.methodReceiver(struct Eq_2 * gs, Eq_4 dwArg0C, Eq_4 dwArg10, Eq_4 dwArg18)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (((word32) *((word32) dwArg0C + 0x0F) & 0x1F) != 0x14)
	{
		reflect.(*rtype).uncommon(gs, dwArg0C);
		if (dwLoc50 != null)
		{
			word16 cx_35 = dwLoc50->w0004;
			if (dwArg18 < (word32) cx_35)
			{
				Eq_139089 eax_59[] = dwLoc50 + dwLoc50->dw0008 / 0x0C;
				Eq_4 ecx_62 = (word32) cx_35;
				if (ecx_62 > 0x00010000)
					runtime.panicslice(gs);
				else if (dwArg18 >= ecx_62)
					runtime.panicindex(gs);
				else
				{
					Eq_4 edx_71 = eax_59[dwArg18].t0008;
					Eq_4 eax_73 = eax_59[dwArg18].t0000;
					reflect.(*rtype).nameOff(gs, dwArg0C, eax_73);
					if ((*dwLoc4C & 0x01) == 0x00)
					{
						runtime.concatstring3(gs, 0x00);
						runtime.convT2Estring(gs, 135066016, fp - 0x18);
						runtime.gopanic(gs);
					}
					else
					{
						runtime.newobject(gs, 0x080CF3A0);
						reflect.(*rtype).textOff(gs, dwArg0C, edx_71);
						if (g_t81576F0 == 0x00)
							*eax_73 = dwLoc4C;
						else
							runtime.writebarrierptr(eax_73, dwLoc4C);
						reflect.(*rtype).typeOff(gs);
						return;
					}
				}
			}
		}
		runtime.gopanic(gs);
	}
	else
	{
		Eq_4 ecx_214 = *((word32) dwArg0C + 36);
		if (dwArg18 >= *((word32) dwArg0C + 40))
			runtime.gopanic(gs);
		else
		{
			reflect.(*rtype).nameOff(gs, dwArg0C, *((word32) ecx_214 + dwArg18 * 0x08));
			if ((*dwLoc4C & 0x01) == 0x00)
			{
				runtime.concatstring3(gs, 0x00);
				runtime.convT2Estring(gs, 135066016, fp - 0x08);
				runtime.gopanic(gs);
			}
			else if (*dwArg10 == 0x00)
			{
				runtime.concatstring3(gs, 0x00);
				runtime.convT2Estring(gs, 135066016, fp - 0x10);
				runtime.gopanic(gs);
			}
			else if (dwArg18 >= 100000)
				runtime.panicindex(gs);
			else
				reflect.(*rtype).typeOff(gs);
		}
	}
}

// 080AC2C0: void reflect.callMethod(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_119193) dwArg04, Stack Eq_4 dwArg08)
// Called from:
//      reflect.methodValueCall
void reflect.callMethod(struct Eq_2 * gs, struct Eq_119193 * dwArg04, Eq_4 dwArg08)
{
	while (true)
	{
		Eq_4 ecx_7 = gs->ptr0000->tFFFFFFFC;
		if (fp > *((word32) ecx_7 + 8))
			break;
		runtime.morestack_noctxt();
	}
	ptr32 * ebx_17 = *((word32) ecx_7 + 16);
	if (ebx_17 != null && *ebx_17 == (word32) fp + 4)
		*ebx_17 = fp - 0x48;
	Eq_4 ecx_28 = dwArg04->t000C;
	int32 edx_30 = dwArg04->dw0014;
	Eq_4 ebx_32 = dwArg04->t0010;
	reflect.methodReceiver(gs, ecx_28, ebx_32, dwArg04->t0008);
	reflect.funcLayout(gs, dwLoc2C, dwLoc30);
	word128 xmm1_444;
	sync.(*Pool).Get(gs, dwLoc30, out xmm1_444);
	if (dwLoc30 != 0x080CF3A0)
		runtime.panicdottypeE(gs, dwLoc30);
	else
	{
		ui32 eax_121 = (word32) *((word32) ecx_28 + 0x0F);
		byte bl_130 = (byte) eax_121;
		if ((eax_121 & 0x1F) == 0x14)
		{
			Eq_4 ebx_183 = *((word32) ebx_32 + 4);
			if (g_t81576F0 == 0x00)
				*ecx_28 = ebx_183;
			else
				runtime.writebarrierptr(ecx_28, ebx_183);
		}
		else if ((edx_30 & 0x80) != 0x00 && (bl_130 & 0x20) != 0x00)
		{
			Eq_4 ebx_138 = *ebx_32;
			if (g_t81576F0 == 0x00)
				*ecx_28 = ebx_138;
			else
				runtime.writebarrierptr(ecx_28, ebx_138);
		}
		else if (g_t81576F0 == 0x00)
			*ecx_28 = ebx_32;
		else
			runtime.writebarrierptr(ecx_28, ebx_32);
		if (ebx_32 > ~0x03)
			reflect.typedmemmovepartial(gs, ecx_28, (word32) ecx_28 + 4, dwArg08, 0x04, (word32) ebx_32 - 4);
		reflect.call(*ecx_28);
		Eq_4 ecx_263 = *ecx_28 - edx_30;
		if (ecx_263 > 0x00)
			reflect.typedmemmovepartial(gs, ecx_28, dwArg08 - 0x04 + edx_30, (word32) ecx_28 + edx_30, edx_30, ecx_263);
		reflect.memclrNoHeapPointers(gs, ecx_28, *ecx_28);
		sync.(*Pool).Put(gs, dwLoc30, 0x080CF3A0, ecx_28);
	}
}

// 080AC560: void reflect.Value.Complex(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg0C)
// Called from:
//      reflect.cvtComplex
//      fmt.(*pp).printValue
void reflect.Value.Complex(struct Eq_2 * gs, Eq_4 dwArg0C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if ((dwArg0C & 0x1F) == 0x0F)
		return;
	if ((dwArg0C & 0x1F) == 0x10)
		return;
	runtime.newobject(gs, 0x080D3140);
	*((word32) dwLoc0C + 4) = 0x15;
	if (g_t81576F0 == 0x00)
		*dwLoc0C = 0x080E33DE;
	else
		runtime.writebarrierptr(dwLoc0C, 0x080E33DE);
	*((word32) dwLoc0C + 8) = dwArg0C & 0x1F;
	runtime.gopanic(gs);
}

// 080AC640: void reflect.Value.Elem(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C)
// Called from:
//      reflect.makeString
//      reflect.makeBytes
//      reflect.makeRunes
//      reflect.cvtI2I
//      fmt.getField
//      fmt.(*pp).printValue
void reflect.Value.Elem(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if ((dwArg0C & 0x1F) == 0x14)
	{
		Eq_4 eax_59;
		word128 xmm1_354;
		reflect.(*rtype).NumMethod(gs, dwArg04, out xmm1_354);
		if (dwLoc14 == 0x00)
			eax_59 = *dwArg08;
		else
		{
			Eq_4 ecx_49 = *dwArg08;
			if (ecx_49 != 0x00)
				ecx_49 = *((word32) ecx_49 + 4);
			eax_59 = ecx_49;
		}
		ui32 edx_73;
		if (eax_59 != 0x00)
		{
			ui32 edx_78 = (word32) *((word32) eax_59 + 0x0F);
			edx_73 = edx_78 & 0x1F;
			if (((byte) edx_78 & 0x20) == 0x00)
				edx_73 = edx_78 & 0x1F | 0x80;
		}
		else
			edx_73 = 0x00;
	}
	else if ((dwArg0C & 0x1F) != 22)
	{
		runtime.newobject(gs, 0x080D3140);
		*((word32) dwLoc14 + 4) = 0x12;
		if (g_t81576F0 == 0x00)
			*dwLoc14 = 135146116;
		else
			runtime.writebarrierptr(dwLoc14, 135146116);
		*((word32) dwLoc14 + 8) = dwArg0C & 0x1F;
		runtime.gopanic(gs);
	}
	else
	{
		Eq_4 eax_166;
		if ((dwArg0C & 0x80) != 0x00)
			eax_166 = *dwArg08;
		else
			eax_166 = dwArg08;
		if (eax_166 == 0x00)
			;
	}
}

// 080AC7C0: void reflect.Value.Field(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack ui32 dwArg0C, Stack Eq_4 dwArg10)
// Called from:
//      fmt.getField
void reflect.Value.Field(struct Eq_2 * gs, Eq_4 dwArg04, ui32 dwArg0C, Eq_4 dwArg10)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if ((dwArg0C & 0x1F) != 0x19)
	{
		runtime.newobject(gs, 0x080D3140);
		*((word32) dwLoc0C + 4) = 0x13;
		if (g_t81576F0 == 0x00)
			*dwLoc0C = 0x080E2DAC;
		else
			runtime.writebarrierptr(dwLoc0C, 0x080E2DAC);
		*((word32) dwLoc0C + 8) = dwArg0C & 0x1F;
		runtime.gopanic(gs);
	}
	else
	{
		Eq_4 eax_75 = *((word32) dwArg04 + 36);
		if (dwArg10 >= *((word32) dwArg04 + 40))
			runtime.gopanic(gs);
		else if ((**((word32) eax_75 + dwArg10 * 0x0C) & 0x01) == 0x00)
			(*((word32) eax_75 + (dwArg10 * 0x0C + 8)) & 0x01) == 0x00;
	}
}

// 080AC8E0: void reflect.Value.Float(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg0C)
// Called from:
//      reflect.cvtFloatInt
//      reflect.cvtFloatUint
//      reflect.cvtFloat
//      fmt.(*pp).printValue
void reflect.Value.Float(struct Eq_2 * gs, Eq_4 dwArg0C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if ((dwArg0C & 0x1F) == 0x0D)
		return;
	if ((dwArg0C & 0x1F) == 0x0E)
		return;
	runtime.newobject(gs, 0x080D3140);
	*((word32) dwLoc0C + 4) = 0x13;
	if (g_t81576F0 == 0x00)
		*dwLoc0C = 135146943;
	else
		runtime.writebarrierptr(dwLoc0C, 135146943);
	*((word32) dwLoc0C + 8) = dwArg0C & 0x1F;
	runtime.gopanic(gs);
}

// 080AC9B0: void reflect.Value.Index(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C, Stack Eq_4 dwArg10)
// Called from:
//      fmt.(*pp).printValue
void reflect.Value.Index(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C, Eq_4 dwArg10)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if ((dwArg0C & 0x1F) != 0x11)
	{
		if ((dwArg0C & 0x1F) != 0x17)
		{
			if ((dwArg0C & 0x1F) != 0x18)
			{
				runtime.newobject(gs, 0x080D3140);
				*((word32) dwLoc0C + 4) = 0x13;
				if (g_t81576F0 == 0x00)
					*dwLoc0C = 0x080E2DD2;
				else
					runtime.writebarrierptr(dwLoc0C, 0x080E2DD2);
				*((word32) dwLoc0C + 8) = dwArg0C & 0x1F;
				runtime.gopanic(gs);
			}
			else
			{
				if (dwArg10 < *((word32) dwArg08 + 4))
					return;
				runtime.gopanic(gs);
			}
		}
		else
		{
			if (dwArg10 < *((word32) dwArg08 + 4))
				return;
			runtime.gopanic(gs);
		}
	}
	else
	{
		if (dwArg10 < *((word32) dwArg04 + 40))
			return;
		runtime.gopanic(gs);
	}
}

// 080ACB60: void reflect.Value.Int(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg0C)
// Called from:
//      reflect.cvtInt
//      reflect.cvtIntFloat
//      reflect.cvtIntString
//      fmt.(*pp).printValue
void reflect.Value.Int(struct Eq_2 * gs, Eq_4 dwArg0C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if ((dwArg0C & 0x1F) <= 0x03)
	{
		if ((dwArg0C & 0x1F) == 0x02)
			return;
		if ((dwArg0C & 0x1F) == 0x03)
			return;
	}
	else
	{
		if ((dwArg0C & 0x1F) == 0x04)
			return;
		if ((dwArg0C & 0x1F) == 0x05)
			return;
		if ((dwArg0C & 0x1F) == 0x06)
			return;
	}
	runtime.newobject(gs, 0x080D3140);
	*((word32) dwLoc0C + 4) = 0x11;
	if (g_t81576F0 == 0x00)
		*dwLoc0C = 0x080E2873;
	else
		runtime.writebarrierptr(dwLoc0C, 0x080E2873);
	*((word32) dwLoc0C + 8) = dwArg0C & 0x1F;
	runtime.gopanic(gs);
}

// 080ACC80: void reflect.Value.CanInterface(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg0C)
// Called from:
//      fmt.(*pp).printArg
//      fmt.(*pp).printValue
void reflect.Value.CanInterface(struct Eq_2 * gs, Eq_4 dwArg0C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (dwArg0C != 0x00)
		return;
	runtime.newobject(gs, 0x080D3140);
	*((word32) dwLoc08 + 4) = 0x1A;
	if (g_t81576F0 == 0x00)
		*dwLoc08 = 0x080E4230;
	else
		runtime.writebarrierptr(dwLoc08, 0x080E4230);
	((word32) dwLoc08 + 8)->u0 = 0x00;
	runtime.gopanic(gs);
}

// 080ACD20: Register word128 reflect.Value.Interface(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C, Register out Eq_119787 xmm1Out)
// Called from:
//      fmt.(*pp).printArg
//      fmt.(*pp).printValue
word128 reflect.Value.Interface(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C, union Eq_119787 & xmm1Out)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_119787 xmm1_34;
	word128 xmm0_33 = reflect.valueInterface(gs, dwArg04, dwArg08, dwArg0C, 0x01, out xmm1_34);
	xmm1Out = xmm1_34;
	return xmm0_33;
}

// 080ACD80: Register word128 reflect.valueInterface(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C, Stack byte bArg10, Register out Eq_119809 xmm1Out)
// Called from:
//      reflect.Value.Interface
//      reflect.Value.assignTo
//      reflect.cvtT2I
word128 reflect.valueInterface(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C, byte bArg10, union Eq_119809 & xmm1Out)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 eax_130 = dwArg0C;
	if (dwArg0C == 0x00)
	{
		runtime.newobject(gs, 0x080D3140);
		*((word32) dwLoc20 + 4) = 0x17;
		if (g_t81576F0 == 0x00)
			*dwLoc20 = 135150133;
		else
			runtime.writebarrierptr(dwLoc20, 135150133);
		((word32) dwLoc20 + 8)->u0 = 0x00;
		runtime.gopanic(gs);
	}
	else if (bArg10 == 0x00 || (dwArg0C & 0x60) == 0x00)
	{
		Eq_4 ecx_129;
		Eq_4 edx_128;
		if ((dwArg0C & 0x0200) == 0x00)
		{
			ecx_129 = dwArg08;
			edx_128 = dwArg04;
		}
		else
		{
			reflect.makeMethodValue(gs, dwArg04, dwArg08, dwArg0C);
			dwLoc18 = dwArg08;
			edx_128 = dwLoc10;
			ecx_129 = dwLoc0C;
			eax_130 = dwLoc08;
		}
		if ((eax_130 & 0x1F) != 0x14)
		{
			Eq_119809 xmm1_155;
			word128 xmm0_154 = reflect.packEface(gs, edx_128, ecx_129, eax_130, out xmm1_155);
			xmm1Out = xmm1_155;
			return xmm0_154;
		}
		else
		{
			Eq_119809 xmm1_185;
			word128 xmm0_184 = reflect.Value.NumMethod(gs, edx_128, eax_130, out xmm1_185);
			if (dwLoc18 == 0x00)
			{
				xmm1Out = xmm1_185;
				return xmm0_184;
			}
			else
			{
				*ecx_129 == 0x00;
				xmm1Out = xmm1_185;
				return xmm0_184;
			}
		}
	}
	else
		runtime.gopanic(gs);
}

// 080ACF10: void reflect.Value.IsNil(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg0C)
// Called from:
//      reflect.cvtI2I
//      fmt.getField
//      fmt.(*pp).catchPanic
//      fmt.(*pp).printValue
void reflect.Value.IsNil(struct Eq_2 * gs, Eq_4 dwArg0C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if ((dwArg0C & 0x1F) <= 0x14)
	{
		if ((dwArg0C & 0x1F) <= 0x13 && (dwArg0C & 0x1F) >= 0x12)
		{
l080ACF47:
			if ((dwArg0C & 0x0200) != 0x00)
				return;
			return;
		}
		if ((dwArg0C & 0x1F) == 0x14)
			return;
	}
	else
	{
		if ((dwArg0C & 0x1F) <= 22)
			goto l080ACF47;
		if ((dwArg0C & 0x1F) == 0x17)
			return;
	}
	runtime.newobject(gs, 0x080D3140);
	*((word32) dwLoc0C + 4) = 0x13;
	if (g_t81576F0 == 0x00)
		*dwLoc0C = 0x080E2DE5;
	else
		runtime.writebarrierptr(dwLoc0C, 0x080E2DE5);
	*((word32) dwLoc0C + 8) = dwArg0C & 0x1F;
	runtime.gopanic(gs);
}

// 080AD020: void reflect.Value.Kind(Register (ptr32 Eq_119969) gs)
void reflect.Value.Kind(struct Eq_119969 * gs)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
}

// 080AD050: void reflect.Value.Len(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg0C)
// Called from:
//      reflect.(*Value).Len
//      fmt.(*pp).printValue
void reflect.Value.Len(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg0C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if ((dwArg0C & 0x1F) <= 0x12)
	{
		if ((dwArg0C & 0x1F) == 0x11)
			return;
		if ((dwArg0C & 0x1F) == 0x12)
		{
			reflect.Value.pointer(gs, dwArg04, dwArg0C);
			reflect.chanlen(gs, dwLoc0C);
			return;
		}
	}
	else
	{
		if ((dwArg0C & 0x1F) == 0x15)
		{
			reflect.Value.pointer(gs, dwArg04, dwArg0C);
			reflect.maplen(gs, dwLoc0C);
			return;
		}
		if ((dwArg0C & 0x1F) == 0x17)
			return;
		if ((dwArg0C & 0x1F) == 0x18)
			return;
	}
	runtime.newobject(gs, 0x080D3140);
	*((word32) dwLoc14 + 4) = 0x11;
	if (g_t81576F0 == 0x00)
		*dwLoc14 = 0x080E2884;
	else
		runtime.writebarrierptr(dwLoc14, 0x080E2884);
	*((word32) dwLoc14 + 8) = dwArg0C & 0x1F;
	runtime.gopanic(gs);
}

// 080AD1A0: void reflect.Value.MapIndex(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg0C, Stack Eq_4 dwArg10, Stack Eq_4 dwArg14, Stack Eq_4 dwArg18)
// Called from:
//      fmt.(*pp).printValue
void reflect.Value.MapIndex(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg0C, Eq_4 dwArg10, Eq_4 dwArg14, Eq_4 dwArg18)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	ptr32 eax_70;
	reflect.flag.mustBe(gs, dwArg0C, 0x15);
	reflect.Value.assignTo(gs, dwArg10, dwArg14, dwArg18, *((word32) dwArg04 + 32), 0x00);
	if ((dwLoc18 & 0x80) != 0x00)
		eax_70 = dwLoc1C;
	else
		eax_70 = (word32) fp + 20;
	reflect.Value.pointer(gs, dwArg04, dwArg0C);
	reflect.mapaccess(gs, dwArg04, 135149181, eax_70);
	Eq_4 ecx_115 = *((word32) dwArg04 + 36);
	if ((*((word32) ecx_115 + 0x0F) & 0x20) != 0x00)
		return;
	reflect.unsafe_New(gs, ecx_115);
	word128 xmm1_295;
	reflect.typedmemmove(gs, ecx_115, 135149181, 135149181, out xmm1_295);
}

// 080AD340: void reflect.Value.MapKeys(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C)
// Called from:
//      fmt.(*pp).printValue
void reflect.Value.MapKeys(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 edx_65;
	reflect.flag.mustBe(gs, dwArg0C, 0x15);
	Eq_4 ecx_29 = *((word32) dwArg04 + 32);
	byte dl_32 = *((word32) ecx_29 + 0x0F);
	reflect.Value.pointer(gs, dwArg04, dwArg0C);
	Eq_4 eax_50 = dwArg0C & 0x60 | (word32) dl_32 & 0x1F;
	if (dwLoc44 == 0x00)
		edx_65.u0 = 0x00;
	else
	{
		reflect.maplen(gs, dwLoc44);
		edx_65 = dwArg08;
	}
	reflect.mapiterinit(gs, dwArg04, dwLoc44);
	word32 edi_454;
	runtime.makeslice(gs, 0x080E08C0, edx_65, edx_65, out edi_454);
	Eq_4 dwLoc4C_332 = edx_65;
	Eq_120164 ebx_114 = 0x00;
	while (ebx_114 < dwLoc40)
	{
		reflect.mapiterkey(gs);
		if (dwLoc4C_332 == 0x00)
			break;
		if ((*((word32) ecx_29 + 0x0F) & 0x20) != 0x00)
		{
			Eq_4 eax_240 = *dwLoc4C_332;
			if (ebx_114 >= dwLoc40)
				runtime.panicindex(gs);
			*((word32) dwLoc44 + (ebx_114 * 0x0C + 8)) = eax_50;
			Eq_4 ebx_250 = (word32) dwLoc44 + ebx_114 * 0x0C;
			Eq_4 edx_251 = (word32) dwLoc44 + 4 + ebx_114 * 0x0C;
			if (g_t81576F0 == 0x00)
			{
				*((word32) dwLoc44 + ebx_114 * 0x0C) = ecx_29;
				*((word32) dwLoc44 + (ebx_114 * 0x0C + 4)) = eax_240;
			}
			else
			{
				runtime.writebarrierptr(ebx_250, ecx_29);
				runtime.writebarrierptr(edx_251, eax_240);
				dwLoc4C_332 = eax_240;
			}
		}
		else
		{
			reflect.unsafe_New(gs, ecx_29);
			word128 xmm1_453;
			reflect.typedmemmove(gs, ecx_29, dwLoc4C_332, dwLoc4C_332, out xmm1_453);
			if (ebx_114 >= dwLoc40)
				runtime.panicindex(gs);
			*((word32) dwLoc44 + (ebx_114 * 0x0C + 8)) = eax_50 | 0x80;
			Eq_4 edi_203 = (word32) dwLoc44 + ebx_114 * 0x0C;
			Eq_4 ebp_204 = (word32) dwLoc44 + 4 + ebx_114 * 0x0C;
			if (g_t81576F0 == 0x00)
			{
				*((word32) dwLoc44 + ebx_114 * 0x0C) = ecx_29;
				*((word32) dwLoc44 + (ebx_114 * 0x0C + 4)) = dwLoc4C_332;
			}
			else
			{
				runtime.writebarrierptr(edi_203, ecx_29);
				runtime.writebarrierptr(ebp_204, dwLoc4C_332);
			}
		}
		reflect.mapiternext(gs, dwArg0C);
		ebx_114 = (word32) ebx_114 + 1;
	}
	if (ebx_114 <= dwLoc3C)
		return;
	runtime.panicslice(gs);
}

// 080AD5E0: Register word128 reflect.Value.NumMethod(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg0C, Register out Eq_119875 xmm1Out)
// Called from:
//      reflect.valueInterface
//      reflect.(*Value).NumMethod
word128 reflect.Value.NumMethod(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg0C, union Eq_119875 & xmm1Out)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (dwArg04 == 0x00)
	{
		runtime.newobject(gs, 0x080D3140);
		*((word32) dwLoc08 + 4) = 0x17;
		if (g_t81576F0 == 0x00)
			*dwLoc08 = 135150156;
		else
			runtime.writebarrierptr(dwLoc08, 135150156);
		((word32) dwLoc08 + 8)->u0 = 0x00;
		runtime.gopanic(gs);
	}
	else if ((dwArg0C & 0x0200) == 0x00)
	{
		Eq_119875 xmm1_84;
		word128 xmm0_83 = reflect.(*rtype).NumMethod(gs, dwArg04, out xmm1_84);
		xmm1Out = xmm1_84;
		return xmm0_83;
	}
	else
	{
		xmm1Out = xmm1;
		return xmm0;
	}
}

// 080AD6A0: void reflect.Value.NumField(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg0C)
// Called from:
//      reflect.(*Value).NumField
//      fmt.(*pp).printValue
void reflect.Value.NumField(struct Eq_2 * gs, Eq_4 dwArg0C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.flag.mustBe(gs, dwArg0C, 0x19);
}

// 080AD6E0: void reflect.Value.Pointer(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg0C)
// Called from:
//      fmt.(*pp).fmtPointer
//      fmt.(*pp).printValue
void reflect.Value.Pointer(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg0C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if ((dwArg0C & 0x1F) <= 0x13)
	{
		if ((dwArg0C & 0x1F) == 0x12)
			goto l080AD714;
		if ((dwArg0C & 0x1F) == 0x13)
		{
			if ((dwArg0C & 0x0200) != 0x00)
				return;
			reflect.Value.pointer(gs, dwArg04, dwArg0C);
			return;
		}
	}
	else
	{
		if ((dwArg0C & 0x1F) <= 22)
			goto l080AD714;
		if ((dwArg0C & 0x1F) == 0x17)
			return;
		if ((dwArg0C & 0x1F) == 0x1A)
		{
l080AD714:
			reflect.Value.pointer(gs, dwArg04, dwArg0C);
			return;
		}
	}
	runtime.newobject(gs, 0x080D3140);
	*((word32) dwLoc18 + 4) = 0x15;
	if (g_t81576F0 == 0x00)
		*dwLoc18 = 0x080E33F3;
	else
		runtime.writebarrierptr(dwLoc18, 0x080E33F3);
	*((word32) dwLoc18 + 8) = dwArg0C & 0x1F;
	runtime.gopanic(gs);
}

// 080AD830: void reflect.Value.SetBytes(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C, Stack Eq_4 dwArg10, Stack Eq_4 dwArg14, Stack word32 dwArg18)
// Called from:
//      reflect.makeBytes
void reflect.Value.SetBytes(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C, Eq_4 dwArg10, Eq_4 dwArg14, word32 dwArg18)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.flag.mustBeAssignable(gs, dwArg0C);
	reflect.flag.mustBe(gs, dwArg0C, 0x17);
	reflect.(*rtype).Elem(gs, dwArg04);
	<anonymous> * eax_48 = *(<anonymous> **) 0x6B;
	eax_48();
	runtime.gopanic(gs);
}

// 080AD8F0: void reflect.Value.setRunes(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C, Stack Eq_4 dwArg10, Stack Eq_4 dwArg14, Stack word32 dwArg18)
// Called from:
//      reflect.makeRunes
void reflect.Value.setRunes(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C, Eq_4 dwArg10, Eq_4 dwArg14, word32 dwArg18)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.flag.mustBeAssignable(gs, dwArg0C);
	reflect.flag.mustBe(gs, dwArg0C, 0x17);
	reflect.(*rtype).Elem(gs, dwArg04);
	<anonymous> * eax_48 = *(<anonymous> **) 0x6B;
	eax_48();
	runtime.gopanic(gs);
}

// 080AD9B0: void reflect.Value.SetString(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C, Stack Eq_4 dwArg10, Stack int32 dwArg14)
// Called from:
//      reflect.makeString
void reflect.Value.SetString(struct Eq_2 * gs, Eq_4 dwArg08, Eq_4 dwArg0C, Eq_4 dwArg10, int32 dwArg14)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.flag.mustBeAssignable(gs, dwArg0C);
	reflect.flag.mustBe(gs, dwArg0C, 0x18);
	*((word32) dwArg08 + 4) = dwArg14;
	if (g_t81576F0 == 0x00)
		*dwArg08 = dwArg10;
	else
		runtime.writebarrierptr(dwArg08, dwArg10);
}

// 080ADA20: void reflect.Value.Slice(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C, Stack Eq_4 dwArg10, Stack Eq_4 dwArg14)
// Called from:
//      fmt.(*pp).printValue
void reflect.Value.Slice(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C, Eq_4 dwArg10, Eq_4 dwArg14)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 eax_153;
	Eq_4 ebx_151;
	Eq_4 edx_152;
	if ((dwArg0C & 0x1F) == 0x11)
	{
		if ((dwArg0C & 0x0100) == 0x00)
			runtime.gopanic(gs);
		edx_152 = *((word32) dwArg04 + 40);
		eax_153 = *((word32) dwArg04 + 36);
		ebx_151 = dwArg08;
	}
	else
	{
		if ((dwArg0C & 0x1F) != 0x17)
		{
			if ((dwArg0C & 0x1F) != 0x18)
			{
				runtime.newobject(gs, 0x080D3140);
				*((word32) dwLoc20 + 4) = 0x13;
				if (g_t81576F0 == 0x00)
					dwLoc20->u0 = 0x080E2DF8;
				else
					runtime.writebarrierptr(dwLoc20, 0x080E2DF8);
				*((word32) dwLoc20 + 8) = dwArg0C & 0x1F;
				runtime.gopanic(gs);
			}
			else if (dwArg10 < 0x00 || (dwArg14 < dwArg10 || dwArg14 > *((word32) dwArg08 + 4)))
				runtime.gopanic(gs);
			else
			{
				runtime.newobject(gs, 0x080D3620);
				word32 eax_121 = Mem107[dwArg08 + 0x00:word32] + dwArg10;
				*((word32) dwLoc20 + 4) = dwArg14 - dwArg10;
				if (g_t81576F0 == 0x00)
					*dwLoc20 = eax_121;
				else
					runtime.writebarrierptr(dwLoc20, eax_121);
				return;
			}
		}
		ebx_151 = *dwArg08;
		edx_152 = *((word32) dwArg08 + 8);
		eax_153 = dwArg04;
	}
	if (dwArg10 < 0x00 || (dwArg14 < dwArg10 || dwArg14 > edx_152))
		runtime.gopanic(gs);
	else
	{
		runtime.newobject(gs, 0x080CA300);
		*((word32) dwLoc20 + 4) = dwArg14 - dwArg10;
		Eq_4 ecx_229 = edx_152 - dwArg10;
		*((word32) dwLoc20 + 8) = ecx_229;
		if (ecx_229 > 0x00)
		{
			Eq_4 edx_260 = (word32) ebx_151 + dwArg10 *s *(*((word32) eax_153 + 32));
			if (g_t81576F0 == 0x00)
				*dwLoc20 = edx_260;
			else
				runtime.writebarrierptr(dwLoc20, edx_260);
		}
		else if (g_t81576F0 == 0x00)
			*dwLoc20 = ebx_151;
		else
			runtime.writebarrierptr(dwLoc20, ebx_151);
	}
}

// 080ADCB0: Register word32 reflect.Value.String(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C)
// Called from:
//      reflect.cvtStringBytes
//      reflect.cvtStringRunes
//      reflect.(*Value).String
//      fmt.(*pp).printValue
word32 reflect.Value.String(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if ((dwArg0C & 0x1F) == 0x00)
		return ebx;
	if ((dwArg0C & 0x1F) == 0x18)
		return ebx;
	reflect.Value.Type(gs, dwArg04, dwArg0C);
	<anonymous> * ecx_45 = dwLoc18->ptr0084;
	ecx_45();
	return runtime.concatstring3(gs, 0x00);
}

// 080ADDA0: void reflect.Value.Type(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg0C)
// Called from:
//      reflect.makeMethodValue
//      reflect.Value.String
//      fmt.(*pp).unknownType
//      fmt.(*pp).badVerb
//      fmt.(*pp).fmtPointer
//      fmt.(*pp).printValue
void reflect.Value.Type(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg0C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (dwArg0C == 0x00)
	{
		runtime.newobject(gs, 0x080D3140);
		*((word32) dwLoc10 + 4) = 0x12;
		if (g_t81576F0 == 0x00)
			*dwLoc10 = 135146134;
		else
			runtime.writebarrierptr(dwLoc10, 135146134);
		((word32) dwLoc10 + 8)->u0 = 0x00;
		runtime.gopanic(gs);
	}
	else
	{
		if ((dwArg0C & 0x0200) == 0x00)
			return;
		if (((word32) *((word32) dwArg04 + 0x0F) & 0x1F) != 0x14)
		{
			reflect.(*rtype).uncommon(gs, dwArg04);
			if (dwLoc10 != 0x00)
			{
				Eq_120715 cx_99 = *((word32) dwLoc10 + 4);
				if (dwArg0C >> 0x0A < (word32) cx_99)
				{
					Eq_120759 ecx_126 = (word32) cx_99;
					if (ecx_126 > 0x00010000)
						runtime.panicslice(gs);
					else if (dwArg0C >> 0x0A >= ecx_126)
						runtime.panicindex(gs);
					else
					{
						reflect.(*rtype).typeOff(gs);
						return;
					}
				}
			}
			runtime.gopanic(gs);
		}
		else if (dwArg0C >> 0x0A >= *((word32) dwArg04 + 40))
			runtime.gopanic(gs);
		else
			reflect.(*rtype).typeOff(gs);
	}
}

// 080ADF60: void reflect.Value.Uint(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg0C)
// Called from:
//      reflect.cvtUint
//      reflect.cvtUintFloat
//      reflect.cvtUintString
//      fmt.(*pp).printValue
void reflect.Value.Uint(struct Eq_2 * gs, Eq_4 dwArg0C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if ((dwArg0C & 0x1F) <= 0x09)
	{
		if ((dwArg0C & 0x1F) == 0x07)
			return;
		if ((dwArg0C & 0x1F) == 0x08)
			return;
		if ((dwArg0C & 0x1F) == 0x09)
			return;
	}
	else
	{
		if ((dwArg0C & 0x1F) == 0x0A)
			return;
		if ((dwArg0C & 0x1F) == 11)
			return;
		if ((dwArg0C & 0x1F) == 0x0C)
			return;
	}
	runtime.newobject(gs, 0x080D3140);
	*((word32) dwLoc0C + 4) = 0x12;
	if (g_t81576F0 == 0x00)
		*dwLoc0C = 0x080E2AA8;
	else
		runtime.writebarrierptr(dwLoc0C, 0x080E2AA8);
	*((word32) dwLoc0C + 8) = dwArg0C & 0x1F;
	runtime.gopanic(gs);
}

// 080AE0B0: void reflect.ValueOf(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
// Called from:
//      fmt.(*pp).fmtBytes
//      fmt.(*pp).catchPanic
//      fmt.(*pp).printArg
void reflect.ValueOf(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (dwArg04 == 0x00)
		return;
	if (g_b81450F8 != 0x00)
	{
		g_t81450FC = dwArg04;
		if (g_t81576F0 == 0x00)
			g_t8145100 = dwArg08;
		else
			runtime.writebarrierptr(0x08145100, dwArg08);
	}
	if (dwArg04 != 0x00)
		(*((word32) dwArg04 + 0x0F) & 0x20) != 0x00;
}

// 080AE190: void reflect.Zero(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
// Called from:
//      reflect.cvtI2I
void reflect.Zero(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (dwArg04 == 0x00)
		runtime.gopanic(gs);
	else
	{
		(*((word32) dwArg04 + 0x0088))();
		if ((dwLoc10->b000F & 0x20) != 0x00)
			return;
		if (dwArg04 != 0x08138A00)
			runtime.panicdottypeI(gs, dwArg04);
		else
			reflect.unsafe_New(gs, dwArg08);
	}
}

// 080AE270: void reflect.New(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
// Called from:
//      reflect.makeString
//      reflect.makeBytes
//      reflect.makeRunes
void reflect.New(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (dwArg04 == 0x00)
		runtime.gopanic(gs);
	else if (dwArg04 != 0x08138A00)
		runtime.panicdottypeI(gs, dwArg04);
	else
	{
		reflect.unsafe_New(gs, dwArg08);
		Eq_4 ecx_64 = *((word32) dwArg04 + 0x0088);
		ecx_64();
		reflect.(*rtype).ptrTo(gs, dwLoc0C);
	}
}

// 080AE330: void reflect.Value.assignTo(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C, Stack Eq_4 dwArg18, Stack Eq_4 dwArg1C)
// Called from:
//      reflect.Value.MapIndex
void reflect.Value.assignTo(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C, Eq_4 dwArg18, Eq_4 dwArg1C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 dwLoc44_507;
	Eq_4 edx_52;
	Eq_4 ecx_51;
	Eq_4 eax_17 = dwArg0C;
	if ((dwArg0C & 0x0200) == 0x00)
	{
		ecx_51 = dwArg08;
		edx_52 = dwArg04;
		dwLoc44_507 = dwLoc44;
	}
	else
	{
		reflect.makeMethodValue(gs, dwArg04, dwArg08, dwArg0C);
		dwLoc3C = dwArg0C;
		eax_17 = dwLoc30;
		ecx_51 = dwLoc34;
		edx_52 = dwLoc38;
		dwLoc44_507 = dwArg04;
	}
	reflect.directlyAssignable(gs, dwArg18, edx_52);
	byte bLoc44_384 = (byte) dwLoc44_507;
	if (bLoc44_384 != 0x00)
		return;
	reflect.implements(gs, dwLoc50, dwArg18);
	if (bLoc44_384 == 0x00)
	{
		reflect.(*rtype).String(gs, edx_52);
		reflect.(*rtype).String(gs, dwArg18);
		runtime.concatstring5(gs, 0x00);
		runtime.convT2Estring(gs, 135066016, fp - 0x08);
		runtime.gopanic(gs);
	}
	else
	{
		Eq_4 eax_226 = dwArg1C;
		if (dwArg1C == 0x00)
		{
			reflect.unsafe_New(gs, dwArg18);
			eax_226 = edx_52;
		}
		word128 xmm1_511;
		reflect.valueInterface(gs, edx_52, ecx_51, eax_17, 0x00, out xmm1_511);
		word128 xmm1_512;
		reflect.(*rtype).NumMethod(gs, dwArg18, out xmm1_512);
		if (ecx_51 == 0x00)
		{
			*eax_226 = dwLoc3C;
			if (g_t81576F0 == 0x00)
				*((word32) eax_226 + 4) = dwLoc38;
			else
				runtime.writebarrierptr((word32) eax_226 + 4, dwLoc38);
		}
		else
			reflect.ifaceE2I(gs, dwArg18, dwLoc3C, eax_226);
	}
}

// 080AE5C0: void reflect.convertOp(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
// Called from:
//      reflect.(*sliceType).ConvertibleTo
void reflect.convertOp(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08)
{
	word24 nLoc0B_485 = SLICE(dwLoc0C, word24, 8);
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	ui32 ecx_18 = (word32) *((word32) dwArg08 + 0x0F);
	if ((ecx_18 & 0x1F) <= 0x0E)
	{
		if ((ecx_18 & 0x1F) <= 0x06 && (ecx_18 & 0x1F) >= 0x02)
		{
			ui32 edx_218 = (word32) *((word32) dwArg04 + 0x0F);
			if ((edx_218 & 0x1F) <= 0x0C)
				return;
			if ((edx_218 & 0x1F) <= 0x0E)
				return;
			if ((edx_218 & 0x1F) == 0x18)
				return;
			goto l080AE625;
		}
		if ((ecx_18 & 0x1F) <= 0x0C && (ecx_18 & 0x1F) >= 0x07)
		{
			ui32 edx_195 = (word32) *((word32) dwArg04 + 0x0F);
			if ((edx_195 & 0x1F) <= 0x0C)
				return;
			if ((edx_195 & 0x1F) <= 0x0E)
				return;
			if ((edx_195 & 0x1F) == 0x18)
				return;
			goto l080AE625;
		}
		if ((ecx_18 & 0x1F) <= ~0x0D)
		{
			ui32 edx_171 = (word32) *((word32) dwArg04 + 0x0F);
			if ((edx_171 & 0x1F) <= 0x06)
				return;
			if ((edx_171 & 0x1F) <= 0x0C)
				return;
			if ((edx_171 & 0x1F) <= ~0x0D)
				return;
l080AE625:
			reflect.haveIdenticalUnderlyingType(gs, dwLoc18, dwArg04, (byte) dwArg08);
			Eq_4 bLoc10_625 = (byte) dwArg08;
			word32 dwLoc0C_487 = SEQ(nLoc0B_485, 0x00);
			if (bLoc08 != 0x00)
				return;
			if (((word32) *((word32) dwArg04 + 0x0F) & 0x1F) == 22)
			{
				reflect.(*rtype).Name(gs, dwArg04);
				if (dwLoc0C_487 == 0x00 && ((word32) (*((word32) dwArg08 + 0x0F)) & 0x1F) == 22)
				{
					reflect.(*rtype).Name(gs, dwArg08);
					if (dwLoc0C_487 == 0x00)
					{
						reflect.(*rtype).Elem(gs, dwArg04);
						Eq_4 ecx_328 = *((word32) dwArg08 + 0x0088);
						ecx_328();
						reflect.(*rtype).Elem(gs, dwArg08);
						Eq_4 ecx_349 = *((word32) dwArg08 + 0x0088);
						ecx_349();
						reflect.haveIdenticalUnderlyingType(gs, dwLoc18, dwArg08, bLoc10_625);
						if (bLoc08 != 0x00)
							return;
					}
				}
			}
			reflect.implements(gs, dwLoc18, dwArg04);
			return;
		}
	}
	else
	{
		if ((ecx_18 & 0x1F) <= 0x10 && (ecx_18 & 0x1F) >= 0x0F)
		{
			if (((word32) *((word32) dwArg04 + 0x0F) & 0x1F) <= ~0x0F)
				return;
			goto l080AE625;
		}
		if ((ecx_18 & 0x1F) == 0x17)
		{
			if (((word32) *((word32) dwArg04 + 0x0F) & 0x1F) == 0x18)
			{
				reflect.(*rtype).Elem(gs, dwArg08);
				<anonymous> * eax_104 = dwLoc10->ptr007C;
				eax_104();
				if (dwLoc0C == 0x00)
				{
					reflect.(*rtype).Elem(gs, dwArg08);
					<anonymous> * ecx_125 = dwLoc10->ptr0054;
					ecx_125();
					if (dwLoc10 == (struct Eq_121212 *) 0x05)
						return;
					if (dwLoc10 == (struct Eq_121212 *) 0x08)
						return;
				}
			}
			goto l080AE625;
		}
		if ((ecx_18 & 0x1F) == 0x18)
		{
			if (((word32) *((word32) dwArg04 + 0x0F) & 0x1F) == 0x17)
			{
				reflect.(*rtype).Elem(gs, dwArg04);
				<anonymous> * eax_44 = dwLoc10->ptr007C;
				eax_44();
				if (dwLoc0C == 0x00)
				{
					reflect.(*rtype).Elem(gs, dwArg04);
					<anonymous> * ecx_66 = dwLoc10->ptr0054;
					ecx_66();
					if (dwLoc10 == (struct Eq_121212 *) 0x05)
						return;
					if (dwLoc10 == (struct Eq_121212 *) 0x08)
						return;
				}
			}
			goto l080AE625;
		}
	}
	goto l080AE625;
}

// 080AE9D0: void reflect.makeInt(Register (ptr32 Eq_2) gs, Stack ui32 dwArg04, Stack Eq_4 dwArg08, Stack word32 dwArg0C, Stack (ptr32 Eq_121258) dwArg10, Stack word32 dwArg14)
// Called from:
//      reflect.cvtInt
//      reflect.cvtUint
//      reflect.cvtFloatInt
//      reflect.cvtFloatUint
void reflect.makeInt(struct Eq_2 * gs, ui32 dwArg04, Eq_4 dwArg08, word32 dwArg0C, struct Eq_121258 * dwArg10, word32 dwArg14)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	<anonymous> * eax_19 = dwArg10->ptr0088;
	eax_19();
	reflect.unsafe_New(gs, dwLoc08);
	Eq_4 edx_40 = *dwLoc08;
	if (edx_40 <= 0x02)
	{
		if (edx_40 == 0x01)
			*dwLoc08 = (byte) dwArg08;
		else if (edx_40 == 0x02)
			*dwLoc08 = (word16) dwArg08;
	}
	else if (edx_40 == 0x04)
		*dwLoc08 = dwArg08;
	else if (edx_40 == 0x08)
	{
		*dwLoc08 = dwArg08;
		*((word32) dwLoc08 + 4) = dwArg0C;
	}
}

// 080AEA90: void reflect.makeFloat(Register (ptr32 Eq_2) gs, Stack ui32 dwArg04, Stack real64 rArg08, Stack (ptr32 Eq_121313) dwArg10, Stack word32 dwArg14)
// Called from:
//      reflect.cvtIntFloat
//      reflect.cvtUintFloat
//      reflect.cvtFloat
void reflect.makeFloat(struct Eq_2 * gs, ui32 dwArg04, real64 rArg08, struct Eq_121313 * dwArg10, word32 dwArg14)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	<anonymous> * eax_19 = dwArg10->ptr0088;
	eax_19();
	reflect.unsafe_New(gs, dwLoc08);
	Eq_121334 edx_40 = *dwLoc08;
	if (edx_40 == 0x04)
		*dwLoc08 = (real32) (real64) (uint128) rArg08;
	else if (edx_40 == 0x08)
		*dwLoc08 = (real64) (uint128) rArg08;
}

// 080AEB30: void reflect.makeComplex(Register (ptr32 Eq_2) gs, Stack ui32 dwArg04, Stack real64 rArg08, Stack real64 rArg10, Stack (ptr32 Eq_121357) dwArg18, Stack word32 dwArg1C)
// Called from:
//      reflect.cvtComplex
void reflect.makeComplex(struct Eq_2 * gs, ui32 dwArg04, real64 rArg08, real64 rArg10, struct Eq_121357 * dwArg18, word32 dwArg1C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	<anonymous> * eax_19 = dwArg18->ptr0088;
	eax_19();
	reflect.unsafe_New(gs, dwLoc08);
	Eq_121378 edx_40 = *dwLoc08;
	if (edx_40 == 0x08)
	{
		*dwLoc08 = (real32) (real64) (uint128) rArg08;
		*((word32) dwLoc08 + 4) = (real32) (real64) (uint128) rArg10;
	}
	else if (edx_40 == 0x10)
	{
		*dwLoc08 = (real64) (uint128) rArg08;
		*((word32) dwLoc08 + 8) = (real64) (uint128) rArg10;
	}
}

// 080AEBF0: void reflect.makeString(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg08, Stack int32 dwArg0C, Stack Eq_4 dwArg10, Stack Eq_4 dwArg14)
// Called from:
//      reflect.cvtIntString
//      reflect.cvtUintString
//      reflect.cvtBytesString
//      reflect.cvtRunesString
void reflect.makeString(struct Eq_2 * gs, Eq_4 dwArg08, int32 dwArg0C, Eq_4 dwArg10, Eq_4 dwArg14)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.New(gs, dwArg10, dwArg14);
	reflect.Value.Elem(gs, dwLoc1C, dwLoc18, dwLoc14);
	reflect.Value.SetString(gs, dwLoc14, dwLoc10, dwArg08, dwArg0C);
}

// 080AECB0: void reflect.makeBytes(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C, Stack word32 dwArg10, Stack Eq_4 dwArg14, Stack Eq_4 dwArg18)
// Called from:
//      reflect.cvtStringBytes
void reflect.makeBytes(struct Eq_2 * gs, Eq_4 dwArg08, Eq_4 dwArg0C, word32 dwArg10, Eq_4 dwArg14, Eq_4 dwArg18)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.New(gs, dwArg14, dwArg18);
	reflect.Value.Elem(gs, dwLoc1C, dwLoc18, dwLoc14);
	reflect.Value.SetBytes(gs, dwLoc18, dwLoc14, dwLoc10, dwArg08, dwArg0C, dwArg10);
}

// 080AED70: void reflect.makeRunes(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C, Stack word32 dwArg10, Stack Eq_4 dwArg14, Stack Eq_4 dwArg18)
// Called from:
//      reflect.cvtStringRunes
void reflect.makeRunes(struct Eq_2 * gs, Eq_4 dwArg08, Eq_4 dwArg0C, word32 dwArg10, Eq_4 dwArg14, Eq_4 dwArg18)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.New(gs, dwArg14, dwArg18);
	reflect.Value.Elem(gs, dwLoc1C, dwLoc18, dwLoc14);
	reflect.Value.setRunes(gs, dwLoc18, dwLoc14, dwLoc10, dwArg08, dwArg0C, dwArg10);
}

// 080AEE30: void reflect.cvtInt(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg0C, Stack (ptr32 Eq_121258) dwArg10, Stack word32 dwArg14)
void reflect.cvtInt(struct Eq_2 * gs, Eq_4 dwArg0C, struct Eq_121258 * dwArg10, word32 dwArg14)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.Value.Int(gs, dwArg0C);
	reflect.makeInt(gs, dwArg0C & 0x60, dwLoc14, dwLoc10, dwArg10, dwArg14);
}

// 080AEEC0: void reflect.cvtUint(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg0C, Stack (ptr32 Eq_121258) dwArg10, Stack word32 dwArg14)
void reflect.cvtUint(struct Eq_2 * gs, Eq_4 dwArg0C, struct Eq_121258 * dwArg10, word32 dwArg14)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.Value.Uint(gs, dwArg0C);
	reflect.makeInt(gs, dwArg0C & 0x60, dwLoc14, dwLoc10, dwArg10, dwArg14);
}

// 080AEF50: void reflect.cvtFloatInt(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg0C, Stack (ptr32 Eq_121258) dwArg10, Stack word32 dwArg14)
void reflect.cvtFloatInt(struct Eq_2 * gs, Eq_4 dwArg0C, struct Eq_121258 * dwArg10, word32 dwArg14)
{
	word32 dwLoc14_84 = (word32) rLoc14;
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.Value.Float(gs, dwArg0C);
	word128 xmm0_107;
	runtime.float64toint64(gs, (real64) (uint128) rLoc14, out xmm0_107);
	reflect.makeInt(gs, dwArg0C & 0x60, dwArg0C, dwLoc14_84, dwArg10, dwArg14);
}

// 080AEFF0: void reflect.cvtFloatUint(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg0C, Stack (ptr32 Eq_121258) dwArg10, Stack word32 dwArg14)
void reflect.cvtFloatUint(struct Eq_2 * gs, Eq_4 dwArg0C, struct Eq_121258 * dwArg10, word32 dwArg14)
{
	word32 dwLoc14_84 = (word32) rLoc14;
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.Value.Float(gs, dwArg0C);
	runtime.float64touint64(gs, (real64) (uint128) rLoc14);
	reflect.makeInt(gs, dwArg0C & 0x60, dwArg0C, dwLoc14_84, dwArg10, dwArg14);
}

// 080AF090: void reflect.cvtIntFloat(Register word24 ebx_24_8, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg0C, Stack (ptr32 Eq_121313) dwArg10, Stack word32 dwArg14)
void reflect.cvtIntFloat(word24 ebx_24_8, struct Eq_2 * gs, Eq_4 dwArg0C, struct Eq_121313 * dwArg10, word32 dwArg14)
{
	word32 dwLoc14 = (word32) qwLoc14;
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.Value.Int(gs, dwArg0C);
	runtime.int64tofloat64(ebx_24_8, gs, qwLoc14);
	reflect.makeFloat(gs, dwArg0C & 0x60, (real64) (uint128) SEQ(dwLoc14, dwArg0C), dwArg10, dwArg14);
}

// 080AF130: void reflect.cvtUintFloat(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg0C, Stack (ptr32 Eq_121313) dwArg10, Stack word32 dwArg14)
void reflect.cvtUintFloat(struct Eq_2 * gs, Eq_4 dwArg0C, struct Eq_121313 * dwArg10, word32 dwArg14)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.Value.Uint(gs, dwArg0C);
	runtime.uint64tofloat64(gs, dwLoc10);
	reflect.makeFloat(gs, dwArg0C & 0x60, (real64) (uint128) SEQ(dwLoc14, dwArg0C), dwArg10, dwArg14);
}

// 080AF1D0: void reflect.cvtFloat(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg0C, Stack (ptr32 Eq_121313) dwArg10, Stack word32 dwArg14)
void reflect.cvtFloat(struct Eq_2 * gs, Eq_4 dwArg0C, struct Eq_121313 * dwArg10, word32 dwArg14)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.Value.Float(gs, dwArg0C);
	reflect.makeFloat(gs, dwArg0C & 0x60, (real64) (uint128) rLoc14, dwArg10, dwArg14);
}

// 080AF250: void reflect.cvtComplex(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg0C, Stack (ptr32 Eq_121357) dwArg10, Stack word32 dwArg14)
void reflect.cvtComplex(struct Eq_2 * gs, Eq_4 dwArg0C, struct Eq_121357 * dwArg10, word32 dwArg14)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.Value.Complex(gs, dwArg0C);
	reflect.makeComplex(gs, dwArg0C & 0x60, (real64) (uint128) rLoc1C, (real64) (uint128) rLoc14, dwArg10, dwArg14);
}

// 080AF2E0: void reflect.cvtIntString(Register Eq_4 ebx, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg0C, Stack Eq_4 dwArg10, Stack Eq_4 dwArg14)
void reflect.cvtIntString(Eq_4 ebx, struct Eq_2 * gs, Eq_4 dwArg0C, Eq_4 dwArg10, Eq_4 dwArg14)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.Value.Int(gs, dwArg0C);
	runtime.intstring(ebx, gs, null, dwLoc14, dwLoc10);
	reflect.makeString(gs, dwLoc14, dwLoc10, dwArg10, dwArg14);
}

// 080AF390: void reflect.cvtUintString(Register Eq_4 ebx, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg0C, Stack Eq_4 dwArg10, Stack Eq_4 dwArg14)
void reflect.cvtUintString(Eq_4 ebx, struct Eq_2 * gs, Eq_4 dwArg0C, Eq_4 dwArg10, Eq_4 dwArg14)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.Value.Uint(gs, dwArg0C);
	runtime.intstring(ebx, gs, null, dwLoc14, dwLoc10);
	reflect.makeString(gs, dwLoc14, dwLoc10, dwArg10, dwArg14);
}

// 080AF440: void reflect.cvtBytesString(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C, Stack Eq_4 dwArg10, Stack Eq_4 dwArg14)
void reflect.cvtBytesString(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C, Eq_4 dwArg10, Eq_4 dwArg14)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.Value.Bytes(gs, dwArg04, dwArg08, dwArg0C);
	runtime.slicebytetostring(gs, 0x00, dwLoc14, dwLoc10);
	reflect.makeString(gs, dwLoc10, dwLoc0C, dwArg10, dwArg14);
}

// 080AF4F0: void reflect.cvtStringBytes(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C, Stack Eq_4 dwArg10, Stack Eq_4 dwArg14)
void reflect.cvtStringBytes(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C, Eq_4 dwArg10, Eq_4 dwArg14)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.stringtoslicebyte(reflect.Value.String(gs, dwArg04, dwArg08, dwArg0C), gs, dwLoc28, null, dwLoc18, dwLoc14);
	reflect.makeBytes(gs, dwLoc18, dwLoc14, dwLoc10, dwArg10, dwArg14);
}

// 080AF5A0: void reflect.cvtRunesString(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack word32 dwArg08, Stack Eq_4 dwArg0C, Stack Eq_4 dwArg10, Stack Eq_4 dwArg14)
void reflect.cvtRunesString(struct Eq_2 * gs, Eq_4 dwArg04, word32 dwArg08, Eq_4 dwArg0C, Eq_4 dwArg10, Eq_4 dwArg14)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.Value.runes(gs, dwArg04, dwArg08, dwArg0C);
	runtime.slicerunetostring(gs, 0x00, dwLoc14, dwLoc10);
	reflect.makeString(gs, dwLoc10, dwLoc0C, dwArg10, dwArg14);
}

// 080AF650: void reflect.cvtStringRunes(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C, Stack Eq_4 dwArg10, Stack Eq_4 dwArg14)
void reflect.cvtStringRunes(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C, Eq_4 dwArg10, Eq_4 dwArg14)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.stringtoslicerune(reflect.Value.String(gs, dwArg04, dwArg08, dwArg0C), gs, dwLoc28, null, dwLoc18, dwLoc14);
	reflect.makeRunes(gs, dwLoc18, dwLoc14, dwLoc10, dwArg10, dwArg14);
}

// 080AF700: void reflect.cvtDirect(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg08, Stack ui32 dwArg0C, Stack (ptr32 Eq_121903) dwArg10, Stack word32 dwArg14)
void reflect.cvtDirect(struct Eq_2 * gs, Eq_4 dwArg08, ui32 dwArg0C, struct Eq_121903 * dwArg10, word32 dwArg14)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	<anonymous> * eax_19 = dwArg10->ptr0088;
	eax_19();
	if ((dwArg0C & 0x0100) != 0x00)
	{
		reflect.unsafe_New(gs, dwLoc10);
		word128 xmm1_152;
		reflect.typedmemmove(gs, dwLoc10, dwLoc10, dwArg08, out xmm1_152);
	}
}

// 080AF7A0: void reflect.cvtT2I(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C, Stack Eq_4 dwArg10, Stack Eq_4 dwArg14)
// Called from:
//      reflect.cvtI2I
void reflect.cvtT2I(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C, Eq_4 dwArg10, Eq_4 dwArg14)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	(*((word32) dwArg10 + 0x0088))();
	reflect.unsafe_New(gs, dwLoc20);
	word128 xmm1_226;
	reflect.valueInterface(gs, dwArg04, dwArg08, dwArg0C, 0x00, out xmm1_226);
	(*((word32) dwArg10 + 112))();
	Eq_4 dwLoc20_175 = dwArg08;
	if (dwArg08 == 0x00)
	{
		*dwLoc20 = dwLoc14;
		if (g_t81576F0 == 0x00)
			*((word32) dwLoc20 + 4) = dwLoc10;
		else
		{
			runtime.writebarrierptr((word32) dwLoc20 + 4, dwLoc10);
			dwLoc20_175 = dwLoc10;
		}
	}
	else
	{
		if (dwArg10 != 0x08138A00)
			runtime.panicdottypeI(gs, dwArg10);
		reflect.ifaceE2I(gs, dwArg14, dwLoc14, dwLoc20);
		dwLoc20_175 = dwLoc14;
	}
	Eq_4 eax_141 = *((word32) dwArg10 + 0x0088);
	eax_141();
}

// 080AF900: void reflect.cvtI2I(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C, Stack Eq_4 dwArg10, Stack Eq_4 dwArg14)
void reflect.cvtI2I(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C, Eq_4 dwArg10, Eq_4 dwArg14)
{
	byte bLoc14 = (byte) dwLoc14;
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.Value.IsNil(gs, dwArg0C);
	if (bLoc14 == 0x00)
	{
		reflect.Value.Elem(gs, dwArg04, dwArg08, dwArg0C);
		reflect.cvtT2I(gs, dwLoc14, dwLoc10, dwLoc0C, dwArg10, dwArg14);
	}
	else
		reflect.Zero(gs, dwArg10, dwArg14);
}

// 080AF9F0: void reflect.(*structType).FieldByName.func1(Register Eq_4 edx, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg00, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
void reflect.(*structType).FieldByName.func1(Eq_4 edx, struct Eq_2 * gs, Eq_4 dwArg00, Eq_4 dwArg04, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
	{
		word32 esi_100;
		word32 ebx_99;
		edx = runtime.morestack(edx, gs, dwLoc04, dwArg00, out ebx_99, out esi_100);
	}
	Eq_4 eax_25 = *((word32) edx + 4);
	if (dwArg08 == *((word32) edx + 8))
	{
		word32 ebx_101;
		word32 esi_102;
		word32 edi_103;
		runtime.eqstring(dwArg08, dwArg04, dwArg08, eax_25, out ebx_101, out esi_102, out edi_103);
	}
}

// 080AFA50: void reflect.FuncOf.func1(Register Eq_4 edx, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg00, Stack Eq_4 dwArg04)
void reflect.FuncOf.func1(Eq_4 edx, struct Eq_2 * gs, Eq_4 dwArg00, Eq_4 dwArg04)
{
	byte bLoc3C = (byte) dwLoc3C;
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
	{
		word32 ebx_304;
		word32 esi_305;
		edx = runtime.morestack(edx, gs, dwLoc04, dwArg00, out ebx_304, out esi_305);
	}
	Eq_4 ecx_106;
	Eq_4 edx_57;
	Eq_4 ebx_53;
	sync.(*Map).Load(gs, 135549544, 0x080CF2A0, fp - 0x20);
	Eq_4 dwLoc48_241 = fp - 0x20;
	if (bLoc3C != 0x00)
	{
		if (dwLoc44 != 0x080C9000)
			runtime.panicdottypeE(gs, dwLoc44);
		ecx_106 = dwLoc40->t0000;
		ebx_53 = dwLoc40->t0004;
		edx_57 = dwLoc40->t0008;
	}
	else
	{
		ebx_53.u0 = 0x00;
		ecx_106.u0 = 0x00;
		edx_57.u0 = 0x00;
	}
	Eq_4 ebp_73 = (byte) ebx_53.u0 + 1;
	if (ebp_73 > edx_57)
	{
		word128 xmm1_308;
		word32 esi_306;
		word128 xmm0_307;
		runtime.growslice(gs, 0x080DDF40, ecx_106, ebx_53, edx_57, ebp_73, out esi_306, out xmm0_307, out xmm1_308);
		dwLoc48_241 = ebx_53;
		dwLoc44 = edx_57;
		ecx_106 = dwLoc3C;
	}
	Eq_4 esi_114 = (byte) ecx_106.u0 + ebx_53 * 0x04;
	if (g_t81576F0 == 0x00)
		*((byte) ecx_106.u0 + ebx_53 * 0x04) = dwArg04;
	else
		runtime.writebarrierptr(esi_114, dwArg04);
	runtime.convT2Eslice(runtime.convT2E32(ebx_53, gs, 0x080CF2A0, fp - 0x1C), gs, 0x080C9000, fp - 0x0C);
	sync.(*Map).Store(gs, 135549544, dwLoc48_241, dwLoc44, dwLoc48_241, dwLoc44);
}

// 080AFC20: void reflect.funcLayout.func1(Register Eq_4 edx, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg00)
void reflect.funcLayout.func1(Eq_4 edx, struct Eq_2 * gs, Eq_4 dwArg00)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
	{
		word32 esi_65;
		word32 ebx_64;
		edx = runtime.morestack(edx, gs, dwLoc04, dwArg00, out ebx_64, out esi_65);
	}
	reflect.unsafe_New(gs, *((word32) edx + 4));
}

// 080AFC60: void reflect.init(Register (ptr32 Eq_2) gs)
// Called from:
//      fmt.init
void reflect.init(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	cu8 al_18 = g_b8157565;
	if (al_18 > 0x01)
		return;
	if (al_18 != 0x01)
	{
		g_b8157565 = 0x01;
		word32 edi_213;
		word32 esi_212;
		runtime.init(gs, out esi_212, out edi_213);
		strconv.init(gs);
		Eq_4 edi_46;
		Eq_4 esi_48;
		unicode.init(sync.init(gs, out esi_48, out edi_46), esi_48, edi_46, gs);
		reflect.TypeOf(gs, 0x080CF320);
		if (dwLoc08 != 0x08138A00)
			runtime.panicdottypeI(gs, dwLoc08);
		else
		{
			if (g_t81576F0 == 0x00)
				reflect.uint8Type = dwLoc04;
			else
				runtime.writebarrierptr(135548828, dwLoc04);
			g_b8157565 = 0x02;
		}
	}
	else
		runtime.throwinit(gs);
}

// 080AFD40: void reflect.methodValueCall(Register (ptr32 Eq_119193) edx, Register (ptr32 Eq_2) gs)
void reflect.methodValueCall(struct Eq_119193 * edx, struct Eq_2 * gs)
{
	ptr32 * ebx_9 = *((word32) gs->ptr0000->tFFFFFFFC + 16);
	if (ebx_9 != null && *ebx_9 == fp + 0x04)
		*ebx_9 = fp - 0x08;
	reflect.callMethod(gs, edx, fp + 0x04);
}

// 080AFD80: void reflect.(*ChanDir).String(Register word32 ebp, Register (ptr32 Eq_23322) esi, Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_99008) dwArg04)
void reflect.(*ChanDir).String(word32 ebp, struct Eq_23322 * esi, struct Eq_2 * gs, union Eq_99008 * dwArg04)
{
	while (true)
	{
		Eq_4 ecx_7 = gs->ptr0000->tFFFFFFFC;
		if (fp > *((word32) ecx_7 + 8))
			break;
		runtime.morestack_noctxt();
	}
	ptr32 * ebx_17 = *((word32) ecx_7 + 16);
	if (ebx_17 != null && *ebx_17 == (word32) fp + 4)
		*ebx_17 = fp - 0x0C;
	if (dwArg04 == null)
		runtime.panicwrap(gs);
	else
		reflect.ChanDir.String(ebx_17, ebp, esi, gs, *dwArg04);
}

// 080AFDE0: void reflect.(*Kind).String(Register word32 ebp, Register (ptr32 Eq_23322) esi, Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_99008) dwArg04)
void reflect.(*Kind).String(word32 ebp, struct Eq_23322 * esi, struct Eq_2 * gs, union Eq_99008 * dwArg04)
{
	while (true)
	{
		Eq_4 ecx_7 = gs->ptr0000->tFFFFFFFC;
		if (fp > *((word32) ecx_7 + 8))
			break;
		runtime.morestack_noctxt();
	}
	ptr32 * ebx_17 = *((word32) ecx_7 + 16);
	if (ebx_17 != null && *ebx_17 == (word32) fp + 4)
		*ebx_17 = fp - 0x0C;
	if (dwArg04 == null)
		runtime.panicwrap(gs);
	else
		reflect.Kind.String(ebx_17, ebp, esi, gs, *dwArg04);
}

// 080AFE40: void type..hash.reflect.uncommonType(Register (ptr32 Eq_2) gs, Register Eq_4 mm0, Stack (ptr32 Eq_205) dwArg04, Stack (ptr32 Eq_205) dwArg08)
void type..hash.reflect.uncommonType(struct Eq_2 * gs, Eq_4 mm0, union Eq_205 * dwArg04, union Eq_205 * dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	word128 xmm1_94;
	word128 xmm1_95;
	runtime.memhash(gs, runtime.memhash(gs, mm0, dwArg04, dwArg08, 0x06, out xmm1_94), (char *) dwArg04 + 8, dwLoc04, 0x04, out xmm1_95);
}

// 080AFEB0: void type..eq.reflect.uncommonType(Register (ptr32 Eq_122398) gs, Stack (ptr32 Eq_122399) dwArg04, Stack (ptr32 Eq_122400) dwArg08)
void type..eq.reflect.uncommonType(struct Eq_122398 * gs, struct Eq_122399 * dwArg04, struct Eq_122400 * dwArg08)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	if (dwArg04->dw0000 == dwArg08->dw0000)
		dwArg04->w0004 != dwArg08->w0004;
}

// 080AFF00: void reflect.(*Value).Kind(Register (ptr32 Eq_2) gs, Stack word32 dwArg04)
void reflect.(*Value).Kind(struct Eq_2 * gs, word32 dwArg04)
{
	while (true)
	{
		Eq_4 ecx_7 = gs->ptr0000->tFFFFFFFC;
		if (fp > *((word32) ecx_7 + 8))
			break;
		runtime.morestack_noctxt();
	}
	struct Eq_122442 * ebx_16 = *((word32) ecx_7 + 16);
	if (ebx_16 != null && ebx_16->t0000 == (word32) fp + 4)
		ebx_16->t0000 = fp;
	if (dwArg04 != 0x00)
		return;
	runtime.panicwrap(gs);
}

// 080AFF50: void reflect.(*Value).Len(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_122462) dwArg04)
void reflect.(*Value).Len(struct Eq_2 * gs, struct Eq_122462 * dwArg04)
{
	while (true)
	{
		Eq_4 ecx_7 = gs->ptr0000->tFFFFFFFC;
		if (fp > *((word32) ecx_7 + 8))
			break;
		runtime.morestack_noctxt();
	}
	ptr32 * ebx_17 = *((word32) ecx_7 + 16);
	if (ebx_17 != null && *ebx_17 == (word32) fp + 4)
		*ebx_17 = fp - 0x10;
	if (dwArg04 == null)
		runtime.panicwrap(gs);
	else
		reflect.Value.Len(gs, dwArg04->t0000, dwArg04->t0008);
}

// 080AFFC0: void reflect.(*Value).NumMethod(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_122507) dwArg04)
void reflect.(*Value).NumMethod(struct Eq_2 * gs, struct Eq_122507 * dwArg04)
{
	while (true)
	{
		Eq_4 ecx_7 = gs->ptr0000->tFFFFFFFC;
		if (fp > *((word32) ecx_7 + 8))
			break;
		runtime.morestack_noctxt();
	}
	ptr32 * ebx_17 = *((word32) ecx_7 + 16);
	if (ebx_17 != null && *ebx_17 == (word32) fp + 4)
		*ebx_17 = fp - 0x10;
	if (dwArg04 == null)
		runtime.panicwrap(gs);
	else
	{
		word128 xmm1_78;
		reflect.Value.NumMethod(gs, dwArg04->t0000, dwArg04->t0008, out xmm1_78);
	}
}

// 080B0030: void reflect.(*Value).NumField(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_122553) dwArg04)
void reflect.(*Value).NumField(struct Eq_2 * gs, struct Eq_122553 * dwArg04)
{
	while (true)
	{
		Eq_4 ecx_7 = gs->ptr0000->tFFFFFFFC;
		if (fp > *((word32) ecx_7 + 8))
			break;
		runtime.morestack_noctxt();
	}
	ptr32 * ebx_17 = *((word32) ecx_7 + 16);
	if (ebx_17 != null && *ebx_17 == (word32) fp + 4)
		*ebx_17 = fp - 0x10;
	if (dwArg04 == null)
		runtime.panicwrap(gs);
	else
		reflect.Value.NumField(gs, dwArg04->t0008);
}

// 080B00A0: void reflect.(*Value).String(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_122595) dwArg04)
void reflect.(*Value).String(struct Eq_2 * gs, struct Eq_122595 * dwArg04)
{
	while (true)
	{
		Eq_4 ecx_7 = gs->ptr0000->tFFFFFFFC;
		if (fp > *((word32) ecx_7 + 8))
			break;
		runtime.morestack_noctxt();
	}
	ptr32 * ebx_17 = *((word32) ecx_7 + 16);
	if (ebx_17 != null && *ebx_17 == (word32) fp + 4)
		*ebx_17 = fp - 0x14;
	if (dwArg04 == null)
		runtime.panicwrap(gs);
	else
		reflect.Value.String(gs, dwArg04->t0000, dwArg04->t0004, dwArg04->t0008);
}

// 080B0110: void type..hash.reflect.Method(Register (ptr32 Eq_2) gs, Register Eq_4 mm0, Stack (ptr32 Eq_636) dwArg04, Stack (ptr32 Eq_205) dwArg08)
void type..hash.reflect.Method(struct Eq_2 * gs, Eq_4 mm0, struct Eq_636 * dwArg04, union Eq_205 * dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 mm0_54 = runtime.strhash(gs, runtime.strhash(gs, mm0, dwArg04, dwArg08), (char *) &dwArg04->t0004 + 4, dwLoc08);
	runtime.interhash(gs, (char *) &dwArg04->t0004 + 0x0C, dwLoc08);
	word128 xmm1_135;
	runtime.memhash(gs, mm0_54, (char *) &dwArg04->t0004 + 20, dwLoc08, 0x10, out xmm1_135);
}

// 080B01A0: void type..eq.reflect.Method(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_122677) dwArg04, Stack Eq_4 dwArg08)
void type..eq.reflect.Method(struct Eq_2 * gs, struct Eq_122677 * dwArg04, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	byte cl_45;
	Eq_4 ecx_18 = dwArg04->t0000;
	Eq_4 ebx_20 = *dwArg08;
	Eq_4 ebp_21 = *((word32) dwArg08 + 4);
	Eq_4 esi_22 = dwArg04->t0004;
	if (esi_22 != ebp_21)
		cl_45 = 0x00;
	else
	{
		word32 edi_273;
		word32 ebx_271;
		word32 esi_272;
		runtime.eqstring(dwArg08, ecx_18, esi_22, ebx_20, out ebx_271, out esi_272, out edi_273);
		bLoc08 = (byte) ebp_21;
		cl_45 = bLoc04;
	}
	byte cl_84;
	if (cl_45 != 0x00)
	{
		Eq_4 ecx_56 = *((word32) dwArg08 + 8);
		Eq_4 ebx_58 = dwArg04->t000C;
		Eq_4 ebp_59 = dwArg04->t0008;
		Eq_4 esi_60 = *((word32) dwArg08 + 0x0C);
		if (ebx_58 != esi_60)
			cl_84 = 0x00;
		else
		{
			word32 ebx_274;
			word32 esi_275;
			word32 edi_276;
			runtime.eqstring(dwArg08, ebp_59, ebx_58, ecx_56, out ebx_274, out esi_275, out edi_276);
			bLoc08 = (byte) esi_60;
			cl_84 = bLoc04;
		}
	}
	else
		cl_84 = 0x00;
	uip32 ecx_116;
	if (cl_84 != 0x00)
	{
		Eq_4 ecx_96 = dwArg04->t0014;
		Eq_4 ebx_97 = dwArg04->t0010;
		Eq_4 esi_100 = *((word32) dwArg08 + 20);
		if (ebx_97 != *((word32) dwArg08 + 16))
			ecx_116 = 0x00;
		else
		{
			runtime.ifaceeq(gs, ebx_97, ecx_96, esi_100);
			ecx_116 = (word32) bLoc08;
		}
	}
	else
		ecx_116 = 0x00;
	if ((byte) ecx_116 != 0x00)
	{
		uip32 ecx_264;
		if (dwArg04->t0018 == *((word32) dwArg08 + 24))
		{
			if (dwArg04->t001C == *((word32) dwArg08 + 28))
			{
				word32 ecx_149 = *((word32) dwArg08 + 32);
				ecx_264 = SEQ(SLICE(ecx_149, word24, 8), (int8) (dwArg04->dw0020 == ecx_149));
			}
			else
				ecx_264 = 0x00;
		}
		else
			ecx_264 = 0x00;
	}
}

// 080B02E0: void type..hash.reflect.ValueError(Register (ptr32 Eq_2) gs, Register Eq_4 mm0, Stack (ptr32 Eq_636) dwArg04, Stack (ptr32 Eq_205) dwArg08)
void type..hash.reflect.ValueError(struct Eq_2 * gs, Eq_4 mm0, struct Eq_636 * dwArg04, union Eq_205 * dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	word128 xmm1_94;
	runtime.memhash(gs, runtime.strhash(gs, mm0, dwArg04, dwArg08), (char *) &dwArg04->t0004 + 4, dwLoc08, 0x04, out xmm1_94);
}

// 080B0340: void type..eq.reflect.ValueError(Register (ptr32 Eq_122836) gs, Stack (ptr32 Eq_122837) dwArg04, Stack (ptr32 Eq_122838) dwArg08)
void type..eq.reflect.ValueError(struct Eq_122836 * gs, struct Eq_122837 * dwArg04, struct Eq_122838 * dwArg08)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	uip32 ecx_112;
	Eq_4 ecx_18 = dwArg04->t0004;
	Eq_4 edx_19 = dwArg04->t0000;
	Eq_4 esi_22 = dwArg08->t0000;
	if (ecx_18 != dwArg08->t0004)
		ecx_112 = 0x00;
	else
	{
		word32 edi_116;
		word32 ebx_114;
		word32 esi_115;
		runtime.eqstring(edx_19, edx_19, ecx_18, esi_22, out ebx_114, out esi_115, out edi_116);
		ecx_112 = (word32) bLoc04;
	}
}

// 080B03C0: void reflect.(*structType).uncommon(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*structType).uncommon(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).uncommon(gs, dwArg04);
}

// 080B03F0: void reflect.(*structType).String(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*structType).String(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).String(gs, dwArg04);
}

// 080B0430: void reflect.(*structType).Size(Register (ptr32 Eq_111955) gs)
void reflect.(*structType).Size(struct Eq_111955 * gs)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	reflect.(*rtype).Size(gs);
}

// 080B0460: void reflect.(*structType).Bits(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*structType).Bits(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).Bits(gs, dwArg04);
}

// 080B0490: void reflect.(*structType).Align(Register (ptr32 Eq_112007) gs)
void reflect.(*structType).Align(struct Eq_112007 * gs)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	reflect.(*rtype).Align(gs);
}

// 080B04C0: void reflect.(*structType).FieldAlign(Register (ptr32 Eq_112020) gs)
void reflect.(*structType).FieldAlign(struct Eq_112020 * gs)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	reflect.(*rtype).FieldAlign(gs);
}

// 080B04F0: void reflect.(*structType).Kind(Register (ptr32 Eq_112033) gs)
void reflect.(*structType).Kind(struct Eq_112033 * gs)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	reflect.(*rtype).Kind(gs);
}

// 080B0520: void reflect.(*structType).common(Register (ptr32 Eq_112046) gs)
void reflect.(*structType).common(struct Eq_112046 * gs)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	reflect.(*rtype).common(gs);
}

// 080B0550: void reflect.(*structType).NumMethod(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*structType).NumMethod(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	word128 xmm1_48;
	reflect.(*rtype).NumMethod(gs, dwArg04, out xmm1_48);
}

// 080B0580: void reflect.(*structType).Method(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg00)
void reflect.(*structType).Method(struct Eq_2 * gs, Eq_4 dwArg00)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	fn0808FD86(0x00, (word32) fp + 0x0C);
	reflect.(*rtype).Method(gs, dwLoc04, dwArg00);
}

// 080B05C0: void reflect.(*structType).MethodByName(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg00, Stack Eq_4 dwArg04)
void reflect.(*structType).MethodByName(struct Eq_2 * gs, Eq_4 dwArg00, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	fn0808FD86(0x00, (word32) fp + 16);
	reflect.(*rtype).MethodByName(gs, dwLoc04, dwArg00, dwArg04);
}

// 080B0600: void reflect.(*structType).PkgPath(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*structType).PkgPath(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).PkgPath(gs, dwArg04);
}

// 080B0640: void reflect.(*structType).Name(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*structType).Name(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).Name(gs, dwArg04);
}

// 080B0680: void reflect.(*structType).ChanDir(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*structType).ChanDir(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).ChanDir(gs, dwArg04);
}

// 080B06B0: void reflect.(*structType).IsVariadic(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*structType).IsVariadic(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).IsVariadic(gs, dwArg04);
}

// 080B06E0: void reflect.(*structType).Elem(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*structType).Elem(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).Elem(gs, dwArg04);
}

// 080B0720: void reflect.(*structType).In(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
void reflect.(*structType).In(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).In(gs, dwArg04, dwArg08);
}

// 080B0760: void reflect.(*structType).Key(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*structType).Key(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).Key(gs, dwArg04);
}

// 080B07A0: void reflect.(*structType).Len(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*structType).Len(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).Len(gs, dwArg04);
}

// 080B07D0: void reflect.(*structType).NumField(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_113346) dwArg04)
void reflect.(*structType).NumField(struct Eq_2 * gs, struct Eq_113346 * dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).NumField(gs, dwArg04);
}

// 080B0800: void reflect.(*structType).NumIn(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*structType).NumIn(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).NumIn(gs, dwArg04);
}

// 080B0830: void reflect.(*structType).NumOut(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*structType).NumOut(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).NumOut(gs, dwArg04);
}

// 080B0860: void reflect.(*structType).Out(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
void reflect.(*structType).Out(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).Out(gs, dwArg04, dwArg08);
}

// 080B08A0: void reflect.(*structType).Implements(Register (ptr32 Eq_2) gs, Stack word32 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C)
void reflect.(*structType).Implements(struct Eq_2 * gs, word32 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).Implements(gs, dwArg04, dwArg08, dwArg0C);
}

// 080B08D0: void reflect.(*structType).AssignableTo(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C)
void reflect.(*structType).AssignableTo(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).AssignableTo(gs, dwArg04, dwArg08, dwArg0C);
}

// 080B0900: void reflect.(*structType).ConvertibleTo(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg08)
void reflect.(*structType).ConvertibleTo(struct Eq_2 * gs, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).ConvertibleTo(gs, dwArg08);
}

// 080B0930: void reflect.(*structType).Comparable(Register (ptr32 Eq_115122) gs, Stack (ptr32 Eq_115123) dwArg04)
void reflect.(*structType).Comparable(struct Eq_115122 * gs, struct Eq_115123 * dwArg04)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	reflect.(*rtype).Comparable(gs, dwArg04);
}

// 080B0960: void reflect.(*funcType).uncommon(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*funcType).uncommon(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).uncommon(gs, dwArg04);
}

// 080B0990: void reflect.(*funcType).String(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*funcType).String(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).String(gs, dwArg04);
}

// 080B09D0: void reflect.(*funcType).Size(Register (ptr32 Eq_111955) gs)
void reflect.(*funcType).Size(struct Eq_111955 * gs)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	reflect.(*rtype).Size(gs);
}

// 080B0A00: void reflect.(*funcType).Bits(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*funcType).Bits(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).Bits(gs, dwArg04);
}

// 080B0A30: void reflect.(*funcType).Align(Register (ptr32 Eq_112007) gs)
void reflect.(*funcType).Align(struct Eq_112007 * gs)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	reflect.(*rtype).Align(gs);
}

// 080B0A60: void reflect.(*funcType).FieldAlign(Register (ptr32 Eq_112020) gs)
void reflect.(*funcType).FieldAlign(struct Eq_112020 * gs)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	reflect.(*rtype).FieldAlign(gs);
}

// 080B0A90: void reflect.(*funcType).Kind(Register (ptr32 Eq_112033) gs)
void reflect.(*funcType).Kind(struct Eq_112033 * gs)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	reflect.(*rtype).Kind(gs);
}

// 080B0AC0: void reflect.(*funcType).common(Register (ptr32 Eq_112046) gs)
void reflect.(*funcType).common(struct Eq_112046 * gs)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	reflect.(*rtype).common(gs);
}

// 080B0AF0: void reflect.(*funcType).NumMethod(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*funcType).NumMethod(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	word128 xmm1_48;
	reflect.(*rtype).NumMethod(gs, dwArg04, out xmm1_48);
}

// 080B0B20: void reflect.(*funcType).Method(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg00)
void reflect.(*funcType).Method(struct Eq_2 * gs, Eq_4 dwArg00)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	fn0808FD86(0x00, (word32) fp + 0x0C);
	reflect.(*rtype).Method(gs, dwLoc04, dwArg00);
}

// 080B0B60: void reflect.(*funcType).MethodByName(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg00, Stack Eq_4 dwArg04)
void reflect.(*funcType).MethodByName(struct Eq_2 * gs, Eq_4 dwArg00, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	fn0808FD86(0x00, (word32) fp + 16);
	reflect.(*rtype).MethodByName(gs, dwLoc04, dwArg00, dwArg04);
}

// 080B0BA0: void reflect.(*funcType).PkgPath(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*funcType).PkgPath(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).PkgPath(gs, dwArg04);
}

// 080B0BE0: void reflect.(*funcType).Name(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*funcType).Name(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).Name(gs, dwArg04);
}

// 080B0C20: void reflect.(*funcType).ChanDir(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*funcType).ChanDir(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).ChanDir(gs, dwArg04);
}

// 080B0C50: void reflect.(*funcType).IsVariadic(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*funcType).IsVariadic(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).IsVariadic(gs, dwArg04);
}

// 080B0C80: void reflect.(*funcType).Elem(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*funcType).Elem(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).Elem(gs, dwArg04);
}

// 080B0CC0: void reflect.(*funcType).Field(Register (ptr32 Eq_2) gs)
void reflect.(*funcType).Field(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	fn0808FD83(0x00, (word32) fp + 0x0C);
	reflect.(*rtype).Field(gs, dwLoc04);
}

// 080B0D00: void reflect.(*funcType).FieldByIndex(Register (ptr32 Eq_2) gs)
void reflect.(*funcType).FieldByIndex(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	fn0808FD83(0x00, (word32) fp + 20);
	reflect.(*rtype).FieldByIndex(gs, dwLoc04);
}

// 080B0D40: void reflect.(*funcType).FieldByName(Register (ptr32 Eq_2) gs)
void reflect.(*funcType).FieldByName(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	fn0808FD83(0x00, (word32) fp + 16);
	reflect.(*rtype).FieldByName(gs, dwLoc04);
}

// 080B0D80: void reflect.(*funcType).FieldByNameFunc(Register (ptr32 Eq_2) gs)
void reflect.(*funcType).FieldByNameFunc(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	fn0808FD83(0x00, (word32) fp + 0x0C);
	reflect.(*rtype).FieldByNameFunc(gs, dwLoc04);
}

// 080B0DC0: void reflect.(*funcType).In(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
void reflect.(*funcType).In(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).In(gs, dwArg04, dwArg08);
}

// 080B0E00: void reflect.(*funcType).Key(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*funcType).Key(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).Key(gs, dwArg04);
}

// 080B0E40: void reflect.(*funcType).Len(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*funcType).Len(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).Len(gs, dwArg04);
}

// 080B0E70: void reflect.(*funcType).NumField(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_113346) dwArg04)
void reflect.(*funcType).NumField(struct Eq_2 * gs, struct Eq_113346 * dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).NumField(gs, dwArg04);
}

// 080B0EA0: void reflect.(*funcType).NumIn(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*funcType).NumIn(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).NumIn(gs, dwArg04);
}

// 080B0ED0: void reflect.(*funcType).NumOut(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*funcType).NumOut(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).NumOut(gs, dwArg04);
}

// 080B0F00: void reflect.(*funcType).Out(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
void reflect.(*funcType).Out(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).Out(gs, dwArg04, dwArg08);
}

// 080B0F40: void reflect.(*funcType).Implements(Register (ptr32 Eq_2) gs, Stack word32 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C)
void reflect.(*funcType).Implements(struct Eq_2 * gs, word32 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).Implements(gs, dwArg04, dwArg08, dwArg0C);
}

// 080B0F70: void reflect.(*funcType).AssignableTo(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C)
void reflect.(*funcType).AssignableTo(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).AssignableTo(gs, dwArg04, dwArg08, dwArg0C);
}

// 080B0FA0: void reflect.(*funcType).ConvertibleTo(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg08)
void reflect.(*funcType).ConvertibleTo(struct Eq_2 * gs, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).ConvertibleTo(gs, dwArg08);
}

// 080B0FD0: void reflect.(*funcType).Comparable(Register (ptr32 Eq_115122) gs, Stack (ptr32 Eq_115123) dwArg04)
void reflect.(*funcType).Comparable(struct Eq_115122 * gs, struct Eq_115123 * dwArg04)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	reflect.(*rtype).Comparable(gs, dwArg04);
}

// 080B1000: void reflect.(*funcTypeFixed128).uncommon(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*funcTypeFixed128).uncommon(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).uncommon(gs, dwArg04);
}

// 080B1030: void reflect.(*funcTypeFixed128).String(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*funcTypeFixed128).String(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).String(gs, dwArg04);
}

// 080B1070: void reflect.(*funcTypeFixed128).Size(Register (ptr32 Eq_111955) gs)
void reflect.(*funcTypeFixed128).Size(struct Eq_111955 * gs)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	reflect.(*rtype).Size(gs);
}

// 080B10A0: void reflect.(*funcTypeFixed128).Bits(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*funcTypeFixed128).Bits(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).Bits(gs, dwArg04);
}

// 080B10D0: void reflect.(*funcTypeFixed128).Align(Register (ptr32 Eq_112007) gs)
void reflect.(*funcTypeFixed128).Align(struct Eq_112007 * gs)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	reflect.(*rtype).Align(gs);
}

// 080B1100: void reflect.(*funcTypeFixed128).FieldAlign(Register (ptr32 Eq_112020) gs)
void reflect.(*funcTypeFixed128).FieldAlign(struct Eq_112020 * gs)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	reflect.(*rtype).FieldAlign(gs);
}

// 080B1130: void reflect.(*funcTypeFixed128).Kind(Register (ptr32 Eq_112033) gs)
void reflect.(*funcTypeFixed128).Kind(struct Eq_112033 * gs)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	reflect.(*rtype).Kind(gs);
}

// 080B1160: void reflect.(*funcTypeFixed128).common(Register (ptr32 Eq_112046) gs)
void reflect.(*funcTypeFixed128).common(struct Eq_112046 * gs)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	reflect.(*rtype).common(gs);
}

// 080B1190: void reflect.(*funcTypeFixed128).NumMethod(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*funcTypeFixed128).NumMethod(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	word128 xmm1_48;
	reflect.(*rtype).NumMethod(gs, dwArg04, out xmm1_48);
}

// 080B11C0: void reflect.(*funcTypeFixed128).Method(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg00)
void reflect.(*funcTypeFixed128).Method(struct Eq_2 * gs, Eq_4 dwArg00)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	fn0808FD86(0x00, (word32) fp + 0x0C);
	reflect.(*rtype).Method(gs, dwLoc04, dwArg00);
}

// 080B1200: void reflect.(*funcTypeFixed128).MethodByName(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg00, Stack Eq_4 dwArg04)
void reflect.(*funcTypeFixed128).MethodByName(struct Eq_2 * gs, Eq_4 dwArg00, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	fn0808FD86(0x00, (word32) fp + 16);
	reflect.(*rtype).MethodByName(gs, dwLoc04, dwArg00, dwArg04);
}

// 080B1240: void reflect.(*funcTypeFixed128).PkgPath(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*funcTypeFixed128).PkgPath(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).PkgPath(gs, dwArg04);
}

// 080B1280: void reflect.(*funcTypeFixed128).Name(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*funcTypeFixed128).Name(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).Name(gs, dwArg04);
}

// 080B12C0: void reflect.(*funcTypeFixed128).ChanDir(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*funcTypeFixed128).ChanDir(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).ChanDir(gs, dwArg04);
}

// 080B12F0: void reflect.(*funcTypeFixed128).IsVariadic(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*funcTypeFixed128).IsVariadic(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).IsVariadic(gs, dwArg04);
}

// 080B1320: void reflect.(*funcTypeFixed128).Elem(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*funcTypeFixed128).Elem(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).Elem(gs, dwArg04);
}

// 080B1360: void reflect.(*funcTypeFixed128).Field(Register (ptr32 Eq_2) gs)
void reflect.(*funcTypeFixed128).Field(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	fn0808FD83(0x00, (word32) fp + 0x0C);
	reflect.(*rtype).Field(gs, dwLoc04);
}

// 080B13A0: void reflect.(*funcTypeFixed128).FieldByIndex(Register (ptr32 Eq_2) gs)
void reflect.(*funcTypeFixed128).FieldByIndex(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	fn0808FD83(0x00, (word32) fp + 20);
	reflect.(*rtype).FieldByIndex(gs, dwLoc04);
}

// 080B13E0: void reflect.(*funcTypeFixed128).FieldByName(Register (ptr32 Eq_2) gs)
void reflect.(*funcTypeFixed128).FieldByName(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	fn0808FD83(0x00, (word32) fp + 16);
	reflect.(*rtype).FieldByName(gs, dwLoc04);
}

// 080B1420: void reflect.(*funcTypeFixed128).FieldByNameFunc(Register (ptr32 Eq_2) gs)
void reflect.(*funcTypeFixed128).FieldByNameFunc(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	fn0808FD83(0x00, (word32) fp + 0x0C);
	reflect.(*rtype).FieldByNameFunc(gs, dwLoc04);
}

// 080B1460: void reflect.(*funcTypeFixed128).In(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
void reflect.(*funcTypeFixed128).In(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).In(gs, dwArg04, dwArg08);
}

// 080B14A0: void reflect.(*funcTypeFixed128).Key(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*funcTypeFixed128).Key(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).Key(gs, dwArg04);
}

// 080B14E0: void reflect.(*funcTypeFixed128).Len(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*funcTypeFixed128).Len(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).Len(gs, dwArg04);
}

// 080B1510: void reflect.(*funcTypeFixed128).NumField(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_113346) dwArg04)
void reflect.(*funcTypeFixed128).NumField(struct Eq_2 * gs, struct Eq_113346 * dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).NumField(gs, dwArg04);
}

// 080B1540: void reflect.(*funcTypeFixed128).NumIn(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*funcTypeFixed128).NumIn(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).NumIn(gs, dwArg04);
}

// 080B1570: void reflect.(*funcTypeFixed128).NumOut(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*funcTypeFixed128).NumOut(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).NumOut(gs, dwArg04);
}

// 080B15A0: void reflect.(*funcTypeFixed128).Out(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
void reflect.(*funcTypeFixed128).Out(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).Out(gs, dwArg04, dwArg08);
}

// 080B15E0: void reflect.(*funcTypeFixed128).Implements(Register (ptr32 Eq_2) gs, Stack word32 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C)
void reflect.(*funcTypeFixed128).Implements(struct Eq_2 * gs, word32 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).Implements(gs, dwArg04, dwArg08, dwArg0C);
}

// 080B1610: void reflect.(*funcTypeFixed128).AssignableTo(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C)
void reflect.(*funcTypeFixed128).AssignableTo(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).AssignableTo(gs, dwArg04, dwArg08, dwArg0C);
}

// 080B1640: void reflect.(*funcTypeFixed128).ConvertibleTo(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg08)
void reflect.(*funcTypeFixed128).ConvertibleTo(struct Eq_2 * gs, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).ConvertibleTo(gs, dwArg08);
}

// 080B1670: void reflect.(*funcTypeFixed128).Comparable(Register (ptr32 Eq_115122) gs, Stack (ptr32 Eq_115123) dwArg04)
void reflect.(*funcTypeFixed128).Comparable(struct Eq_115122 * gs, struct Eq_115123 * dwArg04)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	reflect.(*rtype).Comparable(gs, dwArg04);
}

// 080B16A0: void reflect.(*funcTypeFixed16).uncommon(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*funcTypeFixed16).uncommon(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).uncommon(gs, dwArg04);
}

// 080B16D0: void reflect.(*funcTypeFixed16).String(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*funcTypeFixed16).String(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).String(gs, dwArg04);
}

// 080B1710: void reflect.(*funcTypeFixed16).Size(Register (ptr32 Eq_111955) gs)
void reflect.(*funcTypeFixed16).Size(struct Eq_111955 * gs)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	reflect.(*rtype).Size(gs);
}

// 080B1740: void reflect.(*funcTypeFixed16).Bits(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*funcTypeFixed16).Bits(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).Bits(gs, dwArg04);
}

// 080B1770: void reflect.(*funcTypeFixed16).Align(Register (ptr32 Eq_112007) gs)
void reflect.(*funcTypeFixed16).Align(struct Eq_112007 * gs)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	reflect.(*rtype).Align(gs);
}

// 080B17A0: void reflect.(*funcTypeFixed16).FieldAlign(Register (ptr32 Eq_112020) gs)
void reflect.(*funcTypeFixed16).FieldAlign(struct Eq_112020 * gs)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	reflect.(*rtype).FieldAlign(gs);
}

// 080B17D0: void reflect.(*funcTypeFixed16).Kind(Register (ptr32 Eq_112033) gs)
void reflect.(*funcTypeFixed16).Kind(struct Eq_112033 * gs)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	reflect.(*rtype).Kind(gs);
}

// 080B1800: void reflect.(*funcTypeFixed16).common(Register (ptr32 Eq_112046) gs)
void reflect.(*funcTypeFixed16).common(struct Eq_112046 * gs)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	reflect.(*rtype).common(gs);
}

// 080B1830: void reflect.(*funcTypeFixed16).NumMethod(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*funcTypeFixed16).NumMethod(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	word128 xmm1_48;
	reflect.(*rtype).NumMethod(gs, dwArg04, out xmm1_48);
}

// 080B1860: void reflect.(*funcTypeFixed16).Method(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg00)
void reflect.(*funcTypeFixed16).Method(struct Eq_2 * gs, Eq_4 dwArg00)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	fn0808FD86(0x00, (word32) fp + 0x0C);
	reflect.(*rtype).Method(gs, dwLoc04, dwArg00);
}

// 080B18A0: void reflect.(*funcTypeFixed16).MethodByName(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg00, Stack Eq_4 dwArg04)
void reflect.(*funcTypeFixed16).MethodByName(struct Eq_2 * gs, Eq_4 dwArg00, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	fn0808FD86(0x00, (word32) fp + 16);
	reflect.(*rtype).MethodByName(gs, dwLoc04, dwArg00, dwArg04);
}

// 080B18E0: void reflect.(*funcTypeFixed16).PkgPath(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*funcTypeFixed16).PkgPath(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).PkgPath(gs, dwArg04);
}

// 080B1920: void reflect.(*funcTypeFixed16).Name(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*funcTypeFixed16).Name(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).Name(gs, dwArg04);
}

// 080B1960: void reflect.(*funcTypeFixed16).ChanDir(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*funcTypeFixed16).ChanDir(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).ChanDir(gs, dwArg04);
}

// 080B1990: void reflect.(*funcTypeFixed16).IsVariadic(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*funcTypeFixed16).IsVariadic(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).IsVariadic(gs, dwArg04);
}

// 080B19C0: void reflect.(*funcTypeFixed16).Elem(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*funcTypeFixed16).Elem(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).Elem(gs, dwArg04);
}

// 080B1A00: void reflect.(*funcTypeFixed16).Field(Register (ptr32 Eq_2) gs)
void reflect.(*funcTypeFixed16).Field(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	fn0808FD83(0x00, (word32) fp + 0x0C);
	reflect.(*rtype).Field(gs, dwLoc04);
}

// 080B1A40: void reflect.(*funcTypeFixed16).FieldByIndex(Register (ptr32 Eq_2) gs)
void reflect.(*funcTypeFixed16).FieldByIndex(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	fn0808FD83(0x00, (word32) fp + 20);
	reflect.(*rtype).FieldByIndex(gs, dwLoc04);
}

// 080B1A80: void reflect.(*funcTypeFixed16).FieldByName(Register (ptr32 Eq_2) gs)
void reflect.(*funcTypeFixed16).FieldByName(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	fn0808FD83(0x00, (word32) fp + 16);
	reflect.(*rtype).FieldByName(gs, dwLoc04);
}

// 080B1AC0: void reflect.(*funcTypeFixed16).FieldByNameFunc(Register (ptr32 Eq_2) gs)
void reflect.(*funcTypeFixed16).FieldByNameFunc(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	fn0808FD83(0x00, (word32) fp + 0x0C);
	reflect.(*rtype).FieldByNameFunc(gs, dwLoc04);
}

// 080B1B00: void reflect.(*funcTypeFixed16).In(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
void reflect.(*funcTypeFixed16).In(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).In(gs, dwArg04, dwArg08);
}

// 080B1B40: void reflect.(*funcTypeFixed16).Key(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*funcTypeFixed16).Key(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).Key(gs, dwArg04);
}

// 080B1B80: void reflect.(*funcTypeFixed16).Len(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*funcTypeFixed16).Len(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).Len(gs, dwArg04);
}

// 080B1BB0: void reflect.(*funcTypeFixed16).NumField(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_113346) dwArg04)
void reflect.(*funcTypeFixed16).NumField(struct Eq_2 * gs, struct Eq_113346 * dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).NumField(gs, dwArg04);
}

// 080B1BE0: void reflect.(*funcTypeFixed16).NumIn(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*funcTypeFixed16).NumIn(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).NumIn(gs, dwArg04);
}

// 080B1C10: void reflect.(*funcTypeFixed16).NumOut(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*funcTypeFixed16).NumOut(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).NumOut(gs, dwArg04);
}

// 080B1C40: void reflect.(*funcTypeFixed16).Out(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
void reflect.(*funcTypeFixed16).Out(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).Out(gs, dwArg04, dwArg08);
}

// 080B1C80: void reflect.(*funcTypeFixed16).Implements(Register (ptr32 Eq_2) gs, Stack word32 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C)
void reflect.(*funcTypeFixed16).Implements(struct Eq_2 * gs, word32 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).Implements(gs, dwArg04, dwArg08, dwArg0C);
}

// 080B1CB0: void reflect.(*funcTypeFixed16).AssignableTo(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C)
void reflect.(*funcTypeFixed16).AssignableTo(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).AssignableTo(gs, dwArg04, dwArg08, dwArg0C);
}

// 080B1CE0: void reflect.(*funcTypeFixed16).ConvertibleTo(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg08)
void reflect.(*funcTypeFixed16).ConvertibleTo(struct Eq_2 * gs, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).ConvertibleTo(gs, dwArg08);
}

// 080B1D10: void reflect.(*funcTypeFixed16).Comparable(Register (ptr32 Eq_115122) gs, Stack (ptr32 Eq_115123) dwArg04)
void reflect.(*funcTypeFixed16).Comparable(struct Eq_115122 * gs, struct Eq_115123 * dwArg04)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	reflect.(*rtype).Comparable(gs, dwArg04);
}

// 080B1D40: void reflect.(*funcTypeFixed32).uncommon(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*funcTypeFixed32).uncommon(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).uncommon(gs, dwArg04);
}

// 080B1D70: void reflect.(*funcTypeFixed32).String(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*funcTypeFixed32).String(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).String(gs, dwArg04);
}

// 080B1DB0: void reflect.(*funcTypeFixed32).Size(Register (ptr32 Eq_111955) gs)
void reflect.(*funcTypeFixed32).Size(struct Eq_111955 * gs)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	reflect.(*rtype).Size(gs);
}

// 080B1DE0: void reflect.(*funcTypeFixed32).Bits(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*funcTypeFixed32).Bits(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).Bits(gs, dwArg04);
}

// 080B1E10: void reflect.(*funcTypeFixed32).Align(Register (ptr32 Eq_112007) gs)
void reflect.(*funcTypeFixed32).Align(struct Eq_112007 * gs)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	reflect.(*rtype).Align(gs);
}

// 080B1E40: void reflect.(*funcTypeFixed32).FieldAlign(Register (ptr32 Eq_112020) gs)
void reflect.(*funcTypeFixed32).FieldAlign(struct Eq_112020 * gs)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	reflect.(*rtype).FieldAlign(gs);
}

// 080B1E70: void reflect.(*funcTypeFixed32).Kind(Register (ptr32 Eq_112033) gs)
void reflect.(*funcTypeFixed32).Kind(struct Eq_112033 * gs)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	reflect.(*rtype).Kind(gs);
}

// 080B1EA0: void reflect.(*funcTypeFixed32).common(Register (ptr32 Eq_112046) gs)
void reflect.(*funcTypeFixed32).common(struct Eq_112046 * gs)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	reflect.(*rtype).common(gs);
}

// 080B1ED0: void reflect.(*funcTypeFixed32).NumMethod(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*funcTypeFixed32).NumMethod(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	word128 xmm1_48;
	reflect.(*rtype).NumMethod(gs, dwArg04, out xmm1_48);
}

// 080B1F00: void reflect.(*funcTypeFixed32).Method(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg00)
void reflect.(*funcTypeFixed32).Method(struct Eq_2 * gs, Eq_4 dwArg00)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	fn0808FD86(0x00, (word32) fp + 0x0C);
	reflect.(*rtype).Method(gs, dwLoc04, dwArg00);
}

// 080B1F40: void reflect.(*funcTypeFixed32).MethodByName(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg00, Stack Eq_4 dwArg04)
void reflect.(*funcTypeFixed32).MethodByName(struct Eq_2 * gs, Eq_4 dwArg00, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	fn0808FD86(0x00, (word32) fp + 16);
	reflect.(*rtype).MethodByName(gs, dwLoc04, dwArg00, dwArg04);
}

// 080B1F80: void reflect.(*funcTypeFixed32).PkgPath(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*funcTypeFixed32).PkgPath(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).PkgPath(gs, dwArg04);
}

// 080B1FC0: void reflect.(*funcTypeFixed32).Name(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*funcTypeFixed32).Name(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).Name(gs, dwArg04);
}

// 080B2000: void reflect.(*funcTypeFixed32).ChanDir(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*funcTypeFixed32).ChanDir(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).ChanDir(gs, dwArg04);
}

// 080B2030: void reflect.(*funcTypeFixed32).IsVariadic(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*funcTypeFixed32).IsVariadic(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).IsVariadic(gs, dwArg04);
}

// 080B2060: void reflect.(*funcTypeFixed32).Elem(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*funcTypeFixed32).Elem(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).Elem(gs, dwArg04);
}

// 080B20A0: void reflect.(*funcTypeFixed32).Field(Register (ptr32 Eq_2) gs)
void reflect.(*funcTypeFixed32).Field(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	fn0808FD83(0x00, (word32) fp + 0x0C);
	reflect.(*rtype).Field(gs, dwLoc04);
}

// 080B20E0: void reflect.(*funcTypeFixed32).FieldByIndex(Register (ptr32 Eq_2) gs)
void reflect.(*funcTypeFixed32).FieldByIndex(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	fn0808FD83(0x00, (word32) fp + 20);
	reflect.(*rtype).FieldByIndex(gs, dwLoc04);
}

// 080B2120: void reflect.(*funcTypeFixed32).FieldByName(Register (ptr32 Eq_2) gs)
void reflect.(*funcTypeFixed32).FieldByName(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	fn0808FD83(0x00, (word32) fp + 16);
	reflect.(*rtype).FieldByName(gs, dwLoc04);
}

// 080B2160: void reflect.(*funcTypeFixed32).FieldByNameFunc(Register (ptr32 Eq_2) gs)
void reflect.(*funcTypeFixed32).FieldByNameFunc(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	fn0808FD83(0x00, (word32) fp + 0x0C);
	reflect.(*rtype).FieldByNameFunc(gs, dwLoc04);
}

// 080B21A0: void reflect.(*funcTypeFixed32).In(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
void reflect.(*funcTypeFixed32).In(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).In(gs, dwArg04, dwArg08);
}

// 080B21E0: void reflect.(*funcTypeFixed32).Key(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*funcTypeFixed32).Key(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).Key(gs, dwArg04);
}

// 080B2220: void reflect.(*funcTypeFixed32).Len(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*funcTypeFixed32).Len(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).Len(gs, dwArg04);
}

// 080B2250: void reflect.(*funcTypeFixed32).NumField(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_113346) dwArg04)
void reflect.(*funcTypeFixed32).NumField(struct Eq_2 * gs, struct Eq_113346 * dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).NumField(gs, dwArg04);
}

// 080B2280: void reflect.(*funcTypeFixed32).NumIn(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*funcTypeFixed32).NumIn(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).NumIn(gs, dwArg04);
}

// 080B22B0: void reflect.(*funcTypeFixed32).NumOut(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*funcTypeFixed32).NumOut(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).NumOut(gs, dwArg04);
}

// 080B22E0: void reflect.(*funcTypeFixed32).Out(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
void reflect.(*funcTypeFixed32).Out(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).Out(gs, dwArg04, dwArg08);
}

// 080B2320: void reflect.(*funcTypeFixed32).Implements(Register (ptr32 Eq_2) gs, Stack word32 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C)
void reflect.(*funcTypeFixed32).Implements(struct Eq_2 * gs, word32 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).Implements(gs, dwArg04, dwArg08, dwArg0C);
}

// 080B2350: void reflect.(*funcTypeFixed32).AssignableTo(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C)
void reflect.(*funcTypeFixed32).AssignableTo(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).AssignableTo(gs, dwArg04, dwArg08, dwArg0C);
}

// 080B2380: void reflect.(*funcTypeFixed32).ConvertibleTo(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg08)
void reflect.(*funcTypeFixed32).ConvertibleTo(struct Eq_2 * gs, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).ConvertibleTo(gs, dwArg08);
}

// 080B23B0: void reflect.(*funcTypeFixed32).Comparable(Register (ptr32 Eq_115122) gs, Stack (ptr32 Eq_115123) dwArg04)
void reflect.(*funcTypeFixed32).Comparable(struct Eq_115122 * gs, struct Eq_115123 * dwArg04)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	reflect.(*rtype).Comparable(gs, dwArg04);
}

// 080B23E0: void reflect.(*funcTypeFixed4).uncommon(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*funcTypeFixed4).uncommon(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).uncommon(gs, dwArg04);
}

// 080B2410: void reflect.(*funcTypeFixed4).String(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*funcTypeFixed4).String(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).String(gs, dwArg04);
}

// 080B2450: void reflect.(*funcTypeFixed4).Size(Register (ptr32 Eq_111955) gs)
void reflect.(*funcTypeFixed4).Size(struct Eq_111955 * gs)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	reflect.(*rtype).Size(gs);
}

// 080B2480: void reflect.(*funcTypeFixed4).Bits(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*funcTypeFixed4).Bits(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).Bits(gs, dwArg04);
}

// 080B24B0: void reflect.(*funcTypeFixed4).Align(Register (ptr32 Eq_112007) gs)
void reflect.(*funcTypeFixed4).Align(struct Eq_112007 * gs)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	reflect.(*rtype).Align(gs);
}

// 080B24E0: void reflect.(*funcTypeFixed4).FieldAlign(Register (ptr32 Eq_112020) gs)
void reflect.(*funcTypeFixed4).FieldAlign(struct Eq_112020 * gs)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	reflect.(*rtype).FieldAlign(gs);
}

// 080B2510: void reflect.(*funcTypeFixed4).Kind(Register (ptr32 Eq_112033) gs)
void reflect.(*funcTypeFixed4).Kind(struct Eq_112033 * gs)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	reflect.(*rtype).Kind(gs);
}

// 080B2540: void reflect.(*funcTypeFixed4).common(Register (ptr32 Eq_112046) gs)
void reflect.(*funcTypeFixed4).common(struct Eq_112046 * gs)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	reflect.(*rtype).common(gs);
}

// 080B2570: void reflect.(*funcTypeFixed4).NumMethod(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*funcTypeFixed4).NumMethod(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	word128 xmm1_48;
	reflect.(*rtype).NumMethod(gs, dwArg04, out xmm1_48);
}

// 080B25A0: void reflect.(*funcTypeFixed4).Method(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg00)
void reflect.(*funcTypeFixed4).Method(struct Eq_2 * gs, Eq_4 dwArg00)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	fn0808FD86(0x00, (word32) fp + 0x0C);
	reflect.(*rtype).Method(gs, dwLoc04, dwArg00);
}

// 080B25E0: void reflect.(*funcTypeFixed4).MethodByName(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg00, Stack Eq_4 dwArg04)
void reflect.(*funcTypeFixed4).MethodByName(struct Eq_2 * gs, Eq_4 dwArg00, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	fn0808FD86(0x00, (word32) fp + 16);
	reflect.(*rtype).MethodByName(gs, dwLoc04, dwArg00, dwArg04);
}

// 080B2620: void reflect.(*funcTypeFixed4).PkgPath(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*funcTypeFixed4).PkgPath(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).PkgPath(gs, dwArg04);
}

// 080B2660: void reflect.(*funcTypeFixed4).Name(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*funcTypeFixed4).Name(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).Name(gs, dwArg04);
}

// 080B26A0: void reflect.(*funcTypeFixed4).ChanDir(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*funcTypeFixed4).ChanDir(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).ChanDir(gs, dwArg04);
}

// 080B26D0: void reflect.(*funcTypeFixed4).IsVariadic(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*funcTypeFixed4).IsVariadic(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).IsVariadic(gs, dwArg04);
}

// 080B2700: void reflect.(*funcTypeFixed4).Elem(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*funcTypeFixed4).Elem(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).Elem(gs, dwArg04);
}

// 080B2740: void reflect.(*funcTypeFixed4).Field(Register (ptr32 Eq_2) gs)
void reflect.(*funcTypeFixed4).Field(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	fn0808FD83(0x00, (word32) fp + 0x0C);
	reflect.(*rtype).Field(gs, dwLoc04);
}

// 080B2780: void reflect.(*funcTypeFixed4).FieldByIndex(Register (ptr32 Eq_2) gs)
void reflect.(*funcTypeFixed4).FieldByIndex(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	fn0808FD83(0x00, (word32) fp + 20);
	reflect.(*rtype).FieldByIndex(gs, dwLoc04);
}

// 080B27C0: void reflect.(*funcTypeFixed4).FieldByName(Register (ptr32 Eq_2) gs)
void reflect.(*funcTypeFixed4).FieldByName(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	fn0808FD83(0x00, (word32) fp + 16);
	reflect.(*rtype).FieldByName(gs, dwLoc04);
}

// 080B2800: void reflect.(*funcTypeFixed4).FieldByNameFunc(Register (ptr32 Eq_2) gs)
void reflect.(*funcTypeFixed4).FieldByNameFunc(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	fn0808FD83(0x00, (word32) fp + 0x0C);
	reflect.(*rtype).FieldByNameFunc(gs, dwLoc04);
}

// 080B2840: void reflect.(*funcTypeFixed4).In(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
void reflect.(*funcTypeFixed4).In(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).In(gs, dwArg04, dwArg08);
}

// 080B2880: void reflect.(*funcTypeFixed4).Key(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*funcTypeFixed4).Key(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).Key(gs, dwArg04);
}

// 080B28C0: void reflect.(*funcTypeFixed4).Len(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*funcTypeFixed4).Len(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).Len(gs, dwArg04);
}

// 080B28F0: void reflect.(*funcTypeFixed4).NumField(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_113346) dwArg04)
void reflect.(*funcTypeFixed4).NumField(struct Eq_2 * gs, struct Eq_113346 * dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).NumField(gs, dwArg04);
}

// 080B2920: void reflect.(*funcTypeFixed4).NumIn(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*funcTypeFixed4).NumIn(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).NumIn(gs, dwArg04);
}

// 080B2950: void reflect.(*funcTypeFixed4).NumOut(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*funcTypeFixed4).NumOut(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).NumOut(gs, dwArg04);
}

// 080B2980: void reflect.(*funcTypeFixed4).Out(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
void reflect.(*funcTypeFixed4).Out(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).Out(gs, dwArg04, dwArg08);
}

// 080B29C0: void reflect.(*funcTypeFixed4).Implements(Register (ptr32 Eq_2) gs, Stack word32 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C)
void reflect.(*funcTypeFixed4).Implements(struct Eq_2 * gs, word32 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).Implements(gs, dwArg04, dwArg08, dwArg0C);
}

// 080B29F0: void reflect.(*funcTypeFixed4).AssignableTo(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C)
void reflect.(*funcTypeFixed4).AssignableTo(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).AssignableTo(gs, dwArg04, dwArg08, dwArg0C);
}

// 080B2A20: void reflect.(*funcTypeFixed4).ConvertibleTo(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg08)
void reflect.(*funcTypeFixed4).ConvertibleTo(struct Eq_2 * gs, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).ConvertibleTo(gs, dwArg08);
}

// 080B2A50: void reflect.(*funcTypeFixed4).Comparable(Register (ptr32 Eq_115122) gs, Stack (ptr32 Eq_115123) dwArg04)
void reflect.(*funcTypeFixed4).Comparable(struct Eq_115122 * gs, struct Eq_115123 * dwArg04)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	reflect.(*rtype).Comparable(gs, dwArg04);
}

// 080B2A80: void reflect.(*funcTypeFixed64).uncommon(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*funcTypeFixed64).uncommon(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).uncommon(gs, dwArg04);
}

// 080B2AB0: void reflect.(*funcTypeFixed64).String(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*funcTypeFixed64).String(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).String(gs, dwArg04);
}

// 080B2AF0: void reflect.(*funcTypeFixed64).Size(Register (ptr32 Eq_111955) gs)
void reflect.(*funcTypeFixed64).Size(struct Eq_111955 * gs)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	reflect.(*rtype).Size(gs);
}

// 080B2B20: void reflect.(*funcTypeFixed64).Bits(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*funcTypeFixed64).Bits(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).Bits(gs, dwArg04);
}

// 080B2B50: void reflect.(*funcTypeFixed64).Align(Register (ptr32 Eq_112007) gs)
void reflect.(*funcTypeFixed64).Align(struct Eq_112007 * gs)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	reflect.(*rtype).Align(gs);
}

// 080B2B80: void reflect.(*funcTypeFixed64).FieldAlign(Register (ptr32 Eq_112020) gs)
void reflect.(*funcTypeFixed64).FieldAlign(struct Eq_112020 * gs)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	reflect.(*rtype).FieldAlign(gs);
}

// 080B2BB0: void reflect.(*funcTypeFixed64).Kind(Register (ptr32 Eq_112033) gs)
void reflect.(*funcTypeFixed64).Kind(struct Eq_112033 * gs)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	reflect.(*rtype).Kind(gs);
}

// 080B2BE0: void reflect.(*funcTypeFixed64).common(Register (ptr32 Eq_112046) gs)
void reflect.(*funcTypeFixed64).common(struct Eq_112046 * gs)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	reflect.(*rtype).common(gs);
}

// 080B2C10: void reflect.(*funcTypeFixed64).NumMethod(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*funcTypeFixed64).NumMethod(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	word128 xmm1_48;
	reflect.(*rtype).NumMethod(gs, dwArg04, out xmm1_48);
}

// 080B2C40: void reflect.(*funcTypeFixed64).Method(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg00)
void reflect.(*funcTypeFixed64).Method(struct Eq_2 * gs, Eq_4 dwArg00)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	fn0808FD86(0x00, (word32) fp + 0x0C);
	reflect.(*rtype).Method(gs, dwLoc04, dwArg00);
}

// 080B2C80: void reflect.(*funcTypeFixed64).MethodByName(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg00, Stack Eq_4 dwArg04)
void reflect.(*funcTypeFixed64).MethodByName(struct Eq_2 * gs, Eq_4 dwArg00, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	fn0808FD86(0x00, (word32) fp + 16);
	reflect.(*rtype).MethodByName(gs, dwLoc04, dwArg00, dwArg04);
}

// 080B2CC0: void reflect.(*funcTypeFixed64).PkgPath(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*funcTypeFixed64).PkgPath(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).PkgPath(gs, dwArg04);
}

// 080B2D00: void reflect.(*funcTypeFixed64).Name(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*funcTypeFixed64).Name(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).Name(gs, dwArg04);
}

// 080B2D40: void reflect.(*funcTypeFixed64).ChanDir(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*funcTypeFixed64).ChanDir(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).ChanDir(gs, dwArg04);
}

// 080B2D70: void reflect.(*funcTypeFixed64).IsVariadic(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*funcTypeFixed64).IsVariadic(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).IsVariadic(gs, dwArg04);
}

// 080B2DA0: void reflect.(*funcTypeFixed64).Elem(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*funcTypeFixed64).Elem(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).Elem(gs, dwArg04);
}

// 080B2DE0: void reflect.(*funcTypeFixed64).Field(Register (ptr32 Eq_2) gs)
void reflect.(*funcTypeFixed64).Field(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	fn0808FD83(0x00, (word32) fp + 0x0C);
	reflect.(*rtype).Field(gs, dwLoc04);
}

// 080B2E20: void reflect.(*funcTypeFixed64).FieldByIndex(Register (ptr32 Eq_2) gs)
void reflect.(*funcTypeFixed64).FieldByIndex(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	fn0808FD83(0x00, (word32) fp + 20);
	reflect.(*rtype).FieldByIndex(gs, dwLoc04);
}

// 080B2E60: void reflect.(*funcTypeFixed64).FieldByName(Register (ptr32 Eq_2) gs)
void reflect.(*funcTypeFixed64).FieldByName(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	fn0808FD83(0x00, (word32) fp + 16);
	reflect.(*rtype).FieldByName(gs, dwLoc04);
}

// 080B2EA0: void reflect.(*funcTypeFixed64).FieldByNameFunc(Register (ptr32 Eq_2) gs)
void reflect.(*funcTypeFixed64).FieldByNameFunc(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	fn0808FD83(0x00, (word32) fp + 0x0C);
	reflect.(*rtype).FieldByNameFunc(gs, dwLoc04);
}

// 080B2EE0: void reflect.(*funcTypeFixed64).In(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
void reflect.(*funcTypeFixed64).In(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).In(gs, dwArg04, dwArg08);
}

// 080B2F20: void reflect.(*funcTypeFixed64).Key(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*funcTypeFixed64).Key(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).Key(gs, dwArg04);
}

// 080B2F60: void reflect.(*funcTypeFixed64).Len(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*funcTypeFixed64).Len(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).Len(gs, dwArg04);
}

// 080B2F90: void reflect.(*funcTypeFixed64).NumField(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_113346) dwArg04)
void reflect.(*funcTypeFixed64).NumField(struct Eq_2 * gs, struct Eq_113346 * dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).NumField(gs, dwArg04);
}

// 080B2FC0: void reflect.(*funcTypeFixed64).NumIn(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*funcTypeFixed64).NumIn(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).NumIn(gs, dwArg04);
}

// 080B2FF0: void reflect.(*funcTypeFixed64).NumOut(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*funcTypeFixed64).NumOut(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).NumOut(gs, dwArg04);
}

// 080B3020: void reflect.(*funcTypeFixed64).Out(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
void reflect.(*funcTypeFixed64).Out(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).Out(gs, dwArg04, dwArg08);
}

// 080B3060: void reflect.(*funcTypeFixed64).Implements(Register (ptr32 Eq_2) gs, Stack word32 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C)
void reflect.(*funcTypeFixed64).Implements(struct Eq_2 * gs, word32 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).Implements(gs, dwArg04, dwArg08, dwArg0C);
}

// 080B3090: void reflect.(*funcTypeFixed64).AssignableTo(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C)
void reflect.(*funcTypeFixed64).AssignableTo(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).AssignableTo(gs, dwArg04, dwArg08, dwArg0C);
}

// 080B30C0: void reflect.(*funcTypeFixed64).ConvertibleTo(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg08)
void reflect.(*funcTypeFixed64).ConvertibleTo(struct Eq_2 * gs, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).ConvertibleTo(gs, dwArg08);
}

// 080B30F0: void reflect.(*funcTypeFixed64).Comparable(Register (ptr32 Eq_115122) gs, Stack (ptr32 Eq_115123) dwArg04)
void reflect.(*funcTypeFixed64).Comparable(struct Eq_115122 * gs, struct Eq_115123 * dwArg04)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	reflect.(*rtype).Comparable(gs, dwArg04);
}

// 080B3120: void reflect.(*funcTypeFixed8).uncommon(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*funcTypeFixed8).uncommon(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).uncommon(gs, dwArg04);
}

// 080B3150: void reflect.(*funcTypeFixed8).String(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*funcTypeFixed8).String(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).String(gs, dwArg04);
}

// 080B3190: void reflect.(*funcTypeFixed8).Size(Register (ptr32 Eq_111955) gs)
void reflect.(*funcTypeFixed8).Size(struct Eq_111955 * gs)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	reflect.(*rtype).Size(gs);
}

// 080B31C0: void reflect.(*funcTypeFixed8).Bits(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*funcTypeFixed8).Bits(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).Bits(gs, dwArg04);
}

// 080B31F0: void reflect.(*funcTypeFixed8).Align(Register (ptr32 Eq_112007) gs)
void reflect.(*funcTypeFixed8).Align(struct Eq_112007 * gs)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	reflect.(*rtype).Align(gs);
}

// 080B3220: void reflect.(*funcTypeFixed8).FieldAlign(Register (ptr32 Eq_112020) gs)
void reflect.(*funcTypeFixed8).FieldAlign(struct Eq_112020 * gs)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	reflect.(*rtype).FieldAlign(gs);
}

// 080B3250: void reflect.(*funcTypeFixed8).Kind(Register (ptr32 Eq_112033) gs)
void reflect.(*funcTypeFixed8).Kind(struct Eq_112033 * gs)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	reflect.(*rtype).Kind(gs);
}

// 080B3280: void reflect.(*funcTypeFixed8).common(Register (ptr32 Eq_112046) gs)
void reflect.(*funcTypeFixed8).common(struct Eq_112046 * gs)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	reflect.(*rtype).common(gs);
}

// 080B32B0: void reflect.(*funcTypeFixed8).NumMethod(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*funcTypeFixed8).NumMethod(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	word128 xmm1_48;
	reflect.(*rtype).NumMethod(gs, dwArg04, out xmm1_48);
}

// 080B32E0: void reflect.(*funcTypeFixed8).Method(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg00)
void reflect.(*funcTypeFixed8).Method(struct Eq_2 * gs, Eq_4 dwArg00)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	fn0808FD86(0x00, (word32) fp + 0x0C);
	reflect.(*rtype).Method(gs, dwLoc04, dwArg00);
}

// 080B3320: void reflect.(*funcTypeFixed8).MethodByName(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg00, Stack Eq_4 dwArg04)
void reflect.(*funcTypeFixed8).MethodByName(struct Eq_2 * gs, Eq_4 dwArg00, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	fn0808FD86(0x00, (word32) fp + 16);
	reflect.(*rtype).MethodByName(gs, dwLoc04, dwArg00, dwArg04);
}

// 080B3360: void reflect.(*funcTypeFixed8).PkgPath(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*funcTypeFixed8).PkgPath(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).PkgPath(gs, dwArg04);
}

// 080B33A0: void reflect.(*funcTypeFixed8).Name(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*funcTypeFixed8).Name(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).Name(gs, dwArg04);
}

// 080B33E0: void reflect.(*funcTypeFixed8).ChanDir(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*funcTypeFixed8).ChanDir(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).ChanDir(gs, dwArg04);
}

// 080B3410: void reflect.(*funcTypeFixed8).IsVariadic(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*funcTypeFixed8).IsVariadic(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).IsVariadic(gs, dwArg04);
}

// 080B3440: void reflect.(*funcTypeFixed8).Elem(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*funcTypeFixed8).Elem(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).Elem(gs, dwArg04);
}

// 080B3480: void reflect.(*funcTypeFixed8).Field(Register (ptr32 Eq_2) gs)
void reflect.(*funcTypeFixed8).Field(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	fn0808FD83(0x00, (word32) fp + 0x0C);
	reflect.(*rtype).Field(gs, dwLoc04);
}

// 080B34C0: void reflect.(*funcTypeFixed8).FieldByIndex(Register (ptr32 Eq_2) gs)
void reflect.(*funcTypeFixed8).FieldByIndex(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	fn0808FD83(0x00, (word32) fp + 20);
	reflect.(*rtype).FieldByIndex(gs, dwLoc04);
}

// 080B3500: void reflect.(*funcTypeFixed8).FieldByName(Register (ptr32 Eq_2) gs)
void reflect.(*funcTypeFixed8).FieldByName(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	fn0808FD83(0x00, (word32) fp + 16);
	reflect.(*rtype).FieldByName(gs, dwLoc04);
}

// 080B3540: void reflect.(*funcTypeFixed8).FieldByNameFunc(Register (ptr32 Eq_2) gs)
void reflect.(*funcTypeFixed8).FieldByNameFunc(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	fn0808FD83(0x00, (word32) fp + 0x0C);
	reflect.(*rtype).FieldByNameFunc(gs, dwLoc04);
}

// 080B3580: void reflect.(*funcTypeFixed8).In(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
void reflect.(*funcTypeFixed8).In(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).In(gs, dwArg04, dwArg08);
}

// 080B35C0: void reflect.(*funcTypeFixed8).Key(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*funcTypeFixed8).Key(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).Key(gs, dwArg04);
}

// 080B3600: void reflect.(*funcTypeFixed8).Len(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*funcTypeFixed8).Len(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).Len(gs, dwArg04);
}

// 080B3630: void reflect.(*funcTypeFixed8).NumField(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_113346) dwArg04)
void reflect.(*funcTypeFixed8).NumField(struct Eq_2 * gs, struct Eq_113346 * dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).NumField(gs, dwArg04);
}

// 080B3660: void reflect.(*funcTypeFixed8).NumIn(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*funcTypeFixed8).NumIn(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).NumIn(gs, dwArg04);
}

// 080B3690: void reflect.(*funcTypeFixed8).NumOut(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*funcTypeFixed8).NumOut(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).NumOut(gs, dwArg04);
}

// 080B36C0: void reflect.(*funcTypeFixed8).Out(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
void reflect.(*funcTypeFixed8).Out(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).Out(gs, dwArg04, dwArg08);
}

// 080B3700: void reflect.(*funcTypeFixed8).Implements(Register (ptr32 Eq_2) gs, Stack word32 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C)
void reflect.(*funcTypeFixed8).Implements(struct Eq_2 * gs, word32 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).Implements(gs, dwArg04, dwArg08, dwArg0C);
}

// 080B3730: void reflect.(*funcTypeFixed8).AssignableTo(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C)
void reflect.(*funcTypeFixed8).AssignableTo(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).AssignableTo(gs, dwArg04, dwArg08, dwArg0C);
}

// 080B3760: void reflect.(*funcTypeFixed8).ConvertibleTo(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg08)
void reflect.(*funcTypeFixed8).ConvertibleTo(struct Eq_2 * gs, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).ConvertibleTo(gs, dwArg08);
}

// 080B3790: void reflect.(*funcTypeFixed8).Comparable(Register (ptr32 Eq_115122) gs, Stack (ptr32 Eq_115123) dwArg04)
void reflect.(*funcTypeFixed8).Comparable(struct Eq_115122 * gs, struct Eq_115123 * dwArg04)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	reflect.(*rtype).Comparable(gs, dwArg04);
}

// 080B37C0: void reflect.(*interfaceType).uncommon(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*interfaceType).uncommon(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).uncommon(gs, dwArg04);
}

// 080B37F0: void reflect.(*interfaceType).String(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*interfaceType).String(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).String(gs, dwArg04);
}

// 080B3830: void reflect.(*interfaceType).Size(Register (ptr32 Eq_111955) gs)
void reflect.(*interfaceType).Size(struct Eq_111955 * gs)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	reflect.(*rtype).Size(gs);
}

// 080B3860: void reflect.(*interfaceType).Bits(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*interfaceType).Bits(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).Bits(gs, dwArg04);
}

// 080B3890: void reflect.(*interfaceType).Align(Register (ptr32 Eq_112007) gs)
void reflect.(*interfaceType).Align(struct Eq_112007 * gs)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	reflect.(*rtype).Align(gs);
}

// 080B38C0: void reflect.(*interfaceType).FieldAlign(Register (ptr32 Eq_112020) gs)
void reflect.(*interfaceType).FieldAlign(struct Eq_112020 * gs)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	reflect.(*rtype).FieldAlign(gs);
}

// 080B38F0: void reflect.(*interfaceType).Kind(Register (ptr32 Eq_112033) gs)
void reflect.(*interfaceType).Kind(struct Eq_112033 * gs)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	reflect.(*rtype).Kind(gs);
}

// 080B3920: void reflect.(*interfaceType).common(Register (ptr32 Eq_112046) gs)
void reflect.(*interfaceType).common(struct Eq_112046 * gs)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	reflect.(*rtype).common(gs);
}

// 080B3950: void reflect.(*interfaceType).PkgPath(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*interfaceType).PkgPath(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).PkgPath(gs, dwArg04);
}

// 080B3990: void reflect.(*interfaceType).Name(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*interfaceType).Name(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).Name(gs, dwArg04);
}

// 080B39D0: void reflect.(*interfaceType).ChanDir(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*interfaceType).ChanDir(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).ChanDir(gs, dwArg04);
}

// 080B3A00: void reflect.(*interfaceType).IsVariadic(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*interfaceType).IsVariadic(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).IsVariadic(gs, dwArg04);
}

// 080B3A30: void reflect.(*interfaceType).Elem(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*interfaceType).Elem(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).Elem(gs, dwArg04);
}

// 080B3A70: void reflect.(*interfaceType).Field(Register (ptr32 Eq_2) gs)
void reflect.(*interfaceType).Field(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	fn0808FD83(0x00, (word32) fp + 0x0C);
	reflect.(*rtype).Field(gs, dwLoc04);
}

// 080B3AB0: void reflect.(*interfaceType).FieldByIndex(Register (ptr32 Eq_2) gs)
void reflect.(*interfaceType).FieldByIndex(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	fn0808FD83(0x00, (word32) fp + 20);
	reflect.(*rtype).FieldByIndex(gs, dwLoc04);
}

// 080B3AF0: void reflect.(*interfaceType).FieldByName(Register (ptr32 Eq_2) gs)
void reflect.(*interfaceType).FieldByName(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	fn0808FD83(0x00, (word32) fp + 16);
	reflect.(*rtype).FieldByName(gs, dwLoc04);
}

// 080B3B30: void reflect.(*interfaceType).FieldByNameFunc(Register (ptr32 Eq_2) gs)
void reflect.(*interfaceType).FieldByNameFunc(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	fn0808FD83(0x00, (word32) fp + 0x0C);
	reflect.(*rtype).FieldByNameFunc(gs, dwLoc04);
}

// 080B3B70: void reflect.(*interfaceType).In(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
void reflect.(*interfaceType).In(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).In(gs, dwArg04, dwArg08);
}

// 080B3BB0: void reflect.(*interfaceType).Key(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*interfaceType).Key(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).Key(gs, dwArg04);
}

// 080B3BF0: void reflect.(*interfaceType).Len(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*interfaceType).Len(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).Len(gs, dwArg04);
}

// 080B3C20: void reflect.(*interfaceType).NumField(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_113346) dwArg04)
void reflect.(*interfaceType).NumField(struct Eq_2 * gs, struct Eq_113346 * dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).NumField(gs, dwArg04);
}

// 080B3C50: void reflect.(*interfaceType).NumIn(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*interfaceType).NumIn(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).NumIn(gs, dwArg04);
}

// 080B3C80: void reflect.(*interfaceType).NumOut(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*interfaceType).NumOut(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).NumOut(gs, dwArg04);
}

// 080B3CB0: void reflect.(*interfaceType).Out(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
void reflect.(*interfaceType).Out(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).Out(gs, dwArg04, dwArg08);
}

// 080B3CF0: void reflect.(*interfaceType).Implements(Register (ptr32 Eq_2) gs, Stack word32 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C)
void reflect.(*interfaceType).Implements(struct Eq_2 * gs, word32 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).Implements(gs, dwArg04, dwArg08, dwArg0C);
}

// 080B3D20: void reflect.(*interfaceType).AssignableTo(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C)
void reflect.(*interfaceType).AssignableTo(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).AssignableTo(gs, dwArg04, dwArg08, dwArg0C);
}

// 080B3D50: void reflect.(*interfaceType).ConvertibleTo(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg08)
void reflect.(*interfaceType).ConvertibleTo(struct Eq_2 * gs, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).ConvertibleTo(gs, dwArg08);
}

// 080B3D80: void reflect.(*interfaceType).Comparable(Register (ptr32 Eq_115122) gs, Stack (ptr32 Eq_115123) dwArg04)
void reflect.(*interfaceType).Comparable(struct Eq_115122 * gs, struct Eq_115123 * dwArg04)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	reflect.(*rtype).Comparable(gs, dwArg04);
}

// 080B3DB0: void reflect.(*ptrType).uncommon(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*ptrType).uncommon(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).uncommon(gs, dwArg04);
}

// 080B3DE0: void reflect.(*ptrType).String(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*ptrType).String(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).String(gs, dwArg04);
}

// 080B3E20: void reflect.(*ptrType).Size(Register (ptr32 Eq_111955) gs)
void reflect.(*ptrType).Size(struct Eq_111955 * gs)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	reflect.(*rtype).Size(gs);
}

// 080B3E50: void reflect.(*ptrType).Bits(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*ptrType).Bits(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).Bits(gs, dwArg04);
}

// 080B3E80: void reflect.(*ptrType).Align(Register (ptr32 Eq_112007) gs)
void reflect.(*ptrType).Align(struct Eq_112007 * gs)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	reflect.(*rtype).Align(gs);
}

// 080B3EB0: void reflect.(*ptrType).FieldAlign(Register (ptr32 Eq_112020) gs)
void reflect.(*ptrType).FieldAlign(struct Eq_112020 * gs)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	reflect.(*rtype).FieldAlign(gs);
}

// 080B3EE0: void reflect.(*ptrType).Kind(Register (ptr32 Eq_112033) gs)
void reflect.(*ptrType).Kind(struct Eq_112033 * gs)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	reflect.(*rtype).Kind(gs);
}

// 080B3F10: void reflect.(*ptrType).common(Register (ptr32 Eq_112046) gs)
void reflect.(*ptrType).common(struct Eq_112046 * gs)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	reflect.(*rtype).common(gs);
}

// 080B3F40: void reflect.(*ptrType).NumMethod(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*ptrType).NumMethod(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	word128 xmm1_48;
	reflect.(*rtype).NumMethod(gs, dwArg04, out xmm1_48);
}

// 080B3F70: void reflect.(*ptrType).Method(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg00)
void reflect.(*ptrType).Method(struct Eq_2 * gs, Eq_4 dwArg00)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	fn0808FD86(0x00, (word32) fp + 0x0C);
	reflect.(*rtype).Method(gs, dwLoc04, dwArg00);
}

// 080B3FB0: void reflect.(*ptrType).MethodByName(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg00, Stack Eq_4 dwArg04)
void reflect.(*ptrType).MethodByName(struct Eq_2 * gs, Eq_4 dwArg00, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	fn0808FD86(0x00, (word32) fp + 16);
	reflect.(*rtype).MethodByName(gs, dwLoc04, dwArg00, dwArg04);
}

// 080B3FF0: void reflect.(*ptrType).PkgPath(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*ptrType).PkgPath(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).PkgPath(gs, dwArg04);
}

// 080B4030: void reflect.(*ptrType).Name(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*ptrType).Name(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).Name(gs, dwArg04);
}

// 080B4070: void reflect.(*ptrType).ChanDir(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*ptrType).ChanDir(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).ChanDir(gs, dwArg04);
}

// 080B40A0: void reflect.(*ptrType).IsVariadic(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*ptrType).IsVariadic(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).IsVariadic(gs, dwArg04);
}

// 080B40D0: void reflect.(*ptrType).Elem(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*ptrType).Elem(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).Elem(gs, dwArg04);
}

// 080B4110: void reflect.(*ptrType).Field(Register (ptr32 Eq_2) gs)
void reflect.(*ptrType).Field(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	fn0808FD83(0x00, (word32) fp + 0x0C);
	reflect.(*rtype).Field(gs, dwLoc04);
}

// 080B4150: void reflect.(*ptrType).FieldByIndex(Register (ptr32 Eq_2) gs)
void reflect.(*ptrType).FieldByIndex(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	fn0808FD83(0x00, (word32) fp + 20);
	reflect.(*rtype).FieldByIndex(gs, dwLoc04);
}

// 080B4190: void reflect.(*ptrType).FieldByName(Register (ptr32 Eq_2) gs)
void reflect.(*ptrType).FieldByName(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	fn0808FD83(0x00, (word32) fp + 16);
	reflect.(*rtype).FieldByName(gs, dwLoc04);
}

// 080B41D0: void reflect.(*ptrType).FieldByNameFunc(Register (ptr32 Eq_2) gs)
void reflect.(*ptrType).FieldByNameFunc(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	fn0808FD83(0x00, (word32) fp + 0x0C);
	reflect.(*rtype).FieldByNameFunc(gs, dwLoc04);
}

// 080B4210: void reflect.(*ptrType).In(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
void reflect.(*ptrType).In(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).In(gs, dwArg04, dwArg08);
}

// 080B4250: void reflect.(*ptrType).Key(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*ptrType).Key(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).Key(gs, dwArg04);
}

// 080B4290: void reflect.(*ptrType).Len(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*ptrType).Len(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).Len(gs, dwArg04);
}

// 080B42C0: void reflect.(*ptrType).NumField(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_113346) dwArg04)
void reflect.(*ptrType).NumField(struct Eq_2 * gs, struct Eq_113346 * dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).NumField(gs, dwArg04);
}

// 080B42F0: void reflect.(*ptrType).NumIn(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*ptrType).NumIn(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).NumIn(gs, dwArg04);
}

// 080B4320: void reflect.(*ptrType).NumOut(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*ptrType).NumOut(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).NumOut(gs, dwArg04);
}

// 080B4350: void reflect.(*ptrType).Out(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
void reflect.(*ptrType).Out(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).Out(gs, dwArg04, dwArg08);
}

// 080B4390: void reflect.(*ptrType).Implements(Register (ptr32 Eq_2) gs, Stack word32 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C)
void reflect.(*ptrType).Implements(struct Eq_2 * gs, word32 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).Implements(gs, dwArg04, dwArg08, dwArg0C);
}

// 080B43C0: void reflect.(*ptrType).AssignableTo(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C)
void reflect.(*ptrType).AssignableTo(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).AssignableTo(gs, dwArg04, dwArg08, dwArg0C);
}

// 080B43F0: void reflect.(*ptrType).ConvertibleTo(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg08)
void reflect.(*ptrType).ConvertibleTo(struct Eq_2 * gs, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).ConvertibleTo(gs, dwArg08);
}

// 080B4420: void reflect.(*ptrType).Comparable(Register (ptr32 Eq_115122) gs, Stack (ptr32 Eq_115123) dwArg04)
void reflect.(*ptrType).Comparable(struct Eq_115122 * gs, struct Eq_115123 * dwArg04)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	reflect.(*rtype).Comparable(gs, dwArg04);
}

// 080B4450: void reflect.(*sliceType).uncommon(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*sliceType).uncommon(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).uncommon(gs, dwArg04);
}

// 080B4480: void reflect.(*sliceType).String(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*sliceType).String(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).String(gs, dwArg04);
}

// 080B44C0: void reflect.(*sliceType).Size(Register (ptr32 Eq_111955) gs)
void reflect.(*sliceType).Size(struct Eq_111955 * gs)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	reflect.(*rtype).Size(gs);
}

// 080B44F0: void reflect.(*sliceType).Bits(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*sliceType).Bits(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).Bits(gs, dwArg04);
}

// 080B4520: void reflect.(*sliceType).Align(Register (ptr32 Eq_112007) gs)
void reflect.(*sliceType).Align(struct Eq_112007 * gs)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	reflect.(*rtype).Align(gs);
}

// 080B4550: void reflect.(*sliceType).FieldAlign(Register (ptr32 Eq_112020) gs)
void reflect.(*sliceType).FieldAlign(struct Eq_112020 * gs)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	reflect.(*rtype).FieldAlign(gs);
}

// 080B4580: void reflect.(*sliceType).Kind(Register (ptr32 Eq_112033) gs)
void reflect.(*sliceType).Kind(struct Eq_112033 * gs)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	reflect.(*rtype).Kind(gs);
}

// 080B45B0: void reflect.(*sliceType).common(Register (ptr32 Eq_112046) gs)
void reflect.(*sliceType).common(struct Eq_112046 * gs)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	reflect.(*rtype).common(gs);
}

// 080B45E0: void reflect.(*sliceType).NumMethod(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*sliceType).NumMethod(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	word128 xmm1_48;
	reflect.(*rtype).NumMethod(gs, dwArg04, out xmm1_48);
}

// 080B4610: void reflect.(*sliceType).Method(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg00)
void reflect.(*sliceType).Method(struct Eq_2 * gs, Eq_4 dwArg00)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	fn0808FD86(0x00, (word32) fp + 0x0C);
	reflect.(*rtype).Method(gs, dwLoc04, dwArg00);
}

// 080B4650: void reflect.(*sliceType).MethodByName(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg00, Stack Eq_4 dwArg04)
void reflect.(*sliceType).MethodByName(struct Eq_2 * gs, Eq_4 dwArg00, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	fn0808FD86(0x00, (word32) fp + 16);
	reflect.(*rtype).MethodByName(gs, dwLoc04, dwArg00, dwArg04);
}

// 080B4690: void reflect.(*sliceType).PkgPath(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*sliceType).PkgPath(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).PkgPath(gs, dwArg04);
}

// 080B46D0: void reflect.(*sliceType).Name(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*sliceType).Name(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).Name(gs, dwArg04);
}

// 080B4710: void reflect.(*sliceType).ChanDir(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*sliceType).ChanDir(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).ChanDir(gs, dwArg04);
}

// 080B4740: void reflect.(*sliceType).IsVariadic(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*sliceType).IsVariadic(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).IsVariadic(gs, dwArg04);
}

// 080B4770: void reflect.(*sliceType).Elem(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*sliceType).Elem(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).Elem(gs, dwArg04);
}

// 080B47B0: void reflect.(*sliceType).Field(Register (ptr32 Eq_2) gs)
void reflect.(*sliceType).Field(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	fn0808FD83(0x00, (word32) fp + 0x0C);
	reflect.(*rtype).Field(gs, dwLoc04);
}

// 080B47F0: void reflect.(*sliceType).FieldByIndex(Register (ptr32 Eq_2) gs)
void reflect.(*sliceType).FieldByIndex(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	fn0808FD83(0x00, (word32) fp + 20);
	reflect.(*rtype).FieldByIndex(gs, dwLoc04);
}

// 080B4830: void reflect.(*sliceType).FieldByName(Register (ptr32 Eq_2) gs)
void reflect.(*sliceType).FieldByName(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	fn0808FD83(0x00, (word32) fp + 16);
	reflect.(*rtype).FieldByName(gs, dwLoc04);
}

// 080B4870: void reflect.(*sliceType).FieldByNameFunc(Register (ptr32 Eq_2) gs)
void reflect.(*sliceType).FieldByNameFunc(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	fn0808FD83(0x00, (word32) fp + 0x0C);
	reflect.(*rtype).FieldByNameFunc(gs, dwLoc04);
}

// 080B48B0: void reflect.(*sliceType).In(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
void reflect.(*sliceType).In(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).In(gs, dwArg04, dwArg08);
}

// 080B48F0: void reflect.(*sliceType).Key(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*sliceType).Key(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).Key(gs, dwArg04);
}

// 080B4930: void reflect.(*sliceType).Len(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*sliceType).Len(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).Len(gs, dwArg04);
}

// 080B4960: void reflect.(*sliceType).NumField(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_113346) dwArg04)
void reflect.(*sliceType).NumField(struct Eq_2 * gs, struct Eq_113346 * dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).NumField(gs, dwArg04);
}

// 080B4990: void reflect.(*sliceType).NumIn(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*sliceType).NumIn(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).NumIn(gs, dwArg04);
}

// 080B49C0: void reflect.(*sliceType).NumOut(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
void reflect.(*sliceType).NumOut(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).NumOut(gs, dwArg04);
}

// 080B49F0: void reflect.(*sliceType).Out(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
void reflect.(*sliceType).Out(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).Out(gs, dwArg04, dwArg08);
}

// 080B4A30: void reflect.(*sliceType).Implements(Register (ptr32 Eq_2) gs, Stack word32 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C)
void reflect.(*sliceType).Implements(struct Eq_2 * gs, word32 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).Implements(gs, dwArg04, dwArg08, dwArg0C);
}

// 080B4A60: void reflect.(*sliceType).AssignableTo(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C)
void reflect.(*sliceType).AssignableTo(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).AssignableTo(gs, dwArg04, dwArg08, dwArg0C);
}

// 080B4A90: void reflect.(*sliceType).ConvertibleTo(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg08)
void reflect.(*sliceType).ConvertibleTo(struct Eq_2 * gs, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.(*rtype).ConvertibleTo(gs, dwArg08);
}

// 080B4AC0: void reflect.(*sliceType).Comparable(Register (ptr32 Eq_115122) gs, Stack (ptr32 Eq_115123) dwArg04)
void reflect.(*sliceType).Comparable(struct Eq_115122 * gs, struct Eq_115123 * dwArg04)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	reflect.(*rtype).Comparable(gs, dwArg04);
}

// 080B4AF0: void type..hash.[27]string(Register (ptr32 Eq_2) gs, Register Eq_4 mm0, Stack word32 dwArg04, Stack (ptr32 Eq_205) dwArg08)
void type..hash.[27]string(struct Eq_2 * gs, Eq_4 mm0, word32 dwArg04, union Eq_205 * dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	int32 eax_17;
	union Eq_205 * ecx_20 = dwArg08;
	for (eax_17 = 0x00; eax_17 < 0x1B; ++eax_17)
	{
		mm0 = runtime.strhash(gs, mm0, dwArg04 + eax_17 * 0x08, ecx_20);
		ecx_20 = dwLoc08;
	}
}

// 080B4B50: void type..eq.[27]string(Register (ptr32 Eq_128633) gs, Stack word32 dwArg04, Stack word32 dwArg08)
void type..eq.[27]string(struct Eq_128633 * gs, word32 dwArg04, word32 dwArg08)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	int32 eax_17;
	for (eax_17 = 0x00; eax_17 < 0x1B; ++eax_17)
	{
		struct Eq_128652 * edx_29 = dwArg08 + eax_17 * 0x08;
		struct Eq_128656 * esi_32 = dwArg04 + eax_17 * 0x08;
		Eq_4 edx_33 = edx_29->t0000;
		Eq_4 edi_34 = esi_32->t0004;
		Eq_4 esi_35 = esi_32->t0000;
		if (edi_34 != edx_29->t0004)
			return;
		word32 ebx_129;
		word32 esi_130;
		word32 edi_131;
		runtime.eqstring(edx_33, esi_35, edi_34, edx_33, out ebx_129, out esi_130, out edi_131);
		if (bLoc08 == 0x00)
			return;
	}
}

// 080B4BD0: void type..hash.struct { reflect.b bool; reflect.x interface {} }(Register (ptr32 Eq_2) gs, Register Eq_4 mm0, Stack (ptr32 Eq_205) dwArg04, Stack (ptr32 Eq_205) dwArg08)
void type..hash.struct { reflect.b bool; reflect.x interface {} }(struct Eq_2 * gs, Eq_4 mm0, union Eq_205 * dwArg04, union Eq_205 * dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	word128 xmm1_81;
	runtime.memhash(gs, mm0, dwArg04, dwArg08, 0x01, out xmm1_81);
	runtime.nilinterhash(gs, (char *) dwArg04 + 4, dwLoc04);
}

// 080B4C30: void type..eq.struct { reflect.b bool; reflect.x interface {} }(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_128716) dwArg04, Stack (ptr32 Eq_128717) dwArg08)
void type..eq.struct { reflect.b bool; reflect.x interface {} }(struct Eq_2 * gs, struct Eq_128716 * dwArg04, struct Eq_128717 * dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (dwArg04->b0000 == dwArg08->b0000)
	{
		word32 ecx_28 = dwArg04->dw0008;
		Eq_4 eax_29 = dwArg04->t0004;
		Eq_4 ebx_30 = dwArg08->t0008;
		if (eax_29 == dwArg08->t0004)
			runtime.efaceeq(gs, eax_29, ecx_28, ebx_30);
	}
}

// 080B4CA0: void type..hash.struct { F uintptr; reflect.name string }(Register (ptr32 Eq_2) gs, Register Eq_4 mm0, Stack (ptr32 Eq_205) dwArg04, Stack (ptr32 Eq_205) dwArg08)
void type..hash.struct { F uintptr; reflect.name string }(struct Eq_2 * gs, Eq_4 mm0, union Eq_205 * dwArg04, union Eq_205 * dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	word128 xmm1_92;
	runtime.strhash(gs, runtime.memhash(gs, mm0, dwArg04, dwArg08, 0x04, out xmm1_92), (char *) dwArg04 + 4, dwLoc04);
}

// 080B4D00: void type..eq.struct { F uintptr; reflect.name string }(Register (ptr32 Eq_128781) gs, Stack (ptr32 Eq_128782) dwArg04, Stack (ptr32 Eq_128783) dwArg08)
void type..eq.struct { F uintptr; reflect.name string }(struct Eq_128781 * gs, struct Eq_128782 * dwArg04, struct Eq_128783 * dwArg08)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	if (dwArg04->dw0000 == dwArg08->dw0000)
	{
		Eq_4 edx_27 = dwArg08->t0004;
		Eq_4 ebx_28 = dwArg04->t0008;
		Eq_4 eax_29 = dwArg04->t0004;
		if (ebx_28 == dwArg08->t0008)
		{
			word32 ebx_94;
			word32 esi_95;
			word32 edi_96;
			runtime.eqstring(edx_27, eax_29, ebx_28, edx_27, out ebx_94, out esi_95, out edi_96);
		}
	}
}

// 080B4D70: Register word128 fmt.(*fmt).writePadding(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_128829) dwArg04, Stack Eq_4 dwArg08, Register out Eq_128831 xmm1Out)
// Called from:
//      fmt.(*fmt).pad
//      fmt.(*fmt).padString
//      fmt.(*fmt).fmt_integer
//      fmt.(*fmt).fmt_sbx
//      fmt.(*fmt).fmt_float
word128 fmt.(*fmt).writePadding(struct Eq_2 * gs, struct Eq_128829 * dwArg04, Eq_4 dwArg08, union Eq_128831 & xmm1Out)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (dwArg08 <= 0x00)
	{
		xmm1Out = xmm1;
		return xmm0;
	}
	else
	{
		Eq_4 edx_23 = dwArg04->t0000;
		Eq_4 ebp_27 = *((word32) edx_23 + 4);
		Eq_4 ebx_118 = *((word32) edx_23 + 8);
		Eq_4 edx_133 = *edx_23;
		word32 esi_29 = dwArg08 + ebp_27;
		if (esi_29 > ebx_118)
		{
			Eq_4 ecx_36 = (word32) dwArg08 + ebx_118 * 0x02;
			word32 edi_325;
			runtime.makeslice(gs, 0x080CF320, ecx_36, ecx_36, out edi_325);
			Eq_4 ecx_51 = dwArg04->t0000;
			Eq_4 esi_56 = *((word32) ecx_51 + 4);
			Eq_4 ecx_57 = *ecx_51;
			if (dwLoc18 <= esi_56)
				esi_56 = dwLoc18;
			word32 edi_328;
			word128 xmm2_329;
			word32 ebp_326;
			word32 esi_327;
			runtime.memmove(dwLoc1C, ecx_57, esi_56, out ebp_326, out esi_327, out edi_328, out xmm0, out xmm1, out xmm2_329);
			edx_133 = dwLoc1C;
			ebx_118 = dwLoc14;
		}
		word32 edi_109;
		if (dwArg04->b000A != 0x00)
			edi_109 = 0x30;
		else
			edi_109 = 0x20;
		if (ebp_27 > esi_29 || esi_29 > ebx_118)
			runtime.panicslice(gs);
		else
		{
			int32 ebx_134 = (word32) edx_133 + (ebp_27 & ebp_27 - ebx_118 >> 0x1F);
			Eq_4 ebp_135 = 0x00;
			while (ebp_135 < dwArg08)
			{
				if (ebp_135 >= dwArg08)
					runtime.panicindex(gs);
				*((word32) ebp_135 + ebx_134) = (byte) edi_109;
				ebp_135 = (word32) ebp_135 + 1;
			}
			Eq_4 eax_144 = dwArg04->t0000;
			*((word32) eax_144 + 4) = esi_29;
			*((word32) eax_144 + 8) = ebx_118;
			if (g_t81576F0 == 0x00)
				*eax_144 = edx_133;
			else
				runtime.writebarrierptr(eax_144, edx_133);
			xmm1Out = xmm1;
			return xmm0;
		}
	}
}

// 080B4EC0: void fmt.(*fmt).pad(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_128829) dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C)
// Called from:
//      fmt.(*fmt).fmt_unicode
//      fmt.(*fmt).fmt_integer
//      fmt.(*fmt).fmt_q
//      fmt.(*fmt).fmt_c
//      fmt.(*fmt).fmt_qc
//      fmt.(*fmt).fmt_float
void fmt.(*fmt).pad(struct Eq_2 * gs, struct Eq_128829 * dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (dwArg04->b0004 == 0x00 || dwArg04->t0010 == 0x00)
	{
		Eq_4 eax_312 = dwArg04->t0000;
		Eq_4 ecx_315 = *((word32) eax_312 + 4);
		word32 ebx_317 = ecx_315 + dwArg0C;
		Eq_4 ebp_319 = *eax_312;
		Eq_4 esi_320 = *((word32) eax_312 + 8);
		if (ebx_317 > esi_320)
		{
			word128 xmm1_575;
			word128 xmm0_574;
			word32 esi_573;
			runtime.growslice(gs, 0x080CF320, ebp_319, ecx_315, esi_320, ebx_317, out esi_573, out xmm0_574, out xmm1_575);
			esi_320 = dwLoc20;
			ebp_319 = dwLoc28;
		}
		if (ebx_317 > esi_320)
			runtime.panicslice(gs);
		else
		{
			word128 xmm2_581;
			word128 xmm1_580;
			word128 xmm0_579;
			word32 edi_578;
			word32 esi_577;
			word32 ebp_576;
			runtime.memmove(ebp_319 + ecx_315, dwArg08, dwArg0C, out ebp_576, out esi_577, out edi_578, out xmm0_579, out xmm1_580, out xmm2_581);
			*((word32) eax_312 + 4) = ebx_317;
			*((word32) eax_312 + 8) = esi_320;
			if (g_t81576F0 == 0x00)
				*eax_312 = ebp_319;
			else
				runtime.writebarrierptr(eax_312, ebp_319);
		}
	}
	else
	{
		unicode/utf8.RuneCount(gs, dwArg08, dwArg0C);
		Eq_4 ecx_47 = dwArg04->t0010 - dwLoc30;
		if (dwArg04->b0006 == 0x00)
		{
			word128 xmm1_582;
			fmt.(*fmt).writePadding(gs, dwArg04, ecx_47, out xmm1_582);
			Eq_4 eax_76 = dwArg04->t0000;
			Eq_4 ecx_78 = *((word32) eax_76 + 4);
			word32 ebx_80 = dwArg0C + ecx_78;
			Eq_4 ebp_113 = *((word32) eax_76 + 8);
			Eq_4 esi_114 = *eax_76;
			if (ebx_80 > ebp_113)
			{
				word32 esi_592;
				word128 xmm0_593;
				word128 xmm1_594;
				runtime.growslice(gs, 0x080CF320, esi_114, ecx_78, ebp_113, ebx_80, out esi_592, out xmm0_593, out xmm1_594);
				ebp_113 = dwLoc20;
				esi_114 = dwLoc28;
			}
			if (ebx_80 > ebp_113)
				runtime.panicslice(gs);
			else
			{
				word32 ebp_595;
				word32 esi_596;
				word32 edi_597;
				word128 xmm0_598;
				word128 xmm1_599;
				word128 xmm2_600;
				runtime.memmove(esi_114 + ecx_78, dwArg08, dwArg0C, out ebp_595, out esi_596, out edi_597, out xmm0_598, out xmm1_599, out xmm2_600);
				*((word32) eax_76 + 4) = ebx_80;
				*((word32) eax_76 + 8) = ebp_113;
				if (g_t81576F0 == 0x00)
					*eax_76 = esi_114;
				else
					runtime.writebarrierptr(eax_76, esi_114);
			}
		}
		else
		{
			Eq_4 edx_178 = dwArg04->t0000;
			Eq_4 ebx_180 = *((word32) edx_178 + 4);
			word32 esi_182 = dwArg0C + ebx_180;
			Eq_4 edi_184 = *((word32) edx_178 + 8);
			Eq_4 ecx_185 = *edx_178;
			if (esi_182 > edi_184)
			{
				word128 xmm1_585;
				word32 esi_583;
				word128 xmm0_584;
				runtime.growslice(gs, 0x080CF320, ecx_185, ebx_180, edi_184, esi_182, out esi_583, out xmm0_584, out xmm1_585);
				edi_184 = dwLoc20;
				ecx_185 = dwLoc28;
			}
			if (esi_182 > edi_184)
				runtime.panicslice(gs);
			else
			{
				word32 ebp_586;
				word32 esi_587;
				word32 edi_588;
				word128 xmm0_589;
				word128 xmm1_590;
				word128 xmm2_591;
				runtime.memmove(ecx_185 + ebx_180, dwArg08, dwArg0C, out ebp_586, out esi_587, out edi_588, out xmm0_589, out xmm1_590, out xmm2_591);
				*((word32) edx_178 + 4) = esi_182;
				*((word32) edx_178 + 8) = edi_184;
				if (g_t81576F0 == 0x00)
					*edx_178 = ecx_185;
				else
					runtime.writebarrierptr(edx_178, ecx_185);
				word128 xmm1_601;
				fmt.(*fmt).writePadding(gs, dwArg04, ecx_47, out xmm1_601);
			}
		}
	}
}

// 080B51B0: Register word128 fmt.(*fmt).padString(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_128829) dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C, Register out Eq_129190 xmm1Out)
// Called from:
//      fmt.(*fmt).fmt_boolean
//      fmt.(*fmt).fmt_s
//      fmt.(*fmt).fmt_q
//      fmt.(*pp).fmtPointer
//      fmt.(*pp).printArg
word128 fmt.(*fmt).padString(struct Eq_2 * gs, struct Eq_128829 * dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C, union Eq_129190 & xmm1Out)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (dwArg04->b0004 == 0x00 || dwArg04->t0010 == 0x00)
	{
		Eq_4 eax_310 = dwArg04->t0000;
		Eq_4 ecx_313 = *((word32) eax_310 + 4);
		word32 ebx_315 = dwArg0C + ecx_313;
		Eq_4 ebp_317 = *((word32) eax_310 + 8);
		Eq_4 esi_318 = *eax_310;
		if (ebx_315 > ebp_317)
		{
			word128 xmm1_571;
			word128 xmm0_570;
			word32 esi_569;
			runtime.growslice(gs, 0x080CF320, esi_318, ecx_313, ebp_317, ebx_315, out esi_569, out xmm0_570, out xmm1_571);
			ebp_317 = dwLoc20;
			esi_318 = dwLoc28;
		}
		if (ebx_315 > ebp_317)
			runtime.panicslice(gs);
		else
		{
			word128 xmm0_378;
			Eq_129190 xmm1_379;
			word128 xmm2_575;
			word32 edi_574;
			word32 esi_573;
			word32 ebp_572;
			runtime.memmove(esi_318 + ecx_313, dwArg08, dwArg0C, out ebp_572, out esi_573, out edi_574, out xmm0_378, out xmm1_379, out xmm2_575);
			*((word32) eax_310 + 4) = ebx_315;
			*((word32) eax_310 + 8) = ebp_317;
			if (g_t81576F0 == 0x00)
				*eax_310 = esi_318;
			else
				runtime.writebarrierptr(eax_310, esi_318);
			xmm1Out = xmm1_379;
			return xmm0_378;
		}
	}
	else
	{
		Eq_129190 xmm1_141;
		word128 xmm0_140;
		unicode/utf8.RuneCountInString(gs, dwArg08, dwArg0C);
		Eq_4 ecx_45 = dwArg04->t0010 - dwLoc34;
		if (dwArg04->b0006 != 0x00)
		{
			Eq_4 edx_176 = dwArg04->t0000;
			Eq_4 ebx_178 = *((word32) edx_176 + 4);
			word32 esi_180 = dwArg0C + ebx_178;
			Eq_4 edi_182 = *((word32) edx_176 + 8);
			Eq_4 ecx_183 = *edx_176;
			if (esi_180 > edi_182)
			{
				word32 esi_577;
				word128 xmm0_578;
				word128 xmm1_579;
				runtime.growslice(gs, 0x080CF320, ecx_183, ebx_178, edi_182, esi_180, out esi_577, out xmm0_578, out xmm1_579);
				edi_182 = dwLoc20;
				ecx_183 = dwLoc28;
			}
			if (esi_180 > edi_182)
				runtime.panicslice(gs);
			word32 esi_581;
			word32 edi_582;
			word128 xmm0_583;
			word128 xmm1_584;
			word128 xmm2_585;
			word32 ebp_580;
			runtime.memmove(ecx_183 + ebx_178, dwArg08, dwArg0C, out ebp_580, out esi_581, out edi_582, out xmm0_583, out xmm1_584, out xmm2_585);
			*((word32) edx_176 + 4) = esi_180;
			*((word32) edx_176 + 8) = edi_182;
			if (g_t81576F0 == 0x00)
				*edx_176 = ecx_183;
			else
				runtime.writebarrierptr(edx_176, ecx_183);
			xmm0_140 = fmt.(*fmt).writePadding(gs, dwArg04, ecx_45, out xmm1_141);
		}
		else
		{
			word128 xmm1_576;
			fmt.(*fmt).writePadding(gs, dwArg04, ecx_45, out xmm1_576);
			Eq_4 eax_74 = dwArg04->t0000;
			Eq_4 ecx_76 = *((word32) eax_74 + 4);
			word32 ebx_78 = dwArg0C + ecx_76;
			Eq_4 ebp_111 = *((word32) eax_74 + 8);
			Eq_4 esi_112 = *eax_74;
			if (ebx_78 > ebp_111)
			{
				word32 esi_586;
				word128 xmm0_587;
				word128 xmm1_588;
				runtime.growslice(gs, 0x080CF320, esi_112, ecx_76, ebp_111, ebx_78, out esi_586, out xmm0_587, out xmm1_588);
				ebp_111 = dwLoc20;
				esi_112 = dwLoc28;
			}
			if (ebx_78 > ebp_111)
				runtime.panicslice(gs);
			word32 ebp_589;
			word32 esi_590;
			word32 edi_591;
			word128 xmm2_592;
			runtime.memmove(esi_112 + ecx_76, dwArg08, dwArg0C, out ebp_589, out esi_590, out edi_591, out xmm0_140, out xmm1_141, out xmm2_592);
			*((word32) eax_74 + 4) = ebx_78;
			*((word32) eax_74 + 8) = ebp_111;
			if (g_t81576F0 == 0x00)
				*eax_74 = esi_112;
			else
				runtime.writebarrierptr(eax_74, esi_112);
		}
		xmm1Out = xmm1_141;
		return xmm0_140;
	}
}

// 080B5490: void fmt.(*fmt).fmt_boolean(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_128829) dwArg04, Stack byte bArg08)
// Called from:
//      fmt.(*pp).fmtBool
void fmt.(*fmt).fmt_boolean(struct Eq_2 * gs, struct Eq_128829 * dwArg04, byte bArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (bArg08 != 0x00)
	{
		word128 xmm1_111;
		fmt.(*fmt).padString(gs, dwArg04, 0x080E0F4A, 0x04, out xmm1_111);
	}
	else
	{
		word128 xmm1_110;
		fmt.(*fmt).padString(gs, dwArg04, 0x080E102E, 0x05, out xmm1_110);
	}
}

// 080B5500: void fmt.(*fmt).fmt_unicode(Register word32 edi, Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_128829) dwArg04, Stack Eq_4 dwArg08, Stack uint32 dwArg0C)
// Called from:
//      fmt.(*pp).fmtInteger
void fmt.(*fmt).fmt_unicode(word32 edi, struct Eq_2 * gs, struct Eq_128829 * dwArg04, Eq_4 dwArg08, uint32 dwArg0C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 edx_118;
	Eq_129621 (* ebx_27)[];
	Eq_129621 (* ebp_26)[];
	Eq_129621 ecx_116[] = (char *) &dwArg04->t0014 + 4;
	if (dwArg04->b0005 != 0x00)
	{
		edx_118 = dwArg04->t0014;
		if (edx_118 > 0x04)
		{
			if (edx_118 <= 0x3B)
			{
				ebx_27 = (Eq_129621 (*)[]) 0x44;
				ebp_26 = (Eq_129621 (*)[]) 0x44;
			}
			else
			{
				runtime.makeslice(gs, 0x080CF320, (byte) edx_118.u0 + 9, (byte) edx_118.u0 + 9, out edi);
				bLoc30 = (byte) edx_118 + 0x09;
				ecx_116 = dwLoc28;
				ebp_26 = dwLoc20;
				ebx_27 = dwLoc24;
			}
		}
		else
		{
			ebp_26 = (Eq_129621 (*)[]) 0x44;
			ebx_27 = (Eq_129621 (*)[]) 0x44;
			edx_118.u0 = 0x04;
		}
	}
	else
	{
		ebp_26 = (Eq_129621 (*)[]) 0x44;
		ebx_27 = (Eq_129621 (*)[]) 0x44;
		edx_118.u0 = 0x04;
	}
	uint32 esi_217;
	Eq_129621 (* ebx_210)[];
	Eq_4 ebp_216;
	Eq_4 edx_215;
	ui24 eax_24_8_98 = SLICE(dwArg04, word24, 8);
	if (dwArg04->b0008 != 0x00)
	{
		ui32 edi_104 = SEQ(SLICE(edi, word24, 8), (int8) (dwArg0C == 0x00)) & SEQ(eax_24_8_98, (int8) (dwArg08 <= 1114111)) | SEQ(eax_24_8_98, (int8) Test(ULT,false));
		if ((byte) edi_104 != 0x00)
		{
			strconv.IsPrint(gs, dwArg08);
			if (bLoc30 != 0x00)
			{
				if (ebx_27 - 0x01 >= ebx_27)
					runtime.panicindex(gs);
				ui32 ebp_159;
				Mem143[ebx_27 - 0x01 + ecx_116:byte] = 0x27;
				if (dwArg08 < 0x00)
					ebp_159 = ~0x00;
				else if (dwArg08 <= 0x7F)
					ebp_159 = 0x01;
				else if (dwArg08 <= 0x07FF)
					ebp_159 = 0x02;
				else if (dwArg08 <= ~0xDFFE)
					ebp_159 = ~0x00;
				else if (dwArg08 <= 0xFFFF)
					ebp_159 = 0x03;
				else if (dwArg08 <= 1114111)
					ebp_159 = 0x04;
				else
					ebp_159 = ~0x00;
				Eq_129621 (* ecx_168)[] = ebx_27 - 0x01 - ebp_159;
				if (ecx_168 > ebx_27)
					runtime.panicslice(gs);
				word32 ebp_176 = ebp_26 - ecx_168;
				unicode/utf8.EncodeRune(gs, &(ecx_116 + (-ebp_176 >> 0x1F & ecx_168))->t0000, ebx_27 - ecx_168, dwArg08);
				if (ecx_168 - 0x01 >= ebx_27)
					runtime.panicindex(gs);
				Mem209[ecx_168 - 0x01 + ecx_116:byte] = 0x27;
				ebx_210 = ecx_168 - (Eq_129621 (*)[]) 0x02;
				if (ecx_168 - (Eq_129621 (*)[]) 0x02 >= ebx_27)
					runtime.panicindex(gs);
				Mem213[ecx_168 - 0x02 + ecx_116:byte] = 0x20;
				edx_215 = edx_118;
				ebp_216 = dwArg08;
				esi_217 = dwArg0C;
l080B55B7:
				while (((int8) (ebp_216 >= 0x10) & (int8) (esi_217 == 0x00) | (int8) (esi_217 > 0x00)) != 0x00)
				{
					Eq_129621 (* edx_372)[] = ebx_210 - 0x01;
					word32 ebp_375 = (word32) (ebp_216 & 0x0F)->b80E26DB;
					if (edx_372 >= ebx_27)
						runtime.panicindex(gs);
					ecx_116[ebx_210 - 0x01].t0000.u0 = (byte) ebp_375;
					ebp_216 = esi_217 << 0x1C | ebp_216 >> 0x04;
					esi_217 >>= 0x04;
					ebx_210 = edx_372;
					--edx_215;
				}
				if (esi_217 == 0x00 && ebp_216 < 0x11)
				{
					Eq_129621 (* edx_272)[] = ebx_210 - (Eq_129621 (*)[]) 0x01;
					word32 ebp_274 = (word32) *((word32) ebp_216 + 135145179);
					if (edx_272 < ebx_27)
					{
						Mem284[ebx_210 - 0x01 + ecx_116:byte] = SLICE(ebp_274, byte, 0);
						int32 ebx_289;
						for (ebx_289 = edx_215 - 0x01; ebx_289 > 0x00; --ebx_289)
						{
							Eq_129621 (* ebp_364)[] = edx_272 - (Eq_129621 (*)[]) 0x01;
							if (ebp_364 >= ebx_27)
								runtime.panicindex(gs);
							Mem367[edx_272 - 0x01 + ecx_116:byte] = 0x30;
							edx_272 = ebp_364;
						}
						if (edx_272 - (Eq_129621 (*)[]) 0x01 >= ebx_27)
							runtime.panicindex(gs);
						else
						{
							Mem301[edx_272 - 0x01 + ecx_116:byte] = 0x2B;
							Eq_129621 (* ebx_302)[] = edx_272 - (Eq_129621 (*)[]) 0x02;
							if (ebx_302 >= ebx_27)
								runtime.panicindex(gs);
							else
							{
								Mem305[edx_272 - 0x02 + ecx_116:byte] = 0x55;
								byte al_312 = dwArg04->b000A;
								dwArg04->b000A = 0x00;
								fmt.(*fmt).pad(gs, dwArg04, ecx_116 + (ebx_302 - ebp_26 >> 0x1F & ebx_302), ebx_27 - ebx_302);
								dwArg04->b000A = al_312;
								return;
							}
						}
					}
				}
				runtime.panicindex(gs);
			}
		}
	}
	esi_217 = dwArg0C;
	ebp_216 = dwArg08;
	edx_215 = edx_118;
	ebx_210 = ebx_27;
	goto l080B55B7;
}

// 080B58A0: void fmt.(*fmt).fmt_integer(Register ui24 ebx_24_8, Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_128829) dwArg04, Stack Eq_4 qwArg08, Stack int32 dwArg10, Stack byte bArg14, Stack (ptr32 Eq_129732) dwArg18, Stack Eq_4 dwArg1C)
// Called from:
//      fmt.(*pp).fmt0x64
//      fmt.(*pp).fmtInteger
//      fmt.(*pp).fmtBytes
void fmt.(*fmt).fmt_integer(ui24 ebx_24_8, struct Eq_2 * gs, struct Eq_128829 * dwArg04, Eq_4 qwArg08, int32 dwArg10, byte bArg14, struct Eq_129732 * dwArg18, Eq_4 dwArg1C)
{
	Eq_4 dwArg0C = SLICE(qwArg08, word32, 32);
	Eq_4 dwArg08 = (word32) qwArg08;
	while (true)
	{
		Eq_4 ecx_7 = gs->ptr0000->tFFFFFFFC;
		ui24 ecx_24_8_34 = SLICE(ecx_7, word24, 8);
		if (fp > *((word32) ecx_7 + 8))
			break;
		runtime.morestack_noctxt();
	}
	byte bl_47;
	if (bArg14 != 0x00)
	{
		ui32 ebx_44 = SEQ(ebx_24_8, (int8) (dwArg0C < 0x00)) | SEQ(ecx_24_8_34, (int8) (dwArg0C == 0x00)) & SEQ(ebx_24_8, (int8) Test(ULT,false));
		bl_47 = (byte) ebx_44;
	}
	else
		bl_47 = 0x00;
	Eq_4 edx_108;
	Eq_4 ecx_104;
	if (bl_47 != 0x00)
	{
		ui64 edx_ecx_777 = 0x00 - qwArg08;
		ecx_104 = (word32) edx_ecx_777;
		edx_108 = SLICE(edx_ecx_777, word32, 32);
	}
	else
	{
		ecx_104 = dwArg08;
		edx_108 = dwArg0C;
	}
	Eq_4 esi_129;
	byte bl_181;
	Eq_4 edi_128;
	Eq_130042 (* ebp_130)[] = (char *) &dwArg04->t0014 + 4;
	if (dwArg04->b0004 != 0x00 || dwArg04->b0005 != 0x00)
	{
		Eq_4 esi_100 = (word32) dwArg04->t0014 + ((word32) dwArg04->t0010 + 3);
		if (esi_100 <= 0x44)
		{
			esi_129.u0 = 0x44;
			edi_128.u0 = 0x44;
			bl_181 = bl_47;
		}
		else
		{
			word32 edi_964;
			runtime.makeslice(gs, 0x080CF320, esi_100, esi_100, out edi_964);
			word32 ebx_134 = (word32) bl_47;
			edi_128 = dwLoc24;
			esi_129 = dwLoc28;
			ebp_130 = dwLoc2C;
			bl_181 = (byte) ebx_134;
		}
	}
	else
	{
		esi_129.u0 = 0x44;
		edi_128.u0 = 0x44;
		bl_181 = bl_47;
	}
	Eq_4 edi_163;
	Eq_4 edx_211 = edx_108;
	Eq_4 ecx_207 = ecx_104;
	if (dwArg04->b0005 != 0x00)
	{
		edi_163 = dwArg04->t0014;
		if (edi_163 == 0x00 && ((int8) (edx_108 == 0x00) & (int8) (ecx_104 == 0x00)) != 0x00)
		{
			byte cl_232 = dwArg04->b000A;
			dwArg04->b000A = 0x00;
			word128 xmm1_965;
			fmt.(*fmt).writePadding(gs, dwArg04, dwArg04->t0010, out xmm1_965);
			dwArg04->b000A = cl_232;
			return;
		}
	}
	else if (dwArg04->b000A != 0x00)
	{
		if (dwArg04->b0004 != 0x00)
		{
			edi_163 = dwArg04->t0010;
			if (bl_181 != 0x00 || (dwArg04->b0007 != 0x00 || dwArg04->b0009 != 0x00))
				--edi_163;
		}
		else
			edi_163.u0 = 0x00;
	}
	else
		edi_163.u0 = 0x00;
	Eq_4 esi_327;
	if (dwArg10 > 0x08)
	{
		if (dwArg10 == 0x0A)
		{
			esi_327 = esi_129;
			while (((int8) (edx_211 > 0x00) | (int8) (ecx_207 >= 0x0A) & (int8) (edx_211 == 0x00)) != 0x00)
			{
				runtime.uint64div(gs, ecx_207, edx_211, 0x0A, 0x00);
				Eq_129948 dl_423 = (byte) ecx_207 + 0x30 - (byte) dwLoc28 * 0x0A;
				if (esi_327 - 0x01 >= esi_129)
					runtime.panicindex(gs);
				Mem424[esi_327 - 0x01 + ebp_130:byte] = dl_423;
				ecx_207 = dwLoc28;
				edx_211 = dwLoc24;
				--esi_327;
			}
		}
		else
		{
			if (dwArg10 != 0x10)
				goto l080B5E4D;
			esi_327 = esi_129;
			while (((int8) (edx_211 == 0x00) & (int8) (ecx_207 >= 0x10) | (int8) (edx_211 > 0x00)) != 0x00)
			{
				Eq_4 ecx_323 = ecx_207 & 0x0F;
				if (ecx_323 >= dwArg1C)
				{
l080B5E3F:
					runtime.panicindex(gs);
				}
				Eq_4 edi_328 = esi_327 - 0x01;
				byte cl_333 = Mem320[ecx_323 + dwArg18:byte];
				if (edi_328 >= esi_129)
					goto l080B5E3F;
				Mem335[esi_327 - 0x01 + ebp_130:byte] = cl_333;
				ecx_207 = edx_211 << 0x1C | ecx_207 >> 0x04;
				edx_211 >>= 0x04;
				esi_327 = edi_328;
			}
		}
l080B59C1:
		if (edx_211 == 0x00 && ecx_207 < dwArg1C)
		{
			Eq_4 edx_557 = esi_327 - 0x01;
			byte cl_566 = Mem547[dwArg18 + ecx_207:byte];
			if (edx_557 < esi_129)
			{
				Mem570[esi_327 - 0x01 + ebp_130:byte] = cl_566;
				while (edx_557 > 0x00 && edi_163 > esi_129 - edx_557)
				{
					Eq_4 ebx_742 = edx_557 - (Eq_130042 (*)[]) 0x01;
					if (ebx_742 >= esi_129)
						runtime.panicindex(gs);
					Mem745[edx_557 - 0x01 + ebp_130:byte] = 0x30;
					edx_557 = ebx_742;
				}
				Eq_4 eax_597;
				bool v90_778;
				if (dwArg04->b0008 == 0x00)
				{
					v90_778 = bl_47 == 0x00;
					eax_597 = edx_557;
					goto l080B5A61;
				}
				if (dwArg10 != 0x08)
				{
					if (dwArg10 != 0x10)
					{
						v90_778 = bl_47 == 0x00;
						eax_597 = edx_557;
						goto l080B5A61;
					}
					if (dwArg1C > 0x10)
					{
						Eq_130042 bl_622 = dwArg18->t0010.t0000;
						if (edx_557 - (Eq_130042 (*)[]) 0x01 < esi_129)
						{
							Mem625[edx_557 - 0x01 + ebp_130:byte] = bl_622;
							eax_597 = edx_557 - (Eq_130042 (*)[]) 0x02;
							if (eax_597 >= esi_129)
								runtime.panicindex(gs);
							Mem629[edx_557 - 0x02 + ebp_130:byte] = 0x30;
							v90_778 = bl_47 == 0x00;
l080B5A61:
							Eq_4 edx_672;
							if (!v90_778)
							{
								edx_672 = eax_597 - (Eq_130042 (*)[]) 0x01;
								if (edx_672 >= esi_129)
									runtime.panicindex(gs);
								Mem687[eax_597 - 0x01 + ebp_130:byte] = 0x2D;
							}
							else if (dwArg04->b0007 != 0x00)
							{
								edx_672 = eax_597 - (Eq_130042 (*)[]) 0x01;
								if (edx_672 >= esi_129)
									runtime.panicindex(gs);
								Mem683[eax_597 - 0x01 + ebp_130:byte] = 0x2B;
							}
							else if (dwArg04->b0009 != 0x00)
							{
								edx_672 = eax_597 - (Eq_130042 (*)[]) 0x01;
								if (edx_672 >= esi_129)
									runtime.panicindex(gs);
								Mem679[eax_597 - 0x01 + ebp_130:byte] = 0x20;
							}
							else
								edx_672 = eax_597;
							byte al_697 = dwArg04->b000A;
							dwArg04->b000A = 0x00;
							if (edx_672 > esi_129)
								runtime.panicslice(gs);
							else
							{
								fmt.(*fmt).pad(gs, dwArg04, &(ebp_130 + (edx_672 - edi_128 >> 0x1F & edx_672))->t0000, esi_129 - edx_672);
								dwArg04->b000A = al_697;
								return;
							}
						}
					}
					runtime.panicindex(gs);
				}
				else
				{
					if (edx_557 >= esi_129)
						runtime.panicindex(gs);
					if (Mem585[ebp_130 + edx_557:byte] != 0x30)
					{
						eax_597 = edx_557 - (Eq_130042 (*)[]) 0x01;
						if (eax_597 >= esi_129)
							runtime.panicindex(gs);
						Mem648[edx_557 - 0x01 + ebp_130:byte] = 0x30;
						v90_778 = bl_47 == 0x00;
					}
					else
					{
						v90_778 = bl_47 == 0x00;
						eax_597 = edx_557;
					}
					goto l080B5A61;
				}
			}
		}
		runtime.panicindex(gs);
	}
	else
	{
		if (dwArg10 == 0x02)
		{
			esi_327 = esi_129;
			while (((int8) (edx_211 > 0x00) | (int8) (ecx_207 >= 0x02) & (int8) (edx_211 == 0x00)) != 0x00)
			{
				byte cl_754 = ((byte) ecx_207 & 0x01) + 0x30;
				Eq_4 edi_751 = esi_327 - 0x01;
				if (edi_751 >= esi_129)
					runtime.panicindex(gs);
				ebp_130[esi_327 - 0x01].t0000.u0 = cl_754;
				ecx_207 = edx_211 << 0x1F | ecx_207 >> 0x01;
				edx_211 >>= 0x01;
				esi_327 = edi_751;
			}
			goto l080B59C1;
		}
		if (dwArg10 == 0x08)
		{
			esi_327 = esi_129;
			while (((int8) (edx_211 > 0x00) | (int8) (edx_211 == 0x00) & (int8) (ecx_207 >= 0x08)) != 0x00)
			{
				Eq_129966 cl_494 = ((byte) ecx_207 & 0x07) + 0x30;
				Eq_4 edi_491 = esi_327 - 0x01;
				if (edi_491 >= esi_129)
					runtime.panicindex(gs);
				Mem496[esi_327 - 0x01 + ebp_130:byte] = cl_494;
				ecx_207 = edx_211 << 0x1D | ecx_207 >> 0x03;
				edx_211 >>= 0x03;
				esi_327 = edi_491;
			}
			goto l080B59C1;
		}
l080B5E4D:
		runtime.gopanic(gs);
	}
}

// 080B5E80: void fmt.(*fmt).truncate(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_128829) dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C)
// Called from:
//      fmt.(*fmt).fmt_s
//      fmt.(*fmt).fmt_q
void fmt.(*fmt).truncate(struct Eq_2 * gs, struct Eq_128829 * dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (dwArg04->b0005 != 0x00)
	{
		Eq_4 eax_24 = dwArg04->t0014;
		Eq_4 ecx_25 = 0x00;
		while (ecx_25 < dwArg0C)
		{
			Eq_4 ebp_64;
			if (CONVERT(Mem29[dwArg08 + ecx_25:byte], byte, word32) < 0x80)
				ebp_64 = (word32) ecx_25 + 1;
			else
			{
				runtime.decoderune(gs, dwArg08, dwArg0C, ecx_25);
				ebp_64 = dwLoc0C;
			}
			--eax_24;
			if (eax_24 < 0x00)
			{
				if (ecx_25 > dwArg0C)
					runtime.panicslice(gs);
				else
					return;
			}
			ecx_25 = ebp_64;
		}
	}
}

// 080B5F40: Register Eq_662 fmt.(*fmt).fmt_s(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_128829) dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C, Register out Eq_130259 xmm1Out)
// Called from:
//      fmt.(*pp).fmtString
//      fmt.(*pp).fmtBytes
//      fmt.(*pp).handleMethods
//      fmt.(*pp).printArg
Eq_662 fmt.(*fmt).fmt_s(struct Eq_2 * gs, struct Eq_128829 * dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C, union Eq_130259 & xmm1Out)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	fmt.(*fmt).truncate(gs, dwArg04, dwArg08, dwArg0C);
	Eq_130259 xmm1_50;
	Eq_662 xmm0_49 = fmt.(*fmt).padString(gs, dwArg04, dwLoc08, dwLoc04, out xmm1_50);
	xmm1Out = xmm1_50;
	return xmm0_49;
}

// 080B5FA0: void fmt.(*fmt).fmt_sbx(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_128829) dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C, Stack Eq_4 dwArg10, Stack Eq_4 dwArg14, Stack (ptr32 Eq_130288) dwArg1C, Stack Eq_130289 dwArg20)
// Called from:
//      fmt.(*fmt).fmt_sx
//      fmt.(*fmt).fmt_bx
void fmt.(*fmt).fmt_sbx(struct Eq_2 * gs, struct Eq_128829 * dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C, Eq_4 dwArg10, Eq_4 dwArg14, struct Eq_130288 * dwArg1C, Eq_130289 dwArg20)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 ecx_21;
	if (dwArg10 != 0x00)
		ecx_21 = dwArg14;
	else
		ecx_21 = dwArg0C;
	Eq_4 ebx_31;
	if (dwArg04->b0005 != 0x00)
	{
		ebx_31 = dwArg04->t0014;
		if (ebx_31 < ecx_21)
		{
l080B5FE4:
			Eq_4 ebx_107 = ebx_31 << 0x01;
			if (ebx_107 <= 0x00)
			{
				if (dwArg04->b0004 != 0x00)
				{
					word128 xmm1_1154;
					fmt.(*fmt).writePadding(gs, dwArg04, dwArg04->t0010, out xmm1_1154);
				}
				return;
			}
			else
			{
				Eq_4 ecx_113;
				if (dwArg04->b0009 != 0x00)
				{
					Eq_4 ecx_127;
					if (dwArg04->b0008 != 0x00)
						ecx_127 = ebx_31 << 0x02;
					else
						ecx_127 = ebx_107;
					ecx_113 = (word32) ebx_31 + (ecx_127 - 0x01);
				}
				else
				{
					if (dwArg04->b0008 != 0x00)
						ebx_107 = (word32) ebx_107 + 2;
					ecx_113 = ebx_107;
				}
				if (dwArg04->b0004 != 0x00)
				{
					Eq_4 ebp_158 = dwArg04->t0010;
					if (ebp_158 > ecx_113 && dwArg04->b0006 == 0x00)
					{
						word128 xmm1_1150;
						fmt.(*fmt).writePadding(gs, dwArg04, ebp_158 - ecx_113, out xmm1_1150);
					}
				}
				Eq_4 ecx_214;
				Eq_4 ebp_205 = dwArg04->t0000;
				Eq_4 esi_206 = *((word32) ebp_205 + 8);
				Eq_4 edi_207 = *((word32) ebp_205 + 4);
				Eq_4 ebp_208 = *ebp_205;
				if (dwArg04->b0008 != 0x00)
				{
					if (dwArg20 <= 0x10)
						runtime.panicindex(gs);
					ecx_214 = (word32) edi_207 + 2;
					byte al_225 = dwArg1C->b0010;
					if ((word32) edi_207 + 2 > esi_206)
					{
						word32 esi_1151;
						word128 xmm1_1153;
						word128 xmm0_1152;
						runtime.growslice(gs, 0x080CF320, ebp_208, edi_207, esi_206, (word32) edi_207 + 2, out esi_1151, out xmm0_1152, out xmm1_1153);
						ebp_208 = dwLoc28;
						esi_206 = dwLoc20;
						ecx_214 = dwLoc24 + 0x02;
					}
					Mem264[ebp_208 + edi_207:byte] = 0x30;
					*((word32) edi_207 + ((word32) ebp_208 + 1)) = al_225;
				}
				else
					ecx_214 = edi_207;
				Eq_4 eax_268 = 0x00;
				while (eax_268 < ebx_31)
				{
					Eq_4 edx_361;
					if (dwArg04->b0009 != 0x00)
					{
						if (eax_268 > 0x00)
						{
							Eq_4 edi_370 = (word32) ecx_214 + 1;
							if (edi_370 > esi_206)
							{
								word32 esi_1155;
								word128 xmm1_1157;
								word128 xmm0_1156;
								runtime.growslice(gs, 0x080CF320, ebp_208, ecx_214, esi_206, edi_370, out esi_1155, out xmm0_1156, out xmm1_1157);
								ebp_208 = dwLoc28;
								esi_206 = dwLoc20;
								edi_370 = dwLoc24 + 0x01;
							}
							Mem410[ebp_208 + ecx_214:byte] = 0x20;
							if (dwArg04->b0008 != 0x00)
							{
								if (dwArg20 <= 0x10)
									runtime.panicindex(gs);
								edx_361 = (word32) edi_370 + 2;
								byte bl_434 = dwArg1C->b0010;
								if (edx_361 > esi_206)
								{
									word128 xmm0_1159;
									word128 xmm1_1160;
									word32 esi_1158;
									runtime.growslice(gs, 0x080CF320, ebp_208, edi_370, esi_206, edx_361, out esi_1158, out xmm0_1159, out xmm1_1160);
									ebp_208 = dwLoc28;
									esi_206 = dwLoc20;
									edx_361 = dwLoc24 + 0x02;
								}
								Mem477[ebp_208 + edi_370:byte] = 0x30;
								*((word32) edi_370 + ((word32) ebp_208 + 1)) = bl_434;
							}
							else
								edx_361 = edi_370;
						}
						else
							edx_361 = ecx_214;
					}
					else
						edx_361 = ecx_214;
					word32 edi_500;
					if (dwArg10 != 0x00)
					{
						if (eax_268 >= dwArg14)
							runtime.panicindex(gs);
						edi_500 = CONVERT(Mem490[dwArg10 + eax_268:byte], byte, word32);
					}
					else
					{
						if (eax_268 >= dwArg0C)
							runtime.panicindex(gs);
						edi_500 = CONVERT(Mem490[dwArg08 + eax_268:byte], byte, word32);
					}
					byte al_513 = (byte) edi_500;
					Eq_130289 eax_533 = (word32) ((byte) edi_500 >> 0x04);
					if (eax_533 >= dwArg20)
					{
l080B63A8:
						runtime.panicindex(gs);
					}
					word32 edi_541 = CONVERT(Mem515[dwArg1C + eax_533:byte], byte, word32);
					ui32 eax_542 = (word32) al_513;
					if ((eax_542 & 0x0F) >= dwArg20)
						goto l080B63A8;
					Eq_4 ebx_551 = (word32) edx_361 + 2;
					word32 eax_552 = (word32) dwArg1C[(eax_542 & 0x0F) / 0x0011];
					if (ebx_551 > esi_206)
					{
						word128 xmm1_1163;
						word128 xmm0_1162;
						word32 esi_1161;
						runtime.growslice(gs, 0x080CF320, ebp_208, edx_361, esi_206, ebx_551, out esi_1161, out xmm0_1162, out xmm1_1163);
						ebp_208 = dwLoc28;
						esi_206 = dwLoc20;
						ebx_551 = dwLoc24 + 0x02;
						eax_552 = (word32) (byte) eax_552;
						edi_541 = (word32) (byte) edi_541;
					}
					Mem613[ebp_208 + edx_361:byte] = SLICE(edi_541, byte, 0);
					*((word32) edx_361 + ((word32) ebp_208 + 1)) = (byte) eax_552;
					eax_268 = (word32) eax_268 + 1;
					ecx_214 = ebx_551;
				}
				Eq_4 eax_277 = dwArg04->t0000;
				*((word32) eax_277 + 4) = ecx_214;
				*((word32) eax_277 + 8) = esi_206;
				if (g_t81576F0 == 0x00)
					*eax_277 = ebp_208;
				else
					runtime.writebarrierptr(eax_277, ebp_208);
				if (dwArg04->b0004 != 0x00)
				{
					Eq_4 eax_307 = dwArg04->t0010;
					if (eax_307 > ecx_113 && dwArg04->b0006 != 0x00)
					{
						word128 xmm1_1164;
						fmt.(*fmt).writePadding(gs, dwArg04, eax_307 - ecx_113, out xmm1_1164);
					}
				}
				return;
			}
		}
	}
	ebx_31 = ecx_21;
	goto l080B5FE4;
}

// 080B63E0: void fmt.(*fmt).fmt_sx(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_128829) dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C, Stack (ptr32 Eq_130288) dwArg10, Stack Eq_130289 dwArg14)
// Called from:
//      fmt.(*pp).fmtString
void fmt.(*fmt).fmt_sx(struct Eq_2 * gs, struct Eq_128829 * dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C, struct Eq_130288 * dwArg10, Eq_130289 dwArg14)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	fmt.(*fmt).fmt_sbx(gs, dwArg04, dwArg08, dwArg0C, 0x00, 0x00, dwArg10, dwArg14);
}

// 080B6450: void fmt.(*fmt).fmt_bx(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_128829) dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C, Stack (ptr32 Eq_130288) dwArg14, Stack Eq_130289 dwArg18)
// Called from:
//      fmt.(*pp).fmtBytes
void fmt.(*fmt).fmt_bx(struct Eq_2 * gs, struct Eq_128829 * dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C, struct Eq_130288 * dwArg14, Eq_130289 dwArg18)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	fmt.(*fmt).fmt_sbx(gs, dwArg04, 0x00, 0x00, dwArg08, dwArg0C, dwArg14, dwArg18);
}

// 080B64C0: void fmt.(*fmt).fmt_q(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_128829) dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C)
// Called from:
//      fmt.(*pp).fmtString
//      fmt.(*pp).fmtBytes
void fmt.(*fmt).fmt_q(struct Eq_2 * gs, struct Eq_128829 * dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	fmt.(*fmt).truncate(gs, dwArg04, dwArg08, dwArg0C);
	byte bLoc3C_276 = (byte) dwArg0C;
	if (dwArg04->b0008 != 0x00)
	{
		strconv.CanBackquote(gs, dwLoc38, dwLoc34);
		if (bLoc3C_276 != 0x00)
		{
			runtime.concatstring3(gs, fp - 0x20);
			word128 xmm1_365;
			fmt.(*fmt).padString(gs, dwArg04, dwLoc28, dwLoc24, out xmm1_365);
			return;
		}
	}
	if (dwArg04->b0007 != 0x00)
	{
		strconv.AppendQuoteToASCII(gs, (char *) &dwArg04->t0014 + 4, 0x00, 0x44, dwLoc38, dwLoc34);
		fmt.(*fmt).pad(gs, dwArg04, dwLoc30, dwLoc2C);
	}
	else
	{
		strconv.AppendQuote(gs, (char *) &dwArg04->t0014 + 4, 0x00, 0x44, dwLoc38, dwLoc34);
		fmt.(*fmt).pad(gs, dwArg04, dwLoc30, dwLoc2C);
	}
}

// 080B6640: void fmt.(*fmt).fmt_c(Register ui24 ebx_24_8, Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_128829) dwArg04, Stack Eq_4 dwArg08, Stack uint32 dwArg0C)
// Called from:
//      fmt.(*pp).fmtInteger
void fmt.(*fmt).fmt_c(ui24 ebx_24_8, struct Eq_2 * gs, struct Eq_128829 * dwArg04, Eq_4 dwArg08, uint32 dwArg0C)
{
	while (true)
	{
		Eq_4 ecx_7 = gs->ptr0000->tFFFFFFFC;
		if (fp > *((word32) ecx_7 + 8))
			break;
		runtime.morestack_noctxt();
	}
	if (((int8) (dwArg0C > 0x00) | (int8) (dwArg0C == 0x00) & (int8) (dwArg08 > 1114111)) != 0x00)
		dwArg08.u0 = 0xFFFD;
	unicode/utf8.EncodeRune(gs, (char *) &dwArg04->t0014 + 4, 0x04, dwArg08);
	if (dwLoc08 > 0x44)
		runtime.panicslice(gs);
	else
		fmt.(*fmt).pad(gs, dwArg04, (char *) &dwArg04->t0014 + 4, dwLoc08);
}

// 080B66F0: void fmt.(*fmt).fmt_qc(Register word24 ebx_24_8, Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_128829) dwArg04, Stack Eq_4 dwArg08, Stack uint32 dwArg0C)
// Called from:
//      fmt.(*pp).fmtInteger
void fmt.(*fmt).fmt_qc(word24 ebx_24_8, struct Eq_2 * gs, struct Eq_128829 * dwArg04, Eq_4 dwArg08, uint32 dwArg0C)
{
	while (true)
	{
		Eq_4 ecx_7 = gs->ptr0000->tFFFFFFFC;
		if (fp > *((word32) ecx_7 + 8))
			break;
		runtime.morestack_noctxt();
	}
	if (((int8) (dwArg0C > 0x00) | (int8) (dwArg0C == 0x00) & (int8) (dwArg08 > 1114111)) != 0x00)
		dwArg08.u0 = 0xFFFD;
	if (dwArg04->b0007 != 0x00)
	{
		strconv.AppendQuoteRuneToASCII(gs, (char *) &dwArg04->t0014 + 4, 0x00, 0x44, dwArg08);
		fmt.(*fmt).pad(gs, dwArg04, dwLoc0C, dwLoc08);
	}
	else
	{
		strconv.AppendQuoteRune(gs, (char *) &dwArg04->t0014 + 4, 0x00, 0x44, dwArg08);
		fmt.(*fmt).pad(gs, dwArg04, dwLoc0C, dwLoc08);
	}
}

// 080B67E0: void fmt.(*fmt).fmt_float(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_128829) dwArg04, Stack real64 rArg08, Stack Eq_4 dwArg10, Stack Eq_4 dwArg14, Stack Eq_4 dwArg18)
// Called from:
//      fmt.(*pp).fmtFloat
void fmt.(*fmt).fmt_float(struct Eq_2 * gs, struct Eq_128829 * dwArg04, real64 rArg08, Eq_4 dwArg10, Eq_4 dwArg14, Eq_4 dwArg18)
{
	while (fp - 0x14 <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 ecx_24;
	if (dwArg04->b0005 != 0x00)
		ecx_24 = dwArg04->t0014;
	else
		ecx_24 = dwArg18;
	byte dl_40 = (byte) dwArg14;
	strconv.AppendFloat(gs, (char *) &dwArg04->t0014 + 4, 0x01, 0x44, (real64) (uint128) rArg08, dl_40, dwArg10);
	Eq_4 eax_140 = dwLoc6C;
	Eq_4 ecx_172 = dwLoc70;
	Eq_4 dwLoc80_1119 = SEQ(nLoc7F, dl_40);
	if (dwLoc70 <= 0x01)
		runtime.panicindex(gs);
	else
	{
		Eq_93392 bl_72 = *((word32) dwLoc74 + 1);
		Eq_4 ebp_101 = (word32) dwLoc74 + 1;
		if (bl_72 == 0x2D || bl_72 == 0x2B)
		{
			ecx_172 = dwLoc70 - 0x01;
			eax_140 = dwLoc6C - 0x01;
		}
		else
		{
			*dwLoc74 = 0x2B;
			ebp_101 = dwLoc74;
		}
		if (dwArg04->b0009 != 0x00)
		{
			if (ecx_172 <= 0x00)
				runtime.panicindex(gs);
			if (*ebp_101 == 0x2B && dwArg04->b0007 == 0x00)
				*ebp_101 = 0x20;
		}
		if (ecx_172 <= 0x01)
			runtime.panicindex(gs);
		else
		{
			Eq_93392 bl_121 = *((word32) ebp_101 + 1);
			Eq_4 esi_120 = (word32) ebp_101 + 1;
			if (bl_121 == 0x49 || bl_121 == 0x4E)
			{
				byte bl_130 = dwArg04->b000A;
				dwArg04->b000A = 0x00;
				if (*((word32) ebp_101 + 1) == 0x4E && (dwArg04->b0009 == 0x00 && dwArg04->b0007 == 0x00))
				{
					--ecx_172;
					ebp_101 = esi_120;
				}
				fmt.(*fmt).pad(gs, dwArg04, ebp_101, ecx_172);
				dwArg04->b000A = bl_130;
			}
			else
			{
				Eq_4 ecx_221;
				Eq_4 edx_220;
				Eq_4 eax_222;
				if (dwArg04->b0008 != 0x00)
				{
					if (dwArg14 != 0x62)
					{
						Eq_4 ebx_235;
						if (dwArg14 == 0x47 || (dwArg14 == 0x67 || dwArg14 == 118))
						{
							ebx_235 = ecx_24;
							if (ecx_24 == ~0x00)
								ebx_235.u0 = 0x06;
						}
						else
							ebx_235.u0 = 0x00;
						Eq_4 esi_253 = 0x01;
						word32 edi_254 = 0x00;
						Eq_4 dwLoc64_1056 = 0x00;
						Eq_4 dwLoc20_1058 = fp - 0x3D;
						Eq_4 dwLoc60_1060 = 0x05;
						Eq_4 eax_270 = eax_140;
						Eq_4 ecx_271 = ecx_172;
						ebp_298 = ebp_101;
						while (true)
						{
							Eq_4 ebp_298;
							if (esi_253 >= ecx_271)
								break;
							if (esi_253 >= ecx_271)
								runtime.panicindex(gs);
							word32 edx_969;
							Eq_4 edi_966;
							byte dl_847 = Mem275[ebp_298 + esi_253:byte];
							if (dl_847 == 0x2E)
							{
								edx_969 = 0x01;
								edi_966 = dwLoc20_1058;
							}
							else if (dl_847 != 0x45 && dl_847 != 101)
							{
								--ebx_235;
								edx_969 = edi_254;
								edi_966 = dwLoc20_1058;
							}
							else
							{
								Eq_4 ecx_868 = ecx_271 - esi_253;
								byte al_862 = (byte) edi_254;
								word32 ebx_870 = ecx_868 + dwLoc64_1056;
								Eq_4 eax_877 = (word32) ebp_298 + (esi_253 - eax_270 >> 0x1F & esi_253);
								Eq_4 ebp_878 = dwLoc60_1060;
								if (ebx_870 > dwLoc60_1060)
								{
									word128 xmm1_1320;
									word128 xmm0_1319;
									word32 esi_1318;
									runtime.growslice(gs, 0x080CF320, dwLoc20_1058, dwLoc64_1056, dwLoc60_1060, ebx_870, out esi_1318, out xmm0_1319, out xmm1_1320);
									ebp_878 = dwArg10;
									dwLoc20_1058 = dwLoc80_1119;
								}
								if (ebx_870 > ebp_878)
									runtime.panicslice(gs);
								word128 xmm2_1326;
								word128 xmm1_1325;
								word128 xmm0_1324;
								word32 edi_1323;
								word32 esi_1322;
								word32 ebp_1321;
								runtime.memmove(dwLoc64_1056 + dwLoc20_1058, eax_877, ecx_868, out ebp_1321, out esi_1322, out edi_1323, out xmm0_1324, out xmm1_1325, out xmm2_1326);
								dwLoc60_1060 = ebp_878;
								if (esi_253 > eax_140)
									runtime.panicslice(gs);
								eax_270 = eax_140;
								ebp_298 = ebp_101;
								ecx_271 = esi_253;
								edi_966 = dwLoc20_1058;
								dwLoc64_1056 = ebx_870;
								edx_969 = (word32) al_862;
							}
							esi_253 = (word32) esi_253 + 1;
							dwLoc20_1058 = edi_966;
							edi_254 = edx_969;
						}
						Eq_4 eax_290 = eax_270;
						if ((byte) edi_254 == 0x00)
						{
							Eq_4 esi_292 = (word32) ecx_271 + 1;
							if (esi_292 > eax_270)
							{
								word128 xmm1_1329;
								word32 esi_1327;
								word128 xmm0_1328;
								runtime.growslice(gs, 0x080CF320, ebp_298, ecx_271, eax_270, esi_292, out esi_1327, out xmm0_1328, out xmm1_1329);
								ebp_298 = dwLoc80_1119;
								esi_292 = (word32) ecx_24 + 1;
								eax_290 = dwArg10;
							}
							Mem334[ebp_298 + ecx_271:byte] = 0x2E;
							ecx_271 = esi_292;
						}
						for (; ebx_235 > 0x00; --ebx_235)
						{
							Eq_4 esi_799 = (word32) ecx_271 + 1;
							if (esi_799 > eax_290)
							{
								word128 xmm0_1331;
								word128 xmm1_1332;
								word32 esi_1330;
								runtime.growslice(gs, 0x080CF320, ebp_298, ecx_271, eax_290, esi_799, out esi_1330, out xmm0_1331, out xmm1_1332);
								ebp_298 = dwLoc80_1119;
								esi_799 = (word32) ecx_24 + 1;
								eax_290 = dwArg10;
							}
							Mem839[ebp_298 + ecx_271:byte] = 0x30;
							ecx_271 = esi_799;
						}
						word32 esi_344 = dwLoc64_1056 + ecx_271;
						if (esi_344 > eax_290)
						{
							word128 xmm1_1335;
							word32 esi_1333;
							word128 xmm0_1334;
							runtime.growslice(gs, 0x080CF320, ebp_298, ecx_271, eax_290, esi_344, out esi_1333, out xmm0_1334, out xmm1_1335);
							ebp_298 = dwLoc80_1119;
							eax_290 = dwArg10;
						}
						if (esi_344 > eax_290)
							runtime.panicslice(gs);
						word128 xmm2_1341;
						word128 xmm1_1340;
						word32 edi_1338;
						word128 xmm0_1339;
						word32 ebp_1336;
						word32 esi_1337;
						runtime.memmove(ebp_298 + ecx_271, dwLoc20_1058, dwLoc64_1056, out ebp_1336, out esi_1337, out edi_1338, out xmm0_1339, out xmm1_1340, out xmm2_1341);
						eax_222 = ebp_298;
						ecx_221 = eax_290;
						edx_220 = esi_344;
					}
					else
					{
						edx_220 = ecx_172;
						ecx_221 = eax_140;
						eax_222 = ebp_101;
					}
				}
				else
				{
					edx_220 = ecx_172;
					ecx_221 = eax_140;
					eax_222 = ebp_101;
				}
				if (dwArg04->b0007 == 0x00)
				{
					if (edx_220 <= 0x00)
						runtime.panicindex(gs);
					if (*eax_222 == 0x2B)
					{
						fmt.(*fmt).pad(gs, dwArg04, (word32) eax_222 + (0x01 - ecx_221 >> 0x1F & 0x01), edx_220 - 0x01);
						return;
					}
				}
				if (dwArg04->b000A == 0x00 || (dwArg04->b0004 == 0x00 || dwArg04->t0010 <= edx_220))
					fmt.(*fmt).pad(gs, dwArg04, eax_222, edx_220);
				else
				{
					Eq_4 ebp_554 = dwArg04->t0000;
					if (edx_220 <= 0x00)
						runtime.panicindex(gs);
					else
					{
						word32 esi_562 = (word32) *eax_222;
						Eq_4 edi_563 = *((word32) ebp_554 + 8);
						Eq_4 eax_564 = *((word32) ebp_554 + 4);
						Eq_4 ecx_565 = *ebp_554;
						if ((word32) eax_564 + 1 > edi_563)
						{
							word32 esi_1305;
							word128 xmm0_1306;
							word128 xmm1_1307;
							runtime.growslice(gs, 0x080CF320, ecx_565, eax_564, edi_563, (word32) eax_564 + 1, out esi_1305, out xmm0_1306, out xmm1_1307);
							*((word32) ebp_554 + 8) = dwArg10;
							byte al_573 = (byte) esi_562;
							if (g_t81576F0 == 0x00)
								*ebp_554 = dwLoc80_1119;
							else
								runtime.writebarrierptr(ebp_554, dwLoc80_1119);
							esi_562 = (word32) al_573;
							eax_564 = ecx_24;
							ecx_565 = dwLoc80_1119;
						}
						*((word32) ebp_554 + 4) = (word32) eax_564 + 1;
						Mem651[ecx_565 + eax_564:byte] = SLICE(esi_562, byte, 0);
						word128 xmm1_1308;
						fmt.(*fmt).writePadding(gs, dwArg04, dwArg04->t0010 - edx_220, out xmm1_1308);
						Eq_4 eax_685 = dwArg04->t0000;
						Eq_4 edx_694 = *((word32) eax_685 + 4);
						Eq_4 ecx_693 = (word32) eax_222 + (0x01 - ecx_221 >> 0x1F & 0x01);
						word32 ebp_696 = edx_220 - 0x01 + edx_694;
						Eq_4 esi_698 = *((word32) eax_685 + 8);
						Eq_4 edi_699 = *eax_685;
						if (ebp_696 > esi_698)
						{
							word128 xmm0_1310;
							word32 esi_1309;
							word128 xmm1_1311;
							runtime.growslice(gs, 0x080CF320, edi_699, edx_694, esi_698, ebp_696, out esi_1309, out xmm0_1310, out xmm1_1311);
							edi_699 = dwLoc80_1119;
							esi_698 = dwArg10;
						}
						if (ebp_696 > esi_698)
							runtime.panicslice(gs);
						else
						{
							word32 esi_1313;
							word128 xmm1_1316;
							word32 edi_1314;
							word128 xmm0_1315;
							word32 ebp_1312;
							word128 xmm2_1317;
							runtime.memmove(edi_699 + edx_694, ecx_693, edx_220 - 0x01, out ebp_1312, out esi_1313, out edi_1314, out xmm0_1315, out xmm1_1316, out xmm2_1317);
							*((word32) eax_685 + 4) = ebp_696;
							*((word32) eax_685 + 8) = esi_698;
							if (g_t81576F0 == 0x00)
								*eax_685 = edi_699;
							else
								runtime.writebarrierptr(eax_685, edi_699);
						}
					}
				}
			}
		}
	}
}

// 080B6F30: void fmt.(*buffer).WriteRune(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
// Called from:
//      fmt.(*pp).badVerb
//      fmt.(*pp).catchPanic
void fmt.(*buffer).WriteRune(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 eax_130 = dwArg08;
	if (dwArg08 < 0x80)
	{
		Eq_4 edx_21 = *dwArg04;
		Eq_4 ebx_22 = *((word32) dwArg04 + 8);
		Eq_4 ebp_23 = *((word32) dwArg04 + 4);
		if ((word32) ebp_23 + 1 > ebx_22)
		{
			word128 xmm1_392;
			word128 xmm0_391;
			word32 esi_390;
			runtime.growslice(gs, 0x080CF320, edx_21, ebp_23, ebx_22, (word32) ebp_23 + 1, out esi_390, out xmm0_391, out xmm1_392);
			*((word32) dwArg04 + 8) = dwLoc18;
			if (g_t81576F0 == 0x00)
				*dwArg04 = dwLoc20;
			else
				runtime.writebarrierptr(dwArg04, dwLoc20);
			ebp_23 = dwLoc1C;
			edx_21 = dwLoc20;
		}
		*((word32) dwArg04 + 4) = (word32) ebp_23 + 1;
		Mem95[edx_21 + ebp_23:byte] = SLICE(dwArg08, byte, 0);
	}
	else
	{
		Eq_4 ebx_101 = *((word32) dwArg04 + 4);
		Eq_4 edx_100 = *((word32) dwArg04 + 8);
		Eq_4 ebp_103 = *dwArg04;
		Eq_4 esi_104 = ebx_101;
		ebx_168 = ebx_101;
		while (true)
		{
			Eq_4 ebx_168;
			Eq_4 edi_106 = (word32) esi_104 + 4;
			if (edi_106 <= edx_100)
				break;
			Eq_4 edi_169 = (word32) ebx_168 + 1;
			if (edi_169 > edx_100)
			{
				word128 xmm1_389;
				word128 xmm0_388;
				word32 esi_387;
				runtime.growslice(gs, 0x080CF320, ebp_103, ebx_168, edx_100, edi_169, out esi_387, out xmm0_388, out xmm1_389);
				dwLoc24 = edi_169;
				ebp_103 = dwLoc20;
				edx_100 = dwLoc18;
				edi_169 = (word32) dwLoc1C + 1;
				eax_130 = dwArg08;
				esi_104 = ebx_101;
			}
			Mem209[ebp_103 + ebx_168:byte] = 0x00;
			ebx_168 = edi_169;
		}
		if (esi_104 > edi_106 || edi_106 > edx_100)
			runtime.panicslice(gs);
		else
		{
			unicode/utf8.EncodeRune(gs, (word32) ebp_103 + (esi_104 - edx_100 >> 0x1F & esi_104), 0x04, eax_130);
			word32 eax_141 = dwLoc24 + ebx_101;
			if (eax_141 > edx_100)
				runtime.panicslice(gs);
			else
			{
				*((word32) dwArg04 + 4) = eax_141;
				*((word32) dwArg04 + 8) = edx_100;
				if (g_t81576F0 == 0x00)
					*dwArg04 = ebp_103;
				else
					runtime.writebarrierptr(dwArg04, ebp_103);
			}
		}
	}
}

// 080B70F0: Register word128 fmt.newPrinter(Register (ptr32 Eq_2) gs, Register out Eq_131447 xmm1Out)
// Called from:
//      fmt.Fprintln
word128 fmt.newPrinter(struct Eq_2 * gs, union Eq_131447 & xmm1Out)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_131447 xmm1_29;
	word128 xmm0_28 = sync.(*Pool).Get(gs, 135538336, out xmm1_29);
	if (dwLoc0C != 0x080DC3E0)
		runtime.panicdottypeE(gs, dwLoc0C);
	else
	{
		((word32) dwLoc08 + 0x007E)->u2 = 0x00;
		if (g_t81576F0 == 0x00)
			*((word32) dwLoc08 + 32) = dwLoc08;
		else
			runtime.writebarrierptr((word32) dwLoc08 + 32, dwLoc08);
		((word32) dwLoc08 + 36)->u0 = 0x00;
		*((word32) dwLoc08 + 37) = 0x00;
		*((word32) dwLoc08 + 41) = 0x00;
		xmm1Out = xmm1_29;
		return xmm0_28;
	}
}

// 080B71A0: void fmt.(*pp).free(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04)
// Called from:
//      fmt.Fprintln
void fmt.(*pp).free(struct Eq_2 * gs, Eq_4 dwArg04)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	*((word32) dwArg04 + 4) = 0x00;
	((word32) dwArg04 + 0x0C)->u0 = 0x00;
	if (g_t81576F0 == 0x00)
		*((word32) dwArg04 + 16) = 0x00;
	else
		runtime.writebarrierptr((word32) dwArg04 + 16, 0x00);
	((word32) dwArg04 + 28)->u0 = 0x00;
	if (g_t81576F0 == 0x00)
	{
		((word32) dwArg04 + 20)->u0 = 0x00;
		((word32) dwArg04 + 24)->u0 = 0x00;
	}
	else
	{
		runtime.writebarrierptr((word32) dwArg04 + 20, 0x00);
		runtime.writebarrierptr((word32) dwArg04 + 24, 0x00);
	}
	sync.(*Pool).Put(gs, 135538336, 0x080DC3E0, dwArg04);
}

// 080B7280: void fmt.(*pp).Width(Register (ptr32 Eq_131564) gs)
void fmt.(*pp).Width(struct Eq_131564 * gs)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
}

// 080B72B0: void fmt.(*pp).Precision(Register (ptr32 Eq_131577) gs)
void fmt.(*pp).Precision(struct Eq_131577 * gs)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
}

// 080B72E0: void fmt.(*pp).Flag(Register (ptr32 Eq_131590) gs, Stack (ptr32 Eq_131591) dwArg04, Stack int32 dwArg08)
void fmt.(*pp).Flag(struct Eq_131590 * gs, struct Eq_131591 * dwArg04, int32 dwArg08)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	if (dwArg08 > 0x23)
	{
		if (dwArg08 != 0x2B)
		{
			if (dwArg08 == 0x2D)
				return;
			if (dwArg08 != 0x30)
				;
		}
		else
			dwArg04->b0027 == 0x00;
	}
	else
	{
		if (dwArg08 == 0x20)
			return;
		if (dwArg08 != 0x23)
			return;
		dwArg04->b0028 == 0x00;
	}
}

// 080B7390: void fmt.(*pp).Write(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C)
void fmt.(*pp).Write(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 ecx_18 = *((word32) dwArg04 + 4);
	word32 ebx_20 = ecx_18 + dwArg0C;
	Eq_4 ebp_22 = *((word32) dwArg04 + 8);
	Eq_4 esi_23 = *dwArg04;
	if (ebx_20 > ebp_22)
	{
		word128 xmm1_183;
		word128 xmm0_182;
		word32 esi_181;
		runtime.growslice(gs, 0x080CF320, esi_23, ecx_18, ebp_22, ebx_20, out esi_181, out xmm0_182, out xmm1_183);
		esi_23 = dwLoc18;
		ebp_22 = dwLoc10;
	}
	if (ebx_20 > ebp_22)
		runtime.panicslice(gs);
	else
	{
		word128 xmm2_189;
		word128 xmm1_188;
		word128 xmm0_187;
		word32 edi_186;
		word32 esi_185;
		word32 ebp_184;
		runtime.memmove(esi_23 + ecx_18, dwArg08, dwArg0C, out ebp_184, out esi_185, out edi_186, out xmm0_187, out xmm1_188, out xmm2_189);
		*((word32) dwArg04 + 4) = ebx_20;
		*((word32) dwArg04 + 8) = ebp_22;
		if (g_t81576F0 == 0x00)
			*dwArg04 = esi_23;
		else
			runtime.writebarrierptr(dwArg04, esi_23);
	}
}

// 080B7490: void fmt.Fprintln(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_131703) dwArg04, Stack Eq_4 dwArg08, Stack (ptr32 Eq_131705) dwArg0C, Stack int32 dwArg10, Stack word32 dwArg14)
// Called from:
//      fmt.Println
void fmt.Fprintln(struct Eq_2 * gs, struct Eq_131703 * dwArg04, Eq_4 dwArg08, struct Eq_131705 * dwArg0C, int32 dwArg10, word32 dwArg14)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_662 xmm1_27;
	fmt.(*pp).doPrintln(gs, fmt.newPrinter(gs, out xmm1_27), xmm1_27, dwLoc2C, dwArg0C, dwArg10);
	<anonymous> * eax_67 = dwArg04->ptr0014;
	eax_67();
	fmt.(*pp).free(gs, dwLoc2C);
}

// 080B7550: void fmt.Println(Register (ptr32 Eq_2) gs, Stack (ptr32 Eq_131705) dwArg04, Stack int32 dwArg08, Stack word32 dwArg0C)
// Called from:
//      main.main
void fmt.Println(struct Eq_2 * gs, struct Eq_131705 * dwArg04, int32 dwArg08, word32 dwArg0C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	fmt.Fprintln(gs, &g_t8136650, os.Stdout, dwArg04, dwArg08, dwArg0C);
}

// 080B75C0: void fmt.getField(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack ui32 dwArg0C, Stack Eq_4 dwArg10)
// Called from:
//      fmt.(*pp).printValue
void fmt.getField(struct Eq_2 * gs, Eq_4 dwArg04, ui32 dwArg0C, Eq_4 dwArg10)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	reflect.Value.Field(gs, dwArg04, dwArg0C, dwArg10);
	byte bLoc1C_128 = (byte) dwArg10;
	if ((dwLoc10 & 0x1F) == 0x14)
	{
		reflect.Value.IsNil(gs, dwLoc10);
		if (bLoc1C_128 == 0x00)
			reflect.Value.Elem(gs, dwLoc18, dwLoc14, dwLoc10);
	}
}

// 080B7690: void fmt.(*pp).unknownType(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C, Stack Eq_4 dwArg10)
// Called from:
//      fmt.(*pp).printValue
void fmt.(*pp).unknownType(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C, Eq_4 dwArg10)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (dwArg10 == 0x00)
	{
		Eq_4 ecx_22 = *((word32) dwArg04 + 4);
		Eq_4 ebx_25 = *dwArg04;
		Eq_4 ebp_26 = *((word32) dwArg04 + 8);
		if ((word32) ecx_22 + 5 > ebp_26)
		{
			word128 xmm1_609;
			word128 xmm0_608;
			word32 esi_607;
			runtime.growslice(gs, 0x080CF320, ebx_25, ecx_22, ebp_26, (word32) ecx_22 + 5, out esi_607, out xmm0_608, out xmm1_609);
			ebp_26 = dwLoc24;
			ebx_25 = dwLoc2C;
		}
		if ((word32) ecx_22 + 5 > ebp_26)
			runtime.panicslice(gs);
		else
		{
			word128 xmm2_615;
			word128 xmm1_614;
			word128 xmm0_613;
			word32 edi_612;
			word32 esi_611;
			word32 ebp_610;
			runtime.memmove(ebx_25 + ecx_22, 0x080E0FC5, 0x05, out ebp_610, out esi_611, out edi_612, out xmm0_613, out xmm1_614, out xmm2_615);
			*((word32) dwArg04 + 4) = (word32) ecx_22 + 5;
			*((word32) dwArg04 + 8) = ebp_26;
			if (g_t81576F0 == 0x00)
				*dwArg04 = ebx_25;
			else
				runtime.writebarrierptr(dwArg04, ebx_25);
		}
	}
	else
	{
		Eq_4 edx_122 = *((word32) dwArg04 + 8);
		Eq_4 ebx_123 = *dwArg04;
		Eq_4 ebp_124 = *((word32) dwArg04 + 4);
		if ((word32) ebp_124 + 1 > edx_122)
		{
			word128 xmm1_594;
			word128 xmm0_593;
			word32 esi_592;
			runtime.growslice(gs, 0x080CF320, ebx_123, ebp_124, edx_122, (word32) ebp_124 + 1, out esi_592, out xmm0_593, out xmm1_594);
			*((word32) dwArg04 + 8) = dwLoc24;
			dwLoc34 = edx_122;
			dwLoc30 = (word32) ebp_124 + 1;
			if (g_t81576F0 == 0x00)
				*dwArg04 = dwLoc2C;
			else
				runtime.writebarrierptr(dwArg04, dwLoc2C);
			ebp_124 = dwLoc28;
			ebx_123 = dwLoc2C;
		}
		*((word32) dwArg04 + 4) = (word32) ebp_124 + 1;
		Mem192[ebx_123 + ebp_124:byte] = 0x3F;
		reflect.Value.Type(gs, dwArg08, dwArg10);
		Eq_4 ecx_212 = *((word32) dwLoc34 + 0x0084);
		ecx_212();
		Eq_4 ebx_224 = *((word32) dwArg04 + 4);
		word32 ebp_225 = ebx_224 + dwArg10;
		Eq_4 esi_227 = *((word32) dwArg04 + 8);
		Eq_4 edi_228 = *dwArg04;
		if (ebp_225 > esi_227)
		{
			word128 xmm1_597;
			word128 xmm0_596;
			word32 esi_595;
			runtime.growslice(gs, 0x080CF320, edi_228, ebx_224, esi_227, ebp_225, out esi_595, out xmm0_596, out xmm1_597);
			esi_227 = dwLoc24;
			edi_228 = dwLoc2C;
		}
		if (ebp_225 > esi_227)
			runtime.panicslice(gs);
		else
		{
			word128 xmm2_603;
			word128 xmm1_602;
			word128 xmm0_601;
			word32 edi_600;
			word32 esi_599;
			word32 ebp_598;
			runtime.memmove(edi_228 + ebx_224, dwArg0C, dwArg10, out ebp_598, out esi_599, out edi_600, out xmm0_601, out xmm1_602, out xmm2_603);
			*((word32) dwArg04 + 4) = ebp_225;
			*((word32) dwArg04 + 8) = esi_227;
			if (g_t81576F0 == 0x00)
				*dwArg04 = edi_228;
			else
				runtime.writebarrierptr(dwArg04, edi_228);
			Eq_4 eax_337 = edi_228;
			Eq_4 edx_329 = *((word32) dwArg04 + 8);
			Eq_4 ebx_330 = *((word32) dwArg04 + 4);
			if ((word32) ebx_330 + 1 > edx_329)
			{
				word128 xmm1_606;
				word128 xmm0_605;
				word32 esi_604;
				runtime.growslice(gs, 0x080CF320, edi_228, ebx_330, edx_329, (word32) ebx_330 + 1, out esi_604, out xmm0_605, out xmm1_606);
				*((word32) dwArg04 + 8) = dwLoc24;
				if (g_t81576F0 == 0x00)
					*dwArg04 = dwLoc2C;
				else
					runtime.writebarrierptr(dwArg04, dwLoc2C);
				eax_337 = dwLoc2C;
				ebx_330 = dwLoc28;
			}
			*((word32) dwArg04 + 4) = (word32) ebx_330 + 1;
			Mem399[eax_337 + ebx_330:byte] = 0x3F;
		}
	}
}

// 080B79A0: void fmt.(*pp).badVerb(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
// Called from:
//      fmt.(*pp).fmtBool
//      fmt.(*pp).fmtInteger
//      fmt.(*pp).fmtFloat
//      fmt.(*pp).fmtComplex
//      fmt.(*pp).fmtString
//      fmt.(*pp).fmtPointer
//      fmt.(*pp).printArg
//      fmt.(*pp).printValue
void fmt.(*pp).badVerb(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	*((word32) dwArg04 + 0x007F) = 0x01;
	Eq_4 ecx_22 = *((word32) dwArg04 + 4);
	Eq_4 ebx_25 = *((word32) dwArg04 + 8);
	Eq_4 ebp_26 = *dwArg04;
	if ((word32) ecx_22 + 2 > ebx_25)
	{
		word128 xmm1_1180;
		word128 xmm0_1179;
		word32 esi_1178;
		runtime.growslice(gs, 0x080CF320, ebp_26, ecx_22, ebx_25, (word32) ecx_22 + 2, out esi_1178, out xmm0_1179, out xmm1_1180);
		dwLoc58 = ebx_25;
		dwLoc54 = (word32) ecx_22 + 2;
		ebx_25 = dwLoc48;
		ebp_26 = dwLoc50;
	}
	if ((word32) ecx_22 + 2 > ebx_25)
		runtime.panicslice(gs);
	else
	{
		word128 xmm0_1184;
		word128 xmm2_1186;
		word128 xmm1_1185;
		word32 edi_1183;
		word32 esi_1182;
		word32 ebp_1181;
		runtime.memmove(ebp_26 + ecx_22, 0x080E0DAD, 0x02, out ebp_1181, out esi_1182, out edi_1183, out xmm0_1184, out xmm1_1185, out xmm2_1186);
		*((word32) dwArg04 + 4) = (word32) ecx_22 + 2;
		*((word32) dwArg04 + 8) = ebx_25;
		Eq_4 dwLoc5C_866 = 0x02;
		if (g_t81576F0 == 0x00)
			*dwArg04 = ebp_26;
		else
			runtime.writebarrierptr(dwArg04, ebp_26);
		fmt.(*buffer).WriteRune(gs, dwArg04, dwArg08);
		Eq_4 dwLoc60_1002 = dwArg08;
		Eq_4 ecx_146 = *((word32) dwArg04 + 8);
		Eq_4 edx_147 = *((word32) dwArg04 + 4);
		Eq_4 ebx_148 = *dwArg04;
		if ((word32) edx_147 + 1 > ecx_146)
		{
			word128 xmm1_1189;
			word128 xmm0_1188;
			word32 esi_1187;
			runtime.growslice(gs, 0x080CF320, ebx_148, edx_147, ecx_146, (word32) edx_147 + 1, out esi_1187, out xmm0_1188, out xmm1_1189);
			*((word32) dwArg04 + 8) = dwLoc48;
			dwLoc60_1002 = ebx_148;
			dwLoc5C_866 = edx_147;
			dwLoc58 = ecx_146;
			dwLoc54 = (word32) edx_147 + 1;
			if (g_t81576F0 == 0x00)
				*dwArg04 = dwLoc50;
			else
			{
				runtime.writebarrierptr(dwArg04, dwLoc50);
				dwLoc60_1002 = dwLoc50;
			}
			edx_147 = dwLoc4C;
			ebx_148 = dwLoc50;
		}
		*((word32) dwArg04 + 4) = (word32) edx_147 + 1;
		Mem215[ebx_148 + edx_147:byte] = 0x28;
		Eq_4 edx_217 = *((word32) dwArg04 + 0x0C);
		if (edx_217 != 0x00)
		{
			struct Eq_132166 * edx_551;
			Eq_4 ecx_547 = edx_217;
			if (edx_217 != 0x00)
				edx_551 = &g_t8138A00;
			else
			{
				edx_551 = null;
				ecx_547.u0 = 0x00;
			}
			edx_551->ptr0084();
			Eq_4 ebx_570 = *((word32) dwArg04 + 4);
			word32 ebp_571 = dwLoc5C_866 + ebx_570;
			Eq_4 esi_573 = *((word32) dwArg04 + 8);
			Eq_4 edi_574 = *dwArg04;
			if (ebp_571 > esi_573)
			{
				word128 xmm0_1191;
				word32 esi_1190;
				word128 xmm1_1192;
				runtime.growslice(gs, 0x080CF320, edi_574, ebx_570, esi_573, ebp_571, out esi_1190, out xmm0_1191, out xmm1_1192);
				esi_573 = dwLoc48;
				edi_574 = dwLoc50;
			}
			if (ebp_571 > esi_573)
				runtime.panicslice(gs);
			word32 ebp_1193;
			word32 esi_1194;
			word32 edi_1195;
			word128 xmm0_1196;
			word128 xmm1_1197;
			word128 xmm2_1198;
			runtime.memmove(edi_574 + ebx_570, dwLoc60_1002, dwLoc5C_866, out ebp_1193, out esi_1194, out edi_1195, out xmm0_1196, out xmm1_1197, out xmm2_1198);
			*((word32) dwArg04 + 4) = ebp_571;
			*((word32) dwArg04 + 8) = esi_573;
			if (g_t81576F0 == 0x00)
				*dwArg04 = edi_574;
			else
				runtime.writebarrierptr(dwArg04, edi_574);
			Eq_4 eax_684 = edi_574;
			Eq_4 edx_676 = *((word32) dwArg04 + 4);
			Eq_4 ebx_677 = *((word32) dwArg04 + 8);
			if ((word32) edx_676 + 1 > ebx_677)
			{
				word32 esi_1199;
				word128 xmm0_1200;
				word128 xmm1_1201;
				runtime.growslice(gs, 0x080CF320, edi_574, edx_676, ebx_677, (word32) edx_676 + 1, out esi_1199, out xmm0_1200, out xmm1_1201);
				*((word32) dwArg04 + 8) = dwLoc48;
				if (g_t81576F0 == 0x00)
					*dwArg04 = dwLoc50;
				else
					runtime.writebarrierptr(dwArg04, dwLoc50);
				eax_684 = dwLoc50;
				edx_676 = dwLoc4C;
			}
			*((word32) dwArg04 + 4) = (word32) edx_676 + 1;
			Mem745[eax_684 + edx_676:byte] = 0x3D;
			word128 xmm1_1204;
			fmt.(*pp).printArg(gs, xmm0, xmm1, dwArg04, *((word32) dwArg04 + 0x0C), *((word32) dwArg04 + 16), 118, out xmm1_1204);
		}
		else
		{
			Eq_4 ecx_221 = *((word32) dwArg04 + 28);
			if (ecx_221 == 0x00)
			{
				Eq_4 ecx_448 = *((word32) dwArg04 + 4);
				Eq_4 ebx_451 = *((word32) dwArg04 + 8);
				Eq_4 ebp_452 = *dwArg04;
				if ((word32) ecx_448 + 5 > ebx_451)
				{
					word32 esi_1208;
					word128 xmm0_1209;
					word128 xmm1_1210;
					runtime.growslice(gs, 0x080CF320, ebp_452, ecx_448, ebx_451, (word32) ecx_448 + 5, out esi_1208, out xmm0_1209, out xmm1_1210);
					ebp_452 = dwLoc50;
					ebx_451 = dwLoc48;
				}
				if ((word32) ecx_448 + 5 > ebx_451)
					runtime.panicslice(gs);
				word32 ebp_1211;
				word32 esi_1212;
				word32 edi_1213;
				word128 xmm0_1214;
				word128 xmm1_1215;
				word128 xmm2_1216;
				runtime.memmove(ebp_452 + ecx_448, 0x080E0FC5, 0x05, out ebp_1211, out esi_1212, out edi_1213, out xmm0_1214, out xmm1_1215, out xmm2_1216);
				*((word32) dwArg04 + 4) = (word32) ecx_448 + 5;
				*((word32) dwArg04 + 8) = ebx_451;
				if (g_t81576F0 == 0x00)
					*dwArg04 = ebp_452;
				else
					runtime.writebarrierptr(dwArg04, ebp_452);
			}
			else
			{
				Eq_4 edx_225 = *((word32) dwArg04 + 24);
				reflect.Value.Type(gs, *((word32) dwArg04 + 20), ecx_221);
				Eq_4 ecx_243 = *((word32) dwLoc58 + 0x0084);
				ecx_243();
				Eq_4 ebx_254 = *((word32) dwArg04 + 4);
				word32 ebp_255 = ecx_221 + ebx_254;
				Eq_4 esi_257 = *dwArg04;
				Eq_4 edi_258 = *((word32) dwArg04 + 8);
				if (ebp_255 > edi_258)
				{
					word128 xmm0_1218;
					word32 esi_1217;
					word128 xmm1_1219;
					runtime.growslice(gs, 0x080CF320, esi_257, ebx_254, edi_258, ebp_255, out esi_1217, out xmm0_1218, out xmm1_1219);
					esi_257 = dwLoc50;
					edi_258 = dwLoc48;
				}
				if (ebp_255 > edi_258)
					runtime.panicslice(gs);
				word32 ebp_1220;
				word32 esi_1221;
				word32 edi_1222;
				word128 xmm0_1223;
				word128 xmm2_1225;
				word128 xmm1_1224;
				runtime.memmove(esi_257 + ebx_254, edx_225, ecx_221, out ebp_1220, out esi_1221, out edi_1222, out xmm0_1223, out xmm1_1224, out xmm2_1225);
				*((word32) dwArg04 + 4) = ebp_255;
				*((word32) dwArg04 + 8) = edi_258;
				if (g_t81576F0 == 0x00)
					*dwArg04 = esi_257;
				else
					runtime.writebarrierptr(dwArg04, esi_257);
				Eq_4 eax_367 = esi_257;
				Eq_4 edx_359 = *((word32) dwArg04 + 4);
				Eq_4 ebx_360 = *((word32) dwArg04 + 8);
				if ((word32) edx_359 + 1 > ebx_360)
				{
					word32 esi_1226;
					word128 xmm0_1227;
					word128 xmm1_1228;
					runtime.growslice(gs, 0x080CF320, esi_257, edx_359, ebx_360, (word32) edx_359 + 1, out esi_1226, out xmm0_1227, out xmm1_1228);
					*((word32) dwArg04 + 8) = dwLoc48;
					if (g_t81576F0 == 0x00)
						*dwArg04 = dwLoc50;
					else
						runtime.writebarrierptr(dwArg04, dwLoc50);
					eax_367 = dwLoc50;
					edx_359 = dwLoc4C;
				}
				*((word32) dwArg04 + 4) = (word32) edx_359 + 1;
				Mem428[eax_367 + edx_359:byte] = 0x3D;
				fmt.(*pp).printValue(gs, dwArg04, *((word32) dwArg04 + 20), *((word32) dwArg04 + 24), *((word32) dwArg04 + 28), 118, 0x00);
				dwLoc50.u0 = 0x00;
			}
		}
		Eq_4 ecx_765 = *((word32) dwArg04 + 8);
		Eq_4 edx_766 = *((word32) dwArg04 + 4);
		Eq_4 ebx_767 = *dwArg04;
		if ((word32) edx_766 + 1 > ecx_765)
		{
			word128 xmm0_1206;
			word32 esi_1205;
			word128 xmm1_1207;
			runtime.growslice(gs, 0x080CF320, ebx_767, edx_766, ecx_765, (word32) edx_766 + 1, out esi_1205, out xmm0_1206, out xmm1_1207);
			*((word32) dwArg04 + 8) = dwLoc48;
			if (g_t81576F0 == 0x00)
				*dwArg04 = dwLoc50;
			else
				runtime.writebarrierptr(dwArg04, dwLoc50);
			edx_766 = dwLoc4C;
			ebx_767 = dwLoc50;
		}
		*((word32) dwArg04 + 4) = (word32) edx_766 + 1;
		Mem839[ebx_767 + edx_766:byte] = 0x29;
		*((word32) dwArg04 + 0x007F) = 0x00;
	}
}

// 080B8000: void fmt.(*pp).fmtBool(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack byte bArg08, Stack Eq_4 dwArg0C)
// Called from:
//      fmt.(*pp).printArg
//      fmt.(*pp).printValue
void fmt.(*pp).fmtBool(struct Eq_2 * gs, Eq_4 dwArg04, byte bArg08, Eq_4 dwArg0C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (dwArg0C == 116 || dwArg0C == 118)
		fmt.(*fmt).fmt_boolean(gs, (word32) dwArg04 + 32, bArg08);
	else
		fmt.(*pp).badVerb(gs, dwArg04, dwArg0C);
}

// 080B8060: void fmt.(*pp).fmt0x64(Register ui24 ebx_24_8, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 qwArg08, Stack Eq_4 bArg10)
// Called from:
//      fmt.(*pp).fmtInteger
//      fmt.(*pp).fmtBytes
//      fmt.(*pp).fmtPointer
void fmt.(*pp).fmt0x64(ui24 ebx_24_8, struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 qwArg08, Eq_4 bArg10)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 cl_20 = *((word32) dwArg04 + 40);
	*((word32) dwArg04 + 40) = bArg10;
	fmt.(*fmt).fmt_integer(ebx_24_8, gs, (word32) dwArg04 + 32, qwArg08, 0x10, 0x00, &g_t80E26EC, 0x11);
	*((word32) dwArg04 + 40) = cl_20;
}

// 080B80E0: void fmt.(*pp).fmtInteger(Register word24 edx_24_8, Register Eq_4 ebx, Register word32 ebp, Register word32 edi, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 qwArg08, Stack byte bArg10, Stack Eq_4 dwArg14)
// Called from:
//      fmt.(*pp).fmtPointer
//      fmt.(*pp).printArg
//      fmt.(*pp).printValue
void fmt.(*pp).fmtInteger(word24 edx_24_8, Eq_4 ebx, word32 ebp, word32 edi, struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 qwArg08, byte bArg10, Eq_4 dwArg14)
{
	ui24 ebx_24_8 = SLICE(ebx, word24, 8);
	Eq_4 dwArg08 = (word32) qwArg08;
	uint32 dwArg0C = SLICE(qwArg08, word32, 32);
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (dwArg14 <= 99)
	{
		if (dwArg14 <= 88)
		{
			if (dwArg14 == 0x55)
			{
				fmt.(*fmt).fmt_unicode(edi, gs, (word32) dwArg04 + 32, dwArg08, dwArg0C);
				return;
			}
			if (dwArg14 == 88)
			{
				fmt.(*fmt).fmt_integer(ebx_24_8, gs, (word32) dwArg04 + 32, qwArg08, 0x10, bArg10, &g_t80E26DB, 0x11);
				return;
			}
		}
		else
		{
			if (dwArg14 == 0x62)
			{
				fmt.(*fmt).fmt_integer(ebx_24_8, gs, (word32) dwArg04 + 32, qwArg08, 0x02, bArg10, &g_t80E26EC, 0x11);
				return;
			}
			if (dwArg14 == 99)
			{
				fmt.(*fmt).fmt_c(ebx_24_8, gs, (word32) dwArg04 + 32, dwArg08, dwArg0C);
				return;
			}
		}
	}
	else if (dwArg14 <= 111)
	{
		if (dwArg14 == 100)
		{
			fmt.(*fmt).fmt_integer(ebx_24_8, gs, (word32) dwArg04 + 32, qwArg08, 0x0A, bArg10, &g_t80E26EC, 0x11);
			return;
		}
		if (dwArg14 == 111)
		{
			fmt.(*fmt).fmt_integer(ebx_24_8, gs, (word32) dwArg04 + 32, qwArg08, 0x08, bArg10, &g_t80E26EC, 0x11);
			return;
		}
	}
	else
	{
		if (dwArg14 == 113)
		{
			word24 ebx_24_8_177 = SLICE(dwArg0C, word24, 8);
			if (((int8) Test(ULT,false) | (int8) (dwArg0C == 0x00) & (int8) (dwArg08 <= 1114111)) != 0x00)
				fmt.(*fmt).fmt_qc(ebx_24_8_177, gs, (word32) dwArg04 + 32, dwArg08, dwArg0C);
			else
				fmt.(*pp).badVerb(gs, dwArg04, dwArg14);
			return;
		}
		if (dwArg14 == 118)
		{
			if (*((word32) dwArg04 + 44) != 0x00 && bArg10 == 0x00)
				fmt.(*pp).fmt0x64(ebx_24_8, gs, dwArg04, qwArg08, 0x01);
			else
				fmt.(*fmt).fmt_integer(ebx_24_8, gs, (word32) dwArg04 + 32, qwArg08, 0x0A, bArg10, &g_t80E26EC, 0x11);
			return;
		}
		if (dwArg14 == 0x78)
		{
			fmt.(*fmt).fmt_integer(ebx_24_8, gs, (word32) dwArg04 + 32, qwArg08, 0x10, bArg10, &g_t80E26EC, 0x11);
			return;
		}
	}
	fmt.(*pp).badVerb(gs, dwArg04, dwArg14);
}

// 080B8400: void fmt.(*pp).fmtFloat(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack real64 rArg08, Stack Eq_4 dwArg10, Stack Eq_4 dwArg14)
// Called from:
//      fmt.(*pp).fmtComplex
//      fmt.(*pp).printArg
//      fmt.(*pp).printValue
void fmt.(*pp).fmtFloat(struct Eq_2 * gs, Eq_4 dwArg04, real64 rArg08, Eq_4 dwArg10, Eq_4 dwArg14)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (dwArg14 <= 0x47)
	{
		if (dwArg14 == 0x45)
			goto l080B842B;
		if (dwArg14 == 0x46)
		{
			fmt.(*fmt).fmt_float(gs, (word32) dwArg04 + 32, (real64) (uint128) rArg08, dwArg10, 0x66, 0x06);
			return;
		}
		if (dwArg14 == 0x47)
		{
l080B846A:
			fmt.(*fmt).fmt_float(gs, (word32) dwArg04 + 32, (real64) (uint128) rArg08, dwArg10, dwArg14, ~0x00);
			return;
		}
	}
	else if (dwArg14 <= 0x66)
	{
		if (dwArg14 == 0x62)
			goto l080B846A;
		if (dwArg14 <= 0x66)
		{
l080B842B:
			fmt.(*fmt).fmt_float(gs, (word32) dwArg04 + 32, (real64) (uint128) rArg08, dwArg10, dwArg14, 0x06);
			return;
		}
	}
	else
	{
		if (dwArg14 == 0x67)
			goto l080B846A;
		if (dwArg14 == 118)
		{
			fmt.(*fmt).fmt_float(gs, (word32) dwArg04 + 32, (real64) (uint128) rArg08, dwArg10, 0x67, ~0x00);
			return;
		}
	}
	fmt.(*pp).badVerb(gs, dwArg04, dwArg14);
}

// 080B8560: void fmt.(*pp).fmtComplex(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack real64 rArg08, Stack real64 rArg10, Stack int32 dwArg18, Stack Eq_4 dwArg1C)
// Called from:
//      fmt.(*pp).printArg
//      fmt.(*pp).printValue
void fmt.(*pp).fmtComplex(struct Eq_2 * gs, Eq_4 dwArg04, real64 rArg08, real64 rArg10, int32 dwArg18, Eq_4 dwArg1C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (dwArg1C <= 0x62)
	{
		if (dwArg1C <= 0x47 || dwArg1C == 0x62)
		{
l080B8592:
			byte dl_46 = *((word32) dwArg04 + 39);
			Eq_4 ebx_48 = *((word32) dwArg04 + 8);
			Eq_4 ebp_109 = *dwArg04;
			Eq_4 esi_107 = *((word32) dwArg04 + 4);
			if ((word32) esi_107 + 1 > ebx_48)
			{
				word128 xmm1_458;
				word128 xmm0_457;
				word32 esi_456;
				runtime.growslice(gs, 0x080CF320, ebp_109, esi_107, ebx_48, (word32) esi_107 + 1, out esi_456, out xmm0_457, out xmm1_458);
				*((word32) dwArg04 + 8) = dwLoc18;
				if (g_t81576F0 == 0x00)
					*dwArg04 = dwLoc20;
				else
					runtime.writebarrierptr(dwArg04, dwLoc20);
				esi_107 = dwLoc1C;
				ebp_109 = dwLoc20;
			}
			*((word32) dwArg04 + 4) = (word32) esi_107 + 1;
			Mem120[ebp_109 + esi_107:byte] = 0x28;
			Eq_132903 edx_126 = (dwArg18 >> 0x1F >> 0x1F) + dwArg18;
			fmt.(*pp).fmtFloat(gs, dwArg04, (real64) (uint128) rArg08, edx_126 >> 0x01, dwArg1C);
			*((word32) dwArg04 + 39) = 0x01;
			fmt.(*pp).fmtFloat(gs, dwArg04, (real64) (uint128) rArg10, edx_126 >> 0x01, dwArg1C);
			Eq_4 ecx_158 = *((word32) dwArg04 + 4);
			Eq_4 ebx_161 = *((word32) dwArg04 + 8);
			Eq_4 ebp_162 = *dwArg04;
			if ((word32) ecx_158 + 2 > ebx_161)
			{
				word128 xmm1_461;
				word128 xmm0_460;
				word32 esi_459;
				runtime.growslice(gs, 0x080CF320, ebp_162, ecx_158, ebx_161, (word32) ecx_158 + 2, out esi_459, out xmm0_460, out xmm1_461);
				ebx_161 = dwLoc18;
				ebp_162 = dwLoc20;
			}
			if ((word32) ecx_158 + 2 > ebx_161)
				runtime.panicslice(gs);
			else
			{
				word32 esi_463;
				word32 ebp_462;
				word128 xmm0_465;
				word32 edi_464;
				word128 xmm2_467;
				word128 xmm1_466;
				runtime.memmove(ebp_162 + ecx_158, 135138835, 0x02, out ebp_462, out esi_463, out edi_464, out xmm0_465, out xmm1_466, out xmm2_467);
				*((word32) dwArg04 + 4) = (word32) ecx_158 + 2;
				*((word32) dwArg04 + 8) = ebx_161;
				if (g_t81576F0 == 0x00)
					*dwArg04 = ebp_162;
				else
					runtime.writebarrierptr(dwArg04, ebp_162);
				*((word32) dwArg04 + 39) = dl_46;
				return;
			}
		}
	}
	else if (dwArg1C <= 0x67 || dwArg1C == 118)
		goto l080B8592;
	fmt.(*pp).badVerb(gs, dwArg04, dwArg1C);
}

// 080B8790: void fmt.(*pp).fmtString(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C, Stack Eq_4 dwArg10)
// Called from:
//      fmt.(*pp).handleMethods
//      fmt.(*pp).printArg
//      fmt.(*pp).printValue
void fmt.(*pp).fmtString(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C, Eq_4 dwArg10)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (dwArg10 <= 113)
	{
		if (dwArg10 == 88)
		{
			fmt.(*fmt).fmt_sx(gs, (word32) dwArg04 + 32, dwArg08, dwArg0C, &g_t80E26DB, 0x11);
			return;
		}
		if (dwArg10 == 113)
		{
			fmt.(*fmt).fmt_q(gs, (word32) dwArg04 + 32, dwArg08, dwArg0C);
			return;
		}
	}
	else
	{
		if (dwArg10 == 115)
		{
			word128 xmm1_334;
			fmt.(*fmt).fmt_s(gs, (word32) dwArg04 + 32, dwArg08, dwArg0C, out xmm1_334);
			return;
		}
		if (dwArg10 == 118)
		{
			if (*((word32) dwArg04 + 44) != 0x00)
				fmt.(*fmt).fmt_q(gs, (word32) dwArg04 + 32, dwArg08, dwArg0C);
			else
			{
				word128 xmm1_335;
				fmt.(*fmt).fmt_s(gs, (word32) dwArg04 + 32, dwArg08, dwArg0C, out xmm1_335);
			}
			return;
		}
		if (dwArg10 == 0x78)
		{
			fmt.(*fmt).fmt_sx(gs, (word32) dwArg04 + 32, dwArg08, dwArg0C, &g_t80E26EC, 0x11);
			return;
		}
	}
	fmt.(*pp).badVerb(gs, dwArg04, dwArg10);
}

// 080B8900: void fmt.(*pp).fmtBytes(Register Eq_4 ebx, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C, Stack Eq_4 dwArg14, Stack Eq_4 dwArg18, Stack Eq_4 dwArg1C)
// Called from:
//      fmt.(*pp).printArg
//      fmt.(*pp).printValue
void fmt.(*pp).fmtBytes(Eq_4 ebx, struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C, Eq_4 dwArg14, Eq_4 dwArg18, Eq_4 dwArg1C)
{
	while (fp - 0x1C <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (dwArg14 <= 113)
	{
		if (dwArg14 == 88)
		{
			fmt.(*fmt).fmt_bx(gs, (word32) dwArg04 + 32, dwArg08, dwArg0C, &g_t80E26DB, 0x11);
			return;
		}
		if (dwArg14 == 100)
			goto l080B8942;
		if (dwArg14 == 113)
		{
			runtime.slicebytetostring(gs, fp - 0x60, dwArg08, dwArg0C);
			fmt.(*fmt).fmt_q(gs, (word32) dwArg04 + 32, dwLoc8C, dwLoc88);
			return;
		}
	}
	else
	{
		if (dwArg14 == 115)
		{
			runtime.slicebytetostring(gs, fp - 0x40, dwArg08, dwArg0C);
			word128 xmm1_1648;
			fmt.(*fmt).fmt_s(gs, (word32) dwArg04 + 32, dwLoc8C, dwLoc88, out xmm1_1648);
			return;
		}
		if (dwArg14 == 118)
		{
l080B8942:
			if (*((word32) dwArg04 + 44) == 0x00)
			{
				Eq_4 ecx_288 = *((word32) dwArg04 + 8);
				Eq_4 edx_289 = *((word32) dwArg04 + 4);
				Eq_4 ebx_290 = *dwArg04;
				if ((word32) edx_289 + 1 > ecx_288)
				{
					word128 xmm1_1641;
					word128 xmm0_1640;
					word32 esi_1639;
					runtime.growslice(gs, 0x080CF320, ebx_290, edx_289, ecx_288, (word32) edx_289 + 1, out esi_1639, out xmm0_1640, out xmm1_1641);
					*((word32) dwArg04 + 8) = dwLoc80;
					if (g_t81576F0 == 0x00)
						*dwArg04 = dwLoc88;
					else
						runtime.writebarrierptr(dwArg04, dwLoc88);
					edx_289 = dwLoc84;
					ebx_290 = dwLoc88;
				}
				*((word32) dwArg04 + 4) = (word32) edx_289 + 1;
				Mem358[ebx_290 + edx_289:byte] = 0x5B;
				Eq_4 ecx_359 = 0x00;
				Eq_4 edx_363 = dwArg08;
				while (true)
				{
					ui24 ebx_24_8_536 = SLICE(dwArg0C, word24, 8);
					if (ecx_359 >= dwArg0C)
						break;
					word32 ebp_445 = (word32) *edx_363;
					if (ecx_359 > 0x00)
					{
						Eq_4 ebx_450 = *((word32) dwArg04 + 8);
						Eq_4 esi_448 = *((word32) dwArg04 + 4);
						Eq_4 edi_449 = *dwArg04;
						ebx_24_8_536 = SLICE(ebx_450, word24, 8);
						if ((word32) esi_448 + 1 > ebx_450)
						{
							word128 xmm1_1644;
							word128 xmm0_1643;
							word32 esi_1642;
							runtime.growslice(gs, 0x080CF320, edi_449, esi_448, ebx_450, (word32) esi_448 + 1, out esi_1642, out xmm0_1643, out xmm1_1644);
							*((word32) dwArg04 + 8) = dwLoc80;
							if (g_t81576F0 == 0x00)
								*dwArg04 = dwLoc88;
							else
								runtime.writebarrierptr(dwArg04, dwLoc88);
							ebx_24_8_536 = SLICE(dwArg04, word24, 8);
							esi_448 = dwLoc84;
							edi_449 = dwLoc88;
						}
						*((word32) dwArg04 + 4) = (word32) esi_448 + 1;
						Mem521[edi_449 + esi_448:byte] = 0x20;
					}
					fmt.(*fmt).fmt_integer(ebx_24_8_536, gs, (word32) dwArg04 + 32, (uint64) ebp_445, 0x0A, 0x00, &g_t80E26EC, 0x11);
					dwLoc88.u0 = 0x080E26EC;
					dwLoc84.u0 = 0x11;
					edx_363 = (word32) edx_363 + 1;
					ecx_359 = (word32) ecx_359 + 1;
				}
				Eq_4 ecx_371 = *((word32) dwArg04 + 8);
				Eq_4 edx_372 = *((word32) dwArg04 + 4);
				Eq_4 ebx_373 = *dwArg04;
				if ((word32) edx_372 + 1 > ecx_371)
				{
					word128 xmm1_1647;
					word32 esi_1645;
					word128 xmm0_1646;
					runtime.growslice(gs, 0x080CF320, ebx_373, edx_372, ecx_371, (word32) edx_372 + 1, out esi_1645, out xmm0_1646, out xmm1_1647);
					*((word32) dwArg04 + 8) = dwLoc80;
					if (g_t81576F0 == 0x00)
						*dwArg04 = dwLoc88;
					else
						runtime.writebarrierptr(dwArg04, dwLoc88);
					edx_372 = dwLoc84;
					ebx_373 = dwLoc88;
				}
				*((word32) dwArg04 + 4) = (word32) edx_372 + 1;
				Mem441[ebx_373 + edx_372:byte] = 0x5D;
				return;
			}
			else
			{
				Eq_4 ecx_569 = *((word32) dwArg04 + 4);
				word32 ebx_571 = ecx_569 + dwArg1C;
				Eq_4 ebp_573 = *((word32) dwArg04 + 8);
				Eq_4 esi_574 = *dwArg04;
				if (ebx_571 > ebp_573)
				{
					word32 esi_1606;
					word128 xmm0_1607;
					word128 xmm1_1608;
					runtime.growslice(gs, 0x080CF320, esi_574, ecx_569, ebp_573, ebx_571, out esi_1606, out xmm0_1607, out xmm1_1608);
					ebp_573 = dwLoc80;
					esi_574 = dwLoc88;
				}
				if (ebx_571 > ebp_573)
					runtime.panicslice(gs);
				else
				{
					word128 xmm2_1614;
					word128 xmm1_1613;
					word128 xmm0_1612;
					word32 edi_1611;
					word32 esi_1610;
					word32 ebp_1609;
					runtime.memmove(esi_574 + ecx_569, dwArg18, dwArg1C, out ebp_1609, out esi_1610, out edi_1611, out xmm0_1612, out xmm1_1613, out xmm2_1614);
					*((word32) dwArg04 + 4) = ebx_571;
					*((word32) dwArg04 + 8) = ebp_573;
					if (g_t81576F0 == 0x00)
						*dwArg04 = esi_574;
					else
						runtime.writebarrierptr(dwArg04, esi_574);
					Eq_4 eax_686 = esi_574;
					if (dwArg08 == 0x00)
					{
						Eq_4 edx_677 = *((word32) dwArg04 + 4);
						Eq_4 ebp_680 = *((word32) dwArg04 + 8);
						if ((word32) edx_677 + 5 > ebp_680)
						{
							word128 xmm1_1629;
							word32 esi_1627;
							word128 xmm0_1628;
							runtime.growslice(gs, 0x080CF320, esi_574, edx_677, ebp_680, (word32) edx_677 + 5, out esi_1627, out xmm0_1628, out xmm1_1629);
							eax_686 = dwLoc88;
							ebp_680 = dwLoc80;
						}
						if ((word32) edx_677 + 5 > ebp_680)
							runtime.panicslice(gs);
						else
						{
							word128 xmm2_1635;
							word128 xmm1_1634;
							word128 xmm0_1633;
							word32 edi_1632;
							word32 esi_1631;
							word32 ebp_1630;
							runtime.memmove(eax_686 + edx_677, 0x080E0FB1, 0x05, out ebp_1630, out esi_1631, out edi_1632, out xmm0_1633, out xmm1_1634, out xmm2_1635);
							*((word32) dwArg04 + 4) = (word32) edx_677 + 5;
							*((word32) dwArg04 + 8) = ebp_680;
							if (g_t81576F0 == 0x00)
								*dwArg04 = eax_686;
							else
								runtime.writebarrierptr(dwArg04, eax_686);
							return;
						}
					}
					else
					{
						Eq_4 ebx_777 = *((word32) dwArg04 + 8);
						Eq_4 ebp_778 = *((word32) dwArg04 + 4);
						if ((word32) ebp_778 + 1 > ebx_777)
						{
							word128 xmm1_1617;
							word128 xmm0_1616;
							word32 esi_1615;
							runtime.growslice(gs, 0x080CF320, esi_574, ebp_778, ebx_777, (word32) ebp_778 + 1, out esi_1615, out xmm0_1616, out xmm1_1617);
							*((word32) dwArg04 + 8) = dwLoc80;
							if (g_t81576F0 == 0x00)
								*dwArg04 = dwLoc88;
							else
								runtime.writebarrierptr(dwArg04, dwLoc88);
							eax_686 = dwLoc88;
							ebp_778 = dwLoc84;
						}
						*((word32) dwArg04 + 4) = (word32) ebp_778 + 1;
						Mem846[eax_686 + ebp_778:byte] = 0x7B;
						Eq_4 edx_1072 = dwArg08;
						Eq_4 eax_1074 = 0x00;
						while (true)
						{
							ui24 ebx_24_8_1047 = SLICE(dwArg0C, word24, 8);
							if (eax_1074 >= dwArg0C)
								break;
							word32 ebp_937 = (word32) *edx_1072;
							if (eax_1074 > 0x00)
							{
								Eq_4 esi_941 = *((word32) dwArg04 + 4);
								Eq_4 ebx_944 = *dwArg04;
								Eq_4 eax_945 = *((word32) dwArg04 + 8);
								if ((word32) esi_941 + 2 > eax_945)
								{
									word128 xmm1_1620;
									word32 esi_1618;
									word128 xmm0_1619;
									runtime.growslice(gs, 0x080CF320, ebx_944, esi_941, eax_945, (word32) esi_941 + 2, out esi_1618, out xmm0_1619, out xmm1_1620);
									ebx_944 = dwLoc88;
									eax_945 = dwLoc80;
								}
								if ((word32) esi_941 + 2 > eax_945)
									runtime.panicslice(gs);
								word128 xmm2_1626;
								word128 xmm1_1625;
								word128 xmm0_1624;
								word32 edi_1623;
								word32 esi_1622;
								word32 ebp_1621;
								ebx_24_8_1047 = SLICE(runtime.memmove(ebx_944 + esi_941, 0x080E0DB5, 0x02, out ebp_1621, out esi_1622, out edi_1623, out xmm0_1624, out xmm1_1625, out xmm2_1626), word24, 8);
								*((word32) dwArg04 + 4) = (word32) esi_941 + 2;
								*((word32) dwArg04 + 8) = eax_945;
								if (g_t81576F0 == 0x00)
									*dwArg04 = ebx_944;
								else
									runtime.writebarrierptr(dwArg04, ebx_944);
							}
							fmt.(*pp).fmt0x64(ebx_24_8_1047, gs, dwArg04, (uint64) ebp_937, 0x01);
							edx_1072 = (word32) edx_1072 + 1;
							eax_1074 = (word32) eax_1074 + 1;
						}
						Eq_4 eax_857 = *((word32) dwArg04 + 8);
						Eq_4 edx_858 = *((word32) dwArg04 + 4);
						Eq_4 ebx_859 = *dwArg04;
						if ((word32) edx_858 + 1 > eax_857)
						{
							word128 xmm1_1638;
							word32 esi_1636;
							word128 xmm0_1637;
							runtime.growslice(gs, 0x080CF320, ebx_859, edx_858, eax_857, (word32) edx_858 + 1, out esi_1636, out xmm0_1637, out xmm1_1638);
							*((word32) dwArg04 + 8) = dwLoc80;
							if (g_t81576F0 == 0x00)
								*dwArg04 = dwLoc88;
							else
								runtime.writebarrierptr(dwArg04, dwLoc88);
							edx_858 = dwLoc84;
							ebx_859 = dwLoc88;
						}
						*((word32) dwArg04 + 4) = (word32) edx_858 + 1;
						Mem926[ebx_859 + edx_858:byte] = 0x7D;
						return;
					}
				}
			}
		}
		if (dwArg14 == 0x78)
		{
			fmt.(*fmt).fmt_bx(gs, (word32) dwArg04 + 32, dwArg08, dwArg0C, &g_t80E26EC, 0x11);
			return;
		}
	}
	runtime.convT2Eslice(ebx, gs, 0x080CA1C0, fp - 0x0C);
	reflect.ValueOf(gs, dwLoc94, dwLoc90);
	fmt.(*pp).printValue(gs, dwArg04, dwLoc94, dwLoc90, dwLoc8C, dwArg14, 0x00);
}

// subject_text_0007.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 080B91D0: void fmt.(*pp).fmtPointer(Register Eq_4 ebx, Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C, Stack Eq_4 dwArg10, Stack Eq_4 dwArg14)
// Called from:
//      fmt.(*pp).printArg
//      fmt.(*pp).printValue
void fmt.(*pp).fmtPointer(Eq_4 ebx, struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C, Eq_4 dwArg10, Eq_4 dwArg14)
{
	ui24 ebx_24_8 = SLICE(ebx, word24, 8);
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (((dwArg10 & 0x1F) > 0x13 || (dwArg10 & 0x1F) < 0x12) && ((dwArg10 & 0x1F) > 0x17 && (dwArg10 & 0x1F) != 0x1A))
	{
		fmt.(*pp).badVerb(gs, dwArg04, dwArg14);
		return;
	}
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	Eq_4 stackArg4 = <invalid>;
	reflect.Value.Pointer(gs, stackArg4, dwArg10);
	if (dwArg14 <= 100)
	{
		if (dwArg14 == 88 || (dwArg14 == 0x62 || dwArg14 == 100))
			goto l080B9228;
		goto l080B9257;
	}
	if (dwArg14 <= 0x70)
	{
		if (dwArg14 != 111)
		{
			if (dwArg14 == 0x70)
			{
				fmt.(*pp).fmt0x64(ebx_24_8, gs, dwArg04, (uint64) dwLoc38, *((word32) dwArg04 + 40) ^ 0x01);
				return;
			}
			goto l080B9257;
		}
	}
	else
	{
		if (dwArg14 == 118)
		{
			if (*((word32) dwArg04 + 44) == 0x00)
			{
				if (dwLoc38 == 0x00)
				{
					word128 xmm1_1133;
					fmt.(*fmt).padString(gs, (word32) dwArg04 + 32, 0x080E0FC5, 0x05, out xmm1_1133);
				}
				else
					fmt.(*pp).fmt0x64(ebx_24_8, gs, dwArg04, (uint64) dwLoc38, *((word32) dwArg04 + 40) ^ 0x01);
				return;
			}
			else
			{
				Eq_4 dwLoc38_755;
				Eq_4 edx_133 = *((word32) dwArg04 + 8);
				Eq_4 ebx_134 = *((word32) dwArg04 + 4);
				Eq_4 ebp_135 = *dwArg04;
				dwLoc38_755 = dwLoc38;
				if ((word32) ebx_134 + 1 > edx_133)
				{
					word32 esi_1100;
					word128 xmm0_1101;
					word128 xmm1_1102;
					runtime.growslice(gs, 0x080CF320, ebp_135, ebx_134, edx_133, (word32) ebx_134 + 1, out esi_1100, out xmm0_1101, out xmm1_1102);
					*((word32) dwArg04 + 8) = dwLoc28;
					dwLoc38_755 = edx_133;
					dwLoc34 = (word32) ebx_134 + 1;
					if (g_t81576F0 == 0x00)
						*dwArg04 = dwLoc30;
					else
						runtime.writebarrierptr(dwArg04, dwLoc30);
					ebx_134 = dwLoc2C;
					ebp_135 = dwLoc30;
				}
				*((word32) dwArg04 + 4) = (word32) ebx_134 + 1;
				Mem202[ebp_135 + ebx_134:byte] = 0x28;
				reflect.Value.Type(gs, dwArg08, dwArg10);
				Eq_4 eax_222 = *((word32) dwLoc38_755 + 0x0084);
				eax_222();
				Eq_4 ebx_235 = *((word32) dwArg04 + 4);
				word32 ebp_236 = ebx_235 + dwArg10;
				Eq_4 esi_238 = *((word32) dwArg04 + 8);
				Eq_4 edi_239 = *dwArg04;
				if (ebp_236 > esi_238)
				{
					word32 esi_1103;
					word128 xmm1_1105;
					word128 xmm0_1104;
					runtime.growslice(gs, 0x080CF320, edi_239, ebx_235, esi_238, ebp_236, out esi_1103, out xmm0_1104, out xmm1_1105);
					esi_238 = dwLoc28;
					edi_239 = dwLoc30;
				}
				if (ebp_236 > esi_238)
					runtime.panicslice(gs);
				else
				{
					word128 xmm2_1111;
					word128 xmm1_1110;
					word128 xmm0_1109;
					word32 ebp_1106;
					word32 esi_1107;
					word32 edi_1108;
					runtime.memmove(edi_239 + ebx_235, dwArg0C, dwArg10, out ebp_1106, out esi_1107, out edi_1108, out xmm0_1109, out xmm1_1110, out xmm2_1111);
					*((word32) dwArg04 + 4) = ebp_236;
					*((word32) dwArg04 + 8) = esi_238;
					if (g_t81576F0 == 0x00)
						*dwArg04 = edi_239;
					else
						runtime.writebarrierptr(dwArg04, edi_239);
					Eq_4 eax_350 = edi_239;
					Eq_4 edx_340 = *((word32) dwArg04 + 4);
					Eq_4 ebp_344 = *((word32) dwArg04 + 8);
					if ((word32) edx_340 + 2 > ebp_344)
					{
						word128 xmm1_1114;
						word32 esi_1112;
						word128 xmm0_1113;
						runtime.growslice(gs, 0x080CF320, edi_239, edx_340, ebp_344, (word32) edx_340 + 2, out esi_1112, out xmm0_1113, out xmm1_1114);
						eax_350 = dwLoc30;
						ebp_344 = dwLoc28;
					}
					if ((word32) edx_340 + 2 > ebp_344)
						runtime.panicslice(gs);
					else
					{
						word128 xmm2_1120;
						word128 xmm1_1119;
						word32 esi_1116;
						word32 edi_1117;
						word128 xmm0_1118;
						word32 ebp_1115;
						word24 ebx_24_8_452 = SLICE(runtime.memmove(eax_350 + edx_340, 135138737, 0x02, out ebp_1115, out esi_1116, out edi_1117, out xmm0_1118, out xmm1_1119, out xmm2_1120), word24, 8);
						*((word32) dwArg04 + 4) = (word32) edx_340 + 2;
						*((word32) dwArg04 + 8) = ebp_344;
						if (g_t81576F0 == 0x00)
							*dwArg04 = eax_350;
						else
							runtime.writebarrierptr(dwArg04, eax_350);
						Eq_4 eax_484 = eax_350;
						if (dwLoc38 == 0x00)
						{
							Eq_4 edx_475 = *((word32) dwArg04 + 4);
							Eq_4 ebp_478 = *((word32) dwArg04 + 8);
							if ((word32) edx_475 + 3 > ebp_478)
							{
								word32 esi_1121;
								word128 xmm0_1122;
								word128 xmm1_1123;
								runtime.growslice(gs, 0x080CF320, eax_350, edx_475, ebp_478, (word32) edx_475 + 3, out esi_1121, out xmm0_1122, out xmm1_1123);
								ebp_478 = dwLoc28;
								eax_484 = dwLoc30;
							}
							if ((word32) edx_475 + 3 > ebp_478)
								runtime.panicslice(gs);
							word32 edi_1126;
							word128 xmm0_1127;
							word128 xmm1_1128;
							word32 esi_1125;
							word32 ebp_1124;
							word128 xmm2_1129;
							runtime.memmove(eax_484 + edx_475, 0x080E0E70, 0x03, out ebp_1124, out esi_1125, out edi_1126, out xmm0_1127, out xmm1_1128, out xmm2_1129);
							*((word32) dwArg04 + 4) = (word32) edx_475 + 3;
							*((word32) dwArg04 + 8) = ebp_478;
							if (g_t81576F0 == 0x00)
								*dwArg04 = eax_484;
							else
								runtime.writebarrierptr(dwArg04, eax_484);
						}
						else
							fmt.(*pp).fmt0x64(ebx_24_8_452, gs, dwArg04, (uint64) dwLoc38, 0x01);
						Eq_4 eax_574 = *((word32) dwArg04 + 8);
						Eq_4 edx_575 = *((word32) dwArg04 + 4);
						Eq_4 ebx_576 = *dwArg04;
						if ((word32) edx_575 + 1 > eax_574)
						{
							word128 xmm0_1131;
							word32 esi_1130;
							word128 xmm1_1132;
							runtime.growslice(gs, 0x080CF320, ebx_576, edx_575, eax_574, (word32) edx_575 + 1, out esi_1130, out xmm0_1131, out xmm1_1132);
							*((word32) dwArg04 + 8) = dwLoc28;
							if (g_t81576F0 == 0x00)
								*dwArg04 = dwLoc30;
							else
								runtime.writebarrierptr(dwArg04, dwLoc30);
							edx_575 = dwLoc2C;
							ebx_576 = dwLoc30;
						}
						*((word32) dwArg04 + 4) = (word32) edx_575 + 1;
						Mem644[ebx_576 + edx_575:byte] = 0x29;
						return;
					}
				}
			}
		}
		if (dwArg14 != 0x78)
		{
l080B9257:
			fmt.(*pp).badVerb(gs, dwArg04, dwArg14);
			return;
		}
	}
l080B9228:
	fmt.(*pp).fmtInteger(SLICE(dwArg04, word24, 8), ebx, ebp, edi, gs, dwArg04, dwLoc38, 0x00, dwArg14);
}

// 080B9720: void fmt.(*pp).catchPanic(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C, Stack Eq_4 dwArg10)
void fmt.(*pp).catchPanic(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C, Eq_4 dwArg10)
{
	byte bLoc3C_564 = (byte) dwLoc3C;
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.gorecover(gs, (word32) fp + 4);
	if (dwLoc44 == 0x00)
		return;
	reflect.ValueOf(gs, dwArg08, dwArg0C);
	if ((dwLoc38 & 0x1F) == 22)
	{
		reflect.Value.IsNil(gs, dwLoc38);
		if (bLoc3C_564 != 0x00)
		{
			Eq_4 ecx_69 = *((word32) dwArg04 + 4);
			Eq_4 ebx_103 = *((word32) dwArg04 + 8);
			Eq_4 ebp_104 = *dwArg04;
			if ((word32) ecx_69 + 5 > ebx_103)
			{
				word128 xmm1_837;
				word128 xmm0_836;
				word32 esi_835;
				runtime.growslice(gs, 0x080CF320, ebp_104, ecx_69, ebx_103, (word32) ecx_69 + 5, out esi_835, out xmm0_836, out xmm1_837);
				ebx_103 = dwLoc2C;
				ebp_104 = dwLoc34;
			}
			if ((word32) ecx_69 + 5 > ebx_103)
				runtime.panicslice(gs);
			else
			{
				word32 esi_839;
				word32 ebp_838;
				word32 edi_840;
				word128 xmm0_841;
				word128 xmm1_842;
				word128 xmm2_843;
				runtime.memmove(ebp_104 + ecx_69, 0x080E0FC5, 0x05, out ebp_838, out esi_839, out edi_840, out xmm0_841, out xmm1_842, out xmm2_843);
				*((word32) dwArg04 + 4) = (word32) ecx_69 + 5;
				*((word32) dwArg04 + 8) = ebx_103;
				if (g_t81576F0 == 0x00)
					*dwArg04 = ebp_104;
				else
					runtime.writebarrierptr(dwArg04, ebp_104);
				return;
			}
		}
	}
	if (*((word32) dwArg04 + 0x007E) != 0x00)
		runtime.gopanic(gs);
	else
	{
		word32 ecx_195 = *((word32) dwArg04 + 37);
		Eq_4 bLoc19_679 = *((word32) dwArg04 + 36);
		word32 edx_196 = *((word32) dwArg04 + 41);
		((word32) dwArg04 + 36)->u0 = 0x00;
		*((word32) dwArg04 + 37) = 0x00;
		*((word32) dwArg04 + 41) = 0x00;
		word24 nLoc18_680 = (word24) ecx_195;
		byte bLoc15_695 = SLICE(ecx_195, byte, 24);
		Eq_4 ecx_205 = *((word32) dwArg04 + 4);
		Eq_4 ebx_208 = *((word32) dwArg04 + 8);
		Eq_4 ebp_209 = *dwArg04;
		Eq_4 dwLoc19_678 = SEQ(nLoc18_680, bLoc19_679);
		dwLoc19_678 = SEQ(nLoc18_680, bLoc19_679);
		if ((word32) ecx_205 + 2 > ebx_208)
		{
			word128 xmm1_818;
			word128 xmm0_817;
			word32 esi_816;
			runtime.growslice(gs, 0x080CF320, ebp_209, ecx_205, ebx_208, (word32) ecx_205 + 2, out esi_816, out xmm0_817, out xmm1_818);
			ebx_208 = dwLoc2C;
			ebp_209 = dwLoc34;
		}
		word24 nLoc18_697 = SLICE(dwLoc19_678, word24, 8);
		if ((word32) ecx_205 + 2 > ebx_208)
			runtime.panicslice(gs);
		else
		{
			word128 xmm2_824;
			word128 xmm1_823;
			word128 xmm0_822;
			word32 edi_821;
			word32 esi_820;
			word32 ebp_819;
			runtime.memmove(ebp_209 + ecx_205, 0x080E0DAD, 0x02, out ebp_819, out esi_820, out edi_821, out xmm0_822, out xmm1_823, out xmm2_824);
			*((word32) dwArg04 + 4) = (word32) ecx_205 + 2;
			*((word32) dwArg04 + 8) = ebx_208;
			if (g_t81576F0 == 0x00)
				*dwArg04 = ebp_209;
			else
				runtime.writebarrierptr(dwArg04, ebp_209);
			fmt.(*buffer).WriteRune(gs, dwArg04, dwArg10);
			Eq_4 ecx_329 = *((word32) dwArg04 + 4);
			Eq_4 ebx_332 = *((word32) dwArg04 + 8);
			Eq_4 ebp_333 = *dwArg04;
			if ((word32) ecx_329 + 7 > ebx_332)
			{
				word128 xmm1_827;
				word128 xmm0_826;
				word32 esi_825;
				runtime.growslice(gs, 0x080CF320, ebp_333, ecx_329, ebx_332, (word32) ecx_329 + 7, out esi_825, out xmm0_826, out xmm1_827);
				ebx_332 = dwLoc2C;
				ebp_333 = dwLoc34;
			}
			if ((word32) ecx_329 + 7 > ebx_332)
				runtime.panicslice(gs);
			else
			{
				Eq_662 xmm0_390;
				Eq_662 xmm1_391;
				word128 xmm2_831;
				word32 edi_830;
				word32 esi_829;
				word32 ebp_828;
				runtime.memmove(ebp_333 + ecx_329, 0x080E11E6, 0x07, out ebp_828, out esi_829, out edi_830, out xmm0_390, out xmm1_391, out xmm2_831);
				*((word32) dwArg04 + 4) = (word32) ecx_329 + 7;
				*((word32) dwArg04 + 8) = ebx_332;
				if (g_t81576F0 == 0x00)
					*dwArg04 = ebp_333;
				else
					runtime.writebarrierptr(dwArg04, ebp_333);
				*((word32) dwArg04 + 0x007E) = 0x01;
				word128 xmm1_844;
				fmt.(*pp).printArg(gs, xmm0_390, xmm1_391, dwArg04, dwLoc44, dwLoc40, 118, out xmm1_844);
				*((word32) dwArg04 + 0x007E) = 0x00;
				Eq_4 ecx_461 = *((word32) dwArg04 + 8);
				Eq_4 edx_462 = *((word32) dwArg04 + 4);
				Eq_4 ebx_463 = *dwArg04;
				if ((word32) edx_462 + 1 > ecx_461)
				{
					word128 xmm1_834;
					word128 xmm0_833;
					word32 esi_832;
					runtime.growslice(gs, 0x080CF320, ebx_463, edx_462, ecx_461, (word32) edx_462 + 1, out esi_832, out xmm0_833, out xmm1_834);
					*((word32) dwArg04 + 8) = dwLoc2C;
					if (g_t81576F0 == 0x00)
						*dwArg04 = dwLoc34;
					else
						runtime.writebarrierptr(dwArg04, dwLoc34);
					edx_462 = dwLoc30;
					ebx_463 = dwLoc34;
				}
				*((word32) dwArg04 + 4) = (word32) edx_462 + 1;
				Mem530[ebx_463 + edx_462:byte] = 0x29;
				*((word32) dwArg04 + 36) = dwLoc19_678;
				*((word32) dwArg04 + 37) = SEQ(bLoc15_695, nLoc18_697);
				*((word32) dwArg04 + 41) = edx_196;
			}
		}
	}
}

// 080B9B30: void fmt.(*pp).handleMethods(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08)
// Called from:
//      fmt.(*pp).printArg
//      fmt.(*pp).printValue
void fmt.(*pp).handleMethods(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	if (*((word32) dwArg04 + 0x007F) != 0x00)
	{
		word128 xmm0_728;
		word128 xmm1_729;
		runtime.deferreturn(gs, out xmm0_728, out xmm1_729);
		return;
	}
	runtime.assertE2I2(gs, *((word32) dwArg04 + 0x0C));
	if (bLoc2C != 0x00)
	{
		word32 ecx_69 = *((word32) dwArg04 + 16);
		byte bLoc2C_609 = (byte) dwArg08;
		word32 ebp_730;
		word32 esi_731;
		word32 edi_732;
		if (runtime.deferproc(gs, 0x10, 0x080E7B0C, dwArg04, out ebp_730, out esi_731, out edi_732) != 0x00)
		{
			word128 xmm0_761;
			word128 xmm1_762;
			runtime.deferreturn(gs, out xmm0_761, out xmm1_762);
			return;
		}
		else
		{
			<anonymous> * eax_125 = dwLoc34->ptr0014;
			eax_125();
			word128 xmm0_763;
			word128 xmm1_764;
			runtime.deferreturn(gs, out xmm0_763, out xmm1_764);
			return;
		}
	}
	if (*((word32) dwArg04 + 44) != 0x00)
	{
		runtime.assertE2I2(gs, *((word32) dwArg04 + 0x0C));
		if (bLoc2C != 0x00)
		{
			word32 ecx_190 = *((word32) dwArg04 + 16);
			Eq_4 edx_191 = *((word32) dwArg04 + 0x0C);
			byte bLoc2C_623 = (byte) dwArg08;
			word32 ebp_753;
			word32 esi_754;
			word32 edi_755;
			if (runtime.deferproc(gs, 0x10, 0x080E7B0C, dwArg04, out ebp_753, out esi_754, out edi_755) != 0x00)
			{
				word128 xmm0_756;
				word128 xmm1_757;
				runtime.deferreturn(gs, out xmm0_756, out xmm1_757);
				return;
			}
			else
			{
				<anonymous> * eax_246 = dwLoc34->ptr0014;
				eax_246();
				word128 xmm1_758;
				fmt.(*fmt).fmt_s(gs, (word32) dwArg04 + 32, 0x080E7B0C, dwArg04, out xmm1_758);
				word128 xmm0_759;
				word128 xmm1_760;
				runtime.deferreturn(gs, out xmm0_759, out xmm1_760);
				return;
			}
		}
		goto l080B9BBF;
	}
	if (dwArg08 <= 113)
	{
		if (dwArg08 != 88 && dwArg08 != 113)
			goto l080B9BBF;
	}
	else if (dwArg08 != 115 && (dwArg08 != 118 && dwArg08 != 0x78))
		goto l080B9BBF;
	Eq_4 ebx_316 = *((word32) dwArg04 + 0x0C);
	if (ebx_316 != 0x00)
	{
		runtime.assertE2I2(gs, ebx_316);
		if (bLoc2C != 0x00)
		{
			word32 ecx_462 = *((word32) dwArg04 + 16);
			Eq_4 edx_463 = *((word32) dwArg04 + 0x0C);
			byte bLoc2C_661 = (byte) dwArg08;
			word32 ebp_735;
			word32 esi_736;
			word32 edi_737;
			if (runtime.deferproc(gs, 0x10, 0x080E7B0C, dwArg04, out ebp_735, out esi_736, out edi_737) != 0x00)
			{
				word128 xmm0_738;
				word128 xmm1_739;
				runtime.deferreturn(gs, out xmm0_738, out xmm1_739);
				return;
			}
			else
			{
				<anonymous> * eax_518 = dwLoc34->ptr0014;
				eax_518();
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				Eq_4 stackArg8 = <invalid>;
				Eq_4 stackArg12 = <invalid>;
				fmt.(*pp).fmtString(gs, dwArg04, stackArg8, stackArg12, dwArg08);
				word128 xmm0_742;
				word128 xmm1_743;
				runtime.deferreturn(gs, out xmm0_742, out xmm1_743);
				return;
			}
		}
		runtime.assertE2I2(gs, ebx_316);
		if (bLoc2C != 0x00)
		{
			word32 ecx_364 = *((word32) dwArg04 + 16);
			Eq_4 edx_365 = *((word32) dwArg04 + 0x0C);
			byte bLoc2C_648 = (byte) dwArg08;
			word32 ebp_744;
			word32 esi_745;
			word32 edi_746;
			if (runtime.deferproc(gs, 0x10, 0x080E7B0C, dwArg04, out ebp_744, out esi_745, out edi_746) != 0x00)
			{
				word128 xmm0_747;
				word128 xmm1_748;
				runtime.deferreturn(gs, out xmm0_747, out xmm1_748);
				return;
			}
			else
			{
				<anonymous> * eax_420 = dwLoc34->ptr0014;
				eax_420();
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				Eq_4 stackArg8 = <invalid>;
				Eq_4 stackArg12 = <invalid>;
				fmt.(*pp).fmtString(gs, dwArg04, stackArg8, stackArg12, dwArg08);
				word128 xmm0_751;
				word128 xmm1_752;
				runtime.deferreturn(gs, out xmm0_751, out xmm1_752);
				return;
			}
		}
	}
l080B9BBF:
	word128 xmm0_733;
	word128 xmm1_734;
	runtime.deferreturn(gs, out xmm0_733, out xmm1_734);
}

// 080B9EA0: Register Eq_662 fmt.(*pp).printArg(Register (ptr32 Eq_2) gs, Register Eq_662 xmm0, Register Eq_662 xmm1, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C, Stack Eq_4 dwArg10, Register out Eq_662 xmm1Out)
// Called from:
//      fmt.(*pp).badVerb
//      fmt.(*pp).catchPanic
//      fmt.(*pp).doPrintln
Eq_662 fmt.(*pp).printArg(struct Eq_2 * gs, Eq_662 xmm0, Eq_662 xmm1, Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C, Eq_4 dwArg10, union Eq_662 & xmm1Out)
{
	byte bLoc30_1557 = (byte) dwLoc30;
	byte bLoc2C_1392 = (byte) dwLoc2C;
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	*((word32) dwArg04 + 0x0C) = dwArg08;
	if (g_t81576F0 == 0x00)
		*((word32) dwArg04 + 16) = dwArg0C;
	else
	{
		runtime.writebarrierptr((word32) dwArg04 + 16, dwArg0C);
		dwLoc34 = dwArg0C;
	}
	((word32) dwArg04 + 28)->u0 = 0x00;
	if (g_t81576F0 == 0x00)
	{
		((word32) dwArg04 + 20)->u0 = 0x00;
		((word32) dwArg04 + 24)->u0 = 0x00;
	}
	else
	{
		runtime.writebarrierptr((word32) dwArg04 + 20, 0x00);
		runtime.writebarrierptr((word32) dwArg04 + 24, 0x00);
		dwLoc34.u0 = 0x00;
	}
	if (dwArg08 == 0x00)
	{
		if (dwArg10 == 0x54 || dwArg10 == 118)
			xmm0 = fmt.(*fmt).padString(gs, (word32) dwArg04 + 32, 0x080E0FC5, 0x05, out xmm1);
		else
			fmt.(*pp).badVerb(gs, dwArg04, dwArg10);
		xmm1Out = xmm1;
		return xmm0;
	}
	if (dwArg10 == 0x54)
	{
		struct Eq_134638 * edx_1074;
		Eq_4 eax_1069 = dwArg08;
		if (dwArg08 != 0x00)
			edx_1074 = (struct Eq_134638 *) &g_t8138A00;
		else
		{
			eax_1069.u0 = 0x00;
			edx_1074 = null;
		}
		edx_1074->ptr0084();
		Eq_662 xmm1_1105;
		Eq_662 xmm0_1104 = fmt.(*fmt).fmt_s(gs, (word32) dwArg04 + 32, dwLoc34, dwLoc30, out xmm1_1105);
		xmm1Out = xmm1_1105;
		return xmm0_1104;
	}
	if (dwArg10 == 0x70)
	{
		reflect.ValueOf(gs, dwArg08, dwArg0C);
		fmt.(*pp).fmtPointer(dwArg04, gs, dwArg04, dwLoc30, dwLoc2C, dwLoc28, 0x70);
		xmm1Out = xmm1;
		return xmm0;
	}
	if (dwArg08 != 0x00)
	{
		Eq_4 esi_171 = *((word32) dwArg08 + 8);
		if (esi_171 <= 0xB0C23ED3)
		{
			if (esi_171 <= 0x500C1ABC)
			{
				if (esi_171 > 0x2EA27FFB)
				{
					if (esi_171 == 942571231)
					{
						Eq_4 ebx_715;
						Eq_4 ebp_716;
						if (dwArg08 == 0x080CA1C0)
						{
							ebx_715 = *((word32) dwArg0C + 4);
							ebp_716 = *dwArg0C;
						}
						else
						{
							ebx_715.u0 = 0x00;
							ebp_716.u0 = 0x00;
						}
						if (dwArg08 == 0x080CA1C0)
						{
							fmt.(*pp).fmtBytes(ebx, gs, dwArg04, ebp_716, ebx_715, dwArg10, 0x080E1154, 0x06);
							goto l080B9FDC;
						}
					}
					if (esi_171 == 0x500C1ABC)
					{
						Eq_4 ebx_754;
						Eq_4 esi_753;
						Eq_4 ebp_752;
						if (dwArg08 == 0x080E08C0)
						{
							ebx_754 = *dwArg0C;
							ebp_752 = *((word32) dwArg0C + 8);
							esi_753 = *((word32) dwArg0C + 4);
						}
						else
						{
							ebp_752.u0 = 0x00;
							esi_753.u0 = 0x00;
							ebx_754.u0 = 0x00;
						}
						if (dwArg08 == 0x080E08C0)
						{
							if (ebp_752 != 0x00)
							{
								reflect.Value.CanInterface(gs, ebp_752);
								if (bLoc2C_1392 != 0x00)
								{
									xmm0 = reflect.Value.Interface(gs, ebx_754, esi_753, ebp_752, out xmm1);
									*((word32) dwArg04 + 0x0C) = dwLoc2C;
									byte bLoc30_1426 = (byte) ebp_752;
									if (g_t81576F0 == 0x00)
										*((word32) dwArg04 + 16) = dwLoc28;
									else
										runtime.writebarrierptr((word32) dwArg04 + 16, dwLoc28);
									fmt.(*pp).handleMethods(gs, dwArg04, dwArg10);
									if (bLoc30_1426 != 0x00)
									{
										xmm1Out = xmm1;
										return xmm0;
									}
								}
							}
							fmt.(*pp).printValue(gs, dwArg04, ebx_754, esi_753, ebp_752, dwArg10, 0x00);
							goto l080B9FDC;
						}
					}
					goto l080B9FC7;
				}
				else
				{
					if (esi_171 == 0x13FF06C5)
					{
						uip32 ebx_2006;
						if (dwArg08 == 0x080CE760)
							ebx_2006 = (word32) *dwArg0C;
						else
							ebx_2006 = 0x00;
						byte bl_909 = (byte) ebx_2006;
						if (dwArg08 == 0x080CE760)
						{
							fmt.(*pp).fmtBool(gs, dwArg04, bl_909, dwArg10);
							goto l080B9FDC;
						}
					}
					if (esi_171 != 0x2EA27FFB)
						goto l080B9FC7;
					if (dwArg08 == 0x080CE860)
						xmm0.u0 = (uint128) *dwArg0C;
					else
						xmm0 = __xorps(xmm0, xmm0);
					if (dwArg08 != 0x080CE860)
						goto l080B9FC7;
					fmt.(*pp).fmtFloat(gs, dwArg04, (real64) xmm0, 0x40, dwArg10);
l080B9FDC:
					xmm1Out = xmm1;
					return xmm0;
				}
			}
			if (esi_171 <= 2032468620)
			{
				if (esi_171 == 1715356255)
				{
					uip32 ebx_2008;
					if (dwArg08 == 0x080CF320)
						ebx_2008 = (word32) *dwArg0C;
					else
						ebx_2008 = 0x00;
					byte bl_642 = (byte) ebx_2008;
					if (dwArg08 == 0x080CF320)
					{
						fmt.(*pp).fmtInteger(edx_24_8, ebx, ebp, edi, gs, dwArg04, (word32) bl_642, 0x00, dwArg10);
						goto l080B9FDC;
					}
				}
				if (esi_171 != 2032468620)
					goto l080B9FC7;
				if (dwArg08 == 0x080CE7E0)
				{
					xmm0.u0 = (uint128) *((word32) dwArg0C + 4);
					xmm1.u0 = (uint128) *dwArg0C;
				}
				else
				{
					xmm0 = __xorps(xmm0, xmm0);
					xmm1 = __xorps(xmm1, xmm1);
				}
				if (dwArg08 == 0x080CE7E0)
				{
					real64 v22_689 = (real64) (real32) xmm1;
					real64 v23_693 = (real64) (real32) xmm0;
					fmt.(*pp).fmtComplex(gs, dwArg04, v22_689, v23_693, 0x40, dwArg10);
					xmm1 = SEQ(SLICE(xmm1, word64, 64), v22_689);
					xmm0 = SEQ(SLICE(xmm0, word64, 64), v23_693);
					goto l080B9FDC;
				}
			}
			else
			{
				if (esi_171 == 2251394350)
				{
					Eq_4 ebx_526;
					if (dwArg08 == 135066336)
						ebx_526 = *dwArg0C;
					else
						ebx_526.u0 = 0x00;
					if (dwArg08 == 135066336)
					{
						fmt.(*pp).fmtInteger(edx_24_8, ebx, ebp, edi, gs, dwArg04, ebx_526, 0x00, dwArg10);
						goto l080B9FDC;
					}
				}
				if (esi_171 == ~0x69C06400)
				{
					Eq_4 ebx_557;
					if (dwArg08 == 0x080CEC20)
						ebx_557 = *dwArg0C;
					else
						ebx_557.u0 = 0x00;
					if (dwArg08 == 0x080CEC20)
					{
						fmt.(*pp).fmtInteger(edx_24_8, ebx, ebp, edi, gs, dwArg04, ebx_557, 0x01, dwArg10);
						goto l080B9FDC;
					}
				}
				if (esi_171 != 0xB0C23ED3)
					goto l080B9FC7;
				if (dwArg08 == 0x080CE820)
					xmm0.u0 = (uint128) *dwArg0C;
				else
					xmm0 = __xorps(xmm0, xmm0);
				if (dwArg08 == 0x080CE820)
				{
					real64 v28_615 = (real64) (real32) xmm0;
					fmt.(*pp).fmtFloat(gs, dwArg04, v28_615, 0x20, dwArg10);
					xmm0 = SEQ(SLICE(xmm0, word64, 64), v28_615);
					goto l080B9FDC;
				}
			}
		}
		else if (esi_171 <= 3494570045)
		{
			if (esi_171 <= 0xBBAD4102)
			{
				if (esi_171 == 3004847213)
				{
					if (dwArg08 == 0x080CE7A0)
					{
						xmm0.u0 = (uint128) *((word32) dwArg0C + 8);
						xmm1.u0 = (uint128) *dwArg0C;
					}
					else
					{
						xmm1 = __xorps(xmm1, xmm1);
						xmm0 = __xorps(xmm0, xmm0);
					}
					if (dwArg08 == 0x080CE7A0)
					{
						fmt.(*pp).fmtComplex(gs, dwArg04, (real64) xmm1, (real64) xmm0, 0x80, dwArg10);
						goto l080B9FDC;
					}
				}
				if (esi_171 != 0xBBAD4102)
					goto l080B9FC7;
				Eq_4 ebx_485;
				if (dwArg08 == 0x080CEBE0)
					ebx_485 = *dwArg0C;
				else
					ebx_485.u0 = 0x00;
				if (dwArg08 == 0x080CEBE0)
				{
					fmt.(*pp).fmtInteger(edx_24_8, ebx_485 >> 0x1F, ebp, edi, gs, dwArg04, ebx_485, 0x01, dwArg10);
					goto l080B9FDC;
				}
			}
			else
			{
				if (esi_171 == 3175798674)
				{
					Eq_4 ebx_345;
					if (dwArg08 == 0x080CF360)
						ebx_345 = *dwArg0C;
					else
						ebx_345.u0 = 0x00;
					if (dwArg08 == 0x080CF360)
					{
						fmt.(*pp).fmtInteger(edx_24_8, ebx, ebp, edi, gs, dwArg04, ebx_345, 0x00, dwArg10);
						goto l080B9FDC;
					}
				}
				if (esi_171 == 0xCC06C027)
				{
					uip32 ebx_2014;
					if (dwArg08 == 0x080CEC60)
						ebx_2014 = (word32) *dwArg0C;
					else
						ebx_2014 = 0x00;
					byte bl_384 = (byte) ebx_2014;
					if (dwArg08 == 0x080CEC60)
					{
						fmt.(*pp).fmtInteger(edx_24_8, ebx, ebp, edi, gs, dwArg04, (int32) bl_384, 0x01, dwArg10);
						goto l080B9FDC;
					}
				}
				if (esi_171 != 3494570045)
					goto l080B9FC7;
				Eq_4 ebx_412;
				if (dwArg08 == 0x080CF2A0)
					ebx_412 = *dwArg0C;
				else
					ebx_412.u0 = 0x00;
				if (dwArg08 == 0x080CF2A0)
				{
					fmt.(*pp).fmtInteger(edx_24_8, ebx, ebp, edi, gs, dwArg04, ebx_412, 0x00, dwArg10);
					goto l080B9FDC;
				}
			}
		}
		else if (esi_171 <= ~0x1F00A34B)
		{
			if (esi_171 == 3585636114)
			{
				Eq_4 ebx_284;
				if (dwArg08 == 0x080CF220)
					ebx_284 = *dwArg0C;
				else
					ebx_284.u0 = 0x00;
				if (dwArg08 == 0x080CF220)
				{
					fmt.(*pp).fmtInteger(edx_24_8, ebx, ebp, edi, gs, dwArg04, ebx_284, 0x00, dwArg10);
					goto l080B9FDC;
				}
			}
			if (esi_171 != ~0x1F00A34B)
				goto l080B9FC7;
			Eq_4 ebx_312;
			Eq_4 esi_311;
			if (dwArg08 == 135066016)
			{
				ebx_312 = *((word32) dwArg0C + 4);
				esi_311 = *dwArg0C;
			}
			else
			{
				esi_311.u0 = 0x00;
				ebx_312.u0 = 0x00;
			}
			if (dwArg08 == 135066016)
			{
				fmt.(*pp).fmtString(gs, dwArg04, esi_311, ebx_312, dwArg10);
				goto l080B9FDC;
			}
		}
		else
		{
			if (esi_171 == 0xECD580CE)
			{
				uipr32 ebx_184;
				if (dwArg08 == 0x080CEBA0)
					ebx_184 = (word32) *dwArg0C;
				else
					ebx_184 = 0x00;
				word16 bx_189 = (word16) ebx_184;
				if (dwArg08 == 0x080CEBA0)
				{
					fmt.(*pp).fmtInteger(edx_24_8, ebx, ebp, edi, gs, dwArg04, (int32) bx_189, 0x01, dwArg10);
					goto l080B9FDC;
				}
			}
			if (esi_171 == ~0x100DF15F)
			{
				uipr32 ebx_2012;
				if (dwArg08 == 0x080CF260)
					ebx_2012 = (word32) *dwArg0C;
				else
					ebx_2012 = 0x00;
				word16 bx_226 = (word16) ebx_2012;
				if (dwArg08 == 0x080CF260)
				{
					fmt.(*pp).fmtInteger(edx_24_8, ebx, ebp, edi, gs, dwArg04, (word32) bx_226, 0x00, dwArg10);
					goto l080B9FDC;
				}
			}
			if (esi_171 != 4149441018)
				goto l080B9FC7;
			Eq_4 ebx_251;
			if (dwArg08 == 0x080CEB60)
				ebx_251 = *dwArg0C;
			else
				ebx_251.u0 = 0x00;
			if (dwArg08 == 0x080CEB60)
			{
				fmt.(*pp).fmtInteger(edx_24_8, ebx_251 >> 0x1F, ebp, edi, gs, dwArg04, ebx_251, 0x01, dwArg10);
				goto l080B9FDC;
			}
		}
	}
l080B9FC7:
	fmt.(*pp).handleMethods(gs, dwArg04, dwArg10);
	if (bLoc30_1557 == 0x00)
	{
		reflect.ValueOf(gs, dwArg08, dwArg0C);
		fmt.(*pp).printValue(gs, dwArg04, dwLoc30, dwLoc2C, dwLoc28, dwArg10, 0x00);
	}
	goto l080B9FDC;
}

// 080BA7B0: void fmt.(*pp).printValue(Register (ptr32 Eq_2) gs, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C, Stack Eq_4 dwArg10, Stack Eq_4 dwArg14, Stack Eq_4 dwArg18)
// Called from:
//      fmt.(*pp).badVerb
//      fmt.(*pp).fmtBytes
//      fmt.(*pp).printArg
//      fmt.(*pp).printValue
void fmt.(*pp).printValue(struct Eq_2 * gs, Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C, Eq_4 dwArg10, Eq_4 dwArg14, Eq_4 dwArg18)
{
	byte bLoc0110 = (byte) rLoc0110;
	Eq_4 dwLoc010C = SLICE(rLoc0110, word32, 32);
	Eq_4 dwLoc0108_4295 = (word32) rLoc0108;
	Eq_4 dwLoc0104_4368 = SLICE(rLoc0108, word32, 32);
	while (fp - 0x9C <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	Eq_4 dwLoc010C_4254;
	Eq_4 dwLoc0110_4253;
	word24 nLoc010F_4260;
	byte bLoc0110_4274;
	struct Eq_135101 * esp_1179 = fp - 0x011C;
	if (dwArg18 > 0x00)
	{
		dwLoc0110_4253 = (word32) rLoc0110;
		dwLoc010C_4254 = dwLoc010C;
		nLoc010F_4260 = SLICE(dwLoc0110_4253, word24, 8);
		bLoc0110_4274 = (byte) dwLoc0110_4253;
		if (dwArg10 != 0x00)
		{
			reflect.Value.CanInterface(gs, dwArg10);
			Eq_4 dwLoc0110_4152 = (word32) rLoc0110;
			if (bLoc0110 != 0x00)
			{
				word128 xmm1_6334;
				reflect.Value.Interface(gs, dwArg08, dwArg0C, dwArg10, out xmm1_6334);
				*((word32) dwArg04 + 0x0C) = dwLoc0110_4152;
				byte bLoc0114_4174 = (byte) dwArg10;
				if (g_t81576F0 == 0x00)
					*((word32) dwArg04 + 16) = dwLoc010C;
				else
					runtime.writebarrierptr((word32) dwArg04 + 16, dwLoc010C);
				fmt.(*pp).handleMethods(gs, dwArg04, dwArg14);
				if (bLoc0114_4174 != 0x00)
					return;
			}
		}
	}
	((word32) dwArg04 + 0x0C)->u0 = 0x00;
	if (g_t81576F0 == 0x00)
		((word32) dwArg04 + 16)->u0 = 0x00;
	else
		runtime.writebarrierptr((word32) dwArg04 + 16, 0x00);
	*((word32) dwArg04 + 28) = dwArg10;
	if (g_t81576F0 == 0x00)
	{
		*((word32) dwArg04 + 20) = dwArg08;
		*((word32) dwArg04 + 24) = dwArg0C;
	}
	else
	{
		runtime.writebarrierptr((word32) dwArg04 + 20, dwArg08);
		runtime.writebarrierptr((word32) dwArg04 + 24, dwArg0C);
	}
	if ((dwArg10 & 0x1F) <= 0x10)
	{
		if ((dwArg10 & 0x1F) > 0x0C)
		{
			if ((dwArg10 & 0x1F) <= 0x0E)
			{
				if ((dwArg10 & 0x1F) == 0x0D)
				{
					reflect.Value.Float(gs, dwArg10);
					fmt.(*pp).fmtFloat(gs, dwArg04, (real64) (uint128) rLoc0110, 0x20, dwArg14);
				}
				else
				{
					reflect.Value.Float(gs, dwArg10);
					fmt.(*pp).fmtFloat(gs, dwArg04, (real64) (uint128) rLoc0110, 0x40, dwArg14);
				}
			}
			else if ((dwArg10 & 0x1F) == 0x0F)
			{
				reflect.Value.Complex(gs, dwArg10);
				fmt.(*pp).fmtComplex(gs, dwArg04, (real64) (uint128) rLoc0110, (real64) (uint128) rLoc0108, 0x40, dwArg14);
			}
			else
			{
				reflect.Value.Complex(gs, dwArg10);
				fmt.(*pp).fmtComplex(gs, dwArg04, (real64) (uint128) rLoc0110, (real64) (uint128) rLoc0108, 0x80, dwArg14);
			}
			return;
		}
		if ((dwArg10 & 0x1F) <= 0x01)
		{
			if ((dwArg10 & 0x1F) != 0x00)
			{
				reflect.Value.Bool(gs, dwArg10);
				fmt.(*pp).fmtBool(gs, dwArg04, bLoc0110_4274, dwArg14);
				return;
			}
			else if (dwArg18 != 0x00)
			{
				if (dwArg14 != 118)
				{
					fmt.(*pp).badVerb(gs, dwArg04, dwArg14);
					return;
				}
				else
				{
					Eq_4 eax_391 = *((word32) dwArg04 + 4);
					Eq_4 ebx_394 = *((word32) dwArg04 + 8);
					Eq_4 ebp_395 = *dwArg04;
					if ((word32) eax_391 + 5 > ebx_394)
					{
						word128 xmm0_6237;
						word32 esi_6236;
						word128 xmm1_6238;
						runtime.growslice(gs, 0x080CF320, ebp_395, eax_391, ebx_394, (word32) eax_391 + 5, out esi_6236, out xmm0_6237, out xmm1_6238);
						ebx_394 = dwLoc0100;
						ebp_395 = dwLoc0108_4295;
					}
					if ((word32) eax_391 + 5 > ebx_394)
						runtime.panicslice(gs);
					else
					{
						word32 ebp_6239;
						word128 xmm0_6242;
						word32 esi_6240;
						word32 edi_6241;
						word128 xmm1_6243;
						word128 xmm2_6244;
						runtime.memmove(eax_391 + ebp_395, 0x080E0FC5, 0x05, out ebp_6239, out esi_6240, out edi_6241, out xmm0_6242, out xmm1_6243, out xmm2_6244);
						*((word32) dwArg04 + 4) = (word32) eax_391 + 5;
						*((word32) dwArg04 + 8) = ebx_394;
						if (g_t81576F0 == 0x00)
							*dwArg04 = ebp_395;
						else
							runtime.writebarrierptr(dwArg04, ebp_395);
						return;
					}
				}
			}
			else
			{
				Eq_4 eax_488 = *((word32) dwArg04 + 4);
				Eq_4 ebx_491 = *((word32) dwArg04 + 8);
				Eq_4 ebp_492 = *dwArg04;
				if ((word32) eax_488 + 23 > ebx_491)
				{
					word128 xmm0_6203;
					word128 xmm1_6204;
					word32 esi_6202;
					runtime.growslice(gs, 0x080CF320, ebp_492, eax_488, ebx_491, (word32) eax_488 + 23, out esi_6202, out xmm0_6203, out xmm1_6204);
					ebx_491 = dwLoc0100;
					ebp_492 = dwLoc0108_4295;
				}
				if ((word32) eax_488 + 23 > ebx_491)
					runtime.panicslice(gs);
				else
				{
					word128 xmm2_6210;
					word128 xmm1_6209;
					word128 xmm0_6208;
					word32 edi_6207;
					word32 ebp_6205;
					word32 esi_6206;
					runtime.memmove(eax_488 + ebp_492, 0x080E380D, 0x17, out ebp_6205, out esi_6206, out edi_6207, out xmm0_6208, out xmm1_6209, out xmm2_6210);
					*((word32) dwArg04 + 4) = (word32) eax_488 + 23;
					*((word32) dwArg04 + 8) = ebx_491;
					if (g_t81576F0 == 0x00)
						*dwArg04 = ebp_492;
					else
						runtime.writebarrierptr(dwArg04, ebp_492);
					return;
				}
			}
		}
		if ((dwArg10 & 0x1F) <= 0x06)
		{
			reflect.Value.Int(gs, dwArg10);
			fmt.(*pp).fmtInteger(SLICE(dwArg04, word24, 8), ebx, ebp, edi, gs, dwArg04, dwLoc0110_4253, 0x01, dwArg14);
			return;
		}
		if ((dwArg10 & 0x1F) <= 0x0C)
		{
			reflect.Value.Uint(gs, dwArg10);
			fmt.(*pp).fmtInteger(SLICE(dwArg04, word24, 8), ebx, ebp, edi, gs, dwArg04, dwLoc0110_4253, 0x00, dwArg14);
			return;
		}
		goto l080BB330;
	}
	Eq_4 dwLoc0108_4588;
	Eq_4 dwLoc0104_4697;
	if ((dwArg10 & 0x1F) <= 0x15)
	{
		if ((dwArg10 & 0x1F) > 0x13)
		{
			if ((dwArg10 & 0x1F) == 0x14)
			{
				reflect.Value.Elem(gs, dwArg08, dwArg0C, dwArg10);
				dwLoc0108_4588 = (word32) rLoc0108;
				dwLoc0104_4697 = SLICE(rLoc0108, word32, 32);
				if (dwLoc0108_4295 != 0x00)
				{
					fmt.(*pp).printValue(gs, dwArg04, dwLoc0110_4253, dwLoc010C, dwLoc0108_4295, dwArg14, (word32) dwArg18 + 1);
					return;
				}
				else if (*((word32) dwArg04 + 44) != 0x00)
				{
					reflect.Value.Type(gs, dwArg08, dwArg10);
					Eq_4 ecx_1663 = *((word32) dwLoc0110_4253 + 0x0084);
					ecx_1663();
					Eq_4 ebx_1672 = *((word32) dwArg04 + 4);
					word32 ebp_1673 = dwArg10 + ebx_1672;
					Eq_4 esi_1675 = *((word32) dwArg04 + 8);
					Eq_4 edi_1676 = *dwArg04;
					if (ebp_1673 > esi_1675)
					{
						word32 esi_6307;
						word128 xmm0_6308;
						word128 xmm1_6309;
						runtime.growslice(gs, 0x080CF320, edi_1676, ebx_1672, esi_1675, ebp_1673, out esi_6307, out xmm0_6308, out xmm1_6309);
						esi_1675 = dwLoc0100;
						edi_1676 = dwLoc0108_4588;
					}
					if (ebp_1673 > esi_1675)
						runtime.panicslice(gs);
					else
					{
						word128 xmm2_6315;
						word128 xmm1_6314;
						word32 edi_6312;
						word128 xmm0_6313;
						word32 esi_6311;
						word32 ebp_6310;
						runtime.memmove(edi_1676 + ebx_1672, dwArg0C, dwArg10, out ebp_6310, out esi_6311, out edi_6312, out xmm0_6313, out xmm1_6314, out xmm2_6315);
						*((word32) dwArg04 + 4) = ebp_1673;
						*((word32) dwArg04 + 8) = esi_1675;
						if (g_t81576F0 == 0x00)
							*dwArg04 = edi_1676;
						else
							runtime.writebarrierptr(dwArg04, edi_1676);
						Eq_4 eax_1787 = edi_1676;
						Eq_4 edx_1777 = *((word32) dwArg04 + 4);
						Eq_4 ebp_1781 = *((word32) dwArg04 + 8);
						if ((word32) edx_1777 + 5 > ebp_1781)
						{
							word32 esi_6316;
							word128 xmm1_6318;
							word128 xmm0_6317;
							runtime.growslice(gs, 0x080CF320, edi_1676, edx_1777, ebp_1781, (word32) edx_1777 + 5, out esi_6316, out xmm0_6317, out xmm1_6318);
							ebp_1781 = dwLoc0100;
							eax_1787 = dwLoc0108_4588;
						}
						if ((word32) edx_1777 + 5 > ebp_1781)
							runtime.panicslice(gs);
						else
						{
							word32 ebp_6319;
							word32 esi_6320;
							word32 edi_6321;
							word128 xmm0_6322;
							word128 xmm1_6323;
							word128 xmm2_6324;
							runtime.memmove(eax_1787 + edx_1777, 0x080E0FB1, 0x05, out ebp_6319, out esi_6320, out edi_6321, out xmm0_6322, out xmm1_6323, out xmm2_6324);
							*((word32) dwArg04 + 4) = (word32) edx_1777 + 5;
							*((word32) dwArg04 + 8) = ebp_1781;
							if (g_t81576F0 == 0x00)
								*dwArg04 = eax_1787;
							else
								runtime.writebarrierptr(dwArg04, eax_1787);
							return;
						}
					}
				}
				else
				{
					Eq_4 ecx_1875 = *((word32) dwArg04 + 4);
					Eq_4 ebx_1878 = *((word32) dwArg04 + 8);
					Eq_4 ebp_1879 = *dwArg04;
					if ((word32) ecx_1875 + 5 > ebx_1878)
					{
						word32 esi_6298;
						word128 xmm0_6299;
						word128 xmm1_6300;
						runtime.growslice(gs, 0x080CF320, ebp_1879, ecx_1875, ebx_1878, (word32) ecx_1875 + 5, out esi_6298, out xmm0_6299, out xmm1_6300);
						ebx_1878 = dwLoc0100;
						ebp_1879 = dwLoc0108_4588;
					}
					if ((word32) ecx_1875 + 5 > ebx_1878)
						runtime.panicslice(gs);
					else
					{
						word32 ebp_6301;
						word32 esi_6302;
						word32 edi_6303;
						word128 xmm1_6305;
						word128 xmm0_6304;
						word128 xmm2_6306;
						runtime.memmove(ebp_1879 + ecx_1875, 0x080E0FC5, 0x05, out ebp_6301, out esi_6302, out edi_6303, out xmm0_6304, out xmm1_6305, out xmm2_6306);
						*((word32) dwArg04 + 4) = (word32) ecx_1875 + 5;
						*((word32) dwArg04 + 8) = ebx_1878;
						if (g_t81576F0 == 0x00)
							*dwArg04 = ebp_1879;
						else
							runtime.writebarrierptr(dwArg04, ebp_1879);
						return;
					}
				}
			}
			else
			{
				if (*((word32) dwArg04 + 44) == 0x00)
				{
					Eq_4 ecx_2291 = *((word32) dwArg04 + 4);
					Eq_4 eax_2294 = *((word32) dwArg04 + 8);
					Eq_4 esi_2295 = *dwArg04;
					if ((word32) ecx_2291 + 4 > eax_2294)
					{
						word128 xmm1_6194;
						word128 xmm0_6193;
						word32 esi_6192;
						runtime.growslice(gs, 0x080CF320, esi_2295, ecx_2291, eax_2294, (word32) ecx_2291 + 4, out esi_6192, out xmm0_6193, out xmm1_6194);
						dwLoc0110_4253 = eax_2294;
						dwLoc010C_4254 = (word32) ecx_2291 + 4;
						esi_2295 = dwLoc0108_4588;
						eax_2294 = dwLoc0100;
					}
					if ((word32) ecx_2291 + 4 > eax_2294)
						runtime.panicslice(gs);
					word128 xmm1_6199;
					word128 xmm2_6200;
					word32 edi_6197;
					word32 ebp_6195;
					word128 xmm0_6198;
					word32 esi_6196;
					runtime.memmove(esi_2295 + ecx_2291, 135139130, 0x04, out ebp_6195, out esi_6196, out edi_6197, out xmm0_6198, out xmm1_6199, out xmm2_6200);
					*((word32) dwArg04 + 4) = (word32) ecx_2291 + 4;
					*((word32) dwArg04 + 8) = eax_2294;
					if (g_t81576F0 == 0x00)
						*dwArg04 = esi_2295;
					else
						runtime.writebarrierptr(dwArg04, esi_2295);
				}
				else
				{
					reflect.Value.Type(gs, dwArg08, dwArg10);
					Eq_4 ecx_1989 = *((word32) dwLoc0110_4253 + 0x0084);
					ecx_1989();
					Eq_4 ebx_1998 = *((word32) dwArg04 + 4);
					word32 ebp_1999 = dwArg10 + ebx_1998;
					Eq_4 esi_2001 = *dwArg04;
					dwLoc0110_4253 = *((word32) dwArg04 + 8);
					if (ebp_1999 > dwLoc0110_4253)
					{
						word128 xmm1_6288;
						word128 xmm0_6287;
						word32 esi_6286;
						runtime.growslice(gs, 0x080CF320, esi_2001, ebx_1998, dwLoc0110_4253, ebp_1999, out esi_6286, out xmm0_6287, out xmm1_6288);
						dwLoc010C_4254 = ebp_1999;
						dwLoc0110_4253 = dwLoc0100;
						esi_2001 = dwLoc0108_4588;
					}
					byte bLoc0110_4667 = (byte) dwLoc0110_4253;
					if (ebp_1999 > dwLoc0110_4253)
						runtime.panicslice(gs);
					word32 ebp_6289;
					word32 esi_6290;
					word32 edi_6291;
					word128 xmm0_6292;
					word128 xmm1_6293;
					word128 xmm2_6294;
					runtime.memmove(esi_2001 + ebx_1998, dwArg0C, dwArg10, out ebp_6289, out esi_6290, out edi_6291, out xmm0_6292, out xmm1_6293, out xmm2_6294);
					*((word32) dwArg04 + 4) = ebp_1999;
					*((word32) dwArg04 + 8) = dwLoc0110_4253;
					if (g_t81576F0 == 0x00)
						*dwArg04 = esi_2001;
					else
						runtime.writebarrierptr(dwArg04, esi_2001);
					reflect.Value.IsNil(gs, dwArg10);
					if (bLoc0110_4667 != 0x00)
					{
						Eq_4 ecx_2121 = *((word32) dwArg04 + 4);
						Eq_4 ebx_2124 = *((word32) dwArg04 + 8);
						Eq_4 ebp_2125 = *dwArg04;
						if ((word32) ecx_2121 + 5 > ebx_2124)
						{
							word32 esi_6325;
							word128 xmm0_6326;
							word128 xmm1_6327;
							runtime.growslice(gs, 0x080CF320, ebp_2125, ecx_2121, ebx_2124, (word32) ecx_2121 + 5, out esi_6325, out xmm0_6326, out xmm1_6327);
							ebp_2125 = dwLoc0108_4588;
							ebx_2124 = dwLoc0100;
						}
						if ((word32) ecx_2121 + 5 > ebx_2124)
							runtime.panicslice(gs);
						else
						{
							word32 ebp_6328;
							word32 edi_6330;
							word32 esi_6329;
							word128 xmm0_6331;
							word128 xmm1_6332;
							word128 xmm2_6333;
							runtime.memmove(ebp_2125 + ecx_2121, 0x080E0FB1, 0x05, out ebp_6328, out esi_6329, out edi_6330, out xmm0_6331, out xmm1_6332, out xmm2_6333);
							*((word32) dwArg04 + 4) = (word32) ecx_2121 + 5;
							*((word32) dwArg04 + 8) = ebx_2124;
							if (g_t81576F0 == 0x00)
								*dwArg04 = ebp_2125;
							else
								runtime.writebarrierptr(dwArg04, ebp_2125);
							return;
						}
					}
					Eq_4 ecx_2221 = *((word32) dwArg04 + 8);
					Eq_4 edx_2222 = *dwArg04;
					Eq_4 ebx_2223 = *((word32) dwArg04 + 4);
					if ((word32) ebx_2223 + 1 > ecx_2221)
					{
						word32 esi_6295;
						word128 xmm1_6297;
						word128 xmm0_6296;
						runtime.growslice(gs, 0x080CF320, edx_2222, ebx_2223, ecx_2221, (word32) ebx_2223 + 1, out esi_6295, out xmm0_6296, out xmm1_6297);
						*((word32) dwArg04 + 8) = dwLoc0100;
						dwLoc0110_4253 = ecx_2221;
						dwLoc010C_4254 = (word32) ebx_2223 + 1;
						if (g_t81576F0 == 0x00)
							*dwArg04 = dwLoc0108_4588;
						else
							runtime.writebarrierptr(dwArg04, dwLoc0108_4588);
						ebx_2223 = dwLoc0104_4697;
						edx_2222 = dwLoc0108_4588;
					}
					*((word32) dwArg04 + 4) = (word32) ebx_2223 + 1;
					Mem2290[edx_2222 + ebx_2223:byte] = 0x7B;
				}
				reflect.Value.MapKeys(gs, dwArg08, dwArg0C, dwArg10);
				Eq_4 ecx_2424 = dwLoc0110_4253;
				Eq_4 edx_2425 = 0x00;
				while (edx_2425 < dwLoc010C_4254)
				{
					Eq_4 ebx_2582 = *((word32) ecx_2424 + 8);
					Eq_4 ebp_2584 = *((word32) ecx_2424 + 4);
					Eq_4 esi_2586 = *ecx_2424;
					if (edx_2425 > 0x00)
					{
						if (*((word32) dwArg04 + 44) != 0x00)
						{
							Eq_4 eax_2671 = *((word32) dwArg04 + 4);
							Eq_4 ecx_2674 = *dwArg04;
							Eq_4 ebx_2675 = *((word32) dwArg04 + 8);
							if ((word32) eax_2671 + 2 > ebx_2675)
							{
								word32 esi_6211;
								word128 xmm0_6212;
								word128 xmm1_6213;
								runtime.growslice(gs, 0x080CF320, ecx_2674, eax_2671, ebx_2675, (word32) eax_2671 + 2, out esi_6211, out xmm0_6212, out xmm1_6213);
								ebx_2675 = dwLoc0100;
								ecx_2674 = dwLoc0108_4588;
							}
							if ((word32) eax_2671 + 2 > ebx_2675)
								runtime.panicslice(gs);
							word32 esi_6215;
							word32 ebp_6214;
							word128 xmm2_6219;
							word32 edi_6216;
							word128 xmm1_6218;
							word128 xmm0_6217;
							runtime.memmove(eax_2671 + ecx_2674, 0x080E0DB5, 0x02, out ebp_6214, out esi_6215, out edi_6216, out xmm0_6217, out xmm1_6218, out xmm2_6219);
							*((word32) dwArg04 + 4) = (word32) eax_2671 + 2;
							*((word32) dwArg04 + 8) = ebx_2675;
							if (g_t81576F0 == 0x00)
								*dwArg04 = ecx_2674;
							else
								runtime.writebarrierptr(dwArg04, ecx_2674);
						}
						else
						{
							Eq_4 eax_2597 = *((word32) dwArg04 + 4);
							Eq_4 edx_2598 = *dwArg04;
							Eq_4 ecx_2599 = *((word32) dwArg04 + 8);
							if ((word32) eax_2597 + 1 > ecx_2599)
							{
								word128 xmm0_6228;
								word32 esi_6227;
								word128 xmm1_6229;
								runtime.growslice(gs, 0x080CF320, edx_2598, eax_2597, ecx_2599, (word32) eax_2597 + 1, out esi_6227, out xmm0_6228, out xmm1_6229);
								*((word32) dwArg04 + 8) = dwLoc0100;
								if (g_t81576F0 == 0x00)
									*dwArg04 = dwLoc0108_4588;
								else
									runtime.writebarrierptr(dwArg04, dwLoc0108_4588);
								edx_2598 = dwLoc0108_4588;
								eax_2597 = dwLoc0104_4697;
							}
							*((word32) dwArg04 + 4) = (word32) eax_2597 + 1;
							Mem2669[edx_2598 + eax_2597:byte] = 0x20;
						}
					}
					fmt.(*pp).printValue(gs, dwArg04, esi_2586, ebp_2584, ebx_2582, dwArg14, (word32) dwArg18 + 1);
					Eq_4 ecx_2797 = *((word32) dwArg04 + 8);
					Eq_4 edx_2798 = *((word32) dwArg04 + 4);
					Eq_4 ebx_2799 = *dwArg04;
					if ((word32) edx_2798 + 1 > ecx_2797)
					{
						word32 esi_6221;
						word128 xmm0_6222;
						word128 xmm1_6223;
						runtime.growslice(gs, 0x080CF320, ebx_2799, edx_2798, ecx_2797, (word32) edx_2798 + 1, out esi_6221, out xmm0_6222, out xmm1_6223);
						*((word32) dwArg04 + 8) = dwLoc0100;
						if (g_t81576F0 == 0x00)
							*dwArg04 = (word32) dwArg18 + 1;
						else
							runtime.writebarrierptr(dwArg04, (word32) dwArg18 + 1);
						edx_2798 = dwLoc0104_4697;
						ebx_2799 = (word32) dwArg18 + 1;
					}
					*((word32) dwArg04 + 4) = (word32) edx_2798 + 1;
					Mem2869[ebx_2799 + edx_2798:byte] = 0x3A;
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					Eq_4 stackArg4 = <invalid>;
					reflect.Value.MapIndex(gs, stackArg4, dwArg10, esi_2586, ebp_2584, ebx_2582);
					fmt.(*pp).printValue(gs, dwArg04, dwLoc0104_4697, dwLoc0100, dwLocFC, dwArg14, (word32) dwArg18 + 1);
					dwLoc0108_4588 = (word32) dwArg18 + 1;
					ecx_2424 = (word32) ecx_2424 + 0x0C;
					edx_2425 = (word32) edx_2425 + 1;
				}
				if (*((word32) dwArg04 + 44) != 0x00)
				{
					Eq_4 ecx_2509 = *((word32) dwArg04 + 8);
					Eq_4 edx_2510 = *((word32) dwArg04 + 4);
					Eq_4 ebx_2511 = *dwArg04;
					if ((word32) edx_2510 + 1 > ecx_2509)
					{
						word32 esi_6230;
						word128 xmm1_6232;
						word128 xmm0_6231;
						runtime.growslice(gs, 0x080CF320, ebx_2511, edx_2510, ecx_2509, (word32) edx_2510 + 1, out esi_6230, out xmm0_6231, out xmm1_6232);
						*((word32) dwArg04 + 8) = dwLoc0100;
						if (g_t81576F0 == 0x00)
							*dwArg04 = dwLoc0108_4588;
						else
							runtime.writebarrierptr(dwArg04, dwLoc0108_4588);
						edx_2510 = dwLoc0104_4697;
						ebx_2511 = dwLoc0108_4588;
					}
					*((word32) dwArg04 + 4) = (word32) edx_2510 + 1;
					Mem2578[ebx_2511 + edx_2510:byte] = 0x7D;
				}
				else
				{
					Eq_4 ecx_2440 = *((word32) dwArg04 + 4);
					Eq_4 edx_2441 = *dwArg04;
					Eq_4 ebx_2442 = *((word32) dwArg04 + 8);
					if ((word32) ecx_2440 + 1 > ebx_2442)
					{
						word128 xmm1_6235;
						word32 esi_6233;
						word128 xmm0_6234;
						runtime.growslice(gs, 0x080CF320, edx_2441, ecx_2440, ebx_2442, (word32) ecx_2440 + 1, out esi_6233, out xmm0_6234, out xmm1_6235);
						*((word32) dwArg04 + 8) = dwLoc0100;
						if (g_t81576F0 == 0x00)
							*dwArg04 = dwLoc0108_4588;
						else
							runtime.writebarrierptr(dwArg04, dwLoc0108_4588);
						ecx_2440 = dwLoc0104_4697;
						edx_2441 = dwLoc0108_4588;
					}
					*((word32) dwArg04 + 4) = (word32) ecx_2440 + 1;
					Mem2508[edx_2441 + ecx_2440:byte] = 0x5D;
				}
				return;
			}
		}
		if ((dwArg10 & 0x1F) == 0x11)
		{
l080BA86B:
			if (dwArg14 <= 113)
			{
				if (dwArg14 != 88 && dwArg14 != 113)
					goto l080BAAF1;
			}
			else if (dwArg14 != 115 && dwArg14 != 0x78)
				goto l080BAAF1;
			reflect.Value.Type(gs, dwArg08, dwArg10);
			(*((word32) dwLoc0110_4253 + 44))();
			Eq_4 ecx_3027 = *((word32) dwArg0C + 84);
			ecx_3027();
			if (dwArg0C == 0x08)
			{
				Eq_4 dwLoc0118_5225;
				Eq_4 dwLoc0114_5226;
				Eq_4 edx_3928;
				Eq_4 ecx_3927;
				if ((dwArg10 & 0x1F) != 0x17)
				{
					if ((dwArg10 & 0x0100) == 0x00)
					{
						// Failed to bind call argument.
						// Please report this issue at https://github.com/uxmal/reko
						Eq_4 stackArg4 = <invalid>;
						reflect.Value.Len(gs, stackArg4, dwArg10);
						word32 edi_6146;
						runtime.makeslice(gs, 0x080CF320, dwLoc0110_4253, dwLoc0110_4253, out edi_6146);
						dwLoc0118_5225 = dwLoc0110_4253;
						dwLoc0114_5226 = dwLoc0110_4253;
						Eq_4 ebx_4015 = 0x00;
						while (true)
						{
							Eq_4 dwLoc0104_5298 = SLICE(rLoc0108, word32, 32);
							Eq_4 dwLoc0108_5299 = (word32) rLoc0108;
							edx_3928 = dwLoc0110_4253;
							ecx_3927 = dwLoc010C;
							if (ebx_4015 >= dwLoc010C)
								break;
							reflect.Value.Index(gs, dwArg08, dwArg0C, dwArg10, ebx_4015);
							reflect.Value.Uint(gs, dwLoc0104_5298);
							bLoc0110_4274 = (byte) ebx_4015;
							nLoc010F_4260 = SLICE(ebx_4015, word24, 8);
							dwLoc0118_5225 = dwLoc0108_5299;
							dwLoc0114_5226 = dwLoc0104_5298;
							byte al_4099 = (byte) ebx_4015;
							if (ebx_4015 >= dwLoc010C)
								runtime.panicindex(gs);
							Mem4100[dwLoc0110_4253 + ebx_4015:byte] = al_4099;
							ebx_4015 = (word32) ebx_4015 + 1;
						}
					}
					else
					{
						// Failed to bind call argument.
						// Please report this issue at https://github.com/uxmal/reko
						Eq_4 stackArg4 = <invalid>;
						reflect.Value.Len(gs, stackArg4, dwArg10);
						reflect.Value.Slice(gs, dwArg08, dwArg0C, dwArg10, 0x00, dwLoc0110_4253);
						reflect.Value.Bytes(gs, dwLoc0108_4588, dwLoc0104_4697, dwLoc0100);
						bLoc0110_4274 = 0x00;
						nLoc010F_4260 = 0x00;
						dwLoc010C_4254 = dwLoc0110_4253;
						dwLoc0118_5225 = dwLoc0104_4697;
						dwLoc0114_5226 = dwLoc0100;
						ecx_3927 = dwLoc0110_4253;
						edx_3928.u0 = 0x00;
					}
				}
				else
				{
					reflect.Value.Bytes(gs, dwArg08, dwArg0C, dwArg10);
					dwLoc0118_5225 = dwArg0C;
					dwLoc0114_5226 = dwArg10;
					ecx_3927 = dwLoc010C;
					edx_3928 = dwLoc0110_4253;
				}
				(*((word32) dwLoc0110_4253 + 0x0084))();
				fmt.(*pp).fmtBytes(ebx, gs, dwArg04, edx_3928, ecx_3927, dwArg14, dwLoc0118_5225, dwLoc0114_5226);
				return;
			}
l080BAAF1:
			if (*((word32) dwArg04 + 44) != 0x00)
			{
				reflect.Value.Type(gs, dwArg08, dwArg10);
				Eq_4 ecx_3061 = *((word32) dwLoc0110_4253 + 0x0084);
				ecx_3061();
				Eq_4 ebx_3071 = *((word32) dwArg04 + 4);
				word32 ebp_3072 = dwArg10 + ebx_3071;
				Eq_4 esi_3074 = *dwArg04;
				dwLoc0110_4253 = *((word32) dwArg04 + 8);
				if (ebp_3072 > dwLoc0110_4253)
				{
					word32 esi_6158;
					word128 xmm1_6160;
					word128 xmm0_6159;
					runtime.growslice(gs, 0x080CF320, esi_3074, ebx_3071, dwLoc0110_4253, ebp_3072, out esi_6158, out xmm0_6159, out xmm1_6160);
					dwLoc010C_4254 = ebp_3072;
					esi_3074 = dwLoc0108_4588;
					dwLoc0110_4253 = dwLoc0100;
				}
				byte bLoc0110_5027 = (byte) dwLoc0110_4253;
				if (ebp_3072 > dwLoc0110_4253)
					runtime.panicslice(gs);
				else
				{
					word32 ebp_6161;
					word32 esi_6162;
					word128 xmm0_6164;
					word32 edi_6163;
					word128 xmm1_6165;
					word128 xmm2_6166;
					runtime.memmove(esi_3074 + ebx_3071, dwArg0C, dwArg10, out ebp_6161, out esi_6162, out edi_6163, out xmm0_6164, out xmm1_6165, out xmm2_6166);
					*((word32) dwArg04 + 4) = ebp_3072;
					*((word32) dwArg04 + 8) = dwLoc0110_4253;
					if (g_t81576F0 == 0x00)
						*dwArg04 = esi_3074;
					else
						runtime.writebarrierptr(dwArg04, esi_3074);
					Eq_4 dwLoc0110_5053;
					if ((dwArg10 & 0x1F) == 0x17)
					{
						reflect.Value.IsNil(gs, dwArg10);
						dwLoc0110_5053 = dwLoc0110_4253;
						if (bLoc0110_5027 != 0x00)
						{
							Eq_4 ecx_3198 = *((word32) dwArg04 + 4);
							Eq_4 ebx_3201 = *((word32) dwArg04 + 8);
							Eq_4 ebp_3202 = *dwArg04;
							if ((word32) ecx_3198 + 5 > ebx_3201)
							{
								word128 xmm0_6184;
								word128 xmm1_6185;
								word32 esi_6183;
								runtime.growslice(gs, 0x080CF320, ebp_3202, ecx_3198, ebx_3201, (word32) ecx_3198 + 5, out esi_6183, out xmm0_6184, out xmm1_6185);
								ebx_3201 = dwLoc0100;
								ebp_3202 = dwLoc0108_4588;
							}
							if ((word32) ecx_3198 + 5 > ebx_3201)
								runtime.panicslice(gs);
							else
							{
								word128 xmm2_6191;
								word128 xmm0_6189;
								word128 xmm1_6190;
								word32 edi_6188;
								word32 ebp_6186;
								word32 esi_6187;
								runtime.memmove(ebp_3202 + ecx_3198, 0x080E0FB1, 0x05, out ebp_6186, out esi_6187, out edi_6188, out xmm0_6189, out xmm1_6190, out xmm2_6191);
								*((word32) dwArg04 + 4) = (word32) ecx_3198 + 5;
								*((word32) dwArg04 + 8) = ebx_3201;
								if (g_t81576F0 == 0x00)
									*dwArg04 = ebp_3202;
								else
									runtime.writebarrierptr(dwArg04, ebp_3202);
								return;
							}
						}
					}
					Eq_4 eax_3301 = *((word32) dwArg04 + 4);
					Eq_4 edx_3302 = *dwArg04;
					Eq_4 ebx_3303 = *((word32) dwArg04 + 8);
					if ((word32) eax_3301 + 1 > ebx_3303)
					{
						word128 xmm1_6169;
						word128 xmm0_6168;
						word32 esi_6167;
						runtime.growslice(gs, 0x080CF320, edx_3302, eax_3301, ebx_3303, (word32) eax_3301 + 1, out esi_6167, out xmm0_6168, out xmm1_6169);
						*((word32) dwArg04 + 8) = dwLoc0100;
						dwLoc0110_5053 = ebx_3303;
						dwLoc010C_4254 = (word32) eax_3301 + 1;
						if (g_t81576F0 == 0x00)
							*dwArg04 = dwLoc0108_4588;
						else
							runtime.writebarrierptr(dwArg04, dwLoc0108_4588);
						edx_3302 = dwLoc0108_4588;
						eax_3301 = dwLoc0104_4697;
					}
					*((word32) dwArg04 + 4) = (word32) eax_3301 + 1;
					Mem3371[edx_3302 + eax_3301:byte] = 0x7B;
					Eq_4 eax_3372 = 0x00;
					while (true)
					{
						// Failed to bind call argument.
						// Please report this issue at https://github.com/uxmal/reko
						Eq_4 stackArg4 = <invalid>;
						reflect.Value.Len(gs, stackArg4, dwArg10);
						if (eax_3372 >= dwLoc0110_5053)
							break;
						if (eax_3372 > 0x00)
						{
							Eq_4 edx_3470 = *((word32) dwArg04 + 4);
							Eq_4 ebp_3473 = *((word32) dwArg04 + 8);
							Eq_4 esi_3474 = *dwArg04;
							if ((word32) edx_3470 + 2 > ebp_3473)
							{
								word128 xmm0_6172;
								word128 xmm1_6173;
								word32 esi_6171;
								runtime.growslice(gs, 0x080CF320, esi_3474, edx_3470, ebp_3473, (word32) edx_3470 + 2, out esi_6171, out xmm0_6172, out xmm1_6173);
								dwLoc010C_4254 = (word32) edx_3470 + 2;
								ebp_3473 = dwLoc0100;
								esi_3474 = dwLoc0108_4588;
							}
							if ((word32) edx_3470 + 2 > ebp_3473)
								runtime.panicslice(gs);
							word128 xmm2_6179;
							word32 edi_6176;
							word32 ebp_6174;
							word32 esi_6175;
							word128 xmm1_6178;
							word128 xmm0_6177;
							runtime.memmove(esi_3474 + edx_3470, 0x080E0DB5, 0x02, out ebp_6174, out esi_6175, out edi_6176, out xmm0_6177, out xmm1_6178, out xmm2_6179);
							*((word32) dwArg04 + 4) = (word32) edx_3470 + 2;
							*((word32) dwArg04 + 8) = ebp_3473;
							if (g_t81576F0 == 0x00)
								*dwArg04 = esi_3474;
							else
								runtime.writebarrierptr(dwArg04, esi_3474);
						}
						reflect.Value.Index(gs, dwArg08, dwArg0C, dwArg10, eax_3372);
						fmt.(*pp).printValue(gs, dwArg04, dwLoc010C_4254, dwLoc0108_4588, dwLoc0104_4697, dwArg14, (word32) dwArg18 + 1);
						dwLoc0110_5053 = dwLoc0104_4697;
						dwLoc010C_4254 = dwArg14;
						dwLoc0108_4588 = (word32) dwArg18 + 1;
						eax_3372 = (word32) eax_3372 + 1;
					}
					Eq_4 ecx_3397 = *((word32) dwArg04 + 8);
					Eq_4 edx_3398 = *((word32) dwArg04 + 4);
					Eq_4 ebx_3399 = *dwArg04;
					if ((word32) edx_3398 + 1 > ecx_3397)
					{
						word32 esi_6180;
						word128 xmm1_6182;
						word128 xmm0_6181;
						runtime.growslice(gs, 0x080CF320, ebx_3399, edx_3398, ecx_3397, (word32) edx_3398 + 1, out esi_6180, out xmm0_6181, out xmm1_6182);
						*((word32) dwArg04 + 8) = dwLoc0100;
						if (g_t81576F0 == 0x00)
							*dwArg04 = dwLoc0108_4588;
						else
							runtime.writebarrierptr(dwArg04, dwLoc0108_4588);
						edx_3398 = dwLoc0104_4697;
						ebx_3399 = dwLoc0108_4588;
					}
					*((word32) dwArg04 + 4) = (word32) edx_3398 + 1;
					Mem3466[ebx_3399 + edx_3398:byte] = 0x7D;
					return;
				}
			}
			else
			{
				Eq_4 ecx_3611 = *((word32) dwArg04 + 8);
				Eq_4 edx_3612 = *((word32) dwArg04 + 4);
				Eq_4 ebx_3613 = *dwArg04;
				if ((word32) edx_3612 + 1 > ecx_3611)
				{
					word128 xmm0_6149;
					word128 xmm1_6150;
					word32 esi_6148;
					runtime.growslice(gs, 0x080CF320, ebx_3613, edx_3612, ecx_3611, (word32) edx_3612 + 1, out esi_6148, out xmm0_6149, out xmm1_6150);
					*((word32) dwArg04 + 8) = dwLoc0100;
					dwLoc0110_4253 = ecx_3611;
					dwLoc010C_4254 = (word32) edx_3612 + 1;
					if (g_t81576F0 == 0x00)
						*dwArg04 = dwLoc0108_4588;
					else
						runtime.writebarrierptr(dwArg04, dwLoc0108_4588);
					edx_3612 = dwLoc0104_4697;
					ebx_3613 = dwLoc0108_4588;
				}
				*((word32) dwArg04 + 4) = (word32) edx_3612 + 1;
				Mem3680[ebx_3613 + edx_3612:byte] = 0x5B;
				Eq_4 ecx_3681 = 0x00;
				while (true)
				{
					// Failed to bind call argument.
					// Please report this issue at https://github.com/uxmal/reko
					Eq_4 stackArg4 = <invalid>;
					reflect.Value.Len(gs, stackArg4, dwArg10);
					if (ecx_3681 >= dwLoc0110_4253)
						break;
					if (ecx_3681 > 0x00)
					{
						Eq_4 edx_3792 = *((word32) dwArg04 + 4);
						Eq_4 ebx_3793 = *dwArg04;
						Eq_4 ebp_3794 = *((word32) dwArg04 + 8);
						if ((word32) edx_3792 + 1 > ebp_3794)
						{
							word32 esi_6152;
							word128 xmm0_6153;
							word128 xmm1_6154;
							runtime.growslice(gs, 0x080CF320, ebx_3793, edx_3792, ebp_3794, (word32) edx_3792 + 1, out esi_6152, out xmm0_6153, out xmm1_6154);
							*((word32) dwArg04 + 8) = dwLoc0100;
							dwLoc010C_4254 = (word32) edx_3792 + 1;
							if (g_t81576F0 == 0x00)
								*dwArg04 = dwLoc0108_4588;
							else
								runtime.writebarrierptr(dwArg04, dwLoc0108_4588);
							edx_3792 = dwLoc0104_4697;
							ebx_3793 = dwLoc0108_4588;
						}
						*((word32) dwArg04 + 4) = (word32) edx_3792 + 1;
						Mem3862[ebx_3793 + edx_3792:byte] = 0x20;
					}
					reflect.Value.Index(gs, dwArg08, dwArg0C, dwArg10, ecx_3681);
					fmt.(*pp).printValue(gs, dwArg04, dwLoc010C_4254, dwLoc0108_4588, dwLoc0104_4697, dwArg14, (word32) dwArg18 + 1);
					dwLoc0110_4253 = dwLoc0104_4697;
					dwLoc010C_4254 = dwArg14;
					dwLoc0108_4588 = (word32) dwArg18 + 1;
					ecx_3681 = (word32) ecx_3681 + 1;
				}
				Eq_4 ecx_3706 = *((word32) dwArg04 + 8);
				Eq_4 edx_3707 = *((word32) dwArg04 + 4);
				Eq_4 ebx_3708 = *dwArg04;
				if ((word32) edx_3707 + 1 > ecx_3706)
				{
					word32 esi_6155;
					word128 xmm0_6156;
					word128 xmm1_6157;
					runtime.growslice(gs, 0x080CF320, ebx_3708, edx_3707, ecx_3706, (word32) edx_3707 + 1, out esi_6155, out xmm0_6156, out xmm1_6157);
					*((word32) dwArg04 + 8) = dwLoc0100;
					if (g_t81576F0 == 0x00)
						*dwArg04 = dwLoc0108_4588;
					else
						runtime.writebarrierptr(dwArg04, dwLoc0108_4588);
					edx_3707 = dwLoc0104_4697;
					ebx_3708 = dwLoc0108_4588;
				}
				*((word32) dwArg04 + 4) = (word32) edx_3707 + 1;
				Mem3775[ebx_3708 + edx_3707:byte] = 0x5D;
				return;
			}
		}
		if ((dwArg10 & 0x1F) <= 0x13)
		{
l080BB30C:
			fmt.(*pp).fmtPointer(dwArg08, gs, dwArg04, dwArg08, dwArg0C, dwArg10, dwArg14);
			return;
		}
l080BB330:
		fmt.(*pp).unknownType(gs, dwArg04, dwArg08, dwArg0C, dwArg10);
		return;
	}
	if ((dwArg10 & 0x1F) > 0x17)
	{
		if ((dwArg10 & 0x1F) == 0x18)
		{
			reflect.Value.String(gs, dwArg08, dwArg0C, dwArg10);
			fmt.(*pp).fmtString(gs, dwArg04, dwLoc0110_4253, dwLoc010C, dwArg14);
			return;
		}
		if ((dwArg10 & 0x1F) == 0x19)
		{
			if (*((word32) dwArg04 + 44) != 0x00)
			{
				reflect.Value.Type(gs, dwArg08, dwArg10);
				Eq_4 ecx_647 = *((word32) dwLoc0110_4253 + 0x0084);
				ecx_647();
				Eq_4 ebx_656 = *((word32) dwArg04 + 4);
				word32 ebp_657 = dwArg10 + ebx_656;
				Eq_4 esi_659 = *dwArg04;
				Eq_4 edi_660 = *((word32) dwArg04 + 8);
				if (ebp_657 > edi_660)
				{
					word32 esi_6277;
					word128 xmm0_6278;
					word128 xmm1_6279;
					runtime.growslice(gs, 0x080CF320, esi_659, ebx_656, edi_660, ebp_657, out esi_6277, out xmm0_6278, out xmm1_6279);
					bLoc0110_4274 = (byte) edi_660;
					nLoc010F_4260 = SLICE(edi_660, word24, 8);
					dwLoc010C_4254 = ebp_657;
					edi_660 = dwLoc0100;
					esi_659 = dwLoc0108_4295;
				}
				if (ebp_657 > edi_660)
					runtime.panicslice(gs);
				word32 ebp_6280;
				word32 edi_6282;
				word32 esi_6281;
				word128 xmm2_6285;
				word128 xmm1_6284;
				word128 xmm0_6283;
				runtime.memmove(esi_659 + ebx_656, dwArg0C, dwArg10, out ebp_6280, out esi_6281, out edi_6282, out xmm0_6283, out xmm1_6284, out xmm2_6285);
				*((word32) dwArg04 + 4) = ebp_657;
				*((word32) dwArg04 + 8) = edi_660;
				if (g_t81576F0 == 0x00)
					*dwArg04 = esi_659;
				else
					runtime.writebarrierptr(dwArg04, esi_659);
			}
			Eq_4 ecx_768 = *((word32) dwArg04 + 8);
			Eq_4 edi_769 = *((word32) dwArg04 + 4);
			Eq_4 eax_770 = *dwArg04;
			if ((word32) edi_769 + 1 > ecx_768)
			{
				word32 esi_6246;
				word128 xmm0_6247;
				word128 xmm1_6248;
				runtime.growslice(gs, 0x080CF320, eax_770, edi_769, ecx_768, (word32) edi_769 + 1, out esi_6246, out xmm0_6247, out xmm1_6248);
				*((word32) dwArg04 + 8) = dwLoc0100;
				bLoc0110_4274 = (byte) ecx_768;
				nLoc010F_4260 = SLICE(ecx_768, word24, 8);
				dwLoc010C_4254 = (word32) edi_769 + 1;
				if (g_t81576F0 == 0x00)
					*dwArg04 = dwLoc0108_4295;
				else
					runtime.writebarrierptr(dwArg04, dwLoc0108_4295);
				eax_770 = dwLoc0108_4295;
				edi_769 = dwLoc0104_4368;
			}
			*((word32) dwArg04 + 4) = (word32) edi_769 + 1;
			Mem842[eax_770 + edi_769:byte] = 0x7B;
			Eq_4 ebp_1417 = dwArg0C;
			Eq_4 ebx_1416 = dwArg08;
			word32 ecx_1415 = 0x00;
			while (true)
			{
				esp_1179[24] = (struct Eq_135101) ecx_1415;
				esp_1179->t0000 = ebx_1416;
				esp_1179[1] = (struct Eq_135101) ebp_1417;
				esp_1179[2] = esp_1179[75];
				reflect.Value.NumField(gs, esp_1179[2]);
				int32 ecx_867 = esp_1179[24];
				if (ecx_867 >= esp_1179[3])
					break;
				Eq_4 ecx_1021;
				if (ecx_867 > 0x00)
				{
					Eq_4 eax_1013 = esp_1179[72];
					if (*((word32) eax_1013 + 44) != 0x00)
					{
						Eq_136540 edx_1022 = *((word32) eax_1013 + 4);
						esp_1179[0x0022] = (struct Eq_135101) ((word32) edx_1022.u1 + 2);
						Eq_4 ebx_1023 = (word32) edx_1022.u1 + 2;
						Eq_4 ebp_1025 = *((word32) eax_1013 + 8);
						ptr32 esi_1026 = *eax_1013;
						if ((word32) edx_1022.u1 + 2 > ebp_1025)
						{
							esp_1179[33] = (struct Eq_135101) edx_1022;
							esp_1179->t0000.u0 = 0x080CF320;
							esp_1179[1] = (struct Eq_135101) esi_1026;
							esp_1179[2] = (struct Eq_135101) edx_1022;
							esp_1179[3] = (struct Eq_135101) ebp_1025;
							esp_1179[4] = (struct Eq_135101) ((word32) edx_1022.u1 + 2);
							word32 esi_6249;
							word128 xmm0_6250;
							word128 xmm1_6251;
							runtime.growslice(gs, esp_1179->t0000, esp_1179[1], esp_1179[2], esp_1179[3], esp_1179[4], out esi_6249, out xmm0_6250, out xmm1_6251);
							ebp_1025 = esp_1179[7];
							esi_1026 = (ptr32) esp_1179[5];
							edx_1022 = esp_1179[33];
							ebx_1023 = esp_1179[0x0022];
						}
						if (ebx_1023 > ebp_1025)
							runtime.panicslice(gs);
						esp_1179[54] = (struct Eq_135101) esi_1026;
						esp_1179[33] = (struct Eq_135101) ebp_1025;
						esp_1179->t0000 = (word32) edx_1022 + esi_1026;
						esp_1179[1] = (struct Eq_135101) 0x080E0DB5;
						esp_1179[2] = (struct Eq_135101) 0x02;
						word32 edi_6254;
						word32 esi_6253;
						word32 ebp_6252;
						word128 xmm0_6255;
						word128 xmm1_6256;
						word128 xmm2_6257;
						runtime.memmove(esp_1179->t0000, esp_1179[1], esp_1179[2], out ebp_6252, out esi_6253, out edi_6254, out xmm0_6255, out xmm1_6256, out xmm2_6257);
						ecx_1021 = esp_1179[72];
						*((word32) ecx_1021 + 4) = esp_1179[0x0022];
						*((word32) ecx_1021 + 8) = esp_1179[33];
						if (g_t81576F0 == 0x00)
							*ecx_1021 = esp_1179[54];
						else
						{
							esp_1179->t0000 = ecx_1021;
							esp_1179[1] = esp_1179[54];
							runtime.writebarrierptr(esp_1179->t0000, esp_1179[1]);
							ecx_1021 = esp_1179[72];
						}
					}
					else
					{
						Eq_136540 edx_1008 = *((word32) eax_1013 + 4);
						ptr32 ebx_1010 = *eax_1013;
						Eq_4 ebp_952 = *((word32) eax_1013 + 8);
						if ((word32) edx_1008.u0 + 1 > ebp_952)
						{
							esp_1179->t0000.u0 = 0x080CF320;
							esp_1179[1] = (struct Eq_135101) ebx_1010;
							esp_1179[2] = (struct Eq_135101) edx_1008;
							esp_1179[3] = (struct Eq_135101) ebp_952;
							esp_1179[4] = (struct Eq_135101) ((word32) edx_1008.u0 + 1);
							word32 esi_6271;
							word128 xmm0_6272;
							word128 xmm1_6273;
							runtime.growslice(gs, esp_1179->t0000, esp_1179[1], esp_1179[2], esp_1179[3], esp_1179[4], out esi_6271, out xmm0_6272, out xmm1_6273);
							ptr32 eax_1003 = esp_1179[5];
							Eq_136540 ecx_1004 = esp_1179[6];
							Eq_4 ebx_985 = esp_1179[72];
							*((word32) ebx_985 + 8) = esp_1179[7];
							if (g_t81576F0 == 0x00)
								*ebx_985 = eax_1003;
							else
							{
								esp_1179[55] = (struct Eq_135101) eax_1003;
								esp_1179[31] = (struct Eq_135101) ecx_1004;
								esp_1179->t0000 = ebx_985;
								esp_1179[1] = (struct Eq_135101) eax_1003;
								runtime.writebarrierptr(esp_1179->t0000, esp_1179[1]);
								eax_1003 = (ptr32) esp_1179[55];
								ecx_1004 = esp_1179[31];
							}
							edx_1008 = ecx_1004;
							ebx_1010 = eax_1003;
							eax_1013 = esp_1179[72];
						}
						*((word32) eax_1013 + 4) = (word32) edx_1008.u0 + 1;
						*((word32) edx_1008.u0 + ebx_1010) = 0x20;
						ecx_1021 = eax_1013;
					}
				}
				else
					ecx_1021 = esp_1179[72];
				if (*((word32) ecx_1021 + 43) != 0x00 || *((word32) ecx_1021 + 44) != 0x00)
				{
					esp_1179->t0000 = esp_1179[73];
					esp_1179[1] = esp_1179[74];
					esp_1179[2] = esp_1179[75];
					reflect.Value.Type(gs, esp_1179->t0000, esp_1179[2]);
					Eq_4 eax_1154 = esp_1179[4];
					<anonymous> * ecx_1156 = *((word32) esp_1179[3].dw001C + 20);
					word32 edx_1157 = esp_1179[24];
					esp_1179[1] = (struct Eq_135101) edx_1157;
					esp_1179->t0000 = eax_1154;
					ecx_1156();
					fn0809021E(esp_1179[50], esp_1179 + 58);
					esp_1179 = (struct Eq_135101 *) ((char *) esp_1179 - 4);
					word32 eax_1180 = esp_1179[59];
					word32 ecx_1181 = esp_1179[58];
					if (eax_1180 != 0x00)
					{
						struct Eq_136791 * edx_1186 = esp_1179[72];
						word32 ebx_1187 = edx_1186->dw0004;
						struct Eq_136799 * ebp_1188 = eax_1180 + ebx_1187;
						esp_1179[0x0022] = (struct Eq_135101) ebp_1188;
						struct Eq_136799 * esi_1190 = edx_1186->ptr0008;
						word32 edi_1191 = edx_1186->dw0000;
						if (ebp_1188 > esi_1190)
						{
							esp_1179[33] = (struct Eq_135101) ebx_1187;
							esp_1179[0x0F] = (struct Eq_135101) eax_1180;
							esp_1179[42] = (struct Eq_135101) ecx_1181;
							esp_1179->t0000.u0 = 0x080CF320;
							esp_1179[1] = (struct Eq_135101) edi_1191;
							esp_1179[2] = (struct Eq_135101) ebx_1187;
							esp_1179[3] = (struct Eq_135101) esi_1190;
							esp_1179[4] = (struct Eq_135101) ebp_1188;
							word128 xmm0_6259;
							word128 xmm1_6260;
							word32 esi_6258;
							runtime.growslice(gs, esp_1179->t0000, esp_1179[1], esp_1179[2], esp_1179[3], esp_1179[4], out esi_6258, out xmm0_6259, out xmm1_6260);
							edi_1191 = (word32) esp_1179[5];
							esi_1190 = (struct Eq_136799 *) esp_1179[7];
							eax_1180 = (word32) esp_1179[0x0F];
							ecx_1181 = (word32) esp_1179[42];
							ebx_1187 = (word32) esp_1179[33];
							ebp_1188 = (struct Eq_136799 *) esp_1179[0x0022];
						}
						if (ebp_1188 > esi_1190)
							runtime.panicslice(gs);
						ptr32 eax_1286;
						esp_1179[54] = (struct Eq_135101) edi_1191;
						esp_1179[33] = (struct Eq_135101) esi_1190;
						esp_1179->t0000 = edi_1191 + ebx_1187;
						esp_1179[1] = (struct Eq_135101) ecx_1181;
						esp_1179[2] = (struct Eq_135101) eax_1180;
						word32 edi_6263;
						word32 ebp_6261;
						word128 xmm0_6264;
						word32 esi_6262;
						word128 xmm2_6266;
						word128 xmm1_6265;
						runtime.memmove(esp_1179->t0000, esp_1179[1], esp_1179[2], out ebp_6261, out esi_6262, out edi_6263, out xmm0_6264, out xmm1_6265, out xmm2_6266);
						Eq_4 ecx_1267 = esp_1179[72];
						*((word32) ecx_1267 + 4) = esp_1179[0x0022];
						*((word32) ecx_1267 + 8) = esp_1179[33];
						if (g_t81576F0 == 0x00)
						{
							eax_1286 = (ptr32) esp_1179[54];
							*ecx_1267 = eax_1286;
						}
						else
						{
							esp_1179->t0000 = ecx_1267;
							esp_1179[1] = esp_1179[54];
							runtime.writebarrierptr(esp_1179->t0000, esp_1179[1]);
							eax_1286 = (ptr32) esp_1179[54];
							ecx_1267 = esp_1179[72];
						}
						Eq_4 edx_1292 = *((word32) ecx_1267 + 8);
						int32 ebx_1293 = *((word32) ecx_1267 + 4);
						if (ebx_1293 + 0x01 > edx_1292)
						{
							esp_1179->t0000.u0 = 0x080CF320;
							esp_1179[1] = (struct Eq_135101) eax_1286;
							esp_1179[2] = (struct Eq_135101) ebx_1293;
							esp_1179[3] = (struct Eq_135101) edx_1292;
							esp_1179[4] = (struct Eq_135101) (ebx_1293 + 0x01);
							word32 esi_6267;
							word128 xmm1_6269;
							word128 xmm0_6268;
							runtime.growslice(gs, esp_1179->t0000, esp_1179[1], esp_1179[2], esp_1179[3], esp_1179[4], out esi_6267, out xmm0_6268, out xmm1_6269);
							eax_1286 = (ptr32) esp_1179[5];
							int32 ecx_1327 = esp_1179[6];
							Eq_4 ebx_1329 = esp_1179[72];
							*((word32) ebx_1329 + 8) = esp_1179[7];
							if (g_t81576F0 == 0x00)
								*ebx_1329 = eax_1286;
							else
							{
								esp_1179[56] = (struct Eq_135101) eax_1286;
								esp_1179[32] = (struct Eq_135101) ecx_1327;
								esp_1179->t0000 = ebx_1329;
								esp_1179[1] = (struct Eq_135101) eax_1286;
								runtime.writebarrierptr(esp_1179->t0000, esp_1179[1]);
								eax_1286 = (ptr32) esp_1179[56];
								ecx_1327 = (int32) esp_1179[32];
							}
							ebx_1293 = ecx_1327;
							ecx_1267 = esp_1179[72];
						}
						*((word32) ecx_1267 + 4) = ebx_1293 + 0x01;
						eax_1286 + ebx_1293 = (byte *) 0x3A;
					}
				}
				esp_1179->t0000 = esp_1179[73];
				esp_1179[1] = esp_1179[74];
				esp_1179[2] = esp_1179[75];
				esp_1179[3] = esp_1179[24];
				fmt.getField(gs, esp_1179->t0000, esp_1179[2], esp_1179[3]);
				struct Eq_137079 * eax_1397 = esp_1179[6];
				word32 ecx_1398 = esp_1179[5];
				word32 edx_1399 = esp_1179[4];
				esp_1179->t0000 = esp_1179[72];
				esp_1179[1] = (struct Eq_135101) edx_1399;
				esp_1179[2] = (struct Eq_135101) ecx_1398;
				esp_1179[3] = (struct Eq_135101) eax_1397;
				esp_1179[4] = esp_1179[76];
				esp_1179[5] = (struct Eq_135101) ((word32) esp_1179[77].t0000 + 1);
				// Failed to bind call argument.
				// Please report this issue at https://github.com/uxmal/reko
				Eq_4 stackArg4 = <invalid>;
				fmt.(*pp).printValue(gs, stackArg4, dwArg04, dwArg08, dwArg0C, dwArg10, dwArg14);
				ecx_1415 = (word32) esp_1179[24].t0000 + 1;
				ebx_1416 = esp_1179[73];
				ebp_1417 = esp_1179[74];
			}
			Eq_4 eax_870 = esp_1179[72];
			ptr32 ecx_871 = *eax_870;
			Eq_4 edx_872 = *((word32) eax_870 + 8);
			int32 ebx_873 = *((word32) eax_870 + 4);
			if (ebx_873 + 0x01 > edx_872)
			{
				esp_1179->t0000.u0 = 0x080CF320;
				esp_1179[1] = (struct Eq_135101) ecx_871;
				esp_1179[2] = (struct Eq_135101) ebx_873;
				esp_1179[3] = (struct Eq_135101) edx_872;
				esp_1179[4] = (struct Eq_135101) (ebx_873 + 0x01);
				word32 esi_6274;
				word128 xmm0_6275;
				word128 xmm1_6276;
				runtime.growslice(gs, esp_1179->t0000, esp_1179[1], esp_1179[2], esp_1179[3], esp_1179[4], out esi_6274, out xmm0_6275, out xmm1_6276);
				ptr32 eax_903 = esp_1179[5];
				int32 ecx_904 = esp_1179[6];
				Eq_4 ebx_906 = esp_1179[72];
				*((word32) ebx_906 + 8) = esp_1179[7];
				if (g_t81576F0 == 0x00)
					*ebx_906 = eax_903;
				else
				{
					esp_1179[52] = (struct Eq_135101) eax_903;
					esp_1179[30] = (struct Eq_135101) ecx_904;
					esp_1179->t0000 = ebx_906;
					esp_1179[1] = (struct Eq_135101) eax_903;
					runtime.writebarrierptr(esp_1179->t0000, esp_1179[1]);
					eax_903 = (ptr32) esp_1179[52];
					ecx_904 = (int32) esp_1179[30];
					ebx_906 = esp_1179[72];
				}
				eax_870 = ebx_906;
				ebx_873 = ecx_904;
				ecx_871 = eax_903;
			}
			*((word32) eax_870 + 4) = ebx_873 + 0x01;
			ecx_871 + ebx_873 = (byte *) 0x7D;
			return;
		}
		if ((dwArg10 & 0x1F) == 0x1A)
			goto l080BB30C;
		goto l080BB330;
	}
	if ((dwArg10 & 0x1F) != 22)
		goto l080BA86B;
	if (dwArg18 != 0x00)
		goto l080BB30C;
	// Failed to bind call argument.
	// Please report this issue at https://github.com/uxmal/reko
	Eq_4 stackArg4 = <invalid>;
	reflect.Value.Pointer(gs, stackArg4, dwArg10);
	if (dwLoc0110_4253 == 0x00)
		goto l080BB30C;
	reflect.Value.Elem(gs, dwArg08, dwArg0C, dwArg10);
	if ((dwLoc0108_4295 & 0x1F) <= 0x15)
	{
		if ((dwLoc0108_4295 & 0x1F) == 0x11 || (dwLoc0108_4295 & 0x1F) == 0x15)
		{
l080BBFEF:
			Eq_4 ebp_1488 = *((word32) dwArg04 + 4);
			Eq_4 esi_1489 = *((word32) dwArg04 + 8);
			Eq_4 edi_1490 = *dwArg04;
			if ((word32) ebp_1488 + 1 > esi_1489)
			{
				word32 esi_6224;
				word128 xmm0_6225;
				word128 xmm1_6226;
				runtime.growslice(gs, 0x080CF320, edi_1490, ebp_1488, esi_1489, (word32) ebp_1488 + 1, out esi_6224, out xmm0_6225, out xmm1_6226);
				*((word32) dwArg04 + 8) = dwLoc0100;
				if (g_t81576F0 == 0x00)
					*dwArg04 = dwLoc0108_4295;
				else
					runtime.writebarrierptr(dwArg04, dwLoc0108_4295);
				ebp_1488 = dwLoc0104_4368;
				edi_1490 = dwLoc0108_4295;
			}
			*((word32) dwArg04 + 4) = (word32) ebp_1488 + 1;
			Mem1565[edi_1490 + ebp_1488:byte] = 0x26;
			fmt.(*pp).printValue(gs, dwArg04, dwLoc0110_4253, dwLoc010C, dwLoc0108_4295, dwArg14, (word32) dwArg18 + 1);
			return;
		}
	}
	else if ((dwLoc0108_4295 & 0x1F) == 0x17 || (dwLoc0108_4295 & 0x1F) == 0x19)
		goto l080BBFEF;
	goto l080BB30C;
}

// 080BCE80: void fmt.(*pp).doPrintln(Register (ptr32 Eq_2) gs, Register Eq_662 xmm0, Register Eq_662 xmm1, Stack Eq_4 dwArg04, Stack (ptr32 Eq_131705) dwArg08, Stack int32 dwArg0C)
// Called from:
//      fmt.Fprintln
void fmt.(*pp).doPrintln(struct Eq_2 * gs, Eq_662 xmm0, Eq_662 xmm1, Eq_4 dwArg04, struct Eq_131705 * dwArg08, int32 dwArg0C)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	int32 eax_17;
	struct Eq_131705 * ecx_103 = dwArg08;
	for (eax_17 = 0x00; eax_17 < dwArg0C; ++eax_17)
	{
		Eq_4 ebx_105 = ecx_103->dw0004;
		Eq_4 ebp_106 = ecx_103->dw0000;
		if (eax_17 > 0x00)
		{
			Eq_4 edi_111 = *((word32) dwArg04 + 8);
			Eq_4 edx_112 = *dwArg04;
			Eq_4 eax_113 = *((word32) dwArg04 + 4);
			if ((word32) eax_113 + 1 > edi_111)
			{
				word32 esi_364;
				runtime.growslice(gs, 0x080CF320, edx_112, eax_113, edi_111, (word32) eax_113 + 1, out esi_364, out xmm0, out xmm1);
				*((word32) dwArg04 + 8) = dwLoc24;
				if (g_t81576F0 == 0x00)
					*dwArg04 = dwLoc2C;
				else
					runtime.writebarrierptr(dwArg04, dwLoc2C);
				edx_112 = dwLoc2C;
				eax_113 = dwLoc28;
			}
			*((word32) dwArg04 + 4) = (word32) eax_113 + 1;
			Mem184[edx_112 + eax_113:byte] = 0x20;
		}
		xmm0 = fmt.(*pp).printArg(gs, xmm0, xmm1, dwArg04, ebp_106, ebx_105, 118, out xmm1);
		++ecx_103;
	}
	Eq_4 ecx_28 = *((word32) dwArg04 + 8);
	Eq_4 edx_29 = *dwArg04;
	Eq_4 ebx_30 = *((word32) dwArg04 + 4);
	if ((word32) ebx_30 + 1 > ecx_28)
	{
		word128 xmm1_367;
		word128 xmm0_366;
		word32 esi_365;
		runtime.growslice(gs, 0x080CF320, edx_29, ebx_30, ecx_28, (word32) ebx_30 + 1, out esi_365, out xmm0_366, out xmm1_367);
		*((word32) dwArg04 + 8) = dwLoc24;
		if (g_t81576F0 == 0x00)
			*dwArg04 = dwLoc2C;
		else
			runtime.writebarrierptr(dwArg04, dwLoc2C);
		edx_29 = dwLoc2C;
		ebx_30 = dwLoc28;
	}
	*((word32) dwArg04 + 4) = (word32) ebx_30 + 1;
	Mem97[edx_29 + ebx_30:byte] = 0x0A;
}

// 080BD020: void fmt.glob..func1(Register (ptr32 Eq_2) gs)
void fmt.glob..func1(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	runtime.newobject(gs, 0x080D9C00);
}

// 080BD060: Register word32 fmt.init(Register (ptr32 Eq_2) gs)
// Called from:
//      main.init
word32 fmt.init(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	cu8 al_18 = g_b8157560;
	if (al_18 > 0x01)
		return esi;
	if (al_18 != 0x01)
	{
		g_b8157560 = 0x01;
		strconv.init(gs);
		io.init(gs);
		os.init(gs);
		reflect.init(gs);
		word32 esi_88;
		word32 edi_263;
		sync.init(gs, out esi_88, out edi_263);
		errors.New(gs, 0x080E5FD4, 0x24);
		g_dw8145010 = dwLoc08;
		if (g_t81576F0 == 0x00)
			g_t8145014 = dwLoc04;
		else
			runtime.writebarrierptr(0x08145014, dwLoc04);
		errors.New(gs, 0x080E4D0E, 0x1D);
		g_dw8145008 = dwLoc08;
		if (g_t81576F0 == 0x00)
			g_t814500C = dwLoc04;
		else
			runtime.writebarrierptr(0x0814500C, dwLoc04);
		g_b8157560 = 0x02;
		return esi_88;
	}
	else
		runtime.throwinit(gs);
}

// 080BD160: void type..hash.fmt.fmt(Register (ptr32 Eq_2) gs, Register Eq_4 mm0, Stack (ptr32 Eq_205) dwArg04, Stack (ptr32 Eq_205) dwArg08)
void type..hash.fmt.fmt(struct Eq_2 * gs, Eq_4 mm0, union Eq_205 * dwArg04, union Eq_205 * dwArg08)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	word128 xmm1_94;
	word128 xmm1_95;
	runtime.memhash(gs, runtime.memhash(gs, mm0, dwArg04, dwArg08, 0x0D, out xmm1_94), (char *) dwArg04 + 16, dwLoc04, 0x4C, out xmm1_95);
}

// 080BD1D0: void type..eq.fmt.fmt(Register (ptr32 Eq_138061) gs, Stack byte bArg00, Stack Eq_4 dwArg04, Stack Eq_4 dwArg08, Stack Eq_4 dwArg0C)
void type..eq.fmt.fmt(struct Eq_138061 * gs, byte bArg00, Eq_4 dwArg04, Eq_4 dwArg08, Eq_4 dwArg0C)
{
	while (fp <= ((gs->ptr0000)->ptrFFFFFFFC)->ptr0008)
		runtime.morestack_noctxt();
	uip32 ecx_125;
	struct Eq_138079 * esp_16 = fp - 0x10;
	Eq_4 eax_17 = dwArg04;
	Eq_4 edx_19 = dwArg08;
	if (*dwArg04 != *dwArg08)
		ecx_125 = 0x00;
	else
	{
		word32 ebx_127;
		word32 esi_128;
		word32 edi_129;
		runtime.memequal(dwArg08, (word32) dwArg04 + 4, (word32) dwArg08 + 4, 0x09, out ebx_127, out esi_128, out edi_129);
		esp_16 = fp - 0x0C;
		ecx_125 = (word32) bArg00;
		eax_17 = dwArg08;
		edx_19 = dwArg0C;
	}
	if ((byte) ecx_125 != 0x00)
	{
		esp_16->t0004 = (word32) edx_19 + 16;
		esp_16->t0000 = (word32) eax_17 + 16;
		esp_16->t0008.u0 = 0x4C;
		word32 ebx_130;
		word32 esi_131;
		word32 edi_132;
		runtime.memequal(edx_19, esp_16->t0000, esp_16->t0004, esp_16->t0008, out ebx_130, out esi_131, out edi_132);
	}
}

// 080BD260: void main.main(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.main
void main.main(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	fmt.Println(gs, fp - 0x08, 0x01, 0x01);
}

// 080BD2C0: Register word32 main.init(Register (ptr32 Eq_2) gs)
// Called from:
//      runtime.main
word32 main.init(struct Eq_2 * gs)
{
	while (fp <= *((word32) (gs->ptr0000)->tFFFFFFFC + 8))
		runtime.morestack_noctxt();
	cu8 al_17 = g_b8157563;
	if (al_17 > 0x01)
		return esi;
	if (al_17 != 0x01)
	{
		g_b8157563 = 0x01;
		word32 esi_28 = fmt.init(gs);
		g_b8157563 = 0x02;
		return esi_28;
	}
	else
		runtime.throwinit(gs);
}

