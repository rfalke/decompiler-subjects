/* This file was generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2020 Hex-Rays <info@hex-rays.com>

   Detected compiler: GNU C++
*/

#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

void __golang sync_atomic___ptr_Value__Load(sync_atomic_Value_0 *v, interface_{} x);
void __golang sync_atomic___ptr_Value__Store(sync_atomic_Value_0 *v, interface_{} x);
void __golang sync_atomic_CompareAndSwapInt32();
void __golang sync_atomic_CompareAndSwapUint32();
void __golang sync_atomic_CompareAndSwapUintptr();
void __golang sync_atomic_CompareAndSwapUint64();
void __golang sync_atomic_AddInt32();
void __golang sync_atomic_AddUint32();
void __golang sync_atomic_LoadUint32();
void __golang sync_atomic_LoadUint64();
void __golang sync_atomic_LoadUintptr();
void __golang sync_atomic_LoadPointer();
void __golang sync_atomic_StoreUint32();
void __golang sync_atomic_StoreUintptr();
uintptr __golang type__hash_sync_atomic_Value(sync_atomic_Value_0 *p, uintptr h);
bool __golang type__eq_sync_atomic_Value(sync_atomic_Value_0 *p, sync_atomic_Value_0 *q);
void __golang runtime_internal_sys_Ctz64();
uint32 __golang runtime_internal_atomic_Load(uint32 *ptr);
void *__golang runtime_internal_atomic_Loadp(void *ptr);
uint64 __golang runtime_internal_atomic_Xadd64(uint64 *ptr, int64 delta);
uint64 __golang runtime_internal_atomic_Xchg64(uint64 *ptr, uint64 new);
void __golang runtime_internal_atomic_Cas();
void __golang runtime_internal_atomic_Casuintptr();
void __golang runtime_internal_atomic_Loaduintptr();
void __golang runtime_internal_atomic_Loaduint();
void __golang runtime_internal_atomic_Storeuintptr();
void __golang runtime_internal_atomic_Xadduintptr();
void __golang runtime_internal_atomic_Loadint64();
void __golang runtime_internal_atomic_Xaddint64();
void __golang runtime_internal_atomic_Cas64();
void __golang runtime_internal_atomic_Casp1();
void __golang runtime_internal_atomic_Xadd();
void __golang runtime_internal_atomic_Xchg();
void __golang runtime_internal_atomic_Xchguintptr();
void __golang runtime_internal_atomic_StorepNoWB();
void __golang runtime_internal_atomic_Store();
void __golang runtime_internal_atomic_Load64();
void __golang runtime_internal_atomic_Store64();
void __golang runtime_internal_atomic_Or8();
void __golang runtime_internal_atomic_And8();
uintptr __golang runtime_memhash0(void *p, uintptr h);
uintptr __golang runtime_memhash8(void *p, uintptr h);
uintptr __golang runtime_memhash16(void *p, uintptr h);
uintptr __golang runtime_memhash32(void *p, uintptr h);
uintptr __golang runtime_memhash64(void *p, uintptr h);
uintptr __golang runtime_memhash128(void *p, uintptr h);
uintptr __golang runtime_strhash(void *a, uintptr h);
uintptr __golang runtime_f32hash(void *p, uintptr h);
uintptr __golang runtime_f64hash(void *p, uintptr h);
uintptr __golang runtime_c64hash(void *p, uintptr h);
uintptr __golang runtime_c128hash(void *p, uintptr h);
uintptr __golang runtime_interhash(void *p, uintptr h);
uintptr __golang runtime_nilinterhash(void *p, uintptr h);
bool __golang runtime_memequal0(void *p, void *q);
bool __golang runtime_memequal8(void *p, void *q);
bool __golang runtime_memequal16(void *p, void *q);
bool __golang runtime_memequal32(void *p, void *q);
bool __golang runtime_memequal64(void *p, void *q);
bool __golang runtime_memequal128(void *p, void *q);
bool __golang runtime_f32equal(void *p, void *q);
bool __golang runtime_f64equal(void *p, void *q);
bool __golang runtime_c64equal(void *p, void *q);
bool __golang runtime_c128equal(void *p, void *q);
bool __golang runtime_strequal(void *p, void *q);
bool __golang runtime_interequal(void *p, void *q);
bool __golang runtime_nilinterequal(void *p, void *q);
bool __golang runtime_efaceeq(runtime__type_0 *t, void *x, void *y);
bool __golang runtime_ifaceeq(runtime_itab_0 *tab, void *x, void *y);
void __golang runtime_alginit();
void __golang runtime_atomicstorep(void *ptr, void *new);
bool __golang runtime_casp(void **ptr, void *old, void *new);
void __golang sync_atomic_StorePointer(void **ptr, void *new);
bool __golang sync_atomic_CompareAndSwapPointer(void **ptr, void *old, void *new);
int32 __golang runtime_cgocall(void *fn, void *arg);
void __golang runtime_endcgo(runtime_m *mp);
void __golang runtime_cgocallbackg(uintptr ctxt);
void __golang runtime_cgocallbackg1(uintptr ctxt);
void __golang runtime_unwindm(bool *restore);
bool __golang runtime_cgoIsGoPointer(void *p);
void __golang runtime_cgoCheckWriteBarrier(uintptr *dst, uintptr src);
void __golang runtime_cgoCheckMemmove(runtime__type_0 *typ, void *dst, void *src, uintptr off, uintptr size);
void __golang runtime_cgoCheckSliceCopy(runtime__type_0 *typ, runtime_slice_0 dst, runtime_slice_0 src, __int32 n);
void __golang runtime_cgoCheckTypedBlock(runtime__type_0 *typ, void *src, uintptr off, uintptr size);
void __golang runtime_cgoCheckBits(void *src, uint8 *gcbits, uintptr off, uintptr size);
void __golang runtime_cgoCheckUsingType(runtime__type_0 *typ, void *src, uintptr off, uintptr size);
runtime_hchan *__golang runtime_makechan(runtime_chantype_0 *t, int64 size);
void __golang runtime_chansend1(runtime_hchan *c, void *elem);
bool __golang runtime_chansend(runtime_hchan *c, void *ep, bool block, uintptr callerpc);
void __golang runtime_send(runtime_hchan *c, runtime_sudog *sg, void *ep, func() unlockf, __int32 skip);
void __golang runtime_sendDirect(runtime__type_0 *t, runtime_sudog *sg, void *src);
void __golang runtime_recvDirect(runtime__type_0 *t, runtime_sudog *sg, void *dst);
void __golang runtime_closechan(runtime_hchan *c);
void __golang runtime_chanrecv1(runtime_hchan *c, void *elem);
void __golang runtime_chanrecv(runtime_hchan *c, void *ep, bool block, bool selected, bool received);
void __golang runtime_recv(runtime_hchan *c, runtime_sudog *sg, void *ep, func() unlockf, __int32 skip);
__int32 __golang reflect_chanlen(runtime_hchan *c);
runtime_sudog *__golang runtime___ptr_waitq__dequeue(runtime_waitq_0 *q);
void __golang runtime___ptr_cpuProfile__add(runtime_cpuProfile_0 *p, runtime_g *gp, __uintptr stk);
void __golang runtime___ptr_cpuProfile__addNonGo(runtime_cpuProfile_0 *p, __uintptr stk);
void __golang runtime___ptr_cpuProfile__addExtra(runtime_cpuProfile_0 *p);
__int32 __golang runtime_GOMAXPROCS(__int32 n);
string __golang runtime_gogetenv(string key);
string __golang runtime___ptr_TypeAssertionError__Error(runtime_TypeAssertionError *e);
string __golang runtime_errorString_Error(runtime_errorString e);
string __golang runtime_plainError_Error(runtime_plainError e);
string __golang runtime_typestring(interface_{} x);
void __golang runtime_printany(interface_{} i);
void __golang runtime_panicwrap();
void __golang runtime_Caller(__int32 skip, uintptr pc, string file, __int32 line, bool ok);
__int32 __golang runtime_Callers(__int32 skip, __uintptr pc);
string __golang runtime_GOROOT();
float64 __golang runtime_float64frombits(uint64 b);
uintptr __golang runtime_memhash(void *p, uintptr seed, uintptr s);
runtime_bmap *__golang runtime___ptr_hmap__newoverflow(runtime_hmap *h, runtime_maptype_0 *t, runtime_bmap *b);
runtime_hmap *__golang runtime_makemap(runtime_maptype_0 *t, int64 hint, runtime_hmap *h, void *bucket);
retval_804ED80 __golang runtime_mapaccess2(runtime_maptype_0 *t, runtime_hmap *h, void *key);
retval_804EF80 __golang runtime_mapaccessK(runtime_maptype_0 *t, runtime_hmap *h, void *key);
void *__golang runtime_mapassign(runtime_maptype_0 *t, runtime_hmap *h, void *key);
void __golang runtime_mapiterinit(runtime_maptype_0 *t, runtime_hmap *h, runtime_hiter *it);
void __golang runtime_mapiternext(runtime_hiter *it);
void __golang runtime_makeBucketArray(runtime_maptype_0 *t, uint8 b, void *buckets, runtime_bmap *nextOverflow);
void __golang runtime_hashGrow(runtime_maptype_0 *t, runtime_hmap *h);
void __golang runtime_growWork(runtime_maptype_0 *t, runtime_hmap *h, uintptr bucket);
void __golang runtime_evacuate(runtime_maptype_0 *t, runtime_hmap *h, uintptr oldbucket);
void *__golang reflect_mapaccess(runtime_maptype_0 *t, runtime_hmap *h, void *key);
runtime_hiter *__golang reflect_mapiterinit(runtime_maptype_0 *t, runtime_hmap *h);
void __golang reflect_mapiternext(runtime_hiter *it);
void *__golang reflect_mapiterkey(runtime_hiter *it);
__int32 __golang reflect_maplen(runtime_hmap *h);
void *__golang runtime_mapaccess1_fast32(runtime_maptype_0 *t, runtime_hmap *h, uint32 key);
retval_80511B0 __golang runtime_mapaccess2_fast32(runtime_maptype_0 *t, runtime_hmap *h, uint32 key);
retval_8051320 __golang runtime_mapaccess2_fast64(runtime_maptype_0 *t, runtime_hmap *h, uint64 key);
void *__golang runtime_mapassign_fast32(runtime_maptype_0 *t, runtime_hmap *h, uint32 key);
void *__golang runtime_mapassign_fast64(runtime_maptype_0 *t, runtime_hmap *h, uint64 key);
void *__golang runtime_mapassign_faststr(runtime_maptype_0 *t, runtime_hmap *h, string ky);
runtime_itab_0 *__golang runtime_getitab(runtime_interfacetype_0 *inter, runtime__type_0 *typ, bool canfail);
void __golang runtime_additab(runtime_itab_0 *m, bool locked, bool canfail);
void __golang runtime_itabsinit();
void __golang runtime_panicdottypeE(runtime__type_0 *have, runtime__type_0 *want, runtime__type_0 *iface);
void __golang runtime_panicdottypeI(runtime_itab_0 *have, runtime__type_0 *want, runtime__type_0 *iface);
void __golang runtime_convT2E(runtime__type_0 *t, void *elem, runtime_eface_0 e);
void __golang runtime_convT2E32(runtime__type_0 *t, void *elem, runtime_eface_0 e);
void __golang runtime_convT2Estring(runtime__type_0 *t, void *elem, runtime_eface_0 e);
void __golang runtime_convT2Eslice(runtime__type_0 *t, void *elem, runtime_eface_0 e);
void __golang runtime_convT2I32(runtime_itab_0 *tab, void *elem, runtime_iface_0 i);
void __golang runtime_assertE2I(runtime_interfacetype_0 *inter, runtime_eface_0 e, runtime_iface_0 r);
void __golang runtime_assertE2I2(runtime_interfacetype_0 *inter, runtime_eface_0 e, runtime_iface_0 r, bool b);
void __golang reflect_ifaceE2I(runtime_interfacetype_0 *inter, runtime_eface_0 e, runtime_iface_0 *dst);
void __golang runtime___ptr_lfstack__push(runtime_lfstack *head, runtime_lfnode_0 *node);
void *__golang runtime___ptr_lfstack__pop(runtime_lfstack *head);
bool __golang runtime___ptr_lfstack__empty(runtime_lfstack *head);
void __golang runtime_lock(runtime_mutex_0 *l);
void __golang runtime_unlock(runtime_mutex_0 *l);
void __golang runtime_notewakeup(runtime_note_0 *n);
void __golang runtime_notesleep(runtime_note_0 *n);
bool __golang runtime_notetsleep_internal(runtime_note_0 *n, int64 ns);
bool __golang runtime_notetsleep(runtime_note_0 *n, int64 ns);
bool __golang runtime_notetsleepg(runtime_note_0 *n, int64 ns);
void __golang runtime_mallocinit();
void *__golang runtime___ptr_mheap__sysAlloc(runtime_mheap_0 *h, uintptr n);
runtime_gclinkptr __golang runtime_nextFreeFast(runtime_mspan *s);
void __golang runtime___ptr_mcache__nextFree(runtime_mcache *c, runtime_spanClass spc, runtime_gclinkptr v, runtime_mspan *s, bool shouldhelpgc);
void *__golang runtime_mallocgc(uintptr size, runtime__type_0 *typ, bool needzero);
runtime_mspan *__golang runtime_largeAlloc(uintptr size, bool needzero, bool noscan);
void *__golang runtime_newobject(runtime__type_0 *typ);
void *__golang reflect_unsafe_New(runtime__type_0 *typ);
void *__golang runtime_newarray(runtime__type_0 *typ, __int32 n);
void __golang runtime_profilealloc(runtime_m *mp, void *x, uintptr size);
int32 __golang runtime_nextSample();
void *__golang runtime_persistentalloc(uintptr size, uintptr align, uint64 *sysStat);
void *__golang runtime_persistentalloc1(uintptr size, uintptr align, uint64 *sysStat);
void __golang runtime_gcmarkwb_m(uintptr *slot, uintptr ptr);
void __golang runtime_writebarrierptr_prewrite1(uintptr *dst, uintptr src);
void __golang runtime_writebarrierptr(uintptr *dst, uintptr src);
void __golang runtime_writebarrierptr_prewrite(uintptr *dst, uintptr src);
void __golang runtime_typedmemmove(runtime__type_0 *typ, void *dst, void *src);
void __golang reflect_typedmemmove(runtime__type_0 *typ, void *dst, void *src);
void __golang reflect_typedmemmovepartial(runtime__type_0 *typ, void *dst, void *src, uintptr off, uintptr size);
void __golang runtime_reflectcallmove(runtime__type_0 *typ, void *dst, void *src, uintptr size);
__int32 __golang runtime_typedslicecopy(runtime__type_0 *typ, runtime_slice_0 dst, runtime_slice_0 src);
void __golang runtime_typedmemclr(runtime__type_0 *typ, void *ptr);
void __golang runtime_memclrHasPointers(void *ptr, uintptr n);
void __golang runtime___ptr_mheap__mapBits(runtime_mheap_0 *h, uintptr arena_used);
void __golang runtime___ptr_mspan__refillAllocCache(runtime_mspan *s, uintptr whichByte);
uintptr __golang runtime___ptr_mspan__nextFreeIndex(runtime_mspan *s);
runtime_markBits_0 __golang runtime_markBitsForAddr(uintptr p);
void __golang runtime_markBits_setMarked(runtime_markBits_0 m);
void __golang runtime_heapBitsForSpan(uintptr base, runtime_heapBits_0 hbits);
void __golang runtime_heapBitsForObject(uintptr p, uintptr refBase, uintptr refOff, uintptr base, runtime_heapBits_0 hbits, runtime_mspan *s, uintptr objIndex);
void __golang runtime_heapBits_setCheckmarked(runtime_heapBits_0 h, uintptr size);
void __golang runtime_bulkBarrierPreWrite(uintptr dst, uintptr src, uintptr size);
void __golang runtime_bulkBarrierBitmap(uintptr dst, uintptr src, uintptr size, uintptr maskOffset, uint8 *bits);
void __golang runtime_typeBitsBulkBarrier(runtime__type_0 *typ, uintptr dst, uintptr src, uintptr size);
void __golang runtime_heapBits_initSpan(runtime_heapBits_0 h, runtime_mspan *s);
void __golang runtime_heapBits_initCheckmarkSpan(runtime_heapBits_0 h, uintptr size, uintptr n, uintptr total);
void __golang runtime_heapBits_clearCheckmarkSpan(runtime_heapBits_0 h, uintptr size, uintptr n, uintptr total);
__int32 __golang runtime___ptr_mspan__countAlloc(runtime_mspan *s);
void __golang runtime_heapBitsSetType(uintptr x, uintptr size, uintptr dataSize, runtime__type_0 *typ);
void __golang runtime_heapBitsSetTypeGCProg(runtime_heapBits_0 h, uintptr progSize, uintptr elemSize, uintptr dataSize, uintptr allocSize, uint8 *prog);
runtime_bitvector_0 __golang runtime_progToPointerMask(uint8 *prog, uintptr size);
uintptr __golang runtime_runGCProg(uint8 *prog, uint8 *trailer, uint8 *dst, __int32 size);
runtime_mcache *__golang runtime_allocmcache();
void __golang runtime_freemcache(runtime_mcache *c);
runtime_mspan *__golang runtime___ptr_mcache__refill(runtime_mcache *c, runtime_spanClass spc);
void __golang runtime___ptr_mcache__releaseAll(runtime_mcache *c);
runtime_mspan *__golang runtime___ptr_mcentral__cacheSpan(runtime_mcentral_0 *c);
void __golang runtime___ptr_mcentral__uncacheSpan(runtime_mcentral_0 *c, runtime_mspan *s);
bool __golang runtime___ptr_mcentral__freeSpan(runtime_mcentral_0 *c, runtime_mspan *s, bool preserve, bool wasempty);
runtime_mspan *__golang runtime___ptr_mcentral__grow(runtime_mcentral_0 *c);
bool __golang runtime_addrspace_free(void *v, uintptr n);
void *__golang runtime_mmap_fixed(void *v, uintptr n, int32 prot, int32 flags, int32 fd, uint32 offset);
void *__golang runtime_sysAlloc(uintptr n, uint64 *sysStat);
void __golang runtime_sysUnused(void *v, uintptr n);
void __golang runtime_sysUsed(void *v, uintptr n);
void __golang runtime_sysFree(void *v, uintptr n, uint64 *sysStat);
void __golang runtime_sysFault(void *v, uintptr n);
void *__golang runtime_sysReserve(void *v, uintptr n, bool *reserved);
void __golang runtime_sysMap(void *v, uintptr n, bool reserved, uint64 *sysStat);
void __golang runtime_queuefinalizer(void *p, runtime_funcval *fn, uintptr nret, runtime__type_0 *fint, runtime_ptrtype_0 *ot);
runtime_g *__golang runtime_wakefing();
void __golang runtime_createfing();
void __golang runtime_runfinq();
void __golang runtime_SetFinalizer(interface_{} obj, interface_{} finalizer);
void __golang runtime_findObject(void *v, runtime_mspan *s, void *x, uintptr n);
void *__golang runtime___ptr_fixalloc__alloc(runtime_fixalloc_0 *f);
void __golang runtime_gcinit();
int32 __golang runtime_readgogc();
void __golang runtime_gcenable();
void __golang runtime_debug_setGCPercent(int32 in, int32 out);
void __golang runtime_setGCPhase(uint32 x);
void __golang runtime___ptr_gcControllerState__startCycle(runtime_gcControllerState_0 *c);
void __golang runtime___ptr_gcControllerState__revise(runtime_gcControllerState_0 *c);
float64 __golang runtime___ptr_gcControllerState__endCycle(runtime_gcControllerState_0 *c);
void __golang runtime___ptr_gcControllerState__enlistWorker(runtime_gcControllerState_0 *c);
runtime_g *__golang runtime___ptr_gcControllerState__findRunnableGCWorker(runtime_gcControllerState_0 *c, runtime_p *_p_);
void __golang runtime_gcSetTriggerRatio(float64 triggerRatio);
bool __golang runtime_gcTrigger_test(runtime_gcTrigger_0 t);
void __golang runtime_gcStart(runtime_gcMode mode, runtime_gcTrigger_0 trigger);
void __golang runtime_gcMarkDone();
void __golang runtime_gcMarkTermination(float64 nextTriggerRatio);
void __golang runtime_gcBgMarkStartWorkers();
void __golang runtime_gcBgMarkWorker(runtime_p *_p_);
bool __golang runtime_gcMarkWorkAvailable(runtime_p *p);
void __golang runtime_gcMark(int64 start_time);
void __golang runtime_gcSweep(runtime_gcMode mode);
void __golang runtime_gcResetMarkState();
void __golang sync_runtime_registerPoolCleanup(func() f);
void __golang runtime_clearpools();
void __golang runtime_gchelper();
void __golang runtime_gchelperstart();
__uint8 __golang runtime_itoaDiv(__uint8 buf, uint64 val, __int32 dec);
__uint8 __golang runtime_fmtNSAsMS(__uint8 buf, uint64 ns);
void __golang runtime___ptr_mTreap__insert(runtime_mTreap_0 *root, runtime_mspan *span);
runtime_mspan *__golang runtime___ptr_mTreap__removeNode(runtime_mTreap_0 *root, runtime_treapNode *t);
runtime_mspan *__golang runtime___ptr_mTreap__remove(runtime_mTreap_0 *root, uintptr npages);
void __golang runtime___ptr_mTreap__removeSpan(runtime_mTreap_0 *root, runtime_mspan *span);
uintptr __golang runtime_scavengetreap(runtime_treapNode *treap, uint64 now, uint64 limit);
void __golang runtime___ptr_mTreap__rotateLeft(runtime_mTreap_0 *root, runtime_treapNode *x);
void __golang runtime___ptr_mTreap__rotateRight(runtime_mTreap_0 *root, runtime_treapNode *y);
void __golang runtime_gcMarkRootPrepare();
void __golang runtime_gcMarkRootCheck();
void __golang runtime_markroot(runtime_gcWork_0 *gcw, uint32 i);
void __golang runtime_markrootBlock(uintptr b0, uintptr n0, uint8 *ptrmask0, runtime_gcWork_0 *gcw, __int32 shard);
void __golang runtime_markrootFreeGStacks();
void __golang runtime_markrootSpans(runtime_gcWork_0 *gcw, __int32 shard);
void __golang runtime_gcAssistAlloc(runtime_g *gp);
void __golang runtime_gcAssistAlloc1(runtime_g *gp, int64 scanWork);
void __golang runtime_gcWakeAllAssists();
bool __golang runtime_gcParkAssist();
void __golang runtime_gcFlushBgCredit(int64 scanWork);
void __golang runtime_scanstack(runtime_g *gp, runtime_gcWork_0 *gcw);
void __golang runtime_scanframeworker(runtime_stkframe *frame, runtime_pcvalueCache *cache, runtime_gcWork_0 *gcw);
void __golang runtime_gcDrain(runtime_gcWork_0 *gcw, runtime_gcDrainFlags flags);
int64 __golang runtime_gcDrainN(runtime_gcWork_0 *gcw, int64 scanWork);
void __golang runtime_scanblock(uintptr b0, uintptr n0, uint8 *ptrmask, runtime_gcWork_0 *gcw);
void __golang runtime_scanobject(uintptr b, runtime_gcWork_0 *gcw);
void __golang runtime_shade(uintptr b);
void __golang runtime_greyobject(uintptr obj, uintptr base, uintptr off, runtime_heapBits_0 hbits, runtime_mspan *span, runtime_gcWork_0 *gcw, uintptr objIndex);
void __golang runtime_gcDumpObject(string label, uintptr obj, uintptr off);
void __golang runtime_gcmarknewobject(uintptr obj, uintptr size, uintptr scanSize);
void __golang runtime_gcMarkTinyAllocs();
void __golang runtime_initCheckmarks();
void __golang runtime_clearCheckmarks();
void __golang runtime_finishsweep_m();
void __golang runtime_bgsweep(chan_int c);
uintptr __golang runtime_sweepone();
uintptr __golang runtime_gosweepone();
void __golang runtime___ptr_mspan__ensureSwept(runtime_mspan *s);
bool __golang runtime___ptr_mspan__sweep(runtime_mspan *s, bool preserve);
void __golang runtime_deductSweepCredit(uintptr spanBytes, uintptr callerSweepPages);
void __golang runtime___ptr_gcSweepBuf__push(runtime_gcSweepBuf_0 *b, runtime_mspan *s);
runtime_mspan *__golang runtime___ptr_gcSweepBuf__pop(runtime_gcSweepBuf_0 *b);
__int32 __golang runtime___ptr_gcSweepBuf__numBlocks(runtime_gcSweepBuf_0 *b);
___runtime_mspan __golang runtime___ptr_gcSweepBuf__block(runtime_gcSweepBuf_0 *b, __int32 i);
void __golang runtime_init_0();
void __golang runtime___ptr_gcWork__init(runtime_gcWork_0 *w);
void __golang runtime___ptr_gcWork__put(runtime_gcWork_0 *w, uintptr obj);
uintptr __golang runtime___ptr_gcWork__tryGet(runtime_gcWork_0 *w);
uintptr __golang runtime___ptr_gcWork__get(runtime_gcWork_0 *w);
void __golang runtime___ptr_gcWork__dispose(runtime_gcWork_0 *w);
void __golang runtime___ptr_gcWork__balance(runtime_gcWork_0 *w);
void __golang runtime___ptr_workbuf__checknonempty(runtime_workbuf *b);
void __golang runtime___ptr_workbuf__checkempty(runtime_workbuf *b);
runtime_workbuf *__golang runtime_getempty();
void __golang runtime_putempty(runtime_workbuf *b);
void __golang runtime_putfull(runtime_workbuf *b);
runtime_workbuf *__golang runtime_trygetfull();
runtime_workbuf *__golang runtime_getfull();
runtime_workbuf *__golang runtime_handoff(runtime_workbuf *b);
void __golang runtime_prepareFreeWorkbufs();
bool __golang runtime_freeSomeWbufs(bool preemptible);
void __golang runtime_recordspan(void *vh, void *p);
void __golang runtime___ptr_mheap__init(runtime_mheap_0 *h, uintptr spansStart, uintptr spansBytes);
void __golang runtime___ptr_mheap__setArenaUsed(runtime_mheap_0 *h, uintptr arena_used, bool racemap);
void __golang runtime___ptr_mheap__mapSpans(runtime_mheap_0 *h, uintptr arena_used);
uintptr __golang runtime___ptr_mheap__reclaimList(runtime_mheap_0 *h, runtime_mSpanList_0 *list, uintptr npages);
void __golang runtime___ptr_mheap__reclaim(runtime_mheap_0 *h, uintptr npage);
runtime_mspan *__golang runtime___ptr_mheap__alloc_m(runtime_mheap_0 *h, uintptr npage, runtime_spanClass spanclass, bool large);
runtime_mspan *__golang runtime___ptr_mheap__alloc(runtime_mheap_0 *h, uintptr npage, runtime_spanClass spanclass, bool large, bool needzero);
runtime_mspan *__golang runtime___ptr_mheap__allocManual(runtime_mheap_0 *h, uintptr npage, uint64 *stat);
runtime_mspan *__golang runtime___ptr_mheap__allocSpanLocked(runtime_mheap_0 *h, uintptr npage, uint64 *stat);
runtime_mspan *__golang runtime___ptr_mheap__allocLarge(runtime_mheap_0 *h, uintptr npage);
bool __golang runtime___ptr_mheap__grow(runtime_mheap_0 *h, uintptr npage);
void __golang runtime___ptr_mheap__freeSpan(runtime_mheap_0 *h, runtime_mspan *s, int32 acct);
void __golang runtime___ptr_mheap__freeManual(runtime_mheap_0 *h, runtime_mspan *s, uint64 *stat);
void __golang runtime___ptr_mheap__freeSpanLocked(runtime_mheap_0 *h, runtime_mspan *s, bool acctinuse, bool acctidle, int64 unusedsince);
uintptr __golang runtime_scavengeTreapNode(runtime_treapNode *t, uint64 now, uint64 limit);
uintptr __golang runtime_scavengelist(runtime_mSpanList_0 *list, uint64 now, uint64 limit);
void __golang runtime___ptr_mheap__scavenge(runtime_mheap_0 *h, int32 k, uint64 now, uint64 limit);
void __golang runtime___ptr_mSpanList__remove(runtime_mSpanList_0 *list, runtime_mspan *span);
void __golang runtime___ptr_mSpanList__insert(runtime_mSpanList_0 *list, runtime_mspan *span);
void __golang runtime___ptr_mSpanList__insertBack(runtime_mSpanList_0 *list, runtime_mspan *span);
void __golang runtime___ptr_mSpanList__takeAll(runtime_mSpanList_0 *list, runtime_mSpanList_0 *other);
bool __golang runtime_addspecial(void *p, runtime_special *s);
runtime_special *__golang runtime_removespecial(void *p, uint8 kind);
bool __golang runtime_addfinalizer(void *p, runtime_funcval *f, uintptr nret, runtime__type_0 *fint, runtime_ptrtype_0 *ot);
void __golang runtime_removefinalizer(void *p);
void __golang runtime_setprofilebucket(void *p, runtime_bucket *b);
void __golang runtime_freespecial(runtime_special *s, void *p, uintptr size);
runtime_gcBits *__golang runtime___ptr_gcBitsArena__tryAlloc(runtime_gcBitsArena *b, uintptr bytes);
runtime_gcBits *__golang runtime_newMarkBits(uintptr nelems);
runtime_gcBits *__golang runtime_newAllocBits(uintptr nelems);
void __golang runtime_nextMarkBitArenaEpoch();
runtime_gcBitsArena *__golang runtime_newArenaMayUnlock();
runtime_bucket *__golang runtime_newBucket(runtime_bucketType typ, __int32 nstk);
runtime_memRecord *__golang runtime___ptr_bucket__mp(runtime_bucket *b);
runtime_blockRecord *__golang runtime___ptr_bucket__bp(runtime_bucket *b);
runtime_bucket *__golang runtime_stkbucket(runtime_bucketType typ, uintptr size, __uintptr stk, bool alloc);
bool __golang runtime_eqslice(__uintptr x, __uintptr y);
void __golang runtime_mProf_NextCycle();
void __golang runtime_mProf_Flush();
void __golang runtime_mProf_FlushLocked();
void __golang runtime_mProf_Malloc(void *p, uintptr size);
void __golang runtime_mProf_Free(runtime_bucket *b, uintptr size);
void __golang runtime_blockevent(int64 cycles, __int32 skip);
bool __golang runtime_blocksampled(int64 cycles);
void __golang runtime_saveblockevent(int64 cycles, __int32 skip, runtime_bucketType which);
void __golang sync_event(int64 cycles, __int32 skip);
void __golang runtime_tracealloc(void *p, uintptr size, runtime__type_0 *typ);
void __golang runtime_tracefree(void *p, uintptr size);
void __golang runtime_tracegc();
void __golang runtime_init_1();
void __golang runtime_cachestats();
void __golang runtime_flushmcache(__int32 i);
void __golang runtime_purgecachedstats(runtime_mcache *c);
void __golang runtime_mSysStatInc(uint64 *sysStat, uintptr n);
void __golang runtime_mSysStatDec(uint64 *sysStat, uintptr n);
void __golang internal_poll_runtime_pollServerInit();
bool __golang runtime_netpollinited();
retval_8068E50 __golang internal_poll_runtime_pollOpen(uintptr fd);
void __golang internal_poll_runtime_pollClose(runtime_pollDesc *pd);
void __golang runtime___ptr_pollCache__free(runtime_pollCache_0 *c, runtime_pollDesc *pd);
__int32 __golang internal_poll_runtime_pollReset(runtime_pollDesc *pd, __int32 mode);
__int32 __golang internal_poll_runtime_pollWait(runtime_pollDesc *pd, __int32 mode);
void __golang internal_poll_runtime_pollUnblock(runtime_pollDesc *pd);
void __golang runtime_netpollready(runtime_guintptr *gpp, runtime_pollDesc *pd, int32 mode);
bool __golang runtime_netpollblockcommit(runtime_g *gp, void *gpp);
void __golang runtime_netpollgoready(runtime_g *gp, __int32 traceskip);
bool __golang runtime_netpollblock(runtime_pollDesc *pd, int32 mode, bool waitio);
runtime_g *__golang runtime_netpollunblock(runtime_pollDesc *pd, int32 mode, bool ioready);
runtime_pollDesc *__golang runtime___ptr_pollCache__alloc(runtime_pollCache_0 *c);
void __golang runtime_netpollinit();
int32 __golang runtime_netpollopen(uintptr fd, runtime_pollDesc *pd);
int32 __golang runtime_netpollclose(uintptr fd);
runtime_g *__golang runtime_netpoll(bool block);
void __golang runtime_futexsleep(uint32 *addr, uint32 val, int64 ns);
void __golang runtime_futexwakeup(uint32 *addr, uint32 cnt);
int32 __golang runtime_getproccount();
void __golang runtime_newosproc(runtime_m *mp, void *stk);
void __golang runtime_sysargs(int32 argc, uint8 **argv);
__int32 __golang runtime_sysauxv(__uintptr auxv);
void __golang runtime_osinit();
void __golang runtime_getRandomData(__uint8 r);
void __golang runtime_goenvs();
void __golang runtime_mpreinit(runtime_m *mp);
void __golang runtime_minit();
void __golang runtime_unminit();
void __golang runtime_sigprocmask(int32 how, runtime_sigset *new, runtime_sigset *old);
void __golang runtime_setsig(uint32 i, uintptr fn);
void __golang runtime_setsigstack(uint32 i);
uintptr __golang runtime_getsig(uint32 i);
void __golang runtime_panicCheckMalloc(error_0 err);
void __golang runtime_panicindex();
void __golang runtime_panicslice();
void __golang runtime_panicdivide();
void __golang runtime_panicoverflow();
void __golang runtime_panicfloat();
void __golang runtime_panicmem();
void __golang runtime_throwinit();
void __golang runtime_deferproc(int32 siz, runtime_funcval *fn);
void __golang runtime_testdefersizes();
void __golang runtime_init_2();
runtime__defer *__golang runtime_newdefer(int32 siz);
void __golang runtime_freedefer(runtime__defer *d);
void __golang runtime_freedeferpanic();
void __golang runtime_freedeferfn();
void __golang runtime_deferreturn(uintptr arg0);
void __golang runtime_preprintpanics(runtime__panic *p);
void __golang runtime_printpanics(runtime__panic *p);
void __golang runtime_gopanic(interface_{} e);
uintptr __golang runtime_getargp(__int32 x);
interface_{} __golang runtime_gorecover(uintptr argp);
void __golang runtime_startpanic();
void __golang runtime_dopanic(__int32 unused);
void __golang runtime_throw(string s);
void __golang runtime_recovery(runtime_g *gp);
void __golang runtime_startpanic_m();
void __golang runtime_dopanic_m(runtime_g *gp, uintptr pc, uintptr sp_0);
bool __golang runtime_canpanic(runtime_g *gp);
void __golang runtime_recordForPanic(__uint8 b);
void __golang runtime_printlock();
void __golang runtime_printunlock();
void __golang runtime_gwrite(__uint8 b);
void __golang runtime_printsp();
void __golang runtime_printnl();
void __golang runtime_printbool(bool v);
void __golang runtime_printfloat(float64 v);
void __golang runtime_printcomplex(complex128 c);
void __golang runtime_printuint(uint64 v);
void __golang runtime_printint(int64 v);
void __golang runtime_printhex(uint64 v);
void __golang runtime_printpointer(void *p);
void __golang runtime_printstring(string s);
void __golang runtime_printslice(__uint8 s);
void __golang runtime_printeface(runtime_eface_0 e);
void __golang runtime_main();
void __golang runtime_init_3();
void __golang runtime_forcegchelper();
void __golang runtime_Gosched();
void __golang runtime_gopark(func(_runtime_g__unsafe_Pointer)_bool unlockf, void *lock, string reason, uint8 traceEv, __int32 traceskip);
void __golang runtime_goparkunlock(runtime_mutex_0 *lock, string reason, uint8 traceEv, __int32 traceskip);
void __golang runtime_goready(runtime_g *gp, __int32 traceskip);
runtime_sudog *__golang runtime_acquireSudog();
void __golang runtime_releaseSudog(runtime_sudog *s);
uintptr __golang runtime_funcPC(interface_{} f);
void __golang runtime_badmcall(func(_runtime_g) fn);
void __golang runtime_badmcall2(func(_runtime_g) fn);
void __golang runtime_badreflectcall();
void __golang runtime_badmorestackg0();
void __golang runtime_badmorestackgsignal();
void __golang runtime_badctxt();
void __golang runtime_allgadd(runtime_g *gp);
void __golang runtime_schedinit();
void __golang runtime_dumpgstatus(runtime_g *gp);
void __golang runtime_checkmcount();
void __golang runtime_mcommoninit(runtime_m *mp);
void __golang runtime_ready(runtime_g *gp, __int32 traceskip, bool next);
int32 __golang runtime_gcprocs();
bool __golang runtime_needaddgcproc();
void __golang runtime_helpgc(int32 nproc);
void __golang runtime_freezetheworld();
uint32 __golang runtime_readgstatus(runtime_g *gp);
void __golang runtime_casfrom_Gscanstatus(runtime_g *gp, uint32 oldval, uint32 newval);
bool __golang runtime_castogscanstatus(runtime_g *gp, uint32 oldval, uint32 newval);
void __golang runtime_casgstatus(runtime_g *gp, uint32 oldval, uint32 newval);
void __golang runtime_scang(runtime_g *gp, runtime_gcWork_0 *gcw);
void __golang runtime_restartg(runtime_g *gp);
void __golang runtime_stopTheWorld(string reason);
void __golang runtime_startTheWorld();
void __golang runtime_stopTheWorldWithSema();
void __golang runtime_mhelpgc();
void __golang runtime_startTheWorldWithSema();
void __golang runtime_mstart();
void __golang runtime_mstart1();
void __golang runtime_forEachP(func(_runtime_p) fn);
void __golang runtime_runSafePointFn();
runtime_m *__golang runtime_allocm(runtime_p *_p_, func() fn);
void __golang runtime_needm(uint8 x);
void __golang runtime_newextram();
void __golang runtime_oneNewExtraM();
void __golang runtime_dropm();
runtime_m *__golang runtime_lockextra(bool nilokay);
void __golang runtime_unlockextra(runtime_m *mp);
void __golang runtime_newm(func() fn, runtime_p *_p_);
void __golang runtime_stopm();
void __golang runtime_mspinning();
void __golang runtime_startm(runtime_p *_p_, bool spinning);
void __golang runtime_handoffp(runtime_p *_p_);
void __golang runtime_wakep();
void __golang runtime_stoplockedm();
void __golang runtime_startlockedm(runtime_g *gp);
void __golang runtime_gcstopm();
void __golang runtime_execute(runtime_g *gp, bool inheritTime);
void __golang runtime_findrunnable(runtime_g *gp, bool inheritTime);
bool __golang runtime_pollWork();
void __golang runtime_resetspinning();
void __golang runtime_injectglist(runtime_g *glist);
void __golang runtime_schedule();
bool __golang runtime_parkunlock_c(runtime_g *gp, void *lock);
void __golang runtime_park_m(runtime_g *gp);
void __golang runtime_goschedImpl(runtime_g *gp);
void __golang runtime_gosched_m(runtime_g *gp);
void __golang runtime_gopreempt_m(runtime_g *gp);
void __golang runtime_goexit1();
void __golang runtime_goexit0(runtime_g *gp);
void __golang runtime_save(uintptr pc, uintptr sp_0);
void __golang runtime_reentersyscall(uintptr pc, uintptr sp_0);
void __golang runtime_entersyscall(int32 dummy);
void __golang runtime_entersyscall_sysmon();
void __golang runtime_entersyscall_gcwait();
void __golang runtime_entersyscallblock(int32 dummy);
void __golang runtime_entersyscallblock_handoff();
void __golang runtime_exitsyscall(int32 dummy);
bool __golang runtime_exitsyscallfast();
void __golang runtime_exitsyscallfast_reacquired();
bool __golang runtime_exitsyscallfast_pidle();
void __golang runtime_exitsyscall0(runtime_g *gp);
runtime_g *__golang runtime_malg(int32 stacksize);
void __golang runtime_newproc(int32 siz, runtime_funcval *fn);
runtime_g *__golang runtime_newproc1(runtime_funcval *fn, uint8 *argp, int32 narg, int32 nret, uintptr callerpc);
void __golang runtime_gfput(runtime_p *_p_, runtime_g *gp);
runtime_g *__golang runtime_gfget(runtime_p *_p_);
void __golang runtime_gfpurge(runtime_p *_p_);
void __golang runtime_unlockOSThread();
void __golang runtime_badunlockosthread();
void __golang runtime__System();
void __golang runtime__ExternalCode();
void __golang runtime__LostExternalCode();
void __golang runtime__GC();
void __golang runtime_sigprof(uintptr pc, uintptr sp_0, uintptr lr, runtime_g *gp, runtime_m *mp);
void __golang runtime_sigprofNonGoPC(uintptr pc);
bool __golang runtime_setsSP(uintptr pc);
runtime_p *__golang runtime_procresize(int32 nprocs);
void __golang runtime_acquirep(runtime_p *_p_);
void __golang runtime_acquirep1(runtime_p *_p_);
runtime_p *__golang runtime_releasep();
void __golang runtime_incidlelocked(int32 v);
void __golang runtime_checkdead();
void __golang runtime_sysmon();
uint32 __golang runtime_retake(int64 now);
bool __golang runtime_preemptall();
void __golang runtime_schedtrace(bool detailed);
void __golang runtime_mput(runtime_m *mp);
runtime_g *__golang runtime_globrunqget(runtime_p *_p_, int32 max);
void __golang runtime_pidleput(runtime_p *_p_);
runtime_p *__golang runtime_pidleget();
bool __golang runtime_runqempty(runtime_p *_p_);
void __golang runtime_runqput(runtime_p *_p_, runtime_g *gp, bool next);
bool __golang runtime_runqputslow(runtime_p *_p_, runtime_g *gp, uint32 h, uint32 t);
void __golang runtime_runqget(runtime_p *_p_, runtime_g *gp, bool inheritTime);
uint32 __golang runtime_runqgrab(runtime_p *_p_, runtime_guintptr (*batch)[256], uint32 batchHead, bool stealRunNextG);
runtime_g *__golang runtime_runqsteal(runtime_p *_p_, runtime_p *p2, bool stealRunNextG);
__int32 __golang sync_runtime_procPin();
void __golang sync_runtime_procUnpin();
__int32 __golang sync_atomic_runtime_procPin();
void __golang sync_atomic_runtime_procUnpin();
bool __golang sync_runtime_canSpin(__int32 i);
void __golang sync_runtime_doSpin();
void __golang runtime___ptr_randomOrder__reset(runtime_randomOrder_0 *ord, uint32 count);
uint32 __golang runtime_gcd(uint32 a, uint32 b);
runtime_profIndex __golang runtime___ptr_profAtomic__load(runtime_profAtomic *x);
bool __golang runtime___ptr_profAtomic__cas(runtime_profAtomic *x, runtime_profIndex old, runtime_profIndex new);
bool __golang runtime___ptr_profBuf__hasOverflow(runtime_profBuf *b);
void __golang runtime___ptr_profBuf__takeOverflow(runtime_profBuf *b, uint32 count, uint64 time);
void __golang runtime___ptr_profBuf__incrementOverflow(runtime_profBuf *b, int64 now);
bool __golang runtime___ptr_profBuf__canWriteRecord(runtime_profBuf *b, __int32 nstk);
bool __golang runtime___ptr_profBuf__canWriteTwoRecords(runtime_profBuf *b, __int32 nstk1, __int32 nstk2);
void __golang runtime___ptr_profBuf__write(runtime_profBuf *b, void **tagPtr, int64 now, __uint64 hdr, __uintptr stk);
void __golang runtime___ptr_profBuf__wakeupExtra(runtime_profBuf *b);
__string __golang syscall_runtime_envs();
__string __golang os_runtime_args();
void __golang runtime_gotraceback(int32 level, bool all, bool crash);
void __golang runtime_args(int32 c, uint8 **v);
void __golang runtime_goargs();
void __golang runtime_goenvs_unix();
void __golang runtime_testAtomic64();
void __golang runtime_check();
void __golang runtime_parsedebugvars();
void __golang runtime_debug_SetTraceback(string level);
int32 __golang runtime_timediv(int64 v, int32 div, int32 *rem);
retval_8079460 __golang reflect_typelinks();
void *__golang reflect_resolveNameOff(void *ptrInModule, int32 off);
void *__golang reflect_resolveTypeOff(void *rtype, int32 off);
void *__golang reflect_resolveTextOff(void *rtype, int32 off);
int32 __golang reflect_addReflectOff(void *ptr);
bool __golang runtime___ptr_guintptr__cas(runtime_guintptr *gp, runtime_guintptr old, runtime_guintptr new);
void __golang runtime_extendRandom(__uint8 r, __int32 n);
void __golang runtime___ptr_rwmutex__rlock(runtime_rwmutex_0 *rw);
void __golang runtime___ptr_rwmutex__runlock(runtime_rwmutex_0 *rw);
void __golang internal_poll_runtime_Semacquire(uint32 *addr);
void __golang sync_runtime_Semrelease(uint32 *addr, bool handoff);
void __golang sync_runtime_SemacquireMutex(uint32 *addr, bool lifo);
void __golang internal_poll_runtime_Semrelease(uint32 *addr);
void __golang runtime_readyWithTime(runtime_sudog *s, __int32 traceskip);
void __golang runtime_semacquire(uint32 *addr);
void __golang runtime_semacquire1(uint32 *addr, bool lifo, runtime_semaProfileFlags profile);
void __golang runtime_semrelease(uint32 *addr);
void __golang runtime_semrelease1(uint32 *addr, bool handoff);
bool __golang runtime_cansemacquire(uint32 *addr);
void __golang runtime___ptr_semaRoot__queue(runtime_semaRoot_0 *root, uint32 *addr, runtime_sudog *s, bool lifo);
void __golang runtime___ptr_semaRoot__dequeue(runtime_semaRoot_0 *root, uint32 *addr, runtime_sudog *found, int64 now);
void __golang runtime___ptr_semaRoot__rotateLeft(runtime_semaRoot_0 *root, runtime_sudog *x);
void __golang runtime___ptr_semaRoot__rotateRight(runtime_semaRoot_0 *root, runtime_sudog *y);
void __golang sync_runtime_notifyListCheck(uintptr sz);
int64 __golang sync_runtime_nanotime();
void __golang runtime_dumpregs(runtime_sigctxt *c);
void __golang runtime___ptr_sigctxt__preparePanic(runtime_sigctxt *c, uint32 sig, runtime_g *gp);
void __golang runtime_sighandler(uint32 sig, runtime_siginfo *info, void *ctxt, runtime_g *gp);
void __golang os_sigpipe();
void __golang runtime_init_4();
void __golang runtime_initsig(bool preinit);
bool __golang runtime_sigInstallGoHandler(uint32 sig);
void __golang runtime_setThreadCPUProfiler(int32 hz);
void __golang runtime_sigpipe();
void __golang runtime_sigtrampgo(uint32 sig, runtime_siginfo *info, void *ctx);
void __golang runtime_sigpanic();
void __golang runtime_dieFromSignal(uint32 sig);
void __golang runtime_raisebadsignal(uint32 sig, runtime_sigctxt *c);
void __golang runtime_crash();
void __golang runtime_noSignalStack(uint32 sig);
void __golang runtime_sigNotOnStack(uint32 sig);
void __golang runtime_signalDuringFork(uint32 sig);
void __golang runtime_badsignal(uintptr sig, runtime_sigctxt *c);
bool __golang runtime_sigfwdgo(uint32 sig, runtime_siginfo *info, void *ctx);
void __golang runtime_msigsave(runtime_m *mp);
void __golang runtime_msigrestore(runtime_sigset sigmask);
void __golang runtime_sigblock();
void __golang runtime_unblocksig(uint32 sig);
void __golang runtime_minitSignals();
void __golang runtime_minitSignalStack();
void __golang runtime_minitSignalMask();
void __golang runtime_unminitSignals();
void __golang runtime_signalstack(runtime_stack_0 *s);
bool __golang runtime_sigsend(uint32 s);
bool __golang runtime_signal_ignored(uint32 s);
runtime_slice_0 __golang runtime_makeslice(runtime__type_0 *et, __int32 len, __int32 cap);
runtime_slice_0 __golang runtime_growslice(runtime__type_0 *et, runtime_slice_0 old, __int32 cap);
void __golang runtime_stackinit();
__int32 __golang runtime_stacklog2(uintptr n);
runtime_gclinkptr __golang runtime_stackpoolalloc(uint8 order);
void __golang runtime_stackpoolfree(runtime_gclinkptr x, uint8 order);
void __golang runtime_stackcacherefill(runtime_mcache *c, uint8 order);
void __golang runtime_stackcacherelease(runtime_mcache *c, uint8 order);
void __golang runtime_stackcache_clear(runtime_mcache *c);
runtime_stack_0 __golang runtime_stackalloc(uint32 n);
void __golang runtime_stackfree(runtime_stack_0 stk);
void __golang runtime_adjustpointers(void *scanp, runtime_bitvector_0 *cbv, runtime_adjustinfo *adjinfo, runtime_funcInfo_0 f);
bool __golang runtime_adjustframe(runtime_stkframe *frame, void *arg);
void __golang runtime_adjustctxt(runtime_g *gp, runtime_adjustinfo *adjinfo);
void __golang runtime_adjustdefers(runtime_g *gp, runtime_adjustinfo *adjinfo);
void __golang runtime_adjustsudogs(runtime_g *gp, runtime_adjustinfo *adjinfo);
uintptr __golang runtime_findsghi(runtime_g *gp, runtime_stack_0 stk);
uintptr __golang runtime_syncadjustsudogs(runtime_g *gp, uintptr used, runtime_adjustinfo *adjinfo);
void __golang runtime_copystack(runtime_g *gp, uintptr newsize, bool sync);
int32 __golang runtime_round2(int32 x);
void __golang runtime_newstack(void *ctxt);
void __golang runtime_shrinkstack(runtime_g *gp);
void __golang runtime_freeStackSpans();
void __golang runtime_morestackc();
string __golang runtime_concatstrings(uint8 (*buf)[32], __string a);
string __golang runtime_concatstring2(uint8 (*buf)[32], string a[2]);
string __golang runtime_concatstring3(uint8 (*buf)[32], string a[3]);
string __golang runtime_concatstring4(uint8 (*buf)[32], string a[4]);
string __golang runtime_concatstring5(uint8 (*buf)[32], string a[5]);
void __golang runtime_slicebytetostring(uint8 (*buf)[32], __uint8 b, string str);
void __golang runtime_rawstringtmp(uint8 (*buf)[32], __int32 l, string s, __uint8 b);
__uint8 __golang runtime_stringtoslicebyte(uint8 (*buf)[32], string s);
__int32 __golang runtime_stringtoslicerune(int32 (*buf)[32], string s);
string __golang runtime_slicerunetostring(uint8 (*buf)[32], __int32 a);
string __golang runtime_intstring(uint8 (*buf)[4], int64 v);
void __golang runtime_rawstring(__int32 size, string s, __uint8 b);
void __golang runtime_rawbyteslice(__int32 size, __uint8 b);
void __golang runtime_rawruneslice(__int32 size, __int32 b);
string __golang runtime_gostring(uint8 *p);
__int32 __golang runtime_index(string s, string t);
bool __golang runtime_contains(string s, string t);
retval_8080F10 __golang runtime_atoi(string s);
retval_8081040 __golang runtime_atoi32(string s);
__int32 __golang runtime_findnull(uint8 *s);
string __golang runtime_gostringnocopy(uint8 *str);
void __golang runtime_badsystemstack();
void __golang reflect_memclrNoHeapPointers(void *ptr, uintptr n);
runtime_Frames *__golang runtime_CallersFrames(__uintptr callers);
void __golang runtime___ptr_Frames__Next(runtime_Frames *ci, runtime_Frame_0 frame, bool more);
void __golang runtime___ptr_stackExpander__next(runtime_stackExpander_0 *se, __uintptr callers, __uintptr ncallers, runtime_Frame_0 frame, bool more);
void __golang runtime___ptr_pcExpander__init(runtime_pcExpander_0 *ex, uintptr pc, bool panicCall);
runtime_Frame_0 __golang runtime___ptr_pcExpander__next(runtime_pcExpander_0 *ex);
__runtime_Frame __golang runtime_expandCgoFrames(uintptr pc);
runtime_funcInfo_0 __golang runtime___ptr_Func__funcInfo(runtime_Func *f);
___runtime_moduledata __golang runtime_activeModules();
void __golang runtime_modulesinit();
void __golang runtime_moduledataverify();
void __golang runtime_moduledataverify1(runtime_moduledata_0 *datap);
runtime_Func *__golang runtime_FuncForPC(uintptr pc);
string __golang runtime___ptr_Func__Name(runtime_Func *f);
runtime_moduledata_0 *__golang runtime_findmoduledatap(uintptr pc);
runtime_funcInfo_0 __golang runtime_findfunc(uintptr pc);
int32 __golang runtime_pcvalue(runtime_funcInfo_0 f, int32 off, uintptr targetpc, runtime_pcvalueCache *cache, bool strict);
string __golang runtime_funcname(runtime_funcInfo_0 f);
string __golang runtime_funcnameFromNameoff(runtime_funcInfo_0 f, int32 nameoff);
string __golang runtime_funcfile(runtime_funcInfo_0 f, int32 fileno);
void __golang runtime_funcline1(runtime_funcInfo_0 f, uintptr targetpc, bool strict, string file, int32 line);
void __golang runtime_funcline(runtime_funcInfo_0 f, uintptr targetpc, string file, int32 line);
int32 __golang runtime_funcspdelta(runtime_funcInfo_0 f, uintptr targetpc, runtime_pcvalueCache *cache);
int32 __golang runtime_pcdatavalue(runtime_funcInfo_0 f, int32 table, uintptr targetpc, runtime_pcvalueCache *cache);
void *__golang runtime_funcdata(runtime_funcInfo_0 f, int32 i);
void __golang runtime_step(__uint8 p, uintptr *pc, int32 *val, bool first, __uint8 newp, bool ok);
void __golang runtime_readvarint(__uint8 p, uint32 read, uint32 val);
runtime_bitvector_0 __golang runtime_stackmapdata(runtime_stackmap *stkmap, int32 n);
bool __golang runtime_deltimer(runtime_timer *t);
void __golang runtime_timerproc();
runtime_g *__golang runtime_timejump();
void __golang runtime_siftupTimer(__int32 i);
void __golang runtime_siftdownTimer(__int32 i);
void __golang time_now(int64 sec, int32 nsec, int64 mono);
runtime_g *__golang runtime_traceReader();
void __golang runtime_traceProcFree(runtime_p *pp);
void __golang runtime_traceEvent(uint8 ev, __int32 skip, __uint64 args);
uint64 __golang runtime_traceStackID(runtime_m *mp, __uintptr buf, __int32 skip);
void __golang runtime_traceAcquireBuffer(runtime_m *mp, int32 pid, runtime_traceBufPtr *bufp);
void __golang runtime_traceReleaseBuffer(int32 pid);
runtime_traceBufPtr __golang runtime_traceFlush(runtime_traceBufPtr buf);
void __golang runtime___ptr_traceBuf__varint(runtime_traceBuf *buf, uint64 v);
uint32 __golang runtime___ptr_traceStackTable__put(runtime_traceStackTable_0 *tab, __uintptr pcs);
uint32 __golang runtime___ptr_traceStackTable__find(runtime_traceStackTable_0 *tab, __uintptr pcs, uintptr hash);
runtime_traceStack *__golang runtime___ptr_traceStackTable__newStack(runtime_traceStackTable_0 *tab, __int32 n);
void *__golang runtime___ptr_traceAlloc__alloc(runtime_traceAlloc_0 *a, uintptr n);
void __golang runtime_traceGomaxprocs(int32 procs);
void __golang runtime_traceProcStart();
void __golang runtime_traceProcStop(runtime_p *pp);
void __golang runtime_traceGCStart();
void __golang runtime_traceGCDone();
void __golang runtime_traceGCScanStart();
void __golang runtime_traceGCScanDone();
void __golang runtime_traceGCSweepStart();
void __golang runtime_traceGCSweepSpan(uintptr bytesSwept);
void __golang runtime_traceGCSweepDone();
void __golang runtime_traceGCMarkAssistStart();
void __golang runtime_traceGCMarkAssistDone();
void __golang runtime_traceGoCreate(runtime_g *newg, uintptr pc);
void __golang runtime_traceGoStart();
void __golang runtime_traceGoEnd();
void __golang runtime_traceGoSched();
void __golang runtime_traceGoPreempt();
void __golang runtime_traceGoPark(uint8 traceEv, __int32 skip);
void __golang runtime_traceGoUnpark(runtime_g *gp, __int32 skip);
void __golang runtime_traceGoSysCall();
void __golang runtime_traceGoSysExit(int64 ts);
void __golang runtime_traceGoSysBlock(runtime_p *pp);
void __golang runtime_traceHeapAlloc();
void __golang runtime_traceNextGC();
void __golang runtime_tracebackinit();
void __golang runtime_tracebackdefers(runtime_g *gp, func(_runtime_stkframe__unsafe_Pointer)_bool callback, void *v);
__int32 __golang runtime_gentraceback(uintptr pc0, uintptr sp0, uintptr lr0, runtime_g *gp, __int32 skip, uintptr *pcbuf, __int32 max, func(_runtime_stkframe__unsafe_Pointer)_bool callback, void *v, uint flags);
void __golang runtime_getArgInfo(runtime_stkframe *frame, runtime_funcInfo_0 f, bool needArgMap, runtime_funcval *ctxt, uintptr arglen, runtime_bitvector_0 *argmap);
__int32 __golang runtime_tracebackCgoContext(uintptr *pcbuf, bool printing, uintptr ctxt, __int32 n, __int32 max);
void __golang runtime_printcreatedby(runtime_g *gp);
void __golang runtime_traceback(uintptr pc, uintptr sp_0, uintptr lr, runtime_g *gp);
void __golang runtime_tracebacktrap(uintptr pc, uintptr sp_0, uintptr lr, runtime_g *gp);
void __golang runtime_traceback1(uintptr pc, uintptr sp_0, uintptr lr, runtime_g *gp, uint flags);
__int32 __golang runtime_callers(__int32 skip, __uintptr pcbuf);
__int32 __golang runtime_gcallers(runtime_g *gp, __int32 skip, __uintptr pcbuf);
bool __golang runtime_showframe(runtime_funcInfo_0 f, runtime_g *gp, bool firstFrame);
void __golang runtime_goroutineheader(runtime_g *gp);
void __golang runtime_tracebackothers(runtime_g *me);
void __golang runtime_printCgoTraceback(uintptr (*callers)[32]);
__int32 __golang runtime_printOneCgoTraceback(uintptr pc, __int32 max, runtime_cgoSymbolizerArg_0 *arg);
void __golang runtime_callCgoSymbolizer(runtime_cgoSymbolizerArg_0 *arg);
void __golang runtime_cgoContextPCs(uintptr ctxt, __uintptr buf);
string __golang runtime___ptr__type__string(runtime__type_0 *t);
runtime_uncommontype *__golang runtime___ptr__type__uncommon(runtime__type_0 *t);
void __golang runtime_reflectOffsLock();
void __golang runtime_reflectOffsUnlock();
runtime_name_0 __golang runtime_resolveNameOff(void *ptrInModule, runtime_nameOff off);
runtime_name_0 __golang runtime___ptr__type__nameOff(runtime__type_0 *t, runtime_nameOff off);
runtime__type_0 *__golang runtime_resolveTypeOff(void *ptrInModule, runtime_typeOff off);
runtime__type_0 *__golang runtime___ptr__type__typeOff(runtime__type_0 *t, runtime_typeOff off);
void *__golang runtime___ptr__type__textOff(runtime__type_0 *t, runtime_textOff off);
__int32 __golang runtime_name_tagLen(runtime_name_0 n);
void __golang runtime_name_name(runtime_name_0 n, string s);
void __golang runtime_name_tag(runtime_name_0 n, string s);
string __golang runtime_name_pkgPath(runtime_name_0 n);
void __golang runtime_typelinksinit();
bool __golang runtime_typesEqual(runtime__type_0 *t, runtime__type_0 *v, map_runtime__typePair_struct_{} seen);
void __golang runtime_decoderune(string s, __int32 k, int32 r, __int32 pos);
__int32 __golang runtime_encoderune(__uint8 p, int32 r);
void __golang runtime_float64toint64(float64 d, uint64 y);
void __golang runtime_float64touint64(float64 d, uint64 y);
float64 __golang runtime_int64tofloat64(int64 y);
float64 __golang runtime_uint64tofloat64(uint64 y);
void __golang runtime__d2v(uint64 *y, float64 d);
uint64 __golang runtime_uint64div(uint64 n, uint64 d);
uint64 __golang runtime_uint64mod(uint64 n, uint64 d);
int64 __golang runtime_int64div(int64 n, int64 d);
int64 __golang runtime_int64mod(int64 n, int64 d);
void __golang runtime_dodiv(uint64 n, uint64 d, uint64 q, uint64 r);
void __golang runtime_slowdodiv(uint64 n, uint64 d, uint64 q, uint64 r);
void __golang runtime_writeErr(__uint8 b);
void __golang runtime_cgocallbackg1_func1(runtime_g *gp);
void __golang runtime_cgoCheckWriteBarrier_func1();
void __golang runtime_cgoCheckTypedBlock_func1();
void __golang runtime_cgoCheckTypedBlock_func2();
void __golang runtime_cgoCheckBits_func1();
void __golang runtime_chansend_func1();
void __golang runtime_chanrecv_func1();
void __golang runtime___ptr_mcache__nextFree_func1();
void __golang runtime_mallocgc_func1();
void __golang runtime_persistentalloc_func1();
void __golang runtime_writebarrierptr_prewrite1_func1();
void __golang runtime_writebarrierptr_func1();
void __golang runtime_writebarrierptr_prewrite_func1();
void __golang runtime_typedslicecopy_func1();
void __golang runtime_freemcache_func1();
void __golang runtime_SetFinalizer_func1();
void __golang runtime_SetFinalizer_func2();
bool __golang runtime___ptr_gcControllerState__findRunnableGCWorker_func1(int64 *ptr);
void __golang runtime_gcStart_func1();
void __golang runtime_gcMarkDone_func1_1(runtime_p *_p_);
void __golang runtime_gcMarkDone_func1();
void __golang runtime_gcMarkTermination_func1();
void __golang runtime_gcMarkTermination_func2();
bool __golang runtime_gcBgMarkWorker_func1(runtime_g *g, void *parkp);
void __golang runtime_gcBgMarkWorker_func2();
__int32 __golang runtime_gcMarkRootPrepare_func1(uintptr bytes);
void __golang runtime_markroot_func1();
void __golang runtime_gcAssistAlloc_func1();
bool __golang runtime_scanstack_func1(runtime_stkframe *frame, void *unused);
void __golang runtime_gosweepone_func1();
void __golang runtime_getempty_func1();
void __golang runtime_freeSomeWbufs_func1();
void __golang runtime___ptr_mheap__alloc_func1();
void __golang runtime___ptr_mheap__freeSpan_func1();
void __golang runtime_mProf_Malloc_func1();
void __golang runtime_tracealloc_func1();
void __golang runtime_tracefree_func1();
void __golang runtime_futexwakeup_func1();
void __golang runtime_newdefer_func1();
void __golang runtime_newdefer_func2();
void __golang runtime_freedefer_func1();
void __golang runtime_preprintpanics_func1();
void __golang runtime_dopanic_func1();
void __golang runtime_main_func1();
void __golang runtime_main_func2(bool *&needUnlock);
void __golang runtime_goready_func1();
void __golang runtime_casgstatus_func1();
void __golang runtime_casgstatus_func2();
void __golang runtime_reentersyscall_func1();
void __golang runtime_entersyscallblock_func1();
void __golang runtime_entersyscallblock_func2();
void __golang runtime_exitsyscall_func1();
void __golang runtime_exitsyscallfast_func1();
void __golang runtime_exitsyscallfast_reacquired_func1();
void __golang runtime_malg_func1();
void __golang runtime_newproc_func1();
void __golang runtime_gfget_func1();
void __golang runtime___ptr_rwmutex__rlock_func1();
void __golang runtime_morestackc_func1();
void __golang runtime_callers_func1();
void __golang runtime_init();
void __golang runtime_skipPleaseUseCallersFrames();
void __golang runtime_rt0_go();
void __golang runtime_asminit();
void __golang runtime_gosave();
void __golang runtime_gogo();
void __golang runtime_mcall();
void __golang runtime_systemstack_switch();
void __golang runtime_systemstack();
void __golang runtime_morestack();
void __golang runtime_morestack_noctxt();
void __golang reflect_call();
void __golang runtime_reflectcall();
void __golang callRet();
void __golang runtime_call16();
void __golang runtime_call32();
void __golang runtime_call64();
void __golang runtime_call128();
void __golang runtime_call256();
void __golang runtime_call512();
void __golang runtime_call1024();
void __golang runtime_call2048();
void __golang runtime_call4096();
void __golang runtime_call8192();
void __golang runtime_call16384();
void __golang runtime_call32768();
void __golang runtime_call65536();
void __golang runtime_call131072();
void __golang runtime_call262144();
void __golang runtime_call524288();
void __golang runtime_call1048576();
void __golang runtime_call2097152();
void __golang runtime_call4194304();
void __golang runtime_call8388608();
void __golang runtime_call16777216();
void __golang runtime_call33554432();
void __golang runtime_call67108864();
void __golang runtime_call134217728();
void __golang runtime_call268435456();
void __golang runtime_call536870912();
void __golang runtime_call1073741824();
void __golang runtime_procyield();
void __golang runtime_publicationBarrier();
void __golang runtime_jmpdefer();
void __golang gosave();
void __golang runtime_asmcgocall();
void __golang runtime_cgocallback_gofunc();
void __golang runtime_setg();
void __golang setg_gcc();
void __golang runtime_stackcheck();
void __golang runtime_getcallerpc();
void __golang runtime_cputicks();
void __golang runtime_ldt0setup();
void __golang runtime_emptyfunc();
void __golang runtime_memhash_varlen();
void __golang runtime_aeshash();
void __golang runtime_aeshashstr();
void __golang runtime_aeshashbody();
void __golang runtime_aeshash32();
void __golang runtime_aeshash64();
void __golang runtime_checkASM();
void __golang runtime_memequal();
void __golang runtime_memequal_varlen();
void __golang runtime_eqstring();
void __golang runtime_memeqbody();
void __golang runtime_cmpstring();
void __golang strings_IndexByte();
void __golang runtime_cmpbody();
void __golang runtime_return0();
void __golang runtime_goexit();
void __golang runtime_prefetcht0();
void __golang runtime_prefetcht1();
void __golang runtime_prefetcht2();
void __golang runtime_prefetchnta();
void __golang runtime_uint32tofloat64();
void __golang runtime_float64touint32();
void __golang runtime_duffzero();
void __golang runtime_duffcopy();
void __golang runtime_memclrNoHeapPointers();
void __golang runtime_memmove();
void __golang rt0_386_linux();
int __cdecl main(int argc, const char **argv, const char **envp);
void __golang runtime_exit();
void __golang runtime_exit1();
void __golang runtime_open();
void __golang runtime_closefd();
void __golang runtime_write();
void __golang runtime_read();
void __golang runtime_usleep();
void __golang runtime_gettid();
void __golang runtime_raise();
void __golang runtime_raiseproc();
void __golang runtime_setitimer();
void __golang runtime_mincore();
void __golang runtime_walltime();
void __golang runtime_nanotime();
void __golang runtime_rtsigprocmask();
void __golang runtime_rt_sigaction();
void __golang runtime_sigfwd();
void __golang runtime_sigtramp();
void __golang runtime_sigreturn();
void __golang runtime_mmap();
void __golang runtime_munmap();
void __golang runtime_madvise();
void __golang runtime_futex();
void __golang runtime_clone();
void __golang runtime_sigaltstack();
void __golang runtime_setldt();
void __golang runtime_osyield();
void __golang runtime_sched_getaffinity();
void __golang runtime_epollcreate();
void __golang runtime_epollcreate1();
void __golang runtime_epollctl();
void __golang runtime_epollwait();
void __golang runtime_closeonexec();
void __golang runtime_sbrk0();
void __golang runtime__mul64by32();
void __golang runtime__div64by32();
uintptr __golang type__hash_runtime__func(runtime__func *p, uintptr h);
bool __golang type__eq_runtime__func(runtime__func *p, runtime__func *q);
uintptr __golang type__hash_runtime_uncommontype(runtime_uncommontype *p, uintptr h);
bool __golang type__eq_runtime_uncommontype(runtime_uncommontype *p, runtime_uncommontype *q);
uintptr __golang type__hash_runtime_modulehash(runtime_modulehash_0 *p, uintptr h);
bool __golang type__eq_runtime_modulehash(runtime_modulehash_0 *p, runtime_modulehash_0 *q);
uintptr __golang type__hash_runtime_Frame(runtime_Frame_0 *p, uintptr h);
bool __golang type__eq_runtime_Frame(runtime_Frame_0 *p, runtime_Frame_0 *q);
uintptr __golang type__hash_runtime_MemStats(runtime_MemStats_0 *p, uintptr h);
bool __golang type__eq_runtime_MemStats(runtime_MemStats_0 *p, runtime_MemStats_0 *q);
uintptr __golang type__hash_runtime_TypeAssertionError(runtime_TypeAssertionError *p, uintptr h);
bool __golang type__eq_runtime_TypeAssertionError(runtime_TypeAssertionError *p, runtime_TypeAssertionError *q);
uintptr __golang type__hash_runtime__panic(runtime__panic *p, uintptr h);
bool __golang type__eq_runtime__panic(runtime__panic *p, runtime__panic *q);
uintptr __golang type__hash_runtime__defer(runtime__defer *p, uintptr h);
bool __golang type__eq_runtime__defer(runtime__defer *p, runtime__defer *q);
uintptr __golang type__hash_runtime_special(runtime_special *p, uintptr h);
bool __golang type__eq_runtime_special(runtime_special *p, runtime_special *q);
uintptr __golang type__hash_runtime_markBits(runtime_markBits_0 *p, uintptr h);
bool __golang type__eq_runtime_markBits(runtime_markBits_0 *p, runtime_markBits_0 *q);
uintptr __golang type__hash_runtime_hchan(runtime_hchan *p, uintptr h);
bool __golang type__eq_runtime_hchan(runtime_hchan *p, runtime_hchan *q);
uintptr __golang type__hash_runtime_cpuProfile(runtime_cpuProfile_0 *p, uintptr h);
bool __golang type__eq_runtime_cpuProfile(runtime_cpuProfile_0 *p, runtime_cpuProfile_0 *q);
uintptr __golang type__hash_runtime_dbgVar(runtime_dbgVar_0 *p, uintptr h);
bool __golang type__eq_runtime_dbgVar(runtime_dbgVar_0 *p, runtime_dbgVar_0 *q);
string __golang runtime___ptr_errorString__Error(runtime_errorString *.this);
uintptr __golang type__hash_runtime_finblock(runtime_finblock *p, uintptr h);
bool __golang type__eq_runtime_finblock(runtime_finblock *p, runtime_finblock *q);
uintptr __golang type__hash_runtime_gcControllerState(runtime_gcControllerState_0 *p, uintptr h);
bool __golang type__eq_runtime_gcControllerState(runtime_gcControllerState_0 *p, runtime_gcControllerState_0 *q);
uintptr __golang type__hash_runtime_mcentral(runtime_mcentral_0 *p, uintptr h);
bool __golang type__eq_runtime_mcentral(runtime_mcentral_0 *p, runtime_mcentral_0 *q);
uintptr __golang type__hash_struct__runtime_mcentral_runtime_mcentral__runtime_pad__32_uint8_(struct_{_runtime_mcentral_runtime_mcentral__runtime_pad__32_uint8_} *p, uintptr h);
bool __golang type__eq_struct__runtime_mcentral_runtime_mcentral__runtime_pad__32_uint8_(struct_{_runtime_mcentral_runtime_mcentral__runtime_pad__32_uint8_} *p, struct_{_runtime_mcentral_runtime_mcentral__runtime_pad__32_uint8_} *q);
uintptr __golang type__hash__134_struct__runtime_mcentral_runtime_mcentral__runtime_pad__32_uint8_(struct_{_runtime_mcentral_runtime_mcentral__runtime_pad__32_uint8_} (*p)[134], uintptr h);
bool __golang type__eq__134_struct__runtime_mcentral_runtime_mcentral__runtime_pad__32_uint8_(struct_{_runtime_mcentral_runtime_mcentral__runtime_pad__32_uint8_} (*p)[134], struct_{_runtime_mcentral_runtime_mcentral__runtime_pad__32_uint8_} (*q)[134]);
uintptr __golang type__hash_runtime_mstats(runtime_mstats_0 *p, uintptr h);
bool __golang type__eq_runtime_mstats(runtime_mstats_0 *p, runtime_mstats_0 *q);
string __golang runtime___ptr_plainError__Error(runtime_plainError *.this);
uintptr __golang type__hash_runtime_sigTabT(runtime_sigTabT_0 *p, uintptr h);
bool __golang type__eq_runtime_sigTabT(runtime_sigTabT_0 *p, runtime_sigTabT_0 *q);
uintptr __golang type__hash_runtime_stackmap(runtime_stackmap *p, uintptr h);
bool __golang type__eq_runtime_stackmap(runtime_stackmap *p, runtime_stackmap *q);
uintptr __golang type__hash_runtime_sweepdata(runtime_sweepdata_0 *p, uintptr h);
bool __golang type__eq_runtime_sweepdata(runtime_sweepdata_0 *p, runtime_sweepdata_0 *q);
uintptr __golang type__hash_runtime_traceStack(runtime_traceStack *p, uintptr h);
bool __golang type__eq_runtime_traceStack(runtime_traceStack *p, runtime_traceStack *q);
uintptr __golang type__hash__14_runtime_dbgVar(runtime_dbgVar_0 (*p)[14], uintptr h);
bool __golang type__eq__14_runtime_dbgVar(runtime_dbgVar_0 (*p)[14], runtime_dbgVar_0 (*q)[14]);
uintptr __golang type__hash__2_string(string (*p)[2], uintptr h);
bool __golang type__eq__2_string(string (*p)[2], string (*q)[2]);
uintptr __golang type__hash__33_float64(float64 (*p)[33], uintptr h);
bool __golang type__eq__33_float64(float64 (*p)[33], float64 (*q)[33]);
uintptr __golang type__hash__3_string(string (*p)[3], uintptr h);
bool __golang type__eq__3_string(string (*p)[3], string (*q)[3]);
uintptr __golang type__hash__4_string(string (*p)[4], uintptr h);
bool __golang type__eq__4_string(string (*p)[4], string (*q)[4]);
uintptr __golang type__hash__5_string(string (*p)[5], uintptr h);
bool __golang type__eq__5_string(string (*p)[5], string (*q)[5]);
uintptr __golang type__hash__65_runtime_sigTabT(runtime_sigTabT (*p)[65], uintptr h);
bool __golang type__eq__65_runtime_sigTabT(runtime_sigTabT (*p)[65], runtime_sigTabT (*q)[65]);
uintptr __golang type__hash__6_string(string (*p)[6], uintptr h);
bool __golang type__eq__6_string(string (*p)[6], string (*q)[6]);
uintptr __golang type__hash__9_string(string (*p)[9], uintptr h);
bool __golang type__eq__9_string(string (*p)[9], string (*q)[9]);
uintptr __golang type__hash_struct__runtime_cycle_uint32__runtime_flushed_bool_(struct_{_runtime_cycle_uint32__runtime_flushed_bool_} *p, uintptr h);
bool __golang type__eq_struct__runtime_cycle_uint32__runtime_flushed_bool_(struct_{_runtime_cycle_uint32__runtime_flushed_bool_} *p, struct_{_runtime_cycle_uint32__runtime_flushed_bool_} *q);
uintptr __golang type__hash_struct__runtime_enabled_bool__runtime_pad__3_uint8__runtime_needed_bool__runtime_cgo_bool__runtime_alignme_uint64_(struct_{_runtime_enabled_bool__runtime_pad__3_uint8__runtime_needed_bool__runtime_cgo_bool__runtime_alignme_uint64_} *p, uintptr h);
bool __golang type__eq_struct__runtime_enabled_bool__runtime_pad__3_uint8__runtime_needed_bool__runtime_cgo_bool__runtime_alignme_uint64_(struct_{_runtime_enabled_bool__runtime_pad__3_uint8__runtime_needed_bool__runtime_cgo_bool__runtime_alignme_uint64_} *p, struct_{_runtime_enabled_bool__runtime_pad__3_uint8__runtime_needed_bool__runtime_cgo_bool__runtime_alignme_uint64_} *q);
uintptr __golang type__hash_struct__runtime_full_runtime_lfstack__runtime_empty_runtime_lfstack__runtime_pad0__64_uint8__runtime_wbufSpans_struct__runtime_lock_runtime_mutex__runtime_free_runtime_mSpanList__runtime_busy_runtime_mSpanList_____uint32__runtime_bytesMarked_uint64__runtime_markrootNext_uint32__runtime_markrootJobs_uint32__runtime_nproc_uint32__runtime_tstart_int64__runtime_nwait_uint32__runtime_ndone_uint32__runtime_alldone_runtime_note__runtime_helperDrainBlock_bool__runtime_nFlushCacheRoots_int__runtime_nDataRoots_int__runtime_nBSSRoots_int__runtime_nSpanRoots_int__runtime_nStackRoots_int__runtime_markrootDone_bool__runtime_startSema_uint32__runtime_markDoneSema_uint32__runtime_bgMarkReady_runtime_note__runtime_bgMarkDone_uint32__runtime_mode_runtime_gcMode__runtime_userForced_bool__runtime_totaltime_int64__runtime_initialHeapLive_uint64__runtime_assistQueue_struct__runtime_lock_runtime_mutex__runtime_head_runtime_guintptr__runtime_tail_runtime_guintptr___runtime_sweepWaiters_struct__runtime_lock_runtime_mutex__runtime_head_runtime_guintptr___runtime_cycles_uint32__runtime_stwprocs_int32__runtime_maxprocs_int32__runtime_tSweepTerm_int64__runtime_tMark_int64__runtime_tMarkTerm_int64__runtime_tEnd_int64__runtime_pauseNS_int64__runtime_pauseStart_int64__runtime_heap0_uint64__runtime_heap1_uint64__runtime_heap2_uint64__runtime_heapGoal_uint64_(struct_{_runtime_full_runtime_lfstack__runtime_empty_runtime_lfstack__runtime_pad0__64_uint8__runtime_wbufSpans_struct_{_runtime_lock_runtime_mutex__runtime_free_runtime_mSpanList__runtime_busy_runtime_mSpanList_}____uint32__runtime_bytesMarked_uint64__runtime_markrootNext_uint32__runtime_markrootJobs_uint32__runtime_nproc_uint32__runtime_tstart_int64__runtime_nwait_uint32__runtime_ndone_uint32__runtime_alldone_runtime_note__runtime_helperDrainBlock_bool__runtime_nFlushCacheRoots_int__runtime_nDataRoots_int__runtime_nBSSRoots_int__runtime_nSpanRoots_int__runtime_nStackRoots_int__runtime_markrootDone_bool__runtime_startSema_uint32__runtime_markDoneSema_uint32__runtime_bgMarkReady_runtime_note__runtime_bgMarkDone_uint32__runtime_mode_runtime_gcMode__runtime_userForced_bool__runtime_totaltime_int64__runtime_initialHeapLive_uint64__runtime_assistQueue_struct_{_runtime_lock_runtime_mutex__runtime_head_runtime_guintptr__runtime_tail_runtime_guintptr_}__runtime_sweepWaiters_struct_{_runtime_lock_runtime_mutex__runtime_head_runtime_guintptr_}__runtime_cycles_uint32__runtime_stwprocs_int32__runtime_maxprocs_int32__runtime_tSweepTerm_int64__runtime_tMark_int64__runtime_tMarkTerm_int64__runtime_tEnd_int64__runtime_pauseNS_int64__runtime_pauseStart_int64__runtime_heap0_uint64__runtime_heap1_uint64__runtime_heap2_uint64__runtime_heapGoal_uint64_} *p, uintptr h);
bool __golang type__eq_struct__runtime_full_runtime_lfstack__runtime_empty_runtime_lfstack__runtime_pad0__64_uint8__runtime_wbufSpans_struct__runtime_lock_runtime_mutex__runtime_free_runtime_mSpanList__runtime_busy_runtime_mSpanList_____uint32__runtime_bytesMarked_uint64__runtime_markrootNext_uint32__runtime_markrootJobs_uint32__runtime_nproc_uint32__runtime_tstart_int64__runtime_nwait_uint32__runtime_ndone_uint32__runtime_alldone_runtime_note__runtime_helperDrainBlock_bool__runtime_nFlushCacheRoots_int__runtime_nDataRoots_int__runtime_nBSSRoots_int__runtime_nSpanRoots_int__runtime_nStackRoots_int__runtime_markrootDone_bool__runtime_startSema_uint32__runtime_markDoneSema_uint32__runtime_bgMarkReady_runtime_note__runtime_bgMarkDone_uint32__runtime_mode_runtime_gcMode__runtime_userForced_bool__runtime_totaltime_int64__runtime_initialHeapLive_uint64__runtime_assistQueue_struct__runtime_lock_runtime_mutex__runtime_head_runtime_guintptr__runtime_tail_runtime_guintptr___runtime_sweepWaiters_struct__runtime_lock_runtime_mutex__runtime_head_runtime_guintptr___runtime_cycles_uint32__runtime_stwprocs_int32__runtime_maxprocs_int32__runtime_tSweepTerm_int64__runtime_tMark_int64__runtime_tMarkTerm_int64__runtime_tEnd_int64__runtime_pauseNS_int64__runtime_pauseStart_int64__runtime_heap0_uint64__runtime_heap1_uint64__runtime_heap2_uint64__runtime_heapGoal_uint64_(struct_{_runtime_full_runtime_lfstack__runtime_empty_runtime_lfstack__runtime_pad0__64_uint8__runtime_wbufSpans_struct_{_runtime_lock_runtime_mutex__runtime_free_runtime_mSpanList__runtime_busy_runtime_mSpanList_}____uint32__runtime_bytesMarked_uint64__runtime_markrootNext_uint32__runtime_markrootJobs_uint32__runtime_nproc_uint32__runtime_tstart_int64__runtime_nwait_uint32__runtime_ndone_uint32__runtime_alldone_runtime_note__runtime_helperDrainBlock_bool__runtime_nFlushCacheRoots_int__runtime_nDataRoots_int__runtime_nBSSRoots_int__runtime_nSpanRoots_int__runtime_nStackRoots_int__runtime_markrootDone_bool__runtime_startSema_uint32__runtime_markDoneSema_uint32__runtime_bgMarkReady_runtime_note__runtime_bgMarkDone_uint32__runtime_mode_runtime_gcMode__runtime_userForced_bool__runtime_totaltime_int64__runtime_initialHeapLive_uint64__runtime_assistQueue_struct_{_runtime_lock_runtime_mutex__runtime_head_runtime_guintptr__runtime_tail_runtime_guintptr_}__runtime_sweepWaiters_struct_{_runtime_lock_runtime_mutex__runtime_head_runtime_guintptr_}__runtime_cycles_uint32__runtime_stwprocs_int32__runtime_maxprocs_int32__runtime_tSweepTerm_int64__runtime_tMark_int64__runtime_tMarkTerm_int64__runtime_tEnd_int64__runtime_pauseNS_int64__runtime_pauseStart_int64__runtime_heap0_uint64__runtime_heap1_uint64__runtime_heap2_uint64__runtime_heapGoal_uint64_} *p, struct_{_runtime_full_runtime_lfstack__runtime_empty_runtime_lfstack__runtime_pad0__64_uint8__runtime_wbufSpans_struct_{_runtime_lock_runtime_mutex__runtime_free_runtime_mSpanList__runtime_busy_runtime_mSpanList_}____uint32__runtime_bytesMarked_uint64__runtime_markrootNext_uint32__runtime_markrootJobs_uint32__runtime_nproc_uint32__runtime_tstart_int64__runtime_nwait_uint32__runtime_ndone_uint32__runtime_alldone_runtime_note__runtime_helperDrainBlock_bool__runtime_nFlushCacheRoots_int__runtime_nDataRoots_int__runtime_nBSSRoots_int__runtime_nSpanRoots_int__runtime_nStackRoots_int__runtime_markrootDone_bool__runtime_startSema_uint32__runtime_markDoneSema_uint32__runtime_bgMarkReady_runtime_note__runtime_bgMarkDone_uint32__runtime_mode_runtime_gcMode__runtime_userForced_bool__runtime_totaltime_int64__runtime_initialHeapLive_uint64__runtime_assistQueue_struct_{_runtime_lock_runtime_mutex__runtime_head_runtime_guintptr__runtime_tail_runtime_guintptr_}__runtime_sweepWaiters_struct_{_runtime_lock_runtime_mutex__runtime_head_runtime_guintptr_}__runtime_cycles_uint32__runtime_stwprocs_int32__runtime_maxprocs_int32__runtime_tSweepTerm_int64__runtime_tMark_int64__runtime_tMarkTerm_int64__runtime_tEnd_int64__runtime_pauseNS_int64__runtime_pauseStart_int64__runtime_heap0_uint64__runtime_heap1_uint64__runtime_heap2_uint64__runtime_heapGoal_uint64_} *q);
uintptr __golang type__hash_struct__runtime_note_runtime_note__runtime_mask__3_uint32__runtime_wanted__3_uint32__runtime_ignored__3_uint32__runtime_recv__3_uint32__runtime_state_uint32__runtime_inuse_bool_(struct_{_runtime_note_runtime_note__runtime_mask__3_uint32__runtime_wanted__3_uint32__runtime_ignored__3_uint32__runtime_recv__3_uint32__runtime_state_uint32__runtime_inuse_bool_} *p, uintptr h);
bool __golang type__eq_struct__runtime_note_runtime_note__runtime_mask__3_uint32__runtime_wanted__3_uint32__runtime_ignored__3_uint32__runtime_recv__3_uint32__runtime_state_uint32__runtime_inuse_bool_(struct_{_runtime_note_runtime_note__runtime_mask__3_uint32__runtime_wanted__3_uint32__runtime_ignored__3_uint32__runtime_recv__3_uint32__runtime_state_uint32__runtime_inuse_bool_} *p, struct_{_runtime_note_runtime_note__runtime_mask__3_uint32__runtime_wanted__3_uint32__runtime_ignored__3_uint32__runtime_recv__3_uint32__runtime_state_uint32__runtime_inuse_bool_} *q);
uintptr __golang type__hash_struct__F_uintptr__runtime_c__ptr_runtime_mcache__runtime_spc_runtime_spanClass_(struct_{_F_uintptr__runtime_c__runtime_mcache__runtime_spc_runtime_spanClass_} *p, uintptr h);
bool __golang type__eq_struct__F_uintptr__runtime_c__ptr_runtime_mcache__runtime_spc_runtime_spanClass_(struct_{_F_uintptr__runtime_c__runtime_mcache__runtime_spc_runtime_spanClass_} *p, struct_{_F_uintptr__runtime_c__runtime_mcache__runtime_spc_runtime_spanClass_} *q);
uintptr __golang type__hash_struct__F_uintptr__runtime_preemptible_bool_(struct_{_F_uintptr__runtime_preemptible_bool_} *p, uintptr h);
bool __golang type__eq_struct__F_uintptr__runtime_preemptible_bool_(struct_{_F_uintptr__runtime_preemptible_bool_} *p, struct_{_F_uintptr__runtime_preemptible_bool_} *q);
uintptr __golang type__hash_struct__F_uintptr__runtime_s__ptr__ptr_runtime_mspan__runtime_h__ptr_runtime_mheap__runtime_npage_uintptr__runtime_spanclass_runtime_spanClass__runtime_large_bool_(struct_{_F_uintptr__runtime_s___runtime_mspan__runtime_h__runtime_mheap__runtime_npage_uintptr__runtime_spanclass_runtime_spanClass__runtime_large_bool_} *p, uintptr h);
bool __golang type__eq_struct__F_uintptr__runtime_s__ptr__ptr_runtime_mspan__runtime_h__ptr_runtime_mheap__runtime_npage_uintptr__runtime_spanclass_runtime_spanClass__runtime_large_bool_(struct_{_F_uintptr__runtime_s___runtime_mspan__runtime_h__runtime_mheap__runtime_npage_uintptr__runtime_spanclass_runtime_spanClass__runtime_large_bool_} *p, struct_{_F_uintptr__runtime_s___runtime_mspan__runtime_h__runtime_mheap__runtime_npage_uintptr__runtime_spanclass_runtime_spanClass__runtime_large_bool_} *q);
uintptr __golang type__hash_struct__F_uintptr__runtime_s__ptr__ptr_runtime_mspan__runtime_size__ptr_uintptr__runtime_needzero_bool__runtime_noscan_bool_(struct_{_F_uintptr__runtime_s___runtime_mspan__runtime_size__uintptr__runtime_needzero_bool__runtime_noscan_bool_} *p, uintptr h);
bool __golang type__eq_struct__F_uintptr__runtime_s__ptr__ptr_runtime_mspan__runtime_size__ptr_uintptr__runtime_needzero_bool__runtime_noscan_bool_(struct_{_F_uintptr__runtime_s___runtime_mspan__runtime_size__uintptr__runtime_needzero_bool__runtime_noscan_bool_} *p, struct_{_F_uintptr__runtime_s___runtime_mspan__runtime_size__uintptr__runtime_needzero_bool__runtime_noscan_bool_} *q);
error_0 __golang errors_New(string text);
string __golang errors___ptr_errorString__Error(errors_errorString *e);
void __golang unicode_utf8_DecodeRuneInString(string s, int32 r, __int32 size);
__int32 __golang unicode_utf8_EncodeRune(__uint8 p, int32 r);
__int32 __golang unicode_utf8_RuneCount(__uint8 p);
void __golang unicode_utf8_RuneCountInString(string s, __int32 n);
string __golang strconv___ptr_decimal__String(strconv_decimal *a);
__int32 __golang strconv_digitZero(__uint8 dst);
void __golang strconv_trim(strconv_decimal *a);
void __golang strconv___ptr_decimal__Assign(strconv_decimal *a, uint64 v);
void __golang strconv_rightShift(strconv_decimal *a, uint k);
bool __golang strconv_prefixIsLessThan(__uint8 b, string s);
void __golang strconv_leftShift(strconv_decimal *a, uint k);
void __golang strconv___ptr_decimal__Shift(strconv_decimal *a, __int32 k);
void __golang strconv___ptr_decimal__Round(strconv_decimal *a, __int32 nd);
void __golang strconv___ptr_decimal__RoundDown(strconv_decimal *a, __int32 nd);
void __golang strconv___ptr_decimal__RoundUp(strconv_decimal *a, __int32 nd);
void __golang strconv___ptr_extFloat__AssignComputeBounds(strconv_extFloat_0 *f, uint64 mant, __int32 exp, bool neg, strconv_floatInfo_0 *flt, strconv_extFloat_0 lower, strconv_extFloat_0 upper);
void __golang strconv___ptr_extFloat__Normalize(strconv_extFloat_0 *f, uint shift);
void __golang strconv___ptr_extFloat__Multiply(strconv_extFloat_0 *f, strconv_extFloat_0 g);
void __golang strconv___ptr_extFloat__frexp10(strconv_extFloat_0 *f, __int32 exp10, __int32 index);
void __golang strconv_frexp10Many(strconv_extFloat_0 *a, strconv_extFloat_0 *b, strconv_extFloat_0 *c, __int32 exp10);
bool __golang strconv___ptr_extFloat__FixedDecimal(strconv_extFloat_0 *f, strconv_decimalSlice *d, __int32 n);
bool __golang strconv_adjustLastDigitFixed(strconv_decimalSlice *d, uint64 num, uint64 den, uint shift, uint64 _);
bool __golang strconv___ptr_extFloat__ShortestDecimal(strconv_extFloat_0 *f, strconv_decimalSlice *d, strconv_extFloat_0 *lower, strconv_extFloat_0 *upper);
bool __golang strconv_adjustLastDigit(strconv_decimalSlice *d, uint64 currentDiff, uint64 targetDiff, uint64 maxDiff, uint64 ulpDecimal, uint64 ulpBinary);
__uint8 __golang strconv_AppendFloat(__uint8 dst, float64 f, uint8 fmt, __int32 prec, __int32 bitSize);
__uint8 __golang strconv_genericFtoa(__uint8 dst, float64 val, uint8 fmt, __int32 prec, __int32 bitSize);
__uint8 __golang strconv_bigFtoa(__uint8 dst, __int32 prec, uint8 fmt, bool neg, uint64 mant, __int32 exp, strconv_floatInfo_0 *flt);
__uint8 __golang strconv_formatDigits(__uint8 dst, bool shortest, bool neg, strconv_decimalSlice_0 digs, __int32 prec, uint8 fmt);
void __golang strconv_roundShortest(strconv_decimal *d, uint64 mant, __int32 exp, strconv_floatInfo_0 *flt);
__uint8 __golang strconv_fmtE(__uint8 dst, bool neg, strconv_decimalSlice_0 d, __int32 prec, uint8 fmt);
__uint8 __golang strconv_fmtF(__uint8 dst, bool neg, strconv_decimalSlice_0 d, __int32 prec);
__uint8 __golang strconv_fmtB(__uint8 dst, bool neg, uint64 mant, __int32 exp, strconv_floatInfo_0 *flt);
string __golang strconv_FormatInt(int64 i, __int32 base);
string __golang strconv_Itoa(__int32 i);
void __golang strconv_formatBits(__uint8 dst, uint64 u, __int32 base, bool neg, bool append_, __uint8 d, string s);
__uint8 __golang strconv_appendQuotedWith(__uint8 buf, string s, uint8 quote, bool ASCIIonly, bool graphicOnly);
__uint8 __golang strconv_appendQuotedRuneWith(__uint8 buf, int32 r, uint8 quote, bool ASCIIonly, bool graphicOnly);
__uint8 __golang strconv_appendEscapedRune(__uint8 buf, int32 r, uint8 quote, bool ASCIIonly, bool graphicOnly);
__uint8 __golang strconv_AppendQuote(__uint8 dst, string s);
__uint8 __golang strconv_AppendQuoteToASCII(__uint8 dst, string s);
__uint8 __golang strconv_AppendQuoteRune(__uint8 dst, int32 r);
__uint8 __golang strconv_AppendQuoteRuneToASCII(__uint8 dst, int32 r);
bool __golang strconv_CanBackquote(string s);
__int32 __golang strconv_bsearch16(__uint16 a, uint16 x);
__int32 __golang strconv_bsearch32(__uint32 a, uint32 x);
bool __golang strconv_IsPrint(int32 r);
bool __golang strconv_isInGraphicList(int32 r);
void __golang strconv_init();
uintptr __golang type__hash_strconv_decimal(strconv_decimal *p, uintptr h);
bool __golang type__eq_strconv_decimal(strconv_decimal *p, strconv_decimal *q);
uintptr __golang type__hash_strconv_extFloat(strconv_extFloat_0 *p, uintptr h);
bool __golang type__eq_strconv_extFloat(strconv_extFloat_0 *p, strconv_extFloat_0 *q);
uintptr __golang type__hash_strconv_leftCheat(strconv_leftCheat_0 *p, uintptr h);
bool __golang type__eq_strconv_leftCheat(strconv_leftCheat_0 *p, strconv_leftCheat_0 *q);
uintptr __golang type__hash__61_strconv_leftCheat(strconv_leftCheat_0 (*p)[61], uintptr h);
bool __golang type__eq__61_strconv_leftCheat(strconv_leftCheat_0 (*p)[61], strconv_leftCheat_0 (*q)[61]);
uintptr __golang type__hash__87_strconv_extFloat(strconv_extFloat (*p)[87], uintptr h);
bool __golang type__eq__87_strconv_extFloat(strconv_extFloat (*p)[87], strconv_extFloat (*q)[87]);
void __golang sync___ptr_Map__Load(sync_Map_0 *m, interface_{} key, interface_{} value, bool ok);
void __golang sync___ptr_entry__load(sync_entry *e, interface_{} value, bool ok);
void __golang sync___ptr_Map__Store(sync_Map_0 *m, interface_{} key, interface_{} value);
bool __golang sync___ptr_entry__tryStore(sync_entry *e, interface_{} *i);
void __golang sync___ptr_entry__unexpungeLocked(sync_entry *e, bool wasExpunged);
void __golang sync___ptr_entry__storeLocked(sync_entry *e, interface_{} *i);
void __golang sync___ptr_Map__LoadOrStore(sync_Map_0 *m, interface_{} key, interface_{} value, interface_{} actual, bool loaded);
void __golang sync___ptr_entry__tryLoadOrStore(sync_entry *e, interface_{} i, interface_{} actual, bool loaded, bool ok);
void __golang sync___ptr_Map__missLocked(sync_Map_0 *m);
void __golang sync___ptr_Map__dirtyLocked(sync_Map_0 *m);
void __golang sync___ptr_entry__tryExpungeLocked(sync_entry *e, bool isExpunged);
void __golang sync___ptr_Mutex__Lock(sync_Mutex_0 *m);
void __golang sync___ptr_Mutex__Unlock(sync_Mutex_0 *m);
void __golang sync___ptr_Once__Do(sync_Once_0 *o, func() f);
void __golang sync___ptr_Pool__Put(sync_Pool_0 *p, interface_{} x);
interface_{} __golang sync___ptr_Pool__Get(sync_Pool_0 *p);
void __golang sync___ptr_Pool__getSlow(sync_Pool_0 *p, interface_{} x);
sync_poolLocal *__golang sync___ptr_Pool__pin(sync_Pool_0 *p);
sync_poolLocal *__golang sync___ptr_Pool__pinSlow(sync_Pool_0 *p);
void __golang sync_poolCleanup();
void __golang sync_init_0();
void __golang sync_init_1();
void __golang sync_init();
void __golang io_init();
void __golang syscall_SetNonblock(__int32 fd, bool nonblocking, error_0 err);
void __golang syscall_init_0();
string __golang syscall_itoa(__int32 val);
string __golang syscall_uitoa(uint val);
retval_809C520 __golang syscall_ByteSliceFromString(string s);
retval_809C620 __golang syscall_BytePtrFromString(string s);
void __golang syscall_Readlink(string path, __uint8 buf, __int32 n, error_0 err);
void __golang syscall_mmap(uintptr addr, uintptr length, __int32 prot, __int32 flags, __int32 fd, int64 offset, uintptr xaddr, error_0 err);
string __golang syscall_Errno_Error(syscall_Errno e);
void __golang syscall_Write(__int32 fd, __uint8 p, __int32 n, error_0 err);
void __golang syscall_readlinkat(__int32 dirfd, string path, __uint8 buf, __int32 n, error_0 err);
void __golang syscall_Close(__int32 fd, error_0 err);
void __golang syscall_fcntl(__int32 fd, __int32 cmd, __int32 arg, __int32 val, error_0 err);
void __golang syscall_write(__int32 fd, __uint8 p, __int32 n, error_0 err);
void __golang syscall_munmap(uintptr addr, uintptr length, error_0 err);
void __golang syscall_mmap2(uintptr addr, uintptr length, __int32 prot, __int32 flags, __int32 fd, uintptr pageOffset, uintptr xaddr, error_0 err);
void __golang syscall_init();
void __golang syscall_Syscall();
void __golang syscall_Syscall6();
string __golang syscall___ptr_Errno__Error(syscall_Errno *.this);
uintptr __golang type__hash__133_string(string (*p)[133], uintptr h);
bool __golang type__eq__133_string(string (*p)[133], string (*q)[133]);
void __golang time_init();
string __golang internal_poll___ptr_TimeoutError__Error(internal_poll_TimeoutError_0 *e);
bool __golang internal_poll___ptr_fdMutex__increfAndClose(internal_poll_fdMutex_0 *mu);
bool __golang internal_poll___ptr_fdMutex__decref(internal_poll_fdMutex_0 *mu);
bool __golang internal_poll___ptr_fdMutex__rwlock(internal_poll_fdMutex_0 *mu, bool read);
bool __golang internal_poll___ptr_fdMutex__rwunlock(internal_poll_fdMutex_0 *mu, bool read);
error_0 __golang internal_poll___ptr_FD__decref(internal_poll_FD_0 *fd);
error_0 __golang internal_poll___ptr_FD__writeLock(internal_poll_FD_0 *fd);
void __golang internal_poll___ptr_FD__writeUnlock(internal_poll_FD_0 *fd);
error_0 __golang internal_poll___ptr_pollDesc__init(internal_poll_pollDesc_0 *pd, internal_poll_FD_0 *fd);
void __golang internal_poll___ptr_pollDesc__close(internal_poll_pollDesc_0 *pd);
void __golang internal_poll___ptr_pollDesc__evict(internal_poll_pollDesc_0 *pd);
error_0 __golang internal_poll___ptr_pollDesc__prepare(internal_poll_pollDesc_0 *pd, __int32 mode, bool isFile);
error_0 __golang internal_poll___ptr_pollDesc__prepareWrite(internal_poll_pollDesc_0 *pd, bool isFile);
error_0 __golang internal_poll___ptr_pollDesc__wait(internal_poll_pollDesc_0 *pd, __int32 mode, bool isFile);
error_0 __golang internal_poll___ptr_pollDesc__waitWrite(internal_poll_pollDesc_0 *pd, bool isFile);
error_0 __golang internal_poll_convertErr(__int32 res, bool isFile);
error_0 __golang internal_poll___ptr_FD__Init(internal_poll_FD_0 *fd, string net, bool pollable);
error_0 __golang internal_poll___ptr_FD__destroy(internal_poll_FD_0 *fd);
error_0 __golang internal_poll___ptr_FD__Close(internal_poll_FD_0 *fd);
retval_809E220 __golang internal_poll___ptr_FD__Write(internal_poll_FD_0 *fd, __uint8 p);
void __golang internal_poll_init();
uintptr __golang type__hash_internal_poll_FD(internal_poll_FD_0 *p, uintptr h);
bool __golang type__eq_internal_poll_FD(internal_poll_FD_0 *p, internal_poll_FD_0 *q);
string __golang os___ptr_PathError__Error(os_PathError *e);
string __golang os___ptr_File__Name(os_File *f);
void __golang os___ptr_File__Write(os_File *f, __uint8 b, __int32 n, error_0 err);
retval_809E9A0 __golang os_Readlink(string name);
os_File *__golang os_NewFile(uintptr fd, string name);
os_File *__golang os_newFile(uintptr fd, string name, bool pollable);
void __golang os_epipecheck(os_File *file, error_0 e);
error_0 __golang os___ptr_file__close(os_file *file);
void __golang os___ptr_File__write(os_File *f, __uint8 b, __int32 n, error_0 err);
void __golang os_init_0();
retval_809F020 __golang os_glob__func1();
void __golang os_init();
uintptr __golang type__hash_os_file(os_file *p, uintptr h);
bool __golang type__eq_os_file(os_file *p, os_file *q);
uintptr __golang type__hash_os_PathError(os_PathError *p, uintptr h);
bool __golang type__eq_os_PathError(os_PathError *p, os_PathError *q);
void __golang unicode_init();
reflect_Value_0 __golang reflect_makeMethodValue(string op, reflect_Value_0 v);
__int32 __golang reflect_name_tagLen(reflect_name_0 n);
void __golang reflect_name_tag(reflect_name_0 n, string s);
string __golang reflect_name_pkgPath(reflect_name_0 n);
reflect_name_0 __golang reflect_newName(string n, string tag, string pkgPath, bool exported);
string __golang reflect_Kind_String(reflect_Kind k);
reflect_nameOff __golang reflect_resolveReflectName(reflect_name_0 n);
reflect_name_0 __golang reflect___ptr_rtype__nameOff(reflect_rtype *t, reflect_nameOff off);
reflect_rtype *__golang reflect___ptr_rtype__typeOff(reflect_rtype *t, reflect_typeOff off);
void *__golang reflect___ptr_rtype__textOff(reflect_rtype *t, reflect_textOff off);
reflect_uncommonType *__golang reflect___ptr_rtype__uncommon(reflect_rtype *t);
string __golang reflect___ptr_rtype__String(reflect_rtype *t);
uintptr __golang reflect___ptr_rtype__Size(reflect_rtype *t);
__int32 __golang reflect___ptr_rtype__Bits(reflect_rtype *t);
__int32 __golang reflect___ptr_rtype__Align(reflect_rtype *t);
__int32 __golang reflect___ptr_rtype__FieldAlign(reflect_rtype *t);
reflect_Kind __golang reflect___ptr_rtype__Kind(reflect_rtype *t);
reflect_rtype *__golang reflect___ptr_rtype__common(reflect_rtype *t);
__reflect_method __golang reflect___ptr_rtype__exportedMethods(reflect_rtype *t);
__int32 __golang reflect___ptr_rtype__NumMethod(reflect_rtype *t);
void __golang reflect___ptr_rtype__Method(reflect_rtype *t, __int32 i, reflect_Method_0 m);
void __golang reflect___ptr_rtype__MethodByName(reflect_rtype *t, string name, reflect_Method_0 m, bool ok);
string __golang reflect___ptr_rtype__PkgPath(reflect_rtype *t);
string __golang reflect___ptr_rtype__Name(reflect_rtype *t);
reflect_ChanDir __golang reflect___ptr_rtype__ChanDir(reflect_rtype *t);
bool __golang reflect___ptr_rtype__IsVariadic(reflect_rtype *t);
reflect_Type_0 __golang reflect___ptr_rtype__Elem(reflect_rtype *t);
reflect_StructField_0 __golang reflect___ptr_rtype__Field(reflect_rtype *t, __int32 i);
reflect_StructField_0 __golang reflect___ptr_rtype__FieldByIndex(reflect_rtype *t, __int index);
retval_80A6730 __golang reflect___ptr_rtype__FieldByName(reflect_rtype *t, string name);
retval_80A6810 __golang reflect___ptr_rtype__FieldByNameFunc(reflect_rtype *t, func(string)_bool match);
reflect_Type_0 __golang reflect___ptr_rtype__In(reflect_rtype *t, __int32 i);
reflect_Type_0 __golang reflect___ptr_rtype__Key(reflect_rtype *t);
__int32 __golang reflect___ptr_rtype__Len(reflect_rtype *t);
__int32 __golang reflect___ptr_rtype__NumField(reflect_rtype *t);
__int32 __golang reflect___ptr_rtype__NumIn(reflect_rtype *t);
__int32 __golang reflect___ptr_rtype__NumOut(reflect_rtype *t);
reflect_Type_0 __golang reflect___ptr_rtype__Out(reflect_rtype *t, __int32 i);
string __golang reflect_ChanDir_String(reflect_ChanDir d);
void __golang reflect___ptr_interfaceType__Method(reflect_interfaceType *t, __int32 i, reflect_Method_0 m);
__int32 __golang reflect___ptr_interfaceType__NumMethod(reflect_interfaceType *t);
void __golang reflect___ptr_interfaceType__MethodByName(reflect_interfaceType *t, string name, reflect_Method_0 m, bool ok);
void __golang reflect___ptr_structType__Field(reflect_structType *t, __int32 i, reflect_StructField_0 f);
void __golang reflect___ptr_structType__FieldByIndex(reflect_structType *t, __int index, reflect_StructField_0 f);
void __golang reflect___ptr_structType__FieldByNameFunc(reflect_structType *t, func(string)_bool match, reflect_StructField_0 result, bool ok);
void __golang reflect___ptr_structType__FieldByName(reflect_structType *t, string name, reflect_StructField_0 f, bool present);
reflect_Type_0 __golang reflect_TypeOf(interface_{} i);
reflect_rtype *__golang reflect___ptr_rtype__ptrTo(reflect_rtype *t);
uint32 __golang reflect_fnv1(uint32 x, __uint8 list);
bool __golang reflect___ptr_rtype__Implements(reflect_rtype *t, reflect_Type_0 u);
bool __golang reflect___ptr_rtype__AssignableTo(reflect_rtype *t, reflect_Type_0 u);
bool __golang reflect___ptr_rtype__ConvertibleTo(reflect_rtype *t, reflect_Type_0 u);
bool __golang reflect___ptr_rtype__Comparable(reflect_rtype *t);
bool __golang reflect_implements(reflect_rtype *T, reflect_rtype *V);
bool __golang reflect_directlyAssignable(reflect_rtype *T, reflect_rtype *V);
bool __golang reflect_haveIdenticalType(reflect_Type_0 T, reflect_Type_0 V, bool cmpTags);
bool __golang reflect_haveIdenticalUnderlyingType(reflect_rtype *T, reflect_rtype *V, bool cmpTags);
___reflect_rtype __golang reflect_typesByString(string s);
reflect_Type_0 __golang reflect_FuncOf(__reflect_Type in, __reflect_Type out, bool variadic);
string __golang reflect_funcStr(reflect_funcType *ft);
void __golang reflect_funcLayout(reflect_rtype *t, reflect_rtype *rcvr, reflect_rtype *frametype, uintptr argSize, uintptr retOffset, reflect_bitVector *stk, sync_Pool_0 *framePool);
void __golang reflect_addTypeBits(reflect_bitVector *bv, uintptr offset, reflect_rtype *t);
void *__golang reflect_Value_pointer(reflect_Value_0 v);
interface_{} __golang reflect_packEface(reflect_Value_0 v);
string __golang reflect___ptr_ValueError__Error(reflect_ValueError *e);
string __golang reflect_methodName();
void __golang reflect_flag_mustBe(reflect_flag f, reflect_Kind expected);
void __golang reflect_flag_mustBeAssignable(reflect_flag f);
bool __golang reflect_Value_Bool(reflect_Value_0 v);
__uint8 __golang reflect_Value_Bytes(reflect_Value_0 v);
__int32 __golang reflect_Value_runes(reflect_Value_0 v);
void __golang reflect_methodReceiver(string op, reflect_Value_0 v, __int32 methodIndex, reflect_rtype *rcvrtype, reflect_rtype *t, void *fn);
void __golang reflect_callMethod(reflect_methodValue *ctxt, void *frame);
complex128 __golang reflect_Value_Complex(reflect_Value_0 v);
reflect_Value_0 __golang reflect_Value_Elem(reflect_Value_0 v);
reflect_Value_0 __golang reflect_Value_Field(reflect_Value_0 v, __int32 i);
float64 __golang reflect_Value_Float(reflect_Value_0 v);
reflect_Value_0 __golang reflect_Value_Index(reflect_Value_0 v, __int32 i);
int64 __golang reflect_Value_Int(reflect_Value_0 v);
bool __golang reflect_Value_CanInterface(reflect_Value_0 v);
void __golang reflect_Value_Interface(reflect_Value_0 v, interface_{} i);
interface_{} __golang reflect_valueInterface(reflect_Value_0 v, bool safe);
bool __golang reflect_Value_IsNil(reflect_Value_0 v);
reflect_Kind __golang reflect_Value_Kind(reflect_Value_0 v);
__int32 __golang reflect_Value_Len(reflect_Value_0 v);
reflect_Value_0 __golang reflect_Value_MapIndex(reflect_Value_0 v, reflect_Value_0 key);
__reflect_Value __golang reflect_Value_MapKeys(reflect_Value_0 v);
__int32 __golang reflect_Value_NumMethod(reflect_Value_0 v);
__int32 __golang reflect_Value_NumField(reflect_Value_0 v);
uintptr __golang reflect_Value_Pointer(reflect_Value_0 v);
void __golang reflect_Value_SetBytes(reflect_Value_0 v, __uint8 x);
void __golang reflect_Value_setRunes(reflect_Value_0 v, __int32 x);
void __golang reflect_Value_SetString(reflect_Value_0 v, string x);
reflect_Value_0 __golang reflect_Value_Slice(reflect_Value_0 v, __int32 i, __int32 j);
string __golang reflect_Value_String(reflect_Value_0 v);
reflect_Type_0 __golang reflect_Value_Type(reflect_Value_0 v);
uint64 __golang reflect_Value_Uint(reflect_Value_0 v);
reflect_Value_0 __golang reflect_ValueOf(interface_{} i);
reflect_Value_0 __golang reflect_Zero(reflect_Type_0 typ);
reflect_Value_0 __golang reflect_New(reflect_Type_0 typ);
reflect_Value_0 __golang reflect_Value_assignTo(reflect_Value_0 v, string context, reflect_rtype *dst, void *target);
func(reflect_Value__reflect_Type)_reflect_Value __golang reflect_convertOp(reflect_rtype *dst, reflect_rtype *src);
reflect_Value_0 __golang reflect_makeInt(reflect_flag f, uint64 bits, reflect_Type_0 t);
reflect_Value_0 __golang reflect_makeFloat(reflect_flag f, float64 v, reflect_Type_0 t);
reflect_Value_0 __golang reflect_makeComplex(reflect_flag f, complex128 v, reflect_Type_0 t);
reflect_Value_0 __golang reflect_makeString(reflect_flag f, string v, reflect_Type_0 t);
reflect_Value_0 __golang reflect_makeBytes(reflect_flag f, __uint8 v, reflect_Type_0 t);
reflect_Value_0 __golang reflect_makeRunes(reflect_flag f, __int32 v, reflect_Type_0 t);
reflect_Value_0 __golang reflect_cvtInt(reflect_Value_0 v, reflect_Type_0 t);
reflect_Value_0 __golang reflect_cvtUint(reflect_Value_0 v, reflect_Type_0 t);
reflect_Value_0 __golang reflect_cvtFloatInt(reflect_Value_0 v, reflect_Type_0 t);
reflect_Value_0 __golang reflect_cvtFloatUint(reflect_Value_0 v, reflect_Type_0 t);
reflect_Value_0 __golang reflect_cvtIntFloat(reflect_Value_0 v, reflect_Type_0 t);
reflect_Value_0 __golang reflect_cvtUintFloat(reflect_Value_0 v, reflect_Type_0 t);
reflect_Value_0 __golang reflect_cvtFloat(reflect_Value_0 v, reflect_Type_0 t);
reflect_Value_0 __golang reflect_cvtComplex(reflect_Value_0 v, reflect_Type_0 t);
reflect_Value_0 __golang reflect_cvtIntString(reflect_Value_0 v, reflect_Type_0 t);
reflect_Value_0 __golang reflect_cvtUintString(reflect_Value_0 v, reflect_Type_0 t);
reflect_Value_0 __golang reflect_cvtBytesString(reflect_Value_0 v, reflect_Type_0 t);
reflect_Value_0 __golang reflect_cvtStringBytes(reflect_Value_0 v, reflect_Type_0 t);
reflect_Value_0 __golang reflect_cvtRunesString(reflect_Value_0 v, reflect_Type_0 t);
reflect_Value_0 __golang reflect_cvtStringRunes(reflect_Value_0 v, reflect_Type_0 t);
reflect_Value_0 __golang reflect_cvtDirect(reflect_Value_0 v, reflect_Type_0 typ);
reflect_Value_0 __golang reflect_cvtT2I(reflect_Value_0 v, reflect_Type_0 typ);
reflect_Value_0 __golang reflect_cvtI2I(reflect_Value_0 v, reflect_Type_0 typ);
bool __golang reflect___ptr_structType__FieldByName_func1(string s);
reflect_Type_0 __golang reflect_FuncOf_func1(reflect_rtype *tt);
interface_{} __golang reflect_funcLayout_func1();
void __golang reflect_init();
void __golang reflect_methodValueCall();
string __golang reflect___ptr_ChanDir__String(reflect_ChanDir *.this);
string __golang reflect___ptr_Kind__String(reflect_Kind *.this);
uintptr __golang type__hash_reflect_uncommonType(reflect_uncommonType *p, uintptr h);
bool __golang type__eq_reflect_uncommonType(reflect_uncommonType *p, reflect_uncommonType *q);
reflect_Kind __golang reflect___ptr_Value__Kind(reflect_Value_0 *.this);
__int32 __golang reflect___ptr_Value__Len(reflect_Value_0 *.this);
__int32 __golang reflect___ptr_Value__NumMethod(reflect_Value_0 *.this);
__int32 __golang reflect___ptr_Value__NumField(reflect_Value_0 *.this);
string __golang reflect___ptr_Value__String(reflect_Value_0 *.this);
uintptr __golang type__hash_reflect_Method(reflect_Method_0 *p, uintptr h);
bool __golang type__eq_reflect_Method(reflect_Method_0 *p, reflect_Method_0 *q);
uintptr __golang type__hash_reflect_ValueError(reflect_ValueError *p, uintptr h);
bool __golang type__eq_reflect_ValueError(reflect_ValueError *p, reflect_ValueError *q);
reflect_uncommonType *__golang reflect___ptr_structType__uncommon(reflect_structType *.this);
string __golang reflect___ptr_structType__String(reflect_structType *.this);
uintptr __golang reflect___ptr_structType__Size(reflect_structType *.this);
__int32 __golang reflect___ptr_structType__Bits(reflect_structType *.this);
__int32 __golang reflect___ptr_structType__Align(reflect_structType *.this);
__int32 __golang reflect___ptr_structType__FieldAlign(reflect_structType *.this);
reflect_Kind __golang reflect___ptr_structType__Kind(reflect_structType *.this);
reflect_rtype *__golang reflect___ptr_structType__common(reflect_structType *.this);
__int32 __golang reflect___ptr_structType__NumMethod(reflect_structType *.this);
void __golang reflect___ptr_structType__Method(reflect_structType *.this, __int32 i, reflect_Method_0 m);
void __golang reflect___ptr_structType__MethodByName(reflect_structType *.this, string name, reflect_Method_0 m, bool ok);
string __golang reflect___ptr_structType__PkgPath(reflect_structType *.this);
string __golang reflect___ptr_structType__Name(reflect_structType *.this);
reflect_ChanDir __golang reflect___ptr_structType__ChanDir(reflect_structType *.this);
bool __golang reflect___ptr_structType__IsVariadic(reflect_structType *.this);
reflect_Type_0 __golang reflect___ptr_structType__Elem(reflect_structType *.this);
reflect_Type_0 __golang reflect___ptr_structType__In(reflect_structType *.this, __int32 i);
reflect_Type_0 __golang reflect___ptr_structType__Key(reflect_structType *.this);
__int32 __golang reflect___ptr_structType__Len(reflect_structType *.this);
__int32 __golang reflect___ptr_structType__NumField(reflect_structType *.this);
__int32 __golang reflect___ptr_structType__NumIn(reflect_structType *.this);
__int32 __golang reflect___ptr_structType__NumOut(reflect_structType *.this);
reflect_Type_0 __golang reflect___ptr_structType__Out(reflect_structType *.this, __int32 i);
bool __golang reflect___ptr_structType__Implements(reflect_structType *.this, reflect_Type_0 u);
bool __golang reflect___ptr_structType__AssignableTo(reflect_structType *.this, reflect_Type_0 u);
bool __golang reflect___ptr_structType__ConvertibleTo(reflect_structType *.this, reflect_Type_0 u);
bool __golang reflect___ptr_structType__Comparable(reflect_structType *.this);
reflect_uncommonType *__golang reflect___ptr_funcType__uncommon(reflect_funcType *.this);
string __golang reflect___ptr_funcType__String(reflect_funcType *.this);
uintptr __golang reflect___ptr_funcType__Size(reflect_funcType *.this);
__int32 __golang reflect___ptr_funcType__Bits(reflect_funcType *.this);
__int32 __golang reflect___ptr_funcType__Align(reflect_funcType *.this);
__int32 __golang reflect___ptr_funcType__FieldAlign(reflect_funcType *.this);
reflect_Kind __golang reflect___ptr_funcType__Kind(reflect_funcType *.this);
reflect_rtype *__golang reflect___ptr_funcType__common(reflect_funcType *.this);
__int32 __golang reflect___ptr_funcType__NumMethod(reflect_funcType *.this);
void __golang reflect___ptr_funcType__Method(reflect_funcType *.this, __int32 i, reflect_Method_0 m);
void __golang reflect___ptr_funcType__MethodByName(reflect_funcType *.this, string name, reflect_Method_0 m, bool ok);
string __golang reflect___ptr_funcType__PkgPath(reflect_funcType *.this);
string __golang reflect___ptr_funcType__Name(reflect_funcType *.this);
reflect_ChanDir __golang reflect___ptr_funcType__ChanDir(reflect_funcType *.this);
bool __golang reflect___ptr_funcType__IsVariadic(reflect_funcType *.this);
reflect_Type_0 __golang reflect___ptr_funcType__Elem(reflect_funcType *.this);
reflect_StructField_0 __golang reflect___ptr_funcType__Field(reflect_funcType *.this, __int32 i);
reflect_StructField_0 __golang reflect___ptr_funcType__FieldByIndex(reflect_funcType *.this, __int index);
retval_80B0D40 __golang reflect___ptr_funcType__FieldByName(reflect_funcType *.this, string name);
retval_80B0D80 __golang reflect___ptr_funcType__FieldByNameFunc(reflect_funcType *.this, func(string)_bool match);
reflect_Type_0 __golang reflect___ptr_funcType__In(reflect_funcType *.this, __int32 i);
reflect_Type_0 __golang reflect___ptr_funcType__Key(reflect_funcType *.this);
__int32 __golang reflect___ptr_funcType__Len(reflect_funcType *.this);
__int32 __golang reflect___ptr_funcType__NumField(reflect_funcType *.this);
__int32 __golang reflect___ptr_funcType__NumIn(reflect_funcType *.this);
__int32 __golang reflect___ptr_funcType__NumOut(reflect_funcType *.this);
reflect_Type_0 __golang reflect___ptr_funcType__Out(reflect_funcType *.this, __int32 i);
bool __golang reflect___ptr_funcType__Implements(reflect_funcType *.this, reflect_Type_0 u);
bool __golang reflect___ptr_funcType__AssignableTo(reflect_funcType *.this, reflect_Type_0 u);
bool __golang reflect___ptr_funcType__ConvertibleTo(reflect_funcType *.this, reflect_Type_0 u);
bool __golang reflect___ptr_funcType__Comparable(reflect_funcType *.this);
reflect_uncommonType *__golang reflect___ptr_funcTypeFixed128__uncommon(reflect_funcTypeFixed128 *.this);
string __golang reflect___ptr_funcTypeFixed128__String(reflect_funcTypeFixed128 *.this);
uintptr __golang reflect___ptr_funcTypeFixed128__Size(reflect_funcTypeFixed128 *.this);
__int32 __golang reflect___ptr_funcTypeFixed128__Bits(reflect_funcTypeFixed128 *.this);
__int32 __golang reflect___ptr_funcTypeFixed128__Align(reflect_funcTypeFixed128 *.this);
__int32 __golang reflect___ptr_funcTypeFixed128__FieldAlign(reflect_funcTypeFixed128 *.this);
reflect_Kind __golang reflect___ptr_funcTypeFixed128__Kind(reflect_funcTypeFixed128 *.this);
reflect_rtype *__golang reflect___ptr_funcTypeFixed128__common(reflect_funcTypeFixed128 *.this);
__int32 __golang reflect___ptr_funcTypeFixed128__NumMethod(reflect_funcTypeFixed128 *.this);
void __golang reflect___ptr_funcTypeFixed128__Method(reflect_funcTypeFixed128 *.this, __int32 i, reflect_Method_0 m);
void __golang reflect___ptr_funcTypeFixed128__MethodByName(reflect_funcTypeFixed128 *.this, string name, reflect_Method_0 m, bool ok);
string __golang reflect___ptr_funcTypeFixed128__PkgPath(reflect_funcTypeFixed128 *.this);
string __golang reflect___ptr_funcTypeFixed128__Name(reflect_funcTypeFixed128 *.this);
reflect_ChanDir __golang reflect___ptr_funcTypeFixed128__ChanDir(reflect_funcTypeFixed128 *.this);
bool __golang reflect___ptr_funcTypeFixed128__IsVariadic(reflect_funcTypeFixed128 *.this);
reflect_Type_0 __golang reflect___ptr_funcTypeFixed128__Elem(reflect_funcTypeFixed128 *.this);
reflect_StructField_0 __golang reflect___ptr_funcTypeFixed128__Field(reflect_funcTypeFixed128 *.this, __int32 i);
reflect_StructField_0 __golang reflect___ptr_funcTypeFixed128__FieldByIndex(reflect_funcTypeFixed128 *.this, __int index);
retval_80B13E0 __golang reflect___ptr_funcTypeFixed128__FieldByName(reflect_funcTypeFixed128 *.this, string name);
retval_80B1420 __golang reflect___ptr_funcTypeFixed128__FieldByNameFunc(reflect_funcTypeFixed128 *.this, func(string)_bool match);
reflect_Type_0 __golang reflect___ptr_funcTypeFixed128__In(reflect_funcTypeFixed128 *.this, __int32 i);
reflect_Type_0 __golang reflect___ptr_funcTypeFixed128__Key(reflect_funcTypeFixed128 *.this);
__int32 __golang reflect___ptr_funcTypeFixed128__Len(reflect_funcTypeFixed128 *.this);
__int32 __golang reflect___ptr_funcTypeFixed128__NumField(reflect_funcTypeFixed128 *.this);
__int32 __golang reflect___ptr_funcTypeFixed128__NumIn(reflect_funcTypeFixed128 *.this);
__int32 __golang reflect___ptr_funcTypeFixed128__NumOut(reflect_funcTypeFixed128 *.this);
reflect_Type_0 __golang reflect___ptr_funcTypeFixed128__Out(reflect_funcTypeFixed128 *.this, __int32 i);
bool __golang reflect___ptr_funcTypeFixed128__Implements(reflect_funcTypeFixed128 *.this, reflect_Type_0 u);
bool __golang reflect___ptr_funcTypeFixed128__AssignableTo(reflect_funcTypeFixed128 *.this, reflect_Type_0 u);
bool __golang reflect___ptr_funcTypeFixed128__ConvertibleTo(reflect_funcTypeFixed128 *.this, reflect_Type_0 u);
bool __golang reflect___ptr_funcTypeFixed128__Comparable(reflect_funcTypeFixed128 *.this);
reflect_uncommonType *__golang reflect___ptr_funcTypeFixed16__uncommon(reflect_funcTypeFixed16 *.this);
string __golang reflect___ptr_funcTypeFixed16__String(reflect_funcTypeFixed16 *.this);
uintptr __golang reflect___ptr_funcTypeFixed16__Size(reflect_funcTypeFixed16 *.this);
__int32 __golang reflect___ptr_funcTypeFixed16__Bits(reflect_funcTypeFixed16 *.this);
__int32 __golang reflect___ptr_funcTypeFixed16__Align(reflect_funcTypeFixed16 *.this);
__int32 __golang reflect___ptr_funcTypeFixed16__FieldAlign(reflect_funcTypeFixed16 *.this);
reflect_Kind __golang reflect___ptr_funcTypeFixed16__Kind(reflect_funcTypeFixed16 *.this);
reflect_rtype *__golang reflect___ptr_funcTypeFixed16__common(reflect_funcTypeFixed16 *.this);
__int32 __golang reflect___ptr_funcTypeFixed16__NumMethod(reflect_funcTypeFixed16 *.this);
void __golang reflect___ptr_funcTypeFixed16__Method(reflect_funcTypeFixed16 *.this, __int32 i, reflect_Method_0 m);
void __golang reflect___ptr_funcTypeFixed16__MethodByName(reflect_funcTypeFixed16 *.this, string name, reflect_Method_0 m, bool ok);
string __golang reflect___ptr_funcTypeFixed16__PkgPath(reflect_funcTypeFixed16 *.this);
string __golang reflect___ptr_funcTypeFixed16__Name(reflect_funcTypeFixed16 *.this);
reflect_ChanDir __golang reflect___ptr_funcTypeFixed16__ChanDir(reflect_funcTypeFixed16 *.this);
bool __golang reflect___ptr_funcTypeFixed16__IsVariadic(reflect_funcTypeFixed16 *.this);
reflect_Type_0 __golang reflect___ptr_funcTypeFixed16__Elem(reflect_funcTypeFixed16 *.this);
reflect_StructField_0 __golang reflect___ptr_funcTypeFixed16__Field(reflect_funcTypeFixed16 *.this, __int32 i);
reflect_StructField_0 __golang reflect___ptr_funcTypeFixed16__FieldByIndex(reflect_funcTypeFixed16 *.this, __int index);
retval_80B1A80 __golang reflect___ptr_funcTypeFixed16__FieldByName(reflect_funcTypeFixed16 *.this, string name);
retval_80B1AC0 __golang reflect___ptr_funcTypeFixed16__FieldByNameFunc(reflect_funcTypeFixed16 *.this, func(string)_bool match);
reflect_Type_0 __golang reflect___ptr_funcTypeFixed16__In(reflect_funcTypeFixed16 *.this, __int32 i);
reflect_Type_0 __golang reflect___ptr_funcTypeFixed16__Key(reflect_funcTypeFixed16 *.this);
__int32 __golang reflect___ptr_funcTypeFixed16__Len(reflect_funcTypeFixed16 *.this);
__int32 __golang reflect___ptr_funcTypeFixed16__NumField(reflect_funcTypeFixed16 *.this);
__int32 __golang reflect___ptr_funcTypeFixed16__NumIn(reflect_funcTypeFixed16 *.this);
__int32 __golang reflect___ptr_funcTypeFixed16__NumOut(reflect_funcTypeFixed16 *.this);
reflect_Type_0 __golang reflect___ptr_funcTypeFixed16__Out(reflect_funcTypeFixed16 *.this, __int32 i);
bool __golang reflect___ptr_funcTypeFixed16__Implements(reflect_funcTypeFixed16 *.this, reflect_Type_0 u);
bool __golang reflect___ptr_funcTypeFixed16__AssignableTo(reflect_funcTypeFixed16 *.this, reflect_Type_0 u);
bool __golang reflect___ptr_funcTypeFixed16__ConvertibleTo(reflect_funcTypeFixed16 *.this, reflect_Type_0 u);
bool __golang reflect___ptr_funcTypeFixed16__Comparable(reflect_funcTypeFixed16 *.this);
reflect_uncommonType *__golang reflect___ptr_funcTypeFixed32__uncommon(reflect_funcTypeFixed32 *.this);
string __golang reflect___ptr_funcTypeFixed32__String(reflect_funcTypeFixed32 *.this);
uintptr __golang reflect___ptr_funcTypeFixed32__Size(reflect_funcTypeFixed32 *.this);
__int32 __golang reflect___ptr_funcTypeFixed32__Bits(reflect_funcTypeFixed32 *.this);
__int32 __golang reflect___ptr_funcTypeFixed32__Align(reflect_funcTypeFixed32 *.this);
__int32 __golang reflect___ptr_funcTypeFixed32__FieldAlign(reflect_funcTypeFixed32 *.this);
reflect_Kind __golang reflect___ptr_funcTypeFixed32__Kind(reflect_funcTypeFixed32 *.this);
reflect_rtype *__golang reflect___ptr_funcTypeFixed32__common(reflect_funcTypeFixed32 *.this);
__int32 __golang reflect___ptr_funcTypeFixed32__NumMethod(reflect_funcTypeFixed32 *.this);
void __golang reflect___ptr_funcTypeFixed32__Method(reflect_funcTypeFixed32 *.this, __int32 i, reflect_Method_0 m);
void __golang reflect___ptr_funcTypeFixed32__MethodByName(reflect_funcTypeFixed32 *.this, string name, reflect_Method_0 m, bool ok);
string __golang reflect___ptr_funcTypeFixed32__PkgPath(reflect_funcTypeFixed32 *.this);
string __golang reflect___ptr_funcTypeFixed32__Name(reflect_funcTypeFixed32 *.this);
reflect_ChanDir __golang reflect___ptr_funcTypeFixed32__ChanDir(reflect_funcTypeFixed32 *.this);
bool __golang reflect___ptr_funcTypeFixed32__IsVariadic(reflect_funcTypeFixed32 *.this);
reflect_Type_0 __golang reflect___ptr_funcTypeFixed32__Elem(reflect_funcTypeFixed32 *.this);
reflect_StructField_0 __golang reflect___ptr_funcTypeFixed32__Field(reflect_funcTypeFixed32 *.this, __int32 i);
reflect_StructField_0 __golang reflect___ptr_funcTypeFixed32__FieldByIndex(reflect_funcTypeFixed32 *.this, __int index);
retval_80B2120 __golang reflect___ptr_funcTypeFixed32__FieldByName(reflect_funcTypeFixed32 *.this, string name);
retval_80B2160 __golang reflect___ptr_funcTypeFixed32__FieldByNameFunc(reflect_funcTypeFixed32 *.this, func(string)_bool match);
reflect_Type_0 __golang reflect___ptr_funcTypeFixed32__In(reflect_funcTypeFixed32 *.this, __int32 i);
reflect_Type_0 __golang reflect___ptr_funcTypeFixed32__Key(reflect_funcTypeFixed32 *.this);
__int32 __golang reflect___ptr_funcTypeFixed32__Len(reflect_funcTypeFixed32 *.this);
__int32 __golang reflect___ptr_funcTypeFixed32__NumField(reflect_funcTypeFixed32 *.this);
__int32 __golang reflect___ptr_funcTypeFixed32__NumIn(reflect_funcTypeFixed32 *.this);
__int32 __golang reflect___ptr_funcTypeFixed32__NumOut(reflect_funcTypeFixed32 *.this);
reflect_Type_0 __golang reflect___ptr_funcTypeFixed32__Out(reflect_funcTypeFixed32 *.this, __int32 i);
bool __golang reflect___ptr_funcTypeFixed32__Implements(reflect_funcTypeFixed32 *.this, reflect_Type_0 u);
bool __golang reflect___ptr_funcTypeFixed32__AssignableTo(reflect_funcTypeFixed32 *.this, reflect_Type_0 u);
bool __golang reflect___ptr_funcTypeFixed32__ConvertibleTo(reflect_funcTypeFixed32 *.this, reflect_Type_0 u);
bool __golang reflect___ptr_funcTypeFixed32__Comparable(reflect_funcTypeFixed32 *.this);
reflect_uncommonType *__golang reflect___ptr_funcTypeFixed4__uncommon(reflect_funcTypeFixed4 *.this);
string __golang reflect___ptr_funcTypeFixed4__String(reflect_funcTypeFixed4 *.this);
uintptr __golang reflect___ptr_funcTypeFixed4__Size(reflect_funcTypeFixed4 *.this);
__int32 __golang reflect___ptr_funcTypeFixed4__Bits(reflect_funcTypeFixed4 *.this);
__int32 __golang reflect___ptr_funcTypeFixed4__Align(reflect_funcTypeFixed4 *.this);
__int32 __golang reflect___ptr_funcTypeFixed4__FieldAlign(reflect_funcTypeFixed4 *.this);
reflect_Kind __golang reflect___ptr_funcTypeFixed4__Kind(reflect_funcTypeFixed4 *.this);
reflect_rtype *__golang reflect___ptr_funcTypeFixed4__common(reflect_funcTypeFixed4 *.this);
__int32 __golang reflect___ptr_funcTypeFixed4__NumMethod(reflect_funcTypeFixed4 *.this);
void __golang reflect___ptr_funcTypeFixed4__Method(reflect_funcTypeFixed4 *.this, __int32 i, reflect_Method_0 m);
void __golang reflect___ptr_funcTypeFixed4__MethodByName(reflect_funcTypeFixed4 *.this, string name, reflect_Method_0 m, bool ok);
string __golang reflect___ptr_funcTypeFixed4__PkgPath(reflect_funcTypeFixed4 *.this);
string __golang reflect___ptr_funcTypeFixed4__Name(reflect_funcTypeFixed4 *.this);
reflect_ChanDir __golang reflect___ptr_funcTypeFixed4__ChanDir(reflect_funcTypeFixed4 *.this);
bool __golang reflect___ptr_funcTypeFixed4__IsVariadic(reflect_funcTypeFixed4 *.this);
reflect_Type_0 __golang reflect___ptr_funcTypeFixed4__Elem(reflect_funcTypeFixed4 *.this);
reflect_StructField_0 __golang reflect___ptr_funcTypeFixed4__Field(reflect_funcTypeFixed4 *.this, __int32 i);
reflect_StructField_0 __golang reflect___ptr_funcTypeFixed4__FieldByIndex(reflect_funcTypeFixed4 *.this, __int index);
retval_80B27C0 __golang reflect___ptr_funcTypeFixed4__FieldByName(reflect_funcTypeFixed4 *.this, string name);
retval_80B2800 __golang reflect___ptr_funcTypeFixed4__FieldByNameFunc(reflect_funcTypeFixed4 *.this, func(string)_bool match);
reflect_Type_0 __golang reflect___ptr_funcTypeFixed4__In(reflect_funcTypeFixed4 *.this, __int32 i);
reflect_Type_0 __golang reflect___ptr_funcTypeFixed4__Key(reflect_funcTypeFixed4 *.this);
__int32 __golang reflect___ptr_funcTypeFixed4__Len(reflect_funcTypeFixed4 *.this);
__int32 __golang reflect___ptr_funcTypeFixed4__NumField(reflect_funcTypeFixed4 *.this);
__int32 __golang reflect___ptr_funcTypeFixed4__NumIn(reflect_funcTypeFixed4 *.this);
__int32 __golang reflect___ptr_funcTypeFixed4__NumOut(reflect_funcTypeFixed4 *.this);
reflect_Type_0 __golang reflect___ptr_funcTypeFixed4__Out(reflect_funcTypeFixed4 *.this, __int32 i);
bool __golang reflect___ptr_funcTypeFixed4__Implements(reflect_funcTypeFixed4 *.this, reflect_Type_0 u);
bool __golang reflect___ptr_funcTypeFixed4__AssignableTo(reflect_funcTypeFixed4 *.this, reflect_Type_0 u);
bool __golang reflect___ptr_funcTypeFixed4__ConvertibleTo(reflect_funcTypeFixed4 *.this, reflect_Type_0 u);
bool __golang reflect___ptr_funcTypeFixed4__Comparable(reflect_funcTypeFixed4 *.this);
reflect_uncommonType *__golang reflect___ptr_funcTypeFixed64__uncommon(reflect_funcTypeFixed64 *.this);
string __golang reflect___ptr_funcTypeFixed64__String(reflect_funcTypeFixed64 *.this);
uintptr __golang reflect___ptr_funcTypeFixed64__Size(reflect_funcTypeFixed64 *.this);
__int32 __golang reflect___ptr_funcTypeFixed64__Bits(reflect_funcTypeFixed64 *.this);
__int32 __golang reflect___ptr_funcTypeFixed64__Align(reflect_funcTypeFixed64 *.this);
__int32 __golang reflect___ptr_funcTypeFixed64__FieldAlign(reflect_funcTypeFixed64 *.this);
reflect_Kind __golang reflect___ptr_funcTypeFixed64__Kind(reflect_funcTypeFixed64 *.this);
reflect_rtype *__golang reflect___ptr_funcTypeFixed64__common(reflect_funcTypeFixed64 *.this);
__int32 __golang reflect___ptr_funcTypeFixed64__NumMethod(reflect_funcTypeFixed64 *.this);
void __golang reflect___ptr_funcTypeFixed64__Method(reflect_funcTypeFixed64 *.this, __int32 i, reflect_Method_0 m);
void __golang reflect___ptr_funcTypeFixed64__MethodByName(reflect_funcTypeFixed64 *.this, string name, reflect_Method_0 m, bool ok);
string __golang reflect___ptr_funcTypeFixed64__PkgPath(reflect_funcTypeFixed64 *.this);
string __golang reflect___ptr_funcTypeFixed64__Name(reflect_funcTypeFixed64 *.this);
reflect_ChanDir __golang reflect___ptr_funcTypeFixed64__ChanDir(reflect_funcTypeFixed64 *.this);
bool __golang reflect___ptr_funcTypeFixed64__IsVariadic(reflect_funcTypeFixed64 *.this);
reflect_Type_0 __golang reflect___ptr_funcTypeFixed64__Elem(reflect_funcTypeFixed64 *.this);
reflect_StructField_0 __golang reflect___ptr_funcTypeFixed64__Field(reflect_funcTypeFixed64 *.this, __int32 i);
reflect_StructField_0 __golang reflect___ptr_funcTypeFixed64__FieldByIndex(reflect_funcTypeFixed64 *.this, __int index);
retval_80B2E60 __golang reflect___ptr_funcTypeFixed64__FieldByName(reflect_funcTypeFixed64 *.this, string name);
retval_80B2EA0 __golang reflect___ptr_funcTypeFixed64__FieldByNameFunc(reflect_funcTypeFixed64 *.this, func(string)_bool match);
reflect_Type_0 __golang reflect___ptr_funcTypeFixed64__In(reflect_funcTypeFixed64 *.this, __int32 i);
reflect_Type_0 __golang reflect___ptr_funcTypeFixed64__Key(reflect_funcTypeFixed64 *.this);
__int32 __golang reflect___ptr_funcTypeFixed64__Len(reflect_funcTypeFixed64 *.this);
__int32 __golang reflect___ptr_funcTypeFixed64__NumField(reflect_funcTypeFixed64 *.this);
__int32 __golang reflect___ptr_funcTypeFixed64__NumIn(reflect_funcTypeFixed64 *.this);
__int32 __golang reflect___ptr_funcTypeFixed64__NumOut(reflect_funcTypeFixed64 *.this);
reflect_Type_0 __golang reflect___ptr_funcTypeFixed64__Out(reflect_funcTypeFixed64 *.this, __int32 i);
bool __golang reflect___ptr_funcTypeFixed64__Implements(reflect_funcTypeFixed64 *.this, reflect_Type_0 u);
bool __golang reflect___ptr_funcTypeFixed64__AssignableTo(reflect_funcTypeFixed64 *.this, reflect_Type_0 u);
bool __golang reflect___ptr_funcTypeFixed64__ConvertibleTo(reflect_funcTypeFixed64 *.this, reflect_Type_0 u);
bool __golang reflect___ptr_funcTypeFixed64__Comparable(reflect_funcTypeFixed64 *.this);
reflect_uncommonType *__golang reflect___ptr_funcTypeFixed8__uncommon(reflect_funcTypeFixed8 *.this);
string __golang reflect___ptr_funcTypeFixed8__String(reflect_funcTypeFixed8 *.this);
uintptr __golang reflect___ptr_funcTypeFixed8__Size(reflect_funcTypeFixed8 *.this);
__int32 __golang reflect___ptr_funcTypeFixed8__Bits(reflect_funcTypeFixed8 *.this);
__int32 __golang reflect___ptr_funcTypeFixed8__Align(reflect_funcTypeFixed8 *.this);
__int32 __golang reflect___ptr_funcTypeFixed8__FieldAlign(reflect_funcTypeFixed8 *.this);
reflect_Kind __golang reflect___ptr_funcTypeFixed8__Kind(reflect_funcTypeFixed8 *.this);
reflect_rtype *__golang reflect___ptr_funcTypeFixed8__common(reflect_funcTypeFixed8 *.this);
__int32 __golang reflect___ptr_funcTypeFixed8__NumMethod(reflect_funcTypeFixed8 *.this);
void __golang reflect___ptr_funcTypeFixed8__Method(reflect_funcTypeFixed8 *.this, __int32 i, reflect_Method_0 m);
void __golang reflect___ptr_funcTypeFixed8__MethodByName(reflect_funcTypeFixed8 *.this, string name, reflect_Method_0 m, bool ok);
string __golang reflect___ptr_funcTypeFixed8__PkgPath(reflect_funcTypeFixed8 *.this);
string __golang reflect___ptr_funcTypeFixed8__Name(reflect_funcTypeFixed8 *.this);
reflect_ChanDir __golang reflect___ptr_funcTypeFixed8__ChanDir(reflect_funcTypeFixed8 *.this);
bool __golang reflect___ptr_funcTypeFixed8__IsVariadic(reflect_funcTypeFixed8 *.this);
reflect_Type_0 __golang reflect___ptr_funcTypeFixed8__Elem(reflect_funcTypeFixed8 *.this);
reflect_StructField_0 __golang reflect___ptr_funcTypeFixed8__Field(reflect_funcTypeFixed8 *.this, __int32 i);
reflect_StructField_0 __golang reflect___ptr_funcTypeFixed8__FieldByIndex(reflect_funcTypeFixed8 *.this, __int index);
retval_80B3500 __golang reflect___ptr_funcTypeFixed8__FieldByName(reflect_funcTypeFixed8 *.this, string name);
retval_80B3540 __golang reflect___ptr_funcTypeFixed8__FieldByNameFunc(reflect_funcTypeFixed8 *.this, func(string)_bool match);
reflect_Type_0 __golang reflect___ptr_funcTypeFixed8__In(reflect_funcTypeFixed8 *.this, __int32 i);
reflect_Type_0 __golang reflect___ptr_funcTypeFixed8__Key(reflect_funcTypeFixed8 *.this);
__int32 __golang reflect___ptr_funcTypeFixed8__Len(reflect_funcTypeFixed8 *.this);
__int32 __golang reflect___ptr_funcTypeFixed8__NumField(reflect_funcTypeFixed8 *.this);
__int32 __golang reflect___ptr_funcTypeFixed8__NumIn(reflect_funcTypeFixed8 *.this);
__int32 __golang reflect___ptr_funcTypeFixed8__NumOut(reflect_funcTypeFixed8 *.this);
reflect_Type_0 __golang reflect___ptr_funcTypeFixed8__Out(reflect_funcTypeFixed8 *.this, __int32 i);
bool __golang reflect___ptr_funcTypeFixed8__Implements(reflect_funcTypeFixed8 *.this, reflect_Type_0 u);
bool __golang reflect___ptr_funcTypeFixed8__AssignableTo(reflect_funcTypeFixed8 *.this, reflect_Type_0 u);
bool __golang reflect___ptr_funcTypeFixed8__ConvertibleTo(reflect_funcTypeFixed8 *.this, reflect_Type_0 u);
bool __golang reflect___ptr_funcTypeFixed8__Comparable(reflect_funcTypeFixed8 *.this);
reflect_uncommonType *__golang reflect___ptr_interfaceType__uncommon(reflect_interfaceType *.this);
string __golang reflect___ptr_interfaceType__String(reflect_interfaceType *.this);
uintptr __golang reflect___ptr_interfaceType__Size(reflect_interfaceType *.this);
__int32 __golang reflect___ptr_interfaceType__Bits(reflect_interfaceType *.this);
__int32 __golang reflect___ptr_interfaceType__Align(reflect_interfaceType *.this);
__int32 __golang reflect___ptr_interfaceType__FieldAlign(reflect_interfaceType *.this);
reflect_Kind __golang reflect___ptr_interfaceType__Kind(reflect_interfaceType *.this);
reflect_rtype *__golang reflect___ptr_interfaceType__common(reflect_interfaceType *.this);
string __golang reflect___ptr_interfaceType__PkgPath(reflect_interfaceType *.this);
string __golang reflect___ptr_interfaceType__Name(reflect_interfaceType *.this);
reflect_ChanDir __golang reflect___ptr_interfaceType__ChanDir(reflect_interfaceType *.this);
bool __golang reflect___ptr_interfaceType__IsVariadic(reflect_interfaceType *.this);
reflect_Type_0 __golang reflect___ptr_interfaceType__Elem(reflect_interfaceType *.this);
reflect_StructField_0 __golang reflect___ptr_interfaceType__Field(reflect_interfaceType *.this, __int32 i);
reflect_StructField_0 __golang reflect___ptr_interfaceType__FieldByIndex(reflect_interfaceType *.this, __int index);
retval_80B3AF0 __golang reflect___ptr_interfaceType__FieldByName(reflect_interfaceType *.this, string name);
retval_80B3B30 __golang reflect___ptr_interfaceType__FieldByNameFunc(reflect_interfaceType *.this, func(string)_bool match);
reflect_Type_0 __golang reflect___ptr_interfaceType__In(reflect_interfaceType *.this, __int32 i);
reflect_Type_0 __golang reflect___ptr_interfaceType__Key(reflect_interfaceType *.this);
__int32 __golang reflect___ptr_interfaceType__Len(reflect_interfaceType *.this);
__int32 __golang reflect___ptr_interfaceType__NumField(reflect_interfaceType *.this);
__int32 __golang reflect___ptr_interfaceType__NumIn(reflect_interfaceType *.this);
__int32 __golang reflect___ptr_interfaceType__NumOut(reflect_interfaceType *.this);
reflect_Type_0 __golang reflect___ptr_interfaceType__Out(reflect_interfaceType *.this, __int32 i);
bool __golang reflect___ptr_interfaceType__Implements(reflect_interfaceType *.this, reflect_Type_0 u);
bool __golang reflect___ptr_interfaceType__AssignableTo(reflect_interfaceType *.this, reflect_Type_0 u);
bool __golang reflect___ptr_interfaceType__ConvertibleTo(reflect_interfaceType *.this, reflect_Type_0 u);
bool __golang reflect___ptr_interfaceType__Comparable(reflect_interfaceType *.this);
reflect_uncommonType *__golang reflect___ptr_ptrType__uncommon(reflect_ptrType *.this);
string __golang reflect___ptr_ptrType__String(reflect_ptrType *.this);
uintptr __golang reflect___ptr_ptrType__Size(reflect_ptrType *.this);
__int32 __golang reflect___ptr_ptrType__Bits(reflect_ptrType *.this);
__int32 __golang reflect___ptr_ptrType__Align(reflect_ptrType *.this);
__int32 __golang reflect___ptr_ptrType__FieldAlign(reflect_ptrType *.this);
reflect_Kind __golang reflect___ptr_ptrType__Kind(reflect_ptrType *.this);
reflect_rtype *__golang reflect___ptr_ptrType__common(reflect_ptrType *.this);
__int32 __golang reflect___ptr_ptrType__NumMethod(reflect_ptrType *.this);
void __golang reflect___ptr_ptrType__Method(reflect_ptrType *.this, __int32 i, reflect_Method_0 m);
void __golang reflect___ptr_ptrType__MethodByName(reflect_ptrType *.this, string name, reflect_Method_0 m, bool ok);
string __golang reflect___ptr_ptrType__PkgPath(reflect_ptrType *.this);
string __golang reflect___ptr_ptrType__Name(reflect_ptrType *.this);
reflect_ChanDir __golang reflect___ptr_ptrType__ChanDir(reflect_ptrType *.this);
bool __golang reflect___ptr_ptrType__IsVariadic(reflect_ptrType *.this);
reflect_Type_0 __golang reflect___ptr_ptrType__Elem(reflect_ptrType *.this);
reflect_StructField_0 __golang reflect___ptr_ptrType__Field(reflect_ptrType *.this, __int32 i);
reflect_StructField_0 __golang reflect___ptr_ptrType__FieldByIndex(reflect_ptrType *.this, __int index);
retval_80B4190 __golang reflect___ptr_ptrType__FieldByName(reflect_ptrType *.this, string name);
retval_80B41D0 __golang reflect___ptr_ptrType__FieldByNameFunc(reflect_ptrType *.this, func(string)_bool match);
reflect_Type_0 __golang reflect___ptr_ptrType__In(reflect_ptrType *.this, __int32 i);
reflect_Type_0 __golang reflect___ptr_ptrType__Key(reflect_ptrType *.this);
__int32 __golang reflect___ptr_ptrType__Len(reflect_ptrType *.this);
__int32 __golang reflect___ptr_ptrType__NumField(reflect_ptrType *.this);
__int32 __golang reflect___ptr_ptrType__NumIn(reflect_ptrType *.this);
__int32 __golang reflect___ptr_ptrType__NumOut(reflect_ptrType *.this);
reflect_Type_0 __golang reflect___ptr_ptrType__Out(reflect_ptrType *.this, __int32 i);
bool __golang reflect___ptr_ptrType__Implements(reflect_ptrType *.this, reflect_Type_0 u);
bool __golang reflect___ptr_ptrType__AssignableTo(reflect_ptrType *.this, reflect_Type_0 u);
bool __golang reflect___ptr_ptrType__ConvertibleTo(reflect_ptrType *.this, reflect_Type_0 u);
bool __golang reflect___ptr_ptrType__Comparable(reflect_ptrType *.this);
reflect_uncommonType *__golang reflect___ptr_sliceType__uncommon(reflect_sliceType *.this);
string __golang reflect___ptr_sliceType__String(reflect_sliceType *.this);
uintptr __golang reflect___ptr_sliceType__Size(reflect_sliceType *.this);
__int32 __golang reflect___ptr_sliceType__Bits(reflect_sliceType *.this);
__int32 __golang reflect___ptr_sliceType__Align(reflect_sliceType *.this);
__int32 __golang reflect___ptr_sliceType__FieldAlign(reflect_sliceType *.this);
reflect_Kind __golang reflect___ptr_sliceType__Kind(reflect_sliceType *.this);
reflect_rtype *__golang reflect___ptr_sliceType__common(reflect_sliceType *.this);
__int32 __golang reflect___ptr_sliceType__NumMethod(reflect_sliceType *.this);
void __golang reflect___ptr_sliceType__Method(reflect_sliceType *.this, __int32 i, reflect_Method_0 m);
void __golang reflect___ptr_sliceType__MethodByName(reflect_sliceType *.this, string name, reflect_Method_0 m, bool ok);
string __golang reflect___ptr_sliceType__PkgPath(reflect_sliceType *.this);
string __golang reflect___ptr_sliceType__Name(reflect_sliceType *.this);
reflect_ChanDir __golang reflect___ptr_sliceType__ChanDir(reflect_sliceType *.this);
bool __golang reflect___ptr_sliceType__IsVariadic(reflect_sliceType *.this);
reflect_Type_0 __golang reflect___ptr_sliceType__Elem(reflect_sliceType *.this);
reflect_StructField_0 __golang reflect___ptr_sliceType__Field(reflect_sliceType *.this, __int32 i);
reflect_StructField_0 __golang reflect___ptr_sliceType__FieldByIndex(reflect_sliceType *.this, __int index);
retval_80B4830 __golang reflect___ptr_sliceType__FieldByName(reflect_sliceType *.this, string name);
retval_80B4870 __golang reflect___ptr_sliceType__FieldByNameFunc(reflect_sliceType *.this, func(string)_bool match);
reflect_Type_0 __golang reflect___ptr_sliceType__In(reflect_sliceType *.this, __int32 i);
reflect_Type_0 __golang reflect___ptr_sliceType__Key(reflect_sliceType *.this);
__int32 __golang reflect___ptr_sliceType__Len(reflect_sliceType *.this);
__int32 __golang reflect___ptr_sliceType__NumField(reflect_sliceType *.this);
__int32 __golang reflect___ptr_sliceType__NumIn(reflect_sliceType *.this);
__int32 __golang reflect___ptr_sliceType__NumOut(reflect_sliceType *.this);
reflect_Type_0 __golang reflect___ptr_sliceType__Out(reflect_sliceType *.this, __int32 i);
bool __golang reflect___ptr_sliceType__Implements(reflect_sliceType *.this, reflect_Type_0 u);
bool __golang reflect___ptr_sliceType__AssignableTo(reflect_sliceType *.this, reflect_Type_0 u);
bool __golang reflect___ptr_sliceType__ConvertibleTo(reflect_sliceType *.this, reflect_Type_0 u);
bool __golang reflect___ptr_sliceType__Comparable(reflect_sliceType *.this);
uintptr __golang type__hash__27_string(string (*p)[27], uintptr h);
bool __golang type__eq__27_string(string (*p)[27], string (*q)[27]);
uintptr __golang type__hash_struct__reflect_b_bool__reflect_x_interface__(struct_{_reflect_b_bool__reflect_x_interface_{}_} *p, uintptr h);
bool __golang type__eq_struct__reflect_b_bool__reflect_x_interface__(struct_{_reflect_b_bool__reflect_x_interface_{}_} *p, struct_{_reflect_b_bool__reflect_x_interface_{}_} *q);
uintptr __golang type__hash_struct__F_uintptr__reflect_name_string_(struct_{_F_uintptr__reflect_name_string_} *p, uintptr h);
bool __golang type__eq_struct__F_uintptr__reflect_name_string_(struct_{_F_uintptr__reflect_name_string_} *p, struct_{_F_uintptr__reflect_name_string_} *q);
void __golang fmt___ptr_fmt__writePadding(fmt_fmt *f, __int32 n);
void __golang fmt___ptr_fmt__pad(fmt_fmt *f, __uint8 b);
void __golang fmt___ptr_fmt__padString(fmt_fmt *f, string s);
void __golang fmt___ptr_fmt__fmt_boolean(fmt_fmt *f, bool v);
void __golang fmt___ptr_fmt__fmt_unicode(fmt_fmt *f, uint64 u);
void __golang fmt___ptr_fmt__fmt_integer(fmt_fmt *f, uint64 u, __int32 base, bool isSigned, string digits);
string __golang fmt___ptr_fmt__truncate(fmt_fmt *f, string s);
void __golang fmt___ptr_fmt__fmt_s(fmt_fmt *f, string s);
void __golang fmt___ptr_fmt__fmt_sbx(fmt_fmt *f, string s, __uint8 b, string digits);
void __golang fmt___ptr_fmt__fmt_sx(fmt_fmt *f, string s, string digits);
void __golang fmt___ptr_fmt__fmt_bx(fmt_fmt *f, __uint8 b, string digits);
void __golang fmt___ptr_fmt__fmt_q(fmt_fmt *f, string s);
void __golang fmt___ptr_fmt__fmt_c(fmt_fmt *f, uint64 c);
void __golang fmt___ptr_fmt__fmt_qc(fmt_fmt *f, uint64 c);
void __golang fmt___ptr_fmt__fmt_float(fmt_fmt *f, float64 v, __int32 size, int32 verb, __int32 prec);
void __golang fmt___ptr_buffer__WriteRune(fmt_buffer *bp_0, int32 r);
fmt_pp *__golang fmt_newPrinter();
void __golang fmt___ptr_pp__free(fmt_pp *p);
void __golang fmt___ptr_pp__Width(fmt_pp *p, __int32 wid, bool ok);
void __golang fmt___ptr_pp__Precision(fmt_pp *p, __int32 prec, bool ok);
bool __golang fmt___ptr_pp__Flag(fmt_pp *p, __int32 b);
void __golang fmt___ptr_pp__Write(fmt_pp *p, __uint8 b, __int32 ret, error_0 err);
void __golang fmt_Fprintln(io_Writer_0 w, __interface_{} a, __int32 n, error_0 err);
void __golang fmt_Println(__interface_{} a, __int32 n, error_0 err);
reflect_Value_0 __golang fmt_getField(reflect_Value_0 v, __int32 i);
void __golang fmt___ptr_pp__unknownType(fmt_pp *p, reflect_Value_0 v);
void __golang fmt___ptr_pp__badVerb(fmt_pp *p, int32 verb);
void __golang fmt___ptr_pp__fmtBool(fmt_pp *p, bool v, int32 verb);
void __golang fmt___ptr_pp__fmt0x64(fmt_pp *p, uint64 v, bool leading0x);
void __golang fmt___ptr_pp__fmtInteger(fmt_pp *p, uint64 v, bool isSigned, int32 verb);
void __golang fmt___ptr_pp__fmtFloat(fmt_pp *p, float64 v, __int32 size, int32 verb);
void __golang fmt___ptr_pp__fmtComplex(fmt_pp *p, complex128 v, __int32 size, int32 verb);
void __golang fmt___ptr_pp__fmtString(fmt_pp *p, string v, int32 verb);
void __golang fmt___ptr_pp__fmtBytes(fmt_pp *p, __uint8 v, int32 verb, string typeString);
void __golang fmt___ptr_pp__fmtPointer(fmt_pp *p, reflect_Value_0 value, int32 verb);
void __golang fmt___ptr_pp__catchPanic(fmt_pp *p, interface_{} arg, int32 verb);
void __golang fmt___ptr_pp__handleMethods(fmt_pp *p, int32 verb, bool handled);
void __golang fmt___ptr_pp__printArg(fmt_pp *p, interface_{} arg, int32 verb);
void __golang fmt___ptr_pp__printValue(fmt_pp *p, reflect_Value_0 value, int32 verb, __int32 depth);
void __golang fmt___ptr_pp__doPrintln(fmt_pp *p, __interface_{} a);
interface_{} __golang fmt_glob__func1();
void __golang fmt_init();
uintptr __golang type__hash_fmt_fmt(fmt_fmt *p, uintptr h);
bool __golang type__eq_fmt_fmt(fmt_fmt *p, fmt_fmt *q);
void __cdecl main_main();
void __golang main_init();
void off_80E7B18(void); // idb
void callback(runtime_stkframe *, void *, bool *); // idb
void unlockf(runtime_g *, void *, bool *); // idb
void off_80E7C00(runtime_p *); // idb
void off_80E7C74(void); // idb
void off_80E7C80(void); // idb
void off_80E7C88(runtime_g *, void *, bool *); // idb
void off_80E7CA0(runtime_g *, void *, bool *); // idb
void off_80E7CE8(void); // idb
void off_80E7D0C(void); // idb
void runtime_data(__int32, error_0 *); // idb

//-------------------------------------------------------------------------
// Data declarations

_UNKNOWN loc_808FD50; // weak
_UNKNOWN loc_808FD5C; // weak
_UNKNOWN loc_808FD60; // weak
_UNKNOWN loc_808FD6D; // weak
_UNKNOWN loc_808FD70; // weak
_UNKNOWN loc_808FD77; // weak
_UNKNOWN loc_808FD80; // weak
_UNKNOWN loc_808FD82; // weak
_UNKNOWN loc_808FD83; // weak
_UNKNOWN loc_808FD84; // weak
_UNKNOWN loc_808FD85; // weak
_UNKNOWN loc_808FD86; // weak
_UNKNOWN loc_808FD87; // weak
_UNKNOWN loc_808FD88; // weak
_UNKNOWN loc_808FD89; // weak
_UNKNOWN loc_808FD8A; // weak
_UNKNOWN loc_808FD8B; // weak
_UNKNOWN loc_8090160; // weak
_UNKNOWN loc_80901EC; // weak
_UNKNOWN loc_809021E; // weak
_UNKNOWN loc_8090228; // weak
_UNKNOWN loc_809023C; // weak
_UNKNOWN loc_8090246; // weak
_UNKNOWN loc_8090250; // weak
_UNKNOWN loc_809025A; // weak
_UNKNOWN loc_8090264; // weak
_UNKNOWN loc_809026E; // weak
_UNKNOWN loc_8090278; // weak
const runtime__type_0 stru_80C7140 =
{
  4u,
  4u,
  2764280960u,
  0u,
  4u,
  4u,
  54u,
  (runtime_typeAlg *)0x8144340,
  &runtime_gcbits__,
  19402,
  30080
}; // idb
const runtime__type_0 stru_80C76C0 =
{
  4u,
  4u,
  3808936823u,
  0u,
  4u,
  4u,
  54u,
  (runtime_typeAlg *)0x8144340,
  &runtime_gcbits__,
  13202,
  30400
}; // idb
const runtime__type_0 stru_80C7CC0 =
{
  4u,
  4u,
  1851581772u,
  0u,
  4u,
  4u,
  54u,
  (runtime_typeAlg *)0x8144340,
  &runtime_gcbits__,
  24077,
  0
}; // idb
const runtime__type_0 stru_80C8440 =
{
  4u,
  4u,
  1067908116u,
  0u,
  4u,
  4u,
  54u,
  (runtime_typeAlg *)0x8144340,
  &runtime_gcbits__,
  18604,
  31168
}; // idb
_UNKNOWN unk_80C8F40; // weak
const runtime__type_0 stru_80C9000 =
{
  12u,
  4u,
  364040836u,
  2u,
  4u,
  4u,
  23u,
  &runtime_algarray,
  &runtime_gcbits__,
  21200,
  0
}; // idb
const runtime__type_0 stru_80C9100 =
{
  12u,
  4u,
  2736952062u,
  2u,
  4u,
  4u,
  23u,
  &runtime_algarray,
  &runtime_gcbits__,
  20073,
  33088
}; // idb
const runtime__type_0 stru_80C9200 =
{
  12u,
  4u,
  3369655395u,
  2u,
  4u,
  4u,
  23u,
  &runtime_algarray,
  &runtime_gcbits__,
  27342,
  33152
}; // idb
const runtime__type_0 stru_80C9640 =
{
  12u,
  4u,
  1934436886u,
  2u,
  4u,
  4u,
  23u,
  &runtime_algarray,
  &runtime_gcbits__,
  9689,
  33408
}; // idb
const runtime__type_0 stru_80C9840 =
{
  12u,
  4u,
  4227348762u,
  2u,
  4u,
  4u,
  23u,
  &runtime_algarray,
  &runtime_gcbits__,
  21300,
  0
}; // idb
const runtime__type_0 stru_80CA1C0 =
{
  12u,
  4u,
  942571231u,
  2u,
  4u,
  4u,
  23u,
  &runtime_algarray,
  &runtime_gcbits__,
  9711,
  33664
}; // idb
const runtime__type_0 stru_80CA300 =
{
  12u,
  4u,
  468139078u,
  2u,
  4u,
  4u,
  23u,
  &runtime_algarray,
  &runtime_gcbits__,
  21360,
  33792
}; // idb
_UNKNOWN unk_80CA340; // weak
const runtime_chantype_0 stru_80CA640 =
{
  {
    4u,
    4u,
    3722397880u,
    2u,
    4u,
    4u,
    50u,
    (runtime_typeAlg *)0x8144340,
    &runtime_gcbits__,
    13150,
    0
  },
  &unk_80CE760,
  3u
}; // idb
const runtime_chantype_0 stru_80CA680 =
{
  {
    4u,
    4u,
    1909151121u,
    2u,
    4u,
    4u,
    50u,
    (runtime_typeAlg *)0x8144340,
    &runtime_gcbits__,
    11477,
    0
  },
  &stru_80CEB60,
  3u
}; // idb
_UNKNOWN unk_80CAAC0; // weak
const runtime__type_0 stru_80CADA0 =
{
  0u,
  0u,
  3832192389u,
  2u,
  4u,
  4u,
  145u,
  (runtime_typeAlg *)0x8144328,
  &runtime_gcbits__,
  18179,
  0
}; // idb
const runtime__type_0 stru_80CAE20 =
{
  0u,
  0u,
  1236613318u,
  2u,
  4u,
  4u,
  145u,
  (runtime_typeAlg *)0x8144328,
  &runtime_gcbits__,
  12773,
  0
}; // idb
const runtime__type_0 stru_80CBC20 =
{
  12u,
  4u,
  3986164218u,
  2u,
  4u,
  4u,
  17u,
  &runtime_algarray,
  &runtime_gcbits__,
  14802,
  31936
}; // idb
const runtime__type_0 stru_80CBC60 =
{
  4u,
  0u,
  1420998061u,
  2u,
  4u,
  4u,
  145u,
  (runtime_typeAlg *)0x8144340,
  &runtime_gcbits__,
  8164,
  0
}; // idb
const runtime__type_0 stru_80CBDA0 =
{
  4u,
  0u,
  3264111002u,
  2u,
  4u,
  4u,
  145u,
  (runtime_typeAlg *)0x8144340,
  &runtime_gcbits__,
  14816,
  0
}; // idb
const runtime__type_0 stru_80CBE60 =
{
  4u,
  4u,
  2980487035u,
  2u,
  4u,
  4u,
  49u,
  (runtime_typeAlg *)0x8144340,
  &runtime_gcbits__,
  22121,
  32000
}; // idb
const runtime__type_0 stru_80CC320 =
{
  8u,
  8u,
  1358791475u,
  2u,
  4u,
  4u,
  17u,
  (runtime_typeAlg *)0x8144348,
  &unk_80F03E6,
  25037,
  0
}; // idb
const interface_{} finalizer = { (runtime__type_0 *)4, (void *)4 }; // idb
_UNKNOWN unk_80CE760; // weak
_UNKNOWN unk_80CE7A0; // weak
_UNKNOWN unk_80CE7E0; // weak
_UNKNOWN unk_80CE820; // weak
_UNKNOWN unk_80CE860; // weak
const runtime__type_0 stru_80CEB60 =
{
  4u,
  0u,
  4149441018u,
  7u,
  4u,
  4u,
  130u,
  (runtime_typeAlg *)0x8144340,
  &runtime_gcbits__,
  1335,
  34624
}; // idb
_UNKNOWN unk_80CEBA0; // weak
_UNKNOWN unk_80CEBE0; // weak
_UNKNOWN unk_80CEC20; // weak
_UNKNOWN unk_80CEC60; // weak
const runtime__type_0 stru_80CECA0 =
{
  8u,
  8u,
  413161447u,
  2u,
  4u,
  4u,
  20u,
  (runtime_typeAlg *)0x8144368,
  &unk_80F03E6,
  17440,
  34944
}; // idb
const interface_{} t = { (runtime__type_0 *)8, (void *)4 }; // idb
_UNKNOWN unk_80CF220; // weak
_UNKNOWN unk_80CF260; // weak
const runtime__type_0 stru_80CF2A0 =
{
  4u,
  0u,
  3494570045u,
  7u,
  4u,
  4u,
  138u,
  (runtime_typeAlg *)0x8144340,
  &runtime_gcbits__,
  8244,
  44352
}; // idb
_UNKNOWN unk_80CF2E0; // weak
const runtime__type_0 i =
{
  1u,
  0u,
  1715356255u,
  7u,
  1u,
  1u,
  136u,
  (runtime_typeAlg *)0x8144330,
  &runtime_gcbits__,
  6950,
  44480
}; // idb
const runtime__type_0 et =
{
  4u,
  0u,
  3175798674u,
  7u,
  4u,
  4u,
  140u,
  (runtime_typeAlg *)0x8144340,
  &runtime_gcbits__,
  9788,
  44544
}; // idb
const runtime__type_0 x =
{
  4u,
  4u,
  459064525u,
  7u,
  4u,
  4u,
  58u,
  (runtime_typeAlg *)0x8144340,
  &runtime_gcbits__,
  19690,
  44864
}; // idb
const interface_{} stru_80CF900 = { (runtime__type_0 *)4, (void *)4 }; // idb
const interface_{} stru_80CF940 = { (runtime__type_0 *)4, (void *)4 }; // idb
const runtime_maptype_0 stru_80CF980 =
{
  {
    4u,
    4u,
    325509123u,
    2u,
    4u,
    4u,
    53u,
    &runtime_algarray,
    &runtime_gcbits__,
    29453,
    0
  },
  &unk_80DE480,
  &unk_80CE760,
  &unk_80D4940,
  &unk_80D93E0,
  4u,
  false,
  1u,
  false,
  52u,
  true,
  false
}; // idb
const runtime_maptype_0 stru_80CF9C0 =
{
  {
    4u,
    4u,
    3184467666u,
    2u,
    4u,
    4u,
    53u,
    &runtime_algarray,
    &runtime_gcbits__,
    29231,
    0
  },
  &unk_80DE480,
  &stru_80CEB60,
  &unk_80D49A0,
  &unk_80D9480,
  4u,
  false,
  4u,
  false,
  76u,
  true,
  false
}; // idb
const runtime_maptype_0 stru_80CFA00 =
{
  {
    4u,
    4u,
    2652914775u,
    2u,
    4u,
    4u,
    53u,
    &runtime_algarray,
    &runtime_gcbits__,
    23835,
    0
  },
  &unk_80C8DC0,
  &stru_80CA1C0,
  &unk_80D4A00,
  &unk_80D9520,
  4u,
  false,
  12u,
  false,
  140u,
  true,
  false
}; // idb
const runtime_maptype_0 stru_80CFA40 =
{
  {
    4u,
    4u,
    1377550894u,
    2u,
    4u,
    4u,
    53u,
    &runtime_algarray,
    &runtime_gcbits__,
    28648,
    0
  },
  &unk_80CEBE0,
  &x,
  &unk_80D4A60,
  &unk_80D95C0,
  4u,
  false,
  4u,
  false,
  76u,
  true,
  false
}; // idb
const runtime_maptype_0 stru_80CFA80 =
{
  {
    4u,
    4u,
    2465202076u,
    2u,
    4u,
    4u,
    53u,
    &runtime_algarray,
    &runtime_gcbits__,
    29485,
    35904
  },
  &stru_80CECA0,
  &unk_80DA0E0,
  &unk_80D4AC0,
  &unk_80D9660,
  8u,
  false,
  4u,
  false,
  108u,
  false,
  true
}; // idb
const runtime_maptype_0 stru_80CFAC0 =
{
  {
    4u,
    4u,
    3954996903u,
    2u,
    4u,
    4u,
    53u,
    &runtime_algarray,
    &runtime_gcbits__,
    29827,
    0
  },
  &unk_80D3740,
  &unk_80CF1E0,
  &unk_80D4B20,
  &unk_80D9700,
  8u,
  false,
  0u,
  false,
  76u,
  true,
  false
}; // idb
const runtime_maptype_0 stru_80CFB00 =
{
  {
    4u,
    4u,
    2330605815u,
    2u,
    4u,
    4u,
    53u,
    &runtime_algarray,
    &runtime_gcbits__,
    50319,
    35968
  },
  &unk_80CF120,
  &stru_80D8DA0,
  &unk_80D4B80,
  &unk_80D97A0,
  4u,
  false,
  4u,
  false,
  76u,
  true,
  false
}; // idb
const runtime_maptype_0 stru_80CFB40 =
{
  {
    4u,
    4u,
    3863021588u,
    2u,
    4u,
    4u,
    53u,
    &runtime_algarray,
    &runtime_gcbits__,
    29583,
    0
  },
  &t,
  &unk_80C8EC0,
  &unk_80D4BE0,
  &unk_80D9840,
  8u,
  false,
  4u,
  false,
  108u,
  true,
  true
}; // idb
const runtime_maptype_0 stru_80CFB80 =
{
  {
    4u,
    4u,
    3177232828u,
    2u,
    4u,
    4u,
    53u,
    &runtime_algarray,
    &runtime_gcbits__,
    21420,
    0
  },
  &t,
  &unk_80CEC20,
  &unk_80D4C40,
  &unk_80D98E0,
  8u,
  false,
  8u,
  false,
  140u,
  true,
  true
}; // idb
const runtime_maptype_0 stru_80CFC00 =
{
  {
    4u,
    4u,
    4146183672u,
    2u,
    4u,
    4u,
    53u,
    &runtime_algarray,
    &runtime_gcbits__,
    29262,
    0
  },
  &stru_80CF2A0,
  &unk_80C90C0,
  &unk_80D4D00,
  &unk_80D9A20,
  4u,
  false,
  12u,
  false,
  140u,
  true,
  false
}; // idb
const runtime_maptype_0 stru_80CFC40 =
{
  {
    4u,
    4u,
    480867334u,
    2u,
    4u,
    4u,
    53u,
    &runtime_algarray,
    &runtime_gcbits__,
    28676,
    0
  },
  &x,
  &unk_80CEBE0,
  &unk_80D4D60,
  &unk_80D9AC0,
  4u,
  false,
  4u,
  false,
  76u,
  true,
  false
}; // idb
const runtime__type_0 stru_80CFEE0 =
{
  128u,
  0u,
  486687829u,
  7u,
  4u,
  4u,
  145u,
  &off_80BEB10,
  &runtime_gcbits__,
  23967,
  37696
}; // idb
const interface_{} obj = { (runtime__type_0 *)4, (void *)4 }; // idb
const interface_{} stru_80D0760 = { (runtime__type_0 *)4, (void *)4 }; // idb
const runtime_interfacetype_0 iface =
{
  {
    8u,
    8u,
    235953867u,
    7u,
    4u,
    4u,
    20u,
    (runtime_typeAlg *)0x8144360,
    &unk_80F03E6,
    6914,
    34048
  },
  { NULL },
  { &unk_80D0EA0, 1, 1 }
}; // idb
const runtime_interfacetype_0 arg0 =
{
  {
    8u,
    8u,
    4126641951u,
    7u,
    4u,
    4u,
    20u,
    (runtime_typeAlg *)0x8144360,
    &unk_80F03E6,
    18264,
    34240
  },
  { &unk_80BE30C },
  { &unk_80D0F00, 1, 1 }
}; // idb
const runtime_interfacetype_0 stru_80D0F20 =
{
  {
    8u,
    8u,
    3631212225u,
    7u,
    4u,
    4u,
    20u,
    (runtime_typeAlg *)0x8144360,
    &unk_80F03E6,
    19276,
    34304
  },
  { &unk_80BE30C },
  { &unk_80D0F60, 1, 1 }
}; // idb
const runtime_interfacetype_0 stru_80D0F80 =
{
  {
    8u,
    8u,
    2278602350u,
    7u,
    4u,
    4u,
    20u,
    (runtime_typeAlg *)0x8144360,
    &unk_80F03E6,
    17392,
    34432
  },
  { &unk_80BE30C },
  { &unk_80D0FC0, 1, 1 }
}; // idb
const runtime_interfacetype_0 inter =
{
  {
    8u,
    8u,
    2041828263u,
    7u,
    4u,
    4u,
    20u,
    (runtime_typeAlg *)0x8144360,
    &unk_80F03E6,
    21820,
    41984
  },
  { &unk_80BFFA0 },
  { &unk_80D1080, 1, 1 }
}; // idb
const runtime__type_0 stru_80D10A0 =
{
  8u,
  0u,
  2571319131u,
  2u,
  4u,
  4u,
  153u,
  (runtime_typeAlg *)0x8144348,
  &runtime_gcbits__,
  50057,
  43200
}; // idb
const runtime__type_0 stru_80D1160 =
{
  8u,
  8u,
  2325181254u,
  2u,
  4u,
  4u,
  25u,
  (runtime_typeAlg *)0x8144348,
  &unk_80F03E5,
  52360,
  43328
}; // idb
const runtime__type_0 stru_80D1920 =
{
  8u,
  4u,
  285164608u,
  7u,
  4u,
  4u,
  25u,
  (runtime_typeAlg *)0x8144358,
  &runtime_gcbits__,
  23791,
  75136
}; // idb
const runtime__type_0 stru_80D1CE0 =
{
  4u,
  4u,
  4023412453u,
  7u,
  4u,
  4u,
  57u,
  (runtime_typeAlg *)0x8144340,
  &runtime_gcbits__,
  15110,
  114912
}; // idb
const runtime__type_0 want =
{
  8u,
  4u,
  1275879321u,
  7u,
  4u,
  4u,
  24u,
  (runtime_typeAlg *)0x8144358,
  &runtime_gcbits__,
  26049,
  82304
}; // idb
const interface_{} e = { (runtime__type_0 *)8, (void *)4 }; // idb
const interface_{} stru_80D20C0 = { (runtime__type_0 *)4, (void *)4 }; // idb
const runtime__type_0 stru_80D2120 =
{
  4u,
  4u,
  2228099522u,
  1u,
  4u,
  4u,
  54u,
  (runtime_typeAlg *)0x8144340,
  &runtime_gcbits__,
  17568,
  30272
}; // idb
const runtime__type_0 stru_80D3140 =
{
  12u,
  4u,
  2446902162u,
  7u,
  4u,
  4u,
  25u,
  &off_80BE990,
  &runtime_gcbits__,
  23857,
  75616
}; // idb
const runtime__type_0 stru_80D31A0 =
{
  16u,
  8u,
  1636722911u,
  7u,
  4u,
  4u,
  25u,
  &runtime_algarray,
  &unk_80F03E5,
  22520,
  75712
}; // idb
const runtime__type_0 stru_80D3200 =
{
  16u,
  8u,
  619000936u,
  7u,
  4u,
  4u,
  25u,
  &runtime_algarray,
  &unk_80F03E6,
  22541,
  36288
}; // idb
const runtime__type_0 stru_80D3260 = { 548u, 548u, 1979357136u, 7u, 4u, 4u, 25u, &off_80BED58, &a0_7, 28704, 133600 }; // idb
const runtime__type_0 stru_80D32C0 = { 100u, 100u, 4260178344u, 7u, 4u, 4u, 25u, &off_80BEAC8, &a0_4, 28347, 134304 }; // idb
const runtime__type_0 stru_80D3320 = { 164u, 164u, 3245818182u, 7u, 4u, 4u, 25u, &off_80BEB88, &a0_5, 28374, 135008 }; // idb
const runtime__type_0 stru_80D3380 = { 52u, 52u, 1479615569u, 7u, 4u, 4u, 25u, &off_80BED38, &a0_2, 28003, 135712 }; // idb
const runtime__type_0 stru_80D33E0 = { 292u, 292u, 1510211280u, 7u, 4u, 4u, 25u, &off_80BEC60, &a0_6, 28401, 136416 }; // idb
const runtime__type_0 stru_80D3440 = { 68u, 68u, 882278421u, 7u, 4u, 4u, 25u, &off_80BEDF8, &a0_3, 28029, 137120 }; // idb
const interface_{} stru_80D3500 = { (runtime__type_0 *)8, (void *)8 }; // idb
const runtime__type_0 stru_80D3560 = { 36u, 36u, 2367834493u, 7u, 4u, 4u, 25u, &off_80BEC90, &a0_1, 20244, 130208 }; // idb
const runtime__type_0 stru_80D3620 =
{
  8u,
  4u,
  2988225718u,
  7u,
  4u,
  4u,
  25u,
  (runtime_typeAlg *)0x8144348,
  &runtime_gcbits__,
  26928,
  36736
}; // idb
const runtime__type_0 stru_80D36E0 =
{
  68u,
  48u,
  3052733540u,
  7u,
  4u,
  4u,
  25u,
  &runtime_algarray,
  &asc_80F0410,
  19384,
  75904
}; // idb
const runtime__type_0 stru_80D3C20 =
{
  12u,
  12u,
  345568025u,
  7u,
  4u,
  4u,
  25u,
  &off_80BEAF0,
  &asc_80F03EA,
  21620,
  39872
}; // idb
const runtime__type_0 stru_80D3CE0 =
{
  8u,
  0u,
  984831691u,
  7u,
  4u,
  4u,
  153u,
  (runtime_typeAlg *)0x8144348,
  &runtime_gcbits__,
  21700,
  40640
}; // idb
const runtime__type_0 stru_80D4520 =
{
  128u,
  12u,
  244452524u,
  7u,
  4u,
  4u,
  25u,
  &runtime_algarray,
  &asc_80F03EA,
  19672,
  84128
}; // idb
const runtime__type_0 stru_80D4580 =
{
  8u,
  4u,
  2585937367u,
  7u,
  4u,
  4u,
  25u,
  &runtime_algarray,
  &runtime_gcbits__,
  18672,
  44160
}; // idb
const runtime__type_0 stru_80D4820 =
{
  4u,
  4u,
  1205328019u,
  7u,
  4u,
  4u,
  57u,
  (runtime_typeAlg *)0x8144340,
  &runtime_gcbits__,
  9755,
  126272
}; // idb
_UNKNOWN unk_80D5060; // weak
const runtime__type_0 stru_80D57C0 = { 24u, 24u, 4268186188u, 7u, 4u, 4u, 25u, &off_80BE978, &a56B, 17456, 75232 }; // idb
const runtime__type_0 stru_80D58C0 = { 36u, 24u, 3491593807u, 7u, 4u, 4u, 25u, &off_80BEC90, &a0_0, 21440, 132896 }; // idb
const runtime__type_0 stru_80D69A0 =
{
  48u,
  44u,
  1635509546u,
  7u,
  4u,
  4u,
  25u,
  &off_80BE980,
  &asc_80F041C,
  9766,
  75328
}; // idb
const runtime__type_0 stru_80D6AA0 =
{
  16u,
  0u,
  2567267451u,
  7u,
  4u,
  4u,
  153u,
  (runtime_typeAlg *)0x8144350,
  &runtime_gcbits__,
  19366,
  36544
}; // idb
const runtime__type_0 stru_80D6B20 =
{
  24u,
  20u,
  2856018773u,
  7u,
  4u,
  4u,
  25u,
  &off_80BEC10,
  &unk_80F03F8,
  25980,
  36608
}; // idb
const runtime__type_0 stru_80D6BA0 = { 32u, 28u, 83039381u, 7u, 4u, 4u, 25u, &off_80BE9B0, &aUx, 29048, 82112 }; // idb
const runtime__type_0 stru_80D73A0 =
{
  12u,
  12u,
  3029231016u,
  7u,
  4u,
  4u,
  25u,
  &runtime_algarray,
  &unk_80F03E8,
  13267,
  108224
}; // idb
const runtime__type_0 stru_80D7D20 =
{
  20u,
  20u,
  1498543446u,
  7u,
  4u,
  4u,
  25u,
  &off_80BEBD0,
  &unk_80F03F7,
  23879,
  36480
}; // idb
const runtime__type_0 stru_80D86C0 =
{
  4u,
  4u,
  1989944814u,
  1u,
  4u,
  4u,
  54u,
  (runtime_typeAlg *)0x8144340,
  &runtime_gcbits__,
  13267,
  0
}; // idb
const runtime__type_0 stru_80D88A0 =
{
  32u,
  20u,
  3725771747u,
  7u,
  4u,
  4u,
  25u,
  &off_80BE9A0,
  &unk_80F03F4,
  18366,
  37056
}; // idb
const runtime__type_0 stru_80D8DA0 =
{
  4u,
  4u,
  2204641285u,
  1u,
  4u,
  4u,
  54u,
  (runtime_typeAlg *)0x8144340,
  &runtime_gcbits__,
  18400,
  30208
}; // idb
const runtime__type_0 stru_80D9160 = { 28u, 28u, 803089490u, 7u, 4u, 4u, 25u, &off_80BE9B8, &aPr, 19402, 37184 }; // idb
const runtime__type_0 stru_80D9C00 = { 128u, 36u, 777436576u, 7u, 4u, 4u, 25u, &runtime_algarray, &aY, 8204, 123872 }; // idb
const runtime__type_0 stru_80DABC0 = { 32u, 24u, 2308008992u, 7u, 4u, 4u, 25u, &off_80BEC78, &a0_0, 18332, 130880 }; // idb
const runtime__type_0 typ =
{
  52u,
  48u,
  1447126912u,
  7u,
  4u,
  4u,
  25u,
  &off_80BE9F0,
  &asc_80F0412,
  18451,
  76288
}; // idb
const runtime__type_0 stru_80DB1E0 =
{
  56u,
  56u,
  269191458u,
  7u,
  4u,
  4u,
  25u,
  &off_80BED68,
  &unk_80F040E,
  18604,
  42048
}; // idb
const runtime__type_0 stru_80DB6A0 =
{
  48u,
  32u,
  1247845316u,
  7u,
  4u,
  4u,
  25u,
  &off_80BED10,
  &unk_80F040A,
  18468,
  39104
}; // idb
const runtime__type_0 stru_80DB9C0 =
{
  4u,
  4u,
  3262215369u,
  1u,
  4u,
  4u,
  54u,
  (runtime_typeAlg *)0x8144340,
  &runtime_gcbits__,
  18536,
  30912
}; // idb
const runtime__type_0 stru_80DBAE0 =
{
  8u,
  8u,
  3092519629u,
  7u,
  4u,
  4u,
  20u,
  (runtime_typeAlg *)0x8144360,
  &unk_80F03E6,
  17504,
  36224
}; // idb
const runtime__type_0 stru_80DC3E0 =
{
  4u,
  4u,
  2274331072u,
  1u,
  4u,
  4u,
  54u,
  (runtime_typeAlg *)0x8144340,
  &runtime_gcbits__,
  8204,
  0
}; // idb
const runtime__type_0 stru_80DC7A0 =
{
  2476u,
  2392u,
  951628069u,
  7u,
  4u,
  4u,
  25u,
  &runtime_algarray,
  &unk_80F0640,
  13228,
  40576
}; // idb
const runtime__type_0 stru_80DD7C0 =
{
  212u,
  204u,
  3901217204u,
  7u,
  4u,
  4u,
  25u,
  &runtime_algarray,
  &aP_3,
  13202,
  38592
}; // idb
const interface_{} value = { (runtime__type_0 *)4, (void *)4 }; // idb
const runtime__type_0 key =
{
  4u,
  4u,
  3811822038u,
  1u,
  4u,
  4u,
  54u,
  (runtime_typeAlg *)0x8144340,
  &runtime_gcbits__,
  18332,
  0
}; // idb
const runtime__type_0 stru_80DFD60 =
{
  556u,
  472u,
  4286093336u,
  7u,
  4u,
  4u,
  25u,
  &runtime_algarray,
  &unk_80F04E0,
  13215,
  39680
}; // idb
const runtime__type_0 stru_80E08C0 =
{
  12u,
  8u,
  1342970556u,
  7u,
  4u,
  4u,
  25u,
  &off_80BEAF0,
  &unk_80F03E6,
  18315,
  140320
}; // idb
char a0123456789abcd_1[16] = "0123456789abcdef"; // weak
char a0123456789abcd_0[17] = "0123456789ABCDEFX"; // weak
char a0123456789abcd_2[36] = "0123456789abcdefghijklmnopqrstuvwxyz"; // weak
char a00010203040506[65] = "00010203040506070809101112131415161718192021222324252627282930313"; // weak
const runtime_funcval stru_80E7B0C = { 134977312u }; // idb
const runtime_funcval stru_80E7B14 = { 134863904u }; // idb
int (__golang *off_80E7B1C)(os_file *file, error_0 _r0) = &os___ptr_file__close; // weak
int (__golang *off_80E7B20[17])(reflect_Value_0 v, reflect_Type_0 t, reflect_Value_0 _r2) =
{
  &reflect_cvtBytesString,
  &reflect_cvtComplex,
  &reflect_cvtDirect,
  &reflect_cvtFloatInt,
  &reflect_cvtFloatUint,
  &reflect_cvtFloat,
  &reflect_cvtI2I,
  &reflect_cvtIntFloat,
  &reflect_cvtIntString,
  &reflect_cvtInt,
  &reflect_cvtRunesString,
  &reflect_cvtStringBytes,
  &reflect_cvtStringRunes,
  &reflect_cvtT2I,
  &reflect_cvtUintFloat,
  &reflect_cvtUintString,
  &reflect_cvtUint
}; // weak
int (__golang *off_80E7B24[16])(reflect_Value_0 v, reflect_Type_0 t, reflect_Value_0 _r2) =
{
  &reflect_cvtComplex,
  &reflect_cvtDirect,
  &reflect_cvtFloatInt,
  &reflect_cvtFloatUint,
  &reflect_cvtFloat,
  &reflect_cvtI2I,
  &reflect_cvtIntFloat,
  &reflect_cvtIntString,
  &reflect_cvtInt,
  &reflect_cvtRunesString,
  &reflect_cvtStringBytes,
  &reflect_cvtStringRunes,
  &reflect_cvtT2I,
  &reflect_cvtUintFloat,
  &reflect_cvtUintString,
  &reflect_cvtUint
}; // weak
int (__golang *off_80E7B28[15])(reflect_Value_0 v, reflect_Type_0 typ, reflect_Value_0 _r2) =
{
  &reflect_cvtDirect,
  &reflect_cvtFloatInt,
  &reflect_cvtFloatUint,
  &reflect_cvtFloat,
  &reflect_cvtI2I,
  &reflect_cvtIntFloat,
  &reflect_cvtIntString,
  &reflect_cvtInt,
  &reflect_cvtRunesString,
  &reflect_cvtStringBytes,
  &reflect_cvtStringRunes,
  &reflect_cvtT2I,
  &reflect_cvtUintFloat,
  &reflect_cvtUintString,
  &reflect_cvtUint
}; // weak
int (__golang *off_80E7B2C[14])(reflect_Value_0 v, reflect_Type_0 t, reflect_Value_0 _r2) =
{
  &reflect_cvtFloatInt,
  &reflect_cvtFloatUint,
  &reflect_cvtFloat,
  &reflect_cvtI2I,
  &reflect_cvtIntFloat,
  &reflect_cvtIntString,
  &reflect_cvtInt,
  &reflect_cvtRunesString,
  &reflect_cvtStringBytes,
  &reflect_cvtStringRunes,
  &reflect_cvtT2I,
  &reflect_cvtUintFloat,
  &reflect_cvtUintString,
  &reflect_cvtUint
}; // weak
int (__golang *off_80E7B30[13])(reflect_Value_0 v, reflect_Type_0 t, reflect_Value_0 _r2) =
{
  &reflect_cvtFloatUint,
  &reflect_cvtFloat,
  &reflect_cvtI2I,
  &reflect_cvtIntFloat,
  &reflect_cvtIntString,
  &reflect_cvtInt,
  &reflect_cvtRunesString,
  &reflect_cvtStringBytes,
  &reflect_cvtStringRunes,
  &reflect_cvtT2I,
  &reflect_cvtUintFloat,
  &reflect_cvtUintString,
  &reflect_cvtUint
}; // weak
int (__golang *off_80E7B34[12])(reflect_Value_0 v, reflect_Type_0 t, reflect_Value_0 _r2) =
{
  &reflect_cvtFloat,
  &reflect_cvtI2I,
  &reflect_cvtIntFloat,
  &reflect_cvtIntString,
  &reflect_cvtInt,
  &reflect_cvtRunesString,
  &reflect_cvtStringBytes,
  &reflect_cvtStringRunes,
  &reflect_cvtT2I,
  &reflect_cvtUintFloat,
  &reflect_cvtUintString,
  &reflect_cvtUint
}; // weak
int (__golang *off_80E7B38[11])(reflect_Value_0 v, reflect_Type_0 typ, reflect_Value_0 _r2) =
{
  &reflect_cvtI2I,
  &reflect_cvtIntFloat,
  &reflect_cvtIntString,
  &reflect_cvtInt,
  &reflect_cvtRunesString,
  &reflect_cvtStringBytes,
  &reflect_cvtStringRunes,
  &reflect_cvtT2I,
  &reflect_cvtUintFloat,
  &reflect_cvtUintString,
  &reflect_cvtUint
}; // weak
int (__golang *off_80E7B3C[10])(reflect_Value_0 v, reflect_Type_0 t, reflect_Value_0 _r2) =
{
  &reflect_cvtIntFloat,
  &reflect_cvtIntString,
  &reflect_cvtInt,
  &reflect_cvtRunesString,
  &reflect_cvtStringBytes,
  &reflect_cvtStringRunes,
  &reflect_cvtT2I,
  &reflect_cvtUintFloat,
  &reflect_cvtUintString,
  &reflect_cvtUint
}; // weak
int (__golang *off_80E7B40[9])(reflect_Value_0 v, reflect_Type_0 t, reflect_Value_0 _r2) =
{
  &reflect_cvtIntString,
  &reflect_cvtInt,
  &reflect_cvtRunesString,
  &reflect_cvtStringBytes,
  &reflect_cvtStringRunes,
  &reflect_cvtT2I,
  &reflect_cvtUintFloat,
  &reflect_cvtUintString,
  &reflect_cvtUint
}; // weak
int (__golang *off_80E7B44[8])(reflect_Value_0 v, reflect_Type_0 t, reflect_Value_0 _r2) =
{
  &reflect_cvtInt,
  &reflect_cvtRunesString,
  &reflect_cvtStringBytes,
  &reflect_cvtStringRunes,
  &reflect_cvtT2I,
  &reflect_cvtUintFloat,
  &reflect_cvtUintString,
  &reflect_cvtUint
}; // weak
int (__golang *off_80E7B48[7])(reflect_Value_0 v, reflect_Type_0 t, reflect_Value_0 _r2) =
{
  &reflect_cvtRunesString,
  &reflect_cvtStringBytes,
  &reflect_cvtStringRunes,
  &reflect_cvtT2I,
  &reflect_cvtUintFloat,
  &reflect_cvtUintString,
  &reflect_cvtUint
}; // weak
int (__golang *off_80E7B4C[6])(reflect_Value_0 v, reflect_Type_0 t, reflect_Value_0 _r2) =
{
  &reflect_cvtStringBytes,
  &reflect_cvtStringRunes,
  &reflect_cvtT2I,
  &reflect_cvtUintFloat,
  &reflect_cvtUintString,
  &reflect_cvtUint
}; // weak
int (__golang *off_80E7B50[5])(reflect_Value_0 v, reflect_Type_0 t, reflect_Value_0 _r2) =
{
  &reflect_cvtStringRunes,
  &reflect_cvtT2I,
  &reflect_cvtUintFloat,
  &reflect_cvtUintString,
  &reflect_cvtUint
}; // weak
int (__golang *off_80E7B54[4])(reflect_Value_0 v, reflect_Type_0 typ, reflect_Value_0 _r2) =
{
  &reflect_cvtT2I,
  &reflect_cvtUintFloat,
  &reflect_cvtUintString,
  &reflect_cvtUint
}; // weak
int (__golang *off_80E7B58[3])(reflect_Value_0 v, reflect_Type_0 t, reflect_Value_0 _r2) = { &reflect_cvtUintFloat, &reflect_cvtUintString, &reflect_cvtUint }; // weak
int (__golang *off_80E7B5C[2])(reflect_Value_0 v, reflect_Type_0 t, reflect_Value_0 _r2) = { &reflect_cvtUintString, &reflect_cvtUint }; // weak
int (__golang *off_80E7B60)(reflect_Value_0 v, reflect_Type_0 t, reflect_Value_0 _r2) = &reflect_cvtUint; // weak
int (__golang *off_80E7B6C[4])() =
{
  &runtime__ExternalCode,
  &runtime__GC,
  &runtime__LostExternalCode,
  &runtime__System
}; // weak
int (__golang *off_80E7B70[3])() = { &runtime__GC, &runtime__LostExternalCode, &runtime__System }; // weak
int (__golang *off_80E7B74[2])() = { &runtime__LostExternalCode, &runtime__System }; // weak
int (__golang *off_80E7B78)() = &runtime__System; // weak
const uintptr src = 134805808u; // idb
const uintptr off_80E7B84 = 134805872u; // idb
const uintptr off_80E7B88 = 134805200u; // idb
int (__golang *off_80E7B8C)(int, int, int) = &runtime_asmcgocall; // weak
const runtime_funcval stru_80E7B94 = { 134620208u }; // idb
void (__golang __noreturn *off_80E7BA8[3])() =
{
  &runtime_casgstatus_func2,
  &runtime_cgoCheckBits_func1,
  &runtime_cgoCheckTypedBlock_func2
}; // weak
const runtime_funcval fn = { 134789600u }; // idb
int (__golang *off_80E7BC0)(void *fn, void *arg, int32 _r2) = &runtime_cgocall; // weak
int (__golang *off_80E7BC4)(runtime_hchan *c, void *ep, bool block, __int16 selected) = &runtime_chanrecv; // weak
int (__golang *off_80E7BC8)(runtime_hchan *c, void *ep, bool block, uintptr callerpc, bool _r4) = &runtime_chansend; // weak
void (__golang __noreturn *off_80E7BD8)() = &runtime_exitsyscall_func1; // weak
const runtime_funcval stru_80E7BF0 = { 134665440u }; // idb
int (__golang *off_80E7BF4)() = &runtime_freeStackSpans; // weak
const runtime_funcval stru_80E7BFC = { 134598432u }; // idb
int (__golang *off_80E7C0C)() = &runtime_gcStart_func1; // weak
void (__golang __noreturn *off_80E7C14)() = &runtime_goexit; // weak
int (__golang *off_80E7C2C)() = &runtime_main_func1; // weak
const runtime_funcval stru_80E7C30 = { 134795984u }; // idb
int (__golang *off_80E7C84)() = &runtime_mstart; // weak
const runtime_funcval stru_80E7CA4 = { 134795776u }; // idb
const uintptr off_80E7CA8 = 134628800u; // idb
const runtime_funcval stru_80E7CB8 = { 134583104u }; // idb
int (__golang *off_80E7CD0[4])() =
{
  &runtime_skipPleaseUseCallersFrames,
  &runtime_startTheWorldWithSema,
  &runtime_startpanic_m,
  &runtime_stopTheWorldWithSema
}; // weak
int (__golang *off_80E7CD4[3])() =
{
  &runtime_startTheWorldWithSema,
  &runtime_startpanic_m,
  &runtime_stopTheWorldWithSema
}; // weak
const runtime_funcval stru_80E7D00 = { 134523296u }; // idb
const runtime_funcval len = { 134853872u }; // idb
const runtime_funcval stru_80E7D10 = { 134517392u }; // idb
uint8 runtime_egcdata = 0u; // idb
uint8 reflect_statictmp_24[1] = { 42u }; // idb
uint8 reflect_statictmp_39[1] = { 118u }; // idb
uint8 reflect_statictmp_40[1] = { 46u }; // idb
syscall_Errno os_statictmp_4 = 22u; // idb
void **reflect_statictmp_23 = NULL; // idb
func() reflect_statictmp_36 = NULL; // idb
const runtime_funcval runtime_mainPC = { 134664416u }; // idb
__int32 runtime_statictmp_15 = 1; // idb
syscall_Errno syscall_statictmp_24 = 22u; // idb
const float64 _f64_3fd0000000000000 = 0.25; // idb
__int64 _f64_3fec000000000000 = 4606056518893174784LL; // weak
__int64 _f64_4014000000000000 = 4617315517961601024LL; // weak
__int64 _f64_8000000000000000 = -9223372036854775808LL; // weak
string fmt_statictmp_0 = { &aFmtUnknownBase, 31 }; // idb
string internal_poll_statictmp_1 = { &aInconsistentPo, 25 }; // idb
string internal_poll_statictmp_2 = { &aInconsistentPo, 25 }; // idb
string internal_poll_statictmp_3 = { &aInconsistentPo, 25 }; // idb
string internal_poll_statictmp_4 = { &aInconsistentPo, 25 }; // idb
string internal_poll_statictmp_5 = { &aInconsistentPo, 25 }; // idb
string internal_poll_statictmp_6 = { &aUnreachable, 11 }; // idb
string main_statictmp_0 = { &aHelloWorld, 11 }; // idb
string reflect_statictmp_1 = { &aReflectInterna, 55 }; // idb
string reflect_statictmp_10 = { &aReflectFieldOf, 33 }; // idb
string reflect_statictmp_100 = { &aReflectInterna_0, 45 }; // idb
string reflect_statictmp_101 = { &aReflectInterna_0, 45 }; // idb
string reflect_statictmp_11 = { &aReflectFieldby, 40 }; // idb
string reflect_statictmp_12 = { &aReflectFieldby_0, 39 }; // idb
string reflect_statictmp_120 = { &aReflectZeroNil, 18 }; // idb
string reflect_statictmp_121 = { &aReflectNewNil, 17 }; // idb
string reflect_statictmp_13 = { &aReflectFieldby_1, 43 }; // idb
string reflect_statictmp_14 = { &aReflectInOfNon, 28 }; // idb
string reflect_statictmp_15 = { &aReflectKeyOfNo, 28 }; // idb
string reflect_statictmp_16 = { &aReflectLenOfNo, 30 }; // idb
string reflect_statictmp_17 = { &aReflectNumfiel, 36 }; // idb
string reflect_statictmp_18 = { &aReflectNuminOf, 31 }; // idb
string reflect_statictmp_19 = { &aReflectNumoutO, 32 }; // idb
string reflect_statictmp_2 = { &aReflectCreatin, 61 }; // idb
string reflect_statictmp_20 = { &aReflectOutOfNo, 29 }; // idb
string reflect_statictmp_21 = { &aReflectFieldIn, 34 }; // idb
string reflect_statictmp_25 = { &aReflectNilType, 43 }; // idb
string reflect_statictmp_26 = { &aReflectNonInte, 53 }; // idb
string reflect_statictmp_27 = { &aReflectNilType_0, 45 }; // idb
string reflect_statictmp_28 = { &aReflectNilType_1, 46 }; // idb
string reflect_statictmp_3 = { &aReflectBitsOfN, 25 }; // idb
string reflect_statictmp_35 = { &aReflectFuncofL, 55 }; // idb
string reflect_statictmp_37 = { &aReflectFuncofT, 34 }; // idb
string reflect_statictmp_38 = { &aReflectFuncofD, 54 }; // idb
string reflect_statictmp_4 = { &aReflectMethodI, 34 }; // idb
string reflect_statictmp_61 = { &aReflectFunclay, 36 }; // idb
string reflect_statictmp_63 = { &aCanTCallPointe, 41 }; // idb
string reflect_statictmp_64 = { &aBadIndir, 9 }; // idb
string reflect_statictmp_66 = { &aReflectValueBy, 37 }; // idb
string reflect_statictmp_67 = { &aReflectValueBy_0, 37 }; // idb
string reflect_statictmp_7 = { &aReflectChandir, 33 }; // idb
string reflect_statictmp_79 = { &aReflectInterna_0, 45 }; // idb
string reflect_statictmp_8 = { &aReflectIsvaria, 36 }; // idb
string reflect_statictmp_80 = { &aReflectInterna_0, 45 }; // idb
string reflect_statictmp_81 = { &aReflectFieldIn_0, 33 }; // idb
string reflect_statictmp_83 = { &aReflectArrayIn, 33 }; // idb
string reflect_statictmp_84 = { &aReflectSliceIn, 33 }; // idb
string reflect_statictmp_85 = { &aReflectStringI, 34 }; // idb
string reflect_statictmp_86 = { &aReflectValueIn, 85 }; // idb
string reflect_statictmp_9 = { &aReflectElemOfI, 29 }; // idb
string reflect_statictmp_91 = { &aReflectValueSe, 40 }; // idb
string reflect_statictmp_92 = { &aReflectValueSe_0, 40 }; // idb
string reflect_statictmp_95 = { &aReflectValueSl_1, 49 }; // idb
string reflect_statictmp_96 = { &aReflectValueSl_0, 53 }; // idb
string reflect_statictmp_97 = { &aReflectValueSl, 46 }; // idb
runtime_plainError runtime_statictmp_0 = { &aMakechanSizeOu, 27 }; // idb
runtime_plainError runtime_statictmp_1 = { &aSendOnClosedCh, 22 }; // idb
runtime_plainError runtime_statictmp_10 = { &aAssignmentToEn, 30 }; // idb
runtime_plainError runtime_statictmp_11 = { &aAssignmentToEn, 30 }; // idb
runtime_plainError runtime_statictmp_12 = { &aAssignmentToEn, 30 }; // idb
runtime_plainError runtime_statictmp_14 = { &aRuntimeAllocat, 37 }; // idb
runtime_plainError runtime_statictmp_18 = { &aArgSizeToRefle, 38 }; // idb
runtime_plainError runtime_statictmp_2 = { &aSendOnClosedCh, 22 }; // idb
string runtime_statictmp_21 = { &aSemarootQueue, 14 }; // idb
runtime_errorString runtime_statictmp_22 = { &aMakesliceLenOu, 27 }; // idb
runtime_errorString runtime_statictmp_23 = { &aMakesliceCapOu, 27 }; // idb
runtime_errorString runtime_statictmp_26 = { &aGrowsliceCapOu, 27 }; // idb
runtime_errorString runtime_statictmp_27 = { &aGrowsliceCapOu, 27 }; // idb
runtime_plainError runtime_statictmp_3 = { &aCloseOfNilChan, 20 }; // idb
uint64 runtime_statictmp_35[1] = { 0uLL }; // idb
runtime_plainError runtime_statictmp_4 = { &aCloseOfClosedC, 23 }; // idb
runtime_plainError runtime_statictmp_9 = { &aAssignmentToEn, 30 }; // idb
string strconv_statictmp_1 = { &aStrconvInterna_0, 65 }; // idb
string strconv_statictmp_2 = { &aStrconvInterna, 49 }; // idb
string strconv_statictmp_3 = { &aStrconvNumDenS, 49 }; // idb
string strconv_statictmp_4 = { &aStrconvEDenShi, 28 }; // idb
string strconv_statictmp_5 = { &aStrconvIllegal, 48 }; // idb
string strconv_statictmp_6 = { &aStrconvIllegal_0, 41 }; // idb
string sync_statictmp_3 = { &aSyncUnlockOfUn, 30 }; // idb
string sync_atomic_statictmp_1 = { &aSyncAtomicStor_0, 42 }; // idb
string sync_atomic_statictmp_2 = { &aSyncAtomicStor, 59 }; // idb
__m128i masks[16] =
{
  { { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } },
  { { -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } },
  { { -1, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } },
  { { -1, -1, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } },
  { { -1, -1, -1, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } },
  { { -1, -1, -1, -1, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } },
  { { -1, -1, -1, -1, -1, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } },
  { { -1, -1, -1, -1, -1, -1, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0 } },
  { { -1, -1, -1, -1, -1, -1, -1, -1, 0, 0, 0, 0, 0, 0, 0, 0 } },
  { { -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 0, 0, 0, 0, 0, 0 } },
  { { -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 0, 0, 0, 0, 0 } },
  { { -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 0, 0, 0, 0 } },
  { { -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 0, 0, 0 } },
  { { -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 0, 0 } },
  { { -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 0 } },
  { { -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0 } }
}; // weak
__m128i shifts[16] =
{
  { { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } },
  { { 15, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 } },
  { { 14, 15, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 } },
  { { 13, 14, 15, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 } },
  { { 12, 13, 14, 15, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 } },
  { { 11, 12, 13, 14, 15, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 } },
  { { 10, 11, 12, 13, 14, 15, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 } },
  { { 9, 10, 11, 12, 13, 14, 15, -1, -1, -1, -1, -1, -1, -1, -1, -1 } },
  { { 8, 9, 10, 11, 12, 13, 14, 15, -1, -1, -1, -1, -1, -1, -1, -1 } },
  { { 7, 8, 9, 10, 11, 12, 13, 14, 15, -1, -1, -1, -1, -1, -1, -1 } },
  { { 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, -1, -1, -1, -1, -1, -1 } },
  { { 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, -1, -1, -1, -1, -1 } },
  { { 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, -1, -1, -1, -1 } },
  { { 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, -1, -1, -1 } },
  { { 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, -1, -1 } },
  { { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, -1 } }
}; // weak
uint8 runtime_noptrdata[1] = { 1u }; // idb
bool strconv_optimize = true; // idb
__int32 runtime_MemProfileRate = 524288; // idb
int32 runtime_epfd = -1; // idb
uintptr runtime_maxstacksize = 1048576u; // idb
uintptr runtime_sizeof_C_MStats = 5528u; // idb
uint32 runtime_traceback_cache = 8u; // idb
uint32 runtime_worldsema = 1u; // idb
uintptr syscall_Stderr = 2u; // idb
uintptr syscall_Stdout = 1u; // idb
uintptr syscall_fcntl64Syscall = 55u; // idb
uint8 runtime_finalizer1[5] = { 123u, 239u, 189u, 247u, 222u }; // idb
int64 runtime_forcegcperiod = 120000000000LL; // idb
uint64 runtime_heapminimum = 4194304uLL; // idb
runtime_sigset runtime_sigset_all = { 4294967295u, 4294967295u }; // idb
unicode_utf8_acceptRange unicode_utf8_acceptRanges[5] =
{
  { 128u, 191u },
  { 160u, 191u },
  { 128u, 159u },
  { 144u, 191u },
  { 128u, 143u }
}; // idb
strconv_floatInfo_0 strconv_float32info = { 23u, 8u, -127 }; // idb
strconv_floatInfo strconv_float64info = { 52u, 11u, -1023 }; // idb
runtime_interfacetype_0 *go_itab__errors_errorString_error = &iface; // weak
io_Writer_0 go_itab__os_File_io_Writer = { &unk_80D0FE0, &unk_80DCD40 }; // idb
runtime_interfacetype_0 *go_itab__os_PathError_error = &iface; // weak
runtime_interfacetype_0 *go_itab_runtime_errorString_error = &iface; // weak
runtime_itab_0 go_itab_syscall_Errno_error = { &iface, &unk_80D5060, NULL, 4293485756u, false, false, { 0u, 0u }, { 0u } }; // idb
uint8 runtime_class_to_allocnpages[67] =
{
  0u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  1u,
  2u,
  1u,
  2u,
  1u,
  2u,
  1u,
  3u,
  2u,
  3u,
  1u,
  3u,
  2u,
  3u,
  4u,
  5u,
  6u,
  1u,
  7u,
  6u,
  5u,
  4u,
  3u,
  5u,
  7u,
  2u,
  9u,
  7u,
  5u,
  8u,
  3u,
  10u,
  7u,
  4u
}; // idb
uint8 runtime_size_to_class8[129] =
{
  0u,
  1u,
  2u,
  3u,
  3u,
  4u,
  4u,
  5u,
  5u,
  6u,
  6u,
  7u,
  7u,
  8u,
  8u,
  9u,
  9u,
  10u,
  10u,
  11u,
  11u,
  12u,
  12u,
  13u,
  13u,
  14u,
  14u,
  15u,
  15u,
  16u,
  16u,
  17u,
  17u,
  18u,
  18u,
  18u,
  18u,
  19u,
  19u,
  19u,
  19u,
  20u,
  20u,
  20u,
  20u,
  21u,
  21u,
  21u,
  21u,
  22u,
  22u,
  22u,
  22u,
  23u,
  23u,
  23u,
  23u,
  24u,
  24u,
  24u,
  24u,
  25u,
  25u,
  25u,
  25u,
  26u,
  26u,
  26u,
  26u,
  26u,
  26u,
  26u,
  26u,
  27u,
  27u,
  27u,
  27u,
  27u,
  27u,
  27u,
  27u,
  28u,
  28u,
  28u,
  28u,
  28u,
  28u,
  28u,
  28u,
  29u,
  29u,
  29u,
  29u,
  29u,
  29u,
  29u,
  29u,
  30u,
  30u,
  30u,
  30u,
  30u,
  30u,
  30u,
  30u,
  30u,
  30u,
  30u,
  30u,
  30u,
  30u,
  30u,
  30u,
  31u,
  31u,
  31u,
  31u,
  31u,
  31u,
  31u,
  31u,
  31u,
  31u,
  31u,
  31u,
  31u,
  31u,
  31u,
  31u
}; // idb
uintptr runtime_maxElems[33] =
{
  4294967295u,
  4294967295u,
  2147483647u,
  1431655765u,
  1073741823u,
  858993459u,
  715827882u,
  613566756u,
  536870911u,
  477218588u,
  429496729u,
  390451572u,
  357913941u,
  330382099u,
  306783378u,
  286331153u,
  268435455u,
  252645135u,
  238609294u,
  226050910u,
  214748364u,
  204522252u,
  195225786u,
  186737708u,
  178956970u,
  171798691u,
  165191049u,
  159072862u,
  153391689u,
  148102320u,
  143165576u,
  138547332u,
  134217727u
}; // idb
uint16 runtime_class_to_size[67] =
{
  0u,
  8u,
  16u,
  32u,
  48u,
  64u,
  80u,
  96u,
  112u,
  128u,
  144u,
  160u,
  176u,
  192u,
  208u,
  224u,
  240u,
  256u,
  288u,
  320u,
  352u,
  384u,
  416u,
  448u,
  480u,
  512u,
  576u,
  640u,
  704u,
  768u,
  896u,
  1024u,
  1152u,
  1280u,
  1408u,
  1536u,
  1792u,
  2048u,
  2304u,
  2688u,
  3072u,
  3200u,
  3456u,
  4096u,
  4864u,
  5376u,
  6144u,
  6528u,
  6784u,
  6912u,
  8192u,
  9472u,
  9728u,
  10240u,
  10880u,
  12288u,
  13568u,
  14336u,
  16384u,
  18432u,
  19072u,
  20480u,
  21760u,
  24576u,
  27264u,
  28672u,
  32768u
}; // idb
reflect_Type_0 go_itab__reflect_rtype_reflect_Type = { &stru_80DBAE0, &key }; // idb
uint strconv_shifts[37] =
{
  0u,
  0u,
  1u,
  0u,
  2u,
  0u,
  0u,
  0u,
  3u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  4u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  5u,
  0u,
  0u,
  0u,
  0u
}; // idb
uint64 strconv_uint64pow10[20] =
{
  1uLL,
  10uLL,
  100uLL,
  1000uLL,
  10000uLL,
  100000uLL,
  1000000uLL,
  10000000uLL,
  100000000uLL,
  1000000000uLL,
  10000000000uLL,
  100000000000uLL,
  1000000000000uLL,
  10000000000000uLL,
  100000000000000uLL,
  1000000000000000uLL,
  10000000000000000uLL,
  100000000000000000uLL,
  1000000000000000000uLL,
  10000000000000000000uLL
}; // idb
runtime_moduledata runtime_firstmoduledata =
{
  { &runtime_pclntab, 270381, 270381 },
  { &stru_80F39EC, 1746, 1746 },
  { &dword_8133B50, 138, 138 },
  135209760u,
  134516736u,
  134992643u,
  134516736u,
  134992643u,
  135487488u,
  135537284u,
  135537312u,
  135548776u,
  135548800u,
  135624016u,
  135624032u,
  135632840u,
  135632840u,
  135206528u,
  135205248u,
  134995968u,
  135212088u,
  { &runtime_textsectionmap, 1, 1 },
  { &runtime_typelink, 787, 787 },
  { &runtime_itablink, 8, 8 },
  { NULL, 0, 0 },
  { NULL, 0 },
  { NULL, 0, 0 },
  { NULL, 0 },
  { NULL, 0, 0 },
  { 0, NULL },
  { 0, NULL },
  NULL,
  NULL
}; // idb
uint8 runtime_size_to_class128[249] =
{
  31u,
  32u,
  33u,
  34u,
  35u,
  36u,
  36u,
  37u,
  37u,
  38u,
  38u,
  39u,
  39u,
  39u,
  40u,
  40u,
  40u,
  41u,
  42u,
  42u,
  43u,
  43u,
  43u,
  43u,
  43u,
  44u,
  44u,
  44u,
  44u,
  44u,
  44u,
  45u,
  45u,
  45u,
  45u,
  46u,
  46u,
  46u,
  46u,
  46u,
  46u,
  47u,
  47u,
  47u,
  48u,
  48u,
  49u,
  50u,
  50u,
  50u,
  50u,
  50u,
  50u,
  50u,
  50u,
  50u,
  50u,
  51u,
  51u,
  51u,
  51u,
  51u,
  51u,
  51u,
  51u,
  51u,
  51u,
  52u,
  52u,
  53u,
  53u,
  53u,
  53u,
  54u,
  54u,
  54u,
  54u,
  54u,
  55u,
  55u,
  55u,
  55u,
  55u,
  55u,
  55u,
  55u,
  55u,
  55u,
  55u,
  56u,
  56u,
  56u,
  56u,
  56u,
  56u,
  56u,
  56u,
  56u,
  56u,
  57u,
  57u,
  57u,
  57u,
  57u,
  57u,
  58u,
  58u,
  58u,
  58u,
  58u,
  58u,
  58u,
  58u,
  58u,
  58u,
  58u,
  58u,
  58u,
  58u,
  58u,
  58u,
  59u,
  59u,
  59u,
  59u,
  59u,
  59u,
  59u,
  59u,
  59u,
  59u,
  59u,
  59u,
  59u,
  59u,
  59u,
  59u,
  60u,
  60u,
  60u,
  60u,
  60u,
  61u,
  61u,
  61u,
  61u,
  61u,
  61u,
  61u,
  61u,
  61u,
  61u,
  61u,
  62u,
  62u,
  62u,
  62u,
  62u,
  62u,
  62u,
  62u,
  62u,
  62u,
  63u,
  63u,
  63u,
  63u,
  63u,
  63u,
  63u,
  63u,
  63u,
  63u,
  63u,
  63u,
  63u,
  63u,
  63u,
  63u,
  63u,
  63u,
  63u,
  63u,
  63u,
  63u,
  64u,
  64u,
  64u,
  64u,
  64u,
  64u,
  64u,
  64u,
  64u,
  64u,
  64u,
  64u,
  64u,
  64u,
  64u,
  64u,
  64u,
  64u,
  64u,
  64u,
  64u,
  65u,
  65u,
  65u,
  65u,
  65u,
  65u,
  65u,
  65u,
  65u,
  65u,
  65u,
  66u,
  66u,
  66u,
  66u,
  66u,
  66u,
  66u,
  66u,
  66u,
  66u,
  66u,
  66u,
  66u,
  66u,
  66u,
  66u,
  66u,
  66u,
  66u,
  66u,
  66u,
  66u,
  66u,
  66u,
  66u,
  66u,
  66u,
  66u,
  66u,
  66u,
  66u,
  66u
}; // idb
uint8 runtime_oneBitCount[256] =
{
  0u,
  1u,
  1u,
  2u,
  1u,
  2u,
  2u,
  3u,
  1u,
  2u,
  2u,
  3u,
  2u,
  3u,
  3u,
  4u,
  1u,
  2u,
  2u,
  3u,
  2u,
  3u,
  3u,
  4u,
  2u,
  3u,
  3u,
  4u,
  3u,
  4u,
  4u,
  5u,
  1u,
  2u,
  2u,
  3u,
  2u,
  3u,
  3u,
  4u,
  2u,
  3u,
  3u,
  4u,
  3u,
  4u,
  4u,
  5u,
  2u,
  3u,
  3u,
  4u,
  3u,
  4u,
  4u,
  5u,
  3u,
  4u,
  4u,
  5u,
  4u,
  5u,
  5u,
  6u,
  1u,
  2u,
  2u,
  3u,
  2u,
  3u,
  3u,
  4u,
  2u,
  3u,
  3u,
  4u,
  3u,
  4u,
  4u,
  5u,
  2u,
  3u,
  3u,
  4u,
  3u,
  4u,
  4u,
  5u,
  3u,
  4u,
  4u,
  5u,
  4u,
  5u,
  5u,
  6u,
  2u,
  3u,
  3u,
  4u,
  3u,
  4u,
  4u,
  5u,
  3u,
  4u,
  4u,
  5u,
  4u,
  5u,
  5u,
  6u,
  3u,
  4u,
  4u,
  5u,
  4u,
  5u,
  5u,
  6u,
  4u,
  5u,
  5u,
  6u,
  5u,
  6u,
  6u,
  7u,
  1u,
  2u,
  2u,
  3u,
  2u,
  3u,
  3u,
  4u,
  2u,
  3u,
  3u,
  4u,
  3u,
  4u,
  4u,
  5u,
  2u,
  3u,
  3u,
  4u,
  3u,
  4u,
  4u,
  5u,
  3u,
  4u,
  4u,
  5u,
  4u,
  5u,
  5u,
  6u,
  2u,
  3u,
  3u,
  4u,
  3u,
  4u,
  4u,
  5u,
  3u,
  4u,
  4u,
  5u,
  4u,
  5u,
  5u,
  6u,
  3u,
  4u,
  4u,
  5u,
  4u,
  5u,
  5u,
  6u,
  4u,
  5u,
  5u,
  6u,
  5u,
  6u,
  6u,
  7u,
  2u,
  3u,
  3u,
  4u,
  3u,
  4u,
  4u,
  5u,
  3u,
  4u,
  4u,
  5u,
  4u,
  5u,
  5u,
  6u,
  3u,
  4u,
  4u,
  5u,
  4u,
  5u,
  5u,
  6u,
  4u,
  5u,
  5u,
  6u,
  5u,
  6u,
  6u,
  7u,
  3u,
  4u,
  4u,
  5u,
  4u,
  5u,
  5u,
  6u,
  4u,
  5u,
  5u,
  6u,
  5u,
  6u,
  6u,
  7u,
  4u,
  5u,
  5u,
  6u,
  5u,
  6u,
  6u,
  7u,
  5u,
  6u,
  6u,
  7u,
  6u,
  7u,
  7u,
  8u
}; // idb
uint8 runtime_staticbytes[256] =
{
  0u,
  1u,
  2u,
  3u,
  4u,
  5u,
  6u,
  7u,
  8u,
  9u,
  10u,
  11u,
  12u,
  13u,
  14u,
  15u,
  16u,
  17u,
  18u,
  19u,
  20u,
  21u,
  22u,
  23u,
  24u,
  25u,
  26u,
  27u,
  28u,
  29u,
  30u,
  31u,
  32u,
  33u,
  34u,
  35u,
  36u,
  37u,
  38u,
  39u,
  40u,
  41u,
  42u,
  43u,
  44u,
  45u,
  46u,
  47u,
  48u,
  49u,
  50u,
  51u,
  52u,
  53u,
  54u,
  55u,
  56u,
  57u,
  58u,
  59u,
  60u,
  61u,
  62u,
  63u,
  64u,
  65u,
  66u,
  67u,
  68u,
  69u,
  70u,
  71u,
  72u,
  73u,
  74u,
  75u,
  76u,
  77u,
  78u,
  79u,
  80u,
  81u,
  82u,
  83u,
  84u,
  85u,
  86u,
  87u,
  88u,
  89u,
  90u,
  91u,
  92u,
  93u,
  94u,
  95u,
  96u,
  97u,
  98u,
  99u,
  100u,
  101u,
  102u,
  103u,
  104u,
  105u,
  106u,
  107u,
  108u,
  109u,
  110u,
  111u,
  112u,
  113u,
  114u,
  115u,
  116u,
  117u,
  118u,
  119u,
  120u,
  121u,
  122u,
  123u,
  124u,
  125u,
  126u,
  127u,
  128u,
  129u,
  130u,
  131u,
  132u,
  133u,
  134u,
  135u,
  136u,
  137u,
  138u,
  139u,
  140u,
  141u,
  142u,
  143u,
  144u,
  145u,
  146u,
  147u,
  148u,
  149u,
  150u,
  151u,
  152u,
  153u,
  154u,
  155u,
  156u,
  157u,
  158u,
  159u,
  160u,
  161u,
  162u,
  163u,
  164u,
  165u,
  166u,
  167u,
  168u,
  169u,
  170u,
  171u,
  172u,
  173u,
  174u,
  175u,
  176u,
  177u,
  178u,
  179u,
  180u,
  181u,
  182u,
  183u,
  184u,
  185u,
  186u,
  187u,
  188u,
  189u,
  190u,
  191u,
  192u,
  193u,
  194u,
  195u,
  196u,
  197u,
  198u,
  199u,
  200u,
  201u,
  202u,
  203u,
  204u,
  205u,
  206u,
  207u,
  208u,
  209u,
  210u,
  211u,
  212u,
  213u,
  214u,
  215u,
  216u,
  217u,
  218u,
  219u,
  220u,
  221u,
  222u,
  223u,
  224u,
  225u,
  226u,
  227u,
  228u,
  229u,
  230u,
  231u,
  232u,
  233u,
  234u,
  235u,
  236u,
  237u,
  238u,
  239u,
  240u,
  241u,
  242u,
  243u,
  244u,
  245u,
  246u,
  247u,
  248u,
  249u,
  250u,
  251u,
  252u,
  253u,
  254u,
  255u
}; // idb
uint8 unicode_utf8_first[256] =
{
  240u,
  240u,
  240u,
  240u,
  240u,
  240u,
  240u,
  240u,
  240u,
  240u,
  240u,
  240u,
  240u,
  240u,
  240u,
  240u,
  240u,
  240u,
  240u,
  240u,
  240u,
  240u,
  240u,
  240u,
  240u,
  240u,
  240u,
  240u,
  240u,
  240u,
  240u,
  240u,
  240u,
  240u,
  240u,
  240u,
  240u,
  240u,
  240u,
  240u,
  240u,
  240u,
  240u,
  240u,
  240u,
  240u,
  240u,
  240u,
  240u,
  240u,
  240u,
  240u,
  240u,
  240u,
  240u,
  240u,
  240u,
  240u,
  240u,
  240u,
  240u,
  240u,
  240u,
  240u,
  240u,
  240u,
  240u,
  240u,
  240u,
  240u,
  240u,
  240u,
  240u,
  240u,
  240u,
  240u,
  240u,
  240u,
  240u,
  240u,
  240u,
  240u,
  240u,
  240u,
  240u,
  240u,
  240u,
  240u,
  240u,
  240u,
  240u,
  240u,
  240u,
  240u,
  240u,
  240u,
  240u,
  240u,
  240u,
  240u,
  240u,
  240u,
  240u,
  240u,
  240u,
  240u,
  240u,
  240u,
  240u,
  240u,
  240u,
  240u,
  240u,
  240u,
  240u,
  240u,
  240u,
  240u,
  240u,
  240u,
  240u,
  240u,
  240u,
  240u,
  240u,
  240u,
  240u,
  240u,
  241u,
  241u,
  241u,
  241u,
  241u,
  241u,
  241u,
  241u,
  241u,
  241u,
  241u,
  241u,
  241u,
  241u,
  241u,
  241u,
  241u,
  241u,
  241u,
  241u,
  241u,
  241u,
  241u,
  241u,
  241u,
  241u,
  241u,
  241u,
  241u,
  241u,
  241u,
  241u,
  241u,
  241u,
  241u,
  241u,
  241u,
  241u,
  241u,
  241u,
  241u,
  241u,
  241u,
  241u,
  241u,
  241u,
  241u,
  241u,
  241u,
  241u,
  241u,
  241u,
  241u,
  241u,
  241u,
  241u,
  241u,
  241u,
  241u,
  241u,
  241u,
  241u,
  241u,
  241u,
  241u,
  241u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  19u,
  3u,
  3u,
  3u,
  3u,
  3u,
  3u,
  3u,
  3u,
  3u,
  3u,
  3u,
  3u,
  35u,
  3u,
  3u,
  52u,
  4u,
  4u,
  4u,
  68u,
  241u,
  241u,
  241u,
  241u,
  241u,
  241u,
  241u,
  241u,
  241u,
  241u,
  241u
}; // idb
float64 runtime_fastlog2Table[33] =
{
  0.0,
  0.0443941193584535,
  0.08746284125033943,
  0.1292830169449665,
  0.1699250014423125,
  0.2094533656289499,
  0.2479275134435855,
  0.2854022188622484,
  0.3219280948873623,
  0.3575520046180837,
  0.3923174227787604,
  0.4262647547020979,
  0.4594316186372973,
  0.4918530963296748,
  0.5235619560570128,
  0.5545888516776374,
  0.5849625007211563,
  0.6147098441152082,
  0.6438561897747247,
  0.6724253419714956,
  0.7004397181410922,
  0.7279204545631992,
  0.7548875021634686,
  0.7813597135246596,
  0.8073549220576042,
  0.8328900141647417,
  0.8579809951275721,
  0.8826430493618412,
  0.9068905956085185,
  0.9307373375628862,
  0.9541963103868752,
  0.9772799234999164,
  1.0
}; // idb
runtime_divMagic runtime_class_to_divmagic[67] =
{
  { 0u, 0u, 0u, 0u },
  { 3u, 0u, 1u, 65528u },
  { 4u, 0u, 1u, 65520u },
  { 5u, 0u, 1u, 65504u },
  { 4u, 9u, 171u, 0u },
  { 6u, 0u, 1u, 65472u },
  { 4u, 10u, 205u, 0u },
  { 5u, 9u, 171u, 0u },
  { 4u, 11u, 293u, 0u },
  { 7u, 0u, 1u, 65408u },
  { 4u, 9u, 57u, 0u },
  { 5u, 10u, 205u, 0u },
  { 4u, 12u, 373u, 0u },
  { 6u, 7u, 43u, 0u },
  { 4u, 13u, 631u, 0u },
  { 5u, 11u, 293u, 0u },
  { 4u, 13u, 547u, 0u },
  { 8u, 0u, 1u, 65280u },
  { 5u, 9u, 57u, 0u },
  { 6u, 9u, 103u, 0u },
  { 5u, 12u, 373u, 0u },
  { 7u, 7u, 43u, 0u },
  { 5u, 10u, 79u, 0u },
  { 6u, 10u, 147u, 0u },
  { 5u, 11u, 137u, 0u },
  { 9u, 0u, 1u, 65024u },
  { 6u, 9u, 57u, 0u },
  { 7u, 6u, 13u, 0u },
  { 6u, 11u, 187u, 0u },
  { 8u, 5u, 11u, 0u },
  { 7u, 8u, 37u, 0u },
  { 10u, 0u, 1u, 64512u },
  { 7u, 9u, 57u, 0u },
  { 8u, 6u, 13u, 0u },
  { 7u, 11u, 187u, 0u },
  { 9u, 5u, 11u, 0u },
  { 8u, 8u, 37u, 0u },
  { 11u, 0u, 1u, 63488u },
  { 8u, 9u, 57u, 0u },
  { 7u, 10u, 49u, 0u },
  { 10u, 5u, 11u, 0u },
  { 7u, 10u, 41u, 0u },
  { 7u, 9u, 19u, 0u },
  { 12u, 0u, 1u, 61440u },
  { 8u, 9u, 27u, 0u },
  { 8u, 10u, 49u, 0u },
  { 11u, 5u, 11u, 0u },
  { 7u, 13u, 161u, 0u },
  { 7u, 13u, 155u, 0u },
  { 8u, 9u, 19u, 0u },
  { 13u, 0u, 1u, 57344u },
  { 8u, 12u, 111u, 0u },
  { 9u, 9u, 27u, 0u },
  { 11u, 6u, 13u, 0u },
  { 7u, 14u, 193u, 0u },
  { 12u, 3u, 3u, 0u },
  { 8u, 13u, 155u, 0u },
  { 11u, 8u, 37u, 0u },
  { 14u, 0u, 1u, 49152u },
  { 11u, 8u, 29u, 0u },
  { 7u, 13u, 55u, 0u },
  { 12u, 5u, 7u, 0u },
  { 8u, 14u, 193u, 0u },
  { 13u, 3u, 3u, 0u },
  { 7u, 14u, 77u, 0u },
  { 12u, 7u, 19u, 0u },
  { 15u, 0u, 1u, 32768u }
}; // idb
strconv_extFloat strconv_powersOfTen[87] =
{
  { 18054884314459144840uLL, -1220, false },
  { 13451937075301367670uLL, -1193, false },
  { 10022474136428063862uLL, -1166, false },
  { 14934650266808366570uLL, -1140, false },
  { 11127181549972568877uLL, -1113, false },
  { 16580792590934885855uLL, -1087, false },
  { 12353653155963782858uLL, -1060, false },
  { 18408377700990114895uLL, -1034, false },
  { 13715310171984221708uLL, -1007, false },
  { 10218702384817765436uLL, -980, false },
  { 15227053142812498563uLL, -954, false },
  { 11345038669416679861uLL, -927, false },
  { 16905424996341287883uLL, -901, false },
  { 12595523146049147757uLL, -874, false },
  { 9384396036005875287uLL, -847, false },
  { 13983839803942852151uLL, -821, false },
  { 10418772551374772303uLL, -794, false },
  { 15525180923007089351uLL, -768, false },
  { 11567161174868858868uLL, -741, false },
  { 17236413322193710309uLL, -715, false },
  { 12842128665889583758uLL, -688, false },
  { 9568131466127621947uLL, -661, false },
  { 14257626930069360058uLL, -635, false },
  { 10622759856335341974uLL, -608, false },
  { 15829145694278690180uLL, -582, false },
  { 11793632577567316726uLL, -555, false },
  { 17573882009934360870uLL, -529, false },
  { 13093562431584567480uLL, -502, false },
  { 9755464219737475723uLL, -475, false },
  { 14536774485912137811uLL, -449, false },
  { 10830740992659433045uLL, -422, false },
  { 16139061738043178685uLL, -396, false },
  { 12024538023802026127uLL, -369, false },
  { 17917957937422433684uLL, -343, false },
  { 13349918974505688015uLL, -316, false },
  { 9946464728195732843uLL, -289, false },
  { 14821387422376473014uLL, -263, false },
  { 11042794154864902060uLL, -236, false },
  { 16455045573212060422uLL, -210, false },
  { 12259964326927110867uLL, -183, false },
  { 18268770466636286478uLL, -157, false },
  { 13611294676837538539uLL, -130, false },
  { 10141204801825835212uLL, -103, false },
  { 15111572745182864684uLL, -77, false },
  { 11258999068426240000uLL, -50, false },
  { 16777216000000000000uLL, -24, false },
  { 12500000000000000000uLL, 3, false },
  { 9313225746154785156uLL, 30, false },
  { 13877787807814456755uLL, 56, false },
  { 10339757656912845936uLL, 83, false },
  { 15407439555097886824uLL, 109, false },
  { 11479437019748901445uLL, 136, false },
  { 17105694144590052135uLL, 162, false },
  { 12744735289059618216uLL, 189, false },
  { 9495567745759798747uLL, 216, false },
  { 14149498560666738074uLL, 242, false },
  { 10542197943230523224uLL, 269, false },
  { 15709099088952724970uLL, 295, false },
  { 11704190886730495818uLL, 322, false },
  { 17440603504673385349uLL, 348, false },
  { 12994262207056124023uLL, 375, false },
  { 9681479787123295682uLL, 402, false },
  { 14426529090290212157uLL, 428, false },
  { 10748601772107342003uLL, 455, false },
  { 16016664761464807395uLL, 481, false },
  { 11933345169920330789uLL, 508, false },
  { 17782069995880619868uLL, 534, false },
  { 13248674568444952270uLL, 561, false },
  { 9871031767461413346uLL, 588, false },
  { 14708983551653345445uLL, 614, false },
  { 10959046745042015199uLL, 641, false },
  { 16330252207878254650uLL, 667, false },
  { 12166986024289022870uLL, 694, false },
  { 18130221999122236476uLL, 720, false },
  { 13508068024458167312uLL, 747, false },
  { 10064294952495520794uLL, 774, false },
  { 14996968138956309548uLL, 800, false },
  { 11173611982879273257uLL, 827, false },
  { 16649979327439178909uLL, 853, false },
  { 12405201291620119593uLL, 880, false },
  { 9242595204427927429uLL, 907, false },
  { 13772540099066387757uLL, 933, false },
  { 10261342003245940623uLL, 960, false },
  { 15290591125556738113uLL, 986, false },
  { 11392378155556871081uLL, 1013, false },
  { 16975966327722178521uLL, 1039, false },
  { 12648080533535911531uLL, 1066, false }
}; // idb
void **runtime_cgo_yield = &cgo_yield; // idb
unicode_RangeTable *unicode_ASCII_Hex_Digit = &unicode_statictmp_447; // idb
unicode_RangeTable *unicode_Adlam = &unicode_statictmp_96; // idb
unicode_RangeTable *unicode_Ahom = &unicode_statictmp_99; // idb
unicode_RangeTable *unicode_Anatolian_Hieroglyphs = &unicode_statictmp_102; // idb
unicode_RangeTable *unicode_Arabic = &unicode_statictmp_105; // idb
unicode_RangeTable *unicode_Armenian = &unicode_statictmp_108; // idb
unicode_RangeTable *unicode_Avestan = &unicode_statictmp_110; // idb
unicode_RangeTable *unicode_Balinese = &unicode_statictmp_113; // idb
unicode_RangeTable *unicode_Bamum = &unicode_statictmp_115; // idb
unicode_RangeTable *unicode_Bassa_Vah = &unicode_statictmp_118; // idb
unicode_RangeTable *unicode_Batak = &unicode_statictmp_121; // idb
unicode_RangeTable *unicode_Bengali = &unicode_statictmp_123; // idb
unicode_RangeTable *unicode_Bhaiksuki = &unicode_statictmp_125; // idb
unicode_RangeTable *unicode_Bidi_Control = &unicode_statictmp_449; // idb
unicode_RangeTable *unicode_Bopomofo = &unicode_statictmp_128; // idb
unicode_RangeTable *unicode_Brahmi = &unicode_statictmp_130; // idb
unicode_RangeTable *unicode_Braille = &unicode_statictmp_133; // idb
unicode_RangeTable *unicode_Buginese = &unicode_statictmp_135; // idb
unicode_RangeTable *unicode_Buhid = &unicode_statictmp_137; // idb
unicode_RangeTable *unicode_C = &unicode_statictmp_20; // idb
unicode_RangeTable *unicode_Canadian_Aboriginal = &unicode_statictmp_139; // idb
unicode_RangeTable *unicode_Carian = &unicode_statictmp_141; // idb
unicode_RangeTable *unicode_Caucasian_Albanian = &unicode_statictmp_144; // idb
unicode_RangeTable *unicode_Cc = &unicode_statictmp_23; // idb
unicode_RangeTable *unicode_Cf = &unicode_statictmp_25; // idb
unicode_RangeTable *unicode_Chakma = &unicode_statictmp_147; // idb
unicode_RangeTable *unicode_Cham = &unicode_statictmp_150; // idb
unicode_RangeTable *unicode_Cherokee = &unicode_statictmp_152; // idb
unicode_RangeTable *unicode_Co = &unicode_statictmp_28; // idb
unicode_RangeTable *unicode_Common = &unicode_statictmp_154; // idb
unicode_RangeTable *unicode_Coptic = &unicode_statictmp_157; // idb
unicode_RangeTable *unicode_Cs = &unicode_statictmp_31; // idb
unicode_RangeTable *unicode_Cuneiform = &unicode_statictmp_159; // idb
unicode_RangeTable *unicode_Cypriot = &unicode_statictmp_162; // idb
unicode_RangeTable *unicode_Cyrillic = &unicode_statictmp_165; // idb
unicode_RangeTable *unicode_Dash = &unicode_statictmp_451; // idb
unicode_RangeTable *unicode_Deprecated = &unicode_statictmp_453; // idb
unicode_RangeTable *unicode_Deseret = &unicode_statictmp_167; // idb
unicode_RangeTable *unicode_Devanagari = &unicode_statictmp_170; // idb
unicode_RangeTable *unicode_Diacritic = &unicode_statictmp_456; // idb
unicode_RangeTable *unicode_Duployan = &unicode_statictmp_172; // idb
unicode_RangeTable *unicode_Egyptian_Hieroglyphs = &unicode_statictmp_175; // idb
unicode_RangeTable *unicode_Elbasan = &unicode_statictmp_178; // idb
unicode_RangeTable *unicode_Ethiopic = &unicode_statictmp_181; // idb
unicode_RangeTable *unicode_Extender = &unicode_statictmp_459; // idb
unicode_RangeTable *unicode_Georgian = &unicode_statictmp_183; // idb
unicode_RangeTable *unicode_Glagolitic = &unicode_statictmp_185; // idb
unicode_RangeTable *unicode_Gothic = &unicode_statictmp_188; // idb
unicode_RangeTable *unicode_Grantha = &unicode_statictmp_191; // idb
unicode_RangeTable *unicode_Greek = &unicode_statictmp_194; // idb
unicode_RangeTable *unicode_Gujarati = &unicode_statictmp_197; // idb
unicode_RangeTable *unicode_Gurmukhi = &unicode_statictmp_199; // idb
unicode_RangeTable *unicode_Han = &unicode_statictmp_201; // idb
unicode_RangeTable *unicode_Hangul = &unicode_statictmp_204; // idb
unicode_RangeTable *unicode_Hanunoo = &unicode_statictmp_206; // idb
unicode_RangeTable *unicode_Hatran = &unicode_statictmp_208; // idb
unicode_RangeTable *unicode_Hebrew = &unicode_statictmp_211; // idb
unicode_RangeTable *unicode_Hex_Digit = &unicode_statictmp_462; // idb
unicode_RangeTable *unicode_Hiragana = &unicode_statictmp_213; // idb
unicode_RangeTable *unicode_Hyphen = &unicode_statictmp_464; // idb
unicode_RangeTable *unicode_IDS_Binary_Operator = &unicode_statictmp_466; // idb
unicode_RangeTable *unicode_IDS_Trinary_Operator = &unicode_statictmp_468; // idb
unicode_RangeTable *unicode_Ideographic = &unicode_statictmp_470; // idb
unicode_RangeTable *unicode_Imperial_Aramaic = &unicode_statictmp_216; // idb
unicode_RangeTable *unicode_Inherited = &unicode_statictmp_219; // idb
unicode_RangeTable *unicode_Inscriptional_Pahlavi = &unicode_statictmp_222; // idb
unicode_RangeTable *unicode_Inscriptional_Parthian = &unicode_statictmp_225; // idb
unicode_RangeTable *unicode_Javanese = &unicode_statictmp_228; // idb
unicode_RangeTable *unicode_Join_Control = &unicode_statictmp_473; // idb
unicode_RangeTable *unicode_Kaithi = &unicode_statictmp_230; // idb
unicode_RangeTable *unicode_Kannada = &unicode_statictmp_233; // idb
unicode_RangeTable *unicode_Katakana = &unicode_statictmp_235; // idb
unicode_RangeTable *unicode_Kayah_Li = &unicode_statictmp_238; // idb
unicode_RangeTable *unicode_Kharoshthi = &unicode_statictmp_240; // idb
unicode_RangeTable *unicode_Khmer = &unicode_statictmp_243; // idb
unicode_RangeTable *unicode_Khojki = &unicode_statictmp_245; // idb
unicode_RangeTable *unicode_Khudawadi = &unicode_statictmp_248; // idb
unicode_RangeTable *unicode_L = &unicode_statictmp_1; // idb
unicode_RangeTable *unicode_Lao = &unicode_statictmp_251; // idb
unicode_RangeTable *unicode_Latin = &unicode_statictmp_253; // idb
unicode_RangeTable *unicode_Lepcha = &unicode_statictmp_255; // idb
unicode_RangeTable *unicode_Limbu = &unicode_statictmp_257; // idb
unicode_RangeTable *unicode_Linear_A = &unicode_statictmp_259; // idb
unicode_RangeTable *unicode_Linear_B = &unicode_statictmp_262; // idb
unicode_RangeTable *unicode_Lisu = &unicode_statictmp_265; // idb
unicode_RangeTable *unicode_Ll = &unicode_statictmp_33; // idb
unicode_RangeTable *unicode_Lm = &unicode_statictmp_36; // idb
unicode_RangeTable *unicode_Lo = &unicode_statictmp_39; // idb
unicode_RangeTable *unicode_Logical_Order_Exception = &unicode_statictmp_475; // idb
unicode_RangeTable *unicode_Lt = &unicode_statictmp_42; // idb
unicode_RangeTable *unicode_Lu = &unicode_statictmp_44; // idb
unicode_RangeTable *unicode_Lycian = &unicode_statictmp_267; // idb
unicode_RangeTable *unicode_Lydian = &unicode_statictmp_270; // idb
unicode_RangeTable *unicode_M = &unicode_statictmp_4; // idb
unicode_RangeTable *unicode_Mahajani = &unicode_statictmp_273; // idb
unicode_RangeTable *unicode_Malayalam = &unicode_statictmp_276; // idb
unicode_RangeTable *unicode_Mandaic = &unicode_statictmp_278; // idb
unicode_RangeTable *unicode_Manichaean = &unicode_statictmp_280; // idb
unicode_RangeTable *unicode_Marchen = &unicode_statictmp_283; // idb
unicode_RangeTable *unicode_Mc = &unicode_statictmp_47; // idb
unicode_RangeTable *unicode_Me = &unicode_statictmp_50; // idb
unicode_RangeTable *unicode_Meetei_Mayek = &unicode_statictmp_286; // idb
unicode_RangeTable *unicode_Mende_Kikakui = &unicode_statictmp_288; // idb
unicode_RangeTable *unicode_Meroitic_Cursive = &unicode_statictmp_291; // idb
unicode_RangeTable *unicode_Meroitic_Hieroglyphs = &unicode_statictmp_294; // idb
unicode_RangeTable *unicode_Miao = &unicode_statictmp_297; // idb
unicode_RangeTable *unicode_Mn = &unicode_statictmp_52; // idb
unicode_RangeTable *unicode_Modi = &unicode_statictmp_300; // idb
unicode_RangeTable *unicode_Mongolian = &unicode_statictmp_303; // idb
unicode_RangeTable *unicode_Mro = &unicode_statictmp_306; // idb
unicode_RangeTable *unicode_Multani = &unicode_statictmp_309; // idb
unicode_RangeTable *unicode_Myanmar = &unicode_statictmp_312; // idb
unicode_RangeTable *unicode_N = &unicode_statictmp_7; // idb
unicode_RangeTable *unicode_Nabataean = &unicode_statictmp_314; // idb
unicode_RangeTable *unicode_Nd = &unicode_statictmp_55; // idb
unicode_RangeTable *unicode_New_Tai_Lue = &unicode_statictmp_317; // idb
unicode_RangeTable *unicode_Newa = &unicode_statictmp_319; // idb
unicode_RangeTable *unicode_Nko = &unicode_statictmp_322; // idb
unicode_RangeTable *unicode_Nl = &unicode_statictmp_58; // idb
unicode_RangeTable *unicode_No = &unicode_statictmp_61; // idb
unicode_RangeTable *unicode_Noncharacter_Code_Point = &unicode_statictmp_477; // idb
unicode_RangeTable *unicode_Ogham = &unicode_statictmp_324; // idb
unicode_RangeTable *unicode_Ol_Chiki = &unicode_statictmp_326; // idb
unicode_RangeTable *unicode_Old_Hungarian = &unicode_statictmp_328; // idb
unicode_RangeTable *unicode_Old_Italic = &unicode_statictmp_331; // idb
unicode_RangeTable *unicode_Old_North_Arabian = &unicode_statictmp_334; // idb
unicode_RangeTable *unicode_Old_Permic = &unicode_statictmp_337; // idb
unicode_RangeTable *unicode_Old_Persian = &unicode_statictmp_340; // idb
unicode_RangeTable *unicode_Old_South_Arabian = &unicode_statictmp_343; // idb
unicode_RangeTable *unicode_Old_Turkic = &unicode_statictmp_346; // idb
unicode_RangeTable *unicode_Oriya = &unicode_statictmp_349; // idb
unicode_RangeTable *unicode_Osage = &unicode_statictmp_351; // idb
unicode_RangeTable *unicode_Osmanya = &unicode_statictmp_354; // idb
unicode_RangeTable *unicode_Other_Alphabetic = &unicode_statictmp_480; // idb
unicode_RangeTable *unicode_Other_Default_Ignorable_Code_Point = &unicode_statictmp_483; // idb
unicode_RangeTable *unicode_Other_Grapheme_Extend = &unicode_statictmp_486; // idb
unicode_RangeTable *unicode_Other_ID_Continue = &unicode_statictmp_489; // idb
unicode_RangeTable *unicode_Other_ID_Start = &unicode_statictmp_491; // idb
unicode_RangeTable *unicode_Other_Lowercase = &unicode_statictmp_493; // idb
unicode_RangeTable *unicode_Other_Math = &unicode_statictmp_495; // idb
unicode_RangeTable *unicode_Other_Uppercase = &unicode_statictmp_498; // idb
unicode_RangeTable *unicode_P = &unicode_statictmp_10; // idb
unicode_RangeTable *unicode_Pahawh_Hmong = &unicode_statictmp_357; // idb
unicode_RangeTable *unicode_Palmyrene = &unicode_statictmp_360; // idb
unicode_RangeTable *unicode_Pattern_Syntax = &unicode_statictmp_501; // idb
unicode_RangeTable *unicode_Pattern_White_Space = &unicode_statictmp_503; // idb
unicode_RangeTable *unicode_Pau_Cin_Hau = &unicode_statictmp_363; // idb
unicode_RangeTable *unicode_Pc = &unicode_statictmp_64; // idb
unicode_RangeTable *unicode_Pd = &unicode_statictmp_66; // idb
unicode_RangeTable *unicode_Pe = &unicode_statictmp_68; // idb
unicode_RangeTable *unicode_Pf = &unicode_statictmp_70; // idb
unicode_RangeTable *unicode_Phags_Pa = &unicode_statictmp_366; // idb
unicode_RangeTable *unicode_Phoenician = &unicode_statictmp_368; // idb
unicode_RangeTable *unicode_Pi = &unicode_statictmp_72; // idb
unicode_RangeTable *unicode_Po = &unicode_statictmp_74; // idb
unicode_RangeTable *unicode_Prepended_Concatenation_Mark = &unicode_statictmp_505; // idb
unicode_RangeTable *unicode_Ps = &unicode_statictmp_77; // idb
unicode_RangeTable *unicode_Psalter_Pahlavi = &unicode_statictmp_371; // idb
unicode_RangeTable *unicode_Quotation_Mark = &unicode_statictmp_508; // idb
unicode_RangeTable *unicode_Radical = &unicode_statictmp_510; // idb
unicode_RangeTable *unicode_Rejang = &unicode_statictmp_374; // idb
unicode_RangeTable *unicode_Runic = &unicode_statictmp_376; // idb
unicode_RangeTable *unicode_S = &unicode_statictmp_13; // idb
unicode_RangeTable *unicode_Samaritan = &unicode_statictmp_378; // idb
unicode_RangeTable *unicode_Saurashtra = &unicode_statictmp_380; // idb
unicode_RangeTable *unicode_Sc = &unicode_statictmp_79; // idb
unicode_RangeTable *unicode_Sentence_Terminal = &unicode_statictmp_512; // idb
unicode_RangeTable *unicode_Sharada = &unicode_statictmp_382; // idb
unicode_RangeTable *unicode_Shavian = &unicode_statictmp_385; // idb
unicode_RangeTable *unicode_Siddham = &unicode_statictmp_388; // idb
unicode_RangeTable *unicode_SignWriting = &unicode_statictmp_391; // idb
unicode_RangeTable *unicode_Sinhala = &unicode_statictmp_394; // idb
unicode_RangeTable *unicode_Sk = &unicode_statictmp_81; // idb
unicode_RangeTable *unicode_Sm = &unicode_statictmp_84; // idb
unicode_RangeTable *unicode_So = &unicode_statictmp_87; // idb
unicode_RangeTable *unicode_Soft_Dotted = &unicode_statictmp_515; // idb
unicode_RangeTable *unicode_Sora_Sompeng = &unicode_statictmp_397; // idb
unicode_RangeTable *unicode_Sundanese = &unicode_statictmp_400; // idb
unicode_RangeTable *unicode_Syloti_Nagri = &unicode_statictmp_402; // idb
unicode_RangeTable *unicode_Syriac = &unicode_statictmp_404; // idb
unicode_RangeTable *unicode_Tagalog = &unicode_statictmp_406; // idb
unicode_RangeTable *unicode_Tagbanwa = &unicode_statictmp_408; // idb
unicode_RangeTable *unicode_Tai_Le = &unicode_statictmp_410; // idb
unicode_RangeTable *unicode_Tai_Tham = &unicode_statictmp_412; // idb
unicode_RangeTable *unicode_Tai_Viet = &unicode_statictmp_414; // idb
unicode_RangeTable *unicode_Takri = &unicode_statictmp_416; // idb
unicode_RangeTable *unicode_Tamil = &unicode_statictmp_419; // idb
unicode_RangeTable *unicode_Tangut = &unicode_statictmp_421; // idb
unicode_RangeTable *unicode_Telugu = &unicode_statictmp_424; // idb
unicode_RangeTable *unicode_Terminal_Punctuation = &unicode_statictmp_518; // idb
unicode_RangeTable *unicode_Thaana = &unicode_statictmp_426; // idb
unicode_RangeTable *unicode_Thai = &unicode_statictmp_428; // idb
unicode_RangeTable *unicode_Tibetan = &unicode_statictmp_430; // idb
unicode_RangeTable *unicode_Tifinagh = &unicode_statictmp_432; // idb
unicode_RangeTable *unicode_Tirhuta = &unicode_statictmp_434; // idb
unicode_RangeTable *unicode_Ugaritic = &unicode_statictmp_437; // idb
unicode_RangeTable *unicode_Unified_Ideograph = &unicode_statictmp_521; // idb
unicode_RangeTable *unicode_Vai = &unicode_statictmp_440; // idb
unicode_RangeTable *unicode_Variation_Selector = &unicode_statictmp_524; // idb
unicode_RangeTable *unicode_Warang_Citi = &unicode_statictmp_442; // idb
unicode_RangeTable *unicode_White_Space = &unicode_statictmp_527; // idb
unicode_RangeTable *unicode_Yi = &unicode_statictmp_445; // idb
unicode_RangeTable *unicode_Z = &unicode_statictmp_90; // idb
unicode_RangeTable *unicode_Zl = &unicode_statictmp_92; // idb
unicode_RangeTable *unicode_Zp = &unicode_statictmp_94; // idb
unicode_RangeTable *unicode_Zs = &unicode_statictmp_16; // idb
unicode_RangeTable *unicode_foldCommon = &unicode_statictmp_545; // idb
unicode_RangeTable *unicode_foldGreek = &unicode_statictmp_547; // idb
unicode_RangeTable *unicode_foldInherited = &unicode_statictmp_549; // idb
unicode_RangeTable *unicode_foldL = &unicode_statictmp_531; // idb
unicode_RangeTable *unicode_foldLl = &unicode_statictmp_533; // idb
unicode_RangeTable *unicode_foldLt = &unicode_statictmp_536; // idb
unicode_RangeTable *unicode_foldLu = &unicode_statictmp_538; // idb
unicode_RangeTable *unicode_foldM = &unicode_statictmp_541; // idb
unicode_RangeTable *unicode_foldMn = &unicode_statictmp_543; // idb
error_0 internal_poll_ErrTimeout = { &go_itab__internal_poll_TimeoutError_error, &runtime_noptrbss }; // idb
string runtime_buildVersion = { &aGo192, 7 }; // idb
error_0 runtime_divideError = { &go_itab_runtime_errorString_error, &runtime_statictmp_40 }; // idb
error_0 runtime_floatError = { &go_itab_runtime_errorString_error, &runtime_statictmp_42 }; // idb
error runtime_indexError = { &go_itab_runtime_errorString_error, &runtime_statictmp_43 }; // idb
error_0 runtime_memoryError = { &go_itab_runtime_errorString_error, &runtime_statictmp_39 }; // idb
error_0 runtime_overflowError = { &go_itab_runtime_errorString_error, &runtime_statictmp_41 }; // idb
error_0 runtime_sliceError = { &go_itab_runtime_errorString_error, &runtime_statictmp_44 }; // idb
sync_Pool fmt_ppFree = { NULL, 0u, &off_80E7B10 }; // idb
__string reflect_kindNames = { &reflect_statictmp_125, 27, 27 }; // idb
__runtime_dbgVar runtime_dbgvars = { &runtime_statictmp_45, 14, 14 }; // idb
__uint8 runtime_earlycgocallback = { &runtime__gobytes_6, 42, 42 }; // idb
__string runtime_mSpanStateNames = { &runtime_statictmp_38, 4, 4 }; // idb
__uint8 runtime_procAuxv = { &runtime__gobytes_4, 16, 16 }; // idb
__uint8 runtime_urandom_dev = { &runtime__gobytes_5, 13, 13 }; // idb
__uint16 strconv_isGraphic = { &strconv_statictmp_15, 16, 16 }; // idb
__uint16 strconv_isNotPrint16 = { &strconv_statictmp_12, 139, 139 }; // idb
__uint16 strconv_isNotPrint32 = { &strconv_statictmp_14, 82, 82 }; // idb
__uint16 strconv_isPrint16 = { &strconv_statictmp_11, 462, 462 }; // idb
__uint32 strconv_isPrint32 = { &strconv_statictmp_13, 378, 378 }; // idb
__strconv_leftCheat strconv_leftcheats = { &strconv_statictmp_10, 61, 61 }; // idb
syscall_mmapper syscall_statictmp_51 = { { 0, 0u }, NULL, &off_80E7D18, &off_80E7D1C }; // idb
string time_statictmp_23[4] =
{
  { &aUsrShareZonein, 20 },
  { &aUsrShareLibZon, 24 },
  { &aUsrLibLocaleTz, 19 },
  { NULL, 0 }
}; // idb
string runtime_gStatusStrings[9] =
{
  { &aIdle, 4 },
  { &aRunnable, 8 },
  { &aRunning, 7 },
  { &aSyscall, 7 },
  { &aWaiting, 7 },
  { NULL, 0 },
  { &aDead, 4 },
  { NULL, 0 },
  { &aCopystack, 9 }
}; // idb
runtime_typeAlg_0 runtime_algarray[14] =
{
  { NULL, NULL },
  { &off_80E7C5C, &off_80E7C44 },
  { &off_80E7C70, &off_80E7C58 },
  { &off_80E7C64, &off_80E7C4C },
  { &off_80E7C68, &off_80E7C50 },
  { &off_80E7C6C, &off_80E7C54 },
  { &off_80E7C60, &off_80E7C48 },
  { &off_80E7CE4, &off_80E7CE0 },
  { &off_80E7C24, &off_80E7C20 },
  { &off_80E7C94, &off_80E7C90 },
  { &off_80E7BE4, &off_80E7BE0 },
  { &off_80E7BEC, &off_80E7BE8 },
  { &off_80E7BA4, &off_80E7BA0 },
  { &off_80E7B9C, &off_80E7B98 }
}; // idb
runtime_sigTabT runtime_sigtable[65] =
{
  { 0, { &aSignoneNoTrap, 16 } },
  { 3, { &aSighupTerminal, 28 } },
  { 3, { &aSigintInterrup, 17 } },
  { 5, { &aSigquitQuit, 13 } },
  { 132, { &aSigillIllegalI, 27 } },
  { 132, { &aSigtrapTraceTr, 19 } },
  { 5, { &aSigabrtAbort, 14 } },
  { 136, { &aSigbusBusError, 17 } },
  { 136, { &aSigfpeFloating, 32 } },
  { 0, { &aSigkillKill, 13 } },
  { 1, { &aSigusr1UserDef, 30 } },
  { 136, { &aSigsegvSegment, 31 } },
  { 1, { &aSigusr2UserDef, 30 } },
  { 1, { &aSigpipeWriteTo, 29 } },
  { 1, { &aSigalrmAlarmCl, 20 } },
  { 3, { &aSigtermTermina, 20 } },
  { 132, { &aSigstkfltStack, 22 } },
  { 129, { &aSigchldChildSt, 33 } },
  { 17, { &aSigcontContinu, 17 } },
  { 0, { &aSigstopStopUnb, 26 } },
  { 17, { &aSigtstpKeyboar, 22 } },
  { 17, { &aSigttinBackgro, 33 } },
  { 17, { &aSigttouBackgro, 32 } },
  { 1, { &aSigurgUrgentCo, 34 } },
  { 1, { &aSigxcpuCpuLimi, 27 } },
  { 1, { &aSigxfszFileSiz, 33 } },
  { 1, { &aSigvtalrmVirtu, 30 } },
  { 129, { &aSigprofProfili, 30 } },
  { 1, { &aSigwinchWindow, 28 } },
  { 1, { &aSigioIONowPoss, 23 } },
  { 1, { &aSigpwrPowerFai, 29 } },
  { 4, { &aSigsysBadSyste, 23 } },
  { 192, { &aSignal32, 9 } },
  { 192, { &aSignal33, 9 } },
  { 1, { &aSignal34, 9 } },
  { 1, { &aSignal35, 9 } },
  { 1, { &aSignal36, 9 } },
  { 1, { &aSignal37, 9 } },
  { 1, { &aSignal38, 9 } },
  { 1, { &aSignal39, 9 } },
  { 1, { &aSignal40, 9 } },
  { 1, { &aSignal41, 9 } },
  { 1, { &aSignal42, 9 } },
  { 1, { &aSignal43, 9 } },
  { 1, { &aSignal44, 9 } },
  { 1, { &aSignal45, 9 } },
  { 1, { &aSignal46, 9 } },
  { 1, { &aSignal47, 9 } },
  { 1, { &aSignal48, 9 } },
  { 1, { &aSignal49, 9 } },
  { 1, { &aSignal50, 9 } },
  { 1, { &aSignal51, 9 } },
  { 1, { &aSignal52, 9 } },
  { 1, { &aSignal53, 9 } },
  { 1, { &aSignal54, 9 } },
  { 1, { &aSignal55, 9 } },
  { 1, { &aSignal56, 9 } },
  { 1, { &aSignal57, 9 } },
  { 1, { &aSignal58, 9 } },
  { 1, { &aSignal59, 9 } },
  { 1, { &aSignal60, 9 } },
  { 1, { &aSignal61, 9 } },
  { 1, { &aSignal62, 9 } },
  { 1, { &aSignal63, 9 } },
  { 1, { &aSignal64, 9 } }
}; // idb
string syscall_errors[133] =
{
  { NULL, 0 },
  { &aOperationNotPe, 23 },
  { &aNoSuchFileOrDi, 25 },
  { &aNoSuchProcess, 15 },
  { &aInterruptedSys, 23 },
  { &aInputOutputErr, 18 },
  { &aNoSuchDeviceOr, 25 },
  { &aArgumentListTo, 22 },
  { &aExecFormatErro, 17 },
  { &aBadFileDescrip, 19 },
  { &aNoChildProcess, 18 },
  { &aResourceTempor, 32 },
  { &aCannotAllocate, 22 },
  { &aPermissionDeni, 17 },
  { &aBadAddress, 11 },
  { &aBlockDeviceReq, 21 },
  { &aDeviceOrResour, 23 },
  { &aFileExists, 11 },
  { &aInvalidCrossDe, 25 },
  { &aNoSuchDevice, 14 },
  { &aNotADirectory, 15 },
  { &aIsADirectory, 14 },
  { &aInvalidArgumen, 16 },
  { &aTooManyOpenFil, 29 },
  { &aTooManyOpenFil_0, 19 },
  { &aInappropriateI, 30 },
  { &aTextFileBusy, 14 },
  { &aFileTooLarge, 14 },
  { &aNoSpaceLeftOnD, 23 },
  { &aIllegalSeek, 12 },
  { &aReadOnlyFileSy, 21 },
  { &aTooManyLinks, 14 },
  { &aBrokenPipe, 11 },
  { &aNumericalArgum, 32 },
  { &aNumericalResul, 29 },
  { &aResourceDeadlo, 25 },
  { &aFileNameTooLon, 18 },
  { &aNoLocksAvailab, 18 },
  { &aFunctionNotImp, 24 },
  { &aDirectoryNotEm, 19 },
  { &aTooManyLevelsO, 33 },
  { NULL, 0 },
  { &aNoMessageOfDes, 26 },
  { &aIdentifierRemo, 18 },
  { &aChannelNumberO, 27 },
  { &aLevel2NotSynch, 24 },
  { &aLevel3Halted, 14 },
  { &aLevel3Reset, 13 },
  { &aLinkNumberOutO, 24 },
  { &aProtocolDriver, 28 },
  { &aNoCsiStructure, 26 },
  { &aLevel2Halted, 14 },
  { &aInvalidExchang, 16 },
  { &aInvalidRequest, 26 },
  { &aExchangeFull, 13 },
  { &aNoAnode, 8 },
  { &aInvalidRequest_0, 20 },
  { &aInvalidSlot, 12 },
  { NULL, 0 },
  { &aBadFontFileFor, 20 },
  { &aDeviceNotAStre, 19 },
  { &aNoDataAvailabl, 17 },
  { &aTimerExpired, 13 },
  { &aOutOfStreamsRe, 24 },
  { &aMachineIsNotOn, 29 },
  { &aPackageNotInst, 21 },
  { &aObjectIsRemote, 16 },
  { &aLinkHasBeenSev, 21 },
  { &aAdvertiseError, 15 },
  { &aSrmountError, 13 },
  { &aCommunicationE, 27 },
  { &aProtocolError, 14 },
  { &aMultihopAttemp, 18 },
  { &aRfsSpecificErr, 18 },
  { &aBadMessage, 11 },
  { &aValueTooLargeF, 37 },
  { &aNameNotUniqueO, 26 },
  { &aFileDescriptor, 28 },
  { &aRemoteAddressC, 22 },
  { &aCanNotAccessAN, 38 },
  { &aAccessingACorr, 36 },
  { &aLibSectionInAO, 31 },
  { &aAttemptingToLi, 47 },
  { &aCannotExecASha, 37 },
  { &aInvalidOrIncom, 49 },
  { &aInterruptedSys_0, 43 },
  { &aStreamsPipeErr, 18 },
  { &aTooManyUsers, 14 },
  { &aSocketOperatio, 30 },
  { &aDestinationAdd, 28 },
  { &aMessageTooLong, 16 },
  { &aProtocolWrongT, 30 },
  { &aProtocolNotAva, 22 },
  { &aProtocolNotSup, 22 },
  { &aSocketTypeNotS, 25 },
  { &aOperationNotSu, 23 },
  { &aProtocolFamily, 29 },
  { &aAddressFamilyN, 40 },
  { &aAddressAlready, 22 },
  { &aCannotAssignRe, 31 },
  { &aNetworkIsDown, 15 },
  { &aNetworkIsUnrea, 22 },
  { &aNetworkDropped, 35 },
  { &aSoftwareCaused, 32 },
  { &aConnectionRese, 24 },
  { &aNoBufferSpaceA, 25 },
  { &aTransportEndpo, 39 },
  { &aTransportEndpo_0, 35 },
  { &aCannotSendAfte, 45 },
  { &aTooManyReferen, 34 },
  { &aConnectionTime, 20 },
  { &aConnectionRefu, 18 },
  { &aHostIsDown, 12 },
  { &aNoRouteToHost, 16 },
  { &aOperationAlrea, 29 },
  { &aOperationNowIn, 25 },
  { &aStaleNfsFileHa, 21 },
  { &aStructureNeeds, 24 },
  { &aNotAXenixNamed, 27 },
  { &aNoXenixSemapho, 29 },
  { &aIsANamedTypeFi, 20 },
  { &aRemoteIOError, 16 },
  { &aDiskQuotaExcee, 19 },
  { &aNoMediumFound, 15 },
  { &aWrongMediumTyp, 17 },
  { &aOperationCance, 18 },
  { &aRequiredKeyNot, 26 },
  { &aKeyHasExpired, 15 },
  { &aKeyHasBeenRevo, 20 },
  { &aKeyWasRejected, 27 },
  { &aOwnerDied, 10 },
  { &aStateNotRecove, 21 },
  { &aOperationNotPo, 37 }
}; // idb
void *runtime_bss; // idb
void *cgo_notify_runtime_init_done; // idb
void *cgo_thread_start; // idb
uintptr os_Stderr; // idb
uintptr os_Stdin; // idb
uintptr os_Stdout; // idb
uintptr reflect_uint8Type; // idb
void *runtime__cgo_setenv; // idb
void *runtime__cgo_unsetenv; // idb
runtime_finblock *runtime_allfin; // idb
uintptr runtime_allm; // idb
uintptr runtime_argv; // idb
runtime_bucket *runtime_bbuckets; // idb
uintptr runtime_buckhash; // idb
void *runtime_cgoSymbolizer; // idb
void *runtime_cgoTraceback; // idb
uintptr runtime_deferType; // idb
runtime_finblock *runtime_finc; // idb
uintptr runtime_fing; // idb
runtime_finblock *runtime_finq; // idb
chan_bool runtime_main_init_done; // idb
runtime_bucket *runtime_mbuckets; // idb
void *runtime_modulesSlice; // idb
func() runtime_poolcleanup; // idb
runtime_bucket *runtime_xbuckets; // idb
uintptr sync_expunged; // idb
map_string_int64 time_unitMap; // idb
map_string__unicode_RangeTable unicode_Categories; // idb
map_string__unicode_RangeTable unicode_FoldCategory; // idb
map_string__unicode_RangeTable unicode_FoldScript; // idb
map_string__unicode_RangeTable unicode_Properties; // idb
map_string__unicode_RangeTable unicode_Scripts; // idb
error_0 fmt_boolError; // idb
error_0 fmt_complexError; // idb
error_0 internal_poll_ErrFileClosing; // idb
error_0 internal_poll_ErrNetClosing; // idb
error_0 io_EOF; // idb
error_0 io_ErrClosedPipe; // idb
error_0 io_ErrNoProgress; // idb
error_0 io_ErrShortBuffer; // idb
error_0 io_ErrShortWrite; // idb
error_0 io_ErrUnexpectedEOF; // idb
error_0 io_errOffset; // idb
error_0 io_errWhence; // idb
error_0 os_ErrClosed; // idb
error_0 os_ErrExist; // idb
error_0 os_ErrInvalid; // idb
error_0 os_ErrNotExist; // idb
error_0 os_ErrPermission; // idb
error_0 os_errFinished; // idb
string os_executablePath; // idb
error_0 os_executablePathErr; // idb
runtime_pollCache runtime_pollcache; // idb
error_0 strconv_ErrRange; // idb
error_0 strconv_ErrSyntax; // idb
error_0 time_atoiError; // idb
error_0 time_badData; // idb
error_0 time_errBad; // idb
error_0 time_errLeadingInt; // idb
error_0 time_errLocation; // idb
__string os_Args; // idb
struct_{_reflect_b_bool__reflect_x_interface_{}_} reflect_dummy; // idb
___runtime_g runtime_allgs; // idb
__string runtime_argslice; // idb
__string runtime_envs; // idb
runtime_forcegcstate runtime_forcegc; // idb
struct_{_runtime_mutex__runtime_persistentAlloc_} runtime_globalAlloc; // idb
__map_runtime_typeOff__runtime__type runtime_pinnedTypemaps; // idb
__uint8 runtime_startupRandomData; // idb
___sync_Pool sync_allPools; // idb
__string syscall_envs; // idb
struct_{_runtime_lock_runtime_mutex__runtime_next_int32__runtime_m_map_int32_unsafe_Pointer__runtime_minv_map_unsafe_Pointer_int32_} runtime_reflectOffs; // idb
runtime_randomOrder runtime_stealOrder; // idb
struct_{_runtime_lock_runtime_mutex__runtime_free__runtime_gcBitsArena__runtime_next__runtime_gcBitsArena__runtime_current__runtime_gcBitsArena__runtime_previous__runtime_gcBitsArena_} runtime_gcBitsArenas; // idb
runtime_sweepdata runtime_sweep; // idb
sync_Map_0 reflect_layoutCache; // idb
sync_Map reflect_methodCache; // idb
sync_Map_0 reflect_ptrMap; // idb
struct_{_sync_Mutex__reflect_m_sync_Map_} reflect_funcLookupCache; // idb
runtime_mSpanList_0 runtime_stackpool[4]; // idb
struct_{_runtime_lock_runtime_mutex__runtime_gp__runtime_g__runtime_created_bool__runtime_sleeping_bool__runtime_rescheduling_bool__runtime_sleepUntil_int64__runtime_waitnote_runtime_note__runtime_t____runtime_timer_} runtime_timers; // idb
runtime_mspan_0 runtime_emptymspan; // idb
struct_{_runtime_lock_runtime_mutex__runtime_free__19_runtime_mSpanList_} runtime_stackLarge; // idb
runtime_schedt runtime_sched; // idb
runtime_g_0 runtime_g0; // idb
struct_{_runtime_full_runtime_lfstack__runtime_empty_runtime_lfstack__runtime_pad0__64_uint8__runtime_wbufSpans_struct_{_runtime_lock_runtime_mutex__runtime_free_runtime_mSpanList__runtime_busy_runtime_mSpanList_}____uint32__runtime_bytesMarked_uint64__runtime_markrootNext_uint32__runtime_markrootJobs_uint32__runtime_nproc_uint32__runtime_tstart_int64__runtime_nwait_uint32__runtime_ndone_uint32__runtime_alldone_runtime_note__runtime_helperDrainBlock_bool__runtime_nFlushCacheRoots_int__runtime_nDataRoots_int__runtime_nBSSRoots_int__runtime_nSpanRoots_int__runtime_nStackRoots_int__runtime_markrootDone_bool__runtime_startSema_uint32__runtime_markDoneSema_uint32__runtime_bgMarkReady_runtime_note__runtime_bgMarkDone_uint32__runtime_mode_runtime_gcMode__runtime_userForced_bool__runtime_totaltime_int64__runtime_initialHeapLive_uint64__runtime_assistQueue_struct_{_runtime_lock_runtime_mutex__runtime_head_runtime_guintptr__runtime_tail_runtime_guintptr_}__runtime_sweepWaiters_struct_{_runtime_lock_runtime_mutex__runtime_head_runtime_guintptr_}__runtime_cycles_uint32__runtime_stwprocs_int32__runtime_maxprocs_int32__runtime_tSweepTerm_int64__runtime_tMark_int64__runtime_tMarkTerm_int64__runtime_tEnd_int64__runtime_pauseNS_int64__runtime_pauseStart_int64__runtime_heap0_uint64__runtime_heap1_uint64__runtime_heap2_uint64__runtime_heapGoal_uint64_} runtime_work; // idb
runtime_m_0 runtime_m0; // idb
runtime_cpuProfile runtime_cpuprof; // idb
runtime_itab_0 *runtime_hash[1009]; // idb
runtime_p *runtime_allp[1025]; // idb
runtime_mheap runtime_mheap_; // idb
int dword_81490F0; // weak
uint32 ptr; // idb
int dword_81490FC; // weak
int dword_8149100; // weak
int dword_8149108; // weak
int dword_814910C; // weak
_DWORD dword_8149114[11]; // weak
__int64 qword_8149140; // weak
uint64 qword_8149148; // idb
int dword_8149158; // weak
int dword_814915C; // weak
__int64 qword_8149160; // weak
__int64 qword_8149168; // weak
__int64 qword_8149170; // weak
__int64 qword_8149178; // weak
__int64 qword_8149180; // weak
_QWORD qword_8149188[67]; // weak
int dword_81493A0; // weak
int dword_81493A8; // weak
int dword_81493AC; // weak
int dword_81493B0; // weak
int dword_81493B4; // weak
char byte_81493B8; // weak
runtime_fixalloc_0 f; // idb
runtime_fixalloc_0 stru_814B588; // idb
runtime_fixalloc_0 stru_814B5AC; // idb
runtime_fixalloc_0 stru_814B5D0; // idb
runtime_mutex_0 l; // idb
struct_{_runtime_root_runtime_semaRoot__runtime_pad__52_uint8_} runtime_semtable[251]; // idb
struct_{_runtime_lock_runtime_mutex__runtime_lockOwner__runtime_g__runtime_enabled_bool__runtime_shutdown_bool__runtime_headerWritten_bool__runtime_footerWritten_bool__runtime_shutdownSema_uint32__runtime_seqStart_uint64__runtime_ticksStart_int64__runtime_ticksEnd_int64__runtime_timeStart_int64__runtime_timeEnd_int64__runtime_seqGC_uint64__runtime_reading_runtime_traceBufPtr__runtime_empty_runtime_traceBufPtr__runtime_fullHead_runtime_traceBufPtr__runtime_fullTail_runtime_traceBufPtr__runtime_reader_runtime_guintptr__runtime_stackTab_runtime_traceStackTable__runtime_strings_map_string_uint64__runtime_stringSeq_uint64__runtime_markWorkerLabels__3_uint64__runtime_bufLock_runtime_mutex__runtime_buf_runtime_traceBufPtr_} runtime_trace; // idb
unicode_Range16_0 runtime_noptrbss[]; // idb
uint8 internal_poll_initdone_; // idb
uint8 io_initdone_; // idb
uint8 main_initdone_; // idb
uint8 os_initdone_; // idb
uint8 reflect_initdone_; // idb
bool runtime_cgoHasExtraM; // idb
bool runtime_didothers; // idb
bool runtime_fingRunning; // idb
bool runtime_fingwait; // idb
bool runtime_fingwake; // idb
bool runtime_framepointer_enabled; // idb
bool runtime_gcBlackenPromptly; // idb
uint8 runtime_initdone_; // idb
bool runtime_isIntel; // idb
bool runtime_isarchive; // idb
bool runtime_iscgo; // idb
bool runtime_islibrary; // idb
bool runtime_lfenceBeforeRdtsc; // idb
bool runtime_mainStarted; // idb
bool runtime_signalsOK; // idb
bool runtime_support_aes; // idb
bool runtime_support_avx; // idb
bool runtime_support_avx2; // idb
bool runtime_support_bmi1; // idb
bool runtime_support_bmi2; // idb
bool runtime_support_erms; // idb
bool runtime_support_osxsave; // idb
bool runtime_support_popcnt; // idb
bool runtime_support_sse2; // idb
bool runtime_support_sse41; // idb
bool runtime_support_sse42; // idb
bool runtime_support_ssse3; // idb
bool runtime_useAeshash; // idb
bool runtime_useCheckmark; // idb
uint8 strconv_initdone_; // idb
uint8 sync_initdone_; // idb
uint8 syscall_initdone_; // idb
uint8 time_initdone_; // idb
uint8 unicode_initdone_; // idb
uintptr runtime_allglen; // idb
runtime_mutex_0 runtime_allglock; // idb
int32 runtime_argc; // idb
uintptr runtime_bgsweepPC; // idb
uintptr runtime_bucketmem; // idb
uintptr runtime_cgocallback_gofuncPC; // idb
uintptr runtime_chanrecvpc; // idb
uintptr runtime_chansendpc; // idb
int32 runtime_crashing; // idb
runtime_mutex_0 runtime_deadlock; // idb
runtime_mutex_0 runtime_debuglock; // idb
uintptr runtime_externalthreadhandlerp; // idb
uint32 runtime_extraMCount; // idb
uint32 runtime_extraMWaiters; // idb
uint32 runtime_fingCreate; // idb
runtime_mutex_0 runtime_finlock; // idb
uintptr runtime_forcegchelperPC; // idb
uint32 runtime_freezing; // idb
uintptr runtime_gcBgMarkWorkerPC; // idb
uint32 runtime_gcBlackenEnabled; // idb
int32 runtime_gcpercent; // idb
uint32 runtime_gcphase; // idb
uintptr runtime_goexitPC; // idb
uintptr runtime_gogoPC; // idb
int32 runtime_gomaxprocs; // idb
runtime_mutex_0 runtime_ifaceLock; // idb
uintptr runtime_jmpdeferPC; // idb
uintptr runtime_mcallPC; // idb
uintptr runtime_morestackPC; // idb
uintptr runtime_mstartPC; // idb
int32 runtime_ncpu; // idb
uint32 runtime_netpollInited; // idb
uint32 runtime_netpollWaiters; // idb
int32 runtime_newprocs; // idb
uint32 runtime_panicking; // idb
runtime_mutex_0 runtime_paniclk; // idb
uintptr runtime_physPageSize; // idb
__int32 runtime_printBacklogIndex; // idb
uint32 runtime_processorVersionInfo; // idb
runtime_mutex_0 runtime_proflock; // idb
uintptr runtime_rt0_goPC; // idb
uintptr runtime_runfinqPC; // idb
uint32 runtime_runningPanicDefers; // idb
uintptr runtime_sigpanicPC; // idb
uintptr runtime_skipPC; // idb
runtime_mutex_0 runtime_stackpoolmu; // idb
uintptr runtime_systemstackPC; // idb
uintptr runtime_systemstack_switchPC; // idb
uintptr runtime_timerprocPC; // idb
uint32 runtime_traceback_env; // idb
runtime_mutex_0 runtime_tracelock; // idb
uintptr runtime_zerobase; // idb
uintptr syscall_Stdin; // idb
uintptr syscall__zero; // idb
uint64 runtime_blockprofilerate; // idb
int64 runtime_faketime; // idb
float64 runtime_inf; // idb
runtime_sigset runtime_initSigmask; // idb
struct_{_runtime_cycle_uint32__runtime_flushed_bool_} runtime_mProf; // idb
uint64 runtime_mutexprofilerate; // idb
struct_{_runtime_signalLock_uint32__runtime_hz_int32_} runtime_prof; // idb
int64 runtime_runtimeInitTime; // idb
int64 runtime_startNano; // idb
int64 runtime_starttime; // idb
uint64 runtime_test_x64; // idb
uint64 runtime_test_z64; // idb
sync_Mutex_0 sync_allPoolsMu; // idb
sync_Once internal_poll_serverInit; // idb
__uint8 runtime_hashkey; // idb
_UNKNOWN unk_81576EC; // weak
struct_{_runtime_enabled_bool__runtime_pad__3_uint8__runtime_needed_bool__runtime_cgo_bool__runtime_alignme_uint64_} runtime_writeBarrier; // idb
runtime_rwmutex runtime_execLock; // idb
struct_{_runtime_allocfreetrace_int32__runtime_cgocheck_int32__runtime_efence_int32__runtime_gccheckmark_int32__runtime_gcpacertrace_int32__runtime_gcshrinkstackoff_int32__runtime_gcrescanstacks_int32__runtime_gcstoptheworld_int32__runtime_gctrace_int32__runtime_invalidptr_int32__runtime_sbrk_int32__runtime_scavenge_int32__runtime_scheddetail_int32__runtime_schedtrace_int32_} runtime_debug; // idb
struct_{_runtime_note_runtime_note__runtime_mask__3_uint32__runtime_wanted__3_uint32__runtime_ignored__3_uint32__runtime_recv__3_uint32__runtime_state_uint32__runtime_inuse_bool_} runtime_sig; // idb
__uint8 runtime_aeskeysched; // idb
_UNKNOWN unk_81577B0; // weak
_UNKNOWN unk_81577C0; // weak
_UNKNOWN unk_81577D0; // weak
uint8 runtime_finptrmask[128]; // idb
runtime_gcControllerState runtime_gcController; // idb
__int64 qword_8157870; // weak
__int64 qword_8157878; // weak
__int64 qword_8157880; // weak
int dword_8157888; // weak
int dword_815788C; // weak
__int64 qword_8157890; // weak
__int64 qword_81578A0; // weak
__int64 qword_81578A8; // weak
_UNKNOWN unk_81578F8; // weak
uintptr runtime_fwdSig[65]; // idb
uint32 runtime_handlingSig[65]; // idb
uint8 runtime_zeroVal[1024]; // idb
runtime_mstats runtime_memstats; // idb


//----- (08049000) --------------------------------------------------------
void __golang sync_atomic___ptr_Value__Load(sync_atomic_Value_0 *v, interface_{} x)
{
  int v2; // [esp+4h] [ebp-8h]

  sync_atomic_LoadPointer();
  if ( v2 )
  {
    if ( v2 != -1 )
      sync_atomic_LoadPointer();
  }
}
// 8049039: variable 'v2' is possibly undefined

//----- (08049090) --------------------------------------------------------
void __golang sync_atomic___ptr_Value__Store(sync_atomic_Value_0 *v, interface_{} x)
{
  interface_{} ptr; // [esp+0h] [ebp-10h]
  interface_{} ptra; // [esp+0h] [ebp-10h]
  runtime__type_0 *newa; // [esp+4h] [ebp-Ch]

  if ( !x._type )
  {
    ptra._type = (runtime__type_0 *)&t;
    ptra.data = &sync_atomic_statictmp_1;
    runtime_gopanic(ptra);
    BUG();
  }
  do
  {
    while ( 1 )
    {
      sync_atomic_LoadPointer();
      if ( newa )
        break;
      sync_atomic_runtime_procPin();
      if ( sync_atomic_CompareAndSwapPointer((void **)&v->v._type, 0, (void *)0xFFFFFFFF) )
      {
        sync_atomic_StorePointer(&v->v.data, x.data);
        sync_atomic_StorePointer((void **)&v->v._type, x._type);
        sync_atomic_runtime_procUnpin();
        return;
      }
      sync_atomic_runtime_procUnpin();
    }
  }
  while ( newa == (runtime__type_0 *)-1 );
  if ( newa != x._type )
  {
    ptr._type = (runtime__type_0 *)&t;
    ptr.data = &sync_atomic_statictmp_2;
    runtime_gopanic(ptr);
    BUG();
  }
  sync_atomic_StorePointer(&v->v.data, x.data);
}
// 80490C9: variable 'newa' is possibly undefined

//----- (080491B0) --------------------------------------------------------
void __golang sync_atomic_CompareAndSwapUint32()
{
  volatile signed __int32 *v0; // [esp+4h] [ebp+4h]
  signed __int32 v1; // [esp+8h] [ebp+8h]
  signed __int32 v2; // [esp+Ch] [ebp+Ch]

  _InterlockedCompareExchange(v0, v2, v1);
}

//----- (080491E0) --------------------------------------------------------
void __golang sync_atomic_CompareAndSwapUint64()
{
  volatile signed __int64 *v0; // [esp+4h] [ebp+4h]
  signed __int64 v1; // [esp+8h] [ebp+8h]
  signed __int64 v2; // [esp+10h] [ebp+10h]

  _InterlockedCompareExchange64(v0, v2, v1);
}

//----- (08049220) --------------------------------------------------------
void __golang sync_atomic_AddUint32()
{
  volatile signed __int32 *v0; // [esp+4h] [ebp+4h]
  unsigned int v1; // [esp+8h] [ebp+8h]

  _InterlockedExchangeAdd(v0, v1);
}

//----- (08049240) --------------------------------------------------------
void __golang sync_atomic_LoadUint32()
{
  ;
}

//----- (08049250) --------------------------------------------------------
void __golang sync_atomic_LoadUint64()
{
  _m_empty();
}

//----- (08049290) --------------------------------------------------------
void __golang sync_atomic_StoreUint32()
{
  volatile __int32 *v0; // [esp+4h] [ebp+4h]
  __int32 v1; // [esp+8h] [ebp+8h]

  _InterlockedExchange(v0, v1);
}

//----- (080492B0) --------------------------------------------------------
uintptr __golang type__hash_sync_atomic_Value(sync_atomic_Value_0 *p, uintptr h)
{
  uintptr v2; // [esp+Ch] [ebp-4h]

  v2 = runtime_memhash(p, h, 0);
  return runtime_nilinterhash(p, v2);
}

//----- (08049310) --------------------------------------------------------
bool __golang type__eq_sync_atomic_Value(sync_atomic_Value_0 *p, sync_atomic_Value_0 *q)
{
  return p->v._type == q->v._type && runtime_efaceeq(p->v._type, p->v.data, q->v.data);
}

//----- (08049370) --------------------------------------------------------
void __golang runtime_internal_sys_Ctz64()
{
  ;
}

//----- (080493A0) --------------------------------------------------------
uint32 __golang runtime_internal_atomic_Load(uint32 *ptr)
{
  return *ptr;
}

//----- (080493B0) --------------------------------------------------------
void *__golang runtime_internal_atomic_Loadp(void *ptr)
{
  return *(void **)ptr;
}

//----- (080493C0) --------------------------------------------------------
uint64 __golang runtime_internal_atomic_Xadd64(uint64 *ptr, int64 delta)
{
  char v2; // [esp+14h] [ebp-Ch]
  int v3; // [esp+18h] [ebp-8h]
  uint64 _r2_4; // [esp+34h] [ebp+14h]

  do
  {
    v3 = (*ptr + delta) >> 32;
    runtime_internal_atomic_Cas64();
  }
  while ( !v2 );
  LODWORD(_r2_4) = v3;
  return _r2_4;
}
// 80493FF: variable 'v2' is possibly undefined

//----- (08049420) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
uint64 __golang runtime_internal_atomic_Xchg64(uint64 *ptr, uint64 newa)
{
  char v2; // [esp+14h] [ebp-Ch]
  uint64 old_lo; // [esp+18h] [ebp-8h]

  do
  {
    old_lo = *ptr;
    runtime_internal_atomic_Cas64();
  }
  while ( !v2 );
  return old_lo;
}
// 8049420: variables would overlap: ^30.8 and ^30.12

//----- (08049480) --------------------------------------------------------
void __golang runtime_internal_atomic_Cas()
{
  volatile signed __int32 *v0; // [esp+4h] [ebp+4h]
  signed __int32 v1; // [esp+8h] [ebp+8h]
  signed __int32 v2; // [esp+Ch] [ebp+Ch]

  _InterlockedCompareExchange(v0, v2, v1);
}

//----- (08049510) --------------------------------------------------------
void __golang runtime_internal_atomic_Cas64()
{
  volatile signed __int64 *v0; // ebp
  volatile signed __int64 *v1; // [esp+4h] [ebp+4h]
  signed __int64 v2; // [esp+8h] [ebp+8h]
  signed __int64 v3; // [esp+10h] [ebp+10h]

  v0 = v1;
  if ( ((unsigned __int8)v1 & 7) != 0 )
    v0 = (volatile signed __int64 *)MEMORY[0];
  _InterlockedCompareExchange64(v0, v3, v2);
}

//----- (08049540) --------------------------------------------------------
void __golang runtime_internal_atomic_Casp1()
{
  volatile signed __int32 *v0; // [esp+4h] [ebp+4h]
  signed __int32 v1; // [esp+8h] [ebp+8h]
  signed __int32 v2; // [esp+Ch] [ebp+Ch]

  _InterlockedCompareExchange(v0, v2, v1);
}

//----- (08049560) --------------------------------------------------------
void __golang runtime_internal_atomic_Xadd()
{
  volatile signed __int32 *v0; // [esp+4h] [ebp+4h]
  unsigned int v1; // [esp+8h] [ebp+8h]

  _InterlockedExchangeAdd(v0, v1);
}

//----- (08049580) --------------------------------------------------------
void __golang runtime_internal_atomic_Xchg()
{
  volatile __int32 *v0; // [esp+4h] [ebp+4h]
  __int32 v1; // [esp+8h] [ebp+8h]

  _InterlockedExchange(v0, v1);
}

//----- (080495A0) --------------------------------------------------------
void __golang runtime_internal_atomic_StorepNoWB()
{
  volatile __int32 *v0; // [esp+4h] [ebp+4h]
  __int32 v1; // [esp+8h] [ebp+8h]

  _InterlockedExchange(v0, v1);
}

//----- (080495B0) --------------------------------------------------------
void __golang runtime_internal_atomic_Store()
{
  volatile __int32 *v0; // [esp+4h] [ebp+4h]
  __int32 v1; // [esp+8h] [ebp+8h]

  _InterlockedExchange(v0, v1);
}

//----- (080495C0) --------------------------------------------------------
void __golang runtime_internal_atomic_Load64()
{
  _m_empty();
}

//----- (080495E0) --------------------------------------------------------
void __golang runtime_internal_atomic_Store64()
{
  _QWORD *v0; // eax
  void *retaddr; // [esp+0h] [ebp+0h] BYREF
  _QWORD *v2; // [esp+4h] [ebp+4h]
  __int64 v3; // [esp+8h] [ebp+8h]

  v0 = v2;
  if ( ((unsigned __int8)v2 & 7) != 0 )
    v0 = (_QWORD *)MEMORY[0];
  *v0 = v3;
  _m_empty();
  _InterlockedExchangeAdd((volatile signed __int32 *)&retaddr, 0);
}

//----- (08049610) --------------------------------------------------------
void __golang runtime_internal_atomic_Or8()
{
  volatile signed __int8 *v0; // [esp+4h] [ebp+4h]
  unsigned __int8 v1; // [esp+8h] [ebp+8h]

  _InterlockedOr8(v0, v1);
}

//----- (08049620) --------------------------------------------------------
void __golang runtime_internal_atomic_And8()
{
  volatile signed __int8 *v0; // [esp+4h] [ebp+4h]
  unsigned __int8 v1; // [esp+8h] [ebp+8h]

  _InterlockedAnd8(v0, v1);
}

//----- (08049630) --------------------------------------------------------
uintptr __golang runtime_memhash0(void *p, uintptr h)
{
  return h;
}

//----- (08049660) --------------------------------------------------------
uintptr __golang runtime_memhash8(void *p, uintptr h)
{
  return runtime_memhash(p, h, 1u);
}

//----- (080496B0) --------------------------------------------------------
uintptr __golang runtime_memhash16(void *p, uintptr h)
{
  return runtime_memhash(p, h, 2u);
}

//----- (08049700) --------------------------------------------------------
uintptr __golang runtime_memhash32(void *p, uintptr h)
{
  return runtime_memhash(p, h, 4u);
}

//----- (08049750) --------------------------------------------------------
uintptr __golang runtime_memhash64(void *p, uintptr h)
{
  return runtime_memhash(p, h, 8u);
}

//----- (080497A0) --------------------------------------------------------
uintptr __golang runtime_memhash128(void *p, uintptr h)
{
  return runtime_memhash(p, h, 0x10u);
}

//----- (080497F0) --------------------------------------------------------
uintptr __golang runtime_strhash(void *a, uintptr h)
{
  return runtime_memhash(*(void **)a, h, *((_DWORD *)a + 1));
}

//----- (08049840) --------------------------------------------------------
uintptr __golang runtime_f32hash(void *p, uintptr h)
{
  if ( *(float *)p == 0.0 )
    return -1027967283 * (h ^ 0xAA7F8EA9);
  else
    return runtime_memhash(p, h, 4u);
}

//----- (08049900) --------------------------------------------------------
uintptr __golang runtime_f64hash(void *p, uintptr h)
{
  if ( *(double *)p == 0.0 )
    return -1027967283 * (h ^ 0xAA7F8EA9);
  else
    return runtime_memhash(p, h, 8u);
}

//----- (080499C0) --------------------------------------------------------
uintptr __golang runtime_c64hash(void *p, uintptr h)
{
  uintptr v2; // [esp+8h] [ebp-4h]

  v2 = runtime_f32hash(p, h);
  return runtime_f32hash((char *)p + 4, v2);
}

//----- (08049A20) --------------------------------------------------------
uintptr __golang runtime_c128hash(void *p, uintptr h)
{
  uintptr v2; // [esp+8h] [ebp-4h]

  v2 = runtime_f64hash(p, h);
  return runtime_f64hash((char *)p + 8, v2);
}

//----- (08049A80) --------------------------------------------------------
uintptr __golang runtime_interhash(void *p, uintptr h)
{
  runtime__type_0 *t; // ecx
  int (__golang **hash)(char *, uintptr); // edx
  string a[2]; // [esp+4h] [ebp-20h]
  runtime_eface_0 a_4; // [esp+8h] [ebp-1Ch]
  interface_{} a_4a; // [esp+8h] [ebp-1Ch]
  string elem; // [esp+1Ch] [ebp-8h] BYREF

  if ( !*(_DWORD *)p )
    return h;
  t = *(runtime__type_0 **)(*(_DWORD *)p + 4);
  hash = (int (__golang **)(char *, uintptr))t->alg->hash;
  if ( !hash )
  {
    a[0].str = (uint8 *)"hash of unhashable type ";
    a[0].len = 24;
    a[1] = runtime___ptr__type__string(t);
    elem = runtime_concatstring2(0, *(string (*)[2])&a[0].str);
    runtime_convT2Estring((runtime__type_0 *)&want, &elem, a_4);
    runtime_gopanic(a_4a);
    BUG();
  }
  if ( (t->kind & 0x20) != 0 )
    return -1027967283 * (*hash)((char *)p + 4, h ^ 0xAA7F8EA9);
  else
    return -1027967283 * (*hash)(*((char **)p + 1), h ^ 0xAA7F8EA9);
}
// 8049B6D: variable 'a_4' is possibly undefined
// 8049B81: variable 'a_4a' is possibly undefined

//----- (08049BA0) --------------------------------------------------------
uintptr __golang runtime_nilinterhash(void *p, uintptr h)
{
  runtime__type_0 *v2; // ecx
  int (__golang **hash)(char *, uintptr); // edx
  string a[2]; // [esp+4h] [ebp-20h]
  runtime_eface_0 a_4; // [esp+8h] [ebp-1Ch]
  interface_{} a_4a; // [esp+8h] [ebp-1Ch]
  string elem; // [esp+1Ch] [ebp-8h] BYREF

  v2 = *(runtime__type_0 **)p;
  if ( !*(_DWORD *)p )
    return h;
  hash = (int (__golang **)(char *, uintptr))v2->alg->hash;
  if ( !hash )
  {
    a[0].str = (uint8 *)"hash of unhashable type ";
    a[0].len = 24;
    a[1] = runtime___ptr__type__string((runtime__type_0 *)*(_DWORD *)p);
    elem = runtime_concatstring2(0, *(string (*)[2])&a[0].str);
    runtime_convT2Estring((runtime__type_0 *)&want, &elem, a_4);
    runtime_gopanic(a_4a);
    BUG();
  }
  if ( (v2->kind & 0x20) != 0 )
    return -1027967283 * (*hash)((char *)p + 4, h ^ 0xAA7F8EA9);
  else
    return -1027967283 * (*hash)(*((char **)p + 1), h ^ 0xAA7F8EA9);
}
// 8049C8A: variable 'a_4' is possibly undefined
// 8049C9E: variable 'a_4a' is possibly undefined

//----- (08049CB0) --------------------------------------------------------
bool __golang runtime_memequal0(void *p, void *q)
{
  return 1;
}

//----- (08049CD0) --------------------------------------------------------
bool __golang runtime_memequal8(void *p, void *q)
{
  return *(_BYTE *)p == *(_BYTE *)q;
}

//----- (08049D10) --------------------------------------------------------
bool __golang runtime_memequal16(void *p, void *q)
{
  return *(_WORD *)p == *(_WORD *)q;
}

//----- (08049D50) --------------------------------------------------------
bool __golang runtime_memequal32(void *p, void *q)
{
  return *(_DWORD *)p == *(_DWORD *)q;
}

//----- (08049D80) --------------------------------------------------------
bool __golang runtime_memequal64(void *p, void *q)
{
  return *(_DWORD *)p == *(_DWORD *)q && *((_DWORD *)p + 1) == *((_DWORD *)q + 1);
}

//----- (08049DC0) --------------------------------------------------------
bool __golang runtime_memequal128(void *p, void *q)
{
  return *(_DWORD *)p == *(_DWORD *)q
      && *((_DWORD *)p + 1) == *((_DWORD *)q + 1)
      && *((_DWORD *)q + 3) == *((_DWORD *)p + 3)
      && *((_DWORD *)q + 2) == *((_DWORD *)p + 2);
}

//----- (08049E20) --------------------------------------------------------
bool __golang runtime_f32equal(void *p, void *q)
{
  return *(float *)p == *(float *)q;
}

//----- (08049E60) --------------------------------------------------------
bool __golang runtime_f64equal(void *p, void *q)
{
  return *(double *)p == *(double *)q;
}

//----- (08049EA0) --------------------------------------------------------
bool __golang runtime_c64equal(void *p, void *q)
{
  return *((float *)p + 1) == *((float *)q + 1) && *(float *)p == *(float *)q;
}

//----- (08049EF0) --------------------------------------------------------
bool __golang runtime_c128equal(void *p, void *q)
{
  return *((double *)p + 1) == *((double *)q + 1) && *(double *)p == *(double *)q;
}

//----- (08049F50) --------------------------------------------------------
bool __golang runtime_strequal(void *p, void *q)
{
  bool v3; // [esp+10h] [ebp-4h]

  if ( *((_DWORD *)p + 1) != *((_DWORD *)q + 1) )
    return 0;
  runtime_eqstring();
  return v3;
}
// 8049F99: variable 'v3' is possibly undefined

//----- (08049FB0) --------------------------------------------------------
bool __golang runtime_interequal(void *p, void *q)
{
  return *(_DWORD *)p == *(_DWORD *)q && runtime_ifaceeq(*(runtime_itab_0 **)p, *((void **)p + 1), *((void **)q + 1));
}

//----- (0804A010) --------------------------------------------------------
bool __golang runtime_nilinterequal(void *p, void *q)
{
  return *(_DWORD *)p == *(_DWORD *)q && runtime_efaceeq(*(runtime__type_0 **)p, *((void **)p + 1), *((void **)q + 1));
}

//----- (0804A070) --------------------------------------------------------
bool __golang runtime_efaceeq(runtime__type_0 *t, void *x, void *y)
{
  void (*equal)(void *, void *, bool *); // edx
  __int32 len; // eax
  uint8 *str; // ecx
  string a[2]; // [esp+4h] [ebp-20h]
  runtime_eface_0 a_4; // [esp+8h] [ebp-1Ch]
  interface_{} a_4a; // [esp+8h] [ebp-1Ch]
  string elem; // [esp+1Ch] [ebp-8h] BYREF

  if ( !t )
    return 1;
  equal = t->alg->equal;
  if ( !equal )
  {
    a[0] = runtime___ptr__type__string(t);
    len = a[0].len;
    str = a[0].str;
    a[0].str = (uint8 *)"comparing uncomparable type ";
    a[0].len = 28;
    a[1] = (string)__PAIR64__(len, (unsigned int)str);
    elem = runtime_concatstring2(0, *(string (*)[2])&a[0].str);
    runtime_convT2Estring((runtime__type_0 *)&want, &elem, a_4);
    runtime_gopanic(a_4a);
    BUG();
  }
  if ( (t->kind & 0x20) != 0 )
    return (*(int (__golang **)(void **, void **))equal)(&x, &y);
  else
    return (*(int (__golang **)(void *, void *))equal)(x, y);
}
// 804A144: variable 'a_4' is possibly undefined
// 804A158: variable 'a_4a' is possibly undefined

//----- (0804A170) --------------------------------------------------------
bool __golang runtime_ifaceeq(runtime_itab_0 *tab, void *x, void *y)
{
  runtime__type_0 *t; // eax
  int (__golang **equal)(void **, void **); // edx
  __int32 len; // eax
  uint8 *str; // ecx
  string a[2]; // [esp+4h] [ebp-20h]
  runtime_eface_0 a_4; // [esp+8h] [ebp-1Ch]
  interface_{} a_4a; // [esp+8h] [ebp-1Ch]
  string elem; // [esp+1Ch] [ebp-8h] BYREF

  if ( !tab )
    return 1;
  t = tab->_type;
  equal = (int (__golang **)(void **, void **))t->alg->equal;
  if ( !equal )
  {
    a[0] = runtime___ptr__type__string(t);
    len = a[0].len;
    str = a[0].str;
    a[0].str = (uint8 *)"comparing uncomparable type ";
    a[0].len = 28;
    a[1] = (string)__PAIR64__(len, (unsigned int)str);
    elem = runtime_concatstring2(0, *(string (*)[2])&a[0].str);
    runtime_convT2Estring((runtime__type_0 *)&want, &elem, a_4);
    runtime_gopanic(a_4a);
    BUG();
  }
  if ( (t->kind & 0x20) != 0 )
    return (*equal)(&x, &y);
  else
    return (*equal)((void **)x, (void **)y);
}
// 804A247: variable 'a_4' is possibly undefined
// 804A25B: variable 'a_4a' is possibly undefined

//----- (0804A270) --------------------------------------------------------
void __golang runtime_alginit()
{
  __uint8 r; // [esp+0h] [ebp-Ch]
  __uint8 ra; // [esp+0h] [ebp-Ch]

  if ( runtime_support_aes && runtime_support_ssse3 && runtime_support_sse41 )
  {
    runtime_useAeshash = 1;
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
    {
      runtime_writebarrierptr((uintptr *)&runtime_algarray[4], (uintptr)&src);
      runtime_writebarrierptr((uintptr *)&runtime_algarray[5], (uintptr)&off_80E7B84);
      runtime_writebarrierptr((uintptr *)&runtime_algarray[7], (uintptr)&off_80E7B88);
    }
    else
    {
      runtime_algarray[4].hash = (void (*)(void *, uintptr, uintptr *))&src;
      runtime_algarray[5].hash = (void (*)(void *, uintptr, uintptr *))&off_80E7B84;
      runtime_algarray[7].hash = (void (*)(void *, uintptr, uintptr *))&off_80E7B88;
    }
    r.array = (uint8 *)&runtime_aeskeysched;
    *(_QWORD *)&r.len = 0x4000000040LL;
    runtime_getRandomData(r);
  }
  else
  {
    ra.array = (uint8 *)&runtime_hashkey;
    *(_QWORD *)&ra.len = 0x1000000010LL;
    runtime_getRandomData(ra);
    runtime_hashkey.array = (uint8 *)((int)runtime_hashkey.array | 1);
    runtime_hashkey.len |= 1u;
    runtime_hashkey.cap |= 1u;
    unk_81576EC |= 1u;
  }
}

//----- (0804A3C0) --------------------------------------------------------
void __golang runtime_atomicstorep(void *ptr, void *newa)
{
  runtime_writebarrierptr_prewrite((uintptr *)ptr, (uintptr)newa);
  runtime_internal_atomic_StorepNoWB();
}

//----- (0804A400) --------------------------------------------------------
bool __golang runtime_casp(void **ptr, void *old, void *newa)
{
  bool v3; // [esp+Ch] [ebp-4h]

  runtime_writebarrierptr_prewrite((uintptr *)ptr, (uintptr)newa);
  runtime_internal_atomic_Casp1();
  return v3;
}
// 804A43A: variable 'v3' is possibly undefined

//----- (0804A450) --------------------------------------------------------
void __golang sync_atomic_StorePointer(void **ptr, void *newa)
{
  runtime_writebarrierptr_prewrite((uintptr *)ptr, (uintptr)newa);
  sync_atomic_StoreUintptr();
}

//----- (0804A490) --------------------------------------------------------
bool __golang sync_atomic_CompareAndSwapPointer(void **ptr, void *old, void *newa)
{
  bool v3; // [esp+Ch] [ebp-4h]

  runtime_writebarrierptr_prewrite((uintptr *)ptr, (uintptr)newa);
  sync_atomic_CompareAndSwapUintptr();
  return v3;
}
// 804A4CA: variable 'v3' is possibly undefined

//----- (0804A4E0) --------------------------------------------------------
int32 __golang runtime_cgocall(void *fn, void *arg)
{
  unsigned int v2; // ecx
  uintptr v3; // ecx
  int v4; // edx
  uintptr src; // ebp
  int ncgocall; // ecx
  int ncgocall_high; // edx
  string dummy; // [esp+0h] [ebp-18h]
  string dummya; // [esp+0h] [ebp-18h]
  int32 v10; // [esp+8h] [ebp-10h]
  runtime_m *mp; // [esp+10h] [ebp-8h]
  runtime_g *_g_; // [esp+14h] [ebp-4h]

  if ( !runtime_iscgo )
  {
    dummya.str = (uint8 *)"cgocall unavailable";
    dummya.len = 19;
    runtime_throw(dummya);
    BUG();
  }
  if ( !fn )
  {
    dummy.str = (uint8 *)"cgocall nil";
    dummy.len = 11;
    runtime_throw(dummy);
    BUG();
  }
  v2 = __readgsdword(0);
  *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(v2 - 4) + 24) + 452) += 2;
  v3 = *(_DWORD *)(__readgsdword(0) - 4);
  v4 = *(_DWORD *)(v3 + 24);
  if ( *(_DWORD *)&runtime_writeBarrier.enabled )
  {
    _g_ = (runtime_g *)v3;
    runtime_writebarrierptr((uintptr *)(v4 + 188), v3);
    v3 = (uintptr)_g_;
  }
  else
  {
    *(_DWORD *)(v4 + 188) = v3;
  }
  src = *(_DWORD *)(v3 + 24);
  if ( *(_DWORD *)&runtime_writeBarrier.enabled )
    runtime_writebarrierptr((uintptr *)(v3 + 136), src);
  else
    *(_DWORD *)(v3 + 136) = src;
  mp = *(runtime_m **)(*(_DWORD *)(__readgsdword(0) - 4) + 24);
  ncgocall = mp->ncgocall;
  ncgocall_high = HIDWORD(mp->ncgocall);
  LODWORD(mp->ncgocall) = ncgocall + 1;
  HIDWORD(mp->ncgocall) = __CFADD__(ncgocall, 1) + ncgocall_high;
  ++mp->ncgo;
  mp->incgo = 1;
  (*mp->cgoCallers)[0] = 0;
  runtime_entersyscall(0);
  runtime_asmcgocall();
  runtime_exitsyscall(0);
  runtime_endcgo(mp);
  return v10;
}
// 804A5FC: variable 'v10' is possibly undefined

//----- (0804A670) --------------------------------------------------------
void __golang runtime_endcgo(runtime_m *mp)
{
  mp->incgo = 0;
  --mp->ncgo;
  runtime_unlockOSThread();
}

//----- (0804A690) --------------------------------------------------------
void __golang runtime_cgocallbackg(uintptr ctxt)
{
  int v1; // eax
  string dummy; // [esp+0h] [ebp-2Ch]
  uintptr savedpc; // [esp+8h] [ebp-24h]
  void *savedsp; // [esp+24h] [ebp-8h]
  runtime_g *gp; // [esp+28h] [ebp-4h]

  gp = *(runtime_g **)(__readgsdword(0) - 4);
  if ( gp != gp->m->curg )
  {
    runtime_printlock();
    dummy.str = (uint8 *)"runtime: bad g in cgocallback";
    dummy.len = 29;
    runtime_printstring(dummy);
    runtime_printnl();
    runtime_printunlock();
    runtime_exit();
  }
  v1 = ((int (*)(void))loc_8090264)();
  savedsp = *(void **)(v1 + 56);
  savedpc = *(_DWORD *)(v1 + 60);
  runtime_exitsyscall(0);
  gp->m->incgo = 0;
  runtime_cgocallbackg1(ctxt);
  gp->m->incgo = 1;
  runtime_reentersyscall(savedpc, (uintptr)savedsp);
  ((void (*)(void))loc_8090264)();
}

//----- (0804A780) --------------------------------------------------------
void __golang runtime_cgocallbackg1(uintptr ctxt)
{
  runtime_g *v1; // eax
  uintptr v2; // eax
  runtime_g *v3; // ecx
  __int32 len; // edx
  __int32 v5; // ebx
  _DWORD *array; // ebp
  __int32 cap; // esi
  int v8; // eax
  int v9; // eax
  void *ptr; // [esp+0h] [ebp-38h]
  runtime_slice_0 newa; // [esp+4h] [ebp-34h]
  runtime_slice_0 v12; // [esp+14h] [ebp-24h]
  __int32 v13; // [esp+2Ch] [ebp-Ch]
  runtime_g *gp; // [esp+30h] [ebp-8h]

  v1 = *(runtime_g **)(__readgsdword(0) - 4);
  gp = v1;
  if ( v1->m->needextram )
    goto LABEL_2;
  if ( runtime_internal_atomic_Load(&runtime_extraMWaiters) )
  {
    v1 = gp;
LABEL_2:
    v1->m->needextram = 0;
    runtime_systemstack();
  }
  v2 = ctxt;
  if ( ctxt )
  {
    v3 = gp;
    len = gp->cgoCtxt.len;
    v5 = len + 1;
    array = gp->cgoCtxt.array;
    cap = gp->cgoCtxt.cap;
    if ( len + 1 > cap )
    {
      v13 = gp->cgoCtxt.len;
      newa.array = gp->cgoCtxt.array;
      *(_QWORD *)&newa.len = __PAIR64__(cap, len);
      v12 = runtime_growslice((runtime__type_0 *)&et, newa, len + 1);
      array = v12.array;
      cap = v12.cap;
      v5 = v12.len + 1;
      v2 = ctxt;
      v3 = gp;
      len = v13;
    }
    array[len] = v2;
    if ( !v5 )
      runtime_panicindex();
    runtime_atomicstorep(&v3->cgoCtxt, array);
    gp->cgoCtxt.cap = cap;
    gp->cgoCtxt.len = v5;
    runtime_deferproc(4, (runtime_funcval *)&fn);
    if ( v8 )
      goto LABEL_12;
  }
  if ( !gp->m->ncgo )
    runtime_chanrecv1((runtime_hchan *)runtime_main_init_done, 0);
  runtime_deferproc(4, (runtime_funcval *)&stru_80E7D00);
  if ( v9 )
  {
LABEL_12:
    runtime_deferreturn((uintptr)ptr);
  }
  else
  {
    runtime_reflectcall();
    runtime_deferreturn(0);
  }
}
// 804A863: variable 'v8' is possibly undefined
// 804A89F: variable 'v9' is possibly undefined
// 804A8E8: variable 'ptr' is possibly undefined

//----- (0804A9A0) --------------------------------------------------------
void __golang runtime_unwindm(bool *restore)
{
  int v1; // eax
  runtime_m *v2; // ecx
  int v3; // eax
  int32 locks; // edx
  runtime_m *mp; // [esp+4h] [ebp-4h]

  if ( *restore )
  {
    v1 = *(_DWORD *)(__readgsdword(0) - 4);
    ++*(_DWORD *)(*(_DWORD *)(v1 + 24) + 120);
    v2 = *(runtime_m **)(v1 + 24);
    v2->g0->sched.sp = *(_DWORD *)v2->g0->sched.sp;
    if ( v2->ncgo > 0 )
    {
      mp = v2;
      runtime_endcgo(v2);
      v2 = mp;
    }
    v3 = *(_DWORD *)(__readgsdword(0) - 4);
    locks = v2->locks;
    v2->locks = locks - 1;
    if ( locks == 1 )
    {
      if ( *(_BYTE *)(v3 + 108) )
        *(_DWORD *)(v3 + 8) = -1314;
    }
  }
}

//----- (0804AA50) --------------------------------------------------------
bool __golang runtime_cgoIsGoPointer(void *p)
{
  int *v1; // ecx
  void *v2; // edx
  int i; // ebx
  int v4; // ebp
  unsigned int v6; // esi
  unsigned int v7; // ebp
  unsigned int v9; // ecx
  int v10; // ecx
  unsigned __int64 v11; // [esp+0h] [ebp-Ch]

  if ( !p )
    return 0;
  if ( (unsigned int)p < dword_81493A8 || (unsigned int)p >= dword_81493AC )
    goto LABEL_3;
  v9 = ((unsigned int)p - dword_81493A8) >> 13;
  if ( v9 >= dword_814910C )
    runtime_panicindex();
  v10 = *(_DWORD *)(dword_8149108 + 4 * v9);
  if ( v10 )
  {
    if ( (unsigned int)p >= *(_DWORD *)(v10 + 12)
      && (unsigned __int8)(*(_BYTE *)(v10 + 60) - 1) <= 1u
      && (unsigned int)p < *(_DWORD *)(v10 + 80) )
    {
      return 1;
    }
  }
LABEL_3:
  v11 = COERCE_UNSIGNED_INT64(COERCE_LONG_DOUBLE(COERCE_LONG_DOUBLE(runtime_activeModules())));
  v1 = (int *)v11;
  v2 = p;
  for ( i = 0; i < SHIDWORD(v11); ++i )
  {
    v4 = *v1;
    if ( *(_DWORD *)(*v1 + 64) <= (unsigned int)v2 && (unsigned int)v2 < *(_DWORD *)(*v1 + 68) )
      return 1;
    v6 = *(_DWORD *)(v4 + 72);
    v7 = *(_DWORD *)(v4 + 76);
    if ( v6 <= (unsigned int)v2 && (unsigned int)v2 < v7 )
      return 1;
    ++v1;
    v2 = p;
  }
  return 0;
}
// 804AA63: conditional instruction was optimized away because %p.4!=0
// 8149108: using guessed type int dword_8149108;
// 814910C: using guessed type int dword_814910C;
// 81493A8: using guessed type int dword_81493A8;
// 81493AC: using guessed type int dword_81493AC;

//----- (0804AB50) --------------------------------------------------------
void __golang runtime_cgoCheckWriteBarrier(uintptr *dst, uintptr src)
{
  int v2; // eax
  _DWORD *v3; // ecx

  if ( runtime_cgoIsGoPointer((void *)src) && !runtime_cgoIsGoPointer(dst) )
  {
    v2 = *(_DWORD *)(__readgsdword(0) - 4);
    v3 = *(_DWORD **)(v2 + 24);
    if ( *v3 != v2 && v3[11] != v2 && !v3[26] )
      runtime_systemstack();
  }
}

//----- (0804ABE0) --------------------------------------------------------
void __golang runtime_cgoCheckMemmove(runtime__type_0 *typ, void *dst, void *src, uintptr off, uintptr size)
{
  if ( (typ->kind & 0x80u) == 0 && runtime_cgoIsGoPointer(src) && !runtime_cgoIsGoPointer(dst) )
    runtime_cgoCheckTypedBlock(typ, src, off, size);
}

//----- (0804AC50) --------------------------------------------------------
void __golang runtime_cgoCheckSliceCopy(runtime__type_0 *typ, runtime_slice_0 dst, runtime_slice_0 src, __int32 n)
{
  __int32 v4; // eax
  char *array; // ecx
  __int32 i; // [esp+10h] [ebp-8h]
  char *p; // [esp+14h] [ebp-4h]

  if ( (typ->kind & 0x80u) == 0 && runtime_cgoIsGoPointer(src.array) && !runtime_cgoIsGoPointer(dst.array) )
  {
    v4 = 0;
    array = (char *)src.array;
    while ( v4 < n )
    {
      i = v4;
      p = array;
      runtime_cgoCheckTypedBlock(typ, array, 0, typ->size);
      v4 = i + 1;
      array = &p[typ->size];
    }
  }
}
// 804AC50: could not find valid save-restore pair for ebx

//----- (0804ACF0) --------------------------------------------------------
void __golang runtime_cgoCheckTypedBlock(runtime__type_0 *typ, void *src, uintptr off, uintptr size)
{
  uintptr ptrdata; // ecx
  uintptr v5; // ecx
  int *v6; // eax
  _BYTE *v7; // edx
  int v8; // ebx
  int v9; // ebp
  _BYTE *v10; // esi
  int v11; // edi
  _BYTE *v13; // ebx
  bool v14; // si
  unsigned int v15; // ebp
  unsigned int v16; // ebx
  uint8 *v17; // edx
  int v18; // ebp
  uintptr i; // ecx
  unsigned int v20; // ecx
  uintptr v21; // eax
  unsigned __int64 p; // [esp+0h] [ebp-30h]
  uintptr x; // [esp+10h] [ebp-20h]
  uint8 *_r0_bitp; // [esp+18h] [ebp-18h]
  uintptr sizea; // [esp+40h] [ebp+10h]

  ptrdata = typ->ptrdata;
  if ( ptrdata > off )
  {
    v5 = ptrdata - off;
    if ( size <= v5 )
      v5 = size;
    if ( (typ->kind & 0x40) != 0 )
    {
      sizea = v5;
      p = COERCE_UNSIGNED_INT64(COERCE_LONG_DOUBLE(COERCE_LONG_DOUBLE(runtime_activeModules())));
      v6 = (int *)p;
      v7 = src;
      v8 = 0;
      while ( v8 < SHIDWORD(p) )
      {
        v9 = *v6;
        v10 = *(_BYTE **)(*v6 + 64);
        v11 = v8;
        if ( v10 <= v7 && (unsigned int)v7 < *(_DWORD *)(*v6 + 68) )
        {
          runtime_cgoCheckBits(v10, *(uint8 **)(v9 + 200), (uintptr)&v7[off - *(_DWORD *)(*v6 + 64)], sizea);
          return;
        }
        v13 = *(_BYTE **)(v9 + 72);
        if ( v13 > v7 )
        {
          v14 = 0;
        }
        else
        {
          v13 = *(_BYTE **)(v9 + 72);
          v14 = (unsigned int)v7 < *(_DWORD *)(v9 + 76);
        }
        if ( v14 )
        {
          runtime_cgoCheckBits(v13, *(uint8 **)(v9 + 208), v7 - v13 + off, sizea);
          return;
        }
        ++v6;
        v8 = v11 + 1;
        v7 = src;
      }
      v15 = (unsigned int)&v7[-dword_81493A8];
      v16 = (unsigned int)&v7[-dword_81493A8] >> 13;
      if ( v16 >= dword_814910C )
        runtime_panicindex();
      if ( *(_BYTE *)(*(_DWORD *)(dword_8149108 + 4 * v16) + 60) == 2 )
      {
        ((void (*)(void))loc_808FD8B)();
        runtime_systemstack();
      }
      else
      {
        v17 = (uint8 *)(dword_81493A0 - (v15 >> 4) - 1);
        v18 = (v15 >> 2) & 3;
        for ( i = 0; i < sizea + off; i = v21 + 4 )
        {
          x = i;
          v20 = v18;
          v21 = x;
          if ( x >= off && ((*v17 >> v18) & 1) != 0 )
          {
            _r0_bitp = v17;
            if ( runtime_cgoIsGoPointer(*(void **)((char *)src + x)) )
              runtime_systemstack();
            v21 = x;
            v20 = v18;
            v17 = _r0_bitp;
          }
          if ( v20 >= 3 )
          {
            --v17;
            v18 = 0;
          }
          else
          {
            v18 = v20 + 1;
          }
        }
      }
    }
    else
    {
      runtime_cgoCheckBits(src, typ->gcdata, off, v5);
    }
  }
}
// 8149108: using guessed type int dword_8149108;
// 814910C: using guessed type int dword_814910C;
// 81493A0: using guessed type int dword_81493A0;
// 81493A8: using guessed type int dword_81493A8;

//----- (0804AF50) --------------------------------------------------------
void __golang runtime_cgoCheckBits(void *src, uint8 *gcbits, uintptr off, uintptr size)
{
  uintptr v4; // eax
  uintptr v5; // ecx
  uintptr v6; // ebx
  uint8 *v7; // edx
  char *v8; // eax
  uintptr v9; // ebp
  unsigned int v10; // esi
  uint8 *ptrmask; // [esp+14h] [ebp-8h]
  char *p; // [esp+18h] [ebp-4h]
  uintptr sizea; // [esp+2Ch] [ebp+10h]

  v4 = 32 * (off >> 5);
  v5 = off - v4;
  v6 = off - v4 + size;
  sizea = v6;
  v7 = &gcbits[off >> 5];
  v8 = (char *)src + v4;
  p = v8;
  v9 = 0;
  v10 = 0;
  while ( v9 < v6 )
  {
    if ( (v9 & 0x1F) != 0 )
      v10 >>= 1;
    else
      v10 = *v7++;
    if ( v5 )
    {
      v5 -= 4;
    }
    else if ( (v10 & 1) != 0 )
    {
      ptrmask = v7;
      if ( runtime_cgoIsGoPointer(*(void **)&v8[v9]) )
        runtime_systemstack();
      v8 = p;
      v5 = 0;
      v7 = ptrmask;
      v6 = sizea;
    }
    v9 += 4;
  }
}

//----- (0804B000) --------------------------------------------------------
void __golang runtime_cgoCheckUsingType(runtime__type_0 *typ, void *src, uintptr off, uintptr size)
{
  runtime__type_0 *v4; // eax
  signed __int8 kind; // cl
  uintptr ptrdata; // edx
  uintptr v7; // ebx
  uintptr v8; // edx
  char v9; // cl
  uint32 v10; // ecx
  char *v11; // ebp
  runtime__type_0 *v12; // esi
  uintptr v13; // esi
  uintptr v14; // edi
  uintptr v15; // ecx
  signed __int32 hash; // eax
  signed __int32 v17; // ebp
  char *v18; // esi
  runtime__type_0 *v19; // edi
  uintptr v20; // eax
  uintptr v21; // edi
  uintptr v22; // edi
  string s; // [esp+0h] [ebp-34h]
  uintptr i; // [esp+18h] [ebp-1Ch]
  signed __int32 v25; // [esp+20h] [ebp-14h]
  uintptr v26; // [esp+30h] [ebp-4h]
  uintptr sizea; // [esp+44h] [ebp+10h]
  uintptr sizeb; // [esp+44h] [ebp+10h]

  v4 = typ;
  kind = typ->kind;
  if ( kind >= 0 )
  {
    ptrdata = typ->ptrdata;
    v7 = off;
    if ( ptrdata > off )
    {
      v8 = ptrdata - off;
      if ( size <= v8 )
        v8 = size;
      if ( (kind & 0x40) != 0 )
      {
        v9 = kind & 0x1F;
        if ( v9 == 17 )
        {
          v10 = 0;
          v11 = (char *)src;
          while ( v10 < v4[1].hash )
          {
            v12 = (runtime__type_0 *)v4[1].size;
            if ( v7 < v12->size )
            {
              i = v10;
              sizea = v8;
              runtime_cgoCheckUsingType(v12, v11, v7, v8);
              v4 = typ;
              v10 = i;
              v8 = sizea;
            }
            v13 = *(_DWORD *)v4[1].size;
            v11 += v13;
            if ( v7 <= v13 )
              v13 = v7;
            v14 = *(_DWORD *)v4[1].size - v13;
            v7 -= v13;
            if ( v8 <= v14 )
              break;
            ++v10;
            v8 -= v14;
          }
        }
        else
        {
          if ( v9 != 25 )
          {
            s.str = (uint8 *)"can't happen";
            s.len = 12;
            runtime_throw(s);
            BUG();
          }
          v15 = typ[1].ptrdata;
          hash = typ[1].hash;
          v25 = hash;
          v17 = 0;
          v18 = (char *)src;
          while ( v17 < hash )
          {
            v19 = *(runtime__type_0 **)(v15 + 4);
            if ( v7 < v19->size )
            {
              sizeb = v8;
              v26 = v15;
              runtime_cgoCheckUsingType(v19, v18, v7, v8);
              v15 = v26;
              v8 = sizeb;
            }
            v20 = v19->size;
            v18 += v19->size;
            if ( v7 <= v19->size )
            {
              v21 = v19->size;
              v20 = v7;
            }
            else
            {
              v21 = v19->size;
            }
            v22 = v21 - v20;
            v7 -= v20;
            if ( v8 <= v22 )
              break;
            v15 += 12;
            ++v17;
            v8 -= v22;
            hash = v25;
          }
        }
      }
      else
      {
        runtime_cgoCheckBits(src, typ->gcdata, off, v8);
      }
    }
  }
}

//----- (0804B1C0) --------------------------------------------------------
runtime_hchan *__golang runtime_makechan(runtime_chantype_0 *t, int64 size)
{
  runtime__type_0 *v2; // ecx
  uintptr v3; // edx
  bool v4; // bp
  uintptr v5; // edi
  runtime_hchan *v6; // eax
  uint v7; // ecx
  runtime__type_0 *v8; // edx
  interface_{} v9; // [esp+0h] [ebp-20h]
  string v10; // [esp+0h] [ebp-20h]
  string v11; // [esp+0h] [ebp-20h]
  void *needzero; // [esp+8h] [ebp-18h]
  uintptr *src; // [esp+Ch] [ebp-14h]
  runtime__type_0 *elem; // [esp+18h] [ebp-8h]
  runtime_hchan *ca; // [esp+1Ch] [ebp-4h]
  runtime_hchan *c; // [esp+1Ch] [ebp-4h]

  v2 = t->elem;
  v3 = v2->size;
  if ( v2->size >= 0x10000 )
  {
    v11.str = (uint8 *)"makechan: invalid channel element type";
    v11.len = 38;
    runtime_throw(v11);
    BUG();
  }
  if ( v2->align > 8u )
  {
    v10.str = (uint8 *)"makechan: bad alignment";
    v10.len = 23;
    runtime_throw(v10);
    BUG();
  }
  if ( size < 0 || HIDWORD(size) )
    goto LABEL_27;
  if ( !v3 )
  {
    v4 = HIDWORD(size) == 0;
    v5 = 0;
    goto LABEL_7;
  }
  v4 = HIDWORD(size) == 0;
  v5 = v2->size;
  if ( (unsigned int)size > 0xFFFFFFC7 / v3 )
  {
LABEL_27:
    v9._type = (runtime__type_0 *)&e;
    v9.data = &runtime_statictmp_0;
    runtime_gopanic(v9);
    BUG();
  }
LABEL_7:
  elem = t->elem;
  if ( (v2->kind & 0x80u) != 0 || v4 && (_DWORD)size == 0 )
  {
    src = (uintptr *)runtime_mallocgc(size * v5 + 56, 0, 1);
    v6 = (runtime_hchan *)src;
    v7 = size;
    if ( (_DWORD)size != 0 && v4 )
    {
      v8 = elem;
      if ( elem->size )
      {
        if ( *(_DWORD *)&runtime_writeBarrier.enabled )
        {
          runtime_writebarrierptr(src + 2, (uintptr)(src + 14));
          v6 = (runtime_hchan *)src;
          v7 = size;
          v8 = elem;
        }
        else
        {
          src[2] = (uintptr)(src + 14);
        }
        goto LABEL_12;
      }
    }
    else
    {
      v8 = elem;
    }
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
    {
      runtime_writebarrierptr(src + 2, (uintptr)src);
      v6 = (runtime_hchan *)src;
      v7 = size;
      v8 = elem;
    }
    else
    {
      src[2] = (uintptr)src;
    }
    goto LABEL_12;
  }
  c = (runtime_hchan *)runtime_newobject((runtime__type_0 *)&typ);
  needzero = runtime_newarray(elem, size);
  v6 = c;
  if ( *(_DWORD *)&runtime_writeBarrier.enabled )
  {
    runtime_writebarrierptr((uintptr *)&c->buf, (uintptr)needzero);
    v6 = c;
  }
  else
  {
    c->buf = needzero;
  }
  v7 = size;
  v8 = elem;
LABEL_12:
  v6->elemsize = v8->size;
  if ( *(_DWORD *)&runtime_writeBarrier.enabled )
  {
    ca = v6;
    runtime_writebarrierptr((uintptr *)&v6->elemtype, (uintptr)v8);
    v6 = ca;
    v7 = size;
  }
  else
  {
    v6->elemtype = v8;
  }
  v6->dataqsiz = v7;
  return v6;
}

//----- (0804B430) --------------------------------------------------------
void __golang runtime_chansend1(runtime_hchan *c, void *elem)
{
  uintptr callerpc; // [esp+4h] [ebp-10h]

  runtime_getcallerpc();
  runtime_chansend(c, elem, 1, callerpc);
}
// 804B45B: variable 'callerpc' is possibly undefined

//----- (0804B470) --------------------------------------------------------
bool __golang runtime_chansend(runtime_hchan *c, void *ep, bool block, uintptr callerpc)
{
  runtime_hchan *v4; // eax
  uint dataqsiz; // edx
  bool v6; // zf
  runtime_mutex_0 *v7; // edx
  unsigned int v8; // ebx
  runtime_sudog *v9; // eax
  runtime_g *v10; // edx
  runtime_hchan *v11; // ebp
  uintptr last; // ecx
  runtime_g *v13; // eax
  runtime_sudog *v14; // edx
  unsigned int releasetime; // eax
  signed int releasetime_high; // ecx
  uint v17; // ecx
  runtime_mutex_0 *l; // [esp+0h] [ebp-4Ch]
  interface_{} la; // [esp+0h] [ebp-4Ch]
  string lb; // [esp+0h] [ebp-4Ch]
  string lc; // [esp+0h] [ebp-4Ch]
  interface_{} ld; // [esp+0h] [ebp-4Ch]
  string le; // [esp+0h] [ebp-4Ch]
  unsigned int reason; // [esp+4h] [ebp-48h]
  runtime_sudog *reasona; // [esp+4h] [ebp-48h]
  string reasonb; // [esp+4h] [ebp-48h]
  string reason_4; // [esp+8h] [ebp-44h]
  unsigned __int64 t0_lo; // [esp+18h] [ebp-34h]
  uintptr *sgp; // [esp+20h] [ebp-2Ch]
  runtime_g *gp; // [esp+24h] [ebp-28h]
  uintptr *v31; // [esp+28h] [ebp-24h]
  uintptr *p_last; // [esp+2Ch] [ebp-20h]
  uintptr *p_next; // [esp+2Ch] [ebp-20h]
  uintptr *p_param; // [esp+30h] [ebp-1Ch]
  uintptr *p_waiting; // [esp+34h] [ebp-18h]
  uintptr *p_waitlink; // [esp+34h] [ebp-18h]
  uintptr *dst; // [esp+38h] [ebp-14h]
  uintptr *p_selectdone; // [esp+3Ch] [ebp-10h]
  runtime_mutex_0 *lock; // [esp+40h] [ebp-Ch]
  int v40[2]; // [esp+44h] [ebp-8h] BYREF

  v4 = c;
  if ( c )
  {
    if ( !block && !c->closed )
    {
      dataqsiz = c->dataqsiz;
      v6 = dataqsiz == 0;
      if ( !dataqsiz )
      {
        if ( !c->recvq.first )
          return 0;
        v6 = 1;
      }
      if ( !v6 && c->qcount == dataqsiz )
        return 0;
    }
    if ( HIDWORD(runtime_blockprofilerate) != 0
      || HIDWORD(runtime_blockprofilerate) == 0 && (_DWORD)runtime_blockprofilerate != 0 )
    {
      runtime_cputicks();
      v7 = l;
      v8 = reason;
      v4 = c;
    }
    else
    {
      v7 = 0;
      v8 = 0;
    }
    t0_lo = __PAIR64__(v8, (unsigned int)v7);
    lock = &v4->lock;
    runtime_lock(&v4->lock);
    if ( c->closed )
    {
      runtime_unlock(lock);
      ld._type = (runtime__type_0 *)&e;
      ld.data = &runtime_statictmp_1;
      runtime_gopanic(ld);
      BUG();
    }
    reasona = runtime___ptr_waitq__dequeue(&c->recvq);
    if ( reasona )
    {
      v40[0] = (int)runtime_chansend_func1;
      v40[1] = (int)c;
      runtime_send(c, reasona, ep, (func())v40, 3);
      return 1;
    }
    else if ( c->qcount < c->dataqsiz )
    {
      runtime_typedmemmove(c->elemtype, (char *)c->buf + c->elemsize * c->sendx, ep);
      v17 = c->sendx + 1;
      c->sendx = v17;
      if ( v17 == c->dataqsiz )
        c->sendx = 0;
      ++c->qcount;
      runtime_unlock(lock);
      return 1;
    }
    else if ( block )
    {
      gp = *(runtime_g **)(__readgsdword(0) - 4);
      v9 = runtime_acquireSudog();
      v9->releasetime = 0LL;
      if ( (_DWORD)t0_lo != 0 || v8 != 0 )
      {
        LODWORD(v9->releasetime) = -1;
        HIDWORD(v9->releasetime) = -1;
      }
      sgp = (uintptr *)v9;
      p_selectdone = (uintptr *)&v9->selectdone;
      dst = (uintptr *)&v9->c;
      if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      {
        p_waitlink = (uintptr *)&v9->waitlink;
        runtime_writebarrierptr((uintptr *)&v9->elem, (uintptr)ep);
        runtime_writebarrierptr(p_waitlink, 0);
        runtime_writebarrierptr(sgp, (uintptr)gp);
        runtime_writebarrierptr(p_selectdone, 0);
        runtime_writebarrierptr(dst, (uintptr)c);
        v9 = (runtime_sudog *)sgp;
        v10 = gp;
        v11 = c;
      }
      else
      {
        v9->elem = ep;
        v9->waitlink = 0;
        v10 = gp;
        v9->g = gp;
        v9->selectdone = 0;
        v11 = c;
        v9->c = c;
      }
      p_waiting = (uintptr *)&v10->waiting;
      p_param = (uintptr *)&v10->param;
      if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      {
        p_next = (uintptr *)&v9->next;
        runtime_writebarrierptr((uintptr *)&v10->waiting, (uintptr)v9);
        runtime_writebarrierptr(p_param, 0);
        runtime_writebarrierptr(p_next, 0);
        v9 = (runtime_sudog *)sgp;
        v11 = c;
      }
      else
      {
        v10->waiting = v9;
        v10->param = 0;
        v9->next = 0;
      }
      last = (uintptr)v11->sendq.last;
      p_last = (uintptr *)&v11->sendq.last;
      if ( last )
      {
        if ( *(_DWORD *)&runtime_writeBarrier.enabled )
        {
          v31 = (uintptr *)(last + 8);
          runtime_writebarrierptr((uintptr *)&v9->prev, last);
          runtime_writebarrierptr(v31, (uintptr)sgp);
          runtime_writebarrierptr(p_last, (uintptr)sgp);
        }
        else
        {
          v9->prev = (runtime_sudog *)last;
          *(_DWORD *)(last + 8) = v9;
          v11->sendq.last = v9;
        }
      }
      else if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      {
        runtime_writebarrierptr((uintptr *)&v9->prev, 0);
        runtime_writebarrierptr((uintptr *)&v11->sendq, (uintptr)sgp);
        runtime_writebarrierptr(p_last, (uintptr)sgp);
      }
      else
      {
        v9->prev = 0;
        v11->sendq.first = v9;
        v11->sendq.last = v9;
      }
      reasonb.str = (uint8 *)"chan send";
      reasonb.len = 9;
      runtime_goparkunlock(lock, reasonb, 0x16u, 3);
      v13 = gp;
      v14 = (runtime_sudog *)sgp;
      if ( sgp != (uintptr *)gp->waiting )
      {
        lc.str = (uint8 *)"G waiting list is corrupted";
        lc.len = 27;
        runtime_throw(lc);
        BUG();
      }
      if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      {
        runtime_writebarrierptr(p_waiting, 0);
        v13 = gp;
        v14 = (runtime_sudog *)sgp;
      }
      else
      {
        gp->waiting = 0;
      }
      if ( !v13->param )
      {
        if ( c->closed )
        {
          la._type = (runtime__type_0 *)&e;
          la.data = &runtime_statictmp_2;
          runtime_gopanic(la);
          BUG();
        }
        lb.str = (uint8 *)"chansend: spurious wakeup";
        lb.len = 25;
        runtime_throw(lb);
        BUG();
      }
      if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      {
        runtime_writebarrierptr(p_param, 0);
        v14 = (runtime_sudog *)sgp;
      }
      else
      {
        v13->param = 0;
      }
      releasetime = v14->releasetime;
      releasetime_high = HIDWORD(v14->releasetime);
      if ( releasetime_high == 0 && releasetime != 0 || releasetime_high > 0 )
      {
        runtime_blockevent(__PAIR64__(releasetime_high, releasetime) - t0_lo, 2);
        v14 = (runtime_sudog *)sgp;
      }
      if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      {
        runtime_writebarrierptr(dst, 0);
        v14 = (runtime_sudog *)sgp;
      }
      else
      {
        v14->c = 0;
      }
      runtime_releaseSudog(v14);
      return 1;
    }
    else
    {
      runtime_unlock(lock);
      return 0;
    }
  }
  else
  {
    if ( block )
    {
      reason_4.str = (uint8 *)"chan send (nil chan)";
      reason_4.len = 20;
      runtime_gopark(0, 0, reason_4, 0x10u, 2);
      le.str = (uint8 *)"unreachable";
      le.len = 11;
      runtime_throw(le);
      BUG();
    }
    return 0;
  }
}
// 804B9E1: variable 'l' is possibly undefined
// 804B9E4: variable 'reason' is possibly undefined

//----- (0804BAD0) --------------------------------------------------------
void __golang runtime_send(runtime_hchan *c, runtime_sudog *sg, void *ep, func() unlockf, __int32 skip)
{
  runtime_sudog *v5; // eax
  runtime_g *v6; // eax
  runtime_sudog *v7; // ecx
  int64 v8; // [esp+0h] [ebp-14h]
  runtime_g *gp; // [esp+Ch] [ebp-8h]

  v5 = sg;
  if ( sg->elem )
  {
    runtime_sendDirect(c->elemtype, sg, ep);
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
    {
      runtime_writebarrierptr((uintptr *)&sg->elem, 0);
      v5 = sg;
    }
    else
    {
      v5 = sg;
      sg->elem = 0;
    }
  }
  gp = v5->g;
  (*(void (**)(void))unlockf)();
  v6 = gp;
  if ( *(_DWORD *)&runtime_writeBarrier.enabled )
  {
    runtime_writebarrierptr((uintptr *)&gp->param, (uintptr)sg);
    v6 = gp;
    v7 = sg;
  }
  else
  {
    v7 = sg;
    gp->param = sg;
  }
  if ( LODWORD(v7->releasetime) != 0 || HIDWORD(v7->releasetime) != 0 )
  {
    runtime_cputicks();
    sg->releasetime = v8;
    v6 = gp;
  }
  runtime_goready(v6, skip + 1);
}
// 804BB5E: variable 'v8' is possibly undefined

//----- (0804BBF0) --------------------------------------------------------
void __golang runtime_sendDirect(runtime__type_0 *t, runtime_sudog *sg, void *src)
{
  runtime_typeBitsBulkBarrier(t, (uintptr)sg->elem, (uintptr)src, t->size);
  runtime_memmove();
}

//----- (0804BC60) --------------------------------------------------------
void __golang runtime_recvDirect(runtime__type_0 *t, runtime_sudog *sg, void *dst)
{
  runtime_typeBitsBulkBarrier(t, (uintptr)dst, (uintptr)sg->elem, t->size);
  runtime_memmove();
}

//----- (0804BCD0) --------------------------------------------------------
void __golang runtime_closechan(runtime_hchan *c)
{
  runtime_g *i; // eax
  runtime_sudog *v2; // eax
  void *elem; // ecx
  runtime_g *j; // eax
  runtime_sudog *v5; // eax
  runtime_g *k; // eax
  runtime_mutex_0 *l; // [esp+0h] [ebp-28h]
  runtime_mutex_0 *la; // [esp+0h] [ebp-28h]
  interface_{} lb; // [esp+0h] [ebp-28h]
  interface_{} lc; // [esp+0h] [ebp-28h]
  runtime_sudog *src; // [esp+4h] [ebp-24h]
  runtime_sudog *srca; // [esp+4h] [ebp-24h]
  runtime_sudog *sg; // [esp+8h] [ebp-20h]
  runtime_sudog *sg_0; // [esp+Ch] [ebp-1Ch]
  runtime_g *gp; // [esp+10h] [ebp-18h]
  runtime_g *gp_0; // [esp+14h] [ebp-14h]
  runtime_g *g; // [esp+18h] [ebp-10h]
  runtime_g *g_0; // [esp+1Ch] [ebp-Ch]
  runtime_g *schedlink; // [esp+20h] [ebp-8h]
  uintptr *dst; // [esp+24h] [ebp-4h]

  if ( !c )
  {
    lc._type = (runtime__type_0 *)&e;
    lc.data = &runtime_statictmp_3;
    runtime_gopanic(lc);
    BUG();
  }
  runtime_lock(&c->lock);
  if ( c->closed )
  {
    runtime_unlock(&c->lock);
    lb._type = (runtime__type_0 *)&e;
    lb.data = &runtime_statictmp_4;
    runtime_gopanic(lb);
    BUG();
  }
  c->closed = 1;
  for ( i = 0; ; i->schedlink = (runtime_guintptr)g )
  {
    g = i;
    src = runtime___ptr_waitq__dequeue(&c->recvq);
    v2 = src;
    if ( !src )
      break;
    sg_0 = src;
    elem = src->elem;
    if ( elem )
    {
      dst = (uintptr *)&src->elem;
      runtime_typedmemclr(c->elemtype, elem);
      if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      {
        runtime_writebarrierptr(dst, 0);
        v2 = sg_0;
      }
      else
      {
        v2 = sg_0;
        sg_0->elem = 0;
      }
    }
    if ( HIDWORD(v2->releasetime) != 0 || LODWORD(v2->releasetime) != 0 )
    {
      runtime_cputicks();
      LODWORD(sg_0->releasetime) = l;
      HIDWORD(sg_0->releasetime) = src;
      v2 = sg_0;
    }
    i = v2->g;
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
    {
      gp_0 = i;
      runtime_writebarrierptr((uintptr *)&i->param, 0);
      i = gp_0;
    }
    else
    {
      i->param = 0;
    }
  }
  for ( j = g; ; j->schedlink = (runtime_guintptr)g_0 )
  {
    g_0 = j;
    srca = runtime___ptr_waitq__dequeue(&c->sendq);
    v5 = srca;
    if ( !srca )
      break;
    sg = srca;
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
    {
      runtime_writebarrierptr((uintptr *)&srca->elem, 0);
      v5 = sg;
    }
    else
    {
      srca->elem = 0;
    }
    if ( HIDWORD(v5->releasetime) != 0 || LODWORD(v5->releasetime) != 0 )
    {
      runtime_cputicks();
      LODWORD(sg->releasetime) = la;
      HIDWORD(sg->releasetime) = srca;
      v5 = sg;
    }
    j = v5->g;
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
    {
      gp = j;
      runtime_writebarrierptr((uintptr *)&j->param, 0);
      j = gp;
    }
    else
    {
      j->param = 0;
    }
  }
  runtime_unlock(&c->lock);
  for ( k = g_0; k; k = schedlink )
  {
    schedlink = (runtime_g *)k->schedlink;
    k->schedlink = 0;
    runtime_goready(k, 3);
  }
}
// 804BDB2: variable 'l' is possibly undefined
// 804BDB5: variable 'src' is possibly undefined
// 804BEB2: variable 'la' is possibly undefined
// 804BEB5: variable 'srca' is possibly undefined

//----- (0804BF60) --------------------------------------------------------
#error "804BF77: call analysis failed (funcsize=9)"

//----- (0804BF80) --------------------------------------------------------
void __golang runtime_chanrecv(runtime_hchan *c, void *ep, bool block, bool selected, bool received)
{
  runtime_hchan *v5; // eax
  runtime_mutex_0 *v6; // edx
  unsigned int v7; // ebx
  runtime_hchan *v8; // eax
  int elemsize; // ebx
  char *v10; // ecx
  uint v11; // ecx
  runtime_sudog *v12; // eax
  runtime_hchan *v13; // ebp
  uintptr last; // edi
  runtime_g *v15; // eax
  runtime_sudog *v16; // edx
  __int64 v17; // rcx
  uint dataqsiz; // edx
  bool v19; // zf
  runtime_mutex_0 *l; // [esp+0h] [ebp-54h]
  string la; // [esp+0h] [ebp-54h]
  string lb; // [esp+0h] [ebp-54h]
  void *ptr; // [esp+4h] [ebp-50h]
  runtime_sudog *ptra; // [esp+4h] [ebp-50h]
  string ptrb; // [esp+4h] [ebp-50h]
  string src; // [esp+8h] [ebp-4Ch]
  unsigned __int64 t0_lo; // [esp+18h] [ebp-3Ch]
  uintptr *sgp; // [esp+20h] [ebp-34h]
  char *qp; // [esp+24h] [ebp-30h]
  runtime_g *gp; // [esp+28h] [ebp-2Ch]
  uintptr *p_last; // [esp+34h] [ebp-20h]
  uintptr *p_next; // [esp+34h] [ebp-20h]
  uintptr *dst; // [esp+38h] [ebp-1Ch]
  uintptr *p_c; // [esp+3Ch] [ebp-18h]
  uintptr *p_selectdone; // [esp+40h] [ebp-14h]
  uintptr *p_waitlink; // [esp+44h] [ebp-10h]
  runtime_mutex_0 *lock; // [esp+48h] [ebp-Ch]
  int v38[2]; // [esp+4Ch] [ebp-8h] BYREF

  v5 = c;
  if ( c )
  {
    if ( block )
      goto LABEL_3;
    dataqsiz = c->dataqsiz;
    v19 = dataqsiz == 0;
    if ( !dataqsiz )
    {
      if ( !c->sendq.first )
      {
LABEL_51:
        ptr = (void *)runtime_internal_atomic_Load(&c->closed);
        if ( !ptr )
          return;
        v5 = c;
        goto LABEL_3;
      }
      v19 = 1;
    }
    if ( !v19 )
    {
      l = (runtime_mutex_0 *)c;
      runtime_internal_atomic_Loaduint();
      if ( !ptr )
        goto LABEL_51;
      v5 = c;
    }
LABEL_3:
    if ( HIDWORD(runtime_blockprofilerate) != 0
      || (_DWORD)runtime_blockprofilerate != 0 && HIDWORD(runtime_blockprofilerate) == 0 )
    {
      runtime_cputicks();
      v6 = l;
      v7 = (unsigned int)ptr;
      v5 = c;
    }
    else
    {
      v6 = 0;
      v7 = 0;
    }
    t0_lo = __PAIR64__(v7, (unsigned int)v6);
    lock = &v5->lock;
    runtime_lock(&v5->lock);
    if ( c->closed && !c->qcount )
    {
      runtime_unlock(lock);
      if ( ep )
        runtime_typedmemclr(c->elemtype, ep);
    }
    else
    {
      ptra = runtime___ptr_waitq__dequeue(&c->sendq);
      if ( ptra )
      {
        v38[0] = (int)runtime_chanrecv_func1;
        v38[1] = (int)c;
        runtime_recv(c, ptra, ep, (func())v38, 3);
      }
      else
      {
        v8 = c;
        if ( c->qcount )
        {
          elemsize = c->elemsize;
          v10 = (char *)c->buf + elemsize * c->recvx;
          if ( ep )
          {
            qp = (char *)c->buf + elemsize * c->recvx;
            runtime_typedmemmove(c->elemtype, ep, v10);
            v8 = c;
            v10 = qp;
          }
          runtime_typedmemclr(v8->elemtype, v10);
          v11 = c->recvx + 1;
          c->recvx = v11;
          if ( v11 == c->dataqsiz )
            c->recvx = 0;
          --c->qcount;
          runtime_unlock(lock);
        }
        else if ( block )
        {
          gp = *(runtime_g **)(__readgsdword(0) - 4);
          v12 = runtime_acquireSudog();
          v12->releasetime = 0LL;
          if ( (_DWORD)t0_lo != 0 || v7 != 0 )
          {
            LODWORD(v12->releasetime) = -1;
            HIDWORD(v12->releasetime) = -1;
          }
          sgp = (uintptr *)v12;
          if ( *(_DWORD *)&runtime_writeBarrier.enabled )
          {
            p_waitlink = (uintptr *)&v12->waitlink;
            runtime_writebarrierptr((uintptr *)&v12->elem, (uintptr)ep);
            runtime_writebarrierptr(p_waitlink, 0);
            v12 = (runtime_sudog *)sgp;
          }
          else
          {
            v12->elem = ep;
            v12->waitlink = 0;
          }
          p_selectdone = (uintptr *)&v12->selectdone;
          p_c = (uintptr *)&v12->c;
          dst = (uintptr *)&gp->param;
          if ( *(_DWORD *)&runtime_writeBarrier.enabled )
          {
            p_next = (uintptr *)&v12->next;
            runtime_writebarrierptr((uintptr *)&gp->waiting, (uintptr)v12);
            runtime_writebarrierptr(sgp, (uintptr)gp);
            runtime_writebarrierptr(p_selectdone, 0);
            runtime_writebarrierptr(p_c, (uintptr)c);
            runtime_writebarrierptr(dst, 0);
            runtime_writebarrierptr(p_next, 0);
            v12 = (runtime_sudog *)sgp;
            v13 = c;
          }
          else
          {
            gp->waiting = v12;
            v12->g = gp;
            v12->selectdone = 0;
            v13 = c;
            v12->c = c;
            gp->param = 0;
            v12->next = 0;
          }
          last = (uintptr)v13->recvq.last;
          p_last = (uintptr *)&v13->recvq.last;
          if ( last )
          {
            if ( *(_DWORD *)&runtime_writeBarrier.enabled )
            {
              runtime_writebarrierptr((uintptr *)&v12->prev, last);
              runtime_writebarrierptr((uintptr *)(last + 8), (uintptr)sgp);
              runtime_writebarrierptr(p_last, (uintptr)sgp);
            }
            else
            {
              v12->prev = (runtime_sudog *)last;
              *(_DWORD *)(last + 8) = v12;
              v13->recvq.last = v12;
            }
          }
          else if ( *(_DWORD *)&runtime_writeBarrier.enabled )
          {
            runtime_writebarrierptr((uintptr *)&v12->prev, 0);
            runtime_writebarrierptr((uintptr *)&v13->recvq, (uintptr)sgp);
            runtime_writebarrierptr(p_last, (uintptr)sgp);
          }
          else
          {
            v12->prev = 0;
            v13->recvq.first = v12;
            v13->recvq.last = v12;
          }
          ptrb.str = (uint8 *)"chan receive";
          ptrb.len = 12;
          runtime_goparkunlock(lock, ptrb, 0x17u, 3);
          v15 = gp;
          v16 = (runtime_sudog *)sgp;
          if ( sgp != (uintptr *)gp->waiting )
          {
            la.str = (uint8 *)"G waiting list is corrupted";
            la.len = 27;
            runtime_throw(la);
            BUG();
          }
          if ( *(_DWORD *)&runtime_writeBarrier.enabled )
          {
            runtime_writebarrierptr((uintptr *)&gp->waiting, 0);
            v15 = gp;
            v16 = (runtime_sudog *)sgp;
          }
          else
          {
            gp->waiting = 0;
          }
          LODWORD(v17) = v16->releasetime;
          if ( (_DWORD)v17 != 0 && HIDWORD(v16->releasetime) == 0 || SHIDWORD(v16->releasetime) > 0 )
          {
            HIDWORD(v17) = HIDWORD(v16->releasetime);
            runtime_blockevent(v17 - t0_lo, 2);
            v15 = gp;
            v16 = (runtime_sudog *)sgp;
          }
          if ( *(_DWORD *)&runtime_writeBarrier.enabled )
          {
            runtime_writebarrierptr(dst, 0);
            runtime_writebarrierptr(p_c, 0);
            v16 = (runtime_sudog *)sgp;
          }
          else
          {
            v15->param = 0;
            v16->c = 0;
          }
          runtime_releaseSudog(v16);
        }
        else
        {
          runtime_unlock(lock);
        }
      }
    }
    return;
  }
  if ( block )
  {
    src.str = (uint8 *)"chan receive (nil chan)";
    src.len = 23;
    runtime_gopark(0, 0, src, 0x10u, 2);
    lb.str = (uint8 *)"unreachable";
    lb.len = 11;
    runtime_throw(lb);
    BUG();
  }
}
// 804C514: variable 'l' is possibly undefined
// 804C517: variable 'ptr' is possibly undefined

//----- (0804C610) --------------------------------------------------------
void __golang runtime_recv(runtime_hchan *c, runtime_sudog *sg, void *ep, func() unlockf, __int32 skip)
{
  runtime_hchan *v5; // eax
  runtime_sudog *v6; // eax
  runtime_g *v7; // eax
  runtime_sudog *v8; // ecx
  int elemsize; // ebx
  char *v10; // ecx
  uint v11; // ecx
  int64 v12; // [esp+0h] [ebp-14h]
  char *qp; // [esp+Ch] [ebp-8h]
  runtime_g *gp; // [esp+10h] [ebp-4h]

  v5 = c;
  if ( c->dataqsiz )
  {
    elemsize = c->elemsize;
    v10 = (char *)c->buf + elemsize * c->recvx;
    if ( ep )
    {
      qp = (char *)c->buf + elemsize * c->recvx;
      runtime_typedmemmove(c->elemtype, ep, v10);
      v5 = c;
      v10 = qp;
    }
    runtime_typedmemmove(v5->elemtype, v10, sg->elem);
    v11 = c->recvx + 1;
    c->recvx = v11;
    if ( v11 == c->dataqsiz )
      c->recvx = 0;
    c->sendx = c->recvx;
  }
  else if ( ep )
  {
    runtime_recvDirect(c->elemtype, sg, ep);
  }
  v6 = sg;
  if ( *(_DWORD *)&runtime_writeBarrier.enabled )
  {
    runtime_writebarrierptr((uintptr *)&sg->elem, 0);
    v6 = sg;
  }
  else
  {
    sg->elem = 0;
  }
  gp = v6->g;
  (*(void (**)(void))unlockf)();
  v7 = gp;
  if ( *(_DWORD *)&runtime_writeBarrier.enabled )
  {
    runtime_writebarrierptr((uintptr *)&gp->param, (uintptr)sg);
    v7 = gp;
    v8 = sg;
  }
  else
  {
    v8 = sg;
    gp->param = sg;
  }
  if ( LODWORD(v8->releasetime) != 0 || HIDWORD(v8->releasetime) != 0 )
  {
    runtime_cputicks();
    sg->releasetime = v12;
    v7 = gp;
  }
  runtime_goready(v7, skip + 1);
}
// 804C6C5: variable 'v12' is possibly undefined

//----- (0804C7A0) --------------------------------------------------------
__int32 __golang reflect_chanlen(runtime_hchan *c)
{
  if ( c )
    return c->qcount;
  else
    return 0;
}

//----- (0804C7E0) --------------------------------------------------------
runtime_sudog *__golang runtime___ptr_waitq__dequeue(runtime_waitq_0 *q)
{
  runtime_sudog *first; // ecx
  runtime_sudog *next; // edx
  uint32 *selectdone; // edx
  char v4; // [esp+Ch] [ebp-10h]
  runtime_sudog *y; // [esp+10h] [ebp-Ch]
  runtime_sudog *sgp; // [esp+14h] [ebp-8h]
  uintptr *dst; // [esp+18h] [ebp-4h]

  while ( 1 )
  {
    first = q->first;
    if ( !q->first )
      break;
    sgp = q->first;
    next = first->next;
    if ( next )
    {
      if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      {
        dst = (uintptr *)&first->next;
        y = first->next;
        runtime_writebarrierptr((uintptr *)&next->prev, 0);
        runtime_writebarrierptr((uintptr *)q, (uintptr)y);
        runtime_writebarrierptr(dst, 0);
        first = sgp;
      }
      else
      {
        next->prev = 0;
        q->first = next;
        first->next = 0;
      }
    }
    else if ( *(_DWORD *)&runtime_writeBarrier.enabled )
    {
      runtime_writebarrierptr((uintptr *)q, 0);
      runtime_writebarrierptr((uintptr *)&q->last, 0);
      first = sgp;
    }
    else
    {
      q->first = 0;
      q->last = 0;
    }
    selectdone = first->selectdone;
    if ( selectdone )
    {
      if ( *selectdone )
        continue;
      runtime_internal_atomic_Cas();
      if ( !v4 )
        continue;
    }
    return sgp;
  }
  return 0;
}
// 804C862: variable 'v4' is possibly undefined

//----- (0804C930) --------------------------------------------------------
void __golang runtime___ptr_cpuProfile__add(runtime_cpuProfile_0 *p, runtime_g *gp, __uintptr stk)
{
  int64 now; // [esp+0h] [ebp-30h]
  char now_4; // [esp+Ch] [ebp-24h]
  __uint64 v5; // [esp+10h] [ebp-20h]
  uint64 hdr[1]; // [esp+28h] [ebp-8h] BYREF

  while ( 1 )
  {
    LODWORD(now) = &runtime_prof;
    HIDWORD(now) = 0;
    runtime_internal_atomic_Cas();
    if ( now_4 )
      break;
    runtime_osyield();
  }
  if ( runtime_prof.hz )
  {
    if ( p->numExtra > 0 || LODWORD(p->lostExtra) != 0 && HIDWORD(p->lostExtra) == 0 || HIDWORD(p->lostExtra) != 0 )
      runtime___ptr_cpuProfile__addExtra(p);
    hdr[0] = 1LL;
    runtime_nanotime();
    v5.array = hdr;
    *(_QWORD *)&v5.len = 0x100000001LL;
    runtime___ptr_profBuf__write(runtime_cpuprof.log, &gp->labels, now, v5, stk);
  }
  runtime_internal_atomic_Store();
}
// 804C975: variable 'now_4' is possibly undefined
// 804CA1B: variable 'now' is possibly undefined

//----- (0804CA70) --------------------------------------------------------
void __golang runtime___ptr_cpuProfile__addNonGo(runtime_cpuProfile_0 *p, __uintptr stk)
{
  __int32 numExtra; // eax
  char v3; // [esp+Ch] [ebp-4h]

  while ( 1 )
  {
    runtime_internal_atomic_Cas();
    if ( v3 )
      break;
    runtime_osyield();
  }
  numExtra = runtime_cpuprof.numExtra;
  if ( stk.len + runtime_cpuprof.numExtra + 1 >= 1000 )
  {
    ++runtime_cpuprof.lostExtra;
  }
  else
  {
    if ( runtime_cpuprof.numExtra >= 0x3E8u )
      runtime_panicindex();
    runtime_cpuprof.extra[runtime_cpuprof.numExtra] = stk.len + 1;
    if ( (unsigned int)(numExtra + 1) > 0x3E8 )
      runtime_panicslice();
    runtime_memmove();
    runtime_cpuprof.numExtra += stk.len + 1;
  }
  runtime_internal_atomic_Store();
}
// 804CA9F: variable 'v3' is possibly undefined

//----- (0804CB80) --------------------------------------------------------
void __golang runtime___ptr_cpuProfile__addExtra(runtime_cpuProfile_0 *p)
{
  __int32 j; // eax
  __int32 v2; // edx
  unsigned int v3; // ebx
  int lostExtra_high; // eax
  __uint64 v5; // [esp+10h] [ebp-48h]
  __uint64 v6; // [esp+10h] [ebp-48h]
  __uintptr stk; // [esp+1Ch] [ebp-3Ch]
  __uintptr stka; // [esp+1Ch] [ebp-3Ch]
  __int32 i; // [esp+28h] [ebp-30h]
  uintptr lostStk[2]; // [esp+30h] [ebp-28h] BYREF
  uint64 hdr[1]; // [esp+38h] [ebp-20h] BYREF
  uint64 hdr_0[1]; // [esp+40h] [ebp-18h] BYREF
  interface_{} f; // [esp+48h] [ebp-10h]
  interface_{} f_0; // [esp+50h] [ebp-8h]

  hdr_0[0] = 1LL;
  for ( j = 0; j < p->numExtra; j = p->extra[i] + i )
  {
    if ( (unsigned int)j >= 0x3E8 )
      runtime_panicindex();
    v2 = j + 1;
    v3 = j + p->extra[j];
    if ( j + 1 > v3 || v3 > 0x3E8 )
      runtime_panicslice();
    i = j;
    v5.array = hdr_0;
    *(_QWORD *)&v5.len = 0x100000001LL;
    stk.array = (uintptr *)((char *)p->extra + (((j - 999) >> 31) & (4 * v2)));
    stk.len = v3 - v2;
    stk.cap = 999 - j;
    runtime___ptr_profBuf__write(p->log, 0, 0LL, v5, stk);
  }
  p->numExtra = 0;
  if ( LODWORD(p->lostExtra) != 0 && HIDWORD(p->lostExtra) == 0 || HIDWORD(p->lostExtra) != 0 )
  {
    hdr[0] = 0LL;
    lostExtra_high = HIDWORD(p->lostExtra);
    LODWORD(hdr[0]) = p->lostExtra;
    HIDWORD(hdr[0]) = lostExtra_high;
    f._type = (runtime__type_0 *)&unk_80CA340;
    f.data = off_80E7B74;
    f_0._type = (runtime__type_0 *)&unk_80CA340;
    f_0.data = off_80E7B6C;
    lostStk[0] = (uintptr)runtime__LostExternalCode + 1;
    lostStk[1] = (uintptr)runtime__ExternalCode + 1;
    v6.array = hdr;
    *(_QWORD *)&v6.len = 0x100000001LL;
    stka.array = lostStk;
    *(_QWORD *)&stka.len = 0x200000002LL;
    runtime___ptr_profBuf__write(runtime_cpuprof.log, 0, 0LL, v6, stka);
    p->lostExtra = 0LL;
  }
}
// 80E7B6C: using guessed type int (__golang *off_80E7B6C[4])();
// 80E7B74: using guessed type int (__golang *off_80E7B74[2])();

//----- (0804CDC0) --------------------------------------------------------
__int32 __golang runtime_GOMAXPROCS(__int32 n)
{
  __int32 v1; // eax
  string l; // [esp+0h] [ebp-Ch]
  __int32 v3; // [esp+8h] [ebp-4h]
  __int32 na; // [esp+10h] [ebp+4h]

  v1 = n;
  if ( n > 1024 )
    v1 = 1024;
  na = v1;
  runtime_lock(&runtime_sched.lock);
  v3 = runtime_gomaxprocs;
  runtime_unlock(&runtime_sched.lock);
  if ( na <= 0 || na == v3 )
    return v3;
  l.str = (uint8 *)"GOMAXPROCS";
  l.len = 10;
  runtime_stopTheWorld(l);
  runtime_newprocs = na;
  runtime_startTheWorld();
  return v3;
}

//----- (0804CE70) --------------------------------------------------------
string __golang runtime_gogetenv(string key)
{
  __int32 len; // eax
  string *array; // ecx
  __int32 i; // edx
  __int32 v4; // ebx
  uint8 *str; // ebp
  __int32 v6; // eax
  string s; // [esp+0h] [ebp-28h]
  char v8; // [esp+10h] [ebp-18h]
  __int32 env_len; // [esp+18h] [ebp-10h]
  __int32 v10; // [esp+1Ch] [ebp-Ch]
  string *v11; // [esp+24h] [ebp-4h]
  string _r1; // [esp+34h] [ebp+Ch]

  len = runtime_envs.len;
  array = runtime_envs.array;
  if ( !runtime_envs.array )
  {
    s.str = (uint8 *)"getenv before env init";
    s.len = 22;
    runtime_throw(s);
    BUG();
  }
  env_len = runtime_envs.len;
  for ( i = 0; ; ++i )
  {
    if ( i >= len )
    {
      _r1.str = 0;
      _r1.len = 0;
      return _r1;
    }
    v4 = array->len;
    str = array->str;
    if ( v4 > key.len && str[key.len] == 61 )
      break;
LABEL_3:
    ++array;
  }
  v10 = i;
  v11 = array;
  runtime_eqstring();
  if ( !v8 )
  {
    len = env_len;
    array = v11;
    i = v10;
    goto LABEL_3;
  }
  v6 = key.len + 1;
  if ( key.len + 1 > (unsigned int)v4 )
    runtime_panicslice();
  _r1.str = &str[((v6 - v4) >> 31) & v6];
  _r1.len = v4 - v6;
  return _r1;
}
// 804CEF9: variable 'v8' is possibly undefined

//----- (0804CF80) --------------------------------------------------------
string __golang runtime___ptr_TypeAssertionError__Error(runtime_TypeAssertionError *e)
{
  uint8 *str; // ecx
  __int32 len; // edx
  __int64 v3; // rax
  int v4; // ecx
  uint8 *v5; // eax
  __int32 v6; // ecx
  string v7; // kr00_8
  __int32 *v8; // eax
  int v9; // edx
  int v10; // edx
  int v11; // ecx
  int v12; // eax
  string v13; // kr08_8
  __string a; // [esp+4h] [ebp-8Ch]
  __string aa; // [esp+4h] [ebp-8Ch]
  string ab[4]; // [esp+4h] [ebp-8Ch]
  uint8 *inter_ptr; // [esp+2Ch] [ebp-64h]
  __string v18; // [esp+30h] [ebp-60h] BYREF
  int v19; // [esp+3Ch] [ebp-54h]
  int v20; // [esp+48h] [ebp-48h]
  int v21; // [esp+4Ch] [ebp-44h]
  int v22; // [esp+58h] [ebp-38h]
  int v23; // [esp+5Ch] [ebp-34h]
  __string v24; // [esp+60h] [ebp-30h] BYREF
  int v25; // [esp+6Ch] [ebp-24h]
  int v26; // [esp+78h] [ebp-18h]
  int v27; // [esp+7Ch] [ebp-14h]
  char v28; // [esp+80h] [ebp-10h] BYREF
  int v29; // [esp+88h] [ebp-8h]
  int v30; // [esp+8Ch] [ebp-4h]

  while ( (unsigned int)&v28 <= *(_DWORD *)(*(_DWORD *)(__readgsdword(0) - 4) + 8) )
    runtime_morestack_noctxt();
  if ( e->interfaceString.len )
  {
    str = e->interfaceString.str;
    len = e->interfaceString.len;
  }
  else
  {
    str = (uint8 *)"interface";
    len = 9;
  }
  if ( e->concreteString.len )
  {
    if ( e->missingMethod.len )
    {
      v8 = (__int32 *)((int (*)(void))loc_8090228)();
      v9 = v8[3];
      v18.cap = v8[2];
      v19 = v9;
      v10 = v8[5];
      v20 = v8[4];
      v21 = v10;
      v11 = v8[6];
      v12 = v8[7];
      v22 = v11;
      v23 = v12;
      aa.array = (string *)&v18;
      *(_QWORD *)&aa.len = 0x600000006LL;
      v13 = runtime_concatstrings(0, aa);
      v6 = v13.len;
      v5 = v13.str;
    }
    else
    {
      inter_ptr = str;
      v3 = ((__int64 (*)(void))loc_8090228)();
      v24.cap = (__int32)inter_ptr;
      v25 = HIDWORD(v3);
      HIDWORD(v3) = *(_DWORD *)(v3 + 12);
      v26 = *(_DWORD *)(v3 + 8);
      v27 = HIDWORD(v3);
      v4 = *(_DWORD *)(v3 + 16);
      LODWORD(v3) = *(_DWORD *)(v3 + 20);
      v29 = v4;
      v30 = v3;
      a.array = (string *)&v24;
      *(_QWORD *)&a.len = 0x600000006LL;
      v7 = runtime_concatstrings(0, a);
      v6 = v7.len;
      v5 = v7.str;
    }
    return (string)__PAIR64__(v6, (unsigned int)v5);
  }
  else
  {
    ab[3] = e->assertedString;
    ab[0].str = (uint8 *)"interface conversion: ";
    ab[0].len = 22;
    ab[1] = (string)__PAIR64__(len, (unsigned int)str);
    ab[2].str = (uint8 *)" is nil, not ";
    ab[2].len = 13;
    return runtime_concatstring4(0, *(string (*)[4])&ab[0].str);
  }
}

//----- (0804D150) --------------------------------------------------------
string __golang runtime_errorString_Error(runtime_errorString e)
{
  string a[2]; // [esp+4h] [ebp-18h]

  a[0].str = (uint8 *)"runtime error: ";
  a[0].len = 15;
  a[1] = (string)e;
  return runtime_concatstring2(0, *(string (*)[2])&a[0].str);
}

//----- (0804D1B0) --------------------------------------------------------
string __golang runtime_plainError_Error(runtime_plainError e)
{
  return (string)e;
}

//----- (0804D1E0) --------------------------------------------------------
string __golang runtime_typestring(interface_{} x)
{
  return runtime___ptr__type__string(x._type);
}

//----- (0804D220) --------------------------------------------------------
void __golang runtime_printany(interface_{} i)
{
  runtime__type_0 *type; // edx
  __int16 *data; // ecx
  char v3; // bl
  bool v4; // zf
  float64 v5; // xmm0_8
  unsigned __int8 v6; // bl
  bool v7; // zf
  float v8; // xmm0_4
  float v9; // xmm1_4
  unsigned int v10; // ebx
  unsigned int v11; // ebp
  bool v12; // zf
  uint32 v13; // eax
  unsigned int v14; // ebx
  float v15; // xmm0_4
  bool v16; // zf
  double v17; // xmm0_8
  double v18; // xmm1_8
  int v19; // ebx
  bool v20; // zf
  uintptr v21; // eax
  char v22; // bl
  bool v23; // zf
  uint32 v24; // eax
  unsigned int v25; // ebx
  bool v26; // zf
  __int32 v27; // eax
  unsigned int v28; // ebx
  __int16 v29; // bx
  unsigned __int16 v30; // bx
  __int32 v31; // eax
  string e; // [esp+0h] [ebp-7Ch]
  string ea; // [esp+0h] [ebp-7Ch]
  complex128 eb; // [esp+0h] [ebp-7Ch]
  complex128 ec; // [esp+0h] [ebp-7Ch]
  string ed; // [esp+0h] [ebp-7Ch]
  unsigned int v37; // [esp+8h] [ebp-74h]
  string v38; // [esp+8h] [ebp-74h]
  runtime_iface_0 v39; // [esp+Ch] [ebp-70h]
  runtime_iface_0 v40; // [esp+Ch] [ebp-70h]
  bool v41; // [esp+14h] [ebp-68h]
  char v42; // [esp+14h] [ebp-68h]
  char v43; // [esp+14h] [ebp-68h]
  uint32 v_lo_0; // [esp+28h] [ebp-54h]
  __int32 v_len; // [esp+2Ch] [ebp-50h]
  uint32 v_4; // [esp+3Ch] [ebp-40h]
  __int32 v_7; // [esp+48h] [ebp-34h]
  uintptr v_8; // [esp+4Ch] [ebp-30h]
  uint32 hash; // [esp+58h] [ebp-24h]
  int v50; // [esp+78h] [ebp-4h]

  if ( i._type )
  {
    hash = i._type->hash;
    runtime_assertE2I2((runtime_interfacetype_0 *)&inter, i, v39, v41);
    if ( v42 || (runtime_assertE2I2((runtime_interfacetype_0 *)&iface, i, v40, 0), v43) )
    {
      v50 = ((int (__golang *)(void *))v40.tab->fun[0])(v40.data);
      runtime_printlock();
      runtime_printstring((string)__PAIR64__(v37, v50));
      runtime_printunlock();
      return;
    }
    if ( hash > 0xB31A546D )
    {
      if ( hash > 0xD04AE83D )
      {
        if ( hash > 0xE0FF5CB4 )
        {
          if ( hash == -321552178 )
          {
            type = i._type;
            data = (__int16 *)i.data;
            if ( &unk_80CEBA0 == (_UNKNOWN *)i._type )
              v29 = *(_WORD *)i.data;
            else
              v29 = 0;
            if ( &unk_80CEBA0 == (_UNKNOWN *)i._type )
            {
              runtime_printlock();
              runtime_printint(v29);
              runtime_printunlock();
              return;
            }
          }
          else
          {
            data = (__int16 *)i.data;
            type = i._type;
          }
          if ( hash == -269349216
            && (&unk_80CF260 != (_UNKNOWN *)type ? (v30 = 0) : (v30 = *data), &unk_80CF260 == (_UNKNOWN *)type) )
          {
            runtime_printlock();
            runtime_printint(v30);
            runtime_printunlock();
          }
          else
          {
            if ( hash != -145526278 )
              goto LABEL_17;
            v31 = &stru_80CEB60 == type ? *(_DWORD *)data : 0;
            if ( &stru_80CEB60 != type )
              goto LABEL_17;
            v_7 = v31;
            runtime_printlock();
            runtime_printint(v_7);
            runtime_printunlock();
          }
        }
        else
        {
          if ( hash == -709331182 )
          {
            type = i._type;
            data = (__int16 *)i.data;
            if ( &unk_80CF220 == (_UNKNOWN *)i._type )
              v25 = *(_DWORD *)i.data;
            else
              v25 = 0;
            if ( &unk_80CF220 == (_UNKNOWN *)i._type )
            {
              runtime_printlock();
              runtime_printint(v25);
              runtime_printunlock();
              return;
            }
            v26 = 0;
          }
          else
          {
            v26 = hash == -520135500;
            data = (__int16 *)i.data;
            type = i._type;
          }
          if ( !v26 )
            goto LABEL_17;
          if ( &t == (const interface_{} *)type )
          {
            v27 = *((_DWORD *)data + 1);
            v28 = *(_DWORD *)data;
          }
          else
          {
            v27 = 0;
            v28 = 0;
          }
          if ( &t != (const interface_{} *)type )
            goto LABEL_17;
          v_len = v27;
          runtime_printlock();
          runtime_printstring((string)__PAIR64__(v_len, v28));
          runtime_printunlock();
        }
      }
      else if ( hash > 0xBD4AD792 )
      {
        if ( hash == -871972825 )
        {
          type = i._type;
          data = (__int16 *)i.data;
          if ( &unk_80CEC60 == (_UNKNOWN *)i._type )
            v22 = *(_BYTE *)i.data;
          else
            v22 = 0;
          if ( &unk_80CEC60 == (_UNKNOWN *)i._type )
          {
            runtime_printlock();
            runtime_printint(v22);
            runtime_printunlock();
            return;
          }
          v23 = 0;
        }
        else
        {
          v23 = hash == -800397251;
          data = (__int16 *)i.data;
          type = i._type;
        }
        if ( !v23 )
          goto LABEL_17;
        v24 = &stru_80CF2A0 == type ? *(_DWORD *)data : 0;
        if ( &stru_80CF2A0 != type )
          goto LABEL_17;
        v_4 = v24;
        runtime_printlock();
        runtime_printint(v_4);
        runtime_printunlock();
      }
      else
      {
        if ( hash == -1146273534 )
        {
          type = i._type;
          data = (__int16 *)i.data;
          if ( &unk_80CEBE0 == (_UNKNOWN *)i._type )
            v19 = *(_DWORD *)i.data;
          else
            v19 = 0;
          if ( &unk_80CEBE0 == (_UNKNOWN *)i._type )
          {
            runtime_printlock();
            runtime_printint(v19);
            runtime_printunlock();
            return;
          }
          v20 = 0;
        }
        else
        {
          v20 = hash == -1119168622;
          data = (__int16 *)i.data;
          type = i._type;
        }
        if ( !v20 )
          goto LABEL_17;
        v21 = &et == type ? *(_DWORD *)data : 0;
        if ( &et != type )
          goto LABEL_17;
        v_8 = v21;
        runtime_printlock();
        runtime_printint(v_8);
        runtime_printunlock();
      }
    }
    else if ( hash > 0x7925028C )
    {
      if ( hash > 0x963F9BFF )
      {
        if ( hash == -1329447213 )
        {
          type = i._type;
          data = (__int16 *)i.data;
          if ( &unk_80CE820 == (_UNKNOWN *)i._type )
            v15 = *(float *)i.data;
          else
            v15 = 0.0;
          if ( &unk_80CE820 == (_UNKNOWN *)i._type )
          {
            runtime_printlock();
            runtime_printfloat(v15);
            runtime_printunlock();
            return;
          }
          v16 = 0;
        }
        else
        {
          v16 = hash == -1290120083;
          data = (__int16 *)i.data;
          type = i._type;
        }
        if ( !v16 )
          goto LABEL_17;
        if ( &unk_80CE7A0 == (_UNKNOWN *)type )
        {
          v17 = *(double *)data;
          v18 = *((double *)data + 1);
        }
        else
        {
          v17 = 0.0;
          v18 = 0.0;
        }
        if ( &unk_80CE7A0 != (_UNKNOWN *)type )
          goto LABEL_17;
        runtime_printlock();
        ec.real = v17;
        ec.imag = v18;
        runtime_printcomplex(ec);
        runtime_printunlock();
      }
      else
      {
        if ( hash == -2043572946 )
        {
          type = i._type;
          data = (__int16 *)i.data;
          if ( &unk_80CF2E0 == (_UNKNOWN *)i._type )
          {
            v10 = *((_DWORD *)i.data + 1);
            v11 = *(_DWORD *)i.data;
          }
          else
          {
            v10 = 0;
            v11 = 0;
          }
          if ( &unk_80CF2E0 == (_UNKNOWN *)i._type )
          {
            runtime_printlock();
            runtime_printuint(__PAIR64__(v10, v11));
            runtime_printunlock();
            return;
          }
          v12 = 0;
        }
        else
        {
          v12 = hash == -1774216193;
          data = (__int16 *)i.data;
          type = i._type;
        }
        if ( !v12 )
          goto LABEL_17;
        if ( &unk_80CEC20 == (_UNKNOWN *)type )
        {
          v13 = *(_DWORD *)data;
          v14 = *((_DWORD *)data + 1);
        }
        else
        {
          v13 = 0;
          v14 = 0;
        }
        if ( &unk_80CEC20 != (_UNKNOWN *)type )
          goto LABEL_17;
        v_lo_0 = v13;
        runtime_printlock();
        runtime_printint(__SPAIR64__(v14, v_lo_0));
        runtime_printunlock();
      }
    }
    else if ( hash > 0x2EA27FFB )
    {
      if ( hash == 1715356255 )
      {
        type = i._type;
        data = (__int16 *)i.data;
        if ( &::i == i._type )
          v6 = *(_BYTE *)i.data;
        else
          v6 = 0;
        if ( &::i == i._type )
        {
          runtime_printlock();
          runtime_printint(v6);
          runtime_printunlock();
          return;
        }
        v7 = 0;
      }
      else
      {
        v7 = hash == 2032468620;
        data = (__int16 *)i.data;
        type = i._type;
      }
      if ( !v7 )
        goto LABEL_17;
      if ( &unk_80CE7E0 == (_UNKNOWN *)type )
      {
        v8 = *((float *)data + 1);
        v9 = *(float *)data;
      }
      else
      {
        v9 = 0.0;
        v8 = 0.0;
      }
      if ( &unk_80CE7E0 != (_UNKNOWN *)type )
        goto LABEL_17;
      runtime_printlock();
      eb.real = v9;
      eb.imag = v8;
      runtime_printcomplex(eb);
      runtime_printunlock();
    }
    else
    {
      if ( hash == 335480517 )
      {
        type = i._type;
        data = (__int16 *)i.data;
        if ( &unk_80CE760 == (_UNKNOWN *)i._type )
          v3 = *(_BYTE *)i.data;
        else
          v3 = 0;
        if ( &unk_80CE760 == (_UNKNOWN *)i._type )
        {
          runtime_printlock();
          runtime_printbool(v3);
          runtime_printunlock();
          return;
        }
        v4 = 0;
      }
      else
      {
        v4 = hash == 782401531;
        data = (__int16 *)i.data;
        type = i._type;
      }
      if ( !v4
        || (&unk_80CE860 != (_UNKNOWN *)type ? (v5 = 0.0) : (v5 = *(double *)data), &unk_80CE860 != (_UNKNOWN *)type) )
      {
LABEL_17:
        v38 = runtime_typestring((interface_{})__PAIR64__((unsigned int)data, (unsigned int)type));
        runtime_printlock();
        e.str = (uint8 *)"(";
        e.len = 1;
        runtime_printstring(e);
        runtime_printstring(v38);
        ea.str = (uint8 *)") ";
        ea.len = 2;
        runtime_printstring(ea);
        runtime_printeface(i);
        runtime_printunlock();
        return;
      }
      runtime_printlock();
      runtime_printfloat(v5);
      runtime_printunlock();
    }
  }
  else
  {
    runtime_printlock();
    ed.str = (uint8 *)"nil";
    ed.len = 3;
    runtime_printstring(ed);
    runtime_printunlock();
  }
}
// 804D267: variable 'v39' is possibly undefined
// 804D267: variable 'v41' is possibly undefined
// 804D27B: variable 'v42' is possibly undefined
// 804D27D: variable 'v40' is possibly undefined
// 804D2A9: variable 'v37' is possibly undefined
// 804D2EA: variable 'v43' is possibly undefined
// 80E0D85: using guessed type char asc_80E0D85;

//----- (0804DB10) --------------------------------------------------------
void __golang __noreturn runtime_panicwrap()
{
  unsigned int v0; // ecx
  unsigned int v1; // edx
  unsigned int v2; // eax
  int v3; // ebx
  unsigned int v4; // ebp
  int v5; // eax
  unsigned __int32 v6; // ecx
  int v7; // eax
  int v8; // edx
  _BYTE et[36]; // [esp+0h] [ebp-11Ch]
  string eta; // [esp+0h] [ebp-11Ch]
  __string et_4; // [esp+4h] [ebp-118h]
  string et_4a[2]; // [esp+4h] [ebp-118h]
  string et_4b[2]; // [esp+4h] [ebp-118h]
  string et_4c[2]; // [esp+4h] [ebp-118h]
  runtime_eface_0 cap; // [esp+8h] [ebp-114h]
  interface_{} capa; // [esp+8h] [ebp-114h]
  int cap_4; // [esp+Ch] [ebp-110h]
  string v18; // [esp+14h] [ebp-108h]
  string v19; // [esp+14h] [ebp-108h]
  string v20; // [esp+14h] [ebp-108h]
  bool v21; // [esp+24h] [ebp-F8h]
  __int64 pc_len; // [esp+2Ch] [ebp-F0h]
  unsigned int name_len; // [esp+34h] [ebp-E8h]
  unsigned __int32 name_lena; // [esp+34h] [ebp-E8h]
  uint8 v25[32]; // [esp+5Ch] [ebp-C0h] BYREF
  uint8 *typ_ptr; // [esp+7Ch] [ebp-A0h]
  uint8 *pkg_ptr; // [esp+80h] [ebp-9Ch] BYREF
  uintptr *pc_ptr; // [esp+84h] [ebp-98h]
  runtime_Frames *frames; // [esp+88h] [ebp-94h]
  string elem; // [esp+8Ch] [ebp-90h] BYREF
  runtime_Frame_0 frame; // [esp+94h] [ebp-88h]
  __string a; // [esp+D4h] [ebp-48h] BYREF
  int v33; // [esp+E0h] [ebp-3Ch]
  uint8 *v34; // [esp+ECh] [ebp-30h]
  int v35; // [esp+F0h] [ebp-2Ch]
  uint8 *v36; // [esp+FCh] [ebp-20h]
  int v37; // [esp+100h] [ebp-1Ch]
  uint8 *v38; // [esp+10Ch] [ebp-10h]
  int v39; // [esp+110h] [ebp-Ch]

  while ( (unsigned int)&pkg_ptr <= *(_DWORD *)(*(_DWORD *)(__readgsdword(0) - 4) + 8) )
    runtime_morestack_noctxt();
  *(runtime_slice_0 *)&et[12] = runtime_makeslice((runtime__type_0 *)&::et, 1, 1);
  pc_len = *(_QWORD *)&et[16];
  pc_ptr = *(uintptr **)&et[12];
  *(_DWORD *)&et[4] = *(_DWORD *)&et[12];
  *(_QWORD *)&et[8] = *(_QWORD *)&et[16];
  *(_DWORD *)&et[16] = runtime_Callers(2, *(__uintptr *)&et[4]);
  if ( *(_DWORD *)&et[16] )
  {
    *(_DWORD *)et = pc_ptr;
    *(_QWORD *)&et[4] = pc_len;
    *(_DWORD *)&et[12] = runtime_CallersFrames(*(__uintptr *)et);
    frames = *(runtime_Frames **)&et[12];
    ((void (*)(void))loc_808FD88)();
    runtime___ptr_Frames__Next(frames, *(runtime_Frame_0 *)&et[4], v21);
    ((void (*)(void))loc_8090250)();
    ((void (*)(void))loc_8090250)();
    name_len = frame.Function.len;
    pkg_ptr = frame.Function.str;
    strings_IndexByte();
    if ( cap_4 >= 0 )
    {
      v0 = cap_4 - 1;
      v1 = name_len;
      if ( cap_4 - 1 <= name_len )
      {
        v2 = cap_4 + 2;
        if ( cap_4 + 2 < (int)name_len )
        {
          if ( v0 > v2 || v2 > name_len )
            runtime_panicslice();
          v3 = cap_4 + 2;
          v4 = v2 - v0;
          v5 = v0 & ((int)(v0 - v2) >> 31);
          if ( v4 == 3 && *(_WORD *)&pkg_ptr[v5] == 10286 && pkg_ptr[v5 + 2] == 42 )
          {
            name_lena = name_len - v3;
            typ_ptr = &pkg_ptr[((int)(v3 - v1) >> 31) & v3];
            strings_IndexByte();
            v6 = cap_4 + 2;
            if ( cap_4 + 2 < (int)name_lena )
            {
              if ( cap_4 > v6 || v6 > name_lena )
                runtime_panicslice();
              if ( *(_WORD *)&typ_ptr[cap_4] == 11817 )
              {
                if ( cap_4 <= name_lena )
                {
                  ((void (__golang *)(uint8 *))loc_80901EC)(typ_ptr);
                  a.cap = (__int32)pkg_ptr;
                  v33 = cap_4 - 1;
                  v34 = typ_ptr;
                  v35 = v7;
                  v36 = &typ_ptr[((cap_4 + 2 - v8) >> 31) & (cap_4 + 2)];
                  v37 = v8 - (cap_4 + 2);
                  v38 = typ_ptr;
                  v39 = v7;
                  et_4.array = (string *)&a;
                  *(_QWORD *)&et_4.len = 0x900000009LL;
                  elem = runtime_concatstrings(0, et_4);
                  runtime_convT2Estring((runtime__type_0 *)&e, &elem, cap);
                  runtime_gopanic(capa);
                  BUG();
                }
                runtime_panicslice();
              }
            }
            et_4a[0].str = (uint8 *)"panicwrap: unexpected string after type name: ";
            et_4a[0].len = 46;
            et_4a[1] = frame.Function;
            v18 = runtime_concatstring2(0, *(string (*)[2])&et_4a[0].str);
            runtime_throw(v18);
            BUG();
          }
        }
        et_4b[0].str = (uint8 *)"panicwrap: unexpected string after package name: ";
        et_4b[0].len = 49;
        et_4b[1] = frame.Function;
        v19 = runtime_concatstring2(0, *(string (*)[2])&et_4b[0].str);
        runtime_throw(v19);
        BUG();
      }
      runtime_panicslice();
    }
    et_4c[0].str = (uint8 *)"panicwrap: no ( in ";
    et_4c[0].len = 19;
    et_4c[1] = frame.Function;
    v20 = runtime_concatstring2((uint8 (*)[32])v25, *(string (*)[2])&et_4c[0].str);
    runtime_throw(v20);
    BUG();
  }
  eta.str = (uint8 *)"panicwrap: Callers failed";
  eta.len = 25;
  runtime_throw(eta);
  BUG();
}
// 804DCC6: conditional instruction was optimized away because %cap@4.4>=0
// 804DBD2: variable 'et' is possibly undefined
// 804DBD2: variable 'v21' is possibly undefined
// 804DC2A: variable 'cap_4' is possibly undefined
// 804DD3C: variable 'v7' is possibly undefined
// 804DD4B: variable 'v8' is possibly undefined
// 804DDC1: variable 'cap' is possibly undefined
// 804DDD5: variable 'capa' is possibly undefined

//----- (0804DF50) --------------------------------------------------------
void __golang runtime_Caller(__int32 skip, uintptr pc, string file, __int32 line, bool ok)
{
  uintptr *v5; // ecx
  __int32 v6; // edx
  unsigned int v7; // edx
  __uintptr pcbuf; // [esp+4h] [ebp-C8h]
  __uintptr pcbufa; // [esp+4h] [ebp-C8h]
  __uintptr pcbufb; // [esp+4h] [ebp-C8h]
  long double v11; // [esp+10h] [ebp-BCh]
  __uintptr v12; // [esp+10h] [ebp-BCh]
  runtime_Frame_0 v13; // [esp+1Ch] [ebp-B0h]
  runtime_Frame_0 v14; // [esp+1Ch] [ebp-B0h]
  bool v15; // [esp+3Ch] [ebp-90h]
  bool v16; // [esp+3Ch] [ebp-90h]
  uintptr rpc[3]; // [esp+44h] [ebp-88h] BYREF
  uintptr *callers_ptr; // [esp+50h] [ebp-7Ch]
  char v19; // [esp+80h] [ebp-4Ch] BYREF
  runtime_stackExpander_0 stackExpander; // [esp+94h] [ebp-38h] BYREF

  while ( (unsigned int)&v19 <= *(_DWORD *)(*(_DWORD *)(__readgsdword(0) - 4) + 8) )
    runtime_morestack_noctxt();
  memset(rpc, 0, sizeof(rpc));
  pcbuf.array = rpc;
  *(_QWORD *)&pcbuf.len = 0x300000003LL;
  LODWORD(v11) = runtime_callers(skip, pcbuf);
  if ( SLODWORD(v11) >= 2 )
  {
    ((void (*)(void))loc_808FD82)();
    if ( rpc[0] - runtime_skipPC >= 0x100 )
    {
      if ( rpc[1] - runtime_skipPC - 1 < 0xFF )
        stackExpander.skip = rpc[1] - runtime_skipPC;
      v5 = rpc;
      v6 = 3;
    }
    else
    {
      v5 = &rpc[1];
      v6 = 2;
    }
    *(_QWORD *)&pcbufa.array = __PAIR64__(v6, (unsigned int)v5);
    pcbufa.cap = v6;
    runtime___ptr_stackExpander__next(&stackExpander, pcbufa, *(__uintptr *)&v11, v13, v15);
    if ( v16 )
    {
      callers_ptr = v12.array;
      ((void (*)(void))loc_808FD88)();
      pcbufb.array = callers_ptr;
      *(_QWORD *)&pcbufb.len = __PAIR64__(v7, v12.len);
      runtime___ptr_stackExpander__next(&stackExpander, pcbufb, v12, v14, v16);
      ((void (*)(void))loc_8090250)();
      ((void (*)(void))loc_8090250)();
    }
  }
}
// 804DF50: could not find valid save-restore pair for ebp
// 804E001: variable 'v11' is possibly undefined
// 804E001: variable 'v13' is possibly undefined
// 804E001: variable 'v15' is possibly undefined
// 804E019: variable 'v16' is possibly undefined
// 804E01F: variable 'v12' is possibly undefined
// 804E046: variable 'v7' is possibly undefined
// 804E04E: variable 'v14' is possibly undefined

//----- (0804E160) --------------------------------------------------------
__int32 __golang runtime_Callers(__int32 skip, __uintptr pc)
{
  if ( pc.len )
    return runtime_callers(skip, pc);
  else
    return 0;
}

//----- (0804E1C0) --------------------------------------------------------
string __golang runtime_GOROOT()
{
  string key; // [esp+0h] [ebp-10h]
  string v1; // [esp+8h] [ebp-8h]
  string _r0; // [esp+14h] [ebp+4h]

  key.str = (uint8 *)"GOROOT";
  key.len = 6;
  v1 = runtime_gogetenv(key);
  if ( v1.len )
    return v1;
  _r0.str = (uint8 *)"/usr/local/go";
  _r0.len = 13;
  return _r0;
}

//----- (0804E220) --------------------------------------------------------
float64 __golang runtime_float64frombits(uint64 b)
{
  float64 _r1; // [esp+Ch] [ebp+Ch]

  *(_QWORD *)&_r1 = b;
  return _r1;
}

//----- (0804E250) --------------------------------------------------------
uintptr __golang runtime_memhash(void *p, uintptr seed, uintptr s)
{
  uintptr v3; // ecx
  uintptr v4; // edx
  uintptr v5; // eax
  __int32 v7; // ebp
  __int32 v8; // esi
  int v9; // edi
  unsigned int v10; // ecx
  unsigned int v11; // ecx
  uintptr v12; // [esp+Ch] [ebp-10h]

  if ( runtime_useAeshash )
  {
    runtime_aeshash();
    return v12;
  }
  else
  {
    v3 = s;
    v4 = seed;
    v5 = seed + s * (uintptr)runtime_hashkey.array;
    while ( v3 )
    {
      if ( v3 < 4 )
      {
        v10 = -955283999
            * __ROL4__(
                -1125984735
              * (((unsigned __int8)*((char *)p + v3 - 1) << 16) ^ (*((unsigned __int8 *)p + (v3 >> 1)) << 8) ^ v5 ^ *(unsigned __int8 *)p),
                15);
        goto LABEL_13;
      }
      if ( v3 == 4 )
      {
        v10 = -955283999 * __ROL4__(-1125984735 * (v5 ^ *(_DWORD *)p), 15);
        goto LABEL_13;
      }
      if ( v3 <= 8 )
      {
        v10 = -955283999
            * __ROL4__(
                -1125984735
              * (*(_DWORD *)((char *)p + v3 - 4) ^ (-955283999 * __ROL4__(-1125984735 * (v5 ^ *(_DWORD *)p), 15))),
                15);
        goto LABEL_13;
      }
      if ( v3 <= 0x10 )
      {
        v10 = -955283999
            * __ROL4__(
                -1125984735
              * ((-955283999
                * __ROL4__(
                    -1125984735
                  * ((-955283999
                    * __ROL4__(
                        -1125984735
                      * ((-955283999 * __ROL4__(-1125984735 * (*(_DWORD *)p ^ v5), 15)) ^ *((_DWORD *)p + 1)),
                        15)) ^ *(_DWORD *)((char *)p + v3 - 8)),
                    15)) ^ *(_DWORD *)((char *)p + v3 - 4)),
                15);
        goto LABEL_13;
      }
      v7 = v4 * runtime_hashkey.len;
      v8 = v4 * runtime_hashkey.cap;
      v9 = v4 * unk_81576EC;
      while ( v3 >= 0x10 )
      {
        v5 = -955283999 * __ROL4__(-1125984735 * (*(_DWORD *)p ^ v5), 15);
        v7 = 832293441 * __ROL4__(-955283999 * (*((_DWORD *)p + 1) ^ v7), 15);
        v8 = -1958602207 * __ROL4__(832293441 * (*((_DWORD *)p + 2) ^ v8), 15);
        v9 = -1125984735 * __ROL4__(-1958602207 * (v9 ^ *((_DWORD *)p + 3)), 15);
        v3 -= 16;
        p = (char *)p + 16;
        v4 = seed;
      }
      v5 ^= v9 ^ v8 ^ v7;
    }
    v10 = v5;
LABEL_13:
    v11 = -1958602207 * ((832293441 * ((v10 >> 17) ^ v10)) ^ ((832293441 * ((v10 >> 17) ^ v10)) >> 13));
    return v11 ^ HIWORD(v11);
  }
}
// 804E47F: variable 'v12' is possibly undefined

//----- (0804E4A0) --------------------------------------------------------
runtime_bmap *__golang runtime___ptr_hmap__newoverflow(runtime_hmap *h, runtime_maptype_0 *t, runtime_bmap *b)
{
  runtime_hmap *v3; // eax
  runtime_mapextra *extra; // edx
  runtime_bmap *nextOverflow; // ebp
  int bucketsize; // ebx
  uintptr *v7; // ebp
  uintptr v8; // ebx
  runtime_mapextra *v9; // edx
  runtime_bmap *v10; // edx
  uint8 v11; // bl
  runtime_maptype_0 *v12; // ebx
  uintptr *v13; // ecx
  __int32 v14; // eax
  uintptr *v15; // ebp
  __int32 v16; // esi
  uintptr *array; // eax
  __int32 len; // ecx
  uintptr *v19; // ebx
  int v20; // ebp
  unsigned int v21; // edi
  runtime_slice_0 srcb; // [esp+4h] [ebp-38h]
  ___runtime_bmap *src; // [esp+4h] [ebp-38h]
  runtime_mapextra *srca; // [esp+4h] [ebp-38h]
  runtime_slice_0 v25; // [esp+14h] [ebp-28h]
  runtime_bmap *ovf; // [esp+24h] [ebp-18h]
  uintptr *dst; // [esp+2Ch] [ebp-10h]
  uintptr tophash; // [esp+30h] [ebp-Ch]

  v3 = h;
  extra = h->extra;
  if ( extra && (nextOverflow = extra->nextOverflow) != 0 )
  {
    tophash = (uintptr)extra->nextOverflow->tophash;
    bucketsize = t->bucketsize;
    v7 = (uintptr *)&nextOverflow->tophash[bucketsize - 4];
    v8 = tophash + bucketsize;
    if ( *v7 )
    {
      if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      {
        runtime_writebarrierptr(v7, 0);
        v3 = h;
      }
      else
      {
        *v7 = 0;
      }
      v9 = v3->extra;
      if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      {
        runtime_writebarrierptr((uintptr *)&v9->nextOverflow, 0);
        v3 = h;
      }
      else
      {
        v9->nextOverflow = 0;
      }
    }
    else if ( *(_DWORD *)&runtime_writeBarrier.enabled )
    {
      runtime_writebarrierptr((uintptr *)&extra->nextOverflow, v8);
      v3 = h;
    }
    else
    {
      extra->nextOverflow = (runtime_bmap *)v8;
    }
    v10 = (runtime_bmap *)tophash;
  }
  else
  {
    v10 = (runtime_bmap *)runtime_newobject(t->bucket);
    v3 = h;
  }
  v11 = v3->B;
  if ( v11 >= 0x10u )
  {
    v20 = *(_DWORD *)(*(_DWORD *)(__readgsdword(0) - 4) + 24);
    v21 = (*(int *)(v20 + 148) >> 31) & 0xA8888EEF ^ (2 * *(_DWORD *)(v20 + 148));
    *(_DWORD *)(v20 + 148) = v21;
    if ( (v21 & ((unsigned __int8)(v11 - 15) < 0x20u ? (1 << (v11 - 15)) + 1 : -1)) == 0 )
      ++v3->noverflow;
  }
  else
  {
    ++v3->noverflow;
  }
  ovf = v10;
  v12 = t;
  if ( (t->bucket->kind & 0x80u) != 0 )
  {
    if ( !v3->extra )
    {
      srca = (runtime_mapextra *)runtime_newobject((runtime__type_0 *)&stru_80D3C20);
      if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      {
        runtime_writebarrierptr((uintptr *)&h->extra, (uintptr)srca);
        v3 = h;
      }
      else
      {
        v3 = h;
        h->extra = srca;
      }
      v10 = ovf;
      v12 = t;
    }
    if ( !v3->extra->overflow[0] )
    {
      src = (___runtime_bmap *)runtime_newobject((runtime__type_0 *)&stru_80C9100);
      v3 = h;
      if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      {
        runtime_writebarrierptr((uintptr *)h->extra, (uintptr)src);
        v3 = h;
      }
      else
      {
        h->extra->overflow[0] = src;
      }
      v10 = ovf;
      v12 = t;
    }
    v13 = (uintptr *)v3->extra->overflow[0];
    v14 = v13[2];
    v15 = (uintptr *)*v13;
    v16 = v13[1];
    if ( v16 + 1 > v14 )
    {
      dst = v13;
      srcb.array = (void *)*v13;
      *(_QWORD *)&srcb.len = __PAIR64__(v14, v16);
      v25 = runtime_growslice((runtime__type_0 *)&stru_80D2120, srcb, v16 + 1);
      array = (uintptr *)v25.array;
      len = v25.len;
      v19 = dst;
      dst[2] = v25.cap;
      if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      {
        runtime_writebarrierptr(dst, (uintptr)v25.array);
        array = (uintptr *)v25.array;
        len = v25.len;
        v19 = dst;
      }
      else
      {
        *dst = (uintptr)v25.array;
      }
      v10 = ovf;
      v16 = len;
      v15 = array;
      v13 = v19;
      v12 = t;
    }
    v13[1] = v16 + 1;
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
    {
      runtime_writebarrierptr(&v15[v16], (uintptr)v10);
      v10 = ovf;
      v12 = t;
    }
    else
    {
      v15[v16] = (uintptr)v10;
    }
  }
  if ( *(_DWORD *)&runtime_writeBarrier.enabled )
  {
    runtime_writebarrierptr((uintptr *)&b->tophash[v12->bucketsize - 4], (uintptr)v10);
    return ovf;
  }
  else
  {
    *(_DWORD *)&b->tophash[v12->bucketsize - 4] = v10;
  }
  return v10;
}

//----- (0804E7F0) --------------------------------------------------------
runtime_hmap *__golang runtime_makemap(runtime_maptype_0 *t, int64 hint, runtime_hmap *h, void *bucket)
{
  unsigned int v4; // edx
  unsigned int v5; // eax
  int32 v6; // edx
  runtime__type_0 *key; // ebx
  unsigned int v8; // ebp
  bool v9; // cc
  runtime__type_0 *elem; // esi
  unsigned int v11; // edi
  bool v12; // cc
  uint8 align; // dl
  uint8 v14; // bl
  unsigned int v15; // esi
  uint8 i; // al
  bool v17; // cl
  uintptr v18; // ecx
  void *v20; // ebx
  int v21; // eax
  unsigned int v22; // ebp
  void *v23; // eax
  runtime_mapextra *v24; // eax
  float v25; // xmm0_4
  float v26; // xmm1_4
  uintptr size; // ebx
  unsigned int v28; // ebx
  uint64 dst; // [esp+0h] [ebp-38h]
  string dsta; // [esp+0h] [ebp-38h]
  string dstb; // [esp+0h] [ebp-38h]
  string dstc; // [esp+0h] [ebp-38h]
  string dstd; // [esp+0h] [ebp-38h]
  string dste; // [esp+0h] [ebp-38h]
  string dstf; // [esp+0h] [ebp-38h]
  string dstg; // [esp+0h] [ebp-38h]
  string dsth; // [esp+0h] [ebp-38h]
  string dsti; // [esp+0h] [ebp-38h]
  string dstj; // [esp+0h] [ebp-38h]
  string dstk; // [esp+0h] [ebp-38h]
  string dstl; // [esp+0h] [ebp-38h]
  void *src; // [esp+4h] [ebp-34h]
  double v43; // [esp+8h] [ebp-30h]
  void *v44; // [esp+8h] [ebp-30h]
  uintptr v45; // [esp+Ch] [ebp-2Ch]
  uint8 B; // [esp+13h] [ebp-25h]
  int32 count_hi; // [esp+14h] [ebp-24h]
  uintptr v; // [esp+18h] [ebp-20h]
  unsigned int v_4; // [esp+1Ch] [ebp-1Ch]
  double v50; // [esp+20h] [ebp-18h]
  runtime_mapextra *extra; // [esp+2Ch] [ebp-Ch]
  runtime_mapextra *extraa; // [esp+2Ch] [ebp-Ch]
  void *buckets; // [esp+30h] [ebp-8h]

  if ( t->hmap->size != 28 )
  {
    v = t->hmap->size;
    runtime_printlock();
    dstj.str = (uint8 *)"runtime: sizeof(hmap) =";
    dstj.len = 23;
    runtime_printstring(dstj);
    runtime_printsp();
    runtime_printint(28LL);
    runtime_printsp();
    dstk.str = (uint8 *)", t.hmap.size =";
    dstk.len = 15;
    runtime_printstring(dstk);
    runtime_printsp();
    runtime_printint(v);
    runtime_printnl();
    runtime_printunlock();
    dstl.str = (uint8 *)"bad hmap size";
    dstl.len = 13;
    runtime_throw(dstl);
    BUG();
  }
  v4 = hint;
  if ( hint < 0
    || ((size = t->bucket->size, size >= 0x21) ? (v4 = hint, v28 = 0xFFFFFFFF / size) : (v28 = runtime_maxElems[size]),
        SHIDWORD(hint) > 0 || v4 > v28 && HIDWORD(hint) == 0) )
  {
    v5 = 0;
    v6 = 0;
  }
  else
  {
    v5 = v4;
    v6 = HIDWORD(hint);
  }
  key = t->key;
  if ( !key->alg->hash )
  {
    dsti.str = (uint8 *)"runtime.makemap: unsupported map key type";
    dsti.len = 41;
    runtime_throw(dsti);
    BUG();
  }
  v8 = key->size;
  v9 = key->size <= 0x80;
  if ( key->size > 0x80 )
  {
    if ( !t->indirectkey || t->keysize != 4 )
    {
LABEL_64:
      dsth.str = (uint8 *)"key size wrong";
      dsth.len = 14;
      runtime_throw(dsth);
      BUG();
    }
    v9 = v8 <= 0x80;
  }
  if ( v9 )
  {
    if ( t->indirectkey )
      goto LABEL_64;
    key = t->key;
    if ( (_BYTE)v8 != t->keysize )
      goto LABEL_64;
  }
  count_hi = v6;
  elem = t->elem;
  v11 = elem->size;
  v12 = elem->size <= 0x80;
  if ( elem->size > 0x80 )
  {
    if ( !t->indirectvalue || t->valuesize != 4 )
    {
LABEL_63:
      dstg.str = (uint8 *)"value size wrong";
      dstg.len = 16;
      runtime_throw(dstg);
      BUG();
    }
    v12 = v11 <= 0x80;
  }
  if ( v12 && *(_WORD *)&t->valuesize != (unsigned __int8)v11 )
    goto LABEL_63;
  align = key->align;
  if ( align > 8u )
  {
    dstf.str = (uint8 *)"key align too big";
    dstf.len = 17;
    runtime_throw(dstf);
    BUG();
  }
  v14 = elem->align;
  if ( v14 > 8u )
  {
    dste.str = (uint8 *)"value align too big";
    dste.len = 19;
    runtime_throw(dste);
    BUG();
  }
  if ( !align )
    runtime_panicdivide();
  v15 = v5;
  if ( v8 % align )
  {
    dstd.str = (uint8 *)"key size not a multiple of key align";
    dstd.len = 36;
    runtime_throw(dstd);
    BUG();
  }
  if ( !v14 )
    runtime_panicdivide();
  if ( v11 % v14 )
  {
    dstc.str = (uint8 *)"value size not a multiple of value align";
    dstc.len = 40;
    runtime_throw(dstc);
    BUG();
  }
  if ( 8u % align )
  {
    dstb.str = (uint8 *)"need padding in bucket (key)";
    dstb.len = 28;
    runtime_throw(dstb);
    BUG();
  }
  if ( 8u % v14 )
  {
    dsta.str = (uint8 *)"need padding in bucket (value)";
    dsta.len = 30;
    runtime_throw(dsta);
    BUG();
  }
  v_4 = v5;
  for ( i = 0; ; ++i )
  {
    B = i;
    if ( count_hi > 0 || count_hi == 0 && v15 >= 8 )
    {
      v50 = runtime_int64tofloat64(__SPAIR64__(count_hi, v15));
      LODWORD(dst) = B < 0x20u ? 1 << B : 0;
      HIDWORD(dst) = ((unsigned __int8)(B - 32) < 0x20u ? 1 << (B - 32) : 0) | ((unsigned __int8)(32 - B) < 0x20u ? 1u >> (32 - B) : 0);
      v43 = runtime_uint64tofloat64(dst);
      v25 = v50;
      v26 = v43;
      v17 = v25 >= (float)(6.5 * v26);
      i = B;
      v15 = v_4;
    }
    else
    {
      v17 = 0;
    }
    if ( !v17 )
      break;
  }
  if ( i )
  {
    runtime_makeBucketArray(t, i, (void *)LODWORD(v43), (runtime_bmap *)HIDWORD(v43));
    v23 = v44;
    if ( v45 )
    {
      src = runtime_newobject((runtime__type_0 *)&stru_80D3C20);
      v24 = (runtime_mapextra *)src;
      if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      {
        extraa = (runtime_mapextra *)src;
        runtime_writebarrierptr((uintptr *)src + 2, v45);
        v24 = extraa;
      }
      else
      {
        *((_DWORD *)src + 2) = v45;
      }
      v18 = (uintptr)v24;
      v23 = v44;
    }
    else
    {
      v18 = 0;
    }
    bucket = v23;
    i = B;
  }
  else
  {
    v18 = 0;
  }
  buckets = bucket;
  v20 = h;
  if ( !h )
  {
    extra = (runtime_mapextra *)v18;
    v20 = runtime_newobject(t->hmap);
    i = B;
    v18 = (uintptr)extra;
    bucket = buckets;
  }
  *(_DWORD *)v20 = 0;
  *((_BYTE *)v20 + 5) = i;
  if ( *(_DWORD *)&runtime_writeBarrier.enabled )
  {
    runtime_writebarrierptr((uintptr *)v20 + 6, v18);
    bucket = buckets;
  }
  else
  {
    *((_DWORD *)v20 + 6) = v18;
  }
  *((_BYTE *)v20 + 4) = 0;
  v21 = *(_DWORD *)(*(_DWORD *)(__readgsdword(0) - 4) + 24);
  v22 = (*(int *)(v21 + 148) >> 31) & 0xA8888EEF ^ (2 * *(_DWORD *)(v21 + 148));
  *(_DWORD *)(v21 + 148) = v22;
  *((_DWORD *)v20 + 2) = v22;
  if ( *(_DWORD *)&runtime_writeBarrier.enabled )
  {
    runtime_writebarrierptr((uintptr *)v20 + 3, (uintptr)bucket);
    runtime_writebarrierptr((uintptr *)v20 + 4, 0);
  }
  else
  {
    *((_DWORD *)v20 + 3) = bucket;
    *((_DWORD *)v20 + 4) = 0;
  }
  *((_DWORD *)v20 + 5) = 0;
  *((_WORD *)v20 + 3) = 0;
  return (runtime_hmap *)v20;
}
// 804EAB6: variable 'v43' is possibly undefined
// 804EABF: variable 'v44' is possibly undefined
// 804EAC5: variable 'v45' is possibly undefined

//----- (0804ED80) --------------------------------------------------------
retval_804ED80 __golang runtime_mapaccess2(runtime_maptype_0 *t, runtime_hmap *h, void *key)
{
  unsigned int v3; // esi
  int bucketsize; // eax
  char *v5; // ecx
  _BYTE *oldbuckets; // ebp
  int v7; // esi
  unsigned int v8; // eax
  unsigned int j; // edx
  int v10; // ebx
  int v11; // ebx
  char *v12; // eax
  string s; // [esp+0h] [ebp-1Ch]
  unsigned int v14; // [esp+8h] [ebp-14h]
  uint8 top; // [esp+Fh] [ebp-Dh]
  uintptr i; // [esp+10h] [ebp-Ch]
  runtime_typeAlg *alg; // [esp+14h] [ebp-8h]
  char *v18; // [esp+18h] [ebp-4h]
  retval_804ED80 _r3; // [esp+2Ch] [ebp+10h]

  if ( h && h->count )
  {
    if ( (h->flags & 4) != 0 )
    {
      s.str = (uint8 *)"concurrent map read and map write";
      s.len = 33;
      runtime_throw(s);
      BUG();
    }
    alg = t->key->alg;
    v14 = (*(int (__golang **)(void *, uint32))alg->hash)(key, h->hash0);
    v3 = h->B < 0x20u ? (1 << h->B) + 1 : -1;
    bucketsize = t->bucketsize;
    v5 = (char *)h->buckets + bucketsize * (v14 & v3);
    oldbuckets = h->oldbuckets;
    if ( oldbuckets )
    {
      if ( (h->flags & 8) == 0 )
        v3 >>= 1;
      v7 = bucketsize * (v14 & v3);
      if ( (unsigned __int8)(oldbuckets[v7] - 1) >= 3u )
        v5 = &oldbuckets[v7];
    }
    if ( HIBYTE(v14) >= 4u )
      v8 = HIBYTE(v14);
    else
      LOBYTE(v8) = HIBYTE(v14) + 4;
    top = v8;
    while ( 2 )
    {
      v18 = v5;
      for ( j = 0; j < 8; ++j )
      {
        if ( (_BYTE)v8 == v5[j] )
        {
          i = j;
          if ( t->indirectkey )
            v10 = *(_DWORD *)&v5[j * t->keysize + 8];
          else
            v10 = (int)&v5[j * t->keysize + 8];
          if ( (*(unsigned __int8 (__golang **)(void *, int))alg->equal)(key, v10) )
          {
            v11 = t->valuesize * i;
            if ( t->indirectvalue )
              v12 = *(char **)&v18[8 * t->keysize + 8 + v11];
            else
              v12 = &v18[8 * t->keysize + 8 + v11];
            _r3._r3 = v12;
            _r3._r4 = 1;
            return _r3;
          }
          LOBYTE(v8) = top;
          v5 = v18;
          j = i;
        }
      }
      v5 = *(char **)&v5[t->bucketsize - 4];
      if ( v5 )
        continue;
      break;
    }
    _r3._r3 = runtime_zeroVal;
    _r3._r4 = 0;
  }
  else
  {
    _r3._r3 = runtime_zeroVal;
    _r3._r4 = 0;
  }
  return _r3;
}

//----- (0804EF80) --------------------------------------------------------
retval_804EF80 __golang runtime_mapaccessK(runtime_maptype_0 *t, runtime_hmap *h, void *key)
{
  unsigned int v3; // eax
  unsigned int v4; // ebp
  int bucketsize; // edi
  char *v6; // ecx
  char *oldbuckets; // ebx
  char *v8; // ebx
  unsigned int v9; // eax
  unsigned int j; // edx
  char *v11; // ebp
  char *v12; // eax
  int v13; // [esp+8h] [ebp-18h]
  uint8 top; // [esp+Fh] [ebp-11h]
  uintptr i; // [esp+10h] [ebp-10h]
  runtime_typeAlg *alg; // [esp+18h] [ebp-8h]
  char *v17; // [esp+1Ch] [ebp-4h]
  retval_804EF80 _r3; // [esp+30h] [ebp+10h]

  if ( h && h->count )
  {
    alg = t->key->alg;
    v13 = (*(int (__golang **)(void *, uint32))alg->hash)(key, h->hash0);
    v3 = v13;
    v4 = h->B < 0x20u ? (1 << h->B) + 1 : -1;
    bucketsize = t->bucketsize;
    v6 = (char *)h->buckets + bucketsize * (v13 & v4);
    oldbuckets = (char *)h->oldbuckets;
    if ( oldbuckets )
    {
      v3 = v13;
      if ( (h->flags & 8) == 0 )
        v4 >>= 1;
      v8 = &oldbuckets[bucketsize * (v13 & v4)];
      if ( (unsigned __int8)(*v8 - 1) >= 3u )
        v6 = v8;
    }
    v9 = HIBYTE(v3);
    if ( (unsigned __int8)v9 < 4u )
      LOBYTE(v9) = v9 + 4;
    top = v9;
    while ( 2 )
    {
      v17 = v6;
      for ( j = 0; j < 8; ++j )
      {
        if ( (_BYTE)v9 == v6[j] )
        {
          i = j;
          v11 = &v6[j * t->keysize + 8];
          if ( t->indirectkey )
            v11 = *(char **)v11;
          if ( (*(unsigned __int8 (__golang **)(void *, char *))alg->equal)(key, v11) )
          {
            if ( t->indirectvalue )
              v12 = *(char **)&v17[8 * t->keysize + 8 + i * t->valuesize];
            else
              v12 = &v17[8 * t->keysize + 8 + i * t->valuesize];
            _r3._r3 = v11;
            _r3._r4 = v12;
            return _r3;
          }
          LOBYTE(v9) = top;
          v6 = v17;
          j = i;
        }
      }
      v6 = *(char **)&v6[t->bucketsize - 4];
      if ( v6 )
        continue;
      break;
    }
    _r3._r3 = 0;
    _r3._r4 = 0;
  }
  else
  {
    _r3._r3 = 0;
    _r3._r4 = 0;
  }
  return _r3;
}

//----- (0804F150) --------------------------------------------------------
void *__golang runtime_mapassign(runtime_maptype_0 *t, runtime_hmap *h, void *key)
{
  unsigned int v3; // eax
  runtime_hmap *v4; // ecx
  void *v5; // esi
  int v6; // ebx
  uintptr v7; // ebp
  unsigned __int8 v8; // bl
  uintptr v9; // et0
  bool v10; // zf
  runtime_bmap *v11; // ebx
  unsigned __int8 v12; // si
  unsigned __int8 v13; // t1
  int v14; // ebx
  runtime_bmap *v15; // ecx
  uintptr *tophash; // edi
  uint8 *v17; // eax
  unsigned int v18; // eax
  runtime_hmap *v19; // edx
  void **v20; // eax
  uint8 flags; // dl
  bool v22; // al
  uint8 v23; // cl
  int v24; // ebx
  uint16 noverflow; // ax
  uint8 v26; // bl
  runtime_bmap *v27; // ebp
  bool v28; // al
  uintptr *v29; // eax
  uintptr *v30; // ecx
  float v31; // xmm0_4
  float v32; // xmm1_4
  uint64 typ; // [esp+0h] [ebp-58h]
  string typa; // [esp+0h] [ebp-58h]
  string typb; // [esp+0h] [ebp-58h]
  interface_{} typc; // [esp+0h] [ebp-58h]
  void *dst; // [esp+4h] [ebp-54h]
  uintptr *dsta; // [esp+4h] [ebp-54h]
  void *src; // [esp+8h] [ebp-50h]
  uint8 top; // [esp+12h] [ebp-46h]
  uint8 B; // [esp+13h] [ebp-45h]
  uintptr i; // [esp+14h] [ebp-44h]
  uintptr hash; // [esp+18h] [ebp-40h]
  int bucket; // [esp+1Ch] [ebp-3Ch]
  int keysize; // [esp+20h] [ebp-38h]
  double v46; // [esp+2Ch] [ebp-2Ch]
  uintptr *kmem; // [esp+38h] [ebp-20h]
  uint8 *k; // [esp+3Ch] [ebp-1Ch]
  void *insertk; // [esp+40h] [ebp-18h]
  uintptr *insertka; // [esp+40h] [ebp-18h]
  uint8 *inserti; // [esp+44h] [ebp-14h]
  runtime_typeAlg *alg; // [esp+48h] [ebp-10h]
  uintptr *v53; // [esp+50h] [ebp-8h]
  runtime_bmap *b; // [esp+54h] [ebp-4h]

  if ( !h )
  {
    typc._type = (runtime__type_0 *)&e;
    typc.data = &runtime_statictmp_9;
    runtime_gopanic(typc);
    BUG();
  }
  if ( (h->flags & 4) != 0 )
  {
    typb.str = (uint8 *)"concurrent map writes";
    typb.len = 21;
    runtime_throw(typb);
    BUG();
  }
  alg = t->key->alg;
  v3 = (*(int (__golang **)(void *, uint32))alg->hash)(key, h->hash0);
  hash = v3;
  v4 = h;
  h->flags |= 4u;
  if ( !h->buckets )
  {
    src = runtime_newarray(t->bucket, 1);
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr((uintptr *)&h->buckets, (uintptr)src);
    else
      h->buckets = src;
    v3 = hash;
    v4 = h;
  }
  while ( 2 )
  {
    v19 = v4;
    v23 = v4->B;
    v24 = v3 & (v23 < 0x20u ? (1 << v23) + 1 : -1);
    if ( v19->oldbuckets )
    {
      bucket = v3 & (v23 < 0x20u ? (1 << v23) + 1 : -1);
      runtime_growWork(t, v19, v24);
      v3 = hash;
      v19 = h;
      v24 = bucket;
    }
    v6 = (int)v19->buckets + t->bucketsize * v24;
    v18 = HIBYTE(v3);
    if ( (unsigned __int8)v18 < 4u )
      LOBYTE(v18) = v18 + 4;
    top = v18;
    v15 = 0;
    v5 = 0;
    tophash = 0;
    while ( 2 )
    {
      b = (runtime_bmap *)v6;
      i = 0;
      while ( 1 )
      {
        insertk = v5;
        inserti = (uint8 *)v15;
        v7 = i;
        if ( i >= 8 )
          break;
        v9 = v6 + i;
        v8 = *(_BYTE *)(v6 + i);
        v10 = (_BYTE)v18 == v8;
        v13 = v8;
        v11 = (runtime_bmap *)v9;
        v12 = v13;
        if ( v10 )
        {
          v17 = &b[1].tophash[i * t->keysize];
          if ( t->indirectkey )
            v17 = *(uint8 **)v17;
          k = v17;
          if ( (*(unsigned __int8 (__golang **)(void *, uint8 *))alg->equal)(key, v17) )
          {
            if ( t->needkeyupdate )
              runtime_typedmemmove(t->key, k, key);
            v20 = (void **)&b[t->keysize + 1].tophash[i * t->valuesize];
            goto LABEL_20;
          }
          LOBYTE(v18) = top;
          v19 = h;
          v7 = i;
          v15 = (runtime_bmap *)inserti;
          v14 = (int)insertk;
        }
        else if ( v12 )
        {
          v14 = (int)insertk;
        }
        else if ( v15 )
        {
          v14 = (int)insertk;
        }
        else
        {
          keysize = t->keysize;
          v15 = v11;
          v14 = (int)&b[1].tophash[keysize * i];
          v7 = i;
          tophash = (uintptr *)&b[keysize + 1].tophash[i * t->valuesize];
        }
        i = v7 + 1;
        v5 = (void *)v14;
        v6 = (int)b;
      }
      if ( *(_DWORD *)(v6 + t->bucketsize - 4) )
      {
        v6 = *(_DWORD *)(v6 + t->bucketsize - 4);
        LOBYTE(v18) = top;
        continue;
      }
      break;
    }
    if ( v19->oldbuckets )
    {
      v27 = v15;
    }
    else
    {
      B = v19->B;
      if ( v19->count >= 8u && v19->count >= 0 )
      {
        v46 = runtime_int64tofloat64(v19->count);
        LODWORD(typ) = B < 0x20u ? 1 << B : 0;
        HIDWORD(typ) = ((unsigned __int8)(B - 32) < 0x20u ? 1 << (B - 32) : 0) | ((unsigned __int8)(32 - B) < 0x20u ? 1u >> (32 - B) : 0);
        v31 = v46;
        v32 = runtime_uint64tofloat64(typ);
        v22 = v31 >= (float)(6.5 * v32);
        v15 = (runtime_bmap *)inserti;
        v19 = h;
      }
      else
      {
        v22 = 0;
      }
      if ( v22
        || ((noverflow = v19->noverflow, v26 = v19->B, v26 >= 0x10u) ? (v28 = noverflow >= 0x8000u, v27 = v15) : (runtime_bmap *)(v27 = v15, v28 = noverflow >= (unsigned int)(v26 < 0x20u ? 1 << v26 : 0)),
            v28) )
      {
        runtime_hashGrow(t, v19);
        v3 = hash;
        v4 = h;
        continue;
      }
    }
    break;
  }
  if ( v27 )
  {
    v29 = (uintptr *)v5;
  }
  else
  {
    v27 = runtime___ptr_hmap__newoverflow(v19, t, b);
    tophash = (uintptr *)v27[t->keysize + 1].tophash;
    v29 = (uintptr *)v27[1].tophash;
  }
  if ( t->indirectkey )
  {
    v53 = v29;
    dsta = (uintptr *)runtime_newobject(t->key);
    v30 = dsta;
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
    {
      kmem = dsta;
      runtime_writebarrierptr(v53, (uintptr)dsta);
      v30 = kmem;
    }
    else
    {
      *v53 = (uintptr)dsta;
    }
    v29 = v30;
  }
  if ( t->indirectvalue )
  {
    insertka = v29;
    dst = runtime_newobject(t->elem);
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr(tophash, (uintptr)dst);
    else
      *tophash = (uintptr)dst;
    v29 = insertka;
  }
  runtime_typedmemmove(t->key, v29, key);
  v27->tophash[0] = top;
  ++h->count;
  v20 = (void **)tophash;
LABEL_20:
  flags = h->flags;
  if ( (flags & 4) == 0 )
  {
    typa.str = (uint8 *)"concurrent map writes";
    typa.len = 21;
    runtime_throw(typa);
    BUG();
  }
  h->flags = flags & 0xFB;
  if ( t->indirectvalue )
    return *v20;
  return v20;
}

//----- (0804F700) --------------------------------------------------------
void __golang runtime_mapiterinit(runtime_maptype_0 *t, runtime_hmap *h, runtime_hiter *it)
{
  runtime_hiter *dst; // eax
  runtime_maptype_0 **p_t; // ebp
  void **p_buckets; // edi
  runtime_hmap *v6; // edx
  uintptr buckets; // ebp
  runtime_mapextra *extra; // ebx
  ___runtime_bmap *v9; // ebp
  int v10; // ebx
  unsigned int v11; // esi
  int v12; // ebx
  unsigned int v13; // edi
  unsigned int v14; // ebx
  ___runtime_bmap *src; // [esp+4h] [ebp-28h]
  runtime_mapextra *srca; // [esp+4h] [ebp-28h]
  uintptr *p_extra; // [esp+14h] [ebp-18h]
  uintptr *p_bptr; // [esp+1Ch] [ebp-10h]
  uintptr *p_h; // [esp+24h] [ebp-8h]
  uintptr *p_value; // [esp+28h] [ebp-4h]

  dst = it;
  p_value = (uintptr *)&it->value;
  p_t = &it->t;
  p_h = (uintptr *)&it->h;
  p_buckets = &it->buckets;
  p_bptr = (uintptr *)&it->bptr;
  if ( *(_DWORD *)&runtime_writeBarrier.enabled )
  {
    runtime_writebarrierptr((uintptr *)it, 0);
    runtime_writebarrierptr(p_value, 0);
    runtime_writebarrierptr((uintptr *)&it->t, 0);
    runtime_writebarrierptr(p_h, 0);
    runtime_writebarrierptr((uintptr *)&it->buckets, 0);
    runtime_writebarrierptr(p_bptr, 0);
    runtime_writebarrierptr((uintptr *)it->overflow, 0);
    runtime_writebarrierptr((uintptr *)&it->overflow[1], 0);
    dst = it;
    p_t = &it->t;
    p_buckets = &it->buckets;
  }
  else
  {
    it->key = 0;
    it->value = 0;
    it->t = 0;
    it->h = 0;
    it->buckets = 0;
    it->bptr = 0;
    it->overflow[0] = 0;
    it->overflow[1] = 0;
  }
  v6 = h;
  if ( h && h->count )
  {
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
    {
      runtime_writebarrierptr((uintptr *)p_t, (uintptr)t);
      runtime_writebarrierptr(p_h, (uintptr)h);
      dst = it;
      v6 = h;
      p_buckets = &it->buckets;
    }
    else
    {
      dst->t = t;
      dst->h = h;
    }
    dst->B = v6->B;
    buckets = (uintptr)v6->buckets;
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
    {
      runtime_writebarrierptr((uintptr *)p_buckets, buckets);
      dst = it;
      v6 = h;
    }
    else
    {
      dst->buckets = (void *)buckets;
    }
    if ( (t->bucket->kind & 0x80u) != 0 )
    {
      if ( !v6->extra )
      {
        p_extra = (uintptr *)&v6->extra;
        srca = (runtime_mapextra *)runtime_newobject((runtime__type_0 *)&stru_80D3C20);
        if ( *(_DWORD *)&runtime_writeBarrier.enabled )
          runtime_writebarrierptr(p_extra, (uintptr)srca);
        else
          h->extra = srca;
        dst = it;
        v6 = h;
      }
      if ( !v6->extra->overflow[0] )
      {
        src = (___runtime_bmap *)runtime_newobject((runtime__type_0 *)&stru_80C9100);
        if ( *(_DWORD *)&runtime_writeBarrier.enabled )
          runtime_writebarrierptr((uintptr *)h->extra, (uintptr)src);
        else
          h->extra->overflow[0] = src;
        dst = it;
        v6 = h;
      }
      extra = v6->extra;
      if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      {
        runtime_typedmemmove((runtime__type_0 *)&stru_80CC320, dst->overflow, extra);
        dst = it;
        v6 = h;
      }
      else
      {
        v9 = extra->overflow[1];
        dst->overflow[0] = extra->overflow[0];
        dst->overflow[1] = v9;
      }
    }
    v10 = *(_DWORD *)(*(_DWORD *)(__readgsdword(0) - 4) + 24);
    v11 = (*(int *)(v10 + 148) >> 31) & 0xA8888EEF ^ (2 * *(_DWORD *)(v10 + 148));
    *(_DWORD *)(v10 + 148) = v11;
    if ( v6->B <= 0x1Cu )
    {
      v14 = v11;
    }
    else
    {
      v12 = *(_DWORD *)(*(_DWORD *)(__readgsdword(0) - 4) + 24);
      v13 = (*(int *)(v12 + 148) >> 31) & 0xA8888EEF ^ (2 * *(_DWORD *)(v12 + 148));
      *(_DWORD *)(v12 + 148) = v13;
      v14 = (v13 << 31) + v11;
    }
    dst->startBucket = v14 & (v6->B < 0x20u ? (1 << v6->B) + 1 : -1);
    dst->offset = (v6->B < 0x20u ? v14 >> v6->B : 0) & 7;
    dst->bucket = dst->startBucket;
    dst->wrapped = 0;
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
    {
      runtime_writebarrierptr(p_bptr, 0);
      dst = it;
      v6 = h;
    }
    else
    {
      dst->bptr = 0;
    }
    if ( (v6->flags & 3) != 3 )
    {
      runtime_internal_atomic_Or8();
      dst = it;
    }
    runtime_mapiternext(dst);
  }
  else if ( *(_DWORD *)&runtime_writeBarrier.enabled )
  {
    runtime_writebarrierptr((uintptr *)dst, 0);
    runtime_writebarrierptr(p_value, 0);
  }
  else
  {
    dst->key = 0;
    dst->value = 0;
  }
}

//----- (0804FB30) --------------------------------------------------------
void __golang runtime_mapiternext(runtime_hiter *it)
{
  uintptr v1; // edi
  runtime_maptype_0 *v2; // ecx
  runtime_bmap *bptr; // ebp
  runtime_hmap *v4; // edx
  uint8 i; // bl
  uintptr v6; // eax
  int *v7; // esi
  int v8; // edi
  uint8 v9; // cl
  runtime_maptype_0 *v10; // ecx
  uint8 *key; // ebp
  void *r4; // ecx
  void *v13; // eax
  runtime_maptype_0 *v14; // ecx
  uint8 *v15; // edx
  runtime_hiter *v16; // eax
  runtime_hmap *v17; // ebp
  uint8 B; // si
  int v19; // eax
  int bucketsize; // esi
  runtime_bmap *v21; // eax
  runtime_bmap *v22; // ebx
  int v23; // ecx
  uintptr v24; // eax
  string s; // [esp+0h] [ebp-4Ch]
  retval_804EF80 v26; // [esp+Ch] [ebp-40h]
  uintptr checkBucket; // [esp+18h] [ebp-34h]
  uintptr checkBucketa; // [esp+18h] [ebp-34h]
  uintptr bucket; // [esp+1Ch] [ebp-30h]
  int v30; // [esp+20h] [ebp-2Ch]
  int keysize; // [esp+24h] [ebp-28h]
  void **v; // [esp+28h] [ebp-24h]
  runtime_maptype_0 *t; // [esp+2Ch] [ebp-20h]
  runtime_hmap *h; // [esp+3Ch] [ebp-10h]
  runtime_typeAlg *alg; // [esp+40h] [ebp-Ch]
  runtime_bmap *v36; // [esp+48h] [ebp-4h]

  if ( (it->h->flags & 4) != 0 )
  {
    s.str = (uint8 *)"concurrent map iteration and map write";
    s.len = 38;
    runtime_throw(s);
    BUG();
  }
  h = it->h;
  t = it->t;
  v1 = it->bucket;
  v2 = t;
  bptr = it->bptr;
  v4 = h;
  i = it->i;
  v6 = it->checkBucket;
  alg = t->key->alg;
LABEL_64:
  if ( !bptr )
  {
    v16 = it;
    if ( v1 == it->startBucket && it->wrapped )
    {
      if ( *(_DWORD *)&runtime_writeBarrier.enabled )
        runtime_writebarrierptr((uintptr *)it, 0);
      else
        it->key = 0;
      if ( *(_DWORD *)&runtime_writeBarrier.enabled )
        runtime_writebarrierptr((uintptr *)&it->value, 0);
      else
        it->value = 0;
      return;
    }
    if ( v4->oldbuckets && (v16 = it, it->B == v4->B) )
    {
      v17 = it->h;
      B = v17->B;
      if ( (v17->flags & 8) == 0 )
        --B;
      v19 = v1 & (B < 0x20u ? (1 << B) + 1 : -1);
      bucketsize = v2->bucketsize;
      v21 = (runtime_bmap *)((char *)v4->oldbuckets + bucketsize * v19);
      if ( (unsigned __int8)(v21->tophash[0] - 1) >= 3u )
      {
        v23 = v1;
        v22 = v21;
        v16 = it;
      }
      else
      {
        v16 = it;
        v22 = (runtime_bmap *)((char *)it->buckets + v1 * bucketsize);
        v23 = -1;
      }
    }
    else
    {
      v22 = (runtime_bmap *)((char *)v16->buckets + v1 * v2->bucketsize);
      v23 = -1;
    }
    checkBucketa = v23;
    if ( v1 + 1 == (v16->B < 0x20u ? 1 << v16->B : 0) )
    {
      v16->wrapped = 1;
      v24 = 0;
    }
    else
    {
      v24 = v1 + 1;
    }
    v2 = t;
    v1 = v24;
    bptr = v22;
    i = 0;
    v6 = checkBucketa;
  }
  bucket = v1;
  checkBucket = v6;
  v36 = bptr;
  while ( 1 )
  {
    if ( i >= 8u )
    {
      bptr = *(runtime_bmap **)&bptr->tophash[v2->bucketsize - 4];
      i = 0;
      goto LABEL_64;
    }
    keysize = v2->keysize;
    v30 = (i + it->offset) & 7;
    v7 = (int *)&bptr[1].tophash[v30 * keysize];
    if ( !bptr->tophash[v30] || bptr->tophash[v30] == 1 )
      goto LABEL_3;
    v = (void **)&bptr[keysize + 1].tophash[v30 * v2->valuesize];
    if ( checkBucket != -1 && (v4->flags & 8) == 0 )
    {
      if ( v2->indirectkey )
        v8 = *v7;
      else
        v8 = (int)&bptr[1].tophash[v30 * keysize];
      if ( v2->reflexivekey )
        goto LABEL_12;
      if ( (*(unsigned __int8 (__golang **)(int, int))alg->equal)(v8, v8) )
      {
        v4 = h;
LABEL_12:
        if ( ((it->B < 0x20u ? (1 << it->B) + 1 : -1) & (*(int (__golang **)(int, uint32))alg->hash)(v8, v4->hash0)) != checkBucket )
        {
          v2 = t;
          v4 = h;
          goto LABEL_3;
        }
        goto LABEL_14;
      }
      if ( ((unsigned __int8)(it->B - 1) < 0x20u ? checkBucket >> (it->B - 1) : 0) != (v36->tophash[v30] & 1) )
      {
        v2 = t;
        v4 = h;
        goto LABEL_3;
      }
    }
LABEL_14:
    v9 = v36->tophash[v30];
    if ( v9 != 2 && v9 != 3 )
      break;
    v10 = t;
    if ( t->indirectkey )
      key = (uint8 *)*v7;
    else
      key = &bptr[1].tophash[v30 * keysize];
    if ( !t->reflexivekey )
    {
      if ( !(*(unsigned __int8 (__golang **)(uint8 *, uint8 *))alg->equal)(key, key) )
      {
        if ( *(_DWORD *)&runtime_writeBarrier.enabled )
          runtime_writebarrierptr((uintptr *)it, (uintptr)key);
        else
          it->key = key;
        if ( t->indirectvalue )
          v13 = *v;
        else
          v13 = v;
        if ( *(_DWORD *)&runtime_writeBarrier.enabled )
          runtime_writebarrierptr((uintptr *)&it->value, (uintptr)v13);
        else
          it->value = v13;
        goto LABEL_25;
      }
      v10 = t;
    }
    v26 = runtime_mapaccessK(v10, h, key);
    r4 = v26._r4;
    if ( v26._r3 )
    {
      if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      {
        runtime_writebarrierptr((uintptr *)it, (uintptr)v26._r3);
        r4 = v26._r4;
      }
      else
      {
        it->key = v26._r3;
      }
      if ( !*(_DWORD *)&runtime_writeBarrier.enabled )
      {
        it->value = r4;
        goto LABEL_25;
      }
      goto LABEL_30;
    }
    v2 = t;
    v4 = h;
LABEL_3:
    ++i;
    v6 = checkBucket;
    bptr = v36;
    v1 = bucket;
  }
  v14 = t;
  if ( t->indirectkey )
    v15 = (uint8 *)*v7;
  else
    v15 = &bptr[1].tophash[v30 * keysize];
  if ( *(_DWORD *)&runtime_writeBarrier.enabled )
  {
    runtime_writebarrierptr((uintptr *)it, (uintptr)v15);
    v14 = t;
  }
  else
  {
    it->key = v15;
  }
  if ( v14->indirectvalue )
    r4 = *v;
  else
    r4 = v;
  if ( *(_DWORD *)&runtime_writeBarrier.enabled )
  {
LABEL_30:
    runtime_writebarrierptr((uintptr *)&it->value, (uintptr)r4);
    goto LABEL_25;
  }
  it->value = r4;
LABEL_25:
  it->bucket = bucket;
  if ( it->bptr != v36 )
  {
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr((uintptr *)&it->bptr, (uintptr)v36);
    else
      it->bptr = v36;
  }
  it->i = i + 1;
  it->checkBucket = checkBucket;
}

//----- (080500F0) --------------------------------------------------------
void __golang runtime_makeBucketArray(runtime_maptype_0 *t, uint8 b, void *buckets, runtime_bmap *nextOverflow)
{
  int v4; // esi
  uintptr size; // edi
  unsigned int v6; // ebp
  unsigned int v7; // ecx
  unsigned int v8; // ecx
  unsigned int v9; // ecx
  __int32 n; // eax
  uintptr *v11; // ecx
  unsigned int v12; // ecx
  unsigned int v13; // ecx
  char *src; // [esp+8h] [ebp-14h]
  __int32 v15; // [esp+10h] [ebp-Ch]

  if ( b < 4u )
  {
    n = b < 0x20u ? 1 << b : 0;
  }
  else
  {
    v4 = (b < 0x20u ? 1 << b : 0) + ((unsigned __int8)(b - 4) < 0x20u ? 1 << (b - 4) : 0);
    size = t->bucket->size;
    v6 = v4 * size;
    if ( v4 * size >= 0x8000 )
    {
      if ( v6 + 0x2000 >= v6 )
        v9 = (v6 + 0x1FFF) & 0xFFFFE000;
      else
        v9 = v4 * size;
    }
    else if ( v6 > 0x3F8 )
    {
      v12 = (v6 - 897) >> 7;
      if ( v12 >= 0xF9 || (v13 = runtime_size_to_class128[v12], v13 >= 0x43) )
        runtime_panicindex();
      v9 = runtime_class_to_size[v13];
    }
    else
    {
      v7 = (v6 + 7) >> 3;
      if ( v7 >= 0x81 || (v8 = runtime_size_to_class8[v7], v8 >= 0x43) )
        runtime_panicindex();
      v9 = runtime_class_to_size[v8];
    }
    if ( v9 == v6 )
    {
      n = (b < 0x20u ? 1 << b : 0) + ((unsigned __int8)(b - 4) < 0x20u ? 1 << (b - 4) : 0);
    }
    else
    {
      if ( !size )
        runtime_panicdivide();
      n = v9 / size;
    }
  }
  v15 = n;
  src = (char *)runtime_newarray(t->bucket, n);
  if ( v15 != (b < 0x20u ? 1 << b : 0) )
  {
    v11 = (uintptr *)&src[t->bucketsize * (v15 - 1) - 4 + t->bucketsize];
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr(v11, (uintptr)src);
    else
      *v11 = (uintptr)src;
  }
}

//----- (080502B0) --------------------------------------------------------
void __golang runtime_hashGrow(runtime_maptype_0 *t, runtime_hmap *h)
{
  runtime_hmap *v2; // eax
  bool v3; // cl
  uintptr v4; // ebx
  uint8 v5; // bp
  runtime_hmap *v6; // eax
  uintptr *extra; // ecx
  uintptr v8; // ebp
  uintptr *v9; // ecx
  runtime_mapextra *v10; // eax
  float v11; // xmm0_4
  float v12; // xmm1_4
  uint64 y; // [esp+0h] [ebp-30h]
  string ya; // [esp+0h] [ebp-30h]
  runtime_mapextra *y_4; // [esp+4h] [ebp-2Ch]
  double v16; // [esp+8h] [ebp-28h]
  void *v17; // [esp+8h] [ebp-28h]
  uintptr v18; // [esp+Ch] [ebp-24h]
  char _r2; // [esp+12h] [ebp-1Eh]
  uint8 B; // [esp+13h] [ebp-1Dh]
  double v21; // [esp+14h] [ebp-1Ch]
  void *oldbuckets; // [esp+1Ch] [ebp-14h]
  uintptr *dst; // [esp+2Ch] [ebp-4h]

  v2 = h;
  if ( h->count >= 8u && h->count >= 0 || h->count >> 31 != -1 && h->count < 0 )
  {
    B = h->B;
    v21 = runtime_int64tofloat64(h->count);
    LODWORD(y) = B < 0x20u ? 1 << B : 0;
    HIDWORD(y) = ((unsigned __int8)(B - 32) < 0x20u ? 1 << (B - 32) : 0) | ((unsigned __int8)(32 - B) < 0x20u ? 1u >> (32 - B) : 0);
    v16 = runtime_uint64tofloat64(y);
    v11 = v21;
    v12 = v16;
    v3 = v11 >= (float)(6.5 * v12);
    v2 = h;
  }
  else
  {
    v3 = 0;
  }
  if ( !v3 )
    v2->flags |= 8u;
  _r2 = v3;
  oldbuckets = v2->buckets;
  runtime_makeBucketArray(t, v3 + v2->B, (void *)LODWORD(v16), (runtime_bmap *)HIDWORD(v16));
  v4 = v18;
  v5 = h->flags & 0xFC;
  v6 = h;
  if ( (h->flags & 1) != 0 )
    v5 |= 2u;
  h->B += _r2;
  h->flags = v5;
  if ( *(_DWORD *)&runtime_writeBarrier.enabled )
  {
    runtime_writebarrierptr((uintptr *)&h->oldbuckets, (uintptr)oldbuckets);
    runtime_writebarrierptr((uintptr *)&h->buckets, (uintptr)v17);
    v6 = h;
    v4 = v18;
  }
  else
  {
    h->oldbuckets = oldbuckets;
    h->buckets = v17;
  }
  v6->nevacuate = 0;
  v6->noverflow = 0;
  extra = (uintptr *)v6->extra;
  dst = (uintptr *)&v6->extra;
  if ( extra )
  {
    v8 = *extra;
    if ( *extra )
    {
      if ( extra[1] )
      {
        ya.str = (uint8 *)"overflow is not nil";
        ya.len = 19;
        runtime_throw(ya);
        BUG();
      }
      if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      {
        runtime_writebarrierptr(extra + 1, v8);
        v6 = h;
        v4 = v18;
      }
      else
      {
        extra[1] = v8;
      }
      v9 = (uintptr *)v6->extra;
      if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      {
        runtime_writebarrierptr(v9, 0);
        v6 = h;
        v4 = v18;
      }
      else
      {
        *v9 = 0;
      }
    }
  }
  if ( v4 )
  {
    if ( !v6->extra )
    {
      y_4 = (runtime_mapextra *)runtime_newobject((runtime__type_0 *)&stru_80D3C20);
      if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      {
        runtime_writebarrierptr(dst, (uintptr)y_4);
        v6 = h;
      }
      else
      {
        v6 = h;
        h->extra = y_4;
      }
      v4 = v18;
    }
    v10 = v6->extra;
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr((uintptr *)&v10->nextOverflow, v4);
    else
      v10->nextOverflow = (runtime_bmap *)v4;
  }
}
// 80502B0: could not find valid save-restore pair for ebx
// 8050328: variable 'v16' is possibly undefined
// 8050338: variable 'v18' is possibly undefined
// 8050384: variable 'v17' is possibly undefined

//----- (08050590) --------------------------------------------------------
void __golang runtime_growWork(runtime_maptype_0 *t, runtime_hmap *h, uintptr bucket)
{
  uint8 B; // dl

  B = h->B;
  if ( (h->flags & 8) == 0 )
    --B;
  runtime_evacuate(t, h, bucket & (B < 0x20u ? (1 << B) + 1 : -1));
  if ( h->oldbuckets )
    runtime_evacuate(t, h, h->nevacuate);
}

//----- (08050620) --------------------------------------------------------
void __golang runtime_evacuate(runtime_maptype_0 *t, runtime_hmap *h, uintptr oldbucket)
{
  runtime_maptype_0 *v3; // esi
  int bucketsize; // edx
  _BYTE *v5; // ebx
  uint8 v6; // bp
  uint8 flags; // di
  unsigned int v8; // edi
  runtime_hmap *v9; // eax
  unsigned int v10; // ecx
  uintptr nevacuate; // edx
  runtime_mapextra *extra; // ecx
  char *buckets; // ecx
  int keysize; // ebp
  runtime_bmap *v15; // ebx
  uintptr *v16; // esi
  runtime_bmap *v17; // eax
  int v18; // ecx
  uintptr *tophash; // edx
  int v20; // ebp
  int j; // edi
  _DWORD *v22; // eax
  int v23; // ebp
  int v24; // ebp
  uint8 v25; // al
  __int32 v26; // eax
  _DWORD *v27; // ecx
  bool v28; // cl
  unsigned int v29; // ecx
  runtime_maptype_0 *v30; // eax
  uintptr *v31; // ebp
  uintptr src; // ebx
  __int32 v33; // ecx
  uintptr *v34; // ebx
  uintptr *v35; // ebp
  unsigned int v36; // edi
  int v37; // esi
  unsigned int v38; // ecx
  runtime_maptype_0 *v39; // eax
  uintptr *v40; // edi
  uintptr v41; // ebp
  char *v42; // ebx
  unsigned int v43; // eax
  uint8 v44; // dl
  unsigned int v45; // eax
  unsigned int v46; // ebx
  unsigned int v47; // eax
  string dst; // [esp+0h] [ebp-9Ch]
  unsigned int b; // [esp+8h] [ebp-94h]
  runtime_bmap *v50; // [esp+Ch] [ebp-90h]
  uint8 top; // [esp+11h] [ebp-8Bh]
  uint8 v52; // [esp+12h] [ebp-8Ah]
  uint8 v53; // [esp+13h] [ebp-89h]
  __int32 yi; // [esp+14h] [ebp-88h]
  __int32 yia; // [esp+14h] [ebp-88h]
  __int32 xi; // [esp+18h] [ebp-84h]
  __int32 xia; // [esp+18h] [ebp-84h]
  uintptr x; // [esp+1Ch] [ebp-80h]
  uintptr stop; // [esp+20h] [ebp-7Ch]
  __int32 i; // [esp+24h] [ebp-78h]
  uintptr *yv; // [esp+48h] [ebp-54h]
  void *yk; // [esp+4Ch] [ebp-50h]
  runtime_bmap *y; // [esp+50h] [ebp-4Ch]
  uintptr *xv; // [esp+54h] [ebp-48h]
  uintptr *xk; // [esp+58h] [ebp-44h]
  runtime_bmap *x_0; // [esp+5Ch] [ebp-40h]
  runtime_bmap *p_0; // [esp+64h] [ebp-38h]
  uintptr *p_1; // [esp+68h] [ebp-34h]
  _DWORD *p_2; // [esp+6Ch] [ebp-30h]
  uintptr *p_3; // [esp+70h] [ebp-2Ch]
  uintptr *p_4; // [esp+74h] [ebp-28h]
  uintptr *p_5; // [esp+78h] [ebp-24h]
  uintptr *p_6; // [esp+7Ch] [ebp-20h]
  void *k2_0; // [esp+80h] [ebp-1Ch] BYREF
  runtime_typeAlg *alg; // [esp+84h] [ebp-18h]
  runtime_bmap *v76; // [esp+88h] [ebp-14h]
  void *v77; // [esp+8Ch] [ebp-10h]
  int v78; // [esp+90h] [ebp-Ch]
  _BYTE *v79; // [esp+94h] [ebp-8h]
  uintptr *p_oldbuckets; // [esp+98h] [ebp-4h]

  while ( (unsigned int)&k2_0 <= *(_DWORD *)(*(_DWORD *)(__readgsdword(0) - 4) + 8) )
    runtime_morestack_noctxt();
  v3 = t;
  bucketsize = t->bucketsize;
  x = oldbucket * bucketsize;
  v5 = (char *)h->oldbuckets + oldbucket * bucketsize;
  v6 = h->B;
  flags = h->flags;
  if ( (flags & 8) == 0 )
    --v6;
  p_oldbuckets = (uintptr *)&h->oldbuckets;
  v53 = flags;
  alg = t->key->alg;
  v8 = v6 < 0x20u ? 1 << v6 : 0;
  v9 = h;
  if ( (unsigned __int8)(*v5 - 1) >= 3u )
  {
    v79 = v5;
    buckets = (char *)h->buckets;
    keysize = t->keysize;
    v15 = (runtime_bmap *)&buckets[x];
    p_5 = (uintptr *)&buckets[x + 8];
    v16 = (uintptr *)&buckets[8 * keysize + 8 + x];
    if ( (v53 & 8) != 0 )
    {
      v17 = 0;
      v18 = 0;
      tophash = 0;
    }
    else
    {
      p_0 = (runtime_bmap *)&buckets[bucketsize * (v8 + oldbucket)];
      v18 = (int)&p_0[1];
      tophash = (uintptr *)p_0[keysize + 1].tophash;
      v17 = p_0;
    }
    stop = v8;
    xi = 0;
    xk = p_5;
    yi = 0;
    v20 = (int)v79;
LABEL_82:
    if ( !v20 )
    {
      v9 = h;
      if ( (h->flags & 2) == 0 )
      {
        if ( (t->bucket->kind & 0x80u) != 0 )
          runtime_memclrNoHeapPointers();
        else
          runtime_memclrHasPointers((char *)h->oldbuckets + oldbucket * t->bucketsize + 8, t->bucketsize - 8);
        v9 = h;
        v8 = stop;
      }
      v3 = t;
      goto LABEL_5;
    }
    v78 = v20;
    y = v17;
    v22 = (_DWORD *)(v20 + 8);
    v23 = v20 + 8 * t->keysize + 8;
    for ( j = 0; ; ++j )
    {
      if ( j >= 8 )
      {
        v20 = *(_DWORD *)(v78 + t->bucketsize - 4);
        v8 = stop;
        v17 = y;
        goto LABEL_82;
      }
      if ( (unsigned int)j >= 8 )
        runtime_panicindex();
      p_6 = (uintptr *)v23;
      p_2 = v22;
      v24 = v78;
      v25 = *(_BYTE *)(v78 + j);
      if ( !v25 )
      {
        *(_BYTE *)(v78 + j) = 1;
        v26 = xi;
        goto LABEL_25;
      }
      if ( v25 < 4u )
      {
        dst.str = (uint8 *)"bad map state";
        dst.len = 13;
        runtime_throw(dst);
        BUG();
      }
      v77 = (void *)v18;
      v27 = t->indirectkey ? (_DWORD *)*p_2 : p_2;
      i = j;
      yv = tophash;
      k2_0 = v27;
      xv = v16;
      x_0 = v15;
      if ( (h->flags & 8) == 0 )
        break;
      v28 = 1;
LABEL_35:
      top = v25;
      if ( v28 )
      {
        *(_BYTE *)(v24 + j) = 2;
        v29 = xi;
        if ( xi == 8 )
        {
          v15 = runtime___ptr_hmap__newoverflow(h, t, v15);
          v16 = (uintptr *)v15[t->keysize + 1].tophash;
          v25 = top;
          tophash = yv;
          v29 = 0;
          p_4 = (uintptr *)v15[1].tophash;
        }
        else
        {
          p_4 = xk;
        }
        if ( v29 >= 8 )
          runtime_panicindex();
        v76 = v15;
        xia = v29;
        v15->tophash[v29] = v25;
        v30 = t;
        if ( t->indirectkey )
        {
          v31 = p_4;
          if ( *(_DWORD *)&runtime_writeBarrier.enabled )
          {
            runtime_writebarrierptr(p_4, (uintptr)k2_0);
            v30 = t;
            v29 = xia;
            tophash = yv;
            v31 = p_4;
          }
          else
          {
            *p_4 = (uintptr)k2_0;
          }
        }
        else
        {
          runtime_typedmemmove(t->key, p_4, p_2);
          v30 = t;
          v29 = xia;
          tophash = yv;
          v31 = p_4;
        }
        if ( v30->indirectvalue )
        {
          src = *p_6;
          if ( *(_DWORD *)&runtime_writeBarrier.enabled )
          {
            runtime_writebarrierptr(v16, src);
            v30 = t;
            v29 = xia;
            tophash = yv;
            v31 = p_4;
          }
          else
          {
            *v16 = src;
          }
        }
        else
        {
          runtime_typedmemmove(v30->elem, v16, p_6);
          v30 = t;
          v29 = xia;
          tophash = yv;
          v31 = p_4;
        }
        v33 = v29 + 1;
        v34 = (uintptr *)((char *)v31 + v30->keysize);
        v35 = (uintptr *)((char *)v16 + v30->valuesize);
        v36 = yi;
        yk = v77;
        v37 = (int)v76;
      }
      else
      {
        *(_BYTE *)(v24 + j) = 3;
        v38 = yi;
        if ( yi == 8 )
        {
          v50 = runtime___ptr_hmap__newoverflow(h, t, y);
          tophash = (uintptr *)v50[t->keysize + 1].tophash;
          y = v50;
          v38 = 0;
          p_1 = (uintptr *)v50[1].tophash;
          v25 = top;
        }
        else
        {
          p_1 = (uintptr *)v77;
        }
        if ( v38 >= 8 )
          runtime_panicindex();
        yia = v38;
        p_3 = tophash;
        y->tophash[v38] = v25;
        v39 = t;
        if ( t->indirectkey )
        {
          v40 = p_1;
          if ( *(_DWORD *)&runtime_writeBarrier.enabled )
          {
            runtime_writebarrierptr(p_1, (uintptr)k2_0);
            v39 = t;
            v38 = yia;
            tophash = p_3;
            v40 = p_1;
          }
          else
          {
            *p_1 = (uintptr)k2_0;
          }
        }
        else
        {
          runtime_typedmemmove(t->key, p_1, p_2);
          v39 = t;
          v38 = yia;
          tophash = p_3;
          v40 = p_1;
        }
        if ( v39->indirectvalue )
        {
          v41 = *p_6;
          if ( *(_DWORD *)&runtime_writeBarrier.enabled )
          {
            runtime_writebarrierptr(tophash, v41);
            v39 = t;
            v38 = yia;
            tophash = p_3;
            v40 = p_1;
          }
          else
          {
            *tophash = v41;
          }
        }
        else
        {
          runtime_typedmemmove(v39->elem, tophash, p_6);
          v39 = t;
          v38 = yia;
          tophash = p_3;
          v40 = p_1;
        }
        v42 = (char *)v40 + v39->keysize;
        tophash = (uintptr *)((char *)tophash + v39->valuesize);
        v37 = (int)x_0;
        v35 = xv;
        v36 = v38 + 1;
        yk = v42;
        v33 = xi;
        v34 = xk;
      }
      v26 = v33;
      xk = v34;
      yi = v36;
      v18 = (int)yk;
      j = i;
      v15 = (runtime_bmap *)v37;
      v16 = v35;
LABEL_25:
      xi = v26;
      v22 = (_DWORD *)((char *)p_2 + t->keysize);
      v23 = (int)p_6 + t->valuesize;
    }
    v52 = v25;
    b = (*(int (__golang **)(void *, uint32))alg->hash)(k2_0, h->hash0);
    v43 = b;
    if ( (h->flags & 1) != 0 )
    {
      v43 = b;
      if ( !t->reflexivekey )
      {
        if ( !(*(unsigned __int8 (__golang **)(void *, void *))alg->equal)(k2_0, k2_0) )
        {
          if ( (v52 & 1) != 0 )
            v45 = stop | b;
          else
            v45 = b & ~stop;
          v46 = v45;
          v47 = HIBYTE(v45);
          if ( (unsigned __int8)v47 < 4u )
            LOBYTE(v47) = v47 + 4;
          v44 = v47;
          v43 = v46;
          goto LABEL_70;
        }
        v43 = b;
      }
      v44 = v52;
    }
    else
    {
      v44 = v52;
    }
LABEL_70:
    v15 = x_0;
    v24 = v78;
    v28 = (v43 & stop) == 0;
    v25 = v44;
    tophash = yv;
    goto LABEL_35;
  }
LABEL_5:
  if ( oldbucket == v9->nevacuate )
  {
    v9->nevacuate = oldbucket + 1;
    v10 = v8;
    if ( oldbucket + 1025 <= v8 )
      v8 = oldbucket + 1025;
    while ( 1 )
    {
      nevacuate = v9->nevacuate;
      if ( nevacuate == v8 || (unsigned __int8)(*((_BYTE *)v9->oldbuckets + nevacuate * v3->bucketsize) - 1) >= 3u )
        break;
      v9->nevacuate = nevacuate + 1;
    }
    if ( v10 == nevacuate )
    {
      if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      {
        runtime_writebarrierptr(p_oldbuckets, 0);
        v9 = h;
      }
      else
      {
        v9->oldbuckets = 0;
      }
      extra = v9->extra;
      if ( extra )
      {
        if ( *(_DWORD *)&runtime_writeBarrier.enabled )
        {
          runtime_writebarrierptr((uintptr *)&extra->overflow[1], 0);
          v9 = h;
        }
        else
        {
          extra->overflow[1] = 0;
        }
      }
      v9->flags &= ~8u;
    }
  }
}

//----- (08050EF0) --------------------------------------------------------
void *__golang reflect_mapaccess(runtime_maptype_0 *t, runtime_hmap *h, void *key)
{
  void *r3; // eax
  retval_804ED80 v4; // [esp+Ch] [ebp-8h]

  v4 = runtime_mapaccess2(t, h, key);
  r3 = v4._r3;
  if ( !v4._r4 )
    return 0;
  return r3;
}

//----- (08050F50) --------------------------------------------------------
runtime_hiter *__golang reflect_mapiterinit(runtime_maptype_0 *t, runtime_hmap *h)
{
  runtime_hiter *it; // [esp+Ch] [ebp-4h]

  it = (runtime_hiter *)runtime_newobject((runtime__type_0 *)&stru_80DB6A0);
  runtime_mapiterinit(t, h, it);
  return it;
}

//----- (08050FB0) --------------------------------------------------------
void __golang reflect_mapiternext(runtime_hiter *it)
{
  runtime_mapiternext(it);
}

//----- (08050FE0) --------------------------------------------------------
void *__golang reflect_mapiterkey(runtime_hiter *it)
{
  return it->key;
}

//----- (08051010) --------------------------------------------------------
__int32 __golang reflect_maplen(runtime_hmap *h)
{
  if ( h )
    return h->count;
  else
    return 0;
}

//----- (08051050) --------------------------------------------------------
void *__golang runtime_mapaccess1_fast32(runtime_maptype_0 *t, runtime_hmap *h, uint32 key)
{
  _DWORD *buckets; // eax
  unsigned int i; // ecx
  unsigned int v5; // esi
  int bucketsize; // eax
  _BYTE *oldbuckets; // edi
  char *v8; // ecx
  int v9; // esi
  string s; // [esp+0h] [ebp-Ch]
  int v11; // [esp+8h] [ebp-4h]

  if ( !h || !h->count )
    return runtime_zeroVal;
  if ( (h->flags & 4) != 0 )
  {
    s.str = (uint8 *)"concurrent map read and map write";
    s.len = 33;
    runtime_throw(s);
    BUG();
  }
  if ( h->B )
  {
    v11 = (*(int (__golang **)(uint32 *, uint32))t->key->alg->hash)(&key, h->hash0);
    v5 = h->B < 0x20u ? (1 << h->B) + 1 : -1;
    bucketsize = t->bucketsize;
    oldbuckets = h->oldbuckets;
    v8 = (char *)h->buckets + bucketsize * (v11 & v5);
    if ( oldbuckets )
    {
      if ( (h->flags & 8) == 0 )
        v5 >>= 1;
      v9 = bucketsize * (v11 & v5);
      if ( (unsigned __int8)(oldbuckets[v9] - 1) >= 3u )
        v8 = &oldbuckets[v9];
    }
    buckets = v8;
  }
  else
  {
    buckets = h->buckets;
  }
  do
  {
    for ( i = 0; i < 8; ++i )
    {
      if ( buckets[i + 2] == key && *((_BYTE *)buckets + i) )
        return (char *)buckets + t->valuesize * i + 40;
    }
    buckets = *(_DWORD **)((char *)buckets + t->bucketsize - 4);
  }
  while ( buckets );
  return runtime_zeroVal;
}

//----- (080511B0) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
retval_80511B0 __golang runtime_mapaccess2_fast32(runtime_maptype_0 *t, runtime_hmap *h, uint32 key)
{
  _DWORD *buckets; // eax
  unsigned int i; // ecx
  unsigned int v5; // esi
  int bucketsize; // eax
  _BYTE *oldbuckets; // edi
  char *v8; // ecx
  int v9; // esi
  string s; // [esp+0h] [ebp-Ch]
  int v11; // [esp+8h] [ebp-4h]
  retval_80511B0 _r3; // [esp+1Ch] [ebp+10h] OVERLAPPED

  if ( h && h->count )
  {
    if ( (h->flags & 4) != 0 )
    {
      s.str = (uint8 *)"concurrent map read and map write";
      s.len = 33;
      runtime_throw(s);
      BUG();
    }
    if ( h->B )
    {
      v11 = (*(int (__golang **)(uint32 *, uint32))t->key->alg->hash)(&key, h->hash0);
      v5 = h->B < 0x20u ? (1 << h->B) + 1 : -1;
      bucketsize = t->bucketsize;
      oldbuckets = h->oldbuckets;
      v8 = (char *)h->buckets + bucketsize * (v11 & v5);
      if ( oldbuckets )
      {
        if ( (h->flags & 8) == 0 )
          v5 >>= 1;
        v9 = bucketsize * (v11 & v5);
        if ( (unsigned __int8)(oldbuckets[v9] - 1) >= 3u )
          v8 = &oldbuckets[v9];
      }
      buckets = v8;
    }
    else
    {
      buckets = h->buckets;
    }
    do
    {
      for ( i = 0; i < 8; ++i )
      {
        if ( buckets[i + 2] == key && *((_BYTE *)buckets + i) )
        {
          _r3._r3 = (char *)buckets + t->valuesize * i + 40;
          _r3._r4 = 1;
          return _r3;
        }
      }
      buckets = *(_DWORD **)((char *)buckets + t->bucketsize - 4);
    }
    while ( buckets );
    _r3._r3 = runtime_zeroVal;
    _r3._r4 = 0;
  }
  else
  {
    _r3._r3 = runtime_zeroVal;
    _r3._r4 = 0;
  }
  return _r3;
}
// 80511B0: variables would overlap: ^1C.8 and stkvar "_r3" ^1C.4(has user info),stkvar "_r4" ^20.1(has user info)

//----- (08051320) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
retval_8051320 __golang runtime_mapaccess2_fast64(runtime_maptype_0 *t, runtime_hmap *h, uint64 key)
{
  _DWORD *buckets; // eax
  unsigned int i; // ecx
  unsigned int v5; // esi
  int bucketsize; // eax
  _BYTE *oldbuckets; // edi
  char *v8; // ecx
  int v9; // esi
  string s; // [esp+0h] [ebp-Ch]
  int v11; // [esp+8h] [ebp-4h]
  retval_8051320 _r3; // [esp+20h] [ebp+14h] OVERLAPPED

  if ( h && h->count )
  {
    if ( (h->flags & 4) != 0 )
    {
      s.str = (uint8 *)"concurrent map read and map write";
      s.len = 33;
      runtime_throw(s);
      BUG();
    }
    if ( h->B )
    {
      v11 = (*(int (__golang **)(uint64 *, uint32))t->key->alg->hash)(&key, h->hash0);
      v5 = h->B < 0x20u ? (1 << h->B) + 1 : -1;
      bucketsize = t->bucketsize;
      oldbuckets = h->oldbuckets;
      v8 = (char *)h->buckets + bucketsize * (v11 & v5);
      if ( oldbuckets )
      {
        if ( (h->flags & 8) == 0 )
          v5 >>= 1;
        v9 = bucketsize * (v11 & v5);
        if ( (unsigned __int8)(oldbuckets[v9] - 1) >= 3u )
          v8 = &oldbuckets[v9];
      }
      buckets = v8;
    }
    else
    {
      buckets = h->buckets;
    }
    do
    {
      for ( i = 0; i < 8; ++i )
      {
        if ( buckets[2 * i + 2] == (_DWORD)key && buckets[2 * i + 3] == HIDWORD(key) && *((_BYTE *)buckets + i) )
        {
          _r3._r3 = (char *)buckets + t->valuesize * i + 72;
          _r3._r4 = 1;
          return _r3;
        }
      }
      buckets = *(_DWORD **)((char *)buckets + t->bucketsize - 4);
    }
    while ( buckets );
    _r3._r3 = runtime_zeroVal;
    _r3._r4 = 0;
  }
  else
  {
    _r3._r3 = runtime_zeroVal;
    _r3._r4 = 0;
  }
  return _r3;
}
// 8051320: variables would overlap: ^20.8 and stkvar "_r3" ^20.4(has user info),stkvar "_r4" ^24.1(has user info)

//----- (080514B0) --------------------------------------------------------
void *__golang runtime_mapassign_fast32(runtime_maptype_0 *t, runtime_hmap *h, uint32 key)
{
  unsigned int v3; // eax
  runtime_hmap *v4; // ecx
  runtime_hmap *v5; // ebx
  int bucketsize; // edi
  int v7; // ebx
  int v8; // edi
  runtime_bmap *v9; // ecx
  runtime_maptype_0 *v10; // ebp
  runtime_bmap *v11; // eax
  uint8 flags; // dl
  int v13; // edx
  bool v14; // al
  uint8 v15; // cl
  int v16; // edx
  unsigned int v17; // eax
  uint16 noverflow; // ax
  uint8 v19; // dl
  runtime_bmap *v20; // ebp
  bool v21; // al
  runtime_bmap *v22; // eax
  runtime_bmap *v23; // ecx
  float v24; // xmm0_4
  float v25; // xmm1_4
  uint64 y; // [esp+0h] [ebp-60h]
  string ya; // [esp+0h] [ebp-60h]
  string yb; // [esp+0h] [ebp-60h]
  int64 yc; // [esp+0h] [ebp-60h]
  void *src; // [esp+8h] [ebp-58h]
  uint8 top; // [esp+12h] [ebp-4Eh]
  uint8 B; // [esp+13h] [ebp-4Dh]
  uintptr i; // [esp+14h] [ebp-4Ch]
  uintptr hash; // [esp+18h] [ebp-48h]
  int bucket; // [esp+1Ch] [ebp-44h]
  double v36; // [esp+40h] [ebp-20h]
  runtime_bmap *val; // [esp+48h] [ebp-18h]
  runtime_bmap *vala; // [esp+48h] [ebp-18h]
  runtime_bmap *insertk; // [esp+4Ch] [ebp-14h]
  uint8 *inserti; // [esp+50h] [ebp-10h]
  runtime_bmap *b; // [esp+58h] [ebp-8h]

  if ( !h )
  {
    LODWORD(yc) = &e;
    HIDWORD(yc) = &runtime_statictmp_10;
    runtime_gopanic((interface_{})yc);
    BUG();
  }
  if ( (h->flags & 4) != 0 )
  {
    yb.str = (uint8 *)"concurrent map writes";
    yb.len = 21;
    runtime_throw(yb);
    BUG();
  }
  v3 = (*(int (__golang **)(uint32 *, uint32))t->key->alg->hash)(&key, h->hash0);
  hash = v3;
  v4 = h;
  h->flags |= 4u;
  if ( !h->buckets )
  {
    src = runtime_newarray(t->bucket, 1);
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr((uintptr *)&h->buckets, (uintptr)src);
    else
      h->buckets = src;
    v3 = hash;
    v4 = h;
  }
  while ( 1 )
  {
    v5 = v4;
    v15 = v4->B;
    v16 = v3 & (v15 < 0x20u ? (1 << v15) + 1 : -1);
    if ( v5->oldbuckets )
    {
      bucket = v3 & (v15 < 0x20u ? (1 << v15) + 1 : -1);
      runtime_growWork(t, v5, v16);
      v3 = hash;
      v16 = bucket;
      v5 = h;
    }
    v10 = t;
    bucketsize = t->bucketsize;
    v13 = (int)v5->buckets + bucketsize * v16;
    v17 = HIBYTE(v3);
    if ( (unsigned __int8)v17 < 4u )
      LOBYTE(v17) = v17 + 4;
    v9 = 0;
    insertk = 0;
    val = 0;
    while ( 1 )
    {
      i = 0;
      while ( i < 8 )
      {
        if ( (_BYTE)v17 == *(_BYTE *)(v13 + i) )
        {
          if ( *(_DWORD *)(v13 + 4 * i + 8) == key )
          {
            v11 = (runtime_bmap *)(v10->valuesize * i + v13 + 40);
            goto LABEL_16;
          }
          v7 = (int)insertk;
          v8 = (int)val;
        }
        else if ( *(_BYTE *)(v13 + i) )
        {
          v7 = (int)insertk;
          v8 = (int)val;
        }
        else if ( v9 )
        {
          v7 = (int)insertk;
          v8 = (int)val;
        }
        else
        {
          v8 = i * v10->valuesize + v13 + 40;
          v9 = (runtime_bmap *)(v13 + i);
          v7 = v13 + 4 * i + 8;
          v10 = t;
        }
        ++i;
        insertk = (runtime_bmap *)v7;
        val = (runtime_bmap *)v8;
        v5 = h;
        bucketsize = t->bucketsize;
      }
      if ( !*(_DWORD *)(v13 + bucketsize - 4) )
        break;
      v13 = *(_DWORD *)(v13 + bucketsize - 4);
    }
    top = v17;
    b = (runtime_bmap *)v13;
    if ( v5->oldbuckets )
      break;
    if ( v5->count >= 8u && v5->count >= 0 || v5->count >> 31 != -1 && v5->count < 0 )
    {
      B = v5->B;
      inserti = (uint8 *)v9;
      v36 = runtime_int64tofloat64(v5->count);
      LODWORD(y) = B < 0x20u ? 1 << B : 0;
      HIDWORD(y) = ((unsigned __int8)(B - 32) < 0x20u ? 1 << (B - 32) : 0) | ((unsigned __int8)(32 - B) < 0x20u ? 1u >> (32 - B) : 0);
      v24 = v36;
      v25 = runtime_uint64tofloat64(y);
      v14 = v24 >= (float)(6.5 * v25);
      v9 = (runtime_bmap *)inserti;
      v5 = h;
    }
    else
    {
      v14 = 0;
    }
    if ( !v14 )
    {
      noverflow = v5->noverflow;
      v19 = v5->B;
      if ( v19 >= 0x10u )
      {
        v21 = noverflow >= 0x8000u;
        v20 = v9;
      }
      else
      {
        v20 = v9;
        v21 = noverflow >= (unsigned int)(v19 < 0x20u ? 1 << v19 : 0);
      }
      if ( !v21 )
        goto LABEL_34;
    }
    runtime_hashGrow(t, v5);
    v3 = hash;
    v4 = h;
  }
  v20 = v9;
LABEL_34:
  if ( v20 )
  {
    v22 = insertk;
    v23 = val;
  }
  else
  {
    v20 = runtime___ptr_hmap__newoverflow(v5, t, b);
    v22 = v20 + 1;
    v23 = v20 + 5;
  }
  vala = v23;
  runtime_typedmemmove(t->key, v22, &key);
  v20->tophash[0] = top;
  ++h->count;
  v11 = vala;
LABEL_16:
  flags = h->flags;
  if ( (flags & 4) == 0 )
  {
    ya.str = (uint8 *)"concurrent map writes";
    ya.len = 21;
    runtime_throw(ya);
    BUG();
  }
  h->flags = flags & 0xFB;
  return v11;
}

//----- (08051910) --------------------------------------------------------
void *__golang runtime_mapassign_fast64(runtime_maptype_0 *t, runtime_hmap *h, uint64 key)
{
  unsigned int v3; // eax
  runtime_hmap *v4; // ecx
  runtime_hmap *v5; // ebx
  int bucketsize; // edi
  int v7; // ebx
  int v8; // edi
  runtime_bmap *v9; // ecx
  runtime_maptype_0 *v10; // ebp
  unsigned int v11; // eax
  runtime_bmap *v12; // eax
  uint8 flags; // dl
  int v14; // edx
  bool v15; // al
  uint8 v16; // cl
  int v17; // edx
  uint16 noverflow; // ax
  uint8 v19; // dl
  runtime_bmap *v20; // ebp
  bool v21; // al
  runtime_bmap *v22; // eax
  runtime_bmap *v23; // ecx
  float v24; // xmm0_4
  float v25; // xmm1_4
  uint64 y; // [esp+0h] [ebp-60h]
  string ya; // [esp+0h] [ebp-60h]
  string yb; // [esp+0h] [ebp-60h]
  int64 yc; // [esp+0h] [ebp-60h]
  void *src; // [esp+8h] [ebp-58h]
  uint8 top; // [esp+12h] [ebp-4Eh]
  uint8 B; // [esp+13h] [ebp-4Dh]
  uintptr i; // [esp+14h] [ebp-4Ch]
  uintptr hash; // [esp+18h] [ebp-48h]
  int bucket; // [esp+1Ch] [ebp-44h]
  double v36; // [esp+38h] [ebp-28h]
  runtime_bmap *val; // [esp+48h] [ebp-18h]
  runtime_bmap *vala; // [esp+48h] [ebp-18h]
  runtime_bmap *insertk; // [esp+4Ch] [ebp-14h]
  uint8 *inserti; // [esp+50h] [ebp-10h]
  runtime_bmap *b; // [esp+58h] [ebp-8h]

  if ( !h )
  {
    LODWORD(yc) = &e;
    HIDWORD(yc) = &runtime_statictmp_11;
    runtime_gopanic((interface_{})yc);
    BUG();
  }
  if ( (h->flags & 4) != 0 )
  {
    yb.str = (uint8 *)"concurrent map writes";
    yb.len = 21;
    runtime_throw(yb);
    BUG();
  }
  v3 = (*(int (__golang **)(uint64 *, uint32))t->key->alg->hash)(&key, h->hash0);
  hash = v3;
  v4 = h;
  h->flags |= 4u;
  if ( !h->buckets )
  {
    src = runtime_newarray(t->bucket, 1);
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr((uintptr *)&h->buckets, (uintptr)src);
    else
      h->buckets = src;
    v3 = hash;
    v4 = h;
  }
  while ( 1 )
  {
    v5 = v4;
    v16 = v4->B;
    v17 = v3 & (v16 < 0x20u ? (1 << v16) + 1 : -1);
    if ( v5->oldbuckets )
    {
      bucket = v3 & (v16 < 0x20u ? (1 << v16) + 1 : -1);
      runtime_growWork(t, v5, v17);
      v3 = hash;
      v17 = bucket;
      v5 = h;
    }
    v10 = t;
    bucketsize = t->bucketsize;
    v14 = (int)v5->buckets + bucketsize * v17;
    v11 = HIBYTE(v3);
    if ( (unsigned __int8)v11 < 4u )
      LOBYTE(v11) = v11 + 4;
    top = v11;
    v9 = 0;
    insertk = 0;
    val = 0;
    while ( 1 )
    {
      i = 0;
      while ( i < 8 )
      {
        if ( (_BYTE)v11 == *(_BYTE *)(v14 + i) )
        {
          if ( *(_DWORD *)(v14 + 8 * i + 8) == (_DWORD)key && *(_DWORD *)(v14 + 8 * i + 12) == HIDWORD(key) )
          {
            v12 = (runtime_bmap *)(t->valuesize * i + v14 + 72);
            goto LABEL_16;
          }
          LOBYTE(v11) = top;
          v10 = t;
          v7 = (int)insertk;
          v8 = (int)val;
        }
        else if ( *(_BYTE *)(v14 + i) )
        {
          v7 = (int)insertk;
          v8 = (int)val;
        }
        else if ( v9 )
        {
          v7 = (int)insertk;
          v8 = (int)val;
        }
        else
        {
          v8 = i * v10->valuesize + v14 + 72;
          v9 = (runtime_bmap *)(v14 + i);
          v7 = v14 + 8 * i + 8;
          v10 = t;
        }
        ++i;
        insertk = (runtime_bmap *)v7;
        val = (runtime_bmap *)v8;
        v5 = h;
        bucketsize = t->bucketsize;
      }
      if ( !*(_DWORD *)(v14 + bucketsize - 4) )
        break;
      v14 = *(_DWORD *)(v14 + bucketsize - 4);
    }
    b = (runtime_bmap *)v14;
    if ( v5->oldbuckets )
      break;
    if ( v5->count >> 31 != -1 && v5->count < 0 || v5->count >= 8u && v5->count >= 0 )
    {
      B = v5->B;
      inserti = (uint8 *)v9;
      v36 = runtime_int64tofloat64(v5->count);
      LODWORD(y) = B < 0x20u ? 1 << B : 0;
      HIDWORD(y) = ((unsigned __int8)(B - 32) < 0x20u ? 1 << (B - 32) : 0) | ((unsigned __int8)(32 - B) < 0x20u ? 1u >> (32 - B) : 0);
      v24 = v36;
      v25 = runtime_uint64tofloat64(y);
      v15 = v24 >= (float)(6.5 * v25);
      v9 = (runtime_bmap *)inserti;
      v5 = h;
    }
    else
    {
      v15 = 0;
    }
    if ( !v15 )
    {
      noverflow = v5->noverflow;
      v19 = v5->B;
      if ( v19 >= 0x10u )
      {
        v21 = noverflow >= 0x8000u;
        v20 = v9;
      }
      else
      {
        v20 = v9;
        v21 = noverflow >= (unsigned int)(v19 < 0x20u ? 1 << v19 : 0);
      }
      if ( !v21 )
        goto LABEL_34;
    }
    runtime_hashGrow(t, v5);
    v3 = hash;
    v4 = h;
  }
  v20 = v9;
LABEL_34:
  if ( v20 )
  {
    v22 = insertk;
    v23 = val;
  }
  else
  {
    v20 = runtime___ptr_hmap__newoverflow(v5, t, b);
    v22 = v20 + 1;
    v23 = v20 + 9;
  }
  vala = v23;
  runtime_typedmemmove(t->key, v22, &key);
  v20->tophash[0] = top;
  ++h->count;
  v12 = vala;
LABEL_16:
  flags = h->flags;
  if ( (flags & 4) == 0 )
  {
    ya.str = (uint8 *)"concurrent map writes";
    ya.len = 21;
    runtime_throw(ya);
    BUG();
  }
  h->flags = flags & 0xFB;
  return v12;
}

//----- (08051D90) --------------------------------------------------------
void *__golang runtime_mapassign_faststr(runtime_maptype_0 *t, runtime_hmap *h, string ky)
{
  unsigned int v3; // eax
  runtime_hmap *v4; // ecx
  uintptr *v5; // esi
  uintptr v6; // ebp
  char v7; // bl
  int v8; // ebx
  runtime_bmap *v9; // ecx
  int keysize; // edi
  int v11; // edi
  unsigned int v12; // eax
  int v13; // edx
  uint8 *v14; // eax
  uint8 flags; // dl
  runtime_hmap *v16; // edx
  bool v17; // al
  runtime_hmap *v18; // ebx
  uint8 v19; // cl
  int v20; // edx
  uint16 noverflow; // ax
  uint8 v22; // bl
  runtime_bmap *v23; // ebp
  bool v24; // al
  uintptr *tophash; // eax
  uint8 *str; // ebx
  float v27; // xmm0_4
  float v28; // xmm1_4
  uint64 y; // [esp+0h] [ebp-54h]
  string ya; // [esp+0h] [ebp-54h]
  string yb; // [esp+0h] [ebp-54h]
  int64 yc; // [esp+0h] [ebp-54h]
  double b; // [esp+8h] [ebp-4Ch]
  runtime_bmap *ba; // [esp+8h] [ebp-4Ch]
  uint8 top; // [esp+12h] [ebp-42h]
  uint8 B; // [esp+13h] [ebp-41h]
  uintptr i; // [esp+14h] [ebp-40h]
  uintptr hash; // [esp+18h] [ebp-3Ch]
  int bucket; // [esp+1Ch] [ebp-38h]
  double v40; // [esp+30h] [ebp-24h]
  uint8 *inserti; // [esp+40h] [ebp-14h]
  runtime_bmap *v42; // [esp+44h] [ebp-10h]

  if ( !h )
  {
    LODWORD(yc) = &e;
    HIDWORD(yc) = &runtime_statictmp_12;
    runtime_gopanic((interface_{})yc);
    BUG();
  }
  if ( (h->flags & 4) != 0 )
  {
    yb.str = (uint8 *)"concurrent map writes";
    yb.len = 21;
    runtime_throw(yb);
    BUG();
  }
  v3 = (*(int (__golang **)(string *, uint32))t->key->alg->hash)(&ky, h->hash0);
  hash = v3;
  v4 = h;
  h->flags |= 4u;
  if ( !h->buckets )
  {
    ba = (runtime_bmap *)runtime_newarray(t->bucket, 1);
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr((uintptr *)&h->buckets, (uintptr)ba);
    else
      h->buckets = ba;
    v3 = hash;
    v4 = h;
  }
  while ( 1 )
  {
    v18 = v4;
    v19 = v4->B;
    v20 = v3 & (v19 < 0x20u ? (1 << v19) + 1 : -1);
    if ( v18->oldbuckets )
    {
      bucket = v3 & (v19 < 0x20u ? (1 << v19) + 1 : -1);
      runtime_growWork(t, v18, v20);
      v3 = hash;
      v20 = bucket;
      v18 = h;
    }
    v13 = (int)v18->buckets + t->bucketsize * v20;
    v12 = HIBYTE(v3);
    if ( (unsigned __int8)v12 < 4u )
      LOBYTE(v12) = v12 + 4;
    top = v12;
    v9 = 0;
    v5 = 0;
    v11 = 0;
    do
    {
      v42 = (runtime_bmap *)v13;
      i = 0;
      while ( 1 )
      {
        inserti = (uint8 *)v9;
        v6 = i;
        if ( i >= 8 )
          break;
        v7 = *(_BYTE *)(v13 + i);
        if ( (_BYTE)v12 == v7 )
        {
          if ( *(_DWORD *)(v13 + 8 * i + 12) == ky.len )
          {
            if ( *(uint8 **)(v13 + 8 * i + 8) == ky.str || (runtime_memequal(), BYTE4(b)) )
            {
              v14 = &v42[9].tophash[i * t->valuesize];
              goto LABEL_19;
            }
            LOBYTE(v12) = top;
            v13 = (int)v42;
            v6 = i;
            v9 = (runtime_bmap *)inserti;
            v8 = (int)v5;
          }
          else
          {
            v8 = (int)v5;
          }
        }
        else if ( v7 )
        {
          v8 = (int)v5;
        }
        else if ( v9 )
        {
          v8 = (int)v5;
        }
        else
        {
          v9 = (runtime_bmap *)(v13 + i);
          keysize = t->keysize;
          v8 = i * keysize + v13 + 8;
          v11 = i * t->valuesize + 8 * keysize + v13 + 8;
        }
        i = v6 + 1;
        v5 = (uintptr *)v8;
      }
      v13 = *(_DWORD *)(v13 + t->bucketsize - 4);
    }
    while ( v13 );
    v16 = h;
    if ( h->oldbuckets )
      break;
    B = h->B;
    if ( h->count >= 8u && h->count >= 0 )
    {
      v40 = runtime_int64tofloat64(h->count);
      LODWORD(y) = B < 0x20u ? 1 << B : 0;
      HIDWORD(y) = ((unsigned __int8)(B - 32) < 0x20u ? 1 << (B - 32) : 0) | ((unsigned __int8)(32 - B) < 0x20u ? 1u >> (32 - B) : 0);
      b = runtime_uint64tofloat64(y);
      v27 = v40;
      v28 = b;
      v17 = v27 >= (float)(6.5 * v28);
      v9 = (runtime_bmap *)inserti;
      v16 = h;
    }
    else
    {
      v17 = 0;
    }
    if ( !v17 )
    {
      noverflow = v16->noverflow;
      v22 = v16->B;
      if ( v22 >= 0x10u )
      {
        v24 = noverflow >= 0x8000u;
        v23 = v9;
      }
      else
      {
        v23 = v9;
        v24 = noverflow >= (unsigned int)(v22 < 0x20u ? 1 << v22 : 0);
      }
      if ( !v24 )
        goto LABEL_36;
    }
    runtime_hashGrow(t, v16);
    v3 = hash;
    v4 = h;
  }
  v23 = v9;
LABEL_36:
  if ( v23 )
  {
    tophash = v5;
  }
  else
  {
    v23 = runtime___ptr_hmap__newoverflow(v16, t, v42);
    v11 = (int)&v23[9];
    v16 = h;
    tophash = (uintptr *)v23[1].tophash;
  }
  str = ky.str;
  tophash[1] = ky.len;
  if ( *(_DWORD *)&runtime_writeBarrier.enabled )
  {
    runtime_writebarrierptr(tophash, (uintptr)str);
    v16 = h;
  }
  else
  {
    *tophash = (uintptr)str;
  }
  v23->tophash[0] = top;
  ++v16->count;
  v14 = (uint8 *)v11;
LABEL_19:
  flags = h->flags;
  if ( (flags & 4) == 0 )
  {
    ya.str = (uint8 *)"concurrent map writes";
    ya.len = 21;
    runtime_throw(ya);
    BUG();
  }
  h->flags = flags & 0xFB;
  return v14;
}
// 8051EDA: variable 'b' is possibly undefined

//----- (08052240) --------------------------------------------------------
runtime_itab_0 *__golang runtime_getitab(runtime_interfacetype_0 *inter, runtime__type_0 *typ, bool canfail)
{
  runtime_interfacetype_0 *v3; // ecx
  uint32 hash; // esi
  uint32 v5; // ebp
  int v6; // eax
  runtime_itab_0 *v7; // eax
  bool v8; // zf
  runtime_itab_0 *v9; // eax
  string v10; // kr00_8
  uintptr *v11; // eax
  interface_{} l; // [esp+0h] [ebp-48h]
  string la; // [esp+0h] [ebp-48h]
  string align; // [esp+4h] [ebp-44h]
  uintptr aligna; // [esp+4h] [ebp-44h]
  bool sysStat; // [esp+8h] [ebp-40h]
  bool sysStata; // [esp+8h] [ebp-40h]
  uint64 *sysStatb; // [esp+8h] [ebp-40h]
  runtime_itab_0 *v19; // [esp+Ch] [ebp-3Ch]
  bool v20; // [esp+13h] [ebp-35h]
  __int32 locked; // [esp+14h] [ebp-34h]
  uint32 h; // [esp+18h] [ebp-30h]
  __int32 len; // [esp+20h] [ebp-28h]
  uint8 *name_bytes; // [esp+28h] [ebp-20h]
  runtime_itab_0 *m; // [esp+2Ch] [ebp-1Ch]
  uintptr *v26; // [esp+30h] [ebp-18h]
  uintptr src; // [esp+34h] [ebp-14h]
  uint8 *str; // [esp+38h] [ebp-10h]

  v3 = inter;
  if ( !inter->mhdr.len )
  {
    la.str = (uint8 *)"internal error - misuse of itab";
    la.len = 31;
    runtime_throw(la);
    BUG();
  }
  if ( (typ->tflag & 1) != 0 )
  {
    hash = typ->hash;
    v5 = 17 * hash
       + inter->typ.hash
       - 1009
       * ((((unsigned int)((0x103CE4585LL * (unsigned __int64)(17 * hash + inter->typ.hash)) >> 32) >> 1) | (__CFADD__(17 * hash + inter->typ.hash, (63849861 * (unsigned __int64)(17 * hash + inter->typ.hash)) >> 32) << 31)) >> 9);
    h = v5;
    v6 = 0;
LABEL_17:
    if ( v6 >= 2 )
    {
      v19 = (runtime_itab_0 *)runtime_persistentalloc(4 * (v3->mhdr.len - 1) + 24, 0, &runtime_memstats.other_sys);
      v9 = v19;
      if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      {
        runtime_writebarrierptr((uintptr *)v19, (uintptr)inter);
        runtime_writebarrierptr((uintptr *)&v19->_type, (uintptr)typ);
        v9 = v19;
      }
      else
      {
        v19->inter = inter;
        v19->_type = typ;
      }
      runtime_additab(v9, 1, sysStata);
      runtime_unlock(&runtime_ifaceLock);
      if ( v19->bad )
        return 0;
      else
        return v19;
    }
    else
    {
      locked = v6;
      v20 = v6 != 0;
      if ( v6 )
      {
        runtime_lock(&runtime_ifaceLock);
        v5 = h;
      }
      if ( v5 >= 0x3F1 )
        runtime_panicindex();
      v7 = (runtime_itab_0 *)runtime_internal_atomic_Loadp(&runtime_hash[v5]);
      v3 = inter;
      while ( 1 )
      {
        if ( !v7 )
        {
          v6 = locked + 1;
          v5 = h;
          goto LABEL_17;
        }
        if ( v7->inter == inter && v7->_type == typ )
          break;
        v7 = v7->link;
      }
      if ( v7->bad )
      {
        if ( !canfail )
          runtime_additab(v7, v20, sysStat);
        v8 = locked == 0;
        v7 = 0;
      }
      else
      {
        v8 = locked == 0;
      }
      if ( !v8 )
      {
        m = v7;
        runtime_unlock(&runtime_ifaceLock);
        return m;
      }
      return v7;
    }
  }
  else
  {
    if ( !canfail )
    {
      name_bytes = runtime___ptr__type__nameOff(&inter->typ, inter->mhdr.array->name).bytes;
      v10 = runtime___ptr__type__string(typ);
      align = runtime___ptr__type__string(&inter->typ);
      len = align.len;
      str = align.str;
      runtime_name_name((runtime_name_0)name_bytes, align);
      src = aligna;
      v11 = (uintptr *)runtime_newobject((runtime__type_0 *)&stru_80D6BA0);
      v26 = v11;
      v11[3] = v10.len;
      if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      {
        runtime_writebarrierptr(v11 + 2, (uintptr)v10.str);
        v11 = v26;
      }
      else
      {
        v11[2] = (uintptr)v10.str;
      }
      v11[5] = len;
      if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      {
        runtime_writebarrierptr(v11 + 4, (uintptr)str);
        v11 = v26;
      }
      else
      {
        v11[4] = (uintptr)str;
      }
      v11[7] = (uintptr)sysStatb;
      if ( *(_DWORD *)&runtime_writeBarrier.enabled )
        runtime_writebarrierptr(v11 + 6, src);
      else
        v11[6] = src;
      l._type = (runtime__type_0 *)&stru_80D20C0;
      l.data = v26;
      runtime_gopanic(l);
      BUG();
    }
    return 0;
  }
}
// 8052315: variable 'sysStat' is possibly undefined
// 80523F7: variable 'sysStata' is possibly undefined
// 80524D3: variable 'aligna' is possibly undefined
// 8052527: variable 'sysStatb' is possibly undefined

//----- (080525C0) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
void __golang runtime_additab(runtime_itab_0 *m, bool locked, bool canfail)
{
  runtime_uncommontype *v3; // eax
  runtime__type_0 *p_typ; // edx
  __int32 len; // ebx
  uint32 v6; // esi
  __int32 v7; // edi
  __int32 i; // edx
  __int32 v9; // ecx
  uint32 v10; // edx
  uintptr ptrdata; // ebx
  __int32 bytes; // eax
  runtime_itab_0 *v13; // ecx
  int v14; // ebx
  unsigned int v15; // ebx
  runtime_itab_0 *v16; // esi
  runtime_itab_0 **v17; // ebx
  uintptr *v18; // eax
  interface_{} t; // [esp+0h] [ebp-68h]
  string ta; // [esp+0h] [ebp-68h]
  string off; // [esp+4h] [ebp-64h]
  string offc; // [esp+4h] [ebp-64h]
  string offe; // [esp+4h] [ebp-64h]
  runtime_nameOff offf; // [esp+4h] [ebp-64h]
  string offa; // [esp+4h] [ebp-64h]
  string offd; // [esp+4h] [ebp-64h]
  string offg; // [esp+4h] [ebp-64h]
  string offb; // [esp+4h] [ebp-64h]
  runtime_name_0 na; // [esp+8h] [ebp-60h]
  void *n; // [esp+8h] [ebp-60h]
  runtime_name_0 nc; // [esp+8h] [ebp-60h]
  runtime_name_0 nb; // [esp+8h] [ebp-60h]
  runtime_name_0 nd; // [esp+8h] [ebp-60h]
  char v34; // [esp+10h] [ebp-58h]
  __int32 j; // [esp+18h] [ebp-50h]
  __int32 ipkg_len; // [esp+1Ch] [ebp-4Ch]
  __int32 iname_len; // [esp+20h] [ebp-48h]
  int v38; // [esp+24h] [ebp-44h]
  __int32 mcount; // [esp+28h] [ebp-40h]
  __int32 v40; // [esp+2Ch] [ebp-3Ch]
  __int32 v41; // [esp+2Ch] [ebp-3Ch]
  runtime__type_0 *typ; // [esp+30h] [ebp-38h]
  uint8 *name_bytes; // [esp+34h] [ebp-34h]
  uint8 *n_bytes; // [esp+38h] [ebp-30h]
  runtime__type_0 *itype; // [esp+3Ch] [ebp-2Ch]
  runtime_interfacetype_0 *inter; // [esp+44h] [ebp-24h]
  uint8 *iname_ptr; // [esp+48h] [ebp-20h]
  uintptr *v48; // [esp+4Ch] [ebp-1Ch]
  uint8 *src; // [esp+50h] [ebp-18h]
  uint8 *str; // [esp+54h] [ebp-14h]
  char *v51; // [esp+60h] [ebp-8h]
  runtime_nameOff *p_pkgpath; // [esp+64h] [ebp-4h]

  inter = m->inter;
  typ = m->_type;
  v3 = runtime___ptr__type__uncommon(typ);
  p_typ = &inter->typ;
  len = inter->mhdr.len;
  p_pkgpath = &v3->pkgpath;
  v51 = (char *)v3 + v3->moff;
  v40 = len;
  mcount = v3->mcount;
  v6 = 0;
  v7 = 0;
LABEL_16:
  if ( (int)v6 >= len )
  {
    v13 = m;
  }
  else
  {
    ptrdata = p_typ[1].ptrdata;
    if ( v6 >= p_typ[1].hash )
      runtime_panicindex();
    itype = runtime___ptr__type__typeOff(p_typ, *(_DWORD *)(ptrdata + 8 * v6 + 4));
    offe.len = (__int32)runtime___ptr__type__nameOff(&inter->typ, *(_DWORD *)(ptrdata + 8 * v6)).bytes;
    name_bytes = (uint8 *)offe.len;
    runtime_name_name((runtime_name_0)offe.len, offe);
    iname_len = (__int32)nc.bytes;
    iname_ptr = (uint8 *)offf;
    offa = runtime_name_pkgPath((runtime_name_0)name_bytes);
    bytes = offa.len;
    if ( !offa.len )
    {
      runtime_name_name(inter->pkgpath, (string)(unsigned int)offa.str);
      bytes = (__int32)nd.bytes;
    }
    ipkg_len = bytes;
    for ( i = v7; i < mcount; i = j + 1 )
    {
      if ( i >= (unsigned int)mcount )
        runtime_panicindex();
      j = i;
      v38 = 16 * i;
      n_bytes = runtime___ptr__type__nameOff(typ, *(_DWORD *)&v51[16 * i]).bytes;
      off.len = (__int32)runtime___ptr__type__typeOff(typ, *(_DWORD *)&v51[v38 + 4]);
      if ( (runtime__type_0 *)off.len == itype )
      {
        runtime_name_name((runtime_name_0)n_bytes, off);
        if ( na.bytes == (uint8 *)iname_len )
        {
          runtime_eqstring();
          if ( v34 )
          {
            offc = runtime_name_pkgPath((runtime_name_0)n_bytes);
            v9 = offc.len;
            if ( !offc.len )
            {
              offd.len = (__int32)runtime___ptr__type__nameOff(typ, *p_pkgpath).bytes;
              runtime_name_name((runtime_name_0)offd.len, offd);
              v9 = (__int32)nb.bytes;
            }
            if ( (*n_bytes & 1) != 0 )
              goto LABEL_13;
            if ( ipkg_len == v9 )
            {
              runtime_eqstring();
LABEL_13:
              n = runtime___ptr__type__textOff(typ, *(_DWORD *)&v51[v38 + 8]);
              v10 = v6;
              if ( *(_DWORD *)&runtime_writeBarrier.enabled )
              {
                runtime_writebarrierptr(&m->fun[v6], (uintptr)n);
                v10 = v6;
              }
              else
              {
                m->fun[v6] = (uintptr)n;
              }
              v6 = v10 + 1;
              p_typ = &inter->typ;
              len = v40;
              v7 = j;
              goto LABEL_16;
            }
          }
        }
      }
    }
    if ( !*(&locked + 1) )
    {
      if ( locked )
        runtime_unlock(&runtime_ifaceLock);
      offg = runtime___ptr__type__string(typ);
      v41 = offg.len;
      str = offg.str;
      offb = runtime___ptr__type__string(&inter->typ);
      src = offb.str;
      v18 = (uintptr *)runtime_newobject((runtime__type_0 *)&stru_80D6BA0);
      v48 = v18;
      v18[3] = v41;
      if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      {
        runtime_writebarrierptr(v18 + 2, (uintptr)str);
        v18 = v48;
      }
      else
      {
        v18[2] = (uintptr)str;
      }
      v18[5] = offb.len;
      if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      {
        runtime_writebarrierptr(v18 + 4, (uintptr)src);
        v18 = v48;
      }
      else
      {
        v18[4] = (uintptr)src;
      }
      v18[7] = iname_len;
      if ( *(_DWORD *)&runtime_writeBarrier.enabled )
        runtime_writebarrierptr(v18 + 6, (uintptr)iname_ptr);
      else
        v18[6] = (uintptr)iname_ptr;
      t._type = (runtime__type_0 *)&stru_80D20C0;
      t.data = v48;
      runtime_gopanic(t);
      BUG();
    }
    v13 = m;
    m->bad = 1;
  }
  if ( !locked )
  {
    ta.str = (uint8 *)"invalid itab locking";
    ta.len = 20;
    runtime_throw(ta);
    BUG();
  }
  v14 = 17 * typ->hash + inter->typ.hash;
  v15 = v14
      - 1009
      * ((((unsigned int)((0x103CE4585LL * (unsigned __int64)(unsigned int)v14) >> 32) >> 1) | (__CFADD__(
                                                                                                  v14,
                                                                                                  (63849861
                                                                                                 * (unsigned __int64)(unsigned int)v14) >> 32) << 31)) >> 9);
  if ( v15 >= 0x3F1 )
    runtime_panicindex();
  v16 = runtime_hash[v15];
  v17 = &runtime_hash[v15];
  if ( *(_DWORD *)&runtime_writeBarrier.enabled )
  {
    runtime_writebarrierptr((uintptr *)&v13->link, (uintptr)v16);
    v13 = m;
  }
  else
  {
    v13->link = v16;
  }
  v13->inhash = 1;
  runtime_atomicstorep(v17, v13);
}
// 8052749: conditional instruction was optimized away because %var_58.1!=0
// 80525C0: variables would overlap: ^70.1 and ^70.2
// 80525C0: inconsistent variable size for '^70.1(locked)'

//----- (08052AC0) --------------------------------------------------------
void __golang runtime_itabsinit()
{
  runtime_moduledata_0 **array; // eax
  __int32 len; // ecx
  __int32 i; // edx
  runtime_itab_0 **v3; // ebp
  __int32 j; // esi
  __int32 v5; // ebx
  ___runtime_moduledata l; // [esp+0h] [ebp-24h]
  __int32 v7; // [esp+10h] [ebp-14h]
  __int32 v8; // [esp+14h] [ebp-10h]
  __int32 v9; // [esp+18h] [ebp-Ch]
  runtime_moduledata_0 **v10; // [esp+20h] [ebp-4h]

  runtime_lock(&runtime_ifaceLock);
  l = runtime_activeModules();
  array = l.array;
  len = l.len;
  v9 = l.len;
  for ( i = 0; i < len; ++i )
  {
    v8 = i;
    v10 = array;
    v3 = (*array)->itablinks.array;
    v5 = (*array)->itablinks.len;
    v7 = v5;
    for ( j = 0; j < v5; ++j )
    {
      if ( !(*v3)->inhash )
      {
        runtime_additab(*v3, 1, l.cap);
        array = v10;
        i = v8;
        v5 = v7;
      }
      ++v3;
      len = v9;
    }
    ++array;
  }
  runtime_unlock(&runtime_ifaceLock);
}
// 8052B24: variable 'l' is possibly undefined

//----- (08052B90) --------------------------------------------------------
void __golang __noreturn runtime_panicdottypeE(runtime__type_0 *have, runtime__type_0 *want, runtime__type_0 *iface)
{
  uint8 *str; // eax
  __int32 len; // ecx
  string v5; // kr00_8
  string src; // kr08_8
  uintptr *v7; // eax
  string v8; // kr10_8
  interface_{} t; // [esp+0h] [ebp-28h]
  __int32 haveString_len; // [esp+Ch] [ebp-1Ch]
  uint8 *haveString_ptr; // [esp+18h] [ebp-10h]
  uintptr *v12; // [esp+1Ch] [ebp-Ch]

  if ( have )
  {
    v8 = runtime___ptr__type__string(have);
    len = v8.len;
    str = v8.str;
  }
  else
  {
    str = 0;
    len = 0;
  }
  haveString_ptr = str;
  haveString_len = len;
  v5 = runtime___ptr__type__string(iface);
  src = runtime___ptr__type__string(want);
  v7 = (uintptr *)runtime_newobject((runtime__type_0 *)&stru_80D6BA0);
  v12 = v7;
  v7[1] = v5.len;
  if ( *(_DWORD *)&runtime_writeBarrier.enabled )
  {
    runtime_writebarrierptr(v7, (uintptr)v5.str);
    v7 = v12;
  }
  else
  {
    *v7 = (uintptr)v5.str;
  }
  v7[3] = haveString_len;
  if ( *(_DWORD *)&runtime_writeBarrier.enabled )
  {
    runtime_writebarrierptr(v7 + 2, (uintptr)haveString_ptr);
    v7 = v12;
  }
  else
  {
    v7[2] = (uintptr)haveString_ptr;
  }
  v7[5] = src.len;
  if ( *(_DWORD *)&runtime_writeBarrier.enabled )
  {
    runtime_writebarrierptr(v7 + 4, (uintptr)src.str);
    v7 = v12;
  }
  else
  {
    v7[4] = (uintptr)src.str;
  }
  v7[7] = 0;
  if ( *(_DWORD *)&runtime_writeBarrier.enabled )
    runtime_writebarrierptr(v7 + 6, 0);
  else
    v7[6] = 0;
  t._type = (runtime__type_0 *)&stru_80D20C0;
  t.data = v12;
  runtime_gopanic(t);
  BUG();
}

//----- (08052D10) --------------------------------------------------------
void __golang __noreturn runtime_panicdottypeI(runtime_itab_0 *have, runtime__type_0 *want, runtime__type_0 *iface)
{
  runtime__type_0 *type; // eax

  if ( have )
    type = have->_type;
  else
    type = 0;
  runtime_panicdottypeE(type, want, iface);
}

//----- (08052D60) --------------------------------------------------------
void __golang runtime_convT2E(runtime__type_0 *t, void *elem, runtime_eface_0 e)
{
  void *x; // [esp+10h] [ebp-4h]

  x = runtime_mallocgc(t->size, t, 1);
  runtime_typedmemmove(t, x, elem);
}

//----- (08052DD0) --------------------------------------------------------
void __golang runtime_convT2E32(runtime__type_0 *t, void *elem, runtime_eface_0 e)
{
  if ( *(_DWORD *)elem )
    *(_DWORD *)runtime_mallocgc(4u, t, 0) = *(_DWORD *)elem;
}

//----- (08052E40) --------------------------------------------------------
void __golang runtime_convT2Estring(runtime__type_0 *t, void *elem, runtime_eface_0 e)
{
  uintptr *v3; // eax
  uintptr v4; // ecx

  if ( *((_DWORD *)elem + 1) )
  {
    v3 = (uintptr *)runtime_mallocgc(t->size, t, 1);
    v4 = *(_DWORD *)elem;
    v3[1] = *((_DWORD *)elem + 1);
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr(v3, v4);
    else
      *v3 = v4;
  }
}

//----- (08052ED0) --------------------------------------------------------
void __golang runtime_convT2Eslice(runtime__type_0 *t, void *elem, runtime_eface_0 e)
{
  uintptr *v3; // eax
  uintptr v4; // ebx
  uintptr v5; // ecx

  if ( *(_DWORD *)elem )
  {
    v3 = (uintptr *)runtime_mallocgc(t->size, t, 1);
    v4 = *(_DWORD *)elem;
    v5 = *((_DWORD *)elem + 2);
    v3[1] = *((_DWORD *)elem + 1);
    v3[2] = v5;
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr(v3, v4);
    else
      *v3 = v4;
  }
}

//----- (08052F70) --------------------------------------------------------
void __golang runtime_convT2I32(runtime_itab_0 *tab, void *elem, runtime_iface_0 i)
{
  if ( *(_DWORD *)elem )
    *(_DWORD *)runtime_mallocgc(4u, tab->_type, 0) = *(_DWORD *)elem;
}

//----- (08052FE0) --------------------------------------------------------
void __golang runtime_assertE2I(runtime_interfacetype_0 *inter, runtime_eface_0 e, runtime_iface_0 r)
{
  uintptr *v3; // eax
  interface_{} v4; // [esp+0h] [ebp-1Ch]
  string v5; // [esp+4h] [ebp-18h]
  uintptr *v6; // [esp+18h] [ebp-4h]

  if ( !e._type )
  {
    v5 = runtime___ptr__type__string(&inter->typ);
    v3 = (uintptr *)runtime_newobject((runtime__type_0 *)&stru_80D6BA0);
    v6 = v3;
    v3[5] = v5.len;
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
    {
      runtime_writebarrierptr(v3 + 4, (uintptr)v5.str);
      v3 = v6;
    }
    else
    {
      v3[4] = (uintptr)v5.str;
    }
    v3[7] = 0;
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr(v3 + 6, 0);
    else
      v3[6] = 0;
    v4._type = (runtime__type_0 *)&stru_80D20C0;
    v4.data = v6;
    runtime_gopanic(v4);
    BUG();
  }
  runtime_getitab(inter, e._type, 0);
}

//----- (080530E0) --------------------------------------------------------
void __golang runtime_assertE2I2(runtime_interfacetype_0 *inter, runtime_eface_0 e, runtime_iface_0 r, bool b)
{
  if ( e._type )
    runtime_getitab(inter, e._type, 1);
}

//----- (08053170) --------------------------------------------------------
void __golang reflect_ifaceE2I(runtime_interfacetype_0 *inter, runtime_eface_0 e, runtime_iface_0 *dst)
{
  runtime_iface_0 src; // [esp+Ch] [ebp-10h]
  runtime_iface_0 srca; // [esp+Ch] [ebp-10h]

  runtime_assertE2I(inter, e, src);
  if ( *(_DWORD *)&runtime_writeBarrier.enabled )
  {
    runtime_writebarrierptr((uintptr *)dst, (uintptr)srca.tab);
    runtime_writebarrierptr((uintptr *)&dst->data, (uintptr)srca.data);
  }
  else
  {
    *dst = srca;
  }
}
// 8053170: could not find valid save-restore pair for ebx
// 8053170: could not find valid save-restore pair for ebp
// 805319C: variable 'src' is possibly undefined
// 80531BC: variable 'srca' is possibly undefined

//----- (08053200) --------------------------------------------------------
void __golang runtime___ptr_lfstack__push(runtime_lfstack *head, runtime_lfnode_0 *node)
{
  string s_4; // [esp+4h] [ebp-1Ch]
  char v3; // [esp+14h] [ebp-Ch]

  ++node->pushcnt;
  do
  {
    runtime_internal_atomic_Load64();
    node->next = (uint64)s_4;
    runtime_internal_atomic_Cas64();
  }
  while ( !v3 );
}
// 805324A: variable 's_4' is possibly undefined
// 805327A: variable 'v3' is possibly undefined

//----- (08053360) --------------------------------------------------------
void *__golang runtime___ptr_lfstack__pop(runtime_lfstack *head)
{
  int v1; // [esp+4h] [ebp-20h]
  void *v2; // [esp+8h] [ebp-1Ch]
  char v3; // [esp+14h] [ebp-10h]

  while ( 1 )
  {
    runtime_internal_atomic_Load64();
    if ( v1 == 0 && v2 == 0 )
      break;
    runtime_internal_atomic_Load64();
    runtime_internal_atomic_Cas64();
    if ( v3 )
      return v2;
  }
  return 0;
}
// 8053394: variable 'v1' is possibly undefined
// 805338F: variable 'v2' is possibly undefined
// 80533E8: variable 'v3' is possibly undefined

//----- (08053410) --------------------------------------------------------
bool __golang runtime___ptr_lfstack__empty(runtime_lfstack *head)
{
  int v1; // [esp+4h] [ebp-8h]
  int v2; // [esp+8h] [ebp-4h]

  runtime_internal_atomic_Load64();
  return v1 == 0 && v2 == 0;
}
// 8053440: variable 'v1' is possibly undefined
// 805343B: variable 'v2' is possibly undefined

//----- (08053460) --------------------------------------------------------
void __golang runtime_lock(runtime_mutex_0 *l)
{
  int v1; // eax
  int v2; // ecx
  int v3; // eax
  int v4; // ecx
  __int32 v5; // edx
  int v6; // edx
  string addr; // [esp+0h] [ebp-20h]
  int ns; // [esp+8h] [ebp-18h]
  char ns_4; // [esp+Ch] [ebp-14h]
  uint32 wait; // [esp+10h] [ebp-10h]
  __int32 spin; // [esp+14h] [ebp-Ch]
  __int32 i; // [esp+18h] [ebp-8h]
  __int32 i_0; // [esp+1Ch] [ebp-4h]

  v1 = *(_DWORD *)(*(_DWORD *)(__readgsdword(0) - 4) + 24);
  v2 = *(_DWORD *)(v1 + 120);
  if ( v2 < 0 )
  {
    addr.str = (uint8 *)"runtime·lock: lock count";
    addr.len = 25;
    runtime_throw(addr);
    BUG();
  }
  *(_DWORD *)(v1 + 120) = v2 + 1;
  runtime_internal_atomic_Xchg();
  v3 = ns;
  if ( ns )
  {
    if ( runtime_ncpu <= 1 )
      v4 = 0;
    else
      v4 = 4;
    spin = v4;
    while ( 1 )
    {
      wait = v3;
      v5 = 0;
      while ( v5 < v4 )
      {
        i_0 = v5;
        while ( !l->key )
        {
          ns = v3;
          runtime_internal_atomic_Cas();
          if ( ns_4 )
            return;
          v3 = wait;
        }
        runtime_procyield();
        v5 = i_0 + 1;
        v3 = wait;
        v4 = spin;
      }
      v6 = 0;
      while ( v6 < 1 )
      {
        i = v6;
        while ( !l->key )
        {
          ns = v3;
          runtime_internal_atomic_Cas();
          if ( ns_4 )
            return;
          v3 = wait;
        }
        runtime_osyield();
        v6 = i + 1;
        v3 = wait;
      }
      runtime_internal_atomic_Xchg();
      if ( !ns )
        break;
      runtime_futexsleep(&l->key, 2u, -1LL);
      v4 = spin;
      v3 = 2;
    }
  }
}
// 80534AE: variable 'ns' is possibly undefined
// 8053508: variable 'ns_4' is possibly undefined

//----- (08053620) --------------------------------------------------------
void __golang runtime_unlock(runtime_mutex_0 *l)
{
  int v1; // eax
  int v2; // ecx
  string addr; // [esp+0h] [ebp-Ch]
  string addra; // [esp+0h] [ebp-Ch]
  int v5; // [esp+8h] [ebp-4h]

  runtime_internal_atomic_Xchg();
  if ( !v5 )
  {
    addra.str = (uint8 *)"unlock of unlocked lock";
    addra.len = 23;
    runtime_throw(addra);
    BUG();
  }
  if ( v5 == 2 )
    runtime_futexwakeup(&l->key, 1u);
  v1 = *(_DWORD *)(__readgsdword(0) - 4);
  v2 = --*(_DWORD *)(*(_DWORD *)(v1 + 24) + 120);
  if ( v2 < 0 )
  {
    addr.str = (uint8 *)"runtime·unlock: lock count";
    addr.len = 27;
    runtime_throw(addr);
    BUG();
  }
  if ( !v2 )
  {
    if ( *(_BYTE *)(v1 + 108) )
      *(_DWORD *)(v1 + 8) = -1314;
  }
}
// 8053655: variable 'v5' is possibly undefined

//----- (080536F0) --------------------------------------------------------
void __golang runtime_notewakeup(runtime_note_0 *n)
{
  string addr; // [esp+0h] [ebp-10h]
  string addra; // [esp+0h] [ebp-10h]
  string addrb; // [esp+0h] [ebp-10h]
  unsigned int v4; // [esp+8h] [ebp-8h]

  runtime_internal_atomic_Xchg();
  if ( v4 )
  {
    runtime_printlock();
    addr.str = (uint8 *)"notewakeup - double wakeup (";
    addr.len = 28;
    runtime_printstring(addr);
    runtime_printint(v4);
    addra.str = (uint8 *)")\n";
    addra.len = 2;
    runtime_printstring(addra);
    runtime_printunlock();
    addrb.str = (uint8 *)"notewakeup - double wakeup";
    addrb.len = 26;
    runtime_throw(addrb);
    BUG();
  }
  runtime_futexwakeup(&n->key, 1u);
}
// 8053725: variable 'v4' is possibly undefined

//----- (080537B0) --------------------------------------------------------
void __golang runtime_notesleep(runtime_note_0 *n)
{
  runtime_g *v1; // eax
  int v2; // ecx
  int v3; // edx
  string ptr; // [esp+0h] [ebp-1Ch]
  int64 ns_lo; // [esp+10h] [ebp-Ch]
  runtime_g *gp; // [esp+18h] [ebp-4h]

  v1 = *(runtime_g **)(__readgsdword(0) - 4);
  if ( v1 != v1->m->g0 )
  {
    ptr.str = (uint8 *)"notesleep not on g0";
    ptr.len = 19;
    runtime_throw(ptr);
    BUG();
  }
  if ( *runtime_cgo_yield )
  {
    v2 = 10000000;
    v3 = 0;
  }
  else
  {
    v2 = -1;
    v3 = -1;
  }
  gp = v1;
  ns_lo = __PAIR64__(v3, v2);
  while ( !runtime_internal_atomic_Load(&n->key) )
  {
    gp->m->blocked = 1;
    runtime_futexsleep(&n->key, 0, ns_lo);
    if ( *runtime_cgo_yield )
      runtime_asmcgocall();
    gp->m->blocked = 0;
  }
}
// 80537B0: could not find valid save-restore pair for ebx

//----- (080538C0) --------------------------------------------------------
bool __golang runtime_notetsleep_internal(runtime_note_0 *n, int64 ns)
{
  int v2; // ecx
  unsigned int v3; // edx
  int64 v4; // rcx
  unsigned int ptr; // [esp+0h] [ebp-1Ch]
  __int64 ptra; // [esp+0h] [ebp-1Ch]
  int64 deadline_lo; // [esp+10h] [ebp-Ch]
  runtime_g *gp; // [esp+18h] [ebp-4h]
  unsigned __int64 nsa; // [esp+24h] [ebp+8h]

  gp = *(runtime_g **)(__readgsdword(0) - 4);
  v2 = ns;
  if ( ns >= 0 )
  {
    if ( runtime_internal_atomic_Load(&n->key) )
    {
      return 1;
    }
    else
    {
      runtime_nanotime();
      v4 = ns;
      for ( deadline_lo = ns + ptr; ; v4 = deadline_lo - ptra )
      {
        if ( *runtime_cgo_yield && (SHIDWORD(v4) > 0 || HIDWORD(v4) == 0 && (unsigned int)v4 > 0x989680) )
          v4 = 10000000LL;
        gp->m->blocked = 1;
        runtime_futexsleep(&n->key, 0, v4);
        if ( *runtime_cgo_yield )
          runtime_asmcgocall();
        gp->m->blocked = 0;
        HIDWORD(ptra) = runtime_internal_atomic_Load(&n->key);
        if ( HIDWORD(ptra) )
          break;
        runtime_nanotime();
        if ( deadline_lo < 0 || HIDWORD(deadline_lo) == 0 && (unsigned int)ptra >= (unsigned int)deadline_lo )
          break;
      }
      return runtime_internal_atomic_Load(&n->key) != 0;
    }
  }
  else
  {
    if ( *runtime_cgo_yield )
    {
      v2 = 10000000;
      v3 = 0;
    }
    else
    {
      v3 = HIDWORD(ns);
    }
    nsa = __PAIR64__(v3, v2);
    while ( !runtime_internal_atomic_Load(&n->key) )
    {
      gp->m->blocked = 1;
      runtime_futexsleep(&n->key, 0, nsa);
      if ( *runtime_cgo_yield )
        runtime_asmcgocall();
      gp->m->blocked = 0;
    }
    return 1;
  }
}
// 80539CE: variable 'ptr' is possibly undefined
// 80539EC: variable 'ptra' is possibly undefined

//----- (08053B00) --------------------------------------------------------
bool __golang runtime_notetsleep(runtime_note_0 *n, int64 ns)
{
  int v2; // eax
  _DWORD *v3; // ecx
  string s; // [esp+0h] [ebp-10h]

  v2 = *(_DWORD *)(__readgsdword(0) - 4);
  v3 = *(_DWORD **)(v2 + 24);
  if ( v2 != *v3 && v3[29] )
  {
    s.str = (uint8 *)"notetsleep not on g0";
    s.len = 20;
    runtime_throw(s);
    BUG();
  }
  return runtime_notetsleep_internal(n, ns);
}

//----- (08053B80) --------------------------------------------------------
bool __golang runtime_notetsleepg(runtime_note_0 *n, int64 ns)
{
  int v2; // eax
  string dummy; // [esp+0h] [ebp-14h]
  bool ok; // [esp+13h] [ebp-1h]

  v2 = *(_DWORD *)(__readgsdword(0) - 4);
  if ( v2 == **(_DWORD **)(v2 + 24) )
  {
    dummy.str = (uint8 *)"notetsleepg on g0";
    dummy.len = 17;
    runtime_throw(dummy);
    BUG();
  }
  runtime_entersyscallblock(0);
  ok = runtime_notetsleep_internal(n, ns);
  runtime_exitsyscall(0);
  return ok;
}

//----- (08053C20) --------------------------------------------------------
void __golang runtime_mallocinit()
{
  int i; // eax
  uintptr v1; // eax
  int v2; // ecx
  char *v3; // edx
  uintptr v4; // ebp
  int v5; // ebx
  void *v6; // ebp
  void *v7; // eax
  uintptr v8; // ecx
  unsigned int spansStart; // edx
  void *v; // [esp+0h] [ebp-44h]
  string va; // [esp+0h] [ebp-44h]
  string vb; // [esp+0h] [ebp-44h]
  string vc; // [esp+0h] [ebp-44h]
  string vd; // [esp+0h] [ebp-44h]
  string ve; // [esp+0h] [ebp-44h]
  string vf; // [esp+0h] [ebp-44h]
  string vg; // [esp+0h] [ebp-44h]
  string vh; // [esp+0h] [ebp-44h]
  string vi; // [esp+0h] [ebp-44h]
  string vj; // [esp+0h] [ebp-44h]
  bool reserved; // [esp+13h] [ebp-31h] BYREF
  uintptr procBrk; // [esp+14h] [ebp-30h]
  uintptr pSize; // [esp+18h] [ebp-2Ch]
  uint64 v24; // [esp+24h] [ebp-20h]
  char v25; // [esp+2Ch] [ebp-18h] BYREF
  runtime_g *_g_; // [esp+3Ch] [ebp-8h]
  char *v27; // [esp+40h] [ebp-4h]

  if ( runtime_class_to_size[2] != 16 )
  {
    vj.str = (uint8 *)"bad TinySizeClass";
    vj.len = 17;
    runtime_throw(vj);
    BUG();
  }
  runtime_testdefersizes();
  for ( i = 0; i < 67; ++i )
  {
    if ( (unsigned int)i >= 0x43 )
      runtime_panicindex();
    runtime_memstats.by_size[i].size = runtime_class_to_size[i];
  }
  if ( !runtime_physPageSize )
  {
    vi.str = (uint8 *)"failed to get system page size";
    vi.len = 30;
    runtime_throw(vi);
    BUG();
  }
  if ( runtime_physPageSize < 0x1000 )
  {
    runtime_printlock();
    ve.str = (uint8 *)"system page size (";
    ve.len = 18;
    runtime_printstring(ve);
    runtime_printint(runtime_physPageSize);
    vf.str = (uint8 *)") is smaller than minimum page size (";
    vf.len = 37;
    runtime_printstring(vf);
    runtime_printint(4096LL);
    vg.str = (uint8 *)")\n";
    vg.len = 2;
    runtime_printstring(vg);
    runtime_printunlock();
    vh.str = (uint8 *)"bad system page size";
    vh.len = 20;
    runtime_throw(vh);
    BUG();
  }
  if ( ((runtime_physPageSize - 1) & runtime_physPageSize) != 0 )
  {
    runtime_printlock();
    vb.str = (uint8 *)"system page size (";
    vb.len = 18;
    runtime_printstring(vb);
    runtime_printint(runtime_physPageSize);
    vc.str = (uint8 *)") must be a power of 2\n";
    vc.len = 23;
    runtime_printstring(vc);
    runtime_printunlock();
    vd.str = (uint8 *)"bad system page size";
    vd.len = 20;
    runtime_throw(vd);
    BUG();
  }
  reserved = 0;
  runtime_sbrk0();
  procBrk = (uintptr)v;
  v1 = ((int (*)(void))loc_8090278)();
  v2 = 0;
  v3 = &v25;
  v4 = 0;
  while ( v2 < 4 )
  {
    HIDWORD(v24) = v2;
    v27 = v3;
    v5 = *(_DWORD *)v3;
    v6 = (void *)((runtime_firstmoduledata.end + 1310719) & 0xFFF00000);
    if ( (unsigned int)v6 <= v1 && v1 < (unsigned int)v6 + v5 + 270540800 )
      v6 = (void *)((v1 + 0x1FFFFF) & 0xFFF00000);
    pSize = v5 + 270540800;
    v7 = runtime_sysReserve(v6, v5 + 270540800, &reserved);
    if ( v7 )
    {
      v8 = pSize;
      goto LABEL_18;
    }
    v3 = v27 + 4;
    v2 = HIDWORD(v24) + 1;
    v4 = pSize;
    v1 = procBrk;
  }
  v7 = 0;
  v8 = v4;
LABEL_18:
  if ( !v7 )
  {
    va.str = (uint8 *)"runtime: cannot reserve arena virtual address spac";
    va.len = 51;
    runtime_throw(va);
    BUG();
  }
  spansStart = ((unsigned int)v7 + 0x1FFF) & 0xFFFFE000;
  dword_81493A0 = spansStart + 270532608;
  dword_81493A8 = 0;
  dword_81493B4 = (int)v7 + v8 - (spansStart - (_DWORD)v7);
  dword_81493AC = spansStart + 270532608;
  dword_81493B0 = spansStart + 270532608;
  byte_81493B8 = reserved;
  runtime___ptr_mheap__init(&runtime_mheap_, spansStart, 0x200000u);
  _g_ = *(runtime_g **)(__readgsdword(0) - 4);
  _g_->m->mcache = runtime_allocmcache();
}
// 8053CAB: variable 'v' is possibly undefined
// 81493A0: using guessed type int dword_81493A0;
// 81493A8: using guessed type int dword_81493A8;
// 81493AC: using guessed type int dword_81493AC;
// 81493B0: using guessed type int dword_81493B0;
// 81493B4: using guessed type int dword_81493B4;
// 81493B8: using guessed type char byte_81493B8;

//----- (08054040) --------------------------------------------------------
void *__golang runtime___ptr_mheap__sysAlloc(runtime_mheap_0 *h, uintptr n)
{
  runtime_mheap_0 *v2; // eax
  uintptr arena_end; // ebx
  unsigned int v4; // edx
  uintptr v5; // ecx
  void *arena_alloc; // ebx
  uintptr arena_start; // edx
  void *v8; // eax
  uintptr v9; // ecx
  runtime_mheap_0 *v10; // ecx
  uintptr v11; // edx
  uintptr v12; // ebp
  string v13; // [esp+0h] [ebp-34h]
  string v14; // [esp+0h] [ebp-34h]
  string v15; // [esp+0h] [ebp-34h]
  uint64 v16; // [esp+0h] [ebp-34h]
  string v17; // [esp+0h] [ebp-34h]
  string v18; // [esp+0h] [ebp-34h]
  string v19; // [esp+0h] [ebp-34h]
  uintptr v20; // [esp+8h] [ebp-2Ch]
  uint64 *v21; // [esp+Ch] [ebp-28h]
  bool reserved; // [esp+13h] [ebp-21h] BYREF
  uintptr _r2; // [esp+14h] [ebp-20h]
  uint32 top_lo; // [esp+18h] [ebp-1Ch]
  uintptr p_size; // [esp+1Ch] [ebp-18h]
  uintptr p_size_0; // [esp+20h] [ebp-14h]
  uintptr p; // [esp+24h] [ebp-10h]
  _DWORD v[3]; // [esp+28h] [ebp-Ch] BYREF

  v2 = h;
  arena_end = h->arena_end;
  v4 = n;
  if ( n > arena_end - h->arena_alloc )
  {
    v5 = (n + 268443647) & 0xF0000000;
    if ( arena_end <= v5 + arena_end )
    {
      p_size_0 = (n + 268443647) & 0xF0000000;
      v[0] = v5 + arena_end;
      reserved = 0;
      v21 = (uint64 *)runtime_sysReserve((void *)h->arena_end, p_size_0, &reserved);
      if ( !v21 )
      {
        v4 = n;
LABEL_5:
        _r2 = (v4 + 0x1FFF) & 0xFFFFE000;
        p_size = _r2 + 0x2000;
        v20 = (uintptr)runtime_sysAlloc(_r2 + 0x2000, &runtime_memstats.heap_sys);
        if ( !v20 )
          return 0;
        p = v20;
        arena_start = h->arena_start;
        if ( v20 >= arena_start )
        {
          v8 = (void *)(v20 + (-v20 & 0x1FFF));
          if ( (unsigned int)v8 + n > h->arena_used )
          {
            p = v20 + (-v20 & 0x1FFF);
            runtime___ptr_mheap__setArenaUsed(h, (uintptr)v8 + n, 1);
            v8 = (void *)p;
          }
          if ( ((unsigned __int16)v8 & 0x1FFF) != 0 )
          {
            v18.str = (uint8 *)"misrounded allocation in MHeap_SysAlloc";
            v18.len = 39;
            runtime_throw(v18);
            BUG();
          }
          return v8;
        }
        else
        {
          v[0] = h->arena_start;
          top_lo = arena_start - 1;
          runtime_printlock();
          v13.str = (uint8 *)"runtime: memory allocated by OS (";
          v13.len = 33;
          runtime_printstring(v13);
          runtime_printhex(p);
          v14.str = (uint8 *)") not in usable range [";
          v14.len = 23;
          runtime_printstring(v14);
          runtime_printhex(v[0]);
          v15.str = (uint8 *)",";
          v15.len = 1;
          runtime_printstring(v15);
          LODWORD(v16) = top_lo;
          HIDWORD(v16) = v[0] != 0;
          runtime_printhex(v16);
          v17.str = (uint8 *)")\n";
          v17.len = 2;
          runtime_printstring(v17);
          runtime_printunlock();
          runtime_sysFree((void *)p, p_size, &runtime_memstats.heap_sys);
          return 0;
        }
      }
      v10 = h;
      v11 = h->arena_end;
      if ( v21 == (uint64 *)v11 )
      {
        h->arena_end = v[0];
        h->arena_reserved = reserved;
LABEL_21:
        v2 = v10;
        v4 = n;
        goto LABEL_4;
      }
      if ( h->arena_start > (unsigned int)v21 )
      {
        v12 = p_size_0;
      }
      else
      {
        v12 = p_size_0;
        if ( v11 - h->arena_alloc < 0x1000000 )
        {
          h->arena_end = (uintptr)v21 + p_size_0;
          h->arena_alloc = ((unsigned int)v21 + 0x1FFF) & 0xFFFFE000;
          h->arena_reserved = reserved;
          goto LABEL_21;
        }
      }
      v[1] = v12;
      v[2] = 0;
      runtime_sysFree(v21, v12, (uint64 *)&v[1]);
      v10 = h;
      goto LABEL_21;
    }
  }
LABEL_4:
  arena_alloc = (void *)v2->arena_alloc;
  if ( v4 > v2->arena_end - (int)arena_alloc )
    goto LABEL_5;
  v[0] = v2->arena_alloc;
  runtime_sysMap(arena_alloc, v4, v2->arena_reserved, &runtime_memstats.heap_sys);
  v9 = n + h->arena_alloc;
  h->arena_alloc = v9;
  if ( v9 > h->arena_used )
    runtime___ptr_mheap__setArenaUsed(h, v9, 1);
  if ( (v[0] & 0x1FFF) != 0 )
  {
    v19.str = (uint8 *)"misrounded allocation in MHeap_SysAlloc";
    v19.len = 39;
    runtime_throw(v19);
    BUG();
  }
  return (void *)v[0];
}
// 80E0D89: using guessed type char asc_80E0D89;

//----- (080543E0) --------------------------------------------------------
runtime_gclinkptr __golang runtime_nextFreeFast(runtime_mspan *s)
{
  uintptr freeindex; // ebx
  uintptr v2; // ebp
  uintptr nelems; // esi
  uintptr v4; // ebx
  int v5; // eax
  uintptr elemsize; // eax
  uintptr startAddr; // ebp
  int v8; // [esp+8h] [ebp-10h]
  uintptr result; // [esp+Ch] [ebp-Ch]
  unsigned int allocCache_high; // [esp+14h] [ebp-4h]

  runtime_internal_sys_Ctz64();
  if ( v8 >= 64 )
    return 0;
  freeindex = s->freeindex;
  v2 = freeindex + v8;
  nelems = s->nelems;
  if ( freeindex + v8 >= nelems )
    return 0;
  v4 = v8 + freeindex + 1;
  if ( (v4 & 0x3F) == 0 && v4 != nelems )
    return 0;
  result = v2;
  allocCache_high = HIDWORD(s->allocCache);
  v5 = -((unsigned int)(v8 + 1) < 0x20);
  LODWORD(s->allocCache) = ((unsigned int)(31 - v8) < 0x20 ? allocCache_high << (31 - v8) : 0) | v5 & (LODWORD(s->allocCache) >> (v8 + 1)) | ((unsigned int)(v8 - 31) < 0x20 ? allocCache_high >> (v8 - 31) : 0);
  HIDWORD(s->allocCache) = v5 & (allocCache_high >> (v8 + 1));
  s->freeindex = v4;
  elemsize = s->elemsize;
  startAddr = s->startAddr;
  ++s->allocCount;
  return elemsize * result + startAddr;
}
// 8054416: variable 'v8' is possibly undefined

//----- (080544E0) --------------------------------------------------------
void __golang runtime___ptr_mcache__nextFree(
        runtime_mcache *c,
        runtime_spanClass spc,
        runtime_gclinkptr v,
        runtime_mspan *s,
        bool shouldhelpgc)
{
  uintptr FreeIndex; // eax
  runtime_mspan *v6; // ecx
  uintptr nelems; // edx
  uint16 v8; // bp
  unsigned int v9; // esi
  string v10; // [esp+0h] [ebp-24h]
  string v11; // [esp+0h] [ebp-24h]
  string v12; // [esp+0h] [ebp-24h]
  string v13; // [esp+0h] [ebp-24h]
  string v14; // [esp+0h] [ebp-24h]
  string v15; // [esp+0h] [ebp-24h]
  string v16; // [esp+0h] [ebp-24h]
  uint16 allocCount; // [esp+Ah] [ebp-1Ah]
  uintptr v18; // [esp+Ch] [ebp-18h]
  runtime_mspan *v19; // [esp+14h] [ebp-10h]
  runtime_mspan *v20; // [esp+14h] [ebp-10h]

  if ( spc >= 0x86u )
    runtime_panicindex();
  v19 = c->alloc[spc];
  FreeIndex = runtime___ptr_mspan__nextFreeIndex(v19);
  v6 = v19;
  nelems = v19->nelems;
  if ( FreeIndex == nelems )
  {
    if ( v19->allocCount != nelems )
    {
      v18 = v19->nelems;
      allocCount = v19->allocCount;
      runtime_printlock();
      v14.str = (uint8 *)"runtime: s.allocCount=";
      v14.len = 22;
      runtime_printstring(v14);
      runtime_printsp();
      runtime_printint(allocCount);
      runtime_printsp();
      v15.str = (uint8 *)"s.nelems=";
      v15.len = 9;
      runtime_printstring(v15);
      runtime_printsp();
      runtime_printint(v18);
      runtime_printnl();
      runtime_printunlock();
      v16.str = (uint8 *)"s.allocCount != s.nelems && freeIndex == s.nelems";
      v16.len = 49;
      runtime_throw(v16);
      BUG();
    }
    runtime_systemstack();
    v20 = c->alloc[spc];
    FreeIndex = runtime___ptr_mspan__nextFreeIndex(v20);
    v6 = v20;
  }
  if ( FreeIndex >= v6->nelems )
  {
    v13.str = (uint8 *)"freeIndex is not valid";
    v13.len = 22;
    runtime_throw(v13);
    BUG();
  }
  v8 = v6->allocCount + 1;
  v6->allocCount = v8;
  v9 = v6->nelems;
  if ( v8 > v9 )
  {
    runtime_printlock();
    v10.str = (uint8 *)"s.allocCount=";
    v10.len = 13;
    runtime_printstring(v10);
    runtime_printsp();
    runtime_printint(v8);
    runtime_printsp();
    v11.str = (uint8 *)"s.nelems=";
    v11.len = 9;
    runtime_printstring(v11);
    runtime_printsp();
    runtime_printint(v9);
    runtime_printnl();
    runtime_printunlock();
    v12.str = (uint8 *)"s.allocCount > s.nelems";
    v12.len = 23;
    runtime_throw(v12);
    BUG();
  }
}

//----- (08054730) --------------------------------------------------------
void *__golang runtime_mallocgc(uintptr size, runtime__type_0 *typ, bool needzero)
{
  uintptr align; // ecx
  runtime_g *v4; // ecx
  runtime_g *curg; // edx
  uintptr gcAssistBytes; // ecx
  bool v7; // cf
  int gcAssistBytes_high; // eax
  int v9; // eax
  int v10; // eax
  runtime_m *v11; // ecx
  runtime_mcache *v12; // eax
  bool v13; // si
  unsigned int tinyoffset; // edi
  uintptr tiny; // ebx
  void *v16; // ebx
  int v17; // eax
  int32 locks; // edx
  _DWORD *FreeFast; // eax
  char v20; // cl
  runtime_mcache *v21; // ebx
  uintptr v22; // edx
  uintptr v23; // ebp
  runtime_m *v24; // eax
  int v25; // ecx
  int32 v26; // edx
  runtime_g *v27; // eax
  uintptr v28; // ecx
  int v29; // edx
  int v30; // eax
  int v31; // eax
  int32 v32; // edx
  uintptr v33; // edx
  uintptr v34; // ebx
  uintptr ptrdata; // ecx
  uintptr v36; // edi
  uint8 v37; // dl
  runtime_spanClass v38; // dl
  _BYTE *v39; // ecx
  bool v40; // dl
  uintptr startAddr; // ecx
  string obj; // [esp+0h] [ebp-50h]
  string obja; // [esp+0h] [ebp-50h]
  string objb; // [esp+0h] [ebp-50h]
  uint64 *sysStat; // [esp+8h] [ebp-48h]
  uint64 *sysStata; // [esp+8h] [ebp-48h]
  uint64 *sysStatb; // [esp+8h] [ebp-48h]
  runtime__type_0 *v48; // [esp+Ch] [ebp-44h]
  runtime__type_0 *v49; // [esp+Ch] [ebp-44h]
  bool v50; // [esp+10h] [ebp-40h]
  char v51; // [esp+10h] [ebp-40h]
  bool v52; // [esp+10h] [ebp-40h]
  runtime_spanClass spc; // [esp+15h] [ebp-3Bh]
  bool shouldhelpgc; // [esp+16h] [ebp-3Ah]
  bool shouldhelpgca; // [esp+16h] [ebp-3Ah]
  uintptr scanSize; // [esp+18h] [ebp-38h]
  uintptr dataSize; // [esp+1Ch] [ebp-34h]
  uintptr dataSizea; // [esp+1Ch] [ebp-34h]
  void *x_0; // [esp+24h] [ebp-2Ch]
  _DWORD *x_0a; // [esp+24h] [ebp-2Ch]
  runtime_mspan *span; // [esp+28h] [ebp-28h]
  runtime_mspan *s; // [esp+2Ch] [ebp-24h] BYREF
  runtime_m *mp; // [esp+30h] [ebp-20h]
  runtime_m *mp_0; // [esp+34h] [ebp-1Ch]
  runtime_mcache *c; // [esp+38h] [ebp-18h]
  runtime_g *assistG; // [esp+3Ch] [ebp-14h]
  void (__golang *v67)(); // [esp+40h] [ebp-10h]
  runtime_mspan **p_s; // [esp+44h] [ebp-Ch]
  uintptr *p_size; // [esp+48h] [ebp-8h]
  _BOOL4 v70; // [esp+4Ch] [ebp-4h]

  s = 0;
  if ( runtime_gcphase == 2 )
  {
    objb.str = (uint8 *)"mallocgc called with gcphase == _GCmarktermination";
    objb.len = 50;
    runtime_throw(objb);
    BUG();
  }
  if ( !size )
    return &runtime_zerobase;
  if ( runtime_debug.sbrk )
  {
    if ( typ )
      align = typ->align;
    else
      align = 16;
    return runtime_persistentalloc(size, align, &runtime_memstats.other_sys);
  }
  if ( runtime_gcBlackenEnabled )
  {
    v4 = *(runtime_g **)(__readgsdword(0) - 4);
    curg = v4->m->curg;
    if ( !curg )
      curg = v4;
    gcAssistBytes = curg->gcAssistBytes;
    v7 = gcAssistBytes < size;
    gcAssistBytes_high = HIDWORD(curg->gcAssistBytes);
    LODWORD(curg->gcAssistBytes) = gcAssistBytes - size;
    v9 = gcAssistBytes_high - v7;
    HIDWORD(curg->gcAssistBytes) = v9;
    if ( v9 < 0 )
    {
      assistG = curg;
      runtime_gcAssistAlloc(curg);
      curg = assistG;
    }
  }
  else
  {
    curg = 0;
  }
  v10 = *(_DWORD *)(__readgsdword(0) - 4);
  ++*(_DWORD *)(*(_DWORD *)(v10 + 24) + 120);
  v11 = *(runtime_m **)(v10 + 24);
  if ( v11->mallocing )
  {
    obja.str = (uint8 *)"malloc deadlock";
    obja.len = 15;
    runtime_throw(obja);
    BUG();
  }
  if ( v11->gsignal == *(runtime_g **)(__readgsdword(0) - 4) )
  {
    obj.str = (uint8 *)"malloc during signal";
    obj.len = 20;
    runtime_throw(obj);
    BUG();
  }
  v11->mallocing = 1;
  v12 = *(runtime_mcache **)(*(_DWORD *)(*(_DWORD *)(__readgsdword(0) - 4) + 24) + 184);
  if ( typ )
    v13 = (typ->kind & 0x80u) != 0;
  else
    v13 = 1;
  mp = v11;
  dataSize = size;
  c = v12;
  assistG = curg;
  if ( size > 0x8000 )
  {
    s = 0;
    v67 = runtime_mallocgc_func1;
    p_s = &s;
    p_size = &size;
    v70 = needzero;
    BYTE1(v70) = v13;
    runtime_systemstack();
    s->freeindex = 1;
    s->allocCount = 1;
    startAddr = s->startAddr;
    size = s->elemsize;
    FreeFast = (_DWORD *)startAddr;
    v20 = 1;
  }
  else if ( v13 && size < 0x10 )
  {
    tinyoffset = v12->tinyoffset;
    if ( (size & 7) != 0 )
    {
      if ( (size & 3) != 0 )
      {
        if ( (size & 1) == 0 )
          tinyoffset = (tinyoffset + 1) & 0xFFFFFFFE;
      }
      else
      {
        tinyoffset = (tinyoffset + 3) & 0xFFFFFFFC;
      }
    }
    else
    {
      tinyoffset = (tinyoffset + 7) & 0xFFFFFFF8;
    }
    if ( tinyoffset + size <= 0x10 )
    {
      tiny = v12->tiny;
      if ( tiny )
      {
        v16 = (void *)(tinyoffset + tiny);
        v12->tinyoffset = tinyoffset + size;
        ++v12->local_tinyallocs;
        v11->mallocing = 0;
        v17 = *(_DWORD *)(__readgsdword(0) - 4);
        locks = v11->locks;
        v11->locks = locks - 1;
        if ( locks == 1 && *(_BYTE *)(v17 + 108) )
          *(_DWORD *)(v17 + 8) = -1314;
        return v16;
      }
    }
    FreeFast = (_DWORD *)runtime_nextFreeFast(v12->alloc[5]);
    if ( FreeFast )
    {
      v20 = 0;
    }
    else
    {
      runtime___ptr_mcache__nextFree(c, 5u, (runtime_gclinkptr)sysStat, (runtime_mspan *)v48, v50);
      FreeFast = sysStata;
      v20 = v51;
    }
    *FreeFast = 0;
    FreeFast[1] = 0;
    FreeFast[2] = 0;
    FreeFast[3] = 0;
    v21 = c;
    if ( size < c->tinyoffset || !c->tiny )
    {
      c->tiny = (uintptr)FreeFast;
      v21->tinyoffset = size;
    }
    size = 16;
  }
  else
  {
    if ( size > 0x3F8 )
    {
      if ( (size - 897) >> 7 >= 0xF9 )
        runtime_panicindex();
      v37 = runtime_size_to_class128[(size - 897) >> 7];
    }
    else
    {
      v36 = (size + 7) >> 3;
      if ( v36 >= 0x81 )
        runtime_panicindex();
      v37 = runtime_size_to_class8[v36];
    }
    if ( v37 >= 0x43u )
      runtime_panicindex();
    size = runtime_class_to_size[v37];
    v38 = v13 | (2 * v37);
    if ( v38 >= 0x86u )
      runtime_panicindex();
    spc = v38;
    span = v12->alloc[v38];
    FreeFast = (_DWORD *)runtime_nextFreeFast(span);
    if ( FreeFast )
    {
      v39 = span;
      v40 = 0;
    }
    else
    {
      runtime___ptr_mcache__nextFree(c, spc, (runtime_gclinkptr)sysStat, (runtime_mspan *)v48, v50);
      FreeFast = sysStatb;
      v39 = v49;
      v40 = v52;
    }
    if ( needzero && v39[61] )
    {
      x_0a = FreeFast;
      shouldhelpgca = v40;
      runtime_memclrNoHeapPointers();
      FreeFast = x_0a;
      v40 = shouldhelpgca;
    }
    v20 = v40;
  }
  x_0 = FreeFast;
  shouldhelpgc = v20;
  if ( v13 )
  {
    v22 = 0;
    v23 = dataSize;
  }
  else
  {
    if ( (runtime__type_0 *)runtime_deferType == typ )
      v33 = 28;
    else
      v33 = dataSize;
    dataSizea = v33;
    runtime_heapBitsSetType((uintptr)FreeFast, size, v33, typ);
    if ( dataSizea <= typ->size )
    {
      ptrdata = typ->ptrdata;
      v23 = dataSizea;
    }
    else
    {
      v34 = typ->ptrdata;
      v23 = dataSizea;
      if ( v34 )
        ptrdata = dataSizea - typ->size + v34;
      else
        ptrdata = 0;
    }
    c->local_scan += ptrdata;
    v22 = ptrdata;
  }
  scanSize = v22;
  runtime_publicationBarrier();
  if ( runtime_gcphase )
    runtime_gcmarknewobject((uintptr)x_0, size, scanSize);
  v24 = mp;
  mp->mallocing = 0;
  v25 = *(_DWORD *)(__readgsdword(0) - 4);
  v26 = v24->locks;
  v24->locks = v26 - 1;
  if ( v26 == 1 && *(_BYTE *)(v25 + 108) )
    *(_DWORD *)(v25 + 8) = -1314;
  if ( runtime_debug.allocfreetrace )
    runtime_tracealloc(x_0, size, typ);
  if ( runtime_MemProfileRate > 0 )
  {
    if ( size >= runtime_MemProfileRate || (signed __int32)size >= c->next_sample )
    {
      v30 = *(_DWORD *)(__readgsdword(0) - 4);
      ++*(_DWORD *)(*(_DWORD *)(v30 + 24) + 120);
      mp_0 = *(runtime_m **)(v30 + 24);
      runtime_profilealloc(mp_0, x_0, size);
      v31 = *(_DWORD *)(__readgsdword(0) - 4);
      v32 = mp_0->locks;
      mp_0->locks = v32 - 1;
      if ( v32 == 1 && *(_BYTE *)(v31 + 108) )
        *(_DWORD *)(v31 + 8) = -1314;
    }
    else
    {
      c->next_sample -= size;
    }
  }
  v27 = assistG;
  if ( assistG )
  {
    v28 = assistG->gcAssistBytes;
    v7 = v28 < size - v23;
    v29 = HIDWORD(assistG->gcAssistBytes);
    LODWORD(assistG->gcAssistBytes) = v28 - (size - v23);
    HIDWORD(v27->gcAssistBytes) = v29 - v7;
  }
  if ( shouldhelpgc && runtime_gcTrigger_test((runtime_gcTrigger_0)1uLL) )
    runtime_gcStart(0, (runtime_gcTrigger_0)1uLL);
  return x_0;
}
// 8054C03: variable 'sysStat' is possibly undefined
// 8054C03: variable 'v48' is possibly undefined
// 8054C03: variable 'v50' is possibly undefined
// 8054C08: variable 'sysStata' is possibly undefined
// 8054C0C: variable 'v51' is possibly undefined
// 8054D16: variable 'sysStatb' is possibly undefined
// 8054D1A: variable 'v49' is possibly undefined
// 8054D1E: variable 'v52' is possibly undefined

//----- (08054E90) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
runtime_mspan *__golang runtime_largeAlloc(uintptr size, bool needzero, bool noscan)
{
  uintptr v3; // eax
  string spanBytes; // [esp+0h] [ebp-1Ch]
  string spanBytesa; // [esp+0h] [ebp-1Ch]
  runtime_heapBits_0 callerSweepPages; // [esp+4h] [ebp-18h]
  runtime_heapBits_0 callerSweepPagesa; // [esp+4h] [ebp-18h]
  bool v8; // [esp+Ch] [ebp-10h]
  runtime_mspan *v9; // [esp+Ch] [ebp-10h]
  bool v10; // [esp+10h] [ebp-Ch]
  uintptr npages; // [esp+14h] [ebp-8h]
  runtime_mspan *result; // [esp+2Ch] [ebp+10h]

  if ( size + 0x2000 < size )
  {
    spanBytesa.str = (uint8 *)"out of memory";
    spanBytesa.len = 13;
    runtime_throw(spanBytesa);
    BUG();
  }
  v3 = size >> 13;
  if ( (size & 0x1FFF) != 0 )
    ++v3;
  npages = v3;
  runtime_deductSweepCredit(v3 << 13, v3);
  runtime___ptr_mheap__alloc(&runtime_mheap_, npages, *(&needzero + 1), v8, v10);
  if ( !v9 )
  {
    spanBytes.str = (uint8 *)"out of memory";
    spanBytes.len = 13;
    runtime_throw(spanBytes);
    BUG();
  }
  v9->limit = size + v9->startAddr;
  runtime_heapBitsForSpan(v9->startAddr, callerSweepPages);
  runtime_heapBits_initSpan(callerSweepPagesa, v9);
  return result;
}
// 8054E90: variables would overlap: ^24.1 and ^24.2
// 8054E90: inconsistent variable size for '^24.1(needzero)'

//----- (08054FA0) --------------------------------------------------------
void *__golang runtime_newobject(runtime__type_0 *typ)
{
  return runtime_mallocgc(typ->size, typ, 1);
}

//----- (08054FE0) --------------------------------------------------------
void *__golang reflect_unsafe_New(runtime__type_0 *typ)
{
  return runtime_newobject(typ);
}

//----- (08055020) --------------------------------------------------------
void *__golang runtime_newarray(runtime__type_0 *typ, __int32 n)
{
  runtime__type_0 *v2; // edx
  uintptr v3; // ebx
  unsigned int v4; // eax
  interface_{} size; // [esp+0h] [ebp-10h]

  if ( n < 0
    || ((v2 = typ, v3 = typ->size, typ->size >= 0x21) ? (v4 = 0xFFFFFFFF / v3, v2 = typ) : (runtime__type_0 *)(v4 = runtime_maxElems[v3]),
        n > v4) )
  {
    size._type = (runtime__type_0 *)&e;
    size.data = &runtime_statictmp_14;
    runtime_gopanic(size);
    BUG();
  }
  return runtime_mallocgc(n * v3, v2, 1);
}

//----- (080550B0) --------------------------------------------------------
void __golang runtime_profilealloc(runtime_m *mp, void *x, uintptr size)
{
  mp->mcache->next_sample = runtime_nextSample();
  runtime_mProf_Malloc(x, size);
}

//----- (08055100) --------------------------------------------------------
int32 __golang runtime_nextSample()
{
  __int32 v0; // eax
  int v1; // ecx
  int v2; // edx
  unsigned __int64 v3; // kr00_8
  int v4; // ebx
  double v5; // xmm0_8
  int64 y; // [esp+0h] [ebp-38h]
  __int64 y_4; // [esp+4h] [ebp-34h]
  __int32 period; // [esp+10h] [ebp-28h]
  int v9; // [esp+14h] [ebp-24h]
  double v10; // [esp+20h] [ebp-18h]
  double v11; // [esp+28h] [ebp-10h]
  double v12; // [esp+30h] [ebp-8h]

  v0 = runtime_MemProfileRate;
  if ( runtime_MemProfileRate <= 117440512 )
  {
    if ( !runtime_MemProfileRate )
      return 0;
  }
  else
  {
    v0 = 117440512;
  }
  period = v0;
  v1 = *(_DWORD *)(*(_DWORD *)(__readgsdword(0) - 4) + 24);
  *(_DWORD *)(v1 + 148) = (*(int *)(v1 + 148) >> 31) & 0xA8888EEF ^ (2 * *(_DWORD *)(v1 + 148));
  runtime_uint32tofloat64();
  v2 = (HIDWORD(y_4) >> 20) & 0x7FF;
  v4 = (HIDWORD(y_4) >> 15) & 0x1F;
  v3 = (unsigned int)v4 + 1LL;
  if ( v3 >= 0x21 )
    runtime_panicindex();
  v9 = y_4 >> 27;
  v12 = runtime_fastlog2Table[v4];
  v11 = runtime_fastlog2Table[(_DWORD)v3];
  LODWORD(y) = v2 - 1023;
  HIDWORD(y) = __CFADD__(v2, -1023) - 1;
  v10 = runtime_int64tofloat64(y);
  v5 = v10 + v12 + 0.00000095367431640625 * ((v11 - v12) * runtime_uint64tofloat64(v9 & 0xFFFFFLL)) - 26.0;
  if ( v5 > 0.0 )
    v5 = 0.0;
  return (int)(v5 * ((double)period * -0.6931471805599453)) + 1;
}
// 8055181: variable 'y_4' is possibly undefined

//----- (080552C0) --------------------------------------------------------
void *__golang runtime_persistentalloc(uintptr size, uintptr align, uint64 *sysStat)
{
  void *p[6]; // [esp+4h] [ebp-18h] BYREF

  p[0] = 0;
  ((void (*)(void))loc_808FD8B)();
  p[1] = runtime_persistentalloc_func1;
  p[2] = p;
  p[3] = (void *)size;
  p[4] = (void *)align;
  p[5] = sysStat;
  runtime_systemstack();
  return p[0];
}

//----- (08055340) --------------------------------------------------------
void *__golang runtime_persistentalloc1(uintptr size, uintptr align, uint64 *sysStat)
{
  uintptr v3; // eax
  uintptr v4; // ecx
  int v5; // edx
  runtime_m *v6; // edx
  runtime_puintptr v7; // ebx
  uintptr *p_persistentAlloc; // ebx
  int v9; // ecx
  void *v10; // ecx
  struct_{_runtime_mutex__runtime_persistentAlloc_} *v11; // eax
  char *base; // edx
  uintptr v13; // ebx
  char *v14; // ecx
  int v15; // edx
  int32 locks; // esi
  string n; // [esp+0h] [ebp-20h]
  string na; // [esp+0h] [ebp-20h]
  string nb; // [esp+0h] [ebp-20h]
  string nc; // [esp+0h] [ebp-20h]
  void *src; // [esp+8h] [ebp-18h]
  uintptr a; // [esp+Ch] [ebp-14h]
  char *p; // [esp+14h] [ebp-Ch]
  runtime_m *mp; // [esp+18h] [ebp-8h]

  v3 = size;
  if ( !size )
  {
    nc.str = (uint8 *)"persistentalloc: size == 0";
    nc.len = 26;
    runtime_throw(nc);
    BUG();
  }
  v4 = align;
  if ( align )
  {
    if ( ((align - 1) & align) != 0 )
    {
      nb.str = (uint8 *)"persistentalloc: align is not a power of 2";
      nb.len = 42;
      runtime_throw(nb);
      BUG();
    }
    if ( align > 0x2000 )
    {
      na.str = (uint8 *)"persistentalloc: align is too large";
      na.len = 35;
      runtime_throw(na);
      BUG();
    }
  }
  else
  {
    v4 = 8;
  }
  if ( size >= 0x10000 )
    return runtime_sysAlloc(size, sysStat);
  a = v4;
  v5 = *(_DWORD *)(__readgsdword(0) - 4);
  ++*(_DWORD *)(*(_DWORD *)(v5 + 24) + 120);
  v6 = *(runtime_m **)(v5 + 24);
  mp = v6;
  if ( v6 && (v7 = v6->p) != 0 )
  {
    p_persistentAlloc = (uintptr *)(v7 + 2360);
  }
  else
  {
    runtime_lock(&runtime_globalAlloc.mutex);
    v3 = size;
    v4 = a;
    p_persistentAlloc = (uintptr *)&runtime_globalAlloc.persistentAlloc;
  }
  v9 = (v4 + p_persistentAlloc[1] - 1) & ~(v4 - 1);
  p_persistentAlloc[1] = v9;
  if ( v3 + v9 <= 0x40000 && *p_persistentAlloc )
  {
    v11 = (struct_{_runtime_mutex__runtime_persistentAlloc_} *)p_persistentAlloc;
  }
  else
  {
    src = runtime_sysAlloc(0x40000u, &runtime_memstats.other_sys);
    v10 = src;
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
    {
      runtime_writebarrierptr(p_persistentAlloc, (uintptr)src);
      v11 = (struct_{_runtime_mutex__runtime_persistentAlloc_} *)p_persistentAlloc;
      v10 = src;
    }
    else
    {
      v11 = (struct_{_runtime_mutex__runtime_persistentAlloc_} *)p_persistentAlloc;
      *p_persistentAlloc = (uintptr)src;
    }
    if ( !v10 )
    {
      if ( v11 == (struct_{_runtime_mutex__runtime_persistentAlloc_} *)&runtime_globalAlloc.persistentAlloc )
        runtime_unlock(&runtime_globalAlloc.mutex);
      n.str = (uint8 *)"runtime: cannot allocate memory";
      n.len = 31;
      runtime_throw(n);
      BUG();
    }
    v11->persistentAlloc.base = 0;
  }
  base = (char *)v11->persistentAlloc.base;
  v13 = size;
  v14 = &base[v11->mutex.key];
  v11->persistentAlloc.base = &base[size];
  v15 = *(_DWORD *)(__readgsdword(0) - 4);
  locks = mp->locks;
  mp->locks = locks - 1;
  if ( locks == 1 && *(_BYTE *)(v15 + 108) )
    *(_DWORD *)(v15 + 8) = -1314;
  p = v14;
  if ( v11 == (struct_{_runtime_mutex__runtime_persistentAlloc_} *)&runtime_globalAlloc.persistentAlloc )
  {
    runtime_unlock(&runtime_globalAlloc.mutex);
    v14 = p;
    v13 = size;
  }
  if ( sysStat != &runtime_memstats.other_sys )
  {
    runtime_mSysStatInc(sysStat, v13);
    runtime_mSysStatDec(&runtime_memstats.other_sys, size);
    return p;
  }
  return v14;
}

//----- (080555E0) --------------------------------------------------------
void __golang runtime_gcmarkwb_m(uintptr *slot, uintptr ptr)
{
  uintptr v2; // eax
  int v3; // eax

  if ( runtime_writeBarrier.needed )
  {
    if ( (unsigned int)slot >= 0x1000 && *slot )
      runtime_shade(*slot);
    if ( ptr && ptr >= dword_81493A8 && ptr < dword_81493AC )
    {
      v2 = (ptr - dword_81493A8) >> 13;
      if ( v2 >= dword_814910C )
        runtime_panicindex();
      v3 = *(_DWORD *)(dword_8149108 + 4 * v2);
      if ( v3 && ptr >= *(_DWORD *)(v3 + 12) && ptr < *(_DWORD *)(v3 + 80) && *(_BYTE *)(v3 + 60) == 1 )
        runtime_shade(ptr);
    }
  }
}
// 8149108: using guessed type int dword_8149108;
// 814910C: using guessed type int dword_814910C;
// 81493A8: using guessed type int dword_81493A8;
// 81493AC: using guessed type int dword_81493AC;

//----- (080556A0) --------------------------------------------------------
void __golang runtime_writebarrierptr_prewrite1(uintptr *dst, uintptr src)
{
  int v2; // eax
  int v3; // ecx
  int v4; // eax
  int v5; // edx
  int v6; // ecx
  int32 locks; // edx
  runtime_m *mp; // [esp+4h] [ebp-14h]

  v2 = *(_DWORD *)(__readgsdword(0) - 4);
  ++*(_DWORD *)(*(_DWORD *)(v2 + 24) + 120);
  v3 = *(_DWORD *)(v2 + 24);
  if ( *(_BYTE *)(v3 + 142) || *(int *)(v3 + 128) > 0 )
  {
    v4 = *(_DWORD *)(__readgsdword(0) - 4);
    v5 = *(_DWORD *)(v3 + 120);
    *(_DWORD *)(v3 + 120) = v5 - 1;
    if ( v5 == 1 )
    {
      if ( *(_BYTE *)(v4 + 108) )
        *(_DWORD *)(v4 + 8) = -1314;
    }
  }
  else
  {
    mp = *(runtime_m **)(v2 + 24);
    runtime_systemstack();
    mp->inwb = 0;
    v6 = *(_DWORD *)(__readgsdword(0) - 4);
    locks = mp->locks;
    mp->locks = locks - 1;
    if ( locks == 1 && *(_BYTE *)(v6 + 108) )
      *(_DWORD *)(v6 + 8) = -1314;
  }
}

//----- (08055770) --------------------------------------------------------
void __golang runtime_writebarrierptr(uintptr *dst, uintptr src)
{
  uintptr v2; // eax

  if ( runtime_writeBarrier.cgo )
    runtime_cgoCheckWriteBarrier(dst, src);
  if ( runtime_writeBarrier.needed )
  {
    v2 = src;
    if ( src )
    {
      if ( src < 0x1000 )
      {
        runtime_systemstack();
        v2 = src;
      }
    }
    runtime_writebarrierptr_prewrite1(dst, v2);
    *dst = src;
  }
  else
  {
    *dst = src;
  }
}

//----- (08055810) --------------------------------------------------------
void __golang runtime_writebarrierptr_prewrite(uintptr *dst, uintptr src)
{
  uintptr v2; // eax

  if ( runtime_writeBarrier.cgo )
    runtime_cgoCheckWriteBarrier(dst, src);
  if ( runtime_writeBarrier.needed )
  {
    v2 = src;
    if ( src )
    {
      if ( src < 0x1000 )
      {
        runtime_systemstack();
        v2 = src;
      }
    }
    runtime_writebarrierptr_prewrite1(dst, v2);
  }
}

//----- (08055880) --------------------------------------------------------
void __golang runtime_typedmemmove(runtime__type_0 *typ, void *dst, void *src)
{
  if ( (typ->kind & 0x80u) == 0 )
    runtime_bulkBarrierPreWrite((uintptr)dst, (uintptr)src, typ->size);
  runtime_memmove();
  if ( runtime_writeBarrier.cgo )
    runtime_cgoCheckMemmove(typ, dst, src, 0, typ->size);
}

//----- (08055910) --------------------------------------------------------
void __golang reflect_typedmemmove(runtime__type_0 *typ, void *dst, void *src)
{
  runtime_typedmemmove(typ, dst, src);
}

//----- (08055950) --------------------------------------------------------
void __golang reflect_typedmemmovepartial(runtime__type_0 *typ, void *dst, void *src, uintptr off, uintptr size)
{
  uintptr v5; // ecx
  uintptr v6; // edx
  char *v7; // edi
  char *v8; // eax

  if ( runtime_writeBarrier.needed && (typ->kind & 0x80u) == 0 )
  {
    v5 = size;
    if ( size >= 4 )
    {
      v6 = -off & 3;
      if ( v6 )
      {
        v5 = size - v6;
        v7 = (char *)dst + v6;
        v8 = (char *)src + v6;
      }
      else
      {
        v7 = (char *)dst;
        v8 = (char *)src;
      }
      runtime_bulkBarrierPreWrite((uintptr)v7, (uintptr)v8, v5 & 0xFFFFFFFC);
    }
  }
  runtime_memmove();
  if ( runtime_writeBarrier.cgo )
    runtime_cgoCheckMemmove(typ, dst, src, off, size);
}

//----- (08055A50) --------------------------------------------------------
void __golang runtime_reflectcallmove(runtime__type_0 *typ, void *dst, void *src, uintptr size)
{
  if ( runtime_writeBarrier.needed && typ && (typ->kind & 0x80u) == 0 && size >= 4 )
    runtime_bulkBarrierPreWrite((uintptr)dst, (uintptr)src, size);
  runtime_memmove();
}

//----- (08055AD0) --------------------------------------------------------
__int32 __golang runtime_typedslicecopy(runtime__type_0 *typ, runtime_slice_0 dst, runtime_slice_0 src)
{
  __int32 len; // edx
  void *v4; // edx
  __int32 n; // [esp+20h] [ebp-20h]
  void *srcp; // [esp+24h] [ebp-1Ch] BYREF
  void *dstp[6]; // [esp+28h] [ebp-18h] BYREF

  len = src.len;
  if ( dst.len <= src.len )
    len = dst.len;
  if ( !len )
    return 0;
  n = len;
  dstp[0] = dst.array;
  srcp = src.array;
  if ( runtime_writeBarrier.cgo )
    runtime_cgoCheckSliceCopy(typ, dst, src, len);
  if ( runtime_writeBarrier.needed )
  {
    ((void (*)(void))loc_808FD8B)();
    dstp[1] = runtime_typedslicecopy_func1;
    dstp[2] = &srcp;
    dstp[3] = dstp;
    dstp[4] = v4;
    dstp[5] = &typ;
    runtime_systemstack();
  }
  else
  {
    runtime_memmove();
  }
  return n;
}
// 8055B42: variable 'v4' is possibly undefined

//----- (08055BF0) --------------------------------------------------------
void __golang runtime_typedmemclr(runtime__type_0 *typ, void *ptr)
{
  if ( (typ->kind & 0x80u) == 0 )
    runtime_bulkBarrierPreWrite((uintptr)ptr, 0, typ->size);
  runtime_memclrNoHeapPointers();
}

//----- (08055C40) --------------------------------------------------------
void __golang runtime_memclrHasPointers(void *ptr, uintptr n)
{
  runtime_bulkBarrierPreWrite((uintptr)ptr, 0, n);
  runtime_memclrNoHeapPointers();
}

//----- (08055C80) --------------------------------------------------------
void __golang runtime___ptr_mheap__mapBits(runtime_mheap_0 *h, uintptr arena_used)
{
  uintptr bitmap_mapped; // edx
  uintptr v3; // ebx
  uintptr _r2; // [esp+10h] [ebp-4h]

  bitmap_mapped = h->bitmap_mapped;
  v3 = (((((arena_used - dword_81493A8) >> 4) + 0x1FFF) & 0xFFFFE000) + runtime_physPageSize - 1) & ~(runtime_physPageSize - 1);
  if ( bitmap_mapped < v3 )
  {
    _r2 = (((((arena_used - dword_81493A8) >> 4) + 0x1FFF) & 0xFFFFE000) + runtime_physPageSize - 1) & ~(runtime_physPageSize - 1);
    runtime_sysMap((void *)(h->bitmap - v3), v3 - bitmap_mapped, h->arena_reserved, &runtime_memstats.gc_sys);
    h->bitmap_mapped = _r2;
  }
}
// 81493A8: using guessed type int dword_81493A8;

//----- (08055D30) --------------------------------------------------------
void __golang runtime___ptr_mspan__refillAllocCache(runtime_mspan *s, uintptr whichByte)
{
  runtime_gcBits *v2; // ecx
  int v3; // edx
  int v4; // ebx
  int v5; // ecx
  int v6; // [esp+0h] [ebp-8h]
  int v7; // [esp+4h] [ebp-4h]

  v2 = &s->allocBits[whichByte];
  v3 = *(unsigned __int16 *)v2 | (v2[2] << 16) | (v2[3] << 24);
  v7 = v2[4];
  v6 = v2[5];
  v4 = v2[6];
  v5 = v2[7];
  LODWORD(s->allocCache) = ~v3;
  HIDWORD(s->allocCache) = ~((v5 << 24) | (v4 << 16) | (v6 << 8) | v7);
}

//----- (08055DD0) --------------------------------------------------------
uintptr __golang runtime___ptr_mspan__nextFreeIndex(runtime_mspan *s)
{
  uintptr freeindex; // ecx
  uintptr nelems; // edx
  int v3; // eax
  uintptr v4; // ecx
  unsigned int v5; // eax
  int v6; // edx
  runtime_mspan *v7; // ebx
  unsigned int v8; // eax
  string v9; // [esp+0h] [ebp-20h]
  int v10; // [esp+8h] [ebp-18h]
  unsigned int snelems; // [esp+Ch] [ebp-14h]
  uintptr sfreeindex; // [esp+10h] [ebp-10h]
  unsigned int sfreeindexa; // [esp+10h] [ebp-10h]
  uintptr sfreeindexb; // [esp+10h] [ebp-10h]
  uintptr result; // [esp+14h] [ebp-Ch]
  unsigned int allocCache_high; // [esp+1Ch] [ebp-4h]

  freeindex = s->freeindex;
  nelems = s->nelems;
  if ( nelems == freeindex )
    return s->freeindex;
  if ( freeindex > nelems )
  {
    v9.str = (uint8 *)"s.freeindex > s.nelems";
    v9.len = 22;
    runtime_throw(v9);
    BUG();
  }
  sfreeindex = s->freeindex;
  snelems = s->nelems;
  runtime_internal_sys_Ctz64();
  v3 = v10;
  v4 = sfreeindex;
  while ( v3 == 64 )
  {
    v5 = (v4 + 64) & 0xFFFFFFC0;
    if ( v5 >= snelems )
    {
      s->freeindex = snelems;
      return snelems;
    }
    sfreeindexa = (v4 + 64) & 0xFFFFFFC0;
    runtime___ptr_mspan__refillAllocCache(s, v5 >> 3);
    runtime_internal_sys_Ctz64();
    v3 = v10;
    v4 = sfreeindexa;
  }
  if ( v4 + v3 >= snelems )
  {
    s->freeindex = snelems;
    return snelems;
  }
  else
  {
    result = v4 + v3;
    allocCache_high = HIDWORD(s->allocCache);
    v6 = -((unsigned int)(v3 + 1) < 0x20);
    v7 = s;
    LODWORD(s->allocCache) = ((unsigned int)(v3 - 31) < 0x20 ? allocCache_high >> (v3 - 31) : 0) | v6 & (LODWORD(s->allocCache) >> (v3 + 1)) | ((unsigned int)(31 - v3) < 0x20 ? allocCache_high << (31 - v3) : 0);
    HIDWORD(s->allocCache) = v6 & (allocCache_high >> (v3 + 1));
    v8 = v4 + v3 + 1;
    if ( (v8 & 0x3F) == 0 && v8 != snelems )
    {
      sfreeindexb = v8;
      runtime___ptr_mspan__refillAllocCache(s, v8 >> 3);
      v8 = sfreeindexb;
      v7 = s;
    }
    v7->freeindex = v8;
    return result;
  }
}
// 8055E1D: variable 'v10' is possibly undefined

//----- (08055F70) --------------------------------------------------------
runtime_markBits_0 __golang runtime_markBitsForAddr(uintptr p)
{
  uintptr v1; // edx
  int v2; // eax
  uintptr v3; // edx
  unsigned int v4; // ecx
  int v5; // ecx
  unsigned __int64 v6; // rax
  unsigned __int8 v7; // bl
  int v8; // edi
  uintptr v9; // edx
  runtime_markBits_0 _r1; // [esp+Ch] [ebp+8h]

  v1 = p;
  if ( p && p >= dword_81493A8 && p < dword_81493AC )
  {
    v9 = (p - dword_81493A8) >> 13;
    if ( v9 >= dword_814910C )
      runtime_panicindex();
    v2 = *(_DWORD *)(dword_8149108 + 4 * v9);
    v1 = p;
  }
  else
  {
    v2 = 0;
  }
  v3 = v1 - *(_DWORD *)(v2 + 12);
  if ( v3 )
  {
    if ( *(_WORD *)(v2 + 54) )
    {
      v4 = *(_BYTE *)(v2 + 62) < 0x20u ? v3 >> *(_BYTE *)(v2 + 62) : 0;
    }
    else
    {
      v5 = v2;
      v6 = (*(_BYTE *)(v2 + 62) < 0x20u ? v3 >> *(_BYTE *)(v2 + 62) : 0)
         * (unsigned __int64)*(unsigned __int16 *)(v2 + 52);
      v7 = *(_BYTE *)(v5 + 63);
      v8 = v5;
      v4 = (v7 < 0x20u ? (unsigned int)v6 >> v7 : 0) | ((unsigned __int8)(32 - v7) < 0x20u ? HIDWORD(v6) << (32 - v7) : 0) | ((unsigned __int8)(v7 - 32) < 0x20u ? HIDWORD(v6) >> (v7 - 32) : 0);
      v2 = v8;
    }
  }
  else
  {
    v4 = 0;
  }
  _r1.bytep = (uint8 *)((v4 >> 3) + *(_DWORD *)(v2 + 44));
  _r1.mask = 1 << (v4 & 7);
  _r1.index = v4;
  return _r1;
}
// 8149108: using guessed type int dword_8149108;
// 814910C: using guessed type int dword_814910C;
// 81493A8: using guessed type int dword_81493A8;
// 81493AC: using guessed type int dword_81493AC;

//----- (08056090) --------------------------------------------------------
void __golang runtime_markBits_setMarked(runtime_markBits_0 m)
{
  runtime_internal_atomic_Or8();
}

//----- (080560D0) --------------------------------------------------------
void __golang runtime_heapBitsForSpan(uintptr base, runtime_heapBits_0 hbits)
{
  string s; // [esp+0h] [ebp-10h]
  string sa; // [esp+0h] [ebp-10h]
  string sb; // [esp+0h] [ebp-10h]
  string sc; // [esp+0h] [ebp-10h]
  string sd; // [esp+0h] [ebp-10h]
  int v; // [esp+8h] [ebp-8h]
  int v_4; // [esp+Ch] [ebp-4h]

  v_4 = dword_81493A8;
  if ( base < dword_81493A8 || base >= dword_81493AC )
  {
    v = dword_81493AC;
    runtime_printlock();
    s.str = (uint8 *)"runtime: base ";
    s.len = 14;
    runtime_printstring(s);
    runtime_printhex(base);
    sa.str = (uint8 *)" not in range [";
    sa.len = 15;
    runtime_printstring(sa);
    runtime_printhex((unsigned int)v_4);
    sb.str = (uint8 *)",";
    sb.len = 1;
    runtime_printstring(sb);
    runtime_printhex((unsigned int)v);
    sc.str = (uint8 *)")\n";
    sc.len = 2;
    runtime_printstring(sc);
    runtime_printunlock();
    sd.str = (uint8 *)"heapBitsForSpan: base out of range";
    sd.len = 34;
    runtime_throw(sd);
    BUG();
  }
}
// 80E0D89: using guessed type char asc_80E0D89;
// 81493A0: using guessed type int dword_81493A0;
// 81493A8: using guessed type int dword_81493A8;
// 81493AC: using guessed type int dword_81493AC;

//----- (08056200) --------------------------------------------------------
void __golang runtime_heapBitsForObject(
        uintptr p,
        uintptr refBase,
        uintptr refOff,
        uintptr base,
        runtime_heapBits_0 hbits,
        runtime_mspan *s,
        uintptr objIndex)
{
  uintptr v7; // edx
  int v8; // ebp
  bool v9; // zf
  uintptr v10; // esi
  string labela; // [esp+0h] [ebp-24h]
  string label; // [esp+0h] [ebp-24h]
  string labelb; // [esp+0h] [ebp-24h]
  string labelc; // [esp+0h] [ebp-24h]
  string labeld; // [esp+0h] [ebp-24h]
  string labele; // [esp+0h] [ebp-24h]
  string labelf; // [esp+0h] [ebp-24h]
  string labelg; // [esp+0h] [ebp-24h]
  string labelh; // [esp+0h] [ebp-24h]
  string labeli; // [esp+0h] [ebp-24h]
  string labelj; // [esp+0h] [ebp-24h]
  string labelk; // [esp+0h] [ebp-24h]
  uintptr _r0; // [esp+10h] [ebp-14h]
  uintptr idx; // [esp+14h] [ebp-10h]
  unsigned int v; // [esp+18h] [ebp-Ch]
  unsigned int v_4; // [esp+1Ch] [ebp-8h]

  if ( p >= dword_81493A8 && p < dword_81493AC )
  {
    v7 = (p - dword_81493A8) >> 13;
    if ( v7 >= dword_814910C )
      runtime_panicindex();
    v8 = *(_DWORD *)(dword_8149108 + 4 * v7);
    v9 = v8 == 0;
    if ( v8 )
    {
      v10 = *(_DWORD *)(v8 + 12);
      if ( p >= v10 )
      {
        if ( p < *(_DWORD *)(v8 + 80) )
        {
          if ( *(_BYTE *)(v8 + 60) == 1 )
            return;
          v9 = v8 == 0;
        }
        else
        {
          v9 = v8 == 0;
        }
      }
      else
      {
        v9 = v8 == 0;
      }
    }
    if ( !v9 && *(_BYTE *)(v8 + 60) != 2 && runtime_debug.invalidptr )
    {
      idx = (p - dword_81493A8) >> 13;
      runtime_printlock();
      runtime_printlock();
      labela.str = (uint8 *)"runtime: pointer ";
      labela.len = 17;
      runtime_printstring(labela);
      runtime_printhex(p);
      runtime_printunlock();
      if ( *(_BYTE *)(v8 + 60) == 1 )
      {
        runtime_printlock();
        label.str = (uint8 *)" to unused region of span";
        label.len = 25;
      }
      else
      {
        runtime_printlock();
        label.str = (uint8 *)" to unallocated span";
        label.len = 20;
      }
      runtime_printstring(label);
      runtime_printunlock();
      v_4 = *(unsigned __int8 *)(v8 + 60);
      v = *(_DWORD *)(v8 + 80);
      _r0 = *(_DWORD *)(v8 + 12);
      runtime_printlock();
      labelb.str = (uint8 *)" idx=";
      labelb.len = 5;
      runtime_printstring(labelb);
      runtime_printhex(idx);
      labelc.str = (uint8 *)" span.base()=";
      labelc.len = 13;
      runtime_printstring(labelc);
      runtime_printhex(_r0);
      labeld.str = (uint8 *)" span.limit=";
      labeld.len = 12;
      runtime_printstring(labeld);
      runtime_printhex(v);
      labele.str = (uint8 *)" span.state=";
      labele.len = 12;
      runtime_printstring(labele);
      runtime_printint(v_4);
      labelf.str = (uint8 *)"\n";
      labelf.len = 1;
      runtime_printstring(labelf);
      runtime_printunlock();
      if ( refBase )
      {
        runtime_printlock();
        labelg.str = (uint8 *)"runtime: found in object at *(";
        labelg.len = 30;
        runtime_printstring(labelg);
        runtime_printhex(refBase);
        labelh.str = (uint8 *)"+";
        labelh.len = 1;
        runtime_printstring(labelh);
        runtime_printhex(refOff);
        labeli.str = (uint8 *)")\n";
        labeli.len = 2;
        runtime_printstring(labeli);
        runtime_printunlock();
        labelj.str = (uint8 *)"object";
        labelj.len = 6;
        runtime_gcDumpObject(labelj, refBase, refOff);
      }
      *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(__readgsdword(0) - 4) + 24) + 461) = 2;
      labelk.str = (uint8 *)"found bad pointer in Go heap (incorrect use of unsafe or cgo?)";
      labelk.len = 62;
      runtime_throw(labelk);
      BUG();
    }
  }
}
// 80E0D88: using guessed type char asc_80E0D88;
// 8149108: using guessed type int dword_8149108;
// 814910C: using guessed type int dword_814910C;
// 81493A0: using guessed type int dword_81493A0;
// 81493A8: using guessed type int dword_81493A8;
// 81493AC: using guessed type int dword_81493AC;

//----- (08056610) --------------------------------------------------------
void __golang runtime_heapBits_setCheckmarked(runtime_heapBits_0 h, uintptr size)
{
  runtime_internal_atomic_Or8();
}

//----- (08056690) --------------------------------------------------------
void __golang runtime_bulkBarrierPreWrite(uintptr dst, uintptr src, uintptr size)
{
  uintptr v3; // ebx
  uintptr v4; // ebp
  uintptr v5; // ecx
  uintptr v6; // eax
  int v7; // edx
  uint8 *v8; // edx
  unsigned int v9; // eax
  unsigned int j; // ebx
  uintptr v11; // edi
  unsigned int i; // esi
  uintptr *v13; // eax
  int *v14; // eax
  int k; // ebx
  int v16; // ebp
  uintptr v17; // esi
  int *v18; // ecx
  int m; // ebx
  int v20; // ebp
  uintptr v21; // esi
  unsigned __int64 v22; // [esp+0h] [ebp-2Ch]
  unsigned __int64 v23; // [esp+0h] [ebp-2Ch]
  string v24; // [esp+0h] [ebp-2Ch]
  uint32 h_shift; // [esp+1Ch] [ebp-10h]
  uint32 h_shift_0; // [esp+20h] [ebp-Ch]
  uint8 *_r0_bitp; // [esp+24h] [ebp-8h]
  uint8 *_r0_bitp_0; // [esp+28h] [ebp-4h]

  v3 = src;
  v4 = size;
  if ( (((unsigned __int8)size | (unsigned __int8)(dst | src)) & 3) != 0 )
  {
    v24.str = (uint8 *)"bulkBarrierPreWrite: unaligned arguments";
    v24.len = 40;
    runtime_throw(v24);
    BUG();
  }
  if ( runtime_writeBarrier.needed )
  {
    if ( dst && dst >= dword_81493A8 && dst < dword_81493AC )
    {
      v5 = dst;
      v6 = dst - dword_81493A8;
      if ( (dst - dword_81493A8) >> 13 >= dword_814910C )
        runtime_panicindex();
      v7 = *(_DWORD *)(dword_8149108 + 4 * ((dst - dword_81493A8) >> 13));
      if ( v7 && dst >= *(_DWORD *)(v7 + 12) && dst < *(_DWORD *)(v7 + 80) && *(_BYTE *)(v7 + 60) == 1 )
      {
        v8 = (uint8 *)(dword_81493A0 - (v6 >> 4) - 1);
        v9 = (v6 >> 2) & 3;
        if ( src )
        {
          for ( i = 0; i < v4; i += 4 )
          {
            if ( ((*v8 >> v9) & 1) != 0 )
            {
              _r0_bitp = v8;
              h_shift_0 = v9;
              runtime_writebarrierptr_prewrite1((uintptr *)(i + dst), *(_DWORD *)(i + v3));
              v9 = h_shift_0;
              v8 = _r0_bitp;
              v3 = src;
              v4 = size;
            }
            if ( v9 >= 3 )
            {
              --v8;
              v9 = 0;
            }
            else
            {
              ++v9;
            }
          }
        }
        else
        {
          for ( j = 0; j < v4; j += 4 )
          {
            v11 = v5;
            if ( ((*v8 >> v9) & 1) != 0 )
            {
              h_shift = v9;
              _r0_bitp_0 = v8;
              runtime_writebarrierptr_prewrite1((uintptr *)(j + v5), 0);
              v9 = h_shift;
              v8 = _r0_bitp_0;
              v4 = size;
              v11 = dst;
            }
            if ( v9 >= 3 )
            {
              --v8;
              v9 = 0;
            }
            else
            {
              ++v9;
            }
            v5 = v11;
          }
        }
        return;
      }
    }
    else
    {
      v5 = dst;
    }
    v13 = *(uintptr **)(*(_DWORD *)(*(_DWORD *)(__readgsdword(0) - 4) + 24) + 84);
    if ( !v13 || *v13 > v5 || v5 >= v13[1] )
    {
      v22 = COERCE_UNSIGNED_INT64(COERCE_LONG_DOUBLE(COERCE_LONG_DOUBLE(runtime_activeModules())));
      v14 = (int *)v22;
      for ( k = 0; k < SHIDWORD(v22); ++k )
      {
        v16 = *v14;
        v17 = *(_DWORD *)(*v14 + 64);
        if ( v17 <= dst && dst < *(_DWORD *)(v16 + 68) )
        {
          runtime_bulkBarrierBitmap(dst, src, size, dst - v17, *(uint8 **)(v16 + 200));
          return;
        }
        ++v14;
      }
      v23 = COERCE_UNSIGNED_INT64(COERCE_LONG_DOUBLE(COERCE_LONG_DOUBLE(runtime_activeModules())));
      v18 = (int *)v23;
      for ( m = 0; m < SHIDWORD(v23); ++m )
      {
        v20 = *v18;
        v21 = *(_DWORD *)(*v18 + 72);
        if ( v21 <= dst && dst < *(_DWORD *)(v20 + 76) )
        {
          runtime_bulkBarrierBitmap(dst, src, size, dst - v21, *(uint8 **)(v20 + 208));
          return;
        }
        ++v18;
      }
    }
  }
}
// 8149108: using guessed type int dword_8149108;
// 814910C: using guessed type int dword_814910C;
// 81493A0: using guessed type int dword_81493A0;
// 81493A8: using guessed type int dword_81493A8;
// 81493AC: using guessed type int dword_81493AC;

//----- (08056930) --------------------------------------------------------
void __golang runtime_bulkBarrierBitmap(uintptr dst, uintptr src, uintptr size, uintptr maskOffset, uint8 *bits)
{
  int v5; // edx
  uint8 *v6; // eax
  uintptr j; // ecx
  uint8 mask; // [esp+Bh] [ebp-9h]
  uintptr i; // [esp+Ch] [ebp-8h]
  uint8 *v11; // [esp+10h] [ebp-4h]

  v5 = 1 << ((maskOffset >> 2) & 7);
  v6 = &bits[maskOffset >> 5];
  for ( j = 0; j < size; j += 4 )
  {
    if ( !(_BYTE)v5 )
    {
      if ( *++v6 == 0 )
      {
        j += 28;
        continue;
      }
      LOBYTE(v5) = 1;
    }
    if ( ((unsigned __int8)v5 & *v6) != 0 )
    {
      i = j;
      v11 = v6;
      mask = v5;
      if ( src )
        runtime_writebarrierptr_prewrite1((uintptr *)(j + dst), *(_DWORD *)(j + src));
      else
        runtime_writebarrierptr_prewrite1((uintptr *)(j + dst), 0);
      v6 = v11;
      j = i;
      LOBYTE(v5) = mask;
    }
    LOBYTE(v5) = 2 * v5;
  }
}

//----- (080569E0) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
void __golang runtime_typeBitsBulkBarrier(runtime__type_0 *typ, uintptr dst, uintptr src, uintptr size)
{
  runtime__type_0 *v4; // eax
  uint8 *gcdata; // ecx
  uintptr v6; // edx
  unsigned int v7; // ebx
  runtime__type_0 *t; // [esp+0h] [ebp-24h]
  runtime__type_0 *ta; // [esp+0h] [ebp-24h]
  runtime__type_0 *tb; // [esp+0h] [ebp-24h]
  runtime__type_0 *tc; // [esp+0h] [ebp-24h]
  runtime__type_0 *td; // [esp+0h] [ebp-24h]
  runtime__type_0 *te; // [esp+0h] [ebp-24h]
  runtime__type_0 *tf; // [esp+0h] [ebp-24h]
  string tg; // [esp+0h] [ebp-24h]
  string v16; // [esp+4h] [ebp-20h] OVERLAPPED
  string v17; // [esp+4h] [ebp-20h] OVERLAPPED
  uintptr i; // [esp+Ch] [ebp-18h]
  uintptr v; // [esp+14h] [ebp-10h]
  uint8 *ptrmask; // [esp+1Ch] [ebp-8h]
  uint8 *v21; // [esp+20h] [ebp-4h]
  uint8 *str; // [esp+20h] [ebp-4h]

  v4 = typ;
  if ( !typ )
  {
    tg.str = (uint8 *)"runtime: typeBitsBulkBarrier without type";
    tg.len = 41;
    runtime_throw(tg);
    BUG();
  }
  if ( size != typ->size )
  {
    v17 = runtime___ptr__type__string(typ);
    str = v17.str;
    v = typ->size;
    runtime_printlock();
    tc = (runtime__type_0 *)"runtime: typeBitsBulkBarrier with type ";
    v17.str = (uint8 *)39;
    runtime_printstring(*(string *)((char *)&v17 - 4));
    runtime_printsp();
    runtime_printstring((string)__PAIR64__(v17.len, (unsigned int)str));
    runtime_printsp();
    td = (runtime__type_0 *)" of size ";
    v17.str = (uint8 *)9;
    runtime_printstring(*(string *)((char *)&v17 - 4));
    runtime_printsp();
    runtime_printint(v);
    runtime_printsp();
    te = (runtime__type_0 *)" but memory size";
    v17.str = (uint8 *)16;
    runtime_printstring(*(string *)((char *)&v17 - 4));
    runtime_printsp();
    runtime_printint(size);
    runtime_printnl();
    runtime_printunlock();
    tf = (runtime__type_0 *)"runtime: invalid typeBitsBulkBarrier";
    v17.str = (uint8 *)36;
    runtime_throw(*(string *)((char *)&v17 - 4));
    BUG();
  }
  if ( (typ->kind & 0x40) != 0 )
  {
    v16 = runtime___ptr__type__string(typ);
    v21 = v16.str;
    runtime_printlock();
    t = (runtime__type_0 *)"runtime: typeBitsBulkBarrier with type ";
    v16.str = (uint8 *)39;
    runtime_printstring(*(string *)((char *)&v16 - 4));
    runtime_printsp();
    runtime_printstring((string)__PAIR64__(v16.len, (unsigned int)v21));
    runtime_printsp();
    ta = (runtime__type_0 *)" with GC prog";
    v16.str = (uint8 *)13;
    runtime_printstring(*(string *)((char *)&v16 - 4));
    runtime_printnl();
    runtime_printunlock();
    tb = (runtime__type_0 *)"runtime: invalid typeBitsBulkBarrier";
    v16.str = (uint8 *)36;
    runtime_throw(*(string *)((char *)&v16 - 4));
    BUG();
  }
  if ( runtime_writeBarrier.needed )
  {
    gcdata = typ->gcdata;
    v6 = 0;
    v7 = 0;
    while ( v6 < v4->ptrdata )
    {
      if ( (v6 & 0x1F) != 0 )
        v7 >>= 1;
      else
        v7 = *gcdata++;
      if ( (v7 & 1) != 0 )
      {
        i = v6;
        ptrmask = gcdata;
        runtime_writebarrierptr_prewrite((uintptr *)(v6 + dst), *(_DWORD *)(v6 + src));
        v4 = typ;
        gcdata = ptrmask;
        v6 = i;
      }
      v6 += 4;
    }
  }
}
// 8056A82: failed to expand linear variable ^4.8
// 8056B0B: failed to expand linear variable ^4.8

//----- (08056C00) --------------------------------------------------------
void __golang runtime_heapBits_initSpan(runtime_heapBits_0 h, runtime_mspan *s)
{
  uintptr elemsize; // edx
  uintptr v3; // eax
  string nelems; // [esp+0h] [ebp-Ch]
  uintptr total; // [esp+8h] [ebp-4h]

  total = s->npages << 13;
  elemsize = s->elemsize;
  if ( elemsize )
    v3 = (s->npages << 13) / elemsize;
  else
    v3 = 0;
  s->freeindex = 0;
  s->allocCache = -1LL;
  s->nelems = v3;
  s->allocBits = 0;
  s->gcmarkBits = 0;
  s->gcmarkBits = runtime_newMarkBits(s->nelems);
  s->allocBits = runtime_newAllocBits(s->nelems);
  if ( (total & 0xF) != 0 )
  {
    nelems.str = (uint8 *)"initSpan: unaligned length";
    nelems.len = 26;
    runtime_throw(nelems);
    BUG();
  }
  runtime_memclrNoHeapPointers();
}

//----- (08056CE0) --------------------------------------------------------
void __golang runtime_heapBits_initCheckmarkSpan(runtime_heapBits_0 h, uintptr size, uintptr n, uintptr total)
{
  uint8 *bitp; // ebx
  uint32 shift; // ebp
  uintptr v6; // ecx
  uintptr v7; // ebp

  bitp = h.bitp;
  shift = h.shift;
  v6 = 0;
  while ( v6 < n )
  {
    *bitp &= ~(shift + 1 < 0x20 ? 16 << (shift + 1) : 0);
    ++v6;
    v7 = (size >> 2) + shift;
    bitp -= v7 >> 2;
    shift = v7 & 3;
  }
}

//----- (08056D70) --------------------------------------------------------
void __golang runtime_heapBits_clearCheckmarkSpan(runtime_heapBits_0 h, uintptr size, uintptr n, uintptr total)
{
  ;
}

//----- (08056D90) --------------------------------------------------------
__int32 __golang runtime___ptr_mspan__countAlloc(runtime_mspan *s)
{
  uintptr nelems; // edx
  uintptr v2; // ecx
  uintptr v3; // ebx
  __int32 v4; // ebp
  runtime_gcBits *v5; // esi
  char v6; // dl

  nelems = s->nelems;
  v2 = nelems >> 3;
  v3 = 0;
  v4 = 0;
  while ( v3 < v2 )
  {
    v5 = &s->gcmarkBits[v3++];
    v4 += runtime_oneBitCount[*v5];
  }
  v6 = nelems & 7;
  if ( (s->nelems & 7) != 0 )
    return v4 + runtime_oneBitCount[((1 << v6) - 1) & s->gcmarkBits[v2]];
  else
    return v4;
}

//----- (08056E10) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
void __golang runtime_heapBitsSetType(uintptr x, uintptr size, uintptr dataSize, runtime__type_0 *typ)
{
  runtime__type_0 *v4; // edx
  uint8 *gcdata; // ebx
  _BYTE *v6; // ebp
  uintptr v7; // ecx
  uintptr v8; // ecx
  uintptr v9; // ebp
  int v10; // ecx
  unsigned int v11; // ecx
  uintptr v12; // ebp
  unsigned int v13; // esi
  runtime__type_0 *v14; // eax
  int v15; // ebp
  uint8 *v16; // edx
  int v17; // ebx
  uintptr v18; // esi
  int v19; // edi
  unsigned int v20; // ebp
  unsigned int v21; // eax
  unsigned int v22; // ebp
  char v23; // di
  uintptr v24; // ecx
  _BYTE *v25; // edx
  int v26; // ebp
  uintptr v27; // eax
  char v28; // bl
  uintptr v29; // ebp
  unsigned int v30; // edi
  _BYTE *v31; // esi
  char v32; // bp
  uintptr v33; // ebp
  int v34; // ecx
  uintptr v35; // ebx
  uintptr v36; // esi
  _BYTE *v37; // ecx
  uint8 *v38; // ebx
  uintptr v39; // ebx
  unsigned int v40; // esi
  unsigned int v41; // ebp
  int v42; // ecx
  int v43; // edx
  runtime_heapBits_0 h; // [esp+0h] [ebp-70h]
  string ha; // [esp+0h] [ebp-70h]
  const char *hb; // [esp+0h] [ebp-70h]
  const char *hc; // [esp+0h] [ebp-70h]
  string h_4; // [esp+4h] [ebp-6Ch] OVERLAPPED
  uintptr w; // [esp+1Ch] [ebp-54h]
  uintptr pbits; // [esp+20h] [ebp-50h]
  uintptr i; // [esp+28h] [ebp-48h]
  uintptr endnb; // [esp+2Ch] [ebp-44h]
  uintptr b; // [esp+30h] [ebp-40h]
  int v54; // [esp+38h] [ebp-38h]
  uintptr v55; // [esp+3Ch] [ebp-34h]
  uint8 *p_0; // [esp+60h] [ebp-10h]
  uint8 *endp; // [esp+64h] [ebp-Ch]
  uint8 *s; // [esp+68h] [ebp-8h]
  _BYTE *s_4; // [esp+6Ch] [ebp-4h]
  _BYTE *s_4a; // [esp+6Ch] [ebp-4h]

  v4 = typ;
  gcdata = typ->gcdata;
  v6 = (_BYTE *)(dword_81493A0 - ((x - dword_81493A8) >> 4) - 1);
  v7 = ((x - dword_81493A8) >> 2) & 3;
  if ( size == 8 )
  {
    if ( typ->size == 4 )
    {
      if ( dataSize == 4 )
        v43 = (17 << v7) | (unsigned __int8)*v6 & ~(51 << v7);
      else
        v43 = (unsigned __int8)*v6 | (19 << v7);
      *v6 = v43;
    }
    else
    {
      *v6 = *v6 & ~(51 << v7) | ((*gcdata & 3 | 0x10) << v7);
    }
  }
  else if ( (typ->kind & 0x40) != 0 )
  {
    h.bitp = (uint8 *)(dword_81493A0 - ((x - dword_81493A8) >> 4) - 1);
    h.shift = ((x - dword_81493A8) >> 2) & 3;
    runtime_heapBitsSetTypeGCProg(h, typ->ptrdata, typ->size, dataSize, size, gcdata + 4);
  }
  else
  {
    s_4 = (_BYTE *)(dword_81493A0 - ((x - dword_81493A8) >> 4) - 1);
    p_0 = typ->gcdata;
    v8 = typ->size;
    v55 = typ->size;
    if ( typ->size >= dataSize )
    {
      v14 = typ;
      v16 = typ->gcdata;
      v11 = 0;
      v17 = 0;
      v15 = 0;
      v18 = 0;
    }
    else
    {
      v9 = typ->ptrdata >> 2;
      if ( v9 > 0x19 )
      {
        v41 = (v9 + 7) >> 3;
        v42 = (v8 >> 2) - 8 * (v41 - 1);
        v14 = typ;
        v16 = typ->gcdata;
        v17 = (int)&gcdata[v41 - 1];
        v15 = 0;
        v18 = v42;
        v11 = 0;
      }
      else
      {
        i = 0;
        pbits = 0;
        while ( i < v9 )
        {
          v10 = (i < 0x20 ? *gcdata++ << i : 0) | pbits;
          v4 = typ;
          i += 8;
          pbits = v10;
          v8 = typ->size;
        }
        v11 = v8 >> 2;
        if ( 2 * v11 > 0x19 )
        {
          v14 = v4;
          v15 = pbits;
        }
        else
        {
          v12 = pbits;
          v13 = v11;
          while ( v11 <= 0x20 )
          {
            v12 |= v11 < 0x20 ? v12 << v11 : 0;
            v11 *= 2;
          }
          if ( !(_BYTE)v13 )
            runtime_panicdivide();
          v14 = v4;
          v11 = v13 * (0x19u / (unsigned __int8)v13);
          v15 = (v11 < 0x20 ? (1 << v11) + 1 : -1) & v12;
        }
        v16 = 0;
        v17 = 0;
        v18 = v11;
      }
    }
    if ( v16 )
    {
      v19 = *v16++;
      v11 = 8;
    }
    else
    {
      v19 = v15;
    }
    endnb = v18;
    v54 = v15;
    if ( dataSize == v55 )
    {
      v20 = v14->ptrdata >> 2;
    }
    else
    {
      if ( !v55 )
        runtime_panicdivide();
      v14 = typ;
      v20 = (v55 * (dataSize / v55 - 1) + typ->ptrdata) >> 2;
    }
    if ( !v20 )
    {
      h_4 = runtime___ptr__type__string(v14);
      s = h_4.str;
      runtime_printlock();
      hb = "runtime: invalid type ";
      h_4.str = (uint8 *)22;
      runtime_printstring(*(string *)((char *)&h_4 - 4));
      runtime_printsp();
      runtime_printstring((string)__PAIR64__(h_4.len, (unsigned int)s));
      runtime_printnl();
      runtime_printunlock();
      hc = "heapBitsSetType: called with non-pointer type";
      h_4.str = (uint8 *)45;
      runtime_throw(*(string *)((char *)&h_4 - 4));
      BUG();
    }
    if ( v20 >= 2 )
      v21 = v20;
    else
      v21 = 2;
    if ( (((x - dword_81493A8) >> 2) & 3) != 0 )
    {
      ha.str = (uint8 *)"heapBitsSetType: unexpected shift";
      ha.len = 33;
      runtime_throw(ha);
      BUG();
    }
    v22 = v19;
    v23 = v19 & 0xF | 0xD0;
    if ( v21 > 4 )
    {
      endp = (uint8 *)v17;
      *s_4 = v23;
      v29 = v22 >> 4;
      v30 = v11 - 8;
      v31 = s_4 - 1;
      w = 4;
      while ( 1 )
      {
        b = v29;
        v32 = v29 & 0xF | 0xF0;
        if ( w + 4 >= v21 )
          break;
        *v31 = v32;
        v33 = b >> 4;
        s_4a = v31 - 1;
        if ( v16 == (uint8 *)v17 )
        {
          if ( v16 )
          {
            v33 |= v30 < 0x20 ? *v16 << v30 : 0;
            if ( v30 + endnb >= 8 )
            {
              v34 = v30 + endnb - 8;
              v38 = p_0;
            }
            else
            {
              v34 = v30 + endnb;
              v33 |= v30 + endnb < 0x20 ? *p_0 << (v30 + endnb) : 0;
              v38 = p_0 + 1;
            }
          }
          else
          {
            if ( v30 >= 8 )
            {
              v40 = v30;
              v39 = b >> 4;
            }
            else
            {
              v39 = v33 | (v30 < 0x20 ? v54 << v30 : 0);
              v40 = v30 + endnb;
            }
            v34 = v40 - 8;
            v33 = v39;
            v38 = 0;
          }
          v16 = v38;
        }
        else if ( v30 >= 8 )
        {
          v34 = v30 - 8;
        }
        else
        {
          v34 = v30;
          v33 |= v30 < 0x20 ? *v16++ << v30 : 0;
        }
        v35 = v33;
        v32 = v33 & 0xF | 0xF0;
        v36 = w + 8;
        if ( w + 8 >= v21 )
        {
          v37 = s_4a;
          goto LABEL_45;
        }
        *s_4a = v32;
        w += 8;
        v30 = v34;
        v31 = s_4a - 1;
        v29 = v35 >> 4;
        v17 = (int)endp;
      }
      v37 = v31;
      v36 = w + 4;
LABEL_45:
      v25 = v37;
      v23 = v32;
      v24 = v36;
    }
    else
    {
      v24 = 4;
      v25 = (_BYTE *)(dword_81493A0 - ((x - dword_81493A8) >> 4) - 1);
    }
    if ( v24 > v21 )
    {
      v26 = 4 - (v24 - v21) < 0x20 ? (1 << (4 - (v24 - v21))) + 1 : -1;
      v23 &= v26 | (16 * v26);
    }
    v27 = size >> 2;
    if ( v24 > size >> 2 )
    {
      v28 = v23;
    }
    else
    {
      *v25 = v23;
      v24 += 4;
      --v25;
      while ( v24 <= v27 )
      {
        *v25 = 0;
        v24 += 4;
        --v25;
      }
      v28 = 0;
    }
    if ( v27 + 2 == v24 )
      *v25 = *v25 & 0xCC | v28;
  }
}
// 80572DC: failed to expand linear variable ^4.8
// 81493A0: using guessed type int dword_81493A0;
// 81493A8: using guessed type int dword_81493A8;

//----- (08057360) --------------------------------------------------------
void __golang runtime_heapBitsSetTypeGCProg(
        runtime_heapBits_0 h,
        uintptr progSize,
        uintptr elemSize,
        uintptr dataSize,
        uintptr allocSize,
        uint8 *prog)
{
  unsigned int v6; // edx
  uintptr v7; // esi
  uintptr v8; // ecx
  unsigned int v9; // ecx
  unsigned int v10; // ebx
  unsigned int v11; // ecx
  unsigned int v12; // ecx
  unsigned int v13; // ecx
  uintptr i; // eax
  string s; // [esp+0h] [ebp-40h]
  string sa; // [esp+0h] [ebp-40h]
  string sb; // [esp+0h] [ebp-40h]
  uintptr v18; // [esp+10h] [ebp-30h]
  __int16 v_4; // [esp+18h] [ebp-28h] BYREF
  char v_6; // [esp+1Ah] [ebp-26h]

  if ( elemSize == dataSize )
  {
    v18 = runtime_runGCProg(prog, 0, h.bitp, 2);
    if ( 4 * v18 != progSize )
    {
      runtime_printlock();
      s.str = (uint8 *)"runtime: heapBitsSetTypeGCProg: total bits";
      s.len = 42;
      runtime_printstring(s);
      runtime_printsp();
      runtime_printint(v18);
      runtime_printsp();
      sa.str = (uint8 *)"but progSize";
      sa.len = 12;
      runtime_printstring(sa);
      runtime_printsp();
      runtime_printint(progSize);
      runtime_printnl();
      runtime_printunlock();
      sb.str = (uint8 *)"heapBitsSetTypeGCProg: unexpected bit count";
      sb.len = 43;
      runtime_throw(sb);
      BUG();
    }
  }
  else
  {
    if ( !elemSize )
      runtime_panicdivide();
    ((void (*)(void))loc_808FD86)();
    v7 = elemSize >> 2;
    v8 = (elemSize >> 2) - (progSize >> 2);
    if ( elemSize >> 2 == progSize >> 2 )
    {
      v11 = 0;
    }
    else
    {
      v_4 = 1;
      if ( v8 <= 1 )
      {
        v11 = 2;
      }
      else
      {
        v_6 = -127;
        v9 = v8 - 1;
        v10 = 3;
        while ( v9 >= 0x80 )
        {
          if ( v10 >= 0x28 )
            runtime_panicindex();
          *((_BYTE *)&v_4 + v10++) = v9 | 0x80;
          v9 >>= 7;
        }
        if ( v10 >= 0x28 )
          runtime_panicindex();
        *((_BYTE *)&v_4 + v10) = v9;
        v11 = v10 + 1;
      }
    }
    if ( v11 >= 0x28 )
      runtime_panicindex();
    *((_BYTE *)&v_4 + v11) = 0x80;
    v12 = v11 + 1;
    while ( v7 >= 0x80 )
    {
      if ( v12 >= 0x28 )
        runtime_panicindex();
      *((_BYTE *)&v_4 + v12++) = v7 | 0x80;
      v7 >>= 7;
    }
    if ( v12 >= 0x28 )
      runtime_panicindex();
    *((_BYTE *)&v_4 + v12) = v7;
    v13 = v12 + 1;
    for ( i = v6 / elemSize - 1; i >= 0x80; i >>= 7 )
    {
      if ( v13 >= 0x28 )
        runtime_panicindex();
      *((_BYTE *)&v_4 + v13++) = i | 0x80;
    }
    if ( v13 >= 0x28 )
      runtime_panicindex();
    *((_BYTE *)&v_4 + v13) = i;
    if ( v13 + 1 >= 0x28 )
      runtime_panicindex();
    *((_BYTE *)&v_4 + v13 + 1) = 0;
    runtime_runGCProg(prog, (uint8 *)&v_4, h.bitp, 2);
  }
  runtime_memclrNoHeapPointers();
}
// 80573A4: variable 'v6' is possibly undefined

//----- (08057630) --------------------------------------------------------
runtime_bitvector_0 __golang runtime_progToPointerMask(uint8 *prog, uintptr size)
{
  string v2; // [esp+0h] [ebp-20h]
  uint8 *dst; // [esp+Ch] [ebp-14h]
  uintptr v4; // [esp+10h] [ebp-10h]
  unsigned int n; // [esp+14h] [ebp-Ch]
  uint8 *v6; // [esp+1Ch] [ebp-4h]
  runtime_bitvector_0 _r2; // [esp+2Ch] [ebp+Ch]

  n = ((size >> 2) + 7) >> 3;
  dst = (uint8 *)runtime_persistentalloc(n + 1, 1u, &runtime_memstats.buckhash_sys);
  if ( n + 1 > 0x40000000 )
    runtime_panicslice();
  if ( n >= n + 1 )
    runtime_panicindex();
  dst[n] = -95;
  if ( n == -1 )
    runtime_panicindex();
  v6 = dst;
  v4 = runtime_runGCProg(prog, 0, dst, 1);
  if ( v6[n] != 0xA1 )
  {
    v2.str = (uint8 *)"progToPointerMask: overflow";
    v2.len = 27;
    runtime_throw(v2);
    BUG();
  }
  _r2.n = v4;
  _r2.bytedata = v6;
  return _r2;
}

//----- (08057720) --------------------------------------------------------
uintptr __golang runtime_runGCProg(uint8 *prog, uint8 *trailer, uint8 *dst, __int32 size)
{
  uint8 *v4; // edx
  __int32 v5; // ebx
  uint8 *v8; // eax
  unsigned int v9; // ecx
  unsigned int v10; // edi
  uint8 *v11; // edx
  unsigned int v12; // ebx
  uint8 *v13; // esi
  uint8 v14; // dl
  uint8 *v15; // edx
  uint8 *v16; // ebx
  uint8 *v17; // edx
  uintptr v18; // eax
  unsigned int m; // ecx
  uint8 *v20; // edx
  unsigned int ii; // ecx
  unsigned int v22; // ebx
  unsigned int v23; // edi
  uint8 *v24; // edx
  uint8 *v25; // esi
  uint8 v26; // bl
  int v27; // edx
  unsigned int v28; // edx
  uint8 *v29; // ebx
  unsigned int j; // edx
  uint8 *v31; // ebp
  int v32; // ecx
  unsigned int k; // edx
  uint8 v34; // di
  int v35; // esi
  unsigned int v36; // edx
  unsigned int v37; // ebx
  uint8 *v38; // edi
  uint8 *v39; // ebp
  int v40; // eax
  unsigned int v41; // esi
  unsigned int v42; // ebp
  unsigned int v43; // ecx
  int v44; // edx
  unsigned int v45; // esi
  unsigned int v46; // ebx
  unsigned int v47; // edx
  unsigned int v48; // ecx
  _BYTE *v49; // ebp
  int v50; // eax
  uintptr v51; // edx
  unsigned int v52; // edi
  int v53; // edx
  uint8 *v54; // edi
  unsigned int v55; // ebp
  uint8 *v56; // edx
  char v57; // cl
  unsigned int v58; // ebx
  uint8 *v59; // esi
  unsigned int v60; // edi
  char v61; // bl
  int v62; // ecx
  unsigned int v63; // edx
  uint8 *v64; // ecx
  int v65; // edx
  unsigned int v66; // ebp
  uint8 *v67; // edx
  char v68; // cl
  unsigned int v69; // ebx
  uint8 *v70; // esi
  unsigned int v71; // eax
  char v72; // bl
  int v73; // ecx
  uintptr pattern; // [esp+0h] [ebp-84h]
  char off; // [esp+4h] [ebp-80h]
  uintptr npattern; // [esp+8h] [ebp-7Ch]
  uintptr nbyte; // [esp+Ch] [ebp-78h]
  uintptr nbits; // [esp+10h] [ebp-74h]
  uintptr nb; // [esp+14h] [ebp-70h]
  unsigned int n; // [esp+18h] [ebp-6Ch]
  uintptr i; // [esp+1Ch] [ebp-68h]
  uintptr c; // [esp+20h] [ebp-64h]
  char ca; // [esp+20h] [ebp-64h]
  char cb; // [esp+20h] [ebp-64h]
  uintptr v85; // [esp+28h] [ebp-5Ch]
  uintptr v86; // [esp+28h] [ebp-5Ch]
  unsigned int v87; // [esp+2Ch] [ebp-58h]
  unsigned int v88; // [esp+2Ch] [ebp-58h]
  unsigned int v89; // [esp+2Ch] [ebp-58h]
  uint8 v90; // [esp+30h] [ebp-54h]
  unsigned int v91; // [esp+30h] [ebp-54h]
  int v92; // [esp+30h] [ebp-54h]
  uint8 *v93; // [esp+30h] [ebp-54h]
  uint8 *p_1; // [esp+74h] [ebp-10h]
  uint8 *p_2; // [esp+78h] [ebp-Ch]
  uint8 *v96; // [esp+80h] [ebp-4h] BYREF
  uint8 *trailera; // [esp+8Ch] [ebp+8h]

  while ( (unsigned int)&v96 <= *(_DWORD *)(*(_DWORD *)(__readgsdword(0) - 4) + 8) )
    runtime_morestack_noctxt();
  v4 = dst;
  v5 = size;
  v8 = dst;
  v9 = 0;
  v10 = 0;
  while ( 1 )
  {
    while ( 1 )
    {
      pattern = v10;
      if ( v9 < 8 )
        break;
      if ( v5 == 1 )
      {
        *v4 = v10;
        v10 >>= 8;
        ++v4;
      }
      else
      {
        *v4 = v10 & 0xF | 0xF0;
        v11 = v4 - 1;
        *v11 = (v10 >> 4) & 0xF | 0xF0;
        v10 >>= 8;
        v4 = v11 - 1;
      }
      v9 -= 8;
    }
    p_2 = v4;
    trailera = trailer;
    v90 = *prog;
    v12 = *prog & 0x7F;
    v13 = prog + 1;
    v14 = v90;
    if ( (v90 & 0x80) == 0 )
      break;
    npattern = v9;
    if ( (v90 & 0x7F) != 0 )
    {
      v31 = v13;
    }
    else
    {
      for ( j = 0; ; j += 7 )
      {
        v12 |= j < 0x20 ? (*v13 & 0x7F) << j : 0;
        v31 = v13 + 1;
        if ( (*v13 & 0x80) == 0 )
          break;
        ++v13;
      }
    }
    v91 = v12;
    v32 = 0;
    for ( k = 0; ; k += 7 )
    {
      v34 = *v31;
      v35 = k < 0x20 ? (*v31++ & 0x7F) << k : 0;
      if ( (v34 & 0x80) == 0 )
        break;
      v32 |= v35;
    }
    v96 = v31;
    v36 = v12;
    v37 = v12 * (v35 | v32);
    if ( v91 > 0x19 )
    {
      v51 = v91 - npattern;
      off = v91 - npattern;
      if ( size == 1 )
      {
        v52 = (v51 + 7) >> 3;
        v53 = v51 & 7;
        v93 = &p_2[-v52];
        v54 = &p_2[-v52];
        if ( (off & 7) != 0 )
        {
          v10 = (npattern < 0x20 ? ((unsigned int)(8 - v53) < 0x20 ? *v54 >> (8 - v53) : 0) << npattern : 0) | pattern;
          v55 = v53 + npattern;
          v37 -= v53;
          v56 = v93 + 1;
        }
        else
        {
          v56 = v54;
          v55 = npattern;
          v10 = pattern;
        }
        ca = v37;
        v57 = v37;
        v58 = v37 >> 3;
        v59 = p_2;
        while ( v58 )
        {
          v60 = (v55 < 0x20 ? *v56++ << v55 : 0) | v10;
          *v59 = v60;
          --v58;
          v10 = v60 >> 8;
          ++v59;
          v8 = dst;
          v57 = ca;
        }
        v61 = v57;
        v62 = v57 & 7;
        if ( (v61 & 7) != 0 )
        {
          v10 |= v55 < 0x20 ? (*v56 & ((1 << v62) - 1)) << v55 : 0;
          v63 = v55 + v62;
        }
        else
        {
          v63 = v55;
        }
        v64 = v59;
      }
      else
      {
        n = (v51 + 3) >> 2;
        v65 = v51 & 3;
        if ( (((_BYTE)v91 - (_BYTE)npattern) & 3) != 0 )
        {
          v10 = (npattern < 0x20 ? ((unsigned int)(4 - v65) < 0x20 ? (unsigned __int8)(p_2[n] & 0xF) >> (4 - v65) : 0) << npattern : 0) | pattern;
          v66 = v65 + npattern;
          v37 -= v65;
          v67 = &p_2[n - 1];
        }
        else
        {
          v67 = &p_2[n];
          v66 = npattern;
          v10 = pattern;
        }
        cb = v37;
        v68 = v37;
        v69 = v37 >> 2;
        v70 = p_2;
        while ( v69 )
        {
          v71 = (v66 < 0x20 ? (*v67-- & 0xF) << v66 : 0) | v10;
          *v70 = v71 & 0xF | 0xF0;
          --v69;
          --v70;
          v68 = cb;
          v10 = v71 >> 4;
          v8 = dst;
        }
        v72 = v68;
        v73 = v68 & 3;
        if ( (v72 & 3) != 0 )
        {
          v10 |= v66 < 0x20 ? (*v67 & ((1 << v73) - 1)) << v66 : 0;
          v63 = v66 + v73;
        }
        else
        {
          v63 = v66;
        }
        v64 = v70;
      }
      trailer = v96;
      v16 = v64;
      v9 = v63;
      v15 = trailera;
    }
    else
    {
      if ( size == 1 )
      {
        v38 = p_2;
        v39 = p_2 - 1;
        v87 = npattern;
        v85 = pattern;
        while ( 1 )
        {
          v41 = v87;
          if ( v87 >= v91 )
            break;
          v40 = *v39-- | (v85 << 8);
          v87 += 8;
          v85 = v40;
          v8 = dst;
        }
        v42 = v85;
      }
      else
      {
        v38 = p_2;
        v49 = p_2 + 1;
        v89 = npattern;
        v86 = pattern;
        while ( 1 )
        {
          v41 = v89;
          if ( v89 >= v91 )
            break;
          v50 = *v49++ & 0xF | (16 * v86);
          v89 += 4;
          v86 = v50;
          v8 = dst;
        }
        v42 = v86;
      }
      if ( v41 <= v91 )
        v36 = v41;
      else
        v42 = v41 - v91 < 0x20 ? v42 >> (v41 - v91) : 0;
      if ( v36 == 1 )
      {
        if ( v42 == 1 )
        {
          v43 = 25;
          v44 = 0x1FFFFFF;
        }
        else
        {
          v43 = v37;
          v44 = v42;
        }
      }
      else
      {
        if ( 2 * v36 > 0x19 )
        {
          v43 = v36;
        }
        else
        {
          nb = v36;
          v48 = v36;
          while ( v36 <= 0x20 )
          {
            v42 |= v36 < 0x20 ? v42 << v36 : 0;
            v36 *= 2;
            v48 = nb;
          }
          if ( !v48 )
            runtime_panicdivide();
          v43 = 0x19 / v48 * v48;
          v42 &= v43 < 0x20 ? (1 << v43) + 1 : -1;
        }
        v8 = dst;
        v44 = v42;
      }
      v92 = v44;
      v88 = v43;
      v45 = pattern;
      nbits = npattern;
      while ( v37 >= v43 )
      {
        c = v37;
        v45 |= nbits < 0x20 ? v44 << nbits : 0;
        v46 = v88 + nbits;
        if ( size == 1 )
        {
          while ( v46 >= 8 )
          {
            *v38 = v45;
            v45 >>= 8;
            v46 -= 8;
            ++v38;
          }
        }
        else
        {
          while ( v46 >= 4 )
          {
            *v38 = v45 & 0xF | 0xF0;
            v46 -= 4;
            --v38;
            v45 >>= 4;
          }
        }
        v44 = v92;
        nbits = v46;
        v37 = c - v88;
        v43 = v88;
      }
      if ( v37 )
      {
        v45 |= nbits < 0x20 ? ((v37 < 0x20 ? (1 << v37) + 1 : -1) & v44) << nbits : 0;
        v47 = nbits + v37;
      }
      else
      {
        v47 = nbits;
      }
      v9 = v47;
      trailer = v96;
      v15 = trailera;
      v16 = v38;
      v10 = v45;
    }
LABEL_12:
    prog = trailer;
    trailer = v15;
    v4 = v16;
    v5 = size;
  }
  if ( (v90 & 0x7F) != 0 )
  {
    v22 = v12 >> 3;
    nbyte = v22;
    i = 0;
    p_1 = p_2;
    while ( i < v22 )
    {
      v23 = (v9 < 0x20 ? *v13 << v9 : 0) | v10;
      v24 = v13 + 1;
      if ( size == 1 )
      {
        *p_1 = v23;
        v10 = v23 >> 8;
        v25 = p_1 + 1;
      }
      else
      {
        *p_1 = v23 & 0xF | 0xF0;
        *(p_1 - 1) = (v23 >> 4) & 0xF | 0xF0;
        v10 = v23 >> 8;
        v25 = p_1 - 2;
        v8 = dst;
      }
      v22 = nbyte;
      ++i;
      p_1 = v25;
      v13 = v24;
      v14 = v90;
    }
    v26 = v14;
    v27 = v14 & 7;
    if ( (v26 & 7) != 0 )
    {
      v10 |= v9 < 0x20 ? *v13 << v9 : 0;
      v28 = v9 + v27;
      v29 = v13 + 1;
    }
    else
    {
      v28 = v9;
      v29 = v13;
    }
    v9 = v28;
    trailer = v29;
    v15 = trailera;
    v16 = p_1;
    goto LABEL_12;
  }
  if ( trailer )
  {
    v15 = 0;
    v16 = p_2;
    goto LABEL_12;
  }
  if ( size == 1 )
  {
    v17 = p_2;
    v18 = v9 + 8 * (p_2 - v8);
    for ( m = v9 + (-v9 & 7); m; m -= 8 )
    {
      *v17 = v10;
      v10 >>= 8;
      ++v17;
    }
  }
  else
  {
    v20 = p_2;
    v18 = v9 + 4 * (v8 - p_2);
    for ( ii = v9 + (-v9 & 3); ii; ii -= 4 )
    {
      *v20-- = v10 & 0xF | 0xF0;
      v10 >>= 4;
    }
  }
  return v18;
}

//----- (08057E90) --------------------------------------------------------
runtime_mcache *__golang runtime_allocmcache()
{
  int i; // ecx
  runtime_mcache *v1; // [esp+8h] [ebp-4h]

  runtime_lock(&runtime_mheap_.lock);
  v1 = (runtime_mcache *)runtime___ptr_fixalloc__alloc(&f);
  runtime_unlock(&runtime_mheap_.lock);
  for ( i = 0; i < 134; ++i )
  {
    if ( (unsigned int)i >= 0x86 )
      runtime_panicindex();
    v1->alloc[i] = &runtime_emptymspan;
  }
  v1->next_sample = runtime_nextSample();
  return v1;
}

//----- (08057F30) --------------------------------------------------------
void __golang runtime_freemcache(runtime_mcache *c)
{
  runtime_systemstack();
}

//----- (08057F70) --------------------------------------------------------
runtime_mspan *__golang runtime___ptr_mcache__refill(runtime_mcache *c, runtime_spanClass spc)
{
  runtime_g *v2; // eax
  runtime_mspan *v3; // ebx
  string s; // [esp+0h] [ebp-10h]
  string sa; // [esp+0h] [ebp-10h]
  string sb; // [esp+0h] [ebp-10h]
  runtime_mspan *s_4; // [esp+4h] [ebp-Ch]
  runtime_g *_g_; // [esp+Ch] [ebp-4h]

  v2 = *(runtime_g **)(__readgsdword(0) - 4);
  ++v2->m->locks;
  if ( spc >= 0x86u )
    runtime_panicindex();
  v3 = c->alloc[spc];
  if ( v3->allocCount != v3->nelems )
  {
    sb.str = (uint8 *)"refill of span with free space remaining";
    sb.len = 40;
    runtime_throw(sb);
    BUG();
  }
  _g_ = v2;
  if ( v3 != &runtime_emptymspan )
    v3->incache = 0;
  s_4 = runtime___ptr_mcentral__cacheSpan(&runtime_mheap_.central[spc].mcentral);
  if ( !s_4 )
  {
    sa.str = (uint8 *)"out of memory";
    sa.len = 13;
    runtime_throw(sa);
    BUG();
  }
  if ( s_4->allocCount == s_4->nelems )
  {
    s.str = (uint8 *)"span has no free space";
    s.len = 22;
    runtime_throw(s);
    BUG();
  }
  c->alloc[spc] = s_4;
  --_g_->m->locks;
  return s_4;
}

//----- (08058090) --------------------------------------------------------
void __golang runtime___ptr_mcache__releaseAll(runtime_mcache *c)
{
  int j; // eax
  runtime_mspan *s; // edx
  __int32 i; // [esp+8h] [ebp-4h]

  for ( j = 0; j < 134; ++j )
  {
    if ( (unsigned int)j >= 0x86 )
      runtime_panicindex();
    s = c->alloc[j];
    if ( s != &runtime_emptymspan )
    {
      i = j;
      runtime___ptr_mcentral__uncacheSpan(&runtime_mheap_.central[j].mcentral, s);
      j = i;
      c->alloc[i] = &runtime_emptymspan;
    }
  }
  c->tiny = 0;
  c->tinyoffset = 0;
}

//----- (08058130) --------------------------------------------------------
runtime_mspan *__golang runtime___ptr_mcentral__cacheSpan(runtime_mcentral_0 *c)
{
  unsigned int v1; // ecx
  int v2; // eax
  runtime_mspan *i; // edx
  bool v4; // al
  runtime_mspan *v5; // ecx
  uintptr elemsize; // edx
  int v7; // eax
  uint16 allocCount; // dx
  int v9; // eax
  uintptr nelems; // ebp
  unsigned int v11; // ebx
  unsigned int allocCache_high; // eax
  int v13; // ebp
  runtime_mcentral_0 *v14; // ecx
  runtime_mspan *j; // edx
  string v16; // [esp+0h] [ebp-28h]
  runtime_mspan *callerSweepPages; // [esp+4h] [ebp-24h]
  uintptr callerSweepPagesa; // [esp+4h] [ebp-24h]
  char v19; // [esp+Ch] [ebp-1Ch]
  bool enabled; // [esp+17h] [ebp-11h]
  int spanBytes; // [esp+18h] [ebp-10h]
  uint32 sg; // [esp+1Ch] [ebp-Ch]
  runtime_mspan *s; // [esp+20h] [ebp-8h]
  runtime_mspan *sa; // [esp+20h] [ebp-8h]
  runtime_mspan *sc; // [esp+20h] [ebp-8h]
  runtime_mspan *sb; // [esp+20h] [ebp-8h]

  v1 = c->spanclass >> 1;
  if ( v1 >= 0x43 )
    runtime_panicindex();
  spanBytes = runtime_class_to_allocnpages[v1] << 13;
  runtime_deductSweepCredit(spanBytes, 0);
  runtime_lock(&c->lock);
  if ( runtime_trace.enabled )
    runtime_traceGCSweepStart();
  v2 = dword_81490F0;
  sg = dword_81490F0;
LABEL_39:
  v14 = c;
  for ( i = c->nonempty.first; ; i = i->next )
  {
    if ( !i )
    {
      for ( j = v14->empty.first; ; j = j->next )
      {
        if ( !j )
        {
LABEL_30:
          enabled = runtime_trace.enabled;
          if ( runtime_trace.enabled )
          {
            runtime_traceGCSweepDone();
            v14 = c;
          }
          runtime_unlock(&v14->lock);
          callerSweepPages = runtime___ptr_mcentral__grow(c);
          if ( callerSweepPages )
          {
            sc = callerSweepPages;
            runtime_lock(&c->lock);
            runtime___ptr_mSpanList__insertBack(&c->empty, callerSweepPages);
            runtime_unlock(&c->lock);
            v4 = enabled;
            v5 = sc;
            goto LABEL_10;
          }
          return 0;
        }
        if ( j->sweepgen == v2 - 2 )
        {
          sb = j;
          runtime_internal_atomic_Cas();
          if ( v19 )
          {
            runtime___ptr_mSpanList__remove(&c->empty, sb);
            runtime___ptr_mSpanList__insertBack(&c->empty, sb);
            runtime_unlock(&c->lock);
            runtime___ptr_mspan__sweep(sb, 1);
            callerSweepPagesa = runtime___ptr_mspan__nextFreeIndex(sb);
            v5 = sb;
            if ( callerSweepPagesa == sb->nelems )
            {
              runtime_lock(&c->lock);
              v2 = sg;
              goto LABEL_39;
            }
            sb->freeindex = callerSweepPagesa;
            v4 = 0;
            goto LABEL_10;
          }
          v2 = sg;
          v14 = c;
          j = sb;
        }
        if ( j->sweepgen != v2 - 1 )
          goto LABEL_30;
      }
    }
    s = i;
    if ( i->sweepgen == v2 - 2 )
      break;
LABEL_8:
    if ( i->sweepgen != v2 - 1 )
    {
      runtime___ptr_mSpanList__remove(&v14->nonempty, i);
      runtime___ptr_mSpanList__insertBack(&c->empty, s);
      runtime_unlock(&c->lock);
      v4 = 0;
      v5 = s;
      goto LABEL_10;
    }
  }
  runtime_internal_atomic_Cas();
  if ( !v19 )
  {
    v2 = sg;
    v14 = c;
    i = s;
    goto LABEL_8;
  }
  runtime___ptr_mSpanList__remove(&c->nonempty, s);
  runtime___ptr_mSpanList__insertBack(&c->empty, s);
  runtime_unlock(&c->lock);
  runtime___ptr_mspan__sweep(s, 1);
  v4 = 0;
  v5 = s;
LABEL_10:
  sa = v5;
  if ( runtime_trace.enabled && !v4 )
  {
    runtime_traceGCSweepDone();
    v5 = sa;
  }
  elemsize = v5->elemsize;
  if ( !elemsize )
    runtime_panicdivide();
  v7 = (v5->npages << 13) / elemsize;
  allocCount = v5->allocCount;
  v9 = v7 - allocCount;
  if ( !v9 || (nelems = v5->nelems, v5->freeindex == nelems) || nelems == allocCount )
  {
    v16.str = (uint8 *)"span has no free objects";
    v16.len = 24;
    runtime_throw(v16);
    BUG();
  }
  runtime_internal_atomic_Xadd64(&c->nmalloc, v9);
  runtime_internal_atomic_Xadd64(
    &runtime_memstats.heap_live,
    (unsigned int)spanBytes - (unsigned __int64)(sa->elemsize * sa->allocCount));
  if ( runtime_trace.enabled )
    runtime_traceHeapAlloc();
  if ( runtime_gcBlackenEnabled )
    runtime___ptr_gcControllerState__revise(&runtime_gcController);
  sa->incache = 1;
  runtime___ptr_mspan__refillAllocCache(sa, (sa->freeindex & 0xFFFFFFC0) >> 3);
  v11 = sa->freeindex & 0x3F;
  allocCache_high = HIDWORD(sa->allocCache);
  v13 = -(v11 < 0x20);
  LODWORD(sa->allocCache) = (v11 - 32 < 0x20 ? allocCache_high >> (v11 - 32) : 0) | v13 & (LODWORD(sa->allocCache) >> v11) | (32 - v11 < 0x20 ? allocCache_high << (32 - v11) : 0);
  HIDWORD(sa->allocCache) = v13 & (allocCache_high >> v11);
  return sa;
}
// 805837E: variable 'v19' is possibly undefined
// 81490F0: using guessed type int dword_81490F0;

//----- (08058590) --------------------------------------------------------
void __golang runtime___ptr_mcentral__uncacheSpan(runtime_mcentral_0 *c, runtime_mspan *s)
{
  uint16 allocCount; // cx
  uintptr npages; // edx
  uintptr elemsize; // ebx
  string l; // [esp+0h] [ebp-20h]
  int32 n; // [esp+14h] [ebp-Ch]
  int v7; // [esp+1Ch] [ebp-4h]

  runtime_lock(&c->lock);
  s->incache = 0;
  allocCount = s->allocCount;
  if ( !allocCount )
  {
    l.str = (uint8 *)"uncaching span but s.allocCount == 0";
    l.len = 36;
    runtime_throw(l);
    BUG();
  }
  elemsize = s->elemsize;
  if ( !elemsize )
    runtime_panicdivide();
  npages = s->npages;
  if ( (int)((npages << 13) / elemsize - allocCount) > 0 )
  {
    n = (npages << 13) / elemsize - allocCount;
    v7 = allocCount - (npages << 13) / elemsize;
    runtime___ptr_mSpanList__remove(&c->empty, s);
    runtime___ptr_mSpanList__insert(&c->nonempty, s);
    runtime_internal_atomic_Xadd64(
      &runtime_memstats.heap_live,
      __PAIR64__((unsigned __int64)-(__int64)n >> 32, v7) * s->elemsize);
    runtime_internal_atomic_Xadd64(&c->nmalloc, __SPAIR64__((unsigned __int64)-(__int64)n >> 32, v7));
  }
  runtime_unlock(&c->lock);
}

//----- (080586D0) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
bool __golang runtime___ptr_mcentral__freeSpan(runtime_mcentral_0 *c, runtime_mspan *s, bool preserve, bool wasempty)
{
  string l; // [esp+0h] [ebp-Ch]
  string la; // [esp+0h] [ebp-Ch]
  bool result; // [esp+20h] [ebp+14h]

  if ( s->incache )
  {
    la.str = (uint8 *)"freeSpan given cached span";
    la.len = 26;
    runtime_throw(la);
    BUG();
  }
  s->needzero = 1;
  if ( preserve )
  {
    if ( !s->list )
    {
      l.str = (uint8 *)"can't preserve unlinked span";
      l.len = 28;
      runtime_throw(l);
      BUG();
    }
    runtime_internal_atomic_Store();
  }
  else
  {
    runtime_lock(&c->lock);
    if ( *(&preserve + 1) )
    {
      runtime___ptr_mSpanList__remove(&c->empty, s);
      runtime___ptr_mSpanList__insert(&c->nonempty, s);
    }
    runtime_internal_atomic_Store();
    if ( s->allocCount )
    {
      runtime_unlock(&c->lock);
    }
    else
    {
      runtime___ptr_mSpanList__remove(&c->nonempty, s);
      runtime_unlock(&c->lock);
      runtime___ptr_mheap__freeSpan(&runtime_mheap_, s, 0);
    }
  }
  return result;
}
// 80586D0: variables would overlap: ^18.1 and ^18.2
// 80586D0: inconsistent variable size for '^18.1(preserve)'
// 81490F0: using guessed type int dword_81490F0;

//----- (08058840) --------------------------------------------------------
runtime_mspan *__golang runtime___ptr_mcentral__grow(runtime_mcentral_0 *c)
{
  runtime_spanClass spanclass; // cl
  unsigned int v2; // eax
  uintptr v3; // edx
  int v4; // eax
  runtime_heapBits_0 npage; // [esp+4h] [ebp-18h]
  runtime_heapBits_0 npagea; // [esp+4h] [ebp-18h]
  bool v7; // [esp+Ch] [ebp-10h]
  runtime_mspan *v8; // [esp+Ch] [ebp-10h]
  unsigned int needzero; // [esp+10h] [ebp-Ch]
  runtime_mspan *v10; // [esp+14h] [ebp-8h]

  spanclass = c->spanclass;
  v2 = spanclass >> 1;
  if ( v2 >= 0x43 )
    runtime_panicindex();
  v3 = runtime_class_to_allocnpages[v2];
  v4 = runtime_class_to_size[v2];
  if ( !v4 )
    runtime_panicdivide();
  v10 = runtime___ptr_mheap__alloc(&runtime_mheap_, v3, spanclass, v7, v4);
  if ( !v8 )
    return 0;
  v8->limit = ((_DWORD)v10 << 13) / needzero * needzero + v8->startAddr;
  runtime_heapBitsForSpan(v8->startAddr, npage);
  runtime_heapBits_initSpan(npagea, v8);
  return v8;
}
// 80588AD: variable 'v7' is possibly undefined
// 80588C7: variable 'v8' is possibly undefined
// 80588BF: variable 'needzero' is possibly undefined
// 80588DE: variable 'npage' is possibly undefined
// 80588FA: variable 'npagea' is possibly undefined

//----- (08058930) --------------------------------------------------------
bool __golang runtime_addrspace_free(void *v, uintptr n)
{
  uintptr i; // eax
  int v3; // [esp+Ch] [ebp-8h]
  uintptr off; // [esp+10h] [ebp-4h]

  for ( i = 0; i < n; i = runtime_physPageSize + off )
  {
    off = i;
    runtime_mincore();
    if ( v3 != -22 && v3 != -12 )
      return 0;
  }
  return 1;
}
// 805898B: variable 'v3' is possibly undefined

//----- (080589B0) --------------------------------------------------------
void *__golang runtime_mmap_fixed(void *v, uintptr n, int32 prot, int32 flags, int32 fd, uint32 offset)
{
  void *v6; // eax
  void *v7; // [esp+18h] [ebp-8h]

  runtime_mmap();
  v6 = v7;
  if ( v7 != v )
  {
    if ( runtime_addrspace_free(v, n) )
    {
      if ( (unsigned int)v7 > 0x1000 )
        runtime_munmap();
      runtime_mmap();
      return v7;
    }
    else
    {
      return v7;
    }
  }
  return v6;
}
// 80589FD: variable 'v7' is possibly undefined

//----- (08058AA0) --------------------------------------------------------
void *__golang runtime_sysAlloc(uintptr n, uint64 *sysStat)
{
  string s; // [esp+0h] [ebp-20h]
  string sa; // [esp+0h] [ebp-20h]
  void *v4; // [esp+18h] [ebp-8h]

  runtime_mmap();
  if ( (unsigned int)v4 >= 0x1000 )
  {
    runtime_mSysStatInc(sysStat, n);
    return v4;
  }
  else
  {
    if ( v4 == (void *)13 )
    {
      runtime_printlock();
      sa.str = (uint8 *)"runtime: mmap: access denied\n";
      sa.len = 29;
      runtime_printstring(sa);
      runtime_printunlock();
      runtime_exit();
    }
    if ( v4 == (void *)11 )
    {
      runtime_printlock();
      s.str = (uint8 *)"runtime: mmap: too much locked memory (check 'ulimit -l').\n";
      s.len = 59;
      runtime_printstring(s);
      runtime_printunlock();
      runtime_exit();
    }
    return 0;
  }
}
// 8058AE7: variable 'v4' is possibly undefined

//----- (08058B80) --------------------------------------------------------
void __golang runtime_sysUnused(void *v, uintptr n)
{
  unsigned int v2; // eax
  unsigned int v3; // ecx
  uintptr v4; // ebx
  uintptr v5; // edx
  bool v6; // zf
  string s; // [esp+0h] [ebp-14h]
  uintptr tail; // [esp+Ch] [ebp-8h]
  uintptr head; // [esp+10h] [ebp-4h]

  v2 = (unsigned int)v;
  if ( ((unsigned int)v & 0x1FFFFF) != 0 )
    v3 = (unsigned int)v & 0xFFE00000;
  else
    v3 = 0;
  v4 = n;
  if ( (((unsigned int)v + n) & 0x1FFFFF) != 0 )
    v5 = ((unsigned int)v + n - 1) & 0xFFE00000;
  else
    v5 = 0;
  v6 = v3 == 0;
  if ( v3 )
  {
    if ( v3 + 0x200000 == v5 )
    {
LABEL_12:
      runtime_madvise();
      v2 = (unsigned int)v;
      v4 = n;
      goto LABEL_13;
    }
    v6 = v3 == 0;
  }
  if ( !v6 )
  {
    tail = v5;
    head = v3;
    runtime_madvise();
    v2 = (unsigned int)v;
    v3 = head;
    v5 = tail;
    v4 = n;
  }
  if ( v5 && v3 != v5 )
    goto LABEL_12;
LABEL_13:
  if ( ((runtime_physPageSize - 1) & v2) != 0 || ((runtime_physPageSize - 1) & v4) != 0 )
  {
    s.str = (uint8 *)"unaligned sysUnused";
    s.len = 19;
    runtime_throw(s);
    BUG();
  }
  runtime_madvise();
}

//----- (08058CE0) --------------------------------------------------------
void __golang runtime_sysUsed(void *v, uintptr n)
{
  if ( (((unsigned int)v + 0x1FFFFF) & 0xFFE00000) < (((unsigned int)v + n) & 0xFFE00000) )
    runtime_madvise();
}

//----- (08058D40) --------------------------------------------------------
void __golang runtime_sysFree(void *v, uintptr n, uint64 *sysStat)
{
  runtime_mSysStatDec(sysStat, n);
  runtime_munmap();
}

//----- (08058D70) --------------------------------------------------------
void __golang runtime_sysFault(void *v, uintptr n)
{
  runtime_mmap();
}

//----- (08058DD0) --------------------------------------------------------
void *__golang runtime_sysReserve(void *v, uintptr n, bool *reserved)
{
  void *v3; // [esp+18h] [ebp-4h]

  runtime_mmap();
  if ( (unsigned int)v3 < 0x1000 )
    return 0;
  *reserved = 1;
  return v3;
}
// 8058E25: variable 'v3' is possibly undefined

//----- (08058E50) --------------------------------------------------------
void __golang runtime_sysMap(void *v, uintptr n, bool reserved, uint64 *sysStat)
{
  string s; // [esp+0h] [ebp-20h]
  string sa; // [esp+0h] [ebp-20h]
  string sb; // [esp+0h] [ebp-20h]
  string sc; // [esp+0h] [ebp-20h]
  string sd; // [esp+0h] [ebp-20h]
  string se; // [esp+0h] [ebp-20h]
  string sf; // [esp+0h] [ebp-20h]
  void *v11; // [esp+18h] [ebp-8h]
  void *v12; // [esp+18h] [ebp-8h]

  runtime_mSysStatInc(sysStat, n);
  if ( reserved )
  {
    runtime_mmap();
    if ( v11 == (void *)12 )
    {
      sa.str = (uint8 *)"runtime: out of memory";
      sa.len = 22;
      runtime_throw(sa);
      BUG();
    }
    if ( v11 != v )
    {
      s.str = (uint8 *)"runtime: cannot map pages in arena address space";
      s.len = 48;
      runtime_throw(s);
      BUG();
    }
  }
  else
  {
    v12 = runtime_mmap_fixed(v, n, 3, 34, -1, 0);
    if ( v12 == (void *)12 )
    {
      sf.str = (uint8 *)"runtime: out of memory";
      sf.len = 22;
      runtime_throw(sf);
      BUG();
    }
    if ( v12 != v )
    {
      runtime_printlock();
      sb.str = (uint8 *)"runtime: address space conflict: map(";
      sb.len = 37;
      runtime_printstring(sb);
      runtime_printpointer(v);
      sc.str = (uint8 *)") = ";
      sc.len = 4;
      runtime_printstring(sc);
      runtime_printpointer(v12);
      sd.str = (uint8 *)"\n";
      sd.len = 1;
      runtime_printstring(sd);
      runtime_printunlock();
      se.str = (uint8 *)"runtime: address space conflict";
      se.len = 31;
      runtime_throw(se);
      BUG();
    }
  }
}
// 8058EC3: variable 'v11' is possibly undefined

//----- (08059000) --------------------------------------------------------
void __golang runtime_queuefinalizer(
        void *p,
        runtime_funcval *fn,
        uintptr nret,
        runtime__type_0 *fint,
        runtime_ptrtype_0 *ot)
{
  int i; // eax
  unsigned int v6; // ebx
  uint8 v7; // bl
  runtime_finblock *v8; // eax
  int v9; // eax
  runtime_finblock *v10; // ecx
  string l; // [esp+0h] [ebp-24h]
  uint32 cnt; // [esp+14h] [ebp-10h]
  uintptr *p_arg; // [esp+18h] [ebp-Ch]
  uintptr *dst; // [esp+1Ch] [ebp-8h]
  runtime_finblock *v15; // [esp+20h] [ebp-4h]

  if ( runtime_gcphase )
  {
    l.str = (uint8 *)"queuefinalizer during GC";
    l.len = 24;
    runtime_throw(l);
    BUG();
  }
  runtime_lock(&runtime_finlock);
  if ( !runtime_finq || runtime_finq->cnt == 204 )
  {
    if ( !runtime_finc )
    {
      runtime_finc = (runtime_finblock *)runtime_persistentalloc(0x1000u, 0, &runtime_memstats.gc_sys);
      runtime_finc->alllink = runtime_allfin;
      runtime_allfin = runtime_finc;
      if ( !runtime_finptrmask[0] )
      {
        for ( i = 0; i < 128; ++i )
        {
          v6 = i - 5 * (((int)((unsigned __int64)(3435973837LL * i) >> 32) >> 2) - (i >> 31));
          if ( v6 >= 5 || (v7 = runtime_finalizer1[v6], (unsigned int)i >= 0x80) )
            runtime_panicindex();
          runtime_finptrmask[i] = v7;
        }
      }
    }
    v8 = runtime_finc;
    runtime_finc = runtime_finc->next;
    v8->next = runtime_finq;
    runtime_finq = v8;
  }
  if ( runtime_finq->cnt >= 0xCC )
    runtime_panicindex();
  v15 = runtime_finq;
  cnt = runtime_finq->cnt;
  runtime_internal_atomic_Xadd();
  v9 = cnt;
  v10 = v15;
  if ( *(_DWORD *)&runtime_writeBarrier.enabled )
  {
    runtime_writebarrierptr((uintptr *)&v15->fin[cnt], (uintptr)fn);
    v9 = cnt;
    v10 = v15;
  }
  else
  {
    v15->fin[cnt].fn = fn;
  }
  v10->fin[v9].nret = nret;
  if ( *(_DWORD *)&runtime_writeBarrier.enabled )
  {
    dst = (uintptr *)&v10->fin[v9].ot;
    p_arg = (uintptr *)&v10->fin[v9].arg;
    runtime_writebarrierptr((uintptr *)&v10->fin[v9].fint, (uintptr)fint);
    runtime_writebarrierptr(dst, (uintptr)ot);
    runtime_writebarrierptr(p_arg, (uintptr)p);
  }
  else
  {
    v10->fin[v9].fint = fint;
    v10->fin[v9].ot = ot;
    v10->fin[v9].arg = p;
  }
  runtime_fingwake = 1;
  runtime_unlock(&runtime_finlock);
}

//----- (08059250) --------------------------------------------------------
runtime_g *__golang runtime_wakefing()
{
  uintptr v0; // eax
  runtime_g *res; // [esp+4h] [ebp-4h]

  runtime_lock(&runtime_finlock);
  if ( runtime_fingwait )
  {
    if ( runtime_fingwake )
    {
      runtime_fingwait = 0;
      runtime_fingwake = 0;
      v0 = runtime_fing;
    }
    else
    {
      v0 = 0;
    }
  }
  else
  {
    v0 = 0;
  }
  res = (runtime_g *)v0;
  runtime_unlock(&runtime_finlock);
  return res;
}

//----- (080592D0) --------------------------------------------------------
void __golang runtime_createfing()
{
  char v0; // [esp+Ch] [ebp-4h]

  if ( !runtime_fingCreate )
  {
    runtime_internal_atomic_Cas();
    if ( v0 )
      runtime_newproc(0, (runtime_funcval *)&stru_80E7CB8);
  }
}
// 8059318: variable 'v0' is possibly undefined

//----- (08059340) --------------------------------------------------------
void __golang __noreturn runtime_runfinq()
{
  uintptr v0; // eax
  uintptr *i; // ecx
  runtime_finblock *v2; // eax
  uintptr v3; // eax
  runtime_finblock *v4; // eax
  uintptr v5; // ecx
  uintptr *tab; // edx
  uint32 cnt; // ebx
  int v8; // ebx
  uintptr v9; // edi
  runtime_interfacetype_0 *v10; // ecx
  uintptr v11; // esi
  __int32 v12; // esi
  uintptr v13; // esi
  string l; // [esp+0h] [ebp-4Ch]
  string la; // [esp+0h] [ebp-4Ch]
  string reason; // [esp+4h] [ebp-48h]
  string reasona; // [esp+4h] [ebp-48h]
  runtime_iface_0 traceEv; // [esp+Ch] [ebp-40h]
  uintptr traceEva; // [esp+Ch] [ebp-40h]
  __int32 traceskip; // [esp+10h] [ebp-3Ch]
  uintptr framecap; // [esp+18h] [ebp-34h]
  uintptr framecapa; // [esp+18h] [ebp-34h]
  uintptr v23; // [esp+1Ch] [ebp-30h]
  uint32 v24; // [esp+24h] [ebp-28h]
  runtime_finblock *next; // [esp+28h] [ebp-24h]
  uintptr *frame; // [esp+2Ch] [ebp-20h]
  uintptr *framea; // [esp+2Ch] [ebp-20h]
  runtime_finblock *fba; // [esp+30h] [ebp-1Ch]
  runtime_finblock *fb; // [esp+30h] [ebp-1Ch]
  uintptr *v30; // [esp+34h] [ebp-18h]
  uintptr src; // [esp+38h] [ebp-14h]
  uintptr *dst; // [esp+40h] [ebp-Ch]
  runtime_interfacetype_0 *v33; // [esp+44h] [ebp-8h]

  v0 = 0;
  for ( i = 0; ; i = tab )
  {
    while ( 1 )
    {
      frame = i;
      framecap = v0;
      runtime_lock(&runtime_finlock);
      v2 = runtime_finq;
      runtime_finq = 0;
      if ( v2 )
        break;
      v3 = *(_DWORD *)(__readgsdword(0) - 4);
      if ( *(_DWORD *)&runtime_writeBarrier.enabled )
        runtime_writebarrierptr(&runtime_fing, v3);
      else
        runtime_fing = v3;
      runtime_fingwait = 1;
      reason.str = (uint8 *)"finalizer wait";
      reason.len = 14;
      runtime_goparkunlock(&runtime_finlock, reason, 0x14u, 1);
      v0 = framecap;
      i = frame;
    }
    fba = v2;
    runtime_unlock(&runtime_finlock);
    v4 = fba;
    v5 = framecap;
    tab = frame;
    while ( v4 )
    {
      fb = v4;
      cnt = v4->cnt;
      while ( cnt )
      {
        if ( cnt - 1 >= 0xCC )
          runtime_panicindex();
        v24 = cnt - 1;
        v8 = 5 * cnt - 5;
        v9 = *(&v4->fin[0].nret + v8) + 8;
        if ( v5 < v9 )
        {
          traceEv.tab = (runtime_itab_0 *)runtime_mallocgc(v9, 0, 1);
          tab = (uintptr *)traceEv.tab;
          v4 = fb;
          v5 = v9;
        }
        framecapa = v5;
        if ( !*((_DWORD *)&v4->fin[0].fint + v8) )
        {
          la.str = (uint8 *)"missing type in runfinq";
          la.len = 23;
          runtime_throw(la);
          BUG();
        }
        framea = tab;
        *tab = 0;
        tab[1] = 0;
        v10 = (runtime_interfacetype_0 *)*((_DWORD *)&v4->fin[0].fint + v8);
        if ( (v10->typ.kind & 0x1F) == 20 )
        {
          v33 = (runtime_interfacetype_0 *)*((_DWORD *)&v4->fin[0].fint + v8);
          v11 = *((_DWORD *)&v4->fin[0].ot + v8);
          if ( *(_DWORD *)&runtime_writeBarrier.enabled )
          {
            runtime_writebarrierptr(tab, v11);
            v4 = fb;
            v10 = v33;
            tab = framea;
          }
          else
          {
            *tab = v11;
          }
          dst = tab + 1;
          v12 = *((_DWORD *)&v4->fin[0].arg + v8);
          if ( *(_DWORD *)&runtime_writeBarrier.enabled )
          {
            src = *((_DWORD *)&v4->fin[0].arg + v8);
            runtime_writebarrierptr(dst, v12);
            v10 = v33;
            tab = framea;
            v12 = src;
          }
          else
          {
            tab[1] = v12;
          }
          if ( v10->mhdr.len )
          {
            reasona.str = (uint8 *)*tab;
            reasona.len = v12;
            runtime_assertE2I(v10, (runtime_eface_0)reasona, traceEv);
            if ( *(_DWORD *)&runtime_writeBarrier.enabled )
            {
              runtime_writebarrierptr(framea, traceEva);
              runtime_writebarrierptr(dst, traceskip);
            }
            else
            {
              *framea = traceEva;
              framea[1] = traceskip;
            }
          }
        }
        else
        {
          if ( (v10->typ.kind & 0x1F) != 22 )
          {
            l.str = (uint8 *)"bad kind in runfinq";
            l.len = 19;
            runtime_throw(l);
            BUG();
          }
          v13 = *((_DWORD *)&v4->fin[0].arg + v8);
          if ( *(_DWORD *)&runtime_writeBarrier.enabled )
            runtime_writebarrierptr(tab, v13);
          else
            *tab = v13;
        }
        runtime_fingRunning = 1;
        traceEv.tab = (runtime_itab_0 *)v9;
        traceEv.data = (void *)v9;
        runtime_reflectcall();
        runtime_fingRunning = 0;
        if ( *(_DWORD *)&runtime_writeBarrier.enabled )
        {
          runtime_writebarrierptr((uintptr *)fb->fin + v8, 0);
          runtime_writebarrierptr((uintptr *)&fb->fin[0].arg + v8, 0);
          runtime_writebarrierptr((uintptr *)&fb->fin[0].ot + v8, 0);
        }
        else
        {
          (&fb->fin[0].fn)[v8] = 0;
          *((_DWORD *)&fb->fin[0].arg + v8) = 0;
          *((_DWORD *)&fb->fin[0].ot + v8) = 0;
        }
        runtime_internal_atomic_Store();
        v4 = fb;
        cnt = v24;
        v5 = framecapa;
        tab = framea;
      }
      v30 = tab;
      v23 = v5;
      next = v4->next;
      runtime_lock(&runtime_finlock);
      fb->next = runtime_finc;
      runtime_finc = fb;
      runtime_unlock(&runtime_finlock);
      v4 = next;
      v5 = v23;
      tab = v30;
    }
    v0 = v5;
  }
}
// 80595AD: variable 'traceEv' is possibly undefined
// 80595C8: variable 'traceEva' is possibly undefined
// 80595CA: variable 'traceskip' is possibly undefined

//----- (08059790) --------------------------------------------------------
void __golang runtime_SetFinalizer(interface_{} obj, interface_{} finalizer)
{
  runtime__type_0 *type; // eax
  uintptr size; // edx
  runtime__type_0 *v4; // edx
  int v5; // ebp
  runtime_interfacetype_0 *v6; // ebx
  int v7; // ecx
  char *v8; // ecx
  __int16 v9; // bp
  unsigned __int16 v10; // dx
  unsigned int v11; // esi
  unsigned int v12; // edx
  int v13; // edx
  runtime__type_0 **v14; // ecx
  int v15; // ebp
  int v16; // esi
  runtime__type_0 *v17; // edx
  runtime_moduledata *i; // ecx
  __int32 v19; // eax
  uint8 *v20; // ecx
  string v21; // kr00_8
  __int32 v22; // eax
  uint8 *v23; // ecx
  __int32 v24; // eax
  uint8 *v25; // ecx
  __int32 len; // eax
  uint8 *str; // ecx
  string v; // [esp+0h] [ebp-78h]
  string va; // [esp+0h] [ebp-78h]
  string vb; // [esp+0h] [ebp-78h]
  string vc; // [esp+0h] [ebp-78h]
  runtime_mspan *e; // [esp+4h] [ebp-74h]
  string ea; // [esp+4h] [ebp-74h]
  string eb[4]; // [esp+4h] [ebp-74h]
  string ec[4]; // [esp+4h] [ebp-74h]
  string ed; // [esp+4h] [ebp-74h]
  string ee[5]; // [esp+4h] [ebp-74h]
  string ef[3]; // [esp+4h] [ebp-74h]
  string eg[3]; // [esp+4h] [ebp-74h]
  void *e_4; // [esp+8h] [ebp-70h]
  void *e_4a; // [esp+8h] [ebp-70h]
  runtime_iface_0 v42; // [esp+Ch] [ebp-6Ch]
  bool v43; // [esp+14h] [ebp-64h]
  char v44; // [esp+14h] [ebp-64h]
  string v45; // [esp+1Ch] [ebp-5Ch]
  string v46; // [esp+1Ch] [ebp-5Ch]
  string s; // [esp+24h] [ebp-54h]
  string sa; // [esp+24h] [ebp-54h]
  string v49; // [esp+2Ch] [ebp-4Ch]
  __int32 v50; // [esp+38h] [ebp-40h]
  __int32 v51; // [esp+38h] [ebp-40h]
  runtime__type_0 *t; // [esp+44h] [ebp-34h]
  uint8 *v53; // [esp+48h] [ebp-30h]
  uint8 *v54; // [esp+48h] [ebp-30h]

  if ( runtime_debug.sbrk )
    return;
  if ( !obj._type )
  {
    vc.str = (uint8 *)"runtime.SetFinalizer: first argument is nil";
    vc.len = 43;
    runtime_throw(vc);
    BUG();
  }
  if ( (obj._type->kind & 0x1F) != 22 )
  {
    eg[0] = runtime___ptr__type__string(obj._type);
    len = eg[0].len;
    str = eg[0].str;
    eg[0].str = (uint8 *)"runtime.SetFinalizer: first argument is ";
    eg[0].len = 40;
    eg[1] = (string)__PAIR64__(len, (unsigned int)str);
    eg[2].str = (uint8 *)", not pointer";
    eg[2].len = 13;
    v46 = runtime_concatstring3(0, *(string (*)[3])&eg[0].str);
    runtime_throw(v46);
    BUG();
  }
  if ( !obj._type[1].size )
  {
    vb.str = (uint8 *)"nil elem type!";
    vb.len = 14;
    runtime_throw(vb);
    BUG();
  }
  runtime_findObject(obj.data, e, e_4, (uintptr)v42.tab);
  if ( e_4a )
  {
    if ( obj.data == e_4a )
    {
      type = obj._type;
    }
    else
    {
      type = obj._type;
      size = obj._type[1].size;
      if ( !size || *(char *)(size + 15) >= 0 || *(_DWORD *)size >= 0x10u )
      {
        v.str = (uint8 *)"runtime.SetFinalizer: pointer not at beginning of allocated block";
        v.len = 65;
        runtime_throw(v);
        BUG();
      }
    }
    v4 = finalizer._type;
    if ( !finalizer._type )
    {
      runtime_systemstack();
      return;
    }
    if ( (finalizer._type->kind & 0x1F) != 19 )
    {
      ef[0].str = (uint8 *)"runtime.SetFinalizer: second argument is ";
      ef[0].len = 41;
      ef[1] = runtime___ptr__type__string(finalizer._type);
      ef[2].str = (uint8 *)", not a function";
      ef[2].len = 16;
      v45 = runtime_concatstring3(0, *(string (*)[3])&ef[0].str);
      runtime_throw(v45);
      BUG();
    }
    if ( (finalizer._type[1].size & 0x80000000) != 0 )
    {
      ed = runtime___ptr__type__string(type);
      v51 = ed.len;
      v54 = ed.str;
      ee[0] = runtime___ptr__type__string(finalizer._type);
      v24 = ee[0].len;
      v25 = ee[0].str;
      ee[0].str = (uint8 *)"runtime.SetFinalizer: cannot pass ";
      ee[0].len = 34;
      ee[1] = (string)__PAIR64__(v51, (unsigned int)v54);
      ee[2].str = (uint8 *)" to finalizer ";
      ee[2].len = 14;
      ee[3] = (string)__PAIR64__(v24, (unsigned int)v25);
      ee[4].str = (uint8 *)" because dotdotdot";
      ee[4].len = 18;
      v49 = runtime_concatstring5(0, *(string (*)[5])&ee[0].str);
      runtime_throw(v49);
      BUG();
    }
    if ( LOWORD(finalizer._type[1].size) != 1 )
    {
      v21 = runtime___ptr__type__string(type);
      ec[0] = runtime___ptr__type__string(finalizer._type);
      v22 = ec[0].len;
      v23 = ec[0].str;
      ec[0].str = (uint8 *)"runtime.SetFinalizer: cannot pass ";
      ec[0].len = 34;
      ec[1] = v21;
      ec[2].str = (uint8 *)" to finalizer ";
      ec[2].len = 14;
      ec[3] = (string)__PAIR64__(v22, (unsigned int)v23);
      sa = runtime_concatstring4(0, *(string (*)[4])&ec[0].str);
      runtime_throw(sa);
      BUG();
    }
    if ( (finalizer._type->tflag & 1) != 0 )
      v5 = 52;
    else
      v5 = 36;
    v6 = *(runtime_interfacetype_0 **)((char *)&finalizer._type->size + v5);
    if ( v6 == (runtime_interfacetype_0 *)type )
      goto LABEL_17;
    if ( (v6->typ.kind & 0x1F) == 22 )
    {
      if ( runtime___ptr__type__uncommon(&v6->typ) && runtime___ptr__type__uncommon(obj._type) )
      {
        v17 = obj._type;
      }
      else
      {
        v17 = obj._type;
        if ( v6->pkgpath.bytes == (uint8 *)obj._type[1].size )
        {
          v4 = finalizer._type;
          goto LABEL_17;
        }
      }
    }
    else if ( (v6->typ.kind & 0x1F) == 20 )
    {
      if ( !v6->mhdr.len )
      {
LABEL_17:
        if ( (v4->tflag & 1) != 0 )
          v7 = 52;
        else
          v7 = 36;
        v8 = (char *)v4 + v7;
        v9 = HIWORD(v4[1].size) & 0x7FFF;
        v10 = v4[1].size;
        v11 = v10;
        v12 = (unsigned __int16)(v9 + v10);
        if ( v11 > v12 )
          runtime_panicslice();
        v13 = v12 - v11;
        v14 = (runtime__type_0 **)&v8[((int)(v11 - 0x100000) >> 31) & (4 * v11)];
        v15 = 0;
        v16 = 0;
        while ( v15 < v13 )
        {
          t = *v14++;
          ++v15;
          v16 = t->size + ((v16 + t->align - 1) & ~(t->align - 1));
        }
        runtime_createfing();
        ((void (*)(void))loc_808FD8A)();
        runtime_systemstack();
        return;
      }
      runtime_assertE2I2(v6, obj, v42, v43);
      if ( v44 )
      {
        v4 = finalizer._type;
        goto LABEL_17;
      }
      v17 = obj._type;
    }
    else
    {
      v17 = type;
    }
    ea = runtime___ptr__type__string(v17);
    v50 = ea.len;
    v53 = ea.str;
    eb[0] = runtime___ptr__type__string(finalizer._type);
    v19 = eb[0].len;
    v20 = eb[0].str;
    eb[0].str = (uint8 *)"runtime.SetFinalizer: cannot pass ";
    eb[0].len = 34;
    eb[1] = (string)__PAIR64__(v50, (unsigned int)v53);
    eb[2].str = (uint8 *)" to finalizer ";
    eb[2].len = 14;
    eb[3] = (string)__PAIR64__(v19, (unsigned int)v20);
    s = runtime_concatstring4(0, *(string (*)[4])&eb[0].str);
    runtime_throw(s);
    BUG();
  }
  if ( &runtime_zerobase != obj.data )
  {
    for ( i = &runtime_firstmoduledata; ; i = i->next )
    {
      if ( !i )
      {
        va.str = (uint8 *)"runtime.SetFinalizer: pointer not in allocated block";
        va.len = 52;
        runtime_throw(va);
        BUG();
      }
      if ( (void *)i->noptrdata <= obj.data && obj.data < (void *)i->enoptrdata
        || (void *)i->data <= obj.data && obj.data < (void *)i->edata
        || (void *)i->bss <= obj.data && obj.data < (void *)i->ebss
        || (void *)i->noptrbss <= obj.data && obj.data < (void *)i->enoptrbss )
      {
        break;
      }
    }
  }
}
// 805989F: conditional instruction was optimized away because bx.2==1
// 80598F0: conditional instruction was optimized away because edx.4<10000u
// 80597EC: variable 'e' is possibly undefined
// 80597EC: variable 'e_4' is possibly undefined
// 80597EC: variable 'v42' is possibly undefined
// 80597F7: variable 'e_4a' is possibly undefined
// 80599F1: variable 'v43' is possibly undefined
// 80599FD: variable 'v44' is possibly undefined

//----- (08059E00) --------------------------------------------------------
void __golang runtime_findObject(void *v, runtime_mspan *s, void *x, uintptr n)
{
  runtime_mcache *v4; // edx
  unsigned int v5; // ecx
  unsigned int v6; // eax
  int v7; // ecx
  runtime_mcache *c; // [esp+4h] [ebp-4h]

  v4 = *(runtime_mcache **)(*(_DWORD *)(*(_DWORD *)(__readgsdword(0) - 4) + 24) + 184);
  v5 = v4->local_nlookup + 1;
  v4->local_nlookup = v5;
  if ( v5 >= 0x40000000 )
  {
    c = v4;
    runtime_lock(&runtime_mheap_.lock);
    runtime_purgecachedstats(c);
    runtime_unlock(&runtime_mheap_.lock);
  }
  if ( (unsigned int)v >= dword_81493A8 && (unsigned int)v < dword_81493AC )
  {
    v6 = ((unsigned int)v >> 13) - ((unsigned int)dword_81493A8 >> 13);
    if ( v6 >= dword_814910C )
      runtime_panicindex();
    v7 = *(_DWORD *)(dword_8149108 + 4 * v6);
    if ( v7
      && (unsigned int)v >= *(_DWORD *)(v7 + 12)
      && (unsigned int)v < *(_DWORD *)(v7 + 80)
      && *(_BYTE *)(v7 + 60) == 1
      && *(_BYTE *)(v7 + 58) >> 1
      && !*(_DWORD *)(v7 + 64) )
    {
      runtime_panicdivide();
    }
  }
}
// 8149108: using guessed type int dword_8149108;
// 814910C: using guessed type int dword_814910C;
// 81493A8: using guessed type int dword_81493A8;
// 81493AC: using guessed type int dword_81493AC;

//----- (08059F80) --------------------------------------------------------
void *__golang runtime___ptr_fixalloc__alloc(runtime_fixalloc_0 *f)
{
  runtime_fixalloc_0 *v1; // eax
  runtime_mlink *list; // ebx
  void *chunk; // ecx
  void (__golang **first)(void *, void *); // edx
  string size; // [esp+0h] [ebp-18h]
  string sizea; // [esp+0h] [ebp-18h]
  void *v; // [esp+10h] [ebp-8h]

  v1 = f;
  if ( !f->size )
  {
    runtime_printlock();
    size.str = (uint8 *)"runtime: use of FixAlloc_Alloc before FixAlloc_Init\n";
    size.len = 52;
    runtime_printstring(size);
    runtime_printunlock();
    sizea.str = (uint8 *)"runtime: internal error";
    sizea.len = 23;
    runtime_throw(sizea);
    BUG();
  }
  list = f->list;
  if ( list )
  {
    f->list = list->next;
    f->inuse += f->size;
    if ( f->zero )
      runtime_memclrNoHeapPointers();
    return list;
  }
  else
  {
    if ( f->nchunk < f->size )
    {
      f->chunk = (uintptr)runtime_persistentalloc(0x4000u, 0, f->stat);
      f->nchunk = 0x4000;
      v1 = f;
    }
    chunk = (void *)v1->chunk;
    first = (void (__golang **)(void *, void *))v1->first;
    if ( first )
    {
      v = (void *)v1->chunk;
      (*first)(v1->arg, chunk);
      v1 = f;
      chunk = v;
    }
    v1->chunk += v1->size;
    v1->nchunk -= v1->size;
    v1->inuse += v1->size;
    return chunk;
  }
}

//----- (0805A0B0) --------------------------------------------------------
void __golang runtime_gcinit()
{
  int32 y; // [esp+0h] [ebp-10h]
  int32 y_4; // [esp+4h] [ebp-Ch]
  uint64 v2; // [esp+8h] [ebp-8h]
  uint64 v3; // [esp+8h] [ebp-8h]

  ptr = 1;
  *(_QWORD *)&runtime_memstats.triggerRatio = _f64_3fec000000000000;
  *(double *)&v2 = runtime_uint64tofloat64(runtime_heapminimum);
  runtime_float64touint64(*(double *)&v2 / (runtime_memstats.triggerRatio + 1.0), v2);
  runtime_memstats.heap_marked = v3;
  y = runtime_readgogc();
  runtime_debug_setGCPercent(y, y_4);
  runtime_work.startSema = 1;
  runtime_work.markDoneSema = 1;
}
// 805A12B: variable 'v3' is possibly undefined
// 805A13C: variable 'y_4' is possibly undefined
// 80F1848: using guessed type __int64 _f64_3fec000000000000;

//----- (0805A170) --------------------------------------------------------
int32 __golang runtime_readgogc()
{
  string key; // [esp+0h] [ebp-10h]
  string s; // [esp+8h] [ebp-8h]
  string sa; // [esp+8h] [ebp-8h]

  key.str = (uint8 *)"GOGC";
  key.len = 4;
  s = runtime_gogetenv(key);
  if ( s.len == 3 && *(_WORD *)s.str == 26223 && s.str[2] == 102 )
    return -1;
  sa = (string)runtime_atoi32(s);
  if ( LOBYTE(sa.len) )
    return (int32)sa.str;
  else
    return 100;
}

//----- (0805A200) --------------------------------------------------------
void __golang runtime_gcenable()
{
  runtime_hchan *size_4; // [esp+8h] [ebp-Ch]

  size_4 = runtime_makechan((runtime_chantype_0 *)&stru_80CA680, 1LL);
  runtime_newproc(4, (runtime_funcval *)&stru_80E7B94);
  runtime_chanrecv1(size_4, 0);
  runtime_memstats.enablegc = 1;
}

//----- (0805A280) --------------------------------------------------------
void __golang runtime_debug_setGCPercent(int32 in, int32 out)
{
  int32 v2; // ecx

  runtime_lock(&runtime_mheap_.lock);
  v2 = in;
  if ( in < 0 )
    v2 = -1;
  runtime_gcpercent = v2;
  runtime_heapminimum = runtime_uint64div((__int64)v2 << 22, 0x64uLL);
  runtime_gcSetTriggerRatio(runtime_memstats.triggerRatio);
  runtime_unlock(&runtime_mheap_.lock);
}

//----- (0805A340) --------------------------------------------------------
void __golang runtime_setGCPhase(uint32 x)
{
  bool v1; // al
  bool v2; // al

  runtime_internal_atomic_Store();
  v1 = runtime_gcphase == 1 || runtime_gcphase == 2;
  runtime_writeBarrier.needed = v1;
  v2 = v1 || runtime_writeBarrier.cgo;
  runtime_writeBarrier.enabled = v2;
}

//----- (0805A3A0) --------------------------------------------------------
void __golang runtime___ptr_gcControllerState__startCycle(runtime_gcControllerState_0 *c)
{
  uint64 heap_marked; // kr00_8
  int v2; // ecx
  runtime_p **i; // edx
  runtime_p *v4; // ebx
  string n; // [esp+0h] [ebp-48h]
  string na; // [esp+0h] [ebp-48h]
  string nb; // [esp+0h] [ebp-48h]
  string nc; // [esp+0h] [ebp-48h]
  string nd; // [esp+0h] [ebp-48h]
  string ne; // [esp+0h] [ebp-48h]
  string nf; // [esp+0h] [ebp-48h]
  string ng; // [esp+0h] [ebp-48h]
  uint64 d; // [esp+8h] [ebp-40h]
  uint64 dc; // [esp+8h] [ebp-40h]
  float64 dd; // [esp+8h] [ebp-40h]
  uint64 da; // [esp+8h] [ebp-40h]
  uint64 db; // [esp+8h] [ebp-40h]
  int64 fractionalMarkWorkersNeeded; // [esp+18h] [ebp-30h]
  int64 dedicatedMarkWorkersNeeded; // [esp+20h] [ebp-28h]
  uint64 next_gc; // [esp+28h] [ebp-20h]
  uint64 initialHeapLive; // [esp+30h] [ebp-18h]
  uint64 heap_scan; // [esp+38h] [ebp-10h]
  double v; // [esp+40h] [ebp-8h]
  float64 va; // [esp+40h] [ebp-8h]

  c->scanWork = 0LL;
  c->bgScanCredit = 0LL;
  c->assistTime = 0LL;
  c->dedicatedMarkTime = 0LL;
  c->fractionalMarkTime = 0LL;
  c->idleMarkTime = 0LL;
  if ( HIDWORD(runtime_memstats.gc_trigger) < HIDWORD(runtime_heapminimum)
    || HIDWORD(runtime_memstats.gc_trigger) == HIDWORD(runtime_heapminimum)
    && LODWORD(runtime_memstats.gc_trigger) <= (unsigned int)runtime_heapminimum )
  {
    *(double *)&da = runtime_uint64tofloat64(runtime_memstats.gc_trigger);
    runtime_float64touint64(*(double *)&da / (runtime_memstats.triggerRatio + 1.0), da);
    runtime_memstats.heap_marked = db;
  }
  heap_marked = runtime_memstats.heap_marked;
  runtime_memstats.next_gc = heap_marked + runtime_uint64div(runtime_gcpercent * runtime_memstats.heap_marked, 0x64uLL);
  if ( runtime_gcpercent < 0 )
    runtime_memstats.next_gc = -1LL;
  if ( HIDWORD(runtime_memstats.next_gc) < (runtime_memstats.heap_live + 0x100000) >> 32
    || LODWORD(runtime_memstats.next_gc) < LODWORD(runtime_memstats.heap_live) + 0x100000
    && HIDWORD(runtime_memstats.next_gc) == (runtime_memstats.heap_live + 0x100000) >> 32 )
  {
    runtime_memstats.next_gc = runtime_memstats.heap_live + 0x100000;
  }
  v = (double)runtime_gomaxprocs * 0.25;
  runtime_float64toint64(v, d);
  c->dedicatedMarkWorkersNeeded = dc;
  dd = runtime_int64tofloat64(dc);
  c->fractionalUtilizationGoal = v - dd;
  LODWORD(c->fractionalMarkWorkersNeeded) = v - dd > 0.0;
  HIDWORD(c->fractionalMarkWorkersNeeded) = 0;
  v2 = 0;
  for ( i = runtime_allp; v2 < 1025; ++i )
  {
    v4 = *i;
    if ( !*i )
      break;
    LODWORD(v4->gcAssistTime) = 0;
    HIDWORD(v4->gcAssistTime) = 0;
    ++v2;
  }
  runtime___ptr_gcControllerState__revise(c);
  if ( runtime_debug.gcpacertrace > 0 )
  {
    va = c->assistWorkPerByte;
    heap_scan = runtime_memstats.heap_scan;
    initialHeapLive = runtime_work.initialHeapLive;
    next_gc = runtime_memstats.next_gc;
    dedicatedMarkWorkersNeeded = c->dedicatedMarkWorkersNeeded;
    fractionalMarkWorkersNeeded = c->fractionalMarkWorkersNeeded;
    runtime_printlock();
    n.str = (uint8 *)"pacer: assist ratio=";
    n.len = 20;
    runtime_printstring(n);
    runtime_printfloat(va);
    na.str = (uint8 *)" (scan ";
    na.len = 7;
    runtime_printstring(na);
    runtime_printuint(heap_scan >> 20);
    nb.str = (uint8 *)" MB in ";
    nb.len = 7;
    runtime_printstring(nb);
    runtime_printuint(initialHeapLive >> 20);
    nc.str = (uint8 *)"->";
    nc.len = 2;
    runtime_printstring(nc);
    runtime_printuint(next_gc >> 20);
    nd.str = (uint8 *)" MB)";
    nd.len = 4;
    runtime_printstring(nd);
    ne.str = (uint8 *)" workers=";
    ne.len = 9;
    runtime_printstring(ne);
    runtime_printint(dedicatedMarkWorkersNeeded);
    nf.str = (uint8 *)"+";
    nf.len = 1;
    runtime_printstring(nf);
    runtime_printint(fractionalMarkWorkersNeeded);
    ng.str = (uint8 *)"\n";
    ng.len = 1;
    runtime_printstring(ng);
    runtime_printunlock();
  }
}
// 805A801: variable 'db' is possibly undefined
// 805A542: variable 'd' is possibly undefined
// 805A553: variable 'dc' is possibly undefined
// 80E0D88: using guessed type char asc_80E0D88;

//----- (0805A820) --------------------------------------------------------
void __golang runtime___ptr_gcControllerState__revise(runtime_gcControllerState_0 *c)
{
  bool v1; // t1
  uint64 v2; // rax
  int v3; // eax
  int v4; // ecx
  __int64 y_4; // [esp+4h] [ebp-24h]
  int64 scanWorkExpected_lo; // [esp+10h] [ebp-18h]
  int64 heapDistance_lo; // [esp+18h] [ebp-10h]
  double v8; // [esp+20h] [ebp-8h]
  double v9; // [esp+20h] [ebp-8h]

  v2 = runtime_memstats.heap_scan - c->scanWork;
  v1 = (unsigned int)v2 < 0x3E8;
  LODWORD(v2) = LODWORD(runtime_memstats.heap_scan) - LODWORD(c->scanWork);
  if ( (((runtime_memstats.heap_scan - c->scanWork) >> 32) & 0x80000000) != 0LL
    || (runtime_memstats.heap_scan - c->scanWork) >> 32 == 0 && v1 )
  {
    v2 = 1000LL;
  }
  scanWorkExpected_lo = v2;
  runtime_internal_atomic_Load64();
  v4 = (runtime_memstats.next_gc - y_4) >> 32;
  v3 = LODWORD(runtime_memstats.next_gc) - y_4;
  if ( v4 < 0 || v4 == 0 && LODWORD(runtime_memstats.next_gc) == (_DWORD)y_4 )
  {
    v3 = 1;
    v4 = 0;
  }
  heapDistance_lo = __PAIR64__(v4, v3);
  v8 = runtime_int64tofloat64(scanWorkExpected_lo);
  c->assistWorkPerByte = v8 / runtime_int64tofloat64(heapDistance_lo);
  v9 = runtime_int64tofloat64(heapDistance_lo);
  c->assistBytesPerWork = v9 / runtime_int64tofloat64(scanWorkExpected_lo);
}
// 805A820: could not find valid save-restore pair for ebx
// 805A899: variable 'y_4' is possibly undefined

//----- (0805A980) --------------------------------------------------------
float64 __golang runtime___ptr_gcControllerState__endCycle(runtime_gcControllerState_0 *c)
{
  unsigned int markStartTime; // edx
  double v2; // xmm0_8
  double v3; // xmm1_8
  __int64 v4; // rax
  double v5; // xmm3_8
  double v6; // xmm0_8
  double v7; // xmm1_8
  uint64 y; // [esp+0h] [ebp-84h]
  string ya; // [esp+0h] [ebp-84h]
  string yb; // [esp+0h] [ebp-84h]
  string yc; // [esp+0h] [ebp-84h]
  string yd; // [esp+0h] [ebp-84h]
  string ye; // [esp+0h] [ebp-84h]
  string yf; // [esp+0h] [ebp-84h]
  string yg; // [esp+0h] [ebp-84h]
  string yh; // [esp+0h] [ebp-84h]
  string yi; // [esp+0h] [ebp-84h]
  string yj; // [esp+0h] [ebp-84h]
  string yk; // [esp+0h] [ebp-84h]
  string yl; // [esp+0h] [ebp-84h]
  string ym; // [esp+0h] [ebp-84h]
  string yn; // [esp+0h] [ebp-84h]
  uint64 v23; // [esp+8h] [ebp-7Ch]
  int64 v24; // [esp+8h] [ebp-7Ch]
  __int64 assistDuration_lo; // [esp+10h] [ebp-74h]
  int64 W_a_lo; // [esp+18h] [ebp-6Ch]
  uint64 H_m_prev_lo; // [esp+20h] [ebp-64h]
  uint64 H_a_lo; // [esp+30h] [ebp-54h]
  uint64 H_T_lo; // [esp+38h] [ebp-4Ch]
  int v30; // [esp+40h] [ebp-44h]
  double v31; // [esp+44h] [ebp-40h]
  float64 v; // [esp+5Ch] [ebp-28h]
  double v33; // [esp+64h] [ebp-20h]
  double v34; // [esp+6Ch] [ebp-18h]
  double v35; // [esp+74h] [ebp-10h]
  double v36; // [esp+74h] [ebp-10h]
  double v37; // [esp+74h] [ebp-10h]
  float64 v38; // [esp+7Ch] [ebp-8h] BYREF
  float64 _r0_4; // [esp+90h] [ebp+Ch]

  while ( (unsigned int)&v38 + 4 <= *(_DWORD *)(*(_DWORD *)(__readgsdword(0) - 4) + 8) )
    runtime_morestack_noctxt();
  if ( runtime_work.userForced )
  {
    LODWORD(_r0_4) = HIDWORD(runtime_memstats.triggerRatio);
  }
  else
  {
    v30 = runtime_gcpercent;
    v38 = runtime_uint64tofloat64(runtime_memstats.heap_live);
    v35 = runtime_uint64tofloat64(runtime_memstats.heap_marked);
    runtime_nanotime();
    markStartTime = c->markStartTime;
    LODWORD(v4) = y - markStartTime;
    v2 = (double)v30 / 100.0;
    v34 = v2;
    v3 = v38 / v35 - 1.0;
    v38 = v3;
    HIDWORD(v4) = (y - __PAIR64__(HIDWORD(c->markStartTime), markStartTime)) >> 32;
    if ( (_DWORD)v4 != 0 && HIDWORD(v4) == 0 || SHIDWORD(v4) > 0 )
    {
      assistDuration_lo = v4;
      v37 = runtime_int64tofloat64(c->assistTime);
      v5 = v37 / runtime_int64tofloat64(runtime_gomaxprocs * assistDuration_lo) + 0.25;
      v2 = (double)v30 / 100.0;
      v3 = v38;
    }
    else
    {
      v5 = _f64_3fd0000000000000;
    }
    v36 = v2 - runtime_memstats.triggerRatio;
    v33 = v3 - runtime_memstats.triggerRatio;
    v6 = v2 - runtime_memstats.triggerRatio - (v3 - runtime_memstats.triggerRatio) * (4.0 * v5);
    v7 = 0.5 * v6 + runtime_memstats.triggerRatio;
    if ( runtime_debug.gcpacertrace > 0 )
    {
      v = runtime_memstats.triggerRatio;
      v31 = 0.5 * v6 + runtime_memstats.triggerRatio;
      H_m_prev_lo = runtime_memstats.heap_marked;
      H_T_lo = runtime_memstats.gc_trigger;
      H_a_lo = runtime_memstats.heap_live;
      *(double *)&v23 = runtime_uint64tofloat64(runtime_memstats.heap_marked);
      runtime_float64toint64((v34 + 1.0) * *(double *)&v23, v23);
      W_a_lo = c->scanWork;
      runtime_printlock();
      ya.str = (uint8 *)"pacer: H_m_prev=";
      ya.len = 16;
      runtime_printstring(ya);
      runtime_printuint(H_m_prev_lo);
      yb.str = (uint8 *)" h_t=";
      yb.len = 5;
      runtime_printstring(yb);
      runtime_printfloat(v);
      yc.str = (uint8 *)" H_T=";
      yc.len = 5;
      runtime_printstring(yc);
      runtime_printuint(H_T_lo);
      yd.str = (uint8 *)" h_a=";
      yd.len = 5;
      runtime_printstring(yd);
      runtime_printfloat(v38);
      ye.str = (uint8 *)" H_a=";
      ye.len = 5;
      runtime_printstring(ye);
      runtime_printuint(H_a_lo);
      yf.str = (uint8 *)" h_g=";
      yf.len = 5;
      runtime_printstring(yf);
      runtime_printfloat(v34);
      yg.str = (uint8 *)" H_g=";
      yg.len = 5;
      runtime_printstring(yg);
      runtime_printint(v24);
      yh.str = (uint8 *)" u_a=";
      yh.len = 5;
      runtime_printstring(yh);
      runtime_printfloat(v5);
      yi.str = (uint8 *)" u_g=";
      yi.len = 5;
      runtime_printstring(yi);
      runtime_printfloat(0.25);
      yj.str = (uint8 *)" W_a=";
      yj.len = 5;
      runtime_printstring(yj);
      runtime_printint(W_a_lo);
      yk.str = (uint8 *)" goalΔ=";
      yk.len = 8;
      runtime_printstring(yk);
      runtime_printfloat(v36);
      yl.str = (uint8 *)" actualΔ=";
      yl.len = 10;
      runtime_printstring(yl);
      runtime_printfloat(v33);
      ym.str = (uint8 *)" u_a/u_g=";
      ym.len = 9;
      runtime_printstring(ym);
      runtime_printfloat(4.0 * v5);
      yn.str = (uint8 *)"\n";
      yn.len = 1;
      runtime_printstring(yn);
      runtime_printunlock();
      HIDWORD(v7) = HIDWORD(v31);
    }
    LODWORD(_r0_4) = HIDWORD(v7);
  }
  return _r0_4;
}
// 805AA13: variable 'y' is possibly undefined
// 805ACA5: variable 'v24' is possibly undefined

//----- (0805AE70) --------------------------------------------------------
void __golang runtime___ptr_gcControllerState__enlistWorker(runtime_gcControllerState_0 *c)
{
  int v1; // ecx
  int v2; // ecx
  int v3; // ecx
  int v4; // ecx
  int i; // eax
  int v6; // edx
  int32 v7; // ebx
  unsigned int v8; // esi
  unsigned __int32 v9; // edx
  int v10; // ebx
  int v11; // edx
  runtime_p *v12; // edx
  _DWORD *m; // edx
  char v14; // al
  int v15; // esi

  if ( (LODWORD(c->dedicatedMarkWorkersNeeded) != 0 || HIDWORD(c->dedicatedMarkWorkersNeeded) != 0)
    && c->dedicatedMarkWorkersNeeded >= 0
    && runtime_gomaxprocs > 1 )
  {
    v1 = *(_DWORD *)(__readgsdword(0) - 4);
    if ( v1 )
    {
      v2 = *(_DWORD *)(v1 + 24);
      if ( v2 )
      {
        v3 = *(_DWORD *)(v2 + 92);
        if ( v3 )
        {
          v4 = *(_DWORD *)(v3 + 4);
          for ( i = 0; i < 5; i = v10 + 1 )
          {
            v6 = *(_DWORD *)(*(_DWORD *)(__readgsdword(0) - 4) + 24);
            v7 = runtime_gomaxprocs;
            v8 = (*(int *)(v6 + 148) >> 31) & 0xA8888EEF ^ (2 * *(_DWORD *)(v6 + 148));
            *(_DWORD *)(v6 + 148) = v8;
            v9 = v7 - 1;
            if ( v7 == 1 )
              runtime_panicdivide();
            v10 = i;
            v11 = v8 % v9;
            if ( v11 >= v4 )
              ++v11;
            if ( (unsigned int)v11 >= 0x401 )
              runtime_panicindex();
            v12 = runtime_allp[v11];
            if ( v12->status == 1 )
            {
              m = (_DWORD *)v12->m;
              if ( m && m != *(_DWORD **)(*(_DWORD *)(__readgsdword(0) - 4) + 24) )
              {
                v15 = m[21];
                if ( v15 && v15 != *m )
                {
                  *(_BYTE *)(v15 + 108) = 1;
                  *(_DWORD *)(v15 + 8) = -1314;
                  v14 = 1;
                }
                else
                {
                  v14 = 0;
                }
              }
              else
              {
                v14 = 0;
              }
              if ( v14 )
                break;
            }
          }
        }
      }
    }
  }
}

//----- (0805AFC0) --------------------------------------------------------
runtime_g *__golang runtime___ptr_gcControllerState__findRunnableGCWorker(
        runtime_gcControllerState_0 *c,
        runtime_p *_p_)
{
  runtime_p *v2; // eax
  __int64 p; // [esp+0h] [ebp-2Ch]
  string pa; // [esp+0h] [ebp-2Ch]
  int64 now_lo; // [esp+14h] [ebp-18h]
  double v6; // [esp+1Ch] [ebp-10h]
  runtime_g *gp; // [esp+28h] [ebp-4h]

  if ( !runtime_gcBlackenEnabled )
  {
    pa.str = (uint8 *)"gcControllerState.findRunnable: blackening not enabled";
    pa.len = 54;
    runtime_throw(pa);
    BUG();
  }
  if ( !_p_->gcBgMarkWorker )
    return 0;
  if ( !runtime_gcMarkWorkAvailable(_p_) )
    return 0;
  if ( runtime___ptr_gcControllerState__findRunnableGCWorker_func1(&c->dedicatedMarkWorkersNeeded) )
  {
    v2 = _p_;
    _p_->gcMarkWorkerMode = 0;
  }
  else
  {
    BYTE4(p) = runtime___ptr_gcControllerState__findRunnableGCWorker_func1(&c->fractionalMarkWorkersNeeded);
    if ( !BYTE4(p) )
      return 0;
    runtime_nanotime();
    if ( (_DWORD)p != (_DWORD)qword_8157890 && (unsigned __int64)(p - qword_8157890) >> 32 == 0
      || (int)((unsigned __int64)(p - qword_8157890) >> 32) > 0 )
    {
      now_lo = p - qword_8157890;
      v6 = runtime_int64tofloat64(c->fractionalMarkTime);
      if ( v6 / runtime_int64tofloat64(now_lo) > c->fractionalUtilizationGoal )
      {
        runtime_internal_atomic_Xaddint64();
        return 0;
      }
    }
    v2 = _p_;
    _p_->gcMarkWorkerMode = 1;
  }
  gp = (runtime_g *)v2->gcBgMarkWorker;
  runtime_casgstatus(gp, 4u, 1u);
  if ( runtime_trace.enabled )
    runtime_traceGoUnpark(gp, 0);
  return gp;
}
// 805B0E7: variable 'p' is possibly undefined
// 8157890: using guessed type __int64 qword_8157890;

//----- (0805B1E0) --------------------------------------------------------
void __golang runtime_gcSetTriggerRatio(float64 triggerRatio)
{
  double v1; // xmm1_8
  int v2; // eax
  int v3; // ecx
  int v4; // edx
  int v5; // ebx
  int v6; // edx
  unsigned int v7; // ecx
  unsigned __int64 v8; // kr00_8
  uint64 v9; // kr08_8
  int v10; // ebx
  int v11; // esi
  uint64 v12; // kr10_8
  signed __int64 v13; // rax
  uint32 v14; // ecx
  unsigned int v15; // ebx
  unsigned int v16; // ecx
  int v17; // ebp
  double v18; // xmm2_8
  string y; // [esp+0h] [ebp-78h]
  string ya; // [esp+0h] [ebp-78h]
  string yb; // [esp+0h] [ebp-78h]
  string yc; // [esp+0h] [ebp-78h]
  string yd; // [esp+0h] [ebp-78h]
  string ye; // [esp+0h] [ebp-78h]
  string yf; // [esp+0h] [ebp-78h]
  string yg; // [esp+0h] [ebp-78h]
  uint64 y_4; // [esp+4h] [ebp-74h]
  uint64 y_8; // [esp+8h] [ebp-70h]
  uint32 v29; // [esp+Ch] [ebp-6Ch]
  uint64 v30; // [esp+10h] [ebp-68h]
  uint64 v31; // [esp+10h] [ebp-68h]
  uint32 trigger_lo; // [esp+18h] [ebp-60h]
  uint32 trigger_hi; // [esp+1Ch] [ebp-5Ch]
  uint64 minTrigger_lo; // [esp+28h] [ebp-50h]
  uint32 heapLiveBasis_lo; // [esp+30h] [ebp-48h]
  int64 heapDistance_lo; // [esp+38h] [ebp-40h]
  unsigned __int64 goal_lo; // [esp+40h] [ebp-38h]
  uint64 initialHeapLive; // [esp+48h] [ebp-30h]
  uint64 heap_live; // [esp+50h] [ebp-28h]
  uint64 heap_marked; // [esp+58h] [ebp-20h]
  uint64 v; // [esp+60h] [ebp-18h]
  uint64 v42; // [esp+68h] [ebp-10h]
  unsigned __int64 v43; // [esp+68h] [ebp-10h]
  double v44; // [esp+70h] [ebp-8h]

  if ( triggerRatio >= 0.0 )
  {
    if ( runtime_gcpercent < 0 )
    {
      v18 = triggerRatio;
    }
    else
    {
      v18 = (double)runtime_gcpercent * 0.95 / 100.0;
      if ( triggerRatio <= v18 )
        v18 = triggerRatio;
    }
    v1 = v18;
  }
  else
  {
    v1 = 0.0;
  }
  runtime_memstats.triggerRatio = v1;
  if ( runtime_gcpercent >= 0 )
  {
    *(double *)&y_8 = runtime_uint64tofloat64(runtime_memstats.heap_marked);
    runtime_float64touint64((v1 + 1.0) * *(double *)&y_8, y_8);
    v13 = __PAIR64__(HIDWORD(runtime_heapminimum), v29);
    v14 = HIDWORD(y_4);
    v15 = runtime_heapminimum;
    if ( !ptr )
    {
      trigger_hi = v29;
      trigger_lo = HIDWORD(y_4);
      minTrigger_lo = runtime_heapminimum;
      runtime_internal_atomic_Load64();
      v42 = y_4;
      v31 = runtime_uint64div((__int64)runtime_gcpercent << 20, 0x64uLL);
      v13 = v42 + v31;
      if ( (v42 + v31) >> 32 <= HIDWORD(minTrigger_lo)
        && ((int)v42 + (int)v31 <= (unsigned int)minTrigger_lo || (v42 + v31) >> 32 != HIDWORD(minTrigger_lo)) )
      {
        v13 = minTrigger_lo;
      }
      v14 = trigger_lo;
      v15 = v13;
      LODWORD(v13) = trigger_hi;
    }
    if ( (unsigned int)v13 < HIDWORD(v13) || (_DWORD)v13 == HIDWORD(v13) && v14 < v15 )
    {
      LODWORD(v13) = v15;
      v16 = HIDWORD(v13);
    }
    else
    {
      v17 = v13;
      LODWORD(v13) = v15;
      v15 = v14;
      v16 = HIDWORD(v13);
      HIDWORD(v13) = v17;
    }
    if ( v13 < 0 )
    {
      v43 = __PAIR64__(v16, v13);
      v = runtime_memstats.next_gc;
      heap_marked = runtime_memstats.heap_marked;
      heap_live = runtime_memstats.heap_live;
      initialHeapLive = runtime_work.initialHeapLive;
      runtime_printlock();
      y.str = (uint8 *)"runtime: next_gc=";
      y.len = 17;
      runtime_printstring(y);
      runtime_printuint(v);
      ya.str = (uint8 *)" heap_marked=";
      ya.len = 13;
      runtime_printstring(ya);
      runtime_printuint(heap_marked);
      yb.str = (uint8 *)" heap_live=";
      yb.len = 11;
      runtime_printstring(yb);
      runtime_printuint(heap_live);
      yc.str = (uint8 *)" initialHeapLive=";
      yc.len = 17;
      runtime_printstring(yc);
      runtime_printuint(initialHeapLive);
      yd.str = (uint8 *)"triggerRatio=";
      yd.len = 13;
      runtime_printstring(yd);
      runtime_printfloat(v1);
      ye.str = (uint8 *)" minTrigger=";
      ye.len = 12;
      runtime_printstring(ye);
      runtime_printuint(v43);
      yf.str = (uint8 *)"\n";
      yf.len = 1;
      runtime_printstring(yf);
      runtime_printunlock();
      yg.str = (uint8 *)"gc_trigger underflow";
      yg.len = 20;
      runtime_throw(yg);
      BUG();
    }
    v2 = v15;
    v3 = HIDWORD(v13);
  }
  else
  {
    v2 = -1;
    v3 = -1;
  }
  goal_lo = __PAIR64__(v3, v2);
  LODWORD(runtime_memstats.gc_trigger) = v2;
  HIDWORD(runtime_memstats.gc_trigger) = v3;
  if ( runtime_gcpercent >= 0 )
  {
    v9 = runtime_memstats.heap_marked;
    v30 = runtime_uint64div(runtime_gcpercent * runtime_memstats.heap_marked, 0x64uLL);
    v10 = HIDWORD(goal_lo);
    v11 = goal_lo;
    if ( (v9 + v30) >> 32 >= HIDWORD(goal_lo)
      && ((v9 + v30) >> 32 != HIDWORD(goal_lo) || (int)v9 + (int)v30 >= (unsigned int)goal_lo) )
    {
      v12 = v9 + v30;
      v10 = HIDWORD(v12);
      v11 = v12;
    }
    v4 = v10;
    v5 = v11;
  }
  else
  {
    v4 = -1;
    v5 = -1;
  }
  LODWORD(runtime_memstats.next_gc) = v5;
  HIDWORD(runtime_memstats.next_gc) = v4;
  if ( runtime_trace.enabled )
    runtime_traceNextGC();
  if ( runtime_gcphase )
    runtime___ptr_gcControllerState__revise(&runtime_gcController);
  if ( ptr )
  {
    qword_8149160 = 0LL;
  }
  else
  {
    runtime_internal_atomic_Load64();
    heapLiveBasis_lo = y_4;
    v8 = goal_lo - y_4 - 0x100000;
    v6 = HIDWORD(v8);
    v7 = v8;
    if ( v6 == 0 && v7 < 0x2000 || v6 < 0 )
    {
      v7 = 0x2000;
      v6 = 0;
    }
    heapDistance_lo = __PAIR64__(v6, v7);
    runtime_internal_atomic_Load64();
    if ( (((qword_8149140 - y_4) >> 32) & 0x80000000) != 0LL
      || (qword_8149140 - y_4) >> 32 == 0 && (_DWORD)qword_8149140 == (_DWORD)y_4 )
    {
      qword_8149160 = 0LL;
    }
    else
    {
      v44 = runtime_int64tofloat64(qword_8149140 - y_4);
      *(double *)&qword_8149160 = v44 / runtime_int64tofloat64(heapDistance_lo);
      dword_8149158 = heapLiveBasis_lo;
      dword_814915C = HIDWORD(y_4);
      runtime_internal_atomic_Store64();
    }
  }
}
// 805B2A9: variable 'y_4' is possibly undefined
// 805B4FB: variable 'v29' is possibly undefined
// 8149140: using guessed type __int64 qword_8149140;
// 8149158: using guessed type int dword_8149158;
// 814915C: using guessed type int dword_814915C;
// 8149160: using guessed type __int64 qword_8149160;

//----- (0805B810) --------------------------------------------------------
bool __golang runtime_gcTrigger_test(runtime_gcTrigger_0 t)
{
  __int64 v2; // [esp+4h] [ebp-8h]

  if ( !runtime_memstats.enablegc || runtime_panicking )
    return 0;
  if ( !t.kind )
    return 1;
  if ( runtime_gcphase )
    return 0;
  if ( t.kind == 1 )
    return HIDWORD(runtime_memstats.heap_live) > HIDWORD(runtime_memstats.gc_trigger)
        || HIDWORD(runtime_memstats.heap_live) == HIDWORD(runtime_memstats.gc_trigger)
        && LODWORD(runtime_memstats.heap_live) >= LODWORD(runtime_memstats.gc_trigger);
  if ( t.kind != 2 )
    return t.kind != 3 || (signed __int32)(t.n - runtime_work.cycles) > 0;
  if ( runtime_gcpercent < 0 )
  {
    return 0;
  }
  else
  {
    runtime_internal_atomic_Load64();
    return ((_DWORD)v2 != 0 || HIDWORD(v2) != 0)
        && ((int)((unsigned __int64)(t.now - v2) >> 32) > SHIDWORD(runtime_forcegcperiod)
         || LODWORD(t.now) - (int)v2 > (unsigned int)runtime_forcegcperiod
         && (unsigned __int64)(t.now - v2) >> 32 == HIDWORD(runtime_forcegcperiod));
  }
}
// 805B896: variable 'v2' is possibly undefined

//----- (0805B960) --------------------------------------------------------
void __golang runtime_gcStart(runtime_gcMode mode, runtime_gcTrigger_0 trigger)
{
  int v2; // eax
  _DWORD *v3; // ecx
  int v4; // eax
  int v5; // edx
  bool v6; // al
  runtime_gcMode v7; // eax
  int v8; // edx
  long double t; // [esp+0h] [ebp-20h]
  int64 ta; // [esp+0h] [ebp-20h]
  __int64 now_lo; // [esp+14h] [ebp-Ch]
  runtime_gcMode modea; // [esp+24h] [ebp+4h]

  v2 = *(_DWORD *)(__readgsdword(0) - 4);
  ++*(_DWORD *)(*(_DWORD *)(v2 + 24) + 120);
  v3 = *(_DWORD **)(v2 + 24);
  v4 = *(_DWORD *)(__readgsdword(0) - 4);
  if ( v4 == *v3 || (v5 = v3[30], v5 > 1) || v3[29] )
  {
    v8 = v3[30];
    v3[30] = v8 - 1;
    if ( v8 == 1 && *(_BYTE *)(v4 + 108) )
      *(_DWORD *)(v4 + 8) = -1314;
  }
  else
  {
    v3[30] = v5 - 1;
    if ( v5 == 1 && *(_BYTE *)(v4 + 108) )
      *(_DWORD *)(v4 + 8) = -1314;
    while ( runtime_gcTrigger_test(trigger) && runtime_gosweepone() != -1 )
      ++runtime_sweep.nbgsweep;
    runtime_semacquire(&runtime_work.startSema);
    if ( runtime_gcTrigger_test(trigger) )
    {
      if ( trigger.kind )
        v6 = trigger.kind == 3;
      else
        v6 = 1;
      runtime_work.userForced = v6;
      v7 = mode;
      if ( !mode )
      {
        if ( runtime_debug.gcstoptheworld == 1 )
        {
          v7 = 1;
        }
        else if ( runtime_debug.gcstoptheworld == 2 )
        {
          v7 = 2;
        }
      }
      modea = v7;
      runtime_semacquire(&runtime_worldsema);
      if ( runtime_trace.enabled )
        runtime_traceGCStart();
      if ( !modea )
        runtime_gcBgMarkStartWorkers();
      runtime_gcResetMarkState();
      runtime_work.stwprocs = runtime_gcprocs();
      runtime_work.maxprocs = runtime_gomaxprocs;
      LODWORD(t) = &runtime_memstats.heap_live;
      runtime_internal_atomic_Load64();
      runtime_work.heap0 = *(_QWORD *)((char *)&t + 4);
      runtime_work.pauseNS = 0LL;
      runtime_work.mode = modea;
      runtime_nanotime();
      LODWORD(now_lo) = &runtime_memstats.heap_live;
      HIDWORD(now_lo) = DWORD1(t);
      runtime_work.tSweepTerm = *(_QWORD *)&t;
      runtime_work.pauseStart = *(_QWORD *)&t;
      runtime_systemstack();
      LODWORD(t) = &off_80E7C0C;
      runtime_systemstack();
      runtime_clearpools();
      ++runtime_work.cycles;
      if ( modea )
      {
        runtime_nanotime();
        runtime_work.tMark = *(_QWORD *)&t;
        runtime_work.tMarkTerm = *(_QWORD *)&t;
        runtime_work.heapGoal = runtime_work.heap0;
        runtime_gcMarkTermination(runtime_memstats.triggerRatio);
      }
      else
      {
        runtime___ptr_gcControllerState__startCycle(&runtime_gcController);
        runtime_work.heapGoal = runtime_memstats.next_gc;
        runtime_setGCPhase(1u);
        runtime_work.nproc = -1;
        runtime_work.nwait = -1;
        runtime_gcMarkRootPrepare();
        runtime_gcMarkTinyAllocs();
        HIDWORD(ta) = 1;
        runtime_internal_atomic_Store();
        qword_8157890 = now_lo;
        LODWORD(ta) = off_80E7CD4;
        runtime_systemstack();
        runtime_nanotime();
        runtime_work.pauseNS += ta - runtime_work.pauseStart;
        runtime_work.tMark = ta;
      }
    }
    runtime_semrelease(&runtime_work.startSema);
  }
}
// 805BAFA: variable 't' is possibly undefined
// 80E7C0C: using guessed type int (__golang *off_80E7C0C)();
// 80E7CD4: using guessed type int (__golang *off_80E7CD4[3])();
// 8157890: using guessed type __int64 qword_8157890;

//----- (0805BD40) --------------------------------------------------------
void __golang runtime_gcMarkDone()
{
  int v0; // eax
  int64 addr; // [esp+0h] [ebp-14h]
  long double addr_4; // [esp+4h] [ebp-10h]

  while ( 1 )
  {
    runtime_semacquire(&runtime_work.markDoneSema);
    if ( runtime_gcphase != 1 || runtime_work.nproc != runtime_work.nwait || runtime_gcMarkWorkAvailable(0) )
    {
      runtime_semrelease(&runtime_work.markDoneSema);
      return;
    }
    runtime_internal_atomic_Xaddint64();
    LODWORD(addr) = &unk_81578F8;
    HIDWORD(addr) = 1;
    runtime_internal_atomic_Xaddint64();
    if ( runtime_gcBlackenPromptly )
      break;
    runtime_gcBlackenPromptly = 1;
    runtime_internal_atomic_Xadd();
    runtime_semrelease(&runtime_work.markDoneSema);
    runtime_systemstack();
    runtime_gcMarkRootCheck();
    runtime_internal_atomic_Xaddint64();
    runtime_internal_atomic_Xaddint64();
    runtime_internal_atomic_Xadd();
    if ( runtime_work.nproc || runtime_gcMarkWorkAvailable(0) )
      return;
  }
  runtime_nanotime();
  runtime_work.tMarkTerm = addr;
  runtime_work.pauseStart = addr;
  v0 = *(_DWORD *)(*(_DWORD *)(__readgsdword(0) - 4) + 24);
  *(_DWORD *)(v0 + 116) = 5;
  if ( *(_DWORD *)&runtime_writeBarrier.enabled )
    runtime_writebarrierptr((uintptr *)(v0 + 112), (uintptr)"gcing");
  else
    *(_DWORD *)(v0 + 112) = "gcing";
  runtime_systemstack();
  runtime_work.markrootDone = 1;
  LODWORD(addr_4) = 0;
  runtime_internal_atomic_Store();
  runtime_gcWakeAllAssists();
  runtime_semrelease(&runtime_work.markDoneSema);
  *(double *)((char *)&addr_4 + 4) = runtime___ptr_gcControllerState__endCycle(&runtime_gcController);
  runtime_gcMarkTermination(*(float64 *)&addr_4);
}

//----- (0805BF90) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
void __golang runtime_gcMarkTermination(float64 nextTriggerRatio)
{
  int v1; // eax
  int v2; // ecx
  runtime_g *v3; // eax
  runtime_g *v4; // eax
  runtime_m *v5; // eax
  uint64 *v6; // eax
  int pauseNS_high; // ecx
  unsigned __int64 v8; // kr20_8
  int v9; // ebx
  uint32 v10; // edx
  int v11; // ecx
  __int64 *v12; // ebx
  int32 v13; // ebp
  __int64 v14; // rdi
  int v15; // eax
  uint32 *v16; // ecx
  int v17; // eax
  int32 locks; // edx
  unsigned int x; // [esp+0h] [ebp-1B0h]
  int64 xa; // [esp+0h] [ebp-1B0h]
  __int64 xb; // [esp+0h] [ebp-1B0h]
  int64 xc; // [esp+0h] [ebp-1B0h]
  __uint8 xd; // [esp+0h] [ebp-1B0h]
  string xe; // [esp+0h] [ebp-1B0h]
  string xf; // [esp+0h] [ebp-1B0h]
  string xg; // [esp+0h] [ebp-1B0h]
  string xh; // [esp+0h] [ebp-1B0h]
  __uint8 xi; // [esp+0h] [ebp-1B0h]
  string xj; // [esp+0h] [ebp-1B0h]
  string xk; // [esp+0h] [ebp-1B0h]
  __uint8 xl; // [esp+0h] [ebp-1B0h]
  string xm; // [esp+0h] [ebp-1B0h]
  string xn; // [esp+0h] [ebp-1B0h]
  string xo; // [esp+0h] [ebp-1B0h]
  string xp; // [esp+0h] [ebp-1B0h]
  uint64 xq; // [esp+0h] [ebp-1B0h]
  string xr; // [esp+0h] [ebp-1B0h]
  string xs; // [esp+0h] [ebp-1B0h]
  string xt; // [esp+0h] [ebp-1B0h]
  string xu; // [esp+0h] [ebp-1B0h]
  string xw; // [esp+0h] [ebp-1B0h]
  string xv; // [esp+0h] [ebp-1B0h]
  string xx; // [esp+0h] [ebp-1B0h]
  int32 x_8; // [esp+8h] [ebp-1A8h]
  int x_8a; // [esp+8h] [ebp-1A8h]
  int64 v46; // [esp+Ch] [ebp-1A4h]
  uint64 v47; // [esp+10h] [ebp-1A0h]
  string v48; // [esp+10h] [ebp-1A0h]
  uint8 *v49; // [esp+10h] [ebp-1A0h]
  uint8 *v50; // [esp+10h] [ebp-1A0h]
  uint8 *v51; // [esp+10h] [ebp-1A0h]
  unsigned int v52; // [esp+14h] [ebp-19Ch]
  __uint8 v53; // [esp+14h] [ebp-19Ch] OVERLAPPED
  __uint8 v54; // [esp+14h] [ebp-19Ch] OVERLAPPED
  __uint8 b; // [esp+18h] [ebp-198h]
  uint32 totalCpu_lo; // [esp+2Ch] [ebp-184h]
  uint32 sweepTermCpu_lo; // [esp+30h] [ebp-180h]
  uint32 prev_lo; // [esp+38h] [ebp-178h]
  int32 prev_hi; // [esp+3Ch] [ebp-174h]
  uint32 ns_lo; // [esp+44h] [ebp-16Ch]
  uint32 ns_lo_0; // [esp+48h] [ebp-168h]
  int32 ns_hi; // [esp+4Ch] [ebp-164h]
  int32 ns_hi_0; // [esp+50h] [ebp-160h]
  int64 now_lo; // [esp+54h] [ebp-15Ch]
  uint32 markTermCpu_lo; // [esp+5Ch] [ebp-154h]
  __int32 i; // [esp+64h] [ebp-14Ch]
  __int32 i_0; // [esp+68h] [ebp-148h]
  unsigned int procresizetime_high; // [esp+80h] [ebp-130h] BYREF
  int totaltime_high; // [esp+84h] [ebp-12Ch]
  int y; // [esp+88h] [ebp-128h]
  unsigned int y_4; // [esp+8Ch] [ebp-124h]
  int v72; // [esp+90h] [ebp-120h]
  int v73; // [esp+94h] [ebp-11Ch]
  int v74; // [esp+98h] [ebp-118h]
  uint64 heapGoal; // [esp+9Ch] [ebp-114h]
  uint64 heap2; // [esp+A4h] [ebp-10Ch]
  unsigned int heap1; // [esp+ACh] [ebp-104h]
  int32 v; // [esp+B0h] [ebp-100h]
  uint32 v_4; // [esp+B4h] [ebp-FCh]
  uint64 heap0; // [esp+B8h] [ebp-F8h]
  int64 startTime; // [esp+C0h] [ebp-F0h] BYREF
  float64 gc_cpu_fraction; // [esp+C8h] [ebp-E8h]
  uint8 sbuf[24]; // [esp+D0h] [ebp-E0h] BYREF
  __int64 v84[3]; // [esp+E8h] [ebp-C8h] BYREF
  uint8 v85[32]; // [esp+100h] [ebp-B0h] BYREF
  uint8 v86[32]; // [esp+120h] [ebp-90h] BYREF
  uint8 buf[32]; // [esp+140h] [ebp-70h] BYREF
  int v88[2]; // [esp+160h] [ebp-50h] BYREF
  __int64 v89; // [esp+168h] [ebp-48h]
  __int64 v90; // [esp+170h] [ebp-40h]
  int v91; // [esp+178h] [ebp-38h]
  int v92; // [esp+17Ch] [ebp-34h]
  uint32 v93; // [esp+180h] [ebp-30h]
  int v94; // [esp+184h] [ebp-2Ch]
  runtime_m *mp; // [esp+188h] [ebp-28h]
  runtime_g *gp; // [esp+18Ch] [ebp-24h]
  runtime_g *_g_; // [esp+190h] [ebp-20h]
  char *v98; // [esp+194h] [ebp-1Ch]
  string s; // [esp+198h] [ebp-18h]
  void (__golang *v100)(); // [esp+1A0h] [ebp-10h]
  int64 *v101; // [esp+1A4h] [ebp-Ch]
  void (__golang *v102)(); // [esp+1A8h] [ebp-8h]
  int64 *p_startTime; // [esp+1ACh] [ebp-4h]

  while ( (unsigned int)&procresizetime_high <= *(_DWORD *)(*(_DWORD *)(__readgsdword(0) - 4) + 8) )
    runtime_morestack_noctxt();
  runtime_internal_atomic_Store();
  runtime_gcBlackenPromptly = 0;
  runtime_setGCPhase(2u);
  runtime_work.heap1 = runtime_memstats.heap_live;
  runtime_nanotime();
  startTime = x;
  v1 = *(_DWORD *)(__readgsdword(0) - 4);
  ++*(_DWORD *)(*(_DWORD *)(v1 + 24) + 120);
  v2 = *(_DWORD *)(v1 + 24);
  mp = (runtime_m *)v2;
  *(_DWORD *)(v2 + 116) = 5;
  s.len = v2 + 112;
  if ( *(_DWORD *)&runtime_writeBarrier.enabled )
    runtime_writebarrierptr((uintptr *)(v2 + 112), (uintptr)"gcing");
  else
    *(_DWORD *)(v2 + 112) = "gcing";
  v3 = *(runtime_g **)(__readgsdword(0) - 4);
  _g_ = v3;
  v3->m->traceback = 2;
  gp = v3->m->curg;
  runtime_casgstatus(gp, 2u, 4u);
  v4 = gp;
  gp->waitreason.len = 18;
  if ( *(_DWORD *)&runtime_writeBarrier.enabled )
    runtime_writebarrierptr((uintptr *)&v4->waitreason, (uintptr)"garbage collection");
  else
    v4->waitreason.str = (uint8 *)"garbage collection";
  v102 = runtime_gcMarkTermination_func1;
  p_startTime = &startTime;
  runtime_systemstack();
  v100 = runtime_gcMarkTermination_func2;
  v101 = &startTime;
  runtime_systemstack();
  _g_->m->traceback = 0;
  runtime_casgstatus(gp, 4u, 2u);
  if ( runtime_trace.enabled )
    runtime_traceGCDone();
  v5 = mp;
  mp->preemptoff.len = 0;
  if ( *(_DWORD *)&runtime_writeBarrier.enabled )
    runtime_writebarrierptr((uintptr *)s.len, 0);
  else
    v5->preemptoff.str = 0;
  if ( runtime_gcphase )
  {
    xx.str = (uint8 *)"gc done but gcphase != _GCoff";
    xx.len = 29;
    runtime_throw(xx);
    BUG();
  }
  runtime_gcSetTriggerRatio(nextTriggerRatio);
  runtime_nanotime();
  now_lo = xa;
  time_now(xa, x_8, v46);
  heap0 = 1000000000LL * (unsigned int)xb;
  v_4 = now_lo - LODWORD(runtime_work.pauseStart);
  runtime_work.pauseNS += now_lo - runtime_work.pauseStart;
  runtime_work.tEnd = now_lo;
  runtime_internal_atomic_Store64();
  runtime_internal_atomic_Store64();
  v6 = &runtime_memstats.pause_ns[LOBYTE(runtime_memstats.numgc)];
  pauseNS_high = HIDWORD(runtime_work.pauseNS);
  *(_DWORD *)v6 = runtime_work.pauseNS;
  *((_DWORD *)v6 + 1) = pauseNS_high;
  runtime_memstats.pause_end[LOBYTE(runtime_memstats.numgc)] = x_8a + 1000000000 * xb;
  runtime_memstats.pause_total_ns += runtime_work.pauseNS;
  sweepTermCpu_lo = runtime_work.stwprocs * (LODWORD(runtime_work.tMark) - LODWORD(runtime_work.tSweepTerm));
  heapGoal = __PAIR64__(runtime_sched.totaltime, runtime_work.tMarkTerm);
  v74 = LODWORD(runtime_work.tEnd) - LODWORD(runtime_work.tMarkTerm);
  v73 = ((unsigned int)runtime_work.stwprocs
       * (unsigned __int64)(unsigned int)(LODWORD(runtime_work.tEnd) - LODWORD(runtime_work.tMarkTerm))) >> 32;
  markTermCpu_lo = runtime_work.stwprocs * (LODWORD(runtime_work.tEnd) - LODWORD(runtime_work.tMarkTerm));
  v72 = sweepTermCpu_lo + qword_8157870 + qword_8157878 + qword_8157880;
  y_4 = runtime_work.totaltime;
  LODWORD(runtime_work.totaltime) += markTermCpu_lo + v72;
  y = runtime_work.totaltime;
  HIDWORD(heap0) = (unsigned __int64)(runtime_work.stwprocs * (runtime_work.tMark - runtime_work.tSweepTerm)) >> 32;
  LODWORD(heap0) = (unsigned __int64)(runtime_work.stwprocs * (runtime_work.tEnd - runtime_work.tMarkTerm)) >> 32;
  v8 = runtime_work.stwprocs * (runtime_work.tEnd - runtime_work.tMarkTerm)
     + runtime_work.stwprocs * (runtime_work.tMark - runtime_work.tSweepTerm)
     + qword_8157870
     + qword_8157878
     + qword_8157880
     + __PAIR64__(HIDWORD(runtime_work.totaltime), y_4);
  HIDWORD(runtime_work.totaltime) = HIDWORD(v8);
  v9 = v8;
  v_4 = runtime_sched.procresizetime;
  heap1 = now_lo - LODWORD(runtime_sched.procresizetime);
  v = runtime_gomaxprocs;
  heap2 = (unsigned int)runtime_gomaxprocs
        * (unsigned __int64)(unsigned int)(now_lo - LODWORD(runtime_sched.procresizetime));
  totalCpu_lo = LODWORD(runtime_sched.totaltime) + heap2;
  totaltime_high = HIDWORD(runtime_sched.totaltime);
  procresizetime_high = HIDWORD(runtime_sched.procresizetime);
  gc_cpu_fraction = runtime_int64tofloat64(__SPAIR64__(HIDWORD(v8), runtime_work.totaltime));
  LODWORD(xc) = totalCpu_lo;
  HIDWORD(xc) = HIDWORD(heap2)
              + heap1 * (v >> 31)
              + v * ((now_lo - __PAIR64__(procresizetime_high, v_4)) >> 32)
              + __CFADD__(HIDWORD(heapGoal), (_DWORD)heap2)
              + totaltime_high;
  runtime_memstats.gc_cpu_fraction = gc_cpu_fraction / runtime_int64tofloat64(xc);
  runtime_sweep.nbgsweep = 0;
  runtime_sweep.npausesweep = 0;
  if ( runtime_work.userForced )
    ++runtime_memstats.numforcedgc;
  runtime_lock(&runtime_work.sweepWaiters.lock);
  ++runtime_memstats.numgc;
  runtime_injectglist((runtime_g *)runtime_work.sweepWaiters.head);
  runtime_work.sweepWaiters.head = 0;
  runtime_unlock(&runtime_work.sweepWaiters.lock);
  runtime_mProf_NextCycle();
  runtime_systemstack();
  runtime_mProf_Flush();
  runtime_prepareFreeWorkbufs();
  runtime_systemstack();
  if ( runtime_debug.gctrace > 0 )
  {
    gc_cpu_fraction = runtime_memstats.gc_cpu_fraction;
    ((void (__golang *)(int (__golang **)()))loc_808FD8A)(&off_80E7BF4);
    runtime_printlock();
    v47 = runtime_uint64div(runtime_work.tSweepTerm - runtime_runtimeInitTime, 0xF4240uLL);
    xd.array = sbuf;
    *(_QWORD *)&xd.len = 0x1800000018LL;
    b = runtime_itoaDiv(xd, v47, 3);
    v_4 = runtime_memstats.numgc;
    runtime_slicebytetostring((uint8 (*)[32])buf, b, v48);
    s.str = v49;
    runtime_printlock();
    xe.str = (uint8 *)"gc ";
    xe.len = 3;
    runtime_printstring(xe);
    runtime_printint(v_4);
    xf.str = (uint8 *)" @";
    xf.len = 2;
    runtime_printstring(xf);
    runtime_printstring((string)__PAIR64__(v52, (unsigned int)s.str));
    xg.str = (uint8 *)"s ";
    xg.len = 2;
    runtime_printstring(xg);
    runtime_printint((int)(gc_cpu_fraction * 100.0));
    xh.str = (uint8 *)"%: ";
    xh.len = 3;
    runtime_printstring(xh);
    runtime_printunlock();
    prev_hi = HIDWORD(runtime_work.tSweepTerm);
    ((void (*)(void))loc_808FD8A)();
    v84[0] = runtime_work.tMark;
    v84[1] = runtime_work.tMarkTerm;
    v84[2] = runtime_work.tEnd;
    v11 = 0;
    v12 = v84;
    v13 = prev_hi;
    while ( v11 < 3 )
    {
      i_0 = v11;
      v98 = (char *)v12;
      v14 = *v12;
      ns_hi = *((_DWORD *)v12 + 1);
      ns_lo = *(_DWORD *)v12;
      if ( v11 )
      {
        prev_lo = v10;
        runtime_printlock();
        xj.str = (uint8 *)"+";
        xj.len = 1;
        runtime_printstring(xj);
        runtime_printunlock();
        v10 = prev_lo;
        LODWORD(v14) = ns_lo;
      }
      xi.array = sbuf;
      *(_QWORD *)&xi.len = 0x1800000018LL;
      v53 = runtime_fmtNSAsMS(xi, v14 - __PAIR64__(v13, v10));
      runtime_slicebytetostring((uint8 (*)[32])v86, v53, *(string *)((char *)&v53 - 4));
      s.str = v50;
      runtime_printlock();
      runtime_printstring((string)__PAIR64__((unsigned int)v53.array, (unsigned int)s.str));
      runtime_printunlock();
      v12 = (__int64 *)(v98 + 8);
      v11 = i_0 + 1;
      v13 = ns_hi;
      v10 = ns_lo;
    }
    runtime_printlock();
    xk.str = (uint8 *)" ms clock, ";
    xk.len = 11;
    runtime_printstring(xk);
    runtime_printunlock();
    ((void (*)(void))loc_808FD86)();
    v88[0] = sweepTermCpu_lo;
    v88[1] = HIDWORD(heap0);
    v89 = qword_8157870;
    v90 = qword_8157878 + qword_8157880;
    v91 = dword_8157888;
    v92 = dword_815788C;
    v93 = markTermCpu_lo;
    v94 = heap0;
    v15 = 0;
    v16 = (uint32 *)v88;
    while ( v15 < 5 )
    {
      i = v15;
      v98 = (char *)v16;
      ns_hi_0 = v16[1];
      ns_lo_0 = *v16;
      if ( v15 == 2 || v15 == 3 )
      {
        runtime_printlock();
        xm.str = (uint8 *)"/";
        xm.len = 1;
        runtime_printstring(xm);
        runtime_printunlock();
      }
      else if ( v15 )
      {
        runtime_printlock();
        xn.str = (uint8 *)"+";
        xn.len = 1;
        runtime_printstring(xn);
        runtime_printunlock();
      }
      xl.array = sbuf;
      *(_QWORD *)&xl.len = 0x1800000018LL;
      v54 = runtime_fmtNSAsMS(xl, __PAIR64__(ns_hi_0, ns_lo_0));
      runtime_slicebytetostring((uint8 (*)[32])v85, v54, *(string *)((char *)&v54 - 4));
      s.str = v51;
      runtime_printlock();
      runtime_printstring((string)__PAIR64__((unsigned int)v54.array, (unsigned int)s.str));
      runtime_printunlock();
      v16 = (uint32 *)(v98 + 8);
      v15 = i + 1;
    }
    heap0 = runtime_work.heap0;
    v_4 = HIDWORD(runtime_work.heap1);
    heap1 = runtime_work.heap1;
    heap2 = runtime_work.heap2;
    heapGoal = runtime_work.heapGoal;
    v = runtime_work.maxprocs;
    runtime_printlock();
    xo.str = (uint8 *)" ms cpu, ";
    xo.len = 9;
    runtime_printstring(xo);
    runtime_printuint(heap0 >> 20);
    xp.str = (uint8 *)"->";
    xp.len = 2;
    runtime_printstring(xp);
    LODWORD(xq) = (heap1 >> 20) | (v_4 << 12);
    HIDWORD(xq) = v_4 >> 20;
    runtime_printuint(xq);
    xr.str = (uint8 *)"->";
    xr.len = 2;
    runtime_printstring(xr);
    runtime_printuint(heap2 >> 20);
    xs.str = (uint8 *)" MB, ";
    xs.len = 5;
    runtime_printstring(xs);
    runtime_printuint(heapGoal >> 20);
    xt.str = (uint8 *)" MB goal, ";
    xt.len = 10;
    runtime_printstring(xt);
    runtime_printint(v);
    xu.str = (uint8 *)" P";
    xu.len = 2;
    runtime_printstring(xu);
    runtime_printunlock();
    if ( runtime_work.userForced )
    {
      runtime_printlock();
      xv.str = (uint8 *)" (forced)";
      xv.len = 9;
      runtime_printstring(xv);
      runtime_printunlock();
    }
    runtime_printlock();
    xw.str = (uint8 *)"\n";
    xw.len = 1;
    runtime_printstring(xw);
    runtime_printunlock();
    runtime_printunlock();
  }
  runtime_semrelease(&runtime_worldsema);
  v17 = *(_DWORD *)(__readgsdword(0) - 4);
  locks = mp->locks;
  mp->locks = locks - 1;
  if ( locks == 1 && *(_BYTE *)(v17 + 108) )
    *(_DWORD *)(v17 + 8) = -1314;
}
// 805C8CE: failed to expand linear variable ^14.12
// 805CAA1: failed to expand linear variable ^14.12
// 80E0D88: using guessed type char asc_80E0D88;
// 80E0D8C: using guessed type char asc_80E0D8C;
// 80E7BF4: using guessed type int (__golang *off_80E7BF4)();
// 8157870: using guessed type __int64 qword_8157870;
// 8157878: using guessed type __int64 qword_8157878;
// 8157880: using guessed type __int64 qword_8157880;
// 8157888: using guessed type int dword_8157888;
// 815788C: using guessed type int dword_815788C;

//----- (0805CE70) --------------------------------------------------------
void __golang runtime_gcBgMarkStartWorkers()
{
  int v0; // eax
  runtime_p **i; // ecx
  runtime_p *v2; // edx
  int v3; // [esp+10h] [ebp-8h]
  runtime_p **v4; // [esp+14h] [ebp-4h]

  v0 = 0;
  for ( i = runtime_allp; v0 < 1025; ++i )
  {
    v2 = *i;
    if ( !*i || v2->status == 4 )
      break;
    if ( !v2->gcBgMarkWorker )
    {
      v3 = v0;
      v4 = i;
      runtime_newproc(4, (runtime_funcval *)&stru_80E7BFC);
      runtime_notetsleepg(&runtime_work.bgMarkReady, -1LL);
      runtime_work.bgMarkReady.key = 0;
      v0 = v3;
      i = v4;
    }
    ++v0;
  }
}

//----- (0805CF20) --------------------------------------------------------
void __golang runtime_gcBgMarkWorker(runtime_p *_p_)
{
  runtime_m *m; // ecx
  runtime_m *v2; // ecx
  runtime_parkInfo_2 *v3; // edx
  int v4; // eax
  int v5; // ecx
  runtime_gcMarkWorkerMode gcMarkWorkerMode; // ebx
  int v7; // ebp
  int v8; // esi
  int v9; // eax
  __int64 typ; // [esp+0h] [ebp-48h]
  string typa; // [esp+0h] [ebp-48h]
  string typb; // [esp+0h] [ebp-48h]
  string typc; // [esp+0h] [ebp-48h]
  string typd; // [esp+0h] [ebp-48h]
  string type; // [esp+0h] [ebp-48h]
  string typf; // [esp+0h] [ebp-48h]
  string typg; // [esp+0h] [ebp-48h]
  string typh; // [esp+0h] [ebp-48h]
  runtime_parkInfo_2 *typ_4; // [esp+4h] [ebp-44h]
  string reasona; // [esp+8h] [ebp-40h]
  uint32 reason; // [esp+8h] [ebp-40h]
  __int64 startTime_lo; // [esp+18h] [ebp-30h]
  runtime_gcMarkWorkerMode v; // [esp+28h] [ebp-20h]
  uint32 v_4; // [esp+2Ch] [ebp-1Ch]
  uint32 v_4a; // [esp+2Ch] [ebp-1Ch]
  runtime_parkInfo_2 *park; // [esp+30h] [ebp-18h]
  runtime_g *gp; // [esp+34h] [ebp-14h]
  int v29[3]; // [esp+3Ch] [ebp-Ch] BYREF

  gp = *(runtime_g **)(__readgsdword(0) - 4);
  m = gp->m;
  m->preemptoff.len = 14;
  if ( *(_DWORD *)&runtime_writeBarrier.enabled )
    runtime_writebarrierptr((uintptr *)&m->preemptoff, (uintptr)"GC worker init");
  else
    m->preemptoff.str = (uint8 *)"GC worker init";
  typ_4 = (runtime_parkInfo_2 *)runtime_newobject((runtime__type_0 *)&stru_80D3CE0);
  v2 = gp->m;
  v3 = typ_4;
  park = typ_4;
  v2->preemptoff.len = 0;
  if ( *(_DWORD *)&runtime_writeBarrier.enabled )
  {
    runtime_writebarrierptr((uintptr *)&v2->preemptoff, 0);
    v3 = park;
  }
  else
  {
    v2->preemptoff.str = 0;
  }
  v4 = *(_DWORD *)(__readgsdword(0) - 4);
  ++*(_DWORD *)(*(_DWORD *)(v4 + 24) + 120);
  v3->m = *(_DWORD *)(v4 + 24);
  v3->attach = (runtime_puintptr)_p_;
  runtime_notewakeup(&runtime_work.bgMarkReady);
  while ( 1 )
  {
    reasona.str = (uint8 *)"GC worker (idle)";
    reasona.len = 16;
    runtime_gopark(unlockf, park, reasona, 0x14u, 0);
    if ( (runtime_g *)_p_->gcBgMarkWorker != gp )
      break;
    v5 = *(_DWORD *)(__readgsdword(0) - 4);
    ++*(_DWORD *)(*(_DWORD *)(v5 + 24) + 120);
    park->m = *(_DWORD *)(v5 + 24);
    if ( !runtime_gcBlackenEnabled )
    {
      typh.str = (uint8 *)"gcBgMarkWorker: blackening not enabled";
      typh.len = 38;
      runtime_throw(typh);
      BUG();
    }
    runtime_nanotime();
    startTime_lo = typ;
    HIDWORD(typ) = -1;
    runtime_internal_atomic_Xadd();
    if ( reason == runtime_work.nproc )
    {
      v_4a = runtime_work.nproc;
      runtime_printlock();
      type.str = (uint8 *)"runtime: work.nwait=";
      type.len = 20;
      runtime_printstring(type);
      runtime_printsp();
      runtime_printint(reason);
      runtime_printsp();
      typf.str = (uint8 *)"work.nproc=";
      typf.len = 11;
      runtime_printstring(typf);
      runtime_printsp();
      runtime_printint(v_4a);
      runtime_printnl();
      runtime_printunlock();
      typg.str = (uint8 *)"work.nwait was > work.nproc";
      typg.len = 27;
      runtime_throw(typg);
      BUG();
    }
    v29[0] = (int)runtime_gcBgMarkWorker_func2;
    v29[1] = (int)gp;
    v29[2] = (int)_p_;
    LODWORD(typ) = v29;
    runtime_systemstack();
    if ( runtime_gcBlackenPromptly )
      runtime___ptr_gcWork__dispose(&_p_->gcw);
    runtime_nanotime();
    gcMarkWorkerMode = _p_->gcMarkWorkerMode;
    if ( !gcMarkWorkerMode || gcMarkWorkerMode == 1 )
    {
      runtime_internal_atomic_Xaddint64();
      reason = 0;
      runtime_internal_atomic_Xaddint64();
    }
    else if ( gcMarkWorkerMode == 2 )
    {
      reason = (unsigned __int64)(typ - startTime_lo) >> 32;
      runtime_internal_atomic_Xaddint64();
    }
    runtime_internal_atomic_Xadd();
    if ( reason > runtime_work.nproc )
    {
      v_4 = runtime_work.nproc;
      v = _p_->gcMarkWorkerMode;
      runtime_printlock();
      typa.str = (uint8 *)"runtime: p.gcMarkWorkerMode=";
      typa.len = 28;
      runtime_printstring(typa);
      runtime_printsp();
      runtime_printint(v);
      runtime_printsp();
      typb.str = (uint8 *)"work.nwait=";
      typb.len = 11;
      runtime_printstring(typb);
      runtime_printsp();
      runtime_printint(reason);
      runtime_printsp();
      typc.str = (uint8 *)"work.nproc=";
      typc.len = 11;
      runtime_printstring(typc);
      runtime_printsp();
      runtime_printint(v_4);
      runtime_printnl();
      runtime_printunlock();
      typd.str = (uint8 *)"work.nwait > work.nproc";
      typd.len = 23;
      runtime_throw(typd);
      BUG();
    }
    if ( reason == runtime_work.nproc && !runtime_gcMarkWorkAvailable(0) )
    {
      _p_->gcBgMarkWorker = 0;
      v7 = *(_DWORD *)(__readgsdword(0) - 4);
      v8 = *(_DWORD *)(park->m + 120);
      *(_DWORD *)(park->m + 120) = v8 - 1;
      if ( v8 == 1 )
      {
        if ( *(_BYTE *)(v7 + 108) )
          *(_DWORD *)(v7 + 8) = -1314;
      }
      runtime_gcMarkDone();
      v9 = *(_DWORD *)(__readgsdword(0) - 4);
      ++*(_DWORD *)(*(_DWORD *)(v9 + 24) + 120);
      park->m = *(_DWORD *)(v9 + 24);
      park->attach = (runtime_puintptr)_p_;
    }
  }
}
// 805CF20: could not find valid save-restore pair for ebx
// 805D078: variable 'typ' is possibly undefined
// 805D09E: variable 'reason' is possibly undefined

//----- (0805D440) --------------------------------------------------------
bool __golang runtime_gcMarkWorkAvailable(runtime_p *p)
{
  runtime_workbuf *wbuf1; // ecx
  bool v2; // al

  if ( p )
  {
    wbuf1 = p->gcw.wbuf1;
    if ( wbuf1 )
      v2 = !wbuf1->workbufhdr.nobj && p->gcw.wbuf2->workbufhdr.nobj == 0;
    else
      v2 = 1;
    if ( !v2 )
      return 1;
  }
  if ( runtime___ptr_lfstack__empty(&runtime_work.full) )
    return runtime_work.markrootNext < runtime_work.markrootJobs;
  return 1;
}

//----- (0805D4F0) --------------------------------------------------------
void __golang runtime_gcMark(int64 start_time)
{
  runtime_gcWork_0 *v1; // eax
  int32 i; // eax
  runtime_p *v3; // edx
  runtime_workbuf *wbuf1; // ebx
  bool v5; // bl
  string w; // [esp+0h] [ebp-Ch]
  string wa; // [esp+0h] [ebp-Ch]
  string wb; // [esp+0h] [ebp-Ch]
  string wc; // [esp+0h] [ebp-Ch]
  runtime_gcWork_0 *gcw; // [esp+8h] [ebp-4h]

  if ( runtime_debug.allocfreetrace > 0 )
    runtime_tracegc();
  if ( runtime_gcphase != 2 )
  {
    wc.str = (uint8 *)"in gcMark expecting to see gcphase as _GCmarkterminatio";
    wc.len = 56;
    runtime_throw(wc);
    BUG();
  }
  runtime_work.tstart = start_time;
  runtime_gcMarkRootPrepare();
  runtime_work.nwait = 0;
  runtime_work.ndone = 0;
  runtime_work.nproc = runtime_gcprocs();
  runtime_work.helperDrainBlock = LODWORD(runtime_work.full) != 0
                               || HIDWORD(runtime_work.full) != 0
                               || runtime_work.nStackRoots
                                + runtime_work.nSpanRoots
                                + runtime_work.nBSSRoots
                                + runtime_work.nDataRoots;
  if ( runtime_trace.enabled )
    runtime_traceGCScanStart();
  if ( runtime_work.nproc > 1 )
  {
    runtime_work.alldone.key = 0;
    runtime_helpgc(runtime_work.nproc);
  }
  runtime_gchelperstart();
  v1 = (runtime_gcWork_0 *)(*(_DWORD *)(*(_DWORD *)(*(_DWORD *)(__readgsdword(0) - 4) + 24) + 92) + 2384);
  gcw = v1;
  if ( runtime_work.helperDrainBlock )
    runtime_gcDrain(v1, 0);
  else
    runtime_gcDrain(v1, 2);
  runtime___ptr_gcWork__dispose(gcw);
  if ( runtime_debug.gccheckmark > 0 )
    runtime_gcMarkRootCheck();
  if ( LODWORD(runtime_work.full) != 0 || HIDWORD(runtime_work.full) != 0 )
  {
    wb.str = (uint8 *)"work.full != 0";
    wb.len = 14;
    runtime_throw(wb);
    BUG();
  }
  if ( runtime_work.nproc > 1 )
    runtime_notesleep(&runtime_work.alldone);
  runtime_work.markrootDone = 1;
  for ( i = 0; i < runtime_gomaxprocs; ++i )
  {
    if ( (unsigned int)i >= 0x401 )
      runtime_panicindex();
    v3 = runtime_allp[i];
    wbuf1 = v3->gcw.wbuf1;
    if ( wbuf1 )
    {
      if ( wbuf1->workbufhdr.nobj )
        v5 = 0;
      else
        v5 = v3->gcw.wbuf2->workbufhdr.nobj == 0;
    }
    else
    {
      v5 = 1;
    }
    if ( !v5 )
    {
      wa.str = (uint8 *)"P has cached GC work at end of mark termination";
      wa.len = 47;
      runtime_throw(wa);
      BUG();
    }
    if ( HIDWORD(v3->gcw.scanWork) != 0
      || LODWORD(v3->gcw.scanWork) != 0
      || HIDWORD(v3->gcw.bytesMarked) != 0
      || LODWORD(v3->gcw.bytesMarked) != 0 )
    {
      w.str = (uint8 *)"P has unflushed stats at end of mark termination";
      w.len = 48;
      runtime_throw(w);
      BUG();
    }
  }
  if ( runtime_trace.enabled )
    runtime_traceGCScanDone();
  runtime_cachestats();
  runtime_memstats.heap_marked = runtime_work.bytesMarked;
  runtime_memstats.heap_live = runtime_work.bytesMarked;
  runtime_memstats.heap_scan = runtime_gcController.scanWork;
  if ( runtime_trace.enabled )
    runtime_traceHeapAlloc();
}

//----- (0805D870) --------------------------------------------------------
void __golang runtime_gcSweep(runtime_gcMode mode)
{
  string l; // [esp+0h] [ebp-Ch]
  string la; // [esp+0h] [ebp-Ch]

  if ( runtime_gcphase )
  {
    la.str = (uint8 *)"gcSweep being done but phase is not GCoff";
    la.len = 41;
    runtime_throw(la);
    BUG();
  }
  runtime_lock(&runtime_mheap_.lock);
  dword_81490F0 += 2;
  ptr = 0;
  if ( dword_8149114[5 * (((unsigned int)dword_81490F0 >> 1) & 1) + 4] )
  {
    l.str = (uint8 *)"non-empty swept list";
    l.len = 20;
    runtime_throw(l);
    BUG();
  }
  qword_8149148 = 0LL;
  runtime_unlock(&runtime_mheap_.lock);
  if ( mode == 2 )
  {
    runtime_lock(&runtime_mheap_.lock);
    qword_8149160 = 0LL;
    runtime_unlock(&runtime_mheap_.lock);
    while ( runtime_sweepone() != -1 )
      ++runtime_sweep.npausesweep;
    runtime_prepareFreeWorkbufs();
    while ( runtime_freeSomeWbufs(0) )
      ;
    runtime_mProf_NextCycle();
    runtime_mProf_Flush();
  }
  else
  {
    runtime_lock(&runtime_sweep.lock);
    if ( runtime_sweep.parked )
    {
      runtime_sweep.parked = 0;
      runtime_ready(runtime_sweep.g, 0, 1);
    }
    runtime_unlock(&runtime_sweep.lock);
  }
}
// 81490F0: using guessed type int dword_81490F0;
// 8149114: using guessed type _DWORD dword_8149114[11];
// 8149160: using guessed type __int64 qword_8149160;

//----- (0805DA00) --------------------------------------------------------
void __golang runtime_gcResetMarkState()
{
  runtime_g **array; // eax
  __int32 len; // ecx
  __int32 i; // edx
  runtime_g *v3; // ebx
  uint64 v4; // [esp+4h] [ebp-8h]

  runtime_lock(&runtime_allglock);
  array = runtime_allgs.array;
  len = runtime_allgs.len;
  for ( i = 0; i < len; ++i )
  {
    v3 = *array;
    *(_WORD *)&v3->gcscandone = 0;
    LODWORD(v3->gcAssistBytes) = 0;
    HIDWORD(v3->gcAssistBytes) = 0;
    ++array;
  }
  runtime_unlock(&runtime_allglock);
  runtime_work.bytesMarked = 0LL;
  runtime_internal_atomic_Load64();
  runtime_work.initialHeapLive = v4;
  runtime_work.markrootDone = 0;
}
// 805DA93: variable 'v4' is possibly undefined

//----- (0805DAC0) --------------------------------------------------------
void __golang sync_runtime_registerPoolCleanup(func() f)
{
  if ( *(_DWORD *)&runtime_writeBarrier.enabled )
    runtime_writebarrierptr((uintptr *)&runtime_poolcleanup, (uintptr)f);
  else
    runtime_poolcleanup = f;
}

//----- (0805DB10) --------------------------------------------------------
void __golang runtime_clearpools()
{
  runtime_sudog *j; // eax
  runtime_sudog *next; // ecx
  int k; // eax
  runtime__defer *v3; // edx
  runtime__defer *link; // ebp
  uintptr *v5; // ebx
  __int32 i; // [esp+8h] [ebp-10h]
  runtime_sudog *sgnext; // [esp+Ch] [ebp-Ch]
  runtime__defer *dlink; // [esp+10h] [ebp-8h]
  uintptr *v9; // [esp+14h] [ebp-4h]

  if ( runtime_poolcleanup )
    (*(void (**)(void))runtime_poolcleanup)();
  runtime_lock(&runtime_sched.sudoglock);
  for ( j = runtime_sched.sudogcache; j; j = next )
  {
    next = j->next;
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
    {
      sgnext = j->next;
      runtime_writebarrierptr((uintptr *)&j->next, 0);
      next = sgnext;
    }
    else
    {
      j->next = 0;
    }
  }
  if ( *(_DWORD *)&runtime_writeBarrier.enabled )
    runtime_writebarrierptr((uintptr *)&runtime_sched.sudogcache, 0);
  else
    runtime_sched.sudogcache = 0;
  runtime_unlock(&runtime_sched.sudoglock);
  runtime_lock(&runtime_sched.deferlock);
  for ( k = 0; k < 5; ++k )
  {
    if ( (unsigned int)k >= 5 )
      runtime_panicindex();
    i = k;
    v3 = runtime_sched.deferpool[k];
    v5 = (uintptr *)&runtime_sched.deferpool[k];
    v9 = v5;
    while ( v3 )
    {
      link = v3->link;
      if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      {
        dlink = v3->link;
        runtime_writebarrierptr((uintptr *)&v3->link, 0);
        k = i;
        v5 = v9;
        link = dlink;
      }
      else
      {
        v3->link = 0;
      }
      v3 = link;
    }
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
    {
      runtime_writebarrierptr(v5, 0);
      k = i;
    }
    else
    {
      runtime_sched.deferpool[k] = 0;
    }
  }
  runtime_unlock(&runtime_sched.deferlock);
}

//----- (0805DCA0) --------------------------------------------------------
void __golang runtime_gchelper()
{
  runtime_gcWork_0 *v0; // ecx
  int v1; // [esp+8h] [ebp-10h]
  uint32 nproc; // [esp+Ch] [ebp-Ch]
  runtime_gcWork_0 *gcw; // [esp+10h] [ebp-8h]
  runtime_g *_g_; // [esp+14h] [ebp-4h]

  _g_ = *(runtime_g **)(__readgsdword(0) - 4);
  _g_->m->traceback = 2;
  runtime_gchelperstart();
  if ( runtime_trace.enabled )
    runtime_traceGCScanStart();
  if ( runtime_gcphase == 2 )
  {
    v0 = (runtime_gcWork_0 *)(_g_->m->p + 2384);
    gcw = v0;
    if ( runtime_work.helperDrainBlock )
      runtime_gcDrain(v0, 0);
    else
      runtime_gcDrain(v0, 2);
    runtime___ptr_gcWork__dispose(gcw);
  }
  if ( runtime_trace.enabled )
    runtime_traceGCScanDone();
  nproc = runtime_internal_atomic_Load(&runtime_work.nproc);
  runtime_internal_atomic_Xadd();
  if ( nproc - 1 == v1 )
    runtime_notewakeup(&runtime_work.alldone);
  _g_->m->traceback = 0;
}
// 805DD7A: variable 'v1' is possibly undefined

//----- (0805DDD0) --------------------------------------------------------
void __golang runtime_gchelperstart()
{
  int v0; // eax
  _DWORD *v1; // ecx
  string s; // [esp+0h] [ebp-8h]
  string sa; // [esp+0h] [ebp-8h]

  v0 = *(_DWORD *)(__readgsdword(0) - 4);
  v1 = *(_DWORD **)(v0 + 24);
  if ( v1[34] >= 0x20u )
  {
    sa.str = (uint8 *)"gchelperstart: bad m->helpgc";
    sa.len = 28;
    runtime_throw(sa);
    BUG();
  }
  if ( v0 != *v1 )
  {
    s.str = (uint8 *)"gchelper not running on g0 stack";
    s.len = 32;
    runtime_throw(s);
    BUG();
  }
}

//----- (0805DE50) --------------------------------------------------------
__uint8 __golang runtime_itoaDiv(__uint8 buf, uint64 val, __int32 dec)
{
  int v3; // edi
  int v4; // esi
  unsigned __int32 len; // eax
  __int32 v6; // ebx
  __int32 v7; // ecx
  unsigned int v8; // edx
  unsigned int v9; // ebp
  int v10; // ebx
  __int32 v11; // et0
  int v12; // et1
  int v13; // ebx
  unsigned __int32 v14; // ebx
  int v15; // et1
  uint8 v16; // al
  unsigned __int32 v17; // eax
  uint8 v18; // bp
  uint64 v19; // [esp+10h] [ebp-10h]
  __int32 ia; // [esp+1Ch] [ebp-4h]
  unsigned __int32 i; // [esp+1Ch] [ebp-4h]
  unsigned __int64 vala; // [esp+30h] [ebp+10h]
  __uint8 _r3; // [esp+3Ch] [ebp+1Ch]

  len = buf.len;
  v6 = buf.len - 1;
  v7 = buf.len - 1 - dec;
  v8 = HIDWORD(val);
  v9 = val;
  while ( 1 )
  {
    i = v6;
    v11 = v6;
    v10 = v4;
    LOBYTE(v10) = v8 == 0;
    v12 = v10;
    v13 = v3;
    LOBYTE(v13) = v9 >= 0xA;
    v4 = v13 & v12;
    LOBYTE(v13) = v8 != 0;
    v15 = v13;
    v14 = v11;
    v3 = v4 | v15;
    if ( !((unsigned __int8)v4 | (unsigned __int8)v15) && (int)v14 < v7 )
      break;
    vala = __PAIR64__(v8, v9);
    v16 = runtime_uint64mod(__PAIR64__(v8, v9), 0xAuLL) + 48;
    if ( i >= buf.len )
      runtime_panicindex();
    buf.array[i] = v16;
    v17 = i - 1;
    if ( i - 1 == buf.len - 1 - dec )
    {
      if ( v17 >= buf.len )
        runtime_panicindex();
      buf.array[i - 1] = 46;
      v17 = i - 2;
    }
    ia = v17;
    v19 = runtime_uint64div(vala, 0xAuLL);
    v8 = HIDWORD(v19);
    v9 = v19;
    len = buf.len;
    v7 = buf.len - 1 - dec;
    v6 = ia;
  }
  v18 = v9 + 48;
  if ( v14 >= len )
    runtime_panicindex();
  buf.array[v14] = v18;
  _r3.array = &buf.array[v14 & ((int)(v14 - buf.cap) >> 31)];
  _r3.len = len - v14;
  _r3.cap = buf.cap - v14;
  return _r3;
}
// 805DEC8: variable 'v4' is possibly undefined
// 805DED2: variable 'v3' is possibly undefined

//----- (0805DFA0) --------------------------------------------------------
__uint8 __golang runtime_fmtNSAsMS(__uint8 buf, uint64 ns)
{
  int v2; // ecx
  int v3; // ebx
  int v4; // ebp
  int v5; // ebx
  int v6; // ebx
  unsigned int v7; // eax
  unsigned int v8; // ecx
  __int32 i; // edx
  int v10; // ebx
  int v11; // et0
  int v12; // et1
  uint64 d_8; // [esp+10h] [ebp-18h]
  uint64 d_8a; // [esp+10h] [ebp-18h]
  uint64 d_8b; // [esp+10h] [ebp-18h]
  __int32 dec; // [esp+24h] [ebp-4h]
  __uint8 _r2; // [esp+40h] [ebp+18h]

  LOBYTE(v2) = HIDWORD(ns) == 0;
  LOBYTE(v3) = (unsigned int)ns >= 0x989680;
  v5 = v2 & v3;
  LOBYTE(v2) = HIDWORD(ns) != 0;
  v6 = v2 | v5;
  if ( (_BYTE)v6 )
  {
    d_8b = runtime_uint64div(ns, 0xF4240uLL);
    return runtime_itoaDiv(buf, d_8b, 0);
  }
  else
  {
    d_8 = runtime_uint64div(ns, 0x3E8uLL);
    v7 = HIDWORD(d_8);
    v8 = d_8;
    if ( (_DWORD)d_8 == 0 && HIDWORD(d_8) == 0 )
    {
      if ( !buf.len )
        runtime_panicindex();
      *buf.array = 48;
      _r2.array = buf.array;
      _r2.len = 1;
      _r2.cap = buf.cap;
    }
    else
    {
      for ( i = 3; ; i = dec - 1 )
      {
        LOBYTE(v6) = v7 == 0;
        v11 = v6;
        v10 = v4;
        LOBYTE(v10) = v8 >= 0x64;
        v12 = v10;
        v6 = v11;
        LOBYTE(v6) = v7 != 0;
        v4 = v6 | v11 & v12;
        if ( !((v7 != 0) | (unsigned __int8)(v11 & v12)) )
          break;
        dec = i;
        d_8a = runtime_uint64div(__PAIR64__(v7, v8), 0xAuLL);
        v7 = HIDWORD(d_8a);
        v8 = d_8a;
      }
      return runtime_itoaDiv(buf, __PAIR64__(v7, v8), i);
    }
  }
  return _r2;
}
// 805DFCF: variable 'v2' is possibly undefined
// 805DFCF: variable 'v3' is possibly undefined
// 805E054: variable 'v4' is possibly undefined

//----- (0805E160) --------------------------------------------------------
void __golang runtime___ptr_mTreap__insert(runtime_mTreap_0 *root, runtime_mspan *span)
{
  uintptr npages; // ecx
  runtime_mTreap_0 *v3; // edx
  runtime_treapNode *treap; // ebx
  runtime_treapNode *v5; // esi
  uintptr npagesKey; // edx
  runtime_treapNode *v7; // edx
  runtime_treapNode **p_right; // edx
  runtime_treapNode *v9; // esi
  unsigned int spanKey; // edx
  runtime_treapNode *v11; // edx
  runtime_treapNode *v12; // esi
  runtime_treapNode *v13; // eax
  int v14; // edx
  unsigned int v15; // ebp
  void **v16; // ecx
  string f; // [esp+0h] [ebp-1Ch]
  string fa; // [esp+0h] [ebp-1Ch]
  string fb; // [esp+0h] [ebp-1Ch]
  string fc; // [esp+0h] [ebp-1Ch]
  string fd; // [esp+0h] [ebp-1Ch]
  string fe; // [esp+0h] [ebp-1Ch]
  string ff; // [esp+0h] [ebp-1Ch]
  uintptr v; // [esp+8h] [ebp-14h]
  unsigned int va; // [esp+8h] [ebp-14h]
  runtime_mTreap_0 *v_4; // [esp+Ch] [ebp-10h]
  runtime_mspan *v27; // [esp+14h] [ebp-8h]
  runtime_treapNode *p; // [esp+18h] [ebp-4h]

  npages = span->npages;
  v3 = root;
  treap = root->treap;
  v5 = 0;
  while ( treap )
  {
    npagesKey = treap->npagesKey;
    if ( npagesKey >= npages )
    {
      if ( npagesKey <= npages )
      {
        spanKey = (unsigned int)treap->spanKey;
        if ( spanKey >= (unsigned int)span )
        {
          if ( spanKey <= (unsigned int)span )
          {
            ff.str = (uint8 *)"inserting span already in treap";
            ff.len = 31;
            runtime_throw(ff);
            BUG();
          }
          v11 = treap;
          treap = (runtime_treapNode *)((char *)treap + 4);
        }
        else
        {
          v11 = treap;
        }
        v12 = treap;
        treap = v11;
        p_right = &v12->right;
      }
      else
      {
        p_right = &treap->left;
      }
      v9 = (runtime_treapNode *)p_right;
      v7 = treap;
      treap = v9;
    }
    else
    {
      v7 = treap;
    }
    v5 = v7;
    v3 = (runtime_mTreap_0 *)treap;
    treap = treap->right;
  }
  v_4 = v3;
  v13 = (runtime_treapNode *)runtime___ptr_fixalloc__alloc(&stru_814B588);
  p = v13;
  v13->right = 0;
  v13->left = 0;
  v13->parent = 0;
  v13->spanKey = 0;
  v13->npagesKey = 0;
  v13->priority = 0;
  v13->npagesKey = span->npages;
  v14 = *(_DWORD *)(*(_DWORD *)(__readgsdword(0) - 4) + 24);
  v15 = (*(int *)(v14 + 148) >> 31) & 0xA8888EEF ^ (2 * *(_DWORD *)(v14 + 148));
  *(_DWORD *)(v14 + 148) = v15;
  v13->priority = v15;
  v13->spanKey = span;
  v13->parent = v5;
  v_4->treap = v13;
  while ( 1 )
  {
    v16 = (void **)&v13->parent->right;
    if ( !v16 || (unsigned int)v16[5] <= v13->priority )
      break;
    if ( v13->spanKey->npages != v13->npagesKey )
    {
      v = v13->npagesKey;
      runtime_printlock();
      fa.str = (uint8 *)"runtime: insert t=";
      fa.len = 18;
      runtime_printstring(fa);
      runtime_printsp();
      runtime_printpointer(p);
      runtime_printsp();
      fb.str = (uint8 *)"t.npagesKey=";
      fb.len = 12;
      runtime_printstring(fb);
      runtime_printsp();
      runtime_printint(v);
      runtime_printnl();
      runtime_printunlock();
      v27 = p->spanKey;
      va = v27->npages;
      runtime_printlock();
      fc.str = (uint8 *)"runtime:      t.spanKey=";
      fc.len = 24;
      runtime_printstring(fc);
      runtime_printsp();
      runtime_printpointer(v27);
      runtime_printsp();
      fd.str = (uint8 *)"t.spanKey.npages=";
      fd.len = 17;
      runtime_printstring(fd);
      runtime_printsp();
      runtime_printint(va);
      runtime_printnl();
      runtime_printunlock();
      fe.str = (uint8 *)"span and treap sizes do not match?";
      fe.len = 34;
      runtime_throw(fe);
      BUG();
    }
    if ( v16[1] == v13 )
    {
      runtime___ptr_mTreap__rotateRight(root, v13->parent);
    }
    else
    {
      if ( *v16 != v13 )
      {
        f.str = (uint8 *)"treap insert finds a broken treap";
        f.len = 33;
        runtime_throw(f);
        BUG();
      }
      runtime___ptr_mTreap__rotateLeft(root, v13->parent);
    }
    v13 = p;
  }
}

//----- (0805E400) --------------------------------------------------------
runtime_mspan *__golang runtime___ptr_mTreap__removeNode(runtime_mTreap_0 *root, runtime_treapNode *t)
{
  runtime_treapNode *v2; // eax
  runtime_mspan *spanKey; // ecx
  bool v4; // zf
  runtime_treapNode *left; // ebx
  runtime_treapNode *parent; // edx
  string s; // [esp+0h] [ebp-Ch]
  runtime_mspan *i; // [esp+8h] [ebp-4h]

  v2 = t;
  spanKey = t->spanKey;
  if ( spanKey->npages != t->npagesKey )
  {
    s.str = (uint8 *)"span and treap node npages do not match";
    s.len = 39;
    runtime_throw(s);
    BUG();
  }
  for ( i = t->spanKey; ; spanKey = i )
  {
    v4 = v2->right == 0;
    if ( !v2->right )
      break;
LABEL_5:
    if ( v4 || (left = v2->left) != 0 && left->priority < v2->right->priority )
      runtime___ptr_mTreap__rotateRight(root, v2);
    else
      runtime___ptr_mTreap__rotateLeft(root, v2);
    v2 = t;
  }
  if ( v2->left )
  {
    v4 = 1;
    goto LABEL_5;
  }
  parent = v2->parent;
  if ( parent )
  {
    if ( parent->left == v2 )
      parent->left = 0;
    else
      parent->right = 0;
  }
  else
  {
    root->treap = 0;
  }
  v2->spanKey = 0;
  v2->npagesKey = 0;
  stru_814B588.inuse -= stru_814B588.size;
  v2->right = (runtime_treapNode *)stru_814B588.list;
  stru_814B588.list = (runtime_mlink *)v2;
  return spanKey;
}

//----- (0805E510) --------------------------------------------------------
runtime_mspan *__golang runtime___ptr_mTreap__remove(runtime_mTreap_0 *root, uintptr npages)
{
  runtime_treapNode *treap; // ecx
  runtime_treapNode *left; // ebp
  string s; // [esp+0h] [ebp-10h]
  runtime_mspan *spanKey; // [esp+Ch] [ebp-4h]

  treap = root->treap;
  while ( treap )
  {
    if ( !treap->spanKey )
    {
      s.str = (uint8 *)"treap node with nil spanKey found";
      s.len = 33;
      runtime_throw(s);
      BUG();
    }
    if ( treap->npagesKey >= npages )
    {
      spanKey = treap->spanKey;
      left = treap->left;
      if ( !left || left->npagesKey < npages )
      {
        runtime___ptr_mTreap__removeNode(root, treap);
        return spanKey;
      }
      treap = treap->left;
    }
    else
    {
      treap = treap->right;
    }
  }
  return 0;
}

//----- (0805E5B0) --------------------------------------------------------
void __golang runtime___ptr_mTreap__removeSpan(runtime_mTreap_0 *root, runtime_mspan *span)
{
  uintptr npages; // ecx
  runtime_treapNode *t; // ebx
  runtime_mspan *spanKey; // ebp
  uintptr npagesKey; // esi

  npages = span->npages;
  t = root->treap;
  while ( 1 )
  {
    spanKey = t->spanKey;
    if ( spanKey == span )
      break;
    npagesKey = t->npagesKey;
    if ( npagesKey >= npages )
    {
      if ( npagesKey <= npages )
      {
        if ( spanKey >= span )
        {
          if ( spanKey > span )
            t = t->left;
        }
        else
        {
          t = t->right;
        }
      }
      else
      {
        t = t->left;
      }
    }
    else
    {
      t = t->right;
    }
  }
  runtime___ptr_mTreap__removeNode(root, t);
}

//----- (0805E620) --------------------------------------------------------
uintptr __golang runtime_scavengetreap(runtime_treapNode *treap, uint64 now, uint64 limit)
{
  uintptr v3; // [esp+18h] [ebp-8h]
  uintptr v4; // [esp+1Ch] [ebp-4h]

  if ( !treap )
    return 0;
  v4 = runtime_scavengeTreapNode(treap, now, limit);
  v3 = runtime_scavengetreap(treap->left, now, limit);
  return v4 + v3 + runtime_scavengetreap(treap->right, now, limit);
}

//----- (0805E710) --------------------------------------------------------
void __golang runtime___ptr_mTreap__rotateLeft(runtime_mTreap_0 *root, runtime_treapNode *x)
{
  runtime_treapNode *right; // ecx
  runtime_treapNode *parent; // edx
  runtime_treapNode *left; // ebx
  runtime_treapNode *v5; // ebp
  runtime_treapNode *v6; // esi
  string s; // [esp+0h] [ebp-8h]

  right = x->right;
  parent = x->parent;
  left = x->left;
  v5 = x->right->left;
  v6 = x->right->right;
  right->left = x;
  x->parent = right;
  right->right = v6;
  if ( v6 )
    v6->parent = right;
  x->left = left;
  if ( left )
    left->parent = x;
  x->right = v5;
  if ( v5 )
    v5->parent = x;
  right->parent = parent;
  if ( parent )
  {
    if ( parent->left == x )
    {
      parent->left = right;
    }
    else
    {
      if ( parent->right != x )
      {
        s.str = (uint8 *)"large span treap rotateLeft";
        s.len = 27;
        runtime_throw(s);
        BUG();
      }
      parent->right = right;
    }
  }
  else
  {
    root->treap = right;
  }
}

//----- (0805E7B0) --------------------------------------------------------
void __golang runtime___ptr_mTreap__rotateRight(runtime_mTreap_0 *root, runtime_treapNode *y)
{
  runtime_treapNode *left; // ecx
  runtime_treapNode *parent; // edx
  runtime_treapNode *right; // ebx
  runtime_treapNode *v5; // ebp
  runtime_treapNode *v6; // esi
  string s; // [esp+0h] [ebp-8h]

  left = y->left;
  parent = y->parent;
  right = y->right;
  v5 = left->left;
  v6 = left->right;
  if ( v5 )
    v5->parent = left;
  left->right = y;
  y->parent = left;
  y->left = v6;
  if ( v6 )
    v6->parent = y;
  y->right = right;
  if ( right )
    right->parent = y;
  left->parent = parent;
  if ( parent )
  {
    if ( parent->left == y )
    {
      parent->left = left;
    }
    else
    {
      if ( parent->right != y )
      {
        s.str = (uint8 *)"large span treap rotateRight";
        s.len = 28;
        runtime_throw(s);
        BUG();
      }
      parent->right = left;
    }
  }
  else
  {
    root->treap = left;
  }
}

//----- (0805E840) --------------------------------------------------------
void __golang runtime_gcMarkRootPrepare()
{
  int v0; // eax
  int v1; // ecx
  int v2; // edx
  int v3; // ecx
  int v4; // eax
  unsigned __int64 v5; // kr00_8
  int v6; // edx
  unsigned __int64 bytes; // [esp+0h] [ebp-1Ch]
  unsigned __int64 bytesa; // [esp+0h] [ebp-1Ch]
  __int32 v9; // [esp+4h] [ebp-18h]
  __int32 v10; // [esp+4h] [ebp-18h]
  int v11; // [esp+Ch] [ebp-10h]
  int v12; // [esp+Ch] [ebp-10h]
  int v13; // [esp+10h] [ebp-Ch]
  int v14; // [esp+10h] [ebp-Ch]
  int v15; // [esp+14h] [ebp-8h]
  int v16; // [esp+18h] [ebp-4h]

  if ( runtime_gcphase == 2 )
    runtime_work.nFlushCacheRoots = runtime_gomaxprocs;
  else
    runtime_work.nFlushCacheRoots = 0;
  runtime_work.nDataRoots = 0;
  runtime_work.nBSSRoots = 0;
  if ( !runtime_work.markrootDone )
  {
    bytesa = COERCE_UNSIGNED_INT64(COERCE_LONG_DOUBLE(COERCE_LONG_DOUBLE(runtime_activeModules())));
    v0 = HIDWORD(bytesa);
    v13 = HIDWORD(bytesa);
    v1 = bytesa;
    v2 = 0;
    while ( v2 < v0 )
    {
      v11 = v2;
      v16 = v1;
      v9 = runtime_gcMarkRootPrepare_func1(*(_DWORD *)(*(_DWORD *)v1 + 68) - *(_DWORD *)(*(_DWORD *)v1 + 64));
      if ( v9 > runtime_work.nDataRoots )
        runtime_work.nDataRoots = v9;
      v1 = v16 + 4;
      v2 = v11 + 1;
      v0 = v13;
    }
    bytes = COERCE_UNSIGNED_INT64(COERCE_LONG_DOUBLE(COERCE_LONG_DOUBLE(runtime_activeModules())));
    v3 = HIDWORD(bytes);
    v5 = bytes;
    v14 = HIDWORD(v5);
    v4 = v5;
    v6 = 0;
    while ( v6 < v3 )
    {
      v12 = v6;
      v15 = v4;
      HIDWORD(bytes) = runtime_gcMarkRootPrepare_func1(*(_DWORD *)(*(_DWORD *)v4 + 76) - *(_DWORD *)(*(_DWORD *)v4 + 72));
      if ( SHIDWORD(bytes) > runtime_work.nBSSRoots )
        runtime_work.nBSSRoots = HIDWORD(bytes);
      v4 = v15 + 4;
      v6 = v12 + 1;
      v3 = v14;
    }
  }
  if ( runtime_work.markrootDone )
  {
    runtime_work.nSpanRoots = 0;
    runtime_work.nStackRoots = 0;
    if ( runtime_debug.gcrescanstacks > 0 )
    {
      runtime_internal_atomic_Loaduintptr();
      runtime_work.nStackRoots = HIDWORD(bytes);
    }
  }
  else
  {
    v10 = runtime___ptr_gcSweepBuf__numBlocks((runtime_gcSweepBuf_0 *)&dword_8149114[5
                                                                                   * (((unsigned int)dword_81490F0 >> 1) & 1)]);
    runtime_work.nSpanRoots = v10;
    runtime_internal_atomic_Loaduintptr();
    runtime_work.nStackRoots = v10;
  }
  runtime_work.markrootNext = 0;
  runtime_work.markrootJobs = runtime_work.nStackRoots
                            + runtime_work.nSpanRoots
                            + runtime_work.nBSSRoots
                            + runtime_work.nDataRoots
                            + runtime_work.nFlushCacheRoots
                            + 2;
}
// 805E840: could not find valid save-restore pair for ebx
// 805E9D4: variable 'bytes' is possibly undefined
// 81490F0: using guessed type int dword_81490F0;
// 8149114: using guessed type _DWORD dword_8149114[11];

//----- (0805EA40) --------------------------------------------------------
void __golang runtime_gcMarkRootCheck()
{
  __int32 j; // eax
  runtime_g *v1; // ecx
  runtime_g *v2; // ecx
  __int32 k; // eax
  string l; // [esp+0h] [ebp-20h]
  string la; // [esp+0h] [ebp-20h]
  string lb; // [esp+0h] [ebp-20h]
  string lc; // [esp+0h] [ebp-20h]
  string ld; // [esp+0h] [ebp-20h]
  string le; // [esp+0h] [ebp-20h]
  string lf; // [esp+0h] [ebp-20h]
  string lg; // [esp+0h] [ebp-20h]
  string lh; // [esp+0h] [ebp-20h]
  uint32 v13; // [esp+4h] [ebp-1Ch]
  bool gcscanvalid; // [esp+Ah] [ebp-16h]
  bool gcscandone; // [esp+Bh] [ebp-15h]
  __int32 i; // [esp+Ch] [ebp-14h]
  uint32 v; // [esp+10h] [ebp-10h]
  uint32 va; // [esp+10h] [ebp-10h]
  int64 v_4; // [esp+14h] [ebp-Ch]
  uint32 v_4a; // [esp+14h] [ebp-Ch]
  runtime_g *gp; // [esp+1Ch] [ebp-4h]
  runtime_g *gpa; // [esp+1Ch] [ebp-4h]

  if ( runtime_work.markrootNext < runtime_work.markrootJobs )
  {
    v_4a = runtime_work.markrootNext;
    va = runtime_work.markrootJobs;
    runtime_printlock();
    runtime_printint(v_4a);
    lf.str = (uint8 *)" of ";
    lf.len = 4;
    runtime_printstring(lf);
    runtime_printint(va);
    lg.str = (uint8 *)" markroot jobs done\n";
    lg.len = 20;
    runtime_printstring(lg);
    runtime_printunlock();
    lh.str = (uint8 *)"left over markroot jobs";
    lh.len = 23;
    runtime_throw(lh);
    BUG();
  }
  runtime_lock(&runtime_allglock);
  if ( runtime_gcphase == 2 && runtime_debug.gcrescanstacks > 0 )
  {
    for ( j = 0; ; ++j )
    {
      if ( j >= runtime_allgs.len )
        goto LABEL_13;
      if ( (unsigned int)j >= runtime_allgs.len )
        runtime_panicindex();
      i = j;
      v1 = runtime_allgs.array[j];
      if ( !v1->gcscandone || !v1->gcscanvalid )
      {
        gp = runtime_allgs.array[j];
        if ( runtime_readgstatus(v1) != 6 )
        {
          v2 = gp;
          goto LABEL_21;
        }
        j = i;
      }
    }
  }
  for ( k = 0; k < runtime_work.nStackRoots; ++k )
  {
    if ( (unsigned int)k >= runtime_allgs.len )
      runtime_panicindex();
    v2 = runtime_allgs.array[k];
    if ( !v2->gcscandone )
    {
LABEL_21:
      gpa = v2;
      v13 = runtime_readgstatus(v2);
      v_4 = gpa->goid;
      v = v13;
      gcscandone = gpa->gcscandone;
      gcscanvalid = gpa->gcscanvalid;
      runtime_printlock();
      l.str = (uint8 *)"gp";
      l.len = 2;
      runtime_printstring(l);
      runtime_printsp();
      runtime_printpointer(gpa);
      runtime_printsp();
      la.str = (uint8 *)"goid";
      la.len = 4;
      runtime_printstring(la);
      runtime_printsp();
      runtime_printint(v_4);
      runtime_printsp();
      lb.str = (uint8 *)"status";
      lb.len = 6;
      runtime_printstring(lb);
      runtime_printsp();
      runtime_printint(v);
      runtime_printsp();
      lc.str = (uint8 *)"gcscandone";
      lc.len = 10;
      runtime_printstring(lc);
      runtime_printsp();
      runtime_printbool(gcscandone);
      runtime_printsp();
      ld.str = (uint8 *)"gcscanvalid";
      ld.len = 11;
      runtime_printstring(ld);
      runtime_printsp();
      runtime_printbool(gcscanvalid);
      runtime_printnl();
      runtime_printunlock();
      runtime_unlock(&runtime_allglock);
      le.str = (uint8 *)"scan missed a g";
      le.len = 15;
      runtime_throw(le);
      BUG();
    }
  }
LABEL_13:
  runtime_unlock(&runtime_allglock);
}

//----- (0805ED10) --------------------------------------------------------
void __golang runtime_markroot(runtime_gcWork_0 *gcw, uint32 i)
{
  unsigned __int32 v2; // ecx
  unsigned __int32 v3; // eax
  uint32 v4; // ecx
  runtime_finblock *j; // eax
  unsigned __int32 v6; // eax
  int tstart_high; // ecx
  int v8; // ecx
  unsigned __int64 v9; // kr00_8
  int v10; // eax
  int v11; // edx
  int v12; // ecx
  unsigned __int64 v13; // kr08_8
  int v14; // eax
  int v15; // edx
  string ptr; // [esp+0h] [ebp-48h]
  uintptr n0a; // [esp+4h] [ebp-44h]
  uintptr n0; // [esp+4h] [ebp-44h]
  uint32 baseData; // [esp+14h] [ebp-34h]
  uint32 baseBSS; // [esp+18h] [ebp-30h]
  int v21; // [esp+1Ch] [ebp-2Ch]
  int v22; // [esp+1Ch] [ebp-2Ch]
  int v23; // [esp+20h] [ebp-28h]
  int v24; // [esp+20h] [ebp-28h]
  __int32 v25; // [esp+28h] [ebp-20h]
  runtime_g *gp; // [esp+2Ch] [ebp-1Ch]
  runtime_finblock *fb; // [esp+30h] [ebp-18h]
  int v28; // [esp+34h] [ebp-14h]
  int v29; // [esp+38h] [ebp-10h]

  v2 = runtime_work.nFlushCacheRoots + 2;
  v25 = runtime_work.nBSSRoots + runtime_work.nDataRoots + runtime_work.nFlushCacheRoots;
  if ( i >= 2 && i < v2 )
  {
    runtime_flushmcache(i - 2);
    return;
  }
  v3 = runtime_work.nDataRoots + runtime_work.nFlushCacheRoots + 2;
  if ( v2 <= i && i < v3 )
  {
    baseData = runtime_work.nFlushCacheRoots + 2;
    v13 = COERCE_UNSIGNED_INT64(COERCE_LONG_DOUBLE(COERCE_LONG_DOUBLE(runtime_activeModules())));
    v12 = HIDWORD(v13);
    v24 = HIDWORD(v13);
    v14 = v13;
    v15 = 0;
    while ( v15 < v12 )
    {
      v22 = v15;
      v28 = v14;
      runtime_markrootBlock(
        *(_DWORD *)(*(_DWORD *)v14 + 64),
        *(_DWORD *)(*(_DWORD *)v14 + 68) - *(_DWORD *)(*(_DWORD *)v14 + 64),
        *(uint8 **)(*(_DWORD *)v14 + 200),
        gcw,
        i - baseData);
      v14 = v28 + 4;
      v15 = v22 + 1;
      v12 = HIDWORD(v13);
    }
  }
  else
  {
    v4 = runtime_work.nDataRoots + runtime_work.nFlushCacheRoots + runtime_work.nBSSRoots + 2;
    if ( v3 <= i && i < v4 )
    {
      baseBSS = runtime_work.nDataRoots + runtime_work.nFlushCacheRoots + 2;
      v9 = COERCE_UNSIGNED_INT64(COERCE_LONG_DOUBLE(COERCE_LONG_DOUBLE(runtime_activeModules())));
      v8 = HIDWORD(v9);
      v23 = HIDWORD(v9);
      v10 = v9;
      v11 = 0;
      while ( v11 < v8 )
      {
        v21 = v11;
        v29 = v10;
        runtime_markrootBlock(
          *(_DWORD *)(*(_DWORD *)v10 + 72),
          *(_DWORD *)(*(_DWORD *)v10 + 76) - *(_DWORD *)(*(_DWORD *)v10 + 72),
          *(uint8 **)(*(_DWORD *)v10 + 208),
          gcw,
          i - baseBSS);
        v10 = v29 + 4;
        v11 = v21 + 1;
        v8 = HIDWORD(v9);
      }
    }
    else
    {
      if ( i )
      {
        if ( i == 1 )
        {
          if ( runtime_work.markrootDone )
            return;
        }
        else
        {
          v6 = v25 + runtime_work.nSpanRoots + 2;
          if ( v4 <= i && i < v6 )
          {
            runtime_markrootSpans(gcw, i - v4);
            return;
          }
          if ( v6 > i || i >= runtime_work.nSpanRoots + v25 + runtime_work.nStackRoots + 2 )
          {
            ptr.str = (uint8 *)"markroot: bad index";
            ptr.len = 19;
            runtime_throw(ptr);
            BUG();
          }
          if ( i - v6 >= runtime_allgs.len )
            runtime_panicindex();
          gp = runtime_allgs.array[i - v6];
          n0 = runtime_readgstatus(gp);
          if ( (n0 == 4 || n0 == 3) && LODWORD(gp->waitsince) == 0 && HIDWORD(gp->waitsince) == 0 )
          {
            tstart_high = HIDWORD(runtime_work.tstart);
            LODWORD(gp->waitsince) = runtime_work.tstart;
            HIDWORD(gp->waitsince) = tstart_high;
          }
        }
        runtime_systemstack();
        return;
      }
      if ( !runtime_work.markrootDone )
      {
        for ( j = runtime_allfin; j; j = fb->alllink )
        {
          fb = j;
          n0a = runtime_internal_atomic_Load(&j->cnt);
          runtime_scanblock((uintptr)fb->fin, 20 * n0a, runtime_finptrmask, gcw);
        }
      }
    }
  }
}

//----- (0805F010) --------------------------------------------------------
void __golang runtime_markrootBlock(uintptr b0, uintptr n0, uint8 *ptrmask0, runtime_gcWork_0 *gcw, __int32 shard)
{
  uintptr v5; // ebx
  uintptr v6; // ebp
  uintptr v7; // ebp

  v5 = (shard << 18) + b0;
  v6 = b0 + n0;
  if ( v5 < b0 + n0 )
  {
    if ( b0 + (shard << 18) + 0x40000 <= v6 )
      v7 = 0x40000;
    else
      v7 = v6 - v5;
    runtime_scanblock((shard << 18) + b0, v7, &ptrmask0[0x2000 * shard], gcw);
  }
}

//----- (0805F090) --------------------------------------------------------
void __golang runtime_markrootFreeGStacks()
{
  runtime_g *schedlink; // eax
  runtime_g *v1; // edx
  runtime_g *tail; // [esp+8h] [ebp-Ch]
  runtime_g *gp; // [esp+Ch] [ebp-8h]
  runtime_g *v4; // [esp+10h] [ebp-4h]

  runtime_lock(&runtime_sched.gflock);
  gp = runtime_sched.gfreeStack;
  if ( *(_DWORD *)&runtime_writeBarrier.enabled )
    runtime_writebarrierptr((uintptr *)&runtime_sched.gfreeStack, 0);
  else
    runtime_sched.gfreeStack = 0;
  runtime_unlock(&runtime_sched.gflock);
  schedlink = gp;
  if ( gp )
  {
    v1 = gp;
    while ( schedlink )
    {
      v4 = schedlink;
      runtime_shrinkstack(schedlink);
      v1 = v4;
      schedlink = (runtime_g *)v4->schedlink;
    }
    tail = v1;
    runtime_lock(&runtime_sched.gflock);
    tail->schedlink = (runtime_guintptr)runtime_sched.gfreeNoStack;
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr((uintptr *)&runtime_sched.gfreeNoStack, (uintptr)gp);
    else
      runtime_sched.gfreeNoStack = gp;
    runtime_unlock(&runtime_sched.gflock);
  }
}

//----- (0805F1A0) --------------------------------------------------------
void __golang runtime_markrootSpans(runtime_gcWork_0 *gcw, __int32 shard)
{
  __int32 v2; // eax
  runtime_mutex_0 **v3; // ecx
  __int32 i; // edx
  runtime_mutex_0 *v5; // ebx
  _DWORD *p_key; // eax
  uintptr j; // ecx
  unsigned int v8; // ebx
  string b; // [esp+0h] [ebp-34h]
  string ba; // [esp+0h] [ebp-34h]
  string bb; // [esp+0h] [ebp-34h]
  string bc; // [esp+0h] [ebp-34h]
  string bd; // [esp+0h] [ebp-34h]
  unsigned __int64 ptrmask; // [esp+8h] [ebp-2Ch]
  __int32 spans_len; // [esp+14h] [ebp-20h]
  uint32 sg; // [esp+18h] [ebp-1Ch]
  uintptr v; // [esp+1Ch] [ebp-18h]
  __int32 v_4; // [esp+20h] [ebp-14h]
  runtime_mspan *s; // [esp+24h] [ebp-10h]
  uintptr v20; // [esp+28h] [ebp-Ch]
  runtime_mutex_0 *l; // [esp+2Ch] [ebp-8h]
  runtime_mutex_0 **v22; // [esp+30h] [ebp-4h]

  if ( runtime_work.markrootDone )
  {
    bd.str = (uint8 *)"markrootSpans during second markroot";
    bd.len = 36;
    runtime_throw(bd);
    BUG();
  }
  sg = dword_81490F0;
  ptrmask = COERCE_UNSIGNED_INT64(
              COERCE_LONG_DOUBLE(
                COERCE_LONG_DOUBLE(
                  runtime___ptr_gcSweepBuf__block(
                    (runtime_gcSweepBuf_0 *)&dword_8149114[5 * (((unsigned int)dword_81490F0 >> 1) & 1)],
                    shard))));
  v2 = HIDWORD(ptrmask);
  spans_len = HIDWORD(ptrmask);
  v3 = (runtime_mutex_0 **)ptrmask;
  for ( i = 0; i < v2; ++i )
  {
    v5 = *v3;
    if ( LOBYTE((*v3)[15].key) == 1 )
    {
      if ( !runtime_useCheckmark && v5[12].key != sg )
      {
        v = v5[12].key;
        runtime_printlock();
        b.str = (uint8 *)"sweep ";
        b.len = 6;
        runtime_printstring(b);
        runtime_printint(v);
        ba.str = (uint8 *)" ";
        ba.len = 1;
        runtime_printstring(ba);
        runtime_printint(sg);
        bb.str = (uint8 *)"\n";
        bb.len = 1;
        runtime_printstring(bb);
        runtime_printunlock();
        bc.str = (uint8 *)"gc: unswept span";
        bc.len = 16;
        runtime_throw(bc);
        BUG();
      }
      if ( v5[22].key )
      {
        v_4 = i;
        s = (runtime_mspan *)*v3;
        v22 = v3;
        l = v5 + 21;
        runtime_lock(v5 + 21);
        p_key = &v5->key;
        for ( j = v5[22].key; j; j = *(_DWORD *)j )
        {
          if ( *(_BYTE *)(j + 6) == 1 )
          {
            v8 = p_key[16];
            if ( !v8 )
              runtime_panicdivide();
            v20 = j;
            runtime_scanobject(p_key[3] + v8 * (*(unsigned __int16 *)(j + 4) / v8), gcw);
            runtime_scanblock(v20 + 8, 4u, runtime_noptrdata, gcw);
            p_key = &s->next;
            j = v20;
          }
        }
        runtime_unlock(l);
        v2 = spans_len;
        v3 = v22;
        i = v_4;
      }
    }
    ++v3;
  }
}
// 805F1A0: could not find valid save-restore pair for esi
// 80E0D84: using guessed type char go_string__;
// 81490F0: using guessed type int dword_81490F0;
// 8149114: using guessed type _DWORD dword_8149114[11];

//----- (0805F3C0) --------------------------------------------------------
void __golang runtime_gcAssistAlloc(runtime_g *gp)
{
  runtime_g *v1; // eax
  runtime_g *v2; // edx
  runtime_m *m; // ecx
  bool v4; // cl
  int v5; // eax
  int v6; // ecx
  unsigned int v7; // edx
  unsigned int v8; // ebx
  char v9; // dl
  runtime_g *v10; // eax
  void *param; // ecx
  unsigned int v12; // edx
  unsigned int v13; // ebp
  int v14; // ecx
  int64 y_4; // [esp+4h] [ebp-58h]
  uint64 y_8; // [esp+8h] [ebp-54h]
  uint64 y_8a; // [esp+8h] [ebp-54h]
  __int64 y_8b; // [esp+8h] [ebp-54h]
  uint64 y_8c; // [esp+8h] [ebp-54h]
  int v20; // [esp+Ch] [ebp-50h]
  unsigned int v21; // [esp+Ch] [ebp-50h]
  bool traced; // [esp+17h] [ebp-45h]
  bool traceda; // [esp+17h] [ebp-45h]
  unsigned __int64 stolen_lo; // [esp+18h] [ebp-44h]
  uint32 scanWork_lo; // [esp+20h] [ebp-3Ch]
  int64 debtBytes_lo; // [esp+28h] [ebp-34h]
  unsigned __int64 debtBytes_loa; // [esp+28h] [ebp-34h]
  int64 gcAssistBytes; // [esp+30h] [ebp-2Ch]
  unsigned int v29; // [esp+38h] [ebp-24h]
  unsigned int v30; // [esp+38h] [ebp-24h]
  unsigned int v31; // [esp+3Ch] [ebp-20h]
  double v32; // [esp+40h] [ebp-1Ch]
  double v33; // [esp+40h] [ebp-1Ch]
  double v34; // [esp+40h] [ebp-1Ch]
  void *v35; // [esp+48h] [ebp-14h]

  v1 = gp;
  v2 = *(runtime_g **)(__readgsdword(0) - 4);
  if ( v2 != gp->m->g0 )
  {
    m = v2->m;
    if ( m->locks <= 0 && !m->preemptoff.len )
    {
      v4 = 0;
      while ( 1 )
      {
        traced = v4;
        v32 = *(double *)&qword_81578A0;
        debtBytes_lo = -v1->gcAssistBytes;
        *(double *)&y_8 = runtime_int64tofloat64(debtBytes_lo);
        runtime_float64toint64(v32 * *(double *)&y_8, y_8);
        v5 = v20;
        v6 = HIDWORD(y_4);
        if ( v20 < 0 || v20 == 0 && HIDWORD(y_4) < 0x10000 )
        {
          v34 = *(double *)&qword_81578A8;
          *(double *)&y_8c = runtime_int64tofloat64(0x10000LL);
          runtime_float64toint64(*(double *)&y_8c * v34, y_8c);
          v7 = v21;
          v8 = HIDWORD(y_4);
          v6 = 0x10000;
          v5 = 0;
        }
        else
        {
          v7 = HIDWORD(debtBytes_lo);
          v8 = debtBytes_lo;
        }
        stolen_lo = __PAIR64__(v5, v6);
        debtBytes_loa = __PAIR64__(v7, v8);
        runtime_internal_atomic_Loadint64();
        if ( SHIDWORD(y_4) > 0 || HIDWORD(y_4) == 0 && (_DWORD)y_4 != 0 )
        {
          v12 = HIDWORD(stolen_lo);
          v13 = stolen_lo;
          if ( SHIDWORD(y_4) < SHIDWORD(stolen_lo)
            || HIDWORD(y_4) == HIDWORD(stolen_lo) && (unsigned int)y_4 < (unsigned int)stolen_lo )
          {
            v30 = HIDWORD(y_4);
            v31 = y_4;
            gcAssistBytes = gp->gcAssistBytes;
            v33 = *(double *)&qword_81578A8;
            *(double *)&y_8a = runtime_int64tofloat64(y_4);
            runtime_float64toint64(*(double *)&y_8a * v33, y_8a);
            gp->gcAssistBytes = gcAssistBytes + y_8b + 1;
            v14 = stolen_lo;
            v13 = v31;
            v12 = v30;
          }
          else
          {
            gp->gcAssistBytes += debtBytes_loa;
            v14 = stolen_lo;
          }
          v29 = v12;
          scanWork_lo = v14 - v13;
          runtime_internal_atomic_Xaddint64();
          if ( ((scanWork_lo == 0) & ((stolen_lo - __PAIR64__(v29, v13)) >> 32 == 0)) != 0 )
            break;
        }
        if ( runtime_trace.enabled )
        {
          if ( !traced )
            runtime_traceGCMarkAssistStart();
          v9 = 1;
        }
        else
        {
          v9 = traced;
        }
        traceda = v9;
        runtime_systemstack();
        v10 = gp;
        param = gp->param;
        if ( *(_DWORD *)&runtime_writeBarrier.enabled )
        {
          v35 = gp->param;
          runtime_writebarrierptr((uintptr *)&gp->param, 0);
          v10 = gp;
          param = v35;
        }
        else
        {
          gp->param = 0;
        }
        if ( param )
        {
          runtime_gcMarkDone();
          v10 = gp;
        }
        if ( v10->gcAssistBytes >= 0 )
        {
LABEL_22:
          if ( !traceda )
            return;
          goto LABEL_23;
        }
        if ( v10->preempt )
        {
          runtime_Gosched();
          v1 = gp;
          v4 = traceda;
        }
        else
        {
          if ( runtime_gcParkAssist() )
            goto LABEL_22;
          v1 = gp;
          v4 = traceda;
        }
      }
      if ( traced )
LABEL_23:
        runtime_traceGCMarkAssistDone();
    }
  }
}
// 805F470: variable 'v20' is possibly undefined
// 805F474: variable 'y_4' is possibly undefined
// 805F73D: variable 'y_8b' is possibly undefined
// 805F7B1: variable 'v21' is possibly undefined
// 81578A0: using guessed type __int64 qword_81578A0;
// 81578A8: using guessed type __int64 qword_81578A8;

//----- (0805F7E0) --------------------------------------------------------
void __golang runtime_gcAssistAlloc1(runtime_g *gp, int64 scanWork)
{
  runtime_puintptr p; // ecx
  unsigned int v3; // esi
  unsigned int v4; // ebp
  unsigned int v5; // eax
  unsigned __int64 v6; // kr08_8
  __int64 ptr; // [esp+0h] [ebp-4Ch]
  __int64 ptra; // [esp+0h] [ebp-4Ch]
  string ptrb; // [esp+0h] [ebp-4Ch]
  string ptrc; // [esp+0h] [ebp-4Ch]
  string ptrd; // [esp+0h] [ebp-4Ch]
  string ptre; // [esp+0h] [ebp-4Ch]
  string ptrf; // [esp+0h] [ebp-4Ch]
  string ptrg; // [esp+0h] [ebp-4Ch]
  string ptrh; // [esp+0h] [ebp-4Ch]
  uint32 newval; // [esp+8h] [ebp-44h]
  uint64 newvalb; // [esp+8h] [ebp-44h]
  __int64 newvala; // [esp+8h] [ebp-44h]
  uint32 newval_4; // [esp+Ch] [ebp-40h]
  int64 workDone_lo; // [esp+14h] [ebp-38h]
  __int64 startTime_lo; // [esp+1Ch] [ebp-30h]
  int64 v; // [esp+30h] [ebp-1Ch]
  uint32 va; // [esp+30h] [ebp-1Ch]
  uint32 vb; // [esp+30h] [ebp-1Ch]
  double v25; // [esp+38h] [ebp-14h]
  runtime_gcWork_0 *gcw; // [esp+40h] [ebp-Ch]
  runtime_puintptr v27; // [esp+44h] [ebp-8h]

  if ( *(_DWORD *)&runtime_writeBarrier.enabled )
    runtime_writebarrierptr((uintptr *)&gp->param, 0);
  else
    gp->param = 0;
  HIDWORD(ptr) = runtime_internal_atomic_Load(&runtime_gcBlackenEnabled);
  if ( HIDWORD(ptr) )
  {
    runtime_nanotime();
    startTime_lo = ptr;
    runtime_internal_atomic_Xadd();
    if ( newval == runtime_work.nproc )
    {
      vb = runtime_work.nproc;
      runtime_printlock();
      ptrf.str = (uint8 *)"runtime: work.nwait =";
      ptrf.len = 21;
      runtime_printstring(ptrf);
      runtime_printsp();
      runtime_printint(newval);
      runtime_printsp();
      ptrg.str = (uint8 *)"work.nproc=";
      ptrg.len = 11;
      runtime_printstring(ptrg);
      runtime_printsp();
      runtime_printint(vb);
      runtime_printnl();
      runtime_printunlock();
      ptrh.str = (uint8 *)"nwait > work.nprocs";
      ptrh.len = 19;
      runtime_throw(ptrh);
      BUG();
    }
    runtime_casgstatus(gp, 2u, 4u);
    gp->waitreason.len = 17;
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr((uintptr *)&gp->waitreason, (uintptr)"GC assist marking");
    else
      gp->waitreason.str = (uint8 *)"GC assist marking";
    gcw = (runtime_gcWork_0 *)(*(_DWORD *)(*(_DWORD *)(*(_DWORD *)(__readgsdword(0) - 4) + 24) + 92) + 2384);
    HIDWORD(workDone_lo) = runtime_gcDrainN(gcw, scanWork);
    LODWORD(workDone_lo) = newval_4;
    if ( runtime_gcBlackenPromptly )
      runtime___ptr_gcWork__dispose(gcw);
    runtime_casgstatus(gp, 4u, 2u);
    v = gp->gcAssistBytes;
    v25 = *(double *)&qword_81578A8;
    *(double *)&newvalb = runtime_int64tofloat64(workDone_lo);
    runtime_float64toint64(v25 * *(double *)&newvalb, newvalb);
    gp->gcAssistBytes = v + newvala + 1;
    LODWORD(ptra) = &runtime_work.nwait;
    HIDWORD(ptra) = 1;
    runtime_internal_atomic_Xadd();
    if ( (unsigned int)newvala > runtime_work.nproc )
    {
      va = runtime_work.nproc;
      runtime_printlock();
      ptrb.str = (uint8 *)"runtime: work.nwait=";
      ptrb.len = 20;
      runtime_printstring(ptrb);
      runtime_printsp();
      runtime_printint((unsigned int)newvala);
      runtime_printsp();
      ptrc.str = (uint8 *)"work.nproc=";
      ptrc.len = 11;
      runtime_printstring(ptrc);
      runtime_printsp();
      runtime_printint(va);
      runtime_printsp();
      ptrd.str = (uint8 *)"gcBlackenPromptly=";
      ptrd.len = 18;
      runtime_printstring(ptrd);
      runtime_printsp();
      runtime_printbool(runtime_gcBlackenPromptly);
      runtime_printnl();
      runtime_printunlock();
      ptre.str = (uint8 *)"work.nwait > work.nproc";
      ptre.len = 23;
      runtime_throw(ptre);
      BUG();
    }
    if ( (_DWORD)newvala == runtime_work.nproc )
    {
      BYTE4(ptra) = runtime_gcMarkWorkAvailable(0);
      if ( !BYTE4(ptra) )
      {
        if ( *(_DWORD *)&runtime_writeBarrier.enabled )
          runtime_writebarrierptr((uintptr *)&gp->param, (uintptr)gp);
        else
          gp->param = gp;
      }
    }
    runtime_nanotime();
    p = gp->m->p;
    v3 = *(_DWORD *)(p + 2368);
    v4 = ptra - startTime_lo + v3;
    v5 = *(_DWORD *)(p + 2372);
    *(_DWORD *)(p + 2368) = v4;
    v6 = ptra - startTime_lo + __PAIR64__(v5, v3);
    *(_DWORD *)(p + 2372) = HIDWORD(v6);
    if ( v4 > 0x1388 && HIDWORD(v6) == 0 || SHIDWORD(v6) > 0 )
    {
      v27 = p;
      runtime_internal_atomic_Xaddint64();
      *(_DWORD *)(v27 + 2368) = 0;
      *(_DWORD *)(v27 + 2372) = 0;
    }
  }
  else
  {
    gp->gcAssistBytes = 0LL;
  }
}
// 805F85D: variable 'ptr' is possibly undefined
// 805F883: variable 'newval' is possibly undefined
// 805F90F: variable 'newval_4' is possibly undefined
// 805F9B7: variable 'newvala' is possibly undefined
// 805FA0F: variable 'ptra' is possibly undefined
// 81578A8: using guessed type __int64 qword_81578A8;

//----- (0805FC80) --------------------------------------------------------
void __golang runtime_gcWakeAllAssists()
{
  runtime_lock(&runtime_work.assistQueue.lock);
  runtime_injectglist((runtime_g *)runtime_work.assistQueue.head);
  runtime_work.assistQueue.head = 0;
  runtime_work.assistQueue.tail = 0;
  runtime_unlock(&runtime_work.assistQueue.lock);
}

//----- (0805FCF0) --------------------------------------------------------
bool __golang runtime_gcParkAssist()
{
  runtime_guintptr v0; // eax
  uint32 reason; // [esp+4h] [ebp-18h]
  string reasona; // [esp+4h] [ebp-18h]
  int reason_4; // [esp+8h] [ebp-14h]
  runtime_guintptr tail; // [esp+14h] [ebp-8h]
  runtime_guintptr head; // [esp+18h] [ebp-4h]

  runtime_lock(&runtime_work.assistQueue.lock);
  reason = runtime_internal_atomic_Load(&runtime_gcBlackenEnabled);
  if ( reason )
  {
    v0 = *(_DWORD *)(__readgsdword(0) - 4);
    head = runtime_work.assistQueue.head;
    tail = runtime_work.assistQueue.tail;
    if ( runtime_work.assistQueue.head )
      *(_DWORD *)(runtime_work.assistQueue.tail + 104) = v0;
    else
      runtime_work.assistQueue.head = v0;
    runtime_work.assistQueue.tail = v0;
    *(_DWORD *)(v0 + 104) = 0;
    runtime_internal_atomic_Loadint64();
    if ( reason != 0 && reason_4 == 0 || reason_4 > 0 )
    {
      runtime_work.assistQueue.head = head;
      runtime_work.assistQueue.tail = tail;
      if ( tail )
        *(_DWORD *)(tail + 104) = 0;
      runtime_unlock(&runtime_work.assistQueue.lock);
      return 0;
    }
    else
    {
      reasona.str = (uint8 *)"GC assist wait";
      reasona.len = 14;
      runtime_goparkunlock(&runtime_work.assistQueue.lock, reasona, 0x2Au, 2);
      return 1;
    }
  }
  else
  {
    runtime_unlock(&runtime_work.assistQueue.lock);
    return 1;
  }
}
// 805FD9E: variable 'reason_4' is possibly undefined

//----- (0805FE60) --------------------------------------------------------
void __golang runtime_gcFlushBgCredit(int64 scanWork)
{
  __int64 v1; // rcx
  int v2; // ebp
  runtime_g *head; // eax
  signed int v4; // edx
  int v5; // et0
  int v6; // ebx
  int v7; // et1
  int v8; // ebp
  unsigned __int64 v9; // kr08_8
  int v10; // ebx
  int v11; // et0
  int v12; // et1
  runtime_guintptr v13; // ecx
  signed int v14; // eax
  unsigned int v15; // edx
  uint64 next; // [esp+8h] [ebp-20h]
  int nexta; // [esp+8h] [ebp-20h]
  uint64 nextb; // [esp+8h] [ebp-20h]
  int next_4; // [esp+Ch] [ebp-1Ch]
  runtime_g *schedlink; // [esp+24h] [ebp-4h]

  if ( runtime_work.assistQueue.head )
  {
    *(double *)&next = runtime_int64tofloat64(scanWork);
    runtime_float64toint64(*(double *)&qword_81578A8 * *(double *)&next, next);
    runtime_lock(&runtime_work.assistQueue.lock);
    head = (runtime_g *)runtime_work.assistQueue.head;
    LODWORD(v1) = nexta;
    v4 = next_4;
    while ( 1 )
    {
      if ( !head )
      {
        v14 = v4;
        v15 = v1;
        v13 = 0;
        goto LABEL_10;
      }
      BYTE4(v1) = v4 == 0;
      v5 = HIDWORD(v1);
      HIDWORD(v1) = v2;
      BYTE4(v1) = (_DWORD)v1 != 0;
      v7 = HIDWORD(v1);
      v6 = v5;
      LOBYTE(v6) = v4 > 0;
      v8 = v6 | v5 & v7;
      if ( !((v4 > 0) | (unsigned __int8)(v5 & v7)) )
      {
        HIDWORD(v1) = head;
        v14 = v4;
        v15 = v1;
        v13 = HIDWORD(v1);
        goto LABEL_10;
      }
      HIDWORD(v1) = HIDWORD(head->gcAssistBytes);
      v9 = __PAIR64__(v4, head->gcAssistBytes) + v1;
      BYTE4(v1) = (__PAIR64__(v4, head->gcAssistBytes) + v1) >> 32 == 0;
      v11 = HIDWORD(v1);
      v10 = v8;
      LOBYTE(v10) = 1;
      v12 = v10;
      HIDWORD(v1) = v11;
      BYTE4(v1) = SHIDWORD(v9) > 0;
      v2 = HIDWORD(v1) | v11 & v12;
      if ( !((SHIDWORD(v9) > 0) | (unsigned __int8)(v11 & v12)) )
        break;
      LODWORD(head->gcAssistBytes) = 0;
      HIDWORD(head->gcAssistBytes) = 0;
      schedlink = (runtime_g *)head->schedlink;
      runtime_ready(head, 0, 0);
      head = schedlink;
      v4 = HIDWORD(v9);
      LODWORD(v1) = v9;
    }
    head->gcAssistBytes = v9;
    v13 = head->schedlink;
    if ( v13 )
    {
      head->schedlink = 0;
      *(_DWORD *)(runtime_work.assistQueue.tail + 104) = head;
      runtime_work.assistQueue.tail = (runtime_guintptr)head;
    }
    else
    {
      v13 = (runtime_guintptr)head;
    }
    v14 = 0;
    v15 = 0;
LABEL_10:
    runtime_work.assistQueue.head = v13;
    if ( !v13 )
      runtime_work.assistQueue.tail = 0;
    if ( v14 > 0 || v14 == 0 && v15 != 0 )
    {
      *(double *)&nextb = runtime_int64tofloat64(__SPAIR64__(v14, v15));
      runtime_float64toint64(*(double *)&qword_81578A0 * *(double *)&nextb, nextb);
      runtime_internal_atomic_Xaddint64();
    }
    runtime_unlock(&runtime_work.assistQueue.lock);
  }
  else
  {
    runtime_internal_atomic_Xaddint64();
  }
}
// 805FEDB: variable 'nexta' is possibly undefined
// 805FEDF: variable 'next_4' is possibly undefined
// 805FF38: variable 'v1' is possibly undefined
// 805FF38: variable 'v2' is possibly undefined
// 81578A0: using guessed type __int64 qword_81578A0;
// 81578A8: using guessed type __int64 qword_81578A8;

//----- (080600B0) --------------------------------------------------------
void __golang runtime_scanstack(runtime_g *gp, runtime_gcWork_0 *gcw)
{
  uint32 v2; // eax
  runtime_m *m; // ecx
  runtime_g *v4; // edx
  string pc0; // [esp+0h] [ebp-104h]
  string pc0a; // [esp+0h] [ebp-104h]
  string pc0b; // [esp+0h] [ebp-104h]
  string pc0c; // [esp+0h] [ebp-104h]
  string pc0d; // [esp+0h] [ebp-104h]
  string pc0e; // [esp+0h] [ebp-104h]
  string pc0f; // [esp+0h] [ebp-104h]
  string pc0g; // [esp+0h] [ebp-104h]
  string pc0h; // [esp+0h] [ebp-104h]
  string pc0i; // [esp+0h] [ebp-104h]
  string pc0j; // [esp+0h] [ebp-104h]
  string pc0k; // [esp+0h] [ebp-104h]
  string pc0l; // [esp+0h] [ebp-104h]
  string pc0m; // [esp+0h] [ebp-104h]
  string pc0n; // [esp+0h] [ebp-104h]
  string pc0o; // [esp+0h] [ebp-104h]
  string pc0p; // [esp+0h] [ebp-104h]
  uintptr sp0; // [esp+4h] [ebp-100h]
  uintptr sp0a; // [esp+4h] [ebp-100h]
  uintptr sp0b; // [esp+4h] [ebp-100h]
  uintptr v25; // [esp+2Ch] [ebp-D8h]
  uintptr v26; // [esp+2Ch] [ebp-D8h]
  uintptr v27; // [esp+2Ch] [ebp-D8h]
  int64 v28; // [esp+30h] [ebp-D4h]
  int64 v29; // [esp+30h] [ebp-D4h]
  int64 goid; // [esp+30h] [ebp-D4h]
  runtime_pcvalueCache_0 cache; // [esp+38h] [ebp-CCh] BYREF
  int callback[3]; // [esp+F8h] [ebp-Ch] BYREF

  while ( (unsigned int)&cache.entries[6] <= *(_DWORD *)(*(_DWORD *)(__readgsdword(0) - 4) + 12) )
    runtime_morestackc();
  if ( gp->gcscanvalid )
    return;
  if ( (runtime_readgstatus(gp) & 0x1000) == 0 )
  {
    sp0b = runtime_readgstatus(gp);
    goid = gp->goid;
    v27 = sp0b;
    runtime_printlock();
    pc0l.str = (uint8 *)"runtime:scanstack: gp=";
    pc0l.len = 22;
    runtime_printstring(pc0l);
    runtime_printpointer(gp);
    pc0m.str = (uint8 *)", goid=";
    pc0m.len = 7;
    runtime_printstring(pc0m);
    runtime_printint(goid);
    pc0n.str = (uint8 *)", gp->atomicstatus=";
    pc0n.len = 19;
    runtime_printstring(pc0n);
    runtime_printhex(v27);
    pc0o.str = (uint8 *)"\n";
    pc0o.len = 1;
    runtime_printstring(pc0o);
    runtime_printunlock();
    pc0p.str = (uint8 *)"scanstack - bad status";
    pc0p.len = 22;
    runtime_throw(pc0p);
    BUG();
  }
  v2 = runtime_readgstatus(gp) & 0xFFFFEFFF;
  if ( v2 > 2 )
  {
    if ( v2 - 3 <= 1 )
      goto LABEL_6;
    if ( v2 == 6 )
      return;
LABEL_19:
    sp0 = runtime_readgstatus(gp);
    v28 = gp->goid;
    v25 = sp0;
    runtime_printlock();
    pc0b.str = (uint8 *)"runtime: gp=";
    pc0b.len = 12;
    runtime_printstring(pc0b);
    runtime_printpointer(gp);
    pc0c.str = (uint8 *)", goid=";
    pc0c.len = 7;
    runtime_printstring(pc0c);
    runtime_printint(v28);
    pc0d.str = (uint8 *)", gp->atomicstatus=";
    pc0d.len = 19;
    runtime_printstring(pc0d);
    runtime_printint(v25);
    pc0e.str = (uint8 *)"\n";
    pc0e.len = 1;
    runtime_printstring(pc0e);
    runtime_printunlock();
    pc0f.str = (uint8 *)"mark - bad status";
    pc0f.len = 17;
    runtime_throw(pc0f);
    BUG();
  }
  if ( v2 != 1 )
  {
    if ( v2 == 2 )
    {
      sp0a = runtime_readgstatus(gp);
      v29 = gp->goid;
      v26 = sp0a;
      runtime_printlock();
      pc0g.str = (uint8 *)"runtime: gp=";
      pc0g.len = 12;
      runtime_printstring(pc0g);
      runtime_printpointer(gp);
      pc0h.str = (uint8 *)", goid=";
      pc0h.len = 7;
      runtime_printstring(pc0h);
      runtime_printint(v29);
      pc0i.str = (uint8 *)", gp->atomicstatus=";
      pc0i.len = 19;
      runtime_printstring(pc0i);
      runtime_printint(v26);
      pc0j.str = (uint8 *)"\n";
      pc0j.len = 1;
      runtime_printstring(pc0j);
      runtime_printunlock();
      pc0k.str = (uint8 *)"scanstack: goroutine not stopped";
      pc0k.len = 32;
      runtime_throw(pc0k);
      BUG();
    }
    goto LABEL_19;
  }
LABEL_6:
  if ( gp == *(runtime_g **)(__readgsdword(0) - 4) )
  {
    pc0a.str = (uint8 *)"can't scan our own stack";
    pc0a.len = 24;
    runtime_throw(pc0a);
    BUG();
  }
  m = gp->m;
  if ( m && m->helpgc )
  {
    pc0.str = (uint8 *)"can't scan gchelper stack";
    pc0.len = 25;
    runtime_throw(pc0);
    BUG();
  }
  if ( !runtime_work.markrootDone )
    runtime_shrinkstack(gp);
  ((void (*)(void))loc_808FD60)();
  callback[0] = (int)runtime_scanstack_func1;
  callback[1] = (int)&cache;
  callback[2] = (int)gcw;
  runtime_gentraceback(
    0xFFFFFFFF,
    0xFFFFFFFF,
    0,
    v4,
    0,
    0,
    0x7FFFFFFF,
    (func(_runtime_stkframe__unsafe_Pointer)_bool)callback,
    0,
    0);
  runtime_tracebackdefers(gp, (func(_runtime_stkframe__unsafe_Pointer)_bool)callback, 0);
  gp->gcscanvalid = 1;
}
// 80601E9: variable 'v4' is possibly undefined

//----- (08060530) --------------------------------------------------------
void __golang runtime_scanframeworker(runtime_stkframe *frame, runtime_pcvalueCache *cache, runtime_gcWork_0 *gcw)
{
  uintptr continpc; // ebx
  int32 v4; // eax
  runtime_stkframe *v5; // ecx
  uintptr sp; // ebx
  runtime_bitvector_0 *argmap; // edx
  runtime_bitvector_0 v8; // rax
  string f; // [esp+0h] [ebp-44h]
  string fa; // [esp+0h] [ebp-44h]
  string fb; // [esp+0h] [ebp-44h]
  string fc; // [esp+0h] [ebp-44h]
  string fd; // [esp+0h] [ebp-44h]
  string fe; // [esp+0h] [ebp-44h]
  string ff; // [esp+0h] [ebp-44h]
  string fg; // [esp+0h] [ebp-44h]
  string fh; // [esp+0h] [ebp-44h]
  string fi; // [esp+0h] [ebp-44h]
  string fj; // [esp+0h] [ebp-44h]
  string fk; // [esp+0h] [ebp-44h]
  string fl; // [esp+0h] [ebp-44h]
  string fm; // [esp+0h] [ebp-44h]
  string fn; // [esp+0h] [ebp-44h]
  string fo; // [esp+0h] [ebp-44h]
  string fp; // [esp+0h] [ebp-44h]
  string fq; // [esp+0h] [ebp-44h]
  string fr; // [esp+0h] [ebp-44h]
  string fs; // [esp+0h] [ebp-44h]
  string ft; // [esp+0h] [ebp-44h]
  string fu; // [esp+0h] [ebp-44h]
  runtime_bitvector_0 table; // [esp+8h] [ebp-3Ch]
  string tablea; // [esp+8h] [ebp-3Ch]
  string tableb; // [esp+8h] [ebp-3Ch]
  string tablec; // [esp+8h] [ebp-3Ch]
  string tabled; // [esp+8h] [ebp-3Ch]
  runtime_stackmap *v36; // [esp+Ch] [ebp-38h]
  runtime_stackmap *v37; // [esp+Ch] [ebp-38h]
  uintptr targetpc; // [esp+18h] [ebp-2Ch]
  uintptr size; // [esp+1Ch] [ebp-28h]
  int pcdata; // [esp+20h] [ebp-24h]
  uintptr arglen; // [esp+24h] [ebp-20h]
  uintptr argp; // [esp+28h] [ebp-1Ch]
  uintptr varp; // [esp+28h] [ebp-1Ch]
  int32 v; // [esp+30h] [ebp-14h]
  int32 va; // [esp+30h] [ebp-14h]
  runtime_moduledata_0 *v_4; // [esp+34h] [ebp-10h]
  runtime__func *f__func; // [esp+38h] [ebp-Ch]
  runtime_stackmap *s_4; // [esp+40h] [ebp-4h]
  runtime_stackmap *s_4a; // [esp+40h] [ebp-4h]

  continpc = frame->continpc;
  if ( continpc )
  {
    if ( continpc != frame->fn._func->entry )
      --continpc;
    targetpc = continpc;
    v_4 = frame->fn.datap;
    f__func = frame->fn._func;
    v4 = runtime_pcdatavalue(frame->fn, 0, continpc, cache);
    if ( v4 == -1 )
      v4 = 0;
    pcdata = v4;
    v5 = frame;
    sp = frame->sp;
    if ( frame->varp != sp )
    {
      size = frame->varp - sp;
      v37 = (runtime_stackmap *)runtime_funcdata(
                                  (runtime_funcInfo_0)__PAIR64__((unsigned int)v_4, (unsigned int)f__func),
                                  1);
      if ( !v37 || v37->n <= 0 )
      {
        tabled = runtime_funcname((runtime_funcInfo_0)__PAIR64__((unsigned int)v_4, (unsigned int)f__func));
        varp = frame->varp;
        runtime_printlock();
        fq.str = (uint8 *)"runtime: frame ";
        fq.len = 15;
        runtime_printstring(fq);
        runtime_printstring(tabled);
        fr.str = (uint8 *)" untyped locals ";
        fr.len = 16;
        runtime_printstring(fr);
        runtime_printhex(varp - size);
        fs.str = (uint8 *)"+";
        fs.len = 1;
        runtime_printstring(fs);
        runtime_printhex(size);
        ft.str = (uint8 *)"\n";
        ft.len = 1;
        runtime_printstring(ft);
        runtime_printunlock();
        fu.str = (uint8 *)"missing stackmap";
        fu.len = 16;
        runtime_throw(fu);
        BUG();
      }
      s_4a = v37;
      if ( pcdata < 0 || pcdata >= v37->n )
      {
        tablec = runtime_funcname((runtime_funcInfo_0)__PAIR64__((unsigned int)v_4, (unsigned int)f__func));
        va = s_4a->n;
        runtime_printlock();
        fk.str = (uint8 *)"runtime: pcdata is ";
        fk.len = 19;
        runtime_printstring(fk);
        runtime_printint(pcdata);
        fl.str = (uint8 *)" and ";
        fl.len = 5;
        runtime_printstring(fl);
        runtime_printint(va);
        fm.str = (uint8 *)" locals stack map entries for ";
        fm.len = 30;
        runtime_printstring(fm);
        runtime_printstring(tablec);
        fn.str = (uint8 *)" (targetpc=";
        fn.len = 11;
        runtime_printstring(fn);
        runtime_printint(targetpc);
        fo.str = (uint8 *)")\n";
        fo.len = 2;
        runtime_printstring(fo);
        runtime_printunlock();
        fp.str = (uint8 *)"scanframe: bad symbol table";
        fp.len = 27;
        runtime_throw(fp);
        BUG();
      }
      table = runtime_stackmapdata(v37, pcdata);
      runtime_scanblock(frame->varp - 4 * table.n, 4 * table.n, table.bytedata, gcw);
      v5 = frame;
    }
    if ( v5->arglen )
    {
      argmap = v5->argmap;
      if ( argmap )
      {
        v8 = *argmap;
      }
      else
      {
        v36 = (runtime_stackmap *)runtime_funcdata(
                                    (runtime_funcInfo_0)__PAIR64__((unsigned int)v_4, (unsigned int)f__func),
                                    0);
        if ( !v36 || v36->n <= 0 )
        {
          tableb = runtime_funcname((runtime_funcInfo_0)__PAIR64__((unsigned int)v_4, (unsigned int)f__func));
          argp = frame->argp;
          arglen = frame->arglen;
          runtime_printlock();
          ff.str = (uint8 *)"runtime: frame ";
          ff.len = 15;
          runtime_printstring(ff);
          runtime_printstring(tableb);
          fg.str = (uint8 *)" untyped args ";
          fg.len = 14;
          runtime_printstring(fg);
          runtime_printhex(argp);
          fh.str = (uint8 *)"+";
          fh.len = 1;
          runtime_printstring(fh);
          runtime_printhex(arglen);
          fi.str = (uint8 *)"\n";
          fi.len = 1;
          runtime_printstring(fi);
          runtime_printunlock();
          fj.str = (uint8 *)"missing stackmap";
          fj.len = 16;
          runtime_throw(fj);
          BUG();
        }
        s_4 = v36;
        if ( pcdata < 0 || pcdata >= v36->n )
        {
          tablea = runtime_funcname((runtime_funcInfo_0)__PAIR64__((unsigned int)v_4, (unsigned int)f__func));
          v = s_4->n;
          runtime_printlock();
          f.str = (uint8 *)"runtime: pcdata is ";
          f.len = 19;
          runtime_printstring(f);
          runtime_printint(pcdata);
          fa.str = (uint8 *)" and ";
          fa.len = 5;
          runtime_printstring(fa);
          runtime_printint(v);
          fb.str = (uint8 *)" args stack map entries for ";
          fb.len = 28;
          runtime_printstring(fb);
          runtime_printstring(tablea);
          fc.str = (uint8 *)" (targetpc=";
          fc.len = 11;
          runtime_printstring(fc);
          runtime_printint(targetpc);
          fd.str = (uint8 *)")\n";
          fd.len = 2;
          runtime_printstring(fd);
          runtime_printunlock();
          fe.str = (uint8 *)"scanframe: bad symbol table";
          fe.len = 27;
          runtime_throw(fe);
          BUG();
        }
        v8 = runtime_stackmapdata(v36, pcdata);
        v5 = frame;
      }
      runtime_scanblock(v5->argp, 4 * v8.n, v8.bytedata, gcw);
    }
  }
}
// 80E0D88: using guessed type char asc_80E0D88;

//----- (08060AE0) --------------------------------------------------------
void __golang runtime_gcDrain(runtime_gcWork_0 *gcw, runtime_gcDrainFlags flags)
{
  runtime_g *v2; // eax
  char v3; // dl
  bool v4; // zf
  unsigned int v5; // eax
  unsigned int v6; // ecx
  char v7; // al
  bool v8; // zf
  int32 v9; // edx
  uint32 v10; // ecx
  unsigned int v11; // ebx
  unsigned int v12; // ebp
  bool v13; // zf
  runtime_gcWork_0 *v14; // esi
  runtime_workbuf *wbuf1; // edi
  __int32 nobj; // ecx
  uintptr v17; // ecx
  char v18; // cl
  uint32 v19; // ebx
  unsigned int v20; // esi
  char v21; // al
  unsigned int v22; // ecx
  unsigned int v23; // edx
  uint32 v24; // ebp
  bool v25; // cf
  uint32 v26; // esi
  int scanWork_high; // ebp
  int32 v28; // edi
  string scanWork; // [esp+0h] [ebp-40h]
  int v30; // [esp+8h] [ebp-38h]
  int64 initScanWork_lo; // [esp+14h] [ebp-2Ch]
  unsigned __int64 initScanWork_loa; // [esp+14h] [ebp-2Ch]
  uint32 idleCheck_lo; // [esp+1Ch] [ebp-24h]
  int32 idleCheck_hi; // [esp+20h] [ebp-20h]
  uint32 v35; // [esp+24h] [ebp-1Ch]
  unsigned int v36; // [esp+28h] [ebp-18h]
  unsigned int v37; // [esp+2Ch] [ebp-14h]
  unsigned __int64 v38; // [esp+34h] [ebp-Ch]
  runtime_g *gp; // [esp+3Ch] [ebp-4h]

  if ( !runtime_writeBarrier.needed )
  {
    scanWork.str = (uint8 *)"gcDrain phase incorrect";
    scanWork.len = 23;
    runtime_throw(scanWork);
    BUG();
  }
  initScanWork_lo = gcw->scanWork;
  v2 = *(runtime_g **)(*(_DWORD *)(*(_DWORD *)(__readgsdword(0) - 4) + 24) + 84);
  gp = v2;
  v3 = flags;
  if ( runtime_work.markrootNext >= runtime_work.markrootJobs )
  {
    v7 = flags;
  }
  else
  {
    v4 = (flags & 1) == 0;
    while ( v4 || !v2->preempt )
    {
      runtime_internal_atomic_Xadd();
      if ( v30 - 1 >= runtime_work.markrootJobs )
      {
        v7 = flags;
        goto LABEL_18;
      }
      runtime_markroot(gcw, v30 - 1);
      if ( (flags & 8) != 0 )
      {
        if ( runtime_pollWork() )
        {
          v5 = HIDWORD(initScanWork_lo);
          v6 = initScanWork_lo;
          goto LABEL_13;
        }
        v4 = (flags & 1) == 0;
      }
      else
      {
        v4 = (flags & 1) == 0;
      }
      v2 = gp;
      v3 = flags;
    }
    v7 = v3;
  }
LABEL_18:
  v8 = (v7 & 1) == 0;
  v9 = (unsigned __int64)(initScanWork_lo + 100000) >> 32;
  v10 = initScanWork_lo + 100000;
  v11 = HIDWORD(initScanWork_lo);
  v12 = initScanWork_lo;
  while ( v8 || !gp->preempt )
  {
    idleCheck_lo = v10;
    v38 = __PAIR64__(v11, v12);
    idleCheck_hi = v9;
    if ( LODWORD(runtime_work.full) == 0 && HIDWORD(runtime_work.full) == 0 )
    {
      runtime___ptr_gcWork__balance(gcw);
      v13 = (flags & 0xB) == 0;
    }
    else
    {
      v13 = (v7 & 0xB) == 0;
    }
    if ( v13 )
    {
      v17 = runtime___ptr_gcWork__get(gcw);
      v14 = gcw;
    }
    else
    {
      v14 = gcw;
      wbuf1 = gcw->wbuf1;
      if ( gcw->wbuf1 )
      {
        nobj = wbuf1->workbufhdr.nobj;
        if ( nobj )
        {
          wbuf1->workbufhdr.nobj = nobj - 1;
          if ( (unsigned int)(nobj - 1) >= 0x1FC )
            runtime_panicindex();
          v17 = *(&wbuf1->workbufhdr.nobj + nobj);
        }
        else
        {
          v17 = 0;
        }
      }
      else
      {
        v17 = 0;
      }
      if ( !v17 )
      {
        v17 = runtime___ptr_gcWork__tryGet(gcw);
        v14 = gcw;
      }
    }
    if ( !v17 )
    {
      v5 = v11;
      v6 = v12;
      goto LABEL_13;
    }
    runtime_scanobject(v17, v14);
    if ( SHIDWORD(gcw->scanWork) > 0 || LODWORD(gcw->scanWork) >= 0x7D0 && HIDWORD(gcw->scanWork) == 0 )
    {
      runtime_internal_atomic_Xaddint64();
      v21 = flags;
      if ( (flags & 4) != 0 )
      {
        runtime_gcFlushBgCredit(gcw->scanWork - __PAIR64__(v11, v12));
        v21 = flags;
        v22 = 0;
        v23 = 0;
      }
      else
      {
        v22 = v12;
        v23 = v11;
      }
      v24 = gcw->scanWork;
      v25 = idleCheck_lo < v24;
      v26 = idleCheck_lo - v24;
      scanWork_high = HIDWORD(gcw->scanWork);
      gcw->scanWork = 0LL;
      v28 = idleCheck_hi - (v25 + scanWork_high);
      if ( (v21 & 8) != 0 )
      {
        if ( idleCheck_hi - (v25 + scanWork_high) < 0 || idleCheck_hi == v25 + scanWork_high && v26 == 0 )
        {
          v37 = v22;
          v36 = v23;
          v35 = v26;
          v26 += 100000;
          if ( runtime_pollWork() )
          {
            v5 = v36;
            v6 = v37;
            goto LABEL_13;
          }
          v8 = (flags & 1) == 0;
          v22 = v37;
          v23 = v36;
          v28 += __CFADD__(v35, 100000);
        }
        else
        {
          v8 = (v21 & 1) == 0;
        }
      }
      else
      {
        v8 = (v21 & 1) == 0;
      }
      v19 = v26;
      v12 = v22;
      v20 = v23;
      v18 = flags;
      v9 = v28;
    }
    else
    {
      v18 = flags;
      v8 = (flags & 1) == 0;
      v9 = idleCheck_hi;
      v19 = idleCheck_lo;
      v20 = HIDWORD(v38);
    }
    v7 = v18;
    v10 = v19;
    v11 = v20;
  }
  v5 = v11;
  v6 = v12;
LABEL_13:
  if ( SHIDWORD(gcw->scanWork) > 0 || HIDWORD(gcw->scanWork) == 0 && LODWORD(gcw->scanWork) != 0 )
  {
    initScanWork_loa = __PAIR64__(v5, v6);
    runtime_internal_atomic_Xaddint64();
    if ( (flags & 4) != 0 )
      runtime_gcFlushBgCredit(gcw->scanWork - initScanWork_loa);
    gcw->scanWork = 0LL;
  }
}
// 8060BB4: variable 'v30' is possibly undefined

//----- (08060FD0) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
int64 __golang runtime_gcDrainN(runtime_gcWork_0 *gcw, int64 scanWork)
{
  runtime_gcWork_0 *v2; // ecx
  int v3; // ebx
  unsigned int v4; // ebp
  runtime_g *v5; // eax
  runtime_workbuf *wbuf1; // eax
  __int32 nobj; // edx
  uintptr v8; // eax
  int v9; // eax
  int v10; // ecx
  int v11; // edx
  unsigned int v12; // ecx
  unsigned int v13; // edx
  unsigned __int64 v14; // kr00_8
  string b; // [esp+0h] [ebp-20h]
  int scanWork_high; // [esp+8h] [ebp-18h]
  runtime_g *gp; // [esp+1Ch] [ebp-4h]

  if ( !runtime_writeBarrier.needed )
  {
    b.str = (uint8 *)"gcDrainN phase incorrect";
    b.len = 24;
    runtime_throw(b);
    BUG();
  }
  v2 = gcw;
  v3 = -LODWORD(gcw->scanWork);
  v4 = (unsigned __int64)-gcw->scanWork >> 32;
  v5 = *(runtime_g **)(*(_DWORD *)(*(_DWORD *)(__readgsdword(0) - 4) + 24) + 84);
  gp = v5;
  while ( !v5->preempt
       && ((int)((__PAIR64__(v4, v3) + v2->scanWork) >> 32) < SHIDWORD(scanWork)) | (v3 + LODWORD(v2->scanWork) < (unsigned int)scanWork) & ((__PAIR64__(v4, v3) + v2->scanWork) >> 32 == HIDWORD(scanWork)) )
  {
    if ( LODWORD(runtime_work.full) == 0 && HIDWORD(runtime_work.full) == 0 )
    {
      runtime___ptr_gcWork__balance(v2);
      v2 = gcw;
    }
    wbuf1 = v2->wbuf1;
    if ( v2->wbuf1 )
    {
      nobj = wbuf1->workbufhdr.nobj;
      if ( nobj )
      {
        wbuf1->workbufhdr.nobj = nobj - 1;
        if ( (unsigned int)(nobj - 1) >= 0x1FC )
          runtime_panicindex();
        v8 = *(&wbuf1->workbufhdr.nobj + nobj);
      }
      else
      {
        v8 = 0;
      }
    }
    else
    {
      v8 = 0;
    }
    if ( !v8 )
    {
      v8 = runtime___ptr_gcWork__tryGet(v2);
      v2 = gcw;
    }
    if ( v8 )
    {
      runtime_scanobject(v8, v2);
      if ( SHIDWORD(gcw->scanWork) > 0 || HIDWORD(gcw->scanWork) == 0 && LODWORD(gcw->scanWork) >= 0x7D0 )
      {
        scanWork_high = HIDWORD(gcw->scanWork);
        runtime_internal_atomic_Xaddint64();
        v12 = gcw->scanWork;
        v13 = HIDWORD(gcw->scanWork);
        gcw->scanWork = 0LL;
        v14 = __PAIR64__(v4, v3) + __PAIR64__(v13, v12);
        v11 = (__PAIR64__(v4, v3) + __PAIR64__(v13, v12)) >> 32;
        v10 = v14;
      }
      else
      {
        v10 = v3;
        v11 = v4;
      }
      v9 = v11;
    }
    else
    {
      if ( runtime_work.markrootNext >= runtime_work.markrootJobs )
        return gcw->scanWork + __PAIR64__(v4, v3);
      runtime_internal_atomic_Xadd();
      if ( scanWork_high - 1 >= runtime_work.markrootJobs )
        return gcw->scanWork + __PAIR64__(v4, v3);
      runtime_markroot(gcw, scanWork_high - 1);
      v9 = v4;
      v10 = v3;
    }
    v4 = v9;
    v3 = v10;
    v5 = gp;
    v2 = gcw;
  }
  return gcw->scanWork + __PAIR64__(v4, v3);
}
// 8060FD0: variables would overlap: ^30.8 and ^30.12

//----- (08061240) --------------------------------------------------------
void __golang runtime_scanblock(uintptr b0, uintptr n0, uint8 *ptrmask, runtime_gcWork_0 *gcw)
{
  unsigned int v4; // eax
  unsigned int v5; // ecx
  uintptr v6; // edx
  uintptr v7; // ebx
  uintptr refOff; // ebp
  uint32 v9; // edx
  int i; // edi
  uintptr p; // esi
  uintptr hbits; // [esp+Ch] [ebp-28h]
  runtime_heapBits_0 hbits_4; // [esp+10h] [ebp-24h]
  runtime_mspan *span; // [esp+18h] [ebp-1Ch]
  uintptr objIndex; // [esp+1Ch] [ebp-18h]
  uint32 bits; // [esp+28h] [ebp-Ch]
  uintptr arena_used; // [esp+2Ch] [ebp-8h]
  uintptr arena_start; // [esp+30h] [ebp-4h]

  v4 = dword_81493A8;
  arena_start = dword_81493A8;
  v5 = dword_81493AC;
  arena_used = dword_81493AC;
  v6 = 0;
  while ( 1 )
  {
    v7 = n0;
    if ( v6 >= n0 )
      break;
    refOff = v6;
    v9 = ptrmask[v6 >> 5];
    if ( v9 )
    {
      for ( i = 0; i < 8 && refOff < v7; ++i )
      {
        if ( (v9 & 1) != 0 )
        {
          p = *(_DWORD *)(refOff + b0);
          if ( p )
          {
            if ( v4 <= p && p < v5 )
            {
              bits = v9;
              runtime_heapBitsForObject(p, b0, refOff, hbits, hbits_4, span, objIndex);
              if ( hbits )
                runtime_greyobject(hbits, b0, refOff, hbits_4, span, gcw, objIndex);
              v4 = arena_start;
              v5 = arena_used;
              v9 = bits;
              v7 = n0;
            }
          }
        }
        v9 >>= 1;
        refOff += 4;
      }
      v6 = refOff;
    }
    else
    {
      v6 = refOff + 32;
    }
  }
}
// 80612EA: variable 'hbits' is possibly undefined
// 80612EA: variable 'hbits_4' is possibly undefined
// 80612EA: variable 'span' is possibly undefined
// 80612EA: variable 'objIndex' is possibly undefined
// 81493A8: using guessed type int dword_81493A8;
// 81493AC: using guessed type int dword_81493AC;

//----- (08061370) --------------------------------------------------------
void __golang runtime_scanobject(uintptr b, runtime_gcWork_0 *gcw)
{
  uintptr refBase; // ebp
  unsigned __int8 *v3; // ebx
  uintptr v4; // edi
  __int64 v5; // rax
  unsigned int v6; // esi
  uintptr i; // esi
  runtime_workbuf *wbuf1; // edi
  unsigned int nobj; // ebx
  char v10; // bl
  unsigned int v11; // edx
  uintptr refOff; // esi
  unsigned int v13; // ecx
  int v14; // edi
  unsigned int v15; // edi
  int64 scanWork; // rax
  int bytesMarked; // ecx
  int bytesMarked_high; // edx
  string w; // [esp+0h] [ebp-4Ch]
  uintptr hbits; // [esp+Ch] [ebp-40h]
  runtime_heapBits_0 hbits_4; // [esp+10h] [ebp-3Ch]
  runtime_mspan *span; // [esp+18h] [ebp-34h]
  uintptr objIndex; // [esp+1Ch] [ebp-30h]
  uintptr n; // [esp+28h] [ebp-24h]
  uintptr arena_start; // [esp+30h] [ebp-1Ch]
  unsigned int v26; // [esp+34h] [ebp-18h]
  unsigned int v27; // [esp+38h] [ebp-14h]
  uintptr v28; // [esp+3Ch] [ebp-10h]
  runtime_mspan *s; // [esp+40h] [ebp-Ch]
  uintptr v30; // [esp+48h] [ebp-4h]

  refBase = b;
  v28 = b - dword_81493A8;
  v3 = (unsigned __int8 *)(dword_81493A0 - ((b - dword_81493A8) >> 4) - 1);
  v4 = (b - dword_81493A8) >> 13;
  if ( v4 >= dword_814910C )
    runtime_panicindex();
  HIDWORD(v5) = *(_DWORD *)(dword_8149108 + 4 * v4);
  v6 = *(_DWORD *)(HIDWORD(v5) + 64);
  if ( !v6 )
  {
    w.str = (uint8 *)"scanobject n == 0";
    w.len = 17;
    runtime_throw(w);
    BUG();
  }
  arena_start = dword_81493A8;
  v27 = dword_81493AC;
  if ( v6 <= 0x20000 )
  {
    LODWORD(v5) = *(_DWORD *)(HIDWORD(v5) + 64);
  }
  else
  {
    if ( b == *(_DWORD *)(HIDWORD(v5) + 12) )
    {
      if ( (*(_BYTE *)(HIDWORD(v5) + 58) & 1) != 0 )
      {
        bytesMarked = gcw->bytesMarked;
        bytesMarked_high = HIDWORD(gcw->bytesMarked);
        LODWORD(gcw->bytesMarked) = v6 + bytesMarked;
        HIDWORD(gcw->bytesMarked) = __CFADD__(v6, bytesMarked) + bytesMarked_high;
        return;
      }
      v30 = dword_81493A0 - ((b - dword_81493A8) >> 4) - 1;
      s = *(runtime_mspan **)(dword_8149108 + 4 * v4);
      for ( i = b + 0x20000; i < *(_DWORD *)(HIDWORD(v5) + 64) + *(_DWORD *)(HIDWORD(v5) + 12); i += 0x20000 )
      {
        wbuf1 = gcw->wbuf1;
        if ( gcw->wbuf1 )
        {
          nobj = wbuf1->workbufhdr.nobj;
          if ( nobj == 508 )
          {
            v10 = 0;
          }
          else
          {
            if ( nobj >= 0x1FC )
              runtime_panicindex();
            wbuf1->obj[nobj] = i;
            ++wbuf1->workbufhdr.nobj;
            v10 = 1;
          }
        }
        else
        {
          v10 = 0;
        }
        if ( !v10 )
        {
          runtime___ptr_gcWork__put(gcw, i);
          HIDWORD(v5) = s;
          refBase = b;
        }
        v3 = (unsigned __int8 *)v30;
      }
    }
    LODWORD(v5) = *(_DWORD *)(HIDWORD(v5) + 12) + *(_DWORD *)(HIDWORD(v5) + 64) - refBase;
    if ( (unsigned int)v5 > 0x20000 )
      LODWORD(v5) = 0x20000;
  }
  n = v5;
  v11 = (v28 >> 2) & 3;
  for ( refOff = 0; refOff < (unsigned int)v5; refOff += 4 )
  {
    if ( refOff )
    {
      if ( v11 >= 3 )
      {
        --v3;
        v11 = 0;
      }
      else
      {
        ++v11;
      }
    }
    v13 = v11;
    v14 = *v3 >> v11;
    if ( refOff != 4 && (v14 & 0x10) == 0 )
      break;
    if ( (v14 & 1) != 0 )
    {
      v15 = *(_DWORD *)(refOff + refBase);
      if ( v15 && arena_start <= v15 && v15 < v27 && v15 - refBase >= (unsigned int)v5 )
      {
        v26 = v11;
        runtime_heapBitsForObject(*(_DWORD *)(refOff + refBase), refBase, refOff, hbits, hbits_4, span, objIndex);
        if ( hbits )
          runtime_greyobject(hbits, b, refOff, hbits_4, span, gcw, objIndex);
        LODWORD(v5) = n;
        v13 = v26;
        refBase = b;
      }
      v11 = v13;
    }
  }
  HIDWORD(v5) = HIDWORD(gcw->bytesMarked);
  gcw->bytesMarked = v5 + LODWORD(gcw->bytesMarked);
  scanWork = gcw->scanWork;
  LODWORD(gcw->scanWork) = refOff + scanWork;
  HIDWORD(gcw->scanWork) = __CFADD__(refOff, (_DWORD)scanWork) + HIDWORD(scanWork);
}
// 806153E: variable 'hbits' is possibly undefined
// 806153E: variable 'hbits_4' is possibly undefined
// 806153E: variable 'span' is possibly undefined
// 806153E: variable 'objIndex' is possibly undefined
// 8149108: using guessed type int dword_8149108;
// 814910C: using guessed type int dword_814910C;
// 81493A0: using guessed type int dword_81493A0;
// 81493A8: using guessed type int dword_81493A8;
// 81493AC: using guessed type int dword_81493AC;

//----- (08061640) --------------------------------------------------------
void __golang runtime_shade(uintptr b)
{
  uintptr hbits; // [esp+Ch] [ebp-18h]
  uintptr hbitsa; // [esp+Ch] [ebp-18h]
  runtime_heapBits_0 hbits_4; // [esp+10h] [ebp-14h]
  runtime_heapBits_0 hbits_4a; // [esp+10h] [ebp-14h]
  runtime_mspan *v5; // [esp+18h] [ebp-Ch]
  runtime_mspan *span; // [esp+18h] [ebp-Ch]
  uintptr objIndex; // [esp+1Ch] [ebp-8h]
  uintptr objIndexa; // [esp+1Ch] [ebp-8h]
  runtime_gcWork_0 *gcw; // [esp+20h] [ebp-4h]

  runtime_heapBitsForObject(b, 0, 0, hbits, hbits_4, v5, objIndex);
  if ( hbitsa )
  {
    gcw = (runtime_gcWork_0 *)(*(_DWORD *)(*(_DWORD *)(*(_DWORD *)(__readgsdword(0) - 4) + 24) + 92) + 2384);
    runtime_greyobject(hbitsa, 0, 0, hbits_4a, span, gcw, objIndexa);
    if ( runtime_gcphase == 2 || runtime_gcBlackenPromptly )
      runtime___ptr_gcWork__dispose(gcw);
  }
}
// 8061640: could not find valid save-restore pair for ebx
// 8061640: could not find valid save-restore pair for ebp
// 8061670: variable 'hbits' is possibly undefined
// 8061670: variable 'hbits_4' is possibly undefined
// 8061670: variable 'v5' is possibly undefined
// 8061670: variable 'objIndex' is possibly undefined
// 806168B: variable 'hbitsa' is possibly undefined
// 80616D9: variable 'hbits_4a' is possibly undefined
// 80616D9: variable 'span' is possibly undefined
// 80616D9: variable 'objIndexa' is possibly undefined

//----- (08061710) --------------------------------------------------------
void __golang runtime_greyobject(
        uintptr obj,
        uintptr base,
        uintptr off,
        runtime_heapBits_0 hbits,
        runtime_mspan *span,
        runtime_gcWork_0 *gcw,
        uintptr objIndex)
{
  int v7; // eax
  runtime_gcBits *v8; // ebp
  uintptr size; // eax
  bool v10; // bp
  bool v11; // al
  runtime_workbuf *wbuf1; // ecx
  unsigned int nobj; // edx
  char v14; // cl
  string h; // [esp+0h] [ebp-14h]
  string ha; // [esp+0h] [ebp-14h]
  string hb; // [esp+0h] [ebp-14h]
  string hc; // [esp+0h] [ebp-14h]
  string hd; // [esp+0h] [ebp-14h]
  string he; // [esp+0h] [ebp-14h]
  string hf; // [esp+0h] [ebp-14h]
  string hg; // [esp+0h] [ebp-14h]
  string hh; // [esp+0h] [ebp-14h]
  string hi; // [esp+0h] [ebp-14h]
  string hj; // [esp+0h] [ebp-14h]
  string hk; // [esp+0h] [ebp-14h]
  string hl; // [esp+0h] [ebp-14h]
  string hm; // [esp+0h] [ebp-14h]
  string hn; // [esp+0h] [ebp-14h]
  string ho; // [esp+0h] [ebp-14h]
  string hp; // [esp+0h] [ebp-14h]

  if ( (obj & 3) != 0 )
  {
    hp.str = (uint8 *)"greyobject: obj not pointer-aligned";
    hp.len = 35;
    runtime_throw(hp);
    BUG();
  }
  v7 = 1 << (objIndex & 7);
  v8 = &span->gcmarkBits[objIndex >> 3];
  if ( runtime_useCheckmark )
  {
    if ( ((unsigned __int8)v7 & *v8) == 0 )
    {
      runtime_printlock();
      runtime_printlock();
      hh.str = (uint8 *)"runtime:greyobject: checkmarks finds unexpected unmarked object o";
      hh.len = 68;
      runtime_printstring(hh);
      runtime_printhex(obj);
      hi.str = (uint8 *)"\n";
      hi.len = 1;
      runtime_printstring(hi);
      runtime_printunlock();
      runtime_printlock();
      hj.str = (uint8 *)"runtime: found obj at *(";
      hj.len = 24;
      runtime_printstring(hj);
      runtime_printhex(base);
      hk.str = (uint8 *)"+";
      hk.len = 1;
      runtime_printstring(hk);
      runtime_printhex(off);
      hl.str = (uint8 *)")\n";
      hl.len = 2;
      runtime_printstring(hl);
      runtime_printunlock();
      hm.str = (uint8 *)"base";
      hm.len = 4;
      runtime_gcDumpObject(hm, base, off);
      hn.str = (uint8 *)"obj";
      hn.len = 3;
      runtime_gcDumpObject(hn, obj, 0xFFFFFFFF);
      *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(__readgsdword(0) - 4) + 24) + 461) = 2;
      ho.str = (uint8 *)"checkmark found unmarked object";
      ho.len = 31;
      runtime_throw(ho);
      BUG();
    }
    if ( span->elemsize == 4 )
    {
      size = 4;
      v10 = ((unsigned __int8)-(hbits.shift < 8) & (unsigned __int8)(*hbits.bitp >> SLOBYTE(hbits.shift)) & 1) != 0;
    }
    else
    {
      size = span->elemsize;
      v10 = ((unsigned __int8)-(hbits.shift + 1 < 8) & (unsigned __int8)(*hbits.bitp >> (LOBYTE(hbits.shift) + 1)) & 0x10) != 0;
    }
    if ( !v10 )
    {
      runtime_heapBits_setCheckmarked(hbits, size);
      if ( span->elemsize == 4 )
        v11 = ((unsigned __int8)-(hbits.shift < 8) & (unsigned __int8)(*hbits.bitp >> SLOBYTE(hbits.shift)) & 1) != 0;
      else
        v11 = ((unsigned __int8)-(hbits.shift + 1 < 8) & (unsigned __int8)(*hbits.bitp >> (LOBYTE(hbits.shift) + 1)) & 0x10) != 0;
      if ( !v11 )
      {
        hg.str = (uint8 *)"setCheckmarked and isCheckmarked disagree";
        hg.len = 41;
        runtime_throw(hg);
        BUG();
      }
LABEL_10:
      wbuf1 = gcw->wbuf1;
      if ( gcw->wbuf1 )
      {
        nobj = wbuf1->workbufhdr.nobj;
        if ( nobj == 508 )
        {
          v14 = 0;
        }
        else
        {
          if ( nobj >= 0x1FC )
            runtime_panicindex();
          wbuf1->obj[nobj] = obj;
          ++wbuf1->workbufhdr.nobj;
          v14 = 1;
        }
      }
      else
      {
        v14 = 0;
      }
      if ( !v14 )
        runtime___ptr_gcWork__put(gcw, obj);
    }
  }
  else
  {
    if ( runtime_debug.gccheckmark > 0
      && objIndex >= span->freeindex
      && (span->allocBits[objIndex >> 3] & (unsigned __int8)v7) == 0 )
    {
      runtime_printlock();
      h.str = (uint8 *)"runtime: marking free object ";
      h.len = 29;
      runtime_printstring(h);
      runtime_printhex(obj);
      ha.str = (uint8 *)" found at *(";
      ha.len = 12;
      runtime_printstring(ha);
      runtime_printhex(base);
      hb.str = (uint8 *)"+";
      hb.len = 1;
      runtime_printstring(hb);
      runtime_printhex(off);
      hc.str = (uint8 *)")\n";
      hc.len = 2;
      runtime_printstring(hc);
      runtime_printunlock();
      hd.str = (uint8 *)"base";
      hd.len = 4;
      runtime_gcDumpObject(hd, base, off);
      he.str = (uint8 *)"obj";
      he.len = 3;
      runtime_gcDumpObject(he, obj, 0xFFFFFFFF);
      *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(__readgsdword(0) - 4) + 24) + 461) = 2;
      hf.str = (uint8 *)"marking free object";
      hf.len = 19;
      runtime_throw(hf);
      BUG();
    }
    if ( ((unsigned __int8)v7 & *v8) == 0 )
    {
      runtime_internal_atomic_Or8();
      if ( (span->spanclass & 1) != 0 )
      {
        gcw->bytesMarked += span->elemsize;
        return;
      }
      goto LABEL_10;
    }
  }
}
// 80E0D88: using guessed type char asc_80E0D88;

//----- (08061B90) --------------------------------------------------------
void __golang runtime_gcDumpObject(string label, uintptr obj, uintptr off)
{
  uintptr v3; // ecx
  unsigned __int8 v4; // cl
  string *v5; // eax
  uintptr v6; // ecx
  uintptr v7; // eax
  unsigned int v8; // edx
  char v9; // bl
  string s; // [esp+0h] [ebp-30h]
  string sa; // [esp+0h] [ebp-30h]
  string sb; // [esp+0h] [ebp-30h]
  string sc; // [esp+0h] [ebp-30h]
  string sd; // [esp+0h] [ebp-30h]
  string se; // [esp+0h] [ebp-30h]
  string sf; // [esp+0h] [ebp-30h]
  string sg; // [esp+0h] [ebp-30h]
  string si; // [esp+0h] [ebp-30h]
  string sj; // [esp+0h] [ebp-30h]
  string sk; // [esp+0h] [ebp-30h]
  string sm; // [esp+0h] [ebp-30h]
  string sl; // [esp+0h] [ebp-30h]
  string sh; // [esp+0h] [ebp-30h]
  string sn; // [esp+0h] [ebp-30h]
  string so; // [esp+0h] [ebp-30h]
  string sp; // [esp+0h] [ebp-30h]
  string sq; // [esp+0h] [ebp-30h]
  string sr; // [esp+0h] [ebp-30h]
  string ss; // [esp+0h] [ebp-30h]
  unsigned __int8 v30; // [esp+Bh] [ebp-25h]
  uintptr _r0; // [esp+Ch] [ebp-24h]
  uintptr size; // [esp+10h] [ebp-20h]
  uintptr i; // [esp+14h] [ebp-1Ch]
  __int32 len; // [esp+18h] [ebp-18h]
  unsigned int v; // [esp+1Ch] [ebp-14h]
  unsigned int v_4; // [esp+20h] [ebp-10h]
  unsigned int v37; // [esp+24h] [ebp-Ch]
  unsigned int v38; // [esp+24h] [ebp-Ch]
  int v39; // [esp+28h] [ebp-8h]
  uint8 *str; // [esp+2Ch] [ebp-4h]

  if ( obj < dword_81493A8 || obj >= dword_81493AC )
  {
    runtime_printlock();
    runtime_printstring(label);
    sr.str = (uint8 *)"=";
    sr.len = 1;
    runtime_printstring(sr);
    runtime_printhex(obj);
    ss.str = (uint8 *)" is not in the Go heap\n";
    ss.len = 23;
    runtime_printstring(ss);
    runtime_printunlock();
  }
  else
  {
    v3 = (obj >> 13) - ((unsigned int)dword_81493A8 >> 13);
    if ( v3 >= dword_814910C )
      runtime_panicindex();
    v39 = *(_DWORD *)(dword_8149108 + 4 * v3);
    runtime_printlock();
    runtime_printstring(label);
    s.str = (uint8 *)"=";
    s.len = 1;
    runtime_printstring(s);
    runtime_printhex(obj);
    sa.str = (uint8 *)" k=";
    sa.len = 3;
    runtime_printstring(sa);
    runtime_printhex(obj >> 13);
    runtime_printunlock();
    if ( v39 )
    {
      v_4 = *(unsigned __int8 *)(v39 + 58);
      v37 = *(_DWORD *)(v39 + 80);
      v = *(_DWORD *)(v39 + 64);
      _r0 = *(_DWORD *)(v39 + 12);
      runtime_printlock();
      sb.str = (uint8 *)" s.base()=";
      sb.len = 10;
      runtime_printstring(sb);
      runtime_printhex(_r0);
      sc.str = (uint8 *)" s.limit=";
      sc.len = 9;
      runtime_printstring(sc);
      runtime_printhex(v37);
      sd.str = (uint8 *)" s.spanclass=";
      sd.len = 13;
      runtime_printstring(sd);
      runtime_printint(v_4);
      se.str = (uint8 *)" s.elemsize=";
      se.len = 12;
      runtime_printstring(se);
      runtime_printint(v);
      sf.str = (uint8 *)" s.state=";
      sf.len = 9;
      runtime_printstring(sf);
      runtime_printunlock();
      v4 = *(_BYTE *)(v39 + 60);
      v30 = v4;
      if ( v4 >= runtime_mSpanStateNames.len )
      {
        runtime_printlock();
        so.str = (uint8 *)"unknown(";
        so.len = 8;
        runtime_printstring(so);
        runtime_printint(v30);
        sp.str = (uint8 *)")\n";
        sp.len = 2;
        runtime_printstring(sp);
        runtime_printunlock();
      }
      else
      {
        if ( (unsigned int)v4 >= runtime_mSpanStateNames.len )
          runtime_panicindex();
        v5 = &runtime_mSpanStateNames.array[v4];
        len = v5->len;
        str = v5->str;
        runtime_printlock();
        runtime_printstring((string)__PAIR64__(len, (unsigned int)str));
        sg.str = (uint8 *)"\n";
        sg.len = 1;
        runtime_printstring(sg);
        runtime_printunlock();
      }
      v6 = *(_DWORD *)(v39 + 64);
      if ( *(_BYTE *)(v39 + 60) != 2 || v6 )
      {
        v7 = off;
      }
      else
      {
        v7 = off;
        v6 = off + 4;
      }
      size = v6;
      v8 = 0;
      v9 = 0;
      while ( v8 < v6 )
      {
        if ( v8 < 0x200 || v7 - 64 < v8 && v8 < v7 + 64 )
        {
          i = v8;
          if ( v9 )
          {
            runtime_printlock();
            sh.str = (uint8 *)" ...\n";
            sh.len = 5;
            runtime_printstring(sh);
            runtime_printunlock();
            v8 = i;
          }
          v38 = *(_DWORD *)(v8 + obj);
          runtime_printlock();
          si.str = (uint8 *)" *(";
          si.len = 3;
          runtime_printstring(si);
          runtime_printstring(label);
          sj.str = (uint8 *)"+";
          sj.len = 1;
          runtime_printstring(sj);
          runtime_printint(i);
          sk.str = (uint8 *)") = ";
          sk.len = 4;
          runtime_printstring(sk);
          runtime_printhex(v38);
          runtime_printunlock();
          if ( i == off )
          {
            runtime_printlock();
            sl.str = (uint8 *)" <==";
            sl.len = 4;
            runtime_printstring(sl);
            runtime_printunlock();
          }
          runtime_printlock();
          sm.str = (uint8 *)"\n";
          sm.len = 1;
          runtime_printstring(sm);
          runtime_printunlock();
          v7 = off;
          v6 = size;
          v8 = i;
          v9 = 0;
        }
        else
        {
          v9 = 1;
        }
        v8 += 4;
      }
      if ( v9 )
      {
        runtime_printlock();
        sn.str = (uint8 *)" ...\n";
        sn.len = 5;
        runtime_printstring(sn);
        runtime_printunlock();
      }
    }
    else
    {
      runtime_printlock();
      sq.str = (uint8 *)" s=nil\n";
      sq.len = 7;
      runtime_printstring(sq);
      runtime_printunlock();
    }
  }
}
// 80E0D88: using guessed type char asc_80E0D88;
// 80E0D91: using guessed type char asc_80E0D91;
// 8149108: using guessed type int dword_8149108;
// 814910C: using guessed type int dword_814910C;
// 81493A8: using guessed type int dword_81493A8;
// 81493AC: using guessed type int dword_81493AC;

//----- (08062070) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
void __golang runtime_gcmarknewobject(uintptr obj, uintptr size, uintptr scanSize)
{
  int v3; // ecx
  int v4; // eax
  int v5; // ebx
  int v6; // eax
  int v7; // ebx
  uint8 *p; // [esp+0h] [ebp-10h]
  string pa; // [esp+0h] [ebp-10h]
  runtime_markBits_0 m; // [esp+4h] [ebp-Ch] OVERLAPPED

  if ( runtime_useCheckmark && !runtime_gcBlackenPromptly )
  {
    pa.str = (uint8 *)"gcmarknewobject called while doing checkmark";
    pa.len = 44;
    runtime_throw(pa);
    BUG();
  }
  m = runtime_markBitsForAddr(obj);
  p = m.bytep;
  LOBYTE(m.bytep) = m.mask;
  *(_DWORD *)&m.mask = m.index;
  runtime_markBits_setMarked(*(runtime_markBits_0 *)((char *)&m - 4));
  v3 = *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(__readgsdword(0) - 4) + 24) + 92);
  v4 = *(_DWORD *)(v3 + 2392);
  v5 = *(_DWORD *)(v3 + 2396);
  *(_DWORD *)(v3 + 2392) = size + v4;
  *(_DWORD *)(v3 + 2396) = __CFADD__(size, v4) + v5;
  v6 = *(_DWORD *)(v3 + 2400);
  v7 = *(_DWORD *)(v3 + 2404);
  *(_DWORD *)(v3 + 2400) = scanSize + v6;
  *(_DWORD *)(v3 + 2404) = __CFADD__(scanSize, v6) + v7;
  if ( runtime_gcBlackenPromptly )
    runtime___ptr_gcWork__dispose((runtime_gcWork_0 *)(v3 + 2384));
}
// 8062095: failed to expand linear variable ^4.12

//----- (08062150) --------------------------------------------------------
void __golang runtime_gcMarkTinyAllocs()
{
  int v0; // eax
  runtime_p **i; // ecx
  runtime_p *v2; // edx
  runtime_mcache *mcache; // ebx
  uintptr tiny; // ebp
  uintptr hbits; // [esp+Ch] [ebp-28h]
  runtime_heapBits_0 hbits_4; // [esp+10h] [ebp-24h]
  runtime_heapBits_0 hbits_4a; // [esp+10h] [ebp-24h]
  runtime_mspan *v8; // [esp+18h] [ebp-1Ch]
  runtime_mspan *span; // [esp+18h] [ebp-1Ch]
  uintptr objIndex; // [esp+1Ch] [ebp-18h]
  uintptr objIndexa; // [esp+1Ch] [ebp-18h]
  int v12; // [esp+20h] [ebp-14h]
  runtime_p *p; // [esp+24h] [ebp-10h]
  runtime_mcache *c; // [esp+2Ch] [ebp-8h]
  runtime_p **v15; // [esp+30h] [ebp-4h]

  v0 = 0;
  for ( i = runtime_allp; v0 < 1025; ++i )
  {
    v2 = *i;
    if ( !*i || v2->status == 4 )
      break;
    mcache = v2->mcache;
    if ( mcache )
    {
      tiny = mcache->tiny;
      if ( tiny )
      {
        v12 = v0;
        p = *i;
        c = v2->mcache;
        v15 = i;
        runtime_heapBitsForObject(tiny, 0, 0, hbits, hbits_4, v8, objIndex);
        runtime_greyobject(c->tiny, 0, 0, hbits_4a, span, &p->gcw, objIndexa);
        if ( runtime_gcBlackenPromptly )
          runtime___ptr_gcWork__dispose(&p->gcw);
        v0 = v12;
        i = v15;
      }
    }
    ++v0;
  }
}
// 80621C9: variable 'hbits' is possibly undefined
// 80621C9: variable 'hbits_4' is possibly undefined
// 80621C9: variable 'v8' is possibly undefined
// 80621C9: variable 'objIndex' is possibly undefined
// 8062219: variable 'hbits_4a' is possibly undefined
// 8062219: variable 'span' is possibly undefined
// 8062219: variable 'objIndexa' is possibly undefined

//----- (08062260) --------------------------------------------------------
void __golang runtime_initCheckmarks()
{
  int v0; // eax
  int v1; // ecx
  int i; // edx
  runtime_mspan *v3; // ebx
  uintptr total; // ebx
  uintptr elemsize; // edx
  uintptr v6; // esi
  int n; // eax
  runtime_heapBits_0 h; // [esp+4h] [ebp-20h]
  runtime_heapBits_0 ha; // [esp+4h] [ebp-20h]
  int v10; // [esp+14h] [ebp-10h]
  int v11; // [esp+18h] [ebp-Ch]
  runtime_mspan *s; // [esp+1Ch] [ebp-8h]
  int v13; // [esp+20h] [ebp-4h]

  runtime_useCheckmark = 1;
  v0 = dword_81490FC;
  v1 = dword_8149100;
  v11 = dword_8149100;
  for ( i = 0; i < v1; ++i )
  {
    v3 = *(runtime_mspan **)v0;
    if ( *(_BYTE *)(*(_DWORD *)v0 + 60) == 1 )
    {
      v10 = i;
      s = *(runtime_mspan **)v0;
      v13 = v0;
      runtime_heapBitsForSpan(v3->startAddr, h);
      total = v3->npages << 13;
      elemsize = s->elemsize;
      if ( elemsize )
      {
        v6 = s->elemsize;
        n = total / elemsize;
      }
      else
      {
        v6 = 0;
        n = 0;
      }
      runtime_heapBits_initCheckmarkSpan(ha, v6, n, total);
      v0 = v13;
      v1 = v11;
      i = v10;
    }
    v0 += 4;
  }
}
// 80622BB: variable 'h' is possibly undefined
// 80622F6: variable 'ha' is possibly undefined
// 81490FC: using guessed type int dword_81490FC;
// 8149100: using guessed type int dword_8149100;

//----- (08062320) --------------------------------------------------------
void __golang runtime_clearCheckmarks()
{
  int v0; // eax
  int v1; // ecx
  int i; // edx
  runtime_mspan *v3; // ebx
  uintptr total; // ebx
  uintptr elemsize; // edx
  uintptr v6; // esi
  int n; // eax
  runtime_heapBits_0 h; // [esp+4h] [ebp-20h]
  runtime_heapBits_0 ha; // [esp+4h] [ebp-20h]
  int v10; // [esp+14h] [ebp-10h]
  int v11; // [esp+18h] [ebp-Ch]
  runtime_mspan *s; // [esp+1Ch] [ebp-8h]
  int v13; // [esp+20h] [ebp-4h]

  runtime_useCheckmark = 0;
  v0 = dword_81490FC;
  v1 = dword_8149100;
  v11 = dword_8149100;
  for ( i = 0; i < v1; ++i )
  {
    v3 = *(runtime_mspan **)v0;
    if ( *(_BYTE *)(*(_DWORD *)v0 + 60) == 1 )
    {
      v10 = i;
      s = *(runtime_mspan **)v0;
      v13 = v0;
      runtime_heapBitsForSpan(v3->startAddr, h);
      total = v3->npages << 13;
      elemsize = s->elemsize;
      if ( elemsize )
      {
        v6 = s->elemsize;
        n = total / elemsize;
      }
      else
      {
        v6 = 0;
        n = 0;
      }
      runtime_heapBits_clearCheckmarkSpan(ha, v6, n, total);
      v0 = v13;
      v1 = v11;
      i = v10;
    }
    v0 += 4;
  }
}
// 806237B: variable 'h' is possibly undefined
// 80623B6: variable 'ha' is possibly undefined
// 81490FC: using guessed type int dword_81490FC;
// 8149100: using guessed type int dword_8149100;

//----- (080623E0) --------------------------------------------------------
void __golang runtime_finishsweep_m()
{
  while ( runtime_sweepone() != -1 )
    ++runtime_sweep.npausesweep;
  runtime_nextMarkBitArenaEpoch();
}

//----- (08062430) --------------------------------------------------------
void __golang __noreturn runtime_bgsweep(chan_int c)
{
  runtime_g *v1; // ecx
  string elem; // [esp+4h] [ebp-10h]
  string elema; // [esp+4h] [ebp-10h]

  v1 = *(runtime_g **)(__readgsdword(0) - 4);
  if ( *(_DWORD *)&runtime_writeBarrier.enabled )
    runtime_writebarrierptr((uintptr *)&runtime_sweep.g, (uintptr)v1);
  else
    runtime_sweep.g = v1;
  runtime_lock(&runtime_sweep.lock);
  runtime_sweep.parked = 1;
  runtime_chansend1((runtime_hchan *)c, &runtime_statictmp_15);
  elem.str = (uint8 *)"GC sweep wait";
  elem.len = 13;
  runtime_goparkunlock(&runtime_sweep.lock, elem, 0x14u, 1);
  while ( 1 )
  {
    while ( runtime_gosweepone() != -1 )
    {
      ++runtime_sweep.nbgsweep;
      runtime_Gosched();
    }
    while ( runtime_freeSomeWbufs(1) )
      runtime_Gosched();
    runtime_lock(&runtime_sweep.lock);
    if ( ptr )
    {
      runtime_sweep.parked = 1;
      elema.str = (uint8 *)"GC sweep wait";
      elema.len = 13;
      runtime_goparkunlock(&runtime_sweep.lock, elema, 0x14u, 1);
    }
    else
    {
      runtime_unlock(&runtime_sweep.lock);
    }
  }
}

//----- (08062580) --------------------------------------------------------
uintptr __golang runtime_sweepone()
{
  unsigned int v0; // eax
  unsigned int v1; // eax
  unsigned int v2; // edx
  uint32 v3; // ebx
  int v4; // eax
  unsigned int v5; // edx
  string ptr; // [esp+0h] [ebp-48h]
  string ptra; // [esp+0h] [ebp-48h]
  uint64 ptrb; // [esp+0h] [ebp-48h]
  string ptrc; // [esp+0h] [ebp-48h]
  string ptrd; // [esp+0h] [ebp-48h]
  string ptre; // [esp+0h] [ebp-48h]
  string ptrf; // [esp+0h] [ebp-48h]
  string ptrg; // [esp+0h] [ebp-48h]
  string ptrh; // [esp+0h] [ebp-48h]
  string ptri; // [esp+0h] [ebp-48h]
  string ptrj; // [esp+0h] [ebp-48h]
  runtime_mspan *ptr_4; // [esp+4h] [ebp-44h]
  uint32 v18; // [esp+8h] [ebp-40h]
  char v19; // [esp+Ch] [ebp-3Ch]
  runtime_mSpanState state; // [esp+13h] [ebp-35h]
  uint32 sg; // [esp+14h] [ebp-34h]
  uintptr npages; // [esp+18h] [ebp-30h]
  uintptr npagesa; // [esp+18h] [ebp-30h]
  uint64 v; // [esp+1Ch] [ebp-2Ch]
  int v25; // [esp+24h] [ebp-24h]
  unsigned int heap_live_high; // [esp+28h] [ebp-20h]
  unsigned int v27; // [esp+2Ch] [ebp-1Ch]
  int v28; // [esp+30h] [ebp-18h]
  unsigned int heap_live; // [esp+34h] [ebp-14h]
  uint32 sweepgen; // [esp+34h] [ebp-14h]
  int64 v31; // [esp+38h] [ebp-10h]
  runtime_g *_g_; // [esp+44h] [ebp-4h]

  _g_ = *(runtime_g **)(__readgsdword(0) - 4);
  v31 = qword_8149160;
  ++_g_->m->locks;
  if ( runtime_internal_atomic_Load(&::ptr) )
  {
    --_g_->m->locks;
    return -1;
  }
  runtime_internal_atomic_Xadd();
  v0 = dword_81490F0;
  sg = dword_81490F0;
  while ( 1 )
  {
    v1 = 1 - ((v0 >> 1) & 1);
    if ( v1 >= 2 )
      runtime_panicindex();
    ptr_4 = runtime___ptr_gcSweepBuf__pop(&runtime_mheap_.sweepSpans[v1]);
    if ( !ptr_4 )
    {
      runtime_internal_atomic_Store();
      v4 = -1;
      goto LABEL_15;
    }
    if ( ptr_4->state == 1 )
      break;
    v2 = sg;
    if ( ptr_4->sweepgen != sg )
    {
      state = ptr_4->state;
      sweepgen = ptr_4->sweepgen;
      runtime_printlock();
      ptrf.str = (uint8 *)"runtime: bad span s.state=";
      ptrf.len = 26;
      runtime_printstring(ptrf);
      runtime_printint(state);
      ptrg.str = (uint8 *)" s.sweepgen=";
      ptrg.len = 12;
      runtime_printstring(ptrg);
      runtime_printint(sweepgen);
      ptrh.str = (uint8 *)" sweepgen=";
      ptrh.len = 10;
      runtime_printstring(ptrh);
      runtime_printint(sg);
      ptri.str = (uint8 *)"\n";
      ptri.len = 1;
      runtime_printstring(ptri);
      runtime_printunlock();
      ptrj.str = (uint8 *)"non in-use span in unswept list";
      ptrj.len = 31;
      runtime_throw(ptrj);
      BUG();
    }
LABEL_3:
    v0 = v2;
  }
  v3 = sg;
  if ( ptr_4->sweepgen != sg - 2 )
  {
LABEL_10:
    v2 = v3;
    goto LABEL_3;
  }
  v18 = sg - 1;
  runtime_internal_atomic_Cas();
  if ( !v19 )
  {
    v3 = sg;
    goto LABEL_10;
  }
  npages = ptr_4->npages;
  LOBYTE(v18) = runtime___ptr_mspan__sweep(ptr_4, 0);
  if ( (_BYTE)v18 )
    v4 = npages;
  else
    v4 = 0;
LABEL_15:
  npagesa = v4;
  runtime_internal_atomic_Xadd();
  if ( !v18 && runtime_internal_atomic_Load(&::ptr) && runtime_debug.gcpacertrace > 0 )
  {
    heap_live = runtime_memstats.heap_live;
    v28 = dword_8149158;
    v27 = LODWORD(runtime_memstats.heap_live) - dword_8149158;
    heap_live_high = HIDWORD(runtime_memstats.heap_live);
    v25 = dword_814915C;
    v = qword_8149148;
    runtime_printlock();
    ptr.str = (uint8 *)"pacer: sweep done at heap size ";
    ptr.len = 31;
    runtime_printstring(ptr);
    runtime_printuint(__PAIR64__(HIDWORD(runtime_memstats.heap_live), heap_live) >> 20);
    ptra.str = (uint8 *)"MB; allocated ";
    ptra.len = 14;
    runtime_printstring(ptra);
    v5 = (__PAIR64__(heap_live_high, heap_live) - __PAIR64__(v25, v28)) >> 32;
    LODWORD(ptrb) = (v27 >> 20) | (v5 << 12);
    HIDWORD(ptrb) = v5 >> 20;
    runtime_printuint(ptrb);
    ptrc.str = (uint8 *)"MB during sweep; swept ";
    ptrc.len = 23;
    runtime_printstring(ptrc);
    runtime_printuint(v);
    ptrd.str = (uint8 *)" pages at ";
    ptrd.len = 10;
    runtime_printstring(ptrd);
    runtime_printfloat(*(float64 *)&v31);
    ptre.str = (uint8 *)" pages/byte\n";
    ptre.len = 12;
    runtime_printstring(ptre);
    runtime_printunlock();
  }
  --_g_->m->locks;
  return npagesa;
}
// 8062682: variable 'v19' is possibly undefined
// 80626D3: variable 'v18' is possibly undefined
// 81490F0: using guessed type int dword_81490F0;
// 8149158: using guessed type int dword_8149158;
// 814915C: using guessed type int dword_814915C;
// 8149160: using guessed type __int64 qword_8149160;

//----- (08062960) --------------------------------------------------------
uintptr __golang runtime_gosweepone()
{
  uintptr ret[3]; // [esp+4h] [ebp-Ch] BYREF

  ret[0] = 0;
  ret[1] = (uintptr)runtime_gosweepone_func1;
  ret[2] = (uintptr)ret;
  runtime_systemstack();
  return ret[0];
}

//----- (080629B0) --------------------------------------------------------
void __golang runtime___ptr_mspan__ensureSwept(runtime_mspan *s)
{
  int v1; // eax
  _DWORD *v2; // ecx
  string ptr; // [esp+0h] [ebp-18h]
  char v4; // [esp+Ch] [ebp-Ch]
  uint32 sg; // [esp+10h] [ebp-8h]

  v1 = *(_DWORD *)(__readgsdword(0) - 4);
  v2 = *(_DWORD **)(v1 + 24);
  if ( !v2[30] && !v2[26] && v1 != *v2 )
  {
    ptr.str = (uint8 *)"MSpan_EnsureSwept: m is not locked";
    ptr.len = 34;
    runtime_throw(ptr);
    BUG();
  }
  sg = dword_81490F0;
  if ( runtime_internal_atomic_Load(&s->sweepgen) != sg )
  {
    runtime_internal_atomic_Cas();
    if ( v4 )
    {
      runtime___ptr_mspan__sweep(s, 0);
    }
    else
    {
      while ( runtime_internal_atomic_Load(&s->sweepgen) != sg )
        runtime_osyield();
    }
  }
}
// 8062A3D: variable 'v4' is possibly undefined
// 81490F0: using guessed type int dword_81490F0;

//----- (08062AA0) --------------------------------------------------------
bool __golang runtime___ptr_mspan__sweep(runtime_mspan *s, bool preserve)
{
  runtime_g *v2; // eax
  runtime_m *m; // ecx
  runtime_mspan *v4; // edx
  runtime_mspan *v5; // ecx
  runtime_special **p_specials; // edx
  uintptr elemsize; // ebp
  runtime_special *specials; // esi
  runtime_special *v9; // edi
  unsigned int v10; // edi
  runtime_gcBits *v11; // edx
  int v12; // edi
  int v13; // ebx
  runtime_gcBits *v14; // eax
  runtime_gcBits v15; // dl
  runtime_special *next; // edx
  unsigned int v17; // edi
  runtime_special *v18; // ecx
  char v19; // al
  runtime_special *j; // edx
  runtime_special *v21; // ebx
  unsigned int offset; // ebx
  void *v23; // ebx
  runtime_special *v24; // edx
  uintptr k; // edx
  runtime_mspan *v26; // ebx
  char v27; // bp
  uint16 allocCount; // di
  int v29; // ebp
  bool v30; // al
  bool v31; // zf
  string ptr; // [esp+0h] [ebp-70h]
  string ptra; // [esp+0h] [ebp-70h]
  string ptrb; // [esp+0h] [ebp-70h]
  string ptrc; // [esp+0h] [ebp-70h]
  string ptrd; // [esp+0h] [ebp-70h]
  string ptre; // [esp+0h] [ebp-70h]
  string ptrf; // [esp+0h] [ebp-70h]
  string ptrg; // [esp+0h] [ebp-70h]
  string ptrh; // [esp+0h] [ebp-70h]
  string ptri; // [esp+0h] [ebp-70h]
  string ptrj; // [esp+0h] [ebp-70h]
  string ptrk; // [esp+0h] [ebp-70h]
  string ptrl; // [esp+0h] [ebp-70h]
  string ptrm; // [esp+0h] [ebp-70h]
  string ptrn; // [esp+0h] [ebp-70h]
  string ptro; // [esp+0h] [ebp-70h]
  string ptrp; // [esp+0h] [ebp-70h]
  uint16 delta; // [esp+4h] [ebp-6Ch]
  bool v50; // [esp+Ch] [ebp-64h]
  bool v51; // [esp+Ch] [ebp-64h]
  runtime_spanClass sc; // [esp+16h] [ebp-5Ah]
  bool hasFin; // [esp+18h] [ebp-58h]
  bool freeToHeap; // [esp+19h] [ebp-57h]
  char v55; // [esp+1Ah] [ebp-56h]
  runtime_mSpanState state; // [esp+1Bh] [ebp-55h]
  runtime_mSpanState v57; // [esp+1Bh] [ebp-55h]
  uint16 nfreed; // [esp+1Ch] [ebp-54h]
  uint32 sweepgen; // [esp+20h] [ebp-50h]
  uintptr size; // [esp+24h] [ebp-4Ch]
  uintptr i; // [esp+28h] [ebp-48h]
  uintptr endOffset; // [esp+2Ch] [ebp-44h]
  uint16 v63; // [esp+30h] [ebp-40h]
  uintptr v; // [esp+38h] [ebp-38h]
  int v_4; // [esp+3Ch] [ebp-34h]
  uint32 v_4a; // [esp+3Ch] [ebp-34h]
  uint32 v_4b; // [esp+3Ch] [ebp-34h]
  runtime_special **v68; // [esp+40h] [ebp-30h]
  runtime_special *special; // [esp+44h] [ebp-2Ch]
  runtime_mcache *c; // [esp+48h] [ebp-28h]
  runtime_g *_g_; // [esp+4Ch] [ebp-24h]
  runtime_special *v72; // [esp+50h] [ebp-20h]
  runtime_gcBits *mbits; // [esp+58h] [ebp-18h]
  char mbits_4; // [esp+5Ch] [ebp-14h]
  int mbits_8; // [esp+60h] [ebp-10h]
  runtime_gcBits *abits; // [esp+64h] [ebp-Ch]
  char abits_4; // [esp+68h] [ebp-8h]
  uintptr abits_8; // [esp+6Ch] [ebp-4h]

  ((void (*)(void))loc_808FD8A)();
  v2 = *(runtime_g **)(__readgsdword(0) - 4);
  m = v2->m;
  if ( !m->locks && !m->mallocing && v2 != m->g0 )
  {
    ptrp.str = (uint8 *)"MSpan_Sweep: m is not locked";
    ptrp.len = 28;
    runtime_throw(ptrp);
    BUG();
  }
  sweepgen = dword_81490F0;
  v4 = s;
  state = s->state;
  if ( state != 1 || dword_81490F0 - 1 != s->sweepgen )
  {
    v_4b = s->sweepgen;
    runtime_printlock();
    ptrk.str = (uint8 *)"MSpan_Sweep: state=";
    ptrk.len = 19;
    runtime_printstring(ptrk);
    runtime_printint(state);
    ptrl.str = (uint8 *)" sweepgen=";
    ptrl.len = 10;
    runtime_printstring(ptrl);
    runtime_printint(v_4b);
    ptrm.str = (uint8 *)" mheap.sweepgen=";
    ptrm.len = 16;
    runtime_printstring(ptrm);
    runtime_printint(sweepgen);
    ptrn.str = (uint8 *)"\n";
    ptrn.len = 1;
    runtime_printstring(ptrn);
    runtime_printunlock();
    ptro.str = (uint8 *)"MSpan_Sweep: bad span state";
    ptro.len = 27;
    runtime_throw(ptro);
    BUG();
  }
  _g_ = v2;
  v_4 = dword_81490F0 - 1;
  if ( runtime_trace.enabled )
  {
    runtime_traceGCSweepSpan(s->npages << 13);
    v4 = s;
  }
  runtime_internal_atomic_Xadd64(&qword_8149148, v4->npages);
  v5 = s;
  p_specials = &s->specials;
  sc = s->spanclass;
  elemsize = s->elemsize;
  size = elemsize;
  c = _g_->m->mcache;
  specials = s->specials;
  while ( specials )
  {
    if ( !elemsize )
      runtime_panicdivide();
    v68 = p_specials;
    v10 = specials->offset / elemsize;
    v11 = &v5->gcmarkBits[v10 >> 3];
    v12 = elemsize * v10;
    v13 = 1 << ((specials->offset / elemsize) & 7);
    v14 = v11;
    v15 = *v11;
    if ( ((unsigned __int8)v13 & v15) != 0 )
    {
      next = specials->next;
    }
    else
    {
      v17 = elemsize + v12;
      v18 = specials;
      while ( specials )
      {
        if ( specials->offset >= v17 )
        {
          v19 = 0;
          goto LABEL_20;
        }
        if ( specials->kind == 1 )
        {
          *v14 = v13 | v15;
          v19 = 1;
          goto LABEL_20;
        }
        specials = specials->next;
      }
      v19 = 0;
LABEL_20:
      endOffset = v17;
      hasFin = v19;
      for ( j = (runtime_special *)v68; v18; j = v21 )
      {
        offset = v18->offset;
        if ( offset >= v17 )
          break;
        v23 = (void *)(s->startAddr + offset);
        if ( v18->kind == 1 || !v19 )
        {
          v72 = j;
          special = v18->next;
          j->next = v18->next;
          runtime_freespecial(v18, v23, size);
          v19 = hasFin;
          v17 = endOffset;
          v24 = special;
          v18 = v72;
        }
        else
        {
          v24 = v18->next;
        }
        v21 = v18;
        v18 = v24;
      }
      elemsize = size;
      specials = j;
      next = v18;
    }
    v5 = s;
    v9 = specials;
    specials = next;
    p_specials = &v9->next;
  }
  if ( runtime_debug.allocfreetrace )
  {
    mbits = v5->gcmarkBits;
    mbits_4 = 1;
    mbits_8 = 0;
    abits = v5->allocBits;
    abits_4 = 1;
    abits_8 = 0;
    for ( k = 0; k < v5->nelems; ++k )
    {
      if ( (*mbits & (unsigned __int8)mbits_4) == 0
        && (abits_8 < v5->freeindex || (*abits & (unsigned __int8)abits_4) != 0)
        && runtime_debug.allocfreetrace )
      {
        i = k;
        runtime_tracefree((void *)(v5->startAddr + k * v5->elemsize), elemsize);
        v5 = s;
        k = i;
        elemsize = size;
      }
      if ( mbits_4 == (char)0x80 )
      {
        ++mbits;
        mbits_4 = 1;
      }
      else
      {
        mbits_4 *= 2;
      }
      ++mbits_8;
      if ( abits_4 == (char)0x80 )
      {
        ++abits;
        abits_4 = 1;
      }
      else
      {
        abits_4 *= 2;
      }
      ++abits_8;
    }
  }
  delta = runtime___ptr_mspan__countAlloc(v5);
  if ( sc >> 1 )
  {
    v26 = s;
    v27 = 0;
  }
  else
  {
    v26 = s;
    if ( delta )
    {
      v27 = 0;
    }
    else
    {
      s->needzero = 1;
      v27 = 1;
    }
  }
  allocCount = v26->allocCount;
  nfreed = allocCount - delta;
  if ( delta > allocCount )
  {
    v63 = delta;
    v = v26->nelems;
    runtime_printlock();
    ptre.str = (uint8 *)"runtime: nelems=";
    ptre.len = 16;
    runtime_printstring(ptre);
    runtime_printint(v);
    ptrf.str = (uint8 *)" nalloc=";
    ptrf.len = 8;
    runtime_printstring(ptrf);
    runtime_printint(v63);
    ptrg.str = (uint8 *)" previous allocCount=";
    ptrg.len = 21;
    runtime_printstring(ptrg);
    runtime_printint(allocCount);
    ptrh.str = (uint8 *)" nfreed=";
    ptrh.len = 8;
    runtime_printstring(ptrh);
    runtime_printint(nfreed);
    ptri.str = (uint8 *)"\n";
    ptri.len = 1;
    runtime_printstring(ptri);
    runtime_printunlock();
    ptrj.str = (uint8 *)"sweep increased allocation count";
    ptrj.len = 32;
    runtime_throw(ptrj);
    BUG();
  }
  v55 = sc >> 1;
  freeToHeap = v27;
  v26->allocCount = delta;
  runtime___ptr_mspan__nextFreeIndex(v26);
  s->freeindex = 0;
  if ( runtime_trace.enabled )
  {
    v29 = *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(__readgsdword(0) - 4) + 24) + 92);
    *(_DWORD *)(v29 + 2356) += nfreed * s->elemsize;
  }
  s->allocBits = s->gcmarkBits;
  s->gcmarkBits = runtime_newMarkBits(s->nelems);
  runtime___ptr_mspan__refillAllocCache(s, 0);
  if ( freeToHeap || !nfreed )
  {
    v57 = s->state;
    if ( v57 != 1 || v_4 != s->sweepgen )
    {
      v_4a = s->sweepgen;
      runtime_printlock();
      ptr.str = (uint8 *)"MSpan_Sweep: state=";
      ptr.len = 19;
      runtime_printstring(ptr);
      runtime_printint(v57);
      ptra.str = (uint8 *)" sweepgen=";
      ptra.len = 10;
      runtime_printstring(ptra);
      runtime_printint(v_4a);
      ptrb.str = (uint8 *)" mheap.sweepgen=";
      ptrb.len = 16;
      runtime_printstring(ptrb);
      runtime_printint(sweepgen);
      ptrc.str = (uint8 *)"\n";
      ptrc.len = 1;
      runtime_printstring(ptrc);
      runtime_printunlock();
      ptrd.str = (uint8 *)"MSpan_Sweep: bad span state after sweep";
      ptrd.len = 39;
      runtime_throw(ptrd);
      BUG();
    }
    runtime_internal_atomic_Store();
  }
  if ( !nfreed )
  {
    v31 = !freeToHeap;
LABEL_66:
    if ( v31 )
    {
      v30 = 0;
    }
    else
    {
      if ( runtime_debug.efence <= 0 )
      {
        runtime___ptr_mheap__freeSpan(&runtime_mheap_, s, 1);
      }
      else
      {
        s->limit = 0;
        runtime_sysFault((void *)s->startAddr, size);
      }
      ++c->local_nlargefree;
      c->local_largefree += size;
      v30 = 1;
    }
    goto LABEL_62;
  }
  if ( !v55 )
  {
    v31 = !freeToHeap;
    goto LABEL_66;
  }
  if ( (unsigned int)v55 >= 0x43 )
    runtime_panicindex();
  c->local_nsmallfree[v55] += nfreed;
  if ( sc >= 0x86u )
    runtime_panicindex();
  runtime___ptr_mcentral__freeSpan(&runtime_mheap_.central[sc].mcentral, s, preserve, v50);
  v30 = v51;
LABEL_62:
  if ( !v30 )
  {
    runtime___ptr_gcSweepBuf__push((runtime_gcSweepBuf_0 *)&dword_8149114[5 * ((sweepgen >> 1) & 1)], s);
    return 0;
  }
  return v30;
}
// 8062F6C: variable 'v50' is possibly undefined
// 8062F71: variable 'v51' is possibly undefined
// 81490F0: using guessed type int dword_81490F0;
// 8149114: using guessed type _DWORD dword_8149114[11];

//----- (08063340) --------------------------------------------------------
void __golang runtime_deductSweepCredit(uintptr spanBytes, uintptr callerSweepPages)
{
  int v2; // esi
  __int64 v3; // rax
  int v4; // ebx
  int v5; // esi
  long double d_4; // [esp+4h] [ebp-24h]
  __int64 sweptBasis_lo; // [esp+10h] [ebp-18h]
  __int64 pagesTarget_lo; // [esp+18h] [ebp-10h]
  double v9; // [esp+20h] [ebp-8h]

  if ( *(double *)&qword_8149160 != 0.0 )
  {
    if ( runtime_trace.enabled )
      runtime_traceGCSweepStart();
LABEL_7:
    runtime_internal_atomic_Load64();
    sweptBasis_lo = *(_QWORD *)&d_4;
    runtime_internal_atomic_Load64();
    v9 = *(double *)&qword_8149160;
    runtime_uint32tofloat64();
    runtime_float64toint64(v9 * *(double *)&d_4, *(uint64 *)((char *)&d_4 + 4));
    pagesTarget_lo = *(_QWORD *)((char *)&d_4 + 4) - callerSweepPages;
    while ( 1 )
    {
      runtime_internal_atomic_Load64();
      v3 = *(_QWORD *)&d_4 - sweptBasis_lo;
      v4 = v2;
      LOBYTE(v4) = HIDWORD(pagesTarget_lo) == (unsigned __int64)(*(_QWORD *)&d_4 - sweptBasis_lo) >> 32;
      LOBYTE(v3) = (unsigned int)pagesTarget_lo > LODWORD(d_4) - (int)sweptBasis_lo;
      v5 = v3 & v4;
      LOBYTE(v3) = SHIDWORD(pagesTarget_lo) > (int)((unsigned __int64)(*(_QWORD *)&d_4 - sweptBasis_lo) >> 32);
      v2 = v3 | v5;
      if ( !(_BYTE)v2 )
        break;
      if ( runtime_gosweepone() == -1 )
      {
        qword_8149160 = 0LL;
        break;
      }
      runtime_internal_atomic_Load64();
      if ( LODWORD(d_4) != (_DWORD)sweptBasis_lo || DWORD1(d_4) != HIDWORD(sweptBasis_lo) )
        goto LABEL_7;
    }
    if ( runtime_trace.enabled )
      runtime_traceGCSweepDone();
  }
}
// 8063340: could not find valid save-restore pair for ebx
// 8063340: could not find valid save-restore pair for ebp
// 8063340: could not find valid save-restore pair for edi
// 806339A: variable 'd_4' is possibly undefined
// 80633AC: variable 'v2' is possibly undefined
// 8149158: using guessed type int dword_8149158;
// 8149160: using guessed type __int64 qword_8149160;

//----- (080634E0) --------------------------------------------------------
void __golang runtime___ptr_gcSweepBuf__push(runtime_gcSweepBuf_0 *b, runtime_mspan *s)
{
  unsigned int v2; // eax
  _DWORD *v3; // eax
  char *align; // [esp+4h] [ebp-28h]
  uint64 *sysStat; // [esp+8h] [ebp-24h]
  uintptr top; // [esp+10h] [ebp-1Ch]
  __int16 v7; // [esp+1Ch] [ebp-10h]
  _DWORD *v8; // [esp+24h] [ebp-8h]

  runtime_internal_atomic_Xadd();
  runtime_internal_atomic_Loaduintptr();
  v7 = (_WORD)sysStat - 1;
  v2 = ((unsigned int)sysStat - 1) >> 9;
  top = v2;
  while ( 1 )
  {
    if ( !v2 )
    {
      align = (char *)runtime_internal_atomic_Loadp(&b->spine);
      v3 = runtime_internal_atomic_Loadp(&align[4 * top]);
      goto LABEL_10;
    }
    runtime_lock(&b->spineLock);
    runtime_internal_atomic_Loaduintptr();
    if ( top )
      break;
    runtime_unlock(&b->spineLock);
    v2 = ((unsigned int)sysStat - 1) >> 9;
  }
  if ( b->spineCap == 1 )
  {
    runtime_persistentalloc(8u, 0x40u, &runtime_memstats.gc_sys);
    if ( b->spineCap )
      runtime_memmove();
    runtime_internal_atomic_StorepNoWB();
    b->spineCap = 2;
  }
  v8 = runtime_persistentalloc(0x800u, 0x40u, &runtime_memstats.gc_sys);
  runtime_internal_atomic_StorepNoWB();
  runtime_internal_atomic_Storeuintptr();
  runtime_unlock(&b->spineLock);
  v3 = v8;
LABEL_10:
  v3[v7 & 0x1FF] = s;
}
// 80634E0: could not find valid save-restore pair for ebx
// 8063532: variable 'sysStat' is possibly undefined

//----- (080636D0) --------------------------------------------------------
runtime_mspan *__golang runtime___ptr_gcSweepBuf__pop(runtime_gcSweepBuf_0 *b)
{
  int v1; // eax
  int v2; // ecx
  runtime_mspan *v3; // edx
  int v4; // [esp+8h] [ebp-8h]

  runtime_internal_atomic_Xadd();
  if ( v4 >= 0 )
  {
    v1 = *((_DWORD *)b->spine + ((unsigned int)v4 >> 9));
    v2 = v4 & 0x1FF;
    v3 = *(runtime_mspan **)(v1 + 4 * v2);
    *(_DWORD *)(v1 + 4 * v2) = 0;
    return v3;
  }
  else
  {
    runtime_internal_atomic_Xadd();
    return 0;
  }
}
// 8063708: variable 'v4' is possibly undefined

//----- (08063760) --------------------------------------------------------
__int32 __golang runtime___ptr_gcSweepBuf__numBlocks(runtime_gcSweepBuf_0 *b)
{
  return (runtime_internal_atomic_Load(&b->index) + 511) >> 9;
}

//----- (080637B0) --------------------------------------------------------
___runtime_mspan __golang runtime___ptr_gcSweepBuf__block(runtime_gcSweepBuf_0 *b, __int32 i)
{
  __int32 v2; // ecx
  string ptr; // [esp+0h] [ebp-Ch]
  unsigned int v4; // [esp+4h] [ebp-8h]
  char *v5; // [esp+4h] [ebp-8h]
  uint32 v6; // [esp+4h] [ebp-8h]
  runtime_mspan **v7; // [esp+8h] [ebp-4h]
  ___runtime_mspan _r1; // [esp+18h] [ebp+Ch]

  if ( i < 0 || (runtime_internal_atomic_Loaduintptr(), i >= v4) )
  {
    ptr.str = (uint8 *)"block index out of range";
    ptr.len = 24;
    runtime_throw(ptr);
    BUG();
  }
  v5 = (char *)runtime_internal_atomic_Loadp(&b->spine);
  v7 = (runtime_mspan **)runtime_internal_atomic_Loadp(&v5[4 * i]);
  v6 = runtime_internal_atomic_Load(&b->index);
  if ( i >= v6 >> 9 )
    v2 = v6 & 0x1FF;
  else
    v2 = 512;
  while ( v2 > 0 )
  {
    if ( v2 - 1 >= (unsigned int)v2 )
      runtime_panicindex();
    if ( v7[v2 - 1] )
      break;
    --v2;
  }
  _r1.array = v7;
  _r1.len = v2;
  _r1.cap = 512;
  return _r1;
}
// 80637F0: variable 'v4' is possibly undefined

//----- (080638B0) --------------------------------------------------------
void __golang runtime_init_0()
{
  ;
}

//----- (080638D0) --------------------------------------------------------
void __golang runtime___ptr_gcWork__init(runtime_gcWork_0 *w)
{
  runtime_workbuf *v1; // eax

  w->wbuf1 = runtime_getempty();
  v1 = runtime_trygetfull();
  if ( !v1 )
    v1 = runtime_getempty();
  w->wbuf2 = v1;
}

//----- (08063920) --------------------------------------------------------
void __golang runtime___ptr_gcWork__put(runtime_gcWork_0 *w, uintptr obj)
{
  runtime_workbuf *wbuf1; // ecx
  bool v3; // dl
  unsigned int nobj; // eax
  bool v5; // [esp+7h] [ebp-1h]

  wbuf1 = w->wbuf1;
  if ( w->wbuf1 )
  {
    if ( wbuf1->workbufhdr.nobj == 508 )
    {
      w->wbuf1 = w->wbuf2;
      w->wbuf2 = wbuf1;
      wbuf1 = w->wbuf1;
      v3 = w->wbuf1->workbufhdr.nobj == 508;
      if ( w->wbuf1->workbufhdr.nobj == 508 )
      {
        v5 = w->wbuf1->workbufhdr.nobj == 508;
        runtime_putfull(wbuf1);
        wbuf1 = runtime_getempty();
        w->wbuf1 = wbuf1;
        v3 = v5;
      }
    }
    else
    {
      v3 = 0;
    }
  }
  else
  {
    runtime___ptr_gcWork__init(w);
    wbuf1 = w->wbuf1;
    v3 = 0;
  }
  nobj = wbuf1->workbufhdr.nobj;
  if ( nobj >= 0x1FC )
    runtime_panicindex();
  wbuf1->obj[nobj] = obj;
  ++wbuf1->workbufhdr.nobj;
  if ( v3 && runtime_gcphase == 1 )
    runtime___ptr_gcControllerState__enlistWorker(&runtime_gcController);
}

//----- (080639F0) --------------------------------------------------------
uintptr __golang runtime___ptr_gcWork__tryGet(runtime_gcWork_0 *w)
{
  runtime_gcWork_0 *v1; // eax
  runtime_workbuf *wbuf1; // ecx
  runtime_workbuf *v3; // edx
  __int32 nobj; // eax
  runtime_workbuf *b; // [esp+0h] [ebp-Ch]
  runtime_workbuf *wbuf; // [esp+4h] [ebp-8h]
  runtime_workbuf *owbuf; // [esp+8h] [ebp-4h]

  v1 = w;
  wbuf1 = w->wbuf1;
  if ( !w->wbuf1 )
  {
    runtime___ptr_gcWork__init(w);
    v1 = w;
    wbuf1 = w->wbuf1;
  }
  if ( !wbuf1->workbufhdr.nobj )
  {
    v3 = v1->wbuf1;
    v1->wbuf1 = v1->wbuf2;
    v1->wbuf2 = v3;
    wbuf1 = v1->wbuf1;
    if ( !v1->wbuf1->workbufhdr.nobj )
    {
      owbuf = v1->wbuf1;
      b = runtime_trygetfull();
      if ( !b )
        return 0;
      wbuf = b;
      runtime_putempty(owbuf);
      wbuf1 = wbuf;
      w->wbuf1 = wbuf;
    }
  }
  nobj = wbuf1->workbufhdr.nobj;
  wbuf1->workbufhdr.nobj = nobj - 1;
  if ( (unsigned int)(nobj - 1) >= 0x1FC )
    runtime_panicindex();
  return *(&wbuf1->workbufhdr.nobj + nobj);
}

//----- (08063AB0) --------------------------------------------------------
uintptr __golang runtime___ptr_gcWork__get(runtime_gcWork_0 *w)
{
  runtime_gcWork_0 *v1; // eax
  runtime_workbuf *wbuf1; // ecx
  runtime_workbuf *v3; // edx
  __int32 nobj; // eax
  runtime_workbuf *b; // [esp+0h] [ebp-Ch]
  runtime_workbuf *wbuf; // [esp+4h] [ebp-8h]
  runtime_workbuf *owbuf; // [esp+8h] [ebp-4h]

  v1 = w;
  wbuf1 = w->wbuf1;
  if ( !w->wbuf1 )
  {
    runtime___ptr_gcWork__init(w);
    v1 = w;
    wbuf1 = w->wbuf1;
  }
  if ( !wbuf1->workbufhdr.nobj )
  {
    v3 = v1->wbuf1;
    v1->wbuf1 = v1->wbuf2;
    v1->wbuf2 = v3;
    wbuf1 = v1->wbuf1;
    if ( !v1->wbuf1->workbufhdr.nobj )
    {
      owbuf = v1->wbuf1;
      b = runtime_getfull();
      if ( !b )
        return 0;
      wbuf = b;
      runtime_putempty(owbuf);
      wbuf1 = wbuf;
      w->wbuf1 = wbuf;
    }
  }
  nobj = wbuf1->workbufhdr.nobj;
  wbuf1->workbufhdr.nobj = nobj - 1;
  if ( (unsigned int)(nobj - 1) >= 0x1FC )
    runtime_panicindex();
  return *(&wbuf1->workbufhdr.nobj + nobj);
}

//----- (08063B70) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
void __golang runtime___ptr_gcWork__dispose(runtime_gcWork_0 *w)
{
  runtime_gcWork_0 *v1; // eax
  unsigned int bytesMarked; // ecx
  unsigned int bytesMarked_high; // edx
  int v4; // [esp+10h] [ebp-4h] OVERLAPPED

  v1 = w;
  if ( w->wbuf1 )
  {
    if ( w->wbuf1->workbufhdr.nobj )
      runtime_putfull(w->wbuf1);
    else
      runtime_putempty(w->wbuf1);
    w->wbuf1 = 0;
    if ( w->wbuf2->workbufhdr.nobj )
      runtime_putfull(w->wbuf2);
    else
      runtime_putempty(w->wbuf2);
    v1 = w;
    w->wbuf2 = 0;
  }
  bytesMarked = v1->bytesMarked;
  bytesMarked_high = HIDWORD(v1->bytesMarked);
  if ( bytesMarked_high != 0 || bytesMarked != 0 )
  {
    *(_QWORD *)&v4 = runtime_internal_atomic_Xadd64(
                       &runtime_work.bytesMarked,
                       __SPAIR64__(bytesMarked_high, bytesMarked));
    v1 = w;
    w->bytesMarked = 0LL;
  }
  if ( HIDWORD(v1->scanWork) != 0 || LODWORD(v1->scanWork) != 0 )
  {
    runtime_internal_atomic_Xaddint64();
    w->scanWork = 0LL;
  }
}
// 8063B70: variables would overlap: ^10.4 and ^10.8

//----- (08063C90) --------------------------------------------------------
void __golang runtime___ptr_gcWork__balance(runtime_gcWork_0 *w)
{
  if ( w->wbuf1 )
  {
    if ( w->wbuf2->workbufhdr.nobj )
    {
      runtime_putfull(w->wbuf2);
      w->wbuf2 = runtime_getempty();
    }
    else
    {
      if ( w->wbuf1->workbufhdr.nobj <= 4 )
        return;
      w->wbuf1 = runtime_handoff(w->wbuf1);
    }
    if ( runtime_gcphase == 1 )
      runtime___ptr_gcControllerState__enlistWorker(&runtime_gcController);
  }
}

//----- (08063D20) --------------------------------------------------------
void __golang runtime___ptr_workbuf__checknonempty(runtime_workbuf *b)
{
  string s; // [esp+0h] [ebp-8h]

  if ( !b->workbufhdr.nobj )
  {
    s.str = (uint8 *)"workbuf is empty";
    s.len = 16;
    runtime_throw(s);
    BUG();
  }
}

//----- (08063D70) --------------------------------------------------------
void __golang runtime___ptr_workbuf__checkempty(runtime_workbuf *b)
{
  string s; // [esp+0h] [ebp-8h]

  if ( b->workbufhdr.nobj )
  {
    s.str = (uint8 *)"workbuf is not empty";
    s.len = 20;
    runtime_throw(s);
    BUG();
  }
}

//----- (08063DC0) --------------------------------------------------------
runtime_workbuf *__golang runtime_getempty()
{
  runtime_workbuf *v0; // eax
  int v1; // ecx
  int v2; // edx
  runtime_workbuf *v3; // ebp
  string v4; // [esp+0h] [ebp-24h]
  runtime_workbuf *v5; // [esp+4h] [ebp-20h]
  int v6; // [esp+8h] [ebp-1Ch]
  runtime_mspan *s; // [esp+Ch] [ebp-18h] BYREF
  runtime_workbuf *b; // [esp+10h] [ebp-14h]
  runtime_workbuf *v9; // [esp+14h] [ebp-10h]
  runtime_workbuf *v10; // [esp+18h] [ebp-Ch]
  void (__golang *v11)(); // [esp+1Ch] [ebp-8h]
  runtime_mspan **p_s; // [esp+20h] [ebp-4h]

  if ( LODWORD(runtime_work.empty) != 0 || HIDWORD(runtime_work.empty) != 0 )
  {
    v5 = (runtime_workbuf *)runtime___ptr_lfstack__pop(&runtime_work.empty);
    v0 = v5;
    if ( v5 )
    {
      v9 = v5;
      runtime___ptr_workbuf__checkempty(v5);
      v0 = v5;
    }
  }
  else
  {
    v0 = 0;
  }
  if ( !v0 )
  {
    b = 0;
    s = 0;
    if ( runtime_work.wbufSpans.free.first )
    {
      runtime_lock(&runtime_work.wbufSpans.lock);
      s = runtime_work.wbufSpans.free.first;
      if ( runtime_work.wbufSpans.free.first )
      {
        runtime___ptr_mSpanList__remove(&runtime_work.wbufSpans.free, s);
        runtime___ptr_mSpanList__insert(&runtime_work.wbufSpans.busy, s);
      }
      runtime_unlock(&runtime_work.wbufSpans.lock);
      v0 = b;
    }
    if ( !s )
    {
      v11 = runtime_getempty_func1;
      p_s = &s;
      runtime_systemstack();
      if ( !s )
      {
        v4.str = (uint8 *)"out of memory";
        v4.len = 13;
        runtime_throw(v4);
        BUG();
      }
      runtime_lock(&runtime_work.wbufSpans.lock);
      runtime___ptr_mSpanList__insert(&runtime_work.wbufSpans.busy, s);
      runtime_unlock(&runtime_work.wbufSpans.lock);
      v0 = b;
    }
    v1 = 0;
    while ( 1 )
    {
      v2 = v1 + 2048;
      if ( (unsigned int)(v1 + 2048) > 0x8000 )
        break;
      v3 = (runtime_workbuf *)(v1 + s->startAddr);
      v3->workbufhdr.nobj = 0;
      if ( v1 )
      {
        v6 = v1 + 2048;
        v10 = v0;
        runtime_putempty(v3);
        v2 = v6;
        v3 = v10;
      }
      v1 = v2;
      v0 = v3;
    }
  }
  return v0;
}
// 8063DC0: could not find valid save-restore pair for ebx

//----- (08063F90) --------------------------------------------------------
void __golang runtime_putempty(runtime_workbuf *b)
{
  runtime___ptr_workbuf__checkempty(b);
  runtime___ptr_lfstack__push(&runtime_work.empty, &b->workbufhdr.node);
}

//----- (08063FE0) --------------------------------------------------------
void __golang runtime_putfull(runtime_workbuf *b)
{
  runtime___ptr_workbuf__checknonempty(b);
  runtime___ptr_lfstack__push(&runtime_work.full, &b->workbufhdr.node);
}

//----- (08064030) --------------------------------------------------------
runtime_workbuf *__golang runtime_trygetfull()
{
  runtime_workbuf *b; // [esp+4h] [ebp-8h]

  b = (runtime_workbuf *)runtime___ptr_lfstack__pop(&runtime_work.full);
  if ( !b )
    return 0;
  runtime___ptr_workbuf__checknonempty(b);
  return b;
}

//----- (08064090) --------------------------------------------------------
runtime_workbuf *__golang runtime_getfull()
{
  int j; // eax
  string head; // [esp+0h] [ebp-24h]
  string heada; // [esp+0h] [ebp-24h]
  string headb; // [esp+0h] [ebp-24h]
  string headc; // [esp+0h] [ebp-24h]
  string headd; // [esp+0h] [ebp-24h]
  string heade; // [esp+0h] [ebp-24h]
  string headf; // [esp+0h] [ebp-24h]
  string headg; // [esp+0h] [ebp-24h]
  string headh; // [esp+0h] [ebp-24h]
  runtime_workbuf *b; // [esp+4h] [ebp-20h]
  uint32 v11; // [esp+8h] [ebp-1Ch]
  __int32 i; // [esp+14h] [ebp-10h]
  uint32 v; // [esp+1Ch] [ebp-8h]
  uint32 va; // [esp+1Ch] [ebp-8h]
  uint32 vb; // [esp+1Ch] [ebp-8h]

  b = (runtime_workbuf *)runtime___ptr_lfstack__pop(&runtime_work.full);
  if ( b )
  {
LABEL_2:
    runtime___ptr_workbuf__checknonempty(b);
    return b;
  }
  else
  {
    runtime_internal_atomic_Xadd();
    if ( v11 > runtime_work.nproc )
    {
      vb = runtime_work.nproc;
      runtime_printlock();
      headf.str = (uint8 *)"runtime: work.nwait=";
      headf.len = 20;
      runtime_printstring(headf);
      runtime_printsp();
      runtime_printint(v11);
      runtime_printsp();
      headg.str = (uint8 *)"work.nproc=";
      headg.len = 11;
      runtime_printstring(headg);
      runtime_printsp();
      runtime_printint(vb);
      runtime_printnl();
      runtime_printunlock();
      headh.str = (uint8 *)"work.nwait > work.nproc";
      headh.len = 23;
      runtime_throw(headh);
      BUG();
    }
    for ( j = 0; ; j = i + 1 )
    {
      i = j;
      if ( LODWORD(runtime_work.full) != 0 || HIDWORD(runtime_work.full) != 0 )
      {
        runtime_internal_atomic_Xadd();
        if ( v11 == runtime_work.nproc )
        {
          va = runtime_work.nproc;
          runtime_printlock();
          headc.str = (uint8 *)"runtime: work.nwait=";
          headc.len = 20;
          runtime_printstring(headc);
          runtime_printsp();
          runtime_printint(v11);
          runtime_printsp();
          headd.str = (uint8 *)"work.nproc=";
          headd.len = 11;
          runtime_printstring(headd);
          runtime_printsp();
          runtime_printint(va);
          runtime_printnl();
          runtime_printunlock();
          heade.str = (uint8 *)"work.nwait > work.nproc";
          heade.len = 23;
          runtime_throw(heade);
          BUG();
        }
        b = (runtime_workbuf *)runtime___ptr_lfstack__pop(&runtime_work.full);
        if ( b )
          goto LABEL_2;
        runtime_internal_atomic_Xadd();
        if ( v11 > runtime_work.nproc )
        {
          v = runtime_work.nproc;
          runtime_printlock();
          head.str = (uint8 *)"runtime: work.nwait=";
          head.len = 20;
          runtime_printstring(head);
          runtime_printsp();
          runtime_printint(v11);
          runtime_printsp();
          heada.str = (uint8 *)"work.nproc=";
          heada.len = 11;
          runtime_printstring(heada);
          runtime_printsp();
          runtime_printint(v);
          runtime_printnl();
          runtime_printunlock();
          headb.str = (uint8 *)"work.nwait > work.nproc";
          headb.len = 23;
          runtime_throw(headb);
          BUG();
        }
        j = i;
      }
      if ( runtime_work.nproc == runtime_work.nwait && runtime_work.markrootNext >= runtime_work.markrootJobs )
        break;
      if ( j < 10 )
      {
        runtime_procyield();
      }
      else if ( j >= 20 )
      {
        runtime_usleep();
      }
      else
      {
        runtime_osyield();
      }
    }
    return 0;
  }
}
// 80640F9: variable 'v11' is possibly undefined

//----- (080643D0) --------------------------------------------------------
runtime_workbuf *__golang runtime_handoff(runtime_workbuf *b)
{
  runtime_workbuf *v1; // eax
  __int32 nobj; // ebx
  runtime_workbuf *b1; // [esp+Ch] [ebp-4h]

  v1 = runtime_getempty();
  nobj = b->workbufhdr.nobj;
  b->workbufhdr.nobj = nobj - nobj / 2;
  v1->workbufhdr.nobj = nobj / 2;
  if ( b->workbufhdr.nobj >= 0x1FCu )
    runtime_panicindex();
  b1 = v1;
  runtime_memmove();
  runtime_putfull(b);
  return b1;
}

//----- (08064460) --------------------------------------------------------
void __golang runtime_prepareFreeWorkbufs()
{
  string l; // [esp+0h] [ebp-8h]

  runtime_lock(&runtime_work.wbufSpans.lock);
  if ( LODWORD(runtime_work.full) != 0 || HIDWORD(runtime_work.full) != 0 )
  {
    l.str = (uint8 *)"cannot free workbufs when work.full != 0";
    l.len = 40;
    runtime_throw(l);
    BUG();
  }
  runtime_work.empty = 0LL;
  runtime___ptr_mSpanList__takeAll(&runtime_work.wbufSpans.free, &runtime_work.wbufSpans.busy);
  runtime_unlock(&runtime_work.wbufSpans.lock);
}

//----- (08064510) --------------------------------------------------------
bool __golang runtime_freeSomeWbufs(bool preemptible)
{
  void (__golang *v1)(); // [esp+4h] [ebp-Ch]
  bool v2; // [esp+8h] [ebp-8h]
  runtime_mspan *first; // [esp+Ch] [ebp-4h]

  runtime_lock(&runtime_work.wbufSpans.lock);
  if ( runtime_gcphase || !runtime_work.wbufSpans.free.first )
  {
    runtime_unlock(&runtime_work.wbufSpans.lock);
    return 0;
  }
  else
  {
    v1 = runtime_freeSomeWbufs_func1;
    v2 = preemptible;
    runtime_systemstack();
    first = runtime_work.wbufSpans.free.first;
    runtime_unlock(&runtime_work.wbufSpans.lock);
    return first != 0;
  }
}

//----- (080645C0) --------------------------------------------------------
void __golang runtime_recordspan(void *vh, void *p)
{
  void *v2; // eax
  int v3; // edx
  int v4; // ecx
  runtime_mspan **v5; // ecx
  __int32 v6; // edx
  int v7; // ebx
  _DWORD *v8; // ecx
  __int32 v9; // edx
  __int32 v10; // ebx
  _DWORD *array; // eax
  __int32 len; // ecx
  void *v13; // ebx
  _DWORD *v14; // edx
  string v15; // [esp+0h] [ebp-48h]
  runtime_slice_0 sysStat; // [esp+4h] [ebp-44h]
  runtime_slice_0 src; // [esp+14h] [ebp-34h]
  __int32 oldAllspans_len; // [esp+20h] [ebp-28h]
  __int32 n; // [esp+28h] [ebp-20h]
  runtime_mspan **oldAllspans_ptr; // [esp+30h] [ebp-18h]
  uintptr *dst; // [esp+38h] [ebp-10h]
  long double newa; // [esp+3Ch] [ebp-Ch]

  v2 = vh;
  v3 = *((_DWORD *)vh + 521);
  dst = (uintptr *)((char *)vh + 2076);
  if ( *((_DWORD *)vh + 520) >= v3 )
  {
    v4 = 3 * v3 / 2;
    if ( v4 <= 0x4000 )
      v4 = 0x4000;
    n = v4;
    LODWORD(newa) = runtime_sysAlloc(4 * v4, &runtime_memstats.other_sys);
    if ( !LODWORD(newa) )
    {
      v15.str = (uint8 *)"runtime: cannot allocate memory";
      v15.len = 31;
      runtime_throw(v15);
      BUG();
    }
    v2 = vh;
    DWORD1(newa) = *((_DWORD *)vh + 520);
    HIDWORD(newa) = n;
    if ( SDWORD1(newa) > 0 )
    {
      runtime_typedslicecopy(
        (runtime__type_0 *)&stru_80DB9C0,
        *(runtime_slice_0 *)&newa,
        *((runtime_slice_0 *)vh + 173));
      v2 = vh;
    }
    v5 = (runtime_mspan **)*((_DWORD *)v2 + 519);
    v6 = *((_DWORD *)v2 + 520);
    v7 = *((_DWORD *)v2 + 521);
    *((_DWORD *)v2 + 520) = DWORD1(newa);
    *((_DWORD *)v2 + 521) = n;
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
    {
      oldAllspans_ptr = v5;
      oldAllspans_len = v6;
      runtime_writebarrierptr(dst, LODWORD(newa));
      v2 = vh;
      v5 = oldAllspans_ptr;
      v6 = oldAllspans_len;
    }
    else
    {
      *((_DWORD *)v2 + 519) = LODWORD(newa);
    }
    if ( v6 )
    {
      runtime_sysFree(v5, 4 * v7, &runtime_memstats.other_sys);
      v2 = vh;
    }
  }
  v8 = (_DWORD *)*((_DWORD *)v2 + 519);
  v9 = *((_DWORD *)v2 + 521);
  v10 = *((_DWORD *)v2 + 520);
  if ( v10 + 1 > v9 )
  {
    sysStat.array = (void *)*((_DWORD *)v2 + 519);
    *(_QWORD *)&sysStat.len = __PAIR64__(v9, v10);
    src = runtime_growslice((runtime__type_0 *)&stru_80DB9C0, sysStat, v10 + 1);
    array = src.array;
    len = src.len;
    v13 = vh;
    *((_DWORD *)vh + 521) = src.cap;
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
    {
      runtime_writebarrierptr(dst, (uintptr)src.array);
      array = src.array;
      len = src.len;
      v13 = vh;
    }
    else
    {
      *((_DWORD *)vh + 519) = src.array;
    }
    v14 = array;
    v2 = v13;
    v10 = len;
    v8 = v14;
  }
  *((_DWORD *)v2 + 520) = v10 + 1;
  v8[v10] = p;
}
// 80645C0: could not find valid save-restore pair for edi

//----- (08064840) --------------------------------------------------------
void __golang runtime___ptr_mheap__init(runtime_mheap_0 *h, uintptr spansStart, uintptr spansBytes)
{
  runtime_mheap_0 *v3; // eax
  int i; // ecx
  int j; // ecx
  int v6; // edx
  int v7; // ecx
  uintptr *dst; // [esp+Ch] [ebp-4h]
  uintptr *dsta; // [esp+Ch] [ebp-4h]
  uintptr *dstb; // [esp+Ch] [ebp-4h]
  uintptr *dstc; // [esp+Ch] [ebp-4h]

  v3 = h;
  h->treapalloc.size = 24;
  if ( *(_DWORD *)&runtime_writeBarrier.enabled )
  {
    runtime_writebarrierptr((uintptr *)&h->treapalloc.first, 0);
    runtime_writebarrierptr((uintptr *)&h->treapalloc.arg, 0);
    v3 = h;
  }
  else
  {
    h->treapalloc.first = 0;
    h->treapalloc.arg = 0;
  }
  v3->treapalloc.list = 0;
  v3->treapalloc.chunk = 0;
  v3->treapalloc.nchunk = 0;
  v3->treapalloc.inuse = 0;
  if ( *(_DWORD *)&runtime_writeBarrier.enabled )
  {
    runtime_writebarrierptr((uintptr *)&v3->treapalloc.stat, (uintptr)&runtime_memstats.other_sys);
    v3 = h;
  }
  else
  {
    v3->treapalloc.stat = &runtime_memstats.other_sys;
  }
  v3->treapalloc.zero = 1;
  v3->spanalloc.size = 92;
  if ( *(_DWORD *)&runtime_writeBarrier.enabled )
  {
    dstc = (uintptr *)&v3->spanalloc.arg;
    runtime_writebarrierptr((uintptr *)&v3->spanalloc.first, (uintptr)&off_80E7CA8);
    runtime_writebarrierptr(dstc, (uintptr)h);
    v3 = h;
  }
  else
  {
    v3->spanalloc.first = (void (*)(void *, void *))&off_80E7CA8;
    v3->spanalloc.arg = v3;
  }
  v3->spanalloc.list = 0;
  v3->spanalloc.chunk = 0;
  v3->spanalloc.nchunk = 0;
  v3->spanalloc.inuse = 0;
  if ( *(_DWORD *)&runtime_writeBarrier.enabled )
  {
    runtime_writebarrierptr((uintptr *)&v3->spanalloc.stat, (uintptr)&runtime_memstats.mspan_sys);
    v3 = h;
  }
  else
  {
    v3->spanalloc.stat = &runtime_memstats.mspan_sys;
  }
  v3->spanalloc.zero = 1;
  v3->cachealloc.size = 868;
  if ( *(_DWORD *)&runtime_writeBarrier.enabled )
  {
    dstb = (uintptr *)&v3->cachealloc.arg;
    runtime_writebarrierptr((uintptr *)&v3->cachealloc.first, 0);
    runtime_writebarrierptr(dstb, 0);
    v3 = h;
  }
  else
  {
    v3->cachealloc.first = 0;
    v3->cachealloc.arg = 0;
  }
  v3->cachealloc.list = 0;
  v3->cachealloc.chunk = 0;
  v3->cachealloc.nchunk = 0;
  v3->cachealloc.inuse = 0;
  if ( *(_DWORD *)&runtime_writeBarrier.enabled )
  {
    runtime_writebarrierptr((uintptr *)&v3->cachealloc.stat, (uintptr)&runtime_memstats.mcache_sys);
    v3 = h;
  }
  else
  {
    v3->cachealloc.stat = &runtime_memstats.mcache_sys;
  }
  v3->cachealloc.zero = 1;
  v3->specialfinalizeralloc.size = 24;
  if ( *(_DWORD *)&runtime_writeBarrier.enabled )
  {
    dsta = (uintptr *)&v3->specialfinalizeralloc.arg;
    runtime_writebarrierptr((uintptr *)&v3->specialfinalizeralloc.first, 0);
    runtime_writebarrierptr(dsta, 0);
    v3 = h;
  }
  else
  {
    v3->specialfinalizeralloc.first = 0;
    v3->specialfinalizeralloc.arg = 0;
  }
  v3->specialfinalizeralloc.list = 0;
  v3->specialfinalizeralloc.chunk = 0;
  v3->specialfinalizeralloc.nchunk = 0;
  v3->specialfinalizeralloc.inuse = 0;
  if ( *(_DWORD *)&runtime_writeBarrier.enabled )
  {
    runtime_writebarrierptr((uintptr *)&v3->specialfinalizeralloc.stat, (uintptr)&runtime_memstats.other_sys);
    v3 = h;
  }
  else
  {
    v3->specialfinalizeralloc.stat = &runtime_memstats.other_sys;
  }
  v3->specialfinalizeralloc.zero = 1;
  v3->specialprofilealloc.size = 12;
  if ( *(_DWORD *)&runtime_writeBarrier.enabled )
  {
    dst = (uintptr *)&v3->specialprofilealloc.arg;
    runtime_writebarrierptr((uintptr *)&v3->specialprofilealloc.first, 0);
    runtime_writebarrierptr(dst, 0);
    v3 = h;
  }
  else
  {
    v3->specialprofilealloc.first = 0;
    v3->specialprofilealloc.arg = 0;
  }
  v3->specialprofilealloc.list = 0;
  v3->specialprofilealloc.chunk = 0;
  v3->specialprofilealloc.nchunk = 0;
  v3->specialprofilealloc.inuse = 0;
  if ( *(_DWORD *)&runtime_writeBarrier.enabled )
  {
    runtime_writebarrierptr((uintptr *)&v3->specialprofilealloc.stat, (uintptr)&runtime_memstats.other_sys);
    v3 = h;
  }
  else
  {
    v3->specialprofilealloc.stat = &runtime_memstats.other_sys;
  }
  v3->specialprofilealloc.zero = 1;
  v3->spanalloc.zero = 0;
  for ( i = 0; i < 128; ++i )
  {
    if ( (unsigned int)i >= 0x80 )
      runtime_panicindex();
    v3->free[i].first = 0;
    v3->free[i].last = 0;
    v3->busy[i].first = 0;
    v3->busy[i].last = 0;
  }
  v3->busylarge.first = 0;
  v3->busylarge.last = 0;
  for ( j = 0; j < 134; j = v6 + 1 )
  {
    if ( (unsigned int)j >= 0x86 )
      runtime_panicindex();
    v6 = j;
    v7 = j << 6;
    *(&v3->central[0].mcentral.spanclass + v7) = v6;
    *(runtime_mspan **)((char *)&v3->central[0].mcentral.nonempty.first + v7) = 0;
    *(runtime_mspan **)((char *)&v3->central[0].mcentral.nonempty.last + v7) = 0;
    *(runtime_mspan **)((char *)&v3->central[0].mcentral.empty.first + v7) = 0;
    *(runtime_mspan **)((char *)&v3->central[0].mcentral.empty.last + v7) = 0;
  }
  if ( *(_DWORD *)&runtime_writeBarrier.enabled )
  {
    runtime_writebarrierptr((uintptr *)&v3->spans, spansStart);
    v3 = h;
  }
  else
  {
    v3->spans.array = (runtime_mspan **)spansStart;
  }
  v3->spans.len = 0;
  v3->spans.cap = spansBytes >> 2;
  runtime___ptr_mheap__setArenaUsed(v3, v3->arena_used, 0);
}

//----- (08064E10) --------------------------------------------------------
void __golang runtime___ptr_mheap__setArenaUsed(runtime_mheap_0 *h, uintptr arena_used, bool racemap)
{
  runtime___ptr_mheap__mapBits(h, arena_used);
  runtime___ptr_mheap__mapSpans(h, arena_used);
  h->arena_used = arena_used;
}

//----- (08064E70) --------------------------------------------------------
void __golang runtime___ptr_mheap__mapSpans(runtime_mheap_0 *h, uintptr arena_used)
{
  uintptr v2; // edx
  unsigned __int32 len; // ecx

  v2 = (~(runtime_physPageSize - 1) & (runtime_physPageSize + 4 * ((arena_used - h->arena_start) >> 13) - 1)) >> 2;
  len = h->spans.len;
  if ( len < v2 )
  {
    if ( v2 > h->spans.cap )
      runtime_panicslice();
    h->spans.len = v2;
    if ( len >= v2 )
      runtime_panicindex();
    runtime_sysMap(&h->spans.array[len], 4 * (v2 - len), h->arena_reserved, &runtime_memstats.other_sys);
  }
}

//----- (08064F20) --------------------------------------------------------
uintptr __golang runtime___ptr_mheap__reclaimList(runtime_mheap_0 *h, runtime_mSpanList_0 *list, uintptr npages)
{
  int v3; // eax
  uintptr v4; // ecx
  runtime_mspan *span; // ebx
  uintptr v6; // eax
  char v7; // [esp+Ch] [ebp-14h]
  uintptr snpages; // [esp+10h] [ebp-10h]
  uint32 sg; // [esp+14h] [ebp-Ch]
  uintptr n; // [esp+18h] [ebp-8h]
  uintptr na; // [esp+18h] [ebp-8h]

  v3 = dword_81490F0;
  sg = dword_81490F0;
  v4 = 0;
  while ( 2 )
  {
    na = v4;
    for ( span = list->first; ; span = span->next )
    {
      if ( !span )
        return v4;
      if ( span->sweepgen == v3 - 2 )
        break;
LABEL_5:
      if ( span->sweepgen != v3 - 1 )
        return v4;
    }
    runtime_internal_atomic_Cas();
    if ( !v7 )
    {
      v3 = sg;
      v4 = na;
      goto LABEL_5;
    }
    runtime___ptr_mSpanList__remove(list, span);
    runtime___ptr_mSpanList__insertBack(list, span);
    runtime_unlock(&h->lock);
    snpages = span->npages;
    if ( runtime___ptr_mspan__sweep(span, 0) )
      v6 = na + snpages;
    else
      v6 = na;
    n = v6;
    runtime_lock(&h->lock);
    if ( n < npages )
    {
      v3 = sg;
      v4 = n;
      continue;
    }
    return n;
  }
}
// 8064F8D: variable 'v7' is possibly undefined
// 81490F0: using guessed type int dword_81490F0;

//----- (08065050) --------------------------------------------------------
void __golang runtime___ptr_mheap__reclaim(runtime_mheap_0 *h, uintptr npage)
{
  signed __int32 j; // eax
  int v3; // eax
  uintptr v4; // ecx
  char *v5; // eax
  runtime_mheap_0 *v6; // [esp+0h] [ebp-1Ch]
  uintptr v7; // [esp+Ch] [ebp-10h]
  uintptr reclaimed; // [esp+10h] [ebp-Ch]
  uintptr reclaimeda; // [esp+10h] [ebp-Ch]
  __int32 i; // [esp+14h] [ebp-8h]
  __int32 i_0; // [esp+18h] [ebp-4h]

  for ( j = npage; j < 128; j = i_0 + 1 )
  {
    if ( (unsigned int)j >= 0x80 )
      runtime_panicindex();
    i_0 = j;
    if ( runtime___ptr_mheap__reclaimList(h, &h->busy[j], npage) )
      return;
  }
  if ( !runtime___ptr_mheap__reclaimList(h, &h->busylarge, npage) )
  {
    v3 = 0;
    v4 = 0;
    while ( 1 )
    {
      reclaimed = v4;
      if ( v3 >= (int)npage || v3 >= 128 )
        break;
      if ( (unsigned int)v3 >= 0x80 )
        runtime_panicindex();
      i = v3;
      v7 = runtime___ptr_mheap__reclaimList(h, &h->busy[v3], npage - v4);
      if ( reclaimed + v7 >= npage )
        return;
      v4 = reclaimed + v7;
      v3 = i + 1;
    }
    runtime_unlock(&h->lock);
    v5 = (char *)reclaimed;
    do
    {
      reclaimeda = (uintptr)v5;
      v6 = (runtime_mheap_0 *)runtime_sweepone();
      if ( v6 == (runtime_mheap_0 *)-1 )
        break;
      v5 = (char *)v6 + reclaimeda;
    }
    while ( (unsigned int)v6 + reclaimeda < npage );
    runtime_lock(&h->lock);
  }
}

//----- (080651A0) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
runtime_mspan *__golang runtime___ptr_mheap__alloc_m(
        runtime_mheap_0 *h,
        uintptr npage,
        runtime_spanClass spanclass,
        bool large)
{
  runtime_g *v4; // eax
  runtime_mheap_0 *v5; // eax
  char v6; // cl
  int pagesInUse; // edx
  int pagesInUse_high; // ebp
  unsigned int v9; // ecx
  string l; // [esp+0h] [ebp-1Ch]
  runtime_mspan *v11; // [esp+Ch] [ebp-10h]
  uint64 v12; // [esp+10h] [ebp-Ch]
  runtime_g *_g_; // [esp+18h] [ebp-4h]
  runtime_mspan *result; // [esp+30h] [ebp+14h]

  v4 = *(runtime_g **)(__readgsdword(0) - 4);
  if ( v4 != v4->m->g0 )
  {
    l.str = (uint8 *)"_mheap_alloc not on g0 stack";
    l.len = 28;
    runtime_throw(l);
    BUG();
  }
  _g_ = v4;
  runtime_lock(&h->lock);
  v5 = h;
  if ( !h->sweepdone )
  {
    if ( runtime_trace.enabled )
    {
      runtime_traceGCSweepStart();
      v5 = h;
    }
    runtime___ptr_mheap__reclaim(v5, npage);
    if ( runtime_trace.enabled )
      runtime_traceGCSweepDone();
  }
  runtime_memstats.heap_scan += _g_->m->mcache->local_scan;
  _g_->m->mcache->local_scan = 0;
  runtime_memstats.tinyallocs += _g_->m->mcache->local_tinyallocs;
  _g_->m->mcache->local_tinyallocs = 0;
  v11 = runtime___ptr_mheap__allocSpanLocked(h, npage, &runtime_memstats.heap_inuse);
  if ( v11 )
  {
    runtime_internal_atomic_Store();
    runtime___ptr_gcSweepBuf__push(&h->sweepSpans[(h->sweepgen >> 1) & 1], v11);
    v11->state = 1;
    v11->allocCount = 0;
    v11->spanclass = spanclass;
    v6 = spanclass >> 1;
    if ( spanclass >> 1 )
    {
      if ( (unsigned int)v6 >= 0x43 )
        runtime_panicindex();
      v11->elemsize = runtime_class_to_size[v6];
      v11->divShift = runtime_class_to_divmagic[v6].shift;
      v11->divMul = runtime_class_to_divmagic[v6].mul;
      v11->divShift2 = runtime_class_to_divmagic[v6].shift2;
      v11->baseMask = runtime_class_to_divmagic[v6].baseMask;
    }
    else
    {
      v11->elemsize = v11->npages << 13;
      v11->divShift = 0;
      v11->divMul = 0;
      v11->divShift2 = 0;
      v11->baseMask = 0;
    }
    pagesInUse = h->pagesInUse;
    pagesInUse_high = HIDWORD(h->pagesInUse);
    LODWORD(h->pagesInUse) = npage + pagesInUse;
    HIDWORD(h->pagesInUse) = __CFADD__(npage, pagesInUse) + pagesInUse_high;
    if ( *(&spanclass + 1) )
    {
      ++runtime_memstats.heap_objects;
      qword_8149168 += v11->elemsize;
      ++qword_8149170;
      v12 = runtime_internal_atomic_Xadd64(&runtime_memstats.heap_live, npage << 13);
      v9 = *(_DWORD *)(HIDWORD(v12) + 16);
      if ( v9 >= 0x80 )
        runtime___ptr_mSpanList__insertBack(&h->busylarge, (runtime_mspan *)HIDWORD(v12));
      else
        runtime___ptr_mSpanList__insertBack(&h->busy[v9], (runtime_mspan *)HIDWORD(v12));
    }
  }
  if ( runtime_gcBlackenEnabled )
    runtime___ptr_gcControllerState__revise(&runtime_gcController);
  if ( runtime_trace.enabled )
    runtime_traceHeapAlloc();
  runtime_unlock(&h->lock);
  return result;
}
// 80651A0: variables would overlap: ^28.1 and ^28.2
// 80651A0: inconsistent variable size for '^28.1(spanclass)'
// 8149168: using guessed type __int64 qword_8149168;
// 8149170: using guessed type __int64 qword_8149170;

//----- (08065510) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
runtime_mspan *__golang runtime___ptr_mheap__alloc(
        runtime_mheap_0 *h,
        uintptr npage,
        runtime_spanClass spanclass,
        bool large,
        bool needzero)
{
  runtime_mspan *s[5]; // [esp+8h] [ebp-18h] BYREF
  unsigned __int16 v6; // [esp+1Ch] [ebp-4h]
  runtime_mspan *result; // [esp+38h] [ebp+18h]

  s[0] = 0;
  ((void (*)(void))loc_808FD8B)();
  s[1] = (runtime_mspan *)runtime___ptr_mheap__alloc_func1;
  s[2] = (runtime_mspan *)s;
  s[3] = (runtime_mspan *)h;
  s[4] = (runtime_mspan *)npage;
  v6 = __PAIR16__(*(&spanclass + 1), spanclass);
  runtime_systemstack();
  if ( s[0] )
  {
    if ( *(&spanclass + 2) )
    {
      if ( s[0]->needzero )
        runtime_memclrNoHeapPointers();
    }
    s[0]->needzero = 0;
  }
  return result;
}
// 8065510: inconsistent variable size for '^2C.1(spanclass)'

//----- (080655D0) --------------------------------------------------------
runtime_mspan *__golang runtime___ptr_mheap__allocManual(runtime_mheap_0 *h, uintptr npage, uint64 *stat)
{
  runtime_mspan *v3; // [esp+Ch] [ebp-8h]

  runtime_lock(&h->lock);
  v3 = runtime___ptr_mheap__allocSpanLocked(h, npage, stat);
  if ( v3 )
  {
    v3->state = 2;
    v3->manualFreeList = 0;
    v3->allocCount = 0;
    v3->spanclass = 0;
    v3->nelems = 0;
    v3->elemsize = 0;
    v3->limit = v3->startAddr + (v3->npages << 13);
    runtime_memstats.heap_sys -= v3->npages << 13;
  }
  runtime_unlock(&h->lock);
  return v3;
}

//----- (080656A0) --------------------------------------------------------
runtime_mspan *__golang runtime___ptr_mheap__allocSpanLocked(runtime_mheap_0 *h, uintptr npage, uint64 *stat)
{
  signed __int32 i; // eax
  runtime_mspan *first; // ebp
  runtime_mspan *v5; // eax
  uintptr npages; // ecx
  uintptr v7; // edx
  uintptr v8; // ebp
  unsigned int j; // ebx
  unsigned __int32 v10; // ebp
  uintptr v11; // edx
  runtime_mspan *s; // eax
  uintptr v13; // edx
  uintptr startAddr; // ebx
  unsigned __int32 v15; // ebp
  unsigned __int32 v16; // ebp
  string list; // [esp+0h] [ebp-20h]
  string lista; // [esp+0h] [ebp-20h]
  string listb; // [esp+0h] [ebp-20h]
  int64 unusedsince; // [esp+10h] [ebp-10h]
  uintptr unusedsince_4; // [esp+14h] [ebp-Ch]
  runtime_mspan *span; // [esp+18h] [ebp-8h]
  runtime_mspan *v23; // [esp+1Ch] [ebp-4h]

  for ( i = npage; i < 128; ++i )
  {
    if ( (unsigned int)i >= 0x80 )
      runtime_panicindex();
    first = h->free[i].first;
    if ( first )
    {
      v23 = h->free[i].first;
      runtime___ptr_mSpanList__remove(&h->free[i], first);
      v5 = v23;
      goto LABEL_7;
    }
  }
  v5 = runtime___ptr_mheap__allocLarge(h, npage);
  if ( !v5 )
  {
    if ( !runtime___ptr_mheap__grow(h, npage) )
      return 0;
    v5 = runtime___ptr_mheap__allocLarge(h, npage);
    if ( !v5 )
      return 0;
  }
LABEL_7:
  if ( v5->state != 3 )
  {
    listb.str = (uint8 *)"MHeap_AllocLocked - MSpan not free";
    listb.len = 34;
    runtime_throw(listb);
    BUG();
  }
  npages = v5->npages;
  v7 = npage;
  if ( npages < npage )
  {
    lista.str = (uint8 *)"MHeap_AllocLocked - bad npages";
    lista.len = 30;
    runtime_throw(lista);
    BUG();
  }
  span = v5;
  if ( v5->npreleased )
  {
    runtime_sysUsed((void *)v5->startAddr, npages << 13);
    runtime_memstats.heap_released -= span->npreleased << 13;
    span->npreleased = 0;
    v5 = span;
    v7 = npage;
  }
  if ( v5->npages > v7 )
  {
    s = (runtime_mspan *)runtime___ptr_fixalloc__alloc(&h->spanalloc);
    v13 = span->npages;
    startAddr = span->startAddr;
    s->next = 0;
    s->prev = 0;
    s->list = 0;
    s->startAddr = (npage << 13) + startAddr;
    s->npages = v13 - npage;
    *(_DWORD *)&s->allocCount = 0;
    s->elemsize = 0;
    s->state = 0;
    LODWORD(s->unusedsince) = 0;
    HIDWORD(s->unusedsince) = 0;
    s->npreleased = 0;
    s->speciallock.key = 0;
    s->specials = 0;
    s->needzero = 0;
    s->freeindex = 0;
    s->allocBits = 0;
    s->gcmarkBits = 0;
    span->npages = npage;
    v15 = (s->startAddr - h->arena_start) >> 13;
    if ( v15 )
    {
      if ( v15 - 1 >= h->spans.len )
        runtime_panicindex();
      h->spans.array[v15 - 1] = span;
    }
    if ( v15 >= h->spans.len )
      runtime_panicindex();
    h->spans.array[v15] = s;
    v16 = v15 + s->npages - 1;
    if ( v16 >= h->spans.len )
      runtime_panicindex();
    h->spans.array[v16] = s;
    s->needzero = span->needzero;
    span->state = 2;
    s->state = 2;
    LODWORD(unusedsince) = HIDWORD(span->unusedsince);
    runtime___ptr_mheap__freeSpanLocked(h, s, 0, span->unusedsince, unusedsince);
    v5 = span;
    span->state = 3;
    v7 = npage;
  }
  LODWORD(v5->unusedsince) = 0;
  HIDWORD(v5->unusedsince) = 0;
  v8 = (v5->startAddr - h->arena_start) >> 13;
  unusedsince_4 = v8;
  for ( j = 0; j < v7; ++j )
  {
    v10 = j + v8;
    if ( v10 >= h->spans.len )
      runtime_panicindex();
    h->spans.array[v10] = v5;
    v8 = unusedsince_4;
  }
  v11 = v7 << 13;
  *stat += v11;
  runtime_memstats.heap_idle -= v11;
  if ( v5->list )
  {
    list.str = (uint8 *)"still in list";
    list.len = 13;
    runtime_throw(list);
    BUG();
  }
  return v5;
}
// 80658F5: variable 'unusedsince' is possibly undefined

//----- (08065A40) --------------------------------------------------------
runtime_mspan *__golang runtime___ptr_mheap__allocLarge(runtime_mheap_0 *h, uintptr npage)
{
  return runtime___ptr_mTreap__remove(&h->freelarge, npage);
}

//----- (08065A90) --------------------------------------------------------
bool __golang runtime___ptr_mheap__grow(runtime_mheap_0 *h, uintptr npage)
{
  uintptr v2; // ecx
  void *v3; // eax
  uintptr v4; // ecx
  runtime_mspan *v5; // eax
  unsigned __int32 v6; // ebx
  unsigned __int32 v7; // edx
  uint64 heap_sys; // kr00_8
  string v9; // [esp+0h] [ebp-30h]
  string v10; // [esp+0h] [ebp-30h]
  string v11; // [esp+0h] [ebp-30h]
  int64 unusedsince; // [esp+10h] [ebp-20h]
  uintptr unusedsince_4; // [esp+14h] [ebp-1Ch]
  unsigned int v14; // [esp+18h] [ebp-18h]
  unsigned int v15; // [esp+1Ch] [ebp-14h]
  uintptr v16; // [esp+20h] [ebp-10h]
  uintptr v17; // [esp+24h] [ebp-Ch]
  void *v; // [esp+28h] [ebp-8h]
  runtime_mspan *s; // [esp+2Ch] [ebp-4h]

  unusedsince_4 = ((npage + 7) & 0xFFFFFFF8) << 13;
  if ( unusedsince_4 >= 0x100000 )
    v2 = ((npage + 7) & 0xFFFFFFF8) << 13;
  else
    v2 = 0x100000;
  v17 = v2;
  v3 = runtime___ptr_mheap__sysAlloc(h, v2);
  if ( v3 )
  {
    v4 = v17;
  }
  else
  {
    v4 = v17;
    if ( v17 > unusedsince_4 )
    {
      v3 = runtime___ptr_mheap__sysAlloc(h, unusedsince_4);
      v4 = ((npage + 7) & 0xFFFFFFF8) << 13;
    }
    if ( !v3 )
    {
      v16 = v4;
      heap_sys = runtime_memstats.heap_sys;
      v14 = HIDWORD(heap_sys);
      v15 = heap_sys;
      runtime_printlock();
      v9.str = (uint8 *)"runtime: out of memory: cannot allocate ";
      v9.len = 40;
      runtime_printstring(v9);
      runtime_printint(v16);
      v10.str = (uint8 *)"-byte block (";
      v10.len = 13;
      runtime_printstring(v10);
      runtime_printuint(__PAIR64__(v14, v15));
      v11.str = (uint8 *)" in use)\n";
      v11.len = 9;
      runtime_printstring(v11);
      runtime_printunlock();
      return 0;
    }
  }
  v = v3;
  HIDWORD(unusedsince) = v4;
  v5 = (runtime_mspan *)runtime___ptr_fixalloc__alloc(&h->spanalloc);
  v5->next = 0;
  v5->prev = 0;
  v5->list = 0;
  v5->startAddr = (uintptr)v;
  v5->npages = HIDWORD(unusedsince) >> 13;
  *(_DWORD *)&v5->allocCount = 0;
  v5->elemsize = 0;
  v5->state = 0;
  LODWORD(v5->unusedsince) = 0;
  HIDWORD(v5->unusedsince) = 0;
  v5->npreleased = 0;
  v5->speciallock.key = 0;
  v5->specials = 0;
  v5->needzero = 0;
  v5->freeindex = 0;
  v5->allocBits = 0;
  v5->gcmarkBits = 0;
  v6 = (v5->startAddr - h->arena_start) >> 13;
  v7 = v6;
  while ( v6 < v7 + v5->npages )
  {
    if ( v6 >= h->spans.len )
      runtime_panicindex();
    h->spans.array[v6++] = v5;
  }
  s = v5;
  runtime_internal_atomic_Store();
  s->state = 1;
  h->pagesInUse += s->npages;
  LODWORD(unusedsince) = 0;
  runtime___ptr_mheap__freeSpanLocked(h, s, 0, 0, unusedsince);
  return 1;
}

//----- (08065D10) --------------------------------------------------------
void __golang runtime___ptr_mheap__freeSpan(runtime_mheap_0 *h, runtime_mspan *s, int32 acct)
{
  runtime_systemstack();
}

//----- (08065D60) --------------------------------------------------------
#error "8065DF1: call analysis failed (funcsize=43)"

//----- (08065E10) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
void __golang runtime___ptr_mheap__freeSpanLocked(
        runtime_mheap_0 *h,
        runtime_mspan *s,
        bool acctinuse,
        bool acctidle,
        int64 unusedsince)
{
  runtime_mSpanState state; // cl
  runtime_mheap_0 *v6; // ebx
  uintptr pagesInUse; // ecx
  uintptr npages; // edx
  bool v9; // cf
  uintptr v10; // ecx
  int pagesInUse_high; // edx
  uintptr v12; // ecx
  runtime_mSpanList_0 *p_busylarge; // ecx
  runtime_mspan *v14; // ecx
  uintptr v15; // ebx
  runtime_mspan *span; // edx
  unsigned __int32 v17; // ebx
  unsigned int v18; // ebp
  runtime_mheap_0 *v19; // ecx
  unsigned __int32 v20; // eax
  uintptr v21; // ebx
  runtime_mspan *v22; // ebp
  uintptr v23; // eax
  unsigned int v24; // eax
  uintptr v25; // edx
  int64 list; // [esp+0h] [ebp-20h]
  string lista; // [esp+0h] [ebp-20h]
  string listb; // [esp+0h] [ebp-20h]
  string listc; // [esp+0h] [ebp-20h]
  string listd; // [esp+0h] [ebp-20h]
  string liste; // [esp+0h] [ebp-20h]
  string listf; // [esp+0h] [ebp-20h]
  string listg; // [esp+0h] [ebp-20h]
  string listh; // [esp+0h] [ebp-20h]
  string listi; // [esp+0h] [ebp-20h]
  uint16 allocCount; // [esp+Ah] [ebp-16h]
  uintptr _r0; // [esp+Ch] [ebp-14h]
  uint32 v; // [esp+14h] [ebp-Ch]
  uint32 v_4; // [esp+18h] [ebp-8h]
  runtime_mspan *v40; // [esp+1Ch] [ebp-4h]

  state = s->state;
  if ( state == 1 )
  {
    allocCount = s->allocCount;
    if ( allocCount || (v6 = h, s->sweepgen != h->sweepgen) )
    {
      v_4 = s->sweepgen;
      v = h->sweepgen;
      _r0 = s->startAddr;
      runtime_printlock();
      lista.str = (uint8 *)"MHeap_FreeSpanLocked - span ";
      lista.len = 28;
      runtime_printstring(lista);
      runtime_printpointer(s);
      listb.str = (uint8 *)" ptr ";
      listb.len = 5;
      runtime_printstring(listb);
      runtime_printhex(_r0);
      listc.str = (uint8 *)" allocCount ";
      listc.len = 12;
      runtime_printstring(listc);
      runtime_printint(allocCount);
      listd.str = (uint8 *)" sweepgen ";
      listd.len = 10;
      runtime_printstring(listd);
      runtime_printint(v_4);
      liste.str = (uint8 *)"/";
      liste.len = 1;
      runtime_printstring(liste);
      runtime_printint(v);
      listf.str = (uint8 *)"\n";
      listf.len = 1;
      runtime_printstring(listf);
      runtime_printunlock();
      listg.str = (uint8 *)"MHeap_FreeSpanLocked - invalid free";
      listg.len = 35;
      runtime_throw(listg);
      BUG();
    }
    pagesInUse = h->pagesInUse;
    npages = s->npages;
    v9 = pagesInUse < npages;
    v10 = pagesInUse - npages;
    pagesInUse_high = HIDWORD(h->pagesInUse);
    LODWORD(h->pagesInUse) = v10;
    HIDWORD(h->pagesInUse) = pagesInUse_high - v9;
  }
  else
  {
    if ( state != 2 )
    {
      listi.str = (uint8 *)"MHeap_FreeSpanLocked - invalid span state";
      listi.len = 41;
      runtime_throw(listi);
      BUG();
    }
    if ( s->allocCount )
    {
      listh.str = (uint8 *)"MHeap_FreeSpanLocked - invalid stack free";
      listh.len = 41;
      runtime_throw(listh);
      BUG();
    }
    v6 = h;
  }
  if ( acctinuse )
    runtime_memstats.heap_inuse -= s->npages << 13;
  if ( *(&acctinuse + 1) )
    runtime_memstats.heap_idle += s->npages << 13;
  s->state = 3;
  if ( s->list )
  {
    v12 = s->npages;
    if ( v12 >= 0x80 )
      p_busylarge = &v6->busylarge;
    else
      p_busylarge = &v6->busy[v12];
    runtime___ptr_mSpanList__remove(p_busylarge, s);
  }
  v14 = s;
  s->unusedsince = __PAIR64__(unusedsince, acctidle);
  if ( !acctidle && (_DWORD)unusedsince == 0 )
  {
    runtime_nanotime();
    s->unusedsince = list;
    v14 = s;
  }
  v14->npreleased = 0;
  v15 = (v14->startAddr - h->arena_start) >> 13;
  if ( v15 )
  {
    if ( v15 - 1 >= h->spans.len )
      runtime_panicindex();
    span = h->spans.array[v15 - 1];
    if ( span )
    {
      if ( span->state == 3 )
      {
        v14->startAddr = span->startAddr;
        v14->npages += span->npages;
        v14->npreleased = span->npreleased;
        v14->needzero |= span->needzero;
        v17 = v15 - span->npages;
        if ( v17 >= h->spans.len )
          runtime_panicindex();
        v40 = span;
        h->spans.array[v17] = v14;
        v18 = span->npages;
        if ( v18 < 0x80 )
          runtime___ptr_mSpanList__remove(&h->free[v18], span);
        else
          runtime___ptr_mTreap__removeSpan(&h->freelarge, span);
        v40->state = 0;
        v19 = h;
        h->spanalloc.inuse -= h->spanalloc.size;
        v40->next = (runtime_mspan *)h->spanalloc.list;
        h->spanalloc.list = (runtime_mlink *)v40;
        v20 = v17;
      }
      else
      {
        v19 = h;
        v20 = v15;
      }
    }
    else
    {
      v19 = h;
      v20 = v15;
    }
  }
  else
  {
    v19 = h;
    v20 = 0;
  }
  v21 = s->npages;
  if ( v21 + v20 < v19->spans.len )
  {
    v22 = (runtime_mspan *)*((_DWORD *)&v19->spans.array[v21] + v20);
    if ( v22 )
    {
      if ( v22->state == 3 )
      {
        s->npages = v22->npages + v21;
        s->npreleased += v22->npreleased;
        s->needzero |= v22->needzero;
        v23 = s->npages + v20 - 1;
        if ( v23 >= v19->spans.len )
          runtime_panicindex();
        v19->spans.array[v23] = s;
        v24 = v22->npages;
        if ( v24 < 0x80 )
          runtime___ptr_mSpanList__remove(&v19->free[v24], v22);
        else
          runtime___ptr_mTreap__removeSpan(&v19->freelarge, v22);
        v22->state = 0;
        v19 = h;
        h->spanalloc.inuse -= h->spanalloc.size;
        v22->next = (runtime_mspan *)h->spanalloc.list;
        h->spanalloc.list = (runtime_mlink *)v22;
      }
    }
  }
  v25 = s->npages;
  if ( v25 < 0x80 )
    runtime___ptr_mSpanList__insert(&v19->free[v25], s);
  else
    runtime___ptr_mTreap__insert(&v19->freelarge, s);
}
// 8065E10: variables would overlap: ^2C.1 and ^2C.2
// 8065E10: inconsistent variable size for '^2C.1(acctinuse)'
// 80E0D8C: using guessed type char asc_80E0D8C;

//----- (08066330) --------------------------------------------------------
uintptr __golang runtime_scavengeTreapNode(runtime_treapNode *t, uint64 now, uint64 limit)
{
  runtime_mspan *spanKey; // eax
  uintptr npreleased; // ecx
  uintptr npages; // edx
  char *v; // ebx
  unsigned int v7; // edx
  uintptr v8; // esi
  unsigned int v9; // esi
  uintptr n; // edx
  uintptr v11; // esi

  spanKey = t->spanKey;
  if ( ((int)now - LODWORD(spanKey->unusedsince) <= (unsigned int)limit
     || (now - spanKey->unusedsince) >> 32 != HIDWORD(limit))
    && (now - spanKey->unusedsince) >> 32 <= HIDWORD(limit) )
  {
    return 0;
  }
  npreleased = spanKey->npreleased;
  npages = spanKey->npages;
  if ( npreleased == npages )
    return 0;
  v = (char *)spanKey->startAddr;
  v7 = (unsigned int)&v[0x2000 * npages];
  if ( runtime_physPageSize <= 0x2000 )
  {
    v9 = v7;
  }
  else
  {
    v8 = ~(runtime_physPageSize - 1);
    v = (char *)(v8 & (unsigned int)&v[runtime_physPageSize - 1]);
    v9 = v7 & v8;
    if ( v9 <= (unsigned int)v )
      return 0;
  }
  n = v9 - (_DWORD)v;
  v11 = v9 - (_DWORD)v - (npreleased << 13);
  if ( runtime_physPageSize <= 0x2000 || v11 )
  {
    runtime_memstats.heap_released += v11;
    spanKey->npreleased = n >> 13;
    runtime_sysUnused(v, n);
    return v11;
  }
  return 0;
}

//----- (08066450) --------------------------------------------------------
uintptr __golang runtime_scavengelist(runtime_mSpanList_0 *list, uint64 now, uint64 limit)
{
  char *v; // edi
  runtime_mspan *first; // eax
  uintptr v5; // ecx
  unsigned int v6; // esi
  char *v7; // ebx
  unsigned int v8; // ebx
  unsigned int v9; // et1
  uintptr npreleased; // ebx
  uintptr npages; // esi
  unsigned int v12; // esi
  uintptr v13; // edx
  unsigned int v14; // edx
  uintptr n; // esi
  int v16; // edx
  uintptr v17; // eax
  uintptr sumreleased; // [esp+8h] [ebp-Ch]
  uintptr released; // [esp+Ch] [ebp-8h]
  runtime_mspan *s; // [esp+10h] [ebp-4h]

  first = list->first;
  if ( list->first )
  {
    v5 = 0;
    while ( 1 )
    {
      if ( !first )
        return v5;
      s = first;
      v6 = (now - first->unusedsince) >> 32;
      v7 = v;
      LOBYTE(v7) = v6 == HIDWORD(limit);
      v9 = (unsigned int)v7;
      v8 = now - LODWORD(first->unusedsince);
      LOBYTE(v8) = v8 > (unsigned int)limit;
      v = (char *)(v8 & v9);
      if ( !(v8 & (unsigned __int8)v9 | (v6 > HIDWORD(limit))) )
      {
        v17 = v5;
        goto LABEL_12;
      }
      npreleased = first->npreleased;
      npages = first->npages;
      if ( npreleased == npages )
        break;
      v = (char *)first->startAddr;
      v12 = (unsigned int)&v[0x2000 * npages];
      if ( runtime_physPageSize <= 0x2000 )
      {
        v14 = v12;
      }
      else
      {
        v13 = ~(runtime_physPageSize - 1);
        v = (char *)(v13 & (unsigned int)&v[runtime_physPageSize - 1]);
        v14 = v12 & v13;
        if ( v14 <= (unsigned int)v )
          goto LABEL_3;
      }
      sumreleased = v5;
      n = v14 - (_DWORD)v;
      v16 = v14 - (_DWORD)v - (npreleased << 13);
      if ( runtime_physPageSize <= 0x2000 || v16 )
      {
        released = v16;
        runtime_memstats.heap_released += (unsigned int)v16;
        first->npreleased = n >> 13;
        runtime_sysUnused(v, n);
        v17 = sumreleased + released;
LABEL_12:
        v5 = v17;
        first = s;
      }
LABEL_3:
      first = first->next;
    }
    v17 = v5;
    goto LABEL_12;
  }
  return 0;
}
// 80664A1: variable 'v' is possibly undefined

//----- (08066590) --------------------------------------------------------
void __golang runtime___ptr_mheap__scavenge(runtime_mheap_0 *h, int32 k, uint64 now, uint64 limit)
{
  int v4; // eax
  uintptr j; // ecx
  unsigned int v6; // edx
  string lc; // [esp+0h] [ebp-4Ch]
  string ld; // [esp+0h] [ebp-4Ch]
  string le; // [esp+0h] [ebp-4Ch]
  string lf; // [esp+0h] [ebp-4Ch]
  string lg; // [esp+0h] [ebp-4Ch]
  string lh; // [esp+0h] [ebp-4Ch]
  uint64 li; // [esp+0h] [ebp-4Ch]
  string lj; // [esp+0h] [ebp-4Ch]
  string l; // [esp+0h] [ebp-4Ch]
  string la; // [esp+0h] [ebp-4Ch]
  string lb; // [esp+0h] [ebp-4Ch]
  uintptr v18; // [esp+14h] [ebp-38h]
  uintptr sumreleased; // [esp+18h] [ebp-34h]
  __int32 i; // [esp+1Ch] [ebp-30h]
  unsigned int heap_released_high; // [esp+20h] [ebp-2Ch]
  unsigned int heap_sys_high; // [esp+24h] [ebp-28h]
  uint64 heap_idle; // [esp+28h] [ebp-24h]
  uint64 heap_inuse; // [esp+30h] [ebp-1Ch]
  unsigned int v25; // [esp+38h] [ebp-14h]
  unsigned int heap_released; // [esp+3Ch] [ebp-10h]
  unsigned int heap_sys; // [esp+40h] [ebp-Ch]
  uintptr v28; // [esp+44h] [ebp-8h]
  runtime_g *gp; // [esp+48h] [ebp-4h]

  gp = *(runtime_g **)(__readgsdword(0) - 4);
  ++gp->m->mallocing;
  runtime_lock(&h->lock);
  v4 = 0;
  for ( j = 0; ; j = sumreleased + v18 )
  {
    sumreleased = j;
    if ( v4 >= 128 )
      break;
    if ( (unsigned int)v4 >= 0x80 )
      runtime_panicindex();
    i = v4;
    v18 = runtime_scavengelist(&h->free[v4], now, limit);
    v4 = i + 1;
  }
  v28 = runtime_scavengetreap(h->freelarge.treap, now, limit);
  runtime_unlock(&h->lock);
  --gp->m->mallocing;
  if ( runtime_debug.gctrace > 0 )
  {
    if ( sumreleased + v28 )
    {
      runtime_printlock();
      l.str = (uint8 *)"scvg";
      l.len = 4;
      runtime_printstring(l);
      runtime_printint(k);
      la.str = (uint8 *)": ";
      la.len = 2;
      runtime_printstring(la);
      runtime_printint((sumreleased + v28) >> 20);
      lb.str = (uint8 *)" MB released\n";
      lb.len = 13;
      runtime_printstring(lb);
      runtime_printunlock();
    }
    heap_sys = runtime_memstats.heap_sys;
    heap_released = runtime_memstats.heap_released;
    v25 = LODWORD(runtime_memstats.heap_sys) - LODWORD(runtime_memstats.heap_released);
    heap_inuse = runtime_memstats.heap_inuse;
    heap_idle = runtime_memstats.heap_idle;
    heap_sys_high = HIDWORD(runtime_memstats.heap_sys);
    heap_released_high = HIDWORD(runtime_memstats.heap_released);
    runtime_printlock();
    lc.str = (uint8 *)"scvg";
    lc.len = 4;
    runtime_printstring(lc);
    runtime_printint(k);
    ld.str = (uint8 *)": inuse: ";
    ld.len = 9;
    runtime_printstring(ld);
    runtime_printuint(heap_inuse >> 20);
    le.str = (uint8 *)", idle: ";
    le.len = 8;
    runtime_printstring(le);
    runtime_printuint(heap_idle >> 20);
    lf.str = (uint8 *)", sys: ";
    lf.len = 7;
    runtime_printstring(lf);
    runtime_printuint(__PAIR64__(HIDWORD(runtime_memstats.heap_sys), heap_sys) >> 20);
    lg.str = (uint8 *)", released: ";
    lg.len = 12;
    runtime_printstring(lg);
    runtime_printuint(__PAIR64__(HIDWORD(runtime_memstats.heap_released), heap_released) >> 20);
    lh.str = (uint8 *)", consumed: ";
    lh.len = 12;
    runtime_printstring(lh);
    v6 = (__PAIR64__(heap_sys_high, heap_sys) - __PAIR64__(heap_released_high, heap_released)) >> 32;
    LODWORD(li) = (v25 >> 20) | (v6 << 12);
    HIDWORD(li) = v6 >> 20;
    runtime_printuint(li);
    lj.str = (uint8 *)" (MB)\n";
    lj.len = 6;
    runtime_printstring(lj);
    runtime_printunlock();
  }
}

//----- (08066900) --------------------------------------------------------
void __golang runtime___ptr_mSpanList__remove(runtime_mSpanList_0 *list, runtime_mspan *span)
{
  string s; // [esp+0h] [ebp-14h]
  string sa; // [esp+0h] [ebp-14h]
  string sb; // [esp+0h] [ebp-14h]
  string sc; // [esp+0h] [ebp-14h]
  string sd; // [esp+0h] [ebp-14h]
  string se; // [esp+0h] [ebp-14h]
  string sf; // [esp+0h] [ebp-14h]
  uintptr v; // [esp+8h] [ebp-Ch]
  runtime_mspan *v_4; // [esp+Ch] [ebp-8h]
  runtime_mSpanList_0 *p; // [esp+10h] [ebp-4h]

  if ( span->list != list )
  {
    p = span->list;
    v = span->npages;
    v_4 = span->prev;
    runtime_printlock();
    s.str = (uint8 *)"runtime: failed MSpanList_Remove span.npages=";
    s.len = 45;
    runtime_printstring(s);
    runtime_printint(v);
    sa.str = (uint8 *)" span=";
    sa.len = 6;
    runtime_printstring(sa);
    runtime_printpointer(span);
    sb.str = (uint8 *)" prev=";
    sb.len = 6;
    runtime_printstring(sb);
    runtime_printpointer(v_4);
    sc.str = (uint8 *)" span.list=";
    sc.len = 11;
    runtime_printstring(sc);
    runtime_printpointer(p);
    sd.str = (uint8 *)" list=";
    sd.len = 6;
    runtime_printstring(sd);
    runtime_printpointer(list);
    se.str = (uint8 *)"\n";
    se.len = 1;
    runtime_printstring(se);
    runtime_printunlock();
    sf.str = (uint8 *)"MSpanList_Remove";
    sf.len = 16;
    runtime_throw(sf);
    BUG();
  }
  if ( list->first == span )
    list->first = span->next;
  else
    span->prev->next = span->next;
  if ( span == list->last )
    list->last = span->prev;
  else
    span->next->prev = span->prev;
  span->next = 0;
  span->prev = 0;
  span->list = 0;
}

//----- (08066A70) --------------------------------------------------------
void __golang runtime___ptr_mSpanList__insert(runtime_mSpanList_0 *list, runtime_mspan *span)
{
  string s; // [esp+0h] [ebp-14h]
  string sa; // [esp+0h] [ebp-14h]
  runtime_mSpanList_0 *v4; // [esp+8h] [ebp-Ch]
  runtime_mspan *prev; // [esp+Ch] [ebp-8h]
  runtime_mspan *p; // [esp+10h] [ebp-4h]

  p = span->next;
  if ( span->next || span->prev || span->list )
  {
    prev = span->prev;
    v4 = span->list;
    runtime_printlock();
    s.str = (uint8 *)"runtime: failed MSpanList_Insert";
    s.len = 32;
    runtime_printstring(s);
    runtime_printsp();
    runtime_printpointer(span);
    runtime_printsp();
    runtime_printpointer(p);
    runtime_printsp();
    runtime_printpointer(prev);
    runtime_printsp();
    runtime_printpointer(v4);
    runtime_printnl();
    runtime_printunlock();
    sa.str = (uint8 *)"MSpanList_Insert";
    sa.len = 16;
    runtime_throw(sa);
    BUG();
  }
  span->next = list->first;
  if ( list->first )
    list->first->prev = span;
  else
    list->last = span;
  list->first = span;
  span->list = list;
}

//----- (08066B60) --------------------------------------------------------
void __golang runtime___ptr_mSpanList__insertBack(runtime_mSpanList_0 *list, runtime_mspan *span)
{
  runtime_mspan *last; // edx
  string s; // [esp+0h] [ebp-14h]
  string sa; // [esp+0h] [ebp-14h]
  runtime_mSpanList_0 *v5; // [esp+8h] [ebp-Ch]
  runtime_mspan *prev; // [esp+Ch] [ebp-8h]
  runtime_mspan *p; // [esp+10h] [ebp-4h]

  p = span->next;
  if ( span->next || span->prev || span->list )
  {
    prev = span->prev;
    v5 = span->list;
    runtime_printlock();
    s.str = (uint8 *)"runtime: failed MSpanList_InsertBack";
    s.len = 36;
    runtime_printstring(s);
    runtime_printsp();
    runtime_printpointer(span);
    runtime_printsp();
    runtime_printpointer(p);
    runtime_printsp();
    runtime_printpointer(prev);
    runtime_printsp();
    runtime_printpointer(v5);
    runtime_printnl();
    runtime_printunlock();
    sa.str = (uint8 *)"MSpanList_InsertBack";
    sa.len = 20;
    runtime_throw(sa);
    BUG();
  }
  span->prev = list->last;
  last = list->last;
  if ( last )
    last->next = span;
  else
    list->first = span;
  list->last = span;
  span->list = list;
}

//----- (08066C50) --------------------------------------------------------
void __golang runtime___ptr_mSpanList__takeAll(runtime_mSpanList_0 *list, runtime_mSpanList_0 *other)
{
  runtime_mspan *first; // ecx
  runtime_mspan *last; // ecx

  first = other->first;
  if ( other->first )
  {
    while ( first )
    {
      first->list = list;
      first = first->next;
    }
    if ( list->first )
    {
      other->last->next = list->first;
      list->first->prev = other->last;
      list->first = other->first;
    }
    else
    {
      last = other->last;
      list->first = other->first;
      list->last = last;
    }
    other->first = 0;
    other->last = 0;
  }
}

//----- (08066CC0) --------------------------------------------------------
bool __golang runtime_addspecial(void *p, runtime_special *s)
{
  runtime_mspan *v2; // ecx
  int v3; // eax
  char *v4; // eax
  runtime_special *i; // ecx
  runtime_special *next; // ebx
  char *offset; // ebp
  bool v8; // cf
  bool v9; // zf
  int v10; // eax
  int32 locks; // edx
  int v12; // eax
  int32 v13; // edx
  unsigned int v14; // ecx
  string v15; // [esp+0h] [ebp-20h]
  uint8 kind; // [esp+Bh] [ebp-15h]
  uintptr _r0; // [esp+Ch] [ebp-14h]
  runtime_mspan *s_0; // [esp+14h] [ebp-Ch]
  runtime_m *mp; // [esp+18h] [ebp-8h]
  runtime_mutex_0 *l; // [esp+1Ch] [ebp-4h]

  if ( (unsigned int)p < dword_81493A8 || (unsigned int)p >= dword_81493AC )
  {
    v2 = 0;
  }
  else
  {
    v14 = ((unsigned int)p - dword_81493A8) >> 13;
    if ( v14 >= dword_814910C )
      runtime_panicindex();
    v2 = *(runtime_mspan **)(dword_8149108 + 4 * v14);
    if ( !v2 || (unsigned int)p < v2->startAddr || (unsigned int)p >= v2->limit || v2->state != 1 )
      v2 = 0;
  }
  if ( !v2 )
  {
    v15.str = (uint8 *)"addspecial on invalid pointer";
    v15.len = 29;
    runtime_throw(v15);
    BUG();
  }
  s_0 = v2;
  v3 = *(_DWORD *)(__readgsdword(0) - 4);
  ++*(_DWORD *)(*(_DWORD *)(v3 + 24) + 120);
  mp = *(runtime_m **)(v3 + 24);
  runtime___ptr_mspan__ensureSwept(v2);
  kind = s->kind;
  l = &s_0->speciallock;
  _r0 = s_0->startAddr;
  runtime_lock(&s_0->speciallock);
  v4 = (char *)p - _r0;
  for ( i = (runtime_special *)&s_0->specials; ; i = i->next )
  {
    next = i->next;
    if ( !i->next )
    {
LABEL_13:
      s->offset = (unsigned __int16)v4;
      s->next = i->next;
      i->next = s;
      runtime_unlock(l);
      v10 = *(_DWORD *)(__readgsdword(0) - 4);
      locks = mp->locks;
      mp->locks = locks - 1;
      if ( locks == 1 )
      {
        if ( *(_BYTE *)(v10 + 108) )
          *(_DWORD *)(v10 + 8) = -1314;
      }
      return 1;
    }
    offset = (char *)next->offset;
    v8 = v4 < offset;
    v9 = v4 == offset;
    if ( v4 == offset )
      break;
LABEL_10:
    if ( v8 || v9 && kind < next->kind )
      goto LABEL_13;
  }
  if ( kind != next->kind )
  {
    v8 = v4 < offset;
    v9 = v4 == offset;
    goto LABEL_10;
  }
  runtime_unlock(l);
  v12 = *(_DWORD *)(__readgsdword(0) - 4);
  v13 = mp->locks;
  mp->locks = v13 - 1;
  if ( v13 == 1 && *(_BYTE *)(v12 + 108) )
    *(_DWORD *)(v12 + 8) = -1314;
  return 0;
}
// 8149108: using guessed type int dword_8149108;
// 814910C: using guessed type int dword_814910C;
// 81493A8: using guessed type int dword_81493A8;
// 81493AC: using guessed type int dword_81493AC;

//----- (08066EA0) --------------------------------------------------------
runtime_special *__golang runtime_removespecial(void *p, uint8 kind)
{
  runtime_mspan *v2; // ecx
  int v3; // eax
  runtime_special *i; // ecx
  runtime_special *next; // ebx
  int v6; // eax
  int32 locks; // edx
  int v8; // eax
  int32 v9; // edx
  unsigned int v10; // ecx
  string v11; // [esp+0h] [ebp-20h]
  uintptr _r0; // [esp+8h] [ebp-18h]
  runtime_special *s; // [esp+10h] [ebp-10h]
  runtime_mspan *s_0; // [esp+14h] [ebp-Ch]
  runtime_m *mp; // [esp+18h] [ebp-8h]
  runtime_mutex_0 *l; // [esp+1Ch] [ebp-4h]

  if ( (unsigned int)p < dword_81493A8 || (unsigned int)p >= dword_81493AC )
  {
    v2 = 0;
  }
  else
  {
    v10 = ((unsigned int)p - dword_81493A8) >> 13;
    if ( v10 >= dword_814910C )
      runtime_panicindex();
    v2 = *(runtime_mspan **)(dword_8149108 + 4 * v10);
    if ( !v2 || (unsigned int)p < v2->startAddr || (unsigned int)p >= v2->limit || v2->state != 1 )
      v2 = 0;
  }
  if ( !v2 )
  {
    v11.str = (uint8 *)"removespecial on invalid pointer";
    v11.len = 32;
    runtime_throw(v11);
    BUG();
  }
  s_0 = v2;
  v3 = *(_DWORD *)(__readgsdword(0) - 4);
  ++*(_DWORD *)(*(_DWORD *)(v3 + 24) + 120);
  mp = *(runtime_m **)(v3 + 24);
  runtime___ptr_mspan__ensureSwept(v2);
  l = &s_0->speciallock;
  _r0 = s_0->startAddr;
  runtime_lock(&s_0->speciallock);
  for ( i = (runtime_special *)&s_0->specials; ; i = i->next )
  {
    next = i->next;
    if ( !i->next )
      break;
    if ( (_BYTE *)next->offset == (char *)p - _r0 && kind == next->kind )
    {
      s = i->next;
      i->next = next->next;
      runtime_unlock(l);
      v6 = *(_DWORD *)(__readgsdword(0) - 4);
      locks = mp->locks;
      mp->locks = locks - 1;
      if ( locks == 1 )
      {
        if ( *(_BYTE *)(v6 + 108) )
          *(_DWORD *)(v6 + 8) = -1314;
      }
      return s;
    }
  }
  runtime_unlock(l);
  v8 = *(_DWORD *)(__readgsdword(0) - 4);
  v9 = mp->locks;
  mp->locks = v9 - 1;
  if ( v9 == 1 && *(_BYTE *)(v8 + 108) )
    *(_DWORD *)(v8 + 8) = -1314;
  return 0;
}
// 8149108: using guessed type int dword_8149108;
// 814910C: using guessed type int dword_814910C;
// 81493A8: using guessed type int dword_81493A8;
// 81493AC: using guessed type int dword_81493AC;

//----- (08067070) --------------------------------------------------------
bool __golang runtime_addfinalizer(
        void *p,
        runtime_funcval *f,
        uintptr nret,
        runtime__type_0 *fint,
        runtime_ptrtype_0 *ot)
{
  char *v5; // eax
  int v6; // eax
  int v7; // eax
  int32 locks; // edx
  runtime_special *s; // [esp+4h] [ebp-20h]
  runtime_mspan *sa; // [esp+4h] [ebp-20h]
  void *b; // [esp+8h] [ebp-1Ch]
  uintptr ba; // [esp+8h] [ebp-1Ch]
  runtime_gcWork_0 *v13; // [esp+Ch] [ebp-18h]
  runtime_m *mp; // [esp+10h] [ebp-14h]
  runtime_gcWork_0 *gcw; // [esp+14h] [ebp-10h]
  uintptr *dst; // [esp+18h] [ebp-Ch]
  uintptr b0; // [esp+1Ch] [ebp-8h]
  runtime_mlink *v18; // [esp+20h] [ebp-4h]

  runtime_lock(&l);
  s = (runtime_special *)runtime___ptr_fixalloc__alloc(&stru_814B5AC);
  v18 = (runtime_mlink *)s;
  runtime_unlock(&l);
  v5 = (char *)s;
  s->kind = 1;
  b0 = (uintptr)&s[1];
  if ( *(_DWORD *)&runtime_writeBarrier.enabled )
  {
    runtime_writebarrierptr((uintptr *)&s[1], (uintptr)f);
    v5 = (char *)v18;
  }
  else
  {
    s[1].next = (runtime_special *)f;
  }
  *((_DWORD *)v5 + 3) = nret;
  if ( *(_DWORD *)&runtime_writeBarrier.enabled )
  {
    dst = (uintptr *)(v5 + 20);
    runtime_writebarrierptr((uintptr *)v5 + 4, (uintptr)fint);
    runtime_writebarrierptr(dst, (uintptr)ot);
    v5 = (char *)v18;
  }
  else
  {
    *((_DWORD *)v5 + 4) = fint;
    *((_DWORD *)v5 + 5) = ot;
  }
  LOBYTE(b) = runtime_addspecial(p, (runtime_special *)v5);
  if ( (_BYTE)b )
  {
    if ( runtime_gcphase )
    {
      runtime_findObject(p, sa, b, (uintptr)v13);
      v6 = *(_DWORD *)(__readgsdword(0) - 4);
      ++*(_DWORD *)(*(_DWORD *)(v6 + 24) + 120);
      mp = *(runtime_m **)(v6 + 24);
      gcw = (runtime_gcWork_0 *)(mp->p + 2384);
      runtime_scanobject(ba, gcw);
      runtime_scanblock(b0, 4u, runtime_noptrdata, gcw);
      if ( runtime_gcBlackenPromptly )
        runtime___ptr_gcWork__dispose(gcw);
      v7 = *(_DWORD *)(__readgsdword(0) - 4);
      locks = mp->locks;
      mp->locks = locks - 1;
      if ( locks == 1 )
      {
        if ( *(_BYTE *)(v7 + 108) )
          *(_DWORD *)(v7 + 8) = -1314;
      }
    }
    return 1;
  }
  else
  {
    runtime_lock(&l);
    stru_814B5AC.inuse -= stru_814B5AC.size;
    v18->next = stru_814B5AC.list;
    stru_814B5AC.list = v18;
    runtime_unlock(&l);
    return 0;
  }
}
// 806713F: variable 'sa' is possibly undefined
// 806713F: variable 'b' is possibly undefined
// 806713F: variable 'v13' is possibly undefined
// 8067182: variable 'ba' is possibly undefined

//----- (080672B0) --------------------------------------------------------
void __golang runtime_removefinalizer(void *p)
{
  runtime_mlink *v1; // [esp+8h] [ebp-8h]

  v1 = (runtime_mlink *)runtime_removespecial(p, 1u);
  if ( v1 )
  {
    runtime_lock(&l);
    stru_814B5AC.inuse -= stru_814B5AC.size;
    v1->next = stru_814B5AC.list;
    stru_814B5AC.list = v1;
    runtime_unlock(&l);
  }
}

//----- (08067340) --------------------------------------------------------
void __golang runtime_setprofilebucket(void *p, runtime_bucket *b)
{
  string l; // [esp+0h] [ebp-10h]
  runtime_special *s; // [esp+Ch] [ebp-4h]

  runtime_lock(&::l);
  s = (runtime_special *)runtime___ptr_fixalloc__alloc(&stru_814B5D0);
  runtime_unlock(&::l);
  s->kind = 2;
  s[1].next = (runtime_special *)b;
  if ( !runtime_addspecial(p, s) )
  {
    l.str = (uint8 *)"setprofilebucket: profile already set";
    l.len = 37;
    runtime_throw(l);
    BUG();
  }
}

//----- (080673E0) --------------------------------------------------------
void __golang runtime_freespecial(runtime_special *s, void *p, uintptr size)
{
  uint8 kind; // cl
  string b; // [esp+0h] [ebp-14h]

  kind = s->kind;
  if ( kind == 1 )
  {
    runtime_queuefinalizer(
      p,
      (runtime_funcval *)s[1].next,
      *(_DWORD *)&s[1].offset,
      (runtime__type_0 *)s[2].next,
      *(runtime_ptrtype_0 **)&s[2].offset);
    runtime_lock(&l);
    stru_814B5AC.inuse -= stru_814B5AC.size;
    s->next = (runtime_special *)stru_814B5AC.list;
    stru_814B5AC.list = (runtime_mlink *)s;
    runtime_unlock(&l);
  }
  else
  {
    if ( kind != 2 )
    {
      b.str = (uint8 *)"bad special kind";
      b.len = 16;
      runtime_throw(b);
      BUG();
    }
    runtime_mProf_Free((runtime_bucket *)s[1].next, size);
    runtime_lock(&l);
    stru_814B5D0.inuse -= stru_814B5D0.size;
    s->next = (runtime_special *)stru_814B5D0.list;
    stru_814B5D0.list = (runtime_mlink *)s;
    runtime_unlock(&l);
  }
}

//----- (08067510) --------------------------------------------------------
runtime_gcBits *__golang runtime___ptr_gcBitsArena__tryAlloc(runtime_gcBitsArena *b, uintptr bytes)
{
  int v2; // [esp+4h] [ebp-8h]
  unsigned int v3; // [esp+8h] [ebp-4h]

  if ( !b )
    return 0;
  runtime_internal_atomic_Loaduintptr();
  if ( bytes + v2 > 0xFFF8 )
    return 0;
  runtime_internal_atomic_Xadduintptr();
  if ( v3 > 0xFFF8 )
    return 0;
  if ( v3 - bytes >= 0xFFF8 )
    runtime_panicindex();
  return &b->bits[v3 - bytes];
}
// 8067549: variable 'v2' is possibly undefined
// 806756B: variable 'v3' is possibly undefined

//----- (080675B0) --------------------------------------------------------
runtime_gcBits *__golang runtime_newMarkBits(uintptr nelems)
{
  string ptr; // [esp+0h] [ebp-20h]
  runtime_gcBitsArena *bytes; // [esp+4h] [ebp-1Ch]
  runtime_gcBits *v3; // [esp+8h] [ebp-18h]
  runtime_gcBits *v4; // [esp+8h] [ebp-18h]
  runtime_gcBits *v5; // [esp+8h] [ebp-18h]
  runtime_gcBits *v6; // [esp+8h] [ebp-18h]
  uintptr bytesNeeded; // [esp+Ch] [ebp-14h]
  runtime_gcBitsArena *fresh; // [esp+1Ch] [ebp-4h]

  bytes = (runtime_gcBitsArena *)runtime_internal_atomic_Loadp(&runtime_gcBitsArenas.next);
  bytesNeeded = 8 * ((nelems + 63) >> 6);
  v3 = runtime___ptr_gcBitsArena__tryAlloc(bytes, bytesNeeded);
  if ( v3 )
    return v3;
  runtime_lock(&runtime_gcBitsArenas.lock);
  v4 = runtime___ptr_gcBitsArena__tryAlloc(runtime_gcBitsArenas.next, bytesNeeded);
  if ( v4 )
  {
    runtime_unlock(&runtime_gcBitsArenas.lock);
    return v4;
  }
  else
  {
    fresh = runtime_newArenaMayUnlock();
    v5 = runtime___ptr_gcBitsArena__tryAlloc(runtime_gcBitsArenas.next, bytesNeeded);
    if ( v5 )
    {
      fresh->next = runtime_gcBitsArenas.free;
      runtime_gcBitsArenas.free = fresh;
      runtime_unlock(&runtime_gcBitsArenas.lock);
      return v5;
    }
    else
    {
      v6 = runtime___ptr_gcBitsArena__tryAlloc(fresh, bytesNeeded);
      if ( !v6 )
      {
        ptr.str = (uint8 *)"markBits overflow";
        ptr.len = 17;
        runtime_throw(ptr);
        BUG();
      }
      fresh->next = runtime_gcBitsArenas.next;
      runtime_internal_atomic_StorepNoWB();
      runtime_unlock(&runtime_gcBitsArenas.lock);
      return v6;
    }
  }
}

//----- (08067740) --------------------------------------------------------
runtime_gcBits *__golang runtime_newAllocBits(uintptr nelems)
{
  return runtime_newMarkBits(nelems);
}

//----- (08067780) --------------------------------------------------------
void __golang runtime_nextMarkBitArenaEpoch()
{
  runtime_gcBitsArena *previous; // eax

  runtime_lock(&runtime_gcBitsArenas.lock);
  previous = runtime_gcBitsArenas.previous;
  if ( runtime_gcBitsArenas.previous )
  {
    if ( runtime_gcBitsArenas.free )
    {
      while ( previous->next )
        previous = previous->next;
      previous->next = runtime_gcBitsArenas.free;
      runtime_gcBitsArenas.free = runtime_gcBitsArenas.previous;
    }
    else
    {
      runtime_gcBitsArenas.free = runtime_gcBitsArenas.previous;
    }
  }
  runtime_gcBitsArenas.previous = runtime_gcBitsArenas.current;
  runtime_gcBitsArenas.current = runtime_gcBitsArenas.next;
  runtime_internal_atomic_StorepNoWB();
  runtime_unlock(&runtime_gcBitsArenas.lock);
}

//----- (08067830) --------------------------------------------------------
runtime_gcBitsArena *__golang runtime_newArenaMayUnlock()
{
  runtime_gcBitsArena *v0; // eax
  string l; // [esp+0h] [ebp-14h]
  runtime_gcBitsArena *v2; // [esp+8h] [ebp-Ch]
  runtime_gcBitsArena *free; // [esp+10h] [ebp-4h]

  if ( runtime_gcBitsArenas.free )
  {
    free = runtime_gcBitsArenas.free;
    runtime_gcBitsArenas.free = runtime_gcBitsArenas.free->next;
    runtime_memclrNoHeapPointers();
    v0 = free;
  }
  else
  {
    runtime_unlock(&runtime_gcBitsArenas.lock);
    v2 = (runtime_gcBitsArena *)runtime_sysAlloc(0x10000u, &runtime_memstats.gc_sys);
    if ( !v2 )
    {
      l.str = (uint8 *)"runtime: cannot allocate memory";
      l.len = 31;
      runtime_throw(l);
      BUG();
    }
    runtime_lock(&runtime_gcBitsArenas.lock);
    v0 = v2;
  }
  v0->next = 0;
  v0->free = 0;
  return v0;
}

//----- (080678F0) --------------------------------------------------------
runtime_bucket *__golang runtime_newBucket(runtime_bucketType typ, __int32 nstk)
{
  __int32 v2; // eax
  uintptr v3; // eax
  string v4; // [esp+0h] [ebp-14h]
  runtime_bucket *v5; // [esp+Ch] [ebp-8h]
  uintptr size; // [esp+10h] [ebp-4h]

  v2 = 4 * nstk;
  if ( typ == 1 )
  {
    v3 = v2 + 88;
  }
  else
  {
    if ( (unsigned int)(typ - 2) > 1 )
    {
      v4.str = (uint8 *)"invalid profile bucket type";
      v4.len = 27;
      runtime_throw(v4);
      BUG();
    }
    v3 = v2 + 40;
  }
  size = v3;
  v5 = (runtime_bucket *)runtime_persistentalloc(v3, 0, &runtime_memstats.buckhash_sys);
  runtime_bucketmem += size;
  v5->typ = typ;
  v5->nstk = nstk;
  return v5;
}

//----- (080679A0) --------------------------------------------------------
runtime_memRecord *__golang runtime___ptr_bucket__mp(runtime_bucket *b)
{
  string s; // [esp+0h] [ebp-8h]

  if ( b->typ != 1 )
  {
    s.str = (uint8 *)"bad use of bucket.mp";
    s.len = 20;
    runtime_throw(s);
    BUG();
  }
  return (runtime_memRecord *)(&b[1].next + b->nstk);
}

//----- (080679F0) --------------------------------------------------------
runtime_blockRecord *__golang runtime___ptr_bucket__bp(runtime_bucket *b)
{
  runtime_bucketType typ; // ecx
  string s; // [esp+0h] [ebp-8h]

  typ = b->typ;
  if ( typ != 2 && typ != 3 )
  {
    s.str = (uint8 *)"bad use of bucket.bp";
    s.len = 20;
    runtime_throw(s);
    BUG();
  }
  return (runtime_blockRecord *)(&b[1].next + b->nstk);
}

//----- (08067A50) --------------------------------------------------------
runtime_bucket *__golang runtime_stkbucket(runtime_bucketType typ, uintptr size, __uintptr stk, bool alloc)
{
  __int32 len; // ecx
  uintptr *array; // edx
  __int32 v6; // ebx
  unsigned int v7; // ebp
  int v8; // esi
  uintptr v9; // ebx
  uintptr v10; // esi
  int v11; // ebp
  uintptr *v12; // esi
  int v13; // eax
  unsigned int v14; // ebp
  _DWORD *i; // edx
  __uintptr x; // [esp+0h] [ebp-28h]
  string xa; // [esp+0h] [ebp-28h]
  runtime_bucket *x_8; // [esp+8h] [ebp-20h]
  void *x_8a; // [esp+8h] [ebp-20h]
  __uintptr y; // [esp+Ch] [ebp-1Ch]
  uintptr v21; // [esp+20h] [ebp-8h]
  runtime_bucket *v22; // [esp+24h] [ebp-4h]

  if ( !runtime_buckhash )
  {
    x_8a = runtime_sysAlloc(0xAFC7Cu, &runtime_memstats.buckhash_sys);
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr(&runtime_buckhash, (uintptr)x_8a);
    else
      runtime_buckhash = (uintptr)x_8a;
    if ( !runtime_buckhash )
    {
      xa.str = (uint8 *)"runtime: cannot allocate memory";
      xa.len = 31;
      runtime_throw(xa);
      BUG();
    }
  }
  len = stk.len;
  array = stk.array;
  v6 = 0;
  v7 = 0;
  while ( v6 < stk.len )
  {
    v8 = *array++;
    ++v6;
    v7 = (1025 * (v7 + v8)) ^ ((1025 * (v7 + v8)) >> 6);
  }
  v9 = size;
  v10 = 9 * (((1025 * (size + v7)) >> 6) ^ (1025 * (size + v7)));
  v11 = v10 ^ (v10 >> 11);
  v12 = stk.array;
  v13 = v11;
  v14 = v11
      - 179999
      * ((((unsigned int)((0x174D43F79LL * (unsigned __int64)(unsigned int)v11) >> 32) >> 1) | (__CFADD__(
                                                                                                  v11,
                                                                                                  (1960066937
                                                                                                 * (unsigned __int64)(unsigned int)v11) >> 32) << 31)) >> 17);
  if ( v14 >= 0x2BF1F )
    runtime_panicindex();
  v21 = v13;
  for ( i = *(_DWORD **)(runtime_buckhash + 4 * v14); i; i = (_DWORD *)*i )
  {
    if ( i[2] == typ && v13 == i[3] && v9 == i[4] )
    {
      if ( i[5] > 0x20u )
        runtime_panicslice();
      v22 = (runtime_bucket *)i;
      x.array = i + 6;
      x.len = i[5];
      x.cap = x.len;
      y.array = v12;
      *(_QWORD *)&y.len = __PAIR64__(stk.cap, len);
      if ( runtime_eqslice(x, y) )
        return v22;
      v13 = v21;
      len = stk.len;
      i = &v22->next;
      v9 = size;
      v12 = stk.array;
    }
  }
  if ( !alloc )
    return 0;
  x_8 = runtime_newBucket(typ, len);
  if ( x_8->nstk > 0x20 )
    runtime_panicslice();
  runtime_memmove();
  x_8->hash = v21;
  x_8->size = size;
  x_8->next = *(runtime_bucket **)(runtime_buckhash + 4 * v14);
  *(_DWORD *)(runtime_buckhash + 4 * v14) = x_8;
  if ( typ == 1 )
  {
    x_8->allnext = runtime_mbuckets;
    runtime_mbuckets = x_8;
  }
  else if ( typ == 3 )
  {
    x_8->allnext = runtime_xbuckets;
    runtime_xbuckets = x_8;
  }
  else
  {
    x_8->allnext = runtime_bbuckets;
    runtime_bbuckets = x_8;
  }
  return x_8;
}

//----- (08067CF0) --------------------------------------------------------
bool __golang runtime_eqslice(__uintptr x, __uintptr y)
{
  uintptr *array; // ebx
  __int32 i; // ebp

  if ( x.len != y.len )
    return 0;
  array = x.array;
  for ( i = 0; i < x.len; ++i )
  {
    if ( (unsigned int)i >= y.len )
      runtime_panicindex();
    if ( *array != y.array[i] )
      return 0;
    ++array;
  }
  return 1;
}

//----- (08067D50) --------------------------------------------------------
void __golang runtime_mProf_NextCycle()
{
  runtime_lock(&runtime_proflock);
  runtime_mProf.cycle = (runtime_mProf.cycle + 1) % 0x6000000;
  runtime_mProf.flushed = 0;
  runtime_unlock(&runtime_proflock);
}

//----- (08067DC0) --------------------------------------------------------
void __golang runtime_mProf_Flush()
{
  runtime_lock(&runtime_proflock);
  if ( !runtime_mProf.flushed )
  {
    runtime_mProf_FlushLocked();
    runtime_mProf.flushed = 1;
  }
  runtime_unlock(&runtime_proflock);
}

//----- (08067E20) --------------------------------------------------------
void __golang runtime_mProf_FlushLocked()
{
  runtime_bucket *i; // ecx
  unsigned int v1; // ebx
  runtime_memRecord *v2; // [esp+4h] [ebp-Ch]
  uint32 cycle; // [esp+8h] [ebp-8h]
  runtime_bucket *b; // [esp+Ch] [ebp-4h]

  cycle = runtime_mProf.cycle;
  for ( i = runtime_mbuckets; i; i = b->allnext )
  {
    b = i;
    v2 = runtime___ptr_bucket__mp(i);
    v1 = cycle % 3;
    v2->active.allocs += v2->future[v1].allocs;
    v2->active.frees += v2->future[v1].frees;
    v2->active.alloc_bytes += v2->future[v1].alloc_bytes;
    v2->active.free_bytes += v2->future[v1].free_bytes;
    v2->future[v1].allocs = 0;
    v2->future[v1].frees = 0;
    v2->future[v1].alloc_bytes = 0;
    v2->future[v1].free_bytes = 0;
  }
}

//----- (08067EF0) --------------------------------------------------------
void __golang runtime_mProf_Malloc(void *p, uintptr size)
{
  runtime_memRecord *v2; // ebx
  unsigned int v3; // ecx
  __uintptr pcbuf; // [esp+4h] [ebp-B0h]
  __uintptr pcbuf_4; // [esp+8h] [ebp-ACh]
  unsigned int nstk; // [esp+1Ch] [ebp-98h]
  uint32 cycle; // [esp+20h] [ebp-94h]
  uintptr stk[32]; // [esp+24h] [ebp-90h] BYREF
  runtime_bucket *b; // [esp+A4h] [ebp-10h]
  void (__golang *v10)(); // [esp+A8h] [ebp-Ch]
  void *v11; // [esp+ACh] [ebp-8h]
  runtime_bucket *v12; // [esp+B0h] [ebp-4h]

  while ( (unsigned int)&stk[23] <= *(_DWORD *)(*(_DWORD *)(__readgsdword(0) - 4) + 8) )
    runtime_morestack_noctxt();
  ((void (*)(void))loc_808FD70)();
  pcbuf.array = stk;
  *(_QWORD *)&pcbuf.len = 0x2000000020LL;
  nstk = runtime_callers(4, pcbuf);
  runtime_lock(&runtime_proflock);
  if ( nstk > 0x20 )
    runtime_panicslice();
  pcbuf_4.array = stk;
  *(_QWORD *)&pcbuf_4.len = nstk | 0x2000000000LL;
  b = runtime_stkbucket(1, size, pcbuf_4, 1);
  cycle = runtime_mProf.cycle;
  v2 = runtime___ptr_bucket__mp(b);
  v3 = (cycle + 2) % 3;
  ++v2->future[v3].allocs;
  v2->future[v3].alloc_bytes += size;
  runtime_unlock(&runtime_proflock);
  v10 = runtime_mProf_Malloc_func1;
  v11 = p;
  v12 = b;
  runtime_systemstack();
}
// 8067EF0: could not find valid save-restore pair for ebx

//----- (08068050) --------------------------------------------------------
void __golang runtime_mProf_Free(runtime_bucket *b, uintptr size)
{
  runtime_memRecord *v2; // ebx
  unsigned int v3; // ecx
  uint32 cycle; // [esp+8h] [ebp-4h]

  runtime_lock(&runtime_proflock);
  cycle = runtime_mProf.cycle;
  v2 = runtime___ptr_bucket__mp(b);
  v3 = (cycle + 1) % 3;
  ++v2->future[v3].frees;
  v2->future[v3].free_bytes += size;
  runtime_unlock(&runtime_proflock);
}
// 8068050: could not find valid save-restore pair for ebx

//----- (080680E0) --------------------------------------------------------
void __golang runtime_blockevent(int64 cycles, __int32 skip)
{
  int v2; // eax
  unsigned int v3; // ecx
  unsigned __int64 cyclesa; // [esp+14h] [ebp+4h]

  if ( (_DWORD)cycles == 0 && HIDWORD(cycles) == 0 || cycles < 0 )
  {
    v2 = 1;
    v3 = 0;
  }
  else
  {
    v3 = HIDWORD(cycles);
    v2 = cycles;
  }
  cyclesa = __PAIR64__(v3, v2);
  if ( runtime_blocksampled(__SPAIR64__(v3, v2)) )
    runtime_saveblockevent(cyclesa, skip + 1, 2);
}

//----- (08068180) --------------------------------------------------------
bool __golang runtime_blocksampled(int64 cycles)
{
  int v1; // edx
  unsigned int v2; // ebp
  int64 n_4; // [esp+4h] [ebp-14h]
  int64 v4; // [esp+10h] [ebp-8h]
  bool _r1; // [esp+24h] [ebp+Ch]

  runtime_internal_atomic_Load64();
  _r1 = 0;
  if ( n_4 >= 0 && (HIDWORD(n_4) != 0 || (_DWORD)n_4 != 0) )
  {
    if ( SHIDWORD(n_4) <= SHIDWORD(cycles)
      && (HIDWORD(n_4) != HIDWORD(cycles) || (unsigned int)n_4 <= (unsigned int)cycles) )
    {
      return 1;
    }
    v1 = *(_DWORD *)(*(_DWORD *)(__readgsdword(0) - 4) + 24);
    v2 = (*(int *)(v1 + 148) >> 31) & 0xA8888EEF ^ (2 * *(_DWORD *)(v1 + 148));
    *(_DWORD *)(v1 + 148) = v2;
    v4 = runtime_int64mod(v2, n_4);
    if ( SHIDWORD(v4) <= SHIDWORD(cycles)
      && (HIDWORD(v4) != HIDWORD(cycles) || (unsigned int)v4 <= (unsigned int)cycles) )
    {
      return 1;
    }
  }
  return _r1;
}
// 80681BD: variable 'n_4' is possibly undefined

//----- (08068280) --------------------------------------------------------
void __golang runtime_saveblockevent(int64 cycles, __int32 skip, runtime_bucketType which)
{
  runtime_g *curg; // edx
  __int32 v4; // eax
  bool v5; // cf
  int count_high; // edx
  int v7; // ecx
  int cycles_high; // edx
  __uintptr pcbuf; // [esp+4h] [ebp-A4h]
  runtime_blockRecord *pcbufa; // [esp+4h] [ebp-A4h]
  runtime_blockRecord *pcbufb; // [esp+4h] [ebp-A4h]
  __uintptr pcbuf_4; // [esp+8h] [ebp-A0h]
  __uintptr pcbuf_4a; // [esp+8h] [ebp-A0h]
  unsigned __int32 nstk; // [esp+1Ch] [ebp-8Ch]
  uintptr stk[32]; // [esp+20h] [ebp-88h] BYREF
  runtime_g *gp; // [esp+A0h] [ebp-8h]
  runtime_bucket *b; // [esp+A4h] [ebp-4h]

  while ( (unsigned int)&stk[24] <= *(_DWORD *)(*(_DWORD *)(__readgsdword(0) - 4) + 8) )
    runtime_morestack_noctxt();
  gp = *(runtime_g **)(__readgsdword(0) - 4);
  ((void (*)(void))loc_808FD70)();
  curg = gp->m->curg;
  if ( curg && curg != gp )
  {
    pcbuf_4a.array = stk;
    *(_QWORD *)&pcbuf_4a.len = 0x2000000020LL;
    v4 = runtime_gcallers(gp->m->curg, skip, pcbuf_4a);
  }
  else
  {
    pcbuf.array = stk;
    *(_QWORD *)&pcbuf.len = 0x2000000020LL;
    v4 = runtime_callers(skip, pcbuf);
  }
  nstk = v4;
  runtime_lock(&runtime_proflock);
  if ( nstk > 0x20 )
    runtime_panicslice();
  pcbuf_4.array = stk;
  *(_QWORD *)&pcbuf_4.len = nstk | 0x2000000000LL;
  b = runtime_stkbucket(which, 0, pcbuf_4, 1);
  pcbufa = runtime___ptr_bucket__bp(b);
  v5 = __CFADD__(pcbufa->count, 1);
  count_high = HIDWORD(pcbufa->count);
  ++LODWORD(pcbufa->count);
  HIDWORD(pcbufa->count) = v5 + count_high;
  pcbufb = runtime___ptr_bucket__bp(b);
  v7 = pcbufb->cycles;
  cycles_high = HIDWORD(pcbufb->cycles);
  LODWORD(pcbufb->cycles) = cycles + v7;
  HIDWORD(pcbufb->cycles) = cycles_high + __CFADD__((_DWORD)cycles, v7) + HIDWORD(cycles);
  runtime_unlock(&runtime_proflock);
}

//----- (08068410) --------------------------------------------------------
void __golang sync_event(int64 cycles, __int32 skip)
{
  unsigned int v2; // eax
  unsigned int v3; // ecx
  int v4; // edx
  unsigned int v5; // ebp
  int64 n_4; // [esp+4h] [ebp-14h]
  int64 v7; // [esp+10h] [ebp-8h]
  unsigned __int64 cyclesa; // [esp+1Ch] [ebp+4h]

  v2 = HIDWORD(cycles);
  if ( cycles >= 0 )
  {
    v3 = cycles;
  }
  else
  {
    v2 = 0;
    v3 = 0;
  }
  cyclesa = __PAIR64__(v2, v3);
  runtime_internal_atomic_Load64();
  if ( SHIDWORD(n_4) > 0 || HIDWORD(n_4) == 0 && (_DWORD)n_4 != 0 )
  {
    v4 = *(_DWORD *)(*(_DWORD *)(__readgsdword(0) - 4) + 24);
    v5 = (*(int *)(v4 + 148) >> 31) & 0xA8888EEF ^ (2 * *(_DWORD *)(v4 + 148));
    *(_DWORD *)(v4 + 148) = v5;
    v7 = runtime_int64mod(v5, n_4);
    if ( (_DWORD)v7 == 0 && HIDWORD(v7) == 0 )
      runtime_saveblockevent(cyclesa, skip + 1, 3);
  }
}
// 806847C: variable 'n_4' is possibly undefined

//----- (08068520) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
void __golang runtime_tracealloc(void *p, uintptr size, runtime__type_0 *typ)
{
  runtime_g *curg; // ecx
  runtime_mutex_0 *l; // [esp+0h] [ebp-2Ch]
  runtime_mutex_0 *la; // [esp+0h] [ebp-2Ch]
  runtime_mutex_0 *lb; // [esp+0h] [ebp-2Ch]
  string lc; // [esp+0h] [ebp-2Ch]
  string ld; // [esp+0h] [ebp-2Ch]
  string le; // [esp+0h] [ebp-2Ch]
  string lf; // [esp+0h] [ebp-2Ch]
  string sp_0; // [esp+4h] [ebp-28h] OVERLAPPED
  runtime_g *gp; // [esp+14h] [ebp-18h]
  uint8 *s; // [esp+18h] [ebp-14h]

  runtime_lock(&runtime_tracelock);
  gp = *(runtime_g **)(__readgsdword(0) - 4);
  gp->m->traceback = 2;
  if ( typ )
  {
    sp_0 = runtime___ptr__type__string(typ);
    s = sp_0.str;
    runtime_printlock();
    l = (runtime_mutex_0 *)"tracealloc(";
    sp_0.str = (uint8 *)11;
    runtime_printstring(*(string *)((char *)&sp_0 - 4));
    runtime_printpointer(p);
    la = (runtime_mutex_0 *)", ";
    sp_0.str = (uint8 *)2;
    runtime_printstring(*(string *)((char *)&sp_0 - 4));
    runtime_printhex(size);
    lb = (runtime_mutex_0 *)", ";
    sp_0.str = (uint8 *)2;
    runtime_printstring(*(string *)((char *)&sp_0 - 4));
    runtime_printstring((string)__PAIR64__(sp_0.len, (unsigned int)s));
  }
  else
  {
    runtime_printlock();
    le.str = (uint8 *)"tracealloc(";
    le.len = 11;
    runtime_printstring(le);
    runtime_printpointer(p);
    lf.str = (uint8 *)", ";
    lf.len = 2;
    runtime_printstring(lf);
    runtime_printhex(size);
  }
  lc.str = (uint8 *)")\n";
  lc.len = 2;
  runtime_printstring(lc);
  runtime_printunlock();
  curg = gp->m->curg;
  if ( curg && gp != curg )
  {
    runtime_goroutineheader(gp->m->curg);
    runtime_traceback(0xFFFFFFFF, 0xFFFFFFFF, 0, gp->m->curg);
  }
  else
  {
    runtime_goroutineheader(gp);
    runtime_getcallerpc();
    runtime_systemstack();
  }
  runtime_printlock();
  ld.str = (uint8 *)"\n";
  ld.len = 1;
  runtime_printstring(ld);
  runtime_printunlock();
  gp->m->traceback = 0;
  runtime_unlock(&runtime_tracelock);
}
// 8068572: failed to expand linear variable ^4.8

//----- (08068770) --------------------------------------------------------
void __golang runtime_tracefree(void *p, uintptr size)
{
  string l; // [esp+0h] [ebp-1Ch]
  string la; // [esp+0h] [ebp-1Ch]
  string lb; // [esp+0h] [ebp-1Ch]
  string lc; // [esp+0h] [ebp-1Ch]
  int v6; // [esp+4h] [ebp-18h]
  runtime_g *gp; // [esp+8h] [ebp-14h]
  void (__golang *v8)(); // [esp+Ch] [ebp-10h]
  int v9; // [esp+10h] [ebp-Ch]
  void **p_p; // [esp+14h] [ebp-8h]
  runtime_g *v11; // [esp+18h] [ebp-4h]

  runtime_lock(&runtime_tracelock);
  gp = *(runtime_g **)(__readgsdword(0) - 4);
  gp->m->traceback = 2;
  runtime_printlock();
  l.str = (uint8 *)"tracefree(";
  l.len = 10;
  runtime_printstring(l);
  runtime_printpointer(p);
  la.str = (uint8 *)", ";
  la.len = 2;
  runtime_printstring(la);
  runtime_printhex(size);
  lb.str = (uint8 *)")\n";
  lb.len = 2;
  runtime_printstring(lb);
  runtime_printunlock();
  runtime_goroutineheader(gp);
  runtime_getcallerpc();
  v8 = runtime_tracefree_func1;
  v9 = v6;
  p_p = &p;
  v11 = gp;
  runtime_systemstack();
  runtime_printlock();
  lc.str = (uint8 *)"\n";
  lc.len = 1;
  runtime_printstring(lc);
  runtime_printunlock();
  gp->m->traceback = 0;
  runtime_unlock(&runtime_tracelock);
}
// 8068848: variable 'v6' is possibly undefined

//----- (080688B0) --------------------------------------------------------
void __golang runtime_tracegc()
{
  string l; // [esp+0h] [ebp-Ch]
  string la; // [esp+0h] [ebp-Ch]
  string lb; // [esp+0h] [ebp-Ch]
  runtime_g *gp; // [esp+8h] [ebp-4h]

  runtime_lock(&runtime_tracelock);
  gp = *(runtime_g **)(__readgsdword(0) - 4);
  gp->m->traceback = 2;
  runtime_printlock();
  l.str = (uint8 *)"tracegc()\n";
  l.len = 10;
  runtime_printstring(l);
  runtime_printunlock();
  runtime_tracebackothers(gp);
  runtime_printlock();
  la.str = (uint8 *)"end tracegc\n";
  la.len = 12;
  runtime_printstring(la);
  runtime_printunlock();
  runtime_printlock();
  lb.str = (uint8 *)"\n";
  lb.len = 1;
  runtime_printstring(lb);
  runtime_printunlock();
  gp->m->traceback = 0;
  runtime_unlock(&runtime_tracelock);
}

//----- (08068990) --------------------------------------------------------
void __golang runtime_init_1()
{
  int v0; // esi
  string v; // [esp+0h] [ebp-15A0h]
  runtime_MemStats_0 memStats; // [esp+8h] [ebp-1598h] BYREF

  while ( 1 )
  {
    v0 = *(_DWORD *)(*(_DWORD *)(__readgsdword(0) - 4) + 8);
    if ( v0 != -1314 && (unsigned int)&STACK[0x1910] - v0 > 0x1890 )
      break;
    runtime_morestack_noctxt();
  }
  memset(&memStats, 0, sizeof(memStats));
  if ( runtime_sizeof_C_MStats != 5528 )
  {
    runtime_printlock();
    runtime_printint(runtime_sizeof_C_MStats);
    runtime_printsp();
    runtime_printint(5528LL);
    runtime_printnl();
    runtime_printunlock();
    v.str = (uint8 *)"MStats vs MemStatsType size mismatch";
    v.len = 36;
    runtime_throw(v);
    BUG();
  }
}

//----- (08068A50) --------------------------------------------------------
void __golang runtime_cachestats()
{
  int v0; // eax
  runtime_p **i; // ecx
  runtime_mcache *c; // edx
  int v3; // [esp+4h] [ebp-8h]
  runtime_p **v4; // [esp+8h] [ebp-4h]

  v0 = 0;
  for ( i = runtime_allp; v0 < 1025 && *i; ++i )
  {
    c = (*i)->mcache;
    if ( c )
    {
      v3 = v0;
      v4 = i;
      runtime_purgecachedstats(c);
      v0 = v3;
      i = v4;
    }
    ++v0;
  }
}

//----- (08068AB0) --------------------------------------------------------
void __golang runtime_flushmcache(__int32 i)
{
  runtime_p *v1; // eax
  runtime_mcache *mcache; // eax
  runtime_mcache *c; // [esp+4h] [ebp-4h]

  if ( (unsigned int)i >= 0x401 )
    runtime_panicindex();
  v1 = runtime_allp[i];
  if ( v1 )
  {
    mcache = v1->mcache;
    if ( mcache )
    {
      c = mcache;
      runtime___ptr_mcache__releaseAll(mcache);
      runtime_stackcache_clear(c);
    }
  }
}

//----- (08068B20) --------------------------------------------------------
void __golang runtime_purgecachedstats(runtime_mcache *c)
{
  int i; // eax

  runtime_memstats.heap_scan += c->local_scan;
  c->local_scan = 0;
  runtime_memstats.tinyallocs += c->local_tinyallocs;
  c->local_tinyallocs = 0;
  runtime_memstats.nlookup += c->local_nlookup;
  c->local_nlookup = 0;
  qword_8149178 += c->local_largefree;
  c->local_largefree = 0;
  qword_8149180 += c->local_nlargefree;
  c->local_nlargefree = 0;
  for ( i = 0; i < 67; ++i )
  {
    if ( (unsigned int)i >= 0x43 )
      runtime_panicindex();
    qword_8149188[i] += c->local_nsmallfree[i];
    c->local_nsmallfree[i] = 0;
  }
}
// 8149178: using guessed type __int64 qword_8149178;
// 8149180: using guessed type __int64 qword_8149180;
// 8149188: using guessed type _QWORD qword_8149188[67];

//----- (08068C60) --------------------------------------------------------
void __golang runtime_mSysStatInc(uint64 *sysStat, uintptr n)
{
  string s; // [esp+0h] [ebp-10h]
  string sa; // [esp+0h] [ebp-10h]
  string sb; // [esp+0h] [ebp-10h]
  uintptr v5; // [esp+8h] [ebp-8h]

  runtime_internal_atomic_Xadduintptr();
  if ( v5 < n )
  {
    runtime_printlock();
    s.str = (uint8 *)"runtime: stat overflow: val ";
    s.len = 28;
    runtime_printstring(s);
    runtime_printint(v5);
    sa.str = (uint8 *)", n ";
    sa.len = 4;
    runtime_printstring(sa);
    runtime_printint(n);
    sb.str = (uint8 *)"\n";
    sb.len = 1;
    runtime_printstring(sb);
    runtime_printunlock();
    runtime_exit();
  }
}
// 8068C81: variable 'v5' is possibly undefined

//----- (08068D10) --------------------------------------------------------
void __golang runtime_mSysStatDec(uint64 *sysStat, uintptr n)
{
  string s; // [esp+0h] [ebp-10h]
  string sa; // [esp+0h] [ebp-10h]
  string sb; // [esp+0h] [ebp-10h]
  unsigned int v5; // [esp+8h] [ebp-8h]

  runtime_internal_atomic_Xadduintptr();
  if ( v5 + n < n )
  {
    runtime_printlock();
    s.str = (uint8 *)"runtime: stat underflow: val ";
    s.len = 29;
    runtime_printstring(s);
    runtime_printint(v5);
    sa.str = (uint8 *)", n ";
    sa.len = 4;
    runtime_printstring(sa);
    runtime_printint(n);
    sb.str = (uint8 *)"\n";
    sb.len = 1;
    runtime_printstring(sb);
    runtime_printunlock();
    runtime_exit();
  }
}
// 8068D33: variable 'v5' is possibly undefined

//----- (08068DD0) --------------------------------------------------------
void __golang internal_poll_runtime_pollServerInit()
{
  runtime_netpollinit();
  runtime_internal_atomic_Store();
}

//----- (08068E10) --------------------------------------------------------
bool __golang runtime_netpollinited()
{
  return runtime_internal_atomic_Load(&runtime_netpollInited) != 0;
}

//----- (08068E50) --------------------------------------------------------
retval_8068E50 __golang internal_poll_runtime_pollOpen(uintptr fd)
{
  uintptr wg; // ecx
  uintptr rg; // ecx
  string c; // [esp+0h] [ebp-14h]
  string ca; // [esp+0h] [ebp-14h]
  runtime_pollDesc *pd; // [esp+Ch] [ebp-8h]
  retval_8068E50 _r1; // [esp+1Ch] [ebp+8h]

  pd = runtime___ptr_pollCache__alloc(&runtime_pollcache);
  runtime_lock(&pd->lock);
  wg = pd->wg;
  if ( wg && wg != 1 )
  {
    ca.str = (uint8 *)"runtime: blocked write on free polldesc";
    ca.len = 39;
    runtime_throw(ca);
    BUG();
  }
  rg = pd->rg;
  if ( rg && rg != 1 )
  {
    c.str = (uint8 *)"runtime: blocked read on free polldesc";
    c.len = 38;
    runtime_throw(c);
    BUG();
  }
  pd->fd = fd;
  pd->closing = 0;
  ++pd->seq;
  pd->rg = 0;
  LODWORD(pd->rd) = 0;
  HIDWORD(pd->rd) = 0;
  pd->wg = 0;
  LODWORD(pd->wd) = 0;
  HIDWORD(pd->wd) = 0;
  runtime_unlock(&pd->lock);
  _r1._r1 = pd;
  _r1._r2 = runtime_netpollopen(fd, pd);
  return _r1;
}

//----- (08068F60) --------------------------------------------------------
void __golang internal_poll_runtime_pollClose(runtime_pollDesc *pd)
{
  uintptr wg; // ecx
  uintptr rg; // ecx
  string fd; // [esp+0h] [ebp-8h]
  string fda; // [esp+0h] [ebp-8h]
  string fdb; // [esp+0h] [ebp-8h]

  if ( !pd->closing )
  {
    fdb.str = (uint8 *)"runtime: close polldesc w/o unblock";
    fdb.len = 35;
    runtime_throw(fdb);
    BUG();
  }
  wg = pd->wg;
  if ( wg && wg != 1 )
  {
    fda.str = (uint8 *)"runtime: blocked write on closing polldesc";
    fda.len = 42;
    runtime_throw(fda);
    BUG();
  }
  rg = pd->rg;
  if ( rg && rg != 1 )
  {
    fd.str = (uint8 *)"runtime: blocked read on closing polldesc";
    fd.len = 41;
    runtime_throw(fd);
    BUG();
  }
  runtime_netpollclose(pd->fd);
  runtime___ptr_pollCache__free(&runtime_pollcache, pd);
}

//----- (08069020) --------------------------------------------------------
void __golang runtime___ptr_pollCache__free(runtime_pollCache_0 *c, runtime_pollDesc *pd)
{
  runtime_lock(&c->lock);
  pd->link = c->first;
  c->first = pd;
  runtime_unlock(&c->lock);
}

//----- (08069070) --------------------------------------------------------
__int32 __golang internal_poll_runtime_pollReset(runtime_pollDesc *pd, __int32 mode)
{
  __int32 v2; // ecx

  if ( pd->closing )
  {
    v2 = 1;
  }
  else if ( mode == 114 && pd->rd < 0 || mode == 119 && pd->wd < 0 )
  {
    v2 = 2;
  }
  else
  {
    v2 = 0;
  }
  if ( v2 )
    return v2;
  if ( mode == 114 )
  {
    pd->rg = 0;
  }
  else if ( mode == 119 )
  {
    pd->wg = 0;
  }
  return 0;
}

//----- (08069130) --------------------------------------------------------
__int32 __golang internal_poll_runtime_pollWait(runtime_pollDesc *pd, __int32 mode)
{
  int v2; // ebp
  runtime_pollDesc *v3; // eax
  __int32 v4; // ecx
  __int32 v5; // ecx
  int rd_high; // edx
  int rd; // ebx
  int v8; // ebx
  int v9; // et0
  int v10; // edx
  int v11; // ebx
  int v12; // ebx
  int wd_high; // edx
  int wd; // ebx
  int v15; // ebx
  int v16; // et2

  v3 = pd;
  if ( pd->closing )
  {
    v4 = 1;
  }
  else
  {
    if ( mode == 114 )
    {
      v12 = v2;
      LOBYTE(v12) = HIDWORD(pd->rd) == 0;
      v2 = v12;
      if ( pd->rd < 0 )
        goto LABEL_19;
    }
    if ( mode == 119
      && (wd_high = HIDWORD(pd->wd),
          wd = pd->wd,
          LOBYTE(wd) = 0,
          v16 = wd,
          v15 = v2,
          LOBYTE(v15) = wd_high == 0,
          v2 = v16 & v15,
          (unsigned __int8)v16 & (wd_high == 0) | (wd_high < 0)) )
    {
LABEL_19:
      v4 = 2;
    }
    else
    {
      v4 = 0;
    }
  }
  if ( v4 )
    return v4;
  while ( !runtime_netpollblock(v3, mode, 0) )
  {
    v3 = pd;
    if ( pd->closing )
    {
      v5 = 1;
    }
    else
    {
      if ( mode == 114 )
      {
        rd_high = HIDWORD(pd->rd);
        rd = pd->rd;
        LOBYTE(rd) = 0;
        v9 = rd;
        v8 = v2;
        LOBYTE(v8) = rd_high == 0;
        v2 = v9 & v8;
        if ( (unsigned __int8)v9 & (rd_high == 0) | (rd_high < 0) )
          goto LABEL_11;
      }
      if ( mode == 119
        && (v10 = pd->wd, LOBYTE(v10) = 0, v11 = v2, LOBYTE(v11) = HIDWORD(pd->wd) == 0, v2 = v10 & v11, pd->wd < 0) )
      {
LABEL_11:
        v5 = 2;
      }
      else
      {
        v5 = 0;
      }
    }
    if ( v5 )
      return v5;
  }
  return 0;
}
// 80691B7: variable 'v2' is possibly undefined

//----- (08069280) --------------------------------------------------------
void __golang internal_poll_runtime_pollUnblock(runtime_pollDesc *pd)
{
  runtime_pollDesc *v1; // ecx
  string l; // [esp+0h] [ebp-20h]
  runtime_g *wg; // [esp+10h] [ebp-10h]
  runtime_g *rg; // [esp+14h] [ebp-Ch] BYREF
  uintptr *dst; // [esp+18h] [ebp-8h]
  runtime_mutex_0 *p_lock; // [esp+1Ch] [ebp-4h]

  p_lock = &pd->lock;
  runtime_lock(&pd->lock);
  if ( pd->closing )
  {
    l.str = (uint8 *)"runtime: unblock on closing polldesc";
    l.len = 36;
    runtime_throw(l);
    BUG();
  }
  pd->closing = 1;
  ++pd->seq;
  rg = 0;
  runtime_atomicstorep(&rg, 0);
  rg = runtime_netpollunblock(pd, 114, 0);
  wg = runtime_netpollunblock(pd, 119, 0);
  v1 = pd;
  if ( pd->rt.f )
  {
    dst = (uintptr *)&pd->rt.f;
    runtime_deltimer(&pd->rt);
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr(dst, 0);
    else
      pd->rt.f = 0;
    v1 = pd;
  }
  if ( v1->wt.f )
  {
    dst = (uintptr *)&v1->wt.f;
    runtime_deltimer(&v1->wt);
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr(dst, 0);
    else
      pd->wt.f = 0;
  }
  runtime_unlock(p_lock);
  if ( rg )
    runtime_netpollgoready(rg, 3);
  if ( wg )
    runtime_netpollgoready(wg, 3);
}

//----- (08069430) --------------------------------------------------------
void __golang runtime_netpollready(runtime_guintptr *gpp, runtime_pollDesc *pd, int32 mode)
{
  runtime_g *wg; // [esp+10h] [ebp-8h]
  runtime_g *rg; // [esp+14h] [ebp-4h]

  rg = 0;
  wg = 0;
  if ( mode == 114 || mode == 233 )
    rg = runtime_netpollunblock(pd, 114, 1);
  if ( mode == 119 || mode == 233 )
    wg = runtime_netpollunblock(pd, 119, 1);
  if ( rg )
  {
    rg->schedlink = *gpp;
    *gpp = (runtime_guintptr)rg;
  }
  if ( wg )
  {
    wg->schedlink = *gpp;
    *gpp = (runtime_guintptr)wg;
  }
}

//----- (08069510) --------------------------------------------------------
bool __golang runtime_netpollblockcommit(runtime_g *gp, void *gpp)
{
  bool v2; // al
  bool v3; // [esp+Ch] [ebp-Ch]

  runtime_internal_atomic_Casuintptr();
  v2 = v3;
  if ( v3 )
  {
    runtime_internal_atomic_Xadd();
    return v3;
  }
  return v2;
}
// 8069549: variable 'v3' is possibly undefined

//----- (08069590) --------------------------------------------------------
void __golang runtime_netpollgoready(runtime_g *gp, __int32 traceskip)
{
  runtime_internal_atomic_Xadd();
  runtime_goready(gp, traceskip + 1);
}

//----- (080695E0) --------------------------------------------------------
bool __golang runtime_netpollblock(runtime_pollDesc *pd, int32 mode, bool waitio)
{
  uintptr *p_rg; // ecx
  int v4; // eax
  bool v5; // zf
  string unlockf; // [esp+0h] [ebp-1Ch]
  string unlockfa; // [esp+0h] [ebp-1Ch]
  unsigned int reason; // [esp+8h] [ebp-14h]
  string reasona; // [esp+8h] [ebp-14h]
  char reason_4; // [esp+Ch] [ebp-10h]
  uintptr *gpp; // [esp+18h] [ebp-4h]

  p_rg = &pd->rg;
  if ( mode == 119 )
    p_rg = &pd->wg;
  for ( gpp = p_rg; ; p_rg = gpp )
  {
    if ( *p_rg == 1 )
    {
      *p_rg = 0;
      return 1;
    }
    if ( *p_rg )
    {
      unlockfa.str = (uint8 *)"runtime: double wait";
      unlockfa.len = 20;
      runtime_throw(unlockfa);
      BUG();
    }
    reason = 2;
    runtime_internal_atomic_Casuintptr();
    if ( reason_4 )
      break;
  }
  if ( !waitio )
  {
    if ( pd->closing )
    {
      v4 = 1;
      goto LABEL_14;
    }
    if ( mode == 114 )
    {
      if ( pd->rd < 0 )
        goto LABEL_18;
      v5 = 0;
    }
    else
    {
      v5 = mode == 119;
    }
    if ( !v5 || pd->wd >= 0 )
    {
      v4 = 0;
LABEL_14:
      if ( v4 )
        goto LABEL_10;
      goto LABEL_9;
    }
LABEL_18:
    v4 = 2;
    goto LABEL_14;
  }
LABEL_9:
  reasona.str = (uint8 *)"IO wait";
  reasona.len = 7;
  runtime_gopark(off_80E7C88, gpp, reasona, 0x1Bu, 5);
LABEL_10:
  runtime_internal_atomic_Xchguintptr();
  if ( reason > 2 )
  {
    unlockf.str = (uint8 *)"runtime: corrupted polldesc";
    unlockf.len = 27;
    runtime_throw(unlockf);
    BUG();
  }
  return reason == 1;
}
// 8069652: variable 'reason_4' is possibly undefined
// 80696AD: variable 'reason' is possibly undefined

//----- (08069780) --------------------------------------------------------
runtime_g *__golang runtime_netpollunblock(runtime_pollDesc *pd, int32 mode, bool ioready)
{
  uintptr *p_wg; // eax
  runtime_g *v4; // eax
  char v5; // [esp+Ch] [ebp-Ch]
  uintptr old; // [esp+10h] [ebp-8h]
  uintptr *gpp; // [esp+14h] [ebp-4h]

  if ( mode == 119 )
    p_wg = &pd->wg;
  else
    p_wg = &pd->rg;
  for ( gpp = p_wg; ; p_wg = gpp )
  {
    if ( *p_wg == 1 )
      return 0;
    if ( !*p_wg && !ioready )
      return 0;
    old = *p_wg;
    runtime_internal_atomic_Casuintptr();
    if ( v5 )
      break;
  }
  v4 = (runtime_g *)old;
  if ( old == 2 )
    return 0;
  return v4;
}
// 80697EA: variable 'v5' is possibly undefined

//----- (08069830) --------------------------------------------------------
runtime_pollDesc *__golang runtime___ptr_pollCache__alloc(runtime_pollCache_0 *c)
{
  char *v1; // eax
  runtime_pollCache_0 *l; // ecx
  unsigned int i; // edx
  runtime_pollDesc *v4; // ebp
  runtime_pollDesc *pd; // [esp+10h] [ebp-4h]

  runtime_lock(&c->lock);
  if ( c->first )
  {
    l = c;
  }
  else
  {
    v1 = (char *)runtime_persistentalloc(0xFF0u, 0, &runtime_memstats.other_sys);
    l = c;
    for ( i = 0; i < 0x22; ++i )
    {
      v4 = (runtime_pollDesc *)&v1[120 * i];
      v4->link = c->first;
      c->first = v4;
    }
  }
  pd = l->first;
  l->first = pd->link;
  runtime_unlock(&l->lock);
  return pd;
}

//----- (080698E0) --------------------------------------------------------
void __golang runtime_netpollinit()
{
  string s; // [esp+0h] [ebp-Ch]
  string sa; // [esp+0h] [ebp-Ch]
  int s_4; // [esp+4h] [ebp-8h]
  int v3; // [esp+8h] [ebp-4h]

  runtime_epollcreate1();
  runtime_epfd = s_4;
  if ( s_4 < 0 )
  {
    runtime_epollcreate();
    runtime_epfd = s_4;
    v3 = s_4;
    runtime_printlock();
    s.str = (uint8 *)"runtime: epollcreate failed with";
    s.len = 32;
    runtime_printstring(s);
    runtime_printsp();
    runtime_printint(-v3);
    runtime_printnl();
    runtime_printunlock();
    sa.str = (uint8 *)"runtime: netpollinit failed";
    sa.len = 27;
    runtime_throw(sa);
    BUG();
  }
}
// 806992B: conditional instruction was optimized away because %s@4.4<0
// 8069909: variable 's_4' is possibly undefined

//----- (080699B0) --------------------------------------------------------
int32 __golang runtime_netpollopen(uintptr fd, runtime_pollDesc *pd)
{
  int v2; // [esp+10h] [ebp-10h]

  runtime_epollctl();
  return -v2;
}
// 8069A1F: variable 'v2' is possibly undefined

//----- (08069A30) --------------------------------------------------------
int32 __golang runtime_netpollclose(uintptr fd)
{
  int v1; // [esp+10h] [ebp-10h]

  runtime_epollctl();
  return -v1;
}
// 8069A89: variable 'v1' is possibly undefined

//----- (08069AA0) --------------------------------------------------------
runtime_g *__golang runtime_netpoll(bool block)
{
  unsigned int j; // ecx
  uint32 v2; // ebx
  int v3; // ebp
  int32 mode; // ebx
  int v5; // eax
  string gpp; // [esp+0h] [ebp-624h]
  string gppa; // [esp+0h] [ebp-624h]
  string gppb; // [esp+0h] [ebp-624h]
  int v9; // [esp+10h] [ebp-614h]
  int32 i; // [esp+1Ch] [ebp-608h]
  runtime_guintptr gp; // [esp+20h] [ebp-604h] BYREF
  runtime_epollevent_0 events[128]; // [esp+24h] [ebp-600h] BYREF

  while ( (unsigned int)&events[7].data[4] <= *(_DWORD *)(*(_DWORD *)(__readgsdword(0) - 4) + 8) )
    runtime_morestack_noctxt();
  if ( runtime_epfd == -1 )
    return 0;
  memset(events, 0, sizeof(events));
  do
  {
    while ( 1 )
    {
      runtime_epollwait();
      v5 = v9;
      if ( v9 >= 0 )
        break;
      if ( v9 != -4 )
      {
        runtime_printlock();
        gpp.str = (uint8 *)"runtime: epollwait on fd";
        gpp.len = 24;
        runtime_printstring(gpp);
        runtime_printsp();
        runtime_printint(runtime_epfd);
        runtime_printsp();
        gppa.str = (uint8 *)"failed with";
        gppa.len = 11;
        runtime_printstring(gppa);
        runtime_printsp();
        runtime_printint(-v9);
        runtime_printnl();
        runtime_printunlock();
        gppb.str = (uint8 *)"runtime: netpoll failed";
        gppb.len = 23;
        runtime_throw(gppb);
        BUG();
      }
    }
    gp = 0;
    for ( j = 0; (int)j < v5; ++j )
    {
      if ( j >= 0x80 )
        runtime_panicindex();
      v2 = events[j].events;
      if ( v2 )
      {
        if ( (v2 & 0x2019) != 0 )
          v3 = 114;
        else
          v3 = 0;
        if ( (v2 & 0x1C) != 0 )
          mode = v3 + 119;
        else
          mode = v3;
        if ( mode )
        {
          i = j;
          runtime_netpollready(&gp, *(runtime_pollDesc **)events[j].data, mode);
          v5 = v9;
          j = i;
        }
      }
    }
  }
  while ( block && !gp );
  return (runtime_g *)gp;
}
// 8069B59: variable 'v9' is possibly undefined

//----- (08069CA0) --------------------------------------------------------
void __golang runtime_futexsleep(uint32 *addr, uint32 val, int64 ns)
{
  runtime_timespec_0 ts; // [esp+1Ch] [ebp-8h] BYREF

  ts.tv_nsec = 0;
  if ( ns >= 0 )
  {
    ts.tv_nsec = 0;
    runtime_timediv(ns, 1000000000, &ts.tv_nsec);
    runtime_futex();
  }
  else
  {
    runtime_futex();
  }
}

//----- (08069D70) --------------------------------------------------------
void __golang runtime_futexwakeup(uint32 *addr, uint32 cnt)
{
  int v2; // [esp+18h] [ebp-10h]

  runtime_futex();
  if ( v2 < 0 )
  {
    runtime_systemstack();
    MEMORY[0x1006] = 4102;
  }
}
// 8069DAD: variable 'v2' is possibly undefined

//----- (08069DF0) --------------------------------------------------------
int32 __golang runtime_getproccount()
{
  int v0; // esi
  int v1; // ecx
  uintptr *v2; // edx
  int32 v3; // ebx
  uintptr i; // ebp
  int v6; // [esp+Ch] [ebp-2004h]
  uintptr buf[2048]; // [esp+10h] [ebp-2000h] BYREF

  while ( 1 )
  {
    v0 = *(_DWORD *)(*(_DWORD *)(__readgsdword(0) - 4) + 8);
    if ( v0 != -1314 && (unsigned int)&STACK[0x2380] - v0 > 0x2300 )
      break;
    runtime_morestack_noctxt();
  }
  memset(buf, 0, sizeof(buf));
  runtime_sched_getaffinity();
  if ( v6 < 0 )
    return 1;
  if ( (unsigned int)(v6 / 4) > 0x800 )
    runtime_panicslice();
  v1 = 0;
  v2 = buf;
  v3 = 0;
  while ( v1 < v6 / 4 )
  {
    for ( i = *v2; i; i >>= 1 )
      v3 += i & 1;
    ++v2;
    ++v1;
  }
  if ( v3 )
    return v3;
  else
    return 1;
}
// 8069E55: variable 'v6' is possibly undefined

//----- (08069ED0) --------------------------------------------------------
void __golang runtime_newosproc(runtime_m *mp, void *stk)
{
  string how; // [esp+0h] [ebp-30h]
  string howa; // [esp+0h] [ebp-30h]
  string howb; // [esp+0h] [ebp-30h]
  string howc; // [esp+0h] [ebp-30h]
  string howd; // [esp+0h] [ebp-30h]
  int v7; // [esp+14h] [ebp-1Ch]
  int32 _r0; // [esp+18h] [ebp-18h]
  runtime_sigset oset; // [esp+20h] [ebp-10h] BYREF
  interface_{} f; // [esp+28h] [ebp-8h]

  oset[0] = 0;
  oset[1] = 0;
  runtime_sigprocmask(2, (runtime_sigset *)runtime_sigset_all, (runtime_sigset *)oset);
  f._type = (runtime__type_0 *)&unk_80CA340;
  f.data = &off_80E7C84;
  runtime_clone();
  runtime_sigprocmask(2, (runtime_sigset *)oset, 0);
  if ( v7 < 0 )
  {
    _r0 = runtime_sched.mcount;
    runtime_printlock();
    how.str = (uint8 *)"runtime: failed to create new OS thread (have ";
    how.len = 46;
    runtime_printstring(how);
    runtime_printint(_r0);
    howa.str = (uint8 *)" already; errno=";
    howa.len = 16;
    runtime_printstring(howa);
    runtime_printint(-v7);
    howb.str = (uint8 *)")\n";
    howb.len = 2;
    runtime_printstring(howb);
    runtime_printunlock();
    if ( v7 == -11 )
    {
      runtime_printlock();
      howc.str = (uint8 *)"runtime: may need to increase max user processes (ulimit -u";
      howc.len = 60;
      runtime_printstring(howc);
      runtime_printnl();
      runtime_printunlock();
    }
    howd.str = (uint8 *)"newosproc";
    howd.len = 9;
    runtime_throw(howd);
    BUG();
  }
}
// 8069F8E: variable 'v7' is possibly undefined
// 80E7C84: using guessed type int (__golang *off_80E7C84)();

//----- (0806A070) --------------------------------------------------------
void __golang runtime_sysargs(int32 argc, uint8 **argv)
{
  int32 i; // eax
  __uintptr auxv; // [esp+0h] [ebp-22Ch]
  __uintptr auxva; // [esp+0h] [ebp-22Ch]
  uintptr buf[128]; // [esp+28h] [ebp-204h] BYREF

  while ( (unsigned int)&buf[22] <= *(_DWORD *)(*(_DWORD *)(__readgsdword(0) - 4) + 8) )
    runtime_morestack_noctxt();
  for ( i = argc + 1; argv[i]; ++i )
    ;
  auxv.array = (uintptr *)&argv[i + 1];
  *(_QWORD *)&auxv.len = 0x1000000010000000LL;
  if ( !runtime_sysauxv(auxv) )
  {
    if ( !runtime_procAuxv.len )
      runtime_panicindex();
    runtime_open();
    runtime_duffzero();
    runtime_read();
    runtime_closefd();
    buf[126] = 0;
    auxva.array = buf;
    *(_QWORD *)&auxva.len = 0x8000000080LL;
    runtime_sysauxv(auxva);
  }
}
// 806A10C: conditional instruction was optimized away because %var_220.4==0
// 806A22D: conditional instruction was optimized away because %n.4==0

//----- (0806A280) --------------------------------------------------------
__int32 __golang runtime_sysauxv(__uintptr auxv)
{
  __int32 j; // eax
  uintptr v2; // ebx
  uint8 *src; // ebx
  __int32 i; // [esp+8h] [ebp-4h]

  for ( j = 0; ; j += 2 )
  {
    if ( (unsigned int)j >= auxv.len )
      runtime_panicindex();
    v2 = auxv.array[j];
    if ( !v2 )
      break;
    if ( (unsigned int)(j + 1) >= auxv.len )
      runtime_panicindex();
    if ( v2 == 6 )
    {
      runtime_physPageSize = auxv.array[j + 1];
    }
    else if ( v2 == 25 )
    {
      src = (uint8 *)auxv.array[j + 1];
      runtime_startupRandomData.len = 16;
      runtime_startupRandomData.cap = 16;
      if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      {
        i = j;
        runtime_writebarrierptr((uintptr *)&runtime_startupRandomData, (uintptr)src);
        j = i;
      }
      else
      {
        runtime_startupRandomData.array = src;
      }
    }
  }
  return j / 2;
}

//----- (0806A360) --------------------------------------------------------
void __golang runtime_osinit()
{
  runtime_ncpu = runtime_getproccount();
}

//----- (0806A390) --------------------------------------------------------
void __golang runtime_getRandomData(__uint8 r)
{
  __int32 len; // ecx
  __int32 v2; // [esp+Ch] [ebp-10h]
  __int32 n_0; // [esp+14h] [ebp-8h]

  len = runtime_startupRandomData.len;
  if ( runtime_startupRandomData.array )
  {
    if ( r.len <= runtime_startupRandomData.len )
      len = r.len;
    n_0 = len;
    runtime_memmove();
    runtime_extendRandom(r, n_0);
  }
  else
  {
    if ( !runtime_urandom_dev.len )
      runtime_panicindex();
    runtime_open();
    if ( !r.len )
      runtime_panicindex();
    runtime_read();
    runtime_closefd();
    runtime_extendRandom(r, v2);
  }
}
// 806A484: variable 'v2' is possibly undefined

//----- (0806A4B0) --------------------------------------------------------
void __golang runtime_goenvs()
{
  runtime_goenvs_unix();
}

//----- (0806A4D0) --------------------------------------------------------
void __golang runtime_mpreinit(runtime_m *mp)
{
  runtime_m *v1; // eax
  runtime_g *v2; // ebx
  runtime_g *src; // [esp+4h] [ebp-8h]
  runtime_g *v4; // [esp+8h] [ebp-4h]

  src = runtime_malg(0x8000);
  v1 = mp;
  v2 = src;
  if ( *(_DWORD *)&runtime_writeBarrier.enabled )
  {
    v4 = src;
    runtime_writebarrierptr((uintptr *)&mp->gsignal, (uintptr)src);
    v1 = mp;
    v2 = v4;
  }
  else
  {
    mp->gsignal = src;
  }
  if ( *(_DWORD *)&runtime_writeBarrier.enabled )
    runtime_writebarrierptr((uintptr *)&v2->m, (uintptr)v1);
  else
    v2->m = v1;
}
// 806A4D0: could not find valid save-restore pair for ebx

//----- (0806A550) --------------------------------------------------------
void __golang runtime_minit()
{
  int v0; // eax
  int v1; // [esp+0h] [ebp-4h]

  runtime_minitSignals();
  runtime_gettid();
  v0 = *(_DWORD *)(*(_DWORD *)(__readgsdword(0) - 4) + 24);
  *(_DWORD *)(v0 + 36) = v1;
  *(_DWORD *)(v0 + 40) = 0;
}
// 806A582: variable 'v1' is possibly undefined

//----- (0806A5A0) --------------------------------------------------------
// attributes: thunk
void __golang runtime_unminit()
{
  runtime_unminitSignals();
}

//----- (0806A5B0) --------------------------------------------------------
void __golang runtime_sigprocmask(int32 how, runtime_sigset *newa, runtime_sigset *old)
{
  runtime_rtsigprocmask();
}

//----- (0806A5E0) --------------------------------------------------------
void __golang runtime_setsig(uint32 i, uintptr fn)
{
  ((void (*)(void))loc_808FD8B)();
  runtime_rt_sigaction();
}

//----- (0806A6F0) --------------------------------------------------------
void __golang runtime_setsigstack(uint32 i)
{
  int sa_4; // [esp+18h] [ebp-10h]

  ((void (*)(void))loc_808FD8B)();
  runtime_rt_sigaction();
  if ( (sa_4 & 0x8000000) == 0 )
    runtime_rt_sigaction();
}
// 806A726: variable 'sa_4' is possibly undefined

//----- (0806A770) --------------------------------------------------------
uintptr __golang runtime_getsig(uint32 i)
{
  string s; // [esp+0h] [ebp-28h]
  int v2; // [esp+10h] [ebp-18h]
  uintptr sa; // [esp+14h] [ebp-14h]

  ((void (*)(void))loc_808FD8B)();
  runtime_rt_sigaction();
  if ( v2 )
  {
    s.str = (uint8 *)"rt_sigaction read failure";
    s.len = 25;
    runtime_throw(s);
    BUG();
  }
  return sa;
}
// 806A7A8: variable 'v2' is possibly undefined
// 806A7AE: variable 'sa' is possibly undefined

//----- (0806A7D0) --------------------------------------------------------
void __golang runtime_panicCheckMalloc(error_0 err)
{
  int v1; // eax
  int v2; // eax

  v1 = *(_DWORD *)(__readgsdword(0) - 4);
  if ( v1 )
  {
    v2 = *(_DWORD *)(v1 + 24);
    if ( v2 )
    {
      if ( *(_DWORD *)(v2 + 104) )
      {
        if ( (runtime_interfacetype_0 **)err.tab == &go_itab_runtime_errorString_error )
        {
          runtime_throw(*(string *)err.data);
          BUG();
        }
        runtime_panicdottypeI(err.tab, (runtime__type_0 *)&want, &iface.typ);
      }
    }
  }
}
// 8136690: using guessed type runtime_interfacetype_0 *go_itab_runtime_errorString_error;

//----- (0806A860) --------------------------------------------------------
void __golang __noreturn runtime_panicindex()
{
  void *tab; // eax

  runtime_panicCheckMalloc(runtime_indexError);
  tab = runtime_indexError.tab;
  if ( runtime_indexError.tab )
    tab = runtime_indexError.tab->_type;
  runtime_gopanic((interface_{})__PAIR64__((unsigned int)runtime_indexError.data, (unsigned int)tab));
  BUG();
}

//----- (0806A8C0) --------------------------------------------------------
void __golang __noreturn runtime_panicslice()
{
  void *tab; // eax

  runtime_panicCheckMalloc(runtime_sliceError);
  tab = runtime_sliceError.tab;
  if ( runtime_sliceError.tab )
    tab = runtime_sliceError.tab->_type;
  runtime_gopanic((interface_{})__PAIR64__((unsigned int)runtime_sliceError.data, (unsigned int)tab));
  BUG();
}

//----- (0806A920) --------------------------------------------------------
void __golang __noreturn runtime_panicdivide()
{
  void *tab; // eax

  runtime_panicCheckMalloc(runtime_divideError);
  tab = runtime_divideError.tab;
  if ( runtime_divideError.tab )
    tab = runtime_divideError.tab->_type;
  runtime_gopanic((interface_{})__PAIR64__((unsigned int)runtime_divideError.data, (unsigned int)tab));
  BUG();
}

//----- (0806A980) --------------------------------------------------------
void __golang __noreturn runtime_panicoverflow()
{
  void *tab; // eax

  runtime_panicCheckMalloc(runtime_overflowError);
  tab = runtime_overflowError.tab;
  if ( runtime_overflowError.tab )
    tab = runtime_overflowError.tab->_type;
  runtime_gopanic((interface_{})__PAIR64__((unsigned int)runtime_overflowError.data, (unsigned int)tab));
  BUG();
}

//----- (0806A9E0) --------------------------------------------------------
void __golang __noreturn runtime_panicfloat()
{
  void *tab; // eax

  runtime_panicCheckMalloc(runtime_floatError);
  tab = runtime_floatError.tab;
  if ( runtime_floatError.tab )
    tab = runtime_floatError.tab->_type;
  runtime_gopanic((interface_{})__PAIR64__((unsigned int)runtime_floatError.data, (unsigned int)tab));
  BUG();
}

//----- (0806AA40) --------------------------------------------------------
void __golang __noreturn runtime_panicmem()
{
  void *tab; // eax

  runtime_panicCheckMalloc(runtime_memoryError);
  tab = runtime_memoryError.tab;
  if ( runtime_memoryError.tab )
    tab = runtime_memoryError.tab->_type;
  runtime_gopanic((interface_{})__PAIR64__((unsigned int)runtime_memoryError.data, (unsigned int)tab));
  BUG();
}

//----- (0806AAA0) --------------------------------------------------------
void __golang __noreturn runtime_throwinit()
{
  string s; // [esp+0h] [ebp-8h]

  s.str = (uint8 *)"recursive call during initialization - linker skew";
  s.len = 50;
  runtime_throw(s);
  BUG();
}

//----- (0806AAE0) --------------------------------------------------------
void __golang runtime_deferproc(int32 siz, runtime_funcval *fn)
{
  int v2; // eax
  runtime__defer *v3; // eax
  runtime__defer *v4; // eax
  string v5; // [esp+0h] [ebp-1Ch]
  string v6; // [esp+0h] [ebp-1Ch]
  uintptr src; // [esp+4h] [ebp-18h]
  runtime__defer *srca; // [esp+4h] [ebp-18h]
  uintptr callerpc; // [esp+Ch] [ebp-10h]
  runtime__defer *v10; // [esp+18h] [ebp-4h]
  int32 v11; // [esp+28h] [ebp+Ch]

  v2 = *(_DWORD *)(__readgsdword(0) - 4);
  if ( *(_DWORD *)(*(_DWORD *)(v2 + 24) + 84) != v2 )
  {
    v6.str = (uint8 *)"defer on system stack";
    v6.len = 21;
    runtime_throw(v6);
    BUG();
  }
  runtime_getcallerpc();
  callerpc = src;
  srca = runtime_newdefer(siz);
  v3 = srca;
  if ( srca->_panic )
  {
    v5.str = (uint8 *)"deferproc: d.panic != nil after newdefer";
    v5.len = 40;
    runtime_throw(v5);
    BUG();
  }
  if ( *(_DWORD *)&runtime_writeBarrier.enabled )
  {
    v10 = srca;
    runtime_writebarrierptr((uintptr *)&srca->fn, (uintptr)fn);
    v3 = v10;
  }
  else
  {
    srca->fn = fn;
  }
  v3->pc = callerpc;
  v3->sp = (uintptr)&siz;
  if ( siz )
  {
    if ( siz == 4 )
    {
      if ( v3->siz )
        v4 = v3 + 1;
      else
        v4 = 0;
      v4->siz = v11;
    }
    else
    {
      runtime_memmove();
    }
  }
  runtime_return0();
}
// 806AB1C: variable 'src' is possibly undefined

//----- (0806AC10) --------------------------------------------------------
void __golang runtime_testdefersizes()
{
  int i; // eax
  unsigned int j; // eax
  unsigned int v2; // ecx
  unsigned int v3; // edx
  unsigned int v4; // edx
  unsigned int v5; // edx
  int v6; // edi
  unsigned int v7; // edx
  unsigned int v8; // edx
  string s; // [esp+0h] [ebp-28h]
  string sa; // [esp+0h] [ebp-28h]
  string sb; // [esp+0h] [ebp-28h]
  string sc; // [esp+0h] [ebp-28h]
  string sd; // [esp+0h] [ebp-28h]
  uintptr siz; // [esp+8h] [ebp-20h]
  uintptr siz_0; // [esp+Ch] [ebp-1Ch]
  uintptr defersc; // [esp+10h] [ebp-18h]
  int32 m[5]; // [esp+14h] [ebp-14h]

  ((void (*)(void))loc_808FD8B)();
  for ( i = 0; i < 5; ++i )
  {
    if ( (unsigned int)i >= 5 )
      runtime_panicindex();
    m[i] = -1;
  }
  for ( j = 0; ; ++j )
  {
    v2 = j > 4 ? (j + 11) >> 4 : 0;
    if ( v2 >= 5 )
      break;
    if ( j > 4 )
      v3 = j + 28;
    else
      v3 = 32;
    if ( v3 >= 0x8000 )
    {
      if ( v3 + 0x2000 >= v3 )
        v3 = (v3 + 0x1FFF) & 0xFFFFE000;
    }
    else if ( v3 > 0x3F8 )
    {
      v7 = (v3 - 897) >> 7;
      if ( v7 >= 0xF9 || (v8 = runtime_size_to_class128[v7], v8 >= 0x43) )
        runtime_panicindex();
      v3 = runtime_class_to_size[v8];
    }
    else
    {
      v4 = (v3 + 7) >> 3;
      if ( v4 >= 0x81 || (v5 = runtime_size_to_class8[v4], v5 >= 0x43) )
        runtime_panicindex();
      v3 = runtime_class_to_size[v5];
    }
    v6 = m[v2];
    if ( v6 >= 0 )
    {
      if ( v6 != v3 )
      {
        defersc = v2;
        siz_0 = v3;
        siz = j;
        runtime_printlock();
        s.str = (uint8 *)"bad defer size class: i=";
        s.len = 24;
        runtime_printstring(s);
        runtime_printint(siz);
        sa.str = (uint8 *)" siz=";
        sa.len = 5;
        runtime_printstring(sa);
        runtime_printint(siz_0);
        sb.str = (uint8 *)" defersc=";
        sb.len = 9;
        runtime_printstring(sb);
        runtime_printint(defersc);
        sc.str = (uint8 *)"\n";
        sc.len = 1;
        runtime_printstring(sc);
        runtime_printunlock();
        sd.str = (uint8 *)"bad defer size class";
        sd.len = 20;
        runtime_throw(sd);
        BUG();
      }
    }
    else
    {
      m[v2] = v3;
    }
  }
}

//----- (0806AE40) --------------------------------------------------------
void __golang runtime_init_2()
{
  if ( *(_DWORD *)&runtime_writeBarrier.enabled )
    runtime_writebarrierptr(&runtime_deferType, *((_DWORD *)&stru_80C7140 + 8));
  else
    runtime_deferType = *((_DWORD *)&stru_80C7140 + 8);
}

//----- (0806AEB0) --------------------------------------------------------
runtime__defer *__golang runtime_newdefer(int32 siz)
{
  int v1; // eax
  unsigned int v2; // ecx
  runtime_g *v3; // edx
  int p; // ebp
  int v5; // ebx
  int v6; // esi
  unsigned int v7; // edi
  int v8; // ecx
  runtime_g *v9; // ebx
  runtime__defer *src; // ebp
  uintptr *dst; // esi
  int v12; // [esp+Ch] [ebp-2Ch]
  runtime_g *gp; // [esp+10h] [ebp-28h]
  runtime__defer *d; // [esp+14h] [ebp-24h] BYREF
  uintptr *p_defer; // [esp+18h] [ebp-20h]
  int v16; // [esp+1Ch] [ebp-1Ch]
  void (__golang *v17)(); // [esp+20h] [ebp-18h]
  int v18; // [esp+24h] [ebp-14h]
  runtime__defer **p_d; // [esp+28h] [ebp-10h]
  void (__golang *v20)(); // [esp+2Ch] [ebp-Ch]
  int v21; // [esp+30h] [ebp-8h]
  unsigned int v22; // [esp+34h] [ebp-4h]

  d = 0;
  v1 = siz;
  if ( (unsigned int)siz > 4 )
    v2 = (unsigned int)(siz + 11) >> 4;
  else
    v2 = 0;
  v3 = *(runtime_g **)(__readgsdword(0) - 4);
  gp = v3;
  if ( v2 < 5 )
  {
    p = v3->m->p;
    v16 = p;
    v5 = 3 * v2;
    v12 = 3 * v2;
    if ( !*(_DWORD *)(p + 12 * v2 + 64) && runtime_sched.deferpool[v2] )
    {
      v20 = runtime_newdefer_func1;
      v21 = p;
      v22 = v2;
      runtime_systemstack();
      v1 = siz;
      v5 = v12;
      p = v16;
    }
    v6 = *(_DWORD *)(p + 4 * v5 + 64);
    if ( v6 > 0 )
    {
      v7 = v6 - 1;
      if ( v6 - 1 >= (unsigned int)v6 )
        runtime_panicindex();
      d = *(runtime__defer **)(*(_DWORD *)(p + 4 * v5 + 60) + 4 * v6 - 4);
      v8 = *(_DWORD *)(p + 4 * v5 + 60);
      if ( v7 >= *(_DWORD *)(p + 4 * v5 + 64) )
        runtime_panicindex();
      p_defer = (uintptr *)(v8 + 4 * v6 - 4);
      if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      {
        runtime_writebarrierptr(p_defer, 0);
        v1 = siz;
        v5 = v12;
        p = v16;
        v7 = v6 - 1;
      }
      else
      {
        *(_DWORD *)(v8 + 4 * v6 - 4) = 0;
      }
      if ( v7 > *(_DWORD *)(p + 4 * v5 + 68) )
        runtime_panicslice();
      *(_DWORD *)(p + 4 * v5 + 64) = v7;
    }
  }
  if ( !d )
  {
    v17 = runtime_newdefer_func2;
    v18 = v1;
    p_d = &d;
    runtime_systemstack();
    v1 = siz;
  }
  d->siz = v1;
  v9 = gp;
  src = gp->_defer;
  dst = (uintptr *)&gp->_defer;
  if ( *(_DWORD *)&runtime_writeBarrier.enabled )
  {
    p_defer = (uintptr *)&gp->_defer;
    runtime_writebarrierptr((uintptr *)&d->link, (uintptr)src);
    v9 = gp;
    dst = p_defer;
  }
  else
  {
    d->link = src;
  }
  if ( *(_DWORD *)&runtime_writeBarrier.enabled )
    runtime_writebarrierptr(dst, (uintptr)d);
  else
    v9->_defer = d;
  return d;
}
// 806AEB0: could not find valid save-restore pair for ebx

//----- (0806B090) --------------------------------------------------------
void __golang runtime_freedefer(runtime__defer *d)
{
  runtime__defer *v1; // edi
  unsigned int v2; // eax
  int v3; // edx
  int v4; // edx
  int v5; // eax
  __int32 v6; // ecx
  __int32 v7; // ebx
  uintptr *v8; // ebp
  uintptr *array; // eax
  __int32 len; // ecx
  int v11; // ebx
  int v12; // ebp
  uintptr *dst; // [esp+0h] [ebp-40h]
  runtime_slice_0 src; // [esp+4h] [ebp-3Ch]
  runtime_slice_0 v15; // [esp+14h] [ebp-2Ch]
  int v16; // [esp+24h] [ebp-1Ch]
  uintptr *v17; // [esp+2Ch] [ebp-14h]
  int v18; // [esp+30h] [ebp-10h]
  int v19[3]; // [esp+34h] [ebp-Ch] BYREF

  v1 = d;
  if ( d->_panic )
    runtime_freedeferpanic();
  if ( d->fn )
    runtime_freedeferfn();
  if ( d->siz > 4u )
    v2 = (unsigned int)(d->siz + 11) >> 4;
  else
    v2 = 0;
  if ( v2 < 5 )
  {
    v3 = *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(__readgsdword(0) - 4) + 24) + 92);
    v18 = v3;
    v16 = 3 * v2;
    v17 = (uintptr *)(v3 + 12 * v2 + 60);
    if ( *(_DWORD *)(v3 + 12 * v2 + 64) == *(_DWORD *)(v3 + 12 * v2 + 68) )
    {
      v19[0] = (int)runtime_freedefer_func1;
      v19[1] = v3;
      v19[2] = v2;
      dst = (uintptr *)v19;
      runtime_systemstack();
      v1 = d;
    }
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
    {
      runtime_typedmemclr((runtime__type_0 *)&stru_80D9160, v1);
      v4 = v18;
    }
    else
    {
      ((void (__golang *)(uintptr *))loc_808FD89)(dst);
    }
    v5 = v16;
    v6 = *(_DWORD *)(v4 + 4 * v16 + 68);
    v7 = *(_DWORD *)(v4 + 4 * v16 + 64);
    v8 = *(uintptr **)(v4 + 4 * v16 + 60);
    if ( v7 + 1 > v6 )
    {
      src.array = *(void **)(v4 + 4 * v16 + 60);
      *(_QWORD *)&src.len = __PAIR64__(v6, v7);
      v15 = runtime_growslice((runtime__type_0 *)&stru_80C7140, src, v7 + 1);
      array = (uintptr *)v15.array;
      len = v15.len;
      v11 = v16;
      v12 = v18;
      *(_DWORD *)(v18 + 4 * v16 + 68) = v15.cap;
      if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      {
        runtime_writebarrierptr(v17, (uintptr)v15.array);
        array = (uintptr *)v15.array;
        len = v15.len;
        v11 = v16;
        v12 = v18;
      }
      else
      {
        *(_DWORD *)(v18 + 4 * v16 + 60) = v15.array;
      }
      v4 = v12;
      v8 = array;
      v5 = v11;
      v7 = len;
    }
    *(_DWORD *)(v4 + 4 * v5 + 64) = v7 + 1;
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr(&v8[v7], (uintptr)d);
    else
      v8[v7] = (uintptr)d;
  }
}
// 806B10D: variable 'dst' is possibly undefined
// 806B116: variable 'v4' is possibly undefined

//----- (0806B250) --------------------------------------------------------
void __golang __noreturn runtime_freedeferpanic()
{
  string s; // [esp+0h] [ebp-8h]

  s.str = (uint8 *)"freedefer with d._panic != nil";
  s.len = 30;
  runtime_throw(s);
  BUG();
}

//----- (0806B290) --------------------------------------------------------
void __golang __noreturn runtime_freedeferfn()
{
  string s; // [esp+0h] [ebp-8h]

  s.str = (uint8 *)"freedefer with d.fn != nil";
  s.len = 26;
  runtime_throw(s);
  BUG();
}

//----- (0806B2D0) --------------------------------------------------------
void __golang runtime_deferreturn(uintptr arg0)
{
  runtime_g *v1; // eax
  runtime__defer *d; // ecx
  uintptr *p_defer; // edx
  uintptr src; // edi
  runtime_g *gp; // [esp+Ch] [ebp-14h]
  runtime__defer *defer; // [esp+14h] [ebp-Ch]
  uintptr *v7; // [esp+18h] [ebp-8h]

  v1 = *(runtime_g **)(__readgsdword(0) - 4);
  d = v1->_defer;
  p_defer = (uintptr *)&v1->_defer;
  if ( d && (uintptr *)d->sp == &arg0 )
  {
    gp = v1;
    v7 = (uintptr *)&v1->_defer;
    defer = v1->_defer;
    if ( d->siz )
    {
      if ( d->siz == 4 )
      {
        arg0 = d[1].siz;
      }
      else
      {
        runtime_memmove();
        v1 = gp;
        d = defer;
        p_defer = v7;
      }
    }
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
    {
      runtime_writebarrierptr((uintptr *)&d->fn, 0);
      v1 = gp;
      d = defer;
      p_defer = v7;
    }
    else
    {
      d->fn = 0;
    }
    src = (uintptr)d->link;
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
    {
      runtime_writebarrierptr(p_defer, src);
      d = defer;
    }
    else
    {
      v1->_defer = (runtime__defer *)src;
    }
    runtime_freedefer(d);
    runtime_jmpdefer();
  }
}

//----- (0806B3F0) --------------------------------------------------------
void __golang runtime_preprintpanics(runtime__panic *p)
{
  int v1; // eax
  runtime__panic *v3; // edx
  runtime__panic *v4; // edx
  uintptr siz; // [esp+0h] [ebp-34h]
  long double e; // [esp+8h] [ebp-2Ch]
  bool v7; // [esp+14h] [ebp-20h]
  interface_{}_0 arg; // [esp+18h] [ebp-1Ch]
  uintptr *dst; // [esp+20h] [ebp-14h]
  int v10[2]; // [esp+24h] [ebp-10h] BYREF
  int elem[2]; // [esp+2Ch] [ebp-8h] BYREF
  runtime__panic *pa; // [esp+38h] [ebp+4h]

  runtime_deferproc(0, (runtime_funcval *)&stru_80E7CA4);
  if ( v1 )
  {
    runtime_deferreturn(siz);
  }
  else
  {
    while ( p )
    {
      if ( p->arg._type )
      {
        pa = p;
        dst = (uintptr *)&p->arg.data;
        arg = p->arg;
        runtime_assertE2I2((runtime_interfacetype_0 *)&iface, arg, *(runtime_iface_0 *)((char *)&e + 4), v7);
        if ( v7 )
        {
          elem[0] = (*(int (__golang **)(_DWORD))(DWORD1(e) + 20))(HIDWORD(e));
          elem[1] = LODWORD(e);
          runtime_convT2Estring((runtime__type_0 *)&t, elem, *(runtime_eface_0 *)&e);
          v3 = pa;
          pa->arg._type = (runtime__type_0 *)LODWORD(e);
          if ( *(_DWORD *)&runtime_writeBarrier.enabled )
          {
            runtime_writebarrierptr(dst, DWORD1(e));
            v3 = pa;
          }
          else
          {
            pa->arg.data = (void *)DWORD1(e);
          }
          p = v3;
        }
        else
        {
          runtime_assertE2I2((runtime_interfacetype_0 *)&inter, arg, *(runtime_iface_0 *)((char *)&e + 4), 0);
          if ( v7 )
          {
            v10[0] = (*(int (__golang **)(_DWORD))(DWORD1(e) + 20))(HIDWORD(e));
            v10[1] = LODWORD(e);
            runtime_convT2Estring((runtime__type_0 *)&t, v10, *(runtime_eface_0 *)&e);
            v4 = pa;
            pa->arg._type = (runtime__type_0 *)LODWORD(e);
            if ( *(_DWORD *)&runtime_writeBarrier.enabled )
            {
              runtime_writebarrierptr(dst, DWORD1(e));
              v4 = pa;
            }
            else
            {
              pa->arg.data = (void *)DWORD1(e);
            }
            p = v4;
          }
          else
          {
            p = pa;
          }
        }
      }
      p = p->link;
    }
    runtime_deferreturn(siz);
  }
}
// 806B421: variable 'v1' is possibly undefined
// 806B466: variable 'e' is possibly undefined
// 806B466: variable 'v7' is possibly undefined
// 806B583: variable 'siz' is possibly undefined

//----- (0806B5A0) --------------------------------------------------------
void __golang runtime_printpanics(runtime__panic *p)
{
  string sa; // [esp+0h] [ebp-8h]
  string sc; // [esp+0h] [ebp-8h]
  string sb; // [esp+0h] [ebp-8h]
  string s; // [esp+0h] [ebp-8h]

  if ( p->link )
  {
    runtime_printpanics(p->link);
    runtime_printlock();
    s.str = (uint8 *)"\t";
    s.len = 1;
    runtime_printstring(s);
    runtime_printunlock();
  }
  runtime_printlock();
  sa.str = (uint8 *)"panic: ";
  sa.len = 7;
  runtime_printstring(sa);
  runtime_printunlock();
  runtime_printany(p->arg);
  if ( p->recovered )
  {
    runtime_printlock();
    sb.str = (uint8 *)" [recovered]";
    sb.len = 12;
    runtime_printstring(sb);
    runtime_printunlock();
  }
  runtime_printlock();
  sc.str = (uint8 *)"\n";
  sc.len = 1;
  runtime_printstring(sc);
  runtime_printunlock();
}
// 80E0D9D: using guessed type char asc_80E0D9D;

//----- (0806B690) --------------------------------------------------------
void __golang runtime_gopanic(interface_{} e)
{
  runtime_g *v1; // ecx
  runtime_m *m; // edx
  runtime_g *v3; // eax
  runtime__defer *defer; // ecx
  uintptr *p_defer; // edx
  runtime__panic *panic; // ebx
  uintptr src; // ebp
  runtime__defer *v8; // eax
  runtime_g *v9; // edx
  uintptr link; // ebx
  runtime_g *v11; // eax
  runtime__panic *v12; // ecx
  bool v13; // zf
  uintptr v14; // ecx
  runtime_m *v15; // eax
  string d; // [esp+0h] [ebp-50h]
  string da; // [esp+0h] [ebp-50h]
  string db; // [esp+0h] [ebp-50h]
  string dc; // [esp+0h] [ebp-50h]
  string dd; // [esp+0h] [ebp-50h]
  string de; // [esp+0h] [ebp-50h]
  string df; // [esp+0h] [ebp-50h]
  string dg; // [esp+0h] [ebp-50h]
  string dh; // [esp+0h] [ebp-50h]
  string di; // [esp+0h] [ebp-50h]
  string dj; // [esp+0h] [ebp-50h]
  string dk; // [esp+0h] [ebp-50h]
  string dl; // [esp+0h] [ebp-50h]
  string dm; // [esp+0h] [ebp-50h]
  string dn; // [esp+0h] [ebp-50h]
  string dp; // [esp+0h] [ebp-50h]
  string dq; // [esp+0h] [ebp-50h]
  uintptr pc; // [esp+14h] [ebp-3Ch]
  __int32 len; // [esp+18h] [ebp-38h]
  void *sp_0; // [esp+1Ch] [ebp-34h]
  runtime_g *gp; // [esp+20h] [ebp-30h]
  uint8 *s; // [esp+24h] [ebp-2Ch]
  uintptr *s_4; // [esp+28h] [ebp-28h]
  uintptr *dst; // [esp+2Ch] [ebp-24h]
  runtime__defer *v40; // [esp+30h] [ebp-20h]
  uintptr *p_panic; // [esp+38h] [ebp-18h]
  runtime__panic_0 p; // [esp+3Ch] [ebp-14h] BYREF

  v1 = *(runtime_g **)(__readgsdword(0) - 4);
  m = v1->m;
  if ( m->curg != v1 )
  {
    runtime_printlock();
    dn.str = (uint8 *)"panic: ";
    dn.len = 7;
    runtime_printstring(dn);
    runtime_printunlock();
    runtime_printany(e);
    runtime_printlock();
    dp.str = (uint8 *)"\n";
    dp.len = 1;
    runtime_printstring(dp);
    runtime_printunlock();
    dq.str = (uint8 *)"panic on system stack";
    dq.len = 21;
    runtime_throw(dq);
    BUG();
  }
  if ( m->softfloat )
  {
    --m->locks;
    v1->m->softfloat = 0;
    dm.str = (uint8 *)"panic during softfloat";
    dm.len = 22;
    runtime_throw(dm);
    BUG();
  }
  if ( m->mallocing )
  {
    runtime_printlock();
    dj.str = (uint8 *)"panic: ";
    dj.len = 7;
    runtime_printstring(dj);
    runtime_printunlock();
    runtime_printany(e);
    runtime_printlock();
    dk.str = (uint8 *)"\n";
    dk.len = 1;
    runtime_printstring(dk);
    runtime_printunlock();
    dl.str = (uint8 *)"panic during malloc";
    dl.len = 19;
    runtime_throw(dl);
    BUG();
  }
  gp = v1;
  if ( m->preemptoff.len )
  {
    runtime_printlock();
    de.str = (uint8 *)"panic: ";
    de.len = 7;
    runtime_printstring(de);
    runtime_printunlock();
    runtime_printany(e);
    runtime_printlock();
    df.str = (uint8 *)"\n";
    df.len = 1;
    runtime_printstring(df);
    runtime_printunlock();
    runtime_printlock();
    dg.str = (uint8 *)"preempt off reason: ";
    dg.len = 20;
    runtime_printstring(dg);
    runtime_printunlock();
    v15 = gp->m;
    s = v15->preemptoff.str;
    len = v15->preemptoff.len;
    runtime_printlock();
    runtime_printstring((string)__PAIR64__(len, (unsigned int)s));
    runtime_printunlock();
    runtime_printlock();
    dh.str = (uint8 *)"\n";
    dh.len = 1;
    runtime_printstring(dh);
    runtime_printunlock();
    di.str = (uint8 *)"panic during preemptoff";
    di.len = 23;
    runtime_throw(di);
    BUG();
  }
  if ( m->locks )
  {
    runtime_printlock();
    db.str = (uint8 *)"panic: ";
    db.len = 7;
    runtime_printstring(db);
    runtime_printunlock();
    runtime_printany(e);
    runtime_printlock();
    dc.str = (uint8 *)"\n";
    dc.len = 1;
    runtime_printstring(dc);
    runtime_printunlock();
    dd.str = (uint8 *)"panic holding locks";
    dd.len = 19;
    runtime_throw(dd);
    BUG();
  }
  ((void (*)(void))loc_808FD8B)();
  p.arg = e;
  p.link = gp->_panic;
  p_panic = (uintptr *)&gp->_panic;
  if ( *(_DWORD *)&runtime_writeBarrier.enabled )
    runtime_writebarrierptr((uintptr *)&gp->_panic, (uintptr)&p);
  else
    gp->_panic = &p;
  runtime_internal_atomic_Xadd();
  while ( 1 )
  {
    v3 = gp;
    defer = gp->_defer;
    p_defer = (uintptr *)&gp->_defer;
    if ( !defer )
      break;
    v40 = gp->_defer;
    if ( defer->started )
    {
      panic = defer->_panic;
      if ( panic )
        panic->aborted = 1;
      if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      {
        dst = (uintptr *)&defer->fn;
        runtime_writebarrierptr((uintptr *)&defer->_panic, 0);
        runtime_writebarrierptr(dst, 0);
        v3 = gp;
        defer = v40;
        p_defer = (uintptr *)&gp->_defer;
      }
      else
      {
        defer->_panic = 0;
        defer->fn = 0;
      }
      src = (uintptr)defer->link;
      if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      {
        runtime_writebarrierptr(p_defer, src);
        defer = v40;
      }
      else
      {
        v3->_defer = (runtime__defer *)src;
      }
      runtime_freedefer(defer);
    }
    else
    {
      defer->started = 1;
      s_4 = (uintptr *)&defer->_panic;
      if ( *(_DWORD *)&runtime_writeBarrier.enabled )
        runtime_writebarrierptr((uintptr *)&defer->_panic, (uintptr)&p);
      else
        defer->_panic = &p;
      p.argp = (void *)runtime_getargp(0);
      runtime_reflectcall();
      p.argp = 0;
      v8 = v40;
      v9 = gp;
      if ( gp->_defer != v40 )
      {
        da.str = (uint8 *)"bad defer entry in panic";
        da.len = 24;
        runtime_throw(da);
        BUG();
      }
      if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      {
        runtime_writebarrierptr(s_4, 0);
        runtime_writebarrierptr((uintptr *)&v40->fn, 0);
        v8 = v40;
        v9 = gp;
      }
      else
      {
        v40->_panic = 0;
        v40->fn = 0;
      }
      link = (uintptr)v8->link;
      if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      {
        runtime_writebarrierptr((uintptr *)&gp->_defer, link);
        v8 = v40;
      }
      else
      {
        v9->_defer = (runtime__defer *)link;
      }
      pc = v8->pc;
      sp_0 = (void *)v8->sp;
      runtime_freedefer(v8);
      if ( p.recovered )
      {
        runtime_internal_atomic_Xadd();
        if ( *(_DWORD *)&runtime_writeBarrier.enabled )
        {
          runtime_writebarrierptr(p_panic, (uintptr)p.link);
          v11 = gp;
        }
        else
        {
          v11 = gp;
          gp->_panic = p.link;
        }
        while ( 1 )
        {
          v12 = v11->_panic;
          v13 = v12 == 0;
          if ( !v12 )
            goto LABEL_36;
          if ( !v12->aborted )
            break;
          v14 = (uintptr)v12->link;
          if ( *(_DWORD *)&runtime_writeBarrier.enabled )
          {
            runtime_writebarrierptr(p_panic, v14);
            v11 = gp;
          }
          else
          {
            v11->_panic = (runtime__panic *)v14;
          }
        }
        v13 = v12 == 0;
LABEL_36:
        if ( v13 )
          v11->sig = 0;
        v11->sigcode0 = (uintptr)sp_0;
        v11->sigcode1 = pc;
        runtime_mcall();
        d.str = (uint8 *)"recovery failed";
        d.len = 15;
        runtime_throw(d);
        BUG();
      }
    }
  }
  runtime_preprintpanics(gp->_panic);
  runtime_startpanic();
  runtime_internal_atomic_Xadd();
  runtime_printpanics(gp->_panic);
  runtime_dopanic(0);
  MEMORY[0] = 0;
}

//----- (0806BCE0) --------------------------------------------------------
uintptr __golang runtime_getargp(__int32 x)
{
  return (uintptr)&x;
}
// 806BCE4: returning address of temporary local variable '%x'

//----- (0806BCF0) --------------------------------------------------------
interface_{} __golang runtime_gorecover(uintptr argp)
{
  int v1; // eax
  interface_{} _r1; // [esp+8h] [ebp+8h]

  v1 = *(_DWORD *)(*(_DWORD *)(__readgsdword(0) - 4) + 16);
  if ( v1 && !*(_BYTE *)(v1 + 16) && argp == *(_DWORD *)v1 )
  {
    *(_BYTE *)(v1 + 16) = 1;
    return *(interface_{} *)(v1 + 4);
  }
  else
  {
    _r1._type = 0;
    _r1.data = 0;
  }
  return _r1;
}

//----- (0806BD40) --------------------------------------------------------
void __golang runtime_startpanic()
{
  runtime_systemstack();
}

//----- (0806BD60) --------------------------------------------------------
void __golang runtime_dopanic(__int32 unused)
{
  runtime_getcallerpc();
  runtime_systemstack();
  MEMORY[0] = 0;
}

//----- (0806BDC0) --------------------------------------------------------
void __golang runtime_throw(string s)
{
  int v1; // eax
  string v2; // [esp+0h] [ebp-8h]
  string v3; // [esp+0h] [ebp-8h]

  runtime_printlock();
  v2.str = (uint8 *)"fatal error: ";
  v2.len = 13;
  runtime_printstring(v2);
  runtime_printstring(s);
  v3.str = (uint8 *)"\n";
  v3.len = 1;
  runtime_printstring(v3);
  runtime_printunlock();
  v1 = *(_DWORD *)(*(_DWORD *)(__readgsdword(0) - 4) + 24);
  if ( !*(_DWORD *)(v1 + 108) )
    *(_DWORD *)(v1 + 108) = 1;
  runtime_startpanic();
  runtime_dopanic(0);
  MEMORY[0] = 0;
}

//----- (0806BE50) --------------------------------------------------------
void __golang runtime_recovery(runtime_g *gp)
{
  uintptr sigcode0; // ecx
  uintptr sigcode1; // edx
  string s; // [esp+0h] [ebp-14h]
  string sa; // [esp+0h] [ebp-14h]
  string sb; // [esp+0h] [ebp-14h]
  string sc; // [esp+0h] [ebp-14h]
  string sd; // [esp+0h] [ebp-14h]
  uintptr sp_0; // [esp+8h] [ebp-Ch]
  uintptr v; // [esp+Ch] [ebp-8h]
  uintptr v_4; // [esp+10h] [ebp-4h]

  sigcode0 = gp->sigcode0;
  sigcode1 = gp->sigcode1;
  if ( sigcode0 )
  {
    sp_0 = gp->sigcode0;
    v_4 = gp->stack.lo;
    if ( sigcode0 < gp->stack.lo || gp->stack.hi < sigcode0 )
    {
      v = gp->stack.hi;
      runtime_printlock();
      s.str = (uint8 *)"recover: ";
      s.len = 9;
      runtime_printstring(s);
      runtime_printhex(sp_0);
      sa.str = (uint8 *)" not in [";
      sa.len = 9;
      runtime_printstring(sa);
      runtime_printhex(v_4);
      sb.str = (uint8 *)", ";
      sb.len = 2;
      runtime_printstring(sb);
      runtime_printhex(v);
      sc.str = (uint8 *)"]\n";
      sc.len = 2;
      runtime_printstring(sc);
      runtime_printunlock();
      sd.str = (uint8 *)"bad recovery";
      sd.len = 12;
      runtime_throw(sd);
      BUG();
    }
  }
  gp->sched.sp = sigcode0;
  gp->sched.pc = sigcode1;
  gp->sched.lr = 0;
  gp->sched.ret = 1;
  runtime_gogo();
}

//----- (0806BF80) --------------------------------------------------------
void __golang runtime_startpanic_m()
{
  runtime_g *v0; // eax
  runtime_m *m; // ecx
  int32 dying; // edx
  string la; // [esp+0h] [ebp-10h]
  string lb; // [esp+0h] [ebp-10h]
  runtime_mcache *l; // [esp+0h] [ebp-10h]
  string lc; // [esp+0h] [ebp-10h]
  runtime_g *_g_; // [esp+Ch] [ebp-4h]

  v0 = *(runtime_g **)(__readgsdword(0) - 4);
  _g_ = v0;
  if ( f.size )
  {
    if ( !v0->m->mcache )
    {
      l = runtime_allocmcache();
      v0 = _g_;
      _g_->m->mcache = l;
    }
  }
  else
  {
    runtime_printlock();
    lc.str = (uint8 *)"runtime: panic before malloc heap initialized\n";
    lc.len = 46;
    runtime_printstring(lc);
    runtime_printunlock();
    v0 = _g_;
    _g_->m->mallocing = 1;
  }
  m = v0->m;
  dying = m->dying;
  if ( dying )
  {
    if ( dying != 1 )
    {
      if ( dying == 2 )
      {
        v0->m->dying = 3;
        runtime_printlock();
        la.str = (uint8 *)"stack trace unavailable\n";
        la.len = 24;
        runtime_printstring(la);
        runtime_printunlock();
        runtime_exit();
      }
      runtime_exit();
    }
    m->dying = 2;
    runtime_printlock();
    lb.str = (uint8 *)"panic during panic\n";
    lb.len = 19;
    runtime_printstring(lb);
    runtime_printunlock();
    runtime_dopanic(0);
    runtime_exit();
  }
  m->dying = 1;
  v0->writebuf.len = 0;
  v0->writebuf.cap = 0;
  if ( *(_DWORD *)&runtime_writeBarrier.enabled )
    runtime_writebarrierptr((uintptr *)&v0->writebuf, 0);
  else
    v0->writebuf.array = 0;
  runtime_internal_atomic_Xadd();
  runtime_lock(&runtime_paniclk);
  if ( runtime_debug.schedtrace > 0 || runtime_debug.scheddetail > 0 )
    runtime_schedtrace(1);
  runtime_freezetheworld();
}

//----- (0806C170) --------------------------------------------------------
void __golang __noreturn runtime_dopanic_m(runtime_g *gp, uintptr pc, uintptr sp_0)
{
  uint32 sig; // ecx
  uint8 *str; // edx
  __int32 len; // ebx
  int v6; // ebx
  runtime_m *m; // esi
  int32 s; // [esp+0h] [ebp-30h]
  string sb; // [esp+0h] [ebp-30h]
  string sc; // [esp+0h] [ebp-30h]
  string sd; // [esp+0h] [ebp-30h]
  string se; // [esp+0h] [ebp-30h]
  string sf; // [esp+0h] [ebp-30h]
  int sa; // [esp+0h] [ebp-30h]
  string sg; // [esp+0h] [ebp-30h]
  string sh; // [esp+0h] [ebp-30h]
  string si; // [esp+0h] [ebp-30h]
  bool s_4; // [esp+4h] [ebp-2Ch]
  bool s_4a; // [esp+4h] [ebp-2Ch]
  bool s_5; // [esp+5h] [ebp-2Bh]
  bool lr; // [esp+8h] [ebp-28h]
  uintptr lra; // [esp+8h] [ebp-28h]
  bool docrash; // [esp+12h] [ebp-1Eh]
  bool all; // [esp+13h] [ebp-1Dh]
  uint32 v; // [esp+18h] [ebp-18h]
  uintptr v_4; // [esp+1Ch] [ebp-14h]
  uintptr sigcode1; // [esp+20h] [ebp-10h]
  uintptr sigcode0; // [esp+24h] [ebp-Ch]
  uint8 *v29; // [esp+28h] [ebp-8h]
  runtime_g *curg; // [esp+2Ch] [ebp-4h]

  sig = gp->sig;
  if ( sig )
  {
    if ( sig < 0x41 )
    {
      len = runtime_sigtable[sig].name.len;
      str = runtime_sigtable[sig].name.str;
    }
    else
    {
      str = 0;
      len = 0;
    }
    if ( len )
    {
      v29 = str;
      runtime_printlock();
      sb.str = (uint8 *)"[signal ";
      sb.len = 8;
      runtime_printstring(sb);
      runtime_printstring((string)__PAIR64__(len, (unsigned int)v29));
    }
    else
    {
      v = gp->sig;
      runtime_printlock();
      si.str = (uint8 *)"[signal ";
      si.len = 8;
      runtime_printstring(si);
      runtime_printhex(v);
    }
    runtime_printunlock();
    sigcode0 = gp->sigcode0;
    sigcode1 = gp->sigcode1;
    v_4 = gp->sigpc;
    runtime_printlock();
    sc.str = (uint8 *)" code=";
    sc.len = 6;
    runtime_printstring(sc);
    runtime_printhex(sigcode0);
    sd.str = (uint8 *)" addr=";
    sd.len = 6;
    runtime_printstring(sd);
    runtime_printhex(sigcode1);
    se.str = (uint8 *)" pc=";
    se.len = 4;
    runtime_printstring(se);
    runtime_printhex(v_4);
    sf.str = (uint8 *)"]\n";
    sf.len = 2;
    runtime_printstring(sf);
    runtime_printunlock();
  }
  runtime_gotraceback(s, s_4, lr);
  docrash = s_5;
  v6 = *(_DWORD *)(__readgsdword(0) - 4);
  if ( sa > 0 )
  {
    all = s_4a;
    m = gp->m;
    curg = m->curg;
    if ( m->g0 == gp )
    {
      if ( sa >= 2 || *(int *)(*(_DWORD *)(v6 + 24) + 108) > 0 )
      {
        runtime_printlock();
        sg.str = (uint8 *)"\nruntime stack:\n";
        sg.len = 16;
        runtime_printstring(sg);
        runtime_printunlock();
        runtime_traceback(pc, sp_0, 0, gp);
      }
    }
    else
    {
      runtime_printlock();
      sh.str = (uint8 *)"\n";
      sh.len = 1;
      runtime_printstring(sh);
      runtime_printunlock();
      runtime_goroutineheader(gp);
      runtime_traceback(pc, sp_0, 0, gp);
    }
    if ( !runtime_didothers && (all || curg != gp) )
    {
      runtime_didothers = 1;
      runtime_tracebackothers(gp);
    }
  }
  runtime_unlock(&runtime_paniclk);
  runtime_internal_atomic_Xadd();
  if ( lra )
  {
    runtime_lock(&runtime_deadlock);
    runtime_lock(&runtime_deadlock);
  }
  if ( !docrash )
    runtime_exit();
  runtime_crash();
}
// 806C2AC: variable 's' is possibly undefined
// 806C2AC: variable 's_4' is possibly undefined
// 806C2AC: variable 'lr' is possibly undefined
// 806C2BE: variable 's_5' is possibly undefined
// 806C2D1: variable 'sa' is possibly undefined
// 806C2D3: variable 's_4a' is possibly undefined
// 806C371: variable 'lra' is possibly undefined

//----- (0806C4B0) --------------------------------------------------------
bool __golang runtime_canpanic(runtime_g *gp)
{
  int v1; // eax

  v1 = *(_DWORD *)(*(_DWORD *)(__readgsdword(0) - 4) + 24);
  if ( !gp || gp != *(runtime_g **)(v1 + 84) )
    return 0;
  if ( *(_DWORD *)(v1 + 120) != *(_DWORD *)(v1 + 124)
    || *(_DWORD *)(v1 + 104)
    || *(_DWORD *)(v1 + 108)
    || *(_DWORD *)(v1 + 116)
    || *(_DWORD *)(v1 + 128) )
  {
    return 0;
  }
  return (runtime_readgstatus(gp) & 0xFFFFEFFF) == 2 && !gp->syscallsp;
}

//----- (0806C550) --------------------------------------------------------
void __golang runtime_recordForPanic(__uint8 b)
{
  __int32 j; // eax
  __int32 v2; // ecx
  __int32 n; // [esp+Ch] [ebp-8h]
  __int32 i; // [esp+10h] [ebp-4h]

  runtime_printlock();
  if ( !runtime_internal_atomic_Load(&runtime_panicking) )
  {
    for ( j = 0; j < b.len; j = n + i )
    {
      if ( (unsigned int)runtime_printBacklogIndex > 0x200 || (unsigned int)j > b.len )
        runtime_panicslice();
      i = j;
      v2 = b.len - j;
      if ( 512 - runtime_printBacklogIndex <= b.len - j )
        v2 = 512 - runtime_printBacklogIndex;
      n = v2;
      runtime_memmove();
      runtime_printBacklogIndex = (n + runtime_printBacklogIndex) % 512;
    }
  }
  runtime_printunlock();
}

//----- (0806C650) --------------------------------------------------------
void __golang runtime_printlock()
{
  runtime_m *v0; // eax
  int8 printlock; // cl
  runtime_m *mp; // [esp+4h] [ebp-4h]

  v0 = *(runtime_m **)(*(_DWORD *)(__readgsdword(0) - 4) + 24);
  ++v0->locks;
  printlock = v0->printlock;
  v0->printlock = printlock + 1;
  if ( !printlock )
  {
    mp = v0;
    runtime_lock(&runtime_debuglock);
    v0 = mp;
  }
  --v0->locks;
}

//----- (0806C6C0) --------------------------------------------------------
void __golang runtime_printunlock()
{
  int v0; // eax
  char v1; // cl

  v0 = *(_DWORD *)(*(_DWORD *)(__readgsdword(0) - 4) + 24);
  v1 = *(_BYTE *)(v0 + 144);
  *(_BYTE *)(v0 + 144) = v1 - 1;
  if ( v1 == 1 )
    runtime_unlock(&runtime_debuglock);
}

//----- (0806C720) --------------------------------------------------------
void __golang runtime_gwrite(__uint8 b)
{
  runtime_g *v1; // eax
  unsigned __int32 cap; // ecx
  unsigned __int32 v3; // edx
  __int32 v4; // ebp
  __int32 len; // edx
  unsigned __int32 v6; // ecx
  __int32 n; // [esp+Ch] [ebp-8h]
  runtime_g *gp; // [esp+10h] [ebp-4h]

  if ( b.len )
  {
    runtime_recordForPanic(b);
    v1 = *(runtime_g **)(__readgsdword(0) - 4);
    if ( v1 && (cap = v1->writebuf.cap, v3 = v1->writebuf.len, v1->writebuf.array) )
    {
      if ( v3 > cap )
        runtime_panicslice();
      gp = v1;
      v4 = cap - v3;
      len = b.len;
      if ( v4 <= b.len )
        len = v4;
      n = len;
      runtime_memmove();
      v6 = n + gp->writebuf.len;
      if ( v6 > gp->writebuf.cap )
        runtime_panicslice();
      gp->writebuf.len = v6;
    }
    else
    {
      runtime_writeErr(b);
    }
  }
}

//----- (0806C830) --------------------------------------------------------
void __golang runtime_printsp()
{
  string s; // [esp+0h] [ebp-8h]

  runtime_printlock();
  s.str = (uint8 *)" ";
  s.len = 1;
  runtime_printstring(s);
  runtime_printunlock();
}
// 80E0D84: using guessed type char go_string__;

//----- (0806C870) --------------------------------------------------------
void __golang runtime_printnl()
{
  string s; // [esp+0h] [ebp-8h]

  runtime_printlock();
  s.str = (uint8 *)"\n";
  s.len = 1;
  runtime_printstring(s);
  runtime_printunlock();
}

//----- (0806C8B0) --------------------------------------------------------
void __golang runtime_printbool(bool v)
{
  string s; // [esp+0h] [ebp-8h]

  runtime_printlock();
  if ( v )
  {
    s.str = (uint8 *)"true";
    s.len = 4;
  }
  else
  {
    s.str = (uint8 *)"false";
    s.len = 5;
  }
  runtime_printstring(s);
  runtime_printunlock();
}

//----- (0806C920) --------------------------------------------------------
void __golang runtime_printfloat(float64 v)
{
  __m128i v1; // xmm1
  bool v2; // zf
  int v3; // eax
  int i; // ecx
  int v5; // ebp
  int v6; // eax
  int v7; // ecx
  double v8; // xmm2_8
  double v9; // xmm2_8
  int v10; // ecx
  __uint8 b; // [esp+0h] [ebp-20h]
  string ba; // [esp+0h] [ebp-20h]
  string bb; // [esp+0h] [ebp-20h]
  uint8 buf[14]; // [esp+12h] [ebp-Eh] BYREF

  *(double *)v1.m128i_i64 = v;
  v2 = *(double *)v1.m128i_i64 == *(double *)v1.m128i_i64 + *(double *)v1.m128i_i64;
  if ( *(double *)v1.m128i_i64 == *(double *)v1.m128i_i64 + *(double *)v1.m128i_i64 )
  {
    if ( v > 0.0 )
    {
      runtime_printlock();
      bb.str = (uint8 *)"+Inf";
      bb.len = 4;
      runtime_printstring(bb);
      runtime_printunlock();
      return;
    }
    v2 = v == v + v;
  }
  if ( v2 && v < 0.0 )
  {
    runtime_printlock();
    ba.str = (uint8 *)"-Inf";
    ba.len = 4;
    runtime_printstring(ba);
    runtime_printunlock();
  }
  else
  {
    strcpy((char *)buf, "+");
    memset(&buf[2], 0, 12);
    if ( v == 0.0 )
    {
      if ( 1.0 / 0.0 < 0.0 )
        buf[0] = 45;
      v3 = 0;
    }
    else
    {
      if ( v < 0.0 )
      {
        buf[0] = 45;
        v1.m128i_i64[0] = _mm_xor_si128(v1, (__m128i)(unsigned __int64)_f64_8000000000000000).m128i_u64[0];
      }
      v6 = 0;
      while ( *(double *)v1.m128i_i64 >= 10.0 )
      {
        ++v6;
        *(double *)v1.m128i_i64 = *(double *)v1.m128i_i64 / 10.0;
      }
      while ( *(double *)v1.m128i_i64 < 1.0 )
      {
        --v6;
        *(double *)v1.m128i_i64 = *(double *)v1.m128i_i64 * 10.0;
      }
      v7 = 0;
      v8 = *(double *)&_f64_4014000000000000;
      while ( v7 < 7 )
      {
        ++v7;
        v8 = v8 / 10.0;
      }
      v9 = v8 + *(double *)v1.m128i_i64;
      if ( v9 < 10.0 )
      {
        v10 = v6;
      }
      else
      {
        v10 = v6 + 1;
        v9 = v9 / 10.0;
      }
      *(double *)v1.m128i_i64 = v9;
      v3 = v10;
    }
    for ( i = 0; i < 7; ++i )
    {
      if ( (unsigned int)(i + 2) >= 0xE )
        runtime_panicindex();
      buf[i + 2] = (int)*(double *)v1.m128i_i64 + 48;
      *(double *)v1.m128i_i64 = (*(double *)v1.m128i_i64 - (double)(int)*(double *)v1.m128i_i64) * 10.0;
    }
    buf[1] = buf[2];
    buf[2] = 46;
    *(_WORD *)&buf[9] = 11109;
    if ( v3 < 0 )
    {
      buf[10] = 45;
      v3 = -v3;
    }
    buf[11] = (char)v3 / 100 + 48;
    v5 = ((int)((unsigned __int64)(3435973837LL * v3) >> 32) >> 3) - (v3 >> 31);
    buf[12] = v5 - 10 * ((410 * (unsigned int)(unsigned __int8)v5) >> 12) + 48;
    buf[13] = v3 - 10 * v5 + 48;
    b.array = buf;
    *(_QWORD *)&b.len = 0xE0000000ELL;
    runtime_gwrite(b);
  }
}
// 806CAB6: variable 'v1' is possibly undefined
// 80F1868: using guessed type __int64 _f64_4014000000000000;
// 80F1890: using guessed type __int64 _f64_8000000000000000;

//----- (0806CBB0) --------------------------------------------------------
void __golang runtime_printcomplex(complex128 c)
{
  string s; // [esp+0h] [ebp-8h]
  string sa; // [esp+0h] [ebp-8h]

  runtime_printlock();
  s.str = (uint8 *)"(";
  s.len = 1;
  runtime_printstring(s);
  runtime_printfloat(c.real);
  runtime_printfloat(c.imag);
  sa.str = (uint8 *)"i)";
  sa.len = 2;
  runtime_printstring(sa);
  runtime_printunlock();
}
// 80E0D85: using guessed type char asc_80E0D85;

//----- (0806CC30) --------------------------------------------------------
void __golang runtime_printuint(uint64 v)
{
  int v1; // ebp
  int v2; // eax
  unsigned int v3; // edx
  unsigned int v4; // ecx
  uint8 v5; // al
  int v6; // edx
  unsigned int v7; // ecx
  int v8; // ebx
  int v9; // edx
  __uint8 n; // [esp+0h] [ebp-80h]
  uint64 v11; // [esp+10h] [ebp-70h]
  unsigned __int32 i; // [esp+18h] [ebp-68h]
  uint8 buf[100]; // [esp+1Ch] [ebp-64h] BYREF
  unsigned __int64 va; // [esp+84h] [ebp+4h]

  ((void (*)(void))loc_808FD77)();
  v2 = 99;
  v3 = HIDWORD(v);
  v4 = v;
  while ( v2 > 0 )
  {
    va = __PAIR64__(v3, v4);
    i = v2;
    v5 = runtime_uint64mod(__PAIR64__(v3, v4), 0xAuLL) + 48;
    v7 = i;
    if ( i >= 0x64 )
      runtime_panicindex();
    buf[i] = v5;
    LOBYTE(v6) = HIDWORD(va) == 0;
    v8 = v1;
    LOBYTE(v8) = (unsigned int)va < 0xA;
    v9 = v8 & v6;
    LOBYTE(v8) = 0;
    v1 = v9 | v8;
    if ( (_BYTE)v9 )
      goto LABEL_6;
    v11 = runtime_uint64div(va, 0xAuLL);
    v2 = i - 1;
    v3 = HIDWORD(v11);
    v4 = v11;
  }
  v7 = v2;
LABEL_6:
  if ( v7 > 0x64 )
    runtime_panicslice();
  n.array = &buf[((int)(v7 - 100) >> 31) & v7];
  n.len = 100 - v7;
  n.cap = 100 - v7;
  runtime_gwrite(n);
}
// 806CCF5: variable 'v1' is possibly undefined
// 806CCFC: variable 'v6' is possibly undefined

//----- (0806CD60) --------------------------------------------------------
void __golang runtime_printint(int64 v)
{
  unsigned int v1; // eax
  int v2; // edx
  string v3; // [esp+0h] [ebp-Ch]

  v1 = HIDWORD(v);
  v2 = v;
  if ( v < 0 )
  {
    runtime_printlock();
    v3.str = (uint8 *)"-";
    v3.len = 1;
    runtime_printstring(v3);
    runtime_printunlock();
    v1 = (unsigned __int64)-v >> 32;
    v2 = -(int)v;
  }
  runtime_printuint(__PAIR64__(v1, v2));
}
// 80E0D8A: using guessed type char asc_80E0D8A;

//----- (0806CDF0) --------------------------------------------------------
void __golang runtime_printhex(uint64 v)
{
  int v1; // esi
  unsigned int v2; // ecx
  unsigned int v3; // edx
  int i; // eax
  unsigned int v5; // ebx
  int v6; // edx
  bool v7; // cf
  int v8; // ebx
  unsigned int v9; // et0
  int v10; // edx
  unsigned int v11; // ebx
  int v12; // ett
  __uint8 b; // [esp+0h] [ebp-70h]
  uint8 buf[100]; // [esp+Ch] [ebp-64h] BYREF

  ((void (*)(void))loc_808FD77)();
  v2 = HIDWORD(v);
  v3 = v;
  for ( i = 99; i > 0; --i )
  {
    v5 = v3;
    v6 = (unsigned __int8)a0123456789abcd_1[v3 & 0xF];
    if ( (unsigned int)i >= 0x64 )
      runtime_panicindex();
    buf[i] = v6;
    LOBYTE(v6) = v2 == 0;
    v7 = v5 < 0x10;
    v9 = v5;
    v8 = v1;
    LOBYTE(v8) = v7;
    v10 = v8 & v6;
    LOBYTE(v8) = 0;
    v12 = v8;
    v11 = v9;
    v1 = v10 | v12;
    if ( (unsigned __int8)v10 | (unsigned __int8)v12 )
      break;
    v3 = (v11 >> 4) | (v2 << 28);
    v2 >>= 4;
  }
  if ( (unsigned int)(i - 1) >= 0x64 )
    runtime_panicindex();
  *((_BYTE *)&b.cap + i + 3) = 120;
  if ( (unsigned int)(i - 2) >= 0x64 )
    runtime_panicindex();
  *((_BYTE *)&b.cap + i + 2) = 48;
  b.array = &buf[((i - 102) >> 31) & (i - 2)];
  b.len = 102 - i;
  b.cap = 102 - i;
  runtime_gwrite(b);
}
// 806CE56: variable 'v1' is possibly undefined

//----- (0806CED0) --------------------------------------------------------
void __golang runtime_printpointer(void *p)
{
  runtime_printhex((unsigned int)p);
}

//----- (0806CF10) --------------------------------------------------------
void __golang runtime_printstring(string s)
{
  __uint8 b; // [esp+0h] [ebp-20h]

  *(string *)&b.array = s;
  b.cap = s.len;
  runtime_gwrite(b);
}

//----- (0806CF90) --------------------------------------------------------
void __golang runtime_printslice(__uint8 s)
{
  string v1; // [esp+0h] [ebp-10h]
  string v2; // [esp+0h] [ebp-10h]
  string v3; // [esp+0h] [ebp-10h]

  runtime_printlock();
  v1.str = (uint8 *)"[";
  v1.len = 1;
  runtime_printstring(v1);
  runtime_printint(s.len);
  v2.str = (uint8 *)"/";
  v2.len = 1;
  runtime_printstring(v2);
  runtime_printint(s.cap);
  v3.str = (uint8 *)"]";
  v3.len = 1;
  runtime_printstring(v3);
  runtime_printunlock();
  runtime_printpointer(s.array);
}
// 80E0D8C: using guessed type char asc_80E0D8C;
// 80E0D9B: using guessed type char asc_80E0D9B;
// 80E0D9E: using guessed type char asc_80E0D9E;

//----- (0806D050) --------------------------------------------------------
void __golang runtime_printeface(runtime_eface_0 e)
{
  string s; // [esp+0h] [ebp-8h]
  string sa; // [esp+0h] [ebp-8h]
  string sb; // [esp+0h] [ebp-8h]

  runtime_printlock();
  s.str = (uint8 *)"(";
  s.len = 1;
  runtime_printstring(s);
  runtime_printpointer(e._type);
  sa.str = (uint8 *)",";
  sa.len = 1;
  runtime_printstring(sa);
  runtime_printpointer(e.data);
  sb.str = (uint8 *)")";
  sb.len = 1;
  runtime_printstring(sb);
  runtime_printunlock();
}
// 80E0D85: using guessed type char asc_80E0D85;
// 80E0D86: using guessed type char asc_80E0D86;
// 80E0D89: using guessed type char asc_80E0D89;

//----- (0806D0E0) --------------------------------------------------------
void __golang runtime_main()
{
  unsigned int v0; // eax
  uintptr v1; // eax
  int v2; // ecx
  uintptr v3; // ebx
  int v4; // eax
  int i; // eax
  int (__golang **siz)(); // [esp+0h] [ebp-28h]
  int64 siza; // [esp+0h] [ebp-28h]
  string sizb; // [esp+0h] [ebp-28h]
  string sizc; // [esp+0h] [ebp-28h]
  string sizd; // [esp+0h] [ebp-28h]
  string size; // [esp+0h] [ebp-28h]
  string sizf; // [esp+0h] [ebp-28h]
  string sizg; // [esp+0h] [ebp-28h]
  int siz_4; // [esp+4h] [ebp-24h]
  string reason; // [esp+8h] [ebp-20h]
  hchan<bool> *reason_4; // [esp+Ch] [ebp-1Ch]
  __int32 c; // [esp+1Ch] [ebp-Ch]
  runtime_g *g; // [esp+20h] [ebp-8h]
  runtime_g *_g_; // [esp+24h] [ebp-4h]

  g = *(runtime_g **)(__readgsdword(0) - 4);
  g->m->g0->racectx = 0;
  runtime_maxstacksize = 250000000;
  runtime_mainStarted = 1;
  siz = &off_80E7C2C;
  runtime_systemstack();
  v0 = __readgsdword(0);
  *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(v0 - 4) + 24) + 452) += 2;
  v1 = *(_DWORD *)(__readgsdword(0) - 4);
  v2 = *(_DWORD *)(v1 + 24);
  if ( *(_DWORD *)&runtime_writeBarrier.enabled )
  {
    _g_ = (runtime_g *)v1;
    runtime_writebarrierptr((uintptr *)(v2 + 188), v1);
    v1 = (uintptr)_g_;
  }
  else
  {
    *(_DWORD *)(v2 + 188) = v1;
  }
  v3 = *(_DWORD *)(v1 + 24);
  if ( *(_DWORD *)&runtime_writeBarrier.enabled )
    runtime_writebarrierptr((uintptr *)(v1 + 136), v3);
  else
    *(_DWORD *)(v1 + 136) = v3;
  if ( g->m != &runtime_m0 )
  {
    sizg.str = (uint8 *)"runtime.main not on m0";
    sizg.len = 22;
    runtime_throw(sizg);
    BUG();
  }
  runtime_init();
  runtime_nanotime();
  if ( siz == 0 && siz_4 == 0 )
  {
    sizf.str = (uint8 *)"nanotime returning zero";
    sizf.len = 23;
    runtime_throw(sizf);
    BUG();
  }
  runtime_deferproc(4, (runtime_funcval *)&stru_80E7C30);
  if ( !v4 )
  {
    runtime_nanotime();
    runtime_runtimeInitTime = siza;
    runtime_gcenable();
    reason_4 = (hchan<bool> *)runtime_makechan((runtime_chantype_0 *)&stru_80CA640, 0LL);
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr((uintptr *)&runtime_main_init_done, (uintptr)reason_4);
    else
      runtime_main_init_done = reason_4;
    if ( runtime_iscgo )
    {
      if ( !cgo_thread_start )
      {
        size.str = (uint8 *)"_cgo_thread_start missing";
        size.len = 25;
        runtime_throw(size);
        BUG();
      }
      if ( !runtime__cgo_setenv )
      {
        sizd.str = (uint8 *)"_cgo_setenv missing";
        sizd.len = 19;
        runtime_throw(sizd);
        BUG();
      }
      if ( !runtime__cgo_unsetenv )
      {
        sizc.str = (uint8 *)"_cgo_unsetenv missing";
        sizc.len = 21;
        runtime_throw(sizc);
        BUG();
      }
      if ( !cgo_notify_runtime_init_done )
      {
        sizb.str = (uint8 *)"_cgo_notify_runtime_init_done missing";
        sizb.len = 37;
        runtime_throw(sizb);
        BUG();
      }
      runtime_cgocall(cgo_notify_runtime_init_done, 0);
    }
    main_init();
    runtime_closechan((runtime_hchan *)runtime_main_init_done);
    runtime_unlockOSThread();
    if ( !runtime_isarchive && !runtime_islibrary )
    {
      main_main();
      if ( runtime_internal_atomic_Load(&runtime_runningPanicDefers) )
      {
        for ( i = 0; i < 1000; i = c + 1 )
        {
          c = i;
          if ( !runtime_internal_atomic_Load(&runtime_runningPanicDefers) )
            break;
          runtime_Gosched();
        }
      }
      if ( runtime_internal_atomic_Load(&runtime_panicking) )
      {
        reason.str = (uint8 *)"panicwait";
        reason.len = 9;
        runtime_gopark(0, 0, reason, 0x10u, 1);
      }
      runtime_exit();
    }
  }
  runtime_deferreturn(siza);
}
// 806D1CD: variable 'siz' is possibly undefined
// 806D1C8: variable 'siz_4' is possibly undefined
// 806D1FF: variable 'v4' is possibly undefined
// 806D211: variable 'siza' is possibly undefined
// 80E7C2C: using guessed type int (__golang *off_80E7C2C)();

//----- (0806D4A0) --------------------------------------------------------
void __golang runtime_init_3()
{
  runtime_newproc(0, (runtime_funcval *)&stru_80E7BF0);
}

//----- (0806D4E0) --------------------------------------------------------
void __golang __noreturn runtime_forcegchelper()
{
  runtime_g *v0; // ecx
  unsigned int v1; // ecx
  runtime_gcMode mode; // [esp+0h] [ebp-14h]
  string modea; // [esp+0h] [ebp-14h]
  string modeb; // [esp+0h] [ebp-14h]
  runtime_gcTrigger_0 triggera; // [esp+4h] [ebp-10h]
  string triggerb; // [esp+4h] [ebp-10h]
  unsigned int trigger; // [esp+4h] [ebp-10h]

  v0 = *(runtime_g **)(__readgsdword(0) - 4);
  if ( *(_DWORD *)&runtime_writeBarrier.enabled )
    runtime_writebarrierptr((uintptr *)&runtime_forcegc.g, (uintptr)v0);
  else
    runtime_forcegc.g = v0;
  while ( 1 )
  {
    runtime_lock(&runtime_forcegc.lock);
    if ( runtime_forcegc.idle )
      break;
    runtime_internal_atomic_Store();
    triggerb.str = (uint8 *)"force gc (idle)";
    triggerb.len = 15;
    runtime_goparkunlock(&runtime_forcegc.lock, triggerb, 0x14u, 1);
    if ( runtime_debug.gctrace > 0 )
    {
      runtime_printlock();
      modea.str = (uint8 *)"GC forced";
      modea.len = 9;
      runtime_printstring(modea);
      runtime_printnl();
      runtime_printunlock();
    }
    runtime_nanotime();
    v1 = trigger;
    triggera.kind = 2;
    LODWORD(triggera.now) = mode;
    *(int64 *)((char *)&triggera.now + 4) = v1;
    runtime_gcStart(0, triggera);
  }
  modeb.str = (uint8 *)"forcegc: phase error";
  modeb.len = 20;
  runtime_throw(modeb);
  BUG();
}
// 806D524: variable 'trigger' is possibly undefined
// 806D537: variable 'mode' is possibly undefined

//----- (0806D620) --------------------------------------------------------
void __golang runtime_Gosched()
{
  runtime_mcall();
}

//----- (0806D640) --------------------------------------------------------
void __golang runtime_gopark(
        func(_runtime_g__unsafe_Pointer)_bool unlockf,
        void *lock,
        string reason,
        uint8 traceEv,
        __int32 traceskip)
{
  int v5; // eax
  runtime_m *v6; // ecx
  int v7; // eax
  int32 locks; // edx
  string s; // [esp+0h] [ebp-10h]
  uint32 s_4; // [esp+4h] [ebp-Ch]
  runtime_m *mp; // [esp+8h] [ebp-8h]
  runtime_g *gp; // [esp+Ch] [ebp-4h]

  v5 = *(_DWORD *)(__readgsdword(0) - 4);
  ++*(_DWORD *)(*(_DWORD *)(v5 + 24) + 120);
  mp = *(runtime_m **)(v5 + 24);
  gp = mp->curg;
  s_4 = runtime_readgstatus(gp);
  if ( s_4 != 2 && s_4 != 4098 )
  {
    s.str = (uint8 *)"gopark: bad g status";
    s.len = 20;
    runtime_throw(s);
    BUG();
  }
  v6 = mp;
  if ( *(_DWORD *)&runtime_writeBarrier.enabled )
  {
    runtime_writebarrierptr((uintptr *)&mp->waitlock, (uintptr)lock);
    v6 = mp;
  }
  else
  {
    mp->waitlock = lock;
  }
  if ( *(_DWORD *)&runtime_writeBarrier.enabled )
  {
    runtime_writebarrierptr((uintptr *)&v6->waitunlockf, (uintptr)unlockf);
    v6 = mp;
  }
  else
  {
    v6->waitunlockf = unlockf;
  }
  gp->waitreason.len = reason.len;
  if ( *(_DWORD *)&runtime_writeBarrier.enabled )
  {
    runtime_writebarrierptr((uintptr *)&gp->waitreason, (uintptr)reason.str);
    v6 = mp;
  }
  else
  {
    gp->waitreason.str = reason.str;
  }
  v6->waittraceev = traceEv;
  v6->waittraceskip = traceskip;
  v7 = *(_DWORD *)(__readgsdword(0) - 4);
  locks = v6->locks;
  v6->locks = locks - 1;
  if ( locks == 1 && *(_BYTE *)(v7 + 108) )
    *(_DWORD *)(v7 + 8) = -1314;
  runtime_mcall();
}

//----- (0806D7C0) --------------------------------------------------------
void __golang runtime_goparkunlock(runtime_mutex_0 *lock, string reason, uint8 traceEv, __int32 traceskip)
{
  runtime_gopark(off_80E7CA0, lock, reason, traceEv, traceskip);
}

//----- (0806D820) --------------------------------------------------------
void __golang runtime_goready(runtime_g *gp, __int32 traceskip)
{
  runtime_systemstack();
}

//----- (0806D870) --------------------------------------------------------
runtime_sudog *__golang runtime_acquireSudog()
{
  int v0; // eax
  runtime_puintptr p; // edx
  runtime_puintptr v2; // eax
  runtime_sudog *sudogcache; // ecx
  __int32 v4; // edx
  __int32 v5; // ebx
  uintptr *v6; // ebp
  uintptr *array; // eax
  __int32 len; // ecx
  _DWORD *v9; // eax
  unsigned int v10; // ecx
  int v11; // edx
  unsigned int v12; // ebx
  runtime_sudog *v13; // ebp
  int v14; // eax
  int32 locks; // edx
  uintptr *v16; // ecx
  __int32 v17; // edx
  __int32 v18; // ebx
  uintptr v19; // esi
  uintptr *v20; // eax
  __int32 v21; // ecx
  string l; // [esp+0h] [ebp-48h]
  runtime_slice_0 srca; // [esp+4h] [ebp-44h]
  void *src; // [esp+4h] [ebp-44h]
  runtime_slice_0 srcb; // [esp+4h] [ebp-44h]
  runtime_slice_0 v26; // [esp+14h] [ebp-34h]
  runtime_slice_0 v27; // [esp+14h] [ebp-34h]
  unsigned int v28; // [esp+24h] [ebp-24h]
  runtime_m *mp; // [esp+2Ch] [ebp-1Ch]
  uintptr *p_next; // [esp+34h] [ebp-14h]
  runtime_sudog *v31; // [esp+3Ch] [ebp-Ch]
  uintptr v32; // [esp+3Ch] [ebp-Ch]
  uintptr *dst; // [esp+40h] [ebp-8h]
  runtime_puintptr v34; // [esp+44h] [ebp-4h]

  v0 = *(_DWORD *)(__readgsdword(0) - 4);
  ++*(_DWORD *)(*(_DWORD *)(v0 + 24) + 120);
  mp = *(runtime_m **)(v0 + 24);
  p = mp->p;
  v34 = p;
  if ( *(_DWORD *)(p + 1824) )
  {
    v9 = (_DWORD *)mp->p;
  }
  else
  {
    dst = (uintptr *)(p + 1820);
    runtime_lock(&runtime_sched.sudoglock);
    while ( 1 )
    {
      v2 = v34;
      if ( *(_DWORD *)(v34 + 1824) >= *(_DWORD *)(v34 + 1828) / 2 )
        break;
      sudogcache = runtime_sched.sudogcache;
      if ( !runtime_sched.sudogcache )
        break;
      v31 = runtime_sched.sudogcache;
      if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      {
        p_next = (uintptr *)&runtime_sched.sudogcache->next;
        runtime_writebarrierptr((uintptr *)&runtime_sched.sudogcache, (uintptr)runtime_sched.sudogcache->next);
        runtime_writebarrierptr(p_next, 0);
        v2 = v34;
        sudogcache = v31;
      }
      else
      {
        runtime_sched.sudogcache = runtime_sched.sudogcache->next;
        sudogcache->next = 0;
      }
      v4 = *(_DWORD *)(v2 + 1828);
      v5 = *(_DWORD *)(v2 + 1824);
      v6 = *(uintptr **)(v2 + 1820);
      if ( v5 + 1 > v4 )
      {
        srca.array = *(void **)(v2 + 1820);
        *(_QWORD *)&srca.len = __PAIR64__(v4, v5);
        v26 = runtime_growslice((runtime__type_0 *)&stru_80C8440, srca, v5 + 1);
        array = (uintptr *)v26.array;
        len = v26.len;
        *(_DWORD *)(v34 + 1828) = v26.cap;
        if ( *(_DWORD *)&runtime_writeBarrier.enabled )
        {
          runtime_writebarrierptr(dst, (uintptr)v26.array);
          array = (uintptr *)v26.array;
          len = v26.len;
        }
        else
        {
          *(_DWORD *)(v34 + 1820) = v26.array;
        }
        v5 = len;
        v6 = array;
        v2 = v34;
        sudogcache = v31;
      }
      *(_DWORD *)(v2 + 1824) = v5 + 1;
      if ( *(_DWORD *)&runtime_writeBarrier.enabled )
        runtime_writebarrierptr(&v6[v5], (uintptr)sudogcache);
      else
        v6[v5] = (uintptr)sudogcache;
    }
    runtime_unlock(&runtime_sched.sudoglock);
    v9 = (_DWORD *)v34;
    if ( !*(_DWORD *)(v34 + 1824) )
    {
      src = runtime_newobject((runtime__type_0 *)&stru_80DB1E0);
      v9 = (_DWORD *)v34;
      v16 = *(uintptr **)(v34 + 1820);
      v17 = *(_DWORD *)(v34 + 1828);
      v18 = *(_DWORD *)(v34 + 1824);
      v19 = (uintptr)src;
      if ( v18 + 1 > v17 )
      {
        v32 = (uintptr)src;
        srcb.array = *(void **)(v34 + 1820);
        *(_QWORD *)&srcb.len = __PAIR64__(v17, v18);
        v27 = runtime_growslice((runtime__type_0 *)&stru_80C8440, srcb, v18 + 1);
        v20 = (uintptr *)v27.array;
        v21 = v27.len;
        *(_DWORD *)(v34 + 1828) = v27.cap;
        if ( *(_DWORD *)&runtime_writeBarrier.enabled )
        {
          runtime_writebarrierptr(dst, (uintptr)v27.array);
          v20 = (uintptr *)v27.array;
          v21 = v27.len;
        }
        else
        {
          *(_DWORD *)(v34 + 1820) = v27.array;
        }
        v19 = v32;
        v18 = v21;
        v16 = v20;
        v9 = (_DWORD *)v34;
      }
      v9[456] = v18 + 1;
      if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      {
        runtime_writebarrierptr(&v16[v18], v19);
        v9 = (_DWORD *)v34;
      }
      else
      {
        v16[v18] = v19;
      }
    }
  }
  v10 = v9[456];
  v11 = v9[455];
  v12 = v10 - 1;
  if ( v10 - 1 >= v10 )
    runtime_panicindex();
  v13 = *(runtime_sudog **)(v11 + 4 * v10 - 4);
  if ( *(_DWORD *)&runtime_writeBarrier.enabled )
  {
    v28 = v10 - 1;
    runtime_writebarrierptr((uintptr *)(v11 + 4 * v10 - 4), 0);
    v9 = (_DWORD *)v34;
    v12 = v28;
  }
  else
  {
    *(_DWORD *)(v11 + 4 * v10 - 4) = 0;
  }
  if ( v12 > v9[457] )
    runtime_panicslice();
  v9[456] = v12;
  if ( v13->elem )
  {
    l.str = (uint8 *)"acquireSudog: found s.elem != nil in cache";
    l.len = 42;
    runtime_throw(l);
    BUG();
  }
  v14 = *(_DWORD *)(__readgsdword(0) - 4);
  locks = mp->locks;
  mp->locks = locks - 1;
  if ( locks == 1 && *(_BYTE *)(v14 + 108) )
    *(_DWORD *)(v14 + 8) = -1314;
  return v13;
}

//----- (0806DC00) --------------------------------------------------------
void __golang runtime_releaseSudog(runtime_sudog *s)
{
  int v1; // ecx
  _DWORD *v2; // ebx
  runtime_sudog *v3; // ebp
  runtime_sudog *i; // esi
  int v5; // ecx
  int v6; // edx
  unsigned int v7; // eax
  _DWORD *v8; // eax
  uintptr *v9; // ecx
  __int32 v10; // edx
  __int32 v11; // ebx
  int v12; // eax
  int32 locks; // edx
  uintptr *array; // eax
  __int32 len; // ecx
  _DWORD *v16; // ebx
  string dst; // [esp+0h] [ebp-48h]
  string dsta; // [esp+0h] [ebp-48h]
  string dstb; // [esp+0h] [ebp-48h]
  string dstc; // [esp+0h] [ebp-48h]
  string dstd; // [esp+0h] [ebp-48h]
  string dste; // [esp+0h] [ebp-48h]
  string dstf; // [esp+0h] [ebp-48h]
  runtime_slice_0 src; // [esp+4h] [ebp-44h]
  runtime_slice_0 v25; // [esp+14h] [ebp-34h]
  int v26; // [esp+24h] [ebp-24h]
  runtime_sudog *p; // [esp+28h] [ebp-20h]
  runtime_m *mp; // [esp+2Ch] [ebp-1Ch]
  uintptr *v29; // [esp+40h] [ebp-8h]
  _DWORD *v30; // [esp+44h] [ebp-4h]

  if ( s->elem )
  {
    dstf.str = (uint8 *)"runtime: sudog with non-nil elem";
    dstf.len = 32;
    runtime_throw(dstf);
    BUG();
  }
  if ( s->selectdone )
  {
    dste.str = (uint8 *)"runtime: sudog with non-nil selectdone";
    dste.len = 38;
    runtime_throw(dste);
    BUG();
  }
  if ( s->next )
  {
    dstd.str = (uint8 *)"runtime: sudog with non-nil next";
    dstd.len = 32;
    runtime_throw(dstd);
    BUG();
  }
  if ( s->prev )
  {
    dstc.str = (uint8 *)"runtime: sudog with non-nil prev";
    dstc.len = 32;
    runtime_throw(dstc);
    BUG();
  }
  if ( s->waitlink )
  {
    dstb.str = (uint8 *)"runtime: sudog with non-nil waitlink";
    dstb.len = 36;
    runtime_throw(dstb);
    BUG();
  }
  if ( s->c )
  {
    dsta.str = (uint8 *)"runtime: sudog with non-nil c";
    dsta.len = 29;
    runtime_throw(dsta);
    BUG();
  }
  v1 = *(_DWORD *)(__readgsdword(0) - 4);
  if ( *(_DWORD *)(v1 + 68) )
  {
    dst.str = (uint8 *)"runtime: releaseSudog with non-nil gp.param";
    dst.len = 43;
    runtime_throw(dst);
    BUG();
  }
  ++*(_DWORD *)(*(_DWORD *)(v1 + 24) + 120);
  mp = *(runtime_m **)(v1 + 24);
  v2 = (_DWORD *)mp->p;
  v30 = v2;
  v29 = v2 + 455;
  if ( v2[457] == v2[456] )
  {
    v3 = 0;
    for ( i = 0; ; i = p )
    {
      v5 = v2[456];
      v6 = v2[455];
      if ( v5 <= v2[457] / 2 )
        break;
      v7 = v5 - 1;
      if ( v5 - 1 >= (unsigned int)v5 )
        runtime_panicindex();
      p = *(runtime_sudog **)(v6 + 4 * v5 - 4);
      if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      {
        v26 = v5 - 1;
        runtime_writebarrierptr((uintptr *)(v6 + 4 * v5 - 4), 0);
        v7 = v26;
        v2 = v30;
      }
      else
      {
        *(_DWORD *)(v6 + 4 * v5 - 4) = 0;
      }
      if ( v7 > v2[457] )
        runtime_panicslice();
      v2[456] = v7;
      if ( v3 )
      {
        if ( *(_DWORD *)&runtime_writeBarrier.enabled )
        {
          runtime_writebarrierptr((uintptr *)&i->next, (uintptr)p);
          v2 = v30;
        }
        else
        {
          i->next = p;
        }
      }
      else
      {
        v3 = p;
      }
    }
    runtime_lock(&runtime_sched.sudoglock);
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
    {
      runtime_writebarrierptr((uintptr *)&i->next, (uintptr)runtime_sched.sudogcache);
      runtime_writebarrierptr((uintptr *)&runtime_sched.sudogcache, (uintptr)v3);
    }
    else
    {
      i->next = runtime_sched.sudogcache;
      runtime_sched.sudogcache = v3;
    }
    runtime_unlock(&runtime_sched.sudoglock);
  }
  v8 = v30;
  v9 = (uintptr *)v30[455];
  v10 = v30[456];
  v11 = v30[457];
  if ( v10 + 1 > v11 )
  {
    src.array = (void *)v30[455];
    *(_QWORD *)&src.len = __PAIR64__(v11, v10);
    v25 = runtime_growslice((runtime__type_0 *)&stru_80C8440, src, v10 + 1);
    array = (uintptr *)v25.array;
    len = v25.len;
    v16 = v30;
    v30[457] = v25.cap;
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
    {
      runtime_writebarrierptr(v29, (uintptr)v25.array);
      array = (uintptr *)v25.array;
      len = v25.len;
      v16 = v30;
    }
    else
    {
      v30[455] = v25.array;
    }
    v10 = len;
    v9 = array;
    v8 = v16;
  }
  v8[456] = v10 + 1;
  if ( *(_DWORD *)&runtime_writeBarrier.enabled )
    runtime_writebarrierptr(&v9[v10], (uintptr)s);
  else
    v9[v10] = (uintptr)s;
  v12 = *(_DWORD *)(__readgsdword(0) - 4);
  locks = mp->locks;
  mp->locks = locks - 1;
  if ( locks == 1 && *(_BYTE *)(v12 + 108) )
    *(_DWORD *)(v12 + 8) = -1314;
}

//----- (0806DFC0) --------------------------------------------------------
uintptr __golang runtime_funcPC(interface_{} f)
{
  return *(_DWORD *)f.data;
}

//----- (0806DFE0) --------------------------------------------------------
void __golang __noreturn runtime_badmcall(func(_runtime_g) fn)
{
  string s; // [esp+0h] [ebp-8h]

  s.str = (uint8 *)"runtime: mcall called on m->g0 stack";
  s.len = 36;
  runtime_throw(s);
  BUG();
}

//----- (0806E020) --------------------------------------------------------
void __golang __noreturn runtime_badmcall2(func(_runtime_g) fn)
{
  string s; // [esp+0h] [ebp-8h]

  s.str = (uint8 *)"runtime: mcall function returned";
  s.len = 32;
  runtime_throw(s);
  BUG();
}

//----- (0806E060) --------------------------------------------------------
void __golang __noreturn runtime_badreflectcall()
{
  interface_{} e; // [esp+0h] [ebp-8h]

  e._type = (runtime__type_0 *)&::e;
  e.data = &runtime_statictmp_18;
  runtime_gopanic(e);
  BUG();
}

//----- (0806E0A0) --------------------------------------------------------
void __golang runtime_badmorestackg0()
{
  runtime_write();
}

//----- (0806E0D0) --------------------------------------------------------
void __golang runtime_badmorestackgsignal()
{
  runtime_write();
}

//----- (0806E100) --------------------------------------------------------
void __golang __noreturn runtime_badctxt()
{
  string s; // [esp+0h] [ebp-8h]

  s.str = (uint8 *)"ctxt != 0";
  s.len = 9;
  runtime_throw(s);
  BUG();
}

//----- (0806E120) --------------------------------------------------------
void __golang runtime_allgadd(runtime_g *gp)
{
  uintptr *array; // eax
  __int32 len; // ecx
  string s; // [esp+0h] [ebp-28h]
  runtime_slice_0 v4; // [esp+14h] [ebp-14h]

  if ( !runtime_readgstatus(gp) )
  {
    s.str = (uint8 *)"allgadd: bad status Gidle";
    s.len = 25;
    runtime_throw(s);
    BUG();
  }
  runtime_lock(&runtime_allglock);
  array = (uintptr *)runtime_allgs.array;
  len = runtime_allgs.len;
  if ( runtime_allgs.len + 1 > runtime_allgs.cap )
  {
    v4 = runtime_growslice((runtime__type_0 *)&stru_80C76C0, (runtime_slice_0)runtime_allgs, runtime_allgs.len + 1);
    array = (uintptr *)v4.array;
    len = v4.len;
    runtime_allgs.cap = v4.cap;
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
    {
      runtime_writebarrierptr((uintptr *)&runtime_allgs, (uintptr)v4.array);
      array = (uintptr *)v4.array;
      len = v4.len;
    }
    else
    {
      runtime_allgs.array = (runtime_g **)v4.array;
    }
  }
  runtime_allgs.len = len + 1;
  if ( *(_DWORD *)&runtime_writeBarrier.enabled )
    runtime_writebarrierptr(&array[len], (uintptr)gp);
  else
    array[len] = (uintptr)gp;
  runtime_allglen = runtime_allgs.len;
  runtime_unlock(&runtime_allglock);
}

//----- (0806E260) --------------------------------------------------------
void __golang runtime_schedinit()
{
  runtime_m *m; // eax
  uint32 v1; // ecx
  int str; // eax
  uint64 mp; // [esp+0h] [ebp-18h]
  string mpa; // [esp+0h] [ebp-18h]
  string mpb; // [esp+0h] [ebp-18h]
  string sa; // [esp+8h] [ebp-10h]
  string s; // [esp+8h] [ebp-10h]
  int32 procs; // [esp+10h] [ebp-8h]
  runtime_g *_g_; // [esp+14h] [ebp-4h]

  _g_ = *(runtime_g **)(__readgsdword(0) - 4);
  runtime_sched.maxmcount = 10000;
  runtime_tracebackinit();
  runtime_moduledataverify();
  runtime_stackinit();
  runtime_mallocinit();
  runtime_mcommoninit(_g_->m);
  runtime_alginit();
  runtime_modulesinit();
  runtime_typelinksinit();
  runtime_itabsinit();
  runtime_msigsave(_g_->m);
  m = _g_->m;
  v1 = m->sigmask[1];
  runtime_initSigmask[0] = m->sigmask[0];
  runtime_initSigmask[1] = v1;
  runtime_goargs();
  runtime_goenvs();
  runtime_parsedebugvars();
  runtime_gcinit();
  runtime_nanotime();
  runtime_sched.lastpoll = mp;
  procs = runtime_ncpu;
  mpa.str = (uint8 *)"GOMAXPROCS";
  mpa.len = 10;
  sa = runtime_gogetenv(mpa);
  s = (string)runtime_atoi32(sa);
  str = (int)s.str;
  if ( !LOBYTE(s.len) || (int)s.str <= 0 )
    str = procs;
  if ( str > 1024 )
    str = 1024;
  if ( runtime_procresize(str) )
  {
    mpb.str = (uint8 *)"unknown runnable goroutine during bootstrap";
    mpb.len = 43;
    runtime_throw(mpb);
    BUG();
  }
  if ( !runtime_buildVersion.len )
  {
    runtime_buildVersion.len = 7;
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr((uintptr *)&runtime_buildVersion, (uintptr)"unknown");
    else
      runtime_buildVersion.str = (uint8 *)"unknown";
  }
}
// 806E313: variable 'mp' is possibly undefined

//----- (0806E3F0) --------------------------------------------------------
void __golang runtime_dumpgstatus(runtime_g *gp)
{
  string s; // [esp+0h] [ebp-18h]
  string sa; // [esp+0h] [ebp-18h]
  string sb; // [esp+0h] [ebp-18h]
  string sc; // [esp+0h] [ebp-18h]
  string sd; // [esp+0h] [ebp-18h]
  string se; // [esp+0h] [ebp-18h]
  string sf; // [esp+0h] [ebp-18h]
  string sg; // [esp+0h] [ebp-18h]
  uint32 s_4; // [esp+4h] [ebp-14h]
  uint32 s_4a; // [esp+4h] [ebp-14h]
  uint32 v; // [esp+8h] [ebp-10h]
  uint32 va; // [esp+8h] [ebp-10h]
  int64 v_4; // [esp+Ch] [ebp-Ch]
  int64 v_4a; // [esp+Ch] [ebp-Ch]
  runtime_g *_g_; // [esp+14h] [ebp-4h]

  _g_ = *(runtime_g **)(__readgsdword(0) - 4);
  s_4 = runtime_readgstatus(gp);
  v_4 = gp->goid;
  v = s_4;
  runtime_printlock();
  s.str = (uint8 *)"runtime: gp: gp=";
  s.len = 16;
  runtime_printstring(s);
  runtime_printpointer(gp);
  sa.str = (uint8 *)", goid=";
  sa.len = 7;
  runtime_printstring(sa);
  runtime_printint(v_4);
  sb.str = (uint8 *)", gp->atomicstatus=";
  sb.len = 19;
  runtime_printstring(sb);
  runtime_printint(v);
  sc.str = (uint8 *)"\n";
  sc.len = 1;
  runtime_printstring(sc);
  runtime_printunlock();
  s_4a = runtime_readgstatus(_g_);
  v_4a = _g_->goid;
  va = s_4a;
  runtime_printlock();
  sd.str = (uint8 *)"runtime:  g:  g=";
  sd.len = 16;
  runtime_printstring(sd);
  runtime_printpointer(_g_);
  se.str = (uint8 *)", goid=";
  se.len = 7;
  runtime_printstring(se);
  runtime_printint(v_4a);
  sf.str = (uint8 *)",  g->atomicstatus=";
  sf.len = 19;
  runtime_printstring(sf);
  runtime_printint(va);
  sg.str = (uint8 *)"\n";
  sg.len = 1;
  runtime_printstring(sg);
  runtime_printunlock();
}
// 806E3F0: could not find valid save-restore pair for ebx

//----- (0806E5A0) --------------------------------------------------------
void __golang runtime_checkmcount()
{
  string s; // [esp+0h] [ebp-Ch]
  string sa; // [esp+0h] [ebp-Ch]
  string sb; // [esp+0h] [ebp-Ch]
  int32 maxmcount; // [esp+8h] [ebp-4h]

  if ( runtime_sched.mcount > runtime_sched.maxmcount )
  {
    maxmcount = runtime_sched.maxmcount;
    runtime_printlock();
    s.str = (uint8 *)"runtime: program exceeds ";
    s.len = 25;
    runtime_printstring(s);
    runtime_printint(maxmcount);
    sa.str = (uint8 *)"-thread limit\n";
    sa.len = 14;
    runtime_printstring(sa);
    runtime_printunlock();
    sb.str = (uint8 *)"thread exhaustion";
    sb.len = 17;
    runtime_throw(sb);
    BUG();
  }
}

//----- (0806E640) --------------------------------------------------------
void __golang runtime_mcommoninit(runtime_m *mp)
{
  int v1; // eax
  int32 id; // ecx
  runtime_m *v3; // eax
  runtime_g *gsignal; // ecx
  runtime_mutex_0 *l; // [esp+0h] [ebp-14h]
  uintptr (*newa)[32]; // [esp+4h] [ebp-10h]
  __uintptr newb; // [esp+4h] [ebp-10h]

  v1 = *(_DWORD *)(__readgsdword(0) - 4);
  if ( v1 != **(_DWORD **)(v1 + 24) )
  {
    newb.array = mp->createstack;
    *(_QWORD *)&newb.len = 0x2000000020LL;
    runtime_callers(1, newb);
  }
  runtime_cputicks();
  id = mp->id;
  mp->fastrand = (uint32)&l[310218914].key + id + 2;
  if ( (runtime_mutex_0 *)((char *)l + id) == (runtime_mutex_0 *)-1240875658 )
    mp->fastrand = 1240875658;
  runtime_lock(&runtime_sched.lock);
  mp->id = runtime_sched.mcount++;
  runtime_checkmcount();
  runtime_mpreinit(mp);
  v3 = mp;
  gsignal = mp->gsignal;
  if ( gsignal )
    gsignal->stackguard1 = gsignal->stack.lo + 880;
  if ( *(_DWORD *)&runtime_writeBarrier.enabled )
  {
    runtime_writebarrierptr((uintptr *)&mp->alllink, runtime_allm);
    v3 = mp;
  }
  else
  {
    mp->alllink = (runtime_m *)runtime_allm;
  }
  runtime_atomicstorep(&runtime_allm, v3);
  runtime_unlock(&runtime_sched.lock);
  if ( runtime_iscgo )
  {
    newa = (uintptr (*)[32])runtime_newobject((runtime__type_0 *)&stru_80CFEE0);
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr((uintptr *)&mp->cgoCallers, (uintptr)newa);
    else
      mp->cgoCallers = newa;
  }
}
// 806E682: variable 'l' is possibly undefined

//----- (0806E7D0) --------------------------------------------------------
void __golang runtime_ready(runtime_g *gp, __int32 traceskip, bool next)
{
  runtime_g *v3; // eax
  string s; // [esp+0h] [ebp-10h]
  uint32 s_4; // [esp+4h] [ebp-Ch]
  runtime_g *_g_; // [esp+Ch] [ebp-4h]

  if ( runtime_trace.enabled )
    runtime_traceGoUnpark(gp, traceskip);
  s_4 = runtime_readgstatus(gp);
  v3 = *(runtime_g **)(__readgsdword(0) - 4);
  ++v3->m->locks;
  if ( (s_4 & 0xFFFFEFFF) != 4 )
  {
    runtime_dumpgstatus(gp);
    s.str = (uint8 *)"bad g->status in ready";
    s.len = 22;
    runtime_throw(s);
    BUG();
  }
  _g_ = v3;
  runtime_casgstatus(gp, 4u, 1u);
  runtime_runqput((runtime_p *)_g_->m->p, gp, next);
  if ( runtime_internal_atomic_Load(&runtime_sched.npidle) && !runtime_internal_atomic_Load(&runtime_sched.nmspinning) )
    runtime_wakep();
  if ( !--_g_->m->locks && _g_->preempt )
    _g_->stackguard0 = -1314;
}

//----- (0806E920) --------------------------------------------------------
int32 __golang runtime_gcprocs()
{
  int v0; // ecx
  int32 v1; // eax
  int32 v2; // ecx
  int32 n; // [esp+4h] [ebp-4h]

  runtime_lock(&runtime_sched.lock);
  v0 = runtime_ncpu;
  if ( runtime_gomaxprocs <= runtime_ncpu )
    v0 = runtime_gomaxprocs;
  if ( v0 <= 32 )
    v1 = v0;
  else
    v1 = 32;
  v2 = runtime_sched.nmidle + 1;
  if ( v1 <= runtime_sched.nmidle + 1 )
    v2 = v1;
  n = v2;
  runtime_unlock(&runtime_sched.lock);
  return n;
}

//----- (0806E9A0) --------------------------------------------------------
bool __golang runtime_needaddgcproc()
{
  int v0; // ecx
  int v1; // eax
  int32 n; // [esp+4h] [ebp-8h]
  int32 nmidle; // [esp+8h] [ebp-4h]

  runtime_lock(&runtime_sched.lock);
  v0 = runtime_ncpu;
  if ( runtime_gomaxprocs <= runtime_ncpu )
    v0 = runtime_gomaxprocs;
  if ( v0 <= 32 )
    v1 = v0;
  else
    v1 = 32;
  n = v1;
  nmidle = runtime_sched.nmidle;
  runtime_unlock(&runtime_sched.lock);
  return n - (nmidle + 1) > 0;
}

//----- (0806EA20) --------------------------------------------------------
void __golang runtime_helpgc(int32 nproc)
{
  int32 v1; // eax
  unsigned int v2; // ecx
  runtime_note_0 *midle; // ebp
  bool v4; // zf
  string l; // [esp+0h] [ebp-14h]
  __int32 pos; // [esp+8h] [ebp-Ch]
  int32 n; // [esp+Ch] [ebp-8h]
  runtime_g *_g_; // [esp+10h] [ebp-4h]

  _g_ = *(runtime_g **)(__readgsdword(0) - 4);
  runtime_lock(&runtime_sched.lock);
  v1 = 1;
  v2 = 0;
  while ( v1 < nproc )
  {
    if ( v2 >= 0x401 )
      runtime_panicindex();
    if ( runtime_allp[v2]->mcache == _g_->m->mcache )
      ++v2;
    midle = (runtime_note_0 *)runtime_sched.midle;
    v4 = runtime_sched.midle == 0;
    if ( runtime_sched.midle )
    {
      runtime_sched.midle = *(_DWORD *)(runtime_sched.midle + 180);
      --runtime_sched.nmidle;
      v4 = midle == 0;
    }
    if ( v4 )
    {
      l.str = (uint8 *)"gcprocs inconsistency";
      l.len = 21;
      runtime_throw(l);
      BUG();
    }
    midle[34].key = v1;
    if ( v2 >= 0x401 )
      runtime_panicindex();
    n = v1;
    pos = v2;
    midle[23].key = (uintptr)runtime_allp[v2];
    midle[46].key = (uintptr)runtime_allp[v2]->mcache;
    runtime_notewakeup(midle + 43);
    v1 = n + 1;
    v2 = pos + 1;
  }
  runtime_unlock(&runtime_sched.lock);
}
// 806EA20: could not find valid save-restore pair for esi

//----- (0806EB50) --------------------------------------------------------
void __golang runtime_freezetheworld()
{
  int j; // eax
  __int32 i; // [esp+8h] [ebp-4h]

  runtime_internal_atomic_Store();
  for ( j = 0; j < 5; j = i + 1 )
  {
    i = j;
    runtime_sched.stopwait = 0x7FFFFFFF;
    runtime_internal_atomic_Store();
    if ( !runtime_preemptall() )
      break;
    runtime_usleep();
  }
  runtime_usleep();
  runtime_preemptall();
  runtime_usleep();
}

//----- (0806EC00) --------------------------------------------------------
uint32 __golang runtime_readgstatus(runtime_g *gp)
{
  return runtime_internal_atomic_Load(&gp->atomicstatus);
}

//----- (0806EC20) --------------------------------------------------------
void __golang runtime_casfrom_Gscanstatus(runtime_g *gp, uint32 oldval, uint32 newval)
{
  char v3; // al
  string s; // [esp+0h] [ebp-10h]
  string sa; // [esp+0h] [ebp-10h]
  string sb; // [esp+0h] [ebp-10h]
  string sc; // [esp+0h] [ebp-10h]
  string sd; // [esp+0h] [ebp-10h]
  string se; // [esp+0h] [ebp-10h]
  string sf; // [esp+0h] [ebp-10h]
  string sg; // [esp+0h] [ebp-10h]
  string sh; // [esp+0h] [ebp-10h]
  string si; // [esp+0h] [ebp-10h]
  char v14; // [esp+Ch] [ebp-4h]

  if ( oldval - 4097 > 3 )
  {
    runtime_printlock();
    se.str = (uint8 *)"runtime: casfrom_Gscanstatus bad oldval gp=";
    se.len = 43;
    runtime_printstring(se);
    runtime_printpointer(gp);
    sf.str = (uint8 *)", oldval=";
    sf.len = 9;
    runtime_printstring(sf);
    runtime_printhex(oldval);
    sg.str = (uint8 *)", newval=";
    sg.len = 9;
    runtime_printstring(sg);
    runtime_printhex(newval);
    sh.str = (uint8 *)"\n";
    sh.len = 1;
    runtime_printstring(sh);
    runtime_printunlock();
    runtime_dumpgstatus(gp);
    si.str = (uint8 *)"casfrom_Gscanstatus:top gp->status is not in scan state";
    si.len = 55;
    runtime_throw(si);
    BUG();
  }
  if ( newval == (oldval & 0xFFFFEFFF) )
  {
    runtime_internal_atomic_Cas();
    v3 = v14;
  }
  else
  {
    v3 = 0;
  }
  if ( !v3 )
  {
    runtime_printlock();
    s.str = (uint8 *)"runtime: casfrom_Gscanstatus failed gp=";
    s.len = 39;
    runtime_printstring(s);
    runtime_printpointer(gp);
    sa.str = (uint8 *)", oldval=";
    sa.len = 9;
    runtime_printstring(sa);
    runtime_printhex(oldval);
    sb.str = (uint8 *)", newval=";
    sb.len = 9;
    runtime_printstring(sb);
    runtime_printhex(newval);
    sc.str = (uint8 *)"\n";
    sc.len = 1;
    runtime_printstring(sc);
    runtime_printunlock();
    runtime_dumpgstatus(gp);
    sd.str = (uint8 *)"casfrom_Gscanstatus: gp->status is not in scan state";
    sd.len = 52;
    runtime_throw(sd);
    BUG();
  }
}
// 806EC7E: variable 'v14' is possibly undefined

//----- (0806EE10) --------------------------------------------------------
bool __golang runtime_castogscanstatus(runtime_g *gp, uint32 oldval, uint32 newval)
{
  string s; // [esp+0h] [ebp-10h]
  string sa; // [esp+0h] [ebp-10h]
  string sb; // [esp+0h] [ebp-10h]
  string sc; // [esp+0h] [ebp-10h]
  bool v7; // [esp+Ch] [ebp-4h]

  if ( oldval - 1 > 3 || newval != (oldval | 0x1000) )
  {
    runtime_printlock();
    s.str = (uint8 *)"runtime: castogscanstatus oldval=";
    s.len = 33;
    runtime_printstring(s);
    runtime_printhex(oldval);
    sa.str = (uint8 *)" newval=";
    sa.len = 8;
    runtime_printstring(sa);
    runtime_printhex(newval);
    sb.str = (uint8 *)"\n";
    sb.len = 1;
    runtime_printstring(sb);
    runtime_printunlock();
    sc.str = (uint8 *)"castogscanstatus";
    sc.len = 16;
    runtime_throw(sc);
    BUG();
  }
  runtime_internal_atomic_Cas();
  return v7;
}
// 806EE62: variable 'v7' is possibly undefined

//----- (0806EF00) --------------------------------------------------------
void __golang runtime_casgstatus(runtime_g *gp, uint32 oldval, uint32 newval)
{
  uint32 v3; // eax
  runtime_g *v4; // ecx
  __int32 v5; // edx
  int v6; // ebx
  unsigned int v7; // ebp
  __int64 v8; // rax
  uint32 v9; // esi
  string s; // [esp+0h] [ebp-30h]
  string sa; // [esp+0h] [ebp-30h]
  string sb; // [esp+0h] [ebp-30h]
  string sc; // [esp+0h] [ebp-30h]
  string sd; // [esp+0h] [ebp-30h]
  string se; // [esp+0h] [ebp-30h]
  char v16; // [esp+Ch] [ebp-24h]
  __int32 x; // [esp+10h] [ebp-20h]
  uint32 nextYield_lo; // [esp+14h] [ebp-1Ch]
  __int32 i; // [esp+1Ch] [ebp-14h]
  uint32 v; // [esp+20h] [ebp-10h]

  if ( (oldval & 0x1000) != 0 || (newval & 0x1000) != 0 || newval == oldval )
    runtime_systemstack();
  v3 = oldval;
  if ( oldval == 2 )
  {
    v4 = gp;
    if ( gp->gcscanvalid )
    {
      v = gp->atomicstatus;
      runtime_printlock();
      sa.str = (uint8 *)"runtime: casgstatus ";
      sa.len = 20;
      runtime_printstring(sa);
      runtime_printhex(2uLL);
      sb.str = (uint8 *)"->";
      sb.len = 2;
      runtime_printstring(sb);
      runtime_printhex(newval);
      sc.str = (uint8 *)" gp.status=";
      sc.len = 11;
      runtime_printstring(sc);
      runtime_printhex(v);
      sd.str = (uint8 *)" gp.gcscanvalid=true\n";
      sd.len = 21;
      runtime_printstring(sd);
      runtime_printunlock();
      se.str = (uint8 *)"casgstatus";
      se.len = 10;
      runtime_throw(se);
      BUG();
    }
  }
  else
  {
    v4 = gp;
  }
  v5 = 0;
  v6 = 0;
  v7 = 0;
  while ( 1 )
  {
    i = v5;
    s.str = (uint8 *)&v4->atomicstatus;
    s.len = v3;
    runtime_internal_atomic_Cas();
    if ( v16 )
      break;
    if ( oldval == 4 && gp->atomicstatus == 1 )
    {
      s.str = (uint8 *)off_80E7BA8;
      runtime_systemstack();
    }
    if ( !i )
    {
      runtime_nanotime();
      v6 = (unsigned __int64)(*(_QWORD *)&s + 5000LL) >> 32;
      v7 = (unsigned int)(s.str + 5000);
    }
    nextYield_lo = v7;
    runtime_nanotime();
    HIDWORD(v8) = v6;
    if ( s.str < (uint8 *)v7 && s.len == HIDWORD(v8) || s.len < SHIDWORD(v8) )
    {
      LODWORD(v8) = 0;
      while ( (int)v8 < 10 )
      {
        v4 = gp;
        v9 = oldval;
        if ( oldval == gp->atomicstatus )
          goto LABEL_9;
        x = v8;
        runtime_procyield();
        LODWORD(v8) = x + 1;
        HIDWORD(v8) = v6;
        v7 = nextYield_lo;
      }
      v4 = gp;
      v9 = oldval;
    }
    else
    {
      runtime_osyield();
      runtime_nanotime();
      v8 = *(_QWORD *)&s + 2500LL;
      v4 = gp;
      v9 = oldval;
      v7 = (unsigned int)(s.str + 2500);
    }
LABEL_9:
    v3 = v9;
    v6 = HIDWORD(v8);
    v5 = i + 1;
  }
  if ( newval == 2 )
    gp->gcscanvalid = 0;
}
// 806EFC5: variable 'v16' is possibly undefined
// 80E7BA8: using guessed type void (__golang __noreturn *off_80E7BA8[3])();

//----- (0806F1A0) --------------------------------------------------------
void __golang runtime_scang(runtime_g *gp, runtime_gcWork_0 *gcw)
{
  runtime_g *v2; // eax
  __int32 v3; // ecx
  int32 v4; // edx
  unsigned int v5; // ebx
  __int64 v6; // rax
  int32 v7; // eax
  uint8 *v8; // ecx
  runtime_g *v9; // eax
  string s; // [esp+0h] [ebp-1Ch]
  string sa; // [esp+0h] [ebp-1Ch]
  int32 nextYield_hi; // [esp+14h] [ebp-8h]
  int32 nextYield_hia; // [esp+14h] [ebp-8h]
  __int32 i; // [esp+18h] [ebp-4h]

  v2 = gp;
  gp->gcscandone = 0;
  v3 = 0;
  v4 = 0;
  v5 = 0;
  while ( !v2->gcscandone )
  {
    nextYield_hi = v4;
    i = v3;
    s.len = runtime_readgstatus(v2);
    if ( s.len > 4u )
    {
      if ( s.len == 6 )
      {
        gp->gcscandone = 1;
        break;
      }
      if ( s.len != 8 && s.len != 4100 )
      {
LABEL_32:
        runtime_dumpgstatus(gp);
        sa.str = (uint8 *)"stopg: invalid status";
        sa.len = 21;
        runtime_throw(sa);
        BUG();
      }
    }
    else
    {
      if ( s.len != 1 )
      {
        if ( s.len == 2 )
        {
          if ( (!gp->preemptscan || !gp->preempt || gp->stackguard0 != -1314)
            && runtime_castogscanstatus(gp, 2u, 0x1002u) )
          {
            if ( !gp->gcscandone )
            {
              gp->preemptscan = 1;
              gp->preempt = 1;
              gp->stackguard0 = -1314;
            }
            runtime_casfrom_Gscanstatus(gp, 0x1002u, 2u);
          }
          goto LABEL_10;
        }
        if ( (unsigned int)(s.len - 3) > 1 )
          goto LABEL_32;
      }
      if ( runtime_castogscanstatus(gp, s.len, s.len | 0x1000) )
      {
        v9 = gp;
        if ( !gp->gcscandone )
        {
          runtime_scanstack(gp, gcw);
          v9 = gp;
          gp->gcscandone = 1;
        }
        runtime_restartg(v9);
        break;
      }
    }
LABEL_10:
    if ( i )
    {
      HIDWORD(v6) = nextYield_hi;
    }
    else
    {
      runtime_nanotime();
      v6 = *(_QWORD *)&s + 10000LL;
      v5 = (unsigned int)(s.str + 10000);
    }
    nextYield_hia = HIDWORD(v6);
    runtime_nanotime();
    if ( s.str < (uint8 *)v5 && s.len == nextYield_hia || s.len < nextYield_hia )
    {
      runtime_procyield();
      v7 = nextYield_hia;
      v8 = (uint8 *)v5;
    }
    else
    {
      runtime_osyield();
      runtime_nanotime();
      v7 = (unsigned __int64)(*(_QWORD *)&s + 5000LL) >> 32;
      v8 = s.str + 5000;
    }
    v4 = v7;
    v5 = (unsigned int)v8;
    v2 = gp;
    v3 = i + 1;
  }
  gp->preemptscan = 0;
}
// 806F26E: variable 's' is possibly undefined

//----- (0806F410) --------------------------------------------------------
void __golang runtime_restartg(runtime_g *gp)
{
  string s; // [esp+0h] [ebp-Ch]
  uint32 s_4; // [esp+4h] [ebp-8h]

  s_4 = runtime_readgstatus(gp);
  if ( s_4 != 6 )
  {
    if ( s_4 != 4097 && s_4 - 4099 > 1 )
    {
      runtime_dumpgstatus(gp);
      s.str = (uint8 *)"restartg: unexpected status";
      s.len = 27;
      runtime_throw(s);
      BUG();
    }
    runtime_casfrom_Gscanstatus(gp, s_4, s_4 & 0xFFFFEFFF);
  }
}

//----- (0806F4A0) --------------------------------------------------------
void __golang runtime_stopTheWorld(string reason)
{
  int v1; // eax

  runtime_semacquire(&runtime_worldsema);
  v1 = *(_DWORD *)(*(_DWORD *)(__readgsdword(0) - 4) + 24);
  *(_DWORD *)(v1 + 116) = reason.len;
  if ( *(_DWORD *)&runtime_writeBarrier.enabled )
    runtime_writebarrierptr((uintptr *)(v1 + 112), (uintptr)reason.str);
  else
    *(_DWORD *)(v1 + 112) = reason.str;
  runtime_systemstack();
}

//----- (0806F520) --------------------------------------------------------
void __golang runtime_startTheWorld()
{
  int v0; // eax

  runtime_systemstack();
  runtime_semrelease(&runtime_worldsema);
  v0 = *(_DWORD *)(*(_DWORD *)(__readgsdword(0) - 4) + 24);
  *(_DWORD *)(v0 + 116) = 0;
  if ( *(_DWORD *)&runtime_writeBarrier.enabled )
    runtime_writebarrierptr((uintptr *)(v0 + 112), 0);
  else
    *(_DWORD *)(v0 + 112) = 0;
}

//----- (0806F5A0) --------------------------------------------------------
void __golang runtime_stopTheWorldWithSema()
{
  runtime_g *v0; // eax
  int32 j; // eax
  int32 v2; // eax
  const char *v3; // ecx
  int v4; // edx
  runtime_p *l; // [esp+0h] [ebp-28h]
  string la; // [esp+0h] [ebp-28h]
  char v7; // [esp+Ch] [ebp-1Ch]
  __int32 i; // [esp+10h] [ebp-18h]
  __int32 bad_len; // [esp+14h] [ebp-14h]
  int32 stopwait; // [esp+18h] [ebp-10h]
  runtime_p *p; // [esp+1Ch] [ebp-Ch]
  uint8 *bad_ptr; // [esp+20h] [ebp-8h]
  runtime_g *_g_; // [esp+24h] [ebp-4h]

  v0 = *(runtime_g **)(__readgsdword(0) - 4);
  if ( v0->m->locks > 0 )
  {
    la.str = (uint8 *)"stopTheWorld: holding locks";
    la.len = 27;
    runtime_throw(la);
    BUG();
  }
  _g_ = v0;
  runtime_lock(&runtime_sched.lock);
  runtime_sched.stopwait = runtime_gomaxprocs;
  runtime_internal_atomic_Store();
  runtime_preemptall();
  *(_DWORD *)(_g_->m->p + 8) = 3;
  --runtime_sched.stopwait;
  for ( j = 0; j < runtime_gomaxprocs; ++j )
  {
    if ( (unsigned int)j >= 0x401 )
      runtime_panicindex();
    if ( runtime_allp[j]->status == 2 )
    {
      i = j;
      p = runtime_allp[j];
      runtime_internal_atomic_Cas();
      if ( v7 )
      {
        if ( runtime_trace.enabled )
        {
          runtime_traceGoSysBlock(p);
          runtime_traceProcStop(p);
        }
        ++p->syscalltick;
        --runtime_sched.stopwait;
        j = i;
      }
      else
      {
        j = i;
      }
    }
  }
  while ( 1 )
  {
    l = runtime_pidleget();
    if ( !l )
      break;
    l->status = 3;
    --runtime_sched.stopwait;
  }
  stopwait = runtime_sched.stopwait;
  runtime_unlock(&runtime_sched.lock);
  if ( stopwait > 0 )
  {
    while ( !runtime_notetsleep(&runtime_sched.stopnote, 100000LL) )
      runtime_preemptall();
    runtime_sched.stopnote.key = 0;
  }
  if ( runtime_sched.stopwait )
  {
    v4 = 41;
    v3 = "stopTheWorld: not stopped (stopwait != 0)";
  }
  else
  {
    v2 = 0;
    v3 = 0;
    v4 = 0;
    while ( v2 < runtime_gomaxprocs )
    {
      if ( (unsigned int)v2 >= 0x401 )
        runtime_panicindex();
      if ( runtime_allp[v2]->status != 3 )
      {
        v3 = "stopTheWorld: not stopped (status != _Pgcstop)";
        v4 = 46;
      }
      ++v2;
    }
  }
  bad_len = v4;
  bad_ptr = (uint8 *)v3;
  if ( runtime_internal_atomic_Load(&runtime_freezing) )
  {
    runtime_lock(&runtime_deadlock);
    runtime_lock(&runtime_deadlock);
  }
  if ( bad_len )
  {
    runtime_throw((string)__PAIR64__(bad_len, (unsigned int)bad_ptr));
    BUG();
  }
}
// 806F684: variable 'v7' is possibly undefined

//----- (0806F850) --------------------------------------------------------
void __golang runtime_mhelpgc()
{
  *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(__readgsdword(0) - 4) + 24) + 136) = -1;
}

//----- (0806F890) --------------------------------------------------------
void __golang runtime_startTheWorldWithSema()
{
  int32 v0; // ecx
  runtime_p *v1; // eax
  bool v2; // cl
  runtime_note_0 *m; // edx
  bool v4; // al
  string block; // [esp+0h] [ebp-18h]
  runtime_g *glist; // [esp+4h] [ebp-14h]
  bool add; // [esp+Bh] [ebp-Dh]
  bool adda; // [esp+Bh] [ebp-Dh]
  runtime_p *p1; // [esp+Ch] [ebp-Ch]
  runtime_g *_g_; // [esp+10h] [ebp-8h]
  runtime_p *link; // [esp+14h] [ebp-4h]

  _g_ = *(runtime_g **)(__readgsdword(0) - 4);
  ++_g_->m->locks;
  glist = runtime_netpoll(0);
  runtime_injectglist(glist);
  add = runtime_needaddgcproc();
  runtime_lock(&runtime_sched.lock);
  v0 = runtime_newprocs;
  if ( runtime_newprocs )
    runtime_newprocs = 0;
  else
    v0 = runtime_gomaxprocs;
  p1 = runtime_procresize(v0);
  runtime_sched.gcwaiting = 0;
  if ( runtime_sched.sysmonwait )
  {
    runtime_sched.sysmonwait = 0;
    runtime_notewakeup(&runtime_sched.sysmonnote);
  }
  runtime_unlock(&runtime_sched.lock);
  v1 = p1;
  v2 = add;
  while ( 1 )
  {
    adda = v2;
    if ( !v1 )
      break;
    m = (runtime_note_0 *)v1->m;
    link = (runtime_p *)v1->link;
    if ( m )
    {
      v1->m = 0;
      if ( m[24].key )
      {
        block.str = (uint8 *)"startTheWorld: inconsistent mp->nextp";
        block.len = 37;
        runtime_throw(block);
        BUG();
      }
      m[24].key = (uintptr)v1;
      runtime_notewakeup(m + 43);
      v4 = adda;
    }
    else
    {
      runtime_newm(0, v1);
      v4 = 0;
    }
    v2 = v4;
    v1 = link;
  }
  if ( runtime_internal_atomic_Load(&runtime_sched.npidle) && !runtime_internal_atomic_Load(&runtime_sched.nmspinning) )
    runtime_wakep();
  if ( adda )
    runtime_newm(off_80E7C74, 0);
  if ( !--_g_->m->locks && _g_->preempt )
    _g_->stackguard0 = -1314;
}

//----- (0806FA80) --------------------------------------------------------
void __golang runtime_mstart()
{
  _DWORD *v0; // eax
  int v1; // ecx
  uintptr size; // [esp+0h] [ebp-4h] BYREF

  v0 = *(_DWORD **)(__readgsdword(0) - 4);
  if ( !*v0 )
  {
    size = v0[1];
    if ( !size )
      size = 0x2000;
    v0[1] = &size;
    *v0 = (char *)&size - size + 1024;
  }
  v1 = *v0 + 880;
  v0[2] = v1;
  v0[3] = v1;
  runtime_mstart1();
}

//----- (0806FAE0) --------------------------------------------------------
void __golang runtime_mstart1()
{
  runtime_g *v0; // eax
  runtime_g *g0; // ecx
  runtime_g *v2; // eax
  void (*mstartfn)(void); // edx
  runtime_m *m; // ecx
  runtime_gobuf_0 *preinit; // [esp+0h] [ebp-Ch]
  string preinita; // [esp+0h] [ebp-Ch]
  runtime_g *_g_; // [esp+8h] [ebp-4h]

  v0 = *(runtime_g **)(__readgsdword(0) - 4);
  g0 = v0->m->g0;
  if ( v0 != g0 )
  {
    preinita.str = (uint8 *)"bad runtime·mstart";
    preinita.len = 19;
    runtime_throw(preinita);
    BUG();
  }
  _g_ = v0;
  preinit = &g0->sched;
  runtime_gosave();
  _g_->m->g0->sched.pc = -1;
  runtime_asminit();
  runtime_minit();
  if ( _g_->m == &runtime_m0 )
  {
    if ( runtime_iscgo && !runtime_cgoHasExtraM )
    {
      runtime_cgoHasExtraM = 1;
      runtime_newextram();
    }
    runtime_initsig(0);
  }
  v2 = _g_;
  mstartfn = _g_->m->mstartfn;
  if ( mstartfn )
  {
    (*(void (__golang **)(runtime_gobuf_0 *))mstartfn)(preinit);
    v2 = _g_;
  }
  m = v2->m;
  if ( m->helpgc )
  {
    m->helpgc = 0;
    runtime_stopm();
  }
  else if ( &runtime_m0 != m )
  {
    runtime_acquirep((runtime_p *)m->nextp);
    _g_->m->nextp = 0;
  }
  runtime_schedule();
}
// 806FBCA: variable 'preinit' is possibly undefined

//----- (0806FC10) --------------------------------------------------------
void __golang runtime_forEachP(func(_runtime_p) fn)
{
  int v1; // eax
  int32 v2; // ecx
  int32 v3; // edx
  runtime_p **v4; // ebx
  runtime_puintptr j; // eax
  int32 k; // eax
  runtime_p *v7; // edx
  int32 m; // eax
  int v9; // eax
  int32 locks; // edx
  string l; // [esp+0h] [ebp-30h]
  string la; // [esp+0h] [ebp-30h]
  string lb; // [esp+0h] [ebp-30h]
  uintptr src; // [esp+4h] [ebp-2Ch]
  int v15; // [esp+8h] [ebp-28h]
  char v16; // [esp+Ch] [ebp-24h]
  char v17; // [esp+Ch] [ebp-24h]
  __int32 i; // [esp+10h] [ebp-20h]
  int32 v19; // [esp+14h] [ebp-1Ch]
  int32 v20; // [esp+18h] [ebp-18h]
  int32 safePointWait; // [esp+18h] [ebp-18h]
  runtime_p *p; // [esp+1Ch] [ebp-14h]
  runtime_p *p_0; // [esp+20h] [ebp-10h]
  runtime_m *mp; // [esp+24h] [ebp-Ch]
  runtime_p *v25; // [esp+2Ch] [ebp-4h]

  v1 = *(_DWORD *)(__readgsdword(0) - 4);
  ++*(_DWORD *)(*(_DWORD *)(v1 + 24) + 120);
  mp = *(runtime_m **)(v1 + 24);
  v25 = *(runtime_p **)(*(_DWORD *)(*(_DWORD *)(__readgsdword(0) - 4) + 24) + 92);
  runtime_lock(&runtime_sched.lock);
  if ( runtime_sched.safePointWait )
  {
    lb.str = (uint8 *)"forEachP: sched.safePointWait != 0";
    lb.len = 34;
    runtime_throw(lb);
    BUG();
  }
  runtime_sched.safePointWait = runtime_gomaxprocs - 1;
  if ( *(_DWORD *)&runtime_writeBarrier.enabled )
    runtime_writebarrierptr((uintptr *)&runtime_sched.safePointFn, (uintptr)fn);
  else
    runtime_sched.safePointFn = fn;
  v2 = runtime_gomaxprocs;
  if ( (unsigned int)runtime_gomaxprocs > 0x401 )
    runtime_panicslice();
  v20 = runtime_gomaxprocs;
  v3 = 0;
  v4 = runtime_allp;
  while ( v3 < v2 )
  {
    if ( *v4 != v25 )
    {
      v19 = v3;
      src = 1;
      runtime_internal_atomic_Store();
      v2 = v20;
      v3 = v19;
    }
    ++v4;
    ++v3;
  }
  runtime_preemptall();
  for ( j = runtime_sched.pidle; j; j = p->link )
  {
    p = (runtime_p *)j;
    src = 1;
    v15 = 0;
    runtime_internal_atomic_Cas();
    if ( v16 )
    {
      v16 = (*(int (__golang **)(runtime_p *, int, _DWORD))fn)(p, 1, 0);
      --runtime_sched.safePointWait;
    }
  }
  safePointWait = runtime_sched.safePointWait;
  runtime_unlock(&runtime_sched.lock);
  v17 = (*(int (__golang **)(runtime_p *, uintptr, int))fn)(v25, src, v15);
  for ( k = 0; k < runtime_gomaxprocs; ++k )
  {
    if ( (unsigned int)k >= 0x401 )
      runtime_panicindex();
    v7 = runtime_allp[k];
    if ( v7->status == 2 && v7->runSafePointFn == 1 )
    {
      i = k;
      p_0 = runtime_allp[k];
      runtime_internal_atomic_Cas();
      if ( v17 )
      {
        if ( runtime_trace.enabled )
        {
          runtime_traceGoSysBlock(p_0);
          runtime_traceProcStop(p_0);
        }
        ++p_0->syscalltick;
        runtime_handoffp(p_0);
        k = i;
      }
      else
      {
        k = i;
      }
    }
  }
  if ( safePointWait > 0 )
  {
    while ( !runtime_notetsleep(&runtime_sched.safePointNote, 100000LL) )
      runtime_preemptall();
    runtime_sched.safePointNote.key = 0;
  }
  if ( runtime_sched.safePointWait )
  {
    la.str = (uint8 *)"forEachP: not done";
    la.len = 18;
    runtime_throw(la);
    BUG();
  }
  for ( m = 0; m < runtime_gomaxprocs; ++m )
  {
    if ( (unsigned int)m >= 0x401 )
      runtime_panicindex();
    if ( runtime_allp[m]->runSafePointFn )
    {
      l.str = (uint8 *)"forEachP: P did not run fn";
      l.len = 26;
      runtime_throw(l);
      BUG();
    }
  }
  runtime_lock(&runtime_sched.lock);
  if ( *(_DWORD *)&runtime_writeBarrier.enabled )
    runtime_writebarrierptr((uintptr *)&runtime_sched.safePointFn, 0);
  else
    runtime_sched.safePointFn = 0;
  runtime_unlock(&runtime_sched.lock);
  v9 = *(_DWORD *)(__readgsdword(0) - 4);
  locks = mp->locks;
  mp->locks = locks - 1;
  if ( locks == 1 && *(_BYTE *)(v9 + 108) )
    *(_DWORD *)(v9 + 8) = -1314;
}
// 806FD4B: variable 'v16' is possibly undefined
// 806FD90: variable 'src' is possibly undefined
// 806FD90: variable 'v15' is possibly undefined

//----- (0806FFE0) --------------------------------------------------------
void __golang runtime_runSafePointFn()
{
  int32 v0; // eax
  char v1; // [esp+Ch] [ebp-8h]
  int v2; // [esp+10h] [ebp-4h]

  v2 = *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(__readgsdword(0) - 4) + 24) + 92);
  runtime_internal_atomic_Cas();
  if ( v1 )
  {
    (*(void (__golang **)(int, int, _DWORD))runtime_sched.safePointFn)(v2, 1, 0);
    runtime_lock(&runtime_sched.lock);
    v0 = runtime_sched.safePointWait--;
    if ( v0 == 1 )
      runtime_notewakeup(&runtime_sched.safePointNote);
    runtime_unlock(&runtime_sched.lock);
  }
}
// 8070039: variable 'v1' is possibly undefined

//----- (080700A0) --------------------------------------------------------
runtime_m *__golang runtime_allocm(runtime_p *_p_, func() fn)
{
  runtime_m *v2; // eax
  runtime_m *v3; // eax
  runtime_g *v4; // ecx
  void *src; // [esp+4h] [ebp-Ch]
  runtime_g *srca; // [esp+4h] [ebp-Ch]
  uintptr *mp; // [esp+8h] [ebp-8h]
  runtime_g *_g_; // [esp+Ch] [ebp-4h]

  _g_ = *(runtime_g **)(__readgsdword(0) - 4);
  ++_g_->m->locks;
  if ( !_g_->m->p )
    runtime_acquirep(_p_);
  src = runtime_newobject((runtime__type_0 *)&stru_80DFD60);
  v2 = (runtime_m *)src;
  mp = (uintptr *)src;
  if ( *(_DWORD *)&runtime_writeBarrier.enabled )
  {
    runtime_writebarrierptr((uintptr *)src + 20, (uintptr)fn);
    v2 = (runtime_m *)mp;
  }
  else
  {
    *((_DWORD *)src + 20) = fn;
  }
  runtime_mcommoninit(v2);
  if ( runtime_iscgo )
  {
    srca = runtime_malg(-1);
    v3 = (runtime_m *)mp;
    if ( !*(_DWORD *)&runtime_writeBarrier.enabled )
    {
      *mp = (uintptr)srca;
      goto LABEL_8;
    }
    goto LABEL_17;
  }
  srca = runtime_malg(0x2000);
  v3 = (runtime_m *)mp;
  if ( *(_DWORD *)&runtime_writeBarrier.enabled )
  {
LABEL_17:
    runtime_writebarrierptr(mp, (uintptr)srca);
    v3 = (runtime_m *)mp;
    goto LABEL_8;
  }
  *mp = (uintptr)srca;
LABEL_8:
  if ( *(_DWORD *)&runtime_writeBarrier.enabled )
  {
    runtime_writebarrierptr((uintptr *)&v3->g0->m, (uintptr)v3);
    v3 = (runtime_m *)mp;
  }
  else
  {
    v3->g0->m = v3;
  }
  v4 = _g_;
  if ( _p_ == (runtime_p *)_g_->m->p )
  {
    runtime_releasep();
    v3 = (runtime_m *)mp;
    v4 = _g_;
  }
  if ( !--v4->m->locks && v4->preempt )
    v4->stackguard0 = -1314;
  return v3;
}

//----- (08070240) --------------------------------------------------------
void __golang runtime_needm(uint8 x)
{
  uint32 v1; // eax
  _DWORD *v2; // eax
  bool nilokay[4]; // [esp+0h] [ebp-14h] BYREF
  uint32 oldval; // [esp+4h] [ebp-10h]
  uint32 newval; // [esp+8h] [ebp-Ch]
  runtime_m *mp; // [esp+10h] [ebp-4h]

  if ( runtime_iscgo && !runtime_cgoHasExtraM )
  {
    if ( runtime_earlycgocallback.len )
    {
      oldval = (uint32)runtime_earlycgocallback.array;
      newval = runtime_earlycgocallback.len;
      runtime_write();
      *(_DWORD *)nilokay = 1;
      runtime_exit();
    }
    runtime_panicindex();
  }
  oldval = (uint32)runtime_lockextra(0);
  v1 = oldval;
  mp = (runtime_m *)oldval;
  *(_BYTE *)(oldval + 460) = *(_DWORD *)(oldval + 180) == 0;
  --runtime_extraMCount;
  runtime_unlockextra(*(runtime_m **)(v1 + 180));
  runtime_msigsave(mp);
  runtime_sigblock();
  *(_DWORD *)nilokay = mp->g0;
  runtime_setg();
  v2 = *(_DWORD **)(__readgsdword(0) - 4);
  v2[1] = &STACK[0x418];
  *v2 = &nilokay[-32744];
  v2[2] = &nilokay[-31864];
  runtime_asminit();
  runtime_minit();
  runtime_casgstatus(mp->curg, 6u, 3u);
  *(_DWORD *)nilokay = &runtime_sched.ngsys;
  oldval = -1;
  runtime_internal_atomic_Xadd();
}

//----- (08070370) --------------------------------------------------------
void __golang runtime_newextram()
{
  uint32 v0; // eax
  uint32 v1; // ecx
  uint32 v2; // [esp+8h] [ebp-10h]
  uint32 i; // [esp+Ch] [ebp-Ch]
  runtime_m *mp; // [esp+14h] [ebp-4h]

  runtime_internal_atomic_Xchg();
  v0 = v2;
  if ( v2 )
  {
    v1 = 0;
    while ( v1 < v0 )
    {
      i = v1;
      runtime_oneNewExtraM();
      v1 = i + 1;
      v0 = v2;
    }
  }
  else
  {
    mp = runtime_lockextra(1);
    runtime_unlockextra(mp);
    if ( !mp )
      runtime_oneNewExtraM();
  }
}
// 807039B: variable 'v2' is possibly undefined

//----- (08070400) --------------------------------------------------------
void __golang runtime_oneNewExtraM()
{
  uintptr v0; // ecx
  uintptr *v1; // eax
  int v2; // [esp+Ch] [ebp-1Ch]
  uint64 v3; // [esp+10h] [ebp-18h]
  runtime_m *mp; // [esp+14h] [ebp-14h]
  runtime_g *gp; // [esp+18h] [ebp-10h]
  uintptr *dst; // [esp+1Ch] [ebp-Ch]

  mp = runtime_allocm(0, 0);
  gp = runtime_malg(4096);
  gp->sched.pc = (uintptr)runtime_goexit + 1;
  gp->sched.sp = gp->stack.hi - 16;
  gp->sched.lr = 0;
  gp->sched.g = (runtime_guintptr)gp;
  gp->syscallpc = gp->sched.pc;
  gp->syscallsp = gp->sched.sp;
  gp->stktopsp = gp->sched.sp;
  gp->gcscanvalid = 1;
  gp->gcscandone = 1;
  runtime_casgstatus(gp, 0, 6u);
  v0 = (uintptr)gp;
  if ( *(_DWORD *)&runtime_writeBarrier.enabled )
  {
    runtime_writebarrierptr((uintptr *)&gp->m, (uintptr)mp);
    v1 = (uintptr *)mp;
    v0 = (uintptr)gp;
  }
  else
  {
    v1 = (uintptr *)mp;
    gp->m = mp;
  }
  if ( *(_DWORD *)&runtime_writeBarrier.enabled )
  {
    runtime_writebarrierptr(v1 + 21, v0);
    v1 = (uintptr *)mp;
    v0 = (uintptr)gp;
  }
  else
  {
    v1[21] = v0;
  }
  v1[113] = 2;
  if ( *(_DWORD *)&runtime_writeBarrier.enabled )
  {
    dst = (uintptr *)(v0 + 136);
    runtime_writebarrierptr(v1 + 47, v0);
    runtime_writebarrierptr(dst, (uintptr)mp);
  }
  else
  {
    v1[47] = v0;
    *(_DWORD *)(v0 + 136) = v1;
  }
  v3 = runtime_internal_atomic_Xadd64(&runtime_sched.goidgen, 1LL);
  LODWORD(gp->goid) = v2;
  HIDWORD(gp->goid) = v3;
  runtime_allgadd(gp);
  runtime_internal_atomic_Xadd();
  *(_DWORD *)(HIDWORD(v3) + 180) = runtime_lockextra(1);
  ++runtime_extraMCount;
  runtime_unlockextra((runtime_m *)HIDWORD(v3));
}
// 8070541: variable 'v2' is possibly undefined

//----- (08070610) --------------------------------------------------------
void __golang runtime_dropm()
{
  runtime_m *oldval; // [esp+4h] [ebp-14h]
  runtime_sigset sigmask; // [esp+Ch] [ebp-Ch]
  runtime_m *mp; // [esp+14h] [ebp-4h]

  mp = *(runtime_m **)(*(_DWORD *)(__readgsdword(0) - 4) + 24);
  runtime_casgstatus(mp->curg, 3u, 6u);
  runtime_internal_atomic_Xadd();
  *(_QWORD *)sigmask = *(_QWORD *)mp->sigmask;
  runtime_sigblock();
  runtime_unminit();
  oldval = runtime_lockextra(1);
  ++runtime_extraMCount;
  mp->schedlink = (runtime_muintptr)oldval;
  runtime_setg();
  runtime_unlockextra(mp);
  runtime_msigrestore(*(runtime_sigset *)sigmask);
}

//----- (080706F0) --------------------------------------------------------
runtime_m *__golang runtime_lockextra(bool nilokay)
{
  char i; // al
  int v2; // [esp+4h] [ebp-14h]
  char v3; // [esp+Ch] [ebp-Ch]
  bool incr; // [esp+13h] [ebp-5h]

  for ( i = 0; ; i = 1 )
  {
    while ( 1 )
    {
      incr = i;
      runtime_internal_atomic_Loaduintptr();
      if ( v2 != 1 )
        break;
LABEL_9:
      runtime_osyield();
      i = incr;
    }
    if ( v2 || nilokay )
      break;
    if ( !incr )
    {
      v2 = 1;
      runtime_internal_atomic_Xadd();
    }
    runtime_usleep();
  }
  runtime_internal_atomic_Casuintptr();
  if ( !v3 )
    goto LABEL_9;
  return (runtime_m *)v2;
}
// 807070E: variable 'v2' is possibly undefined
// 8070776: variable 'v3' is possibly undefined

//----- (080707C0) --------------------------------------------------------
void __golang runtime_unlockextra(runtime_m *mp)
{
  runtime_internal_atomic_Storeuintptr();
}

//----- (080707F0) --------------------------------------------------------
void __golang runtime_newm(func() fn, runtime_p *_p_)
{
  runtime_m *v2; // eax
  uint32 v3; // edx
  string s; // [esp+0h] [ebp-24h]
  runtime_m *mp; // [esp+Ch] [ebp-18h]

  v2 = runtime_allocm(_p_, fn);
  v2->nextp = (runtime_puintptr)_p_;
  v3 = runtime_initSigmask[1];
  v2->sigmask[0] = runtime_initSigmask[0];
  v2->sigmask[1] = v3;
  if ( runtime_iscgo )
  {
    if ( !cgo_thread_start )
    {
      s.str = (uint8 *)"_cgo_thread_start missing";
      s.len = 25;
      runtime_throw(s);
      BUG();
    }
    runtime___ptr_rwmutex__rlock(&runtime_execLock);
    runtime_asmcgocall();
    runtime___ptr_rwmutex__runlock(&runtime_execLock);
  }
  else
  {
    mp = v2;
    runtime___ptr_rwmutex__rlock(&runtime_execLock);
    runtime_newosproc(mp, (void *)mp->g0->stack.hi);
    runtime___ptr_rwmutex__runlock(&runtime_execLock);
  }
}
// 80E7C84: using guessed type int (__golang *off_80E7C84)();

//----- (08070940) --------------------------------------------------------
void __golang runtime_stopm()
{
  runtime_g *v0; // eax
  runtime_m *m; // ecx
  runtime_m *v2; // ecx
  string l; // [esp+0h] [ebp-Ch]
  string la; // [esp+0h] [ebp-Ch]
  string lb; // [esp+0h] [ebp-Ch]
  runtime_g *_g_; // [esp+8h] [ebp-4h]

  v0 = *(runtime_g **)(__readgsdword(0) - 4);
  m = v0->m;
  if ( m->locks )
  {
    lb.str = (uint8 *)"stopm holding locks";
    lb.len = 19;
    runtime_throw(lb);
    BUG();
  }
  if ( m->p )
  {
    la.str = (uint8 *)"stopm holding p";
    la.len = 15;
    runtime_throw(la);
    BUG();
  }
  if ( m->spinning )
  {
    l.str = (uint8 *)"stopm spinning";
    l.len = 14;
    runtime_throw(l);
    BUG();
  }
  for ( _g_ = v0; ; _g_->m->p = 0 )
  {
    runtime_lock(&runtime_sched.lock);
    runtime_mput(_g_->m);
    runtime_unlock(&runtime_sched.lock);
    runtime_notesleep(&_g_->m->park);
    _g_->m->park.key = 0;
    v2 = _g_->m;
    if ( !v2->helpgc )
      break;
    runtime_gchelper();
    _g_->m->helpgc = 0;
    _g_->m->mcache = 0;
  }
  runtime_acquirep((runtime_p *)v2->nextp);
  _g_->m->nextp = 0;
}

//----- (08070AA0) --------------------------------------------------------
void __golang runtime_mspinning()
{
  *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(__readgsdword(0) - 4) + 24) + 140) = 1;
}

//----- (08070AE0) --------------------------------------------------------
void __golang runtime_startm(runtime_p *_p_, bool spinning)
{
  runtime_p *v2; // eax
  runtime_muintptr v3; // eax
  bool v4; // cl
  void (*v5)(void); // eax
  string l; // [esp+0h] [ebp-18h]
  string la; // [esp+0h] [ebp-18h]
  string lb; // [esp+0h] [ebp-18h]
  string lc; // [esp+0h] [ebp-18h]
  int v10; // [esp+8h] [ebp-10h]
  runtime_p *p; // [esp+Ch] [ebp-Ch]
  runtime_muintptr midle; // [esp+14h] [ebp-4h]

  runtime_lock(&runtime_sched.lock);
  v2 = _p_;
  if ( _p_ || (v2 = runtime_pidleget()) != 0 )
  {
    p = v2;
    midle = runtime_sched.midle;
    if ( runtime_sched.midle )
    {
      runtime_sched.midle = *(_DWORD *)(runtime_sched.midle + 180);
      --runtime_sched.nmidle;
    }
    runtime_unlock(&runtime_sched.lock);
    v3 = midle;
    if ( midle )
    {
      if ( *(_BYTE *)(midle + 140) )
      {
        lb.str = (uint8 *)"startm: m is spinning";
        lb.len = 21;
        runtime_throw(lb);
        BUG();
      }
      if ( *(_DWORD *)(midle + 96) )
      {
        la.str = (uint8 *)"startm: m has p";
        la.len = 15;
        runtime_throw(la);
        BUG();
      }
      v4 = spinning;
      if ( spinning )
      {
        if ( !runtime_runqempty(p) )
        {
          l.str = (uint8 *)"startm: p has runnable gs";
          l.len = 25;
          runtime_throw(l);
          BUG();
        }
        v3 = midle;
        v4 = spinning;
      }
      *(_BYTE *)(v3 + 140) = v4;
      *(_DWORD *)(v3 + 96) = p;
      runtime_notewakeup((runtime_note_0 *)(v3 + 172));
    }
    else
    {
      if ( spinning )
        v5 = off_80E7C80;
      else
        v5 = 0;
      runtime_newm(v5, p);
    }
  }
  else
  {
    runtime_unlock(&runtime_sched.lock);
    if ( spinning )
    {
      runtime_internal_atomic_Xadd();
      if ( v10 < 0 )
      {
        lc.str = (uint8 *)"startm: negative nmspinning";
        lc.len = 27;
        runtime_throw(lc);
        BUG();
      }
    }
  }
}
// 8070C34: variable 'v10' is possibly undefined

//----- (08070CB0) --------------------------------------------------------
void __golang runtime_handoffp(runtime_p *_p_)
{
  int32 v1; // eax
  runtime_p *v2; // eax
  int32 v3; // eax
  uint32 spinning; // [esp+4h] [ebp-10h]
  int v5; // [esp+8h] [ebp-Ch]
  char v6; // [esp+Ch] [ebp-8h]
  uint32 v7; // [esp+10h] [ebp-4h]

  if ( !runtime_runqempty(_p_) || runtime_sched.runqsize || runtime_gcBlackenEnabled && runtime_gcMarkWorkAvailable(_p_) )
  {
    runtime_startm(_p_, 0);
    return;
  }
  v7 = runtime_internal_atomic_Load(&runtime_sched.nmspinning);
  spinning = runtime_internal_atomic_Load(&runtime_sched.npidle);
  if ( !(v7 + spinning) )
  {
    spinning = 0;
    v5 = 1;
    runtime_internal_atomic_Cas();
    if ( v6 )
    {
      runtime_startm(_p_, 1);
      return;
    }
  }
  runtime_lock(&runtime_sched.lock);
  if ( !runtime_sched.gcwaiting )
  {
    v2 = _p_;
    if ( _p_->runSafePointFn )
    {
      spinning = 1;
      v5 = 0;
      runtime_internal_atomic_Cas();
      if ( v6 )
      {
        spinning = (*(int (__golang **)(runtime_p *))runtime_sched.safePointFn)(_p_);
        v3 = runtime_sched.safePointWait--;
        if ( v3 == 1 )
          runtime_notewakeup(&runtime_sched.safePointNote);
        v2 = _p_;
      }
      else
      {
        v2 = _p_;
      }
    }
    if ( !runtime_sched.runqsize )
    {
      if ( runtime_gomaxprocs - 1 != runtime_sched.npidle )
      {
LABEL_13:
        runtime_pidleput(v2);
        runtime_unlock(&runtime_sched.lock);
        return;
      }
      runtime_internal_atomic_Load64();
      if ( spinning == 0 && v5 == 0 )
      {
        v2 = _p_;
        goto LABEL_13;
      }
    }
    runtime_unlock(&runtime_sched.lock);
    runtime_startm(_p_, 0);
    return;
  }
  _p_->status = 3;
  v1 = runtime_sched.stopwait--;
  if ( v1 == 1 )
    runtime_notewakeup(&runtime_sched.stopnote);
  runtime_unlock(&runtime_sched.lock);
}
// 8070DFF: variable 'v5' is possibly undefined
// 8070E78: variable 'v6' is possibly undefined

//----- (08070F40) --------------------------------------------------------
void __golang runtime_wakep()
{
  char v0; // [esp+Ch] [ebp-4h]

  runtime_internal_atomic_Cas();
  if ( v0 )
    runtime_startm(0, 1);
}
// 8070F7A: variable 'v0' is possibly undefined

//----- (08070FA0) --------------------------------------------------------
void __golang runtime_stoplockedm()
{
  runtime_g *v0; // eax
  runtime_m *m; // ecx
  runtime_g *lockedg; // edx
  runtime_p *v; // [esp+0h] [ebp-Ch]
  string va; // [esp+0h] [ebp-Ch]
  string vb; // [esp+0h] [ebp-Ch]
  string vc; // [esp+0h] [ebp-Ch]
  runtime_g *_g_; // [esp+8h] [ebp-4h]

  v0 = *(runtime_g **)(__readgsdword(0) - 4);
  m = v0->m;
  lockedg = m->lockedg;
  if ( !lockedg || lockedg->lockedm != m )
  {
    vc.str = (uint8 *)"stoplockedm: inconsistent locking";
    vc.len = 33;
    runtime_throw(vc);
    BUG();
  }
  _g_ = v0;
  if ( m->p )
  {
    v = runtime_releasep();
    runtime_handoffp(v);
  }
  runtime_incidlelocked(1);
  runtime_notesleep(&_g_->m->park);
  _g_->m->park.key = 0;
  if ( (runtime_readgstatus(_g_->m->lockedg) & 0xFFFFEFFF) != 1 )
  {
    runtime_printlock();
    va.str = (uint8 *)"runtime:stoplockedm: g is not Grunnable or Gscanrunnable\n";
    va.len = 57;
    runtime_printstring(va);
    runtime_printunlock();
    runtime_dumpgstatus(_g_);
    vb.str = (uint8 *)"stoplockedm: not runnable";
    vb.len = 25;
    runtime_throw(vb);
    BUG();
  }
  runtime_acquirep((runtime_p *)_g_->m->nextp);
  _g_->m->nextp = 0;
}

//----- (080710F0) --------------------------------------------------------
void __golang runtime_startlockedm(runtime_g *gp)
{
  runtime_m *lockedm; // ecx
  string v; // [esp+0h] [ebp-10h]
  string va; // [esp+0h] [ebp-10h]
  runtime_m *mp; // [esp+8h] [ebp-8h]

  lockedm = gp->lockedm;
  if ( lockedm == *(runtime_m **)(*(_DWORD *)(__readgsdword(0) - 4) + 24) )
  {
    va.str = (uint8 *)"startlockedm: locked to me";
    va.len = 26;
    runtime_throw(va);
    BUG();
  }
  if ( lockedm->nextp )
  {
    v.str = (uint8 *)"startlockedm: m has p";
    v.len = 21;
    runtime_throw(v);
    BUG();
  }
  mp = gp->lockedm;
  runtime_incidlelocked(-1);
  mp->nextp = (runtime_puintptr)runtime_releasep();
  runtime_notewakeup(&mp->park);
  runtime_stopm();
}

//----- (080711B0) --------------------------------------------------------
void __golang runtime_gcstopm()
{
  int v0; // eax
  int v1; // eax
  int32 v2; // eax
  string l; // [esp+0h] [ebp-10h]
  string la; // [esp+0h] [ebp-10h]
  int v5; // [esp+8h] [ebp-8h]
  runtime_p *_p_; // [esp+Ch] [ebp-4h]

  v0 = *(_DWORD *)(__readgsdword(0) - 4);
  if ( !runtime_sched.gcwaiting )
  {
    la.str = (uint8 *)"gcstopm: not waiting for gc";
    la.len = 27;
    runtime_throw(la);
    BUG();
  }
  v1 = *(_DWORD *)(v0 + 24);
  if ( *(_BYTE *)(v1 + 140) )
  {
    *(_BYTE *)(v1 + 140) = 0;
    runtime_internal_atomic_Xadd();
    if ( v5 < 0 )
    {
      l.str = (uint8 *)"gcstopm: negative nmspinning";
      l.len = 28;
      runtime_throw(l);
      BUG();
    }
  }
  _p_ = runtime_releasep();
  runtime_lock(&runtime_sched.lock);
  _p_->status = 3;
  v2 = runtime_sched.stopwait--;
  if ( v2 == 1 )
    runtime_notewakeup(&runtime_sched.stopnote);
  runtime_unlock(&runtime_sched.lock);
  runtime_stopm();
}
// 8071275: variable 'v5' is possibly undefined

//----- (080712C0) --------------------------------------------------------
void __golang runtime_execute(runtime_g *gp, bool inheritTime)
{
  runtime_g *v2; // eax
  runtime_g *v3; // ecx
  runtime_m *m; // edx
  uintptr v5; // ebp
  runtime_g *_g_; // [esp+Ch] [ebp-4h]

  _g_ = *(runtime_g **)(__readgsdword(0) - 4);
  runtime_casgstatus(gp, 1u, 2u);
  v2 = gp;
  gp->waitsince = 0LL;
  gp->preempt = 0;
  gp->stackguard0 = gp->stack.lo + 880;
  if ( !inheritTime )
    ++*(_DWORD *)(_g_->m->p + 16);
  v3 = _g_;
  m = _g_->m;
  if ( *(_DWORD *)&runtime_writeBarrier.enabled )
  {
    runtime_writebarrierptr((uintptr *)&m->curg, (uintptr)gp);
    v2 = gp;
    v3 = _g_;
  }
  else
  {
    m->curg = gp;
  }
  v5 = (uintptr)v3->m;
  if ( *(_DWORD *)&runtime_writeBarrier.enabled )
  {
    runtime_writebarrierptr((uintptr *)&v2->m, v5);
    v2 = gp;
    v3 = _g_;
  }
  else
  {
    v2->m = (runtime_m *)v5;
  }
  if ( v3->m->profilehz != runtime_sched.profilehz )
  {
    runtime_setThreadCPUProfiler(runtime_sched.profilehz);
    v2 = gp;
  }
  if ( runtime_trace.enabled )
  {
    if ( v2->syscallsp && v2->sysblocktraced )
      runtime_traceGoSysExit(v2->sysexitticks);
    runtime_traceGoStart();
  }
  runtime_gogo();
}

//----- (08071420) --------------------------------------------------------
void __golang runtime_findrunnable(runtime_g *gp, bool inheritTime)
{
  runtime_g *v2; // eax
  int v3; // edi
  int j; // eax
  int v5; // ecx
  unsigned int v6; // ebp
  runtime_p *v7; // eax
  int32 k; // ecx
  runtime_p *v9; // ebp
  runtime_p *v10; // eax
  runtime_m *v11; // ecx
  runtime_p *v12; // ecx
  runtime_g *v13; // edx
  runtime_m *m; // ecx
  runtime_m *v15; // ecx
  runtime_p *p; // [esp+0h] [ebp-58h]
  runtime_p *pb; // [esp+0h] [ebp-58h]
  runtime_g *pa; // [esp+0h] [ebp-58h]
  string pc; // [esp+0h] [ebp-58h]
  string pd; // [esp+0h] [ebp-58h]
  string pe; // [esp+0h] [ebp-58h]
  string pf; // [esp+0h] [ebp-58h]
  uint32 p2; // [esp+4h] [ebp-54h]
  runtime_p *p2b; // [esp+4h] [ebp-54h]
  runtime_g *p2a; // [esp+4h] [ebp-54h]
  runtime_g *stealRunNextG; // [esp+8h] [ebp-50h]
  runtime_g *v27; // [esp+Ch] [ebp-4Ch]
  bool spinning; // [esp+17h] [ebp-41h]
  __int32 i; // [esp+18h] [ebp-40h]
  uint32 v30; // [esp+1Ch] [ebp-3Ch]
  int v31; // [esp+20h] [ebp-38h]
  int32 v32; // [esp+24h] [ebp-34h]
  int enuma; // [esp+28h] [ebp-30h]
  uint32 enum_4; // [esp+2Ch] [ebp-2Ch]
  uint32 enum_8; // [esp+30h] [ebp-28h]
  uint32 enum_12; // [esp+34h] [ebp-24h]
  runtime_g *gp_0; // [esp+38h] [ebp-20h]
  runtime_g *gp_1; // [esp+3Ch] [ebp-1Ch]
  runtime_p *_p_; // [esp+48h] [ebp-10h]
  runtime_p *_p_a; // [esp+48h] [ebp-10h]
  runtime_p *_p_b; // [esp+48h] [ebp-10h]
  runtime_p *_p__0; // [esp+4Ch] [ebp-Ch]
  runtime_g *_g_; // [esp+50h] [ebp-8h]
  runtime_p *v44; // [esp+54h] [ebp-4h]
  runtime_g *gcBgMarkWorker; // [esp+54h] [ebp-4h]

  v2 = *(runtime_g **)(__readgsdword(0) - 4);
  for ( _g_ = v2; ; v2 = _g_ )
  {
LABEL_43:
    while ( 1 )
    {
      v12 = (runtime_p *)v2->m->p;
      if ( !runtime_sched.gcwaiting )
        break;
      runtime_gcstopm();
      v2 = _g_;
    }
    v44 = (runtime_p *)v2->m->p;
    if ( v12->runSafePointFn )
    {
      runtime_runSafePointFn();
      v12 = v44;
    }
    if ( runtime_fingwait && runtime_fingwake )
    {
      pa = runtime_wakefing();
      if ( pa )
        runtime_ready(pa, 0, 1);
      v12 = v44;
    }
    if ( *runtime_cgo_yield )
    {
      p2 = 0;
      runtime_asmcgocall();
      v12 = v44;
    }
    runtime_runqget(v12, (runtime_g *)p2, (bool)stealRunNextG);
    if ( p2b )
      return;
    if ( runtime_sched.runqsize )
    {
      runtime_lock(&runtime_sched.lock);
      stealRunNextG = runtime_globrunqget(v44, 0);
      runtime_unlock(&runtime_sched.lock);
      if ( stealRunNextG )
        return;
    }
    if ( runtime_netpollinited() && (LODWORD(runtime_sched.lastpoll) != 0 || HIDWORD(runtime_sched.lastpoll) != 0) )
    {
      p2a = runtime_netpoll(0);
      if ( p2a )
      {
        gp_1 = p2a;
        runtime_injectglist((runtime_g *)p2a->schedlink);
        runtime_casgstatus(p2a, 4u, 1u);
        if ( runtime_trace.enabled )
          runtime_traceGoUnpark(gp_1, 0);
        return;
      }
    }
    v32 = runtime_gomaxprocs;
    p2 = runtime_internal_atomic_Load(&runtime_sched.npidle);
    if ( v32 - 1 == p2 )
    {
      v7 = v44;
      goto LABEL_33;
    }
    v13 = _g_;
    if ( !_g_->m->spinning )
    {
      v30 = runtime_internal_atomic_Load(&runtime_sched.nmspinning);
      p2 = runtime_internal_atomic_Load(&runtime_sched.npidle);
      if ( 2 * v30 >= v32 - p2 )
      {
        v7 = v44;
        goto LABEL_33;
      }
      v13 = _g_;
    }
    m = v13->m;
    if ( !m->spinning )
    {
      m->spinning = 1;
      p2 = 1;
      runtime_internal_atomic_Xadd();
    }
    for ( j = 0; j < 4; j = v3 + 1 )
    {
      v5 = *(_DWORD *)(*(_DWORD *)(__readgsdword(0) - 4) + 24);
      v6 = (*(int *)(v5 + 148) >> 31) & 0xA8888EEF ^ (2 * *(_DWORD *)(v5 + 148));
      *(_DWORD *)(v5 + 148) = v6;
      if ( !runtime_stealOrder.count )
        runtime_panicdivide();
      v3 = j;
      if ( !runtime_stealOrder.coprimes.len )
        runtime_panicdivide();
      v31 = j;
      enuma = 0;
      enum_4 = runtime_stealOrder.count;
      enum_8 = v6 % runtime_stealOrder.count;
      enum_12 = runtime_stealOrder.coprimes.array[v6 % runtime_stealOrder.coprimes.len];
      while ( enuma != enum_4 )
      {
        if ( runtime_sched.gcwaiting )
        {
          v2 = _g_;
          goto LABEL_43;
        }
        if ( enum_8 >= 0x401 )
          runtime_panicindex();
        v27 = runtime_runqsteal(v44, runtime_allp[enum_8], v3 > 2);
        if ( v27 )
          return;
        ++enuma;
        if ( !enum_4 )
          runtime_panicdivide();
        enum_8 = (enum_8 + enum_12) % enum_4;
        v3 = v31;
      }
    }
    v7 = v44;
LABEL_33:
    _p_a = v7;
    if ( runtime_gcBlackenEnabled )
    {
      if ( v7->gcBgMarkWorker )
      {
        LOBYTE(p2) = runtime_gcMarkWorkAvailable(v7);
        if ( (_BYTE)p2 )
        {
          _p_a->gcMarkWorkerMode = 2;
          gcBgMarkWorker = (runtime_g *)_p_a->gcBgMarkWorker;
          runtime_casgstatus(gcBgMarkWorker, 4u, 1u);
          if ( runtime_trace.enabled )
            runtime_traceGoUnpark(gcBgMarkWorker, 0);
          return;
        }
      }
    }
    runtime_lock(&runtime_sched.lock);
    if ( !runtime_sched.gcwaiting && !_p_a->runSafePointFn )
      break;
    runtime_unlock(&runtime_sched.lock);
  }
  if ( runtime_sched.runqsize )
  {
    runtime_globrunqget(_p_a, 0);
    runtime_unlock(&runtime_sched.lock);
    return;
  }
  if ( runtime_releasep() != _p_a )
  {
    pf.str = (uint8 *)"findrunnable: wrong p";
    pf.len = 21;
    runtime_throw(pf);
    BUG();
  }
  runtime_pidleput(_p_a);
  runtime_unlock(&runtime_sched.lock);
  v11 = _g_->m;
  spinning = v11->spinning;
  if ( spinning )
  {
    v11->spinning = 0;
    p2 = -1;
    runtime_internal_atomic_Xadd();
    if ( (int)stealRunNextG < 0 )
    {
      pe.str = (uint8 *)"findrunnable: negative nmspinning";
      pe.len = 33;
      runtime_throw(pe);
      BUG();
    }
  }
  for ( k = 0; ; ++k )
  {
    if ( k >= runtime_gomaxprocs )
      goto LABEL_24;
    if ( (unsigned int)k >= 0x401 )
      runtime_panicindex();
    v9 = runtime_allp[k];
    if ( v9 )
      break;
LABEL_17:
    ;
  }
  i = k;
  LOBYTE(p2) = runtime_runqempty(v9);
  if ( (_BYTE)p2 )
  {
    k = i;
    goto LABEL_17;
  }
  runtime_lock(&runtime_sched.lock);
  _p__0 = runtime_pidleget();
  runtime_unlock(&runtime_sched.lock);
  if ( _p__0 )
  {
    runtime_acquirep(_p__0);
    if ( spinning )
    {
      _g_->m->spinning = 1;
      p2 = 1;
      runtime_internal_atomic_Xadd();
    }
    v2 = _g_;
    goto LABEL_43;
  }
LABEL_24:
  if ( runtime_gcBlackenEnabled )
  {
    LOBYTE(p2) = runtime_gcMarkWorkAvailable(0);
    if ( (_BYTE)p2 )
    {
      runtime_lock(&runtime_sched.lock);
      p = runtime_pidleget();
      v10 = p;
      if ( p && !p->gcBgMarkWorker )
      {
        runtime_pidleput(p);
        v10 = 0;
      }
      _p_ = v10;
      runtime_unlock(&runtime_sched.lock);
      if ( _p_ )
      {
        runtime_acquirep(_p_);
        if ( spinning )
        {
          _g_->m->spinning = 1;
          p2 = 1;
          runtime_internal_atomic_Xadd();
        }
        v7 = _p_;
        goto LABEL_33;
      }
    }
  }
  if ( !runtime_netpollinited() )
    goto LABEL_42;
  p2 = runtime_internal_atomic_Load(&runtime_netpollWaiters);
  if ( !p2 || !((v27 != 0) | ((unsigned int)runtime_internal_atomic_Xchg64(&runtime_sched.lastpoll, 0LL) != 0)) )
    goto LABEL_42;
  v15 = _g_->m;
  if ( v15->p )
  {
    pd.str = (uint8 *)"findrunnable: netpoll with p";
    pd.len = 28;
    runtime_throw(pd);
    BUG();
  }
  if ( v15->spinning )
  {
    pc.str = (uint8 *)"findrunnable: netpoll with spinning";
    pc.len = 35;
    runtime_throw(pc);
    BUG();
  }
  gp_0 = runtime_netpoll(1);
  runtime_nanotime();
  p2 = (uint32)pb;
  LOBYTE(stealRunNextG) = (_BYTE)gp_0;
  runtime_internal_atomic_Store64();
  if ( !gp_0 )
  {
LABEL_42:
    runtime_stopm();
    v2 = _g_;
    goto LABEL_43;
  }
  runtime_lock(&runtime_sched.lock);
  _p_b = runtime_pidleget();
  runtime_unlock(&runtime_sched.lock);
  if ( !_p_b )
  {
    runtime_injectglist(gp_0);
    goto LABEL_42;
  }
  runtime_acquirep(_p_b);
  runtime_injectglist((runtime_g *)gp_0->schedlink);
  runtime_casgstatus(gp_0, 4u, 1u);
  if ( runtime_trace.enabled )
    runtime_traceGoUnpark(gp_0, 0);
}
// 80717C0: variable 'p2' is possibly undefined
// 80717C0: variable 'stealRunNextG' is possibly undefined
// 80717D0: variable 'p2b' is possibly undefined
// 80718AD: variable 'v27' is possibly undefined
// 8071906: variable 'pb' is possibly undefined

//----- (08071D50) --------------------------------------------------------
bool __golang runtime_pollWork()
{
  runtime_g *glist; // [esp+4h] [ebp-4h]

  if ( runtime_sched.runqsize )
    return 1;
  if ( !runtime_runqempty(*(runtime_p **)(*(_DWORD *)(*(_DWORD *)(__readgsdword(0) - 4) + 24) + 92)) )
    return 1;
  if ( !runtime_netpollinited() )
    return 0;
  if ( !runtime_internal_atomic_Load(&runtime_netpollWaiters) )
    return 0;
  if ( LODWORD(runtime_sched.lastpoll) == 0 && HIDWORD(runtime_sched.lastpoll) == 0 )
    return 0;
  glist = runtime_netpoll(0);
  if ( !glist )
    return 0;
  runtime_injectglist(glist);
  return 1;
}

//----- (08071E30) --------------------------------------------------------
void __golang runtime_resetspinning()
{
  int v0; // eax
  string ptr; // [esp+0h] [ebp-Ch]
  string ptra; // [esp+0h] [ebp-Ch]
  int v3; // [esp+8h] [ebp-4h]

  v0 = *(_DWORD *)(*(_DWORD *)(__readgsdword(0) - 4) + 24);
  if ( !*(_BYTE *)(v0 + 140) )
  {
    ptra.str = (uint8 *)"resetspinning: not a spinning m";
    ptra.len = 31;
    runtime_throw(ptra);
    BUG();
  }
  *(_BYTE *)(v0 + 140) = 0;
  runtime_internal_atomic_Xadd();
  if ( v3 < 0 )
  {
    ptr.str = (uint8 *)"findrunnable: negative nmspinning";
    ptr.len = 33;
    runtime_throw(ptr);
    BUG();
  }
  if ( !v3 )
  {
    if ( runtime_internal_atomic_Load(&runtime_sched.npidle) )
      runtime_wakep();
  }
}
// 8071E87: variable 'v3' is possibly undefined

//----- (08071EF0) --------------------------------------------------------
void __golang runtime_injectglist(runtime_g *glist)
{
  runtime_g *schedlink; // eax
  runtime_g *v2; // eax
  __int32 v3; // ecx
  __int32 i; // eax
  __int32 n; // [esp+Ch] [ebp-10h]
  __int32 na; // [esp+Ch] [ebp-10h]
  runtime_g *gp; // [esp+10h] [ebp-Ch]
  runtime_g *g; // [esp+14h] [ebp-8h]
  runtime_g *v9; // [esp+18h] [ebp-4h]

  schedlink = glist;
  if ( glist )
  {
    if ( runtime_trace.enabled )
    {
      while ( schedlink )
      {
        gp = schedlink;
        runtime_traceGoUnpark(schedlink, 0);
        schedlink = (runtime_g *)gp->schedlink;
      }
    }
    runtime_lock(&runtime_sched.lock);
    v2 = glist;
    v3 = 0;
    while ( 1 )
    {
      n = v3;
      if ( !v2 )
        break;
      g = v2;
      v9 = (runtime_g *)v2->schedlink;
      runtime_casgstatus(v2, 4u, 1u);
      g->schedlink = 0;
      if ( runtime_sched.runqtail )
        *(_DWORD *)(runtime_sched.runqtail + 104) = g;
      else
        runtime_sched.runqhead = (runtime_guintptr)g;
      runtime_sched.runqtail = (runtime_guintptr)g;
      ++runtime_sched.runqsize;
      v3 = n + 1;
      v2 = v9;
    }
    runtime_unlock(&runtime_sched.lock);
    for ( i = n; i && runtime_sched.npidle; i = na - 1 )
    {
      na = i;
      runtime_startm(0, 0);
    }
  }
}

//----- (08072040) --------------------------------------------------------
void __golang runtime_schedule()
{
  runtime_g *v0; // ecx
  runtime_m *m; // edx
  runtime_g *v2; // eax
  bool v3; // cl
  runtime_g *v4; // ebx
  runtime_g *s; // [esp+0h] [ebp-1Ch]
  runtime_g *sa; // [esp+0h] [ebp-1Ch]
  string sb; // [esp+0h] [ebp-1Ch]
  string sc; // [esp+0h] [ebp-1Ch]
  runtime_g *s_4; // [esp+4h] [ebp-18h]
  runtime_g *newval; // [esp+8h] [ebp-14h]
  bool inheritTime; // [esp+Fh] [ebp-Dh]
  runtime_g *gp; // [esp+10h] [ebp-Ch]
  runtime_g *_g_; // [esp+14h] [ebp-8h]
  runtime_g *v14; // [esp+18h] [ebp-4h]

  v0 = *(runtime_g **)(__readgsdword(0) - 4);
  m = v0->m;
  if ( m->locks )
  {
    sc.str = (uint8 *)"schedule: holding locks";
    sc.len = 23;
    runtime_throw(sc);
    BUG();
  }
  _g_ = v0;
  if ( m->lockedg )
  {
    runtime_stoplockedm();
    runtime_execute(_g_->m->lockedg, 0);
    v0 = _g_;
  }
  while ( 1 )
  {
    while ( runtime_sched.gcwaiting )
    {
      runtime_gcstopm();
      v0 = _g_;
    }
    if ( *(_DWORD *)(v0->m->p + 2408) )
      runtime_runSafePointFn();
    if ( runtime_trace.enabled || runtime_trace.shutdown )
    {
      s = runtime_traceReader();
      v2 = s;
      if ( s )
      {
        v14 = s;
        runtime_casgstatus(s, 4u, 1u);
        runtime_traceGoUnpark(v14, 0);
        v2 = v14;
      }
    }
    else
    {
      v2 = 0;
    }
    if ( !v2 && runtime_gcBlackenEnabled )
    {
      newval = runtime___ptr_gcControllerState__findRunnableGCWorker(&runtime_gcController, (runtime_p *)_g_->m->p);
      v2 = newval;
    }
    if ( !v2 )
    {
      v4 = 0;
      if ( !(*(_DWORD *)(_g_->m->p + 16) % 0x3Du) && runtime_sched.runqsize > 0 )
      {
        runtime_lock(&runtime_sched.lock);
        newval = runtime_globrunqget((runtime_p *)_g_->m->p, 1);
        runtime_unlock(&runtime_sched.lock);
        v4 = newval;
      }
      v2 = v4;
    }
    if ( v2 )
    {
      v3 = 0;
    }
    else
    {
      runtime_runqget((runtime_p *)_g_->m->p, s_4, (bool)newval);
      v2 = s_4;
      v3 = (char)newval;
      if ( s_4 && _g_->m->spinning )
      {
        sb.str = (uint8 *)"schedule: spinning with local work";
        sb.len = 34;
        runtime_throw(sb);
        BUG();
      }
    }
    if ( !v2 )
    {
      runtime_findrunnable(s, (bool)s_4);
      v2 = sa;
      v3 = (char)s_4;
    }
    if ( _g_->m->spinning )
    {
      inheritTime = v3;
      gp = v2;
      runtime_resetspinning();
      v2 = gp;
      v3 = inheritTime;
    }
    if ( !v2->lockedm )
      break;
    runtime_startlockedm(v2);
    v0 = _g_;
  }
  runtime_execute(v2, v3);
}
// 807213F: variable 's' is possibly undefined
// 807213F: variable 's_4' is possibly undefined
// 8072144: variable 'sa' is possibly undefined
// 807215B: variable 'newval' is possibly undefined

//----- (08072310) --------------------------------------------------------
bool __golang runtime_parkunlock_c(runtime_g *gp, void *lock)
{
  runtime_unlock((runtime_mutex_0 *)lock);
  return 1;
}

//----- (08072350) --------------------------------------------------------
void __golang runtime_park_m(runtime_g *gp)
{
  runtime_g *v1; // eax
  int v2; // eax
  runtime_m *m; // ecx
  runtime_g *v4; // eax
  runtime_m *v5; // ecx
  char v6; // bl
  runtime_m *v7; // eax
  char newval; // [esp+8h] [ebp-Ch]
  runtime_g *_g_; // [esp+10h] [ebp-4h]

  v1 = *(runtime_g **)(__readgsdword(0) - 4);
  _g_ = v1;
  if ( runtime_trace.enabled )
    runtime_traceGoPark(v1->m->waittraceev, v1->m->waittraceskip);
  runtime_casgstatus(gp, 2u, 4u);
  v2 = *(_DWORD *)(__readgsdword(0) - 4);
  *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(v2 + 24) + 84) + 24) = 0;
  *(_DWORD *)(*(_DWORD *)(v2 + 24) + 84) = 0;
  m = _g_->m;
  if ( m->waitunlockf )
  {
    newval = (*(int (__golang **)(runtime_g *, void *))m->waitunlockf)(gp, m->waitlock);
    v4 = _g_;
    v5 = _g_->m;
    v6 = newval;
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
    {
      runtime_writebarrierptr((uintptr *)&v5->waitunlockf, 0);
      v4 = _g_;
      v6 = newval;
    }
    else
    {
      v5->waitunlockf = 0;
    }
    v7 = v4->m;
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
    {
      runtime_writebarrierptr((uintptr *)&v7->waitlock, 0);
      v6 = newval;
    }
    else
    {
      v7->waitlock = 0;
    }
    if ( !v6 )
    {
      if ( runtime_trace.enabled )
        runtime_traceGoUnpark(gp, 2);
      runtime_casgstatus(gp, 4u, 1u);
      runtime_execute(gp, 1);
    }
  }
  runtime_schedule();
}

//----- (08072520) --------------------------------------------------------
void __golang runtime_goschedImpl(runtime_g *gp)
{
  int v1; // eax
  string s; // [esp+0h] [ebp-Ch]

  if ( (runtime_readgstatus(gp) & 0xFFFFEFFF) != 2 )
  {
    runtime_dumpgstatus(gp);
    s.str = (uint8 *)"bad g status";
    s.len = 12;
    runtime_throw(s);
    BUG();
  }
  runtime_casgstatus(gp, 2u, 1u);
  v1 = *(_DWORD *)(__readgsdword(0) - 4);
  *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(v1 + 24) + 84) + 24) = 0;
  *(_DWORD *)(*(_DWORD *)(v1 + 24) + 84) = 0;
  runtime_lock(&runtime_sched.lock);
  gp->schedlink = 0;
  if ( runtime_sched.runqtail )
    *(_DWORD *)(runtime_sched.runqtail + 104) = gp;
  else
    runtime_sched.runqhead = (runtime_guintptr)gp;
  runtime_sched.runqtail = (runtime_guintptr)gp;
  ++runtime_sched.runqsize;
  runtime_unlock(&runtime_sched.lock);
  runtime_schedule();
}

//----- (08072640) --------------------------------------------------------
void __golang runtime_gosched_m(runtime_g *gp)
{
  if ( runtime_trace.enabled )
    runtime_traceGoSched();
  runtime_goschedImpl(gp);
}

//----- (08072680) --------------------------------------------------------
void __golang runtime_gopreempt_m(runtime_g *gp)
{
  if ( runtime_trace.enabled )
    runtime_traceGoPreempt();
  runtime_goschedImpl(gp);
}

//----- (080726C0) --------------------------------------------------------
void __golang __noreturn runtime_goexit1()
{
  if ( runtime_trace.enabled )
    runtime_traceGoEnd();
  runtime_mcall();
}

//----- (08072700) --------------------------------------------------------
void __golang runtime_goexit0(runtime_g *gp)
{
  runtime_g *v1; // eax
  uintptr startpc; // ecx
  bool v3; // cl
  int v4; // ecx
  int v5; // edx
  int v6; // edx
  int v7; // edx
  string s; // [esp+0h] [ebp-28h]
  string sa; // [esp+0h] [ebp-28h]
  string sb; // [esp+0h] [ebp-28h]
  unsigned int v; // [esp+Ch] [ebp-1Ch]
  int v_4; // [esp+10h] [ebp-18h]
  uintptr *p_lockedm; // [esp+14h] [ebp-14h]
  uintptr *p_panic; // [esp+18h] [ebp-10h]
  uintptr *p_timer; // [esp+1Ch] [ebp-Ch]
  uintptr *p_labels; // [esp+20h] [ebp-8h]
  uintptr *dst; // [esp+24h] [ebp-4h]

  v_4 = *(_DWORD *)(__readgsdword(0) - 4);
  runtime_casgstatus(gp, 2u, 6u);
  v1 = gp;
  startpc = gp->startpc;
  if ( runtime_runfinqPC == startpc && !runtime_fingRunning )
  {
    v3 = 1;
  }
  else if ( runtime_bgsweepPC == startpc )
  {
    v3 = 1;
  }
  else
  {
    v3 = runtime_forcegchelperPC == startpc || runtime_timerprocPC == startpc || runtime_gcBgMarkWorkerPC == startpc;
  }
  if ( v3 )
  {
    runtime_internal_atomic_Xadd();
    v1 = gp;
  }
  if ( *(_DWORD *)&runtime_writeBarrier.enabled )
  {
    p_lockedm = (uintptr *)&v1->lockedm;
    runtime_writebarrierptr((uintptr *)&v1->m, 0);
    runtime_writebarrierptr(p_lockedm, 0);
    v1 = gp;
  }
  else
  {
    v1->m = 0;
    v1->lockedm = 0;
  }
  v4 = v_4;
  v5 = *(_DWORD *)(v_4 + 24);
  if ( *(_DWORD *)&runtime_writeBarrier.enabled )
  {
    runtime_writebarrierptr((uintptr *)(v5 + 188), 0);
    v1 = gp;
    v4 = v_4;
  }
  else
  {
    *(_DWORD *)(v5 + 188) = 0;
  }
  v1->paniconfault = 0;
  if ( *(_DWORD *)&runtime_writeBarrier.enabled )
  {
    p_panic = (uintptr *)&v1->_panic;
    runtime_writebarrierptr((uintptr *)&v1->_defer, 0);
    runtime_writebarrierptr(p_panic, 0);
    v1 = gp;
    v4 = v_4;
  }
  else
  {
    v1->_defer = 0;
    v1->_panic = 0;
  }
  v1->writebuf.len = 0;
  v1->writebuf.cap = 0;
  if ( *(_DWORD *)&runtime_writeBarrier.enabled )
  {
    runtime_writebarrierptr((uintptr *)&v1->writebuf, 0);
    v1 = gp;
    v4 = v_4;
  }
  else
  {
    v1->writebuf.array = 0;
  }
  v1->waitreason.len = 0;
  if ( *(_DWORD *)&runtime_writeBarrier.enabled )
  {
    dst = (uintptr *)&v1->param;
    p_labels = (uintptr *)&v1->labels;
    p_timer = (uintptr *)&v1->timer;
    runtime_writebarrierptr((uintptr *)&v1->waitreason, 0);
    runtime_writebarrierptr(dst, 0);
    runtime_writebarrierptr(p_labels, 0);
    runtime_writebarrierptr(p_timer, 0);
    v1 = gp;
    v4 = v_4;
  }
  else
  {
    v1->waitreason.str = 0;
    v1->param = 0;
    v1->labels = 0;
    v1->timer = 0;
  }
  v1->gcscanvalid = 1;
  v6 = *(_DWORD *)(__readgsdword(0) - 4);
  *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(v6 + 24) + 84) + 24) = 0;
  *(_DWORD *)(*(_DWORD *)(v6 + 24) + 84) = 0;
  v7 = *(_DWORD *)(v4 + 24);
  if ( (*(_DWORD *)(v7 + 452) & 0xFFFFFFFE) != 0 )
  {
    v = *(_DWORD *)(v7 + 452);
    runtime_printlock();
    s.str = (uint8 *)"invalid m->locked = ";
    s.len = 20;
    runtime_printstring(s);
    runtime_printint(v);
    sa.str = (uint8 *)"\n";
    sa.len = 1;
    runtime_printstring(sa);
    runtime_printunlock();
    sb.str = (uint8 *)"internal lockOSThread error";
    sb.len = 27;
    runtime_throw(sb);
    BUG();
  }
  *(_DWORD *)(v7 + 452) = 0;
  runtime_gfput(*(runtime_p **)(*(_DWORD *)(v4 + 24) + 92), v1);
  runtime_schedule();
}

//----- (08072AC0) --------------------------------------------------------
void __golang runtime_save(uintptr pc, uintptr sp_0)
{
  _DWORD *v2; // eax

  v2 = *(_DWORD **)(__readgsdword(0) - 4);
  v2[8] = pc;
  v2[7] = sp_0;
  v2[12] = 0;
  v2[11] = 0;
  v2[9] = v2;
  if ( v2[10] )
    runtime_badctxt();
}

//----- (08072B00) --------------------------------------------------------
void __golang runtime_reentersyscall(uintptr pc, uintptr sp_0)
{
  uintptr syscallsp; // ecx
  runtime_g *v3; // eax
  runtime_g *_g_; // [esp+Ch] [ebp-Ch]

  _g_ = *(runtime_g **)(__readgsdword(0) - 4);
  ++_g_->m->locks;
  _g_->stackguard0 = -1314;
  _g_->throwsplit = 1;
  runtime_save(pc, sp_0);
  _g_->syscallsp = sp_0;
  _g_->syscallpc = pc;
  runtime_casgstatus(_g_, 2u, 3u);
  syscallsp = _g_->syscallsp;
  if ( syscallsp < _g_->stack.lo || _g_->stack.hi < syscallsp )
    runtime_systemstack();
  if ( runtime_trace.enabled )
  {
    runtime_systemstack();
    runtime_save(pc, sp_0);
  }
  if ( runtime_internal_atomic_Load(&runtime_sched.sysmonwait) )
  {
    runtime_systemstack();
    runtime_save(pc, sp_0);
  }
  v3 = _g_;
  if ( *(_DWORD *)(_g_->m->p + 2408) )
  {
    runtime_systemstack();
    runtime_save(pc, sp_0);
    v3 = _g_;
  }
  v3->m->syscalltick = *(_DWORD *)(v3->m->p + 20);
  v3->sysblocktraced = 1;
  v3->m->mcache = 0;
  *(_DWORD *)(v3->m->p + 48) = 0;
  runtime_internal_atomic_Store();
  if ( runtime_sched.gcwaiting )
  {
    runtime_systemstack();
    runtime_save(pc, sp_0);
  }
  _g_->stackguard0 = -1314;
  --_g_->m->locks;
}

//----- (08072D00) --------------------------------------------------------
void __golang runtime_entersyscall(int32 dummy)
{
  uintptr sp_0; // [esp+4h] [ebp-4h]

  runtime_getcallerpc();
  runtime_reentersyscall(sp_0, (uintptr)&dummy);
}
// 8072D1E: variable 'sp_0' is possibly undefined

//----- (08072D30) --------------------------------------------------------
void __golang runtime_entersyscall_sysmon()
{
  runtime_lock(&runtime_sched.lock);
  if ( runtime_internal_atomic_Load(&runtime_sched.sysmonwait) )
  {
    runtime_internal_atomic_Store();
    runtime_notewakeup(&runtime_sched.sysmonnote);
  }
  runtime_unlock(&runtime_sched.lock);
}

//----- (08072DB0) --------------------------------------------------------
void __golang runtime_entersyscall_gcwait()
{
  int32 v0; // eax
  char v1; // [esp+Ch] [ebp-8h]
  runtime_p *pp; // [esp+10h] [ebp-4h]

  pp = *(runtime_p **)(*(_DWORD *)(*(_DWORD *)(__readgsdword(0) - 4) + 24) + 92);
  runtime_lock(&runtime_sched.lock);
  if ( runtime_sched.stopwait > 0 )
  {
    runtime_internal_atomic_Cas();
    if ( v1 )
    {
      if ( runtime_trace.enabled )
      {
        runtime_traceGoSysBlock(pp);
        runtime_traceProcStop(pp);
      }
      ++pp->syscalltick;
      v0 = runtime_sched.stopwait--;
      if ( v0 == 1 )
        runtime_notewakeup(&runtime_sched.stopnote);
    }
  }
  runtime_unlock(&runtime_sched.lock);
}
// 8072E32: variable 'v1' is possibly undefined

//----- (08072EA0) --------------------------------------------------------
void __golang runtime_entersyscallblock(int32 dummy)
{
  uintptr syscallsp; // ecx
  uintptr v2; // ecx
  uintptr sp_0; // [esp+4h] [ebp-34h]
  uintptr sp_0a; // [esp+4h] [ebp-34h]
  runtime_g *_g_; // [esp+14h] [ebp-24h]

  _g_ = *(runtime_g **)(__readgsdword(0) - 4);
  ++_g_->m->locks;
  _g_->throwsplit = 1;
  _g_->stackguard0 = -1314;
  _g_->m->syscalltick = *(_DWORD *)(_g_->m->p + 20);
  _g_->sysblocktraced = 1;
  ++*(_DWORD *)(_g_->m->p + 20);
  runtime_getcallerpc();
  runtime_save(sp_0, (uintptr)&dummy);
  _g_->syscallsp = _g_->sched.sp;
  _g_->syscallpc = _g_->sched.pc;
  syscallsp = _g_->syscallsp;
  if ( syscallsp < _g_->stack.lo || _g_->stack.hi < syscallsp )
  {
    ((void (*)(void))loc_808FD8B)();
    runtime_systemstack();
  }
  runtime_casgstatus(_g_, 2u, 3u);
  v2 = _g_->syscallsp;
  if ( v2 < _g_->stack.lo || _g_->stack.hi < v2 )
    runtime_systemstack();
  runtime_systemstack();
  runtime_getcallerpc();
  runtime_save(sp_0a, (uintptr)&dummy);
  --_g_->m->locks;
}
// 8072F0C: variable 'sp_0' is possibly undefined
// 8072FE4: variable 'sp_0a' is possibly undefined

//----- (08073020) --------------------------------------------------------
void __golang runtime_entersyscallblock_handoff()
{
  runtime_p *pp; // [esp+0h] [ebp-4h]

  if ( runtime_trace.enabled )
  {
    runtime_traceGoSysCall();
    runtime_traceGoSysBlock(*(runtime_p **)(*(_DWORD *)(*(_DWORD *)(__readgsdword(0) - 4) + 24) + 92));
  }
  pp = runtime_releasep();
  runtime_handoffp(pp);
}

//----- (08073080) --------------------------------------------------------
void __golang runtime_exitsyscall(int32 dummy)
{
  runtime_g *v1; // eax
  runtime_g *v2; // eax
  runtime_g *v3; // edx
  runtime_m *m; // ecx
  runtime_puintptr v5; // edx
  runtime_g *gp; // [esp+0h] [ebp-14h]
  string gpa; // [esp+0h] [ebp-14h]
  string gpb; // [esp+0h] [ebp-14h]
  uint32 oldval; // [esp+4h] [ebp-10h]
  runtime_g *_g_; // [esp+Ch] [ebp-8h]
  runtime_puintptr p; // [esp+10h] [ebp-4h]

  v1 = *(runtime_g **)(__readgsdword(0) - 4);
  _g_ = v1;
  ++v1->m->locks;
  if ( (unsigned int)&dummy > v1->syscallsp )
  {
    gp = (runtime_g *)&off_80E7BD8;
    runtime_systemstack();
    v1 = _g_;
  }
  LODWORD(v1->waitsince) = 0;
  HIDWORD(v1->waitsince) = 0;
  p = v1->m->p;
  LOBYTE(gp) = runtime_exitsyscallfast();
  if ( (_BYTE)gp )
  {
    m = _g_->m;
    if ( !m->mcache )
    {
      gpb.str = (uint8 *)"lost mcache";
      gpb.len = 11;
      runtime_throw(gpb);
      BUG();
    }
    if ( runtime_trace.enabled )
    {
      v5 = m->p;
      if ( p != v5 || m->syscalltick != *(_DWORD *)(v5 + 20) )
        runtime_systemstack();
    }
    ++*(_DWORD *)(_g_->m->p + 20);
    runtime_casgstatus(_g_, 3u, 2u);
    _g_->syscallsp = 0;
    --_g_->m->locks;
    if ( _g_->preempt )
      _g_->stackguard0 = -1314;
    else
      _g_->stackguard0 = _g_->stack.lo + 880;
    _g_->throwsplit = 0;
  }
  else
  {
    v2 = _g_;
    LODWORD(_g_->sysexitticks) = 0;
    HIDWORD(_g_->sysexitticks) = 0;
    if ( runtime_trace.enabled )
    {
      while ( p && *(_DWORD *)(p + 20) == v2->m->syscalltick )
      {
        runtime_osyield();
        v2 = _g_;
      }
      runtime_cputicks();
      v3 = _g_;
      LODWORD(_g_->sysexitticks) = gp;
      HIDWORD(_g_->sysexitticks) = oldval;
    }
    else
    {
      v3 = _g_;
    }
    --v3->m->locks;
    runtime_mcall();
    if ( !_g_->m->mcache )
    {
      gpa.str = (uint8 *)"lost mcache";
      gpa.len = 11;
      runtime_throw(gpa);
      BUG();
    }
    _g_->syscallsp = 0;
    ++*(_DWORD *)(_g_->m->p + 20);
    _g_->throwsplit = 0;
  }
}
// 8073129: variable 'gp' is possibly undefined
// 807312C: variable 'oldval' is possibly undefined
// 80E7BD8: using guessed type void (__golang __noreturn *off_80E7BD8)();

//----- (08073280) --------------------------------------------------------
bool __golang runtime_exitsyscallfast()
{
  runtime_g *v0; // eax
  runtime_puintptr p; // ecx
  runtime_m *m; // ecx
  int v3; // edx
  char v4; // [esp+Ch] [ebp-1Ch]
  bool ok; // [esp+13h] [ebp-15h] BYREF
  runtime_g *_g_; // [esp+14h] [ebp-14h]
  void (__golang *v7)(); // [esp+18h] [ebp-10h]
  bool *p_ok; // [esp+1Ch] [ebp-Ch]
  int v9; // [esp+20h] [ebp-8h]
  runtime_g *v10; // [esp+24h] [ebp-4h]
  bool _r0; // [esp+2Ch] [ebp+4h]

  v0 = *(runtime_g **)(__readgsdword(0) - 4);
  if ( runtime_sched.stopwait == 0x7FFFFFFF )
  {
    v0->m->mcache = 0;
    v0->m->p = 0;
    return 0;
  }
  else
  {
    p = v0->m->p;
    if ( p && *(_DWORD *)(p + 8) == 2 )
    {
      _g_ = v0;
      runtime_internal_atomic_Cas();
      if ( v4 )
      {
        runtime_exitsyscallfast_reacquired();
        return 1;
      }
      v0 = _g_;
    }
    m = v0->m;
    v3 = m->p;
    m->mcache = 0;
    v0->m->p = 0;
    _r0 = 0;
    if ( runtime_sched.pidle )
    {
      ok = 0;
      v7 = runtime_exitsyscallfast_func1;
      p_ok = &ok;
      v9 = v3;
      v10 = v0;
      runtime_systemstack();
      if ( ok )
        return 1;
    }
  }
  return _r0;
}
// 8073344: variable 'v4' is possibly undefined

//----- (08073380) --------------------------------------------------------
void __golang runtime_exitsyscallfast_reacquired()
{
  runtime_g *v0; // eax
  runtime_g *_g_; // [esp+4h] [ebp-Ch]

  v0 = *(runtime_g **)(__readgsdword(0) - 4);
  v0->m->mcache = *(runtime_mcache **)(v0->m->p + 52);
  *(_DWORD *)(v0->m->p + 48) = v0->m;
  if ( v0->m->syscalltick != *(_DWORD *)(v0->m->p + 20) )
  {
    if ( runtime_trace.enabled )
    {
      _g_ = v0;
      runtime_systemstack();
      v0 = _g_;
    }
    ++*(_DWORD *)(v0->m->p + 20);
  }
}

//----- (08073410) --------------------------------------------------------
bool __golang runtime_exitsyscallfast_pidle()
{
  runtime_p *_p_; // [esp+8h] [ebp-4h]

  runtime_lock(&runtime_sched.lock);
  _p_ = runtime_pidleget();
  if ( _p_ && runtime_internal_atomic_Load(&runtime_sched.sysmonwait) )
  {
    runtime_internal_atomic_Store();
    runtime_notewakeup(&runtime_sched.sysmonnote);
  }
  runtime_unlock(&runtime_sched.lock);
  if ( !_p_ )
    return 0;
  runtime_acquirep(_p_);
  return 1;
}

//----- (080734D0) --------------------------------------------------------
void __golang runtime_exitsyscall0(runtime_g *gp)
{
  int v1; // eax
  runtime_p *_p_; // [esp+Ch] [ebp-8h]
  runtime_g *_g_; // [esp+10h] [ebp-4h]

  _g_ = *(runtime_g **)(__readgsdword(0) - 4);
  runtime_casgstatus(gp, 3u, 1u);
  v1 = *(_DWORD *)(__readgsdword(0) - 4);
  *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(v1 + 24) + 84) + 24) = 0;
  *(_DWORD *)(*(_DWORD *)(v1 + 24) + 84) = 0;
  runtime_lock(&runtime_sched.lock);
  _p_ = runtime_pidleget();
  if ( _p_ )
  {
    if ( runtime_internal_atomic_Load(&runtime_sched.sysmonwait) )
    {
      runtime_internal_atomic_Store();
      runtime_notewakeup(&runtime_sched.sysmonnote);
    }
  }
  else
  {
    gp->schedlink = 0;
    if ( runtime_sched.runqtail )
      *(_DWORD *)(runtime_sched.runqtail + 104) = gp;
    else
      runtime_sched.runqhead = (runtime_guintptr)gp;
    runtime_sched.runqtail = (runtime_guintptr)gp;
    ++runtime_sched.runqsize;
  }
  runtime_unlock(&runtime_sched.lock);
  if ( _p_ )
  {
    runtime_acquirep(_p_);
    runtime_execute(gp, 0);
  }
  if ( _g_->m->lockedg )
  {
    runtime_stoplockedm();
    runtime_execute(gp, 0);
  }
  runtime_stopm();
  runtime_schedule();
}

//----- (08073670) --------------------------------------------------------
runtime_g *__golang runtime_malg(int32 stacksize)
{
  runtime_g *v1; // eax
  runtime_g *v2; // [esp+4h] [ebp-14h]

  v2 = (runtime_g *)runtime_newobject((runtime__type_0 *)&stru_80DD7C0);
  v1 = v2;
  if ( stacksize >= 0 )
  {
    runtime_round2(stacksize);
    runtime_systemstack();
    v1 = v2;
    v2->stackguard0 = v2->stack.lo + 880;
    v2->stackguard1 = -1;
  }
  return v1;
}

//----- (08073700) --------------------------------------------------------
void __golang runtime_newproc(int32 siz, runtime_funcval *fn)
{
  runtime_getcallerpc();
  ((void (__golang *)(int32 *))loc_808FD8B)(&siz);
  runtime_systemstack();
}

//----- (08073770) --------------------------------------------------------
runtime_g *__golang runtime_newproc1(runtime_funcval *fn, uint8 *argp, int32 narg, int32 nret, uintptr callerpc)
{
  runtime_g *v5; // eax
  runtime_g *v6; // eax
  runtime_g *v7; // ecx
  uintptr *v8; // edx
  runtime_funcval *v9; // ebx
  uintptr v10; // ebp
  runtime_g *curg; // edx
  uintptr labels; // edx
  uintptr startpc; // edx
  bool v14; // dl
  runtime_p *v15; // eax
  int goidcache_high; // edx
  runtime_g *v17; // ebx
  int goidcache; // ecx
  int v19; // edx
  string _p_; // [esp+0h] [ebp-38h]
  string _p_a; // [esp+0h] [ebp-38h]
  string _p_b; // [esp+0h] [ebp-38h]
  string _p_c; // [esp+0h] [ebp-38h]
  runtime_funcInfo_0 oldval; // [esp+4h] [ebp-34h]
  runtime_bitvector_0 newval; // [esp+8h] [ebp-30h]
  __int64 stkmap; // [esp+Ch] [ebp-2Ch]
  runtime_stackmap *stkmapa; // [esp+Ch] [ebp-2Ch]
  unsigned __int32 spArg; // [esp+14h] [ebp-24h]
  runtime_g *newg; // [esp+1Ch] [ebp-1Ch]
  runtime_g *gp; // [esp+20h] [ebp-18h]
  runtime_g *_g_; // [esp+24h] [ebp-14h]
  runtime_p *p; // [esp+2Ch] [ebp-Ch]

  v5 = *(runtime_g **)(__readgsdword(0) - 4);
  if ( !fn )
  {
    v5->m->throwing = -1;
    _p_c.str = (uint8 *)"go of nil func value";
    _p_c.len = 20;
    runtime_throw(_p_c);
    BUG();
  }
  ++v5->m->locks;
  if ( (int)((nret + narg + 7) & 0xFFFFFFF8) >= 2028 )
  {
    _p_b.str = (uint8 *)"newproc: function arguments too large for new goroutine";
    _p_b.len = 55;
    runtime_throw(_p_b);
    BUG();
  }
  _g_ = v5;
  p = (runtime_p *)v5->m->p;
  v6 = runtime_gfget(p);
  if ( !v6 )
  {
    newg = runtime_malg(2048);
    runtime_casgstatus(newg, 0, 6u);
    runtime_allgadd(newg);
    v6 = newg;
  }
  if ( !v6->stack.hi )
  {
    _p_a.str = (uint8 *)"newproc1: newg missing stack";
    _p_a.len = 28;
    runtime_throw(_p_a);
    BUG();
  }
  gp = v6;
  if ( runtime_readgstatus(v6) != 6 )
  {
    _p_.str = (uint8 *)"newproc1: new g is not Gdead";
    _p_.len = 28;
    runtime_throw(_p_);
    BUG();
  }
  spArg = gp->stack.hi - (((nret + narg + 7) & 0xFFFFFFF8) + 16);
  if ( narg > 0 )
  {
    runtime_memmove();
    if ( runtime_writeBarrier.needed && !_g_->m->curg->gcscandone )
    {
      oldval = runtime_findfunc(fn->fn);
      stkmapa = (runtime_stackmap *)runtime_funcdata(oldval, 0);
      newval = runtime_stackmapdata(stkmapa, 0);
      runtime_bulkBarrierBitmap(spArg, spArg, narg, 0, newval.bytedata);
    }
  }
  runtime_memclrNoHeapPointers();
  v7 = gp;
  gp->sched.sp = spArg;
  gp->stktopsp = spArg;
  gp->sched.pc = (uintptr)runtime_goexit + 1;
  gp->sched.g = (runtime_guintptr)gp;
  v8 = (uintptr *)(gp->sched.sp - 4);
  v9 = fn;
  v10 = fn->fn;
  *v8 = gp->sched.pc;
  gp->sched.sp = (uintptr)v8;
  gp->sched.pc = v10;
  if ( *(_DWORD *)&runtime_writeBarrier.enabled )
  {
    runtime_writebarrierptr((uintptr *)&gp->sched.ctxt, (uintptr)fn);
    v7 = gp;
    v9 = fn;
  }
  else
  {
    gp->sched.ctxt = fn;
  }
  v7->gopc = callerpc;
  v7->startpc = v9->fn;
  curg = _g_->m->curg;
  if ( curg )
  {
    labels = (uintptr)curg->labels;
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
    {
      runtime_writebarrierptr((uintptr *)&v7->labels, labels);
      v7 = gp;
    }
    else
    {
      v7->labels = (void *)labels;
    }
  }
  startpc = v7->startpc;
  if ( runtime_runfinqPC == startpc && !runtime_fingRunning )
  {
    v14 = 1;
  }
  else if ( runtime_bgsweepPC == startpc )
  {
    v14 = 1;
  }
  else
  {
    v14 = runtime_forcegchelperPC == startpc || runtime_timerprocPC == startpc || runtime_gcBgMarkWorkerPC == startpc;
  }
  if ( v14 )
  {
    runtime_internal_atomic_Xadd();
    v7 = gp;
  }
  v7->gcscanvalid = 0;
  runtime_casgstatus(v7, 6u, 1u);
  v15 = p;
  if ( LODWORD(p->goidcache) == LODWORD(p->goidcacheend) && HIDWORD(p->goidcache) == HIDWORD(p->goidcacheend) )
  {
    HIDWORD(stkmap) = runtime_internal_atomic_Xadd64(&runtime_sched.goidgen, 16LL);
    HIDWORD(p->goidcache) = HIDWORD(stkmap);
    LODWORD(p->goidcache) = stkmap - 15;
    HIDWORD(p->goidcache) = __CFADD__((_DWORD)stkmap, -15) + HIDWORD(stkmap) - 1;
    p->goidcacheend = stkmap + 1;
    v15 = p;
  }
  goidcache_high = HIDWORD(v15->goidcache);
  v17 = gp;
  LODWORD(gp->goid) = v15->goidcache;
  HIDWORD(gp->goid) = goidcache_high;
  goidcache = v15->goidcache;
  v19 = HIDWORD(v15->goidcache);
  LODWORD(v15->goidcache) = goidcache + 1;
  HIDWORD(v15->goidcache) = __CFADD__(goidcache, 1) + v19;
  if ( runtime_trace.enabled )
  {
    runtime_traceGoCreate(gp, gp->startpc);
    v15 = p;
    v17 = gp;
  }
  runtime_runqput(v15, v17, 1);
  if ( runtime_internal_atomic_Load(&runtime_sched.npidle)
    && !runtime_internal_atomic_Load(&runtime_sched.nmspinning)
    && runtime_mainStarted )
  {
    runtime_wakep();
  }
  if ( !--_g_->m->locks && _g_->preempt )
    _g_->stackguard0 = -1314;
  return gp;
}
// 8073770: could not find valid save-restore pair for ebx
// 8073A83: variable 'stkmap' is possibly undefined

//----- (08073CD0) --------------------------------------------------------
void __golang runtime_gfput(runtime_p *_p_, runtime_g *gp)
{
  runtime_g *v2; // eax
  runtime_p *v3; // ecx
  int v4; // eax
  int32 gfreecnt; // ecx
  runtime_g *gfree; // ecx
  runtime_g *schedlink; // ebx
  string stk; // [esp+0h] [ebp-10h]
  runtime_g *gpa; // [esp+18h] [ebp+8h]

  if ( runtime_readgstatus(gp) != 6 )
  {
    stk.str = (uint8 *)"gfput: bad status (not Gdead)";
    stk.len = 29;
    runtime_throw(stk);
    BUG();
  }
  v2 = gp;
  if ( gp->stack.hi - gp->stack.lo != 2048 )
  {
    runtime_stackfree(gp->stack);
    v2 = gp;
    gp->stack.lo = 0;
    gp->stack.hi = 0;
    gp->stackguard0 = 0;
  }
  v3 = _p_;
  v2->schedlink = (runtime_guintptr)_p_->gfree;
  if ( *(_DWORD *)&runtime_writeBarrier.enabled )
  {
    runtime_writebarrierptr((uintptr *)&_p_->gfree, (uintptr)v2);
    v3 = _p_;
  }
  else
  {
    _p_->gfree = v2;
  }
  v4 = v3->gfreecnt + 1;
  v3->gfreecnt = v4;
  if ( v4 >= 64 )
  {
    runtime_lock(&runtime_sched.gflock);
    while ( 1 )
    {
      gfreecnt = _p_->gfreecnt;
      if ( gfreecnt < 32 )
        break;
      _p_->gfreecnt = gfreecnt - 1;
      gfree = _p_->gfree;
      schedlink = (runtime_g *)gfree->schedlink;
      if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      {
        gpa = _p_->gfree;
        runtime_writebarrierptr((uintptr *)&_p_->gfree, (uintptr)schedlink);
        gfree = gpa;
      }
      else
      {
        _p_->gfree = schedlink;
      }
      if ( gfree->stack.lo )
      {
        gfree->schedlink = (runtime_guintptr)runtime_sched.gfreeStack;
        if ( *(_DWORD *)&runtime_writeBarrier.enabled )
          runtime_writebarrierptr((uintptr *)&runtime_sched.gfreeStack, (uintptr)gfree);
        else
          runtime_sched.gfreeStack = gfree;
      }
      else
      {
        gfree->schedlink = (runtime_guintptr)runtime_sched.gfreeNoStack;
        if ( *(_DWORD *)&runtime_writeBarrier.enabled )
          runtime_writebarrierptr((uintptr *)&runtime_sched.gfreeNoStack, (uintptr)gfree);
        else
          runtime_sched.gfreeNoStack = gfree;
      }
      ++runtime_sched.ngfree;
    }
    runtime_unlock(&runtime_sched.gflock);
  }
}

//----- (08073ED0) --------------------------------------------------------
runtime_g *__golang runtime_gfget(runtime_p *_p_)
{
  runtime_p *v1; // eax
  runtime_g *src; // ecx
  runtime_p *v3; // eax
  runtime_g *gfree; // ecx
  bool v5; // zf
  runtime_g *schedlink; // ebp
  runtime_g *gp; // [esp+8h] [ebp-18h]
  runtime_g *gfreeNoStack; // [esp+Ch] [ebp-14h]
  runtime_g *gfreeStack; // [esp+10h] [ebp-10h]

  while ( 1 )
  {
    v3 = _p_;
    gfree = _p_->gfree;
    v5 = gfree == 0;
    if ( gfree )
      break;
    if ( !runtime_sched.gfreeStack && !runtime_sched.gfreeNoStack )
    {
      v5 = 1;
      break;
    }
    runtime_lock(&runtime_sched.gflock);
    while ( 1 )
    {
      v1 = _p_;
      if ( _p_->gfreecnt >= 32 )
        break;
      src = runtime_sched.gfreeStack;
      if ( runtime_sched.gfreeStack )
      {
        if ( *(_DWORD *)&runtime_writeBarrier.enabled )
        {
          gfreeStack = runtime_sched.gfreeStack;
          runtime_writebarrierptr((uintptr *)&runtime_sched.gfreeStack, runtime_sched.gfreeStack->schedlink);
          v1 = _p_;
          src = gfreeStack;
        }
        else
        {
          runtime_sched.gfreeStack = (runtime_g *)runtime_sched.gfreeStack->schedlink;
        }
      }
      else
      {
        src = runtime_sched.gfreeNoStack;
        if ( !runtime_sched.gfreeNoStack )
          break;
        if ( *(_DWORD *)&runtime_writeBarrier.enabled )
        {
          gfreeNoStack = runtime_sched.gfreeNoStack;
          runtime_writebarrierptr((uintptr *)&runtime_sched.gfreeNoStack, runtime_sched.gfreeNoStack->schedlink);
          v1 = _p_;
          src = gfreeNoStack;
        }
        else
        {
          runtime_sched.gfreeNoStack = (runtime_g *)runtime_sched.gfreeNoStack->schedlink;
        }
      }
      ++v1->gfreecnt;
      --runtime_sched.ngfree;
      src->schedlink = (runtime_guintptr)v1->gfree;
      if ( *(_DWORD *)&runtime_writeBarrier.enabled )
        runtime_writebarrierptr((uintptr *)&_p_->gfree, (uintptr)src);
      else
        v1->gfree = src;
    }
    runtime_unlock(&runtime_sched.gflock);
  }
  if ( !v5 )
  {
    gp = _p_->gfree;
    schedlink = (runtime_g *)gfree->schedlink;
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
    {
      runtime_writebarrierptr((uintptr *)&_p_->gfree, (uintptr)schedlink);
      v3 = _p_;
      gfree = gp;
    }
    else
    {
      _p_->gfree = schedlink;
    }
    --v3->gfreecnt;
    if ( !gfree->stack.lo )
    {
      runtime_systemstack();
      gfree = gp;
      gp->stackguard0 = gp->stack.lo + 880;
    }
  }
  return gfree;
}

//----- (080740B0) --------------------------------------------------------
void __golang runtime_gfpurge(runtime_p *_p_)
{
  int32 gfreecnt; // ecx
  runtime_g *src; // ecx
  runtime_g *schedlink; // ebp
  runtime_g *gp; // [esp+8h] [ebp-8h]

  runtime_lock(&runtime_sched.gflock);
  while ( 1 )
  {
    gfreecnt = _p_->gfreecnt;
    if ( !gfreecnt )
      break;
    _p_->gfreecnt = gfreecnt - 1;
    src = _p_->gfree;
    schedlink = (runtime_g *)src->schedlink;
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
    {
      gp = _p_->gfree;
      runtime_writebarrierptr((uintptr *)&_p_->gfree, (uintptr)schedlink);
      src = gp;
    }
    else
    {
      _p_->gfree = schedlink;
    }
    if ( src->stack.lo )
    {
      src->schedlink = (runtime_guintptr)runtime_sched.gfreeStack;
      if ( *(_DWORD *)&runtime_writeBarrier.enabled )
        runtime_writebarrierptr((uintptr *)&runtime_sched.gfreeStack, (uintptr)src);
      else
        runtime_sched.gfreeStack = src;
    }
    else
    {
      src->schedlink = (runtime_guintptr)runtime_sched.gfreeNoStack;
      if ( *(_DWORD *)&runtime_writeBarrier.enabled )
        runtime_writebarrierptr((uintptr *)&runtime_sched.gfreeNoStack, (uintptr)src);
      else
        runtime_sched.gfreeNoStack = src;
    }
    ++runtime_sched.ngfree;
  }
  runtime_unlock(&runtime_sched.gflock);
}

//----- (080741E0) --------------------------------------------------------
void __golang runtime_unlockOSThread()
{
  runtime_g *v0; // eax
  runtime_g *v1; // eax
  runtime_m *m; // ecx
  runtime_g *_g_; // [esp+8h] [ebp-8h]
  runtime_g *_g__0; // [esp+Ch] [ebp-4h]

  v0 = *(runtime_g **)(__readgsdword(0) - 4);
  if ( v0->m->locked < 2 )
  {
    _g__0 = v0;
    runtime_systemstack();
    v0 = _g__0;
  }
  v0->m->locked -= 2;
  v1 = *(runtime_g **)(__readgsdword(0) - 4);
  m = v1->m;
  if ( !m->locked )
  {
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
    {
      _g_ = v1;
      runtime_writebarrierptr((uintptr *)&m->lockedg, 0);
      v1 = _g_;
    }
    else
    {
      m->lockedg = 0;
    }
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr((uintptr *)&v1->lockedm, 0);
    else
      v1->lockedm = 0;
  }
}

//----- (080742C0) --------------------------------------------------------
void __golang __noreturn runtime_badunlockosthread()
{
  string s; // [esp+0h] [ebp-8h]

  s.str = (uint8 *)"runtime: internal error: misuse of lockOSThread/unlockOSThread";
  s.len = 62;
  runtime_throw(s);
  BUG();
}

//----- (08074300) --------------------------------------------------------
void __golang runtime__System()
{
  runtime__System();
}

//----- (08074320) --------------------------------------------------------
void __golang runtime__ExternalCode()
{
  runtime__ExternalCode();
}

//----- (08074340) --------------------------------------------------------
void __golang runtime__LostExternalCode()
{
  runtime__LostExternalCode();
}

//----- (08074360) --------------------------------------------------------
void __golang runtime__GC()
{
  runtime__GC();
}

//----- (08074380) --------------------------------------------------------
void __golang runtime_sigprof(uintptr pc, uintptr sp_0, uintptr lr, runtime_g *gp, runtime_m *mp)
{
  int v5; // ecx
  uintptr sp0; // ebx
  char v7; // dl
  runtime_g *curg; // eax
  runtime_m *v9; // eax
  uintptr (*cgoCallers)[32]; // ecx
  unsigned int i; // edx
  bool v12; // cc
  unsigned int v13; // ecx
  __int32 v14; // eax
  char *v15; // ecx
  unsigned int v16; // eax
  __uintptr lr0; // [esp+8h] [ebp-140h]
  __int32 cgoOff; // [esp+2Ch] [ebp-11Ch]
  uintptr stk[64]; // [esp+30h] [ebp-118h] BYREF
  interface_{} f; // [esp+130h] [ebp-18h]
  interface_{} f_0; // [esp+138h] [ebp-10h]
  interface_{} f_1; // [esp+140h] [ebp-8h]

  while ( (unsigned int)&stk[20] <= *(_DWORD *)(*(_DWORD *)(__readgsdword(0) - 4) + 8) )
    runtime_morestack_noctxt();
  ((void (*)(void))loc_808FD8A)();
  if ( !runtime_prof.hz )
    return;
  v5 = *(_DWORD *)(*(_DWORD *)(__readgsdword(0) - 4) + 24);
  ++*(_DWORD *)(v5 + 104);
  if ( gp )
  {
    sp0 = sp_0;
    if ( sp_0 >= gp->stack.lo && gp->stack.hi >= sp_0 )
    {
      runtime_setsSP(pc);
      sp0 = sp_0;
    }
  }
  else
  {
    sp0 = sp_0;
  }
  ((void (*)(void))loc_808FD50)();
  if ( mp->ncgo > 0 )
  {
    curg = mp->curg;
    if ( curg )
    {
      if ( curg->syscallpc && curg->syscallsp )
      {
        if ( runtime_internal_atomic_Load(&mp->cgoCallersUse) )
        {
          v9 = mp;
        }
        else
        {
          v9 = mp;
          cgoCallers = mp->cgoCallers;
          if ( cgoCallers && (*cgoCallers)[0] )
          {
            for ( i = 0; ; ++i )
            {
              v12 = i <= 0x20;
              if ( (int)i >= 32 )
                break;
              if ( i >= 0x20 )
                runtime_panicindex();
              if ( !(*cgoCallers)[i] )
              {
                v12 = i <= 0x20;
                break;
              }
            }
            if ( !v12 )
              runtime_panicslice();
            cgoOff = i;
            runtime_memmove();
            v9 = mp;
            (*mp->cgoCallers)[0] = 0;
            v13 = cgoOff;
            goto LABEL_20;
          }
        }
        v13 = 0;
LABEL_20:
        if ( v13 >= 0x40 )
          runtime_panicindex();
        v14 = runtime_gentraceback(
                v9->curg->syscallpc,
                v9->curg->syscallsp,
                0,
                v9->curg,
                0,
                &stk[v13],
                64 - v13,
                0,
                0,
                0);
        goto LABEL_22;
      }
    }
  }
  if ( v7 )
    v14 = runtime_gentraceback(pc, sp0, lr, gp, 0, stk, 64, 0, 0, 6u);
  else
    v14 = 0;
LABEL_22:
  if ( v14 <= 0 )
  {
    v15 = (char *)pc;
    if ( pc > runtime_firstmoduledata.etext )
    {
      f._type = (runtime__type_0 *)&unk_80CA340;
      f.data = off_80E7B6C;
      v15 = (char *)runtime__ExternalCode + 1;
    }
    stk[0] = (uintptr)v15;
    if ( mp->preemptoff.len || mp->helpgc )
    {
      f_0._type = (runtime__type_0 *)&unk_80CA340;
      f_0.data = off_80E7B70;
      stk[1] = (uintptr)runtime__GC + 1;
    }
    else
    {
      f_1._type = (runtime__type_0 *)&unk_80CA340;
      f_1.data = &off_80E7B78;
      stk[1] = (uintptr)runtime__System + 1;
    }
    v14 = 2;
  }
  if ( runtime_prof.hz )
  {
    if ( (unsigned int)v14 > 0x40 )
      runtime_panicslice();
    lr0.array = stk;
    *(_QWORD *)&lr0.len = (unsigned int)v14 | 0x4000000000LL;
    runtime___ptr_cpuProfile__add(&runtime_cpuprof, gp, lr0);
  }
  v16 = __readgsdword(0);
  --*(_DWORD *)(*(_DWORD *)(*(_DWORD *)(v16 - 4) + 24) + 104);
}
// 807467B: variable 'v7' is possibly undefined
// 80E7B6C: using guessed type int (__golang *off_80E7B6C[4])();
// 80E7B70: using guessed type int (__golang *off_80E7B70[3])();
// 80E7B78: using guessed type int (__golang *off_80E7B78)();

//----- (08074780) --------------------------------------------------------
void __golang runtime_sigprofNonGoPC(uintptr pc)
{
  __uintptr stk; // [esp+4h] [ebp-1Ch]
  __uintptr v2; // [esp+10h] [ebp-10h] BYREF
  int (__golang **v3)(); // [esp+1Ch] [ebp-4h]

  if ( runtime_prof.hz )
  {
    v2.cap = (__int32)&unk_80CA340;
    v3 = off_80E7B6C;
    v2.array = (uintptr *)pc;
    v2.len = (__int32)runtime__ExternalCode + 1;
    stk.array = (uintptr *)&v2;
    *(_QWORD *)&stk.len = 0x200000002LL;
    runtime___ptr_cpuProfile__addNonGo(&runtime_cpuprof, stk);
  }
}
// 80E7B6C: using guessed type int (__golang *off_80E7B6C[4])();

//----- (08074800) --------------------------------------------------------
bool __golang runtime_setsSP(uintptr pc)
{
  uintptr entry; // eax
  runtime__func *func; // [esp+4h] [ebp-8h]

  func = runtime_findfunc(pc)._func;
  if ( !func )
    return 1;
  entry = func->entry;
  return runtime_gogoPC == func->entry
      || runtime_systemstackPC == entry
      || runtime_mcallPC == entry
      || runtime_morestackPC == entry;
}

//----- (08074880) --------------------------------------------------------
runtime_p *__golang runtime_procresize(int32 nprocs)
{
  int32 v1; // edx
  int32 j; // eax
  int32 v3; // ecx
  runtime_p *v4; // ebp
  runtime_mcache *v5; // esi
  _DWORD *p_key; // eax
  int k; // edx
  int v8; // ebx
  uintptr *v9; // ebp
  int v10; // edi
  uintptr src; // edx
  signed __int32 v12; // eax
  uint32 runqtail; // edi
  runtime_guintptr v14; // esi
  runtime_guintptr runnext; // esi
  runtime_g *gcBgMarkWorker; // esi
  runtime_p *v17; // eax
  uintptr sudogbuf; // ecx
  int v19; // ecx
  __int32 v20; // eax
  int v21; // ecx
  runtime_p *v22; // edx
  runtime_p *v23; // ebp
  runtime_g *v24; // ecx
  _DWORD *p; // edx
  bool v26; // zf
  int v27; // edx
  runtime_p *v28; // ebx
  runtime_p *v29; // edi
  runtime_muintptr midle; // eax
  runtime_p *v31; // ecx
  runtime_p *v32; // eax
  int64 typ; // [esp+0h] [ebp-58h]
  string typa; // [esp+0h] [ebp-58h]
  string typb; // [esp+0h] [ebp-58h]
  int32 old; // [esp+Ch] [ebp-4Ch]
  int32 i; // [esp+14h] [ebp-44h]
  int32 i_0; // [esp+18h] [ebp-40h]
  __int32 i_1; // [esp+1Ch] [ebp-3Ch]
  int32 i_2; // [esp+20h] [ebp-38h]
  int v41; // [esp+24h] [ebp-34h]
  runtime_p *pp; // [esp+38h] [ebp-20h]
  runtime_g *_g_; // [esp+48h] [ebp-10h]
  runtime_p **ptr; // [esp+54h] [ebp-4h]

  if ( (unsigned int)runtime_gomaxprocs > 0x400 || nprocs <= 0 || nprocs > 1024 )
  {
    typb.str = (uint8 *)"procresize: invalid arg";
    typb.len = 23;
    runtime_throw(typb);
    BUG();
  }
  old = runtime_gomaxprocs;
  if ( runtime_trace.enabled )
    runtime_traceGomaxprocs(nprocs);
  runtime_nanotime();
  if ( LODWORD(runtime_sched.procresizetime) != 0 || HIDWORD(runtime_sched.procresizetime) != 0 )
    runtime_sched.totaltime += (typ - runtime_sched.procresizetime) * old;
  v1 = old;
  runtime_sched.procresizetime = typ;
  for ( j = 0; ; ++j )
  {
    v3 = nprocs;
    if ( j >= nprocs )
      break;
    if ( (unsigned int)j >= 0x401 )
      runtime_panicindex();
    i_0 = j;
    v4 = runtime_allp[j];
    if ( !v4 )
    {
      ptr = &runtime_allp[j];
      p_key = runtime_newobject((runtime__type_0 *)&stru_80DC7A0);
      pp = (runtime_p *)p_key;
      p_key[1] = i_0;
      p_key[2] = 3;
      p_key[456] = 0;
      p_key[457] = 128;
      if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      {
        runtime_writebarrierptr(p_key + 455, (uintptr)(p_key + 458));
        p_key = &pp->lock.key;
      }
      else
      {
        p_key[455] = p_key + 458;
      }
      for ( k = 0; k < 5; k = v10 + 1 )
      {
        if ( (unsigned int)k >= 5 )
          runtime_panicindex();
        v8 = 3 * k;
        p_key[v8 + 16] = 0;
        p_key[v8 + 17] = 32;
        v9 = &p_key[3 * k + 15];
        v10 = k;
        src = (uintptr)&p_key[32 * k + 30];
        if ( *(_DWORD *)&runtime_writeBarrier.enabled )
        {
          runtime_writebarrierptr(v9, src);
          p_key = &pp->lock.key;
        }
        else
        {
          p_key[v8 + 15] = src;
        }
      }
      runtime_atomicstorep(ptr, p_key);
      j = i_0;
      v1 = old;
      v4 = pp;
    }
    if ( !v4->mcache )
    {
      if ( v1 || j )
      {
        v4->mcache = runtime_allocmcache();
        j = i_0;
        v1 = old;
      }
      else
      {
        v5 = *(runtime_mcache **)(*(_DWORD *)(*(_DWORD *)(__readgsdword(0) - 4) + 24) + 184);
        if ( !v5 )
        {
          typa.str = (uint8 *)"missing mcache?";
          typa.len = 15;
          runtime_throw(typa);
          BUG();
        }
        v4->mcache = v5;
      }
    }
  }
  v12 = nprocs;
  while ( v3 < v1 )
  {
    if ( (unsigned int)v3 >= 0x401 )
      runtime_panicindex();
    i_2 = v3;
    v23 = runtime_allp[v3];
    if ( runtime_trace.enabled && v23 == *(runtime_p **)(*(_DWORD *)(*(_DWORD *)(__readgsdword(0) - 4) + 24) + 92) )
    {
      runtime_traceGoSched();
      runtime_traceProcStop(v23);
    }
    while ( 1 )
    {
      runqtail = v23->runqtail;
      if ( v23->runqhead == runqtail )
        break;
      v23->runqtail = runqtail - 1;
      v14 = v23->runq[(unsigned __int8)(runqtail - 1)];
      *(_DWORD *)(v14 + 104) = runtime_sched.runqhead;
      runtime_sched.runqhead = v14;
      if ( !runtime_sched.runqtail )
        runtime_sched.runqtail = v14;
      ++runtime_sched.runqsize;
    }
    runnext = v23->runnext;
    if ( runnext )
    {
      *(_DWORD *)(runnext + 104) = runtime_sched.runqhead;
      runtime_sched.runqhead = runnext;
      if ( !runtime_sched.runqtail )
        runtime_sched.runqtail = runnext;
      ++runtime_sched.runqsize;
      v23->runnext = 0;
    }
    gcBgMarkWorker = (runtime_g *)v23->gcBgMarkWorker;
    if ( gcBgMarkWorker )
    {
      runtime_casgstatus(gcBgMarkWorker, 4u, 1u);
      if ( runtime_trace.enabled )
        runtime_traceGoUnpark(gcBgMarkWorker, 0);
      gcBgMarkWorker->schedlink = 0;
      if ( runtime_sched.runqtail )
        *(_DWORD *)(runtime_sched.runqtail + 104) = gcBgMarkWorker;
      else
        runtime_sched.runqhead = (runtime_guintptr)gcBgMarkWorker;
      runtime_sched.runqtail = (runtime_guintptr)gcBgMarkWorker;
      ++runtime_sched.runqsize;
      v23->gcBgMarkWorker = 0;
    }
    runtime_memclrHasPointers(v23->sudogbuf, 0x200u);
    v17 = v23;
    sudogbuf = (uintptr)v23->sudogbuf;
    v23->sudogcache.len = 0;
    v23->sudogcache.cap = 128;
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
    {
      runtime_writebarrierptr((uintptr *)&v23->sudogcache, sudogbuf);
      v17 = v23;
    }
    else
    {
      v23->sudogcache.array = (runtime_sudog **)sudogbuf;
    }
    v19 = 0;
    while ( v19 < 5 )
    {
      if ( (unsigned int)v19 >= 5 )
        runtime_panicindex();
      i_1 = v19;
      v41 = v19 << 7;
      runtime_memclrHasPointers(v17->deferpoolbuf[v19], 0x80u);
      v20 = i_1;
      v21 = i_1;
      v22 = v23;
      v23->deferpool[v21].len = 0;
      v23->deferpool[v21].cap = 32;
      if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      {
        runtime_writebarrierptr((uintptr *)&v23->deferpool[i_1], (uintptr)v23->deferpoolbuf + v41);
        v20 = i_1;
        v22 = v23;
      }
      else
      {
        v23->deferpool[i_1].array = (runtime__defer **)((char *)v23->deferpoolbuf[0] + v41);
      }
      v19 = v20 + 1;
      v17 = v22;
    }
    runtime_freemcache(v17->mcache);
    v23->mcache = 0;
    runtime_gfpurge(v23);
    runtime_traceProcFree(v23);
    v23->status = 4;
    v3 = i_2 + 1;
    v12 = nprocs;
    v1 = old;
  }
  v24 = *(runtime_g **)(__readgsdword(0) - 4);
  _g_ = v24;
  p = (_DWORD *)v24->m->p;
  v26 = p == 0;
  if ( p )
  {
    if ( p[1] < v12 )
    {
      p[2] = 1;
      goto LABEL_66;
    }
    v26 = p == 0;
  }
  if ( !v26 )
    p[12] = 0;
  v24->m->p = 0;
  v24->m->mcache = 0;
  v32 = runtime_allp[0];
  runtime_allp[0]->m = 0;
  v32->status = 0;
  runtime_acquirep(v32);
  if ( runtime_trace.enabled )
    runtime_traceGoStart();
  v12 = nprocs;
  v24 = _g_;
LABEL_66:
  v27 = v12 - 1;
  v28 = 0;
  while ( v27 >= 0 )
  {
    if ( (unsigned int)v27 >= 0x401 )
      runtime_panicindex();
    v29 = runtime_allp[v27];
    if ( (runtime_p *)v24->m->p != v29 )
    {
      i = v27;
      v29->status = 0;
      if ( runtime_runqempty(v29) )
      {
        runtime_pidleput(v29);
        v31 = v28;
      }
      else
      {
        midle = runtime_sched.midle;
        if ( runtime_sched.midle )
        {
          runtime_sched.midle = *(_DWORD *)(runtime_sched.midle + 180);
          --runtime_sched.nmidle;
        }
        v31 = v29;
        v29->m = midle;
        v29->link = (runtime_puintptr)v28;
      }
      v12 = nprocs;
      v27 = i;
      v28 = v31;
      v24 = _g_;
    }
    --v27;
  }
  runtime___ptr_randomOrder__reset(&runtime_stealOrder, v12);
  runtime_internal_atomic_Store();
  return v28;
}
// 8074955: variable 'typ' is possibly undefined

//----- (08075030) --------------------------------------------------------
void __golang runtime_acquirep(runtime_p *_p_)
{
  runtime_acquirep1(_p_);
  *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(__readgsdword(0) - 4) + 24) + 184) = _p_->mcache;
  if ( runtime_trace.enabled )
    runtime_traceProcStart();
}

//----- (08075090) --------------------------------------------------------
void __golang runtime_acquirep1(runtime_p *_p_)
{
  int v1; // eax
  int v2; // ecx
  runtime_muintptr m; // ebp
  bool v4; // zf
  int32 v5; // eax
  string s; // [esp+0h] [ebp-14h]
  string sa; // [esp+0h] [ebp-14h]
  string sb; // [esp+0h] [ebp-14h]
  string sc; // [esp+0h] [ebp-14h]
  string sd; // [esp+0h] [ebp-14h]
  string se; // [esp+0h] [ebp-14h]
  int32 id; // [esp+8h] [ebp-Ch]
  uint32 v; // [esp+Ch] [ebp-8h]
  runtime_muintptr v_4; // [esp+10h] [ebp-4h]

  v1 = *(_DWORD *)(__readgsdword(0) - 4);
  v2 = *(_DWORD *)(v1 + 24);
  if ( *(_DWORD *)(v2 + 92) || *(_DWORD *)(v2 + 184) )
  {
    se.str = (uint8 *)"acquirep: already in go";
    se.len = 23;
    runtime_throw(se);
    BUG();
  }
  m = _p_->m;
  v4 = m == 0;
  if ( m )
  {
LABEL_7:
    v_4 = _p_->m;
    if ( v4 )
      v5 = 0;
    else
      v5 = *(_DWORD *)(m + 100);
    id = v5;
    v = _p_->status;
    runtime_printlock();
    s.str = (uint8 *)"acquirep: p->m=";
    s.len = 15;
    runtime_printstring(s);
    runtime_printint(v_4);
    sa.str = (uint8 *)"(";
    sa.len = 1;
    runtime_printstring(sa);
    runtime_printint(id);
    sb.str = (uint8 *)") p->status=";
    sb.len = 12;
    runtime_printstring(sb);
    runtime_printint(v);
    sc.str = (uint8 *)"\n";
    sc.len = 1;
    runtime_printstring(sc);
    runtime_printunlock();
    sd.str = (uint8 *)"acquirep: invalid p state";
    sd.len = 25;
    runtime_throw(sd);
    BUG();
  }
  if ( _p_->status )
  {
    v4 = 1;
    goto LABEL_7;
  }
  *(_DWORD *)(v2 + 92) = _p_;
  _p_->m = *(_DWORD *)(v1 + 24);
  _p_->status = 1;
}
// 80E0D85: using guessed type char asc_80E0D85;

//----- (08075200) --------------------------------------------------------
runtime_p *__golang runtime_releasep()
{
  int v0; // eax
  int v1; // ecx
  runtime_p *v2; // edx
  runtime_mcache *v3; // ebx
  string pp; // [esp+0h] [ebp-24h]
  string ppa; // [esp+0h] [ebp-24h]
  string ppb; // [esp+0h] [ebp-24h]
  string ppc; // [esp+0h] [ebp-24h]
  string ppd; // [esp+0h] [ebp-24h]
  string ppe; // [esp+0h] [ebp-24h]
  string ppf; // [esp+0h] [ebp-24h]
  string ppg; // [esp+0h] [ebp-24h]
  string pph; // [esp+0h] [ebp-24h]
  runtime_muintptr mp; // [esp+8h] [ebp-1Ch]
  uint32 v; // [esp+Ch] [ebp-18h]
  int v_4; // [esp+10h] [ebp-14h]
  runtime_mcache *mcache; // [esp+14h] [ebp-10h]
  runtime_p *v17; // [esp+18h] [ebp-Ch]
  void *p; // [esp+20h] [ebp-4h]

  v0 = *(_DWORD *)(__readgsdword(0) - 4);
  v1 = *(_DWORD *)(v0 + 24);
  v2 = *(runtime_p **)(v1 + 92);
  if ( !v2 || (v3 = *(runtime_mcache **)(v1 + 184)) == 0 )
  {
    pph.str = (uint8 *)"releasep: invalid arg";
    pph.len = 21;
    runtime_throw(pph);
    BUG();
  }
  p = *(void **)(v0 + 24);
  v17 = *(runtime_p **)(v1 + 92);
  mp = v2->m;
  if ( mp != v1 || v2->mcache != v3 || v2->status != 1 )
  {
    mcache = v2->mcache;
    v = v2->status;
    runtime_printlock();
    pp.str = (uint8 *)"releasep: m=";
    pp.len = 12;
    runtime_printstring(pp);
    runtime_printpointer(p);
    ppa.str = (uint8 *)" m->p=";
    ppa.len = 6;
    runtime_printstring(ppa);
    runtime_printpointer(v17);
    ppb.str = (uint8 *)" p->m=";
    ppb.len = 6;
    runtime_printstring(ppb);
    runtime_printint(mp);
    ppc.str = (uint8 *)" m->mcache=";
    ppc.len = 11;
    runtime_printstring(ppc);
    runtime_printpointer(v3);
    ppd.str = (uint8 *)" p->mcache=";
    ppd.len = 11;
    runtime_printstring(ppd);
    runtime_printpointer(mcache);
    ppe.str = (uint8 *)" p->status=";
    ppe.len = 11;
    runtime_printstring(ppe);
    runtime_printint(v);
    ppf.str = (uint8 *)"\n";
    ppf.len = 1;
    runtime_printstring(ppf);
    runtime_printunlock();
    ppg.str = (uint8 *)"releasep: invalid p state";
    ppg.len = 25;
    runtime_throw(ppg);
    BUG();
  }
  if ( runtime_trace.enabled )
  {
    v_4 = v0;
    runtime_traceProcStop(v2);
    v0 = v_4;
    v2 = v17;
  }
  *(_DWORD *)(*(_DWORD *)(v0 + 24) + 92) = 0;
  *(_DWORD *)(*(_DWORD *)(v0 + 24) + 184) = 0;
  v2->m = 0;
  v2->status = 0;
  return v2;
}

//----- (08075400) --------------------------------------------------------
void __golang runtime_incidlelocked(int32 v)
{
  runtime_lock(&runtime_sched.lock);
  runtime_sched.nmidlelocked += v;
  if ( v > 0 )
    runtime_checkdead();
  runtime_unlock(&runtime_sched.lock);
}

//----- (08075460) --------------------------------------------------------
void __golang runtime_checkdead()
{
  __int32 v0; // eax
  __int32 v1; // ecx
  runtime_g *v2; // edx
  uintptr startpc; // ebx
  bool v4; // bl
  __int32 v5; // eax
  runtime_note_0 *midle; // ecx
  bool v7; // zf
  runtime_g *l; // [esp+0h] [ebp-30h]
  runtime_p *la; // [esp+0h] [ebp-30h]
  string lb; // [esp+0h] [ebp-30h]
  string lc; // [esp+0h] [ebp-30h]
  string ld; // [esp+0h] [ebp-30h]
  string le; // [esp+0h] [ebp-30h]
  string lf; // [esp+0h] [ebp-30h]
  string lg; // [esp+0h] [ebp-30h]
  string lh; // [esp+0h] [ebp-30h]
  string li; // [esp+0h] [ebp-30h]
  string lj; // [esp+0h] [ebp-30h]
  string lk; // [esp+0h] [ebp-30h]
  string ll; // [esp+0h] [ebp-30h]
  string lm; // [esp+0h] [ebp-30h]
  string ln; // [esp+0h] [ebp-30h]
  uint32 oldval; // [esp+4h] [ebp-2Ch]
  __int32 i; // [esp+Ch] [ebp-24h]
  __int32 grunning; // [esp+10h] [ebp-20h]
  int32 nmidlelocked; // [esp+14h] [ebp-1Ch]
  int32 nmidle; // [esp+18h] [ebp-18h]
  unsigned int goid_high; // [esp+1Ch] [ebp-14h]
  int32 mcount; // [esp+1Ch] [ebp-14h]
  unsigned int v; // [esp+20h] [ebp-10h]
  uint32 v_4; // [esp+24h] [ebp-Ch]
  runtime_g *gp; // [esp+28h] [ebp-8h]
  runtime_g *g; // [esp+2Ch] [ebp-4h]

  if ( !runtime_islibrary
    && !runtime_isarchive
    && !runtime_panicking
    && runtime_sched.mcount - runtime_sched.nmidle - runtime_sched.nmidlelocked - 1 <= 0 )
  {
    if ( runtime_sched.mcount - runtime_sched.nmidle - runtime_sched.nmidlelocked - 1 < 0 )
    {
      mcount = runtime_sched.mcount;
      nmidle = runtime_sched.nmidle;
      nmidlelocked = runtime_sched.nmidlelocked;
      runtime_printlock();
      lj.str = (uint8 *)"runtime: checkdead: nmidle=";
      lj.len = 27;
      runtime_printstring(lj);
      runtime_printint(nmidle);
      lk.str = (uint8 *)" nmidlelocked=";
      lk.len = 14;
      runtime_printstring(lk);
      runtime_printint(nmidlelocked);
      ll.str = (uint8 *)" mcount=";
      ll.len = 8;
      runtime_printstring(ll);
      runtime_printint(mcount);
      lm.str = (uint8 *)"\n";
      lm.len = 1;
      runtime_printstring(lm);
      runtime_printunlock();
      ln.str = (uint8 *)"checkdead: inconsistent counts";
      ln.len = 30;
      runtime_throw(ln);
      BUG();
    }
    runtime_lock(&runtime_allglock);
    v0 = 0;
    v1 = 0;
    while ( 1 )
    {
      grunning = v1;
      if ( v0 >= runtime_allgs.len )
        break;
      if ( (unsigned int)v0 >= runtime_allgs.len )
        runtime_panicindex();
      v2 = runtime_allgs.array[v0];
      startpc = v2->startpc;
      if ( runtime_runfinqPC == startpc && !runtime_fingRunning )
      {
        v4 = 1;
      }
      else if ( runtime_bgsweepPC == startpc )
      {
        v4 = 1;
      }
      else
      {
        v4 = runtime_forcegchelperPC == startpc || runtime_timerprocPC == startpc || runtime_gcBgMarkWorkerPC == startpc;
      }
      if ( !v4 )
      {
        i = v0;
        gp = runtime_allgs.array[v0];
        oldval = runtime_readgstatus(v2);
        if ( (oldval & 0xFFFFEFFF) - 1 <= 2 )
        {
          v_4 = oldval;
          runtime_unlock(&runtime_allglock);
          v = gp->goid;
          goid_high = HIDWORD(gp->goid);
          runtime_printlock();
          lf.str = (uint8 *)"runtime: checkdead: find g ";
          lf.len = 27;
          runtime_printstring(lf);
          runtime_printint(__SPAIR64__(goid_high, v));
          lg.str = (uint8 *)" in status ";
          lg.len = 11;
          runtime_printstring(lg);
          runtime_printint(v_4);
          lh.str = (uint8 *)"\n";
          lh.len = 1;
          runtime_printstring(lh);
          runtime_printunlock();
          li.str = (uint8 *)"checkdead: runnable g";
          li.len = 21;
          runtime_throw(li);
          BUG();
        }
        if ( (oldval & 0xFFFFEFFF) == 4 )
          v5 = grunning + 1;
        else
          v5 = grunning;
        v1 = v5;
        v0 = i;
      }
      ++v0;
    }
    runtime_unlock(&runtime_allglock);
    if ( !grunning )
    {
      le.str = (uint8 *)"no goroutines (main called runtime.Goexit) - deadlock!";
      le.len = 54;
      runtime_throw(le);
      BUG();
    }
    l = runtime_timejump();
    if ( !l )
    {
      *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(__readgsdword(0) - 4) + 24) + 108) = -1;
      ld.str = (uint8 *)"all goroutines are asleep - deadlock!";
      ld.len = 37;
      runtime_throw(ld);
      BUG();
    }
    g = l;
    runtime_casgstatus(l, 4u, 1u);
    g->schedlink = 0;
    if ( runtime_sched.runqtail )
      *(_DWORD *)(runtime_sched.runqtail + 104) = g;
    else
      runtime_sched.runqhead = (runtime_guintptr)g;
    runtime_sched.runqtail = (runtime_guintptr)g;
    ++runtime_sched.runqsize;
    la = runtime_pidleget();
    if ( !la )
    {
      lc.str = (uint8 *)"checkdead: no p for timer";
      lc.len = 25;
      runtime_throw(lc);
      BUG();
    }
    midle = (runtime_note_0 *)runtime_sched.midle;
    v7 = runtime_sched.midle == 0;
    if ( runtime_sched.midle )
    {
      runtime_sched.midle = *(_DWORD *)(runtime_sched.midle + 180);
      --runtime_sched.nmidle;
      v7 = midle == 0;
    }
    if ( v7 )
    {
      lb.str = (uint8 *)"checkdead: no m for timer";
      lb.len = 25;
      runtime_throw(lb);
      BUG();
    }
    midle[24].key = (uintptr)la;
    runtime_notewakeup(midle + 43);
  }
}

//----- (08075890) --------------------------------------------------------
void __golang __noreturn runtime_sysmon()
{
  int v0; // eax
  int v1; // ecx
  runtime_mutex_0 *v2; // eax
  int32 v3; // ecx
  int v4; // edx
  unsigned int v5; // ebx
  __int32 v6; // ebp
  uint64 *v7; // esi
  unsigned int v8; // edi
  unsigned int v9; // eax
  unsigned int v10; // ebx
  int v11; // eax
  __int32 v12; // ecx
  uint32 v13; // eax
  __int32 v14; // ecx
  unsigned int v15; // ecx
  __int32 v16; // eax
  runtime_mutex_0 *v17; // edi
  int v18; // ebp
  int32 v19; // ecx
  __int32 v20; // ebx
  uint64 *p_lastpoll; // ecx
  unsigned int v22; // esi
  runtime_mutex_0 *l; // [esp+0h] [ebp-50h]
  runtime_gcTrigger_0 la; // [esp+0h] [ebp-50h]
  int64 ns; // [esp+4h] [ebp-4Ch]
  runtime_g *nsa; // [esp+4h] [ebp-4Ch]
  uint64 t_now_lo; // [esp+18h] [ebp-38h]
  signed __int64 scavengelimit_lo; // [esp+20h] [ebp-30h]
  __int32 nscavenge; // [esp+28h] [ebp-28h]
  __int32 nscavengea; // [esp+28h] [ebp-28h]
  unsigned __int64 lasttrace_lo; // [esp+2Ch] [ebp-24h]
  unsigned __int64 lastscavenge_lo; // [esp+34h] [ebp-1Ch]
  int32 lastscavenge_hi; // [esp+38h] [ebp-18h]
  __int32 idle; // [esp+40h] [ebp-10h]
  __int32 idlec; // [esp+40h] [ebp-10h]
  __int32 idlea; // [esp+40h] [ebp-10h]
  __int32 idleb; // [esp+40h] [ebp-10h]
  uint32 delaya; // [esp+44h] [ebp-Ch]
  uint32 delay; // [esp+44h] [ebp-Ch]

  if ( runtime_debug.scavenge <= 0 )
  {
    v0 = 69;
    v1 = -647710720;
  }
  else
  {
    runtime_forcegcperiod = 10000000LL;
    v0 = 0;
    v1 = 20000000;
  }
  scavengelimit_lo = __PAIR64__(v0, v1);
  runtime_nanotime();
  v2 = l;
  v3 = ns;
  v4 = 0;
  v5 = 0;
  v6 = 0;
  v7 = 0;
  v8 = 0;
  while ( 1 )
  {
    if ( v4 )
    {
      if ( v4 > 50 )
        v5 *= 2;
    }
    else
    {
      v5 = 20;
    }
    lasttrace_lo = __PAIR64__(v8, (unsigned int)v7);
    nscavenge = v6;
    lastscavenge_lo = __PAIR64__(v3, (unsigned int)v2);
    idle = v4;
    if ( v5 > 0x2710 )
      v5 = 10000;
    runtime_usleep();
    if ( runtime_debug.schedtrace <= 0
      && (runtime_sched.gcwaiting
       || (LODWORD(ns) = runtime_internal_atomic_Load(&runtime_sched.npidle), runtime_gomaxprocs == (_DWORD)ns)) )
    {
      runtime_lock(&runtime_sched.lock);
      if ( runtime_internal_atomic_Load(&runtime_sched.gcwaiting)
        || (LODWORD(ns) = runtime_internal_atomic_Load(&runtime_sched.npidle), runtime_gomaxprocs == (_DWORD)ns) )
      {
        runtime_internal_atomic_Store();
        runtime_unlock(&runtime_sched.lock);
        if ( SHIDWORD(scavengelimit_lo) < SHIDWORD(runtime_forcegcperiod)
          || HIDWORD(scavengelimit_lo) == HIDWORD(runtime_forcegcperiod)
          && (unsigned int)scavengelimit_lo < (unsigned int)runtime_forcegcperiod )
        {
          v9 = scavengelimit_lo / 2;
          v10 = (unsigned __int64)(scavengelimit_lo / 2) >> 32;
        }
        else
        {
          v10 = (unsigned __int64)(runtime_forcegcperiod / 2) >> 32;
          v9 = runtime_forcegcperiod / 2;
        }
        runtime_notetsleep(&runtime_sched.sysmonnote, __SPAIR64__(v10, v9));
        runtime_lock(&runtime_sched.lock);
        LODWORD(ns) = 0;
        runtime_internal_atomic_Store();
        runtime_sched.sysmonnote.key = 0;
        v11 = 20;
        v12 = 0;
      }
      else
      {
        v11 = v5;
        v12 = idle;
      }
      idlec = v12;
      delaya = v11;
      runtime_unlock(&runtime_sched.lock);
      v13 = delaya;
      v14 = idlec;
    }
    else
    {
      v13 = v5;
      v14 = idle;
    }
    idlea = v14;
    delay = v13;
    if ( *runtime_cgo_yield )
    {
      LODWORD(ns) = 0;
      runtime_asmcgocall();
    }
    runtime_internal_atomic_Load64();
    runtime_nanotime();
    LODWORD(t_now_lo) = &runtime_sched.lastpoll;
    v15 = ns;
    HIDWORD(t_now_lo) = ns;
    if ( ((_DWORD)ns != 0 || HIDWORD(ns) != 0)
      && ((int)((unsigned __int64)(ns + 10000000) >> 32) < (int)ns
       || (unsigned __int64)(ns + 10000000) >> 32 == (_DWORD)ns
       && (int)ns + 10000000 < (unsigned int)&runtime_sched.lastpoll) )
    {
      runtime_internal_atomic_Cas64();
      nsa = runtime_netpoll(0);
      if ( nsa )
      {
        runtime_incidlelocked(-1);
        runtime_injectglist(nsa);
        runtime_incidlelocked(1);
      }
      v15 = HIDWORD(t_now_lo);
    }
    if ( runtime_retake(__SPAIR64__(v15, (runtime_schedt *)&runtime_sched.lastpoll)) )
      v16 = 0;
    else
      v16 = idlea + 1;
    idleb = v16;
    la.kind = 2;
    la.now = t_now_lo;
    la.n = 0;
    if ( runtime_gcTrigger_test(la) )
    {
      LODWORD(ns) = runtime_internal_atomic_Load(&runtime_forcegc.idle);
      if ( (_DWORD)ns )
      {
        runtime_lock(&runtime_forcegc.lock);
        runtime_forcegc.idle = 0;
        runtime_forcegc.g->schedlink = 0;
        runtime_injectglist(runtime_forcegc.g);
        runtime_unlock(&runtime_forcegc.lock);
      }
    }
    v17 = (runtime_mutex_0 *)lastscavenge_lo;
    v18 = HIDWORD(t_now_lo);
    if ( (int)((scavengelimit_lo / 2 + lastscavenge_lo) >> 32) < SHIDWORD(t_now_lo)
      || (scavengelimit_lo / 2 + lastscavenge_lo) >> 32 == HIDWORD(t_now_lo)
      && (unsigned int)(scavengelimit_lo / 2) + (unsigned int)lastscavenge_lo < (unsigned int)&runtime_sched.lastpoll )
    {
      runtime___ptr_mheap__scavenge(&runtime_mheap_, nscavenge, t_now_lo, scavengelimit_lo);
      v20 = nscavenge + 1;
      v18 = HIDWORD(t_now_lo);
      v19 = HIDWORD(t_now_lo);
      v17 = (runtime_mutex_0 *)t_now_lo;
    }
    else
    {
      v19 = HIDWORD(lastscavenge_lo);
      v20 = nscavenge;
    }
    lastscavenge_hi = v19;
    nscavengea = v20;
    if ( runtime_debug.schedtrace <= 0 )
    {
      v22 = HIDWORD(lasttrace_lo);
      p_lastpoll = (uint64 *)lasttrace_lo;
    }
    else
    {
      p_lastpoll = v7;
      v22 = HIDWORD(lasttrace_lo);
      if ( (int)((lasttrace_lo + 1000000LL * runtime_debug.schedtrace) >> 32) < v18
        || (lasttrace_lo + 1000000LL * runtime_debug.schedtrace) >> 32 == v18
        && (int)lasttrace_lo + 1000000 * runtime_debug.schedtrace <= (unsigned int)&runtime_sched.lastpoll )
      {
        runtime_schedtrace(runtime_debug.scheddetail > 0);
        v22 = HIDWORD(t_now_lo);
        p_lastpoll = &runtime_sched.lastpoll;
      }
    }
    v4 = idleb;
    v5 = delay;
    v2 = v17;
    v6 = nscavengea;
    v8 = v22;
    v7 = p_lastpoll;
    v3 = lastscavenge_hi;
  }
}
// 80758DF: variable 'l' is possibly undefined
// 80758E2: variable 'ns' is possibly undefined

//----- (08075E20) --------------------------------------------------------
uint32 __golang runtime_retake(int64 now)
{
  int32 v1; // eax
  uint32 v2; // ecx
  runtime_p *v3; // ebx
  uint32 status; // esi
  uint32 syscalltick; // ebp
  __int32 v6; // eax
  uint32 v7; // eax
  uint32 schedtick; // ebp
  _DWORD *m; // edx
  int v10; // ebx
  char v11; // [esp+Ch] [ebp-20h]
  __int32 n; // [esp+14h] [ebp-18h]
  int32 i; // [esp+18h] [ebp-14h]
  uint32 v14; // [esp+1Ch] [ebp-10h]
  __int32 v15; // [esp+20h] [ebp-Ch]

  v1 = 0;
  v2 = 0;
  while ( v1 < runtime_gomaxprocs )
  {
    if ( (unsigned int)v1 >= 0x401 )
      runtime_panicindex();
    v3 = runtime_allp[v1];
    if ( v3 )
    {
      i = v1;
      status = v3->status;
      if ( status == 2 )
      {
        syscalltick = v3->syscalltick;
        if ( v3->sysmontick.syscalltick != syscalltick )
        {
          v3->sysmontick.syscalltick = syscalltick;
          v3->sysmontick.syscallwhen = now;
          goto LABEL_2;
        }
        n = v2;
        if ( !runtime_runqempty(v3)
          || (v14 = runtime_internal_atomic_Load(&runtime_sched.nmspinning),
              !(v14 + runtime_internal_atomic_Load(&runtime_sched.npidle)))
          || ((unsigned __int64)(v3->sysmontick.syscallwhen + 10000000) >> 32 != HIDWORD(now)
           || LODWORD(v3->sysmontick.syscallwhen) + 10000000 <= (unsigned int)now)
          && (int)((unsigned __int64)(v3->sysmontick.syscallwhen + 10000000) >> 32) <= SHIDWORD(now) )
        {
          runtime_incidlelocked(-1);
          runtime_internal_atomic_Cas();
          if ( v11 )
          {
            if ( runtime_trace.enabled )
            {
              runtime_traceGoSysBlock(v3);
              runtime_traceProcStop(v3);
            }
            ++v3->syscalltick;
            runtime_handoffp(v3);
            v6 = n + 1;
          }
          else
          {
            v6 = n;
          }
          v15 = v6;
          runtime_incidlelocked(1);
          v7 = v15;
          goto LABEL_15;
        }
        v1 = i;
        v2 = n;
      }
      else
      {
        if ( status != 1 )
          goto LABEL_27;
        schedtick = v3->schedtick;
        if ( v3->sysmontick.schedtick == schedtick )
        {
          if ( (LODWORD(v3->sysmontick.schedwhen) + 10000000 <= (unsigned int)now
             || (unsigned __int64)(v3->sysmontick.schedwhen + 10000000) >> 32 != HIDWORD(now))
            && (int)((unsigned __int64)(v3->sysmontick.schedwhen + 10000000) >> 32) <= SHIDWORD(now) )
          {
            m = (_DWORD *)v3->m;
            if ( m )
            {
              if ( *(_DWORD **)(*(_DWORD *)(__readgsdword(0) - 4) + 24) != m )
              {
                v10 = m[21];
                if ( v10 )
                {
                  if ( v10 != *m )
                  {
                    *(_BYTE *)(v10 + 108) = 1;
                    *(_DWORD *)(v10 + 8) = -1314;
                  }
                }
              }
            }
LABEL_27:
            v7 = v2;
LABEL_15:
            v2 = v7;
            v1 = i;
          }
        }
        else
        {
          v3->sysmontick.schedtick = schedtick;
          v3->sysmontick.schedwhen = now;
        }
      }
    }
LABEL_2:
    ++v1;
  }
  return v2;
}
// 8075EF4: variable 'v11' is possibly undefined

//----- (080760E0) --------------------------------------------------------
bool __golang runtime_preemptall()
{
  int32 v0; // eax
  char v1; // cl
  runtime_p *v2; // ebx
  _DWORD *m; // ebx
  char v4; // bl
  int v5; // ebp

  v0 = 0;
  v1 = 0;
  while ( v0 < runtime_gomaxprocs )
  {
    if ( (unsigned int)v0 >= 0x401 )
      runtime_panicindex();
    v2 = runtime_allp[v0];
    if ( v2 && v2->status == 1 )
    {
      m = (_DWORD *)v2->m;
      if ( m && *(_DWORD **)(*(_DWORD *)(__readgsdword(0) - 4) + 24) != m )
      {
        v5 = m[21];
        if ( v5 && v5 != *m )
        {
          *(_BYTE *)(v5 + 108) = 1;
          *(_DWORD *)(v5 + 8) = -1314;
          v4 = 1;
        }
        else
        {
          v4 = 0;
        }
      }
      else
      {
        v4 = 0;
      }
      v1 |= v4;
    }
    ++v0;
  }
  return v1;
}

//----- (08076180) --------------------------------------------------------
void __golang runtime_schedtrace(bool detailed)
{
  bool v1; // al
  int32 j; // ecx
  runtime_p *v3; // ebx
  int v4; // edx
  uintptr k; // eax
  int v6; // ecx
  int v7; // edx
  int v8; // ebx
  int v9; // ebx
  int v10; // ebp
  int v11; // ecx
  int v12; // esi
  int v13; // edx
  __int32 m; // eax
  runtime_g *v15; // ecx
  runtime_m *v16; // edx
  runtime_m *lockedm; // ebx
  int v18; // edx
  int v19; // ebx
  int64 l; // [esp+0h] [ebp-90h]
  string la; // [esp+0h] [ebp-90h]
  string lb; // [esp+0h] [ebp-90h]
  string lc; // [esp+0h] [ebp-90h]
  string ld; // [esp+0h] [ebp-90h]
  string le; // [esp+0h] [ebp-90h]
  string lf; // [esp+0h] [ebp-90h]
  string lg; // [esp+0h] [ebp-90h]
  string lm; // [esp+0h] [ebp-90h]
  string ln; // [esp+0h] [ebp-90h]
  string lo; // [esp+0h] [ebp-90h]
  string lp; // [esp+0h] [ebp-90h]
  string lq; // [esp+0h] [ebp-90h]
  string lr; // [esp+0h] [ebp-90h]
  string ls; // [esp+0h] [ebp-90h]
  string lt; // [esp+0h] [ebp-90h]
  string lu; // [esp+0h] [ebp-90h]
  string lw; // [esp+0h] [ebp-90h]
  string lv; // [esp+0h] [ebp-90h]
  string lx; // [esp+0h] [ebp-90h]
  string ly; // [esp+0h] [ebp-90h]
  string lz; // [esp+0h] [ebp-90h]
  string lba; // [esp+0h] [ebp-90h]
  string lbb; // [esp+0h] [ebp-90h]
  string lbc; // [esp+0h] [ebp-90h]
  string lbd; // [esp+0h] [ebp-90h]
  string lbe; // [esp+0h] [ebp-90h]
  string lbf; // [esp+0h] [ebp-90h]
  string lbg; // [esp+0h] [ebp-90h]
  string lbh; // [esp+0h] [ebp-90h]
  string lbi; // [esp+0h] [ebp-90h]
  string lbj; // [esp+0h] [ebp-90h]
  string lbk; // [esp+0h] [ebp-90h]
  string lbl; // [esp+0h] [ebp-90h]
  string lbm; // [esp+0h] [ebp-90h]
  string lbn; // [esp+0h] [ebp-90h]
  string lbo; // [esp+0h] [ebp-90h]
  string lbp; // [esp+0h] [ebp-90h]
  string lh; // [esp+0h] [ebp-90h]
  string li; // [esp+0h] [ebp-90h]
  string lj; // [esp+0h] [ebp-90h]
  string lk; // [esp+0h] [ebp-90h]
  string ll; // [esp+0h] [ebp-90h]
  uint32 l_4; // [esp+4h] [ebp-8Ch]
  char v64; // [esp+1Ah] [ebp-76h]
  char v65; // [esp+1Bh] [ebp-75h]
  uint32 t; // [esp+1Ch] [ebp-74h]
  int64 now_lo; // [esp+20h] [ebp-70h]
  int64 id3_lo; // [esp+28h] [ebp-68h]
  int64 id2_lo; // [esp+30h] [ebp-60h]
  int32 id1_0; // [esp+40h] [ebp-50h]
  int32 id; // [esp+44h] [ebp-4Ch]
  int32 i; // [esp+48h] [ebp-48h]
  uint32 h; // [esp+4Ch] [ebp-44h]
  __int32 gi; // [esp+50h] [ebp-40h]
  int64 v75; // [esp+54h] [ebp-3Ch]
  unsigned int v76; // [esp+5Ch] [ebp-34h]
  __int32 len; // [esp+5Ch] [ebp-34h]
  int64 v; // [esp+60h] [ebp-30h]
  int64 va; // [esp+60h] [ebp-30h]
  uint32 nmspinning; // [esp+68h] [ebp-28h]
  uint32 syscalltick; // [esp+68h] [ebp-28h]
  int32 mcount; // [esp+6Ch] [ebp-24h]
  int v83; // [esp+6Ch] [ebp-24h]
  int32 stopwait; // [esp+6Ch] [ebp-24h]
  uint32 npidle; // [esp+70h] [ebp-20h]
  uint32 schedtick; // [esp+70h] [ebp-20h]
  uint32 v87; // [esp+70h] [ebp-20h]
  uint32 sysmonwait; // [esp+70h] [ebp-20h]
  __int64 v89; // [esp+74h] [ebp-1Ch]
  int64 goid; // [esp+74h] [ebp-1Ch]
  runtime_m *mp; // [esp+7Ch] [ebp-14h]
  runtime_g *gp; // [esp+80h] [ebp-10h] BYREF
  runtime_p *_p_; // [esp+84h] [ebp-Ch]
  string s; // [esp+88h] [ebp-8h]

  while ( (unsigned int)&gp <= *(_DWORD *)(*(_DWORD *)(__readgsdword(0) - 4) + 8) )
    runtime_morestack_noctxt();
  runtime_nanotime();
  now_lo = l;
  if ( (_DWORD)runtime_starttime == 0 && HIDWORD(runtime_starttime) == 0 )
    runtime_starttime = l;
  runtime_lock(&runtime_sched.lock);
  v89 = runtime_int64div(now_lo - runtime_starttime, 1000000LL);
  npidle = runtime_sched.npidle;
  mcount = runtime_sched.mcount;
  nmspinning = runtime_sched.nmspinning;
  v = __PAIR64__(runtime_sched.nmidle, runtime_sched.runqsize);
  runtime_printlock();
  la.str = (uint8 *)"SCHED ";
  la.len = 6;
  runtime_printstring(la);
  runtime_printint(v89);
  lb.str = (uint8 *)"ms: gomaxprocs=";
  lb.len = 15;
  runtime_printstring(lb);
  runtime_printint(runtime_gomaxprocs);
  lc.str = (uint8 *)" idleprocs=";
  lc.len = 11;
  runtime_printstring(lc);
  runtime_printint(npidle);
  ld.str = (uint8 *)" threads=";
  ld.len = 9;
  runtime_printstring(ld);
  runtime_printint(mcount);
  le.str = (uint8 *)" spinningthreads=";
  le.len = 17;
  runtime_printstring(le);
  runtime_printint(nmspinning);
  lf.str = (uint8 *)" idlethreads=";
  lf.len = 13;
  runtime_printstring(lf);
  runtime_printint(v >> 32);
  lg.str = (uint8 *)" runqueue=";
  lg.len = 10;
  runtime_printstring(lg);
  runtime_printint((int)v);
  runtime_printunlock();
  v1 = detailed;
  if ( detailed )
  {
    v89 = __PAIR64__(runtime_sched.nmidlelocked, runtime_sched.gcwaiting);
    stopwait = runtime_sched.stopwait;
    sysmonwait = runtime_sched.sysmonwait;
    runtime_printlock();
    lh.str = (uint8 *)" gcwaiting=";
    lh.len = 11;
    runtime_printstring(lh);
    runtime_printint((unsigned int)v89);
    li.str = (uint8 *)" nmidlelocked=";
    li.len = 14;
    runtime_printstring(li);
    runtime_printint(v89 >> 32);
    lj.str = (uint8 *)" stopwait=";
    lj.len = 10;
    runtime_printstring(lj);
    runtime_printint(stopwait);
    lk.str = (uint8 *)" sysmonwait=";
    lk.len = 12;
    runtime_printstring(lk);
    runtime_printint(sysmonwait);
    ll.str = (uint8 *)"\n";
    ll.len = 1;
    runtime_printstring(ll);
    runtime_printunlock();
    v1 = detailed;
  }
  for ( j = 0; j < runtime_gomaxprocs; ++j )
  {
    if ( (unsigned int)j >= 0x401 )
      runtime_panicindex();
    v3 = runtime_allp[j];
    if ( v3 )
    {
      i = j;
      _p_ = runtime_allp[j];
      s.len = v3->m;
      h = runtime_internal_atomic_Load(&v3->runqhead);
      t = runtime_internal_atomic_Load(&_p_->runqtail);
      if ( detailed )
      {
        if ( s.len )
          v4 = *(_DWORD *)(s.len + 100);
        else
          v4 = -1;
        id = v4;
        LODWORD(v89) = _p_->status;
        schedtick = _p_->schedtick;
        syscalltick = _p_->syscalltick;
        HIDWORD(v89) = _p_->gfreecnt;
        runtime_printlock();
        lm.str = (uint8 *)"  P";
        lm.len = 3;
        runtime_printstring(lm);
        runtime_printint(i);
        ln.str = (uint8 *)": status=";
        ln.len = 9;
        runtime_printstring(ln);
        runtime_printint((unsigned int)v89);
        lo.str = (uint8 *)" schedtick=";
        lo.len = 11;
        runtime_printstring(lo);
        runtime_printint(schedtick);
        lp.str = (uint8 *)" syscalltick=";
        lp.len = 13;
        runtime_printstring(lp);
        runtime_printint(syscalltick);
        lq.str = (uint8 *)" m=";
        lq.len = 3;
        runtime_printstring(lq);
        runtime_printint(id);
        lr.str = (uint8 *)" runqsize=";
        lr.len = 10;
        runtime_printstring(lr);
        runtime_printint(t - h);
        ls.str = (uint8 *)" gfreecnt=";
        ls.len = 10;
        runtime_printstring(ls);
        runtime_printint(v89 >> 32);
        lt.str = (uint8 *)"\n";
        lt.len = 1;
        runtime_printstring(lt);
        runtime_printunlock();
      }
      else
      {
        runtime_printlock();
        lu.str = (uint8 *)" ";
        lu.len = 1;
        runtime_printstring(lu);
        runtime_printunlock();
        if ( !i )
        {
          runtime_printlock();
          lv.str = (uint8 *)"[";
          lv.len = 1;
          runtime_printstring(lv);
          runtime_printunlock();
        }
        runtime_printlock();
        runtime_printint(t - h);
        runtime_printunlock();
        if ( runtime_gomaxprocs - 1 == i )
        {
          runtime_printlock();
          lw.str = (uint8 *)"]\n";
          lw.len = 2;
          runtime_printstring(lw);
          runtime_printunlock();
        }
      }
      v1 = detailed;
      j = i;
    }
  }
  if ( v1 )
  {
    for ( k = runtime_allm; k; k = (uintptr)mp->alllink )
    {
      v6 = *(_DWORD *)(k + 84);
      v7 = *(_DWORD *)(k + 188);
      v8 = *(_DWORD *)(k + 92);
      if ( v8 )
        v9 = *(_DWORD *)(v8 + 4);
      else
        v9 = -1;
      if ( v6 )
      {
        v10 = *(_DWORD *)(v6 + 84);
        v11 = *(_DWORD *)(v6 + 80);
      }
      else
      {
        v11 = -1;
        v10 = -1;
      }
      id2_lo = __PAIR64__(v10, v11);
      if ( v7 )
      {
        v12 = *(_DWORD *)(v7 + 84);
        v13 = *(_DWORD *)(v7 + 80);
      }
      else
      {
        v13 = -1;
        v12 = -1;
      }
      mp = (runtime_m *)k;
      id3_lo = __PAIR64__(v12, v13);
      HIDWORD(v89) = *(_DWORD *)(k + 100);
      v83 = *(_DWORD *)(k + 104);
      HIDWORD(va) = *(_DWORD *)(k + 108);
      v76 = *(_DWORD *)(k + 116);
      s.str = *(uint8 **)(k + 112);
      LODWORD(va) = *(_DWORD *)(k + 120);
      HIDWORD(v75) = *(_DWORD *)(k + 128);
      LODWORD(v75) = *(_DWORD *)(k + 136);
      v65 = *(_BYTE *)(k + 140);
      v64 = *(_BYTE *)(k + 141);
      runtime_printlock();
      lx.str = (uint8 *)"  M";
      lx.len = 3;
      runtime_printstring(lx);
      runtime_printint(v89 >> 32);
      ly.str = (uint8 *)": p=";
      ly.len = 4;
      runtime_printstring(ly);
      runtime_printint(v9);
      lz.str = (uint8 *)" curg=";
      lz.len = 6;
      runtime_printstring(lz);
      runtime_printint(id2_lo);
      lba.str = (uint8 *)" mallocing=";
      lba.len = 11;
      runtime_printstring(lba);
      runtime_printint(v83);
      lbb.str = (uint8 *)" throwing=";
      lbb.len = 10;
      runtime_printstring(lbb);
      runtime_printint(va >> 32);
      lbc.str = (uint8 *)" preemptoff=";
      lbc.len = 12;
      runtime_printstring(lbc);
      runtime_printstring((string)__PAIR64__(v76, (unsigned int)s.str));
      lbd.str = (uint8 *)" locks=";
      lbd.len = 7;
      runtime_printstring(lbd);
      runtime_printint((int)va);
      lbe.str = (uint8 *)" dying=";
      lbe.len = 7;
      runtime_printstring(lbe);
      runtime_printint(v75 >> 32);
      lbf.str = (uint8 *)" helpgc=";
      lbf.len = 8;
      runtime_printstring(lbf);
      runtime_printint((int)v75);
      lbg.str = (uint8 *)" spinning=";
      lbg.len = 10;
      runtime_printstring(lbg);
      runtime_printbool(v65);
      lbh.str = (uint8 *)" blocked=";
      lbh.len = 9;
      runtime_printstring(lbh);
      runtime_printbool(v64);
      lbi.str = (uint8 *)" lockedg=";
      lbi.len = 9;
      runtime_printstring(lbi);
      runtime_printint(id3_lo);
      lbj.str = (uint8 *)"\n";
      lbj.len = 1;
      runtime_printstring(lbj);
      runtime_printunlock();
    }
    runtime_lock(&runtime_allglock);
    for ( m = 0; m < runtime_allgs.len; m = gi + 1 )
    {
      if ( (unsigned int)m >= runtime_allgs.len )
        runtime_panicindex();
      v15 = runtime_allgs.array[m];
      v16 = v15->m;
      lockedm = v15->lockedm;
      if ( v16 )
        v18 = v16->id;
      else
        v18 = -1;
      gi = m;
      id1_0 = v18;
      if ( lockedm )
        v19 = lockedm->id;
      else
        v19 = -1;
      gp = runtime_allgs.array[m];
      l_4 = runtime_readgstatus(v15);
      goid = gp->goid;
      v87 = l_4;
      s.str = gp->waitreason.str;
      len = gp->waitreason.len;
      runtime_printlock();
      lbk.str = (uint8 *)"  G";
      lbk.len = 3;
      runtime_printstring(lbk);
      runtime_printint(goid);
      lbl.str = (uint8 *)": status=";
      lbl.len = 9;
      runtime_printstring(lbl);
      runtime_printint(v87);
      lbm.str = (uint8 *)"(";
      lbm.len = 1;
      runtime_printstring(lbm);
      runtime_printstring((string)__PAIR64__(len, (unsigned int)s.str));
      lbn.str = (uint8 *)") m=";
      lbn.len = 4;
      runtime_printstring(lbn);
      runtime_printint(id1_0);
      lbo.str = (uint8 *)" lockedm=";
      lbo.len = 9;
      runtime_printstring(lbo);
      runtime_printint(v19);
      lbp.str = (uint8 *)"\n";
      lbp.len = 1;
      runtime_printstring(lbp);
      runtime_printunlock();
    }
    runtime_unlock(&runtime_allglock);
    runtime_unlock(&runtime_sched.lock);
  }
  else
  {
    runtime_unlock(&runtime_sched.lock);
  }
}
// 80761B0: variable 'l' is possibly undefined
// 80E0D84: using guessed type char go_string__;
// 80E0D85: using guessed type char asc_80E0D85;
// 80E0D9B: using guessed type char asc_80E0D9B;

//----- (08076C40) --------------------------------------------------------
void __golang runtime_mput(runtime_m *mp)
{
  mp->schedlink = runtime_sched.midle;
  runtime_sched.midle = (runtime_muintptr)mp;
  ++runtime_sched.nmidle;
  runtime_checkdead();
}

//----- (08076C90) --------------------------------------------------------
runtime_g *__golang runtime_globrunqget(runtime_p *_p_, int32 max)
{
  int32 runqsize; // ebx
  int32 v3; // eax
  int32 v4; // ecx
  int32 v5; // eax
  int32 v6; // ecx
  runtime_g *runqhead; // eax
  int v8; // ecx
  runtime_g *gp; // eax
  int32 n; // [esp+Ch] [ebp-8h]
  runtime_guintptr v11; // [esp+10h] [ebp-4h]

  if ( !runtime_sched.runqsize )
    return 0;
  if ( !runtime_gomaxprocs )
    runtime_panicdivide();
  runqsize = runtime_sched.runqsize;
  if ( runtime_gomaxprocs == -1 )
    v3 = -runtime_sched.runqsize;
  else
    v3 = runtime_sched.runqsize / runtime_gomaxprocs;
  v4 = v3 + 1;
  if ( v3 + 1 <= runtime_sched.runqsize )
  {
    v5 = runtime_sched.runqsize;
    runqsize = v4;
  }
  else
  {
    v5 = runtime_sched.runqsize;
  }
  v6 = max;
  if ( max <= 0 || runqsize <= max )
    v6 = runqsize;
  if ( v6 > 128 )
    v6 = 128;
  runtime_sched.runqsize = v5 - v6;
  if ( v5 == v6 )
    runtime_sched.runqtail = 0;
  runqhead = (runtime_g *)runtime_sched.runqhead;
  v11 = runtime_sched.runqhead;
  runtime_sched.runqhead = *(_DWORD *)(runtime_sched.runqhead + 104);
  v8 = v6 - 1;
  while ( v8 > 0 )
  {
    n = v8;
    gp = (runtime_g *)runtime_sched.runqhead;
    runtime_sched.runqhead = *(_DWORD *)(runtime_sched.runqhead + 104);
    runtime_runqput(_p_, gp, 0);
    v8 = n - 1;
    runqhead = (runtime_g *)v11;
  }
  return runqhead;
}

//----- (08076D90) --------------------------------------------------------
void __golang runtime_pidleput(runtime_p *_p_)
{
  string s; // [esp+0h] [ebp-Ch]

  if ( !runtime_runqempty(_p_) )
  {
    s.str = (uint8 *)"pidleput: P has non-empty run queue";
    s.len = 35;
    runtime_throw(s);
    BUG();
  }
  _p_->link = runtime_sched.pidle;
  runtime_sched.pidle = (runtime_puintptr)_p_;
  runtime_internal_atomic_Xadd();
}

//----- (08076E10) --------------------------------------------------------
runtime_p *__golang runtime_pidleget()
{
  runtime_p *pidle; // eax
  runtime_p *v1; // [esp+Ch] [ebp-4h]

  pidle = (runtime_p *)runtime_sched.pidle;
  if ( runtime_sched.pidle )
  {
    v1 = (runtime_p *)runtime_sched.pidle;
    runtime_sched.pidle = *(_DWORD *)(runtime_sched.pidle + 12);
    runtime_internal_atomic_Xadd();
    return v1;
  }
  return pidle;
}

//----- (08076E70) --------------------------------------------------------
bool __golang runtime_runqempty(runtime_p *_p_)
{
  uint32 tail; // [esp+8h] [ebp-10h]
  uint32 head; // [esp+10h] [ebp-8h]

  do
  {
    head = runtime_internal_atomic_Load(&_p_->runqhead);
    tail = runtime_internal_atomic_Load(&_p_->runqtail);
    runtime_internal_atomic_Loaduintptr();
  }
  while ( runtime_internal_atomic_Load(&_p_->runqtail) != tail );
  return tail == head && tail == 0;
}

//----- (08076F20) --------------------------------------------------------
void __golang runtime_runqput(runtime_p *_p_, runtime_g *gp, bool next)
{
  runtime_g *v3; // eax
  uint32 v4; // eax
  uint32 t; // ebp
  runtime_guintptr gp_0; // [esp+14h] [ebp-8h]
  runtime_g *g; // [esp+18h] [ebp-4h]

  if ( next )
  {
    do
      gp_0 = _p_->runnext;
    while ( !runtime___ptr_guintptr__cas(&_p_->runnext, gp_0, (runtime_guintptr)gp) );
    v3 = (runtime_g *)gp_0;
    if ( !gp_0 )
      return;
  }
  else
  {
    v3 = gp;
  }
  g = v3;
  while ( 1 )
  {
    v4 = runtime_internal_atomic_Load(&_p_->runqhead);
    t = _p_->runqtail;
    if ( t - v4 < 0x100 )
      break;
    if ( runtime_runqputslow(_p_, g, v4, t) )
      return;
  }
  _p_->runq[(unsigned __int8)_p_->runqtail] = (runtime_guintptr)g;
  runtime_internal_atomic_Store();
}

//----- (08077020) --------------------------------------------------------
bool __golang runtime_runqputslow(runtime_p *_p_, runtime_g *gp, uint32 h, uint32 t)
{
  unsigned int i; // ecx
  unsigned int j; // ecx
  runtime_g *v6; // ecx
  runtime_g *v7; // edx
  string l; // [esp+0h] [ebp-218h]
  char v9; // [esp+Ch] [ebp-20Ch]
  runtime_g *batch[129]; // [esp+14h] [ebp-204h] BYREF

  while ( (unsigned int)&batch[27] <= *(_DWORD *)(*(_DWORD *)(__readgsdword(0) - 4) + 8) )
    runtime_morestack_noctxt();
  memset(batch, 0, sizeof(batch));
  if ( (t - h) >> 1 != 128 )
  {
    l.str = (uint8 *)"runqputslow: queue is not full";
    l.len = 30;
    runtime_throw(l);
    BUG();
  }
  for ( i = 0; i < 0x80; ++i )
    batch[i] = (runtime_g *)_p_->runq[(unsigned __int8)(i + h)];
  runtime_internal_atomic_Cas();
  if ( !v9 )
    return 0;
  batch[128] = gp;
  for ( j = 0; j < 0x80; ++j )
  {
    if ( j + 1 >= 0x81 )
      runtime_panicindex();
    batch[j]->schedlink = (runtime_guintptr)batch[j + 1];
  }
  runtime_lock(&runtime_sched.lock);
  v6 = batch[128];
  v7 = batch[0];
  batch[128]->schedlink = 0;
  if ( runtime_sched.runqtail )
    *(_DWORD *)(runtime_sched.runqtail + 104) = v7;
  else
    runtime_sched.runqhead = (runtime_guintptr)v7;
  runtime_sched.runqtail = (runtime_guintptr)v6;
  runtime_sched.runqsize += 129;
  runtime_unlock(&runtime_sched.lock);
  return 1;
}
// 807709D: conditional instruction was optimized away because ecx.4<80u
// 80770FD: conditional instruction was optimized away because ecx.4<80u
// 80770C9: variable 'v9' is possibly undefined

//----- (080771E0) --------------------------------------------------------
void __golang runtime_runqget(runtime_p *_p_, runtime_g *gp, bool inheritTime)
{
  runtime_p *v3; // eax
  runtime_guintptr old; // ecx
  bool v5; // [esp+Ch] [ebp-10h]

  while ( 1 )
  {
    v3 = _p_;
    old = _p_->runnext;
    if ( !old )
      break;
    v5 = runtime___ptr_guintptr__cas(&_p_->runnext, old, 0);
    if ( v5 )
      return;
  }
  while ( _p_->runqtail != runtime_internal_atomic_Load(&v3->runqhead) )
  {
    runtime_internal_atomic_Cas();
    if ( v5 )
      break;
    v3 = _p_;
  }
}
// 80771E0: could not find valid save-restore pair for ebx
// 8077291: variable 'v5' is possibly undefined

//----- (080772C0) --------------------------------------------------------
uint32 __golang runtime_runqgrab(runtime_p *_p_, runtime_guintptr (*batch)[256], uint32 batchHead, bool stealRunNextG)
{
  unsigned int v4; // eax
  unsigned int v5; // edx
  char v6; // bl
  unsigned int i; // esi
  uint32 old; // [esp+4h] [ebp-24h]
  bool v9; // [esp+Ch] [ebp-1Ch]
  runtime_guintptr next; // [esp+10h] [ebp-18h]
  uint32 n; // [esp+14h] [ebp-14h]
  uint32 h; // [esp+18h] [ebp-10h]

  while ( 1 )
  {
    while ( 1 )
    {
      h = runtime_internal_atomic_Load(&_p_->runqhead);
      old = runtime_internal_atomic_Load(&_p_->runqtail);
      v4 = (old - h) >> 1;
      v5 = old - h - v4;
      if ( old - h == v4 )
        break;
      if ( v5 <= 0x80 )
      {
        v6 = batchHead;
        for ( i = 0; i < v5; ++i )
        {
          (*batch)[(unsigned __int8)(i + v6)] = _p_->runq[(unsigned __int8)(i + h)];
          v6 = batchHead;
        }
        n = old - h - v4;
        runtime_internal_atomic_Cas();
        if ( v9 )
          return n;
      }
    }
    if ( !stealRunNextG || !_p_->runnext )
      break;
    next = _p_->runnext;
    runtime_usleep();
    v9 = runtime___ptr_guintptr__cas(&_p_->runnext, next, 0);
    if ( v9 )
    {
      (*batch)[(unsigned __int8)batchHead] = next;
      return 1;
    }
  }
  return 0;
}
// 807738A: variable 'v9' is possibly undefined

//----- (08077430) --------------------------------------------------------
runtime_g *__golang runtime_runqsteal(runtime_p *_p_, runtime_p *p2, bool stealRunNextG)
{
  runtime_g *v3; // ebp
  string s; // [esp+0h] [ebp-28h]
  uint32 v5; // [esp+10h] [ebp-18h]
  uint32 t; // [esp+14h] [ebp-14h]

  t = _p_->runqtail;
  v5 = runtime_runqgrab(p2, (runtime_guintptr (*)[256])_p_->runq, t, stealRunNextG);
  if ( !v5 )
    return 0;
  v3 = (runtime_g *)_p_->runq[(unsigned __int8)(v5 + t - 1)];
  if ( v5 == 1 )
    return (runtime_g *)_p_->runq[(unsigned __int8)t];
  if ( t - runtime_internal_atomic_Load(&_p_->runqhead) + v5 - 1 >= 0x100 )
  {
    s.str = (uint8 *)"runqsteal: runq overflow";
    s.len = 24;
    runtime_throw(s);
    BUG();
  }
  runtime_internal_atomic_Store();
  return v3;
}
// 8077430: could not find valid save-restore pair for ebx

//----- (08077540) --------------------------------------------------------
__int32 __golang sync_runtime_procPin()
{
  int v0; // eax

  v0 = *(_DWORD *)(*(_DWORD *)(__readgsdword(0) - 4) + 24);
  ++*(_DWORD *)(v0 + 120);
  return *(_DWORD *)(*(_DWORD *)(v0 + 92) + 4);
}

//----- (08077570) --------------------------------------------------------
void __golang sync_runtime_procUnpin()
{
  int v0; // eax

  v0 = *(_DWORD *)(*(_DWORD *)(__readgsdword(0) - 4) + 24);
  --*(_DWORD *)(v0 + 120);
}

//----- (08077590) --------------------------------------------------------
__int32 __golang sync_atomic_runtime_procPin()
{
  int v0; // eax

  v0 = *(_DWORD *)(*(_DWORD *)(__readgsdword(0) - 4) + 24);
  ++*(_DWORD *)(v0 + 120);
  return *(_DWORD *)(*(_DWORD *)(v0 + 92) + 4);
}

//----- (080775C0) --------------------------------------------------------
void __golang sync_atomic_runtime_procUnpin()
{
  int v0; // eax

  v0 = *(_DWORD *)(*(_DWORD *)(__readgsdword(0) - 4) + 24);
  --*(_DWORD *)(v0 + 120);
}

//----- (080775E0) --------------------------------------------------------
bool __golang sync_runtime_canSpin(__int32 i)
{
  return i < 4
      && runtime_ncpu > 1
      && runtime_gomaxprocs > (signed __int32)(runtime_sched.npidle + runtime_sched.nmspinning + 1)
      && runtime_runqempty(*(runtime_p **)(*(_DWORD *)(*(_DWORD *)(__readgsdword(0) - 4) + 24) + 92));
}

//----- (08077650) --------------------------------------------------------
void __golang sync_runtime_doSpin()
{
  runtime_procyield();
}

//----- (08077670) --------------------------------------------------------
void __golang runtime___ptr_randomOrder__reset(runtime_randomOrder_0 *ord, uint32 count)
{
  uint32 v2; // eax
  uint32 a; // edx
  runtime_randomOrder_0 *v4; // eax
  __int32 cap; // ecx
  uint32 *array; // edx
  __int32 len; // ebx
  uint32 v8; // ecx
  uint32 *v9; // eax
  __int32 v10; // ecx
  runtime_slice_0 b; // [esp+4h] [ebp-2Ch]
  runtime_slice_0 src; // [esp+14h] [ebp-1Ch]
  uint32 i; // [esp+20h] [ebp-10h]

  v2 = count;
  ord->count = count;
  ord->coprimes.len = 0;
  a = 1;
  while ( a <= v2 )
  {
    i = a;
    if ( runtime_gcd(a, v2) == 1 )
    {
      v4 = ord;
      cap = ord->coprimes.cap;
      array = ord->coprimes.array;
      len = ord->coprimes.len;
      if ( len + 1 > cap )
      {
        b.array = ord->coprimes.array;
        *(_QWORD *)&b.len = __PAIR64__(cap, len);
        src = runtime_growslice((runtime__type_0 *)&stru_80CF2A0, b, len + 1);
        v9 = (uint32 *)src.array;
        v10 = src.len;
        ord->coprimes.cap = src.cap;
        if ( *(_DWORD *)&runtime_writeBarrier.enabled )
        {
          runtime_writebarrierptr((uintptr *)&ord->coprimes, (uintptr)src.array);
          v9 = (uint32 *)src.array;
          v10 = src.len;
        }
        else
        {
          ord->coprimes.array = (uint32 *)src.array;
        }
        len = v10;
        array = v9;
        v4 = ord;
      }
      v4->coprimes.len = len + 1;
      v8 = i;
      array[len] = i;
    }
    else
    {
      v8 = i;
    }
    a = v8 + 1;
    v2 = count;
  }
}

//----- (08077790) --------------------------------------------------------
uint32 __golang runtime_gcd(uint32 a, uint32 b)
{
  uint32 v4; // ebx

  while ( b )
  {
    v4 = b;
    b = a % b;
    a = v4;
  }
  return a;
}

//----- (080777D0) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
runtime_profIndex __golang runtime___ptr_profAtomic__load(runtime_profAtomic *x)
{
  runtime_profIndex v1; // [esp+4h] [ebp-8h]

  runtime_internal_atomic_Load64();
  return v1;
}
// 80777D0: variables would overlap: ^14.8 and ^14.12

//----- (08077810) --------------------------------------------------------
bool __golang runtime___ptr_profAtomic__cas(runtime_profAtomic *x, runtime_profIndex old, runtime_profIndex newa)
{
  bool v3; // [esp+14h] [ebp-4h]

  runtime_internal_atomic_Cas64();
  return v3;
}
// 8077856: variable 'v3' is possibly undefined

//----- (08077870) --------------------------------------------------------
bool __golang runtime___ptr_profBuf__hasOverflow(runtime_profBuf *b)
{
  int v1; // [esp+4h] [ebp-8h]

  runtime_internal_atomic_Load64();
  return v1 != 0;
}
// 807789F: variable 'v1' is possibly undefined

//----- (080778B0) --------------------------------------------------------
void __golang runtime___ptr_profBuf__takeOverflow(runtime_profBuf *b, uint32 count, uint64 time)
{
  int v3; // [esp+4h] [ebp-2Ch]
  char v4; // [esp+14h] [ebp-1Ch]

  do
  {
    runtime_internal_atomic_Load64();
    runtime_internal_atomic_Load64();
    if ( !v3 )
      break;
    runtime_internal_atomic_Cas64();
  }
  while ( !v4 );
}
// 8077951: variable 'v3' is possibly undefined
// 8077987: variable 'v4' is possibly undefined

//----- (080779C0) --------------------------------------------------------
void __golang runtime___ptr_profBuf__incrementOverflow(runtime_profBuf *b, int64 now)
{
  int v2; // [esp+4h] [ebp-20h]
  char v3; // [esp+14h] [ebp-10h]

  while ( 1 )
  {
    runtime_internal_atomic_Load64();
    if ( !v2 )
      break;
    if ( v2 != -1 )
    {
      runtime_internal_atomic_Cas64();
      if ( !v3 )
        continue;
    }
    return;
  }
  runtime_internal_atomic_Store64();
  runtime_internal_atomic_Store64();
}
// 80779F8: variable 'v2' is possibly undefined
// 8077A20: variable 'v3' is possibly undefined

//----- (08077A90) --------------------------------------------------------
bool __golang runtime___ptr_profBuf__canWriteRecord(runtime_profBuf *b, __int32 nstk)
{
  unsigned __int32 len; // ebx
  __int32 v3; // ebp
  uintptr hdrsize; // edx
  unsigned int v5; // [esp+4h] [ebp-10h]
  runtime_profIndex v6; // [esp+8h] [ebp-Ch]
  uint32 x_hi; // [esp+10h] [ebp-4h]

  x_hi = runtime___ptr_profAtomic__load(&b->r);
  v6 = runtime___ptr_profAtomic__load(&b->w);
  if ( b->tags.len + ((int)(4 * ((x_hi >> 2) - ((unsigned int)v6 >> 2))) >> 2) < 1 )
    return 0;
  len = b->data.len;
  v3 = len + ((int)(4 * (HIDWORD(v6) - v5)) >> 2);
  hdrsize = b->hdrsize;
  if ( !len )
    runtime_panicdivide();
  if ( (int)(v5 % len + hdrsize + nstk + 2) > (int)len )
    v3 = ((int)(4 * (HIDWORD(v6) - v5)) >> 2) + v5 % len;
  return v3 >= (int)(hdrsize + nstk + 2);
}
// 8077B06: variable 'v5' is possibly undefined

//----- (08077B60) --------------------------------------------------------
bool __golang runtime___ptr_profBuf__canWriteTwoRecords(runtime_profBuf *b, __int32 nstk1, __int32 nstk2)
{
  unsigned __int32 len; // ebx
  int v4; // ebp
  uintptr hdrsize; // ecx
  int v6; // edx
  uintptr v7; // eax
  __int32 v8; // edi
  __int32 v9; // ebp
  unsigned int v10; // [esp+4h] [ebp-14h]
  runtime_profIndex v11; // [esp+8h] [ebp-10h]
  uint32 x_hi; // [esp+10h] [ebp-8h]

  x_hi = runtime___ptr_profAtomic__load(&b->r);
  v11 = runtime___ptr_profAtomic__load(&b->w);
  if ( b->tags.len + ((int)(4 * ((x_hi >> 2) - ((unsigned int)v11 >> 2))) >> 2) < 2 )
    return 0;
  len = b->data.len;
  v4 = len + ((int)(4 * (HIDWORD(v11) - v10)) >> 2);
  if ( !len )
    runtime_panicdivide();
  hdrsize = b->hdrsize;
  v6 = v10 % len;
  v7 = hdrsize + nstk1;
  v8 = b->data.len;
  if ( (int)(hdrsize + nstk1 + v10 % len + 2) > (int)len )
  {
    v4 = ((int)(4 * (HIDWORD(v11) - v10)) >> 2) + v6;
    v6 = 0;
  }
  v9 = v4 - (hdrsize + nstk1 + 2);
  if ( (int)(nstk2 + hdrsize + v7 + v6 + 4) > v8 )
    v9 -= v8 - (v7 + v6 + 2);
  return v9 >= (int)(hdrsize + nstk2 + 2);
}
// 8077BD6: variable 'v10' is possibly undefined

//----- (08077C60) --------------------------------------------------------
void __golang runtime___ptr_profBuf__write(runtime_profBuf *b, void **tagPtr, int64 now, __uint64 hdr, __uintptr stk)
{
  bool v5; // zf
  unsigned __int32 len; // ebp
  unsigned __int32 v7; // edx
  unsigned int v8; // edx
  uint64 *v9; // eax
  __int32 v10; // eax
  __int32 cap; // ebx
  unsigned __int32 v12; // ebp
  uint64 *array; // esi
  unsigned __int32 v14; // ebp
  int v15; // ebx
  __int32 hdrsize; // eax
  __int32 v17; // esi
  uint64 *v18; // eax
  unsigned __int32 v19; // ecx
  runtime_profBuf *v20; // edx
  uintptr i; // ebx
  uint64 *v22; // ebp
  uintptr *v23; // ebp
  __int32 j; // esi
  uintptr *v25; // edx
  uintptr v26; // edi
  unsigned int v27; // edx
  string s; // [esp+0h] [ebp-50h]
  bool s_4; // [esp+4h] [ebp-4Ch]
  uintptr s_4a; // [esp+4h] [ebp-4Ch]
  string s_4b; // [esp+4h] [ebp-4Ch]
  uint32 s_4c; // [esp+4h] [ebp-4Ch]
  uint64 nstk2; // [esp+8h] [ebp-48h]
  unsigned __int32 nstk2a; // [esp+8h] [ebp-48h]
  _BYTE nstk2b[20]; // [esp+8h] [ebp-48h]
  runtime_profIndex newa; // [esp+Ch] [ebp-44h]
  __uintptr v37; // [esp+1Ch] [ebp-34h]
  bool hasOverflow; // [esp+2Bh] [ebp-25h]
  char x_hi; // [esp+2Ch] [ebp-24h]
  uintptr stk_0[1]; // [esp+30h] [ebp-20h] BYREF
  __int32 skip; // [esp+34h] [ebp-1Ch]
  uintptr pc; // [esp+38h] [ebp-18h]
  __int32 data_len; // [esp+3Ch] [ebp-14h]
  __int32 data_cap; // [esp+40h] [ebp-10h]
  int v45; // [esp+44h] [ebp-Ch]
  uint64 *data_ptr; // [esp+48h] [ebp-8h]
  runtime_profAtomic *x; // [esp+4Ch] [ebp-4h]

  if ( !b )
    return;
  if ( hdr.len > (signed __int32)b->hdrsize )
  {
    s.str = (uint8 *)"misuse of profBuf.write";
    s.len = 23;
    runtime_throw(s);
    BUG();
  }
  s_4 = runtime___ptr_profBuf__hasOverflow(b);
  v5 = !s_4;
  if ( !s_4 )
    goto LABEL_4;
  hasOverflow = s_4;
  BYTE4(nstk2) = runtime___ptr_profBuf__canWriteTwoRecords(b, 1, stk.len);
  if ( !BYTE4(nstk2) )
  {
    v5 = !hasOverflow;
LABEL_4:
    if ( !v5 || !runtime___ptr_profBuf__canWriteRecord(b, stk.len) )
    {
      runtime___ptr_profBuf__incrementOverflow(b, now);
      runtime___ptr_profBuf__wakeupExtra(b);
      return;
    }
    goto LABEL_6;
  }
  runtime___ptr_profBuf__takeOverflow(b, s_4c, nstk2);
  if ( s_4a )
  {
    stk_0[0] = s_4a;
    *(_QWORD *)&nstk2b[4] = *(unsigned int *)&nstk2b[4];
    *(_QWORD *)&nstk2b[12] = 0LL;
    v37.array = stk_0;
    *(_QWORD *)&v37.len = 0x100000001LL;
    runtime___ptr_profBuf__write(b, 0, *(int64 *)nstk2b, *(__uint64 *)&nstk2b[8], v37);
  }
LABEL_6:
  runtime___ptr_profAtomic__load(&b->r);
  x = &b->w;
  nstk2a = runtime___ptr_profAtomic__load(&b->w);
  len = b->tags.len;
  if ( !len )
    runtime_panicdivide();
  if ( tagPtr )
    b->tags.array[(nstk2a >> 2) % len] = *tagPtr;
  v7 = b->data.len;
  if ( !v7 )
    runtime_panicdivide();
  v8 = s_4a % v7;
  if ( (signed int)(v8 + b->hdrsize + stk.len + 2) <= b->data.len )
  {
    v10 = 0;
  }
  else
  {
    v9 = &b->data.array[v8];
    *(_DWORD *)v9 = 0;
    *((_DWORD *)v9 + 1) = 0;
    v10 = b->data.len - v8;
    v8 = 0;
  }
  cap = b->data.cap;
  v12 = b->data.len;
  array = b->data.array;
  if ( v8 > v12 )
    runtime_panicslice();
  skip = v10;
  v14 = v12 - v8;
  data_cap = cap - v8;
  v15 = (8 * v8) & ((int)(v8 - cap) >> 31);
  if ( !v14 )
    runtime_panicindex();
  *(_DWORD *)((char *)array + v15) = stk.len + b->hdrsize + 2;
  *(_DWORD *)((char *)array + v15 + 4) = 0;
  if ( v14 <= 1 )
    runtime_panicindex();
  *(uint64 *)((char *)array + v15 + 8) = now;
  hdrsize = b->hdrsize;
  if ( (unsigned int)hdrsize >= 0xFFFFFFFE || hdrsize + 2 > (unsigned int)data_cap )
    runtime_panicslice();
  data_len = v14;
  data_ptr = (uint64 *)((char *)array + v15);
  v17 = hdr.len;
  if ( hdrsize <= hdr.len )
    v17 = hdrsize;
  v45 = v17;
  s_4b.str = (uint8 *)hdr.array;
  runtime_memmove();
  v18 = data_ptr;
  v19 = data_len;
  v20 = b;
  for ( i = v45; i < b->hdrsize; ++i )
  {
    if ( i + 2 >= v19 )
      runtime_panicindex();
    v22 = &v18[i + 2];
    *(_DWORD *)v22 = 0;
    *((_DWORD *)v22 + 1) = 0;
  }
  v23 = stk.array;
  for ( j = 0; j < stk.len; ++j )
  {
    v26 = *v23;
    v27 = v20->hdrsize + j + 2;
    if ( v27 >= v19 )
      runtime_panicindex();
    pc = *v23;
    v25 = (uintptr *)&v18[v27];
    *v25 = v26;
    v25[1] = 0;
    ++v23;
    v20 = b;
  }
  do
  {
    s_4b.len = runtime___ptr_profAtomic__load(x);
    x_hi = s_4b.len;
    LODWORD(newa) = &s_4b.str[b->hdrsize + 2 + skip + stk.len];
    HIDWORD(newa) = 4 * (((unsigned __int32)s_4b.len >> 2) + 1);
  }
  while ( !runtime___ptr_profAtomic__cas(x, *(_QWORD *)&s_4b, newa) );
  if ( (x_hi & 1) != 0 )
    runtime_notewakeup(&b->wait);
}
// 8077C60: could not find valid save-restore pair for edi
// 8077C60: could not find valid save-restore pair for esi
// 8077D38: variable 's_4a' is possibly undefined
// 8077ECD: variable 's_4b' is possibly undefined
// 8077F80: variable 's_4c' is possibly undefined
// 8077F80: variable 'nstk2' is possibly undefined
// 8077FB8: variable 'nstk2b' is possibly undefined

//----- (08078060) --------------------------------------------------------
void __golang runtime___ptr_profBuf__wakeupExtra(runtime_profBuf *b)
{
  runtime_profIndex v1; // [esp+4h] [ebp-1Ch]
  char old_hi; // [esp+18h] [ebp-8h]

  do
  {
    HIDWORD(v1) = runtime___ptr_profAtomic__load(&b->w);
    old_hi = BYTE4(v1);
  }
  while ( !runtime___ptr_profAtomic__cas(&b->w, v1, v1 | 0x200000000LL) );
  if ( (old_hi & 1) != 0 )
    runtime_notewakeup(&b->wait);
}
// 80780A8: variable 'v1' is possibly undefined

//----- (080780E0) --------------------------------------------------------
__string __golang syscall_runtime_envs()
{
  string *array; // eax
  unsigned __int32 len; // ecx
  unsigned __int32 cap; // edx
  runtime_slice_0 dst; // [esp+4h] [ebp-28h]
  runtime_slice_0 dsta; // [esp+4h] [ebp-28h]
  runtime_slice_0 src_4; // [esp+14h] [ebp-18h]
  __int32 v6; // [esp+20h] [ebp-Ch]
  __int32 v7; // [esp+24h] [ebp-8h]
  string *v8; // [esp+28h] [ebp-4h]
  __string _r0; // [esp+30h] [ebp+4h]

  dst.array = runtime_newobject((runtime__type_0 *)&stru_80CAE20);
  array = (string *)dst.array;
  len = runtime_envs.len;
  v7 = runtime_envs.len;
  if ( runtime_envs.len )
  {
    *(_QWORD *)&dst.len = 0LL;
    src_4 = runtime_growslice((runtime__type_0 *)&t, dst, runtime_envs.len);
    cap = src_4.cap;
    array = (string *)src_4.array;
    len = v7;
  }
  else
  {
    cap = 0;
  }
  if ( len > cap )
    runtime_panicslice();
  v6 = cap;
  v8 = array;
  dsta.array = array;
  *(_QWORD *)&dsta.len = __PAIR64__(cap, len);
  runtime_typedslicecopy((runtime__type_0 *)&t, dsta, (runtime_slice_0)runtime_envs);
  _r0.array = v8;
  _r0.len = v7;
  _r0.cap = v6;
  return _r0;
}

//----- (080781D0) --------------------------------------------------------
__string __golang os_runtime_args()
{
  string *array; // eax
  unsigned __int32 len; // ecx
  unsigned __int32 cap; // edx
  runtime_slice_0 dst; // [esp+4h] [ebp-28h]
  runtime_slice_0 dsta; // [esp+4h] [ebp-28h]
  runtime_slice_0 src_4; // [esp+14h] [ebp-18h]
  __int32 v6; // [esp+20h] [ebp-Ch]
  __int32 v7; // [esp+24h] [ebp-8h]
  string *v8; // [esp+28h] [ebp-4h]
  __string _r0; // [esp+30h] [ebp+4h]

  dst.array = runtime_newobject((runtime__type_0 *)&stru_80CAE20);
  array = (string *)dst.array;
  len = runtime_argslice.len;
  v7 = runtime_argslice.len;
  if ( runtime_argslice.len )
  {
    *(_QWORD *)&dst.len = 0LL;
    src_4 = runtime_growslice((runtime__type_0 *)&t, dst, runtime_argslice.len);
    cap = src_4.cap;
    array = (string *)src_4.array;
    len = v7;
  }
  else
  {
    cap = 0;
  }
  if ( len > cap )
    runtime_panicslice();
  v6 = cap;
  v8 = array;
  dsta.array = array;
  *(_QWORD *)&dsta.len = __PAIR64__(cap, len);
  runtime_typedslicecopy((runtime__type_0 *)&t, dsta, (runtime_slice_0)runtime_argslice);
  _r0.array = v8;
  _r0.len = v7;
  _r0.cap = v6;
  return _r0;
}

//----- (080782C0) --------------------------------------------------------
void __golang runtime_gotraceback(int32 level, bool all, bool crash)
{
  runtime_internal_atomic_Load(&runtime_traceback_cache);
}

//----- (08078340) --------------------------------------------------------
void __golang runtime_args(int32 c, uint8 **v)
{
  int32 argc; // eax
  uint8 **argv; // ecx

  argc = c;
  runtime_argc = c;
  if ( *(_DWORD *)&runtime_writeBarrier.enabled )
  {
    runtime_writebarrierptr(&runtime_argv, (uintptr)v);
    argc = c;
    argv = v;
  }
  else
  {
    argv = v;
    runtime_argv = (uintptr)v;
  }
  runtime_sysargs(argc, argv);
}

//----- (080783B0) --------------------------------------------------------
void __golang runtime_goargs()
{
  int32 j; // eax
  string *array; // eax
  unsigned __int32 v2; // ebp
  uintptr *v3; // eax
  string len; // [esp+4h] [ebp-18h]
  runtime_slice_0 src; // [esp+Ch] [ebp-10h]
  unsigned __int32 i; // [esp+18h] [ebp-4h]

  src = runtime_makeslice((runtime__type_0 *)&t, runtime_argc, runtime_argc);
  runtime_argslice.len = src.len;
  runtime_argslice.cap = src.cap;
  if ( *(_DWORD *)&runtime_writeBarrier.enabled )
    runtime_writebarrierptr((uintptr *)&runtime_argslice, (uintptr)src.array);
  else
    runtime_argslice.array = (string *)src.array;
  for ( j = 0; j < runtime_argc; j = v2 + 1 )
  {
    i = j;
    len = runtime_gostringnocopy((uint8 *)*(_DWORD *)(runtime_argv + 4 * j));
    array = runtime_argslice.array;
    v2 = i;
    if ( i >= runtime_argslice.len )
      runtime_panicindex();
    runtime_argslice.array[i].len = len.len;
    v3 = (uintptr *)&array[i];
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
    {
      runtime_writebarrierptr(v3, (uintptr)len.str);
      v2 = i;
    }
    else
    {
      *v3 = (uintptr)len.str;
    }
  }
}
// 80783B0: could not find valid save-restore pair for ebx
// 80783B0: could not find valid save-restore pair for ebp

//----- (080784B0) --------------------------------------------------------
void __golang runtime_goenvs_unix()
{
  __int32 cap; // eax
  signed __int32 j; // eax
  string *array; // eax
  unsigned __int32 v3; // ebp
  uintptr *v4; // eax
  string len; // [esp+4h] [ebp-1Ch]
  runtime_slice_0 src; // [esp+Ch] [ebp-14h]
  int32 n; // [esp+18h] [ebp-8h]
  unsigned __int32 i; // [esp+1Ch] [ebp-4h]

  for ( cap = 0; *(_DWORD *)(runtime_argv + 4 * (cap + runtime_argc + 1)); ++cap )
    ;
  n = cap;
  src = runtime_makeslice((runtime__type_0 *)&t, cap, cap);
  runtime_envs.len = src.len;
  runtime_envs.cap = src.cap;
  if ( *(_DWORD *)&runtime_writeBarrier.enabled )
    runtime_writebarrierptr((uintptr *)&runtime_envs, (uintptr)src.array);
  else
    runtime_envs.array = (string *)src.array;
  for ( j = 0; j < n; j = v3 + 1 )
  {
    i = j;
    len = runtime_gostring((uint8 *)*(_DWORD *)(runtime_argv + 4 * (runtime_argc + j + 1)));
    array = runtime_envs.array;
    v3 = i;
    if ( i >= runtime_envs.len )
      runtime_panicindex();
    runtime_envs.array[i].len = len.len;
    v4 = (uintptr *)&array[i];
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
    {
      runtime_writebarrierptr(v4, (uintptr)len.str);
      v3 = i;
    }
    else
    {
      *v4 = (uintptr)len.str;
    }
  }
}
// 80784B0: could not find valid save-restore pair for ebx
// 80784B0: could not find valid save-restore pair for ebp

//----- (080785D0) --------------------------------------------------------
void __golang runtime_testAtomic64()
{
  string ptr; // [esp+0h] [ebp-28h]
  string ptra; // [esp+0h] [ebp-28h]
  string ptrb; // [esp+0h] [ebp-28h]
  char v3; // [esp+14h] [ebp-14h]

  runtime_test_z64 = 42LL;
  runtime_test_x64 = 0LL;
  runtime_prefetcht0();
  runtime_prefetcht1();
  runtime_prefetcht2();
  runtime_prefetchnta();
  runtime_internal_atomic_Cas64();
  if ( !v3 )
  {
    if ( HIDWORD(runtime_test_x64) == 0 && (_DWORD)runtime_test_x64 == 0 )
    {
      runtime_test_x64 = 42LL;
      runtime_internal_atomic_Cas64();
      ptr.str = (uint8 *)"cas64 failed";
      ptr.len = 12;
      runtime_throw(ptr);
      BUG();
    }
    ptra.str = (uint8 *)"cas64 failed";
    ptra.len = 12;
    runtime_throw(ptra);
    BUG();
  }
  ptrb.str = (uint8 *)"cas64 failed";
  ptrb.len = 12;
  runtime_throw(ptrb);
  BUG();
}
// 807870D: conditional instruction was optimized away because %var_14.1==0
// 807869A: variable 'v3' is possibly undefined

//----- (080789A0) --------------------------------------------------------
void __golang runtime_check()
{
  string v; // [esp+0h] [ebp-40h]
  string va; // [esp+0h] [ebp-40h]
  string vb; // [esp+0h] [ebp-40h]
  char rem; // [esp+Ch] [ebp-34h]
  int32 e; // [esp+24h] [ebp-1Ch] BYREF
  float64 j1; // [esp+28h] [ebp-18h]
  float64 j; // [esp+30h] [ebp-10h]
  void *k; // [esp+3Ch] [ebp-4h]

  e = 0;
  j = 0.0;
  j1 = 0.0;
  k = 0;
  if ( runtime_timediv(0xB3A4B57CE31LL, 1000000000, &e) == 12345 && e == 54321 )
  {
    runtime_internal_atomic_Cas();
    if ( rem )
    {
      v.str = (uint8 *)"cas2";
      v.len = 4;
      runtime_throw(v);
      BUG();
    }
    va.str = (uint8 *)"cas1";
    va.len = 4;
    runtime_throw(va);
    BUG();
  }
  vb.str = (uint8 *)"bad timediv";
  vb.len = 11;
  runtime_throw(vb);
  BUG();
}
// 8078A9A: conditional instruction was optimized away because %rem.1!=0
// 8078A5C: variable 'rem' is possibly undefined

//----- (08078EC0) --------------------------------------------------------
void __golang runtime_parsedebugvars()
{
  __int32 len; // eax
  uint8 *str; // ecx
  uint8 *v2; // eax
  __int32 v3; // ecx
  unsigned __int32 v4; // edx
  __int32 v5; // eax
  __int32 v6; // edx
  runtime_dbgVar_0 *array; // ebp
  __int32 v8; // esi
  __int32 i; // edi
  __int32 v10; // edx
  uint8 *v11; // esi
  string key; // [esp+0h] [ebp-40h]
  string keya; // [esp+0h] [ebp-40h]
  string tb; // [esp+8h] [ebp-38h]
  string tc; // [esp+8h] [ebp-38h]
  string td; // [esp+8h] [ebp-38h]
  string t; // [esp+8h] [ebp-38h]
  string ta; // [esp+8h] [ebp-38h]
  string te; // [esp+8h] [ebp-38h]
  __int32 v20; // [esp+10h] [ebp-30h]
  __int32 v21; // [esp+10h] [ebp-30h]
  __int32 value_len; // [esp+14h] [ebp-2Ch]
  __int32 p_len; // [esp+18h] [ebp-28h]
  unsigned __int32 field_len; // [esp+20h] [ebp-20h]
  unsigned __int32 field_lena; // [esp+20h] [ebp-20h]
  __int32 v26; // [esp+28h] [ebp-18h]
  uint8 *value_ptr; // [esp+2Ch] [ebp-14h]
  int32 *v_value; // [esp+30h] [ebp-10h]
  uint8 *p_ptr; // [esp+34h] [ebp-Ch]
  uint8 *key_ptr; // [esp+38h] [ebp-8h]

  runtime_debug.cgocheck = 1;
  runtime_debug.invalidptr = 1;
  key.str = (uint8 *)"GODEBUG";
  key.len = 7;
  tb = runtime_gogetenv(key);
  len = tb.len;
  str = tb.str;
  while ( len )
  {
    field_len = len;
    key_ptr = str;
    tc.str = (uint8 *)",";
    tc.len = 1;
    v20 = runtime_index((string)__PAIR64__(len, (unsigned int)str), tc);
    if ( v20 >= 0 )
    {
      if ( v20 > field_len || (v10 = v20 + 1, v20 + 1 > field_len) )
        runtime_panicslice();
      v11 = &key_ptr[v10 & ((int)(v10 - field_len) >> 31)];
      v3 = field_len - v10;
      v4 = v20;
      v2 = v11;
    }
    else
    {
      v2 = 0;
      v3 = 0;
      v4 = field_len;
    }
    field_lena = v4;
    p_ptr = v2;
    p_len = v3;
    td.str = (uint8 *)"=";
    td.len = 1;
    v21 = runtime_index((string)__PAIR64__(v4, (unsigned int)key_ptr), td);
    v5 = v21;
    if ( v21 >= 0 )
    {
      if ( v21 > field_lena || (v6 = v21 + 1, v21 + 1 > field_lena) )
        runtime_panicslice();
      value_len = field_lena - v6;
      value_ptr = &key_ptr[v6 & ((int)(v6 - field_lena) >> 31)];
      if ( v21 == 14 )
      {
        runtime_eqstring();
        ta = (string)runtime_atoi((string)__PAIR64__(value_len, (unsigned int)value_ptr));
        if ( LOBYTE(ta.len) )
          runtime_MemProfileRate = (__int32)ta.str;
      }
      else
      {
        array = runtime_dbgvars.array;
        v8 = runtime_dbgvars.len;
        v26 = runtime_dbgvars.len;
        for ( i = 0; i < v8; ++i )
        {
          v_value = array->value;
          if ( array->name.len == v5 )
          {
            runtime_eqstring();
            if ( (_BYTE)v21 )
            {
              t = (string)runtime_atoi32((string)__PAIR64__(value_len, (unsigned int)value_ptr));
              if ( LOBYTE(t.len) )
                *v_value = (int32)t.str;
              v5 = v21;
              v8 = v26;
            }
            else
            {
              v5 = v21;
              v8 = v26;
            }
          }
          ++array;
        }
      }
    }
    len = p_len;
    str = p_ptr;
  }
  keya.str = (uint8 *)"GOTRACEBACK";
  keya.len = 11;
  te = runtime_gogetenv(keya);
  runtime_debug_SetTraceback(te);
  runtime_traceback_env = runtime_traceback_cache;
  if ( runtime_debug.cgocheck > 1 )
  {
    runtime_writeBarrier.cgo = 1;
    runtime_writeBarrier.enabled = 1;
  }
}
// 80790A3: conditional instruction was optimized away because %var_30.1==E
// 80E0D89: using guessed type char asc_80E0D89;
// 80E0D91: using guessed type char asc_80E0D91;

//----- (08079190) --------------------------------------------------------
void __golang runtime_debug_SetTraceback(string level)
{
  __int32 len; // eax
  uint8 *str; // ecx
  bool v3; // zf
  bool v4; // zf
  int v5; // [esp+10h] [ebp-4h]

  len = level.len;
  if ( level.len < 4 )
    goto LABEL_2;
  if ( level.len == 4 )
  {
    runtime_cmpstring();
    if ( v5 <= 0 )
    {
      len = 4;
LABEL_2:
      if ( len )
      {
        if ( len == 3 )
        {
          str = level.str;
          if ( *(_WORD *)level.str == 27745 )
          {
            if ( level.str[2] == 108 )
              goto LABEL_3;
            v3 = 0;
          }
          else
          {
            v3 = 0;
          }
        }
        else
        {
          v3 = len == 4;
          str = level.str;
        }
        if ( !v3 || *(_DWORD *)str != 1701736302 )
        {
LABEL_10:
          runtime_atoi((string)__PAIR64__(len, (unsigned int)str));
          goto LABEL_3;
        }
      }
      goto LABEL_3;
    }
    len = 4;
  }
  if ( len == 5 )
  {
    str = level.str;
    if ( *(_DWORD *)level.str == 1935766115 && level.str[4] == 104 )
      goto LABEL_3;
  }
  else
  {
    str = level.str;
  }
  v4 = len == 6;
  if ( len == 6 )
  {
    if ( *(_DWORD *)str == 1735289203 )
    {
      if ( *((_WORD *)str + 2) == 25964 )
        goto LABEL_3;
      v4 = 1;
    }
    else
    {
      v4 = 1;
    }
  }
  if ( !v4 || *(_DWORD *)str != 1953724787 || *((_WORD *)str + 2) != 28005 )
    goto LABEL_10;
LABEL_3:
  runtime_internal_atomic_Store();
}
// 8079313: variable 'v5' is possibly undefined

//----- (08079340) --------------------------------------------------------
int32 __golang runtime_timediv(int64 v, int32 div, int32 *rem)
{
  int32 v3; // eax
  int v4; // edx
  unsigned __int32 v5; // ebx
  int v6; // ecx
  int32 v7; // ebp
  int v8; // edi
  int v9; // esi
  unsigned int v10; // eax
  unsigned int v11; // ecx
  int32 v12; // ebp
  bool v13; // cf
  unsigned __int32 v14; // ecx
  int v15; // esi
  bool v16; // bl
  unsigned __int32 v17; // ebp
  unsigned int v18; // ecx
  unsigned __int32 v19; // edx
  int v20; // edi
  int32 v21; // eax
  int32 res; // [esp+0h] [ebp-Ch]
  int v_4; // [esp+14h] [ebp+8h]

  v3 = div;
  v4 = HIDWORD(v);
  v5 = v;
  v6 = 30;
  v7 = 0;
  while ( v6 >= 0 )
  {
    v_4 = v4;
    res = v7;
    v8 = ((unsigned __int64)(unsigned int)v6 - 32) >> 32;
    v9 = v8 & (v3 >> 31 << v6) | ((unsigned int)(32 - v6) < 0x20 ? (unsigned int)v3 >> (32 - v6) : 0);
    v10 = v6;
    v11 = v6 - 32;
    v12 = div << v11;
    v13 = v11 < 0x20;
    v14 = v5;
    v15 = (v13 ? v12 : 0) | v9;
    v16 = v4 == v15;
    v17 = v14;
    v18 = v10;
    v19 = v8 & (div << v10);
    v20 = v_4;
    if ( v_4 > v15 || v17 >= v19 && v16 )
    {
      v20 = (__PAIR64__(v_4, v17) - __PAIR64__(v15, v19)) >> 32;
      v17 -= v19;
      v21 = res + (v10 < 0x20 ? 1 << v10 : 0);
    }
    else
    {
      v21 = res;
    }
    v6 = v18 - 1;
    v5 = v17;
    v4 = v20;
    v7 = v21;
    v3 = div;
  }
  if ( v4 > v3 >> 31 || v5 >= v3 && v4 == v3 >> 31 )
  {
    if ( rem )
      *rem = 0;
    return 0x7FFFFFFF;
  }
  else
  {
    if ( rem )
      *rem = v5;
    return v7;
  }
}

//----- (08079460) --------------------------------------------------------
retval_8079460 __golang reflect_typelinks()
{
  uintptr types; // ebx
  __int32 *v1; // ecx
  __int32 cap; // edx
  uintptr array; // eax
  __int32 v4; // eax
  __int32 v5; // edx
  __int32 v6; // ebp
  __int32 v7; // esi
  __int32 v8; // edi
  runtime_moduledata_0 **v9; // ebx
  runtime_moduledata_0 *v10; // eax
  __int32 v11; // edx
  __int32 v12; // ebx
  uintptr v13; // ecx
  __int32 v14; // ecx
  uintptr v15; // edx
  __int32 v16; // ebx
  __int32 v17; // eax
  int v18; // ebp
  ___runtime_moduledata typ; // [esp+0h] [ebp-8Ch]
  runtime_slice_0 src; // [esp+4h] [ebp-88h]
  runtime_slice_0 srca; // [esp+4h] [ebp-88h]
  runtime_slice_0 v22; // [esp+14h] [ebp-78h]
  runtime_slice_0 v23; // [esp+14h] [ebp-78h]
  __int32 sections_len; // [esp+20h] [ebp-6Ch]
  __int32 ret_len; // [esp+28h] [ebp-64h]
  __int32 modules_len; // [esp+30h] [ebp-5Ch]
  __int32 v27; // [esp+38h] [ebp-54h]
  __int32 v28; // [esp+44h] [ebp-48h]
  void **sections_ptr; // [esp+5Ch] [ebp-30h]
  __int32 *ret_ptr; // [esp+60h] [ebp-2Ch]
  runtime_moduledata_0 **modules_ptr; // [esp+64h] [ebp-28h]
  runtime_moduledata_0 *md; // [esp+68h] [ebp-24h]
  __int32 *v33; // [esp+6Ch] [ebp-20h]
  uintptr v34; // [esp+70h] [ebp-1Ch]
  uintptr v35; // [esp+74h] [ebp-18h]
  runtime_moduledata_0 **v36; // [esp+78h] [ebp-14h]
  runtime_slice_0 old; // [esp+7Ch] [ebp-10h] BYREF
  int len; // [esp+88h] [ebp-4h]
  retval_8079460 _r0; // [esp+90h] [ebp+4h]

  while ( (unsigned int)&old.len <= *(_DWORD *)(*(_DWORD *)(__readgsdword(0) - 4) + 8) )
    runtime_morestack_noctxt();
  typ = runtime_activeModules();
  modules_len = typ.len;
  modules_ptr = typ.array;
  typ.len = (__int32)runtime_newobject((runtime__type_0 *)&stru_80CBE60);
  if ( !modules_len )
    runtime_panicindex();
  len = typ.len;
  types = (*modules_ptr)->types;
  old.cap = (__int32)modules_ptr + (((1 - typ.cap) >> 31) & 4);
  if ( *(_DWORD *)&runtime_writeBarrier.enabled )
    runtime_writebarrierptr((uintptr *)typ.len, types);
  else
    *(_DWORD *)typ.len = types;
  v1 = (__int32 *)runtime_newobject((runtime__type_0 *)&stru_80CBC20);
  cap = (*modules_ptr)->typelinks.cap;
  array = (uintptr)(*modules_ptr)->typelinks.array;
  v1->len = (*modules_ptr)->typelinks.len;
  v1->cap = cap;
  if ( *(_DWORD *)&runtime_writeBarrier.enabled )
  {
    v33 = v1;
    runtime_writebarrierptr((uintptr *)v1, array);
    v1 = v33;
  }
  else
  {
    v1->array = (int32 *)array;
  }
  v4 = modules_len - 1;
  v5 = 0;
  v6 = 1;
  v7 = 1;
  v8 = 1;
  sections_len = 1;
  old.len = len;
  v9 = (runtime_moduledata_0 **)old.cap;
  while ( v5 < v4 )
  {
    v28 = v5;
    old.array = v1;
    v36 = v9;
    v10 = *v9;
    md = v10;
    v11 = sections_len;
    v12 = sections_len + 1;
    v13 = v10->types;
    if ( sections_len + 1 > v8 )
    {
      v34 = v10->types;
      srca.array = (void *)old.len;
      *(_QWORD *)&srca.len = __PAIR64__(v8, sections_len);
      v23 = runtime_growslice((runtime__type_0 *)&x, srca, sections_len + 1);
      v8 = v23.cap;
      v12 = v23.len + 1;
      v13 = v34;
      v11 = sections_len;
      sections_ptr = (void **)v23.array;
      v10 = md;
    }
    else
    {
      sections_ptr = (void **)old.len;
    }
    sections_len = v12;
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
    {
      runtime_writebarrierptr((uintptr *)&sections_ptr[v11], v13);
      v10 = md;
    }
    else
    {
      sections_ptr[v11] = (void *)v13;
    }
    v14 = v6 + 1;
    v15 = (uintptr)v10->typelinks.array;
    v16 = v10->typelinks.len;
    v17 = v10->typelinks.cap;
    if ( v6 + 1 > v7 )
    {
      v35 = v15;
      v27 = v17;
      src.array = old.array;
      *(_QWORD *)&src.len = __PAIR64__(v7, v6);
      v22 = runtime_growslice((runtime__type_0 *)&stru_80C9640, src, v6 + 1);
      v7 = v22.cap;
      v14 = v22.len + 1;
      v15 = v35;
      ret_ptr = (__int32 *)v22.array;
      v17 = v27;
    }
    else
    {
      ret_ptr = (__int32 *)old.array;
    }
    ret_len = v14;
    v18 = v6;
    v1 = ret_ptr;
    ret_ptr[v18].len = v16;
    ret_ptr[v18].cap = v17;
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
    {
      runtime_writebarrierptr((uintptr *)&ret_ptr[v18], v15);
      v1 = ret_ptr;
    }
    else
    {
      ret_ptr[v18].array = (int32 *)v15;
    }
    v9 = v36 + 1;
    v5 = v28 + 1;
    v6 = ret_len;
    old.len = (__int32)sections_ptr;
    v4 = modules_len - 1;
  }
  _r0._r0.array = (void **)old.len;
  _r0._r0.len = sections_len;
  _r0._r0.cap = v8;
  _r0._r1.array = v1;
  _r0._r1.len = v6;
  _r0._r1.cap = v7;
  return _r0;
}

//----- (080797C0) --------------------------------------------------------
void *__golang reflect_resolveNameOff(void *ptrInModule, int32 off)
{
  return (void *)runtime_resolveNameOff(ptrInModule, off);
}

//----- (08079800) --------------------------------------------------------
void *__golang reflect_resolveTypeOff(void *rtype, int32 off)
{
  return runtime___ptr__type__typeOff((runtime__type_0 *)rtype, off);
}

//----- (08079840) --------------------------------------------------------
void *__golang reflect_resolveTextOff(void *rtype, int32 off)
{
  return runtime___ptr__type__textOff((runtime__type_0 *)rtype, off);
}

//----- (08079880) --------------------------------------------------------
int32 __golang reflect_addReflectOff(void *ptr)
{
  uint32 v1; // eax
  void *v2; // ecx
  retval_80511B0 dsta; // [esp+Ch] [ebp-14h]
  uintptr *dst; // [esp+Ch] [ebp-14h]
  hash<int32,unsafe_Pointer> *src; // [esp+14h] [ebp-Ch]
  hash<unsafe_Pointer,int32> *srca; // [esp+14h] [ebp-Ch]
  int32 id; // [esp+18h] [ebp-8h]
  uint32 key; // [esp+1Ch] [ebp-4h]

  runtime_reflectOffsLock();
  if ( !runtime_reflectOffs.m )
  {
    src = (hash<int32,unsafe_Pointer> *)runtime_makemap((runtime_maptype_0 *)&stru_80CFA40, 0LL, 0, 0);
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr((uintptr *)&runtime_reflectOffs.m, (uintptr)src);
    else
      runtime_reflectOffs.m = src;
    srca = (hash<unsafe_Pointer,int32> *)runtime_makemap((runtime_maptype_0 *)&stru_80CFC40, 0LL, 0, 0);
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr((uintptr *)&runtime_reflectOffs.minv, (uintptr)srca);
    else
      runtime_reflectOffs.minv = srca;
    runtime_reflectOffs.next = -1;
  }
  dsta = runtime_mapaccess2_fast32(
           (runtime_maptype_0 *)&stru_80CFC40,
           (runtime_hmap *)runtime_reflectOffs.minv,
           (uint32)ptr);
  v1 = *(_DWORD *)dsta._r3;
  if ( !dsta._r4 )
  {
    key = runtime_reflectOffs.next--;
    dst = (uintptr *)runtime_mapassign_fast32(
                       (runtime_maptype_0 *)&stru_80CFA40,
                       (runtime_hmap *)runtime_reflectOffs.m,
                       key);
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
    {
      runtime_writebarrierptr(dst, (uintptr)ptr);
      v2 = ptr;
    }
    else
    {
      v2 = ptr;
      *dst = (uintptr)ptr;
    }
    *(_DWORD *)runtime_mapassign_fast32(
                 (runtime_maptype_0 *)&stru_80CFC40,
                 (runtime_hmap *)runtime_reflectOffs.minv,
                 (uint32)v2) = key;
    v1 = key;
  }
  id = v1;
  runtime_reflectOffsUnlock();
  return id;
}

//----- (08079A40) --------------------------------------------------------
bool __golang runtime___ptr_guintptr__cas(runtime_guintptr *gp, runtime_guintptr old, runtime_guintptr newa)
{
  bool v3; // [esp+Ch] [ebp-4h]

  runtime_internal_atomic_Casuintptr();
  return v3;
}
// 8079A64: variable 'v3' is possibly undefined

//----- (08079A70) --------------------------------------------------------
void __golang runtime_extendRandom(__uint8 r, __int32 n)
{
  __int32 v2; // eax
  int i; // ebp
  __int32 v4; // ebx
  uintptr v5; // eax
  int v6; // edx
  uintptr seed; // [esp+0h] [ebp-18h]
  __int32 w; // [esp+10h] [ebp-8h]
  uintptr s; // [esp+14h] [ebp-4h]

  v2 = n;
  if ( n < 0 )
    v2 = 0;
  while ( v2 < r.len )
  {
    w = v2;
    if ( v2 <= 16 )
      v6 = v2;
    else
      v6 = 16;
    s = v6;
    runtime_nanotime();
    if ( w - s >= r.len )
      runtime_panicindex();
    v5 = runtime_memhash(&r.array[w - s], seed, s);
    v4 = w;
    for ( i = 0; i < 4 && v4 < r.len; ++i )
    {
      if ( (unsigned int)v4 >= r.len )
        runtime_panicindex();
      r.array[v4++] = v5;
      v5 >>= 8;
    }
    v2 = v4;
  }
}
// 8079AF1: variable 'seed' is possibly undefined

//----- (08079B30) --------------------------------------------------------
void __golang runtime___ptr_rwmutex__rlock(runtime_rwmutex_0 *rw)
{
  int v1; // ecx
  int v2; // [esp+8h] [ebp-Ch]

  v1 = *(_DWORD *)(*(_DWORD *)(__readgsdword(0) - 4) + 24);
  ++*(_DWORD *)(v1 + 120);
  runtime_internal_atomic_Xadd();
  if ( v2 < 0 )
    runtime_systemstack();
}
// 8079B7D: variable 'v2' is possibly undefined

//----- (08079BB0) --------------------------------------------------------
void __golang runtime___ptr_rwmutex__runlock(runtime_rwmutex_0 *rw)
{
  int v1; // eax
  int v2; // ecx
  int v3; // edx
  string l; // [esp+0h] [ebp-Ch]
  int v5; // [esp+8h] [ebp-4h]

  runtime_internal_atomic_Xadd();
  if ( v5 < 0 )
  {
    if ( v5 == -1 || v5 == -1073741825 )
    {
      l.str = (uint8 *)"runlock of unlocked rwmutex";
      l.len = 27;
      runtime_throw(l);
      BUG();
    }
    runtime_internal_atomic_Xadd();
  }
  v1 = *(_DWORD *)(__readgsdword(0) - 4);
  v2 = *(_DWORD *)(v1 + 24);
  v3 = *(_DWORD *)(v2 + 120);
  *(_DWORD *)(v2 + 120) = v3 - 1;
  if ( v3 == 1 )
  {
    if ( *(_BYTE *)(v1 + 108) )
      *(_DWORD *)(v1 + 8) = -1314;
  }
}
// 8079C1B: conditional instruction was optimized away because %var_4.4 is in (<-40000001|C0000000..FFFFFFFE)
// 8079BE8: variable 'v5' is possibly undefined

//----- (08079CB0) --------------------------------------------------------
void __golang internal_poll_runtime_Semacquire(uint32 *addr)
{
  runtime_semacquire1(addr, 0, 1);
}

//----- (08079CF0) --------------------------------------------------------
void __golang sync_runtime_Semrelease(uint32 *addr, bool handoff)
{
  runtime_semrelease1(addr, handoff);
}

//----- (08079D30) --------------------------------------------------------
void __golang sync_runtime_SemacquireMutex(uint32 *addr, bool lifo)
{
  runtime_semacquire1(addr, lifo, 3);
}

//----- (08079D70) --------------------------------------------------------
void __golang internal_poll_runtime_Semrelease(uint32 *addr)
{
  runtime_semrelease(addr);
}

//----- (08079DA0) --------------------------------------------------------
void __golang runtime_readyWithTime(runtime_sudog *s, __int32 traceskip)
{
  runtime_sudog *v2; // eax
  int64 gp; // [esp+0h] [ebp-8h]

  v2 = s;
  if ( LODWORD(s->releasetime) != 0 || HIDWORD(s->releasetime) != 0 )
  {
    runtime_cputicks();
    s->releasetime = gp;
    v2 = s;
  }
  runtime_goready(v2->g, traceskip);
}
// 8079DF5: variable 'gp' is possibly undefined

//----- (08079E10) --------------------------------------------------------
void __golang runtime_semacquire(uint32 *addr)
{
  runtime_semacquire1(addr, 0, 0);
}

//----- (08079E50) --------------------------------------------------------
void __golang runtime_semacquire1(uint32 *addr, bool lifo, runtime_semaProfileFlags profile)
{
  int v3; // eax
  runtime_mutex_0 *v4; // ebx
  unsigned int v5; // ebp
  char v6; // al
  uintptr v7; // edx
  runtime_mutex_0 *v8; // esi
  unsigned int v9; // ebp
  runtime_sudog *v10; // eax
  signed int releasetime_high; // ecx
  unsigned int releasetime; // edx
  runtime_mutex_0 *l; // [esp+0h] [ebp-34h]
  string la; // [esp+0h] [ebp-34h]
  uintptr reason; // [esp+4h] [ebp-30h]
  string reasona; // [esp+4h] [ebp-30h]
  unsigned __int64 t0_lo; // [esp+14h] [ebp-20h]
  unsigned int v18; // [esp+1Ch] [ebp-18h]
  runtime_sudog *s; // [esp+24h] [ebp-10h]
  runtime_semaRoot_0 *root; // [esp+28h] [ebp-Ch]
  runtime_mutex_0 *lock; // [esp+30h] [ebp-4h]

  v3 = *(_DWORD *)(__readgsdword(0) - 4);
  if ( v3 != *(_DWORD *)(*(_DWORD *)(v3 + 24) + 84) )
  {
    la.str = (uint8 *)"semacquire not on the G stack";
    la.len = 29;
    runtime_throw(la);
    BUG();
  }
  LOBYTE(reason) = runtime_cansemacquire(addr);
  if ( !(_BYTE)reason )
  {
    l = (runtime_mutex_0 *)runtime_acquireSudog();
    s = (runtime_sudog *)l;
    *(_QWORD *)&l[7].key = 0LL;
    *(_QWORD *)&l[5].key = 0LL;
    l[9].key = 0;
    v4 = l;
    v5 = ((unsigned int)addr >> 3) % 0xFB;
    v6 = profile;
    if ( (profile & 1) != 0 )
    {
      v4 = l;
      v6 = profile;
      if ( HIDWORD(runtime_blockprofilerate) != 0
        || HIDWORD(runtime_blockprofilerate) == 0 && (_DWORD)runtime_blockprofilerate != 0 )
      {
        runtime_cputicks();
        v7 = reason;
        v8 = l;
        v4 = l;
        l[7].key = -1;
        l[8].key = -1;
        v6 = profile;
        v5 = ((unsigned int)addr >> 3) % 0xFB;
      }
      else
      {
        v7 = 0;
        v8 = 0;
      }
    }
    else
    {
      v7 = 0;
      v8 = 0;
    }
    if ( (v6 & 2) != 0
      && (HIDWORD(runtime_mutexprofilerate) != 0
       || HIDWORD(runtime_mutexprofilerate) == 0 && (_DWORD)runtime_mutexprofilerate != 0) )
    {
      if ( v8 == 0 && v7 == 0 )
      {
        runtime_cputicks();
        v7 = reason;
        v8 = l;
        v4 = l;
        v5 = ((unsigned int)addr >> 3) % 0xFB;
      }
      v4[5].key = (uintptr)v8;
      v4[6].key = v7;
    }
    t0_lo = __PAIR64__(v7, (unsigned int)v8);
    v9 = v5 << 6;
    v18 = v9;
    root = (runtime_semaRoot *)((char *)&runtime_semtable[0].root + v9);
    while ( 1 )
    {
      lock = (runtime_mutex_0 *)((char *)&runtime_semtable[0].root.lock + v9);
      runtime_lock((runtime_mutex_0 *)((char *)&runtime_semtable[0].root.lock + v9));
      runtime_internal_atomic_Xadd();
      if ( runtime_cansemacquire(addr) )
        break;
      runtime___ptr_semaRoot__queue(root, addr, s, lifo);
      reasona.str = (uint8 *)"semacquire";
      reasona.len = 10;
      runtime_goparkunlock(lock, reasona, 0x19u, 4);
      if ( s->ticket || runtime_cansemacquire(addr) )
        goto LABEL_16;
      v9 = v18;
    }
    runtime_internal_atomic_Xadd();
    runtime_unlock(lock);
LABEL_16:
    v10 = s;
    releasetime_high = HIDWORD(s->releasetime);
    releasetime = s->releasetime;
    if ( releasetime_high == 0 && releasetime != 0 || releasetime_high > 0 )
    {
      runtime_blockevent(__PAIR64__(releasetime_high, releasetime) - t0_lo, 3);
      v10 = s;
    }
    runtime_releaseSudog(v10);
  }
}
// 807A0E7: variable 'reason' is possibly undefined

//----- (0807A160) --------------------------------------------------------
void __golang runtime_semrelease(uint32 *addr)
{
  runtime_semrelease1(addr, 0);
}

//----- (0807A1A0) --------------------------------------------------------
void __golang runtime_semrelease1(uint32 *addr, bool handoff)
{
  runtime_sudog *v2; // eax
  unsigned int v3; // ecx
  unsigned int v4; // edx
  string ptr; // [esp+0h] [ebp-34h]
  runtime_sudog *skip; // [esp+8h] [ebp-2Ch]
  __int32 skipa; // [esp+8h] [ebp-2Ch]
  int64 v8; // [esp+Ch] [ebp-28h]
  __int64 v9; // [esp+Ch] [ebp-28h]
  unsigned int v10; // [esp+1Ch] [ebp-18h]
  runtime_sudog *s; // [esp+24h] [ebp-10h]
  runtime_mutex_0 *l; // [esp+2Ch] [ebp-8h]

  runtime_internal_atomic_Xadd();
  v10 = (((unsigned int)addr >> 3)
       - 251 * ((unsigned int)((2190262207u * (unsigned __int64)((unsigned int)addr >> 3)) >> 32) >> 7)) << 6;
  if ( runtime_internal_atomic_Load((uint32 *)((char *)&runtime_semtable[0].root.nwait + v10)) )
  {
    l = (runtime_mutex_0 *)((char *)&runtime_semtable[0].root.lock + v10);
    runtime_lock((runtime_mutex_0 *)((char *)&runtime_semtable[0].root.lock + v10));
    if ( runtime_internal_atomic_Load((uint32 *)((char *)&runtime_semtable[0].root.nwait + v10)) )
    {
      runtime___ptr_semaRoot__dequeue((runtime_semaRoot_0 *)((char *)&runtime_semtable[0].root + v10), addr, skip, v8);
      s = (runtime_sudog *)skipa;
      if ( skipa )
        runtime_internal_atomic_Xadd();
      runtime_unlock(l);
      v2 = (runtime_sudog *)skipa;
      if ( skipa )
      {
        v3 = *(_DWORD *)(skipa + 20);
        v4 = *(_DWORD *)(skipa + 24);
        if ( v3 != 0 || v4 != 0 )
        {
          sync_event(v9 - __PAIR64__(v4, v3), 3);
          v2 = s;
        }
        if ( v2->ticket )
        {
          ptr.str = (uint8 *)"corrupted semaphore ticket";
          ptr.len = 26;
          runtime_throw(ptr);
          BUG();
        }
        if ( handoff )
        {
          if ( runtime_cansemacquire(addr) )
          {
            v2 = s;
            s->ticket = 1;
          }
          else
          {
            v2 = s;
          }
        }
        runtime_readyWithTime(v2, 5);
      }
    }
    else
    {
      runtime_unlock(l);
    }
  }
}
// 807A260: variable 'skip' is possibly undefined
// 807A260: variable 'v8' is possibly undefined
// 807A271: variable 'skipa' is possibly undefined
// 807A30B: variable 'v9' is possibly undefined

//----- (0807A380) --------------------------------------------------------
bool __golang runtime_cansemacquire(uint32 *addr)
{
  char v1; // [esp+Ch] [ebp-4h]

  while ( runtime_internal_atomic_Load(addr) )
  {
    runtime_internal_atomic_Cas();
    if ( v1 )
      return 1;
  }
  return 0;
}
// 807A3C1: variable 'v1' is possibly undefined

//----- (0807A3E0) --------------------------------------------------------
void __golang runtime___ptr_semaRoot__queue(runtime_semaRoot_0 *root, uint32 *addr, runtime_sudog *s, bool lifo)
{
  runtime_sudog *v4; // eax
  runtime_g *v5; // edx
  runtime_sudog **p_prev; // esi
  uint32 *v7; // ecx
  runtime_semaRoot_0 *v8; // edx
  runtime_sudog **p_treap; // ebx
  uintptr *src; // edi
  uint32 *v11; // ebp
  uintptr v12; // ecx
  uintptr v13; // ebx
  uintptr *v14; // ebp
  uintptr v15; // edx
  uintptr v16; // edx
  runtime_sudog *prev; // ecx
  runtime_sudog *next; // ecx
  uintptr *p_waittail; // edx
  uintptr v20; // esi
  uintptr v21; // ecx
  uintptr *v22; // edx
  int v23; // ecx
  unsigned int v24; // esi
  runtime_sudog *parent; // ecx
  interface_{} dst; // [esp+0h] [ebp-38h]
  runtime_sudog *last; // [esp+18h] [ebp-20h]
  runtime_sudog **v28; // [esp+20h] [ebp-18h]
  uintptr *p_next; // [esp+34h] [ebp-4h]
  uintptr *p_waitlink; // [esp+34h] [ebp-4h]

  v4 = s;
  v5 = *(runtime_g **)(__readgsdword(0) - 4);
  p_next = (uintptr *)&s->next;
  p_prev = &s->prev;
  if ( *(_DWORD *)&runtime_writeBarrier.enabled )
  {
    runtime_writebarrierptr((uintptr *)s, (uintptr)v5);
    runtime_writebarrierptr((uintptr *)&s->elem, (uintptr)addr);
    runtime_writebarrierptr(p_next, 0);
    runtime_writebarrierptr((uintptr *)&s->prev, 0);
    v4 = s;
    v7 = addr;
    p_prev = &s->prev;
  }
  else
  {
    s->g = v5;
    v7 = addr;
    s->elem = addr;
    s->next = 0;
    s->prev = 0;
  }
  v8 = root;
  p_treap = &root->treap;
  src = (uintptr *)root->treap;
  last = 0;
  while ( src )
  {
    v11 = (uint32 *)src[4];
    if ( v7 == v11 )
    {
      if ( lifo )
      {
        if ( *(_DWORD *)&runtime_writeBarrier.enabled )
        {
          runtime_writebarrierptr((uintptr *)p_treap, (uintptr)v4);
          v4 = s;
          p_prev = &s->prev;
        }
        else
        {
          *p_treap = v4;
        }
        v4->ticket = src[9];
        v12 = src[6];
        LODWORD(v4->acquiretime) = src[5];
        HIDWORD(v4->acquiretime) = v12;
        v13 = src[10];
        v14 = src + 10;
        if ( *(_DWORD *)&runtime_writeBarrier.enabled )
        {
          runtime_writebarrierptr((uintptr *)&v4->parent, v13);
          v4 = s;
          v14 = src + 10;
          p_prev = &s->prev;
        }
        else
        {
          v4->parent = (runtime_sudog *)v13;
        }
        v15 = src[3];
        if ( *(_DWORD *)&runtime_writeBarrier.enabled )
        {
          runtime_writebarrierptr((uintptr *)p_prev, v15);
          v4 = s;
          v14 = src + 10;
        }
        else
        {
          v4->prev = (runtime_sudog *)v15;
        }
        v16 = src[2];
        if ( *(_DWORD *)&runtime_writeBarrier.enabled )
        {
          runtime_writebarrierptr(p_next, v16);
          v4 = s;
          v14 = src + 10;
        }
        else
        {
          v4->next = (runtime_sudog *)v16;
        }
        prev = v4->prev;
        if ( prev )
        {
          if ( *(_DWORD *)&runtime_writeBarrier.enabled )
          {
            runtime_writebarrierptr((uintptr *)&prev->parent, (uintptr)v4);
            v4 = s;
            v14 = src + 10;
          }
          else
          {
            prev->parent = v4;
          }
        }
        next = v4->next;
        if ( next )
        {
          if ( *(_DWORD *)&runtime_writeBarrier.enabled )
          {
            runtime_writebarrierptr((uintptr *)&next->parent, (uintptr)v4);
            v4 = s;
            v14 = src + 10;
          }
          else
          {
            next->parent = v4;
          }
        }
        if ( *(_DWORD *)&runtime_writeBarrier.enabled )
        {
          runtime_writebarrierptr((uintptr *)&v4->waitlink, (uintptr)src);
          v4 = s;
          v14 = src + 10;
        }
        else
        {
          v4->waitlink = (runtime_sudog *)src;
        }
        p_waittail = (uintptr *)&v4->waittail;
        v20 = src[12];
        if ( *(_DWORD *)&runtime_writeBarrier.enabled )
        {
          v28 = &v4->waittail;
          runtime_writebarrierptr((uintptr *)&v4->waittail, v20);
          v4 = s;
          p_waittail = (uintptr *)v28;
          v14 = src + 10;
        }
        else
        {
          v4->waittail = (runtime_sudog *)v20;
        }
        if ( !v20 )
        {
          if ( *(_DWORD *)&runtime_writeBarrier.enabled )
          {
            runtime_writebarrierptr(p_waittail, (uintptr)src);
            v14 = src + 10;
          }
          else
          {
            v4->waittail = (runtime_sudog *)src;
          }
        }
        if ( *(_DWORD *)&runtime_writeBarrier.enabled )
        {
          runtime_writebarrierptr(v14, 0);
          runtime_writebarrierptr(src + 3, 0);
          runtime_writebarrierptr(src + 2, 0);
          runtime_writebarrierptr(src + 12, 0);
        }
        else
        {
          src[10] = 0;
          src[3] = 0;
          src[2] = 0;
          src[12] = 0;
        }
      }
      else
      {
        v21 = src[12];
        v22 = src + 12;
        if ( v21 )
        {
          if ( *(_DWORD *)&runtime_writeBarrier.enabled )
          {
            runtime_writebarrierptr((uintptr *)(v21 + 44), (uintptr)v4);
            v4 = s;
            v22 = src + 12;
          }
          else
          {
            *(_DWORD *)(v21 + 44) = v4;
          }
        }
        else if ( *(_DWORD *)&runtime_writeBarrier.enabled )
        {
          runtime_writebarrierptr(src + 11, (uintptr)v4);
          v4 = s;
          v22 = src + 12;
        }
        else
        {
          src[11] = (uintptr)v4;
        }
        if ( *(_DWORD *)&runtime_writeBarrier.enabled )
        {
          p_waitlink = (uintptr *)&v4->waitlink;
          runtime_writebarrierptr(v22, (uintptr)v4);
          runtime_writebarrierptr(p_waitlink, 0);
        }
        else
        {
          src[12] = (uintptr)v4;
          v4->waitlink = 0;
        }
      }
      return;
    }
    if ( v7 >= v11 )
      p_treap = (runtime_sudog **)(src + 2);
    else
      p_treap = (runtime_sudog **)(src + 3);
    last = (runtime_sudog *)src;
    src = (uintptr *)*p_treap;
  }
  v23 = *(_DWORD *)(*(_DWORD *)(__readgsdword(0) - 4) + 24);
  v24 = (*(int *)(v23 + 148) >> 31) & 0xA8888EEF ^ (2 * *(_DWORD *)(v23 + 148));
  *(_DWORD *)(v23 + 148) = v24;
  v4->ticket = v24;
  if ( *(_DWORD *)&runtime_writeBarrier.enabled )
  {
    runtime_writebarrierptr((uintptr *)&v4->parent, (uintptr)last);
    v4 = s;
    v8 = root;
  }
  else
  {
    v4->parent = last;
  }
  if ( *(_DWORD *)&runtime_writeBarrier.enabled )
  {
    runtime_writebarrierptr((uintptr *)p_treap, (uintptr)v4);
    v4 = s;
    v8 = root;
  }
  else
  {
    *p_treap = v4;
  }
  while ( 1 )
  {
    parent = v4->parent;
    if ( !parent || parent->ticket <= v4->ticket )
      break;
    if ( v4 == parent->prev )
    {
      runtime___ptr_semaRoot__rotateRight(v8, v4->parent);
    }
    else
    {
      if ( parent->next != v4 )
      {
        dst._type = (runtime__type_0 *)&t;
        dst.data = &runtime_statictmp_21;
        runtime_gopanic(dst);
        BUG();
      }
      runtime___ptr_semaRoot__rotateLeft(v8, v4->parent);
    }
    v4 = s;
    v8 = root;
  }
}

//----- (0807A950) --------------------------------------------------------
void __golang runtime___ptr_semaRoot__dequeue(runtime_semaRoot_0 *root, uint32 *addr, runtime_sudog *found, int64 now)
{
  runtime_semaRoot_0 *v4; // eax
  uintptr *p_treap; // ecx
  runtime_sudog *i; // edx
  uint32 *elem; // esi
  runtime_semaRoot_0 *v8; // ebx
  runtime_sudog *v9; // esi
  uintptr *waitlink; // edi
  runtime_sudog *next; // ecx
  bool v12; // zf
  runtime_sudog *prev; // ebp
  runtime_sudog *parent; // ecx
  uintptr v15; // ebp
  uintptr v16; // ebp
  uintptr v17; // ebp
  uintptr waittail; // ebp
  runtime_semaRoot_0 *v19; // [esp+0h] [ebp-2Ch]
  runtime_sudog *y; // [esp+4h] [ebp-28h]
  runtime_sudog *t; // [esp+10h] [ebp-1Ch]
  runtime_sudog *s; // [esp+14h] [ebp-18h]
  runtime_sudog **ps; // [esp+18h] [ebp-14h]
  uintptr *dst; // [esp+1Ch] [ebp-10h]
  uintptr *p_next; // [esp+20h] [ebp-Ch]
  uintptr *p_waitlink; // [esp+20h] [ebp-Ch]
  runtime_sudog *v27; // [esp+24h] [ebp-8h]
  runtime_sudog *v28; // [esp+24h] [ebp-8h]
  uintptr *p_prev; // [esp+28h] [ebp-4h]
  uintptr *p_waittail; // [esp+28h] [ebp-4h]

  v4 = root;
  p_treap = (uintptr *)&root->treap;
  for ( i = root->treap; i; i = (runtime_sudog *)*p_treap )
  {
    elem = (uint32 *)i->elem;
    if ( addr == elem )
    {
      s = i;
      dst = (uintptr *)&i->elem;
      if ( LODWORD(i->acquiretime) != 0 || HIDWORD(i->acquiretime) != 0 )
      {
        ps = (runtime_sudog **)p_treap;
        runtime_cputicks();
        v8 = v19;
        v9 = y;
        v4 = root;
        p_treap = (uintptr *)ps;
        i = s;
      }
      else
      {
        v8 = 0;
        v9 = 0;
      }
      waitlink = (uintptr *)i->waitlink;
      if ( !waitlink )
      {
        while ( 1 )
        {
          next = i->next;
          v12 = next == 0;
          if ( !next )
          {
            if ( !i->prev )
            {
              parent = i->parent;
              if ( parent )
              {
                if ( i == parent->prev )
                {
                  if ( *(_DWORD *)&runtime_writeBarrier.enabled )
                  {
                    runtime_writebarrierptr((uintptr *)&parent->prev, 0);
                    i = s;
                  }
                  else
                  {
                    parent->prev = 0;
                  }
                }
                else if ( *(_DWORD *)&runtime_writeBarrier.enabled )
                {
                  runtime_writebarrierptr((uintptr *)&parent->next, 0);
                  i = s;
                }
                else
                {
                  parent->next = 0;
                }
              }
              else if ( *(_DWORD *)&runtime_writeBarrier.enabled )
              {
                runtime_writebarrierptr((uintptr *)&root->treap, 0);
                i = s;
              }
              else
              {
                v4->treap = 0;
              }
              goto LABEL_25;
            }
            v12 = 1;
          }
          if ( v12 || (prev = i->prev) != 0 && prev->ticket < next->ticket )
            runtime___ptr_semaRoot__rotateRight(v4, i);
          else
            runtime___ptr_semaRoot__rotateLeft(v4, i);
          v4 = root;
          i = s;
        }
      }
      p_waitlink = (uintptr *)&i->waitlink;
      t = i->waitlink;
      if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      {
        runtime_writebarrierptr(p_treap, (uintptr)waitlink);
        i = s;
      }
      else
      {
        *p_treap = (uintptr)waitlink;
      }
      waitlink[9] = i->ticket;
      v15 = (uintptr)i->parent;
      if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      {
        runtime_writebarrierptr(waitlink + 10, v15);
        i = s;
      }
      else
      {
        waitlink[10] = v15;
      }
      v16 = (uintptr)i->prev;
      if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      {
        v28 = i->prev;
        runtime_writebarrierptr(waitlink + 3, v16);
        i = s;
        v16 = (uintptr)v28;
        waitlink = (uintptr *)t;
      }
      else
      {
        waitlink[3] = v16;
      }
      if ( v16 )
      {
        if ( *(_DWORD *)&runtime_writeBarrier.enabled )
        {
          runtime_writebarrierptr((uintptr *)(v16 + 40), (uintptr)waitlink);
          i = s;
          waitlink = (uintptr *)t;
        }
        else
        {
          *(_DWORD *)(v16 + 40) = waitlink;
        }
      }
      v17 = (uintptr)i->next;
      if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      {
        v27 = i->next;
        runtime_writebarrierptr(waitlink + 2, v17);
        i = s;
        v17 = (uintptr)v27;
        waitlink = (uintptr *)t;
      }
      else
      {
        waitlink[2] = v17;
      }
      if ( v17 )
      {
        if ( *(_DWORD *)&runtime_writeBarrier.enabled )
        {
          runtime_writebarrierptr((uintptr *)(v17 + 40), (uintptr)waitlink);
          i = s;
          waitlink = (uintptr *)t;
        }
        else
        {
          *(_DWORD *)(v17 + 40) = waitlink;
        }
      }
      if ( waitlink[11] )
      {
        waittail = (uintptr)i->waittail;
        if ( *(_DWORD *)&runtime_writeBarrier.enabled )
        {
          runtime_writebarrierptr(waitlink + 12, waittail);
          i = s;
          waitlink = (uintptr *)t;
        }
        else
        {
          waitlink[12] = waittail;
        }
      }
      else if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      {
        runtime_writebarrierptr(waitlink + 12, 0);
        i = s;
        waitlink = (uintptr *)t;
      }
      else
      {
        waitlink[12] = 0;
      }
      waitlink[5] = (uintptr)v8;
      waitlink[6] = (uintptr)v9;
      if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      {
        p_waittail = (uintptr *)&i->waittail;
        runtime_writebarrierptr(p_waitlink, 0);
        runtime_writebarrierptr(p_waittail, 0);
        i = s;
      }
      else
      {
        i->waitlink = 0;
        i->waittail = 0;
      }
LABEL_25:
      if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      {
        p_next = (uintptr *)&i->next;
        p_prev = (uintptr *)&i->prev;
        runtime_writebarrierptr((uintptr *)&i->parent, 0);
        runtime_writebarrierptr(dst, 0);
        runtime_writebarrierptr(p_next, 0);
        runtime_writebarrierptr(p_prev, 0);
        i = s;
      }
      else
      {
        i->parent = 0;
        i->elem = 0;
        i->next = 0;
        i->prev = 0;
      }
      i->ticket = 0;
      return;
    }
    if ( addr >= elem )
      p_treap = (uintptr *)&i->next;
    else
      p_treap = (uintptr *)&i->prev;
  }
}
// 807ADFE: variable 'v19' is possibly undefined
// 807AE01: variable 'y' is possibly undefined

//----- (0807AE50) --------------------------------------------------------
void __golang runtime___ptr_semaRoot__rotateLeft(runtime_semaRoot_0 *root, runtime_sudog *x)
{
  runtime_sudog *v2; // eax
  runtime_sudog *src; // ecx
  runtime_sudog *prev; // ebp
  uintptr v5; // ebx
  uintptr next; // esi
  runtime_sudog *v7; // edx
  string dst; // [esp+0h] [ebp-2Ch]
  runtime_sudog *y; // [esp+8h] [ebp-24h]
  runtime_sudog *p; // [esp+Ch] [ebp-20h]
  uintptr *p_next; // [esp+20h] [ebp-Ch]

  v2 = x;
  src = x->next;
  y = src;
  p = x->parent;
  prev = x->prev;
  v5 = (uintptr)src->prev;
  next = (uintptr)src->next;
  p_next = (uintptr *)&src->next;
  if ( *(_DWORD *)&runtime_writeBarrier.enabled )
  {
    runtime_writebarrierptr((uintptr *)&src->prev, (uintptr)x);
    runtime_writebarrierptr((uintptr *)&x->parent, (uintptr)y);
    runtime_writebarrierptr(p_next, next);
    v2 = x;
    src = y;
  }
  else
  {
    src->prev = x;
    x->parent = src;
    src->next = (runtime_sudog *)next;
  }
  if ( next )
  {
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
    {
      runtime_writebarrierptr((uintptr *)(next + 40), (uintptr)src);
      v2 = x;
      src = y;
    }
    else
    {
      *(_DWORD *)(next + 40) = src;
    }
  }
  if ( *(_DWORD *)&runtime_writeBarrier.enabled )
  {
    runtime_writebarrierptr((uintptr *)&x->prev, (uintptr)prev);
    v2 = x;
    src = y;
  }
  else
  {
    v2->prev = prev;
  }
  if ( prev )
  {
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
    {
      runtime_writebarrierptr((uintptr *)&prev->parent, (uintptr)v2);
      v2 = x;
      src = y;
    }
    else
    {
      prev->parent = v2;
    }
  }
  if ( *(_DWORD *)&runtime_writeBarrier.enabled )
  {
    runtime_writebarrierptr((uintptr *)&x->next, v5);
    v2 = x;
    src = y;
  }
  else
  {
    v2->next = (runtime_sudog *)v5;
  }
  if ( v5 )
  {
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
    {
      runtime_writebarrierptr((uintptr *)(v5 + 40), (uintptr)v2);
      v2 = x;
      src = y;
    }
    else
    {
      *(_DWORD *)(v5 + 40) = v2;
    }
  }
  if ( *(_DWORD *)&runtime_writeBarrier.enabled )
  {
    runtime_writebarrierptr((uintptr *)&src->parent, (uintptr)p);
    v2 = x;
    src = y;
    v7 = p;
  }
  else
  {
    v7 = p;
    src->parent = p;
  }
  if ( v7 )
  {
    if ( v7->prev == v2 )
    {
      if ( *(_DWORD *)&runtime_writeBarrier.enabled )
        runtime_writebarrierptr((uintptr *)&v7->prev, (uintptr)src);
      else
        v7->prev = src;
    }
    else
    {
      if ( v7->next != v2 )
      {
        dst.str = (uint8 *)"semaRoot rotateLeft";
        dst.len = 19;
        runtime_throw(dst);
        BUG();
      }
      if ( *(_DWORD *)&runtime_writeBarrier.enabled )
        runtime_writebarrierptr((uintptr *)&v7->next, (uintptr)src);
      else
        v7->next = src;
    }
  }
  else if ( *(_DWORD *)&runtime_writeBarrier.enabled )
  {
    runtime_writebarrierptr((uintptr *)&root->treap, (uintptr)src);
  }
  else
  {
    root->treap = src;
  }
}

//----- (0807B100) --------------------------------------------------------
void __golang runtime___ptr_semaRoot__rotateRight(runtime_semaRoot_0 *root, runtime_sudog *y)
{
  runtime_sudog *v2; // eax
  runtime_sudog *src; // ecx
  runtime_sudog *next; // esi
  runtime_sudog *prev; // ebp
  uintptr v6; // ebx
  runtime_sudog *v7; // edx
  string dst; // [esp+0h] [ebp-28h]
  runtime_sudog *x; // [esp+8h] [ebp-20h]
  runtime_sudog *p; // [esp+Ch] [ebp-1Ch]
  uintptr *p_next; // [esp+1Ch] [ebp-Ch]

  v2 = y;
  src = y->prev;
  x = src;
  p = y->parent;
  next = y->next;
  prev = src->prev;
  v6 = (uintptr)src->next;
  p_next = (uintptr *)&src->next;
  if ( prev )
  {
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
    {
      runtime_writebarrierptr((uintptr *)&prev->parent, (uintptr)src);
      v2 = y;
      src = x;
    }
    else
    {
      prev->parent = src;
    }
  }
  if ( *(_DWORD *)&runtime_writeBarrier.enabled )
  {
    runtime_writebarrierptr(p_next, (uintptr)v2);
    runtime_writebarrierptr((uintptr *)&y->parent, (uintptr)x);
    runtime_writebarrierptr((uintptr *)&y->prev, v6);
    v2 = y;
    src = x;
  }
  else
  {
    src->next = v2;
    v2->parent = src;
    v2->prev = (runtime_sudog *)v6;
  }
  if ( v6 )
  {
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
    {
      runtime_writebarrierptr((uintptr *)(v6 + 40), (uintptr)v2);
      v2 = y;
      src = x;
    }
    else
    {
      *(_DWORD *)(v6 + 40) = v2;
    }
  }
  if ( *(_DWORD *)&runtime_writeBarrier.enabled )
  {
    runtime_writebarrierptr((uintptr *)&y->next, (uintptr)next);
    v2 = y;
    src = x;
  }
  else
  {
    v2->next = next;
  }
  if ( next )
  {
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
    {
      runtime_writebarrierptr((uintptr *)&next->parent, (uintptr)v2);
      v2 = y;
      src = x;
    }
    else
    {
      next->parent = v2;
    }
  }
  if ( *(_DWORD *)&runtime_writeBarrier.enabled )
  {
    runtime_writebarrierptr((uintptr *)&src->parent, (uintptr)p);
    v2 = y;
    src = x;
    v7 = p;
  }
  else
  {
    v7 = p;
    src->parent = p;
  }
  if ( v7 )
  {
    if ( v7->prev == v2 )
    {
      if ( *(_DWORD *)&runtime_writeBarrier.enabled )
        runtime_writebarrierptr((uintptr *)&v7->prev, (uintptr)src);
      else
        v7->prev = src;
    }
    else
    {
      if ( v7->next != v2 )
      {
        dst.str = (uint8 *)"semaRoot rotateRight";
        dst.len = 20;
        runtime_throw(dst);
        BUG();
      }
      if ( *(_DWORD *)&runtime_writeBarrier.enabled )
        runtime_writebarrierptr((uintptr *)&v7->next, (uintptr)src);
      else
        v7->next = src;
    }
  }
  else if ( *(_DWORD *)&runtime_writeBarrier.enabled )
  {
    runtime_writebarrierptr((uintptr *)&root->treap, (uintptr)src);
  }
  else
  {
    root->treap = src;
  }
}

//----- (0807B370) --------------------------------------------------------
void __golang sync_runtime_notifyListCheck(uintptr sz)
{
  string s; // [esp+0h] [ebp-8h]
  string sa; // [esp+0h] [ebp-8h]
  string sb; // [esp+0h] [ebp-8h]
  string sc; // [esp+0h] [ebp-8h]

  if ( sz != 20 )
  {
    runtime_printlock();
    s.str = (uint8 *)"runtime: bad notifyList size - sync=";
    s.len = 36;
    runtime_printstring(s);
    runtime_printint(sz);
    sa.str = (uint8 *)" runtime=";
    sa.len = 9;
    runtime_printstring(sa);
    runtime_printint(20LL);
    sb.str = (uint8 *)"\n";
    sb.len = 1;
    runtime_printstring(sb);
    runtime_printunlock();
    sc.str = (uint8 *)"bad notifyList size";
    sc.len = 19;
    runtime_throw(sc);
    BUG();
  }
}

//----- (0807B430) --------------------------------------------------------
int64 __golang sync_runtime_nanotime()
{
  int64 v0; // [esp+0h] [ebp-8h]

  runtime_nanotime();
  return v0;
}
// 807B451: variable 'v0' is possibly undefined

//----- (0807B470) --------------------------------------------------------
void __golang runtime_dumpregs(runtime_sigctxt *c)
{
  string s; // [esp+0h] [ebp-34h]
  string sa; // [esp+0h] [ebp-34h]
  string sb; // [esp+0h] [ebp-34h]
  string sc; // [esp+0h] [ebp-34h]
  string sd; // [esp+0h] [ebp-34h]
  string se; // [esp+0h] [ebp-34h]
  string sf; // [esp+0h] [ebp-34h]
  string sg; // [esp+0h] [ebp-34h]
  string sh; // [esp+0h] [ebp-34h]
  string si; // [esp+0h] [ebp-34h]
  string sj; // [esp+0h] [ebp-34h]
  string sk; // [esp+0h] [ebp-34h]
  string sl; // [esp+0h] [ebp-34h]
  string sm; // [esp+0h] [ebp-34h]
  string sn; // [esp+0h] [ebp-34h]
  string so; // [esp+0h] [ebp-34h]
  string sp; // [esp+0h] [ebp-34h]
  string sq; // [esp+0h] [ebp-34h]
  string sr; // [esp+0h] [ebp-34h]
  string ss; // [esp+0h] [ebp-34h]
  string st; // [esp+0h] [ebp-34h]
  string su; // [esp+0h] [ebp-34h]
  string sv; // [esp+0h] [ebp-34h]
  string sw; // [esp+0h] [ebp-34h]
  string sx; // [esp+0h] [ebp-34h]
  string sy; // [esp+0h] [ebp-34h]
  uint32 _r0; // [esp+8h] [ebp-2Ch]
  uint32 _r0_0; // [esp+Ch] [ebp-28h]
  uint32 _r0_1; // [esp+10h] [ebp-24h]
  uint32 _r0_2; // [esp+14h] [ebp-20h]
  uint32 _r0_3; // [esp+18h] [ebp-1Ch]
  uint32 _r0_4; // [esp+1Ch] [ebp-18h]
  uint32 _r0_5; // [esp+20h] [ebp-14h]
  uint32 _r0_6; // [esp+24h] [ebp-10h]
  uint32 _r0_7; // [esp+28h] [ebp-Ch]
  uint32 _r0_8; // [esp+2Ch] [ebp-8h]
  unsigned int v37; // [esp+30h] [ebp-4h]
  unsigned int v38; // [esp+30h] [ebp-4h]
  unsigned int v39; // [esp+30h] [ebp-4h]

  _r0_7 = *((_DWORD *)c->ctxt + 16);
  runtime_printlock();
  s.str = (uint8 *)"eax    ";
  s.len = 7;
  runtime_printstring(s);
  runtime_printhex(_r0_7);
  sa.str = (uint8 *)"\n";
  sa.len = 1;
  runtime_printstring(sa);
  runtime_printunlock();
  _r0_6 = *((_DWORD *)c->ctxt + 13);
  runtime_printlock();
  sb.str = (uint8 *)"ebx    ";
  sb.len = 7;
  runtime_printstring(sb);
  runtime_printhex(_r0_6);
  sc.str = (uint8 *)"\n";
  sc.len = 1;
  runtime_printstring(sc);
  runtime_printunlock();
  _r0_5 = *((_DWORD *)c->ctxt + 15);
  runtime_printlock();
  sd.str = (uint8 *)"ecx    ";
  sd.len = 7;
  runtime_printstring(sd);
  runtime_printhex(_r0_5);
  se.str = (uint8 *)"\n";
  se.len = 1;
  runtime_printstring(se);
  runtime_printunlock();
  _r0_4 = *((_DWORD *)c->ctxt + 14);
  runtime_printlock();
  sf.str = (uint8 *)"edx    ";
  sf.len = 7;
  runtime_printstring(sf);
  runtime_printhex(_r0_4);
  sg.str = (uint8 *)"\n";
  sg.len = 1;
  runtime_printstring(sg);
  runtime_printunlock();
  _r0_2 = *((_DWORD *)c->ctxt + 9);
  runtime_printlock();
  sh.str = (uint8 *)"edi    ";
  sh.len = 7;
  runtime_printstring(sh);
  runtime_printhex(_r0_2);
  si.str = (uint8 *)"\n";
  si.len = 1;
  runtime_printstring(si);
  runtime_printunlock();
  _r0_0 = *((_DWORD *)c->ctxt + 10);
  runtime_printlock();
  sj.str = (uint8 *)"esi    ";
  sj.len = 7;
  runtime_printstring(sj);
  runtime_printhex(_r0_0);
  sk.str = (uint8 *)"\n";
  sk.len = 1;
  runtime_printstring(sk);
  runtime_printunlock();
  _r0_1 = *((_DWORD *)c->ctxt + 11);
  runtime_printlock();
  sl.str = (uint8 *)"ebp    ";
  sl.len = 7;
  runtime_printstring(sl);
  runtime_printhex(_r0_1);
  sm.str = (uint8 *)"\n";
  sm.len = 1;
  runtime_printstring(sm);
  runtime_printunlock();
  _r0_8 = *((_DWORD *)c->ctxt + 12);
  runtime_printlock();
  sn.str = (uint8 *)"esp    ";
  sn.len = 7;
  runtime_printstring(sn);
  runtime_printhex(_r0_8);
  so.str = (uint8 *)"\n";
  so.len = 1;
  runtime_printstring(so);
  runtime_printunlock();
  _r0_3 = *((_DWORD *)c->ctxt + 19);
  runtime_printlock();
  sp.str = (uint8 *)"eip    ";
  sp.len = 7;
  runtime_printstring(sp);
  runtime_printhex(_r0_3);
  sq.str = (uint8 *)"\n";
  sq.len = 1;
  runtime_printstring(sq);
  runtime_printunlock();
  _r0 = *((_DWORD *)c->ctxt + 21);
  runtime_printlock();
  sr.str = (uint8 *)"eflags ";
  sr.len = 7;
  runtime_printstring(sr);
  runtime_printhex(_r0);
  ss.str = (uint8 *)"\n";
  ss.len = 1;
  runtime_printstring(ss);
  runtime_printunlock();
  v37 = *((unsigned __int16 *)c->ctxt + 40);
  runtime_printlock();
  st.str = (uint8 *)"cs     ";
  st.len = 7;
  runtime_printstring(st);
  runtime_printhex(v37);
  su.str = (uint8 *)"\n";
  su.len = 1;
  runtime_printstring(su);
  runtime_printunlock();
  v38 = *((unsigned __int16 *)c->ctxt + 12);
  runtime_printlock();
  sv.str = (uint8 *)"fs     ";
  sv.len = 7;
  runtime_printstring(sv);
  runtime_printhex(v38);
  sw.str = (uint8 *)"\n";
  sw.len = 1;
  runtime_printstring(sw);
  runtime_printunlock();
  v39 = *((unsigned __int16 *)c->ctxt + 10);
  runtime_printlock();
  sx.str = (uint8 *)"gs     ";
  sx.len = 7;
  runtime_printstring(sx);
  runtime_printhex(v39);
  sy.str = (uint8 *)"\n";
  sy.len = 1;
  runtime_printstring(sy);
  runtime_printunlock();
}

//----- (0807B960) --------------------------------------------------------
void __golang runtime___ptr_sigctxt__preparePanic(runtime_sigctxt *c, uint32 sig, runtime_g *gp)
{
  runtime_sigctxt *v3; // eax
  _DWORD *ctxt; // ecx
  uintptr pc; // edx
  uintptr *v6; // ecx
  uintptr *v7; // ecx
  uintptr *v8; // [esp+Ch] [ebp-10h]
  uintptr v9; // [esp+10h] [ebp-Ch]

  v3 = c;
  ctxt = c->ctxt;
  pc = ctxt[19];
  v6 = (uintptr *)ctxt[12];
  if ( pc )
  {
    v9 = pc;
    v8 = v6;
    if ( (unsigned int)runtime_findfunc(pc)._func )
    {
      v3 = c;
      v6 = v8;
      pc = v9;
    }
    else if ( (unsigned int)runtime_findfunc(*v8)._func )
    {
      v3 = c;
      v6 = v8;
      pc = 0;
    }
    else
    {
      v3 = c;
      v6 = v8;
      pc = v9;
    }
  }
  if ( pc )
  {
    v7 = v6 - 1;
    *v7 = pc;
    *((_DWORD *)v3->ctxt + 12) = v7;
  }
  *((_DWORD *)v3->ctxt + 19) = runtime_sigpanic;
}

//----- (0807BA40) --------------------------------------------------------
void __golang runtime_sighandler(uint32 sig, runtime_siginfo *info, void *ctxt, runtime_g *gp)
{
  runtime_g *v4; // eax
  int32 v5; // ecx
  int v6; // ebp
  bool v7; // zf
  runtime_m *m; // ecx
  runtime_g *lockedg; // edx
  bool v10; // cl
  runtime_g *curg; // ecx
  runtime_g *v12; // edx
  string s; // [esp+0h] [ebp-3Ch]
  string sa; // [esp+0h] [ebp-3Ch]
  string sb; // [esp+0h] [ebp-3Ch]
  string sc; // [esp+0h] [ebp-3Ch]
  string sd; // [esp+0h] [ebp-3Ch]
  string sf; // [esp+0h] [ebp-3Ch]
  uint32 sg; // [esp+0h] [ebp-3Ch]
  signed __int32 sh; // [esp+0h] [ebp-3Ch]
  string si; // [esp+0h] [ebp-3Ch]
  string sj; // [esp+0h] [ebp-3Ch]
  string se; // [esp+0h] [ebp-3Ch]
  string sk; // [esp+0h] [ebp-3Ch]
  bool all; // [esp+4h] [ebp-38h]
  bool all_1; // [esp+5h] [ebp-37h]
  bool lr; // [esp+8h] [ebp-34h]
  bool docrash; // [esp+17h] [ebp-25h]
  uint32 _r0; // [esp+18h] [ebp-24h]
  char flags; // [esp+1Ch] [ebp-20h]
  unsigned int v; // [esp+20h] [ebp-1Ch]
  int32 v_4; // [esp+24h] [ebp-18h]
  __int32 len; // [esp+28h] [ebp-14h]
  runtime_g *_g_; // [esp+2Ch] [ebp-10h]
  string v35; // [esp+30h] [ebp-Ch] BYREF
  _DWORD *v36; // [esp+38h] [ebp-4h]
  runtime_g *gpa; // [esp+4Ch] [ebp+10h]

  v4 = *(runtime_g **)(__readgsdword(0) - 4);
  v35.len = (__int32)info;
  v36 = ctxt;
  if ( sig == 27 )
  {
    runtime_sigprof(*((_DWORD *)ctxt + 19), *((_DWORD *)ctxt + 12), 0, gp, v4->m);
  }
  else
  {
    if ( sig >= 0x41 )
      LOBYTE(v5) = 4;
    else
      v5 = runtime_sigtable[sig].flags;
    v6 = *(_DWORD *)(v35.len + 8);
    v7 = v6 == 0;
    if ( v6 )
    {
      if ( (v5 & 8) != 0 )
      {
        gp->sig = sig;
        gp->sigcode0 = *(_DWORD *)(v35.len + 8);
        gp->sigcode1 = *(_DWORD *)(v35.len + 12);
        gp->sigpc = v36[19];
        runtime___ptr_sigctxt__preparePanic((runtime_sigctxt *)&v35.len, sig, gp);
        return;
      }
      v7 = v6 == 0;
    }
    _g_ = v4;
    flags = v5;
    if ( (!v7 && (v5 & 1) == 0 || !runtime_sigsend(sig)) && (*(_DWORD *)(v35.len + 8) || !runtime_signal_ignored(sig)) )
    {
      if ( (flags & 2) != 0 )
        runtime_dieFromSignal(sig);
      if ( (flags & 4) != 0 )
      {
        _g_->m->throwing = 1;
        _g_->m->caughtsig = (runtime_guintptr)gp;
        if ( !runtime_crashing )
          runtime_startpanic();
        if ( sig >= 0x41 )
        {
          runtime_printlock();
          sk.str = (uint8 *)"Signal ";
          sk.len = 7;
          runtime_printstring(sk);
          runtime_printint(sig);
        }
        else
        {
          len = runtime_sigtable[sig].name.len;
          v35.str = runtime_sigtable[sig].name.str;
          runtime_printlock();
          runtime_printstring((string)__PAIR64__(len, (unsigned int)v35.str));
        }
        s.str = (uint8 *)"\n";
        s.len = 1;
        runtime_printstring(s);
        runtime_printunlock();
        v_4 = _g_->m->id;
        _r0 = v36[19];
        v = *(_DWORD *)(v35.len + 8);
        runtime_printlock();
        sa.str = (uint8 *)"PC=";
        sa.len = 3;
        runtime_printstring(sa);
        runtime_printhex(_r0);
        sb.str = (uint8 *)" m=";
        sb.len = 3;
        runtime_printstring(sb);
        runtime_printint(v_4);
        sc.str = (uint8 *)" sigcode=";
        sc.len = 9;
        runtime_printstring(sc);
        runtime_printint(v);
        sd.str = (uint8 *)"\n";
        sd.len = 1;
        runtime_printstring(sd);
        runtime_printunlock();
        m = _g_->m;
        if ( m->lockedg )
        {
          if ( m->ncgo <= 0 )
          {
            lockedg = gp;
          }
          else
          {
            lockedg = gp;
            if ( gp == m->g0 )
            {
              runtime_printlock();
              se.str = (uint8 *)"signal arrived during cgo execution\n";
              se.len = 36;
              runtime_printstring(se);
              runtime_printunlock();
              lockedg = _g_->m->lockedg;
            }
          }
        }
        else
        {
          lockedg = gp;
        }
        gpa = lockedg;
        runtime_printlock();
        sf.str = (uint8 *)"\n";
        sf.len = 1;
        runtime_printstring(sf);
        runtime_printunlock();
        runtime_gotraceback(sg, all, lr);
        v10 = all_1;
        if ( sh <= 0 )
        {
LABEL_21:
          if ( v10 )
          {
            if ( ++runtime_crashing < (int)(runtime_sched.mcount - runtime_extraMCount) )
            {
              runtime_printlock();
              si.str = (uint8 *)"\n-----\n\n";
              si.len = 8;
              runtime_printstring(si);
              runtime_printunlock();
              runtime_raiseproc();
              runtime_usleep();
            }
            runtime_crash();
          }
          runtime_exit();
        }
        docrash = all_1;
        runtime_goroutineheader(gpa);
        runtime_tracebacktrap(v36[19], v36[12], 0, gpa);
        if ( runtime_crashing <= 0 )
        {
          v12 = gpa;
        }
        else
        {
          curg = _g_->m->curg;
          v12 = gpa;
          if ( gpa != curg && curg )
          {
            if ( (runtime_readgstatus(_g_->m->curg) & 0xFFFFEFFF) == 2 )
            {
              runtime_goroutineheader(_g_->m->curg);
              runtime_traceback(0xFFFFFFFF, 0xFFFFFFFF, 0, _g_->m->curg);
LABEL_31:
              runtime_dumpregs((runtime_sigctxt *)&v35.len);
              v10 = docrash;
              goto LABEL_21;
            }
            v12 = gpa;
          }
        }
        if ( !runtime_crashing )
        {
          runtime_tracebackothers(v12);
          runtime_printlock();
          sj.str = (uint8 *)"\n";
          sj.len = 1;
          runtime_printstring(sj);
          runtime_printunlock();
        }
        goto LABEL_31;
      }
    }
  }
}
// 807BC9F: variable 'sg' is possibly undefined
// 807BC9F: variable 'all' is possibly undefined
// 807BC9F: variable 'lr' is possibly undefined
// 807BCA7: variable 'all_1' is possibly undefined
// 807BCAE: variable 'sh' is possibly undefined

//----- (0807BFD0) --------------------------------------------------------
void __golang os_sigpipe()
{
  runtime_systemstack();
}

//----- (0807C000) --------------------------------------------------------
void __golang runtime_init_4()
{
  ;
}

//----- (0807C020) --------------------------------------------------------
void __golang runtime_initsig(bool preinit)
{
  bool v1; // zf
  uint32 j; // eax
  int32 flags; // ecx
  uintptr v4; // edx
  uint32 i; // [esp+8h] [ebp-Ch]

  if ( !preinit )
    runtime_signalsOK = 1;
  if ( runtime_isarchive )
  {
    v1 = !preinit;
    goto LABEL_5;
  }
  if ( runtime_islibrary )
  {
    v1 = !preinit;
LABEL_5:
    if ( v1 )
      return;
  }
  for ( j = 0; j < 0x41; ++j )
  {
    flags = runtime_sigtable[j].flags;
    if ( flags && (flags & 0x10) == 0 )
    {
      i = j;
      runtime_fwdSig[j] = runtime_getsig(j);
      if ( runtime_sigInstallGoHandler(i) )
      {
        runtime_handlingSig[i] = 1;
        runtime_setsig(i, (uintptr)runtime_sighandler);
        j = i;
      }
      else
      {
        j = i;
        v4 = runtime_fwdSig[i];
        if ( v4 )
        {
          if ( v4 != 1 )
          {
            runtime_setsigstack(i);
            j = i;
          }
        }
      }
    }
  }
}

//----- (0807C150) --------------------------------------------------------
bool __golang runtime_sigInstallGoHandler(uint32 sig)
{
  int32 flags; // ecx
  int v2; // [esp+4h] [ebp-4h]

  if ( sig - 1 <= 1 )
  {
    if ( sig >= 0x41 )
      runtime_panicindex();
    runtime_internal_atomic_Loaduintptr();
    if ( v2 == 1 )
      return 0;
  }
  if ( sig >= 0x41 )
    runtime_panicindex();
  flags = runtime_sigtable[sig].flags;
  if ( (flags & 0x40) != 0 )
    return 0;
  return !runtime_isarchive && !runtime_islibrary || (flags & 8) != 0 || sig == 13;
}
// 807C180: variable 'v2' is possibly undefined

//----- (0807C200) --------------------------------------------------------
void __golang runtime_setThreadCPUProfiler(int32 hz)
{
  runtime_setitimer();
  *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(__readgsdword(0) - 4) + 24) + 132) = hz;
}

//----- (0807C2E0) --------------------------------------------------------
void __golang runtime_sigpipe()
{
  if ( !runtime_sigsend(0xDu) )
    runtime_dieFromSignal(0xDu);
}

//----- (0807C330) --------------------------------------------------------
void __golang runtime_sigtrampgo(uint32 sig, runtime_siginfo *info, void *ctx)
{
  runtime_g *v3; // ecx
  runtime_m *m; // edx
  runtime_g *gsignal; // ebx
  int v6; // eax
  uint8 **v7; // edx
  uint8 *v8; // ebx
  char v9; // al
  uint8 **v10; // eax
  int v11; // eax
  uint8 **v12; // edx
  uint8 *ss_sp; // ebx
  bool setStack; // [esp+13h] [ebp-45h]
  uint8 *gsignalStack; // [esp+18h] [ebp-40h]
  uint8 *gsignalStack_4; // [esp+1Ch] [ebp-3Ch]
  uint8 *gsignalStack_8; // [esp+20h] [ebp-38h]
  uint8 *gsignalStack_12; // [esp+24h] [ebp-34h]
  uint8 *gsignalStack_16; // [esp+28h] [ebp-30h]
  runtime_g *g; // [esp+2Ch] [ebp-2Ch]
  runtime_sigctxt c; // [esp+38h] [ebp-20h] BYREF
  runtime_stackt_0 st; // [esp+40h] [ebp-18h] BYREF
  runtime_stackt_0 st_0; // [esp+4Ch] [ebp-Ch] BYREF

  ((void (*)(void))loc_808FD8A)();
  if ( !runtime_sigfwdgo(sig, info, ctx) )
  {
    v3 = *(runtime_g **)(__readgsdword(0) - 4);
    if ( v3 )
    {
      g = v3;
      ((void (*)(void))loc_808FD8B)();
      m = g->m;
      gsignal = m->gsignal;
      if ( (unsigned int)&sig < gsignal->stack.lo || (unsigned int)&sig >= gsignal->stack.hi )
      {
        if ( (unsigned int)&sig < m->g0->stack.lo || (unsigned int)&sig >= m->g0->stack.hi )
        {
          memset(&st_0, 0, sizeof(st_0));
          runtime_sigaltstack();
          if ( (uint8 *)&sig >= &st_0.ss_sp[st_0.ss_size] )
          {
            runtime_setg();
            runtime_needm(0);
            runtime_sigNotOnStack(sig);
          }
          v11 = *(_DWORD *)(__readgsdword(0) - 4);
          v12 = *(uint8 ***)(*(_DWORD *)(v11 + 24) + 44);
          gsignalStack = *v12;
          gsignalStack_4 = v12[1];
          gsignalStack_8 = v12[2];
          gsignalStack_12 = v12[3];
          gsignalStack_16 = v12[16];
          ss_sp = st_0.ss_sp;
          *v12 = st_0.ss_sp;
          *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(v11 + 24) + 44) + 4) = &ss_sp[st_0.ss_size];
          ss_sp += 880;
          *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(v11 + 24) + 44) + 8) = ss_sp;
          *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(v11 + 24) + 44) + 12) = ss_sp;
          g->m->gsignal->stktopsp = (uintptr)&sig;
        }
        else
        {
          memset(&st, 0, sizeof(st));
          st.ss_size = g->m->g0->stack.hi - g->m->g0->stack.lo;
          st.ss_sp = (uint8 *)g->m->g0->stack.lo;
          v6 = *(_DWORD *)(__readgsdword(0) - 4);
          v7 = *(uint8 ***)(*(_DWORD *)(v6 + 24) + 44);
          gsignalStack = *v7;
          gsignalStack_4 = v7[1];
          gsignalStack_8 = v7[2];
          gsignalStack_12 = v7[3];
          gsignalStack_16 = v7[16];
          v8 = st.ss_sp;
          *v7 = st.ss_sp;
          *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(v6 + 24) + 44) + 4) = &v8[st.ss_size];
          v8 += 880;
          *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(v6 + 24) + 44) + 8) = v8;
          *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(v6 + 24) + 44) + 12) = v8;
          g->m->gsignal->stktopsp = (uintptr)&sig;
        }
        v9 = 1;
      }
      else
      {
        v9 = 0;
      }
      setStack = v9;
      runtime_setg();
      if ( g->stackguard0 == -1234 )
        runtime_signalDuringFork(sig);
      runtime_sighandler(sig, info, ctx, g);
      runtime_setg();
      if ( setStack )
      {
        v10 = *(uint8 ***)(*(_DWORD *)(*(_DWORD *)(__readgsdword(0) - 4) + 24) + 44);
        *v10 = gsignalStack;
        v10[1] = gsignalStack_4;
        v10[2] = gsignalStack_8;
        v10[3] = gsignalStack_12;
        v10[16] = gsignalStack_16;
      }
    }
    else
    {
      c.info = info;
      c.ctxt = ctx;
      if ( sig == 27 )
        runtime_sigprofNonGoPC(*((_DWORD *)ctx + 19));
      else
        runtime_badsignal(sig, &c);
    }
  }
}
// 807C4FE: variable 'gsignalStack' is possibly undefined
// 807C500: variable 'gsignalStack_4' is possibly undefined
// 807C507: variable 'gsignalStack_8' is possibly undefined
// 807C50E: variable 'gsignalStack_12' is possibly undefined
// 807C515: variable 'gsignalStack_16' is possibly undefined

//----- (0807C6D0) --------------------------------------------------------
void __golang __noreturn runtime_sigpanic()
{
  uint32 sig; // ecx
  uintptr sigcode0; // ecx
  unsigned int v2; // eax
  uintptr v3; // ecx
  unsigned int v4; // eax
  __int32 len; // edx
  string gp; // [esp+0h] [ebp-20h]
  string gpa; // [esp+0h] [ebp-20h]
  string gpb; // [esp+0h] [ebp-20h]
  string gpc; // [esp+0h] [ebp-20h]
  string gpd; // [esp+0h] [ebp-20h]
  string gpe; // [esp+0h] [ebp-20h]
  string gpf; // [esp+0h] [ebp-20h]
  string gpg; // [esp+0h] [ebp-20h]
  interface_{} e; // [esp+8h] [ebp-18h]
  interface_{} ea; // [esp+8h] [ebp-18h]
  uintptr v; // [esp+10h] [ebp-10h]
  uintptr va; // [esp+10h] [ebp-10h]
  runtime_g *v_4; // [esp+14h] [ebp-Ch]
  int elem[2]; // [esp+18h] [ebp-8h] BYREF

  v_4 = *(runtime_g **)(__readgsdword(0) - 4);
  if ( runtime_canpanic(v_4) )
  {
    sig = v_4->sig;
    if ( sig == 7 )
    {
      if ( v_4->sigcode0 != 2 || v_4->sigcode1 >= 0x1000 )
      {
        if ( v_4->paniconfault )
          runtime_panicmem();
        va = v_4->sigcode1;
        runtime_printlock();
        gpd.str = (uint8 *)"unexpected fault address ";
        gpd.len = 25;
        runtime_printstring(gpd);
        runtime_printhex(va);
        gpe.str = (uint8 *)"\n";
        gpe.len = 1;
        runtime_printstring(gpe);
        runtime_printunlock();
        gpf.str = (uint8 *)"fault";
        gpf.len = 5;
        runtime_throw(gpf);
        BUG();
      }
      runtime_panicmem();
    }
    if ( sig == 8 )
    {
      sigcode0 = v_4->sigcode0;
      if ( sigcode0 != 1 )
      {
        if ( sigcode0 != 2 )
          runtime_panicfloat();
        runtime_panicoverflow();
      }
      runtime_panicdivide();
    }
    if ( sig == 11 )
    {
      v3 = v_4->sigcode0;
      if ( v3 && v3 != 1 && v3 != 2 || v_4->sigcode1 >= 0x1000 )
      {
        if ( v_4->paniconfault )
          runtime_panicmem();
        v = v_4->sigcode1;
        runtime_printlock();
        gpa.str = (uint8 *)"unexpected fault address ";
        gpa.len = 25;
        runtime_printstring(gpa);
        runtime_printhex(v);
        gpb.str = (uint8 *)"\n";
        gpb.len = 1;
        runtime_printstring(gpb);
        runtime_printunlock();
        gpc.str = (uint8 *)"fault";
        gpc.len = 5;
        runtime_throw(gpc);
        BUG();
      }
      runtime_panicmem();
    }
    v2 = v_4->sig;
    if ( v2 < 0x41 )
    {
      v4 = v2;
      len = runtime_sigtable[v4].name.len;
      elem[0] = (int)runtime_sigtable[v4].name.str;
      elem[1] = len;
      runtime_convT2Estring((runtime__type_0 *)&want, elem, e);
      runtime_gopanic(ea);
      BUG();
    }
    gp.str = (uint8 *)"unexpected signal value";
    gp.len = 23;
    runtime_throw(gp);
    BUG();
  }
  gpg.str = (uint8 *)"unexpected signal during runtime execution";
  gpg.len = 42;
  runtime_throw(gpg);
  BUG();
}
// 807C802: variable 'e' is possibly undefined
// 807C816: variable 'ea' is possibly undefined

//----- (0807C940) --------------------------------------------------------
void __golang __noreturn runtime_dieFromSignal(uint32 sig)
{
  runtime_setsig(sig, 0);
  runtime_unblocksig(sig);
  runtime_raise();
  runtime_osyield();
  runtime_osyield();
  runtime_osyield();
  runtime_exit();
}

//----- (0807C990) --------------------------------------------------------
void __golang runtime_raisebadsignal(uint32 sig, runtime_sigctxt *c)
{
  uint32 v2; // eax
  uintptr v3; // ecx
  uintptr fn; // [esp+4h] [ebp-10h]
  uintptr handler; // [esp+8h] [ebp-Ch]

  v2 = sig;
  if ( sig != 27 )
  {
    if ( sig < 0x41 )
    {
      runtime_internal_atomic_Loaduintptr();
      v3 = fn;
      v2 = sig;
    }
    else
    {
      v3 = 0;
    }
    if ( (handler = v3, runtime_unblocksig(v2), runtime_setsig(sig, handler), !runtime_isarchive) && !runtime_islibrary
      || handler
      || !c->info->si_code )
    {
      runtime_raise();
      runtime_usleep();
      runtime_setsig(sig, (uintptr)runtime_sighandler);
    }
  }
}
// 807CA70: variable 'fn' is possibly undefined

//----- (0807CA90) --------------------------------------------------------
void __golang __noreturn runtime_crash()
{
  runtime_dieFromSignal(6u);
}

//----- (0807CAC0) --------------------------------------------------------
void __golang __noreturn runtime_noSignalStack(uint32 sig)
{
  string s; // [esp+0h] [ebp-8h]
  string sa; // [esp+0h] [ebp-8h]
  string sb; // [esp+0h] [ebp-8h]

  runtime_printlock();
  s.str = (uint8 *)"signal";
  s.len = 6;
  runtime_printstring(s);
  runtime_printsp();
  runtime_printint(sig);
  runtime_printsp();
  sa.str = (uint8 *)"received on thread with no signal stack";
  sa.len = 39;
  runtime_printstring(sa);
  runtime_printnl();
  runtime_printunlock();
  sb.str = (uint8 *)"non-Go code disabled sigaltstack";
  sb.len = 32;
  runtime_throw(sb);
  BUG();
}

//----- (0807CB50) --------------------------------------------------------
void __golang __noreturn runtime_sigNotOnStack(uint32 sig)
{
  string s; // [esp+0h] [ebp-8h]
  string sa; // [esp+0h] [ebp-8h]
  string sb; // [esp+0h] [ebp-8h]

  runtime_printlock();
  s.str = (uint8 *)"signal";
  s.len = 6;
  runtime_printstring(s);
  runtime_printsp();
  runtime_printint(sig);
  runtime_printsp();
  sa.str = (uint8 *)"received but handler not on signal stack";
  sa.len = 40;
  runtime_printstring(sa);
  runtime_printnl();
  runtime_printunlock();
  sb.str = (uint8 *)"non-Go code set up signal handler without SA_ONSTACK flag";
  sb.len = 57;
  runtime_throw(sb);
  BUG();
}

//----- (0807CBE0) --------------------------------------------------------
void __golang __noreturn runtime_signalDuringFork(uint32 sig)
{
  string s; // [esp+0h] [ebp-8h]
  string sa; // [esp+0h] [ebp-8h]
  string sb; // [esp+0h] [ebp-8h]

  runtime_printlock();
  s.str = (uint8 *)"signal";
  s.len = 6;
  runtime_printstring(s);
  runtime_printsp();
  runtime_printint(sig);
  runtime_printsp();
  sa.str = (uint8 *)"received during fork";
  sa.len = 20;
  runtime_printstring(sa);
  runtime_printnl();
  runtime_printunlock();
  sb.str = (uint8 *)"signal received during fork";
  sb.len = 27;
  runtime_throw(sb);
  BUG();
}

//----- (0807CC70) --------------------------------------------------------
void __golang runtime_badsignal(uintptr sig, runtime_sigctxt *c)
{
  runtime_needm(0);
  if ( !runtime_sigsend(sig) )
    runtime_raisebadsignal(sig, c);
  runtime_dropm();
}

//----- (0807CCB0) --------------------------------------------------------
bool __golang runtime_sigfwdgo(uint32 sig, runtime_siginfo *info, void *ctx)
{
  int v3; // ecx
  int v4; // ecx
  int v5; // [esp+4h] [ebp-18h]

  if ( sig >= 0x41 )
    return 0;
  runtime_internal_atomic_Loaduintptr();
  if ( !runtime_signalsOK )
  {
    if ( !v5 )
      runtime_dieFromSignal(sig);
    goto LABEL_18;
  }
  if ( !v5 )
    return 0;
  if ( !runtime_internal_atomic_Load(&runtime_handlingSig[sig]) )
  {
LABEL_18:
    runtime_sigfwd();
    return 1;
  }
  if ( (!info->si_code || (runtime_sigtable[sig].flags & 8) == 0) && sig != 13 )
    return 0;
  v3 = *(_DWORD *)(__readgsdword(0) - 4);
  if ( v3 )
  {
    v4 = *(_DWORD *)(v3 + 24);
    if ( v4 )
    {
      if ( *(_DWORD *)(v4 + 84) && !*(_BYTE *)(v4 + 145) )
        return 0;
    }
  }
  if ( v5 != 1 )
    runtime_sigfwd();
  return 1;
}
// 807CCE6: variable 'v5' is possibly undefined

//----- (0807CE30) --------------------------------------------------------
void __golang runtime_msigsave(runtime_m *mp)
{
  runtime_sigprocmask(2, 0, (runtime_sigset *)mp->sigmask);
}

//----- (0807CE60) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
void __golang runtime_msigrestore(runtime_sigset sigmask)
{
  runtime_sigprocmask(2, (runtime_sigset *)sigmask, 0);
}
// 807CE60: array has been used for an input argument

//----- (0807CE90) --------------------------------------------------------
void __golang runtime_sigblock()
{
  runtime_sigprocmask(2, (runtime_sigset *)runtime_sigset_all, 0);
}

//----- (0807CEC0) --------------------------------------------------------
void __golang runtime_unblocksig(uint32 sig)
{
  unsigned int v1; // edx
  runtime_sigset set; // [esp+Ch] [ebp-8h] BYREF

  set[0] = 0;
  set[1] = 0;
  v1 = (int)(((unsigned int)((int)(sig - 1) >> 31) >> 27) + sig - 1) >> 5;
  if ( v1 >= 2 )
    runtime_panicindex();
  set[v1] |= 1 << (sig - 1);
  runtime_sigprocmask(1, (runtime_sigset *)set, 0);
}

//----- (0807CF30) --------------------------------------------------------
void __golang runtime_minitSignals()
{
  runtime_minitSignalStack();
  runtime_minitSignalMask();
}

//----- (0807CF60) --------------------------------------------------------
void __golang runtime_minitSignalStack()
{
  int v0; // eax
  runtime_g *_g_; // [esp+8h] [ebp-10h]

  _g_ = *(runtime_g **)(__readgsdword(0) - 4);
  runtime_sigaltstack();
  v0 = *(_DWORD *)(__readgsdword(0) - 4);
  **(_DWORD **)(*(_DWORD *)(v0 + 24) + 44) = 0;
  *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(v0 + 24) + 44) + 4) = 0;
  *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(v0 + 24) + 44) + 8) = 880;
  *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(v0 + 24) + 44) + 12) = 880;
  _g_->m->newSigstack = 0;
}

//----- (0807D050) --------------------------------------------------------
void __golang runtime_minitSignalMask()
{
  int v0; // eax
  uint32 v1; // edx
  uint32 v2; // eax
  int i; // eax
  unsigned int v4; // edx
  runtime_sigset nmask; // [esp+Ch] [ebp-8h] BYREF

  v0 = *(_DWORD *)(*(_DWORD *)(__readgsdword(0) - 4) + 24);
  v1 = *(_DWORD *)(v0 + 48);
  v2 = *(_DWORD *)(v0 + 52);
  nmask[0] = v1;
  nmask[1] = v2;
  for ( i = 0; i < 65; ++i )
  {
    if ( (unsigned int)i >= 0x41 )
      runtime_panicindex();
    if ( (runtime_sigtable[i].flags & 0x80) != 0 )
    {
      v4 = (int)(((unsigned int)((i - 1) >> 31) >> 27) + i - 1) >> 5;
      if ( v4 >= 2 )
        runtime_panicindex();
      nmask[v4] &= ~(1 << (i - 1));
    }
  }
  runtime_sigprocmask(2, (runtime_sigset *)nmask, 0);
}

//----- (0807D120) --------------------------------------------------------
void __golang runtime_unminitSignals()
{
  if ( *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(__readgsdword(0) - 4) + 24) + 143) )
    runtime_sigaltstack();
}

//----- (0807D170) --------------------------------------------------------
void __golang runtime_signalstack(runtime_stack_0 *s)
{
  runtime_sigaltstack();
}

//----- (0807D1C0) --------------------------------------------------------
bool __golang runtime_sigsend(uint32 s)
{
  int v1; // eax
  string ptr; // [esp+0h] [ebp-18h]
  uint32 v3; // [esp+4h] [ebp-14h]
  uint32 v4; // [esp+4h] [ebp-14h]
  char v5; // [esp+Ch] [ebp-Ch]

  if ( !runtime_sig.inuse || s >= 0x60 )
    return 0;
  if ( s >> 5 >= 3 )
    runtime_panicindex();
  v3 = runtime_internal_atomic_Load(&runtime_sig.wanted[s >> 5]);
  v1 = 1 << s;
  if ( ((1 << s) & v3) == 0 )
    return 0;
  while ( 1 )
  {
    if ( (v1 & runtime_sig.mask[s >> 5]) != 0 )
      return 1;
    runtime_internal_atomic_Cas();
    if ( v5 )
      break;
    v1 = 1 << s;
  }
  v4 = runtime_internal_atomic_Load(&runtime_sig.state);
  if ( v4 )
  {
    if ( v4 == 1 )
    {
      runtime_internal_atomic_Cas();
      runtime_notewakeup(&runtime_sig.note);
    }
    else if ( v4 != 2 )
    {
      ptr.str = (uint8 *)"sigsend: inconsistent state";
      ptr.len = 27;
      runtime_throw(ptr);
      BUG();
    }
  }
  else
  {
    runtime_internal_atomic_Cas();
  }
  return 1;
}
// 807D2AB: conditional instruction was optimized away because %var_C.1!=0
// 807D2F0: conditional instruction was optimized away because %var_C.1!=0
// 807D269: variable 'v5' is possibly undefined

//----- (0807D340) --------------------------------------------------------
bool __golang runtime_signal_ignored(uint32 s)
{
  if ( s >> 5 >= 3 )
    runtime_panicindex();
  return ((1 << s) & runtime_internal_atomic_Load(&runtime_sig.ignored[s >> 5])) != 0;
}

//----- (0807D3A0) --------------------------------------------------------
runtime_slice_0 __golang runtime_makeslice(runtime__type_0 *et, __int32 len, __int32 cap)
{
  uintptr v3; // edx
  unsigned int v4; // eax
  interface_{} size; // [esp+0h] [ebp-10h]
  interface_{} sizea; // [esp+0h] [ebp-10h]
  runtime_slice_0 _r3; // [esp+20h] [ebp+10h]

  v3 = et->size;
  if ( et->size >= 0x21 )
    v4 = 0xFFFFFFFF / v3;
  else
    v4 = runtime_maxElems[v3];
  if ( len < 0 || len > v4 )
  {
    sizea._type = (runtime__type_0 *)&want;
    sizea.data = &runtime_statictmp_22;
    runtime_gopanic(sizea);
    BUG();
  }
  if ( cap < len || cap > v4 )
  {
    size._type = (runtime__type_0 *)&want;
    size.data = &runtime_statictmp_23;
    runtime_gopanic(size);
    BUG();
  }
  _r3.array = runtime_mallocgc(cap * v3, et, 1);
  _r3.len = len;
  _r3.cap = cap;
  return _r3;
}

//----- (0807D470) --------------------------------------------------------
runtime_slice_0 __golang runtime_growslice(runtime__type_0 *et, runtime_slice_0 old, __int32 cap)
{
  uintptr v3; // edx
  unsigned __int32 v4; // ebx
  unsigned __int32 len; // edi
  __int32 v6; // eax
  unsigned int v7; // ebx
  unsigned int v8; // ebx
  unsigned int v9; // eax
  char *v10; // eax
  unsigned __int32 v11; // ecx
  unsigned int v12; // ebx
  unsigned int v13; // ebx
  unsigned int v14; // ebx
  unsigned int v15; // ebx
  unsigned int v16; // ebx
  unsigned int v17; // ebx
  unsigned int v18; // ebx
  unsigned int v19; // ebx
  unsigned int v20; // ebx
  unsigned int v21; // ebx
  unsigned int v22; // ebx
  unsigned int v23; // ebx
  interface_{} size; // [esp+0h] [ebp-3Ch]
  interface_{} sizea; // [esp+0h] [ebp-3Ch]
  char *v26; // [esp+Ch] [ebp-30h]
  uintptr _r1; // [esp+10h] [ebp-2Ch]
  uintptr x; // [esp+14h] [ebp-28h]
  uintptr capmem; // [esp+24h] [ebp-18h]
  char *p_0; // [esp+34h] [ebp-8h]
  runtime_slice_0 _r3; // [esp+54h] [ebp+18h]

  v3 = et->size;
  if ( et->size )
  {
    v4 = old.cap;
    if ( cap > 2 * old.cap )
    {
      v6 = old.cap;
      len = old.len;
      v4 = cap;
    }
    else
    {
      len = old.len;
      if ( old.len < 1024 )
      {
        v6 = old.cap;
        v4 = 2 * old.cap;
      }
      else
      {
        v6 = old.cap;
        while ( (int)v4 < cap )
          v4 += (int)v4 / 4;
      }
    }
    if ( v3 == 1 )
    {
      if ( v4 >= 0x8000 )
      {
        if ( v4 + 0x2000 >= v4 )
          v4 = (v4 + 0x1FFF) & 0xFFFFE000;
      }
      else if ( v4 > 0x3F8 )
      {
        v12 = (v4 - 897) >> 7;
        if ( v12 >= 0xF9 || (v13 = runtime_size_to_class128[v12], v13 >= 0x43) )
          runtime_panicindex();
        v4 = runtime_class_to_size[v13];
      }
      else
      {
        v7 = (v4 + 7) >> 3;
        if ( v7 >= 0x81 || (v8 = runtime_size_to_class8[v7], v8 >= 0x43) )
          runtime_panicindex();
        v4 = runtime_class_to_size[v8];
      }
      capmem = v4;
    }
    else if ( v3 == 4 )
    {
      v14 = 4 * v4;
      if ( v14 >= 0x8000 )
      {
        if ( v14 + 0x2000 >= v14 )
          v14 = (v14 + 0x1FFF) & 0xFFFFE000;
      }
      else if ( v14 > 0x3F8 )
      {
        v17 = (v14 - 897) >> 7;
        if ( v17 >= 0xF9 || (v18 = runtime_size_to_class128[v17], v18 >= 0x43) )
          runtime_panicindex();
        v14 = runtime_class_to_size[v18];
      }
      else
      {
        v15 = (v14 + 7) >> 3;
        if ( v15 >= 0x81 || (v16 = runtime_size_to_class8[v15], v16 >= 0x43) )
          runtime_panicindex();
        v14 = runtime_class_to_size[v16];
      }
      _r1 = v14;
      len *= 4;
      v4 = v14 >> 2;
      capmem = _r1;
    }
    else
    {
      len *= v3;
      v19 = v3 * v4;
      if ( v19 >= 0x8000 )
      {
        if ( v19 + 0x2000 >= v19 )
          v19 = (v19 + 0x1FFF) & 0xFFFFE000;
      }
      else if ( v19 > 0x3F8 )
      {
        v22 = (v19 - 897) >> 7;
        if ( v22 >= 0xF9 || (v23 = runtime_size_to_class128[v22], v23 >= 0x43) )
          runtime_panicindex();
        v19 = runtime_class_to_size[v23];
      }
      else
      {
        v20 = (v19 + 7) >> 3;
        if ( v20 >= 0x81 || (v21 = runtime_size_to_class8[v20], v21 >= 0x43) )
          runtime_panicindex();
        v19 = runtime_class_to_size[v21];
      }
      capmem = v19;
      v4 = v19 / v3;
    }
    if ( cap < v6 || (v3 >= 0x21 ? (v9 = 0xFFFFFFFF / v3) : (v9 = runtime_maxElems[v3]), v4 > v9) )
    {
      size._type = (runtime__type_0 *)&want;
      size.data = &runtime_statictmp_27;
      runtime_gopanic(size);
      BUG();
    }
    if ( (et->kind & 0x80u) != 0 )
    {
      p_0 = (char *)runtime_mallocgc(capmem, 0, 0);
      runtime_memmove();
      runtime_memclrNoHeapPointers();
      v10 = p_0;
    }
    else
    {
      v26 = (char *)runtime_mallocgc(capmem, et, 1);
      v10 = v26;
      if ( runtime_writeBarrier.enabled )
      {
        v11 = 0;
        while ( v11 < len )
        {
          x = v11;
          runtime_typedmemmove(et, &v10[v11], (char *)old.array + v11);
          v11 = et->size + x;
          v10 = v26;
        }
      }
      else
      {
        runtime_memmove();
        v10 = v26;
      }
    }
    _r3.array = v10;
    _r3.len = old.len;
    _r3.cap = v4;
  }
  else
  {
    if ( cap < old.cap )
    {
      sizea._type = (runtime__type_0 *)&want;
      sizea.data = &runtime_statictmp_26;
      runtime_gopanic(sizea);
      BUG();
    }
    _r3.array = &runtime_zerobase;
    _r3.len = old.len;
    _r3.cap = cap;
  }
  return _r3;
}

//----- (0807D900) --------------------------------------------------------
void __golang runtime_stackinit()
{
  int i; // eax
  runtime_mSpanList_0 *v1; // edx
  int j; // eax
  runtime_mSpanList_0 *v3; // edx

  for ( i = 0; i < 4; ++i )
  {
    if ( (unsigned int)i >= 4 )
      runtime_panicindex();
    v1 = &runtime_stackpool[i];
    v1->first = 0;
    v1->last = 0;
  }
  for ( j = 0; j < 19; ++j )
  {
    if ( (unsigned int)j >= 0x13 )
      runtime_panicindex();
    v3 = &runtime_stackLarge.free[j];
    v3->first = 0;
    v3->last = 0;
  }
}

//----- (0807D980) --------------------------------------------------------
__int32 __golang runtime_stacklog2(uintptr n)
{
  __int32 v2; // ecx

  v2 = 0;
  while ( n > 1 )
  {
    n >>= 1;
    ++v2;
  }
  return v2;
}

//----- (0807D9B0) --------------------------------------------------------
runtime_gclinkptr __golang runtime_stackpoolalloc(uint8 order)
{
  unsigned int i; // ecx
  runtime_gclinkptr *v2; // ebx
  runtime_mspan *first; // eax
  runtime_gclinkptr *manualFreeList; // ecx
  string h; // [esp+0h] [ebp-1Ch]
  string ha; // [esp+0h] [ebp-1Ch]
  string hb; // [esp+0h] [ebp-1Ch]
  string hc; // [esp+0h] [ebp-1Ch]
  runtime_mspan *span; // [esp+Ch] [ebp-10h]
  runtime_gclinkptr p; // [esp+10h] [ebp-Ch]
  runtime_mSpanList_0 *list; // [esp+18h] [ebp-4h]

  if ( order >= 4u )
    runtime_panicindex();
  list = &runtime_stackpool[order];
  if ( list->first )
  {
    first = runtime_stackpool[order].first;
  }
  else
  {
    span = runtime___ptr_mheap__allocManual(&runtime_mheap_, 4u, &runtime_memstats.stacks_inuse);
    if ( !span )
    {
      hc.str = (uint8 *)"out of memory";
      hc.len = 13;
      runtime_throw(hc);
      BUG();
    }
    if ( span->allocCount )
    {
      hb.str = (uint8 *)"bad allocCount";
      hb.len = 14;
      runtime_throw(hb);
      BUG();
    }
    if ( span->manualFreeList )
    {
      ha.str = (uint8 *)"bad manualFreeList";
      ha.len = 18;
      runtime_throw(ha);
      BUG();
    }
    span->elemsize = order < 0x20u ? 2048 << order : 0;
    for ( i = 0; i < 0x8000; i += span->elemsize )
    {
      v2 = (runtime_gclinkptr *)(i + span->startAddr);
      *v2 = span->manualFreeList;
      span->manualFreeList = (runtime_gclinkptr)v2;
    }
    runtime___ptr_mSpanList__insert(list, span);
    first = span;
  }
  manualFreeList = (runtime_gclinkptr *)first->manualFreeList;
  if ( !manualFreeList )
  {
    h.str = (uint8 *)"span has no free stacks";
    h.len = 23;
    runtime_throw(h);
    BUG();
  }
  first->manualFreeList = *manualFreeList;
  ++first->allocCount;
  if ( !first->manualFreeList )
  {
    p = (runtime_gclinkptr)manualFreeList;
    runtime___ptr_mSpanList__remove(list, first);
    return p;
  }
  return (runtime_gclinkptr)manualFreeList;
}

//----- (0807DB40) --------------------------------------------------------
void __golang runtime_stackpoolfree(runtime_gclinkptr x, uint8 order)
{
  _DWORD *v2; // edx
  runtime_gclinkptr v3; // ecx
  runtime_mspan *span; // eax
  uint16 allocCount; // cx
  string list; // [esp+0h] [ebp-10h]
  runtime_mspan *s; // [esp+Ch] [ebp-4h]

  v2 = (_DWORD *)x;
  v3 = (x - dword_81493A8) >> 13;
  if ( v3 >= dword_814910C )
    runtime_panicindex();
  span = *(runtime_mspan **)(dword_8149108 + 4 * v3);
  if ( span->state != 2 )
  {
    list.str = (uint8 *)"freeing stack not in a stack span";
    list.len = 33;
    runtime_throw(list);
    BUG();
  }
  s = *(runtime_mspan **)(dword_8149108 + 4 * v3);
  if ( !span->manualFreeList )
  {
    if ( order >= 4u )
      runtime_panicindex();
    runtime___ptr_mSpanList__insert(&runtime_stackpool[order], span);
    span = s;
    v2 = (_DWORD *)x;
  }
  *v2 = span->manualFreeList;
  span->manualFreeList = (runtime_gclinkptr)v2;
  allocCount = span->allocCount;
  span->allocCount = allocCount - 1;
  if ( !runtime_gcphase && allocCount == 1 )
  {
    if ( order >= 4u )
      runtime_panicindex();
    runtime___ptr_mSpanList__remove(&runtime_stackpool[order], span);
    s->manualFreeList = 0;
    runtime___ptr_mheap__freeManual(&runtime_mheap_, s, &runtime_memstats.stacks_inuse);
  }
}
// 8149108: using guessed type int dword_8149108;
// 814910C: using guessed type int dword_814910C;
// 81493A8: using guessed type int dword_81493A8;

//----- (0807DC80) --------------------------------------------------------
void __golang runtime_stackcacherefill(runtime_mcache *c, uint8 order)
{
  unsigned int v2; // eax
  _DWORD *v3; // ecx
  _DWORD *v4; // [esp+4h] [ebp-Ch]
  uintptr size; // [esp+8h] [ebp-8h]
  runtime_gclinkptr list; // [esp+Ch] [ebp-4h]

  runtime_lock(&runtime_stackpoolmu);
  v2 = 0;
  v3 = 0;
  while ( 1 )
  {
    size = v2;
    list = (runtime_gclinkptr)v3;
    if ( v2 >= 0x4000 )
      break;
    v4 = (_DWORD *)runtime_stackpoolalloc(order);
    *v4 = list;
    v3 = v4;
    v2 = size + (order < 0x20u ? 2048 << order : 0);
  }
  runtime_unlock(&runtime_stackpoolmu);
  if ( order >= 4u )
    runtime_panicindex();
  c->stackcache[order].list = list;
  c->stackcache[order].size = size;
}
// 807DC80: could not find valid save-restore pair for ebx

//----- (0807DD50) --------------------------------------------------------
void __golang runtime_stackcacherelease(runtime_mcache *c, uint8 order)
{
  uintptr v2; // ebx
  runtime_gclinkptr *v3; // ebp
  runtime_gclinkptr y; // [esp+8h] [ebp-1Ch]
  uintptr size; // [esp+18h] [ebp-Ch]
  runtime_gclinkptr x; // [esp+1Ch] [ebp-8h]

  if ( order >= 4u )
    runtime_panicindex();
  x = c->stackcache[order].list;
  size = c->stackcache[order].size;
  runtime_lock(&runtime_stackpoolmu);
  v2 = size;
  v3 = (runtime_gclinkptr *)x;
  while ( v2 > 0x4000 )
  {
    y = *v3;
    runtime_stackpoolfree((runtime_gclinkptr)v3, order);
    v2 -= order < 0x20u ? 2048 << order : 0;
    v3 = (runtime_gclinkptr *)y;
  }
  runtime_unlock(&runtime_stackpoolmu);
  c->stackcache[order].list = (runtime_gclinkptr)v3;
  c->stackcache[order].size = v2;
}
// 807DD50: could not find valid save-restore pair for ebp

//----- (0807DE60) --------------------------------------------------------
void __golang runtime_stackcache_clear(runtime_mcache *c)
{
  uint8 i; // al
  runtime_mcache *v2; // ecx
  int v3; // edx
  runtime_stackfreelist *v4; // ebx
  runtime_gclinkptr *list; // ebp
  uint8 order; // [esp+Bh] [ebp-Dh]
  runtime_gclinkptr y; // [esp+Ch] [ebp-Ch]
  int v8; // [esp+10h] [ebp-8h]
  runtime_stackfreelist *v9; // [esp+14h] [ebp-4h]

  runtime_lock(&runtime_stackpoolmu);
  for ( i = 0; i < 4u; ++i )
  {
    v2 = c;
    if ( i >= 4u )
      runtime_panicindex();
    order = i;
    v4 = &c->stackcache[i];
    v9 = v4;
    list = (runtime_gclinkptr *)v4->list;
    v3 = 8 * i;
    v8 = v3;
    while ( list )
    {
      y = *list;
      runtime_stackpoolfree((runtime_gclinkptr)list, i);
      i = order;
      v2 = c;
      v3 = v8;
      v4 = v9;
      list = (runtime_gclinkptr *)y;
    }
    v4->list = 0;
    *(uintptr *)((char *)&v2->stackcache[0].size + v3) = 0;
  }
  runtime_unlock(&runtime_stackpoolmu);
}

//----- (0807DF20) --------------------------------------------------------
runtime_stack_0 __golang runtime_stackalloc(uint32 n)
{
  int v1; // eax
  _DWORD *v2; // ecx
  uint32 v3; // eax
  uint32 v4; // edx
  uint8 v5; // bl
  runtime_mcache *v6; // eax
  uintptr startAddr; // eax
  int v8; // ebp
  runtime_gclinkptr *list; // esi
  runtime_stackfreelist *v10; // ecx
  runtime_mspan *first; // eax
  runtime_mspan *v12; // eax
  runtime_mspan *v13; // eax
  string l; // [esp+0h] [ebp-34h]
  string la; // [esp+0h] [ebp-34h]
  string lb; // [esp+0h] [ebp-34h]
  string lc; // [esp+0h] [ebp-34h]
  uint64 *stat; // [esp+8h] [ebp-2Ch]
  runtime_mspan *v19; // [esp+Ch] [ebp-28h]
  uintptr _r2; // [esp+14h] [ebp-20h]
  runtime_gclinkptr x; // [esp+18h] [ebp-1Ch]
  unsigned int log2npage; // [esp+20h] [ebp-14h]
  runtime_mspan *s; // [esp+24h] [ebp-10h]
  runtime_mspan *v24; // [esp+28h] [ebp-Ch]
  runtime_stackfreelist *v25; // [esp+2Ch] [ebp-8h]
  runtime_stack_0 _r1; // [esp+3Ch] [ebp+8h]

  v1 = *(_DWORD *)(__readgsdword(0) - 4);
  v2 = *(_DWORD **)(v1 + 24);
  if ( v1 != *v2 )
  {
    lc.str = (uint8 *)"stackalloc not on scheduler stack";
    lc.len = 33;
    runtime_throw(lc);
    BUG();
  }
  v3 = n;
  if ( ((n - 1) & n) != 0 )
  {
    lb.str = (uint8 *)"stack size not a power of 2";
    lb.len = 27;
    runtime_throw(lb);
    BUG();
  }
  if ( runtime_debug.efence )
  {
    _r2 = ~(runtime_physPageSize - 1) & (n + runtime_physPageSize - 1);
    stat = (uint64 *)runtime_sysAlloc(_r2, &runtime_memstats.stacks_sys);
    if ( !stat )
    {
      la.str = (uint8 *)"out of memory (stackalloc)";
      la.len = 26;
      runtime_throw(la);
      BUG();
    }
    _r1.lo = (uintptr)stat;
    _r1.hi = (uintptr)stat + _r2;
  }
  else
  {
    if ( n >= 0x8000 )
    {
      log2npage = runtime_stacklog2(n >> 13);
      runtime_lock(&runtime_stackLarge.lock);
      if ( log2npage >= 0x13 )
        runtime_panicindex();
      first = runtime_stackLarge.free[log2npage].first;
      if ( first )
      {
        v24 = runtime_stackLarge.free[log2npage].first;
        runtime___ptr_mSpanList__remove(&runtime_stackLarge.free[log2npage], first);
        v12 = v24;
      }
      else
      {
        v12 = 0;
      }
      s = v12;
      runtime_unlock(&runtime_stackLarge.lock);
      v13 = s;
      if ( !s )
      {
        v19 = runtime___ptr_mheap__allocManual(&runtime_mheap_, n >> 13, &runtime_memstats.stacks_inuse);
        v13 = v19;
        if ( !v19 )
        {
          l.str = (uint8 *)"out of memory";
          l.len = 13;
          runtime_throw(l);
          BUG();
        }
        v19->elemsize = n;
      }
      startAddr = v13->startAddr;
    }
    else
    {
      v4 = n;
      v5 = 0;
      while ( v3 > 0x800 )
      {
        ++v5;
        v3 >>= 1;
      }
      v6 = (runtime_mcache *)v2[46];
      if ( !v6 || v2[29] || v2[34] )
      {
        runtime_lock(&runtime_stackpoolmu);
        x = runtime_stackpoolalloc(v5);
        runtime_unlock(&runtime_stackpoolmu);
        startAddr = x;
      }
      else
      {
        if ( v5 >= 4u )
          runtime_panicindex();
        v8 = (int)&v6->stackcache[v5];
        list = *(runtime_gclinkptr **)v8;
        v10 = (runtime_stackfreelist *)v8;
        if ( !*(_DWORD *)v8 )
        {
          v25 = &v6->stackcache[v5];
          runtime_stackcacherefill(v6, v5);
          v10 = v25;
          list = (runtime_gclinkptr *)v25->list;
          v4 = n;
        }
        v10->list = *list;
        *(_DWORD *)(v8 + 4) -= v4;
        startAddr = (uintptr)list;
      }
    }
    _r1.lo = startAddr;
    _r1.hi = n + startAddr;
  }
  return _r1;
}

//----- (0807E1C0) --------------------------------------------------------
void __golang runtime_stackfree(runtime_stack_0 stk)
{
  int v1; // eax
  _DWORD *lo; // ecx
  uintptr v3; // ebx
  uintptr v4; // edx
  uint8 v5; // bp
  _DWORD *v6; // eax
  runtime_mcache *v7; // ebx
  runtime_stackfreelist *v8; // esi
  uintptr *p_size; // eax
  uintptr v10; // ecx
  runtime_mspan *v11; // eax
  string l; // [esp+0h] [ebp-2Ch]
  string la; // [esp+0h] [ebp-2Ch]
  uintptr _r0; // [esp+10h] [ebp-1Ch]
  unsigned int log2npage; // [esp+14h] [ebp-18h]
  runtime_mspan *s; // [esp+20h] [ebp-Ch]

  v1 = *(_DWORD *)(__readgsdword(0) - 4);
  lo = (_DWORD *)stk.lo;
  v3 = stk.hi - stk.lo;
  if ( ((stk.hi - stk.lo - 1) & (stk.hi - stk.lo)) != 0 )
  {
    la.str = (uint8 *)"stack not a power of 2";
    la.len = 22;
    runtime_throw(la);
    BUG();
  }
  if ( runtime_debug.efence )
  {
    runtime_sysFault((void *)stk.lo, stk.hi - stk.lo);
  }
  else if ( v3 >= 0x8000 )
  {
    v10 = (stk.lo - dword_81493A8) >> 13;
    if ( v10 >= dword_814910C )
      runtime_panicindex();
    v11 = *(runtime_mspan **)(dword_8149108 + 4 * v10);
    if ( v11->state != 2 )
    {
      _r0 = v11->startAddr;
      runtime_printlock();
      runtime_printhex(_r0);
      runtime_printsp();
      runtime_printpointer((void *)stk.lo);
      runtime_printnl();
      runtime_printunlock();
      l.str = (uint8 *)"bad span state";
      l.len = 14;
      runtime_throw(l);
      BUG();
    }
    if ( runtime_gcphase )
    {
      s = *(runtime_mspan **)(dword_8149108 + 4 * v10);
      log2npage = runtime_stacklog2(v11->npages);
      runtime_lock(&runtime_stackLarge.lock);
      if ( log2npage >= 0x13 )
        runtime_panicindex();
      runtime___ptr_mSpanList__insert(&runtime_stackLarge.free[log2npage], s);
      runtime_unlock(&runtime_stackLarge.lock);
    }
    else
    {
      runtime___ptr_mheap__freeManual(&runtime_mheap_, v11, &runtime_memstats.stacks_inuse);
    }
  }
  else
  {
    v4 = stk.hi - stk.lo;
    v5 = 0;
    while ( v3 > 0x800 )
    {
      ++v5;
      v3 >>= 1;
    }
    v6 = *(_DWORD **)(v1 + 24);
    v7 = (runtime_mcache *)v6[46];
    if ( !v7 || v6[29] || v6[34] )
    {
      runtime_lock(&runtime_stackpoolmu);
      runtime_stackpoolfree(stk.lo, v5);
      runtime_unlock(&runtime_stackpoolmu);
    }
    else
    {
      if ( v5 >= 4u )
        runtime_panicindex();
      v8 = &v7->stackcache[v5];
      p_size = &v7->stackcache[v5].size;
      if ( *p_size >= 0x8000 )
      {
        runtime_stackcacherelease(v7, v5);
        p_size = &v7->stackcache[v5].size;
        lo = (_DWORD *)stk.lo;
        v4 = stk.hi - stk.lo;
      }
      *lo = v8->list;
      v8->list = (runtime_gclinkptr)lo;
      *p_size += v4;
    }
  }
}
// 8149108: using guessed type int dword_8149108;
// 814910C: using guessed type int dword_814910C;
// 81493A8: using guessed type int dword_81493A8;

//----- (0807E460) --------------------------------------------------------
void __golang runtime_adjustpointers(
        void *scanp,
        runtime_bitvector_0 *cbv,
        runtime_adjustinfo *adjinfo,
        runtime_funcInfo_0 f)
{
  uintptr lo; // edx
  unsigned __int32 n; // esi
  char *v6; // edi
  unsigned int *v7; // eax
  unsigned int v8; // ebx
  string v9; // [esp+0h] [ebp-54h]
  string v10; // [esp+0h] [ebp-54h]
  string v11; // [esp+0h] [ebp-54h]
  string v12; // [esp+0h] [ebp-54h]
  string v13; // [esp+0h] [ebp-54h]
  string v14; // [esp+8h] [ebp-4Ch]
  char v15; // [esp+Ch] [ebp-48h]
  uintptr p; // [esp+10h] [ebp-44h]
  uintptr i; // [esp+14h] [ebp-40h]
  uintptr delta; // [esp+18h] [ebp-3Ch]
  uintptr sghi; // [esp+20h] [ebp-34h]
  int32 v20; // [esp+28h] [ebp-2Ch]
  uintptr hi; // [esp+2Ch] [ebp-28h]
  uintptr v22; // [esp+30h] [ebp-24h]
  uint8 *bv_4; // [esp+48h] [ebp-Ch]
  unsigned int bv_8; // [esp+4Ch] [ebp-8h]

  if ( (unsigned int)((int)(((unsigned int)((cbv->n + 7) >> 31) >> 29) + cbv->n + 7) >> 3) > 0x40000000 )
    runtime_panicslice();
  bv_4 = cbv->bytedata;
  bv_8 = (int)(((unsigned int)((cbv->n + 7) >> 31) >> 29) + cbv->n + 7) >> 3;
  lo = adjinfo->old.lo;
  v22 = adjinfo->old.lo;
  hi = adjinfo->old.hi;
  delta = adjinfo->delta;
  n = cbv->n;
  v20 = cbv->n;
  v6 = (char *)scanp;
  sghi = adjinfo->sghi;
  for ( i = 0; i < n; ++i )
  {
    if ( i >> 3 >= bv_8 )
      runtime_panicindex();
    if ( ((bv_4[i >> 3] >> (i & 7)) & 1) == 1 )
    {
      v7 = (unsigned int *)&v6[4 * i];
      while ( 1 )
      {
        v8 = *v7;
        if ( f._func && v8 && v8 < 0x1000 && runtime_debug.invalidptr )
        {
          p = *v7;
          *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(__readgsdword(0) - 4) + 24) + 461) = 2;
          v14 = runtime_funcname(f);
          runtime_printlock();
          v9.str = (uint8 *)"runtime: bad pointer in frame ";
          v9.len = 30;
          runtime_printstring(v9);
          runtime_printstring(v14);
          v10.str = (uint8 *)" at ";
          v10.len = 4;
          runtime_printstring(v10);
          runtime_printpointer(&v6[4 * i]);
          v11.str = (uint8 *)": ";
          v11.len = 2;
          runtime_printstring(v11);
          runtime_printhex(p);
          v12.str = (uint8 *)"\n";
          v12.len = 1;
          runtime_printstring(v12);
          runtime_printunlock();
          v13.str = (uint8 *)"invalid pointer found on stack";
          v13.len = 30;
          runtime_throw(v13);
          BUG();
        }
        if ( lo > v8 || v8 >= hi )
          break;
        if ( (unsigned int)scanp >= sghi )
        {
          *v7 = delta + v8;
          break;
        }
        runtime_internal_atomic_Casp1();
        if ( v15 )
          break;
        v7 = (unsigned int *)&v6[4 * i];
        lo = v22;
      }
    }
    lo = v22;
    n = v20;
    v6 = (char *)scanp;
  }
}
// 807E579: variable 'v15' is possibly undefined

//----- (0807E700) --------------------------------------------------------
bool __golang runtime_adjustframe(runtime_stkframe *frame, void *arg)
{
  uintptr continpc; // ecx
  uintptr entry; // ebp
  int32 v4; // eax
  runtime_stkframe *v5; // ecx
  uintptr sp; // ebx
  int32 *p_n; // edx
  uint8 *v8; // eax
  string f; // [esp+0h] [ebp-54h]
  string fa; // [esp+0h] [ebp-54h]
  string fb; // [esp+0h] [ebp-54h]
  string fc; // [esp+0h] [ebp-54h]
  string fd; // [esp+0h] [ebp-54h]
  string fe; // [esp+0h] [ebp-54h]
  string ff; // [esp+0h] [ebp-54h]
  string fg; // [esp+0h] [ebp-54h]
  string fh; // [esp+0h] [ebp-54h]
  string fi; // [esp+0h] [ebp-54h]
  string fj; // [esp+0h] [ebp-54h]
  string fk; // [esp+0h] [ebp-54h]
  string fl; // [esp+0h] [ebp-54h]
  string fm; // [esp+0h] [ebp-54h]
  string fn; // [esp+0h] [ebp-54h]
  string fo; // [esp+0h] [ebp-54h]
  string fp; // [esp+0h] [ebp-54h]
  string fq; // [esp+0h] [ebp-54h]
  string fr; // [esp+0h] [ebp-54h]
  string fs; // [esp+0h] [ebp-54h]
  string ft; // [esp+0h] [ebp-54h]
  string fu; // [esp+0h] [ebp-54h]
  string table; // [esp+8h] [ebp-4Ch]
  string tablea; // [esp+8h] [ebp-4Ch]
  string tableb; // [esp+8h] [ebp-4Ch]
  string tablec; // [esp+8h] [ebp-4Ch]
  runtime_stackmap *v35; // [esp+Ch] [ebp-48h]
  runtime_stackmap *v36; // [esp+Ch] [ebp-48h]
  uintptr targetpc; // [esp+18h] [ebp-3Ch]
  uintptr size; // [esp+1Ch] [ebp-38h]
  int pcdata; // [esp+20h] [ebp-34h]
  uintptr arglen; // [esp+24h] [ebp-30h]
  uintptr argp; // [esp+28h] [ebp-2Ch]
  uintptr varp; // [esp+28h] [ebp-2Ch]
  int32 v; // [esp+30h] [ebp-24h]
  int32 va; // [esp+30h] [ebp-24h]
  runtime_moduledata_0 *v_4; // [esp+34h] [ebp-20h]
  runtime__func *f__func; // [esp+38h] [ebp-1Ch]
  runtime_stackmap *s_4; // [esp+40h] [ebp-14h]
  runtime_stackmap *s_4a; // [esp+40h] [ebp-14h]
  runtime_bitvector_0 bv; // [esp+44h] [ebp-10h] BYREF
  runtime_bitvector_0 bv_0; // [esp+4Ch] [ebp-8h] BYREF

  bv.n = 0;
  bv.bytedata = 0;
  continpc = frame->continpc;
  if ( !continpc )
    return 1;
  entry = frame->fn._func->entry;
  if ( entry == runtime_systemstack_switchPC )
    return 1;
  if ( continpc != entry )
    --continpc;
  targetpc = continpc;
  v_4 = frame->fn.datap;
  f__func = frame->fn._func;
  v4 = runtime_pcdatavalue(frame->fn, 0, continpc, (runtime_pcvalueCache *)((char *)arg + 12));
  if ( v4 == -1 )
    v4 = 0;
  pcdata = v4;
  v5 = frame;
  sp = frame->sp;
  if ( frame->varp != sp )
  {
    size = frame->varp - sp;
    bv.n = 0;
    bv.bytedata = 0;
    v36 = (runtime_stackmap *)runtime_funcdata(
                                (runtime_funcInfo_0)__PAIR64__((unsigned int)v_4, (unsigned int)f__func),
                                1);
    if ( !v36 || v36->n <= 0 )
    {
      tablec = runtime_funcname((runtime_funcInfo_0)__PAIR64__((unsigned int)v_4, (unsigned int)f__func));
      varp = frame->varp;
      runtime_printlock();
      fq.str = (uint8 *)"runtime: frame ";
      fq.len = 15;
      runtime_printstring(fq);
      runtime_printstring(tablec);
      fr.str = (uint8 *)" untyped locals ";
      fr.len = 16;
      runtime_printstring(fr);
      runtime_printhex(varp - size);
      fs.str = (uint8 *)"+";
      fs.len = 1;
      runtime_printstring(fs);
      runtime_printhex(size);
      ft.str = (uint8 *)"\n";
      ft.len = 1;
      runtime_printstring(ft);
      runtime_printunlock();
      fu.str = (uint8 *)"missing stackmap";
      fu.len = 16;
      runtime_throw(fu);
      BUG();
    }
    s_4a = v36;
    if ( pcdata < 0 || pcdata >= v36->n )
    {
      tableb = runtime_funcname((runtime_funcInfo_0)__PAIR64__((unsigned int)v_4, (unsigned int)f__func));
      va = s_4a->n;
      runtime_printlock();
      fk.str = (uint8 *)"runtime: pcdata is ";
      fk.len = 19;
      runtime_printstring(fk);
      runtime_printint(pcdata);
      fl.str = (uint8 *)" and ";
      fl.len = 5;
      runtime_printstring(fl);
      runtime_printint(va);
      fm.str = (uint8 *)" locals stack map entries for ";
      fm.len = 30;
      runtime_printstring(fm);
      runtime_printstring(tableb);
      fn.str = (uint8 *)" (targetpc=";
      fn.len = 11;
      runtime_printstring(fn);
      runtime_printint(targetpc);
      fo.str = (uint8 *)")\n";
      fo.len = 2;
      runtime_printstring(fo);
      runtime_printunlock();
      fp.str = (uint8 *)"bad symbol table";
      fp.len = 16;
      runtime_throw(fp);
      BUG();
    }
    bv = runtime_stackmapdata(v36, pcdata);
    runtime_adjustpointers(
      (void *)(frame->varp - 4 * bv.n),
      &bv,
      (runtime_adjustinfo *)arg,
      (runtime_funcInfo_0)__PAIR64__((unsigned int)v_4, (unsigned int)f__func));
    v5 = frame;
  }
  if ( v5->arglen )
  {
    bv_0.n = 0;
    bv_0.bytedata = 0;
    p_n = &v5->argmap->n;
    if ( p_n )
    {
      v8 = (uint8 *)p_n[1];
      bv_0.n = *p_n;
      bv_0.bytedata = v8;
    }
    else
    {
      v35 = (runtime_stackmap *)runtime_funcdata(
                                  (runtime_funcInfo_0)__PAIR64__((unsigned int)v_4, (unsigned int)f__func),
                                  0);
      if ( !v35 || v35->n <= 0 )
      {
        tablea = runtime_funcname((runtime_funcInfo_0)__PAIR64__((unsigned int)v_4, (unsigned int)f__func));
        argp = frame->argp;
        arglen = frame->arglen;
        runtime_printlock();
        ff.str = (uint8 *)"runtime: frame ";
        ff.len = 15;
        runtime_printstring(ff);
        runtime_printstring(tablea);
        fg.str = (uint8 *)" untyped args ";
        fg.len = 14;
        runtime_printstring(fg);
        runtime_printint(argp);
        fh.str = (uint8 *)"+";
        fh.len = 1;
        runtime_printstring(fh);
        runtime_printint(arglen);
        fi.str = (uint8 *)"\n";
        fi.len = 1;
        runtime_printstring(fi);
        runtime_printunlock();
        fj.str = (uint8 *)"missing stackmap";
        fj.len = 16;
        runtime_throw(fj);
        BUG();
      }
      s_4 = v35;
      if ( pcdata < 0 || pcdata >= v35->n )
      {
        table = runtime_funcname((runtime_funcInfo_0)__PAIR64__((unsigned int)v_4, (unsigned int)f__func));
        v = s_4->n;
        runtime_printlock();
        f.str = (uint8 *)"runtime: pcdata is ";
        f.len = 19;
        runtime_printstring(f);
        runtime_printint(pcdata);
        fa.str = (uint8 *)" and ";
        fa.len = 5;
        runtime_printstring(fa);
        runtime_printint(v);
        fb.str = (uint8 *)" args stack map entries for ";
        fb.len = 28;
        runtime_printstring(fb);
        runtime_printstring(table);
        fc.str = (uint8 *)" (targetpc=";
        fc.len = 11;
        runtime_printstring(fc);
        runtime_printint(targetpc);
        fd.str = (uint8 *)")\n";
        fd.len = 2;
        runtime_printstring(fd);
        runtime_printunlock();
        fe.str = (uint8 *)"bad symbol table";
        fe.len = 16;
        runtime_throw(fe);
        BUG();
      }
      bv_0 = runtime_stackmapdata(v35, pcdata);
      v5 = frame;
    }
    runtime_adjustpointers((void *)v5->argp, &bv_0, (runtime_adjustinfo *)arg, 0LL);
  }
  return 1;
}
// 80E0D88: using guessed type char asc_80E0D88;

//----- (0807ED40) --------------------------------------------------------
void __golang runtime_adjustctxt(runtime_g *gp, runtime_adjustinfo *adjinfo)
{
  char *ctxt; // ecx
  uintptr bp; // ecx

  ctxt = (char *)gp->sched.ctxt;
  if ( adjinfo->old.lo <= (unsigned int)ctxt && (unsigned int)ctxt < adjinfo->old.hi )
    gp->sched.ctxt = &ctxt[adjinfo->delta];
  if ( runtime_framepointer_enabled )
  {
    bp = gp->sched.bp;
    if ( adjinfo->old.lo <= bp && bp < adjinfo->old.hi )
      gp->sched.bp = adjinfo->delta + bp;
  }
}

//----- (0807EDB0) --------------------------------------------------------
void __golang runtime_adjustdefers(runtime_g *gp, runtime_adjustinfo *adjinfo)
{
  runtime__defer *i; // eax
  uintptr fn; // edx
  uintptr sp; // edx
  uintptr panic; // edx

  runtime_tracebackdefers(gp, callback, adjinfo);
  for ( i = gp->_defer; i; i = i->link )
  {
    fn = (uintptr)i->fn;
    if ( adjinfo->old.lo <= fn && fn < adjinfo->old.hi )
      i->fn = (runtime_funcval *)(adjinfo->delta + fn);
    sp = i->sp;
    if ( adjinfo->old.lo <= sp && sp < adjinfo->old.hi )
      i->sp = adjinfo->delta + sp;
    panic = (uintptr)i->_panic;
    if ( adjinfo->old.lo <= panic && panic < adjinfo->old.hi )
      i->_panic = (runtime__panic *)(adjinfo->delta + panic);
  }
}

//----- (0807EE70) --------------------------------------------------------
void __golang runtime_adjustsudogs(runtime_g *gp, runtime_adjustinfo *adjinfo)
{
  runtime_sudog *i; // eax
  uintptr elem; // edx
  uintptr selectdone; // edx

  for ( i = gp->waiting; i; i = i->waitlink )
  {
    elem = (uintptr)i->elem;
    if ( adjinfo->old.lo <= elem && elem < adjinfo->old.hi )
      i->elem = (void *)(adjinfo->delta + elem);
    selectdone = (uintptr)i->selectdone;
    if ( adjinfo->old.lo <= selectdone && selectdone < adjinfo->old.hi )
      i->selectdone = (uint32 *)(adjinfo->delta + selectdone);
  }
}

//----- (0807EEE0) --------------------------------------------------------
uintptr __golang runtime_findsghi(runtime_g *gp, runtime_stack_0 stk)
{
  runtime_sudog *waiting; // eax
  unsigned int v3; // ebx
  unsigned int v4; // ebp

  waiting = gp->waiting;
  v3 = 0;
  while ( waiting )
  {
    v4 = (unsigned int)waiting->elem + waiting->c->elemsize;
    if ( stk.lo > v4 || v4 >= stk.hi || v4 <= v3 )
      v4 = v3;
    v3 = (unsigned int)(waiting->selectdone + 1);
    if ( stk.lo > v3 || v3 >= stk.hi || v3 <= v4 )
      v3 = v4;
    waiting = waiting->waitlink;
  }
  return v3;
}

//----- (0807EF50) --------------------------------------------------------
uintptr __golang runtime_syncadjustsudogs(runtime_g *gp, uintptr used, runtime_adjustinfo *adjinfo)
{
  runtime_g *v3; // eax
  runtime_sudog *waiting; // ecx
  runtime_mutex_0 *v5; // edx
  runtime_mutex_0 *c; // ebx
  uintptr sghi; // ecx
  uintptr v8; // eax
  runtime_sudog *v9; // ecx
  runtime_mutex_0 *v10; // edx
  runtime_mutex_0 *v11; // ebx
  uintptr sgsize; // [esp+Ch] [ebp-Ch]
  uintptr sgsizea; // [esp+Ch] [ebp-Ch]
  runtime_sudog *sg; // [esp+10h] [ebp-8h]
  runtime_sudog *sg_0; // [esp+14h] [ebp-4h]

  v3 = gp;
  waiting = gp->waiting;
  if ( !waiting )
    return 0;
  v5 = 0;
  while ( waiting )
  {
    c = (runtime_mutex_0 *)waiting->c;
    if ( v5 != c )
    {
      sg_0 = waiting;
      runtime_lock(c + 12);
      v3 = gp;
      waiting = sg_0;
    }
    v5 = (runtime_mutex_0 *)waiting->c;
    waiting = waiting->waitlink;
  }
  runtime_adjustsudogs(v3, adjinfo);
  sghi = adjinfo->sghi;
  if ( sghi )
  {
    sgsizea = sghi - (adjinfo->old.hi - used);
    runtime_memmove();
    v8 = sgsizea;
  }
  else
  {
    v8 = 0;
  }
  sgsize = v8;
  v9 = gp->waiting;
  v10 = 0;
  while ( v9 )
  {
    v11 = (runtime_mutex_0 *)v9->c;
    if ( v10 != v11 )
    {
      sg = v9;
      runtime_unlock(v11 + 12);
      v8 = sgsize;
      v9 = sg;
    }
    v10 = (runtime_mutex_0 *)v9->c;
    v9 = v9->waitlink;
  }
  return v8;
}

//----- (0807F060) --------------------------------------------------------
void __golang runtime_copystack(runtime_g *gp, uintptr newsize, bool sync)
{
  int v3; // edx
  runtime__panic *panic; // ecx
  string n; // [esp+0h] [ebp-114h]
  string na; // [esp+0h] [ebp-114h]
  runtime_stack old_lo; // [esp+2Ch] [ebp-E8h]
  runtime_stack new_lo; // [esp+34h] [ebp-E0h]
  uintptr ncopy; // [esp+3Ch] [ebp-D8h]
  uintptr sp; // [esp+40h] [ebp-D4h]
  runtime_adjustinfo_0 adjinfo; // [esp+44h] [ebp-D0h] BYREF

  while ( (unsigned int)&adjinfo.cache.entries[4] <= *(_DWORD *)(*(_DWORD *)(__readgsdword(0) - 4) + 8) )
    runtime_morestack_noctxt();
  if ( gp->syscallsp )
  {
    na.str = (uint8 *)"stack growth not allowed in system call";
    na.len = 39;
    runtime_throw(na);
    BUG();
  }
  if ( !gp->stack.lo )
  {
    n.str = (uint8 *)"nil stackbase";
    n.len = 13;
    runtime_throw(n);
    BUG();
  }
  old_lo = gp->stack;
  sp = gp->sched.sp;
  new_lo = runtime_stackalloc(newsize);
  ((void (*)(void))loc_808FD5C)();
  adjinfo.old = old_lo;
  adjinfo.delta = v3 - old_lo.hi;
  ncopy = old_lo.hi - sp;
  if ( sync )
  {
    runtime_adjustsudogs(gp, &adjinfo);
  }
  else
  {
    adjinfo.sghi = runtime_findsghi(gp, old_lo);
    runtime_syncadjustsudogs(gp, ncopy, &adjinfo);
  }
  runtime_memmove();
  runtime_adjustctxt(gp, &adjinfo);
  runtime_adjustdefers(gp, &adjinfo);
  panic = gp->_panic;
  if ( adjinfo.old.lo <= (unsigned int)panic && (unsigned int)panic < adjinfo.old.hi )
    gp->_panic = (runtime__panic *)((char *)panic + adjinfo.delta);
  if ( adjinfo.sghi )
    adjinfo.sghi += adjinfo.delta;
  gp->stack = new_lo;
  gp->stackguard0 = new_lo.lo + 880;
  gp->sched.sp = new_lo.hi - ncopy;
  gp->stktopsp += adjinfo.delta;
  runtime_gentraceback(0xFFFFFFFF, 0xFFFFFFFF, 0, gp, 0, 0, 0x7FFFFFFF, callback, &adjinfo, 0);
  runtime_stackfree(old_lo);
}
// 807F060: could not find valid save-restore pair for ebp
// 807F0EF: variable 'v3' is possibly undefined

//----- (0807F2E0) --------------------------------------------------------
int32 __golang runtime_round2(int32 x)
{
  unsigned int i; // ecx
  int v2; // ebx

  for ( i = 0; ; ++i )
  {
    v2 = -(i < 0x20);
    if ( (v2 & (1 << i)) >= x )
      break;
  }
  return v2 & (1 << i);
}

//----- (0807F320) --------------------------------------------------------
void __golang runtime_newstack(void *ctxt)
{
  int v1; // eax
  int v2; // ecx
  unsigned int *v3; // ebx
  unsigned int *v4; // ebp
  int v5; // eax
  _DWORD *v6; // edx
  runtime_g *v7; // eax
  unsigned int v8; // ebx
  runtime_g **v9; // ecx
  runtime_g *v10; // eax
  runtime_g *v11; // eax
  string s; // [esp+0h] [ebp-B4h]
  string sa; // [esp+0h] [ebp-B4h]
  string sb; // [esp+0h] [ebp-B4h]
  string sc; // [esp+0h] [ebp-B4h]
  string sd; // [esp+0h] [ebp-B4h]
  string se; // [esp+0h] [ebp-B4h]
  string sf; // [esp+0h] [ebp-B4h]
  string sg; // [esp+0h] [ebp-B4h]
  string sh; // [esp+0h] [ebp-B4h]
  string si; // [esp+0h] [ebp-B4h]
  string sj; // [esp+0h] [ebp-B4h]
  string sk; // [esp+0h] [ebp-B4h]
  string sl; // [esp+0h] [ebp-B4h]
  string sm; // [esp+0h] [ebp-B4h]
  string sn; // [esp+0h] [ebp-B4h]
  string so; // [esp+0h] [ebp-B4h]
  string sp; // [esp+0h] [ebp-B4h]
  string sq; // [esp+0h] [ebp-B4h]
  string sr; // [esp+0h] [ebp-B4h]
  string ss; // [esp+0h] [ebp-B4h]
  string st; // [esp+0h] [ebp-B4h]
  string su; // [esp+0h] [ebp-B4h]
  string sv; // [esp+0h] [ebp-B4h]
  string sw; // [esp+0h] [ebp-B4h]
  string sx; // [esp+0h] [ebp-B4h]
  string sy; // [esp+0h] [ebp-B4h]
  string sz; // [esp+0h] [ebp-B4h]
  string sba; // [esp+0h] [ebp-B4h]
  string sbb; // [esp+0h] [ebp-B4h]
  string sbc; // [esp+0h] [ebp-B4h]
  string sbd; // [esp+0h] [ebp-B4h]
  string sbe; // [esp+0h] [ebp-B4h]
  string sbf; // [esp+0h] [ebp-B4h]
  string sbg; // [esp+0h] [ebp-B4h]
  string sbh; // [esp+0h] [ebp-B4h]
  string sbi; // [esp+0h] [ebp-B4h]
  string sbj; // [esp+0h] [ebp-B4h]
  string sbk; // [esp+0h] [ebp-B4h]
  string sbl; // [esp+0h] [ebp-B4h]
  string sbm; // [esp+0h] [ebp-B4h]
  string sbn; // [esp+0h] [ebp-B4h]
  string sbo; // [esp+0h] [ebp-B4h]
  string sbp; // [esp+0h] [ebp-B4h]
  string sbq; // [esp+0h] [ebp-B4h]
  string sbr; // [esp+0h] [ebp-B4h]
  string sbs; // [esp+0h] [ebp-B4h]
  string sbt; // [esp+0h] [ebp-B4h]
  string sbu; // [esp+0h] [ebp-B4h]
  int s_4; // [esp+4h] [ebp-B0h]
  int newsize; // [esp+14h] [ebp-A0h]
  runtime_guintptr gp; // [esp+18h] [ebp-9Ch]
  uint32 v; // [esp+1Ch] [ebp-98h]
  unsigned int v_4; // [esp+20h] [ebp-94h]
  unsigned int v65; // [esp+24h] [ebp-90h]
  unsigned int v66; // [esp+24h] [ebp-90h]
  uintptr v67; // [esp+28h] [ebp-8Ch]
  unsigned int v68; // [esp+28h] [ebp-8Ch]
  uintptr v69; // [esp+2Ch] [ebp-88h]
  unsigned int v70; // [esp+2Ch] [ebp-88h]
  uintptr v71; // [esp+30h] [ebp-84h]
  uintptr lr; // [esp+30h] [ebp-84h]
  unsigned int v73; // [esp+34h] [ebp-80h]
  unsigned int v74; // [esp+38h] [ebp-7Ch]
  uintptr pc; // [esp+38h] [ebp-7Ch]
  unsigned int v76; // [esp+3Ch] [ebp-78h]
  unsigned int v77; // [esp+3Ch] [ebp-78h]
  int v78; // [esp+40h] [ebp-74h]
  unsigned int v79; // [esp+40h] [ebp-74h]
  unsigned int v80; // [esp+40h] [ebp-74h]
  int v81; // [esp+44h] [ebp-70h]
  runtime_gcWork_0 *gcw; // [esp+48h] [ebp-6Ch]
  void *v83; // [esp+4Ch] [ebp-68h]
  void *v84; // [esp+50h] [ebp-64h]
  void *v85; // [esp+54h] [ebp-60h]
  void *p; // [esp+58h] [ebp-5Ch]
  void *pa; // [esp+58h] [ebp-5Ch]
  uintptr morebuf; // [esp+60h] [ebp-54h]
  uintptr morebuf_4; // [esp+64h] [ebp-50h]
  runtime_g *morebuf_8; // [esp+68h] [ebp-4Ch]
  uintptr morebuf_20; // [esp+74h] [ebp-40h]
  runtime_gobuf_0 morebuf_0; // [esp+7Ch] [ebp-38h] BYREF
  runtime_gobuf_0 morebuf_1; // [esp+98h] [ebp-1Ch]

  while ( (unsigned int)&morebuf_0.pc <= *(_DWORD *)(*(_DWORD *)(__readgsdword(0) - 4) + 8) )
    runtime_morestack_noctxt();
  v1 = *(_DWORD *)(__readgsdword(0) - 4);
  v2 = *(_DWORD *)(v1 + 24);
  v3 = *(unsigned int **)(v2 + 12);
  if ( v3[2] == -1234 )
  {
    sbu.str = (uint8 *)"stack growth after fork";
    sbu.len = 23;
    runtime_throw(sbu);
    BUG();
  }
  v81 = v1;
  v4 = *(unsigned int **)(v2 + 84);
  if ( v3 != v4 )
  {
    v85 = *(void **)(v1 + 24);
    gp = *(_DWORD *)(v2 + 12);
    v84 = *(void **)v2;
    v83 = *(void **)(v2 + 44);
    runtime_printlock();
    sbn.str = (uint8 *)"runtime: newstack called from g=";
    sbn.len = 32;
    runtime_printstring(sbn);
    runtime_printhex(gp);
    sbo.str = (uint8 *)"\n\tm=";
    sbo.len = 4;
    runtime_printstring(sbo);
    runtime_printpointer(v85);
    sbp.str = (uint8 *)" m->curg=";
    sbp.len = 9;
    runtime_printstring(sbp);
    runtime_printpointer(v4);
    sbq.str = (uint8 *)" m->g0=";
    sbq.len = 7;
    runtime_printstring(sbq);
    runtime_printpointer(v84);
    sbr.str = (uint8 *)" m->gsignal=";
    sbr.len = 12;
    runtime_printstring(sbr);
    runtime_printpointer(v83);
    sbs.str = (uint8 *)"\n";
    sbs.len = 1;
    runtime_printstring(sbs);
    runtime_printunlock();
    ((void (*)(void))loc_809025A)();
    runtime_traceback(morebuf_4, morebuf, morebuf_20, morebuf_8);
    sbt.str = (uint8 *)"runtime: wrong goroutine in newstack";
    sbt.len = 36;
    runtime_throw(sbt);
    BUG();
  }
  if ( *(_DWORD *)&runtime_writeBarrier.enabled )
  {
    runtime_writebarrierptr(v4 + 10, (uintptr)ctxt);
    v1 = v81;
  }
  else
  {
    v4[10] = (unsigned int)ctxt;
  }
  if ( *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(v1 + 24) + 84) + 113) )
  {
    ((void (*)(void))loc_809025A)();
    v4[14] = morebuf_0.sp;
    v4[15] = morebuf_0.pc;
    v80 = *v4;
    v77 = v4[1];
    pc = morebuf_0.pc;
    lr = morebuf_0.lr;
    v70 = v4[8];
    v68 = v4[7];
    v66 = v4[12];
    pa = (void *)v4[10];
    runtime_printlock();
    sz.str = (uint8 *)"runtime: newstack sp=";
    sz.len = 21;
    runtime_printstring(sz);
    runtime_printhex(v68);
    sba.str = (uint8 *)" stack=[";
    sba.len = 8;
    runtime_printstring(sba);
    runtime_printhex(v80);
    sbb.str = (uint8 *)", ";
    sbb.len = 2;
    runtime_printstring(sbb);
    runtime_printhex(v77);
    sbc.str = (uint8 *)"]\n";
    sbc.len = 2;
    runtime_printstring(sbc);
    sbd.str = (uint8 *)"\tmorebuf={pc:";
    sbd.len = 13;
    runtime_printstring(sbd);
    runtime_printhex(pc);
    sbe.str = (uint8 *)" sp:";
    sbe.len = 4;
    runtime_printstring(sbe);
    runtime_printhex(morebuf_0.sp);
    sbf.str = (uint8 *)" lr:";
    sbf.len = 4;
    runtime_printstring(sbf);
    runtime_printhex(lr);
    sbg.str = (uint8 *)"}\n";
    sbg.len = 2;
    runtime_printstring(sbg);
    sbh.str = (uint8 *)"\tsched={pc:";
    sbh.len = 11;
    runtime_printstring(sbh);
    runtime_printhex(v70);
    sbi.str = (uint8 *)" sp:";
    sbi.len = 4;
    runtime_printstring(sbi);
    runtime_printhex(v68);
    sbj.str = (uint8 *)" lr:";
    sbj.len = 4;
    runtime_printstring(sbj);
    runtime_printhex(v66);
    sbk.str = (uint8 *)" ctxt:";
    sbk.len = 6;
    runtime_printstring(sbk);
    runtime_printpointer(pa);
    sbl.str = (uint8 *)"}\n";
    sbl.len = 2;
    runtime_printstring(sbl);
    runtime_printunlock();
    runtime_traceback(morebuf_0.pc, morebuf_0.sp, morebuf_0.lr, (runtime_g *)v4);
    sbm.str = (uint8 *)"runtime: stack split at bad time";
    sbm.len = 32;
    runtime_throw(sbm);
    BUG();
  }
  v5 = ((int (*)(void))loc_809025A)();
  *(_DWORD *)(*(_DWORD *)(v5 + 24) + 8) = 0;
  *(_DWORD *)(*(_DWORD *)(v5 + 24) + 24) = 0;
  *(_DWORD *)(*(_DWORD *)(v5 + 24) + 4) = 0;
  *(_DWORD *)(*(_DWORD *)(v5 + 24) + 12) = 0;
  runtime_internal_atomic_Loaduintptr();
  v78 = s_4;
  if ( s_4 == -1314 )
  {
    v6 = *(_DWORD **)(v81 + 24);
    if ( v6[30] || v6[26] || v6[29] || *(_DWORD *)(v6[23] + 8) != 1 )
    {
      v4[2] = *v4 + 880;
      runtime_gogo();
    }
  }
  v7 = (runtime_g *)v4;
  if ( !*v4 )
  {
    sy.str = (uint8 *)"missing stack in newstack";
    sy.len = 25;
    runtime_throw(sy);
    BUG();
  }
  v8 = v4[7] - 4;
  if ( v8 < *v4 )
  {
    v76 = v4[7];
    v74 = *v4;
    v73 = v4[1];
    v71 = morebuf_1.pc;
    v69 = morebuf_1.sp;
    v67 = morebuf_1.lr;
    v65 = v4[8];
    v_4 = v4[12];
    p = (void *)v4[10];
    runtime_printlock();
    s.str = (uint8 *)"runtime: newstack sp=";
    s.len = 21;
    runtime_printstring(s);
    runtime_printhex(v8);
    sa.str = (uint8 *)" stack=[";
    sa.len = 8;
    runtime_printstring(sa);
    runtime_printhex(v74);
    sb.str = (uint8 *)", ";
    sb.len = 2;
    runtime_printstring(sb);
    runtime_printhex(v73);
    sc.str = (uint8 *)"]\n";
    sc.len = 2;
    runtime_printstring(sc);
    sd.str = (uint8 *)"\tmorebuf={pc:";
    sd.len = 13;
    runtime_printstring(sd);
    runtime_printhex(v71);
    se.str = (uint8 *)" sp:";
    se.len = 4;
    runtime_printstring(se);
    runtime_printhex(v69);
    sf.str = (uint8 *)" lr:";
    sf.len = 4;
    runtime_printstring(sf);
    runtime_printhex(v67);
    sg.str = (uint8 *)"}\n";
    sg.len = 2;
    runtime_printstring(sg);
    sh.str = (uint8 *)"\tsched={pc:";
    sh.len = 11;
    runtime_printstring(sh);
    runtime_printhex(v65);
    si.str = (uint8 *)" sp:";
    si.len = 4;
    runtime_printstring(si);
    runtime_printhex(v76);
    sj.str = (uint8 *)" lr:";
    sj.len = 4;
    runtime_printstring(sj);
    runtime_printhex(v_4);
    sk.str = (uint8 *)" ctxt:";
    sk.len = 6;
    runtime_printstring(sk);
    runtime_printpointer(p);
    sl.str = (uint8 *)"}\n";
    sl.len = 2;
    runtime_printstring(sl);
    runtime_printunlock();
    v7 = (runtime_g *)v4;
  }
  if ( v8 < v7->stack.lo )
  {
    v = runtime_readgstatus(v7);
    runtime_printlock();
    sr.str = (uint8 *)"runtime: gp=";
    sr.len = 12;
    runtime_printstring(sr);
    runtime_printpointer(v4);
    ss.str = (uint8 *)", gp->status=";
    ss.len = 13;
    runtime_printstring(ss);
    runtime_printhex(v);
    st.str = (uint8 *)"\n ";
    st.len = 2;
    runtime_printstring(st);
    runtime_printunlock();
    v79 = *v4;
    runtime_printlock();
    su.str = (uint8 *)"runtime: split stack overflow: ";
    su.len = 31;
    runtime_printstring(su);
    runtime_printhex(v8);
    sv.str = (uint8 *)" < ";
    sv.len = 3;
    runtime_printstring(sv);
    runtime_printhex(v79);
    sw.str = (uint8 *)"\n";
    sw.len = 1;
    runtime_printstring(sw);
    runtime_printunlock();
    sx.str = (uint8 *)"runtime: split stack overflow";
    sx.len = 29;
    runtime_throw(sx);
    BUG();
  }
  if ( v78 == -1314 )
  {
    v9 = *(runtime_g ***)(v81 + 24);
    if ( v7 == *v9 )
    {
      sq.str = (uint8 *)"runtime: preempt g0";
      sq.len = 19;
      runtime_throw(sq);
      BUG();
    }
    if ( !v9[23] && !v9[30] )
    {
      sp.str = (uint8 *)"runtime: g is running but p is not";
      sp.len = 34;
      runtime_throw(sp);
      BUG();
    }
    runtime_casgstatus(v7, 2u, 4u);
    v10 = (runtime_g *)v4;
    if ( *((_BYTE *)v4 + 110) )
    {
      while ( !runtime_castogscanstatus(v10, 4u, 0x1004u) )
        v10 = (runtime_g *)v4;
      v11 = (runtime_g *)v4;
      if ( !*((_BYTE *)v4 + 111) )
      {
        gcw = (runtime_gcWork_0 *)(*(_DWORD *)(v4[6] + 92) + 2384);
        runtime_scanstack((runtime_g *)v4, gcw);
        if ( runtime_gcBlackenPromptly )
          runtime___ptr_gcWork__dispose(gcw);
        v11 = (runtime_g *)v4;
        *((_BYTE *)v4 + 111) = 1;
      }
      v11->preemptscan = 0;
      v11->preempt = 0;
      runtime_casfrom_Gscanstatus(v11, 0x1004u, 4u);
      runtime_casgstatus((runtime_g *)v4, 4u, 2u);
      v4[2] = *v4 + 880;
      runtime_gogo();
    }
    runtime_casgstatus((runtime_g *)v4, 4u, 2u);
    runtime_gopreempt_m((runtime_g *)v4);
  }
  if ( 2 * (v4[1] - *v4) > runtime_maxstacksize )
  {
    runtime_printlock();
    sm.str = (uint8 *)"runtime: goroutine stack exceeds ";
    sm.len = 33;
    runtime_printstring(sm);
    runtime_printint(runtime_maxstacksize);
    sn.str = (uint8 *)"-byte limit\n";
    sn.len = 12;
    runtime_printstring(sn);
    runtime_printunlock();
    so.str = (uint8 *)"stack overflow";
    so.len = 14;
    runtime_throw(so);
    BUG();
  }
  newsize = 2 * (v4[1] - *v4);
  runtime_casgstatus((runtime_g *)v4, 2u, 8u);
  runtime_copystack((runtime_g *)v4, newsize, 1);
  runtime_casgstatus((runtime_g *)v4, 8u, 2u);
  runtime_gogo();
}
// 807F3EF: variable 's_4' is possibly undefined
// 807FE15: variable 'morebuf_4' is possibly undefined
// 807FE15: variable 'morebuf' is possibly undefined
// 807FE15: variable 'morebuf_20' is possibly undefined
// 807FE15: variable 'morebuf_8' is possibly undefined

//----- (0807FE60) --------------------------------------------------------
void __golang runtime_shrinkstack(runtime_g *gp)
{
  uintptr hi; // ebx
  uintptr v2; // edx
  string stk; // [esp+0h] [ebp-Ch]
  string stka; // [esp+0h] [ebp-Ch]
  uint32 stk_4; // [esp+4h] [ebp-8h]

  stk_4 = runtime_readgstatus(gp);
  if ( (stk_4 & 0xFFFFEFFF) == 6 )
  {
    if ( gp->stack.lo )
    {
      runtime_stackfree(gp->stack);
      gp->stack.lo = 0;
      gp->stack.hi = 0;
    }
  }
  else
  {
    if ( !gp->stack.lo )
    {
      stka.str = (uint8 *)"missing stack in shrinkstack";
      stka.len = 28;
      runtime_throw(stka);
      BUG();
    }
    if ( (stk_4 & 0x1000) == 0 )
    {
      stk.str = (uint8 *)"bad status in shrinkstack";
      stk.len = 25;
      runtime_throw(stk);
      BUG();
    }
    if ( runtime_debug.gcshrinkstackoff <= 0 && gp->startpc != runtime_gcBgMarkWorkerPC )
    {
      hi = gp->stack.hi;
      v2 = hi - gp->stack.lo;
      if ( v2 >> 1 >= 0x800 && hi - gp->sched.sp + 752 < v2 >> 2 && !gp->syscallsp )
        runtime_copystack(gp, v2 >> 1, 0);
    }
  }
}

//----- (0807FF90) --------------------------------------------------------
void __golang runtime_freeStackSpans()
{
  int j; // eax
  runtime_mspan *span; // ebx
  runtime_mspan *next; // ebp
  runtime_mSpanList_0 *v3; // edx
  int k; // eax
  runtime_mSpanList_0 *v5; // ecx
  runtime_mspan *m; // edx
  __int32 order; // [esp+Ch] [ebp-20h]
  __int32 i; // [esp+10h] [ebp-1Ch]
  runtime_mspan *s_0; // [esp+18h] [ebp-14h]
  runtime_mspan *next_0; // [esp+20h] [ebp-Ch]
  runtime_mSpanList_0 *list; // [esp+24h] [ebp-8h]
  runtime_mSpanList_0 *v12; // [esp+28h] [ebp-4h]

  runtime_lock(&runtime_stackpoolmu);
  for ( j = 0; j < 4; ++j )
  {
    if ( (unsigned int)j >= 4 )
      runtime_panicindex();
    order = j;
    v3 = &runtime_stackpool[j];
    list = v3;
    for ( span = v3->first; span; span = next )
    {
      next = span->next;
      if ( !span->allocCount )
      {
        runtime___ptr_mSpanList__remove(v3, span);
        span->manualFreeList = 0;
        runtime___ptr_mheap__freeManual(&runtime_mheap_, span, &runtime_memstats.stacks_inuse);
        j = order;
        v3 = list;
      }
    }
  }
  runtime_unlock(&runtime_stackpoolmu);
  runtime_lock(&runtime_stackLarge.lock);
  for ( k = 0; k < 19; ++k )
  {
    if ( (unsigned int)k >= 0x13 )
      runtime_panicindex();
    i = k;
    v5 = &runtime_stackLarge.free[k];
    v12 = v5;
    for ( m = v5->first; m; m = next_0 )
    {
      s_0 = m;
      next_0 = m->next;
      runtime___ptr_mSpanList__remove(v5, m);
      runtime___ptr_mheap__freeManual(&runtime_mheap_, s_0, &runtime_memstats.stacks_inuse);
      k = i;
      v5 = v12;
    }
  }
  runtime_unlock(&runtime_stackLarge.lock);
}

//----- (080800F0) --------------------------------------------------------
void __golang runtime_morestackc()
{
  runtime_systemstack();
}

//----- (08080110) --------------------------------------------------------
string __golang runtime_concatstrings(uint8 (*buf)[32], __string a)
{
  string *array; // eax
  string *v3; // edx
  __int32 v4; // ebx
  int v5; // ebp
  unsigned __int32 v6; // esi
  __int32 v7; // edi
  __int32 len; // edx
  __int32 v9; // edx
  uint8 (*v10)[32]; // eax
  _DWORD *v11; // ebp
  unsigned __int32 v13; // eax
  uint8 *v14; // ecx
  __int32 v15; // edx
  uint8 *v16; // ebx
  __int32 v17; // ebp
  __int32 v18; // esi
  string *v19; // edi
  string v20; // [esp+0h] [ebp-44h]
  string v21; // [esp+8h] [ebp-3Ch]
  uint8 *v22; // [esp+8h] [ebp-3Ch]
  __int32 v23; // [esp+Ch] [ebp-38h]
  __uint8 v24; // [esp+10h] [ebp-34h]
  uint8 *v25; // [esp+10h] [ebp-34h]
  unsigned __int32 v26; // [esp+14h] [ebp-30h]
  __int32 v27; // [esp+18h] [ebp-2Ch]
  unsigned __int32 x_len; // [esp+1Ch] [ebp-28h]
  unsigned __int32 b_len; // [esp+24h] [ebp-20h]
  __int32 b_cap; // [esp+28h] [ebp-1Ch]
  uint8 *b_ptr; // [esp+34h] [ebp-10h]
  uint8 *s; // [esp+3Ch] [ebp-8h]
  string _r2; // [esp+58h] [ebp+14h]

  array = a.array;
  v3 = a.array;
  v4 = 0;
  v5 = 0;
  v6 = 0;
  v7 = 0;
  while ( v4 < a.len )
  {
    len = array->len;
    if ( len )
    {
      v9 = v7 + len;
      if ( v9 < v7 )
      {
        v20.str = (uint8 *)"string concatenation too long";
        v20.len = 29;
        runtime_throw(v20);
        BUG();
      }
      ++v5;
      v6 = v4;
      v7 = v9;
    }
    ++array;
    ++v4;
    v3 = a.array;
  }
  if ( !v5 )
  {
    _r2.str = 0;
    _r2.len = 0;
    return _r2;
  }
  if ( v5 != 1 )
  {
    v10 = buf;
LABEL_14:
    runtime_rawstringtmp(v10, v7, v21, v24);
    v13 = v26;
    v14 = v25;
    v15 = v23;
    v16 = v22;
    v17 = v27;
    v18 = 0;
    v19 = a.array;
    while ( 1 )
    {
      b_cap = v17;
      if ( v18 >= a.len )
        break;
      b_len = v13;
      x_len = v19->len;
      b_ptr = v14;
      runtime_memmove();
      if ( x_len > b_len )
        runtime_panicslice();
      ++v19;
      ++v18;
      v16 = v22;
      v17 -= x_len;
      v14 = &b_ptr[((int)(x_len - b_cap) >> 31) & x_len];
      v13 = b_len - x_len;
      v15 = v23;
    }
    _r2.str = v16;
    _r2.len = v15;
    return _r2;
  }
  v10 = buf;
  if ( !buf )
  {
    if ( v6 >= a.len )
      runtime_panicindex();
    s = v3[v6].str;
    v11 = *(_DWORD **)(__readgsdword(0) - 4);
    if ( *v11 <= (unsigned int)s && (unsigned int)s < v11[1] )
      goto LABEL_14;
  }
  if ( v6 >= a.len )
    runtime_panicindex();
  return a.array[v6];
}
// 80801D3: variable 'v21' is possibly undefined
// 80801D3: variable 'v24' is possibly undefined
// 80801D8: variable 'v26' is possibly undefined
// 80801DC: variable 'v25' is possibly undefined
// 80801E0: variable 'v23' is possibly undefined
// 80801E8: variable 'v22' is possibly undefined
// 80801F0: variable 'v27' is possibly undefined

//----- (08080310) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
string __golang runtime_concatstring2(uint8 (*buf)[32], string a[2])
{
  __string v2; // [esp+4h] [ebp-14h]

  v2.array = a;
  *(_QWORD *)&v2.len = 0x200000002LL;
  return runtime_concatstrings(buf, v2);
}
// 8080310: array has been used for an input argument

//----- (08080370) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
string __golang runtime_concatstring3(uint8 (*buf)[32], string a[3])
{
  __string v2; // [esp+4h] [ebp-14h]

  v2.array = a;
  *(_QWORD *)&v2.len = 0x300000003LL;
  return runtime_concatstrings(buf, v2);
}
// 8080370: array has been used for an input argument

//----- (080803D0) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
string __golang runtime_concatstring4(uint8 (*buf)[32], string a[4])
{
  __string v2; // [esp+4h] [ebp-14h]

  v2.array = a;
  *(_QWORD *)&v2.len = 0x400000004LL;
  return runtime_concatstrings(buf, v2);
}
// 80803D0: array has been used for an input argument

//----- (08080430) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
string __golang runtime_concatstring5(uint8 (*buf)[32], string a[5])
{
  __string v2; // [esp+4h] [ebp-14h]

  v2.array = a;
  *(_QWORD *)&v2.len = 0x500000005LL;
  return runtime_concatstrings(buf, v2);
}
// 8080430: array has been used for an input argument

//----- (08080490) --------------------------------------------------------
void __golang runtime_slicebytetostring(uint8 (*buf)[32], __uint8 b, string str)
{
  if ( b.len )
  {
    if ( !buf || b.len > 32 )
      runtime_mallocgc(b.len, 0, 0);
    runtime_memmove();
  }
}

//----- (08080530) --------------------------------------------------------
void __golang runtime_rawstringtmp(uint8 (*buf)[32], __int32 l, string s, __uint8 b)
{
  __int32 size; // ecx
  string v5; // [esp+4h] [ebp-14h]
  __uint8 v6; // [esp+Ch] [ebp-Ch]

  if ( !buf )
  {
    size = l;
    goto LABEL_5;
  }
  size = l;
  if ( l > 32 )
  {
LABEL_5:
    runtime_rawstring(size, v5, v6);
    return;
  }
  if ( (unsigned int)l > 0x20 )
    runtime_panicslice();
}
// 808057C: variable 'v5' is possibly undefined
// 808057C: variable 'v6' is possibly undefined

//----- (080805B0) --------------------------------------------------------
__uint8 __golang runtime_stringtoslicebyte(uint8 (*buf)[32], string s)
{
  __int32 size; // ecx
  int v3; // eax
  __int32 len; // ecx
  uint8 (*v5)[32]; // edx
  __uint8 v6; // [esp+4h] [ebp-18h]
  uint8 (*v7)[32]; // [esp+4h] [ebp-18h]
  __int32 v8; // [esp+8h] [ebp-14h]
  int v9; // [esp+Ch] [ebp-10h]
  __int32 b_len; // [esp+10h] [ebp-Ch]
  __int32 b_cap; // [esp+14h] [ebp-8h]
  uint8 *b_ptr; // [esp+18h] [ebp-4h]
  __uint8 _r2; // [esp+2Ch] [ebp+10h]

  if ( !buf )
  {
    size = s.len;
    goto LABEL_5;
  }
  size = s.len;
  if ( s.len > 32 )
  {
LABEL_5:
    runtime_rawbyteslice(size, v6);
    len = v8;
    v5 = v7;
    v3 = v9;
    goto LABEL_4;
  }
  ((void (*)(void))loc_808FD88)();
  v3 = 32;
  len = s.len;
  v5 = buf;
LABEL_4:
  b_cap = v3;
  b_len = len;
  b_ptr = (uint8 *)v5;
  runtime_memmove();
  _r2.array = b_ptr;
  _r2.len = b_len;
  _r2.cap = b_cap;
  return _r2;
}
// 8080639: variable 'v6' is possibly undefined
// 808063E: variable 'v8' is possibly undefined
// 8080642: variable 'v7' is possibly undefined
// 8080646: variable 'v9' is possibly undefined

//----- (08080660) --------------------------------------------------------
__int32 __golang runtime_stringtoslicerune(int32 (*buf)[32], string s)
{
  __int32 k; // eax
  __int32 i; // ecx
  __int32 v4; // ebp
  __int32 v5; // edx
  char v6; // cf
  char v7; // zf
  unsigned __int32 len; // eax
  __int32 cap; // ecx
  int32 (*array)[32]; // ebx
  __int32 v11; // ebp
  unsigned __int32 v12; // esi
  unsigned int v13; // ecx
  __int32 v14; // [esp+4h] [ebp-20h]
  __int32 v15; // [esp+10h] [ebp-14h]
  __int32 a_len; // [esp+18h] [ebp-Ch]
  __int32 a_lena; // [esp+18h] [ebp-Ch]
  __int32 a_cap; // [esp+1Ch] [ebp-8h]
  int32 (*v19)[32]; // [esp+20h] [ebp-4h]
  __int32 _r2; // [esp+34h] [ebp+10h]

  k = 0;
  for ( i = 0; ; ++i )
  {
    a_len = i;
    if ( k >= s.len )
      break;
    if ( s.str[k] >= 0x80u )
    {
      runtime_decoderune(s, k, v14.cap, v15);
      v4 = v15;
      i = a_len;
    }
    else
    {
      v4 = k + 1;
    }
    k = v4;
  }
  if ( buf && i <= 32 )
  {
    ((void (*)(void))loc_808FD70)();
    if ( !(v6 | v7) )
      runtime_panicslice();
    len = a_len;
    cap = 32;
    array = buf;
  }
  else
  {
    runtime_rawruneslice(i, v14);
    cap = v14.cap;
    len = v14.len;
    array = (int32 (*)[32])v14.array;
    v5 = s.len;
  }
  a_lena = len;
  a_cap = cap;
  v19 = array;
  v11 = 0;
  v12 = 0;
  while ( v11 < v5 )
  {
    v13 = s.str[v11];
    if ( v13 >= 0x80 )
    {
      runtime_decoderune((string)__PAIR64__(v5, (unsigned int)s.str), v11, v14.cap, v15);
      v13 = v14.cap;
      v11 = v15;
      len = a_lena;
      v5 = s.len;
      array = v19;
    }
    else
    {
      ++v11;
    }
    if ( v12 >= len )
      runtime_panicindex();
    (*array)[v12++] = v13;
    cap = a_cap;
  }
  _r2.array = (int32 *)array;
  _r2.len = len;
  _r2.cap = cap;
  return _r2;
}
// 80806AE: variable 'v14' is possibly undefined
// 80806AE: variable 'v15' is possibly undefined
// 80806E4: variable 'v6' is possibly undefined
// 80806E4: variable 'v7' is possibly undefined
// 8080713: variable 'v5' is possibly undefined

//----- (080807B0) --------------------------------------------------------
string __golang runtime_slicerunetostring(uint8 (*buf)[32], __int32 a)
{
  __int32 v2; // eax
  int32 *array; // ecx
  uint8 *i; // edx
  __int32 v5; // eax
  unsigned __int32 v6; // ecx
  uint8 *v7; // edx
  unsigned __int32 v8; // ebp
  __int32 v9; // esi
  int32 *v10; // edi
  unsigned __int32 v11; // esi
  __uint8 p; // [esp+0h] [ebp-44h]
  __uint8 pa; // [esp+0h] [ebp-44h]
  string p_8; // [esp+8h] [ebp-3Ch]
  uint8 *p_8a; // [esp+8h] [ebp-3Ch]
  int32 r; // [esp+Ch] [ebp-38h]
  __uint8 v17; // [esp+10h] [ebp-34h]
  uint8 *v18; // [esp+10h] [ebp-34h]
  __int32 v19; // [esp+10h] [ebp-34h]
  __int32 v20; // [esp+14h] [ebp-30h]
  __int32 v21; // [esp+18h] [ebp-2Ch]
  __int32 size2; // [esp+1Ch] [ebp-28h]
  __int32 size1; // [esp+20h] [ebp-24h]
  __int32 s_len; // [esp+24h] [ebp-20h]
  uint8 dum[4]; // [esp+28h] [ebp-1Ch] BYREF
  __int32 b_len; // [esp+2Ch] [ebp-18h]
  __int32 b_cap; // [esp+30h] [ebp-14h]
  int v28; // [esp+34h] [ebp-10h]
  uint8 *s_ptr; // [esp+38h] [ebp-Ch]
  uint8 *b_ptr; // [esp+3Ch] [ebp-8h]
  int32 *v31; // [esp+40h] [ebp-4h]
  string _r2; // [esp+58h] [ebp+14h]

  *(_DWORD *)dum = 0;
  v2 = 0;
  array = a.array;
  for ( i = 0; ; i = &v17.array[size1] )
  {
    size1 = (__int32)i;
    if ( v2 >= a.len )
      break;
    v28 = v2;
    v31 = array;
    p.array = dum;
    *(_QWORD *)&p.len = 0x400000004LL;
    v17.array = (uint8 *)runtime_encoderune(p, *array);
    array = v31 + 1;
    v2 = v28 + 1;
  }
  runtime_rawstringtmp(buf, (__int32)(i + 3), p_8, v17);
  v5 = v21;
  b_cap = v21;
  v6 = v20;
  b_len = v20;
  v7 = v18;
  b_ptr = v18;
  s_ptr = p_8a;
  v8 = r;
  s_len = r;
  v9 = 0;
  size2 = 0;
  v10 = a.array;
  while ( v9 < a.len )
  {
    v28 = v9;
    v31 = v10;
    v11 = size2;
    if ( size2 >= size1 )
      goto LABEL_10;
    if ( size2 > v6 )
      runtime_panicslice();
    pa.array = &v7[size2 & ((size2 - v5) >> 31)];
    pa.len = v6 - size2;
    pa.cap = v5 - size2;
    v19 = runtime_encoderune(pa, *v10);
    v10 = v31 + 1;
    v9 = v28 + 1;
    v6 = b_len;
    v7 = b_ptr;
    v8 = s_len;
    size2 += v19;
    v5 = b_cap;
  }
  v11 = size2;
LABEL_10:
  if ( v11 > v8 )
    runtime_panicslice();
  _r2.str = s_ptr;
  _r2.len = v11;
  return _r2;
}
// 80807B0: could not find valid save-restore pair for ebp
// 80807B0: could not find valid save-restore pair for esi
// 8080835: variable 'p_8' is possibly undefined
// 8080835: variable 'v17' is possibly undefined
// 808083A: variable 'v21' is possibly undefined
// 8080842: variable 'v20' is possibly undefined
// 808084A: variable 'v18' is possibly undefined
// 8080856: variable 'p_8a' is possibly undefined
// 808085A: variable 'r' is possibly undefined

//----- (08080920) --------------------------------------------------------
string __golang runtime_intstring(uint8 (*buf)[4], int64 v)
{
  uint8 (*v2)[4]; // eax
  int v3; // ecx
  int v4; // edx
  unsigned int v5; // ebx
  uint8 (*v6)[4]; // ebp
  int32 v7; // ebp
  __uint8 p; // [esp+0h] [ebp-20h]
  string p_4; // [esp+4h] [ebp-1Ch]
  uint8 (*p_4a)[4]; // [esp+4h] [ebp-1Ch]
  unsigned int p_8; // [esp+8h] [ebp-18h]
  __uint8 r; // [esp+Ch] [ebp-14h]
  int32 ra; // [esp+Ch] [ebp-14h]
  unsigned __int32 v14; // [esp+10h] [ebp-10h]
  int v15; // [esp+10h] [ebp-10h]
  int v16; // [esp+14h] [ebp-Ch]
  uint8 *s_ptr; // [esp+1Ch] [ebp-4h]
  string _r2; // [esp+30h] [ebp+10h]

  v2 = buf;
  if ( buf )
  {
    v3 = 4;
    v4 = 4;
    v5 = 4;
    v6 = buf;
  }
  else
  {
    runtime_rawstring(4, p_4, r);
    v6 = p_4a;
    v5 = p_8;
    v2 = (uint8 (*)[4])ra;
    v3 = v15;
    v4 = v16;
  }
  s_ptr = (uint8 *)v6;
  if ( (int)v >> 31 == HIDWORD(v) )
    v7 = v;
  else
    v7 = 65533;
  p.array = (uint8 *)v2;
  *(_QWORD *)&p.len = __PAIR64__(v4, v3);
  v14 = runtime_encoderune(p, v7);
  if ( v14 > v5 )
    runtime_panicslice();
  _r2.str = s_ptr;
  _r2.len = v14;
  return _r2;
}
// 80809AB: variable 'p_4' is possibly undefined
// 80809AB: variable 'r' is possibly undefined
// 80809B0: variable 'p_4a' is possibly undefined
// 80809B4: variable 'p_8' is possibly undefined
// 80809B8: variable 'ra' is possibly undefined
// 80809BC: variable 'v15' is possibly undefined
// 80809C0: variable 'v16' is possibly undefined

//----- (080809E0) --------------------------------------------------------
void __golang runtime_rawstring(__int32 size, string s, __uint8 b)
{
  runtime_mallocgc(size, 0, 0);
}

//----- (08080A60) --------------------------------------------------------
void __golang runtime_rawbyteslice(__int32 size, __uint8 b)
{
  unsigned int v2; // ecx
  unsigned int v3; // ecx
  uintptr v4; // ecx
  unsigned int v5; // ecx
  unsigned int v6; // ecx
  uintptr cap; // [esp+10h] [ebp-8h]

  if ( (unsigned int)size >= 0x8000 )
  {
    if ( size + 0x2000 >= (unsigned int)size )
      v4 = (size + 0x1FFF) & 0xFFFFE000;
    else
      v4 = size;
  }
  else if ( (unsigned int)size > 0x3F8 )
  {
    v5 = (unsigned int)(size - 897) >> 7;
    if ( v5 >= 0xF9 || (v6 = runtime_size_to_class128[v5], v6 >= 0x43) )
      runtime_panicindex();
    v4 = runtime_class_to_size[v6];
  }
  else
  {
    v2 = (unsigned int)(size + 7) >> 3;
    if ( v2 >= 0x81 || (v3 = runtime_size_to_class8[v2], v3 >= 0x43) )
      runtime_panicindex();
    v4 = runtime_class_to_size[v3];
  }
  cap = v4;
  runtime_mallocgc(v4, 0, 0);
  if ( cap != size )
    runtime_memclrNoHeapPointers();
}

//----- (08080BA0) --------------------------------------------------------
void __golang runtime_rawruneslice(__int32 size, __int32 b)
{
  unsigned __int32 v2; // eax
  unsigned int v3; // edx
  unsigned int v4; // edx
  unsigned int v5; // edx
  unsigned int v6; // edx
  unsigned int v7; // edx
  string v8; // [esp+0h] [ebp-1Ch]
  uintptr mem; // [esp+14h] [ebp-8h]

  if ( (unsigned int)size > 0x3FFFFFFF )
  {
    v8.str = (uint8 *)"out of memory";
    v8.len = 13;
    runtime_throw(v8);
    BUG();
  }
  v2 = 4 * size;
  if ( (unsigned int)(4 * size) >= 0x8000 )
  {
    if ( v2 + 0x2000 >= v2 )
      v5 = (v2 + 0x1FFF) & 0xFFFFE000;
    else
      v5 = 4 * size;
  }
  else if ( v2 > 0x3F8 )
  {
    v6 = (v2 - 897) >> 7;
    if ( v6 >= 0xF9 || (v7 = runtime_size_to_class128[v6], v7 >= 0x43) )
      runtime_panicindex();
    v5 = runtime_class_to_size[v7];
  }
  else
  {
    v3 = (v2 + 7) >> 3;
    if ( v3 >= 0x81 || (v4 = runtime_size_to_class8[v3], v4 >= 0x43) )
      runtime_panicindex();
    v5 = runtime_class_to_size[v4];
  }
  mem = v5;
  runtime_mallocgc(v5, 0, 0);
  if ( mem != 4 * size )
    runtime_memclrNoHeapPointers();
}

//----- (08080D20) --------------------------------------------------------
string __golang runtime_gostring(uint8 *p)
{
  string size; // [esp+4h] [ebp-20h]
  string sizea; // [esp+4h] [ebp-20h]
  __uint8 v3; // [esp+Ch] [ebp-18h]
  int v4; // [esp+10h] [ebp-14h]
  string _r1; // [esp+2Ch] [ebp+8h]

  size.str = (uint8 *)runtime_findnull(p);
  if ( size.str )
  {
    runtime_rawstring((__int32)size.str, size, v3);
    if ( !v4 )
      runtime_panicindex();
    runtime_memmove();
    return sizea;
  }
  else
  {
    _r1.str = 0;
    _r1.len = 0;
  }
  return _r1;
}
// 8080D54: variable 'size' is possibly undefined
// 8080D54: variable 'v3' is possibly undefined
// 8080D6B: variable 'v4' is possibly undefined
// 8080D91: variable 'sizea' is possibly undefined

//----- (08080DD0) --------------------------------------------------------
__int32 __golang runtime_index(string s, string t)
{
  __int32 len; // eax
  __int32 j; // ecx
  char v4; // dl
  char v5; // [esp+10h] [ebp-8h]
  __int32 i; // [esp+14h] [ebp-4h]

  len = t.len;
  if ( !t.len )
    return 0;
  for ( j = 0; j < s.len; ++j )
  {
    if ( (unsigned int)j >= s.len )
      runtime_panicindex();
    if ( s.str[j] == *t.str )
    {
      if ( s.len - j >= len )
      {
        i = j;
        runtime_eqstring();
        v4 = v5;
        len = t.len;
        j = i;
      }
      else
      {
        v4 = 0;
      }
      if ( v4 )
        return j;
    }
  }
  return -1;
}
// 8080E5A: variable 'v5' is possibly undefined

//----- (08080EB0) --------------------------------------------------------
bool __golang runtime_contains(string s, string t)
{
  return runtime_index(s, t) >= 0;
}

//----- (08080F10) --------------------------------------------------------
retval_8080F10 __golang runtime_atoi(string s)
{
  __int32 len; // edx
  uint8 *str; // eax
  char v3; // cl
  __int32 v4; // ebx
  unsigned __int32 v5; // ebp
  uint8 v6; // si
  unsigned int v7; // ebp
  unsigned int v8; // esi
  bool v9; // zf
  retval_8080F10 _r1; // [esp+Ch] [ebp+Ch]

  if ( s.len )
  {
    if ( *s.str == 45 )
    {
      len = s.len - 1;
      str = &s.str[((1 - s.len) >> 31) & 1];
      v3 = 1;
    }
    else
    {
      str = s.str;
      len = s.len;
      v3 = 0;
    }
    v4 = 0;
    v5 = 0;
    while ( v4 < len )
    {
      if ( v4 >= (unsigned int)len )
        runtime_panicindex();
      v6 = str[v4];
      if ( (unsigned __int8)(v6 - 48) > 9u )
      {
        _r1._r1 = 0;
        _r1._r2 = 0;
        return _r1;
      }
      if ( v5 > 0x19999999 )
      {
        _r1._r1 = 0;
        _r1._r2 = 0;
        return _r1;
      }
      v7 = 10 * v5;
      v8 = v6 + v7 - 48;
      if ( v8 < v7 )
      {
        _r1._r1 = 0;
        _r1._r2 = 0;
        return _r1;
      }
      ++v4;
      v5 = v8;
    }
    v9 = v3 == 0;
    if ( !v3 )
    {
      if ( v5 > 0x7FFFFFFF )
      {
        _r1._r1 = 0;
        _r1._r2 = 0;
        return _r1;
      }
      v9 = 1;
    }
    if ( v9 )
    {
LABEL_19:
      _r1._r1 = v5;
      _r1._r2 = 1;
      return _r1;
    }
    if ( v5 <= 0x80000000 )
    {
      if ( v3 )
        v5 = -v5;
      goto LABEL_19;
    }
    _r1._r1 = 0;
    _r1._r2 = 0;
  }
  else
  {
    _r1._r1 = 0;
    _r1._r2 = 0;
  }
  return _r1;
}

//----- (08081040) --------------------------------------------------------
retval_8081040 __golang runtime_atoi32(string s)
{
  return (retval_8081040)runtime_atoi(s);
}

//----- (08081090) --------------------------------------------------------
__int32 __golang runtime_findnull(uint8 *s)
{
  unsigned __int32 i; // ecx

  if ( !s )
    return 0;
  for ( i = 0; ; ++i )
  {
    if ( i >= 0x7FFFFFFE )
      runtime_panicindex();
    if ( !s[i] )
      break;
  }
  return i;
}

//----- (080810D0) --------------------------------------------------------
string __golang runtime_gostringnocopy(uint8 *str)
{
  string _r1; // [esp+18h] [ebp+8h]

  _r1.str = str;
  _r1.len = runtime_findnull(str);
  return _r1;
}

//----- (08081100) --------------------------------------------------------
void __golang __noreturn runtime_badsystemstack()
{
  string s; // [esp+0h] [ebp-8h]

  s.str = (uint8 *)"systemstack called from unexpected goroutine";
  s.len = 44;
  runtime_throw(s);
  BUG();
}

//----- (08081140) --------------------------------------------------------
void __golang reflect_memclrNoHeapPointers(void *ptr, uintptr n)
{
  runtime_memclrNoHeapPointers();
}

//----- (08081180) --------------------------------------------------------
runtime_Frames *__golang runtime_CallersFrames(__uintptr callers)
{
  runtime_Frames *v1; // eax
  __int32 len; // ecx
  uintptr *array; // edx
  __int32 cap; // ebp
  uintptr v5; // ebx
  uintptr *src; // [esp+4h] [ebp-8h]
  runtime_Frames *ci; // [esp+8h] [ebp-4h]

  src = (uintptr *)runtime_newobject((runtime__type_0 *)&stru_80D36E0);
  v1 = (runtime_Frames *)src;
  len = callers.len;
  if ( callers.len < 1 )
  {
    array = callers.array;
  }
  else
  {
    array = callers.array;
    if ( *callers.array - runtime_skipPC < 0x100 )
    {
      cap = callers.cap - 1;
      array = (uintptr *)((char *)callers.array + (((1 - callers.cap) >> 31) & 4));
      len = callers.len - 1;
      goto LABEL_4;
    }
  }
  if ( callers.len >= 2 )
  {
    v5 = array[1] - runtime_skipPC;
    if ( v5 - 1 < 0xFF )
      src[16] = v5;
  }
  cap = callers.cap;
LABEL_4:
  src[1] = len;
  src[2] = cap;
  if ( *(_DWORD *)&runtime_writeBarrier.enabled )
  {
    ci = (runtime_Frames *)src;
    runtime_writebarrierptr(src, (uintptr)array);
    return ci;
  }
  else
  {
    *src = (uintptr)array;
  }
  return v1;
}

//----- (08081240) --------------------------------------------------------
void __golang runtime___ptr_Frames__Next(runtime_Frames *ci, runtime_Frame_0 frame, bool more)
{
  __int32 v3; // edx
  __uintptr v4; // [esp+10h] [ebp-58h]
  uintptr *v5; // [esp+10h] [ebp-58h]
  __int32 v6; // [esp+18h] [ebp-50h]
  runtime_Frame_0 v7; // [esp+1Ch] [ebp-4Ch]
  bool v8; // [esp+3Ch] [ebp-2Ch]

  ((void (*)(void))loc_808FD88)();
  ((void (*)(void))loc_808FD88)();
  runtime___ptr_stackExpander__next(&ci->stackExpander, ci->callers, v4, v7, v8);
  ((void (*)(void))loc_8090250)();
  ci->callers.len = v3;
  ci->callers.cap = v6;
  if ( *(_DWORD *)&runtime_writeBarrier.enabled )
    runtime_writebarrierptr((uintptr *)ci, (uintptr)v5);
  else
    ci->callers.array = v5;
  ((void (*)(void))loc_8090250)();
}
// 8081240: could not find valid save-restore pair for ebx
// 808128B: variable 'v4' is possibly undefined
// 808128B: variable 'v7' is possibly undefined
// 808128B: variable 'v8' is possibly undefined
// 80812BA: variable 'v3' is possibly undefined
// 80812BD: variable 'v6' is possibly undefined
// 80812CE: variable 'v5' is possibly undefined

//----- (08081310) --------------------------------------------------------
void __golang runtime___ptr_stackExpander__next(
        runtime_stackExpander_0 *se,
        __uintptr callers,
        __uintptr ncallers,
        runtime_Frame_0 frame,
        bool more)
{
  runtime_stackExpander_0 *ex; // ebx
  runtime__func *func; // ebp
  bool v7; // al
  __int32 v8; // ebp

  ((void (*)(void))loc_808FD88)();
  if ( se->pcExpander.more )
  {
    ex = se;
LABEL_11:
    runtime___ptr_pcExpander__next(&ex->pcExpander);
    ((void (*)(void))loc_8090250)();
    return;
  }
  if ( callers.len )
  {
    runtime___ptr_pcExpander__init(&se->pcExpander, *callers.array, se->wasPanic);
    ex = se;
    func = se->pcExpander.funcInfo._func;
    if ( func )
      v7 = func->entry == runtime_sigpanicPC;
    else
      v7 = 0;
    se->wasPanic = v7;
    v8 = callers.len - 1;
    if ( se->skip > 0 )
    {
      while ( ex->skip > 0 )
      {
        runtime___ptr_pcExpander__next(&ex->pcExpander);
        ex = se;
        --se->skip;
        v8 = callers.len - 1;
      }
      ex->skip = 0;
      if ( !v8 )
        runtime_panicslice();
    }
    if ( ex->pcExpander.more )
      goto LABEL_11;
    ((void (*)(void))loc_8090250)();
  }
  else
  {
    se->wasPanic = 0;
    ((void (*)(void))loc_8090250)();
  }
}

//----- (08081510) --------------------------------------------------------
void __golang runtime___ptr_pcExpander__init(runtime_pcExpander_0 *ex, uintptr pc, bool panicCall)
{
  runtime_pcExpander_0 *v3; // ecx
  uintptr entry; // eax
  int32 v5; // edx
  runtime_pcExpander_0 *v6; // ebx
  runtime_pcExpander_0 *v7; // edx
  runtime_pcExpander_0 *v8; // ecx
  runtime_pcExpander_0 *v9; // ebx
  runtime_funcInfo_0 src; // [esp+4h] [ebp-24h]
  __runtime_Frame srca; // [esp+4h] [ebp-24h]
  runtime_inlinedCall (*strict)[1048576]; // [esp+Ch] [ebp-1Ch]
  string cache; // [esp+10h] [ebp-18h]
  uint8 *cachea; // [esp+10h] [ebp-18h]
  __int32 v15; // [esp+14h] [ebp-14h]
  int32 v16; // [esp+18h] [ebp-10h]
  int32 v17; // [esp+18h] [ebp-10h]

  ex->more = 0;
  src = runtime_findfunc(pc);
  v3 = ex;
  if ( *(_DWORD *)&runtime_writeBarrier.enabled )
  {
    runtime_writebarrierptr((uintptr *)&ex->funcInfo, (uintptr)src._func);
    runtime_writebarrierptr((uintptr *)&ex->funcInfo.datap, (uintptr)src.datap);
    v3 = ex;
  }
  else
  {
    ex->funcInfo = src;
  }
  if ( v3->funcInfo._func )
  {
    v3->more = 1;
    entry = v3->funcInfo._func->entry;
    v3->pc = pc;
    if ( pc > entry && !panicCall )
      v3->pc = pc - 1;
    runtime_funcline1(v3->funcInfo, v3->pc, 0, cache, v16);
    v5 = v17;
    v6 = ex;
    ex->file.len = v15;
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
    {
      runtime_writebarrierptr((uintptr *)&ex->file, (uintptr)cachea);
      v5 = v17;
      v6 = ex;
    }
    else
    {
      ex->file.str = cachea;
    }
    v6->line = v5;
    strict = (runtime_inlinedCall (*)[1048576])runtime_funcdata(v6->funcInfo, 2);
    if ( strict )
    {
      v7 = ex;
      if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      {
        runtime_writebarrierptr((uintptr *)&ex->inlTree, (uintptr)strict);
        v7 = ex;
      }
      else
      {
        ex->inlTree = strict;
      }
      ex->inlIndex = runtime_pcdatavalue(v7->funcInfo, 1, v7->pc, 0);
    }
    else
    {
      v8 = ex;
      if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      {
        runtime_writebarrierptr((uintptr *)&ex->inlTree, 0);
        v8 = ex;
      }
      else
      {
        ex->inlTree = 0;
      }
      v8->inlIndex = -1;
    }
  }
  else if ( runtime_cgoSymbolizer )
  {
    srca = runtime_expandCgoFrames(pc);
    v9 = ex;
    ex->frames.len = srca.len;
    ex->frames.cap = srca.cap;
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
    {
      runtime_writebarrierptr((uintptr *)&ex->frames, (uintptr)srca.array);
      v9 = ex;
    }
    else
    {
      ex->frames.array = srca.array;
    }
    v9->more = v9->frames.len > 0;
  }
}
// 8081510: could not find valid save-restore pair for esi
// 80815A6: variable 'cache' is possibly undefined
// 80815A6: variable 'v16' is possibly undefined
// 80815B3: variable 'v17' is possibly undefined
// 80815BB: variable 'v15' is possibly undefined
// 80815CF: variable 'cachea' is possibly undefined

//----- (08081750) --------------------------------------------------------
runtime_Frame_0 __golang runtime___ptr_pcExpander__next(runtime_pcExpander_0 *ex)
{
  uintptr *dst; // edx
  runtime_pcExpander_0 *v2; // eax
  __int32 cap; // ecx
  runtime_Frame_0 *array; // ebx
  __int32 len; // ebp
  __int32 v6; // ecx
  runtime_Frame_0 *src; // ecx
  int32 inlIndex; // eax
  runtime_inlinedCall (*inlTree)[1048576]; // edx
  int v10; // eax
  runtime_pcExpander_0 *v11; // edx
  string v12; // [esp+Ch] [ebp-7Ch]
  int32 call_parent; // [esp+14h] [ebp-74h]
  int32 call_line; // [esp+18h] [ebp-70h]
  int32 call_file; // [esp+1Ch] [ebp-6Ch]
  int v16[2]; // [esp+80h] [ebp-8h] BYREF
  runtime_Frame_0 _r0; // [esp+90h] [ebp+8h]

  while ( (unsigned int)v16 <= *(_DWORD *)(*(_DWORD *)(__readgsdword(0) - 4) + 8) )
    runtime_morestack_noctxt();
  ((void (*)(void))loc_808FD88)();
  if ( ex->more )
  {
    if ( ex->frames.len <= 0 )
    {
      inlIndex = ex->inlIndex;
      if ( inlIndex < 0 )
      {
        ex->more = 0;
        runtime_funcname(ex->funcInfo);
        ((void (*)(void))loc_8090250)();
        v16[0] = ex->line;
        v16[1] = ex->funcInfo._func->entry;
        ((void (*)(void))loc_8090250)();
      }
      else
      {
        inlTree = ex->inlTree;
        if ( (unsigned int)inlIndex >= 0x100000 )
          runtime_panicindex();
        v10 = inlIndex;
        call_file = (*inlTree)[v10].file;
        call_line = (*inlTree)[v10].line;
        call_parent = (*inlTree)[v10].parent;
        runtime_funcnameFromNameoff(ex->funcInfo, (*inlTree)[v10].func_);
        ((void (*)(void))loc_8090250)();
        v12 = runtime_funcfile(ex->funcInfo, call_file);
        v11 = ex;
        ex->file.len = v12.len;
        if ( *(_DWORD *)&runtime_writeBarrier.enabled )
        {
          runtime_writebarrierptr((uintptr *)&ex->file, (uintptr)v12.str);
          v11 = ex;
        }
        else
        {
          ex->file.str = v12.str;
        }
        v11->line = call_line;
        v11->inlIndex = call_parent;
        ((void (*)(void))loc_8090250)();
      }
    }
    else
    {
      ((void (*)(void))loc_8090250)();
      v2 = ex;
      cap = ex->frames.cap;
      array = ex->frames.array;
      len = ex->frames.len;
      if ( !len )
        runtime_panicslice();
      ex->frames.len = len - 1;
      v6 = cap - 1;
      ex->frames.cap = v6;
      src = (runtime_Frame_0 *)((char *)array + ((-v6 >> 31) & 0x20));
      if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      {
        runtime_writebarrierptr(dst, (uintptr)src);
        v2 = ex;
      }
      else
      {
        ex->frames.array = src;
      }
      v2->more = v2->frames.len > 0;
      ((void (*)(void))loc_8090250)();
    }
  }
  else
  {
    ((void (*)(void))loc_8090250)();
  }
  return _r0;
}
// 8081806: variable 'dst' is possibly undefined

//----- (08081A00) --------------------------------------------------------
__runtime_Frame __golang runtime_expandCgoFrames(uintptr pc)
{
  __int32 v1; // eax
  __int32 v2; // ecx
  runtime_Frame_0 *i; // edx
  string v4; // kr00_8
  int v5; // eax
  int v6; // eax
  __int32 v7; // edx
  __int32 cap; // ebx
  runtime_Frame_0 *array; // ebp
  string dst; // [esp+4h] [ebp-74h]
  runtime_slice_0 dsta; // [esp+4h] [ebp-74h]
  runtime_slice_0 v12; // [esp+14h] [ebp-64h]
  unsigned __int64 frames_len; // [esp+20h] [ebp-58h]
  __int32 frames_lena; // [esp+20h] [ebp-58h]
  runtime_slice_0 old; // [esp+38h] [ebp-40h] BYREF
  int v16; // [esp+44h] [ebp-34h]
  uint8 *v17; // [esp+48h] [ebp-30h]
  int v18; // [esp+4Ch] [ebp-2Ch]
  int v19; // [esp+50h] [ebp-28h]
  int src[2]; // [esp+58h] [ebp-20h] BYREF
  string v21; // [esp+60h] [ebp-18h]
  int v22; // [esp+68h] [ebp-10h]
  int len; // [esp+6Ch] [ebp-Ch]
  int v24; // [esp+70h] [ebp-8h]
  int v25; // [esp+74h] [ebp-4h]
  __runtime_Frame _r1; // [esp+80h] [ebp+8h]

  ((void (*)(void))loc_808FD89)();
  old.len = pc;
  runtime_callCgoSymbolizer((runtime_cgoSymbolizerArg_0 *)&old.len);
  if ( old.cap || v17 )
  {
    v1 = 0;
    v2 = 0;
    for ( i = 0; ; i = array )
    {
      frames_len = __PAIR64__(v1, v2);
      old.array = i;
      v4 = runtime_gostring(v17);
      dst = runtime_gostring((uint8 *)old.cap);
      v5 = ((int (*)(void))loc_8090250)();
      src[0] = pc;
      src[1] = 0;
      v21 = v4;
      v22 = v5;
      len = dst.len;
      v24 = v16;
      v25 = v18;
      v6 = frames_len;
      v7 = frames_len + 1;
      cap = HIDWORD(frames_len);
      if ( (int)frames_len + 1 > SHIDWORD(frames_len) )
      {
        dsta.array = old.array;
        *(_QWORD *)&dsta.len = frames_len;
        v12 = runtime_growslice((runtime__type_0 *)&stru_80D88A0, dsta, (int)frames_len + 1);
        array = (runtime_Frame_0 *)v12.array;
        cap = v12.cap;
        v7 = v12.len + 1;
        v6 = frames_len;
      }
      else
      {
        array = (runtime_Frame_0 *)old.array;
      }
      frames_lena = v7;
      if ( *(_DWORD *)&runtime_writeBarrier.enabled )
        runtime_typedmemmove((runtime__type_0 *)&stru_80D88A0, &array[v6], src);
      else
        ((void (*)(void))loc_8090250)();
      if ( !v19 )
        break;
      runtime_callCgoSymbolizer((runtime_cgoSymbolizerArg_0 *)&old.len);
      v1 = cap;
      v2 = frames_lena;
    }
    old.len = 0;
    runtime_callCgoSymbolizer((runtime_cgoSymbolizerArg_0 *)&old.len);
    _r1.array = array;
    _r1.len = frames_lena;
    _r1.cap = cap;
  }
  else
  {
    _r1.array = 0;
    _r1.len = 0;
    _r1.cap = 0;
  }
  return _r1;
}
// 8081A00: could not find valid save-restore pair for ebx
// 8081A00: could not find valid save-restore pair for ebp

//----- (08081C20) --------------------------------------------------------
runtime_funcInfo_0 __golang runtime___ptr_Func__funcInfo(runtime_Func *f)
{
  runtime_funcInfo_0 _r0; // [esp+10h] [ebp+8h]

  _r0._func = (runtime__func *)f;
  _r0.datap = runtime_findmoduledatap(*(_DWORD *)f->gap0);
  return _r0;
}

//----- (08081C60) --------------------------------------------------------
___runtime_moduledata __golang runtime_activeModules()
{
  ___runtime_moduledata *v0; // [esp+4h] [ebp-4h]
  ___runtime_moduledata _r0; // [esp+Ch] [ebp+4h]

  v0 = (___runtime_moduledata *)runtime_internal_atomic_Loadp(&runtime_modulesSlice);
  if ( v0 )
    return *v0;
  _r0.array = 0;
  _r0.len = 0;
  _r0.cap = 0;
  return _r0;
}

//----- (08081CB0) --------------------------------------------------------
void __golang runtime_modulesinit()
{
  uintptr *v0; // eax
  runtime_moduledata *i; // ecx
  __int32 v2; // edx
  __int32 v3; // ebx
  uintptr *v4; // ebp
  runtime_moduledata_0 *v5; // edx
  runtime_moduledata *v6; // edx
  uintptr *array; // eax
  __int32 len; // ecx
  uintptr *v9; // ebx
  signed __int32 v10; // ecx
  uintptr *v11; // ebx
  uintptr *v12; // ebp
  uintptr j; // esi
  uintptr v14; // edi
  uintptr v15; // edx
  runtime_slice_0 size; // [esp+4h] [ebp-3Ch]
  runtime_bitvector_0 v17; // [esp+8h] [ebp-38h]
  runtime_bitvector_0 v18; // [esp+8h] [ebp-38h]
  runtime_slice_0 v19; // [esp+14h] [ebp-2Ch]
  uintptr *modules; // [esp+28h] [ebp-18h]
  runtime_moduledata_0 *md; // [esp+2Ch] [ebp-14h]
  uintptr *dst; // [esp+34h] [ebp-Ch]

  v0 = (uintptr *)runtime_newobject((runtime__type_0 *)&stru_80C9200);
  modules = v0;
  for ( i = &runtime_firstmoduledata; i; i = i->next )
  {
    md = i;
    v2 = v0[1];
    v3 = v0[2];
    v4 = (uintptr *)*v0;
    if ( v2 + 1 > v3 )
    {
      size.array = (void *)*v0;
      *(_QWORD *)&size.len = __PAIR64__(v3, v2);
      v19 = runtime_growslice((runtime__type_0 *)&stru_80C7CC0, size, v2 + 1);
      array = (uintptr *)v19.array;
      len = v19.len;
      v9 = modules;
      modules[2] = v19.cap;
      if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      {
        runtime_writebarrierptr(modules, (uintptr)v19.array);
        array = (uintptr *)v19.array;
        len = v19.len;
        v9 = modules;
      }
      else
      {
        *modules = (uintptr)v19.array;
      }
      v2 = len;
      v4 = array;
      v0 = v9;
      i = md;
    }
    v0[1] = v2 + 1;
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
    {
      runtime_writebarrierptr(&v4[v2], (uintptr)i);
      v0 = modules;
      i = md;
    }
    else
    {
      v4[v2] = (uintptr)i;
    }
    if ( !i->gcdatamask.n && !i->gcdatamask.bytedata )
    {
      dst = (uintptr *)&i->gcdatamask.bytedata;
      v17 = runtime_progToPointerMask((uint8 *)i->gcdata, i->edata - i->data);
      v5 = md;
      md->gcdatamask.n = v17.n;
      if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      {
        runtime_writebarrierptr(dst, (uintptr)v17.bytedata);
        v5 = md;
      }
      else
      {
        md->gcdatamask.bytedata = v17.bytedata;
      }
      v18 = runtime_progToPointerMask((uint8 *)v5->gcbss, v5->ebss - v5->bss);
      v6 = md;
      md->gcbssmask.n = v18.n;
      if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      {
        runtime_writebarrierptr((uintptr *)&md->gcbssmask.bytedata, (uintptr)v18.bytedata);
        v6 = md;
      }
      else
      {
        md->gcbssmask.bytedata = v18.bytedata;
      }
      v0 = modules;
      i = v6;
    }
  }
  v10 = v0[1];
  v11 = (uintptr *)*v0;
  v12 = (uintptr *)*v0;
  for ( j = 0; (int)j < v10; ++j )
  {
    v14 = *v11;
    if ( *(_DWORD *)(*v11 + 48) <= (unsigned int)main_main && (unsigned int)main_main <= *(_DWORD *)(v14 + 52) )
    {
      if ( !v10 )
        runtime_panicindex();
      if ( *(_DWORD *)&runtime_writeBarrier.enabled )
        runtime_writebarrierptr(v12, v14);
      else
        *v12 = v14;
      v0 = modules;
      v15 = *modules;
      if ( j >= modules[1] )
        runtime_panicindex();
      if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      {
        runtime_writebarrierptr((uintptr *)(v15 + 4 * j), (uintptr)&runtime_firstmoduledata);
        v0 = modules;
      }
      else
      {
        *(_DWORD *)(v15 + 4 * j) = &runtime_firstmoduledata;
      }
      break;
    }
    ++v11;
    v0 = modules;
  }
  runtime_atomicstorep(&runtime_modulesSlice, v0);
}

//----- (08081F50) --------------------------------------------------------
void __golang runtime_moduledataverify()
{
  runtime_moduledata_0 *i; // eax
  runtime_moduledata_0 *datap; // [esp+4h] [ebp-4h]

  for ( i = &runtime_firstmoduledata; i; i = datap->next )
  {
    datap = i;
    runtime_moduledataverify1(i);
  }
}

//----- (08081FA0) --------------------------------------------------------
void __golang runtime_moduledataverify1(runtime_moduledata_0 *datap)
{
  uint8 *array; // ebx
  __int32 v2; // edx
  unsigned __int32 v3; // ecx
  __int32 k; // eax
  unsigned __int32 v5; // ebp
  __int32 v6; // esi
  runtime_functab_0 *v7; // edx
  runtime_moduledata_0 *v8; // edi
  __int32 v9; // ecx
  int v10; // edx
  __int32 v11; // ebp
  uint8 *v12; // eax
  unsigned __int32 v13; // ebx
  unsigned __int32 v14; // esi
  uintptr v15; // edi
  unsigned __int32 v16; // edx
  unsigned int v17; // edx
  unsigned __int32 v18; // ebx
  uint8 *v19; // ebp
  unsigned __int32 v20; // esi
  runtime__func *func; // esi
  unsigned __int32 v22; // edx
  uint8 *v23; // edx
  int v24; // edx
  uint8 *str; // ebx
  runtime_functab_0 *v26; // ecx
  unsigned __int32 v27; // edx
  __int32 m; // eax
  unsigned __int32 funcoff; // esi
  runtime_functab_0 *v30; // ecx
  string v31; // kr00_8
  unsigned __int32 v32; // ebp
  __int32 v33; // ecx
  __int32 v34; // ebx
  __int32 v35; // edx
  runtime_moduledata_0 *v36; // esi
  __int32 v37; // edi
  __int32 v38; // ebx
  uint8 *v39; // ecx
  string f; // [esp+0h] [ebp-158h]
  string fa; // [esp+0h] [ebp-158h]
  string fb; // [esp+0h] [ebp-158h]
  string fc; // [esp+0h] [ebp-158h]
  string fd; // [esp+0h] [ebp-158h]
  string fe; // [esp+0h] [ebp-158h]
  runtime_funcInfo_0 ff; // [esp+0h] [ebp-158h]
  string fg; // [esp+0h] [ebp-158h]
  string fh; // [esp+0h] [ebp-158h]
  string fi; // [esp+0h] [ebp-158h]
  string fj; // [esp+0h] [ebp-158h]
  string fk; // [esp+0h] [ebp-158h]
  string fl; // [esp+0h] [ebp-158h]
  string fm; // [esp+0h] [ebp-158h]
  int32 off; // [esp+8h] [ebp-150h]
  string offa; // [esp+8h] [ebp-150h]
  string offb; // [esp+8h] [ebp-150h]
  uintptr targetpc; // [esp+Ch] [ebp-14Ch]
  char cache; // [esp+10h] [ebp-148h]
  __int32 nftab; // [esp+1Ch] [ebp-13Ch]
  unsigned __int32 j; // [esp+20h] [ebp-138h]
  __int32 i; // [esp+24h] [ebp-134h]
  __int32 f2name_len; // [esp+28h] [ebp-130h]
  unsigned int v; // [esp+30h] [ebp-128h]
  unsigned int v_4; // [esp+34h] [ebp-124h]
  unsigned int v65; // [esp+38h] [ebp-120h]
  unsigned int v66; // [esp+3Ch] [ebp-11Ch]
  uintptr v67; // [esp+40h] [ebp-118h]
  uintptr entry; // [esp+44h] [ebp-114h]
  uintptr v69; // [esp+44h] [ebp-114h]
  unsigned __int32 v70; // [esp+48h] [ebp-110h]
  __int32 v71; // [esp+48h] [ebp-110h]
  __int32 len; // [esp+4Ch] [ebp-10Ch]
  __int32 v73; // [esp+4Ch] [ebp-10Ch]
  __int32 v74; // [esp+4Ch] [ebp-10Ch]
  _DWORD v75[49]; // [esp+50h] [ebp-108h] BYREF
  uint8 *f2name_ptr; // [esp+114h] [ebp-44h]
  string v77; // [esp+118h] [ebp-40h]
  string s; // [esp+120h] [ebp-38h]
  runtime_funcInfo_0 v79; // [esp+128h] [ebp-30h]
  runtime_modulehash_0 modulehash; // [esp+130h] [ebp-28h]

  while ( (unsigned int)&v75[12] <= *(_DWORD *)(*(_DWORD *)(__readgsdword(0) - 4) + 8) )
    runtime_morestack_noctxt();
  array = datap->pclntable.array;
  v75[0] = *(_DWORD *)datap->pclntable.array;
  if ( v75[0] != -5 || array[4] || array[5] || array[6] != 1 || array[7] != 4 )
  {
    v66 = array[4];
    v65 = array[5];
    v_4 = array[6];
    v = array[7];
    runtime_printlock();
    fl.str = (uint8 *)"runtime: function symbol table header:";
    fl.len = 38;
    runtime_printstring(fl);
    runtime_printsp();
    runtime_printhex(v75[0]);
    runtime_printsp();
    runtime_printhex(v66);
    runtime_printsp();
    runtime_printhex(v65);
    runtime_printsp();
    runtime_printhex(v_4);
    runtime_printsp();
    runtime_printhex(v);
    runtime_printnl();
    runtime_printunlock();
    fm.str = (uint8 *)"invalid function symbol table\n";
    fm.len = 30;
    runtime_throw(fm);
    BUG();
  }
  len = datap->ftab.len;
  ((void (*)(void))loc_808FD60)();
  v3 = v2 - 1;
  nftab = v2 - 1;
  for ( k = 0; k < (int)v3; k = v70 )
  {
    v5 = datap->ftab.len;
    v6 = v2;
    v7 = datap->ftab.array;
    if ( k >= v5 || (v8 = datap, v79.datap = (runtime_moduledata_0 *)&v7[k], v9 = k + 1, k + 1 >= v5) )
      runtime_panicindex();
    v70 = k + 1;
    v10 = (int)&v7[k + 1];
    if ( v79.datap->pclntable.array > (uint8 *)*(_DWORD *)v10 )
    {
      v18 = datap->pclntable.len;
      v19 = datap->pclntable.array;
      v20 = v79.datap->pclntable.len;
      if ( v20 < v18 )
      {
        func = (runtime__func *)&v19[v20];
        v22 = *(_DWORD *)(v10 + 4);
        if ( v22 < v18 )
        {
          i = k;
          v23 = &v19[v22];
          if ( v9 < nftab )
          {
            v79._func = func;
            v31 = runtime_funcname((runtime_funcInfo_0)__PAIR64__((unsigned int)datap, (unsigned int)v23));
            v24 = v31.len;
            str = v31.str;
            func = v79._func;
            v8 = datap;
          }
          else
          {
            v24 = 3;
            str = (uint8 *)"end";
          }
          f2name_len = v24;
          f2name_ptr = str;
          offa = runtime_funcname((runtime_funcInfo_0)__PAIR64__((unsigned int)v8, (unsigned int)func));
          v26 = datap->ftab.array;
          v27 = datap->ftab.len;
          if ( i < v27 && v70 < v27 )
          {
            entry = v26[i].entry;
            s.str = offa.str;
            v67 = v26[i + 1].entry;
            runtime_printlock();
            fa.str = (uint8 *)"function symbol table not sorted by program counter:";
            fa.len = 52;
            runtime_printstring(fa);
            runtime_printsp();
            runtime_printhex(entry);
            runtime_printsp();
            runtime_printstring((string)__PAIR64__(offa.len, (unsigned int)s.str));
            runtime_printsp();
            fb.str = (uint8 *)">";
            fb.len = 1;
            runtime_printstring(fb);
            runtime_printsp();
            runtime_printhex(v67);
            runtime_printsp();
            runtime_printstring((string)__PAIR64__(f2name_len, (unsigned int)f2name_ptr));
            runtime_printnl();
            runtime_printunlock();
            for ( m = 0; m <= i; m = j + 1 )
            {
              if ( (unsigned int)m >= datap->ftab.len
                || (funcoff = datap->ftab.array[m].funcoff, funcoff >= datap->pclntable.len)
                || (j = m,
                    ff._func = (runtime__func *)&datap->pclntable.array[funcoff],
                    ff.datap = datap,
                    offb = runtime_funcname(ff),
                    v30 = datap->ftab.array,
                    j >= datap->ftab.len) )
              {
                runtime_panicindex();
              }
              s.str = offb.str;
              v69 = v30[j].entry;
              runtime_printlock();
              fc.str = (uint8 *)"\t";
              fc.len = 1;
              runtime_printstring(fc);
              runtime_printhex(v69);
              fd.str = (uint8 *)" ";
              fd.len = 1;
              runtime_printstring(fd);
              runtime_printstring((string)__PAIR64__(offb.len, (unsigned int)s.str));
              fe.str = (uint8 *)"\n";
              fe.len = 1;
              runtime_printstring(fe);
              runtime_printunlock();
            }
            fk.str = (uint8 *)"invalid runtime symbol table";
            fk.len = 28;
            runtime_throw(fk);
            BUG();
          }
          runtime_panicindex();
        }
        runtime_panicindex();
      }
      runtime_panicindex();
    }
    v11 = nftab;
    if ( nftab - k < 5 )
    {
      v12 = datap->pclntable.array;
      v13 = datap->pclntable.len;
      v14 = v79.datap->pclntable.len;
      if ( v14 >= v13 )
        runtime_panicindex();
      v79._func = (runtime__func *)&v12[v14];
      v15 = *(_DWORD *)&v12[v14];
      if ( v9 < nftab )
      {
        v16 = *(_DWORD *)(v10 + 4);
        if ( v16 >= v13 )
          runtime_panicindex();
        if ( *(_DWORD *)&v12[v16 + 24] )
        {
          v17 = *(_DWORD *)&v12[v16] - 16;
          if ( v17 >= v15 )
            v15 = v17;
        }
      }
      s.len = (__int32)v12;
      runtime_pcvalue(
        (runtime_funcInfo_0)__PAIR64__((unsigned int)datap, (unsigned int)v79._func),
        *(_DWORD *)&v12[v14 + 20],
        v15,
        (runtime_pcvalueCache *)&v75[1],
        1);
      runtime_pcvalue(
        (runtime_funcInfo_0)__PAIR64__((unsigned int)datap, (unsigned int)v79._func),
        *(_DWORD *)(s.len + v14 + 24),
        v15,
        (runtime_pcvalueCache *)&v75[1],
        1);
      runtime_pcvalue(
        (runtime_funcInfo_0)__PAIR64__((unsigned int)datap, (unsigned int)v79._func),
        *(_DWORD *)(s.len + v14 + 16),
        v15,
        (runtime_pcvalueCache *)&v75[1],
        1);
      v11 = nftab;
      v6 = len;
    }
    v3 = v11;
    v2 = v6;
  }
  v32 = datap->ftab.len;
  if ( !v32 )
    runtime_panicindex();
  if ( datap->ftab.array->entry != datap->minpc )
    goto LABEL_49;
  if ( v3 >= v32 )
    runtime_panicindex();
  if ( datap->maxpc != datap->ftab.array[v2 - 1].entry )
  {
LABEL_49:
    fj.str = (uint8 *)"minpc or maxpc invalid";
    fj.len = 22;
    runtime_throw(fj);
    BUG();
  }
  v33 = datap->modulehashes.len;
  v73 = v33;
  v34 = 0;
  while ( v34 < v33 )
  {
    cache = ((int (__golang *)(uint8 *, __int32, int32, uintptr))loc_809026E)(f.str, f.len, off, targetpc);
    v36 = (runtime_moduledata_0 *)((int (*)(void))loc_809026E)();
    v37 = v34;
    v38 = modulehash.runtimehash->len;
    v39 = modulehash.runtimehash->str;
    if ( modulehash.linktimehash.len != v38 )
      goto LABEL_46;
    v77.len = v35;
    f = modulehash.linktimehash;
    off = (int32)v39;
    targetpc = v38;
    runtime_eqstring();
    if ( !cache )
    {
      v36 = datap;
LABEL_46:
      v74 = v36->modulename.len;
      s.str = v36->modulename.str;
      v71 = modulehash.modulename.len;
      v77.str = modulehash.modulename.str;
      runtime_printlock();
      fg.str = (uint8 *)"abi mismatch detected between";
      fg.len = 29;
      runtime_printstring(fg);
      runtime_printsp();
      runtime_printstring((string)__PAIR64__(v74, (unsigned int)s.str));
      runtime_printsp();
      fh.str = (uint8 *)"and";
      fh.len = 3;
      runtime_printstring(fh);
      runtime_printsp();
      runtime_printstring((string)__PAIR64__(v71, (unsigned int)v77.str));
      runtime_printnl();
      runtime_printunlock();
      fi.str = (uint8 *)"abi mismatch";
      fi.len = 12;
      runtime_throw(fi);
      BUG();
    }
    v34 = v37 + 1;
    v33 = v73;
  }
}
// 8082029: variable 'v2' is possibly undefined
// 80824BC: variable 'f' is possibly undefined
// 80824BC: variable 'off' is possibly undefined
// 80824BC: variable 'targetpc' is possibly undefined
// 80824FA: variable 'v35' is possibly undefined
// 80E0D84: using guessed type char go_string__;
// 80E0D92: using guessed type char asc_80E0D92;
// 80E0D9D: using guessed type char asc_80E0D9D;

//----- (08082750) --------------------------------------------------------
runtime_Func *__golang runtime_FuncForPC(uintptr pc)
{
  return (runtime_Func *)runtime_findfunc(pc)._func;
}

//----- (08082790) --------------------------------------------------------
string __golang runtime___ptr_Func__Name(runtime_Func *f)
{
  runtime_funcInfo_0 v1; // [esp+4h] [ebp-Ch]
  string _r0; // [esp+18h] [ebp+8h]

  if ( f )
  {
    v1 = runtime___ptr_Func__funcInfo(f);
    return runtime_funcname(v1);
  }
  else
  {
    _r0.str = 0;
    _r0.len = 0;
  }
  return _r0;
}

//----- (08082800) --------------------------------------------------------
runtime_moduledata_0 *__golang runtime_findmoduledatap(uintptr pc)
{
  runtime_moduledata *i; // ecx

  for ( i = &runtime_firstmoduledata; i; i = i->next )
  {
    if ( i->minpc <= pc && pc < i->maxpc )
      return i;
  }
  return 0;
}

//----- (08082850) --------------------------------------------------------
runtime_funcInfo_0 __golang runtime_findfunc(uintptr pc)
{
  _DWORD *v1; // edx
  unsigned int v2; // ecx
  unsigned int v3; // ecx
  runtime_functab_0 *array; // edx
  unsigned int len; // ebp
  unsigned __int32 funcoff; // ecx
  string v7; // [esp+0h] [ebp-8h]
  runtime_moduledata_0 *v8; // [esp+4h] [ebp-4h]
  runtime_funcInfo_0 _r1; // [esp+10h] [ebp+8h]

  v8 = runtime_findmoduledatap(pc);
  if ( v8 )
  {
    v2 = (unsigned __int16)((pc - LOWORD(v8->minpc)) & 0xFFF) >> 8;
    if ( v2 >= 0x10 )
      runtime_panicindex();
    v1 = (_DWORD *)(v8->findfunctab + 20 * ((pc - v8->minpc) >> 12));
    v3 = *v1 + *((unsigned __int8 *)v1 + v2 + 4);
    array = v8->ftab.array;
    len = v8->ftab.len;
    if ( v3 >= len )
      v3 = len - 1;
    if ( v3 >= len )
      runtime_panicindex();
    if ( pc < array[v3].entry )
    {
      while ( 1 )
      {
        if ( v3 >= len )
          runtime_panicindex();
        if ( array[v3].entry <= pc || !v3 )
          break;
        --v3;
      }
      if ( !v3 )
      {
        v7.str = (uint8 *)"findfunc: bad findfunctab entry idx";
        v7.len = 35;
        runtime_throw(v7);
        BUG();
      }
    }
    else
    {
      while ( 1 )
      {
        if ( v3 + 1 >= len )
          runtime_panicindex();
        if ( array[v3 + 1].entry > pc )
          break;
        ++v3;
      }
    }
    if ( v3 >= len || (funcoff = array[v3].funcoff, funcoff >= v8->pclntable.len) )
      runtime_panicindex();
    _r1._func = (runtime__func *)&v8->pclntable.array[funcoff];
    _r1.datap = v8;
  }
  else
  {
    _r1._func = 0;
    _r1.datap = 0;
  }
  return _r1;
}

//----- (08082980) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
int32 __golang runtime_pcvalue(
        runtime_funcInfo_0 f,
        int32 off,
        uintptr targetpc,
        runtime_pcvalueCache *cache,
        bool strict)
{
  int i; // ebx
  runtime__func *func; // ebx
  __int32 cap; // esi
  unsigned __int32 len; // edi
  uint8 *array; // ebp
  __int32 v10; // edi
  __int32 v11; // ecx
  uint8 *v12; // ebp
  int v13; // ecx
  unsigned int v14; // ebx
  int v15; // ecx
  int32 v16; // edx
  __int32 v17; // ecx
  unsigned __int32 v18; // edx
  uint8 *v19; // eax
  runtime__func *v20; // ebp
  __int32 v21; // edx
  __int32 v22; // esi
  uint8 *j; // eax
  __uint8 p; // [esp+0h] [ebp-48h]
  string pa; // [esp+0h] [ebp-48h]
  string pb; // [esp+0h] [ebp-48h]
  string pc; // [esp+0h] [ebp-48h]
  string pd; // [esp+0h] [ebp-48h]
  uint8 *pe; // [esp+0h] [ebp-48h]
  const char *pf; // [esp+0h] [ebp-48h]
  string pg; // [esp+0h] [ebp-48h]
  string ph; // [esp+0h] [ebp-48h]
  string pi; // [esp+0h] [ebp-48h]
  __uint8 pj; // [esp+0h] [ebp-48h]
  string pk; // [esp+0h] [ebp-48h]
  string pl; // [esp+0h] [ebp-48h]
  string pm; // [esp+0h] [ebp-48h]
  string pn; // [esp+0h] [ebp-48h]
  long double p_4; // [esp+4h] [ebp-44h] OVERLAPPED
  __uint8 v40; // [esp+18h] [ebp-30h]
  bool v41; // [esp+24h] [ebp-24h]
  int32 val; // [esp+28h] [ebp-20h] BYREF
  uintptr pca; // [esp+2Ch] [ebp-1Ch] BYREF
  __int32 p_len; // [esp+30h] [ebp-18h]
  __int32 p_cap; // [esp+34h] [ebp-14h]
  uintptr v; // [esp+38h] [ebp-10h]
  unsigned int v_4; // [esp+3Ch] [ebp-Ch]
  uint8 *p_ptr; // [esp+40h] [ebp-8h]
  unsigned int v49; // [esp+44h] [ebp-4h]

  if ( !off )
    return -1;
  if ( cache )
  {
    for ( i = 0; i < 16; ++i )
    {
      if ( (unsigned int)i >= 0x10 )
        runtime_panicindex();
      if ( off == cache->entries[i].off && targetpc == cache->entries[i].targetpc )
        return cache->entries[i].val;
    }
  }
  func = f._func;
  if ( f._func )
  {
    cap = f.datap->pclntable.cap;
    len = f.datap->pclntable.len;
    array = f.datap->pclntable.array;
    if ( off > len )
      runtime_panicslice();
    pca = f._func->entry;
    val = -1;
    v10 = len - off;
    v11 = cap - off;
    v12 = &array[off & ((off - cap) >> 31)];
    while ( 1 )
    {
      p.array = v12;
      *(_QWORD *)&p.len = __PAIR64__(v11, v10);
      runtime_step(p, &pca, &val, func->entry == pca, v40, v41);
      if ( !v41 )
        break;
      if ( targetpc < pca )
      {
        if ( cache )
        {
          v13 = *(_DWORD *)(*(_DWORD *)(__readgsdword(0) - 4) + 24);
          v14 = (*(int *)(v13 + 148) >> 31) & 0xA8888EEF ^ (2 * *(_DWORD *)(v13 + 148));
          *(_DWORD *)(v13 + 148) = v14;
          v15 = v14 & 0xF;
          v16 = val;
          cache->entries[v15].targetpc = targetpc;
          cache->entries[v15].off = off;
          cache->entries[v15].val = v16;
        }
        return val;
      }
      func = f._func;
      v10 = v40.len;
      v12 = v40.array;
      v11 = v40.cap;
    }
    if ( !runtime_panicking && strict )
    {
      p_cap = v40.cap;
      p_len = v40.len;
      p_ptr = v40.array;
      *(string *)((char *)&p_4 + 4) = runtime_funcname(f);
      v_4 = HIDWORD(p_4);
      v49 = DWORD1(p_4);
      v = pca;
      runtime_printlock();
      pa.str = (uint8 *)"runtime: invalid pc-encoded table f=";
      pa.len = 36;
      runtime_printstring(pa);
      runtime_printstring((string)__PAIR64__(v_4, v49));
      pb.str = (uint8 *)" pc=";
      pb.len = 4;
      runtime_printstring(pb);
      runtime_printhex(v);
      pc.str = (uint8 *)" targetpc=";
      pc.len = 10;
      runtime_printstring(pc);
      runtime_printhex(targetpc);
      pd.str = (uint8 *)" tab=";
      pd.len = 5;
      runtime_printstring(pd);
      pe = p_ptr;
      *(_QWORD *)&p_4 = __PAIR64__(p_cap, p_len);
      runtime_printslice(*(__uint8 *)((char *)&p_4 - 4));
      pf = "\n";
      LODWORD(p_4) = 1;
      runtime_printstring(*(string *)((char *)&p_4 - 4));
      runtime_printunlock();
      v17 = f.datap->pclntable.cap;
      v18 = f.datap->pclntable.len;
      v19 = f.datap->pclntable.array;
      if ( off <= v18 )
      {
        v20 = f._func;
        pca = f._func->entry;
        val = -1;
        v21 = v18 - off;
        v22 = v17 - off;
        for ( j = &v19[off & ((off - v17) >> 31)]; ; j = p_ptr )
        {
          pj.array = j;
          *(_QWORD *)&pj.len = __PAIR64__(v22, v21);
          runtime_step(pj, &pca, &val, v20->entry == pca, v40, v41);
          if ( !v41 )
            break;
          p_cap = v40.cap;
          p_len = v40.len;
          p_ptr = v40.array;
          v = pca;
          runtime_printlock();
          pg.str = (uint8 *)"\tvalue=";
          pg.len = 7;
          runtime_printstring(pg);
          runtime_printint(val);
          ph.str = (uint8 *)" until pc=";
          ph.len = 10;
          runtime_printstring(ph);
          runtime_printhex(v);
          pi.str = (uint8 *)"\n";
          pi.len = 1;
          runtime_printstring(pi);
          runtime_printunlock();
          v20 = f._func;
          v22 = p_cap;
          v21 = p_len;
        }
        pk.str = (uint8 *)"invalid runtime symbol table";
        pk.len = 28;
        runtime_throw(pk);
        BUG();
      }
      runtime_panicslice();
    }
    return -1;
  }
  else
  {
    if ( strict && !runtime_panicking )
    {
      v = MEMORY[0];
      runtime_printlock();
      pl.str = (uint8 *)"runtime: no module data for ";
      pl.len = 28;
      runtime_printstring(pl);
      runtime_printhex(v);
      pm.str = (uint8 *)"\n";
      pm.len = 1;
      runtime_printstring(pm);
      runtime_printunlock();
      pn.str = (uint8 *)"no module data";
      pn.len = 14;
      runtime_throw(pn);
      BUG();
    }
    return -1;
  }
}
// 8082B10: failed to expand linear variable ^4.12

//----- (08082E00) --------------------------------------------------------
string __golang runtime_funcname(runtime_funcInfo_0 f)
{
  unsigned __int32 nameoff; // eax
  uint8 *str; // eax

  if ( f._func && (nameoff = f._func->nameoff) != 0 )
  {
    if ( nameoff >= f.datap->pclntable.len )
      runtime_panicindex();
    str = &f.datap->pclntable.array[nameoff];
  }
  else
  {
    str = 0;
  }
  return runtime_gostringnocopy(str);
}

//----- (08082E70) --------------------------------------------------------
string __golang runtime_funcnameFromNameoff(runtime_funcInfo_0 f, int32 nameoff)
{
  string _r2; // [esp+1Ch] [ebp+10h]

  if ( f._func )
  {
    if ( (unsigned int)nameoff >= f.datap->pclntable.len )
      runtime_panicindex();
    return runtime_gostringnocopy(&f.datap->pclntable.array[nameoff]);
  }
  else
  {
    _r2.str = 0;
    _r2.len = 0;
  }
  return _r2;
}

//----- (08082EE0) --------------------------------------------------------
string __golang runtime_funcfile(runtime_funcInfo_0 f, int32 fileno)
{
  unsigned __int32 v2; // eax
  string _r2; // [esp+1Ch] [ebp+10h]

  if ( f._func )
  {
    if ( (unsigned int)fileno >= f.datap->filetab.len
      || (v2 = f.datap->filetab.array[fileno], v2 >= f.datap->pclntable.len) )
    {
      runtime_panicindex();
    }
    return runtime_gostringnocopy(&f.datap->pclntable.array[v2]);
  }
  else
  {
    _r2.str = (uint8 *)"?";
    _r2.len = 1;
  }
  return _r2;
}
// 80E0D93: using guessed type char asc_80E0D93;

//----- (08082F60) --------------------------------------------------------
void __golang runtime_funcline1(runtime_funcInfo_0 f, uintptr targetpc, bool strict, string file, int32 line)
{
  __int32 len; // ebx
  unsigned __int32 v6; // ecx
  int32 v7; // [esp+18h] [ebp-8h]
  int32 v8; // [esp+1Ch] [ebp-4h]

  if ( f._func )
  {
    v8 = runtime_pcvalue(f, f._func->pcfile, targetpc, 0, strict);
    v7 = runtime_pcvalue(f, f._func->pcln, targetpc, 0, strict);
    if ( v8 != -1 && v7 != -1 )
    {
      len = f.datap->filetab.len;
      if ( v8 < len )
      {
        if ( v8 >= (unsigned int)len || (v6 = f.datap->filetab.array[v8], v6 >= f.datap->pclntable.len) )
          runtime_panicindex();
        runtime_gostringnocopy(&f.datap->pclntable.array[v6]);
      }
    }
  }
}

//----- (080830A0) --------------------------------------------------------
void __golang runtime_funcline(runtime_funcInfo_0 f, uintptr targetpc, string file, int32 line)
{
  string v4; // [esp+10h] [ebp-Ch]
  int32 v5; // [esp+18h] [ebp-4h]

  runtime_funcline1(f, targetpc, 1, v4, v5);
}
// 80830D1: variable 'v4' is possibly undefined
// 80830D1: variable 'v5' is possibly undefined

//----- (08083100) --------------------------------------------------------
int32 __golang runtime_funcspdelta(runtime_funcInfo_0 f, uintptr targetpc, runtime_pcvalueCache *cache)
{
  int32 v3; // eax
  string v4; // [esp+0h] [ebp-30h]
  string v5; // [esp+0h] [ebp-30h]
  string v6; // [esp+0h] [ebp-30h]
  string v7; // [esp+0h] [ebp-30h]
  string v8; // [esp+0h] [ebp-30h]
  string v9; // [esp+0h] [ebp-30h]
  string off; // [esp+8h] [ebp-28h]
  int32 v11; // [esp+18h] [ebp-18h]
  int32 v; // [esp+24h] [ebp-Ch]
  uintptr v_4; // [esp+28h] [ebp-8h]

  v11 = runtime_pcvalue(f, f._func->pcsp, targetpc, cache, 1);
  v3 = v11;
  if ( (v11 & 3) != 0 )
  {
    off = runtime_funcname(f);
    v_4 = f._func->entry;
    v = f._func->pcsp;
    runtime_printlock();
    v4.str = (uint8 *)"invalid spdelta ";
    v4.len = 16;
    runtime_printstring(v4);
    runtime_printstring(off);
    v5.str = (uint8 *)" ";
    v5.len = 1;
    runtime_printstring(v5);
    runtime_printhex(v_4);
    v6.str = (uint8 *)" ";
    v6.len = 1;
    runtime_printstring(v6);
    runtime_printhex(targetpc);
    v7.str = (uint8 *)" ";
    v7.len = 1;
    runtime_printstring(v7);
    runtime_printhex(v);
    v8.str = (uint8 *)" ";
    v8.len = 1;
    runtime_printstring(v8);
    runtime_printint(v11);
    v9.str = (uint8 *)"\n";
    v9.len = 1;
    runtime_printstring(v9);
    runtime_printunlock();
    return v11;
  }
  return v3;
}
// 80E0D84: using guessed type char go_string__;

//----- (080832A0) --------------------------------------------------------
int32 __golang runtime_pcdatavalue(runtime_funcInfo_0 f, int32 table, uintptr targetpc, runtime_pcvalueCache *cache)
{
  if ( table < 0 || table >= f._func->npcdata )
    return -1;
  else
    return runtime_pcvalue(f, *(&f._func[1].entry + table), targetpc, cache, 1);
}

//----- (08083320) --------------------------------------------------------
void *__golang runtime_funcdata(runtime_funcInfo_0 f, int32 i)
{
  if ( i < 0 || i >= f._func->nfuncdata )
    return 0;
  else
    return (void *)*(&f._func[1].entry + f._func->npcdata + i);
}

//----- (08083370) --------------------------------------------------------
void __golang runtime_step(__uint8 p, uintptr *pc, int32 *val, bool first, __uint8 newp, bool ok)
{
  unsigned __int32 len; // eax
  uint8 *array; // ecx
  uint32 v8; // edx
  unsigned int v9; // ebx
  unsigned int v10; // eax
  unsigned __int32 v11; // esi
  __int32 v12; // ebx
  uint8 *v13; // ebp
  int v14; // edx
  int v15; // ecx
  unsigned int v16; // ebx
  __uint8 v17; // [esp+0h] [ebp-1Ch]
  uint32 v18; // [esp+Ch] [ebp-10h]
  unsigned int v19; // [esp+Ch] [ebp-10h]
  uint32 v20; // [esp+10h] [ebp-Ch]
  int v21; // [esp+10h] [ebp-Ch]
  int v22; // [esp+14h] [ebp-8h]
  unsigned int p_4; // [esp+24h] [ebp+8h]

  len = p.len;
  if ( !p.len )
    runtime_panicindex();
  array = p.array;
  v8 = *p.array;
  if ( *p.array || first )
  {
    if ( (v8 & 0x80) != 0 )
    {
      runtime_readvarint(p, v18, v20);
      v9 = v18;
      v8 = v20;
      len = p.len;
      array = p.array;
    }
    else
    {
      v9 = 1;
    }
    if ( v9 > len )
      runtime_panicslice();
    v10 = len - v9;
    v11 = p.cap - v9;
    v12 = ((int)(v9 - p.cap) >> 31) & v9;
    v13 = &array[v12];
    if ( (v8 & 1) != 0 )
      v14 = ~(v8 >> 1);
    else
      v14 = v8 >> 1;
    if ( !v10 )
      runtime_panicindex();
    p_4 = v10;
    v15 = array[v12];
    if ( (v15 & 0x80) != 0 )
    {
      v22 = v14;
      v17.array = v13;
      *(_QWORD *)&v17.len = __PAIR64__(v11, v10);
      runtime_readvarint(v17, v18, v20);
      v16 = v19;
      v15 = v21;
      v10 = p_4;
      v14 = v22;
    }
    else
    {
      v16 = 1;
    }
    if ( v16 > v10 )
      runtime_panicslice();
    *pc += v15;
    *val += v14;
  }
}
// 808346C: variable 'v18' is possibly undefined
// 808346C: variable 'v20' is possibly undefined
// 8083471: variable 'v19' is possibly undefined
// 8083475: variable 'v21' is possibly undefined

//----- (08083510) --------------------------------------------------------
void __golang runtime_readvarint(__uint8 p, uint32 read, uint32 val)
{
  unsigned __int32 v3; // ecx
  int v4; // ebx
  char i; // bp
  signed __int8 b; // [esp+3h] [ebp-1h]

  v3 = 0;
  v4 = 0;
  for ( i = 0; ; i += 7 )
  {
    if ( v3 >= p.len )
      runtime_panicindex();
    b = p.array[v3];
    v4 |= (b & 0x7F) << i;
    if ( b >= 0 )
      break;
    ++v3;
  }
}

//----- (08083580) --------------------------------------------------------
runtime_bitvector_0 __golang runtime_stackmapdata(runtime_stackmap *stkmap, int32 n)
{
  string s; // [esp+0h] [ebp-8h]
  runtime_bitvector_0 _r2; // [esp+14h] [ebp+Ch]

  if ( n < 0 || n >= stkmap->n )
  {
    s.str = (uint8 *)"stackmapdata: index out of range";
    s.len = 32;
    runtime_throw(s);
    BUG();
  }
  _r2.n = stkmap->nbit;
  _r2.bytedata = &stkmap->bytedata[((_r2.n + 7) >> 3) * n];
  return _r2;
}

//----- (080835F0) --------------------------------------------------------
bool __golang runtime_deltimer(runtime_timer *t)
{
  unsigned __int32 v1; // ecx
  __int32 len; // ebx
  unsigned __int32 v3; // ebp
  runtime_timer *src; // esi
  __int32 last; // [esp+8h] [ebp-Ch]
  __int32 i; // [esp+Ch] [ebp-8h]
  __int32 v7; // [esp+10h] [ebp-4h]

  runtime_lock(&runtime_timers.lock);
  v1 = t->i;
  len = runtime_timers.t.len;
  if ( t->i < 0 )
    goto LABEL_2;
  v3 = runtime_timers.t.len - 1;
  if ( (int)v1 > runtime_timers.t.len - 1 )
    goto LABEL_2;
  if ( v1 >= runtime_timers.t.len )
    runtime_panicindex();
  if ( runtime_timers.t.array[v1] == t )
  {
    i = t->i;
    last = runtime_timers.t.len - 1;
    if ( v3 != v1 )
    {
      if ( v3 >= runtime_timers.t.len )
        runtime_panicindex();
      src = runtime_timers.t.array[runtime_timers.t.len - 1];
      if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      {
        v7 = runtime_timers.t.len;
        runtime_writebarrierptr((uintptr *)&runtime_timers.t.array[v1], (uintptr)src);
        v1 = i;
        len = v7;
        v3 = last;
      }
      else
      {
        runtime_timers.t.array[v1] = src;
      }
      if ( v1 >= runtime_timers.t.len )
        runtime_panicindex();
      runtime_timers.t.array[v1]->i = v1;
    }
    if ( v3 >= runtime_timers.t.len )
      runtime_panicindex();
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
    {
      runtime_writebarrierptr((uintptr *)&runtime_timers.t.array[len - 1], 0);
      v1 = i;
      v3 = last;
    }
    else
    {
      runtime_timers.t.array[len - 1] = 0;
    }
    if ( v3 > runtime_timers.t.cap )
      runtime_panicslice();
    runtime_timers.t.len = v3;
    if ( v3 != v1 )
    {
      runtime_siftupTimer(v1);
      runtime_siftdownTimer(i);
    }
    runtime_unlock(&runtime_timers.lock);
    return 1;
  }
  else
  {
LABEL_2:
    runtime_unlock(&runtime_timers.lock);
    return 0;
  }
}

//----- (08083780) --------------------------------------------------------
void __golang __noreturn runtime_timerproc()
{
  int v0; // edi
  runtime_g *v1; // ecx
  unsigned int v2; // eax
  unsigned int v3; // ecx
  __int32 len; // edx
  runtime_timer *v5; // ebp
  int v6; // ecx
  int v7; // esi
  unsigned __int64 v8; // kr08_8
  int v9; // ebx
  int v10; // edi
  int period_high; // eax
  int v12; // ebx
  int v13; // et1
  int v14; // ebx
  int v15; // edi
  int v16; // ebx
  unsigned __int32 v17; // eax
  runtime_timer *v18; // esi
  unsigned int v19; // kr00_4
  __int64 l; // [esp+0h] [ebp-54h]
  string l_4; // [esp+4h] [ebp-50h]
  int64 traceskip; // [esp+10h] [ebp-44h]
  uintptr seq; // [esp+18h] [ebp-3Ch]
  __int64 now_lo; // [esp+1Ch] [ebp-38h]
  __int32 last; // [esp+24h] [ebp-30h]
  int64 delta_lo; // [esp+28h] [ebp-2Ch]
  unsigned int period; // [esp+30h] [ebp-24h]
  int v28; // [esp+30h] [ebp-24h]
  unsigned int v29; // [esp+34h] [ebp-20h]
  __int32 v30; // [esp+38h] [ebp-1Ch]
  unsigned int when_high; // [esp+3Ch] [ebp-18h]
  unsigned int when; // [esp+40h] [ebp-14h]
  runtime_timer *t; // [esp+44h] [ebp-10h]
  func(interface_{}__uintptr) f; // [esp+48h] [ebp-Ch]
  uint8 *arg_type; // [esp+4Ch] [ebp-8h]
  uint8 *arg_data; // [esp+50h] [ebp-4h]

  v1 = *(runtime_g **)(__readgsdword(0) - 4);
  if ( *(_DWORD *)&runtime_writeBarrier.enabled )
    runtime_writebarrierptr((uintptr *)&runtime_timers.gp, (uintptr)v1);
  else
    runtime_timers.gp = v1;
  while ( 1 )
  {
    runtime_lock(&runtime_timers.lock);
    runtime_timers.sleeping = 0;
    runtime_nanotime();
    v2 = HIDWORD(l);
    v3 = l;
    for ( now_lo = l; ; v3 = now_lo )
    {
      len = runtime_timers.t.len;
      if ( !runtime_timers.t.len )
        break;
      v5 = *runtime_timers.t.array;
      when = (*runtime_timers.t.array)->when;
      v8 = (*runtime_timers.t.array)->when - __PAIR64__(v2, v3);
      v6 = HIDWORD(v8);
      v7 = v8;
      when_high = HIDWORD((*runtime_timers.t.array)->when);
      LOBYTE(v2) = HIDWORD(v8) == 0;
      v9 = v0;
      LOBYTE(v9) = (_DWORD)v8 != 0;
      v10 = v2 & v9;
      LOBYTE(v2) = SHIDWORD(v8) > 0;
      v0 = v2 | v10;
      if ( (_BYTE)v0 )
        goto LABEL_23;
      t = *runtime_timers.t.array;
      period_high = HIDWORD(v5->period);
      v12 = v8;
      LOBYTE(v12) = period_high == 0;
      v13 = v12;
      v14 = v0;
      LOBYTE(v14) = LODWORD(v5->period) != 0;
      v15 = v13 & v14;
      v16 = v13;
      LOBYTE(v16) = period_high > 0;
      v0 = v16 | v15;
      if ( (_BYTE)v0 )
      {
        v29 = HIDWORD(v5->period);
        period = v5->period;
        traceskip = runtime_int64div(now_lo - __PAIR64__(when_high, when), v5->period);
        v19 = period;
        v28 = period * (traceskip + 1);
        v0 = (int)v5;
        LODWORD(v5->when) = when + v28;
        HIDWORD(v5->when) = when_high + __CFADD__(when, v28) + ((__PAIR64__(v29, v19) * (traceskip + 1)) >> 32);
        runtime_siftdownTimer(0);
      }
      else
      {
        v17 = runtime_timers.t.len - 1;
        last = runtime_timers.t.len - 1;
        if ( runtime_timers.t.len - 1 > 0 )
        {
          if ( v17 >= runtime_timers.t.len )
            runtime_panicindex();
          v18 = runtime_timers.t.array[runtime_timers.t.len - 1];
          if ( *(_DWORD *)&runtime_writeBarrier.enabled )
          {
            v30 = runtime_timers.t.len;
            runtime_writebarrierptr((uintptr *)runtime_timers.t.array, (uintptr)v18);
            v17 = last;
            len = v30;
          }
          else
          {
            *runtime_timers.t.array = v18;
          }
          if ( !runtime_timers.t.len )
            runtime_panicindex();
          **(_DWORD **)runtime_timers.t.array = 0;
        }
        if ( v17 >= runtime_timers.t.len )
          runtime_panicindex();
        if ( *(_DWORD *)&runtime_writeBarrier.enabled )
        {
          runtime_writebarrierptr((uintptr *)&runtime_timers.t.array[len - 1], 0);
          v17 = last;
        }
        else
        {
          runtime_timers.t.array[len - 1] = 0;
        }
        if ( v17 > runtime_timers.t.cap )
          runtime_panicslice();
        runtime_timers.t.len = v17;
        if ( (int)v17 > 0 )
        {
          runtime_siftdownTimer(0);
          v5 = t;
        }
        v5->i = -1;
      }
      f = v5->f;
      arg_data = (uint8 *)v5->arg.data;
      arg_type = (uint8 *)v5->arg._type;
      seq = v5->seq;
      runtime_unlock(&runtime_timers.lock);
      (*(void (__golang **)(uint8 *, uint8 *, uintptr))f)(arg_type, arg_data, seq);
      runtime_lock(&runtime_timers.lock);
      v2 = HIDWORD(now_lo);
    }
    v6 = -1;
    v7 = -1;
LABEL_23:
    if ( v6 < 0 || SHIDWORD(runtime_faketime) > 0 || HIDWORD(runtime_faketime) == 0 && (_DWORD)runtime_faketime != 0 )
    {
      runtime_timers.rescheduling = 1;
      l_4.str = (uint8 *)"timer goroutine (idle)";
      l_4.len = 22;
      runtime_goparkunlock(&runtime_timers.lock, l_4, 0x14u, 1);
    }
    else
    {
      delta_lo = __PAIR64__(v6, v7);
      runtime_timers.sleeping = 1;
      runtime_timers.sleepUntil = __PAIR64__(v6, v7) + now_lo;
      runtime_timers.waitnote.key = 0;
      runtime_unlock(&runtime_timers.lock);
      runtime_notetsleepg(&runtime_timers.waitnote, delta_lo);
    }
  }
}
// 808384D: variable 'v0' is possibly undefined
// 8083A73: variable 'l' is possibly undefined

//----- (08083B70) --------------------------------------------------------
runtime_g *__golang runtime_timejump()
{
  int when_high; // ebx
  runtime_g *v1; // eax
  runtime_g *gp; // [esp+4h] [ebp-4h]

  if ( (_DWORD)runtime_faketime == 0 && HIDWORD(runtime_faketime) == 0 )
    return 0;
  runtime_lock(&runtime_timers.lock);
  if ( runtime_timers.created && runtime_timers.t.len )
  {
    when_high = HIDWORD((*runtime_timers.t.array)->when);
    if ( HIDWORD(runtime_faketime) == when_high
      && (unsigned int)runtime_faketime < LODWORD((*runtime_timers.t.array)->when)
      || SHIDWORD(runtime_faketime) < when_high )
    {
      LODWORD(runtime_faketime) = (*runtime_timers.t.array)->when;
      HIDWORD(runtime_faketime) = when_high;
      if ( runtime_timers.rescheduling )
      {
        runtime_timers.rescheduling = 0;
        v1 = runtime_timers.gp;
      }
      else
      {
        v1 = 0;
      }
    }
    else
    {
      v1 = 0;
    }
    gp = v1;
    runtime_unlock(&runtime_timers.lock);
    return gp;
  }
  else
  {
    runtime_unlock(&runtime_timers.lock);
    return 0;
  }
}

//----- (08083C80) --------------------------------------------------------
void __golang runtime_siftupTimer(__int32 i)
{
  runtime_timer **array; // eax
  unsigned __int32 len; // ecx
  __int32 v3; // edx
  uint32 when; // ebp
  int32 when_high; // esi
  unsigned int v6; // edi
  __int32 v7; // ecx
  unsigned __int32 v8; // ebx
  _DWORD *p_i; // edx
  runtime_timer *v10; // ecx
  uint32 when_lo; // [esp+8h] [ebp-24h]
  int32 when_hi; // [esp+Ch] [ebp-20h]
  unsigned __int32 t_len; // [esp+10h] [ebp-1Ch]
  __int32 p; // [esp+14h] [ebp-18h]
  runtime_timer **t_ptr; // [esp+18h] [ebp-14h]
  uintptr *dst; // [esp+20h] [ebp-Ch]
  uintptr v17; // [esp+24h] [ebp-8h]
  runtime_timer *src; // [esp+28h] [ebp-4h]
  __int32 ia; // [esp+30h] [ebp+4h]

  array = runtime_timers.t.array;
  len = runtime_timers.t.len;
  v3 = i;
  if ( (unsigned int)i >= runtime_timers.t.len )
    runtime_panicindex();
  t_ptr = runtime_timers.t.array;
  t_len = runtime_timers.t.len;
  src = runtime_timers.t.array[i];
  when = src->when;
  when_lo = when;
  when_high = HIDWORD(src->when);
  when_hi = when_high;
  while ( v3 > 0 )
  {
    v6 = (int)(((unsigned int)((v3 - 1) >> 31) >> 30) + v3 - 1) >> 2;
    if ( v6 >= len )
      runtime_panicindex();
    ia = v3;
    v17 = (uintptr)array[v6];
    if ( when >= *(_DWORD *)(v17 + 4) && when_high == *(_DWORD *)(v17 + 8) || when_high > *(_DWORD *)(v17 + 8) )
      break;
    v7 = v3;
    v8 = t_len;
    if ( v3 >= t_len )
      runtime_panicindex();
    p = (int)(((unsigned int)((v3 - 1) >> 31) >> 30) + v3 - 1) >> 2;
    dst = (uintptr *)&array[v6];
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
    {
      runtime_writebarrierptr((uintptr *)&array[v3], v17);
      array = t_ptr;
      v7 = ia;
      p_i = (_DWORD *)v17;
      v8 = t_len;
      when = when_lo;
      when_high = when_hi;
    }
    else
    {
      p_i = &array[v6]->i;
      array[ia] = (runtime_timer *)v17;
    }
    *p_i = v7;
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
    {
      runtime_writebarrierptr(dst, (uintptr)src);
      array = t_ptr;
      v10 = src;
      v8 = t_len;
      when = when_lo;
      when_high = when_hi;
      v6 = p;
    }
    else
    {
      v10 = src;
      array[v6] = src;
    }
    v10->i = v6;
    len = v8;
    v3 = v6;
  }
}

//----- (08083E00) --------------------------------------------------------
void __golang runtime_siftdownTimer(__int32 i)
{
  runtime_timer **array; // eax
  __int32 len; // ecx
  __int32 v3; // edx
  __int32 v4; // edi
  int v5; // edx
  runtime_timer *v6; // edi
  uint32 when; // ebp
  int32 when_high; // edi
  __int32 v9; // esi
  runtime_timer *v10; // eax
  int32 v11; // eax
  uint32 v12; // ecx
  int v13; // ebx
  runtime_timer *v14; // esi
  int32 v15; // ecx
  uint32 v16; // esi
  runtime_timer *v17; // edx
  int32 v18; // edi
  uint32 v19; // edx
  unsigned __int32 v20; // eax
  __int32 v21; // edx
  runtime_timer **v22; // ebx
  runtime_timer *v23; // esi
  __int32 v24; // edi
  runtime_timer *v25; // ecx
  uint32 when_lo; // [esp+8h] [ebp-34h]
  int32 when_hi; // [esp+Ch] [ebp-30h]
  uint32 w_lo; // [esp+10h] [ebp-2Ch]
  int32 w_hi; // [esp+14h] [ebp-28h]
  unsigned int t_len; // [esp+18h] [ebp-24h]
  __int32 c; // [esp+1Ch] [ebp-20h]
  uint32 v32; // [esp+20h] [ebp-1Ch]
  unsigned int v33; // [esp+24h] [ebp-18h]
  int v34; // [esp+28h] [ebp-14h]
  int v35; // [esp+28h] [ebp-14h]
  __int32 v36; // [esp+28h] [ebp-14h]
  runtime_timer **t_ptr; // [esp+2Ch] [ebp-10h]
  uintptr *dst; // [esp+34h] [ebp-8h]
  runtime_timer *src; // [esp+38h] [ebp-4h]

  array = runtime_timers.t.array;
  len = runtime_timers.t.len;
  v3 = i;
  if ( (unsigned int)i >= runtime_timers.t.len )
    runtime_panicindex();
  t_ptr = runtime_timers.t.array;
  t_len = runtime_timers.t.len;
  src = runtime_timers.t.array[i];
  when_lo = src->when;
  when_hi = HIDWORD(src->when);
  while ( 1 )
  {
    v4 = v3;
    v5 = 4 * v3;
    if ( v5 + 1 >= len )
      break;
    if ( v5 + 1 >= (unsigned int)len )
      runtime_panicindex();
    v34 = v5;
    v33 = v4;
    v6 = array[v5 + 1];
    when = v6->when;
    when_high = HIDWORD(v6->when);
    v9 = v5 + 2;
    if ( v5 + 2 >= len )
    {
      v11 = when_high;
      v12 = when;
      v9 = v5 + 1;
    }
    else
    {
      if ( v5 + 2 >= (unsigned int)len )
        runtime_panicindex();
      v10 = array[v5 + 2];
      v32 = v10->when;
      v11 = HIDWORD(v10->when);
      if ( v32 < when && v11 == when_high || v11 < when_high )
      {
        v12 = v32;
      }
      else
      {
        v11 = when_high;
        v12 = when;
        v9 = v5 + 1;
      }
    }
    v13 = v5 + 3;
    if ( v5 + 3 >= (int)t_len )
    {
      v18 = v11;
      v19 = v12;
      v20 = v9;
    }
    else
    {
      if ( v5 + 3 >= t_len )
        runtime_panicindex();
      w_hi = v11;
      w_lo = v12;
      c = v9;
      v14 = t_ptr[v5 + 3];
      v15 = HIDWORD(v14->when);
      v16 = v14->when;
      if ( v5 + 4 >= (int)t_len )
      {
        v19 = v16;
        v18 = v15;
        v20 = v34 + 3;
      }
      else
      {
        if ( v5 + 4 >= t_len )
          runtime_panicindex();
        v35 = v5 + 4;
        v17 = t_ptr[v5 + 4];
        v18 = HIDWORD(v17->when);
        v19 = v17->when;
        if ( v18 < v15 || v19 < v16 && v18 == v15 )
        {
          v20 = v35;
        }
        else
        {
          v19 = v16;
          v18 = v15;
          v20 = v13;
        }
      }
      if ( v18 >= w_hi && (v18 != w_hi || v19 >= w_lo) )
      {
        v18 = w_hi;
        v19 = w_lo;
        v20 = c;
      }
    }
    if ( v18 == when_hi && v19 >= when_lo || v18 > when_hi )
      break;
    v21 = t_len;
    if ( v20 >= t_len || (v22 = t_ptr, v23 = t_ptr[v20], dst = (uintptr *)&t_ptr[v20], v24 = v33, v33 >= t_len) )
      runtime_panicindex();
    v36 = v20;
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
    {
      runtime_writebarrierptr((uintptr *)&t_ptr[v33], (uintptr)v23);
      v20 = v36;
      v21 = t_len;
      v22 = t_ptr;
      v24 = v33;
    }
    else
    {
      t_ptr[v33] = v23;
    }
    v23->i = v24;
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
    {
      runtime_writebarrierptr(dst, (uintptr)src);
      v20 = v36;
      v25 = src;
      v21 = t_len;
      v22 = t_ptr;
    }
    else
    {
      v25 = src;
      v22[v20] = src;
    }
    v25->i = v20;
    array = v22;
    len = v21;
    v3 = v36;
  }
}

//----- (080840B0) --------------------------------------------------------
void __golang time_now(int64 sec, int32 nsec, int64 mono)
{
  runtime_walltime();
  runtime_nanotime();
}

//----- (08084130) --------------------------------------------------------
runtime_g *__golang runtime_traceReader()
{
  runtime_g *reader; // [esp+4h] [ebp-4h]

  if ( !runtime_trace.reader || !runtime_trace.fullHead && !runtime_trace.shutdown )
    return 0;
  runtime_lock(&runtime_trace.lock);
  if ( runtime_trace.reader && (runtime_trace.fullHead || runtime_trace.shutdown) )
  {
    reader = (runtime_g *)runtime_trace.reader;
    runtime_trace.reader = 0;
    runtime_unlock(&runtime_trace.lock);
    return reader;
  }
  else
  {
    runtime_unlock(&runtime_trace.lock);
    return 0;
  }
}

//----- (08084200) --------------------------------------------------------
void __golang runtime_traceProcFree(runtime_p *pp)
{
  runtime_traceBufPtr tracebuf; // ecx
  _DWORD *tp; // [esp+4h] [ebp-4h]

  tracebuf = pp->tracebuf;
  pp->tracebuf = 0;
  if ( tracebuf )
  {
    tp = (_DWORD *)tracebuf;
    runtime_lock(&runtime_trace.lock);
    *tp = 0;
    if ( runtime_trace.fullHead )
      *(_DWORD *)runtime_trace.fullTail = tp;
    else
      runtime_trace.fullHead = (runtime_traceBufPtr)tp;
    runtime_trace.fullTail = (runtime_traceBufPtr)tp;
    runtime_unlock(&runtime_trace.lock);
  }
}

//----- (08084290) --------------------------------------------------------
void __golang runtime_traceEvent(uint8 ev, __int32 skip, __uint64 args)
{
  __int64 v3; // kr00_8
  runtime_traceBufPtr v4; // ecx
  runtime_traceBuf *v5; // eax
  unsigned int lastTicks; // ebx
  unsigned int v7; // ebp
  uint32 v8; // ecx
  bool v9; // cf
  unsigned int v10; // ebx
  int v11; // edx
  char len; // si
  char v13; // di
  uint8 v14; // bl
  unsigned int pos; // esi
  _BYTE *v16; // ebx
  __int32 v17; // eax
  uint64 *array; // ecx
  int v19; // eax
  __int32 v20; // ecx
  runtime_m *v21; // [esp+0h] [ebp-4Ch]
  __int64 v22; // [esp+0h] [ebp-4Ch]
  string v23; // [esp+0h] [ebp-4Ch]
  int32 v24; // [esp+4h] [ebp-48h]
  __uintptr v25; // [esp+4h] [ebp-48h]
  runtime_traceBufPtr *v26; // [esp+8h] [ebp-44h]
  runtime_traceBufPtr *v27; // [esp+8h] [ebp-44h]
  uint64 v28; // [esp+14h] [ebp-38h]
  uint32 tickDiff_lo; // [esp+1Ch] [ebp-30h]
  uint32 tickDiff_hi; // [esp+20h] [ebp-2Ch]
  __int32 v31; // [esp+30h] [ebp-1Ch]
  __int32 v32; // [esp+34h] [ebp-18h]
  runtime_traceBuf *buf; // [esp+44h] [ebp-8h]
  uint64 *v34; // [esp+48h] [ebp-4h]

  runtime_traceAcquireBuffer(v21, v24, v26);
  if ( runtime_trace.enabled || *(_BYTE *)(v22 + 480) )
  {
    v3 = v22;
    if ( *v27 && 65008 - *(_DWORD *)(*v27 + 12) >= 52 )
    {
      v4 = *v27;
    }
    else
    {
      HIDWORD(v22) = runtime_traceFlush(*v27);
      v4 = HIDWORD(v22);
      *v27 = HIDWORD(v22);
    }
    buf = (runtime_traceBuf *)v4;
    runtime_cputicks();
    v5 = buf;
    lastTicks = buf->traceBufHeader.lastTicks;
    v7 = v22 >> 6;
    v8 = v7 - lastTicks;
    v9 = v7 < lastTicks;
    v10 = HIDWORD(v22) >> 6;
    v11 = (HIDWORD(v22) >> 6) - (v9 + HIDWORD(buf->traceBufHeader.lastTicks));
    if ( !buf->traceBufHeader.pos )
    {
      buf->arr[0] = 65;
      ++buf->traceBufHeader.pos;
      runtime___ptr_traceBuf__varint(buf, SHIDWORD(v3));
      runtime___ptr_traceBuf__varint(buf, __PAIR64__(v10, v7));
      v5 = buf;
      v11 = 0;
      v8 = 0;
    }
    LODWORD(v5->traceBufHeader.lastTicks) = v7;
    HIDWORD(v5->traceBufHeader.lastTicks) = v10;
    if ( skip < 0 )
      len = args.len;
    else
      len = LOBYTE(args.len) + 1;
    if ( (unsigned __int8)len > 3u )
      len = 3;
    v13 = len;
    v14 = (len << 6) | ev;
    pos = v5->traceBufHeader.pos;
    if ( pos >= 0xFDF0 )
      runtime_panicindex();
    v32 = v5->traceBufHeader.pos;
    v5->arr[pos] = v14;
    ++v5->traceBufHeader.pos;
    if ( v13 == 3 )
    {
      tickDiff_hi = v11;
      tickDiff_lo = v8;
      runtime___ptr_traceBuf__varint(v5, 0LL);
      v5 = buf;
      v20 = buf->traceBufHeader.pos;
      if ( (unsigned int)(v20 - 1) >= 0xFDF0 )
        runtime_panicindex();
      v16 = (char *)&buf->traceBufHeader.stk[127] + v20 + 3;
      v8 = tickDiff_lo;
      v11 = tickDiff_hi;
    }
    else
    {
      v16 = 0;
    }
    runtime___ptr_traceBuf__varint(v5, __PAIR64__(v11, v8));
    v17 = 0;
    array = args.array;
    while ( v17 < args.len )
    {
      v31 = v17;
      v34 = array;
      runtime___ptr_traceBuf__varint(buf, *array);
      array = v34 + 1;
      v17 = v31 + 1;
    }
    if ( skip )
    {
      if ( skip > 0 )
      {
        v25.array = buf->traceBufHeader.stk;
        *(_QWORD *)&v25.len = 0x8000000080LL;
        HIDWORD(v28) = runtime_traceStackID((runtime_m *)v3, v25, skip);
        runtime___ptr_traceBuf__varint(buf, v28);
      }
    }
    else
    {
      runtime___ptr_traceBuf__varint(buf, 0LL);
    }
    v19 = buf->traceBufHeader.pos - v32;
    if ( v19 > 52 )
    {
      v23.str = (uint8 *)"invalid length of trace event";
      v23.len = 29;
      runtime_throw(v23);
      BUG();
    }
    if ( v16 )
      *v16 = v19 - 2;
    runtime_traceReleaseBuffer(SHIDWORD(v3));
  }
  else
  {
    runtime_traceReleaseBuffer(SHIDWORD(v22));
  }
}
// 80842A9: variable 'v21' is possibly undefined
// 80842A9: variable 'v24' is possibly undefined
// 80842A9: variable 'v26' is possibly undefined
// 80842CC: variable 'v22' is possibly undefined
// 80842D6: variable 'v27' is possibly undefined
// 808447B: variable 'v28' is possibly undefined

//----- (080845B0) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
uint64 __golang runtime_traceStackID(runtime_m *mp, __uintptr buf, __int32 skip)
{
  runtime_g *curg; // ecx
  __int32 v4; // eax
  __uintptr pcs; // [esp+4h] [ebp-18h]
  runtime_g *gp; // [esp+18h] [ebp-4h]

  curg = mp->curg;
  gp = curg;
  if ( curg == *(runtime_g **)(__readgsdword(0) - 4) )
  {
    v4 = runtime_callers(skip + 1, buf);
    curg = gp;
  }
  else if ( curg )
  {
    v4 = runtime_gcallers(curg, skip, buf);
    curg = gp;
  }
  else
  {
    v4 = 0;
  }
  if ( v4 > 0 )
    --v4;
  if ( v4 > 0 && LODWORD(curg->goid) == 1 && HIDWORD(curg->goid) == 0 )
    --v4;
  if ( (unsigned int)v4 > buf.cap )
    runtime_panicslice();
  pcs.array = buf.array;
  *(_QWORD *)&pcs.len = __PAIR64__(buf.cap, v4);
  return runtime___ptr_traceStackTable__put(&runtime_trace.stackTab, pcs);
}
// 80845B0: variables would overlap: ^34.8 and ^34.12

//----- (080846D0) --------------------------------------------------------
void __golang runtime_traceAcquireBuffer(runtime_m *mp, int32 pid, runtime_traceBufPtr *bufp)
{
  int v3; // eax

  v3 = *(_DWORD *)(__readgsdword(0) - 4);
  ++*(_DWORD *)(*(_DWORD *)(v3 + 24) + 120);
  if ( !*(_DWORD *)(*(_DWORD *)(v3 + 24) + 92) )
    runtime_lock(&runtime_trace.bufLock);
}

//----- (08084760) --------------------------------------------------------
void __golang runtime_traceReleaseBuffer(int32 pid)
{
  int v1; // eax
  int v2; // ecx
  int v3; // edx

  if ( pid == -1 )
    runtime_unlock(&runtime_trace.bufLock);
  v1 = *(_DWORD *)(__readgsdword(0) - 4);
  v2 = *(_DWORD *)(v1 + 24);
  v3 = *(_DWORD *)(v2 + 120);
  *(_DWORD *)(v2 + 120) = v3 - 1;
  if ( v3 == 1 )
  {
    if ( *(_BYTE *)(v1 + 108) )
      *(_DWORD *)(v1 + 8) = -1314;
  }
}

//----- (080847D0) --------------------------------------------------------
runtime_traceBufPtr __golang runtime_traceFlush(runtime_traceBufPtr buf)
{
  bool v1; // al
  _DWORD *empty; // ecx
  bool v3; // zf
  string l; // [esp+0h] [ebp-14h]
  _DWORD *v5; // [esp+8h] [ebp-Ch]
  bool dolock; // [esp+Fh] [ebp-5h]
  runtime_traceBufPtr tp; // [esp+10h] [ebp-4h]

  if ( runtime_trace.lockOwner )
    v1 = runtime_trace.lockOwner != *(runtime_g **)(*(_DWORD *)(*(_DWORD *)(__readgsdword(0) - 4) + 24) + 84);
  else
    v1 = 1;
  dolock = v1;
  if ( v1 )
  {
    runtime_lock(&runtime_trace.lock);
    v1 = dolock;
  }
  if ( buf )
  {
    *(_DWORD *)buf = 0;
    if ( runtime_trace.fullHead )
      *(_DWORD *)runtime_trace.fullTail = buf;
    else
      runtime_trace.fullHead = buf;
    runtime_trace.fullTail = buf;
  }
  empty = (_DWORD *)runtime_trace.empty;
  if ( runtime_trace.empty )
  {
    runtime_trace.empty = *(_DWORD *)runtime_trace.empty;
    v3 = !v1;
  }
  else
  {
    v5 = runtime_sysAlloc(0x10000u, &runtime_memstats.other_sys);
    if ( !v5 )
    {
      l.str = (uint8 *)"trace: out of memory";
      l.len = 20;
      runtime_throw(l);
      BUG();
    }
    v3 = !dolock;
    empty = v5;
  }
  *empty = 0;
  empty[3] = 0;
  empty[1] = 0;
  empty[2] = 0;
  if ( !v3 )
  {
    tp = (runtime_traceBufPtr)empty;
    runtime_unlock(&runtime_trace.lock);
    return tp;
  }
  return (runtime_traceBufPtr)empty;
}

//----- (08084920) --------------------------------------------------------
void __golang runtime___ptr_traceBuf__varint(runtime_traceBuf *buf, uint64 v)
{
  unsigned int v2; // ebp
  int v3; // esi
  unsigned __int32 pos; // ecx
  unsigned int v5; // edx
  unsigned int v6; // ebx
  bool v7; // zf
  unsigned int v8; // ebx
  unsigned int v9; // et0
  unsigned int v10; // et1
  int v11; // ebx
  int v12; // ebp
  unsigned int v13; // ebx
  int v14; // et1

  pos = buf->traceBufHeader.pos;
  v6 = HIDWORD(v);
  v5 = v;
  while ( 1 )
  {
    v7 = v6 == 0;
    v9 = v6;
    v8 = v2;
    LOBYTE(v8) = v7;
    v10 = v8;
    v11 = v3;
    LOBYTE(v11) = v5 >= 0x80;
    v12 = v11 & v10;
    LOBYTE(v11) = v9 != 0;
    v14 = v11;
    v13 = v9;
    v3 = v12 | v14;
    if ( !((unsigned __int8)v12 | (unsigned __int8)v14) )
      break;
    if ( pos >= 0xFDF0 )
      runtime_panicindex();
    buf->arr[pos] = v5 | 0x80;
    v2 = v5 >> 7;
    v5 = (v5 >> 7) | (v13 << 25);
    v6 = v13 >> 7;
    ++pos;
  }
  if ( pos >= 0xFDF0 )
    runtime_panicindex();
  buf->arr[pos] = v5;
  buf->traceBufHeader.pos = pos + 1;
}
// 8084963: variable 'v2' is possibly undefined
// 8084970: variable 'v3' is possibly undefined

//----- (080849C0) --------------------------------------------------------
uint32 __golang runtime___ptr_traceStackTable__put(runtime_traceStackTable_0 *tab, __uintptr pcs)
{
  runtime_traceStack *v2; // eax
  uintptr *array; // ebp
  __int32 i; // esi
  uint32 v5; // [esp+14h] [ebp-10h]
  uint32 v6; // [esp+14h] [ebp-10h]
  uintptr hash; // [esp+1Ch] [ebp-8h]
  runtime_traceStack *ts; // [esp+20h] [ebp-4h]

  if ( !pcs.len )
    return 0;
  hash = runtime_memhash(pcs.array, 0, 4 * pcs.len);
  v5 = runtime___ptr_traceStackTable__find(tab, pcs, hash);
  if ( v5 )
    return v5;
  runtime_lock(&tab->lock);
  v6 = runtime___ptr_traceStackTable__find(tab, pcs, hash);
  if ( v6 )
  {
    runtime_unlock(&tab->lock);
    return v6;
  }
  else
  {
    ++tab->seq;
    v2 = runtime___ptr_traceStackTable__newStack(tab, pcs.len);
    v2->hash = hash;
    v2->id = tab->seq;
    v2->n = pcs.len;
    if ( pcs.len > 0x80u )
      runtime_panicslice();
    array = pcs.array;
    for ( i = 0; i < pcs.len; ++i )
    {
      if ( (unsigned int)i >= pcs.len )
        runtime_panicindex();
      *(_DWORD *)&v2->gap10[4 * i] = *array++;
    }
    ts = v2;
    v2->link = tab->tab[hash & 0x1FFF];
    runtime_atomicstorep(&tab->tab[hash & 0x1FFF], v2);
    runtime_unlock(&tab->lock);
    return ts->id;
  }
}

//----- (08084B70) --------------------------------------------------------
uint32 __golang runtime___ptr_traceStackTable__find(runtime_traceStackTable_0 *tab, __uintptr pcs, uintptr hash)
{
  uintptr v3; // edx
  runtime_traceStack *link; // eax
  _DWORD *v5; // esi
  __int32 i; // edi
  unsigned int n; // ebp
  runtime_traceStack *ts; // [esp+0h] [ebp-4h]

  v3 = hash;
  link = (runtime_traceStack *)tab->tab[hash & 0x1FFF];
  while ( 1 )
  {
    if ( !link )
      return 0;
    ts = link;
    if ( v3 == link->hash )
    {
      n = link->n;
      if ( n == pcs.len )
        break;
    }
LABEL_6:
    link = (runtime_traceStack *)ts->link;
    v3 = hash;
  }
  v5 = link->gap10;
  if ( n > 0x80 )
    runtime_panicslice();
  for ( i = 0; i < (int)n; ++i )
  {
    if ( (unsigned int)i >= pcs.len )
      runtime_panicindex();
    if ( *v5 != pcs.array[i] )
      goto LABEL_6;
    ++v5;
    link = ts;
  }
  return link->id;
}

//----- (08084C30) --------------------------------------------------------
runtime_traceStack *__golang runtime___ptr_traceStackTable__newStack(runtime_traceStackTable_0 *tab, __int32 n)
{
  return (runtime_traceStack *)runtime___ptr_traceAlloc__alloc(&tab->mem, 4 * n + 20);
}

//----- (08084C80) --------------------------------------------------------
void *__golang runtime___ptr_traceAlloc__alloc(runtime_traceAlloc_0 *a, uintptr n)
{
  uintptr v2; // edx
  runtime_traceAlloc_0 *v3; // ecx
  runtime_traceAllocBlockPtr head; // eax
  unsigned int off; // edx
  string v6; // [esp+0h] [ebp-Ch]
  string v7; // [esp+0h] [ebp-Ch]
  _DWORD *v8; // [esp+8h] [ebp-4h]
  uintptr na; // [esp+14h] [ebp+8h]

  v2 = (n + 3) & 0xFFFFFFFC;
  na = v2;
  if ( a->head && v2 + a->off <= 0xFFFC )
  {
    v3 = a;
  }
  else
  {
    if ( v2 > 0xFFFC )
    {
      v7.str = (uint8 *)"trace: alloc too large";
      v7.len = 22;
      runtime_throw(v7);
      BUG();
    }
    v8 = runtime_sysAlloc(0x10000u, &runtime_memstats.other_sys);
    if ( !v8 )
    {
      v6.str = (uint8 *)"trace: out of memory";
      v6.len = 20;
      runtime_throw(v6);
      BUG();
    }
    v3 = a;
    *v8 = a->head;
    a->head = (runtime_traceAllocBlockPtr)v8;
    a->off = 0;
  }
  head = v3->head;
  off = v3->off;
  if ( off >= 0xFFFC )
    runtime_panicindex();
  v3->off = off + na;
  return (void *)(head + off + 4);
}

//----- (08084D70) --------------------------------------------------------
void __golang runtime_traceGomaxprocs(int32 procs)
{
  __uint64 args; // [esp+8h] [ebp-14h]
  int v2[2]; // [esp+14h] [ebp-8h] BYREF

  v2[0] = procs;
  v2[1] = procs >> 31;
  args.array = (uint64 *)v2;
  *(_QWORD *)&args.len = 0x100000001LL;
  runtime_traceEvent(4u, 1, args);
}

//----- (08084DE0) --------------------------------------------------------
void __golang runtime_traceProcStart()
{
  __uint64 args; // [esp+8h] [ebp-14h]
  int v1; // [esp+14h] [ebp-8h] BYREF
  int v2; // [esp+18h] [ebp-4h]

  v1 = 0;
  v2 = 0;
  v1 = *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(__readgsdword(0) - 4) + 24) + 100);
  v2 = v1 >> 31;
  args.array = (uint64 *)&v1;
  *(_QWORD *)&args.len = 0x100000001LL;
  runtime_traceEvent(5u, -1, args);
}

//----- (08084E60) --------------------------------------------------------
void __golang runtime_traceProcStop(runtime_p *pp)
{
  int v1; // eax
  int v2; // eax
  int32 locks; // edx
  __uint64 args; // [esp+8h] [ebp-14h] BYREF
  runtime_puintptr oldp; // [esp+14h] [ebp-8h]
  runtime_m *mp; // [esp+18h] [ebp-4h]

  v1 = *(_DWORD *)(__readgsdword(0) - 4);
  ++*(_DWORD *)(*(_DWORD *)(v1 + 24) + 120);
  mp = *(runtime_m **)(v1 + 24);
  oldp = mp->p;
  mp->p = (runtime_puintptr)pp;
  memset(&args, 0, sizeof(args));
  runtime_traceEvent(6u, -1, args);
  mp->p = oldp;
  v2 = *(_DWORD *)(__readgsdword(0) - 4);
  locks = mp->locks;
  mp->locks = locks - 1;
  if ( locks == 1 )
  {
    if ( *(_BYTE *)(v2 + 108) )
      *(_DWORD *)(v2 + 8) = -1314;
  }
}

//----- (08084F20) --------------------------------------------------------
void __golang runtime_traceGCStart()
{
  __uint64 args; // [esp+8h] [ebp-14h]
  uint64 seqGC; // [esp+14h] [ebp-8h] BYREF

  seqGC = runtime_trace.seqGC;
  args.array = &seqGC;
  *(_QWORD *)&args.len = 0x100000001LL;
  runtime_traceEvent(7u, 3, args);
  ++runtime_trace.seqGC;
}

//----- (08084FB0) --------------------------------------------------------
void __golang runtime_traceGCDone()
{
  __uint64 args; // [esp+8h] [ebp-Ch] BYREF

  memset(&args, 0, sizeof(args));
  runtime_traceEvent(8u, -1, args);
}

//----- (08085000) --------------------------------------------------------
void __golang runtime_traceGCScanStart()
{
  __uint64 args; // [esp+8h] [ebp-Ch] BYREF

  memset(&args, 0, sizeof(args));
  runtime_traceEvent(9u, -1, args);
}

//----- (08085050) --------------------------------------------------------
void __golang runtime_traceGCScanDone()
{
  __uint64 args; // [esp+8h] [ebp-Ch] BYREF

  memset(&args, 0, sizeof(args));
  runtime_traceEvent(0xAu, -1, args);
}

//----- (080850A0) --------------------------------------------------------
void __golang runtime_traceGCSweepStart()
{
  int v0; // ecx
  string s; // [esp+0h] [ebp-8h]

  v0 = *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(__readgsdword(0) - 4) + 24) + 92);
  if ( *(_BYTE *)(v0 + 2348) )
  {
    s.str = (uint8 *)"double traceGCSweepStart";
    s.len = 24;
    runtime_throw(s);
    BUG();
  }
  *(_BYTE *)(v0 + 2348) = 1;
  *(_DWORD *)(v0 + 2352) = 0;
  *(_DWORD *)(v0 + 2356) = 0;
}

//----- (08085120) --------------------------------------------------------
void __golang runtime_traceGCSweepSpan(uintptr bytesSwept)
{
  int v1; // ecx
  __uint64 args; // [esp+8h] [ebp-10h] BYREF
  int v3; // [esp+14h] [ebp-4h]

  v1 = *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(__readgsdword(0) - 4) + 24) + 92);
  if ( *(_BYTE *)(v1 + 2348) )
  {
    if ( !*(_DWORD *)(v1 + 2352) )
    {
      v3 = v1;
      memset(&args, 0, sizeof(args));
      runtime_traceEvent(0xBu, 1, args);
      v1 = v3;
    }
    *(_DWORD *)(v1 + 2352) += bytesSwept;
  }
}

//----- (080851C0) --------------------------------------------------------
void __golang runtime_traceGCSweepDone()
{
  int v0; // ecx
  string ev; // [esp+0h] [ebp-28h]
  __uint64 args; // [esp+8h] [ebp-20h]
  __uint64 v3; // [esp+14h] [ebp-14h] BYREF
  int v4; // [esp+20h] [ebp-8h]
  int v5; // [esp+24h] [ebp-4h]

  v0 = *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(__readgsdword(0) - 4) + 24) + 92);
  if ( !*(_BYTE *)(v0 + 2348) )
  {
    ev.str = (uint8 *)"missing traceGCSweepStart";
    ev.len = 25;
    runtime_throw(ev);
    BUG();
  }
  if ( *(_DWORD *)(v0 + 2352) )
  {
    v5 = v0;
    memset(&v3, 0, sizeof(v3));
    v4 = 0;
    v3.array = *(uint64 **)(v0 + 2352);
    v3.len = 0;
    v3.cap = *(_DWORD *)(v0 + 2356);
    v4 = 0;
    args.array = (uint64 *)&v3;
    *(_QWORD *)&args.len = 0x200000002LL;
    runtime_traceEvent(0xCu, -1, args);
    v0 = v5;
  }
  *(_BYTE *)(v0 + 2348) = 0;
}

//----- (080852B0) --------------------------------------------------------
void __golang runtime_traceGCMarkAssistStart()
{
  __uint64 args; // [esp+8h] [ebp-Ch] BYREF

  memset(&args, 0, sizeof(args));
  runtime_traceEvent(0x2Bu, 1, args);
}

//----- (08085300) --------------------------------------------------------
void __golang runtime_traceGCMarkAssistDone()
{
  __uint64 args; // [esp+8h] [ebp-Ch] BYREF

  memset(&args, 0, sizeof(args));
  runtime_traceEvent(0x2Cu, -1, args);
}

//----- (08085350) --------------------------------------------------------
void __golang runtime_traceGoCreate(runtime_g *newg, uintptr pc)
{
  __int32 goid_high; // ecx
  __uintptr pcs; // [esp+4h] [ebp-20h]
  __uintptr pcs_4; // [esp+8h] [ebp-1Ch]
  __int32 v5; // [esp+10h] [ebp-14h]
  __uint64 args; // [esp+14h] [ebp-10h] BYREF
  int v7; // [esp+20h] [ebp-4h]

  newg->traceseq = 0LL;
  newg->tracelastp = *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(__readgsdword(0) - 4) + 24) + 92);
  pcs.array = (uintptr *)runtime_newobject((runtime__type_0 *)&stru_80CBDA0);
  *pcs.array = pc + 1;
  *(_QWORD *)&pcs.len = 0x100000001LL;
  v5 = runtime___ptr_traceStackTable__put(&runtime_trace.stackTab, pcs);
  memset(&args, 0, sizeof(args));
  v7 = 0;
  goid_high = HIDWORD(newg->goid);
  args.array = (uint64 *)newg->goid;
  args.len = goid_high;
  args.cap = v5;
  v7 = 0;
  pcs_4.array = (uintptr *)&args;
  *(_QWORD *)&pcs_4.len = 0x200000002LL;
  runtime_traceEvent(0xDu, 2, (__uint64)pcs_4);
}

//----- (08085450) --------------------------------------------------------
void __golang runtime_traceGoStart()
{
  runtime_g *v0; // ecx
  int traceseq; // ebx
  runtime_puintptr p; // edx
  int traceseq_high; // ebp
  runtime_puintptr v4; // ebx
  __int32 goid_high; // ebp
  int v6; // ecx
  unsigned int v7; // ecx
  uint64 *v8; // eax
  int v9; // ecx
  int v10; // eax
  __int32 v11; // eax
  int v12; // eax
  int v13; // eax
  __uint64 args; // [esp+8h] [ebp-40h]
  __uint64 argsa; // [esp+8h] [ebp-40h]
  __uint64 argsb; // [esp+8h] [ebp-40h]
  __uint64 v17; // [esp+14h] [ebp-34h] BYREF
  int v18; // [esp+20h] [ebp-28h]
  int v19; // [esp+24h] [ebp-24h]
  int v20; // [esp+28h] [ebp-20h]
  __uint64 v21; // [esp+2Ch] [ebp-1Ch] BYREF
  int v22; // [esp+38h] [ebp-10h]
  int v23; // [esp+3Ch] [ebp-Ch]
  int v24; // [esp+40h] [ebp-8h]
  runtime_g *_g_; // [esp+44h] [ebp-4h]

  v0 = *(runtime_g **)(*(_DWORD *)(*(_DWORD *)(__readgsdword(0) - 4) + 24) + 84);
  traceseq = v0->traceseq;
  p = v0->m->p;
  traceseq_high = HIDWORD(v0->traceseq);
  LODWORD(v0->traceseq) = traceseq + 1;
  HIDWORD(v0->traceseq) = __CFADD__(traceseq, 1) + traceseq_high;
  v4 = p;
  if ( v0 == *(runtime_g **)(p + 2376) )
  {
    _g_ = v0;
    ((void (*)(void))loc_808FD8A)();
    goid_high = HIDWORD(_g_->goid);
    v21.array = (uint64 *)_g_->goid;
    v21.len = goid_high;
    v6 = HIDWORD(_g_->traceseq);
    v21.cap = _g_->traceseq;
    v22 = v6;
    v7 = *(_DWORD *)(v4 + 2380);
    if ( v7 >= 3 )
      runtime_panicindex();
    v8 = &runtime_trace.markWorkerLabels[v7];
    v9 = *(_DWORD *)v8;
    v10 = *((_DWORD *)v8 + 1);
    v23 = v9;
    v24 = v10;
    args.array = (uint64 *)&v21;
    *(_QWORD *)&args.len = 0x300000003LL;
    runtime_traceEvent(0x29u, -1, args);
  }
  else if ( v0->tracelastp == p )
  {
    v17.array = 0;
    v17.len = 0;
    v11 = HIDWORD(v0->goid);
    v17.array = (uint64 *)v0->goid;
    v17.len = v11;
    argsa.array = (uint64 *)&v17;
    *(_QWORD *)&argsa.len = 0x100000001LL;
    runtime_traceEvent(0x26u, -1, argsa);
  }
  else
  {
    v0->tracelastp = p;
    v17.cap = 0;
    v18 = 0;
    v19 = 0;
    v20 = 0;
    v12 = HIDWORD(v0->goid);
    v17.cap = v0->goid;
    v18 = v12;
    v13 = HIDWORD(v0->traceseq);
    v19 = v0->traceseq;
    v20 = v13;
    argsb.array = (uint64 *)&v17.cap;
    *(_QWORD *)&argsb.len = 0x200000002LL;
    runtime_traceEvent(0xEu, -1, argsb);
  }
}

//----- (08085610) --------------------------------------------------------
void __golang runtime_traceGoEnd()
{
  __uint64 args; // [esp+8h] [ebp-Ch] BYREF

  memset(&args, 0, sizeof(args));
  runtime_traceEvent(0xFu, -1, args);
}

//----- (08085660) --------------------------------------------------------
void __golang runtime_traceGoSched()
{
  int v0; // eax
  __uint64 args; // [esp+8h] [ebp-Ch] BYREF

  v0 = *(_DWORD *)(__readgsdword(0) - 4);
  *(_DWORD *)(v0 + 132) = *(_DWORD *)(*(_DWORD *)(v0 + 24) + 92);
  memset(&args, 0, sizeof(args));
  runtime_traceEvent(0x11u, 1, args);
}

//----- (080856D0) --------------------------------------------------------
void __golang runtime_traceGoPreempt()
{
  int v0; // eax
  __uint64 args; // [esp+8h] [ebp-Ch] BYREF

  v0 = *(_DWORD *)(__readgsdword(0) - 4);
  *(_DWORD *)(v0 + 132) = *(_DWORD *)(*(_DWORD *)(v0 + 24) + 92);
  memset(&args, 0, sizeof(args));
  runtime_traceEvent(0x12u, 1, args);
}

//----- (08085740) --------------------------------------------------------
void __golang runtime_traceGoPark(uint8 traceEv, __int32 skip)
{
  uint8 v2; // al
  __uint64 args; // [esp+8h] [ebp-Ch] BYREF

  v2 = traceEv;
  if ( (traceEv & 0x80u) != 0 )
  {
    memset(&args, 0, sizeof(args));
    runtime_traceEvent(0x24u, -1, args);
    v2 = traceEv;
  }
  memset(&args, 0, sizeof(args));
  runtime_traceEvent(v2 & 0x7F, skip, args);
}

//----- (080857D0) --------------------------------------------------------
void __golang runtime_traceGoUnpark(runtime_g *gp, __int32 skip)
{
  int traceseq; // edx
  runtime_puintptr v3; // eax
  int traceseq_high; // ebx
  __int32 goid_high; // eax
  int v6; // eax
  int v7; // eax
  __uint64 args; // [esp+8h] [ebp-24h]
  __uint64 argsa; // [esp+8h] [ebp-24h]
  __uint64 v10; // [esp+14h] [ebp-18h] BYREF
  int v11; // [esp+20h] [ebp-Ch]
  int v12; // [esp+24h] [ebp-8h]
  int v13; // [esp+28h] [ebp-4h]

  traceseq = gp->traceseq;
  v3 = *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(__readgsdword(0) - 4) + 24) + 92);
  traceseq_high = HIDWORD(gp->traceseq);
  LODWORD(gp->traceseq) = traceseq + 1;
  HIDWORD(gp->traceseq) = __CFADD__(traceseq, 1) + traceseq_high;
  if ( gp->tracelastp == v3 )
  {
    v10.array = 0;
    v10.len = 0;
    goid_high = HIDWORD(gp->goid);
    v10.array = (uint64 *)gp->goid;
    v10.len = goid_high;
    args.array = (uint64 *)&v10;
    *(_QWORD *)&args.len = 0x100000001LL;
    runtime_traceEvent(0x27u, skip, args);
  }
  else
  {
    gp->tracelastp = v3;
    v10.cap = 0;
    v11 = 0;
    v12 = 0;
    v13 = 0;
    v6 = HIDWORD(gp->goid);
    v10.cap = gp->goid;
    v11 = v6;
    v7 = HIDWORD(gp->traceseq);
    v12 = gp->traceseq;
    v13 = v7;
    argsa.array = (uint64 *)&v10.cap;
    *(_QWORD *)&argsa.len = 0x200000002LL;
    runtime_traceEvent(0x15u, skip, argsa);
  }
}

//----- (080858F0) --------------------------------------------------------
void __golang runtime_traceGoSysCall()
{
  __uint64 args; // [esp+8h] [ebp-Ch] BYREF

  memset(&args, 0, sizeof(args));
  runtime_traceEvent(0x1Cu, 1, args);
}

//----- (08085940) --------------------------------------------------------
void __golang runtime_traceGoSysExit(int64 ts)
{
  unsigned int v1; // eax
  unsigned int v2; // ecx
  _DWORD *v3; // edx
  int v4; // ebx
  int v5; // ebp
  unsigned int v6; // ebx
  int v7; // edx
  __int32 v8; // ecx
  int v9; // ecx
  __uint64 args; // [esp+8h] [ebp-24h]
  __uint64 v11; // [esp+14h] [ebp-18h] BYREF
  int v12; // [esp+20h] [ebp-Ch]
  unsigned int v13; // [esp+24h] [ebp-8h]
  unsigned int v14; // [esp+28h] [ebp-4h]
  unsigned int tsa; // [esp+30h] [ebp+4h]

  if ( (_DWORD)ts != 0 || HIDWORD(ts) != 0 )
  {
    if ( SHIDWORD(ts) < SHIDWORD(runtime_trace.ticksStart)
      || (unsigned int)ts < LODWORD(runtime_trace.ticksStart) && HIDWORD(ts) == HIDWORD(runtime_trace.ticksStart) )
    {
      v1 = 0;
      v2 = 0;
    }
    else
    {
      v1 = HIDWORD(ts);
      v2 = ts;
    }
  }
  else
  {
    v1 = HIDWORD(ts);
    v2 = ts;
  }
  tsa = v2;
  v3 = *(_DWORD **)(*(_DWORD *)(*(_DWORD *)(__readgsdword(0) - 4) + 24) + 84);
  v4 = v3[31];
  v5 = v3[32];
  v3[31] = v4 + 1;
  v3[32] = __CFADD__(v4, 1) + v5;
  v3[33] = *(_DWORD *)(v3[6] + 92);
  v6 = v1;
  ((void (*)(void))loc_808FD8A)();
  v8 = *(_DWORD *)(v7 + 84);
  v11.array = *(uint64 **)(v7 + 80);
  v11.len = v8;
  v9 = *(_DWORD *)(v7 + 128);
  v11.cap = *(_DWORD *)(v7 + 124);
  v12 = v9;
  v13 = (v6 << 26) | (tsa >> 6);
  v14 = v6 >> 6;
  args.array = (uint64 *)&v11;
  *(_QWORD *)&args.len = 0x300000003LL;
  runtime_traceEvent(0x1Du, -1, args);
}
// 80859F6: variable 'v7' is possibly undefined

//----- (08085A80) --------------------------------------------------------
void __golang runtime_traceGoSysBlock(runtime_p *pp)
{
  int v1; // eax
  int v2; // eax
  int32 locks; // edx
  __uint64 args; // [esp+8h] [ebp-14h] BYREF
  runtime_puintptr oldp; // [esp+14h] [ebp-8h]
  runtime_m *mp; // [esp+18h] [ebp-4h]

  v1 = *(_DWORD *)(__readgsdword(0) - 4);
  ++*(_DWORD *)(*(_DWORD *)(v1 + 24) + 120);
  mp = *(runtime_m **)(v1 + 24);
  oldp = mp->p;
  mp->p = (runtime_puintptr)pp;
  memset(&args, 0, sizeof(args));
  runtime_traceEvent(0x1Eu, -1, args);
  mp->p = oldp;
  v2 = *(_DWORD *)(__readgsdword(0) - 4);
  locks = mp->locks;
  mp->locks = locks - 1;
  if ( locks == 1 )
  {
    if ( *(_BYTE *)(v2 + 108) )
      *(_DWORD *)(v2 + 8) = -1314;
  }
}

//----- (08085B40) --------------------------------------------------------
void __golang runtime_traceHeapAlloc()
{
  __uint64 args; // [esp+8h] [ebp-14h]
  uint64 heap_live; // [esp+14h] [ebp-8h] BYREF

  heap_live = runtime_memstats.heap_live;
  args.array = &heap_live;
  *(_QWORD *)&args.len = 0x100000001LL;
  runtime_traceEvent(0x21u, -1, args);
}

//----- (08085BB0) --------------------------------------------------------
void __golang runtime_traceNextGC()
{
  __uint64 args; // [esp+8h] [ebp-1Ch]
  __uint64 argsa; // [esp+8h] [ebp-1Ch]
  uint64 next_gc; // [esp+14h] [ebp-10h] BYREF
  uint64 v3; // [esp+1Ch] [ebp-8h] BYREF

  if ( LODWORD(runtime_memstats.next_gc) == -1 && HIDWORD(runtime_memstats.next_gc) == -1 )
  {
    v3 = runtime_statictmp_35[0];
    args.array = &v3;
    *(_QWORD *)&args.len = 0x100000001LL;
    runtime_traceEvent(0x22u, -1, args);
  }
  else
  {
    next_gc = runtime_memstats.next_gc;
    argsa.array = &next_gc;
    *(_QWORD *)&argsa.len = 0x100000001LL;
    runtime_traceEvent(0x22u, -1, argsa);
  }
}

//----- (08085C90) --------------------------------------------------------
void __golang runtime_tracebackinit()
{
  interface_{} f_15; // [esp+80h] [ebp-8h] BYREF

  while ( (unsigned int)&f_15 <= *(_DWORD *)(*(_DWORD *)(__readgsdword(0) - 4) + 8) )
    runtime_morestack_noctxt();
  f_15._type = (runtime__type_0 *)&unk_80CAAC0;
  f_15.data = &off_80E7C14;
  runtime_goexitPC = (uintptr)runtime_goexit;
  runtime_jmpdeferPC = (uintptr)runtime_jmpdefer;
  runtime_mcallPC = (uintptr)runtime_mcall;
  runtime_morestackPC = (uintptr)runtime_morestack;
  runtime_mstartPC = (uintptr)runtime_mstart;
  runtime_rt0_goPC = (uintptr)runtime_rt0_go;
  runtime_sigpanicPC = (uintptr)runtime_sigpanic;
  runtime_runfinqPC = 134583104;
  runtime_bgsweepPC = 134620208;
  runtime_forcegchelperPC = 134665440;
  runtime_timerprocPC = (uintptr)runtime_timerproc;
  runtime_gcBgMarkWorkerPC = 134598432;
  runtime_systemstack_switchPC = (uintptr)runtime_systemstack_switch;
  runtime_systemstackPC = (uintptr)runtime_systemstack;
  runtime_cgocallback_gofuncPC = (uintptr)runtime_cgocallback_gofunc;
  runtime_skipPC = (uintptr)runtime_skipPleaseUseCallersFrames;
  runtime_gogoPC = (uintptr)runtime_gogo;
}
// 80E7C14: using guessed type void (__golang __noreturn *off_80E7C14)();
// 80E7C84: using guessed type int (__golang *off_80E7C84)();
// 80E7CD0: using guessed type int (__golang *off_80E7CD0[4])();

//----- (08085F30) --------------------------------------------------------
void __golang runtime_tracebackdefers(runtime_g *gp, func(_runtime_stkframe__unsafe_Pointer)_bool callback, void *v)
{
  runtime__defer *i; // ecx
  uintptr *p_fn; // eax
  uintptr v5; // ebx
  string pc; // [esp+0h] [ebp-54h]
  string pca; // [esp+0h] [ebp-54h]
  string pcb; // [esp+0h] [ebp-54h]
  runtime_funcInfo_0 f; // [esp+4h] [ebp-50h]
  uintptr v10; // [esp+14h] [ebp-40h]
  runtime_bitvector_0 *v11; // [esp+18h] [ebp-3Ch]
  uintptr v12; // [esp+1Ch] [ebp-38h]
  runtime_funcval *ctxt; // [esp+20h] [ebp-34h]
  runtime__defer *v14; // [esp+24h] [ebp-30h]
  runtime_stkframe_0 frame; // [esp+28h] [ebp-2Ch] BYREF

  ((void (*)(void))loc_808FD85)();
  for ( i = gp->_defer; i; i = v14->link )
  {
    v14 = i;
    p_fn = &i->fn->fn;
    if ( p_fn )
    {
      ctxt = i->fn;
      frame.pc = *p_fn;
      f = runtime_findfunc(frame.pc);
      if ( !f._func )
      {
        v12 = frame.pc;
        runtime_printlock();
        pc.str = (uint8 *)"runtime: unknown pc in defer ";
        pc.len = 29;
        runtime_printstring(pc);
        runtime_printhex(v12);
        pca.str = (uint8 *)"\n";
        pca.len = 1;
        runtime_printstring(pca);
        runtime_printunlock();
        pcb.str = (uint8 *)"unknown pc";
        pcb.len = 10;
        runtime_throw(pcb);
        BUG();
      }
      frame.fn = f;
      v5 = v14->siz ? (uintptr)&v14[1] : 0;
      frame.argp = v5;
      runtime_getArgInfo(&frame, f, 1, ctxt, v10, v11);
      frame.arglen = v10;
      frame.argmap = v11;
    }
    else
    {
      memset(&frame, 0, 12);
      memset(&frame.argp, 0, 12);
    }
    frame.continpc = frame.pc;
    if ( !(*(unsigned __int8 (__golang **)(runtime_stkframe_0 *, void *))callback)(&frame, v) )
      break;
  }
}
// 8086027: variable 'v10' is possibly undefined
// 8086027: variable 'v11' is possibly undefined

//----- (080860D0) --------------------------------------------------------
__int32 __golang runtime_gentraceback(
        uintptr pc0,
        uintptr sp0,
        uintptr lr0,
        runtime_g *gp,
        __int32 skip,
        uintptr *pcbuf,
        __int32 max,
        func(_runtime_stkframe__unsafe_Pointer)_bool callback,
        void *v,
        uint flags)
{
  runtime_g *v10; // edx
  uintptr syscallpc; // ebx
  uintptr *v12; // edx
  __int32 len; // ebx
  uintptr *array; // esi
  runtime__defer *j; // edi
  __int32 v16; // eax
  bool v17; // cl
  uint8 *str; // edx
  __int32 v19; // ebp
  __int32 v20; // esi
  runtime__defer *k; // edi
  uintptr v22; // ecx
  bool v23; // zf
  uintptr *v24; // ecx
  bool v25; // zf
  __int32 v26; // ebx
  int v27; // eax
  __int32 v28; // edi
  __int32 v29; // eax
  __int32 v30; // esi
  uintptr v31; // ebp
  uintptr entry; // eax
  bool v33; // al
  runtime_moduledata_0 *datap; // eax
  runtime__func *v35; // ebx
  func(_runtime_stkframe__unsafe_Pointer)_bool v36; // eax
  bool v37; // si
  runtime__defer *v38; // eax
  unsigned int v39; // ecx
  bool v40; // zf
  __int32 v41; // edx
  runtime__defer *ii; // eax
  uintptr stktopsp; // ebx
  runtime__func *func; // ebp
  char v45; // di
  uintptr v46; // esi
  uint8 *v47; // eax
  __int32 v48; // ecx
  int32 v49; // edx
  int v50; // eax
  uint8 *v51; // ecx
  uintptr argp; // eax
  uintptr v53; // ecx
  runtime_m *m; // edx
  __int32 v55; // eax
  unsigned int v56; // eax
  uint8 *v57; // edx
  int32 v58; // ebx
  uintptr v59; // esi
  int v60; // eax
  int v61; // edx
  int v62; // ebx
  char *v63; // ebx
  uintptr sp; // eax
  runtime_g *curg; // edi
  runtime_g *v66; // edx
  uint8 *v67; // ebx
  __int32 v68; // edx
  uint8 *v69; // edi
  uint8 *v70; // edi
  uint8 *v71; // esi
  uint8 *v72; // eax
  string v73; // kr10_8
  uintptr pc; // [esp+0h] [ebp-1C0h]
  uintptr pca; // [esp+0h] [ebp-1C0h]
  string pcb; // [esp+0h] [ebp-1C0h]
  string pcc; // [esp+0h] [ebp-1C0h]
  string pcd; // [esp+0h] [ebp-1C0h]
  string pce; // [esp+0h] [ebp-1C0h]
  string pcf; // [esp+0h] [ebp-1C0h]
  string pcg; // [esp+0h] [ebp-1C0h]
  string pch; // [esp+0h] [ebp-1C0h]
  string pci; // [esp+0h] [ebp-1C0h]
  string pck; // [esp+0h] [ebp-1C0h]
  string pcl; // [esp+0h] [ebp-1C0h]
  string pcm; // [esp+0h] [ebp-1C0h]
  string pcn; // [esp+0h] [ebp-1C0h]
  string pco; // [esp+0h] [ebp-1C0h]
  string pcp; // [esp+0h] [ebp-1C0h]
  string pcr; // [esp+0h] [ebp-1C0h]
  string pcs; // [esp+0h] [ebp-1C0h]
  string pct; // [esp+0h] [ebp-1C0h]
  string pcu; // [esp+0h] [ebp-1C0h]
  string pcq; // [esp+0h] [ebp-1C0h]
  string pcv; // [esp+0h] [ebp-1C0h]
  string pcw; // [esp+0h] [ebp-1C0h]
  string pcx; // [esp+0h] [ebp-1C0h]
  string pcy; // [esp+0h] [ebp-1C0h]
  string pcz; // [esp+0h] [ebp-1C0h]
  string pcba; // [esp+0h] [ebp-1C0h]
  string pcbb; // [esp+0h] [ebp-1C0h]
  string pcbc; // [esp+0h] [ebp-1C0h]
  string pcbd; // [esp+0h] [ebp-1C0h]
  string pcbe; // [esp+0h] [ebp-1C0h]
  string pcbf; // [esp+0h] [ebp-1C0h]
  string pcbg; // [esp+0h] [ebp-1C0h]
  string pcbh; // [esp+0h] [ebp-1C0h]
  string pcbi; // [esp+0h] [ebp-1C0h]
  string pcj; // [esp+0h] [ebp-1C0h]
  string pcbj; // [esp+0h] [ebp-1C0h]
  string pcbk; // [esp+0h] [ebp-1C0h]
  string pcbl; // [esp+0h] [ebp-1C0h]
  string pcbm; // [esp+0h] [ebp-1C0h]
  string pcbn; // [esp+0h] [ebp-1C0h]
  string pcbo; // [esp+0h] [ebp-1C0h]
  string pcbp; // [esp+0h] [ebp-1C0h]
  string pcbq; // [esp+0h] [ebp-1C0h]
  string pcbr; // [esp+0h] [ebp-1C0h]
  string pcbs; // [esp+0h] [ebp-1C0h]
  bool v120; // [esp+4h] [ebp-1BCh]
  runtime_funcInfo_0 v121; // [esp+4h] [ebp-1BCh]
  runtime_funcInfo_0 v122; // [esp+4h] [ebp-1BCh]
  long double v123; // [esp+8h] [ebp-1B8h]
  string v124; // [esp+Ch] [ebp-1B4h]
  int32 v125; // [esp+14h] [ebp-1ACh]
  runtime_bitvector_0 *v126; // [esp+18h] [ebp-1A8h]
  bool waspanic; // [esp+1Eh] [ebp-1A2h]
  bool printing; // [esp+1Fh] [ebp-1A1h]
  uintptr sp_0; // [esp+28h] [ebp-198h]
  __int32 nprint; // [esp+2Ch] [ebp-194h]
  __int32 name_len; // [esp+30h] [ebp-190h]
  int n; // [esp+38h] [ebp-188h]
  int32 line; // [esp+3Ch] [ebp-184h]
  int32 linea; // [esp+3Ch] [ebp-184h]
  int32 level; // [esp+40h] [ebp-180h]
  uintptr i; // [esp+44h] [ebp-17Ch]
  __int32 file_len; // [esp+48h] [ebp-178h]
  __int32 file_lena; // [esp+48h] [ebp-178h]
  __int32 cgoCtxt_len; // [esp+50h] [ebp-170h]
  __int32 cgoCtxt_lena; // [esp+50h] [ebp-170h]
  int v141; // [esp+54h] [ebp-16Ch]
  __int32 v142; // [esp+58h] [ebp-168h]
  uintptr v143; // [esp+60h] [ebp-160h]
  __int32 v144; // [esp+64h] [ebp-15Ch]
  uintptr v145; // [esp+74h] [ebp-14Ch]
  uintptr v146; // [esp+74h] [ebp-14Ch]
  uint64 v147; // [esp+74h] [ebp-14Ch]
  uintptr v148; // [esp+74h] [ebp-14Ch]
  uintptr hi; // [esp+74h] [ebp-14Ch]
  uintptr v150; // [esp+78h] [ebp-148h]
  uintptr v151; // [esp+78h] [ebp-148h]
  unsigned int v152; // [esp+78h] [ebp-148h]
  uintptr v153; // [esp+78h] [ebp-148h]
  uintptr v154; // [esp+78h] [ebp-148h]
  uintptr lo; // [esp+78h] [ebp-148h]
  uintptr lr; // [esp+78h] [ebp-148h]
  uintptr v157; // [esp+78h] [ebp-148h]
  int64 goid; // [esp+7Ch] [ebp-144h] BYREF
  unsigned int v159; // [esp+84h] [ebp-13Ch]
  uintptr v160; // [esp+88h] [ebp-138h]
  runtime_pcvalueCache_0 cache; // [esp+90h] [ebp-130h] BYREF
  uint8 *name_ptr; // [esp+150h] [ebp-70h]
  uint8 *name_ptr_0; // [esp+154h] [ebp-6Ch]
  runtime_g *g; // [esp+158h] [ebp-68h]
  uint8 *file_ptr; // [esp+15Ch] [ebp-64h]
  runtime_moduledata_0 *f_datap; // [esp+160h] [ebp-60h]
  runtime_moduledata_0 *f_datap_0; // [esp+164h] [ebp-5Ch]
  runtime__func *f__func; // [esp+168h] [ebp-58h]
  runtime__func *f__func_0; // [esp+16Ch] [ebp-54h]
  uintptr *cgoCtxt_ptr; // [esp+170h] [ebp-50h]
  runtime__defer *_defer; // [esp+174h] [ebp-4Ch]
  string s; // [esp+178h] [ebp-48h]
  uintptr v173; // [esp+180h] [ebp-40h]
  string v174; // [esp+184h] [ebp-3Ch]
  interface_{} f; // [esp+18Ch] [ebp-34h]
  runtime_stkframe_0 frame; // [esp+194h] [ebp-2Ch] BYREF
  __int32 skipa; // [esp+1D4h] [ebp+14h]

  while ( (unsigned int)&goid + 4 <= *(_DWORD *)(*(_DWORD *)(__readgsdword(0) - 4) + 8) )
    runtime_morestack_noctxt();
  f._type = 0;
  f.data = 0;
  if ( skip > 0 && callback )
  {
    pcbs.str = (uint8 *)"gentraceback callback cannot be used with non-zero skip";
    pcbs.len = 55;
    runtime_throw(pcbs);
    BUG();
  }
  if ( !runtime_goexitPC )
  {
    pcbr.str = (uint8 *)"gentraceback before goexitPC initialization";
    pcbr.len = 43;
    runtime_throw(pcbr);
    BUG();
  }
  v10 = *(runtime_g **)(__readgsdword(0) - 4);
  g = v10;
  if ( v10 == gp && v10 == v10->m->curg )
  {
    pcbq.str = (uint8 *)"gentraceback cannot trace user goroutine on its own stack";
    pcbq.len = 57;
    runtime_throw(pcbq);
    BUG();
  }
  runtime_gotraceback(pc, v120, SLOBYTE(v123));
  if ( pc0 == -1 )
  {
    if ( sp0 == -1 )
    {
      if ( gp->syscallsp )
        syscallpc = gp->syscallpc;
      else
        syscallpc = gp->sched.pc;
    }
    else
    {
      syscallpc = -1;
    }
  }
  else
  {
    syscallpc = pc0;
  }
  level = pca;
  ((void (*)(void))loc_808FD85)();
  frame.pc = syscallpc;
  frame.sp = (uintptr)v12;
  len = gp->cgoCtxt.len;
  array = gp->cgoCtxt.array;
  if ( pcbuf )
    printing = 0;
  else
    printing = callback == 0;
  for ( j = gp->_defer; j && j->sp == -1; j = j->link )
    ;
  _defer = j;
  cgoCtxt_ptr = array;
  if ( !frame.pc )
  {
    frame.pc = *v12;
    frame.sp += 4;
  }
  v121 = runtime_findfunc(frame.pc);
  if ( !v121._func )
  {
    if ( callback )
    {
      v157 = frame.pc;
      runtime_printlock();
      pcbn.str = (uint8 *)"runtime: unknown pc ";
      pcbn.len = 20;
      runtime_printstring(pcbn);
      runtime_printhex(v157);
      pcbo.str = (uint8 *)"\n";
      pcbo.len = 1;
      runtime_printstring(pcbo);
      runtime_printunlock();
      pcbp.str = (uint8 *)"unknown pc";
      pcbp.len = 10;
      runtime_throw(pcbp);
      BUG();
    }
    return 0;
  }
  frame.fn = v121;
  ((void (*)(void))loc_808FD60)();
  v16 = 0;
  v17 = 0;
  str = (uint8 *)cgoCtxt_ptr;
  v19 = skip;
  v20 = 0;
  for ( k = _defer; ; k = _defer )
  {
    skipa = v19;
    if ( v16 >= max )
      break;
    n = v16;
    func = frame.fn._func;
    f_datap = frame.fn.datap;
    if ( !frame.fn._func->pcsp )
    {
      v38 = k;
      v39 = n;
      v28 = v20;
      goto LABEL_57;
    }
    v174.len = (__int32)k;
    nprint = v20;
    f__func = frame.fn._func;
    waspanic = v17;
    if ( !frame.fp )
    {
      sp = frame.sp;
      if ( (flags & 4) != 0 )
      {
        if ( runtime_systemstackPC == frame.fn._func->entry )
        {
          if ( g->m->g0 == gp )
          {
            curg = gp->m->curg;
            if ( curg )
            {
              sp = curg->sched.sp;
              frame.sp = sp;
              v66 = gp->m->curg;
              v67 = (uint8 *)v66->cgoCtxt.array;
              v68 = v66->cgoCtxt.len;
            }
            else
            {
              v69 = str;
              v68 = len;
              v67 = v69;
            }
          }
          else
          {
            v70 = str;
            v68 = len;
            v67 = v70;
          }
        }
        else
        {
          v71 = str;
          v68 = len;
          v67 = v71;
        }
      }
      else
      {
        v160 = frame.sp;
        v72 = str;
        v68 = len;
        v67 = v72;
        sp = frame.sp;
      }
      sp_0 = sp;
      cgoCtxt_lena = v68;
      v174.str = v67;
      HIDWORD(v123) = runtime_funcspdelta(
                        (runtime_funcInfo_0)__PAIR64__((unsigned int)f_datap, (unsigned int)frame.fn._func),
                        frame.pc,
                        &cache);
      frame.fp = sp_0 + HIDWORD(v123) + 4;
      v17 = waspanic;
      func = f__func;
      k = (runtime__defer *)v174.len;
      len = cgoCtxt_lena;
      str = v174.str;
    }
    cgoCtxt_len = len;
    entry = func->entry;
    if ( runtime_goexitPC == func->entry )
    {
      v33 = 1;
    }
    else if ( runtime_mstartPC == entry )
    {
      v33 = 1;
    }
    else if ( runtime_mcallPC == entry )
    {
      v33 = 1;
    }
    else if ( runtime_morestackPC == entry )
    {
      v33 = 1;
    }
    else if ( runtime_rt0_goPC == entry )
    {
      v33 = 1;
    }
    else if ( runtime_externalthreadhandlerp )
    {
      v33 = entry == runtime_externalthreadhandlerp;
    }
    else
    {
      v33 = 0;
    }
    v174.str = str;
    if ( v33 )
    {
      frame.lr = 0;
      datap = 0;
      v35 = 0;
    }
    else
    {
      if ( !frame.lr )
        frame.lr = *(_DWORD *)(frame.fp - 4);
      v122 = runtime_findfunc(frame.lr);
      datap = v122.datap;
      if ( !v122._func && callback )
      {
        v73 = runtime_funcname((runtime_funcInfo_0)__PAIR64__((unsigned int)f_datap, (unsigned int)f__func));
        v159 = v73.len;
        v174.str = v73.str;
        lr = frame.lr;
        runtime_printlock();
        pcbj.str = (uint8 *)"runtime: unexpected return pc for ";
        pcbj.len = 34;
        runtime_printstring(pcbj);
        runtime_printstring((string)__PAIR64__(v159, (unsigned int)v174.str));
        pcbk.str = (uint8 *)" called from ";
        pcbk.len = 13;
        runtime_printstring(pcbk);
        runtime_printhex(lr);
        pcbl.str = (uint8 *)"\n";
        pcbl.len = 1;
        runtime_printstring(pcbl);
        runtime_printunlock();
        pcbm.str = (uint8 *)"unknown caller pc";
        pcbm.len = 17;
        runtime_throw(pcbm);
        BUG();
      }
      str = v174.str;
      func = f__func;
      k = (runtime__defer *)v174.len;
      v35 = v122._func;
      v17 = waspanic;
    }
    f_datap_0 = datap;
    f__func_0 = v35;
    frame.varp = frame.fp - 4;
    v36 = callback;
    if ( callback || (v37 = printing) )
    {
      frame.argp = frame.fp;
      runtime_getArgInfo(
        &frame,
        (runtime_funcInfo_0)__PAIR64__((unsigned int)f_datap, (unsigned int)func),
        callback != 0,
        0,
        v125,
        v126);
      frame.arglen = v125;
      frame.argmap = v126;
      v36 = callback;
      v17 = waspanic;
      str = v174.str;
      func = f__func;
      v37 = printing;
      k = (runtime__defer *)v174.len;
    }
    frame.continpc = frame.pc;
    if ( v17 )
    {
      if ( k && frame.sp == k->sp )
        frame.continpc = k->pc;
      else
        frame.continpc = 0;
    }
    while ( k )
    {
      v22 = k->sp;
      if ( frame.sp != v22 && v22 != -1 )
      {
        v23 = v36 == 0;
        goto LABEL_26;
      }
      k = k->link;
    }
    v23 = v36 == 0;
LABEL_26:
    _defer = k;
    if ( v23 )
    {
      v24 = pcbuf;
      v25 = pcbuf == 0;
    }
    else
    {
      if ( !(*(unsigned __int8 (__golang **)(runtime_stkframe_0 *, void *))v36)(&frame, v) )
        return n;
      v24 = pcbuf;
      v25 = pcbuf == 0;
      str = v174.str;
      func = f__func;
      v37 = printing;
    }
    if ( v25 )
    {
      v27 = n;
      v26 = skipa;
    }
    else
    {
      v26 = skipa;
      if ( skipa )
      {
        v59 = frame.pc;
        if ( (n > 0 || (flags & 2) == 0) && frame.pc > func->entry && !waspanic )
          v59 = frame.pc - 1;
        DWORD1(v123) = runtime_funcdata((runtime_funcInfo_0)__PAIR64__((unsigned int)f_datap, (unsigned int)func), 2);
        if ( !DWORD1(v123) )
        {
          v26 = skipa - 1;
          str = v174.str;
          func = f__func;
          v28 = nprint;
          v29 = n;
          goto LABEL_35;
        }
        v173 = DWORD1(v123);
        v125 = runtime_pcdatavalue(
                 (runtime_funcInfo_0)__PAIR64__((unsigned int)f_datap, (unsigned int)f__func),
                 1,
                 v59,
                 &cache);
        v60 = v125;
        v61 = skipa;
        v62 = 0;
        while ( v60 >= 0 && v61 > 0 )
        {
          if ( (unsigned int)v60 >= 0x100000 )
            runtime_panicindex();
          --v61;
          ++v62;
          v60 = *(_DWORD *)(16 * v60 + v173);
        }
        if ( v61 > 0 )
        {
          v26 = v61 - 1;
          str = v174.str;
          func = f__func;
          v28 = nprint;
          v29 = n;
          goto LABEL_35;
        }
        if ( (unsigned int)n >= 0x100000 )
          runtime_panicindex();
        pcbuf[n] = frame.pc;
        v27 = n + 1;
        if ( n + 1 >= max )
        {
          v27 = n;
        }
        else
        {
          f._type = (runtime__type_0 *)&unk_80CA340;
          f.data = off_80E7CD0;
          v63 = (char *)runtime_skipPleaseUseCallersFrames + v62;
          if ( (unsigned int)v27 >= 0x100000 )
            runtime_panicindex();
          pcbuf[n + 1] = (uintptr)v63;
        }
        func = f__func;
        v37 = printing;
        v26 = v61;
        str = v174.str;
      }
      else
      {
        v27 = n;
        if ( (unsigned int)n >= 0x100000 )
          runtime_panicindex();
        v24[n] = frame.pc;
      }
    }
    if ( v37 )
    {
      v144 = v26;
      v159 = v27;
      v45 = flags;
      if ( (flags & 1) != 0 )
      {
LABEL_77:
        v46 = frame.pc;
        if ( (v27 > 0 || (v45 & 2) == 0) && frame.pc > func->entry && !waspanic )
          v46 = frame.pc - 1;
        runtime_funcline(
          (runtime_funcInfo_0)__PAIR64__((unsigned int)f_datap, (unsigned int)func),
          v46,
          *(string *)((char *)&v123 + 4),
          v125);
        file_len = HIDWORD(v123);
        file_ptr = (uint8 *)DWORD1(v123);
        line = v125;
        DWORD1(v123) = runtime_funcdata((runtime_funcInfo_0)__PAIR64__((unsigned int)f_datap, (unsigned int)f__func), 2);
        if ( DWORD1(v123) )
        {
          v173 = DWORD1(v123);
          v125 = runtime_pcdatavalue(
                   (runtime_funcInfo_0)__PAIR64__((unsigned int)f_datap, (unsigned int)f__func),
                   1,
                   v46,
                   0);
          v56 = v125;
          v48 = file_len;
          v57 = file_ptr;
          v58 = line;
          while ( v56 != -1 )
          {
            if ( v56 >= 0x100000 )
              runtime_panicindex();
            v142 = v48;
            s.str = v57;
            HIDWORD(goid) = v58;
            v141 = 16 * v56;
            v124 = runtime_funcnameFromNameoff(
                     (runtime_funcInfo_0)__PAIR64__((unsigned int)f_datap, (unsigned int)f__func),
                     *(_DWORD *)(v173 + 16 * v56 + 12));
            name_ptr_0 = v124.str;
            runtime_printlock();
            runtime_printstring((string)__PAIR64__(v124.len, (unsigned int)name_ptr_0));
            pcv.str = (uint8 *)"(...)\n";
            pcv.len = 6;
            runtime_printstring(pcv);
            runtime_printunlock();
            runtime_printlock();
            pcw.str = (uint8 *)"\t";
            pcw.len = 1;
            runtime_printstring(pcw);
            runtime_printstring((string)__PAIR64__(v142, (unsigned int)s.str));
            pcx.str = (uint8 *)":";
            pcx.len = 1;
            runtime_printstring(pcx);
            runtime_printint(goid >> 32);
            pcy.str = (uint8 *)"\n";
            pcy.len = 1;
            runtime_printstring(pcy);
            runtime_printunlock();
            *(string *)((char *)&v123 + 4) = runtime_funcfile(
                                               (runtime_funcInfo_0)__PAIR64__(
                                                                     (unsigned int)f_datap,
                                                                     (unsigned int)f__func),
                                               *(_DWORD *)(v173 + v141 + 4));
            v48 = HIDWORD(v123);
            v57 = (uint8 *)DWORD1(v123);
            v56 = *(_DWORD *)(v141 + v173);
            v58 = *(_DWORD *)(v173 + v141 + 8);
          }
          v47 = v57;
          v49 = v58;
        }
        else
        {
          v47 = file_ptr;
          v48 = HIDWORD(v123);
          v49 = v125;
        }
        file_ptr = v47;
        file_lena = v48;
        linea = v49;
        *(string *)&v123 = runtime_funcname((runtime_funcInfo_0)__PAIR64__((unsigned int)f_datap, (unsigned int)f__func));
        v50 = DWORD1(v123);
        v51 = (uint8 *)LODWORD(v123);
        if ( DWORD1(v123) == 15 )
        {
          s.len = LODWORD(v123);
          DWORD1(v123) = 15;
          runtime_eqstring();
          if ( BYTE8(v123) )
          {
            v50 = 5;
            v51 = (uint8 *)"panic";
          }
          else
          {
            v50 = 15;
            v51 = (uint8 *)s.len;
          }
        }
        name_len = v50;
        name_ptr = v51;
        runtime_printlock();
        runtime_printstring((string)__PAIR64__(name_len, (unsigned int)name_ptr));
        pck.str = (uint8 *)"(";
        pck.len = 1;
        runtime_printstring(pck);
        runtime_printunlock();
        argp = frame.argp;
        v173 = frame.argp;
        v53 = 0;
        while ( v53 < frame.arglen >> 2 )
        {
          if ( v53 >= 0xA )
          {
            runtime_printlock();
            pcm.str = (uint8 *)", ...";
            pcm.len = 5;
            runtime_printstring(pcm);
            runtime_printunlock();
            break;
          }
          i = v53;
          if ( v53 )
          {
            runtime_printlock();
            pcl.str = (uint8 *)", ";
            pcl.len = 2;
            runtime_printstring(pcl);
            runtime_printunlock();
            argp = v173;
            v53 = i;
          }
          v152 = *(_DWORD *)(argp + 4 * v53);
          runtime_printlock();
          runtime_printhex(v152);
          runtime_printunlock();
          v53 = i + 1;
          argp = v173;
        }
        runtime_printlock();
        pcn.str = (uint8 *)")\n";
        pcn.len = 2;
        runtime_printstring(pcn);
        runtime_printunlock();
        runtime_printlock();
        pco.str = (uint8 *)"\t";
        pco.len = 1;
        runtime_printstring(pco);
        runtime_printstring((string)__PAIR64__(file_lena, (unsigned int)file_ptr));
        pcp.str = (uint8 *)":";
        pcp.len = 1;
        runtime_printstring(pcp);
        runtime_printint(linea);
        runtime_printunlock();
        if ( frame.pc > f__func->entry )
        {
          v153 = frame.pc;
          v148 = f__func->entry;
          runtime_printlock();
          pcq.str = (uint8 *)" +";
          pcq.len = 2;
          runtime_printstring(pcq);
          runtime_printhex(v153 - v148);
          runtime_printunlock();
        }
        m = g->m;
        if ( m->throwing > 0 && m->curg == gp || level >= 2 )
        {
          v147 = *(_QWORD *)&frame.sp;
          v143 = frame.pc;
          runtime_printlock();
          pcr.str = (uint8 *)" fp=";
          pcr.len = 4;
          runtime_printstring(pcr);
          runtime_printhex(HIDWORD(v147));
          pcs.str = (uint8 *)" sp=";
          pcs.len = 4;
          runtime_printstring(pcs);
          runtime_printhex((unsigned int)v147);
          pct.str = (uint8 *)" pc=";
          pct.len = 4;
          runtime_printstring(pct);
          runtime_printhex(v143);
          runtime_printunlock();
        }
        runtime_printlock();
        pcu.str = (uint8 *)"\n";
        pcu.len = 1;
        runtime_printstring(pcu);
        runtime_printunlock();
        v55 = nprint + 1;
      }
      else
      {
        BYTE8(v123) = runtime_showframe(
                        (runtime_funcInfo_0)__PAIR64__((unsigned int)f_datap, (unsigned int)func),
                        gp,
                        nprint == 0);
        if ( BYTE8(v123) )
        {
          v27 = v159;
          func = f__func;
          v45 = flags;
          goto LABEL_77;
        }
        v55 = nprint;
      }
      str = v174.str;
      v26 = v144;
      func = f__func;
      v28 = v55;
      v27 = v159;
      goto LABEL_34;
    }
    v28 = nprint;
LABEL_34:
    v29 = v27 + 1;
LABEL_35:
    if ( runtime_cgocallback_gofuncPC == func->entry && cgoCtxt_len > 0 )
    {
      v30 = cgoCtxt_len - 1;
      if ( cgoCtxt_len - 1 >= (unsigned int)cgoCtxt_len )
        runtime_panicindex();
      if ( !v26 && !callback )
      {
        v125 = runtime_tracebackCgoContext(pcbuf, printing, *(_DWORD *)&str[4 * cgoCtxt_len - 4], v29, max);
        v29 = v125;
        str = v174.str;
        func = f__func;
      }
    }
    else
    {
      v30 = cgoCtxt_len;
    }
    v159 = v29;
    v31 = func->entry;
    if ( !f__func_0 )
    {
      v38 = _defer;
      v39 = v159;
      goto LABEL_57;
    }
    frame.fn._func = f__func_0;
    frame.fn.datap = f_datap_0;
    frame.pc = frame.lr;
    frame.lr = 0;
    frame.sp = frame.fp;
    frame.fp = 0;
    frame.argmap = 0;
    v17 = runtime_sigpanicPC == v31;
    v16 = v159;
    v19 = v26;
    len = v30;
    v20 = v28;
  }
  v39 = v16;
  v38 = k;
  v28 = v20;
LABEL_57:
  if ( !printing )
    v28 = v39;
  v40 = callback == 0;
  if ( callback )
  {
    v41 = max;
    if ( v28 >= max )
    {
      v40 = callback == 0;
    }
    else
    {
      if ( v38 )
      {
        goid = gp->goid;
        v150 = v38->sp;
        v145 = v38->pc;
        runtime_printlock();
        pcb.str = (uint8 *)"runtime: g";
        pcb.len = 10;
        runtime_printstring(pcb);
        runtime_printint(goid);
        pcc.str = (uint8 *)": leftover defer sp=";
        pcc.len = 20;
        runtime_printstring(pcc);
        runtime_printhex(v150);
        pcd.str = (uint8 *)" pc=";
        pcd.len = 4;
        runtime_printstring(pcd);
        runtime_printhex(v145);
        pce.str = (uint8 *)"\n";
        pce.len = 1;
        runtime_printstring(pce);
        runtime_printunlock();
        for ( ii = gp->_defer; ii; ii = _defer->link )
        {
          _defer = ii;
          v151 = ii->sp;
          v146 = ii->pc;
          runtime_printlock();
          pcf.str = (uint8 *)"\tdefer ";
          pcf.len = 7;
          runtime_printstring(pcf);
          runtime_printpointer(_defer);
          pcg.str = (uint8 *)" sp=";
          pcg.len = 4;
          runtime_printstring(pcg);
          runtime_printhex(v151);
          pch.str = (uint8 *)" pc=";
          pch.len = 4;
          runtime_printstring(pch);
          runtime_printhex(v146);
          pci.str = (uint8 *)"\n";
          pci.len = 1;
          runtime_printstring(pci);
          runtime_printunlock();
        }
        pcj.str = (uint8 *)"traceback has leftover defers";
        pcj.len = 29;
        runtime_throw(pcj);
        BUG();
      }
      v40 = callback == 0;
    }
  }
  else
  {
    v41 = max;
  }
  if ( !v40 && v28 < v41 )
  {
    stktopsp = gp->stktopsp;
    if ( frame.sp != stktopsp )
    {
      v154 = frame.sp;
      goid = gp->goid;
      runtime_printlock();
      pcz.str = (uint8 *)"runtime: g";
      pcz.len = 10;
      runtime_printstring(pcz);
      runtime_printint(goid);
      pcba.str = (uint8 *)": frame.sp=";
      pcba.len = 11;
      runtime_printstring(pcba);
      runtime_printhex(v154);
      pcbb.str = (uint8 *)" top=";
      pcbb.len = 5;
      runtime_printstring(pcbb);
      runtime_printhex(stktopsp);
      pcbc.str = (uint8 *)"\n";
      pcbc.len = 1;
      runtime_printstring(pcbc);
      runtime_printunlock();
      lo = gp->stack.lo;
      hi = gp->stack.hi;
      runtime_printlock();
      pcbd.str = (uint8 *)"\tstack=[";
      pcbd.len = 8;
      runtime_printstring(pcbd);
      runtime_printhex(lo);
      pcbe.str = (uint8 *)"-";
      pcbe.len = 1;
      runtime_printstring(pcbe);
      runtime_printhex(hi);
      pcbf.str = (uint8 *)"] n=";
      pcbf.len = 4;
      runtime_printstring(pcbf);
      runtime_printint(v28);
      pcbg.str = (uint8 *)" max=";
      pcbg.len = 5;
      runtime_printstring(pcbg);
      runtime_printint(max);
      pcbh.str = (uint8 *)"\n";
      pcbh.len = 1;
      runtime_printstring(pcbh);
      runtime_printunlock();
      pcbi.str = (uint8 *)"traceback did not unwind completely";
      pcbi.len = 35;
      runtime_throw(pcbi);
      BUG();
    }
  }
  return v28;
}
// 808615C: variable 'pc' is possibly undefined
// 808615C: variable 'v120' is possibly undefined
// 808615C: variable 'v123' is possibly undefined
// 8086199: variable 'pca' is possibly undefined
// 80861B4: variable 'v12' is possibly undefined
// 80867F1: variable 'v125' is possibly undefined
// 80870CC: variable 'v126' is possibly undefined
// 80E0D85: using guessed type char asc_80E0D85;
// 80E0D8A: using guessed type char asc_80E0D8A;
// 80E0D8F: using guessed type char asc_80E0D8F;
// 80E0D9D: using guessed type char asc_80E0D9D;
// 80E7CD0: using guessed type int (__golang *off_80E7CD0[4])();

//----- (08087730) --------------------------------------------------------
void __golang runtime_getArgInfo(
        runtime_stkframe *frame,
        runtime_funcInfo_0 f,
        bool needArgMap,
        runtime_funcval *ctxt,
        uintptr arglen,
        runtime_bitvector_0 *argmap)
{
  __int32 len; // eax
  runtime_funcval *v7; // eax
  string v8; // [esp+0h] [ebp-20h]
  string v9; // [esp+0h] [ebp-20h]
  string v10; // [esp+0h] [ebp-20h]
  string v11; // [esp+8h] [ebp-18h]
  string v12; // [esp+8h] [ebp-18h]
  char v13; // [esp+10h] [ebp-10h]

  if ( !needArgMap || f._func->args != 0x80000000 )
    return;
  v11 = runtime_funcname(f);
  len = v11.len;
  if ( v11.len != 20 )
    goto LABEL_4;
  runtime_eqstring();
  if ( !v13 )
  {
    len = 20;
LABEL_4:
    if ( len != 23 )
      return;
    runtime_eqstring();
    if ( !v13 )
      return;
  }
  v7 = ctxt;
  if ( !ctxt )
    v7 = *(runtime_funcval **)frame->sp;
  if ( v7->fn != f._func->entry )
  {
    v12 = runtime_funcname(f);
    runtime_printlock();
    v8.str = (uint8 *)"runtime: confused by ";
    v8.len = 21;
    runtime_printstring(v8);
    runtime_printstring(v12);
    v9.str = (uint8 *)"\n";
    v9.len = 1;
    runtime_printstring(v9);
    runtime_printunlock();
    v10.str = (uint8 *)"reflect mismatch";
    v10.len = 16;
    runtime_throw(v10);
    BUG();
  }
}
// 80877C6: variable 'v13' is possibly undefined

//----- (080878C0) --------------------------------------------------------
__int32 __golang runtime_tracebackCgoContext(uintptr *pcbuf, bool printing, uintptr ctxt, __int32 n, __int32 max)
{
  int v5; // eax
  uintptr *v6; // ecx
  bool v7; // dl
  uintptr v9; // ebp
  __int32 v10; // eax
  string v11; // [esp+0h] [ebp-13Ch]
  string v12; // [esp+0h] [ebp-13Ch]
  __uintptr buf; // [esp+4h] [ebp-138h]
  bool anySymbolized; // [esp+12h] [ebp-12Ah]
  bool v15; // [esp+13h] [ebp-129h]
  int v16; // [esp+18h] [ebp-124h]
  uintptr cgoPCs[32]; // [esp+1Ch] [ebp-120h] BYREF
  char v18; // [esp+9Ch] [ebp-A0h] BYREF
  uintptr *v19; // [esp+11Ch] [ebp-20h]
  runtime_cgoSymbolizerArg_0 arg; // [esp+120h] [ebp-1Ch] BYREF

  while ( (unsigned int)&cgoPCs[25] <= *(_DWORD *)(*(_DWORD *)(__readgsdword(0) - 4) + 8) )
    runtime_morestack_noctxt();
  ((void (*)(void))loc_808FD70)();
  buf.array = cgoPCs;
  *(_QWORD *)&buf.len = 0x2000000020LL;
  runtime_cgoContextPCs(ctxt, buf);
  ((void (*)(void))loc_808FD89)();
  ((void (*)(void))loc_8090160)();
  v5 = 0;
  v6 = (uintptr *)&v18;
  v7 = 0;
  while ( v5 < 32 )
  {
    v9 = *v6;
    if ( !*v6 || n >= max )
      break;
    if ( pcbuf )
    {
      if ( (unsigned int)n >= 0x100000 )
        runtime_panicindex();
      pcbuf[n] = v9;
    }
    if ( printing )
    {
      v16 = v5;
      anySymbolized = v7;
      v19 = v6;
      v15 = runtime_cgoSymbolizer != 0;
      if ( runtime_cgoSymbolizer )
      {
        v10 = runtime_printOneCgoTraceback(v9, max - n, &arg) + n - 1;
      }
      else
      {
        runtime_printlock();
        v11.str = (uint8 *)"non-Go function at pc=";
        v11.len = 22;
        runtime_printstring(v11);
        runtime_printhex(v9);
        v12.str = (uint8 *)"\n";
        v12.len = 1;
        runtime_printstring(v12);
        runtime_printunlock();
        v10 = n;
      }
      v7 = anySymbolized || v15;
      v6 = v19;
      n = v10;
      v5 = v16;
    }
    ++v6;
    ++v5;
    ++n;
  }
  if ( v7 )
  {
    arg.pc = 0;
    runtime_callCgoSymbolizer(&arg);
  }
  return n;
}

//----- (08087AD0) --------------------------------------------------------
void __golang runtime_printcreatedby(runtime_g *gp)
{
  uintptr v1; // ecx
  string pc; // [esp+0h] [ebp-3Ch]
  string pca; // [esp+0h] [ebp-3Ch]
  string pcb; // [esp+0h] [ebp-3Ch]
  string pcc; // [esp+0h] [ebp-3Ch]
  string pce; // [esp+0h] [ebp-3Ch]
  string pcd; // [esp+0h] [ebp-3Ch]
  runtime_funcInfo_0 f; // [esp+4h] [ebp-38h]
  long double f_4; // [esp+8h] [ebp-34h]
  string firstFrame; // [esp+Ch] [ebp-30h]
  int32 v11; // [esp+14h] [ebp-28h]
  int v12; // [esp+14h] [ebp-28h]
  uintptr tracepc; // [esp+18h] [ebp-24h]
  uintptr entry; // [esp+24h] [ebp-18h]
  runtime_moduledata_0 *f_datap; // [esp+30h] [ebp-Ch]
  runtime__func *f__func; // [esp+34h] [ebp-8h]

  tracepc = gp->gopc;
  f = runtime_findfunc(tracepc);
  if ( f._func )
  {
    f_datap = f.datap;
    f__func = f._func;
    BYTE8(f_4) = runtime_showframe(f, gp, 0);
    if ( BYTE8(f_4) )
    {
      if ( LODWORD(gp->goid) != 1 || HIDWORD(gp->goid) != 0 )
      {
        *(string *)&f_4 = runtime_funcname((runtime_funcInfo_0)__PAIR64__((unsigned int)f_datap, (unsigned int)f__func));
        runtime_printlock();
        pc.str = (uint8 *)"created by ";
        pc.len = 11;
        runtime_printstring(pc);
        runtime_printstring(*(string *)&f_4);
        pca.str = (uint8 *)"\n";
        pca.len = 1;
        runtime_printstring(pca);
        runtime_printunlock();
        if ( tracepc <= f__func->entry )
          v1 = tracepc;
        else
          v1 = tracepc - 1;
        runtime_funcline(
          (runtime_funcInfo_0)__PAIR64__((unsigned int)f_datap, (unsigned int)f__func),
          v1,
          *(string *)((char *)&f_4 + 4),
          v11);
        runtime_printlock();
        pcb.str = (uint8 *)"\t";
        pcb.len = 1;
        runtime_printstring(pcb);
        runtime_printstring(firstFrame);
        pcc.str = (uint8 *)":";
        pcc.len = 1;
        runtime_printstring(pcc);
        runtime_printint(v12);
        runtime_printunlock();
        if ( tracepc > f__func->entry )
        {
          entry = f__func->entry;
          runtime_printlock();
          pcd.str = (uint8 *)" +";
          pcd.len = 2;
          runtime_printstring(pcd);
          runtime_printhex(tracepc - entry);
          runtime_printunlock();
        }
        runtime_printlock();
        pce.str = (uint8 *)"\n";
        pce.len = 1;
        runtime_printstring(pce);
        runtime_printunlock();
      }
    }
  }
}
// 8087BE6: variable 'f_4' is possibly undefined
// 8087BE6: variable 'v11' is possibly undefined
// 8087C2D: variable 'firstFrame' is possibly undefined
// 8087C52: variable 'v12' is possibly undefined
// 80E0D8F: using guessed type char asc_80E0D8F;
// 80E0D9D: using guessed type char asc_80E0D9D;

//----- (08087CF0) --------------------------------------------------------
void __golang runtime_traceback(uintptr pc, uintptr sp_0, uintptr lr, runtime_g *gp)
{
  runtime_traceback1(pc, sp_0, lr, gp, 0);
}

//----- (08087D40) --------------------------------------------------------
void __golang runtime_tracebacktrap(uintptr pc, uintptr sp_0, uintptr lr, runtime_g *gp)
{
  runtime_traceback1(pc, sp_0, lr, gp, 2u);
}

//----- (08087D90) --------------------------------------------------------
void __golang runtime_traceback1(uintptr pc, uintptr sp_0, uintptr lr, runtime_g *gp, uint flags)
{
  runtime_g *v5; // eax
  runtime_m *m; // ecx
  uintptr (*v7)[32]; // edx
  runtime_g *v8; // eax
  uintptr syscallpc; // ecx
  uintptr sp0; // edx
  uint v11; // ebx
  __int32 v12; // eax
  int v13; // eax
  string pc0a; // [esp+0h] [ebp-ACh]
  uintptr pc0; // [esp+0h] [ebp-ACh]
  runtime_cgoCallers cgoCallers; // [esp+2Ch] [ebp-80h] BYREF
  uintptr pca; // [esp+B0h] [ebp+4h]
  uintptr sp_0a; // [esp+B4h] [ebp+8h]

  while ( (unsigned int)&cgoCallers[21] <= *(_DWORD *)(*(_DWORD *)(__readgsdword(0) - 4) + 8) )
    runtime_morestack_noctxt();
  if ( runtime_iscgo )
  {
    v5 = gp;
    m = gp->m;
    if ( m )
    {
      if ( m->ncgo > 0 )
      {
        if ( gp->syscallsp )
        {
          v7 = m->cgoCallers;
          if ( v7 )
          {
            if ( (*v7)[0] )
            {
              pc0 = (uintptr)&m->cgoCallersUse;
              runtime_internal_atomic_Store();
              ((void (__golang *)(uintptr, int))loc_8090160)(pc0, 1);
              **(_DWORD **)(*(_DWORD *)(v13 + 24) + 168) = 0;
              runtime_internal_atomic_Store();
              runtime_printCgoTraceback((uintptr (*)[32])cgoCallers);
              v5 = gp;
            }
          }
        }
      }
    }
  }
  else
  {
    v5 = gp;
  }
  if ( (runtime_readgstatus(v5) & 0xFFFFEFFF) == 3 )
  {
    v8 = gp;
    syscallpc = gp->syscallpc;
    sp0 = gp->syscallsp;
    v11 = flags & 0xFFFFFFFD;
  }
  else
  {
    v8 = gp;
    syscallpc = pc;
    sp0 = sp_0;
    v11 = flags;
  }
  pca = syscallpc;
  sp_0a = sp0;
  v12 = runtime_gentraceback(syscallpc, sp0, lr, v8, 0, 0, 100, 0, 0, v11);
  if ( !v12 && (v11 & 1) == 0 )
    v12 = runtime_gentraceback(pca, sp_0a, lr, gp, 0, 0, 100, 0, 0, v11 | 1);
  if ( v12 == 100 )
  {
    runtime_printlock();
    pc0a.str = (uint8 *)"...additional frames elided...\n";
    pc0a.len = 31;
    runtime_printstring(pc0a);
    runtime_printunlock();
  }
  runtime_printcreatedby(gp);
}
// 8087F8D: variable 'v13' is possibly undefined

//----- (08087FF0) --------------------------------------------------------
__int32 __golang runtime_callers(__int32 skip, __uintptr pcbuf)
{
  int v2; // edx
  __int32 n[2]; // [esp+8h] [ebp-30h] BYREF
  runtime_g *gp; // [esp+10h] [ebp-28h]
  void (__golang *v5)(); // [esp+14h] [ebp-24h]
  __int32 *v6; // [esp+18h] [ebp-20h]
  int v7; // [esp+1Ch] [ebp-1Ch]
  __int32 *p_skip; // [esp+20h] [ebp-18h]
  runtime_g *v9; // [esp+24h] [ebp-14h]
  __int32 *v10; // [esp+28h] [ebp-10h]
  __uintptr v11; // [esp+2Ch] [ebp-Ch]

  n[1] = (__int32)&skip;
  runtime_getcallerpc();
  gp = *(runtime_g **)(__readgsdword(0) - 4);
  n[0] = 0;
  ((void (__golang *)(__int32 *))loc_808FD87)(&skip);
  v5 = runtime_callers_func1;
  v6 = n;
  v7 = v2;
  p_skip = &skip;
  v9 = gp;
  v10 = &skip;
  v11 = pcbuf;
  runtime_systemstack();
  return n[0];
}
// 8088057: variable 'v2' is possibly undefined

//----- (080880B0) --------------------------------------------------------
__int32 __golang runtime_gcallers(runtime_g *gp, __int32 skip, __uintptr pcbuf)
{
  if ( !pcbuf.len )
    runtime_panicindex();
  return runtime_gentraceback(0xFFFFFFFF, 0xFFFFFFFF, 0, gp, skip, pcbuf.array, pcbuf.len, 0, 0, 0);
}

//----- (08088140) --------------------------------------------------------
bool __golang runtime_showframe(runtime_funcInfo_0 f, runtime_g *gp, bool firstFrame)
{
  int v3; // eax
  uint8 *str; // eax
  int v5; // ecx
  string v6; // kr00_8
  string v7; // kr08_8
  bool v9; // dl
  bool v10; // dl
  uint8 v12; // al
  int32 v13; // [esp+0h] [ebp-20h]
  int32 v14; // [esp+0h] [ebp-20h]
  bool v15; // [esp+4h] [ebp-1Ch]
  bool t; // [esp+8h] [ebp-18h]
  string ta; // [esp+8h] [ebp-18h]
  string tb; // [esp+8h] [ebp-18h]
  bool v19; // [esp+10h] [ebp-10h]
  __int32 name_len; // [esp+14h] [ebp-Ch]
  int32 level; // [esp+18h] [ebp-8h]
  uint8 *name_ptr; // [esp+1Ch] [ebp-4h]

  v3 = *(_DWORD *)(*(_DWORD *)(__readgsdword(0) - 4) + 24);
  if ( *(int *)(v3 + 108) > 0 && gp && (*(runtime_g **)(v3 + 84) == gp || *(runtime_g **)(v3 + 88) == gp) )
    return 1;
  runtime_gotraceback(v13, v15, t);
  level = v14;
  ta = runtime_funcname(f);
  v6 = ta;
  v5 = HIDWORD(*(unsigned __int64 *)&v6);
  str = v6.str;
  v7 = ta;
  name_len = HIDWORD(*(unsigned __int64 *)&v7);
  name_ptr = v7.str;
  if ( ta.len == 15 )
  {
    runtime_eqstring();
    if ( v19 && !firstFrame )
      return 1;
    str = ta.str;
    v5 = 15;
  }
  if ( level > 1 )
    return 1;
  if ( f._func )
  {
    tb.str = (uint8 *)".";
    tb.len = 1;
    v19 = runtime_contains((string)__PAIR64__(v5, (unsigned int)str), tb);
    v9 = v19;
    str = name_ptr;
    v5 = name_len;
  }
  else
  {
    v9 = 0;
  }
  if ( !v9 )
    return 0;
  if ( v5 >= 8 )
  {
    runtime_eqstring();
    v10 = v19;
    str = name_ptr;
    v5 = name_len;
  }
  else
  {
    v10 = 0;
  }
  if ( !v10 )
    return 1;
  if ( v5 <= 8 )
    return 0;
  if ( *(_DWORD *)str != 1953396082 || *((_DWORD *)str + 1) != 778399081 )
    return 0;
  v12 = str[8];
  return v12 >= 0x41u && v12 <= 0x5Au;
}
// 808818F: variable 'v13' is possibly undefined
// 808818F: variable 'v15' is possibly undefined
// 808818F: variable 't' is possibly undefined
// 8088197: variable 'v14' is possibly undefined
// 8088268: variable 'v19' is possibly undefined
// 80E0D8B: using guessed type char asc_80E0D8B;

//----- (08088300) --------------------------------------------------------
void __golang runtime_goroutineheader(runtime_g *gp)
{
  unsigned int v1; // eax
  string *v2; // edx
  const char *str; // ebx
  int len; // edx
  bool v5; // zf
  runtime_g *v6; // ebp
  uint8 *v7; // esi
  __int32 v8; // edi
  int64 v9; // rax
  string s; // [esp+0h] [ebp-34h]
  string sa; // [esp+0h] [ebp-34h]
  string sb; // [esp+0h] [ebp-34h]
  string sg; // [esp+0h] [ebp-34h]
  string sf; // [esp+0h] [ebp-34h]
  string sd; // [esp+0h] [ebp-34h]
  string se; // [esp+0h] [ebp-34h]
  string sc; // [esp+0h] [ebp-34h]
  int64 waitfor_lo; // [esp+18h] [ebp-1Ch]
  int64 v; // [esp+24h] [ebp-10h]
  __int16 v20; // [esp+2Ch] [ebp-8h]

  s.len = runtime_readgstatus(gp);
  v1 = s.len & 0xFFFFEFFF;
  if ( (s.len & 0xFFFFEFFF) >= 9 )
  {
    str = "???";
    len = 3;
  }
  else
  {
    v2 = &runtime_gStatusStrings[v1];
    str = (const char *)v2->str;
    len = v2->len;
  }
  v5 = v1 == 4;
  if ( v1 == 4 )
  {
    v6 = gp;
    v7 = gp->waitreason.str;
    v8 = gp->waitreason.len;
    v5 = 1;
    if ( !v8 )
    {
      v8 = len;
      v7 = (uint8 *)str;
    }
  }
  else
  {
    v6 = gp;
    v8 = len;
    v7 = (uint8 *)str;
  }
  v20 = s.len;
  if ( v5 || v1 == 3 )
  {
    if ( LODWORD(v6->waitsince) != 0 || HIDWORD(v6->waitsince) != 0 )
    {
      runtime_nanotime();
      v9 = runtime_int64div(*(_QWORD *)&s - gp->waitsince, 60000000000LL);
      v6 = gp;
    }
    else
    {
      v9 = 0LL;
    }
  }
  else
  {
    v9 = 0LL;
  }
  waitfor_lo = v9;
  v = v6->goid;
  runtime_printlock();
  sa.str = (uint8 *)"goroutine ";
  sa.len = 10;
  runtime_printstring(sa);
  runtime_printint(v);
  sb.str = (uint8 *)" [";
  sb.len = 2;
  runtime_printstring(sb);
  runtime_printstring((string)__PAIR64__(v8, (unsigned int)v7));
  runtime_printunlock();
  if ( (v20 & 0x1000) != 0 )
  {
    runtime_printlock();
    sc.str = (uint8 *)" (scan)";
    sc.len = 7;
    runtime_printstring(sc);
    runtime_printunlock();
  }
  if ( SHIDWORD(waitfor_lo) > 0 || (_DWORD)waitfor_lo != 0 && HIDWORD(waitfor_lo) == 0 )
  {
    runtime_printlock();
    sd.str = (uint8 *)", ";
    sd.len = 2;
    runtime_printstring(sd);
    runtime_printint(waitfor_lo);
    se.str = (uint8 *)" minutes";
    se.len = 8;
    runtime_printstring(se);
    runtime_printunlock();
  }
  if ( gp->lockedm )
  {
    runtime_printlock();
    sf.str = (uint8 *)", locked to thread";
    sf.len = 18;
    runtime_printstring(sf);
    runtime_printunlock();
  }
  runtime_printlock();
  sg.str = (uint8 *)"]:\n";
  sg.len = 3;
  runtime_printstring(sg);
  runtime_printunlock();
}
// 8088518: variable 's' is possibly undefined

//----- (08088590) --------------------------------------------------------
void __golang runtime_tracebackothers(runtime_g *me)
{
  runtime_g *curg; // ecx
  __int32 len; // eax
  runtime_g **array; // ecx
  __int32 i; // edx
  runtime_g *v5; // ebx
  uintptr startpc; // ecx
  bool v7; // cl
  runtime_g *v8; // eax
  runtime_mutex_0 *l; // [esp+0h] [ebp-2Ch]
  runtime_mutex_0 *la; // [esp+0h] [ebp-2Ch]
  string lc; // [esp+0h] [ebp-2Ch]
  string ld; // [esp+0h] [ebp-2Ch]
  string lb; // [esp+0h] [ebp-2Ch]
  bool sp_0; // [esp+4h] [ebp-28h]
  bool lr; // [esp+8h] [ebp-24h]
  int32 level; // [esp+10h] [ebp-1Ch]
  __int32 v17; // [esp+14h] [ebp-18h]
  __int32 v18; // [esp+18h] [ebp-14h]
  runtime_g *gp; // [esp+1Ch] [ebp-10h]
  runtime_g *g; // [esp+24h] [ebp-8h]
  runtime_g **v21; // [esp+28h] [ebp-4h]

  runtime_gotraceback((int32)l, sp_0, lr);
  g = *(runtime_g **)(__readgsdword(0) - 4);
  level = (int32)la;
  curg = g->m->curg;
  if ( curg && me != curg )
  {
    gp = g->m->curg;
    runtime_printlock();
    lb.str = (uint8 *)"\n";
    lb.len = 1;
    runtime_printstring(lb);
    runtime_printunlock();
    runtime_goroutineheader(gp);
    runtime_traceback(0xFFFFFFFF, 0xFFFFFFFF, 0, gp);
  }
  runtime_lock(&runtime_allglock);
  len = runtime_allgs.len;
  v18 = runtime_allgs.len;
  array = runtime_allgs.array;
  for ( i = 0; i < len; ++i )
  {
    v5 = *array;
    if ( me != *array && v5 != g->m->curg )
    {
      v17 = i;
      v21 = array;
      if ( runtime_readgstatus(v5) == 6
        || ((startpc = v5->startpc, runtime_runfinqPC == startpc) && !runtime_fingRunning ? (v7 = 1) : runtime_bgsweepPC != startpc ? (runtime_forcegchelperPC != startpc ? (runtime_timerprocPC != startpc ? (v7 = runtime_gcBgMarkWorkerPC == startpc) : (v7 = 1)) : (v7 = 1)) : (v7 = 1),
            v7 && level < 2) )
      {
        len = v18;
        array = v21;
        i = v17;
        goto LABEL_5;
      }
      runtime_printlock();
      lc.str = (uint8 *)"\n";
      lc.len = 1;
      runtime_printstring(lc);
      runtime_printunlock();
      runtime_goroutineheader(v5);
      v8 = v5;
      if ( v5->m == g->m )
      {
LABEL_18:
        runtime_traceback(0xFFFFFFFF, 0xFFFFFFFF, 0, v8);
      }
      else
      {
        if ( (runtime_readgstatus(v5) & 0xFFFFEFFF) != 2 )
        {
          v8 = v5;
          goto LABEL_18;
        }
        runtime_printlock();
        ld.str = (uint8 *)"\tgoroutine running on other thread; stack unavailable\n";
        ld.len = 54;
        runtime_printstring(ld);
        runtime_printunlock();
        runtime_printcreatedby(v5);
      }
      len = v18;
      array = v21;
      i = v17;
    }
LABEL_5:
    ++array;
  }
  runtime_unlock(&runtime_allglock);
}
// 8088590: could not find valid save-restore pair for esi
// 80885A9: variable 'l' is possibly undefined
// 80885A9: variable 'sp_0' is possibly undefined
// 80885A9: variable 'lr' is possibly undefined
// 80885C5: variable 'la' is possibly undefined

//----- (08088820) --------------------------------------------------------
void __golang runtime_printCgoTraceback(uintptr (*callers)[32])
{
  uintptr (*v1)[32]; // ecx
  int i; // eax
  uintptr (*v3)[32]; // eax
  int j; // ecx
  string pc; // [esp+0h] [ebp-38h]
  string pca; // [esp+0h] [ebp-38h]
  uintptr c; // [esp+10h] [ebp-28h]
  int v8; // [esp+14h] [ebp-24h]
  int v9; // [esp+14h] [ebp-24h]
  uintptr (*v10)[32]; // [esp+18h] [ebp-20h]
  uintptr (*v11)[32]; // [esp+18h] [ebp-20h]
  runtime_cgoSymbolizerArg_0 arg; // [esp+1Ch] [ebp-1Ch] BYREF

  if ( runtime_cgoSymbolizer )
  {
    ((void (*)(void))loc_808FD89)();
    v1 = callers;
    for ( i = 0; i < 32 && (*v1)[0]; i = v8 + 1 )
    {
      v8 = i;
      v10 = v1;
      runtime_printOneCgoTraceback((*v1)[0], 0x7FFFFFFF, &arg);
      v1 = (uintptr (*)[32])((char *)v10 + 4);
    }
    arg.pc = 0;
    runtime_callCgoSymbolizer(&arg);
  }
  else
  {
    v3 = callers;
    for ( j = 0; j < 32 && (*v3)[0]; j = v9 + 1 )
    {
      v9 = j;
      c = (*v3)[0];
      v11 = v3;
      runtime_printlock();
      pc.str = (uint8 *)"non-Go function at pc=";
      pc.len = 22;
      runtime_printstring(pc);
      runtime_printhex(c);
      pca.str = (uint8 *)"\n";
      pca.len = 1;
      runtime_printstring(pca);
      runtime_printunlock();
      v3 = (uintptr (*)[32])((char *)v11 + 4);
    }
  }
}

//----- (08088930) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
__int32 __golang runtime_printOneCgoTraceback(uintptr pc, __int32 max, runtime_cgoSymbolizerArg_0 *arg)
{
  runtime_cgoSymbolizerArg_0 *v3; // ecx
  __int32 i; // edx
  __int32 v5; // eax
  string s; // [esp+0h] [ebp-1Ch]
  string sc; // [esp+0h] [ebp-1Ch]
  string sd; // [esp+0h] [ebp-1Ch]
  const char *sa; // [esp+0h] [ebp-1Ch]
  const char *sb; // [esp+0h] [ebp-1Ch]
  string se; // [esp+0h] [ebp-1Ch]
  string s_4; // [esp+4h] [ebp-18h]
  string s_4a; // [esp+4h] [ebp-18h] OVERLAPPED
  __int32 c; // [esp+Ch] [ebp-10h]
  uintptr v; // [esp+10h] [ebp-Ch]

  v3 = arg;
  arg->pc = pc;
  for ( i = 0; i <= max; i = c + 1 )
  {
    c = i;
    runtime_callCgoSymbolizer(v3);
    if ( arg->funcName )
    {
      s_4 = runtime_gostringnocopy(arg->funcName);
      runtime_printlock();
      runtime_printstring(s_4);
    }
    else
    {
      runtime_printlock();
      se.str = (uint8 *)"non-Go function";
      se.len = 15;
      runtime_printstring(se);
    }
    runtime_printnl();
    runtime_printunlock();
    runtime_printlock();
    s.str = (uint8 *)"\t";
    s.len = 1;
    runtime_printstring(s);
    runtime_printunlock();
    if ( arg->file )
    {
      s_4a = runtime_gostringnocopy(arg->file);
      v = arg->lineno;
      runtime_printlock();
      runtime_printstring(s_4a);
      sa = ":";
      s_4a.str = (uint8 *)1;
      runtime_printstring(*(string *)((char *)&s_4a - 4));
      runtime_printint(v);
      sb = " ";
      s_4a.str = (uint8 *)1;
      runtime_printstring(*(string *)((char *)&s_4a - 4));
      runtime_printunlock();
    }
    runtime_printlock();
    sc.str = (uint8 *)"pc=";
    sc.len = 3;
    runtime_printstring(sc);
    runtime_printhex(pc);
    sd.str = (uint8 *)"\n";
    sd.len = 1;
    runtime_printstring(sd);
    runtime_printunlock();
    v5 = c + 1;
    v3 = arg;
    if ( !arg->more )
      return v5;
  }
  return i;
}
// 8088A54: failed to expand linear variable ^4.8
// 80E0D84: using guessed type char go_string__;
// 80E0D8F: using guessed type char asc_80E0D8F;
// 80E0D9D: using guessed type char asc_80E0D9D;

//----- (08088B20) --------------------------------------------------------
void __golang runtime_callCgoSymbolizer(runtime_cgoSymbolizerArg_0 *arg)
{
  int (__golang **v1)(int, int, int); // eax
  int v2; // eax

  if ( runtime_panicking || (v2 = *(_DWORD *)(__readgsdword(0) - 4), *(_DWORD *)(*(_DWORD *)(v2 + 24) + 84) != v2) )
    v1 = &off_80E7B8C;
  else
    v1 = (int (__golang **)(int, int, int))&off_80E7BC0;
  ((void (__golang *)(void *, runtime_cgoSymbolizerArg_0 *))*v1)(runtime_cgoSymbolizer, arg);
}
// 80E7B8C: using guessed type int (__golang *off_80E7B8C)(int, int, int);
// 80E7BC0: using guessed type int (__golang *off_80E7BC0)(void *fn, void *arg, int32 _r2);

//----- (08088B90) --------------------------------------------------------
void __golang runtime_cgoContextPCs(uintptr ctxt, __uintptr buf)
{
  int (__golang **v2)(int, int, int); // eax
  int v3; // eax
  runtime_cgoTracebackArg_0 arg; // [esp+Ch] [ebp-10h] BYREF

  if ( runtime_cgoTraceback )
  {
    if ( runtime_panicking || (v3 = *(_DWORD *)(__readgsdword(0) - 4), *(_DWORD *)(*(_DWORD *)(v3 + 24) + 84) != v3) )
      v2 = &off_80E7B8C;
    else
      v2 = (int (__golang **)(int, int, int))&off_80E7BC0;
    if ( !buf.len )
      runtime_panicindex();
    arg.sigContext = 0;
    arg.context = ctxt;
    arg.buf = buf.array;
    arg.max = buf.len;
    ((void (__golang *)(void *, runtime_cgoTracebackArg_0 *))*v2)(runtime_cgoTraceback, &arg);
  }
}
// 80E7B8C: using guessed type int (__golang *off_80E7B8C)(int, int, int);
// 80E7BC0: using guessed type int (__golang *off_80E7BC0)(void *fn, void *arg, int32 _r2);

//----- (08088C40) --------------------------------------------------------
string __golang runtime___ptr__type__string(runtime__type_0 *t)
{
  string offa; // [esp+4h] [ebp-8h]
  string off; // [esp+4h] [ebp-8h]
  string _r0; // [esp+14h] [ebp+8h]

  offa.len = (__int32)runtime___ptr__type__nameOff(t, t->str).bytes;
  runtime_name_name((runtime_name_0)offa.len, offa);
  if ( (t->tflag & 2) == 0 )
    return off;
  if ( !off.len )
    runtime_panicslice();
  _r0.str = &off.str[((1 - off.len) >> 31) & 1];
  _r0.len = off.len - 1;
  return _r0;
}
// 8088C6F: variable 'offa' is possibly undefined
// 8088C8C: variable 'off' is possibly undefined

//----- (08088CD0) --------------------------------------------------------
runtime_uncommontype *__golang runtime___ptr__type__uncommon(runtime__type_0 *t)
{
  unsigned __int8 v1; // cl

  if ( (t->tflag & 1) == 0 )
    return 0;
  v1 = t->kind & 0x1F;
  if ( v1 > 0x14u )
  {
    if ( v1 > 0x16u )
    {
      if ( v1 == 23 )
      {
        return (runtime_uncommontype *)&t[1].ptrdata;
      }
      else
      {
        if ( v1 != 25 )
          return (runtime_uncommontype *)&t[1];
        return (runtime_uncommontype *)&t[1].alg;
      }
    }
    else if ( v1 == 21 )
    {
      return (runtime_uncommontype *)&t[1].str;
    }
    else
    {
      return (runtime_uncommontype *)&t[1].ptrdata;
    }
  }
  else if ( v1 > 0x12u )
  {
    if ( v1 == 19 )
      return (runtime_uncommontype *)&t[1].ptrdata;
    else
      return (runtime_uncommontype *)&t[1].alg;
  }
  else if ( v1 == 17 )
  {
    return (runtime_uncommontype *)&t[1].tflag;
  }
  else
  {
    if ( v1 != 18 )
      return (runtime_uncommontype *)&t[1];
    return (runtime_uncommontype *)&t[1].hash;
  }
}

//----- (08088D90) --------------------------------------------------------
void __golang runtime_reflectOffsLock()
{
  runtime_lock(&runtime_reflectOffs.lock);
}

//----- (08088DC0) --------------------------------------------------------
void __golang runtime_reflectOffsUnlock()
{
  runtime_unlock(&runtime_reflectOffs.lock);
}

//----- (08088DF0) --------------------------------------------------------
runtime_name_0 __golang runtime_resolveNameOff(void *ptrInModule, runtime_nameOff off)
{
  runtime_moduledata *i; // edx
  unsigned int types; // ebx
  unsigned int etypes; // ebp
  runtime_moduledata *j; // eax
  string t; // [esp+0h] [ebp-2Ch]
  string ta; // [esp+0h] [ebp-2Ch]
  string tb; // [esp+0h] [ebp-2Ch]
  string tc; // [esp+0h] [ebp-2Ch]
  string td; // [esp+0h] [ebp-2Ch]
  string te; // [esp+0h] [ebp-2Ch]
  string tf; // [esp+0h] [ebp-2Ch]
  string tg; // [esp+0h] [ebp-2Ch]
  string th; // [esp+0h] [ebp-2Ch]
  string ti; // [esp+0h] [ebp-2Ch]
  retval_80511B0 v16; // [esp+Ch] [ebp-20h]
  uintptr v; // [esp+1Ch] [ebp-10h]
  uintptr v_4; // [esp+20h] [ebp-Ch]
  uintptr v_4a; // [esp+20h] [ebp-Ch]
  runtime_name_0 v20; // [esp+24h] [ebp-8h]
  runtime_moduledata_0 *next; // [esp+28h] [ebp-4h]

  if ( !off )
    return 0;
  for ( i = &runtime_firstmoduledata; i; i = i->next )
  {
    types = i->types;
    if ( (unsigned int)ptrInModule >= types )
    {
      etypes = i->etypes;
      if ( (unsigned int)ptrInModule < etypes )
      {
        if ( types + off > etypes )
        {
          v_4a = i->types;
          runtime_printlock();
          tf.str = (uint8 *)"runtime: nameOff";
          tf.len = 16;
          runtime_printstring(tf);
          runtime_printsp();
          runtime_printhex(off);
          runtime_printsp();
          tg.str = (uint8 *)"out of range";
          tg.len = 12;
          runtime_printstring(tg);
          runtime_printsp();
          runtime_printhex(v_4a);
          runtime_printsp();
          th.str = (uint8 *)"-";
          th.len = 1;
          runtime_printstring(th);
          runtime_printsp();
          runtime_printhex(etypes);
          runtime_printnl();
          runtime_printunlock();
          ti.str = (uint8 *)"runtime: name offset out of range";
          ti.len = 33;
          runtime_throw(ti);
          BUG();
        }
        return (runtime_name_0)(types + off);
      }
    }
  }
  runtime_reflectOffsLock();
  v16 = runtime_mapaccess2_fast32((runtime_maptype_0 *)&stru_80CFA40, (runtime_hmap *)runtime_reflectOffs.m, off);
  v20.bytes = *(uint8 **)v16._r3;
  runtime_reflectOffsUnlock();
  if ( !v16._r4 )
  {
    runtime_printlock();
    t.str = (uint8 *)"runtime: nameOff";
    t.len = 16;
    runtime_printstring(t);
    runtime_printsp();
    runtime_printhex(off);
    runtime_printsp();
    ta.str = (uint8 *)"base";
    ta.len = 4;
    runtime_printstring(ta);
    runtime_printsp();
    runtime_printhex((unsigned int)ptrInModule);
    runtime_printsp();
    tb.str = (uint8 *)"not in ranges:";
    tb.len = 14;
    runtime_printstring(tb);
    runtime_printnl();
    runtime_printunlock();
    for ( j = &runtime_firstmoduledata; j; j = next->next )
    {
      next = j;
      v_4 = j->types;
      v = j->etypes;
      runtime_printlock();
      tc.str = (uint8 *)"\ttypes";
      tc.len = 6;
      runtime_printstring(tc);
      runtime_printsp();
      runtime_printhex(v_4);
      runtime_printsp();
      td.str = (uint8 *)"etypes";
      td.len = 6;
      runtime_printstring(td);
      runtime_printsp();
      runtime_printhex(v);
      runtime_printnl();
      runtime_printunlock();
    }
    te.str = (uint8 *)"runtime: name offset base pointer out of range";
    te.len = 46;
    runtime_throw(te);
    BUG();
  }
  return v20;
}
// 80E0D8A: using guessed type char asc_80E0D8A;

//----- (080890D0) --------------------------------------------------------
runtime_name_0 __golang runtime___ptr__type__nameOff(runtime__type_0 *t, runtime_nameOff off)
{
  return runtime_resolveNameOff(t, off);
}

//----- (08089110) --------------------------------------------------------
runtime__type_0 *__golang runtime_resolveTypeOff(void *ptrInModule, runtime_typeOff off)
{
  runtime_moduledata *i; // edx
  uintptr types; // ecx
  runtime_moduledata *j; // eax
  string t; // [esp+0h] [ebp-28h]
  string ta; // [esp+0h] [ebp-28h]
  string tb; // [esp+0h] [ebp-28h]
  string tc; // [esp+0h] [ebp-28h]
  string td; // [esp+0h] [ebp-28h]
  string tf; // [esp+0h] [ebp-28h]
  string tg; // [esp+0h] [ebp-28h]
  string th; // [esp+0h] [ebp-28h]
  string ti; // [esp+0h] [ebp-28h]
  string te; // [esp+0h] [ebp-28h]
  runtime__type_0 **v15; // [esp+Ch] [ebp-1Ch]
  uintptr v; // [esp+14h] [ebp-14h]
  uintptr va; // [esp+14h] [ebp-14h]
  uintptr v_4; // [esp+18h] [ebp-10h]
  uintptr v_4a; // [esp+18h] [ebp-10h]
  runtime__type_0 *v20; // [esp+1Ch] [ebp-Ch]
  runtime_moduledata_0 *next; // [esp+20h] [ebp-8h]
  runtime_moduledata_0 *md; // [esp+24h] [ebp-4h]

  if ( !off )
    return 0;
  for ( i = &runtime_firstmoduledata; i; i = i->next )
  {
    if ( (unsigned int)ptrInModule >= i->types && (unsigned int)ptrInModule < i->etypes )
      goto LABEL_7;
  }
  i = 0;
LABEL_7:
  if ( i )
  {
    md = i;
    v15 = (runtime__type_0 **)runtime_mapaccess1_fast32(
                                (runtime_maptype_0 *)&stru_80CFB00,
                                (runtime_hmap *)i->typemap,
                                off);
    if ( *v15 )
    {
      return *v15;
    }
    else
    {
      types = md->types;
      if ( types + off > md->etypes )
      {
        v_4a = md->types;
        va = md->etypes;
        runtime_printlock();
        tf.str = (uint8 *)"runtime: typeOff";
        tf.len = 16;
        runtime_printstring(tf);
        runtime_printsp();
        runtime_printhex(off);
        runtime_printsp();
        tg.str = (uint8 *)"out of range";
        tg.len = 12;
        runtime_printstring(tg);
        runtime_printsp();
        runtime_printhex(v_4a);
        runtime_printsp();
        th.str = (uint8 *)"-";
        th.len = 1;
        runtime_printstring(th);
        runtime_printsp();
        runtime_printhex(va);
        runtime_printnl();
        runtime_printunlock();
        ti.str = (uint8 *)"runtime: type offset out of range";
        ti.len = 33;
        runtime_throw(ti);
        BUG();
      }
      return (runtime__type_0 *)(types + off);
    }
  }
  else
  {
    runtime_reflectOffsLock();
    v20 = *(runtime__type_0 **)runtime_mapaccess1_fast32(
                                 (runtime_maptype_0 *)&stru_80CFA40,
                                 (runtime_hmap *)runtime_reflectOffs.m,
                                 off);
    runtime_reflectOffsUnlock();
    if ( !v20 )
    {
      runtime_printlock();
      t.str = (uint8 *)"runtime: typeOff";
      t.len = 16;
      runtime_printstring(t);
      runtime_printsp();
      runtime_printhex(off);
      runtime_printsp();
      ta.str = (uint8 *)"base";
      ta.len = 4;
      runtime_printstring(ta);
      runtime_printsp();
      runtime_printhex((unsigned int)ptrInModule);
      runtime_printsp();
      tb.str = (uint8 *)"not in ranges:";
      tb.len = 14;
      runtime_printstring(tb);
      runtime_printnl();
      runtime_printunlock();
      for ( j = &runtime_firstmoduledata; j; j = next->next )
      {
        next = j;
        v_4 = j->types;
        v = j->etypes;
        runtime_printlock();
        tc.str = (uint8 *)"\ttypes";
        tc.len = 6;
        runtime_printstring(tc);
        runtime_printsp();
        runtime_printhex(v_4);
        runtime_printsp();
        td.str = (uint8 *)"etypes";
        td.len = 6;
        runtime_printstring(td);
        runtime_printsp();
        runtime_printhex(v);
        runtime_printnl();
        runtime_printunlock();
      }
      te.str = (uint8 *)"runtime: type offset base pointer out of range";
      te.len = 46;
      runtime_throw(te);
      BUG();
    }
    return v20;
  }
}
// 80E0D8A: using guessed type char asc_80E0D8A;

//----- (08089430) --------------------------------------------------------
runtime__type_0 *__golang runtime___ptr__type__typeOff(runtime__type_0 *t, runtime_typeOff off)
{
  return runtime_resolveTypeOff(t, off);
}

//----- (08089470) --------------------------------------------------------
void *__golang runtime___ptr__type__textOff(runtime__type_0 *t, runtime_textOff off)
{
  runtime_moduledata *i; // ecx
  runtime_textsect *array; // eax
  int len; // edx
  int j; // ebp
  unsigned int vaddr; // edi
  void *v7; // eax
  runtime_moduledata *k; // eax
  string s; // [esp+0h] [ebp-28h]
  string sa; // [esp+0h] [ebp-28h]
  string sb; // [esp+0h] [ebp-28h]
  string sc; // [esp+0h] [ebp-28h]
  string sd; // [esp+0h] [ebp-28h]
  string sf; // [esp+0h] [ebp-28h]
  string sg; // [esp+0h] [ebp-28h]
  string sh; // [esp+0h] [ebp-28h]
  string si; // [esp+0h] [ebp-28h]
  string se; // [esp+0h] [ebp-28h]
  uintptr v; // [esp+14h] [ebp-14h]
  uintptr va; // [esp+14h] [ebp-14h]
  uintptr v_4; // [esp+18h] [ebp-10h]
  uintptr v_4a; // [esp+18h] [ebp-10h]
  void *v23; // [esp+1Ch] [ebp-Ch]
  runtime_moduledata_0 *next; // [esp+20h] [ebp-8h]

  for ( i = &runtime_firstmoduledata; i; i = i->next )
  {
    if ( (unsigned int)t >= i->types && (unsigned int)t < i->etypes )
      goto LABEL_6;
  }
  i = 0;
LABEL_6:
  if ( i )
  {
    array = i->textsectmap.array;
    len = i->textsectmap.len;
    if ( len <= 1 )
    {
      v7 = (void *)(off + i->text);
    }
    else
    {
      for ( j = 0; j < len; ++j )
      {
        if ( j >= (unsigned int)len )
          runtime_panicindex();
        vaddr = array[j].vaddr;
        if ( off >= vaddr && off <= vaddr + array[j].length )
        {
          v7 = (void *)(off + array[j].baseaddr - vaddr);
          goto LABEL_15;
        }
      }
      v7 = 0;
    }
LABEL_15:
    if ( (unsigned int)v7 > i->etext )
    {
      v_4a = i->etext;
      va = i->text;
      runtime_printlock();
      sf.str = (uint8 *)"runtime: textOff";
      sf.len = 16;
      runtime_printstring(sf);
      runtime_printsp();
      runtime_printhex(off);
      runtime_printsp();
      sg.str = (uint8 *)"out of range";
      sg.len = 12;
      runtime_printstring(sg);
      runtime_printsp();
      runtime_printhex(va);
      runtime_printsp();
      sh.str = (uint8 *)"-";
      sh.len = 1;
      runtime_printstring(sh);
      runtime_printsp();
      runtime_printhex(v_4a);
      runtime_printnl();
      runtime_printunlock();
      si.str = (uint8 *)"runtime: text offset out of range";
      si.len = 33;
      runtime_throw(si);
      BUG();
    }
    return v7;
  }
  else
  {
    runtime_reflectOffsLock();
    v23 = *(void **)runtime_mapaccess1_fast32(
                      (runtime_maptype_0 *)&stru_80CFA40,
                      (runtime_hmap *)runtime_reflectOffs.m,
                      off);
    runtime_reflectOffsUnlock();
    if ( !v23 )
    {
      runtime_printlock();
      s.str = (uint8 *)"runtime: textOff";
      s.len = 16;
      runtime_printstring(s);
      runtime_printsp();
      runtime_printhex(off);
      runtime_printsp();
      sa.str = (uint8 *)"base";
      sa.len = 4;
      runtime_printstring(sa);
      runtime_printsp();
      runtime_printhex((unsigned int)t);
      runtime_printsp();
      sb.str = (uint8 *)"not in ranges:";
      sb.len = 14;
      runtime_printstring(sb);
      runtime_printnl();
      runtime_printunlock();
      for ( k = &runtime_firstmoduledata; k; k = next->next )
      {
        next = k;
        v_4 = k->types;
        v = k->etypes;
        runtime_printlock();
        sc.str = (uint8 *)"\ttypes";
        sc.len = 6;
        runtime_printstring(sc);
        runtime_printsp();
        runtime_printhex(v_4);
        runtime_printsp();
        sd.str = (uint8 *)"etypes";
        sd.len = 6;
        runtime_printstring(sd);
        runtime_printsp();
        runtime_printhex(v);
        runtime_printnl();
        runtime_printunlock();
      }
      se.str = (uint8 *)"runtime: text offset base pointer out of range";
      se.len = 46;
      runtime_throw(se);
      BUG();
    }
    return v23;
  }
}
// 80E0D8A: using guessed type char asc_80E0D8A;

//----- (080897A0) --------------------------------------------------------
__int32 __golang runtime_name_tagLen(runtime_name_0 n)
{
  if ( (*n.bytes & 2) != 0 )
    return _byteswap_ushort(*(_WORD *)&n.bytes[_byteswap_ushort(*(_WORD *)(n.bytes + 1)) + 3]);
  else
    return 0;
}

//----- (08089810) --------------------------------------------------------
void __golang runtime_name_name(runtime_name_0 n, string s)
{
  ;
}

//----- (08089890) --------------------------------------------------------
void __golang runtime_name_tag(runtime_name_0 n, string s)
{
  runtime_name_tagLen(n);
}

//----- (08089910) --------------------------------------------------------
string __golang runtime_name_pkgPath(runtime_name_0 n)
{
  string off; // [esp+4h] [ebp-10h]
  string offa; // [esp+4h] [ebp-10h]
  string _r0; // [esp+1Ch] [ebp+8h]

  if ( n.bytes && (*n.bytes & 4) != 0 )
  {
    runtime_name_tagLen(n);
    runtime_memmove();
    off.len = (__int32)runtime_resolveNameOff(n.bytes, 0).bytes;
    runtime_name_name((runtime_name_0)off.len, off);
    return offa;
  }
  else
  {
    _r0.str = 0;
    _r0.len = 0;
  }
  return _r0;
}
// 80899D3: variable 'off' is possibly undefined
// 80899E0: variable 'offa' is possibly undefined

//----- (08089A00) --------------------------------------------------------
void __golang runtime_typelinksinit()
{
  runtime_moduledata_0 *v0; // eax
  runtime_moduledata_0 **v1; // ecx
  __int32 v2; // edx
  __int32 i; // ebx
  runtime__type_0 **count; // edx
  __int32 k; // esi
  uint32 *array; // esi
  runtime_moduledata_0 *v7; // ebp
  __int32 v8; // edi
  uint32 v9; // ebx
  runtime_hmap *typemap; // ecx
  runtime__type_0 *v11; // ecx
  __int32 hash0; // ecx
  __int32 v13; // eax
  uintptr v14; // ebx
  uintptr *v15; // ebp
  __int32 v16; // edx
  uintptr *v17; // eax
  runtime_hmap *v18; // eax
  __int32 v19; // edx
  map_runtime_typeOff__runtime__type *v20; // ebx
  runtime_moduledata_0 *v21; // ecx
  __int32 v22; // eax
  uint32 *v23; // edx
  __int32 m; // ebx
  runtime__type_0 **v25; // eax
  int v26; // edx
  int v27; // ecx
  runtime__type_0 *v28; // eax
  map_runtime_typeOff__runtime__type *v29; // eax
  __int32 v30; // ecx
  ___runtime_moduledata v31; // [esp+0h] [ebp-128h]
  runtime_slice_0 hint; // [esp+4h] [ebp-124h]
  runtime_hmap *h; // [esp+Ch] [ebp-11Ch]
  runtime_hmap *ha; // [esp+Ch] [ebp-11Ch]
  runtime_hmap *hb; // [esp+Ch] [ebp-11Ch]
  runtime_slice_0 seena; // [esp+14h] [ebp-114h]
  hash<runtime__typePair,struct {}> *seenb; // [esp+14h] [ebp-114h]
  runtime_slice_0 seen; // [esp+14h] [ebp-114h]
  __int32 tlist_len; // [esp+20h] [ebp-108h]
  uint32 tl; // [esp+24h] [ebp-104h]
  __int32 v41; // [esp+2Ch] [ebp-FCh]
  int v42; // [esp+2Ch] [ebp-FCh]
  __int32 v43; // [esp+30h] [ebp-F8h]
  int v44; // [esp+30h] [ebp-F8h]
  __int32 j; // [esp+34h] [ebp-F4h]
  __int32 v46; // [esp+38h] [ebp-F0h]
  __int32 v47; // [esp+38h] [ebp-F0h]
  __int32 v48; // [esp+3Ch] [ebp-ECh]
  __int32 len; // [esp+40h] [ebp-E8h]
  __int32 v50; // [esp+40h] [ebp-E8h]
  runtime_hmap *typehash; // [esp+4Ch] [ebp-DCh]
  map_runtime_typeOff__runtime__type tm; // [esp+50h] [ebp-D8h]
  runtime__type_0 *t; // [esp+54h] [ebp-D4h]
  runtime__type_0 *t_0; // [esp+58h] [ebp-D0h]
  runtime_moduledata_0 *prev; // [esp+5Ch] [ebp-CCh]
  runtime_moduledata_0 *md; // [esp+60h] [ebp-C8h]
  runtime__type_0 *candidate; // [esp+64h] [ebp-C4h]
  runtime__type_0 *v58; // [esp+6Ch] [ebp-BCh]
  uintptr src; // [esp+74h] [ebp-B4h]
  uint32 *v60; // [esp+78h] [ebp-B0h]
  uint32 *v61; // [esp+78h] [ebp-B0h]
  runtime_moduledata_0 **v62; // [esp+7Ch] [ebp-ACh]
  runtime_hmap v63; // [esp+80h] [ebp-A8h] BYREF
  char bucket[140]; // [esp+9Ch] [ebp-8Ch] BYREF

  while ( (unsigned int)&v63 <= *(_DWORD *)(*(_DWORD *)(__readgsdword(0) - 4) + 8) )
    runtime_morestack_noctxt();
  if ( runtime_firstmoduledata.next )
  {
    len = runtime_firstmoduledata.typelinks.len;
    ((void (*)(void))loc_808FD89)();
    ((void (*)(void))loc_808FD6D)();
    typehash = runtime_makemap((runtime_maptype_0 *)&stru_80CFC00, len, &v63, bucket);
    v31 = runtime_activeModules();
    if ( !v31.len )
      runtime_panicindex();
    v0 = *v31.array;
    v1 = (runtime_moduledata_0 **)((char *)v31.array + (((1 - v31.cap) >> 31) & 4));
    v2 = v31.len - 1;
    v50 = v31.len - 1;
    for ( i = 0; i < v2; ++i )
    {
      v48 = i;
      prev = v0;
      v62 = v1;
      v7 = *v1;
      md = *v1;
      array = (uint32 *)v0->typelinks.array;
      v8 = v0->typelinks.len;
      v46 = v8;
      for ( j = 0; j < v8; ++j )
      {
        v60 = array;
        v9 = *array;
        typemap = (runtime_hmap *)v0->typemap;
        if ( typemap )
          v11 = *(runtime__type_0 **)runtime_mapaccess1_fast32((runtime_maptype_0 *)&stru_80CFB00, typemap, v9);
        else
          v11 = (runtime__type_0 *)(v9 + v0->types);
        t = v11;
        h = (runtime_hmap *)runtime_mapaccess1_fast32((runtime_maptype_0 *)&stru_80CFC00, typehash, v11->hash);
        hash0 = h->hash0;
        count = (runtime__type_0 **)h->count;
        v13 = *(_DWORD *)&h->flags;
        v14 = (uintptr)t;
        v15 = (uintptr *)h->count;
        for ( k = 0; k < v13; ++k )
        {
          if ( *count == t )
            goto LABEL_8;
          ++count;
        }
        v16 = v13 + 1;
        if ( v13 + 1 > hash0 )
        {
          tlist_len = *(_DWORD *)&h->flags;
          hint.array = (void *)h->count;
          *(_QWORD *)&hint.len = __PAIR64__(hash0, v13);
          seena = runtime_growslice((runtime__type_0 *)&stru_80D8DA0, hint, v13 + 1);
          v15 = (uintptr *)seena.array;
          hash0 = seena.cap;
          v16 = seena.len + 1;
          v13 = tlist_len;
          v14 = (uintptr)t;
        }
        v43 = v16;
        v41 = hash0;
        if ( *(_DWORD *)&runtime_writeBarrier.enabled )
        {
          runtime_writebarrierptr(&v15[v13], v14);
          v14 = (uintptr)t;
        }
        else
        {
          v15[v13] = v14;
        }
        v17 = (uintptr *)runtime_mapassign_fast32((runtime_maptype_0 *)&stru_80CFC00, typehash, *(_DWORD *)(v14 + 8));
        v17[1] = v43;
        v17[2] = v41;
        if ( *(_DWORD *)&runtime_writeBarrier.enabled )
          runtime_writebarrierptr(v17, (uintptr)v15);
        else
          *v17 = (uintptr)v15;
LABEL_8:
        array = v60 + 1;
        v1 = v62;
        i = v48;
        v7 = md;
        v8 = v46;
        v0 = prev;
      }
      if ( !v7->typemap )
      {
        v18 = runtime_makemap((runtime_maptype_0 *)&stru_80CFB00, v7->typelinks.len, 0, 0);
        tm = (map_runtime_typeOff__runtime__type)v18;
        v19 = runtime_pinnedTypemaps.len;
        v20 = runtime_pinnedTypemaps.array;
        if ( runtime_pinnedTypemaps.len + 1 > runtime_pinnedTypemaps.cap )
        {
          seen = runtime_growslice(
                   &stru_80CFB00.typ,
                   (runtime_slice_0)runtime_pinnedTypemaps,
                   runtime_pinnedTypemaps.len + 1);
          v29 = (map_runtime_typeOff__runtime__type *)seen.array;
          v30 = seen.len;
          runtime_pinnedTypemaps.cap = seen.cap;
          if ( *(_DWORD *)&runtime_writeBarrier.enabled )
          {
            runtime_writebarrierptr((uintptr *)&runtime_pinnedTypemaps, (uintptr)seen.array);
            v29 = (map_runtime_typeOff__runtime__type *)seen.array;
            v30 = seen.len;
          }
          else
          {
            runtime_pinnedTypemaps.array = (map_runtime_typeOff__runtime__type *)seen.array;
          }
          v19 = v30;
          v20 = v29;
          v18 = (runtime_hmap *)tm;
        }
        runtime_pinnedTypemaps.len = v19 + 1;
        if ( *(_DWORD *)&runtime_writeBarrier.enabled )
        {
          runtime_writebarrierptr((uintptr *)&v20[v19], (uintptr)v18);
          runtime_writebarrierptr((uintptr *)&v7->typemap, (uintptr)tm);
          v21 = md;
        }
        else
        {
          v20[v19] = (map_runtime_typeOff__runtime__type)v18;
          v21 = md;
          md->typemap = (map_runtime_typeOff__runtime__type)v18;
        }
        v22 = v21->typelinks.len;
        v47 = v22;
        v23 = (uint32 *)v21->typelinks.array;
        for ( m = 0; m < v22; ++m )
        {
          v61 = v23;
          tl = *v23;
          v58 = (runtime__type_0 *)(*v23 + v21->types);
          hb = (runtime_hmap *)runtime_mapaccess1_fast32((runtime_maptype_0 *)&stru_80CFC00, typehash, v58->hash);
          v27 = *(_DWORD *)&hb->flags;
          v44 = v27;
          v25 = (runtime__type_0 **)hb->count;
          v26 = 0;
          while ( v26 < v27 )
          {
            v42 = v26;
            src = (uintptr)v25;
            candidate = *v25;
            seenb = (hash<runtime__typePair,struct {}> *)runtime_makemap((runtime_maptype_0 *)&stru_80CFAC0, 0LL, 0, 0);
            if ( runtime_typesEqual(v58, candidate, seenb) )
            {
              v28 = candidate;
              goto LABEL_34;
            }
            v25 = (runtime__type_0 **)(src + 4);
            v26 = v42 + 1;
            v27 = v44;
          }
          v28 = v58;
LABEL_34:
          t_0 = v28;
          ha = (runtime_hmap *)runtime_mapassign_fast32(
                                 (runtime_maptype_0 *)&stru_80CFB00,
                                 (runtime_hmap *)md->typemap,
                                 tl);
          if ( *(_DWORD *)&runtime_writeBarrier.enabled )
            runtime_writebarrierptr((uintptr *)ha, (uintptr)t_0);
          else
            ha->count = (__int32)t_0;
          v23 = v61 + 1;
          v22 = v47;
          v21 = md;
        }
        v1 = v62;
        i = v48;
        v7 = md;
      }
      ++v1;
      v2 = v50;
      v0 = v7;
    }
  }
}
// 8089A00: using guessed type char var_8C[140];

//----- (08089F40) --------------------------------------------------------
bool __golang runtime_typesEqual(runtime__type_0 *t, runtime__type_0 *v, map_runtime__typePair_struct_{} seen)
{
  uint8 v3; // bl
  string v4; // kr00_8
  bool v5; // zf
  runtime__type_0 *v6; // edx
  __int32 v7; // ecx
  unsigned __int32 v8; // ebx
  runtime__type_0 *v9; // eax
  int v10; // ebp
  char *v11; // ebp
  int v12; // esi
  char *v13; // esi
  unsigned int v14; // edi
  int v15; // ecx
  char *v16; // ecx
  __int16 v17; // bx
  unsigned __int16 size; // ax
  unsigned int v19; // ebp
  unsigned int v20; // eax
  __int32 v21; // eax
  runtime__type_0 **v22; // ecx
  int v23; // ebx
  char *v24; // ebx
  __int16 v25; // bp
  unsigned __int16 v26; // dx
  unsigned int v27; // esi
  unsigned int v28; // edx
  unsigned __int32 v29; // edx
  char *v30; // ebx
  unsigned int v31; // ebp
  runtime__type_0 *v32; // eax
  signed __int32 hash; // ecx
  runtime__type_0 *v34; // edx
  uint32 v35; // ebx
  uintptr ptrdata; // ebp
  uint32 v37; // edi
  uintptr v38; // edx
  runtime__type_0 *v42; // eax
  signed __int32 v43; // ecx
  runtime__type_0 *v44; // edx
  uint32 v45; // ebx
  uintptr v46; // esi
  uint32 v47; // edi
  uintptr v48; // edx
  __int32 v49; // ecx
  __int32 v50; // eax
  string n; // [esp+0h] [ebp-90h]
  string na; // [esp+0h] [ebp-90h]
  string h; // [esp+4h] [ebp-8Ch]
  string hb; // [esp+4h] [ebp-8Ch]
  string hc; // [esp+4h] [ebp-8Ch]
  string hd; // [esp+4h] [ebp-8Ch]
  string he; // [esp+4h] [ebp-8Ch]
  string hf; // [esp+4h] [ebp-8Ch]
  string hg; // [esp+4h] [ebp-8Ch]
  string hh; // [esp+4h] [ebp-8Ch]
  string hi; // [esp+4h] [ebp-8Ch]
  string ha; // [esp+4h] [ebp-8Ch]
  string hj; // [esp+4h] [ebp-8Ch]
  runtime_hmap *hk; // [esp+4h] [ebp-8Ch]
  string hl; // [esp+4h] [ebp-8Ch]
  string hm; // [esp+4h] [ebp-8Ch]
  runtime_hmap *hn; // [esp+4h] [ebp-8Ch]
  int key; // [esp+8h] [ebp-88h]
  int keya; // [esp+8h] [ebp-88h]
  runtime__type_0 *keyb; // [esp+8h] [ebp-88h]
  int keyc; // [esp+8h] [ebp-88h]
  uint8 *keyd; // [esp+8h] [ebp-88h]
  uint8 *keye; // [esp+8h] [ebp-88h]
  uint8 *keyf; // [esp+8h] [ebp-88h]
  retval_8051320 v75; // [esp+10h] [ebp-80h]
  unsigned __int8 v76; // [esp+10h] [ebp-80h]
  uint8 kind; // [esp+1Ah] [ebp-76h]
  __int32 vout_len; // [esp+1Ch] [ebp-74h]
  __int32 vin_len; // [esp+20h] [ebp-70h]
  __int32 tout_len; // [esp+24h] [ebp-6Ch]
  __int32 tin_len; // [esp+28h] [ebp-68h]
  uint8 *pkgpatht_len; // [esp+2Ch] [ebp-64h]
  __int32 v83; // [esp+40h] [ebp-50h]
  __int32 v84; // [esp+40h] [ebp-50h]
  uint8 *v85; // [esp+40h] [ebp-50h]
  __int32 len; // [esp+44h] [ebp-4Ch]
  __int32 v87; // [esp+44h] [ebp-4Ch]
  __int32 sb; // [esp+48h] [ebp-48h]
  uint32 s; // [esp+48h] [ebp-48h]
  uint32 sa; // [esp+48h] [ebp-48h]
  char *s_4; // [esp+4Ch] [ebp-44h]
  uint8 *vname_bytes; // [esp+50h] [ebp-40h]
  runtime_imethod_0 *vm; // [esp+54h] [ebp-3Ch]
  runtime_uncommontype *uv; // [esp+58h] [ebp-38h]
  runtime_uncommontype *ut; // [esp+5Ch] [ebp-34h]
  runtime__type_0 **tout_ptr; // [esp+60h] [ebp-30h]
  uint8 *tname_bytes; // [esp+64h] [ebp-2Ch]
  runtime__type_0 *tityp; // [esp+6Ch] [ebp-24h]
  uintptr v99; // [esp+78h] [ebp-18h]
  uintptr v100; // [esp+7Ch] [ebp-14h]
  uintptr v101; // [esp+80h] [ebp-10h] BYREF
  char *v102; // [esp+84h] [ebp-Ch]
  char *v103; // [esp+88h] [ebp-8h]
  uint8 *str; // [esp+8Ch] [ebp-4h]

  while ( (unsigned int)&v101 <= *(_DWORD *)(*(_DWORD *)(__readgsdword(0) - 4) + 8) )
    runtime_morestack_noctxt();
  v75 = runtime_mapaccess2_fast64(
          (runtime_maptype_0 *)&stru_80CFAC0,
          (runtime_hmap *)seen,
          __PAIR64__((unsigned int)v, (unsigned int)t));
  if ( v75._r4 )
    return 1;
  v76 = (unsigned __int8)runtime_mapassign_fast64(
                           (runtime_maptype_0 *)&stru_80CFAC0,
                           (runtime_hmap *)seen,
                           __PAIR64__((unsigned int)v, (unsigned int)t));
  if ( t == v )
    return 1;
  v3 = t->kind;
  if ( (v3 & 0x1F) != (v->kind & 0x1F) )
    return 0;
  kind = v3 & 0x1F;
  v4 = runtime___ptr__type__string(t);
  str = v4.str;
  h = runtime___ptr__type__string(v);
  if ( h.len != v4.len )
    return 0;
  h.len = (__int32)h.str;
  runtime_eqstring();
  if ( !v76 )
    return 0;
  ut = runtime___ptr__type__uncommon(t);
  h.str = (uint8 *)runtime___ptr__type__uncommon(v);
  v5 = ut == 0;
  if ( !ut )
  {
    if ( !h.str )
      goto LABEL_10;
    v5 = 1;
  }
  if ( v5 || !h.str )
    return 0;
  uv = (runtime_uncommontype *)h.str;
  hl.len = (__int32)runtime___ptr__type__nameOff(t, ut->pkgpath).bytes;
  runtime_name_name((runtime_name_0)hl.len, hl);
  pkgpatht_len = keye;
  hm.len = (__int32)runtime___ptr__type__nameOff(v, uv->pkgpath).bytes;
  runtime_name_name((runtime_name_0)hm.len, hm);
  v50 = (__int32)hn;
  if ( keyf != pkgpatht_len )
    return 0;
  h.str = pkgpatht_len;
  h.len = v50;
  runtime_eqstring();
LABEL_10:
  if ( (unsigned __int8)(kind - 1) <= 0xFu )
    return 1;
  if ( kind <= 0x15u )
  {
    if ( kind > 0x12u )
    {
      if ( kind == 19 )
      {
        v6 = v;
        if ( HIWORD(t[1].size) == HIWORD(v[1].size)
          && (LOWORD(v7) = t[1].size, LOWORD(v8) = v[1].size, (_WORD)v8 == (_WORD)v7) )
        {
          v9 = t;
          if ( (t->tflag & 1) != 0 )
            v10 = 52;
          else
            v10 = 36;
          v11 = (char *)t + v10;
          v7 = (unsigned __int16)v7;
          if ( (v->tflag & 1) != 0 )
            v12 = 52;
          else
            v12 = 36;
          v13 = (char *)v + v12;
          v8 = (unsigned __int16)v8;
          v103 = v11;
          tin_len = (unsigned __int16)v7;
          v102 = v13;
          vin_len = (unsigned __int16)v8;
          v14 = 0;
          while ( (int)v14 < v7 )
          {
            if ( v14 >= v7 || v14 >= v8 )
              runtime_panicindex();
            if ( !runtime_typesEqual(*(runtime__type_0 **)&v11[4 * v14], *(runtime__type_0 **)&v13[4 * v14], seen) )
              return 0;
            ++v14;
            v9 = t;
            v7 = tin_len;
            v6 = v;
            v8 = vin_len;
            v11 = v103;
            v13 = v102;
          }
          if ( (v9->tflag & 1) != 0 )
            v15 = 52;
          else
            v15 = 36;
          v16 = (char *)v9 + v15;
          v17 = HIWORD(v9[1].size) & 0x7FFF;
          size = v9[1].size;
          v19 = size;
          v20 = (unsigned __int16)(v17 + size);
          if ( v19 > v20 )
            runtime_panicslice();
          v21 = v20 - v19;
          v22 = (runtime__type_0 **)&v16[(4 * v19) & ((int)(v19 - 0x100000) >> 31)];
          if ( (v6->tflag & 1) != 0 )
            v23 = 52;
          else
            v23 = 36;
          v24 = (char *)v6 + v23;
          v25 = HIWORD(v6[1].size) & 0x7FFF;
          v26 = v6[1].size;
          v27 = v26;
          v28 = (unsigned __int16)(v25 + v26);
          if ( v27 > v28 )
            runtime_panicslice();
          tout_len = v21;
          tout_ptr = v22;
          v29 = v28 - v27;
          vout_len = v29;
          v30 = &v24[(4 * v27) & ((int)(v27 - 0x100000) >> 31)];
          s_4 = v30;
          v31 = 0;
          while ( (int)v31 < v21 )
          {
            if ( v31 >= v21 || v31 >= v29 )
              runtime_panicindex();
            if ( !runtime_typesEqual(v22[v31], *(runtime__type_0 **)&v30[4 * v31], seen) )
              return 0;
            ++v31;
            v21 = tout_len;
            v22 = tout_ptr;
            v29 = vout_len;
            v30 = s_4;
          }
          return 1;
        }
        else
        {
          return 0;
        }
      }
      else if ( kind == 20 )
      {
        runtime_name_name((runtime_name_0)t[1].size, h);
        sb = hb.len;
        str = hb.str;
        runtime_name_name((runtime_name_0)v[1].size, hb);
        if ( key == sb )
        {
          runtime_eqstring();
          v32 = t;
          hash = t[1].hash;
          v34 = v;
          if ( hash == v[1].hash )
          {
            s = t[1].hash;
            v35 = 0;
            while ( (int)v35 < hash )
            {
              ptrdata = v32[1].ptrdata;
              if ( v35 >= v32[1].hash )
                runtime_panicindex();
              v37 = v34[1].hash;
              v38 = v34[1].ptrdata;
              if ( v35 >= v37 )
                runtime_panicindex();
              v101 = v32[1].ptrdata;
              v100 = v38;
              tname_bytes = runtime_resolveNameOff((void *)(ptrdata + 8 * v35), *(_DWORD *)(ptrdata + 8 * v35)).bytes;
              vm = (runtime_imethod_0 *)(v100 + 8 * v35);
              hc.len = (__int32)runtime_resolveNameOff(vm, vm->name).bytes;
              vname_bytes = (uint8 *)hc.len;
              runtime_name_name((runtime_name_0)tname_bytes, hc);
              len = hd.len;
              str = hd.str;
              runtime_name_name((runtime_name_0)vname_bytes, hd);
              if ( keya != len )
                return 0;
              runtime_eqstring();
              he = runtime_name_pkgPath((runtime_name_0)tname_bytes);
              v87 = he.len;
              str = he.str;
              hf = runtime_name_pkgPath((runtime_name_0)vname_bytes);
              if ( hf.len != v87 )
                return 0;
              runtime_eqstring();
              tityp = runtime_resolveTypeOff((void *)(ptrdata + 8 * v35), *(_DWORD *)(v101 + 8 * v35 + 4));
              keyb = runtime_resolveTypeOff(vm, *(_DWORD *)(v100 + 8 * v35 + 4));
              if ( !runtime_typesEqual(tityp, keyb, seen) )
                return 0;
              ++v35;
              v32 = t;
              hash = s;
              v34 = v;
            }
            return 1;
          }
          else
          {
            return 0;
          }
        }
        else
        {
          return 0;
        }
      }
      else
      {
        return runtime_typesEqual((runtime__type_0 *)t[1].size, (runtime__type_0 *)v[1].size, seen)
            && runtime_typesEqual((runtime__type_0 *)t[1].ptrdata, (runtime__type_0 *)v[1].ptrdata, seen);
      }
    }
    if ( kind == 17 )
      return runtime_typesEqual((runtime__type_0 *)t[1].size, (runtime__type_0 *)v[1].size, seen)
          && t[1].hash == v[1].hash;
    if ( kind == 18 )
      return t[1].ptrdata == v[1].ptrdata
          && runtime_typesEqual((runtime__type_0 *)t[1].size, (runtime__type_0 *)v[1].size, seen);
LABEL_121:
    runtime_printlock();
    n.str = (uint8 *)"runtime: impossible type kind";
    n.len = 29;
    runtime_printstring(n);
    runtime_printsp();
    runtime_printint(v3 & 0x1F);
    runtime_printnl();
    runtime_printunlock();
    na.str = (uint8 *)"runtime: impossible type kind";
    na.len = 29;
    runtime_throw(na);
    BUG();
  }
  if ( kind <= 0x17u )
    return runtime_typesEqual((runtime__type_0 *)t[1].size, (runtime__type_0 *)v[1].size, seen);
  if ( kind == 24 )
    return 1;
  if ( kind != 25 )
  {
    if ( kind != 26 )
      goto LABEL_121;
    return 1;
  }
  v42 = t;
  v43 = t[1].hash;
  v44 = v;
  if ( v43 != v[1].hash )
    return 0;
  sa = t[1].hash;
  v45 = 0;
  while ( (int)v45 < v43 )
  {
    v46 = v42[1].ptrdata;
    if ( v45 >= v42[1].hash )
      runtime_panicindex();
    v47 = v44[1].hash;
    v48 = v44[1].ptrdata;
    if ( v45 >= v47 )
      runtime_panicindex();
    v99 = v48;
    runtime_name_name(*(runtime_name_0 *)(v46 + 12 * v45), h);
    v83 = hg.len;
    str = hg.str;
    runtime_name_name(*(runtime_name_0 *)(v99 + 12 * v45), hg);
    if ( keyc != v83 )
      return 0;
    runtime_eqstring();
    hh = runtime_name_pkgPath(*(runtime_name_0 *)(v46 + 12 * v45));
    v84 = hh.len;
    str = hh.str;
    hi = runtime_name_pkgPath(*(runtime_name_0 *)(v99 + 12 * v45));
    if ( hi.len != v84 )
      return 0;
    runtime_eqstring();
    if ( !runtime_typesEqual(*(runtime__type_0 **)(v46 + 12 * v45 + 4), *(runtime__type_0 **)(v99 + 12 * v45 + 4), seen) )
      return 0;
    runtime_name_tag(*(runtime_name_0 *)(v46 + 12 * v45), ha);
    v85 = (uint8 *)hj.len;
    str = hj.str;
    runtime_name_tag(*(runtime_name_0 *)(v99 + 12 * v45), hj);
    v49 = (__int32)hk;
    if ( keyd != v85 )
      return 0;
    h.str = v85;
    h.len = v49;
    runtime_eqstring();
    if ( *(_DWORD *)(v46 + 12 * v45 + 8) != *(_DWORD *)(v99 + 12 * v45 + 8) )
      return 0;
    ++v45;
    v42 = t;
    v43 = sa;
    v44 = v;
  }
  return 1;
}
// 808A22F: conditional instruction was optimized away because eax.4<10000u
// 808A287: conditional instruction was optimized away because edx.4<10000u
// 808A3E8: conditional instruction was optimized away because %var_80.1!=0
// 808A505: conditional instruction was optimized away because %var_80.1!=0
// 808A56C: conditional instruction was optimized away because %var_80.1!=0
// 808A8E1: conditional instruction was optimized away because %var_80.1!=0
// 808A956: conditional instruction was optimized away because %var_80.1!=0
// 808A9FF: conditional instruction was optimized away because %var_80.1!=0
// 808AB43: conditional instruction was optimized away because %var_80.1!=0
// 808A391: variable 'hb' is possibly undefined
// 808A3B5: variable 'key' is possibly undefined
// 808A4AB: variable 'hc' is possibly undefined
// 808A4B4: variable 'hd' is possibly undefined
// 808A4DD: variable 'keya' is possibly undefined
// 808A889: variable 'hg' is possibly undefined
// 808A8B9: variable 'keyc' is possibly undefined
// 808A9A2: variable 'ha' is possibly undefined
// 808A9AB: variable 'hj' is possibly undefined
// 808A9D1: variable 'hk' is possibly undefined
// 808A9DB: variable 'keyd' is possibly undefined
// 808AADA: variable 'hl' is possibly undefined
// 808AAE3: variable 'keye' is possibly undefined
// 808AB0F: variable 'hm' is possibly undefined
// 808AB14: variable 'hn' is possibly undefined
// 808AB22: variable 'keyf' is possibly undefined

//----- (0808AC30) --------------------------------------------------------
void __golang runtime_decoderune(string s, __int32 k, int32 r, __int32 pos)
{
  if ( k < s.len )
  {
    if ( (unsigned int)k > s.len )
      runtime_panicslice();
    if ( s.len == k )
      runtime_panicindex();
  }
}

//----- (0808ADD0) --------------------------------------------------------
__int32 __golang runtime_encoderune(__uint8 p, int32 r)
{
  int32 v2; // eax

  v2 = r;
  if ( (unsigned int)r <= 0x7F )
  {
    if ( !p.len )
      runtime_panicindex();
    *p.array = r;
    return 1;
  }
  if ( (unsigned int)r <= 0x7FF )
  {
    if ( p.len <= 1u )
      runtime_panicindex();
    *p.array = (r >> 6) | 0xC0;
    p.array[1] = r & 0x3F | 0x80;
    return 2;
  }
  if ( (unsigned int)r > 0x10FFFF || (unsigned int)(r - 55296) <= 0x7FF )
  {
    v2 = 65533;
  }
  else if ( (unsigned int)r > 0xFFFF )
  {
    if ( p.len <= 3u )
      runtime_panicindex();
    *p.array = (r >> 18) | 0xF0;
    p.array[1] = (r >> 12) & 0x3F | 0x80;
    p.array[2] = (r >> 6) & 0x3F | 0x80;
    p.array[3] = r & 0x3F | 0x80;
    return 4;
  }
  if ( p.len <= 2u )
    runtime_panicindex();
  *p.array = (v2 >> 12) | 0xE0;
  p.array[1] = (v2 >> 6) & 0x3F | 0x80;
  p.array[2] = v2 & 0x3F | 0x80;
  return 3;
}

//----- (0808AF10) --------------------------------------------------------
void __golang runtime_float64toint64(float64 d, uint64 y)
{
  y = 0LL;
  runtime__d2v(&y, d);
}

//----- (0808AF60) --------------------------------------------------------
void __golang runtime_float64touint64(float64 d, uint64 y)
{
  y = 0LL;
  runtime__d2v(&y, d);
}

//----- (0808AFB0) --------------------------------------------------------
float64 __golang runtime_int64tofloat64(int64 y)
{
  __m128i v1; // xmm0
  double v2; // [esp+4h] [ebp-14h]
  float64 _r1; // [esp+24h] [ebp+Ch]

  runtime_uint32tofloat64();
  runtime_uint32tofloat64();
  if ( y >= 0 )
    return v2 + v2 * 4294967296.0;
  v1 = (__m128i)*(unsigned __int64 *)&v2;
  *(double *)v1.m128i_i64 = v2 + 4294967296.0 * v2;
  *(_QWORD *)&_r1 = _mm_xor_si128(v1, (__m128i)(unsigned __int64)_f64_8000000000000000).m128i_u64[0];
  return _r1;
}
// 808B017: variable 'v2' is possibly undefined
// 80F1890: using guessed type __int64 _f64_8000000000000000;

//----- (0808B0A0) --------------------------------------------------------
float64 __golang runtime_uint64tofloat64(uint64 y)
{
  double v1; // [esp+4h] [ebp-10h]

  runtime_uint32tofloat64();
  runtime_uint32tofloat64();
  return v1 * 4294967296.0 + v1;
}
// 808B0ED: variable 'v1' is possibly undefined

//----- (0808B110) --------------------------------------------------------
void __golang runtime__d2v(uint64 *y, float64 d)
{
  int v2; // edx
  unsigned int v3; // eax
  unsigned int v4; // ebp
  int v5; // ebx
  unsigned int v6; // esi
  unsigned int v7; // ecx
  unsigned int v8; // edx
  int v9; // ebp
  unsigned int v10; // [esp+8h] [ebp-Ch]

  v2 = LODWORD(d);
  v3 = HIDWORD(d) & 0xFFFFF | 0x100000;
  v4 = HIDWORD(d);
  v5 = (HIDWORD(d) >> 20) & 0x7FF;
  v6 = v5 - 1075;
  v7 = 1075 - v5;
  if ( 1075 - v5 < 0 )
  {
    if ( v6 > 0xB )
    {
      runtime_float64touint32();
      v3 = v10;
      v2 = 0;
    }
    else
    {
      v9 = -(v6 < 0x20);
      v2 = v9 & (LODWORD(d) << v6);
      v3 = ((unsigned int)(1107 - v5) < 0x20 ? LODWORD(d) >> (83 - (HIDWORD(d) >> 20)) : 0) | v9 & (v3 << v6);
    }
    v4 = HIDWORD(d);
  }
  else if ( v7 >= 0x20 )
  {
    if ( v7 != 32 )
    {
      if ( v7 >= 0x40 )
        v8 = 0;
      else
        v8 = v7 - 32 < 0x20 ? v3 >> (v7 - 32) : 0;
      v3 = v8;
    }
    v2 = v3;
    v3 = 0;
  }
  else if ( v7 )
  {
    v2 = (32 - v7 < 0x20 ? v3 << (32 - v7) : 0) | (v7 < 0x20 ? LODWORD(d) >> v7 : 0);
    v3 = (((unsigned __int64)v7 - 32) >> 32) & (v3 >> v7);
  }
  if ( v4 >> 31 << 31 )
  {
    if ( v2 )
    {
      v2 = -v2;
      v3 = ~v3;
    }
    else
    {
      v3 = -v3;
    }
  }
  *(_DWORD *)y = v2;
  *((_DWORD *)y + 1) = v3;
}
// 808B21A: variable 'v10' is possibly undefined

//----- (0808B230) --------------------------------------------------------
uint64 __golang runtime_uint64div(uint64 n, uint64 d)
{
  unsigned int v2; // edx
  uint64 v3; // [esp+10h] [ebp-10h]
  uint64 v4; // [esp+10h] [ebp-10h]
  uint64 v5; // [esp+18h] [ebp-8h]

  if ( HIDWORD(n) )
  {
    v2 = HIDWORD(d);
    goto LABEL_6;
  }
  v2 = HIDWORD(d);
  if ( HIDWORD(d) )
  {
LABEL_6:
    runtime_dodiv(n, __PAIR64__(v2, d), v3, v5);
    return v4;
  }
  if ( !(_DWORD)d )
    runtime_panicdivide();
  return (unsigned int)n / (unsigned int)d;
}
// 808B25D: conditional instruction was optimized away because %d.4!=0
// 808B29B: variable 'v3' is possibly undefined
// 808B29B: variable 'v5' is possibly undefined
// 808B2A8: variable 'v4' is possibly undefined

//----- (0808B2D0) --------------------------------------------------------
uint64 __golang runtime_uint64mod(uint64 n, uint64 d)
{
  unsigned int v2; // edx
  uint64 v3; // [esp+10h] [ebp-10h]
  uint64 v4; // [esp+18h] [ebp-8h]
  uint64 v5; // [esp+18h] [ebp-8h]

  if ( HIDWORD(n) )
  {
    v2 = HIDWORD(d);
    goto LABEL_6;
  }
  v2 = HIDWORD(d);
  if ( HIDWORD(d) )
  {
LABEL_6:
    runtime_dodiv(n, __PAIR64__(v2, d), v3, v4);
    return v5;
  }
  if ( !(_DWORD)d )
    runtime_panicdivide();
  return (unsigned int)n % (unsigned int)d;
}
// 808B2FD: conditional instruction was optimized away because %d.4!=0
// 808B33B: variable 'v3' is possibly undefined
// 808B33B: variable 'v4' is possibly undefined
// 808B348: variable 'v5' is possibly undefined

//----- (0808B370) --------------------------------------------------------
int64 __golang runtime_int64div(int64 n, int64 d)
{
  int v2; // ebp
  int v3; // esi
  int v5; // eax
  unsigned int v6; // ecx
  int v7; // edx
  unsigned int v8; // ebp
  int v9; // edx
  unsigned int v10; // ecx
  uint64 v11; // [esp+10h] [ebp-14h]
  __int64 v12; // [esp+10h] [ebp-14h]
  uint64 v13; // [esp+18h] [ebp-Ch]

  if ( (int)n >> 31 != HIDWORD(n) )
  {
    v3 = HIDWORD(d);
    v2 = d;
    goto LABEL_12;
  }
  v3 = HIDWORD(d);
  v2 = d;
  if ( (int)d >> 31 != HIDWORD(d) )
  {
LABEL_12:
    if ( n >= 0 )
    {
      v6 = HIDWORD(n);
      v5 = n;
    }
    else
    {
      v5 = -(int)n;
      v6 = (unsigned __int64)-n >> 32;
    }
    if ( v3 >= 0 )
    {
      v7 = v2;
      v8 = v3;
    }
    else
    {
      v7 = -v2;
      v8 = (unsigned __int64)-__SPAIR64__(v3, v2) >> 32;
    }
    runtime_dodiv(__PAIR64__(v6, v5), __PAIR64__(v8, v7), v11, v13);
    if ( n < 0 == v3 < 0 )
    {
      v10 = HIDWORD(v12);
      v9 = v12;
    }
    else
    {
      v9 = -(int)v12;
      v10 = (unsigned __int64)-v12 >> 32;
    }
    return __PAIR64__(v10, v9);
  }
  if ( (_DWORD)n == 0x80000000 && (_DWORD)d == -1 )
    return 0x80000000LL;
  if ( !(_DWORD)d )
    runtime_panicdivide();
  if ( (_DWORD)d == -1 )
    return -(int)n;
  else
    return (int)n / (int)d;
}
// 808B47F: variable 'v11' is possibly undefined
// 808B47F: variable 'v13' is possibly undefined
// 808B49C: variable 'v12' is possibly undefined

//----- (0808B4F0) --------------------------------------------------------
int64 __golang runtime_int64mod(int64 n, int64 d)
{
  int v2; // ebp
  int v3; // esi
  int v5; // eax
  unsigned int v6; // ecx
  int v7; // edx
  unsigned int v8; // ebp
  int v9; // edx
  unsigned int v10; // ecx
  uint64 v11; // [esp+10h] [ebp-14h]
  uint64 v12; // [esp+18h] [ebp-Ch]
  __int64 v13; // [esp+18h] [ebp-Ch]

  if ( HIDWORD(n) != (int)n >> 31 )
  {
    v3 = HIDWORD(d);
    v2 = d;
    goto LABEL_9;
  }
  v3 = HIDWORD(d);
  v2 = d;
  if ( HIDWORD(d) != (int)d >> 31 )
  {
LABEL_9:
    if ( n >= 0 )
    {
      v6 = HIDWORD(n);
      v5 = n;
    }
    else
    {
      v5 = -(int)n;
      v6 = (unsigned __int64)-n >> 32;
    }
    if ( v3 >= 0 )
    {
      v7 = v2;
      v8 = v3;
    }
    else
    {
      v7 = -v2;
      v8 = (unsigned __int64)-__SPAIR64__(v3, v2) >> 32;
    }
    runtime_dodiv(__PAIR64__(v6, v5), __PAIR64__(v8, v7), v11, v12);
    if ( n >= 0 )
    {
      v10 = HIDWORD(v13);
      v9 = v13;
    }
    else
    {
      v9 = -(int)v13;
      v10 = (unsigned __int64)-v13 >> 32;
    }
    return __PAIR64__(v10, v9);
  }
  if ( !(_DWORD)d )
    runtime_panicdivide();
  if ( (_DWORD)d == -1 )
    return 0;
  else
    return (int)n % (int)d;
}
// 808B5D4: variable 'v11' is possibly undefined
// 808B5D4: variable 'v12' is possibly undefined
// 808B5EC: variable 'v13' is possibly undefined

//----- (0808B640) --------------------------------------------------------
void __golang runtime_dodiv(uint64 n, uint64 d, uint64 q, uint64 r)
{
  uint64 v4; // [esp+10h] [ebp-24h]
  uint64 v5; // [esp+18h] [ebp-1Ch]

  if ( ((unsigned int)d <= (unsigned int)n || HIDWORD(d) != HIDWORD(n)) && HIDWORD(d) <= HIDWORD(n) )
  {
    if ( HIDWORD(d) )
    {
      runtime__mul64by32();
      if ( (_DWORD)v4 )
        runtime_slowdodiv(n, d, v4, v5);
    }
    else
    {
      if ( HIDWORD(n) >= (unsigned int)d && !(_DWORD)d )
        runtime_panicdivide();
      runtime__div64by32();
    }
  }
}
// 808B69C: conditional instruction was optimized away because %d.4!=0
// 808B767: variable 'v4' is possibly undefined
// 808B788: variable 'v5' is possibly undefined

//----- (0808B830) --------------------------------------------------------
void __golang runtime_slowdodiv(uint64 n, uint64 d, uint64 q, uint64 r)
{
  unsigned int v4; // edx
  unsigned int v5; // eax
  unsigned int v6; // ebx
  unsigned int v7; // esi
  int v8; // edi
  unsigned int v9; // ecx
  unsigned int v10; // ebx
  int v11; // ebp
  unsigned int v12; // esi
  int v13; // ebp
  unsigned __int64 v14; // kr00_8
  int v15; // [esp+4h] [ebp-8h]

  v4 = d;
  if ( (_DWORD)d == 0 && HIDWORD(d) == 0 )
    runtime_panicdivide();
  v5 = HIDWORD(d);
  if ( HIDWORD(n) < 0x80000000 )
  {
    v6 = HIDWORD(n);
    v7 = n;
  }
  else
  {
    v6 = 0x80000000;
    v7 = 0;
  }
  v8 = 0;
  while ( v5 < v6 || v4 < v7 && v5 == v6 )
  {
    v5 = (v4 >> 31) | (2 * v5);
    ++v8;
    v4 *= 2;
  }
  v9 = HIDWORD(n);
  v10 = n;
  v11 = 0;
  v12 = 0;
  while ( v8 >= 0 )
  {
    v15 = (2 * v11) | (v12 >> 31);
    v13 = 2 * v12;
    if ( v9 > v5 || v9 == v5 && v10 >= v4 )
    {
      v14 = __PAIR64__(v9, v10) - __PAIR64__(v5, v4);
      v9 = (__PAIR64__(v9, v10) - __PAIR64__(v5, v4)) >> 32;
      v10 = v14;
      v13 |= 1u;
    }
    --v8;
    v4 = (v5 << 31) | (v4 >> 1);
    v5 >>= 1;
    v12 = v13;
    v11 = v15;
  }
}

//----- (0808B990) --------------------------------------------------------
void __golang runtime_writeErr(__uint8 b)
{
  if ( !b.len )
    runtime_panicindex();
  runtime_write();
}

//----- (0808B9E0) --------------------------------------------------------
void __golang runtime_cgocallbackg1_func1(runtime_g *gp)
{
  --gp->cgoCtxt.len;
}

//----- (0808BA20) --------------------------------------------------------
void __golang __noreturn runtime_cgoCheckWriteBarrier_func1()
{
  int v0; // edx
  string s; // [esp+0h] [ebp-10h]
  string sa; // [esp+0h] [ebp-10h]
  string sb; // [esp+0h] [ebp-10h]
  uintptr src; // [esp+8h] [ebp-8h]
  unsigned int v5; // [esp+Ch] [ebp-4h]

  src = *(_DWORD *)(v0 + 4);
  v5 = *(_DWORD *)(v0 + 8);
  runtime_printlock();
  s.str = (uint8 *)"write of Go pointer";
  s.len = 19;
  runtime_printstring(s);
  runtime_printsp();
  runtime_printhex(src);
  runtime_printsp();
  sa.str = (uint8 *)"to non-Go memory";
  sa.len = 16;
  runtime_printstring(sa);
  runtime_printsp();
  runtime_printhex(v5);
  runtime_printnl();
  runtime_printunlock();
  sb.str = (uint8 *)"Go pointer stored into non-Go memory";
  sb.len = 36;
  runtime_throw(sb);
  BUG();
}
// 808BA39: variable 'v0' is possibly undefined

//----- (0808BAE0) --------------------------------------------------------
void __golang runtime_cgoCheckTypedBlock_func1()
{
  int v0; // edx

  runtime_cgoCheckUsingType(
    *(runtime__type_0 **)(v0 + 4),
    *(void **)(v0 + 8),
    *(_DWORD *)(v0 + 12),
    *(_DWORD *)(v0 + 16));
}
// 808BAF5: variable 'v0' is possibly undefined

//----- (0808BB20) --------------------------------------------------------
void __golang __noreturn runtime_cgoCheckTypedBlock_func2()
{
  string s; // [esp+0h] [ebp-8h]

  s.str = (uint8 *)"Go pointer stored into non-Go memory";
  s.len = 36;
  runtime_throw(s);
  BUG();
}

//----- (0808BB60) --------------------------------------------------------
void __golang __noreturn runtime_cgoCheckBits_func1()
{
  string s; // [esp+0h] [ebp-8h]

  s.str = (uint8 *)"Go pointer stored into non-Go memory";
  s.len = 36;
  runtime_throw(s);
  BUG();
}

//----- (0808BBA0) --------------------------------------------------------
void __golang runtime_chansend_func1()
{
  int v0; // edx

  runtime_unlock((runtime_mutex_0 *)(*(_DWORD *)(v0 + 4) + 48));
}
// 808BBB5: variable 'v0' is possibly undefined

//----- (0808BBD0) --------------------------------------------------------
void __golang runtime_chanrecv_func1()
{
  int v0; // edx

  runtime_unlock((runtime_mutex_0 *)(*(_DWORD *)(v0 + 4) + 48));
}
// 808BBE5: variable 'v0' is possibly undefined

//----- (0808BC00) --------------------------------------------------------
void __golang runtime___ptr_mcache__nextFree_func1()
{
  int v0; // edx

  runtime___ptr_mcache__refill(*(runtime_mcache **)(v0 + 4), *(_BYTE *)(v0 + 8));
}
// 808BC15: variable 'v0' is possibly undefined

//----- (0808BC40) --------------------------------------------------------
void __golang runtime_mallocgc_func1()
{
  int v0; // edx
  bool v1; // [esp+8h] [ebp-8h]
  runtime_mspan *v2; // [esp+8h] [ebp-8h]
  runtime_mspan *_s; // [esp+Ch] [ebp-4h]

  _s = runtime_largeAlloc(**(_DWORD **)(v0 + 8), *(_BYTE *)(v0 + 12), v1);
  _s->next = v2;
}
// 808BC5C: variable 'v0' is possibly undefined
// 808BC74: variable 'v1' is possibly undefined
// 808BC81: variable 'v2' is possibly undefined

//----- (0808BC90) --------------------------------------------------------
void __golang runtime_persistentalloc_func1()
{
  int v0; // edx
  void *src; // [esp+Ch] [ebp-8h]
  void **_p; // [esp+10h] [ebp-4h]

  _p = *(void ***)(v0 + 4);
  src = runtime_persistentalloc1(*(_DWORD *)(v0 + 8), *(_DWORD *)(v0 + 12), *(uint64 **)(v0 + 16));
  if ( *(_DWORD *)&runtime_writeBarrier.enabled )
    runtime_writebarrierptr((uintptr *)_p, (uintptr)src);
  else
    *_p = src;
}
// 808BCA5: variable 'v0' is possibly undefined

//----- (0808BD00) --------------------------------------------------------
void __golang runtime_writebarrierptr_prewrite1_func1()
{
  _DWORD *v0; // edx
  int v1; // eax
  uintptr ptr; // ecx
  uintptr *v3; // edx
  uintptr v4; // edi
  unsigned int v5; // ecx
  int v6; // ecx
  string slot; // [esp+0h] [ebp-8h]

  v1 = v0[1];
  ptr = v0[2];
  v3 = (uintptr *)v0[3];
  if ( !*(_DWORD *)(v1 + 92)
    && runtime_memstats.enablegc
    && !*(_BYTE *)(v1 + 142)
    && ptr
    && ptr >= dword_81493A8
    && ptr < dword_81493AC )
  {
    v4 = ptr;
    v5 = (ptr - dword_81493A8) >> 13;
    if ( v5 >= dword_814910C )
      runtime_panicindex();
    v6 = *(_DWORD *)(dword_8149108 + 4 * v5);
    if ( v6 && v4 >= *(_DWORD *)(v6 + 12) && v4 < *(_DWORD *)(v6 + 80) && *(_BYTE *)(v6 + 60) == 1 )
    {
      slot.str = (uint8 *)"writebarrierptr_prewrite1 called with mp.p == nil";
      slot.len = 49;
      runtime_throw(slot);
      BUG();
    }
    ptr = v4;
  }
  *(_BYTE *)(v1 + 142) = 1;
  runtime_gcmarkwb_m(v3, ptr);
}
// 808BD19: variable 'v0' is possibly undefined
// 8149108: using guessed type int dword_8149108;
// 814910C: using guessed type int dword_814910C;
// 81493A8: using guessed type int dword_81493A8;
// 81493AC: using guessed type int dword_81493AC;

//----- (0808BDE0) --------------------------------------------------------
void __golang __noreturn runtime_writebarrierptr_func1()
{
  int v0; // edx
  string s; // [esp+0h] [ebp-10h]
  string sa; // [esp+0h] [ebp-10h]
  string sb; // [esp+0h] [ebp-10h]
  string sc; // [esp+0h] [ebp-10h]
  uintptr src; // [esp+8h] [ebp-8h]
  uintptr *dst; // [esp+Ch] [ebp-4h]

  dst = *(uintptr **)(v0 + 4);
  src = *(_DWORD *)(v0 + 8);
  runtime_printlock();
  s.str = (uint8 *)"runtime: writebarrierptr *";
  s.len = 26;
  runtime_printstring(s);
  runtime_printpointer(dst);
  sa.str = (uint8 *)" = ";
  sa.len = 3;
  runtime_printstring(sa);
  runtime_printhex(src);
  sb.str = (uint8 *)"\n";
  sb.len = 1;
  runtime_printstring(sb);
  runtime_printunlock();
  sc.str = (uint8 *)"bad pointer in write barrier";
  sc.len = 28;
  runtime_throw(sc);
  BUG();
}
// 808BDF9: variable 'v0' is possibly undefined

//----- (0808BEA0) --------------------------------------------------------
void __golang __noreturn runtime_writebarrierptr_prewrite_func1()
{
  string s; // [esp+0h] [ebp-8h]

  s.str = (uint8 *)"bad pointer in write barrier";
  s.len = 28;
  runtime_throw(s);
  BUG();
}

//----- (0808BEE0) --------------------------------------------------------
void __golang runtime_typedslicecopy_func1()
{
  _DWORD *v0; // edx
  void **v1; // eax
  void **v2; // ecx
  __int32 v3; // ebx
  runtime__type_0 **v4; // edx
  char *v5; // esi
  uintptr size; // edi
  __int32 v7; // ebp
  uintptr v8; // esi
  uintptr v9; // ebx
  __int32 k; // ebx
  void **v11; // esi
  uintptr v12; // ebx
  void **v13; // edi
  uintptr v14; // ecx
  __int32 j; // ebx
  void **v16; // esi
  uintptr v17; // ebx
  void **v18; // edi
  uintptr v19; // ecx
  __int32 n; // [esp+Ch] [ebp-1Ch]
  __int32 i; // [esp+10h] [ebp-18h]
  __int32 i_0; // [esp+14h] [ebp-14h]
  runtime__type_0 **_typ; // [esp+1Ch] [ebp-Ch]
  uintptr *_srcp; // [esp+20h] [ebp-8h]
  uintptr *_dstp; // [esp+24h] [ebp-4h]

  v1 = (void **)v0[1];
  _srcp = (uintptr *)v1;
  v2 = (void **)v0[2];
  _dstp = (uintptr *)v2;
  v3 = v0[3];
  n = v3;
  v4 = (runtime__type_0 **)v0[4];
  _typ = v4;
  v5 = (char *)*v2;
  if ( *v1 >= *v2 || (size = (*v4)->size, (char *)*v1 + size * v3 <= v5) )
  {
    for ( j = 0; ; j = i_0 )
    {
      runtime_typedmemmove(*v4, *v2, *v1);
      if ( j + 1 >= n )
        break;
      i_0 = j + 1;
      v4 = _typ;
      v16 = (void **)_dstp;
      v17 = *_dstp + (*_typ)->size;
      if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      {
        runtime_writebarrierptr(_dstp, v17);
        v4 = _typ;
        v16 = (void **)_dstp;
      }
      else
      {
        *_dstp = v17;
      }
      v18 = (void **)_srcp;
      v19 = (*v4)->size + *_srcp;
      if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      {
        runtime_writebarrierptr(_srcp, v19);
        v4 = _typ;
        v16 = (void **)_dstp;
        v18 = (void **)_srcp;
      }
      else
      {
        *_srcp = v19;
      }
      v1 = v18;
      v2 = v16;
    }
  }
  else
  {
    v7 = v3 - 1;
    v8 = (uintptr)&v5[(v3 - 1) * size];
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
    {
      runtime_writebarrierptr((uintptr *)v2, v8);
      v1 = (void **)_srcp;
      v2 = (void **)_dstp;
      v4 = _typ;
      v7 = v3 - 1;
    }
    else
    {
      *v2 = (void *)v8;
    }
    v9 = (uintptr)*v1 + v7 * (*v4)->size;
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
    {
      runtime_writebarrierptr((uintptr *)v1, v9);
      v1 = (void **)_srcp;
      v2 = (void **)_dstp;
      v4 = _typ;
    }
    else
    {
      *v1 = (void *)v9;
    }
    for ( k = 0; ; k = i )
    {
      runtime_typedmemmove(*v4, *v2, *v1);
      if ( k + 1 >= n )
        break;
      i = k + 1;
      v4 = _typ;
      v11 = (void **)_dstp;
      v12 = *_dstp - (*_typ)->size;
      if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      {
        runtime_writebarrierptr(_dstp, v12);
        v4 = _typ;
        v11 = (void **)_dstp;
      }
      else
      {
        *_dstp = v12;
      }
      v13 = (void **)_srcp;
      v14 = *_srcp - (*v4)->size;
      if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      {
        runtime_writebarrierptr(_srcp, v14);
        v4 = _typ;
        v11 = (void **)_dstp;
        v13 = (void **)_srcp;
      }
      else
      {
        *_srcp = v14;
      }
      v1 = v13;
      v2 = v11;
    }
  }
}
// 808BEF9: variable 'v0' is possibly undefined

//----- (0808C120) --------------------------------------------------------
void __golang runtime_freemcache_func1()
{
  int v0; // edx
  runtime_mcache *c; // [esp+4h] [ebp-4h]

  c = *(runtime_mcache **)(v0 + 4);
  runtime___ptr_mcache__releaseAll(c);
  runtime_stackcache_clear(c);
  runtime_lock(&runtime_mheap_.lock);
  runtime_purgecachedstats(c);
  f.inuse -= f.size;
  c->next_sample = (int32)f.list;
  f.list = (runtime_mlink *)c;
  runtime_unlock(&runtime_mheap_.lock);
}
// 808C135: variable 'v0' is possibly undefined

//----- (0808C1C0) --------------------------------------------------------
void __golang runtime_SetFinalizer_func1()
{
  int v0; // edx

  runtime_removefinalizer(*(void **)(*(_DWORD *)(v0 + 4) + 4));
}
// 808C1D5: variable 'v0' is possibly undefined

//----- (0808C1F0) --------------------------------------------------------
void __golang runtime_SetFinalizer_func2()
{
  int v0; // edx
  string p; // [esp+0h] [ebp-18h]

  if ( !runtime_addfinalizer(
          *(void **)(*(_DWORD *)(v0 + 4) + 4),
          *(runtime_funcval **)(*(_DWORD *)(v0 + 8) + 4),
          *(_DWORD *)(v0 + 12),
          *(runtime__type_0 **)(v0 + 16),
          *(runtime_ptrtype_0 **)(v0 + 20)) )
  {
    p.str = (uint8 *)"runtime.SetFinalizer: finalizer already set";
    p.len = 43;
    runtime_throw(p);
    BUG();
  }
}
// 808C205: variable 'v0' is possibly undefined

//----- (0808C260) --------------------------------------------------------
bool __golang runtime___ptr_gcControllerState__findRunnableGCWorker_func1(int64 *ptr)
{
  int v1; // [esp+10h] [ebp-4h]

  if ( *((_DWORD *)ptr + 1) <= 0 && (*((_DWORD *)ptr + 1) != 0 || *(_DWORD *)ptr == 0) )
    return 0;
  runtime_internal_atomic_Xaddint64();
  if ( v1 < 0 )
  {
    runtime_internal_atomic_Xaddint64();
    return 0;
  }
  return 1;
}
// 808C2D7: variable 'v1' is possibly undefined

//----- (0808C310) --------------------------------------------------------
void __golang runtime_gcStart_func1()
{
  runtime_finishsweep_m();
}

//----- (0808C330) --------------------------------------------------------
void __golang runtime_gcMarkDone_func1_1(runtime_p *_p_)
{
  runtime___ptr_gcWork__dispose(&_p_->gcw);
}

//----- (0808C370) --------------------------------------------------------
void __golang runtime_gcMarkDone_func1()
{
  runtime_forEachP(off_80E7C00);
}

//----- (0808C3A0) --------------------------------------------------------
void __golang runtime_gcMarkTermination_func1()
{
  int v0; // edx

  runtime_gcMark(*(_QWORD *)*(_DWORD *)(v0 + 4));
}
// 808C3B5: variable 'v0' is possibly undefined

//----- (0808C3E0) --------------------------------------------------------
void __golang runtime_gcMarkTermination_func2()
{
  int v0; // edx
  uint32 x; // [esp+0h] [ebp-Ch]
  int v2; // [esp+4h] [ebp-8h]
  int64 *_startTime; // [esp+8h] [ebp-4h]

  _startTime = *(int64 **)(v0 + 4);
  runtime_work.heap2 = runtime_work.bytesMarked;
  if ( runtime_debug.gccheckmark > 0 )
  {
    runtime_gcResetMarkState();
    runtime_initCheckmarks();
    runtime_gcMark(*_startTime);
    runtime_clearCheckmarks();
  }
  runtime_setGCPhase(0);
  runtime_gcSweep(runtime_work.mode);
  if ( runtime_debug.gctrace > 1 )
  {
    runtime_nanotime();
    *(_DWORD *)_startTime = x;
    *((_DWORD *)_startTime + 1) = v2;
    runtime_gcResetMarkState();
    runtime_finishsweep_m();
    runtime_setGCPhase(2u);
    runtime_gcMark(*_startTime);
    runtime_setGCPhase(0);
    runtime_gcSweep(runtime_work.mode);
  }
}
// 808C3F9: variable 'v0' is possibly undefined
// 808C45F: variable 'x' is possibly undefined
// 808C461: variable 'v2' is possibly undefined

//----- (0808C4E0) --------------------------------------------------------
bool __golang runtime_gcBgMarkWorker_func1(runtime_g *g, void *parkp)
{
  int v2; // edx
  int v3; // ebx
  int v4; // ecx
  bool _r2; // [esp+1Ch] [ebp+Ch]

  v2 = *(_DWORD *)(__readgsdword(0) - 4);
  v3 = *(_DWORD *)(*(_DWORD *)parkp + 120);
  *(_DWORD *)(*(_DWORD *)parkp + 120) = v3 - 1;
  if ( v3 == 1 && *(_BYTE *)(v2 + 108) )
    *(_DWORD *)(v2 + 8) = -1314;
  v4 = *((_DWORD *)parkp + 1);
  _r2 = 1;
  if ( v4 )
  {
    *((_DWORD *)parkp + 1) = 0;
    if ( !runtime___ptr_guintptr__cas((runtime_guintptr *)(v4 + 2376), 0, (runtime_guintptr)g) )
      return 0;
  }
  return _r2;
}

//----- (0808C580) --------------------------------------------------------
void __golang runtime_gcBgMarkWorker_func2()
{
  int v0; // edx
  runtime_gcMarkWorkerMode gcMarkWorkerMode; // ecx
  string s; // [esp+0h] [ebp-18h]
  runtime_g *s_4; // [esp+4h] [ebp-14h]
  bool newval; // [esp+8h] [ebp-10h]
  runtime_g *gp; // [esp+Ch] [ebp-Ch]
  runtime_p *_p_; // [esp+10h] [ebp-8h]

  gp = *(runtime_g **)(v0 + 4);
  _p_ = *(runtime_p **)(v0 + 8);
  runtime_casgstatus(gp, 2u, 4u);
  gcMarkWorkerMode = _p_->gcMarkWorkerMode;
  if ( gcMarkWorkerMode )
  {
    if ( gcMarkWorkerMode == 1 )
    {
      runtime_gcDrain(&_p_->gcw, 5);
    }
    else
    {
      if ( gcMarkWorkerMode != 2 )
      {
        s.str = (uint8 *)"gcBgMarkWorker: unexpected gcMarkWorkerMode";
        s.len = 43;
        runtime_throw(s);
        BUG();
      }
      runtime_gcDrain(&_p_->gcw, 13);
    }
  }
  else
  {
    runtime_gcDrain(&_p_->gcw, 5);
    if ( gp->preempt )
    {
      runtime_lock(&runtime_sched.lock);
      while ( 1 )
      {
        runtime_runqget(_p_, s_4, newval);
        if ( !s_4 )
          break;
        s_4->schedlink = 0;
        if ( runtime_sched.runqtail )
          *(_DWORD *)(runtime_sched.runqtail + 104) = s_4;
        else
          runtime_sched.runqhead = (runtime_guintptr)s_4;
        runtime_sched.runqtail = (runtime_guintptr)s_4;
        ++runtime_sched.runqsize;
      }
      runtime_unlock(&runtime_sched.lock);
    }
    runtime_gcDrain(&_p_->gcw, 6);
  }
  runtime_casgstatus(gp, 4u, 2u);
}
// 808C599: variable 'v0' is possibly undefined
// 808C60F: variable 's_4' is possibly undefined
// 808C629: variable 'newval' is possibly undefined

//----- (0808C710) --------------------------------------------------------
__int32 __golang runtime_gcMarkRootPrepare_func1(uintptr bytes)
{
  return (bytes + 0x3FFFF) >> 18;
}

//----- (0808C740) --------------------------------------------------------
void __golang runtime_markroot_func1()
{
  int v0; // edx
  runtime_g *v1; // ecx
  runtime_gcWork_0 *v2; // edx
  runtime_g *v3; // eax
  bool v4; // bl
  runtime_g *userG; // [esp+10h] [ebp-Ch]
  runtime_g *gp; // [esp+14h] [ebp-8h]
  runtime_gcWork_0 *gcw; // [esp+18h] [ebp-4h]

  v1 = *(runtime_g **)(v0 + 4);
  gp = v1;
  v2 = *(runtime_gcWork_0 **)(v0 + 8);
  gcw = v2;
  v3 = *(runtime_g **)(*(_DWORD *)(*(_DWORD *)(__readgsdword(0) - 4) + 24) + 84);
  userG = v3;
  if ( v1 == v3 )
  {
    v4 = runtime_readgstatus(v3) == 2;
    v3 = userG;
    v1 = gp;
    v2 = gcw;
  }
  else
  {
    v4 = 0;
  }
  if ( v4 )
  {
    runtime_casgstatus(v3, 2u, 4u);
    userG->waitreason.len = 23;
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr((uintptr *)&userG->waitreason, (uintptr)"garbage collection scan");
    else
      userG->waitreason.str = (uint8 *)"garbage collection scan";
    v1 = gp;
    v2 = gcw;
  }
  runtime_scang(v1, v2);
  if ( v4 )
    runtime_casgstatus(userG, 4u, 2u);
}
// 808C769: variable 'v0' is possibly undefined

//----- (0808C850) --------------------------------------------------------
void __golang runtime_gcAssistAlloc_func1()
{
  int v0; // edx

  runtime_gcAssistAlloc1(*(runtime_g **)(v0 + 4), *(_QWORD *)(v0 + 8));
}
// 808C865: variable 'v0' is possibly undefined

//----- (0808C890) --------------------------------------------------------
bool __golang runtime_scanstack_func1(runtime_stkframe *frame, void *unused)
{
  int v2; // edx

  runtime_scanframeworker(frame, *(runtime_pcvalueCache **)(v2 + 4), *(runtime_gcWork_0 **)(v2 + 8));
  return 1;
}
// 808C8A5: variable 'v2' is possibly undefined

//----- (0808C8D0) --------------------------------------------------------
void __golang runtime_gosweepone_func1()
{
  int v0; // edx
  uintptr *_ret; // [esp+4h] [ebp-4h]

  _ret = *(uintptr **)(v0 + 4);
  *_ret = runtime_sweepone();
}
// 808C8E5: variable 'v0' is possibly undefined

//----- (0808C910) --------------------------------------------------------
void __golang runtime_getempty_func1()
{
  int v0; // edx
  runtime_mspan **_s; // [esp+10h] [ebp-4h]

  _s = *(runtime_mspan ***)(v0 + 4);
  *_s = runtime___ptr_mheap__allocManual(&runtime_mheap_, 4u, &runtime_memstats.gc_sys);
}
// 808C925: variable 'v0' is possibly undefined

//----- (0808C970) --------------------------------------------------------
void __golang runtime_freeSomeWbufs_func1()
{
  int v0; // edx
  char v1; // cl
  runtime_g *v2; // eax
  int v3; // edx
  bool preemptible; // [esp+Fh] [ebp-Dh]
  __int32 i; // [esp+10h] [ebp-Ch]
  runtime_g *gp; // [esp+14h] [ebp-8h]
  runtime_mspan *s; // [esp+18h] [ebp-4h]

  v1 = *(_BYTE *)(v0 + 4);
  preemptible = v1;
  v2 = *(runtime_g **)(*(_DWORD *)(*(_DWORD *)(__readgsdword(0) - 4) + 24) + 84);
  gp = v2;
  v3 = 0;
  while ( v3 < 64 && (!v1 || !v2->preempt) && runtime_work.wbufSpans.free.first )
  {
    i = v3;
    s = runtime_work.wbufSpans.free.first;
    runtime___ptr_mSpanList__remove(&runtime_work.wbufSpans.free, runtime_work.wbufSpans.free.first);
    runtime___ptr_mheap__freeManual(&runtime_mheap_, s, &runtime_memstats.gc_sys);
    v3 = i + 1;
    v2 = gp;
    v1 = preemptible;
  }
}
// 808C999: variable 'v0' is possibly undefined

//----- (0808CA20) --------------------------------------------------------
void __golang runtime___ptr_mheap__alloc_func1()
{
  int v0; // edx
  bool v1; // [esp+Ch] [ebp-8h]
  runtime_mspan *v2; // [esp+Ch] [ebp-8h]
  runtime_mspan *_s; // [esp+10h] [ebp-4h]

  _s = runtime___ptr_mheap__alloc_m(*(runtime_mheap_0 **)(v0 + 8), *(_DWORD *)(v0 + 12), *(_BYTE *)(v0 + 16), v1);
  _s->next = v2;
}
// 808CA3C: variable 'v0' is possibly undefined
// 808CA5B: variable 'v1' is possibly undefined
// 808CA68: variable 'v2' is possibly undefined

//----- (0808CA80) --------------------------------------------------------
void __golang runtime___ptr_mheap__freeSpan_func1()
{
  _DWORD *v0; // edx
  int64 unusedsince; // [esp+10h] [ebp-14h]
  runtime_mspan *s; // [esp+18h] [ebp-Ch]
  runtime_m *mp; // [esp+1Ch] [ebp-8h]
  runtime_mheap_0 *h; // [esp+20h] [ebp-4h]

  h = (runtime_mheap_0 *)v0[1];
  s = (runtime_mspan *)v0[2];
  HIDWORD(unusedsince) = v0[3];
  mp = *(runtime_m **)(*(_DWORD *)(__readgsdword(0) - 4) + 24);
  runtime_lock(&h->lock);
  runtime_memstats.heap_scan += mp->mcache->local_scan;
  mp->mcache->local_scan = 0;
  runtime_memstats.tinyallocs += mp->mcache->local_tinyallocs;
  mp->mcache->local_tinyallocs = 0;
  if ( HIDWORD(unusedsince) )
    --runtime_memstats.heap_objects;
  if ( runtime_gcBlackenEnabled )
    runtime___ptr_gcControllerState__revise(&runtime_gcController);
  LODWORD(unusedsince) = 0;
  runtime___ptr_mheap__freeSpanLocked(h, s, 1, 0, unusedsince);
  runtime_unlock(&h->lock);
}
// 808CA99: variable 'v0' is possibly undefined

//----- (0808CBC0) --------------------------------------------------------
void __golang runtime_mProf_Malloc_func1()
{
  int v0; // edx

  runtime_setprofilebucket(*(void **)(v0 + 4), *(runtime_bucket **)(v0 + 8));
}
// 808CBD5: variable 'v0' is possibly undefined

//----- (0808CC00) --------------------------------------------------------
void __golang runtime_tracealloc_func1()
{
  int v0; // edx

  runtime_traceback(*(_DWORD *)(v0 + 4), *(_DWORD *)(v0 + 8), 0, *(runtime_g **)(v0 + 12));
}
// 808CC15: variable 'v0' is possibly undefined

//----- (0808CC50) --------------------------------------------------------
void __golang runtime_tracefree_func1()
{
  int v0; // edx

  runtime_traceback(*(_DWORD *)(v0 + 4), *(_DWORD *)(v0 + 8), 0, *(runtime_g **)(v0 + 12));
}
// 808CC65: variable 'v0' is possibly undefined

//----- (0808CCA0) --------------------------------------------------------
void __golang runtime_futexwakeup_func1()
{
  int v0; // edx
  string s; // [esp+0h] [ebp-10h]
  string sa; // [esp+0h] [ebp-10h]
  string sb; // [esp+0h] [ebp-10h]
  int32 ret; // [esp+8h] [ebp-8h]
  uint32 *addr; // [esp+Ch] [ebp-4h]

  addr = *(uint32 **)(v0 + 4);
  ret = *(_DWORD *)(v0 + 8);
  runtime_printlock();
  s.str = (uint8 *)"futexwakeup addr=";
  s.len = 17;
  runtime_printstring(s);
  runtime_printpointer(addr);
  sa.str = (uint8 *)" returned ";
  sa.len = 10;
  runtime_printstring(sa);
  runtime_printint(ret);
  sb.str = (uint8 *)"\n";
  sb.len = 1;
  runtime_printstring(sb);
  runtime_printunlock();
}
// 808CCB9: variable 'v0' is possibly undefined

//----- (0808CD40) --------------------------------------------------------
void __golang runtime_newdefer_func1()
{
  int v0; // edx
  int v1; // edx
  runtime__defer *v2; // ebp
  runtime__defer *link; // edi
  runtime_p *v4; // eax
  __int32 v5; // ebx
  __int32 v6; // esi
  uintptr *v7; // edi
  uintptr *array; // eax
  __int32 len; // ecx
  int v10; // ebx
  runtime_slice_0 src; // [esp+4h] [ebp-40h]
  runtime_slice_0 v12; // [esp+14h] [ebp-30h]
  uintptr sc; // [esp+20h] [ebp-24h]
  runtime_p *pp; // [esp+2Ch] [ebp-18h]
  runtime__defer *v15; // [esp+34h] [ebp-10h]

  pp = *(runtime_p **)(v0 + 4);
  sc = *(_DWORD *)(v0 + 8);
  runtime_lock(&runtime_sched.deferlock);
  while ( 1 )
  {
    if ( sc >= 5 )
      runtime_panicindex();
    v1 = 3 * sc;
    if ( pp->deferpool[sc].len >= pp->deferpool[sc].cap / 2 )
      break;
    v2 = runtime_sched.deferpool[sc];
    if ( !v2 )
      break;
    v15 = runtime_sched.deferpool[sc];
    link = v2->link;
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
    {
      runtime_writebarrierptr((uintptr *)&runtime_sched.deferpool[sc], (uintptr)link);
      runtime_writebarrierptr((uintptr *)&v2->link, 0);
      v1 = 3 * sc;
    }
    else
    {
      runtime_sched.deferpool[sc] = link;
      v2->link = 0;
    }
    v4 = pp;
    v5 = *(&pp->deferpool[0].cap + v1);
    v6 = *(&pp->deferpool[0].len + v1);
    v7 = (uintptr *)*((_DWORD *)&pp->deferpool[0].array + v1);
    if ( v6 + 1 > v5 )
    {
      src.array = (void *)*((_DWORD *)&pp->deferpool[0].array + v1);
      *(_QWORD *)&src.len = __PAIR64__(v5, v6);
      v12 = runtime_growslice((runtime__type_0 *)&stru_80C7140, src, v6 + 1);
      array = (uintptr *)v12.array;
      len = v12.len;
      v10 = 3 * sc;
      pp->deferpool[sc].cap = v12.cap;
      if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      {
        runtime_writebarrierptr((uintptr *)&pp->deferpool[sc], (uintptr)v12.array);
        array = (uintptr *)v12.array;
        len = v12.len;
        v10 = 3 * sc;
      }
      else
      {
        pp->deferpool[sc].array = (runtime__defer **)v12.array;
      }
      v1 = v10;
      v2 = v15;
      v6 = len;
      v7 = array;
      v4 = pp;
    }
    *(&v4->deferpool[0].len + v1) = v6 + 1;
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr(&v7[v6], (uintptr)v2);
    else
      v7[v6] = (uintptr)v2;
  }
  runtime_unlock(&runtime_sched.deferlock);
}
// 808CD59: variable 'v0' is possibly undefined

//----- (0808CF20) --------------------------------------------------------
void __golang runtime_newdefer_func2()
{
  int v0; // edx
  unsigned int v1; // eax
  unsigned int size; // eax
  unsigned int v3; // eax
  unsigned int v4; // eax
  unsigned int v5; // eax
  unsigned int v6; // eax
  runtime__defer *src; // [esp+Ch] [ebp-8h]
  runtime__defer **_d; // [esp+10h] [ebp-4h]

  v1 = *(_DWORD *)(v0 + 4);
  if ( v1 > 4 )
    size = v1 + 28;
  else
    size = 32;
  _d = *(runtime__defer ***)(v0 + 8);
  if ( size >= 0x8000 )
  {
    if ( size + 0x2000 >= size )
      size = (size + 0x1FFF) & 0xFFFFE000;
  }
  else if ( size > 0x3F8 )
  {
    v5 = (size - 897) >> 7;
    if ( v5 >= 0xF9 || (v6 = runtime_size_to_class128[v5], v6 >= 0x43) )
      runtime_panicindex();
    size = runtime_class_to_size[v6];
  }
  else
  {
    v3 = (size + 7) >> 3;
    if ( v3 >= 0x81 || (v4 = runtime_size_to_class8[v3], v4 >= 0x43) )
      runtime_panicindex();
    size = runtime_class_to_size[v4];
  }
  src = (runtime__defer *)runtime_mallocgc(size, (runtime__type_0 *)runtime_deferType, 1);
  if ( *(_DWORD *)&runtime_writeBarrier.enabled )
    runtime_writebarrierptr((uintptr *)_d, (uintptr)src);
  else
    *_d = src;
}
// 808CF39: variable 'v0' is possibly undefined

//----- (0808D040) --------------------------------------------------------
void __golang runtime_freedefer_func1()
{
  int v0; // edx
  runtime_p *v1; // eax
  unsigned int v2; // ecx
  runtime__defer *v3; // edx
  runtime__defer *v4; // ebx
  int v5; // ebp
  runtime__defer **array; // esi
  int len; // edi
  unsigned int v8; // ecx
  runtime__defer *src; // esi
  uintptr sc; // [esp+8h] [ebp-20h]
  runtime_p *pp; // [esp+14h] [ebp-14h]
  runtime__defer *last; // [esp+18h] [ebp-10h]
  runtime__defer *d; // [esp+20h] [ebp-8h]

  v1 = *(runtime_p **)(v0 + 4);
  pp = v1;
  v2 = *(_DWORD *)(v0 + 8);
  sc = v2;
  v3 = 0;
  v4 = 0;
  while ( 1 )
  {
    if ( v2 >= 5 )
      runtime_panicindex();
    last = v3;
    v5 = v2;
    array = v1->deferpool[v2].array;
    len = v1->deferpool[v2].len;
    if ( len <= v1->deferpool[v2].cap / 2 )
      break;
    v8 = len - 1;
    if ( len - 1 >= (unsigned int)len )
      runtime_panicindex();
    d = array[len - 1];
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
    {
      runtime_writebarrierptr((uintptr *)&array[len - 1], 0);
      v1 = pp;
      v8 = len - 1;
    }
    else
    {
      array[len - 1] = 0;
    }
    if ( v8 > v1->deferpool[v5].cap )
      runtime_panicslice();
    v1->deferpool[v5].len = v8;
    if ( v4 )
    {
      if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      {
        runtime_writebarrierptr((uintptr *)&last->link, (uintptr)d);
        v1 = pp;
        v3 = d;
      }
      else
      {
        v3 = d;
        last->link = d;
      }
    }
    else
    {
      v3 = d;
      v4 = d;
    }
    v2 = sc;
  }
  runtime_lock(&runtime_sched.deferlock);
  src = runtime_sched.deferpool[sc];
  if ( *(_DWORD *)&runtime_writeBarrier.enabled )
  {
    runtime_writebarrierptr((uintptr *)&last->link, (uintptr)src);
    runtime_writebarrierptr((uintptr *)&runtime_sched.deferpool[sc], (uintptr)v4);
  }
  else
  {
    last->link = src;
    runtime_sched.deferpool[sc] = v4;
  }
  runtime_unlock(&runtime_sched.deferlock);
}
// 808D040: could not find valid save-restore pair for ebx
// 808D059: variable 'v0' is possibly undefined

//----- (0808D200) --------------------------------------------------------
void __golang runtime_preprintpanics_func1()
{
  string argp; // [esp+0h] [ebp-Ch]
  uintptr v1; // [esp+10h] [ebp+4h] BYREF

  if ( (unsigned int)runtime_gorecover((uintptr)&v1)._type )
  {
    argp.str = (uint8 *)"panic while printing panic value";
    argp.len = 32;
    runtime_throw(argp);
    BUG();
  }
}

//----- (0808D250) --------------------------------------------------------
void __golang __noreturn runtime_dopanic_func1()
{
  int v0; // edx

  runtime_dopanic_m(*(runtime_g **)(v0 + 4), *(_DWORD *)(v0 + 8), *(_DWORD *)(v0 + 12));
}
// 808D265: variable 'v0' is possibly undefined

//----- (0808D290) --------------------------------------------------------
void __golang runtime_main_func1()
{
  runtime_newm(off_80E7CE8, 0);
}

//----- (0808D2D0) --------------------------------------------------------
void __golang runtime_main_func2(bool *&needUnlock)
{
  if ( *&needUnlock )
    runtime_unlockOSThread();
}

//----- (0808D300) --------------------------------------------------------
void __golang runtime_goready_func1()
{
  int v0; // edx

  runtime_ready(*(runtime_g **)(v0 + 4), *(_DWORD *)(v0 + 8), 1);
}
// 808D315: variable 'v0' is possibly undefined

//----- (0808D340) --------------------------------------------------------
void __golang __noreturn runtime_casgstatus_func1()
{
  int v0; // edx
  string s; // [esp+0h] [ebp-10h]
  string sa; // [esp+0h] [ebp-10h]
  string sb; // [esp+0h] [ebp-10h]
  string sc; // [esp+0h] [ebp-10h]
  uint32 oldval; // [esp+8h] [ebp-8h]
  uint32 newval; // [esp+Ch] [ebp-4h]

  oldval = *(_DWORD *)(v0 + 4);
  newval = *(_DWORD *)(v0 + 8);
  runtime_printlock();
  s.str = (uint8 *)"runtime: casgstatus: oldval=";
  s.len = 28;
  runtime_printstring(s);
  runtime_printhex(oldval);
  sa.str = (uint8 *)" newval=";
  sa.len = 8;
  runtime_printstring(sa);
  runtime_printhex(newval);
  sb.str = (uint8 *)"\n";
  sb.len = 1;
  runtime_printstring(sb);
  runtime_printunlock();
  sc.str = (uint8 *)"casgstatus: bad incoming values";
  sc.len = 31;
  runtime_throw(sc);
  BUG();
}
// 808D359: variable 'v0' is possibly undefined

//----- (0808D400) --------------------------------------------------------
void __golang __noreturn runtime_casgstatus_func2()
{
  string s; // [esp+0h] [ebp-8h]

  s.str = (uint8 *)"casgstatus: waiting for Gwaiting but is Grunnable";
  s.len = 49;
  runtime_throw(s);
  BUG();
}

//----- (0808D440) --------------------------------------------------------
void __golang __noreturn runtime_reentersyscall_func1()
{
  int v0; // edx
  unsigned int *v1; // eax
  string s; // [esp+0h] [ebp-14h]
  string sa; // [esp+0h] [ebp-14h]
  string sb; // [esp+0h] [ebp-14h]
  string sc; // [esp+0h] [ebp-14h]
  string sd; // [esp+0h] [ebp-14h]
  unsigned int v; // [esp+8h] [ebp-Ch]
  unsigned int v_4; // [esp+Ch] [ebp-8h]
  unsigned int v9; // [esp+10h] [ebp-4h]

  v1 = *(unsigned int **)(v0 + 4);
  v9 = v1[14];
  v_4 = *v1;
  v = v1[1];
  runtime_printlock();
  s.str = (uint8 *)"entersyscall inconsistent ";
  s.len = 26;
  runtime_printstring(s);
  runtime_printhex(v9);
  sa.str = (uint8 *)" [";
  sa.len = 2;
  runtime_printstring(sa);
  runtime_printhex(v_4);
  sb.str = (uint8 *)",";
  sb.len = 1;
  runtime_printstring(sb);
  runtime_printhex(v);
  sc.str = (uint8 *)"]\n";
  sc.len = 2;
  runtime_printstring(sc);
  runtime_printunlock();
  sd.str = (uint8 *)"entersyscall";
  sd.len = 12;
  runtime_throw(sd);
  BUG();
}
// 808D459: variable 'v0' is possibly undefined
// 80E0D89: using guessed type char asc_80E0D89;

//----- (0808D530) --------------------------------------------------------
void __golang __noreturn runtime_entersyscallblock_func1()
{
  _DWORD *v0; // edx
  unsigned int *v1; // eax
  string s; // [esp+0h] [ebp-1Ch]
  string sa; // [esp+0h] [ebp-1Ch]
  string sb; // [esp+0h] [ebp-1Ch]
  string sc; // [esp+0h] [ebp-1Ch]
  string sd; // [esp+0h] [ebp-1Ch]
  string se; // [esp+0h] [ebp-1Ch]
  string sf; // [esp+0h] [ebp-1Ch]
  uintptr sp3; // [esp+8h] [ebp-14h]
  uintptr sp2; // [esp+Ch] [ebp-10h]
  uintptr sp1; // [esp+10h] [ebp-Ch]
  unsigned int v; // [esp+14h] [ebp-8h]
  unsigned int v_4; // [esp+18h] [ebp-4h]

  v1 = (unsigned int *)v0[4];
  sp1 = v0[1];
  sp2 = v0[2];
  sp3 = v0[3];
  v = *v1;
  v_4 = v1[1];
  runtime_printlock();
  s.str = (uint8 *)"entersyscallblock inconsistent ";
  s.len = 31;
  runtime_printstring(s);
  runtime_printhex(sp1);
  sa.str = (uint8 *)" ";
  sa.len = 1;
  runtime_printstring(sa);
  runtime_printhex(sp2);
  sb.str = (uint8 *)" ";
  sb.len = 1;
  runtime_printstring(sb);
  runtime_printhex(sp3);
  sc.str = (uint8 *)" [";
  sc.len = 2;
  runtime_printstring(sc);
  runtime_printhex(v);
  sd.str = (uint8 *)",";
  sd.len = 1;
  runtime_printstring(sd);
  runtime_printhex(v_4);
  se.str = (uint8 *)"]\n";
  se.len = 2;
  runtime_printstring(se);
  runtime_printunlock();
  sf.str = (uint8 *)"entersyscallblock";
  sf.len = 17;
  runtime_throw(sf);
  BUG();
}
// 808D549: variable 'v0' is possibly undefined
// 80E0D84: using guessed type char go_string__;
// 80E0D89: using guessed type char asc_80E0D89;

//----- (0808D690) --------------------------------------------------------
void __golang __noreturn runtime_entersyscallblock_func2()
{
  int v0; // edx
  unsigned int *v1; // eax
  string s; // [esp+0h] [ebp-1Ch]
  string sa; // [esp+0h] [ebp-1Ch]
  string sb; // [esp+0h] [ebp-1Ch]
  string sc; // [esp+0h] [ebp-1Ch]
  string sd; // [esp+0h] [ebp-1Ch]
  string se; // [esp+0h] [ebp-1Ch]
  string sf; // [esp+0h] [ebp-1Ch]
  uintptr sp_0; // [esp+8h] [ebp-14h]
  unsigned int v; // [esp+Ch] [ebp-10h]
  unsigned int v_4; // [esp+10h] [ebp-Ch]
  unsigned int v12; // [esp+14h] [ebp-8h]
  unsigned int v13; // [esp+18h] [ebp-4h]

  v1 = *(unsigned int **)(v0 + 8);
  sp_0 = *(_DWORD *)(v0 + 4);
  v12 = v1[7];
  v_4 = v1[14];
  v = *v1;
  v13 = v1[1];
  runtime_printlock();
  s.str = (uint8 *)"entersyscallblock inconsistent ";
  s.len = 31;
  runtime_printstring(s);
  runtime_printhex(sp_0);
  sa.str = (uint8 *)" ";
  sa.len = 1;
  runtime_printstring(sa);
  runtime_printhex(v12);
  sb.str = (uint8 *)" ";
  sb.len = 1;
  runtime_printstring(sb);
  runtime_printhex(v_4);
  sc.str = (uint8 *)" [";
  sc.len = 2;
  runtime_printstring(sc);
  runtime_printhex(v);
  sd.str = (uint8 *)",";
  sd.len = 1;
  runtime_printstring(sd);
  runtime_printhex(v13);
  se.str = (uint8 *)"]\n";
  se.len = 2;
  runtime_printstring(se);
  runtime_printunlock();
  sf.str = (uint8 *)"entersyscallblock";
  sf.len = 17;
  runtime_throw(sf);
  BUG();
}
// 808D6A9: variable 'v0' is possibly undefined
// 80E0D84: using guessed type char go_string__;
// 80E0D89: using guessed type char asc_80E0D89;

//----- (0808D7F0) --------------------------------------------------------
void __golang __noreturn runtime_exitsyscall_func1()
{
  string s; // [esp+0h] [ebp-8h]

  s.str = (uint8 *)"exitsyscall: syscall frame is no longer valid";
  s.len = 45;
  runtime_throw(s);
  BUG();
}

//----- (0808D830) --------------------------------------------------------
void __golang runtime_exitsyscallfast_func1()
{
  _DWORD *v0; // edx
  runtime_p *v1; // eax
  bool ts; // [esp+0h] [ebp-14h]
  runtime_p *oldp; // [esp+8h] [ebp-Ch]
  runtime_g *_g_; // [esp+Ch] [ebp-8h]
  bool *_ok; // [esp+10h] [ebp-4h]

  _ok = (bool *)v0[1];
  oldp = (runtime_p *)v0[2];
  _g_ = (runtime_g *)v0[3];
  ts = runtime_exitsyscallfast_pidle();
  *_ok = ts;
  if ( ts && runtime_trace.enabled )
  {
    v1 = oldp;
    if ( oldp )
    {
      while ( v1->syscalltick == _g_->m->syscalltick )
      {
        runtime_osyield();
        v1 = oldp;
      }
    }
    runtime_traceGoSysExit(0LL);
  }
}
// 808D845: variable 'v0' is possibly undefined

//----- (0808D8D0) --------------------------------------------------------
void __golang runtime_exitsyscallfast_reacquired_func1()
{
  int v0; // edx

  runtime_traceGoSysBlock(*(runtime_p **)(*(_DWORD *)(*(_DWORD *)(v0 + 4) + 24) + 92));
  runtime_traceGoSysExit(0LL);
}
// 808D8E5: variable 'v0' is possibly undefined

//----- (0808D920) --------------------------------------------------------
void __golang runtime_malg_func1()
{
  int v0; // edx
  runtime_g *newg; // [esp+Ch] [ebp-4h]

  newg = *(runtime_g **)(v0 + 4);
  newg->stack = runtime_stackalloc(*(_DWORD *)(v0 + 8));
}
// 808D935: variable 'v0' is possibly undefined

//----- (0808D970) --------------------------------------------------------
void __golang runtime_newproc_func1()
{
  int v0; // edx

  runtime_newproc1(
    **(runtime_funcval ***)(v0 + 4),
    *(uint8 **)(v0 + 8),
    **(_DWORD **)(v0 + 12),
    0,
    *(_DWORD *)(v0 + 16));
}
// 808D985: variable 'v0' is possibly undefined

//----- (0808D9C0) --------------------------------------------------------
void __golang runtime_gfget_func1()
{
  int v0; // edx
  runtime_g *gp; // [esp+Ch] [ebp-4h]

  gp = *(runtime_g **)(v0 + 4);
  gp->stack = runtime_stackalloc(0x800u);
}
// 808D9D5: variable 'v0' is possibly undefined

//----- (0808DA10) --------------------------------------------------------
void __golang runtime___ptr_rwmutex__rlock_func1()
{
  int v0; // edx
  uint32 readerPass; // ecx
  runtime_rwmutex_0 *rw; // [esp+4h] [ebp-Ch]
  runtime_m *m; // [esp+8h] [ebp-8h]

  rw = *(runtime_rwmutex_0 **)(v0 + 4);
  runtime_lock(&rw->rLock);
  readerPass = rw->readerPass;
  if ( readerPass )
  {
    rw->readerPass = readerPass - 1;
    runtime_unlock(&rw->rLock);
  }
  else
  {
    m = *(runtime_m **)(*(_DWORD *)(__readgsdword(0) - 4) + 24);
    m->schedlink = rw->readers;
    rw->readers = (runtime_muintptr)m;
    runtime_unlock(&rw->rLock);
    runtime_notesleep(&m->park);
    m->park.key = 0;
  }
}
// 808DA29: variable 'v0' is possibly undefined

//----- (0808DAC0) --------------------------------------------------------
void __golang __noreturn runtime_morestackc_func1()
{
  string s; // [esp+0h] [ebp-8h]

  s.str = (uint8 *)"attempt to execute system stack code on user stack";
  s.len = 50;
  runtime_throw(s);
  BUG();
}

//----- (0808DB00) --------------------------------------------------------
void __golang runtime_callers_func1()
{
  int v0; // edx
  __int32 *v1; // eax
  uintptr pc0; // ecx
  uintptr sp0; // ebx
  runtime_g *gp; // ebp
  __int32 skip; // esi
  uintptr *pcbuf; // edi
  __int32 max; // edx

  v1 = *(__int32 **)(v0 + 4);
  pc0 = *(_DWORD *)(v0 + 8);
  sp0 = *(_DWORD *)(v0 + 12);
  gp = *(runtime_g **)(v0 + 16);
  skip = **(_DWORD **)(v0 + 20);
  pcbuf = *(uintptr **)(v0 + 24);
  max = *(_DWORD *)(v0 + 28);
  if ( !max )
    runtime_panicindex();
  *v1 = runtime_gentraceback(pc0, sp0, 0, gp, skip, pcbuf, max, 0, 0, 0);
}
// 808DB15: variable 'v0' is possibly undefined

//----- (0808DB90) --------------------------------------------------------
void __golang runtime_init()
{
  uint64 b; // [esp+0h] [ebp-10h]
  uint64 ba; // [esp+0h] [ebp-10h]
  uint64 bb; // [esp+0h] [ebp-10h]

  if ( runtime_initdone_ <= 1u )
  {
    if ( runtime_initdone_ == 1 )
      runtime_throwinit();
    runtime_initdone_ = 1;
    runtime_inf = runtime_float64frombits(0x7FF0000000000000uLL);
    LODWORD(b) = &stru_80CF940;
    HIDWORD(b) = &off_80E7BC8;
    runtime_chansendpc = runtime_funcPC((interface_{})b);
    LODWORD(ba) = &stru_80CF900;
    HIDWORD(ba) = &off_80E7BC4;
    runtime_chanrecvpc = runtime_funcPC((interface_{})ba);
    runtime_nanotime();
    runtime_startNano = bb + 0xFFFFFFFF - 0x100000000LL;
    runtime_init_0();
    runtime_init_1();
    runtime_init_2();
    runtime_init_3();
    runtime_init_4();
    runtime_initdone_ = 2;
  }
}
// 808DC3E: variable 'bb' is possibly undefined
// 80E7BC4: using guessed type int (__golang *off_80E7BC4)(runtime_hchan *c, void *ep, bool block, __int16 selected);
// 80E7BC8: using guessed type int (__golang *off_80E7BC8)(runtime_hchan *c, void *ep, bool block, uintptr callerpc, bool _r4);

//----- (0808DC80) --------------------------------------------------------
void __golang runtime_skipPleaseUseCallersFrames()
{
  runtime_rt0_go();
}

//----- (0808DD80) --------------------------------------------------------
void __golang runtime_rt0_go()
{
  unsigned int v0; // kr00_4
  unsigned int v1; // kr04_4
  unsigned int v2; // kr08_4
  unsigned int v3; // eax
  int v9; // esi
  uintptr v19; // eax
  char v20[65424]; // [esp+0h] [ebp-10018h] BYREF
  unsigned int v21; // [esp+FF90h] [ebp-88h]
  unsigned int v22; // [esp+FF94h] [ebp-84h]
  int32 c[30]; // [esp+FF98h] [ebp-80h] BYREF
  int32 v24; // [esp+10010h] [ebp-8h]
  uint8 **v; // [esp+10014h] [ebp-4h]
  int32 v26; // [esp+1001Ch] [ebp+4h]
  uint8 **v27; // [esp+10020h] [ebp+8h]

  v24 = v26;
  v = v27;
  runtime_g0.stackguard0 = (uintptr)v20;
  runtime_g0.stackguard1 = (uintptr)v20;
  runtime_g0.stack.lo = (uintptr)v20;
  runtime_g0.stack.hi = (uintptr)c;
  v0 = __readeflags();
  v22 = v0;
  v1 = __readeflags();
  v21 = v1 ^ 0x200000;
  __writeeflags(v1 ^ 0x200000);
  v2 = __readeflags();
  v3 = v22 ^ v2;
  __writeeflags(v22);
  if ( (v3 & 0x200000) == 0 )
    goto LABEL_2;
  _EAX = 0;
  __asm { cpuid }
  v9 = _EAX;
  if ( _EAX )
  {
    if ( _EBX == 1970169159 && _EDX == 1231384169 && _ECX == 1818588270 )
    {
      runtime_isIntel = 1;
      runtime_lfenceBeforeRdtsc = 1;
    }
    _EAX = 1;
    __asm { cpuid }
    runtime_processorVersionInfo = _EAX;
    if ( (_EDX & 0x800000) == 0 )
    {
LABEL_2:
      c[0] = 2;
      c[1] = (int32)"This program can only be run on processors with MMX support.\n";
      c[2] = 61;
      runtime_write();
      c[0] = 1;
      runtime_exit();
    }
    runtime_support_sse2 = (_EDX & 0x4000000) != 0;
    runtime_support_ssse3 = (_ECX & 0x200) != 0;
    runtime_support_sse41 = (_ECX & 0x80000) != 0;
    runtime_support_sse42 = (_ECX & 0x100000) != 0;
    runtime_support_popcnt = (_ECX & 0x800000) != 0;
    runtime_support_aes = (_ECX & 0x2000000) != 0;
    runtime_support_osxsave = (_ECX & 0x8000000) != 0;
    runtime_support_avx = (_ECX & 0x10000000) != 0;
    if ( v9 >= 7 )
    {
      _EAX = 7;
      __asm { cpuid }
      runtime_support_bmi1 = (_EBX & 8) != 0;
      runtime_support_avx2 = (_EBX & 0x20) != 0;
      runtime_support_bmi2 = (_EBX & 0x100) != 0;
      runtime_support_erms = (_EBX & 0x200) != 0;
    }
    if ( !runtime_support_osxsave )
      goto LABEL_13;
    __asm { xgetbv }
    if ( (_EAX & 6) != 6 )
    {
LABEL_13:
      runtime_support_avx = 0;
      runtime_support_avx2 = 0;
    }
  }
  if ( runtime_bss )
  {
    STACK[0x1FF38] = ((int (__golang *)(runtime_g_0 *, void (__golang *)()))runtime_bss)(&runtime_g0, setg_gcc);
    v19 = runtime_g0.stack.lo + 880;
    runtime_g0.stackguard0 = runtime_g0.stack.lo + 880;
    runtime_g0.stackguard1 = v19;
  }
  else
  {
    runtime_ldt0setup();
    *(_DWORD *)(__readgsdword(0) - 4) = 291;
    if ( runtime_m0.tls[0] != 291 )
      MEMORY[0] = runtime_m0.tls[0];
  }
  *(_DWORD *)(__readgsdword(0) - 4) = &runtime_g0;
  runtime_m0.g0 = &runtime_g0;
  runtime_g0.m = &runtime_m0;
  runtime_emptyfunc();
  runtime_check();
  runtime_args(v24, v);
  runtime_osinit();
  runtime_schedinit();
  runtime_newproc(0, (runtime_funcval *)&runtime_mainPC);
  runtime_mstart();
  __asm { int     3; - software interrupt to invoke the debugger }
}
// 8144F80: invalid function type has been ignored

//----- (0808DFC0) --------------------------------------------------------
void __golang runtime_asminit()
{
  ;
}

//----- (0808DFD0) --------------------------------------------------------
void __golang runtime_gosave()
{
  _DWORD *v0; // eax
  void *retaddr; // [esp+0h] [ebp+0h]
  _DWORD *v2; // [esp+4h] [ebp+4h] BYREF

  v0 = v2;
  *v2 = &v2;
  v0[1] = retaddr;
  v0[4] = 0;
  if ( v0[3] )
    runtime_badctxt();
  v0[2] = *(_DWORD *)(__readgsdword(0) - 4);
}

//----- (0808E010) --------------------------------------------------------
void __golang runtime_gogo()
{
  int v0; // ebx
  int v1; // [esp+Ch] [ebp+4h]

  v0 = v1;
  if ( *(_DWORD *)(v1 + 12) )
  {
    runtime_writebarrierptr_prewrite((uintptr *)(v1 + 12), 0);
    v0 = v1;
  }
  *(_DWORD *)(__readgsdword(0) - 4) = *(_DWORD *)(v0 + 8);
  *(_DWORD *)v0 = 0;
  *(_DWORD *)(v0 + 16) = 0;
  *(_DWORD *)(v0 + 12) = 0;
  (*(void (**)(void))(v0 + 4))();
}

//----- (0808E070) --------------------------------------------------------
void __golang runtime_mcall()
{
  func(_runtime_g) v0; // edi
  unsigned int v1; // edx
  _DWORD *v2; // eax
  _DWORD *v3; // esi
  int retaddr; // [esp+0h] [ebp+0h]
  func(_runtime_g) v5; // [esp+4h] [ebp+4h] BYREF

  v0 = v5;
  v1 = __readgsdword(0);
  v2 = *(_DWORD **)(v1 - 4);
  v2[8] = retaddr;
  v2[7] = &v5;
  v2[9] = v2;
  v3 = **(_DWORD ***)(*(_DWORD *)(v1 - 4) + 24);
  if ( v3 == v2 )
    runtime_badmcall(v5);
  *(_DWORD *)(v1 - 4) = v3;
  retaddr = (*(int (__golang **)(_DWORD *))v0)(v2);
  runtime_badmcall2(v5);
}

//----- (0808E0D0) --------------------------------------------------------
void __golang runtime_systemstack()
{
  _DWORD *v0; // eax
  _DWORD *v1; // ebx
  _DWORD *v2; // edx
  unsigned int v3; // ecx
  int v4; // eax
  void *retaddr; // [esp+0h] [ebp+0h] BYREF
  void (**v6)(void); // [esp+4h] [ebp+4h]

  v0 = *(_DWORD **)(__readgsdword(0) - 4);
  v1 = (_DWORD *)v0[6];
  if ( v0 == (_DWORD *)v1[11] || (v2 = (_DWORD *)*v1, v0 == (_DWORD *)*v1) )
  {
    (*v6)();
  }
  else
  {
    if ( v0 != (_DWORD *)v1[21] )
      runtime_badsystemstack();
    v0[8] = runtime_systemstack_switch;
    v0[7] = &retaddr;
    v0[9] = v0;
    *(_DWORD *)(__readgsdword(0) - 4) = v2;
    *(_DWORD *)(v2[7] - 4) = runtime_mstart;
    (*v6)();
    v3 = __readgsdword(0);
    v4 = *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(v3 - 4) + 24) + 84);
    *(_DWORD *)(v3 - 4) = v4;
    *(_DWORD *)(v4 + 28) = 0;
  }
}

//----- (0808E160) --------------------------------------------------------
void __golang runtime_morestack()
{
  void *v0; // edx
  unsigned int v1; // ecx
  _DWORD *v2; // ebx
  unsigned int v3; // ecx
  _DWORD *v4; // esi
  void *retaddr; // [esp+0h] [ebp+0h]
  int v6; // [esp+4h] [ebp+4h] BYREF
  char v7; // [esp+8h] [ebp+8h] BYREF

  v1 = __readgsdword(0);
  v2 = *(_DWORD **)(*(_DWORD *)(v1 - 4) + 24);
  if ( *(_DWORD *)(v1 - 4) == *v2 )
  {
    runtime_badmorestackg0();
    __asm { int     3; - software interrupt to invoke the debugger }
  }
  if ( *(_DWORD *)(v1 - 4) == v2[11] )
  {
    runtime_badmorestackgsignal();
    __asm { int     3; - software interrupt to invoke the debugger }
  }
  v2[2] = v6;
  v2[1] = &v7;
  v3 = __readgsdword(0);
  v4 = *(_DWORD **)(v3 - 4);
  v2[3] = v4;
  v4[8] = retaddr;
  v4[9] = v4;
  v4[7] = &v6;
  *(_DWORD *)(v3 - 4) = *v2;
  runtime_newstack(v0);
  MEMORY[0x1003] = 0;
}
// 808E184: variable 'v1' is possibly undefined
// 808E1D2: variable 'v0' is possibly undefined

//----- (0808E1F0) --------------------------------------------------------
void __golang runtime_morestack_noctxt()
{
  runtime_morestack();
}

//----- (0808E210) --------------------------------------------------------
void __golang runtime_reflectcall()
{
  unsigned int v0; // [esp+10h] [ebp+10h]

  if ( v0 > 0x10 )
  {
    if ( v0 > 0x20 )
    {
      if ( v0 > 0x40 )
      {
        if ( v0 > 0x80 )
        {
          if ( v0 > 0x100 )
          {
            if ( v0 > 0x200 )
            {
              if ( v0 > 0x400 )
              {
                if ( v0 > 0x800 )
                {
                  if ( v0 > 0x1000 )
                  {
                    if ( v0 > 0x2000 )
                    {
                      if ( v0 > 0x4000 )
                      {
                        if ( v0 > 0x8000 )
                        {
                          if ( v0 > 0x10000 )
                          {
                            if ( v0 > 0x20000 )
                            {
                              if ( v0 > 0x40000 )
                              {
                                if ( v0 > 0x80000 )
                                {
                                  if ( v0 > 0x100000 )
                                  {
                                    if ( v0 > 0x200000 )
                                    {
                                      if ( v0 > 0x400000 )
                                      {
                                        if ( v0 > 0x800000 )
                                        {
                                          if ( v0 > 0x1000000 )
                                          {
                                            if ( v0 > 0x2000000 )
                                            {
                                              if ( v0 > 0x4000000 )
                                              {
                                                if ( v0 > 0x8000000 )
                                                {
                                                  if ( v0 > 0x10000000 )
                                                  {
                                                    if ( v0 > 0x20000000 )
                                                    {
                                                      if ( v0 > 0x40000000 )
                                                        runtime_badreflectcall();
                                                      runtime_call1073741824();
                                                    }
                                                    else
                                                    {
                                                      runtime_call536870912();
                                                    }
                                                  }
                                                  else
                                                  {
                                                    runtime_call268435456();
                                                  }
                                                }
                                                else
                                                {
                                                  runtime_call134217728();
                                                }
                                              }
                                              else
                                              {
                                                runtime_call67108864();
                                              }
                                            }
                                            else
                                            {
                                              runtime_call33554432();
                                            }
                                          }
                                          else
                                          {
                                            runtime_call16777216();
                                          }
                                        }
                                        else
                                        {
                                          runtime_call8388608();
                                        }
                                      }
                                      else
                                      {
                                        runtime_call4194304();
                                      }
                                    }
                                    else
                                    {
                                      runtime_call2097152();
                                    }
                                  }
                                  else
                                  {
                                    runtime_call1048576();
                                  }
                                }
                                else
                                {
                                  runtime_call524288();
                                }
                              }
                              else
                              {
                                runtime_call262144();
                              }
                            }
                            else
                            {
                              runtime_call131072();
                            }
                          }
                          else
                          {
                            runtime_call65536();
                          }
                        }
                        else
                        {
                          runtime_call32768();
                        }
                      }
                      else
                      {
                        runtime_call16384();
                      }
                    }
                    else
                    {
                      runtime_call8192();
                    }
                  }
                  else
                  {
                    runtime_call4096();
                  }
                }
                else
                {
                  runtime_call2048();
                }
              }
              else
              {
                runtime_call1024();
              }
            }
            else
            {
              runtime_call512();
            }
          }
          else
          {
            runtime_call256();
          }
        }
        else
        {
          runtime_call128();
        }
      }
      else
      {
        runtime_call64();
      }
    }
    else
    {
      runtime_call32();
    }
  }
  else
  {
    runtime_call16();
  }
}

//----- (0808E3B0) --------------------------------------------------------
void __golang callRet()
{
  runtime__type_0 *typ; // edx
  uintptr size; // ecx
  void *dst; // edi
  void *src; // esi

  runtime_reflectcallmove(typ, dst, src, size);
}
// 808E3C2: variable 'typ' is possibly undefined
// 808E3C2: variable 'dst' is possibly undefined
// 808E3C2: variable 'src' is possibly undefined
// 808E3C2: variable 'size' is possibly undefined

//----- (0808E3D0) --------------------------------------------------------
void __golang runtime_call16()
{
  int v0; // ecx
  int **v1; // ebx
  _BYTE v2[16]; // [esp+0h] [ebp-10h] BYREF
  int v3; // [esp+14h] [ebp+4h] BYREF
  void (**v4)(void); // [esp+18h] [ebp+8h]
  const void *v5; // [esp+1Ch] [ebp+Ch]
  unsigned int v6; // [esp+20h] [ebp+10h]

  v1 = *(int ***)(v0 + 16);
  if ( v1 && *v1 == &v3 )
    *v1 = (int *)v2;
  qmemcpy(v2, v5, v6);
  (*v4)();
  callRet();
}
// 808E3E5: variable 'v0' is possibly undefined

//----- (0808E440) --------------------------------------------------------
void __golang runtime_call32()
{
  int v0; // ecx
  int **v1; // ebx
  _BYTE v2[32]; // [esp+0h] [ebp-20h] BYREF
  int v3; // [esp+24h] [ebp+4h] BYREF
  void (**v4)(void); // [esp+28h] [ebp+8h]
  const void *v5; // [esp+2Ch] [ebp+Ch]
  unsigned int v6; // [esp+30h] [ebp+10h]

  v1 = *(int ***)(v0 + 16);
  if ( v1 && *v1 == &v3 )
    *v1 = (int *)v2;
  qmemcpy(v2, v5, v6);
  (*v4)();
  callRet();
}
// 808E455: variable 'v0' is possibly undefined

//----- (0808E4B0) --------------------------------------------------------
void __golang runtime_call64()
{
  int v0; // ecx
  int **v1; // ebx
  _BYTE v2[64]; // [esp+0h] [ebp-40h] BYREF
  int v3; // [esp+44h] [ebp+4h] BYREF
  void (**v4)(void); // [esp+48h] [ebp+8h]
  const void *v5; // [esp+4Ch] [ebp+Ch]
  unsigned int v6; // [esp+50h] [ebp+10h]

  v1 = *(int ***)(v0 + 16);
  if ( v1 && *v1 == &v3 )
    *v1 = (int *)v2;
  qmemcpy(v2, v5, v6);
  (*v4)();
  callRet();
}
// 808E4C5: variable 'v0' is possibly undefined

//----- (0808E520) --------------------------------------------------------
void __golang runtime_call128()
{
  int v0; // ecx
  int **v1; // ebx
  _BYTE v2[128]; // [esp+0h] [ebp-80h] BYREF
  int v3; // [esp+84h] [ebp+4h] BYREF
  void (**v4)(void); // [esp+88h] [ebp+8h]
  const void *v5; // [esp+8Ch] [ebp+Ch]
  unsigned int v6; // [esp+90h] [ebp+10h]

  v1 = *(int ***)(v0 + 16);
  if ( v1 && *v1 == &v3 )
    *v1 = (int *)v2;
  qmemcpy(v2, v5, v6);
  (*v4)();
  callRet();
}
// 808E538: variable 'v0' is possibly undefined

//----- (0808E5B0) --------------------------------------------------------
void __golang runtime_call256()
{
  int v0; // ecx
  int **v1; // ebx
  _BYTE v2[128]; // [esp-80h] [ebp-100h] BYREF
  char v3; // [esp+0h] [ebp-80h] BYREF
  int v4; // [esp+84h] [ebp+4h] BYREF
  void (**v5)(void); // [esp+88h] [ebp+8h]
  const void *v6; // [esp+8Ch] [ebp+Ch]
  unsigned int v7; // [esp+90h] [ebp+10h]

  while ( 1 )
  {
    v0 = *(_DWORD *)(__readgsdword(0) - 4);
    if ( (unsigned int)&v3 > *(_DWORD *)(v0 + 8) )
      break;
    runtime_morestack_noctxt();
  }
  v1 = *(int ***)(v0 + 16);
  if ( v1 && *v1 == &v4 )
    *v1 = (int *)v2;
  qmemcpy(v2, v6, v7);
  (*v5)();
  callRet();
}

//----- (0808E640) --------------------------------------------------------
void __golang runtime_call512()
{
  int v0; // ecx
  int **v1; // ebx
  _BYTE v2[128]; // [esp-80h] [ebp-200h] BYREF
  char v3; // [esp+0h] [ebp-180h] BYREF
  int v4; // [esp+184h] [ebp+4h] BYREF
  void (**v5)(void); // [esp+188h] [ebp+8h]
  const void *v6; // [esp+18Ch] [ebp+Ch]
  unsigned int v7; // [esp+190h] [ebp+10h]

  while ( 1 )
  {
    v0 = *(_DWORD *)(__readgsdword(0) - 4);
    if ( (unsigned int)&v3 > *(_DWORD *)(v0 + 8) )
      break;
    runtime_morestack_noctxt();
  }
  v1 = *(int ***)(v0 + 16);
  if ( v1 && *v1 == &v4 )
    *v1 = (int *)v2;
  qmemcpy(v2, v6, v7);
  (*v5)();
  callRet();
}

//----- (0808E6D0) --------------------------------------------------------
void __golang runtime_call1024()
{
  int v0; // ecx
  int **v1; // ebx
  _BYTE v2[128]; // [esp-80h] [ebp-400h] BYREF
  char v3; // [esp+0h] [ebp-380h] BYREF
  int v4; // [esp+384h] [ebp+4h] BYREF
  void (**v5)(void); // [esp+388h] [ebp+8h]
  const void *v6; // [esp+38Ch] [ebp+Ch]
  unsigned int v7; // [esp+390h] [ebp+10h]

  while ( 1 )
  {
    v0 = *(_DWORD *)(__readgsdword(0) - 4);
    if ( (unsigned int)&v3 > *(_DWORD *)(v0 + 8) )
      break;
    runtime_morestack_noctxt();
  }
  v1 = *(int ***)(v0 + 16);
  if ( v1 && *v1 == &v4 )
    *v1 = (int *)v2;
  qmemcpy(v2, v6, v7);
  (*v5)();
  callRet();
}

//----- (0808E760) --------------------------------------------------------
void __golang runtime_call2048()
{
  int v0; // ecx
  int **v1; // ebx
  _BYTE v2[128]; // [esp-80h] [ebp-800h] BYREF
  char v3; // [esp+0h] [ebp-780h] BYREF
  int v4; // [esp+784h] [ebp+4h] BYREF
  void (**v5)(void); // [esp+788h] [ebp+8h]
  const void *v6; // [esp+78Ch] [ebp+Ch]
  unsigned int v7; // [esp+790h] [ebp+10h]

  while ( 1 )
  {
    v0 = *(_DWORD *)(__readgsdword(0) - 4);
    if ( (unsigned int)&v3 > *(_DWORD *)(v0 + 8) )
      break;
    runtime_morestack_noctxt();
  }
  v1 = *(int ***)(v0 + 16);
  if ( v1 && *v1 == &v4 )
    *v1 = (int *)v2;
  qmemcpy(v2, v6, v7);
  (*v5)();
  callRet();
}

//----- (0808E7F0) --------------------------------------------------------
void __golang runtime_call4096()
{
  int v0; // ecx
  int **v1; // ebx
  _BYTE v2[128]; // [esp-80h] [ebp-1000h] BYREF
  char v3; // [esp+0h] [ebp-F80h] BYREF
  int v4; // [esp+F84h] [ebp+4h] BYREF
  void (**v5)(void); // [esp+F88h] [ebp+8h]
  const void *v6; // [esp+F8Ch] [ebp+Ch]
  unsigned int v7; // [esp+F90h] [ebp+10h]

  while ( 1 )
  {
    v0 = *(_DWORD *)(__readgsdword(0) - 4);
    if ( (unsigned int)&v3 > *(_DWORD *)(v0 + 8) )
      break;
    runtime_morestack_noctxt();
  }
  v1 = *(int ***)(v0 + 16);
  if ( v1 && *v1 == &v4 )
    *v1 = (int *)v2;
  qmemcpy(v2, v6, v7);
  (*v5)();
  callRet();
}

//----- (0808E880) --------------------------------------------------------
void __golang runtime_call8192()
{
  int v0; // ecx
  int v1; // esi
  int **v2; // ebx
  _BYTE v3[8192]; // [esp-2000h] [ebp-2000h] BYREF
  int v4; // [esp+4h] [ebp+4h] BYREF
  void (**v5)(void); // [esp+8h] [ebp+8h]
  const void *v6; // [esp+Ch] [ebp+Ch]
  unsigned int v7; // [esp+10h] [ebp+10h]

  while ( 1 )
  {
    v0 = *(_DWORD *)(__readgsdword(0) - 4);
    v1 = *(_DWORD *)(v0 + 8);
    if ( v1 != -1314 && (unsigned int)&STACK[0x370] - v1 > 0x22F0 )
      break;
    runtime_morestack_noctxt();
  }
  v2 = *(int ***)(v0 + 16);
  if ( v2 && *v2 == &v4 )
    *v2 = (int *)v3;
  qmemcpy(v3, v6, v7);
  (*v5)();
  callRet();
}

//----- (0808E920) --------------------------------------------------------
void __golang runtime_call16384()
{
  int v0; // ecx
  int v1; // esi
  int **v2; // ebx
  _BYTE v3[16384]; // [esp-4000h] [ebp-4000h] BYREF
  int v4; // [esp+4h] [ebp+4h] BYREF
  void (**v5)(void); // [esp+8h] [ebp+8h]
  const void *v6; // [esp+Ch] [ebp+Ch]
  unsigned int v7; // [esp+10h] [ebp+10h]

  while ( 1 )
  {
    v0 = *(_DWORD *)(__readgsdword(0) - 4);
    v1 = *(_DWORD *)(v0 + 8);
    if ( v1 != -1314 && (unsigned int)&STACK[0x370] - v1 > 0x42F0 )
      break;
    runtime_morestack_noctxt();
  }
  v2 = *(int ***)(v0 + 16);
  if ( v2 && *v2 == &v4 )
    *v2 = (int *)v3;
  qmemcpy(v3, v6, v7);
  (*v5)();
  callRet();
}

//----- (0808E9C0) --------------------------------------------------------
void __golang runtime_call32768()
{
  int v0; // ecx
  int v1; // esi
  int **v2; // ebx
  _BYTE v3[32768]; // [esp-8000h] [ebp-8000h] BYREF
  int v4; // [esp+4h] [ebp+4h] BYREF
  void (**v5)(void); // [esp+8h] [ebp+8h]
  const void *v6; // [esp+Ch] [ebp+Ch]
  unsigned int v7; // [esp+10h] [ebp+10h]

  while ( 1 )
  {
    v0 = *(_DWORD *)(__readgsdword(0) - 4);
    v1 = *(_DWORD *)(v0 + 8);
    if ( v1 != -1314 && (unsigned int)&STACK[0x370] - v1 > 0x82F0 )
      break;
    runtime_morestack_noctxt();
  }
  v2 = *(int ***)(v0 + 16);
  if ( v2 && *v2 == &v4 )
    *v2 = (int *)v3;
  qmemcpy(v3, v6, v7);
  (*v5)();
  callRet();
}

//----- (0808EA60) --------------------------------------------------------
void __golang runtime_call65536()
{
  int v0; // ecx
  int v1; // esi
  int **v2; // ebx
  _BYTE v3[65536]; // [esp-10000h] [ebp-10000h] BYREF
  int v4; // [esp+4h] [ebp+4h] BYREF
  void (**v5)(void); // [esp+8h] [ebp+8h]
  const void *v6; // [esp+Ch] [ebp+Ch]
  unsigned int v7; // [esp+10h] [ebp+10h]

  while ( 1 )
  {
    v0 = *(_DWORD *)(__readgsdword(0) - 4);
    v1 = *(_DWORD *)(v0 + 8);
    if ( v1 != -1314 && (unsigned int)&STACK[0x370] - v1 > 0x102F0 )
      break;
    runtime_morestack_noctxt();
  }
  v2 = *(int ***)(v0 + 16);
  if ( v2 && *v2 == &v4 )
    *v2 = (int *)v3;
  qmemcpy(v3, v6, v7);
  (*v5)();
  callRet();
}

//----- (0808EB00) --------------------------------------------------------
void __golang runtime_call131072()
{
  int v0; // ecx
  int v1; // esi
  int **v2; // ebx
  _BYTE v3[131072]; // [esp-20000h] [ebp-20000h] BYREF
  int v4; // [esp+4h] [ebp+4h] BYREF
  void (**v5)(void); // [esp+8h] [ebp+8h]
  const void *v6; // [esp+Ch] [ebp+Ch]
  unsigned int v7; // [esp+10h] [ebp+10h]

  while ( 1 )
  {
    v0 = *(_DWORD *)(__readgsdword(0) - 4);
    v1 = *(_DWORD *)(v0 + 8);
    if ( v1 != -1314 && (unsigned int)&STACK[0x370] - v1 > 0x202F0 )
      break;
    runtime_morestack_noctxt();
  }
  v2 = *(int ***)(v0 + 16);
  if ( v2 && *v2 == &v4 )
    *v2 = (int *)v3;
  qmemcpy(v3, v6, v7);
  (*v5)();
  callRet();
}

//----- (0808EBA0) --------------------------------------------------------
void __golang runtime_call262144()
{
  int v0; // ecx
  int v1; // esi
  int **v2; // ebx
  _BYTE v3[262144]; // [esp-40000h] [ebp-40000h] BYREF
  int v4; // [esp+4h] [ebp+4h] BYREF
  void (**v5)(void); // [esp+8h] [ebp+8h]
  const void *v6; // [esp+Ch] [ebp+Ch]
  unsigned int v7; // [esp+10h] [ebp+10h]

  while ( 1 )
  {
    v0 = *(_DWORD *)(__readgsdword(0) - 4);
    v1 = *(_DWORD *)(v0 + 8);
    if ( v1 != -1314 && (unsigned int)&STACK[0x370] - v1 > 0x402F0 )
      break;
    runtime_morestack_noctxt();
  }
  v2 = *(int ***)(v0 + 16);
  if ( v2 && *v2 == &v4 )
    *v2 = (int *)v3;
  qmemcpy(v3, v6, v7);
  (*v5)();
  callRet();
}

//----- (0808EC40) --------------------------------------------------------
void __golang runtime_call524288()
{
  int v0; // ecx
  int v1; // esi
  int **v2; // ebx
  _BYTE v3[524288]; // [esp-80000h] [ebp-80000h] BYREF
  int v4; // [esp+4h] [ebp+4h] BYREF
  void (**v5)(void); // [esp+8h] [ebp+8h]
  const void *v6; // [esp+Ch] [ebp+Ch]
  unsigned int v7; // [esp+10h] [ebp+10h]

  while ( 1 )
  {
    v0 = *(_DWORD *)(__readgsdword(0) - 4);
    v1 = *(_DWORD *)(v0 + 8);
    if ( v1 != -1314 && (unsigned int)&STACK[0x370] - v1 > 0x802F0 )
      break;
    runtime_morestack_noctxt();
  }
  v2 = *(int ***)(v0 + 16);
  if ( v2 && *v2 == &v4 )
    *v2 = (int *)v3;
  qmemcpy(v3, v6, v7);
  (*v5)();
  callRet();
}

//----- (0808ECE0) --------------------------------------------------------
#error "808ECE0: stack frame is too big (funcsize=0)"

//----- (0808ED80) --------------------------------------------------------
#error "808ED80: stack frame is too big (funcsize=0)"

//----- (0808EE20) --------------------------------------------------------
#error "808EE20: stack frame is too big (funcsize=0)"

//----- (0808EEC0) --------------------------------------------------------
#error "808EEC0: stack frame is too big (funcsize=0)"

//----- (0808EF60) --------------------------------------------------------
#error "808EF60: stack frame is too big (funcsize=0)"

//----- (0808F000) --------------------------------------------------------
#error "808F000: stack frame is too big (funcsize=0)"

//----- (0808F0A0) --------------------------------------------------------
#error "808F0A0: stack frame is too big (funcsize=0)"

//----- (0808F140) --------------------------------------------------------
#error "808F140: stack frame is too big (funcsize=0)"

//----- (0808F1E0) --------------------------------------------------------
#error "808F1E0: stack frame is too big (funcsize=0)"

//----- (0808F280) --------------------------------------------------------
#error "808F280: stack frame is too big (funcsize=0)"

//----- (0808F320) --------------------------------------------------------
#error "808F320: stack frame is too big (funcsize=0)"

//----- (0808F3C0) --------------------------------------------------------
void __golang runtime_procyield()
{
  int v0; // eax
  int v1; // [esp+4h] [ebp+4h]

  v0 = v1;
  do
  {
    _mm_pause();
    --v0;
  }
  while ( v0 );
}

//----- (0808F3E0) --------------------------------------------------------
void __golang runtime_jmpdefer()
{
  char *retaddr; // [esp+4h] [ebp+0h]
  void (**v1)(void); // [esp+8h] [ebp+4h]

  retaddr -= 5;
  (*v1)();
}

//----- (0808F400) --------------------------------------------------------
void __golang gosave()
{
  _DWORD *v0; // ebx
  void *retaddr; // [esp+8h] [ebp+0h]
  char v2; // [esp+Ch] [ebp+4h] BYREF

  v0 = *(_DWORD **)(__readgsdword(0) - 4);
  v0[7] = &v2;
  v0[8] = retaddr;
  v0[11] = 0;
  if ( v0[10] )
    runtime_badctxt();
}

//----- (0808F440) --------------------------------------------------------
void __golang runtime_asmcgocall()
{
  int (__golang *v0)(int, int, int); // eax
  int *v1; // edx
  unsigned int v2; // ecx
  int v3; // esi
  int v4; // edi
  int retaddr; // [esp+20h] [ebp+0h] BYREF
  int (__golang *v6)(int, int, int); // [esp+24h] [ebp+4h]
  int v7; // [esp+28h] [ebp+8h]

  v0 = v6;
  v1 = &retaddr;
  v2 = __readgsdword(0);
  v3 = **(_DWORD **)(*(_DWORD *)(v2 - 4) + 24);
  v4 = *(_DWORD *)(v2 - 4);
  if ( v3 != v4 )
  {
    gosave();
    *(_DWORD *)(__readgsdword(0) - 4) = v3;
  }
  retaddr = v0(v7, *(_DWORD *)(v4 + 4) - (_DWORD)v1, v4);
  *(_DWORD *)(__readgsdword(0) - 4) = v7;
}
// 808F492: variable 'v0' is possibly undefined
// 808F48B: variable 'v1' is possibly undefined

//----- (0808F4C0) --------------------------------------------------------
void __golang runtime_cgocallback_gofunc()
{
  unsigned int v0; // ecx
  int v1; // ebp
  _DWORD *v2; // ebp
  int v3; // edx
  int v4; // esi
  int v5; // esi
  int v6; // edx
  unsigned int v7; // ecx
  int v8; // esi
  int v9; // esi
  uint8 x[4]; // [esp+0h] [ebp-Ch] BYREF
  int v11; // [esp+4h] [ebp-8h]
  void *retaddr; // [esp+Ch] [ebp+0h]
  char v13; // [esp+10h] [ebp+4h] BYREF
  uintptr ctxt; // [esp+1Ch] [ebp+10h]

  v0 = __readgsdword(0);
  v1 = *(_DWORD *)(v0 - 4);
  if ( v1 )
  {
    v2 = *(_DWORD **)(v1 + 24);
    v3 = (int)v2;
  }
  else
  {
    runtime_needm(0);
    v3 = *(_DWORD *)x;
    v0 = __readgsdword(0);
    v2 = *(_DWORD **)(*(_DWORD *)(v0 - 4) + 24);
    *(_DWORD *)(*v2 + 28) = x;
  }
  v4 = *v2;
  *(_DWORD *)x = *(_DWORD *)(*v2 + 28);
  *(_DWORD *)(v4 + 28) = x;
  v5 = v2[21];
  *(_DWORD *)(v0 - 4) = v5;
  *(_DWORD *)(*(_DWORD *)(v5 + 28) - 4) = *(_DWORD *)(v5 + 32);
  v11 = v3;
  runtime_cgocallbackg(ctxt);
  v6 = v11;
  v7 = __readgsdword(0);
  v8 = *(_DWORD *)(v7 - 4);
  *(_DWORD *)(v8 + 32) = retaddr;
  *(_DWORD *)(v8 + 28) = &v13;
  v9 = **(_DWORD **)(*(_DWORD *)(v7 - 4) + 24);
  *(_DWORD *)(v7 - 4) = v9;
  *(_DWORD *)(v9 + 28) = *(_DWORD *)x;
  if ( !v6 )
    runtime_dropm();
}

//----- (0808F580) --------------------------------------------------------
void __golang runtime_setg()
{
  int v0; // [esp+4h] [ebp+4h]

  *(_DWORD *)(__readgsdword(0) - 4) = v0;
}

//----- (0808F5A0) --------------------------------------------------------
void __golang setg_gcc()
{
  int v0; // [esp+4h] [ebp+4h]

  *(_DWORD *)(__readgsdword(0) - 4) = v0;
}

//----- (0808F5C0) --------------------------------------------------------
void __golang runtime_stackcheck()
{
  _DWORD *v0; // eax
  void *retaddr; // [esp+0h] [ebp+0h] BYREF

  v0 = *(_DWORD **)(__readgsdword(0) - 4);
  if ( v0[1] <= (unsigned int)&retaddr )
    __asm { int     3; - software interrupt to invoke the debugger }
  if ( (unsigned int)&retaddr <= *v0 )
    __asm { int     3; - software interrupt to invoke the debugger }
}

//----- (0808F5E0) --------------------------------------------------------
void __golang runtime_getcallerpc()
{
  ;
}

//----- (0808F600) --------------------------------------------------------
void __golang runtime_cputicks()
{
  if ( runtime_support_sse2 )
  {
    if ( runtime_lfenceBeforeRdtsc )
      _mm_lfence();
    else
      _mm_mfence();
  }
  __rdtsc();
}

//----- (0808F630) --------------------------------------------------------
void __golang runtime_ldt0setup()
{
  runtime_setldt();
}

//----- (0808F660) --------------------------------------------------------
void __golang runtime_emptyfunc()
{
  ;
}

//----- (0808F680) --------------------------------------------------------
void __golang runtime_memhash_varlen()
{
  int v0; // edx
  void *p; // [esp+14h] [ebp+4h]
  uintptr seed; // [esp+18h] [ebp+8h]

  runtime_memhash(p, seed, *(_DWORD *)(v0 + 4));
}
// 808F68B: variable 'v0' is possibly undefined

//----- (0808F6B0) --------------------------------------------------------
void __golang runtime_aeshash()
{
  runtime_aeshashbody();
}

//----- (0808F6D0) --------------------------------------------------------
void __golang runtime_aeshashstr()
{
  runtime_aeshashbody();
}

//----- (0808F6F0) --------------------------------------------------------
void __golang runtime_aeshashbody()
{
  const __m128i *v0; // eax
  _DWORD *v1; // edx
  unsigned int v2; // ebx
  __m128i v3; // xmm1
  const __m128i *v6; // eax
  __m128i v22; // xmm2
  __m128i v23; // xmm3
  __m128i v46; // xmm2
  __m128i v47; // xmm3
  unsigned int v62; // ebx
  unsigned int v79; // [esp+8h] [ebp+8h]

  v3 = _mm_shufflehi_epi16(_mm_insert_epi16(_mm_cvtsi32_si128(v79), v2, 4), 0);
  _XMM0 = _mm_xor_si128(v3, *(__m128i *)&runtime_aeskeysched.array);
  __asm { aesenc  xmm0, xmm0 }
  if ( v2 < 0x10 )
  {
    if ( !v2 )
    {
      __asm { aesenc  xmm0, xmm0 }
      *v1 = _mm_cvtsi128_si32(_XMM0);
      return;
    }
    v6 = v0 + 1;
    if ( ((unsigned __int16)v6 & 0xFF0) != 0 )
      _XMM1 = _mm_and_si128(_mm_loadu_si128(v6 - 1), masks[v2]);
    else
      _XMM1 = _mm_shuffle_epi8(_mm_loadu_si128((const __m128i *)((char *)v6 + v2 - 32)), shifts[v2]);
LABEL_9:
    __asm
    {
      aesenc  xmm1, xmm0
      aesenc  xmm1, xmm1
      aesenc  xmm1, xmm1
    }
    *v1 = _mm_cvtsi128_si32(_XMM1);
    return;
  }
  if ( v2 == 16 )
  {
    _XMM1 = _mm_loadu_si128(v0);
    goto LABEL_9;
  }
  if ( v2 <= 0x20 )
  {
    _XMM1 = _mm_xor_si128(v3, unk_81577B0);
    __asm { aesenc  xmm1, xmm1 }
    _XMM2 = _mm_loadu_si128(v0);
    _XMM3 = _mm_loadu_si128((const __m128i *)((char *)v0 + v2 - 16));
    __asm
    {
      aesenc  xmm2, xmm0
      aesenc  xmm3, xmm1
      aesenc  xmm2, xmm2
      aesenc  xmm3, xmm3
      aesenc  xmm2, xmm2
      aesenc  xmm3, xmm3
    }
    *v1 = _mm_cvtsi128_si32(_mm_xor_si128(_XMM2, _XMM3));
  }
  else if ( v2 <= 0x40 )
  {
    v22 = v3;
    v23 = v3;
    _XMM1 = _mm_xor_si128(v3, unk_81577B0);
    _XMM2 = _mm_xor_si128(v22, unk_81577C0);
    _XMM3 = _mm_xor_si128(v23, unk_81577D0);
    __asm
    {
      aesenc  xmm1, xmm1
      aesenc  xmm2, xmm2
      aesenc  xmm3, xmm3
    }
    _XMM4 = _mm_loadu_si128(v0);
    _XMM5 = _mm_loadu_si128(v0 + 1);
    _XMM6 = _mm_loadu_si128((const __m128i *)((char *)v0 + v2 - 32));
    _XMM7 = _mm_loadu_si128((const __m128i *)((char *)v0 + v2 - 16));
    __asm
    {
      aesenc  xmm4, xmm0
      aesenc  xmm5, xmm1
      aesenc  xmm6, xmm2
      aesenc  xmm7, xmm3
      aesenc  xmm4, xmm4
      aesenc  xmm5, xmm5
      aesenc  xmm6, xmm6
      aesenc  xmm7, xmm7
      aesenc  xmm4, xmm4
      aesenc  xmm5, xmm5
      aesenc  xmm6, xmm6
      aesenc  xmm7, xmm7
    }
    *v1 = _mm_cvtsi128_si32(_mm_xor_si128(_mm_xor_si128(_XMM4, _XMM6), _mm_xor_si128(_XMM5, _XMM7)));
  }
  else
  {
    v46 = v3;
    v47 = v3;
    _XMM1 = _mm_xor_si128(v3, unk_81577B0);
    _XMM2 = _mm_xor_si128(v46, unk_81577C0);
    _XMM3 = _mm_xor_si128(v47, unk_81577D0);
    __asm
    {
      aesenc  xmm1, xmm1
      aesenc  xmm2, xmm2
      aesenc  xmm3, xmm3
    }
    _XMM4 = _mm_loadu_si128((const __m128i *)((char *)v0 + v2 - 64));
    _XMM5 = _mm_loadu_si128((const __m128i *)((char *)v0 + v2 - 48));
    _XMM6 = _mm_loadu_si128((const __m128i *)((char *)v0 + v2 - 32));
    _XMM7 = _mm_loadu_si128((const __m128i *)((char *)v0 + v2 - 16));
    __asm
    {
      aesenc  xmm4, xmm0
      aesenc  xmm5, xmm1
      aesenc  xmm6, xmm2
      aesenc  xmm7, xmm3
    }
    v62 = (v2 - 1) >> 6;
    do
    {
      _XMM0 = _mm_loadu_si128(v0);
      _XMM1 = _mm_loadu_si128(v0 + 1);
      _XMM2 = _mm_loadu_si128(v0 + 2);
      _XMM3 = _mm_loadu_si128(v0 + 3);
      __asm
      {
        aesenc  xmm4, xmm0
        aesenc  xmm5, xmm1
        aesenc  xmm6, xmm2
        aesenc  xmm7, xmm3
        aesenc  xmm4, xmm4
        aesenc  xmm5, xmm5
        aesenc  xmm6, xmm6
        aesenc  xmm7, xmm7
      }
      v0 += 4;
      --v62;
    }
    while ( v62 );
    __asm
    {
      aesenc  xmm4, xmm4
      aesenc  xmm5, xmm5
      aesenc  xmm6, xmm6
      aesenc  xmm7, xmm7
      aesenc  xmm4, xmm4
      aesenc  xmm5, xmm5
      aesenc  xmm6, xmm6
      aesenc  xmm7, xmm7
    }
    *v1 = _mm_cvtsi128_si32(_mm_xor_si128(_mm_xor_si128(_XMM4, _XMM6), _mm_xor_si128(_XMM5, _XMM7)));
  }
}
// 808F6F6: variable 'v2' is possibly undefined
// 808F87E: variable 'v0' is possibly undefined
// 808F757: variable 'v1' is possibly undefined
// 80F2120: using guessed type __m128i masks[16];
// 80F2220: using guessed type __m128i shifts[16];

//----- (0808F930) --------------------------------------------------------
void __golang runtime_aeshash32()
{
  int *v4; // [esp+4h] [ebp+4h]
  unsigned int v5; // [esp+8h] [ebp+8h]

  _XMM0 = _mm_insert_epi32(_mm_cvtsi32_si128(v5), *v4, 1);
  __asm
  {
    aesenc  xmm0, xmmword ptr ds:runtime_aeskeysched.array
    aesenc  xmm0, xmmword ptr ds:unk_81577B0
    aesenc  xmm0, xmmword ptr ds:unk_81577C0
  }
}

//----- (0808F970) --------------------------------------------------------
void __golang runtime_aeshash64()
{
  const __m128i *v4; // [esp+4h] [ebp+4h]
  int v5; // [esp+8h] [ebp+8h]

  _XMM0 = _mm_insert_epi32(_mm_loadl_epi64(v4), v5, 2);
  __asm
  {
    aesenc  xmm0, xmmword ptr ds:runtime_aeskeysched.array
    aesenc  xmm0, xmmword ptr ds:unk_81577B0
    aesenc  xmm0, xmmword ptr ds:unk_81577C0
  }
}

//----- (0808F9B0) --------------------------------------------------------
void __golang runtime_checkASM()
{
  ;
}

//----- (0808F9D0) --------------------------------------------------------
void __golang runtime_memequal()
{
  int v0; // [esp+4h] [ebp+4h]
  int v1; // [esp+8h] [ebp+8h]

  if ( v0 != v1 )
    runtime_memeqbody();
}

//----- (0808F9F0) --------------------------------------------------------
void __golang runtime_memequal_varlen()
{
  int v0; // [esp+4h] [ebp+4h]
  int v1; // [esp+8h] [ebp+8h]

  if ( v0 != v1 )
    runtime_memeqbody();
}

//----- (0808FA10) --------------------------------------------------------
void __golang runtime_eqstring()
{
  int v0; // [esp+4h] [ebp+4h]
  int v1; // [esp+Ch] [ebp+Ch]

  if ( v0 != v1 )
    runtime_memeqbody();
}

//----- (0808FA30) --------------------------------------------------------
void __golang runtime_memeqbody()
{
  bool *v0; // eax
  unsigned int v1; // ebx
  const __m128i *v2; // edi
  const __m128i *v3; // esi
  int v4; // edx
  __int32 v5; // ecx
  __int32 v6; // edx
  bool v7; // zf
  char v8; // cl
  unsigned __int32 v9; // esi
  unsigned __int32 v10; // edi

  if ( v1 < 4 )
  {
    v7 = v1 == 0;
    if ( v1 )
    {
      v8 = -8 * v1;
      if ( (unsigned __int8)v3 > 0xFCu )
        v9 = *(unsigned __int32 *)((char *)&v3->m128i_i32[-1] + v1) >> v8;
      else
        v9 = v3->m128i_i32[0];
      if ( (unsigned __int8)v2 > 0xFCu )
        v10 = *(unsigned __int32 *)((char *)&v2->m128i_i32[-1] + v1) >> v8;
      else
        v10 = v2->m128i_i32[0];
      v7 = (v10 - v9) << v8 == 0;
    }
    *v0 = v7;
  }
  else
  {
    while ( v1 >= 0x40 && runtime_support_sse2 )
    {
      v4 = _mm_movemask_epi8(
             _mm_and_si128(
               _mm_and_si128(
                 _mm_cmpeq_epi8(_mm_loadu_si128(v3), _mm_loadu_si128(v2)),
                 _mm_cmpeq_epi8(_mm_loadu_si128(v3 + 1), _mm_loadu_si128(v2 + 1))),
               _mm_and_si128(
                 _mm_cmpeq_epi8(_mm_loadu_si128(v3 + 2), _mm_loadu_si128(v2 + 2)),
                 _mm_cmpeq_epi8(_mm_loadu_si128(v3 + 3), _mm_loadu_si128(v2 + 3)))));
      v3 += 4;
      v2 += 4;
      v1 -= 64;
      if ( v4 != 0xFFFF )
      {
        *v0 = 0;
        return;
      }
    }
    while ( v1 > 4 )
    {
      v5 = v3->m128i_i32[0];
      v6 = v2->m128i_i32[0];
      v3 = (const __m128i *)((char *)v3 + 4);
      v2 = (const __m128i *)((char *)v2 + 4);
      v1 -= 4;
      if ( v5 != v6 )
      {
        *v0 = 0;
        return;
      }
    }
    *v0 = *(__int32 *)((char *)&v3->m128i_i32[-1] + v1) == *(__int32 *)((char *)&v2->m128i_i32[-1] + v1);
  }
}
// 808FA33: variable 'v1' is possibly undefined
// 808FA47: variable 'v3' is possibly undefined
// 808FA4B: variable 'v2' is possibly undefined
// 808FA9E: variable 'v0' is possibly undefined

//----- (0808FB10) --------------------------------------------------------
void __golang runtime_cmpstring()
{
  runtime_cmpbody();
}

//----- (0808FB30) --------------------------------------------------------
void __golang strings_IndexByte()
{
  int v0; // ecx
  _BYTE *v1; // edi
  bool v2; // zf
  _BYTE *v3; // [esp+4h] [ebp+4h]
  int v4; // [esp+8h] [ebp+8h]
  unsigned __int8 v5; // [esp+Ch] [ebp+Ch]

  v0 = v4;
  v1 = v3;
  do
  {
    if ( !v0 )
      break;
    v2 = *v1++ == v5;
    --v0;
  }
  while ( !v2 );
}

//----- (0808FB60) --------------------------------------------------------
void __golang runtime_cmpbody()
{
  _DWORD *v0; // eax
  signed int v1; // edx
  signed int v2; // ebx
  const __m128i *v3; // edi
  const __m128i *v4; // esi
  unsigned int v5; // ebp
  bool v6; // cc
  int v7; // edx
  int v8; // ebx
  unsigned int v9; // ebx
  unsigned int v10; // ecx
  unsigned __int32 v11; // ebx
  char v12; // cl
  unsigned __int32 v13; // esi
  unsigned int v14; // esi
  unsigned __int32 v15; // edi
  unsigned __int32 v16; // esi
  unsigned __int32 v17; // edi
  unsigned int v18; // ecx

  v5 = v1;
  v6 = v1 <= v2;
  v7 = v1 - v2;
  if ( !v6 )
    v5 = v2;
  if ( v4 == v3 )
  {
LABEL_24:
    *v0 = (v7 == 0) + 2 * (v7 < 0) - 1;
    return;
  }
  if ( v5 < 4 )
  {
    v12 = -8 * v5;
    if ( -8 * v5 )
    {
      v13 = (unsigned __int8)v4 > 0xFCu ? *(unsigned __int32 *)((char *)&v4->m128i_i32[-1] + v5) >> v12 : v4->m128i_i32[0];
      v14 = v13 << v12;
      v15 = (unsigned __int8)v3 > 0xFCu ? *(unsigned __int32 *)((char *)&v3->m128i_i32[-1] + v5) >> v12 : v3->m128i_i32[0];
      v16 = _byteswap_ulong(v14);
      v17 = v16 ^ _byteswap_ulong(v15 << v12);
      if ( v17 )
      {
        _BitScanReverse(&v18, v17);
        *v0 = 2 * ((v16 >> v18) & 1) - 1;
        return;
      }
    }
    goto LABEL_24;
  }
  if ( !runtime_support_sse2 )
    goto LABEL_10;
  while ( v5 >= 0x10 )
  {
    v8 = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_loadu_si128(v3), _mm_loadu_si128(v4))) ^ 0xFFFF;
    if ( v8 )
    {
      _BitScanForward((unsigned int *)&v8, v8);
      *v0 = 2 * (v4->m128i_i8[v8] > (unsigned int)v3->m128i_i8[v8]) - 1;
      return;
    }
    ++v4;
    ++v3;
    v5 -= 16;
  }
LABEL_10:
  while ( v5 > 4 )
  {
    v9 = v4->m128i_i32[0];
    v10 = v3->m128i_i32[0];
    if ( v4->m128i_i32[0] != v3->m128i_i32[0] )
      goto LABEL_14;
    v4 = (const __m128i *)((char *)v4 + 4);
    v3 = (const __m128i *)((char *)v3 + 4);
    v5 -= 4;
  }
  v9 = *(unsigned __int32 *)((char *)&v4->m128i_u32[-1] + v5);
  v10 = *(unsigned __int32 *)((char *)&v3->m128i_u32[-1] + v5);
  if ( v9 == v10 )
    goto LABEL_24;
LABEL_14:
  v11 = _byteswap_ulong(v9);
  _BitScanReverse(&v10, v11 ^ _byteswap_ulong(v10));
  *v0 = 2 * ((v11 >> v10) & 1) - 1;
}
// 808FB60: variable 'v1' is possibly undefined
// 808FB62: variable 'v2' is possibly undefined
// 808FB6A: variable 'v4' is possibly undefined
// 808FB6A: variable 'v3' is possibly undefined
// 808FBBF: variable 'v0' is possibly undefined

//----- (0808FC60) --------------------------------------------------------
void __golang runtime_return0()
{
  ;
}

//----- (0808FC70) --------------------------------------------------------
void __golang __noreturn runtime_goexit()
{
  runtime_goexit1();
}

//----- (0808FCC0) --------------------------------------------------------
void __golang runtime_uint32tofloat64()
{
  ;
}

//----- (0808FCE0) --------------------------------------------------------
void __golang runtime_float64touint32()
{
  ;
}

//----- (0808FD10) --------------------------------------------------------
void __golang runtime_duffzero()
{
  int v0; // eax
  _DWORD *v1; // edi
  _DWORD *v2; // edi

  *v1 = v0;
  v2 = v1 + 1;
  *v2++ = v0;
  *v2++ = v0;
  *v2++ = v0;
  *v2++ = v0;
  *v2++ = v0;
  *v2++ = v0;
  *v2++ = v0;
  *v2++ = v0;
  *v2++ = v0;
  *v2++ = v0;
  *v2++ = v0;
  *v2++ = v0;
  *v2++ = v0;
  *v2++ = v0;
  *v2++ = v0;
  *v2++ = v0;
  *v2++ = v0;
  *v2++ = v0;
  *v2++ = v0;
  *v2++ = v0;
  *v2++ = v0;
  *v2++ = v0;
  *v2++ = v0;
  *v2++ = v0;
  *v2++ = v0;
  *v2++ = v0;
  *v2++ = v0;
  *v2++ = v0;
  *v2++ = v0;
  *v2++ = v0;
  *v2++ = v0;
  *v2++ = v0;
  *v2++ = v0;
  *v2++ = v0;
  *v2++ = v0;
  *v2++ = v0;
  *v2++ = v0;
  *v2++ = v0;
  *v2++ = v0;
  *v2++ = v0;
  *v2++ = v0;
  *v2++ = v0;
  *v2++ = v0;
  *v2++ = v0;
  *v2++ = v0;
  *v2++ = v0;
  *v2++ = v0;
  *v2++ = v0;
  *v2++ = v0;
  *v2++ = v0;
  *v2++ = v0;
  *v2++ = v0;
  *v2++ = v0;
  *v2++ = v0;
  *v2++ = v0;
  *v2++ = v0;
  *v2++ = v0;
  *v2++ = v0;
  *v2++ = v0;
  *v2++ = v0;
  *v2++ = v0;
  *v2++ = v0;
  *v2++ = v0;
  *v2++ = v0;
  *v2++ = v0;
  *v2++ = v0;
  *v2++ = v0;
  *v2++ = v0;
  *v2++ = v0;
  *v2++ = v0;
  *v2++ = v0;
  *v2++ = v0;
  *v2++ = v0;
  *v2++ = v0;
  *v2++ = v0;
  *v2++ = v0;
  *v2++ = v0;
  *v2++ = v0;
  *v2++ = v0;
  *v2++ = v0;
  *v2++ = v0;
  *v2++ = v0;
  *v2++ = v0;
  *v2++ = v0;
  *v2++ = v0;
  *v2++ = v0;
  *v2++ = v0;
  *v2++ = v0;
  *v2++ = v0;
  *v2++ = v0;
  *v2++ = v0;
  *v2++ = v0;
  *v2++ = v0;
  *v2++ = v0;
  *v2++ = v0;
  *v2++ = v0;
  *v2++ = v0;
  *v2++ = v0;
  *v2++ = v0;
  *v2++ = v0;
  *v2++ = v0;
  *v2++ = v0;
  *v2++ = v0;
  *v2++ = v0;
  *v2++ = v0;
  *v2++ = v0;
  *v2++ = v0;
  *v2++ = v0;
  *v2++ = v0;
  *v2++ = v0;
  *v2++ = v0;
  *v2++ = v0;
  *v2++ = v0;
  *v2++ = v0;
  *v2++ = v0;
  *v2++ = v0;
  *v2++ = v0;
  *v2++ = v0;
  *v2++ = v0;
  *v2++ = v0;
  *v2++ = v0;
  *v2++ = v0;
  *v2++ = v0;
  *v2++ = v0;
  *v2++ = v0;
  *v2 = v0;
  v2[1] = v0;
}
// 808FD10: variable 'v0' is possibly undefined
// 808FD10: variable 'v1' is possibly undefined

//----- (0808FDA0) --------------------------------------------------------
void __golang runtime_duffcopy()
{
  _DWORD *v0; // edi
  int *v1; // esi
  int v2; // ecx
  int *v3; // esi
  int *v4; // edi
  int v5; // ecx
  int v6; // ecx
  int v7; // ecx
  int v8; // ecx
  int v9; // ecx
  int v10; // ecx
  int v11; // ecx
  int v12; // ecx
  int v13; // ecx
  int v14; // ecx
  int v15; // ecx
  int v16; // ecx
  int v17; // ecx
  int v18; // ecx
  int v19; // ecx
  int v20; // ecx
  int v21; // ecx
  int v22; // ecx
  int v23; // ecx
  int v24; // ecx
  int v25; // ecx
  int v26; // ecx
  int v27; // ecx
  int v28; // ecx
  int v29; // ecx
  int v30; // ecx
  int v31; // ecx
  int v32; // ecx
  int v33; // ecx
  int v34; // ecx
  int v35; // ecx
  int v36; // ecx
  int v37; // ecx
  int v38; // ecx
  int v39; // ecx
  int v40; // ecx
  int v41; // ecx
  int v42; // ecx
  int v43; // ecx
  int v44; // ecx
  int v45; // ecx
  int v46; // ecx
  int v47; // ecx
  int v48; // ecx
  int v49; // ecx
  int v50; // ecx
  int v51; // ecx
  int v52; // ecx
  int v53; // ecx
  int v54; // ecx
  int v55; // ecx
  int v56; // ecx
  int v57; // ecx
  int v58; // ecx
  int v59; // ecx
  int v60; // ecx
  int v61; // ecx
  int v62; // ecx
  int v63; // ecx
  int v64; // ecx
  int v65; // ecx
  int v66; // ecx
  int v67; // ecx
  int v68; // ecx
  int v69; // ecx
  int v70; // ecx
  int v71; // ecx
  int v72; // ecx
  int v73; // ecx
  int v74; // ecx
  int v75; // ecx
  int v76; // ecx
  int v77; // ecx
  int v78; // ecx
  int v79; // ecx
  int v80; // ecx
  int v81; // ecx
  int v82; // ecx
  int v83; // ecx
  int v84; // ecx
  int v85; // ecx
  int v86; // ecx
  int v87; // ecx
  int v88; // ecx
  int v89; // ecx
  int v90; // ecx
  int v91; // ecx
  int v92; // ecx
  int v93; // ecx
  int v94; // ecx
  int v95; // ecx
  int v96; // ecx
  int v97; // ecx
  int v98; // ecx
  int v99; // ecx
  int v100; // ecx
  int v101; // ecx
  int v102; // ecx
  int v103; // ecx
  int v104; // ecx
  int v105; // ecx
  int v106; // ecx
  int v107; // ecx
  int v108; // ecx
  int v109; // ecx
  int v110; // ecx
  int v111; // ecx
  int v112; // ecx
  int v113; // ecx
  int v114; // ecx
  int v115; // ecx
  int v116; // ecx
  int v117; // ecx
  int v118; // ecx
  int v119; // ecx
  int v120; // ecx
  int v121; // ecx
  int v122; // ecx
  int v123; // ecx
  int v124; // ecx
  int v125; // ecx
  int v126; // ecx
  int v127; // ecx
  int v128; // ecx
  int v129; // ecx

  v2 = *v1;
  v3 = v1 + 1;
  *v0 = v2;
  v4 = v0 + 1;
  v5 = *v3++;
  *v4++ = v5;
  v6 = *v3++;
  *v4++ = v6;
  v7 = *v3++;
  *v4++ = v7;
  v8 = *v3++;
  *v4++ = v8;
  v9 = *v3++;
  *v4++ = v9;
  v10 = *v3++;
  *v4++ = v10;
  v11 = *v3++;
  *v4++ = v11;
  v12 = *v3++;
  *v4++ = v12;
  v13 = *v3++;
  *v4++ = v13;
  v14 = *v3++;
  *v4++ = v14;
  v15 = *v3++;
  *v4++ = v15;
  v16 = *v3++;
  *v4++ = v16;
  v17 = *v3++;
  *v4++ = v17;
  v18 = *v3++;
  *v4++ = v18;
  v19 = *v3++;
  *v4++ = v19;
  v20 = *v3++;
  *v4++ = v20;
  v21 = *v3++;
  *v4++ = v21;
  v22 = *v3++;
  *v4++ = v22;
  v23 = *v3++;
  *v4++ = v23;
  v24 = *v3++;
  *v4++ = v24;
  v25 = *v3++;
  *v4++ = v25;
  v26 = *v3++;
  *v4++ = v26;
  v27 = *v3++;
  *v4++ = v27;
  v28 = *v3++;
  *v4++ = v28;
  v29 = *v3++;
  *v4++ = v29;
  v30 = *v3++;
  *v4++ = v30;
  v31 = *v3++;
  *v4++ = v31;
  v32 = *v3++;
  *v4++ = v32;
  v33 = *v3++;
  *v4++ = v33;
  v34 = *v3++;
  *v4++ = v34;
  v35 = *v3++;
  *v4++ = v35;
  v36 = *v3++;
  *v4++ = v36;
  v37 = *v3++;
  *v4++ = v37;
  v38 = *v3++;
  *v4++ = v38;
  v39 = *v3++;
  *v4++ = v39;
  v40 = *v3++;
  *v4++ = v40;
  v41 = *v3++;
  *v4++ = v41;
  v42 = *v3++;
  *v4++ = v42;
  v43 = *v3++;
  *v4++ = v43;
  v44 = *v3++;
  *v4++ = v44;
  v45 = *v3++;
  *v4++ = v45;
  v46 = *v3++;
  *v4++ = v46;
  v47 = *v3++;
  *v4++ = v47;
  v48 = *v3++;
  *v4++ = v48;
  v49 = *v3++;
  *v4++ = v49;
  v50 = *v3++;
  *v4++ = v50;
  v51 = *v3++;
  *v4++ = v51;
  v52 = *v3++;
  *v4++ = v52;
  v53 = *v3++;
  *v4++ = v53;
  v54 = *v3++;
  *v4++ = v54;
  v55 = *v3++;
  *v4++ = v55;
  v56 = *v3++;
  *v4++ = v56;
  v57 = *v3++;
  *v4++ = v57;
  v58 = *v3++;
  *v4++ = v58;
  v59 = *v3++;
  *v4++ = v59;
  v60 = *v3++;
  *v4++ = v60;
  v61 = *v3++;
  *v4++ = v61;
  v62 = *v3++;
  *v4++ = v62;
  v63 = *v3++;
  *v4++ = v63;
  v64 = *v3++;
  *v4++ = v64;
  v65 = *v3++;
  *v4++ = v65;
  v66 = *v3++;
  *v4++ = v66;
  v67 = *v3++;
  *v4++ = v67;
  v68 = *v3++;
  *v4++ = v68;
  v69 = *v3++;
  *v4++ = v69;
  v70 = *v3++;
  *v4++ = v70;
  v71 = *v3++;
  *v4++ = v71;
  v72 = *v3++;
  *v4++ = v72;
  v73 = *v3++;
  *v4++ = v73;
  v74 = *v3++;
  *v4++ = v74;
  v75 = *v3++;
  *v4++ = v75;
  v76 = *v3++;
  *v4++ = v76;
  v77 = *v3++;
  *v4++ = v77;
  v78 = *v3++;
  *v4++ = v78;
  v79 = *v3++;
  *v4++ = v79;
  v80 = *v3++;
  *v4++ = v80;
  v81 = *v3++;
  *v4++ = v81;
  v82 = *v3++;
  *v4++ = v82;
  v83 = *v3++;
  *v4++ = v83;
  v84 = *v3++;
  *v4++ = v84;
  v85 = *v3++;
  *v4++ = v85;
  v86 = *v3++;
  *v4++ = v86;
  v87 = *v3++;
  *v4++ = v87;
  v88 = *v3++;
  *v4++ = v88;
  v89 = *v3++;
  *v4++ = v89;
  v90 = *v3++;
  *v4++ = v90;
  v91 = *v3++;
  *v4++ = v91;
  v92 = *v3++;
  *v4++ = v92;
  v93 = *v3++;
  *v4++ = v93;
  v94 = *v3++;
  *v4++ = v94;
  v95 = *v3++;
  *v4++ = v95;
  v96 = *v3++;
  *v4++ = v96;
  v97 = *v3++;
  *v4++ = v97;
  v98 = *v3++;
  *v4++ = v98;
  v99 = *v3++;
  *v4++ = v99;
  v100 = *v3++;
  *v4++ = v100;
  v101 = *v3++;
  *v4++ = v101;
  v102 = *v3++;
  *v4++ = v102;
  v103 = *v3++;
  *v4++ = v103;
  v104 = *v3++;
  *v4++ = v104;
  v105 = *v3++;
  *v4++ = v105;
  v106 = *v3++;
  *v4++ = v106;
  v107 = *v3++;
  *v4++ = v107;
  v108 = *v3++;
  *v4++ = v108;
  v109 = *v3++;
  *v4++ = v109;
  v110 = *v3++;
  *v4++ = v110;
  v111 = *v3++;
  *v4++ = v111;
  v112 = *v3++;
  *v4++ = v112;
  v113 = *v3++;
  *v4++ = v113;
  v114 = *v3++;
  *v4++ = v114;
  v115 = *v3++;
  *v4++ = v115;
  v116 = *v3++;
  *v4++ = v116;
  v117 = *v3++;
  *v4++ = v117;
  v118 = *v3++;
  *v4++ = v118;
  v119 = *v3++;
  *v4++ = v119;
  v120 = *v3++;
  *v4++ = v120;
  v121 = *v3++;
  *v4++ = v121;
  v122 = *v3++;
  *v4++ = v122;
  v123 = *v3++;
  *v4++ = v123;
  v124 = *v3++;
  *v4++ = v124;
  v125 = *v3++;
  *v4++ = v125;
  v126 = *v3++;
  *v4++ = v126;
  v127 = *v3++;
  *v4++ = v127;
  v128 = *v3++;
  *v4++ = v128;
  v129 = *v3++;
  *v4++ = v129;
  *v4 = *v3;
  v4[1] = v3[1];
}
// 808FDA0: variable 'v1' is possibly undefined
// 808FDA5: variable 'v0' is possibly undefined

//----- (080902B0) --------------------------------------------------------
void __golang runtime_memclrNoHeapPointers()
{
  char *v0; // edi
  unsigned int v1; // ebx
  char *v2; // [esp+4h] [ebp+4h]
  unsigned int v3; // [esp+8h] [ebp+8h]

  v0 = v2;
  v1 = v3;
  while ( v1 )
  {
    if ( v1 <= 2 )
    {
      *v0 = 0;
      v0[v1 - 1] = 0;
      return;
    }
    if ( v1 < 4 )
    {
      *(_WORD *)v0 = 0;
      v0[2] = 0;
      return;
    }
    if ( v1 == 4 )
    {
      *(_DWORD *)v0 = 0;
      return;
    }
    if ( v1 <= 8 )
    {
      *(_DWORD *)v0 = 0;
      *(_DWORD *)&v0[v1 - 4] = 0;
      return;
    }
    if ( v1 <= 0x10 )
    {
      *(_DWORD *)v0 = 0;
      *((_DWORD *)v0 + 1) = 0;
      *(_DWORD *)&v0[v1 - 8] = 0;
      *(_DWORD *)&v0[v1 - 4] = 0;
      return;
    }
    if ( runtime_support_sse2 )
    {
      if ( v1 <= 0x20 )
      {
        *(_OWORD *)v0 = 0LL;
        *(_OWORD *)&v0[v1 - 16] = 0LL;
        return;
      }
      if ( v1 <= 0x40 )
      {
        *(_OWORD *)v0 = 0LL;
        *((_OWORD *)v0 + 1) = 0LL;
        *(_OWORD *)&v0[v1 - 32] = 0LL;
        *(_OWORD *)&v0[v1 - 16] = 0LL;
        return;
      }
      if ( v1 <= 0x80 )
      {
        *(_OWORD *)v0 = 0LL;
        *((_OWORD *)v0 + 1) = 0LL;
        *((_OWORD *)v0 + 2) = 0LL;
        *((_OWORD *)v0 + 3) = 0LL;
        *(_OWORD *)&v0[v1 - 64] = 0LL;
        *(_OWORD *)&v0[v1 - 48] = 0LL;
        *(_OWORD *)&v0[v1 - 32] = 0LL;
        *(_OWORD *)&v0[v1 - 16] = 0LL;
        return;
      }
      if ( v1 <= 0x100 )
      {
        *(_OWORD *)v0 = 0LL;
        *((_OWORD *)v0 + 1) = 0LL;
        *((_OWORD *)v0 + 2) = 0LL;
        *((_OWORD *)v0 + 3) = 0LL;
        *((_OWORD *)v0 + 4) = 0LL;
        *((_OWORD *)v0 + 5) = 0LL;
        *((_OWORD *)v0 + 6) = 0LL;
        *((_OWORD *)v0 + 7) = 0LL;
        *(_OWORD *)&v0[v1 - 128] = 0LL;
        *(_OWORD *)&v0[v1 - 112] = 0LL;
        *(_OWORD *)&v0[v1 - 96] = 0LL;
        *(_OWORD *)&v0[v1 - 80] = 0LL;
        *(_OWORD *)&v0[v1 - 64] = 0LL;
        *(_OWORD *)&v0[v1 - 48] = 0LL;
        *(_OWORD *)&v0[v1 - 32] = 0LL;
        *(_OWORD *)&v0[v1 - 16] = 0LL;
        return;
      }
      do
      {
        *(_OWORD *)v0 = 0LL;
        *((_OWORD *)v0 + 1) = 0LL;
        *((_OWORD *)v0 + 2) = 0LL;
        *((_OWORD *)v0 + 3) = 0LL;
        *((_OWORD *)v0 + 4) = 0LL;
        *((_OWORD *)v0 + 5) = 0LL;
        *((_OWORD *)v0 + 6) = 0LL;
        *((_OWORD *)v0 + 7) = 0LL;
        *((_OWORD *)v0 + 8) = 0LL;
        *((_OWORD *)v0 + 9) = 0LL;
        *((_OWORD *)v0 + 10) = 0LL;
        *((_OWORD *)v0 + 11) = 0LL;
        *((_OWORD *)v0 + 12) = 0LL;
        *((_OWORD *)v0 + 13) = 0LL;
        *((_OWORD *)v0 + 14) = 0LL;
        *((_OWORD *)v0 + 15) = 0LL;
        v1 -= 256;
        v0 += 256;
      }
      while ( v1 >= 0x100 );
    }
    else
    {
      memset(v0, 0, 4 * (v1 >> 2));
      v0 += 4 * (v1 >> 2);
      v1 &= 3u;
      if ( !v1 )
        return;
    }
  }
}

//----- (08090490) --------------------------------------------------------
void __golang runtime_memmove()
{
  unsigned int v0; // edi
  const __m128i *v1; // esi
  unsigned int v2; // ebx
  unsigned int v3; // ecx
  unsigned int v4; // edi
  __int8 *v5; // esi
  unsigned int v6; // ecx
  _DWORD *v7; // edi
  char *v8; // esi
  __int8 v9; // cl
  __int8 v10; // cl
  int v11; // ecx
  __int32 v12; // ecx
  int v13; // edx
  int v14; // ebp
  __m128i v15; // xmm1
  __m128i v16; // xmm1
  __m128i v17; // xmm2
  __m128i v18; // xmm3
  __m128i v19; // xmm1
  __m128i v20; // xmm2
  __m128i v21; // xmm3
  __m128i v22; // xmm4
  __m128i v23; // xmm5
  __m128i v24; // xmm6
  __m128i v25; // xmm7
  unsigned int v26; // [esp+4h] [ebp+4h]
  const __m128i *v27; // [esp+8h] [ebp+8h]
  unsigned int v28; // [esp+Ch] [ebp+Ch]

  v0 = v26;
  v1 = v27;
  v2 = v28;
  while ( v2 )
  {
    if ( v2 <= 2 )
    {
      v9 = v1->m128i_i8[v2 - 1];
      *(_BYTE *)v0 = v1->m128i_i8[0];
      *(_BYTE *)(v0 + v2 - 1) = v9;
      return;
    }
    if ( v2 < 4 )
    {
      v10 = v1->m128i_i8[2];
      *(_WORD *)v0 = v1->m128i_i16[0];
      *(_BYTE *)(v0 + 2) = v10;
      return;
    }
    if ( v2 == 4 )
    {
      *(_DWORD *)v0 = v1->m128i_i32[0];
      return;
    }
    if ( v2 <= 8 )
    {
      v11 = *(__int32 *)((char *)&v1->m128i_i32[-1] + v2);
      *(_DWORD *)v0 = v1->m128i_i32[0];
      *(_DWORD *)(v0 + v2 - 4) = v11;
      return;
    }
    if ( v2 <= 0x10 )
    {
      v12 = v1->m128i_i32[1];
      v13 = *(__int32 *)((char *)&v1->m128i_i32[-2] + v2);
      v14 = *(__int32 *)((char *)&v1->m128i_i32[-1] + v2);
      *(_DWORD *)v0 = v1->m128i_i32[0];
      *(_DWORD *)(v0 + 4) = v12;
      *(_DWORD *)(v0 + v2 - 8) = v13;
      *(_DWORD *)(v0 + v2 - 4) = v14;
      return;
    }
    if ( runtime_support_sse2 )
    {
      if ( v2 <= 0x20 )
      {
        v15 = _mm_loadu_si128((const __m128i *)((char *)v1 + v2 - 16));
        *(__m128i *)v0 = _mm_loadu_si128(v1);
        *(__m128i *)(v0 + v2 - 16) = v15;
        return;
      }
      if ( v2 <= 0x40 )
      {
        v16 = _mm_loadu_si128(v1 + 1);
        v17 = _mm_loadu_si128((const __m128i *)((char *)v1 + v2 - 32));
        v18 = _mm_loadu_si128((const __m128i *)((char *)v1 + v2 - 16));
        *(__m128i *)v0 = _mm_loadu_si128(v1);
        *(__m128i *)(v0 + 16) = v16;
        *(__m128i *)(v0 + v2 - 32) = v17;
        *(__m128i *)(v0 + v2 - 16) = v18;
        return;
      }
      if ( v2 <= 0x80 )
      {
        v19 = _mm_loadu_si128(v1 + 1);
        v20 = _mm_loadu_si128(v1 + 2);
        v21 = _mm_loadu_si128(v1 + 3);
        v22 = _mm_loadu_si128((const __m128i *)((char *)v1 + v2 - 64));
        v23 = _mm_loadu_si128((const __m128i *)((char *)v1 + v2 - 48));
        v24 = _mm_loadu_si128((const __m128i *)((char *)v1 + v2 - 32));
        v25 = _mm_loadu_si128((const __m128i *)((char *)v1 + v2 - 16));
        *(__m128i *)v0 = _mm_loadu_si128(v1);
        *(__m128i *)(v0 + 16) = v19;
        *(__m128i *)(v0 + 32) = v20;
        *(__m128i *)(v0 + 48) = v21;
        *(__m128i *)(v0 + v2 - 64) = v22;
        *(__m128i *)(v0 + v2 - 48) = v23;
        *(__m128i *)(v0 + v2 - 32) = v24;
        *(__m128i *)(v0 + v2 - 16) = v25;
        return;
      }
    }
    if ( (unsigned int)v1 > v0 || (unsigned int)v1->m128i_u32 + v2 <= v0 )
    {
      if ( runtime_support_erms && ((v0 | (unsigned int)v1) & 3) != 0 )
      {
        qmemcpy((void *)v0, v1, v2);
        return;
      }
      v3 = v2 >> 2;
      v2 &= 3u;
      qmemcpy((void *)v0, v1, 4 * v3);
      v1 = (const __m128i *)((char *)v1 + 4 * v3);
      v0 += 4 * v3;
    }
    else
    {
      v4 = v2 + v0;
      v5 = &v1->m128i_i8[v2];
      v6 = v2 >> 2;
      v2 &= 3u;
      v7 = (_DWORD *)(v4 - 4);
      v8 = v5 - 4;
      while ( v6 )
      {
        *v7 = *(_DWORD *)v8;
        v8 -= 4;
        --v7;
        --v6;
      }
      v0 = (unsigned int)v7 - v2 + 4;
      v1 = (const __m128i *)&v8[-v2 + 4];
    }
  }
}

//----- (08090630) --------------------------------------------------------
#error "8090642: call analysis failed (funcsize=7)"

//----- (08090660) --------------------------------------------------------
void __golang __noreturn runtime_exit()
{
  __asm { int     80h; LINUX - sys_exit_group }
}
// 8090669: control flows out of bounds to 809066B

//----- (08090670) --------------------------------------------------------
void __golang __noreturn runtime_exit1()
{
  int v0; // eax
  int status; // [esp+4h] [ebp+4h]

  v0 = sys_exit(status);
}

//----- (08090680) --------------------------------------------------------
void __golang runtime_open()
{
  char *filename; // [esp+4h] [ebp+4h]
  int flags; // [esp+8h] [ebp+8h]
  mode_t mode; // [esp+Ch] [ebp+Ch]

  sys_open(filename, flags, mode);
}

//----- (080906B0) --------------------------------------------------------
void __golang runtime_closefd()
{
  int fd; // [esp+4h] [ebp+4h]

  sys_close(fd);
}

//----- (080906D0) --------------------------------------------------------
void __golang runtime_write()
{
  int fd; // [esp+4h] [ebp+4h]
  const void *addr; // [esp+8h] [ebp+8h]
  size_t len; // [esp+Ch] [ebp+Ch]

  sys_write(fd, addr, len);
}

//----- (08090700) --------------------------------------------------------
void __golang runtime_read()
{
  int fd; // [esp+4h] [ebp+4h]
  void *addr; // [esp+8h] [ebp+8h]
  size_t len; // [esp+Ch] [ebp+Ch]

  sys_read(fd, addr, len);
}

//----- (08090730) --------------------------------------------------------
void __golang runtime_usleep()
{
  __asm { int     80h; LINUX - }
}

//----- (08090770) --------------------------------------------------------
void __golang runtime_gettid()
{
  __asm { int     80h; LINUX - sys_gettid }
}

//----- (08090780) --------------------------------------------------------
void __golang runtime_raise()
{
  int v0; // eax
  int sig; // [esp+10h] [ebp+4h]

  __asm { int     80h; LINUX - sys_gettid }
  v0 = sys_tkill(224, sig);
}

//----- (080907A0) --------------------------------------------------------
void __golang runtime_raiseproc()
{
  int v0; // eax
  int sig; // [esp+10h] [ebp+4h]

  __asm { int     80h; LINUX - sys_getpid }
  v0 = sys_kill(20, sig);
}

//----- (080907C0) --------------------------------------------------------
void __golang runtime_setitimer()
{
  int v0; // eax
  int which; // [esp+4h] [ebp+4h]
  struct itimerval *value; // [esp+8h] [ebp+8h]
  struct itimerval *ovalue; // [esp+Ch] [ebp+Ch]

  v0 = sys_setitimer(which, value, ovalue);
}

//----- (080907E0) --------------------------------------------------------
void __golang runtime_mincore()
{
  void *start; // [esp+4h] [ebp+4h]
  size_t length; // [esp+8h] [ebp+8h]
  unsigned __int8 *vec; // [esp+Ch] [ebp+Ch]

  sys_mincore(start, length, vec);
}

//----- (08090800) --------------------------------------------------------
void __golang runtime_walltime()
{
  __asm { int     80h; LINUX - sys_clock_gettime }
}

//----- (08090830) --------------------------------------------------------
void __golang runtime_nanotime()
{
  __asm { int     80h; LINUX - sys_clock_gettime }
}

//----- (08090870) --------------------------------------------------------
void __golang runtime_rtsigprocmask()
{
  __asm { int     80h; LINUX - sys_rt_sigprocmask }
}

//----- (080908A0) --------------------------------------------------------
void __golang runtime_rt_sigaction()
{
  __asm { int     80h; LINUX - sys_rt_sigaction }
}

//----- (080908C0) --------------------------------------------------------
void __golang runtime_sigfwd()
{
  int v0; // [esp+20h] [ebp-Ch] BYREF
  void (__golang *v1)(int, int, int, int *); // [esp+30h] [ebp+4h]
  int v2; // [esp+34h] [ebp+8h]
  int v3; // [esp+38h] [ebp+Ch]
  int v4; // [esp+3Ch] [ebp+10h]

  v1(v2, v3, v4, &v0);
}

//----- (08090900) --------------------------------------------------------
void __golang runtime_sigtramp()
{
  uint32 sig; // [esp+20h] [ebp+4h]
  runtime_siginfo *info; // [esp+24h] [ebp+8h]
  void *ctx; // [esp+28h] [ebp+Ch]

  runtime_sigtrampgo(sig, info, ctx);
}

//----- (08090960) --------------------------------------------------------
void __golang runtime_sigreturn()
{
  __asm
  {
    int     80h; LINUX - sys_rt_sigreturn
    int     3; - software interrupt to invoke the debugger
  }
}

//----- (08090970) --------------------------------------------------------
void __golang runtime_mmap()
{
  void *start; // [esp+4h] [ebp+4h]
  size_t len; // [esp+8h] [ebp+8h]
  int prot; // [esp+Ch] [ebp+Ch]
  int flags; // [esp+10h] [ebp+10h]
  int fd; // [esp+14h] [ebp+14h]
  unsigned int v5; // [esp+18h] [ebp+18h]

  sys_mmap2(start, len, prot, flags, fd, v5 >> 12);
}

//----- (080909B0) --------------------------------------------------------
void __golang runtime_munmap()
{
  void *addr; // [esp+4h] [ebp+4h]
  int len; // [esp+8h] [ebp+8h]

  if ( (unsigned int)sys_munmap(addr, len) > 0xFFFFF001 )
    __asm { int     3; - software interrupt to invoke the debugger }
}

//----- (080909D0) --------------------------------------------------------
void __golang runtime_madvise()
{
  int v0; // eax
  void *start; // [esp+4h] [ebp+4h]
  size_t length; // [esp+8h] [ebp+8h]
  int advice; // [esp+Ch] [ebp+Ch]

  v0 = sys_madvise1(start, length, advice);
}

//----- (080909F0) --------------------------------------------------------
void __golang runtime_futex()
{
  int *uaddr; // [esp+4h] [ebp+4h]
  int op; // [esp+8h] [ebp+8h]
  int val; // [esp+Ch] [ebp+Ch]
  const struct timespec *timeout; // [esp+10h] [ebp+10h]
  int *uaddr2; // [esp+14h] [ebp+14h]
  int val3; // [esp+18h] [ebp+18h]

  sys_futex(uaddr, op, val, timeout, uaddr2, val3);
}

//----- (08090A20) --------------------------------------------------------
void __golang runtime_clone()
{
  _DWORD *v0; // ecx
  _DWORD *retaddr; // [esp+0h] [ebp+0h]
  int flags; // [esp+4h] [ebp+4h]
  void (*v3)(void); // [esp+8h] [ebp+8h]
  int v4; // [esp+Ch] [ebp+Ch]
  int v5; // [esp+10h] [ebp+10h]
  struct user_desc *newtls; // [esp+14h] [ebp+14h]

  v0 = (_DWORD *)((char *)v3 - 16);
  *v0 = v4;
  v0[1] = v5;
  v0[2] = newtls;
  v0[3] = 1234;
  if ( !sys_clone(flags, (char *)v3 - 16, 0, newtls, 0) )
  {
    if ( v4 != 1234 )
      __asm { int     3; - software interrupt to invoke the debugger }
    __asm { int     80h; LINUX - sys_gettid }
    if ( retaddr )
    {
      if ( flags )
      {
        retaddr[9] = 224;
        runtime_setldt();
        *(_DWORD *)(__readgsdword(0) - 4) = flags;
        *(_DWORD *)(flags + 24) = retaddr;
        runtime_stackcheck();
        runtime_emptyfunc();
      }
    }
    v3();
    runtime_exit1();
  }
}

//----- (08090AD0) --------------------------------------------------------
void __golang runtime_sigaltstack()
{
  const stack_t *v0; // [esp+4h] [ebp+4h]
  stack_t *oss; // [esp+8h] [ebp+8h]

  if ( (unsigned int)sys_sigaltstack(v0, oss) > 0xFFFFF001 )
    __asm { int     3; - software interrupt to invoke the debugger }
}

//----- (08090AF0) --------------------------------------------------------
void __golang runtime_setldt()
{
  int v0; // [esp+28h] [ebp+8h]

  *(_DWORD *)(v0 + 4) = v0 + 4;
  __asm { int     80h; LINUX - sys_set_thread_area }
}
// 813601C: using guessed type int runtime_tls_entry_number;

//----- (08090B50) --------------------------------------------------------
void __golang runtime_osyield()
{
  __asm { int     80h; LINUX - sys_sched_yield }
}

//----- (08090B60) --------------------------------------------------------
void __golang runtime_sched_getaffinity()
{
  __asm { int     80h; LINUX - sys_sched_getaffinity }
}

//----- (08090B80) --------------------------------------------------------
void __golang runtime_epollcreate()
{
  __asm { int     80h; LINUX - sys_epoll_create }
}

//----- (08090B90) --------------------------------------------------------
void __golang runtime_epollcreate1()
{
  __asm { int     80h; LINUX - }
}

//----- (08090BA0) --------------------------------------------------------
void __golang runtime_epollctl()
{
  __asm { int     80h; LINUX - sys_epoll_ctl }
}

//----- (08090BC0) --------------------------------------------------------
void __golang runtime_epollwait()
{
  __asm { int     80h; LINUX - sys_epoll_wait }
}

//----- (08090BE0) --------------------------------------------------------
void __golang runtime_closeonexec()
{
  int v0; // eax
  int fd; // [esp+4h] [ebp+4h]

  v0 = sys_fcntl(fd, 2, (struct flock *)1);
}

//----- (08090C00) --------------------------------------------------------
void __golang runtime_sbrk0()
{
  sys_brk(0);
}

//----- (08090C10) --------------------------------------------------------
void __golang runtime__mul64by32()
{
  _DWORD *v0; // [esp+4h] [ebp+4h]
  unsigned int v1; // [esp+8h] [ebp+8h]
  int v2; // [esp+Ch] [ebp+Ch]
  unsigned int v3; // [esp+10h] [ebp+10h]

  *v0 = v3 * v1;
  v0[1] = v3 * v2 + ((v3 * (unsigned __int64)v1) >> 32);
}

//----- (08090C40) --------------------------------------------------------
void __golang runtime__div64by32()
{
  unsigned __int64 v0; // [esp+4h] [ebp+4h]
  unsigned int v1; // [esp+Ch] [ebp+Ch]
  _DWORD *v2; // [esp+10h] [ebp+10h]

  *v2 = v0 % v1;
}

//----- (08090C60) --------------------------------------------------------
uintptr __golang type__hash_runtime__func(runtime__func *p, uintptr h)
{
  uintptr seed; // [esp+Ch] [ebp-4h]

  seed = runtime_memhash(p, h, 0xCu);
  return runtime_memhash(&p->pcsp, seed, 0x14u);
}

//----- (08090CD0) --------------------------------------------------------
bool __golang type__eq_runtime__func(runtime__func *p, runtime__func *q)
{
  bool v3; // [esp+Ch] [ebp-4h]

  runtime_memequal();
  if ( !v3 )
    return 0;
  runtime_memequal();
  return v3;
}
// 8090D08: variable 'v3' is possibly undefined

//----- (08090D50) --------------------------------------------------------
uintptr __golang type__hash_runtime_uncommontype(runtime_uncommontype *p, uintptr h)
{
  uintptr seed; // [esp+Ch] [ebp-4h]

  seed = runtime_memhash(p, h, 6u);
  return runtime_memhash(&p->moff, seed, 4u);
}

//----- (08090DC0) --------------------------------------------------------
bool __golang type__eq_runtime_uncommontype(runtime_uncommontype *p, runtime_uncommontype *q)
{
  return p->pkgpath == q->pkgpath && p->mcount == q->mcount && p->moff == q->moff;
}

//----- (08090E10) --------------------------------------------------------
uintptr __golang type__hash_runtime_modulehash(runtime_modulehash_0 *p, uintptr h)
{
  uintptr s; // [esp+8h] [ebp-8h]
  uintptr sa; // [esp+8h] [ebp-8h]

  s = runtime_strhash(p, h);
  sa = runtime_strhash(&p->linktimehash, s);
  return runtime_memhash(&p->runtimehash, sa, 4u);
}

//----- (08090E90) --------------------------------------------------------
bool __golang type__eq_runtime_modulehash(runtime_modulehash_0 *p, runtime_modulehash_0 *q)
{
  runtime_modulehash_0 *v2; // eax
  runtime_modulehash_0 *v3; // ebx
  char v4; // cl
  char v5; // cl
  char v7; // [esp+10h] [ebp-4h]

  v2 = p;
  v3 = q;
  if ( q->modulename.len == p->modulename.len )
  {
    runtime_eqstring();
    v4 = v7;
    v2 = p;
    v3 = q;
  }
  else
  {
    v4 = 0;
  }
  if ( v4 )
  {
    if ( v3->linktimehash.len == v2->linktimehash.len )
    {
      runtime_eqstring();
      v5 = v7;
      v2 = p;
      v3 = q;
    }
    else
    {
      v5 = 0;
    }
  }
  else
  {
    v5 = 0;
  }
  return v5 && v2->runtimehash == v3->runtimehash;
}
// 8090F06: variable 'v7' is possibly undefined

//----- (08090F50) --------------------------------------------------------
uintptr __golang type__hash_runtime_Frame(runtime_Frame_0 *p, uintptr h)
{
  uintptr s; // [esp+8h] [ebp-8h]
  uintptr sa; // [esp+8h] [ebp-8h]
  uintptr v4; // [esp+Ch] [ebp-4h]

  v4 = runtime_memhash(p, h, 8u);
  s = runtime_strhash(&p->Function, v4);
  sa = runtime_strhash(&p->File, s);
  return runtime_memhash(&p->Line, sa, 8u);
}

//----- (08090FF0) --------------------------------------------------------
bool __golang type__eq_runtime_Frame(runtime_Frame_0 *p, runtime_Frame_0 *q)
{
  runtime_Frame_0 *v2; // eax
  runtime_Frame_0 *v3; // edx
  char v4; // cl
  char v5; // cl
  char v7; // [esp+10h] [ebp-4h]

  v2 = p;
  v3 = q;
  if ( p->PC == q->PC )
  {
    if ( p->Func == q->Func )
    {
      if ( q->Function.len == p->Function.len )
      {
        runtime_eqstring();
        v4 = v7;
        v2 = p;
        v3 = q;
      }
      else
      {
        v4 = 0;
      }
    }
    else
    {
      v4 = 0;
    }
  }
  else
  {
    v4 = 0;
  }
  if ( v4 )
  {
    if ( v2->File.len == v3->File.len )
    {
      runtime_eqstring();
      v5 = v7;
      v2 = p;
      v3 = q;
    }
    else
    {
      v5 = 0;
    }
  }
  else
  {
    v5 = 0;
  }
  return v5 && v2->Line == v3->Line && v2->Entry == v3->Entry;
}
// 8091090: variable 'v7' is possibly undefined

//----- (080910F0) --------------------------------------------------------
uintptr __golang type__hash_runtime_MemStats(runtime_MemStats_0 *p, uintptr h)
{
  uintptr s; // [esp+8h] [ebp-8h]
  uintptr v3; // [esp+Ch] [ebp-4h]
  uintptr seed; // [esp+Ch] [ebp-4h]

  v3 = runtime_memhash(p, h, 0x10C8u);
  s = runtime_f64hash(&p->GCCPUFraction, v3);
  seed = runtime_memhash(&p->EnableGC, s, 2u);
  return runtime_memhash(p->BySize, seed, 0x4C4u);
}

//----- (080911A0) --------------------------------------------------------
bool __golang type__eq_runtime_MemStats(runtime_MemStats_0 *p, runtime_MemStats_0 *q)
{
  bool v3; // [esp+Ch] [ebp-4h]

  runtime_memequal();
  if ( !v3 )
    return 0;
  if ( p->GCCPUFraction != q->GCCPUFraction )
    return 0;
  if ( p->EnableGC != q->EnableGC )
    return 0;
  if ( p->DebugGC != q->DebugGC )
    return 0;
  runtime_memequal();
  return v3;
}
// 80911DC: variable 'v3' is possibly undefined

//----- (08091270) --------------------------------------------------------
uintptr __golang type__hash_runtime_TypeAssertionError(runtime_TypeAssertionError *p, uintptr h)
{
  uintptr v2; // [esp+8h] [ebp-4h]
  uintptr v3; // [esp+8h] [ebp-4h]
  uintptr v4; // [esp+8h] [ebp-4h]

  v2 = runtime_strhash(p, h);
  v3 = runtime_strhash(&p->concreteString, v2);
  v4 = runtime_strhash(&p->assertedString, v3);
  return runtime_strhash(&p->missingMethod, v4);
}

//----- (08091300) --------------------------------------------------------
bool __golang type__eq_runtime_TypeAssertionError(runtime_TypeAssertionError *p, runtime_TypeAssertionError *q)
{
  runtime_TypeAssertionError *v2; // eax
  runtime_TypeAssertionError *v3; // ebx
  bool v4; // cl
  bool v5; // cl
  bool v6; // cl
  bool v8; // [esp+10h] [ebp-4h]

  v2 = q;
  v3 = p;
  if ( q->interfaceString.len == p->interfaceString.len )
  {
    runtime_eqstring();
    v4 = v8;
    v2 = q;
    v3 = p;
  }
  else
  {
    v4 = 0;
  }
  if ( v4 )
  {
    if ( v2->concreteString.len == v3->concreteString.len )
    {
      runtime_eqstring();
      v5 = v8;
      v2 = q;
      v3 = p;
    }
    else
    {
      v5 = 0;
    }
  }
  else
  {
    v5 = 0;
  }
  if ( v5 )
  {
    if ( v3->assertedString.len == v2->assertedString.len )
    {
      runtime_eqstring();
      v6 = v8;
      v2 = q;
      v3 = p;
    }
    else
    {
      v6 = 0;
    }
  }
  else
  {
    v6 = 0;
  }
  if ( !v6 )
    return 0;
  if ( v2->missingMethod.len != v3->missingMethod.len )
    return 0;
  runtime_eqstring();
  return v8;
}
// 8091397: variable 'v8' is possibly undefined

//----- (08091430) --------------------------------------------------------
uintptr __golang type__hash_runtime__panic(runtime__panic *p, uintptr h)
{
  uintptr s; // [esp+8h] [ebp-8h]
  uintptr v3; // [esp+Ch] [ebp-4h]

  v3 = runtime_memhash(p, h, 4u);
  s = runtime_nilinterhash(&p->arg, v3);
  return runtime_memhash(&p->link, s, 6u);
}

//----- (080914B0) --------------------------------------------------------
bool __golang type__eq_runtime__panic(runtime__panic *p, runtime__panic *q)
{
  bool v2; // cl
  bool v4; // [esp+Ch] [ebp-4h]

  if ( p->argp == q->argp )
  {
    if ( p->arg._type == q->arg._type )
    {
      v4 = runtime_efaceeq(p->arg._type, p->arg.data, q->arg.data);
      v2 = v4;
    }
    else
    {
      v2 = 0;
    }
  }
  else
  {
    v2 = 0;
  }
  if ( !v2 )
    return 0;
  runtime_memequal();
  return v4;
}
// 809150F: variable 'v4' is possibly undefined

//----- (08091550) --------------------------------------------------------
uintptr __golang type__hash_runtime__defer(runtime__defer *p, uintptr h)
{
  uintptr seed; // [esp+Ch] [ebp-4h]

  seed = runtime_memhash(p, h, 5u);
  return runtime_memhash(&p->sp, seed, 0x14u);
}

//----- (080915C0) --------------------------------------------------------
bool __golang type__eq_runtime__defer(runtime__defer *p, runtime__defer *q)
{
  bool v3; // [esp+Ch] [ebp-4h]

  if ( p->siz != q->siz )
    return 0;
  if ( p->started != q->started )
    return 0;
  runtime_memequal();
  return v3;
}
// 8091615: variable 'v3' is possibly undefined

//----- (08091630) --------------------------------------------------------
uintptr __golang type__hash_runtime_special(runtime_special *p, uintptr h)
{
  return runtime_memhash(p, h, 7u);
}

//----- (08091680) --------------------------------------------------------
bool __golang type__eq_runtime_special(runtime_special *p, runtime_special *q)
{
  bool v2; // [esp+Ch] [ebp-4h]

  runtime_memequal();
  return v2;
}
// 80916B6: variable 'v2' is possibly undefined

//----- (080916D0) --------------------------------------------------------
uintptr __golang type__hash_runtime_markBits(runtime_markBits_0 *p, uintptr h)
{
  uintptr seed; // [esp+Ch] [ebp-4h]

  seed = runtime_memhash(p, h, 5u);
  return runtime_memhash(&p->index, seed, 4u);
}

//----- (08091740) --------------------------------------------------------
bool __golang type__eq_runtime_markBits(runtime_markBits_0 *p, runtime_markBits_0 *q)
{
  return p->bytep == q->bytep && p->mask == q->mask && p->index == q->index;
}

//----- (08091790) --------------------------------------------------------
uintptr __golang type__hash_runtime_hchan(runtime_hchan *p, uintptr h)
{
  uintptr seed; // [esp+Ch] [ebp-4h]

  seed = runtime_memhash(p, h, 0xEu);
  return runtime_memhash(&p->closed, seed, 0x24u);
}

//----- (08091800) --------------------------------------------------------
bool __golang type__eq_runtime_hchan(runtime_hchan *p, runtime_hchan *q)
{
  bool v3; // [esp+Ch] [ebp-4h]

  runtime_memequal();
  if ( !v3 )
    return 0;
  runtime_memequal();
  return v3;
}
// 8091838: variable 'v3' is possibly undefined

//----- (08091880) --------------------------------------------------------
uintptr __golang type__hash_runtime_cpuProfile(runtime_cpuProfile_0 *p, uintptr h)
{
  uintptr seed; // [esp+Ch] [ebp-4h]

  seed = runtime_memhash(p, h, 5u);
  return runtime_memhash(&p->log, seed, 0xFB0u);
}

//----- (080918F0) --------------------------------------------------------
bool __golang type__eq_runtime_cpuProfile(runtime_cpuProfile_0 *p, runtime_cpuProfile_0 *q)
{
  bool v3; // [esp+Ch] [ebp-4h]

  if ( p->lock.key != q->lock.key )
    return 0;
  if ( p->on != q->on )
    return 0;
  runtime_memequal();
  return v3;
}
// 8091945: variable 'v3' is possibly undefined

//----- (08091960) --------------------------------------------------------
uintptr __golang type__hash_runtime_dbgVar(runtime_dbgVar_0 *p, uintptr h)
{
  uintptr s; // [esp+8h] [ebp-8h]

  s = runtime_strhash(p, h);
  return runtime_memhash(&p->value, s, 4u);
}

//----- (080919C0) --------------------------------------------------------
bool __golang type__eq_runtime_dbgVar(runtime_dbgVar_0 *p, runtime_dbgVar_0 *q)
{
  runtime_dbgVar_0 *v2; // eax
  runtime_dbgVar_0 *v3; // ebx
  char v4; // cl
  char v6; // [esp+10h] [ebp-4h]

  v2 = p;
  v3 = q;
  if ( p->name.len == q->name.len )
  {
    runtime_eqstring();
    v4 = v6;
    v2 = p;
    v3 = q;
  }
  else
  {
    v4 = 0;
  }
  return v4 && v2->value == v3->value;
}
// 8091A1C: variable 'v6' is possibly undefined

//----- (08091A40) --------------------------------------------------------
string __golang runtime___ptr_errorString__Error(runtime_errorString *.this)
{
  int v1; // ecx
  uint8 (***v2)[32]; // ebx
  __int32 len; // ecx
  uint8 *str; // eax
  uint8 (*buf)[32]; // [esp+0h] [ebp-1Ch] BYREF
  string a[2]; // [esp+4h] [ebp-18h]

  v2 = *(uint8 (****)[32])(v1 + 16);
  if ( v2 && *v2 == (uint8 (**)[32])&.this )
    *v2 = &buf;
  if ( !.this )
    runtime_panicwrap();
  len = .this->len;
  str = .this->str;
  a[0].str = (uint8 *)"runtime error: ";
  a[0].len = 15;
  a[1].str = str;
  a[1].len = len;
  return runtime_concatstring2(0, *(string (*)[2])&a[0].str);
}
// 8091A55: variable 'v1' is possibly undefined

//----- (08091AC0) --------------------------------------------------------
uintptr __golang type__hash_runtime_finblock(runtime_finblock *p, uintptr h)
{
  uintptr seed; // [esp+Ch] [ebp-4h]

  seed = runtime_memhash(p, h, 0xCu);
  return runtime_memhash(p->fin, seed, 0xFF0u);
}

//----- (08091B30) --------------------------------------------------------
bool __golang type__eq_runtime_finblock(runtime_finblock *p, runtime_finblock *q)
{
  bool v3; // [esp+Ch] [ebp-4h]

  runtime_memequal();
  if ( !v3 )
    return 0;
  runtime_memequal();
  return v3;
}
// 8091B68: variable 'v3' is possibly undefined

//----- (08091BB0) --------------------------------------------------------
uintptr __golang type__hash_runtime_gcControllerState(runtime_gcControllerState_0 *p, uintptr h)
{
  uintptr s; // [esp+8h] [ebp-8h]
  uintptr sa; // [esp+8h] [ebp-8h]
  uintptr sb; // [esp+8h] [ebp-8h]
  uintptr v5; // [esp+Ch] [ebp-4h]

  v5 = runtime_memhash(p, h, 0x40u);
  s = runtime_f64hash(&p->assistWorkPerByte, v5);
  sa = runtime_f64hash(&p->assistBytesPerWork, s);
  sb = runtime_f64hash(&p->fractionalUtilizationGoal, sa);
  return runtime_memhash(&p->fractionalMarkWorkersNeeded, sb, 8u);
}

//----- (08091C70) --------------------------------------------------------
bool __golang type__eq_runtime_gcControllerState(runtime_gcControllerState_0 *p, runtime_gcControllerState_0 *q)
{
  char v3; // [esp+Ch] [ebp-4h]

  runtime_memequal();
  if ( !v3 )
    return 0;
  if ( q->assistWorkPerByte != p->assistWorkPerByte )
    return 0;
  if ( p->assistBytesPerWork != q->assistBytesPerWork )
    return 0;
  if ( p->fractionalUtilizationGoal == q->fractionalUtilizationGoal )
    return LODWORD(p->fractionalMarkWorkersNeeded) == LODWORD(q->fractionalMarkWorkersNeeded)
        && HIDWORD(p->fractionalMarkWorkersNeeded) == HIDWORD(q->fractionalMarkWorkersNeeded);
  return 0;
}
// 8091CAC: variable 'v3' is possibly undefined

//----- (08091D40) --------------------------------------------------------
uintptr __golang type__hash_runtime_mcentral(runtime_mcentral_0 *p, uintptr h)
{
  uintptr seed; // [esp+Ch] [ebp-4h]

  seed = runtime_memhash(p, h, 5u);
  return runtime_memhash(&p->nonempty, seed, 0x18u);
}

//----- (08091DB0) --------------------------------------------------------
bool __golang type__eq_runtime_mcentral(runtime_mcentral_0 *p, runtime_mcentral_0 *q)
{
  bool v3; // [esp+Ch] [ebp-4h]

  if ( p->lock.key != q->lock.key )
    return 0;
  if ( p->spanclass != q->spanclass )
    return 0;
  runtime_memequal();
  return v3;
}
// 8091E05: variable 'v3' is possibly undefined

//----- (08091E20) --------------------------------------------------------
uintptr __golang type__hash_struct__runtime_mcentral_runtime_mcentral__runtime_pad__32_uint8_(
        struct_{_runtime_mcentral_runtime_mcentral__runtime_pad__32_uint8_} *p,
        uintptr h)
{
  uintptr s; // [esp+8h] [ebp-8h]

  s = type__hash_runtime_mcentral(&p->mcentral, h);
  return runtime_memhash(p->pad, s, 0x20u);
}

//----- (08091E80) --------------------------------------------------------
bool __golang type__eq_struct__runtime_mcentral_runtime_mcentral__runtime_pad__32_uint8_(
        struct_{_runtime_mcentral_runtime_mcentral__runtime_pad__32_uint8_} *p,
        struct_{_runtime_mcentral_runtime_mcentral__runtime_pad__32_uint8_} *q)
{
  bool v3; // [esp+Ch] [ebp-4h]

  if ( !type__eq_runtime_mcentral(&p->mcentral, &q->mcentral) )
    return 0;
  runtime_memequal();
  return v3;
}
// 8091EDE: variable 'v3' is possibly undefined

//----- (08091EF0) --------------------------------------------------------
uintptr __golang type__hash__134_struct__runtime_mcentral_runtime_mcentral__runtime_pad__32_uint8_(
        struct_{_runtime_mcentral_runtime_mcentral__runtime_pad__32_uint8_} (*p)[134],
        uintptr h)
{
  int j; // eax
  __int32 i; // [esp+Ch] [ebp-4h]

  for ( j = 0; j < 134; j = i + 1 )
  {
    i = j;
    h = type__hash_struct__runtime_mcentral_runtime_mcentral__runtime_pad__32_uint8_(&(*p)[j], h);
  }
  return h;
}

//----- (08091F50) --------------------------------------------------------
bool __golang type__eq__134_struct__runtime_mcentral_runtime_mcentral__runtime_pad__32_uint8_(
        struct_{_runtime_mcentral_runtime_mcentral__runtime_pad__32_uint8_} (*p)[134],
        struct_{_runtime_mcentral_runtime_mcentral__runtime_pad__32_uint8_} (*q)[134])
{
  int j; // eax
  char v3; // [esp+Ch] [ebp-Ch]
  __int32 i; // [esp+10h] [ebp-8h]

  for ( j = 0; j < 134; j = i + 1 )
  {
    i = j;
    if ( type__eq_runtime_mcentral(&(*p)[j].mcentral, &(*q)[j].mcentral) )
    {
      runtime_memequal();
      if ( v3 )
        continue;
    }
    return 0;
  }
  return 1;
}
// 8091FD8: variable 'v3' is possibly undefined

//----- (08092000) --------------------------------------------------------
uintptr __golang type__hash_runtime_mstats(runtime_mstats_0 *p, uintptr h)
{
  uintptr s; // [esp+8h] [ebp-8h]
  uintptr sa; // [esp+8h] [ebp-8h]
  uintptr v4; // [esp+Ch] [ebp-4h]
  uintptr seed; // [esp+Ch] [ebp-4h]
  uintptr v6; // [esp+Ch] [ebp-4h]

  v4 = runtime_memhash(p, h, 0x10C8u);
  s = runtime_f64hash(&p->gc_cpu_fraction, v4);
  seed = runtime_memhash(&p->enablegc, s, 2u);
  v6 = runtime_memhash(p->by_size, seed, 0x54Cu);
  sa = runtime_f64hash(&p->triggerRatio, v6);
  return runtime_memhash(&p->gc_trigger, sa, 0x20u);
}

//----- (080920F0) --------------------------------------------------------
bool __golang type__eq_runtime_mstats(runtime_mstats_0 *p, runtime_mstats_0 *q)
{
  runtime_mstats_0 *v2; // eax
  runtime_mstats_0 *v3; // ecx
  bool v4; // dl
  bool v6; // [esp+Ch] [ebp-4h]

  runtime_memequal();
  if ( v6 )
  {
    v2 = p;
    v3 = q;
    if ( p->gc_cpu_fraction == q->gc_cpu_fraction )
    {
      if ( q->enablegc == p->enablegc )
      {
        if ( q->debuggc == p->debuggc )
        {
          runtime_memequal();
          v4 = v6;
          v2 = p;
          v3 = q;
        }
        else
        {
          v4 = 0;
        }
      }
      else
      {
        v4 = 0;
      }
    }
    else
    {
      v4 = 0;
    }
  }
  else
  {
    v2 = p;
    v3 = q;
    v4 = 0;
  }
  if ( !v4 )
    return 0;
  if ( v2->triggerRatio != v3->triggerRatio )
    return 0;
  runtime_memequal();
  return v6;
}
// 809212C: variable 'v6' is possibly undefined

//----- (08092230) --------------------------------------------------------
string __golang runtime___ptr_plainError__Error(runtime_plainError *.this)
{
  int v1; // ecx
  runtime_plainError ***v2; // ebx
  __int32 len; // ecx
  void *retaddr; // [esp+0h] [ebp+0h] BYREF
  string _r0; // [esp+8h] [ebp+8h]

  v2 = *(runtime_plainError ****)(v1 + 16);
  if ( v2 && *v2 == &.this )
    *v2 = (runtime_plainError **)&retaddr;
  if ( !.this )
    runtime_panicwrap();
  len = .this->len;
  _r0.str = .this->str;
  _r0.len = len;
  return _r0;
}
// 8092242: variable 'v1' is possibly undefined

//----- (08092280) --------------------------------------------------------
uintptr __golang type__hash_runtime_sigTabT(runtime_sigTabT_0 *p, uintptr h)
{
  uintptr v2; // [esp+Ch] [ebp-4h]

  v2 = runtime_memhash(p, h, 4u);
  return runtime_strhash(&p->name, v2);
}

//----- (080922E0) --------------------------------------------------------
bool __golang type__eq_runtime_sigTabT(runtime_sigTabT_0 *p, runtime_sigTabT_0 *q)
{
  bool v3; // [esp+10h] [ebp-4h]

  if ( p->flags != q->flags )
    return 0;
  if ( p->name.len != q->name.len )
    return 0;
  runtime_eqstring();
  return v3;
}
// 8092333: variable 'v3' is possibly undefined

//----- (08092350) --------------------------------------------------------
uintptr __golang type__hash_runtime_stackmap(runtime_stackmap *p, uintptr h)
{
  return runtime_memhash(p, h, 9u);
}

//----- (080923A0) --------------------------------------------------------
bool __golang type__eq_runtime_stackmap(runtime_stackmap *p, runtime_stackmap *q)
{
  bool v2; // [esp+Ch] [ebp-4h]

  runtime_memequal();
  return v2;
}
// 80923D6: variable 'v2' is possibly undefined

//----- (080923F0) --------------------------------------------------------
uintptr __golang type__hash_runtime_sweepdata(runtime_sweepdata_0 *p, uintptr h)
{
  uintptr seed; // [esp+Ch] [ebp-4h]

  seed = runtime_memhash(p, h, 0xAu);
  return runtime_memhash(&p->nbgsweep, seed, 8u);
}

//----- (08092460) --------------------------------------------------------
bool __golang type__eq_runtime_sweepdata(runtime_sweepdata_0 *p, runtime_sweepdata_0 *q)
{
  char v3; // [esp+Ch] [ebp-4h]

  runtime_memequal();
  return v3 && p->nbgsweep == q->nbgsweep && q->npausesweep == p->npausesweep;
}
// 8092498: variable 'v3' is possibly undefined

//----- (080924D0) --------------------------------------------------------
uintptr __golang type__hash_runtime_traceStack(runtime_traceStack *p, uintptr h)
{
  return runtime_memhash(p, h, 0x10u);
}

//----- (08092520) --------------------------------------------------------
bool __golang type__eq_runtime_traceStack(runtime_traceStack *p, runtime_traceStack *q)
{
  return runtime_memequal128(p, q);
}

//----- (08092560) --------------------------------------------------------
uintptr __golang type__hash__14_runtime_dbgVar(runtime_dbgVar_0 (*p)[14], uintptr h)
{
  int j; // eax
  __int32 i; // [esp+Ch] [ebp-4h]

  for ( j = 0; j < 14; j = i + 1 )
  {
    i = j;
    h = type__hash_runtime_dbgVar(&(*p)[j], h);
  }
  return h;
}

//----- (080925C0) --------------------------------------------------------
bool __golang type__eq__14_runtime_dbgVar(runtime_dbgVar_0 (*p)[14], runtime_dbgVar_0 (*q)[14])
{
  int j; // eax
  char v3; // [esp+10h] [ebp-Ch]
  __int32 i; // [esp+14h] [ebp-8h]
  int v5; // [esp+18h] [ebp-4h]

  for ( j = 0; j < 14; j = i + 1 )
  {
    i = j;
    if ( (*p)[j].name.len == (*q)[j].name.len )
    {
      v5 = j;
      runtime_eqstring();
      if ( v3 )
      {
        if ( (*p)[v5].value == (*q)[v5].value )
          continue;
      }
    }
    return 0;
  }
  return 1;
}
// 8092625: variable 'v3' is possibly undefined

//----- (08092660) --------------------------------------------------------
uintptr __golang type__hash__2_string(string (*p)[2], uintptr h)
{
  int j; // eax
  __int32 i; // [esp+Ch] [ebp-4h]

  for ( j = 0; j < 2; j = i + 1 )
  {
    i = j;
    h = runtime_strhash(&(*p)[j], h);
  }
  return h;
}

//----- (080926C0) --------------------------------------------------------
bool __golang type__eq__2_string(string (*p)[2], string (*q)[2])
{
  int j; // eax
  char v3; // [esp+10h] [ebp-8h]
  __int32 i; // [esp+14h] [ebp-4h]

  for ( j = 0; j < 2; j = i + 1 )
  {
    if ( (*p)[j].len == (*q)[j].len )
    {
      i = j;
      runtime_eqstring();
      if ( v3 )
        continue;
    }
    return 0;
  }
  return 1;
}
// 8092721: variable 'v3' is possibly undefined

//----- (08092740) --------------------------------------------------------
uintptr __golang type__hash__33_float64(float64 (*p)[33], uintptr h)
{
  int j; // eax
  __int32 i; // [esp+Ch] [ebp-4h]

  for ( j = 0; j < 33; j = i + 1 )
  {
    i = j;
    h = runtime_f64hash(&(*p)[j], h);
  }
  return h;
}

//----- (080927A0) --------------------------------------------------------
bool __golang type__eq__33_float64(float64 (*p)[33], float64 (*q)[33])
{
  int i; // edx

  for ( i = 0; i < 33; ++i )
  {
    if ( (*p)[i] != (*q)[i] )
      return 0;
  }
  return 1;
}

//----- (080927F0) --------------------------------------------------------
uintptr __golang type__hash__3_string(string (*p)[3], uintptr h)
{
  int j; // eax
  __int32 i; // [esp+Ch] [ebp-4h]

  for ( j = 0; j < 3; j = i + 1 )
  {
    i = j;
    h = runtime_strhash(&(*p)[j], h);
  }
  return h;
}

//----- (08092850) --------------------------------------------------------
bool __golang type__eq__3_string(string (*p)[3], string (*q)[3])
{
  int j; // eax
  char v3; // [esp+10h] [ebp-8h]
  __int32 i; // [esp+14h] [ebp-4h]

  for ( j = 0; j < 3; j = i + 1 )
  {
    if ( (*p)[j].len == (*q)[j].len )
    {
      i = j;
      runtime_eqstring();
      if ( v3 )
        continue;
    }
    return 0;
  }
  return 1;
}
// 80928B1: variable 'v3' is possibly undefined

//----- (080928D0) --------------------------------------------------------
uintptr __golang type__hash__4_string(string (*p)[4], uintptr h)
{
  int j; // eax
  __int32 i; // [esp+Ch] [ebp-4h]

  for ( j = 0; j < 4; j = i + 1 )
  {
    i = j;
    h = runtime_strhash(&(*p)[j], h);
  }
  return h;
}

//----- (08092930) --------------------------------------------------------
bool __golang type__eq__4_string(string (*p)[4], string (*q)[4])
{
  int j; // eax
  char v3; // [esp+10h] [ebp-8h]
  __int32 i; // [esp+14h] [ebp-4h]

  for ( j = 0; j < 4; j = i + 1 )
  {
    if ( (*p)[j].len == (*q)[j].len )
    {
      i = j;
      runtime_eqstring();
      if ( v3 )
        continue;
    }
    return 0;
  }
  return 1;
}
// 8092991: variable 'v3' is possibly undefined

//----- (080929B0) --------------------------------------------------------
uintptr __golang type__hash__5_string(string (*p)[5], uintptr h)
{
  int j; // eax
  __int32 i; // [esp+Ch] [ebp-4h]

  for ( j = 0; j < 5; j = i + 1 )
  {
    i = j;
    h = runtime_strhash(&(*p)[j], h);
  }
  return h;
}

//----- (08092A10) --------------------------------------------------------
bool __golang type__eq__5_string(string (*p)[5], string (*q)[5])
{
  int j; // eax
  char v3; // [esp+10h] [ebp-8h]
  __int32 i; // [esp+14h] [ebp-4h]

  for ( j = 0; j < 5; j = i + 1 )
  {
    if ( (*p)[j].len == (*q)[j].len )
    {
      i = j;
      runtime_eqstring();
      if ( v3 )
        continue;
    }
    return 0;
  }
  return 1;
}
// 8092A71: variable 'v3' is possibly undefined

//----- (08092A90) --------------------------------------------------------
uintptr __golang type__hash__65_runtime_sigTabT(runtime_sigTabT (*p)[65], uintptr h)
{
  int j; // eax
  __int32 i; // [esp+Ch] [ebp-4h]

  for ( j = 0; j < 65; j = i + 1 )
  {
    i = j;
    h = type__hash_runtime_sigTabT(&(*p)[j], h);
  }
  return h;
}

//----- (08092AF0) --------------------------------------------------------
bool __golang type__eq__65_runtime_sigTabT(runtime_sigTabT (*p)[65], runtime_sigTabT (*q)[65])
{
  int j; // eax
  char v3; // [esp+10h] [ebp-8h]
  __int32 i; // [esp+14h] [ebp-4h]

  for ( j = 0; j < 65; j = i + 1 )
  {
    if ( (*p)[j].flags == (*q)[j].flags && (*p)[j].name.len == (*q)[j].name.len )
    {
      i = j;
      runtime_eqstring();
      if ( v3 )
        continue;
    }
    return 0;
  }
  return 1;
}
// 8092B5E: variable 'v3' is possibly undefined

//----- (08092B80) --------------------------------------------------------
uintptr __golang type__hash__6_string(string (*p)[6], uintptr h)
{
  int j; // eax
  __int32 i; // [esp+Ch] [ebp-4h]

  for ( j = 0; j < 6; j = i + 1 )
  {
    i = j;
    h = runtime_strhash(&(*p)[j], h);
  }
  return h;
}

//----- (08092BE0) --------------------------------------------------------
bool __golang type__eq__6_string(string (*p)[6], string (*q)[6])
{
  int j; // eax
  char v3; // [esp+10h] [ebp-8h]
  __int32 i; // [esp+14h] [ebp-4h]

  for ( j = 0; j < 6; j = i + 1 )
  {
    if ( (*p)[j].len == (*q)[j].len )
    {
      i = j;
      runtime_eqstring();
      if ( v3 )
        continue;
    }
    return 0;
  }
  return 1;
}
// 8092C41: variable 'v3' is possibly undefined

//----- (08092C60) --------------------------------------------------------
uintptr __golang type__hash__9_string(string (*p)[9], uintptr h)
{
  int j; // eax
  __int32 i; // [esp+Ch] [ebp-4h]

  for ( j = 0; j < 9; j = i + 1 )
  {
    i = j;
    h = runtime_strhash(&(*p)[j], h);
  }
  return h;
}

//----- (08092CC0) --------------------------------------------------------
bool __golang type__eq__9_string(string (*p)[9], string (*q)[9])
{
  int j; // eax
  char v3; // [esp+10h] [ebp-8h]
  __int32 i; // [esp+14h] [ebp-4h]

  for ( j = 0; j < 9; j = i + 1 )
  {
    if ( (*p)[j].len == (*q)[j].len )
    {
      i = j;
      runtime_eqstring();
      if ( v3 )
        continue;
    }
    return 0;
  }
  return 1;
}
// 8092D21: variable 'v3' is possibly undefined

//----- (08092D40) --------------------------------------------------------
uintptr __golang type__hash_struct__runtime_cycle_uint32__runtime_flushed_bool_(
        struct_{_runtime_cycle_uint32__runtime_flushed_bool_} *p,
        uintptr h)
{
  return runtime_memhash(p, h, 5u);
}

//----- (08092D90) --------------------------------------------------------
bool __golang type__eq_struct__runtime_cycle_uint32__runtime_flushed_bool_(
        struct_{_runtime_cycle_uint32__runtime_flushed_bool_} *p,
        struct_{_runtime_cycle_uint32__runtime_flushed_bool_} *q)
{
  return p->cycle == q->cycle && p->flushed == q->flushed;
}

//----- (08092DD0) --------------------------------------------------------
uintptr __golang type__hash_struct__runtime_enabled_bool__runtime_pad__3_uint8__runtime_needed_bool__runtime_cgo_bool__runtime_alignme_uint64_(
        struct_{_runtime_enabled_bool__runtime_pad__3_uint8__runtime_needed_bool__runtime_cgo_bool__runtime_alignme_uint64_} *p,
        uintptr h)
{
  uintptr seed; // [esp+Ch] [ebp-4h]

  seed = runtime_memhash(p, h, 6u);
  return runtime_memhash(&p->alignme, seed, 8u);
}

//----- (08092E40) --------------------------------------------------------
bool __golang type__eq_struct__runtime_enabled_bool__runtime_pad__3_uint8__runtime_needed_bool__runtime_cgo_bool__runtime_alignme_uint64_(
        struct_{_runtime_enabled_bool__runtime_pad__3_uint8__runtime_needed_bool__runtime_cgo_bool__runtime_alignme_uint64_} *p,
        struct_{_runtime_enabled_bool__runtime_pad__3_uint8__runtime_needed_bool__runtime_cgo_bool__runtime_alignme_uint64_} *q)
{
  char v3; // [esp+Ch] [ebp-4h]

  runtime_memequal();
  return v3 && LODWORD(p->alignme) == LODWORD(q->alignme) && HIDWORD(p->alignme) == HIDWORD(q->alignme);
}
// 8092E78: variable 'v3' is possibly undefined

//----- (08092EB0) --------------------------------------------------------
uintptr __golang type__hash_struct__runtime_full_runtime_lfstack__runtime_empty_runtime_lfstack__runtime_pad0__64_uint8__runtime_wbufSpans_struct__runtime_lock_runtime_mutex__runtime_free_runtime_mSpanList__runtime_busy_runtime_mSpanList_____uint32__runtime_bytesMarked_uint64__runtime_markrootNext_uint32__runtime_markrootJobs_uint32__runtime_nproc_uint32__runtime_tstart_int64__runtime_nwait_uint32__runtime_ndone_uint32__runtime_alldone_runtime_note__runtime_helperDrainBlock_bool__runtime_nFlushCacheRoots_int__runtime_nDataRoots_int__runtime_nBSSRoots_int__runtime_nSpanRoots_int__runtime_nStackRoots_int__runtime_markrootDone_bool__runtime_startSema_uint32__runtime_markDoneSema_uint32__runtime_bgMarkReady_runtime_note__runtime_bgMarkDone_uint32__runtime_mode_runtime_gcMode__runtime_userForced_bool__runtime_totaltime_int64__runtime_initialHeapLive_uint64__runtime_assistQueue_struct__runtime_lock_runtime_mutex__runtime_head_runtime_guintptr__runtime_tail_runtime_guintptr___runtime_sweepWaiters_struct__runtime_lock_runtime_mutex__runtime_head_runtime_guintptr___runtime_cycles_uint32__runtime_stwprocs_int32__runtime_maxprocs_int32__runtime_tSweepTerm_int64__runtime_tMark_int64__runtime_tMarkTerm_int64__runtime_tEnd_int64__runtime_pauseNS_int64__runtime_pauseStart_int64__runtime_heap0_uint64__runtime_heap1_uint64__runtime_heap2_uint64__runtime_heapGoal_uint64_(
        struct_{_runtime_full_runtime_lfstack__runtime_empty_runtime_lfstack__runtime_pad0__64_uint8__runtime_wbufSpans_struct_{_runtime_lock_runtime_mutex__runtime_free_runtime_mSpanList__runtime_busy_runtime_mSpanList_}____uint32__runtime_bytesMarked_uint64__runtime_markrootNext_uint32__runtime_markrootJobs_uint32__runtime_nproc_uint32__runtime_tstart_int64__runtime_nwait_uint32__runtime_ndone_uint32__runtime_alldone_runtime_note__runtime_helperDrainBlock_bool__runtime_nFlushCacheRoots_int__runtime_nDataRoots_int__runtime_nBSSRoots_int__runtime_nSpanRoots_int__runtime_nStackRoots_int__runtime_markrootDone_bool__runtime_startSema_uint32__runtime_markDoneSema_uint32__runtime_bgMarkReady_runtime_note__runtime_bgMarkDone_uint32__runtime_mode_runtime_gcMode__runtime_userForced_bool__runtime_totaltime_int64__runtime_initialHeapLive_uint64__runtime_assistQueue_struct_{_runtime_lock_runtime_mutex__runtime_head_runtime_guintptr__runtime_tail_runtime_guintptr_}__runtime_sweepWaiters_struct_{_runtime_lock_runtime_mutex__runtime_head_runtime_guintptr_}__runtime_cycles_uint32__runtime_stwprocs_int32__runtime_maxprocs_int32__runtime_tSweepTerm_int64__runtime_tMark_int64__runtime_tMarkTerm_int64__runtime_tEnd_int64__runtime_pauseNS_int64__runtime_pauseStart_int64__runtime_heap0_uint64__runtime_heap1_uint64__runtime_heap2_uint64__runtime_heapGoal_uint64_} *p,
        uintptr h)
{
  uintptr seed; // [esp+Ch] [ebp-4h]
  uintptr v3; // [esp+Ch] [ebp-4h]
  uintptr v4; // [esp+Ch] [ebp-4h]
  uintptr v5; // [esp+Ch] [ebp-4h]

  seed = runtime_memhash(p, h, 0x64u);
  v3 = runtime_memhash(&p->bytesMarked, seed, 0x29u);
  v4 = runtime_memhash(&p->nFlushCacheRoots, v3, 0x15u);
  v5 = runtime_memhash(&p->startSema, v4, 0x15u);
  return runtime_memhash(&p->totaltime, v5, 0x80u);
}

//----- (08092F80) --------------------------------------------------------
bool __golang type__eq_struct__runtime_full_runtime_lfstack__runtime_empty_runtime_lfstack__runtime_pad0__64_uint8__runtime_wbufSpans_struct__runtime_lock_runtime_mutex__runtime_free_runtime_mSpanList__runtime_busy_runtime_mSpanList_____uint32__runtime_bytesMarked_uint64__runtime_markrootNext_uint32__runtime_markrootJobs_uint32__runtime_nproc_uint32__runtime_tstart_int64__runtime_nwait_uint32__runtime_ndone_uint32__runtime_alldone_runtime_note__runtime_helperDrainBlock_bool__runtime_nFlushCacheRoots_int__runtime_nDataRoots_int__runtime_nBSSRoots_int__runtime_nSpanRoots_int__runtime_nStackRoots_int__runtime_markrootDone_bool__runtime_startSema_uint32__runtime_markDoneSema_uint32__runtime_bgMarkReady_runtime_note__runtime_bgMarkDone_uint32__runtime_mode_runtime_gcMode__runtime_userForced_bool__runtime_totaltime_int64__runtime_initialHeapLive_uint64__runtime_assistQueue_struct__runtime_lock_runtime_mutex__runtime_head_runtime_guintptr__runtime_tail_runtime_guintptr___runtime_sweepWaiters_struct__runtime_lock_runtime_mutex__runtime_head_runtime_guintptr___runtime_cycles_uint32__runtime_stwprocs_int32__runtime_maxprocs_int32__runtime_tSweepTerm_int64__runtime_tMark_int64__runtime_tMarkTerm_int64__runtime_tEnd_int64__runtime_pauseNS_int64__runtime_pauseStart_int64__runtime_heap0_uint64__runtime_heap1_uint64__runtime_heap2_uint64__runtime_heapGoal_uint64_(
        struct_{_runtime_full_runtime_lfstack__runtime_empty_runtime_lfstack__runtime_pad0__64_uint8__runtime_wbufSpans_struct_{_runtime_lock_runtime_mutex__runtime_free_runtime_mSpanList__runtime_busy_runtime_mSpanList_}____uint32__runtime_bytesMarked_uint64__runtime_markrootNext_uint32__runtime_markrootJobs_uint32__runtime_nproc_uint32__runtime_tstart_int64__runtime_nwait_uint32__runtime_ndone_uint32__runtime_alldone_runtime_note__runtime_helperDrainBlock_bool__runtime_nFlushCacheRoots_int__runtime_nDataRoots_int__runtime_nBSSRoots_int__runtime_nSpanRoots_int__runtime_nStackRoots_int__runtime_markrootDone_bool__runtime_startSema_uint32__runtime_markDoneSema_uint32__runtime_bgMarkReady_runtime_note__runtime_bgMarkDone_uint32__runtime_mode_runtime_gcMode__runtime_userForced_bool__runtime_totaltime_int64__runtime_initialHeapLive_uint64__runtime_assistQueue_struct_{_runtime_lock_runtime_mutex__runtime_head_runtime_guintptr__runtime_tail_runtime_guintptr_}__runtime_sweepWaiters_struct_{_runtime_lock_runtime_mutex__runtime_head_runtime_guintptr_}__runtime_cycles_uint32__runtime_stwprocs_int32__runtime_maxprocs_int32__runtime_tSweepTerm_int64__runtime_tMark_int64__runtime_tMarkTerm_int64__runtime_tEnd_int64__runtime_pauseNS_int64__runtime_pauseStart_int64__runtime_heap0_uint64__runtime_heap1_uint64__runtime_heap2_uint64__runtime_heapGoal_uint64_} *p,
        struct_{_runtime_full_runtime_lfstack__runtime_empty_runtime_lfstack__runtime_pad0__64_uint8__runtime_wbufSpans_struct_{_runtime_lock_runtime_mutex__runtime_free_runtime_mSpanList__runtime_busy_runtime_mSpanList_}____uint32__runtime_bytesMarked_uint64__runtime_markrootNext_uint32__runtime_markrootJobs_uint32__runtime_nproc_uint32__runtime_tstart_int64__runtime_nwait_uint32__runtime_ndone_uint32__runtime_alldone_runtime_note__runtime_helperDrainBlock_bool__runtime_nFlushCacheRoots_int__runtime_nDataRoots_int__runtime_nBSSRoots_int__runtime_nSpanRoots_int__runtime_nStackRoots_int__runtime_markrootDone_bool__runtime_startSema_uint32__runtime_markDoneSema_uint32__runtime_bgMarkReady_runtime_note__runtime_bgMarkDone_uint32__runtime_mode_runtime_gcMode__runtime_userForced_bool__runtime_totaltime_int64__runtime_initialHeapLive_uint64__runtime_assistQueue_struct_{_runtime_lock_runtime_mutex__runtime_head_runtime_guintptr__runtime_tail_runtime_guintptr_}__runtime_sweepWaiters_struct_{_runtime_lock_runtime_mutex__runtime_head_runtime_guintptr_}__runtime_cycles_uint32__runtime_stwprocs_int32__runtime_maxprocs_int32__runtime_tSweepTerm_int64__runtime_tMark_int64__runtime_tMarkTerm_int64__runtime_tEnd_int64__runtime_pauseNS_int64__runtime_pauseStart_int64__runtime_heap0_uint64__runtime_heap1_uint64__runtime_heap2_uint64__runtime_heapGoal_uint64_} *q)
{
  bool v2; // al
  bool v3; // al
  bool v4; // al
  bool v6; // [esp+Ch] [ebp-4h]

  runtime_memequal();
  if ( v6 )
  {
    runtime_memequal();
    v2 = v6;
  }
  else
  {
    v2 = 0;
  }
  if ( v2 )
  {
    runtime_memequal();
    v3 = v6;
  }
  else
  {
    v3 = 0;
  }
  if ( v3 )
  {
    runtime_memequal();
    v4 = v6;
  }
  else
  {
    v4 = 0;
  }
  if ( !v4 )
    return 0;
  runtime_memequal();
  return v6;
}
// 8092FBC: variable 'v6' is possibly undefined

//----- (080930B0) --------------------------------------------------------
uintptr __golang type__hash_struct__runtime_note_runtime_note__runtime_mask__3_uint32__runtime_wanted__3_uint32__runtime_ignored__3_uint32__runtime_recv__3_uint32__runtime_state_uint32__runtime_inuse_bool_(
        struct_{_runtime_note_runtime_note__runtime_mask__3_uint32__runtime_wanted__3_uint32__runtime_ignored__3_uint32__runtime_recv__3_uint32__runtime_state_uint32__runtime_inuse_bool_} *p,
        uintptr h)
{
  return runtime_memhash(p, h, 0x39u);
}

//----- (08093100) --------------------------------------------------------
bool __golang type__eq_struct__runtime_note_runtime_note__runtime_mask__3_uint32__runtime_wanted__3_uint32__runtime_ignored__3_uint32__runtime_recv__3_uint32__runtime_state_uint32__runtime_inuse_bool_(
        struct_{_runtime_note_runtime_note__runtime_mask__3_uint32__runtime_wanted__3_uint32__runtime_ignored__3_uint32__runtime_recv__3_uint32__runtime_state_uint32__runtime_inuse_bool_} *p,
        struct_{_runtime_note_runtime_note__runtime_mask__3_uint32__runtime_wanted__3_uint32__runtime_ignored__3_uint32__runtime_recv__3_uint32__runtime_state_uint32__runtime_inuse_bool_} *q)
{
  bool v2; // [esp+Ch] [ebp-4h]

  runtime_memequal();
  return v2;
}
// 8093136: variable 'v2' is possibly undefined

//----- (08093150) --------------------------------------------------------
uintptr __golang type__hash_struct__F_uintptr__runtime_c__ptr_runtime_mcache__runtime_spc_runtime_spanClass_(
        struct_{_F_uintptr__runtime_c__runtime_mcache__runtime_spc_runtime_spanClass_} *p,
        uintptr h)
{
  return runtime_memhash(p, h, 9u);
}

//----- (080931A0) --------------------------------------------------------
bool __golang type__eq_struct__F_uintptr__runtime_c__ptr_runtime_mcache__runtime_spc_runtime_spanClass_(
        struct_{_F_uintptr__runtime_c__runtime_mcache__runtime_spc_runtime_spanClass_} *p,
        struct_{_F_uintptr__runtime_c__runtime_mcache__runtime_spc_runtime_spanClass_} *q)
{
  bool v2; // [esp+Ch] [ebp-4h]

  runtime_memequal();
  return v2;
}
// 80931D6: variable 'v2' is possibly undefined

//----- (080931F0) --------------------------------------------------------
uintptr __golang type__hash_struct__F_uintptr__runtime_preemptible_bool_(
        struct_{_F_uintptr__runtime_preemptible_bool_} *p,
        uintptr h)
{
  return runtime_memhash(p, h, 5u);
}

//----- (08093240) --------------------------------------------------------
bool __golang type__eq_struct__F_uintptr__runtime_preemptible_bool_(
        struct_{_F_uintptr__runtime_preemptible_bool_} *p,
        struct_{_F_uintptr__runtime_preemptible_bool_} *q)
{
  return p->_F == q->_F && p->preemptible == q->preemptible;
}

//----- (08093280) --------------------------------------------------------
uintptr __golang type__hash_struct__F_uintptr__runtime_s__ptr__ptr_runtime_mspan__runtime_h__ptr_runtime_mheap__runtime_npage_uintptr__runtime_spanclass_runtime_spanClass__runtime_large_bool_(
        struct_{_F_uintptr__runtime_s___runtime_mspan__runtime_h__runtime_mheap__runtime_npage_uintptr__runtime_spanclass_runtime_spanClass__runtime_large_bool_} *p,
        uintptr h)
{
  return runtime_memhash(p, h, 0x12u);
}

//----- (080932D0) --------------------------------------------------------
bool __golang type__eq_struct__F_uintptr__runtime_s__ptr__ptr_runtime_mspan__runtime_h__ptr_runtime_mheap__runtime_npage_uintptr__runtime_spanclass_runtime_spanClass__runtime_large_bool_(
        struct_{_F_uintptr__runtime_s___runtime_mspan__runtime_h__runtime_mheap__runtime_npage_uintptr__runtime_spanclass_runtime_spanClass__runtime_large_bool_} *p,
        struct_{_F_uintptr__runtime_s___runtime_mspan__runtime_h__runtime_mheap__runtime_npage_uintptr__runtime_spanclass_runtime_spanClass__runtime_large_bool_} *q)
{
  bool v2; // [esp+Ch] [ebp-4h]

  runtime_memequal();
  return v2;
}
// 8093306: variable 'v2' is possibly undefined

//----- (08093320) --------------------------------------------------------
uintptr __golang type__hash_struct__F_uintptr__runtime_s__ptr__ptr_runtime_mspan__runtime_size__ptr_uintptr__runtime_needzero_bool__runtime_noscan_bool_(
        struct_{_F_uintptr__runtime_s___runtime_mspan__runtime_size__uintptr__runtime_needzero_bool__runtime_noscan_bool_} *p,
        uintptr h)
{
  return runtime_memhash(p, h, 0xEu);
}

//----- (08093370) --------------------------------------------------------
bool __golang type__eq_struct__F_uintptr__runtime_s__ptr__ptr_runtime_mspan__runtime_size__ptr_uintptr__runtime_needzero_bool__runtime_noscan_bool_(
        struct_{_F_uintptr__runtime_s___runtime_mspan__runtime_size__uintptr__runtime_needzero_bool__runtime_noscan_bool_} *p,
        struct_{_F_uintptr__runtime_s___runtime_mspan__runtime_size__uintptr__runtime_needzero_bool__runtime_noscan_bool_} *q)
{
  bool v2; // [esp+Ch] [ebp-4h]

  runtime_memequal();
  return v2;
}
// 80933A6: variable 'v2' is possibly undefined

//----- (080933C0) --------------------------------------------------------
error_0 __golang errors_New(string text)
{
  uintptr *v1; // eax
  uintptr *v2; // [esp+8h] [ebp-4h]
  error_0 _r1; // [esp+18h] [ebp+Ch]

  v1 = (uintptr *)runtime_newobject((runtime__type_0 *)&stru_80D1920);
  v1[1] = text.len;
  if ( *(_DWORD *)&runtime_writeBarrier.enabled )
  {
    v2 = v1;
    runtime_writebarrierptr(v1, (uintptr)text.str);
    v1 = v2;
  }
  else
  {
    *v1 = (uintptr)text.str;
  }
  _r1.tab = (runtime_itab_0 *)&go_itab__errors_errorString_error;
  _r1.data = v1;
  return _r1;
}
// 8136610: using guessed type runtime_interfacetype_0 *go_itab__errors_errorString_error;

//----- (08093440) --------------------------------------------------------
string __golang errors___ptr_errorString__Error(errors_errorString *e)
{
  return e->s;
}

//----- (08093470) --------------------------------------------------------
void __golang unicode_utf8_DecodeRuneInString(string s, int32 r, __int32 size)
{
  uint8 v3; // bl
  unsigned int v4; // ebx
  unsigned __int8 v5; // bp
  unicode_utf8_acceptRange *v6; // ebx
  uint8 hi; // di
  uint8 lo; // bl

  if ( s.len >= 1 )
  {
    v3 = unicode_utf8_first[*s.str];
    if ( v3 < 0xF0u )
    {
      v4 = v3 >> 4;
      if ( v4 >= 5 )
        runtime_panicindex();
      v5 = unicode_utf8_first[*s.str] & 7;
      v6 = &unicode_utf8_acceptRanges[v4];
      hi = v6->hi;
      lo = v6->lo;
      if ( s.len >= v5 )
      {
        if ( s.len <= 1u )
          runtime_panicindex();
        if ( s.str[1] >= lo && hi >= s.str[1] && v5 != 2 )
        {
          if ( s.len <= 2u )
            runtime_panicindex();
          if ( (unsigned __int8)(s.str[2] + 0x80) <= 0x3Fu && v5 != 3 && s.len <= 3u )
            runtime_panicindex();
        }
      }
    }
  }
}

//----- (08093640) --------------------------------------------------------
__int32 __golang unicode_utf8_EncodeRune(__uint8 p, int32 r)
{
  int32 v2; // eax

  v2 = r;
  if ( (unsigned int)r <= 0x7F )
  {
    if ( !p.len )
      runtime_panicindex();
    *p.array = r;
    return 1;
  }
  if ( (unsigned int)r <= 0x7FF )
  {
    if ( p.len <= 1u )
      runtime_panicindex();
    *p.array = (r >> 6) | 0xC0;
    p.array[1] = r & 0x3F | 0x80;
    return 2;
  }
  if ( (unsigned int)r > 0x10FFFF || (unsigned int)(r - 55296) <= 0x7FF )
  {
    v2 = 65533;
  }
  else if ( (unsigned int)r > 0xFFFF )
  {
    if ( p.len <= 3u )
      runtime_panicindex();
    *p.array = (r >> 18) | 0xF0;
    p.array[1] = (r >> 12) & 0x3F | 0x80;
    p.array[2] = (r >> 6) & 0x3F | 0x80;
    p.array[3] = r & 0x3F | 0x80;
    return 4;
  }
  if ( p.len <= 2u )
    runtime_panicindex();
  *p.array = (v2 >> 12) | 0xE0;
  p.array[1] = (v2 >> 6) & 0x3F | 0x80;
  p.array[2] = v2 & 0x3F | 0x80;
  return 3;
}

//----- (08093780) --------------------------------------------------------
__int32 __golang unicode_utf8_RuneCount(__uint8 p)
{
  __int32 v1; // edx
  __int32 v2; // ebx
  uint8 v3; // bp
  int v4; // ebp
  unsigned int v5; // esi
  unicode_utf8_acceptRange *v6; // esi
  uint8 hi; // di
  uint8 lo; // si
  uint8 v9; // bl
  int v10; // ebx
  int v11; // ebx
  int v12; // ebx
  __int32 n; // [esp+0h] [ebp-4h]

  v1 = 0;
  v2 = 0;
  while ( v1 < p.len )
  {
    if ( (unsigned int)v1 >= p.len )
      runtime_panicindex();
    if ( p.array[v1] >= 0x80u )
    {
      v3 = unicode_utf8_first[p.array[v1]];
      if ( v3 == 0xF1 )
      {
        ++v1;
      }
      else
      {
        v4 = v3 & 7;
        if ( v4 + v1 <= p.len )
        {
          v5 = unicode_utf8_first[p.array[v1]] >> 4;
          if ( v5 >= 5 )
            runtime_panicindex();
          n = v2;
          v6 = &unicode_utf8_acceptRanges[v5];
          hi = v6->hi;
          lo = v6->lo;
          if ( (unsigned int)(v1 + 1) >= p.len )
            runtime_panicindex();
          v9 = p.array[v1 + 1];
          if ( v9 < lo || hi < v9 )
          {
            v10 = 1;
          }
          else
          {
            if ( v4 != 2 )
            {
              if ( (unsigned int)(v1 + 2) >= p.len )
                runtime_panicindex();
              if ( (unsigned __int8)(p.array[v1 + 2] + 0x80) <= 0x3Fu )
              {
                if ( v4 != 3 )
                {
                  if ( (unsigned int)(v1 + 3) >= p.len )
                    runtime_panicindex();
                  if ( (unsigned __int8)(p.array[v1 + 3] + 0x80) <= 0x3Fu )
                    v12 = v4;
                  else
                    v12 = 1;
                  v4 = v12;
                }
                v11 = v4;
              }
              else
              {
                v11 = 1;
              }
              v4 = v11;
            }
            v10 = v4;
          }
          v1 += v10;
          v2 = n;
        }
        else
        {
          ++v1;
        }
      }
    }
    else
    {
      ++v1;
    }
    ++v2;
  }
  return v2;
}

//----- (080938D0) --------------------------------------------------------
void __golang unicode_utf8_RuneCountInString(string s, __int32 n)
{
  __int32 v2; // edx
  int v3; // ebx
  uint8 v4; // bp
  int v5; // ebp
  unsigned int v6; // esi
  unicode_utf8_acceptRange *v7; // esi
  uint8 lo; // di
  uint8 hi; // si
  uint8 v10; // bl
  int v11; // ebx
  int v12; // ebx
  int v13; // ebx
  int v14; // [esp+0h] [ebp-4h]

  v2 = 0;
  v3 = 0;
  while ( v2 < s.len )
  {
    if ( (unsigned int)v2 >= s.len )
      runtime_panicindex();
    if ( s.str[v2] >= 0x80u )
    {
      v4 = unicode_utf8_first[s.str[v2]];
      if ( v4 == 0xF1 )
      {
        ++v2;
      }
      else
      {
        v5 = v4 & 7;
        if ( v5 + v2 <= s.len )
        {
          v6 = unicode_utf8_first[s.str[v2]] >> 4;
          if ( v6 >= 5 )
            runtime_panicindex();
          v14 = v3;
          v7 = &unicode_utf8_acceptRanges[v6];
          lo = v7->lo;
          hi = v7->hi;
          if ( (unsigned int)(v2 + 1) >= s.len )
            runtime_panicindex();
          v10 = s.str[v2 + 1];
          if ( v10 < lo || hi < v10 )
          {
            v11 = 1;
          }
          else
          {
            if ( v5 != 2 )
            {
              if ( (unsigned int)(v2 + 2) >= s.len )
                runtime_panicindex();
              if ( (unsigned __int8)(s.str[v2 + 2] + 0x80) <= 0x3Fu )
              {
                if ( v5 != 3 )
                {
                  if ( (unsigned int)(v2 + 3) >= s.len )
                    runtime_panicindex();
                  if ( (unsigned __int8)(s.str[v2 + 3] + 0x80) <= 0x3Fu )
                    v13 = v5;
                  else
                    v13 = 1;
                  v5 = v13;
                }
                v12 = v5;
              }
              else
              {
                v12 = 1;
              }
              v5 = v12;
            }
            v11 = v5;
          }
          v2 += v11;
          v3 = v14;
        }
        else
        {
          ++v2;
        }
      }
    }
    else
    {
      ++v2;
    }
    ++v3;
  }
}

//----- (08093A20) --------------------------------------------------------
string __golang strconv___ptr_decimal__String(strconv_decimal *a)
{
  __int32 nd; // ecx
  __int32 dp; // ebx
  __int32 len; // ecx
  __int32 v4; // ebp
  __int32 v5; // esi
  unsigned __int32 v6; // esi
  __int32 v7; // edi
  unsigned int v8; // eax
  unsigned __int32 v9; // edi
  unsigned __int32 v10; // edx
  int v11; // edx
  unsigned __int32 v12; // ecx
  _BYTE et[24]; // [esp+0h] [ebp-2Ch]
  string v14; // [esp+10h] [ebp-1Ch]
  int v15; // [esp+20h] [ebp-Ch]
  uint8 *buf_ptr; // [esp+28h] [ebp-4h]
  string _r0; // [esp+34h] [ebp+8h]

  nd = a->nd;
  dp = a->dp;
  if ( dp <= 0 )
    len = nd + 10;
  else
    len = nd + dp + 10;
  if ( dp < 0 )
    len -= dp;
  *(runtime_slice_0 *)&et[12] = runtime_makeslice((runtime__type_0 *)&i, len, len);
  v4 = a->nd;
  if ( v4 )
  {
    buf_ptr = *(uint8 **)&et[12];
    v5 = a->dp;
    if ( v5 > 0 )
    {
      if ( v5 >= v4 )
      {
        if ( (unsigned int)v4 > 0x320 )
          runtime_panicslice();
        if ( *(int *)&et[16] <= v4 )
          v4 = *(_DWORD *)&et[16];
        runtime_memmove();
        v12 = v4 + a->dp - a->nd;
        if ( v4 > v12 || v12 > *(_DWORD *)&et[20] )
          runtime_panicslice();
        *(_DWORD *)et = *(_DWORD *)&et[12] + (v4 & ((v4 - *(_DWORD *)&et[20]) >> 31));
        *(_DWORD *)&et[4] = a->dp - a->nd;
        *(_DWORD *)&et[8] = *(_DWORD *)&et[20] - v4;
        v8 = v4 + strconv_digitZero(*(__uint8 *)et);
      }
      else
      {
        if ( (unsigned int)v5 > 0x320 )
          runtime_panicslice();
        if ( *(int *)&et[16] <= v5 )
          v5 = *(_DWORD *)&et[16];
        runtime_memmove();
        if ( (unsigned int)v5 >= *(_DWORD *)&et[16] )
          runtime_panicindex();
        *(_BYTE *)(*(_DWORD *)&et[12] + v5) = 46;
        if ( (unsigned int)(v5 + 1) > *(_DWORD *)&et[16] || (v9 = a->dp, v10 = a->nd, v9 > v10) || v10 > 0x320 )
          runtime_panicslice();
        v11 = v10 - v9;
        if ( *(_DWORD *)&et[16] - (v5 + 1) <= v11 )
          v11 = *(_DWORD *)&et[16] - (v5 + 1);
        v15 = v11;
        runtime_memmove();
        v8 = v15 + v5 + 1;
      }
    }
    else
    {
      if ( !*(_DWORD *)&et[16] )
        runtime_panicindex();
      **(_BYTE **)&et[12] = 48;
      if ( *(_DWORD *)&et[16] <= 1u )
        runtime_panicindex();
      *(_BYTE *)(*(_DWORD *)&et[12] + 1) = 46;
      v6 = 2 - a->dp;
      if ( v6 < 2 || v6 > *(_DWORD *)&et[20] )
        runtime_panicslice();
      *(_DWORD *)et = *(_DWORD *)&et[12] + (((2 - *(_DWORD *)&et[20]) >> 31) & 2);
      *(_DWORD *)&et[4] = -a->dp;
      *(_DWORD *)&et[8] = *(_DWORD *)&et[20] - 2;
      *(_DWORD *)&et[12] = strconv_digitZero(*(__uint8 *)et);
      if ( (unsigned int)(*(_DWORD *)&et[12] + 2) > *(_DWORD *)&et[16] || (v7 = a->nd, (unsigned int)v7 > 0x320) )
        runtime_panicslice();
      if ( *(_DWORD *)&et[16] - (*(_DWORD *)&et[12] + 2) <= v7 )
        v7 = *(_DWORD *)&et[16] - (*(_DWORD *)&et[12] + 2);
      runtime_memmove();
      v8 = v7 + *(_DWORD *)&et[12] + 2;
    }
    if ( v8 > *(_DWORD *)&et[20] )
      runtime_panicslice();
    *(_DWORD *)&et[4] = buf_ptr;
    *(_QWORD *)&et[8] = __PAIR64__(*(unsigned int *)&et[20], v8);
    runtime_slicebytetostring(0, *(__uint8 *)&et[4], *(string *)&et[16]);
    return v14;
  }
  else
  {
    _r0.str = (uint8 *)"0";
    _r0.len = 1;
  }
  return _r0;
}
// 8093B97: variable 'v14' is possibly undefined
// 80E0D8D: using guessed type char a0;

//----- (08093D80) --------------------------------------------------------
__int32 __golang strconv_digitZero(__uint8 dst)
{
  __int32 i; // edx

  for ( i = 0; i < dst.len; ++i )
  {
    if ( (unsigned int)i >= dst.len )
      runtime_panicindex();
    dst.array[i] = 48;
  }
  return dst.len;
}

//----- (08093DC0) --------------------------------------------------------
void __golang strconv_trim(strconv_decimal *a)
{
  __int32 nd; // ecx
  bool v2; // zf

  while ( 1 )
  {
    nd = a->nd;
    v2 = nd == 0;
    if ( nd <= 0 )
      break;
    if ( (unsigned int)(nd - 1) >= 0x320 )
      runtime_panicindex();
    if ( a->d[nd - 1] != 48 )
    {
      v2 = nd == 0;
      break;
    }
    a->nd = nd - 1;
  }
  if ( v2 )
    a->dp = 0;
}

//----- (08093E20) --------------------------------------------------------
void __golang strconv___ptr_decimal__Assign(strconv_decimal *a, uint64 v)
{
  __int32 v2; // ebx
  int v3; // ebp
  unsigned int v4; // eax
  unsigned int v5; // ecx
  __int32 i; // edx
  int v7; // ebx
  __int32 v8; // et0
  int v9; // ebp
  int j; // ecx
  unsigned __int32 nd; // edx
  uint64 v12; // [esp+10h] [ebp-24h]
  __int32 n; // [esp+18h] [ebp-1Ch]
  uint8 buf[24]; // [esp+1Ch] [ebp-18h]
  char va; // [esp+3Ch] [ebp+8h]

  ((void (*)(void))loc_808FD8A)();
  v4 = HIDWORD(v);
  v5 = v;
  for ( i = 0; ; i = v2 + 1 )
  {
    LOBYTE(v2) = v4 == 0;
    v8 = v2;
    v7 = v3;
    LOBYTE(v7) = v5 != 0;
    v9 = v7 & v8;
    LOBYTE(v7) = v4 != 0;
    v3 = v9 | v7;
    if ( !(_BYTE)v3 )
      break;
    va = v5;
    n = i;
    v12 = runtime_uint64div(__PAIR64__(v4, v5), 0xAuLL);
    v4 = HIDWORD(v12);
    v5 = v12;
    v2 = n;
    if ( (unsigned int)n >= 0x18 )
      runtime_panicindex();
    buf[n] = va - 10 * v12 + 48;
  }
  a->nd = 0;
  for ( j = i - 1; j >= 0; --j )
  {
    if ( (unsigned int)j >= 0x18 || (nd = a->nd, nd >= 0x320) )
      runtime_panicindex();
    a->d[nd] = buf[j];
    ++a->nd;
  }
  a->dp = a->nd;
  strconv_trim(a);
}
// 8093E5E: variable 'v2' is possibly undefined
// 8093E5E: variable 'v3' is possibly undefined

//----- (08093F40) --------------------------------------------------------
void __golang strconv_rightShift(strconv_decimal *a, uint k)
{
  unsigned int v2; // ecx
  __int32 i; // ebx
  unsigned int v4; // ebp
  unsigned int v5; // esi
  int v6; // edi
  __int32 v7; // esi
  int v8; // ebx
  int v9; // ebp
  __int32 v10; // esi
  int v11; // ebp
  __int32 v12; // ebp
  unsigned __int32 w; // [esp+4h] [ebp-14h]
  uint n; // [esp+Ch] [ebp-Ch]
  uint na; // [esp+Ch] [ebp-Ch]
  uint mask; // [esp+10h] [ebp-8h]
  unsigned int v17; // [esp+14h] [ebp-4h]

  v2 = 0;
  for ( i = 0; ; ++i )
  {
    v4 = v2;
    v5 = v2;
    v6 = -(k < 0x20);
    if ( ((v2 >> k) & v6) != 0 )
      break;
    if ( i >= a->nd )
    {
      if ( !v2 )
      {
        a->nd = 0;
        return;
      }
      while ( 1 )
      {
        v4 = v5;
        if ( ((v5 >> k) & v6) != 0 )
          break;
        v5 *= 10;
        ++i;
      }
      break;
    }
    if ( (unsigned int)i >= 0x320 )
      runtime_panicindex();
    v2 = a->d[i] + 10 * v2 - 48;
  }
  a->dp -= i - 1;
  mask = (v6 & (1 << k)) - 1;
  v7 = i;
  w = 0;
  while ( v7 < a->nd )
  {
    if ( (unsigned int)v7 >= 0x320 )
      runtime_panicindex();
    n = v4;
    v8 = a->d[v7];
    v9 = v6 & (v4 >> k);
    if ( w >= 0x320 )
      runtime_panicindex();
    a->d[w] = v9 + 48;
    ++v7;
    v4 = v8 + 10 * (mask & n) - 48;
    v6 = -(k < 0x20);
    ++w;
  }
  v10 = w;
  while ( v4 )
  {
    na = v4;
    v17 = v4 >> k;
    v11 = v6 & (v4 >> k);
    if ( v10 >= 800 )
    {
      if ( (v17 & v6) != 0 )
        a->trunc = 1;
      v12 = v10;
    }
    else
    {
      if ( (unsigned int)v10 >= 0x320 )
        runtime_panicindex();
      a->d[v10] = v11 + 48;
      v12 = v10 + 1;
    }
    v10 = v12;
    v4 = 10 * (mask & na);
  }
  a->nd = v10;
  strconv_trim(a);
}

//----- (08094100) --------------------------------------------------------
bool __golang strconv_prefixIsLessThan(__uint8 b, string s)
{
  uint8 *array; // ebx
  __int32 i; // ebp
  uint8 v4; // si
  uint8 v5; // bl
  uint8 *v6; // et1
  bool v7; // cf
  bool v8; // zf

  array = b.array;
  for ( i = 0; i < s.len; ++i )
  {
    if ( i >= b.len )
      return 1;
    if ( (unsigned int)i >= b.len || (v4 = array[i], (unsigned int)i >= s.len) )
      runtime_panicindex();
    v6 = array;
    v5 = s.str[i];
    v7 = v4 < v5;
    v8 = v4 == v5;
    array = v6;
    if ( !v8 )
      return v7;
  }
  return 0;
}

//----- (08094170) --------------------------------------------------------
void __golang strconv_leftShift(strconv_decimal *a, uint k)
{
  unsigned __int32 nd; // esi
  __int32 v3; // edx
  __int32 v4; // ebp
  __int32 v5; // esi
  int v6; // ebp
  uint v7; // edi
  unsigned int v8; // eax
  uint v9; // ecx
  unsigned int v10; // edx
  unsigned int v11; // edi
  unsigned int v12; // ecx
  __int32 v13; // eax
  __uint8 b; // [esp+0h] [ebp-20h]
  __int32 delta; // [esp+18h] [ebp-8h]
  __int32 v16; // [esp+1Ch] [ebp-4h]

  if ( k >= strconv_leftcheats.len )
    runtime_panicindex();
  nd = a->nd;
  if ( nd > 0x320 )
    runtime_panicslice();
  v16 = strconv_leftcheats.array[k].delta;
  b.array = (uint8 *)a;
  *(_QWORD *)&b.len = nd | 0x32000000000LL;
  if ( strconv_prefixIsLessThan(b, strconv_leftcheats.array[k].cutoff) )
    v3 = v16 - 1;
  else
    v3 = v16;
  delta = v3;
  v4 = a->nd;
  v5 = v3 + v4;
  v6 = v4 - 1;
  v7 = k;
  v8 = 0;
  while ( v6 >= 0 )
  {
    if ( (unsigned int)v6 >= 0x320 )
      runtime_panicindex();
    v9 = v7;
    v10 = v8 + (v7 < 0x20 ? (a->d[v6] - 48) << v7 : 0);
    v8 = v10 / 0xA;
    v11 = v10 % 0xA;
    if ( v5 - 1 >= 800 )
    {
      if ( v11 )
        a->trunc = 1;
    }
    else
    {
      if ( (unsigned int)(v5 - 1) >= 0x320 )
        runtime_panicindex();
      a->d[v5 - 1] = v11 + 48;
    }
    --v6;
    v7 = v9;
    --v5;
    v3 = delta;
  }
  while ( v8 )
  {
    v12 = v8 % 0xA;
    if ( v5 - 1 >= 800 )
    {
      if ( v12 )
        a->trunc = 1;
    }
    else
    {
      if ( (unsigned int)(v5 - 1) >= 0x320 )
        runtime_panicindex();
      a->d[v5 - 1] = v12 + 48;
    }
    v8 /= 0xAu;
    --v5;
  }
  v13 = v3 + a->nd;
  a->nd = v13;
  if ( v13 >= 800 )
    a->nd = 800;
  a->dp += v3;
  strconv_trim(a);
}

//----- (08094330) --------------------------------------------------------
void __golang strconv___ptr_decimal__Shift(strconv_decimal *a, __int32 k)
{
  strconv_decimal *v2; // eax
  __int32 v3; // ecx
  __int32 ka; // [esp+10h] [ebp+8h]
  __int32 kb; // [esp+10h] [ebp+8h]

  v2 = a;
  if ( a->nd )
  {
    v3 = k;
    if ( k > 0 )
    {
      while ( v3 > 28 )
      {
        ka = v3;
        strconv_leftShift(v2, 0x1Cu);
        v3 = ka - 28;
        v2 = a;
      }
      strconv_leftShift(v2, v3);
    }
    else if ( k < 0 )
    {
      while ( v3 < -28 )
      {
        kb = v3;
        strconv_rightShift(v2, 0x1Cu);
        v3 = kb + 28;
        v2 = a;
      }
      strconv_rightShift(v2, -v3);
    }
  }
}

//----- (080943E0) --------------------------------------------------------
void __golang strconv___ptr_decimal__Round(strconv_decimal *a, __int32 nd)
{
  __int32 v2; // edx
  uint8 v3; // bl
  bool v4; // cf
  bool v5; // dl

  if ( nd < 0 )
    return;
  v2 = a->nd;
  if ( nd >= v2 )
    return;
  if ( (unsigned int)nd >= 0x320 )
    runtime_panicindex();
  v3 = a->d[nd];
  v4 = v3 < 0x35u;
  if ( v3 == 53 )
  {
    if ( nd + 1 == v2 )
    {
      if ( a->trunc )
      {
LABEL_8:
        strconv___ptr_decimal__RoundUp(a, nd);
        return;
      }
      if ( nd <= 0 )
      {
        v5 = 0;
      }
      else
      {
        if ( (unsigned int)(nd - 1) >= 0x320 )
          runtime_panicindex();
        v5 = ((a->d[nd - 1] - 48) & 1) != 0;
      }
      goto LABEL_12;
    }
    v4 = 0;
  }
  v5 = !v4;
LABEL_12:
  if ( v5 )
    goto LABEL_8;
  strconv___ptr_decimal__RoundDown(a, nd);
}

//----- (080944A0) --------------------------------------------------------
void __golang strconv___ptr_decimal__RoundDown(strconv_decimal *a, __int32 nd)
{
  if ( nd >= 0 && nd < a->nd )
  {
    a->nd = nd;
    strconv_trim(a);
  }
}

//----- (080944F0) --------------------------------------------------------
void __golang strconv___ptr_decimal__RoundUp(strconv_decimal *a, __int32 nd)
{
  __int32 i; // eax
  uint8 v3; // dl

  if ( nd >= 0 && nd < a->nd )
  {
    for ( i = nd - 1; i >= 0; --i )
    {
      if ( (unsigned int)i >= 0x320 )
        runtime_panicindex();
      v3 = a->d[i];
      if ( v3 < 0x39u )
      {
        a->d[i] = v3 + 1;
        a->nd = i + 1;
        return;
      }
    }
    a->d[0] = 49;
    a->nd = 1;
    ++a->dp;
  }
}

//----- (08094570) --------------------------------------------------------
void __golang strconv___ptr_extFloat__AssignComputeBounds(
        strconv_extFloat_0 *f,
        uint64 mant,
        __int32 exp,
        bool neg,
        strconv_floatInfo_0 *flt,
        strconv_extFloat_0 lower,
        strconv_extFloat_0 upper)
{
  __int32 v7; // edi
  unsigned __int32 v8; // ebx
  int v9; // edi
  int v10; // ebp
  unsigned int v11; // eax
  bool v12; // t1
  int v13; // ebx
  unsigned int mant_high; // ebp
  int v15; // [esp+8h] [ebp-20h]
  int v16; // [esp+10h] [ebp-18h]
  int v17; // [esp+14h] [ebp-14h]
  char v18; // [esp+18h] [ebp-10h]
  int v19; // [esp+1Ch] [ebp-Ch]
  unsigned int v20; // [esp+1Ch] [ebp-Ch]

  f->mant = mant;
  f->exp = exp - flt->mantbits;
  f->neg = neg;
  v7 = f->exp;
  if ( v7 <= 0 )
  {
    v8 = f->exp;
    v9 = -v7;
    v19 = HIDWORD(mant) >> (-(char)v8 - 32);
    v18 = v8 + 32;
    v10 = HIDWORD(mant) << (v8 + 32);
    v17 = -(-v8 < 0x20);
    v16 = v17 & (HIDWORD(mant) >> -(char)v8);
    v11 = v17 & ((unsigned int)mant >> -(char)v8);
    v8 += 32;
    v15 = -((unsigned int)(v9 - 32) < 0x20);
    v20 = v11 | (v8 < 0x20 ? v10 : 0) | v15 & v19;
    v12 = HIDWORD(mant) == (v15 & (v20 << (v9 - 32)) | v17 & (v16 << v9) | (v8 < 0x20 ? v20 >> v8 : 0));
    v13 = -(v8 < 0x20);
    if ( (_DWORD)mant == (v17 & (v20 << v9)) && v12 )
    {
      mant_high = HIDWORD(f->mant);
      LODWORD(f->mant) = v13 & (mant_high << v18) | v17 & (LODWORD(f->mant) >> v9) | v15 & (mant_high >> (v9 - 32));
      HIDWORD(f->mant) = v17 & (mant_high >> v9);
      f->exp = 0;
    }
  }
}

//----- (08094830) --------------------------------------------------------
void __golang strconv___ptr_extFloat__Normalize(strconv_extFloat_0 *f, uint shift)
{
  unsigned int mant; // edx
  __int32 exp; // ecx
  unsigned int v4; // ebp
  unsigned int v5; // esi
  unsigned int v6; // edx
  unsigned int v7; // ebp
  unsigned int v8; // esi
  unsigned int v9; // edx
  unsigned int v10; // ebp
  int v11; // esi
  unsigned int v12; // edx
  int v13; // ebp
  int v14; // esi

  mant = f->mant;
  if ( HIDWORD(f->mant) != 0 || LODWORD(f->mant) != 0 )
  {
    if ( HIDWORD(f->mant) )
    {
      v4 = f->mant;
      mant = HIDWORD(f->mant);
      exp = f->exp;
    }
    else
    {
      exp = f->exp - 32;
      v4 = 0;
    }
    v5 = mant;
    if ( HIWORD(mant) )
    {
      v6 = v4;
    }
    else
    {
      v5 = HIWORD(v4) | (mant << 16);
      v6 = v4 << 16;
      exp -= 16;
    }
    v7 = v5;
    if ( HIBYTE(v5) )
    {
      v8 = v6;
    }
    else
    {
      v7 = HIBYTE(v6) | (v5 << 8);
      v8 = v6 << 8;
      exp -= 8;
    }
    v9 = v7;
    if ( v7 >> 28 )
    {
      v10 = v8;
    }
    else
    {
      v9 = (v8 >> 28) | (16 * v7);
      v10 = 16 * v8;
      exp -= 4;
    }
    v11 = v9;
    if ( v9 >> 30 )
    {
      v12 = v10;
    }
    else
    {
      v11 = (v10 >> 30) | (4 * v9);
      v12 = 4 * v10;
      exp -= 2;
    }
    v13 = v11;
    if ( v11 < 0 )
    {
      v14 = v12;
    }
    else
    {
      v13 = (v12 >> 31) | (2 * v11);
      v14 = 2 * v12;
      --exp;
    }
    LODWORD(f->mant) = v14;
    HIDWORD(f->mant) = v13;
    f->exp = exp;
  }
}

//----- (08094990) --------------------------------------------------------
void __golang strconv___ptr_extFloat__Multiply(strconv_extFloat_0 *f, strconv_extFloat_0 g)
{
  unsigned int mant_high; // ebp
  __int64 v3; // rax
  unsigned __int64 v4; // rdi
  unsigned __int64 cross2_lo; // [esp+0h] [ebp-18h]
  unsigned int v6; // [esp+10h] [ebp-8h]

  mant_high = HIDWORD(f->mant);
  cross2_lo = HIDWORD(g.mant) * (unsigned __int64)LODWORD(f->mant);
  v6 = (g.mant * mant_high) >> 32;
  LODWORD(v3) = (g.mant * f->mant) >> 32;
  HIDWORD(v3) = (((LODWORD(g.mant) * (unsigned __int64)LODWORD(f->mant)) >> 32)
               + LODWORD(g.mant) * mant_high
               + (unsigned __int64)(unsigned int)cross2_lo) >> 32;
  v4 = ((LODWORD(g.mant) * (unsigned __int64)mant_high) >> 32) + HIDWORD(g.mant) * (unsigned __int64)mant_high;
  LODWORD(v4) = HIDWORD(cross2_lo);
  HIDWORD(v4) = (v4 + v6) >> 32;
  HIDWORD(f->mant) = HIDWORD(v4);
  f->mant = HIDWORD(cross2_lo) + v6 + __PAIR64__(HIDWORD(v4), (unsigned __int64)(v3 + 0x80000000LL) >> 32);
  f->exp += g.exp + 64;
}

//----- (08094A70) --------------------------------------------------------
void __golang strconv___ptr_extFloat__frexp10(strconv_extFloat_0 *f, __int32 exp10, __int32 index)
{
  __int32 v3; // edx
  unsigned int i; // edx
  unsigned int v5; // eax
  unsigned int v6; // edx
  __int32 v7; // edi
  unsigned int v8; // eax
  strconv_extFloat_0 g; // [esp+4h] [ebp-14h]

  v3 = ((int)((0xFFFFFFECBB2ECBACLL * (f->exp + 46)) >> 32) >> 6) - ((-28 * (f->exp + 46)) >> 31);
  for ( i = (int)(((unsigned int)((v3 + 348) >> 31) >> 29) + v3 + 348) >> 3; ; i = v8 )
  {
    if ( i >= 0x57 )
      runtime_panicindex();
    v5 = i;
    v6 = i;
    v7 = f->exp + strconv_powersOfTen[v6].exp + 64;
    if ( v7 < -60 )
    {
      v8 = v5 + 1;
      continue;
    }
    if ( v7 <= -32 )
      break;
    v8 = v5 - 1;
  }
  g.mant = strconv_powersOfTen[v6].mant;
  g.exp = strconv_powersOfTen[v6].exp;
  g.neg = strconv_powersOfTen[v6].neg;
  strconv___ptr_extFloat__Multiply(f, g);
}
// 8094B10: variable 'g' is possibly undefined

//----- (08094B50) --------------------------------------------------------
void __golang strconv_frexp10Many(strconv_extFloat_0 *a, strconv_extFloat_0 *b, strconv_extFloat_0 *c, __int32 exp10)
{
  __int32 exp; // edx
  bool neg; // bl
  strconv_extFloat_0 g; // [esp+4h] [ebp-18h]
  int mant_high; // [esp+14h] [ebp-8h]

  strconv___ptr_extFloat__frexp10(c, g.mant, SHIDWORD(g.mant));
  if ( HIDWORD(g.mant) >= 0x57 )
    runtime_panicindex();
  mant_high = HIDWORD(g.mant);
  exp = strconv_powersOfTen[HIDWORD(g.mant)].exp;
  neg = strconv_powersOfTen[HIDWORD(g.mant)].neg;
  g.mant = strconv_powersOfTen[HIDWORD(g.mant)].mant;
  g.exp = exp;
  g.neg = neg;
  strconv___ptr_extFloat__Multiply(a, g);
  strconv___ptr_extFloat__Multiply(b, strconv_powersOfTen[mant_high]);
}
// 8094B70: variable 'g' is possibly undefined

//----- (08094C20) --------------------------------------------------------
bool __golang strconv___ptr_extFloat__FixedDecimal(strconv_extFloat_0 *f, strconv_decimalSlice *d, __int32 n)
{
  __int64 v3; // kr00_8
  int v4; // eax
  unsigned __int64 v5; // kr18_8
  unsigned int v6; // edx
  int v7; // esi
  unsigned int v8; // esi
  uint64 *v9; // ebx
  strconv_decimalSlice *v10; // ebp
  unsigned int v11; // ebx
  int v12; // esi
  unsigned int v13; // edx
  int v14; // eax
  char v15; // di
  char v16; // di
  strconv_decimalSlice *v17; // edx
  int v18; // ecx
  unsigned int v19; // edi
  unsigned __int32 v20; // eax
  unsigned __int32 v21; // eax
  __int32 v22; // et2
  strconv_decimalSlice *v23; // ecx
  int v24; // ebx
  char v25; // bp
  unsigned int v26; // esi
  unsigned int v27; // esi
  unsigned int v28; // edx
  int v29; // eax
  unsigned int v30; // ebx
  __int32 i; // ecx
  interface_{} e; // [esp+0h] [ebp-C8h]
  interface_{} ea; // [esp+0h] [ebp-C8h]
  uint e_4; // [esp+4h] [ebp-C4h]
  __int32 e_4b; // [esp+4h] [ebp-C4h]
  int e_4a; // [esp+4h] [ebp-C4h]
  uint64 e_4c; // [esp+4h] [ebp-C4h]
  __int32 v38; // [esp+8h] [ebp-C0h]
  __int64 __lo; // [esp+24h] [ebp-A4h]
  uint32 rest; // [esp+2Ch] [ebp-9Ch]
  uint64 pow10_lo; // [esp+30h] [ebp-98h]
  __int64 pow_lo; // [esp+38h] [ebp-90h]
  __int32 integerDigits; // [esp+48h] [ebp-80h]
  unsigned __int64 fraction_lo; // [esp+4Ch] [ebp-7Ch]
  __int64 fraction_loa; // [esp+4Ch] [ebp-7Ch]
  int v46; // [esp+5Ch] [ebp-6Ch]
  unsigned int v47; // [esp+60h] [ebp-68h]
  int v48; // [esp+64h] [ebp-64h]
  int v49; // [esp+68h] [ebp-60h]
  __int32 v50; // [esp+6Ch] [ebp-5Ch]
  unsigned int mant_high; // [esp+74h] [ebp-54h]
  char v52; // [esp+78h] [ebp-50h]
  __int32 shift; // [esp+7Ch] [ebp-4Ch]
  strconv_decimalSlice *v54[10]; // [esp+80h] [ebp-48h] BYREF
  uint8 buf[32]; // [esp+A8h] [ebp-20h] BYREF

  while ( (unsigned int)v54 <= *(_DWORD *)(*(_DWORD *)(__readgsdword(0) - 4) + 8) )
    runtime_morestack_noctxt();
  if ( LODWORD(f->mant) == 0 && HIDWORD(f->mant) == 0 )
  {
    d->nd = 0;
    d->dp = 0;
    d->neg = f->neg;
    return 1;
  }
  else
  {
    if ( !n )
    {
      ea._type = (runtime__type_0 *)&t;
      ea.data = &strconv_statictmp_1;
      runtime_gopanic(ea);
      BUG();
    }
    strconv___ptr_extFloat__Normalize(f, e_4);
    strconv___ptr_extFloat__frexp10(f, e_4b, v38);
    shift = -f->exp;
    mant_high = HIDWORD(f->mant);
    v3 = (unsigned int)shift - 32LL;
    v50 = f->exp + 32;
    v49 = -(f->exp >= 0xFFFFFFE0);
    v48 = -((unsigned int)(shift - 32) < 0x20);
    v47 = v48 & (mant_high >> (-LOBYTE(f->exp) - 32)) | HIDWORD(v3) & (LODWORD(f->mant) >> -LOBYTE(f->exp)) | v49 & (mant_high << (LOBYTE(f->exp) + 32));
    v4 = (__PAIR64__(mant_high, f->mant)
        - __PAIR64__(
            ((unsigned int)(32 - shift) < 0x20 ? (v48 & (mant_high >> (shift - 32)) | HIDWORD(v3) & (LODWORD(f->mant) >> shift) | v49 & (mant_high << (32 - shift))) >> (32 - shift) : 0) | v48 & ((v48 & (mant_high >> (shift - 32)) | HIDWORD(v3) & (LODWORD(f->mant) >> shift) | v49 & (mant_high << (32 - shift))) << (shift - 32)),
            HIDWORD(v3) & (v47 << shift))) >> 32;
    v5 = __PAIR64__(mant_high, f->mant)
       - __PAIR64__(
           ((unsigned int)(32 - shift) < 0x20 ? (v48 & (mant_high >> (shift - 32)) | HIDWORD(v3) & (LODWORD(f->mant) >> shift) | v49 & (mant_high << (32 - shift))) >> (32 - shift) : 0) | v48 & ((v48 & (mant_high >> (shift - 32)) | HIDWORD(v3) & (LODWORD(f->mant) >> shift) | v49 & (mant_high << (32 - shift))) << (shift - 32)),
           HIDWORD(v3) & (v47 << shift));
    v54[8] = (strconv_decimalSlice *)HIDWORD(v5);
    LODWORD(fraction_lo) = v5;
    v6 = v47;
    v7 = 0;
    v54[6] = (strconv_decimalSlice *)-((unsigned int)(32 - shift) < 0x20);
    pow_lo = 1LL;
    while ( v7 < 20 )
    {
      if ( HIDWORD(pow_lo) != 0 || HIDWORD(pow_lo) == 0 && (unsigned int)pow_lo > v6 )
        goto LABEL_8;
      ++v7;
      v6 = v47;
      pow_lo *= 10LL;
    }
    v7 = 0;
LABEL_8:
    v46 = v4;
    integerDigits = v7;
    if ( v7 <= n )
    {
      v10 = 0;
      v11 = 1;
      v12 = 0;
    }
    else
    {
      v8 = v7 - n;
      if ( v8 >= 0x14 )
        runtime_panicindex();
      v9 = &strconv_uint64pow10[v8];
      v10 = (strconv_decimalSlice *)*((_DWORD *)v9 + 1);
      v11 = *(_DWORD *)v9;
      if ( !v11 )
        runtime_panicdivide();
      v12 = v47 % v11;
    }
    v52 = shift - 32;
    LODWORD(pow10_lo) = v11;
    ((void (*)(void))loc_808FD88)();
    v14 = 32;
    while ( v13 )
    {
      v15 = v13;
      v13 /= 0xAu;
      v16 = v15 - 10 * v13;
      if ( (unsigned int)(v14 - 1) >= 0x20 )
        runtime_panicindex();
      buf[--v14] = v16 + 48;
    }
    HIDWORD(pow10_lo) = v10;
    rest = v12;
    v17 = d;
    v18 = v14;
    while ( v14 < 32 )
    {
      v19 = v14;
      v20 = v14 - v18;
      if ( v19 >= 0x20 || v20 >= d->d.len )
        runtime_panicindex();
      d->d.array[v20] = buf[v19];
      v14 = v19 + 1;
      v10 = (strconv_decimalSlice *)HIDWORD(pow10_lo);
      v12 = rest;
    }
    d->nd = 32 - v18;
    v21 = 32 - v18;
    d->dp = e_4a + integerDigits;
    if ( v18 + n - 32 <= 0 )
    {
      v25 = shift - 32;
      v29 = 1;
      v30 = 0;
      HIDWORD(fraction_lo) = v46;
    }
    else
    {
      if ( v12 || (v22 = v18 + n - 32, v23 = v10, v24 = v22, (_DWORD)pow10_lo != 1 || v10 != 0) )
      {
        e._type = (runtime__type_0 *)&t;
        e.data = &strconv_statictmp_2;
        runtime_gopanic(e);
        BUG();
      }
      v25 = shift - 32;
      v54[4] = (strconv_decimalSlice *)v21;
      HIDWORD(fraction_lo) = v46;
      v54[2] = v23;
      __lo = 1LL;
      v54[0] = d;
      while ( v24 > 0 )
      {
        fraction_loa = 10 * fraction_lo;
        __lo *= 10LL;
        v27 = v49 & (1u >> v50) | v3 & (1 << v25);
        if ( (unsigned int)(__lo >> 31) > v27
          || (unsigned int)(__lo >> 31) == v27 && 2 * (int)__lo > (HIDWORD(v3) & (unsigned int)(1 << shift)) )
        {
          return 0;
        }
        v28 = HIDWORD(v3) & ((unsigned int)fraction_loa >> shift) | v49 & (HIDWORD(fraction_loa) << v50) | v48 & (HIDWORD(fraction_loa) >> v52);
        if ( v21 >= d->d.len )
          runtime_panicindex();
        v26 = HIDWORD(v3) & ((unsigned int)fraction_loa >> shift) | v49 & (HIDWORD(fraction_loa) << v50) | v48 & (HIDWORD(fraction_loa) >> v52);
        d->d.array[v21] = v28 + 48;
        --v24;
        fraction_lo = fraction_loa
                    - __PAIR64__(
                        v48 & (v26 << v52) | v49 & (v26 >> v50) | HIDWORD(v3) & ((HIDWORD(v3) & (HIDWORD(fraction_loa) >> shift)) << SBYTE4(pow10_lo)),
                        HIDWORD(v3) & (v28 << shift));
        ++v21;
        v17 = d;
        v25 = shift - 32;
        v12 = rest;
      }
      v17->nd = v21;
      v30 = HIDWORD(__lo);
      v29 = __lo;
    }
    LODWORD(e_4c) = HIDWORD(v3) & (v12 << shift) | fraction_lo;
    HIDWORD(e_4c) = HIDWORD(fraction_lo) | v49 & (rest >> v50) | v3 & (rest << v25);
    if ( strconv_adjustLastDigitFixed(v17, e_4c, pow10_lo, shift, __PAIR64__(v30, v29)) )
    {
      for ( i = d->nd - 1; i >= 0; --i )
      {
        if ( (unsigned int)i >= d->d.len )
          runtime_panicindex();
        if ( d->d.array[i] != 48 )
        {
          d->nd = i + 1;
          return 1;
        }
      }
      return 1;
    }
    else
    {
      return 0;
    }
  }
}
// 8094C72: variable 'e_4' is possibly undefined
// 8094C81: variable 'e_4b' is possibly undefined
// 8094C81: variable 'v38' is possibly undefined
// 8094E36: variable 'v13' is possibly undefined
// 8094EC2: variable 'e_4a' is possibly undefined

//----- (08095280) --------------------------------------------------------
bool __golang strconv_adjustLastDigitFixed(strconv_decimalSlice *d, uint64 num, uint64 den, uint shift, uint64 _)
{
  unsigned int v5; // eax
  unsigned int v6; // edx
  bool v7; // zf
  unsigned int v8; // eax
  __int32 i; // ecx
  bool v10; // sf
  interface_{} e; // [esp+0h] [ebp-Ch]
  interface_{} ea; // [esp+0h] [ebp-Ch]

  v5 = shift < 0x20 ? (_DWORD)den << shift : 0;
  v6 = (shift - 32 < 0x20 ? (_DWORD)den << (shift - 32) : 0) | (shift < 0x20 ? HIDWORD(den) << shift : 0) | (32 - shift < 0x20 ? (unsigned int)den >> (32 - shift) : 0);
  if ( (unsigned int)num > v5 && HIDWORD(num) == v6 || HIDWORD(num) > v6 )
  {
    ea._type = (runtime__type_0 *)&t;
    ea.data = &strconv_statictmp_3;
    runtime_gopanic(ea);
    BUG();
  }
  v7 = (unsigned int)((__int64)_ >> 31) <= v6 && ((unsigned int)((__int64)_ >> 31) != v6 || 2 * (int)_ <= v5);
  v8 = shift < 0x20 ? (_DWORD)den << shift : 0;
  if ( !v7 )
  {
    e._type = (runtime__type_0 *)&t;
    e.data = &strconv_statictmp_4;
    runtime_gopanic(e);
    BUG();
  }
  if ( (unsigned int)((__int64)(_ + num) >> 31) < v6
    || 2 * ((int)_ + (int)num) < v8 && (unsigned int)((__int64)(_ + num) >> 31) == v6 )
  {
    return 1;
  }
  if ( (unsigned int)((__int64)(num - _) >> 31) <= v6
    && ((unsigned int)((__int64)(num - _) >> 31) != v6 || 2 * ((int)num - (int)_) <= v8) )
  {
    return 0;
  }
  for ( i = d->nd - 1; ; --i )
  {
    v10 = i < 0;
    if ( i < 0 )
      break;
    if ( (unsigned int)i >= d->d.len )
      runtime_panicindex();
    if ( d->d.array[i] != 57 )
    {
      v10 = i < 0;
      break;
    }
    --d->nd;
  }
  if ( v10 )
  {
    if ( !d->d.len )
      runtime_panicindex();
    *d->d.array = 49;
    d->nd = 1;
    ++d->dp;
  }
  else
  {
    if ( (unsigned int)i >= d->d.len )
      runtime_panicindex();
    ++d->d.array[i];
  }
  return 1;
}

//----- (08095480) --------------------------------------------------------
bool __golang strconv___ptr_extFloat__ShortestDecimal(
        strconv_extFloat_0 *f,
        strconv_decimalSlice *d,
        strconv_extFloat_0 *lower,
        strconv_extFloat_0 *upper)
{
  int mant_high; // ecx
  bool neg; // bl
  strconv_extFloat_0 *v6; // esi
  strconv_extFloat_0 *v7; // ecx
  unsigned int mant; // edx
  unsigned int v9; // ebx
  int j; // eax
  unsigned int v11; // et0
  bool v12; // t1
  strconv_extFloat_0 *v13; // ebx
  bool v14; // bp
  unsigned int v15; // ebx
  strconv_extFloat_0 *v16; // et1
  __int32 v17; // edx
  strconv_decimalSlice *v18; // ebx
  __int32 k; // ebp
  int nd; // eax
  bool v21; // zf
  __int32 exp; // ecx
  __int32 v23; // ebx
  int v24; // esi
  unsigned int v25; // ecx
  unsigned int v26; // ebx
  int v27; // edi
  __int32 v28; // ecx
  __int32 v29; // ebp
  int v30; // esi
  unsigned int v31; // ecx
  unsigned int v32; // ebp
  int v33; // eax
  strconv_extFloat_0 *v34; // eax
  bool v35; // cf
  int v36; // ebp
  int v37; // eax
  unsigned int v38; // ebp
  int v39; // ecx
  unsigned int v40; // edx
  __int32 v41; // ebp
  unsigned int v42; // esi
  int v43; // edx
  char v44; // si
  __int32 v45; // ebp
  uint64 *v46; // ebp
  uint32 v47; // edx
  uint32 v48; // ebp
  uint8 *array; // edi
  char v50; // dl
  uint32 v51; // ebp
  uint32 v52; // edi
  char v53; // cl
  unsigned int v54; // edi
  unsigned int v55; // edx
  int v56; // edi
  __int64 v57; // rax
  unsigned int v58; // ebx
  unsigned __int32 v59; // ebp
  int v60; // edi
  int v61; // ebx
  unsigned __int64 v62; // rax
  unsigned int v63; // ebx
  uint currentDiff_4; // [esp+4h] [ebp-ECh]
  __int32 targetDiff_4; // [esp+Ch] [ebp-E4h]
  int targetDiff_4a; // [esp+Ch] [ebp-E4h]
  uint64 targetDiff_8; // [esp+10h] [ebp-E0h]
  uint64 ulpDecimal; // [esp+1Ch] [ebp-D4h]
  uint64 ulpDecimala; // [esp+1Ch] [ebp-D4h]
  char v_lo; // [esp+34h] [ebp-BCh]
  uint32 targetDiff_lo; // [esp+38h] [ebp-B8h]
  uint32 pow_lo; // [esp+3Ch] [ebp-B4h]
  uint32 pow_hi; // [esp+40h] [ebp-B0h]
  uint32 pow_hi_0; // [esp+44h] [ebp-ACh]
  unsigned __int32 n; // [esp+48h] [ebp-A8h]
  __int64 multiplier_lo; // [esp+4Ch] [ebp-A4h]
  __int32 integerDigits; // [esp+54h] [ebp-9Ch]
  uint32 integer; // [esp+58h] [ebp-98h]
  __int32 i; // [esp+5Ch] [ebp-94h]
  unsigned __int64 fraction_lo; // [esp+60h] [ebp-90h]
  __int64 fraction_loa; // [esp+60h] [ebp-90h]
  uint32 currentDiff_lo; // [esp+6Ch] [ebp-84h]
  uint32 allowance_lo; // [esp+70h] [ebp-80h]
  unsigned int v84; // [esp+74h] [ebp-7Ch]
  int v85; // [esp+78h] [ebp-78h]
  unsigned int v86; // [esp+7Ch] [ebp-74h]
  int v87; // [esp+80h] [ebp-70h] BYREF
  int v88; // [esp+84h] [ebp-6Ch]
  int v89; // [esp+88h] [ebp-68h]
  int v90; // [esp+8Ch] [ebp-64h]
  unsigned int v91; // [esp+90h] [ebp-60h]
  unsigned int v92; // [esp+94h] [ebp-5Ch]
  unsigned int v93; // [esp+98h] [ebp-58h]
  unsigned __int32 v94; // [esp+9Ch] [ebp-54h]
  unsigned int v95; // [esp+A0h] [ebp-50h]
  int v96; // [esp+A4h] [ebp-4Ch]
  int v97; // [esp+ACh] [ebp-44h]
  int v98; // [esp+B4h] [ebp-3Ch]
  unsigned __int32 v99; // [esp+BCh] [ebp-34h]
  unsigned int v100; // [esp+C4h] [ebp-2Ch]
  int v101; // [esp+CCh] [ebp-24h]
  uint8 buf[24]; // [esp+D4h] [ebp-1Ch] BYREF
  uint8 *v103; // [esp+ECh] [ebp-4h]

  while ( (unsigned int)&v87 <= *(_DWORD *)(*(_DWORD *)(__readgsdword(0) - 4) + 8) )
    runtime_morestack_noctxt();
  if ( LODWORD(f->mant) == 0 && HIDWORD(f->mant) == 0 )
  {
    d->nd = 0;
    d->dp = 0;
    d->neg = f->neg;
    return 1;
  }
  if ( f->exp )
  {
    v6 = upper;
  }
  else
  {
    mant_high = HIDWORD(lower->mant);
    if ( LODWORD(lower->mant) == LODWORD(f->mant) && mant_high == HIDWORD(f->mant) )
    {
      if ( lower->exp )
      {
        v6 = upper;
      }
      else
      {
        neg = lower->neg;
        if ( f->neg == neg )
        {
          v6 = upper;
          if ( LODWORD(upper->mant) == LODWORD(lower->mant)
            && HIDWORD(upper->mant) == mant_high
            && !upper->exp
            && upper->neg == neg )
          {
            ((void (*)(void))loc_808FD8A)();
            v7 = f;
            mant = f->mant;
            v9 = HIDWORD(f->mant);
            for ( j = 23; ; j = n - 1 )
            {
              v11 = v9;
              v12 = v9 == 0;
              v13 = v6;
              v14 = mant != 0 && v12;
              LOBYTE(v13) = v11 != 0;
              v16 = v13;
              v15 = v11;
              v6 = v16;
              if ( !((unsigned __int8)v16 | v14) )
                break;
              v_lo = mant;
              n = j;
              targetDiff_8 = runtime_uint64div(__PAIR64__(v15, mant), 0xAuLL);
              if ( n >= 0x18 )
                runtime_panicindex();
              buf[n] = v_lo - 10 * targetDiff_8 + 48;
              v7 = f;
              v9 = HIDWORD(targetDiff_8);
              mant = targetDiff_8;
            }
            v17 = 23 - j;
            v18 = d;
            for ( k = 0; k < v17; ++k )
            {
              if ( (unsigned int)(j + k + 1) >= 0x18 || (unsigned int)k >= v18->d.len )
                runtime_panicindex();
              v18->d.array[k] = buf[j + 1 + k];
              v7 = f;
              v18 = d;
            }
            v18->nd = v17;
            v18->dp = v17;
            while ( 1 )
            {
              nd = v18->nd;
              v21 = nd == 0;
              if ( nd <= 0 )
                break;
              if ( (unsigned int)(nd - 1) >= v18->d.len )
                runtime_panicindex();
              if ( v18->d.array[nd - 1] != 48 )
              {
                v21 = nd == 0;
                break;
              }
              v18->nd = nd - 1;
            }
            if ( v21 )
              v18->dp = 0;
            v18->neg = v7->neg;
            return 1;
          }
        }
        else
        {
          v6 = upper;
        }
      }
    }
    else
    {
      v6 = upper;
    }
  }
  strconv___ptr_extFloat__Normalize(v6, currentDiff_4);
  exp = f->exp;
  v23 = upper->exp;
  if ( exp > v23 )
  {
    v95 = f->mant;
    v24 = HIDWORD(f->mant);
    v25 = exp - v23;
    v94 = v25;
    v26 = v95;
    v27 = -(v25 < 0x20);
    LODWORD(f->mant) = v27 & (v95 << v25);
    v93 = v25 - 32;
    HIDWORD(f->mant) = (32 - v25 < 0x20 ? v26 >> (32 - v25) : 0) | v27 & (v24 << v94) | (v25 - 32 < 0x20 ? v95 << (v25 - 32) : 0);
    f->exp = upper->exp;
  }
  v28 = lower->exp;
  v29 = upper->exp;
  if ( v28 <= v29 )
  {
    v34 = upper;
  }
  else
  {
    v30 = HIDWORD(lower->mant);
    v95 = lower->mant;
    v31 = v28 - v29;
    v94 = v31;
    v32 = v95;
    v33 = -(v31 < 0x20);
    LODWORD(lower->mant) = v33 & (v95 << v31);
    v93 = 32 - v31;
    HIDWORD(lower->mant) = v33 & (v30 << v94) | (32 - v31 < 0x20 ? v95 >> (32 - v31) : 0) | (v31 - 32 < 0x20 ? v32 << (v31 - 32) : 0);
    v34 = upper;
    lower->exp = upper->exp;
  }
  strconv_frexp10Many(lower, f, v34, targetDiff_4);
  ++upper->mant;
  v35 = LODWORD(lower->mant) != 0;
  v95 = LODWORD(lower->mant) - 1;
  v36 = HIDWORD(lower->mant);
  LODWORD(lower->mant) = v95;
  v92 = v35 + v36 - 1;
  HIDWORD(lower->mant) = v92;
  v94 = -upper->exp;
  v93 = HIDWORD(upper->mant);
  v91 = upper->mant;
  v90 = v94 - 32;
  v89 = 32 - v94;
  v88 = -(v94 < 0x20);
  v87 = -(32 - v94 < 0x20);
  v37 = -(v94 - 32 < 0x20);
  v86 = v88 & (v91 >> v94) | v87 & (v93 << (32 - v94)) | v37 & (v93 >> (v94 - 32));
  v85 = (__PAIR64__(v93, v91) - __PAIR64__(v87 & (v86 >> (32 - v94)) | v37 & (v86 << (v94 - 32)), v88 & (v86 << v94))) >> 32;
  LODWORD(fraction_lo) = v91 - (v88 & (v86 << v94));
  allowance_lo = v91 - v95;
  v38 = f->mant;
  targetDiff_lo = v91 - LODWORD(f->mant);
  v39 = v94 - 32;
  v92 = (__PAIR64__(v93, v91) - __PAIR64__(v92, v95)) >> 32;
  v84 = (__PAIR64__(v93, v91) - __PAIR64__(HIDWORD(f->mant), v38)) >> 32;
  v40 = v86;
  v41 = 0;
  v42 = 1;
  v101 = v37;
  pow_hi_0 = 0;
  while ( v41 < 20 )
  {
    if ( pow_hi_0 != 0 || pow_hi_0 == 0 && v42 > v40 )
      goto LABEL_38;
    ++v41;
    pow_hi_0 = (10 * __PAIR64__(pow_hi_0, v42)) >> 32;
    v42 *= 10;
    v40 = v86;
  }
  v41 = 0;
LABEL_38:
  v95 = -(v94 - 32 < 0x20);
  integerDigits = v41;
  v43 = v89;
  v44 = v94;
  v100 = v95;
  i = 0;
  v99 = v94 - 32;
  integer = v86;
  while ( i < v41 )
  {
    v45 = v41 - i;
    if ( (unsigned int)(v45 - 1) >= 0x14 )
      runtime_panicindex();
    v46 = &strconv_uint64pow10[v45 - 1];
    v47 = *((_DWORD *)v46 + 1);
    v48 = *(_DWORD *)v46;
    if ( !v48 )
      runtime_panicdivide();
    pow_hi = v47;
    array = d->d.array;
    if ( (unsigned int)i >= d->d.len )
      runtime_panicindex();
    pow_lo = v48;
    v50 = integer / v48;
    integer %= v48;
    v93 = v88 & (integer << v44);
    v51 = fraction_lo + v93;
    currentDiff_lo = fraction_lo + v93;
    array[i] = v50 + 48;
    v52 = integer << v39;
    v53 = v89;
    v54 = v85 + __CFADD__((_DWORD)fraction_lo, v93) + (v87 & (integer >> v89) | v95 & v52);
    v55 = v92;
    if ( v54 < v92 || v54 == v92 && v51 < allowance_lo )
    {
      d->nd = i + 1;
      d->dp = targetDiff_4a + integerDigits;
      d->neg = f->neg;
      LODWORD(ulpDecimal) = v88 & (pow_lo << v94);
      HIDWORD(ulpDecimal) = v88 & (pow_hi << v94) | v87 & (pow_lo >> v53) | v95 & (pow_lo << v90);
      return strconv_adjustLastDigit(
               d,
               __PAIR64__(v54, currentDiff_lo),
               __PAIR64__(v84, targetDiff_lo),
               __PAIR64__(v55, allowance_lo),
               ulpDecimal,
               2uLL);
    }
    v37 = v95;
    v39 = v90;
    v43 = v89;
    v41 = integerDigits;
    v44 = v94;
    ++i;
  }
  d->nd = v41;
  d->dp = targetDiff_4a + v41;
  d->neg = f->neg;
  v56 = v87;
  v98 = v37;
  HIDWORD(fraction_lo) = v85;
  v97 = v39;
  v96 = v43;
  multiplier_lo = 1LL;
  while ( 1 )
  {
    v93 = (10 * (unsigned __int64)(unsigned int)fraction_lo) >> 32;
    fraction_loa = 10 * fraction_lo;
    v57 = 10 * multiplier_lo;
    HIDWORD(multiplier_lo) = (unsigned __int64)(10 * multiplier_lo) >> 32;
    v58 = v88 & ((unsigned int)fraction_loa >> v44) | v56 & (HIDWORD(fraction_loa) << v89) | v95 & (HIDWORD(fraction_loa) >> v39);
    v59 = d->nd;
    if ( v59 >= d->d.len )
      runtime_panicindex();
    v103 = d->d.array;
    LODWORD(multiplier_lo) = v57;
    v93 = v88 & ((unsigned int)fraction_loa >> v44) | v56 & (HIDWORD(fraction_loa) << v89) | v95 & (HIDWORD(fraction_loa) >> v39);
    v60 = v93;
    v61 = v88 & (v58 << v44);
    v91 = fraction_loa - v61;
    v62 = allowance_lo * (unsigned __int64)(unsigned int)v57;
    v103[v59] = v93 + 48;
    ++d->nd;
    v63 = (fraction_loa - __PAIR64__(v95 & (v60 << v90) | v87 & (v93 >> v89) | v88 & (v60 >> 31 << v44), v61)) >> 32;
    if ( (v63 < (__PAIR64__(v92, allowance_lo) * multiplier_lo) >> 32) | (v63 == (__PAIR64__(v92, allowance_lo)
                                                                                * multiplier_lo) >> 32
                                                                       && v91 < (unsigned int)v62) )
      break;
    v56 = v87;
    fraction_lo = __PAIR64__(v63, v91);
    LOBYTE(v39) = v90;
  }
  v93 = multiplier_lo * v92 + HIDWORD(v62) + HIDWORD(multiplier_lo) * allowance_lo;
  LODWORD(ulpDecimala) = v88 & (1 << v44);
  HIDWORD(ulpDecimala) = v87 & (1u >> v89) | v95 & (1 << v90);
  return strconv_adjustLastDigit(
           d,
           __PAIR64__(v63, v91),
           multiplier_lo * __PAIR64__(v84, targetDiff_lo),
           __PAIR64__(v93, v62),
           ulpDecimala,
           2 * multiplier_lo);
}
// 80956A5: variable 'currentDiff_4' is possibly undefined
// 80957C4: variable 'targetDiff_4' is possibly undefined
// 8095B54: variable 'targetDiff_4a' is possibly undefined

//----- (08095FB0) --------------------------------------------------------
bool __golang strconv_adjustLastDigit(
        strconv_decimalSlice *d,
        uint64 currentDiff,
        uint64 targetDiff,
        uint64 maxDiff,
        uint64 ulpDecimal,
        uint64 ulpBinary)
{
  unsigned int v6; // ecx
  int v7; // eax
  unsigned int v8; // edi
  unsigned int v9; // edx
  unsigned int v10; // ebx
  __int32 nd; // eax
  uint64 v12; // kr00_8
  int v13; // [esp+Ch] [ebp-4h]

  v6 = HIDWORD(ulpBinary);
  v7 = HIDWORD(ulpDecimal);
  v8 = ulpDecimal;
  if ( HIDWORD(ulpDecimal) == (unsigned int)((__int64)ulpBinary >> 31) && (unsigned int)ulpDecimal < 2 * (int)ulpBinary
    || HIDWORD(ulpDecimal) < (unsigned int)((__int64)ulpBinary >> 31) )
  {
    return 0;
  }
  v9 = HIDWORD(targetDiff);
  v10 = targetDiff;
  while ( 1 )
  {
    v13 = (v8 >> 1) | (v7 << 31);
    if ( !(((__PAIR64__(v6, ulpBinary) + currentDiff + __PAIR64__(HIDWORD(ulpDecimal) >> 1, v13)) >> 32 < v9) | ((__PAIR64__(v6, ulpBinary) + currentDiff + __PAIR64__(HIDWORD(ulpDecimal) >> 1, v13)) >> 32 == v9 && (int)ulpBinary + (int)currentDiff + v13 < v10)) )
      break;
    nd = d->nd;
    if ( (unsigned int)(nd - 1) >= d->d.len )
      runtime_panicindex();
    --d->d.array[nd - 1];
    v9 = HIDWORD(targetDiff);
    v6 = HIDWORD(ulpBinary);
    v10 = targetDiff;
    currentDiff += ulpDecimal;
    v7 = HIDWORD(ulpDecimal);
    v8 = ulpDecimal;
  }
  v12 = ulpBinary + __PAIR64__((HIDWORD(ulpDecimal) >> 1) + __CFADD__(v10, v13) + v9, v10 + v13);
  if ( (ulpDecimal + currentDiff) >> 32 < HIDWORD(v12)
    || (ulpDecimal + currentDiff) >> 32 == HIDWORD(v12) && (int)ulpDecimal + (int)currentDiff <= (unsigned int)v12 )
  {
    return 0;
  }
  if ( HIDWORD(currentDiff) < HIDWORD(ulpBinary)
    || HIDWORD(currentDiff) == HIDWORD(ulpBinary) && (unsigned int)currentDiff < (unsigned int)ulpBinary
    || HIDWORD(currentDiff) > (maxDiff - ulpBinary) >> 32
    || (unsigned int)currentDiff > (int)maxDiff - (int)ulpBinary && HIDWORD(currentDiff) == (maxDiff - ulpBinary) >> 32 )
  {
    return 0;
  }
  if ( d->nd == 1 )
  {
    if ( !d->d.len )
      runtime_panicindex();
    if ( *d->d.array == 48 )
    {
      d->nd = 0;
      d->dp = 0;
    }
  }
  return 1;
}

//----- (080961D0) --------------------------------------------------------
__uint8 __golang strconv_AppendFloat(__uint8 dst, float64 f, uint8 fmt, __int32 prec, __int32 bitSize)
{
  return strconv_genericFtoa(dst, f, fmt, prec, bitSize);
}

//----- (08096250) --------------------------------------------------------
__uint8 __golang strconv_genericFtoa(__uint8 dst, float64 val, uint8 fmt, __int32 prec, __int32 bitSize)
{
  float v5; // xmm0_4
  float v6; // edx
  uint32 v7; // eax
  strconv_floatInfo *v8; // ecx
  strconv_floatInfo_0 *v9; // esi
  uint32 v10; // ebp
  uint32 v11; // edi
  bool v12; // al
  int v13; // ecx
  int v14; // edi
  int v15; // eax
  char *v16; // ecx
  unsigned __int32 v17; // ebx
  unsigned __int32 v18; // ebp
  uint8 *array; // esi
  int v20; // ecx
  unsigned int v21; // edx
  __int32 v22; // ecx
  uint8 v23; // bl
  int v24; // ebp
  __int32 v25; // ecx
  unsigned int v26; // edx
  unsigned int v27; // edi
  bool v28; // dl
  __int32 v29; // ebp
  bool v30; // al
  bool v31; // zf
  __int32 nd; // edx
  interface_{} et; // [esp+0h] [ebp-12Ch]
  bool old_8; // [esp+Ch] [ebp-120h]
  bool cap; // [esp+10h] [ebp-11Ch]
  _BYTE cap_4[36]; // [esp+14h] [ebp-118h]
  runtime_slice_0 cap_4a; // [esp+14h] [ebp-118h]
  __uint8 v38; // [esp+24h] [ebp-108h]
  __uint8 v39; // [esp+24h] [ebp-108h]
  __uint8 v40; // [esp+24h] [ebp-108h]
  __uint8 v41; // [esp+30h] [ebp-FCh]
  bool v42; // [esp+3Fh] [ebp-EDh]
  unsigned __int64 mant_lo; // [esp+44h] [ebp-E8h]
  __int32 exp; // [esp+50h] [ebp-DCh]
  uint32 bits_hi; // [esp+58h] [ebp-D4h]
  __int32 v46; // [esp+60h] [ebp-CCh]
  __int32 v47; // [esp+60h] [ebp-CCh]
  unsigned int expbits; // [esp+74h] [ebp-B8h]
  int v49; // [esp+7Ch] [ebp-B0h]
  uint32 v50; // [esp+80h] [ebp-ACh] BYREF
  unsigned int mantbits; // [esp+84h] [ebp-A8h]
  float64 f_2_0; // [esp+88h] [ebp-A4h]
  strconv_extFloat_0 upper; // [esp+90h] [ebp-9Ch] BYREF
  strconv_extFloat_0 lower; // [esp+A0h] [ebp-8Ch] BYREF
  strconv_extFloat_0 f; // [esp+B0h] [ebp-7Ch] BYREF
  strconv_extFloat_0 v56; // [esp+C0h] [ebp-6Ch] BYREF
  uint8 buf[24]; // [esp+D0h] [ebp-5Ch] BYREF
  uint8 buf_0[32]; // [esp+E8h] [ebp-44h] BYREF
  uint8 *s_ptr; // [esp+108h] [ebp-24h]
  __int32 v60; // [esp+10Ch] [ebp-20h]
  uint8 *v61; // [esp+110h] [ebp-1Ch]
  strconv_decimalSlice_0 digs; // [esp+114h] [ebp-18h] BYREF
  __int32 preca; // [esp+148h] [ebp+1Ch]
  __uint8 _r5; // [esp+150h] [ebp+24h]

  while ( (unsigned int)&v50 <= *(_DWORD *)(*(_DWORD *)(__readgsdword(0) - 4) + 8) )
    runtime_morestack_noctxt();
  if ( bitSize == 32 )
  {
    v5 = val;
    v6 = v5;
    v7 = 0;
    v8 = &strconv_float32info;
  }
  else
  {
    if ( bitSize != 64 )
    {
      et._type = (runtime__type_0 *)&t;
      et.data = &strconv_statictmp_5;
      runtime_gopanic(et);
      BUG();
    }
    f_2_0 = val;
    v7 = HIDWORD(val);
    v6 = *(float *)&val;
    v8 = &strconv_float64info;
  }
  bits_hi = v7;
  mantbits = v8->mantbits;
  v50 = -(mantbits < 0x20);
  v9 = v8;
  v49 = v50 & (1 << mantbits);
  expbits = v8->expbits;
  v10 = v7;
  v11 = v7 >> (mantbits - 32);
  v12 = ((32 - (expbits + mantbits) < 0x20 ? v7 << (32 - (expbits + mantbits)) : 0) | (mantbits + expbits < 0x20 ? LODWORD(v6) >> (mantbits + expbits) : 0) | (expbits + mantbits - 32 < 0x20 ? v7 >> (expbits + mantbits - 32) : 0)) != 0
     || ((v7 >> (mantbits + expbits)) & (((unsigned __int64)(expbits + mantbits) - 32) >> 32)) != 0;
  v50 = (mantbits - 32 < 0x20 ? v11 : 0) | (32 - mantbits < 0x20 ? v10 << (32 - mantbits) : 0) | v50 & (LODWORD(v6) >> mantbits);
  v13 = expbits < 0x20 ? (1 << expbits) + 1 : -1;
  v14 = (v49 - 1) & LODWORD(v6);
  if ( (v50 & v13) != v13 )
  {
    if ( (v13 & v50) != 0 )
    {
      v14 |= v49;
      v21 = (mantbits - 32 < 0x20 ? 1 << (mantbits - 32) : 0) | (32 - mantbits < 0x20 ? 1u >> (32 - mantbits) : 0) | ((__PAIR64__((mantbits - 32 < 0x20 ? 1 << (mantbits - 32) : 0) | (32 - mantbits < 0x20 ? 1u >> (32 - mantbits) : 0), v49) - 1) >> 32) & bits_hi;
      v20 = v50 & (expbits < 0x20 ? (1 << expbits) + 1 : -1);
    }
    else
    {
      v20 = (v50 & v13) + 1;
      v21 = ((__PAIR64__(
                (mantbits - 32 < 0x20 ? 1 << (mantbits - 32) : 0) | (32 - mantbits < 0x20 ? 1u >> (32 - mantbits) : 0),
                v49)
            - 1) >> 32) & bits_hi;
    }
    v22 = v9->bias + v20;
    v23 = fmt;
    if ( fmt == 98 )
      return strconv_fmtB(dst, v12, __PAIR64__(v21, v14), v22, v9);
    if ( !strconv_optimize )
    {
      *(_QWORD *)&v40.len = COERCE_UNSIGNED_INT64(
                              COERCE_LONG_DOUBLE(
                                COERCE_LONG_DOUBLE(
                                  strconv_bigFtoa(
                                    dst,
                                    prec,
                                    fmt,
                                    v14,
                                    __PAIR64__(v22, v21),
                                    (__int32)v9,
                                    *(strconv_floatInfo_0 **)&cap_4[16]))));
      return v40;
    }
    v60 = (__int32)v9;
    v42 = v12;
    exp = v22;
    mant_lo = __PAIR64__(v21, v14);
    v24 = v14;
    ((void (*)(void))loc_808FD8A)();
    v25 = prec;
    v27 = v26;
    v28 = prec < 0;
    if ( prec >= 0 )
    {
      if ( fmt != 102 )
      {
        if ( fmt > 0x47u )
        {
          if ( fmt == 101 )
            goto LABEL_23;
          if ( fmt == 103 )
          {
            v31 = prec == 0;
            goto LABEL_32;
          }
        }
        else
        {
          if ( fmt == 69 )
          {
LABEL_23:
            v29 = prec + 1;
            goto LABEL_24;
          }
          if ( fmt == 71 )
          {
            v31 = prec == 0;
LABEL_32:
            if ( v31 )
              v25 = 1;
            v29 = v25;
            goto LABEL_24;
          }
        }
        v29 = prec;
LABEL_24:
        if ( v29 <= 15 )
        {
          v47 = v25;
          ((void (*)(void))loc_808FD8A)();
          digs.d.array = buf;
          digs.d.len = 24;
          digs.d.cap = 24;
          f.exp = 0;
          f.neg = 0;
          f.mant = mant_lo;
          f.exp = exp - v9->mantbits;
          f.neg = v42;
          v30 = strconv___ptr_extFloat__FixedDecimal(&f, &digs, v29);
          v25 = v47;
          v28 = prec < 0;
          v23 = fmt;
          v9 = (strconv_floatInfo_0 *)v60;
          v27 = HIDWORD(mant_lo);
        }
        else
        {
          v30 = 0;
        }
        goto LABEL_26;
      }
      v30 = 0;
LABEL_26:
      if ( v30 )
      {
        preca = v25;
        old_8 = v28;
        ((void (*)(void))loc_8090264)();
        *(_DWORD *)&cap_4[20] = preca;
        cap_4[24] = v23;
        *(_QWORD *)&v41.len = COERCE_UNSIGNED_INT64(
                                COERCE_LONG_DOUBLE(
                                  COERCE_LONG_DOUBLE(
                                    strconv_formatDigits(
                                      dst,
                                      old_8,
                                      cap,
                                      *(strconv_decimalSlice_0 *)cap_4,
                                      *(__int32 *)&cap_4[24],
                                      cap_4[28]))));
        return v41;
      }
      else
      {
        *(_QWORD *)&v38.len = COERCE_UNSIGNED_INT64(
                                COERCE_LONG_DOUBLE(
                                  COERCE_LONG_DOUBLE(
                                    strconv_bigFtoa(
                                      dst,
                                      v25,
                                      v23,
                                      mant_lo,
                                      __PAIR64__(exp, v27),
                                      (__int32)v9,
                                      *(strconv_floatInfo_0 **)&cap_4[16]))));
        return v38;
      }
    }
    memset(&v56, 0, 13);
    strconv___ptr_extFloat__AssignComputeBounds(
      &v56,
      __PAIR64__(v27, v24),
      exp,
      v42,
      v9,
      *(strconv_extFloat_0 *)&cap_4[4],
      *(strconv_extFloat_0 *)&cap_4[20]);
    lower = *(strconv_extFloat_0 *)&cap_4[4];
    upper = *(strconv_extFloat_0 *)&cap_4[20];
    ((void (*)(void))loc_808FD88)();
    digs.d.array = buf_0;
    digs.d.len = 32;
    digs.d.cap = 32;
    cap = strconv___ptr_extFloat__ShortestDecimal(&v56, &digs, &lower, &upper);
    v30 = cap;
    if ( !cap )
    {
      *(_QWORD *)&v39.len = COERCE_UNSIGNED_INT64(
                              COERCE_LONG_DOUBLE(
                                COERCE_LONG_DOUBLE(
                                  strconv_bigFtoa(
                                    dst,
                                    prec,
                                    fmt,
                                    mant_lo,
                                    __PAIR64__(exp, HIDWORD(mant_lo)),
                                    v60,
                                    *(strconv_floatInfo_0 **)&cap_4[16]))));
      return v39;
    }
    if ( fmt > 0x47u )
    {
      switch ( fmt )
      {
        case 'e':
LABEL_43:
          nd = digs.nd - 1;
          if ( digs.nd - 1 <= 0 )
            nd = 0;
          goto LABEL_45;
        case 'f':
          nd = digs.nd - digs.dp;
          if ( digs.nd - digs.dp <= 0 )
            nd = 0;
          goto LABEL_45;
        case 'g':
          goto LABEL_47;
      }
    }
    else
    {
      if ( fmt == 69 )
        goto LABEL_43;
      if ( fmt == 71 )
      {
LABEL_47:
        nd = digs.nd;
LABEL_45:
        v23 = fmt;
        v9 = (strconv_floatInfo_0 *)v60;
        v27 = HIDWORD(mant_lo);
        v25 = nd;
        v28 = prec < 0;
        goto LABEL_26;
      }
    }
    nd = prec;
    goto LABEL_45;
  }
  if ( (bits_hi & ((__PAIR64__(
                      (mantbits - 32 < 0x20 ? 1 << (mantbits - 32) : 0) | (32 - mantbits < 0x20 ? 1u >> (32 - mantbits) : 0),
                      v49)
                  - 1) >> 32)) != 0
    || (LODWORD(v6) & (v49 - 1)) != 0 )
  {
    v15 = 3;
    v16 = "NaN";
  }
  else if ( v12 )
  {
    v15 = 4;
    v16 = "-Inf";
  }
  else
  {
    v15 = 4;
    v16 = "+Inf";
  }
  v17 = dst.len + v15;
  v46 = dst.len + v15;
  v18 = dst.cap;
  if ( (unsigned int)(dst.len + v15) > dst.cap )
  {
    s_ptr = (uint8 *)v16;
    cap_4a = runtime_growslice((runtime__type_0 *)&i, (runtime_slice_0)dst, v17);
    v18 = cap_4a.cap;
    array = (uint8 *)cap_4a.array;
    v17 = v46;
  }
  else
  {
    array = dst.array;
  }
  if ( v17 > v18 )
    runtime_panicslice();
  v61 = array;
  runtime_memmove();
  _r5.array = v61;
  _r5.len = v46;
  _r5.cap = v18;
  return _r5;
}
// 8096577: variable 'v26' is possibly undefined
// 809660A: variable 'cap' is possibly undefined
// 809660A: variable 'cap_4' is possibly undefined
// 809661B: variable 'v41' is possibly undefined
// 8096691: variable 'v38' is possibly undefined
// 80969BD: variable 'v39' is possibly undefined
// 8096A2D: variable 'v40' is possibly undefined

//----- (08096B20) --------------------------------------------------------
__uint8 __golang strconv_bigFtoa(
        __uint8 dst,
        __int32 prec,
        uint8 fmt,
        bool neg,
        uint64 mant,
        __int32 exp,
        strconv_floatInfo_0 *flt)
{
  __int32 v7; // edx
  int v8; // edx
  bool v9; // zf
  bool v10; // [esp+10h] [ebp-374h]
  strconv_decimalSlice_0 v11; // [esp+14h] [ebp-370h]
  __int32 v12; // [esp+2Ch] [ebp-358h]
  uint8 v13; // [esp+30h] [ebp-354h]
  strconv_decimal d; // [esp+40h] [ebp-344h] BYREF
  strconv_decimalSlice_0 digs; // [esp+36Ch] [ebp-18h]
  __uint8 _r7_4; // [esp+3B0h] [ebp+2Ch]

  while ( (unsigned int)&d.d[64] <= *(_DWORD *)(*(_DWORD *)(__readgsdword(0) - 4) + 8) )
    runtime_morestack_noctxt();
  memset(&d, 0, sizeof(d));
  strconv___ptr_decimal__Assign(&d, __PAIR64__(mant, neg));
  strconv___ptr_decimal__Shift(&d, HIDWORD(mant) - *(_DWORD *)exp);
  ((void (*)(void))loc_808FD8A)();
  v7 = prec;
  if ( prec < 0 )
  {
    strconv_roundShortest(&d, __PAIR64__(mant, neg), SHIDWORD(mant), (strconv_floatInfo_0 *)exp);
    ((void (*)(void))loc_808FD8A)();
    digs.d.array = (uint8 *)&d;
    digs.d.len = 800;
    digs.d.cap = 800;
    digs.nd = d.nd;
    digs.dp = d.dp;
    goto LABEL_7;
  }
  if ( fmt > 0x47u )
  {
    if ( fmt == 101 )
      goto LABEL_5;
    if ( fmt == 102 )
    {
      strconv___ptr_decimal__Round(&d, prec + d.dp);
      goto LABEL_6;
    }
    if ( fmt != 103 )
      goto LABEL_6;
    v9 = prec == 0;
LABEL_10:
    if ( v9 )
      v7 = 1;
    strconv___ptr_decimal__Round(&d, v7);
    goto LABEL_6;
  }
  if ( fmt != 69 )
  {
    if ( fmt != 71 )
      goto LABEL_6;
    v9 = prec == 0;
    goto LABEL_10;
  }
LABEL_5:
  strconv___ptr_decimal__Round(&d, prec + 1);
LABEL_6:
  ((void (*)(void))loc_808FD8A)();
  digs.d.array = (uint8 *)&d;
  digs.d.len = 800;
  digs.d.cap = 800;
  digs.nd = d.nd;
  digs.dp = d.dp;
LABEL_7:
  ((void (*)(void))loc_8090264)();
  *(_DWORD *)&v11.neg = v8;
  LOBYTE(v12) = fmt;
  *(_QWORD *)&_r7_4.array = COERCE_UNSIGNED_INT64(COERCE_LONG_DOUBLE(COERCE_LONG_DOUBLE(strconv_formatDigits(dst, prec < 0, v10, v11, v12, v13))));
  return _r7_4;
}
// 8096C84: variable 'v8' is possibly undefined
// 8096C94: variable 'v10' is possibly undefined
// 8096C94: variable 'v11' is possibly undefined
// 8096C94: variable 'v12' is possibly undefined
// 8096C94: variable 'v13' is possibly undefined

//----- (08096E30) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
__uint8 __golang strconv_formatDigits(
        __uint8 dst,
        bool shortest,
        bool neg,
        strconv_decimalSlice_0 digs,
        __int32 prec,
        uint8 fmt)
{
  char v6; // al
  uint8 v7; // al
  __int32 v8; // ecx
  __int32 v9; // ebx
  bool v10; // cc
  char v11; // al
  __int32 v12; // ebx
  __int32 len; // ecx
  uint8 *v14; // edx
  __int32 v15; // ebx
  _BYTE *array; // ebp
  strconv_decimalSlice_0 cap; // [esp+10h] [ebp-2Ch]
  runtime_slice_0 v18; // [esp+14h] [ebp-28h]
  __uint8 v19; // [esp+2Ch] [ebp-10h]
  __uint8 v20; // [esp+2Ch] [ebp-10h]
  __uint8 v21; // [esp+30h] [ebp-Ch]
  __uint8 v22; // [esp+30h] [ebp-Ch]
  __uint8 _r6_4; // [esp+74h] [ebp+38h]

  v6 = prec;
  if ( (unsigned __int8)prec > 0x47u )
  {
    switch ( (_BYTE)prec )
    {
      case 'e':
        goto LABEL_3;
      case 'f':
        ((void (*)(void))loc_8090264)();
        v20 = strconv_fmtF(dst, *(&shortest + 1), cap, *(__int32 *)&digs.neg);
        _r6_4.array = (uint8 *)v20.len;
        _r6_4.len = v20.cap;
        return _r6_4;
      case 'g':
        goto LABEL_5;
    }
LABEL_23:
    len = dst.len;
    v14 = (uint8 *)(dst.len + 2);
    v15 = dst.cap;
    if ( dst.len + 2 > dst.cap )
    {
      v18 = runtime_growslice((runtime__type_0 *)&i, (runtime_slice_0)dst, dst.len + 2);
      array = v18.array;
      v15 = v18.cap;
      v14 = (uint8 *)(v18.len + 2);
      v6 = prec;
      len = dst.len;
    }
    else
    {
      array = dst.array;
    }
    array[len] = 37;
    array[len + 1] = v6;
    _r6_4.array = v14;
    _r6_4.len = v15;
    return _r6_4;
  }
  if ( (_BYTE)prec == 69 )
  {
LABEL_3:
    v7 = ((int (*)(void))loc_8090264)();
    v21 = strconv_fmtE(dst, *(&shortest + 1), cap, *(__int32 *)&digs.neg, v7);
    _r6_4.array = (uint8 *)v21.len;
    _r6_4.len = v21.cap;
    return _r6_4;
  }
  if ( (_BYTE)prec != 71 )
    goto LABEL_23;
LABEL_5:
  v8 = digs.d.cap;
  if ( *(int *)&digs.neg <= digs.d.cap || digs.d.cap < digs.nd )
  {
    v9 = digs.d.cap;
    v8 = *(_DWORD *)&digs.neg;
  }
  else
  {
    v9 = digs.d.cap;
  }
  if ( shortest )
    v8 = 6;
  if ( digs.nd - 1 < -4 )
  {
    v10 = *(_DWORD *)&digs.neg <= v9;
LABEL_12:
    if ( v10 )
      v9 = *(_DWORD *)&digs.neg;
    v11 = ((int (*)(void))loc_8090264)();
    v22 = strconv_fmtE(dst, *(&shortest + 1), cap, v9 - 1, v11 - 2);
    _r6_4.array = (uint8 *)v22.len;
    _r6_4.len = v22.cap;
    return _r6_4;
  }
  if ( digs.nd - 1 >= v8 )
  {
    v10 = *(_DWORD *)&digs.neg <= v9;
    goto LABEL_12;
  }
  if ( *(int *)&digs.neg <= digs.nd )
    v9 = *(_DWORD *)&digs.neg;
  v12 = v9 - digs.nd;
  if ( v12 <= 0 )
    v12 = 0;
  ((void (*)(void))loc_8090264)();
  v19 = strconv_fmtF(dst, *(&shortest + 1), cap, v12);
  _r6_4.array = (uint8 *)v19.len;
  _r6_4.len = v19.cap;
  return _r6_4;
}
// 8096E30: variables would overlap: ^4C.1 and ^4C.2
// 8096E30: inconsistent variable size for '^4C.1(shortest)'
// 8096E30: using guessed type __int32 fmt;

//----- (080970B0) --------------------------------------------------------
void __golang strconv_roundShortest(strconv_decimal *d, uint64 mant, __int32 exp, strconv_floatInfo_0 *flt)
{
  unsigned int v4; // edi
  unsigned int v5; // edx
  unsigned int v6; // eax
  unsigned int v7; // ebx
  __int32 v8; // ecx
  strconv_decimal *v9; // ebx
  __int32 i; // eax
  uint8 v11; // si
  uint8 v12; // di
  unsigned __int8 v13; // bl
  bool v14; // cl
  bool v15; // bl
  bool v16; // zf
  __int32 minexp; // [esp+Ch] [ebp-668h]
  __int32 explo; // [esp+10h] [ebp-664h]
  int v19; // [esp+18h] [ebp-65Ch]
  strconv_decimal v20; // [esp+1Ch] [ebp-658h] BYREF
  strconv_decimal a; // [esp+348h] [ebp-32Ch] BYREF

  while ( (unsigned int)&v20.d[100] <= *(_DWORD *)(*(_DWORD *)(__readgsdword(0) - 4) + 8) )
    runtime_morestack_noctxt();
  if ( (_DWORD)mant == 0 && HIDWORD(mant) == 0 )
  {
    d->nd = 0;
    return;
  }
  minexp = flt->bias + 1;
  if ( exp <= minexp )
  {
    v4 = mant;
  }
  else
  {
    v4 = mant;
    if ( 332 * (d->dp - d->nd) >= (signed __int32)(100 * (exp - flt->mantbits)) )
      return;
  }
  v19 = 2 * v4;
  memset(&a, 0, sizeof(a));
  strconv___ptr_decimal__Assign(&a, 2 * __PAIR64__(HIDWORD(mant), v4) + 1);
  strconv___ptr_decimal__Shift(&a, exp - flt->mantbits - 1);
  v5 = (flt->mantbits - 32 < 0x20 ? 1 << (LOBYTE(flt->mantbits) - 32) : 0) | (32 - flt->mantbits < 0x20 ? 1u >> (32 - LOBYTE(flt->mantbits)) : 0);
  if ( (unsigned int)mant > ((1 << flt->mantbits) & (unsigned int)-(flt->mantbits < 0x20)) && HIDWORD(mant) == v5
    || HIDWORD(mant) > v5
    || minexp == exp )
  {
    v7 = (mant - 1) >> 32;
    v6 = mant - 1;
    v8 = exp;
  }
  else
  {
    v7 = (v19 != 0) + (unsigned int)(__SPAIR64__(HIDWORD(mant), v4) >> 31) - 1;
    v8 = exp - 1;
    v6 = v19 - 1;
  }
  explo = v8;
  memset(&v20, 0, sizeof(v20));
  strconv___ptr_decimal__Assign(&v20, __PAIR64__((2 * v7) | (v6 >> 31), 2 * v6) + 1);
  strconv___ptr_decimal__Shift(&v20, explo - flt->mantbits - 1);
  v9 = d;
  for ( i = 0; i < v9->nd; ++i )
  {
    if ( i >= v20.nd )
    {
      v11 = 48;
    }
    else
    {
      if ( (unsigned int)i >= 0x320 )
        runtime_panicindex();
      v11 = v20.d[i];
    }
    if ( (unsigned int)i >= 0x320 )
      runtime_panicindex();
    v12 = v9->d[i];
    if ( i >= a.nd )
      v13 = 48;
    else
      v13 = a.d[i];
    v14 = v11 != v12 || (mant & 1) == 0 && v20.nd == i + 1;
    if ( v13 == v12 )
      v15 = 0;
    else
      v15 = (mant & 1) == 0 || (unsigned __int8)(v12 + 1) < v13 || i + 1 < a.nd;
    v16 = !v14;
    if ( v14 )
    {
      if ( v15 )
      {
        strconv___ptr_decimal__Round(d, i + 1);
        return;
      }
      v16 = !v14;
    }
    if ( !v16 )
    {
      strconv___ptr_decimal__RoundDown(d, i + 1);
      return;
    }
    if ( v15 )
    {
      strconv___ptr_decimal__RoundUp(d, i + 1);
      return;
    }
    v9 = d;
  }
}

//----- (08097470) --------------------------------------------------------
__uint8 __golang strconv_fmtE(__uint8 dst, bool neg, strconv_decimalSlice_0 d, __int32 prec, uint8 fmt)
{
  unsigned __int64 cap; // rcx
  __int32 len; // edx
  _BYTE *array; // eax
  __int32 v8; // ebp
  __int32 v9; // edx
  __int32 nd; // ebp
  __int32 v11; // esi
  __int32 v12; // edx
  char v13; // bp
  __int32 v14; // esi
  void *v15; // ebp
  int v16; // edx
  char v17; // al
  void *v18; // ebp
  int v19; // edx
  char v20; // al
  unsigned int v21; // edx
  char v22; // di
  runtime_slice_0 oldb; // [esp+4h] [ebp-3Ch]
  runtime_slice_0 olde; // [esp+4h] [ebp-3Ch]
  runtime_slice_0 oldf; // [esp+4h] [ebp-3Ch]
  runtime_slice_0 oldg; // [esp+4h] [ebp-3Ch]
  runtime_slice_0 oldd; // [esp+4h] [ebp-3Ch]
  runtime_slice_0 oldc; // [esp+4h] [ebp-3Ch]
  runtime_slice_0 oldh; // [esp+4h] [ebp-3Ch]
  runtime_slice_0 olda; // [esp+4h] [ebp-3Ch]
  runtime_slice_0 old; // [esp+4h] [ebp-3Ch]
  runtime_slice_0 v32; // [esp+14h] [ebp-2Ch]
  runtime_slice_0 v33; // [esp+14h] [ebp-2Ch]
  runtime_slice_0 v34; // [esp+14h] [ebp-2Ch]
  runtime_slice_0 v35; // [esp+14h] [ebp-2Ch]
  runtime_slice_0 v36; // [esp+14h] [ebp-2Ch]
  runtime_slice_0 v37; // [esp+14h] [ebp-2Ch]
  runtime_slice_0 v38; // [esp+14h] [ebp-2Ch]
  runtime_slice_0 v39; // [esp+14h] [ebp-2Ch]
  runtime_slice_0 v40; // [esp+14h] [ebp-2Ch]
  runtime_slice_0 v41; // [esp+14h] [ebp-2Ch]
  uint8 ch_0; // [esp+22h] [ebp-1Eh]
  char v43; // [esp+23h] [ebp-1Dh]
  __int32 exp; // [esp+2Ch] [ebp-14h]
  char v45; // [esp+34h] [ebp-Ch]
  int v46; // [esp+34h] [ebp-Ch]
  __int32 v47; // [esp+38h] [ebp-8h]
  char v48; // [esp+38h] [ebp-8h]
  char v49; // [esp+38h] [ebp-8h]
  _BYTE *dsta; // [esp+44h] [ebp+4h]
  unsigned int dst_4c; // [esp+48h] [ebp+8h]
  __int32 dst_4b; // [esp+48h] [ebp+8h]
  __int32 dst_4; // [esp+48h] [ebp+8h]
  __int32 dst_4a; // [esp+48h] [ebp+8h]
  __uint8 _r5; // [esp+74h] [ebp+34h]

  if ( neg )
  {
    cap = *(_QWORD *)&dst.len;
    len = dst.len + 1;
    if ( dst.len + 1 > dst.cap )
    {
      v41 = runtime_growslice((runtime__type_0 *)&i, (runtime_slice_0)dst, dst.len + 1);
      array = v41.array;
      len = v41.len + 1;
      cap = __PAIR64__(v41.cap, dst.len);
    }
    else
    {
      array = dst.array;
    }
    array[cap] = 45;
  }
  else
  {
    HIDWORD(cap) = dst.cap;
    array = dst.array;
    len = dst.len;
  }
  if ( d.nd )
  {
    if ( !d.d.len )
      runtime_panicindex();
    LOBYTE(cap) = *d.d.array;
  }
  else
  {
    LOBYTE(cap) = 48;
  }
  v8 = len + 1;
  if ( len + 1 > SHIDWORD(cap) )
  {
    dst_4a = len;
    ch_0 = cap;
    old.array = array;
    *(_QWORD *)&old.len = __PAIR64__(HIDWORD(cap), len);
    v40 = runtime_growslice((runtime__type_0 *)&i, old, len + 1);
    array = v40.array;
    HIDWORD(cap) = v40.cap;
    v8 = v40.len + 1;
    LOBYTE(cap) = ch_0;
    len = dst_4a;
  }
  array[len] = cap;
  LODWORD(cap) = prec;
  if ( prec <= 0 )
  {
    v9 = v8;
  }
  else
  {
    v9 = v8 + 1;
    if ( v8 + 1 > SHIDWORD(cap) )
    {
      olda.array = array;
      *(_QWORD *)&olda.len = __PAIR64__(HIDWORD(cap), v8);
      v39 = runtime_growslice((runtime__type_0 *)&i, olda, v8 + 1);
      array = v39.array;
      v9 = v39.len + 1;
      cap = __PAIR64__(v39.cap, prec);
    }
    array[v8] = 46;
    nd = d.nd;
    if ( d.nd >= (int)cap + 1 )
      nd = cap + 1;
    if ( nd > 1 )
    {
      if ( (unsigned int)nd > d.d.cap )
        goto LABEL_51;
      LODWORD(cap) = nd + v9 - 1;
      dst_4 = cap;
      if ( (unsigned int)cap > HIDWORD(cap) )
      {
        oldh.array = array;
        *(_QWORD *)&oldh.len = __PAIR64__(HIDWORD(cap), v9);
        v38 = runtime_growslice((runtime__type_0 *)&i, oldh, cap);
        array = v38.array;
        cap = __PAIR64__(v38.cap, dst_4);
      }
      if ( (unsigned int)cap > HIDWORD(cap) )
LABEL_51:
        runtime_panicslice();
      dsta = array;
      runtime_memmove();
      LODWORD(cap) = prec;
      v9 = dst_4;
      array = dsta;
    }
    else
    {
      nd = 1;
    }
    while ( nd <= (int)cap )
    {
      v11 = v9 + 1;
      if ( v9 + 1 > SHIDWORD(cap) )
      {
        v47 = v9;
        oldb.array = array;
        *(_QWORD *)&oldb.len = __PAIR64__(HIDWORD(cap), v9);
        v32 = runtime_growslice((runtime__type_0 *)&i, oldb, v9 + 1);
        array = v32.array;
        v11 = v32.len + 1;
        cap = __PAIR64__(v32.cap, prec);
        v9 = v47;
      }
      array[v9] = 48;
      ++nd;
      v9 = v11;
    }
  }
  LODWORD(cap) = v9 + 1;
  if ( v9 + 1 > SHIDWORD(cap) )
  {
    dst_4b = v9;
    oldc.array = array;
    *(_QWORD *)&oldc.len = __PAIR64__(HIDWORD(cap), v9);
    v37 = runtime_growslice((runtime__type_0 *)&i, oldc, v9 + 1);
    array = v37.array;
    HIDWORD(cap) = v37.cap;
    LODWORD(cap) = v37.len + 1;
    v9 = dst_4b;
  }
  array[v9] = fmt;
  v12 = d.dp - 1;
  if ( !d.nd )
    v12 = 0;
  if ( v12 >= 0 )
  {
    v13 = 43;
  }
  else
  {
    v12 = -v12;
    v13 = 45;
  }
  exp = v12;
  v14 = cap + 1;
  if ( (int)cap + 1 > SHIDWORD(cap) )
  {
    dst_4c = cap;
    oldd.array = array;
    *(_QWORD *)&oldd.len = cap;
    v36 = runtime_growslice((runtime__type_0 *)&i, oldd, (int)cap + 1);
    array = v36.array;
    v14 = v36.len + 1;
    cap = __PAIR64__(v36.cap, dst_4c);
    v12 = exp;
  }
  array[cap] = v13;
  if ( v12 >= 10 )
  {
    if ( v12 >= 100 )
    {
      LODWORD(cap) = v14 + 3;
      v18 = array;
      v46 = ((int)((unsigned __int64)(1374389535LL * v12) >> 32) >> 5) - (exp >> 31);
      v19 = ((int)((unsigned __int64)(3435973837LL * exp) >> 32) >> 3) - (exp >> 31);
      v20 = v19;
      v21 = v19 - 10 * ((410 * (unsigned int)(unsigned __int8)v19) >> 12);
      v22 = exp - 10 * v20;
      if ( v14 + 3 > SHIDWORD(cap) )
      {
        v43 = v21;
        v49 = exp - 10 * v20;
        oldg.array = v18;
        *(_QWORD *)&oldg.len = __PAIR64__(HIDWORD(cap), v14);
        v35 = runtime_growslice((runtime__type_0 *)&i, oldg, cap);
        v18 = v35.array;
        HIDWORD(cap) = v35.cap;
        LODWORD(cap) = v35.len + 3;
        LOBYTE(v21) = v43;
        v22 = v49;
      }
      *((_BYTE *)v18 + v14) = v46 + 48;
      *((_BYTE *)v18 + v14 + 1) = v21 + 48;
      *((_BYTE *)v18 + v14 + 2) = v22 + 48;
      array = v18;
    }
    else
    {
      LODWORD(cap) = v14 + 2;
      v15 = array;
      v16 = ((int)(exp + ((unsigned __int64)(-858993459LL * v12) >> 32)) >> 3) - (exp >> 31);
      v17 = exp - 10 * v16;
      if ( v14 + 2 > SHIDWORD(cap) )
      {
        v48 = v16;
        v45 = exp - 10 * v16;
        oldf.array = v15;
        *(_QWORD *)&oldf.len = __PAIR64__(HIDWORD(cap), v14);
        v34 = runtime_growslice((runtime__type_0 *)&i, oldf, v14 + 2);
        v15 = v34.array;
        HIDWORD(cap) = v34.cap;
        LODWORD(cap) = v34.len + 2;
        v17 = v45;
        LOBYTE(v16) = v48;
      }
      *((_BYTE *)v15 + v14) = v16 + 48;
      *((_BYTE *)v15 + v14 + 1) = v17 + 48;
      array = v15;
    }
  }
  else
  {
    LODWORD(cap) = v14 + 2;
    if ( v14 + 2 > SHIDWORD(cap) )
    {
      olde.array = array;
      *(_QWORD *)&olde.len = __PAIR64__(HIDWORD(cap), v14);
      v33 = runtime_growslice((runtime__type_0 *)&i, olde, v14 + 2);
      array = v33.array;
      HIDWORD(cap) = v33.cap;
      LODWORD(cap) = v33.len + 2;
      LOBYTE(v12) = exp;
    }
    array[v14] = 48;
    array[v14 + 1] = v12 + 48;
  }
  _r5.array = array;
  *(_QWORD *)&_r5.len = cap;
  return _r5;
}

//----- (080979A0) --------------------------------------------------------
__uint8 __golang strconv_fmtF(__uint8 dst, bool neg, strconv_decimalSlice_0 d, __int32 prec)
{
  unsigned __int64 v4; // rax
  __int32 len; // ecx
  _BYTE *array; // ebx
  __int32 v7; // ecx
  __int32 v8; // ebp
  __int32 v9; // esi
  uint8 v10; // cl
  __int32 v11; // esi
  unsigned __int32 nd; // ebp
  unsigned __int32 v13; // esi
  __int32 v14; // ecx
  __int32 v15; // ebp
  runtime_slice_0 oldb; // [esp+4h] [ebp-3Ch]
  runtime_slice_0 olda; // [esp+4h] [ebp-3Ch]
  runtime_slice_0 old; // [esp+4h] [ebp-3Ch]
  runtime_slice_0 oldd; // [esp+4h] [ebp-3Ch]
  runtime_slice_0 oldc; // [esp+4h] [ebp-3Ch]
  runtime_slice_0 v21; // [esp+14h] [ebp-2Ch]
  runtime_slice_0 v22; // [esp+14h] [ebp-2Ch]
  runtime_slice_0 v23; // [esp+14h] [ebp-2Ch]
  runtime_slice_0 v24; // [esp+14h] [ebp-2Ch]
  runtime_slice_0 v25; // [esp+14h] [ebp-2Ch]
  runtime_slice_0 v26; // [esp+14h] [ebp-2Ch]
  uint8 ch_0; // [esp+23h] [ebp-1Dh]
  __int32 m; // [esp+24h] [ebp-1Ch]
  __int32 i; // [esp+28h] [ebp-18h]
  __int32 v30; // [esp+2Ch] [ebp-14h]
  unsigned __int32 v31; // [esp+30h] [ebp-10h]
  unsigned int v32; // [esp+34h] [ebp-Ch]
  __int32 dst_4; // [esp+48h] [ebp+8h]
  unsigned int dst_8; // [esp+4Ch] [ebp+Ch]
  __uint8 _r4; // [esp+70h] [ebp+30h]

  if ( neg )
  {
    v4 = *(_QWORD *)&dst.len;
    len = dst.len + 1;
    if ( dst.len + 1 > dst.cap )
    {
      v26 = runtime_growslice((runtime__type_0 *)&::i, (runtime_slice_0)dst, dst.len + 1);
      array = v26.array;
      len = v26.len + 1;
      v4 = __PAIR64__(v26.cap, dst.len);
    }
    else
    {
      array = dst.array;
    }
    array[v4] = 45;
  }
  else
  {
    array = dst.array;
    len = dst.len;
    HIDWORD(v4) = dst.cap;
  }
  dst_4 = len;
  if ( d.dp > 0 )
  {
    nd = d.nd;
    if ( d.nd >= d.dp )
      nd = d.dp;
    if ( nd > d.d.cap )
      goto LABEL_40;
    v13 = nd + len;
    v31 = nd + len;
    if ( nd + len > HIDWORD(v4) )
    {
      oldc.array = array;
      *(_QWORD *)&oldc.len = __PAIR64__(HIDWORD(v4), len);
      v25 = runtime_growslice((runtime__type_0 *)&::i, oldc, nd + len);
      array = v25.array;
      HIDWORD(v4) = v25.cap;
      v13 = v31;
    }
    if ( v13 > HIDWORD(v4) )
LABEL_40:
      runtime_panicslice();
    dst_8 = HIDWORD(v4);
    runtime_memmove();
    v4 = __PAIR64__(dst_8, nd);
    v14 = v31;
    while ( (int)v4 < d.dp )
    {
      v15 = v14 + 1;
      if ( v14 + 1 > SHIDWORD(v4) )
      {
        m = v4;
        v30 = v14;
        oldd.array = array;
        *(_QWORD *)&oldd.len = __PAIR64__(HIDWORD(v4), v14);
        v24 = runtime_growslice((runtime__type_0 *)&::i, oldd, v14 + 1);
        array = v24.array;
        v15 = v24.len + 1;
        v4 = __PAIR64__(v24.cap, m);
        v14 = v30;
      }
      array[v14] = 48;
      LODWORD(v4) = v4 + 1;
      v14 = v15;
    }
    LODWORD(v4) = v14;
  }
  else
  {
    LODWORD(v4) = len + 1;
    if ( len + 1 > SHIDWORD(v4) )
    {
      old.array = array;
      *(_QWORD *)&old.len = __PAIR64__(HIDWORD(v4), len);
      v23 = runtime_growslice((runtime__type_0 *)&::i, old, len + 1);
      array = v23.array;
      HIDWORD(v4) = v23.cap;
      LODWORD(v4) = v23.len + 1;
      len = dst_4;
    }
    array[len] = 48;
  }
  v7 = prec;
  if ( prec <= 0 )
  {
    v8 = v4;
  }
  else
  {
    v8 = v4 + 1;
    if ( (int)v4 + 1 > SHIDWORD(v4) )
    {
      v32 = v4;
      olda.array = array;
      *(_QWORD *)&olda.len = v4;
      v22 = runtime_growslice((runtime__type_0 *)&::i, olda, (int)v4 + 1);
      array = v22.array;
      v8 = v22.len + 1;
      v4 = __PAIR64__(v22.cap, v32);
      v7 = prec;
    }
    array[v4] = 46;
    LODWORD(v4) = 0;
    while ( (int)v4 < v7 )
    {
      v9 = v4 + d.dp;
      if ( (int)v4 + d.dp < 0 )
      {
        v10 = 48;
      }
      else if ( v9 >= d.nd )
      {
        v10 = 48;
      }
      else
      {
        if ( (unsigned int)v9 >= d.d.len )
          runtime_panicindex();
        v10 = d.d.array[v9];
      }
      v11 = v8 + 1;
      if ( v8 + 1 > SHIDWORD(v4) )
      {
        i = v4;
        ch_0 = v10;
        oldb.array = array;
        *(_QWORD *)&oldb.len = __PAIR64__(HIDWORD(v4), v8);
        v21 = runtime_growslice((runtime__type_0 *)&::i, oldb, v8 + 1);
        array = v21.array;
        v11 = v21.len + 1;
        v4 = __PAIR64__(v21.cap, i);
        v10 = ch_0;
      }
      array[v8] = v10;
      LODWORD(v4) = v4 + 1;
      v7 = prec;
      v8 = v11;
    }
  }
  _r4.array = array;
  _r4.len = v8;
  _r4.cap = HIDWORD(v4);
  return _r4;
}

//----- (08097CB0) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
__uint8 __golang strconv_fmtB(__uint8 dst, bool neg, uint64 mant, __int32 exp, strconv_floatInfo_0 *flt)
{
  __int32 len; // eax
  __int32 v6; // ecx
  __int32 cap; // edx
  uint8 *array; // ebx
  uint8 *v9; // eax
  int v10; // ecx
  int v11; // edx
  int v12; // ebx
  signed __int32 v13; // ebp
  __int32 v14; // ecx
  __uint8 v15; // [esp+0h] [ebp-34h]
  __uint8 v16; // [esp+0h] [ebp-34h]
  uint8 *v17; // [esp+4h] [ebp-30h] OVERLAPPED
  __int64 v18; // [esp+4h] [ebp-30h] OVERLAPPED
  int v19; // [esp+8h] [ebp-2Ch]
  uint64 u; // [esp+Ch] [ebp-28h] OVERLAPPED
  uint64 ua; // [esp+Ch] [ebp-28h] OVERLAPPED
  runtime_slice_0 base; // [esp+14h] [ebp-20h]
  _BYTE basea[24]; // [esp+14h] [ebp-20h]
  __uint8 v24; // [esp+1Ch] [ebp-18h]
  __uint8 v25; // [esp+20h] [ebp-14h]
  string v26; // [esp+2Ch] [ebp-8h]
  string v27; // [esp+2Ch] [ebp-8h]

  if ( neg )
  {
    len = dst.len;
    v6 = dst.len + 1;
    cap = dst.cap;
    if ( dst.len + 1 > dst.cap )
    {
      v18 = *(_QWORD *)&dst.array;
      ua = __PAIR64__(v6, dst.cap);
      base = runtime_growslice((runtime__type_0 *)&i, *(runtime_slice_0 *)&v18, v6);
      array = (uint8 *)base.array;
      cap = base.cap;
      v6 = base.len + 1;
      len = dst.len;
    }
    else
    {
      array = dst.array;
    }
    array[len] = 45;
  }
  else
  {
    array = dst.array;
    v6 = dst.len;
    cap = dst.cap;
  }
  v15.array = array;
  *(_QWORD *)&v15.len = __PAIR64__(cap, v6);
  strconv_formatBits(v15, mant, 10, 0, base.cap, v25, v26);
  v10 = *(_DWORD *)&basea[12];
  v9 = *(uint8 **)&basea[8];
  v11 = *(_DWORD *)&basea[16];
  v12 = *(_DWORD *)&basea[12] + 1;
  if ( *(_DWORD *)&basea[12] + 1 > *(int *)&basea[16] )
  {
    *(runtime_slice_0 *)basea = runtime_growslice(
                                  (runtime__type_0 *)&i,
                                  *(runtime_slice_0 *)&basea[8],
                                  *(_DWORD *)&basea[12] + 1);
    v9 = *(uint8 **)basea;
    v11 = *(_DWORD *)&basea[8];
    v12 = *(_DWORD *)&basea[4] + 1;
    v10 = *(_DWORD *)&basea[12];
  }
  v9[v10] = 112;
  v13 = exp - flt->mantbits;
  if ( v13 < 0 )
  {
    v14 = v12;
  }
  else
  {
    v14 = v12 + 1;
    if ( v12 + 1 > v11 )
    {
      v27.len = v12;
      v17 = v9;
      v19 = v12;
      u = __PAIR64__(v14, v11);
      *(runtime_slice_0 *)basea = runtime_growslice((runtime__type_0 *)&i, *(runtime_slice_0 *)&v17, v14);
      v9 = *(uint8 **)basea;
      v11 = *(_DWORD *)&basea[8];
      v14 = *(_DWORD *)&basea[4] + 1;
    }
    v9[v12] = 43;
  }
  v16.array = v9;
  *(_QWORD *)&v16.len = __PAIR64__(v11, v14);
  strconv_formatBits(v16, v13, 10, v13 < 0, basea[8], *(__uint8 *)&basea[12], v27);
  return v24;
}
// 8097DBB: failed to expand linear variable ^4.4
// 8097E38: failed to expand linear variable ^4.8

//----- (08097E80) --------------------------------------------------------
#error "8097F64: call analysis failed (funcsize=84)"

//----- (08097FA0) --------------------------------------------------------
string __golang strconv_Itoa(__int32 i)
{
  return strconv_FormatInt(i, 10);
}

//----- (08097FF0) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
void __golang strconv_formatBits(__uint8 dst, uint64 u, __int32 base, bool neg, bool append_, __uint8 d, string s)
{
  int v7; // eax
  bool v8; // cl
  uint64 v9; // rax
  int v10; // ebx
  unsigned int v11; // edx
  int j; // ebp
  unsigned int v13; // eax
  unsigned int v14; // edx
  unsigned int v15; // esi
  char v16; // dl
  int v17; // edx
  char v18; // dl
  unsigned int v19; // esi
  unsigned int v20; // edx
  unsigned int v21; // eax
  unsigned int v22; // eax
  char v23; // dl
  bool v24; // zf
  unsigned int v25; // ecx
  unsigned __int32 v26; // eax
  unsigned __int32 v27; // ebx
  void *array; // esi
  unsigned __int32 v29; // esi
  unsigned __int32 v30; // ebx
  __int32 v31; // edi
  int v32; // esi
  int v33; // edi
  int v34; // ebx
  unsigned int v35; // ebp
  __int32 v36; // esi
  __int32 v37; // ebx
  char v38; // al
  unsigned __int32 v39; // ebp
  unsigned __int32 v40; // ebx
  int v41; // esi
  unsigned int v42; // edx
  char v43; // dl
  char v44; // al
  uint64 n; // [esp+0h] [ebp-9Ch]
  __uint8 n_4; // [esp+4h] [ebp-98h]
  uint64 cap; // [esp+10h] [ebp-8Ch]
  runtime_slice_0 v48; // [esp+14h] [ebp-88h]
  uint s_0; // [esp+20h] [ebp-7Ch]
  __int32 i; // [esp+34h] [ebp-68h]
  __int32 ia; // [esp+34h] [ebp-68h]
  unsigned __int32 v52; // [esp+44h] [ebp-58h]
  int v53; // [esp+48h] [ebp-54h]
  char v54[2]; // [esp+55h] [ebp-47h]
  uint8 a[65]; // [esp+57h] [ebp-45h] BYREF
  void *v56; // [esp+98h] [ebp-4h]
  int ua; // [esp+ACh] [ebp+10h]

  while ( (unsigned int)&a[41] <= *(_DWORD *)(*(_DWORD *)(__readgsdword(0) - 4) + 8) )
    runtime_morestack_noctxt();
  if ( (unsigned int)(base - 2) > 0x22 )
  {
    LODWORD(n) = &t;
    HIDWORD(n) = &strconv_statictmp_6;
    runtime_gopanic((interface_{})n);
    BUG();
  }
  *(_DWORD *)a = 0;
  v7 = ((int (*)(void))loc_808FD80)();
  v8 = neg;
  if ( neg )
    v9 = (unsigned int)v7 - u;
  else
    v9 = u;
  if ( base == 10 )
  {
    v10 = 65;
    while ( (unsigned int)v9 >= 0x3B9ACA00 && HIDWORD(v9) == 0 || HIDWORD(v9) != 0 )
    {
      v53 = v9;
      cap = runtime_uint64div(v9, 0x3B9ACA00uLL);
      v11 = v53 - 1000000000 * cap;
      for ( j = 4; j > 0; --j )
      {
        v13 = v11 / 0x64;
        v14 = v11 % 0x64;
        v15 = 2 * v14;
        if ( 2 * v14 + 1 >= 0xC8 || (unsigned int)(v10 - 1) >= 0x41 )
          runtime_panicindex();
        a[v10 - 1] = a00010203040506[v15 + 1];
        if ( v15 >= 0xC8 || (v16 = a00010203040506[2 * v14], (unsigned int)(v10 - 2) >= 0x41) )
          runtime_panicindex();
        v54[v10] = v16;
        v10 -= 2;
        v11 = v13;
      }
      v17 = 2 * v11;
      if ( (unsigned int)(v17 + 1) >= 0xC8 || (v18 = a00010203040506[v17 + 1], (unsigned int)(v10 - 1) >= 0x41) )
        runtime_panicindex();
      v54[v10 + 1] = v18;
      v8 = neg;
      v9 = cap;
      --v10;
    }
    while ( (unsigned int)v9 >= 0x64 )
    {
      v19 = 2 * ((unsigned int)v9 % 0x64);
      if ( v19 + 1 >= 0xC8 || (unsigned int)(v10 - 1) >= 0x41 )
        runtime_panicindex();
      a[v10 - 1] = a00010203040506[v19 + 1];
      if ( v19 >= 0xC8 || (unsigned int)(v10 - 2) >= 0x41 )
        runtime_panicindex();
      v54[v10] = a00010203040506[2 * ((unsigned int)v9 % 0x64)];
      LODWORD(v9) = (unsigned int)v9 / 0x64;
      v10 -= 2;
    }
    HIDWORD(v9) = v9;
    v21 = 2 * v9;
    if ( v21 + 1 >= 0xC8 || (unsigned int)(v10 - 1) >= 0x41 )
      runtime_panicindex();
    a[v10 - 1] = a00010203040506[v21 + 1];
    if ( v20 < 0xA )
    {
      v24 = !v8;
      v22 = v10 - 1;
    }
    else
    {
      if ( v21 >= 0xC8 || (v22 = v10 - 2, v23 = a00010203040506[2 * v20], (unsigned int)(v10 - 2) >= 0x41) )
        runtime_panicindex();
      a[v10 - 2] = v23;
      v24 = !v8;
    }
  }
  else
  {
    if ( (unsigned int)base >= 0x25 )
      runtime_panicindex();
    if ( strconv_shifts[base] )
    {
      s_0 = strconv_shifts[base];
      v29 = base;
      v30 = base >> 31;
      v31 = base - 1;
      i = 65;
      while ( HIDWORD(v9) == v30 && (unsigned int)v9 >= v29 || HIDWORD(v9) > v30 )
      {
        v35 = v9;
        LODWORD(v9) = v31 & v9;
        if ( (unsigned int)v9 >= 0x24 || (v36 = i, LOBYTE(v9) = a0123456789abcd_2[v9], (unsigned int)(i - 1) >= 0x41) )
          runtime_panicindex();
        --i;
        v54[v36 + 1] = v9;
        v32 = -(s_0 < 0x20);
        v33 = (s_0 - 32 < 0x20 ? HIDWORD(v9) >> (s_0 - 32) : 0) | v32 & (v35 >> s_0) | (32 - s_0 < 0x20 ? HIDWORD(v9) << (32 - s_0) : 0);
        v34 = v32 & (HIDWORD(v9) >> s_0);
        v8 = neg;
        v29 = base;
        v9 = __PAIR64__(v34, v33);
        v30 = base >> 31;
        v31 = base - 1;
      }
      if ( (unsigned int)v9 >= 0x24 || (v37 = i - 1, v38 = a0123456789abcd_2[v9], (unsigned int)(i - 1) >= 0x41) )
        runtime_panicindex();
      a[i - 1] = v38;
      v24 = !v8;
    }
    else
    {
      v39 = base;
      v40 = base >> 31;
      v41 = 65;
      while ( HIDWORD(v9) > v40 || (unsigned int)v9 >= v39 && HIDWORD(v9) == v40 )
      {
        ua = v9;
        ia = v41;
        cap = runtime_uint64div(v9, __PAIR64__(v40, v39));
        v42 = ua - cap * base;
        if ( v42 >= 0x24 || (--v41, v43 = a0123456789abcd_2[v42], (unsigned int)(ia - 1) >= 0x41) )
          runtime_panicindex();
        v54[ia + 1] = v43;
        v40 = base >> 31;
        v39 = base;
        v9 = cap;
      }
      if ( (unsigned int)v9 >= 0x24 || (v44 = a0123456789abcd_2[v9], (unsigned int)(v41 - 1) >= 0x41) )
        runtime_panicindex();
      a[v41 - 1] = v44;
      v24 = !neg;
      v37 = v41 - 1;
    }
    v22 = v37;
  }
  if ( v24 )
  {
    v25 = v22;
  }
  else
  {
    v25 = v22 - 1;
    if ( v22 - 1 >= 0x41 )
      runtime_panicindex();
    v54[v22 + 1] = 45;
  }
  if ( *(&neg + 1) )
  {
    if ( v25 > 0x41
      || ((v26 = dst.len - v25 + 65, v52 = v26, v27 = dst.cap, v26 > dst.cap) ? (void *)(v48 = runtime_growslice(
                                                                                                 (runtime__type_0 *)&::i,
                                                                                                 (runtime_slice_0)dst,
                                                                                                 v26),
                                                                                         array = v48.array,
                                                                                         v27 = v48.cap,
                                                                                         v26 = v52) : (array = dst.array),
          v26 > v27) )
    {
      runtime_panicslice();
    }
    v56 = array;
    runtime_memmove();
  }
  else
  {
    if ( v25 > 0x41 )
      runtime_panicslice();
    n_4.array = &a[((int)(v25 - 65) >> 31) & v25];
    n_4.len = 65 - v25;
    n_4.cap = 65 - v25;
    runtime_slicebytetostring(0, n_4, (string)cap);
  }
}
// 8097FF0: variables would overlap: ^B8.1 and ^B8.2
// 8097FF0: inconsistent variable size for '^B8.1(neg)'

//----- (08098700) --------------------------------------------------------
__uint8 __golang strconv_appendQuotedWith(__uint8 buf, string s, uint8 quote, bool ASCIIonly, bool graphicOnly)
{
  __int32 len; // eax
  __int32 v6; // ecx
  uint8 *cap; // edx
  _BYTE *array; // ebx
  uint8 v9; // bp
  uint8 *str; // eax
  __int32 i; // esi
  unsigned __int32 v12; // edi
  unsigned __int32 v13; // edi
  uint8 *v14; // eax
  unsigned int v15; // ecx
  __int32 v16; // edx
  int v17; // ebx
  char v18; // cl
  uint8 *v19; // esi
  _BYTE *v20; // edi
  char v21; // dl
  __uint8 et; // [esp+0h] [ebp-3Ch]
  runtime_slice_0 olda; // [esp+4h] [ebp-38h]
  runtime_slice_0 oldb; // [esp+4h] [ebp-38h]
  runtime_slice_0 old; // [esp+4h] [ebp-38h]
  runtime_slice_0 oldc; // [esp+4h] [ebp-38h]
  int32 old_4; // [esp+8h] [ebp-34h]
  unsigned __int32 old_4a; // [esp+8h] [ebp-34h]
  __int32 old_8; // [esp+Ch] [ebp-30h]
  _BYTE v30[20]; // [esp+14h] [ebp-28h]
  runtime_slice_0 v31; // [esp+14h] [ebp-28h]
  uint8 *v32; // [esp+28h] [ebp-14h]
  __int32 v33; // [esp+2Ch] [ebp-10h]
  void *bufa; // [esp+40h] [ebp+4h]
  __int32 buf_4; // [esp+44h] [ebp+8h]
  uint8 *buf_8; // [esp+48h] [ebp+Ch]
  uint8 *sa; // [esp+4Ch] [ebp+10h]
  unsigned __int32 s_4; // [esp+50h] [ebp+14h]
  __uint8 _r5_8; // [esp+60h] [ebp+24h]

  len = buf.len;
  v6 = buf.len + 1;
  cap = (uint8 *)buf.cap;
  if ( buf.len + 1 > buf.cap )
  {
    *(runtime_slice_0 *)v30 = runtime_growslice((runtime__type_0 *)&::i, (runtime_slice_0)buf, buf.len + 1);
    array = *(_BYTE **)v30;
    cap = *(uint8 **)&v30[8];
    v6 = *(_DWORD *)&v30[4] + 1;
    len = buf.len;
  }
  else
  {
    array = buf.array;
  }
  array[len] = quote;
  v9 = quote;
  str = s.str;
  for ( i = s.len; ; i = s_4 - *(_DWORD *)&v30[16] )
  {
    buf_4 = v6;
    if ( i <= 0 )
      break;
    sa = str;
    s_4 = i;
    v12 = *str;
    if ( v12 >= 0x80 )
    {
      v32 = cap;
      unicode_utf8_DecodeRuneInString((string)__PAIR64__(i, (unsigned int)str), old_4, old_8);
      v12 = old_4a;
      v6 = buf_4;
      cap = v32;
      v9 = quote;
      *(_DWORD *)&v30[16] = old_8;
    }
    else
    {
      *(_DWORD *)&v30[16] = 1;
    }
    if ( *(_DWORD *)&v30[16] == 1 && v12 == 65533 )
    {
      v13 = v6 + 2;
      v33 = v6 + 2;
      if ( v6 + 2 > (unsigned int)cap )
      {
        old.array = array;
        *(_QWORD *)&old.len = __PAIR64__((unsigned int)cap, v6);
        *(runtime_slice_0 *)v30 = runtime_growslice((runtime__type_0 *)&::i, old, v6 + 2);
        cap = *(uint8 **)&v30[8];
        array = *(_BYTE **)v30;
        v13 = v33;
      }
      if ( v13 > (unsigned int)cap )
        runtime_panicslice();
      buf_8 = cap;
      bufa = array;
      old_4 = 2;
      runtime_memmove();
      v14 = sa;
      v15 = *sa >> 4;
      if ( v15 >= 0x10 )
        runtime_panicindex();
      v16 = buf_4;
      v17 = buf_4 + 3;
      v18 = a0123456789abcd_1[v15];
      v19 = buf_8;
      if ( buf_4 + 3 > (int)buf_8 )
      {
        v30[15] = v18;
        oldb.array = bufa;
        *(_QWORD *)&oldb.len = __PAIR64__((unsigned int)buf_8, v33);
        *(runtime_slice_0 *)v30 = runtime_growslice((runtime__type_0 *)&::i, oldb, buf_4 + 3);
        v20 = *(_BYTE **)v30;
        v19 = *(uint8 **)&v30[8];
        v17 = *(_DWORD *)&v30[4] + 1;
        v14 = sa;
        v18 = v30[15];
        v16 = buf_4;
      }
      else
      {
        v20 = bufa;
      }
      v20[v16 + 2] = v18;
      v6 = v17 + 1;
      v21 = a0123456789abcd_1[*v14 & 0xF];
      if ( v17 + 1 > (int)v19 )
      {
        v30[15] = a0123456789abcd_1[*v14 & 0xF];
        olda.array = v20;
        *(_QWORD *)&olda.len = __PAIR64__((unsigned int)v19, v17);
        *(runtime_slice_0 *)v30 = runtime_growslice((runtime__type_0 *)&::i, olda, v17 + 1);
        v20 = *(_BYTE **)v30;
        v19 = *(uint8 **)&v30[8];
        v6 = *(_DWORD *)&v30[4] + 1;
        v14 = sa;
        v21 = v30[15];
      }
      v20[v17] = v21;
    }
    else
    {
      et.array = array;
      *(_QWORD *)&et.len = __PAIR64__((unsigned int)cap, v6);
      *(__uint8 *)&v30[8] = strconv_appendEscapedRune(et, v12, v9, v30[0], v30[4]);
      v6 = *(_DWORD *)&v30[4];
      v20 = *(_BYTE **)v30;
      v19 = *(uint8 **)&v30[8];
      v14 = sa;
    }
    if ( *(_DWORD *)&v30[16] > s_4 )
      runtime_panicslice();
    str = &v14[((int)(*(_DWORD *)&v30[16] - s_4) >> 31) & *(_DWORD *)&v30[16]];
    v9 = quote;
    array = v20;
    cap = v19;
  }
  if ( v6 + 1 > (int)cap )
  {
    oldc.array = array;
    *(_QWORD *)&oldc.len = __PAIR64__((unsigned int)cap, v6);
    v31 = runtime_growslice((runtime__type_0 *)&::i, oldc, v6 + 1);
    array = v31.array;
    cap = (uint8 *)v31.cap;
    v6 = buf_4;
    v9 = quote;
  }
  array[v6] = v9;
  _r5_8.array = cap;
  return _r5_8;
}
// 809894F: variable 'v30' is possibly undefined
// 809897E: variable 'old_4' is possibly undefined
// 809897E: variable 'old_8' is possibly undefined
// 8098983: variable 'old_4a' is possibly undefined

//----- (08098A60) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
__uint8 __golang strconv_appendQuotedRuneWith(__uint8 buf, int32 r, uint8 quote, bool ASCIIonly, bool graphicOnly)
{
  __int32 len; // eax
  __int32 v6; // ecx
  __int32 cap; // edx
  uint8 *array; // ebx
  int32 v9; // eax
  uint8 *v10; // eax
  __int32 v11; // ecx
  _BYTE *v12; // edx
  __uint8 v13; // [esp+0h] [ebp-20h]
  runtime_slice_0 old; // [esp+14h] [ebp-Ch] OVERLAPPED
  __int32 buf_4; // [esp+28h] [ebp+8h]
  __uint8 _r5_8; // [esp+40h] [ebp+20h]

  len = buf.len;
  v6 = buf.len + 1;
  cap = buf.cap;
  if ( buf.len + 1 > buf.cap )
  {
    old = runtime_growslice((runtime__type_0 *)&i, (runtime_slice_0)buf, buf.len + 1);
    array = (uint8 *)old.array;
    cap = old.cap;
    v6 = old.len + 1;
    len = buf.len;
  }
  else
  {
    array = buf.array;
  }
  array[len] = quote;
  v9 = r;
  if ( (unsigned int)r >= 0xD800 && (unsigned int)(r - 57344) > 0x101FFF )
    v9 = 65533;
  v13.array = array;
  *(_QWORD *)&v13.len = __PAIR64__(cap, v6);
  *(__uint8 *)&old.cap = strconv_appendEscapedRune(v13, v9, quote, (bool)old.array, old.len);
  v10 = (uint8 *)old.cap;
  v11 = old.len;
  v12 = old.array;
  if ( old.len + 1 > old.cap )
  {
    buf_4 = old.len;
    old = runtime_growslice((runtime__type_0 *)&i, old, old.len + 1);
    v12 = old.array;
    v10 = (uint8 *)old.cap;
    v11 = buf_4;
  }
  v12[v11] = quote;
  _r5_8.array = v10;
  return _r5_8;
}
// 8098A60: variables would overlap: ^14.12 and ^1C.12

//----- (08098BA0) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
__uint8 __golang strconv_appendEscapedRune(__uint8 buf, int32 r, uint8 quote, bool ASCIIonly, bool graphicOnly)
{
  int32 v5; // ecx
  int v6; // eax
  unsigned __int32 v7; // edx
  unsigned __int32 v8; // ebx
  void *v9; // ebp
  int v10; // eax
  uint8 *v11; // ecx
  void *v12; // edx
  unsigned int v13; // ebx
  __int32 v14; // ebp
  __int32 v15; // edi
  char v16; // al
  unsigned __int32 v17; // edx
  unsigned __int32 v18; // ebx
  void *v19; // ebp
  int v20; // eax
  void *v21; // edx
  unsigned int v22; // ebx
  __int32 v23; // ebp
  __int32 v24; // edi
  char v25; // al
  unsigned __int32 v26; // edx
  unsigned __int32 v27; // ebx
  void *v28; // ebp
  char v29; // cl
  unsigned int v30; // eax
  __int32 v31; // edx
  __int32 v32; // ebx
  char v33; // al
  __int32 v34; // esi
  _BYTE *v35; // edi
  char v36; // cl
  unsigned __int32 v37; // ecx
  unsigned __int32 v38; // edx
  unsigned __int32 v39; // ecx
  unsigned __int32 v40; // ecx
  unsigned __int32 v41; // ecx
  unsigned __int32 v42; // ecx
  unsigned __int32 v43; // ecx
  unsigned __int32 v44; // ecx
  __int32 v45; // eax
  uint8 *v46; // edx
  _BYTE *v47; // ebx
  unsigned __int32 v48; // edx
  uint8 *v49; // ebx
  __int32 len; // eax
  __int32 v51; // edx
  uint8 *v52; // ebx
  _BYTE *array; // ebp
  __uint8 et; // [esp+0h] [ebp-3Ch]
  runtime_slice_0 old; // [esp+4h] [ebp-38h]
  runtime_slice_0 olda; // [esp+4h] [ebp-38h]
  runtime_slice_0 oldb; // [esp+4h] [ebp-38h]
  runtime_slice_0 oldc; // [esp+4h] [ebp-38h]
  runtime_slice_0 oldd; // [esp+4h] [ebp-38h]
  unsigned int cap; // [esp+10h] [ebp-2Ch]
  runtime_slice_0 v61; // [esp+14h] [ebp-28h]
  runtime_slice_0 v62; // [esp+14h] [ebp-28h]
  runtime_slice_0 v63; // [esp+14h] [ebp-28h]
  runtime_slice_0 v64; // [esp+14h] [ebp-28h]
  runtime_slice_0 v65; // [esp+14h] [ebp-28h]
  runtime_slice_0 v66; // [esp+14h] [ebp-28h]
  runtime_slice_0 v67; // [esp+14h] [ebp-28h]
  runtime_slice_0 v68; // [esp+14h] [ebp-28h]
  runtime_slice_0 v69; // [esp+14h] [ebp-28h]
  runtime_slice_0 v70; // [esp+14h] [ebp-28h]
  runtime_slice_0 v71; // [esp+14h] [ebp-28h]
  runtime_slice_0 v72; // [esp+14h] [ebp-28h]
  runtime_slice_0 v73; // [esp+14h] [ebp-28h]
  runtime_slice_0 v74; // [esp+14h] [ebp-28h]
  runtime_slice_0 v75; // [esp+14h] [ebp-28h]
  runtime_slice_0 v76; // [esp+14h] [ebp-28h]
  runtime_slice_0 v77; // [esp+14h] [ebp-28h]
  runtime_slice_0 v78; // [esp+14h] [ebp-28h]
  char v79; // [esp+23h] [ebp-19h]
  char v80; // [esp+23h] [ebp-19h]
  char v81; // [esp+23h] [ebp-19h]
  char v82; // [esp+23h] [ebp-19h]
  __int32 s; // [esp+24h] [ebp-18h]
  __int32 s_0; // [esp+28h] [ebp-14h]
  uint8 runeTmp[4]; // [esp+2Ch] [ebp-10h] BYREF
  __int32 n; // [esp+30h] [ebp-Ch]
  unsigned int v87; // [esp+34h] [ebp-8h]
  unsigned int v88; // [esp+38h] [ebp-4h]
  __int32 buf_4; // [esp+44h] [ebp+8h]
  uint8 *buf_8; // [esp+48h] [ebp+Ch]
  int32 ra; // [esp+4Ch] [ebp+10h]
  __uint8 _r5_8; // [esp+5Ch] [ebp+20h]

  *(_DWORD *)runeTmp = 0;
  v5 = r;
  if ( quote == r || r == 92 )
  {
    len = buf.len;
    v51 = buf.len + 1;
    v52 = (uint8 *)buf.cap;
    if ( buf.len + 1 > buf.cap )
    {
      v78 = runtime_growslice((runtime__type_0 *)&i, (runtime_slice_0)buf, buf.len + 1);
      array = v78.array;
      v52 = (uint8 *)v78.cap;
      v51 = v78.len + 1;
      len = buf.len;
      LOBYTE(v5) = r;
    }
    else
    {
      array = buf.array;
    }
    array[len] = 92;
    if ( v51 + 1 > (int)v52 )
    {
      buf_4 = v51;
      oldd.array = array;
      *(_QWORD *)&oldd.len = __PAIR64__((unsigned int)v52, v51);
      v77 = runtime_growslice((runtime__type_0 *)&i, oldd, v51 + 1);
      array = v77.array;
      v52 = (uint8 *)v77.cap;
      LOBYTE(v5) = r;
      v51 = buf_4;
    }
    array[v51] = v5;
    _r5_8.array = v52;
  }
  else if ( *(&quote + 1) )
  {
    if ( r >= 128 )
      goto LABEL_5;
    if ( !strconv_IsPrint(r) )
    {
      v5 = r;
      goto LABEL_5;
    }
    v45 = buf.len;
    v46 = (uint8 *)buf.cap;
    if ( buf.len + 1 > buf.cap )
    {
      v75 = runtime_growslice((runtime__type_0 *)&i, (runtime_slice_0)buf, buf.len + 1);
      v47 = v75.array;
      v46 = (uint8 *)v75.cap;
      v45 = buf.len;
    }
    else
    {
      v47 = buf.array;
    }
    v47[v45] = r;
    _r5_8.array = v46;
  }
  else
  {
    if ( !strconv_IsPrint(r) && (!*(&quote + 2) || !strconv_isInGraphicList(r)) )
    {
      v5 = r;
LABEL_5:
      if ( v5 > 9 )
      {
        if ( v5 <= 11 )
        {
          if ( v5 == 10 )
          {
            v43 = buf.len + 2;
            v88 = buf.len + 2;
            v38 = buf.cap;
            if ( (unsigned int)(buf.len + 2) > buf.cap )
            {
              v73 = runtime_growslice((runtime__type_0 *)&i, (runtime_slice_0)buf, buf.len + 2);
              v38 = v73.cap;
              v43 = v88;
            }
            if ( v43 > v38 )
              runtime_panicslice();
          }
          else
          {
            v44 = buf.len + 2;
            v88 = buf.len + 2;
            v38 = buf.cap;
            if ( (unsigned int)(buf.len + 2) > buf.cap )
            {
              v74 = runtime_growslice((runtime__type_0 *)&i, (runtime_slice_0)buf, buf.len + 2);
              v38 = v74.cap;
              v44 = v88;
            }
            if ( v44 > v38 )
              runtime_panicslice();
          }
        }
        else if ( v5 == 12 )
        {
          v42 = buf.len + 2;
          v88 = buf.len + 2;
          v38 = buf.cap;
          if ( (unsigned int)(buf.len + 2) > buf.cap )
          {
            v72 = runtime_growslice((runtime__type_0 *)&i, (runtime_slice_0)buf, buf.len + 2);
            v38 = v72.cap;
            v42 = v88;
          }
          if ( v42 > v38 )
            runtime_panicslice();
        }
        else
        {
          if ( v5 != 13 )
            goto LABEL_9;
          v41 = buf.len + 2;
          v88 = buf.len + 2;
          v38 = buf.cap;
          if ( (unsigned int)(buf.len + 2) > buf.cap )
          {
            v71 = runtime_growslice((runtime__type_0 *)&i, (runtime_slice_0)buf, buf.len + 2);
            v38 = v71.cap;
            v41 = v88;
          }
          if ( v41 > v38 )
            runtime_panicslice();
        }
      }
      else
      {
        switch ( v5 )
        {
          case 7:
            v40 = buf.len + 2;
            v88 = buf.len + 2;
            v38 = buf.cap;
            if ( (unsigned int)(buf.len + 2) > buf.cap )
            {
              v70 = runtime_growslice((runtime__type_0 *)&i, (runtime_slice_0)buf, buf.len + 2);
              v38 = v70.cap;
              v40 = v88;
            }
            if ( v40 > v38 )
              runtime_panicslice();
            break;
          case 8:
            v39 = buf.len + 2;
            v88 = buf.len + 2;
            v38 = buf.cap;
            if ( (unsigned int)(buf.len + 2) > buf.cap )
            {
              v69 = runtime_growslice((runtime__type_0 *)&i, (runtime_slice_0)buf, buf.len + 2);
              v38 = v69.cap;
              v39 = v88;
            }
            if ( v39 > v38 )
              runtime_panicslice();
            break;
          case 9:
            v37 = buf.len + 2;
            v88 = buf.len + 2;
            v38 = buf.cap;
            if ( (unsigned int)(buf.len + 2) > buf.cap )
            {
              v68 = runtime_growslice((runtime__type_0 *)&i, (runtime_slice_0)buf, buf.len + 2);
              v38 = v68.cap;
              v37 = v88;
            }
            if ( v37 > v38 )
              runtime_panicslice();
            break;
          default:
LABEL_9:
            if ( v5 < 32 )
            {
              v26 = buf.len + 2;
              v88 = buf.len + 2;
              v27 = buf.cap;
              if ( (unsigned int)(buf.len + 2) > buf.cap )
              {
                v67 = runtime_growslice((runtime__type_0 *)&i, (runtime_slice_0)buf, buf.len + 2);
                v28 = v67.array;
                v27 = v67.cap;
                v26 = v88;
              }
              else
              {
                v28 = buf.array;
              }
              if ( v26 > v27 )
                runtime_panicslice();
              buf.cap = v27;
              runtime_memmove();
              v29 = r;
              v30 = (unsigned __int8)r >> 4;
              if ( v30 >= 0x10 )
                runtime_panicindex();
              v31 = buf.len;
              v32 = buf.len + 3;
              v33 = a0123456789abcd_1[v30];
              v34 = buf.cap;
              if ( buf.len + 3 > buf.cap )
              {
                v82 = v33;
                oldc.array = v28;
                *(_QWORD *)&oldc.len = __PAIR64__(buf.cap, v88);
                v66 = runtime_growslice((runtime__type_0 *)&i, oldc, buf.len + 3);
                v35 = v66.array;
                v34 = v66.cap;
                v32 = v66.len + 1;
                v33 = v82;
                v29 = r;
                v31 = buf.len;
              }
              else
              {
                v35 = v28;
              }
              v35[v31 + 2] = v33;
              v36 = a0123456789abcd_1[v29 & 0xF];
              if ( v32 + 1 > v34 )
              {
                v81 = v36;
                oldb.array = v35;
                *(_QWORD *)&oldb.len = __PAIR64__(v34, v32);
                v65 = runtime_growslice((runtime__type_0 *)&i, oldb, v32 + 1);
                v35 = v65.array;
                v34 = v65.cap;
                v36 = v81;
              }
              v35[v32] = v36;
              v11 = (uint8 *)v34;
              goto LABEL_20;
            }
            if ( v5 <= 1114111 )
            {
              if ( v5 >= 0x10000 )
              {
                v17 = buf.len + 2;
                v88 = buf.len + 2;
                v18 = buf.cap;
                if ( (unsigned int)(buf.len + 2) > buf.cap )
                {
                  v64 = runtime_growslice((runtime__type_0 *)&i, (runtime_slice_0)buf, buf.len + 2);
                  v19 = v64.array;
                  v18 = v64.cap;
                  v17 = v88;
                }
                else
                {
                  v19 = buf.array;
                }
                if ( v17 > v18 )
                  runtime_panicslice();
                runtime_memmove();
                v20 = 28;
                v11 = (uint8 *)v18;
                v21 = v19;
                v22 = v88;
                while ( v20 >= 0 )
                {
                  s = v20;
                  v23 = v22 + 1;
                  v24 = (__int32)v11;
                  v25 = a0123456789abcd_1[(r >> ((unsigned int)v20 >= 0x20 ? -1 : v20)) & 0xF];
                  if ( (int)(v22 + 1) > (int)v11 )
                  {
                    v87 = v22;
                    v80 = v25;
                    olda.array = v21;
                    *(_QWORD *)&olda.len = __PAIR64__((unsigned int)v11, v22);
                    v63 = runtime_growslice((runtime__type_0 *)&i, olda, v22 + 1);
                    v21 = v63.array;
                    v24 = v63.cap;
                    v23 = v63.len + 1;
                    v25 = v80;
                  }
                  *((_BYTE *)v21 + v22) = v25;
                  v20 = s - 4;
                  v11 = (uint8 *)v24;
                  v22 = v23;
                }
                goto LABEL_20;
              }
              v6 = v5;
            }
            else
            {
              v6 = 65533;
            }
            ra = v6;
            v7 = buf.len + 2;
            v88 = buf.len + 2;
            v8 = buf.cap;
            if ( (unsigned int)(buf.len + 2) > buf.cap )
            {
              v62 = runtime_growslice((runtime__type_0 *)&i, (runtime_slice_0)buf, buf.len + 2);
              v9 = v62.array;
              v8 = v62.cap;
              v7 = v88;
            }
            else
            {
              v9 = buf.array;
            }
            if ( v7 > v8 )
              runtime_panicslice();
            runtime_memmove();
            v10 = 12;
            v11 = (uint8 *)v8;
            v12 = v9;
            v13 = v88;
            while ( v10 >= 0 )
            {
              s_0 = v10;
              v14 = v13 + 1;
              v15 = (__int32)v11;
              v16 = a0123456789abcd_1[(ra >> ((unsigned int)v10 >= 0x20 ? -1 : v10)) & 0xF];
              if ( (int)(v13 + 1) > (int)v11 )
              {
                v79 = v16;
                v87 = v13;
                old.array = v12;
                *(_QWORD *)&old.len = __PAIR64__((unsigned int)v11, v13);
                v61 = runtime_growslice((runtime__type_0 *)&i, old, v13 + 1);
                v12 = v61.array;
                v15 = v61.cap;
                v14 = v61.len + 1;
                v16 = v79;
              }
              *((_BYTE *)v12 + v13) = v16;
              v10 = s_0 - 4;
              v11 = (uint8 *)v15;
              v13 = v14;
            }
LABEL_20:
            _r5_8.array = v11;
            return _r5_8;
        }
      }
      buf_8 = (uint8 *)v38;
      runtime_memmove();
      v11 = buf_8;
      goto LABEL_20;
    }
    et.array = runeTmp;
    *(_QWORD *)&et.len = 0x400000004LL;
    cap = unicode_utf8_EncodeRune(et, r);
    if ( cap > 4 )
      goto LABEL_108;
    v48 = buf.len + cap;
    v88 = buf.len + cap;
    v49 = (uint8 *)buf.cap;
    if ( buf.len + cap > buf.cap )
    {
      n = cap;
      v76 = runtime_growslice((runtime__type_0 *)&i, (runtime_slice_0)buf, v48);
      v49 = (uint8 *)v76.cap;
      v48 = v88;
    }
    if ( v48 > (unsigned int)v49 )
LABEL_108:
      runtime_panicslice();
    runtime_memmove();
    _r5_8.array = v49;
  }
  return _r5_8;
}
// 8098BA0: inconsistent variable size for '^50.1(quote)'

//----- (08099680) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
__uint8 __golang strconv_AppendQuote(__uint8 dst, string s)
{
  __uint8 v2; // [esp+18h] [ebp-Ch] OVERLAPPED

  *(_QWORD *)&v2.cap = COERCE_UNSIGNED_INT64(COERCE_LONG_DOUBLE(COERCE_LONG_DOUBLE(strconv_appendQuotedWith(dst, s, 0x22u, (bool)v2.array, v2.len))));
  return v2;
}
// 8099680: variables would overlap: ^20.4 and ^20.8
// 8099680: variables would overlap: ^18.12 and ^20.8

//----- (080996F0) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
__uint8 __golang strconv_AppendQuoteToASCII(__uint8 dst, string s)
{
  __uint8 v2; // [esp+18h] [ebp-Ch] OVERLAPPED

  *(_QWORD *)&v2.cap = COERCE_UNSIGNED_INT64(COERCE_LONG_DOUBLE(COERCE_LONG_DOUBLE(strconv_appendQuotedWith(dst, s, 0x22u, (bool)v2.array, v2.len))));
  return v2;
}
// 80996F0: variables would overlap: ^20.4 and ^20.8
// 80996F0: variables would overlap: ^18.12 and ^20.8

//----- (08099760) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
__uint8 __golang strconv_AppendQuoteRune(__uint8 dst, int32 r)
{
  __uint8 v2; // [esp+14h] [ebp-Ch] OVERLAPPED

  *(_QWORD *)&v2.cap = COERCE_UNSIGNED_INT64(COERCE_LONG_DOUBLE(COERCE_LONG_DOUBLE(strconv_appendQuotedRuneWith(dst, r, 0x27u, (bool)v2.array, v2.len))));
  return v2;
}
// 8099760: variables would overlap: ^1C.4 and ^1C.8
// 8099760: variables would overlap: ^14.12 and ^1C.8

//----- (080997D0) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
__uint8 __golang strconv_AppendQuoteRuneToASCII(__uint8 dst, int32 r)
{
  __uint8 v2; // [esp+14h] [ebp-Ch] OVERLAPPED

  *(_QWORD *)&v2.cap = COERCE_UNSIGNED_INT64(COERCE_LONG_DOUBLE(COERCE_LONG_DOUBLE(strconv_appendQuotedRuneWith(dst, r, 0x27u, (bool)v2.array, v2.len))));
  return v2;
}
// 80997D0: variables would overlap: ^1C.4 and ^1C.8
// 80997D0: variables would overlap: ^14.12 and ^1C.8

//----- (08099840) --------------------------------------------------------
bool __golang strconv_CanBackquote(string s)
{
  uint8 *str; // eax
  __int32 i; // ecx
  int32 v3; // [esp+8h] [ebp-8h]
  __int32 v4; // [esp+Ch] [ebp-4h]
  uint8 *sa; // [esp+14h] [ebp+4h]
  unsigned int s_4; // [esp+18h] [ebp+8h]

  str = s.str;
  for ( i = s.len; i > 0; i = s_4 - v4 )
  {
    sa = str;
    s_4 = i;
    unicode_utf8_DecodeRuneInString((string)__PAIR64__(i, (unsigned int)str), v3, v4);
    if ( v4 > s_4 )
      runtime_panicslice();
    if ( v4 <= 1 )
    {
      if ( v3 == 65533 )
        return 0;
      if ( v3 < 32 && v3 != 9 || v3 == 96 || v3 == 127 )
        return 0;
    }
    else if ( v3 == 65279 )
    {
      return 0;
    }
    str = &sa[v4 & ((int)(v4 - s_4) >> 31)];
  }
  return 1;
}
// 8099898: variable 'v4' is possibly undefined
// 809987A: variable 'v3' is possibly undefined

//----- (08099900) --------------------------------------------------------
__int32 __golang strconv_bsearch16(__uint16 a, uint16 x)
{
  uint16 *array; // ecx
  __int32 len; // edx
  __int32 v4; // ebp
  __int32 v5; // esi
  int v6; // edx
  int v7; // ecx

  array = a.array;
  len = a.len;
  v4 = 0;
  while ( v4 < len )
  {
    v5 = len;
    v6 = (len - v4) / 2;
    if ( (unsigned int)(v6 + v4) >= a.len )
      runtime_panicindex();
    if ( array[v6 + v4] >= x )
    {
      v5 = v6 + v4;
      v7 = v4;
    }
    else
    {
      v7 = v6 + v4 + 1;
    }
    v4 = v7;
    len = v5;
    array = a.array;
  }
  return v4;
}

//----- (08099980) --------------------------------------------------------
__int32 __golang strconv_bsearch32(__uint32 a, uint32 x)
{
  uint32 *array; // ecx
  __int32 len; // edx
  __int32 v4; // ebp
  __int32 v5; // esi
  int v6; // edx
  int v7; // ecx

  array = a.array;
  len = a.len;
  v4 = 0;
  while ( v4 < len )
  {
    v5 = len;
    v6 = (len - v4) / 2;
    if ( (unsigned int)(v6 + v4) >= a.len )
      runtime_panicindex();
    if ( array[v6 + v4] >= x )
    {
      v5 = v6 + v4;
      v7 = v4;
    }
    else
    {
      v7 = v6 + v4 + 1;
    }
    v4 = v7;
    len = v5;
    array = a.array;
  }
  return v4;
}

//----- (080999F0) --------------------------------------------------------
bool __golang strconv_IsPrint(int32 r)
{
  __uint16 a; // [esp+0h] [ebp-3Ch]
  __uint16 aa; // [esp+0h] [ebp-3Ch]
  __int32 v5; // [esp+10h] [ebp-2Ch]
  __int32 v6; // [esp+10h] [ebp-2Ch]
  __int32 v7; // [esp+10h] [ebp-2Ch]
  __int32 v8; // [esp+10h] [ebp-2Ch]
  unsigned int isPrint_len; // [esp+14h] [ebp-28h]
  unsigned int isPrint_len_0; // [esp+18h] [ebp-24h]
  __int32 isNotPrint_len; // [esp+1Ch] [ebp-20h]
  __int32 isNotPrint_len_0; // [esp+20h] [ebp-1Ch]
  __int32 isNotPrint_cap; // [esp+24h] [ebp-18h]
  __int32 isNotPrint_cap_0; // [esp+28h] [ebp-14h]
  uint16 *isPrint_ptr; // [esp+2Ch] [ebp-10h]
  uint32 *isPrint_ptr_0; // [esp+30h] [ebp-Ch]
  uint16 *isNotPrint_ptr; // [esp+34h] [ebp-8h]
  uint16 *isNotPrint_ptr_0; // [esp+38h] [ebp-4h]

  if ( r <= 255 )
    return (unsigned int)(r - 32) <= 0x5E || (unsigned int)(r - 161) <= 0x5E && r != 173;
  if ( (unsigned int)r >= 0x10000 )
  {
    isPrint_len = strconv_isPrint32.len;
    isPrint_ptr_0 = strconv_isPrint32.array;
    isNotPrint_len_0 = strconv_isNotPrint32.len;
    isNotPrint_ptr_0 = strconv_isNotPrint32.array;
    isNotPrint_cap_0 = strconv_isNotPrint32.cap;
    v7 = strconv_bsearch32(strconv_isPrint32, r);
    if ( v7 < (int)isPrint_len )
    {
      if ( (v7 & 0xFFFFFFFE) >= isPrint_len )
        goto LABEL_33;
      if ( r < isPrint_ptr_0[v7 & 0xFFFFFFFE] )
        return 0;
      if ( (v7 | 1u) >= isPrint_len )
LABEL_33:
        runtime_panicindex();
      if ( isPrint_ptr_0[v7 | 1] >= r )
      {
        if ( r >= 0x20000 )
          return 1;
        aa.array = isNotPrint_ptr_0;
        *(_QWORD *)&aa.len = __PAIR64__(isNotPrint_cap_0, isNotPrint_len_0);
        v8 = strconv_bsearch16(aa, r);
        if ( v8 >= isNotPrint_len_0 )
          return 1;
        if ( v8 >= (unsigned int)isNotPrint_len_0 )
          runtime_panicindex();
        return isNotPrint_ptr_0[v8] != (uint16)r;
      }
    }
    return 0;
  }
  isPrint_len_0 = strconv_isPrint16.len;
  isPrint_ptr = strconv_isPrint16.array;
  isNotPrint_cap = strconv_isNotPrint16.cap;
  isNotPrint_ptr = strconv_isNotPrint16.array;
  isNotPrint_len = strconv_isNotPrint16.len;
  v5 = strconv_bsearch16(strconv_isPrint16, r);
  if ( v5 >= (int)isPrint_len_0 )
    return 0;
  if ( (v5 & 0xFFFFFFFE) >= isPrint_len_0 )
    goto LABEL_35;
  if ( (unsigned __int16)r < isPrint_ptr[v5 & 0xFFFFFFFE] )
    return 0;
  if ( (v5 | 1u) >= isPrint_len_0 )
LABEL_35:
    runtime_panicindex();
  if ( isPrint_ptr[v5 | 1] < (unsigned __int16)r )
    return 0;
  a.array = isNotPrint_ptr;
  *(_QWORD *)&a.len = __PAIR64__(isNotPrint_cap, isNotPrint_len);
  v6 = strconv_bsearch16(a, r);
  if ( v6 >= isNotPrint_len )
    return 1;
  if ( v6 >= (unsigned int)isNotPrint_len )
    runtime_panicindex();
  return isNotPrint_ptr[v6] != (uint16)r;
}

//----- (08099C60) --------------------------------------------------------
bool __golang strconv_isInGraphicList(int32 r)
{
  __int32 v2; // [esp+10h] [ebp-4h]

  if ( r > 0xFFFF )
    return 0;
  v2 = strconv_bsearch16(strconv_isGraphic, r);
  if ( v2 >= strconv_isGraphic.len )
    return 0;
  if ( (unsigned int)v2 >= strconv_isGraphic.len )
    runtime_panicindex();
  return (_WORD)r == strconv_isGraphic.array[v2];
}

//----- (08099D00) --------------------------------------------------------
void __golang strconv_init()
{
  string text; // [esp+0h] [ebp-10h]
  string texta; // [esp+0h] [ebp-10h]
  error_0 v2; // [esp+8h] [ebp-8h]
  error_0 v3; // [esp+8h] [ebp-8h]

  if ( strconv_initdone_ <= 1u )
  {
    if ( strconv_initdone_ == 1 )
      runtime_throwinit();
    strconv_initdone_ = 1;
    text.str = (uint8 *)"value out of range";
    text.len = 18;
    v2 = errors_New(text);
    strconv_ErrRange.tab = v2.tab;
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr((uintptr *)&strconv_ErrRange.data, (uintptr)v2.data);
    else
      strconv_ErrRange.data = v2.data;
    texta.str = (uint8 *)"invalid syntax";
    texta.len = 14;
    v3 = errors_New(texta);
    strconv_ErrSyntax.tab = v3.tab;
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr((uintptr *)&strconv_ErrSyntax.data, (uintptr)v3.data);
    else
      strconv_ErrSyntax.data = v3.data;
    strconv_initdone_ = 2;
  }
}

//----- (08099DE0) --------------------------------------------------------
uintptr __golang type__hash_strconv_decimal(strconv_decimal *p, uintptr h)
{
  return runtime_memhash(p, h, 0x32Au);
}

//----- (08099E30) --------------------------------------------------------
bool __golang type__eq_strconv_decimal(strconv_decimal *p, strconv_decimal *q)
{
  bool v2; // [esp+Ch] [ebp-4h]

  runtime_memequal();
  return v2;
}
// 8099E66: variable 'v2' is possibly undefined

//----- (08099E80) --------------------------------------------------------
uintptr __golang type__hash_strconv_extFloat(strconv_extFloat_0 *p, uintptr h)
{
  return runtime_memhash(p, h, 0xDu);
}

//----- (08099ED0) --------------------------------------------------------
bool __golang type__eq_strconv_extFloat(strconv_extFloat_0 *p, strconv_extFloat_0 *q)
{
  bool v2; // [esp+Ch] [ebp-4h]

  runtime_memequal();
  return v2;
}
// 8099F06: variable 'v2' is possibly undefined

//----- (08099F20) --------------------------------------------------------
uintptr __golang type__hash_strconv_leftCheat(strconv_leftCheat_0 *p, uintptr h)
{
  uintptr v2; // [esp+Ch] [ebp-4h]

  v2 = runtime_memhash(p, h, 4u);
  return runtime_strhash(&p->cutoff, v2);
}

//----- (08099F80) --------------------------------------------------------
bool __golang type__eq_strconv_leftCheat(strconv_leftCheat_0 *p, strconv_leftCheat_0 *q)
{
  bool v3; // [esp+10h] [ebp-4h]

  if ( p->delta != q->delta )
    return 0;
  if ( p->cutoff.len != q->cutoff.len )
    return 0;
  runtime_eqstring();
  return v3;
}
// 8099FD3: variable 'v3' is possibly undefined

//----- (08099FF0) --------------------------------------------------------
uintptr __golang type__hash__61_strconv_leftCheat(strconv_leftCheat_0 (*p)[61], uintptr h)
{
  int j; // eax
  __int32 i; // [esp+Ch] [ebp-4h]

  for ( j = 0; j < 61; j = i + 1 )
  {
    i = j;
    h = type__hash_strconv_leftCheat(&(*p)[j], h);
  }
  return h;
}

//----- (0809A050) --------------------------------------------------------
bool __golang type__eq__61_strconv_leftCheat(strconv_leftCheat_0 (*p)[61], strconv_leftCheat_0 (*q)[61])
{
  int j; // eax
  char v3; // [esp+10h] [ebp-8h]
  __int32 i; // [esp+14h] [ebp-4h]

  for ( j = 0; j < 61; j = i + 1 )
  {
    if ( (*p)[j].delta == (*q)[j].delta && (*p)[j].cutoff.len == (*q)[j].cutoff.len )
    {
      i = j;
      runtime_eqstring();
      if ( v3 )
        continue;
    }
    return 0;
  }
  return 1;
}
// 809A0BE: variable 'v3' is possibly undefined

//----- (0809A0E0) --------------------------------------------------------
uintptr __golang type__hash__87_strconv_extFloat(strconv_extFloat (*p)[87], uintptr h)
{
  int j; // eax
  __int32 i; // [esp+Ch] [ebp-4h]

  for ( j = 0; j < 87; j = i + 1 )
  {
    i = j;
    h = type__hash_strconv_extFloat(&(*p)[j], h);
  }
  return h;
}

//----- (0809A140) --------------------------------------------------------
bool __golang type__eq__87_strconv_extFloat(strconv_extFloat (*p)[87], strconv_extFloat (*q)[87])
{
  int j; // edx
  int v3; // edx
  __int32 i; // [esp+0h] [ebp-4h]

  for ( j = 0; j < 87; j = i + 1 )
  {
    i = j;
    v3 = j;
    if ( LODWORD((*p)[v3].mant) != LODWORD((*q)[v3].mant)
      || HIDWORD((*p)[v3].mant) != HIDWORD((*q)[v3].mant)
      || (*p)[v3].exp != (*q)[v3].exp
      || (*p)[v3].neg != (*q)[v3].neg )
    {
      return 0;
    }
  }
  return 1;
}

//----- (0809A1D0) --------------------------------------------------------
void __golang sync___ptr_Map__Load(sync_Map_0 *m, interface_{} key, interface_{} value, bool ok)
{
  char v4; // al
  runtime_hmap *v5; // ecx
  bool r4; // cl
  sync_entry *v7; // eax
  runtime_hmap *v8; // ecx
  char v9; // al
  bool v10; // cl
  sync_entry *v11; // eax
  interface_{} h; // [esp+4h] [ebp-34h]
  runtime_hmap *hb; // [esp+4h] [ebp-34h]
  interface_{} ha; // [esp+4h] [ebp-34h]
  runtime_hmap *hc; // [esp+4h] [ebp-34h]
  _BYTE *v16; // [esp+8h] [ebp-30h]
  runtime_hmap **v17; // [esp+8h] [ebp-30h]
  retval_804ED80 v18; // [esp+Ch] [ebp-2Ch]
  bool read_amended; // [esp+16h] [ebp-22h]
  bool read_amendeda; // [esp+16h] [ebp-22h]
  bool v21; // [esp+17h] [ebp-21h]
  sync_entry *e; // [esp+18h] [ebp-20h]
  sync_entry *ea; // [esp+18h] [ebp-20h]
  interface_{} v24; // [esp+20h] [ebp-18h] BYREF
  interface_{} v25; // [esp+28h] [ebp-10h] BYREF
  interface_{} v26; // [esp+30h] [ebp-8h] BYREF

  sync_atomic___ptr_Value__Load(&m->read, h);
  if ( hb == (runtime_hmap *)&stru_80D4580 )
  {
    v4 = v16[4];
    v5 = *(runtime_hmap **)v16;
  }
  else
  {
    v4 = 0;
    v5 = 0;
  }
  read_amended = v4;
  v24 = key;
  v18 = runtime_mapaccess2((runtime_maptype_0 *)&stru_80CFA80, v5, &v24);
  r4 = v18._r4;
  v7 = *(sync_entry **)v18._r3;
  if ( v18._r4 )
  {
    r4 = 1;
  }
  else if ( read_amended )
  {
    sync___ptr_Mutex__Lock(&m->mu);
    sync_atomic___ptr_Value__Load(&m->read, ha);
    if ( hc == (runtime_hmap *)&stru_80D4580 )
    {
      v8 = *v17;
      v9 = *((_BYTE *)v17 + 4);
    }
    else
    {
      v8 = 0;
      v9 = 0;
    }
    read_amendeda = v9;
    v26 = key;
    v18 = runtime_mapaccess2((runtime_maptype_0 *)&stru_80CFA80, v8, &v26);
    v10 = v18._r4;
    v11 = *(sync_entry **)v18._r3;
    if ( v18._r4 )
    {
      v10 = 1;
    }
    else if ( read_amendeda )
    {
      v25 = key;
      v18 = runtime_mapaccess2((runtime_maptype_0 *)&stru_80CFA80, (runtime_hmap *)m->dirty, &v25);
      ea = *(sync_entry **)v18._r3;
      sync___ptr_Map__missLocked(m);
      v10 = v18._r4;
      v11 = ea;
    }
    e = v11;
    v21 = v10;
    sync___ptr_Mutex__Unlock(&m->mu);
    r4 = v21;
    v7 = e;
  }
  if ( r4 )
    sync___ptr_entry__load(v7, ha, (bool)v18._r3);
}
// 809A1F9: variable 'h' is possibly undefined
// 809A20E: variable 'hb' is possibly undefined
// 809A214: variable 'v16' is possibly undefined
// 809A263: variable 'ha' is possibly undefined
// 809A2CF: variable 'hc' is possibly undefined
// 809A2D5: variable 'v17' is possibly undefined

//----- (0809A3D0) --------------------------------------------------------
void __golang sync___ptr_entry__load(sync_entry *e, interface_{} value, bool ok)
{
  sync_atomic_LoadPointer();
}

//----- (0809A440) --------------------------------------------------------
void __golang sync___ptr_Map__Store(sync_Map_0 *m, interface_{} key, interface_{} value)
{
  runtime_hmap *v3; // eax
  runtime_hmap *v4; // ecx
  char v5; // al
  uintptr data; // eax
  interface_{} h; // [esp+4h] [ebp-5Ch]
  runtime_hmap *he; // [esp+4h] [ebp-5Ch]
  interface_{} ha; // [esp+4h] [ebp-5Ch]
  runtime_hmap *hf; // [esp+4h] [ebp-5Ch]
  bool hb; // [esp+4h] [ebp-5Ch]
  char hg; // [esp+4h] [ebp-5Ch]
  runtime_hmap *hc; // [esp+4h] [ebp-5Ch]
  runtime_hmap *hd; // [esp+4h] [ebp-5Ch]
  runtime_hmap **x; // [esp+8h] [ebp-58h]
  int xa; // [esp+8h] [ebp-58h]
  long double xb; // [esp+8h] [ebp-58h]
  interface_{} xc; // [esp+8h] [ebp-58h]
  runtime_eface_0 x_4; // [esp+Ch] [ebp-54h]
  runtime_eface_0 x_4a; // [esp+Ch] [ebp-54h]
  uintptr *x_4b; // [esp+Ch] [ebp-54h]
  uintptr *x_4c; // [esp+Ch] [ebp-54h]
  bool read_amended; // [esp+17h] [ebp-49h]
  sync_entry *_r1; // [esp+18h] [ebp-48h]
  map_interface_{}__sync_entry read_m; // [esp+1Ch] [ebp-44h]
  sync_entry *e; // [esp+20h] [ebp-40h]
  sync_atomic_Value *v; // [esp+24h] [ebp-3Ch]
  interface_{} *_value; // [esp+28h] [ebp-38h]
  interface_{} *_i; // [esp+2Ch] [ebp-34h]
  interface_{} v30; // [esp+30h] [ebp-30h] BYREF
  map_interface_{}__sync_entry elem; // [esp+38h] [ebp-28h] BYREF
  char v32; // [esp+3Ch] [ebp-24h]
  runtime_eface_0 v33; // [esp+40h] [ebp-20h] BYREF
  interface_{} v34; // [esp+48h] [ebp-18h] BYREF
  interface_{} v35; // [esp+50h] [ebp-10h] BYREF
  interface_{} v36; // [esp+58h] [ebp-8h] BYREF

  h._type = (runtime__type_0 *)runtime_newobject((runtime__type_0 *)&stru_80CECA0);
  _value = (interface_{} *)h._type;
  h._type->size = (uintptr)value._type;
  if ( *(_DWORD *)&runtime_writeBarrier.enabled )
    runtime_writebarrierptr(&h._type->ptrdata, (uintptr)value.data);
  else
    h._type->ptrdata = (uintptr)value.data;
  v = &m->read;
  sync_atomic___ptr_Value__Load(&m->read, h);
  if ( he == (runtime_hmap *)&stru_80D4580 )
    v3 = *x;
  else
    v3 = 0;
  v36 = key;
  x_4 = (runtime_eface_0)runtime_mapaccess2((runtime_maptype_0 *)&stru_80CFA80, v3, &v36);
  if ( !LOBYTE(x_4.data) || (LOBYTE(ha.data) = sync___ptr_entry__tryStore((sync_entry *)x_4._type->size, _value)) == 0 )
  {
    sync___ptr_Mutex__Lock(&m->mu);
    sync_atomic___ptr_Value__Load(v, ha);
    if ( hf == (runtime_hmap *)&stru_80D4580 )
    {
      v4 = *(runtime_hmap **)xa;
      v5 = *(_BYTE *)(xa + 4);
    }
    else
    {
      v5 = 0;
      v4 = 0;
    }
    read_amended = v5;
    read_m = (map_interface_{}__sync_entry)v4;
    v35 = key;
    x_4a = (runtime_eface_0)runtime_mapaccess2((runtime_maptype_0 *)&stru_80CFA80, v4, &v35);
    if ( LOBYTE(x_4a.data) )
    {
      e = (sync_entry *)x_4a._type->size;
      sync___ptr_entry__unexpungeLocked((sync_entry *)x_4a._type->size, hb);
      if ( hg )
      {
        v34 = key;
        x_4b = (uintptr *)runtime_mapassign((runtime_maptype_0 *)&stru_80CFA80, (runtime_hmap *)m->dirty, &v34);
        if ( *(_DWORD *)&runtime_writeBarrier.enabled )
          runtime_writebarrierptr(x_4b, (uintptr)e);
        else
          *x_4b = (uintptr)e;
      }
      sync___ptr_entry__storeLocked(e, _value);
    }
    else
    {
      v33 = key;
      *(retval_804ED80 *)((char *)&xb + 4) = runtime_mapaccess2(
                                               (runtime_maptype_0 *)&stru_80CFA80,
                                               (runtime_hmap *)m->dirty,
                                               &v33);
      if ( BYTE8(xb) )
      {
        sync___ptr_entry__storeLocked(*(sync_entry **)DWORD1(xb), _value);
      }
      else
      {
        if ( !read_amended )
        {
          sync___ptr_Map__dirtyLocked(m);
          elem = read_m;
          v32 = 1;
          runtime_convT2E((runtime__type_0 *)&stru_80D4580, &elem, *(runtime_eface_0 *)&xb);
          sync_atomic___ptr_Value__Store(v, xc);
        }
        v30 = key;
        hc = (runtime_hmap *)runtime_newobject((runtime__type_0 *)&stru_80CECA0);
        data = (uintptr)_value->data;
        _i = (interface_{} *)hc;
        hc->count = (__int32)_value->_type;
        if ( *(_DWORD *)&runtime_writeBarrier.enabled )
          runtime_writebarrierptr((uintptr *)&hc->flags, data);
        else
          *(_DWORD *)&hc->flags = data;
        hd = (runtime_hmap *)runtime_newobject((runtime__type_0 *)&stru_80D1CE0);
        _r1 = (sync_entry *)hd;
        if ( *(_DWORD *)&runtime_writeBarrier.enabled )
          runtime_writebarrierptr((uintptr *)hd, (uintptr)_i);
        else
          hd->count = (__int32)_i;
        x_4c = (uintptr *)runtime_mapassign((runtime_maptype_0 *)&stru_80CFA80, (runtime_hmap *)m->dirty, &v30);
        if ( *(_DWORD *)&runtime_writeBarrier.enabled )
          runtime_writebarrierptr(x_4c, (uintptr)_r1);
        else
          *x_4c = (uintptr)_r1;
      }
    }
    sync___ptr_Mutex__Unlock(&m->mu);
  }
}
// 809A49D: variable 'h' is possibly undefined
// 809A4B2: variable 'he' is possibly undefined
// 809A4B8: variable 'x' is possibly undefined
// 809A50A: variable 'ha' is possibly undefined
// 809A51F: variable 'hf' is possibly undefined
// 809A525: variable 'xa' is possibly undefined
// 809A577: variable 'hb' is possibly undefined
// 809A583: variable 'hg' is possibly undefined
// 809A765: variable 'xb' is possibly undefined
// 809A781: variable 'xc' is possibly undefined

//----- (0809A7F0) --------------------------------------------------------
bool __golang sync___ptr_entry__tryStore(sync_entry *e, interface_{} *i)
{
  void *v2; // eax
  void *old; // [esp+4h] [ebp-Ch]
  void *olda; // [esp+4h] [ebp-Ch]

  sync_atomic_LoadPointer();
  v2 = old;
  if ( (void *)sync_expunged == old )
    return 0;
  while ( !sync_atomic_CompareAndSwapPointer(&e->p, v2, i) )
  {
    sync_atomic_LoadPointer();
    v2 = olda;
    if ( (void *)sync_expunged == olda )
      return 0;
  }
  return 1;
}
// 809A813: variable 'old' is possibly undefined
// 809A84E: variable 'olda' is possibly undefined

//----- (0809A890) --------------------------------------------------------
void __golang sync___ptr_entry__unexpungeLocked(sync_entry *e, bool wasExpunged)
{
  sync_atomic_CompareAndSwapPointer(&e->p, (void *)sync_expunged, 0);
}

//----- (0809A8E0) --------------------------------------------------------
void __golang sync___ptr_entry__storeLocked(sync_entry *e, interface_{} *i)
{
  sync_atomic_StorePointer(&e->p, i);
}

//----- (0809A920) --------------------------------------------------------
void __golang sync___ptr_Map__LoadOrStore(
        sync_Map_0 *m,
        interface_{} key,
        interface_{} value,
        interface_{} actual,
        bool loaded)
{
  runtime_hmap *v5; // eax
  runtime_hmap *v6; // ecx
  char v7; // al
  _DWORD *v8; // eax
  interface_{} h; // [esp+4h] [ebp-64h]
  runtime_hmap *hd; // [esp+4h] [ebp-64h]
  interface_{} ha; // [esp+4h] [ebp-64h]
  runtime_hmap *he; // [esp+4h] [ebp-64h]
  bool hb; // [esp+4h] [ebp-64h]
  char hf; // [esp+4h] [ebp-64h]
  runtime_hmap *hc; // [esp+4h] [ebp-64h]
  runtime_hmap **x; // [esp+8h] [ebp-60h]
  int xa; // [esp+8h] [ebp-60h]
  long double xb; // [esp+8h] [ebp-60h]
  interface_{} xc; // [esp+8h] [ebp-60h]
  runtime_eface_0 x_4; // [esp+Ch] [ebp-5Ch]
  runtime_eface_0 x_4a; // [esp+Ch] [ebp-5Ch]
  uintptr *x_4b; // [esp+Ch] [ebp-5Ch]
  bool v23; // [esp+14h] [ebp-54h]
  char v24; // [esp+15h] [ebp-53h]
  bool v25; // [esp+18h] [ebp-50h]
  bool read_amended; // [esp+1Ah] [ebp-4Eh]
  sync_entry *_r1; // [esp+1Ch] [ebp-4Ch]
  map_interface_{}__sync_entry read_m; // [esp+20h] [ebp-48h]
  sync_entry *e; // [esp+24h] [ebp-44h]
  sync_atomic_Value *v; // [esp+30h] [ebp-38h]
  interface_{} *_i; // [esp+34h] [ebp-34h]
  interface_{} v32; // [esp+38h] [ebp-30h] BYREF
  map_interface_{}__sync_entry elem; // [esp+40h] [ebp-28h] BYREF
  char v34; // [esp+44h] [ebp-24h]
  runtime_eface_0 v35; // [esp+48h] [ebp-20h] BYREF
  interface_{} v36; // [esp+50h] [ebp-18h] BYREF
  interface_{} v37; // [esp+58h] [ebp-10h] BYREF
  interface_{} v38; // [esp+60h] [ebp-8h] BYREF

  v = &m->read;
  sync_atomic___ptr_Value__Load(&m->read, h);
  if ( hd == (runtime_hmap *)&stru_80D4580 )
    v5 = *x;
  else
    v5 = 0;
  v38 = key;
  x_4 = (runtime_eface_0)runtime_mapaccess2((runtime_maptype_0 *)&stru_80CFA80, v5, &v38);
  if ( !LOBYTE(x_4.data)
    || (sync___ptr_entry__tryLoadOrStore((sync_entry *)x_4._type->size, value, x_4, v23, v25), !v24) )
  {
    sync___ptr_Mutex__Lock(&m->mu);
    sync_atomic___ptr_Value__Load(v, ha);
    if ( he == (runtime_hmap *)&stru_80D4580 )
    {
      v6 = *(runtime_hmap **)xa;
      v7 = *(_BYTE *)(xa + 4);
    }
    else
    {
      v7 = 0;
      v6 = 0;
    }
    read_amended = v7;
    read_m = (map_interface_{}__sync_entry)v6;
    v37 = key;
    x_4a = (runtime_eface_0)runtime_mapaccess2((runtime_maptype_0 *)&stru_80CFA80, v6, &v37);
    if ( LOBYTE(x_4a.data) )
    {
      e = (sync_entry *)x_4a._type->size;
      sync___ptr_entry__unexpungeLocked((sync_entry *)x_4a._type->size, hb);
      if ( hf )
      {
        v36 = key;
        x_4a._type = (runtime__type_0 *)runtime_mapassign(
                                          (runtime_maptype_0 *)&stru_80CFA80,
                                          (runtime_hmap *)m->dirty,
                                          &v36);
        if ( *(_DWORD *)&runtime_writeBarrier.enabled )
          runtime_writebarrierptr(&x_4a._type->size, (uintptr)e);
        else
          x_4a._type->size = (uintptr)e;
      }
      sync___ptr_entry__tryLoadOrStore(e, value, x_4a, v23, v25);
    }
    else
    {
      v35 = key;
      *(retval_804ED80 *)((char *)&xb + 4) = runtime_mapaccess2(
                                               (runtime_maptype_0 *)&stru_80CFA80,
                                               (runtime_hmap *)m->dirty,
                                               &v35);
      if ( BYTE8(xb) )
      {
        sync___ptr_entry__tryLoadOrStore(
          *(sync_entry **)DWORD1(xb),
          value,
          *(interface_{} *)((char *)&xb + 4),
          v23,
          v25);
        sync___ptr_Map__missLocked(m);
      }
      else
      {
        if ( !read_amended )
        {
          sync___ptr_Map__dirtyLocked(m);
          elem = read_m;
          v34 = 1;
          runtime_convT2E((runtime__type_0 *)&stru_80D4580, &elem, *(runtime_eface_0 *)&xb);
          sync_atomic___ptr_Value__Store(v, xc);
        }
        v32 = key;
        v8 = runtime_newobject((runtime__type_0 *)&stru_80CECA0);
        _i = (interface_{} *)v8;
        *v8 = value._type;
        if ( *(_DWORD *)&runtime_writeBarrier.enabled )
          runtime_writebarrierptr(v8 + 1, (uintptr)value.data);
        else
          v8[1] = value.data;
        hc = (runtime_hmap *)runtime_newobject((runtime__type_0 *)&stru_80D1CE0);
        _r1 = (sync_entry *)hc;
        if ( *(_DWORD *)&runtime_writeBarrier.enabled )
          runtime_writebarrierptr((uintptr *)hc, (uintptr)_i);
        else
          hc->count = (__int32)_i;
        x_4b = (uintptr *)runtime_mapassign((runtime_maptype_0 *)&stru_80CFA80, (runtime_hmap *)m->dirty, &v32);
        if ( *(_DWORD *)&runtime_writeBarrier.enabled )
          runtime_writebarrierptr(x_4b, (uintptr)_r1);
        else
          *x_4b = (uintptr)_r1;
      }
    }
    sync___ptr_Mutex__Unlock(&m->mu);
  }
}
// 809A949: variable 'h' is possibly undefined
// 809A95E: variable 'hd' is possibly undefined
// 809A964: variable 'x' is possibly undefined
// 809A9B6: variable 'ha' is possibly undefined
// 809A9CB: variable 'he' is possibly undefined
// 809A9D1: variable 'xa' is possibly undefined
// 809AA23: variable 'hb' is possibly undefined
// 809AA2F: variable 'hf' is possibly undefined
// 809AA48: variable 'v23' is possibly undefined
// 809AA48: variable 'v25' is possibly undefined
// 809AC67: variable 'xb' is possibly undefined
// 809AC83: variable 'xc' is possibly undefined
// 809AD11: variable 'v24' is possibly undefined

//----- (0809AD50) --------------------------------------------------------
void __golang sync___ptr_entry__tryLoadOrStore(
        sync_entry *e,
        interface_{} i,
        interface_{} actual,
        bool loaded,
        bool ok)
{
  interface_{} *v5; // eax
  void *old; // [esp+4h] [ebp-10h]
  _DWORD *olda; // [esp+4h] [ebp-10h]
  void *oldb; // [esp+4h] [ebp-10h]
  interface_{} *_ic; // [esp+10h] [ebp-4h]

  sync_atomic_LoadPointer();
  if ( (void *)sync_expunged != old && !old )
  {
    olda = runtime_newobject((runtime__type_0 *)&stru_80CECA0);
    v5 = (interface_{} *)olda;
    _ic = (interface_{} *)olda;
    *olda = i._type;
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
    {
      runtime_writebarrierptr(olda + 1, (uintptr)i.data);
      v5 = _ic;
    }
    else
    {
      olda[1] = i.data;
    }
    while ( !sync_atomic_CompareAndSwapPointer(&e->p, 0, v5) )
    {
      sync_atomic_LoadPointer();
      if ( (void *)sync_expunged == oldb || oldb )
        break;
      v5 = _ic;
    }
  }
}
// 809AD83: variable 'old' is possibly undefined
// 809AE04: variable 'oldb' is possibly undefined

//----- (0809AED0) --------------------------------------------------------
void __golang sync___ptr_Map__missLocked(sync_Map_0 *m)
{
  __int32 v1; // ecx
  map_interface_{}__sync_entry dirty; // edx
  __int32 count; // edx
  sync_Map_0 *v4; // eax
  interface_{} x; // [esp+8h] [ebp-14h]
  interface_{} xa; // [esp+8h] [ebp-14h]
  map_interface_{}__sync_entry elem; // [esp+14h] [ebp-8h] BYREF
  char v8; // [esp+18h] [ebp-4h]

  v1 = m->misses + 1;
  m->misses = v1;
  dirty = m->dirty;
  if ( dirty )
    count = dirty->count;
  else
    count = 0;
  if ( v1 >= count )
  {
    elem = 0;
    v8 = 0;
    elem = m->dirty;
    runtime_convT2E((runtime__type_0 *)&stru_80D4580, &elem, x);
    sync_atomic___ptr_Value__Store(&m->read, xa);
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
    {
      runtime_writebarrierptr((uintptr *)&m->dirty, 0);
      v4 = m;
    }
    else
    {
      v4 = m;
      m->dirty = 0;
    }
    v4->misses = 0;
  }
}
// 809AF35: variable 'x' is possibly undefined
// 809AF54: variable 'xa' is possibly undefined

//----- (0809AFB0) --------------------------------------------------------
void __golang sync___ptr_Map__dirtyLocked(sync_Map_0 *m)
{
  runtime_hmap *v1; // eax
  __int32 count; // ecx
  int64 hint; // [esp+4h] [ebp-60h]
  const runtime__type_0 *hintb; // [esp+4h] [ebp-60h]
  bool hinta; // [esp+4h] [ebp-60h]
  runtime_hmap **hint_4; // [esp+8h] [ebp-5Ch]
  runtime_hmap *h; // [esp+Ch] [ebp-58h]
  hash<interface {},*sync_entry> *src; // [esp+14h] [ebp-50h]
  runtime_hmap *read_m; // [esp+18h] [ebp-4Ch]
  uint8 *k_type; // [esp+1Ch] [ebp-48h]
  uint8 *k_data; // [esp+20h] [ebp-44h]
  sync_entry *e; // [esp+24h] [ebp-40h]
  int key[2]; // [esp+2Ch] [ebp-38h] BYREF
  runtime_hiter it; // [esp+34h] [ebp-30h] BYREF

  if ( !m->dirty )
  {
    sync_atomic___ptr_Value__Load(&m->read, (interface_{})hint);
    if ( hintb == &stru_80D4580 )
      v1 = *hint_4;
    else
      v1 = 0;
    read_m = v1;
    if ( v1 )
      count = v1->count;
    else
      count = 0;
    src = (hash<interface {},*sync_entry> *)runtime_makemap((runtime_maptype_0 *)&stru_80CFA80, count, 0, 0);
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr((uintptr *)&m->dirty, (uintptr)src);
    else
      m->dirty = src;
    ((void (*)(void))loc_808FD84)();
    runtime_mapiterinit((runtime_maptype_0 *)&stru_80CFA80, read_m, &it);
    while ( it.key )
    {
      k_type = *(uint8 **)it.key;
      k_data = (uint8 *)*((_DWORD *)it.key + 1);
      e = *(sync_entry **)it.value;
      sync___ptr_entry__tryExpungeLocked(*(sync_entry **)it.value, hinta);
      if ( !hinta )
      {
        key[0] = (int)k_type;
        key[1] = (int)k_data;
        h = (runtime_hmap *)runtime_mapassign((runtime_maptype_0 *)&stru_80CFA80, (runtime_hmap *)m->dirty, key);
        if ( *(_DWORD *)&runtime_writeBarrier.enabled )
          runtime_writebarrierptr((uintptr *)h, (uintptr)e);
        else
          h->count = (__int32)e;
      }
      runtime_mapiternext(&it);
    }
  }
}
// 809AFE5: variable 'hint' is possibly undefined
// 809AFFA: variable 'hintb' is possibly undefined
// 809B000: variable 'hint_4' is possibly undefined
// 809B0AF: variable 'hinta' is possibly undefined

//----- (0809B160) --------------------------------------------------------
void __golang sync___ptr_entry__tryExpungeLocked(sync_entry *e, bool isExpunged)
{
  void *old; // [esp+4h] [ebp-Ch]

  do
    sync_atomic_LoadPointer();
  while ( !old && !sync_atomic_CompareAndSwapPointer(&e->p, 0, (void *)sync_expunged) );
}
// 809B19B: variable 'old' is possibly undefined

//----- (0809B1F0) --------------------------------------------------------
void __golang sync___ptr_Mutex__Lock(sync_Mutex_0 *m)
{
  int32 state; // ecx
  __int32 v2; // edx
  bool i; // bp
  bool v4; // al
  char v5; // [esp+Ch] [ebp-18h]
  bool awoke; // [esp+13h] [ebp-11h]
  int32 newa; // [esp+1Ch] [ebp-8h]
  __int32 iter; // [esp+20h] [ebp-4h]

  sync_atomic_CompareAndSwapInt32();
  if ( !v5 )
  {
    state = m->state;
    v2 = 0;
    for ( i = 0; ; i = awoke )
    {
      while ( 1 )
      {
        iter = v2;
        newa = state;
        if ( (state & 5) == 1 && sync_runtime_canSpin(v2) )
          break;
        sync_atomic_CompareAndSwapInt32();
        state = m->state;
        v2 = iter;
      }
      v4 = i;
      if ( (newa & 2) == 0 )
      {
        if ( newa >> 3 )
        {
          sync_atomic_CompareAndSwapInt32();
          v4 = 0;
        }
      }
      awoke = v4;
      sync_runtime_doSpin();
      v2 = iter + 1;
      state = m->state;
    }
  }
}
// 809B28A: conditional instruction was optimized away because bl.1==0
// 809B29B: conditional instruction was optimized away because bp.1==0
// 809B2C3: conditional instruction was optimized away because %var_18.1==0
// 809B418: conditional instruction was optimized away because %awoke.1==0
// 809B47A: conditional instruction was optimized away because %var_18.1==0
// 809B22E: variable 'v5' is possibly undefined

//----- (0809B4F0) --------------------------------------------------------
void __golang sync___ptr_Mutex__Unlock(sync_Mutex_0 *m)
{
  int32 state; // eax
  interface_{} addr; // [esp+0h] [ebp-10h]
  int32 v3; // [esp+8h] [ebp-8h]
  char v4; // [esp+Ch] [ebp-4h]

  sync_atomic_AddInt32();
  state = v3;
  if ( ((v3 + 1) & 1) == 0 )
  {
    addr._type = (runtime__type_0 *)&t;
    addr.data = &sync_statictmp_3;
    runtime_gopanic(addr);
    BUG();
  }
  if ( (v3 & 4) != 0 )
  {
    sync_runtime_Semrelease(&m->sema, 1);
  }
  else
  {
    while ( state >> 3 && (state & 7) == 0 )
    {
      sync_atomic_CompareAndSwapInt32();
      if ( v4 )
      {
        sync_runtime_Semrelease(&m->sema, 0);
        return;
      }
      state = m->state;
    }
  }
}
// 809B51F: variable 'v3' is possibly undefined
// 809B56F: variable 'v4' is possibly undefined

//----- (0809B5D0) --------------------------------------------------------
void __golang sync___ptr_Once__Do(sync_Once_0 *o, func() f)
{
  int v2; // eax
  int v3; // eax
  sync_Mutex_0 *m; // [esp+0h] [ebp-14h]
  runtime_funcval *fn; // [esp+4h] [ebp-10h]

  sync_atomic_LoadUint32();
  if ( fn == (runtime_funcval *)1 )
  {
    runtime_deferreturn((uintptr)&o->done);
  }
  else
  {
    sync___ptr_Mutex__Lock(&o->m);
    runtime_deferproc(4, (runtime_funcval *)&len);
    if ( !v2 && !o->done )
    {
      runtime_deferproc(8, (runtime_funcval *)&stru_80E7D10);
      if ( !v3 )
        (*(void (**)(void))f)();
    }
    runtime_deferreturn((uintptr)m);
  }
}
// 809B605: variable 'fn' is possibly undefined
// 809B637: variable 'v2' is possibly undefined
// 809B645: variable 'm' is possibly undefined
// 809B676: variable 'v3' is possibly undefined

//----- (0809B6B0) --------------------------------------------------------
void __golang sync___ptr_Pool__Put(sync_Pool_0 *p, interface_{} x)
{
  void *data; // ecx
  runtime__type_0 *type; // edx
  sync_poolLocal *v4; // eax
  interface_{} *array; // ecx
  __int32 len; // edx
  __int32 cap; // ebx
  uintptr *p_data; // ecx
  interface_{} *v9; // eax
  __int32 v10; // ecx
  sync_poolLocal *v11; // ebx
  sync_poolLocal *src; // [esp+4h] [ebp-30h]
  runtime_slice_0 srca; // [esp+4h] [ebp-30h]
  runtime_slice_0 v14; // [esp+14h] [ebp-20h]
  sync_poolLocal *l; // [esp+24h] [ebp-10h]
  runtime__type_0 *xa; // [esp+3Ch] [ebp+8h]
  uintptr x_4; // [esp+40h] [ebp+Ch]

  if ( x._type )
  {
    src = sync___ptr_Pool__pin(p);
    l = src;
    if ( src->poolLocalInternal.private._type )
    {
      data = x.data;
      type = x._type;
    }
    else
    {
      src->poolLocalInternal.private._type = x._type;
      if ( *(_DWORD *)&runtime_writeBarrier.enabled )
        runtime_writebarrierptr((uintptr *)&src->poolLocalInternal.private.data, (uintptr)x.data);
      else
        src->poolLocalInternal.private.data = x.data;
      data = 0;
      type = 0;
    }
    x_4 = (uintptr)data;
    xa = type;
    sync_runtime_procUnpin();
    if ( xa )
    {
      sync___ptr_Mutex__Lock(&l->poolLocalInternal.Mutex);
      v4 = l;
      array = l->poolLocalInternal.shared.array;
      len = l->poolLocalInternal.shared.len;
      cap = l->poolLocalInternal.shared.cap;
      if ( len + 1 > cap )
      {
        srca.array = l->poolLocalInternal.shared.array;
        *(_QWORD *)&srca.len = __PAIR64__(cap, len);
        v14 = runtime_growslice((runtime__type_0 *)&stru_80CECA0, srca, len + 1);
        v9 = (interface_{} *)v14.array;
        v10 = v14.len;
        v11 = l;
        l->poolLocalInternal.shared.cap = v14.cap;
        if ( *(_DWORD *)&runtime_writeBarrier.enabled )
        {
          runtime_writebarrierptr((uintptr *)&l->poolLocalInternal.shared, (uintptr)v14.array);
          v9 = (interface_{} *)v14.array;
          v10 = v14.len;
          v11 = l;
        }
        else
        {
          l->poolLocalInternal.shared.array = (interface_{} *)v14.array;
        }
        len = v10;
        array = v9;
        v4 = v11;
      }
      v4->poolLocalInternal.shared.len = len + 1;
      array[len]._type = xa;
      p_data = (uintptr *)&array[len].data;
      if ( *(_DWORD *)&runtime_writeBarrier.enabled )
        runtime_writebarrierptr(p_data, x_4);
      else
        *p_data = x_4;
      sync___ptr_Mutex__Unlock(&l->poolLocalInternal.Mutex);
    }
  }
}

//----- (0809B840) --------------------------------------------------------
interface_{} __golang sync___ptr_Pool__Get(sync_Pool_0 *p)
{
  runtime__type_0 *v1; // eax
  void *v2; // ecx
  void (*New)(interface_{} *); // edx
  unsigned __int32 len; // edx
  unsigned __int32 v5; // ebx
  interface_{} *v6; // ecx
  uint8 *type; // edx
  uint8 *data; // ecx
  sync_Pool_0 *v9; // [esp+0h] [ebp-1Ch]
  interface_{} src; // [esp+4h] [ebp-18h]
  uint8 *x_type; // [esp+Ch] [ebp-10h]
  uint8 *x_typea; // [esp+Ch] [ebp-10h]
  uint8 *x_data; // [esp+10h] [ebp-Ch]
  uint8 *x_dataa; // [esp+10h] [ebp-Ch]
  sync_poolLocal *l; // [esp+14h] [ebp-8h]
  interface_{} _r0; // [esp+24h] [ebp+8h]

  src._type = (runtime__type_0 *)sync___ptr_Pool__pin(p);
  l = (sync_poolLocal *)src._type;
  x_type = (uint8 *)src._type->size;
  x_data = (uint8 *)src._type->ptrdata;
  src._type->size = 0;
  if ( *(_DWORD *)&runtime_writeBarrier.enabled )
    runtime_writebarrierptr(&src._type->ptrdata, 0);
  else
    src._type->ptrdata = 0;
  sync_runtime_procUnpin();
  v1 = (runtime__type_0 *)x_type;
  if ( x_type )
  {
    v2 = x_data;
  }
  else
  {
    sync___ptr_Mutex__Lock(&l->poolLocalInternal.Mutex);
    len = l->poolLocalInternal.shared.len;
    v5 = len - 1;
    if ( (int)(len - 1) < 0 )
    {
      data = x_data;
      type = 0;
    }
    else
    {
      if ( v5 >= len )
        runtime_panicindex();
      v6 = &l->poolLocalInternal.shared.array[len - 1];
      type = (uint8 *)v6->_type;
      data = (uint8 *)v6->data;
      l->poolLocalInternal.shared.len = v5;
    }
    x_dataa = data;
    x_typea = type;
    sync___ptr_Mutex__Unlock(&l->poolLocalInternal.Mutex);
    v1 = (runtime__type_0 *)x_typea;
    if ( x_typea )
    {
      v2 = x_dataa;
    }
    else
    {
      sync___ptr_Pool__getSlow(p, src);
      v2 = src.data;
      v1 = src._type;
    }
  }
  if ( !v1 )
  {
    New = p->New;
    if ( New )
    {
      (*(void (**)(void))New)();
      v1 = (runtime__type_0 *)v9;
      v2 = src._type;
    }
  }
  _r0._type = v1;
  _r0.data = v2;
  return _r0;
}
// 809B8C8: variable 'v9' is possibly undefined
// 809B8CB: variable 'src' is possibly undefined

//----- (0809B970) --------------------------------------------------------
void __golang sync___ptr_Pool__getSlow(sync_Pool_0 *p, interface_{} x)
{
  __int32 j; // eax
  int v3; // eax
  int v4; // edx
  unsigned int v5; // edx
  unsigned int v6; // ebp
  __int32 v7; // [esp+4h] [ebp-24h]
  __int32 pid; // [esp+Ch] [ebp-1Ch]
  __int32 i; // [esp+10h] [ebp-18h]
  char *l; // [esp+14h] [ebp-14h]
  sync_Mutex_0 *m; // [esp+20h] [ebp-8h]
  char *v12; // [esp+24h] [ebp-4h]

  sync_atomic_LoadUintptr();
  l = (char *)p->local;
  pid = sync_runtime_procPin();
  sync_runtime_procUnpin();
  for ( j = 0; j < v7; j = i + 1 )
  {
    if ( !v7 )
      runtime_panicdivide();
    i = j;
    v3 = j + pid + 1;
    if ( v7 == -1 )
      v4 = 0;
    else
      v4 = v3 % v7;
    v12 = &l[128 * v4];
    m = (sync_Mutex_0 *)(v12 + 20);
    sync___ptr_Mutex__Lock((sync_Mutex_0 *)(v12 + 20));
    v5 = *((_DWORD *)v12 + 3);
    v6 = v5 - 1;
    if ( (int)(v5 - 1) >= 0 )
    {
      if ( v6 >= v5 )
        runtime_panicindex();
      *((_DWORD *)v12 + 3) = v6;
      sync___ptr_Mutex__Unlock(m);
      return;
    }
    sync___ptr_Mutex__Unlock(m);
  }
}
// 809B970: could not find valid save-restore pair for esi
// 809B9D8: variable 'v7' is possibly undefined

//----- (0809BA90) --------------------------------------------------------
sync_poolLocal *__golang sync___ptr_Pool__pin(sync_Pool_0 *p)
{
  unsigned __int32 v1; // [esp+4h] [ebp-8h]
  unsigned __int32 i; // [esp+8h] [ebp-4h]

  i = sync_runtime_procPin();
  sync_atomic_LoadUintptr();
  if ( i >= v1 )
    return sync___ptr_Pool__pinSlow(p);
  else
    return (sync_poolLocal *)((char *)p->local + 128 * i);
}
// 809BAD2: variable 'v1' is possibly undefined

//----- (0809BB00) --------------------------------------------------------
sync_poolLocal *__golang sync___ptr_Pool__pinSlow(sync_Pool_0 *p)
{
  int v1; // eax
  sync_Pool_0 *v2; // ecx
  char *local; // ebp
  __int32 len; // ebp
  sync_Pool_0 **array; // esi
  sync_Pool_0 **v6; // eax
  __int32 v7; // ecx
  sync_Mutex_0 *m; // [esp+0h] [ebp-3Ch]
  unsigned __int32 ma; // [esp+0h] [ebp-3Ch]
  unsigned __int64 newa; // [esp+Ch] [ebp-30h]
  runtime_slice_0 src; // [esp+14h] [ebp-28h]
  __int32 size; // [esp+20h] [ebp-1Ch]
  unsigned __int32 i; // [esp+28h] [ebp-14h]
  sync_poolLocal *_r0; // [esp+44h] [ebp+8h]

  _r0 = 0;
  sync_runtime_procUnpin();
  sync___ptr_Mutex__Lock(&sync_allPoolsMu);
  runtime_deferproc(4, (runtime_funcval *)&::len);
  if ( v1 )
  {
    runtime_deferreturn((uintptr)m);
  }
  else
  {
    ma = sync_runtime_procPin();
    v2 = p;
    local = (char *)p->local;
    if ( ma < p->localSize )
    {
      _r0 = (sync_poolLocal *)&local[128 * ma];
      runtime_deferreturn(ma);
    }
    else
    {
      i = ma;
      if ( !local )
      {
        len = sync_allPools.len;
        array = sync_allPools.array;
        if ( sync_allPools.len + 1 > sync_allPools.cap )
        {
          src = runtime_growslice(
                  (runtime__type_0 *)&stru_80D86C0,
                  (runtime_slice_0)sync_allPools,
                  sync_allPools.len + 1);
          v6 = (sync_Pool_0 **)src.array;
          v7 = src.len;
          sync_allPools.cap = src.cap;
          if ( *(_DWORD *)&runtime_writeBarrier.enabled )
          {
            runtime_writebarrierptr((uintptr *)&sync_allPools, (uintptr)src.array);
            v6 = (sync_Pool_0 **)src.array;
            v7 = src.len;
          }
          else
          {
            sync_allPools.array = (sync_Pool_0 **)src.array;
          }
          len = v7;
          array = v6;
          v2 = p;
        }
        sync_allPools.len = len + 1;
        if ( *(_DWORD *)&runtime_writeBarrier.enabled )
          runtime_writebarrierptr((uintptr *)&array[len], (uintptr)v2);
        else
          array[len] = v2;
      }
      size = runtime_GOMAXPROCS(0);
      newa = COERCE_UNSIGNED_INT64(COERCE_LONG_DOUBLE(COERCE_LONG_DOUBLE(runtime_makeslice((runtime__type_0 *)&stru_80D4520, size, size))));
      if ( !HIDWORD(newa) )
        runtime_panicindex();
      sync_atomic_StorePointer(&p->local, (void *)newa);
      sync_atomic_StoreUintptr();
      if ( i >= HIDWORD(newa) )
        runtime_panicindex();
      _r0 = (sync_poolLocal *)(newa + (i << 7));
      runtime_deferreturn((uintptr)&p->localSize);
    }
  }
  return _r0;
}
// 809BB56: variable 'v1' is possibly undefined
// 809BCF4: variable 'm' is possibly undefined

//----- (0809BD20) --------------------------------------------------------
void __golang sync_poolCleanup()
{
  sync_Pool_0 **array; // eax
  __int32 len; // ecx
  __int32 j; // edx
  __int32 v3; // ebp
  __int32 v4; // edi
  int v5; // ebp
  int v6; // ecx
  uintptr *dst; // edx
  uintptr *v8; // ebx
  sync_Pool_0 **src; // [esp+4h] [ebp-20h]
  __int32 i; // [esp+8h] [ebp-1Ch]
  __int32 i_0; // [esp+Ch] [ebp-18h]
  __int32 v12; // [esp+10h] [ebp-14h]
  sync_Pool_0 *p; // [esp+14h] [ebp-10h]
  sync_Pool_0 **v14; // [esp+20h] [ebp-4h]

  array = sync_allPools.array;
  len = sync_allPools.len;
  v12 = sync_allPools.len;
  for ( j = 0; j < len; ++j )
  {
    v8 = (uintptr *)*array;
    if ( (unsigned int)j >= sync_allPools.len )
      runtime_panicindex();
    i_0 = j;
    p = *array;
    v14 = array;
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
    {
      runtime_writebarrierptr((uintptr *)&sync_allPools.array[j], 0);
      array = v14;
      len = v12;
      j = i_0;
    }
    else
    {
      sync_allPools.array[j] = 0;
    }
    v3 = 0;
    while ( v3 < (int)v8[1] )
    {
      i = v3;
      v4 = v3;
      v5 = *v8 + (v3 << 7);
      *(_DWORD *)v5 = 0;
      if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      {
        runtime_writebarrierptr((uintptr *)(v5 + 4), 0);
        array = v14;
        v8 = (uintptr *)p;
        v4 = i;
      }
      else
      {
        *(_DWORD *)(v5 + 4) = 0;
      }
      v6 = *(_DWORD *)(v5 + 12);
      dst = (uintptr *)(v5 + 8);
      if ( v6 )
      {
        runtime_memclrHasPointers(*(void **)(v5 + 8), 8 * v6);
        array = v14;
        dst = (uintptr *)(v5 + 8);
        v8 = (uintptr *)p;
        v4 = i;
      }
      *(_DWORD *)(v5 + 12) = 0;
      *(_DWORD *)(v5 + 16) = 0;
      if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      {
        runtime_writebarrierptr(dst, 0);
        array = v14;
        v8 = (uintptr *)p;
        v4 = i;
      }
      else
      {
        *(_DWORD *)(v5 + 8) = 0;
      }
      v3 = v4 + 1;
      len = v12;
      j = i_0;
    }
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
    {
      runtime_writebarrierptr(v8, 0);
      array = v14;
      len = v12;
      j = i_0;
      v8 = (uintptr *)p;
    }
    else
    {
      *v8 = 0;
    }
    v8[1] = 0;
    ++array;
  }
  src = (sync_Pool_0 **)runtime_newobject((runtime__type_0 *)&stru_80CADA0);
  sync_allPools.len = 0;
  sync_allPools.cap = 0;
  if ( *(_DWORD *)&runtime_writeBarrier.enabled )
    runtime_writebarrierptr((uintptr *)&sync_allPools, (uintptr)src);
  else
    sync_allPools.array = src;
}

//----- (0809BF40) --------------------------------------------------------
void __golang sync_init_0()
{
  sync_runtime_registerPoolCleanup(off_80E7D0C);
}

//----- (0809BF70) --------------------------------------------------------
void __golang sync_init_1()
{
  ((void (*)(void))loc_808FD8B)();
  sync_runtime_notifyListCheck(0x14u);
}

//----- (0809BFB0) --------------------------------------------------------
void __golang sync_init()
{
  void *src; // [esp+4h] [ebp-4h]

  if ( sync_initdone_ <= 1u )
  {
    if ( sync_initdone_ == 1 )
      runtime_throwinit();
    sync_initdone_ = 1;
    runtime_init();
    src = runtime_newobject((runtime__type_0 *)&stru_80CECA0);
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr(&sync_expunged, (uintptr)src);
    else
      sync_expunged = (uintptr)src;
    sync_init_0();
    sync_init_1();
    sync_initdone_ = 2;
  }
}

//----- (0809C040) --------------------------------------------------------
void __golang io_init()
{
  string text; // [esp+0h] [ebp-10h]
  string texta; // [esp+0h] [ebp-10h]
  string textb; // [esp+0h] [ebp-10h]
  string textc; // [esp+0h] [ebp-10h]
  string textd; // [esp+0h] [ebp-10h]
  string texte; // [esp+0h] [ebp-10h]
  string textf; // [esp+0h] [ebp-10h]
  string textg; // [esp+0h] [ebp-10h]
  error_0 v8; // [esp+8h] [ebp-8h]
  error_0 v9; // [esp+8h] [ebp-8h]
  error_0 v10; // [esp+8h] [ebp-8h]
  error_0 v11; // [esp+8h] [ebp-8h]
  error_0 v12; // [esp+8h] [ebp-8h]
  error_0 v13; // [esp+8h] [ebp-8h]
  error_0 v14; // [esp+8h] [ebp-8h]
  error_0 v15; // [esp+8h] [ebp-8h]

  if ( io_initdone_ <= 1u )
  {
    if ( io_initdone_ == 1 )
      runtime_throwinit();
    io_initdone_ = 1;
    sync_init();
    text.str = (uint8 *)"short write";
    text.len = 11;
    v8 = errors_New(text);
    io_ErrShortWrite.tab = v8.tab;
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr((uintptr *)&io_ErrShortWrite.data, (uintptr)v8.data);
    else
      io_ErrShortWrite.data = v8.data;
    texta.str = (uint8 *)"short buffer";
    texta.len = 12;
    v9 = errors_New(texta);
    io_ErrShortBuffer.tab = v9.tab;
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr((uintptr *)&io_ErrShortBuffer.data, (uintptr)v9.data);
    else
      io_ErrShortBuffer.data = v9.data;
    textb.str = (uint8 *)"EOF";
    textb.len = 3;
    v10 = errors_New(textb);
    io_EOF.tab = v10.tab;
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr((uintptr *)&io_EOF.data, (uintptr)v10.data);
    else
      io_EOF.data = v10.data;
    textc.str = (uint8 *)"unexpected EOF";
    textc.len = 14;
    v11 = errors_New(textc);
    io_ErrUnexpectedEOF.tab = v11.tab;
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr((uintptr *)&io_ErrUnexpectedEOF.data, (uintptr)v11.data);
    else
      io_ErrUnexpectedEOF.data = v11.data;
    textd.str = (uint8 *)"multiple Read calls return no data or error";
    textd.len = 43;
    v12 = errors_New(textd);
    io_ErrNoProgress.tab = v12.tab;
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr((uintptr *)&io_ErrNoProgress.data, (uintptr)v12.data);
    else
      io_ErrNoProgress.data = v12.data;
    texte.str = (uint8 *)"Seek: invalid whence";
    texte.len = 20;
    v13 = errors_New(texte);
    io_errWhence.tab = v13.tab;
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr((uintptr *)&io_errWhence.data, (uintptr)v13.data);
    else
      io_errWhence.data = v13.data;
    textf.str = (uint8 *)"Seek: invalid offset";
    textf.len = 20;
    v14 = errors_New(textf);
    io_errOffset.tab = v14.tab;
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr((uintptr *)&io_errOffset.data, (uintptr)v14.data);
    else
      io_errOffset.data = v14.data;
    textg.str = (uint8 *)"io: read/write on closed pipe";
    textg.len = 29;
    v15 = errors_New(textg);
    io_ErrClosedPipe.tab = v15.tab;
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr((uintptr *)&io_ErrClosedPipe.data, (uintptr)v15.data);
    else
      io_ErrClosedPipe.data = v15.data;
    io_initdone_ = 2;
  }
}

//----- (0809C300) --------------------------------------------------------
void __golang syscall_SetNonblock(__int32 fd, bool nonblocking, error_0 err)
{
  __int32 arg; // eax
  __int32 v4; // [esp+Ch] [ebp-Ch]
  __int32 v5; // [esp+Ch] [ebp-Ch]
  error_0 v6; // [esp+10h] [ebp-8h]
  error_0 v7; // [esp+10h] [ebp-8h]

  syscall_fcntl(fd, 3, 0, v4, v6);
  if ( !v7.tab )
  {
    if ( nonblocking )
      arg = v5 | 0x800;
    else
      arg = v5 & 0xFFFFF7FF;
    syscall_fcntl(fd, 4, arg, v5, v7);
  }
}
// 809C32C: variable 'v4' is possibly undefined
// 809C32C: variable 'v6' is possibly undefined
// 809C33F: variable 'v7' is possibly undefined
// 809C34A: variable 'v5' is possibly undefined

//----- (0809C3A0) --------------------------------------------------------
void __golang syscall_init_0()
{
  syscall_fcntl64Syscall = 221;
}

//----- (0809C3D0) --------------------------------------------------------
string __golang syscall_itoa(__int32 val)
{
  __int32 v1; // eax
  uint8 *v2; // ecx
  uint8 *str; // eax
  __int32 len; // ecx
  string v5; // kr00_8
  string v6; // kr08_8
  string a[2]; // [esp+4h] [ebp-18h]

  if ( val >= 0 )
  {
    v6 = syscall_uitoa(val);
    len = v6.len;
    str = v6.str;
  }
  else
  {
    a[0] = syscall_uitoa(-val);
    v1 = a[0].len;
    v2 = a[0].str;
    a[0].str = (uint8 *)"-";
    a[0].len = 1;
    a[1] = (string)__PAIR64__(v1, (unsigned int)v2);
    v5 = runtime_concatstring2(0, *(string (*)[2])&a[0].str);
    len = v5.len;
    str = v5.str;
  }
  return (string)__PAIR64__(len, (unsigned int)str);
}
// 80E0D8A: using guessed type char asc_80E0D8A;

//----- (0809C460) --------------------------------------------------------
string __golang syscall_uitoa(uint val)
{
  unsigned int v2; // eax
  uint v3; // edx
  uint v4; // ecx
  __uint8 b; // [esp+4h] [ebp-34h]
  string v6; // [esp+10h] [ebp-28h]
  string v7; // [esp+10h] [ebp-28h]
  uint8 buf[32]; // [esp+18h] [ebp-20h] BYREF

  ((void (*)(void))loc_808FD88)();
  v2 = 31;
  while ( val >= 0xA )
  {
    v3 = val / 0xA;
    v4 = val % 0xA;
    if ( v2 >= 0x20 )
      runtime_panicindex();
    buf[v2--] = v4 + 48;
    val = v3;
  }
  if ( v2 >= 0x20 )
    runtime_panicindex();
  buf[v2] = val + 48;
  b.array = &buf[((int)(v2 - 32) >> 31) & v2];
  b.len = 32 - v2;
  b.cap = 32 - v2;
  runtime_slicebytetostring(0, b, v6);
  return v7;
}
// 809C4EF: variable 'v6' is possibly undefined
// 809C4FC: variable 'v7' is possibly undefined

//----- (0809C520) --------------------------------------------------------
retval_809C520 __golang syscall_ByteSliceFromString(string s)
{
  __int32 i; // edx
  __uint8 v2; // [esp+Ch] [ebp-18h]
  retval_809C520 _r1; // [esp+30h] [ebp+Ch]

  for ( i = 0; i < s.len; ++i )
  {
    if ( (unsigned int)i >= s.len )
      runtime_panicindex();
    if ( !s.str[i] )
    {
      _r1._r1.array = 0;
      _r1._r1.len = 0;
      _r1._r1.cap = 0;
      _r1._r2.tab = &go_itab_syscall_Errno_error;
      _r1._r2.data = &syscall_statictmp_24;
      return _r1;
    }
  }
  v2 = (__uint8)runtime_makeslice((runtime__type_0 *)&::i, s.len + 1, s.len + 1);
  runtime_memmove();
  _r1._r1 = v2;
  _r1._r2.tab = 0;
  _r1._r2.data = 0;
  return _r1;
}

//----- (0809C620) --------------------------------------------------------
retval_809C620 __golang syscall_BytePtrFromString(string s)
{
  retval_809C520 v1; // [esp+8h] [ebp-14h]
  retval_809C620 _r1; // [esp+28h] [ebp+Ch]

  v1 = syscall_ByteSliceFromString(s);
  if ( v1._r2.tab )
  {
    _r1._r1 = 0;
    _r1._r2 = v1._r2;
  }
  else
  {
    if ( !v1._r1.len )
      runtime_panicindex();
    _r1._r1 = v1._r1.array;
    _r1._r2.tab = 0;
    _r1._r2.data = 0;
  }
  return _r1;
}

//----- (0809C6A0) --------------------------------------------------------
void __golang syscall_Readlink(string path, __uint8 buf, __int32 n, error_0 err)
{
  __int32 v4; // [esp+18h] [ebp-Ch]
  error_0 v5; // [esp+1Ch] [ebp-8h]

  syscall_readlinkat(-100, path, buf, v4, v5);
}
// 809C6E4: variable 'v4' is possibly undefined
// 809C6E4: variable 'v5' is possibly undefined

//----- (0809C710) --------------------------------------------------------
void __golang syscall_mmap(
        uintptr addr,
        uintptr length,
        __int32 prot,
        __int32 flags,
        __int32 fd,
        int64 offset,
        uintptr xaddr,
        error_0 err)
{
  uintptr v8; // [esp+18h] [ebp-Ch]
  error_0 v9; // [esp+1Ch] [ebp-8h]

  if ( (_DWORD)offset == (unsigned int)(offset / 4096) << 12 && HIDWORD(offset) == (unsigned int)(offset / 4096) >> 20 )
    syscall_mmap2(addr, length, prot, flags, fd, offset / 4096, v8, v9);
}
// 809C7AD: variable 'v8' is possibly undefined
// 809C7AD: variable 'v9' is possibly undefined

//----- (0809C7E0) --------------------------------------------------------
string __golang syscall_Errno_Error(syscall_Errno e)
{
  string *v1; // ecx
  uint8 *v2; // edx
  __int32 v3; // ecx
  __int32 len; // eax
  uint8 *str; // ecx
  string a[2]; // [esp+4h] [ebp-18h]
  string _r0; // [esp+24h] [ebp+8h]

  if ( e < 0x85 && (v1 = &syscall_errors[e], v2 = v1->str, (v3 = v1->len) != 0) )
  {
    _r0.str = v2;
    _r0.len = v3;
  }
  else
  {
    a[0] = syscall_itoa(e);
    len = a[0].len;
    str = a[0].str;
    a[0].str = (uint8 *)"errno ";
    a[0].len = 6;
    a[1] = (string)__PAIR64__(len, (unsigned int)str);
    return runtime_concatstring2(0, *(string (*)[2])&a[0].str);
  }
  return _r0;
}

//----- (0809C880) --------------------------------------------------------
void __golang syscall_Write(__int32 fd, __uint8 p, __int32 n, error_0 err)
{
  __int32 v4; // [esp+10h] [ebp-Ch]
  error_0 v5; // [esp+14h] [ebp-8h]

  syscall_write(fd, p, v4, v5);
}
// 809C8B4: variable 'v4' is possibly undefined
// 809C8B4: variable 'v5' is possibly undefined

//----- (0809C8E0) --------------------------------------------------------
void __golang syscall_readlinkat(__int32 dirfd, string path, __uint8 buf, __int32 n, error_0 err)
{
  uintptr *v5; // ebp
  retval_809C620 i; // [esp+8h] [ebp-34h]
  runtime_iface_0 ia; // [esp+8h] [ebp-34h]
  unsigned int v8; // [esp+24h] [ebp-18h]
  int elem[4]; // [esp+2Ch] [ebp-10h] BYREF

  i = syscall_BytePtrFromString(path);
  if ( !i._r2.tab )
  {
    elem[2] = 0;
    elem[1] = (int)i._r2.data;
    v5 = buf.len <= 0 ? &syscall__zero : (uintptr *)buf.array;
    elem[3] = (int)i._r1;
    ia = (runtime_iface_0)__PAIR64__((unsigned int)v5, (unsigned int)i._r1);
    syscall_Syscall6();
    if ( v8 )
    {
      if ( v8 <= 2 )
      {
        if ( v8 == 2 )
          return;
        goto LABEL_7;
      }
      if ( v8 != 11 && v8 != 22 )
      {
LABEL_7:
        elem[0] = v8;
        runtime_convT2I32(&go_itab_syscall_Errno_error, elem, ia);
      }
    }
  }
}
// 809C97D: variable 'v8' is possibly undefined

//----- (0809CA30) --------------------------------------------------------
void __golang syscall_Close(__int32 fd, error_0 err)
{
  unsigned int v2; // [esp+18h] [ebp-8h]
  unsigned int elem; // [esp+1Ch] [ebp-4h] BYREF

  syscall_Syscall();
  if ( v2 )
  {
    if ( v2 <= 2 )
    {
      if ( v2 == 2 )
        return;
      goto LABEL_4;
    }
    if ( v2 != 11 && v2 != 22 )
    {
LABEL_4:
      elem = v2;
      runtime_convT2I32(&go_itab_syscall_Errno_error, &elem, 0LL);
    }
  }
}
// 809CA73: variable 'v2' is possibly undefined

//----- (0809CAF0) --------------------------------------------------------
void __golang syscall_fcntl(__int32 fd, __int32 cmd, __int32 arg, __int32 val, error_0 err)
{
  unsigned int v5; // [esp+18h] [ebp-Ch]
  unsigned int elem; // [esp+20h] [ebp-4h] BYREF

  syscall_Syscall();
  if ( v5 )
  {
    if ( v5 <= 2 )
    {
      if ( v5 == 2 )
        return;
      goto LABEL_4;
    }
    if ( v5 != 11 && v5 != 22 )
    {
LABEL_4:
      elem = v5;
      runtime_convT2I32(&go_itab_syscall_Errno_error, &elem, (runtime_iface_0)__PAIR64__(arg, cmd));
    }
  }
}
// 809CB37: variable 'v5' is possibly undefined

//----- (0809CBC0) --------------------------------------------------------
void __golang syscall_write(__int32 fd, __uint8 p, __int32 n, error_0 err)
{
  uint8 *array; // ecx
  runtime_iface_0 i; // [esp+8h] [ebp-1Ch]
  unsigned int v6; // [esp+18h] [ebp-Ch]
  unsigned int elem; // [esp+20h] [ebp-4h] BYREF

  if ( p.len <= 0 )
    array = (uint8 *)&syscall__zero;
  else
    array = p.array;
  i = (runtime_iface_0)__PAIR64__(p.len, (unsigned int)array);
  syscall_Syscall();
  if ( v6 )
  {
    if ( v6 <= 2 )
    {
      if ( v6 == 2 )
        return;
      goto LABEL_6;
    }
    if ( v6 != 11 && v6 != 22 )
    {
LABEL_6:
      elem = v6;
      runtime_convT2I32(&go_itab_syscall_Errno_error, &elem, i);
    }
  }
}
// 809CC0F: variable 'v6' is possibly undefined

//----- (0809CCB0) --------------------------------------------------------
void __golang syscall_munmap(uintptr addr, uintptr length, error_0 err)
{
  unsigned int v3; // [esp+18h] [ebp-8h]
  unsigned int elem; // [esp+1Ch] [ebp-4h] BYREF

  syscall_Syscall();
  if ( v3 )
  {
    if ( v3 <= 2 )
    {
      if ( v3 == 2 )
        return;
      goto LABEL_4;
    }
    if ( v3 != 11 && v3 != 22 )
    {
LABEL_4:
      elem = v3;
      runtime_convT2I32(&go_itab_syscall_Errno_error, &elem, (runtime_iface_0)length);
    }
  }
}
// 809CCF3: variable 'v3' is possibly undefined

//----- (0809CD70) --------------------------------------------------------
void __golang syscall_mmap2(
        uintptr addr,
        uintptr length,
        __int32 prot,
        __int32 flags,
        __int32 fd,
        uintptr pageOffset,
        uintptr xaddr,
        error_0 err)
{
  unsigned int v8; // [esp+24h] [ebp-Ch]
  unsigned int elem; // [esp+2Ch] [ebp-4h] BYREF

  syscall_Syscall6();
  if ( v8 )
  {
    if ( v8 <= 2 )
    {
      if ( v8 == 2 )
        return;
      goto LABEL_4;
    }
    if ( v8 != 11 && v8 != 22 )
    {
LABEL_4:
      elem = v8;
      runtime_convT2I32(&go_itab_syscall_Errno_error, &elem, (runtime_iface_0)__PAIR64__(prot, length));
    }
  }
}
// 809CDCF: variable 'v8' is possibly undefined

//----- (0809CE60) --------------------------------------------------------
void __golang syscall_init()
{
  __string t; // [esp+0h] [ebp-18h]
  hash<*uint8,[]uint8> *src; // [esp+14h] [ebp-4h]

  if ( syscall_initdone_ <= 1u )
  {
    if ( syscall_initdone_ == 1 )
      runtime_throwinit();
    syscall_initdone_ = 1;
    sync_init();
    runtime_init();
    t = syscall_runtime_envs();
    *(_QWORD *)&syscall_envs.len = *(_QWORD *)&t.len;
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr((uintptr *)&syscall_envs, (uintptr)t.array);
    else
      syscall_envs.array = t.array;
    src = (hash<*uint8,[]uint8> *)runtime_makemap((runtime_maptype_0 *)&stru_80CFA00, 0LL, 0, 0);
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr((uintptr *)&syscall_statictmp_51.active, (uintptr)src);
    else
      syscall_statictmp_51.active = src;
    syscall_init_0();
    syscall_initdone_ = 2;
  }
}

//----- (0809CF60) --------------------------------------------------------
#error "809CF60: call analysis failed (funcsize=21)"

//----- (0809CFC0) --------------------------------------------------------
#error "809CFC0: call analysis failed (funcsize=22)"

//----- (0809D020) --------------------------------------------------------
string __golang syscall___ptr_Errno__Error(syscall_Errno *.this)
{
  int v1; // ecx
  syscall_Errno **v2; // ebx
  syscall_Errno e; // [esp+0h] [ebp-Ch] BYREF

  v2 = *(syscall_Errno ***)(v1 + 16);
  if ( v2 && *v2 == (syscall_Errno *)&.this )
    *v2 = &e;
  if ( !.this )
    runtime_panicwrap();
  return syscall_Errno_Error(*.this);
}
// 809D035: variable 'v1' is possibly undefined

//----- (0809D080) --------------------------------------------------------
uintptr __golang type__hash__133_string(string (*p)[133], uintptr h)
{
  int j; // eax
  __int32 i; // [esp+Ch] [ebp-4h]

  for ( j = 0; j < 133; j = i + 1 )
  {
    i = j;
    h = runtime_strhash(&(*p)[j], h);
  }
  return h;
}

//----- (0809D0E0) --------------------------------------------------------
bool __golang type__eq__133_string(string (*p)[133], string (*q)[133])
{
  int j; // eax
  char v3; // [esp+10h] [ebp-8h]
  __int32 i; // [esp+14h] [ebp-4h]

  for ( j = 0; j < 133; j = i + 1 )
  {
    if ( (*p)[j].len == (*q)[j].len )
    {
      i = j;
      runtime_eqstring();
      if ( v3 )
        continue;
    }
    return 0;
  }
  return 1;
}
// 809D143: variable 'v3' is possibly undefined

//----- (0809D160) --------------------------------------------------------
void __golang time_init()
{
  string text; // [esp+0h] [ebp-20h]
  string texta; // [esp+0h] [ebp-20h]
  string textb; // [esp+0h] [ebp-20h]
  string textc; // [esp+0h] [ebp-20h]
  string textd; // [esp+0h] [ebp-20h]
  string text_4[2]; // [esp+4h] [ebp-1Ch]
  string ky; // [esp+8h] [ebp-18h]
  string kya; // [esp+8h] [ebp-18h]
  string kyb; // [esp+8h] [ebp-18h]
  string kye; // [esp+8h] [ebp-18h]
  string kyf; // [esp+8h] [ebp-18h]
  string kyg; // [esp+8h] [ebp-18h]
  string kyh; // [esp+8h] [ebp-18h]
  string kyi; // [esp+8h] [ebp-18h]
  string kyj; // [esp+8h] [ebp-18h]
  string kyk; // [esp+8h] [ebp-18h]
  string kyl; // [esp+8h] [ebp-18h]
  string kyc; // [esp+8h] [ebp-18h]
  string kyd; // [esp+8h] [ebp-18h]
  _DWORD *bucket; // [esp+10h] [ebp-10h]
  _DWORD *bucketa; // [esp+10h] [ebp-10h]
  _DWORD *bucketb; // [esp+10h] [ebp-10h]
  _DWORD *bucketc; // [esp+10h] [ebp-10h]
  _DWORD *bucketd; // [esp+10h] [ebp-10h]
  _DWORD *buckete; // [esp+10h] [ebp-10h]
  _DWORD *bucketf; // [esp+10h] [ebp-10h]
  _DWORD *bucketg; // [esp+10h] [ebp-10h]
  string h; // [esp+14h] [ebp-Ch]
  runtime_hmap *src; // [esp+1Ch] [ebp-4h]

  if ( time_initdone_ <= 1u )
  {
    if ( time_initdone_ == 1 )
      runtime_throwinit();
    time_initdone_ = 1;
    syscall_init();
    sync_init();
    runtime_init();
    text.str = (uint8 *)"time: invalid number";
    text.len = 20;
    ky = (string)errors_New(text);
    time_atoiError.tab = (runtime_itab_0 *)ky.str;
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr((uintptr *)&time_atoiError.data, ky.len);
    else
      time_atoiError.data = (void *)ky.len;
    texta.str = (uint8 *)"bad value for field";
    texta.len = 19;
    kya = (string)errors_New(texta);
    time_errBad.tab = (runtime_itab_0 *)kya.str;
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr((uintptr *)&time_errBad.data, kya.len);
    else
      time_errBad.data = (void *)kya.len;
    textb.str = (uint8 *)"time: bad [0-9]*";
    textb.len = 16;
    kyb = (string)errors_New(textb);
    time_errLeadingInt.tab = (runtime_itab_0 *)kyb.str;
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr((uintptr *)&time_errLeadingInt.data, kyb.len);
    else
      time_errLeadingInt.data = (void *)kyb.len;
    src = runtime_makemap((runtime_maptype_0 *)&stru_80CFB80, 8LL, 0, 0);
    kye.str = (uint8 *)"ns";
    kye.len = 2;
    bucket = runtime_mapassign_faststr((runtime_maptype_0 *)&stru_80CFB80, src, kye);
    *bucket = 1;
    bucket[1] = 0;
    kyf.str = (uint8 *)"us";
    kyf.len = 2;
    bucketa = runtime_mapassign_faststr((runtime_maptype_0 *)&stru_80CFB80, src, kyf);
    *bucketa = 1000;
    bucketa[1] = 0;
    kyg.str = (uint8 *)"µs";
    kyg.len = 3;
    bucketb = runtime_mapassign_faststr((runtime_maptype_0 *)&stru_80CFB80, src, kyg);
    *bucketb = 1000;
    bucketb[1] = 0;
    kyh.str = (uint8 *)"μs";
    kyh.len = 3;
    bucketc = runtime_mapassign_faststr((runtime_maptype_0 *)&stru_80CFB80, src, kyh);
    *bucketc = 1000;
    bucketc[1] = 0;
    kyi.str = (uint8 *)"ms";
    kyi.len = 2;
    bucketd = runtime_mapassign_faststr((runtime_maptype_0 *)&stru_80CFB80, src, kyi);
    *bucketd = 1000000;
    bucketd[1] = 0;
    kyj.str = (uint8 *)"s";
    kyj.len = 1;
    buckete = runtime_mapassign_faststr((runtime_maptype_0 *)&stru_80CFB80, src, kyj);
    *buckete = 1000000000;
    buckete[1] = 0;
    kyk.str = (uint8 *)"m";
    kyk.len = 1;
    bucketf = runtime_mapassign_faststr((runtime_maptype_0 *)&stru_80CFB80, src, kyk);
    *bucketf = -129542144;
    bucketf[1] = 13;
    kyl.str = (uint8 *)"h";
    kyl.len = 1;
    bucketg = runtime_mapassign_faststr((runtime_maptype_0 *)&stru_80CFB80, src, kyl);
    *bucketg = 817405952;
    bucketg[1] = 838;
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr((uintptr *)&time_unitMap, (uintptr)src);
    else
      time_unitMap = (map_string_int64)src;
    textc.str = (uint8 *)"time: invalid location name";
    textc.len = 27;
    kyc = (string)errors_New(textc);
    time_errLocation.tab = (runtime_itab_0 *)kyc.str;
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr((uintptr *)&time_errLocation.data, kyc.len);
    else
      time_errLocation.data = (void *)kyc.len;
    textd.str = (uint8 *)"malformed time zone information";
    textd.len = 31;
    kyd = (string)errors_New(textd);
    time_badData.tab = (runtime_itab_0 *)kyd.str;
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr((uintptr *)&time_badData.data, kyd.len);
    else
      time_badData.data = (void *)kyd.len;
    text_4[0] = runtime_GOROOT();
    text_4[1].str = (uint8 *)"/lib/time/zoneinfo.zip";
    text_4[1].len = 22;
    h = runtime_concatstring2(0, *(string (*)[2])&text_4[0].str);
    time_statictmp_23[3].len = h.len;
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr((uintptr *)&time_statictmp_23[3], (uintptr)h.str);
    else
      time_statictmp_23[3].str = h.str;
    time_initdone_ = 2;
  }
}
// 80E0DA0: using guessed type char asc_80E0DA0;
// 80E0DA1: using guessed type char aM_3;
// 80E0DA2: using guessed type char aS_0;

//----- (0809D5E0) --------------------------------------------------------
string __golang internal_poll___ptr_TimeoutError__Error(internal_poll_TimeoutError_0 *e)
{
  string _r0; // [esp+8h] [ebp+8h]

  _r0.str = (uint8 *)"i/o timeout";
  _r0.len = 11;
  return _r0;
}

//----- (0809D610) --------------------------------------------------------
bool __golang internal_poll___ptr_fdMutex__increfAndClose(internal_poll_fdMutex_0 *mu)
{
  uint32 v1; // eax
  int v2; // ecx
  interface_{} addr; // [esp+0h] [ebp-28h]
  uint32 v4; // [esp+4h] [ebp-24h]
  int v5; // [esp+8h] [ebp-20h]
  char v6; // [esp+14h] [ebp-14h]
  uint32 old_lo; // [esp+18h] [ebp-10h]
  uint32 old_hi; // [esp+1Ch] [ebp-Ch]
  uint32 old_hia; // [esp+1Ch] [ebp-Ch]
  uint32 v10; // [esp+24h] [ebp-4h]
  uint32 v11; // [esp+24h] [ebp-4h]

  do
  {
    sync_atomic_LoadUint64();
    if ( (v4 & 1) != 0 )
      return 0;
    if ( (((v4 | 1) + 8) & 0x7FFFF8) == 0 )
    {
      addr._type = (runtime__type_0 *)&t;
      addr.data = &internal_poll_statictmp_1;
      runtime_gopanic(addr);
      BUG();
    }
    sync_atomic_CompareAndSwapUint64();
  }
  while ( !v6 );
  v1 = v4;
  v2 = v5;
  while ( (v1 & 0xFF800000) != 0 || (v2 & 0x7FF) != 0 )
  {
    old_lo = v1;
    old_hi = v2;
    v10 = v1 - 0x800000;
    internal_poll_runtime_Semrelease(&mu->rsema);
    v2 = __CFADD__(old_lo, -8388608) + old_hi - 1;
    v1 = v10;
  }
  while ( (v2 & 0x7FFFF800) != 0 )
  {
    old_hia = v2;
    v11 = v1;
    internal_poll_runtime_Semrelease(&mu->wsema);
    v2 = old_hia - 2048;
    v1 = v11;
  }
  return 1;
}
// 809D63F: variable 'v4' is possibly undefined
// 809D6A0: variable 'v6' is possibly undefined
// 809D6A6: variable 'v5' is possibly undefined

//----- (0809D770) --------------------------------------------------------
bool __golang internal_poll___ptr_fdMutex__decref(internal_poll_fdMutex_0 *mu)
{
  interface_{} e; // [esp+0h] [ebp-1Ch]
  int e_4; // [esp+4h] [ebp-18h]
  char v3; // [esp+14h] [ebp-8h]

  do
  {
    sync_atomic_LoadUint64();
    if ( (e_4 & 0x7FFFF8) == 0 )
    {
      e._type = (runtime__type_0 *)&t;
      e.data = &internal_poll_statictmp_2;
      runtime_gopanic(e);
      BUG();
    }
    sync_atomic_CompareAndSwapUint64();
  }
  while ( !v3 );
  return ((e_4 - 8) & 0x7FFFF9) == 1;
}
// 809D79F: variable 'e_4' is possibly undefined
// 809D7D4: variable 'v3' is possibly undefined

//----- (0809D820) --------------------------------------------------------
bool __golang internal_poll___ptr_fdMutex__rwlock(internal_poll_fdMutex_0 *mu, bool read)
{
  uint32 *p_rsema; // ecx
  int v3; // edx
  int v4; // ebx
  int v5; // ebp
  int v6; // esi
  int v7; // edi
  interface_{} addr; // [esp+0h] [ebp-34h]
  interface_{} addra; // [esp+0h] [ebp-34h]
  __int64 v10; // [esp+4h] [ebp-30h]
  char v11; // [esp+14h] [ebp-20h]
  uint32 mutexBit_lo; // [esp+2Ch] [ebp-8h]
  uint32 *mutexSema; // [esp+30h] [ebp-4h]

  if ( read )
  {
    p_rsema = &mu->rsema;
    v3 = 2;
    v4 = 0x800000;
    v5 = 0;
    v6 = 2047;
    v7 = -8388608;
  }
  else
  {
    p_rsema = &mu->wsema;
    v3 = 4;
    v4 = 0;
    v5 = 2048;
    v6 = 2147481600;
    v7 = 0;
  }
  mutexBit_lo = v3;
  mutexSema = p_rsema;
  while ( 1 )
  {
    sync_atomic_LoadUint64();
    if ( (v10 & 1) != 0 )
      break;
    if ( ((unsigned int)v10 & mutexBit_lo) != 0 )
    {
      if ( ((((v4 + (_DWORD)v10) & v7) == 0) & ((((__PAIR64__(v5, v4) + v10) >> 32) & (unsigned int)v6) == 0)) != 0 )
      {
        addr._type = (runtime__type_0 *)&t;
        addr.data = &internal_poll_statictmp_4;
        runtime_gopanic(addr);
        BUG();
      }
    }
    else if ( ((((unsigned int)v10 | mutexBit_lo) + 8) & 0x7FFFF8) == 0 )
    {
      addra._type = (runtime__type_0 *)&t;
      addra.data = &internal_poll_statictmp_3;
      runtime_gopanic(addra);
      BUG();
    }
    sync_atomic_CompareAndSwapUint64();
    if ( v11 )
    {
      if ( ((unsigned int)v10 & mutexBit_lo) == 0 )
        return 1;
      internal_poll_runtime_Semacquire(mutexSema);
    }
  }
  return 0;
}
// 809D895: variable 'v10' is possibly undefined
// 809D8F2: variable 'v11' is possibly undefined

//----- (0809D9B0) --------------------------------------------------------
bool __golang internal_poll___ptr_fdMutex__rwunlock(internal_poll_fdMutex_0 *mu, bool read)
{
  uint32 *p_rsema; // ecx
  int v3; // edx
  int v4; // ebx
  int v5; // ebp
  int v6; // edi
  int v7; // edx
  interface_{} addr; // [esp+0h] [ebp-38h]
  int v9; // [esp+4h] [ebp-34h]
  int v10; // [esp+8h] [ebp-30h]
  char v11; // [esp+14h] [ebp-24h]
  bool v12; // [esp+1Bh] [ebp-1Dh]
  uint32 new_lo; // [esp+1Ch] [ebp-1Ch]
  uint32 mutexBit_lo; // [esp+30h] [ebp-8h]
  uint32 *mutexSema; // [esp+34h] [ebp-4h]

  if ( read )
  {
    p_rsema = &mu->rsema;
    v3 = 2;
    v4 = -8388608;
    v5 = 2047;
    v6 = 0x800000;
  }
  else
  {
    p_rsema = &mu->wsema;
    v3 = 4;
    v4 = 0;
    v5 = 2147481600;
    v6 = 0;
  }
  mutexBit_lo = v3;
  mutexSema = p_rsema;
  do
  {
    sync_atomic_LoadUint64();
    if ( (v9 & mutexBit_lo) == 0 || (v9 & 0x7FFFF8) == 0 )
    {
      addr._type = (runtime__type_0 *)&t;
      addr.data = &internal_poll_statictmp_5;
      runtime_gopanic(addr);
      BUG();
    }
    v7 = (v9 & ~mutexBit_lo) - 8;
    v12 = (v9 & v4) != 0 || (v10 & v5) != 0;
    if ( v12 )
      v7 -= v6;
    new_lo = v7;
    sync_atomic_CompareAndSwapUint64();
  }
  while ( !v11 );
  if ( v12 )
    internal_poll_runtime_Semrelease(mutexSema);
  return (new_lo & 0x7FFFF9) == 1;
}
// 809D9B0: could not find valid save-restore pair for edi
// 809D9B0: could not find valid save-restore pair for esi
// 809DA29: variable 'v9' is possibly undefined
// 809DA5D: variable 'v10' is possibly undefined
// 809DAA8: variable 'v11' is possibly undefined

//----- (0809DB30) --------------------------------------------------------
error_0 __golang internal_poll___ptr_FD__decref(internal_poll_FD_0 *fd)
{
  error_0 _r0; // [esp+14h] [ebp+8h]

  if ( internal_poll___ptr_fdMutex__decref(&fd->fdmu) )
    return internal_poll___ptr_FD__destroy(fd);
  _r0.tab = 0;
  _r0.data = 0;
  return _r0;
}

//----- (0809DBA0) --------------------------------------------------------
error_0 __golang internal_poll___ptr_FD__writeLock(internal_poll_FD_0 *fd)
{
  runtime_itab_0 *tab; // eax
  void *data; // ecx
  error_0 _r0; // [esp+14h] [ebp+8h]

  if ( internal_poll___ptr_fdMutex__rwlock(&fd->fdmu, 0) )
  {
    _r0.tab = 0;
    _r0.data = 0;
  }
  else
  {
    if ( fd->isFile )
    {
      tab = internal_poll_ErrFileClosing.tab;
      data = internal_poll_ErrFileClosing.data;
    }
    else
    {
      tab = internal_poll_ErrNetClosing.tab;
      data = internal_poll_ErrNetClosing.data;
    }
    _r0.tab = tab;
    _r0.data = data;
  }
  return _r0;
}

//----- (0809DC20) --------------------------------------------------------
void __golang internal_poll___ptr_FD__writeUnlock(internal_poll_FD_0 *fd)
{
  if ( internal_poll___ptr_fdMutex__rwunlock(&fd->fdmu, 0) )
    internal_poll___ptr_FD__destroy(fd);
}

//----- (0809DC70) --------------------------------------------------------
error_0 __golang internal_poll___ptr_pollDesc__init(internal_poll_pollDesc_0 *pd, internal_poll_FD_0 *fd)
{
  int v2; // ecx
  long double f; // [esp+4h] [ebp-18h]
  error_0 v4; // [esp+8h] [ebp-14h]
  int elem; // [esp+18h] [ebp-4h] BYREF
  error_0 _r1; // [esp+28h] [ebp+Ch]

  sync___ptr_Once__Do(&internal_poll_serverInit, off_80E7B18);
  *(retval_8068E50 *)&f = internal_poll_runtime_pollOpen(fd->Sysfd);
  v2 = DWORD1(f);
  if ( DWORD1(f) )
  {
    if ( LODWORD(f) )
    {
      internal_poll_runtime_pollUnblock((runtime_pollDesc *)LODWORD(f));
      internal_poll_runtime_pollClose((runtime_pollDesc *)LODWORD(f));
      v2 = DWORD1(f);
    }
    elem = v2;
    runtime_convT2I32(&go_itab_syscall_Errno_error, &elem, *(runtime_iface_0 *)((char *)&f + 4));
    return v4;
  }
  else
  {
    pd->runtimeCtx = (uintptr)LODWORD(f);
    _r1.tab = 0;
    _r1.data = 0;
  }
  return _r1;
}
// 809DCD5: variable 'f' is possibly undefined
// 809DCE2: variable 'v4' is possibly undefined

//----- (0809DD40) --------------------------------------------------------
void __golang internal_poll___ptr_pollDesc__close(internal_poll_pollDesc_0 *pd)
{
  if ( pd->runtimeCtx )
  {
    internal_poll_runtime_pollClose((runtime_pollDesc *)pd->runtimeCtx);
    pd->runtimeCtx = 0;
  }
}

//----- (0809DD80) --------------------------------------------------------
void __golang internal_poll___ptr_pollDesc__evict(internal_poll_pollDesc_0 *pd)
{
  if ( pd->runtimeCtx )
    internal_poll_runtime_pollUnblock((runtime_pollDesc *)pd->runtimeCtx);
}

//----- (0809DDC0) --------------------------------------------------------
error_0 __golang internal_poll___ptr_pollDesc__prepare(internal_poll_pollDesc_0 *pd, __int32 mode, bool isFile)
{
  __int32 res; // [esp+8h] [ebp-8h]
  error_0 _r2; // [esp+20h] [ebp+10h]

  if ( pd->runtimeCtx )
  {
    res = internal_poll_runtime_pollReset((runtime_pollDesc *)pd->runtimeCtx, mode);
    return internal_poll_convertErr(res, isFile);
  }
  else
  {
    _r2.tab = 0;
    _r2.data = 0;
  }
  return _r2;
}

//----- (0809DE40) --------------------------------------------------------
error_0 __golang internal_poll___ptr_pollDesc__prepareWrite(internal_poll_pollDesc_0 *pd, bool isFile)
{
  return internal_poll___ptr_pollDesc__prepare(pd, 119, isFile);
}

//----- (0809DE90) --------------------------------------------------------
error_0 __golang internal_poll___ptr_pollDesc__wait(internal_poll_pollDesc_0 *pd, __int32 mode, bool isFile)
{
  uintptr *v3; // eax
  __int32 res; // [esp+8h] [ebp-Ch]
  uintptr *v5; // [esp+10h] [ebp-4h]
  error_0 _r2; // [esp+24h] [ebp+10h]

  if ( pd->runtimeCtx )
  {
    res = internal_poll_runtime_pollWait((runtime_pollDesc *)pd->runtimeCtx, mode);
    return internal_poll_convertErr(res, isFile);
  }
  else
  {
    v3 = (uintptr *)runtime_newobject((runtime__type_0 *)&stru_80D1920);
    v3[1] = 33;
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
    {
      v5 = v3;
      runtime_writebarrierptr(v3, (uintptr)"waiting for unsupported file type");
      v3 = v5;
    }
    else
    {
      *v3 = (uintptr)"waiting for unsupported file type";
    }
    _r2.tab = (runtime_itab_0 *)&go_itab__errors_errorString_error;
    _r2.data = v3;
  }
  return _r2;
}
// 8136610: using guessed type runtime_interfacetype_0 *go_itab__errors_errorString_error;

//----- (0809DF50) --------------------------------------------------------
error_0 __golang internal_poll___ptr_pollDesc__waitWrite(internal_poll_pollDesc_0 *pd, bool isFile)
{
  return internal_poll___ptr_pollDesc__wait(pd, 119, isFile);
}

//----- (0809DFA0) --------------------------------------------------------
error_0 __golang internal_poll_convertErr(__int32 res, bool isFile)
{
  runtime_itab_0 *tab; // eax
  void *data; // ecx
  string s; // [esp+0h] [ebp-8h]
  string sa; // [esp+0h] [ebp-8h]
  error_0 _r2; // [esp+14h] [ebp+Ch]

  if ( res )
  {
    if ( res == 1 )
    {
      if ( isFile )
      {
        tab = internal_poll_ErrFileClosing.tab;
        data = internal_poll_ErrFileClosing.data;
      }
      else
      {
        tab = internal_poll_ErrNetClosing.tab;
        data = internal_poll_ErrNetClosing.data;
      }
      _r2.tab = tab;
      _r2.data = data;
    }
    else
    {
      if ( res != 2 )
      {
        runtime_printlock();
        s.str = (uint8 *)"unreachable: ";
        s.len = 13;
        runtime_printstring(s);
        runtime_printsp();
        runtime_printint(res);
        runtime_printnl();
        runtime_printunlock();
        sa.str = (uint8 *)&t;
        sa.len = (__int32)&internal_poll_statictmp_6;
        runtime_gopanic((interface_{})sa);
        BUG();
      }
      return internal_poll_ErrTimeout;
    }
  }
  else
  {
    _r2.tab = 0;
    _r2.data = 0;
  }
  return _r2;
}

//----- (0809E090) --------------------------------------------------------
error_0 __golang internal_poll___ptr_FD__Init(internal_poll_FD_0 *fd, string net, bool pollable)
{
  internal_poll_FD_0 *v3; // eax
  error_0 _r2; // [esp+24h] [ebp+14h]

  if ( net.len == 4 && *(_DWORD *)net.str == 1701603686 )
  {
    v3 = fd;
    fd->isFile = 1;
  }
  else
  {
    v3 = fd;
  }
  if ( pollable )
    return internal_poll___ptr_pollDesc__init(&v3->pd, v3);
  _r2.tab = 0;
  _r2.data = 0;
  return _r2;
}

//----- (0809E120) --------------------------------------------------------
error_0 __golang internal_poll___ptr_FD__destroy(internal_poll_FD_0 *fd)
{
  error_0 v1; // [esp+4h] [ebp-8h]

  internal_poll___ptr_pollDesc__close(&fd->pd);
  v1.tab = (runtime_itab_0 *)(*(int (__golang **)(__int32))runtime_data)(fd->Sysfd);
  fd->Sysfd = -1;
  return v1;
}
// 809E16D: variable 'v1' is possibly undefined

//----- (0809E180) --------------------------------------------------------
error_0 __golang internal_poll___ptr_FD__Close(internal_poll_FD_0 *fd)
{
  runtime_itab_0 *tab; // eax
  void *data; // ecx
  error_0 _r0; // [esp+14h] [ebp+8h]

  if ( internal_poll___ptr_fdMutex__increfAndClose(&fd->fdmu) )
  {
    internal_poll___ptr_pollDesc__evict(&fd->pd);
    return internal_poll___ptr_FD__decref(fd);
  }
  else
  {
    if ( fd->isFile )
    {
      tab = internal_poll_ErrFileClosing.tab;
      data = internal_poll_ErrFileClosing.data;
    }
    else
    {
      tab = internal_poll_ErrNetClosing.tab;
      data = internal_poll_ErrNetClosing.data;
    }
    _r0.tab = tab;
    _r0.data = data;
  }
  return _r0;
}

//----- (0809E220) --------------------------------------------------------
retval_809E220 __golang internal_poll___ptr_FD__Write(internal_poll_FD_0 *fd, __uint8 p)
{
  int v2; // eax
  unsigned __int32 v3; // eax
  __int32 len; // ebx
  unsigned __int32 v5; // edx
  error_0 v6; // rax
  __int32 v7; // ecx
  __int32 v8; // ebx
  uintptr siz; // [esp+0h] [ebp-2Ch]
  uintptr siza; // [esp+0h] [ebp-2Ch]
  uintptr sizb; // [esp+0h] [ebp-2Ch]
  uintptr sizc; // [esp+0h] [ebp-2Ch]
  error_0 fn; // [esp+4h] [ebp-28h]
  __uint8 fna; // [esp+4h] [ebp-28h]
  error_0 v15; // [esp+8h] [ebp-24h]
  error_0 v16; // [esp+8h] [ebp-24h]
  __int32 v17; // [esp+10h] [ebp-1Ch]
  error_0 v18; // [esp+14h] [ebp-18h]
  __int32 nn; // [esp+1Ch] [ebp-10h]
  retval_809E220 _r1; // [esp+40h] [ebp+14h]

  _r1._r1 = 0;
  _r1._r2.tab = 0;
  _r1._r2.data = 0;
  fn = internal_poll___ptr_FD__writeLock(fd);
  if ( fn.tab )
  {
    _r1._r1 = 0;
    _r1._r2 = fn;
    runtime_deferreturn(siz);
  }
  else
  {
    runtime_deferproc(4, (runtime_funcval *)&stru_80E7B14);
    if ( v2 )
    {
      runtime_deferreturn(siza);
    }
    else
    {
      v15 = internal_poll___ptr_pollDesc__prepareWrite(&fd->pd, fd->isFile);
      if ( !v15.tab )
      {
        v3 = 0;
        while ( fd->IsStream )
        {
          len = p.len;
          if ( (int)(p.len - v3) <= 0x40000000 )
            goto LABEL_30;
          v5 = v3 + 0x40000000;
LABEL_9:
          if ( v3 > v5 || v5 > p.cap )
            runtime_panicslice();
          nn = v3;
          fna.array = &p.array[v3 & ((int)(v3 - p.cap) >> 31)];
          fna.len = v5 - v3;
          fna.cap = p.cap - v3;
          syscall_Write(fd->Sysfd, fna, v17, v18);
          v6 = v18;
          v7 = v17;
          if ( v17 <= 0 )
            v8 = nn;
          else
            v8 = v17 + nn;
          if ( v8 == p.len )
          {
            _r1._r1 = v8;
            _r1._r2 = v18;
            runtime_deferreturn(sizc);
            return _r1;
          }
          if ( v18.tab && &unk_80D5060 == (_UNKNOWN *)v18.tab->_type && *(_DWORD *)v18.data == 11 && fd->pd.runtimeCtx )
          {
            v16 = internal_poll___ptr_pollDesc__waitWrite(&fd->pd, fd->isFile);
            if ( !v16.tab )
              goto LABEL_5;
            v6 = v16;
            v7 = v17;
          }
          if ( v6.tab )
          {
            _r1._r1 = v8;
            _r1._r2 = v6;
            runtime_deferreturn(sizc);
            return _r1;
          }
          if ( !v7 )
          {
            _r1._r1 = v8;
            _r1._r2 = io_ErrUnexpectedEOF;
            runtime_deferreturn(sizc);
            return _r1;
          }
LABEL_5:
          v3 = v8;
        }
        len = p.len;
LABEL_30:
        v5 = len;
        goto LABEL_9;
      }
      _r1._r1 = 0;
      _r1._r2 = v15;
      runtime_deferreturn(sizb);
    }
  }
  return _r1;
}
// 809E28D: variable 'v2' is possibly undefined
// 809E32F: variable 'v17' is possibly undefined
// 809E32F: variable 'v18' is possibly undefined
// 809E3B4: variable 'sizc' is possibly undefined
// 809E47D: variable 'sizb' is possibly undefined
// 809E487: variable 'siza' is possibly undefined
// 809E4A1: variable 'siz' is possibly undefined

//----- (0809E4C0) --------------------------------------------------------
void __golang internal_poll_init()
{
  string text; // [esp+0h] [ebp-10h]
  string texta; // [esp+0h] [ebp-10h]
  error_0 v2; // [esp+8h] [ebp-8h]
  error_0 v3; // [esp+8h] [ebp-8h]

  if ( internal_poll_initdone_ <= 1u )
  {
    if ( internal_poll_initdone_ == 1 )
      runtime_throwinit();
    internal_poll_initdone_ = 1;
    sync_init();
    syscall_init();
    time_init();
    io_init();
    text.str = (uint8 *)"use of closed network connection";
    text.len = 32;
    v2 = errors_New(text);
    internal_poll_ErrNetClosing.tab = v2.tab;
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr((uintptr *)&internal_poll_ErrNetClosing.data, (uintptr)v2.data);
    else
      internal_poll_ErrNetClosing.data = v2.data;
    texta.str = (uint8 *)"use of closed file";
    texta.len = 18;
    v3 = errors_New(texta);
    internal_poll_ErrFileClosing.tab = v3.tab;
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr((uintptr *)&internal_poll_ErrFileClosing.data, (uintptr)v3.data);
    else
      internal_poll_ErrFileClosing.data = v3.data;
    internal_poll_initdone_ = 2;
  }
}

//----- (0809E5C0) --------------------------------------------------------
uintptr __golang type__hash_internal_poll_FD(internal_poll_FD_0 *p, uintptr h)
{
  return runtime_memhash(p, h, 0x1Fu);
}

//----- (0809E610) --------------------------------------------------------
bool __golang type__eq_internal_poll_FD(internal_poll_FD_0 *p, internal_poll_FD_0 *q)
{
  bool v2; // [esp+Ch] [ebp-4h]

  runtime_memequal();
  return v2;
}
// 809E646: variable 'v2' is possibly undefined

//----- (0809E660) --------------------------------------------------------
string __golang os___ptr_PathError__Error(os_PathError *e)
{
  int v1; // ebp
  unsigned int v2; // esi
  string a[5]; // [esp+4h] [ebp-30h]
  unsigned int a_4; // [esp+8h] [ebp-2Ch]

  v1 = ((int (__golang *)(void *))e->Err.tab->fun[0])(e->Err.data);
  v2 = a_4;
  a[2] = e->Path;
  a[0] = e->Op;
  a[1].str = (uint8 *)" ";
  a[1].len = 1;
  a[3].str = (uint8 *)": ";
  a[3].len = 2;
  a[4] = (string)__PAIR64__(v2, v1);
  return runtime_concatstring5(0, *(string (*)[5])&a[0].str);
}
// 809E660: could not find valid save-restore pair for ebp
// 809E660: could not find valid save-restore pair for esi
// 809E69E: variable 'a_4' is possibly undefined
// 80E0D84: using guessed type char go_string__;

//----- (0809E710) --------------------------------------------------------
string __golang os___ptr_File__Name(os_File *f)
{
  return f->file->name;
}

//----- (0809E740) --------------------------------------------------------
void __golang os___ptr_File__Write(os_File *f, __uint8 b, __int32 n, error_0 err)
{
  runtime_itab_0 *tab; // edx
  runtime_itab_0 *v5; // eax
  uint8 *data; // ecx
  uintptr *v7; // eax
  uint8 *str; // edx
  __int32 v9; // [esp+10h] [ebp-2Ch]
  error_0 e; // [esp+14h] [ebp-28h]
  error_0 ea; // [esp+14h] [ebp-28h]
  uint8 *err_itab; // [esp+28h] [ebp-14h]
  uint8 *err_data; // [esp+2Ch] [ebp-10h]
  uintptr *v14; // [esp+30h] [ebp-Ch]

  if ( f )
    tab = 0;
  else
    tab = os_ErrInvalid.tab;
  if ( !tab )
  {
    os___ptr_File__write(f, b, v9, e);
    os_epipecheck(f, ea);
    v5 = ea.tab;
    if ( ea.tab )
    {
      if ( io_EOF.tab == ea.tab )
      {
        if ( runtime_ifaceeq(ea.tab, ea.data, io_EOF.data) )
          return;
        v5 = ea.tab;
      }
      if ( internal_poll_ErrFileClosing.tab == v5 )
      {
        if ( runtime_ifaceeq(v5, ea.data, internal_poll_ErrFileClosing.data) )
        {
          v5 = os_ErrClosed.tab;
          data = (uint8 *)os_ErrClosed.data;
        }
        else
        {
          data = (uint8 *)ea.data;
          v5 = ea.tab;
        }
      }
      else
      {
        data = (uint8 *)ea.data;
      }
      err_data = data;
      err_itab = (uint8 *)v5;
      v7 = (uintptr *)runtime_newobject((runtime__type_0 *)&stru_80D57C0);
      v14 = v7;
      v7[1] = 5;
      if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      {
        runtime_writebarrierptr(v7, (uintptr)"write");
        v7 = v14;
      }
      else
      {
        *v7 = (uintptr)"write";
      }
      str = f->file->name.str;
      v7[3] = f->file->name.len;
      if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      {
        runtime_writebarrierptr(v7 + 2, (uintptr)str);
        v7 = v14;
      }
      else
      {
        v7[2] = (uintptr)str;
      }
      v7[4] = (uintptr)err_itab;
      if ( *(_DWORD *)&runtime_writeBarrier.enabled )
        runtime_writebarrierptr(v7 + 5, (uintptr)err_data);
      else
        v7[5] = (uintptr)err_data;
    }
  }
}
// 809E78C: variable 'v9' is possibly undefined
// 809E78C: variable 'e' is possibly undefined
// 809E7DE: variable 'ea' is possibly undefined

//----- (0809E9A0) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
retval_809E9A0 __golang os_Readlink(string name)
{
  __int32 i; // eax
  __int32 v2; // ecx
  uintptr *v3; // eax
  __uint8 b; // [esp+4h] [ebp-34h]
  __uint8 b_8; // [esp+Ch] [ebp-2Ch]
  string v6; // [esp+10h] [ebp-28h]
  uint8 *v7; // [esp+10h] [ebp-28h]
  __int32 v8; // [esp+14h] [ebp-24h]
  error_0 v9; // [esp+18h] [ebp-20h]
  __int32 len; // [esp+20h] [ebp-18h]
  unsigned __int32 b_cap; // [esp+24h] [ebp-14h]
  uint8 *b_ptr; // [esp+30h] [ebp-8h]
  uintptr *v13; // [esp+34h] [ebp-4h]
  retval_809E9A0 _r1; // [esp+44h] [ebp+Ch]

  for ( i = 128; ; i = 2 * len )
  {
    len = i;
    b_8 = (__uint8)runtime_makeslice((runtime__type_0 *)&::i, i, i);
    b_cap = b_8.cap;
    b_ptr = b_8.array;
    syscall_Readlink(name, b_8, b_8.cap, v9);
    v2 = v6.len;
    if ( v6.len < 0 )
      v2 = 0;
    if ( v9.tab )
      break;
    if ( v2 < len )
    {
      if ( v2 > b_cap )
        runtime_panicslice();
      b.array = b_ptr;
      *(_QWORD *)&b.len = __PAIR64__(b_cap, v2);
      runtime_slicebytetostring(0, b, v6);
      _r1._r1.str = v7;
      _r1._r1.len = v8;
      _r1._r2.tab = 0;
      _r1._r2.data = 0;
      return _r1;
    }
  }
  v3 = (uintptr *)runtime_newobject((runtime__type_0 *)&stru_80D57C0);
  v13 = v3;
  v3[1] = 8;
  if ( *(_DWORD *)&runtime_writeBarrier.enabled )
  {
    runtime_writebarrierptr(v3, (uintptr)"readlink");
    v3 = v13;
  }
  else
  {
    *v3 = (uintptr)"readlink";
  }
  v3[3] = name.len;
  if ( *(_DWORD *)&runtime_writeBarrier.enabled )
  {
    runtime_writebarrierptr(v3 + 2, (uintptr)name.str);
    v3 = v13;
  }
  else
  {
    v3[2] = (uintptr)name.str;
  }
  v3[4] = (uintptr)v9.tab;
  if ( *(_DWORD *)&runtime_writeBarrier.enabled )
  {
    runtime_writebarrierptr(v3 + 5, (uintptr)v9.data);
    v3 = v13;
  }
  else
  {
    v3[5] = (uintptr)v9.data;
  }
  _r1._r1.str = 0;
  _r1._r1.len = 0;
  _r1._r2.tab = (runtime_itab_0 *)&go_itab__os_PathError_error;
  _r1._r2.data = v3;
  return _r1;
}
// 809E9D8: failed to expand linear variable ^C.12
// 8136670: using guessed type runtime_interfacetype_0 *go_itab__os_PathError_error;

//----- (0809EB70) --------------------------------------------------------
os_File *__golang os_NewFile(uintptr fd, string name)
{
  return os_newFile(fd, name, 0);
}

//----- (0809EBC0) --------------------------------------------------------
os_File *__golang os_newFile(uintptr fd, string name, bool pollable)
{
  internal_poll_FD_0 *v3; // eax
  interface_{} typ; // [esp+0h] [ebp-20h]
  string net; // [esp+4h] [ebp-1Ch]
  string net_4; // [esp+8h] [ebp-18h]
  string net_4a; // [esp+8h] [ebp-18h]
  int net_4b; // [esp+8h] [ebp-18h]
  uintptr *f; // [esp+18h] [ebp-8h]
  internal_poll_FD_0 *v10; // [esp+1Ch] [ebp-4h]

  if ( (fd & 0x80000000) != 0 )
    return 0;
  f = (uintptr *)runtime_newobject((runtime__type_0 *)&stru_80D4820);
  v3 = (internal_poll_FD_0 *)runtime_newobject((runtime__type_0 *)&stru_80D69A0);
  v10 = v3;
  v3->Sysfd = fd;
  *(_WORD *)&v3->IsStream = 257;
  HIDWORD(v3[1].fdmu.state) = name.len;
  if ( *(_DWORD *)&runtime_writeBarrier.enabled )
  {
    runtime_writebarrierptr((uintptr *)&v3[1], (uintptr)name.str);
    v3 = v10;
  }
  else
  {
    LODWORD(v3[1].fdmu.state) = name.str;
  }
  if ( *(_DWORD *)&runtime_writeBarrier.enabled )
  {
    runtime_writebarrierptr(f, (uintptr)v3);
    v3 = v10;
  }
  else
  {
    *f = (uintptr)v3;
  }
  net.str = (uint8 *)"file";
  net.len = 4;
  if ( !(unsigned int)internal_poll___ptr_FD__Init(v3, net, pollable).tab && pollable )
  {
    syscall_SetNonblock(fd, 1, (error_0)net_4);
    if ( !net_4b )
      *(_BYTE *)(*f + 44) = 1;
  }
  typ._type = (runtime__type_0 *)&obj;
  typ.data = (void *)*f;
  net_4a.str = (uint8 *)&finalizer;
  net_4a.len = (__int32)&off_80E7B1C;
  runtime_SetFinalizer(typ, (interface_{})net_4a);
  return (os_File *)f;
}
// 809ECCB: variable 'net_4' is possibly undefined
// 809ECD6: variable 'net_4b' is possibly undefined
// 80E7B1C: using guessed type int (__golang *off_80E7B1C)(os_file *file, error_0 _r0);

//----- (0809ED30) --------------------------------------------------------
void __golang os_epipecheck(os_File *file, error_0 e)
{
  __int32 Sysfd; // eax

  if ( e.tab )
  {
    if ( e.tab->_type == (runtime__type_0 *)&unk_80D5060 && *(_DWORD *)e.data == 32 )
    {
      Sysfd = file->file->pfd.Sysfd;
      if ( Sysfd == 1 || Sysfd == 2 )
        os_sigpipe();
    }
  }
}

//----- (0809ED90) --------------------------------------------------------
error_0 __golang os___ptr_file__close(os_file *file)
{
  runtime_itab_0 *tab; // eax
  uint8 *data; // ecx
  uintptr *v3; // eax
  os_file *v4; // ecx
  uint8 *str; // edx
  runtime_interfacetype_0 **v6; // edx
  interface_{} fd; // [esp+0h] [ebp-24h]
  error_0 src; // [esp+4h] [ebp-20h]
  error_0 err_itab; // [esp+10h] [ebp-14h]
  uint8 *e_itab; // [esp+18h] [ebp-Ch]
  error_0 e_itaba; // [esp+18h] [ebp-Ch]
  uint8 *e_data; // [esp+1Ch] [ebp-8h]
  uintptr *v13; // [esp+20h] [ebp-4h]
  error_0 _r0; // [esp+2Ch] [ebp+8h]

  if ( file )
  {
    src = internal_poll___ptr_FD__Close(&file->pfd);
    data = (uint8 *)src.data;
    tab = src.tab;
    if ( src.tab )
    {
      if ( src.tab == internal_poll_ErrFileClosing.tab )
      {
        e_itaba = src;
        if ( runtime_ifaceeq(src.tab, src.data, internal_poll_ErrFileClosing.data) )
        {
          tab = os_ErrClosed.tab;
          data = (uint8 *)os_ErrClosed.data;
        }
        else
        {
          data = (uint8 *)e_itaba.data;
          tab = e_itaba.tab;
        }
      }
      e_data = data;
      e_itab = (uint8 *)tab;
      v3 = (uintptr *)runtime_newobject((runtime__type_0 *)&stru_80D57C0);
      v13 = v3;
      v3[1] = 5;
      if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      {
        runtime_writebarrierptr(v3, (uintptr)"close");
        v3 = v13;
      }
      else
      {
        *v3 = (uintptr)"close";
      }
      v4 = file;
      str = file->name.str;
      v3[3] = file->name.len;
      if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      {
        runtime_writebarrierptr(v3 + 2, (uintptr)str);
        v3 = v13;
        v4 = file;
      }
      else
      {
        v3[2] = (uintptr)str;
      }
      v3[4] = (uintptr)e_itab;
      if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      {
        runtime_writebarrierptr(v3 + 5, (uintptr)e_data);
        v3 = v13;
        v4 = file;
      }
      else
      {
        v3[5] = (uintptr)e_data;
      }
      v6 = &go_itab__os_PathError_error;
    }
    else
    {
      v4 = file;
      v6 = 0;
      v3 = 0;
    }
    err_itab = (error_0)__PAIR64__((unsigned int)v3, (unsigned int)v6);
    fd._type = (runtime__type_0 *)&obj;
    fd.data = v4;
    runtime_SetFinalizer(fd, 0LL);
    return err_itab;
  }
  else
  {
    _r0.tab = &go_itab_syscall_Errno_error;
    _r0.data = &os_statictmp_4;
  }
  return _r0;
}
// 8136670: using guessed type runtime_interfacetype_0 *go_itab__os_PathError_error;

//----- (0809EF60) --------------------------------------------------------
void __golang os___ptr_File__write(os_File *f, __uint8 b, __int32 n, error_0 err)
{
  internal_poll___ptr_FD__Write(&f->file->pfd, b);
}

//----- (0809EFC0) --------------------------------------------------------
void __golang os_init_0()
{
  __string src; // [esp+0h] [ebp-Ch]

  src = os_runtime_args();
  os_Args.len = src.len;
  os_Args.cap = src.cap;
  if ( *(_DWORD *)&runtime_writeBarrier.enabled )
    runtime_writebarrierptr((uintptr *)&os_Args, (uintptr)src.array);
  else
    os_Args.array = src.array;
}

//----- (0809F020) --------------------------------------------------------
retval_809F020 __golang os_glob__func1()
{
  string name; // [esp+0h] [ebp-18h]
  retval_809F020 _r0; // [esp+1Ch] [ebp+4h]

  name.str = (uint8 *)"/proc/self/exe";
  name.len = 14;
  _r0 = (retval_809F020)os_Readlink(name);
  return _r0;
}

//----- (0809F080) --------------------------------------------------------
void __golang os_init()
{
  runtime_itab_0 *tab; // edx
  void *data; // ebx
  string texta; // [esp+0h] [ebp-18h]
  string textb; // [esp+0h] [ebp-18h]
  string textc; // [esp+0h] [ebp-18h]
  string textd; // [esp+0h] [ebp-18h]
  string texte; // [esp+0h] [ebp-18h]
  string textf; // [esp+0h] [ebp-18h]
  retval_809F020 text; // [esp+0h] [ebp-18h]
  string text_4; // [esp+4h] [ebp-14h]
  string text_4a; // [esp+4h] [ebp-14h]
  string text_4b; // [esp+4h] [ebp-14h]
  error_0 v12; // [esp+8h] [ebp-10h]
  error_0 v13; // [esp+8h] [ebp-10h]
  error_0 v14; // [esp+8h] [ebp-10h]
  error_0 v15; // [esp+8h] [ebp-10h]
  error_0 v16; // [esp+8h] [ebp-10h]
  error_0 v17; // [esp+8h] [ebp-10h]
  os_File *src; // [esp+Ch] [ebp-Ch]
  os_File *srca; // [esp+Ch] [ebp-Ch]
  os_File *srcb; // [esp+Ch] [ebp-Ch]

  if ( os_initdone_ <= 1u )
  {
    if ( os_initdone_ == 1 )
      runtime_throwinit();
    os_initdone_ = 1;
    io_init();
    runtime_init();
    syscall_init();
    sync_init();
    time_init();
    internal_poll_init();
    texta.str = (uint8 *)"invalid argument";
    texta.len = 16;
    v12 = errors_New(texta);
    os_ErrInvalid.tab = v12.tab;
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr((uintptr *)&os_ErrInvalid.data, (uintptr)v12.data);
    else
      os_ErrInvalid.data = v12.data;
    textb.str = (uint8 *)"permission denied";
    textb.len = 17;
    v13 = errors_New(textb);
    os_ErrPermission.tab = v13.tab;
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr((uintptr *)&os_ErrPermission.data, (uintptr)v13.data);
    else
      os_ErrPermission.data = v13.data;
    textc.str = (uint8 *)"file already exists";
    textc.len = 19;
    v14 = errors_New(textc);
    os_ErrExist.tab = v14.tab;
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr((uintptr *)&os_ErrExist.data, (uintptr)v14.data);
    else
      os_ErrExist.data = v14.data;
    textd.str = (uint8 *)"file does not exist";
    textd.len = 19;
    v15 = errors_New(textd);
    os_ErrNotExist.tab = v15.tab;
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr((uintptr *)&os_ErrNotExist.data, (uintptr)v15.data);
    else
      os_ErrNotExist.data = v15.data;
    texte.str = (uint8 *)"file already closed";
    texte.len = 19;
    v16 = errors_New(texte);
    os_ErrClosed.tab = v16.tab;
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr((uintptr *)&os_ErrClosed.data, (uintptr)v16.data);
    else
      os_ErrClosed.data = v16.data;
    textf.str = (uint8 *)"os: process already finished";
    textf.len = 28;
    v17 = errors_New(textf);
    os_errFinished.tab = v17.tab;
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr((uintptr *)&os_errFinished.data, (uintptr)v17.data);
    else
      os_errFinished.data = v17.data;
    text = os_glob__func1();
    tab = text._r1.tab;
    data = text._r1.data;
    os_executablePath.len = text._r0.len;
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
    {
      runtime_writebarrierptr((uintptr *)&os_executablePath, (uintptr)text._r0.str);
      tab = text._r1.tab;
      data = text._r1.data;
    }
    else
    {
      os_executablePath.str = text._r0.str;
    }
    os_executablePathErr.tab = tab;
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr((uintptr *)&os_executablePathErr.data, (uintptr)data);
    else
      os_executablePathErr.data = data;
    text_4.str = (uint8 *)"/dev/stdin";
    text_4.len = 10;
    src = os_NewFile(syscall_Stdin, text_4);
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr(&os_Stdin, (uintptr)src);
    else
      os_Stdin = (uintptr)src;
    text_4a.str = (uint8 *)"/dev/stdout";
    text_4a.len = 11;
    srca = os_NewFile(syscall_Stdout, text_4a);
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr(&os_Stdout, (uintptr)srca);
    else
      os_Stdout = (uintptr)srca;
    text_4b.str = (uint8 *)"/dev/stderr";
    text_4b.len = 11;
    srcb = os_NewFile(syscall_Stderr, text_4b);
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr(&os_Stderr, (uintptr)srcb);
    else
      os_Stderr = (uintptr)srcb;
    os_init_0();
    os_initdone_ = 2;
  }
}
// 809F080: could not find valid save-restore pair for ebx

//----- (0809F430) --------------------------------------------------------
uintptr __golang type__hash_os_file(os_file *p, uintptr h)
{
  uintptr s; // [esp+8h] [ebp-8h]
  uintptr sa; // [esp+8h] [ebp-8h]

  s = type__hash_internal_poll_FD(&p->pfd, h);
  sa = runtime_strhash(&p->name, s);
  return runtime_memhash(&p->dirinfo, sa, 5u);
}

//----- (0809F4B0) --------------------------------------------------------
bool __golang type__eq_os_file(os_file *p, os_file *q)
{
  os_file *v2; // eax
  os_file *v3; // edx
  char v4; // cl
  char v6; // [esp+10h] [ebp-4h]

  if ( type__eq_internal_poll_FD(&p->pfd, &q->pfd) )
  {
    v2 = p;
    v3 = q;
    if ( p->name.len == q->name.len )
    {
      runtime_eqstring();
      v4 = v6;
      v2 = p;
      v3 = q;
    }
    else
    {
      v4 = 0;
    }
  }
  else
  {
    v2 = p;
    v3 = q;
    v4 = 0;
  }
  return v4 && v2->dirinfo == v3->dirinfo && v2->nonblock == v3->nonblock;
}
// 809F53F: variable 'v6' is possibly undefined

//----- (0809F570) --------------------------------------------------------
uintptr __golang type__hash_os_PathError(os_PathError *p, uintptr h)
{
  uintptr v2; // [esp+8h] [ebp-4h]
  uintptr v3; // [esp+8h] [ebp-4h]

  v2 = runtime_strhash(p, h);
  v3 = runtime_strhash(&p->Path, v2);
  return runtime_interhash(&p->Err, v3);
}

//----- (0809F5E0) --------------------------------------------------------
bool __golang type__eq_os_PathError(os_PathError *p, os_PathError *q)
{
  os_PathError *v2; // eax
  os_PathError *v3; // ebx
  char v4; // cl
  char v5; // cl
  runtime_itab_0 *tab; // ecx
  void *x; // ebx
  char v9; // [esp+10h] [ebp-4h]

  v2 = q;
  v3 = p;
  if ( q->Op.len == p->Op.len )
  {
    runtime_eqstring();
    v4 = v9;
    v2 = q;
    v3 = p;
  }
  else
  {
    v4 = 0;
  }
  if ( v4 )
  {
    if ( v3->Path.len == v2->Path.len )
    {
      runtime_eqstring();
      v5 = v9;
      v2 = q;
      v3 = p;
    }
    else
    {
      v5 = 0;
    }
  }
  else
  {
    v5 = 0;
  }
  if ( !v5 )
    return 0;
  tab = v3->Err.tab;
  x = v3->Err.data;
  return tab == v2->Err.tab && runtime_ifaceeq(tab, x, v2->Err.data);
}
// 809F674: variable 'v9' is possibly undefined

//----- (0809F6C0) --------------------------------------------------------
void __golang unicode_init()
{
  string hint_4; // [esp+8h] [ebp-28h]
  string hint_4a; // [esp+8h] [ebp-28h]
  string hint_4b; // [esp+8h] [ebp-28h]
  string hint_4c; // [esp+8h] [ebp-28h]
  string hint_4d; // [esp+8h] [ebp-28h]
  string hint_4e; // [esp+8h] [ebp-28h]
  string hint_4f; // [esp+8h] [ebp-28h]
  string hint_4g; // [esp+8h] [ebp-28h]
  string hint_4h; // [esp+8h] [ebp-28h]
  string hint_4i; // [esp+8h] [ebp-28h]
  string hint_4j; // [esp+8h] [ebp-28h]
  string hint_4k; // [esp+8h] [ebp-28h]
  string hint_4l; // [esp+8h] [ebp-28h]
  string hint_4m; // [esp+8h] [ebp-28h]
  string hint_4n; // [esp+8h] [ebp-28h]
  string hint_4o; // [esp+8h] [ebp-28h]
  string hint_4p; // [esp+8h] [ebp-28h]
  string hint_4q; // [esp+8h] [ebp-28h]
  string hint_4r; // [esp+8h] [ebp-28h]
  string hint_4s; // [esp+8h] [ebp-28h]
  string hint_4t; // [esp+8h] [ebp-28h]
  string hint_4u; // [esp+8h] [ebp-28h]
  string hint_4v; // [esp+8h] [ebp-28h]
  string hint_4w; // [esp+8h] [ebp-28h]
  string hint_4x; // [esp+8h] [ebp-28h]
  string hint_4y; // [esp+8h] [ebp-28h]
  string hint_4z; // [esp+8h] [ebp-28h]
  string hint_4ba; // [esp+8h] [ebp-28h]
  string hint_4bb; // [esp+8h] [ebp-28h]
  string hint_4bc; // [esp+8h] [ebp-28h]
  string hint_4bd; // [esp+8h] [ebp-28h]
  string hint_4be; // [esp+8h] [ebp-28h]
  string hint_4bf; // [esp+8h] [ebp-28h]
  string hint_4bg; // [esp+8h] [ebp-28h]
  string hint_4bh; // [esp+8h] [ebp-28h]
  string hint_4bi; // [esp+8h] [ebp-28h]
  string hint_4bj; // [esp+8h] [ebp-28h]
  string hint_4bk; // [esp+8h] [ebp-28h]
  string hint_4bl; // [esp+8h] [ebp-28h]
  string hint_4bm; // [esp+8h] [ebp-28h]
  string hint_4bn; // [esp+8h] [ebp-28h]
  string hint_4bo; // [esp+8h] [ebp-28h]
  string hint_4bp; // [esp+8h] [ebp-28h]
  string hint_4bq; // [esp+8h] [ebp-28h]
  string hint_4br; // [esp+8h] [ebp-28h]
  string hint_4bs; // [esp+8h] [ebp-28h]
  string hint_4bt; // [esp+8h] [ebp-28h]
  string hint_4bu; // [esp+8h] [ebp-28h]
  string hint_4bv; // [esp+8h] [ebp-28h]
  string hint_4bw; // [esp+8h] [ebp-28h]
  string hint_4bx; // [esp+8h] [ebp-28h]
  string hint_4by; // [esp+8h] [ebp-28h]
  string hint_4bz; // [esp+8h] [ebp-28h]
  string hint_4ca; // [esp+8h] [ebp-28h]
  string hint_4cb; // [esp+8h] [ebp-28h]
  string hint_4cc; // [esp+8h] [ebp-28h]
  string hint_4cd; // [esp+8h] [ebp-28h]
  string hint_4ce; // [esp+8h] [ebp-28h]
  string hint_4cf; // [esp+8h] [ebp-28h]
  string hint_4cg; // [esp+8h] [ebp-28h]
  string hint_4ch; // [esp+8h] [ebp-28h]
  string hint_4ci; // [esp+8h] [ebp-28h]
  string hint_4cj; // [esp+8h] [ebp-28h]
  string hint_4ck; // [esp+8h] [ebp-28h]
  string hint_4cl; // [esp+8h] [ebp-28h]
  string hint_4cm; // [esp+8h] [ebp-28h]
  string hint_4cn; // [esp+8h] [ebp-28h]
  string hint_4co; // [esp+8h] [ebp-28h]
  string hint_4cp; // [esp+8h] [ebp-28h]
  string hint_4cq; // [esp+8h] [ebp-28h]
  string hint_4cr; // [esp+8h] [ebp-28h]
  string hint_4cs; // [esp+8h] [ebp-28h]
  string hint_4ct; // [esp+8h] [ebp-28h]
  string hint_4cu; // [esp+8h] [ebp-28h]
  string hint_4cv; // [esp+8h] [ebp-28h]
  string hint_4cw; // [esp+8h] [ebp-28h]
  string hint_4cx; // [esp+8h] [ebp-28h]
  string hint_4cy; // [esp+8h] [ebp-28h]
  string hint_4cz; // [esp+8h] [ebp-28h]
  string hint_4da; // [esp+8h] [ebp-28h]
  string hint_4db; // [esp+8h] [ebp-28h]
  string hint_4dc; // [esp+8h] [ebp-28h]
  string hint_4dd; // [esp+8h] [ebp-28h]
  string hint_4de; // [esp+8h] [ebp-28h]
  string hint_4df; // [esp+8h] [ebp-28h]
  string hint_4dg; // [esp+8h] [ebp-28h]
  string hint_4dh; // [esp+8h] [ebp-28h]
  string hint_4di; // [esp+8h] [ebp-28h]
  string hint_4dj; // [esp+8h] [ebp-28h]
  string hint_4dk; // [esp+8h] [ebp-28h]
  string hint_4dl; // [esp+8h] [ebp-28h]
  string hint_4dm; // [esp+8h] [ebp-28h]
  string hint_4dn; // [esp+8h] [ebp-28h]
  string hint_4do; // [esp+8h] [ebp-28h]
  string hint_4dp; // [esp+8h] [ebp-28h]
  string hint_4dq; // [esp+8h] [ebp-28h]
  string hint_4dr; // [esp+8h] [ebp-28h]
  string hint_4ds; // [esp+8h] [ebp-28h]
  string hint_4dt; // [esp+8h] [ebp-28h]
  string hint_4du; // [esp+8h] [ebp-28h]
  string hint_4dv; // [esp+8h] [ebp-28h]
  string hint_4dw; // [esp+8h] [ebp-28h]
  string hint_4dx; // [esp+8h] [ebp-28h]
  string hint_4dy; // [esp+8h] [ebp-28h]
  string hint_4dz; // [esp+8h] [ebp-28h]
  string hint_4ea; // [esp+8h] [ebp-28h]
  string hint_4eb; // [esp+8h] [ebp-28h]
  string hint_4ec; // [esp+8h] [ebp-28h]
  string hint_4ed; // [esp+8h] [ebp-28h]
  string hint_4ee; // [esp+8h] [ebp-28h]
  string hint_4ef; // [esp+8h] [ebp-28h]
  string hint_4eg; // [esp+8h] [ebp-28h]
  string hint_4eh; // [esp+8h] [ebp-28h]
  string hint_4ei; // [esp+8h] [ebp-28h]
  string hint_4ej; // [esp+8h] [ebp-28h]
  string hint_4ek; // [esp+8h] [ebp-28h]
  string hint_4el; // [esp+8h] [ebp-28h]
  string hint_4em; // [esp+8h] [ebp-28h]
  string hint_4en; // [esp+8h] [ebp-28h]
  string hint_4eo; // [esp+8h] [ebp-28h]
  string hint_4ep; // [esp+8h] [ebp-28h]
  string hint_4eq; // [esp+8h] [ebp-28h]
  string hint_4er; // [esp+8h] [ebp-28h]
  string hint_4es; // [esp+8h] [ebp-28h]
  string hint_4et; // [esp+8h] [ebp-28h]
  string hint_4eu; // [esp+8h] [ebp-28h]
  string hint_4ev; // [esp+8h] [ebp-28h]
  string hint_4ew; // [esp+8h] [ebp-28h]
  string hint_4ex; // [esp+8h] [ebp-28h]
  string hint_4ey; // [esp+8h] [ebp-28h]
  string hint_4ez; // [esp+8h] [ebp-28h]
  string hint_4fa; // [esp+8h] [ebp-28h]
  string hint_4fb; // [esp+8h] [ebp-28h]
  string hint_4fc; // [esp+8h] [ebp-28h]
  string hint_4fd; // [esp+8h] [ebp-28h]
  string hint_4fe; // [esp+8h] [ebp-28h]
  string hint_4ff; // [esp+8h] [ebp-28h]
  string hint_4fg; // [esp+8h] [ebp-28h]
  string hint_4fh; // [esp+8h] [ebp-28h]
  string hint_4fi; // [esp+8h] [ebp-28h]
  string hint_4fj; // [esp+8h] [ebp-28h]
  string hint_4fk; // [esp+8h] [ebp-28h]
  string hint_4fl; // [esp+8h] [ebp-28h]
  string hint_4fm; // [esp+8h] [ebp-28h]
  string hint_4fn; // [esp+8h] [ebp-28h]
  string hint_4fo; // [esp+8h] [ebp-28h]
  string hint_4fp; // [esp+8h] [ebp-28h]
  string hint_4fq; // [esp+8h] [ebp-28h]
  string hint_4fr; // [esp+8h] [ebp-28h]
  string hint_4fs; // [esp+8h] [ebp-28h]
  string hint_4ft; // [esp+8h] [ebp-28h]
  string hint_4fu; // [esp+8h] [ebp-28h]
  string hint_4fv; // [esp+8h] [ebp-28h]
  string hint_4fw; // [esp+8h] [ebp-28h]
  string hint_4fx; // [esp+8h] [ebp-28h]
  string hint_4fy; // [esp+8h] [ebp-28h]
  string hint_4fz; // [esp+8h] [ebp-28h]
  string hint_4ga; // [esp+8h] [ebp-28h]
  string hint_4gb; // [esp+8h] [ebp-28h]
  string hint_4gc; // [esp+8h] [ebp-28h]
  string hint_4gd; // [esp+8h] [ebp-28h]
  string hint_4ge; // [esp+8h] [ebp-28h]
  string hint_4gf; // [esp+8h] [ebp-28h]
  string hint_4gg; // [esp+8h] [ebp-28h]
  string hint_4gh; // [esp+8h] [ebp-28h]
  string hint_4gi; // [esp+8h] [ebp-28h]
  string hint_4gj; // [esp+8h] [ebp-28h]
  string hint_4gk; // [esp+8h] [ebp-28h]
  string hint_4gl; // [esp+8h] [ebp-28h]
  string hint_4gm; // [esp+8h] [ebp-28h]
  string hint_4gn; // [esp+8h] [ebp-28h]
  string hint_4go; // [esp+8h] [ebp-28h]
  string hint_4gp; // [esp+8h] [ebp-28h]
  string hint_4gq; // [esp+8h] [ebp-28h]
  string hint_4gr; // [esp+8h] [ebp-28h]
  string hint_4gs; // [esp+8h] [ebp-28h]
  string hint_4gt; // [esp+8h] [ebp-28h]
  string hint_4gu; // [esp+8h] [ebp-28h]
  string hint_4gv; // [esp+8h] [ebp-28h]
  string hint_4gw; // [esp+8h] [ebp-28h]
  string hint_4gx; // [esp+8h] [ebp-28h]
  string hint_4gy; // [esp+8h] [ebp-28h]
  string hint_4gz; // [esp+8h] [ebp-28h]
  string hint_4ha; // [esp+8h] [ebp-28h]
  string hint_4hb; // [esp+8h] [ebp-28h]
  string hint_4hc; // [esp+8h] [ebp-28h]
  string hint_4hd; // [esp+8h] [ebp-28h]
  string hint_4he; // [esp+8h] [ebp-28h]
  string hint_4hf; // [esp+8h] [ebp-28h]
  string hint_4hg; // [esp+8h] [ebp-28h]
  string hint_4hh; // [esp+8h] [ebp-28h]
  string hint_4hi; // [esp+8h] [ebp-28h]
  string hint_4hj; // [esp+8h] [ebp-28h]
  string hint_4hk; // [esp+8h] [ebp-28h]
  string hint_4hl; // [esp+8h] [ebp-28h]
  string hint_4hm; // [esp+8h] [ebp-28h]
  string hint_4hn; // [esp+8h] [ebp-28h]
  string hint_4ho; // [esp+8h] [ebp-28h]
  string hint_4hp; // [esp+8h] [ebp-28h]
  string hint_4hq; // [esp+8h] [ebp-28h]
  string hint_4hr; // [esp+8h] [ebp-28h]
  string hint_4hs; // [esp+8h] [ebp-28h]
  string hint_4ht; // [esp+8h] [ebp-28h]
  string hint_4hu; // [esp+8h] [ebp-28h]
  string hint_4hv; // [esp+8h] [ebp-28h]
  string hint_4hw; // [esp+8h] [ebp-28h]
  string hint_4hx; // [esp+8h] [ebp-28h]
  string hint_4hy; // [esp+8h] [ebp-28h]
  string hint_4hz; // [esp+8h] [ebp-28h]
  string hint_4ia; // [esp+8h] [ebp-28h]
  string hint_4ib; // [esp+8h] [ebp-28h]
  string hint_4ic; // [esp+8h] [ebp-28h]
  string hint_4id; // [esp+8h] [ebp-28h]
  string hint_4ie; // [esp+8h] [ebp-28h]
  string hint_4if; // [esp+8h] [ebp-28h]
  string hint_4ig; // [esp+8h] [ebp-28h]
  uintptr *bucket; // [esp+10h] [ebp-20h]
  uintptr *bucketa; // [esp+10h] [ebp-20h]
  uintptr *bucketb; // [esp+10h] [ebp-20h]
  uintptr *bucketc; // [esp+10h] [ebp-20h]
  uintptr *bucketd; // [esp+10h] [ebp-20h]
  uintptr *buckete; // [esp+10h] [ebp-20h]
  uintptr *bucketf; // [esp+10h] [ebp-20h]
  uintptr *bucketg; // [esp+10h] [ebp-20h]
  uintptr *bucketh; // [esp+10h] [ebp-20h]
  uintptr *bucketi; // [esp+10h] [ebp-20h]
  uintptr *bucketj; // [esp+10h] [ebp-20h]
  uintptr *bucketk; // [esp+10h] [ebp-20h]
  uintptr *bucketl; // [esp+10h] [ebp-20h]
  uintptr *bucketm; // [esp+10h] [ebp-20h]
  uintptr *bucketn; // [esp+10h] [ebp-20h]
  uintptr *bucketo; // [esp+10h] [ebp-20h]
  uintptr *bucketp; // [esp+10h] [ebp-20h]
  uintptr *bucketq; // [esp+10h] [ebp-20h]
  uintptr *bucketr; // [esp+10h] [ebp-20h]
  uintptr *buckets; // [esp+10h] [ebp-20h]
  uintptr *buckett; // [esp+10h] [ebp-20h]
  uintptr *bucketu; // [esp+10h] [ebp-20h]
  uintptr *bucketv; // [esp+10h] [ebp-20h]
  uintptr *bucketw; // [esp+10h] [ebp-20h]
  uintptr *bucketx; // [esp+10h] [ebp-20h]
  uintptr *buckety; // [esp+10h] [ebp-20h]
  uintptr *bucketz; // [esp+10h] [ebp-20h]
  uintptr *bucketba; // [esp+10h] [ebp-20h]
  uintptr *bucketbb; // [esp+10h] [ebp-20h]
  uintptr *bucketbc; // [esp+10h] [ebp-20h]
  uintptr *bucketbd; // [esp+10h] [ebp-20h]
  uintptr *bucketbe; // [esp+10h] [ebp-20h]
  uintptr *bucketbf; // [esp+10h] [ebp-20h]
  uintptr *bucketbg; // [esp+10h] [ebp-20h]
  uintptr *bucketbh; // [esp+10h] [ebp-20h]
  uintptr *bucketbi; // [esp+10h] [ebp-20h]
  uintptr *bucketbj; // [esp+10h] [ebp-20h]
  uintptr *bucketbk; // [esp+10h] [ebp-20h]
  uintptr *bucketbl; // [esp+10h] [ebp-20h]
  uintptr *bucketbm; // [esp+10h] [ebp-20h]
  uintptr *bucketbn; // [esp+10h] [ebp-20h]
  uintptr *bucketbo; // [esp+10h] [ebp-20h]
  uintptr *bucketbp; // [esp+10h] [ebp-20h]
  uintptr *bucketbq; // [esp+10h] [ebp-20h]
  uintptr *bucketbr; // [esp+10h] [ebp-20h]
  uintptr *bucketbs; // [esp+10h] [ebp-20h]
  uintptr *bucketbt; // [esp+10h] [ebp-20h]
  uintptr *bucketbu; // [esp+10h] [ebp-20h]
  uintptr *bucketbv; // [esp+10h] [ebp-20h]
  uintptr *bucketbw; // [esp+10h] [ebp-20h]
  uintptr *bucketbx; // [esp+10h] [ebp-20h]
  uintptr *bucketby; // [esp+10h] [ebp-20h]
  uintptr *bucketbz; // [esp+10h] [ebp-20h]
  uintptr *bucketca; // [esp+10h] [ebp-20h]
  uintptr *bucketcb; // [esp+10h] [ebp-20h]
  uintptr *bucketcc; // [esp+10h] [ebp-20h]
  uintptr *bucketcd; // [esp+10h] [ebp-20h]
  uintptr *bucketce; // [esp+10h] [ebp-20h]
  uintptr *bucketcf; // [esp+10h] [ebp-20h]
  uintptr *bucketcg; // [esp+10h] [ebp-20h]
  uintptr *bucketch; // [esp+10h] [ebp-20h]
  uintptr *bucketci; // [esp+10h] [ebp-20h]
  uintptr *bucketcj; // [esp+10h] [ebp-20h]
  uintptr *bucketck; // [esp+10h] [ebp-20h]
  uintptr *bucketcl; // [esp+10h] [ebp-20h]
  uintptr *bucketcm; // [esp+10h] [ebp-20h]
  uintptr *bucketcn; // [esp+10h] [ebp-20h]
  uintptr *bucketco; // [esp+10h] [ebp-20h]
  uintptr *bucketcp; // [esp+10h] [ebp-20h]
  uintptr *bucketcq; // [esp+10h] [ebp-20h]
  uintptr *bucketcr; // [esp+10h] [ebp-20h]
  uintptr *bucketcs; // [esp+10h] [ebp-20h]
  uintptr *bucketct; // [esp+10h] [ebp-20h]
  uintptr *bucketcu; // [esp+10h] [ebp-20h]
  uintptr *bucketcv; // [esp+10h] [ebp-20h]
  uintptr *bucketcw; // [esp+10h] [ebp-20h]
  uintptr *bucketcx; // [esp+10h] [ebp-20h]
  uintptr *bucketcy; // [esp+10h] [ebp-20h]
  uintptr *bucketcz; // [esp+10h] [ebp-20h]
  uintptr *bucketda; // [esp+10h] [ebp-20h]
  uintptr *bucketdb; // [esp+10h] [ebp-20h]
  uintptr *bucketdc; // [esp+10h] [ebp-20h]
  uintptr *bucketdd; // [esp+10h] [ebp-20h]
  uintptr *bucketde; // [esp+10h] [ebp-20h]
  uintptr *bucketdf; // [esp+10h] [ebp-20h]
  uintptr *bucketdg; // [esp+10h] [ebp-20h]
  uintptr *bucketdh; // [esp+10h] [ebp-20h]
  uintptr *bucketdi; // [esp+10h] [ebp-20h]
  uintptr *bucketdj; // [esp+10h] [ebp-20h]
  uintptr *bucketdk; // [esp+10h] [ebp-20h]
  uintptr *bucketdl; // [esp+10h] [ebp-20h]
  uintptr *bucketdm; // [esp+10h] [ebp-20h]
  uintptr *bucketdn; // [esp+10h] [ebp-20h]
  uintptr *bucketdo; // [esp+10h] [ebp-20h]
  uintptr *bucketdp; // [esp+10h] [ebp-20h]
  uintptr *bucketdq; // [esp+10h] [ebp-20h]
  uintptr *bucketdr; // [esp+10h] [ebp-20h]
  uintptr *bucketds; // [esp+10h] [ebp-20h]
  uintptr *bucketdt; // [esp+10h] [ebp-20h]
  uintptr *bucketdu; // [esp+10h] [ebp-20h]
  uintptr *bucketdv; // [esp+10h] [ebp-20h]
  uintptr *bucketdw; // [esp+10h] [ebp-20h]
  uintptr *bucketdx; // [esp+10h] [ebp-20h]
  uintptr *bucketdy; // [esp+10h] [ebp-20h]
  uintptr *bucketdz; // [esp+10h] [ebp-20h]
  uintptr *bucketea; // [esp+10h] [ebp-20h]
  uintptr *bucketeb; // [esp+10h] [ebp-20h]
  uintptr *bucketec; // [esp+10h] [ebp-20h]
  uintptr *bucketed; // [esp+10h] [ebp-20h]
  uintptr *bucketee; // [esp+10h] [ebp-20h]
  uintptr *bucketef; // [esp+10h] [ebp-20h]
  uintptr *bucketeg; // [esp+10h] [ebp-20h]
  uintptr *bucketeh; // [esp+10h] [ebp-20h]
  uintptr *bucketei; // [esp+10h] [ebp-20h]
  uintptr *bucketej; // [esp+10h] [ebp-20h]
  uintptr *bucketek; // [esp+10h] [ebp-20h]
  uintptr *bucketel; // [esp+10h] [ebp-20h]
  uintptr *bucketem; // [esp+10h] [ebp-20h]
  uintptr *bucketen; // [esp+10h] [ebp-20h]
  uintptr *bucketeo; // [esp+10h] [ebp-20h]
  uintptr *bucketep; // [esp+10h] [ebp-20h]
  uintptr *bucketeq; // [esp+10h] [ebp-20h]
  uintptr *bucketer; // [esp+10h] [ebp-20h]
  uintptr *bucketes; // [esp+10h] [ebp-20h]
  uintptr *bucketet; // [esp+10h] [ebp-20h]
  uintptr *bucketeu; // [esp+10h] [ebp-20h]
  uintptr *bucketev; // [esp+10h] [ebp-20h]
  uintptr *bucketew; // [esp+10h] [ebp-20h]
  uintptr *bucketex; // [esp+10h] [ebp-20h]
  uintptr *bucketey; // [esp+10h] [ebp-20h]
  uintptr *bucketez; // [esp+10h] [ebp-20h]
  uintptr *bucketfa; // [esp+10h] [ebp-20h]
  uintptr *bucketfb; // [esp+10h] [ebp-20h]
  uintptr *bucketfc; // [esp+10h] [ebp-20h]
  uintptr *bucketfd; // [esp+10h] [ebp-20h]
  uintptr *bucketfe; // [esp+10h] [ebp-20h]
  uintptr *bucketff; // [esp+10h] [ebp-20h]
  uintptr *bucketfg; // [esp+10h] [ebp-20h]
  uintptr *bucketfh; // [esp+10h] [ebp-20h]
  uintptr *bucketfi; // [esp+10h] [ebp-20h]
  uintptr *bucketfj; // [esp+10h] [ebp-20h]
  uintptr *bucketfk; // [esp+10h] [ebp-20h]
  uintptr *bucketfl; // [esp+10h] [ebp-20h]
  uintptr *bucketfm; // [esp+10h] [ebp-20h]
  uintptr *bucketfn; // [esp+10h] [ebp-20h]
  uintptr *bucketfo; // [esp+10h] [ebp-20h]
  uintptr *bucketfp; // [esp+10h] [ebp-20h]
  uintptr *bucketfq; // [esp+10h] [ebp-20h]
  uintptr *bucketfr; // [esp+10h] [ebp-20h]
  uintptr *bucketfs; // [esp+10h] [ebp-20h]
  uintptr *bucketft; // [esp+10h] [ebp-20h]
  uintptr *bucketfu; // [esp+10h] [ebp-20h]
  uintptr *bucketfv; // [esp+10h] [ebp-20h]
  uintptr *bucketfw; // [esp+10h] [ebp-20h]
  uintptr *bucketfx; // [esp+10h] [ebp-20h]
  uintptr *bucketfy; // [esp+10h] [ebp-20h]
  uintptr *bucketfz; // [esp+10h] [ebp-20h]
  uintptr *bucketga; // [esp+10h] [ebp-20h]
  uintptr *bucketgb; // [esp+10h] [ebp-20h]
  uintptr *bucketgc; // [esp+10h] [ebp-20h]
  uintptr *bucketgd; // [esp+10h] [ebp-20h]
  uintptr *bucketge; // [esp+10h] [ebp-20h]
  uintptr *bucketgf; // [esp+10h] [ebp-20h]
  uintptr *bucketgg; // [esp+10h] [ebp-20h]
  uintptr *bucketgh; // [esp+10h] [ebp-20h]
  uintptr *bucketgi; // [esp+10h] [ebp-20h]
  uintptr *bucketgj; // [esp+10h] [ebp-20h]
  uintptr *bucketgk; // [esp+10h] [ebp-20h]
  uintptr *bucketgl; // [esp+10h] [ebp-20h]
  uintptr *bucketgm; // [esp+10h] [ebp-20h]
  uintptr *bucketgn; // [esp+10h] [ebp-20h]
  uintptr *bucketgo; // [esp+10h] [ebp-20h]
  uintptr *bucketgp; // [esp+10h] [ebp-20h]
  uintptr *bucketgq; // [esp+10h] [ebp-20h]
  uintptr *bucketgr; // [esp+10h] [ebp-20h]
  uintptr *bucketgs; // [esp+10h] [ebp-20h]
  uintptr *bucketgt; // [esp+10h] [ebp-20h]
  uintptr *bucketgu; // [esp+10h] [ebp-20h]
  uintptr *bucketgv; // [esp+10h] [ebp-20h]
  uintptr *bucketgw; // [esp+10h] [ebp-20h]
  uintptr *bucketgx; // [esp+10h] [ebp-20h]
  uintptr *bucketgy; // [esp+10h] [ebp-20h]
  uintptr *bucketgz; // [esp+10h] [ebp-20h]
  uintptr *bucketha; // [esp+10h] [ebp-20h]
  uintptr *buckethb; // [esp+10h] [ebp-20h]
  uintptr *buckethc; // [esp+10h] [ebp-20h]
  uintptr *buckethd; // [esp+10h] [ebp-20h]
  uintptr *buckethe; // [esp+10h] [ebp-20h]
  uintptr *buckethf; // [esp+10h] [ebp-20h]
  uintptr *buckethg; // [esp+10h] [ebp-20h]
  uintptr *buckethh; // [esp+10h] [ebp-20h]
  uintptr *buckethi; // [esp+10h] [ebp-20h]
  uintptr *buckethj; // [esp+10h] [ebp-20h]
  uintptr *buckethk; // [esp+10h] [ebp-20h]
  uintptr *buckethl; // [esp+10h] [ebp-20h]
  uintptr *buckethm; // [esp+10h] [ebp-20h]
  uintptr *buckethn; // [esp+10h] [ebp-20h]
  uintptr *bucketho; // [esp+10h] [ebp-20h]
  uintptr *buckethp; // [esp+10h] [ebp-20h]
  uintptr *buckethq; // [esp+10h] [ebp-20h]
  uintptr *buckethr; // [esp+10h] [ebp-20h]
  uintptr *buckeths; // [esp+10h] [ebp-20h]
  uintptr *bucketht; // [esp+10h] [ebp-20h]
  uintptr *buckethu; // [esp+10h] [ebp-20h]
  uintptr *buckethv; // [esp+10h] [ebp-20h]
  uintptr *buckethw; // [esp+10h] [ebp-20h]
  uintptr *buckethx; // [esp+10h] [ebp-20h]
  uintptr *buckethy; // [esp+10h] [ebp-20h]
  uintptr *buckethz; // [esp+10h] [ebp-20h]
  uintptr *bucketia; // [esp+10h] [ebp-20h]
  uintptr *bucketib; // [esp+10h] [ebp-20h]
  uintptr *bucketic; // [esp+10h] [ebp-20h]
  uintptr *bucketid; // [esp+10h] [ebp-20h]
  uintptr *bucketie; // [esp+10h] [ebp-20h]
  uintptr *bucketif; // [esp+10h] [ebp-20h]
  uintptr *bucketig; // [esp+10h] [ebp-20h]
  runtime_hmap *v432; // [esp+18h] [ebp-18h]
  runtime_hmap *v433; // [esp+1Ch] [ebp-14h]
  runtime_hmap *v434; // [esp+20h] [ebp-10h]
  runtime_hmap *v435; // [esp+24h] [ebp-Ch]
  unicode_RangeTable *src; // [esp+28h] [ebp-8h]
  unicode_RangeTable *srca; // [esp+28h] [ebp-8h]
  unicode_RangeTable *srcb; // [esp+28h] [ebp-8h]
  unicode_RangeTable *srcc; // [esp+28h] [ebp-8h]
  unicode_RangeTable *srcd; // [esp+28h] [ebp-8h]
  unicode_RangeTable *srce; // [esp+28h] [ebp-8h]
  unicode_RangeTable *srcf; // [esp+28h] [ebp-8h]
  unicode_RangeTable *srcg; // [esp+28h] [ebp-8h]
  unicode_RangeTable *srch; // [esp+28h] [ebp-8h]
  unicode_RangeTable *srci; // [esp+28h] [ebp-8h]
  unicode_RangeTable *srcj; // [esp+28h] [ebp-8h]
  unicode_RangeTable *srck; // [esp+28h] [ebp-8h]
  unicode_RangeTable *srcl; // [esp+28h] [ebp-8h]
  unicode_RangeTable *srcm; // [esp+28h] [ebp-8h]
  unicode_RangeTable *srcn; // [esp+28h] [ebp-8h]
  unicode_RangeTable *srco; // [esp+28h] [ebp-8h]
  unicode_RangeTable *srcp; // [esp+28h] [ebp-8h]
  unicode_RangeTable *srcq; // [esp+28h] [ebp-8h]
  unicode_RangeTable *srcr; // [esp+28h] [ebp-8h]
  unicode_RangeTable *srcs; // [esp+28h] [ebp-8h]
  unicode_RangeTable *srct; // [esp+28h] [ebp-8h]
  unicode_RangeTable *srcu; // [esp+28h] [ebp-8h]
  unicode_RangeTable *srcv; // [esp+28h] [ebp-8h]
  unicode_RangeTable *srcw; // [esp+28h] [ebp-8h]
  unicode_RangeTable *srcx; // [esp+28h] [ebp-8h]
  unicode_RangeTable *srcy; // [esp+28h] [ebp-8h]
  unicode_RangeTable *srcz; // [esp+28h] [ebp-8h]
  unicode_RangeTable *srcba; // [esp+28h] [ebp-8h]
  unicode_RangeTable *srcbb; // [esp+28h] [ebp-8h]
  unicode_RangeTable *srcbc; // [esp+28h] [ebp-8h]
  unicode_RangeTable *srcbd; // [esp+28h] [ebp-8h]
  unicode_RangeTable *srcbe; // [esp+28h] [ebp-8h]
  unicode_RangeTable *srcbf; // [esp+28h] [ebp-8h]
  unicode_RangeTable *srcbg; // [esp+28h] [ebp-8h]
  unicode_RangeTable *srcbh; // [esp+28h] [ebp-8h]
  unicode_RangeTable *srcbi; // [esp+28h] [ebp-8h]
  unicode_RangeTable *srcbj; // [esp+28h] [ebp-8h]
  unicode_RangeTable *srcbk; // [esp+28h] [ebp-8h]
  unicode_RangeTable *srcbl; // [esp+28h] [ebp-8h]
  unicode_RangeTable *srcbm; // [esp+28h] [ebp-8h]
  unicode_RangeTable *srcbn; // [esp+28h] [ebp-8h]
  unicode_RangeTable *srcbo; // [esp+28h] [ebp-8h]
  unicode_RangeTable *srcbp; // [esp+28h] [ebp-8h]
  unicode_RangeTable *srcbq; // [esp+28h] [ebp-8h]
  unicode_RangeTable *srcbr; // [esp+28h] [ebp-8h]
  unicode_RangeTable *srcbs; // [esp+28h] [ebp-8h]
  unicode_RangeTable *srcbt; // [esp+28h] [ebp-8h]
  unicode_RangeTable *srcbu; // [esp+28h] [ebp-8h]
  unicode_RangeTable *srcbv; // [esp+28h] [ebp-8h]
  unicode_RangeTable *srcbw; // [esp+28h] [ebp-8h]
  unicode_RangeTable *srcbx; // [esp+28h] [ebp-8h]
  unicode_RangeTable *srcby; // [esp+28h] [ebp-8h]
  unicode_RangeTable *srcbz; // [esp+28h] [ebp-8h]
  unicode_RangeTable *srcca; // [esp+28h] [ebp-8h]
  unicode_RangeTable *srccb; // [esp+28h] [ebp-8h]
  unicode_RangeTable *srccc; // [esp+28h] [ebp-8h]
  unicode_RangeTable *srccd; // [esp+28h] [ebp-8h]
  unicode_RangeTable *srcce; // [esp+28h] [ebp-8h]
  unicode_RangeTable *srccf; // [esp+28h] [ebp-8h]
  unicode_RangeTable *srccg; // [esp+28h] [ebp-8h]
  unicode_RangeTable *srcch; // [esp+28h] [ebp-8h]
  unicode_RangeTable *srcci; // [esp+28h] [ebp-8h]
  unicode_RangeTable *srccj; // [esp+28h] [ebp-8h]
  unicode_RangeTable *srcck; // [esp+28h] [ebp-8h]
  unicode_RangeTable *srccl; // [esp+28h] [ebp-8h]
  unicode_RangeTable *srccm; // [esp+28h] [ebp-8h]
  unicode_RangeTable *srccn; // [esp+28h] [ebp-8h]
  unicode_RangeTable *srcco; // [esp+28h] [ebp-8h]
  unicode_RangeTable *srccp; // [esp+28h] [ebp-8h]
  unicode_RangeTable *srccq; // [esp+28h] [ebp-8h]
  unicode_RangeTable *srccr; // [esp+28h] [ebp-8h]
  unicode_RangeTable *srccs; // [esp+28h] [ebp-8h]
  unicode_RangeTable *srcct; // [esp+28h] [ebp-8h]
  unicode_RangeTable *srccu; // [esp+28h] [ebp-8h]
  unicode_RangeTable *srccv; // [esp+28h] [ebp-8h]
  unicode_RangeTable *srccw; // [esp+28h] [ebp-8h]
  unicode_RangeTable *srccx; // [esp+28h] [ebp-8h]
  unicode_RangeTable *srccy; // [esp+28h] [ebp-8h]
  unicode_RangeTable *srccz; // [esp+28h] [ebp-8h]
  unicode_RangeTable *srcda; // [esp+28h] [ebp-8h]
  unicode_RangeTable *srcdb; // [esp+28h] [ebp-8h]
  unicode_RangeTable *srcdc; // [esp+28h] [ebp-8h]
  unicode_RangeTable *srcdd; // [esp+28h] [ebp-8h]
  unicode_RangeTable *srcde; // [esp+28h] [ebp-8h]
  unicode_RangeTable *srcdf; // [esp+28h] [ebp-8h]
  unicode_RangeTable *srcdg; // [esp+28h] [ebp-8h]
  unicode_RangeTable *srcdh; // [esp+28h] [ebp-8h]
  unicode_RangeTable *srcdi; // [esp+28h] [ebp-8h]
  unicode_RangeTable *srcdj; // [esp+28h] [ebp-8h]
  unicode_RangeTable *srcdk; // [esp+28h] [ebp-8h]
  unicode_RangeTable *srcdl; // [esp+28h] [ebp-8h]
  unicode_RangeTable *srcdm; // [esp+28h] [ebp-8h]
  unicode_RangeTable *srcdn; // [esp+28h] [ebp-8h]
  unicode_RangeTable *srcdo; // [esp+28h] [ebp-8h]
  unicode_RangeTable *srcdp; // [esp+28h] [ebp-8h]
  unicode_RangeTable *srcdq; // [esp+28h] [ebp-8h]
  unicode_RangeTable *srcdr; // [esp+28h] [ebp-8h]
  unicode_RangeTable *srcds; // [esp+28h] [ebp-8h]
  unicode_RangeTable *srcdt; // [esp+28h] [ebp-8h]
  unicode_RangeTable *srcdu; // [esp+28h] [ebp-8h]
  unicode_RangeTable *srcdv; // [esp+28h] [ebp-8h]
  unicode_RangeTable *srcdw; // [esp+28h] [ebp-8h]
  unicode_RangeTable *srcdx; // [esp+28h] [ebp-8h]
  unicode_RangeTable *srcdy; // [esp+28h] [ebp-8h]
  unicode_RangeTable *srcdz; // [esp+28h] [ebp-8h]
  unicode_RangeTable *srcea; // [esp+28h] [ebp-8h]
  unicode_RangeTable *srceb; // [esp+28h] [ebp-8h]
  unicode_RangeTable *srcec; // [esp+28h] [ebp-8h]
  unicode_RangeTable *srced; // [esp+28h] [ebp-8h]
  unicode_RangeTable *srcee; // [esp+28h] [ebp-8h]
  unicode_RangeTable *srcef; // [esp+28h] [ebp-8h]
  unicode_RangeTable *srceg; // [esp+28h] [ebp-8h]
  unicode_RangeTable *srceh; // [esp+28h] [ebp-8h]
  unicode_RangeTable *srcei; // [esp+28h] [ebp-8h]
  unicode_RangeTable *srcej; // [esp+28h] [ebp-8h]
  unicode_RangeTable *srcek; // [esp+28h] [ebp-8h]
  unicode_RangeTable *srcel; // [esp+28h] [ebp-8h]
  unicode_RangeTable *srcem; // [esp+28h] [ebp-8h]
  unicode_RangeTable *srcen; // [esp+28h] [ebp-8h]
  unicode_RangeTable *srceo; // [esp+28h] [ebp-8h]
  unicode_RangeTable *srcep; // [esp+28h] [ebp-8h]
  unicode_RangeTable *srceq; // [esp+28h] [ebp-8h]
  unicode_RangeTable *srcer; // [esp+28h] [ebp-8h]
  unicode_RangeTable *srces; // [esp+28h] [ebp-8h]
  unicode_RangeTable *srcet; // [esp+28h] [ebp-8h]
  unicode_RangeTable *srceu; // [esp+28h] [ebp-8h]
  unicode_RangeTable *srcev; // [esp+28h] [ebp-8h]
  unicode_RangeTable *srcew; // [esp+28h] [ebp-8h]
  unicode_RangeTable *srcex; // [esp+28h] [ebp-8h]
  unicode_RangeTable *srcey; // [esp+28h] [ebp-8h]
  unicode_RangeTable *srcez; // [esp+28h] [ebp-8h]
  unicode_RangeTable *srcfa; // [esp+28h] [ebp-8h]
  unicode_RangeTable *srcfb; // [esp+28h] [ebp-8h]
  unicode_RangeTable *srcfc; // [esp+28h] [ebp-8h]
  unicode_RangeTable *srcfd; // [esp+28h] [ebp-8h]
  unicode_RangeTable *srcfe; // [esp+28h] [ebp-8h]
  unicode_RangeTable *srcff; // [esp+28h] [ebp-8h]
  unicode_RangeTable *srcfg; // [esp+28h] [ebp-8h]
  unicode_RangeTable *srcfh; // [esp+28h] [ebp-8h]
  unicode_RangeTable *srcfi; // [esp+28h] [ebp-8h]
  unicode_RangeTable *srcfj; // [esp+28h] [ebp-8h]
  unicode_RangeTable *srcfk; // [esp+28h] [ebp-8h]
  unicode_RangeTable *srcfl; // [esp+28h] [ebp-8h]
  unicode_RangeTable *srcfm; // [esp+28h] [ebp-8h]
  unicode_RangeTable *srcfn; // [esp+28h] [ebp-8h]
  unicode_RangeTable *srcfo; // [esp+28h] [ebp-8h]
  unicode_RangeTable *srcfp; // [esp+28h] [ebp-8h]
  unicode_RangeTable *srcfq; // [esp+28h] [ebp-8h]
  unicode_RangeTable *srcfr; // [esp+28h] [ebp-8h]
  unicode_RangeTable *srcfs; // [esp+28h] [ebp-8h]
  unicode_RangeTable *srcft; // [esp+28h] [ebp-8h]
  unicode_RangeTable *srcfu; // [esp+28h] [ebp-8h]
  unicode_RangeTable *srcfv; // [esp+28h] [ebp-8h]
  unicode_RangeTable *srcfw; // [esp+28h] [ebp-8h]
  unicode_RangeTable *srcfx; // [esp+28h] [ebp-8h]
  unicode_RangeTable *srcfy; // [esp+28h] [ebp-8h]
  unicode_RangeTable *srcfz; // [esp+28h] [ebp-8h]
  unicode_RangeTable *srcga; // [esp+28h] [ebp-8h]
  unicode_RangeTable *srcgb; // [esp+28h] [ebp-8h]
  unicode_RangeTable *srcgc; // [esp+28h] [ebp-8h]
  unicode_RangeTable *srcgd; // [esp+28h] [ebp-8h]
  unicode_RangeTable *srcge; // [esp+28h] [ebp-8h]
  unicode_RangeTable *srcgf; // [esp+28h] [ebp-8h]
  unicode_RangeTable *srcgg; // [esp+28h] [ebp-8h]
  unicode_RangeTable *srcgh; // [esp+28h] [ebp-8h]
  unicode_RangeTable *srcgi; // [esp+28h] [ebp-8h]
  unicode_RangeTable *srcgj; // [esp+28h] [ebp-8h]
  unicode_RangeTable *srcgk; // [esp+28h] [ebp-8h]
  unicode_RangeTable *srcgl; // [esp+28h] [ebp-8h]
  unicode_RangeTable *srcgm; // [esp+28h] [ebp-8h]
  unicode_RangeTable *srcgn; // [esp+28h] [ebp-8h]
  unicode_RangeTable *srcgo; // [esp+28h] [ebp-8h]
  unicode_RangeTable *srcgp; // [esp+28h] [ebp-8h]
  unicode_RangeTable *srcgq; // [esp+28h] [ebp-8h]
  unicode_RangeTable *srcgr; // [esp+28h] [ebp-8h]
  unicode_RangeTable *srcgs; // [esp+28h] [ebp-8h]
  unicode_RangeTable *srcgt; // [esp+28h] [ebp-8h]
  unicode_RangeTable *srcgu; // [esp+28h] [ebp-8h]
  unicode_RangeTable *srcgv; // [esp+28h] [ebp-8h]
  unicode_RangeTable *srcgw; // [esp+28h] [ebp-8h]
  unicode_RangeTable *srcgx; // [esp+28h] [ebp-8h]
  unicode_RangeTable *srcgy; // [esp+28h] [ebp-8h]
  unicode_RangeTable *srcgz; // [esp+28h] [ebp-8h]
  unicode_RangeTable *srcha; // [esp+28h] [ebp-8h]
  unicode_RangeTable *srchb; // [esp+28h] [ebp-8h]
  unicode_RangeTable *srchc; // [esp+28h] [ebp-8h]
  unicode_RangeTable *srchd; // [esp+28h] [ebp-8h]
  unicode_RangeTable *srche; // [esp+28h] [ebp-8h]
  unicode_RangeTable *srchf; // [esp+28h] [ebp-8h]
  unicode_RangeTable *srchg; // [esp+28h] [ebp-8h]
  unicode_RangeTable *srchh; // [esp+28h] [ebp-8h]
  unicode_RangeTable *srchi; // [esp+28h] [ebp-8h]
  unicode_RangeTable *srchj; // [esp+28h] [ebp-8h]
  unicode_RangeTable *srchk; // [esp+28h] [ebp-8h]
  unicode_RangeTable *srchl; // [esp+28h] [ebp-8h]
  unicode_RangeTable *srchm; // [esp+28h] [ebp-8h]
  unicode_RangeTable *srchn; // [esp+28h] [ebp-8h]
  unicode_RangeTable *srcho; // [esp+28h] [ebp-8h]
  unicode_RangeTable *srchp; // [esp+28h] [ebp-8h]
  unicode_RangeTable *srchq; // [esp+28h] [ebp-8h]
  unicode_RangeTable *srchr; // [esp+28h] [ebp-8h]
  unicode_RangeTable *srchs; // [esp+28h] [ebp-8h]
  unicode_RangeTable *srcht; // [esp+28h] [ebp-8h]
  unicode_RangeTable *srchu; // [esp+28h] [ebp-8h]
  unicode_RangeTable *srchv; // [esp+28h] [ebp-8h]
  unicode_RangeTable *srchw; // [esp+28h] [ebp-8h]
  unicode_RangeTable *srchx; // [esp+28h] [ebp-8h]
  unicode_RangeTable *srchy; // [esp+28h] [ebp-8h]
  unicode_RangeTable *srchz; // [esp+28h] [ebp-8h]
  unicode_RangeTable *srcia; // [esp+28h] [ebp-8h]
  unicode_RangeTable *srcib; // [esp+28h] [ebp-8h]
  unicode_RangeTable *srcic; // [esp+28h] [ebp-8h]
  unicode_RangeTable *srcid; // [esp+28h] [ebp-8h]
  unicode_RangeTable *srcie; // [esp+28h] [ebp-8h]
  unicode_RangeTable *srcif; // [esp+28h] [ebp-8h]
  unicode_RangeTable *srcig; // [esp+28h] [ebp-8h]
  runtime_hmap *v652; // [esp+2Ch] [ebp-4h]

  if ( unicode_initdone_ <= 1u )
  {
    if ( unicode_initdone_ == 1 )
      runtime_throwinit();
    unicode_initdone_ = 1;
    v652 = runtime_makemap((runtime_maptype_0 *)&stru_80CFB40, 36LL, 0, 0);
    src = unicode_C;
    hint_4.str = (uint8 *)"C";
    hint_4.len = 1;
    bucket = (uintptr *)runtime_mapassign_faststr((runtime_maptype_0 *)&stru_80CFB40, v652, hint_4);
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr(bucket, (uintptr)src);
    else
      *bucket = (uintptr)src;
    srca = unicode_Cc;
    hint_4a.str = (uint8 *)"Cc";
    hint_4a.len = 2;
    bucketa = (uintptr *)runtime_mapassign_faststr((runtime_maptype_0 *)&stru_80CFB40, v652, hint_4a);
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr(bucketa, (uintptr)srca);
    else
      *bucketa = (uintptr)srca;
    srcb = unicode_Cf;
    hint_4b.str = (uint8 *)"Cf";
    hint_4b.len = 2;
    bucketb = (uintptr *)runtime_mapassign_faststr((runtime_maptype_0 *)&stru_80CFB40, v652, hint_4b);
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr(bucketb, (uintptr)srcb);
    else
      *bucketb = (uintptr)srcb;
    srcc = unicode_Co;
    hint_4c.str = (uint8 *)"Co";
    hint_4c.len = 2;
    bucketc = (uintptr *)runtime_mapassign_faststr((runtime_maptype_0 *)&stru_80CFB40, v652, hint_4c);
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr(bucketc, (uintptr)srcc);
    else
      *bucketc = (uintptr)srcc;
    srcd = unicode_Cs;
    hint_4d.str = (uint8 *)"Cs";
    hint_4d.len = 2;
    bucketd = (uintptr *)runtime_mapassign_faststr((runtime_maptype_0 *)&stru_80CFB40, v652, hint_4d);
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr(bucketd, (uintptr)srcd);
    else
      *bucketd = (uintptr)srcd;
    srce = unicode_L;
    hint_4e.str = (uint8 *)"L";
    hint_4e.len = 1;
    buckete = (uintptr *)runtime_mapassign_faststr((runtime_maptype_0 *)&stru_80CFB40, v652, hint_4e);
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr(buckete, (uintptr)srce);
    else
      *buckete = (uintptr)srce;
    srcf = unicode_Ll;
    hint_4f.str = (uint8 *)"Ll";
    hint_4f.len = 2;
    bucketf = (uintptr *)runtime_mapassign_faststr((runtime_maptype_0 *)&stru_80CFB40, v652, hint_4f);
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr(bucketf, (uintptr)srcf);
    else
      *bucketf = (uintptr)srcf;
    srcg = unicode_Lm;
    hint_4g.str = (uint8 *)"Lm";
    hint_4g.len = 2;
    bucketg = (uintptr *)runtime_mapassign_faststr((runtime_maptype_0 *)&stru_80CFB40, v652, hint_4g);
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr(bucketg, (uintptr)srcg);
    else
      *bucketg = (uintptr)srcg;
    srch = unicode_Lo;
    hint_4h.str = (uint8 *)"Lo";
    hint_4h.len = 2;
    bucketh = (uintptr *)runtime_mapassign_faststr((runtime_maptype_0 *)&stru_80CFB40, v652, hint_4h);
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr(bucketh, (uintptr)srch);
    else
      *bucketh = (uintptr)srch;
    srci = unicode_Lt;
    hint_4i.str = (uint8 *)"Lt";
    hint_4i.len = 2;
    bucketi = (uintptr *)runtime_mapassign_faststr((runtime_maptype_0 *)&stru_80CFB40, v652, hint_4i);
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr(bucketi, (uintptr)srci);
    else
      *bucketi = (uintptr)srci;
    srcj = unicode_Lu;
    hint_4j.str = (uint8 *)"Lu";
    hint_4j.len = 2;
    bucketj = (uintptr *)runtime_mapassign_faststr((runtime_maptype_0 *)&stru_80CFB40, v652, hint_4j);
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr(bucketj, (uintptr)srcj);
    else
      *bucketj = (uintptr)srcj;
    srck = unicode_M;
    hint_4k.str = (uint8 *)"M";
    hint_4k.len = 1;
    bucketk = (uintptr *)runtime_mapassign_faststr((runtime_maptype_0 *)&stru_80CFB40, v652, hint_4k);
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr(bucketk, (uintptr)srck);
    else
      *bucketk = (uintptr)srck;
    srcl = unicode_Mc;
    hint_4l.str = (uint8 *)"Mc";
    hint_4l.len = 2;
    bucketl = (uintptr *)runtime_mapassign_faststr((runtime_maptype_0 *)&stru_80CFB40, v652, hint_4l);
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr(bucketl, (uintptr)srcl);
    else
      *bucketl = (uintptr)srcl;
    srcm = unicode_Me;
    hint_4m.str = (uint8 *)"Me";
    hint_4m.len = 2;
    bucketm = (uintptr *)runtime_mapassign_faststr((runtime_maptype_0 *)&stru_80CFB40, v652, hint_4m);
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr(bucketm, (uintptr)srcm);
    else
      *bucketm = (uintptr)srcm;
    srcn = unicode_Mn;
    hint_4n.str = (uint8 *)"Mn";
    hint_4n.len = 2;
    bucketn = (uintptr *)runtime_mapassign_faststr((runtime_maptype_0 *)&stru_80CFB40, v652, hint_4n);
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr(bucketn, (uintptr)srcn);
    else
      *bucketn = (uintptr)srcn;
    srco = unicode_N;
    hint_4o.str = (uint8 *)"N";
    hint_4o.len = 1;
    bucketo = (uintptr *)runtime_mapassign_faststr((runtime_maptype_0 *)&stru_80CFB40, v652, hint_4o);
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr(bucketo, (uintptr)srco);
    else
      *bucketo = (uintptr)srco;
    srcp = unicode_Nd;
    hint_4p.str = (uint8 *)"Nd";
    hint_4p.len = 2;
    bucketp = (uintptr *)runtime_mapassign_faststr((runtime_maptype_0 *)&stru_80CFB40, v652, hint_4p);
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr(bucketp, (uintptr)srcp);
    else
      *bucketp = (uintptr)srcp;
    srcq = unicode_Nl;
    hint_4q.str = (uint8 *)"Nl";
    hint_4q.len = 2;
    bucketq = (uintptr *)runtime_mapassign_faststr((runtime_maptype_0 *)&stru_80CFB40, v652, hint_4q);
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr(bucketq, (uintptr)srcq);
    else
      *bucketq = (uintptr)srcq;
    srcr = unicode_No;
    hint_4r.str = (uint8 *)"No";
    hint_4r.len = 2;
    bucketr = (uintptr *)runtime_mapassign_faststr((runtime_maptype_0 *)&stru_80CFB40, v652, hint_4r);
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr(bucketr, (uintptr)srcr);
    else
      *bucketr = (uintptr)srcr;
    srcs = unicode_P;
    hint_4s.str = (uint8 *)"P";
    hint_4s.len = 1;
    buckets = (uintptr *)runtime_mapassign_faststr((runtime_maptype_0 *)&stru_80CFB40, v652, hint_4s);
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr(buckets, (uintptr)srcs);
    else
      *buckets = (uintptr)srcs;
    srct = unicode_Pc;
    hint_4t.str = (uint8 *)"Pc";
    hint_4t.len = 2;
    buckett = (uintptr *)runtime_mapassign_faststr((runtime_maptype_0 *)&stru_80CFB40, v652, hint_4t);
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr(buckett, (uintptr)srct);
    else
      *buckett = (uintptr)srct;
    srcu = unicode_Pd;
    hint_4u.str = (uint8 *)"Pd";
    hint_4u.len = 2;
    bucketu = (uintptr *)runtime_mapassign_faststr((runtime_maptype_0 *)&stru_80CFB40, v652, hint_4u);
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr(bucketu, (uintptr)srcu);
    else
      *bucketu = (uintptr)srcu;
    srcv = unicode_Pe;
    hint_4v.str = (uint8 *)"Pe";
    hint_4v.len = 2;
    bucketv = (uintptr *)runtime_mapassign_faststr((runtime_maptype_0 *)&stru_80CFB40, v652, hint_4v);
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr(bucketv, (uintptr)srcv);
    else
      *bucketv = (uintptr)srcv;
    srcw = unicode_Pf;
    hint_4w.str = (uint8 *)"Pf";
    hint_4w.len = 2;
    bucketw = (uintptr *)runtime_mapassign_faststr((runtime_maptype_0 *)&stru_80CFB40, v652, hint_4w);
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr(bucketw, (uintptr)srcw);
    else
      *bucketw = (uintptr)srcw;
    srcx = unicode_Pi;
    hint_4x.str = (uint8 *)"Pi";
    hint_4x.len = 2;
    bucketx = (uintptr *)runtime_mapassign_faststr((runtime_maptype_0 *)&stru_80CFB40, v652, hint_4x);
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr(bucketx, (uintptr)srcx);
    else
      *bucketx = (uintptr)srcx;
    srcy = unicode_Po;
    hint_4y.str = (uint8 *)"Po";
    hint_4y.len = 2;
    buckety = (uintptr *)runtime_mapassign_faststr((runtime_maptype_0 *)&stru_80CFB40, v652, hint_4y);
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr(buckety, (uintptr)srcy);
    else
      *buckety = (uintptr)srcy;
    srcz = unicode_Ps;
    hint_4z.str = (uint8 *)"Ps";
    hint_4z.len = 2;
    bucketz = (uintptr *)runtime_mapassign_faststr((runtime_maptype_0 *)&stru_80CFB40, v652, hint_4z);
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr(bucketz, (uintptr)srcz);
    else
      *bucketz = (uintptr)srcz;
    srcba = unicode_S;
    hint_4ba.str = (uint8 *)"S";
    hint_4ba.len = 1;
    bucketba = (uintptr *)runtime_mapassign_faststr((runtime_maptype_0 *)&stru_80CFB40, v652, hint_4ba);
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr(bucketba, (uintptr)srcba);
    else
      *bucketba = (uintptr)srcba;
    srcbb = unicode_Sc;
    hint_4bb.str = (uint8 *)"Sc";
    hint_4bb.len = 2;
    bucketbb = (uintptr *)runtime_mapassign_faststr((runtime_maptype_0 *)&stru_80CFB40, v652, hint_4bb);
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr(bucketbb, (uintptr)srcbb);
    else
      *bucketbb = (uintptr)srcbb;
    srcbc = unicode_Sk;
    hint_4bc.str = (uint8 *)"Sk";
    hint_4bc.len = 2;
    bucketbc = (uintptr *)runtime_mapassign_faststr((runtime_maptype_0 *)&stru_80CFB40, v652, hint_4bc);
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr(bucketbc, (uintptr)srcbc);
    else
      *bucketbc = (uintptr)srcbc;
    srcbd = unicode_Sm;
    hint_4bd.str = (uint8 *)"Sm";
    hint_4bd.len = 2;
    bucketbd = (uintptr *)runtime_mapassign_faststr((runtime_maptype_0 *)&stru_80CFB40, v652, hint_4bd);
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr(bucketbd, (uintptr)srcbd);
    else
      *bucketbd = (uintptr)srcbd;
    srcbe = unicode_So;
    hint_4be.str = (uint8 *)"So";
    hint_4be.len = 2;
    bucketbe = (uintptr *)runtime_mapassign_faststr((runtime_maptype_0 *)&stru_80CFB40, v652, hint_4be);
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr(bucketbe, (uintptr)srcbe);
    else
      *bucketbe = (uintptr)srcbe;
    srcbf = unicode_Z;
    hint_4bf.str = (uint8 *)"Z";
    hint_4bf.len = 1;
    bucketbf = (uintptr *)runtime_mapassign_faststr((runtime_maptype_0 *)&stru_80CFB40, v652, hint_4bf);
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr(bucketbf, (uintptr)srcbf);
    else
      *bucketbf = (uintptr)srcbf;
    srcbg = unicode_Zl;
    hint_4bg.str = (uint8 *)"Zl";
    hint_4bg.len = 2;
    bucketbg = (uintptr *)runtime_mapassign_faststr((runtime_maptype_0 *)&stru_80CFB40, v652, hint_4bg);
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr(bucketbg, (uintptr)srcbg);
    else
      *bucketbg = (uintptr)srcbg;
    srcbh = unicode_Zp;
    hint_4bh.str = (uint8 *)"Zp";
    hint_4bh.len = 2;
    bucketbh = (uintptr *)runtime_mapassign_faststr((runtime_maptype_0 *)&stru_80CFB40, v652, hint_4bh);
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr(bucketbh, (uintptr)srcbh);
    else
      *bucketbh = (uintptr)srcbh;
    srcbi = unicode_Zs;
    hint_4bi.str = (uint8 *)"Zs";
    hint_4bi.len = 2;
    bucketbi = (uintptr *)runtime_mapassign_faststr((runtime_maptype_0 *)&stru_80CFB40, v652, hint_4bi);
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
    {
      runtime_writebarrierptr(bucketbi, (uintptr)srcbi);
      runtime_writebarrierptr((uintptr *)&unicode_Categories, (uintptr)v652);
    }
    else
    {
      *bucketbi = (uintptr)srcbi;
      unicode_Categories = (map_string__unicode_RangeTable)v652;
    }
    v435 = runtime_makemap((runtime_maptype_0 *)&stru_80CFB40, 137LL, 0, 0);
    srcbj = unicode_Adlam;
    hint_4bj.str = (uint8 *)"Adlam";
    hint_4bj.len = 5;
    bucketbj = (uintptr *)runtime_mapassign_faststr((runtime_maptype_0 *)&stru_80CFB40, v435, hint_4bj);
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr(bucketbj, (uintptr)srcbj);
    else
      *bucketbj = (uintptr)srcbj;
    srcbk = unicode_Ahom;
    hint_4bk.str = (uint8 *)"Ahom";
    hint_4bk.len = 4;
    bucketbk = (uintptr *)runtime_mapassign_faststr((runtime_maptype_0 *)&stru_80CFB40, v435, hint_4bk);
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr(bucketbk, (uintptr)srcbk);
    else
      *bucketbk = (uintptr)srcbk;
    srcbl = unicode_Anatolian_Hieroglyphs;
    hint_4bl.str = (uint8 *)"Anatolian_Hieroglyphs";
    hint_4bl.len = 21;
    bucketbl = (uintptr *)runtime_mapassign_faststr((runtime_maptype_0 *)&stru_80CFB40, v435, hint_4bl);
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr(bucketbl, (uintptr)srcbl);
    else
      *bucketbl = (uintptr)srcbl;
    srcbm = unicode_Arabic;
    hint_4bm.str = (uint8 *)"Arabic";
    hint_4bm.len = 6;
    bucketbm = (uintptr *)runtime_mapassign_faststr((runtime_maptype_0 *)&stru_80CFB40, v435, hint_4bm);
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr(bucketbm, (uintptr)srcbm);
    else
      *bucketbm = (uintptr)srcbm;
    srcbn = unicode_Armenian;
    hint_4bn.str = (uint8 *)"Armenian";
    hint_4bn.len = 8;
    bucketbn = (uintptr *)runtime_mapassign_faststr((runtime_maptype_0 *)&stru_80CFB40, v435, hint_4bn);
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr(bucketbn, (uintptr)srcbn);
    else
      *bucketbn = (uintptr)srcbn;
    srcbo = unicode_Avestan;
    hint_4bo.str = (uint8 *)"Avestan";
    hint_4bo.len = 7;
    bucketbo = (uintptr *)runtime_mapassign_faststr((runtime_maptype_0 *)&stru_80CFB40, v435, hint_4bo);
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr(bucketbo, (uintptr)srcbo);
    else
      *bucketbo = (uintptr)srcbo;
    srcbp = unicode_Balinese;
    hint_4bp.str = (uint8 *)"Balinese";
    hint_4bp.len = 8;
    bucketbp = (uintptr *)runtime_mapassign_faststr((runtime_maptype_0 *)&stru_80CFB40, v435, hint_4bp);
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr(bucketbp, (uintptr)srcbp);
    else
      *bucketbp = (uintptr)srcbp;
    srcbq = unicode_Bamum;
    hint_4bq.str = (uint8 *)"Bamum";
    hint_4bq.len = 5;
    bucketbq = (uintptr *)runtime_mapassign_faststr((runtime_maptype_0 *)&stru_80CFB40, v435, hint_4bq);
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr(bucketbq, (uintptr)srcbq);
    else
      *bucketbq = (uintptr)srcbq;
    srcbr = unicode_Bassa_Vah;
    hint_4br.str = (uint8 *)"Bassa_Vah";
    hint_4br.len = 9;
    bucketbr = (uintptr *)runtime_mapassign_faststr((runtime_maptype_0 *)&stru_80CFB40, v435, hint_4br);
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr(bucketbr, (uintptr)srcbr);
    else
      *bucketbr = (uintptr)srcbr;
    srcbs = unicode_Batak;
    hint_4bs.str = (uint8 *)"Batak";
    hint_4bs.len = 5;
    bucketbs = (uintptr *)runtime_mapassign_faststr((runtime_maptype_0 *)&stru_80CFB40, v435, hint_4bs);
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr(bucketbs, (uintptr)srcbs);
    else
      *bucketbs = (uintptr)srcbs;
    srcbt = unicode_Bengali;
    hint_4bt.str = (uint8 *)"Bengali";
    hint_4bt.len = 7;
    bucketbt = (uintptr *)runtime_mapassign_faststr((runtime_maptype_0 *)&stru_80CFB40, v435, hint_4bt);
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr(bucketbt, (uintptr)srcbt);
    else
      *bucketbt = (uintptr)srcbt;
    srcbu = unicode_Bhaiksuki;
    hint_4bu.str = (uint8 *)"Bhaiksuki";
    hint_4bu.len = 9;
    bucketbu = (uintptr *)runtime_mapassign_faststr((runtime_maptype_0 *)&stru_80CFB40, v435, hint_4bu);
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr(bucketbu, (uintptr)srcbu);
    else
      *bucketbu = (uintptr)srcbu;
    srcbv = unicode_Bopomofo;
    hint_4bv.str = (uint8 *)"Bopomofo";
    hint_4bv.len = 8;
    bucketbv = (uintptr *)runtime_mapassign_faststr((runtime_maptype_0 *)&stru_80CFB40, v435, hint_4bv);
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr(bucketbv, (uintptr)srcbv);
    else
      *bucketbv = (uintptr)srcbv;
    srcbw = unicode_Brahmi;
    hint_4bw.str = (uint8 *)"Brahmi";
    hint_4bw.len = 6;
    bucketbw = (uintptr *)runtime_mapassign_faststr((runtime_maptype_0 *)&stru_80CFB40, v435, hint_4bw);
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr(bucketbw, (uintptr)srcbw);
    else
      *bucketbw = (uintptr)srcbw;
    srcbx = unicode_Braille;
    hint_4bx.str = (uint8 *)"Braille";
    hint_4bx.len = 7;
    bucketbx = (uintptr *)runtime_mapassign_faststr((runtime_maptype_0 *)&stru_80CFB40, v435, hint_4bx);
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr(bucketbx, (uintptr)srcbx);
    else
      *bucketbx = (uintptr)srcbx;
    srcby = unicode_Buginese;
    hint_4by.str = (uint8 *)"Buginese";
    hint_4by.len = 8;
    bucketby = (uintptr *)runtime_mapassign_faststr((runtime_maptype_0 *)&stru_80CFB40, v435, hint_4by);
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr(bucketby, (uintptr)srcby);
    else
      *bucketby = (uintptr)srcby;
    srcbz = unicode_Buhid;
    hint_4bz.str = (uint8 *)"Buhid";
    hint_4bz.len = 5;
    bucketbz = (uintptr *)runtime_mapassign_faststr((runtime_maptype_0 *)&stru_80CFB40, v435, hint_4bz);
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr(bucketbz, (uintptr)srcbz);
    else
      *bucketbz = (uintptr)srcbz;
    srcca = unicode_Canadian_Aboriginal;
    hint_4ca.str = (uint8 *)"Canadian_Aboriginal";
    hint_4ca.len = 19;
    bucketca = (uintptr *)runtime_mapassign_faststr((runtime_maptype_0 *)&stru_80CFB40, v435, hint_4ca);
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr(bucketca, (uintptr)srcca);
    else
      *bucketca = (uintptr)srcca;
    srccb = unicode_Carian;
    hint_4cb.str = (uint8 *)"Carian";
    hint_4cb.len = 6;
    bucketcb = (uintptr *)runtime_mapassign_faststr((runtime_maptype_0 *)&stru_80CFB40, v435, hint_4cb);
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr(bucketcb, (uintptr)srccb);
    else
      *bucketcb = (uintptr)srccb;
    srccc = unicode_Caucasian_Albanian;
    hint_4cc.str = (uint8 *)"Caucasian_Albanian";
    hint_4cc.len = 18;
    bucketcc = (uintptr *)runtime_mapassign_faststr((runtime_maptype_0 *)&stru_80CFB40, v435, hint_4cc);
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr(bucketcc, (uintptr)srccc);
    else
      *bucketcc = (uintptr)srccc;
    srccd = unicode_Chakma;
    hint_4cd.str = (uint8 *)"Chakma";
    hint_4cd.len = 6;
    bucketcd = (uintptr *)runtime_mapassign_faststr((runtime_maptype_0 *)&stru_80CFB40, v435, hint_4cd);
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr(bucketcd, (uintptr)srccd);
    else
      *bucketcd = (uintptr)srccd;
    srcce = unicode_Cham;
    hint_4ce.str = (uint8 *)"Cham";
    hint_4ce.len = 4;
    bucketce = (uintptr *)runtime_mapassign_faststr((runtime_maptype_0 *)&stru_80CFB40, v435, hint_4ce);
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr(bucketce, (uintptr)srcce);
    else
      *bucketce = (uintptr)srcce;
    srccf = unicode_Cherokee;
    hint_4cf.str = (uint8 *)"Cherokee";
    hint_4cf.len = 8;
    bucketcf = (uintptr *)runtime_mapassign_faststr((runtime_maptype_0 *)&stru_80CFB40, v435, hint_4cf);
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr(bucketcf, (uintptr)srccf);
    else
      *bucketcf = (uintptr)srccf;
    srccg = unicode_Common;
    hint_4cg.str = (uint8 *)"Common";
    hint_4cg.len = 6;
    bucketcg = (uintptr *)runtime_mapassign_faststr((runtime_maptype_0 *)&stru_80CFB40, v435, hint_4cg);
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr(bucketcg, (uintptr)srccg);
    else
      *bucketcg = (uintptr)srccg;
    srcch = unicode_Coptic;
    hint_4ch.str = (uint8 *)"Coptic";
    hint_4ch.len = 6;
    bucketch = (uintptr *)runtime_mapassign_faststr((runtime_maptype_0 *)&stru_80CFB40, v435, hint_4ch);
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr(bucketch, (uintptr)srcch);
    else
      *bucketch = (uintptr)srcch;
    srcci = unicode_Cuneiform;
    hint_4ci.str = (uint8 *)"Cuneiform";
    hint_4ci.len = 9;
    bucketci = (uintptr *)runtime_mapassign_faststr((runtime_maptype_0 *)&stru_80CFB40, v435, hint_4ci);
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr(bucketci, (uintptr)srcci);
    else
      *bucketci = (uintptr)srcci;
    srccj = unicode_Cypriot;
    hint_4cj.str = (uint8 *)"Cypriot";
    hint_4cj.len = 7;
    bucketcj = (uintptr *)runtime_mapassign_faststr((runtime_maptype_0 *)&stru_80CFB40, v435, hint_4cj);
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr(bucketcj, (uintptr)srccj);
    else
      *bucketcj = (uintptr)srccj;
    srcck = unicode_Cyrillic;
    hint_4ck.str = (uint8 *)"Cyrillic";
    hint_4ck.len = 8;
    bucketck = (uintptr *)runtime_mapassign_faststr((runtime_maptype_0 *)&stru_80CFB40, v435, hint_4ck);
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr(bucketck, (uintptr)srcck);
    else
      *bucketck = (uintptr)srcck;
    srccl = unicode_Deseret;
    hint_4cl.str = (uint8 *)"Deseret";
    hint_4cl.len = 7;
    bucketcl = (uintptr *)runtime_mapassign_faststr((runtime_maptype_0 *)&stru_80CFB40, v435, hint_4cl);
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr(bucketcl, (uintptr)srccl);
    else
      *bucketcl = (uintptr)srccl;
    srccm = unicode_Devanagari;
    hint_4cm.str = (uint8 *)"Devanagari";
    hint_4cm.len = 10;
    bucketcm = (uintptr *)runtime_mapassign_faststr((runtime_maptype_0 *)&stru_80CFB40, v435, hint_4cm);
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr(bucketcm, (uintptr)srccm);
    else
      *bucketcm = (uintptr)srccm;
    srccn = unicode_Duployan;
    hint_4cn.str = (uint8 *)"Duployan";
    hint_4cn.len = 8;
    bucketcn = (uintptr *)runtime_mapassign_faststr((runtime_maptype_0 *)&stru_80CFB40, v435, hint_4cn);
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr(bucketcn, (uintptr)srccn);
    else
      *bucketcn = (uintptr)srccn;
    srcco = unicode_Egyptian_Hieroglyphs;
    hint_4co.str = (uint8 *)"Egyptian_Hieroglyphs";
    hint_4co.len = 20;
    bucketco = (uintptr *)runtime_mapassign_faststr((runtime_maptype_0 *)&stru_80CFB40, v435, hint_4co);
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr(bucketco, (uintptr)srcco);
    else
      *bucketco = (uintptr)srcco;
    srccp = unicode_Elbasan;
    hint_4cp.str = (uint8 *)"Elbasan";
    hint_4cp.len = 7;
    bucketcp = (uintptr *)runtime_mapassign_faststr((runtime_maptype_0 *)&stru_80CFB40, v435, hint_4cp);
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr(bucketcp, (uintptr)srccp);
    else
      *bucketcp = (uintptr)srccp;
    srccq = unicode_Ethiopic;
    hint_4cq.str = (uint8 *)"Ethiopic";
    hint_4cq.len = 8;
    bucketcq = (uintptr *)runtime_mapassign_faststr((runtime_maptype_0 *)&stru_80CFB40, v435, hint_4cq);
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr(bucketcq, (uintptr)srccq);
    else
      *bucketcq = (uintptr)srccq;
    srccr = unicode_Georgian;
    hint_4cr.str = (uint8 *)"Georgian";
    hint_4cr.len = 8;
    bucketcr = (uintptr *)runtime_mapassign_faststr((runtime_maptype_0 *)&stru_80CFB40, v435, hint_4cr);
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr(bucketcr, (uintptr)srccr);
    else
      *bucketcr = (uintptr)srccr;
    srccs = unicode_Glagolitic;
    hint_4cs.str = (uint8 *)"Glagolitic";
    hint_4cs.len = 10;
    bucketcs = (uintptr *)runtime_mapassign_faststr((runtime_maptype_0 *)&stru_80CFB40, v435, hint_4cs);
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr(bucketcs, (uintptr)srccs);
    else
      *bucketcs = (uintptr)srccs;
    srcct = unicode_Gothic;
    hint_4ct.str = (uint8 *)"Gothic";
    hint_4ct.len = 6;
    bucketct = (uintptr *)runtime_mapassign_faststr((runtime_maptype_0 *)&stru_80CFB40, v435, hint_4ct);
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr(bucketct, (uintptr)srcct);
    else
      *bucketct = (uintptr)srcct;
    srccu = unicode_Grantha;
    hint_4cu.str = (uint8 *)"Grantha";
    hint_4cu.len = 7;
    bucketcu = (uintptr *)runtime_mapassign_faststr((runtime_maptype_0 *)&stru_80CFB40, v435, hint_4cu);
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr(bucketcu, (uintptr)srccu);
    else
      *bucketcu = (uintptr)srccu;
    srccv = unicode_Greek;
    hint_4cv.str = (uint8 *)"Greek";
    hint_4cv.len = 5;
    bucketcv = (uintptr *)runtime_mapassign_faststr((runtime_maptype_0 *)&stru_80CFB40, v435, hint_4cv);
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr(bucketcv, (uintptr)srccv);
    else
      *bucketcv = (uintptr)srccv;
    srccw = unicode_Gujarati;
    hint_4cw.str = (uint8 *)"Gujarati";
    hint_4cw.len = 8;
    bucketcw = (uintptr *)runtime_mapassign_faststr((runtime_maptype_0 *)&stru_80CFB40, v435, hint_4cw);
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr(bucketcw, (uintptr)srccw);
    else
      *bucketcw = (uintptr)srccw;
    srccx = unicode_Gurmukhi;
    hint_4cx.str = (uint8 *)"Gurmukhi";
    hint_4cx.len = 8;
    bucketcx = (uintptr *)runtime_mapassign_faststr((runtime_maptype_0 *)&stru_80CFB40, v435, hint_4cx);
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr(bucketcx, (uintptr)srccx);
    else
      *bucketcx = (uintptr)srccx;
    srccy = unicode_Han;
    hint_4cy.str = (uint8 *)"Han";
    hint_4cy.len = 3;
    bucketcy = (uintptr *)runtime_mapassign_faststr((runtime_maptype_0 *)&stru_80CFB40, v435, hint_4cy);
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr(bucketcy, (uintptr)srccy);
    else
      *bucketcy = (uintptr)srccy;
    srccz = unicode_Hangul;
    hint_4cz.str = (uint8 *)"Hangul";
    hint_4cz.len = 6;
    bucketcz = (uintptr *)runtime_mapassign_faststr((runtime_maptype_0 *)&stru_80CFB40, v435, hint_4cz);
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr(bucketcz, (uintptr)srccz);
    else
      *bucketcz = (uintptr)srccz;
    srcda = unicode_Hanunoo;
    hint_4da.str = (uint8 *)"Hanunoo";
    hint_4da.len = 7;
    bucketda = (uintptr *)runtime_mapassign_faststr((runtime_maptype_0 *)&stru_80CFB40, v435, hint_4da);
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr(bucketda, (uintptr)srcda);
    else
      *bucketda = (uintptr)srcda;
    srcdb = unicode_Hatran;
    hint_4db.str = (uint8 *)"Hatran";
    hint_4db.len = 6;
    bucketdb = (uintptr *)runtime_mapassign_faststr((runtime_maptype_0 *)&stru_80CFB40, v435, hint_4db);
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr(bucketdb, (uintptr)srcdb);
    else
      *bucketdb = (uintptr)srcdb;
    srcdc = unicode_Hebrew;
    hint_4dc.str = (uint8 *)"Hebrew";
    hint_4dc.len = 6;
    bucketdc = (uintptr *)runtime_mapassign_faststr((runtime_maptype_0 *)&stru_80CFB40, v435, hint_4dc);
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr(bucketdc, (uintptr)srcdc);
    else
      *bucketdc = (uintptr)srcdc;
    srcdd = unicode_Hiragana;
    hint_4dd.str = (uint8 *)"Hiragana";
    hint_4dd.len = 8;
    bucketdd = (uintptr *)runtime_mapassign_faststr((runtime_maptype_0 *)&stru_80CFB40, v435, hint_4dd);
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr(bucketdd, (uintptr)srcdd);
    else
      *bucketdd = (uintptr)srcdd;
    srcde = unicode_Imperial_Aramaic;
    hint_4de.str = (uint8 *)"Imperial_Aramaic";
    hint_4de.len = 16;
    bucketde = (uintptr *)runtime_mapassign_faststr((runtime_maptype_0 *)&stru_80CFB40, v435, hint_4de);
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr(bucketde, (uintptr)srcde);
    else
      *bucketde = (uintptr)srcde;
    srcdf = unicode_Inherited;
    hint_4df.str = (uint8 *)"Inherited";
    hint_4df.len = 9;
    bucketdf = (uintptr *)runtime_mapassign_faststr((runtime_maptype_0 *)&stru_80CFB40, v435, hint_4df);
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr(bucketdf, (uintptr)srcdf);
    else
      *bucketdf = (uintptr)srcdf;
    srcdg = unicode_Inscriptional_Pahlavi;
    hint_4dg.str = (uint8 *)"Inscriptional_Pahlavi";
    hint_4dg.len = 21;
    bucketdg = (uintptr *)runtime_mapassign_faststr((runtime_maptype_0 *)&stru_80CFB40, v435, hint_4dg);
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr(bucketdg, (uintptr)srcdg);
    else
      *bucketdg = (uintptr)srcdg;
    srcdh = unicode_Inscriptional_Parthian;
    hint_4dh.str = (uint8 *)"Inscriptional_Parthian";
    hint_4dh.len = 22;
    bucketdh = (uintptr *)runtime_mapassign_faststr((runtime_maptype_0 *)&stru_80CFB40, v435, hint_4dh);
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr(bucketdh, (uintptr)srcdh);
    else
      *bucketdh = (uintptr)srcdh;
    srcdi = unicode_Javanese;
    hint_4di.str = (uint8 *)"Javanese";
    hint_4di.len = 8;
    bucketdi = (uintptr *)runtime_mapassign_faststr((runtime_maptype_0 *)&stru_80CFB40, v435, hint_4di);
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr(bucketdi, (uintptr)srcdi);
    else
      *bucketdi = (uintptr)srcdi;
    srcdj = unicode_Kaithi;
    hint_4dj.str = (uint8 *)"Kaithi";
    hint_4dj.len = 6;
    bucketdj = (uintptr *)runtime_mapassign_faststr((runtime_maptype_0 *)&stru_80CFB40, v435, hint_4dj);
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr(bucketdj, (uintptr)srcdj);
    else
      *bucketdj = (uintptr)srcdj;
    srcdk = unicode_Kannada;
    hint_4dk.str = (uint8 *)"Kannada";
    hint_4dk.len = 7;
    bucketdk = (uintptr *)runtime_mapassign_faststr((runtime_maptype_0 *)&stru_80CFB40, v435, hint_4dk);
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr(bucketdk, (uintptr)srcdk);
    else
      *bucketdk = (uintptr)srcdk;
    srcdl = unicode_Katakana;
    hint_4dl.str = (uint8 *)"Katakana";
    hint_4dl.len = 8;
    bucketdl = (uintptr *)runtime_mapassign_faststr((runtime_maptype_0 *)&stru_80CFB40, v435, hint_4dl);
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr(bucketdl, (uintptr)srcdl);
    else
      *bucketdl = (uintptr)srcdl;
    srcdm = unicode_Kayah_Li;
    hint_4dm.str = (uint8 *)"Kayah_Li";
    hint_4dm.len = 8;
    bucketdm = (uintptr *)runtime_mapassign_faststr((runtime_maptype_0 *)&stru_80CFB40, v435, hint_4dm);
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr(bucketdm, (uintptr)srcdm);
    else
      *bucketdm = (uintptr)srcdm;
    srcdn = unicode_Kharoshthi;
    hint_4dn.str = (uint8 *)"Kharoshthi";
    hint_4dn.len = 10;
    bucketdn = (uintptr *)runtime_mapassign_faststr((runtime_maptype_0 *)&stru_80CFB40, v435, hint_4dn);
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr(bucketdn, (uintptr)srcdn);
    else
      *bucketdn = (uintptr)srcdn;
    srcdo = unicode_Khmer;
    hint_4do.str = (uint8 *)"Khmer";
    hint_4do.len = 5;
    bucketdo = (uintptr *)runtime_mapassign_faststr((runtime_maptype_0 *)&stru_80CFB40, v435, hint_4do);
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr(bucketdo, (uintptr)srcdo);
    else
      *bucketdo = (uintptr)srcdo;
    srcdp = unicode_Khojki;
    hint_4dp.str = (uint8 *)"Khojki";
    hint_4dp.len = 6;
    bucketdp = (uintptr *)runtime_mapassign_faststr((runtime_maptype_0 *)&stru_80CFB40, v435, hint_4dp);
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr(bucketdp, (uintptr)srcdp);
    else
      *bucketdp = (uintptr)srcdp;
    srcdq = unicode_Khudawadi;
    hint_4dq.str = (uint8 *)"Khudawadi";
    hint_4dq.len = 9;
    bucketdq = (uintptr *)runtime_mapassign_faststr((runtime_maptype_0 *)&stru_80CFB40, v435, hint_4dq);
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr(bucketdq, (uintptr)srcdq);
    else
      *bucketdq = (uintptr)srcdq;
    srcdr = unicode_Lao;
    hint_4dr.str = (uint8 *)"Lao";
    hint_4dr.len = 3;
    bucketdr = (uintptr *)runtime_mapassign_faststr((runtime_maptype_0 *)&stru_80CFB40, v435, hint_4dr);
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr(bucketdr, (uintptr)srcdr);
    else
      *bucketdr = (uintptr)srcdr;
    srcds = unicode_Latin;
    hint_4ds.str = (uint8 *)"Latin";
    hint_4ds.len = 5;
    bucketds = (uintptr *)runtime_mapassign_faststr((runtime_maptype_0 *)&stru_80CFB40, v435, hint_4ds);
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr(bucketds, (uintptr)srcds);
    else
      *bucketds = (uintptr)srcds;
    srcdt = unicode_Lepcha;
    hint_4dt.str = (uint8 *)"Lepcha";
    hint_4dt.len = 6;
    bucketdt = (uintptr *)runtime_mapassign_faststr((runtime_maptype_0 *)&stru_80CFB40, v435, hint_4dt);
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr(bucketdt, (uintptr)srcdt);
    else
      *bucketdt = (uintptr)srcdt;
    srcdu = unicode_Limbu;
    hint_4du.str = (uint8 *)"Limbu";
    hint_4du.len = 5;
    bucketdu = (uintptr *)runtime_mapassign_faststr((runtime_maptype_0 *)&stru_80CFB40, v435, hint_4du);
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr(bucketdu, (uintptr)srcdu);
    else
      *bucketdu = (uintptr)srcdu;
    srcdv = unicode_Linear_A;
    hint_4dv.str = (uint8 *)"Linear_A";
    hint_4dv.len = 8;
    bucketdv = (uintptr *)runtime_mapassign_faststr((runtime_maptype_0 *)&stru_80CFB40, v435, hint_4dv);
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr(bucketdv, (uintptr)srcdv);
    else
      *bucketdv = (uintptr)srcdv;
    srcdw = unicode_Linear_B;
    hint_4dw.str = (uint8 *)"Linear_B";
    hint_4dw.len = 8;
    bucketdw = (uintptr *)runtime_mapassign_faststr((runtime_maptype_0 *)&stru_80CFB40, v435, hint_4dw);
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr(bucketdw, (uintptr)srcdw);
    else
      *bucketdw = (uintptr)srcdw;
    srcdx = unicode_Lisu;
    hint_4dx.str = (uint8 *)"Lisu";
    hint_4dx.len = 4;
    bucketdx = (uintptr *)runtime_mapassign_faststr((runtime_maptype_0 *)&stru_80CFB40, v435, hint_4dx);
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr(bucketdx, (uintptr)srcdx);
    else
      *bucketdx = (uintptr)srcdx;
    srcdy = unicode_Lycian;
    hint_4dy.str = (uint8 *)"Lycian";
    hint_4dy.len = 6;
    bucketdy = (uintptr *)runtime_mapassign_faststr((runtime_maptype_0 *)&stru_80CFB40, v435, hint_4dy);
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr(bucketdy, (uintptr)srcdy);
    else
      *bucketdy = (uintptr)srcdy;
    srcdz = unicode_Lydian;
    hint_4dz.str = (uint8 *)"Lydian";
    hint_4dz.len = 6;
    bucketdz = (uintptr *)runtime_mapassign_faststr((runtime_maptype_0 *)&stru_80CFB40, v435, hint_4dz);
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr(bucketdz, (uintptr)srcdz);
    else
      *bucketdz = (uintptr)srcdz;
    srcea = unicode_Mahajani;
    hint_4ea.str = (uint8 *)"Mahajani";
    hint_4ea.len = 8;
    bucketea = (uintptr *)runtime_mapassign_faststr((runtime_maptype_0 *)&stru_80CFB40, v435, hint_4ea);
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr(bucketea, (uintptr)srcea);
    else
      *bucketea = (uintptr)srcea;
    srceb = unicode_Malayalam;
    hint_4eb.str = (uint8 *)"Malayalam";
    hint_4eb.len = 9;
    bucketeb = (uintptr *)runtime_mapassign_faststr((runtime_maptype_0 *)&stru_80CFB40, v435, hint_4eb);
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr(bucketeb, (uintptr)srceb);
    else
      *bucketeb = (uintptr)srceb;
    srcec = unicode_Mandaic;
    hint_4ec.str = (uint8 *)"Mandaic";
    hint_4ec.len = 7;
    bucketec = (uintptr *)runtime_mapassign_faststr((runtime_maptype_0 *)&stru_80CFB40, v435, hint_4ec);
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr(bucketec, (uintptr)srcec);
    else
      *bucketec = (uintptr)srcec;
    srced = unicode_Manichaean;
    hint_4ed.str = (uint8 *)"Manichaean";
    hint_4ed.len = 10;
    bucketed = (uintptr *)runtime_mapassign_faststr((runtime_maptype_0 *)&stru_80CFB40, v435, hint_4ed);
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr(bucketed, (uintptr)srced);
    else
      *bucketed = (uintptr)srced;
    srcee = unicode_Marchen;
    hint_4ee.str = (uint8 *)"Marchen";
    hint_4ee.len = 7;
    bucketee = (uintptr *)runtime_mapassign_faststr((runtime_maptype_0 *)&stru_80CFB40, v435, hint_4ee);
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr(bucketee, (uintptr)srcee);
    else
      *bucketee = (uintptr)srcee;
    srcef = unicode_Meetei_Mayek;
    hint_4ef.str = (uint8 *)"Meetei_Mayek";
    hint_4ef.len = 12;
    bucketef = (uintptr *)runtime_mapassign_faststr((runtime_maptype_0 *)&stru_80CFB40, v435, hint_4ef);
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr(bucketef, (uintptr)srcef);
    else
      *bucketef = (uintptr)srcef;
    srceg = unicode_Mende_Kikakui;
    hint_4eg.str = (uint8 *)"Mende_Kikakui";
    hint_4eg.len = 13;
    bucketeg = (uintptr *)runtime_mapassign_faststr((runtime_maptype_0 *)&stru_80CFB40, v435, hint_4eg);
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr(bucketeg, (uintptr)srceg);
    else
      *bucketeg = (uintptr)srceg;
    srceh = unicode_Meroitic_Cursive;
    hint_4eh.str = (uint8 *)"Meroitic_Cursive";
    hint_4eh.len = 16;
    bucketeh = (uintptr *)runtime_mapassign_faststr((runtime_maptype_0 *)&stru_80CFB40, v435, hint_4eh);
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr(bucketeh, (uintptr)srceh);
    else
      *bucketeh = (uintptr)srceh;
    srcei = unicode_Meroitic_Hieroglyphs;
    hint_4ei.str = (uint8 *)"Meroitic_Hieroglyphs";
    hint_4ei.len = 20;
    bucketei = (uintptr *)runtime_mapassign_faststr((runtime_maptype_0 *)&stru_80CFB40, v435, hint_4ei);
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr(bucketei, (uintptr)srcei);
    else
      *bucketei = (uintptr)srcei;
    srcej = unicode_Miao;
    hint_4ej.str = (uint8 *)"Miao";
    hint_4ej.len = 4;
    bucketej = (uintptr *)runtime_mapassign_faststr((runtime_maptype_0 *)&stru_80CFB40, v435, hint_4ej);
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr(bucketej, (uintptr)srcej);
    else
      *bucketej = (uintptr)srcej;
    srcek = unicode_Modi;
    hint_4ek.str = (uint8 *)"Modi";
    hint_4ek.len = 4;
    bucketek = (uintptr *)runtime_mapassign_faststr((runtime_maptype_0 *)&stru_80CFB40, v435, hint_4ek);
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr(bucketek, (uintptr)srcek);
    else
      *bucketek = (uintptr)srcek;
    srcel = unicode_Mongolian;
    hint_4el.str = (uint8 *)"Mongolian";
    hint_4el.len = 9;
    bucketel = (uintptr *)runtime_mapassign_faststr((runtime_maptype_0 *)&stru_80CFB40, v435, hint_4el);
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr(bucketel, (uintptr)srcel);
    else
      *bucketel = (uintptr)srcel;
    srcem = unicode_Mro;
    hint_4em.str = (uint8 *)"Mro";
    hint_4em.len = 3;
    bucketem = (uintptr *)runtime_mapassign_faststr((runtime_maptype_0 *)&stru_80CFB40, v435, hint_4em);
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr(bucketem, (uintptr)srcem);
    else
      *bucketem = (uintptr)srcem;
    srcen = unicode_Multani;
    hint_4en.str = (uint8 *)"Multani";
    hint_4en.len = 7;
    bucketen = (uintptr *)runtime_mapassign_faststr((runtime_maptype_0 *)&stru_80CFB40, v435, hint_4en);
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr(bucketen, (uintptr)srcen);
    else
      *bucketen = (uintptr)srcen;
    srceo = unicode_Myanmar;
    hint_4eo.str = (uint8 *)"Myanmar";
    hint_4eo.len = 7;
    bucketeo = (uintptr *)runtime_mapassign_faststr((runtime_maptype_0 *)&stru_80CFB40, v435, hint_4eo);
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr(bucketeo, (uintptr)srceo);
    else
      *bucketeo = (uintptr)srceo;
    srcep = unicode_Nabataean;
    hint_4ep.str = (uint8 *)"Nabataean";
    hint_4ep.len = 9;
    bucketep = (uintptr *)runtime_mapassign_faststr((runtime_maptype_0 *)&stru_80CFB40, v435, hint_4ep);
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr(bucketep, (uintptr)srcep);
    else
      *bucketep = (uintptr)srcep;
    srceq = unicode_New_Tai_Lue;
    hint_4eq.str = (uint8 *)"New_Tai_Lue";
    hint_4eq.len = 11;
    bucketeq = (uintptr *)runtime_mapassign_faststr((runtime_maptype_0 *)&stru_80CFB40, v435, hint_4eq);
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr(bucketeq, (uintptr)srceq);
    else
      *bucketeq = (uintptr)srceq;
    srcer = unicode_Newa;
    hint_4er.str = (uint8 *)"Newa";
    hint_4er.len = 4;
    bucketer = (uintptr *)runtime_mapassign_faststr((runtime_maptype_0 *)&stru_80CFB40, v435, hint_4er);
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr(bucketer, (uintptr)srcer);
    else
      *bucketer = (uintptr)srcer;
    srces = unicode_Nko;
    hint_4es.str = (uint8 *)"Nko";
    hint_4es.len = 3;
    bucketes = (uintptr *)runtime_mapassign_faststr((runtime_maptype_0 *)&stru_80CFB40, v435, hint_4es);
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr(bucketes, (uintptr)srces);
    else
      *bucketes = (uintptr)srces;
    srcet = unicode_Ogham;
    hint_4et.str = (uint8 *)"Ogham";
    hint_4et.len = 5;
    bucketet = (uintptr *)runtime_mapassign_faststr((runtime_maptype_0 *)&stru_80CFB40, v435, hint_4et);
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr(bucketet, (uintptr)srcet);
    else
      *bucketet = (uintptr)srcet;
    srceu = unicode_Ol_Chiki;
    hint_4eu.str = (uint8 *)"Ol_Chiki";
    hint_4eu.len = 8;
    bucketeu = (uintptr *)runtime_mapassign_faststr((runtime_maptype_0 *)&stru_80CFB40, v435, hint_4eu);
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr(bucketeu, (uintptr)srceu);
    else
      *bucketeu = (uintptr)srceu;
    srcev = unicode_Old_Hungarian;
    hint_4ev.str = (uint8 *)"Old_Hungarian";
    hint_4ev.len = 13;
    bucketev = (uintptr *)runtime_mapassign_faststr((runtime_maptype_0 *)&stru_80CFB40, v435, hint_4ev);
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr(bucketev, (uintptr)srcev);
    else
      *bucketev = (uintptr)srcev;
    srcew = unicode_Old_Italic;
    hint_4ew.str = (uint8 *)"Old_Italic";
    hint_4ew.len = 10;
    bucketew = (uintptr *)runtime_mapassign_faststr((runtime_maptype_0 *)&stru_80CFB40, v435, hint_4ew);
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr(bucketew, (uintptr)srcew);
    else
      *bucketew = (uintptr)srcew;
    srcex = unicode_Old_North_Arabian;
    hint_4ex.str = (uint8 *)"Old_North_Arabian";
    hint_4ex.len = 17;
    bucketex = (uintptr *)runtime_mapassign_faststr((runtime_maptype_0 *)&stru_80CFB40, v435, hint_4ex);
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr(bucketex, (uintptr)srcex);
    else
      *bucketex = (uintptr)srcex;
    srcey = unicode_Old_Permic;
    hint_4ey.str = (uint8 *)"Old_Permic";
    hint_4ey.len = 10;
    bucketey = (uintptr *)runtime_mapassign_faststr((runtime_maptype_0 *)&stru_80CFB40, v435, hint_4ey);
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr(bucketey, (uintptr)srcey);
    else
      *bucketey = (uintptr)srcey;
    srcez = unicode_Old_Persian;
    hint_4ez.str = (uint8 *)"Old_Persian";
    hint_4ez.len = 11;
    bucketez = (uintptr *)runtime_mapassign_faststr((runtime_maptype_0 *)&stru_80CFB40, v435, hint_4ez);
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr(bucketez, (uintptr)srcez);
    else
      *bucketez = (uintptr)srcez;
    srcfa = unicode_Old_South_Arabian;
    hint_4fa.str = (uint8 *)"Old_South_Arabian";
    hint_4fa.len = 17;
    bucketfa = (uintptr *)runtime_mapassign_faststr((runtime_maptype_0 *)&stru_80CFB40, v435, hint_4fa);
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr(bucketfa, (uintptr)srcfa);
    else
      *bucketfa = (uintptr)srcfa;
    srcfb = unicode_Old_Turkic;
    hint_4fb.str = (uint8 *)"Old_Turkic";
    hint_4fb.len = 10;
    bucketfb = (uintptr *)runtime_mapassign_faststr((runtime_maptype_0 *)&stru_80CFB40, v435, hint_4fb);
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr(bucketfb, (uintptr)srcfb);
    else
      *bucketfb = (uintptr)srcfb;
    srcfc = unicode_Oriya;
    hint_4fc.str = (uint8 *)"Oriya";
    hint_4fc.len = 5;
    bucketfc = (uintptr *)runtime_mapassign_faststr((runtime_maptype_0 *)&stru_80CFB40, v435, hint_4fc);
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr(bucketfc, (uintptr)srcfc);
    else
      *bucketfc = (uintptr)srcfc;
    srcfd = unicode_Osage;
    hint_4fd.str = (uint8 *)"Osage";
    hint_4fd.len = 5;
    bucketfd = (uintptr *)runtime_mapassign_faststr((runtime_maptype_0 *)&stru_80CFB40, v435, hint_4fd);
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr(bucketfd, (uintptr)srcfd);
    else
      *bucketfd = (uintptr)srcfd;
    srcfe = unicode_Osmanya;
    hint_4fe.str = (uint8 *)"Osmanya";
    hint_4fe.len = 7;
    bucketfe = (uintptr *)runtime_mapassign_faststr((runtime_maptype_0 *)&stru_80CFB40, v435, hint_4fe);
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr(bucketfe, (uintptr)srcfe);
    else
      *bucketfe = (uintptr)srcfe;
    srcff = unicode_Pahawh_Hmong;
    hint_4ff.str = (uint8 *)"Pahawh_Hmong";
    hint_4ff.len = 12;
    bucketff = (uintptr *)runtime_mapassign_faststr((runtime_maptype_0 *)&stru_80CFB40, v435, hint_4ff);
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr(bucketff, (uintptr)srcff);
    else
      *bucketff = (uintptr)srcff;
    srcfg = unicode_Palmyrene;
    hint_4fg.str = (uint8 *)"Palmyrene";
    hint_4fg.len = 9;
    bucketfg = (uintptr *)runtime_mapassign_faststr((runtime_maptype_0 *)&stru_80CFB40, v435, hint_4fg);
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr(bucketfg, (uintptr)srcfg);
    else
      *bucketfg = (uintptr)srcfg;
    srcfh = unicode_Pau_Cin_Hau;
    hint_4fh.str = (uint8 *)"Pau_Cin_Hau";
    hint_4fh.len = 11;
    bucketfh = (uintptr *)runtime_mapassign_faststr((runtime_maptype_0 *)&stru_80CFB40, v435, hint_4fh);
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr(bucketfh, (uintptr)srcfh);
    else
      *bucketfh = (uintptr)srcfh;
    srcfi = unicode_Phags_Pa;
    hint_4fi.str = (uint8 *)"Phags_Pa";
    hint_4fi.len = 8;
    bucketfi = (uintptr *)runtime_mapassign_faststr((runtime_maptype_0 *)&stru_80CFB40, v435, hint_4fi);
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr(bucketfi, (uintptr)srcfi);
    else
      *bucketfi = (uintptr)srcfi;
    srcfj = unicode_Phoenician;
    hint_4fj.str = (uint8 *)"Phoenician";
    hint_4fj.len = 10;
    bucketfj = (uintptr *)runtime_mapassign_faststr((runtime_maptype_0 *)&stru_80CFB40, v435, hint_4fj);
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr(bucketfj, (uintptr)srcfj);
    else
      *bucketfj = (uintptr)srcfj;
    srcfk = unicode_Psalter_Pahlavi;
    hint_4fk.str = (uint8 *)"Psalter_Pahlavi";
    hint_4fk.len = 15;
    bucketfk = (uintptr *)runtime_mapassign_faststr((runtime_maptype_0 *)&stru_80CFB40, v435, hint_4fk);
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr(bucketfk, (uintptr)srcfk);
    else
      *bucketfk = (uintptr)srcfk;
    srcfl = unicode_Rejang;
    hint_4fl.str = (uint8 *)"Rejang";
    hint_4fl.len = 6;
    bucketfl = (uintptr *)runtime_mapassign_faststr((runtime_maptype_0 *)&stru_80CFB40, v435, hint_4fl);
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr(bucketfl, (uintptr)srcfl);
    else
      *bucketfl = (uintptr)srcfl;
    srcfm = unicode_Runic;
    hint_4fm.str = (uint8 *)"Runic";
    hint_4fm.len = 5;
    bucketfm = (uintptr *)runtime_mapassign_faststr((runtime_maptype_0 *)&stru_80CFB40, v435, hint_4fm);
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr(bucketfm, (uintptr)srcfm);
    else
      *bucketfm = (uintptr)srcfm;
    srcfn = unicode_Samaritan;
    hint_4fn.str = (uint8 *)"Samaritan";
    hint_4fn.len = 9;
    bucketfn = (uintptr *)runtime_mapassign_faststr((runtime_maptype_0 *)&stru_80CFB40, v435, hint_4fn);
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr(bucketfn, (uintptr)srcfn);
    else
      *bucketfn = (uintptr)srcfn;
    srcfo = unicode_Saurashtra;
    hint_4fo.str = (uint8 *)"Saurashtra";
    hint_4fo.len = 10;
    bucketfo = (uintptr *)runtime_mapassign_faststr((runtime_maptype_0 *)&stru_80CFB40, v435, hint_4fo);
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr(bucketfo, (uintptr)srcfo);
    else
      *bucketfo = (uintptr)srcfo;
    srcfp = unicode_Sharada;
    hint_4fp.str = (uint8 *)"Sharada";
    hint_4fp.len = 7;
    bucketfp = (uintptr *)runtime_mapassign_faststr((runtime_maptype_0 *)&stru_80CFB40, v435, hint_4fp);
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr(bucketfp, (uintptr)srcfp);
    else
      *bucketfp = (uintptr)srcfp;
    srcfq = unicode_Shavian;
    hint_4fq.str = (uint8 *)"Shavian";
    hint_4fq.len = 7;
    bucketfq = (uintptr *)runtime_mapassign_faststr((runtime_maptype_0 *)&stru_80CFB40, v435, hint_4fq);
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr(bucketfq, (uintptr)srcfq);
    else
      *bucketfq = (uintptr)srcfq;
    srcfr = unicode_Siddham;
    hint_4fr.str = (uint8 *)"Siddham";
    hint_4fr.len = 7;
    bucketfr = (uintptr *)runtime_mapassign_faststr((runtime_maptype_0 *)&stru_80CFB40, v435, hint_4fr);
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr(bucketfr, (uintptr)srcfr);
    else
      *bucketfr = (uintptr)srcfr;
    srcfs = unicode_SignWriting;
    hint_4fs.str = (uint8 *)"SignWriting";
    hint_4fs.len = 11;
    bucketfs = (uintptr *)runtime_mapassign_faststr((runtime_maptype_0 *)&stru_80CFB40, v435, hint_4fs);
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr(bucketfs, (uintptr)srcfs);
    else
      *bucketfs = (uintptr)srcfs;
    srcft = unicode_Sinhala;
    hint_4ft.str = (uint8 *)"Sinhala";
    hint_4ft.len = 7;
    bucketft = (uintptr *)runtime_mapassign_faststr((runtime_maptype_0 *)&stru_80CFB40, v435, hint_4ft);
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr(bucketft, (uintptr)srcft);
    else
      *bucketft = (uintptr)srcft;
    srcfu = unicode_Sora_Sompeng;
    hint_4fu.str = (uint8 *)"Sora_Sompeng";
    hint_4fu.len = 12;
    bucketfu = (uintptr *)runtime_mapassign_faststr((runtime_maptype_0 *)&stru_80CFB40, v435, hint_4fu);
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr(bucketfu, (uintptr)srcfu);
    else
      *bucketfu = (uintptr)srcfu;
    srcfv = unicode_Sundanese;
    hint_4fv.str = (uint8 *)"Sundanese";
    hint_4fv.len = 9;
    bucketfv = (uintptr *)runtime_mapassign_faststr((runtime_maptype_0 *)&stru_80CFB40, v435, hint_4fv);
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr(bucketfv, (uintptr)srcfv);
    else
      *bucketfv = (uintptr)srcfv;
    srcfw = unicode_Syloti_Nagri;
    hint_4fw.str = (uint8 *)"Syloti_Nagri";
    hint_4fw.len = 12;
    bucketfw = (uintptr *)runtime_mapassign_faststr((runtime_maptype_0 *)&stru_80CFB40, v435, hint_4fw);
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr(bucketfw, (uintptr)srcfw);
    else
      *bucketfw = (uintptr)srcfw;
    srcfx = unicode_Syriac;
    hint_4fx.str = (uint8 *)"Syriac";
    hint_4fx.len = 6;
    bucketfx = (uintptr *)runtime_mapassign_faststr((runtime_maptype_0 *)&stru_80CFB40, v435, hint_4fx);
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr(bucketfx, (uintptr)srcfx);
    else
      *bucketfx = (uintptr)srcfx;
    srcfy = unicode_Tagalog;
    hint_4fy.str = (uint8 *)"Tagalog";
    hint_4fy.len = 7;
    bucketfy = (uintptr *)runtime_mapassign_faststr((runtime_maptype_0 *)&stru_80CFB40, v435, hint_4fy);
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr(bucketfy, (uintptr)srcfy);
    else
      *bucketfy = (uintptr)srcfy;
    srcfz = unicode_Tagbanwa;
    hint_4fz.str = (uint8 *)"Tagbanwa";
    hint_4fz.len = 8;
    bucketfz = (uintptr *)runtime_mapassign_faststr((runtime_maptype_0 *)&stru_80CFB40, v435, hint_4fz);
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr(bucketfz, (uintptr)srcfz);
    else
      *bucketfz = (uintptr)srcfz;
    srcga = unicode_Tai_Le;
    hint_4ga.str = (uint8 *)"Tai_Le";
    hint_4ga.len = 6;
    bucketga = (uintptr *)runtime_mapassign_faststr((runtime_maptype_0 *)&stru_80CFB40, v435, hint_4ga);
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr(bucketga, (uintptr)srcga);
    else
      *bucketga = (uintptr)srcga;
    srcgb = unicode_Tai_Tham;
    hint_4gb.str = (uint8 *)"Tai_Tham";
    hint_4gb.len = 8;
    bucketgb = (uintptr *)runtime_mapassign_faststr((runtime_maptype_0 *)&stru_80CFB40, v435, hint_4gb);
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr(bucketgb, (uintptr)srcgb);
    else
      *bucketgb = (uintptr)srcgb;
    srcgc = unicode_Tai_Viet;
    hint_4gc.str = (uint8 *)"Tai_Viet";
    hint_4gc.len = 8;
    bucketgc = (uintptr *)runtime_mapassign_faststr((runtime_maptype_0 *)&stru_80CFB40, v435, hint_4gc);
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr(bucketgc, (uintptr)srcgc);
    else
      *bucketgc = (uintptr)srcgc;
    srcgd = unicode_Takri;
    hint_4gd.str = (uint8 *)"Takri";
    hint_4gd.len = 5;
    bucketgd = (uintptr *)runtime_mapassign_faststr((runtime_maptype_0 *)&stru_80CFB40, v435, hint_4gd);
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr(bucketgd, (uintptr)srcgd);
    else
      *bucketgd = (uintptr)srcgd;
    srcge = unicode_Tamil;
    hint_4ge.str = (uint8 *)"Tamil";
    hint_4ge.len = 5;
    bucketge = (uintptr *)runtime_mapassign_faststr((runtime_maptype_0 *)&stru_80CFB40, v435, hint_4ge);
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr(bucketge, (uintptr)srcge);
    else
      *bucketge = (uintptr)srcge;
    srcgf = unicode_Tangut;
    hint_4gf.str = (uint8 *)"Tangut";
    hint_4gf.len = 6;
    bucketgf = (uintptr *)runtime_mapassign_faststr((runtime_maptype_0 *)&stru_80CFB40, v435, hint_4gf);
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr(bucketgf, (uintptr)srcgf);
    else
      *bucketgf = (uintptr)srcgf;
    srcgg = unicode_Telugu;
    hint_4gg.str = (uint8 *)"Telugu";
    hint_4gg.len = 6;
    bucketgg = (uintptr *)runtime_mapassign_faststr((runtime_maptype_0 *)&stru_80CFB40, v435, hint_4gg);
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr(bucketgg, (uintptr)srcgg);
    else
      *bucketgg = (uintptr)srcgg;
    srcgh = unicode_Thaana;
    hint_4gh.str = (uint8 *)"Thaana";
    hint_4gh.len = 6;
    bucketgh = (uintptr *)runtime_mapassign_faststr((runtime_maptype_0 *)&stru_80CFB40, v435, hint_4gh);
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr(bucketgh, (uintptr)srcgh);
    else
      *bucketgh = (uintptr)srcgh;
    srcgi = unicode_Thai;
    hint_4gi.str = (uint8 *)"Thai";
    hint_4gi.len = 4;
    bucketgi = (uintptr *)runtime_mapassign_faststr((runtime_maptype_0 *)&stru_80CFB40, v435, hint_4gi);
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr(bucketgi, (uintptr)srcgi);
    else
      *bucketgi = (uintptr)srcgi;
    srcgj = unicode_Tibetan;
    hint_4gj.str = (uint8 *)"Tibetan";
    hint_4gj.len = 7;
    bucketgj = (uintptr *)runtime_mapassign_faststr((runtime_maptype_0 *)&stru_80CFB40, v435, hint_4gj);
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr(bucketgj, (uintptr)srcgj);
    else
      *bucketgj = (uintptr)srcgj;
    srcgk = unicode_Tifinagh;
    hint_4gk.str = (uint8 *)"Tifinagh";
    hint_4gk.len = 8;
    bucketgk = (uintptr *)runtime_mapassign_faststr((runtime_maptype_0 *)&stru_80CFB40, v435, hint_4gk);
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr(bucketgk, (uintptr)srcgk);
    else
      *bucketgk = (uintptr)srcgk;
    srcgl = unicode_Tirhuta;
    hint_4gl.str = (uint8 *)"Tirhuta";
    hint_4gl.len = 7;
    bucketgl = (uintptr *)runtime_mapassign_faststr((runtime_maptype_0 *)&stru_80CFB40, v435, hint_4gl);
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr(bucketgl, (uintptr)srcgl);
    else
      *bucketgl = (uintptr)srcgl;
    srcgm = unicode_Ugaritic;
    hint_4gm.str = (uint8 *)"Ugaritic";
    hint_4gm.len = 8;
    bucketgm = (uintptr *)runtime_mapassign_faststr((runtime_maptype_0 *)&stru_80CFB40, v435, hint_4gm);
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr(bucketgm, (uintptr)srcgm);
    else
      *bucketgm = (uintptr)srcgm;
    srcgn = unicode_Vai;
    hint_4gn.str = (uint8 *)"Vai";
    hint_4gn.len = 3;
    bucketgn = (uintptr *)runtime_mapassign_faststr((runtime_maptype_0 *)&stru_80CFB40, v435, hint_4gn);
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr(bucketgn, (uintptr)srcgn);
    else
      *bucketgn = (uintptr)srcgn;
    srcgo = unicode_Warang_Citi;
    hint_4go.str = (uint8 *)"Warang_Citi";
    hint_4go.len = 11;
    bucketgo = (uintptr *)runtime_mapassign_faststr((runtime_maptype_0 *)&stru_80CFB40, v435, hint_4go);
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr(bucketgo, (uintptr)srcgo);
    else
      *bucketgo = (uintptr)srcgo;
    srcgp = unicode_Yi;
    hint_4gp.str = (uint8 *)"Yi";
    hint_4gp.len = 2;
    bucketgp = (uintptr *)runtime_mapassign_faststr((runtime_maptype_0 *)&stru_80CFB40, v435, hint_4gp);
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
    {
      runtime_writebarrierptr(bucketgp, (uintptr)srcgp);
      runtime_writebarrierptr((uintptr *)&unicode_Scripts, (uintptr)v435);
    }
    else
    {
      *bucketgp = (uintptr)srcgp;
      unicode_Scripts = (map_string__unicode_RangeTable)v435;
    }
    v434 = runtime_makemap((runtime_maptype_0 *)&stru_80CFB40, 34LL, 0, 0);
    srcgq = unicode_ASCII_Hex_Digit;
    hint_4gq.str = (uint8 *)"ASCII_Hex_Digit";
    hint_4gq.len = 15;
    bucketgq = (uintptr *)runtime_mapassign_faststr((runtime_maptype_0 *)&stru_80CFB40, v434, hint_4gq);
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr(bucketgq, (uintptr)srcgq);
    else
      *bucketgq = (uintptr)srcgq;
    srcgr = unicode_Bidi_Control;
    hint_4gr.str = (uint8 *)"Bidi_Control";
    hint_4gr.len = 12;
    bucketgr = (uintptr *)runtime_mapassign_faststr((runtime_maptype_0 *)&stru_80CFB40, v434, hint_4gr);
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr(bucketgr, (uintptr)srcgr);
    else
      *bucketgr = (uintptr)srcgr;
    srcgs = unicode_Dash;
    hint_4gs.str = (uint8 *)"Dash";
    hint_4gs.len = 4;
    bucketgs = (uintptr *)runtime_mapassign_faststr((runtime_maptype_0 *)&stru_80CFB40, v434, hint_4gs);
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr(bucketgs, (uintptr)srcgs);
    else
      *bucketgs = (uintptr)srcgs;
    srcgt = unicode_Deprecated;
    hint_4gt.str = (uint8 *)"Deprecated";
    hint_4gt.len = 10;
    bucketgt = (uintptr *)runtime_mapassign_faststr((runtime_maptype_0 *)&stru_80CFB40, v434, hint_4gt);
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr(bucketgt, (uintptr)srcgt);
    else
      *bucketgt = (uintptr)srcgt;
    srcgu = unicode_Diacritic;
    hint_4gu.str = (uint8 *)"Diacritic";
    hint_4gu.len = 9;
    bucketgu = (uintptr *)runtime_mapassign_faststr((runtime_maptype_0 *)&stru_80CFB40, v434, hint_4gu);
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr(bucketgu, (uintptr)srcgu);
    else
      *bucketgu = (uintptr)srcgu;
    srcgv = unicode_Extender;
    hint_4gv.str = (uint8 *)"Extender";
    hint_4gv.len = 8;
    bucketgv = (uintptr *)runtime_mapassign_faststr((runtime_maptype_0 *)&stru_80CFB40, v434, hint_4gv);
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr(bucketgv, (uintptr)srcgv);
    else
      *bucketgv = (uintptr)srcgv;
    srcgw = unicode_Hex_Digit;
    hint_4gw.str = (uint8 *)"Hex_Digit";
    hint_4gw.len = 9;
    bucketgw = (uintptr *)runtime_mapassign_faststr((runtime_maptype_0 *)&stru_80CFB40, v434, hint_4gw);
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr(bucketgw, (uintptr)srcgw);
    else
      *bucketgw = (uintptr)srcgw;
    srcgx = unicode_Hyphen;
    hint_4gx.str = (uint8 *)"Hyphen";
    hint_4gx.len = 6;
    bucketgx = (uintptr *)runtime_mapassign_faststr((runtime_maptype_0 *)&stru_80CFB40, v434, hint_4gx);
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr(bucketgx, (uintptr)srcgx);
    else
      *bucketgx = (uintptr)srcgx;
    srcgy = unicode_IDS_Binary_Operator;
    hint_4gy.str = (uint8 *)"IDS_Binary_Operator";
    hint_4gy.len = 19;
    bucketgy = (uintptr *)runtime_mapassign_faststr((runtime_maptype_0 *)&stru_80CFB40, v434, hint_4gy);
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr(bucketgy, (uintptr)srcgy);
    else
      *bucketgy = (uintptr)srcgy;
    srcgz = unicode_IDS_Trinary_Operator;
    hint_4gz.str = (uint8 *)"IDS_Trinary_Operator";
    hint_4gz.len = 20;
    bucketgz = (uintptr *)runtime_mapassign_faststr((runtime_maptype_0 *)&stru_80CFB40, v434, hint_4gz);
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr(bucketgz, (uintptr)srcgz);
    else
      *bucketgz = (uintptr)srcgz;
    srcha = unicode_Ideographic;
    hint_4ha.str = (uint8 *)"Ideographic";
    hint_4ha.len = 11;
    bucketha = (uintptr *)runtime_mapassign_faststr((runtime_maptype_0 *)&stru_80CFB40, v434, hint_4ha);
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr(bucketha, (uintptr)srcha);
    else
      *bucketha = (uintptr)srcha;
    srchb = unicode_Join_Control;
    hint_4hb.str = (uint8 *)"Join_Control";
    hint_4hb.len = 12;
    buckethb = (uintptr *)runtime_mapassign_faststr((runtime_maptype_0 *)&stru_80CFB40, v434, hint_4hb);
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr(buckethb, (uintptr)srchb);
    else
      *buckethb = (uintptr)srchb;
    srchc = unicode_Logical_Order_Exception;
    hint_4hc.str = (uint8 *)"Logical_Order_Exception";
    hint_4hc.len = 23;
    buckethc = (uintptr *)runtime_mapassign_faststr((runtime_maptype_0 *)&stru_80CFB40, v434, hint_4hc);
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr(buckethc, (uintptr)srchc);
    else
      *buckethc = (uintptr)srchc;
    srchd = unicode_Noncharacter_Code_Point;
    hint_4hd.str = (uint8 *)"Noncharacter_Code_Point";
    hint_4hd.len = 23;
    buckethd = (uintptr *)runtime_mapassign_faststr((runtime_maptype_0 *)&stru_80CFB40, v434, hint_4hd);
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr(buckethd, (uintptr)srchd);
    else
      *buckethd = (uintptr)srchd;
    srche = unicode_Other_Alphabetic;
    hint_4he.str = (uint8 *)"Other_Alphabetic";
    hint_4he.len = 16;
    buckethe = (uintptr *)runtime_mapassign_faststr((runtime_maptype_0 *)&stru_80CFB40, v434, hint_4he);
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr(buckethe, (uintptr)srche);
    else
      *buckethe = (uintptr)srche;
    srchf = unicode_Other_Default_Ignorable_Code_Point;
    hint_4hf.str = (uint8 *)"Other_Default_Ignorable_Code_Point";
    hint_4hf.len = 34;
    buckethf = (uintptr *)runtime_mapassign_faststr((runtime_maptype_0 *)&stru_80CFB40, v434, hint_4hf);
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr(buckethf, (uintptr)srchf);
    else
      *buckethf = (uintptr)srchf;
    srchg = unicode_Other_Grapheme_Extend;
    hint_4hg.str = (uint8 *)"Other_Grapheme_Extend";
    hint_4hg.len = 21;
    buckethg = (uintptr *)runtime_mapassign_faststr((runtime_maptype_0 *)&stru_80CFB40, v434, hint_4hg);
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr(buckethg, (uintptr)srchg);
    else
      *buckethg = (uintptr)srchg;
    srchh = unicode_Other_ID_Continue;
    hint_4hh.str = (uint8 *)"Other_ID_Continue";
    hint_4hh.len = 17;
    buckethh = (uintptr *)runtime_mapassign_faststr((runtime_maptype_0 *)&stru_80CFB40, v434, hint_4hh);
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr(buckethh, (uintptr)srchh);
    else
      *buckethh = (uintptr)srchh;
    srchi = unicode_Other_ID_Start;
    hint_4hi.str = (uint8 *)"Other_ID_Start";
    hint_4hi.len = 14;
    buckethi = (uintptr *)runtime_mapassign_faststr((runtime_maptype_0 *)&stru_80CFB40, v434, hint_4hi);
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr(buckethi, (uintptr)srchi);
    else
      *buckethi = (uintptr)srchi;
    srchj = unicode_Other_Lowercase;
    hint_4hj.str = (uint8 *)"Other_Lowercase";
    hint_4hj.len = 15;
    buckethj = (uintptr *)runtime_mapassign_faststr((runtime_maptype_0 *)&stru_80CFB40, v434, hint_4hj);
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr(buckethj, (uintptr)srchj);
    else
      *buckethj = (uintptr)srchj;
    srchk = unicode_Other_Math;
    hint_4hk.str = (uint8 *)"Other_Math";
    hint_4hk.len = 10;
    buckethk = (uintptr *)runtime_mapassign_faststr((runtime_maptype_0 *)&stru_80CFB40, v434, hint_4hk);
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr(buckethk, (uintptr)srchk);
    else
      *buckethk = (uintptr)srchk;
    srchl = unicode_Other_Uppercase;
    hint_4hl.str = (uint8 *)"Other_Uppercase";
    hint_4hl.len = 15;
    buckethl = (uintptr *)runtime_mapassign_faststr((runtime_maptype_0 *)&stru_80CFB40, v434, hint_4hl);
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr(buckethl, (uintptr)srchl);
    else
      *buckethl = (uintptr)srchl;
    srchm = unicode_Pattern_Syntax;
    hint_4hm.str = (uint8 *)"Pattern_Syntax";
    hint_4hm.len = 14;
    buckethm = (uintptr *)runtime_mapassign_faststr((runtime_maptype_0 *)&stru_80CFB40, v434, hint_4hm);
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr(buckethm, (uintptr)srchm);
    else
      *buckethm = (uintptr)srchm;
    srchn = unicode_Pattern_White_Space;
    hint_4hn.str = (uint8 *)"Pattern_White_Space";
    hint_4hn.len = 19;
    buckethn = (uintptr *)runtime_mapassign_faststr((runtime_maptype_0 *)&stru_80CFB40, v434, hint_4hn);
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr(buckethn, (uintptr)srchn);
    else
      *buckethn = (uintptr)srchn;
    srcho = unicode_Prepended_Concatenation_Mark;
    hint_4ho.str = (uint8 *)"Prepended_Concatenation_Mark";
    hint_4ho.len = 28;
    bucketho = (uintptr *)runtime_mapassign_faststr((runtime_maptype_0 *)&stru_80CFB40, v434, hint_4ho);
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr(bucketho, (uintptr)srcho);
    else
      *bucketho = (uintptr)srcho;
    srchp = unicode_Quotation_Mark;
    hint_4hp.str = (uint8 *)"Quotation_Mark";
    hint_4hp.len = 14;
    buckethp = (uintptr *)runtime_mapassign_faststr((runtime_maptype_0 *)&stru_80CFB40, v434, hint_4hp);
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr(buckethp, (uintptr)srchp);
    else
      *buckethp = (uintptr)srchp;
    srchq = unicode_Radical;
    hint_4hq.str = (uint8 *)"Radical";
    hint_4hq.len = 7;
    buckethq = (uintptr *)runtime_mapassign_faststr((runtime_maptype_0 *)&stru_80CFB40, v434, hint_4hq);
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr(buckethq, (uintptr)srchq);
    else
      *buckethq = (uintptr)srchq;
    srchr = unicode_Sentence_Terminal;
    hint_4hr.str = (uint8 *)"Sentence_Terminal";
    hint_4hr.len = 17;
    buckethr = (uintptr *)runtime_mapassign_faststr((runtime_maptype_0 *)&stru_80CFB40, v434, hint_4hr);
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr(buckethr, (uintptr)srchr);
    else
      *buckethr = (uintptr)srchr;
    srchs = unicode_Sentence_Terminal;
    hint_4hs.str = (uint8 *)"STerm";
    hint_4hs.len = 5;
    buckeths = (uintptr *)runtime_mapassign_faststr((runtime_maptype_0 *)&stru_80CFB40, v434, hint_4hs);
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr(buckeths, (uintptr)srchs);
    else
      *buckeths = (uintptr)srchs;
    srcht = unicode_Soft_Dotted;
    hint_4ht.str = (uint8 *)"Soft_Dotted";
    hint_4ht.len = 11;
    bucketht = (uintptr *)runtime_mapassign_faststr((runtime_maptype_0 *)&stru_80CFB40, v434, hint_4ht);
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr(bucketht, (uintptr)srcht);
    else
      *bucketht = (uintptr)srcht;
    srchu = unicode_Terminal_Punctuation;
    hint_4hu.str = (uint8 *)"Terminal_Punctuation";
    hint_4hu.len = 20;
    buckethu = (uintptr *)runtime_mapassign_faststr((runtime_maptype_0 *)&stru_80CFB40, v434, hint_4hu);
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr(buckethu, (uintptr)srchu);
    else
      *buckethu = (uintptr)srchu;
    srchv = unicode_Unified_Ideograph;
    hint_4hv.str = (uint8 *)"Unified_Ideograph";
    hint_4hv.len = 17;
    buckethv = (uintptr *)runtime_mapassign_faststr((runtime_maptype_0 *)&stru_80CFB40, v434, hint_4hv);
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr(buckethv, (uintptr)srchv);
    else
      *buckethv = (uintptr)srchv;
    srchw = unicode_Variation_Selector;
    hint_4hw.str = (uint8 *)"Variation_Selector";
    hint_4hw.len = 18;
    buckethw = (uintptr *)runtime_mapassign_faststr((runtime_maptype_0 *)&stru_80CFB40, v434, hint_4hw);
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr(buckethw, (uintptr)srchw);
    else
      *buckethw = (uintptr)srchw;
    srchx = unicode_White_Space;
    hint_4hx.str = (uint8 *)"White_Space";
    hint_4hx.len = 11;
    buckethx = (uintptr *)runtime_mapassign_faststr((runtime_maptype_0 *)&stru_80CFB40, v434, hint_4hx);
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
    {
      runtime_writebarrierptr(buckethx, (uintptr)srchx);
      runtime_writebarrierptr((uintptr *)&unicode_Properties, (uintptr)v434);
    }
    else
    {
      *buckethx = (uintptr)srchx;
      unicode_Properties = (map_string__unicode_RangeTable)v434;
    }
    v433 = runtime_makemap((runtime_maptype_0 *)&stru_80CFB40, 6LL, 0, 0);
    srchy = unicode_foldL;
    hint_4hy.str = (uint8 *)"L";
    hint_4hy.len = 1;
    buckethy = (uintptr *)runtime_mapassign_faststr((runtime_maptype_0 *)&stru_80CFB40, v433, hint_4hy);
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr(buckethy, (uintptr)srchy);
    else
      *buckethy = (uintptr)srchy;
    srchz = unicode_foldLl;
    hint_4hz.str = (uint8 *)"Ll";
    hint_4hz.len = 2;
    buckethz = (uintptr *)runtime_mapassign_faststr((runtime_maptype_0 *)&stru_80CFB40, v433, hint_4hz);
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr(buckethz, (uintptr)srchz);
    else
      *buckethz = (uintptr)srchz;
    srcia = unicode_foldLt;
    hint_4ia.str = (uint8 *)"Lt";
    hint_4ia.len = 2;
    bucketia = (uintptr *)runtime_mapassign_faststr((runtime_maptype_0 *)&stru_80CFB40, v433, hint_4ia);
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr(bucketia, (uintptr)srcia);
    else
      *bucketia = (uintptr)srcia;
    srcib = unicode_foldLu;
    hint_4ib.str = (uint8 *)"Lu";
    hint_4ib.len = 2;
    bucketib = (uintptr *)runtime_mapassign_faststr((runtime_maptype_0 *)&stru_80CFB40, v433, hint_4ib);
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr(bucketib, (uintptr)srcib);
    else
      *bucketib = (uintptr)srcib;
    srcic = unicode_foldM;
    hint_4ic.str = (uint8 *)"M";
    hint_4ic.len = 1;
    bucketic = (uintptr *)runtime_mapassign_faststr((runtime_maptype_0 *)&stru_80CFB40, v433, hint_4ic);
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr(bucketic, (uintptr)srcic);
    else
      *bucketic = (uintptr)srcic;
    srcid = unicode_foldMn;
    hint_4id.str = (uint8 *)"Mn";
    hint_4id.len = 2;
    bucketid = (uintptr *)runtime_mapassign_faststr((runtime_maptype_0 *)&stru_80CFB40, v433, hint_4id);
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
    {
      runtime_writebarrierptr(bucketid, (uintptr)srcid);
      runtime_writebarrierptr((uintptr *)&unicode_FoldCategory, (uintptr)v433);
    }
    else
    {
      *bucketid = (uintptr)srcid;
      unicode_FoldCategory = (map_string__unicode_RangeTable)v433;
    }
    v432 = runtime_makemap((runtime_maptype_0 *)&stru_80CFB40, 3LL, 0, 0);
    srcie = unicode_foldCommon;
    hint_4ie.str = (uint8 *)"Common";
    hint_4ie.len = 6;
    bucketie = (uintptr *)runtime_mapassign_faststr((runtime_maptype_0 *)&stru_80CFB40, v432, hint_4ie);
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr(bucketie, (uintptr)srcie);
    else
      *bucketie = (uintptr)srcie;
    srcif = unicode_foldGreek;
    hint_4if.str = (uint8 *)"Greek";
    hint_4if.len = 5;
    bucketif = (uintptr *)runtime_mapassign_faststr((runtime_maptype_0 *)&stru_80CFB40, v432, hint_4if);
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr(bucketif, (uintptr)srcif);
    else
      *bucketif = (uintptr)srcif;
    srcig = unicode_foldInherited;
    hint_4ig.str = (uint8 *)"Inherited";
    hint_4ig.len = 9;
    bucketig = (uintptr *)runtime_mapassign_faststr((runtime_maptype_0 *)&stru_80CFB40, v432, hint_4ig);
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
    {
      runtime_writebarrierptr(bucketig, (uintptr)srcig);
      runtime_writebarrierptr((uintptr *)&unicode_FoldScript, (uintptr)v432);
    }
    else
    {
      *bucketig = (uintptr)srcig;
      unicode_FoldScript = (map_string__unicode_RangeTable)v432;
    }
    unicode_initdone_ = 2;
  }
}
// 80E0D94: using guessed type char aC;
// 80E0D95: using guessed type char asc_80E0D95;
// 80E0D96: using guessed type char aM_4;
// 80E0D97: using guessed type char aN_1;
// 80E0D98: using guessed type char aP_2;
// 80E0D99: using guessed type char aS_1;
// 80E0D9A: using guessed type char aZ;

//----- (080A4A80) --------------------------------------------------------
reflect_Value_0 __golang reflect_makeMethodValue(string op, reflect_Value_0 v)
{
  _DWORD *p_fn; // eax
  void *ptr; // ecx
  interface_{} v4; // [esp+0h] [ebp-44h]
  reflect_rtype *v5; // [esp+8h] [ebp-3Ch]
  reflect_Value_0 v6; // [esp+8h] [ebp-3Ch]
  reflect_Type_0 have; // [esp+Ch] [ebp-38h]
  reflect_bitVector *methodIndex; // [esp+14h] [ebp-30h]
  __int32 methodIndexa; // [esp+14h] [ebp-30h]
  sync_Pool_0 *v10; // [esp+18h] [ebp-2Ch]
  reflect_rtype *v11; // [esp+18h] [ebp-2Ch]
  reflect_rtype *v12; // [esp+1Ch] [ebp-28h]
  void *v13; // [esp+20h] [ebp-24h]
  uint8 kind; // [esp+27h] [ebp-1Dh]
  reflect_methodValue *fv; // [esp+34h] [ebp-10h]
  uintptr *dst; // [esp+3Ch] [ebp-8h]
  reflect_rtype *data; // [esp+40h] [ebp-4h]
  reflect_Value_0 _r2; // [esp+5Ch] [ebp+18h]

  if ( (v.flag & 0x200) == 0 )
  {
    v4._type = (runtime__type_0 *)&t;
    v4.data = &reflect_statictmp_1;
    runtime_gopanic(v4);
    BUG();
  }
  kind = v.typ->kind;
  have = reflect_Value_Type(v);
  if ( (reflect_Type_0 *)have.tab != &go_itab__reflect_rtype_reflect_Type )
    runtime_panicdottypeI(have.tab, (runtime__type_0 *)&key, (runtime__type_0 *)&stru_80DBAE0);
  data = (reflect_rtype *)have.data;
  reflect_funcLayout((reflect_rtype *)have.data, 0, v5, (uintptr)have.tab, (uintptr)have.data, methodIndex, v10);
  p_fn = runtime_newobject((runtime__type_0 *)&stru_80D6B20);
  fv = (reflect_methodValue *)p_fn;
  *p_fn = reflect_methodValueCall;
  if ( *(_DWORD *)&runtime_writeBarrier.enabled )
  {
    runtime_writebarrierptr(p_fn + 1, methodIndexa);
    p_fn = &fv->fn;
  }
  else
  {
    p_fn[1] = methodIndexa;
  }
  p_fn[2] = (int)v.flag >> 10;
  p_fn[5] = v.flag & 0x1E0 | kind & 0x1F;
  if ( *(_DWORD *)&runtime_writeBarrier.enabled )
  {
    dst = p_fn + 4;
    runtime_writebarrierptr(p_fn + 3, (uintptr)v.typ);
    runtime_writebarrierptr(dst, (uintptr)v.ptr);
    p_fn = &fv->fn;
    ptr = v.ptr;
  }
  else
  {
    p_fn[3] = v.typ;
    ptr = v.ptr;
    p_fn[4] = v.ptr;
  }
  v6.typ = (reflect_rtype *)p_fn[3];
  v6.ptr = ptr;
  v6.flag = p_fn[5];
  reflect_methodReceiver(op, v6, p_fn[2], v11, v12, v13);
  _r2.typ = data;
  _r2.ptr = fv;
  _r2.flag = v.flag & 0x60 | 0x13;
  return _r2;
}
// 80A4B1A: variable 'v5' is possibly undefined
// 80A4B1A: variable 'methodIndex' is possibly undefined
// 80A4B1A: variable 'v10' is possibly undefined
// 80A4B5A: variable 'methodIndexa' is possibly undefined
// 80A4BB4: variable 'v11' is possibly undefined
// 80A4BB4: variable 'v12' is possibly undefined
// 80A4BB4: variable 'v13' is possibly undefined

//----- (080A4C70) --------------------------------------------------------
__int32 __golang reflect_name_tagLen(reflect_name_0 n)
{
  if ( (*n.bytes & 2) != 0 )
    return _byteswap_ushort(*(_WORD *)&n.bytes[_byteswap_ushort(*(_WORD *)(n.bytes + 1)) + 3]);
  else
    return 0;
}

//----- (080A4CE0) --------------------------------------------------------
void __golang reflect_name_tag(reflect_name_0 n, string s)
{
  reflect_name_tagLen(n);
}

//----- (080A4D60) --------------------------------------------------------
string __golang reflect_name_pkgPath(reflect_name_0 n)
{
  char *v1; // [esp+8h] [ebp-14h]
  string s; // [esp+14h] [ebp-8h]
  string _r0; // [esp+24h] [ebp+8h]

  if ( n.bytes && (*n.bytes & 4) != 0 )
  {
    reflect_name_tagLen(n);
    runtime_memmove();
    v1 = (char *)reflect_resolveTypeOff(n.bytes, 0);
    s = 0LL;
    if ( v1 )
    {
      s.str = (uint8 *)(v1 + 3);
      s.len = (unsigned __int8)v1[2] | ((unsigned __int8)v1[1] << 8);
    }
    return s;
  }
  else
  {
    _r0.str = 0;
    _r0.len = 0;
  }
  return _r0;
}

//----- (080A4E80) --------------------------------------------------------
reflect_name_0 __golang reflect_newName(string n, string tag, string pkgPath, bool exported)
{
  __int32 v4; // ebx
  char v5; // bp
  __int32 v6; // ebx
  bool v7; // zf
  interface_{} et; // [esp+0h] [ebp-40h]
  string len[2]; // [esp+4h] [ebp-3Ch]
  string lena[2]; // [esp+4h] [ebp-3Ch]
  runtime_eface_0 cap; // [esp+8h] [ebp-38h]
  interface_{} capa; // [esp+8h] [ebp-38h]
  runtime_eface_0 capb; // [esp+8h] [ebp-38h]
  interface_{} capc; // [esp+8h] [ebp-38h]
  runtime_slice_0 v15; // [esp+Ch] [ebp-34h]
  unsigned __int32 l; // [esp+20h] [ebp-20h]
  string elem; // [esp+30h] [ebp-10h] BYREF
  string v18; // [esp+38h] [ebp-8h] BYREF

  if ( n.len > 0xFFFF )
  {
    lena[0].str = (uint8 *)"reflect.nameFrom: name too long: ";
    lena[0].len = 33;
    lena[1] = n;
    v18 = runtime_concatstring2(0, *(string (*)[2])&lena[0].str);
    runtime_convT2Estring((runtime__type_0 *)&t, &v18, capb);
    runtime_gopanic(capc);
    BUG();
  }
  if ( tag.len > 0xFFFF )
  {
    len[0].str = (uint8 *)"reflect.nameFrom: tag too long: ";
    len[0].len = 32;
    len[1] = tag;
    elem = runtime_concatstring2(0, *(string (*)[2])&len[0].str);
    runtime_convT2Estring((runtime__type_0 *)&t, &elem, cap);
    runtime_gopanic(capa);
    BUG();
  }
  if ( tag.len <= 0 )
  {
    v4 = n.len + 3;
    v5 = exported;
  }
  else
  {
    v4 = tag.len + n.len + 5;
    v5 = exported | 2;
  }
  l = n.len + 3;
  if ( pkgPath.len )
    v5 |= 4u;
  v15 = runtime_makeslice((runtime__type_0 *)&i, v4, v4);
  if ( !v15.len )
    runtime_panicindex();
  *(_BYTE *)v15.array = v5;
  if ( v15.len <= 1u )
    runtime_panicindex();
  *((_BYTE *)v15.array + 1) = BYTE1(n.len);
  if ( v15.len <= 2u )
    runtime_panicindex();
  *((_BYTE *)v15.array + 2) = n.len;
  runtime_memmove();
  if ( tag.len <= 0 )
  {
    v7 = pkgPath.len == 0;
  }
  else
  {
    if ( l > v15.len )
      runtime_panicslice();
    v6 = l & ((int)(l - v15.cap) >> 31);
    if ( v15.len == l )
      runtime_panicindex();
    *((_BYTE *)v15.array + v6) = BYTE1(tag.len);
    if ( v15.len - l <= 1 )
      runtime_panicindex();
    *((_BYTE *)v15.array + v6 + 1) = tag.len;
    runtime_memmove();
    v7 = pkgPath.len == 0;
  }
  if ( !v7 )
  {
    et._type = (runtime__type_0 *)&t;
    et.data = &reflect_statictmp_2;
    runtime_gopanic(et);
    BUG();
  }
  return (reflect_name_0)v15.array;
}
// 80A50A9: variable 'cap' is possibly undefined
// 80A50BD: variable 'capa' is possibly undefined
// 80A510F: variable 'capb' is possibly undefined
// 80A5123: variable 'capc' is possibly undefined

//----- (080A5140) --------------------------------------------------------
string __golang reflect_Kind_String(reflect_Kind k)
{
  string a[2]; // [esp+4h] [ebp-18h]

  if ( (int)k >= reflect_kindNames.len )
  {
    a[0].str = (uint8 *)"kind";
    a[0].len = 4;
    a[1] = strconv_Itoa(k);
    return runtime_concatstring2(0, *(string (*)[2])&a[0].str);
  }
  else
  {
    if ( k >= reflect_kindNames.len )
      runtime_panicindex();
    return reflect_kindNames.array[k];
  }
}

//----- (080A51E0) --------------------------------------------------------
reflect_nameOff __golang reflect_resolveReflectName(reflect_name_0 n)
{
  return reflect_addReflectOff(n.bytes);
}

//----- (080A5220) --------------------------------------------------------
reflect_name_0 __golang reflect___ptr_rtype__nameOff(reflect_rtype *t, reflect_nameOff off)
{
  return (reflect_name_0)reflect_resolveNameOff(t, off);
}

//----- (080A5260) --------------------------------------------------------
reflect_rtype *__golang reflect___ptr_rtype__typeOff(reflect_rtype *t, reflect_typeOff off)
{
  return (reflect_rtype *)reflect_resolveTypeOff(t, off);
}

//----- (080A52A0) --------------------------------------------------------
void *__golang reflect___ptr_rtype__textOff(reflect_rtype *t, reflect_textOff off)
{
  return reflect_resolveTextOff(t, off);
}

//----- (080A52E0) --------------------------------------------------------
reflect_uncommonType *__golang reflect___ptr_rtype__uncommon(reflect_rtype *t)
{
  unsigned int v1; // ecx

  if ( (t->tflag & 1) == 0 )
    return 0;
  v1 = t->kind & 0x1F;
  if ( v1 > 0x14 )
  {
    if ( v1 > 0x16 )
    {
      if ( v1 == 23 )
      {
        return (reflect_uncommonType *)&t[1].ptrdata;
      }
      else
      {
        if ( v1 != 25 )
          return (reflect_uncommonType *)&t[1];
        return (reflect_uncommonType *)&t[1].alg;
      }
    }
    else if ( v1 == 21 )
    {
      return (reflect_uncommonType *)&t[1].str;
    }
    else
    {
      return (reflect_uncommonType *)&t[1].ptrdata;
    }
  }
  else if ( v1 > 0x12 )
  {
    if ( v1 == 19 )
      return (reflect_uncommonType *)&t[1].ptrdata;
    else
      return (reflect_uncommonType *)&t[1].alg;
  }
  else if ( v1 == 17 )
  {
    return (reflect_uncommonType *)&t[1].tflag;
  }
  else
  {
    if ( v1 != 18 )
      return (reflect_uncommonType *)&t[1];
    return (reflect_uncommonType *)&t[1].hash;
  }
}

//----- (080A53A0) --------------------------------------------------------
string __golang reflect___ptr_rtype__String(reflect_rtype *t)
{
  reflect_name_0 v1; // [esp+8h] [ebp-Ch]
  string s; // [esp+Ch] [ebp-8h]
  string _r0; // [esp+1Ch] [ebp+8h]

  v1.bytes = reflect___ptr_rtype__nameOff(t, t->str).bytes;
  s = 0LL;
  if ( v1.bytes )
  {
    s.str = v1.bytes + 3;
    s.len = v1.bytes[2] | (v1.bytes[1] << 8);
  }
  if ( (t->tflag & 2) == 0 )
    return s;
  if ( !s.len )
    runtime_panicslice();
  _r0.str = &s.str[((1 - s.len) >> 31) & 1];
  _r0.len = s.len - 1;
  return _r0;
}

//----- (080A5450) --------------------------------------------------------
uintptr __golang reflect___ptr_rtype__Size(reflect_rtype *t)
{
  return t->size;
}

//----- (080A5480) --------------------------------------------------------
__int32 __golang reflect___ptr_rtype__Bits(reflect_rtype *t)
{
  __int32 len; // eax
  uint8 *str; // ecx
  interface_{} buf; // [esp+0h] [ebp-24h]
  string a[2]; // [esp+4h] [ebp-20h]
  runtime_eface_0 a_4; // [esp+8h] [ebp-1Ch]
  interface_{} a_4a; // [esp+8h] [ebp-1Ch]
  string elem; // [esp+1Ch] [ebp-8h] BYREF

  if ( !t )
  {
    buf._type = (runtime__type_0 *)&::t;
    buf.data = &reflect_statictmp_3;
    runtime_gopanic(buf);
    BUG();
  }
  if ( (t->kind & 0x1Fu) - 2 > 0xE )
  {
    a[0] = reflect___ptr_rtype__String(t);
    len = a[0].len;
    str = a[0].str;
    a[0].str = (uint8 *)"reflect: Bits of non-arithmetic Type ";
    a[0].len = 37;
    a[1] = (string)__PAIR64__(len, (unsigned int)str);
    elem = runtime_concatstring2(0, *(string (*)[2])&a[0].str);
    runtime_convT2Estring((runtime__type_0 *)&::t, &elem, a_4);
    runtime_gopanic(a_4a);
    BUG();
  }
  return 8 * t->size;
}
// 80A5518: variable 'a_4' is possibly undefined
// 80A552C: variable 'a_4a' is possibly undefined

//----- (080A5560) --------------------------------------------------------
__int32 __golang reflect___ptr_rtype__Align(reflect_rtype *t)
{
  return t->align;
}

//----- (080A5590) --------------------------------------------------------
__int32 __golang reflect___ptr_rtype__FieldAlign(reflect_rtype *t)
{
  return t->fieldAlign;
}

//----- (080A55C0) --------------------------------------------------------
reflect_Kind __golang reflect___ptr_rtype__Kind(reflect_rtype *t)
{
  return t->kind & 0x1F;
}

//----- (080A55F0) --------------------------------------------------------
reflect_rtype *__golang reflect___ptr_rtype__common(reflect_rtype *t)
{
  return t;
}

//----- (080A5620) --------------------------------------------------------
__reflect_method __golang reflect___ptr_rtype__exportedMethods(reflect_rtype *t)
{
  reflect_nameOff *v1; // ecx
  __int32 mcount; // eax
  __int32 i; // ebx
  char v4; // al
  int v5; // eax
  int v6; // ecx
  __int32 v7; // edx
  __int32 v8; // ebx
  reflect_nameOff *v9; // ebp
  __int32 v10; // eax
  char *v11; // ebx
  int v12; // eax
  _BYTE key[28]; // [esp+4h] [ebp-58h]
  reflect_uncommonType *keya; // [esp+4h] [ebp-58h]
  runtime_slice_0 keyb; // [esp+4h] [ebp-58h]
  runtime__type_0 *have; // [esp+14h] [ebp-48h]
  __reflect_method *v17; // [esp+18h] [ebp-44h]
  __int32 methods_cap; // [esp+20h] [ebp-3Ch]
  reflect_textOff m_tfn; // [esp+24h] [ebp-38h]
  reflect_nameOff m_name; // [esp+28h] [ebp-34h]
  reflect_typeOff m_mtyp; // [esp+2Ch] [ebp-30h]
  reflect_textOff m_ifn; // [esp+30h] [ebp-2Ch]
  __int32 v23; // [esp+34h] [ebp-28h]
  __int32 v24; // [esp+38h] [ebp-24h]
  __int32 cap; // [esp+3Ch] [ebp-20h]
  char *old; // [esp+44h] [ebp-18h]
  reflect_nameOff *old_4; // [esp+48h] [ebp-14h]
  reflect_nameOff *old_8; // [esp+4Ch] [ebp-10h]
  int elem[3]; // [esp+50h] [ebp-Ch] BYREF
  __reflect_method _r0; // [esp+64h] [ebp+8h]

  *(_DWORD *)key = &::key;
  *(_DWORD *)&key[4] = t;
  sync___ptr_Map__Load(&reflect_methodCache, *(interface_{} *)key, *(interface_{} *)&key[8], key[16]);
  if ( key[16] )
  {
    if ( *(const runtime__type_0 **)&key[8] != &stru_80C9840 )
      runtime_panicdottypeE(
        *(runtime__type_0 **)&key[8],
        (runtime__type_0 *)&stru_80C9840,
        (runtime__type_0 *)&stru_80CECA0);
    return *(__reflect_method *)*(_DWORD *)&key[12];
  }
  else
  {
    keya = reflect___ptr_rtype__uncommon(t);
    if ( keya )
    {
      v1 = (reflect_nameOff *)((char *)&keya->pkgPath + keya->moff);
      mcount = keya->mcount;
      old_8 = v1;
      cap = mcount;
      for ( i = 0; i < mcount; ++i )
      {
        old_4 = v1;
        *(reflect_name_0 *)&key[4] = reflect___ptr_rtype__nameOff(t, *v1);
        if ( (**(_BYTE **)&key[4] & 1) == 0 )
        {
          v4 = 0;
          goto LABEL_8;
        }
        v1 = old_4 + 4;
        mcount = cap;
      }
      v4 = 1;
LABEL_8:
      if ( v4 )
      {
        v5 = (int)old_8;
        v6 = cap;
      }
      else
      {
        *(runtime_slice_0 *)&key[8] = runtime_makeslice((runtime__type_0 *)&stru_80D6AA0, 0, cap);
        v5 = *(_DWORD *)&key[8];
        v6 = *(_DWORD *)&key[12];
        v7 = *(_DWORD *)&key[16];
        v8 = 0;
        v9 = old_8;
        while ( v8 < cap )
        {
          v24 = v8;
          old = (char *)v5;
          methods_cap = v6;
          v23 = v7;
          m_tfn = v9[3];
          m_name = *v9;
          m_ifn = v9[2];
          m_mtyp = v9[1];
          *(reflect_name_0 *)&key[4] = reflect___ptr_rtype__nameOff(t, *v9);
          if ( (**(_BYTE **)&key[4] & 1) != 0 )
          {
            v10 = methods_cap;
            v6 = methods_cap + 1;
            v7 = v23;
            if ( methods_cap + 1 > v23 )
            {
              keyb.array = old;
              *(_QWORD *)&keyb.len = __PAIR64__(v23, methods_cap);
              *(runtime_slice_0 *)&key[16] = runtime_growslice((runtime__type_0 *)&stru_80D6AA0, keyb, methods_cap + 1);
              v11 = *(char **)&key[16];
              v7 = *(_DWORD *)&key[24];
              v6 = *(_DWORD *)&key[20] + 1;
              v10 = methods_cap;
            }
            else
            {
              v11 = old;
            }
            v12 = 16 * v10;
            *(_DWORD *)&v11[v12] = m_name;
            *(_DWORD *)&v11[v12 + 4] = m_mtyp;
            *(_DWORD *)&v11[v12 + 8] = m_ifn;
            *(_DWORD *)&v11[v12 + 12] = m_tfn;
          }
          else
          {
            v11 = old;
            v6 = methods_cap;
            v7 = v23;
          }
          v9 += 4;
          v5 = (int)v11;
          v8 = v24 + 1;
        }
      }
      elem[0] = v5;
      elem[1] = v6;
      elem[2] = v6;
      runtime_convT2Eslice((runtime__type_0 *)&stru_80C9840, elem, *(runtime_eface_0 *)&key[4]);
      *(_QWORD *)&key[8] = *(_QWORD *)&key[4];
      *(_DWORD *)key = &::key;
      *(_DWORD *)&key[4] = t;
      sync___ptr_Map__LoadOrStore(
        &reflect_methodCache,
        *(interface_{} *)key,
        *(interface_{} *)&key[8],
        *(interface_{} *)&key[16],
        key[24]);
      if ( have != &stru_80C9840 )
        runtime_panicdottypeE(have, (runtime__type_0 *)&stru_80C9840, (runtime__type_0 *)&stru_80CECA0);
      return *v17;
    }
    else
    {
      _r0.array = 0;
      _r0.len = 0;
      _r0.cap = 0;
    }
  }
  return _r0;
}
// 80A5620: could not find valid save-restore pair for esi
// 80A5654: variable 'key' is possibly undefined
// 80A5878: variable 'have' is possibly undefined
// 80A5882: variable 'v17' is possibly undefined

//----- (080A5930) --------------------------------------------------------
__int32 __golang reflect___ptr_rtype__NumMethod(reflect_rtype *t)
{
  __reflect_method v1; // [esp+4h] [ebp-Ch]

  if ( (t->kind & 0x1F) == 20 )
    return t[1].hash;
  if ( (t->tflag & 1) == 0 )
    return 0;
  v1 = reflect___ptr_rtype__exportedMethods(t);
  return v1.len;
}

//----- (080A5990) --------------------------------------------------------
void __golang reflect___ptr_rtype__Method(reflect_rtype *t, __int32 i, reflect_Method_0 m)
{
  int size_low; // ecx
  __int32 cap; // eax
  int v5; // edx
  __int64 v6; // rcx
  uintptr *v7; // edx
  int v8; // edi
  uintptr *v9; // ebp
  int v10; // edi
  uintptr v11; // edi
  __int32 v12; // edx
  uintptr *v13; // eax
  unsigned __int16 size; // di
  unsigned int v15; // ebp
  __int32 len; // ecx
  reflect_Type_0 *array; // edx
  __int32 v18; // eax
  int v19; // ebp
  char *v20; // ebp
  unsigned __int16 v21; // di
  unsigned int v22; // esi
  signed int v23; // esi
  uintptr *v24; // ebx
  signed int v25; // ebp
  uintptr v26; // edi
  __int32 v27; // esi
  uintptr *p_data; // ecx
  bool variadic; // al
  __reflect_Type in; // [esp+0h] [ebp-CCh]
  interface_{} ina; // [esp+0h] [ebp-CCh]
  unsigned __int64 in_4; // [esp+4h] [ebp-C8h]
  _BYTE in_4a[20]; // [esp+4h] [ebp-C8h]
  runtime_slice_0 in_4b; // [esp+4h] [ebp-C8h]
  runtime_slice_0 in_4c; // [esp+4h] [ebp-C8h]
  reflect_Method_0 in_8; // [esp+8h] [ebp-C4h]
  reflect_name_0 in_8a; // [esp+8h] [ebp-C4h]
  reflect_rtype *in_8c; // [esp+8h] [ebp-C4h]
  void *in_8b; // [esp+8h] [ebp-C4h]
  runtime_slice_0 old; // [esp+Ch] [ebp-C0h]
  runtime_slice_0 olda; // [esp+Ch] [ebp-C0h]
  runtime_slice_0 old_8a; // [esp+14h] [ebp-B8h]
  runtime_slice_0 old_8b; // [esp+14h] [ebp-B8h]
  runtime_slice_0 old_8; // [esp+14h] [ebp-B8h]
  __int32 _r0_len; // [esp+30h] [ebp-9Ch]
  reflect_textOff p_tfn; // [esp+34h] [ebp-98h]
  reflect_typeOff p_mtyp; // [esp+38h] [ebp-94h]
  __int32 out_len; // [esp+3Ch] [ebp-90h]
  __int32 out_lena; // [esp+3Ch] [ebp-90h]
  __int32 out_cap; // [esp+40h] [ebp-8Ch]
  __int32 in_len; // [esp+44h] [ebp-88h]
  __int32 in_cap; // [esp+48h] [ebp-84h]
  __int32 in_capa; // [esp+48h] [ebp-84h]
  __int32 v54; // [esp+4Ch] [ebp-80h]
  __int32 v55; // [esp+50h] [ebp-7Ch]
  __int32 v56; // [esp+54h] [ebp-78h]
  int j; // [esp+58h] [ebp-74h]
  int v58; // [esp+5Ch] [ebp-70h]
  int v59; // [esp+5Ch] [ebp-70h]
  reflect_rtype *ret; // [esp+68h] [ebp-64h]
  reflect_Type_0 *out_ptr; // [esp+6Ch] [ebp-60h]
  runtime_itab_0 *mt_itab; // [esp+70h] [ebp-5Ch]
  reflect_Type_0 *in_ptr; // [esp+78h] [ebp-54h]
  reflect_rtype *arg; // [esp+7Ch] [ebp-50h]
  int v65; // [esp+80h] [ebp-4Ch] BYREF
  uintptr *dst; // [esp+84h] [ebp-48h]
  __reflect_Type out; // [esp+88h] [ebp-44h]
  uintptr *v68; // [esp+94h] [ebp-38h]
  reflect_rtype *v69; // [esp+98h] [ebp-34h]
  string s; // [esp+9Ch] [ebp-30h]

  while ( (unsigned int)&v65 <= *(_DWORD *)(*(_DWORD *)(__readgsdword(0) - 4) + 8) )
    runtime_morestack_noctxt();
  ((void (*)(void))loc_808FD86)();
  if ( (t->kind & 0x1F) == 20 )
  {
    reflect___ptr_interfaceType__Method((reflect_interfaceType *)t, i, in_8);
    ((void (*)(void))loc_809023C)();
    ((void (*)(void))loc_809023C)();
  }
  else
  {
    in_4 = COERCE_UNSIGNED_INT64(COERCE_LONG_DOUBLE(COERCE_LONG_DOUBLE(reflect___ptr_rtype__exportedMethods(t))));
    if ( i < 0 || i >= SHIDWORD(in_4) )
    {
      ina._type = (runtime__type_0 *)&::t;
      ina.data = &reflect_statictmp_4;
      runtime_gopanic(ina);
      BUG();
    }
    p_tfn = *(_DWORD *)(in_4 + 16 * i + 12);
    p_mtyp = *(_DWORD *)(in_4 + 16 * i + 4);
    in_8a.bytes = reflect___ptr_rtype__nameOff(t, *(_DWORD *)(in_4 + 16 * i)).bytes;
    s.str = 0;
    s.len = 0;
    if ( in_8a.bytes )
    {
      s.str = in_8a.bytes + 3;
      s.len = in_8a.bytes[2] | (in_8a.bytes[1] << 8);
    }
    in_8c = reflect___ptr_rtype__typeOff(t, p_mtyp);
    size_low = LOWORD(in_8c[1].size);
    v69 = in_8c;
    *(runtime_slice_0 *)&in_4a[8] = runtime_makeslice((runtime__type_0 *)&stru_80DBAE0, 0, size_low + 1);
    cap = *(_DWORD *)&in_4a[16];
    v5 = *(_DWORD *)&in_4a[12];
    v6 = *(_QWORD *)&in_4a[8] + 0x100000000LL;
    if ( *(_DWORD *)&in_4a[12] + 1 > *(int *)&in_4a[16] )
    {
      v59 = *(_DWORD *)&in_4a[12];
      *(_DWORD *)in_4a = *(_DWORD *)&in_4a[8];
      *(_QWORD *)&in_4a[4] = *(_QWORD *)&in_4a[12];
      old_8 = runtime_growslice((runtime__type_0 *)&stru_80DBAE0, *(runtime_slice_0 *)in_4a, *(_DWORD *)&in_4a[12] + 1);
      v6 = *(_QWORD *)&old_8.array + 0x100000000LL;
      cap = old_8.cap;
      v5 = v59;
    }
    *(_DWORD *)(v6 + 8 * v5) = &go_itab__reflect_rtype_reflect_Type;
    v7 = (uintptr *)(v6 + 8 * v5 + 4);
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
    {
      v65 = v6;
      in_capa = cap;
      runtime_writebarrierptr(v7, (uintptr)t);
      cap = in_capa;
      LODWORD(v6) = v65;
    }
    else
    {
      *v7 = (uintptr)t;
    }
    if ( (v69->tflag & 1) != 0 )
      v8 = 52;
    else
      v8 = 36;
    v9 = (uintptr *)((char *)&v69->size + v8);
    v10 = LOWORD(v69[1].size);
    v58 = v10;
    for ( j = 0; ; ++j )
    {
      in_len = HIDWORD(v6);
      if ( j >= v10 )
        break;
      v68 = v9;
      v11 = *v9;
      v12 = HIDWORD(v6) + 1;
      if ( HIDWORD(v6) + 1 > cap )
      {
        arg = (reflect_rtype *)*v9;
        in_4b.array = (void *)v6;
        *(_QWORD *)&in_4b.len = __PAIR64__(cap, HIDWORD(v6));
        old_8a = runtime_growslice((runtime__type_0 *)&stru_80DBAE0, in_4b, HIDWORD(v6) + 1);
        LODWORD(v6) = old_8a.array;
        v9 = v68;
        v11 = (uintptr)arg;
        v12 = old_8a.len + 1;
        cap = old_8a.cap;
      }
      in_cap = cap;
      *(_DWORD *)(v6 + 8 * HIDWORD(v6)) = &go_itab__reflect_rtype_reflect_Type;
      v13 = (uintptr *)(v6 + 8 * HIDWORD(v6) + 4);
      if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      {
        in_ptr = (reflect_Type_0 *)v6;
        v56 = v12;
        runtime_writebarrierptr(v13, v11);
        LODWORD(v6) = in_ptr;
        v12 = v56;
        v9 = v68;
      }
      else
      {
        *v13 = v11;
      }
      ++v9;
      v10 = v58;
      cap = in_cap;
      HIDWORD(v6) = v12;
    }
    v55 = cap;
    size = v69[1].size;
    v15 = (unsigned __int16)(size + (HIWORD(v69[1].size) & 0x7FFF));
    if ( size > v15 )
      runtime_panicslice();
    out.cap = v6;
    old = runtime_makeslice((runtime__type_0 *)&stru_80DBAE0, 0, v15 - size);
    len = old.len;
    array = (reflect_Type_0 *)old.array;
    v18 = old.cap;
    if ( (v69->tflag & 1) != 0 )
      v19 = 52;
    else
      v19 = 36;
    v20 = (char *)v69 + v19;
    v21 = v69[1].size;
    v22 = (unsigned __int16)(v21 + (HIWORD(v69[1].size) & 0x7FFF));
    if ( v21 > v22 )
      runtime_panicslice();
    v23 = v22 - v21;
    _r0_len = v23;
    v24 = (uintptr *)&v20[(4 * v21) & ((v21 - 0x100000) >> 31)];
    v25 = 0;
    while ( 1 )
    {
      out_len = len;
      if ( v25 >= v23 )
        break;
      out.len = (__int32)v24;
      v26 = *v24;
      v27 = len + 1;
      if ( len + 1 > v18 )
      {
        ret = (reflect_rtype *)*v24;
        in_4c.array = array;
        *(_QWORD *)&in_4c.len = __PAIR64__(v18, len);
        old_8b = runtime_growslice((runtime__type_0 *)&stru_80DBAE0, in_4c, len + 1);
        array = (reflect_Type_0 *)old_8b.array;
        v27 = old_8b.len + 1;
        v24 = (uintptr *)out.len;
        v26 = (uintptr)ret;
        v18 = old_8b.cap;
        len = out_len;
      }
      out_lena = v27;
      out_cap = v18;
      array[len].tab = (runtime_itab_0 *)&go_itab__reflect_rtype_reflect_Type;
      p_data = (uintptr *)&array[len].data;
      if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      {
        out_ptr = array;
        runtime_writebarrierptr(p_data, v26);
        array = out_ptr;
        v24 = (uintptr *)out.len;
      }
      else
      {
        *p_data = v26;
      }
      ++v24;
      ++v25;
      v23 = _r0_len;
      len = out_lena;
      v18 = out_cap;
    }
    out.array = array;
    v54 = v18;
    variadic = reflect___ptr_rtype__IsVariadic(v69);
    in.array = (reflect_Type_0 *)out.cap;
    *(_QWORD *)&in.len = __PAIR64__(v55, in_len);
    olda.array = out.array;
    *(_QWORD *)&olda.len = __PAIR64__(v54, out_len);
    mt_itab = reflect_FuncOf(in, (__reflect_Type)olda, variadic).tab;
    dst = (uintptr *)runtime_newobject((runtime__type_0 *)&x);
    in_8b = reflect___ptr_rtype__textOff(t, p_tfn);
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr(dst, (uintptr)in_8b);
    else
      *dst = (uintptr)in_8b;
    if ( mt_itab != (runtime_itab_0 *)&go_itab__reflect_rtype_reflect_Type )
      runtime_panicdottypeI(mt_itab, (runtime__type_0 *)&key, (runtime__type_0 *)&stru_80DBAE0);
  }
}
// 80A5D3E: conditional instruction was optimized away because esi.4<10000u
// 80A59DF: variable 'in_8' is possibly undefined

//----- (080A6060) --------------------------------------------------------
void __golang reflect___ptr_rtype__MethodByName(reflect_rtype *t, string name, reflect_Method_0 m, bool ok)
{
  reflect_uncommonType *v4; // eax
  char *v5; // ecx
  unsigned int mcount; // edx
  __int32 v7; // ebx
  reflect_rtype *v8; // [esp+0h] [ebp-CCh]
  reflect_uncommonType *off; // [esp+4h] [ebp-C8h]
  _BYTE v10[44]; // [esp+8h] [ebp-C4h]
  bool v11; // [esp+34h] [ebp-98h]
  unsigned int v12; // [esp+40h] [ebp-8Ch]
  char *v13; // [esp+44h] [ebp-88h]
  reflect_uncommonType *v14; // [esp+48h] [ebp-84h]
  char v15; // [esp+80h] [ebp-4Ch] BYREF

  while ( (unsigned int)&v15 <= *(_DWORD *)(*(_DWORD *)(__readgsdword(0) - 4) + 8) )
    runtime_morestack_noctxt();
  ((void (*)(void))loc_808FD86)();
  if ( (t->kind & 0x1F) == 20 )
  {
    ((void (*)(void))loc_808FD86)();
    reflect___ptr_interfaceType__MethodByName((reflect_interfaceType *)t, name, *(reflect_Method_0 *)&v10[4], v11);
    ((void (*)(void))loc_809023C)();
    ((void (*)(void))loc_809023C)();
    ((void (*)(void))loc_809023C)();
  }
  else
  {
    off = reflect___ptr_rtype__uncommon(t);
    v4 = off;
    if ( off )
    {
      v5 = (char *)off + off->moff;
      mcount = off->mcount;
      v14 = off;
      v13 = v5;
      v12 = mcount;
      v7 = 0;
      while ( v7 < v4->mcount )
      {
        if ( v7 >= mcount )
          runtime_panicindex();
        *(reflect_name_0 *)v10 = reflect___ptr_rtype__nameOff(t, *(_DWORD *)&v5[16 * v7]);
        if ( (**(_BYTE **)v10 & 1) != 0
          && name.len == (*(unsigned __int8 *)(*(_DWORD *)v10 + 2) | (*(unsigned __int8 *)(*(_DWORD *)v10 + 1) << 8)) )
        {
          v8 = (reflect_rtype *)(*(_DWORD *)v10 + 3);
          *(string *)v10 = name;
          runtime_eqstring();
          if ( v10[8] )
          {
            reflect___ptr_rtype__Method(t, v7, *(reflect_Method_0 *)v10);
            ((void (*)(void))loc_809023C)();
            ((void (*)(void))loc_809023C)();
            return;
          }
        }
        ++v7;
        v4 = v14;
        v5 = v13;
        mcount = v12;
      }
      ((void (__golang *)(reflect_rtype *))loc_809023C)(v8);
    }
    else
    {
      ((void (*)(void))loc_809023C)();
    }
  }
}
// 80A619D: variable 'v10' is possibly undefined
// 80A6207: variable 'v8' is possibly undefined
// 80A6265: variable 'v11' is possibly undefined

//----- (080A62D0) --------------------------------------------------------
string __golang reflect___ptr_rtype__PkgPath(reflect_rtype *t)
{
  reflect_uncommonType *off; // [esp+4h] [ebp-10h]
  reflect_name_0 v2; // [esp+8h] [ebp-Ch]
  string s; // [esp+Ch] [ebp-8h]
  string _r0; // [esp+1Ch] [ebp+8h]

  if ( (t->tflag & 4) != 0 )
  {
    off = reflect___ptr_rtype__uncommon(t);
    if ( off )
    {
      v2.bytes = reflect___ptr_rtype__nameOff(t, off->pkgPath).bytes;
      s = 0LL;
      if ( v2.bytes )
      {
        s.str = v2.bytes + 3;
        s.len = v2.bytes[2] | (v2.bytes[1] << 8);
      }
      return s;
    }
    else
    {
      _r0.str = 0;
      _r0.len = 0;
    }
  }
  else
  {
    _r0.str = 0;
    _r0.len = 0;
  }
  return _r0;
}

//----- (080A6390) --------------------------------------------------------
string __golang reflect___ptr_rtype__Name(reflect_rtype *t)
{
  __int32 i; // edx
  unsigned __int32 v2; // edx
  string v3; // [esp+4h] [ebp-8h]
  string _r0; // [esp+14h] [ebp+8h]

  if ( (t->tflag & 4) != 0 )
  {
    v3 = reflect___ptr_rtype__String(t);
    for ( i = v3.len - 1; i >= 0; --i )
    {
      if ( (unsigned int)i >= v3.len )
        runtime_panicindex();
      if ( v3.str[i] == 46 )
        break;
    }
    v2 = i + 1;
    if ( v2 > v3.len )
      runtime_panicslice();
    _r0.str = &v3.str[((int)(v2 - v3.len) >> 31) & v2];
    _r0.len = v3.len - v2;
  }
  else
  {
    _r0.str = 0;
    _r0.len = 0;
  }
  return _r0;
}

//----- (080A6430) --------------------------------------------------------
reflect_ChanDir __golang reflect___ptr_rtype__ChanDir(reflect_rtype *t)
{
  interface_{} e; // [esp+0h] [ebp-8h]

  if ( (t->kind & 0x1F) != 18 )
  {
    e._type = (runtime__type_0 *)&::t;
    e.data = &reflect_statictmp_7;
    runtime_gopanic(e);
    BUG();
  }
  return t[1].ptrdata;
}

//----- (080A6490) --------------------------------------------------------
bool __golang reflect___ptr_rtype__IsVariadic(reflect_rtype *t)
{
  interface_{} e; // [esp+0h] [ebp-8h]

  if ( (t->kind & 0x1F) != 19 )
  {
    e._type = (runtime__type_0 *)&::t;
    e.data = &reflect_statictmp_8;
    runtime_gopanic(e);
    BUG();
  }
  return (t[1].size & 0x80000000) != 0;
}

//----- (080A64F0) --------------------------------------------------------
reflect_Type_0 __golang reflect___ptr_rtype__Elem(reflect_rtype *t)
{
  unsigned int v1; // ecx
  void *size; // eax
  runtime_itab_0 *v3; // ecx
  void *v4; // eax
  runtime_itab_0 *v5; // ecx
  void *ptrdata; // eax
  runtime_itab_0 *v7; // ecx
  void *v8; // eax
  runtime_itab_0 *v9; // ecx
  void *v10; // eax
  runtime_itab_0 *v11; // ecx
  interface_{} e; // [esp+0h] [ebp-8h]
  reflect_Type_0 _r0; // [esp+10h] [ebp+8h]

  v1 = t->kind & 0x1F;
  if ( v1 <= 0x12 )
  {
    if ( v1 == 17 )
    {
      size = (void *)t[1].size;
      if ( size )
      {
        v3 = (runtime_itab_0 *)&go_itab__reflect_rtype_reflect_Type;
      }
      else
      {
        size = 0;
        v3 = 0;
      }
      _r0.tab = v3;
      _r0.data = size;
      return _r0;
    }
    if ( v1 == 18 )
    {
      v4 = (void *)t[1].size;
      if ( v4 )
      {
        v5 = (runtime_itab_0 *)&go_itab__reflect_rtype_reflect_Type;
      }
      else
      {
        v5 = 0;
        v4 = 0;
      }
      _r0.tab = v5;
      _r0.data = v4;
      return _r0;
    }
LABEL_27:
    e._type = (runtime__type_0 *)&::t;
    e.data = &reflect_statictmp_9;
    runtime_gopanic(e);
    BUG();
  }
  switch ( v1 )
  {
    case 0x15u:
      ptrdata = (void *)t[1].ptrdata;
      if ( ptrdata )
      {
        v7 = (runtime_itab_0 *)&go_itab__reflect_rtype_reflect_Type;
      }
      else
      {
        ptrdata = 0;
        v7 = 0;
      }
      _r0.tab = v7;
      _r0.data = ptrdata;
      break;
    case 0x16u:
      v8 = (void *)t[1].size;
      if ( v8 )
      {
        v9 = (runtime_itab_0 *)&go_itab__reflect_rtype_reflect_Type;
      }
      else
      {
        v8 = 0;
        v9 = 0;
      }
      _r0.tab = v9;
      _r0.data = v8;
      break;
    case 0x17u:
      v10 = (void *)t[1].size;
      if ( v10 )
      {
        v11 = (runtime_itab_0 *)&go_itab__reflect_rtype_reflect_Type;
      }
      else
      {
        v10 = 0;
        v11 = 0;
      }
      _r0.tab = v11;
      _r0.data = v10;
      break;
    default:
      goto LABEL_27;
  }
  return _r0;
}

//----- (080A6600) --------------------------------------------------------
reflect_StructField_0 __golang reflect___ptr_rtype__Field(reflect_rtype *t, __int32 i)
{
  interface_{} e; // [esp+0h] [ebp-70h]
  reflect_StructField_0 v3; // [esp+8h] [ebp-68h]
  reflect_StructField_0 _r1; // [esp+7Ch] [ebp+Ch]

  ((void (*)(void))loc_808FD83)();
  if ( (t->kind & 0x1F) != 25 )
  {
    e._type = (runtime__type_0 *)&::t;
    e.data = &reflect_statictmp_10;
    runtime_gopanic(e);
    BUG();
  }
  reflect___ptr_structType__Field((reflect_structType *)t, i, v3);
  ((void (*)(void))loc_809021E)();
  ((void (*)(void))loc_809021E)();
  return _r1;
}
// 80A663B: variable 'v3' is possibly undefined

//----- (080A6680) --------------------------------------------------------
reflect_StructField_0 __golang reflect___ptr_rtype__FieldByIndex(reflect_rtype *t, __int index)
{
  interface_{} e; // [esp+0h] [ebp-78h]
  reflect_StructField_0 v3; // [esp+10h] [ebp-68h]
  reflect_StructField_0 _r1; // [esp+8Ch] [ebp+14h]

  ((void (*)(void))loc_808FD83)();
  if ( (t->kind & 0x1F) != 25 )
  {
    e._type = (runtime__type_0 *)&::t;
    e.data = &reflect_statictmp_11;
    runtime_gopanic(e);
    BUG();
  }
  reflect___ptr_structType__FieldByIndex((reflect_structType *)t, index, v3);
  ((void (*)(void))loc_809021E)();
  ((void (*)(void))loc_809021E)();
  return _r1;
}
// 80A66DB: variable 'v3' is possibly undefined

//----- (080A6730) --------------------------------------------------------
retval_80A6730 __golang reflect___ptr_rtype__FieldByName(reflect_rtype *t, string name)
{
  interface_{} e; // [esp+0h] [ebp-B0h]
  reflect_StructField_0 v3; // [esp+Ch] [ebp-A4h]
  bool v4; // [esp+40h] [ebp-70h]
  bool v5; // [esp+40h] [ebp-70h]
  char v6; // [esp+80h] [ebp-30h] BYREF
  retval_80A6730 _r1; // [esp+C0h] [ebp+10h]

  while ( (unsigned int)&v6 <= *(_DWORD *)(*(_DWORD *)(__readgsdword(0) - 4) + 8) )
    runtime_morestack_noctxt();
  ((void (*)(void))loc_808FD83)();
  if ( (t->kind & 0x1F) != 25 )
  {
    e._type = (runtime__type_0 *)&::t;
    e.data = &reflect_statictmp_12;
    runtime_gopanic(e);
    BUG();
  }
  ((void (*)(void))loc_808FD83)();
  reflect___ptr_structType__FieldByName((reflect_structType *)t, name, v3, v4);
  ((void (*)(void))loc_809021E)();
  ((void (*)(void))loc_809021E)();
  ((void (*)(void))loc_809021E)();
  _r1._r2 = v5;
  return _r1;
}
// 80A679A: variable 'v3' is possibly undefined
// 80A679A: variable 'v4' is possibly undefined
// 80A67D7: variable 'v5' is possibly undefined

//----- (080A6810) --------------------------------------------------------
retval_80A6810 __golang reflect___ptr_rtype__FieldByNameFunc(reflect_rtype *t, func(string)_bool match)
{
  interface_{} e; // [esp+0h] [ebp-ACh]
  reflect_StructField_0 v3; // [esp+8h] [ebp-A4h]
  bool v4; // [esp+3Ch] [ebp-70h]
  bool v5; // [esp+3Ch] [ebp-70h]
  char v6; // [esp+80h] [ebp-2Ch] BYREF
  retval_80A6810 _r1; // [esp+B8h] [ebp+Ch]

  while ( (unsigned int)&v6 <= *(_DWORD *)(*(_DWORD *)(__readgsdword(0) - 4) + 8) )
    runtime_morestack_noctxt();
  ((void (*)(void))loc_808FD83)();
  if ( (t->kind & 0x1F) != 25 )
  {
    e._type = (runtime__type_0 *)&::t;
    e.data = &reflect_statictmp_13;
    runtime_gopanic(e);
    BUG();
  }
  ((void (*)(void))loc_808FD83)();
  reflect___ptr_structType__FieldByNameFunc((reflect_structType *)t, match, v3, v4);
  ((void (*)(void))loc_809021E)();
  ((void (*)(void))loc_809021E)();
  ((void (*)(void))loc_809021E)();
  _r1._r2 = v5;
  return _r1;
}
// 80A686F: variable 'v3' is possibly undefined
// 80A686F: variable 'v4' is possibly undefined
// 80A68AC: variable 'v5' is possibly undefined

//----- (080A68E0) --------------------------------------------------------
reflect_Type_0 __golang reflect___ptr_rtype__In(reflect_rtype *t, __int32 i)
{
  int v2; // ecx
  char *v3; // ecx
  void *v4; // eax
  runtime_itab_0 *v5; // ecx
  interface_{} e; // [esp+0h] [ebp-8h]
  reflect_Type_0 _r1; // [esp+14h] [ebp+Ch]

  if ( (t->kind & 0x1F) != 19 )
  {
    e._type = (runtime__type_0 *)&::t;
    e.data = &reflect_statictmp_14;
    runtime_gopanic(e);
    BUG();
  }
  if ( (t->tflag & 1) != 0 )
    v2 = 52;
  else
    v2 = 36;
  v3 = (char *)t + v2;
  if ( i >= (unsigned int)LOWORD(t[1].size) )
    runtime_panicindex();
  v4 = *(void **)&v3[4 * i];
  if ( v4 )
  {
    v5 = (runtime_itab_0 *)&go_itab__reflect_rtype_reflect_Type;
  }
  else
  {
    v5 = 0;
    v4 = 0;
  }
  _r1.tab = v5;
  _r1.data = v4;
  return _r1;
}

//----- (080A6990) --------------------------------------------------------
reflect_Type_0 __golang reflect___ptr_rtype__Key(reflect_rtype *t)
{
  void *size; // eax
  runtime_itab_0 *v2; // ecx
  interface_{} e; // [esp+0h] [ebp-8h]
  reflect_Type_0 _r0; // [esp+10h] [ebp+8h]

  if ( (t->kind & 0x1F) != 21 )
  {
    e._type = (runtime__type_0 *)&::t;
    e.data = &reflect_statictmp_15;
    runtime_gopanic(e);
    BUG();
  }
  size = (void *)t[1].size;
  if ( size )
  {
    v2 = (runtime_itab_0 *)&go_itab__reflect_rtype_reflect_Type;
  }
  else
  {
    v2 = 0;
    size = 0;
  }
  _r0.tab = v2;
  _r0.data = size;
  return _r0;
}

//----- (080A6A00) --------------------------------------------------------
__int32 __golang reflect___ptr_rtype__Len(reflect_rtype *t)
{
  interface_{} e; // [esp+0h] [ebp-8h]

  if ( (t->kind & 0x1F) != 17 )
  {
    e._type = (runtime__type_0 *)&::t;
    e.data = &reflect_statictmp_16;
    runtime_gopanic(e);
    BUG();
  }
  return t[1].hash;
}

//----- (080A6A60) --------------------------------------------------------
__int32 __golang reflect___ptr_rtype__NumField(reflect_rtype *t)
{
  interface_{} e; // [esp+0h] [ebp-8h]

  if ( (t->kind & 0x1F) != 25 )
  {
    e._type = (runtime__type_0 *)&::t;
    e.data = &reflect_statictmp_17;
    runtime_gopanic(e);
    BUG();
  }
  return t[1].hash;
}

//----- (080A6AC0) --------------------------------------------------------
__int32 __golang reflect___ptr_rtype__NumIn(reflect_rtype *t)
{
  interface_{} e; // [esp+0h] [ebp-8h]

  if ( (t->kind & 0x1F) != 19 )
  {
    e._type = (runtime__type_0 *)&::t;
    e.data = &reflect_statictmp_18;
    runtime_gopanic(e);
    BUG();
  }
  return LOWORD(t[1].size);
}

//----- (080A6B20) --------------------------------------------------------
__int32 __golang reflect___ptr_rtype__NumOut(reflect_rtype *t)
{
  unsigned __int16 size; // ax
  unsigned int v2; // edx
  unsigned int v3; // eax
  interface_{} e; // [esp+0h] [ebp-8h]

  if ( (t->kind & 0x1F) != 19 )
  {
    e._type = (runtime__type_0 *)&::t;
    e.data = &reflect_statictmp_19;
    runtime_gopanic(e);
    BUG();
  }
  size = t[1].size;
  v2 = size;
  v3 = (unsigned __int16)((HIWORD(t[1].size) & 0x7FFF) + size);
  if ( v2 > v3 )
    runtime_panicslice();
  return v3 - v2;
}
// 80A6B78: conditional instruction was optimized away because eax.4<10000u

//----- (080A6BC0) --------------------------------------------------------
reflect_Type_0 __golang reflect___ptr_rtype__Out(reflect_rtype *t, __int32 i)
{
  int v2; // ecx
  char *v3; // ecx
  unsigned __int16 size; // ax
  unsigned int v5; // ebx
  unsigned int v6; // eax
  char *v7; // ecx
  void *v8; // eax
  runtime_itab_0 *v9; // ecx
  interface_{} e; // [esp+0h] [ebp-8h]
  reflect_Type_0 _r1; // [esp+14h] [ebp+Ch]

  if ( (t->kind & 0x1F) != 19 )
  {
    e._type = (runtime__type_0 *)&::t;
    e.data = &reflect_statictmp_20;
    runtime_gopanic(e);
    BUG();
  }
  if ( (t->tflag & 1) != 0 )
    v2 = 52;
  else
    v2 = 36;
  v3 = (char *)t + v2;
  size = t[1].size;
  v5 = size;
  v6 = (unsigned __int16)((HIWORD(t[1].size) & 0x7FFF) + size);
  if ( v5 > v6 )
    runtime_panicslice();
  v7 = &v3[((int)(v5 - 0x100000) >> 31) & (4 * v5)];
  if ( i >= v6 - v5 )
    runtime_panicindex();
  v8 = *(void **)&v7[4 * i];
  if ( v8 )
  {
    v9 = (runtime_itab_0 *)&go_itab__reflect_rtype_reflect_Type;
  }
  else
  {
    v9 = 0;
    v8 = 0;
  }
  _r1.tab = v9;
  _r1.data = v8;
  return _r1;
}
// 80A6C20: conditional instruction was optimized away because eax.4<10000u

//----- (080A6CA0) --------------------------------------------------------
string __golang reflect_ChanDir_String(reflect_ChanDir d)
{
  string a[2]; // [esp+4h] [ebp-18h]
  string _r0; // [esp+24h] [ebp+8h]

  switch ( d )
  {
    case 1:
      _r0.str = (uint8 *)"<-chan";
      _r0.len = 6;
      break;
    case 2:
      _r0.str = (uint8 *)"chan<-";
      _r0.len = 6;
      break;
    case 3:
      _r0.str = (uint8 *)"chan";
      _r0.len = 4;
      break;
    default:
      a[0].str = (uint8 *)"ChanDir";
      a[0].len = 7;
      a[1] = strconv_Itoa(d);
      return runtime_concatstring2(0, *(string (*)[2])&a[0].str);
  }
  return _r0;
}

//----- (080A6D70) --------------------------------------------------------
void __golang reflect___ptr_interfaceType__Method(reflect_interfaceType *t, __int32 i, reflect_Method_0 m)
{
  reflect_name_0 n; // [esp+8h] [ebp-18h]
  reflect_imethod_0 *array; // [esp+Ch] [ebp-14h]

  ((void (*)(void))loc_808FD86)();
  if ( i >= 0 && i < t->methods.len )
  {
    array = t->methods.array;
    n.bytes = reflect___ptr_rtype__nameOff(&t->rtype, array[i].name).bytes;
    if ( (*n.bytes & 1) == 0 )
      reflect_name_pkgPath(n);
    reflect___ptr_rtype__typeOff(&t->rtype, array[i].typ);
  }
}

//----- (080A6EE0) --------------------------------------------------------
__int32 __golang reflect___ptr_interfaceType__NumMethod(reflect_interfaceType *t)
{
  return t->methods.len;
}

//----- (080A6F10) --------------------------------------------------------
void __golang reflect___ptr_interfaceType__MethodByName(
        reflect_interfaceType *t,
        string name,
        reflect_Method_0 m,
        bool ok)
{
  reflect_interfaceType *v4; // ecx
  __int32 len; // eax
  __int32 j; // edx
  reflect_Method_0 v7; // [esp+8h] [ebp-60h]
  reflect_name_0 v8; // [esp+8h] [ebp-60h]
  __int32 i; // [esp+30h] [ebp-38h]
  __int32 v10; // [esp+34h] [ebp-34h]
  int s_4; // [esp+3Ch] [ebp-2Ch]

  ((void (*)(void))loc_808FD86)();
  v4 = t;
  if ( t )
  {
    len = t->methods.len;
    v10 = len;
    for ( j = 0; j < len; j = i + 1 )
    {
      if ( (unsigned int)j >= v4->methods.len )
        runtime_panicindex();
      i = j;
      v8.bytes = reflect___ptr_rtype__nameOff(&v4->rtype, v4->methods.array[j].name).bytes;
      s_4 = 0;
      if ( v8.bytes )
        s_4 = v8.bytes[2] | (v8.bytes[1] << 8);
      if ( s_4 == name.len )
      {
        v7.Name = name;
        runtime_eqstring();
        if ( LOBYTE(v7.PkgPath.str) )
        {
          reflect___ptr_interfaceType__Method(t, i, v7);
          ((void (*)(void))loc_809023C)();
          ((void (*)(void))loc_809023C)();
          return;
        }
      }
      len = v10;
      v4 = t;
    }
  }
}
// 80A6FEF: variable 'v7' is possibly undefined

//----- (080A7060) --------------------------------------------------------
void __golang reflect___ptr_structType__Field(reflect_structType *t, __int32 i, reflect_StructField_0 f)
{
  reflect_structField_0 *array; // ebx
  __int32 v4; // edx
  interface_{} n; // [esp+0h] [ebp-24h]
  string v6; // [esp+4h] [ebp-20h]

  ((void (*)(void))loc_808FD83)();
  if ( i < 0 || (array = t->fields.array, i >= t->fields.len) )
  {
    n._type = (runtime__type_0 *)&::t;
    n.data = &reflect_statictmp_21;
    runtime_gopanic(n);
    BUG();
  }
  v4 = i;
  if ( (*array[i].name.bytes & 1) == 0 )
  {
    v6 = reflect_name_pkgPath(array[i].name);
    v4 = i;
  }
  reflect_name_tag(array[v4].name, v6);
  *(_DWORD *)runtime_newobject((runtime__type_0 *)&stru_80CBC60) = i;
}
// 80A713B: variable 'v6' is possibly undefined

//----- (080A7240) --------------------------------------------------------
void __golang reflect___ptr_structType__FieldByIndex(reflect_structType *t, __int index, reflect_StructField_0 f)
{
  reflect_structType *v3; // ecx
  reflect_Type_0 *v4; // eax
  __int32 v5; // ecx
  __int32 *array; // edx
  __int32 v7; // ebp
  uint8 *v8; // eax
  uint8 *v9; // ecx
  int v10; // [esp+4h] [ebp-50h]
  uint8 *v11; // [esp+8h] [ebp-4Ch] BYREF
  __int32 x; // [esp+3Ch] [ebp-18h]
  __int32 i; // [esp+40h] [ebp-14h]
  uint8 *ft_itab; // [esp+44h] [ebp-10h]
  uint8 *ft_data; // [esp+48h] [ebp-Ch]
  __int32 *v16; // [esp+4Ch] [ebp-8h]
  int *v17; // [esp+50h] [ebp-4h]
  uint8 *f_16; // [esp+78h] [ebp+24h]
  uint8 *f_20; // [esp+7Ch] [ebp+28h]

  ((void (*)(void))loc_808FD83)();
  v3 = t;
  if ( t )
  {
    v4 = &go_itab__reflect_rtype_reflect_Type;
  }
  else
  {
    v4 = 0;
    v3 = 0;
  }
  f_16 = (uint8 *)v4;
  f_20 = (uint8 *)v3;
  v17 = (int *)&v11;
  v5 = 0;
  array = index.array;
  while ( v5 < index.len )
  {
    i = v5;
    v16 = array;
    v7 = *array;
    if ( v5 > 0 )
    {
      x = *array;
      ft_data = f_20;
      ft_itab = f_16;
      if ( (*((int (__golang **)(uint8 *))f_16 + 21))(f_20) == 22
        && (v10 = (*((int (__golang **)(uint8 *))ft_itab + 11))(ft_data),
            (*(int (__golang **)(uint8 *))(v10 + 84))(v11) == 25) )
      {
        v9 = (uint8 *)(*((int (__golang **)(uint8 *))ft_itab + 11))(ft_data);
        v8 = v11;
      }
      else
      {
        v8 = ft_data;
        v9 = ft_itab;
      }
      f_16 = v9;
      f_20 = v8;
      v7 = x;
    }
    v11 = (uint8 *)(*((int (__golang **)(uint8 *, __int32))f_16 + 12))(f_20, v7);
    ((void (*)(void))loc_809021E)();
    array = v16 + 1;
    v5 = i + 1;
  }
}
// 80A7240: could not find valid save-restore pair for esi

//----- (080A7380) --------------------------------------------------------
void __golang reflect___ptr_structType__FieldByNameFunc(
        reflect_structType *t,
        func(string)_bool match,
        reflect_StructField_0 result,
        bool ok)
{
  int *v4; // eax
  __int32 v5; // ebp
  char *v6; // esi
  __int32 v7; // edi
  int v8; // ebx
  runtime_hmap *v9; // ecx
  char v10; // al
  hash<*reflect_structType,int> *v11; // ecx
  __int32 cap; // edx
  int v13; // ebx
  int v14; // ebp
  reflect_structType *v15; // eax
  __int32 len; // ecx
  __int32 v17; // edx
  char v18; // bl
  map__reflect_structType_int v19; // ebp
  void *v20; // esi
  int v21; // edi
  unsigned __int32 v22; // ecx
  reflect_structField_0 *array; // eax
  unsigned __int8 *bytes; // ebp
  __int32 v25; // ebp
  uint8 *str; // esi
  reflect_rtype *typ; // eax
  char v28; // al
  __int32 v29; // ecx
  int v30; // edx
  void *v31; // ebx
  int v32; // ebp
  hash<*reflect_structType,int> *v33; // eax
  unsigned __int32 v34; // eax
  unsigned int v35; // ecx
  void *v36; // edx
  __int32 v37; // eax
  __int32 v38; // ecx
  int v39; // edx
  __int32 *v40; // ebx
  int v41; // esi
  int v42; // edi
  int v43; // eax
  unsigned int v44; // esi
  reflect_fieldScan_0 *v45; // ebp
  int v46; // edx
  unsigned __int32 v47; // eax
  unsigned int v48; // ecx
  void *v49; // edx
  _DWORD *v50; // eax
  __int32 v51; // ecx
  _BYTE hint[56]; // [esp+4h] [ebp-FCh] BYREF
  char v53; // [esp+3Ch] [ebp-C4h] BYREF
  char v54; // [esp+3Eh] [ebp-C2h]
  char v55; // [esp+3Fh] [ebp-C1h]
  __int32 scan_index_len; // [esp+40h] [ebp-C0h]
  __int32 next_len; // [esp+44h] [ebp-BCh]
  __int32 next_cap; // [esp+48h] [ebp-B8h]
  __int32 index_len; // [esp+4Ch] [ebp-B4h]
  __int32 index_cap; // [esp+50h] [ebp-B0h]
  __int32 i; // [esp+54h] [ebp-ACh]
  __int32 fname_len; // [esp+58h] [ebp-A8h]
  int v63; // [esp+5Ch] [ebp-A4h]
  int v64; // [esp+60h] [ebp-A0h]
  int v65; // [esp+64h] [ebp-9Ch]
  int v66; // [esp+68h] [ebp-98h]
  int v67; // [esp+6Ch] [ebp-94h]
  int v68; // [esp+70h] [ebp-90h]
  int v69; // [esp+74h] [ebp-8Ch]
  int *v70; // [esp+78h] [ebp-88h]
  int v71[8]; // [esp+80h] [ebp-80h] BYREF
  map__reflect_structType_bool visited; // [esp+A0h] [ebp-60h]
  reflect_structType *scan_typ; // [esp+A4h] [ebp-5Ch]
  __int32 *scan_index_ptr; // [esp+A8h] [ebp-58h]
  map__reflect_structType_int nextCount; // [esp+ACh] [ebp-54h]
  reflect_fieldScan_0 *next_ptr; // [esp+B0h] [ebp-50h]
  __int32 *index_ptr; // [esp+B4h] [ebp-4Ch]
  uint8 *fname_ptr; // [esp+B8h] [ebp-48h]
  map__reflect_structType_int count; // [esp+BCh] [ebp-44h]
  uintptr *p_index; // [esp+C0h] [ebp-40h]
  uintptr *dst; // [esp+C4h] [ebp-3Ch]
  runtime_slice_0 v82; // [esp+C8h] [ebp-38h]
  runtime_slice_0 old; // [esp+D4h] [ebp-2Ch]
  int *v84; // [esp+E0h] [ebp-20h]
  _BYTE *v85; // [esp+E4h] [ebp-1Ch]
  string s; // [esp+E8h] [ebp-18h]
  int v87[4]; // [esp+F0h] [ebp-10h] BYREF

  while ( (unsigned int)v71 <= *(_DWORD *)(*(_DWORD *)(__readgsdword(0) - 4) + 8) )
    runtime_morestack_noctxt();
  s.str = 0;
  s.len = 0;
  ((void (*)(void))loc_808FD83)();
  memset(&v87[1], 0, 12);
  v87[0] = (int)t;
  *(_DWORD *)&hint[16] = runtime_makemap((runtime_maptype_0 *)&stru_80CF980, 0LL, 0, 0);
  visited = *(map__reflect_structType_bool *)&hint[16];
  v85 = &hint[4];
  v4 = v87;
  v5 = 1;
  v6 = &v53;
  v7 = 0;
  count = 0;
  v71[2] = *(_DWORD *)&hint[16];
  v55 = 0;
  v8 = 1;
  v9 = *(runtime_hmap **)&hint[16];
  while ( v8 > 0 )
  {
    v84 = v4;
    next_len = v8;
    next_cap = v5;
    v71[0] = (int)v4;
    v69 = 0;
    v70 = v4;
    nextCount = 0;
    v71[6] = (int)v9;
    v68 = 0;
    while ( v69 < v8 )
    {
      v67 = v7;
      old.cap = (__int32)v6;
      old.len = (__int32)v4;
      scan_index_len = v4[2];
      scan_index_ptr = (__int32 *)v4[1];
      scan_typ = (reflect_structType *)*v4;
      *(_DWORD *)&hint[8] = runtime_mapaccess1_fast32((runtime_maptype_0 *)&stru_80CF980, v9, (uint32)scan_typ);
      if ( **(_BYTE **)&hint[8] )
      {
        v10 = v55;
        v11 = nextCount;
        cap = old.cap;
        v13 = v68;
        v14 = v67;
      }
      else
      {
        *(_DWORD *)&hint[8] = runtime_mapassign_fast32(
                                (runtime_maptype_0 *)&stru_80CF980,
                                (runtime_hmap *)visited,
                                (uint32)scan_typ);
        **(_BYTE **)&hint[8] = 1;
        v15 = scan_typ;
        len = scan_typ->fields.len;
        v66 = len;
        v17 = 0;
        v18 = v55;
        v19 = nextCount;
        v20 = (void *)old.cap;
        v21 = v67;
        while ( v17 < len )
        {
          v22 = v15->fields.len;
          array = v15->fields.array;
          if ( v17 >= v22 )
            runtime_panicindex();
          old.array = v20;
          v82.cap = (__int32)v19;
          bytes = array[v17].name.bytes;
          s.str = 0;
          s.len = 0;
          if ( bytes )
          {
            s.str = bytes + 3;
            s.len = bytes[2] | (bytes[1] << 8);
          }
          i = v17;
          v65 = v21;
          v54 = v18;
          v25 = s.len;
          str = s.str;
          if ( (array[v17].offsetAnon & 1) != 0 )
          {
            typ = array[v17].typ;
            if ( (typ->kind & 0x1F) == 22 )
            {
              fname_len = s.len;
              fname_ptr = s.str;
              *(reflect_Type_0 *)hint = reflect___ptr_rtype__Elem(typ);
              *(_DWORD *)hint = (*(int (__golang **)(_DWORD))(*(_DWORD *)hint + 136))(*(_DWORD *)&hint[4]);
              typ = *(reflect_rtype **)hint;
              v25 = fname_len;
              str = fname_ptr;
            }
          }
          else
          {
            typ = 0;
          }
          v82.len = (__int32)typ;
          *(_DWORD *)&hint[4] = (*(int (__golang **)(uint8 *, __int32))match)(str, v25);
          if ( hint[4] )
          {
            *(_DWORD *)&hint[8] = runtime_mapaccess1_fast32(
                                    (runtime_maptype_0 *)&stru_80CF9C0,
                                    (runtime_hmap *)count,
                                    (uint32)scan_typ);
            if ( (int)**(_DWORD **)&hint[8] > 1 || v54 )
            {
              ((void (*)(void))loc_809021E)();
              return;
            }
            reflect___ptr_structType__Field(scan_typ, i, *(reflect_StructField_0 *)&hint[4]);
            ((void (*)(void))loc_809021E)();
            v47 = scan_index_len;
            if ( scan_index_len )
            {
              memset(hint, 0, 12);
              *(runtime_slice_0 *)&hint[16] = runtime_growslice(
                                                (runtime__type_0 *)&stru_80CEB60,
                                                *(runtime_slice_0 *)hint,
                                                scan_index_len);
              v49 = *(void **)&hint[16];
              v48 = *(_DWORD *)&hint[24];
              v47 = scan_index_len;
            }
            else
            {
              v48 = 0;
              v49 = 0;
            }
            if ( v47 > v48 )
              runtime_panicslice();
            v64 = v48;
            v82.array = v49;
            *(_DWORD *)hint = scan_index_ptr;
            *(_DWORD *)&hint[4] = 4 * v47;
            runtime_memmove();
            v50 = v82.array;
            v51 = scan_index_len;
            if ( scan_index_len + 1 > v64 )
            {
              *(_DWORD *)hint = v82.array;
              *(_DWORD *)&hint[4] = scan_index_len;
              *(_DWORD *)&hint[8] = v64;
              *(runtime_slice_0 *)&hint[16] = runtime_growslice(
                                                (runtime__type_0 *)&stru_80CEB60,
                                                *(runtime_slice_0 *)hint,
                                                scan_index_len + 1);
              v50 = *(_DWORD **)&hint[16];
              v51 = *(_DWORD *)&hint[20];
            }
            v50[v51] = i;
            v28 = 1;
            v29 = v82.cap;
            v30 = v68;
            v31 = old.array;
            v32 = v65;
          }
          else
          {
            v28 = v54;
            if ( !v54 && v82.len && (*(_BYTE *)(v82.len + 15) & 0x1F) == 25 )
            {
              *(_DWORD *)&hint[8] = runtime_mapaccess1_fast32(
                                      (runtime_maptype_0 *)&stru_80CF9C0,
                                      (runtime_hmap *)v82.cap,
                                      v82.len);
              if ( (int)**(_DWORD **)&hint[8] > 0 )
              {
                *(_DWORD *)&hint[8] = runtime_mapassign_fast32(
                                        (runtime_maptype_0 *)&stru_80CF9C0,
                                        (runtime_hmap *)v82.cap,
                                        v82.len);
                **(_DWORD **)&hint[8] = 2;
                v28 = v54;
                v29 = v82.cap;
                v30 = v68;
                v31 = old.array;
                v32 = v65;
              }
              else
              {
                v33 = (hash<*reflect_structType,int> *)v82.cap;
                if ( !v82.cap )
                {
                  *(_DWORD *)&hint[16] = runtime_makemap((runtime_maptype_0 *)&stru_80CF9C0, 0LL, 0, 0);
                  v33 = *(hash<*reflect_structType,int> **)&hint[16];
                }
                nextCount = v33;
                *(_DWORD *)&hint[8] = runtime_mapassign_fast32(
                                        (runtime_maptype_0 *)&stru_80CF9C0,
                                        (runtime_hmap *)v33,
                                        v82.len);
                **(_DWORD **)&hint[8] = 1;
                *(_DWORD *)&hint[8] = runtime_mapaccess1_fast32(
                                        (runtime_maptype_0 *)&stru_80CF9C0,
                                        (runtime_hmap *)count,
                                        (uint32)scan_typ);
                if ( (int)**(_DWORD **)&hint[8] > 1 )
                {
                  *(_DWORD *)&hint[8] = runtime_mapassign_fast32(
                                          (runtime_maptype_0 *)&stru_80CF9C0,
                                          (runtime_hmap *)nextCount,
                                          v82.len);
                  **(_DWORD **)&hint[8] = 2;
                }
                v34 = scan_index_len;
                if ( scan_index_len )
                {
                  memset(hint, 0, 12);
                  *(runtime_slice_0 *)&hint[16] = runtime_growslice(
                                                    (runtime__type_0 *)&stru_80CEB60,
                                                    *(runtime_slice_0 *)hint,
                                                    scan_index_len);
                  v36 = *(void **)&hint[16];
                  v35 = *(_DWORD *)&hint[24];
                  v34 = scan_index_len;
                }
                else
                {
                  v35 = 0;
                  v36 = 0;
                }
                if ( v34 > v35 )
                  runtime_panicslice();
                v64 = v35;
                v82.array = v36;
                *(_DWORD *)hint = scan_index_ptr;
                *(_DWORD *)&hint[4] = 4 * v34;
                runtime_memmove();
                v37 = scan_index_len;
                v38 = scan_index_len + 1;
                v39 = v64;
                if ( scan_index_len + 1 > v64 )
                {
                  *(_DWORD *)hint = v82.array;
                  *(_DWORD *)&hint[4] = scan_index_len;
                  *(_DWORD *)&hint[8] = v64;
                  *(runtime_slice_0 *)&hint[16] = runtime_growslice(
                                                    (runtime__type_0 *)&stru_80CEB60,
                                                    *(runtime_slice_0 *)hint,
                                                    scan_index_len + 1);
                  v40 = *(__int32 **)&hint[16];
                  v39 = *(_DWORD *)&hint[24];
                  v38 = *(_DWORD *)&hint[20] + 1;
                  v37 = scan_index_len;
                }
                else
                {
                  v40 = (__int32 *)v82.array;
                }
                index_ptr = v40;
                v40[v37] = i;
                v41 = v68;
                v42 = v68 + 1;
                v43 = v65;
                if ( v68 + 1 > v65 )
                {
                  index_len = v38;
                  index_cap = v39;
                  *(_DWORD *)hint = old.array;
                  *(_DWORD *)&hint[4] = v68;
                  *(_DWORD *)&hint[8] = v65;
                  *(runtime_slice_0 *)&hint[16] = runtime_growslice(
                                                    (runtime__type_0 *)&stru_80D3200,
                                                    *(runtime_slice_0 *)hint,
                                                    v68 + 1);
                  v42 = *(_DWORD *)&hint[20] + 1;
                  v38 = index_len;
                  v40 = index_ptr;
                  v41 = v68;
                  next_ptr = *(reflect_fieldScan_0 **)&hint[16];
                  v43 = *(_DWORD *)&hint[24];
                  v39 = index_cap;
                }
                else
                {
                  v71[4] = v65;
                  next_ptr = (reflect_fieldScan_0 *)old.array;
                }
                v44 = v41;
                v45 = next_ptr;
                next_ptr[v44].index.len = v38;
                v45[v44].index.cap = v39;
                v46 = v43;
                dst = (uintptr *)&v45[v44];
                if ( *(_DWORD *)&runtime_writeBarrier.enabled )
                {
                  v63 = v42;
                  v68 = v43;
                  p_index = (uintptr *)&v45[v44].index;
                  runtime_writebarrierptr(dst, v82.len);
                  runtime_writebarrierptr(p_index, (uintptr)index_ptr);
                  v46 = v68;
                  v45 = next_ptr;
                  v42 = v63;
                }
                else
                {
                  v45[v44].typ = (reflect_structType *)v82.len;
                  v45[v44].index.array = v40;
                }
                v28 = v54;
                v29 = (__int32)nextCount;
                v31 = v45;
                v32 = v46;
                v30 = v42;
              }
            }
            else
            {
              v29 = v82.cap;
              v30 = v68;
              v31 = old.array;
              v32 = v65;
            }
          }
          v21 = v32;
          v68 = v30;
          v17 = i + 1;
          v19 = (map__reflect_structType_int)v29;
          v20 = v31;
          len = v66;
          v18 = v28;
          v15 = scan_typ;
        }
        v10 = v18;
        v11 = v19;
        cap = (__int32)v20;
        v13 = v68;
        v14 = v21;
      }
      ++v69;
      v55 = v10;
      nextCount = v11;
      v7 = v14;
      v68 = v13;
      v9 = (runtime_hmap *)visited;
      v8 = next_len;
      v4 = (int *)(old.len + 16);
      v6 = (char *)cap;
    }
    if ( v55 )
      break;
    v4 = (int *)v6;
    v8 = v68;
    v5 = v7;
    v6 = (char *)v84;
    v7 = next_cap;
    count = nextCount;
  }
}

//----- (080A7CE0) --------------------------------------------------------
void __golang reflect___ptr_structType__FieldByName(
        reflect_structType *t,
        string name,
        reflect_StructField_0 f,
        bool present)
{
  __int32 len; // edx
  reflect_structType *v5; // ebx
  __int32 v6; // ebp
  __int32 v7; // esi
  char v8; // di
  unsigned __int32 v9; // ecx
  int array; // ebx
  unsigned __int8 *v11; // ebp
  int v12; // edx
  string v13; // [esp+0h] [ebp-108h]
  reflect_StructField_0 v14; // [esp+8h] [ebp-100h] BYREF
  bool v15; // [esp+3Ch] [ebp-CCh]
  bool hasAnon; // [esp+42h] [ebp-C6h]
  bool v17; // [esp+43h] [ebp-C5h]
  __int32 i; // [esp+44h] [ebp-C4h]
  int v19; // [esp+48h] [ebp-C0h]
  int v20; // [esp+4Ch] [ebp-BCh]
  int v21; // [esp+50h] [ebp-B8h]
  reflect_StructField_0 *v22; // [esp+54h] [ebp-B4h]
  string s; // [esp+58h] [ebp-B0h]
  int match[3]; // [esp+60h] [ebp-A8h] BYREF
  char v25; // [esp+80h] [ebp-88h] BYREF

  while ( (unsigned int)&v25 <= *(_DWORD *)(*(_DWORD *)(__readgsdword(0) - 4) + 8) )
    runtime_morestack_noctxt();
  s.str = 0;
  s.len = 0;
  ((void (*)(void))loc_808FD83)();
  v22 = &v14;
  len = name.len;
  if ( name.len )
  {
    v5 = t;
    v6 = t->fields.len;
    v20 = v6;
    v7 = 0;
    v8 = 0;
    while ( v7 < v6 )
    {
      v9 = v5->fields.len;
      array = (int)v5->fields.array;
      if ( v7 >= v9 )
        runtime_panicindex();
      v19 = 3 * v7;
      v11 = *(unsigned __int8 **)(array + 12 * v7);
      s.str = 0;
      s.len = 0;
      if ( v11 )
      {
        s.str = v11 + 3;
        s.len = v11[2] | (v11[1] << 8);
      }
      if ( s.len == len )
      {
        i = v7;
        v21 = array;
        hasAnon = v8;
        v13 = s;
        v14.Name.str = name.str;
        v14.Name.len = len;
        runtime_eqstring();
        if ( LOBYTE(v14.PkgPath.str) )
        {
          reflect___ptr_structType__Field(t, i, v14);
          ((void (*)(void))loc_809021E)();
          ((void (*)(void))loc_809021E)();
          return;
        }
        len = name.len;
        array = v21;
        v7 = i;
        v8 = hasAnon;
      }
      ++v7;
      v8 |= (*(_DWORD *)(array + 4 * v19 + 8) & 1) != 0;
      v5 = t;
      v6 = v20;
    }
  }
  else
  {
    v5 = t;
    v8 = 0;
  }
  if ( v8 )
  {
    v14.Name.str = (uint8 *)((int (__golang *)(uint8 *, __int32))loc_808FD83)(v13.str, v13.len);
    match[0] = (int)reflect___ptr_structType__FieldByName_func1;
    match[1] = (int)name.str;
    match[2] = v12;
    reflect___ptr_structType__FieldByNameFunc(v5, (func(string)_bool)match, v14, v15);
    ((void (*)(void))loc_809021E)();
    v17 = v15;
    ((void (*)(void))loc_809021E)();
    ((void (*)(void))loc_809021E)();
  }
}
// 80A7E65: variable 'v13' is possibly undefined
// 80A7E87: variable 'v12' is possibly undefined

//----- (080A7F20) --------------------------------------------------------
reflect_Type_0 __golang reflect_TypeOf(interface_{} i)
{
  runtime__type_0 *type; // eax
  runtime_itab_0 *v2; // ecx
  reflect_Type_0 _r1; // [esp+Ch] [ebp+Ch]

  type = i._type;
  if ( i._type )
  {
    v2 = (runtime_itab_0 *)&go_itab__reflect_rtype_reflect_Type;
  }
  else
  {
    type = 0;
    v2 = 0;
  }
  _r1.tab = v2;
  _r1.data = type;
  return _r1;
}

//----- (080A7F60) --------------------------------------------------------
reflect_rtype *__golang reflect___ptr_rtype__ptrTo(reflect_rtype *t)
{
  __int32 len; // eax
  uint8 *str; // ecx
  void **type; // ecx
  int i; // ebx
  reflect_ptrType *v5; // ecx
  uintptr *p_size; // ecx
  reflect_rtype *v7; // eax
  interface_{} keya; // [esp+4h] [ebp-58h]
  string keyb[2]; // [esp+4h] [ebp-58h]
  interface_{} keyc; // [esp+4h] [ebp-58h]
  reflect_ptrType *key; // [esp+4h] [ebp-58h]
  reflect_nameOff keyd; // [esp+4h] [ebp-58h]
  __uint8 keye; // [esp+4h] [ebp-58h]
  interface_{} keyf; // [esp+4h] [ebp-58h]
  interface_{} key_4; // [esp+8h] [ebp-54h]
  interface_{} value; // [esp+Ch] [ebp-50h]
  runtime__type_0 *valuea; // [esp+Ch] [ebp-50h]
  interface_{} valueb; // [esp+Ch] [ebp-50h]
  interface_{} valuec; // [esp+Ch] [ebp-50h]
  reflect_rtype *value_4; // [esp+10h] [ebp-4Ch]
  uint32 value_4a; // [esp+10h] [ebp-4Ch]
  bool s; // [esp+14h] [ebp-48h]
  char se; // [esp+14h] [ebp-48h]
  interface_{} sa; // [esp+14h] [ebp-48h]
  runtime__type_0 *sb; // [esp+14h] [ebp-48h]
  string sc; // [esp+14h] [ebp-48h]
  runtime__type_0 *sd; // [esp+14h] [ebp-48h]
  reflect_rtype *s_4; // [esp+18h] [ebp-44h]
  reflect_rtype *s_4a; // [esp+18h] [ebp-44h]
  bool n; // [esp+1Ch] [ebp-40h]
  reflect_name_0 na; // [esp+1Ch] [ebp-40h]
  char list[37]; // [esp+23h] [ebp-39h] BYREF
  uint8 *s_ptr; // [esp+48h] [ebp-14h]
  reflect_ptrType *prototype; // [esp+4Ch] [ebp-10h]
  reflect_ptrType *_pp; // [esp+50h] [ebp-Ch]
  interface_{} iptr; // [esp+54h] [ebp-8h]

  if ( t->ptrToThis )
    return reflect___ptr_rtype__typeOff(t, t->ptrToThis);
  keya._type = (runtime__type_0 *)&::key;
  keya.data = t;
  sync___ptr_Map__Load(&reflect_ptrMap, keya, value, s);
  if ( se )
  {
    if ( valuea != (runtime__type_0 *)&::value )
      runtime_panicdottypeE(valuea, (runtime__type_0 *)&::value, (runtime__type_0 *)&stru_80CECA0);
    return value_4;
  }
  else
  {
    keyb[0] = reflect___ptr_rtype__String(t);
    len = keyb[0].len;
    str = keyb[0].str;
    keyb[0].str = (uint8 *)"*";
    keyb[0].len = 1;
    keyb[1] = (string)__PAIR64__(len, (unsigned int)str);
    sa = (interface_{})runtime_concatstring2((uint8 (*)[32])&list[5], *(string (*)[2])&keyb[0].str);
    *(_DWORD *)&list[1] = sa.data;
    s_ptr = (uint8 *)sa._type;
    key_4 = (interface_{})COERCE_UNSIGNED_INT64(COERCE_LONG_DOUBLE(COERCE_LONG_DOUBLE(reflect_typesByString((string)sa))));
    type = (void **)key_4._type;
    for ( i = 0; i < (int)key_4.data; ++i )
    {
      if ( *((reflect_rtype **)*type + 8) == t )
      {
        keyc._type = (runtime__type_0 *)&::key;
        keyc.data = t;
        valueb._type = (runtime__type_0 *)&::value;
        valueb.data = *type;
        sync___ptr_Map__LoadOrStore(&reflect_ptrMap, keyc, valueb, sa, n);
        if ( sb != (runtime__type_0 *)&::value )
          runtime_panicdottypeE(sb, (runtime__type_0 *)&::value, (runtime__type_0 *)&stru_80CECA0);
        return s_4;
      }
      ++type;
    }
    iptr._type = (runtime__type_0 *)&unk_80C8F40;
    iptr.data = reflect_statictmp_23;
    prototype = (reflect_ptrType *)&unk_80C8F40;
    key = (reflect_ptrType *)runtime_newobject((runtime__type_0 *)&stru_80D3560);
    _pp = key;
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_typedmemmove((runtime__type_0 *)&stru_80D3560, key, prototype);
    else
      ((void (*)(void))loc_8090246)();
    na.bytes = reflect_newName((string)__PAIR64__(*(unsigned int *)&list[1], (unsigned int)s_ptr), 0LL, 0LL, 0).bytes;
    keyd = reflect_resolveReflectName(na);
    v5 = _pp;
    _pp->rtype.str = keyd;
    v5->rtype.ptrToThis = 0;
    list[0] = reflect_statictmp_24[0];
    keye.array = (uint8 *)list;
    *(_QWORD *)&keye.len = 0x100000001LL;
    value_4a = reflect_fnv1(t->hash, keye);
    p_size = &_pp->rtype.size;
    _pp->rtype.hash = value_4a;
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
    {
      runtime_writebarrierptr(p_size + 8, (uintptr)t);
      v7 = t;
      p_size = &_pp->rtype.size;
    }
    else
    {
      v7 = t;
      p_size[8] = (uintptr)t;
    }
    keyf._type = (runtime__type_0 *)&::key;
    keyf.data = v7;
    valuec._type = (runtime__type_0 *)&::value;
    valuec.data = p_size;
    sync___ptr_Map__LoadOrStore(&reflect_ptrMap, keyf, valuec, (interface_{})sc, (bool)na.bytes);
    if ( sd != (runtime__type_0 *)&::value )
      runtime_panicdottypeE(sd, (runtime__type_0 *)&::value, (runtime__type_0 *)&stru_80CECA0);
    return s_4a;
  }
}
// 80A7F60: could not find valid save-restore pair for edi
// 80A7F9F: variable 'value' is possibly undefined
// 80A7F9F: variable 's' is possibly undefined
// 80A7FB3: variable 'se' is possibly undefined
// 80A8055: variable 'n' is possibly undefined
// 80A806A: variable 'sb' is possibly undefined
// 80A8072: variable 's_4' is possibly undefined
// 80A8192: variable 'sc' is possibly undefined
// 80A81A7: variable 'sd' is possibly undefined
// 80A81AB: variable 's_4a' is possibly undefined
// 80A81F0: variable 'valuea' is possibly undefined
// 80A81F4: variable 'value_4' is possibly undefined
// 80E0D87: using guessed type char asc_80E0D87;

//----- (080A8270) --------------------------------------------------------
uint32 __golang reflect_fnv1(uint32 x, __uint8 list)
{
  uint8 *array; // edx
  __int32 i; // ebx

  array = list.array;
  for ( i = 0; i < list.len; ++i )
    x = *array++ ^ (16777619 * x);
  return x;
}

//----- (080A82C0) --------------------------------------------------------
bool __golang reflect___ptr_rtype__Implements(reflect_rtype *t, reflect_Type_0 u)
{
  interface_{} T; // [esp+0h] [ebp-Ch]
  interface_{} Ta; // [esp+0h] [ebp-Ch]

  if ( !u.tab )
  {
    Ta._type = (runtime__type_0 *)&::t;
    Ta.data = &reflect_statictmp_25;
    runtime_gopanic(Ta);
    BUG();
  }
  if ( ((int (__golang *)(void *))u.tab[3].hash)(u.data) != 20 )
  {
    T._type = (runtime__type_0 *)&::t;
    T.data = &reflect_statictmp_26;
    runtime_gopanic(T);
    BUG();
  }
  if ( &go_itab__reflect_rtype_reflect_Type != (reflect_Type_0 *)u.tab )
    runtime_panicdottypeI(u.tab, (runtime__type_0 *)&key, (runtime__type_0 *)&stru_80DBAE0);
  return reflect_implements((reflect_rtype *)u.data, t);
}

//----- (080A8390) --------------------------------------------------------
bool __golang reflect___ptr_rtype__AssignableTo(reflect_rtype *t, reflect_Type_0 u)
{
  interface_{} T; // [esp+0h] [ebp-Ch]

  if ( !u.tab )
  {
    T._type = (runtime__type_0 *)&::t;
    T.data = &reflect_statictmp_27;
    runtime_gopanic(T);
    BUG();
  }
  if ( &go_itab__reflect_rtype_reflect_Type != (reflect_Type_0 *)u.tab )
    runtime_panicdottypeI(u.tab, (runtime__type_0 *)&key, (runtime__type_0 *)&stru_80DBAE0);
  return reflect_directlyAssignable((reflect_rtype *)u.data, t) || reflect_implements((reflect_rtype *)u.data, t);
}

//----- (080A8450) --------------------------------------------------------
bool __golang reflect___ptr_rtype__ConvertibleTo(reflect_rtype *t, reflect_Type_0 u)
{
  interface_{} dst; // [esp+0h] [ebp-Ch]

  if ( !u.tab )
  {
    dst._type = (runtime__type_0 *)&::t;
    dst.data = &reflect_statictmp_28;
    runtime_gopanic(dst);
    BUG();
  }
  if ( &go_itab__reflect_rtype_reflect_Type != (reflect_Type_0 *)u.tab )
    runtime_panicdottypeI(u.tab, (runtime__type_0 *)&key, (runtime__type_0 *)&stru_80DBAE0);
  return reflect_convertOp((reflect_rtype *)u.data, t) != 0;
}

//----- (080A84E0) --------------------------------------------------------
bool __golang reflect___ptr_rtype__Comparable(reflect_rtype *t)
{
  reflect_typeAlg *alg; // eax

  alg = t->alg;
  return alg && alg->equal != 0;
}

//----- (080A8520) --------------------------------------------------------
bool __golang reflect_implements(reflect_rtype *T, reflect_rtype *V)
{
  reflect_rtype *t; // eax
  reflect_rtype *v3; // ecx
  signed __int32 v4; // edx
  uint32 v5; // ebx
  uintptr ptrdata; // ebp
  uint32 v7; // eax
  uintptr size; // ecx
  __int32 len; // edx
  uintptr v10; // ecx
  __int32 v11; // edx
  reflect_uncommonType *v12; // eax
  int v13; // ebx
  uint32 v14; // ebp
  uint32 v15; // eax
  unsigned __int8 *v16; // ecx
  __int32 v17; // ecx
  __int32 v18; // eax
  string off; // [esp+4h] [ebp-9Ch]
  string offa; // [esp+4h] [ebp-9Ch]
  reflect_uncommonType *offb; // [esp+4h] [ebp-9Ch]
  string offc; // [esp+4h] [ebp-9Ch]
  string offd; // [esp+4h] [ebp-9Ch]
  reflect_name_0 v24; // [esp+8h] [ebp-98h]
  reflect_name_0 v25; // [esp+8h] [ebp-98h]
  reflect_name_0 v26; // [esp+8h] [ebp-98h]
  reflect_name_0 v27; // [esp+8h] [ebp-98h]
  reflect_name_0 v28; // [esp+8h] [ebp-98h]
  char v29; // [esp+10h] [ebp-90h]
  reflect_typeOff vm_mtyp; // [esp+14h] [ebp-8Ch]
  __int32 tmPkgPath_len; // [esp+18h] [ebp-88h]
  __int32 tmPkgPath_len_0; // [esp+1Ch] [ebp-84h]
  unsigned __int32 j_0; // [esp+24h] [ebp-7Ch]
  unsigned int mcount; // [esp+30h] [ebp-70h]
  uint8 *n_bytes; // [esp+3Ch] [ebp-64h]
  uint8 *n_bytes_0; // [esp+40h] [ebp-60h]
  uint8 *n_bytes_1; // [esp+44h] [ebp-5Ch]
  uint8 *n_bytes_2; // [esp+48h] [ebp-58h]
  char *v39; // [esp+4Ch] [ebp-54h]
  reflect_nameOff *p_pkgPath; // [esp+50h] [ebp-50h]
  reflect_rtype *v41; // [esp+54h] [ebp-4Ch]
  reflect_rtype *v42; // [esp+54h] [ebp-4Ch]
  uintptr v43; // [esp+58h] [ebp-48h]
  uintptr v44; // [esp+5Ch] [ebp-44h]
  int s_4; // [esp+64h] [ebp-3Ch]
  int s_0_4; // [esp+6Ch] [ebp-34h]
  int s_1_4; // [esp+74h] [ebp-2Ch]
  int s_2_4; // [esp+7Ch] [ebp-24h]
  string s_3; // [esp+80h] [ebp-20h] BYREF
  string s_4a; // [esp+88h] [ebp-18h]
  string s_5; // [esp+90h] [ebp-10h]
  string s_6; // [esp+98h] [ebp-8h]

  while ( (unsigned int)&s_3 <= *(_DWORD *)(*(_DWORD *)(__readgsdword(0) - 4) + 8) )
    runtime_morestack_noctxt();
  ((void (*)(void))loc_808FD80)();
  t = T;
  if ( (T->kind & 0x1F) != 20 )
    return 0;
  if ( !T[1].hash )
    return 1;
  v3 = V;
  if ( (V->kind & 0x1F) == 20 )
  {
    v4 = 0;
    v5 = 0;
    while ( 1 )
    {
      if ( v4 >= (signed __int32)v3[1].hash )
        return 0;
      ptrdata = t[1].ptrdata;
      if ( v5 >= t[1].hash )
        runtime_panicindex();
      j_0 = v4;
      v24.bytes = reflect___ptr_rtype__nameOff(t, *(_DWORD *)(ptrdata + 8 * v5)).bytes;
      if ( j_0 >= V[1].hash )
        runtime_panicindex();
      v43 = V[1].ptrdata;
      n_bytes_2 = v24.bytes;
      v25.bytes = reflect___ptr_rtype__nameOff(V, *(_DWORD *)(v43 + 8 * j_0)).bytes;
      s_4a.str = 0;
      s_4a.len = 0;
      if ( v25.bytes )
      {
        s_4a.str = v25.bytes + 3;
        s_4a.len = (v25.bytes[1] << 8) | v25.bytes[2];
      }
      s_4 = 0;
      if ( n_bytes_2 )
        s_4 = (n_bytes_2[1] << 8) | n_bytes_2[2];
      if ( s_4 != s_4a.len
        || (n_bytes_1 = v25.bytes, runtime_eqstring(), !v29)
        || (v41 = reflect___ptr_rtype__typeOff(V, *(_DWORD *)(v43 + 8 * j_0 + 4)),
            reflect___ptr_rtype__typeOff(T, *(_DWORD *)(ptrdata + 8 * v5 + 4)) != v41) )
      {
        v7 = v5;
        goto LABEL_6;
      }
      if ( (*n_bytes_2 & 1) == 0 )
      {
        off = reflect_name_pkgPath((reflect_name_0)n_bytes_2);
        if ( off.len )
        {
          len = off.len;
        }
        else
        {
          size = T[1].size;
          s_0_4 = 0;
          if ( size )
            s_0_4 = (*(unsigned __int8 *)(size + 1) << 8) | *(unsigned __int8 *)(size + 2);
          len = s_0_4;
        }
        tmPkgPath_len_0 = len;
        offa = reflect_name_pkgPath((reflect_name_0)n_bytes_1);
        if ( offa.len )
        {
          v11 = offa.len;
        }
        else
        {
          v10 = V[1].size;
          s_1_4 = 0;
          if ( v10 )
            s_1_4 = (*(unsigned __int8 *)(v10 + 1) << 8) | *(unsigned __int8 *)(v10 + 2);
          v11 = s_1_4;
        }
        if ( v11 != tmPkgPath_len_0 )
        {
          v7 = v5;
          goto LABEL_6;
        }
        runtime_eqstring();
      }
      v7 = v5 + 1;
      if ( (signed __int32)(v5 + 1) >= (signed __int32)T[1].hash )
        return 1;
LABEL_6:
      v4 = j_0 + 1;
      v3 = V;
      v5 = v7;
      t = T;
    }
  }
  offb = reflect___ptr_rtype__uncommon(V);
  v12 = offb;
  if ( offb )
  {
    mcount = offb->mcount;
    p_pkgPath = &offb->pkgPath;
    v39 = (char *)offb + offb->moff;
    v13 = 0;
    v14 = 0;
    while ( 1 )
    {
      if ( v13 >= v12->mcount )
        return 0;
      if ( v14 >= T[1].hash )
        runtime_panicindex();
      v44 = T[1].ptrdata;
      v26.bytes = reflect___ptr_rtype__nameOff(T, *(_DWORD *)(v44 + 8 * v14)).bytes;
      if ( v13 >= mcount )
        runtime_panicindex();
      n_bytes = v26.bytes;
      vm_mtyp = *(_DWORD *)&v39[16 * v13 + 4];
      v27.bytes = reflect___ptr_rtype__nameOff(V, *(_DWORD *)&v39[16 * v13]).bytes;
      s_2_4 = 0;
      if ( v27.bytes )
        s_2_4 = (v27.bytes[1] << 8) | v27.bytes[2];
      s_5.str = 0;
      s_5.len = 0;
      if ( n_bytes )
      {
        s_5.str = n_bytes + 3;
        s_5.len = (n_bytes[1] << 8) | n_bytes[2];
      }
      if ( s_5.len != s_2_4
        || (n_bytes_0 = v27.bytes, runtime_eqstring(), !v29)
        || (v42 = reflect___ptr_rtype__typeOff(V, vm_mtyp),
            reflect___ptr_rtype__typeOff(T, *(_DWORD *)(v44 + 8 * v14 + 4)) != v42) )
      {
        v15 = v14;
        goto LABEL_37;
      }
      if ( (*n_bytes & 1) == 0 )
      {
        offc = reflect_name_pkgPath((reflect_name_0)n_bytes);
        if ( offc.len )
        {
          v17 = offc.len;
        }
        else
        {
          v16 = (unsigned __int8 *)T[1].size;
          s_6.str = 0;
          s_6.len = 0;
          if ( v16 )
          {
            s_6.str = v16 + 3;
            s_6.len = (v16[1] << 8) | v16[2];
          }
          v17 = s_6.len;
        }
        tmPkgPath_len = v17;
        offd = reflect_name_pkgPath((reflect_name_0)n_bytes_0);
        v18 = offd.len;
        if ( !offd.len )
        {
          v28.bytes = reflect___ptr_rtype__nameOff(V, *p_pkgPath).bytes;
          s_3.str = 0;
          s_3.len = 0;
          if ( v28.bytes )
          {
            s_3.str = v28.bytes + 3;
            s_3.len = (v28.bytes[1] << 8) | v28.bytes[2];
          }
          v18 = s_3.len;
        }
        if ( v18 != tmPkgPath_len )
        {
          v15 = v14;
          goto LABEL_37;
        }
        runtime_eqstring();
      }
      v15 = v14 + 1;
      if ( (signed __int32)(v14 + 1) >= (signed __int32)T[1].hash )
        return 1;
LABEL_37:
      ++v13;
      v14 = v15;
      v12 = (reflect_uncommonType *)p_pkgPath;
    }
  }
  return 0;
}
// 80A882A: conditional instruction was optimized away because %var_90.1!=0
// 80A8B0F: conditional instruction was optimized away because %var_90.1!=0
// 80A86BC: variable 'v29' is possibly undefined

//----- (080A8C00) --------------------------------------------------------
bool __golang reflect_directlyAssignable(reflect_rtype *T, reflect_rtype *V)
{
  string v2; // [esp+4h] [ebp-Ch]
  string v3; // [esp+4h] [ebp-Ch]
  bool _r2; // [esp+1Ch] [ebp+Ch]

  if ( T == V )
    return 1;
  v2 = reflect___ptr_rtype__Name(T);
  _r2 = (!v2.len || (v3 = reflect___ptr_rtype__Name(V), !v3.len))
     && (T->kind & 0x1F) == (V->kind & 0x1F)
     && reflect_haveIdenticalUnderlyingType(T, V, 1);
  return _r2;
}

//----- (080A8CA0) --------------------------------------------------------
bool __golang reflect_haveIdenticalType(reflect_Type_0 T, reflect_Type_0 V, bool cmpTags)
{
  reflect_rtype *x; // [esp+4h] [ebp-20h]
  char v5; // [esp+10h] [ebp-14h]
  int v6; // [esp+14h] [ebp-10h]
  reflect_rtype *v7; // [esp+1Ch] [ebp-8h]

  if ( cmpTags )
  {
    return T.tab == V.tab && runtime_ifaceeq(T.tab, T.data, V.data);
  }
  else
  {
    ((void (__golang *)(void *))T.tab[4]._type)(T.data);
    ((void (__golang *)(void *))V.tab[4]._type)(V.data);
    runtime_eqstring();
    if ( v5
      && (v6 = ((int (__golang *)(void *))T.tab[3].hash)(T.data), v6 == ((int (__golang *)(void *))V.tab[3].hash)(V.data)) )
    {
      v7 = (reflect_rtype *)(*(int (__golang **)(void *))&T.tab[5].bad)(T.data);
      x = (reflect_rtype *)(*(int (__golang **)(void *))&V.tab[5].bad)(V.data);
      return reflect_haveIdenticalUnderlyingType(v7, x, 0);
    }
    else
    {
      return 0;
    }
  }
}
// 80A8D5F: variable 'v5' is possibly undefined

//----- (080A8DF0) --------------------------------------------------------
bool __golang reflect_haveIdenticalUnderlyingType(reflect_rtype *T, reflect_rtype *V, bool cmpTags)
{
  reflect_rtype *v3; // eax
  reflect_rtype *v4; // ecx
  unsigned int v5; // edx
  __int32 v6; // edx
  __int32 i; // eax
  reflect_Type_0 v8; // kr00_8
  signed __int32 hash; // edx
  uint32 v12; // ebx
  uintptr ptrdata; // esi
  uint32 v14; // edi
  uintptr v15; // ecx
  int v16; // edi
  int v17; // eax
  _BYTE *v18; // edx
  uintptr size; // ecx
  __int32 v20; // edx
  uintptr v21; // ecx
  __int32 v22; // ecx
  reflect_Type_0 t; // [esp+0h] [ebp-6Ch]
  reflect_Type_0 v25; // [esp+4h] [ebp-68h]
  reflect_Type_0 v26; // [esp+4h] [ebp-68h]
  reflect_Type_0 v27; // [esp+4h] [ebp-68h]
  reflect_Type_0 v28; // [esp+4h] [ebp-68h]
  string v29; // [esp+4h] [ebp-68h]
  string v30; // [esp+4h] [ebp-68h]
  string v31; // [esp+4h] [ebp-68h]
  reflect_Type_0 v32; // [esp+4h] [ebp-68h]
  reflect_Type_0 v33; // [esp+4h] [ebp-68h]
  reflect_Type_0 v34; // [esp+4h] [ebp-68h]
  reflect_Type_0 v35; // [esp+8h] [ebp-64h]
  reflect_Type_0 v36; // [esp+8h] [ebp-64h]
  reflect_Type_0 v37; // [esp+8h] [ebp-64h]
  int v38; // [esp+8h] [ebp-64h]
  bool v39; // [esp+10h] [ebp-5Ch]
  __int32 tp_len; // [esp+18h] [ebp-54h]
  __int32 i_0; // [esp+20h] [ebp-4Ch]
  __int32 i_1; // [esp+24h] [ebp-48h]
  __int32 len; // [esp+28h] [ebp-44h]
  __int32 v44; // [esp+30h] [ebp-3Ch]
  uint32 v45; // [esp+30h] [ebp-3Ch]
  reflect_ChanDir v46; // [esp+34h] [ebp-38h]
  reflect_Type_0 v47; // [esp+3Ch] [ebp-30h]
  reflect_Type_0 v48; // [esp+3Ch] [ebp-30h]
  reflect_Type_0 v49; // [esp+3Ch] [ebp-30h]
  reflect_Type_0 v50; // [esp+3Ch] [ebp-30h]
  reflect_Type_0 v51; // [esp+3Ch] [ebp-30h]
  reflect_Type_0 v52; // [esp+3Ch] [ebp-30h]
  reflect_Type_0 v53; // [esp+3Ch] [ebp-30h]
  uintptr v54; // [esp+48h] [ebp-24h]
  int s_4; // [esp+50h] [ebp-1Ch]
  int s_0_4; // [esp+58h] [ebp-14h]
  int s_1_4; // [esp+60h] [ebp-Ch]
  int s_2_4; // [esp+68h] [ebp-4h]

  ((void (*)(void))loc_808FD88)();
  v3 = T;
  v4 = V;
  if ( T == V )
    return 1;
  v5 = T->kind & 0x1F;
  if ( v5 != (V->kind & 0x1F) )
    return 0;
  if ( v5 - 1 <= 0xF || v5 == 24 || v5 == 26 )
    return 1;
  if ( v5 <= 0x13 )
  {
    switch ( v5 )
    {
      case 0x11u:
        v44 = reflect___ptr_rtype__Len(T);
        if ( v44 != reflect___ptr_rtype__Len(V) )
          return 0;
        v50 = reflect___ptr_rtype__Elem(T);
        v27 = reflect___ptr_rtype__Elem(V);
        return reflect_haveIdenticalType(v50, v27, cmpTags);
      case 0x12u:
        if ( reflect___ptr_rtype__ChanDir(V) == 3 )
        {
          v49 = reflect___ptr_rtype__Elem(T);
          v26 = reflect___ptr_rtype__Elem(V);
          if ( reflect_haveIdenticalType(v49, v26, cmpTags) )
            return 1;
        }
        v46 = reflect___ptr_rtype__ChanDir(V);
        if ( v46 != reflect___ptr_rtype__ChanDir(T) )
          return 0;
        v48 = reflect___ptr_rtype__Elem(T);
        v25 = reflect___ptr_rtype__Elem(V);
        return reflect_haveIdenticalType(v48, v25, cmpTags);
      case 0x13u:
        if ( HIWORD(T[1].size) != HIWORD(V[1].size) || LOWORD(T[1].size) != LOWORD(V[1].size) )
          return 0;
        v6 = 0;
        while ( 1 )
        {
          i_0 = v6;
          if ( v6 >= reflect___ptr_rtype__NumIn(v3) )
            break;
          v47 = reflect___ptr_rtype__In(T, i_0);
          v35 = reflect___ptr_rtype__In(V, i_0);
          if ( !reflect_haveIdenticalType(v47, v35, cmpTags) )
            return 0;
          v6 = i_0 + 1;
          v3 = T;
        }
        for ( i = 0; ; i = i_1 + 1 )
        {
          i_1 = i;
          if ( i >= reflect___ptr_rtype__NumOut(T) )
            break;
          v8 = reflect___ptr_rtype__Out(T, i_1);
          v36 = reflect___ptr_rtype__Out(V, i_1);
          if ( !reflect_haveIdenticalType(v8, v36, cmpTags) )
            return 0;
        }
        return 1;
    }
    return 0;
  }
  if ( v5 <= 0x15 )
  {
    if ( v5 == 20 )
      return !T[1].hash && !V[1].hash;
    v52 = reflect___ptr_rtype__Key(T);
    v33 = reflect___ptr_rtype__Key(V);
    if ( !reflect_haveIdenticalType(v52, v33, cmpTags) )
      return 0;
    v53 = reflect___ptr_rtype__Elem(T);
    v34 = reflect___ptr_rtype__Elem(V);
    return reflect_haveIdenticalType(v53, v34, cmpTags);
  }
  if ( v5 - 22 <= 1 )
  {
    v51 = reflect___ptr_rtype__Elem(T);
    v32 = reflect___ptr_rtype__Elem(V);
    return reflect_haveIdenticalType(v51, v32, cmpTags);
  }
  if ( v5 != 25 )
    return 0;
  hash = T[1].hash;
  if ( hash != V[1].hash )
    return 0;
  v45 = T[1].hash;
  v12 = 0;
  while ( (int)v12 < hash )
  {
    ptrdata = v3[1].ptrdata;
    if ( v12 >= v3[1].hash )
      runtime_panicindex();
    v14 = v4[1].hash;
    v15 = v4[1].ptrdata;
    if ( v12 >= v14 )
      runtime_panicindex();
    v16 = *(_DWORD *)(ptrdata + 12 * v12);
    s_0_4 = 0;
    if ( v16 )
      s_0_4 = (*(unsigned __int8 *)(v16 + 1) << 8) | *(unsigned __int8 *)(v16 + 2);
    v17 = *(_DWORD *)(v15 + 12 * v12);
    s_2_4 = 0;
    if ( v17 )
      s_2_4 = *(unsigned __int8 *)(v17 + 2) | (*(unsigned __int8 *)(v17 + 1) << 8);
    if ( s_2_4 != s_0_4 )
      return 0;
    v54 = v15;
    runtime_eqstring();
    if ( !v39 )
      return 0;
    v37.tab = (runtime_itab_0 *)&go_itab__reflect_rtype_reflect_Type;
    v37.data = *(void **)(v54 + 12 * v12 + 4);
    t.tab = (runtime_itab_0 *)&go_itab__reflect_rtype_reflect_Type;
    t.data = *(void **)(ptrdata + 12 * v12 + 4);
    if ( !reflect_haveIdenticalType(t, v37, cmpTags) )
      return 0;
    if ( cmpTags )
    {
      reflect_name_tag(*(reflect_name_0 *)(ptrdata + 12 * v12), (string)v28);
      len = v31.len;
      reflect_name_tag(*(reflect_name_0 *)(v54 + 12 * v12), v31);
      if ( v38 != len )
        return 0;
      runtime_eqstring();
      if ( !v39 )
        return 0;
    }
    if ( *(_DWORD *)(ptrdata + 12 * v12 + 8) != *(_DWORD *)(v54 + 12 * v12 + 8) )
      return 0;
    v18 = *(_BYTE **)(ptrdata + 12 * v12);
    if ( (*v18 & 1) == 0 )
    {
      v29 = reflect_name_pkgPath((reflect_name_0)v18);
      if ( v29.len )
      {
        v20 = v29.len;
      }
      else
      {
        size = T[1].size;
        s_1_4 = 0;
        if ( size )
          s_1_4 = (*(unsigned __int8 *)(size + 1) << 8) | *(unsigned __int8 *)(size + 2);
        v20 = s_1_4;
      }
      tp_len = v20;
      v30 = reflect_name_pkgPath(*(reflect_name_0 *)(v54 + 12 * v12));
      if ( v30.len )
      {
        v22 = v30.len;
      }
      else
      {
        v21 = V[1].size;
        s_4 = 0;
        if ( v21 )
          s_4 = *(unsigned __int8 *)(v21 + 2) | (*(unsigned __int8 *)(v21 + 1) << 8);
        v22 = s_4;
      }
      if ( v22 != tp_len )
        return 0;
      runtime_eqstring();
      if ( !v39 )
        return 0;
    }
    ++v12;
    v3 = T;
    v4 = V;
    hash = v45;
  }
  return 1;
}
// 80A927C: variable 'v39' is possibly undefined
// 80A9417: variable 'v28' is possibly undefined
// 80A9420: variable 'v31' is possibly undefined
// 80A944D: variable 'v38' is possibly undefined

//----- (080A9620) --------------------------------------------------------
___reflect_rtype __golang reflect_typesByString(string s)
{
  __int32 v1; // eax
  int32 **v2; // ecx
  unsigned __int32 v3; // edx
  void **v4; // ebx
  unsigned __int32 v5; // ebp
  uintptr *v6; // esi
  __int32 v7; // edi
  char *v8; // ebx
  int32 *v9; // ecx
  unsigned __int32 v10; // edx
  int v11; // eax
  __int32 v12; // eax
  int v13; // ecx
  unsigned int v14; // eax
  unsigned int v15; // ecx
  int v16; // eax
  int v17; // ecx
  unsigned int v18; // edx
  uintptr *v19; // ebx
  _BYTE t[32]; // [esp+0h] [ebp-74h]
  string src; // [esp+4h] [ebp-70h]
  runtime_slice_0 srca; // [esp+4h] [ebp-70h]
  __int32 sections_len; // [esp+20h] [ebp-54h]
  unsigned __int64 ret_len; // [esp+24h] [ebp-50h]
  __int32 ret_lena; // [esp+24h] [ebp-50h]
  __int32 offset_len; // [esp+2Ch] [ebp-48h]
  unsigned __int32 offs_len; // [esp+34h] [ebp-40h]
  __int32 j; // [esp+38h] [ebp-3Ch]
  __int32 j_0; // [esp+3Ch] [ebp-38h]
  __int32 j_0a; // [esp+3Ch] [ebp-38h]
  __int32 h; // [esp+40h] [ebp-34h]
  unsigned int v32; // [esp+44h] [ebp-30h]
  int v33; // [esp+48h] [ebp-2Ch]
  int v34; // [esp+4Ch] [ebp-28h]
  void **sections_ptr; // [esp+58h] [ebp-1Ch]
  char *p; // [esp+60h] [ebp-14h]
  int32 *offs_ptr; // [esp+64h] [ebp-10h]
  reflect_rtype *v38; // [esp+68h] [ebp-Ch]
  uintptr *v39; // [esp+6Ch] [ebp-8h]
  int32 **v40; // [esp+70h] [ebp-4h]
  ___reflect_rtype _r1; // [esp+80h] [ebp+Ch]

  *(retval_8079460 *)t = reflect_typelinks();
  v1 = *(_DWORD *)&t[16];
  offset_len = *(_DWORD *)&t[16];
  v2 = *(int32 ***)&t[12];
  v3 = *(_DWORD *)&t[4];
  sections_len = *(_DWORD *)&t[4];
  v4 = *(void ***)t;
  sections_ptr = *(void ***)t;
  v5 = 0;
  v6 = 0;
  v7 = 0;
  HIDWORD(ret_len) = 0;
  while ( (int)v5 < v1 )
  {
    v40 = v2;
    v12 = (__int32)v2[1];
    v9 = *v2;
    if ( v5 >= v3 )
      runtime_panicindex();
    offs_len = v12;
    offs_ptr = v9;
    v39 = v6;
    ret_lena = v7;
    v8 = (char *)v4[v5];
    p = v8;
    j_0 = 0;
    while ( 1 )
    {
      v10 = j_0;
      if ( j_0 >= v12 )
        break;
      j = v12;
      v11 = (v12 - j_0) / 2;
      if ( v11 + j_0 >= offs_len )
        runtime_panicindex();
      v34 = v11;
      h = v11 + j_0;
      reflect___ptr_rtype__String((reflect_rtype *)&v8[v9[v11 + j_0]]);
      runtime_cmpstring();
      if ( *(int *)&t[16] < 0 )
      {
        v13 = v34 + j_0 + 1;
        v12 = j;
      }
      else
      {
        v12 = h;
        v13 = j_0;
      }
      v8 = p;
      v6 = v39;
      v7 = ret_lena;
      j_0 = v13;
      v9 = offs_ptr;
    }
    v14 = HIDWORD(ret_len);
    while ( 1 )
    {
      ret_len = __PAIR64__(v14, v7);
      if ( (int)v10 >= (int)offs_len )
        break;
      if ( v10 >= offs_len )
        runtime_panicindex();
      j_0a = v10;
      v38 = (reflect_rtype *)&v8[v9[v10]];
      src = reflect___ptr_rtype__String(v38);
      if ( src.len != s.len )
        break;
      runtime_eqstring();
      if ( !t[16] )
        break;
      v16 = v7;
      v17 = v7 + 1;
      v18 = HIDWORD(ret_len);
      if ( v7 + 1 > SHIDWORD(ret_len) )
      {
        srca.array = v6;
        *(_QWORD *)&srca.len = ret_len;
        *(runtime_slice_0 *)&t[20] = runtime_growslice((runtime__type_0 *)&key, srca, (int)ret_len + 1);
        v19 = *(uintptr **)&t[20];
        v18 = *(_DWORD *)&t[28];
        v17 = *(_DWORD *)&t[24] + 1;
        v16 = ret_len;
      }
      else
      {
        v19 = v6;
      }
      if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      {
        v33 = v17;
        v32 = v18;
        runtime_writebarrierptr(&v19[v16], (uintptr)v38);
        v17 = v33;
        v18 = v32;
      }
      else
      {
        v19[v16] = (uintptr)v38;
      }
      v6 = v19;
      v7 = v17;
      v8 = p;
      v15 = v18;
      v10 = j_0a + 1;
      v14 = v15;
      v9 = offs_ptr;
    }
    v2 = v40 + 3;
    ++v5;
    v1 = offset_len;
    v3 = sections_len;
    v4 = sections_ptr;
  }
  _r1.array = (reflect_rtype **)v6;
  _r1.len = v7;
  _r1.cap = HIDWORD(ret_len);
  return _r1;
}
// 80A9620: could not find valid save-restore pair for ebx
// 80A96F8: variable 't' is possibly undefined

//----- (080A98E0) --------------------------------------------------------
reflect_Type_0 __golang reflect_FuncOf(__reflect_Type in, __reflect_Type out, bool variadic)
{
  __int32 v3; // ebp
  reflect_funcType *v4; // eax
  __int32 v5; // ecx
  __int32 v6; // edx
  __int32 v7; // edx
  __int32 v8; // ecx
  reflect_Type_0 *array; // ebx
  uint32 v10; // ebp
  uint8 *v11; // esi
  unsigned int v12; // edi
  uint8 *data; // eax
  int v14; // ecx
  uint32 v15; // eax
  __int32 v16; // ecx
  reflect_Type_0 *v17; // edx
  uint8 *v18; // ebx
  __int32 v19; // ebp
  int i; // esi
  uint8 *v21; // edi
  int v22; // ecx
  reflect_funcType *v23; // ecx
  int v24; // ecx
  reflect_rtype **v25; // eax
  __int32 v26; // ebx
  int v27; // eax
  int v28; // eax
  reflect_rtype **v29; // ecx
  __int32 v30; // edx
  int v31; // eax
  reflect_rtype **v32; // ecx
  __int32 v33; // edx
  reflect_funcType *v34; // ecx
  runtime__type_0 *typ; // [esp+0h] [ebp-98h]
  runtime__type_0 *typa; // [esp+0h] [ebp-98h]
  runtime__type_0 *typb; // [esp+0h] [ebp-98h]
  runtime__type_0 *typc; // [esp+0h] [ebp-98h]
  runtime__type_0 *typd; // [esp+0h] [ebp-98h]
  interface_{} type; // [esp+0h] [ebp-98h]
  interface_{} typf; // [esp+0h] [ebp-98h]
  interface_{} typg; // [esp+0h] [ebp-98h]
  __uint8 lista; // [esp+4h] [ebp-94h]
  __uint8 listb; // [esp+4h] [ebp-94h]
  __uint8 listd; // [esp+4h] [ebp-94h]
  __uint8 liste; // [esp+4h] [ebp-94h]
  __uint8 listf; // [esp+4h] [ebp-94h]
  interface_{} listg; // [esp+4h] [ebp-94h]
  interface_{} listh; // [esp+4h] [ebp-94h]
  void (**listi)(void); // [esp+4h] [ebp-94h]
  string listj; // [esp+4h] [ebp-94h]
  reflect_Type_0 list; // [esp+4h] [ebp-94h]
  reflect_Type_0 listk; // [esp+4h] [ebp-94h]
  __uint8 listc; // [esp+4h] [ebp-94h]
  unsigned __int64 list_4; // [esp+8h] [ebp-90h]
  interface_{} list_8; // [esp+Ch] [ebp-8Ch]
  interface_{} list_8a; // [esp+Ch] [ebp-8Ch]
  runtime__type_0 *list_8b; // [esp+Ch] [ebp-8Ch]
  __int32 cap; // [esp+10h] [ebp-88h]
  long double v60; // [esp+14h] [ebp-84h]
  bool v61; // [esp+14h] [ebp-84h]
  char v62; // [esp+14h] [ebp-84h]
  reflect_name_0 n; // [esp+1Ch] [ebp-7Ch]
  _WORD v64[7]; // [esp+22h] [ebp-76h] BYREF
  __int32 args_cap; // [esp+30h] [ebp-68h]
  int v66; // [esp+34h] [ebp-64h] BYREF
  uint32 v67; // [esp+38h] [ebp-60h] BYREF
  __uint8 v68; // [esp+3Ch] [ebp-5Ch] BYREF
  int v69; // [esp+48h] [ebp-50h]
  reflect_rtype *tt; // [esp+4Ch] [ebp-4Ch]
  reflect_rtype *t; // [esp+50h] [ebp-48h]
  reflect_rtype *t_0; // [esp+54h] [ebp-44h]
  uint8 *str_ptr; // [esp+58h] [ebp-40h]
  reflect_funcType *prototype; // [esp+5Ch] [ebp-3Ch]
  uint8 *out_data; // [esp+60h] [ebp-38h]
  uint8 *in_data; // [esp+64h] [ebp-34h]
  reflect_funcType *ft; // [esp+68h] [ebp-30h]
  reflect_rtype **args_ptr; // [esp+6Ch] [ebp-2Ch]
  reflect_rtype **v79; // [esp+70h] [ebp-28h]
  void (**v80)(void); // [esp+74h] [ebp-24h]
  reflect_rtype **v81; // [esp+78h] [ebp-20h]
  reflect_rtype **v82; // [esp+7Ch] [ebp-1Ch]
  reflect_Type_0 *v83; // [esp+80h] [ebp-18h] BYREF
  runtime_slice_0 old; // [esp+84h] [ebp-14h]
  void *v85; // [esp+90h] [ebp-8h]
  func() v86; // [esp+94h] [ebp-4h]
  reflect_Type_0 _r3; // [esp+B8h] [ebp+20h]

  while ( (unsigned int)&v83 <= *(_DWORD *)(*(_DWORD *)(__readgsdword(0) - 4) + 8) )
    runtime_morestack_noctxt();
  _r3.tab = 0;
  _r3.data = 0;
  if ( variadic )
  {
    if ( !in.len )
      goto LABEL_74;
    if ( (unsigned int)(in.len - 1) >= in.len )
      runtime_panicindex();
    if ( ((int (__golang *)(void *))in.array[in.len - 1].tab[3].hash)(in.array[in.len - 1].data) != 23 )
    {
LABEL_74:
      typg._type = (runtime__type_0 *)&::t;
      typg.data = &reflect_statictmp_35;
      runtime_gopanic(typg);
      BUG();
    }
  }
  v85 = &unk_80CA340;
  v86 = reflect_statictmp_36;
  prototype = (reflect_funcType *)&unk_80CA340;
  v3 = in.len + out.len;
  if ( in.len + out.len <= 4 )
  {
    v4 = (reflect_funcType *)runtime_newobject((runtime__type_0 *)&stru_80D3380);
    v5 = (__int32)&v4[1];
    v6 = 4;
  }
  else if ( v3 <= 8 )
  {
    v4 = (reflect_funcType *)runtime_newobject((runtime__type_0 *)&stru_80D3440);
    v5 = (__int32)&v4[1];
    v6 = 8;
  }
  else if ( v3 <= 16 )
  {
    v4 = (reflect_funcType *)runtime_newobject((runtime__type_0 *)&stru_80D32C0);
    v5 = (__int32)&v4[1];
    v6 = 16;
  }
  else if ( v3 <= 32 )
  {
    v4 = (reflect_funcType *)runtime_newobject((runtime__type_0 *)&stru_80D3320);
    v5 = (__int32)&v4[1];
    v6 = 32;
  }
  else if ( v3 <= 64 )
  {
    v4 = (reflect_funcType *)runtime_newobject((runtime__type_0 *)&stru_80D33E0);
    v5 = (__int32)&v4[1];
    v6 = 64;
  }
  else
  {
    if ( v3 > 128 )
    {
      typf._type = (runtime__type_0 *)&::t;
      typf.data = &reflect_statictmp_37;
      runtime_gopanic(typf);
      BUG();
    }
    v4 = (reflect_funcType *)runtime_newobject((runtime__type_0 *)&stru_80D3260);
    v5 = (__int32)&v4[1];
    v6 = 128;
  }
  ft = v4;
  old.cap = v5;
  if ( *(_DWORD *)&runtime_writeBarrier.enabled )
  {
    args_cap = v6;
    runtime_typedmemmove((runtime__type_0 *)&stru_80D58C0, v4, prototype);
    v7 = args_cap;
  }
  else
  {
    ((void (*)(void))loc_8090246)();
  }
  v8 = 0;
  array = in.array;
  v10 = 0;
  v11 = (uint8 *)old.cap;
  v12 = 0;
  while ( 1 )
  {
    *(_DWORD *)&v64[5] = v12;
    if ( v8 >= in.len )
      break;
    v69 = v8;
    old.len = (__int32)array;
    data = (uint8 *)array->data;
    if ( (reflect_Type_0 *)array->tab != &go_itab__reflect_rtype_reflect_Type )
      runtime_panicdottypeI(array->tab, (runtime__type_0 *)&key, (runtime__type_0 *)&stru_80DBAE0);
    in_data = (uint8 *)array->data;
    *(_DWORD *)&v64[3] = v10;
    v14 = v12 + 1;
    if ( (int)(v12 + 1) > v7 )
    {
      listb.array = v11;
      *(_QWORD *)&listb.len = __PAIR64__(v7, v12);
      *(runtime_slice_0 *)&v60 = runtime_growslice((runtime__type_0 *)&key, (runtime_slice_0)listb, v12 + 1);
      v11 = (uint8 *)LODWORD(v60);
      v7 = HIDWORD(v60);
      v14 = DWORD1(v60) + 1;
      data = in_data;
      v10 = *(_DWORD *)&v64[3];
      v12 = *(_DWORD *)&v64[5];
    }
    args_ptr = (reflect_rtype **)v11;
    *(_DWORD *)&v64[5] = v14;
    args_cap = v7;
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
    {
      runtime_writebarrierptr((uintptr *)&v11[4 * v12], (uintptr)data);
      data = in_data;
      v10 = *(_DWORD *)&v64[3];
    }
    else
    {
      *(_DWORD *)&v11[4 * v12] = data;
    }
    v68.len = 0;
    LOBYTE(v68.len) = HIBYTE(*((_DWORD *)data + 2));
    BYTE1(v68.len) = BYTE2(*((_DWORD *)data + 2));
    BYTE2(v68.len) = BYTE1(*((_DWORD *)data + 2));
    HIBYTE(v68.len) = *((_DWORD *)data + 2);
    lista.array = (uint8 *)&v68.len;
    *(_QWORD *)&lista.len = 0x400000004LL;
    v10 = reflect_fnv1(v10, lista);
    array = (reflect_Type_0 *)(old.len + 8);
    v8 = v69 + 1;
    v11 = (uint8 *)args_ptr;
    v12 = *(_DWORD *)&v64[5];
    v7 = args_cap;
  }
  old.array = v11;
  v68.cap = v7;
  if ( variadic )
  {
    HIBYTE(v64[0]) = reflect_statictmp_39[0];
    listc.array = (uint8 *)v64 + 1;
    *(_QWORD *)&listc.len = 0x100000001LL;
    v10 = reflect_fnv1(v10, listc);
  }
  LOBYTE(v64[0]) = reflect_statictmp_40[0];
  listd.array = (uint8 *)v64;
  *(_QWORD *)&listd.len = 0x100000001LL;
  list_8.data = (void *)reflect_fnv1(v10, listd);
  v15 = (uint32)list_8.data;
  v16 = 0;
  v17 = out.array;
  v18 = (uint8 *)old.array;
  v19 = v68.cap;
  for ( i = *(_DWORD *)&v64[5]; ; i = *(_DWORD *)&v64[5] )
  {
    *(_DWORD *)&v64[3] = v15;
    if ( v16 >= out.len )
      break;
    v69 = v16;
    v83 = v17;
    v21 = (uint8 *)v17->data;
    if ( (reflect_Type_0 *)v17->tab != &go_itab__reflect_rtype_reflect_Type )
      runtime_panicdottypeI(v17->tab, (runtime__type_0 *)&key, (runtime__type_0 *)&stru_80DBAE0);
    out_data = (uint8 *)v17->data;
    v22 = i + 1;
    if ( i + 1 > v19 )
    {
      *(_DWORD *)&v64[5] = i;
      listf.array = v18;
      *(_QWORD *)&listf.len = __PAIR64__(v19, i);
      *(runtime_slice_0 *)&v60 = runtime_growslice((runtime__type_0 *)&key, (runtime_slice_0)listf, i + 1);
      v18 = (uint8 *)LODWORD(v60);
      v19 = HIDWORD(v60);
      v22 = DWORD1(v60) + 1;
      v15 = *(_DWORD *)&v64[3];
      i = *(_DWORD *)&v64[5];
      v21 = out_data;
    }
    args_ptr = (reflect_rtype **)v18;
    *(_DWORD *)&v64[5] = v22;
    args_cap = v19;
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
    {
      runtime_writebarrierptr((uintptr *)&v18[4 * i], (uintptr)v21);
      v15 = *(_DWORD *)&v64[3];
      v21 = out_data;
    }
    else
    {
      *(_DWORD *)&v18[4 * i] = v21;
    }
    v68.array = 0;
    LOBYTE(v68.array) = HIBYTE(*((_DWORD *)v21 + 2));
    BYTE1(v68.array) = BYTE2(*((_DWORD *)v21 + 2));
    BYTE2(v68.array) = BYTE1(*((_DWORD *)v21 + 2));
    HIBYTE(v68.array) = *((_DWORD *)v21 + 2);
    liste.array = (uint8 *)&v68;
    *(_QWORD *)&liste.len = 0x400000004LL;
    list_8.data = (void *)reflect_fnv1(v15, liste);
    v15 = (uint32)list_8.data;
    v17 = v83 + 1;
    v16 = v69 + 1;
    v18 = (uint8 *)args_ptr;
    v19 = args_cap;
  }
  if ( i > 50 )
  {
    type._type = (runtime__type_0 *)&::t;
    type.data = &reflect_statictmp_38;
    runtime_gopanic(type);
    BUG();
  }
  v23 = ft;
  ft->rtype.tflag = 0;
  v23->rtype.hash = v15;
  v23->inCount = in.len;
  v23->outCount = out.len;
  if ( variadic )
    v23->outCount = LOWORD(out.len) | 0x8000;
  v67 = v15;
  listg._type = (runtime__type_0 *)&stru_80CF2A0;
  listg.data = &v67;
  sync___ptr_Map__Load(&reflect_funcLookupCache.m, listg, list_8, SLOBYTE(v60));
  if ( v61 )
  {
    if ( list_8a._type != &stru_80C9000 )
      runtime_panicdottypeE(list_8a._type, (runtime__type_0 *)&stru_80C9000, (runtime__type_0 *)&stru_80CECA0);
    v24 = *((_DWORD *)list_8a.data + 1);
    v69 = v24;
    v25 = *(reflect_rtype ***)list_8a.data;
    v26 = 0;
    while ( v26 < v24 )
    {
      v68.cap = v26;
      v82 = v25;
      t = *v25;
      LOBYTE(list_8a._type) = reflect_haveIdenticalUnderlyingType(&ft->rtype, t, 1);
      if ( LOBYTE(list_8a._type) )
      {
        _r3.tab = (runtime_itab_0 *)&go_itab__reflect_rtype_reflect_Type;
        _r3.data = t;
        runtime_deferreturn((uintptr)typ);
        return _r3;
      }
      v25 = v82 + 1;
      v26 = v68.cap + 1;
      v24 = v69;
    }
  }
  sync___ptr_Mutex__Lock(&reflect_funcLookupCache.Mutex);
  runtime_deferproc(4, (runtime_funcval *)&len);
  if ( v27 )
  {
    runtime_deferreturn((uintptr)typa);
  }
  else
  {
    v66 = *(_DWORD *)&v64[3];
    listh._type = (runtime__type_0 *)&stru_80CF2A0;
    listh.data = &v66;
    sync___ptr_Map__Load(&reflect_funcLookupCache.m, listh, list_8a, v61);
    if ( v62 )
    {
      if ( list_8b != &stru_80C9000 )
        runtime_panicdottypeE(list_8b, (runtime__type_0 *)&stru_80C9000, (runtime__type_0 *)&stru_80CECA0);
      v28 = *(_DWORD *)(cap + 4);
      v69 = v28;
      v29 = *(reflect_rtype ***)cap;
      v30 = 0;
      while ( v30 < v28 )
      {
        v68.cap = v30;
        v81 = v29;
        t_0 = *v29;
        if ( reflect_haveIdenticalUnderlyingType(&ft->rtype, t_0, 1) )
        {
          _r3.tab = (runtime_itab_0 *)&go_itab__reflect_rtype_reflect_Type;
          _r3.data = t_0;
          runtime_deferreturn((uintptr)typb);
          return _r3;
        }
        v29 = v81 + 1;
        v30 = v68.cap + 1;
        v28 = v69;
      }
    }
    listi = (void (**)(void))runtime_newobject((runtime__type_0 *)&stru_80D10A0);
    v80 = listi;
    *listi = (void (*)(void))reflect_FuncOf_func1;
    listi[1] = *(void (**)(void))&v64[3];
    listj = reflect_funcStr(ft);
    *(_DWORD *)&v64[1] = listj.len;
    str_ptr = listj.str;
    list_4 = COERCE_UNSIGNED_INT64(COERCE_LONG_DOUBLE(COERCE_LONG_DOUBLE(reflect_typesByString(listj))));
    v31 = HIDWORD(list_4);
    v69 = HIDWORD(list_4);
    v32 = (reflect_rtype **)list_4;
    v33 = 0;
    while ( v33 < v31 )
    {
      v68.cap = v33;
      v79 = v32;
      tt = *v32;
      if ( reflect_haveIdenticalUnderlyingType(&ft->rtype, tt, 1) )
      {
        typc = (runtime__type_0 *)tt;
        (*v80)();
        _r3 = list;
        runtime_deferreturn((uintptr)typc);
        return _r3;
      }
      v32 = v79 + 1;
      v33 = v68.cap + 1;
      v31 = v69;
    }
    n.bytes = reflect_newName((string)__PAIR64__(*(unsigned int *)&v64[1], (unsigned int)str_ptr), 0LL, 0LL, 0).bytes;
    listk.tab = (runtime_itab_0 *)reflect_resolveReflectName(n);
    v34 = ft;
    ft->rtype.str = (reflect_nameOff)listk.tab;
    v34->rtype.ptrToThis = 0;
    typd = (runtime__type_0 *)v34;
    (*v80)();
    _r3 = listk;
    runtime_deferreturn((uintptr)typd);
  }
  return _r3;
}
// 80A98E0: could not find valid save-restore pair for ebp
// 80A98E0: could not find valid save-restore pair for esi
// 80A9A9D: variable 'v7' is possibly undefined
// 80A9CFD: variable 'list_8' is possibly undefined
// 80A9CFD: variable 'v60' is possibly undefined
// 80A9D11: variable 'v61' is possibly undefined
// 80A9D1F: variable 'list_8a' is possibly undefined
// 80A9D93: variable 'typ' is possibly undefined
// 80A9DCF: variable 'v27' is possibly undefined
// 80A9E0C: variable 'v62' is possibly undefined
// 80A9E1A: variable 'list_8b' is possibly undefined
// 80A9E20: variable 'cap' is possibly undefined
// 80A9E88: variable 'typb' is possibly undefined
// 80A9F4A: variable 'list' is possibly undefined
// 80A9FCF: variable 'listk' is possibly undefined
// 80A9FEB: variable 'typa' is possibly undefined

//----- (080AA210) --------------------------------------------------------
string __golang reflect_funcStr(reflect_funcType *ft)
{
  reflect_funcType *v1; // ecx
  int v2; // eax
  reflect_rtype **v3; // eax
  int inCount; // edx
  int v5; // ebx
  uint8 *v6; // ebp
  unsigned __int64 v7; // rdi
  unsigned int v8; // eax
  uint8 *v9; // eax
  unsigned int v10; // ecx
  unsigned int v11; // edx
  unsigned __int32 v12; // ebx
  unsigned __int32 v13; // ebp
  uint8 *v14; // esi
  unsigned __int32 v15; // edx
  uint8 *v16; // esi
  unsigned __int32 v17; // eax
  unsigned __int32 v18; // ecx
  uint8 *v19; // edx
  unsigned __int32 v20; // edx
  unsigned __int32 v21; // ebp
  uint8 *v22; // esi
  int v23; // eax
  int v24; // edx
  char *v25; // edx
  __int16 v26; // bx
  uint16 v27; // cx
  unsigned int v28; // edi
  unsigned int v29; // ecx
  int v30; // ecx
  reflect_rtype **v31; // edx
  int v32; // ebx
  int v33; // eax
  unsigned int v34; // ecx
  unsigned int v35; // eax
  uint8 *v36; // ecx
  int v37; // edx
  unsigned __int32 v38; // edx
  unsigned __int32 v39; // ebp
  uint8 *v40; // esi
  int v41; // eax
  unsigned int v42; // ebx
  int v43; // ecx
  uint8 *v44; // edx
  string old; // [esp+4h] [ebp-9Ch]
  runtime_slice_0 oldd; // [esp+4h] [ebp-9Ch]
  runtime_slice_0 olde; // [esp+4h] [ebp-9Ch]
  string olda; // [esp+4h] [ebp-9Ch]
  runtime_slice_0 oldf; // [esp+4h] [ebp-9Ch]
  runtime_slice_0 oldc; // [esp+4h] [ebp-9Ch]
  string oldb; // [esp+4h] [ebp-9Ch]
  runtime_slice_0 oldj; // [esp+4h] [ebp-9Ch]
  runtime_slice_0 oldi; // [esp+4h] [ebp-9Ch]
  __uint8 oldl; // [esp+4h] [ebp-9Ch]
  runtime_slice_0 oldk; // [esp+4h] [ebp-9Ch]
  runtime_slice_0 oldh; // [esp+4h] [ebp-9Ch]
  runtime_slice_0 oldm; // [esp+4h] [ebp-9Ch]
  runtime_slice_0 oldg; // [esp+4h] [ebp-9Ch]
  __int128 cap; // [esp+10h] [ebp-90h]
  string capa; // [esp+10h] [ebp-90h]
  unsigned __int64 repr_len; // [esp+20h] [ebp-80h]
  __int32 repr_lena; // [esp+20h] [ebp-80h]
  unsigned __int64 repr_lenb; // [esp+20h] [ebp-80h]
  __int32 out_len; // [esp+28h] [ebp-78h]
  __int32 i; // [esp+2Ch] [ebp-74h]
  __int32 i_0; // [esp+30h] [ebp-70h]
  unsigned __int32 v67; // [esp+38h] [ebp-68h]
  unsigned __int32 v68; // [esp+3Ch] [ebp-64h]
  int v69; // [esp+40h] [ebp-60h]
  unsigned __int32 v70; // [esp+40h] [ebp-60h]
  int v71; // [esp+40h] [ebp-60h]
  runtime_slice_0 v72; // [esp+44h] [ebp-5Ch] BYREF
  char v73; // [esp+80h] [ebp-20h] BYREF
  reflect_rtype *t; // [esp+84h] [ebp-1Ch]
  reflect_rtype *t_0; // [esp+88h] [ebp-18h]
  uint8 *repr_ptr; // [esp+8Ch] [ebp-14h]
  reflect_rtype **out_ptr; // [esp+90h] [ebp-10h]
  reflect_rtype **v78; // [esp+94h] [ebp-Ch]
  uint8 *str; // [esp+98h] [ebp-8h]
  reflect_rtype **v80; // [esp+9Ch] [ebp-4h]

  while ( (unsigned int)&v73 <= *(_DWORD *)(*(_DWORD *)(__readgsdword(0) - 4) + 8) )
    runtime_morestack_noctxt();
  ((void (*)(void))loc_808FD80)();
  runtime_memmove();
  v1 = ft;
  if ( (ft->rtype.tflag & 1) != 0 )
    v2 = 52;
  else
    v2 = 36;
  v3 = (reflect_rtype **)((char *)ft + v2);
  inCount = ft->inCount;
  v69 = inCount;
  v5 = 0;
  v6 = (uint8 *)&v72;
  v7 = 0x4000000005LL;
  while ( v5 < inCount )
  {
    i = v5;
    v80 = v3;
    t_0 = *v3;
    if ( v5 <= 0 )
    {
      v9 = v6;
      v10 = HIDWORD(v7);
      v11 = v7;
    }
    else
    {
      v8 = v7 + 2;
      if ( (unsigned int)(v7 + 2) > HIDWORD(v7) )
      {
        oldc.array = v6;
        *(_QWORD *)&oldc.len = v7;
        *(runtime_slice_0 *)((char *)&cap + 4) = runtime_growslice((runtime__type_0 *)&::i, oldc, (int)v7 + 2);
        HIDWORD(v7) = HIDWORD(cap);
        v6 = (uint8 *)DWORD1(cap);
        v8 = v7 + 2;
      }
      if ( v8 > HIDWORD(v7) )
        runtime_panicslice();
      repr_ptr = v6;
      runtime_memmove();
      v9 = repr_ptr;
      v10 = HIDWORD(v7);
      v11 = v7 + 2;
    }
    repr_ptr = v9;
    repr_len = __PAIR64__(v10, v11);
    if ( reflect___ptr_rtype__IsVariadic(&ft->rtype) && ft->inCount - 1 == v5 )
    {
      v12 = repr_len + 3;
      v13 = HIDWORD(repr_len);
      if ( (unsigned int)(repr_len + 3) > HIDWORD(repr_len) )
      {
        olde.array = repr_ptr;
        *(_QWORD *)&olde.len = repr_len;
        *(runtime_slice_0 *)((char *)&cap + 4) = runtime_growslice((runtime__type_0 *)&::i, olde, (int)repr_len + 3);
        v13 = HIDWORD(cap);
        v14 = (uint8 *)DWORD1(cap);
        v12 = repr_len + 3;
      }
      else
      {
        v14 = repr_ptr;
      }
      if ( v12 > v13 )
        runtime_panicslice();
      repr_ptr = v14;
      runtime_memmove();
      old = reflect___ptr_rtype__String((reflect_rtype *)t_0[1].size);
      v15 = repr_len + old.len + 3;
      v67 = v15;
      if ( v15 > v13 )
      {
        str = old.str;
        oldd.array = repr_ptr;
        *(_QWORD *)&oldd.len = __PAIR64__(v13, (int)repr_len + 3);
        *(runtime_slice_0 *)((char *)&cap + 4) = runtime_growslice((runtime__type_0 *)&::i, oldd, v15);
        v13 = HIDWORD(cap);
        v16 = (uint8 *)DWORD1(cap);
        v15 = v67;
      }
      else
      {
        v16 = repr_ptr;
      }
      if ( v15 > v13 )
        runtime_panicslice();
      repr_ptr = v16;
      runtime_memmove();
      v17 = v67;
      v18 = v13;
      v19 = repr_ptr;
    }
    else
    {
      olda = reflect___ptr_rtype__String(t_0);
      v20 = repr_len + olda.len;
      v68 = repr_len + olda.len;
      v21 = HIDWORD(repr_len);
      if ( (unsigned int)(repr_len + olda.len) > HIDWORD(repr_len) )
      {
        str = olda.str;
        oldf.array = repr_ptr;
        *(_QWORD *)&oldf.len = repr_len;
        *(runtime_slice_0 *)((char *)&cap + 4) = runtime_growslice((runtime__type_0 *)&::i, oldf, v20);
        v21 = HIDWORD(cap);
        v22 = (uint8 *)DWORD1(cap);
        v20 = v68;
      }
      else
      {
        v22 = repr_ptr;
      }
      if ( v20 > v21 )
        runtime_panicslice();
      repr_ptr = v22;
      runtime_memmove();
      v17 = v68;
      v18 = v21;
      v19 = repr_ptr;
    }
    v7 = __PAIR64__(v18, v17);
    v1 = ft;
    v3 = v80 + 1;
    v5 = i + 1;
    v6 = v19;
    inCount = v69;
  }
  v23 = v7 + 1;
  if ( (int)v7 + 1 > SHIDWORD(v7) )
  {
    oldg.array = v6;
    *(_QWORD *)&oldg.len = v7;
    *(runtime_slice_0 *)((char *)&cap + 4) = runtime_growslice((runtime__type_0 *)&::i, oldg, (int)v7 + 1);
    v6 = (uint8 *)DWORD1(cap);
    HIDWORD(v7) = HIDWORD(cap);
    v23 = DWORD2(cap) + 1;
    v1 = ft;
  }
  v6[v7] = 41;
  if ( (v1->rtype.tflag & 1) != 0 )
    v24 = 52;
  else
    v24 = 36;
  v25 = (char *)v1 + v24;
  v26 = v1->outCount & 0x7FFF;
  v27 = v1->inCount;
  v28 = v27;
  v29 = (unsigned __int16)(v26 + v27);
  if ( v28 > v29 )
    runtime_panicslice();
  repr_lena = v23;
  v30 = v29 - v28;
  out_len = v30;
  v31 = (reflect_rtype **)&v25[((int)(v28 - 0x100000) >> 31) & (4 * v28)];
  out_ptr = v31;
  if ( v30 == 1 )
  {
    v32 = v23 + 1;
    if ( v23 + 1 > SHIDWORD(v7) )
    {
      oldh.array = v6;
      *(_QWORD *)&oldh.len = __PAIR64__(HIDWORD(v7), v23);
      *(runtime_slice_0 *)((char *)&cap + 4) = runtime_growslice((runtime__type_0 *)&::i, oldh, v23 + 1);
      v6 = (uint8 *)DWORD1(cap);
      HIDWORD(v7) = HIDWORD(cap);
      v32 = DWORD2(cap) + 1;
      v23 = repr_lena;
      v30 = 1;
      v31 = out_ptr;
    }
    v6[v23] = 32;
  }
  else
  {
    if ( v30 <= 1 )
    {
      v43 = HIDWORD(v7);
      v44 = v6;
    }
    else
    {
      v42 = v23 + 2;
      v71 = v23 + 2;
      if ( (unsigned int)(v23 + 2) > HIDWORD(v7) )
      {
        oldm.array = v6;
        *(_QWORD *)&oldm.len = __PAIR64__(HIDWORD(v7), v23);
        *(runtime_slice_0 *)((char *)&cap + 4) = runtime_growslice((runtime__type_0 *)&::i, oldm, v23 + 2);
        HIDWORD(v7) = HIDWORD(cap);
        v6 = (uint8 *)DWORD1(cap);
        v42 = v71;
      }
      if ( v42 > HIDWORD(v7) )
        runtime_panicslice();
      repr_ptr = v6;
      runtime_memmove();
      v23 = v71;
      v43 = HIDWORD(v7);
      v44 = repr_ptr;
    }
    HIDWORD(v7) = v43;
    v32 = v23;
    v6 = v44;
    v30 = out_len;
    v31 = out_ptr;
  }
  v33 = 0;
  while ( v33 < v30 )
  {
    i_0 = v33;
    v78 = v31;
    t = *v31;
    if ( v33 <= 0 )
    {
      v35 = HIDWORD(v7);
      v36 = v6;
      v37 = v32;
    }
    else
    {
      v34 = v32 + 2;
      if ( (unsigned int)(v32 + 2) > HIDWORD(v7) )
      {
        oldi.array = v6;
        *(_QWORD *)&oldi.len = __PAIR64__(HIDWORD(v7), v32);
        *(runtime_slice_0 *)((char *)&cap + 4) = runtime_growslice((runtime__type_0 *)&::i, oldi, v32 + 2);
        HIDWORD(v7) = HIDWORD(cap);
        v6 = (uint8 *)DWORD1(cap);
        v34 = v32 + 2;
      }
      if ( v34 > HIDWORD(v7) )
        runtime_panicslice();
      repr_ptr = v6;
      runtime_memmove();
      v35 = HIDWORD(v7);
      v36 = repr_ptr;
      v37 = v32 + 2;
    }
    repr_ptr = v36;
    repr_lenb = __PAIR64__(v35, v37);
    oldb = reflect___ptr_rtype__String(t);
    v38 = oldb.len + repr_lenb;
    v70 = oldb.len + repr_lenb;
    v39 = HIDWORD(repr_lenb);
    if ( (unsigned int)(oldb.len + repr_lenb) > HIDWORD(repr_lenb) )
    {
      str = oldb.str;
      oldj.array = repr_ptr;
      *(_QWORD *)&oldj.len = repr_lenb;
      *(runtime_slice_0 *)((char *)&cap + 4) = runtime_growslice((runtime__type_0 *)&::i, oldj, v38);
      v39 = HIDWORD(cap);
      v40 = (uint8 *)DWORD1(cap);
      v38 = v70;
    }
    else
    {
      v40 = repr_ptr;
    }
    if ( v38 > v39 )
      runtime_panicslice();
    repr_ptr = v40;
    runtime_memmove();
    v31 = v78 + 1;
    v33 = i_0 + 1;
    v30 = out_len;
    HIDWORD(v7) = v39;
    v32 = v70;
    v6 = repr_ptr;
  }
  if ( v30 <= 1 )
  {
    v41 = v32;
  }
  else
  {
    v41 = v32 + 1;
    if ( v32 + 1 > SHIDWORD(v7) )
    {
      oldk.array = v6;
      *(_QWORD *)&oldk.len = __PAIR64__(HIDWORD(v7), v32);
      *(runtime_slice_0 *)((char *)&cap + 4) = runtime_growslice((runtime__type_0 *)&::i, oldk, v32 + 1);
      v6 = (uint8 *)DWORD1(cap);
      HIDWORD(v7) = HIDWORD(cap);
      v41 = DWORD2(cap) + 1;
    }
    v6[v32] = 41;
  }
  oldl.array = v6;
  *(_QWORD *)&oldl.len = __PAIR64__(HIDWORD(v7), v41);
  runtime_slicebytetostring(0, oldl, (string)cap);
  return capa;
}
// 80AA628: conditional instruction was optimized away because ecx.4<10000u
// 80AA834: variable 'cap' is possibly undefined
// 80AA841: variable 'capa' is possibly undefined

//----- (080AAA10) --------------------------------------------------------
void __golang reflect_funcLayout(
        reflect_rtype *t,
        reflect_rtype *rcvr,
        reflect_rtype *frametype,
        uintptr argSize,
        uintptr retOffset,
        reflect_bitVector *stk,
        sync_Pool_0 *framePool)
{
  reflect_bitVector *v7; // eax
  signed __int8 kind; // dl
  __int32 v9; // edx
  void *v10; // ebx
  __int32 v11; // ebp
  unsigned __int32 v12; // ebp
  int v13; // ecx
  reflect_rtype *v14; // edx
  int v15; // ebx
  reflect_rtype **v16; // ebx
  int size_low; // ebp
  int v18; // esi
  int v19; // ebp
  uintptr v20; // ecx
  int v21; // esi
  char *v22; // esi
  __int16 v23; // di
  unsigned __int16 size; // bp
  unsigned int v25; // edx
  unsigned int v26; // ebp
  __int32 v27; // ebp
  reflect_rtype **v28; // edx
  __int32 v29; // edi
  void *v30; // eax
  reflect_bitVector *v31; // ecx
  uintptr v32; // ebx
  reflect_rtype *v33; // edx
  bool v34; // zf
  string v35; // kr00_8
  __int32 v36; // eax
  uint8 *v37; // ecx
  _DWORD *v38; // eax
  int v39; // edx
  __int32 v40; // eax
  uint8 *v41; // ecx
  void *array; // eax
  __int32 v43; // ecx
  reflect_bitVector *v44; // ebx
  __int32 len; // eax
  uint8 *str; // ecx
  interface_{} m; // [esp+0h] [ebp-144h]
  interface_{} keya; // [esp+4h] [ebp-140h]
  char *key; // [esp+4h] [ebp-140h]
  string keyb[5]; // [esp+4h] [ebp-140h]
  reflect_nameOff keyc; // [esp+4h] [ebp-140h]
  string keyd[3]; // [esp+4h] [ebp-140h]
  runtime_slice_0 keye; // [esp+4h] [ebp-140h]
  string keyf[2]; // [esp+4h] [ebp-140h]
  interface_{} key_4; // [esp+8h] [ebp-13Ch]
  runtime_eface_0 key_4a; // [esp+8h] [ebp-13Ch]
  interface_{} key_4b; // [esp+8h] [ebp-13Ch]
  runtime_eface_0 key_4c; // [esp+8h] [ebp-13Ch]
  interface_{} key_4d; // [esp+8h] [ebp-13Ch]
  interface_{} value; // [esp+Ch] [ebp-138h]
  uint8 *valuea; // [esp+Ch] [ebp-138h]
  bool v62; // [esp+14h] [ebp-130h]
  char v63; // [esp+14h] [ebp-130h]
  interface_{} v64; // [esp+14h] [ebp-130h]
  uint8 *v65; // [esp+14h] [ebp-130h]
  runtime_slice_0 v66; // [esp+14h] [ebp-130h]
  reflect_name_0 v67; // [esp+1Ch] [ebp-128h]
  string v68; // [esp+1Ch] [ebp-128h]
  string n; // [esp+2Ch] [ebp-118h]
  __int32 _r0_len; // [esp+34h] [ebp-110h]
  uintptr offseta; // [esp+38h] [ebp-10Ch]
  uintptr offset; // [esp+38h] [ebp-10Ch]
  uint32 argN; // [esp+3Ch] [ebp-108h]
  uintptr v74; // [esp+40h] [ebp-104h]
  uintptr v75; // [esp+40h] [ebp-104h]
  int v76; // [esp+44h] [ebp-100h]
  int v77; // [esp+4Ch] [ebp-F8h]
  __int32 v78; // [esp+4Ch] [ebp-F8h]
  uint8 buf[32]; // [esp+50h] [ebp-F4h] BYREF
  uint8 v80[32]; // [esp+70h] [ebp-D4h] BYREF
  reflect_rtype *x; // [esp+90h] [ebp-B4h]
  reflect_rtype *res; // [esp+94h] [ebp-B0h]
  uint8 *lti_type; // [esp+98h] [ebp-ACh]
  uint8 *lti_type_0; // [esp+9Ch] [ebp-A8h]
  reflect_bitVector *bv; // [esp+A0h] [ebp-A4h]
  reflect_rtype *arg; // [esp+A4h] [ebp-A0h]
  void *v87; // [esp+A8h] [ebp-9Ch]
  uintptr *dst; // [esp+ACh] [ebp-98h]
  _DWORD *v89; // [esp+B0h] [ebp-94h]
  interface_{} v90; // [esp+B4h] [ebp-90h]
  void *data; // [esp+BCh] [ebp-88h]
  reflect_rtype **v92; // [esp+C0h] [ebp-84h]
  reflect_rtype **v93; // [esp+C4h] [ebp-80h]
  int v94[2]; // [esp+C8h] [ebp-7Ch] BYREF
  int elem[2]; // [esp+D0h] [ebp-74h] BYREF
  string v96; // [esp+D8h] [ebp-6Ch] BYREF
  int v97[5]; // [esp+11Ch] [ebp-28h] BYREF

  while ( (unsigned int)&v80[16] <= *(_DWORD *)(*(_DWORD *)(__readgsdword(0) - 4) + 8) )
    runtime_morestack_noctxt();
  if ( (t->kind & 0x1F) != 19 )
  {
    m._type = (runtime__type_0 *)&::t;
    m.data = &reflect_statictmp_61;
    runtime_gopanic(m);
    BUG();
  }
  if ( rcvr && (rcvr->kind & 0x1F) == 20 )
  {
    keyf[0] = reflect___ptr_rtype__String(rcvr);
    len = keyf[0].len;
    str = keyf[0].str;
    keyf[0].str = (uint8 *)"reflect: funcLayout with interface receiver ";
    keyf[0].len = 44;
    keyf[1] = (string)__PAIR64__(len, (unsigned int)str);
    v96 = runtime_concatstring2(0, *(string (*)[2])&keyf[0].str);
    runtime_convT2Estring((runtime__type_0 *)&::t, &v96, key_4c);
    runtime_gopanic(key_4d);
    BUG();
  }
  v94[0] = (int)t;
  v94[1] = (int)rcvr;
  keya._type = (runtime__type_0 *)&stru_80D3500;
  keya.data = v94;
  sync___ptr_Map__Load(&reflect_layoutCache, keya, value, v62);
  if ( v63 )
  {
    lti_type_0 = valuea;
    ((void (*)(void))loc_808FD8B)();
    if ( lti_type_0 != (uint8 *)&stru_80D7D20 )
      runtime_panicdottypeE(
        (runtime__type_0 *)lti_type_0,
        (runtime__type_0 *)&stru_80D7D20,
        (runtime__type_0 *)&stru_80CECA0);
    ((void (*)(void))loc_809026E)();
    ((void (*)(void))loc_809026E)();
  }
  else
  {
    key = (char *)runtime_newobject((runtime__type_0 *)&stru_80D31A0);
    v7 = (reflect_bitVector *)key;
    bv = (reflect_bitVector *)key;
    if ( rcvr )
    {
      kind = rcvr->kind;
      if ( (kind & 0x20) == 0 || kind >= 0 )
      {
        if ( (*(_DWORD *)key & 7) == 0 )
        {
          v9 = *((_DWORD *)key + 2);
          v10 = (void *)*((_DWORD *)key + 1);
          v11 = *((_DWORD *)key + 3);
          if ( v9 + 1 > v11 )
          {
            dst = (uintptr *)(key + 4);
            keye.array = v10;
            *(_QWORD *)&keye.len = __PAIR64__(v11, v9);
            v66 = runtime_growslice((runtime__type_0 *)&i, keye, v9 + 1);
            array = v66.array;
            v43 = v66.len;
            v44 = bv;
            bv->data.cap = v66.cap;
            if ( *(_DWORD *)&runtime_writeBarrier.enabled )
            {
              v87 = v66.array;
              runtime_writebarrierptr(dst, (uintptr)v66.array);
              array = v87;
              v43 = v66.len;
            }
            else
            {
              v44->data.array = (uint8 *)v66.array;
            }
            v9 = v43;
            v10 = array;
            v7 = bv;
          }
          v7->data.len = v9 + 1;
          *((_BYTE *)v10 + v9) = 0;
        }
        v12 = v7->n >> 3;
        if ( v12 >= v7->data.len )
          runtime_panicindex();
        v7->data.array[v12] |= 1 << (v7->n++ & 7);
      }
      v13 = 4;
    }
    else
    {
      v13 = 0;
    }
    v14 = t;
    if ( (t->tflag & 1) != 0 )
      v15 = 52;
    else
      v15 = 36;
    v16 = (reflect_rtype **)((char *)t + v15);
    size_low = LOWORD(t[1].size);
    v77 = size_low;
    v18 = 0;
    while ( v18 < size_low )
    {
      v93 = v16;
      arg = *v16;
      offseta = v13 + (-v13 & (unsigned __int8)(arg->align - 1));
      reflect_addTypeBits(v7, offseta, arg);
      v16 = v93 + 1;
      ++v18;
      v13 = arg->size + offseta;
      v7 = bv;
      v14 = t;
      size_low = v77;
    }
    v19 = v13;
    v20 = v13 + (-v13 & 3);
    if ( (v14->tflag & 1) != 0 )
      v21 = 52;
    else
      v21 = 36;
    v76 = v19;
    v22 = (char *)v14 + v21;
    v23 = HIWORD(v14[1].size) & 0x7FFF;
    size = v14[1].size;
    v25 = size;
    v26 = (unsigned __int16)(v23 + size);
    if ( v25 > v26 )
      runtime_panicslice();
    argN = v7->n;
    offset = v20;
    v27 = v26 - v25;
    _r0_len = v27;
    v28 = (reflect_rtype **)&v22[((int)(v25 - 0x100000) >> 31) & (4 * v25)];
    v29 = 0;
    while ( v29 < v27 )
    {
      v92 = v28;
      res = *v28;
      v74 = v20 + (-v20 & (unsigned __int8)(res->align - 1));
      reflect_addTypeBits(v7, v74, res);
      v28 = v92 + 1;
      ++v29;
      v20 = res->size + v74;
      v7 = bv;
      v27 = _r0_len;
    }
    v75 = v20;
    v30 = runtime_newobject((runtime__type_0 *)&stru_80DABC0);
    x = (reflect_rtype *)v30;
    *((_BYTE *)v30 + 13) = 4;
    *(_DWORD *)v30 = v75 + (-v75 & 3);
    v31 = bv;
    *((_DWORD *)v30 + 1) = 4 * bv->n;
    if ( v31->n )
    {
      v32 = (uintptr)v31->data.array;
      if ( !v31->data.len )
        runtime_panicindex();
      if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      {
        runtime_writebarrierptr((uintptr *)v30 + 5, v32);
        v33 = rcvr;
        v34 = rcvr == 0;
        v31 = bv;
      }
      else
      {
        *((_DWORD *)v30 + 5) = v32;
        v33 = rcvr;
        v34 = rcvr == 0;
      }
    }
    else
    {
      *((_BYTE *)v30 + 15) |= 0x80u;
      v33 = rcvr;
      v34 = rcvr == 0;
    }
    v31->n = argN;
    if ( v34 )
    {
      keyd[0] = reflect___ptr_rtype__String(t);
      v40 = keyd[0].len;
      v41 = keyd[0].str;
      keyd[0].str = (uint8 *)"funcargs(";
      keyd[0].len = 9;
      keyd[1] = (string)__PAIR64__(v40, (unsigned int)v41);
      keyd[2].str = (uint8 *)")";
      keyd[2].len = 1;
      v68 = runtime_concatstring3((uint8 (*)[32])v80, *(string (*)[3])&keyd[0].str);
      v36 = v68.len;
      v37 = v68.str;
    }
    else
    {
      keyb[0] = reflect___ptr_rtype__String(v33);
      v78 = keyb[0].len;
      data = keyb[0].str;
      v35 = reflect___ptr_rtype__String(t);
      keyb[0].str = (uint8 *)"methodargs(";
      keyb[0].len = 11;
      keyb[1] = (string)__PAIR64__(v78, (unsigned int)data);
      keyb[2].str = (uint8 *)")(";
      keyb[2].len = 2;
      keyb[3] = v35;
      keyb[4].str = (uint8 *)")";
      keyb[4].len = 1;
      n = runtime_concatstring5((uint8 (*)[32])buf, *(string (*)[5])&keyb[0].str);
      v36 = n.len;
      v37 = n.str;
    }
    v67.bytes = reflect_newName((string)__PAIR64__(v36, (unsigned int)v37), 0LL, 0LL, 0).bytes;
    keyc = reflect_resolveReflectName(v67);
    x->str = keyc;
    v90.data = runtime_newobject((runtime__type_0 *)&stru_80D73A0);
    v38 = runtime_newobject((runtime__type_0 *)&stru_80D1160);
    *v38 = reflect_funcLayout_func1;
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
    {
      v89 = v38;
      runtime_writebarrierptr(v38 + 1, (uintptr)x);
      v38 = v89;
    }
    else
    {
      v38[1] = x;
    }
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr((uintptr *)v90.data + 2, (uintptr)v38);
    else
      *((_DWORD *)v90.data + 2) = v38;
    elem[0] = (int)t;
    elem[1] = (int)rcvr;
    ((void (*)(void))loc_809026E)();
    v97[0] = (int)x;
    v97[1] = v76;
    v97[2] = offset;
    v97[3] = (int)bv;
    v97[4] = v39;
    runtime_convT2E((runtime__type_0 *)&stru_80D3500, elem, key_4);
    data = key_4a.data;
    v90._type = key_4a._type;
    runtime_convT2E((runtime__type_0 *)&stru_80D7D20, v97, key_4a);
    sync___ptr_Map__LoadOrStore(
      &reflect_layoutCache,
      (interface_{})__PAIR64__((unsigned int)data, (unsigned int)v90._type),
      key_4b,
      v64,
      (bool)v67.bytes);
    lti_type = v65;
    ((void (*)(void))loc_808FD8B)();
    if ( lti_type != (uint8 *)&stru_80D7D20 )
      runtime_panicdottypeE(
        (runtime__type_0 *)lti_type,
        (runtime__type_0 *)&stru_80D7D20,
        (runtime__type_0 *)&stru_80CECA0);
    ((void (*)(void))loc_809026E)();
    ((void (*)(void))loc_809026E)();
  }
}
// 80AAA10: could not find valid save-restore pair for ebx
// 80AAA10: could not find valid save-restore pair for ebp
// 80AAC36: conditional instruction was optimized away because ebp.4<10000u
// 80AAA91: variable 'value' is possibly undefined
// 80AAA91: variable 'v62' is possibly undefined
// 80AAAA5: variable 'v63' is possibly undefined
// 80AAF0D: variable 'v39' is possibly undefined
// 80AAF28: variable 'key_4' is possibly undefined
// 80AAF31: variable 'key_4a' is possibly undefined
// 80AAF8B: variable 'key_4b' is possibly undefined
// 80AAF8B: variable 'v64' is possibly undefined
// 80AAF98: variable 'v65' is possibly undefined
// 80AB1D0: variable 'valuea' is possibly undefined
// 80AB312: variable 'key_4c' is possibly undefined
// 80AB326: variable 'key_4d' is possibly undefined
// 80E0D86: using guessed type char asc_80E0D86;

//----- (080AB360) --------------------------------------------------------
void __golang reflect_addTypeBits(reflect_bitVector *bv, uintptr offset, reflect_rtype *t)
{
  reflect_rtype *v3; // eax
  signed __int8 kind; // dl
  unsigned int v5; // edx
  reflect_bitVector *v6; // eax
  uint32 v7; // edx
  uint8 *v8; // edx
  __int32 v9; // ebx
  __int32 v10; // esi
  uint8 *v11; // eax
  __int32 v12; // ecx
  __int32 v13; // edx
  __int32 v14; // ebx
  uint8 *v15; // ebp
  unsigned __int32 v16; // ecx
  uint8 *v17; // eax
  __int32 v18; // ecx
  reflect_bitVector *v19; // ebx
  reflect_bitVector *v20; // eax
  uint32 n; // edx
  uint8 *array; // edx
  __int32 len; // ebx
  __int32 cap; // esi
  uint8 *v25; // eax
  __int32 v26; // ecx
  uint8 *v27; // edx
  __int32 v28; // ebx
  __int32 v29; // ebp
  unsigned __int32 v30; // ecx
  int v31; // edx
  __int32 v32; // edx
  __int32 v33; // ebx
  uint8 *v34; // ebp
  unsigned __int32 v35; // ecx
  uint8 *v36; // eax
  __int32 v37; // ecx
  reflect_bitVector *v38; // ebx
  uint8 *v39; // eax
  __int32 v40; // ecx
  __int32 v41; // ecx
  signed __int32 hash; // ecx
  __int32 v43; // edx
  runtime_slice_0 old; // [esp+4h] [ebp-40h]
  runtime_slice_0 olda; // [esp+4h] [ebp-40h]
  runtime_slice_0 oldb; // [esp+4h] [ebp-40h]
  runtime_slice_0 oldc; // [esp+4h] [ebp-40h]
  runtime_slice_0 oldd; // [esp+4h] [ebp-40h]
  runtime_slice_0 src; // [esp+14h] [ebp-30h]
  runtime_slice_0 srca; // [esp+14h] [ebp-30h]
  runtime_slice_0 srcb; // [esp+14h] [ebp-30h]
  runtime_slice_0 srcc; // [esp+14h] [ebp-30h]
  runtime_slice_0 srcd; // [esp+14h] [ebp-30h]
  __int32 i; // [esp+20h] [ebp-24h]
  __int32 i_0; // [esp+24h] [ebp-20h]
  signed __int32 v56; // [esp+30h] [ebp-14h]
  uintptr *dst; // [esp+40h] [ebp-4h]

  v3 = t;
  kind = t->kind;
  if ( kind < 0 )
    return;
  v5 = kind & 0x1F;
  if ( v5 <= 0x14 )
  {
    if ( v5 == 17 )
    {
      v41 = 0;
      while ( v41 < (signed __int32)v3[1].hash )
      {
        i = v41;
        reflect_addTypeBits(bv, offset + v41 * *(_DWORD *)v3[1].size, (reflect_rtype *)v3[1].size);
        v41 = i + 1;
        v3 = t;
      }
      return;
    }
    if ( v5 - 18 > 1 )
    {
      if ( v5 == 20 )
      {
        while ( 1 )
        {
          v20 = bv;
          n = bv->n;
          if ( bv->n >= offset >> 2 )
            break;
          if ( (n & 7) == 0 )
          {
            array = bv->data.array;
            len = bv->data.len;
            cap = bv->data.cap;
            if ( len + 1 > cap )
            {
              oldb.array = bv->data.array;
              *(_QWORD *)&oldb.len = __PAIR64__(cap, len);
              srcb = runtime_growslice((runtime__type_0 *)&::i, oldb, len + 1);
              v25 = (uint8 *)srcb.array;
              v26 = srcb.len;
              bv->data.cap = srcb.cap;
              if ( *(_DWORD *)&runtime_writeBarrier.enabled )
              {
                runtime_writebarrierptr((uintptr *)&bv->data, (uintptr)srcb.array);
                v25 = (uint8 *)srcb.array;
                v26 = srcb.len;
              }
              else
              {
                bv->data.array = (uint8 *)srcb.array;
              }
              len = v26;
              array = v25;
              v20 = bv;
            }
            v20->data.len = len + 1;
            array[len] = 0;
          }
          if ( v20->n >> 3 >= v20->data.len )
            runtime_panicindex();
          ++v20->n;
        }
        if ( (n & 7) == 0 )
        {
          v27 = bv->data.array;
          v28 = bv->data.len;
          v29 = bv->data.cap;
          if ( v28 + 1 > v29 )
          {
            oldd.array = bv->data.array;
            *(_QWORD *)&oldd.len = __PAIR64__(v29, v28);
            srcd = runtime_growslice((runtime__type_0 *)&::i, oldd, v28 + 1);
            v39 = (uint8 *)srcd.array;
            v40 = srcd.len;
            bv->data.cap = srcd.cap;
            if ( *(_DWORD *)&runtime_writeBarrier.enabled )
            {
              runtime_writebarrierptr((uintptr *)&bv->data, (uintptr)srcd.array);
              v39 = (uint8 *)srcd.array;
              v40 = srcd.len;
            }
            else
            {
              bv->data.array = (uint8 *)srcd.array;
            }
            v28 = v40;
            v27 = v39;
            v20 = bv;
          }
          v20->data.len = v28 + 1;
          v27[v28] = 0;
        }
        v30 = v20->n >> 3;
        if ( v30 >= v20->data.len )
          runtime_panicindex();
        dst = (uintptr *)&v20->data;
        v20->data.array[v30] |= 1 << (v20->n & 7);
        v31 = v20->n + 1;
        v20->n = v31;
        if ( (v31 & 7) == 0 )
        {
          v32 = v20->data.cap;
          v33 = v20->data.len;
          v34 = v20->data.array;
          if ( v33 + 1 > v32 )
          {
            oldc.array = v20->data.array;
            *(_QWORD *)&oldc.len = __PAIR64__(v32, v33);
            srcc = runtime_growslice((runtime__type_0 *)&::i, oldc, v33 + 1);
            v36 = (uint8 *)srcc.array;
            v37 = srcc.len;
            v38 = bv;
            bv->data.cap = srcc.cap;
            if ( *(_DWORD *)&runtime_writeBarrier.enabled )
            {
              runtime_writebarrierptr(dst, (uintptr)srcc.array);
              v36 = (uint8 *)srcc.array;
              v37 = srcc.len;
              v38 = bv;
            }
            else
            {
              bv->data.array = (uint8 *)srcc.array;
            }
            v34 = v36;
            v20 = v38;
            v33 = v37;
          }
          v20->data.len = v33 + 1;
          v34[v33] = 0;
        }
        v35 = v20->n >> 3;
        if ( v35 >= v20->data.len )
          runtime_panicindex();
        v20->data.array[v20->n >> 3] = (1 << (v20->n & 7)) | v20->data.array[v35];
        ++v20->n;
      }
      return;
    }
    goto LABEL_7;
  }
  if ( v5 - 21 <= 3 )
  {
LABEL_7:
    while ( 1 )
    {
      v6 = bv;
      v7 = bv->n;
      if ( bv->n >= offset >> 2 )
        break;
      if ( (v7 & 7) == 0 )
      {
        v8 = bv->data.array;
        v9 = bv->data.len;
        v10 = bv->data.cap;
        if ( v9 + 1 > v10 )
        {
          old.array = bv->data.array;
          *(_QWORD *)&old.len = __PAIR64__(v10, v9);
          src = runtime_growslice((runtime__type_0 *)&::i, old, v9 + 1);
          v11 = (uint8 *)src.array;
          v12 = src.len;
          bv->data.cap = src.cap;
          if ( *(_DWORD *)&runtime_writeBarrier.enabled )
          {
            runtime_writebarrierptr((uintptr *)&bv->data, (uintptr)src.array);
            v11 = (uint8 *)src.array;
            v12 = src.len;
          }
          else
          {
            bv->data.array = (uint8 *)src.array;
          }
          v9 = v12;
          v8 = v11;
          v6 = bv;
        }
        v6->data.len = v9 + 1;
        v8[v9] = 0;
      }
      if ( v6->n >> 3 >= v6->data.len )
        runtime_panicindex();
      ++v6->n;
    }
    if ( (v7 & 7) == 0 )
    {
      v13 = bv->data.len;
      v14 = bv->data.cap;
      v15 = bv->data.array;
      if ( v13 + 1 > v14 )
      {
        olda.array = bv->data.array;
        *(_QWORD *)&olda.len = __PAIR64__(v14, v13);
        srca = runtime_growslice((runtime__type_0 *)&::i, olda, v13 + 1);
        v17 = (uint8 *)srca.array;
        v18 = srca.len;
        v19 = bv;
        bv->data.cap = srca.cap;
        if ( *(_DWORD *)&runtime_writeBarrier.enabled )
        {
          runtime_writebarrierptr((uintptr *)&bv->data, (uintptr)srca.array);
          v17 = (uint8 *)srca.array;
          v18 = srca.len;
          v19 = bv;
        }
        else
        {
          bv->data.array = (uint8 *)srca.array;
        }
        v13 = v18;
        v15 = v17;
        v6 = v19;
      }
      v6->data.len = v13 + 1;
      v15[v13] = 0;
    }
    v16 = v6->n >> 3;
    if ( v16 >= v6->data.len )
      runtime_panicindex();
    v6->data.array[v6->n >> 3] = (1 << (v6->n & 7)) | v6->data.array[v16];
    ++v6->n;
    return;
  }
  if ( v5 != 25 )
  {
    if ( v5 != 26 )
      return;
    goto LABEL_7;
  }
  hash = t[1].hash;
  v56 = hash;
  v43 = 0;
  while ( v43 < hash )
  {
    if ( v43 >= v3[1].hash )
      runtime_panicindex();
    i_0 = v43;
    reflect_addTypeBits(
      bv,
      offset + (*(_DWORD *)(v3[1].ptrdata + 12 * v43 + 8) >> 1),
      *(reflect_rtype **)(v3[1].ptrdata + 12 * v43 + 4));
    v43 = i_0 + 1;
    v3 = t;
    hash = v56;
  }
}

//----- (080AB8B0) --------------------------------------------------------
void *__golang reflect_Value_pointer(reflect_Value_0 v)
{
  interface_{} e; // [esp+0h] [ebp-8h]

  if ( v.typ->size != 4 || (v.typ->kind & 0x80u) != 0 )
  {
    e._type = (runtime__type_0 *)&t;
    e.data = &reflect_statictmp_63;
    runtime_gopanic(e);
    BUG();
  }
  if ( (v.flag & 0x80) != 0 )
    return *(void **)v.ptr;
  else
    return v.ptr;
}

//----- (080AB920) --------------------------------------------------------
interface_{} __golang reflect_packEface(reflect_Value_0 v)
{
  runtime__type_0 *v1; // eax
  void *ptr; // ecx
  interface_{} typ; // [esp+0h] [ebp-18h]
  void *c; // [esp+Ch] [ebp-Ch]
  void *i_4; // [esp+14h] [ebp-4h]
  interface_{} _r1; // [esp+28h] [ebp+10h]

  v1 = (runtime__type_0 *)v.typ;
  if ( (v.typ->kind & 0x20) != 0 )
  {
    if ( (v.flag & 0x80) != 0 )
      i_4 = *(void **)v.ptr;
    else
      i_4 = v.ptr;
  }
  else
  {
    if ( (v.flag & 0x80) == 0 )
    {
      typ._type = (runtime__type_0 *)&t;
      typ.data = &reflect_statictmp_64;
      runtime_gopanic(typ);
      BUG();
    }
    if ( (v.flag & 0x100) != 0 )
    {
      c = reflect_unsafe_New((runtime__type_0 *)v.typ);
      reflect_typedmemmove((runtime__type_0 *)v.typ, c, v.ptr);
      v1 = (runtime__type_0 *)v.typ;
      ptr = c;
    }
    else
    {
      ptr = v.ptr;
    }
    i_4 = ptr;
  }
  _r1._type = v1;
  _r1.data = i_4;
  return _r1;
}

//----- (080ABA00) --------------------------------------------------------
string __golang reflect___ptr_ValueError__Error(reflect_ValueError *e)
{
  uint8 *str; // eax
  __int32 len; // ecx
  string v3; // kr00_8
  string v4; // kr08_8
  string v5; // kr10_8
  string a[3]; // [esp+4h] [ebp-30h]
  string aa[5]; // [esp+4h] [ebp-30h]

  if ( e->Kind )
  {
    v4 = reflect_Kind_String(e->Kind);
    aa[1] = e->Method;
    aa[0].str = (uint8 *)"reflect: call of ";
    aa[0].len = 17;
    aa[2].str = (uint8 *)" on ";
    aa[2].len = 4;
    aa[3] = v4;
    aa[4].str = (uint8 *)" Value";
    aa[4].len = 6;
    v5 = runtime_concatstring5(0, *(string (*)[5])&aa[0].str);
    len = v5.len;
    str = v5.str;
  }
  else
  {
    a[1] = e->Method;
    a[0].str = (uint8 *)"reflect: call of ";
    a[0].len = 17;
    a[2].str = (uint8 *)" on zero Value";
    a[2].len = 14;
    v3 = runtime_concatstring3(0, *(string (*)[3])&a[0].str);
    len = v3.len;
    str = v3.str;
  }
  return (string)__PAIR64__(len, (unsigned int)str);
}
// 80ABA00: could not find valid save-restore pair for ebx

//----- (080ABB00) --------------------------------------------------------
string __golang reflect_methodName()
{
  uintptr pc; // [esp+4h] [ebp-14h]
  uintptr pcb; // [esp+4h] [ebp-14h]
  runtime_Func *pca; // [esp+4h] [ebp-14h]
  string v3; // [esp+8h] [ebp-10h]
  __int32 v4; // [esp+10h] [ebp-8h]
  bool v5; // [esp+14h] [ebp-4h]
  string _r0; // [esp+1Ch] [ebp+4h]

  runtime_Caller(2, pc, v3, v4, v5);
  pca = runtime_FuncForPC(pcb);
  if ( pca )
    return runtime___ptr_Func__Name(pca);
  _r0.str = (uint8 *)"unknown method";
  _r0.len = 14;
  return _r0;
}
// 80ABB1C: variable 'pc' is possibly undefined
// 80ABB1C: variable 'v3' is possibly undefined
// 80ABB1C: variable 'v4' is possibly undefined
// 80ABB1C: variable 'v5' is possibly undefined
// 80ABB28: variable 'pcb' is possibly undefined

//----- (080ABB70) --------------------------------------------------------
void __golang reflect_flag_mustBe(reflect_flag f, reflect_Kind expected)
{
  uintptr *v2; // eax
  string typ; // [esp+0h] [ebp-18h]
  interface_{} typa; // [esp+0h] [ebp-18h]
  uintptr *v5; // [esp+10h] [ebp-8h]
  uint8 *src; // [esp+14h] [ebp-4h]

  if ( (f & 0x1F) != expected )
  {
    typ = reflect_methodName();
    src = typ.str;
    v2 = (uintptr *)runtime_newobject((runtime__type_0 *)&stru_80D3140);
    v5 = v2;
    v2[1] = typ.len;
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr(v2, (uintptr)src);
    else
      *v2 = (uintptr)src;
    v5[2] = f & 0x1F;
    typa._type = (runtime__type_0 *)&stru_80D0760;
    typa.data = v5;
    runtime_gopanic(typa);
    BUG();
  }
}

//----- (080ABC20) --------------------------------------------------------
void __golang reflect_flag_mustBeAssignable(reflect_flag f)
{
  uintptr *v1; // eax
  unsigned int v2; // ecx
  unsigned int v3; // ecx
  string typ; // [esp+0h] [ebp-40h]
  interface_{} typa; // [esp+0h] [ebp-40h]
  _BYTE typb[28]; // [esp+0h] [ebp-40h]
  _BYTE typc[28]; // [esp+0h] [ebp-40h]
  runtime_eface_0 e; // [esp+8h] [ebp-38h]
  interface_{} ea; // [esp+8h] [ebp-38h]
  runtime_eface_0 eb; // [esp+8h] [ebp-38h]
  interface_{} ec; // [esp+8h] [ebp-38h]
  uint8 *src; // [esp+28h] [ebp-18h]
  uintptr *v13; // [esp+2Ch] [ebp-14h]
  string elem; // [esp+30h] [ebp-10h] BYREF
  string v15; // [esp+38h] [ebp-8h] BYREF

  if ( !f )
  {
    typ = reflect_methodName();
    src = typ.str;
    v1 = (uintptr *)runtime_newobject((runtime__type_0 *)&stru_80D3140);
    v13 = v1;
    v1[1] = typ.len;
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr(v1, (uintptr)src);
    else
      *v1 = (uintptr)src;
    v13[2] = 0;
    typa._type = (runtime__type_0 *)&stru_80D0760;
    typa.data = v13;
    runtime_gopanic(typa);
    BUG();
  }
  if ( (f & 0x60) != 0 )
  {
    *(string *)typc = reflect_methodName();
    v3 = *(_DWORD *)&typc[4];
    *(_DWORD *)&typc[4] = "reflect: ";
    *(_DWORD *)&typc[8] = 9;
    *(_QWORD *)&typc[12] = __PAIR64__(v3, *(unsigned int *)typc);
    *(_DWORD *)&typc[20] = " using value obtained using unexported field";
    *(_DWORD *)&typc[24] = 44;
    v15 = runtime_concatstring3(0, *(string (*)[3])&typc[4]);
    runtime_convT2Estring((runtime__type_0 *)&t, &v15, eb);
    runtime_gopanic(ec);
    BUG();
  }
  if ( (f & 0x100) == 0 )
  {
    *(string *)typb = reflect_methodName();
    v2 = *(_DWORD *)&typb[4];
    *(_DWORD *)&typb[4] = "reflect: ";
    *(_DWORD *)&typb[8] = 9;
    *(_QWORD *)&typb[12] = __PAIR64__(v2, *(unsigned int *)typb);
    *(_DWORD *)&typb[20] = " using unaddressable value";
    *(_DWORD *)&typb[24] = 26;
    elem = runtime_concatstring3(0, *(string (*)[3])&typb[4]);
    runtime_convT2Estring((runtime__type_0 *)&t, &elem, e);
    runtime_gopanic(ea);
    BUG();
  }
}
// 80ABD2E: variable 'e' is possibly undefined
// 80ABD42: variable 'ea' is possibly undefined
// 80ABDAE: variable 'eb' is possibly undefined
// 80ABDC2: variable 'ec' is possibly undefined

//----- (080ABDE0) --------------------------------------------------------
bool __golang reflect_Value_Bool(reflect_Value_0 v)
{
  reflect_flag_mustBe(v.flag, 1u);
  return *(_BYTE *)v.ptr;
}

//----- (080ABE20) --------------------------------------------------------
__uint8 __golang reflect_Value_Bytes(reflect_Value_0 v)
{
  interface_{} f; // [esp+0h] [ebp-Ch]
  reflect_Type_0 expected; // [esp+4h] [ebp-8h]
  __uint8 _r0; // [esp+1Ch] [ebp+10h]

  reflect_flag_mustBe(v.flag, 0x17u);
  expected = reflect___ptr_rtype__Elem(v.typ);
  if ( ((int (__golang *)(void *))expected.tab[3].hash)(expected.data) != 8 )
  {
    f._type = (runtime__type_0 *)&t;
    f.data = &reflect_statictmp_66;
    runtime_gopanic(f);
    BUG();
  }
  _r0.array = *(uint8 **)v.ptr;
  _r0.len = *((_DWORD *)v.ptr + 1);
  _r0.cap = *((_DWORD *)v.ptr + 2);
  return _r0;
}

//----- (080ABEB0) --------------------------------------------------------
__int32 __golang reflect_Value_runes(reflect_Value_0 v)
{
  interface_{} f; // [esp+0h] [ebp-Ch]
  reflect_Type_0 expected; // [esp+4h] [ebp-8h]
  __int32 _r0; // [esp+1Ch] [ebp+10h]

  reflect_flag_mustBe(v.flag, 0x17u);
  expected = reflect___ptr_rtype__Elem(v.typ);
  if ( ((int (__golang *)(void *))expected.tab[3].hash)(expected.data) != 5 )
  {
    f._type = (runtime__type_0 *)&t;
    f.data = &reflect_statictmp_67;
    runtime_gopanic(f);
    BUG();
  }
  _r0.array = *(int32 **)v.ptr;
  _r0.len = *((_DWORD *)v.ptr + 1);
  _r0.cap = *((_DWORD *)v.ptr + 2);
  return _r0;
}

//----- (080ABF40) --------------------------------------------------------
void __golang reflect_methodReceiver(
        string op,
        reflect_Value_0 v,
        __int32 methodIndex,
        reflect_rtype *rcvrtype,
        reflect_rtype *t,
        void *fn)
{
  uint16 mcount; // cx
  char *v7; // eax
  interface_{} buf; // [esp+0h] [ebp-54h]
  interface_{} bufa; // [esp+0h] [ebp-54h]
  reflect_uncommonType *off; // [esp+4h] [ebp-50h]
  string offa[3]; // [esp+4h] [ebp-50h]
  string offb[3]; // [esp+4h] [ebp-50h]
  string offc[3]; // [esp+4h] [ebp-50h]
  void *src; // [esp+8h] [ebp-4Ch]
  runtime_eface_0 srca; // [esp+8h] [ebp-4Ch]
  interface_{} srcb; // [esp+8h] [ebp-4Ch]
  runtime_eface_0 srcc; // [esp+8h] [ebp-4Ch]
  interface_{} srcd; // [esp+8h] [ebp-4Ch]
  runtime_eface_0 srce; // [esp+8h] [ebp-4Ch]
  interface_{} srcf; // [esp+8h] [ebp-4Ch]
  reflect_typeOff m_mtyp; // [esp+24h] [ebp-30h]
  reflect_textOff m_ifn; // [esp+28h] [ebp-2Ch]
  uintptr ptrdata; // [esp+34h] [ebp-20h]
  void **_ifn; // [esp+38h] [ebp-1Ch]
  string elem; // [esp+3Ch] [ebp-18h] BYREF
  string v26; // [esp+44h] [ebp-10h] BYREF
  string v27; // [esp+4Ch] [ebp-8h] BYREF

  if ( (v.typ->kind & 0x1F) == 20 )
  {
    if ( methodIndex >= v.typ[1].hash )
    {
      bufa._type = (runtime__type_0 *)&::t;
      bufa.data = &reflect_statictmp_79;
      runtime_gopanic(bufa);
      BUG();
    }
    ptrdata = v.typ[1].ptrdata;
    if ( (*reflect___ptr_rtype__nameOff(v.typ, *(_DWORD *)(ptrdata + 8 * methodIndex)).bytes & 1) == 0 )
    {
      offc[0].str = (uint8 *)"reflect: ";
      offc[0].len = 9;
      offc[1].str = op.str;
      *(_QWORD *)&offc[1].len = __PAIR64__(" of unexported method", op.len);
      offc[2].len = 21;
      v27 = runtime_concatstring3(0, *(string (*)[3])&offc[0].str);
      runtime_convT2Estring((runtime__type_0 *)&::t, &v27, srce);
      runtime_gopanic(srcf);
      BUG();
    }
    if ( !*(_DWORD *)v.ptr )
    {
      offb[0].str = (uint8 *)"reflect: ";
      offb[0].len = 9;
      offb[1].str = op.str;
      *(_QWORD *)&offb[1].len = __PAIR64__(" of method on nil interface value", op.len);
      offb[2].len = 33;
      v26 = runtime_concatstring3(0, *(string (*)[3])&offb[0].str);
      runtime_convT2Estring((runtime__type_0 *)&::t, &v26, srcc);
      runtime_gopanic(srcd);
      BUG();
    }
    if ( (unsigned int)methodIndex >= 0x186A0 )
      runtime_panicindex();
    reflect___ptr_rtype__typeOff(v.typ, *(_DWORD *)(ptrdata + 8 * methodIndex + 4));
  }
  else
  {
    off = reflect___ptr_rtype__uncommon(v.typ);
    if ( !off || (mcount = off->mcount, methodIndex >= (unsigned int)mcount) )
    {
      buf._type = (runtime__type_0 *)&::t;
      buf.data = &reflect_statictmp_80;
      runtime_gopanic(buf);
      BUG();
    }
    v7 = (char *)off + off->moff;
    if ( methodIndex >= (unsigned int)mcount )
      runtime_panicindex();
    m_mtyp = *(_DWORD *)&v7[16 * methodIndex + 4];
    m_ifn = *(_DWORD *)&v7[16 * methodIndex + 8];
    if ( (*reflect___ptr_rtype__nameOff(v.typ, *(_DWORD *)&v7[16 * methodIndex]).bytes & 1) == 0 )
    {
      offa[0].str = (uint8 *)"reflect: ";
      offa[0].len = 9;
      offa[1].str = op.str;
      *(_QWORD *)&offa[1].len = __PAIR64__(" of unexported method", op.len);
      offa[2].len = 21;
      elem = runtime_concatstring3(0, *(string (*)[3])&offa[0].str);
      runtime_convT2Estring((runtime__type_0 *)&::t, &elem, srca);
      runtime_gopanic(srcb);
      BUG();
    }
    _ifn = (void **)runtime_newobject((runtime__type_0 *)&x);
    src = reflect___ptr_rtype__textOff(v.typ, m_ifn);
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr((uintptr *)_ifn, (uintptr)src);
    else
      *_ifn = src;
    reflect___ptr_rtype__typeOff(v.typ, m_mtyp);
  }
}
// 80AC158: variable 'srca' is possibly undefined
// 80AC16C: variable 'srcb' is possibly undefined
// 80AC203: variable 'srcc' is possibly undefined
// 80AC217: variable 'srcd' is possibly undefined
// 80AC27F: variable 'srce' is possibly undefined
// 80AC293: variable 'srcf' is possibly undefined

//----- (080AC2C0) --------------------------------------------------------
void __golang reflect_callMethod(reflect_methodValue *ctxt, void *frame)
{
  int v2; // ecx
  reflect_methodValue ***v3; // ebx
  char *v4; // ecx
  uint8 kind; // bl
  uintptr v6; // ebx
  reflect_rtype *v7; // eax
  _BYTE op[20]; // [esp+0h] [ebp-48h] BYREF
  __int32 methodIndex; // [esp+14h] [ebp-34h]
  reflect_rtype *rcvr; // [esp+18h] [ebp-30h]
  reflect_rtype *t; // [esp+1Ch] [ebp-2Ch]
  void *v12; // [esp+20h] [ebp-28h]
  reflect_flag v_flag; // [esp+24h] [ebp-24h]
  uintptr retOffset; // [esp+28h] [ebp-20h]
  uintptr argSize; // [esp+2Ch] [ebp-1Ch]
  reflect_rtype *v_typ; // [esp+30h] [ebp-18h]
  void *v_ptr; // [esp+34h] [ebp-14h]
  reflect_rtype *frametype; // [esp+38h] [ebp-10h]
  sync_Pool_0 *framePool; // [esp+3Ch] [ebp-Ch]
  void *fn; // [esp+40h] [ebp-8h]
  void *ptr; // [esp+44h] [ebp-4h]

  v3 = *(reflect_methodValue ****)(v2 + 16);
  if ( v3 && *v3 == &ctxt )
    *v3 = (reflect_methodValue **)op;
  v_typ = ctxt->rcvr.typ;
  v_flag = ctxt->rcvr.flag;
  v_ptr = ctxt->rcvr.ptr;
  methodIndex = ctxt->method;
  *(_DWORD *)op = "call";
  *(_DWORD *)&op[4] = 4;
  *(_DWORD *)&op[8] = v_typ;
  *(_DWORD *)&op[12] = v_ptr;
  *(_DWORD *)&op[16] = v_flag;
  reflect_methodReceiver(*(string *)op, *(reflect_Value_0 *)&op[8], methodIndex, rcvr, t, v12);
  fn = v12;
  reflect_funcLayout(
    t,
    rcvr,
    *(reflect_rtype **)&op[8],
    *(uintptr *)&op[12],
    *(uintptr *)&op[16],
    (reflect_bitVector *)methodIndex,
    (sync_Pool_0 *)rcvr);
  frametype = *(reflect_rtype **)&op[8];
  argSize = *(_DWORD *)&op[12];
  retOffset = *(_DWORD *)&op[16];
  framePool = (sync_Pool_0 *)rcvr;
  *(interface_{} *)&op[4] = sync___ptr_Pool__Get((sync_Pool_0 *)rcvr);
  v4 = *(char **)&op[8];
  if ( *(const runtime__type_0 **)&op[4] != &x )
    runtime_panicdottypeE(*(runtime__type_0 **)&op[4], (runtime__type_0 *)&x, (runtime__type_0 *)&stru_80CECA0);
  ptr = *(void **)&op[8];
  kind = v_typ->kind;
  if ( (kind & 0x1F) == 20 )
  {
    v6 = *((_DWORD *)v_ptr + 1);
    if ( !*(_DWORD *)&runtime_writeBarrier.enabled )
    {
      **(_DWORD **)&op[8] = v6;
      goto LABEL_6;
    }
    goto LABEL_11;
  }
  if ( (v_flag & 0x80) != 0 && (kind & 0x20) != 0 )
  {
    v6 = *(_DWORD *)v_ptr;
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
    {
LABEL_11:
      runtime_writebarrierptr(*(uintptr **)&op[8], v6);
      v4 = (char *)ptr;
      goto LABEL_6;
    }
    **(_DWORD **)&op[8] = v6;
  }
  else if ( *(_DWORD *)&runtime_writeBarrier.enabled )
  {
    runtime_writebarrierptr(*(uintptr **)&op[8], (uintptr)v_ptr);
    v4 = (char *)ptr;
  }
  else
  {
    **(_DWORD **)&op[8] = v_ptr;
  }
LABEL_6:
  if ( argSize != 4 )
  {
    reflect_typedmemmovepartial((runtime__type_0 *)frametype, v4 + 4, frame, 4u, argSize - 4);
    v4 = (char *)ptr;
  }
  *(_DWORD *)&op[12] = frametype->size;
  *(_DWORD *)op = frametype;
  *(_DWORD *)&op[4] = fn;
  *(_DWORD *)&op[8] = v4;
  *(_DWORD *)&op[16] = retOffset;
  reflect_call();
  v7 = frametype;
  if ( frametype->size != retOffset )
  {
    reflect_typedmemmovepartial(
      (runtime__type_0 *)frametype,
      (char *)frame + retOffset - 4,
      (char *)ptr + retOffset,
      retOffset,
      frametype->size - retOffset);
    v7 = frametype;
  }
  reflect_memclrNoHeapPointers(ptr, v7->size);
  *(_DWORD *)&op[4] = &x;
  *(_DWORD *)&op[8] = ptr;
  sync___ptr_Pool__Put(framePool, *(interface_{} *)&op[4]);
}
// 80AC2D9: variable 'v2' is possibly undefined

//----- (080AC560) --------------------------------------------------------
complex128 __golang reflect_Value_Complex(reflect_Value_0 v)
{
  int v1; // eax
  uintptr *v2; // eax
  interface_{} typ; // [esp+0h] [ebp-10h]
  uintptr *v4; // [esp+Ch] [ebp-4h]
  complex128 _r0; // [esp+20h] [ebp+10h]

  v1 = v.flag & 0x1F;
  if ( v1 == 15 )
  {
    _r0.real = *(float *)v.ptr;
    _r0.imag = *((float *)v.ptr + 1);
  }
  else
  {
    if ( v1 != 16 )
    {
      v2 = (uintptr *)runtime_newobject((runtime__type_0 *)&stru_80D3140);
      v4 = v2;
      v2[1] = 21;
      if ( *(_DWORD *)&runtime_writeBarrier.enabled )
        runtime_writebarrierptr(v2, (uintptr)"reflect.Value.Complex");
      else
        *v2 = (uintptr)"reflect.Value.Complex";
      v4[2] = v.flag & 0x1F;
      typ._type = (runtime__type_0 *)&stru_80D0760;
      typ.data = v4;
      runtime_gopanic(typ);
      BUG();
    }
    _r0.real = *(double *)v.ptr;
    _r0.imag = *((double *)v.ptr + 1);
  }
  return _r0;
}

//----- (080AC640) --------------------------------------------------------
reflect_Value_0 __golang reflect_Value_Elem(reflect_Value_0 v)
{
  void *ptr; // eax
  uintptr *v2; // eax
  void *v3; // ecx
  reflect_rtype *v4; // eax
  uint8 kind; // bl
  int v6; // edx
  reflect_rtype *v7; // ecx
  reflect_rtype *v8; // edx
  interface_{} typ; // [esp+0h] [ebp-18h]
  uintptr *v10; // [esp+Ch] [ebp-Ch]
  reflect_Value_0 _r0; // [esp+28h] [ebp+10h]

  if ( (v.flag & 0x1F) == 20 )
  {
    if ( reflect___ptr_rtype__NumMethod(v.typ) )
    {
      v7 = *(reflect_rtype **)v.ptr;
      if ( *(_DWORD *)v.ptr )
        v7 = (reflect_rtype *)v7->ptrdata;
      v8 = v7;
      v3 = (void *)*((_DWORD *)v.ptr + 1);
      v4 = v8;
    }
    else
    {
      v3 = (void *)*((_DWORD *)v.ptr + 1);
      v4 = *(reflect_rtype **)v.ptr;
    }
    if ( v4 )
    {
      kind = v4->kind;
      v6 = kind & 0x1F;
      if ( (kind & 0x20) == 0 )
        v6 |= 0x80u;
    }
    else
    {
      v6 = 0;
      v3 = 0;
      v4 = 0;
    }
    if ( v6 )
      v6 |= v.flag & 0x60;
    _r0.typ = v4;
    _r0.ptr = v3;
    _r0.flag = v6;
  }
  else
  {
    if ( (v.flag & 0x1F) != 22 )
    {
      v2 = (uintptr *)runtime_newobject((runtime__type_0 *)&stru_80D3140);
      v10 = v2;
      v2[1] = 18;
      if ( *(_DWORD *)&runtime_writeBarrier.enabled )
        runtime_writebarrierptr(v2, (uintptr)"reflect.Value.Elem");
      else
        *v2 = (uintptr)"reflect.Value.Elem";
      v10[2] = v.flag & 0x1F;
      typ._type = (runtime__type_0 *)&stru_80D0760;
      typ.data = v10;
      runtime_gopanic(typ);
      BUG();
    }
    if ( (v.flag & 0x80) != 0 )
      ptr = *(void **)v.ptr;
    else
      ptr = v.ptr;
    if ( ptr )
    {
      _r0.typ = (reflect_rtype *)v.typ[1].size;
      _r0.ptr = ptr;
      _r0.flag = v.flag & 0x60 | _r0.typ->kind & 0x1F | 0x180;
    }
    else
    {
      _r0.typ = 0;
      _r0.ptr = 0;
      _r0.flag = 0;
    }
  }
  return _r0;
}

//----- (080AC7C0) --------------------------------------------------------
reflect_Value_0 __golang reflect_Value_Field(reflect_Value_0 v, __int32 i)
{
  uintptr ptrdata; // eax
  reflect_rtype *v3; // ebx
  int v4; // ecx
  bool v5; // zf
  uintptr v6; // eax
  uintptr *v7; // eax
  interface_{} typ; // [esp+0h] [ebp-10h]
  interface_{} typa; // [esp+0h] [ebp-10h]
  uintptr *v10; // [esp+Ch] [ebp-4h]
  reflect_Value_0 _r1; // [esp+24h] [ebp+14h]

  if ( (v.flag & 0x1F) != 25 )
  {
    v7 = (uintptr *)runtime_newobject((runtime__type_0 *)&stru_80D3140);
    v10 = v7;
    v7[1] = 19;
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr(v7, (uintptr)"reflect.Value.Field");
    else
      *v7 = (uintptr)"reflect.Value.Field";
    v10[2] = v.flag & 0x1F;
    typ._type = (runtime__type_0 *)&stru_80D0760;
    typ.data = v10;
    runtime_gopanic(typ);
    BUG();
  }
  ptrdata = v.typ[1].ptrdata;
  if ( i >= v.typ[1].hash )
  {
    typa._type = (runtime__type_0 *)&t;
    typa.data = &reflect_statictmp_81;
    runtime_gopanic(typa);
    BUG();
  }
  v3 = *(reflect_rtype **)(ptrdata + 12 * i + 4);
  v4 = v3->kind & 0x1F | v.flag & 0x1A0;
  v5 = (**(_BYTE **)(ptrdata + 12 * i) & 1) == 0;
  v6 = v.typ[1].ptrdata;
  if ( v5 )
  {
    if ( (*(_DWORD *)(v6 + 12 * i + 8) & 1) != 0 )
      v4 |= 0x40u;
    else
      v4 |= 0x20u;
  }
  _r1.typ = v3;
  _r1.ptr = (char *)v.ptr + (*(_DWORD *)(v6 + 12 * i + 8) >> 1);
  _r1.flag = v4;
  return _r1;
}

//----- (080AC8E0) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
float64 __golang reflect_Value_Float(reflect_Value_0 v)
{
  int v1; // eax
  uintptr *v2; // eax
  interface_{} typ; // [esp+0h] [ebp-10h]
  uintptr *v4; // [esp+Ch] [ebp-4h]

  v1 = v.flag & 0x1F;
  if ( v1 == 13 )
    return *(float *)v.ptr;
  if ( v1 != 14 )
  {
    v2 = (uintptr *)runtime_newobject((runtime__type_0 *)&stru_80D3140);
    v4 = v2;
    v2[1] = 19;
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr(v2, (uintptr)"reflect.Value.Float");
    else
      *v2 = (uintptr)"reflect.Value.Float";
    v4[2] = v.flag & 0x1F;
    typ._type = (runtime__type_0 *)&stru_80D0760;
    typ.data = v4;
    runtime_gopanic(typ);
    BUG();
  }
  return *(double *)v.ptr;
}
// 80AC8E0: variables would overlap: ^20.8 and ^20.12

//----- (080AC9B0) --------------------------------------------------------
reflect_Value_0 __golang reflect_Value_Index(reflect_Value_0 v, __int32 i)
{
  int v2; // eax
  reflect_rtype *size; // eax
  reflect_rtype *v4; // edx
  uintptr *v5; // eax
  interface_{} typ; // [esp+0h] [ebp-10h]
  interface_{} typa; // [esp+0h] [ebp-10h]
  interface_{} typb; // [esp+0h] [ebp-10h]
  interface_{} typc; // [esp+0h] [ebp-10h]
  uintptr *v10; // [esp+Ch] [ebp-4h]
  reflect_Value_0 _r1; // [esp+24h] [ebp+14h]

  v2 = v.flag & 0x1F;
  switch ( v2 )
  {
    case 17:
      if ( i >= v.typ[1].hash )
      {
        typc._type = (runtime__type_0 *)&t;
        typc.data = &reflect_statictmp_83;
        runtime_gopanic(typc);
        BUG();
      }
      size = (reflect_rtype *)v.typ[1].size;
      _r1.typ = size;
      _r1.ptr = (char *)v.ptr + size->size * i;
      _r1.flag = size->kind & 0x1F | v.flag & 0x1E0;
      break;
    case 23:
      if ( (unsigned int)i >= *((_DWORD *)v.ptr + 1) )
      {
        typb._type = (runtime__type_0 *)&t;
        typb.data = &reflect_statictmp_84;
        runtime_gopanic(typb);
        BUG();
      }
      v4 = (reflect_rtype *)v.typ[1].size;
      _r1.typ = v4;
      _r1.ptr = (void *)(v4->size * i + *(_DWORD *)v.ptr);
      _r1.flag = v.flag & 0x60 | v4->kind & 0x1F | 0x180;
      break;
    case 24:
      if ( (unsigned int)i >= *((_DWORD *)v.ptr + 1) )
      {
        typa._type = (runtime__type_0 *)&t;
        typa.data = &reflect_statictmp_85;
        runtime_gopanic(typa);
        BUG();
      }
      _r1.typ = (reflect_rtype *)reflect_uint8Type;
      _r1.ptr = (void *)(i + *(_DWORD *)v.ptr);
      _r1.flag = v.flag & 0x60 | 0x88;
      break;
    default:
      v5 = (uintptr *)runtime_newobject((runtime__type_0 *)&stru_80D3140);
      v10 = v5;
      v5[1] = 19;
      if ( *(_DWORD *)&runtime_writeBarrier.enabled )
        runtime_writebarrierptr(v5, (uintptr)"reflect.Value.Index");
      else
        *v5 = (uintptr)"reflect.Value.Index";
      v10[2] = v.flag & 0x1F;
      typ._type = (runtime__type_0 *)&stru_80D0760;
      typ.data = v10;
      runtime_gopanic(typ);
      BUG();
  }
  return _r1;
}

//----- (080ACB60) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
int64 __golang reflect_Value_Int(reflect_Value_0 v)
{
  unsigned int v1; // eax
  uintptr *v2; // eax
  interface_{} typ; // [esp+0h] [ebp-10h]
  unsigned int v4; // [esp+8h] [ebp-8h]
  uintptr *v5; // [esp+Ch] [ebp-4h]

  v1 = v.flag & 0x1F;
  v4 = v1;
  if ( v1 > 3 )
  {
    switch ( v1 )
    {
      case 4u:
        return *(__int16 *)v.ptr;
      case 5u:
        return *(int *)v.ptr;
      case 6u:
        return *(_QWORD *)v.ptr;
      default:
        goto LABEL_5;
    }
  }
  else
  {
    if ( v1 != 2 )
    {
      if ( v1 == 3 )
        return *(char *)v.ptr;
LABEL_5:
      v2 = (uintptr *)runtime_newobject((runtime__type_0 *)&stru_80D3140);
      v5 = v2;
      v2[1] = 17;
      if ( *(_DWORD *)&runtime_writeBarrier.enabled )
        runtime_writebarrierptr(v2, (uintptr)"reflect.Value.Int");
      else
        *v2 = (uintptr)"reflect.Value.Int";
      v5[2] = v4;
      typ._type = (runtime__type_0 *)&stru_80D0760;
      typ.data = v5;
      runtime_gopanic(typ);
      BUG();
    }
    return *(int *)v.ptr;
  }
}
// 80ACB60: variables would overlap: ^20.8 and ^20.12

//----- (080ACC80) --------------------------------------------------------
bool __golang reflect_Value_CanInterface(reflect_Value_0 v)
{
  uintptr *v1; // eax
  interface_{} typ; // [esp+0h] [ebp-Ch]
  uintptr *v3; // [esp+8h] [ebp-4h]

  if ( !v.flag )
  {
    v1 = (uintptr *)runtime_newobject((runtime__type_0 *)&stru_80D3140);
    v3 = v1;
    v1[1] = 26;
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr(v1, (uintptr)"reflect.Value.CanInterface");
    else
      *v1 = (uintptr)"reflect.Value.CanInterface";
    v3[2] = 0;
    typ._type = (runtime__type_0 *)&stru_80D0760;
    typ.data = v3;
    runtime_gopanic(typ);
    BUG();
  }
  return (v.flag & 0x60) == 0;
}

//----- (080ACD20) --------------------------------------------------------
void __golang reflect_Value_Interface(reflect_Value_0 v, interface_{} i)
{
  reflect_valueInterface(v, 1);
}

//----- (080ACD80) --------------------------------------------------------
interface_{} __golang reflect_valueInterface(reflect_Value_0 v, bool safe)
{
  reflect_flag flag; // eax
  __int64 v3; // rcx
  reflect_rtype *typ; // edx
  runtime__type_0 *v5; // eax
  uintptr *v6; // eax
  reflect_Value_0 v7; // [esp+0h] [ebp-24h]
  reflect_Value_0 v8; // [esp+0h] [ebp-24h]
  string v9; // [esp+0h] [ebp-24h]
  interface_{} v10; // [esp+0h] [ebp-24h]
  interface_{} v11; // [esp+0h] [ebp-24h]
  reflect_Value_0 MethodValue; // [esp+14h] [ebp-10h]
  uintptr *v13; // [esp+20h] [ebp-4h]
  int v_4; // [esp+2Ch] [ebp+8h]
  interface_{} _r2; // [esp+38h] [ebp+14h]

  flag = v.flag;
  if ( !v.flag )
  {
    v6 = (uintptr *)runtime_newobject((runtime__type_0 *)&stru_80D3140);
    v13 = v6;
    v6[1] = 23;
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr(v6, (uintptr)"reflect.Value.Interface");
    else
      *v6 = (uintptr)"reflect.Value.Interface";
    v13[2] = 0;
    v10._type = (runtime__type_0 *)&stru_80D0760;
    v10.data = v13;
    runtime_gopanic(v10);
    BUG();
  }
  if ( safe && (v.flag & 0x60) != 0 )
  {
    v11._type = (runtime__type_0 *)&t;
    v11.data = &reflect_statictmp_86;
    runtime_gopanic(v11);
    BUG();
  }
  if ( (v.flag & 0x200) != 0 )
  {
    v9.str = (uint8 *)"Interface";
    v9.len = 9;
    MethodValue = reflect_makeMethodValue(v9, v);
    typ = MethodValue.typ;
    LODWORD(v3) = MethodValue.ptr;
    flag = MethodValue.flag;
  }
  else
  {
    LODWORD(v3) = v.ptr;
    typ = v.typ;
  }
  HIDWORD(v3) = flag;
  if ( (flag & 0x1F) == 20 )
  {
    v_4 = v3;
    v7.typ = typ;
    *(_QWORD *)&v7.ptr = v3;
    if ( reflect_Value_NumMethod(v7) )
    {
      v5 = *(runtime__type_0 **)v_4;
      if ( *(_DWORD *)v_4 )
        v5 = (runtime__type_0 *)v5->ptrdata;
      _r2._type = v5;
      _r2.data = *(void **)(v_4 + 4);
    }
    else
    {
      _r2._type = *(runtime__type_0 **)v_4;
      _r2.data = *(void **)(v_4 + 4);
    }
  }
  else
  {
    v8.typ = typ;
    *(_QWORD *)&v8.ptr = v3;
    return reflect_packEface(v8);
  }
  return _r2;
}

//----- (080ACF10) --------------------------------------------------------
bool __golang reflect_Value_IsNil(reflect_Value_0 v)
{
  unsigned int v1; // eax
  void *ptr; // eax
  uintptr *v3; // eax
  interface_{} typ; // [esp+0h] [ebp-10h]
  uintptr *v5; // [esp+Ch] [ebp-4h]

  v1 = v.flag & 0x1F;
  if ( v1 <= 0x14 )
  {
    if ( v1 - 18 <= 1 )
      goto LABEL_3;
    if ( v1 == 20 )
      return *(_DWORD *)v.ptr == 0;
LABEL_11:
    v3 = (uintptr *)runtime_newobject((runtime__type_0 *)&stru_80D3140);
    v5 = v3;
    v3[1] = 19;
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr(v3, (uintptr)"reflect.Value.IsNil");
    else
      *v3 = (uintptr)"reflect.Value.IsNil";
    v5[2] = v.flag & 0x1F;
    typ._type = (runtime__type_0 *)&stru_80D0760;
    typ.data = v5;
    runtime_gopanic(typ);
    BUG();
  }
  if ( v1 - 21 > 1 )
  {
    if ( v1 == 23 )
      return *(_DWORD *)v.ptr == 0;
    goto LABEL_11;
  }
LABEL_3:
  if ( (v.flag & 0x200) != 0 )
    return 0;
  if ( (v.flag & 0x80) != 0 )
    ptr = *(void **)v.ptr;
  else
    ptr = v.ptr;
  return ptr == 0;
}

//----- (080AD020) --------------------------------------------------------
reflect_Kind __golang reflect_Value_Kind(reflect_Value_0 v)
{
  return v.flag & 0x1F;
}

//----- (080AD050) --------------------------------------------------------
__int32 __golang reflect_Value_Len(reflect_Value_0 v)
{
  unsigned int v1; // eax
  uintptr *v2; // eax
  interface_{} v3; // [esp+0h] [ebp-18h]
  runtime_hchan *c; // [esp+Ch] [ebp-Ch]
  runtime_hchan *ca; // [esp+Ch] [ebp-Ch]
  uintptr *v6; // [esp+14h] [ebp-4h]

  v1 = v.flag & 0x1F;
  if ( v1 > 0x12 )
  {
    switch ( v1 )
    {
      case 0x15u:
        ca = (runtime_hchan *)reflect_Value_pointer(v);
        return reflect_maplen((runtime_hmap *)ca);
      case 0x17u:
        return *((_DWORD *)v.ptr + 1);
      case 0x18u:
        return *((_DWORD *)v.ptr + 1);
      default:
        goto LABEL_5;
    }
  }
  else
  {
    if ( v1 != 17 )
    {
      if ( v1 == 18 )
      {
        c = (runtime_hchan *)reflect_Value_pointer(v);
        return reflect_chanlen(c);
      }
LABEL_5:
      v2 = (uintptr *)runtime_newobject((runtime__type_0 *)&stru_80D3140);
      v6 = v2;
      v2[1] = 17;
      if ( *(_DWORD *)&runtime_writeBarrier.enabled )
        runtime_writebarrierptr(v2, (uintptr)"reflect.Value.Len");
      else
        *v2 = (uintptr)"reflect.Value.Len";
      v6[2] = v.flag & 0x1F;
      v3._type = (runtime__type_0 *)&stru_80D0760;
      v3.data = v6;
      runtime_gopanic(v3);
      BUG();
    }
    return v.typ[1].hash;
  }
}

//----- (080AD1A0) --------------------------------------------------------
reflect_Value_0 __golang reflect_Value_MapIndex(reflect_Value_0 v, reflect_Value_0 key)
{
  void *ptr; // eax
  runtime__type_0 *ptrdata; // ecx
  int v4; // edx
  void *v5; // eax
  string contexta; // [esp+Ch] [ebp-30h]
  runtime_hmap *contextb; // [esp+Ch] [ebp-30h]
  void **context; // [esp+Ch] [ebp-30h]
  reflect_Value_0 v9; // [esp+1Ch] [ebp-20h]
  int fl; // [esp+28h] [ebp-14h]
  runtime__type_0 *t; // [esp+2Ch] [ebp-10h]
  void *k; // [esp+30h] [ebp-Ch]
  void *c; // [esp+38h] [ebp-4h]
  reflect_Value_0 _r1; // [esp+58h] [ebp+1Ch] BYREF

  reflect_flag_mustBe(v.flag, 0x15u);
  contexta.str = (uint8 *)"reflect.Value.MapIndex";
  contexta.len = 22;
  v9 = reflect_Value_assignTo(key, contexta, (reflect_rtype *)v.typ[1].size, 0);
  key.ptr = v9.ptr;
  key.flag = v9.flag;
  if ( (v9.flag & 0x80) != 0 )
    ptr = key.ptr;
  else
    ptr = &key.ptr;
  k = ptr;
  contextb = (runtime_hmap *)reflect_Value_pointer(v);
  context = (void **)reflect_mapaccess((runtime_maptype_0 *)v.typ, contextb, k);
  if ( context )
  {
    ptrdata = (runtime__type_0 *)v.typ[1].ptrdata;
    v4 = (LOBYTE(key.flag) | LOBYTE(v.flag)) & 0x60 | ptrdata->kind & 0x1F;
    if ( (ptrdata->kind & 0x20) != 0 )
    {
      v5 = *context;
      _r1.typ = (reflect_rtype *)v.typ[1].ptrdata;
      _r1.ptr = v5;
      _r1.flag = v4;
    }
    else
    {
      t = (runtime__type_0 *)v.typ[1].ptrdata;
      fl = (LOBYTE(key.flag) | LOBYTE(v.flag)) & 0x60 | ptrdata->kind & 0x1F;
      c = reflect_unsafe_New(ptrdata);
      reflect_typedmemmove(t, c, context);
      _r1.typ = (reflect_rtype *)t;
      _r1.ptr = c;
      _r1.flag = fl | 0x80;
    }
  }
  else
  {
    memset(&_r1, 0, sizeof(_r1));
  }
  return _r1;
}

//----- (080AD340) --------------------------------------------------------
__reflect_Value __golang reflect_Value_MapKeys(reflect_Value_0 v)
{
  runtime_hmap *v1; // ecx
  __int32 v2; // edx
  __int32 len; // ecx
  unsigned __int32 v4; // ebx
  uintptr v5; // eax
  uintptr *v6; // ebx
  uintptr *expected; // [esp+4h] [ebp-4Ch]
  runtime_hmap *h; // [esp+Ch] [ebp-44h]
  runtime_slice_0 ha; // [esp+Ch] [ebp-44h]
  uint8 kind; // [esp+1Bh] [ebp-35h]
  __int32 mlen; // [esp+1Ch] [ebp-34h]
  __int32 i; // [esp+20h] [ebp-30h]
  int fl; // [esp+24h] [ebp-2Ch]
  runtime__type_0 *t; // [esp+30h] [ebp-20h]
  runtime_hiter *it; // [esp+3Ch] [ebp-14h]
  void *c; // [esp+40h] [ebp-10h]
  uintptr src; // [esp+4Ch] [ebp-4h]
  __reflect_Value _r0; // [esp+60h] [ebp+10h]

  reflect_flag_mustBe(v.flag, 0x15u);
  t = (runtime__type_0 *)v.typ[1].size;
  kind = t->kind;
  h = (runtime_hmap *)reflect_Value_pointer(v);
  fl = kind & 0x1F | v.flag & 0x60;
  v1 = h;
  if ( h )
  {
    v2 = reflect_maplen(h);
    v1 = h;
  }
  else
  {
    v2 = 0;
  }
  mlen = v2;
  it = reflect_mapiterinit((runtime_maptype_0 *)v.typ, v1);
  ha = runtime_makeslice((runtime__type_0 *)&stru_80E08C0, mlen, mlen);
  len = ha.len;
  v4 = 0;
  while ( 1 )
  {
    i = v4;
    if ( (int)v4 >= len )
      break;
    expected = (uintptr *)reflect_mapiterkey(it);
    if ( !expected )
      break;
    if ( (t->kind & 0x20) != 0 )
    {
      v5 = *expected;
      if ( v4 >= ha.len )
        runtime_panicindex();
      *((_DWORD *)ha.array + 3 * v4 + 2) = fl;
      v6 = (uintptr *)((char *)ha.array + 12 * v4);
      if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      {
        src = v5;
        runtime_writebarrierptr(v6, (uintptr)t);
        runtime_writebarrierptr(v6 + 1, src);
      }
      else
      {
        *((_DWORD *)ha.array + 3 * i) = t;
        *((_DWORD *)ha.array + 3 * i + 1) = v5;
      }
    }
    else
    {
      c = reflect_unsafe_New(t);
      reflect_typedmemmove(t, c, expected);
      if ( v4 >= ha.len )
        runtime_panicindex();
      *((_DWORD *)ha.array + 3 * v4 + 2) = fl | 0x80;
      if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      {
        runtime_writebarrierptr((uintptr *)ha.array + 3 * v4, (uintptr)t);
        runtime_writebarrierptr((uintptr *)ha.array + 3 * v4 + 1, (uintptr)c);
      }
      else
      {
        *((_DWORD *)ha.array + 3 * v4) = t;
        *((_DWORD *)ha.array + 3 * v4 + 1) = c;
      }
    }
    reflect_mapiternext(it);
    v4 = i + 1;
    len = ha.len;
  }
  if ( v4 > ha.cap )
    runtime_panicslice();
  _r0.array = (reflect_Value_0 *)ha.array;
  _r0.len = v4;
  _r0.cap = ha.cap;
  return _r0;
}

//----- (080AD5E0) --------------------------------------------------------
__int32 __golang reflect_Value_NumMethod(reflect_Value_0 v)
{
  uintptr *v1; // eax
  interface_{} t; // [esp+0h] [ebp-Ch]
  uintptr *v3; // [esp+8h] [ebp-4h]

  if ( !v.typ )
  {
    v1 = (uintptr *)runtime_newobject((runtime__type_0 *)&stru_80D3140);
    v3 = v1;
    v1[1] = 23;
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr(v1, (uintptr)"reflect.Value.NumMethod");
    else
      *v1 = (uintptr)"reflect.Value.NumMethod";
    v3[2] = 0;
    t._type = (runtime__type_0 *)&stru_80D0760;
    t.data = v3;
    runtime_gopanic(t);
    BUG();
  }
  if ( (v.flag & 0x200) != 0 )
    return 0;
  else
    return reflect___ptr_rtype__NumMethod(v.typ);
}

//----- (080AD6A0) --------------------------------------------------------
__int32 __golang reflect_Value_NumField(reflect_Value_0 v)
{
  reflect_flag_mustBe(v.flag, 0x19u);
  return v.typ[1].hash;
}

//----- (080AD6E0) --------------------------------------------------------
uintptr __golang reflect_Value_Pointer(reflect_Value_0 v)
{
  unsigned int v1; // eax
  uintptr v2; // eax
  uintptr *v3; // eax
  interface_{} v4; // [esp+0h] [ebp-1Ch]
  uintptr *v5; // [esp+Ch] [ebp-10h]
  uintptr *v6; // [esp+18h] [ebp-4h]

  v1 = v.flag & 0x1F;
  if ( v1 > 0x13 )
  {
    if ( v1 - 21 <= 1 )
      return (uintptr)reflect_Value_pointer(v);
    if ( v1 == 23 )
      return *(_DWORD *)v.ptr;
    if ( v1 == 26 )
      return (uintptr)reflect_Value_pointer(v);
LABEL_10:
    v3 = (uintptr *)runtime_newobject((runtime__type_0 *)&stru_80D3140);
    v6 = v3;
    v3[1] = 21;
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr(v3, (uintptr)"reflect.Value.Pointer");
    else
      *v3 = (uintptr)"reflect.Value.Pointer";
    v6[2] = v.flag & 0x1F;
    v4._type = (runtime__type_0 *)&stru_80D0760;
    v4.data = v6;
    runtime_gopanic(v4);
    BUG();
  }
  if ( v1 == 18 )
    return (uintptr)reflect_Value_pointer(v);
  if ( v1 != 19 )
    goto LABEL_10;
  if ( (v.flag & 0x200) != 0 )
    return (uintptr)reflect_methodValueCall;
  v5 = (uintptr *)reflect_Value_pointer(v);
  v2 = (uintptr)v5;
  if ( v5 )
    return *v5;
  return v2;
}

//----- (080AD830) --------------------------------------------------------
void __golang reflect_Value_SetBytes(reflect_Value_0 v, __uint8 x)
{
  interface_{} f; // [esp+0h] [ebp-Ch]
  reflect_Type_0 expected; // [esp+4h] [ebp-8h]

  reflect_flag_mustBeAssignable(v.flag);
  reflect_flag_mustBe(v.flag, 0x17u);
  expected = reflect___ptr_rtype__Elem(v.typ);
  if ( ((int (__golang *)(void *))expected.tab[3].hash)(expected.data) != 8 )
  {
    f._type = (runtime__type_0 *)&t;
    f.data = &reflect_statictmp_91;
    runtime_gopanic(f);
    BUG();
  }
  *((_DWORD *)v.ptr + 1) = x.len;
  *((_DWORD *)v.ptr + 2) = x.cap;
  if ( *(_DWORD *)&runtime_writeBarrier.enabled )
    runtime_writebarrierptr((uintptr *)v.ptr, (uintptr)x.array);
  else
    *(_DWORD *)v.ptr = x.array;
}

//----- (080AD8F0) --------------------------------------------------------
void __golang reflect_Value_setRunes(reflect_Value_0 v, __int32 x)
{
  interface_{} f; // [esp+0h] [ebp-Ch]
  reflect_Type_0 expected; // [esp+4h] [ebp-8h]

  reflect_flag_mustBeAssignable(v.flag);
  reflect_flag_mustBe(v.flag, 0x17u);
  expected = reflect___ptr_rtype__Elem(v.typ);
  if ( ((int (__golang *)(void *))expected.tab[3].hash)(expected.data) != 5 )
  {
    f._type = (runtime__type_0 *)&t;
    f.data = &reflect_statictmp_92;
    runtime_gopanic(f);
    BUG();
  }
  *((_DWORD *)v.ptr + 1) = x.len;
  *((_DWORD *)v.ptr + 2) = x.cap;
  if ( *(_DWORD *)&runtime_writeBarrier.enabled )
    runtime_writebarrierptr((uintptr *)v.ptr, (uintptr)x.array);
  else
    *(_DWORD *)v.ptr = x.array;
}

//----- (080AD9B0) --------------------------------------------------------
void __golang reflect_Value_SetString(reflect_Value_0 v, string x)
{
  reflect_flag_mustBeAssignable(v.flag);
  reflect_flag_mustBe(v.flag, 0x18u);
  *((_DWORD *)v.ptr + 1) = x.len;
  if ( *(_DWORD *)&runtime_writeBarrier.enabled )
    runtime_writebarrierptr((uintptr *)v.ptr, (uintptr)x.str);
  else
    *(_DWORD *)v.ptr = x.str;
}

//----- (080ADA20) --------------------------------------------------------
reflect_Value_0 __golang reflect_Value_Slice(reflect_Value_0 v, __int32 i, __int32 j)
{
  int v3; // eax
  __int32 hash; // edx
  uintptr ptrdata; // eax
  void *ptr; // ebx
  uintptr *v7; // eax
  reflect_rtype *p_rtype; // ecx
  uintptr v9; // edx
  uintptr *v10; // ebx
  uintptr v11; // eax
  uintptr *v12; // eax
  interface_{} e; // [esp+0h] [ebp-24h]
  interface_{} ea; // [esp+0h] [ebp-24h]
  interface_{} eb; // [esp+0h] [ebp-24h]
  interface_{} ec; // [esp+0h] [ebp-24h]
  uintptr *e_4; // [esp+4h] [ebp-20h]
  __int32 cap; // [esp+8h] [ebp-1Ch]
  reflect_sliceType *typ; // [esp+10h] [ebp-14h]
  uintptr *v20; // [esp+18h] [ebp-Ch]
  uintptr *v21; // [esp+1Ch] [ebp-8h]
  reflect_Value_0 _r2; // [esp+3Ch] [ebp+18h]

  v3 = v.flag & 0x1F;
  if ( v3 == 17 )
  {
    if ( (v.flag & 0x100) == 0 )
    {
      ec._type = (runtime__type_0 *)&t;
      ec.data = &reflect_statictmp_95;
      runtime_gopanic(ec);
      BUG();
    }
    hash = v.typ[1].hash;
    ptrdata = v.typ[1].ptrdata;
    ptr = v.ptr;
    goto LABEL_4;
  }
  if ( v3 == 23 )
  {
    ptr = *(void **)v.ptr;
    hash = *((_DWORD *)v.ptr + 2);
    ptrdata = (uintptr)v.typ;
LABEL_4:
    if ( i < 0 || j < i || j > hash )
    {
      ea._type = (runtime__type_0 *)&t;
      ea.data = &reflect_statictmp_97;
      runtime_gopanic(ea);
      BUG();
    }
    typ = (reflect_sliceType *)ptrdata;
    cap = hash;
    v7 = (uintptr *)runtime_newobject((runtime__type_0 *)&stru_80CA300);
    v21 = v7;
    v7[1] = j - i;
    v7[2] = cap - i;
    if ( cap - i <= 0 )
    {
      if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      {
        runtime_writebarrierptr(v7, (uintptr)ptr);
        v7 = v21;
      }
      else
      {
        *v7 = (uintptr)ptr;
      }
      p_rtype = &typ->rtype;
    }
    else
    {
      p_rtype = &typ->rtype;
      v9 = (uintptr)ptr + typ->elem->size * i;
      if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      {
        runtime_writebarrierptr(v7, v9);
        v7 = v21;
        p_rtype = &typ->rtype;
      }
      else
      {
        *v7 = v9;
      }
    }
    _r2.typ = p_rtype;
    _r2.ptr = v7;
    _r2.flag = v.flag & 0x60 | 0x97;
    return _r2;
  }
  if ( v3 != 24 )
  {
    v12 = (uintptr *)runtime_newobject((runtime__type_0 *)&stru_80D3140);
    v20 = v12;
    v12[1] = 19;
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr(v12, (uintptr)"reflect.Value.Slice");
    else
      *v12 = (uintptr)"reflect.Value.Slice";
    v20[2] = v.flag & 0x1F;
    e._type = (runtime__type_0 *)&stru_80D0760;
    e.data = v20;
    runtime_gopanic(e);
    BUG();
  }
  if ( i < 0 || j < i || j > *((_DWORD *)v.ptr + 1) )
  {
    eb._type = (runtime__type_0 *)&t;
    eb.data = &reflect_statictmp_96;
    runtime_gopanic(eb);
    BUG();
  }
  e_4 = (uintptr *)runtime_newobject((runtime__type_0 *)&stru_80D3620);
  v10 = e_4;
  v11 = i + *(_DWORD *)v.ptr;
  e_4[1] = j - i;
  if ( *(_DWORD *)&runtime_writeBarrier.enabled )
    runtime_writebarrierptr(e_4, v11);
  else
    *e_4 = v11;
  _r2.typ = v.typ;
  _r2.ptr = v10;
  _r2.flag = v.flag;
  return _r2;
}

//----- (080ADCB0) --------------------------------------------------------
string __golang reflect_Value_String(reflect_Value_0 v)
{
  uint8 *v1; // eax
  unsigned int v2; // ecx
  string v3[3]; // [esp+4h] [ebp-20h]
  unsigned int v4; // [esp+8h] [ebp-1Ch]
  string _r0; // [esp+34h] [ebp+10h]

  if ( (v.flag & 0x1F) != 0 )
  {
    if ( (v.flag & 0x1F) == 24 )
    {
      _r0.str = *(uint8 **)v.ptr;
      _r0.len = *((_DWORD *)v.ptr + 1);
    }
    else
    {
      v3[1] = (string)reflect_Value_Type(v);
      v1 = (uint8 *)(*((int (__golang **)(__int32))v3[1].str + 33))(v3[1].len);
      v2 = v4;
      v3[0].str = (uint8 *)"<";
      v3[0].len = 1;
      v3[1].str = v1;
      *(_QWORD *)&v3[1].len = __PAIR64__(" Value>", v2);
      v3[2].len = 7;
      return runtime_concatstring3(0, *(string (*)[3])&v3[0].str);
    }
  }
  else
  {
    _r0.str = (uint8 *)"<invalid Value>";
    _r0.len = 15;
  }
  return _r0;
}
// 80ADD27: variable 'v4' is possibly undefined
// 80E0D90: using guessed type char asc_80E0D90;

//----- (080ADDA0) --------------------------------------------------------
reflect_Type_0 __golang reflect_Value_Type(reflect_Value_0 v)
{
  unsigned int v1; // eax
  uintptr *v2; // eax
  interface_{} t; // [esp+0h] [ebp-14h]
  interface_{} ta; // [esp+0h] [ebp-14h]
  interface_{} tb; // [esp+0h] [ebp-14h]
  reflect_uncommonType *off; // [esp+4h] [ebp-10h]
  unsigned __int32 i; // [esp+Ch] [ebp-8h]
  uintptr *v8; // [esp+10h] [ebp-4h]
  reflect_Type_0 _r0; // [esp+24h] [ebp+10h]

  if ( !v.flag )
  {
    v2 = (uintptr *)runtime_newobject((runtime__type_0 *)&stru_80D3140);
    v8 = v2;
    v2[1] = 18;
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr(v2, (uintptr)"reflect.Value.Type");
    else
      *v2 = (uintptr)"reflect.Value.Type";
    v8[2] = 0;
    t._type = (runtime__type_0 *)&stru_80D0760;
    t.data = v8;
    runtime_gopanic(t);
    BUG();
  }
  if ( (v.flag & 0x200) != 0 )
  {
    v1 = (int)v.flag >> 10;
    if ( (v.typ->kind & 0x1F) == 20 )
    {
      if ( v1 >= v.typ[1].hash )
      {
        tb._type = (runtime__type_0 *)&::t;
        tb.data = &reflect_statictmp_100;
        runtime_gopanic(tb);
        BUG();
      }
      _r0.tab = (runtime_itab_0 *)&go_itab__reflect_rtype_reflect_Type;
      _r0.data = reflect___ptr_rtype__typeOff(v.typ, *(_DWORD *)(v.typ[1].ptrdata + 8 * v1 + 4));
    }
    else
    {
      i = (int)v.flag >> 10;
      off = reflect___ptr_rtype__uncommon(v.typ);
      if ( !off || i >= off->mcount )
      {
        ta._type = (runtime__type_0 *)&::t;
        ta.data = &reflect_statictmp_101;
        runtime_gopanic(ta);
        BUG();
      }
      _r0.tab = (runtime_itab_0 *)&go_itab__reflect_rtype_reflect_Type;
      _r0.data = reflect___ptr_rtype__typeOff(v.typ, *(_DWORD *)((char *)&off[i].mcount + off->moff));
    }
  }
  else
  {
    _r0.tab = (runtime_itab_0 *)&go_itab__reflect_rtype_reflect_Type;
    _r0.data = v.typ;
  }
  return _r0;
}

//----- (080ADF60) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
uint64 __golang reflect_Value_Uint(reflect_Value_0 v)
{
  unsigned int v1; // eax
  uintptr *v2; // eax
  interface_{} typ; // [esp+0h] [ebp-10h]
  unsigned int v4; // [esp+8h] [ebp-8h]
  uintptr *v5; // [esp+Ch] [ebp-4h]

  v1 = v.flag & 0x1F;
  v4 = v1;
  if ( v1 > 9 )
  {
    switch ( v1 )
    {
      case 0xAu:
        return *(unsigned int *)v.ptr;
      case 0xBu:
        return *(_QWORD *)v.ptr;
      case 0xCu:
        return *(unsigned int *)v.ptr;
      default:
        goto LABEL_6;
    }
  }
  else
  {
    switch ( v1 )
    {
      case 7u:
        return *(unsigned int *)v.ptr;
      case 8u:
        return *(unsigned __int8 *)v.ptr;
      case 9u:
        return *(unsigned __int16 *)v.ptr;
      default:
LABEL_6:
        v2 = (uintptr *)runtime_newobject((runtime__type_0 *)&stru_80D3140);
        v5 = v2;
        v2[1] = 18;
        if ( *(_DWORD *)&runtime_writeBarrier.enabled )
          runtime_writebarrierptr(v2, (uintptr)"reflect.Value.Uint");
        else
          *v2 = (uintptr)"reflect.Value.Uint";
        v5[2] = v4;
        typ._type = (runtime__type_0 *)&stru_80D0760;
        typ.data = v5;
        runtime_gopanic(typ);
        BUG();
    }
  }
}
// 80ADF60: variables would overlap: ^20.8 and ^20.12

//----- (080AE0B0) --------------------------------------------------------
reflect_Value_0 __golang reflect_ValueOf(interface_{} i)
{
  reflect_rtype *type; // eax
  void *data; // ecx
  uint8 kind; // bl
  int v4; // edx
  reflect_Value_0 _r1; // [esp+1Ch] [ebp+Ch]

  type = (reflect_rtype *)i._type;
  if ( i._type )
  {
    if ( reflect_dummy.b )
    {
      reflect_dummy.x._type = i._type;
      if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      {
        runtime_writebarrierptr((uintptr *)&reflect_dummy.x.data, (uintptr)i.data);
        type = (reflect_rtype *)i._type;
        data = i.data;
      }
      else
      {
        data = i.data;
        reflect_dummy.x.data = i.data;
      }
    }
    else
    {
      data = i.data;
    }
    if ( type )
    {
      kind = type->kind;
      v4 = kind & 0x1F;
      if ( (kind & 0x20) == 0 )
        v4 |= 0x80u;
    }
    else
    {
      v4 = 0;
      data = 0;
      type = 0;
    }
    _r1.typ = type;
    _r1.ptr = data;
    _r1.flag = v4;
  }
  else
  {
    _r1.typ = 0;
    _r1.ptr = 0;
    _r1.flag = 0;
  }
  return _r1;
}

//----- (080AE190) --------------------------------------------------------
reflect_Value_0 __golang reflect_Zero(reflect_Type_0 typ)
{
  uint8 kind; // dl
  interface_{} e; // [esp+0h] [ebp-14h]
  reflect_rtype *e_4; // [esp+4h] [ebp-10h]
  int v4; // [esp+Ch] [ebp-8h]
  reflect_Value_0 _r1; // [esp+20h] [ebp+Ch]

  if ( !typ.tab )
  {
    e._type = (runtime__type_0 *)&t;
    e.data = &reflect_statictmp_120;
    runtime_gopanic(e);
    BUG();
  }
  e_4 = (reflect_rtype *)(*(int (__golang **)(void *))&typ.tab[5].bad)(typ.data);
  kind = e_4->kind;
  if ( (kind & 0x20) != 0 )
  {
    _r1.typ = e_4;
    _r1.ptr = 0;
    _r1.flag = kind & 0x1F;
  }
  else
  {
    if ( &go_itab__reflect_rtype_reflect_Type != (reflect_Type_0 *)typ.tab )
      runtime_panicdottypeI(typ.tab, (runtime__type_0 *)&key, (runtime__type_0 *)&stru_80DBAE0);
    v4 = kind & 0x1F;
    _r1.typ = e_4;
    _r1.ptr = reflect_unsafe_New((runtime__type_0 *)typ.data);
    _r1.flag = v4 | 0x80;
  }
  return _r1;
}

//----- (080AE270) --------------------------------------------------------
reflect_Value_0 __golang reflect_New(reflect_Type_0 typ)
{
  interface_{} e; // [esp+0h] [ebp-10h]
  reflect_rtype *e_4; // [esp+4h] [ebp-Ch]
  void *ptr; // [esp+Ch] [ebp-4h]
  reflect_Value_0 _r1; // [esp+1Ch] [ebp+Ch]

  if ( !typ.tab )
  {
    e._type = (runtime__type_0 *)&t;
    e.data = &reflect_statictmp_121;
    runtime_gopanic(e);
    BUG();
  }
  if ( &go_itab__reflect_rtype_reflect_Type != (reflect_Type_0 *)typ.tab )
    runtime_panicdottypeI(typ.tab, (runtime__type_0 *)&key, (runtime__type_0 *)&stru_80DBAE0);
  ptr = reflect_unsafe_New((runtime__type_0 *)typ.data);
  e_4 = (reflect_rtype *)(*(int (__golang **)(void *))&typ.tab[5].bad)(typ.data);
  _r1.typ = reflect___ptr_rtype__ptrTo(e_4);
  _r1.ptr = ptr;
  _r1.flag = 22;
  return _r1;
}

//----- (080AE330) --------------------------------------------------------
reflect_Value_0 __golang reflect_Value_assignTo(reflect_Value_0 v, string context, reflect_rtype *dst, void *target)
{
  reflect_flag flag; // eax
  void *ptr; // ecx
  reflect_rtype *typ; // edx
  void *v7; // eax
  void *v8; // ecx
  reflect_Value_0 T; // [esp+0h] [ebp-4Ch]
  string V; // [esp+4h] [ebp-48h]
  string Va[5]; // [esp+4h] [ebp-48h]
  runtime_eface_0 v12; // [esp+8h] [ebp-44h]
  interface_{} v13; // [esp+8h] [ebp-44h]
  reflect_Value_0 MethodValue; // [esp+14h] [ebp-38h]
  __int32 len; // [esp+34h] [ebp-18h]
  interface_{} x_type; // [esp+38h] [ebp-14h]
  uint8 *str; // [esp+40h] [ebp-Ch]
  string elem; // [esp+44h] [ebp-8h] BYREF
  reflect_rtype *va; // [esp+50h] [ebp+4h]
  unsigned __int64 v_4; // [esp+54h] [ebp+8h]
  void *targeta; // [esp+68h] [ebp+1Ch]
  reflect_Value_0 _r3; // [esp+6Ch] [ebp+20h]

  flag = v.flag;
  if ( (v.flag & 0x200) != 0 )
  {
    MethodValue = reflect_makeMethodValue(context, v);
    flag = MethodValue.flag;
    ptr = MethodValue.ptr;
    typ = MethodValue.typ;
  }
  else
  {
    ptr = v.ptr;
    typ = v.typ;
  }
  v_4 = __PAIR64__(flag, (unsigned int)ptr);
  va = typ;
  if ( reflect_directlyAssignable(dst, typ) )
  {
    _r3.typ = dst;
    _r3.ptr = (void *)v_4;
    _r3.flag = dst->kind & 0x1F | WORD2(v_4) & 0x1E0;
  }
  else
  {
    if ( !reflect_implements(dst, va) )
    {
      V = reflect___ptr_rtype__String(va);
      len = V.len;
      str = V.str;
      Va[0] = context;
      Va[1].str = (uint8 *)": value of type ";
      Va[1].len = 16;
      Va[2] = (string)__PAIR64__(len, (unsigned int)str);
      Va[3].str = (uint8 *)" is not assignable to type ";
      Va[3].len = 27;
      Va[4] = reflect___ptr_rtype__String(dst);
      elem = runtime_concatstring5(0, *(string (*)[5])&Va[0].str);
      runtime_convT2Estring((runtime__type_0 *)&t, &elem, v12);
      runtime_gopanic(v13);
      BUG();
    }
    v7 = target;
    if ( !target )
      v7 = reflect_unsafe_New((runtime__type_0 *)dst);
    targeta = v7;
    T.typ = va;
    *(_QWORD *)&T.ptr = v_4;
    x_type = reflect_valueInterface(T, 0);
    if ( reflect___ptr_rtype__NumMethod(dst) )
    {
      reflect_ifaceE2I((runtime_interfacetype_0 *)dst, x_type, (runtime_iface_0 *)targeta);
      v8 = targeta;
    }
    else
    {
      v8 = targeta;
      *(_DWORD *)targeta = x_type._type;
      if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      {
        runtime_writebarrierptr((uintptr *)targeta + 1, (uintptr)x_type.data);
        v8 = targeta;
      }
      else
      {
        *((_DWORD *)targeta + 1) = x_type.data;
      }
    }
    _r3.typ = dst;
    _r3.ptr = v8;
    _r3.flag = 148;
  }
  return _r3;
}
// 80AE596: variable 'v12' is possibly undefined
// 80AE5AA: variable 'v13' is possibly undefined

//----- (080AE5C0) --------------------------------------------------------
func(reflect_Value__reflect_Type)_reflect_Value __golang reflect_convertOp(reflect_rtype *dst, reflect_rtype *src)
{
  reflect_rtype *v2; // eax
  unsigned int v3; // ecx
  reflect_rtype *T; // ecx
  int v5; // edx
  reflect_rtype *v6; // eax
  int v7; // edx
  int v8; // edx
  string Vb; // [esp+4h] [ebp-10h]
  string Vc; // [esp+4h] [ebp-10h]
  reflect_Type_0 Vd; // [esp+4h] [ebp-10h]
  reflect_Type_0 Ve; // [esp+4h] [ebp-10h]
  reflect_Type_0 Vf; // [esp+4h] [ebp-10h]
  reflect_Type_0 Vg; // [esp+4h] [ebp-10h]
  reflect_rtype *V; // [esp+4h] [ebp-10h]
  reflect_Type_0 Vh; // [esp+4h] [ebp-10h]
  reflect_Type_0 Vi; // [esp+4h] [ebp-10h]
  reflect_rtype *Va; // [esp+4h] [ebp-10h]
  reflect_rtype *v19; // [esp+10h] [ebp-4h]

  v2 = src;
  v3 = src->kind & 0x1F;
  if ( v3 <= 0xE )
  {
    if ( v3 - 2 <= 4 )
    {
      T = dst;
      v5 = dst->kind & 0x1F;
      if ( (unsigned int)(v5 - 2) <= 0xA )
        return (func(reflect_Value__reflect_Type)_reflect_Value)off_80E7B44;
      if ( (unsigned int)(v5 - 13) <= 1 )
        return (func(reflect_Value__reflect_Type)_reflect_Value)off_80E7B3C;
      if ( v5 == 24 )
        return (func(reflect_Value__reflect_Type)_reflect_Value)off_80E7B40;
      goto LABEL_6;
    }
    if ( v3 - 7 <= 5 )
    {
      T = dst;
      v7 = dst->kind & 0x1F;
      if ( (unsigned int)(v7 - 2) <= 0xA )
        return (func(reflect_Value__reflect_Type)_reflect_Value)&off_80E7B60;
      if ( (unsigned int)(v7 - 13) <= 1 )
        return (func(reflect_Value__reflect_Type)_reflect_Value)off_80E7B58;
      if ( v7 == 24 )
        return (func(reflect_Value__reflect_Type)_reflect_Value)off_80E7B5C;
      goto LABEL_6;
    }
    if ( v3 - 13 <= 1 )
    {
      T = dst;
      v8 = dst->kind & 0x1F;
      if ( (unsigned int)(v8 - 2) <= 4 )
        return (func(reflect_Value__reflect_Type)_reflect_Value)off_80E7B2C;
      if ( (unsigned int)(v8 - 7) <= 5 )
        return (func(reflect_Value__reflect_Type)_reflect_Value)off_80E7B30;
      if ( (unsigned int)(v8 - 13) <= 1 )
        return (func(reflect_Value__reflect_Type)_reflect_Value)off_80E7B34;
      goto LABEL_6;
    }
    goto LABEL_40;
  }
  if ( v3 - 15 <= 1 )
  {
    T = dst;
    if ( (dst->kind & 0x1Fu) - 15 <= 1 )
      return (func(reflect_Value__reflect_Type)_reflect_Value)off_80E7B24;
    goto LABEL_6;
  }
  if ( v3 == 23 )
  {
    T = dst;
    if ( (dst->kind & 0x1F) == 24 )
    {
      Vf = reflect___ptr_rtype__Elem(src);
      ((void (__golang *)(void *))Vf.tab[5]._type)(Vf.data);
      if ( Vf.data )
      {
        v2 = src;
        T = dst;
      }
      else
      {
        Vg = reflect___ptr_rtype__Elem(src);
        V = (reflect_rtype *)((int (__golang *)(void *))Vg.tab[3].hash)(Vg.data);
        if ( V == (reflect_rtype *)5 )
          return (func(reflect_Value__reflect_Type)_reflect_Value)off_80E7B48;
        if ( V == (reflect_rtype *)8 )
          return (func(reflect_Value__reflect_Type)_reflect_Value)off_80E7B20;
        v2 = src;
        T = dst;
      }
    }
    goto LABEL_6;
  }
  if ( v3 != 24 )
  {
LABEL_40:
    T = dst;
    goto LABEL_6;
  }
  T = dst;
  if ( (dst->kind & 0x1F) == 23 )
  {
    Vh = reflect___ptr_rtype__Elem(dst);
    ((void (__golang *)(void *))Vh.tab[5]._type)(Vh.data);
    if ( Vh.data )
    {
      v2 = src;
      T = dst;
    }
    else
    {
      Vi = reflect___ptr_rtype__Elem(dst);
      Va = (reflect_rtype *)((int (__golang *)(void *))Vi.tab[3].hash)(Vi.data);
      if ( Va == (reflect_rtype *)5 )
        return (func(reflect_Value__reflect_Type)_reflect_Value)off_80E7B50;
      if ( Va == (reflect_rtype *)8 )
        return (func(reflect_Value__reflect_Type)_reflect_Value)off_80E7B4C;
      v2 = src;
      T = dst;
    }
  }
LABEL_6:
  if ( reflect_haveIdenticalUnderlyingType(T, v2, 0) )
    return (func(reflect_Value__reflect_Type)_reflect_Value)off_80E7B28;
  v6 = dst;
  if ( (dst->kind & 0x1F) == 22 )
  {
    Vb = reflect___ptr_rtype__Name(dst);
    if ( !Vb.len && (src->kind & 0x1F) == 22 )
    {
      Vc = reflect___ptr_rtype__Name(src);
      if ( Vc.len )
      {
        v6 = dst;
      }
      else
      {
        Vd = reflect___ptr_rtype__Elem(dst);
        v19 = (reflect_rtype *)(*(int (__golang **)(void *))&Vd.tab[5].bad)(Vd.data);
        Ve = reflect___ptr_rtype__Elem(src);
        Ve.tab = (runtime_itab_0 *)(*(int (__golang **)(void *))&Ve.tab[5].bad)(Ve.data);
        if ( reflect_haveIdenticalUnderlyingType(v19, (reflect_rtype *)Ve.tab, 0) )
          return (func(reflect_Value__reflect_Type)_reflect_Value)off_80E7B28;
        v6 = dst;
      }
    }
    else
    {
      v6 = dst;
    }
  }
  if ( !reflect_implements(v6, src) )
    return 0;
  if ( (src->kind & 0x1F) == 20 )
    return (func(reflect_Value__reflect_Type)_reflect_Value)off_80E7B38;
  return (func(reflect_Value__reflect_Type)_reflect_Value)off_80E7B54;
}
// 80E7B20: using guessed type int (__golang *off_80E7B20[17])(reflect_Value_0 v, reflect_Type_0 t, reflect_Value_0 _r2);
// 80E7B24: using guessed type int (__golang *off_80E7B24[16])(reflect_Value_0 v, reflect_Type_0 t, reflect_Value_0 _r2);
// 80E7B28: using guessed type int (__golang *off_80E7B28[15])(reflect_Value_0 v, reflect_Type_0 typ, reflect_Value_0 _r2);
// 80E7B2C: using guessed type int (__golang *off_80E7B2C[14])(reflect_Value_0 v, reflect_Type_0 t, reflect_Value_0 _r2);
// 80E7B30: using guessed type int (__golang *off_80E7B30[13])(reflect_Value_0 v, reflect_Type_0 t, reflect_Value_0 _r2);
// 80E7B34: using guessed type int (__golang *off_80E7B34[12])(reflect_Value_0 v, reflect_Type_0 t, reflect_Value_0 _r2);
// 80E7B38: using guessed type int (__golang *off_80E7B38[11])(reflect_Value_0 v, reflect_Type_0 typ, reflect_Value_0 _r2);
// 80E7B3C: using guessed type int (__golang *off_80E7B3C[10])(reflect_Value_0 v, reflect_Type_0 t, reflect_Value_0 _r2);
// 80E7B40: using guessed type int (__golang *off_80E7B40[9])(reflect_Value_0 v, reflect_Type_0 t, reflect_Value_0 _r2);
// 80E7B44: using guessed type int (__golang *off_80E7B44[8])(reflect_Value_0 v, reflect_Type_0 t, reflect_Value_0 _r2);
// 80E7B48: using guessed type int (__golang *off_80E7B48[7])(reflect_Value_0 v, reflect_Type_0 t, reflect_Value_0 _r2);
// 80E7B4C: using guessed type int (__golang *off_80E7B4C[6])(reflect_Value_0 v, reflect_Type_0 t, reflect_Value_0 _r2);
// 80E7B50: using guessed type int (__golang *off_80E7B50[5])(reflect_Value_0 v, reflect_Type_0 t, reflect_Value_0 _r2);
// 80E7B54: using guessed type int (__golang *off_80E7B54[4])(reflect_Value_0 v, reflect_Type_0 typ, reflect_Value_0 _r2);
// 80E7B58: using guessed type int (__golang *off_80E7B58[3])(reflect_Value_0 v, reflect_Type_0 t, reflect_Value_0 _r2);
// 80E7B5C: using guessed type int (__golang *off_80E7B5C[2])(reflect_Value_0 v, reflect_Type_0 t, reflect_Value_0 _r2);
// 80E7B60: using guessed type int (__golang *off_80E7B60)(reflect_Value_0 v, reflect_Type_0 t, reflect_Value_0 _r2);

//----- (080AE9D0) --------------------------------------------------------
reflect_Value_0 __golang reflect_makeInt(reflect_flag f, uint64 bits, reflect_Type_0 t)
{
  uintptr size; // edx
  runtime__type_0 *v4; // [esp+4h] [ebp-8h]
  runtime__type_0 *t_0; // [esp+8h] [ebp-4h]
  reflect_Value_0 _r3; // [esp+24h] [ebp+18h]

  t_0 = (runtime__type_0 *)(*(int (__golang **)(void *))&t.tab[5].bad)(t.data);
  v4 = (runtime__type_0 *)reflect_unsafe_New(t_0);
  size = t_0->size;
  if ( t_0->size > 2 )
  {
    if ( size == 4 )
    {
      v4->size = bits;
    }
    else if ( size == 8 )
    {
      *(_QWORD *)&v4->size = bits;
    }
  }
  else if ( size == 1 )
  {
    LOBYTE(v4->size) = bits;
  }
  else if ( size == 2 )
  {
    LOWORD(v4->size) = bits;
  }
  _r3.typ = (reflect_rtype *)t_0;
  _r3.ptr = v4;
  _r3.flag = f | t_0->kind & 0x1F | 0x80;
  return _r3;
}

//----- (080AEA90) --------------------------------------------------------
reflect_Value_0 __golang reflect_makeFloat(reflect_flag f, float64 v, reflect_Type_0 t)
{
  uintptr v3; // xmm0_4
  runtime__type_0 *v4; // [esp+4h] [ebp-8h]
  runtime__type_0 *t_0; // [esp+8h] [ebp-4h]
  reflect_Value_0 _r3; // [esp+24h] [ebp+18h]

  t_0 = (runtime__type_0 *)(*(int (__golang **)(void *))&t.tab[5].bad)(t.data);
  v4 = (runtime__type_0 *)reflect_unsafe_New(t_0);
  if ( t_0->size == 4 )
  {
    *(float *)&v3 = v;
    v4->size = v3;
  }
  else if ( t_0->size == 8 )
  {
    *(float64 *)&v4->size = v;
  }
  _r3.typ = (reflect_rtype *)t_0;
  _r3.ptr = v4;
  _r3.flag = f | t_0->kind & 0x1F | 0x80;
  return _r3;
}

//----- (080AEB30) --------------------------------------------------------
reflect_Value_0 __golang reflect_makeComplex(reflect_flag f, complex128 v, reflect_Type_0 t)
{
  float real; // xmm0_4
  float imag; // xmm0_4
  float *v5; // [esp+4h] [ebp-8h]
  runtime__type_0 *t_0; // [esp+8h] [ebp-4h]
  reflect_Value_0 _r3; // [esp+2Ch] [ebp+20h]

  t_0 = (runtime__type_0 *)(*(int (__golang **)(void *))&t.tab[5].bad)(t.data);
  v5 = (float *)reflect_unsafe_New(t_0);
  if ( t_0->size == 8 )
  {
    real = v.real;
    *v5 = real;
    imag = v.imag;
    v5[1] = imag;
  }
  else if ( t_0->size == 16 )
  {
    *(complex128 *)v5 = v;
  }
  _r3.typ = (reflect_rtype *)t_0;
  _r3.ptr = v5;
  _r3.flag = f | t_0->kind & 0x1F | 0x80;
  return _r3;
}

//----- (080AEBF0) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
reflect_Value_0 __golang reflect_makeString(reflect_flag f, string v, reflect_Type_0 t)
{
  int typ; // [esp+0h] [ebp-24h]
  __int128 typ_4; // [esp+4h] [ebp-20h] OVERLAPPED
  reflect_Value_0 v5; // [esp+Ch] [ebp-18h]
  reflect_rtype *ret_typ; // [esp+1Ch] [ebp-8h]
  void *ret_ptr; // [esp+20h] [ebp-4h]
  reflect_Value_0 _r3; // [esp+3Ch] [ebp+18h]

  *(reflect_Value_0 *)((char *)&typ_4 + 4) = reflect_New(t);
  typ = DWORD1(typ_4);
  *(_QWORD *)&typ_4 = *((_QWORD *)&typ_4 + 1);
  v5 = reflect_Value_Elem(*(reflect_Value_0 *)((char *)&typ_4 - 4));
  ret_typ = v5.typ;
  ret_ptr = v5.ptr;
  reflect_Value_SetString(v5, v);
  _r3.typ = ret_typ;
  _r3.ptr = ret_ptr;
  _r3.flag = f | v5.flag & 0xFFFFFEFF;
  return _r3;
}
// 80AEC19: failed to expand linear variable ^4.16

//----- (080AECB0) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
reflect_Value_0 __golang reflect_makeBytes(reflect_flag f, __uint8 v, reflect_Type_0 t)
{
  int typ; // [esp+0h] [ebp-24h]
  __int128 typ_4; // [esp+4h] [ebp-20h] OVERLAPPED
  reflect_Value_0 v5; // [esp+Ch] [ebp-18h]
  reflect_flag ret_flag; // [esp+18h] [ebp-Ch]
  reflect_rtype *ret_typ; // [esp+1Ch] [ebp-8h]
  void *ret_ptr; // [esp+20h] [ebp-4h]
  reflect_Value_0 _r3; // [esp+40h] [ebp+1Ch]

  *(reflect_Value_0 *)((char *)&typ_4 + 4) = reflect_New(t);
  typ = DWORD1(typ_4);
  *(_QWORD *)&typ_4 = *((_QWORD *)&typ_4 + 1);
  v5 = reflect_Value_Elem(*(reflect_Value_0 *)((char *)&typ_4 - 4));
  ret_typ = v5.typ;
  ret_ptr = v5.ptr;
  ret_flag = v5.flag;
  reflect_Value_SetBytes(v5, v);
  _r3.typ = ret_typ;
  _r3.ptr = ret_ptr;
  _r3.flag = f | ret_flag & 0xFFFFFEFF;
  return _r3;
}
// 80AECD9: failed to expand linear variable ^4.16

//----- (080AED70) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
reflect_Value_0 __golang reflect_makeRunes(reflect_flag f, __int32 v, reflect_Type_0 t)
{
  int typ; // [esp+0h] [ebp-24h]
  __int128 typ_4; // [esp+4h] [ebp-20h] OVERLAPPED
  reflect_Value_0 v5; // [esp+Ch] [ebp-18h]
  reflect_flag ret_flag; // [esp+18h] [ebp-Ch]
  reflect_rtype *ret_typ; // [esp+1Ch] [ebp-8h]
  void *ret_ptr; // [esp+20h] [ebp-4h]
  reflect_Value_0 _r3; // [esp+40h] [ebp+1Ch]

  *(reflect_Value_0 *)((char *)&typ_4 + 4) = reflect_New(t);
  typ = DWORD1(typ_4);
  *(_QWORD *)&typ_4 = *((_QWORD *)&typ_4 + 1);
  v5 = reflect_Value_Elem(*(reflect_Value_0 *)((char *)&typ_4 - 4));
  ret_typ = v5.typ;
  ret_ptr = v5.ptr;
  ret_flag = v5.flag;
  reflect_Value_setRunes(v5, v);
  _r3.typ = ret_typ;
  _r3.ptr = ret_ptr;
  _r3.flag = f | ret_flag & 0xFFFFFEFF;
  return _r3;
}
// 80AED99: failed to expand linear variable ^4.16

//----- (080AEE30) --------------------------------------------------------
reflect_Value_0 __golang reflect_cvtInt(reflect_Value_0 v, reflect_Type_0 t)
{
  uint64 v2; // [esp+Ch] [ebp-14h]

  HIDWORD(v2) = reflect_Value_Int(v);
  return reflect_makeInt(v.flag & 0x60, v2, t);
}
// 80AEE8B: variable 'v2' is possibly undefined

//----- (080AEEC0) --------------------------------------------------------
reflect_Value_0 __golang reflect_cvtUint(reflect_Value_0 v, reflect_Type_0 t)
{
  uint64 v2; // [esp+Ch] [ebp-14h]

  HIDWORD(v2) = reflect_Value_Uint(v);
  return reflect_makeInt(v.flag & 0x60, v2, t);
}
// 80AEF1B: variable 'v2' is possibly undefined

//----- (080AEF50) --------------------------------------------------------
reflect_Value_0 __golang reflect_cvtFloatInt(reflect_Value_0 v, reflect_Type_0 t)
{
  __int128 v2; // [esp+8h] [ebp-18h]
  uint64 v3; // [esp+8h] [ebp-18h]

  *((double *)&v2 + 1) = reflect_Value_Float(v);
  runtime_float64toint64(*(float64 *)((char *)&v2 + 4), v2);
  return reflect_makeInt(v.flag & 0x60, v3, t);
}
// 80AEF8C: variable 'v2' is possibly undefined
// 80AEFBB: variable 'v3' is possibly undefined

//----- (080AEFF0) --------------------------------------------------------
reflect_Value_0 __golang reflect_cvtFloatUint(reflect_Value_0 v, reflect_Type_0 t)
{
  __int128 v2; // [esp+8h] [ebp-18h]
  uint64 v3; // [esp+8h] [ebp-18h]

  *((double *)&v2 + 1) = reflect_Value_Float(v);
  runtime_float64touint64(*(float64 *)((char *)&v2 + 4), v2);
  return reflect_makeInt(v.flag & 0x60, v3, t);
}
// 80AF02C: variable 'v2' is possibly undefined
// 80AF05B: variable 'v3' is possibly undefined

//----- (080AF090) --------------------------------------------------------
reflect_Value_0 __golang reflect_cvtIntFloat(reflect_Value_0 v, reflect_Type_0 t)
{
  float64 v2; // [esp+8h] [ebp-18h]
  int64 y; // [esp+Ch] [ebp-14h]

  HIDWORD(y) = reflect_Value_Int(v);
  v2 = runtime_int64tofloat64(y);
  return reflect_makeFloat(v.flag & 0x60, v2, t);
}
// 80AF0D0: variable 'y' is possibly undefined

//----- (080AF130) --------------------------------------------------------
reflect_Value_0 __golang reflect_cvtUintFloat(reflect_Value_0 v, reflect_Type_0 t)
{
  float64 v2; // [esp+8h] [ebp-18h]
  uint64 y; // [esp+Ch] [ebp-14h]

  HIDWORD(y) = reflect_Value_Uint(v);
  v2 = runtime_uint64tofloat64(y);
  return reflect_makeFloat(v.flag & 0x60, v2, t);
}
// 80AF170: variable 'y' is possibly undefined

//----- (080AF1D0) --------------------------------------------------------
reflect_Value_0 __golang reflect_cvtFloat(reflect_Value_0 v, reflect_Type_0 t)
{
  long double v2; // [esp+Ch] [ebp-14h]

  *(double *)((char *)&v2 + 4) = reflect_Value_Float(v);
  return reflect_makeFloat(v.flag & 0x60, *(float64 *)&v2, t);
}
// 80AF227: variable 'v2' is possibly undefined

//----- (080AF250) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
reflect_Value_0 __golang reflect_cvtComplex(reflect_Value_0 v, reflect_Type_0 t)
{
  complex128 v2; // [esp+4h] [ebp-24h]

  v2 = reflect_Value_Complex(v);
  return reflect_makeComplex(v.flag & 0x60, v2, t);
}
// 80AF27D: failed to expand linear variable ^C.16

//----- (080AF2E0) --------------------------------------------------------
reflect_Value_0 __golang reflect_cvtIntString(reflect_Value_0 v, reflect_Type_0 t)
{
  int64 v2; // [esp+Ch] [ebp-14h]
  int64 v3; // [esp+Ch] [ebp-14h]

  HIDWORD(v2) = reflect_Value_Int(v);
  v3 = (int64)runtime_intstring(0, v2);
  return reflect_makeString(v.flag & 0x60, (string)v3, t);
}
// 80AF32C: variable 'v2' is possibly undefined

//----- (080AF390) --------------------------------------------------------
reflect_Value_0 __golang reflect_cvtUintString(reflect_Value_0 v, reflect_Type_0 t)
{
  int64 v2; // [esp+Ch] [ebp-14h]
  int64 v3; // [esp+Ch] [ebp-14h]

  HIDWORD(v2) = reflect_Value_Uint(v);
  v3 = (int64)runtime_intstring(0, v2);
  return reflect_makeString(v.flag & 0x60, (string)v3, t);
}
// 80AF3DC: variable 'v2' is possibly undefined

//----- (080AF440) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
reflect_Value_0 __golang reflect_cvtBytesString(reflect_Value_0 v, reflect_Type_0 t)
{
  int v2; // [esp+4h] [ebp-1Ch]
  __int128 var20_8; // [esp+8h] [ebp-18h] OVERLAPPED
  string b_4; // [esp+10h] [ebp-10h]

  *(__uint8 *)((char *)&var20_8 + 4) = reflect_Value_Bytes(v);
  v2 = DWORD1(var20_8);
  *(_QWORD *)&var20_8 = *((_QWORD *)&var20_8 + 1);
  runtime_slicebytetostring(0, *(__uint8 *)((char *)&var20_8 - 4), *((string *)&var20_8 + 1));
  return reflect_makeString(v.flag & 0x60, b_4, t);
}
// 80AF471: failed to expand linear variable ^8.16

//----- (080AF4F0) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
reflect_Value_0 __golang reflect_cvtStringBytes(reflect_Value_0 v, reflect_Type_0 t)
{
  int v2; // [esp+4h] [ebp-20h]
  __int128 var24_8; // [esp+8h] [ebp-1Ch] OVERLAPPED
  string s; // [esp+Ch] [ebp-18h]

  s = reflect_Value_String(v);
  *(__uint8 *)((char *)&var24_8 + 4) = runtime_stringtoslicebyte(0, s);
  v2 = DWORD1(var24_8);
  *(_QWORD *)&var24_8 = *((_QWORD *)&var24_8 + 1);
  return reflect_makeBytes(v.flag & 0x60, *(__uint8 *)((char *)&var24_8 - 4), t);
}
// 80AF53D: failed to expand linear variable ^8.16

//----- (080AF5A0) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
reflect_Value_0 __golang reflect_cvtRunesString(reflect_Value_0 v, reflect_Type_0 t)
{
  int v2; // [esp+4h] [ebp-1Ch]
  __int128 var20_8; // [esp+8h] [ebp-18h] OVERLAPPED
  string a_4; // [esp+10h] [ebp-10h]

  *(__int32 *)((char *)&var20_8 + 4) = reflect_Value_runes(v);
  v2 = DWORD1(var20_8);
  *(_QWORD *)&var20_8 = *((_QWORD *)&var20_8 + 1);
  a_4 = runtime_slicerunetostring(0, *(__int32 *)((char *)&var20_8 - 4));
  return reflect_makeString(v.flag & 0x60, a_4, t);
}
// 80AF5D1: failed to expand linear variable ^8.16

//----- (080AF650) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
reflect_Value_0 __golang reflect_cvtStringRunes(reflect_Value_0 v, reflect_Type_0 t)
{
  int v2; // [esp+4h] [ebp-20h]
  __int128 var24_8; // [esp+8h] [ebp-1Ch] OVERLAPPED
  string s; // [esp+Ch] [ebp-18h]

  s = reflect_Value_String(v);
  *(__int32 *)((char *)&var24_8 + 4) = runtime_stringtoslicerune(0, s);
  v2 = DWORD1(var24_8);
  *(_QWORD *)&var24_8 = *((_QWORD *)&var24_8 + 1);
  return reflect_makeRunes(v.flag & 0x60, *(__int32 *)((char *)&var24_8 - 4), t);
}
// 80AF69D: failed to expand linear variable ^8.16

//----- (080AF700) --------------------------------------------------------
reflect_Value_0 __golang reflect_cvtDirect(reflect_Value_0 v, reflect_Type_0 typ)
{
  reflect_rtype *v2; // eax
  reflect_flag flag; // ecx
  char v4; // dl
  void *ptr; // ebx
  runtime__type_0 *v6; // [esp+4h] [ebp-10h]
  reflect_rtype *t; // [esp+Ch] [ebp-8h]
  void *c; // [esp+10h] [ebp-4h]
  reflect_Value_0 _r2; // [esp+2Ch] [ebp+18h]

  v6 = (runtime__type_0 *)(*(int (__golang **)(void *))&typ.tab[5].bad)(typ.data);
  v2 = (reflect_rtype *)v6;
  flag = v.flag;
  if ( (v.flag & 0x100) != 0 )
  {
    t = (reflect_rtype *)v6;
    c = reflect_unsafe_New(v6);
    reflect_typedmemmove(v6, c, v.ptr);
    v4 = v.flag;
    flag = v.flag & 0xFFFFFEFF;
    v2 = t;
    ptr = c;
  }
  else
  {
    v4 = v.flag;
    ptr = v.ptr;
  }
  _r2.typ = v2;
  _r2.ptr = ptr;
  _r2.flag = flag | v4 & 0x60;
  return _r2;
}

//----- (080AF7A0) --------------------------------------------------------
reflect_Value_0 __golang reflect_cvtT2I(reflect_Value_0 v, reflect_Type_0 typ)
{
  runtime__type_0 *v2; // [esp+4h] [ebp-20h]
  interface_{} x_type; // [esp+18h] [ebp-Ch]
  void *target; // [esp+20h] [ebp-4h]
  reflect_Value_0 _r2; // [esp+3Ch] [ebp+18h]

  v2 = (runtime__type_0 *)(*(int (__golang **)(void *))&typ.tab[5].bad)(typ.data);
  target = reflect_unsafe_New(v2);
  x_type = reflect_valueInterface(v, 0);
  if ( (*(int (__golang **)(void *))&typ.tab[4].bad)(typ.data) )
  {
    if ( (reflect_Type_0 *)typ.tab != &go_itab__reflect_rtype_reflect_Type )
      runtime_panicdottypeI(typ.tab, (runtime__type_0 *)&key, (runtime__type_0 *)&stru_80DBAE0);
    reflect_ifaceE2I((runtime_interfacetype_0 *)typ.data, x_type, (runtime_iface_0 *)target);
  }
  else
  {
    *(_DWORD *)target = x_type._type;
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr((uintptr *)target + 1, (uintptr)x_type.data);
    else
      *((_DWORD *)target + 1) = x_type.data;
  }
  _r2.typ = (reflect_rtype *)(*(int (__golang **)(void *))&typ.tab[5].bad)(typ.data);
  _r2.ptr = target;
  _r2.flag = v.flag & 0x60 | 0x94;
  return _r2;
}

//----- (080AF900) --------------------------------------------------------
reflect_Value_0 __golang reflect_cvtI2I(reflect_Value_0 v, reflect_Type_0 typ)
{
  reflect_Value_0 v2; // [esp+8h] [ebp-18h]
  reflect_Value_0 v3; // [esp+Ch] [ebp-14h]
  reflect_Value_0 _r2; // [esp+38h] [ebp+18h]

  if ( reflect_Value_IsNil(v) )
  {
    v2 = reflect_Zero(typ);
    _r2.typ = v2.typ;
    _r2.ptr = v2.ptr;
    _r2.flag = v.flag & 0x60 | v2.flag;
  }
  else
  {
    v3 = reflect_Value_Elem(v);
    return reflect_cvtT2I(v3, typ);
  }
  return _r2;
}

//----- (080AF9F0) --------------------------------------------------------
bool __golang reflect___ptr_structType__FieldByName_func1(string s)
{
  int v1; // edx
  bool v3; // [esp+10h] [ebp-4h]

  if ( s.len != *(_DWORD *)(v1 + 8) )
    return 0;
  runtime_eqstring();
  return v3;
}
// 80AFA08: variable 'v1' is possibly undefined
// 80AFA35: variable 'v3' is possibly undefined

//----- (080AFA50) --------------------------------------------------------
reflect_Type_0 __golang reflect_FuncOf_func1(reflect_rtype *tt)
{
  int v1; // edx
  void *array; // ecx
  unsigned int v3; // ebx
  __int32 cap; // edx
  __int32 v5; // ebp
  interface_{} key; // [esp+4h] [ebp-4Ch]
  runtime_slice_0 keya; // [esp+4h] [ebp-4Ch]
  interface_{} key_4; // [esp+8h] [ebp-48h]
  runtime_eface_0 key_4a; // [esp+8h] [ebp-48h]
  interface_{} key_4b; // [esp+8h] [ebp-48h]
  interface_{} value; // [esp+Ch] [ebp-44h]
  int value_4; // [esp+10h] [ebp-40h]
  bool v13; // [esp+14h] [ebp-3Ch]
  char v14; // [esp+14h] [ebp-3Ch]
  runtime_slice_0 v15; // [esp+14h] [ebp-3Ch]
  runtime__type_0 *hash; // [esp+24h] [ebp-2Ch]
  __int32 v17; // [esp+28h] [ebp-28h]
  runtime_eface_0 e; // [esp+30h] [ebp-20h] BYREF
  void *v19; // [esp+38h] [ebp-18h]
  void *data; // [esp+3Ch] [ebp-14h]
  interface_{} v21; // [esp+40h] [ebp-10h] BYREF
  int v22; // [esp+48h] [ebp-8h]
  int v23; // [esp+4Ch] [ebp-4h]
  reflect_Type_0 _r1; // [esp+58h] [ebp+8h]

  hash = *(runtime__type_0 **)(v1 + 4);
  e._type = hash;
  key._type = (runtime__type_0 *)&stru_80CF2A0;
  key.data = &e;
  sync___ptr_Map__Load(&reflect_funcLookupCache.m, key, value, v13);
  if ( v14 )
  {
    if ( key_4.data != &stru_80C9000 )
      runtime_panicdottypeE(
        (runtime__type_0 *)key_4.data,
        (runtime__type_0 *)&stru_80C9000,
        (runtime__type_0 *)&stru_80CECA0);
    array = *(void **)value_4;
    v3 = *(_DWORD *)(value_4 + 4);
    cap = *(_DWORD *)(value_4 + 8);
  }
  else
  {
    v3 = 0;
    array = 0;
    cap = 0;
  }
  e.data = hash;
  v5 = v3 + 1;
  if ( (int)(v3 + 1) > cap )
  {
    keya.array = array;
    *(_QWORD *)&keya.len = __PAIR64__(cap, v3);
    v15 = runtime_growslice((runtime__type_0 *)&::key, keya, v3 + 1);
    array = v15.array;
    cap = v15.cap;
    v5 = v15.len + 1;
  }
  if ( *(_DWORD *)&runtime_writeBarrier.enabled )
  {
    v19 = array;
    v17 = cap;
    runtime_writebarrierptr((uintptr *)array + v3, (uintptr)tt);
    array = v19;
    cap = v17;
  }
  else
  {
    *((_DWORD *)array + v3) = tt;
  }
  v21.data = array;
  v22 = v5;
  v23 = cap;
  runtime_convT2E32((runtime__type_0 *)&stru_80CF2A0, &e.data, key_4);
  data = key_4a.data;
  v21._type = key_4a._type;
  runtime_convT2Eslice((runtime__type_0 *)&stru_80C9000, &v21.data, key_4a);
  sync___ptr_Map__Store(
    &reflect_funcLookupCache.m,
    (interface_{})__PAIR64__((unsigned int)data, (unsigned int)v21._type),
    key_4b);
  _r1.tab = (runtime_itab_0 *)&go_itab__reflect_rtype_reflect_Type;
  _r1.data = tt;
  return _r1;
}
// 80AFA69: variable 'v1' is possibly undefined
// 80AFA8F: variable 'value' is possibly undefined
// 80AFA8F: variable 'v13' is possibly undefined
// 80AFAA3: variable 'v14' is possibly undefined
// 80AFAB1: variable 'key_4' is possibly undefined
// 80AFAB7: variable 'value_4' is possibly undefined
// 80AFB18: variable 'key_4a' is possibly undefined
// 80AFB5B: variable 'key_4b' is possibly undefined

//----- (080AFC20) --------------------------------------------------------
interface_{} __golang reflect_funcLayout_func1()
{
  int v0; // edx
  interface_{} _r0; // [esp+Ch] [ebp+4h]

  _r0._type = (runtime__type_0 *)&x;
  _r0.data = reflect_unsafe_New(*(runtime__type_0 **)(v0 + 4));
  return _r0;
}
// 80AFC35: variable 'v0' is possibly undefined

//----- (080AFC60) --------------------------------------------------------
void __golang reflect_init()
{
  interface_{} i; // [esp+0h] [ebp-10h]
  reflect_Type_0 iface; // [esp+8h] [ebp-8h]

  if ( reflect_initdone_ <= 1u )
  {
    if ( reflect_initdone_ == 1 )
      runtime_throwinit();
    reflect_initdone_ = 1;
    runtime_init();
    strconv_init();
    sync_init();
    unicode_init();
    i._type = (runtime__type_0 *)&::i;
    i.data = &runtime_staticbytes[runtime_egcdata];
    iface = reflect_TypeOf(i);
    if ( (reflect_Type_0 *)iface.tab != &go_itab__reflect_rtype_reflect_Type )
      runtime_panicdottypeI(iface.tab, (runtime__type_0 *)&key, (runtime__type_0 *)&stru_80DBAE0);
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr(&reflect_uint8Type, (uintptr)iface.data);
    else
      reflect_uint8Type = (uintptr)iface.data;
    reflect_initdone_ = 2;
  }
}

//----- (080AFD40) --------------------------------------------------------
void __golang reflect_methodValueCall()
{
  reflect_methodValue *v0; // edx
  reflect_methodValue ***v1; // ebx
  reflect_methodValue *ctxt; // [esp+0h] [ebp-8h] BYREF
  char frame; // [esp+Ch] [ebp+4h] BYREF

  v1 = *(reflect_methodValue ****)(*(_DWORD *)(__readgsdword(0) - 4) + 16);
  if ( v1 && *v1 == (reflect_methodValue **)&frame )
    *v1 = &ctxt;
  reflect_callMethod(v0, &frame);
}
// 80AFD62: variable 'v0' is possibly undefined

//----- (080AFD80) --------------------------------------------------------
string __golang reflect___ptr_ChanDir__String(reflect_ChanDir *.this)
{
  int v1; // ecx
  reflect_ChanDir **v2; // ebx
  reflect_ChanDir d; // [esp+0h] [ebp-Ch] BYREF

  v2 = *(reflect_ChanDir ***)(v1 + 16);
  if ( v2 && *v2 == (reflect_ChanDir *)&.this )
    *v2 = &d;
  if ( !.this )
    runtime_panicwrap();
  return reflect_ChanDir_String(*.this);
}
// 80AFD95: variable 'v1' is possibly undefined

//----- (080AFDE0) --------------------------------------------------------
string __golang reflect___ptr_Kind__String(reflect_Kind *.this)
{
  int v1; // ecx
  reflect_Kind **v2; // ebx
  reflect_Kind k; // [esp+0h] [ebp-Ch] BYREF

  v2 = *(reflect_Kind ***)(v1 + 16);
  if ( v2 && *v2 == (reflect_Kind *)&.this )
    *v2 = &k;
  if ( !.this )
    runtime_panicwrap();
  return reflect_Kind_String(*.this);
}
// 80AFDF5: variable 'v1' is possibly undefined

//----- (080AFE40) --------------------------------------------------------
uintptr __golang type__hash_reflect_uncommonType(reflect_uncommonType *p, uintptr h)
{
  uintptr seed; // [esp+Ch] [ebp-4h]

  seed = runtime_memhash(p, h, 6u);
  return runtime_memhash(&p->moff, seed, 4u);
}

//----- (080AFEB0) --------------------------------------------------------
bool __golang type__eq_reflect_uncommonType(reflect_uncommonType *p, reflect_uncommonType *q)
{
  return p->pkgPath == q->pkgPath && p->mcount == q->mcount && p->moff == q->moff;
}

//----- (080AFF00) --------------------------------------------------------
reflect_Kind __golang reflect___ptr_Value__Kind(reflect_Value_0 *.this)
{
  int v1; // ecx
  reflect_Value_0 ***v2; // ebx
  void *retaddr; // [esp+0h] [ebp+0h] BYREF

  v2 = *(reflect_Value_0 ****)(v1 + 16);
  if ( v2 && *v2 == &.this )
    *v2 = (reflect_Value_0 **)&retaddr;
  if ( !.this )
    runtime_panicwrap();
  return .this->flag & 0x1F;
}
// 80AFF12: variable 'v1' is possibly undefined

//----- (080AFF50) --------------------------------------------------------
__int32 __golang reflect___ptr_Value__Len(reflect_Value_0 *.this)
{
  int v1; // ecx
  reflect_Value_0 **v2; // ebx
  void *ptr; // ecx
  reflect_flag flag; // eax
  reflect_Value_0 v; // [esp+0h] [ebp-10h] BYREF

  v2 = *(reflect_Value_0 ***)(v1 + 16);
  if ( v2 && *v2 == (reflect_Value_0 *)&.this )
    *v2 = &v;
  if ( !.this )
    runtime_panicwrap();
  ptr = .this->ptr;
  flag = .this->flag;
  v.typ = .this->typ;
  v.ptr = ptr;
  v.flag = flag;
  return reflect_Value_Len(v);
}
// 80AFF65: variable 'v1' is possibly undefined

//----- (080AFFC0) --------------------------------------------------------
__int32 __golang reflect___ptr_Value__NumMethod(reflect_Value_0 *.this)
{
  int v1; // ecx
  reflect_Value_0 **v2; // ebx
  void *ptr; // ecx
  reflect_flag flag; // eax
  reflect_Value_0 v; // [esp+0h] [ebp-10h] BYREF

  v2 = *(reflect_Value_0 ***)(v1 + 16);
  if ( v2 && *v2 == (reflect_Value_0 *)&.this )
    *v2 = &v;
  if ( !.this )
    runtime_panicwrap();
  ptr = .this->ptr;
  flag = .this->flag;
  v.typ = .this->typ;
  v.ptr = ptr;
  v.flag = flag;
  return reflect_Value_NumMethod(v);
}
// 80AFFD5: variable 'v1' is possibly undefined

//----- (080B0030) --------------------------------------------------------
__int32 __golang reflect___ptr_Value__NumField(reflect_Value_0 *.this)
{
  int v1; // ecx
  reflect_Value_0 **v2; // ebx
  void *ptr; // ecx
  reflect_flag flag; // eax
  reflect_Value_0 v; // [esp+0h] [ebp-10h] BYREF

  v2 = *(reflect_Value_0 ***)(v1 + 16);
  if ( v2 && *v2 == (reflect_Value_0 *)&.this )
    *v2 = &v;
  if ( !.this )
    runtime_panicwrap();
  ptr = .this->ptr;
  flag = .this->flag;
  v.typ = .this->typ;
  v.ptr = ptr;
  v.flag = flag;
  return reflect_Value_NumField(v);
}
// 80B0045: variable 'v1' is possibly undefined

//----- (080B00A0) --------------------------------------------------------
string __golang reflect___ptr_Value__String(reflect_Value_0 *.this)
{
  int v1; // ecx
  reflect_Value_0 **v2; // ebx
  void *ptr; // ecx
  reflect_flag flag; // eax
  reflect_Value_0 v; // [esp+0h] [ebp-14h] BYREF

  v2 = *(reflect_Value_0 ***)(v1 + 16);
  if ( v2 && *v2 == (reflect_Value_0 *)&.this )
    *v2 = &v;
  if ( !.this )
    runtime_panicwrap();
  ptr = .this->ptr;
  flag = .this->flag;
  v.typ = .this->typ;
  v.ptr = ptr;
  v.flag = flag;
  return reflect_Value_String(v);
}
// 80B00B5: variable 'v1' is possibly undefined

//----- (080B0110) --------------------------------------------------------
uintptr __golang type__hash_reflect_Method(reflect_Method_0 *p, uintptr h)
{
  uintptr s; // [esp+8h] [ebp-8h]
  uintptr sa; // [esp+8h] [ebp-8h]
  uintptr sb; // [esp+8h] [ebp-8h]

  s = runtime_strhash(p, h);
  sa = runtime_strhash(&p->PkgPath, s);
  sb = runtime_interhash(&p->Type, sa);
  return runtime_memhash(&p->Func, sb, 0x10u);
}

//----- (080B01A0) --------------------------------------------------------
bool __golang type__eq_reflect_Method(reflect_Method_0 *p, reflect_Method_0 *q)
{
  reflect_Method_0 *v2; // eax
  reflect_Method_0 *v3; // edx
  char v4; // cl
  char v5; // cl
  bool v6; // cl
  bool v7; // cl
  char v9; // [esp+10h] [ebp-4h]

  v2 = p;
  v3 = q;
  if ( p->Name.len == q->Name.len )
  {
    runtime_eqstring();
    v4 = v9;
    v2 = p;
    v3 = q;
  }
  else
  {
    v4 = 0;
  }
  if ( v4 )
  {
    if ( v2->PkgPath.len == v3->PkgPath.len )
    {
      runtime_eqstring();
      v5 = v9;
      v2 = p;
      v3 = q;
    }
    else
    {
      v5 = 0;
    }
  }
  else
  {
    v5 = 0;
  }
  if ( v5 )
  {
    if ( v2->Type.tab == v3->Type.tab )
    {
      v6 = runtime_ifaceeq(v2->Type.tab, v2->Type.data, v3->Type.data);
      v2 = p;
      v3 = q;
    }
    else
    {
      v6 = 0;
    }
  }
  else
  {
    v6 = 0;
  }
  if ( !v6 )
    return 0;
  v7 = v2->Func.typ == v3->Func.typ && v2->Func.ptr == v3->Func.ptr && v2->Func.flag == v3->Func.flag;
  return v7 && v2->Index == v3->Index;
}
// 80B028A: variable 'v9' is possibly undefined

//----- (080B02E0) --------------------------------------------------------
uintptr __golang type__hash_reflect_ValueError(reflect_ValueError *p, uintptr h)
{
  uintptr s; // [esp+8h] [ebp-8h]

  s = runtime_strhash(p, h);
  return runtime_memhash(&p->Kind, s, 4u);
}

//----- (080B0340) --------------------------------------------------------
bool __golang type__eq_reflect_ValueError(reflect_ValueError *p, reflect_ValueError *q)
{
  reflect_ValueError *v2; // eax
  reflect_ValueError *v3; // ebx
  char v4; // cl
  char v6; // [esp+10h] [ebp-4h]

  v2 = p;
  v3 = q;
  if ( p->Method.len == q->Method.len )
  {
    runtime_eqstring();
    v4 = v6;
    v2 = p;
    v3 = q;
  }
  else
  {
    v4 = 0;
  }
  return v4 && v2->Kind == v3->Kind;
}
// 80B039C: variable 'v6' is possibly undefined

//----- (080B03C0) --------------------------------------------------------
reflect_uncommonType *__golang reflect___ptr_structType__uncommon(reflect_structType *.this)
{
  return reflect___ptr_rtype__uncommon(&.this->rtype);
}

//----- (080B03F0) --------------------------------------------------------
string __golang reflect___ptr_structType__String(reflect_structType *.this)
{
  return reflect___ptr_rtype__String(&.this->rtype);
}

//----- (080B0430) --------------------------------------------------------
uintptr __golang reflect___ptr_structType__Size(reflect_structType *.this)
{
  return reflect___ptr_rtype__Size(&.this->rtype);
}

//----- (080B0460) --------------------------------------------------------
__int32 __golang reflect___ptr_structType__Bits(reflect_structType *.this)
{
  return reflect___ptr_rtype__Bits(&.this->rtype);
}

//----- (080B0490) --------------------------------------------------------
__int32 __golang reflect___ptr_structType__Align(reflect_structType *.this)
{
  return reflect___ptr_rtype__Align(&.this->rtype);
}

//----- (080B04C0) --------------------------------------------------------
__int32 __golang reflect___ptr_structType__FieldAlign(reflect_structType *.this)
{
  return reflect___ptr_rtype__FieldAlign(&.this->rtype);
}

//----- (080B04F0) --------------------------------------------------------
reflect_Kind __golang reflect___ptr_structType__Kind(reflect_structType *.this)
{
  return reflect___ptr_rtype__Kind(&.this->rtype);
}

//----- (080B0520) --------------------------------------------------------
reflect_rtype *__golang reflect___ptr_structType__common(reflect_structType *.this)
{
  return reflect___ptr_rtype__common(&.this->rtype);
}

//----- (080B0550) --------------------------------------------------------
__int32 __golang reflect___ptr_structType__NumMethod(reflect_structType *.this)
{
  return reflect___ptr_rtype__NumMethod(&.this->rtype);
}

//----- (080B0580) --------------------------------------------------------
void __golang reflect___ptr_structType__Method(reflect_structType *.this, __int32 i, reflect_Method_0 m)
{
  ((void (*)(void))loc_808FD86)();
  reflect___ptr_rtype__Method(&.this->rtype, i, m);
}

//----- (080B05C0) --------------------------------------------------------
void __golang reflect___ptr_structType__MethodByName(
        reflect_structType *.this,
        string name,
        reflect_Method_0 m,
        bool ok)
{
  ((void (*)(void))loc_808FD86)();
  reflect___ptr_rtype__MethodByName(&.this->rtype, name, m, 0);
}

//----- (080B0600) --------------------------------------------------------
string __golang reflect___ptr_structType__PkgPath(reflect_structType *.this)
{
  return reflect___ptr_rtype__PkgPath(&.this->rtype);
}

//----- (080B0640) --------------------------------------------------------
string __golang reflect___ptr_structType__Name(reflect_structType *.this)
{
  return reflect___ptr_rtype__Name(&.this->rtype);
}

//----- (080B0680) --------------------------------------------------------
reflect_ChanDir __golang reflect___ptr_structType__ChanDir(reflect_structType *.this)
{
  return reflect___ptr_rtype__ChanDir(&.this->rtype);
}

//----- (080B06B0) --------------------------------------------------------
bool __golang reflect___ptr_structType__IsVariadic(reflect_structType *.this)
{
  return reflect___ptr_rtype__IsVariadic(&.this->rtype);
}

//----- (080B06E0) --------------------------------------------------------
reflect_Type_0 __golang reflect___ptr_structType__Elem(reflect_structType *.this)
{
  return reflect___ptr_rtype__Elem(&.this->rtype);
}

//----- (080B0720) --------------------------------------------------------
reflect_Type_0 __golang reflect___ptr_structType__In(reflect_structType *.this, __int32 i)
{
  return reflect___ptr_rtype__In(&.this->rtype, i);
}

//----- (080B0760) --------------------------------------------------------
reflect_Type_0 __golang reflect___ptr_structType__Key(reflect_structType *.this)
{
  return reflect___ptr_rtype__Key(&.this->rtype);
}

//----- (080B07A0) --------------------------------------------------------
__int32 __golang reflect___ptr_structType__Len(reflect_structType *.this)
{
  return reflect___ptr_rtype__Len(&.this->rtype);
}

//----- (080B07D0) --------------------------------------------------------
__int32 __golang reflect___ptr_structType__NumField(reflect_structType *.this)
{
  return reflect___ptr_rtype__NumField(&.this->rtype);
}

//----- (080B0800) --------------------------------------------------------
__int32 __golang reflect___ptr_structType__NumIn(reflect_structType *.this)
{
  return reflect___ptr_rtype__NumIn(&.this->rtype);
}

//----- (080B0830) --------------------------------------------------------
__int32 __golang reflect___ptr_structType__NumOut(reflect_structType *.this)
{
  return reflect___ptr_rtype__NumOut(&.this->rtype);
}

//----- (080B0860) --------------------------------------------------------
reflect_Type_0 __golang reflect___ptr_structType__Out(reflect_structType *.this, __int32 i)
{
  return reflect___ptr_rtype__Out(&.this->rtype, i);
}

//----- (080B08A0) --------------------------------------------------------
bool __golang reflect___ptr_structType__Implements(reflect_structType *.this, reflect_Type_0 u)
{
  return reflect___ptr_rtype__Implements(&.this->rtype, u);
}

//----- (080B08D0) --------------------------------------------------------
bool __golang reflect___ptr_structType__AssignableTo(reflect_structType *.this, reflect_Type_0 u)
{
  return reflect___ptr_rtype__AssignableTo(&.this->rtype, u);
}

//----- (080B0900) --------------------------------------------------------
bool __golang reflect___ptr_structType__ConvertibleTo(reflect_structType *.this, reflect_Type_0 u)
{
  return reflect___ptr_rtype__ConvertibleTo(&.this->rtype, u);
}

//----- (080B0930) --------------------------------------------------------
bool __golang reflect___ptr_structType__Comparable(reflect_structType *.this)
{
  return reflect___ptr_rtype__Comparable(&.this->rtype);
}

//----- (080B0960) --------------------------------------------------------
reflect_uncommonType *__golang reflect___ptr_funcType__uncommon(reflect_funcType *.this)
{
  return reflect___ptr_rtype__uncommon(&.this->rtype);
}

//----- (080B0990) --------------------------------------------------------
string __golang reflect___ptr_funcType__String(reflect_funcType *.this)
{
  return reflect___ptr_rtype__String(&.this->rtype);
}

//----- (080B09D0) --------------------------------------------------------
uintptr __golang reflect___ptr_funcType__Size(reflect_funcType *.this)
{
  return reflect___ptr_rtype__Size(&.this->rtype);
}

//----- (080B0A00) --------------------------------------------------------
__int32 __golang reflect___ptr_funcType__Bits(reflect_funcType *.this)
{
  return reflect___ptr_rtype__Bits(&.this->rtype);
}

//----- (080B0A30) --------------------------------------------------------
__int32 __golang reflect___ptr_funcType__Align(reflect_funcType *.this)
{
  return reflect___ptr_rtype__Align(&.this->rtype);
}

//----- (080B0A60) --------------------------------------------------------
__int32 __golang reflect___ptr_funcType__FieldAlign(reflect_funcType *.this)
{
  return reflect___ptr_rtype__FieldAlign(&.this->rtype);
}

//----- (080B0A90) --------------------------------------------------------
reflect_Kind __golang reflect___ptr_funcType__Kind(reflect_funcType *.this)
{
  return reflect___ptr_rtype__Kind(&.this->rtype);
}

//----- (080B0AC0) --------------------------------------------------------
reflect_rtype *__golang reflect___ptr_funcType__common(reflect_funcType *.this)
{
  return reflect___ptr_rtype__common(&.this->rtype);
}

//----- (080B0AF0) --------------------------------------------------------
__int32 __golang reflect___ptr_funcType__NumMethod(reflect_funcType *.this)
{
  return reflect___ptr_rtype__NumMethod(&.this->rtype);
}

//----- (080B0B20) --------------------------------------------------------
void __golang reflect___ptr_funcType__Method(reflect_funcType *.this, __int32 i, reflect_Method_0 m)
{
  ((void (*)(void))loc_808FD86)();
  reflect___ptr_rtype__Method(&.this->rtype, i, m);
}

//----- (080B0B60) --------------------------------------------------------
void __golang reflect___ptr_funcType__MethodByName(reflect_funcType *.this, string name, reflect_Method_0 m, bool ok)
{
  ((void (*)(void))loc_808FD86)();
  reflect___ptr_rtype__MethodByName(&.this->rtype, name, m, 0);
}

//----- (080B0BA0) --------------------------------------------------------
string __golang reflect___ptr_funcType__PkgPath(reflect_funcType *.this)
{
  return reflect___ptr_rtype__PkgPath(&.this->rtype);
}

//----- (080B0BE0) --------------------------------------------------------
string __golang reflect___ptr_funcType__Name(reflect_funcType *.this)
{
  return reflect___ptr_rtype__Name(&.this->rtype);
}

//----- (080B0C20) --------------------------------------------------------
reflect_ChanDir __golang reflect___ptr_funcType__ChanDir(reflect_funcType *.this)
{
  return reflect___ptr_rtype__ChanDir(&.this->rtype);
}

//----- (080B0C50) --------------------------------------------------------
bool __golang reflect___ptr_funcType__IsVariadic(reflect_funcType *.this)
{
  return reflect___ptr_rtype__IsVariadic(&.this->rtype);
}

//----- (080B0C80) --------------------------------------------------------
reflect_Type_0 __golang reflect___ptr_funcType__Elem(reflect_funcType *.this)
{
  return reflect___ptr_rtype__Elem(&.this->rtype);
}

//----- (080B0CC0) --------------------------------------------------------
reflect_StructField_0 __golang reflect___ptr_funcType__Field(reflect_funcType *.this, __int32 i)
{
  ((void (*)(void))loc_808FD83)();
  return reflect___ptr_rtype__Field(&.this->rtype, i);
}

//----- (080B0D00) --------------------------------------------------------
reflect_StructField_0 __golang reflect___ptr_funcType__FieldByIndex(reflect_funcType *.this, __int index)
{
  ((void (*)(void))loc_808FD83)();
  return reflect___ptr_rtype__FieldByIndex(&.this->rtype, index);
}

//----- (080B0D40) --------------------------------------------------------
retval_80B0D40 __golang reflect___ptr_funcType__FieldByName(reflect_funcType *.this, string name)
{
  ((void (*)(void))loc_808FD83)();
  return (retval_80B0D40)reflect___ptr_rtype__FieldByName(&.this->rtype, name);
}

//----- (080B0D80) --------------------------------------------------------
retval_80B0D80 __golang reflect___ptr_funcType__FieldByNameFunc(reflect_funcType *.this, func(string)_bool match)
{
  ((void (*)(void))loc_808FD83)();
  return (retval_80B0D80)reflect___ptr_rtype__FieldByNameFunc(&.this->rtype, match);
}

//----- (080B0DC0) --------------------------------------------------------
reflect_Type_0 __golang reflect___ptr_funcType__In(reflect_funcType *.this, __int32 i)
{
  return reflect___ptr_rtype__In(&.this->rtype, i);
}

//----- (080B0E00) --------------------------------------------------------
reflect_Type_0 __golang reflect___ptr_funcType__Key(reflect_funcType *.this)
{
  return reflect___ptr_rtype__Key(&.this->rtype);
}

//----- (080B0E40) --------------------------------------------------------
__int32 __golang reflect___ptr_funcType__Len(reflect_funcType *.this)
{
  return reflect___ptr_rtype__Len(&.this->rtype);
}

//----- (080B0E70) --------------------------------------------------------
__int32 __golang reflect___ptr_funcType__NumField(reflect_funcType *.this)
{
  return reflect___ptr_rtype__NumField(&.this->rtype);
}

//----- (080B0EA0) --------------------------------------------------------
__int32 __golang reflect___ptr_funcType__NumIn(reflect_funcType *.this)
{
  return reflect___ptr_rtype__NumIn(&.this->rtype);
}

//----- (080B0ED0) --------------------------------------------------------
__int32 __golang reflect___ptr_funcType__NumOut(reflect_funcType *.this)
{
  return reflect___ptr_rtype__NumOut(&.this->rtype);
}

//----- (080B0F00) --------------------------------------------------------
reflect_Type_0 __golang reflect___ptr_funcType__Out(reflect_funcType *.this, __int32 i)
{
  return reflect___ptr_rtype__Out(&.this->rtype, i);
}

//----- (080B0F40) --------------------------------------------------------
bool __golang reflect___ptr_funcType__Implements(reflect_funcType *.this, reflect_Type_0 u)
{
  return reflect___ptr_rtype__Implements(&.this->rtype, u);
}

//----- (080B0F70) --------------------------------------------------------
bool __golang reflect___ptr_funcType__AssignableTo(reflect_funcType *.this, reflect_Type_0 u)
{
  return reflect___ptr_rtype__AssignableTo(&.this->rtype, u);
}

//----- (080B0FA0) --------------------------------------------------------
bool __golang reflect___ptr_funcType__ConvertibleTo(reflect_funcType *.this, reflect_Type_0 u)
{
  return reflect___ptr_rtype__ConvertibleTo(&.this->rtype, u);
}

//----- (080B0FD0) --------------------------------------------------------
bool __golang reflect___ptr_funcType__Comparable(reflect_funcType *.this)
{
  return reflect___ptr_rtype__Comparable(&.this->rtype);
}

//----- (080B1000) --------------------------------------------------------
reflect_uncommonType *__golang reflect___ptr_funcTypeFixed128__uncommon(reflect_funcTypeFixed128 *.this)
{
  return reflect___ptr_rtype__uncommon(&.this->funcType.rtype);
}

//----- (080B1030) --------------------------------------------------------
string __golang reflect___ptr_funcTypeFixed128__String(reflect_funcTypeFixed128 *.this)
{
  return reflect___ptr_rtype__String(&.this->funcType.rtype);
}

//----- (080B1070) --------------------------------------------------------
uintptr __golang reflect___ptr_funcTypeFixed128__Size(reflect_funcTypeFixed128 *.this)
{
  return reflect___ptr_rtype__Size(&.this->funcType.rtype);
}

//----- (080B10A0) --------------------------------------------------------
__int32 __golang reflect___ptr_funcTypeFixed128__Bits(reflect_funcTypeFixed128 *.this)
{
  return reflect___ptr_rtype__Bits(&.this->funcType.rtype);
}

//----- (080B10D0) --------------------------------------------------------
__int32 __golang reflect___ptr_funcTypeFixed128__Align(reflect_funcTypeFixed128 *.this)
{
  return reflect___ptr_rtype__Align(&.this->funcType.rtype);
}

//----- (080B1100) --------------------------------------------------------
__int32 __golang reflect___ptr_funcTypeFixed128__FieldAlign(reflect_funcTypeFixed128 *.this)
{
  return reflect___ptr_rtype__FieldAlign(&.this->funcType.rtype);
}

//----- (080B1130) --------------------------------------------------------
reflect_Kind __golang reflect___ptr_funcTypeFixed128__Kind(reflect_funcTypeFixed128 *.this)
{
  return reflect___ptr_rtype__Kind(&.this->funcType.rtype);
}

//----- (080B1160) --------------------------------------------------------
reflect_rtype *__golang reflect___ptr_funcTypeFixed128__common(reflect_funcTypeFixed128 *.this)
{
  return reflect___ptr_rtype__common(&.this->funcType.rtype);
}

//----- (080B1190) --------------------------------------------------------
__int32 __golang reflect___ptr_funcTypeFixed128__NumMethod(reflect_funcTypeFixed128 *.this)
{
  return reflect___ptr_rtype__NumMethod(&.this->funcType.rtype);
}

//----- (080B11C0) --------------------------------------------------------
void __golang reflect___ptr_funcTypeFixed128__Method(reflect_funcTypeFixed128 *.this, __int32 i, reflect_Method_0 m)
{
  ((void (*)(void))loc_808FD86)();
  reflect___ptr_rtype__Method(&.this->funcType.rtype, i, m);
}

//----- (080B1200) --------------------------------------------------------
void __golang reflect___ptr_funcTypeFixed128__MethodByName(
        reflect_funcTypeFixed128 *.this,
        string name,
        reflect_Method_0 m,
        bool ok)
{
  ((void (*)(void))loc_808FD86)();
  reflect___ptr_rtype__MethodByName(&.this->funcType.rtype, name, m, 0);
}

//----- (080B1240) --------------------------------------------------------
string __golang reflect___ptr_funcTypeFixed128__PkgPath(reflect_funcTypeFixed128 *.this)
{
  return reflect___ptr_rtype__PkgPath(&.this->funcType.rtype);
}

//----- (080B1280) --------------------------------------------------------
string __golang reflect___ptr_funcTypeFixed128__Name(reflect_funcTypeFixed128 *.this)
{
  return reflect___ptr_rtype__Name(&.this->funcType.rtype);
}

//----- (080B12C0) --------------------------------------------------------
reflect_ChanDir __golang reflect___ptr_funcTypeFixed128__ChanDir(reflect_funcTypeFixed128 *.this)
{
  return reflect___ptr_rtype__ChanDir(&.this->funcType.rtype);
}

//----- (080B12F0) --------------------------------------------------------
bool __golang reflect___ptr_funcTypeFixed128__IsVariadic(reflect_funcTypeFixed128 *.this)
{
  return reflect___ptr_rtype__IsVariadic(&.this->funcType.rtype);
}

//----- (080B1320) --------------------------------------------------------
reflect_Type_0 __golang reflect___ptr_funcTypeFixed128__Elem(reflect_funcTypeFixed128 *.this)
{
  return reflect___ptr_rtype__Elem(&.this->funcType.rtype);
}

//----- (080B1360) --------------------------------------------------------
reflect_StructField_0 __golang reflect___ptr_funcTypeFixed128__Field(reflect_funcTypeFixed128 *.this, __int32 i)
{
  ((void (*)(void))loc_808FD83)();
  return reflect___ptr_rtype__Field(&.this->funcType.rtype, i);
}

//----- (080B13A0) --------------------------------------------------------
reflect_StructField_0 __golang reflect___ptr_funcTypeFixed128__FieldByIndex(
        reflect_funcTypeFixed128 *.this,
        __int index)
{
  ((void (*)(void))loc_808FD83)();
  return reflect___ptr_rtype__FieldByIndex(&.this->funcType.rtype, index);
}

//----- (080B13E0) --------------------------------------------------------
retval_80B13E0 __golang reflect___ptr_funcTypeFixed128__FieldByName(reflect_funcTypeFixed128 *.this, string name)
{
  ((void (*)(void))loc_808FD83)();
  return (retval_80B13E0)reflect___ptr_rtype__FieldByName(&.this->funcType.rtype, name);
}

//----- (080B1420) --------------------------------------------------------
retval_80B1420 __golang reflect___ptr_funcTypeFixed128__FieldByNameFunc(
        reflect_funcTypeFixed128 *.this,
        func(string)_bool match)
{
  ((void (*)(void))loc_808FD83)();
  return (retval_80B1420)reflect___ptr_rtype__FieldByNameFunc(&.this->funcType.rtype, match);
}

//----- (080B1460) --------------------------------------------------------
reflect_Type_0 __golang reflect___ptr_funcTypeFixed128__In(reflect_funcTypeFixed128 *.this, __int32 i)
{
  return reflect___ptr_rtype__In(&.this->funcType.rtype, i);
}

//----- (080B14A0) --------------------------------------------------------
reflect_Type_0 __golang reflect___ptr_funcTypeFixed128__Key(reflect_funcTypeFixed128 *.this)
{
  return reflect___ptr_rtype__Key(&.this->funcType.rtype);
}

//----- (080B14E0) --------------------------------------------------------
__int32 __golang reflect___ptr_funcTypeFixed128__Len(reflect_funcTypeFixed128 *.this)
{
  return reflect___ptr_rtype__Len(&.this->funcType.rtype);
}

//----- (080B1510) --------------------------------------------------------
__int32 __golang reflect___ptr_funcTypeFixed128__NumField(reflect_funcTypeFixed128 *.this)
{
  return reflect___ptr_rtype__NumField(&.this->funcType.rtype);
}

//----- (080B1540) --------------------------------------------------------
__int32 __golang reflect___ptr_funcTypeFixed128__NumIn(reflect_funcTypeFixed128 *.this)
{
  return reflect___ptr_rtype__NumIn(&.this->funcType.rtype);
}

//----- (080B1570) --------------------------------------------------------
__int32 __golang reflect___ptr_funcTypeFixed128__NumOut(reflect_funcTypeFixed128 *.this)
{
  return reflect___ptr_rtype__NumOut(&.this->funcType.rtype);
}

//----- (080B15A0) --------------------------------------------------------
reflect_Type_0 __golang reflect___ptr_funcTypeFixed128__Out(reflect_funcTypeFixed128 *.this, __int32 i)
{
  return reflect___ptr_rtype__Out(&.this->funcType.rtype, i);
}

//----- (080B15E0) --------------------------------------------------------
bool __golang reflect___ptr_funcTypeFixed128__Implements(reflect_funcTypeFixed128 *.this, reflect_Type_0 u)
{
  return reflect___ptr_rtype__Implements(&.this->funcType.rtype, u);
}

//----- (080B1610) --------------------------------------------------------
bool __golang reflect___ptr_funcTypeFixed128__AssignableTo(reflect_funcTypeFixed128 *.this, reflect_Type_0 u)
{
  return reflect___ptr_rtype__AssignableTo(&.this->funcType.rtype, u);
}

//----- (080B1640) --------------------------------------------------------
bool __golang reflect___ptr_funcTypeFixed128__ConvertibleTo(reflect_funcTypeFixed128 *.this, reflect_Type_0 u)
{
  return reflect___ptr_rtype__ConvertibleTo(&.this->funcType.rtype, u);
}

//----- (080B1670) --------------------------------------------------------
bool __golang reflect___ptr_funcTypeFixed128__Comparable(reflect_funcTypeFixed128 *.this)
{
  return reflect___ptr_rtype__Comparable(&.this->funcType.rtype);
}

//----- (080B16A0) --------------------------------------------------------
reflect_uncommonType *__golang reflect___ptr_funcTypeFixed16__uncommon(reflect_funcTypeFixed16 *.this)
{
  return reflect___ptr_rtype__uncommon(&.this->funcType.rtype);
}

//----- (080B16D0) --------------------------------------------------------
string __golang reflect___ptr_funcTypeFixed16__String(reflect_funcTypeFixed16 *.this)
{
  return reflect___ptr_rtype__String(&.this->funcType.rtype);
}

//----- (080B1710) --------------------------------------------------------
uintptr __golang reflect___ptr_funcTypeFixed16__Size(reflect_funcTypeFixed16 *.this)
{
  return reflect___ptr_rtype__Size(&.this->funcType.rtype);
}

//----- (080B1740) --------------------------------------------------------
__int32 __golang reflect___ptr_funcTypeFixed16__Bits(reflect_funcTypeFixed16 *.this)
{
  return reflect___ptr_rtype__Bits(&.this->funcType.rtype);
}

//----- (080B1770) --------------------------------------------------------
__int32 __golang reflect___ptr_funcTypeFixed16__Align(reflect_funcTypeFixed16 *.this)
{
  return reflect___ptr_rtype__Align(&.this->funcType.rtype);
}

//----- (080B17A0) --------------------------------------------------------
__int32 __golang reflect___ptr_funcTypeFixed16__FieldAlign(reflect_funcTypeFixed16 *.this)
{
  return reflect___ptr_rtype__FieldAlign(&.this->funcType.rtype);
}

//----- (080B17D0) --------------------------------------------------------
reflect_Kind __golang reflect___ptr_funcTypeFixed16__Kind(reflect_funcTypeFixed16 *.this)
{
  return reflect___ptr_rtype__Kind(&.this->funcType.rtype);
}

//----- (080B1800) --------------------------------------------------------
reflect_rtype *__golang reflect___ptr_funcTypeFixed16__common(reflect_funcTypeFixed16 *.this)
{
  return reflect___ptr_rtype__common(&.this->funcType.rtype);
}

//----- (080B1830) --------------------------------------------------------
__int32 __golang reflect___ptr_funcTypeFixed16__NumMethod(reflect_funcTypeFixed16 *.this)
{
  return reflect___ptr_rtype__NumMethod(&.this->funcType.rtype);
}

//----- (080B1860) --------------------------------------------------------
void __golang reflect___ptr_funcTypeFixed16__Method(reflect_funcTypeFixed16 *.this, __int32 i, reflect_Method_0 m)
{
  ((void (*)(void))loc_808FD86)();
  reflect___ptr_rtype__Method(&.this->funcType.rtype, i, m);
}

//----- (080B18A0) --------------------------------------------------------
void __golang reflect___ptr_funcTypeFixed16__MethodByName(
        reflect_funcTypeFixed16 *.this,
        string name,
        reflect_Method_0 m,
        bool ok)
{
  ((void (*)(void))loc_808FD86)();
  reflect___ptr_rtype__MethodByName(&.this->funcType.rtype, name, m, 0);
}

//----- (080B18E0) --------------------------------------------------------
string __golang reflect___ptr_funcTypeFixed16__PkgPath(reflect_funcTypeFixed16 *.this)
{
  return reflect___ptr_rtype__PkgPath(&.this->funcType.rtype);
}

//----- (080B1920) --------------------------------------------------------
string __golang reflect___ptr_funcTypeFixed16__Name(reflect_funcTypeFixed16 *.this)
{
  return reflect___ptr_rtype__Name(&.this->funcType.rtype);
}

//----- (080B1960) --------------------------------------------------------
reflect_ChanDir __golang reflect___ptr_funcTypeFixed16__ChanDir(reflect_funcTypeFixed16 *.this)
{
  return reflect___ptr_rtype__ChanDir(&.this->funcType.rtype);
}

//----- (080B1990) --------------------------------------------------------
bool __golang reflect___ptr_funcTypeFixed16__IsVariadic(reflect_funcTypeFixed16 *.this)
{
  return reflect___ptr_rtype__IsVariadic(&.this->funcType.rtype);
}

//----- (080B19C0) --------------------------------------------------------
reflect_Type_0 __golang reflect___ptr_funcTypeFixed16__Elem(reflect_funcTypeFixed16 *.this)
{
  return reflect___ptr_rtype__Elem(&.this->funcType.rtype);
}

//----- (080B1A00) --------------------------------------------------------
reflect_StructField_0 __golang reflect___ptr_funcTypeFixed16__Field(reflect_funcTypeFixed16 *.this, __int32 i)
{
  ((void (*)(void))loc_808FD83)();
  return reflect___ptr_rtype__Field(&.this->funcType.rtype, i);
}

//----- (080B1A40) --------------------------------------------------------
reflect_StructField_0 __golang reflect___ptr_funcTypeFixed16__FieldByIndex(reflect_funcTypeFixed16 *.this, __int index)
{
  ((void (*)(void))loc_808FD83)();
  return reflect___ptr_rtype__FieldByIndex(&.this->funcType.rtype, index);
}

//----- (080B1A80) --------------------------------------------------------
retval_80B1A80 __golang reflect___ptr_funcTypeFixed16__FieldByName(reflect_funcTypeFixed16 *.this, string name)
{
  ((void (*)(void))loc_808FD83)();
  return (retval_80B1A80)reflect___ptr_rtype__FieldByName(&.this->funcType.rtype, name);
}

//----- (080B1AC0) --------------------------------------------------------
retval_80B1AC0 __golang reflect___ptr_funcTypeFixed16__FieldByNameFunc(
        reflect_funcTypeFixed16 *.this,
        func(string)_bool match)
{
  ((void (*)(void))loc_808FD83)();
  return (retval_80B1AC0)reflect___ptr_rtype__FieldByNameFunc(&.this->funcType.rtype, match);
}

//----- (080B1B00) --------------------------------------------------------
reflect_Type_0 __golang reflect___ptr_funcTypeFixed16__In(reflect_funcTypeFixed16 *.this, __int32 i)
{
  return reflect___ptr_rtype__In(&.this->funcType.rtype, i);
}

//----- (080B1B40) --------------------------------------------------------
reflect_Type_0 __golang reflect___ptr_funcTypeFixed16__Key(reflect_funcTypeFixed16 *.this)
{
  return reflect___ptr_rtype__Key(&.this->funcType.rtype);
}

//----- (080B1B80) --------------------------------------------------------
__int32 __golang reflect___ptr_funcTypeFixed16__Len(reflect_funcTypeFixed16 *.this)
{
  return reflect___ptr_rtype__Len(&.this->funcType.rtype);
}

//----- (080B1BB0) --------------------------------------------------------
__int32 __golang reflect___ptr_funcTypeFixed16__NumField(reflect_funcTypeFixed16 *.this)
{
  return reflect___ptr_rtype__NumField(&.this->funcType.rtype);
}

//----- (080B1BE0) --------------------------------------------------------
__int32 __golang reflect___ptr_funcTypeFixed16__NumIn(reflect_funcTypeFixed16 *.this)
{
  return reflect___ptr_rtype__NumIn(&.this->funcType.rtype);
}

//----- (080B1C10) --------------------------------------------------------
__int32 __golang reflect___ptr_funcTypeFixed16__NumOut(reflect_funcTypeFixed16 *.this)
{
  return reflect___ptr_rtype__NumOut(&.this->funcType.rtype);
}

//----- (080B1C40) --------------------------------------------------------
reflect_Type_0 __golang reflect___ptr_funcTypeFixed16__Out(reflect_funcTypeFixed16 *.this, __int32 i)
{
  return reflect___ptr_rtype__Out(&.this->funcType.rtype, i);
}

//----- (080B1C80) --------------------------------------------------------
bool __golang reflect___ptr_funcTypeFixed16__Implements(reflect_funcTypeFixed16 *.this, reflect_Type_0 u)
{
  return reflect___ptr_rtype__Implements(&.this->funcType.rtype, u);
}

//----- (080B1CB0) --------------------------------------------------------
bool __golang reflect___ptr_funcTypeFixed16__AssignableTo(reflect_funcTypeFixed16 *.this, reflect_Type_0 u)
{
  return reflect___ptr_rtype__AssignableTo(&.this->funcType.rtype, u);
}

//----- (080B1CE0) --------------------------------------------------------
bool __golang reflect___ptr_funcTypeFixed16__ConvertibleTo(reflect_funcTypeFixed16 *.this, reflect_Type_0 u)
{
  return reflect___ptr_rtype__ConvertibleTo(&.this->funcType.rtype, u);
}

//----- (080B1D10) --------------------------------------------------------
bool __golang reflect___ptr_funcTypeFixed16__Comparable(reflect_funcTypeFixed16 *.this)
{
  return reflect___ptr_rtype__Comparable(&.this->funcType.rtype);
}

//----- (080B1D40) --------------------------------------------------------
reflect_uncommonType *__golang reflect___ptr_funcTypeFixed32__uncommon(reflect_funcTypeFixed32 *.this)
{
  return reflect___ptr_rtype__uncommon(&.this->funcType.rtype);
}

//----- (080B1D70) --------------------------------------------------------
string __golang reflect___ptr_funcTypeFixed32__String(reflect_funcTypeFixed32 *.this)
{
  return reflect___ptr_rtype__String(&.this->funcType.rtype);
}

//----- (080B1DB0) --------------------------------------------------------
uintptr __golang reflect___ptr_funcTypeFixed32__Size(reflect_funcTypeFixed32 *.this)
{
  return reflect___ptr_rtype__Size(&.this->funcType.rtype);
}

//----- (080B1DE0) --------------------------------------------------------
__int32 __golang reflect___ptr_funcTypeFixed32__Bits(reflect_funcTypeFixed32 *.this)
{
  return reflect___ptr_rtype__Bits(&.this->funcType.rtype);
}

//----- (080B1E10) --------------------------------------------------------
__int32 __golang reflect___ptr_funcTypeFixed32__Align(reflect_funcTypeFixed32 *.this)
{
  return reflect___ptr_rtype__Align(&.this->funcType.rtype);
}

//----- (080B1E40) --------------------------------------------------------
__int32 __golang reflect___ptr_funcTypeFixed32__FieldAlign(reflect_funcTypeFixed32 *.this)
{
  return reflect___ptr_rtype__FieldAlign(&.this->funcType.rtype);
}

//----- (080B1E70) --------------------------------------------------------
reflect_Kind __golang reflect___ptr_funcTypeFixed32__Kind(reflect_funcTypeFixed32 *.this)
{
  return reflect___ptr_rtype__Kind(&.this->funcType.rtype);
}

//----- (080B1EA0) --------------------------------------------------------
reflect_rtype *__golang reflect___ptr_funcTypeFixed32__common(reflect_funcTypeFixed32 *.this)
{
  return reflect___ptr_rtype__common(&.this->funcType.rtype);
}

//----- (080B1ED0) --------------------------------------------------------
__int32 __golang reflect___ptr_funcTypeFixed32__NumMethod(reflect_funcTypeFixed32 *.this)
{
  return reflect___ptr_rtype__NumMethod(&.this->funcType.rtype);
}

//----- (080B1F00) --------------------------------------------------------
void __golang reflect___ptr_funcTypeFixed32__Method(reflect_funcTypeFixed32 *.this, __int32 i, reflect_Method_0 m)
{
  ((void (*)(void))loc_808FD86)();
  reflect___ptr_rtype__Method(&.this->funcType.rtype, i, m);
}

//----- (080B1F40) --------------------------------------------------------
void __golang reflect___ptr_funcTypeFixed32__MethodByName(
        reflect_funcTypeFixed32 *.this,
        string name,
        reflect_Method_0 m,
        bool ok)
{
  ((void (*)(void))loc_808FD86)();
  reflect___ptr_rtype__MethodByName(&.this->funcType.rtype, name, m, 0);
}

//----- (080B1F80) --------------------------------------------------------
string __golang reflect___ptr_funcTypeFixed32__PkgPath(reflect_funcTypeFixed32 *.this)
{
  return reflect___ptr_rtype__PkgPath(&.this->funcType.rtype);
}

//----- (080B1FC0) --------------------------------------------------------
string __golang reflect___ptr_funcTypeFixed32__Name(reflect_funcTypeFixed32 *.this)
{
  return reflect___ptr_rtype__Name(&.this->funcType.rtype);
}

//----- (080B2000) --------------------------------------------------------
reflect_ChanDir __golang reflect___ptr_funcTypeFixed32__ChanDir(reflect_funcTypeFixed32 *.this)
{
  return reflect___ptr_rtype__ChanDir(&.this->funcType.rtype);
}

//----- (080B2030) --------------------------------------------------------
bool __golang reflect___ptr_funcTypeFixed32__IsVariadic(reflect_funcTypeFixed32 *.this)
{
  return reflect___ptr_rtype__IsVariadic(&.this->funcType.rtype);
}

//----- (080B2060) --------------------------------------------------------
reflect_Type_0 __golang reflect___ptr_funcTypeFixed32__Elem(reflect_funcTypeFixed32 *.this)
{
  return reflect___ptr_rtype__Elem(&.this->funcType.rtype);
}

//----- (080B20A0) --------------------------------------------------------
reflect_StructField_0 __golang reflect___ptr_funcTypeFixed32__Field(reflect_funcTypeFixed32 *.this, __int32 i)
{
  ((void (*)(void))loc_808FD83)();
  return reflect___ptr_rtype__Field(&.this->funcType.rtype, i);
}

//----- (080B20E0) --------------------------------------------------------
reflect_StructField_0 __golang reflect___ptr_funcTypeFixed32__FieldByIndex(reflect_funcTypeFixed32 *.this, __int index)
{
  ((void (*)(void))loc_808FD83)();
  return reflect___ptr_rtype__FieldByIndex(&.this->funcType.rtype, index);
}

//----- (080B2120) --------------------------------------------------------
retval_80B2120 __golang reflect___ptr_funcTypeFixed32__FieldByName(reflect_funcTypeFixed32 *.this, string name)
{
  ((void (*)(void))loc_808FD83)();
  return (retval_80B2120)reflect___ptr_rtype__FieldByName(&.this->funcType.rtype, name);
}

//----- (080B2160) --------------------------------------------------------
retval_80B2160 __golang reflect___ptr_funcTypeFixed32__FieldByNameFunc(
        reflect_funcTypeFixed32 *.this,
        func(string)_bool match)
{
  ((void (*)(void))loc_808FD83)();
  return (retval_80B2160)reflect___ptr_rtype__FieldByNameFunc(&.this->funcType.rtype, match);
}

//----- (080B21A0) --------------------------------------------------------
reflect_Type_0 __golang reflect___ptr_funcTypeFixed32__In(reflect_funcTypeFixed32 *.this, __int32 i)
{
  return reflect___ptr_rtype__In(&.this->funcType.rtype, i);
}

//----- (080B21E0) --------------------------------------------------------
reflect_Type_0 __golang reflect___ptr_funcTypeFixed32__Key(reflect_funcTypeFixed32 *.this)
{
  return reflect___ptr_rtype__Key(&.this->funcType.rtype);
}

//----- (080B2220) --------------------------------------------------------
__int32 __golang reflect___ptr_funcTypeFixed32__Len(reflect_funcTypeFixed32 *.this)
{
  return reflect___ptr_rtype__Len(&.this->funcType.rtype);
}

//----- (080B2250) --------------------------------------------------------
__int32 __golang reflect___ptr_funcTypeFixed32__NumField(reflect_funcTypeFixed32 *.this)
{
  return reflect___ptr_rtype__NumField(&.this->funcType.rtype);
}

//----- (080B2280) --------------------------------------------------------
__int32 __golang reflect___ptr_funcTypeFixed32__NumIn(reflect_funcTypeFixed32 *.this)
{
  return reflect___ptr_rtype__NumIn(&.this->funcType.rtype);
}

//----- (080B22B0) --------------------------------------------------------
__int32 __golang reflect___ptr_funcTypeFixed32__NumOut(reflect_funcTypeFixed32 *.this)
{
  return reflect___ptr_rtype__NumOut(&.this->funcType.rtype);
}

//----- (080B22E0) --------------------------------------------------------
reflect_Type_0 __golang reflect___ptr_funcTypeFixed32__Out(reflect_funcTypeFixed32 *.this, __int32 i)
{
  return reflect___ptr_rtype__Out(&.this->funcType.rtype, i);
}

//----- (080B2320) --------------------------------------------------------
bool __golang reflect___ptr_funcTypeFixed32__Implements(reflect_funcTypeFixed32 *.this, reflect_Type_0 u)
{
  return reflect___ptr_rtype__Implements(&.this->funcType.rtype, u);
}

//----- (080B2350) --------------------------------------------------------
bool __golang reflect___ptr_funcTypeFixed32__AssignableTo(reflect_funcTypeFixed32 *.this, reflect_Type_0 u)
{
  return reflect___ptr_rtype__AssignableTo(&.this->funcType.rtype, u);
}

//----- (080B2380) --------------------------------------------------------
bool __golang reflect___ptr_funcTypeFixed32__ConvertibleTo(reflect_funcTypeFixed32 *.this, reflect_Type_0 u)
{
  return reflect___ptr_rtype__ConvertibleTo(&.this->funcType.rtype, u);
}

//----- (080B23B0) --------------------------------------------------------
bool __golang reflect___ptr_funcTypeFixed32__Comparable(reflect_funcTypeFixed32 *.this)
{
  return reflect___ptr_rtype__Comparable(&.this->funcType.rtype);
}

//----- (080B23E0) --------------------------------------------------------
reflect_uncommonType *__golang reflect___ptr_funcTypeFixed4__uncommon(reflect_funcTypeFixed4 *.this)
{
  return reflect___ptr_rtype__uncommon(&.this->funcType.rtype);
}

//----- (080B2410) --------------------------------------------------------
string __golang reflect___ptr_funcTypeFixed4__String(reflect_funcTypeFixed4 *.this)
{
  return reflect___ptr_rtype__String(&.this->funcType.rtype);
}

//----- (080B2450) --------------------------------------------------------
uintptr __golang reflect___ptr_funcTypeFixed4__Size(reflect_funcTypeFixed4 *.this)
{
  return reflect___ptr_rtype__Size(&.this->funcType.rtype);
}

//----- (080B2480) --------------------------------------------------------
__int32 __golang reflect___ptr_funcTypeFixed4__Bits(reflect_funcTypeFixed4 *.this)
{
  return reflect___ptr_rtype__Bits(&.this->funcType.rtype);
}

//----- (080B24B0) --------------------------------------------------------
__int32 __golang reflect___ptr_funcTypeFixed4__Align(reflect_funcTypeFixed4 *.this)
{
  return reflect___ptr_rtype__Align(&.this->funcType.rtype);
}

//----- (080B24E0) --------------------------------------------------------
__int32 __golang reflect___ptr_funcTypeFixed4__FieldAlign(reflect_funcTypeFixed4 *.this)
{
  return reflect___ptr_rtype__FieldAlign(&.this->funcType.rtype);
}

//----- (080B2510) --------------------------------------------------------
reflect_Kind __golang reflect___ptr_funcTypeFixed4__Kind(reflect_funcTypeFixed4 *.this)
{
  return reflect___ptr_rtype__Kind(&.this->funcType.rtype);
}

//----- (080B2540) --------------------------------------------------------
reflect_rtype *__golang reflect___ptr_funcTypeFixed4__common(reflect_funcTypeFixed4 *.this)
{
  return reflect___ptr_rtype__common(&.this->funcType.rtype);
}

//----- (080B2570) --------------------------------------------------------
__int32 __golang reflect___ptr_funcTypeFixed4__NumMethod(reflect_funcTypeFixed4 *.this)
{
  return reflect___ptr_rtype__NumMethod(&.this->funcType.rtype);
}

//----- (080B25A0) --------------------------------------------------------
void __golang reflect___ptr_funcTypeFixed4__Method(reflect_funcTypeFixed4 *.this, __int32 i, reflect_Method_0 m)
{
  ((void (*)(void))loc_808FD86)();
  reflect___ptr_rtype__Method(&.this->funcType.rtype, i, m);
}

//----- (080B25E0) --------------------------------------------------------
void __golang reflect___ptr_funcTypeFixed4__MethodByName(
        reflect_funcTypeFixed4 *.this,
        string name,
        reflect_Method_0 m,
        bool ok)
{
  ((void (*)(void))loc_808FD86)();
  reflect___ptr_rtype__MethodByName(&.this->funcType.rtype, name, m, 0);
}

//----- (080B2620) --------------------------------------------------------
string __golang reflect___ptr_funcTypeFixed4__PkgPath(reflect_funcTypeFixed4 *.this)
{
  return reflect___ptr_rtype__PkgPath(&.this->funcType.rtype);
}

//----- (080B2660) --------------------------------------------------------
string __golang reflect___ptr_funcTypeFixed4__Name(reflect_funcTypeFixed4 *.this)
{
  return reflect___ptr_rtype__Name(&.this->funcType.rtype);
}

//----- (080B26A0) --------------------------------------------------------
reflect_ChanDir __golang reflect___ptr_funcTypeFixed4__ChanDir(reflect_funcTypeFixed4 *.this)
{
  return reflect___ptr_rtype__ChanDir(&.this->funcType.rtype);
}

//----- (080B26D0) --------------------------------------------------------
bool __golang reflect___ptr_funcTypeFixed4__IsVariadic(reflect_funcTypeFixed4 *.this)
{
  return reflect___ptr_rtype__IsVariadic(&.this->funcType.rtype);
}

//----- (080B2700) --------------------------------------------------------
reflect_Type_0 __golang reflect___ptr_funcTypeFixed4__Elem(reflect_funcTypeFixed4 *.this)
{
  return reflect___ptr_rtype__Elem(&.this->funcType.rtype);
}

//----- (080B2740) --------------------------------------------------------
reflect_StructField_0 __golang reflect___ptr_funcTypeFixed4__Field(reflect_funcTypeFixed4 *.this, __int32 i)
{
  ((void (*)(void))loc_808FD83)();
  return reflect___ptr_rtype__Field(&.this->funcType.rtype, i);
}

//----- (080B2780) --------------------------------------------------------
reflect_StructField_0 __golang reflect___ptr_funcTypeFixed4__FieldByIndex(reflect_funcTypeFixed4 *.this, __int index)
{
  ((void (*)(void))loc_808FD83)();
  return reflect___ptr_rtype__FieldByIndex(&.this->funcType.rtype, index);
}

//----- (080B27C0) --------------------------------------------------------
retval_80B27C0 __golang reflect___ptr_funcTypeFixed4__FieldByName(reflect_funcTypeFixed4 *.this, string name)
{
  ((void (*)(void))loc_808FD83)();
  return (retval_80B27C0)reflect___ptr_rtype__FieldByName(&.this->funcType.rtype, name);
}

//----- (080B2800) --------------------------------------------------------
retval_80B2800 __golang reflect___ptr_funcTypeFixed4__FieldByNameFunc(
        reflect_funcTypeFixed4 *.this,
        func(string)_bool match)
{
  ((void (*)(void))loc_808FD83)();
  return (retval_80B2800)reflect___ptr_rtype__FieldByNameFunc(&.this->funcType.rtype, match);
}

//----- (080B2840) --------------------------------------------------------
reflect_Type_0 __golang reflect___ptr_funcTypeFixed4__In(reflect_funcTypeFixed4 *.this, __int32 i)
{
  return reflect___ptr_rtype__In(&.this->funcType.rtype, i);
}

//----- (080B2880) --------------------------------------------------------
reflect_Type_0 __golang reflect___ptr_funcTypeFixed4__Key(reflect_funcTypeFixed4 *.this)
{
  return reflect___ptr_rtype__Key(&.this->funcType.rtype);
}

//----- (080B28C0) --------------------------------------------------------
__int32 __golang reflect___ptr_funcTypeFixed4__Len(reflect_funcTypeFixed4 *.this)
{
  return reflect___ptr_rtype__Len(&.this->funcType.rtype);
}

//----- (080B28F0) --------------------------------------------------------
__int32 __golang reflect___ptr_funcTypeFixed4__NumField(reflect_funcTypeFixed4 *.this)
{
  return reflect___ptr_rtype__NumField(&.this->funcType.rtype);
}

//----- (080B2920) --------------------------------------------------------
__int32 __golang reflect___ptr_funcTypeFixed4__NumIn(reflect_funcTypeFixed4 *.this)
{
  return reflect___ptr_rtype__NumIn(&.this->funcType.rtype);
}

//----- (080B2950) --------------------------------------------------------
__int32 __golang reflect___ptr_funcTypeFixed4__NumOut(reflect_funcTypeFixed4 *.this)
{
  return reflect___ptr_rtype__NumOut(&.this->funcType.rtype);
}

//----- (080B2980) --------------------------------------------------------
reflect_Type_0 __golang reflect___ptr_funcTypeFixed4__Out(reflect_funcTypeFixed4 *.this, __int32 i)
{
  return reflect___ptr_rtype__Out(&.this->funcType.rtype, i);
}

//----- (080B29C0) --------------------------------------------------------
bool __golang reflect___ptr_funcTypeFixed4__Implements(reflect_funcTypeFixed4 *.this, reflect_Type_0 u)
{
  return reflect___ptr_rtype__Implements(&.this->funcType.rtype, u);
}

//----- (080B29F0) --------------------------------------------------------
bool __golang reflect___ptr_funcTypeFixed4__AssignableTo(reflect_funcTypeFixed4 *.this, reflect_Type_0 u)
{
  return reflect___ptr_rtype__AssignableTo(&.this->funcType.rtype, u);
}

//----- (080B2A20) --------------------------------------------------------
bool __golang reflect___ptr_funcTypeFixed4__ConvertibleTo(reflect_funcTypeFixed4 *.this, reflect_Type_0 u)
{
  return reflect___ptr_rtype__ConvertibleTo(&.this->funcType.rtype, u);
}

//----- (080B2A50) --------------------------------------------------------
bool __golang reflect___ptr_funcTypeFixed4__Comparable(reflect_funcTypeFixed4 *.this)
{
  return reflect___ptr_rtype__Comparable(&.this->funcType.rtype);
}

//----- (080B2A80) --------------------------------------------------------
reflect_uncommonType *__golang reflect___ptr_funcTypeFixed64__uncommon(reflect_funcTypeFixed64 *.this)
{
  return reflect___ptr_rtype__uncommon(&.this->funcType.rtype);
}

//----- (080B2AB0) --------------------------------------------------------
string __golang reflect___ptr_funcTypeFixed64__String(reflect_funcTypeFixed64 *.this)
{
  return reflect___ptr_rtype__String(&.this->funcType.rtype);
}

//----- (080B2AF0) --------------------------------------------------------
uintptr __golang reflect___ptr_funcTypeFixed64__Size(reflect_funcTypeFixed64 *.this)
{
  return reflect___ptr_rtype__Size(&.this->funcType.rtype);
}

//----- (080B2B20) --------------------------------------------------------
__int32 __golang reflect___ptr_funcTypeFixed64__Bits(reflect_funcTypeFixed64 *.this)
{
  return reflect___ptr_rtype__Bits(&.this->funcType.rtype);
}

//----- (080B2B50) --------------------------------------------------------
__int32 __golang reflect___ptr_funcTypeFixed64__Align(reflect_funcTypeFixed64 *.this)
{
  return reflect___ptr_rtype__Align(&.this->funcType.rtype);
}

//----- (080B2B80) --------------------------------------------------------
__int32 __golang reflect___ptr_funcTypeFixed64__FieldAlign(reflect_funcTypeFixed64 *.this)
{
  return reflect___ptr_rtype__FieldAlign(&.this->funcType.rtype);
}

//----- (080B2BB0) --------------------------------------------------------
reflect_Kind __golang reflect___ptr_funcTypeFixed64__Kind(reflect_funcTypeFixed64 *.this)
{
  return reflect___ptr_rtype__Kind(&.this->funcType.rtype);
}

//----- (080B2BE0) --------------------------------------------------------
reflect_rtype *__golang reflect___ptr_funcTypeFixed64__common(reflect_funcTypeFixed64 *.this)
{
  return reflect___ptr_rtype__common(&.this->funcType.rtype);
}

//----- (080B2C10) --------------------------------------------------------
__int32 __golang reflect___ptr_funcTypeFixed64__NumMethod(reflect_funcTypeFixed64 *.this)
{
  return reflect___ptr_rtype__NumMethod(&.this->funcType.rtype);
}

//----- (080B2C40) --------------------------------------------------------
void __golang reflect___ptr_funcTypeFixed64__Method(reflect_funcTypeFixed64 *.this, __int32 i, reflect_Method_0 m)
{
  ((void (*)(void))loc_808FD86)();
  reflect___ptr_rtype__Method(&.this->funcType.rtype, i, m);
}

//----- (080B2C80) --------------------------------------------------------
void __golang reflect___ptr_funcTypeFixed64__MethodByName(
        reflect_funcTypeFixed64 *.this,
        string name,
        reflect_Method_0 m,
        bool ok)
{
  ((void (*)(void))loc_808FD86)();
  reflect___ptr_rtype__MethodByName(&.this->funcType.rtype, name, m, 0);
}

//----- (080B2CC0) --------------------------------------------------------
string __golang reflect___ptr_funcTypeFixed64__PkgPath(reflect_funcTypeFixed64 *.this)
{
  return reflect___ptr_rtype__PkgPath(&.this->funcType.rtype);
}

//----- (080B2D00) --------------------------------------------------------
string __golang reflect___ptr_funcTypeFixed64__Name(reflect_funcTypeFixed64 *.this)
{
  return reflect___ptr_rtype__Name(&.this->funcType.rtype);
}

//----- (080B2D40) --------------------------------------------------------
reflect_ChanDir __golang reflect___ptr_funcTypeFixed64__ChanDir(reflect_funcTypeFixed64 *.this)
{
  return reflect___ptr_rtype__ChanDir(&.this->funcType.rtype);
}

//----- (080B2D70) --------------------------------------------------------
bool __golang reflect___ptr_funcTypeFixed64__IsVariadic(reflect_funcTypeFixed64 *.this)
{
  return reflect___ptr_rtype__IsVariadic(&.this->funcType.rtype);
}

//----- (080B2DA0) --------------------------------------------------------
reflect_Type_0 __golang reflect___ptr_funcTypeFixed64__Elem(reflect_funcTypeFixed64 *.this)
{
  return reflect___ptr_rtype__Elem(&.this->funcType.rtype);
}

//----- (080B2DE0) --------------------------------------------------------
reflect_StructField_0 __golang reflect___ptr_funcTypeFixed64__Field(reflect_funcTypeFixed64 *.this, __int32 i)
{
  ((void (*)(void))loc_808FD83)();
  return reflect___ptr_rtype__Field(&.this->funcType.rtype, i);
}

//----- (080B2E20) --------------------------------------------------------
reflect_StructField_0 __golang reflect___ptr_funcTypeFixed64__FieldByIndex(reflect_funcTypeFixed64 *.this, __int index)
{
  ((void (*)(void))loc_808FD83)();
  return reflect___ptr_rtype__FieldByIndex(&.this->funcType.rtype, index);
}

//----- (080B2E60) --------------------------------------------------------
retval_80B2E60 __golang reflect___ptr_funcTypeFixed64__FieldByName(reflect_funcTypeFixed64 *.this, string name)
{
  ((void (*)(void))loc_808FD83)();
  return (retval_80B2E60)reflect___ptr_rtype__FieldByName(&.this->funcType.rtype, name);
}

//----- (080B2EA0) --------------------------------------------------------
retval_80B2EA0 __golang reflect___ptr_funcTypeFixed64__FieldByNameFunc(
        reflect_funcTypeFixed64 *.this,
        func(string)_bool match)
{
  ((void (*)(void))loc_808FD83)();
  return (retval_80B2EA0)reflect___ptr_rtype__FieldByNameFunc(&.this->funcType.rtype, match);
}

//----- (080B2EE0) --------------------------------------------------------
reflect_Type_0 __golang reflect___ptr_funcTypeFixed64__In(reflect_funcTypeFixed64 *.this, __int32 i)
{
  return reflect___ptr_rtype__In(&.this->funcType.rtype, i);
}

//----- (080B2F20) --------------------------------------------------------
reflect_Type_0 __golang reflect___ptr_funcTypeFixed64__Key(reflect_funcTypeFixed64 *.this)
{
  return reflect___ptr_rtype__Key(&.this->funcType.rtype);
}

//----- (080B2F60) --------------------------------------------------------
__int32 __golang reflect___ptr_funcTypeFixed64__Len(reflect_funcTypeFixed64 *.this)
{
  return reflect___ptr_rtype__Len(&.this->funcType.rtype);
}

//----- (080B2F90) --------------------------------------------------------
__int32 __golang reflect___ptr_funcTypeFixed64__NumField(reflect_funcTypeFixed64 *.this)
{
  return reflect___ptr_rtype__NumField(&.this->funcType.rtype);
}

//----- (080B2FC0) --------------------------------------------------------
__int32 __golang reflect___ptr_funcTypeFixed64__NumIn(reflect_funcTypeFixed64 *.this)
{
  return reflect___ptr_rtype__NumIn(&.this->funcType.rtype);
}

//----- (080B2FF0) --------------------------------------------------------
__int32 __golang reflect___ptr_funcTypeFixed64__NumOut(reflect_funcTypeFixed64 *.this)
{
  return reflect___ptr_rtype__NumOut(&.this->funcType.rtype);
}

//----- (080B3020) --------------------------------------------------------
reflect_Type_0 __golang reflect___ptr_funcTypeFixed64__Out(reflect_funcTypeFixed64 *.this, __int32 i)
{
  return reflect___ptr_rtype__Out(&.this->funcType.rtype, i);
}

//----- (080B3060) --------------------------------------------------------
bool __golang reflect___ptr_funcTypeFixed64__Implements(reflect_funcTypeFixed64 *.this, reflect_Type_0 u)
{
  return reflect___ptr_rtype__Implements(&.this->funcType.rtype, u);
}

//----- (080B3090) --------------------------------------------------------
bool __golang reflect___ptr_funcTypeFixed64__AssignableTo(reflect_funcTypeFixed64 *.this, reflect_Type_0 u)
{
  return reflect___ptr_rtype__AssignableTo(&.this->funcType.rtype, u);
}

//----- (080B30C0) --------------------------------------------------------
bool __golang reflect___ptr_funcTypeFixed64__ConvertibleTo(reflect_funcTypeFixed64 *.this, reflect_Type_0 u)
{
  return reflect___ptr_rtype__ConvertibleTo(&.this->funcType.rtype, u);
}

//----- (080B30F0) --------------------------------------------------------
bool __golang reflect___ptr_funcTypeFixed64__Comparable(reflect_funcTypeFixed64 *.this)
{
  return reflect___ptr_rtype__Comparable(&.this->funcType.rtype);
}

//----- (080B3120) --------------------------------------------------------
reflect_uncommonType *__golang reflect___ptr_funcTypeFixed8__uncommon(reflect_funcTypeFixed8 *.this)
{
  return reflect___ptr_rtype__uncommon(&.this->funcType.rtype);
}

//----- (080B3150) --------------------------------------------------------
string __golang reflect___ptr_funcTypeFixed8__String(reflect_funcTypeFixed8 *.this)
{
  return reflect___ptr_rtype__String(&.this->funcType.rtype);
}

//----- (080B3190) --------------------------------------------------------
uintptr __golang reflect___ptr_funcTypeFixed8__Size(reflect_funcTypeFixed8 *.this)
{
  return reflect___ptr_rtype__Size(&.this->funcType.rtype);
}

//----- (080B31C0) --------------------------------------------------------
__int32 __golang reflect___ptr_funcTypeFixed8__Bits(reflect_funcTypeFixed8 *.this)
{
  return reflect___ptr_rtype__Bits(&.this->funcType.rtype);
}

//----- (080B31F0) --------------------------------------------------------
__int32 __golang reflect___ptr_funcTypeFixed8__Align(reflect_funcTypeFixed8 *.this)
{
  return reflect___ptr_rtype__Align(&.this->funcType.rtype);
}

//----- (080B3220) --------------------------------------------------------
__int32 __golang reflect___ptr_funcTypeFixed8__FieldAlign(reflect_funcTypeFixed8 *.this)
{
  return reflect___ptr_rtype__FieldAlign(&.this->funcType.rtype);
}

//----- (080B3250) --------------------------------------------------------
reflect_Kind __golang reflect___ptr_funcTypeFixed8__Kind(reflect_funcTypeFixed8 *.this)
{
  return reflect___ptr_rtype__Kind(&.this->funcType.rtype);
}

//----- (080B3280) --------------------------------------------------------
reflect_rtype *__golang reflect___ptr_funcTypeFixed8__common(reflect_funcTypeFixed8 *.this)
{
  return reflect___ptr_rtype__common(&.this->funcType.rtype);
}

//----- (080B32B0) --------------------------------------------------------
__int32 __golang reflect___ptr_funcTypeFixed8__NumMethod(reflect_funcTypeFixed8 *.this)
{
  return reflect___ptr_rtype__NumMethod(&.this->funcType.rtype);
}

//----- (080B32E0) --------------------------------------------------------
void __golang reflect___ptr_funcTypeFixed8__Method(reflect_funcTypeFixed8 *.this, __int32 i, reflect_Method_0 m)
{
  ((void (*)(void))loc_808FD86)();
  reflect___ptr_rtype__Method(&.this->funcType.rtype, i, m);
}

//----- (080B3320) --------------------------------------------------------
void __golang reflect___ptr_funcTypeFixed8__MethodByName(
        reflect_funcTypeFixed8 *.this,
        string name,
        reflect_Method_0 m,
        bool ok)
{
  ((void (*)(void))loc_808FD86)();
  reflect___ptr_rtype__MethodByName(&.this->funcType.rtype, name, m, 0);
}

//----- (080B3360) --------------------------------------------------------
string __golang reflect___ptr_funcTypeFixed8__PkgPath(reflect_funcTypeFixed8 *.this)
{
  return reflect___ptr_rtype__PkgPath(&.this->funcType.rtype);
}

//----- (080B33A0) --------------------------------------------------------
string __golang reflect___ptr_funcTypeFixed8__Name(reflect_funcTypeFixed8 *.this)
{
  return reflect___ptr_rtype__Name(&.this->funcType.rtype);
}

//----- (080B33E0) --------------------------------------------------------
reflect_ChanDir __golang reflect___ptr_funcTypeFixed8__ChanDir(reflect_funcTypeFixed8 *.this)
{
  return reflect___ptr_rtype__ChanDir(&.this->funcType.rtype);
}

//----- (080B3410) --------------------------------------------------------
bool __golang reflect___ptr_funcTypeFixed8__IsVariadic(reflect_funcTypeFixed8 *.this)
{
  return reflect___ptr_rtype__IsVariadic(&.this->funcType.rtype);
}

//----- (080B3440) --------------------------------------------------------
reflect_Type_0 __golang reflect___ptr_funcTypeFixed8__Elem(reflect_funcTypeFixed8 *.this)
{
  return reflect___ptr_rtype__Elem(&.this->funcType.rtype);
}

//----- (080B3480) --------------------------------------------------------
reflect_StructField_0 __golang reflect___ptr_funcTypeFixed8__Field(reflect_funcTypeFixed8 *.this, __int32 i)
{
  ((void (*)(void))loc_808FD83)();
  return reflect___ptr_rtype__Field(&.this->funcType.rtype, i);
}

//----- (080B34C0) --------------------------------------------------------
reflect_StructField_0 __golang reflect___ptr_funcTypeFixed8__FieldByIndex(reflect_funcTypeFixed8 *.this, __int index)
{
  ((void (*)(void))loc_808FD83)();
  return reflect___ptr_rtype__FieldByIndex(&.this->funcType.rtype, index);
}

//----- (080B3500) --------------------------------------------------------
retval_80B3500 __golang reflect___ptr_funcTypeFixed8__FieldByName(reflect_funcTypeFixed8 *.this, string name)
{
  ((void (*)(void))loc_808FD83)();
  return (retval_80B3500)reflect___ptr_rtype__FieldByName(&.this->funcType.rtype, name);
}

//----- (080B3540) --------------------------------------------------------
retval_80B3540 __golang reflect___ptr_funcTypeFixed8__FieldByNameFunc(
        reflect_funcTypeFixed8 *.this,
        func(string)_bool match)
{
  ((void (*)(void))loc_808FD83)();
  return (retval_80B3540)reflect___ptr_rtype__FieldByNameFunc(&.this->funcType.rtype, match);
}

//----- (080B3580) --------------------------------------------------------
reflect_Type_0 __golang reflect___ptr_funcTypeFixed8__In(reflect_funcTypeFixed8 *.this, __int32 i)
{
  return reflect___ptr_rtype__In(&.this->funcType.rtype, i);
}

//----- (080B35C0) --------------------------------------------------------
reflect_Type_0 __golang reflect___ptr_funcTypeFixed8__Key(reflect_funcTypeFixed8 *.this)
{
  return reflect___ptr_rtype__Key(&.this->funcType.rtype);
}

//----- (080B3600) --------------------------------------------------------
__int32 __golang reflect___ptr_funcTypeFixed8__Len(reflect_funcTypeFixed8 *.this)
{
  return reflect___ptr_rtype__Len(&.this->funcType.rtype);
}

//----- (080B3630) --------------------------------------------------------
__int32 __golang reflect___ptr_funcTypeFixed8__NumField(reflect_funcTypeFixed8 *.this)
{
  return reflect___ptr_rtype__NumField(&.this->funcType.rtype);
}

//----- (080B3660) --------------------------------------------------------
__int32 __golang reflect___ptr_funcTypeFixed8__NumIn(reflect_funcTypeFixed8 *.this)
{
  return reflect___ptr_rtype__NumIn(&.this->funcType.rtype);
}

//----- (080B3690) --------------------------------------------------------
__int32 __golang reflect___ptr_funcTypeFixed8__NumOut(reflect_funcTypeFixed8 *.this)
{
  return reflect___ptr_rtype__NumOut(&.this->funcType.rtype);
}

//----- (080B36C0) --------------------------------------------------------
reflect_Type_0 __golang reflect___ptr_funcTypeFixed8__Out(reflect_funcTypeFixed8 *.this, __int32 i)
{
  return reflect___ptr_rtype__Out(&.this->funcType.rtype, i);
}

//----- (080B3700) --------------------------------------------------------
bool __golang reflect___ptr_funcTypeFixed8__Implements(reflect_funcTypeFixed8 *.this, reflect_Type_0 u)
{
  return reflect___ptr_rtype__Implements(&.this->funcType.rtype, u);
}

//----- (080B3730) --------------------------------------------------------
bool __golang reflect___ptr_funcTypeFixed8__AssignableTo(reflect_funcTypeFixed8 *.this, reflect_Type_0 u)
{
  return reflect___ptr_rtype__AssignableTo(&.this->funcType.rtype, u);
}

//----- (080B3760) --------------------------------------------------------
bool __golang reflect___ptr_funcTypeFixed8__ConvertibleTo(reflect_funcTypeFixed8 *.this, reflect_Type_0 u)
{
  return reflect___ptr_rtype__ConvertibleTo(&.this->funcType.rtype, u);
}

//----- (080B3790) --------------------------------------------------------
bool __golang reflect___ptr_funcTypeFixed8__Comparable(reflect_funcTypeFixed8 *.this)
{
  return reflect___ptr_rtype__Comparable(&.this->funcType.rtype);
}

//----- (080B37C0) --------------------------------------------------------
reflect_uncommonType *__golang reflect___ptr_interfaceType__uncommon(reflect_interfaceType *.this)
{
  return reflect___ptr_rtype__uncommon(&.this->rtype);
}

//----- (080B37F0) --------------------------------------------------------
string __golang reflect___ptr_interfaceType__String(reflect_interfaceType *.this)
{
  return reflect___ptr_rtype__String(&.this->rtype);
}

//----- (080B3830) --------------------------------------------------------
uintptr __golang reflect___ptr_interfaceType__Size(reflect_interfaceType *.this)
{
  return reflect___ptr_rtype__Size(&.this->rtype);
}

//----- (080B3860) --------------------------------------------------------
__int32 __golang reflect___ptr_interfaceType__Bits(reflect_interfaceType *.this)
{
  return reflect___ptr_rtype__Bits(&.this->rtype);
}

//----- (080B3890) --------------------------------------------------------
__int32 __golang reflect___ptr_interfaceType__Align(reflect_interfaceType *.this)
{
  return reflect___ptr_rtype__Align(&.this->rtype);
}

//----- (080B38C0) --------------------------------------------------------
__int32 __golang reflect___ptr_interfaceType__FieldAlign(reflect_interfaceType *.this)
{
  return reflect___ptr_rtype__FieldAlign(&.this->rtype);
}

//----- (080B38F0) --------------------------------------------------------
reflect_Kind __golang reflect___ptr_interfaceType__Kind(reflect_interfaceType *.this)
{
  return reflect___ptr_rtype__Kind(&.this->rtype);
}

//----- (080B3920) --------------------------------------------------------
reflect_rtype *__golang reflect___ptr_interfaceType__common(reflect_interfaceType *.this)
{
  return reflect___ptr_rtype__common(&.this->rtype);
}

//----- (080B3950) --------------------------------------------------------
string __golang reflect___ptr_interfaceType__PkgPath(reflect_interfaceType *.this)
{
  return reflect___ptr_rtype__PkgPath(&.this->rtype);
}

//----- (080B3990) --------------------------------------------------------
string __golang reflect___ptr_interfaceType__Name(reflect_interfaceType *.this)
{
  return reflect___ptr_rtype__Name(&.this->rtype);
}

//----- (080B39D0) --------------------------------------------------------
reflect_ChanDir __golang reflect___ptr_interfaceType__ChanDir(reflect_interfaceType *.this)
{
  return reflect___ptr_rtype__ChanDir(&.this->rtype);
}

//----- (080B3A00) --------------------------------------------------------
bool __golang reflect___ptr_interfaceType__IsVariadic(reflect_interfaceType *.this)
{
  return reflect___ptr_rtype__IsVariadic(&.this->rtype);
}

//----- (080B3A30) --------------------------------------------------------
reflect_Type_0 __golang reflect___ptr_interfaceType__Elem(reflect_interfaceType *.this)
{
  return reflect___ptr_rtype__Elem(&.this->rtype);
}

//----- (080B3A70) --------------------------------------------------------
reflect_StructField_0 __golang reflect___ptr_interfaceType__Field(reflect_interfaceType *.this, __int32 i)
{
  ((void (*)(void))loc_808FD83)();
  return reflect___ptr_rtype__Field(&.this->rtype, i);
}

//----- (080B3AB0) --------------------------------------------------------
reflect_StructField_0 __golang reflect___ptr_interfaceType__FieldByIndex(reflect_interfaceType *.this, __int index)
{
  ((void (*)(void))loc_808FD83)();
  return reflect___ptr_rtype__FieldByIndex(&.this->rtype, index);
}

//----- (080B3AF0) --------------------------------------------------------
retval_80B3AF0 __golang reflect___ptr_interfaceType__FieldByName(reflect_interfaceType *.this, string name)
{
  ((void (*)(void))loc_808FD83)();
  return (retval_80B3AF0)reflect___ptr_rtype__FieldByName(&.this->rtype, name);
}

//----- (080B3B30) --------------------------------------------------------
retval_80B3B30 __golang reflect___ptr_interfaceType__FieldByNameFunc(
        reflect_interfaceType *.this,
        func(string)_bool match)
{
  ((void (*)(void))loc_808FD83)();
  return (retval_80B3B30)reflect___ptr_rtype__FieldByNameFunc(&.this->rtype, match);
}

//----- (080B3B70) --------------------------------------------------------
reflect_Type_0 __golang reflect___ptr_interfaceType__In(reflect_interfaceType *.this, __int32 i)
{
  return reflect___ptr_rtype__In(&.this->rtype, i);
}

//----- (080B3BB0) --------------------------------------------------------
reflect_Type_0 __golang reflect___ptr_interfaceType__Key(reflect_interfaceType *.this)
{
  return reflect___ptr_rtype__Key(&.this->rtype);
}

//----- (080B3BF0) --------------------------------------------------------
__int32 __golang reflect___ptr_interfaceType__Len(reflect_interfaceType *.this)
{
  return reflect___ptr_rtype__Len(&.this->rtype);
}

//----- (080B3C20) --------------------------------------------------------
__int32 __golang reflect___ptr_interfaceType__NumField(reflect_interfaceType *.this)
{
  return reflect___ptr_rtype__NumField(&.this->rtype);
}

//----- (080B3C50) --------------------------------------------------------
__int32 __golang reflect___ptr_interfaceType__NumIn(reflect_interfaceType *.this)
{
  return reflect___ptr_rtype__NumIn(&.this->rtype);
}

//----- (080B3C80) --------------------------------------------------------
__int32 __golang reflect___ptr_interfaceType__NumOut(reflect_interfaceType *.this)
{
  return reflect___ptr_rtype__NumOut(&.this->rtype);
}

//----- (080B3CB0) --------------------------------------------------------
reflect_Type_0 __golang reflect___ptr_interfaceType__Out(reflect_interfaceType *.this, __int32 i)
{
  return reflect___ptr_rtype__Out(&.this->rtype, i);
}

//----- (080B3CF0) --------------------------------------------------------
bool __golang reflect___ptr_interfaceType__Implements(reflect_interfaceType *.this, reflect_Type_0 u)
{
  return reflect___ptr_rtype__Implements(&.this->rtype, u);
}

//----- (080B3D20) --------------------------------------------------------
bool __golang reflect___ptr_interfaceType__AssignableTo(reflect_interfaceType *.this, reflect_Type_0 u)
{
  return reflect___ptr_rtype__AssignableTo(&.this->rtype, u);
}

//----- (080B3D50) --------------------------------------------------------
bool __golang reflect___ptr_interfaceType__ConvertibleTo(reflect_interfaceType *.this, reflect_Type_0 u)
{
  return reflect___ptr_rtype__ConvertibleTo(&.this->rtype, u);
}

//----- (080B3D80) --------------------------------------------------------
bool __golang reflect___ptr_interfaceType__Comparable(reflect_interfaceType *.this)
{
  return reflect___ptr_rtype__Comparable(&.this->rtype);
}

//----- (080B3DB0) --------------------------------------------------------
reflect_uncommonType *__golang reflect___ptr_ptrType__uncommon(reflect_ptrType *.this)
{
  return reflect___ptr_rtype__uncommon(&.this->rtype);
}

//----- (080B3DE0) --------------------------------------------------------
string __golang reflect___ptr_ptrType__String(reflect_ptrType *.this)
{
  return reflect___ptr_rtype__String(&.this->rtype);
}

//----- (080B3E20) --------------------------------------------------------
uintptr __golang reflect___ptr_ptrType__Size(reflect_ptrType *.this)
{
  return reflect___ptr_rtype__Size(&.this->rtype);
}

//----- (080B3E50) --------------------------------------------------------
__int32 __golang reflect___ptr_ptrType__Bits(reflect_ptrType *.this)
{
  return reflect___ptr_rtype__Bits(&.this->rtype);
}

//----- (080B3E80) --------------------------------------------------------
__int32 __golang reflect___ptr_ptrType__Align(reflect_ptrType *.this)
{
  return reflect___ptr_rtype__Align(&.this->rtype);
}

//----- (080B3EB0) --------------------------------------------------------
__int32 __golang reflect___ptr_ptrType__FieldAlign(reflect_ptrType *.this)
{
  return reflect___ptr_rtype__FieldAlign(&.this->rtype);
}

//----- (080B3EE0) --------------------------------------------------------
reflect_Kind __golang reflect___ptr_ptrType__Kind(reflect_ptrType *.this)
{
  return reflect___ptr_rtype__Kind(&.this->rtype);
}

//----- (080B3F10) --------------------------------------------------------
reflect_rtype *__golang reflect___ptr_ptrType__common(reflect_ptrType *.this)
{
  return reflect___ptr_rtype__common(&.this->rtype);
}

//----- (080B3F40) --------------------------------------------------------
__int32 __golang reflect___ptr_ptrType__NumMethod(reflect_ptrType *.this)
{
  return reflect___ptr_rtype__NumMethod(&.this->rtype);
}

//----- (080B3F70) --------------------------------------------------------
void __golang reflect___ptr_ptrType__Method(reflect_ptrType *.this, __int32 i, reflect_Method_0 m)
{
  ((void (*)(void))loc_808FD86)();
  reflect___ptr_rtype__Method(&.this->rtype, i, m);
}

//----- (080B3FB0) --------------------------------------------------------
void __golang reflect___ptr_ptrType__MethodByName(reflect_ptrType *.this, string name, reflect_Method_0 m, bool ok)
{
  ((void (*)(void))loc_808FD86)();
  reflect___ptr_rtype__MethodByName(&.this->rtype, name, m, 0);
}

//----- (080B3FF0) --------------------------------------------------------
string __golang reflect___ptr_ptrType__PkgPath(reflect_ptrType *.this)
{
  return reflect___ptr_rtype__PkgPath(&.this->rtype);
}

//----- (080B4030) --------------------------------------------------------
string __golang reflect___ptr_ptrType__Name(reflect_ptrType *.this)
{
  return reflect___ptr_rtype__Name(&.this->rtype);
}

//----- (080B4070) --------------------------------------------------------
reflect_ChanDir __golang reflect___ptr_ptrType__ChanDir(reflect_ptrType *.this)
{
  return reflect___ptr_rtype__ChanDir(&.this->rtype);
}

//----- (080B40A0) --------------------------------------------------------
bool __golang reflect___ptr_ptrType__IsVariadic(reflect_ptrType *.this)
{
  return reflect___ptr_rtype__IsVariadic(&.this->rtype);
}

//----- (080B40D0) --------------------------------------------------------
reflect_Type_0 __golang reflect___ptr_ptrType__Elem(reflect_ptrType *.this)
{
  return reflect___ptr_rtype__Elem(&.this->rtype);
}

//----- (080B4110) --------------------------------------------------------
reflect_StructField_0 __golang reflect___ptr_ptrType__Field(reflect_ptrType *.this, __int32 i)
{
  ((void (*)(void))loc_808FD83)();
  return reflect___ptr_rtype__Field(&.this->rtype, i);
}

//----- (080B4150) --------------------------------------------------------
reflect_StructField_0 __golang reflect___ptr_ptrType__FieldByIndex(reflect_ptrType *.this, __int index)
{
  ((void (*)(void))loc_808FD83)();
  return reflect___ptr_rtype__FieldByIndex(&.this->rtype, index);
}

//----- (080B4190) --------------------------------------------------------
retval_80B4190 __golang reflect___ptr_ptrType__FieldByName(reflect_ptrType *.this, string name)
{
  ((void (*)(void))loc_808FD83)();
  return (retval_80B4190)reflect___ptr_rtype__FieldByName(&.this->rtype, name);
}

//----- (080B41D0) --------------------------------------------------------
retval_80B41D0 __golang reflect___ptr_ptrType__FieldByNameFunc(reflect_ptrType *.this, func(string)_bool match)
{
  ((void (*)(void))loc_808FD83)();
  return (retval_80B41D0)reflect___ptr_rtype__FieldByNameFunc(&.this->rtype, match);
}

//----- (080B4210) --------------------------------------------------------
reflect_Type_0 __golang reflect___ptr_ptrType__In(reflect_ptrType *.this, __int32 i)
{
  return reflect___ptr_rtype__In(&.this->rtype, i);
}

//----- (080B4250) --------------------------------------------------------
reflect_Type_0 __golang reflect___ptr_ptrType__Key(reflect_ptrType *.this)
{
  return reflect___ptr_rtype__Key(&.this->rtype);
}

//----- (080B4290) --------------------------------------------------------
__int32 __golang reflect___ptr_ptrType__Len(reflect_ptrType *.this)
{
  return reflect___ptr_rtype__Len(&.this->rtype);
}

//----- (080B42C0) --------------------------------------------------------
__int32 __golang reflect___ptr_ptrType__NumField(reflect_ptrType *.this)
{
  return reflect___ptr_rtype__NumField(&.this->rtype);
}

//----- (080B42F0) --------------------------------------------------------
__int32 __golang reflect___ptr_ptrType__NumIn(reflect_ptrType *.this)
{
  return reflect___ptr_rtype__NumIn(&.this->rtype);
}

//----- (080B4320) --------------------------------------------------------
__int32 __golang reflect___ptr_ptrType__NumOut(reflect_ptrType *.this)
{
  return reflect___ptr_rtype__NumOut(&.this->rtype);
}

//----- (080B4350) --------------------------------------------------------
reflect_Type_0 __golang reflect___ptr_ptrType__Out(reflect_ptrType *.this, __int32 i)
{
  return reflect___ptr_rtype__Out(&.this->rtype, i);
}

//----- (080B4390) --------------------------------------------------------
bool __golang reflect___ptr_ptrType__Implements(reflect_ptrType *.this, reflect_Type_0 u)
{
  return reflect___ptr_rtype__Implements(&.this->rtype, u);
}

//----- (080B43C0) --------------------------------------------------------
bool __golang reflect___ptr_ptrType__AssignableTo(reflect_ptrType *.this, reflect_Type_0 u)
{
  return reflect___ptr_rtype__AssignableTo(&.this->rtype, u);
}

//----- (080B43F0) --------------------------------------------------------
bool __golang reflect___ptr_ptrType__ConvertibleTo(reflect_ptrType *.this, reflect_Type_0 u)
{
  return reflect___ptr_rtype__ConvertibleTo(&.this->rtype, u);
}

//----- (080B4420) --------------------------------------------------------
bool __golang reflect___ptr_ptrType__Comparable(reflect_ptrType *.this)
{
  return reflect___ptr_rtype__Comparable(&.this->rtype);
}

//----- (080B4450) --------------------------------------------------------
reflect_uncommonType *__golang reflect___ptr_sliceType__uncommon(reflect_sliceType *.this)
{
  return reflect___ptr_rtype__uncommon(&.this->rtype);
}

//----- (080B4480) --------------------------------------------------------
string __golang reflect___ptr_sliceType__String(reflect_sliceType *.this)
{
  return reflect___ptr_rtype__String(&.this->rtype);
}

//----- (080B44C0) --------------------------------------------------------
uintptr __golang reflect___ptr_sliceType__Size(reflect_sliceType *.this)
{
  return reflect___ptr_rtype__Size(&.this->rtype);
}

//----- (080B44F0) --------------------------------------------------------
__int32 __golang reflect___ptr_sliceType__Bits(reflect_sliceType *.this)
{
  return reflect___ptr_rtype__Bits(&.this->rtype);
}

//----- (080B4520) --------------------------------------------------------
__int32 __golang reflect___ptr_sliceType__Align(reflect_sliceType *.this)
{
  return reflect___ptr_rtype__Align(&.this->rtype);
}

//----- (080B4550) --------------------------------------------------------
__int32 __golang reflect___ptr_sliceType__FieldAlign(reflect_sliceType *.this)
{
  return reflect___ptr_rtype__FieldAlign(&.this->rtype);
}

//----- (080B4580) --------------------------------------------------------
reflect_Kind __golang reflect___ptr_sliceType__Kind(reflect_sliceType *.this)
{
  return reflect___ptr_rtype__Kind(&.this->rtype);
}

//----- (080B45B0) --------------------------------------------------------
reflect_rtype *__golang reflect___ptr_sliceType__common(reflect_sliceType *.this)
{
  return reflect___ptr_rtype__common(&.this->rtype);
}

//----- (080B45E0) --------------------------------------------------------
__int32 __golang reflect___ptr_sliceType__NumMethod(reflect_sliceType *.this)
{
  return reflect___ptr_rtype__NumMethod(&.this->rtype);
}

//----- (080B4610) --------------------------------------------------------
void __golang reflect___ptr_sliceType__Method(reflect_sliceType *.this, __int32 i, reflect_Method_0 m)
{
  ((void (*)(void))loc_808FD86)();
  reflect___ptr_rtype__Method(&.this->rtype, i, m);
}

//----- (080B4650) --------------------------------------------------------
void __golang reflect___ptr_sliceType__MethodByName(reflect_sliceType *.this, string name, reflect_Method_0 m, bool ok)
{
  ((void (*)(void))loc_808FD86)();
  reflect___ptr_rtype__MethodByName(&.this->rtype, name, m, 0);
}

//----- (080B4690) --------------------------------------------------------
string __golang reflect___ptr_sliceType__PkgPath(reflect_sliceType *.this)
{
  return reflect___ptr_rtype__PkgPath(&.this->rtype);
}

//----- (080B46D0) --------------------------------------------------------
string __golang reflect___ptr_sliceType__Name(reflect_sliceType *.this)
{
  return reflect___ptr_rtype__Name(&.this->rtype);
}

//----- (080B4710) --------------------------------------------------------
reflect_ChanDir __golang reflect___ptr_sliceType__ChanDir(reflect_sliceType *.this)
{
  return reflect___ptr_rtype__ChanDir(&.this->rtype);
}

//----- (080B4740) --------------------------------------------------------
bool __golang reflect___ptr_sliceType__IsVariadic(reflect_sliceType *.this)
{
  return reflect___ptr_rtype__IsVariadic(&.this->rtype);
}

//----- (080B4770) --------------------------------------------------------
reflect_Type_0 __golang reflect___ptr_sliceType__Elem(reflect_sliceType *.this)
{
  return reflect___ptr_rtype__Elem(&.this->rtype);
}

//----- (080B47B0) --------------------------------------------------------
reflect_StructField_0 __golang reflect___ptr_sliceType__Field(reflect_sliceType *.this, __int32 i)
{
  ((void (*)(void))loc_808FD83)();
  return reflect___ptr_rtype__Field(&.this->rtype, i);
}

//----- (080B47F0) --------------------------------------------------------
reflect_StructField_0 __golang reflect___ptr_sliceType__FieldByIndex(reflect_sliceType *.this, __int index)
{
  ((void (*)(void))loc_808FD83)();
  return reflect___ptr_rtype__FieldByIndex(&.this->rtype, index);
}

//----- (080B4830) --------------------------------------------------------
retval_80B4830 __golang reflect___ptr_sliceType__FieldByName(reflect_sliceType *.this, string name)
{
  ((void (*)(void))loc_808FD83)();
  return (retval_80B4830)reflect___ptr_rtype__FieldByName(&.this->rtype, name);
}

//----- (080B4870) --------------------------------------------------------
retval_80B4870 __golang reflect___ptr_sliceType__FieldByNameFunc(reflect_sliceType *.this, func(string)_bool match)
{
  ((void (*)(void))loc_808FD83)();
  return (retval_80B4870)reflect___ptr_rtype__FieldByNameFunc(&.this->rtype, match);
}

//----- (080B48B0) --------------------------------------------------------
reflect_Type_0 __golang reflect___ptr_sliceType__In(reflect_sliceType *.this, __int32 i)
{
  return reflect___ptr_rtype__In(&.this->rtype, i);
}

//----- (080B48F0) --------------------------------------------------------
reflect_Type_0 __golang reflect___ptr_sliceType__Key(reflect_sliceType *.this)
{
  return reflect___ptr_rtype__Key(&.this->rtype);
}

//----- (080B4930) --------------------------------------------------------
__int32 __golang reflect___ptr_sliceType__Len(reflect_sliceType *.this)
{
  return reflect___ptr_rtype__Len(&.this->rtype);
}

//----- (080B4960) --------------------------------------------------------
__int32 __golang reflect___ptr_sliceType__NumField(reflect_sliceType *.this)
{
  return reflect___ptr_rtype__NumField(&.this->rtype);
}

//----- (080B4990) --------------------------------------------------------
__int32 __golang reflect___ptr_sliceType__NumIn(reflect_sliceType *.this)
{
  return reflect___ptr_rtype__NumIn(&.this->rtype);
}

//----- (080B49C0) --------------------------------------------------------
__int32 __golang reflect___ptr_sliceType__NumOut(reflect_sliceType *.this)
{
  return reflect___ptr_rtype__NumOut(&.this->rtype);
}

//----- (080B49F0) --------------------------------------------------------
reflect_Type_0 __golang reflect___ptr_sliceType__Out(reflect_sliceType *.this, __int32 i)
{
  return reflect___ptr_rtype__Out(&.this->rtype, i);
}

//----- (080B4A30) --------------------------------------------------------
bool __golang reflect___ptr_sliceType__Implements(reflect_sliceType *.this, reflect_Type_0 u)
{
  return reflect___ptr_rtype__Implements(&.this->rtype, u);
}

//----- (080B4A60) --------------------------------------------------------
bool __golang reflect___ptr_sliceType__AssignableTo(reflect_sliceType *.this, reflect_Type_0 u)
{
  return reflect___ptr_rtype__AssignableTo(&.this->rtype, u);
}

//----- (080B4A90) --------------------------------------------------------
bool __golang reflect___ptr_sliceType__ConvertibleTo(reflect_sliceType *.this, reflect_Type_0 u)
{
  return reflect___ptr_rtype__ConvertibleTo(&.this->rtype, u);
}

//----- (080B4AC0) --------------------------------------------------------
bool __golang reflect___ptr_sliceType__Comparable(reflect_sliceType *.this)
{
  return reflect___ptr_rtype__Comparable(&.this->rtype);
}

//----- (080B4AF0) --------------------------------------------------------
uintptr __golang type__hash__27_string(string (*p)[27], uintptr h)
{
  int j; // eax
  __int32 i; // [esp+Ch] [ebp-4h]

  for ( j = 0; j < 27; j = i + 1 )
  {
    i = j;
    h = runtime_strhash(&(*p)[j], h);
  }
  return h;
}

//----- (080B4B50) --------------------------------------------------------
bool __golang type__eq__27_string(string (*p)[27], string (*q)[27])
{
  int j; // eax
  char v3; // [esp+10h] [ebp-8h]
  __int32 i; // [esp+14h] [ebp-4h]

  for ( j = 0; j < 27; j = i + 1 )
  {
    if ( (*p)[j].len == (*q)[j].len )
    {
      i = j;
      runtime_eqstring();
      if ( v3 )
        continue;
    }
    return 0;
  }
  return 1;
}
// 80B4BB1: variable 'v3' is possibly undefined

//----- (080B4BD0) --------------------------------------------------------
uintptr __golang type__hash_struct__reflect_b_bool__reflect_x_interface__(
        struct_{_reflect_b_bool__reflect_x_interface_{}_} *p,
        uintptr h)
{
  uintptr v2; // [esp+Ch] [ebp-4h]

  v2 = runtime_memhash(p, h, 1u);
  return runtime_nilinterhash(&p->x, v2);
}

//----- (080B4C30) --------------------------------------------------------
bool __golang type__eq_struct__reflect_b_bool__reflect_x_interface__(
        struct_{_reflect_b_bool__reflect_x_interface_{}_} *p,
        struct_{_reflect_b_bool__reflect_x_interface_{}_} *q)
{
  runtime__type_0 *t; // eax

  if ( p->b != q->b )
    return 0;
  t = p->x._type;
  return t == q->x._type && runtime_efaceeq(t, p->x.data, q->x.data);
}

//----- (080B4CA0) --------------------------------------------------------
uintptr __golang type__hash_struct__F_uintptr__reflect_name_string_(
        struct_{_F_uintptr__reflect_name_string_} *p,
        uintptr h)
{
  uintptr v2; // [esp+Ch] [ebp-4h]

  v2 = runtime_memhash(p, h, 4u);
  return runtime_strhash(&p->name, v2);
}

//----- (080B4D00) --------------------------------------------------------
bool __golang type__eq_struct__F_uintptr__reflect_name_string_(
        struct_{_F_uintptr__reflect_name_string_} *p,
        struct_{_F_uintptr__reflect_name_string_} *q)
{
  bool v3; // [esp+10h] [ebp-4h]

  if ( p->_F != q->_F )
    return 0;
  if ( p->name.len != q->name.len )
    return 0;
  runtime_eqstring();
  return v3;
}
// 80B4D53: variable 'v3' is possibly undefined

//----- (080B4D70) --------------------------------------------------------
void __golang fmt___ptr_fmt__writePadding(fmt_fmt *f, __int32 n)
{
  __int32 v2; // eax
  fmt_fmt *v3; // ecx
  __int32 cap; // ebx
  unsigned __int32 len; // ebp
  char *src; // edx
  unsigned __int32 v7; // esi
  char v8; // di
  char *v9; // ebx
  __int32 i; // ebp
  uintptr *dst; // eax
  runtime_slice_0 v12; // [esp+Ch] [ebp-1Ch]
  __int32 newLen; // [esp+18h] [ebp-10h]
  __int32 buf_len; // [esp+1Ch] [ebp-Ch]
  __int32 buf_cap; // [esp+20h] [ebp-8h]

  v2 = n;
  if ( n > 0 )
  {
    v3 = f;
    cap = f->buf->cap;
    len = f->buf->len;
    src = (char *)f->buf->array;
    v7 = n + len;
    if ( (int)(n + len) > cap )
    {
      newLen = n + len;
      buf_len = f->buf->len;
      v12 = runtime_makeslice((runtime__type_0 *)&::i, n + 2 * cap, n + 2 * cap);
      runtime_memmove();
      v2 = n;
      v3 = f;
      len = buf_len;
      v7 = newLen;
      src = (char *)v12.array;
      cap = v12.cap;
    }
    if ( v3->fmtFlags.zero )
      v8 = 48;
    else
      v8 = 32;
    if ( len > v7 || v7 > cap )
      runtime_panicslice();
    buf_cap = cap;
    v9 = &src[((int)(len - cap) >> 31) & len];
    for ( i = 0; i < v2; ++i )
    {
      if ( i >= (unsigned int)v2 )
        runtime_panicindex();
      v9[i] = v8;
    }
    dst = (uintptr *)v3->buf;
    dst[1] = v7;
    dst[2] = buf_cap;
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr(dst, (uintptr)src);
    else
      *dst = (uintptr)src;
  }
}

//----- (080B4EC0) --------------------------------------------------------
void __golang fmt___ptr_fmt__pad(fmt_fmt *f, __uint8 b)
{
  __int32 len; // ecx
  unsigned __int32 v3; // ebx
  uint8 *array; // ebp
  unsigned __int32 cap; // esi
  uintptr *dst; // ecx
  __int32 v7; // ebx
  unsigned __int32 v8; // esi
  unsigned __int32 v9; // edi
  void *v10; // ecx
  __int32 v11; // ecx
  unsigned __int32 v12; // ebx
  unsigned __int32 v13; // ebp
  uint8 *v14; // esi
  runtime_slice_0 src; // [esp+4h] [ebp-38h]
  runtime_slice_0 srca; // [esp+4h] [ebp-38h]
  runtime_slice_0 srcb; // [esp+4h] [ebp-38h]
  __int32 v18; // [esp+Ch] [ebp-30h]
  runtime_slice_0 v19; // [esp+14h] [ebp-28h]
  runtime_slice_0 v20; // [esp+14h] [ebp-28h]
  runtime_slice_0 v21; // [esp+14h] [ebp-28h]
  __int32 width; // [esp+20h] [ebp-1Ch]
  __int32 v23; // [esp+28h] [ebp-14h]
  __int32 v24; // [esp+28h] [ebp-14h]
  uintptr *b_0; // [esp+2Ch] [ebp-10h]
  fmt_buffer *b_1; // [esp+30h] [ebp-Ch]
  fmt_buffer *b_2; // [esp+34h] [ebp-8h]
  uintptr v28; // [esp+38h] [ebp-4h]
  uintptr v29; // [esp+38h] [ebp-4h]

  if ( !f->fmtFlags.widPresent || !f->wid )
  {
    b_1 = f->buf;
    len = f->buf->len;
    v3 = len + b.len;
    v23 = len + b.len;
    array = f->buf->array;
    cap = f->buf->cap;
    if ( len + b.len > cap )
    {
      src.array = f->buf->array;
      *(_QWORD *)&src.len = __PAIR64__(cap, len);
      v19 = runtime_growslice((runtime__type_0 *)&i, src, len + b.len);
      cap = v19.cap;
      array = (uint8 *)v19.array;
      v3 = v23;
    }
    if ( v3 > cap )
      runtime_panicslice();
    v28 = (uintptr)array;
    runtime_memmove();
    dst = (uintptr *)b_1;
    b_1->len = v23;
    b_1->cap = cap;
    if ( !*(_DWORD *)&runtime_writeBarrier.enabled )
    {
      b_1->array = array;
      return;
    }
    goto LABEL_8;
  }
  v18 = unicode_utf8_RuneCount(b);
  if ( f->fmtFlags.minus )
  {
    width = f->wid - v18;
    b_0 = (uintptr *)f->buf;
    v7 = f->buf->len;
    v8 = b.len + v7;
    v9 = f->buf->cap;
    v10 = f->buf->array;
    if ( b.len + v7 > v9 )
    {
      srca.array = f->buf->array;
      *(_QWORD *)&srca.len = __PAIR64__(v9, v7);
      v20 = runtime_growslice((runtime__type_0 *)&i, srca, b.len + v7);
      v9 = v20.cap;
      v10 = v20.array;
      v8 = b.len + v7;
    }
    if ( v8 > v9 )
      runtime_panicslice();
    v29 = (uintptr)v10;
    runtime_memmove();
    b_0[1] = b.len + v7;
    b_0[2] = v9;
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr(b_0, v29);
    else
      *b_0 = v29;
    fmt___ptr_fmt__writePadding(f, width);
  }
  else
  {
    fmt___ptr_fmt__writePadding(f, f->wid - v18);
    b_2 = f->buf;
    v11 = f->buf->len;
    v12 = b.len + v11;
    v24 = b.len + v11;
    v13 = f->buf->cap;
    v14 = f->buf->array;
    if ( b.len + v11 > v13 )
    {
      srcb.array = f->buf->array;
      *(_QWORD *)&srcb.len = __PAIR64__(v13, v11);
      v21 = runtime_growslice((runtime__type_0 *)&i, srcb, b.len + v11);
      v13 = v21.cap;
      v14 = (uint8 *)v21.array;
      v12 = v24;
    }
    if ( v12 > v13 )
      runtime_panicslice();
    v28 = (uintptr)v14;
    runtime_memmove();
    dst = (uintptr *)b_2;
    b_2->len = v24;
    b_2->cap = v13;
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
    {
LABEL_8:
      runtime_writebarrierptr(dst, v28);
      return;
    }
    b_2->array = v14;
  }
}

//----- (080B51B0) --------------------------------------------------------
void __golang fmt___ptr_fmt__padString(fmt_fmt *f, string s)
{
  __int32 len; // ecx
  unsigned __int32 v3; // ebx
  unsigned __int32 cap; // ebp
  uint8 *array; // esi
  uintptr *dst; // ecx
  __int32 v7; // ebx
  unsigned __int32 v8; // esi
  unsigned __int32 v9; // edi
  void *v10; // ecx
  __int32 v11; // ecx
  unsigned __int32 v12; // ebx
  unsigned __int32 v13; // ebp
  uint8 *v14; // esi
  runtime_slice_0 src; // [esp+4h] [ebp-38h]
  runtime_slice_0 srca; // [esp+4h] [ebp-38h]
  runtime_slice_0 srcb; // [esp+4h] [ebp-38h]
  __int32 v18; // [esp+8h] [ebp-34h]
  int v19; // [esp+8h] [ebp-34h]
  runtime_slice_0 v20; // [esp+14h] [ebp-28h]
  runtime_slice_0 v21; // [esp+14h] [ebp-28h]
  runtime_slice_0 v22; // [esp+14h] [ebp-28h]
  __int32 width; // [esp+20h] [ebp-1Ch]
  __int32 v24; // [esp+28h] [ebp-14h]
  __int32 v25; // [esp+28h] [ebp-14h]
  uintptr *b; // [esp+2Ch] [ebp-10h]
  fmt_buffer *b_0; // [esp+30h] [ebp-Ch]
  fmt_buffer *b_1; // [esp+34h] [ebp-8h]
  uintptr v29; // [esp+38h] [ebp-4h]
  uintptr v30; // [esp+38h] [ebp-4h]

  if ( !f->fmtFlags.widPresent || !f->wid )
  {
    b_0 = f->buf;
    len = f->buf->len;
    v3 = s.len + len;
    v24 = s.len + len;
    cap = f->buf->cap;
    array = f->buf->array;
    if ( s.len + len > cap )
    {
      src.array = f->buf->array;
      *(_QWORD *)&src.len = __PAIR64__(cap, len);
      v20 = runtime_growslice((runtime__type_0 *)&i, src, s.len + len);
      cap = v20.cap;
      array = (uint8 *)v20.array;
      v3 = v24;
    }
    if ( v3 > cap )
      runtime_panicslice();
    v29 = (uintptr)array;
    runtime_memmove();
    dst = (uintptr *)b_0;
    b_0->len = v24;
    b_0->cap = cap;
    if ( !*(_DWORD *)&runtime_writeBarrier.enabled )
    {
      b_0->array = array;
      return;
    }
    goto LABEL_8;
  }
  unicode_utf8_RuneCountInString(s, v18);
  if ( f->fmtFlags.minus )
  {
    width = f->wid - v19;
    b = (uintptr *)f->buf;
    v7 = f->buf->len;
    v8 = s.len + v7;
    v9 = f->buf->cap;
    v10 = f->buf->array;
    if ( s.len + v7 > v9 )
    {
      srca.array = f->buf->array;
      *(_QWORD *)&srca.len = __PAIR64__(v9, v7);
      v21 = runtime_growslice((runtime__type_0 *)&i, srca, s.len + v7);
      v9 = v21.cap;
      v10 = v21.array;
      v8 = s.len + v7;
    }
    if ( v8 > v9 )
      runtime_panicslice();
    v30 = (uintptr)v10;
    runtime_memmove();
    b[1] = s.len + v7;
    b[2] = v9;
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr(b, v30);
    else
      *b = v30;
    fmt___ptr_fmt__writePadding(f, width);
  }
  else
  {
    fmt___ptr_fmt__writePadding(f, f->wid - v19);
    b_1 = f->buf;
    v11 = f->buf->len;
    v12 = s.len + v11;
    v25 = s.len + v11;
    v13 = f->buf->cap;
    v14 = f->buf->array;
    if ( s.len + v11 > v13 )
    {
      srcb.array = f->buf->array;
      *(_QWORD *)&srcb.len = __PAIR64__(v13, v11);
      v22 = runtime_growslice((runtime__type_0 *)&i, srcb, s.len + v11);
      v13 = v22.cap;
      v14 = (uint8 *)v22.array;
      v12 = v25;
    }
    if ( v12 > v13 )
      runtime_panicslice();
    v29 = (uintptr)v14;
    runtime_memmove();
    dst = (uintptr *)b_1;
    b_1->len = v25;
    b_1->cap = v13;
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
    {
LABEL_8:
      runtime_writebarrierptr(dst, v29);
      return;
    }
    b_1->array = v14;
  }
}
// 80B52AA: variable 'v18' is possibly undefined
// 80B52C8: variable 'v19' is possibly undefined

//----- (080B5490) --------------------------------------------------------
void __golang fmt___ptr_fmt__fmt_boolean(fmt_fmt *f, bool v)
{
  string s; // [esp+4h] [ebp-8h]

  if ( v )
  {
    s.str = (uint8 *)"true";
    s.len = 4;
  }
  else
  {
    s.str = (uint8 *)"false";
    s.len = 5;
  }
  fmt___ptr_fmt__padString(f, s);
}

//----- (080B5500) --------------------------------------------------------
void __golang fmt___ptr_fmt__fmt_unicode(fmt_fmt *f, uint64 u)
{
  fmt_fmt *v2; // eax
  uint8 *intbuf; // ecx
  __int32 v4; // edx
  unsigned __int32 len; // ebx
  __int32 cap; // ebp
  unsigned int v7; // esi
  unsigned int v8; // ebp
  unsigned int v9; // eax
  char v10; // bp
  unsigned __int32 v11; // edx
  char v12; // bp
  int j; // ebx
  unsigned __int32 v14; // ebx
  int v15; // ebp
  unsigned __int32 v16; // ecx
  __uint8 r; // [esp+0h] [ebp-34h]
  __uint8 b; // [esp+4h] [ebp-30h]
  __uint8 b_8; // [esp+Ch] [ebp-28h]
  bool oldZero; // [esp+1Bh] [ebp-19h]
  __int32 prec; // [esp+1Ch] [ebp-18h]
  __int32 preca; // [esp+1Ch] [ebp-18h]
  __int32 i; // [esp+20h] [ebp-14h]
  unsigned __int32 buf_len; // [esp+24h] [ebp-10h]
  __int32 buf_cap; // [esp+28h] [ebp-Ch]
  __int32 v26; // [esp+2Ch] [ebp-8h]
  uint8 *buf_ptr; // [esp+30h] [ebp-4h]
  unsigned int ua; // [esp+3Ch] [ebp+8h]

  v2 = f;
  intbuf = f->intbuf;
  if ( f->fmtFlags.precPresent )
  {
    v4 = f->prec;
    if ( v4 <= 4 )
    {
      cap = 68;
      len = 68;
      v4 = 4;
    }
    else if ( v4 + 9 > 68 )
    {
      v26 = f->prec;
      b_8 = (__uint8)runtime_makeslice((runtime__type_0 *)&::i, v4 + 9, v4 + 9);
      intbuf = b_8.array;
      cap = b_8.cap;
      len = b_8.len;
      v2 = f;
      v4 = v26;
    }
    else
    {
      len = 68;
      cap = 68;
    }
  }
  else
  {
    cap = 68;
    len = 68;
    v4 = 4;
  }
  buf_cap = cap;
  if ( !v2->fmtFlags.sharp )
  {
    v7 = HIDWORD(u);
    v8 = u;
    goto LABEL_7;
  }
  v7 = HIDWORD(u);
  v8 = u;
  if ( (unsigned int)u > 0x10FFFF || HIDWORD(u) != 0 )
  {
LABEL_7:
    v9 = len;
    goto LABEL_9;
  }
  buf_len = len;
  buf_ptr = intbuf;
  preca = v4;
  if ( !strconv_IsPrint(u) )
  {
    intbuf = buf_ptr;
    v4 = preca;
    v7 = HIDWORD(u);
    v8 = u;
    goto LABEL_7;
  }
  if ( len - 1 >= len )
    runtime_panicindex();
  buf_ptr[len - 1] = 39;
  if ( (u & 0x80000000) == 0LL )
  {
    if ( (int)u > 127 )
    {
      if ( (int)u > 2047 )
      {
        if ( (unsigned int)(u - 55296) > 0x7FF )
        {
          if ( (int)u > 0xFFFF )
          {
            if ( (int)u > 1114111 )
              v15 = -1;
            else
              v15 = 4;
          }
          else
          {
            v15 = 3;
          }
        }
        else
        {
          v15 = -1;
        }
      }
      else
      {
        v15 = 2;
      }
    }
    else
    {
      v15 = 1;
    }
  }
  else
  {
    v15 = -1;
  }
  v16 = len - 1 - v15;
  if ( v16 > len )
    runtime_panicslice();
  i = len - 1 - v15;
  r.array = &buf_ptr[v16 & ((int)(v16 - buf_cap) >> 31)];
  r.len = v15 + 1;
  r.cap = buf_cap - v16;
  unicode_utf8_EncodeRune(r, u);
  if ( i - 1 >= len )
    runtime_panicindex();
  intbuf = buf_ptr;
  buf_ptr[i - 1] = 39;
  len = i - 2;
  if ( i - 2 >= buf_len )
    runtime_panicindex();
  buf_ptr[i - 2] = 32;
  v9 = buf_len;
  v4 = preca;
  v7 = HIDWORD(u);
  v8 = u;
LABEL_9:
  while ( 1 )
  {
    prec = v4;
    if ( v7 == 0 && (v7 != 0 || v8 < 0x10) )
      break;
    ua = v8;
    v10 = a0123456789abcd_0[v8 & 0xF];
    if ( len - 1 >= v9 )
      runtime_panicindex();
    intbuf[len - 1] = v10;
    v8 = (ua >> 4) | (v7 << 28);
    v7 >>= 4;
    --len;
    --v4;
  }
  if ( v7 || v8 >= 0x11 || (v11 = len - 1, v12 = a0123456789abcd_0[v8], len - 1 >= v9) )
    runtime_panicindex();
  intbuf[len - 1] = v12;
  for ( j = prec - 1; j > 0; --j )
  {
    if ( v11 - 1 >= v9 )
      runtime_panicindex();
    intbuf[--v11] = 48;
  }
  if ( v11 - 1 >= v9 )
    runtime_panicindex();
  intbuf[v11 - 1] = 43;
  v14 = v11 - 2;
  if ( v11 - 2 >= v9 )
    runtime_panicindex();
  intbuf[v11 - 2] = 85;
  oldZero = f->fmtFlags.zero;
  f->fmtFlags.zero = 0;
  b.array = &intbuf[v14 & ((int)(v14 - buf_cap) >> 31)];
  b.len = v9 - v14;
  b.cap = buf_cap - v14;
  fmt___ptr_fmt__pad(f, b);
  f->fmtFlags.zero = oldZero;
}

//----- (080B58A0) --------------------------------------------------------
void __golang fmt___ptr_fmt__fmt_integer(fmt_fmt *f, uint64 u, __int32 base, bool isSigned, string digits)
{
  bool v5; // bl
  unsigned __int32 v6; // ecx
  signed __int64 v7; // rax
  uint8 *intbuf; // ebp
  __int32 v9; // esi
  __int32 len; // esi
  __int32 cap; // edi
  signed int v12; // edi
  unsigned int v13; // ebx
  char v14; // cl
  int v15; // edx
  uint8 v16; // cl
  unsigned int v17; // esi
  int v18; // eax
  bool v19; // zf
  unsigned int v20; // edx
  bool zero; // al
  char v22; // cl
  uint8 *str; // ebx
  unsigned __int32 v24; // ecx
  char v25; // cl
  uint64 n; // [esp+0h] [ebp-38h]
  __uint8 n_4; // [esp+4h] [ebp-34h]
  runtime_slice_0 v28; // [esp+Ch] [ebp-2Ch]
  uint64 v29; // [esp+10h] [ebp-28h]
  bool oldZero; // [esp+19h] [ebp-1Fh]
  bool oldZero_0; // [esp+1Ah] [ebp-1Eh]
  bool negative; // [esp+1Bh] [ebp-1Dh]
  unsigned __int32 buf_len; // [esp+24h] [ebp-14h]
  __int32 buf_cap; // [esp+28h] [ebp-10h]
  unsigned int v35; // [esp+2Ch] [ebp-Ch]
  char v36; // [esp+30h] [ebp-8h]
  unsigned __int32 v37; // [esp+30h] [ebp-8h]
  uint8 *buf_ptr; // [esp+34h] [ebp-4h]

  v5 = isSigned && (u & 0x8000000000000000LL) != 0LL;
  if ( v5 )
  {
    v6 = -(int)u;
    HIDWORD(v7) = (unsigned __int64)-(__int64)u >> 32;
  }
  else
  {
    HIDWORD(v7) = HIDWORD(u);
    v6 = u;
  }
  negative = v5;
  intbuf = f->intbuf;
  LODWORD(v7) = f;
  if ( f->fmtFlags.widPresent || (LODWORD(v7) = f, f->fmtFlags.precPresent) )
  {
    v9 = *(_DWORD *)(v7 + 16) + *(_DWORD *)(v7 + 20) + 3;
    if ( v9 > 68 )
    {
      v37 = v6;
      v35 = HIDWORD(v7);
      v28 = runtime_makeslice((runtime__type_0 *)&i, v9, v9);
      cap = v28.cap;
      len = v28.len;
      intbuf = (uint8 *)v28.array;
      v7 = __PAIR64__(v35, (unsigned int)f);
      v6 = v37;
    }
    else
    {
      len = 68;
      cap = 68;
    }
  }
  else
  {
    len = 68;
    cap = 68;
  }
  buf_cap = cap;
  if ( *(_BYTE *)(v7 + 5) )
  {
    v12 = *(_DWORD *)(v7 + 20);
    if ( !v12 && v6 == 0 && HIDWORD(v7) == 0 )
    {
      oldZero = f->fmtFlags.zero;
      f->fmtFlags.zero = 0;
      fmt___ptr_fmt__writePadding(f, f->wid);
      f->fmtFlags.zero = oldZero;
      return;
    }
  }
  else if ( *(_BYTE *)(v7 + 10) )
  {
    if ( *(_BYTE *)(v7 + 4) )
    {
      v12 = *(_DWORD *)(v7 + 16);
      if ( v5 || *(_BYTE *)(v7 + 7) || *(_BYTE *)(v7 + 9) )
        --v12;
    }
    else
    {
      v12 = 0;
    }
  }
  else
  {
    v12 = 0;
  }
  if ( base <= 8 )
  {
    if ( base == 2 )
    {
      v13 = len;
      while ( HIDWORD(v7) == 0 && v6 >= 2 || HIDWORD(v7) != 0 )
      {
        LODWORD(v7) = v6;
        v14 = (v6 & 1) + 48;
        if ( len - 1 >= v13 )
          runtime_panicindex();
        intbuf[len - 1] = v14;
        v6 = v7 >> 1;
        HIDWORD(v7) >>= 1;
        --len;
      }
      goto LABEL_18;
    }
    if ( base == 8 )
    {
      v13 = len;
      while ( v6 >= 8 && HIDWORD(v7) == 0 || HIDWORD(v7) != 0 )
      {
        LODWORD(v7) = v6;
        v22 = (v6 & 7) + 48;
        if ( len - 1 >= v13 )
          runtime_panicindex();
        intbuf[len - 1] = v22;
        v6 = v7 >> 3;
        HIDWORD(v7) >>= 3;
        --len;
      }
      goto LABEL_18;
    }
LABEL_99:
    LODWORD(n) = &t;
    HIDWORD(n) = &fmt_statictmp_0;
    runtime_gopanic((interface_{})n);
    BUG();
  }
  buf_len = len;
  if ( base == 10 )
  {
    buf_ptr = intbuf;
    v13 = len;
    while ( HIDWORD(v7) == 0 && v6 >= 0xA || HIDWORD(v7) != 0 )
    {
      LODWORD(v7) = v6;
      v36 = v6 + 48;
      v29 = runtime_uint64div(v7, 0xAuLL);
      if ( len - 1 >= buf_len )
        runtime_panicindex();
      buf_ptr[len - 1] = v36 - 10 * v29;
      HIDWORD(v7) = HIDWORD(v29);
      v6 = v29;
      --len;
      v13 = buf_len;
      intbuf = buf_ptr;
    }
  }
  else
  {
    if ( base != 16 )
      goto LABEL_99;
    str = digits.str;
    while ( HIDWORD(v7) != 0 || v6 >= 0x10 && HIDWORD(v7) == 0 )
    {
      LODWORD(v7) = v6;
      v24 = v6 & 0xF;
      if ( v24 >= digits.len || (v25 = str[v24], len - 1 >= buf_len) )
        runtime_panicindex();
      intbuf[len - 1] = v25;
      v6 = v7 >> 4;
      HIDWORD(v7) >>= 4;
      str = digits.str;
      --len;
    }
    v13 = buf_len;
  }
LABEL_18:
  if ( HIDWORD(v7) || v6 >= digits.len || (v15 = len - 1, v16 = digits.str[v6], len - 1 >= v13) )
    runtime_panicindex();
  intbuf[len - 1] = v16;
  while ( v15 > 0 )
  {
    v17 = v13;
    if ( v12 <= (int)(v13 - v15) )
      goto LABEL_27;
    if ( v15 - 1 >= v13 )
      runtime_panicindex();
    intbuf[--v15] = 48;
  }
  v17 = v13;
LABEL_27:
  if ( f->fmtFlags.sharp )
  {
    if ( base == 8 )
    {
      if ( v15 >= v17 )
        runtime_panicindex();
      if ( intbuf[v15] == 48 )
      {
        v19 = !negative;
        v18 = v15;
      }
      else
      {
        v18 = v15 - 1;
        if ( v15 - 1 >= v17 )
          runtime_panicindex();
        intbuf[v15 - 1] = 48;
        v19 = !negative;
      }
    }
    else if ( base == 16 )
    {
      if ( digits.len <= 0x10u || v15 - 1 >= v17 )
        runtime_panicindex();
      intbuf[v15 - 1] = digits.str[16];
      v18 = v15 - 2;
      if ( v15 - 2 >= v17 )
        runtime_panicindex();
      intbuf[v15 - 2] = 48;
      v19 = !negative;
    }
    else
    {
      v19 = !negative;
      v18 = v15;
    }
  }
  else
  {
    v19 = !negative;
    v18 = v15;
  }
  if ( v19 )
  {
    if ( f->fmtFlags.plus )
    {
      v20 = v18 - 1;
      if ( v18 - 1 >= v17 )
        runtime_panicindex();
      intbuf[v18 - 1] = 43;
    }
    else if ( f->fmtFlags.space )
    {
      v20 = v18 - 1;
      if ( v18 - 1 >= v17 )
        runtime_panicindex();
      intbuf[v18 - 1] = 32;
    }
    else
    {
      v20 = v18;
    }
  }
  else
  {
    v20 = v18 - 1;
    if ( v18 - 1 >= v17 )
      runtime_panicindex();
    intbuf[v18 - 1] = 45;
  }
  zero = f->fmtFlags.zero;
  f->fmtFlags.zero = 0;
  if ( v20 > v17 )
    runtime_panicslice();
  oldZero_0 = zero;
  n_4.array = &intbuf[v20 & ((int)(v20 - buf_cap) >> 31)];
  n_4.len = v17 - v20;
  n_4.cap = buf_cap - v20;
  fmt___ptr_fmt__pad(f, n_4);
  f->fmtFlags.zero = oldZero_0;
}

//----- (080B5E80) --------------------------------------------------------
string __golang fmt___ptr_fmt__truncate(fmt_fmt *f, string s)
{
  __int32 prec; // eax
  __int32 k; // ecx
  unsigned __int32 len; // edx
  uint8 *str; // ebx
  __int32 v6; // ebp
  int32 v7; // [esp+Ch] [ebp-10h]
  __int32 v8; // [esp+10h] [ebp-Ch]
  __int32 n; // [esp+14h] [ebp-8h]
  __int32 i; // [esp+18h] [ebp-4h]
  string _r1; // [esp+2Ch] [ebp+10h]

  if ( f->fmtFlags.precPresent )
  {
    prec = f->prec;
    for ( k = 0; ; k = v6 )
    {
      len = s.len;
      if ( k >= s.len )
        break;
      str = s.str;
      if ( s.str[k] >= 0x80u )
      {
        i = k;
        n = prec;
        runtime_decoderune(s, k, v7, v8);
        v6 = v8;
        prec = n;
        k = i;
        len = s.len;
        str = s.str;
      }
      else
      {
        v6 = k + 1;
      }
      if ( --prec < 0 )
      {
        if ( k > len )
          runtime_panicslice();
        _r1.str = str;
        _r1.len = k;
        return _r1;
      }
    }
  }
  else
  {
    len = s.len;
  }
  _r1.str = s.str;
  _r1.len = len;
  return _r1;
}
// 80B5EF1: variable 'v7' is possibly undefined
// 80B5EF1: variable 'v8' is possibly undefined

//----- (080B5F40) --------------------------------------------------------
void __golang fmt___ptr_fmt__fmt_s(fmt_fmt *f, string s)
{
  string v2; // [esp+Ch] [ebp-8h]

  v2 = fmt___ptr_fmt__truncate(f, s);
  fmt___ptr_fmt__padString(f, v2);
}

//----- (080B5FA0) --------------------------------------------------------
void __golang fmt___ptr_fmt__fmt_sbx(fmt_fmt *f, string s, __uint8 b, string digits)
{
  __int32 len; // ecx
  fmt_fmt *v5; // edx
  __int32 prec; // ebx
  __int32 v7; // ecx
  int v8; // ebx
  __int32 v9; // ebx
  int v10; // ecx
  int v11; // ecx
  __int32 wid; // ebp
  __int64 v13; // rdi
  _BYTE *array; // ebp
  __int32 v15; // ecx
  uint8 v16; // al
  __int32 v17; // eax
  __int32 v18; // edx
  uint8 v19; // bl
  uint8 *v20; // ecx
  bool v21; // zf
  uint8 v22; // di
  unsigned __int32 v23; // edi
  uint8 v24; // di
  unsigned __int32 v25; // eax
  __int32 v26; // ebx
  uint8 v27; // al
  uintptr *buf; // eax
  __int32 v29; // eax
  int v30; // ebp
  int v31; // ebp
  runtime_slice_0 olda; // [esp+4h] [ebp-38h]
  runtime_slice_0 oldb; // [esp+4h] [ebp-38h]
  runtime_slice_0 old; // [esp+4h] [ebp-38h]
  runtime_slice_0 v35; // [esp+14h] [ebp-28h]
  runtime_slice_0 v36; // [esp+14h] [ebp-28h]
  runtime_slice_0 v37; // [esp+14h] [ebp-28h]
  runtime_slice_0 v38; // [esp+14h] [ebp-28h]
  uint8 c; // [esp+21h] [ebp-1Bh]
  uint8 v40; // [esp+22h] [ebp-1Ah]
  uint8 v41; // [esp+23h] [ebp-19h]
  __int32 width; // [esp+24h] [ebp-18h]
  __int32 i; // [esp+28h] [ebp-14h]
  __int32 buf_len; // [esp+2Ch] [ebp-10h]
  __int32 v45; // [esp+30h] [ebp-Ch]
  __int32 v46; // [esp+38h] [ebp-4h]

  if ( b.array )
    len = b.len;
  else
    len = s.len;
  v5 = f;
  if ( !f->fmtFlags.precPresent || (prec = f->prec, prec >= len) )
    prec = len;
  v7 = prec;
  v8 = 2 * prec;
  if ( v8 <= 0 )
  {
    if ( f->fmtFlags.widPresent )
      fmt___ptr_fmt__writePadding(f, f->wid);
  }
  else
  {
    if ( f->fmtFlags.space )
    {
      if ( f->fmtFlags.sharp )
      {
        v9 = v7;
        v10 = 4 * v7;
      }
      else
      {
        v30 = v8;
        v9 = v7;
        v10 = v30;
      }
      v11 = v10 + v9 - 1;
    }
    else
    {
      if ( f->fmtFlags.sharp )
        v8 += 2;
      v31 = v8;
      v9 = v7;
      v11 = v31;
    }
    v46 = v9;
    width = v11;
    if ( f->fmtFlags.widPresent )
    {
      wid = f->wid;
      if ( wid > v11 && !f->fmtFlags.minus )
      {
        fmt___ptr_fmt__writePadding(f, wid - v11);
        v5 = f;
      }
    }
    v13 = *(_QWORD *)&v5->buf->len;
    array = v5->buf->array;
    if ( v5->fmtFlags.sharp )
    {
      if ( digits.len <= 0x10u )
        runtime_panicindex();
      v15 = v13 + 2;
      v16 = digits.str[16];
      if ( (int)v13 + 2 > SHIDWORD(v13) )
      {
        v41 = digits.str[16];
        v38 = runtime_growslice((runtime__type_0 *)&::i, *(runtime_slice_0 *)v5->buf, (int)v13 + 2);
        array = v38.array;
        HIDWORD(v13) = v38.cap;
        v15 = v38.len + 2;
        v16 = v41;
        v5 = f;
      }
      array[v13] = 48;
      array[(_DWORD)v13 + 1] = v16;
    }
    else
    {
      v15 = v5->buf->len;
    }
    v17 = 0;
    while ( v17 < v9 )
    {
      i = v17;
      if ( v5->fmtFlags.space )
      {
        if ( v17 <= 0 )
        {
          v21 = b.array == 0;
          v18 = v15;
          v20 = b.array;
        }
        else
        {
          LODWORD(v13) = v15 + 1;
          if ( v15 + 1 > SHIDWORD(v13) )
          {
            v45 = v15;
            old.array = array;
            *(_QWORD *)&old.len = __PAIR64__(HIDWORD(v13), v15);
            v37 = runtime_growslice((runtime__type_0 *)&::i, old, v15 + 1);
            array = v37.array;
            HIDWORD(v13) = v37.cap;
            LODWORD(v13) = v37.len + 1;
            v17 = i;
            v15 = v45;
            v5 = f;
          }
          array[v15] = 32;
          if ( v5->fmtFlags.sharp )
          {
            if ( digits.len <= 0x10u )
              runtime_panicindex();
            v18 = v13 + 2;
            v19 = digits.str[16];
            if ( (int)v13 + 2 > SHIDWORD(v13) )
            {
              oldb.array = array;
              *(_QWORD *)&oldb.len = v13;
              v36 = runtime_growslice((runtime__type_0 *)&::i, oldb, (int)v13 + 2);
              array = v36.array;
              HIDWORD(v13) = v36.cap;
              v18 = v36.len + 2;
              v20 = b.array;
              v21 = b.array == 0;
              v17 = i;
            }
            else
            {
              v20 = b.array;
              v21 = b.array == 0;
            }
            array[v13] = 48;
            array[(_DWORD)v13 + 1] = v19;
          }
          else
          {
            v20 = b.array;
            v21 = b.array == 0;
            v18 = v13;
          }
        }
      }
      else
      {
        v21 = b.array == 0;
        v18 = v15;
        v20 = b.array;
      }
      if ( v21 )
      {
        if ( (unsigned int)v17 >= s.len )
          runtime_panicindex();
        v22 = s.str[v17];
      }
      else
      {
        if ( (unsigned int)v17 >= b.len )
          runtime_panicindex();
        v22 = v20[v17];
      }
      c = v22;
      v23 = v22 >> 4;
      if ( v23 >= digits.len || (v24 = digits.str[v23], v25 = c & 0xF, v25 >= digits.len) )
        runtime_panicindex();
      v26 = v18 + 2;
      v27 = digits.str[v25];
      if ( v18 + 2 > SHIDWORD(v13) )
      {
        buf_len = v18;
        v40 = v27;
        olda.array = array;
        *(_QWORD *)&olda.len = __PAIR64__(HIDWORD(v13), v18);
        v35 = runtime_growslice((runtime__type_0 *)&::i, olda, v18 + 2);
        array = v35.array;
        HIDWORD(v13) = v35.cap;
        v26 = v35.len + 2;
        v27 = v40;
        v18 = buf_len;
      }
      array[v18] = v24;
      array[v18 + 1] = v27;
      v17 = i + 1;
      v5 = f;
      v15 = v26;
      v9 = v46;
    }
    buf = (uintptr *)v5->buf;
    buf[1] = v15;
    buf[2] = HIDWORD(v13);
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
    {
      runtime_writebarrierptr(buf, (uintptr)array);
      v5 = f;
    }
    else
    {
      *buf = (uintptr)array;
    }
    if ( v5->fmtFlags.widPresent )
    {
      v29 = v5->wid;
      if ( v29 > width && v5->fmtFlags.minus )
        fmt___ptr_fmt__writePadding(v5, v29 - width);
    }
  }
}

//----- (080B63E0) --------------------------------------------------------
void __golang fmt___ptr_fmt__fmt_sx(fmt_fmt *f, string s, string digits)
{
  __uint8 b; // [esp+Ch] [ebp-14h] BYREF

  memset(&b, 0, sizeof(b));
  fmt___ptr_fmt__fmt_sbx(f, s, b, digits);
}

//----- (080B6450) --------------------------------------------------------
void __golang fmt___ptr_fmt__fmt_bx(fmt_fmt *f, __uint8 b, string digits)
{
  fmt___ptr_fmt__fmt_sbx(f, 0LL, b, digits);
}

//----- (080B64C0) --------------------------------------------------------
void __golang fmt___ptr_fmt__fmt_q(fmt_fmt *f, string s)
{
  __int32 len; // eax
  uint8 *str; // ecx
  fmt_fmt *v4; // edx
  __uint8 dst; // [esp+0h] [ebp-44h]
  string dst_4[3]; // [esp+4h] [ebp-40h]
  __uint8 b; // [esp+14h] [ebp-30h]
  string b_8; // [esp+1Ch] [ebp-28h]
  uint8 buf[32]; // [esp+24h] [ebp-20h] BYREF

  dst_4[1] = fmt___ptr_fmt__truncate(f, s);
  len = dst_4[1].len;
  str = dst_4[1].str;
  v4 = f;
  if ( f->fmtFlags.sharp )
  {
    if ( strconv_CanBackquote(dst_4[1]) )
    {
      dst_4[0].str = (uint8 *)"`";
      dst_4[0].len = 1;
      dst_4[2].str = (uint8 *)"`";
      dst_4[2].len = 1;
      b_8 = runtime_concatstring3((uint8 (*)[32])buf, *(string (*)[3])&dst_4[0].str);
      fmt___ptr_fmt__padString(f, b_8);
      return;
    }
    len = dst_4[1].len;
    str = dst_4[1].str;
    v4 = f;
  }
  dst.array = v4->intbuf;
  *(_QWORD *)&dst.len = 0x4400000000LL;
  if ( v4->fmtFlags.plus )
    b = strconv_AppendQuoteToASCII(dst, (string)__PAIR64__(len, (unsigned int)str));
  else
    b = strconv_AppendQuote(dst, (string)__PAIR64__(len, (unsigned int)str));
  fmt___ptr_fmt__pad(f, b);
}
// 80E0D9F: using guessed type char asc_80E0D9F;

//----- (080B6640) --------------------------------------------------------
void __golang fmt___ptr_fmt__fmt_c(fmt_fmt *f, uint64 c)
{
  uint64 r; // rax
  __uint8 p; // [esp+0h] [ebp-18h]
  __uint8 p_4; // [esp+4h] [ebp-14h]
  unsigned __int32 v5; // [esp+10h] [ebp-8h]

  r = c;
  if ( (unsigned int)c > 0x10FFFF && HIDWORD(c) == 0 || HIDWORD(c) != 0 )
    LODWORD(r) = 65533;
  p.array = f->intbuf;
  *(_QWORD *)&p.len = 0x4400000004LL;
  v5 = unicode_utf8_EncodeRune(p, r);
  if ( v5 > 0x44 )
    runtime_panicslice();
  p_4.array = f->intbuf;
  *(_QWORD *)&p_4.len = v5 | 0x4400000000LL;
  fmt___ptr_fmt__pad(f, p_4);
}

//----- (080B66F0) --------------------------------------------------------
void __golang fmt___ptr_fmt__fmt_qc(fmt_fmt *f, uint64 c)
{
  int32 r; // eax
  __uint8 dst; // [esp+0h] [ebp-1Ch]
  __uint8 b; // [esp+10h] [ebp-Ch]

  if ( (unsigned int)c > 0x10FFFF && HIDWORD(c) == 0 || HIDWORD(c) != 0 )
    r = 65533;
  else
    r = c;
  dst.array = f->intbuf;
  *(_QWORD *)&dst.len = 0x4400000000LL;
  if ( f->fmtFlags.plus )
    b = strconv_AppendQuoteRuneToASCII(dst, r);
  else
    b = strconv_AppendQuoteRune(dst, r);
  fmt___ptr_fmt__pad(f, b);
}

//----- (080B67E0) --------------------------------------------------------
void __golang fmt___ptr_fmt__fmt_float(fmt_fmt *f, float64 v, __int32 size, int32 verb, __int32 prec)
{
  __int32 v5; // ecx
  __int32 cap; // eax
  unsigned __int32 len; // ecx
  uint8 v8; // bl
  uint8 *array; // ebp
  uint8 v10; // bl
  int v11; // ebx
  unsigned int v12; // esi
  int v13; // edi
  uint8 v14; // dl
  int v15; // edx
  uint8 *v16; // edi
  unsigned __int32 v17; // ebx
  int v18; // eax
  unsigned __int32 v19; // ebp
  __int32 v20; // esi
  unsigned int v21; // esi
  uint8 *v22; // eax
  __int32 v23; // ecx
  __int32 v24; // edx
  fmt_fmt *v25; // ebx
  fmt_buffer *buf; // ebp
  uint8 v27; // si
  __int32 v28; // edi
  __int32 v29; // eax
  uint8 *v30; // ecx
  __int32 v31; // edx
  unsigned __int32 v32; // ebp
  unsigned __int32 v33; // esi
  uint8 *v34; // edi
  uintptr *v35; // ecx
  uint8 *v36; // eax
  __int32 v37; // ecx
  uintptr *v38; // ebx
  uint8 *v39; // edx
  __int32 v40; // esi
  __uint8 dst; // [esp+0h] [ebp-94h]
  __uint8 dst_4; // [esp+4h] [ebp-90h]
  __uint8 dst_4a; // [esp+4h] [ebp-90h]
  __uint8 dst_4c; // [esp+4h] [ebp-90h]
  __uint8 dst_4d; // [esp+4h] [ebp-90h]
  __uint8 dst_4e; // [esp+4h] [ebp-90h]
  __uint8 dst_4f; // [esp+4h] [ebp-90h]
  __uint8 dst_4b; // [esp+4h] [ebp-90h]
  __uint8 dst_4g; // [esp+4h] [ebp-90h]
  __uint8 dst_4h; // [esp+4h] [ebp-90h]
  runtime_slice_0 fmta; // [esp+14h] [ebp-80h]
  runtime_slice_0 fmtb; // [esp+14h] [ebp-80h]
  runtime_slice_0 fmtd; // [esp+14h] [ebp-80h]
  runtime_slice_0 fmt; // [esp+14h] [ebp-80h]
  runtime_slice_0 fmtc; // [esp+14h] [ebp-80h]
  runtime_slice_0 fmte; // [esp+14h] [ebp-80h]
  __uint8 appended; // [esp+20h] [ebp-74h]
  bool oldZero; // [esp+2Dh] [ebp-67h]
  bool hasDecimalPoint; // [esp+2Eh] [ebp-66h]
  __int64 tail_len; // [esp+30h] [ebp-64h]
  __int32 num_len; // [esp+38h] [ebp-5Ch]
  __int32 num_lena; // [esp+38h] [ebp-5Ch]
  __int32 num_lenb; // [esp+38h] [ebp-5Ch]
  unsigned __int32 num_cap; // [esp+3Ch] [ebp-58h]
  __int32 num_capb; // [esp+3Ch] [ebp-58h]
  __int32 num_capa; // [esp+3Ch] [ebp-58h]
  __int32 digits; // [esp+44h] [ebp-50h]
  __int32 digitsa; // [esp+44h] [ebp-50h]
  unsigned __int32 v69; // [esp+50h] [ebp-44h]
  __int32 v70; // [esp+50h] [ebp-44h]
  uint8 tailBuf[5]; // [esp+57h] [ebp-3Dh] BYREF
  fmt_fmt *v72; // [esp+5Ch] [ebp-38h]
  unsigned __int32 v73; // [esp+64h] [ebp-30h]
  int v74; // [esp+6Ch] [ebp-28h]
  uint8 *tail_ptr; // [esp+74h] [ebp-20h]
  uint8 *p_ptr; // [esp+78h] [ebp-1Ch]
  uint8 *num_ptr; // [esp+7Ch] [ebp-18h]
  fmt_buffer *b; // [esp+80h] [ebp-14h] BYREF
  fmt_buffer *b_0; // [esp+84h] [ebp-10h]
  uint8 *v80; // [esp+88h] [ebp-Ch]
  uintptr src; // [esp+8Ch] [ebp-8h]
  int v82; // [esp+90h] [ebp-4h]

  while ( (unsigned int)&b <= *(_DWORD *)(*(_DWORD *)(__readgsdword(0) - 4) + 8) )
    runtime_morestack_noctxt();
  if ( f->fmtFlags.precPresent )
    v5 = f->prec;
  else
    v5 = prec;
  digits = v5;
  dst.array = f->intbuf;
  *(_QWORD *)&dst.len = 0x4400000001LL;
  appended = strconv_AppendFloat(dst, v, verb, v5, size);
  cap = appended.cap;
  len = appended.len;
  if ( appended.len <= 1u )
    runtime_panicindex();
  v8 = appended.array[1];
  array = appended.array + 1;
  if ( v8 == 45 || v8 == 43 )
  {
    len = appended.len - 1;
    cap = appended.cap - 1;
  }
  else
  {
    *appended.array = 43;
    array = appended.array;
  }
  if ( f->fmtFlags.space )
  {
    if ( !len )
      runtime_panicindex();
    if ( *array == 43 && !f->fmtFlags.plus )
      *array = 32;
  }
  if ( len <= 1 )
    runtime_panicindex();
  v10 = array[1];
  if ( v10 == 73 || v10 == 78 )
  {
    oldZero = f->fmtFlags.zero;
    f->fmtFlags.zero = 0;
    if ( array[1] == 78 && !f->fmtFlags.space && !f->fmtFlags.plus )
    {
      --len;
      --cap;
      ++array;
    }
    dst_4h.array = array;
    *(_QWORD *)&dst_4h.len = __PAIR64__(cap, len);
    fmt___ptr_fmt__pad(f, dst_4h);
    f->fmtFlags.zero = oldZero;
  }
  else
  {
    if ( f->fmtFlags.sharp )
    {
      if ( verb == 98 )
      {
        v24 = len;
        v23 = cap;
        v22 = array;
      }
      else
      {
        if ( verb == 71 || verb == 103 || verb == 118 )
        {
          v11 = digits;
          if ( digits == -1 )
            v11 = 6;
        }
        else
        {
          v11 = 0;
        }
        num_ptr = array;
        num_cap = cap;
        memset(tailBuf, 0, sizeof(tailBuf));
        v12 = 1;
        v13 = 0;
        v74 = cap;
        tail_len = 0x500000000LL;
        v73 = len;
        tail_ptr = tailBuf;
        v72 = f;
        while ( 1 )
        {
          digitsa = v11;
          if ( (int)v12 >= (int)len )
            break;
          if ( v12 >= len )
            runtime_panicindex();
          v14 = array[v12];
          if ( v14 == 46 )
          {
            v15 = 1;
            v16 = tail_ptr;
          }
          else if ( v14 == 69 || v14 == 101 )
          {
            hasDecimalPoint = v13;
            v17 = len - v12 + tail_len;
            v69 = v17;
            v18 = (int)&array[v12 & ((int)(v12 - cap) >> 31)];
            v19 = HIDWORD(tail_len);
            if ( v17 > HIDWORD(tail_len) )
            {
              v82 = v18;
              dst_4.array = tail_ptr;
              *(_QWORD *)&dst_4.len = tail_len;
              fmta = runtime_growslice((runtime__type_0 *)&i, (runtime_slice_0)dst_4, v17);
              v19 = fmta.cap;
              tail_ptr = (uint8 *)fmta.array;
            }
            if ( v17 > v19 )
              runtime_panicslice();
            HIDWORD(tail_len) = v19;
            runtime_memmove();
            if ( v12 > num_cap )
              runtime_panicslice();
            cap = num_cap;
            array = num_ptr;
            len = v12;
            v11 = digitsa;
            v16 = tail_ptr;
            LODWORD(tail_len) = v69;
            v15 = hasDecimalPoint;
          }
          else
          {
            --v11;
            v15 = v13;
            v16 = tail_ptr;
          }
          ++v12;
          tail_ptr = v16;
          v13 = v15;
        }
        if ( !(_BYTE)v13 )
        {
          v40 = len + 1;
          if ( (int)(len + 1) > cap )
          {
            num_lenb = len;
            dst_4g.array = array;
            *(_QWORD *)&dst_4g.len = __PAIR64__(cap, len);
            fmte = runtime_growslice((runtime__type_0 *)&i, (runtime_slice_0)dst_4g, len + 1);
            array = (uint8 *)fmte.array;
            v40 = fmte.len + 1;
            cap = fmte.cap;
            len = num_lenb;
          }
          array[len] = 46;
          len = v40;
        }
        while ( 1 )
        {
          num_len = len;
          if ( v11 <= 0 )
            break;
          v20 = len + 1;
          if ( (int)(len + 1) > cap )
          {
            dst_4a.array = array;
            *(_QWORD *)&dst_4a.len = __PAIR64__(cap, len);
            fmtb = runtime_growslice((runtime__type_0 *)&i, (runtime_slice_0)dst_4a, len + 1);
            array = (uint8 *)fmtb.array;
            v20 = fmtb.len + 1;
            cap = fmtb.cap;
            len = num_len;
          }
          array[len] = 48;
          --v11;
          len = v20;
        }
        v21 = tail_len + len;
        v70 = tail_len + len;
        if ( (unsigned int)tail_len + len > cap )
        {
          dst_4b.array = array;
          *(_QWORD *)&dst_4b.len = __PAIR64__(cap, len);
          fmtc = runtime_growslice((runtime__type_0 *)&i, (runtime_slice_0)dst_4b, (unsigned int)tail_len + len);
          array = (uint8 *)fmtc.array;
          cap = fmtc.cap;
          v21 = v70;
        }
        if ( v21 > cap )
          runtime_panicslice();
        num_capb = cap;
        num_ptr = array;
        runtime_memmove();
        v22 = num_ptr;
        v23 = num_capb;
        v24 = v70;
      }
    }
    else
    {
      v24 = len;
      v23 = cap;
      v22 = array;
    }
    v25 = f;
    if ( f->fmtFlags.plus )
      goto LABEL_47;
    if ( !v24 )
      runtime_panicindex();
    if ( *v22 != 43 )
    {
LABEL_47:
      if ( f->fmtFlags.zero && f->fmtFlags.widPresent && f->wid > v24 )
      {
        buf = f->buf;
        if ( !v24 )
          runtime_panicindex();
        num_ptr = v22;
        num_capa = v23;
        num_lena = v24;
        v27 = *v22;
        v28 = buf->cap;
        v29 = buf->len;
        v30 = buf->array;
        if ( v29 + 1 > v28 )
        {
          b = buf;
          dst_4d.array = v30;
          *(_QWORD *)&dst_4d.len = __PAIR64__(v28, v29);
          fmt = runtime_growslice((runtime__type_0 *)&i, (runtime_slice_0)dst_4d, v29 + 1);
          v36 = (uint8 *)fmt.array;
          v37 = fmt.len;
          v38 = (uintptr *)b;
          b->cap = fmt.cap;
          if ( *(_DWORD *)&runtime_writeBarrier.enabled )
          {
            v80 = (uint8 *)fmt.array;
            runtime_writebarrierptr(v38, (uintptr)fmt.array);
            v36 = v80;
            v37 = fmt.len;
            v38 = (uintptr *)b;
          }
          else
          {
            *v38 = (uintptr)fmt.array;
          }
          buf = (fmt_buffer *)v38;
          v25 = f;
          v39 = v36;
          v29 = v37;
          v30 = v39;
        }
        buf->len = v29 + 1;
        v30[v29] = v27;
        fmt___ptr_fmt__writePadding(v25, v25->wid - num_lena);
        b_0 = f->buf;
        v31 = b_0->len;
        v32 = num_lena + v31 - 1;
        v33 = b_0->cap;
        v34 = b_0->array;
        if ( v32 > v33 )
        {
          p_ptr = &num_ptr[((1 - num_capa) >> 31) & 1];
          dst_4c.array = v34;
          *(_QWORD *)&dst_4c.len = __PAIR64__(v33, v31);
          fmtd = runtime_growslice((runtime__type_0 *)&i, (runtime_slice_0)dst_4c, num_lena + v31 - 1);
          v34 = (uint8 *)fmtd.array;
          v33 = fmtd.cap;
        }
        if ( v32 > v33 )
          runtime_panicslice();
        src = (uintptr)v34;
        runtime_memmove();
        v35 = (uintptr *)b_0;
        b_0->len = v32;
        v35[2] = v33;
        if ( *(_DWORD *)&runtime_writeBarrier.enabled )
          runtime_writebarrierptr(v35, src);
        else
          *v35 = src;
      }
      else
      {
        dst_4e.array = v22;
        *(_QWORD *)&dst_4e.len = __PAIR64__(v23, v24);
        fmt___ptr_fmt__pad(f, dst_4e);
      }
    }
    else
    {
      dst_4f.array = &v22[((1 - v23) >> 31) & 1];
      dst_4f.len = v24 - 1;
      dst_4f.cap = v23 - 1;
      fmt___ptr_fmt__pad(f, dst_4f);
    }
  }
}

//----- (080B6F30) --------------------------------------------------------
void __golang fmt___ptr_buffer__WriteRune(fmt_buffer *bp_0, int32 r)
{
  int32 v2; // eax
  __int32 v3; // edx
  __int32 v4; // ebx
  char *v5; // ebp
  unsigned __int32 v6; // esi
  unsigned int v7; // edi
  __int32 v8; // edi
  unsigned __int32 v9; // eax
  fmt_buffer *v10; // ecx
  uint8 *array; // edx
  __int32 cap; // ebx
  __int32 len; // ebp
  __int32 v14; // ecx
  fmt_buffer *v15; // ebx
  __uint8 et; // [esp+0h] [ebp-34h]
  runtime_slice_0 old; // [esp+4h] [ebp-30h]
  runtime_slice_0 olda; // [esp+4h] [ebp-30h]
  runtime_slice_0 srca; // [esp+14h] [ebp-20h]
  runtime_slice_0 src; // [esp+14h] [ebp-20h]
  __int32 b_len; // [esp+20h] [ebp-14h]
  unsigned __int32 b_cap; // [esp+24h] [ebp-10h]

  v2 = r;
  if ( r < 128 )
  {
    v10 = bp_0;
    array = bp_0->array;
    cap = bp_0->cap;
    len = bp_0->len;
    if ( len + 1 > cap )
    {
      olda.array = bp_0->array;
      *(_QWORD *)&olda.len = __PAIR64__(cap, len);
      src = runtime_growslice((runtime__type_0 *)&i, olda, len + 1);
      v2 = (int32)src.array;
      v14 = src.len;
      v15 = bp_0;
      bp_0->cap = src.cap;
      if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      {
        runtime_writebarrierptr((uintptr *)bp_0, (uintptr)src.array);
        v2 = (int32)src.array;
        v14 = src.len;
        v15 = bp_0;
      }
      else
      {
        bp_0->array = (uint8 *)src.array;
      }
      len = v14;
      array = (uint8 *)v2;
      LOBYTE(v2) = r;
      v10 = v15;
    }
    v10->len = len + 1;
    array[len] = v2;
  }
  else
  {
    v3 = bp_0->cap;
    v4 = bp_0->len;
    b_len = v4;
    v5 = (char *)bp_0->array;
    v6 = v4;
    while ( 1 )
    {
      v7 = v6 + 4;
      if ( (int)(v6 + 4) <= v3 )
        break;
      v8 = v4 + 1;
      if ( v4 + 1 > v3 )
      {
        old.array = v5;
        *(_QWORD *)&old.len = __PAIR64__(v3, v4);
        srca = runtime_growslice((runtime__type_0 *)&i, old, v4 + 1);
        v5 = (char *)srca.array;
        v3 = srca.cap;
        v8 = srca.len + 1;
        v2 = r;
        v6 = b_len;
      }
      v5[v4] = 0;
      v4 = v8;
    }
    if ( v6 > v7 || v7 > v3 )
      runtime_panicslice();
    b_cap = v3;
    et.array = (uint8 *)&v5[v6 & ((int)(v6 - v3) >> 31)];
    et.len = 4;
    et.cap = v3 - v6;
    v9 = b_len + unicode_utf8_EncodeRune(et, v2);
    if ( v9 > b_cap )
      runtime_panicslice();
    bp_0->len = v9;
    bp_0->cap = b_cap;
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr((uintptr *)bp_0, (uintptr)v5);
    else
      bp_0->array = (uint8 *)v5;
  }
}

//----- (080B70F0) --------------------------------------------------------
fmt_pp *__golang fmt_newPrinter()
{
  char *data; // eax
  interface_{} src; // [esp+4h] [ebp-Ch]

  src = sync___ptr_Pool__Get(&fmt_ppFree);
  data = (char *)src.data;
  if ( src._type != &stru_80DC3E0 )
    runtime_panicdottypeE(src._type, (runtime__type_0 *)&stru_80DC3E0, (runtime__type_0 *)&stru_80CECA0);
  *((_WORD *)src.data + 63) = 0;
  if ( *(_DWORD *)&runtime_writeBarrier.enabled )
  {
    runtime_writebarrierptr((uintptr *)src.data + 8, (uintptr)src.data);
    data = (char *)src.data;
  }
  else
  {
    *((_DWORD *)src.data + 8) = src.data;
  }
  *((_DWORD *)data + 9) = 0;
  *(_DWORD *)(data + 37) = 0;
  *(_DWORD *)(data + 41) = 0;
  return (fmt_pp *)data;
}

//----- (080B71A0) --------------------------------------------------------
void __golang fmt___ptr_pp__free(fmt_pp *p)
{
  uintptr *v1; // eax
  interface_{} x; // [esp+4h] [ebp-Ch]
  uintptr *dst; // [esp+Ch] [ebp-4h]

  v1 = (uintptr *)p;
  p->buf.len = 0;
  p->arg._type = 0;
  if ( *(_DWORD *)&runtime_writeBarrier.enabled )
  {
    runtime_writebarrierptr((uintptr *)&p->arg.data, 0);
    v1 = (uintptr *)p;
  }
  else
  {
    p->arg.data = 0;
  }
  v1[7] = 0;
  if ( *(_DWORD *)&runtime_writeBarrier.enabled )
  {
    dst = v1 + 6;
    runtime_writebarrierptr(v1 + 5, 0);
    runtime_writebarrierptr(dst, 0);
    v1 = (uintptr *)p;
  }
  else
  {
    v1[5] = 0;
    v1[6] = 0;
  }
  x._type = (runtime__type_0 *)&stru_80DC3E0;
  x.data = v1;
  sync___ptr_Pool__Put(&fmt_ppFree, x);
}

//----- (080B7280) --------------------------------------------------------
void __golang fmt___ptr_pp__Width(fmt_pp *p, __int32 wid, bool ok)
{
  ;
}

//----- (080B72B0) --------------------------------------------------------
void __golang fmt___ptr_pp__Precision(fmt_pp *p, __int32 prec, bool ok)
{
  ;
}

//----- (080B72E0) --------------------------------------------------------
bool __golang fmt___ptr_pp__Flag(fmt_pp *p, __int32 b)
{
  if ( b <= 35 )
  {
    if ( b == 32 )
      return p->fmt.fmtFlags.space;
    if ( b == 35 )
      return p->fmt.fmtFlags.sharp || p->fmt.fmtFlags.sharpV;
    return 0;
  }
  if ( b != 43 )
  {
    if ( b == 45 )
      return p->fmt.fmtFlags.minus;
    if ( b == 48 )
      return p->fmt.fmtFlags.zero;
    return 0;
  }
  return p->fmt.fmtFlags.plus || p->fmt.fmtFlags.plusV;
}

//----- (080B7390) --------------------------------------------------------
void __golang fmt___ptr_pp__Write(fmt_pp *p, __uint8 b, __int32 ret, error_0 err)
{
  __int32 len; // ecx
  unsigned __int32 v5; // ebx
  unsigned int cap; // ebp
  uint8 *array; // esi
  runtime_slice_0 src; // [esp+4h] [ebp-28h]
  runtime_slice_0 v9; // [esp+14h] [ebp-18h]
  __int32 v10; // [esp+24h] [ebp-8h]

  len = p->buf.len;
  v5 = len + b.len;
  v10 = len + b.len;
  cap = p->buf.cap;
  array = p->buf.array;
  if ( len + b.len > cap )
  {
    src.array = p->buf.array;
    *(_QWORD *)&src.len = __PAIR64__(cap, len);
    v9 = runtime_growslice((runtime__type_0 *)&i, src, len + b.len);
    array = (uint8 *)v9.array;
    cap = v9.cap;
    v5 = v10;
  }
  if ( v5 > cap )
    runtime_panicslice();
  runtime_memmove();
  p->buf.len = v10;
  p->buf.cap = cap;
  if ( *(_DWORD *)&runtime_writeBarrier.enabled )
    runtime_writebarrierptr((uintptr *)p, (uintptr)array);
  else
    p->buf.array = array;
}

//----- (080B7490) --------------------------------------------------------
void __golang fmt_Fprintln(io_Writer_0 w, __interface_{} a, __int32 n, error_0 err)
{
  fmt_pp *p; // [esp+20h] [ebp-Ch]

  p = fmt_newPrinter();
  fmt___ptr_pp__doPrintln(p, a);
  ((void (__golang *)(void *, uint8 *, __int32, __int32))w.tab->fun[0])(w.data, p->buf.array, p->buf.len, p->buf.cap);
  fmt___ptr_pp__free(p);
}
// 80B7490: could not find valid save-restore pair for ebx

//----- (080B7550) --------------------------------------------------------
void __golang fmt_Println(__interface_{} a, __int32 n, error_0 err)
{
  io_Writer_0 w; // [esp+0h] [ebp-20h]
  __int32 v4; // [esp+14h] [ebp-Ch]
  error_0 v5; // [esp+18h] [ebp-8h]

  w.tab = (runtime_itab_0 *)&go_itab__os_File_io_Writer;
  w.data = (void *)os_Stdout;
  fmt_Fprintln(w, a, v4, v5);
}
// 80B7590: variable 'v4' is possibly undefined
// 80B7590: variable 'v5' is possibly undefined

//----- (080B75C0) --------------------------------------------------------
reflect_Value_0 __golang fmt_getField(reflect_Value_0 v, __int32 i)
{
  reflect_rtype *typ; // eax
  void *ptr; // ecx
  reflect_flag flag; // ebx
  reflect_Value_0 v5; // [esp+Ch] [ebp-1Ch]
  reflect_Value_0 v6; // [esp+10h] [ebp-18h]
  reflect_Value_0 _r2; // [esp+3Ch] [ebp+14h]

  v6 = reflect_Value_Field(v, i);
  typ = v6.typ;
  ptr = v6.ptr;
  flag = v6.flag;
  if ( (v6.flag & 0x1F) == 20 )
  {
    if ( reflect_Value_IsNil(v6) )
    {
      typ = v6.typ;
      ptr = v6.ptr;
      flag = v6.flag;
    }
    else
    {
      v5 = reflect_Value_Elem(v6);
      typ = v5.typ;
      ptr = v5.ptr;
      flag = v5.flag;
    }
  }
  _r2.typ = typ;
  _r2.ptr = ptr;
  _r2.flag = flag;
  return _r2;
}
// 80B75C0: could not find valid save-restore pair for ebx

//----- (080B7690) --------------------------------------------------------
void __golang fmt___ptr_pp__unknownType(fmt_pp *p, reflect_Value_0 v)
{
  reflect_flag flag; // eax
  fmt_pp *v3; // ecx
  __int32 v4; // edx
  uint8 *array; // ebx
  __int32 len; // ebp
  __int32 v7; // ebx
  unsigned __int32 cap; // ebp
  unsigned int v9; // esi
  uint8 *v10; // edi
  fmt_pp *v11; // ecx
  reflect_rtype *v12; // eax
  __int32 v13; // edx
  __int32 v14; // ebx
  __int32 v15; // ecx
  fmt_pp *v16; // ebx
  __int32 v17; // edx
  uint8 *v18; // eax
  __int32 v19; // ecx
  __int32 v20; // ecx
  unsigned __int32 v21; // edx
  uint8 *v22; // ebx
  unsigned int v23; // ebp
  reflect_Value_0 v24; // [esp+0h] [ebp-40h]
  reflect_Value_0 v25; // [esp+4h] [ebp-3Ch]
  reflect_Value_0 v26; // [esp+4h] [ebp-3Ch]
  reflect_Value_0 v27; // [esp+4h] [ebp-3Ch]
  reflect_Value_0 v28; // [esp+4h] [ebp-3Ch]
  int v29; // [esp+8h] [ebp-38h]
  reflect_Type_0 v30; // [esp+Ch] [ebp-34h]
  runtime_slice_0 src; // [esp+14h] [ebp-2Ch]
  runtime_slice_0 srcb; // [esp+14h] [ebp-2Ch]
  runtime_slice_0 srca; // [esp+14h] [ebp-2Ch]
  runtime_slice_0 srcc; // [esp+14h] [ebp-2Ch]
  __int32 v35; // [esp+2Ch] [ebp-14h]
  __int32 v36; // [esp+2Ch] [ebp-14h]

  flag = v.flag;
  if ( v.flag )
  {
    v3 = p;
    v4 = p->buf.cap;
    array = p->buf.array;
    len = p->buf.len;
    if ( len + 1 > v4 )
    {
      v27.typ = (reflect_rtype *)p->buf.array;
      *(_QWORD *)&v27.ptr = __PAIR64__(v4, len);
      srca = runtime_growslice((runtime__type_0 *)&i, (runtime_slice_0)v27, len + 1);
      v18 = (uint8 *)srca.array;
      v19 = srca.len;
      p->buf.cap = srca.cap;
      if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      {
        runtime_writebarrierptr((uintptr *)p, (uintptr)srca.array);
        v18 = (uint8 *)srca.array;
        v19 = srca.len;
      }
      else
      {
        p->buf.array = (uint8 *)srca.array;
      }
      len = v19;
      array = v18;
      flag = v.flag;
      v3 = p;
    }
    v3->buf.len = len + 1;
    array[len] = 63;
    v24.typ = v.typ;
    *(_QWORD *)&v24.ptr = __PAIR64__(flag, (unsigned int)v.ptr);
    v30 = reflect_Value_Type(v24);
    ((void (__golang *)(void *))v30.tab[5].hash)(v30.data);
    v7 = p->buf.len;
    cap = v7 + v29;
    v35 = v7 + v29;
    v9 = p->buf.cap;
    v10 = p->buf.array;
    if ( v7 + v29 > v9 )
    {
      v26.typ = (reflect_rtype *)p->buf.array;
      *(_QWORD *)&v26.ptr = __PAIR64__(v9, v7);
      srcb = runtime_growslice((runtime__type_0 *)&i, (runtime_slice_0)v26, cap);
      v9 = srcb.cap;
      v10 = (uint8 *)srcb.array;
      cap = v35;
    }
    if ( cap > v9 )
      runtime_panicslice();
    runtime_memmove();
    v11 = p;
    p->buf.len = v35;
    p->buf.cap = v9;
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
    {
      runtime_writebarrierptr((uintptr *)p, (uintptr)v10);
      v12 = (reflect_rtype *)v10;
      v11 = p;
    }
    else
    {
      v12 = (reflect_rtype *)v10;
      p->buf.array = v10;
    }
    v13 = v11->buf.cap;
    v14 = v11->buf.len;
    if ( v14 + 1 > v13 )
    {
      v25.typ = v12;
      *(_QWORD *)&v25.ptr = __PAIR64__(v13, v14);
      src = runtime_growslice((runtime__type_0 *)&i, (runtime_slice_0)v25, v14 + 1);
      v12 = (reflect_rtype *)src.array;
      v15 = src.len;
      v16 = p;
      p->buf.cap = src.cap;
      if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      {
        runtime_writebarrierptr((uintptr *)p, (uintptr)src.array);
        v12 = (reflect_rtype *)src.array;
        v15 = src.len;
        v16 = p;
      }
      else
      {
        p->buf.array = (uint8 *)src.array;
      }
      v17 = v15;
      v11 = v16;
      v14 = v17;
    }
    v11->buf.len = v14 + 1;
    *((_BYTE *)&v12->size + v14) = 63;
  }
  else
  {
    v20 = p->buf.len;
    v21 = v20 + 5;
    v36 = v20 + 5;
    v22 = p->buf.array;
    v23 = p->buf.cap;
    if ( v20 + 5 > v23 )
    {
      v28.typ = (reflect_rtype *)p->buf.array;
      *(_QWORD *)&v28.ptr = __PAIR64__(v23, v20);
      srcc = runtime_growslice((runtime__type_0 *)&i, (runtime_slice_0)v28, v20 + 5);
      v23 = srcc.cap;
      v22 = (uint8 *)srcc.array;
      v21 = v36;
    }
    if ( v21 > v23 )
      runtime_panicslice();
    runtime_memmove();
    p->buf.len = v36;
    p->buf.cap = v23;
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr((uintptr *)p, (uintptr)v22);
    else
      p->buf.array = v22;
  }
}
// 80B7710: variable 'v29' is possibly undefined

//----- (080B79A0) --------------------------------------------------------
void __golang fmt___ptr_pp__badVerb(fmt_pp *p, int32 verb)
{
  __int64 v2; // rcx
  unsigned __int32 v3; // edx
  uint8 *array; // ebp
  fmt_pp *v6; // eax
  __int32 v7; // ecx
  __int32 len; // edx
  uint8 *v9; // ebx
  __int32 v10; // ebx
  unsigned __int32 cap; // ebp
  unsigned int v12; // esi
  uint8 *v13; // edi
  fmt_pp *v14; // ecx
  void *v15; // eax
  __int32 v16; // edx
  __int32 v17; // ebx
  fmt_pp *v18; // eax
  __int32 v19; // ecx
  __int32 v20; // edx
  uint8 *v21; // ebx
  uint8 *v22; // eax
  __int32 v23; // ecx
  fmt_pp *v24; // ebx
  uint8 *v25; // ebp
  __int32 v26; // ecx
  fmt_pp *v27; // ebx
  __int64 v28; // rcx
  unsigned __int32 v29; // edx
  uint8 *v30; // ebp
  __int32 v31; // ebx
  unsigned __int32 v32; // ebp
  uint8 *v33; // esi
  unsigned int v34; // edi
  fmt_pp *v35; // ecx
  void *v36; // eax
  __int32 v37; // edx
  __int32 v38; // ebx
  __int32 v39; // ecx
  fmt_pp *v40; // ebx
  uint8 *v41; // eax
  __int32 v42; // ecx
  runtime_slice_0 ra; // [esp+4h] [ebp-60h]
  runtime_slice_0 rb; // [esp+4h] [ebp-60h]
  runtime_slice_0 r; // [esp+4h] [ebp-60h]
  runtime_slice_0 rd; // [esp+4h] [ebp-60h]
  runtime_slice_0 rc; // [esp+4h] [ebp-60h]
  runtime_slice_0 re; // [esp+4h] [ebp-60h]
  int v49; // [esp+8h] [ebp-5Ch]
  int v50; // [esp+8h] [ebp-5Ch]
  reflect_Type_0 v51; // [esp+Ch] [ebp-58h]
  runtime_slice_0 src; // [esp+14h] [ebp-50h]
  runtime_slice_0 srca; // [esp+14h] [ebp-50h]
  runtime_slice_0 srce; // [esp+14h] [ebp-50h]
  runtime_slice_0 srcf; // [esp+14h] [ebp-50h]
  runtime_slice_0 srcb; // [esp+14h] [ebp-50h]
  runtime_slice_0 srcg; // [esp+14h] [ebp-50h]
  runtime_slice_0 srcc; // [esp+14h] [ebp-50h]
  runtime_slice_0 srcd; // [esp+14h] [ebp-50h]
  __int32 v60; // [esp+38h] [ebp-2Ch]
  __int32 v61; // [esp+38h] [ebp-2Ch]
  __int32 v62; // [esp+38h] [ebp-2Ch]
  __int32 v63; // [esp+38h] [ebp-2Ch]

  p->erroring = 1;
  v2 = *(_QWORD *)&p->buf.len;
  v3 = v2 + 2;
  v60 = v2 + 2;
  array = p->buf.array;
  if ( (unsigned int)(v2 + 2) > HIDWORD(v2) )
  {
    srcd = runtime_growslice((runtime__type_0 *)&i, (runtime_slice_0)p->buf, (int)v2 + 2);
    HIDWORD(v2) = srcd.cap;
    array = (uint8 *)srcd.array;
    v3 = v60;
  }
  if ( v3 > HIDWORD(v2) )
    runtime_panicslice();
  v49 = 2;
  runtime_memmove();
  LODWORD(v2) = p;
  p->buf.len = v60;
  p->buf.cap = HIDWORD(v2);
  if ( *(_DWORD *)&runtime_writeBarrier.enabled )
    runtime_writebarrierptr((uintptr *)p, (uintptr)array);
  else
    p->buf.array = array;
  fmt___ptr_buffer__WriteRune(&p->buf, verb);
  v6 = p;
  v7 = p->buf.cap;
  len = p->buf.len;
  v9 = p->buf.array;
  if ( len + 1 > v7 )
  {
    re.array = p->buf.array;
    *(_QWORD *)&re.len = __PAIR64__(v7, len);
    srcc = runtime_growslice((runtime__type_0 *)&i, re, len + 1);
    v41 = (uint8 *)srcc.array;
    v42 = srcc.len;
    p->buf.cap = srcc.cap;
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
    {
      runtime_writebarrierptr((uintptr *)p, (uintptr)srcc.array);
      v41 = (uint8 *)srcc.array;
      v42 = srcc.len;
    }
    else
    {
      p->buf.array = (uint8 *)srcc.array;
    }
    len = v42;
    v9 = v41;
    v6 = p;
  }
  v6->buf.len = len + 1;
  v9[len] = 40;
  if ( v6->arg._type )
  {
    (*((void (__golang **)(runtime__type_0 *))&go_itab__reflect_rtype_reflect_Type + 33))(v6->arg._type);
    v10 = p->buf.len;
    cap = v49 + v10;
    v61 = v49 + v10;
    v12 = p->buf.cap;
    v13 = p->buf.array;
    if ( v49 + v10 > v12 )
    {
      r.array = p->buf.array;
      *(_QWORD *)&r.len = __PAIR64__(v12, v10);
      srce = runtime_growslice((runtime__type_0 *)&i, r, cap);
      v12 = srce.cap;
      v13 = (uint8 *)srce.array;
      cap = v61;
    }
    if ( cap > v12 )
      runtime_panicslice();
    runtime_memmove();
    v14 = p;
    p->buf.len = v61;
    p->buf.cap = v12;
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
    {
      runtime_writebarrierptr((uintptr *)p, (uintptr)v13);
      v15 = v13;
      v14 = p;
    }
    else
    {
      v15 = v13;
      p->buf.array = v13;
    }
    v16 = v14->buf.len;
    v17 = v14->buf.cap;
    if ( v16 + 1 > v17 )
    {
      rb.array = v15;
      *(_QWORD *)&rb.len = __PAIR64__(v17, v16);
      srca = runtime_growslice((runtime__type_0 *)&i, rb, v16 + 1);
      v15 = srca.array;
      v26 = srca.len;
      v27 = p;
      p->buf.cap = srca.cap;
      if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      {
        runtime_writebarrierptr((uintptr *)p, (uintptr)srca.array);
        v15 = srca.array;
        v26 = srca.len;
        v27 = p;
      }
      else
      {
        p->buf.array = (uint8 *)srca.array;
      }
      v16 = v26;
      v14 = v27;
    }
    v14->buf.len = v16 + 1;
    *((_BYTE *)v15 + v16) = 61;
    fmt___ptr_pp__printArg(v14, v14->arg, 118);
  }
  else if ( v6->value.flag )
  {
    v51 = reflect_Value_Type(v6->value);
    ((void (__golang *)(void *))v51.tab[5].hash)(v51.data);
    v31 = p->buf.len;
    v32 = v50 + v31;
    v63 = v50 + v31;
    v33 = p->buf.array;
    v34 = p->buf.cap;
    if ( v50 + v31 > v34 )
    {
      rc.array = p->buf.array;
      *(_QWORD *)&rc.len = __PAIR64__(v34, v31);
      srcg = runtime_growslice((runtime__type_0 *)&i, rc, v32);
      v33 = (uint8 *)srcg.array;
      v34 = srcg.cap;
      v32 = v63;
    }
    if ( v32 > v34 )
      runtime_panicslice();
    runtime_memmove();
    v35 = p;
    p->buf.len = v63;
    p->buf.cap = v34;
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
    {
      runtime_writebarrierptr((uintptr *)p, (uintptr)v33);
      v36 = v33;
      v35 = p;
    }
    else
    {
      v36 = v33;
      p->buf.array = v33;
    }
    v37 = v35->buf.len;
    v38 = v35->buf.cap;
    if ( v37 + 1 > v38 )
    {
      rd.array = v36;
      *(_QWORD *)&rd.len = __PAIR64__(v38, v37);
      srcb = runtime_growslice((runtime__type_0 *)&i, rd, v37 + 1);
      v36 = srcb.array;
      v39 = srcb.len;
      v40 = p;
      p->buf.cap = srcb.cap;
      if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      {
        runtime_writebarrierptr((uintptr *)p, (uintptr)srcb.array);
        v36 = srcb.array;
        v39 = srcb.len;
        v40 = p;
      }
      else
      {
        p->buf.array = (uint8 *)srcb.array;
      }
      v37 = v39;
      v35 = v40;
    }
    v35->buf.len = v37 + 1;
    *((_BYTE *)v36 + v37) = 61;
    fmt___ptr_pp__printValue(v35, v35->value, 118, 0);
  }
  else
  {
    v28 = *(_QWORD *)&v6->buf.len;
    v29 = v28 + 5;
    v62 = v28 + 5;
    v30 = v6->buf.array;
    if ( (unsigned int)(v28 + 5) > HIDWORD(v28) )
    {
      srcf = runtime_growslice((runtime__type_0 *)&i, (runtime_slice_0)v6->buf, (int)v28 + 5);
      v30 = (uint8 *)srcf.array;
      HIDWORD(v28) = srcf.cap;
      v29 = v62;
    }
    if ( v29 > HIDWORD(v28) )
      runtime_panicslice();
    runtime_memmove();
    p->buf.len = v62;
    p->buf.cap = HIDWORD(v28);
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr((uintptr *)p, (uintptr)v30);
    else
      p->buf.array = v30;
  }
  v18 = p;
  v19 = p->buf.cap;
  v20 = p->buf.len;
  v21 = p->buf.array;
  if ( v20 + 1 > v19 )
  {
    ra.array = p->buf.array;
    *(_QWORD *)&ra.len = __PAIR64__(v19, v20);
    src = runtime_growslice((runtime__type_0 *)&i, ra, v20 + 1);
    v22 = (uint8 *)src.array;
    v23 = src.len;
    v24 = p;
    p->buf.cap = src.cap;
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
    {
      runtime_writebarrierptr((uintptr *)p, (uintptr)src.array);
      v22 = (uint8 *)src.array;
      v23 = src.len;
      v24 = p;
    }
    else
    {
      p->buf.array = (uint8 *)src.array;
    }
    v20 = v23;
    v25 = v22;
    v18 = v24;
    v21 = v25;
  }
  v18->buf.len = v20 + 1;
  v21[v20] = 41;
  v18->erroring = 0;
}
// 80B7A83: conditional instruction was optimized away because edx.4!=0
// 80B7AA9: variable 'v49' is possibly undefined
// 80B7DA5: variable 'v50' is possibly undefined

//----- (080B8000) --------------------------------------------------------
void __golang fmt___ptr_pp__fmtBool(fmt_pp *p, bool v, int32 verb)
{
  if ( verb == 116 || verb == 118 )
    fmt___ptr_fmt__fmt_boolean(&p->fmt, v);
  else
    fmt___ptr_pp__badVerb(p, verb);
}

//----- (080B8060) --------------------------------------------------------
void __golang fmt___ptr_pp__fmt0x64(fmt_pp *p, uint64 v, bool leading0x)
{
  string digits; // [esp+14h] [ebp-Ch]
  bool sharp; // [esp+1Fh] [ebp-1h]

  sharp = p->fmt.fmtFlags.sharp;
  p->fmt.fmtFlags.sharp = leading0x;
  digits.str = (uint8 *)"0123456789abcdefx";
  digits.len = 17;
  fmt___ptr_fmt__fmt_integer(&p->fmt, v, 16, 0, digits);
  p->fmt.fmtFlags.sharp = sharp;
}

//----- (080B80E0) --------------------------------------------------------
void __golang fmt___ptr_pp__fmtInteger(fmt_pp *p, uint64 v, bool isSigned, int32 verb)
{
  bool v4; // cl
  string digits; // [esp+14h] [ebp-8h]
  string digitsa; // [esp+14h] [ebp-8h]
  string digitsb; // [esp+14h] [ebp-8h]
  string digitsc; // [esp+14h] [ebp-8h]
  string digitsd; // [esp+14h] [ebp-8h]
  string digitse; // [esp+14h] [ebp-8h]

  if ( verb > 99 )
  {
    if ( verb > 111 )
    {
      switch ( verb )
      {
        case 'q':
          if ( (unsigned int)v > 0x10FFFF || HIDWORD(v) != 0 )
            goto LABEL_5;
          fmt___ptr_fmt__fmt_qc(&p->fmt, v);
          break;
        case 'v':
          if ( p->fmt.fmtFlags.sharpV )
          {
            v4 = isSigned;
            if ( !isSigned )
            {
              fmt___ptr_pp__fmt0x64(p, v, 1);
              return;
            }
          }
          else
          {
            v4 = isSigned;
          }
          digitsd.str = (uint8 *)"0123456789abcdefx";
          digitsd.len = 17;
          fmt___ptr_fmt__fmt_integer(&p->fmt, v, 10, v4, digitsd);
          return;
        case 'x':
          digitse.str = (uint8 *)"0123456789abcdefx";
          digitse.len = 17;
          fmt___ptr_fmt__fmt_integer(&p->fmt, v, 16, isSigned, digitse);
          break;
        default:
          goto LABEL_5;
      }
    }
    else if ( verb == 100 )
    {
      digitsc.str = (uint8 *)"0123456789abcdefx";
      digitsc.len = 17;
      fmt___ptr_fmt__fmt_integer(&p->fmt, v, 10, isSigned, digitsc);
    }
    else
    {
      if ( verb != 111 )
        goto LABEL_5;
      digitsb.str = (uint8 *)"0123456789abcdefx";
      digitsb.len = 17;
      fmt___ptr_fmt__fmt_integer(&p->fmt, v, 8, isSigned, digitsb);
    }
  }
  else if ( verb > 88 )
  {
    if ( verb == 98 )
    {
      digitsa.str = (uint8 *)"0123456789abcdefx";
      digitsa.len = 17;
      fmt___ptr_fmt__fmt_integer(&p->fmt, v, 2, isSigned, digitsa);
    }
    else
    {
      if ( verb != 99 )
        goto LABEL_5;
      fmt___ptr_fmt__fmt_c(&p->fmt, v);
    }
  }
  else if ( verb == 85 )
  {
    fmt___ptr_fmt__fmt_unicode(&p->fmt, v);
  }
  else
  {
    if ( verb != 88 )
    {
LABEL_5:
      fmt___ptr_pp__badVerb(p, verb);
      return;
    }
    digits.str = (uint8 *)"0123456789ABCDEFX";
    digits.len = 17;
    fmt___ptr_fmt__fmt_integer(&p->fmt, v, 16, isSigned, digits);
  }
}

//----- (080B8400) --------------------------------------------------------
void __golang fmt___ptr_pp__fmtFloat(fmt_pp *p, float64 v, __int32 size, int32 verb)
{
  if ( verb > 71 )
  {
    if ( verb > 102 )
    {
      if ( verb == 103 )
        goto LABEL_6;
      if ( verb == 118 )
      {
        fmt___ptr_fmt__fmt_float(&p->fmt, v, size, 103, -1);
        return;
      }
    }
    else
    {
      if ( verb == 98 )
        goto LABEL_6;
      if ( (unsigned int)(verb - 101) <= 1 )
        goto LABEL_3;
    }
LABEL_7:
    fmt___ptr_pp__badVerb(p, verb);
    return;
  }
  if ( verb == 69 )
  {
LABEL_3:
    fmt___ptr_fmt__fmt_float(&p->fmt, v, size, verb, 6);
    return;
  }
  if ( verb != 70 )
  {
    if ( verb == 71 )
    {
LABEL_6:
      fmt___ptr_fmt__fmt_float(&p->fmt, v, size, verb, -1);
      return;
    }
    goto LABEL_7;
  }
  fmt___ptr_fmt__fmt_float(&p->fmt, v, size, 102, 6);
}

//----- (080B8560) --------------------------------------------------------
void __golang fmt___ptr_pp__fmtComplex(fmt_pp *p, complex128 v, __int32 size, int32 verb)
{
  int32 v4; // eax
  fmt_pp *v5; // ecx
  __int32 cap; // ebx
  uint8 *array; // ebp
  __int32 len; // esi
  __int64 v9; // rcx
  unsigned __int32 v10; // edx
  uint8 *v11; // ebp
  uint8 *v13; // eax
  __int32 v14; // ecx
  fmt_pp *v15; // ebx
  runtime_slice_0 v16; // [esp+4h] [ebp-30h]
  runtime_slice_0 v17; // [esp+14h] [ebp-20h]
  runtime_slice_0 v18; // [esp+14h] [ebp-20h]
  bool oldPlus; // [esp+23h] [ebp-11h]
  __int32 v20; // [esp+28h] [ebp-Ch]

  v4 = verb;
  if ( verb > 98 )
  {
    if ( (unsigned int)(verb - 101) > 2 && verb != 118 )
      goto LABEL_16;
  }
  else if ( (unsigned int)(verb - 69) > 2 && verb != 98 )
  {
LABEL_16:
    fmt___ptr_pp__badVerb(p, verb);
    return;
  }
  v5 = p;
  oldPlus = p->fmt.fmtFlags.plus;
  cap = p->buf.cap;
  array = p->buf.array;
  len = p->buf.len;
  if ( len + 1 > cap )
  {
    v16.array = p->buf.array;
    *(_QWORD *)&v16.len = __PAIR64__(cap, len);
    v18 = runtime_growslice((runtime__type_0 *)&i, v16, len + 1);
    v13 = (uint8 *)v18.array;
    v14 = v18.len;
    v15 = p;
    p->buf.cap = v18.cap;
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
    {
      runtime_writebarrierptr((uintptr *)p, (uintptr)v18.array);
      v13 = (uint8 *)v18.array;
      v14 = v18.len;
      v15 = p;
    }
    else
    {
      p->buf.array = (uint8 *)v18.array;
    }
    len = v14;
    array = v13;
    v4 = verb;
    v5 = v15;
  }
  v5->buf.len = len + 1;
  array[len] = 40;
  fmt___ptr_pp__fmtFloat(v5, v.real, size / 2, v4);
  p->fmt.fmtFlags.plus = 1;
  fmt___ptr_pp__fmtFloat(p, v.imag, size / 2, verb);
  v9 = *(_QWORD *)&p->buf.len;
  v10 = v9 + 2;
  v20 = v9 + 2;
  v11 = p->buf.array;
  if ( (unsigned int)(v9 + 2) > HIDWORD(v9) )
  {
    v17 = runtime_growslice((runtime__type_0 *)&i, (runtime_slice_0)p->buf, (int)v9 + 2);
    HIDWORD(v9) = v17.cap;
    v11 = (uint8 *)v17.array;
    v10 = v20;
  }
  if ( v10 > HIDWORD(v9) )
    runtime_panicslice();
  runtime_memmove();
  LODWORD(v9) = p;
  p->buf.len = v20;
  p->buf.cap = HIDWORD(v9);
  if ( *(_DWORD *)&runtime_writeBarrier.enabled )
    runtime_writebarrierptr((uintptr *)p, (uintptr)v11);
  else
    p->buf.array = v11;
  p->fmt.fmtFlags.plus = oldPlus;
}

//----- (080B8790) --------------------------------------------------------
void __golang fmt___ptr_pp__fmtString(fmt_pp *p, string v, int32 verb)
{
  string digits; // [esp+Ch] [ebp-8h]
  string digitsa; // [esp+Ch] [ebp-8h]

  if ( verb <= 113 )
  {
    if ( verb == 88 )
    {
      digits.str = (uint8 *)"0123456789ABCDEFX";
      digits.len = 17;
      fmt___ptr_fmt__fmt_sx(&p->fmt, v, digits);
      return;
    }
    if ( verb != 113 )
    {
LABEL_4:
      fmt___ptr_pp__badVerb(p, verb);
      return;
    }
    goto LABEL_10;
  }
  if ( verb == 115 )
    goto LABEL_14;
  if ( verb == 118 )
  {
    if ( p->fmt.fmtFlags.sharpV )
    {
LABEL_10:
      fmt___ptr_fmt__fmt_q(&p->fmt, v);
      return;
    }
LABEL_14:
    fmt___ptr_fmt__fmt_s(&p->fmt, v);
    return;
  }
  if ( verb != 120 )
    goto LABEL_4;
  digitsa.str = (uint8 *)"0123456789abcdefx";
  digitsa.len = 17;
  fmt___ptr_fmt__fmt_sx(&p->fmt, v, digitsa);
}

//----- (080B8900) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
void __golang fmt___ptr_pp__fmtBytes(fmt_pp *p, __uint8 v, int32 verb, string typeString)
{
  fmt_pp *v4; // eax
  __int32 len; // ecx
  unsigned __int32 v6; // ebx
  unsigned int v7; // ebp
  uint8 *array; // esi
  fmt_pp *v9; // ecx
  uint8 *v10; // eax
  uint8 *v11; // edx
  __int32 v12; // ebx
  __int32 v13; // ebp
  __int32 v14; // eax
  __int32 v15; // esi
  unsigned __int32 v16; // edi
  void *v17; // ebx
  unsigned __int32 v18; // eax
  __int32 v19; // eax
  __int32 v20; // edx
  uint8 *v21; // ebx
  uint8 *v22; // eax
  __int32 v23; // ecx
  fmt_pp *v24; // ebx
  __int32 v25; // ecx
  fmt_pp *v26; // ebx
  __int32 v27; // edx
  unsigned __int32 v28; // ebx
  unsigned int v29; // ebp
  __int32 v30; // ecx
  __int32 v31; // edx
  uint8 *v32; // ebx
  __int32 v33; // ecx
  uint8 *v34; // edx
  unsigned int v35; // ebp
  __int32 v36; // esi
  uint8 *v37; // edi
  __int32 v38; // ebx
  uint8 *v39; // eax
  __int32 v40; // ecx
  fmt_pp *v41; // ebx
  __int32 v42; // ecx
  __int32 v43; // edx
  uint8 *v44; // ebx
  uint8 *v45; // eax
  __int32 v46; // ecx
  fmt_pp *v47; // ebx
  uint8 *v48; // ebp
  uint8 *v49; // eax
  __int32 v50; // ecx
  runtime_slice_0 v51; // [esp+4h] [ebp-98h]
  runtime_slice_0 v52; // [esp+4h] [ebp-98h]
  runtime_slice_0 v53; // [esp+4h] [ebp-98h]
  runtime_slice_0 v54; // [esp+4h] [ebp-98h]
  runtime_slice_0 v55; // [esp+4h] [ebp-98h]
  runtime_slice_0 v56; // [esp+4h] [ebp-98h]
  runtime_slice_0 v57; // [esp+4h] [ebp-98h]
  runtime_slice_0 v58; // [esp+4h] [ebp-98h]
  reflect_Value_0 v59; // [esp+4h] [ebp-98h]
  runtime_eface_0 v60; // [esp+8h] [ebp-94h]
  interface_{} v61; // [esp+8h] [ebp-94h]
  string cap; // [esp+10h] [ebp-8Ch]
  string capa; // [esp+10h] [ebp-8Ch]
  string capb; // [esp+10h] [ebp-8Ch]
  string capc; // [esp+10h] [ebp-8Ch]
  string capd; // [esp+10h] [ebp-8Ch]
  runtime_slice_0 v67; // [esp+14h] [ebp-88h]
  runtime_slice_0 v68; // [esp+14h] [ebp-88h]
  runtime_slice_0 v69; // [esp+14h] [ebp-88h]
  runtime_slice_0 v70; // [esp+14h] [ebp-88h]
  runtime_slice_0 v71; // [esp+14h] [ebp-88h]
  string v72; // [esp+14h] [ebp-88h]
  runtime_slice_0 v73; // [esp+14h] [ebp-88h]
  runtime_slice_0 v74; // [esp+14h] [ebp-88h]
  runtime_slice_0 v75; // [esp+14h] [ebp-88h]
  __int32 i; // [esp+20h] [ebp-7Ch]
  __int32 i_0; // [esp+24h] [ebp-78h]
  unsigned int v78; // [esp+30h] [ebp-6Ch]
  unsigned int v79; // [esp+30h] [ebp-6Ch]
  __int32 v80; // [esp+34h] [ebp-68h]
  __int32 v81; // [esp+38h] [ebp-64h]
  __int32 v82; // [esp+38h] [ebp-64h]
  uint8 buf[32]; // [esp+3Ch] [ebp-60h] BYREF
  uint8 v84[32]; // [esp+5Ch] [ebp-40h] BYREF
  void *v85; // [esp+7Ch] [ebp-20h]
  uint8 *v86; // [esp+80h] [ebp-1Ch] BYREF
  uintptr src; // [esp+84h] [ebp-18h]
  uint8 *v88; // [esp+88h] [ebp-14h]
  uint8 *old; // [esp+8Ch] [ebp-10h]
  __uint8 old_4; // [esp+90h] [ebp-Ch] BYREF

  while ( (unsigned int)&v86 <= *(_DWORD *)(*(_DWORD *)(__readgsdword(0) - 4) + 8) )
    runtime_morestack_noctxt();
  if ( verb <= 113 )
  {
    switch ( verb )
    {
      case 'X':
        capb.str = (uint8 *)"0123456789ABCDEFX";
        capb.len = 17;
        fmt___ptr_fmt__fmt_bx(&p->fmt, v, capb);
        return;
      case 'd':
        goto LABEL_5;
      case 'q':
        runtime_slicebytetostring((uint8 (*)[32])buf, v, cap);
        fmt___ptr_fmt__fmt_q(&p->fmt, capa);
        return;
    }
LABEL_62:
    old_4 = v;
    runtime_convT2Eslice((runtime__type_0 *)&stru_80CA1C0, &old_4, v60);
    v59 = reflect_ValueOf(v61);
    fmt___ptr_pp__printValue(p, v59, verb, 0);
    return;
  }
  if ( verb == 115 )
  {
    runtime_slicebytetostring((uint8 (*)[32])v84, v, cap);
    fmt___ptr_fmt__fmt_s(&p->fmt, capd);
    return;
  }
  if ( verb != 118 )
  {
    if ( verb == 120 )
    {
      capc.str = (uint8 *)"0123456789abcdefx";
      capc.len = 17;
      fmt___ptr_fmt__fmt_bx(&p->fmt, v, capc);
      return;
    }
    goto LABEL_62;
  }
LABEL_5:
  v4 = p;
  if ( p->fmt.fmtFlags.sharpV )
  {
    len = p->buf.len;
    v6 = len + typeString.len;
    v81 = len + typeString.len;
    v7 = p->buf.cap;
    array = p->buf.array;
    if ( len + typeString.len > v7 )
    {
      v55.array = p->buf.array;
      *(_QWORD *)&v55.len = __PAIR64__(v7, len);
      v71 = runtime_growslice((runtime__type_0 *)&::i, v55, len + typeString.len);
      v7 = v71.cap;
      array = (uint8 *)v71.array;
      v6 = v81;
    }
    if ( v6 > v7 )
      runtime_panicslice();
    old = array;
    runtime_memmove();
    v9 = p;
    p->buf.len = v81;
    p->buf.cap = v7;
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
    {
      runtime_writebarrierptr((uintptr *)p, (uintptr)old);
      v10 = old;
      v9 = p;
    }
    else
    {
      v10 = old;
      p->buf.array = old;
    }
    v11 = v.array;
    if ( v.array )
    {
      v12 = v9->buf.cap;
      v13 = v9->buf.len;
      if ( v13 + 1 > v12 )
      {
        v53.array = v10;
        *(_QWORD *)&v53.len = __PAIR64__(v12, v13);
        v69 = runtime_growslice((runtime__type_0 *)&::i, v53, v13 + 1);
        v10 = (uint8 *)v69.array;
        v25 = v69.len;
        v26 = p;
        p->buf.cap = v69.cap;
        if ( *(_DWORD *)&runtime_writeBarrier.enabled )
        {
          v85 = v69.array;
          runtime_writebarrierptr((uintptr *)p, (uintptr)v69.array);
          v10 = (uint8 *)v69.array;
          v25 = v69.len;
          v26 = p;
        }
        else
        {
          p->buf.array = (uint8 *)v69.array;
        }
        v11 = v.array;
        v13 = v25;
        v9 = v26;
      }
      v9->buf.len = v13 + 1;
      v10[v13] = 123;
      v14 = 0;
      while ( v14 < v.len )
      {
        i = v14;
        v88 = v11;
        v78 = *v11;
        if ( v14 > 0 )
        {
          v15 = v9->buf.len;
          v16 = v15 + 2;
          v17 = v9->buf.array;
          v18 = v9->buf.cap;
          if ( v15 + 2 > v18 )
          {
            v51.array = v9->buf.array;
            *(_QWORD *)&v51.len = __PAIR64__(v18, v15);
            v67 = runtime_growslice((runtime__type_0 *)&::i, v51, v15 + 2);
            v17 = v67.array;
            v18 = v67.cap;
            v16 = v15 + 2;
          }
          if ( v16 > v18 )
            runtime_panicslice();
          src = (uintptr)v17;
          v80 = v18;
          runtime_memmove();
          v9 = p;
          p->buf.len = v15 + 2;
          p->buf.cap = v80;
          if ( *(_DWORD *)&runtime_writeBarrier.enabled )
          {
            runtime_writebarrierptr((uintptr *)p, src);
            v9 = p;
          }
          else
          {
            p->buf.array = (uint8 *)src;
          }
        }
        fmt___ptr_pp__fmt0x64(v9, v78, 1);
        v11 = v88 + 1;
        v14 = i + 1;
        v9 = p;
      }
      v19 = v9->buf.cap;
      v20 = v9->buf.len;
      v21 = v9->buf.array;
      if ( v20 + 1 > v19 )
      {
        v52.array = v9->buf.array;
        *(_QWORD *)&v52.len = __PAIR64__(v19, v20);
        v68 = runtime_growslice((runtime__type_0 *)&::i, v52, v20 + 1);
        v22 = (uint8 *)v68.array;
        v23 = v68.len;
        v24 = p;
        p->buf.cap = v68.cap;
        if ( *(_DWORD *)&runtime_writeBarrier.enabled )
        {
          v86 = (uint8 *)v68.array;
          runtime_writebarrierptr((uintptr *)p, (uintptr)v68.array);
          v22 = v86;
          v23 = v68.len;
          v24 = p;
        }
        else
        {
          p->buf.array = (uint8 *)v68.array;
        }
        v20 = v23;
        v9 = v24;
        v21 = v22;
      }
      v9->buf.len = v20 + 1;
      v21[v20] = 125;
    }
    else
    {
      v27 = v9->buf.len;
      v28 = v27 + 5;
      v82 = v27 + 5;
      v29 = v9->buf.cap;
      if ( v27 + 5 > v29 )
      {
        v54.array = v10;
        *(_QWORD *)&v54.len = __PAIR64__(v29, v27);
        v70 = runtime_growslice((runtime__type_0 *)&::i, v54, v27 + 5);
        v10 = (uint8 *)v70.array;
        v29 = v70.cap;
        v28 = v82;
      }
      if ( v28 > v29 )
        runtime_panicslice();
      old = v10;
      runtime_memmove();
      p->buf.len = v82;
      p->buf.cap = v29;
      if ( *(_DWORD *)&runtime_writeBarrier.enabled )
        runtime_writebarrierptr((uintptr *)p, (uintptr)old);
      else
        p->buf.array = old;
    }
  }
  else
  {
    v30 = p->buf.cap;
    v31 = p->buf.len;
    v32 = p->buf.array;
    if ( v31 + 1 > v30 )
    {
      v58.array = p->buf.array;
      *(_QWORD *)&v58.len = __PAIR64__(v30, v31);
      v75 = runtime_growslice((runtime__type_0 *)&::i, v58, v31 + 1);
      v49 = (uint8 *)v75.array;
      v50 = v75.len;
      p->buf.cap = v75.cap;
      if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      {
        v88 = (uint8 *)v75.array;
        runtime_writebarrierptr((uintptr *)p, (uintptr)v75.array);
        v49 = v88;
        v50 = v75.len;
      }
      else
      {
        p->buf.array = (uint8 *)v75.array;
      }
      v31 = v50;
      v32 = v49;
      v4 = p;
    }
    v4->buf.len = v31 + 1;
    v32[v31] = 91;
    v33 = 0;
    v34 = v.array;
    while ( v33 < v.len )
    {
      i_0 = v33;
      v88 = v34;
      v35 = *v34;
      if ( v33 > 0 )
      {
        v36 = v4->buf.len;
        v37 = v4->buf.array;
        v38 = v4->buf.cap;
        if ( v36 + 1 > v38 )
        {
          v79 = *v34;
          v56.array = v4->buf.array;
          *(_QWORD *)&v56.len = __PAIR64__(v38, v36);
          v73 = runtime_growslice((runtime__type_0 *)&::i, v56, v36 + 1);
          v39 = (uint8 *)v73.array;
          v40 = v73.len;
          v41 = p;
          p->buf.cap = v73.cap;
          if ( *(_DWORD *)&runtime_writeBarrier.enabled )
          {
            v86 = (uint8 *)v73.array;
            runtime_writebarrierptr((uintptr *)p, (uintptr)v73.array);
            v39 = v86;
            v40 = v73.len;
            v41 = p;
          }
          else
          {
            p->buf.array = (uint8 *)v73.array;
          }
          v35 = v79;
          v36 = v40;
          v37 = v39;
          v4 = v41;
        }
        v4->buf.len = v36 + 1;
        v37[v36] = 32;
      }
      v72.str = (uint8 *)"0123456789abcdefx";
      v72.len = 17;
      fmt___ptr_fmt__fmt_integer(&v4->fmt, v35, 10, 0, v72);
      v34 = v88 + 1;
      v33 = i_0 + 1;
      v4 = p;
    }
    v42 = v4->buf.cap;
    v43 = v4->buf.len;
    v44 = v4->buf.array;
    if ( v43 + 1 > v42 )
    {
      v57.array = v4->buf.array;
      *(_QWORD *)&v57.len = __PAIR64__(v42, v43);
      v74 = runtime_growslice((runtime__type_0 *)&::i, v57, v43 + 1);
      v45 = (uint8 *)v74.array;
      v46 = v74.len;
      v47 = p;
      p->buf.cap = v74.cap;
      if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      {
        runtime_writebarrierptr((uintptr *)p, (uintptr)v74.array);
        v45 = (uint8 *)v74.array;
        v46 = v74.len;
        v47 = p;
      }
      else
      {
        p->buf.array = (uint8 *)v74.array;
      }
      v43 = v46;
      v48 = v45;
      v4 = v47;
      v44 = v48;
    }
    v4->buf.len = v43 + 1;
    v44[v43] = 93;
  }
}
// 80B8FFB: failed to expand linear variable ^8.12

//----- (080B91D0) --------------------------------------------------------
void __golang fmt___ptr_pp__fmtPointer(fmt_pp *p, reflect_Value_0 value, int32 verb)
{
  int v3; // eax
  fmt_pp *v4; // ecx
  __int32 v5; // edx
  __int32 len; // ebx
  uint8 *array; // ebp
  __int32 v8; // ebx
  unsigned __int32 cap; // ebp
  unsigned int v10; // esi
  uint8 *v11; // edi
  fmt_pp *v12; // ecx
  reflect_rtype *v13; // eax
  __int32 v14; // edx
  unsigned __int32 v15; // ebx
  unsigned int v16; // ebp
  fmt_pp *v17; // ecx
  reflect_rtype *v18; // eax
  __int32 v19; // edx
  unsigned __int32 v20; // ebx
  unsigned int v21; // ebp
  fmt_pp *v22; // ecx
  __int32 v23; // eax
  __int32 v24; // edx
  uint8 *v25; // ebx
  uint8 *v26; // eax
  __int32 v27; // ecx
  fmt_pp *v28; // ebx
  uint8 *v29; // eax
  __int32 v30; // ecx
  reflect_Value_0 v_4c; // [esp+4h] [ebp-40h]
  reflect_Value_0 v_4b; // [esp+4h] [ebp-40h]
  reflect_Value_0 v_4a; // [esp+4h] [ebp-40h]
  reflect_Value_0 v_4; // [esp+4h] [ebp-40h]
  reflect_Value_0 v_4d; // [esp+4h] [ebp-40h]
  string v_4e; // [esp+4h] [ebp-40h]
  int v_8; // [esp+8h] [ebp-3Ch]
  uintptr isSigned; // [esp+Ch] [ebp-38h]
  reflect_Type_0 isSigneda; // [esp+Ch] [ebp-38h]
  runtime_slice_0 src; // [esp+14h] [ebp-30h]
  runtime_slice_0 srcd; // [esp+14h] [ebp-30h]
  runtime_slice_0 srcc; // [esp+14h] [ebp-30h]
  runtime_slice_0 srcb; // [esp+14h] [ebp-30h]
  runtime_slice_0 srca; // [esp+14h] [ebp-30h]
  uintptr u; // [esp+20h] [ebp-24h]
  __int32 v46; // [esp+30h] [ebp-14h]
  __int32 v47; // [esp+30h] [ebp-14h]
  __int32 v48; // [esp+30h] [ebp-14h]
  uint8 *v49; // [esp+40h] [ebp-4h]
  uint8 *v50; // [esp+40h] [ebp-4h]

  v3 = value.flag & 0x1F;
  if ( (unsigned int)(v3 - 18) > 1 && (unsigned int)(v3 - 21) > 2 && v3 != 26 )
    goto LABEL_52;
  isSigned = reflect_Value_Pointer(value);
  if ( verb <= 100 )
  {
    if ( verb != 88 && verb != 98 && verb != 100 )
      goto LABEL_52;
LABEL_4:
    fmt___ptr_pp__fmtInteger(p, isSigned, 0, verb);
    return;
  }
  if ( verb <= 112 )
  {
    if ( verb == 111 )
      goto LABEL_4;
    if ( verb == 112 )
    {
LABEL_11:
      fmt___ptr_pp__fmt0x64(p, isSigned, !p->fmt.fmtFlags.sharp);
      return;
    }
LABEL_52:
    fmt___ptr_pp__badVerb(p, verb);
    return;
  }
  if ( verb != 118 )
  {
    if ( verb == 120 )
      goto LABEL_4;
    goto LABEL_52;
  }
  v4 = p;
  if ( !p->fmt.fmtFlags.sharpV )
  {
    if ( !isSigned )
    {
      v_4e.str = (uint8 *)"<nil>";
      v_4e.len = 5;
      fmt___ptr_fmt__padString(&p->fmt, v_4e);
      return;
    }
    goto LABEL_11;
  }
  u = isSigned;
  v5 = p->buf.cap;
  len = p->buf.len;
  array = p->buf.array;
  if ( len + 1 > v5 )
  {
    v_4d.typ = (reflect_rtype *)p->buf.array;
    *(_QWORD *)&v_4d.ptr = __PAIR64__(v5, len);
    srca = runtime_growslice((runtime__type_0 *)&i, (runtime_slice_0)v_4d, len + 1);
    v29 = (uint8 *)srca.array;
    v30 = srca.len;
    p->buf.cap = srca.cap;
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
    {
      runtime_writebarrierptr((uintptr *)p, (uintptr)srca.array);
      v29 = (uint8 *)srca.array;
      v30 = srca.len;
    }
    else
    {
      p->buf.array = (uint8 *)srca.array;
    }
    len = v30;
    array = v29;
    v4 = p;
  }
  v4->buf.len = len + 1;
  array[len] = 40;
  isSigneda = reflect_Value_Type(value);
  ((void (__golang *)(void *))isSigneda.tab[5].hash)(isSigneda.data);
  v8 = p->buf.len;
  cap = v8 + v_8;
  v46 = v8 + v_8;
  v10 = p->buf.cap;
  v11 = p->buf.array;
  if ( v8 + v_8 > v10 )
  {
    v_4.typ = (reflect_rtype *)p->buf.array;
    *(_QWORD *)&v_4.ptr = __PAIR64__(v10, v8);
    srcb = runtime_growslice((runtime__type_0 *)&i, (runtime_slice_0)v_4, cap);
    v10 = srcb.cap;
    v11 = (uint8 *)srcb.array;
    cap = v46;
  }
  if ( cap > v10 )
    runtime_panicslice();
  runtime_memmove();
  v12 = p;
  p->buf.len = v46;
  p->buf.cap = v10;
  if ( *(_DWORD *)&runtime_writeBarrier.enabled )
  {
    runtime_writebarrierptr((uintptr *)p, (uintptr)v11);
    v13 = (reflect_rtype *)v11;
    v12 = p;
  }
  else
  {
    v13 = (reflect_rtype *)v11;
    p->buf.array = v11;
  }
  v14 = v12->buf.len;
  v15 = v14 + 2;
  v47 = v14 + 2;
  v16 = v12->buf.cap;
  if ( v14 + 2 > v16 )
  {
    v_4a.typ = v13;
    *(_QWORD *)&v_4a.ptr = __PAIR64__(v16, v14);
    srcc = runtime_growslice((runtime__type_0 *)&i, (runtime_slice_0)v_4a, v14 + 2);
    v13 = (reflect_rtype *)srcc.array;
    v16 = srcc.cap;
    v15 = v47;
  }
  if ( v15 > v16 )
    runtime_panicslice();
  v49 = (uint8 *)v13;
  runtime_memmove();
  v17 = p;
  p->buf.len = v47;
  p->buf.cap = v16;
  if ( *(_DWORD *)&runtime_writeBarrier.enabled )
  {
    runtime_writebarrierptr((uintptr *)p, (uintptr)v49);
    v18 = (reflect_rtype *)v49;
    v17 = p;
  }
  else
  {
    v18 = (reflect_rtype *)v49;
    p->buf.array = v49;
  }
  if ( u )
  {
    fmt___ptr_pp__fmt0x64(v17, u, 1);
    v22 = p;
  }
  else
  {
    v19 = v17->buf.len;
    v20 = v19 + 3;
    v48 = v19 + 3;
    v21 = v17->buf.cap;
    if ( v19 + 3 > v21 )
    {
      v_4b.typ = v18;
      *(_QWORD *)&v_4b.ptr = __PAIR64__(v21, v19);
      srcd = runtime_growslice((runtime__type_0 *)&i, (runtime_slice_0)v_4b, v19 + 3);
      v21 = srcd.cap;
      v18 = (reflect_rtype *)srcd.array;
      v20 = v48;
    }
    if ( v20 > v21 )
      runtime_panicslice();
    v50 = (uint8 *)v18;
    runtime_memmove();
    v22 = p;
    p->buf.len = v48;
    p->buf.cap = v21;
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
    {
      runtime_writebarrierptr((uintptr *)p, (uintptr)v50);
      v22 = p;
    }
    else
    {
      p->buf.array = v50;
    }
  }
  v23 = v22->buf.cap;
  v24 = v22->buf.len;
  v25 = v22->buf.array;
  if ( v24 + 1 > v23 )
  {
    v_4c.typ = (reflect_rtype *)v22->buf.array;
    *(_QWORD *)&v_4c.ptr = __PAIR64__(v23, v24);
    src = runtime_growslice((runtime__type_0 *)&i, (runtime_slice_0)v_4c, v24 + 1);
    v26 = (uint8 *)src.array;
    v27 = src.len;
    v28 = p;
    p->buf.cap = src.cap;
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
    {
      runtime_writebarrierptr((uintptr *)p, (uintptr)src.array);
      v26 = (uint8 *)src.array;
      v27 = src.len;
      v28 = p;
    }
    else
    {
      p->buf.array = (uint8 *)src.array;
    }
    v24 = v27;
    v22 = v28;
    v25 = v26;
  }
  v22->buf.len = v24 + 1;
  v25[v24] = 41;
}
// 80B9316: variable 'v_8' is possibly undefined

//----- (080B9720) --------------------------------------------------------
void __golang fmt___ptr_pp__catchPanic(fmt_pp *p, interface_{} arg, int32 verb)
{
  fmt_pp *v3; // eax
  __int64 v4; // rcx
  unsigned __int32 v5; // edx
  uintptr v6; // ebp
  uintptr *v7; // ecx
  __int64 v8; // rcx
  unsigned __int32 v9; // edx
  uint8 *v10; // ebp
  fmt_pp *v11; // ecx
  fmt_pp *v12; // eax
  __int32 cap; // ecx
  __int32 len; // edx
  uint8 *v15; // ebx
  uint8 *v16; // eax
  __int32 v17; // ecx
  uintptr *v18; // ebx
  uint8 *v19; // ebp
  __int64 v20; // rcx
  unsigned __int32 v21; // edx
  void *array; // ebp
  uintptr *v23; // ecx
  interface_{} r; // [esp+4h] [ebp-44h]
  runtime_slice_0 ra; // [esp+4h] [ebp-44h]
  reflect_Value_0 v; // [esp+8h] [ebp-40h]
  runtime_slice_0 src; // [esp+14h] [ebp-34h]
  runtime_slice_0 srcb; // [esp+14h] [ebp-34h]
  runtime_slice_0 srca; // [esp+14h] [ebp-34h]
  runtime_slice_0 srcc; // [esp+14h] [ebp-34h]
  __int32 v31; // [esp+28h] [ebp-20h]
  __int32 v32; // [esp+28h] [ebp-20h]
  __int32 v33; // [esp+28h] [ebp-20h]
  _BYTE oldFlags[5]; // [esp+2Fh] [ebp-19h]
  int oldFlags_5; // [esp+34h] [ebp-14h]
  interface_{} err_type; // [esp+38h] [ebp-10h]

  r = runtime_gorecover((uintptr)&p);
  if ( r._type )
  {
    err_type = r;
    v = reflect_ValueOf(arg);
    if ( (v.flag & 0x1F) == 22 && reflect_Value_IsNil(v) )
    {
      v20 = *(_QWORD *)&p->buf.len;
      v21 = v20 + 5;
      v33 = v20 + 5;
      array = p->buf.array;
      if ( (unsigned int)(v20 + 5) > HIDWORD(v20) )
      {
        srcc = runtime_growslice((runtime__type_0 *)&i, (runtime_slice_0)p->buf, (int)v20 + 5);
        HIDWORD(v20) = srcc.cap;
        array = srcc.array;
        v21 = v33;
      }
      if ( v21 > HIDWORD(v20) )
        runtime_panicslice();
      runtime_memmove();
      LODWORD(v20) = p;
      p->buf.len = v33;
      *(_DWORD *)(v20 + 8) = HIDWORD(v20);
      if ( *(_DWORD *)&runtime_writeBarrier.enabled )
        runtime_writebarrierptr(v23, (uintptr)array);
      else
        *v23 = (uintptr)array;
    }
    else
    {
      v3 = p;
      if ( p->panicking )
      {
        runtime_gopanic(err_type);
        BUG();
      }
      *(_DWORD *)oldFlags = *(_DWORD *)&p->fmt.fmtFlags.widPresent;
      *(_DWORD *)&oldFlags[1] = *(_DWORD *)&p->fmt.fmtFlags.precPresent;
      oldFlags_5 = *(_DWORD *)&p->fmt.fmtFlags.space;
      *(_DWORD *)&p->fmt.fmtFlags.widPresent = 0;
      *(_DWORD *)&v3->fmt.fmtFlags.precPresent = 0;
      *(_DWORD *)&v3->fmt.fmtFlags.space = 0;
      v4 = *(_QWORD *)&v3->buf.len;
      v5 = v4 + 2;
      v31 = v4 + 2;
      v6 = (uintptr)v3->buf.array;
      if ( (unsigned int)(v4 + 2) > HIDWORD(v4) )
      {
        srca = runtime_growslice((runtime__type_0 *)&i, (runtime_slice_0)v3->buf, (int)v4 + 2);
        HIDWORD(v4) = srca.cap;
        v6 = (uintptr)srca.array;
        v5 = v31;
      }
      if ( v5 > HIDWORD(v4) )
        runtime_panicslice();
      runtime_memmove();
      LODWORD(v4) = p;
      p->buf.len = v31;
      *(_DWORD *)(v4 + 8) = HIDWORD(v4);
      if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      {
        runtime_writebarrierptr(v7, v6);
        v7 = (uintptr *)p;
      }
      else
      {
        *v7 = v6;
      }
      fmt___ptr_buffer__WriteRune((fmt_buffer *)v7, verb);
      v8 = *(_QWORD *)&p->buf.len;
      v9 = v8 + 7;
      v32 = v8 + 7;
      v10 = p->buf.array;
      if ( (unsigned int)(v8 + 7) > HIDWORD(v8) )
      {
        srcb = runtime_growslice((runtime__type_0 *)&i, (runtime_slice_0)p->buf, (int)v8 + 7);
        HIDWORD(v8) = srcb.cap;
        v10 = (uint8 *)srcb.array;
        v9 = v32;
      }
      if ( v9 > HIDWORD(v8) )
        runtime_panicslice();
      runtime_memmove();
      LODWORD(v8) = p;
      p->buf.len = v32;
      *(_DWORD *)(v8 + 8) = HIDWORD(v8);
      if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      {
        runtime_writebarrierptr((uintptr *)v11, (uintptr)v10);
        v11 = p;
      }
      else
      {
        v11->buf.array = v10;
      }
      v11->panicking = 1;
      fmt___ptr_pp__printArg(v11, err_type, 118);
      v12 = p;
      p->panicking = 0;
      cap = v12->buf.cap;
      len = v12->buf.len;
      v15 = v12->buf.array;
      if ( len + 1 > cap )
      {
        ra.array = v12->buf.array;
        *(_QWORD *)&ra.len = __PAIR64__(cap, len);
        src = runtime_growslice((runtime__type_0 *)&i, ra, len + 1);
        v16 = (uint8 *)src.array;
        v17 = src.len;
        v18 = (uintptr *)p;
        p->buf.cap = src.cap;
        if ( *(_DWORD *)&runtime_writeBarrier.enabled )
        {
          runtime_writebarrierptr(v18, (uintptr)src.array);
          v16 = (uint8 *)src.array;
          v17 = src.len;
          v18 = (uintptr *)p;
        }
        else
        {
          *v18 = (uintptr)src.array;
        }
        len = v17;
        v19 = v16;
        v12 = (fmt_pp *)v18;
        v15 = v19;
      }
      v12->buf.len = len + 1;
      v15[len] = 41;
      *(_DWORD *)&v12->fmt.fmtFlags.widPresent = *(_DWORD *)oldFlags;
      *(_DWORD *)&v12->fmt.fmtFlags.precPresent = *(_DWORD *)&oldFlags[1];
      *(_DWORD *)&v12->fmt.fmtFlags.space = oldFlags_5;
    }
  }
}

//----- (080B9B30) --------------------------------------------------------
void __golang fmt___ptr_pp__handleMethods(fmt_pp *p, int32 verb, bool handled)
{
  int v3; // eax
  int v4; // eax
  int v5; // eax
  int v6; // eax
  runtime_interfacetype_0 *inter; // [esp+0h] [ebp-40h]
  runtime_eface_0 e; // [esp+4h] [ebp-3Ch]
  runtime_eface_0 ea; // [esp+4h] [ebp-3Ch]
  runtime_iface_0 v10; // [esp+Ch] [ebp-34h]
  runtime_iface_0 v11; // [esp+Ch] [ebp-34h]
  runtime_iface_0 v12; // [esp+Ch] [ebp-34h]
  int32 v13; // [esp+Ch] [ebp-34h]
  int v14; // [esp+10h] [ebp-30h]
  bool v15; // [esp+14h] [ebp-2Ch]
  char v16; // [esp+14h] [ebp-2Ch]
  char v17; // [esp+14h] [ebp-2Ch]
  char v18; // [esp+14h] [ebp-2Ch]
  char v19; // [esp+14h] [ebp-2Ch]
  interface_{} arg; // [esp+38h] [ebp-8h]

  if ( p->erroring )
    goto LABEL_27;
  runtime_assertE2I2((runtime_interfacetype_0 *)&arg0, p->arg, v10, v15);
  if ( v16 )
  {
    runtime_deferproc(16, (runtime_funcval *)&stru_80E7B0C);
    if ( !v6 )
    {
      ((void (*)(void))v11.tab->fun[0])();
      runtime_deferreturn((uintptr)v11.data);
      return;
    }
  }
  else
  {
    if ( p->fmt.fmtFlags.sharpV )
    {
      runtime_assertE2I2((runtime_interfacetype_0 *)&stru_80D0F20, p->arg, v11, 0);
      if ( v19 )
      {
        ea.data = p;
        runtime_deferproc(16, (runtime_funcval *)&stru_80E7B0C);
        if ( !v5 )
        {
          ea._type = (runtime__type_0 *)(*(int (__golang **)(int))(v13 + 20))(v14);
          fmt___ptr_fmt__fmt_s(&p->fmt, (string)ea);
        }
      }
      goto LABEL_27;
    }
    if ( verb > 113 )
    {
      if ( verb != 115 && verb != 118 && verb != 120 )
        goto LABEL_27;
    }
    else if ( verb != 88 && verb != 113 )
    {
      goto LABEL_27;
    }
    if ( p->arg._type )
    {
      arg = p->arg;
      runtime_assertE2I2((runtime_interfacetype_0 *)&iface, arg, v11, 0);
      if ( v17 )
      {
        e.data = p;
        runtime_deferproc(16, (runtime_funcval *)&stru_80E7B0C);
        if ( v3 )
          goto LABEL_27;
      }
      else
      {
        runtime_assertE2I2((runtime_interfacetype_0 *)&stru_80D0F80, arg, v12, 0);
        if ( !v18 )
          goto LABEL_27;
        e.data = p;
        runtime_deferproc(16, (runtime_funcval *)&stru_80E7B0C);
        if ( v4 )
          goto LABEL_27;
      }
      e._type = (runtime__type_0 *)((int (__golang *)(void *))v12.tab->fun[0])(v12.data);
      fmt___ptr_pp__fmtString(p, (string)e, verb);
    }
  }
LABEL_27:
  runtime_deferreturn((uintptr)inter);
}
// 80B9B75: variable 'v10' is possibly undefined
// 80B9B75: variable 'v15' is possibly undefined
// 80B9B89: variable 'v16' is possibly undefined
// 80B9BE7: variable 'v11' is possibly undefined
// 80B9BFB: variable 'v17' is possibly undefined
// 80B9C40: variable 'v3' is possibly undefined
// 80B9C46: variable 'v12' is possibly undefined
// 80B9CA7: variable 'v18' is possibly undefined
// 80B9CF0: variable 'v4' is possibly undefined
// 80B9D83: variable 'v19' is possibly undefined
// 80B9DCC: variable 'v5' is possibly undefined
// 80B9DD2: variable 'v13' is possibly undefined
// 80B9DDC: variable 'v14' is possibly undefined
// 80B9E44: variable 'v6' is possibly undefined
// 80B9E85: variable 'inter' is possibly undefined

//----- (080B9EA0) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
void __golang fmt___ptr_pp__printArg(fmt_pp *p, interface_{} arg, int32 verb)
{
  interface_{} v3; // rax
  fmt_pp *v4; // ecx
  int32 v5; // ebp
  unsigned int hash; // esi
  char v7; // bl
  bool v8; // zf
  float64 v9; // xmm0_8
  unsigned int v10; // edi
  unsigned int v11; // ebx
  uint8 *v12; // ebp
  bool v13; // zf
  reflect_rtype *v14; // ebx
  unsigned int v15; // ebp
  unsigned int v16; // esi
  fmt_pp *v17; // edx
  unsigned __int8 v18; // bl
  bool v19; // zf
  float v20; // xmm0_4
  float v21; // xmm1_4
  unsigned int v22; // ebx
  unsigned int v23; // edi
  unsigned int v24; // ebx
  unsigned int v25; // edi
  bool v26; // zf
  float v27; // xmm0_4
  double v28; // xmm0_8
  double v29; // xmm1_8
  bool v30; // zf
  int v31; // ebx
  unsigned int v32; // ebx
  char v33; // bl
  bool v34; // zf
  bool v35; // zf
  unsigned int v36; // ebx
  unsigned int v37; // esi
  __int16 v38; // bx
  unsigned __int16 v39; // bx
  reflect_Value_0 f; // [esp+0h] [ebp-38h]
  string v41; // [esp+4h] [ebp-34h]
  reflect_Value_0 v42; // [esp+4h] [ebp-34h]
  reflect_Value_0 v43; // [esp+4h] [ebp-34h]
  __uint8 v44; // [esp+4h] [ebp-34h]
  complex128 v45; // [esp+4h] [ebp-34h]
  complex128 v46; // [esp+4h] [ebp-34h]
  reflect_Value_0 v47; // [esp+4h] [ebp-34h]
  string v48; // [esp+4h] [ebp-34h]
  char v49; // [esp+8h] [ebp-30h]
  bool v50; // [esp+8h] [ebp-30h]
  char v51; // [esp+8h] [ebp-30h]
  interface_{} size; // [esp+Ch] [ebp-2Ch]
  runtime__type_0 *sizea; // [esp+Ch] [ebp-2Ch]
  void *size_4; // [esp+10h] [ebp-28h]
  string depth; // [esp+14h] [ebp-24h]
  reflect_Value_0 v_2_typ; // [esp+20h] [ebp-18h]

  v3._type = arg._type;
  v4 = p;
  p->arg._type = arg._type;
  if ( *(_DWORD *)&runtime_writeBarrier.enabled )
  {
    runtime_writebarrierptr((uintptr *)&p->arg.data, (uintptr)arg.data);
    v3 = arg;
    v4 = p;
  }
  else
  {
    v3.data = arg.data;
    p->arg.data = arg.data;
  }
  v4->value.flag = 0;
  if ( *(_DWORD *)&runtime_writeBarrier.enabled )
  {
    v_2_typ.flag = (reflect_flag)&v4->value.ptr;
    runtime_writebarrierptr((uintptr *)&v4->value, 0);
    runtime_writebarrierptr((uintptr *)v_2_typ.flag, 0);
    v3 = arg;
    v4 = p;
  }
  else
  {
    v4->value.typ = 0;
    v4->value.ptr = 0;
  }
  if ( !v3._type )
  {
    if ( verb == 84 || verb == 118 )
    {
      v48.str = (uint8 *)"<nil>";
      v48.len = 5;
      fmt___ptr_fmt__padString(&v4->fmt, v48);
    }
    else
    {
      fmt___ptr_pp__badVerb(v4, verb);
    }
    return;
  }
  v5 = verb;
  if ( verb == 84 )
  {
    v41.str = (uint8 *)(*((int (__golang **)(runtime__type_0 *))&go_itab__reflect_rtype_reflect_Type + 33))(v3._type);
    fmt___ptr_fmt__fmt_s(&p->fmt, v41);
    return;
  }
  if ( verb == 112 )
  {
    v47 = reflect_ValueOf(v3);
    fmt___ptr_pp__fmtPointer(p, v47, 112);
    return;
  }
  hash = v3._type->hash;
  if ( hash > 0xB0C23ED3 )
  {
    if ( hash <= 0xD04AE83D )
    {
      if ( hash <= 0xBBAD4102 )
      {
        if ( hash == -1290120083 )
        {
          if ( &unk_80CE7A0 == (_UNKNOWN *)v3._type )
          {
            v28 = *((double *)v3.data + 1);
            v29 = *(double *)v3.data;
          }
          else
          {
            v29 = 0.0;
            v28 = 0.0;
          }
          if ( &unk_80CE7A0 == (_UNKNOWN *)v3._type )
          {
            v46.real = v29;
            v46.imag = v28;
            fmt___ptr_pp__fmtComplex(v4, v46, 128, verb);
            return;
          }
          v30 = 0;
        }
        else
        {
          v30 = hash == -1146273534;
        }
        if ( !v30 )
          goto LABEL_21;
        v31 = &unk_80CEBE0 == (_UNKNOWN *)v3._type ? *(_DWORD *)v3.data : 0;
        if ( &unk_80CEBE0 != (_UNKNOWN *)v3._type )
          goto LABEL_21;
LABEL_98:
        fmt___ptr_pp__fmtInteger(v4, v31, 1, verb);
        return;
      }
      if ( hash != -1119168622 || (&et != v3._type ? (v32 = 0) : (v32 = *(_DWORD *)v3.data), &et != v3._type) )
      {
        if ( hash == -871972825 )
        {
          if ( &unk_80CEC60 == (_UNKNOWN *)v3._type )
            v33 = *(_BYTE *)v3.data;
          else
            v33 = 0;
          if ( &unk_80CEC60 == (_UNKNOWN *)v3._type )
          {
            fmt___ptr_pp__fmtInteger(v4, v33, 1, verb);
            return;
          }
          v34 = 0;
        }
        else
        {
          v34 = hash == -800397251;
        }
        if ( !v34 )
          goto LABEL_21;
        v32 = &stru_80CF2A0 == v3._type ? *(_DWORD *)v3.data : 0;
        if ( &stru_80CF2A0 != v3._type )
          goto LABEL_21;
      }
LABEL_116:
      fmt___ptr_pp__fmtInteger(v4, v32, 0, verb);
      return;
    }
    if ( hash > 0xE0FF5CB4 )
    {
      if ( hash == -321552178 )
      {
        v38 = &unk_80CEBA0 == (_UNKNOWN *)v3._type ? *(_WORD *)v3.data : 0;
        if ( &unk_80CEBA0 == (_UNKNOWN *)v3._type )
        {
          fmt___ptr_pp__fmtInteger(v4, v38, 1, verb);
          return;
        }
      }
      if ( hash == -269349216 )
      {
        v39 = &unk_80CF260 == (_UNKNOWN *)v3._type ? *(_WORD *)v3.data : 0;
        if ( &unk_80CF260 == (_UNKNOWN *)v3._type )
        {
          fmt___ptr_pp__fmtInteger(v4, v39, 0, verb);
          return;
        }
      }
      if ( hash != -145526278 )
        goto LABEL_21;
      v31 = &stru_80CEB60 == v3._type ? *(_DWORD *)v3.data : 0;
      if ( &stru_80CEB60 != v3._type )
        goto LABEL_21;
      goto LABEL_98;
    }
    if ( hash == -709331182 )
    {
      if ( &unk_80CF220 == (_UNKNOWN *)v3._type )
        v32 = *(_DWORD *)v3.data;
      else
        v32 = 0;
      if ( &unk_80CF220 == (_UNKNOWN *)v3._type )
        goto LABEL_116;
      v35 = 0;
    }
    else
    {
      v35 = hash == -520135500;
    }
    if ( v35 )
    {
      if ( &t == (const interface_{} *)v3._type )
      {
        v36 = *((_DWORD *)v3.data + 1);
        v37 = *(_DWORD *)v3.data;
      }
      else
      {
        v37 = 0;
        v36 = 0;
      }
      if ( &t == (const interface_{} *)v3._type )
      {
        fmt___ptr_pp__fmtString(v4, (string)__PAIR64__(v36, v37), verb);
        return;
      }
    }
    goto LABEL_21;
  }
  if ( hash > 0x500C1ABC )
  {
    if ( hash > 0x7925028C )
    {
      if ( hash == -2043572946 )
      {
        if ( &unk_80CF2E0 == (_UNKNOWN *)v3._type )
        {
          v22 = *(_DWORD *)v3.data;
          v23 = *((_DWORD *)v3.data + 1);
        }
        else
        {
          v23 = 0;
          v22 = 0;
        }
        if ( &unk_80CF2E0 == (_UNKNOWN *)v3._type )
        {
          fmt___ptr_pp__fmtInteger(v4, __PAIR64__(v23, v22), 0, verb);
          return;
        }
      }
      if ( hash == -1774216193 )
      {
        if ( &unk_80CEC20 == (_UNKNOWN *)v3._type )
        {
          v24 = *(_DWORD *)v3.data;
          v25 = *((_DWORD *)v3.data + 1);
        }
        else
        {
          v24 = 0;
          v25 = 0;
        }
        if ( &unk_80CEC20 == (_UNKNOWN *)v3._type )
        {
          fmt___ptr_pp__fmtInteger(v4, __PAIR64__(v25, v24), 1, verb);
          return;
        }
        v26 = 0;
      }
      else
      {
        v26 = hash == -1329447213;
      }
      if ( v26 )
      {
        v27 = &unk_80CE820 == (_UNKNOWN *)v3._type ? *(float *)v3.data : 0.0;
        if ( &unk_80CE820 == (_UNKNOWN *)v3._type )
        {
          fmt___ptr_pp__fmtFloat(v4, v27, 32, verb);
          return;
        }
      }
    }
    else
    {
      if ( hash == 1715356255 )
      {
        if ( &i == v3._type )
          v18 = *(_BYTE *)v3.data;
        else
          v18 = 0;
        if ( &i == v3._type )
        {
          fmt___ptr_pp__fmtInteger(v4, v18, 0, verb);
          return;
        }
        v19 = 0;
      }
      else
      {
        v19 = hash == 2032468620;
      }
      if ( v19 )
      {
        if ( &unk_80CE7E0 == (_UNKNOWN *)v3._type )
        {
          v20 = *((float *)v3.data + 1);
          v21 = *(float *)v3.data;
        }
        else
        {
          v20 = 0.0;
          v21 = 0.0;
        }
        if ( &unk_80CE7E0 == (_UNKNOWN *)v3._type )
        {
          v45.real = v21;
          v45.imag = v20;
          fmt___ptr_pp__fmtComplex(v4, v45, 64, verb);
          return;
        }
      }
    }
    goto LABEL_21;
  }
  if ( hash <= 0x2EA27FFB )
  {
    if ( hash == 335480517 )
    {
      if ( &unk_80CE760 == (_UNKNOWN *)v3._type )
        v7 = *(_BYTE *)v3.data;
      else
        v7 = 0;
      if ( &unk_80CE760 == (_UNKNOWN *)v3._type )
      {
        fmt___ptr_pp__fmtBool(v4, v7, verb);
        return;
      }
      v8 = 0;
    }
    else
    {
      v8 = hash == 782401531;
    }
    if ( v8 )
    {
      v9 = &unk_80CE860 == (_UNKNOWN *)v3._type ? *(double *)v3.data : 0.0;
      if ( &unk_80CE860 == (_UNKNOWN *)v3._type )
      {
        fmt___ptr_pp__fmtFloat(v4, v9, 64, verb);
        return;
      }
    }
    goto LABEL_21;
  }
  if ( hash == 942571231 )
  {
    if ( &stru_80CA1C0 == v3._type )
    {
      v10 = *((_DWORD *)v3.data + 2);
      v11 = *((_DWORD *)v3.data + 1);
      v12 = *(uint8 **)v3.data;
    }
    else
    {
      v10 = 0;
      v11 = 0;
      v12 = 0;
    }
    if ( &stru_80CA1C0 == v3._type )
    {
      v44.array = v12;
      *(_QWORD *)&v44.len = __PAIR64__(v10, v11);
      depth.str = (uint8 *)"[]byte";
      depth.len = 6;
      fmt___ptr_pp__fmtBytes(v4, v44, verb, depth);
      return;
    }
    v13 = 0;
  }
  else
  {
    v13 = hash == 1342970556;
  }
  if ( !v13
    || (&stru_80E08C0 != v3._type ? (v15 = 0, v16 = 0, v14 = 0) : (reflect_rtype *)(v14 = *(reflect_rtype **)v3.data,
                                                                                    v15 = *((_DWORD *)v3.data + 2),
                                                                                    v16 = *((_DWORD *)v3.data + 1)),
        &stru_80E08C0 != v3._type) )
  {
    v5 = verb;
LABEL_21:
    fmt___ptr_pp__handleMethods(v4, v5, v41.len);
    if ( !v49 )
    {
      v42 = reflect_ValueOf(arg);
      fmt___ptr_pp__printValue(p, v42, verb, 0);
    }
    return;
  }
  if ( !v15 )
  {
LABEL_38:
    v43.typ = v14;
    *(_QWORD *)&v43.ptr = __PAIR64__(v15, v16);
    fmt___ptr_pp__printValue(v4, v43, verb, 0);
    return;
  }
  *(_QWORD *)&v_2_typ.typ = __PAIR64__(v16, (unsigned int)v14);
  f.typ = v14;
  *(_QWORD *)&f.ptr = __PAIR64__(v15, v16);
  LOBYTE(size._type) = reflect_Value_CanInterface(f);
  if ( !LOBYTE(size._type) )
  {
    v4 = p;
    goto LABEL_38;
  }
  reflect_Value_Interface(v_2_typ, size);
  v17 = p;
  p->arg._type = sizea;
  if ( *(_DWORD *)&runtime_writeBarrier.enabled )
  {
    runtime_writebarrierptr((uintptr *)&p->arg.data, (uintptr)size_4);
    v17 = p;
  }
  else
  {
    p->arg.data = size_4;
  }
  fmt___ptr_pp__handleMethods(v17, verb, v50);
  if ( !v51 )
  {
    v4 = p;
    goto LABEL_38;
  }
}
// 80B9F28: conditional instruction was optimized away because eax.4!=0
// 80B9F5F: conditional instruction was optimized away because eax.4!=0
// 80B9FF0: failed to expand linear variable ^8.12
// 80BA6C9: failed to expand linear variable ^8.12

//----- (080BA7B0) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
void __golang fmt___ptr_pp__printValue(fmt_pp *p, reflect_Value_0 value, int32 verb, __int32 depth)
{
  __int32 v4; // eax
  reflect_flag flag; // ecx
  fmt_pp *v6; // edx
  reflect_rtype *typ; // ebx
  void *ptr; // ebp
  reflect_flag v9; // esi
  unsigned int v10; // ecx
  __int32 v11; // eax
  __int32 v12; // ecx
  uint8 *v13; // edx
  __int32 v14; // ebx
  uint8 *v15; // ebp
  __int32 v16; // edx
  unsigned int v17; // eax
  unsigned int v18; // ecx
  fmt_pp *v19; // eax
  __int32 v20; // ecx
  __int32 v21; // edx
  uint8 *v22; // ebx
  __int32 j; // ecx
  __int32 v24; // ecx
  fmt_pp *v25; // eax
  __int32 v26; // edx
  uint8 *v27; // ebx
  __int32 v28; // ebp
  uint8 *v29; // eax
  __int32 v30; // ecx
  fmt_pp *v31; // eax
  __int32 v32; // ecx
  __int32 v33; // edx
  uint8 *v34; // ebx
  uint8 *v35; // eax
  int v36; // ecx
  fmt_pp *v37; // ebx
  uint8 *v38; // ebp
  uint8 *v39; // eax
  int v40; // ecx
  uint8 *v41; // eax
  __int32 v42; // ecx
  __int32 v43; // ebx
  unsigned __int32 cap; // ebp
  uint8 *v45; // esi
  unsigned __int32 v46; // edi
  fmt_pp *v47; // ecx
  __int32 v48; // eax
  uint8 *v49; // edx
  __int32 v50; // ebx
  __int32 k; // eax
  __int32 v52; // edx
  unsigned __int32 v53; // ebx
  unsigned __int32 v54; // ebp
  uint8 *v55; // esi
  fmt_pp *v56; // eax
  __int32 v57; // ecx
  __int32 v58; // edx
  uint8 *v59; // ebx
  uint8 *v60; // eax
  int v61; // ecx
  fmt_pp *v62; // ebx
  uint8 *v63; // ebp
  uint8 *v64; // eax
  int v65; // ecx
  fmt_pp *v66; // ebx
  __int32 v67; // ecx
  unsigned __int32 v68; // edx
  unsigned __int32 v69; // ebx
  uint8 *v70; // ebp
  uintptr *v71; // ecx
  int v72; // ecx
  unsigned __int32 v73; // edi
  unsigned int v74; // eax
  uintptr v75; // esi
  __int32 v76; // eax
  int v77; // ecx
  __int32 v78; // edx
  fmt_pp *v79; // edi
  __int32 v80; // eax
  unsigned __int32 v81; // edx
  uint8 *v82; // ecx
  unsigned __int32 v83; // ebx
  fmt_pp *v84; // ecx
  fmt_pp *v85; // eax
  __int32 v86; // ecx
  __int32 v87; // edx
  uint8 *v88; // ebx
  uint8 *v89; // eax
  int v90; // ecx
  __int32 v91; // eax
  uint8 *v92; // edx
  __int32 v93; // ecx
  uint8 *v94; // eax
  int v95; // ecx
  fmt_pp *v96; // ebx
  fmt_pp *v97; // eax
  __int32 v98; // ecx
  __int32 v99; // edx
  uint8 *v100; // ebx
  uint8 *v101; // eax
  int v102; // ecx
  fmt_pp *v103; // ebx
  uint8 *v104; // ebp
  __int32 v105; // ecx
  uint8 *v106; // edx
  __int32 v107; // ebx
  uint8 *v108; // eax
  fmt_pp *v109; // ebx
  __int32 v110; // eax
  uint8 *v111; // ecx
  __int32 v112; // ebx
  unsigned __int32 v113; // ebp
  uint8 *v114; // esi
  unsigned __int32 v115; // edi
  fmt_pp *v116; // eax
  __int32 v117; // ecx
  uint8 *v118; // edx
  __int32 v119; // ebx
  uint8 *v120; // eax
  int v121; // ecx
  __int32 v122; // ecx
  unsigned __int32 v123; // edx
  unsigned __int32 v124; // ebx
  uint8 *v125; // ebp
  __int32 v126; // ecx
  unsigned __int32 v127; // edx
  unsigned __int32 v128; // ebx
  uint8 *v129; // ebp
  __int32 v130; // eax
  uint8 *v131; // ecx
  __int32 v132; // ebx
  unsigned __int32 v133; // ebp
  unsigned __int32 v134; // esi
  uint8 *v135; // edi
  fmt_pp *v136; // ecx
  uintptr v137; // eax
  int v138; // edx
  unsigned __int32 v139; // ebx
  unsigned int v140; // ebp
  void *v141; // ecx
  reflect_rtype *v142; // edx
  unsigned int v143; // eax
  fmt_pp *v144; // eax
  __int32 v145; // ebp
  __int32 v146; // esi
  uint8 *v147; // edi
  uint8 *v148; // eax
  __int32 v149; // ecx
  fmt_pp *v150; // ebx
  __int32 v151; // ecx
  __int32 v152; // edi
  uint8 *v153; // eax
  __int32 v154; // ecx
  fmt_pp *v155; // eax
  __int32 v156; // edx
  unsigned __int32 v157; // ebx
  unsigned __int32 v158; // ebp
  uint8 *v159; // esi
  fmt_pp *v160; // ecx
  __int32 v161; // eax
  uint8 *v162; // ecx
  __int32 v163; // ebx
  unsigned __int32 v164; // ebp
  unsigned __int32 v165; // esi
  uint8 *v166; // edi
  fmt_pp *v167; // ecx
  uint8 *v168; // eax
  __int32 v169; // edx
  __int32 v170; // ebx
  int v171; // ecx
  __int32 v172; // edx
  uint8 *v173; // ebx
  __int32 v174; // ebp
  uint8 *v175; // eax
  int v176; // ecx
  fmt_pp *v177; // eax
  uint8 *v178; // ecx
  __int32 v179; // edx
  __int32 v180; // ebx
  uint8 *v181; // eax
  int v182; // ecx
  fmt_pp *v183; // ebx
  uint8 *v184; // edx
  __int32 v185; // ecx
  fmt_pp *v186; // ebx
  __int32 v187; // eax
  uint8 *v188; // ecx
  __int32 v189; // ebx
  unsigned __int32 v190; // ebp
  uint8 *v191; // esi
  unsigned __int32 v192; // edi
  fmt_pp *v193; // ecx
  int v194; // eax
  unsigned __int32 v195; // ecx
  unsigned int v196; // ebx
  uintptr v197; // ebp
  int len; // eax
  unsigned __int32 v199; // ecx
  unsigned int v200; // ebx
  uintptr array; // ebp
  void *v202; // eax
  fmt_pp *v203; // edx
  _BYTE v[36]; // [esp+0h] [ebp-11Ch] BYREF
  __int32 s_len; // [esp+3Ch] [ebp-E0h]
  __int32 s_len_0; // [esp+40h] [ebp-DCh]
  __int32 s_len_1; // [esp+44h] [ebp-D8h]
  __int32 s_len_2; // [esp+48h] [ebp-D4h]
  __int32 s_len_3; // [esp+4Ch] [ebp-D0h]
  __int32 keys_len; // [esp+50h] [ebp-CCh]
  reflect_flag key_flag; // [esp+54h] [ebp-C8h]
  __int32 i; // [esp+58h] [ebp-C4h]
  __int32 i_0; // [esp+5Ch] [ebp-C0h]
  __int32 i_1; // [esp+60h] [ebp-BCh]
  __int32 i_2; // [esp+64h] [ebp-B8h]
  __int32 i_3; // [esp+68h] [ebp-B4h]
  __int32 bytes_len; // [esp+6Ch] [ebp-B0h]
  __int32 bytes_cap; // [esp+70h] [ebp-ACh]
  int v219; // [esp+74h] [ebp-A8h]
  int v220; // [esp+78h] [ebp-A4h]
  int v221; // [esp+7Ch] [ebp-A0h]
  int v222; // [esp+80h] [ebp-9Ch] BYREF
  int v223; // [esp+84h] [ebp-98h]
  __int32 v224; // [esp+88h] [ebp-94h]
  unsigned int v225; // [esp+8Ch] [ebp-90h]
  reflect_rtype *v_2_typ; // [esp+90h] [ebp-8Ch]
  void *v_2_ptr; // [esp+94h] [ebp-88h]
  __int64 t_itab; // [esp+98h] [ebp-84h] OVERLAPPED
  uint8 *s_ptr; // [esp+A0h] [ebp-7Ch]
  uint8 *s_ptr_0; // [esp+A4h] [ebp-78h]
  uint8 *s_ptr_1; // [esp+A8h] [ebp-74h]
  uint8 *s_ptr_2; // [esp+ACh] [ebp-70h]
  uint8 *s_ptr_3; // [esp+B0h] [ebp-6Ch]
  reflect_rtype *key_typ; // [esp+B4h] [ebp-68h]
  void *key_ptr; // [esp+B8h] [ebp-64h]
  uint8 *bytes_ptr; // [esp+BCh] [ebp-60h]
  uintptr *dst; // [esp+C0h] [ebp-5Ch]
  uintptr v238; // [esp+C4h] [ebp-58h]
  _BYTE *v239; // [esp+C8h] [ebp-54h]
  uint8 *v240; // [esp+CCh] [ebp-50h]
  uint8 *v241; // [esp+D0h] [ebp-4Ch]
  int v242; // [esp+D4h] [ebp-48h]
  uintptr src; // [esp+D8h] [ebp-44h]
  uint8 *v244; // [esp+DCh] [ebp-40h]
  uint8 *v245; // [esp+E0h] [ebp-3Ch]
  uint8 *v246; // [esp+E4h] [ebp-38h]
  uint8 *v247; // [esp+E8h] [ebp-34h]
  int v248; // [esp+ECh] [ebp-30h]

  while ( (unsigned int)&v222 <= *(_DWORD *)(*(_DWORD *)(__readgsdword(0) - 4) + 8) )
    runtime_morestack_noctxt();
  v4 = depth;
  if ( depth <= 0 )
  {
    flag = value.flag;
  }
  else
  {
    flag = value.flag;
    if ( value.flag )
    {
      v[12] = reflect_Value_CanInterface(value);
      if ( v[12] )
      {
        reflect_Value_Interface(value, *(interface_{} *)&v[12]);
        v202 = *(void **)&v[16];
        v203 = p;
        p->arg._type = *(runtime__type_0 **)&v[12];
        if ( *(_DWORD *)&runtime_writeBarrier.enabled )
        {
          runtime_writebarrierptr((uintptr *)&p->arg.data, (uintptr)v202);
          v203 = p;
        }
        else
        {
          p->arg.data = v202;
        }
        fmt___ptr_pp__handleMethods(v203, verb, v[8]);
        if ( v[8] )
          return;
        v4 = depth;
        flag = value.flag;
      }
      else
      {
        v4 = depth;
        flag = value.flag;
      }
    }
  }
  v6 = p;
  p->arg._type = 0;
  if ( *(_DWORD *)&runtime_writeBarrier.enabled )
  {
    runtime_writebarrierptr((uintptr *)&p->arg.data, 0);
    v4 = depth;
    flag = value.flag;
    v6 = p;
  }
  else
  {
    p->arg.data = 0;
  }
  v6->value.flag = flag;
  if ( *(_DWORD *)&runtime_writeBarrier.enabled )
  {
    dst = (uintptr *)&v6->value.ptr;
    runtime_writebarrierptr((uintptr *)&v6->value, (uintptr)value.typ);
    runtime_writebarrierptr(dst, (uintptr)value.ptr);
    v4 = depth;
    flag = value.flag;
    v6 = p;
    typ = value.typ;
    ptr = value.ptr;
  }
  else
  {
    typ = value.typ;
    v6->value.typ = value.typ;
    ptr = value.ptr;
    v6->value.ptr = value.ptr;
  }
  v9 = flag;
  v10 = flag & 0x1F;
  if ( v10 <= 0x10 )
  {
    if ( v10 > 0xC )
    {
      if ( v10 > 0xE )
      {
        *(_DWORD *)v = typ;
        *(_DWORD *)&v[4] = ptr;
        *(_DWORD *)&v[8] = v9;
        if ( v10 == 15 )
        {
          *(complex128 *)&v[12] = reflect_Value_Complex(*(reflect_Value_0 *)v);
          *(_QWORD *)&v[4] = *(_QWORD *)&v[12];
          *(_QWORD *)&v[12] = *(_QWORD *)&v[20];
          fmt___ptr_pp__fmtComplex(p, *(complex128 *)&v[4], 64, verb);
        }
        else
        {
          *(complex128 *)&v[12] = reflect_Value_Complex(*(reflect_Value_0 *)v);
          *(_QWORD *)&v[4] = *(_QWORD *)&v[12];
          *(_QWORD *)&v[12] = *(_QWORD *)&v[20];
          fmt___ptr_pp__fmtComplex(p, *(complex128 *)&v[4], 128, verb);
        }
      }
      else
      {
        *(_DWORD *)v = typ;
        *(_DWORD *)&v[4] = ptr;
        *(_DWORD *)&v[8] = v9;
        if ( v10 == 13 )
        {
          *(double *)&v[16] = reflect_Value_Float(*(reflect_Value_0 *)v);
          fmt___ptr_pp__fmtFloat(p, *(float64 *)&v[12], 32, verb);
        }
        else
        {
          *(double *)&v[16] = reflect_Value_Float(*(reflect_Value_0 *)v);
          fmt___ptr_pp__fmtFloat(p, *(float64 *)&v[12], 64, verb);
        }
      }
      return;
    }
    if ( v10 <= 1 )
    {
      if ( (v9 & 0x1F) != 0 )
      {
        *(_DWORD *)v = typ;
        *(_DWORD *)&v[4] = ptr;
        *(_DWORD *)&v[8] = v9;
        v[12] = reflect_Value_Bool(*(reflect_Value_0 *)v);
        fmt___ptr_pp__fmtBool(p, v[12], verb);
        return;
      }
      if ( v4 )
      {
        if ( verb != 118 )
        {
          fmt___ptr_pp__badVerb(v6, verb);
          return;
        }
        len = v6->buf.len;
        v199 = len + 5;
        v224 = len + 5;
        v200 = v6->buf.cap;
        array = (uintptr)v6->buf.array;
        if ( len + 5 > v200 )
        {
          v223 = len;
          *(_DWORD *)&v[4] = array;
          *(_DWORD *)&v[8] = len;
          *(_DWORD *)&v[12] = v200;
          *(runtime_slice_0 *)&v[20] = runtime_growslice((runtime__type_0 *)&::i, *(runtime_slice_0 *)&v[4], len + 5);
          v200 = *(_DWORD *)&v[28];
          array = *(_DWORD *)&v[20];
          len = v223;
          v199 = v224;
        }
        if ( v199 > v200 )
          runtime_panicslice();
        v223 = v200;
        src = array;
        *(_DWORD *)v = array + len;
        *(_DWORD *)&v[4] = "<nil>";
        *(_DWORD *)&v[8] = 5;
        runtime_memmove();
        v71 = (uintptr *)p;
        p->buf.len = v224;
        p->buf.cap = v223;
        if ( !*(_DWORD *)&runtime_writeBarrier.enabled )
        {
          p->buf.array = (uint8 *)src;
          return;
        }
      }
      else
      {
        v194 = v6->buf.len;
        v195 = v194 + 23;
        v224 = v194 + 23;
        v196 = v6->buf.cap;
        v197 = (uintptr)v6->buf.array;
        if ( v194 + 23 > v196 )
        {
          v223 = v194;
          *(_DWORD *)&v[4] = v197;
          *(_DWORD *)&v[8] = v194;
          *(_DWORD *)&v[12] = v196;
          *(runtime_slice_0 *)&v[20] = runtime_growslice((runtime__type_0 *)&::i, *(runtime_slice_0 *)&v[4], v194 + 23);
          v196 = *(_DWORD *)&v[28];
          v197 = *(_DWORD *)&v[20];
          v194 = v223;
          v195 = v224;
        }
        if ( v195 > v196 )
          runtime_panicslice();
        src = v197;
        v223 = v196;
        *(_DWORD *)v = v197 + v194;
        *(_DWORD *)&v[4] = "<invalid reflect.Value>";
        *(_DWORD *)&v[8] = 23;
        runtime_memmove();
        v71 = (uintptr *)p;
        p->buf.len = v224;
        p->buf.cap = v223;
        if ( !*(_DWORD *)&runtime_writeBarrier.enabled )
        {
          p->buf.array = (uint8 *)src;
          return;
        }
      }
      goto LABEL_268;
    }
    if ( v10 - 2 <= 4 )
    {
      *(_DWORD *)v = typ;
      *(_DWORD *)&v[4] = ptr;
      *(_DWORD *)&v[8] = v9;
      *(_QWORD *)&v[16] = reflect_Value_Int(*(reflect_Value_0 *)v);
      fmt___ptr_pp__fmtInteger(p, *(uint64 *)&v[12], 1, verb);
      return;
    }
    if ( v10 - 7 <= 5 )
    {
      *(_DWORD *)v = typ;
      *(_DWORD *)&v[4] = ptr;
      *(_DWORD *)&v[8] = v9;
      *(_QWORD *)&v[16] = reflect_Value_Uint(*(reflect_Value_0 *)v);
      fmt___ptr_pp__fmtInteger(p, *(uint64 *)&v[12], 0, verb);
      return;
    }
    goto LABEL_90;
  }
  if ( v10 <= 0x15 )
  {
    if ( v10 <= 0x13 )
    {
      if ( v10 == 17 )
        goto LABEL_12;
      if ( v10 - 18 <= 1 )
        goto LABEL_89;
LABEL_90:
      *(_DWORD *)&v[4] = typ;
      *(_DWORD *)&v[8] = ptr;
      *(_DWORD *)&v[12] = v9;
      fmt___ptr_pp__unknownType(v6, *(reflect_Value_0 *)&v[4]);
      return;
    }
    if ( v10 == 20 )
    {
      *(_DWORD *)v = typ;
      *(_DWORD *)&v[4] = ptr;
      *(_DWORD *)&v[8] = v9;
      *(reflect_Value_0 *)&v[12] = reflect_Value_Elem(*(reflect_Value_0 *)v);
      if ( *(_DWORD *)&v[20] )
      {
        *(_DWORD *)&v[4] = *(_DWORD *)&v[12];
        *(_DWORD *)&v[8] = *(_DWORD *)&v[16];
        *(_DWORD *)&v[12] = *(_DWORD *)&v[20];
        fmt___ptr_pp__printValue(p, *(reflect_Value_0 *)&v[4], verb, depth + 1);
        return;
      }
      if ( p->fmt.fmtFlags.sharpV )
      {
        *(reflect_Type_0 *)&v[12] = reflect_Value_Type(value);
        *(_DWORD *)&v[4] = (*(int (__golang **)(_DWORD))(*(_DWORD *)&v[12] + 132))(*(_DWORD *)&v[16]);
        v130 = *(_DWORD *)&v[8];
        v131 = *(uint8 **)&v[4];
        v132 = p->buf.len;
        v133 = *(_DWORD *)&v[8] + v132;
        v224 = *(_DWORD *)&v[8] + v132;
        v134 = p->buf.cap;
        v135 = p->buf.array;
        if ( *(_DWORD *)&v[8] + v132 > v134 )
        {
          v223 = v132;
          s_len_2 = *(_DWORD *)&v[8];
          s_ptr_2 = *(uint8 **)&v[4];
          *(_DWORD *)&v[4] = v135;
          *(_DWORD *)&v[8] = v132;
          *(_DWORD *)&v[12] = v134;
          *(runtime_slice_0 *)&v[20] = runtime_growslice((runtime__type_0 *)&::i, *(runtime_slice_0 *)&v[4], v133);
          v134 = *(_DWORD *)&v[28];
          v135 = *(uint8 **)&v[20];
          v130 = s_len_2;
          v131 = s_ptr_2;
          v132 = v223;
          v133 = v224;
        }
        if ( v133 > v134 )
          runtime_panicslice();
        src = (uintptr)v135;
        v223 = v134;
        *(_DWORD *)v = &v135[v132];
        *(_DWORD *)&v[4] = v131;
        *(_DWORD *)&v[8] = v130;
        runtime_memmove();
        v136 = p;
        p->buf.len = v224;
        p->buf.cap = v223;
        if ( *(_DWORD *)&runtime_writeBarrier.enabled )
        {
          runtime_writebarrierptr((uintptr *)p, src);
          v137 = src;
          v136 = p;
        }
        else
        {
          v137 = src;
          p->buf.array = (uint8 *)src;
        }
        v138 = v136->buf.len;
        v139 = v138 + 5;
        v224 = v138 + 5;
        v140 = v136->buf.cap;
        if ( v138 + 5 > v140 )
        {
          v223 = v138;
          *(_DWORD *)&v[4] = v137;
          *(_DWORD *)&v[8] = v138;
          *(_DWORD *)&v[12] = v140;
          *(runtime_slice_0 *)&v[20] = runtime_growslice((runtime__type_0 *)&::i, *(runtime_slice_0 *)&v[4], v138 + 5);
          v140 = *(_DWORD *)&v[28];
          v137 = *(_DWORD *)&v[20];
          v138 = v223;
          v139 = v224;
        }
        if ( v139 > v140 )
          runtime_panicslice();
        src = v137;
        v223 = v140;
        *(_DWORD *)v = v137 + v138;
        *(_DWORD *)&v[4] = "(nil)";
        *(_DWORD *)&v[8] = 5;
        runtime_memmove();
        v71 = (uintptr *)p;
        p->buf.len = v224;
        p->buf.cap = v223;
        if ( !*(_DWORD *)&runtime_writeBarrier.enabled )
        {
          p->buf.array = (uint8 *)src;
          return;
        }
      }
      else
      {
        v126 = p->buf.len;
        v127 = v126 + 5;
        v224 = v126 + 5;
        v128 = p->buf.cap;
        v129 = p->buf.array;
        if ( v126 + 5 > v128 )
        {
          v223 = v126;
          *(_DWORD *)&v[4] = v129;
          *(_DWORD *)&v[8] = v126;
          *(_DWORD *)&v[12] = v128;
          *(runtime_slice_0 *)&v[20] = runtime_growslice((runtime__type_0 *)&::i, *(runtime_slice_0 *)&v[4], v126 + 5);
          v128 = *(_DWORD *)&v[28];
          v129 = *(uint8 **)&v[20];
          v126 = v223;
          v127 = v224;
        }
        if ( v127 > v128 )
          runtime_panicslice();
        src = (uintptr)v129;
        v223 = v128;
        *(_DWORD *)v = &v129[v126];
        *(_DWORD *)&v[4] = "<nil>";
        *(_DWORD *)&v[8] = 5;
        runtime_memmove();
        v71 = (uintptr *)p;
        p->buf.len = v224;
        p->buf.cap = v223;
        if ( !*(_DWORD *)&runtime_writeBarrier.enabled )
        {
          p->buf.array = (uint8 *)src;
          return;
        }
      }
      goto LABEL_268;
    }
    if ( v6->fmt.fmtFlags.sharpV )
    {
      *(_DWORD *)v = typ;
      *(_DWORD *)&v[4] = ptr;
      *(_DWORD *)&v[8] = v9;
      *(reflect_Type_0 *)&v[12] = reflect_Value_Type(*(reflect_Value_0 *)v);
      *(_DWORD *)&v[4] = (*(int (__golang **)(_DWORD))(*(_DWORD *)&v[12] + 132))(*(_DWORD *)&v[16]);
      v110 = *(_DWORD *)&v[8];
      v111 = *(uint8 **)&v[4];
      v112 = p->buf.len;
      v113 = *(_DWORD *)&v[8] + v112;
      v224 = *(_DWORD *)&v[8] + v112;
      v114 = p->buf.array;
      v115 = p->buf.cap;
      if ( *(_DWORD *)&v[8] + v112 > v115 )
      {
        v223 = v112;
        s_len_3 = *(_DWORD *)&v[8];
        s_ptr_3 = *(uint8 **)&v[4];
        *(_DWORD *)&v[4] = v114;
        *(_DWORD *)&v[8] = v112;
        *(_DWORD *)&v[12] = v115;
        *(runtime_slice_0 *)&v[20] = runtime_growslice((runtime__type_0 *)&::i, *(runtime_slice_0 *)&v[4], v113);
        v115 = *(_DWORD *)&v[28];
        v114 = *(uint8 **)&v[20];
        v110 = s_len_3;
        v111 = s_ptr_3;
        v112 = v223;
        v113 = v224;
      }
      if ( v113 > v115 )
        runtime_panicslice();
      src = (uintptr)v114;
      v223 = v115;
      *(_DWORD *)v = &v114[v112];
      *(_DWORD *)&v[4] = v111;
      *(_DWORD *)&v[8] = v110;
      runtime_memmove();
      p->buf.len = v224;
      p->buf.cap = v223;
      if ( *(_DWORD *)&runtime_writeBarrier.enabled )
        runtime_writebarrierptr((uintptr *)p, src);
      else
        p->buf.array = (uint8 *)src;
      v[12] = reflect_Value_IsNil(value);
      if ( v[12] )
      {
        v122 = p->buf.len;
        v123 = v122 + 5;
        v224 = v122 + 5;
        v124 = p->buf.cap;
        v125 = p->buf.array;
        if ( v122 + 5 > v124 )
        {
          v223 = v122;
          *(_DWORD *)&v[4] = v125;
          *(_DWORD *)&v[8] = v122;
          *(_DWORD *)&v[12] = v124;
          *(runtime_slice_0 *)&v[20] = runtime_growslice((runtime__type_0 *)&::i, *(runtime_slice_0 *)&v[4], v122 + 5);
          v125 = *(uint8 **)&v[20];
          v124 = *(_DWORD *)&v[28];
          v122 = v223;
          v123 = v224;
        }
        if ( v123 > v124 )
          runtime_panicslice();
        v223 = v124;
        src = (uintptr)v125;
        *(_DWORD *)v = &v125[v122];
        *(_DWORD *)&v[4] = "(nil)";
        *(_DWORD *)&v[8] = 5;
        runtime_memmove();
        v71 = (uintptr *)p;
        p->buf.len = v224;
        p->buf.cap = v223;
        if ( !*(_DWORD *)&runtime_writeBarrier.enabled )
        {
          p->buf.array = (uint8 *)src;
          return;
        }
        goto LABEL_268;
      }
      v116 = p;
      v117 = p->buf.cap;
      v118 = p->buf.array;
      v119 = p->buf.len;
      if ( v119 + 1 > v117 )
      {
        *(_DWORD *)&v[4] = p->buf.array;
        *(_DWORD *)&v[8] = v119;
        *(_DWORD *)&v[12] = v117;
        *(runtime_slice_0 *)&v[20] = runtime_growslice((runtime__type_0 *)&::i, *(runtime_slice_0 *)&v[4], v119 + 1);
        v120 = *(uint8 **)&v[20];
        v121 = *(_DWORD *)&v[24];
        p->buf.cap = *(_DWORD *)&v[28];
        if ( *(_DWORD *)&runtime_writeBarrier.enabled )
        {
          v240 = v120;
          v219 = v121;
          runtime_writebarrierptr((uintptr *)p, (uintptr)v120);
          v120 = v240;
          v121 = v219;
        }
        else
        {
          p->buf.array = v120;
        }
        v119 = v121;
        v118 = v120;
        v116 = p;
      }
      v116->buf.len = v119 + 1;
      v118[v119] = 123;
    }
    else
    {
      v72 = v6->buf.len;
      v73 = v72 + 4;
      v224 = v72 + 4;
      v74 = v6->buf.cap;
      v75 = (uintptr)v6->buf.array;
      if ( v72 + 4 > v74 )
      {
        v223 = v72;
        *(_DWORD *)&v[4] = v75;
        *(_DWORD *)&v[8] = v72;
        *(_DWORD *)&v[12] = v74;
        *(runtime_slice_0 *)&v[20] = runtime_growslice((runtime__type_0 *)&::i, *(runtime_slice_0 *)&v[4], v72 + 4);
        v75 = *(_DWORD *)&v[20];
        v74 = *(_DWORD *)&v[28];
        v72 = v223;
        v73 = v224;
      }
      if ( v73 > v74 )
        runtime_panicslice();
      src = v75;
      v223 = v74;
      *(_DWORD *)v = v75 + v72;
      *(_DWORD *)&v[4] = "map[";
      *(_DWORD *)&v[8] = 4;
      runtime_memmove();
      p->buf.len = v224;
      p->buf.cap = v223;
      if ( *(_DWORD *)&runtime_writeBarrier.enabled )
        runtime_writebarrierptr((uintptr *)p, src);
      else
        p->buf.array = (uint8 *)src;
    }
    *(__reflect_Value *)&v[12] = reflect_Value_MapKeys(value);
    v76 = *(_DWORD *)&v[16];
    keys_len = *(_DWORD *)&v[16];
    v77 = *(_DWORD *)&v[12];
    v78 = 0;
    while ( v78 < v76 )
    {
      i_2 = v78;
      v242 = v77;
      key_flag = *(_DWORD *)(v77 + 8);
      key_ptr = *(void **)(v77 + 4);
      key_typ = *(reflect_rtype **)v77;
      if ( v78 <= 0 )
      {
        v84 = p;
      }
      else
      {
        v79 = p;
        if ( p->fmt.fmtFlags.sharpV )
        {
          v80 = p->buf.len;
          v81 = v80 + 2;
          v224 = v80 + 2;
          v82 = p->buf.array;
          v83 = p->buf.cap;
          if ( v80 + 2 > v83 )
          {
            v223 = v80;
            *(_DWORD *)&v[4] = v82;
            *(_DWORD *)&v[8] = v80;
            *(_DWORD *)&v[12] = v83;
            *(runtime_slice_0 *)&v[20] = runtime_growslice((runtime__type_0 *)&::i, *(runtime_slice_0 *)&v[4], v80 + 2);
            v83 = *(_DWORD *)&v[28];
            v82 = *(uint8 **)&v[20];
            v80 = v223;
            v81 = v224;
          }
          if ( v81 > v83 )
            runtime_panicslice();
          src = (uintptr)v82;
          v223 = v83;
          *(_DWORD *)v = &v82[v80];
          *(_DWORD *)&v[4] = ", ";
          *(_DWORD *)&v[8] = 2;
          runtime_memmove();
          v84 = p;
          p->buf.len = v224;
          p->buf.cap = v223;
          if ( *(_DWORD *)&runtime_writeBarrier.enabled )
          {
            runtime_writebarrierptr((uintptr *)p, src);
            v84 = p;
          }
          else
          {
            p->buf.array = (uint8 *)src;
          }
        }
        else
        {
          v91 = p->buf.len;
          v92 = p->buf.array;
          v93 = p->buf.cap;
          if ( v91 + 1 > v93 )
          {
            *(_DWORD *)&v[4] = p->buf.array;
            *(_DWORD *)&v[8] = v91;
            *(_DWORD *)&v[12] = v93;
            *(runtime_slice_0 *)&v[20] = runtime_growslice((runtime__type_0 *)&::i, *(runtime_slice_0 *)&v[4], v91 + 1);
            v94 = *(uint8 **)&v[20];
            v95 = *(_DWORD *)&v[24];
            v96 = p;
            p->buf.cap = *(_DWORD *)&v[28];
            if ( *(_DWORD *)&runtime_writeBarrier.enabled )
            {
              v244 = v94;
              v221 = v95;
              runtime_writebarrierptr((uintptr *)p, (uintptr)v94);
              v94 = v244;
              v95 = v221;
              v96 = p;
            }
            else
            {
              p->buf.array = v94;
            }
            v79 = v96;
            v92 = v94;
            v91 = v95;
          }
          v79->buf.len = v91 + 1;
          v92[v91] = 32;
          v84 = v79;
        }
      }
      *(_DWORD *)&v[4] = key_typ;
      *(_DWORD *)&v[8] = key_ptr;
      *(_DWORD *)&v[12] = key_flag;
      v224 = depth + 1;
      fmt___ptr_pp__printValue(v84, *(reflect_Value_0 *)&v[4], verb, depth + 1);
      v85 = p;
      v86 = p->buf.cap;
      v87 = p->buf.len;
      v88 = p->buf.array;
      if ( v87 + 1 > v86 )
      {
        *(_DWORD *)&v[4] = p->buf.array;
        *(_DWORD *)&v[8] = v87;
        *(_DWORD *)&v[12] = v86;
        *(runtime_slice_0 *)&v[20] = runtime_growslice((runtime__type_0 *)&::i, *(runtime_slice_0 *)&v[4], v87 + 1);
        v89 = *(uint8 **)&v[20];
        v90 = *(_DWORD *)&v[24];
        p->buf.cap = *(_DWORD *)&v[28];
        if ( *(_DWORD *)&runtime_writeBarrier.enabled )
        {
          v245 = v89;
          v222 = v90;
          runtime_writebarrierptr((uintptr *)p, (uintptr)v89);
          v89 = v245;
          v90 = v222;
        }
        else
        {
          p->buf.array = v89;
        }
        v87 = v90;
        v88 = v89;
        v85 = p;
      }
      v85->buf.len = v87 + 1;
      v88[v87] = 58;
      *(_DWORD *)&v[12] = key_typ;
      *(_DWORD *)&v[16] = key_ptr;
      *(_DWORD *)&v[20] = key_flag;
      *(reflect_Value_0 *)&v[24] = reflect_Value_MapIndex(value, *(reflect_Value_0 *)&v[12]);
      *(_DWORD *)&v[4] = *(_DWORD *)&v[24];
      *(_DWORD *)&v[8] = *(_DWORD *)&v[28];
      *(_DWORD *)&v[12] = *(_DWORD *)&v[32];
      fmt___ptr_pp__printValue(p, *(reflect_Value_0 *)&v[4], verb, v224);
      v77 = v242 + 12;
      v78 = i_2 + 1;
      v76 = keys_len;
    }
    v97 = p;
    if ( p->fmt.fmtFlags.sharpV )
    {
      v98 = p->buf.cap;
      v99 = p->buf.len;
      v100 = p->buf.array;
      if ( v99 + 1 > v98 )
      {
        *(_DWORD *)&v[4] = p->buf.array;
        *(_DWORD *)&v[8] = v99;
        *(_DWORD *)&v[12] = v98;
        *(runtime_slice_0 *)&v[20] = runtime_growslice((runtime__type_0 *)&::i, *(runtime_slice_0 *)&v[4], v99 + 1);
        v101 = *(uint8 **)&v[20];
        v102 = *(_DWORD *)&v[24];
        v103 = p;
        p->buf.cap = *(_DWORD *)&v[28];
        if ( *(_DWORD *)&runtime_writeBarrier.enabled )
        {
          v241 = v101;
          v220 = v102;
          runtime_writebarrierptr((uintptr *)p, (uintptr)v101);
          v101 = v241;
          v102 = v220;
          v103 = p;
        }
        else
        {
          p->buf.array = v101;
        }
        v99 = v102;
        v104 = v101;
        v97 = v103;
        v100 = v104;
      }
      v97->buf.len = v99 + 1;
      v100[v99] = 125;
    }
    else
    {
      v105 = p->buf.len;
      v106 = p->buf.array;
      v107 = p->buf.cap;
      if ( v105 + 1 > v107 )
      {
        *(_DWORD *)&v[4] = p->buf.array;
        *(_DWORD *)&v[8] = v105;
        *(_DWORD *)&v[12] = v107;
        *(runtime_slice_0 *)&v[20] = runtime_growslice((runtime__type_0 *)&::i, *(runtime_slice_0 *)&v[4], v105 + 1);
        v108 = *(uint8 **)&v[20];
        v105 = *(_DWORD *)&v[24];
        v109 = p;
        p->buf.cap = *(_DWORD *)&v[28];
        if ( *(_DWORD *)&runtime_writeBarrier.enabled )
        {
          v241 = v108;
          v220 = v105;
          runtime_writebarrierptr((uintptr *)p, (uintptr)v108);
          v108 = v241;
          v105 = v220;
          v109 = p;
        }
        else
        {
          p->buf.array = v108;
        }
        v106 = v108;
        v97 = v109;
      }
      v97->buf.len = v105 + 1;
      v106[v105] = 93;
    }
    return;
  }
  if ( v10 <= 0x17 )
  {
    if ( v10 != 22 )
    {
LABEL_12:
      v225 = v10;
      if ( verb > 113 )
      {
        if ( verb != 115 && verb != 120 )
          goto LABEL_25;
      }
      else if ( verb != 88 && verb != 113 )
      {
LABEL_25:
        v19 = p;
        if ( !p->fmt.fmtFlags.sharpV )
        {
          v20 = p->buf.cap;
          v21 = p->buf.len;
          v22 = p->buf.array;
          if ( v21 + 1 > v20 )
          {
            *(_DWORD *)&v[4] = p->buf.array;
            *(_DWORD *)&v[8] = v21;
            *(_DWORD *)&v[12] = v20;
            *(runtime_slice_0 *)&v[20] = runtime_growslice((runtime__type_0 *)&::i, *(runtime_slice_0 *)&v[4], v21 + 1);
            v39 = *(uint8 **)&v[20];
            v40 = *(_DWORD *)&v[24];
            p->buf.cap = *(_DWORD *)&v[28];
            if ( *(_DWORD *)&runtime_writeBarrier.enabled )
            {
              v244 = v39;
              v222 = v40;
              runtime_writebarrierptr((uintptr *)p, (uintptr)v39);
              v39 = v244;
              v40 = v222;
            }
            else
            {
              p->buf.array = v39;
            }
            v21 = v40;
            v22 = v39;
            v19 = p;
          }
          v19->buf.len = v21 + 1;
          v22[v21] = 91;
          for ( j = 0; ; j = i + 1 )
          {
            i = j;
            *(_DWORD *)&v[12] = reflect_Value_Len(value);
            v24 = i;
            if ( i >= *(int *)&v[12] )
              break;
            if ( i > 0 )
            {
              v25 = p;
              v26 = p->buf.len;
              v27 = p->buf.array;
              v28 = p->buf.cap;
              if ( v26 + 1 > v28 )
              {
                *(_DWORD *)&v[4] = p->buf.array;
                *(_DWORD *)&v[8] = v26;
                *(_DWORD *)&v[12] = v28;
                *(runtime_slice_0 *)&v[20] = runtime_growslice(
                                               (runtime__type_0 *)&::i,
                                               *(runtime_slice_0 *)&v[4],
                                               v26 + 1);
                v29 = *(uint8 **)&v[20];
                v30 = *(_DWORD *)&v[24];
                p->buf.cap = *(_DWORD *)&v[28];
                if ( *(_DWORD *)&runtime_writeBarrier.enabled )
                {
                  v246 = v29;
                  v224 = v30;
                  runtime_writebarrierptr((uintptr *)p, (uintptr)v29);
                  v29 = v246;
                  v30 = v224;
                }
                else
                {
                  p->buf.array = v29;
                }
                v26 = v30;
                v27 = v29;
                v25 = p;
                v24 = i;
              }
              v25->buf.len = v26 + 1;
              v27[v26] = 32;
            }
            *(reflect_Value_0 *)&v[16] = reflect_Value_Index(value, v24);
            *(_DWORD *)&v[4] = *(_DWORD *)&v[16];
            *(_DWORD *)&v[8] = *(_DWORD *)&v[20];
            *(_DWORD *)&v[12] = *(_DWORD *)&v[24];
            fmt___ptr_pp__printValue(p, *(reflect_Value_0 *)&v[4], verb, depth + 1);
          }
          v31 = p;
          v32 = p->buf.cap;
          v33 = p->buf.len;
          v34 = p->buf.array;
          if ( v33 + 1 > v32 )
          {
            *(_DWORD *)&v[4] = p->buf.array;
            *(_DWORD *)&v[8] = v33;
            *(_DWORD *)&v[12] = v32;
            *(runtime_slice_0 *)&v[20] = runtime_growslice((runtime__type_0 *)&::i, *(runtime_slice_0 *)&v[4], v33 + 1);
            v35 = *(uint8 **)&v[20];
            v36 = *(_DWORD *)&v[24];
            v37 = p;
            p->buf.cap = *(_DWORD *)&v[28];
            if ( *(_DWORD *)&runtime_writeBarrier.enabled )
            {
              v245 = v35;
              v223 = v36;
              runtime_writebarrierptr((uintptr *)p, (uintptr)v35);
              v35 = v245;
              v36 = v223;
              v37 = p;
            }
            else
            {
              p->buf.array = v35;
            }
            v33 = v36;
            v38 = v35;
            v31 = v37;
            v34 = v38;
          }
          v31->buf.len = v33 + 1;
          v34[v33] = 93;
          return;
        }
        *(reflect_Type_0 *)&v[12] = reflect_Value_Type(value);
        *(_DWORD *)&v[4] = (*(int (__golang **)(_DWORD))(*(_DWORD *)&v[12] + 132))(*(_DWORD *)&v[16]);
        v41 = *(uint8 **)&v[4];
        v42 = *(_DWORD *)&v[8];
        v43 = p->buf.len;
        cap = *(_DWORD *)&v[8] + v43;
        v224 = *(_DWORD *)&v[8] + v43;
        v45 = p->buf.array;
        v46 = p->buf.cap;
        if ( *(_DWORD *)&v[8] + v43 > v46 )
        {
          v223 = v43;
          s_ptr = *(uint8 **)&v[4];
          s_len_0 = *(_DWORD *)&v[8];
          *(_DWORD *)&v[4] = v45;
          *(_DWORD *)&v[8] = v43;
          *(_DWORD *)&v[12] = v46;
          *(runtime_slice_0 *)&v[20] = runtime_growslice((runtime__type_0 *)&::i, *(runtime_slice_0 *)&v[4], cap);
          v45 = *(uint8 **)&v[20];
          v46 = *(_DWORD *)&v[28];
          v41 = s_ptr;
          v42 = s_len_0;
          v43 = v223;
          cap = v224;
        }
        if ( cap > v46 )
          runtime_panicslice();
        v223 = v46;
        src = (uintptr)v45;
        *(_DWORD *)v = &v45[v43];
        *(_DWORD *)&v[4] = v41;
        *(_DWORD *)&v[8] = v42;
        runtime_memmove();
        v47 = p;
        p->buf.len = v224;
        p->buf.cap = v223;
        if ( *(_DWORD *)&runtime_writeBarrier.enabled )
        {
          runtime_writebarrierptr((uintptr *)p, src);
          v47 = p;
        }
        else
        {
          p->buf.array = (uint8 *)src;
        }
        if ( v225 != 23 )
          goto LABEL_53;
        v[12] = reflect_Value_IsNil(value);
        if ( !v[12] )
        {
          v47 = p;
LABEL_53:
          v48 = v47->buf.len;
          v49 = v47->buf.array;
          v50 = v47->buf.cap;
          if ( v48 + 1 > v50 )
          {
            *(_DWORD *)&v[4] = v47->buf.array;
            *(_DWORD *)&v[8] = v48;
            *(_DWORD *)&v[12] = v50;
            *(runtime_slice_0 *)&v[20] = runtime_growslice((runtime__type_0 *)&::i, *(runtime_slice_0 *)&v[4], v48 + 1);
            v64 = *(uint8 **)&v[20];
            v65 = *(_DWORD *)&v[24];
            v66 = p;
            p->buf.cap = *(_DWORD *)&v[28];
            if ( *(_DWORD *)&runtime_writeBarrier.enabled )
            {
              v244 = v64;
              v221 = v65;
              runtime_writebarrierptr((uintptr *)p, (uintptr)v64);
              v64 = v244;
              v65 = v221;
              v66 = p;
            }
            else
            {
              p->buf.array = v64;
            }
            v49 = v64;
            v48 = v65;
            v47 = v66;
          }
          v47->buf.len = v48 + 1;
          v49[v48] = 123;
          for ( k = 0; ; k = i_3 + 1 )
          {
            i_3 = k;
            *(_DWORD *)&v[12] = reflect_Value_Len(value);
            if ( i_3 >= *(int *)&v[12] )
              break;
            if ( i_3 > 0 )
            {
              v52 = p->buf.len;
              v53 = v52 + 2;
              v224 = v52 + 2;
              v54 = p->buf.cap;
              v55 = p->buf.array;
              if ( v52 + 2 > v54 )
              {
                v223 = v52;
                *(_DWORD *)&v[4] = v55;
                *(_DWORD *)&v[8] = v52;
                *(_DWORD *)&v[12] = v54;
                *(runtime_slice_0 *)&v[20] = runtime_growslice(
                                               (runtime__type_0 *)&::i,
                                               *(runtime_slice_0 *)&v[4],
                                               v52 + 2);
                v54 = *(_DWORD *)&v[28];
                v55 = *(uint8 **)&v[20];
                v52 = v223;
                v53 = v224;
              }
              if ( v53 > v54 )
                runtime_panicslice();
              src = (uintptr)v55;
              v223 = v54;
              *(_DWORD *)v = &v55[v52];
              *(_DWORD *)&v[4] = ", ";
              *(_DWORD *)&v[8] = 2;
              runtime_memmove();
              p->buf.len = v224;
              p->buf.cap = v223;
              if ( *(_DWORD *)&runtime_writeBarrier.enabled )
                runtime_writebarrierptr((uintptr *)p, src);
              else
                p->buf.array = (uint8 *)src;
            }
            *(reflect_Value_0 *)&v[16] = reflect_Value_Index(value, i_3);
            *(_DWORD *)&v[4] = *(_DWORD *)&v[16];
            *(_DWORD *)&v[8] = *(_DWORD *)&v[20];
            *(_DWORD *)&v[12] = *(_DWORD *)&v[24];
            fmt___ptr_pp__printValue(p, *(reflect_Value_0 *)&v[4], verb, depth + 1);
          }
          v56 = p;
          v57 = p->buf.cap;
          v58 = p->buf.len;
          v59 = p->buf.array;
          if ( v58 + 1 > v57 )
          {
            *(_DWORD *)&v[4] = p->buf.array;
            *(_DWORD *)&v[8] = v58;
            *(_DWORD *)&v[12] = v57;
            *(runtime_slice_0 *)&v[20] = runtime_growslice((runtime__type_0 *)&::i, *(runtime_slice_0 *)&v[4], v58 + 1);
            v60 = *(uint8 **)&v[20];
            v61 = *(_DWORD *)&v[24];
            v62 = p;
            p->buf.cap = *(_DWORD *)&v[28];
            if ( *(_DWORD *)&runtime_writeBarrier.enabled )
            {
              v245 = v60;
              v222 = v61;
              runtime_writebarrierptr((uintptr *)p, (uintptr)v60);
              v60 = v245;
              v61 = v222;
              v62 = p;
            }
            else
            {
              p->buf.array = v60;
            }
            v58 = v61;
            v63 = v60;
            v56 = v62;
            v59 = v63;
          }
          v56->buf.len = v58 + 1;
          v59[v58] = 125;
          return;
        }
        v67 = p->buf.len;
        v68 = v67 + 5;
        v224 = v67 + 5;
        v69 = p->buf.cap;
        v70 = p->buf.array;
        if ( v67 + 5 > v69 )
        {
          v223 = v67;
          *(_DWORD *)&v[4] = v70;
          *(_DWORD *)&v[8] = v67;
          *(_DWORD *)&v[12] = v69;
          *(runtime_slice_0 *)&v[20] = runtime_growslice((runtime__type_0 *)&::i, *(runtime_slice_0 *)&v[4], v67 + 5);
          v69 = *(_DWORD *)&v[28];
          v70 = *(uint8 **)&v[20];
          v67 = v223;
          v68 = v224;
        }
        if ( v68 > v69 )
          runtime_panicslice();
        v223 = v69;
        src = (uintptr)v70;
        *(_DWORD *)v = &v70[v67];
        *(_DWORD *)&v[4] = "(nil)";
        *(_DWORD *)&v[8] = 5;
        runtime_memmove();
        v71 = (uintptr *)p;
        p->buf.len = v224;
        p->buf.cap = v223;
        if ( !*(_DWORD *)&runtime_writeBarrier.enabled )
        {
          p->buf.array = (uint8 *)src;
          return;
        }
LABEL_268:
        runtime_writebarrierptr(v71, src);
        return;
      }
      *(_DWORD *)v = typ;
      *(_DWORD *)&v[4] = ptr;
      *(_DWORD *)&v[8] = v9;
      *(reflect_Type_0 *)&v[12] = reflect_Value_Type(*(reflect_Value_0 *)v);
      t_itab = *(_QWORD *)&v[12];
      *(_DWORD *)&v[4] = (*(int (__golang **)(_DWORD))(*(_DWORD *)&v[12] + 44))(*(_DWORD *)&v[16]);
      *(_DWORD *)&v[4] = (*(int (__golang **)(_DWORD))(*(_DWORD *)&v[4] + 84))(*(_DWORD *)&v[8]);
      if ( *(_DWORD *)&v[4] == 8 )
      {
        if ( v225 == 23 )
        {
          *(__uint8 *)&v[12] = reflect_Value_Bytes(value);
          v11 = *(_DWORD *)&v[20];
          v12 = *(_DWORD *)&v[16];
          v13 = *(uint8 **)&v[12];
        }
        else if ( (value.flag & 0x100) != 0 )
        {
          *(_DWORD *)&v[12] = reflect_Value_Len(value);
          *(reflect_Value_0 *)&v[20] = reflect_Value_Slice(value, 0, *(__int32 *)&v[12]);
          *(_DWORD *)v = *(_DWORD *)&v[20];
          *(_DWORD *)&v[4] = *(_DWORD *)&v[24];
          *(_DWORD *)&v[8] = *(_DWORD *)&v[28];
          *(__uint8 *)&v[12] = reflect_Value_Bytes(*(reflect_Value_0 *)v);
          v11 = *(_DWORD *)&v[20];
          v12 = *(_DWORD *)&v[16];
          v13 = *(uint8 **)&v[12];
        }
        else
        {
          *(_DWORD *)&v[12] = reflect_Value_Len(value);
          *(runtime_slice_0 *)&v[12] = runtime_makeslice(
                                         (runtime__type_0 *)&::i,
                                         *(__int32 *)&v[12],
                                         *(__int32 *)&v[12]);
          v11 = *(_DWORD *)&v[20];
          bytes_cap = *(_DWORD *)&v[20];
          v12 = *(_DWORD *)&v[16];
          bytes_len = *(_DWORD *)&v[16];
          v13 = *(uint8 **)&v[12];
          bytes_ptr = *(uint8 **)&v[12];
          v14 = 0;
          while ( v14 < v12 )
          {
            i_0 = v14;
            *(reflect_Value_0 *)&v[16] = reflect_Value_Index(value, v14);
            *(_DWORD *)v = *(_DWORD *)&v[16];
            *(_DWORD *)&v[4] = *(_DWORD *)&v[20];
            *(_DWORD *)&v[8] = *(_DWORD *)&v[24];
            *(_QWORD *)&v[16] = reflect_Value_Uint(*(reflect_Value_0 *)v);
            v16 = bytes_len;
            if ( v14 >= (unsigned int)bytes_len )
              runtime_panicindex();
            v15 = bytes_ptr;
            bytes_ptr[i_0] = v[12];
            ++v14;
            v11 = bytes_cap;
            v12 = v16;
            v13 = v15;
          }
        }
        bytes_len = v12;
        bytes_ptr = v13;
        bytes_cap = v11;
        *(_DWORD *)&v[4] = (*(int (__golang **)(_DWORD))(t_itab + 132))(HIDWORD(t_itab));
        v17 = *(_DWORD *)&v[8];
        v18 = *(_DWORD *)&v[4];
        *(_DWORD *)&v[4] = bytes_ptr;
        *(_DWORD *)&v[8] = bytes_len;
        *(_DWORD *)&v[12] = bytes_cap;
        fmt___ptr_pp__fmtBytes(p, *(__uint8 *)&v[4], verb, (string)__PAIR64__(v17, v18));
        return;
      }
      goto LABEL_25;
    }
    if ( v4 )
    {
LABEL_89:
      *(_DWORD *)&v[4] = typ;
      *(_DWORD *)&v[8] = ptr;
      *(_DWORD *)&v[12] = v9;
      fmt___ptr_pp__fmtPointer(v6, *(reflect_Value_0 *)&v[4], verb);
      return;
    }
    *(_DWORD *)v = typ;
    *(_DWORD *)&v[4] = ptr;
    *(_DWORD *)&v[8] = v9;
    if ( !reflect_Value_Pointer(*(reflect_Value_0 *)v) )
    {
      v6 = p;
      typ = value.typ;
      ptr = value.ptr;
      v9 = value.flag;
      goto LABEL_89;
    }
    *(reflect_Value_0 *)&v[12] = reflect_Value_Elem(value);
    v141 = *(void **)&v[16];
    v142 = *(reflect_rtype **)&v[12];
    v143 = v[20] & 0x1F;
    if ( v143 > 0x15 )
    {
      if ( v143 != 23 && v143 != 25 )
        goto LABEL_189;
    }
    else if ( v143 != 17 && v143 != 21 )
    {
LABEL_189:
      v6 = p;
      typ = value.typ;
      ptr = value.ptr;
      v9 = value.flag;
      goto LABEL_89;
    }
    v225 = *(_DWORD *)&v[20];
    v144 = p;
    v145 = p->buf.len;
    v146 = p->buf.cap;
    v147 = p->buf.array;
    if ( v145 + 1 > v146 )
    {
      v_2_ptr = *(void **)&v[16];
      v_2_typ = *(reflect_rtype **)&v[12];
      *(_DWORD *)&v[4] = v147;
      *(_DWORD *)&v[8] = v145;
      *(_DWORD *)&v[12] = v146;
      *(runtime_slice_0 *)&v[20] = runtime_growslice((runtime__type_0 *)&::i, *(runtime_slice_0 *)&v[4], v145 + 1);
      v148 = *(uint8 **)&v[20];
      v149 = *(_DWORD *)&v[24];
      v150 = p;
      p->buf.cap = *(_DWORD *)&v[28];
      if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      {
        v246 = v148;
        v224 = v149;
        runtime_writebarrierptr((uintptr *)p, (uintptr)v148);
        v148 = v246;
        v149 = v224;
        v150 = p;
      }
      else
      {
        p->buf.array = v148;
      }
      v142 = v_2_typ;
      v145 = v149;
      v147 = v148;
      v144 = v150;
      v141 = v_2_ptr;
    }
    v144->buf.len = v145 + 1;
    v147[v145] = 38;
    *(_DWORD *)&v[4] = v142;
    *(_DWORD *)&v[8] = v141;
    *(_DWORD *)&v[12] = v225;
    fmt___ptr_pp__printValue(v144, *(reflect_Value_0 *)&v[4], verb, depth + 1);
    return;
  }
  if ( v10 == 24 )
  {
    *(_DWORD *)v = typ;
    *(_DWORD *)&v[4] = ptr;
    *(_DWORD *)&v[8] = v9;
    *(string *)&v[12] = reflect_Value_String(*(reflect_Value_0 *)v);
    fmt___ptr_pp__fmtString(p, *(string *)&v[12], verb);
    return;
  }
  if ( v10 != 25 )
  {
    if ( v10 == 26 )
      goto LABEL_89;
    goto LABEL_90;
  }
  if ( v6->fmt.fmtFlags.sharpV )
  {
    *(_DWORD *)v = typ;
    *(_DWORD *)&v[4] = ptr;
    *(_DWORD *)&v[8] = v9;
    *(reflect_Type_0 *)&v[12] = reflect_Value_Type(*(reflect_Value_0 *)v);
    *(_DWORD *)&v[4] = (*(int (__golang **)(_DWORD))(*(_DWORD *)&v[12] + 132))(*(_DWORD *)&v[16]);
    v187 = *(_DWORD *)&v[8];
    v188 = *(uint8 **)&v[4];
    v189 = p->buf.len;
    v190 = *(_DWORD *)&v[8] + v189;
    v223 = *(_DWORD *)&v[8] + v189;
    v191 = p->buf.array;
    v192 = p->buf.cap;
    if ( *(_DWORD *)&v[8] + v189 > v192 )
    {
      v219 = v189;
      s_len_1 = *(_DWORD *)&v[8];
      s_ptr_0 = *(uint8 **)&v[4];
      *(_DWORD *)&v[4] = v191;
      *(_DWORD *)&v[8] = v189;
      *(_DWORD *)&v[12] = v192;
      *(runtime_slice_0 *)&v[20] = runtime_growslice((runtime__type_0 *)&::i, *(runtime_slice_0 *)&v[4], v190);
      v192 = *(_DWORD *)&v[28];
      v191 = *(uint8 **)&v[20];
      v187 = s_len_1;
      v188 = s_ptr_0;
      v190 = v223;
    }
    if ( v190 > v192 )
      runtime_panicslice();
    v219 = v192;
    v238 = (uintptr)v191;
    *(_DWORD *)v = &v191[v189];
    *(_DWORD *)&v[4] = v188;
    *(_DWORD *)&v[8] = v187;
    runtime_memmove();
    v193 = p;
    p->buf.len = v223;
    p->buf.cap = v219;
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
    {
      runtime_writebarrierptr((uintptr *)p, v238);
      v193 = p;
    }
    else
    {
      p->buf.array = (uint8 *)v238;
    }
    v6 = v193;
    typ = value.typ;
    ptr = value.ptr;
  }
  v151 = v6->buf.cap;
  v152 = v6->buf.len;
  v153 = v6->buf.array;
  if ( v152 + 1 > v151 )
  {
    *(_DWORD *)&v[4] = v6->buf.array;
    *(_DWORD *)&v[8] = v152;
    *(_DWORD *)&v[12] = v151;
    *(runtime_slice_0 *)&v[20] = runtime_growslice((runtime__type_0 *)&::i, *(runtime_slice_0 *)&v[4], v152 + 1);
    v153 = *(uint8 **)&v[20];
    v185 = *(_DWORD *)&v[24];
    v186 = p;
    p->buf.cap = *(_DWORD *)&v[28];
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
    {
      v246 = v153;
      v224 = v185;
      runtime_writebarrierptr((uintptr *)p, (uintptr)v153);
      v153 = v246;
      v185 = v224;
      v186 = p;
    }
    else
    {
      p->buf.array = v153;
    }
    v6 = v186;
    typ = value.typ;
    ptr = value.ptr;
    v152 = v185;
  }
  v6->buf.len = v152 + 1;
  v153[v152] = 123;
  v239 = &v[8];
  v154 = 0;
  while ( 1 )
  {
    i_1 = v154;
    *(_DWORD *)v = typ;
    *(_DWORD *)&v[4] = ptr;
    *(_DWORD *)&v[8] = value.flag;
    *(_DWORD *)&v[12] = reflect_Value_NumField(*(reflect_Value_0 *)v);
    if ( i_1 >= *(int *)&v[12] )
      break;
    if ( i_1 <= 0 )
    {
      v160 = p;
    }
    else
    {
      v155 = p;
      if ( p->fmt.fmtFlags.sharpV )
      {
        v156 = p->buf.len;
        v157 = v156 + 2;
        v224 = v156 + 2;
        v158 = p->buf.cap;
        v159 = p->buf.array;
        if ( v156 + 2 > v158 )
        {
          v223 = v156;
          *(_DWORD *)&v[4] = v159;
          *(_DWORD *)&v[8] = v156;
          *(_DWORD *)&v[12] = v158;
          *(runtime_slice_0 *)&v[20] = runtime_growslice((runtime__type_0 *)&::i, *(runtime_slice_0 *)&v[4], v156 + 2);
          v158 = *(_DWORD *)&v[28];
          v159 = *(uint8 **)&v[20];
          v156 = v223;
          v157 = v224;
        }
        if ( v157 > v158 )
          runtime_panicslice();
        src = (uintptr)v159;
        v223 = v158;
        *(_DWORD *)v = &v159[v156];
        *(_DWORD *)&v[4] = ", ";
        *(_DWORD *)&v[8] = 2;
        runtime_memmove();
        v160 = p;
        p->buf.len = v224;
        p->buf.cap = v223;
        if ( *(_DWORD *)&runtime_writeBarrier.enabled )
        {
          runtime_writebarrierptr((uintptr *)p, src);
          v160 = p;
        }
        else
        {
          p->buf.array = (uint8 *)src;
        }
      }
      else
      {
        v172 = p->buf.len;
        v173 = p->buf.array;
        v174 = p->buf.cap;
        if ( v172 + 1 > v174 )
        {
          *(_DWORD *)&v[4] = p->buf.array;
          *(_DWORD *)&v[8] = v172;
          *(_DWORD *)&v[12] = v174;
          *(runtime_slice_0 *)&v[20] = runtime_growslice((runtime__type_0 *)&::i, *(runtime_slice_0 *)&v[4], v172 + 1);
          v175 = *(uint8 **)&v[20];
          v176 = *(_DWORD *)&v[24];
          p->buf.cap = *(_DWORD *)&v[28];
          if ( *(_DWORD *)&runtime_writeBarrier.enabled )
          {
            v244 = v175;
            v221 = v176;
            runtime_writebarrierptr((uintptr *)p, (uintptr)v175);
            v175 = v244;
            v176 = v221;
          }
          else
          {
            p->buf.array = v175;
          }
          v172 = v176;
          v173 = v175;
          v155 = p;
        }
        v155->buf.len = v172 + 1;
        v173[v172] = 32;
        v160 = v155;
      }
    }
    if ( v160->fmt.fmtFlags.plusV || v160->fmt.fmtFlags.sharpV )
    {
      *(reflect_Type_0 *)&v[12] = reflect_Value_Type(value);
      *(_DWORD *)&v[8] = (*(int (__golang **)(_DWORD, __int32))(*(_DWORD *)&v[12] + 48))(*(_DWORD *)&v[16], i_1);
      ((void (*)(void))loc_809021E)();
      v161 = v248;
      v162 = v247;
      if ( v248 )
      {
        v163 = p->buf.len;
        v164 = v248 + v163;
        v224 = v248 + v163;
        v165 = p->buf.cap;
        v166 = p->buf.array;
        if ( v248 + v163 > v165 )
        {
          v223 = v163;
          s_len = v248;
          s_ptr_1 = v247;
          *(_DWORD *)&v[4] = v166;
          *(_DWORD *)&v[8] = v163;
          *(_DWORD *)&v[12] = v165;
          *(runtime_slice_0 *)&v[20] = runtime_growslice((runtime__type_0 *)&::i, *(runtime_slice_0 *)&v[4], v164);
          v166 = *(uint8 **)&v[20];
          v165 = *(_DWORD *)&v[28];
          v161 = s_len;
          v162 = s_ptr_1;
          v163 = v223;
          v164 = v224;
        }
        if ( v164 > v165 )
          runtime_panicslice();
        src = (uintptr)v166;
        v223 = v165;
        *(_DWORD *)v = &v166[v163];
        *(_DWORD *)&v[4] = v162;
        *(_DWORD *)&v[8] = v161;
        runtime_memmove();
        v167 = p;
        p->buf.len = v224;
        p->buf.cap = v223;
        if ( *(_DWORD *)&runtime_writeBarrier.enabled )
        {
          runtime_writebarrierptr((uintptr *)p, src);
          v168 = (uint8 *)src;
          v167 = p;
        }
        else
        {
          v168 = (uint8 *)src;
          p->buf.array = (uint8 *)src;
        }
        v169 = v167->buf.cap;
        v170 = v167->buf.len;
        if ( v170 + 1 > v169 )
        {
          *(_DWORD *)&v[4] = v168;
          *(_DWORD *)&v[8] = v170;
          *(_DWORD *)&v[12] = v169;
          *(runtime_slice_0 *)&v[20] = runtime_growslice((runtime__type_0 *)&::i, *(runtime_slice_0 *)&v[4], v170 + 1);
          v168 = *(uint8 **)&v[20];
          v171 = *(_DWORD *)&v[24];
          p->buf.cap = *(_DWORD *)&v[28];
          if ( *(_DWORD *)&runtime_writeBarrier.enabled )
          {
            v245 = v168;
            v222 = v171;
            runtime_writebarrierptr((uintptr *)p, (uintptr)v168);
            v168 = v245;
            v171 = v222;
          }
          else
          {
            p->buf.array = v168;
          }
          v170 = v171;
          v167 = p;
        }
        v167->buf.len = v170 + 1;
        v168[v170] = 58;
      }
    }
    *(reflect_Value_0 *)&v[16] = fmt_getField(value, i_1);
    *(_DWORD *)&v[4] = *(_DWORD *)&v[16];
    *(_DWORD *)&v[8] = *(_DWORD *)&v[20];
    *(_DWORD *)&v[12] = *(_DWORD *)&v[24];
    fmt___ptr_pp__printValue(p, *(reflect_Value_0 *)&v[4], verb, depth + 1);
    v154 = i_1 + 1;
    typ = value.typ;
    ptr = value.ptr;
  }
  v177 = p;
  v178 = p->buf.array;
  v179 = p->buf.cap;
  v180 = p->buf.len;
  if ( v180 + 1 > v179 )
  {
    *(_DWORD *)&v[4] = p->buf.array;
    *(_DWORD *)&v[8] = v180;
    *(_DWORD *)&v[12] = v179;
    *(runtime_slice_0 *)&v[20] = runtime_growslice((runtime__type_0 *)&::i, *(runtime_slice_0 *)&v[4], v180 + 1);
    v181 = *(uint8 **)&v[20];
    v182 = *(_DWORD *)&v[24];
    v183 = p;
    p->buf.cap = *(_DWORD *)&v[28];
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
    {
      v241 = v181;
      v220 = v182;
      runtime_writebarrierptr((uintptr *)p, (uintptr)v181);
      v181 = v241;
      v182 = v220;
      v183 = p;
    }
    else
    {
      p->buf.array = v181;
    }
    v184 = v181;
    v177 = v183;
    v180 = v182;
    v178 = v184;
  }
  v177->buf.len = v180 + 1;
  v178[v180] = 125;
}
// 80BA7B0: variables would overlap: ^98.8 and stkvar "t.itab" ^98.4(has user info),stkvar "t.data" ^9C.4(has user info)

//----- (080BCE80) --------------------------------------------------------
void __golang fmt___ptr_pp__doPrintln(fmt_pp *p, __interface_{} a)
{
  __int32 v2; // eax
  interface_{} *array; // ecx
  void *data; // ebx
  runtime__type_0 *type; // ebp
  fmt_pp *v6; // esi
  __int32 cap; // edi
  uint8 *v8; // edx
  __int32 len; // eax
  uint8 *v10; // eax
  __int32 v11; // ecx
  fmt_pp *v12; // eax
  __int32 v13; // ecx
  uint8 *v14; // edx
  __int32 v15; // ebx
  uint8 *v16; // eax
  __int32 v17; // ecx
  fmt_pp *v18; // ebx
  runtime_slice_0 arg; // [esp+4h] [ebp-3Ch]
  runtime_slice_0 arga; // [esp+4h] [ebp-3Ch]
  runtime_slice_0 src; // [esp+14h] [ebp-2Ch]
  runtime_slice_0 srca; // [esp+14h] [ebp-2Ch]
  __int32 argNum; // [esp+20h] [ebp-20h]
  uint8 *arg_data; // [esp+30h] [ebp-10h]
  interface_{} *v25; // [esp+3Ch] [ebp-4h]

  v2 = 0;
  array = a.array;
  while ( v2 < a.len )
  {
    argNum = v2;
    v25 = array;
    data = array->data;
    type = array->_type;
    if ( v2 <= 0 )
    {
      v6 = p;
    }
    else
    {
      v6 = p;
      cap = p->buf.cap;
      v8 = p->buf.array;
      len = p->buf.len;
      if ( len + 1 > cap )
      {
        arg_data = (uint8 *)array->data;
        arg.array = p->buf.array;
        *(_QWORD *)&arg.len = __PAIR64__(cap, len);
        src = runtime_growslice((runtime__type_0 *)&i, arg, len + 1);
        v10 = (uint8 *)src.array;
        v11 = src.len;
        p->buf.cap = src.cap;
        if ( *(_DWORD *)&runtime_writeBarrier.enabled )
        {
          runtime_writebarrierptr((uintptr *)p, (uintptr)src.array);
          v10 = (uint8 *)src.array;
          v11 = src.len;
        }
        else
        {
          p->buf.array = (uint8 *)src.array;
        }
        data = arg_data;
        v6 = p;
        v8 = v10;
        len = v11;
      }
      v6->buf.len = len + 1;
      v8[len] = 32;
    }
    fmt___ptr_pp__printArg(v6, (interface_{})__PAIR64__((unsigned int)data, (unsigned int)type), 118);
    array = v25 + 1;
    v2 = argNum + 1;
  }
  v12 = p;
  v13 = p->buf.cap;
  v14 = p->buf.array;
  v15 = p->buf.len;
  if ( v15 + 1 > v13 )
  {
    arga.array = p->buf.array;
    *(_QWORD *)&arga.len = __PAIR64__(v13, v15);
    srca = runtime_growslice((runtime__type_0 *)&i, arga, v15 + 1);
    v16 = (uint8 *)srca.array;
    v17 = srca.len;
    v18 = p;
    p->buf.cap = srca.cap;
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
    {
      runtime_writebarrierptr((uintptr *)p, (uintptr)srca.array);
      v16 = (uint8 *)srca.array;
      v17 = srca.len;
      v18 = p;
    }
    else
    {
      p->buf.array = (uint8 *)srca.array;
    }
    v14 = v16;
    v12 = v18;
    v15 = v17;
  }
  v12->buf.len = v15 + 1;
  v14[v15] = 10;
}

//----- (080BD020) --------------------------------------------------------
interface_{} __golang fmt_glob__func1()
{
  interface_{} _r0; // [esp+Ch] [ebp+4h]

  _r0._type = (runtime__type_0 *)&stru_80DC3E0;
  _r0.data = runtime_newobject((runtime__type_0 *)&stru_80D9C00);
  return _r0;
}

//----- (080BD060) --------------------------------------------------------
void __golang fmt_init()
{
  string text; // [esp+0h] [ebp-10h]
  string texta; // [esp+0h] [ebp-10h]
  error_0 v2; // [esp+8h] [ebp-8h]
  error_0 v3; // [esp+8h] [ebp-8h]

  if ( LOBYTE(runtime_noptrbss[0].Lo) <= 1u )
  {
    if ( LOBYTE(runtime_noptrbss[0].Lo) == 1 )
      runtime_throwinit();
    LOBYTE(runtime_noptrbss[0].Lo) = 1;
    strconv_init();
    io_init();
    os_init();
    reflect_init();
    sync_init();
    text.str = (uint8 *)"syntax error scanning complex number";
    text.len = 36;
    v2 = errors_New(text);
    fmt_complexError.tab = v2.tab;
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr((uintptr *)&fmt_complexError.data, (uintptr)v2.data);
    else
      fmt_complexError.data = v2.data;
    texta.str = (uint8 *)"syntax error scanning boolean";
    texta.len = 29;
    v3 = errors_New(texta);
    fmt_boolError.tab = v3.tab;
    if ( *(_DWORD *)&runtime_writeBarrier.enabled )
      runtime_writebarrierptr((uintptr *)&fmt_boolError.data, (uintptr)v3.data);
    else
      fmt_boolError.data = v3.data;
    LOBYTE(runtime_noptrbss[0].Lo) = 2;
  }
}

//----- (080BD160) --------------------------------------------------------
uintptr __golang type__hash_fmt_fmt(fmt_fmt *p, uintptr h)
{
  uintptr seed; // [esp+Ch] [ebp-4h]

  seed = runtime_memhash(p, h, 0xDu);
  return runtime_memhash(&p->wid, seed, 0x4Cu);
}

//----- (080BD1D0) --------------------------------------------------------
bool __golang type__eq_fmt_fmt(fmt_fmt *p, fmt_fmt *q)
{
  bool v2; // cl
  bool v4; // [esp+Ch] [ebp-4h]

  if ( p->buf == q->buf )
  {
    runtime_memequal();
    v2 = v4;
  }
  else
  {
    v2 = 0;
  }
  if ( !v2 )
    return 0;
  runtime_memequal();
  return v4;
}
// 80BD21F: variable 'v4' is possibly undefined

//----- (080BD260) --------------------------------------------------------
void __cdecl main_main()
{
  __interface_{} a; // [esp+0h] [ebp-20h]
  __int32 v1; // [esp+Ch] [ebp-14h]
  error_0 v2; // [esp+10h] [ebp-10h]
  int v3[2]; // [esp+18h] [ebp-8h] BYREF

  v3[0] = (int)&t;
  v3[1] = (int)&main_statictmp_0;
  a.array = (interface_{} *)v3;
  *(_QWORD *)&a.len = 0x100000001LL;
  fmt_Println(a, v1, v2);
}
// 80BD2B0: variable 'v1' is possibly undefined
// 80BD2B0: variable 'v2' is possibly undefined

//----- (080BD2C0) --------------------------------------------------------
void __golang main_init()
{
  if ( main_initdone_ <= 1u )
  {
    if ( main_initdone_ == 1 )
      runtime_throwinit();
    main_initdone_ = 1;
    fmt_init();
    main_initdone_ = 2;
  }
}

// nfuncs=1745 queued=1722 decompiled=1722 lumina nreq=0 worse=0 better=0
#error "There were 17 decompilation failure(s) on 1722 function(s)"
