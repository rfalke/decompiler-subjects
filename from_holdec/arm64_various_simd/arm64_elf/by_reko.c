// subject_bss.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

byte g_b12018 = 0x00; // 0000000000012018
word64 high = 0x00; // 0000000000012050
word64 low = 0x00; // 0000000000012058
// subject_data.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

word64 g_qw12000 = 0x00012000; // 0000000000012000
Eq_289 g_a12008[] = // 0000000000012008
	{
	};
// subject_fini.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 0000000000000BF0: void _fini()
void _fini()
{
}

// subject_got.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

word64 g_qw11FA0 = 0x00; // 0000000000011FA0
<anonymous> * _init_GOT = _init; // 0000000000011FA8
word64 g_qw11FB0 = 0x00; // 0000000000011FB0
<anonymous> * g_ptr11FB8 = null; // 0000000000011FB8
union Eq_107 * g_ptr11FC0 = &g_t12050; // 0000000000011FC0
char * g_ptr11FC8 = &g_str0E30; // 0000000000011FC8
union Eq_108 * g_ptr11FD0 = &g_t12058; // 0000000000011FD0
<anonymous> * g_ptr11FD8 = null; // 0000000000011FD8
<anonymous> * main_GOT = main; // 0000000000011FE0
<anonymous> * _fini_GOT = _fini; // 0000000000011FE8
char * g_ptr11FF0 = &g_str0DF8; // 0000000000011FF0
word64 g_qw11FF8 = 0x00; // 0000000000011FF8
// subject_init.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 0000000000000630: void _init()
void _init()
{
}

// subject_rodata.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

Eq_397 g_t0DF8 = // 0000000000000DF8
	{
		
		{
			0x4C, 0x6F, 0x72, 0x65, 0x6D, 0x20, 0x49, 0x70, 0x73, 0x75, 0x6D, 0x20, 0x69, 0x73, 0x20, 0x73, 
		}
	};
Eq_396 g_t0E30 = // 0000000000000E30
	{
		
		{
			0x4C, 0x6F, 0x52, 0x65, 0x6D, 0x20, 0x69, 0x50, 0x53, 0x55, 0x4D, 0x20, 0x69, 0x73, 0x20, 0x73, 
		}
	};
// subject_text.c
// Generated by decompiling subject.exe
// using Reko decompiler version VERSION

#include "subject.h"

// 00000000000006C0: void _start(Register (ptr64 void) x6)
void _start(void * x6)
{
	int32 * fp;
	_start_c(fp, x6);
}

// 00000000000006DC: void _start_c(Register (ptr64 int32) x0, Register (ptr64 void) x6)
// Called from:
//      _start
void _start_c(int32 * x0, void * x6)
{
	__libc_start_main(main_GOT, *x0, x0 + 2, _init_GOT, _fini_GOT, null, x6);
}

// 0000000000000704: void deregister_tm_clones()
// Called from:
//      __do_global_dtors_aux
void deregister_tm_clones()
{
	if (&g_b12018 == &g_b12018)
		return;
	<anonymous> * x1_12 = g_ptr11FD8;
	if (x1_12 == null)
		return;
	word64 x16_18;
	x1_12();
}

// 0000000000000734: void register_tm_clones()
// Called from:
//      frame_dummy
void register_tm_clones()
{
	if ((&g_b12018 - &g_b12018 >> 3) / 0x02 == 0x00)
		return;
	<anonymous> * x2_13 = g_ptr11FB8;
	if (x2_13 == null)
		return;
	word64 x16_19;
	x2_13();
}

// 0000000000000770: void __do_global_dtors_aux()
void __do_global_dtors_aux()
{
	if ((word32) g_b12018 != 0x00)
		return;
	struct Eq_56 * x19_15 = &g_qw12000;
	if (g_qw11FA0 != 0x00)
		__cxa_finalize(&g_qw12000, g_qw12000);
	deregister_tm_clones();
	if (g_qw11FB0 != 0x00)
		__deregister_frame_info(null, 0x0EA0);
	x19_15->b0018 = 0x01;
}

// 00000000000007D8: void frame_dummy()
void frame_dummy()
{
	if (g_qw11FF8 != 0x00)
		__register_frame_info(null, 0x0EA0, &g_qw12000, 0x00012020);
	register_tm_clones();
}

// 0000000000000808: Register real64 dump(Register (ptr64 char) x0)
// Called from:
//      main
real64 dump(char * x0)
{
	int32 dwLoc2E;
	word16 wLoc2A;
	real64 d0;
	word16 wLoc2C_168 = SLICE(dwLoc2E, word16, 16);
	printf("===== %s\n", x0);
	printf("x1/x0 (high/low):       0x%016lx 0x%016lx\n", g_ptr11FC0->u0, g_ptr11FD0->u0);
	printf("memory:                 0x");
	word16 wLoc28_172 = (word16) x0;
	int32 dwLoc1C_138 = 0x00;
	while (true)
	{
		int32 dwLoc2C_169 = SEQ(wLoc2A, wLoc2C_168);
		if (dwLoc1C_138 > 0x0F)
			break;
		printf("%02x", (word32) (&g_a12008->u0)[(int64) dwLoc2E]);
		if (dwLoc1C_138 == 0x07)
			printf(" 0x");
		++dwLoc1C_138;
	}
	puts("");
	printf("as float (s, 4 byte):   ");
	int32 dwLoc18_144 = 0x00;
	while (true)
	{
		int32 dwLoc2A_175 = SEQ(wLoc28_172, wLoc2A);
		if (dwLoc18_144 > 0x03)
			break;
		d0 = (real64) (&g_a12008->u2)[(int64) dwLoc2C_169 * 4];
		printf("[%d]=%f ", dwLoc18_144, d0);
		++dwLoc18_144;
	}
	puts("");
	printf("as double (d, 8 byte):  ");
	int32 dwLoc14_150;
	for (dwLoc14_150 = 0x00; dwLoc14_150 <= 0x01; ++dwLoc14_150)
	{
		d0 = (&g_a12008->u1)[(int64) dwLoc2A_175 * 8];
		printf("[%d]=%f ", dwLoc14_150, d0);
	}
	puts("");
	puts("");
	return d0;
}

// 00000000000009A8: void main(Register (ptr128 (arr Eq_423)) q0)
void main(Eq_423 (* q0)[])
{
	word64 q0_64_64_35 = SLICE(q0, word64, 64);
	fn0000000000000AB0(g_ptr11FC0, g_ptr11FD0, g_a12008, q0);
	fn0000000000000AD4(g_ptr11FC0, g_ptr11FD0, g_a12008, SEQ(q0_64_64_35, dump("2x double values of 0.75")));
	dump("4x float values of 0.75");
	fn0000000000000AF8(g_ptr11FC0, g_ptr11FD0, g_a12008);
	dump("4x float values of 123, 456, 789, 543 divided by 100");
	fn0000000000000B50(g_ptr11FC0, g_ptr11FD0, g_a12008);
	dump("4x float values of 123, 456, 789, 543 divided by 100 and than add 2 to every byte");
	printf("first input:  '%s'\n", g_ptr11FF0);
	printf("second input: '%s'\n", g_ptr11FC8);
	fn0000000000000BB8(g_ptr11FC0, g_ptr11FD0, g_a12008);
	dump("compare first 16 bytes of two strings (ff=eq, 00=ne)");
}

// 0000000000000AB0: void fn0000000000000AB0(Register (ptr64 Eq_107) x0, Register (ptr64 Eq_108) x1, Register (arr Eq_289) x2, Register (arr Eq_423) q0)
// Called from:
//      main
void fn0000000000000AB0(union Eq_107 * x0, union Eq_108 * x1, Eq_289 x2[], Eq_423 q0[])
{
	x2[0].u3 = (Eq_429 (*)[]) SEQ(q0[0].t0000.u1, (word64) q0);
	x0->u1 = q0[0].t0000.u1;
	x1->u1 = (word64) (word64) q0;
}

// 0000000000000AD4: void fn0000000000000AD4(Register (ptr64 Eq_107) x0, Register (ptr64 Eq_108) x1, Register (arr Eq_289) x2, Register (arr Eq_427) q0)
// Called from:
//      main
void fn0000000000000AD4(union Eq_107 * x0, union Eq_108 * x1, Eq_289 x2[], Eq_427 q0[])
{
	Eq_289 q0_4 = __dup<word32,word32[4]>(q0[0].r0000);
	x2[0].u3 = (Eq_429 (*)[]) q0_4;
	x0->u1 = (word64) *((word128) q0_4 + 1);
	x1->u1 = (word64) (word64) q0_4;
}

// 0000000000000AF8: void fn0000000000000AF8(Register (ptr64 Eq_107) x0, Register (ptr64 Eq_108) x1, Register (arr Eq_289) x2)
// Called from:
//      main
void fn0000000000000AF8(union Eq_107 * x0, union Eq_108 * x1, Eq_289 x2[])
{
	word96 q0_96_32;
	Eq_289 q0_26 = __simd_fdiv<real32[4]>(SEQ(543.0F, (word96) SEQ(SLICE(q0_96_32, word32, 64), 789.0F, (word64) SEQ(SLICE(q0_96_32, word64, 32), 456.0F, 123.0F))), __dup<word32,word32[4]>(100.0F));
	x2[0].u3 = (Eq_429 (*)[]) q0_26;
	x0->u1 = (word64) *((word128) q0_26 + 1);
	x1->u1 = (word64) (word64) q0_26;
}

// 0000000000000B50: void fn0000000000000B50(Register (ptr64 Eq_107) x0, Register (ptr64 Eq_108) x1, Register (arr Eq_289) x2)
// Called from:
//      main
void fn0000000000000B50(union Eq_107 * x0, union Eq_108 * x1, Eq_289 x2[])
{
	word96 q0_96_32;
	Eq_289 q0_34 = __simd_add<byte[16]>(__simd_fdiv<real32[4]>(SEQ(543.0F, (word96) SEQ(SLICE(q0_96_32, word32, 64), 789.0F, (word64) SEQ(SLICE(q0_96_32, word64, 32), 456.0F, 123.0F))), __dup<word32,word32[4]>(100.0F)), __dup<byte,byte[16]>(0x02));
	x2[0].u3 = (Eq_429 (*)[]) q0_34;
	x0->u1 = (word64) *((word128) q0_34 + 1);
	x1->u1 = (word64) (word64) q0_34;
}

// 0000000000000BB8: void fn0000000000000BB8(Register (ptr64 Eq_107) x0, Register (ptr64 Eq_108) x1, Register (arr Eq_289) x2)
// Called from:
//      main
void fn0000000000000BB8(union Eq_107 * x0, union Eq_108 * x1, Eq_289 x2[])
{
	Eq_289 q0_12 = __cmeq<byte[16]>(g_t0E30.u0, g_t0DF8.u0);
	x2[0].u3 = (Eq_429 (*)[]) q0_12;
	x0->u1 = (word64) *((word128) q0_12 + 1);
	x1->u1 = (word64) (word64) q0_12;
}

