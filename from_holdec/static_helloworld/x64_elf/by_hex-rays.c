/* This file was generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2020 Hex-Rays <info@hex-rays.com>

   Detected compiler: GNU C++
*/

#include <defs.h>

#include <stdarg.h>


//-------------------------------------------------------------------------
// Function declarations

__int64 __fastcall strcpy_ifunc(_QWORD, _QWORD); // weak
__int64 __fastcall j_strnlen(_QWORD, _QWORD); // weak
__int64 __fastcall j_memmove(_QWORD, _QWORD, _QWORD); // weak
__int64 __fastcall j_rawmemchr(_QWORD, _QWORD); // weak
__int64 __fastcall j_memcpy(_QWORD, _QWORD, _QWORD); // weak
__int64 __fastcall j_wcslen(_QWORD); // weak
__int64 __fastcall j_strrchr_ifunc(_QWORD, _QWORD); // weak
__int64 __fastcall j_stpcpy(_QWORD); // weak
__int64 __fastcall j_strchrnul(_QWORD, _QWORD); // weak
__int64 __fastcall j_memchr_ifunc(_QWORD, _QWORD, _QWORD); // weak
__int64 __fastcall j_strstr(_QWORD, _QWORD); // weak
__int64 __fastcall j_strncmp_ifunc(_QWORD, _QWORD, _QWORD); // weak
__int64 __fastcall j_memcmp_ifunc(_QWORD, _QWORD, _QWORD); // weak
__int64 __fastcall j_strcasecmp_l(_QWORD, _QWORD, _QWORD); // weak
__int64 __fastcall j_memset_ifunc(_QWORD, _QWORD, _QWORD); // weak
__int64 __fastcall j_wcsnlen(_QWORD, _QWORD); // weak
__int64 __fastcall j_strcmp_ifunc(_QWORD, _QWORD); // weak
__int64 __fastcall j_wmemset(_QWORD, _QWORD, _QWORD); // weak
__int64 __fastcall j_mempcpy(_QWORD, _QWORD, _QWORD); // weak
__int64 __fastcall j_strcspn_ifunc(_QWORD, _QWORD); // weak
__int64 __fastcall j_strspn_ifunc(_QWORD, _QWORD); // weak
__int64 __fastcall j_strlen_ifunc(_QWORD); // weak
__int64 __fastcall j_strchr_ifunc(_QWORD, _QWORD); // weak
void __fastcall __noreturn _assert_fail_base_cold_0(__int64 a1, __int64 a2, __int64 a3, __int64 a4, u32 *a5, unsigned __int64 a6, int a7, __int64 a8);
void __fastcall __noreturn nl_load_domain_cold_0(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD); // weak
void __fastcall __noreturn abort(__int64, __int64 _RSI, __int64, __int64, u32 *, u32);
void __fastcall __noreturn IO_new_fclose_cold_0(); // weak
void __fastcall __noreturn IO_fflush_cold_0(); // weak
void __fastcall __noreturn IO_puts_cold_0(); // weak
void __fastcall __noreturn IO_wfile_underflow_cold_2(); // weak
void __fastcall __noreturn IO_new_file_underflow_cold_6(); // weak
void __fastcall __noreturn dl_start(__int64, __int64, __int64, __int64, u32 *, u32);
void __fastcall __noreturn IO_fwrite_cold_0(); // weak
void __fastcall __noreturn IO_getdelim_cold_0(); // weak
void __noreturn read_encoded_value_with_base_cold_5(void); // weak
void __fastcall __noreturn execute_cfa_program_cold_6(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD); // weak
void __fastcall __noreturn uw_update_context_1_cold_8(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD); // weak
void __noreturn uw_init_context_1_cold_9(void); // weak
void __noreturn uw_update_context_cold_10(void); // weak
void __noreturn Unwind_RaiseException_Phase2_cold_11(void); // weak
void __fastcall __noreturn uw_install_context_1_cold_12(_QWORD, _QWORD); // weak
void __noreturn Unwind_GetGR_cold_13(void); // weak
void __noreturn Unwind_SetGR_cold_14(void); // weak
void __noreturn Unwind_Resume_cold_15(void); // weak
void __noreturn Unwind_Resume_or_Rethrow_cold_16(void); // weak
void __noreturn read_encoded_value_with_base_cold_8(void); // weak
void __noreturn read_encoded_value_with_base_cold_0(void); // weak
__int64 *__fastcall fini(__int64, __int64, __int64, __int64, u32 *, unsigned __int64);
int __cdecl main(int argc, const char **argv, const char **envp);
__int64 init_cacheinfo();
__int16 __fastcall get_common_indeces_constprop_1(unsigned int *, int *, unsigned int *, _DWORD *);
__int64 __fastcall check_one_fd(unsigned int, int, unsigned __int64);
__int64 __fastcall _libc_check_standard_fds(__int64, __int64, unsigned __int64);
unsigned __int64 _libc_setup_tls();
void __fastcall __noreturn _assert_fail_base(unsigned __int64, __int64, __int64, unsigned int, unsigned __int8 *, __int64, int, __int64);
void __fastcall __noreturn _assert_fail(__int64, __int64, unsigned int, unsigned __int8 *);
unsigned __int8 *__fastcall dcgettext(char *, unsigned __int8 *, unsigned int);
__int64 __fastcall plural_eval(_DWORD *, __int64);
__int64 __fastcall transcmp(__int64, __int64);
unsigned __int64 __fastcall plural_lookup_isra_2(__int64, __int64, unsigned __int64, __int64);
__int64 __fastcall nl_find_msg(__int64, __off_t, unsigned __int8 *, unsigned int, u32 *);
unsigned __int8 *__fastcall _dcigettext(char *, unsigned __int8 *, __int64, int, __int64, unsigned int);
__int64 *__fastcall nl_find_domain(__int64 a1, __int64 a2, __int64 a3, __off_t a4);
unsigned __int64 __fastcall nl_load_domain(__int64 a1, __off_t _RSI, __int64 a3, __int64 a4, u32 *a5, unsigned __int64 a6);
__int64 __fastcall alias_compare(_QWORD *, _QWORD *);
__int64 __fastcall read_alias_file(__int64, int);
__int64 __fastcall nl_expand_alias(__int64, __int64, __int64, __int64, u32 *, u32);
__int64 *__fastcall nl_make_l10nflist(__int64 **a1, __int64 a2, __int64 a3, int a4, __int64 a5, __int64 a6, __int64 a7, __int64 a8, __int64 a9, __int64 a10, int a11);
_DWORD *__fastcall nl_normalize_codeset(unsigned __int8 *, unsigned __int64, _QWORD *, __int64, u32 *, __int64);
__int64 __fastcall nl_explode_name(unsigned __int8 *, unsigned __int8 **, _QWORD *, unsigned __int8 **, _QWORD *, _QWORD *);
void __fastcall _gettext_free_exp(int *, __int64, __int64, __int64, u32 *, unsigned __int64);
int *__fastcall new_exp(int a1, __int64 a2, _QWORD *a3, __int64 a4, u32 *a5, unsigned __int64 a6);
__int64 __fastcall _gettextparse(unsigned __int8 **, __int64, __int64, __int64, __int64, unsigned __int8 *);
unsigned __int64 __fastcall _gettext_extract_plural(__int64, unsigned __int8 **, unsigned __int64 *);
unsigned __int64 __fastcall _hash_string(unsigned __int8 *);
int setjmp(jmp_buf env);
__int64 __fastcall raise(int sig); // idb
__int64 __fastcall msort_with_tmp_part_0(__int64 *, _QWORD *, unsigned __int64);
unsigned __int64 __fastcall qsort_r(char *a1, __int64 a2, unsigned __int64 a3, int (__fastcall *a4)(char *, char *, __int64), u32 *a5, unsigned __int64 a6);
unsigned __int64 __fastcall qsort(char *, __int64, unsigned __int64, int (__fastcall *)(char *, char *, __int64), __int64, unsigned __int64);
char *__fastcall getenv(_BYTE *);
void __fastcall __noreturn _run_exit_handlers(int *status, _QWORD **a2, __int64 a3, __int64 a4, u32 *a5, unsigned __int64 a6);
void __fastcall __noreturn exit(int *a1, __int64 a2, __int64 a3, __int64 a4, u32 *a5, unsigned __int64 a6);
u32 *__fastcall _new_exitfn(u32 **);
__int64 __fastcall _internal_atexit(__int64, __int64, __int64, __int64, u32 *, u32);
int __fastcall _cxa_atexit(void (__fastcall *lpfunc)(void *), void *obj, void *lpdso_handle);
unsigned __int64 __fastcall _strtoull_internal(char *, char **, int, int);
unsigned __int64 __fastcall strtouq(char *, char **, int);
unsigned __int64 __fastcall ___strtoull_l_internal(char *, char **, int, int, __int64);
unsigned __int64 __fastcall strtoull_l(char *, char **, int, __int64);
unsigned __int64 __fastcall _correctly_grouped_prefixmb(unsigned __int64, unsigned __int64, char *, char *);
__int64 printf(unsigned __int64, ...);
__int64 asprintf(__int64 *, unsigned __int64, ...);
__int64 __fastcall locked_vfxprintf(__int64 a1, __int64 a2, __m128i *a3);
__int64 _fxprintf(_QWORD *a1, __int64 a2, ...);
__int64 _fxprintf_nocancel(_QWORD *a1, __int64 a2, ...);
__int64 __fastcall fclose(__int64 a1, __int64 _RSI, __int64 a3, unsigned int *a4, u32 *a5, unsigned __int64 a6);
__int64 __fastcall fflush(__int64, unsigned __int64 _RSI, __int64, __int64, __int64 _R8, unsigned __int64);
__int64 __fastcall _fopen_maybe_mmap(__int64);
__int64 __fastcall _fopen_internal(const char *, _BYTE *, _QWORD *, __int64, u32 *, __int64);
__int64 __fastcall fopen64(const char *, _BYTE *, __int64, __int64, u32 *, __int64);
__int64 __fastcall puts(__int64, __int64 _RSI);
__int64 __fastcall adjust_wide_data(__int64, char);
__int64 __fastcall IO_wfile_underflow(__int64, unsigned __int64 _RSI, __int64, __int64, void *, unsigned __int64 _R9);
__int64 __fastcall IO_wfile_seekoff(__int64, __int64, unsigned int, __int64, u32 *, unsigned __int64);
__int64 __fastcall IO_wfile_underflow_maybe_mmap(__int64, __int64, __int64, __int64, u32 *, __int64);
__int64 __fastcall IO_wfile_underflow_mmap(__int64, __int64, __int64, __int64, u32 *, __int64);
__int64 __fastcall IO_wdo_write(__int64, __int64, __int64, __int64, u32 *);
__int64 __fastcall IO_wfile_overflow(unsigned int *, __int64, __int64, __int64, u32 *, unsigned __int64);
__int64 __fastcall IO_wfile_sync(__int64, __int64, __int64, __int64, u32 *, __int64);
unsigned __int64 __fastcall IO_wfile_xsputn(__int64, unsigned __int64, unsigned __int64, unsigned __int64, u32 *, __int64);
__int64 __fastcall vasprintf(__int64 *, unsigned __int64, __m128i *, __int64, u32 *, __int64);
unsigned __int64 __fastcall _libc_message(char, size_t iov_base, __int64, __int64, u32 *, __int64, char);
void __fastcall __noreturn _libc_fatal(__int64, __int64, __int64, __int64, u32 *, __int64);
void __fastcall IO_vtable_check(__int64, __int64, __int64, __int64, u32 *, __int64);
__int64 __fastcall fgets_unlocked(__int64, int, int *);
__int64 __fastcall IO_file_seekoff_maybe_mmap(__int64, __int64, __int64, __int64, u32 *, __int64);
unsigned __int64 __fastcall IO_file_close(__int64);
_QWORD *__fastcall IO_new_file_setbuf(_QWORD *a1, __int64 a2, __int64 a3, __int64 a4, u32 *a5, __int64 a6);
_QWORD *__fastcall IO_file_setbuf_mmap(_QWORD *a1, __int64 a2, __int64 a3, __int64 a4, u32 *a5, __int64 a6);
__int64 __fastcall new_do_write(__int64, __int64, __int64, __int64, u32 *, __int64);
__int64 __fastcall IO_new_file_underflow(__int64, __int64 _RSI, __int64, __int64, void *, unsigned __int64 _R9);
unsigned __int64 __fastcall IO_file_close_mmap(__int64);
__int64 __fastcall mmap_remap_check(__int64, __int64, __int64, __int64, u32 *, __int64);
unsigned __int64 __fastcall IO_file_seek(__int64, off_t, unsigned int);
__int64 __fastcall IO_file_sync_mmap(__int64);
unsigned __int64 __fastcall decide_maybe_mmap(__int64, __int64, __int64, __int64, u32 *, __int64);
__int64 __fastcall IO_file_underflow_maybe_mmap(__int64, __int64, __int64, __int64, u32 *, __int64);
__int64 __fastcall IO_file_xsgetn_maybe_mmap(__int64, __int64, __int64, __int64, u32 *, __int64);
__int64 __fastcall IO_new_file_seekoff(__int64, char *, unsigned int, u32 *, u32 *, unsigned __int64);
unsigned __int64 __fastcall IO_file_stat(__int64, struct stat *);
__int64 __fastcall IO_new_file_write(__int64, const char *, __int64);
__int64 __fastcall IO_file_xsgetn_mmap(__int64, __int64, unsigned __int64, __int64, u32 *, __int64);
unsigned __int64 __fastcall IO_file_xsgetn(__int64, __int64, __int64, __int64, u32 *, unsigned __int64);
__int64 __fastcall IO_file_seekoff_mmap(__int64, __int64, int, __int64, u32 *, __int64);
__int64 __fastcall IO_file_underflow_mmap(__int64, __int64, __int64, __int64, u32 *, __int64);
unsigned __int64 __fastcall IO_file_read(__int64, char *, size_t);
unsigned __int64 __fastcall IO_new_file_xsputn(_QWORD *, unsigned __int64, unsigned __int64, __int64, u32 *, __int64);
unsigned __int64 __fastcall IO_new_file_init_internal(__int64, __int64, __int64, __int64, __int64, u32);
unsigned __int64 __fastcall IO_new_file_init(__int64, __int64, __int64, __int64, __int64, u32);
int *__fastcall IO_file_open(int *, const char *, unsigned int, int, __int16);
__int64 __fastcall IO_new_file_attach(__int64, __int64, __int64, __int64, u32 *, __int64);
__int64 __fastcall IO_new_do_write(__int64, __int64, __int64, __int64, u32 *, __int64);
__int64 __fastcall IO_new_file_close_it(__int64 a1, __int64 a2, __int64 a3, __int64 a4, u32 *a5, unsigned __int64 a6);
int *__fastcall IO_new_file_fopen(__int64, const char *, _BYTE *);
__int64 *__fastcall IO_new_file_finish(__int64, __int64, __int64, unsigned int *, u32 *, unsigned __int64);
__int64 __fastcall IO_new_file_overflow(unsigned int *, __int64, __int64, __int64, u32 *, unsigned __int64);
__int64 __fastcall IO_new_file_sync(__int64, __int64, __int64, __int64, u32 *, __int64);
__int64 __fastcall save_for_backup(_QWORD *, __int64, __int64, __int64, __int64, __int64);
__int64 __fastcall flush_cleanup(__int64, __int64, __int64, __int64, u32 *, u32);
unsigned __int64 __fastcall IO_un_link_part_2(unsigned int *, __int64, __int64, unsigned int *, u32 *, u32);
unsigned __int64 __fastcall IO_un_link(unsigned int *, __int64, __int64, unsigned int *, u32 *, u32);
unsigned __int64 __fastcall IO_link_in(_QWORD *, __int64 _RSI, __int64, __int64, __int64 _R8, u32);
__int64 __fastcall IO_least_marker(__int64, __int64);
__int64 __fastcall IO_switch_to_main_get_area(__int64);
__int64 __fastcall IO_switch_to_backup_area(__int64);
__int64 __fastcall IO_switch_to_get_mode(__int64, __int64, __int64, __int64, u32 *, __int64);
__int64 *__fastcall IO_free_backup_area(int *, __int64, __int64, __int64, u32 *, unsigned __int64);
__int64 __fastcall _overflow(__int64, __int64, __int64, __int64, u32 *, __int64);
__int64 __fastcall _underflow(__int64 a1, __int64 a2, __int64 a3, unsigned __int64 a4, u32 *a5, unsigned __int64 a6);
__int64 __fastcall _uflow(__int64 a1, __int64 a2, __int64 a3, unsigned __int64 a4, u32 *a5, unsigned __int64 a6);
__int64 __fastcall IO_setb(int *, __int64, __int64, __int64, u32 *, unsigned __int64);
void __fastcall IO_doallocbuf(__int64, __int64, __int64, __int64, u32 *, __int64);
__int64 __fastcall IO_default_underflow(); // weak
__int64 __fastcall IO_default_uflow(__int64, __int64, __int64, __int64, u32 *, __int64);
unsigned __int64 __fastcall IO_default_xsputn(_QWORD *, __int64, unsigned __int64, __int64, u32 *, __int64);
__int64 __fastcall IO_sgetn(__int64, __int64, __int64, __int64, __int64, __int64);
__int64 __fastcall IO_default_xsgetn(__int64 a1, __int64 a2, __int64 a3, unsigned __int64 a4, u32 *a5, unsigned __int64 a6);
__int64 __fastcall IO_default_setbuf(__int64, __int64, __int64, __int64, u32 *, __int64);
__int64 __fastcall IO_default_seekpos(__int64, __int64, __int64, __int64, __int64, __int64);
__int64 __fastcall IO_default_doallocate(unsigned int *, __int64, _QWORD *, __int64, u32 *, __int64);
unsigned __int64 IO_enable_locks();
_QWORD *__fastcall IO_old_init(__int64, int);
_QWORD *__fastcall IO_init_internal(__int64, int);
_QWORD *__fastcall IO_init(__int64, int);
_QWORD *__fastcall IO_no_init(__int64, int);
__int64 __fastcall IO_default_sync(); // weak
__int64 *__fastcall IO_default_finish(__int64, __int64, __int64, unsigned int *, u32 *, unsigned __int64);
__int64 __fastcall IO_default_seekoff(); // weak
__int64 __fastcall IO_sputbackc(__int64, __int64, __int64, __int64, u32 *, __int64);
__int64 __fastcall IO_sungetc(__int64, __int64, __int64, __int64, u32 *, __int64);
__int64 __fastcall IO_adjust_column(int, unsigned __int64, int);
__int64 __fastcall IO_flush_all_lockp(__int64 *, unsigned __int64 _RSI, __int64, __int64, u32 *, __int64);
__int64 __fastcall IO_cleanup(__int64, __int64 _RSI, __int64, __int64, u32 *, __int64);
__int64 __fastcall IO_flush_all(__int64, unsigned __int64, __int64, __int64, u32 *, __int64);
unsigned __int64 __fastcall flushlbf(__int64 *, __int64 _RSI, __int64, __int64, u32 *, __int64);
__int64 __fastcall IO_init_marker(__int64, unsigned int *, __int64, __int64, u32 *, __int64);
_QWORD *__fastcall IO_remove_marker(_QWORD *);
__int64 __fastcall IO_marker_difference(__int64, __int64);
__int64 __fastcall IO_marker_delta(__int64);
__int64 __fastcall IO_seekmark(int *, __int64);
__int64 *__fastcall IO_unsave_markers(int *, __int64, __int64, __int64, u32 *, unsigned __int64);
__int64 __fastcall IO_default_pbackfail(_QWORD *, __int64, _QWORD *, __int64, u32 *, __int64);
__int64 __fastcall IO_default_seek(); // weak
__int64 __fastcall IO_default_stat(); // weak
__int64 __fastcall IO_default_read(); // weak
__int64 __fastcall IO_default_write(); // weak
__int64 __fastcall IO_default_showmanyc(); // weak
void IO_default_imbue();
void *IO_iter_begin();
__int64 __fastcall IO_iter_end(); // weak
__int64 __fastcall IO_iter_next(__int64);
__int64 __fastcall IO_iter_file(__int64);
__int64 __fastcall IO_list_lock(__int64, __int64, __int64, __int64, u32 *, u32);
signed __int64 __fastcall IO_list_unlock(__int64, __int64, __int64, __int64, u32 *, u32);
void IO_list_resetlock();
__int64 __fastcall IO_str_underflow(int *);
__int64 __fastcall IO_str_overflow(__int64, __int64, __int64, __int64, u32 *, __int64);
__int64 __fastcall enlarge_userbuf(__int64, __int64, _QWORD *, __int64, u32 *, __int64);
__int64 __fastcall IO_str_seekoff(__int64, __int64, int, __int64, u32 *, __int64);
__int64 __fastcall IO_str_pbackfail(_QWORD *, __int64, _QWORD *, __int64, u32 *, __int64);
__int64 *__fastcall IO_str_finish(__int64, __int64, __int64, unsigned int *, u32 *, unsigned __int64);
__int64 __fastcall IO_str_init_static_internal(__int64, unsigned __int64, __int64, __int64, u32 *, unsigned __int64);
__int64 __fastcall IO_str_init_static(__int64, unsigned __int64, int, __int64, u32 *, unsigned __int64);
__int64 __fastcall IO_str_init_readonly(_DWORD *, unsigned __int64, int, __int64, u32 *, unsigned __int64);
unsigned __int64 __fastcall IO_str_count(_QWORD *);
_BOOL8 __fastcall _libc_alloca_cutoff(unsigned __int64);
__int64 __fastcall _lll_lock_wait_private(u32 *, __int64, __int64, __int64, u32 *, u32);
signed __int64 __fastcall _lll_unlock_wake_private(u32 *, __int64, __int64, __int64, u32 *, u32);
__int64 __fastcall dl_tunable_set_arena_max(__int64 *);
__int64 __fastcall dl_tunable_set_arena_test(__int64 *);
unsigned __int64 __fastcall dl_tunable_set_tcache_max(unsigned __int64 *);
__int64 __fastcall dl_tunable_set_tcache_count(__int64 *);
__int64 __fastcall dl_tunable_set_tcache_unsorted_limit(__int64 *);
__int64 __fastcall mem2mem_check(__int64, unsigned __int64);
unsigned __int64 __fastcall mem2chunk_check(__int64, _QWORD *);
int *__fastcall int_mallinfo(__int64, __int64);
int *__fastcall malloc_init_state(__int64);
__int64 __fastcall dl_tunable_set_trim_threshold(__int64 *);
__int64 __fastcall dl_tunable_set_top_pad(__int64 *);
__int64 __fastcall dl_tunable_set_mmap_threshold(__int64 *);
__int64 __fastcall dl_tunable_set_mmaps_max(__int64 *);
__int64 __fastcall dl_tunable_set_perturb_byte(__int64 *);
void __fastcall __noreturn _malloc_assert(const char *, __int64, unsigned int, __int64);
void __fastcall detach_arena(__int64 a1);
unsigned __int64 __fastcall get_free_list(__int64 a1, __int64 a2, __int64 a3, __int64 a4, u32 *a5, u32 a6);
__int64 *__fastcall malloc_printerr(__int64, __int64, __int64, __int64, u32 *, __int64);
__int64 *__fastcall top_check(__int64, __int64, __int64, __int64, u32 *, __int64);
__int64 *__fastcall malloc_consolidate(const char *, __int64, __int64, _QWORD *, unsigned __int64);
unsigned __int64 __fastcall new_heap(unsigned __int64, __int64);
__int64 *__fastcall munmap_chunk(__int64 *, __int64, __int64, __int64, __int64, __int64);
__int64 *__fastcall mremap_chunk(__int64 *a1, __int64 a2);
unsigned __int64 ptmalloc_init_part_0();
int *__fastcall arena_get2_part_4(__int64, __int64, __int64, __int64, u32 *, u32);
u32 *__fastcall arena_get_retry(volatile signed __int32 *a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, u32 a6);
__int64 (__fastcall *__fastcall dl_tunable_set_mallopt_check(unsigned int *))(unsigned __int64 a1, int *a2, __int64 a3, __int64 a4, u32 *a5, __int64 a6, double a7);
__int64 __fastcall _malloc_info_part_8(__int64);
__int64 __fastcall systrim_isra_1_constprop_9(unsigned __int64, __int64);
unsigned __int64 __fastcall int_free(__int64, unsigned __int64 _RSI, unsigned __int64, __int64, unsigned __int64, unsigned __int64);
_QWORD *__fastcall sysmalloc(unsigned __int64 a1, __int64 a2);
_QWORD *__fastcall int_malloc(int *, unsigned __int64 j, __int64, __int64, unsigned __int64, __int64);
__int64 __fastcall malloc_check(int *, __int64, __int64, __int64, u32 *, __int64);
_QWORD *__fastcall tcache_init_part_5(__int64 a1, __int64 a2, __int64 a3, __int64 a4, u32 *a5, __int64 a6);
_QWORD *__fastcall int_memalign(int *, __int64, unsigned __int64, __int64, unsigned __int64, __int64, double);
__int64 __fastcall memalign_check(unsigned __int64, int *, __int64, __int64, u32 *, __int64, double);
__int64 *__fastcall free_check_part_2(__int64, __int64, __int64, __int64, u32 *, u32);
__int64 *__fastcall free_check(__int64, __int64, __int64, __int64, u32 *, u32);
_QWORD *__fastcall int_realloc(__int64, unsigned __int64, unsigned __int64, unsigned __int64, u32 *, unsigned __int64);
__int64 __fastcall realloc_check(int *, int *, __int64, __int64, u32 *, __int64);
__int64 __fastcall _malloc_fork_lock_parent(__int64, __int64, __int64, __int64, u32 *, u32);
signed __int64 __fastcall _malloc_fork_unlock_parent(__int64, __int64, __int64, __int64, u32 *, u32);
int *_malloc_fork_unlock_child();
__int64 (__fastcall *_malloc_check_init())(unsigned __int64 a1, int *a2, __int64 a3, __int64 a4, u32 *a5, __int64 a6, double a7);
_QWORD *__fastcall malloc(unsigned __int64 a1, __int64 a2, _QWORD *a3, __int64 a4, u32 *a5, __int64 a6);
_QWORD *__fastcall malloc_hook_ini(unsigned __int64 a1, __int64 a2, _QWORD *a3, __int64 a4, u32 *a5, __int64 a6);
_QWORD *__fastcall mid_memalign(unsigned __int64 a1, unsigned __int64 a2, _QWORD *a3, __int64 a4, u32 *a5, __int64 a6, double a7);
_QWORD *__fastcall memalign_hook_ini(unsigned __int64 a1, unsigned __int64 a2, double a3, __int64 a4, __int64 a5, u32 *a6, __int64 a7);
__int64 *__fastcall free(__int64, __int64, __int64, __int64, u32 *, unsigned __int64);
signed __int64 __fastcall _malloc_arena_thread_freeres(__int64, __int64, __int64, __int64, u32 *, unsigned __int64);
__int64 *__fastcall realloc(__int64 a1, unsigned __int64 a2, _QWORD *a3, __int64 a4, u32 *a5, unsigned __int64 a6);
__int64 *__fastcall realloc_hook_ini(__int64 a1, unsigned __int64 a2, _QWORD *a3, __int64 a4, u32 *a5, unsigned __int64 a6);
_QWORD *__fastcall memalign(unsigned __int64 a1, unsigned __int64 a2, double a3, __int64 a4, __int64 a5, u32 *a6, __int64 a7);
_QWORD *__fastcall valloc(unsigned __int64 a1, double a2, __int64 a3, __int64 a4, __int64 a5, u32 *a6, __int64 a7);
_QWORD *__fastcall pvalloc(unsigned __int64 a1, double a2, __int64 a3, __int64 a4, __int64 a5, u32 *a6, __int64 a7);
u32 *__fastcall calloc(__int64 a1, unsigned __int64 a2, __int64 a3, __int64 a4, u32 *a5, __int64 a6);
__int64 __fastcall malloc_trim(unsigned __int64, __int64, __int64, __int64, __int64, unsigned __int64);
__m128i *__fastcall malloc_usable_size(__int64, __int64, __int64, __int64, __int64, __int64);
__m128i *__fastcall mallinfo(__m128i *, __int64, __int64, __int64, u32 *, u32);
unsigned __int64 __fastcall malloc_stats(__int64, __int64, __int64, __int64, u32 *, __int64);
__int64 __fastcall mallopt(int, __int64, __int64, _QWORD *, u32 *, u32);
__int64 __fastcall posix_memalign(__int64 *, unsigned __int64, unsigned __int64, double, __int64, u32 *, __int64);
__int64 __fastcall malloc_info(int, __int64);
unsigned __int64 __fastcall _default_morecore(__int64 a1);
const __m128i *(__fastcall *strchr_ifunc())(__int64 a1, unsigned int a2);
__int64 (__fastcall *strcmp_ifunc())(__int64 *a1, __int64 *a2);
void *strcpy_ifunc();
_BYTE *(__fastcall *strcspn_ifunc())(__int64 a1, __m128i *a2);
__int64 __fastcall strdup(__int64, __int64);
int (__fastcall *strlen_ifunc())(const __m128i *a1);
__int64 (__fastcall *strncmp_ifunc())(__int64 *a1, __int64 *a2, unsigned __int64 a3);
unsigned __int64 __fastcall critical_factorization(__int64, unsigned __int64, __int64 *);
__int64 __fastcall two_way_long_needle(__int64, unsigned __int64, __int64, unsigned __int64);
char *__fastcall _strstr_sse2(char *a1, char *a2);
__int8 *(__fastcall *strstr())(__int64, char *);
__int64 (__fastcall *memcmp_ifunc())(const __m128i *a1, const __m128i *a2, unsigned __int64 a3);
__int64 (__fastcall *memmove())(__int64 _RDI, __int64 _RSI, unsigned __int64 _RDX);
__int64 (__fastcall *memset_ifunc())(__int64 _RDI, int _ESI, unsigned __int64 _RDX);
void (*mempcpy())();
void *stpcpy();
__int64 (__fastcall *strcasecmp_l())(__int64 a1, __int64 a2, __int64 a3, __m128i a4, __m128i a5, __m128i a6, double a7, double a8);
__int64 (__fastcall *memcpy())(__int64 _RDI, __int64 _RSI, unsigned __int64 _RDX);
__int64 (__fastcall *rawmemchr())(const __m128i *a1, unsigned __int64 a2);
unsigned __int64 (__fastcall *strchrnul())(unsigned __int64 _RDI, int _ESI);
__int64 __fastcall _strcmp_sse2(__int64 *, __int64 *);
__int64 __fastcall _strcmp_sse2_unaligned(const __m128i *, const __m128i *);
__int64 __fastcall _strcmp_ssse3(__int64 *, __int64 *);
__int64 __fastcall _strcmp_avx2(unsigned __int64 _RDI, __int64 _RSI);
__int64 __fastcall _strncmp_sse2(__int64 *, __int64 *, unsigned __int64);
__int64 __fastcall _strncmp_ssse3(__int64 *, __int64 *, unsigned __int64);
__int64 __fastcall _strncmp_sse42(const __m128i *, const __m128i *, unsigned __int64);
__int64 __fastcall _strncmp_avx2(unsigned __int64 _RDI, unsigned __int64 _RSI, unsigned __int64);
__int64 __fastcall _rawmemchr_sse2(const __m128i *, unsigned __int64);
unsigned __int64 __fastcall _rawmemchr_avx2(unsigned __int64 i, int _ESI);
__int64 __fastcall _memcmp_sse2(const __m128i *, unsigned __int8 *, unsigned __int64);
unsigned __int64 __fastcall _memcmp_avx2_movbe(__int64 _RDI, __int64 _RSI, unsigned __int64 _RDX, __int64 _RCX);
__int64 __fastcall _memcmp_sse4_1(const __m128i *_RDI, __m128i *_RSI, unsigned __int64);
void __fastcall _mempcpy_chk_ssse3(__int64, __int64, unsigned __int64, unsigned __int64, u32 *, __int64);
void _mempcpy_ssse3();
__int64 __fastcall _memcpy_chk_ssse3(__m128i *, const __m128i *_RSI, unsigned __int64, unsigned __int64, u32 *, __int64);
__int64 __fastcall _memcpy_ssse3(__m128i *, const __m128i *_RSI, unsigned __int64);
__m128i *__fastcall _memmove_chk_ssse3(__m128i *a1, const __m128i *_RSI, unsigned __int64 a3, unsigned __int64 a4, u32 *a5, __int64 a6);
__m128i *__fastcall _memmove_ssse3(__m128i *a1, const __m128i *_RSI, unsigned __int64 a3);
void __fastcall _mempcpy_chk_ssse3_back(__int64, __int64, unsigned __int64, unsigned __int64, u32 *, __int64);
void _mempcpy_ssse3_back();
__int64 __fastcall _memcpy_chk_ssse3_back(__m128i *, const __m128i *, unsigned __int64, unsigned __int64, u32 *, __int64);
__int64 __fastcall _memcpy_ssse3_back(__m128i *, const __m128i *, unsigned __int64);
__m128i *__fastcall _memmove_chk_ssse3_back(__m128i *a1, const __m128i *a2, unsigned __int64 a3, unsigned __int64 a4, u32 *a5, __int64 a6);
__m128i *__fastcall _memmove_ssse3_back(__m128i *a1, const __m128i *a2, unsigned __int64 a3);
void __fastcall _mempcpy_chk_avx512_no_vzeroupper(__int64, __int64, unsigned __int64, unsigned __int64, u32 *, __int64);
void _mempcpy_avx512_no_vzeroupper();
unsigned __int64 __fastcall _memmove_chk_avx512_no_vzeroupper(unsigned __int64 _RDI, _BYTE *_RSI, unsigned __int64, unsigned __int64, u32 *, __int64);
unsigned __int64 __fastcall _memmove_avx512_no_vzeroupper(unsigned __int64 _RDI, _BYTE *_RSI, unsigned __int64);
__int64 __fastcall _strcasecmp_sse2(__int64, __int64, __m128i, __m128i, __m128i, double, double);
__int64 __fastcall _strcasecmp_l_sse2(__int64, __int64, __int64, __m128i, __m128i, __m128i, double, double);
__int64 __fastcall _strcasecmp_ssse3(__int64, __int64, __m128i, __m128i, __m128i, double, double);
__int64 __fastcall _strcasecmp_l_ssse3(__int64, __int64, __int64, __m128i, __m128i, __m128i, double, double);
__int64 __fastcall _strcasecmp_sse42(__int64, __int64, double, double, double, double);
__int64 __fastcall _strcasecmp_l_sse42(__int64, __int64, __int64, double, double, double, double);
__int64 __fastcall _strcasecmp_avx(__int64, __int64, __m128, double, double, double);
__int64 __fastcall _strcasecmp_l_avx(__int64 _RDI, __int64 _RSI, __int64, __m128 _XMM0, double, double, double);
__int8 *__fastcall _strchr_sse2(const __m128i *, char);
char *__fastcall _strchrnul_sse2(const __m128i *, unsigned int);
__int64 __fastcall _strchr_avx2(unsigned __int64 _RDI, int _ESI);
unsigned __int64 __fastcall _strchrnul_avx2(unsigned __int64 _RDI, int _ESI);
int __fastcall _strlen_sse2(const __m128i *);
unsigned __int64 __fastcall _strlen_avx2(unsigned __int64 _RDI, __m128 _XMM0);
_BYTE *__fastcall _strcpy_sse2(_BYTE *, _BYTE *);
_BYTE *__fastcall _stpcpy_sse2(_BYTE *, _BYTE *);
_QWORD *__fastcall _strcpy_ssse3(_QWORD *, _BYTE *);
unsigned __int64 __fastcall _stpcpy_ssse3(_QWORD *, _BYTE *);
__int64 __fastcall _strcpy_sse2_unaligned(__m128i *, const __m128i *);
__int64 __fastcall _stpcpy_sse2_unaligned(__m128i *, const __m128i *);
const __m128i *__fastcall _strchr_sse2_no_bsf(__int64, unsigned int);
__int64 __fastcall _memcmp_ssse3(const __m128i *, const __m128i *, unsigned __int64);
__int8 *__fastcall _strstr_sse2_unaligned(__int64, char *);
_BYTE *__fastcall _strcspn_sse2(__int64, _BYTE *);
_BYTE *__fastcall _strcspn_sse42(__int64, __m128i *);
unsigned __int64 __fastcall _memset_chk_avx512_no_vzeroupper(unsigned __int64 _RDI, __int64 _ESI, unsigned __int64, __m128 _XMM0, unsigned __int64, u32 *, __int64);
unsigned __int64 __fastcall _memset_avx512_no_vzeroupper(unsigned __int64 _RDI, int _ESI, unsigned __int64, __m128 _XMM0);
void _mempcpy_sse2_unaligned();
_OWORD *__fastcall _memmove_sse2_unaligned(_OWORD *, _OWORD *, unsigned __int64);
void __fastcall _mempcpy_chk_erms(__int64 a1, __int64 a2, unsigned __int64 a3, unsigned __int64 a4, u32 *a5, __int64 a6);
void __fastcall _mempcpy_erms(__int64, __int64, __int64);
char *__fastcall _memmove_chk_erms(char *, char *, unsigned __int64, unsigned __int64, u32 *, __int64);
char *__fastcall _memmove_erms(char *, char *, unsigned __int64);
void _mempcpy_sse2_unaligned_erms();
_OWORD *__fastcall _memmove_sse2_unaligned_erms(_OWORD *, _OWORD *, unsigned __int64);
void _mempcpy_avx_unaligned();
__int64 __fastcall _memmove_avx_unaligned(__int64 _RDI, __int64 _RSI, unsigned __int64 _RDX);
void _mempcpy_avx_unaligned_erms();
__int64 *__fastcall _memmove_avx_unaligned_erms(__int64 *_RDI, __int64 *_RSI, unsigned __int64 _RDX);
void _mempcpy_avx512_unaligned();
__int64 __fastcall _memmove_avx512_unaligned(__int64 _RDI, __int64 _RSI, unsigned __int64 _RDX);
void _mempcpy_avx512_unaligned_erms();
__int64 *__fastcall _memmove_avx512_unaligned_erms(__int64 *_RDI, __int64 *_RSI, unsigned __int64 _RDX);
void bzero();
void _wmemset_sse2_unaligned();
__m128i *__fastcall _memset_sse2_unaligned(__m128i *, unsigned int, unsigned __int64);
void *__fastcall _memset_chk_erms(void *, __int64, unsigned __int64, unsigned __int64, u32 *, __int64);
void *__fastcall _memset_erms(void *, char, unsigned __int64);
__m128i *__fastcall _memset_sse2_unaligned_erms(__m128i *, unsigned int, unsigned __int64);
void __fastcall _wmemset_avx2_unaligned(__int64, int _ESI);
__int64 __fastcall _memset_avx2_unaligned(__int64 _RDI, int _ESI, unsigned __int64 _RDX);
void *__fastcall _memset_avx2_erms(void *, char, unsigned __int64);
_QWORD *__fastcall _memset_avx2_unaligned_erms(_QWORD *_RDI, int _ESI, unsigned __int64 _RDX);
void __fastcall _wmemset_avx512_unaligned(__int64, int _ESI);
__int64 __fastcall _memset_avx512_unaligned(__int64 _RDI, int _ESI, unsigned __int64 _RDX);
void *__fastcall _memset_avx512_erms(void *, char, unsigned __int64);
_QWORD *__fastcall _memset_avx512_unaligned_erms(_QWORD *_RDI, int _ESI, unsigned __int64 _RDX);
__int64 __fastcall handle_amd(int);
__int64 __fastcall intel_check_word_isra_0(int, int, _BYTE *, _BYTE *, _DWORD *, _DWORD *);
__int64 __fastcall handle_intel_constprop_1(int);
__int64 __fastcall _cache_sysconf(int);
__int64 __fastcall _strcasecmp_l_nonascii(__int64, __int64, __int64);
__int64 __fastcall wmempcpy(__int64, __int64, __int64);
__int64 __fastcall mbsrtowcs(__int64, __int64 *, __int64, void *, __int64, __int64);
__int64 *__fastcall nl_cleanup_ctype(__int64, __int64, __int64, __int64, u32 *, unsigned __int64);
__int64 __fastcall _wcsmbs_getfct(unsigned __int8 *a1, unsigned __int8 *a2, unsigned __int64 *a3, __int64 a4, __int64 a5, u32 a6);
unsigned __int64 __fastcall _wcsmbs_load_conv(__int64 a1, __int64 a2, __int64 a3, __int64 a4, u32 *a5, __int64 a6);
__int64 __fastcall _wcsmbs_clone_conv(__m128i *a1, __int64 a2, __int64 a3, __int64 a4, u32 *a5, __int64 a6);
__int64 __fastcall _wcsmbs_named_conv(__int64 *a1, unsigned __int8 *a2, __int64 a3, __int64 a4, __int64 a5, u32 a6);
__int64 __fastcall _mbsrtowcs_l(__int64, __int64 *, __int64, __int64, __int64 *, __int64);
void __noreturn exit(int status);
__int64 __fastcall _sysconf_check_spec(__int64);
__int64 __fastcall sysconf(int, __int64, int);
unsigned __int64 sched_yield();
rlim64_t _get_child_max();
unsigned __int64 __fastcall xstat(unsigned int, const char *, struct stat *);
unsigned __int64 __fastcall fxstat(unsigned int, unsigned int, struct stat *);
unsigned __int64 __fastcall open64(const char *filename, int flags, int);
unsigned __int64 __fastcall read(unsigned int fd, char *buf, size_t count);
unsigned __int64 __fastcall write(unsigned int fd, const char *buf, size_t count);
unsigned __int64 __fastcall lseek64(unsigned int, off_t, unsigned int);
char *__fastcall getcwd(__int64 *a1, unsigned __int64 a2, _QWORD *a3, __int64 a4, u32 *a5, __int64 a6);
unsigned __int64 __fastcall _close_nocancel(unsigned int);
unsigned __int64 __fastcall _fcntl64_nocancel_adjusted(unsigned int, unsigned int, unsigned __int64);
unsigned __int64 __fastcall _fcntl64_nocancel(unsigned int, unsigned int, unsigned __int64);
unsigned __int64 __fastcall _open_nocancel(const char *filename, int flags, int);
unsigned __int64 __fastcall _openat_nocancel(int, const char *, int, int);
unsigned __int64 __fastcall _read_nocancel(unsigned int, char *, size_t);
unsigned __int64 __fastcall _write_nocancel(unsigned int, const char *, size_t);
unsigned __int64 __fastcall getrlimit64(unsigned int resource, struct rlimit64 *old_rlim);
unsigned __int64 __fastcall sbrk(__int64 a1);
__int64 getpagesize();
__int64 __fastcall getdtablesize(); // weak
unsigned __int64 __fastcall mmap64(unsigned __int64 addr, unsigned __int64 len, unsigned __int64 prot, unsigned __int64 flags, unsigned __int64 fd, unsigned __int64 off);
unsigned __int64 __fastcall munmap(unsigned __int64, size_t);
unsigned __int64 __fastcall mprotect(unsigned __int64, size_t, unsigned __int64);
unsigned __int64 __fastcall madvise(unsigned __int64, size_t, int);
__int64 __fastcall trecurse(__int64, void (__fastcall *)(__int64, _QWORD), unsigned int);
__int64 *__fastcall tdestroy_recurse(_QWORD *, void (__fastcall *)(_QWORD));
unsigned __int64 __fastcall maybe_split_for_insert_isra_0(__int64, _QWORD *, unsigned __int64 *, int, int, int);
_QWORD *__fastcall tsearch(__int64, __int64 *, __int64 (__fastcall *)(__int64, _QWORD), __int64, u32 *, __int64);
unsigned __int64 __fastcall tfind(__int64, _QWORD *, __int64 (__fastcall *)(__int64, _QWORD));
unsigned __int64 __fastcall tdelete(__int64, __int64 *, __int64 (__fastcall *)(__int64, _QWORD));
__int64 __fastcall twalk(__int64, void (__fastcall *)(__int64, _QWORD));
__int64 *__fastcall tdestroy(_QWORD *, void (__fastcall *)(_QWORD));
char *__fastcall next_line(unsigned int, char *, _QWORD *, char **, char *);
unsigned __int64 __fastcall sysinfo_mempages(__int64, unsigned int);
__int64 get_nprocs();
__int64 __fastcall get_nprocs_conf(__int64, char **, int);
unsigned __int64 get_phys_pages();
unsigned __int64 get_avphys_pages();
__int64 __fastcall _getclktck(); // weak
void __fastcall _init_misc(__int64, _QWORD *);
unsigned __int64 __fastcall mremap(unsigned __int64, unsigned __int64, unsigned __int64, unsigned __int64, unsigned __int64);
unsigned __int64 __fastcall sysinfo(struct sysinfo *);
void __fastcall __noreturn _chk_fail(__int64, __int64, __int64, __int64, u32 *, __int64);
void __fastcall __noreturn _fortify_fail_abort(char, __int64, __int64, __int64, u32 *, __int64);
void __fastcall __noreturn _fortify_fail(__int64, __int64, __int64, __int64, u32 *, __int64);
void dl_debug_state();
void **__fastcall dl_debug_initialize(void *a1, __int64 a2);
__int64 __fastcall do_tunable_update_val(__int64, unsigned __int64 *);
__int64 __fastcall tunable_initialize(__int64, char *);
__int64 __fastcall _tunable_set_val(unsigned int, unsigned __int64 *);
void __fastcall _tunables_init(__int64 *);
__int64 __fastcall _tunable_get_val(unsigned int, _QWORD *, __int64 (__fastcall *)(char **));
__int64 __fastcall dl_aux_init(__int64 *);
unsigned __int64 dl_non_dynamic_init();
void *dl_get_dl_main_map();
signed __int64 _libc_init_secure();
void __fastcall dl_mcount_wrapper(__int64);
void __fastcall dl_mcount_wrapper_check(__int64);
void __fastcall dl_tunable_set_hwcaps(char **);
__int64 __fastcall dl_tunable_set_x86_ibt(const __m128i **);
__int64 __fastcall dl_tunable_set_x86_shstk(const __m128i **);
__int64 dl_discover_osversion();
unsigned __int64 __fastcall _libc_init_first(unsigned int, _QWORD *, char **);
__int64 __fastcall _gconv_open(char *, char *, _QWORD *, int);
__int64 __fastcall _gconv(_QWORD *, __int64 *, unsigned __int64, __int64 *, __int64, _QWORD *);
__int64 __fastcall _gconv_close(__int64 *, __int64, __int64, __int64, u32 *, unsigned __int64);
__int64 __fastcall _gconv_alias_compare(_QWORD *, _QWORD *);
__int64 __fastcall derivation_compare(_QWORD *, _QWORD *);
__int64 __fastcall _gconv_get_modules_db(); // weak
__int64 __fastcall _gconv_get_alias_db(); // weak
__int64 __fastcall _gconv_release_step(__int64);
__int64 __fastcall find_derivation(__int64, __int64, __int64, __int64, __int64 *, unsigned __int64 *);
__int64 __fastcall _gconv_compare_alias(unsigned __int8 *, unsigned __int8 *);
__int64 __fastcall _gconv_find_transform(unsigned __int8 *, unsigned __int8 *, __int64 *, __int64 *, u32 *, u32);
__int64 __fastcall _gconv_close_transform(__int64, __int64, __int64, __int64, u32 *, unsigned __int64);
void __fastcall insert_module(__int64, int);
__int64 __fastcall detect_conflict(__int64);
unsigned __int64 __fastcall add_module_isra_0(char *, __int64, __int64, int);
__int64 *__fastcall add_alias2_isra_1_part_2(__int64, __int64, __int64, __int64, u32 *, __int64);
unsigned __int64 __fastcall _gconv_get_path(__int64, __int64, __int64, __int64, u32 *, u32);
unsigned __int64 __fastcall _gconv_read_conf(__int64, __int64);
__int64 __fastcall _gconv_get_builtin_trans(__int64, __int64);
__int64 __fastcall _gconv_btwoc_ascii(__int64, char);
__int64 __fastcall _gconv_transform_internal_ucs4(__int64, unsigned __int64 *, unsigned __int64 *, unsigned __int64, unsigned __int64 *, __int64, unsigned int, unsigned int);
__int64 __fastcall _gconv_transform_ucs4_internal(__int64, __int64, unsigned int **, unsigned int *, int **, _QWORD *, unsigned int, unsigned int);
__int64 __fastcall _gconv_transform_internal_ucs4le(__int64, __int64, unsigned __int64 *, unsigned __int64, unsigned __int64 *, __int64, unsigned int, unsigned int);
__int64 __fastcall _gconv_transform_ucs4le_internal(__int64, __int64, unsigned __int64 *, unsigned __int64, _QWORD *, _QWORD *, unsigned int, unsigned int);
__int64 __fastcall _gconv_transform_ascii_internal(__int64, __int64, unsigned __int8 **, unsigned __int8 *, _QWORD *, _QWORD *, unsigned int, unsigned int);
__int64 __fastcall _gconv_transform_internal_ascii(_QWORD *, __int64, unsigned int **, unsigned __int64, _QWORD *, _QWORD *, unsigned int, unsigned int);
__int64 __fastcall _gconv_transform_internal_utf8(_QWORD *, __int64, __int64 *, unsigned __int64, _QWORD *, _QWORD *, unsigned int, unsigned int);
__int64 __fastcall _gconv_transform_utf8_internal(__int64, __int64, unsigned __int8 **, unsigned __int64, unsigned int **, _QWORD *, unsigned int, unsigned int);
__int64 __fastcall _gconv_transform_ucs2_internal(__int64, __int64, unsigned __int64 *, unsigned __int64, char **, _QWORD *, unsigned int, unsigned int);
__int64 __fastcall _gconv_transform_internal_ucs2(_QWORD *, __int64, unsigned int **, unsigned __int64, _QWORD *, _QWORD *, unsigned int, unsigned int);
__int64 __fastcall _gconv_transform_ucs2reverse_internal(__int64, __int64, unsigned __int64 *, unsigned __int64, char **, _QWORD *, unsigned int, unsigned int);
__int64 __fastcall _gconv_transform_internal_ucs2reverse(_QWORD *, __int64, unsigned int **, unsigned __int64, _QWORD *, _QWORD *, unsigned int, unsigned int);
__int64 __fastcall _gconv_transliterate(_QWORD *, __int64, __int64, unsigned int **, unsigned __int64, __int64 *, _QWORD *);
__int64 __fastcall find_module_idx(unsigned __int8 *, _QWORD *);
__int64 __fastcall find_module(__int64, __int64, _QWORD *);
__int64 __fastcall _gconv_get_cache(); // weak
__int64 _gconv_load_cache();
__int64 __fastcall _gconv_compare_alias_cache(unsigned __int8 *, unsigned __int8 *, _DWORD *);
__int64 __fastcall _gconv_lookup_cache(unsigned __int8 *, unsigned __int8 *, __int64 *, __int64 *, char);
__int64 *__fastcall _gconv_release_cache(__int64, __int64, __int64, __int64, u32 *, unsigned __int64);
__int64 __fastcall known_compare(_QWORD *, _QWORD *);
void __fastcall do_release_shlib(__int64 *, __int64, __int64, __int64, __int64, __int64);
__int64 __fastcall _gconv_find_shlib(__int64);
__int64 __fastcall _gconv_release_shlib(__int64);
const char *__fastcall new_composite_name(int, __int64);
char **__fastcall setlocale(int a1, const char *a2);
unsigned __int64 __fastcall strip(_BYTE *, char *);
char **__fastcall nl_find_locale(const char *, __int64, int, __int64 *);
void __fastcall nl_remove_locale(int, size_t, __int64, __int64, u32 *, unsigned __int64);
_QWORD *__fastcall nl_intern_locale_data(unsigned int a1, unsigned int *a2, _QWORD *a3, __int64 a4, __int64 a5, __int64 a6);
unsigned __int64 __fastcall nl_load_locale(const char **, unsigned int, int);
__int64 *__fastcall nl_unload_locale(__int64, size_t, __int64, __int64, u32 *, unsigned __int64);
__int64 __fastcall nl_load_locale_from_archive(int, __int64 *, int);
int (*nl_postload_ctype())[256];
__int64 __fastcall _current_locale_name(int);
unsigned __int64 _ctype_b_loc();
unsigned __int64 _ctype_toupper_loc();
unsigned __int64 _ctype_tolower_loc();
unsigned __int64 _ctype_init();
__int64 _setfpucw();
__int64 __fastcall _sigsetjmp(_QWORD *a1, int a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, char a7);
__int64 __fastcall _sigjmp_save(__int64, int);
unsigned __int64 __fastcall _restore_rt(int, __int64, __int64);
unsigned __int64 __fastcall _libc_sigaction(int, __int64, __int64);
unsigned __int64 __fastcall sigaction(int, __int64, __int64);
unsigned __int64 __fastcall sigprocmask(int, sigset_t *, sigset_t *);
unsigned __int64 __fastcall quicksort(char *, unsigned __int64, unsigned __int64, int (__fastcall *)(char *, char *, __int64), __int64);
__int64 __fastcall _add_to_environ(__int64 a1, __int64 a2, char *a3, unsigned int a4);
__int64 __fastcall setenv(_BYTE *, __int64, unsigned int);
__int64 __fastcall unsetenv(_BYTE *);
__int64 __fastcall clearenv(__int64, __int64, __int64, __int64, u32 *, unsigned __int64);
char *__fastcall secure_getenv(_BYTE *);
unsigned __int64 __fastcall _strtoll_internal(char *a1, char **a2, int a3, int a4);
unsigned __int64 __fastcall strtoq(char *a1, char **a2, int a3);
unsigned __int64 __fastcall ___strtoll_l_internal(char *a1, char **a2, int a3, int a4, __int64 a5);
unsigned __int64 __fastcall strtoll_l(char *a1, char **a2, int a3, __int64 a4);
__int64 __fastcall read_int(_QWORD *);
_BYTE *__fastcall group_number(unsigned __int64, _BYTE *, _BYTE *, _BYTE *, __int64);
__int64 __fastcall i18n_number_rewrite(__int64, __int64, __int64);
__int64 __fastcall IO_helper_overflow(_QWORD *, unsigned __int8, __int64, __int64, u32 *, __int64);
__int64 __fastcall printf_positional(char *a1, __int64 a2, int a3, __int64 a4, u32 *a5, unsigned __int64 a6, int a7, _BYTE *a8, __int64 a9, int a10, char *a11, __int64 a12);
__int64 __fastcall vfprintf(__int64, unsigned __int64, __m128i *);
__int64 __fastcall buffered_vfprintf(__int64, __int64 _RSI, __m128i *);
__int64 __fastcall hack_digit(__int64);
__int64 __fastcall i18n_number_rewrite_0(__int64, __int64, __int64);
__int64 __fastcall _guess_grouping_part_0(unsigned int, char *);
__int64 __fastcall _printf_fp_l(char *, _QWORD *, __int64, long double **, u32 *, __int64);
__int64 __fastcall _printf_fp(char *, __int64, long double **, __int64, u32 *, __int64);
__int64 __fastcall _guess_grouping(unsigned int, char *);
__int64 __fastcall register_printf_specifier(signed int, __int64, __int64, __int64, u32 *, __int64);
__int64 __fastcall register_printf_function(signed int, __int64, __int64, __int64, u32 *, __int64);
__int64 __fastcall _printf_fphex(__int64, __int64, const __m128i **, __int64, __int64, __int64);
__int64 __fastcall register_printf_modifier(char *, __int64, __int64, __int64, u32 *, __int64);
__int64 __fastcall _handle_registered_modifier_mb(unsigned __int8 **, __int64);
__int64 __fastcall _handle_registered_modifier_wc(unsigned int **, __int64);
__int64 __fastcall register_printf_type(__int64, __int64, __int64, __int64, u32 *, __int64);
__int64 fprintf(__int64, unsigned __int64, ...);
__int64 __fastcall read_int_0(_QWORD *);
_DWORD *__fastcall group_number_0(__int64 a1, _DWORD *a2, _DWORD *a3, _BYTE *a4, int a5);
_DWORD *__fastcall i18n_number_rewrite_1(_DWORD *, __int64, _DWORD *);
__int64 __fastcall IO_helper_overflow_0(__int64, unsigned int, __int64, __int64, u32 *, __int64);
__int64 __fastcall printf_positional_0(u32 *, unsigned __int64, unsigned int, __int64, u32 *, unsigned __int64, int, _DWORD *, __int64, unsigned int, _BYTE *, int);
__int64 __fastcall vfwprintf(__int64 a1, int *a2, __m128i *a3, __int64 a4, u32 *a5, __int64 a6);
__int64 __fastcall buffered_vfprintf_0(__int64 a1, __int64 _RSI, __m128i *a3, __int64 a4, u32 *a5, __int64 a6);
signed __int64 __fastcall funlockfile(__int64, __int64, __int64, __int64, u32 *, u32);
__int64 __fastcall read_int_1(_QWORD *);
__int64 __fastcall _parse_one_specmb(__int64, int, __int64);
__int64 __fastcall read_int_2(_QWORD *);
__int64 __fastcall _parse_one_specwc(__int64, int, __int64, __int64 *);
__int64 __fastcall IO_file_doallocate(__int64, _WORD *, _QWORD *, __int64, u32 *, __int64);
__int64 __fastcall fputs(__int64, __int64 _RSI);
__int64 __fastcall IO_wfile_doallocate(__int64, _WORD *, _QWORD *, __int64, u32 *, __int64);
__int64 __fastcall fwrite(__int64 a1, __int64 _RSI, __int64 a3, __int64 a4, __int64 _R8, __int64 a6);
__int64 __fastcall getdelim(__int64 *, __int64 _RSI, __int64 _RDX, unsigned int *, u32 *, unsigned __int64);
_BYTE *__fastcall IO_getline_info(__int64, __int64, unsigned __int64, unsigned __int64, u32 *, _DWORD *);
_BYTE *__fastcall IO_getline(__int64, __int64, unsigned __int64, unsigned __int64, u32 *);
__int64 __fastcall IO_padn(char *, char *i, int, __int64, u32 *, __int64);
__int64 __fastcall IO_wpadn(char *, __int64, int, __int64, u32 *, __int64);
__int64 __fastcall save_for_wbackup_isra_0(__int64 **, __int64, __int64);
__int64 __fastcall IO_least_wmarker(__int64, __int64);
_QWORD *__fastcall IO_switch_to_main_wget_area(__int64);
_QWORD *__fastcall IO_switch_to_wbackup_area(__int64);
__int64 __fastcall IO_wsetb(__int64, __int64, __int64, __int64, __int64, unsigned __int64);
__int64 __fastcall IO_wdefault_pbackfail(int *, __int64, _QWORD *, __int64, u32 *, __int64);
unsigned __int64 __fastcall IO_wdefault_finish(__int64, __int64, __int64, unsigned int *, u32 *, unsigned __int64);
__int64 __fastcall IO_wdefault_uflow(__int64, __int64, __int64, __int64, u32 *, __int64);
__int64 __fastcall _woverflow(__int64, __int64, __int64, __int64, u32 *, __int64);
__int64 __fastcall IO_wdefault_xsputn(__int64, __int64, __int64, __int64, u32 *, __int64);
void __fastcall IO_wdoallocbuf(__int64, __int64, __int64, __int64, __int64, unsigned __int64);
__int64 __fastcall IO_wdefault_doallocate(__int64, __int64, _QWORD *, __int64, u32 *, __int64);
__int64 __fastcall IO_switch_to_wget_mode(int *);
_QWORD *__fastcall IO_free_wbackup_area(int *, __int64, __int64, __int64, u32 *, unsigned __int64);
__int64 __fastcall _wuflow(int *, unsigned __int64, __int64, __int64, u32 *, unsigned __int64);
__int64 __fastcall _wunderflow(int *, unsigned __int64, __int64, __int64, u32 *, unsigned __int64);
unsigned __int64 __fastcall IO_wdefault_xsgetn(__int64, __int64, unsigned __int64, __int64, u32 *, unsigned __int64);
__int64 __fastcall IO_sputbackwc(__int64, __int64, __int64, __int64, u32 *, __int64);
__int64 __fastcall IO_sungetwc(__int64, __int64, __int64, __int64, u32 *, __int64);
__int64 __fastcall IO_adjust_wcolumn(int, unsigned __int64, int);
__int64 __fastcall IO_init_wmarker(__int64, __int64);
__int64 __fastcall IO_wmarker_delta(__int64);
__int64 __fastcall IO_seekwmark(int *, __int64);
_QWORD *__fastcall IO_unsave_wmarkers(int *, __int64, __int64, __int64, u32 *, unsigned __int64);
__int64 __fastcall do_encoding(__int64);
__int64 __fastcall do_always_noconv(); // weak
__int64 __fastcall do_max_length(__int64);
__int64 __fastcall do_in(_QWORD *, __int64, __int64, __int64, _QWORD *, __int64, __int64, _QWORD *);
__int64 __fastcall do_unshift(_QWORD *, __int64, __int64, __int64, _QWORD *);
__int64 __fastcall do_out(_QWORD *, __int64, __int64, __int64, _QWORD *, __int64, __int64, _QWORD *);
__int64 __fastcall do_length(_QWORD *, __int64, __int64, __int64, __int64);
__int64 __fastcall IO_fwide(__int64 a1, __int64 a2, __int64 a3, __int64 a4, u32 *a5, __int64 a6);
int _libc_enable_asynccancel();
void __fastcall _libc_disable_asynccancel(char, __int64, u32, __int64, u32 *, u32);
__int64 __fastcall _libc_scratch_buffer_grow_preserve(__int64 *a1, __int64 a2, _QWORD *a3, __int64 *a4, u32 *a5, unsigned __int64 a6);
__int64 __fastcall _libc_scratch_buffer_set_array_size(__int64 *, unsigned __int64, __int64, __int64, u32 *, unsigned __int64);
__int64 __fastcall strndup(__int64, __int64);
unsigned __int8 *__fastcall strerror_r(int, __int64, unsigned __int64);
char *(__fastcall *strnlen())(__int64 a1, __int64 a2);
__int64 (__fastcall *strrchr_ifunc())(__int64 _RDI, unsigned __int64 a2);
_BYTE *__fastcall strtok_r(_BYTE *, __int64, _BYTE **);
__int64 (__fastcall *memchr_ifunc())(const __m128i *a1, unsigned int a2, unsigned __int64 a3);
unsigned __int64 __fastcall critical_factorization_0(__int64, unsigned __int64, __int64 *);
__int64 __fastcall two_way_long_needle_0(__int64, __int64, __int64, unsigned __int64);
__int64 __fastcall memmem(__int64, unsigned __int64, unsigned __int8 *, unsigned __int64);
__int64 __fastcall argz_create_sep(char *, __int64, unsigned __int64 *, __int64 *);
__int64 __fastcall argz_add_sep(__int64 *, _QWORD *, char *, int);
__int64 __fastcall _memchr_sse2(const __m128i *, unsigned int, unsigned __int64);
unsigned __int64 __fastcall _memchr_avx2(unsigned __int64, int _ESI, unsigned __int64);
char *__fastcall _strrchr_sse2(const __m128i *, unsigned int);
__int64 __fastcall _strrchr_avx2(__int64 _RDI, unsigned __int64);
char *__fastcall _strnlen_sse2(__int64, __int64);
unsigned __int64 __fastcall _strnlen_avx2(unsigned __int64 _RDI, unsigned __int64, __m128 _XMM0);
unsigned __int64 (__fastcall *wcslen())(unsigned __int64 _RDI, __m128 _XMM0);
__int64 __fastcall wmemcpy(__int64, __int64, __int64);
__int64 __fastcall wmemmove(__int64, __int64, __int64);
void (__fastcall *wmemset())(__int64 a1, int _ESI);
__int64 __fastcall btowc(unsigned int a1, __int64 a2, __int64 a3, __int64 a4, u32 *a5, __int64 a6);
__int64 __fastcall wcrtomb(char *a1, __int64 a2, void *a3, __int64 a4, u32 *a5, __int64 a6);
__int64 __fastcall wcsrtombs(__int64 a1, _QWORD *a2, __int64 a3, __int64 *a4, u32 *a5, __int64 a6);
unsigned __int64 (__fastcall *wcsnlen())(__int64 a1, __int64 a2);
int *__fastcall wcschrnul(int *, int);
unsigned __int64 __fastcall _wcsnlen_sse4_1(__int64, __int64);
__int64 __fastcall _wcsnlen_sse2(_DWORD *, __int64);
unsigned __int64 __fastcall _wcslen_sse2(_DWORD *a1);
unsigned __int64 __fastcall _wcslen_avx2(unsigned __int64 _RDI, __m128 _XMM0);
unsigned __int64 __fastcall _wcsnlen_avx2(unsigned __int64 _RDI, __int64, __m128 _XMM0);
signed __int64 __fastcall time(time_t *);
_QWORD *__fastcall _alloc_dir(unsigned int a1, __int64 a2, _QWORD *a3, __int64 a4, u32 *a5, __int64 a6);
_QWORD *__fastcall opendir_tail(signed int a1);
_QWORD *__fastcall _opendirat(int a1, const char *a2, __int64 a3, int a4);
_QWORD *__fastcall opendir(const char *a1, __int64 a2, int a3);
unsigned __int64 __fastcall closedir(unsigned int *, __int64, __int64, __int64, u32 *, unsigned __int64);
unsigned __int64 __fastcall rewinddir(__int64, __int64, __int64, __int64, u32 *, u32);
__int64 __fastcall readdir64(__int64, __int64, __int64, __int64, u32 *, u32);
_QWORD *__fastcall fdopendir(unsigned int a1);
unsigned __int64 __fastcall uname(struct old_utsname *);
signed __int64 getuid();
signed __int64 geteuid();
signed __int64 getgid();
signed __int64 getegid();
__int64 __fastcall lxstat(unsigned int);
unsigned __int64 __fastcall _fxstatat64(unsigned int, int, const char *, struct stat *, int);
_BOOL8 __fastcall isatty(unsigned int);
unsigned __int64 __fastcall tcgetattr(unsigned int);
__int64 __fastcall brk(unsigned __int64);
__int64 __fastcall wctrans(__int64);
__int64 __fastcall towctrans(unsigned int, _DWORD *);
__int64 __fastcall _readonly_area(unsigned __int64, unsigned __int64, __int64, __int64, u32 *, __int64);
__int64 __fastcall is_dst(_BYTE *, __int64);
_BOOL8 __fastcall is_trusted_path_normalize(char *, __int64);
__int64 __fastcall dl_process_pt_note(__int64, _QWORD *, _QWORD *, _QWORD *, u32 *, unsigned __int64);
void __fastcall __noreturn lose(int a1, __int64 a2, void *a3, __int64 a4, __int64 a5, const char *a6, __int64 a7);
__int64 __fastcall add_name_to_object_isra_5(_QWORD *a1, void *a2);
__int64 __fastcall open_verify_constprop_9(const char *a1, unsigned __int64 a2, int a3, _BYTE *a4, int a5);
__int64 __fastcall open_path(__int64 a1, __int64 a2, int a3, __int64 *a4, __int64 *a5, unsigned __int64 a6, __int64 a7, int a8, _BYTE *a9);
__int64 __fastcall dl_map_object_from_fd_constprop_10(const char *, unsigned int, char *, unsigned __int8 *, _QWORD *, char, int, __int64, __int64);
void __fastcall add_path_isra_4_constprop_11(__int64, __int64 *);
__int64 __fastcall dl_dst_count(__int64);
char *__fastcall dl_dst_substitute(__int64, char *, char *);
char *__fastcall expand_dynamic_string_token(__int64, char *);
_QWORD *__fastcall fillin_rpath(__int64, _QWORD *, __int64, __int64, __int64, __int64);
__int64 __fastcall cache_rpath_part_8(__int64, __int64, int, __int64);
const char *__fastcall dl_init_paths(_BYTE *);
u32 *__fastcall dl_map_object(__int64, char *, char, int, int, __int64);
void __fastcall dl_rtld_di_serinfo(__int64, __int64, char);
unsigned int *__fastcall check_match(__int64, unsigned int *, __int64, char, unsigned __int8, unsigned int *, unsigned int, __int64, __int64, unsigned int **, _DWORD *);
__int64 __fastcall do_lookup_x(unsigned __int8 *, unsigned __int64, unsigned __int64 *, unsigned int *, unsigned int **, __int64, __int64, __int64, char, __int64, int, __int64);
__int64 __fastcall dl_lookup_symbol_x(unsigned __int8 *, __int64, unsigned int **, __int64 *, const char **, int, double, double, double, double, double, double, double, double, int, __int64);
unsigned int *__fastcall dl_setup_hash(__int64);
__int64 __fastcall dl_add_to_namespace_list(_QWORD *, __int64);
u32 *__fastcall dl_new_object(unsigned __int8 *, __int64, char, _QWORD *, char, __int64);
__int64 __fastcall dl_try_allocate_static_tls(__int64);
__int64 __fastcall dl_allocate_static_tls(__int64);
__int64 __fastcall dl_nothread_init_static_tls(_QWORD *);
unsigned __int64 __fastcall dl_protect_relro(_QWORD *);
void __fastcall __noreturn dl_reloc_bad_type(__int64, unsigned int);
void __fastcall dl_relocate_object(__int64 a1, __int64 *a2, int a3, unsigned int a4, u32 *a5, __int64 a6, double a7, double a8, double a9, double a10, double a11, double a12, double a13, double a14);
_QWORD *__fastcall dl_important_hwcaps(__int64, __int64, __int64 *, _QWORD *);
signed __int64 __fastcall dl_debug_vdprintf(int, int, _BYTE *, __int64);
unsigned __int64 __fastcall dl_sysdep_read_whole_file(const char *, __off_t *, unsigned int);
signed __int64 dl_debug_printf(_BYTE *, ...);
signed __int64 dl_debug_printf_c(_BYTE *, ...);
signed __int64 dl_dprintf(int, _BYTE *, ...);
__int64 __fastcall dl_name_match_p(__int64, __int64);
__int64 __fastcall dl_higher_prime_number(unsigned __int64);
__int64 __fastcall dl_strtoul(char *, char **);
unsigned __int64 dl_start_profile();
void __fastcall dl_mcount(__int64, __int64);
u32 *__fastcall allocate_dtv(__int64 a1, __int64 a2, __int64 a3, __int64 a4, u32 *a5, __int64 a6);
void __noreturn oom();
unsigned __int64 dl_next_tls_modid();
__int64 __fastcall dl_count_modids(); // weak
__int64 __fastcall dl_get_tls_static_info(_QWORD *, _QWORD *);
u32 *__fastcall dl_allocate_tls_storage(__int64, __int64, _QWORD *, __int64, u32 *, __int64);
__int64 __fastcall dl_allocate_tls_init(__int64, __int64, __int64, __int64, u32 *, unsigned __int64);
__int64 __fastcall dl_allocate_tls(__int64, __int64, _QWORD *, __int64, u32 *, __int64);
__int64 *__fastcall dl_deallocate_tls(__int64, __int64, __int64, __int64, u32 *, unsigned __int64);
__int64 __fastcall dl_tls_get_addr_soft(__int64);
__int64 __fastcall dl_add_to_slotinfo(unsigned __int64, __int64, _QWORD *, __int64, u32 *, __int64);
__int64 dl_get_origin();
__int64 __fastcall dl_scope_free(__int64 a1, __int64 a2, _QWORD *a3, __int64 a4, u32 *a5, unsigned __int64 a6);
unsigned int __fastcall dl_make_stack_executable(_QWORD *);
__int64 __fastcall dl_runtime_profile_sse(unsigned __int64, unsigned __int64, __int64, __int64, __int64, __int64, __m128, __m128, __m128, __m128, __m128, __m128, __m128, __m128, unsigned int, __int64, __int64);
__int64 __fastcall dl_runtime_resolve_fxsave(__int64, __int64, __int64, __int64, __int64, __int64, double, double, double, double, double, double, double, double, unsigned int);
__int64 __fastcall dl_runtime_resolve_xsave(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, double a7, double a8, double a9, double a10, double a11, double a12, double a13, double a14, __int64 a15, __int64 a16, __int64 a17, __int64 a18, __int64 a19, int a20, __int64 a21, int a22, int a23, int a24, int a25, int a26, int a27, int a28, int a29, int a30, int a31, int a32, int a33, int a34, int a35, int a36, int a37, int a38, int a39, int a40, int a41, int a42, int a43, int a44, int a45, int a46, int a47, int a48, int a49, int a50, int a51, int a52, int a53, int a54, int a55, int a56, int a57, int a58, int a59, int a60, int a61, int a62, int a63);
__int64 __fastcall dl_runtime_resolve_xsavec(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, double a7, double a8, double a9, double a10, double a11, double a12, double a13, double a14, __int64 a15, __int64 a16, __int64 a17, __int64 a18, __int64 a19, __int64 a20, __int64 a21, int a22, int a23, int a24, int a25, int a26, int a27, int a28, int a29, int a30, int a31, int a32, int a33, int a34, int a35, int a36, int a37, int a38, int a39, int a40, int a41, int a42, int a43, int a44, int a45, int a46, int a47, int a48, int a49, int a50, int a51, int a52, int a53, int a54, int a55, int a56, int a57, int a58, int a59, int a60, int a61, int a62, int a63);
void __noreturn length_mismatch();
const char *__fastcall dl_exception_create(const char **, void *, __int64);
const char *__fastcall dl_exception_create_format(const char **, void *, _BYTE *, double, double, double, double, double, double, double, double, __int64, u32 *, __int64, char);
__int64 *__fastcall dl_exception_free(_QWORD *, __int64, __int64, __int64, u32 *, unsigned __int64);
__int64 __fastcall dl_cache_libcmp(char *, char *);
__int64 __fastcall dl_load_cache_lookup(char *);
unsigned __int64 dl_unload_cache();
__int64 __fastcall dl_tlsdesc_return(); // weak
unsigned __int64 __fastcall dl_tlsdesc_undefweak();
__int64 __fastcall dl_tlsdesc_resolve_rela(__int64, __int64, __int64, __int64, __int64, __int64, double, double, double, double, double, double, double, double);
__int64 __fastcall dl_tlsdesc_resolve_hold(__int64, __int64, __int64, __int64, __int64, __int64);
__int64 __fastcall do_dlopen(__int64);
__int64 __fastcall dlerror_run(void (__fastcall *)(__int64), __int64, __int64, __int64, __int64, __int64);
__int64 __fastcall _libc_dlclose(__int64, __int64, __int64, __int64, __int64, __int64);
__int64 __fastcall _libc_dlsym(__int64, __int64, __int64, __int64, __int64, __int64);
__int64 __fastcall _libc_dlvsym(__int64, __int64, unsigned __int8 *, __int64, __int64, __int64);
unsigned __int64 __fastcall do_dlsym_private(__int64, double, double, double, double, double, double, double, double);
__int64 __fastcall do_dlsym(__int64, double, double, double, double, double, double, double, double);
__int64 __fastcall do_dlvsym(__int64, double, double, double, double, double, double, double, double);
void __fastcall do_dlclose(__int64);
__int64 __fastcall _libc_dlsym_private(__int64, __int64, __int64, __int64, __int64, __int64);
_QWORD *__fastcall _libc_register_dl_open_hook(__int64, __int64, __int64, __int64, __int64, __int64);
__int64 __fastcall _libc_dlopen_mode(__int64, int, __int64, __int64, __int64, __int64);
void __fastcall __noreturn fatal_error(int, const char *, const char *, const char *);
void __fastcall __noreturn dl_signal_exception(int a1, const __m128i *a2, const char *a3);
void __fastcall __noreturn dl_signal_error(int, void *, const char *, const char *);
__int64 __fastcall dl_catch_exception(__int64, void (__fastcall *)(__int64), __int64, __int64, __int64, __int64);
__int64 __fastcall dl_catch_error(_QWORD *, _QWORD *, bool *, void (__fastcall *)(__int64), __int64, __int64);
void __noreturn _longjmp(struct __jmp_buf_tag env[1], int val);
__int64 __fastcall _mpn_cmp(__int64, __int64, __int64);
__int64 __fastcall _mpn_divrem(__int64, __int64, unsigned __int64 *, __int64, __int64 *, __int64);
unsigned __int64 __fastcall _mpn_lshift(__int64, __int64, unsigned __int64, char);
unsigned __int64 __fastcall _mpn_rshift(unsigned __int64 *, unsigned __int64 *, unsigned __int64, char);
__int64 __fastcall _mpn_mul(_QWORD *a1, __int64 *a2, __int64 a3, unsigned __int64 *a4, __int64 a5);
__int64 __fastcall _mpn_mul_1(_QWORD *, _QWORD *, __int64, unsigned __int64);
__int64 __fastcall _mpn_impn_mul_n_basecase(_QWORD *a1, __int64 *a2, unsigned __int64 *a3, __int64 a4);
__int64 __fastcall _mpn_impn_mul_n(__int64 *, __int64 *, unsigned __int64 *, __int64, __int64 *);
__int64 __fastcall _mpn_impn_sqr_n_basecase(_QWORD *a1, unsigned __int64 *a2, __int64 a3);
__int64 __fastcall _mpn_impn_sqr_n(unsigned __int64 *, unsigned __int64 *, __int64, __int64 *);
unsigned __int64 __fastcall _mpn_mul_n(unsigned __int64 *, unsigned __int64 *, unsigned __int64 *, __int64);
_BOOL8 __fastcall _mpn_sub_n(__int64, unsigned __int64 *, __int64 *, __int64);
unsigned __int64 __fastcall _mpn_submul_1(unsigned __int64 *, unsigned __int64 *, __int64, unsigned __int64);
__int64 __fastcall _mpn_extract_double(__int64 *, double, __int64, _DWORD *, _DWORD *);
__int64 __fastcall _mpn_extract_long_double(__int64 *, __int64, _DWORD *, int *, __int64, __int64, __int64, __int16);
__int64 __fastcall _mpn_extract_float128(_QWORD *, __m128i, __int64, _DWORD *, _DWORD *);
__int64 __fastcall itoa_word(unsigned __int64, __int64, unsigned int, int);
_BYTE *__fastcall fitoa_word(unsigned __int64, __int64, unsigned int, int);
void *init();
__int64 __fastcall _dlerror(__int64, __int64, __int64, __int64, u32 *, unsigned __int64);
__int64 *__fastcall check_free_isra_0(__int64 **, __int64, __int64, __int64, u32 *, unsigned __int64);
__int64 *__fastcall free_key_mem(__int64, __int64, __int64, __int64, u32 *, unsigned __int64);
_BOOL8 __fastcall dlerror_run(void (__fastcall *)(__int64), __int64, __int64, __int64, u32 *, unsigned __int64);
_QWORD *__fastcall _libc_register_dlfcn_hook(__int64, __int64, __int64, __int64, __int64, __int64);
__int64 __fastcall _dladdr(unsigned __int64, _QWORD *);
__int64 __fastcall _dladdr1(unsigned __int64, _QWORD *, _QWORD *, int);
void __fastcall dlinfo_doit(__int64);
_BOOL8 __fastcall _dlinfo(__int64, int, __int64, __int64, u32 *, unsigned __int64);
__int64 __fastcall dlmopen_doit(__int64);
__int64 __fastcall _dlmopen(__int64, __int64, __int64, __int64, u32 *, unsigned __int64);
unsigned __int8 *__fastcall strerror(int);
_BYTE *(__fastcall *strspn_ifunc())(__int64 a1, __m128i *a2);
__int64 __fastcall strsep(_QWORD *, __int64);
_BYTE *__fastcall _strspn_sse2(__int64, _BYTE *);
_BYTE *__fastcall _strspn_sse42(__int64, __m128i *);
unsigned __int64 __fastcall _getdents64(unsigned int, struct linux_dirent64 *, unsigned int);
signed __int64 getpid();
unsigned __int64 __fastcall _profil_counter(__int64, __int64, __int64);
unsigned __int64 __fastcall profil(__int64, unsigned __int64, __int64, int);
__int64 _profile_frequency();
__int64 (*__fastcall dl_fixup(__int64, unsigned int, double, double, double, double, double, double, double, double))(void);
__int64 (*__fastcall dl_profile_fixup(__int64, unsigned int, __int64, double, double, double, double, double, double, double, double, __int64, _QWORD *))(void);
void dl_call_pltexit();
__int64 __fastcall add_to_global(__int64, __int64, __int64, __int64, __int64, __int64);
_QWORD *__fastcall dl_find_dso_for_object(unsigned __int64);
__int64 __fastcall dl_open(void *a1, int a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, __int64 a7);
signed __int64 __fastcall dl_show_scope(_QWORD *, unsigned int);
signed __int64 __fastcall dl_open_worker(__int64, double, double, double, double, double, double, double, double);
__int64 __fastcall remove_slotinfo(__int64, unsigned __int64 *, __int64, unsigned __int8);
void __fastcall dl_close_worker(__int64, char);
void __fastcall sub_47506E(__int64, char);
void __fastcall dl_close(__int64);
void __fastcall dl_sort_maps(__int64, unsigned int, __int64, char);
unsigned __int64 (__fastcall *__fastcall dl_tlsdesc_resolve_rela_fixup(__int64, __int64, double, double, double, double, double, double, double, double))();
__int64 __fastcall dl_tlsdesc_resolve_hold_fixup(__int64);
unsigned __int64 __fastcall dl_unmap(__int64);
char __fastcall dl_cet_open_check(__int64);
__int64 __fastcall dl_addr(unsigned __int64, _QWORD *, _QWORD *, _QWORD *);
__int64 __fastcall dl_addr_inside_object(__int64, __int64);
__int64 __fastcall _mpn_add_n(__int64, __int64 *, __int64 *, __int64);
unsigned __int64 __fastcall _mpn_addmul_1(__int64 *, unsigned __int64 *, __int64, unsigned __int64);
__int64 __fastcall dlopen_doit(__int64);
__int64 __fastcall _dlopen(__int64, int, __int64, __int64, u32 *, unsigned __int64);
void __fastcall dlclose_doit(__int64);
_BOOL8 __fastcall _dlclose(__int64, __int64, __int64, __int64, u32 *, unsigned __int64);
__int64 (*__fastcall dlsym_doit(__int64 a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9))(void);
__int64 __fastcall _dlsym(__int64, __int64, __int64, __int64, u32 *, unsigned __int64);
__int64 (*__fastcall dlvsym_doit(__int64 a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9))(void);
__int64 __fastcall _dlvsym(__int64, __int64, __int64, __int64, u32 *, unsigned __int64);
unsigned __int64 __fastcall setitimer(int, struct itimerval *, struct itimerval *);
__int64 __fastcall dl_build_local_scope(_QWORD *, __int64);
u32 *__fastcall openaux(__int64);
__int64 *__fastcall dl_map_object_deps(__int64, __int64 *, __int64, int, __int64, unsigned __int64);
__int64 __fastcall call_init_part_0(__int64, unsigned int, __int64, __int64);
_DWORD *__fastcall dl_init(__int64, unsigned int, __int64, __int64);
__int64 __fastcall dl_check_map_versions(_QWORD *a1, unsigned int a2, int a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11, __int64 a12, u32 *a13, __int64 a14);
__int64 __fastcall dl_check_all_versions(__int64 a1, unsigned int a2, int a3, __int64 a4, u32 *a5, __int64 a6, double a7, double a8, double a9, double a10, double a11, double a12, double a13, double a14);
__int64 __fastcall call_dl_lookup(__int64, double, double, double, double, double, double, double, double);
__int64 (*__fastcall do_sym(__int64 a1, unsigned __int8 *a2, unsigned __int64 a3, const char **a4, int a5, double a6, double a7, double a8, double a9, double a10, double a11, double a12, double a13))(void);
__int64 (*__fastcall dl_vsym(__int64 a1, unsigned __int8 *a2, unsigned __int8 *a3, unsigned __int64 a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11, double a12))(void);
__int64 (*__fastcall dl_sym(__int64 a1, unsigned __int8 *a2, unsigned __int64 a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11))(void);
unsigned __int64 __fastcall _unordtf2(__m128, __m128);
__int64 __fastcall _lttf2(__m128 a1, __m128 a2);
void __fastcall _sfp_handle_exceptions(char);
_QWORD *__fastcall read_encoded_value_with_base(char, __int64, __int64, _QWORD *);
__int64 __fastcall base_of_encoded_value(char, _QWORD *, __int64, __int64, u32 *, u32);
void __fastcall execute_cfa_program(_BYTE *, unsigned __int64, __int64, _QWORD *);
void init_dwarf_reg_size_table();
__int64 __fastcall uw_frame_state_for(_QWORD *, char *, __int64, __int64, u32 *, __int64);
__int64 __fastcall execute_stack_op(unsigned __int8 *, unsigned __int64, __int64, __int64);
__int64 __fastcall uw_update_context_1(const __m128i *a1, __int64 a2, __int64 a3, __int64 a4, u32 *a5, u32 a6);
__int64 __fastcall uw_init_context_1(__m128i *a1, __int64 a2, __int64 a3, __int64 a4, u32 *a5, __int64 a6);
__int64 __fastcall uw_update_context(const __m128i *, __int64, __int64, __int64, u32 *, u32);
__int64 __fastcall Unwind_RaiseException_Phase2(_QWORD *, __m128i *, __int64 *, __int64, u32 *, __int64);
__int64 __fastcall Unwind_ForcedUnwind_Phase2(_QWORD *, __m128i *, __int64 *, __int64, u32 *, __int64);
char *__fastcall uw_install_context_1(unsigned __int64, char *);
__int64 __fastcall Unwind_GetGR(__int64, int);
__int64 __fastcall Unwind_GetCFA(__int64);
__int64 __fastcall Unwind_SetGR(__int64, int, __int64);
__int64 __fastcall Unwind_GetIP(__int64);
__int64 __fastcall Unwind_GetIPInfo(__int64, _DWORD *);
void __fastcall Unwind_SetIP(__int64, __int64);
__int64 __fastcall Unwind_GetLanguageSpecificData(__int64);
__int64 __fastcall Unwind_GetRegionStart(__int64);
unsigned int *__fastcall Unwind_FindEnclosingFunction(__int64, __int64, unsigned __int64, __int64 *, u32 *, __int64);
__int64 __fastcall Unwind_GetDataRelBase(__int64);
__int64 __fastcall Unwind_GetTextRelBase(__int64);
__int64 __fastcall _frame_state_for(__int64, __int64, __int64, __int64, __int64, __int64);
void Unwind_DebugHook();
__int64 __fastcall Unwind_RaiseException(_QWORD *, __int64, __int64, __int64, u32 *, __int64, char);
__int64 __fastcall Unwind_ForcedUnwind(_QWORD *, __int64, __int64, __int64, u32 *, __int64, char);
void __fastcall __noreturn Unwind_Resume(_QWORD *, __int64, __int64, __int64, u32 *, __int64, char);
void __fastcall __noreturn Unwind_Resume_or_Rethrow(_QWORD *, __int64, __int64, __int64, u32 *, __int64, char);
__int64 (__fastcall *__fastcall Unwind_DeleteException(__int64))(__int64, __int64);
__int64 __fastcall Unwind_Backtrace(unsigned int (__fastcall *)(__m128i *, __int64), __int64, __int64, __int64, u32 *, __int64, char);
__int64 __fastcall fde_unencoded_compare(__int64, __int64, __int64);
void __fastcall frame_downheap(__int64, __int64 (__fastcall *)(__int64, __int64, _QWORD), __int64, int, __int64, _QWORD *);
void __fastcall frame_heapsort(__int64, __int64 (__fastcall *)(__int64, __int64, _QWORD), __int64, __int64, __int64, _QWORD *);
__int64 __fastcall size_of_encoded_value(char, __int64, __int64, __int64, u32 *, u32);
__int64 __fastcall base_from_object(char, __int64, __int64, __int64, u32 *, u32);
__int64 __fastcall base_from_cb_data(char, __int64, __int64, __int64, u32 *, u32);
_QWORD *__fastcall read_encoded_value_with_base_0(char, __int64, __int64, _QWORD *);
__int64 __fastcall fde_single_encoding_compare(__int64, __int64, __int64, __int64, u32 *, u32);
__int64 __fastcall get_cie_encoding(_BYTE *);
unsigned int *__fastcall linear_search_fdes(__int64, unsigned int *, __int64, __int64, __int64, u32);
__int64 __fastcall Unwind_IteratePhdrCallback(__int64 *, unsigned __int64, __int64, __int64, __int64, unsigned __int64);
__int64 __fastcall fde_mixed_encoding_compare(__int64, __int64, __int64);
__int64 __fastcall classify_object_over_fdes(__int64, unsigned int *);
__int64 __fastcall add_fdes(__int64, __int64 *, __int64, __int64, __int64, u32);
unsigned int *__fastcall search_object(__int64, __int64, __int64, __int64, u32 *, __int64);
__int64 __fastcall _register_frame_info_bases_part_5(__int64, _QWORD *, __int64, __int64);
__int64 __fastcall _register_frame_info_bases(unsigned int *a1, _QWORD *a2, __int64 a3, __int64 a4);
__int64 __fastcall _register_frame_info(unsigned int *, _QWORD *);
__int64 __fastcall _register_frame(unsigned int *, __int64, _QWORD *, __int64, u32 *, __int64);
__int64 __fastcall _register_frame_info_table_bases(__int64, _QWORD *, __int64, __int64);
__int64 __fastcall _register_frame_info_table(__int64, _QWORD *);
__int64 __fastcall _register_frame_table(__int64, __int64, _QWORD *, __int64, u32 *, __int64);
__int64 __fastcall _deregister_frame_info_bases(_DWORD *, __int64, __int64, __int64, u32 *, unsigned __int64);
__int64 __fastcall _deregister_frame_info(_DWORD *, __int64, __int64, __int64, u32 *, unsigned __int64);
__int64 *__fastcall _deregister_frame(_DWORD *, __int64, __int64, __int64, u32 *, unsigned __int64);
unsigned int *__fastcall Unwind_Find_FDE(unsigned __int64, _QWORD *, unsigned __int64, __int64 *, u32 *, __int64);
__int64 __fastcall base_of_encoded_value_0(__int64, __int64, __int64, __int64, u32 *, u32);
_QWORD *__fastcall read_encoded_value_with_base_1(char, __int64, __int64, _QWORD *);
__int64 __fastcall _gcc_personality_v0(int, char, __int64, __int64, __int64);
__int64 __fastcall dl_iterate_phdr(__int64 (__fastcall *)(__int64 *, __int64, __int64), __int64);
__int64 *__fastcall free_mem(__int64, __int64, __int64, __int64, u32 *, unsigned __int64);
__int64 *__fastcall nl_finddomain_subfreeres(__int64, size_t, __int64, __int64, u32 *, unsigned __int64);
__int64 *__fastcall nl_unload_domain(__int64, size_t, __int64, __int64, u32 *, unsigned __int64);
__int64 *__fastcall buffer_free(__int64, __int64, __int64, __int64, u32 *, unsigned __int64);
__int64 *__fastcall free_derivation(__int64, __int64, __int64, __int64, u32 *, unsigned __int64);
__int64 *__fastcall free_modules_db(_QWORD *a1, __int64 a2, __int64 a3, __int64 a4, u32 *a5, unsigned __int64 a6);
__int64 *__fastcall free_mem_0(__int64, __int64 *(__fastcall *)(__int64 a1, __int64 a2, __int64 a3, __int64 a4, u32 *a5, unsigned __int64 a6), __int64, __int64, u32 *, unsigned __int64);
__int64 *__fastcall free_mem_1(__int64, __int64, __int64, __int64, u32 *, unsigned __int64);
unsigned __int64 __fastcall free_mem_2(__int64, __int64, __int64, __int64, u32 *, unsigned __int64);
__int64 *__fastcall do_release_all(__int64, __int64, __int64, __int64, u32 *, unsigned __int64);
__int64 *free_mem_3();
__int64 *__fastcall free_category(int a1, void **a2, void **a3, __int64 a4, u32 *a5, unsigned __int64 a6);
void __fastcall nl_locale_subfreeres(__int64, __int64, __int64, __int64, u32 *, unsigned __int64);
void __fastcall nl_archive_subfreeres(__int64, __int64, __int64, __int64, u32 *, unsigned __int64);
__int64 *__fastcall free_mem_4(__int64, __int64, __int64, __int64, u32 *, unsigned __int64);
__int64 *__fastcall free_mem_5(__int64, __int64, __int64, __int64, u32 *, unsigned __int64);
__int64 __fastcall free_slotinfo(__int64 **);
__int64 *__fastcall free_mem_6(__int64, __int64, __int64, __int64, u32 *, unsigned __int64);

//-------------------------------------------------------------------------
// Data declarations

_UNKNOWN dl_runtime_profile_avx512; // weak
_UNKNOWN dl_runtime_profile_avx; // weak
unsigned __int8 yyr2[16] = { 0u, 2u, 1u, 5u, 3u, 3u, 3u, 3u, 3u, 3u, 2u, 1u, 1u, 3u, 0u, 0u }; // weak
unsigned __int8 yyr1[32] =
{
  0u,
  16u,
  17u,
  18u,
  18u,
  18u,
  18u,
  18u,
  18u,
  18u,
  18u,
  18u,
  18u,
  18u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u
}; // weak
char yycheck[64] =
{
  '\x01',
  '\n',
  '\v',
  '\x04',
  '\r',
  '\x0E',
  '\b',
  '\t',
  '\0',
  '\n',
  '\v',
  '\f',
  '\r',
  '\x0E',
  '\x0F',
  '\x10',
  '\x03',
  '\x04',
  '\x05',
  '\x06',
  '\a',
  '\b',
  '\t',
  '\t',
  '\x19',
  '\a',
  '\b',
  '\t',
  '\x0F',
  '\x03',
  '\x04',
  '\x05',
  '\x06',
  '\a',
  '\b',
  '\t',
  '\xFF',
  '\xFF',
  '\f',
  '\x03',
  '\x04',
  '\x05',
  '\x06',
  '\a',
  '\b',
  '\t',
  '\x05',
  '\x06',
  '\a',
  '\b',
  '\t',
  '\x06',
  '\a',
  '\b',
  '\t',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // weak
unsigned __int8 yytable[55] =
{
  7u,
  1u,
  2u,
  8u,
  3u,
  4u,
  15u,
  16u,
  9u,
  18u,
  19u,
  20u,
  21u,
  22u,
  23u,
  24u,
  10u,
  11u,
  12u,
  13u,
  14u,
  15u,
  16u,
  16u,
  26u,
  14u,
  15u,
  16u,
  17u,
  10u,
  11u,
  12u,
  13u,
  14u,
  15u,
  16u,
  0u,
  0u,
  25u,
  10u,
  11u,
  12u,
  13u,
  14u,
  15u,
  16u,
  12u,
  13u,
  14u,
  15u,
  16u,
  13u,
  14u,
  15u,
  16u
}; // weak
char yydefgoto[3] = { '\xFF', '\x05', '\x06' }; // weak
char yypgoto[6] = { '\xF6', '\xF6', '\xFF', '\0', '\0', '\0' }; // weak
unsigned __int8 yydefact[32] =
{
  0u,
  0u,
  12u,
  11u,
  0u,
  0u,
  2u,
  10u,
  0u,
  1u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  13u,
  0u,
  4u,
  5u,
  6u,
  7u,
  8u,
  9u,
  0u,
  3u,
  0u,
  0u,
  0u,
  0u,
  0u
}; // weak
char yypact[32] =
{
  '\xF7',
  '\xF7',
  '\xF6',
  '\xF6',
  '\xF7',
  '\b',
  '$',
  '\xF6',
  '\r',
  '\xF6',
  '\xF7',
  '\xF7',
  '\xF7',
  '\xF7',
  '\xF7',
  '\xF7',
  '\xF7',
  '\xF6',
  '\x1A',
  ')',
  '-',
  '\x12',
  '\xFE',
  '\x0E',
  '\xF6',
  '\xF7',
  '$',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // weak
unsigned __int8 yytranslate[263] =
{
  0u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  10u,
  2u,
  2u,
  2u,
  2u,
  5u,
  2u,
  14u,
  15u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  12u,
  2u,
  2u,
  2u,
  2u,
  3u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  13u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  4u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  2u,
  1u,
  2u,
  6u,
  7u,
  8u,
  9u,
  11u
}; // weak
int dword_481BB0[16] =
{
  -432064,
  -431744,
  -431424,
  -431104,
  -430784,
  -430464,
  -430144,
  -429824,
  -429504,
  -429184,
  -428864,
  -428544,
  -428224,
  -427904,
  -427584,
  -432224
}; // weak
int dword_481BF0[16] =
{
  -426240,
  -425952,
  -425664,
  -425376,
  -425088,
  -424800,
  -424512,
  -424224,
  -423936,
  -423648,
  -423360,
  -423072,
  -422784,
  -422496,
  -422208,
  -426400
}; // weak
int dword_481C30[16] =
{
  -420416,
  -420032,
  -419648,
  -419264,
  -418880,
  -418496,
  -418112,
  -417728,
  -417344,
  -416960,
  -416576,
  -416192,
  -415808,
  -415424,
  -415040,
  -420624
}; // weak
int dword_481C70[16] =
{
  -414240,
  -413872,
  -413504,
  -413136,
  -412768,
  -412400,
  -412032,
  -411664,
  -411296,
  -410928,
  -410560,
  -410192,
  -409824,
  -409456,
  -409088,
  -414448
}; // weak
int dword_481CB0[16] =
{
  -408336,
  -408096,
  -407856,
  -407616,
  -407376,
  -407136,
  -406896,
  -406656,
  -406416,
  -406176,
  -405936,
  -405696,
  -405456,
  -405216,
  -404976,
  -408512
}; // weak
int dword_481CF0[80] =
{
  -397441,
  -396720,
  -396994,
  -396736,
  -397455,
  -397248,
  -397008,
  -396768,
  -397498,
  -397326,
  -397118,
  -396862,
  -397472,
  -397296,
  -397056,
  -396816,
  -397515,
  -397343,
  -397135,
  -396879,
  -396623,
  -396495,
  -396367,
  -396239,
  -396111,
  -395983,
  -395839,
  -395695,
  -395551,
  -395407,
  -395247,
  -395087,
  -394962,
  -397370,
  -397162,
  -396906,
  -396650,
  -396522,
  -396394,
  -396266,
  -396138,
  -396010,
  -395866,
  -395722,
  -395578,
  -395434,
  -395274,
  -395114,
  -394985,
  -397397,
  -397189,
  -396933,
  -396677,
  -396549,
  -396421,
  -396293,
  -396165,
  -396037,
  -395893,
  -395749,
  -395605,
  -395461,
  -395301,
  -395141,
  -395008,
  -397424,
  -397216,
  -396960,
  -396704,
  -396576,
  -396448,
  -396320,
  -396192,
  -396064,
  -395920,
  -395776,
  -395632,
  -395488,
  -395328,
  -395168
}; // weak
int dword_481E30[80] =
{
  -388280,
  -387824,
  -387344,
  -386864,
  -386384,
  -385872,
  -385360,
  -384848,
  -388288,
  -387840,
  -387360,
  -386880,
  -386400,
  -385904,
  -385392,
  -384880,
  -388320,
  -387872,
  -387392,
  -386912,
  -386432,
  -385936,
  -385424,
  -384912,
  -388352,
  -387904,
  -387424,
  -386944,
  -386464,
  -385984,
  -385472,
  -384960,
  -388400,
  -387952,
  -387472,
  -386992,
  -386512,
  -386032,
  -385520,
  -385008,
  -388448,
  -388000,
  -387520,
  -387040,
  -386560,
  -386096,
  -385584,
  -385072,
  -388512,
  -388064,
  -387584,
  -387104,
  -386624,
  -386160,
  -385648,
  -385136,
  -388576,
  -388128,
  -387648,
  -387168,
  -386688,
  -386224,
  -385712,
  -385200,
  -388640,
  -388192,
  -387728,
  -387248,
  -386752,
  -386288,
  -385776,
  -385264,
  -388704,
  -388272,
  -387808,
  -387328,
  -386832,
  -386368,
  -385856,
  -385344
}; // weak
int dword_481F70[16] =
{
  -395168,
  -394064,
  -393728,
  -393392,
  -393056,
  -392720,
  -392384,
  -392048,
  -391712,
  -391376,
  -391040,
  -390704,
  -390368,
  -390032,
  -389696,
  -389360
}; // weak
int dword_481FB0[16] =
{
  -394672,
  -393952,
  -393616,
  -393280,
  -392944,
  -392608,
  -392272,
  -391936,
  -391600,
  -391264,
  -390928,
  -390592,
  -390256,
  -389920,
  -389584,
  -389248
}; // weak
int dword_481FF0[80] =
{
  -378008,
  -377552,
  -377072,
  -376592,
  -376112,
  -375600,
  -375088,
  -374576,
  -378016,
  -377568,
  -377088,
  -376608,
  -376128,
  -375632,
  -375120,
  -374608,
  -378048,
  -377600,
  -377120,
  -376640,
  -376160,
  -375664,
  -375152,
  -374640,
  -378080,
  -377632,
  -377152,
  -376672,
  -376192,
  -375712,
  -375200,
  -374688,
  -378128,
  -377680,
  -377200,
  -376720,
  -376240,
  -375760,
  -375248,
  -374736,
  -378176,
  -377728,
  -377248,
  -376768,
  -376288,
  -375824,
  -375312,
  -374800,
  -378240,
  -377792,
  -377312,
  -376832,
  -376352,
  -375888,
  -375376,
  -374864,
  -378304,
  -377856,
  -377376,
  -376896,
  -376416,
  -375952,
  -375440,
  -374928,
  -378368,
  -377920,
  -377456,
  -376976,
  -376480,
  -376016,
  -375504,
  -374992,
  -378432,
  -378000,
  -377536,
  -377056,
  -376560,
  -376096,
  -375584,
  -375072
}; // weak
int dword_482130[16] =
{
  -384896,
  -383792,
  -383456,
  -383120,
  -382784,
  -382448,
  -382112,
  -381776,
  -381440,
  -381104,
  -380768,
  -380432,
  -380096,
  -379760,
  -379424,
  -379088
}; // weak
int dword_482170[16] =
{
  -384400,
  -383680,
  -383344,
  -383008,
  -382672,
  -382336,
  -382000,
  -381664,
  -381328,
  -380992,
  -380656,
  -380320,
  -379984,
  -379648,
  -379312,
  -378976
}; // weak
int dword_4821B0[144] =
{
  -364786,
  -363120,
  -363232,
  -363344,
  -363456,
  -363568,
  -363680,
  -363792,
  -363904,
  -364016,
  -364128,
  -364240,
  -364352,
  -364464,
  -364576,
  -364688,
  -364794,
  -363146,
  -363258,
  -363370,
  -363482,
  -363594,
  -363706,
  -363818,
  -363930,
  -364042,
  -364154,
  -364266,
  -364378,
  -364490,
  -364602,
  -364714,
  -364804,
  -363156,
  -363268,
  -363380,
  -363492,
  -363604,
  -363716,
  -363828,
  -363940,
  -364052,
  -364164,
  -364276,
  -364388,
  -364500,
  -364612,
  -364724,
  -364814,
  -363166,
  -363278,
  -363390,
  -363502,
  -363614,
  -363726,
  -363838,
  -363950,
  -364062,
  -364174,
  -364286,
  -364398,
  -364510,
  -364622,
  -364734,
  -364824,
  -363176,
  -363288,
  -363400,
  -363512,
  -363624,
  -363736,
  -363848,
  -363960,
  -364072,
  -364184,
  -364296,
  -364408,
  -364520,
  -364632,
  -364744,
  -364834,
  -363186,
  -363298,
  -363410,
  -363522,
  -363634,
  -363746,
  -363858,
  -363970,
  -364082,
  -364194,
  -364306,
  -364418,
  -364530,
  -364642,
  -364754,
  -364844,
  -363196,
  -363308,
  -363420,
  -363532,
  -363644,
  -363756,
  -363868,
  -363980,
  -364092,
  -364204,
  -364316,
  -364428,
  -364540,
  -364652,
  -364764,
  -364854,
  -363206,
  -363318,
  -363430,
  -363542,
  -363654,
  -363766,
  -363878,
  -363990,
  -364102,
  -364214,
  -364326,
  -364438,
  -364550,
  -364662,
  -364774,
  -364864,
  -363216,
  -363328,
  -363440,
  -363552,
  -363664,
  -363776,
  -363888,
  -364000,
  -364112,
  -364224,
  -364336,
  -364448,
  -364560,
  -364672,
  -364784
}; // weak
int dword_4823F0[144] =
{
  -367440,
  -365456,
  -365584,
  -365728,
  -365856,
  -365984,
  -366112,
  -366240,
  -366368,
  -366496,
  -366624,
  -366752,
  -366880,
  -367024,
  -367168,
  -367312,
  -367450,
  -365492,
  -365620,
  -365764,
  -365892,
  -366020,
  -366148,
  -366276,
  -366404,
  -366532,
  -366660,
  -366788,
  -366916,
  -367060,
  -367204,
  -367348,
  -367460,
  -365502,
  -365630,
  -365774,
  -365902,
  -366030,
  -366158,
  -366286,
  -366414,
  -366542,
  -366670,
  -366798,
  -366926,
  -367070,
  -367214,
  -367358,
  -367470,
  -365512,
  -365640,
  -365784,
  -365912,
  -366040,
  -366168,
  -366296,
  -366424,
  -366552,
  -366680,
  -366808,
  -366936,
  -367080,
  -367224,
  -367368,
  -367480,
  -365522,
  -365650,
  -365794,
  -365922,
  -366050,
  -366178,
  -366306,
  -366434,
  -366562,
  -366690,
  -366818,
  -366946,
  -367090,
  -367234,
  -367378,
  -367490,
  -365532,
  -365660,
  -365804,
  -365932,
  -366060,
  -366188,
  -366316,
  -366444,
  -366572,
  -366700,
  -366828,
  -366956,
  -367100,
  -367244,
  -367388,
  -367500,
  -365542,
  -365670,
  -365814,
  -365942,
  -366070,
  -366198,
  -366326,
  -366454,
  -366582,
  -366710,
  -366838,
  -366966,
  -367110,
  -367254,
  -367398,
  -367510,
  -365552,
  -365680,
  -365824,
  -365952,
  -366080,
  -366208,
  -366336,
  -366464,
  -366592,
  -366720,
  -366848,
  -366976,
  -367120,
  -367264,
  -367408,
  -367520,
  -365568,
  -365696,
  -365840,
  -365968,
  -366096,
  -366224,
  -366352,
  -366480,
  -366608,
  -366736,
  -366864,
  -366992,
  -367136,
  -367280,
  -367424
}; // weak
int dword_482630[16] =
{
  -374960,
  -374672,
  -374288,
  -373904,
  -373520,
  -373136,
  -372752,
  -372368,
  -371984,
  -371600,
  -371216,
  -370832,
  -370448,
  -370064,
  -369680,
  -369296
}; // weak
int dword_482670[16] =
{
  -374864,
  -374544,
  -374160,
  -373776,
  -373392,
  -373008,
  -372624,
  -372240,
  -371856,
  -371472,
  -371088,
  -370704,
  -370320,
  -369936,
  -369552,
  -369168
}; // weak
int dword_4826B0[144] =
{
  -355010,
  -353344,
  -353456,
  -353568,
  -353680,
  -353792,
  -353904,
  -354016,
  -354128,
  -354240,
  -354352,
  -354464,
  -354576,
  -354688,
  -354800,
  -354912,
  -355018,
  -353370,
  -353482,
  -353594,
  -353706,
  -353818,
  -353930,
  -354042,
  -354154,
  -354266,
  -354378,
  -354490,
  -354602,
  -354714,
  -354826,
  -354938,
  -355028,
  -353380,
  -353492,
  -353604,
  -353716,
  -353828,
  -353940,
  -354052,
  -354164,
  -354276,
  -354388,
  -354500,
  -354612,
  -354724,
  -354836,
  -354948,
  -355038,
  -353390,
  -353502,
  -353614,
  -353726,
  -353838,
  -353950,
  -354062,
  -354174,
  -354286,
  -354398,
  -354510,
  -354622,
  -354734,
  -354846,
  -354958,
  -355048,
  -353400,
  -353512,
  -353624,
  -353736,
  -353848,
  -353960,
  -354072,
  -354184,
  -354296,
  -354408,
  -354520,
  -354632,
  -354744,
  -354856,
  -354968,
  -355058,
  -353410,
  -353522,
  -353634,
  -353746,
  -353858,
  -353970,
  -354082,
  -354194,
  -354306,
  -354418,
  -354530,
  -354642,
  -354754,
  -354866,
  -354978,
  -355068,
  -353420,
  -353532,
  -353644,
  -353756,
  -353868,
  -353980,
  -354092,
  -354204,
  -354316,
  -354428,
  -354540,
  -354652,
  -354764,
  -354876,
  -354988,
  -355078,
  -353430,
  -353542,
  -353654,
  -353766,
  -353878,
  -353990,
  -354102,
  -354214,
  -354326,
  -354438,
  -354550,
  -354662,
  -354774,
  -354886,
  -354998,
  -355088,
  -353440,
  -353552,
  -353664,
  -353776,
  -353888,
  -354000,
  -354112,
  -354224,
  -354336,
  -354448,
  -354560,
  -354672,
  -354784,
  -354896,
  -355008
}; // weak
int dword_4828F0[144] =
{
  -357664,
  -355680,
  -355808,
  -355952,
  -356080,
  -356208,
  -356336,
  -356464,
  -356592,
  -356720,
  -356848,
  -356976,
  -357104,
  -357248,
  -357392,
  -357536,
  -357674,
  -355716,
  -355844,
  -355988,
  -356116,
  -356244,
  -356372,
  -356500,
  -356628,
  -356756,
  -356884,
  -357012,
  -357140,
  -357284,
  -357428,
  -357572,
  -357684,
  -355726,
  -355854,
  -355998,
  -356126,
  -356254,
  -356382,
  -356510,
  -356638,
  -356766,
  -356894,
  -357022,
  -357150,
  -357294,
  -357438,
  -357582,
  -357694,
  -355736,
  -355864,
  -356008,
  -356136,
  -356264,
  -356392,
  -356520,
  -356648,
  -356776,
  -356904,
  -357032,
  -357160,
  -357304,
  -357448,
  -357592,
  -357704,
  -355746,
  -355874,
  -356018,
  -356146,
  -356274,
  -356402,
  -356530,
  -356658,
  -356786,
  -356914,
  -357042,
  -357170,
  -357314,
  -357458,
  -357602,
  -357714,
  -355756,
  -355884,
  -356028,
  -356156,
  -356284,
  -356412,
  -356540,
  -356668,
  -356796,
  -356924,
  -357052,
  -357180,
  -357324,
  -357468,
  -357612,
  -357724,
  -355766,
  -355894,
  -356038,
  -356166,
  -356294,
  -356422,
  -356550,
  -356678,
  -356806,
  -356934,
  -357062,
  -357190,
  -357334,
  -357478,
  -357622,
  -357734,
  -355776,
  -355904,
  -356048,
  -356176,
  -356304,
  -356432,
  -356560,
  -356688,
  -356816,
  -356944,
  -357072,
  -357200,
  -357344,
  -357488,
  -357632,
  -357744,
  -355792,
  -355920,
  -356064,
  -356192,
  -356320,
  -356448,
  -356576,
  -356704,
  -356832,
  -356960,
  -357088,
  -357216,
  -357360,
  -357504,
  -357648
}; // weak
int dword_482B30[16] =
{
  -365232,
  -364944,
  -364560,
  -364176,
  -363792,
  -363408,
  -363024,
  -362640,
  -362256,
  -361872,
  -361488,
  -361104,
  -360720,
  -360336,
  -359952,
  -359568
}; // weak
int dword_482B70[16] =
{
  -365136,
  -364816,
  -364432,
  -364048,
  -363664,
  -363280,
  -362896,
  -362512,
  -362128,
  -361744,
  -361360,
  -360976,
  -360592,
  -360208,
  -359824,
  -359440
}; // weak
__int128 xmmword_482BB0 = 0x40404040404040404040404040404040LL; // weak
__int128 xmmword_482BC0 = 0x5B5B5B5B5B5B5B5B5B5B5B5B5B5B5B5BLL; // weak
__int128 blanks = 0x20202020202020202020202020202020LL; // weak
int dword_482BE0[16] =
{
  -352064,
  -351536,
  -351008,
  -350480,
  -349952,
  -349424,
  -348896,
  -348368,
  -347840,
  -347312,
  -346784,
  -346256,
  -345728,
  -345200,
  -344672,
  -352448
}; // weak
int dword_482C20[16] =
{
  -343344,
  -342832,
  -342320,
  -341808,
  -341296,
  -340784,
  -340272,
  -339760,
  -339248,
  -338736,
  -338224,
  -337712,
  -337200,
  -336688,
  -336176,
  -343728
}; // weak
int dword_482C60[16] =
{
  -334896,
  -334480,
  -334064,
  -333648,
  -333232,
  -332816,
  -332400,
  -331984,
  -331568,
  -331152,
  -330736,
  -330320,
  -329904,
  -329488,
  -329072,
  -335264
}; // weak
int dword_482CB0[16] =
{
  -328000,
  -327664,
  -327328,
  -326992,
  -326656,
  -326320,
  -325984,
  -325648,
  -325312,
  -324976,
  -324640,
  -324304,
  -323968,
  -323632,
  -323296,
  -328272
}; // weak
int dword_482CF0[32] =
{
  -306304,
  -306288,
  -306272,
  -306256,
  -306240,
  -306224,
  -306208,
  -306192,
  -306176,
  -306160,
  -306144,
  -306128,
  -306112,
  -306096,
  -306080,
  -306064,
  -306048,
  -306032,
  -306000,
  -305984,
  -305968,
  -305936,
  -305904,
  -305872,
  -305840,
  -305808,
  -305776,
  -305744,
  -305712,
  -305680,
  -305648,
  -305616
}; // weak
int dword_482D70[32] =
{
  -304848,
  -304832,
  -304816,
  -304800,
  -304784,
  -304768,
  -304736,
  -304720,
  -304704,
  -304688,
  -304656,
  -304624,
  -304592,
  -304560,
  -304528,
  -304496,
  -304480,
  -304464,
  -304432,
  -304400,
  -304368,
  -304336,
  -304304,
  -304272,
  -304240,
  -304208,
  -304176,
  -304144,
  -304112,
  -304080,
  -304048,
  -304016
}; // weak
_UNKNOWN __m128i_shift_right; // weak
_UNKNOWN intel_02_known; // weak
_UNKNOWN unk_4836DD; // weak
char aVarTmp[9] = "/var/tmp"; // weak
char unsecure_envvars_10823[11] = "GCONV_PATH"; // weak
char dl_x86_hwcap_flags[5] = "sse2"; // weak
_UNKNOWN unk_484270; // weak
int gconv_module_ext = 7303982; // weak
__int128 default_gconv_path = 0x766E6F63672F343662696C2F7273752FLL; // weak
_UNKNOWN empty_path_elem; // weak
_BYTE inmask_11790[5] = { -64, -32, -16, -8, -4 }; // weak
unsigned __int8 nl_category_name_sizes[16] = { 8u, 10u, 7u, 10u, 11u, 11u, 6u, 8u, 7u, 10u, 12u, 14u, 17u, 0u, 0u, 0u }; // weak
unsigned __int8 nl_category_name_idxs[16] = { 11u, 32u, 43u, 0u, 20u, 51u, 0u, 63u, 72u, 80u, 91u, 104u, 119u, 0u, 0u, 0u }; // weak
char nl_category_names[11] = "LC_COLLATE"; // weak
int codeset_idx_10299[16] = { 14, 5, 110, 18, 45, 4, 0, 2, 6, 12, 4, 1, 15, 0, 0, 0 }; // weak
_QWORD nl_category_num_items[14] = { 86LL, 6LL, 159LL, 19LL, 46LL, 5LL, 0LL, 3LL, 7LL, 13LL, 5LL, 2LL, 16LL, 0LL }; // weak
_DWORD dword_4860E0[256] =
{
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  13,
  14,
  15,
  16,
  17,
  18,
  19,
  20,
  21,
  22,
  23,
  24,
  25,
  26,
  27,
  28,
  29,
  30,
  31,
  32,
  33,
  34,
  35,
  36,
  37,
  38,
  39,
  40,
  41,
  42,
  43,
  44,
  45,
  46,
  47,
  48,
  49,
  50,
  51,
  52,
  53,
  54,
  55,
  56,
  57,
  58,
  59,
  60,
  61,
  62,
  63,
  64,
  97,
  98,
  99,
  100,
  101,
  102,
  103,
  104,
  105,
  106,
  107,
  108,
  109,
  110,
  111,
  112,
  113,
  114,
  115,
  116,
  117,
  118,
  119,
  120,
  121,
  122,
  91,
  92,
  93,
  94,
  95,
  96,
  97,
  98,
  99,
  100,
  101,
  102,
  103,
  104,
  105,
  106,
  107,
  108,
  109,
  110,
  111,
  112,
  113,
  114,
  115,
  116,
  117,
  118,
  119,
  120,
  121,
  122,
  123,
  124,
  125,
  126,
  127,
  128,
  129,
  130,
  131,
  132,
  133,
  134,
  135,
  136,
  137,
  138,
  139,
  140,
  141,
  142,
  143,
  144,
  145,
  146,
  147,
  148,
  149,
  150,
  151,
  152,
  153,
  154,
  155,
  156,
  157,
  158,
  159,
  160,
  161,
  162,
  163,
  164,
  165,
  166,
  167,
  168,
  169,
  170,
  171,
  172,
  173,
  174,
  175,
  176,
  177,
  178,
  179,
  180,
  181,
  182,
  183,
  184,
  185,
  186,
  187,
  188,
  189,
  190,
  191,
  192,
  193,
  194,
  195,
  196,
  197,
  198,
  199,
  200,
  201,
  202,
  203,
  204,
  205,
  206,
  207,
  208,
  209,
  210,
  211,
  212,
  213,
  214,
  215,
  216,
  217,
  218,
  219,
  220,
  221,
  222,
  223,
  224,
  225,
  226,
  227,
  228,
  229,
  230,
  231,
  232,
  233,
  234,
  235,
  236,
  237,
  238,
  239,
  240,
  241,
  242,
  243,
  244,
  245,
  246,
  247,
  248,
  249,
  250,
  251,
  252,
  253,
  254,
  255
}; // weak
unsigned int dword_4866E0[256] =
{
  0u,
  1u,
  2u,
  3u,
  4u,
  5u,
  6u,
  7u,
  8u,
  9u,
  10u,
  11u,
  12u,
  13u,
  14u,
  15u,
  16u,
  17u,
  18u,
  19u,
  20u,
  21u,
  22u,
  23u,
  24u,
  25u,
  26u,
  27u,
  28u,
  29u,
  30u,
  31u,
  32u,
  33u,
  34u,
  35u,
  36u,
  37u,
  38u,
  39u,
  40u,
  41u,
  42u,
  43u,
  44u,
  45u,
  46u,
  47u,
  48u,
  49u,
  50u,
  51u,
  52u,
  53u,
  54u,
  55u,
  56u,
  57u,
  58u,
  59u,
  60u,
  61u,
  62u,
  63u,
  64u,
  65u,
  66u,
  67u,
  68u,
  69u,
  70u,
  71u,
  72u,
  73u,
  74u,
  75u,
  76u,
  77u,
  78u,
  79u,
  80u,
  81u,
  82u,
  83u,
  84u,
  85u,
  86u,
  87u,
  88u,
  89u,
  90u,
  91u,
  92u,
  93u,
  94u,
  95u,
  96u,
  65u,
  66u,
  67u,
  68u,
  69u,
  70u,
  71u,
  72u,
  73u,
  74u,
  75u,
  76u,
  77u,
  78u,
  79u,
  80u,
  81u,
  82u,
  83u,
  84u,
  85u,
  86u,
  87u,
  88u,
  89u,
  90u,
  123u,
  124u,
  125u,
  126u,
  127u,
  128u,
  129u,
  130u,
  131u,
  132u,
  133u,
  134u,
  135u,
  136u,
  137u,
  138u,
  139u,
  140u,
  141u,
  142u,
  143u,
  144u,
  145u,
  146u,
  147u,
  148u,
  149u,
  150u,
  151u,
  152u,
  153u,
  154u,
  155u,
  156u,
  157u,
  158u,
  159u,
  160u,
  161u,
  162u,
  163u,
  164u,
  165u,
  166u,
  167u,
  168u,
  169u,
  170u,
  171u,
  172u,
  173u,
  174u,
  175u,
  176u,
  177u,
  178u,
  179u,
  180u,
  181u,
  182u,
  183u,
  184u,
  185u,
  186u,
  187u,
  188u,
  189u,
  190u,
  191u,
  192u,
  193u,
  194u,
  195u,
  196u,
  197u,
  198u,
  199u,
  200u,
  201u,
  202u,
  203u,
  204u,
  205u,
  206u,
  207u,
  208u,
  209u,
  210u,
  211u,
  212u,
  213u,
  214u,
  215u,
  216u,
  217u,
  218u,
  219u,
  220u,
  221u,
  222u,
  223u,
  224u,
  225u,
  226u,
  227u,
  228u,
  229u,
  230u,
  231u,
  232u,
  233u,
  234u,
  235u,
  236u,
  237u,
  238u,
  239u,
  240u,
  241u,
  242u,
  243u,
  244u,
  245u,
  246u,
  247u,
  248u,
  249u,
  250u,
  251u,
  252u,
  253u,
  254u,
  255u
}; // weak
_WORD word_486FE0[256] =
{
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  8195,
  8194,
  8194,
  8194,
  8194,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  24577,
  -16380,
  -16380,
  -16380,
  -16380,
  -16380,
  -16380,
  -16380,
  -16380,
  -16380,
  -16380,
  -16380,
  -16380,
  -16380,
  -16380,
  -16380,
  -10232,
  -10232,
  -10232,
  -10232,
  -10232,
  -10232,
  -10232,
  -10232,
  -10232,
  -10232,
  -16380,
  -16380,
  -16380,
  -16380,
  -16380,
  -16380,
  -16380,
  -11000,
  -11000,
  -11000,
  -11000,
  -11000,
  -11000,
  -15096,
  -15096,
  -15096,
  -15096,
  -15096,
  -15096,
  -15096,
  -15096,
  -15096,
  -15096,
  -15096,
  -15096,
  -15096,
  -15096,
  -15096,
  -15096,
  -15096,
  -15096,
  -15096,
  -15096,
  -16380,
  -16380,
  -16380,
  -16380,
  -16380,
  -16380,
  -10744,
  -10744,
  -10744,
  -10744,
  -10744,
  -10744,
  -14840,
  -14840,
  -14840,
  -14840,
  -14840,
  -14840,
  -14840,
  -14840,
  -14840,
  -14840,
  -14840,
  -14840,
  -14840,
  -14840,
  -14840,
  -14840,
  -14840,
  -14840,
  -14840,
  -14840,
  -16380,
  -16380,
  -16380,
  -16380,
  2,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0
}; // weak
_BYTE _strtol_ul_rem_tab[6] = { 1, 0, 3, 0, 3, 1 }; // weak
_QWORD _strtol_ul_max_tab[6] =
{
  9223372036854775807LL,
  6148914691236517205LL,
  4611686018427387903LL,
  3689348814741910323LL,
  3074457345618258602LL,
  2635249153387078802LL
}; // weak
unsigned __int8 jump_table[91] =
{
  1u,
  0u,
  0u,
  4u,
  0u,
  14u,
  0u,
  6u,
  0u,
  0u,
  7u,
  2u,
  0u,
  3u,
  9u,
  0u,
  5u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  8u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  26u,
  0u,
  25u,
  0u,
  19u,
  19u,
  19u,
  0u,
  29u,
  0u,
  0u,
  12u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  21u,
  0u,
  0u,
  0u,
  0u,
  18u,
  0u,
  13u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  26u,
  0u,
  20u,
  15u,
  19u,
  19u,
  19u,
  10u,
  15u,
  28u,
  0u,
  11u,
  24u,
  23u,
  17u,
  22u,
  12u,
  0u,
  21u,
  27u,
  16u,
  0u,
  0u,
  18u,
  0u,
  13u
}; // weak
_UNKNOWN unk_49153B; // weak
void *__ptr32 off_49153F = (void *__ptr32)0x464E49LL; // weak
_UNKNOWN unk_491543; // weak
_UNKNOWN unk_491547; // weak
_UNKNOWN unk_49154C; // weak
_UNKNOWN unk_49155C; // weak
_UNKNOWN unk_49156C; // weak
_UNKNOWN unk_49157C; // weak
_UNKNOWN unk_49158C; // weak
__int128 xmmword_4915B0 = 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFLL; // weak
__int128 xmmword_4915C0 = 0x7FFEFFFFFFFFFFFFFFFFFFFFFFFFFFFFLL; // weak
_UNKNOWN unk_491654; // weak
_UNKNOWN null_0; // weak
_UNKNOWN zeroes; // weak
_UNKNOWN zeroes_0; // weak
_UNKNOWN blanks_0; // weak
void *__ptr32 off_491E7A = (void *__ptr32)0x42494CLL; // weak
_UNKNOWN expected_note_11399; // weak
__int64 expected_11393 = 282584257676671LL; // weak
int dword_4924B9 = 0; // weak
__int64 expected2_11392 = 216455366371460479LL; // weak
int dummy_bucket_11494 = 0; // weak
char primes_10644[2] = "\a"; // weak
unsigned __int8 byte_493145[13] = { 111u, 110u, 0u, 84u, 117u, 101u, 0u, 87u, 101u, 100u, 0u, 84u, 104u }; // weak
_UNKNOWN unk_493152; // weak
unsigned __int8 byte_493255[1707] =
{
  0u,
  2u,
  0u,
  37u,
  97u,
  32u,
  37u,
  98u,
  32u,
  37u,
  101u,
  32u,
  37u,
  72u,
  58u,
  37u,
  77u,
  58u,
  37u,
  83u,
  32u,
  37u,
  90u,
  32u,
  37u,
  89u,
  0u,
  83u,
  0u,
  0u,
  0u,
  117u,
  0u,
  0u,
  0u,
  110u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  77u,
  0u,
  0u,
  0u,
  111u,
  0u,
  0u,
  0u,
  110u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  84u,
  0u,
  0u,
  0u,
  117u,
  0u,
  0u,
  0u,
  101u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  87u,
  0u,
  0u,
  0u,
  101u,
  0u,
  0u,
  0u,
  100u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  84u,
  0u,
  0u,
  0u,
  104u,
  0u,
  0u,
  0u,
  117u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  70u,
  0u,
  0u,
  0u,
  114u,
  0u,
  0u,
  0u,
  105u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  83u,
  0u,
  0u,
  0u,
  97u,
  0u,
  0u,
  0u,
  116u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  83u,
  0u,
  0u,
  0u,
  117u,
  0u,
  0u,
  0u,
  110u,
  0u,
  0u,
  0u,
  100u,
  0u,
  0u,
  0u,
  97u,
  0u,
  0u,
  0u,
  121u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  77u,
  0u,
  0u,
  0u,
  111u,
  0u,
  0u,
  0u,
  110u,
  0u,
  0u,
  0u,
  100u,
  0u,
  0u,
  0u,
  97u,
  0u,
  0u,
  0u,
  121u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  70u,
  0u,
  0u,
  0u,
  114u,
  0u,
  0u,
  0u,
  105u,
  0u,
  0u,
  0u,
  100u,
  0u,
  0u,
  0u,
  97u,
  0u,
  0u,
  0u,
  121u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  74u,
  0u,
  0u,
  0u,
  97u,
  0u,
  0u,
  0u,
  110u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  70u,
  0u,
  0u,
  0u,
  101u,
  0u,
  0u,
  0u,
  98u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  77u,
  0u,
  0u,
  0u,
  97u,
  0u,
  0u,
  0u,
  114u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  65u,
  0u,
  0u,
  0u,
  112u,
  0u,
  0u,
  0u,
  114u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  77u,
  0u,
  0u,
  0u,
  97u,
  0u,
  0u,
  0u,
  121u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  74u,
  0u,
  0u,
  0u,
  117u,
  0u,
  0u,
  0u,
  110u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  74u,
  0u,
  0u,
  0u,
  117u,
  0u,
  0u,
  0u,
  108u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  65u,
  0u,
  0u,
  0u,
  117u,
  0u,
  0u,
  0u,
  103u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  83u,
  0u,
  0u,
  0u,
  101u,
  0u,
  0u,
  0u,
  112u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  79u,
  0u,
  0u,
  0u,
  99u,
  0u,
  0u,
  0u,
  116u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  78u,
  0u,
  0u,
  0u,
  111u,
  0u,
  0u,
  0u,
  118u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  68u,
  0u,
  0u,
  0u,
  101u,
  0u,
  0u,
  0u,
  99u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  77u,
  0u,
  0u,
  0u,
  97u,
  0u,
  0u,
  0u,
  114u,
  0u,
  0u,
  0u,
  99u,
  0u,
  0u,
  0u,
  104u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  65u,
  0u,
  0u,
  0u,
  112u,
  0u,
  0u,
  0u,
  114u,
  0u,
  0u,
  0u,
  105u,
  0u,
  0u,
  0u,
  108u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  74u,
  0u,
  0u,
  0u,
  117u,
  0u,
  0u,
  0u,
  110u,
  0u,
  0u,
  0u,
  101u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  74u,
  0u,
  0u,
  0u,
  117u,
  0u,
  0u,
  0u,
  108u,
  0u,
  0u,
  0u,
  121u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  65u,
  0u,
  0u,
  0u,
  117u,
  0u,
  0u,
  0u,
  103u,
  0u,
  0u,
  0u,
  117u,
  0u,
  0u,
  0u,
  115u,
  0u,
  0u,
  0u,
  116u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  65u,
  0u,
  0u,
  0u,
  77u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  80u,
  0u,
  0u,
  0u,
  77u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  84u,
  0u,
  0u,
  0u,
  117u,
  0u,
  0u,
  0u,
  101u,
  0u,
  0u,
  0u,
  115u,
  0u,
  0u,
  0u,
  100u,
  0u,
  0u,
  0u,
  97u,
  0u,
  0u,
  0u,
  121u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  87u,
  0u,
  0u,
  0u,
  101u,
  0u,
  0u,
  0u,
  100u,
  0u,
  0u,
  0u,
  110u,
  0u,
  0u,
  0u,
  101u,
  0u,
  0u,
  0u,
  115u,
  0u,
  0u,
  0u,
  100u,
  0u,
  0u,
  0u,
  97u,
  0u,
  0u,
  0u,
  121u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  84u,
  0u,
  0u,
  0u,
  104u,
  0u,
  0u,
  0u,
  117u,
  0u,
  0u,
  0u,
  114u,
  0u,
  0u,
  0u,
  115u,
  0u,
  0u,
  0u,
  100u,
  0u,
  0u,
  0u,
  97u,
  0u,
  0u,
  0u,
  121u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  83u,
  0u,
  0u,
  0u,
  97u,
  0u,
  0u,
  0u,
  116u,
  0u,
  0u,
  0u,
  117u,
  0u,
  0u,
  0u,
  114u,
  0u,
  0u,
  0u,
  100u,
  0u,
  0u,
  0u,
  97u,
  0u,
  0u,
  0u,
  121u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  74u,
  0u,
  0u,
  0u,
  97u,
  0u,
  0u,
  0u,
  110u,
  0u,
  0u,
  0u,
  117u,
  0u,
  0u,
  0u,
  97u,
  0u,
  0u,
  0u,
  114u,
  0u,
  0u,
  0u,
  121u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  70u,
  0u,
  0u,
  0u,
  101u,
  0u,
  0u,
  0u,
  98u,
  0u,
  0u,
  0u,
  114u,
  0u,
  0u,
  0u,
  117u,
  0u,
  0u,
  0u,
  97u,
  0u,
  0u,
  0u,
  114u,
  0u,
  0u,
  0u,
  121u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  83u,
  0u,
  0u,
  0u,
  101u,
  0u,
  0u,
  0u,
  112u,
  0u,
  0u,
  0u,
  116u,
  0u,
  0u,
  0u,
  101u,
  0u,
  0u,
  0u,
  109u,
  0u,
  0u,
  0u,
  98u,
  0u,
  0u,
  0u,
  101u,
  0u,
  0u,
  0u,
  114u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  79u,
  0u,
  0u,
  0u,
  99u,
  0u,
  0u,
  0u,
  116u,
  0u,
  0u,
  0u,
  111u,
  0u,
  0u,
  0u,
  98u,
  0u,
  0u,
  0u,
  101u,
  0u,
  0u,
  0u,
  114u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  78u,
  0u,
  0u,
  0u,
  111u,
  0u,
  0u,
  0u,
  118u,
  0u,
  0u,
  0u,
  101u,
  0u,
  0u,
  0u,
  109u,
  0u,
  0u,
  0u,
  98u,
  0u,
  0u,
  0u,
  101u,
  0u,
  0u,
  0u,
  114u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  68u,
  0u,
  0u,
  0u,
  101u,
  0u,
  0u,
  0u,
  99u,
  0u,
  0u,
  0u,
  101u,
  0u,
  0u,
  0u,
  109u,
  0u,
  0u,
  0u,
  98u,
  0u,
  0u,
  0u,
  101u,
  0u,
  0u,
  0u,
  114u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  37u,
  0u,
  0u,
  0u,
  97u,
  0u,
  0u,
  0u,
  32u,
  0u,
  0u,
  0u,
  37u,
  0u,
  0u,
  0u,
  98u,
  0u,
  0u,
  0u,
  32u,
  0u,
  0u,
  0u,
  37u,
  0u,
  0u,
  0u,
  101u,
  0u,
  0u,
  0u,
  32u,
  0u,
  0u,
  0u,
  37u,
  0u,
  0u,
  0u,
  72u,
  0u,
  0u,
  0u,
  58u,
  0u,
  0u,
  0u,
  37u,
  0u,
  0u,
  0u,
  77u,
  0u,
  0u,
  0u,
  58u,
  0u,
  0u,
  0u,
  37u,
  0u,
  0u,
  0u,
  83u,
  0u,
  0u,
  0u,
  32u,
  0u,
  0u,
  0u,
  37u,
  0u,
  0u,
  0u,
  89u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  37u,
  0u,
  0u,
  0u,
  109u,
  0u,
  0u,
  0u,
  47u,
  0u,
  0u,
  0u,
  37u,
  0u,
  0u,
  0u,
  100u,
  0u,
  0u,
  0u,
  47u,
  0u,
  0u,
  0u,
  37u,
  0u,
  0u,
  0u,
  121u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  37u,
  0u,
  0u,
  0u,
  72u,
  0u,
  0u,
  0u,
  58u,
  0u,
  0u,
  0u,
  37u,
  0u,
  0u,
  0u,
  77u,
  0u,
  0u,
  0u,
  58u,
  0u,
  0u,
  0u,
  37u,
  0u,
  0u,
  0u,
  83u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  37u,
  0u,
  0u,
  0u,
  73u,
  0u,
  0u,
  0u,
  58u,
  0u,
  0u,
  0u,
  37u,
  0u,
  0u,
  0u,
  77u,
  0u,
  0u,
  0u,
  58u,
  0u,
  0u,
  0u,
  37u,
  0u,
  0u,
  0u,
  83u,
  0u,
  0u,
  0u,
  32u,
  0u,
  0u,
  0u,
  37u,
  0u,
  0u,
  0u,
  112u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  37u,
  0u,
  0u,
  0u,
  97u,
  0u,
  0u,
  0u,
  32u,
  0u,
  0u,
  0u,
  37u,
  0u,
  0u,
  0u,
  98u,
  0u,
  0u,
  0u,
  32u,
  0u,
  0u,
  0u,
  37u,
  0u,
  0u,
  0u,
  101u,
  0u,
  0u,
  0u,
  32u,
  0u,
  0u,
  0u,
  37u,
  0u,
  0u,
  0u,
  72u,
  0u,
  0u,
  0u,
  58u,
  0u,
  0u,
  0u,
  37u,
  0u,
  0u,
  0u,
  77u,
  0u,
  0u,
  0u,
  58u,
  0u,
  0u,
  0u,
  37u,
  0u,
  0u,
  0u,
  83u,
  0u,
  0u,
  0u,
  32u,
  0u,
  0u,
  0u,
  37u,
  0u,
  0u,
  0u,
  90u,
  0u,
  0u,
  0u,
  32u,
  0u,
  0u,
  0u,
  37u,
  0u,
  0u,
  0u,
  89u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  37u,
  112u,
  37u,
  116u,
  37u,
  103u,
  37u,
  116u,
  37u,
  109u,
  37u,
  116u,
  37u,
  102u,
  0u,
  0u,
  37u,
  97u,
  37u,
  78u,
  37u,
  102u,
  37u,
  78u,
  37u,
  100u,
  37u,
  78u,
  37u,
  98u,
  37u,
  78u,
  37u,
  115u,
  32u,
  37u,
  104u,
  32u,
  37u,
  101u,
  32u,
  37u,
  114u,
  37u,
  78u,
  37u,
  67u,
  45u,
  37u,
  122u,
  32u,
  37u,
  84u,
  37u,
  78u,
  37u,
  99u,
  37u,
  78u,
  0u,
  43u,
  37u,
  99u,
  32u,
  37u,
  97u,
  32u,
  37u,
  108u,
  0u,
  73u,
  83u,
  79u,
  47u,
  73u,
  69u,
  67u,
  32u,
  49u,
  52u,
  54u,
  53u,
  50u,
  32u,
  105u,
  49u,
  56u,
  110u,
  32u,
  70u,
  68u,
  67u,
  67u,
  45u,
  115u,
  101u,
  116u,
  0u,
  75u,
  101u,
  108u,
  100u,
  32u,
  83u,
  105u,
  109u,
  111u,
  110u,
  115u,
  101u,
  110u,
  0u,
  107u,
  101u,
  108u,
  100u,
  64u,
  100u,
  107u,
  117u,
  117u,
  103u,
  46u,
  100u,
  107u,
  0u,
  43u,
  52u,
  53u,
  32u,
  51u,
  49u,
  50u,
  50u,
  45u,
  54u,
  53u,
  52u,
  51u,
  0u,
  43u,
  52u,
  53u,
  32u,
  51u,
  51u,
  50u,
  53u,
  45u,
  54u,
  53u,
  52u,
  51u,
  0u,
  73u,
  83u,
  79u,
  0u,
  49u,
  46u,
  48u,
  0u,
  49u,
  57u,
  57u,
  55u,
  45u,
  49u,
  50u,
  45u,
  50u,
  48u,
  0u,
  0u,
  0u,
  0u,
  73u,
  83u,
  79u,
  47u,
  73u,
  69u,
  67u,
  32u,
  74u,
  84u,
  67u,
  49u,
  47u,
  83u,
  67u,
  50u,
  50u,
  47u,
  87u,
  71u,
  50u,
  48u,
  32u,
  45u,
  32u,
  105u,
  110u,
  116u,
  101u,
  114u,
  110u,
  97u,
  116u,
  105u,
  111u,
  110u,
  97u,
  108u,
  105u,
  122u,
  97u,
  116u,
  105u,
  111u,
  110u,
  0u,
  0u,
  0u,
  67u,
  47u,
  111u,
  32u,
  75u,
  101u,
  108u,
  100u,
  32u,
  83u,
  105u,
  109u,
  111u,
  110u,
  115u,
  101u,
  110u,
  44u,
  32u,
  83u,
  107u,
  116u,
  46u,
  32u,
  74u,
  111u,
  114u,
  103u,
  101u,
  110u,
  115u,
  32u,
  65u,
  108u,
  108u,
  101u,
  32u,
  56u,
  44u,
  32u,
  68u,
  75u,
  45u,
  49u,
  54u,
  49u,
  53u,
  32u,
  75u,
  111u,
  98u,
  101u,
  110u,
  104u,
  97u,
  118u,
  110u,
  32u,
  86u,
  0u,
  0u,
  0u,
  0u,
  0u,
  105u,
  49u,
  56u,
  110u,
  58u,
  49u,
  57u,
  57u,
  57u,
  0u,
  105u,
  49u,
  56u,
  110u,
  58u,
  49u,
  57u,
  57u,
  57u,
  0u,
  105u,
  49u,
  56u,
  110u,
  58u,
  49u,
  57u,
  57u,
  57u,
  0u,
  105u,
  49u,
  56u,
  110u,
  58u,
  49u,
  57u,
  57u,
  57u,
  0u,
  105u,
  49u,
  56u,
  110u,
  58u,
  49u,
  57u,
  57u,
  57u,
  0u,
  105u,
  49u,
  56u,
  110u,
  58u,
  49u,
  57u,
  57u,
  57u,
  0u,
  0u,
  105u,
  49u,
  56u,
  110u,
  58u,
  49u,
  57u,
  57u,
  57u,
  0u,
  105u,
  49u,
  56u,
  110u,
  58u,
  49u,
  57u,
  57u,
  57u,
  0u,
  105u,
  49u,
  56u,
  110u,
  58u,
  49u,
  57u,
  57u,
  57u,
  0u,
  105u,
  49u,
  56u,
  110u,
  58u,
  49u,
  57u,
  57u,
  57u,
  0u,
  105u,
  49u,
  56u,
  110u,
  58u,
  49u,
  57u,
  57u,
  57u,
  0u,
  105u,
  49u,
  56u,
  110u,
  58u,
  49u,
  57u,
  57u,
  57u,
  0u,
  105u,
  49u,
  56u,
  110u,
  58u,
  49u,
  57u,
  57u,
  57u,
  0u,
  105u,
  49u,
  56u,
  110u,
  58u,
  49u,
  57u,
  57u,
  57u,
  0u,
  105u,
  49u,
  56u,
  110u,
  58u,
  49u,
  57u,
  57u,
  57u,
  0u,
  105u,
  49u,
  56u,
  110u,
  58u,
  49u,
  57u,
  57u,
  57u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u
}; // weak
_UNKNOWN unk_493E38; // weak
_UNKNOWN unk_493F58; // weak
unsigned __int64 _tens[1728] =
{
  0uLL,
  10uLL,
  0uLL,
  100uLL,
  0uLL,
  10000uLL,
  0uLL,
  100000000uLL,
  0uLL,
  10000000000000000uLL,
  0uLL,
  9632337040368467968uLL,
  5421010862427uLL,
  0uLL,
  0uLL,
  7942358959831785217uLL,
  16807427164405733357uLL,
  1593091uLL,
  0uLL,
  0uLL,
  0uLL,
  279109966635548161uLL,
  2554917779393558781uLL,
  14124656261812188652uLL,
  11976055582626787546uLL,
  2537941837315uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  13750482914757213185uLL,
  1302999927698857842uLL,
  14936872543252795590uLL,
  2788415840139466767uLL,
  2095640732773017264uLL,
  7205570348933370714uLL,
  7348167152523113408uLL,
  9285516396840364274uLL,
  6907659600622710236uLL,
  349175uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  8643096425819600897uLL,
  6743743997439985372uLL,
  14059704609098336919uLL,
  10729359125898331411uLL,
  4933048501514368705uLL,
  12258131603170554683uLL,
  2172371001088594721uLL,
  13569903330219142946uLL,
  13809142207969578845uLL,
  16716360519037769646uLL,
  9631256923806107285uLL,
  12866941232305103710uLL,
  1397931361048440292uLL,
  7619627737732970332uLL,
  12725409486282665900uLL,
  11703051443360963910uLL,
  9947078370803086083uLL,
  13966287901448440471uLL,
  121923442132uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  17679772531488845825uLL,
  2216509366347768155uLL,
  1568689219195129479uLL,
  5511594616325588277uLL,
  1067709417009240089uLL,
  9070650952098657518uLL,
  11515285870634858015uLL,
  2539561553659505564uLL,
  17604889300961091799uLL,
  14511540856854204724uLL,
  12099083339557485471uLL,
  7115240299237943815uLL,
  313979240050606788uLL,
  10004784664717172195uLL,
  15570268847930131473uLL,
  10359715202835930803uLL,
  17685054012115162812uLL,
  13183273382855797757uLL,
  7743260039872919062uLL,
  9284593436392572926uLL,
  11105921222066415013uLL,
  18198799323400703846uLL,
  16314988383739458320uLL,
  4387527177871570570uLL,
  8476708682254672590uLL,
  4925096874831034057uLL,
  14075687868072027455uLL,
  112866656203221926uLL,
  9852830467773230418uLL,
  25755239915196746uLL,
  2201493076310172510uLL,
  8342165458688466438uLL,
  13954006576066379050uLL,
  15193819059903295636uLL,
  12565616718911389531uLL,
  3815854855847885129uLL,
  15696762163583540628uLL,
  805uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  16359721904723189761uLL,
  5323973632697650495uLL,
  17187956456762001185uLL,
  3930387638628283780uLL,
  3374723710406992273uLL,
  16884225088663222131uLL,
  10967440051041439154uLL,
  9686916182456720060uLL,
  10554548046311730194uLL,
  7390739362393647554uLL,
  6316162333127736719uLL,
  18122464886584070891uLL,
  4044404959645932768uLL,
  3801320885861987401uLL,
  12080950653257274590uLL,
  16414324262488991299uLL,
  16395687498836410113uLL,
  12173633940896186260uLL,
  10843185433142632150uLL,
  11048169832730399808uLL,
  12674828934734683716uLL,
  17370808310130582550uLL,
  10500926985433408692uLL,
  10252725158410704555uLL,
  14170108270502067523uLL,
  3698946465517688080uLL,
  989984870770509463uLL,
  10965601426733943069uLL,
  11389898658438335655uLL,
  6901098232861256586uLL,
  1921335291173932590uLL,
  7662788640922083388uLL,
  9775023833308395430uLL,
  4640401278902814207uLL,
  14532050972198413359uLL,
  8378549018693130223uLL,
  11672322628395371653uLL,
  8930704142764178555uLL,
  6275193859483102017uLL,
  15782593304269205087uLL,
  8673060659034172558uLL,
  8018354414354334043uLL,
  1824896661540749038uLL,
  11345563346725559868uLL,
  14959216444480821949uLL,
  970189517688324683uLL,
  3338835207603007873uLL,
  17684964260791738489uLL,
  1436466329061721851uLL,
  4554134986752476101uLL,
  6398757850768963907uLL,
  4709779218751158342uLL,
  10033277748582410264uLL,
  17932125878679265063uLL,
  10004750887749091440uLL,
  256584531835386932uLL,
  14396282740722731628uLL,
  3086085133731396950uLL,
  17831272085689600064uLL,
  10573926491412564693uLL,
  14888061047859191737uLL,
  4570995450261499817uLL,
  10410165022312935266uLL,
  5691078631447480790uLL,
  8632710455805418155uLL,
  790672778942823293uLL,
  16505464105756800547uLL,
  2092171438149740401uLL,
  17505030673829275878uLL,
  1291290830058928444uLL,
  14856191690683232796uLL,
  8916773426496500052uLL,
  10152003807578858265uLL,
  13104441193763861714uLL,
  649395uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  15308384451594534913uLL,
  17913664074042735335uLL,
  6115977719198531863uLL,
  5794980608663993169uLL,
  16544350702855106930uLL,
  9253787637781258566uLL,
  4977988951675168190uLL,
  9087837664087448770uLL,
  2098480401110016986uLL,
  15474332540882100712uLL,
  14042133997396540944uLL,
  1090855284423485362uLL,
  12639956485351058381uLL,
  1454115676006639319uLL,
  3180465001342538023uLL,
  14649076551958697729uLL,
  9801292446545910916uLL,
  13552201410826594004uLL,
  6101141927469189381uLL,
  1881431857880609316uLL,
  4907847477899433595uLL,
  8714572486973123228uLL,
  3514969632331374520uLL,
  11667642286891470094uLL,
  2391499697425323350uLL,
  17486585679659076043uLL,
  18267223761882105642uLL,
  2886610765822313148uLL,
  9302834862968900288uLL,
  15246507846733637044uLL,
  15924227519624562840uLL,
  9743741243284697760uLL,
  3159780987244964246uLL,
  7304816812369628428uLL,
  17584602612559717809uLL,
  4146812420657846766uLL,
  14525415362681041515uLL,
  8477630142371600195uLL,
  4380695748062263745uLL,
  12119915994367943173uLL,
  16970630866565485122uLL,
  4332724980155264503uLL,
  8079943140620527639uLL,
  1687908087554405626uLL,
  17051081099834002166uLL,
  12638146269730763230uLL,
  11883749876933445771uLL,
  4662462156371383785uLL,
  4796962238316531176uLL,
  3325504751659868927uLL,
  6469595803187862550uLL,
  5852556621152583005uLL,
  9229334792448387881uLL,
  17979733373938620709uLL,
  13951623534175792756uLL,
  17075879371091039277uLL,
  14212246479457938037uLL,
  4008999959804158260uLL,
  2414266395366403722uLL,
  3252733766253918247uLL,
  6382678985007829216uLL,
  2245927470982310841uLL,
  13790724502051307301uLL,
  13116936866733148041uLL,
  9718402891306794538uLL,
  13516274400356104875uLL,
  17859223875778049403uLL,
  4396895129099725471uLL,
  3563053650368467915uLL,
  12176845952536972668uLL,
  3492050964335269015uLL,
  2740656767075170753uLL,
  4409704077614761919uLL,
  10237775279597492710uLL,
  3314206875098230827uLL,
  16437361028114095448uLL,
  12361736225407656572uLL,
  16792510651790145480uLL,
  11449053143229929935uLL,
  18336641737580333136uLL,
  6558939822118891088uLL,
  4606255756908155300uLL,
  2360792578991605004uLL,
  160428430149144538uLL,
  11644861220729221511uLL,
  10785178451159739786uLL,
  14923560618031934681uLL,
  1902620814992781610uLL,
  14064076995338910412uLL,
  11547019064112212657uLL,
  16847481479966225734uLL,
  8331994491163145469uLL,
  11739712981738851885uLL,
  8008309968651120619uLL,
  10266969595459035264uLL,
  15175153381217702033uLL,
  12208659352573720245uLL,
  7714061140750342961uLL,
  2892831567213510541uLL,
  15453714249045017319uLL,
  71020323573871677uLL,
  15431137995750602633uLL,
  5659146884637671933uLL,
  5998809010488554503uLL,
  16552192379299157850uLL,
  1192197967194298797uLL,
  16157555793424861524uLL,
  10929371590994640255uLL,
  3194469143425738352uLL,
  6651586784672005225uLL,
  11062427140788057791uLL,
  6834443579468668318uLL,
  16421563197797455922uLL,
  6251046422506172884uLL,
  13952303462156793860uLL,
  16632486601871393224uLL,
  11313454360291325172uLL,
  5587835232504462834uLL,
  3105197524618514637uLL,
  18268568531031972989uLL,
  2397205535804309313uLL,
  59413027864729597uLL,
  11869878125348715710uLL,
  12592801707270523266uLL,
  8070632061321113656uLL,
  18403647807860650811uLL,
  267109013517069093uLL,
  6537214311028855260uLL,
  5220826919973709902uLL,
  3448740582779163661uLL,
  16822239213112884941uLL,
  5975299384311048185uLL,
  10294433804430712138uLL,
  4739856055412448774uLL,
  12057273038326387897uLL,
  13119002941950056609uLL,
  3354445304051737058uLL,
  13592813067499314594uLL,
  3890182464434078629uLL,
  17820384357466425060uLL,
  9785228118969879380uLL,
  1778431746734556271uLL,
  10075313876350055029uLL,
  13994048489400919028uLL,
  17948287074199726448uLL,
  2815088342305858722uLL,
  2676626035777198370uLL,
  1174257960026283968uLL,
  421714788677uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  11471884475673051137uLL,
  8902860357476377573uLL,
  13350296775839230505uLL,
  10609191786344608888uLL,
  7261211985859587338uLL,
  11439672689354862964uLL,
  16789708072300570627uLL,
  4607056528866348430uLL,
  3202978990421512997uLL,
  2024899620433984146uLL,
  17666950207239811774uLL,
  4233228489390288200uLL,
  9137580478688460738uLL,
  4060411066587388546uLL,
  11119949806060600124uLL,
  867715462473090103uLL,
  14382394941384869610uLL,
  4856042377419278489uLL,
  8265605599571137921uLL,
  538981667666252469uLL,
  4270263388700786523uLL,
  3281140600308898503uLL,
  4121392524544394174uLL,
  2077884106245940229uLL,
  9773041957329767574uLL,
  7550623316597646685uLL,
  8611033926449791714uLL,
  18137922955420802793uLL,
  2796546741236224013uLL,
  15477096484628446761uLL,
  9517540128113714010uLL,
  9471917970500821378uLL,
  15938570248662483124uLL,
  5228016831978462619uLL,
  15720991252586974501uLL,
  7662829825220776698uLL,
  17328310068068434348uLL,
  3371736428170309730uLL,
  3803724952191098855uLL,
  13115926536504376719uLL,
  16752571196153442257uLL,
  16540185467776259880uLL,
  3432518182450051120uLL,
  5880364967211798870uLL,
  12355748840305392783uLL,
  14196090758536469575uLL,
  7370123524686686319uLL,
  6819740424617592686uLL,
  13037938013537368753uLL,
  15029273671291927100uLL,
  3671312928327205696uLL,
  7473228676544792780uLL,
  17234079691312938123uLL,
  14164740848093544419uLL,
  13169904779481875902uLL,
  7179036968465894054uLL,
  8244653688947194445uLL,
  17179797746073799490uLL,
  5591970751047577674uLL,
  17530550506268329742uLL,
  5965746721852312330uLL,
  1604149463243472865uLL,
  7734199791463116918uLL,
  11305790396015856714uLL,
  4441196105025505137uLL,
  13046431581185664762uLL,
  124776524294606713uLL,
  1134521334706523966uLL,
  11671728093344476434uLL,
  14103440020972933148uLL,
  3966727403013869059uLL,
  9828094508409132821uLL,
  4355682486381147287uLL,
  10261407143988481234uLL,
  3800455155249557199uLL,
  12700901937937547500uLL,
  18184475466894579360uLL,
  13267691151779895412uLL,
  4714157123477697445uLL,
  10770360171308585263uLL,
  9083344917597998040uLL,
  12078649873810212155uLL,
  18218989082046199377uLL,
  4454285072780637351uLL,
  5287307245618354742uLL,
  16042289702059031730uLL,
  4131926574212754010uLL,
  217692071448455473uLL,
  3624845916216282093uLL,
  2901203491797614218uLL,
  6679177724033967080uLL,
  44561358851332790uLL,
  9094639944041587162uLL,
  13690915012276084311uLL,
  1408896670826320686uLL,
  5359130319612337580uLL,
  6148412925099835601uLL,
  5211368532286409612uLL,
  11386360825549027374uLL,
  16895182466965795071uLL,
  3392940493846427241uLL,
  438089879085393580uLL,
  4783928372776399972uLL,
  6278117363595909959uLL,
  12569481049412674733uLL,
  15648622492570893902uLL,
  1966316336235305115uLL,
  1603775390515993547uLL,
  13576113010204316709uLL,
  10821754650102840474uLL,
  18198222517222903152uLL,
  6966163076615302988uLL,
  1373932372410129684uLL,
  3285839581819684990uLL,
  30177575069719475uLL,
  16447047871247307061uLL,
  11618654126674833808uLL,
  990072222556306872uLL,
  1260682336135768017uLL,
  13862055046689532489uLL,
  15668483092844698432uLL,
  1879572630092764264uLL,
  13912027797058626108uLL,
  6231679788219816920uLL,
  13857858054844167403uLL,
  18101470072534728857uLL,
  4144579812461609229uLL,
  7048589655616599284uLL,
  9946956499532694630uLL,
  9771303850109874038uLL,
  6477823708780339765uLL,
  17526247621747041971uLL,
  13525995675852669549uLL,
  3928768291901239810uLL,
  8094153383078124544uLL,
  11214278667728965552uLL,
  11251547162596832610uLL,
  5964946855123292381uLL,
  3622548288590237903uLL,
  13469765967150053587uLL,
  17798986288523466082uLL,
  14684592818807932259uLL,
  16724077276802963921uLL,
  7119877993753121290uLL,
  1864571304902781632uLL,
  12871984921385213812uLL,
  9065447042604670298uLL,
  3987130777300360550uLL,
  6890545752116901685uLL,
  17275341711601865750uLL,
  6296474927799264658uLL,
  1257436973037243463uLL,
  13854281781965301421uLL,
  1657132483318662716uLL,
  17309399540017292849uLL,
  12808111630089217242uLL,
  1098489625264462071uLL,
  14010458905686364135uLL,
  16134414519481621220uLL,
  14288255900328821475uLL,
  3469093466388187882uLL,
  15982710881468295872uLL,
  4056765540058056052uLL,
  15945176389096104089uLL,
  8625339365793505375uLL,
  12316179968863788913uLL,
  15334123773538054321uLL,
  9536238824220581765uLL,
  16080825720106203271uLL,
  6235695225418121745uLL,
  12035192956458019349uLL,
  3235835166714703698uLL,
  5348960676912581218uLL,
  15315062772709464647uLL,
  17335089708021308662uLL,
  16855855317958414409uLL,
  2369751139431140406uLL,
  3693542588628609043uLL,
  7350405893393987577uLL,
  17402072586341663801uLL,
  7007897690013647122uLL,
  15671767872059304758uLL,
  9259490518292347915uLL,
  14836045474406130394uLL,
  4654005815464502513uLL,
  6487825998330548401uLL,
  7013356660323385022uLL,
  7136200343936679946uLL,
  15341236858676437716uLL,
  3657357368867197449uLL,
  12621075530054608378uLL,
  5603868621997066972uLL,
  7683447656788439942uLL,
  450883379216880060uLL,
  14291494350184945047uLL,
  5466258454997635048uLL,
  14206933098432772126uLL,
  4775870327277641692uLL,
  1864430798867181939uLL,
  13748978265070608793uLL,
  12250822864261576589uLL,
  12561896977498605296uLL,
  16060949594257359328uLL,
  17775189113543311529uLL,
  11835965177892927035uLL,
  4218664174878121437uLL,
  3499000902478111683uLL,
  15169853304359126294uLL,
  7076121963053575143uLL,
  832652347668916805uLL,
  1292148207755194737uLL,
  7556838978364207852uLL,
  5904021986723518500uLL,
  4610244652288570024uLL,
  4526508363195533871uLL,
  746120481022614726uLL,
  737965197247830486uLL,
  4006266184415762653uLL,
  9272188239892688050uLL,
  15346235246415709678uLL,
  11850675997347533184uLL,
  11181059668610842701uLL,
  6687857983250662774uLL,
  2908718488661492818uLL,
  4828337780126983225uLL,
  18071738646453002184uLL,
  12790187227727197880uLL,
  17602483480871623153uLL,
  12523532189621855977uLL,
  10598805712727696716uLL,
  2179787555896149376uLL,
  2242193929457337594uLL,
  14908923241136742532uLL,
  8369182018012550027uLL,
  13385381554043022324uLL,
  3332327430110633913uLL,
  16138090784046208492uLL,
  16172324607469047339uLL,
  8279089815915615244uLL,
  12872906602736235247uLL,
  10894545290539475621uLL,
  15428756545851905023uLL,
  4155747980686992922uLL,
  4074479178894544043uLL,
  66083965608603584uLL,
  13873786284662268377uLL,
  8861183628277687555uLL,
  12119497911296021430uLL,
  2154012318305274287uLL,
  15490706314503067312uLL,
  13643145488710608367uLL,
  672340241093017103uLL,
  6039493278284091973uLL,
  9679797700977436461uLL,
  18070795828318171174uLL,
  2188146431134935377uLL,
  5247392385741514952uLL,
  1852539214842869734uLL,
  12235621681634112739uLL,
  8812930319623534062uLL,
  5585597406294108629uLL,
  11312989214475901864uLL,
  1547377291787797995uLL,
  8641748937186208205uLL,
  12518148659168623694uLL,
  6611379197521520985uLL,
  18096591571068008576uLL,
  15087021227100112139uLL,
  13058454842015958418uLL,
  1473584652966833794uLL,
  4387660670140018168uLL,
  8452836916843525402uLL,
  14376083294443363955uLL,
  13998026203969090659uLL,
  611968444648172645uLL,
  990232438801273845uLL,
  18001186324715561929uLL,
  13470591857250177501uLL,
  14881554140239420091uLL,
  16696367836720124495uLL,
  6328076032778459673uLL,
  17027497695968504616uLL,
  10192245646262428833uLL,
  8282482589527318647uLL,
  4319014353374321425uLL,
  14134087271041670980uLL,
  5060230880114618599uLL,
  13179509240430058600uLL,
  3903514232614801894uLL,
  17774749744702165255uLL,
  15448635507030969726uLL,
  15983775238358480209uLL,
  14542832143965487887uLL,
  9385618098039514666uLL,
  14431419612662304843uLL,
  730863073501675978uLL,
  16750118380379734815uLL,
  9640uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  0uLL,
  4734805469491560449uLL,
  10121257849976593262uLL,
  15515629337278225642uLL,
  2212915151774210058uLL,
  6663637332045858029uLL,
  17106819522173841436uLL,
  3033795390447658772uLL,
  7718383707400077069uLL,
  12070305067207246826uLL,
  15269198220603765480uLL,
  12022708185728420608uLL,
  77444305565097111uLL,
  8296127084146860649uLL,
  14577212820789302003uLL,
  13899605314113795749uLL,
  8897556787106485718uLL,
  7107770150399380644uLL,
  1369953078461852783uLL,
  6979674467786437514uLL,
  2729737685714719189uLL,
  9190845266052516846uLL,
  6386092840706145984uLL,
  16884110044525508193uLL,
  497786295510831247uLL,
  15336071592842749761uLL,
  17156058692796322532uLL,
  16661818661295323366uLL,
  12481489461498853344uLL,
  18251396167712326597uLL,
  15236682849758868873uLL,
  16333707862015760982uLL,
  17136221655482026951uLL,
  17258581931538932704uLL,
  3160048940096833902uLL,
  121625224721269761uLL,
  3015482372342246716uLL,
  8342191648913931706uLL,
  2246028606627019557uLL,
  7104930024182662526uLL,
  11730316574742269048uLL,
  17174226397389258387uLL,
  3293804579498370401uLL,
  12229660688171001513uLL,
  17808938300559919671uLL,
  6264083323008108029uLL,
  4820815117438024262uLL,
  1979000428121124723uLL,
  5000774170954614568uLL,
  13400083969695276429uLL,
  7428139934551454625uLL,
  18219586041198889900uLL,
  8109609685913604125uLL,
  10689190222021330491uLL,
  3943907756943551137uLL,
  15603232223630142478uLL,
  10606089764396743274uLL,
  9383719762736370775uLL,
  13694736319478899974uLL,
  429624420090361397uLL,
  227546753412414805uLL,
  10958941985171486308uLL,
  9317445823423829521uLL,
  11863145362419627165uLL,
  124380730737735756uLL,
  12552037702125281698uLL,
  9506975322446266162uLL,
  6361070452196727670uLL,
  5864118314335574899uLL,
  18198500491023879415uLL,
  693710845576296048uLL,
  8428067657989979622uLL,
  9190375061780140607uLL,
  10233837080291626964uLL,
  4057199436792326716uLL,
  13045485967964913036uLL,
  11817552225424326361uLL,
  5663867194179809591uLL,
  15664113128692531456uLL,
  6644074694371287637uLL,
  16610458961791675163uLL,
  13432715223539641941uLL,
  6940147613714364150uLL,
  18261330529675285112uLL,
  2770687570340300641uLL,
  166471986444296544uLL,
  12221445684842817040uLL,
  3714622590696147444uLL,
  13395141296670025798uLL,
  18078325802076901297uLL,
  9544778141000382241uLL,
  8850914703500200093uLL,
  3810737736735386096uLL,
  2117555260343410051uLL,
  7753203251593962517uLL,
  15352731779707439967uLL,
  9760728061453422725uLL,
  2483876614472218676uLL,
  10699122055411684078uLL,
  5879369345516927746uLL,
  9820609875533667240uLL,
  1291610685003704965uLL,
  6744219916322133607uLL,
  6377819355385901546uLL,
  9082047296049079505uLL,
  262618211405078579uLL,
  13492211879229157542uLL,
  4724420303847709296uLL,
  9288067968855177716uLL,
  18081871568052183444uLL,
  15255571885403220809uLL,
  2246442144788530940uLL,
  5989308098935123279uLL,
  12615376019575866866uLL,
  4096604902035173619uLL,
  1905680188673640379uLL,
  8808037380749664979uLL,
  8867179827953113686uLL,
  7941208416960536773uLL,
  18347042130696346271uLL,
  15584880924717276034uLL,
  13897724177272848634uLL,
  12551787830541190531uLL,
  2110016464489331948uLL,
  14992959231120953655uLL,
  5155915500390579529uLL,
  12442146891740213991uLL,
  2160740412631082538uLL,
  9730887319064298835uLL,
  1978135137454895105uLL,
  15897433142756147197uLL,
  13898937827296434258uLL,
  5590837795874025034uLL,
  9484905015510360453uLL,
  17275755682218086779uLL,
  10314851585219303017uLL,
  5146514476452997833uLL,
  2685838092360807032uLL,
  15747968310853364118uLL,
  7575162550584052276uLL,
  1821625350956509481uLL,
  10447650892868985115uLL,
  15463586423088736703uLL,
  8070960717235237951uLL,
  13868706090985122474uLL,
  13236089072964070824uLL,
  5790854297122038982uLL,
  2061890046203343898uLL,
  5137585270307907960uLL,
  15715866395455301341uLL,
  11014733278402684640uLL,
  4568822892720381524uLL,
  12213368994331367452uLL,
  5943072258025584213uLL,
  7505656341731662881uLL,
  14753420679915426390uLL,
  9664331041129200534uLL,
  17199517800612930949uLL,
  5794715994807321562uLL,
  8979439602782410600uLL,
  4013690875255814327uLL,
  4788592446297410452uLL,
  7881249861415092932uLL,
  977213487573654953uLL,
  923062152329155855uLL,
  4256185035634640191uLL,
  13906774969675892998uLL,
  14161724765760561488uLL,
  6255788174608088660uLL,
  10210013452150317293uLL,
  8367282897729021557uLL,
  10862241542321977678uLL,
  11187115365641634717uLL,
  3891102563569129293uLL,
  7629137599207408133uLL,
  7206037909846636727uLL,
  2254919723564098762uLL,
  345833071429309102uLL,
  6402540102058174110uLL,
  9993931782660189727uLL,
  17117048624709230955uLL,
  15351552506541377956uLL,
  7713128122863319014uLL,
  13063338318504485937uLL,
  8043383629459294916uLL,
  4270244130714287096uLL,
  4616501241752789289uLL,
  12917970067360550833uLL,
  15216767300886581640uLL,
  4002001954492136096uLL,
  5582674356224425892uLL,
  15691189327006698731uLL,
  496217562383964892uLL,
  12932605376116838262uLL,
  10129998758561910460uLL,
  13865559614370304939uLL,
  9217339887777235754uLL,
  7243018590514884616uLL,
  18294862474403337033uLL,
  16142146085195415143uLL,
  14886871845072019831uLL,
  2300006803713887302uLL,
  18387940067694584475uLL,
  3556096087578066588uLL,
  6264767967456942360uLL,
  15681931933092219954uLL,
  4390515012152303249uLL,
  3076968672531178662uLL,
  685494910557321329uLL,
  1554506352208529567uLL,
  1048563793801477249uLL,
  7544257401359168115uLL,
  4899780768732861239uLL,
  6228153394030153705uLL,
  3875228905107521478uLL,
  12213353771590417241uLL,
  3665307925385752280uLL,
  10879570772616087791uLL,
  16415046184014461354uLL,
  14801994811320008192uLL,
  11119987069880539776uLL,
  17228333530235298435uLL,
  3719945549511708577uLL,
  14039959997874172910uLL,
  14719985354109373991uLL,
  15442706550340326076uLL,
  13047800856127100021uLL,
  2288611147839956377uLL,
  9448949895124092391uLL,
  13804128556948045390uLL,
  8247673722161199901uLL,
  148315241783422880uLL,
  15789799508766571876uLL,
  12877528415822026998uLL,
  10366825621887250416uLL,
  11898814583440249363uLL,
  16071290835298069823uLL,
  8389982701544306242uLL,
  5531549643251140676uLL,
  13247162871222536649uLL,
  7934349776229807266uLL,
  4538358977143258963uLL,
  3866163666857351430uLL,
  8435037624664422256uLL,
  3945944434010580332uLL,
  10612995937096529291uLL,
  10841492461118130552uLL,
  13689459140963273483uLL,
  12189878734466096599uLL,
  14694040652629156278uLL,
  4909641398634409324uLL,
  5780023090082049999uLL,
  14771108088292417007uLL,
  8441958620808173734uLL,
  5802132159669142617uLL,
  3837336995815619849uLL,
  13094846272644807387uLL,
  14842572029935447119uLL,
  10928844086004218498uLL,
  8622139958963810291uLL,
  4422969696044156012uLL,
  18185137623170258852uLL,
  17863661099822387132uLL,
  8953841731266092224uLL,
  36243936373993352uLL,
  16633041120702408291uLL,
  7739468521893678775uLL,
  5400063286861787915uLL,
  5911383954510574696uLL,
  13549567227410895618uLL,
  4462297794485792433uLL,
  4488813832859891898uLL,
  9149453056204172263uLL,
  16072057649937339852uLL,
  14906252576287692882uLL,
  8271452853949304499uLL,
  12682978554623931762uLL,
  14161437512065128627uLL,
  13784333364958352242uLL,
  17498790818744364869uLL,
  4386398306651350959uLL,
  17752071168966977669uLL,
  11751121423168546560uLL,
  8513311550241749682uLL,
  5506446386574490598uLL,
  16816145206245824821uLL,
  15370636948415514970uLL,
  12935074577649872510uLL,
  1795701080378382525uLL,
  16421062591580980484uLL,
  5877668516262607274uLL,
  14470586578551447980uLL,
  615937378094845009uLL,
  12778027080395170404uLL,
  3791679676342426565uLL,
  4743847784124955223uLL,
  3939428438826997938uLL,
  12226466631961438040uLL,
  380016710757123738uLL,
  14087416469497764374uLL,
  8138182875361518595uLL,
  5750736256044723814uLL,
  1619983966589145066uLL,
  18357635038569013170uLL,
  14814083067111296201uLL,
  715413425090626948uLL,
  9135518289989772581uLL,
  13925186074541670108uLL,
  3364764793476385191uLL,
  1508568848530349820uLL,
  14805458262187994201uLL,
  2581819420077395771uLL,
  6278762597119133640uLL,
  3556184041718296984uLL,
  5439958548908742630uLL,
  7479012800218807592uLL,
  7955047275508466584uLL,
  4458066949235466665uLL,
  14405619857460450990uLL,
  8679876237645706046uLL,
  7090760345643478520uLL,
  10420916073231012493uLL,
  13969307499797965498uLL,
  15606609066046934242uLL,
  13475028426200374633uLL,
  14582819938952771207uLL,
  17922194891837345081uLL,
  4125754028215992048uLL,
  8237728046923545536uLL,
  15834689908400742596uLL,
  9482414039290099121uLL,
  16180514410995101061uLL,
  6361338485692057877uLL,
  4650210388499741911uLL,
  3177294050395039042uLL,
  12878722309003899601uLL,
  14776805802460653631uLL,
  12417795414619379443uLL,
  8638306631721133406uLL,
  13374993531057029467uLL,
  16794297820608458695uLL,
  13065224726059011467uLL,
  18161090566516283883uLL,
  10000991812735694046uLL,
  15726288451780480573uLL,
  14325417656278098057uLL,
  18276442862297480992uLL,
  15021258950012786934uLL,
  2673275801057568021uLL,
  10980729785569853527uLL,
  714465189390498639uLL,
  7710723724879456621uLL,
  5953251749140717989uLL,
  118077562892454633uLL,
  6530344183011542391uLL,
  4783103019933741530uLL,
  8503129753748748176uLL,
  1373327054916871614uLL,
  6669491806629209052uLL,
  4619390691939421970uLL,
  5179515648996959200uLL,
  17155187161697855366uLL,
  766338409476030181uLL,
  6174714569872033076uLL,
  17368333665660907914uLL,
  16120237955114327542uLL,
  10439866645798423118uLL,
  6237193887174943905uLL,
  7900288714350616477uLL,
  5028236635819917577uLL,
  14941654990907225065uLL,
  1275793776340190361uLL,
  13597436476261611948uLL,
  318366277531347168uLL,
  3197935369052220685uLL,
  12180226880536647184uLL,
  2504132107801706035uLL,
  2093311415691930214uLL,
  6922968032991936927uLL,
  11927163809467665465uLL,
  6498538161365680020uLL,
  5317923361881221976uLL,
  1984350716132981565uLL,
  17114404654485726811uLL,
  2972873668403553411uLL,
  6222876120405539532uLL,
  13784618221787804389uLL,
  11899182145211787639uLL,
  4978466172617045902uLL,
  5472336470505433178uLL,
  7507908464930718658uLL,
  4578519326550553428uLL,
  17096232158379453321uLL,
  10976393345146391307uLL,
  13157233092310693755uLL,
  5837651449315757829uLL,
  3522472294424637525uLL,
  13371242401898742198uLL,
  18396572553515496657uLL,
  1479883141297090646uLL,
  12234424566944963686uLL,
  5420445628202743048uLL,
  10731003223710911985uLL,
  10358986641882413654uLL,
  14138233474367093252uLL,
  10161105303174940855uLL,
  5221210355222047774uLL,
  13316923634258916882uLL,
  12994861201109634664uLL,
  449688148965171360uLL,
  17412473396382420084uLL,
  10163377233794373973uLL,
  8790836677585569327uLL,
  14338671742972842895uLL,
  9635950892958167495uLL,
  10265929424288084660uLL,
  6215699239099148302uLL,
  6957179226869499802uLL,
  8451901963419586670uLL,
  12670061005932332406uLL,
  16726097683059026649uLL,
  16063955088469276942uLL,
  13102397751801344190uLL,
  11417447281476489587uLL,
  13359637725955156344uLL,
  8245110187859509816uLL,
  7339993977514879941uLL,
  10129395182840808247uLL,
  3659997764317471742uLL,
  4691598600072034734uLL,
  8284964964162430336uLL,
  9566823205505672627uLL,
  4189915749727266302uLL,
  5308965371519461459uLL,
  2054797008891295341uLL,
  18127093924196552729uLL,
  4299196883765669209uLL,
  11827607050011750044uLL,
  4366869471967700896uLL,
  14900107216279217013uLL,
  5151825020866902336uLL,
  12851456451705123783uLL,
  14964368771570310647uLL,
  16330134348011374408uLL,
  5025013570029662271uLL,
  11274104849752320816uLL,
  1053939472501839694uLL,
  4221769898647927732uLL,
  4357920165500097666uLL,
  7834076884326979563uLL,
  4272063780046627846uLL,
  4039116997058321770uLL,
  15719527290815271228uLL,
  1348202375856620388uLL,
  2301898783875571271uLL,
  6460035136011136646uLL,
  10697760313953023253uLL,
  9757329734462923813uLL,
  4584246636790019109uLL,
  6885835975334039940uLL,
  6249906805861885349uLL,
  1725716591743982184uLL,
  11654361487674072621uLL,
  9884822493454733233uLL,
  12987911935559252168uLL,
  4902101741859337225uLL,
  18350419941460675969uLL,
  15398558065995343830uLL,
  15727956704498719552uLL,
  9775692600225218369uLL,
  5118530954824848124uLL,
  941859248514608678uLL,
  6746433271605450562uLL,
  2114129833224464615uLL,
  12546478733877450220uLL,
  6395367805235268478uLL,
  6351512176232662553uLL,
  11672948938689807397uLL,
  15146708894654240359uLL,
  12711757839786531851uLL,
  10393967024288635114uLL,
  1079482412171585708uLL,
  1660095950523830107uLL,
  4570275898977334110uLL,
  9984337143728963412uLL,
  8352020334175620458uLL,
  7268817811428017472uLL,
  10186204447584012985uLL,
  17127960777199221886uLL,
  16597698406407271981uLL,
  7425334241403613730uLL,
  4771374893546118783uLL,
  3442128010744075328uLL,
  10027420342430549022uLL,
  12083075240219002361uLL,
  588527856080217357uLL,
  305227581199019801uLL,
  9136966043892137413uLL,
  16167939901854583435uLL,
  9361845494630744524uLL,
  8878612434848834319uLL,
  16060149010011229344uLL,
  17919194163411307292uLL,
  6639113234980662253uLL,
  18078320177945311096uLL,
  15546328468071953813uLL,
  13546331756440638230uLL,
  14199943778032405328uLL,
  10630353806352961533uLL,
  18144698404047954644uLL,
  1197376723885704574uLL,
  16230126305972622040uLL,
  13879110215555232370uLL,
  227176813662154075uLL,
  12259279986700132039uLL,
  16436033856146448774uLL,
  5277417808893919132uLL,
  15407423850140845350uLL,
  14941017342975270852uLL,
  5674047306833804966uLL,
  7851051224316364461uLL,
  9425565812167574176uLL,
  2943367180561279421uLL,
  8105073495705153153uLL,
  18155546573049577216uLL,
  5697406480502376064uLL,
  5877477751337405235uLL,
  16569231526066812308uLL,
  15537884248800472423uLL,
  10457536541605423473uLL,
  2223801759201342324uLL,
  14316208179399799868uLL,
  15637346486681360577uLL,
  4608566767287318283uLL,
  15573142054250388104uLL,
  6547935807155622982uLL,
  2358717164769637863uLL,
  16614977917201558734uLL,
  9224005500602735395uLL,
  10714921687208609333uLL,
  8671288339249264200uLL,
  5608869571866323513uLL,
  16021647703108623168uLL,
  7977466863429629561uLL,
  10348410572281587866uLL,
  7242289474995514715uLL,
  1567169508226279381uLL,
  13859779875488551809uLL,
  11529389869754286116uLL,
  12412500515456065757uLL,
  17353677876775041213uLL,
  1025395215826879256uLL,
  1615699621365775136uLL,
  4321995075701125085uLL,
  7179077730157579846uLL,
  11538444951899202355uLL,
  4448248277864616299uLL,
  8394522697799974727uLL,
  7265749836394272542uLL,
  562550948483866244uLL,
  8433249156541039618uLL,
  12740995855244699898uLL,
  6288290551140793701uLL,
  17808079497555484198uLL,
  5018038877509214997uLL,
  18911087437259851uLL,
  16955519772417071495uLL,
  7864500398214309565uLL,
  975518652973548277uLL,
  17802037049267904108uLL,
  622187558004557147uLL,
  15318501651330331146uLL,
  5598898530851347884uLL,
  15022728920480447812uLL,
  7970622010814221179uLL,
  10467490273800292370uLL,
  1251993471097504428uLL,
  6584765995150877185uLL,
  12775098777202305839uLL,
  9528624601268067443uLL,
  6791359573957131238uLL,
  8524739724542477550uLL,
  5391013523391169218uLL,
  16544365194255056399uLL,
  5551858142341314141uLL,
  13150694727490329004uLL,
  7884679690313721309uLL,
  13646039774517641819uLL,
  15511235226750475393uLL,
  14308408534714033049uLL,
  16894040979321575468uLL,
  17625365623029753264uLL,
  15655709270582917808uLL,
  11127891396163609889uLL,
  10343413873168693000uLL,
  92947107uLL,
  0uLL,
  0uLL,
  0uLL
}; // weak
char itoa_lower_digits[37] = "0123456789abcdefghijklmnopqrstuvwxyz"; // weak
char itowa_lower_digits[2] = "0"; // weak
int sys_nerr = 135; // weak
_UNKNOWN unk_499318; // weak
_UNKNOWN terminator_9142; // weak
_UNKNOWN _gettext_germanic_plural; // weak
void *_wcsmbs_gconv_fcts_c = &to_wc; // weak
char *nl_C_LC_CTYPE = "C"; // weak
void *step3a_jumps_13585[30] =
{
  &loc_450CC0,
  &loc_450CC0,
  &loc_450CC0,
  &loc_450CC0,
  &loc_450CC0,
  &loc_450CC0,
  &loc_450CC0,
  &loc_450CC0,
  &loc_450CC0,
  &loc_450CC0,
  &loc_451330,
  &loc_450CC0,
  &loc_450CC0,
  &loc_450CC0,
  &loc_451E40,
  &loc_451FA0,
  &loc_451DE0,
  &loc_451E90,
  &loc_451E78,
  &loc_450CC0,
  &loc_450CC0,
  &loc_450CC0,
  &loc_450CC0,
  &loc_451A90,
  &loc_450CC0,
  &loc_450CC0,
  &loc_450CC0,
  &loc_450CC0,
  &loc_450CC0,
  &loc_450CC0
}; // weak
__int128 _libio_codecvt = 0x4618800000000000000000LL; // weak
__int128 xmmword_4A62F0 = 0x4616900000000000461790LL; // weak
__int128 xmmword_4A6300 = 0x4616700000000000461640LL; // weak
__m128i xmmword_4A6310[2] =
{
  { { -112, 25, 70, 0, 0, 0, 0, 0, 128, 22, 70, 0, 0, 0, 0, 0 } },
  { { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } }
}; // weak
__int128 xmmword_4A6330 = 0LL; // weak
__int128 xmmword_4A6340 = 0LL; // weak
__m128i xmmword_4A6350[2] =
{
  { { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } },
  { { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } }
}; // weak
__int128 xmmword_4A6370 = 0LL; // weak
__int128 xmmword_4A6380 = 0LL; // weak
__int128 xmmword_4A6390 = 0LL; // weak
char *nl_C_LC_MONETARY = "C"; // weak
char *nl_C_LC_NUMERIC = "C"; // weak
const char *const sys_errlist[] = { "Success" };
char *tunable_list = "glibc.tune.hwcaps"; // weak
_UNKNOWN unk_4A7528; // weak
int dword_4A7A34 = 0; // weak
__int64 dyn_temp_10781[] = { 0LL }; // weak
__int64 qword_4A7A48 = 0LL; // weak
__int64 _libc_stack_end = 0LL; // weak
int _libc_enable_secure = 1; // weak
char *map_0 = "=INTERNAL->ucs4"; // weak
char *off_4A7B00 = "=ucs4->INTERNAL"; // weak
__int64 (__fastcall *nl_category_postload[16])() =
{
  &nl_postload_ctype,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL
}; // weak
_QWORD nl_current_used[16] =
{
  2LL,
  2LL,
  0LL,
  0LL,
  2LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL
}; // weak
char **nl_C[6] =
{
  &nl_C_LC_CTYPE,
  &nl_C_LC_NUMERIC,
  &nl_C_LC_TIME,
  &nl_C_LC_COLLATE,
  &nl_C_LC_MONETARY,
  &nl_C_LC_MESSAGES
}; // weak
char **nl_C_locobj[6] =
{
  &nl_C_LC_CTYPE,
  &nl_C_LC_NUMERIC,
  &nl_C_LC_TIME,
  &nl_C_LC_COLLATE,
  &nl_C_LC_MONETARY,
  &nl_C_LC_MESSAGES
}; // weak
__int64 rtld_search_dirs = 0LL; // weak
int dword_4A7ED8 = 0; // weak
__int64 max_capstrlen = 0LL; // weak
__int64 ncapstr = 0LL; // weak
__int64 capstr = 0LL; // weak
__int64 env_path_list = 0LL; // weak
int dword_4A7F08 = 0; // weak
int _stack_prot = 16777216; // weak
__int64 dl_tls_static_size = 2048LL; // weak
char *nl_current_default_domain = "messages"; // weak
void *_exit_funcs = &initial; // weak
void *IO_list_all = &IO_2_1_stderr_; // weak
void *stderr = &IO_2_1_stderr_; // weak
void *stdout = &IO_2_1_stdout_; // weak
void *stdin = &IO_2_1_stdin_; // weak
int may_shrink_heap_11587 = -1; // weak
int _libc_malloc_initialized = -1; // weak
__int64 narenas = 1LL; // weak
__int64 mp_ = 131072LL; // weak
__int64 qword_4A87E8 = 131072LL; // weak
__int64 qword_4A87F0 = 131072LL; // weak
__int64 qword_4A87F8 = 8LL; // weak
__int64 qword_4A8800 = 0LL; // weak
int dword_4A8808 = 0; // weak
int dword_4A880C = 65536; // weak
int dword_4A8810 = 0; // weak
int dword_4A8814 = 0; // weak
__int64 qword_4A8818 = 0LL; // weak
__int64 qword_4A8820 = 0LL; // weak
__int64 qword_4A8828 = 0LL; // weak
__int64 qword_4A8830 = 64LL; // weak
__int64 qword_4A8838 = 1032LL; // weak
__int64 qword_4A8840 = 7LL; // weak
__int64 qword_4A8848 = 0LL; // weak
__int64 (__fastcall *_memalign_hook)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, double) = &memalign_hook_ini; // weak
__int64 (__fastcall *_realloc_hook)(_QWORD, _QWORD, _QWORD) = &realloc_hook_ini; // weak
__int64 (__fastcall *_malloc_hook)(_QWORD, _QWORD) = &malloc_hook_ini; // weak
int main_arena = 0; // weak
int dword_4A8884 = 0; // weak
__int64 qword_4A88E0 = 0LL; // weak
int *off_4A90F0 = &main_arena; // weak
__int64 qword_4A9108 = 0LL; // weak
__int64 (__fastcall *_morecore)(_QWORD) = &_default_morecore; // weak
__int64 _x86_raw_shared_cache_size = 1048576LL; // weak
__int64 _x86_raw_shared_cache_size_half = 524288LL; // weak
__int64 _x86_shared_cache_size = 1048576LL; // weak
__int64 _x86_shared_cache_size_half = 524288LL; // weak
__int64 _x86_raw_data_cache_size = 32768LL; // weak
__int64 _x86_raw_data_cache_size_half = 16384LL; // weak
__int64 _x86_data_cache_size = 32768LL; // weak
__int64 _x86_data_cache_size_half = 16384LL; // weak
int cached_result_11481 = -1; // weak
char (*program_invocation_short_name[2])[1707] = { &byte_493255, &byte_493255 }; // weak
char (*program_invocation_name)[1707] = &byte_493255; // weak
int dl_stack_flags = 7; // weak
__int16 dl_fpu_control = 895; // weak
int dl_correct_cache_id = 771; // weak
int dl_debug_fd = 2; // weak
__int64 dl_pagesize = 4096LL; // weak
_DWORD dl_starting_up[2] = { 1, 0 }; // weak
__int64 dl_load_adds = 1LL; // weak
__int64 dl_nns = 1LL; // weak
__int64 dl_use_load_bias = -2LL; // weak
__int64 (__fastcall *dl_make_stack_executable_hook)(_QWORD, _QWORD) = &dl_make_stack_executable; // weak
__int64 (__fastcall *dl_init_static_tls)(_QWORD, _QWORD, _QWORD) = &dl_nothread_init_static_tls; // weak
void **dl_initial_searchlist = &_compound_literal_3; // weak
int dword_4A9258 = 1; // weak
void *dl_ns = &dl_main_map; // weak
int dword_4A9288 = 1; // weak
void ***off_4A9290 = &off_4A95E0; // weak
__int64 qword_4A9298 = 0LL; // weak
_UNKNOWN dl_main_map; // weak
__int64 qword_4A95C8 = 0LL; // weak
__int16 word_4A95D8 = 0; // weak
__int64 qword_4A9660 = 0LL; // weak
int _libc_multiple_libcs = 1; // weak
char *builtin_modules[2] = { "INTERNAL", "ISO-10646/UCS4/" }; // weak
char **nl_global_locale[6] =
{
  &nl_C_LC_CTYPE,
  &nl_C_LC_NUMERIC,
  &nl_C_LC_TIME,
  &nl_C_LC_COLLATE,
  &nl_C_LC_MONETARY,
  &nl_C_LC_MESSAGES
}; // weak
__int16 (*off_4A9AC8)[256] = &word_486FE0; // weak
int (*off_4A9AD0[2])[256] = { &dword_4860E0, &dword_4866E0 }; // weak
int (*off_4A9AD8)[256] = &dword_4866E0; // weak
char *off_4A9AE0[13] = { "C", "C", "C", "C", "C", "C", "C", "C", "C", "C", "C", "C", "C" }; // weak
char *off_4A9B10[7] = { "C", "C", "C", "C", "C", "C", "C" }; // weak
__int16 _fpu_control = 895; // weak
int pa_next_type = 8; // weak
__int64 (__fastcall *dl_open_hook[13])() =
{
  &_libc_dlopen_mode,
  &_libc_dlsym,
  &_libc_dlclose,
  &_libc_dlvsym,
  &_dlopen,
  &_dlclose,
  &_dlsym,
  &_dlvsym,
  &_dlerror,
  &_dladdr,
  &_dladdr1,
  &_dlinfo,
  &_dlmopen
}; // weak
__int64 (__fastcall *dlfcn_hooks[9])() =
{
  &_dlopen,
  &_dlclose,
  &_dlsym,
  &_dlvsym,
  &_dlerror,
  &_dladdr,
  &_dladdr1,
  &_dlinfo,
  &_dlmopen
}; // weak
__int64 adds_9298 = -1LL; // weak
u32 _start___libc_IO_vtables[48] =
{
  0u,
  0u,
  0u,
  0u,
  4250304u,
  0u,
  4238656u,
  0u,
  4237744u,
  0u,
  4590624u,
  0u,
  4590032u,
  0u,
  4239792u,
  0u,
  4246432u,
  0u,
  4235520u,
  0u,
  4255616u,
  0u,
  4241888u,
  0u,
  4239360u,
  0u,
  4586736u,
  0u,
  4247472u,
  0u,
  4246000u,
  0u,
  4243760u,
  0u,
  4241808u,
  0u,
  4245968u,
  0u,
  4259968u,
  0u,
  4259984u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u
}; // weak
_UNKNOWN IO_wfile_jumps_mmap; // weak
_UNKNOWN IO_wfile_jumps; // weak
_UNKNOWN IO_file_jumps_maybe_mmap; // weak
_UNKNOWN IO_file_jumps_mmap; // weak
_UNKNOWN IO_file_jumps; // weak
_UNKNOWN IO_str_jumps; // weak
_UNKNOWN IO_helper_jumps; // weak
_UNKNOWN IO_helper_jumps_0; // weak
__int64 (__fastcall *_start___libc_atexit)() = &IO_cleanup; // weak
_UNKNOWN edata; // weak
__int64 static_slotinfo; // weak
__int64 qword_4AA388; // weak
__int64 output_charset_cache_11675; // weak
int output_charset_cached_11676; // weak
__int64 freemem_size_11636; // weak
__int64 freemem_11635; // weak
int lock_11628; // weak
__int64 transmem_list; // weak
__int64 root; // weak
__int64 nl_loaded_domains; // weak
int lock_10757; // weak
int dword_4AA884; // weak
__int64 qword_4AA888; // weak
__int64 locale_alias_path_10130; // weak
__int64 maxmap; // weak
__int64 nmap; // weak
__int64 string_space_max; // weak
__int64 string_space_act; // weak
int lock_0; // weak
__int64 _abort_msg; // weak
int lock; // weak
int dword_4AA8D4; // weak
__int64 qword_4AA8D8; // weak
int stage; // weak
__int64 phys_pages_8689; // weak
int pagesize_8690; // weak
char _exit_funcs_done; // weak
__int64 freeres_list; // weak
char dealloc_buffers; // weak
int stdio_needs_locking; // weak
__int64 run_fp; // weak
__int64 list_all_lock; // weak
__int64 qword_4AAD38; // weak
__int64 (__fastcall *_after_morecore_hook)(_QWORD, _QWORD); // weak
__int64 (__fastcall *_free_hook)(_QWORD, _QWORD); // weak
__int64 next_to_use_12694; // weak
__int64 narenas_limit_12715; // weak
int using_malloc_checking; // weak
unsigned __int64 aligned_heap_area; // idb
int list_lock; // weak
__int64 free_list; // weak
int free_list_lock; // weak
int perturb_byte; // weak
__int64 global_max_fast; // weak
_UNKNOWN state; // weak
char **environ;
__int64 timestamp_11482; // weak
__int64 dl_hwcap; // weak
int dl_x86_cpu_features; // weak
int dword_4AAE04; // weak
int dword_4AAE08; // weak
_UNKNOWN unk_4AAE0C; // weak
char byte_4AAE0E; // weak
int dword_4AAE10; // weak
int dword_4AAE14; // weak
int dword_4AAE18; // weak
int dword_4AAE1C; // weak
int dword_4AAE20; // weak
int dword_4AAE24; // weak
int dword_4AAE38; // weak
int dword_4AAE3C; // weak
__int64 qword_4AAE40; // weak
int dword_4AAE48; // weak
int dword_4AAE4C; // weak
__int64 qword_4AAE50; // weak
__int64 qword_4AAE58; // weak
__int64 qword_4AAE60; // weak
int once_0; // weak
__int64 known_derivations; // weak
int modcounter_12697; // weak
int lock_12717; // weak
int cache_malloced; // weak
__int64 cache_size; // weak
__int64 gconv_cache; // weak
__int64 release_handle; // weak
__int64 loaded; // weak
__int64 archloaded; // weak
_UNKNOWN archive_stat; // weak
unsigned __int64 len; // idb
__int64 headmap; // weak
int dword_4AAFBC; // weak
__int64 archmapped; // weak
__int64 last_environ; // weak
__int64 known_values; // weak
int envlock; // weak
int lock_1; // weak
int next_bit; // weak
int lock_2; // weak
int lock_3; // weak
_UNKNOWN state_0; // weak
_UNKNOWN state_1; // weak
__int64 _curbrk; // weak
__int64 max_dirnamelen; // weak
int log_hashfraction; // weak
__int64 textsize; // weak
__int64 lowpc; // weak
int fromidx; // weak
int fromlimit; // weak
__int64 froms; // weak
__int64 tos; // weak
__int64 narcsp; // weak
int narcs; // weak
int running; // weak
__int64 data; // weak
__int64 cachesize; // weak
__int64 cache_new; // weak
__int64 cache; // weak
int once; // weak
__int64 static_buf; // weak
_UNKNOWN last_result; // weak
__int64 *qword_4AB0B8; // weak
_UNKNOWN oact_8659; // weak
struct itimerval otimer_8660; // weak
int pc_scale; // weak
__int64 pc_offset; // weak
__int64 nsamples; // weak
__int64 samples; // weak
int dl_close_state_11871; // weak
char dwarf_reg_size_table[]; // weak
char byte_4AB1C7; // weak
_UNKNOWN marker_9036; // weak
__int64 subs_9299; // weak
__int64 frame_hdr_cache_head; // weak
_UNKNOWN frame_hdr_cache; // weak
_UNKNOWN unk_4AB230; // weak
__int64 qword_4AB378; // weak
int any_objects_registered; // weak
__int64 seen_objects; // weak
__int64 unseen_objects; // weak
__int64 dl_tls_static_used; // weak
__int64 dl_tls_static_align; // weak
__int64 dl_tls_max_dtv_idx; // weak
__int64 dl_static_dtv; // weak
_QWORD qword_4AB3F0[2]; // weak
__int64 qword_4AB400; // weak
__int64 qword_4AB408; // weak
__int64 dl_tls_dtv_slotinfo_list; // weak
char dl_tls_dtv_gaps; // weak
__int64 dl_tls_generation; // weak
__int64 dl_tls_static_nelem; // weak
__int64 nl_domain_bindings; // weak
int nl_msg_cat_cntr; // weak
int _exit_funcs_lock; // weak
__int64 _new_exitfn_called; // weak
int _libc_multiple_threads; // weak
__int64 _x86_shared_non_temporal_threshold; // weak
int _x86_prefetchw; // weak
_UNKNOWN r_debug; // weak
__int64 qword_4AB860; // weak
__int64 dl_profile_output; // weak
__int64 dl_platformlen; // weak
int dl_debug_mask; // weak
__int64 (__fastcall *dl_wait_lookup_done)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD); // weak
__int64 dl_profile; // weak
int dl_bind_not; // weak
__int64 dl_auxv; // weak
__int64 dl_platform; // weak
int dl_x86_feature_1; // weak
int dword_4AB8B4; // weak
int dl_lazy; // weak
__int64 dl_sysinfo_map; // weak
int dl_inhibit_cache; // weak
__int64 dl_phdr; // weak
__int64 dl_scope_free_list; // weak
__int64 dl_origin_path; // weak
int dl_clktck; // weak
int dl_dynamic_weak; // weak
__int64 dl_sysinfo_dso; // weak
__int64 dl_init_all_dirs; // weak
int dl_verbose; // weak
__int64 dl_phnum; // weak
__int64 dl_profile_map; // weak
__int64 dl_initfirst; // weak
__int64 dl_all_dirs; // weak
int dl_osversion; // weak
__int64 dl_inhibit_rpath; // weak
int dl_x86_legacy_bitmap; // idb
__int64 qword_4AB948; // weak
int _libc_enable_secure_decided; // weak
int _libc_argc; // weak
__int64 _libc_argv; // weak
__int64 _gconv_modules_db; // weak
int _gconv_lock; // weak
__int64 _gconv_alias_db; // weak
__int64 _gconv_path_envvar; // weak
__int64 _gconv_max_path_elem_len; // weak
__int64 _gconv_path_elem; // weak
_QWORD nl_locale_file_list[13]; // weak
__int64 _printf_function_table; // weak
__int64 _printf_modifier_table; // weak
__int64 map; // weak
__int64 string_space; // weak
__int64 _printf_arginfo_table; // weak
__int64 _printf_va_arg_table; // weak
__int64 buf; // weak


//----- (00000000004010E0) ----------------------------------------------------
void __fastcall __noreturn _assert_fail_base_cold_0(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        u32 *a5,
        unsigned __int64 a6,
        int a7,
        __int64 a8)
{
  __int64 v8; // rdx
  __int64 v9; // rcx
  u32 *v10; // r8
  u32 v11; // er9

  free(a8, a2, a3, a4, a5, a6);
  abort(a8, a2, v8, v9, v10, v11);
}
// 4010EA: variable 'v8' is possibly undefined
// 4010EA: variable 'v9' is possibly undefined
// 4010EA: variable 'v10' is possibly undefined
// 4010EA: variable 'v11' is possibly undefined

//----- (00000000004010F4) ----------------------------------------------------
void __fastcall __noreturn abort(__int64 a1, __int64 _RSI, __int64 a3, __int64 a4, u32 *a5, u32 a6)
{
  __int64 v6; // rdx
  __int64 i; // rax
  bool v8; // zf
  __int64 v9; // rcx
  u32 *v10; // r8
  u32 v11; // er9
  __int64 v12; // rdx
  __int64 v14; // rcx
  __int64 *v15; // rdi
  __int64 v16; // rax
  sigset_t v17; // [rsp+0h] [rbp-128h] BYREF
  __int64 v18[17]; // [rsp+80h] [rbp-A8h] BYREF
  int v19; // [rsp+108h] [rbp-20h]
  unsigned __int64 v20; // [rsp+118h] [rbp-10h]

  v6 = __readfsqword(0x10u);
  v20 = __readfsqword(0x28u);
  if ( qword_4AA8D8 == v6 )
  {
LABEL_8:
    ++dword_4AA8D4;
    if ( !stage )
    {
      stage = 1;
      for ( i = 16LL; ; v17.__val[i] = 0LL )
      {
        --i;
        _RSI = (__int64)&v17;
        if ( i == -1 )
          break;
      }
      v17.__val[0] |= 0x20uLL;
      sigprocmask(1, &v17, 0LL);
    }
    if ( stage != 1 )
    {
      if ( stage != 2 )
        goto LABEL_35;
      goto LABEL_29;
    }
    v8 = dword_4AA8D4-- == 1;
    stage = 0;
    if ( v8 )
    {
      qword_4AA8D8 = 0LL;
      if ( _libc_multiple_threads )
      {
        if ( !_InterlockedDecrement(&lock) )
          goto LABEL_20;
      }
      else if ( !--lock )
      {
        goto LABEL_20;
      }
      _lll_unlock_wake_private((u32 *)&lock, _RSI, v6, a4, a5, a6);
    }
LABEL_20:
    raise(6);
    v12 = __readfsqword(0x10u);
    if ( qword_4AA8D8 == v12 )
    {
LABEL_27:
      ++dword_4AA8D4;
LABEL_29:
      v14 = 38LL;
      stage = 3;
      v15 = v18;
      while ( v14 )
      {
        *(_DWORD *)v15 = 0;
        v15 = (__int64 *)((char *)v15 + 4);
        --v14;
      }
      v16 = 16LL;
      do
        v18[v16--] = -1LL;
      while ( v16 );
      v19 = 0;
      sigaction(6, (__int64)v18, 0LL);
LABEL_35:
      if ( stage == 3 )
      {
        stage = 4;
        raise(6);
      }
      if ( stage == 4 )
      {
        stage = 5;
        __halt();
      }
      if ( stage == 5 )
      {
        stage = 6;
        exit(127);
      }
      __halt();
    }
    _ESI = 1;
    if ( _libc_multiple_threads )
    {
      if ( !_InterlockedCompareExchange(&lock, 1, 0) )
        goto LABEL_26;
    }
    else
    {
      __asm { cmpxchg cs:lock, esi }
      if ( !_libc_multiple_threads )
      {
LABEL_26:
        qword_4AA8D8 = v12;
        goto LABEL_27;
      }
    }
    _lll_lock_wait_private((u32 *)&lock, 1LL, v12, v9, v10, v11);
    goto LABEL_26;
  }
  _RSI = 1LL;
  if ( _libc_multiple_threads )
  {
    if ( !_InterlockedCompareExchange(&lock, 1, 0) )
      goto LABEL_7;
  }
  else
  {
    __asm { cmpxchg cs:lock, esi }
    if ( !_libc_multiple_threads )
    {
LABEL_7:
      qword_4AA8D8 = v6;
      goto LABEL_8;
    }
  }
  _lll_lock_wait_private((u32 *)&lock, 1LL, v6, a4, a5, a6);
  goto LABEL_7;
}
// 401163: variable 'v6' is possibly undefined
// 401205: variable 'a4' is possibly undefined
// 401205: variable 'a5' is possibly undefined
// 401205: variable 'a6' is possibly undefined
// 401260: variable 'v9' is possibly undefined
// 401260: variable 'v10' is possibly undefined
// 401260: variable 'v11' is possibly undefined
// 40126C: variable 'v12' is possibly undefined
// 4AA8D0: using guessed type int lock;
// 4AA8D4: using guessed type int dword_4AA8D4;
// 4AA8D8: using guessed type __int64 qword_4AA8D8;
// 4AA8E0: using guessed type int stage;
// 4AB820: using guessed type int _libc_multiple_threads;
// 4010F4: using guessed type _QWORD var_A8[17];

//----- (0000000000401318) ----------------------------------------------------
#error "401362: call analysis failed (funcsize=19)"

//----- (0000000000401367) ----------------------------------------------------
#error "4013B1: call analysis failed (funcsize=19)"

//----- (00000000004013B6) ----------------------------------------------------
#error "401401: call analysis failed (funcsize=19)"

//----- (0000000000401406) ----------------------------------------------------
#error "401451: call analysis failed (funcsize=19)"

//----- (0000000000401456) ----------------------------------------------------
#error "4014A2: call analysis failed (funcsize=19)"

//----- (00000000004014A7) ----------------------------------------------------
void __fastcall __noreturn dl_start(__int64 a1, __int64 a2, __int64 a3, __int64 a4, u32 *a5, u32 a6)
{
  abort(a1, a2, a3, a4, a5, a6);
}

//----- (0000000000401502) ----------------------------------------------------
#error "40154C: call analysis failed (funcsize=19)"

//----- (0000000000401551) ----------------------------------------------------
#error "40159B: call analysis failed (funcsize=19)"

//----- (00000000004015F0) ----------------------------------------------------
__int64 *__fastcall fini(__int64 a1, __int64 a2, __int64 a3, __int64 a4, u32 *a5, unsigned __int64 a6)
{
  return check_free_isra_0(&qword_4AB0B8, a2, a3, a4, a5, a6);
}
// 4AB0B8: using guessed type __int64 *qword_4AB0B8;

//----- (0000000000401600) ----------------------------------------------------
int __cdecl main(int argc, const char **argv, const char **envp)
{
  puts((__int64)"Hello World", (__int64)argv);
  printf((unsigned __int64)"argc=%d\n", (unsigned int)argc);
  return 0;
}

//----- (0000000000401620) ----------------------------------------------------
__int64 init_cacheinfo()
{
  __int64 v0; // rax
  unsigned int v1; // esi
  __int64 v2; // rbp
  __int64 v3; // r12
  __int64 v4; // rax
  __int64 v5; // rax
  __int64 v6; // rax
  __int64 result; // rax
  int v8; // er13
  __int64 v9; // r14
  int v10; // er10
  int v11; // er15
  int v12; // esi
  int v13; // ecx
  signed int v14; // er8
  bool v15; // r11
  int v16; // edi
  int v22; // ecx
  __int64 v23; // r8
  unsigned int v29; // edi
  _BOOL4 v45; // eax
  int v46; // edi
  int v52; // ecx
  unsigned int v53; // ecx
  int v54; // eax
  int v55; // ebx
  unsigned int v56; // ecx
  unsigned int v57; // ecx

  if ( dl_x86_cpu_features == 1 )
  {
    v8 = dword_4AAE04;
    v3 = handle_intel_constprop_1(188);
    v9 = handle_intel_constprop_1(191);
    v2 = handle_intel_constprop_1(194);
    if ( v2 <= 0 )
    {
      v2 = v9;
      v10 = -1;
      v11 = 2;
    }
    else
    {
      v10 = 0;
      v11 = 3;
    }
    v1 = dword_4AAE14 & 0x10000000;
    if ( (dword_4AAE14 & 0x10000000) == 0 )
      goto LABEL_41;
    if ( v8 <= 3 )
    {
      v14 = 0;
      v15 = 1;
LABEL_33:
      v1 = (unsigned __int8)byte_4AAE0E;
LABEL_34:
      if ( v2 > 0 && v1 )
        v2 /= (__int64)v1;
LABEL_37:
      if ( !v15 )
      {
        if ( v14 )
          v9 /= v14;
LABEL_40:
        v2 += v9;
      }
LABEL_41:
      v0 = qword_4AAE50;
      if ( !qword_4AAE50 )
      {
LABEL_6:
        if ( v3 > 0 )
        {
          v4 = v3;
          _x86_raw_data_cache_size = v3;
          LOBYTE(v3) = 0;
          _x86_data_cache_size = v3;
          _x86_raw_data_cache_size_half = v4 >> 1;
          _x86_data_cache_size_half = v3 >> 1;
        }
        v5 = qword_4AAE58;
        if ( !qword_4AAE58 )
          goto LABEL_10;
        goto LABEL_9;
      }
LABEL_5:
      v3 = v0;
      goto LABEL_6;
    }
    v12 = 3;
    if ( v10 )
    {
      v12 = 1;
      v10 = -1;
    }
    v13 = 0;
    v14 = 0;
    v15 = 1;
    while ( 1 )
    {
      v16 = v13 + 1;
      _RAX = 4LL;
      __asm { cpuid }
      if ( (_RAX & 0x1F) == 0 )
        goto LABEL_33;
      v22 = (unsigned __int8)_RAX >> 5;
      if ( v22 == 2 )
      {
        if ( (v12 & 1) == 0 )
          goto LABEL_30;
        v12 &= ~1u;
        v14 = ((unsigned int)_RAX >> 14) & 0x3FF;
      }
      else if ( v22 == 3 )
      {
        if ( (v12 & 2) == 0 )
          goto LABEL_30;
        v12 &= ~2u;
        v10 = ((unsigned int)_RAX >> 14) & 0x3FF;
        v15 = (_RDX & 2) != 0;
      }
      if ( !v12 )
      {
        if ( v8 > 10 )
        {
          v45 = 1;
          if ( v10 <= 0 )
            v45 = v14 > 0 && v11 == 2;
          v46 = (v14 > 0 && v11 == 3) | (2 * v45);
          while ( v46 )
          {
            _RAX = 11LL;
            __asm { cpuid }
            v52 = _RCX & 0xFF00;
            if ( !(_BYTE)_RBX || !v52 )
              break;
            if ( v52 == 256 )
            {
              if ( (v46 & 1) != 0 )
              {
                _BitScanReverse(&v53, v14);
                v46 &= ~1u;
                v14 = ((unsigned __int8)_RBX - 1) & ~(-1 << (v53 + 1));
              }
            }
            else if ( v52 == 512 && (v46 & 2) != 0 )
            {
              v55 = (unsigned __int8)_RBX - 1;
              if ( v11 == 2 )
              {
                _BitScanReverse(&v57, v14);
                v14 = v55 & ~(-1 << (v57 + 1));
              }
              else
              {
                _BitScanReverse(&v56, v10);
                v10 = v55 & ~(-1 << (v56 + 1));
              }
              v46 &= ~2u;
            }
            ++v12;
          }
        }
        v14 -= (v14 == 0) - 1;
        if ( v10 <= 0 )
        {
          if ( v11 != 2 )
          {
            v1 = 0;
            if ( !v10 )
              goto LABEL_37;
            v1 = -1;
            goto LABEL_34;
          }
        }
        else if ( v11 != 2 )
        {
          v1 = v10 + 1;
          goto LABEL_34;
        }
        if ( v14 )
        {
          v1 = v14;
          if ( (unsigned int)v14 > 2 && dword_4AAE38 == 6 && (unsigned int)(dword_4AAE3C - 55) <= 0x26 )
          {
            v54 = 2;
            if ( ((1LL << ((unsigned __int8)dword_4AAE3C - 55)) & 0x4800480001LL) == 0 )
              v54 = v14;
            v1 = v54;
          }
          goto LABEL_34;
        }
        v1 = 0;
        if ( !v15 )
          goto LABEL_40;
        goto LABEL_41;
      }
LABEL_30:
      v13 = v16;
    }
  }
  if ( dl_x86_cpu_features == 2 )
  {
    v3 = handle_amd(188);
    v2 = handle_amd(191);
    v1 = 0;
    v23 = handle_amd(194);
    _RAX = 0x80000000LL;
    __asm { cpuid }
    v29 = _RAX;
    if ( v23 <= 0 )
    {
LABEL_48:
      if ( v29 > 0x80000000 )
      {
        _RAX = 2147483649LL;
        __asm { cpuid }
        if ( (_RCX & 0x100) != 0 || (int)_RDX < 0 )
          _x86_prefetchw = -1;
      }
      goto LABEL_41;
    }
    if ( (unsigned int)_RAX > 0x80000007 )
    {
      _RAX = 2147483656LL;
      __asm { cpuid }
      v29 = _RAX;
      v1 = 1 << ((unsigned __int16)_RCX >> 12);
    }
    else
    {
      _RAX = 1LL;
      __asm { cpuid }
      v29 = _RAX;
      v1 = _RDX & 0x10000000;
      if ( (_RDX & 0x10000000) == 0 )
        goto LABEL_47;
      v1 = BYTE2(_RBX);
      if ( !BYTE2(_RBX) )
        goto LABEL_47;
    }
    v23 /= (__int64)v1;
LABEL_47:
    v2 += v23;
    goto LABEL_48;
  }
  v0 = qword_4AAE50;
  if ( qword_4AAE50 )
  {
    v1 = 0;
    v2 = -1LL;
    goto LABEL_5;
  }
  v5 = qword_4AAE58;
  v1 = 0;
  if ( !qword_4AAE58 )
    goto LABEL_12;
LABEL_9:
  v2 = v5;
LABEL_10:
  if ( v2 > 0 )
  {
    v6 = v2;
    _x86_raw_shared_cache_size = v2;
    LOBYTE(v2) = 0;
    _x86_shared_cache_size = v2;
    _x86_raw_shared_cache_size_half = v6 >> 1;
    _x86_shared_cache_size_half = v2 >> 1;
  }
LABEL_12:
  result = qword_4AAE60;
  if ( !qword_4AAE60 )
    result = 3 * _x86_shared_cache_size * v1 / 4;
  _x86_shared_non_temporal_threshold = result;
  return result;
}
// 4A9120: using guessed type __int64 _x86_raw_shared_cache_size;
// 4A9128: using guessed type __int64 _x86_raw_shared_cache_size_half;
// 4A9130: using guessed type __int64 _x86_shared_cache_size;
// 4A9138: using guessed type __int64 _x86_shared_cache_size_half;
// 4A9140: using guessed type __int64 _x86_raw_data_cache_size;
// 4A9148: using guessed type __int64 _x86_raw_data_cache_size_half;
// 4A9150: using guessed type __int64 _x86_data_cache_size;
// 4A9158: using guessed type __int64 _x86_data_cache_size_half;
// 4AAE00: using guessed type int dl_x86_cpu_features;
// 4AAE04: using guessed type int dword_4AAE04;
// 4AAE0E: using guessed type char byte_4AAE0E;
// 4AAE14: using guessed type int dword_4AAE14;
// 4AAE38: using guessed type int dword_4AAE38;
// 4AAE3C: using guessed type int dword_4AAE3C;
// 4AAE50: using guessed type __int64 qword_4AAE50;
// 4AAE58: using guessed type __int64 qword_4AAE58;
// 4AAE60: using guessed type __int64 qword_4AAE60;
// 4AB828: using guessed type __int64 _x86_shared_non_temporal_threshold;
// 4AB830: using guessed type int _x86_prefetchw;

//----- (0000000000401BF0) ----------------------------------------------------
__int16 __fastcall get_common_indeces_constprop_1(unsigned int *a1, int *a2, unsigned int *a3, _DWORD *a4)
{
  _DWORD *v23; // rdi
  int *v24; // r8
  unsigned int v25; // esi
  int v26; // er9
  unsigned int v32; // eax
  int v33; // edx
  int v34; // ecx
  __int64 v36; // [rsp+0h] [rbp-108h]
  int v37; // [rsp+8h] [rbp-100h] BYREF
  int v38; // [rsp+7Ch] [rbp-8Ch]
  __int64 v39; // [rsp+80h] [rbp-88h] BYREF
  int v40; // [rsp+FCh] [rbp-Ch]

  if ( a1 )
  {
    _RAX = 1LL;
    __asm { cpuid }
    dword_4AAE14 = _RDX;
    unk_4AAE0C = _RBX;
    dword_4AAE10 = _RCX;
    dword_4AAE08 = _RAX;
    *a1 = ((unsigned int)_RAX >> 8) & 0xF;
    *a2 = (unsigned __int8)_RAX >> 4;
    *a3 = ((unsigned int)_RAX >> 12) & 0xF0;
    *a4 = _RAX & 0xF;
    if ( *a1 == 15 )
    {
      *a1 = (unsigned __int8)((unsigned int)_RAX >> 20) + 15;
      LODWORD(_RAX) = *a3;
      *a2 += *a3;
    }
  }
  if ( dword_4AAE04 > 6 )
  {
    _RAX = 7LL;
    __asm { cpuid }
    dword_4AAE18 = _RAX;
    dword_4AAE1C = _RBX;
    dword_4AAE20 = _RCX;
    dword_4AAE24 = _RDX;
  }
  if ( (dword_4AAE10 & 0x8000000) != 0 )
  {
    __asm { xgetbv }
    if ( (_RAX & 6) == 6 )
    {
      if ( (dword_4AAE10 & 0x10000000) != 0 )
      {
        v33 = dword_4AAE4C;
        dword_4AAE4C |= 0x40u;
        if ( (dword_4AAE1C & 0x20) != 0 )
          dword_4AAE4C = v33 | 0xC40;
        if ( (dword_4AAE10 & 0x1000) != 0 )
          dword_4AAE4C |= 0x80u;
      }
      LODWORD(_RAX) = _RAX & 0xE0;
      if ( (_DWORD)_RAX == 224 && (dword_4AAE1C & 0x10000) != 0 )
      {
        LODWORD(_RAX) = dword_4AAE4C;
        v34 = dword_4AAE4C;
        BYTE1(_RAX) = BYTE1(dword_4AAE4C) | 0x10;
        if ( (dword_4AAE1C & 0x20000) != 0 )
        {
          BYTE1(v34) = BYTE1(dword_4AAE4C) | 0x30;
          LODWORD(_RAX) = v34;
        }
        dword_4AAE4C = _RAX;
      }
    }
    if ( dword_4AAE04 > 12 )
    {
      _RAX = 13LL;
      __asm { cpuid }
      if ( (_DWORD)_RBX )
      {
        dword_4AAE48 = (_RBX + 127) & 0xFFFFFFC0;
        qword_4AAE40 = ((_DWORD)_RBX + 127) & 0xFFFFFFC0;
        _RAX = 13LL;
        __asm { cpuid }
        if ( (_RAX & 2) != 0 )
        {
          v23 = (_DWORD *)&v39 + 1;
          v24 = &v37;
          v37 = 576;
          v25 = 2;
          v26 = 238;
          HIDWORD(v36) = 160;
          v39 = 0x100000000A0LL;
          while ( 1 )
          {
            if ( _bittest(&v26, v25) )
            {
              _RAX = 13LL;
              __asm { cpuid }
              v23[1] = _RAX;
              if ( v25 == 2 )
                goto LABEL_17;
              v32 = *(v24 - 1) + *v23;
              if ( (_RCX & 2) != 0 )
                v32 = (v32 + 63) & 0xFFFFFFC0;
              *v24 = v32;
            }
            else
            {
              v23[1] = 0;
              if ( v25 == 2 )
                goto LABEL_17;
              *v24 = *(v24 - 1) + *v23;
            }
            if ( v25 == 31 )
            {
              LODWORD(_RAX) = v38 + v40;
              if ( v38 + v40 )
              {
                dword_4AAE4C |= 0x400000u;
                LODWORD(_RAX) = (_RAX + 127) & 0xFFFFFFC0;
                qword_4AAE40 = (unsigned int)_RAX;
              }
              return _RAX;
            }
LABEL_17:
            ++v25;
            ++v23;
            ++v24;
          }
        }
      }
    }
  }
  return _RAX;
}
// 401C98: variable '_RAX' is possibly undefined
// 4AAE04: using guessed type int dword_4AAE04;
// 4AAE08: using guessed type int dword_4AAE08;
// 4AAE10: using guessed type int dword_4AAE10;
// 4AAE14: using guessed type int dword_4AAE14;
// 4AAE18: using guessed type int dword_4AAE18;
// 4AAE1C: using guessed type int dword_4AAE1C;
// 4AAE20: using guessed type int dword_4AAE20;
// 4AAE24: using guessed type int dword_4AAE24;
// 4AAE40: using guessed type __int64 qword_4AAE40;
// 4AAE48: using guessed type int dword_4AAE48;
// 4AAE4C: using guessed type int dword_4AAE4C;

//----- (0000000000402590) ----------------------------------------------------
__int64 __fastcall check_one_fd(unsigned int a1, int a2, unsigned __int64 a3)
{
  __int64 result; // rax
  const char *v5; // rdi
  struct stat v6; // [rsp+0h] [rbp-A8h] BYREF

  result = _fcntl64_nocancel(a1, 1u, a3);
  if ( (_DWORD)result == -1 )
  {
    result = -64LL;
    if ( __readfsdword(0xFFFFFFC0) == 9 )
    {
      v5 = "/dev/full";
      if ( a2 == 0x20000 )
        v5 = "/dev/null";
      if ( a1 != (unsigned int)_open_nocancel(v5, a2, 0)
        || (unsigned int)fxstat(1u, a1, &v6)
        || (result = v6.st_mode & 0xF000, (_DWORD)result != 0x2000)
        || v6.st_rdev != 4LL * (a2 != 0x20000) + 259 )
      {
        __halt();
      }
    }
  }
  return result;
}

//----- (0000000000402640) ----------------------------------------------------
__int64 __fastcall _libc_check_standard_fds(__int64 a1, __int64 a2, unsigned __int64 a3)
{
  unsigned __int64 v3; // rdx
  unsigned __int64 v4; // rdx

  check_one_fd(0, 131073, a3);
  check_one_fd(1u, 0x20000, v3);
  return check_one_fd(2u, 0x20000, v4);
}
// 40265E: variable 'v3' is possibly undefined
// 402671: variable 'v4' is possibly undefined

//----- (0000000000402680) ----------------------------------------------------
unsigned __int64 _libc_setup_tls()
{
  unsigned __int64 v0; // rbx
  _QWORD *v1; // r14
  unsigned __int64 v2; // rax
  unsigned __int64 v3; // r12
  unsigned __int64 v4; // r13
  unsigned __int64 v5; // rbp
  unsigned __int64 v6; // rax
  __int64 v7; // r8
  unsigned __int64 v8; // rcx
  unsigned __int64 v9; // r15
  _QWORD *v10; // rsi
  unsigned __int64 *v11; // rdx
  signed __int64 v12; // rax
  __int64 v13; // rdx
  __int64 v14; // rcx
  __int64 v15; // r9
  __int64 v16; // rax
  unsigned __int64 result; // rax
  unsigned __int64 v18; // rax
  __int64 v19; // [rsp+8h] [rbp-50h]
  unsigned __int64 v20; // [rsp+10h] [rbp-48h]
  unsigned __int64 v21; // [rsp+10h] [rbp-48h]
  u32 *v22; // [rsp+18h] [rbp-40h]

  v0 = dl_phdr;
  v1 = dl_ns;
  if ( dl_phdr )
  {
    v2 = dl_phdr + 56 * dl_phnum;
    if ( dl_phdr < v2 )
    {
      while ( *(_DWORD *)v0 != 7 )
      {
        v0 += 56LL;
        if ( v2 <= v0 )
          goto LABEL_12;
      }
      v3 = *(_QWORD *)(v0 + 48);
      v4 = *(_QWORD *)(v0 + 40);
      v19 = *(_QWORD *)(v0 + 32);
      v20 = *(_QWORD *)(v0 + 16) + *(_QWORD *)dl_ns;
      if ( v3 > 0x40 )
      {
        v5 = v3 * ((v3 + v4 + dl_tls_static_size - 1) / v3);
        v6 = sbrk(v5 + v3 + 2304);
        v7 = v3;
        dl_static_dtv = 62LL;
        v8 = -(__int64)v3 & (v6 + v3 - 1);
LABEL_8:
        v0 = v20;
        v9 = v3 * ((v3 + v4 - 1) / v3);
        goto LABEL_9;
      }
      v0 = *(_QWORD *)(v0 + 16) + *(_QWORD *)dl_ns;
      v9 = v4;
    }
    else
    {
LABEL_12:
      v19 = 0LL;
      v3 = 0LL;
      v0 = 0LL;
      v9 = 0LL;
    }
  }
  else
  {
    v19 = 0LL;
    v3 = 0LL;
    v9 = 0LL;
  }
  v5 = (v9 + dl_tls_static_size + 63) & 0xFFFFFFFFFFFFFFC0LL;
  v18 = sbrk(v5 + 2368);
  dl_static_dtv = 62LL;
  v8 = (v18 + 63) & 0xFFFFFFFFFFFFFFC0LL;
  if ( v3 )
  {
    v20 = v0;
    v4 = v9;
    v7 = 64LL;
    goto LABEL_8;
  }
  v4 = v9;
  v7 = 64LL;
LABEL_9:
  v21 = v8;
  v1[137] = v9;
  v22 = (u32 *)v7;
  qword_4AB400 = v8 + v5 - v9;
  qword_4AB408 = 0LL;
  j_memcpy(v8 + v5 - v9, v0, v19);
  v10 = (_QWORD *)(v21 + v5);
  v10[1] = qword_4AB3F0;
  *v10 = v10;
  v10[2] = v10;
  v12 = sys_arch_prctl((struct task_struct *)0x1002, (int)v21 + (int)v5, v11);
  if ( (_DWORD)v12 )
    _libc_fatal((__int64)"cannot set %fs base address for thread-local storage", (__int64)v10, v13, v14, v22, v15);
  v1[135] = v3;
  v1[134] = v4;
  v1[133] = v19;
  dl_tls_dtv_slotinfo_list = (__int64)&static_slotinfo;
  v16 = dl_tls_static_size;
  v1[132] = v0;
  qword_4AA388 = (__int64)v1;
  v1[138] = 1LL;
  result = ((v9 + v16 + 63) & 0xFFFFFFFFFFFFFFC0LL) + 2304;
  dl_tls_static_used = v9;
  static_slotinfo = 64LL;
  dl_tls_max_dtv_idx = 1LL;
  dl_tls_static_size = result;
  dl_tls_static_align = (__int64)v22;
  dl_tls_static_nelem = 1LL;
  return result;
}
// 4027BD: variable 'v11' is possibly undefined
// 4027CF: variable 'v13' is possibly undefined
// 4027CF: variable 'v14' is possibly undefined
// 4027CF: variable 'v15' is possibly undefined
// 401040: using guessed type __int64 __fastcall j_memcpy(_QWORD, _QWORD, _QWORD);
// 4A80E8: using guessed type __int64 dl_tls_static_size;
// 4A9280: using guessed type void *dl_ns;
// 4AA360: using guessed type __int64 static_slotinfo;
// 4AA388: using guessed type __int64 qword_4AA388;
// 4AB3C0: using guessed type __int64 dl_tls_static_used;
// 4AB3C8: using guessed type __int64 dl_tls_static_align;
// 4AB3D0: using guessed type __int64 dl_tls_max_dtv_idx;
// 4AB3E0: using guessed type __int64 dl_static_dtv;
// 4AB3F0: using guessed type _QWORD qword_4AB3F0[2];
// 4AB400: using guessed type __int64 qword_4AB400;
// 4AB408: using guessed type __int64 qword_4AB408;
// 4AB7E0: using guessed type __int64 dl_tls_dtv_slotinfo_list;
// 4AB7F8: using guessed type __int64 dl_tls_static_nelem;
// 4AB8D0: using guessed type __int64 dl_phdr;
// 4AB908: using guessed type __int64 dl_phnum;

//----- (0000000000402A00) ----------------------------------------------------
void __fastcall __noreturn _assert_fail_base(
        unsigned __int64 a1,
        __int64 a2,
        __int64 a3,
        unsigned int a4,
        unsigned __int8 *a5,
        __int64 a6,
        int a7,
        __int64 a8)
{
  unsigned __int8 *v10; // r8
  unsigned __int8 *v11; // rcx
  __int64 v12; // rdx
  __int64 v13; // rcx
  __int64 v14; // r8
  unsigned __int64 v15; // r9
  __int64 v16; // rdi
  size_t v17; // rsi
  __int64 v18; // rdx
  __int64 v19; // rcx
  _DWORD *v20; // rbx
  u32 *v21; // r8
  unsigned __int64 v22; // r9
  unsigned int *v23; // rbx
  int v24; // [rsp+Ch] [rbp-3Ch] BYREF
  const char *v25[7]; // [rsp+10h] [rbp-38h] BYREF

  v25[1] = (const char *)__readfsqword(0x28u);
  v10 = ": ";
  if ( !a5 )
  {
    a5 = byte_493255;
    v10 = byte_493255;
  }
  v11 = byte_493255;
  if ( *(_BYTE *)program_invocation_short_name[0] )
    v11 = ": ";
  if ( (int)asprintf((__int64 *)v25, a1, program_invocation_short_name[0], v11, a3, a4, a5, v10, a2, &v24) >= 0 )
  {
    _fxprintf(0LL, (__int64)"%s", v25[0]);
    fflush((__int64)stderr, (unsigned __int64)"%s", v12, v13, v14, v15);
    v16 = 0LL;
    v24 = -(int)dl_pagesize & (dl_pagesize + v24);
    v17 = v24;
    v20 = (_DWORD *)mmap64(0LL, v24, 3uLL, 0x22uLL, 0xFFFFFFFFuLL, 0LL);
    if ( v20 != (_DWORD *)-1LL )
    {
      v17 = (size_t)v25[0];
      v16 = (__int64)(v20 + 1);
      *v20 = v24;
      strcpy_ifunc(v20 + 1, v17);
      v23 = (unsigned int *)_InterlockedExchange64(&_abort_msg, (__int64)v20);
      if ( v23 )
      {
        v17 = *v23;
        v16 = (__int64)v23;
        munmap((unsigned __int64)v23, v17);
      }
    }
    _assert_fail_base_cold_0(v16, v17, v18, v19, v21, v22, a7, a8);
  }
  write(2u, "Unexpected error.\n", 0x12uLL);
  JUMPOUT(0x4010EALL);
}
// 402B47: control flows out of bounds to 4010EA
// 402ABC: variable 'v12' is possibly undefined
// 402ABC: variable 'v13' is possibly undefined
// 402ABC: variable 'v14' is possibly undefined
// 402ABC: variable 'v15' is possibly undefined
// 402B2C: variable 'v18' is possibly undefined
// 402B2C: variable 'v19' is possibly undefined
// 402B2C: variable 'v21' is possibly undefined
// 402B2C: variable 'v22' is possibly undefined
// 401020: using guessed type __int64 __fastcall strcpy_ifunc(_QWORD, _QWORD);
// 493255: using guessed type unsigned __int8 byte_493255[1707];
// 4A8798: using guessed type void *stderr;
// 4A9168: using guessed type char (*program_invocation_short_name[2])[1707];
// 4A91F8: using guessed type __int64 dl_pagesize;
// 4AA8C0: using guessed type __int64 _abort_msg;

//----- (0000000000402B60) ----------------------------------------------------
void __fastcall __noreturn _assert_fail(__int64 a1, __int64 a2, unsigned int a3, unsigned __int8 *a4)
{
  unsigned __int8 *v6; // rax
  __int64 v7; // r9
  int v8; // [rsp+0h] [rbp-28h]
  __int64 v9; // [rsp+8h] [rbp-20h]

  v6 = dcgettext("libc", "%s%s%s:%u: %s%sAssertion `%s' failed.\n%n", 5u);
  _assert_fail_base((unsigned __int64)v6, a1, a2, a3, a4, v7, v8, v9);
}
// 402BA1: variable 'v7' is possibly undefined
// 402BA1: variable 'v8' is possibly undefined
// 402BA1: variable 'v9' is possibly undefined

//----- (0000000000402BB0) ----------------------------------------------------
unsigned __int8 *__fastcall dcgettext(char *a1, unsigned __int8 *a2, unsigned int a3)
{
  return _dcigettext(a1, a2, 0LL, 0, 0LL, a3);
}

//----- (0000000000402BD0) ----------------------------------------------------
__int64 __fastcall plural_eval(_DWORD *a1, __int64 a2)
{
  _DWORD *v2; // rbx
  int v3; // eax
  bool v4; // cc
  __int64 v5; // rbp
  int v7; // eax
  int v8; // eax
  __int64 v9; // rax

  v2 = a1;
  v3 = *a1;
  v4 = *a1 <= 1;
  if ( *a1 == 1 )
    return plural_eval(*((_DWORD **)v2 + 1), a2) == 0;
  while ( 1 )
  {
    if ( v4 )
    {
      if ( v3 )
        return 0LL;
      v7 = v2[1];
      v5 = a2;
      if ( !v7 )
        return v5;
      if ( v7 != 1 )
        return 0LL;
      return *((_QWORD *)v2 + 1);
    }
    if ( v3 == 2 )
      break;
    if ( v3 != 3 )
      return 0LL;
    v2 = *(_DWORD **)&v2[2 * (plural_eval(*((_DWORD **)v2 + 1), a2) == 0) + 4];
    v3 = *v2;
    v4 = *v2 <= 1;
    if ( *v2 == 1 )
      return plural_eval(*((_DWORD **)v2 + 1), a2) == 0;
  }
  v5 = plural_eval(*((_DWORD **)v2 + 1), a2);
  v8 = v2[1];
  if ( v8 == 15 )
  {
    if ( v5 )
      return 1LL;
    return plural_eval(*((_DWORD **)v2 + 2), a2) != 0;
  }
  if ( v8 != 14 )
  {
    plural_eval(*((_DWORD **)v2 + 2), a2);
    v9 = (unsigned int)(v2[1] - 3);
    if ( (unsigned int)v9 <= 0xA )
      __asm { jmp     rax }
    return 0LL;
  }
  if ( v5 )
    return plural_eval(*((_DWORD **)v2 + 2), a2) != 0;
  return v5;
}

//----- (0000000000402DB0) ----------------------------------------------------
__int64 __fastcall transcmp(__int64 a1, __int64 a2)
{
  __int64 v4; // rsi
  __int64 v5; // rdi
  __int64 result; // rax

  if ( *(_QWORD *)(a2 + 32) )
    v4 = a2 + 56;
  else
    v4 = *(_QWORD *)(a2 + 56);
  v5 = a1 + 56;
  if ( !*(_QWORD *)(a1 + 32) )
    v5 = *(_QWORD *)(a1 + 56);
  result = j_strcmp_ifunc(v5, v4);
  if ( !(_DWORD)result )
  {
    result = j_strcmp_ifunc(*(_QWORD *)a1, *(_QWORD *)a2);
    if ( !(_DWORD)result )
    {
      result = j_strcmp_ifunc(*(_QWORD *)(a1 + 16), *(_QWORD *)(a2 + 16));
      if ( !(_DWORD)result )
        return (unsigned int)(*(_DWORD *)(a1 + 8) - *(_DWORD *)(a2 + 8));
    }
  }
  return result;
}
// 4010A0: using guessed type __int64 __fastcall j_strcmp_ifunc(_QWORD, _QWORD);

//----- (0000000000402E30) ----------------------------------------------------
unsigned __int64 __fastcall plural_lookup_isra_2(__int64 a1, __int64 a2, unsigned __int64 a3, __int64 a4)
{
  unsigned __int64 v6; // rax
  unsigned __int64 v7; // rbx
  unsigned __int64 v8; // rdi
  unsigned __int64 v9; // rbp

  v6 = plural_eval(*(_DWORD **)(a1 + 184), a2);
  if ( v6 < *(_QWORD *)(a1 + 192) )
  {
    v7 = v6;
    v8 = a3;
    v9 = a3 + a4;
    while ( --v7 != -1LL )
    {
      v8 = j_rawmemchr(v8, 0LL) + 1;
      if ( v8 >= v9 )
        return a3;
    }
    return v8;
  }
  return a3;
}
// 401038: using guessed type __int64 __fastcall j_rawmemchr(_QWORD, _QWORD);

//----- (0000000000402EA0) ----------------------------------------------------
__int64 __fastcall nl_find_msg(__int64 a1, __off_t a2, unsigned __int8 *a3, unsigned int a4, u32 *a5)
{
  unsigned __int64 v5; // r9
  __int64 *v6; // r12
  bool v7; // zf
  unsigned int v8; // eax
  unsigned int v9; // esi
  int v10; // er8
  __int64 v11; // rcx
  unsigned int v12; // edx
  unsigned int v13; // er13
  __int64 *v14; // r15
  unsigned int v15; // er11
  int v16; // er12
  unsigned int v17; // ebx
  unsigned int v18; // er14
  unsigned __int32 v19; // eax
  unsigned __int64 v20; // r14
  unsigned int *v21; // rdi
  unsigned int v22; // eax
  __int64 v23; // rax
  __int64 v24; // rsi
  __int64 v25; // rsi
  int v26; // eax
  u32 *v27; // r8
  unsigned __int64 v28; // r9
  unsigned __int64 v29; // r15
  __int64 v30; // rax
  __int64 *v31; // rbx
  __int64 v32; // rdx
  unsigned __int64 v34; // r15
  unsigned __int64 v35; // rbx
  __int64 v36; // r13
  __int64 v37; // r14
  unsigned __int64 v38; // r13
  unsigned __int64 v39; // rbx
  __int64 v40; // rsi
  unsigned __int32 v41; // eax
  int v42; // eax
  unsigned int v43; // eax
  unsigned __int64 *v44; // rax
  __int64 v45; // rbx
  unsigned int *v46; // rdx
  __int64 v47; // rax
  unsigned int v48; // edx
  __int64 v49; // r14
  __int64 v50; // rcx
  __int64 v51; // rbx
  _QWORD *v52; // r12
  __int64 v53; // r14
  __int64 v54; // rcx
  __int64 v55; // rax
  unsigned __int8 **v56; // rax
  __int64 v57; // r13
  _QWORD *v58; // r12
  __int64 v59; // rbx
  __int64 v60; // rdx
  __int64 v61; // rcx
  char *v62; // rax
  char *v63; // r14
  __int64 v65; // r14
  int v66; // er15
  unsigned __int64 v67; // rcx
  __int64 v68; // r13
  __int64 *v69; // rbx
  __int64 v70; // rcx
  __int64 v71; // r12
  __int64 *v72; // rax
  __int64 v73; // rdx
  __int64 v74; // rcx
  int v75; // eax
  __int64 v76; // rdx
  __int64 v77; // r14
  __int64 *v78; // rdx
  char *v79; // r13
  __int64 v80; // rdi
  __off_t v81; // rsi
  __int64 *v82; // rax
  __int64 msg; // rax
  __int64 v84; // rax
  __int64 v85; // rax
  __int64 *v86; // r8
  __int64 *v87; // rdx
  void *v88; // rsp
  char *v89; // r14
  _BYTE *v90; // rax
  unsigned __int64 v91; // rdi
  __int64 *v92; // rcx
  char *i; // rax
  char v94; // dl
  __int64 v95; // rdx
  char *v96; // rsi
  __int16 v97; // dx
  signed __int64 v98; // rax
  void *v99; // rsp
  __int64 v100; // rax
  char *v101; // rsi
  char *v102; // rdx
  __int64 *v103; // rax
  unsigned __int64 j; // rdi
  char v105; // dl
  __int64 v106; // rdx
  char *v107; // rsi
  __int16 v108; // dx
  signed __int64 v109; // rax
  void *v110; // rsp
  __int64 v111; // rax
  char *v112; // rdx
  int v113; // eax
  unsigned __int64 v114; // r13
  _QWORD *v115; // rdx
  __int64 v116; // rcx
  u32 *v117; // r8
  __int64 v118; // r9
  _QWORD *v119; // rax
  __int64 v120; // rdx
  __int64 v121; // rax
  __int64 v122; // rbx
  __int64 v123; // r15
  char *v124; // rcx
  __int64 v125; // rsi
  unsigned __int64 v126; // rax
  __int64 v127; // rcx
  __int64 v128; // rdx
  u32 *v129; // rax
  char v131[4096]; // [rsp+8h] [rbp-30B0h] BYREF
  char v132[4096]; // [rsp+1008h] [rbp-20B0h] BYREF
  _BYTE v133[15]; // [rsp+2008h] [rbp-10B0h] BYREF
  __int64 v134; // [rsp+3008h] [rbp-B0h] BYREF
  u32 *v135; // [rsp+3010h] [rbp-A8h]
  unsigned int v136; // [rsp+301Ch] [rbp-9Ch]
  __off_t v137; // [rsp+3020h] [rbp-98h]
  __int64 v138; // [rsp+3028h] [rbp-90h]
  __int64 v139; // [rsp+3030h] [rbp-88h]
  __int64 v140; // [rsp+3038h] [rbp-80h]
  unsigned __int64 v141; // [rsp+3040h] [rbp-78h]
  __int64 *v142; // [rsp+3048h] [rbp-70h]
  _QWORD *v143; // [rsp+3050h] [rbp-68h]
  char *v144; // [rsp+3058h] [rbp-60h]
  unsigned __int8 *v145; // [rsp+3060h] [rbp-58h]
  __int64 v146; // [rsp+3068h] [rbp-50h] BYREF
  __int64 *v147; // [rsp+3070h] [rbp-48h] BYREF
  char v148[8]; // [rsp+3078h] [rbp-40h] BYREF
  unsigned __int64 v149; // [rsp+3080h] [rbp-38h]

  v140 = a1;
  v5 = *(unsigned int *)(a1 + 8);
  v137 = a2;
  v145 = a3;
  v136 = a4;
  v135 = a5;
  v149 = __readfsqword(0x28u);
  if ( (int)v5 <= 0 )
    nl_load_domain(a1, a2, (__int64)a3, 0LL, a5, v5);
  v6 = *(__int64 **)(v140 + 16);
  if ( !v6 )
    return 0LL;
  v7 = v6[12] == 0;
  LODWORD(v144) = *((_DWORD *)v6 + 10);
  if ( !v7 )
  {
    LODWORD(v142) = j_strlen_ifunc(v145);
    v8 = _hash_string(v145);
    v9 = *((_DWORD *)v6 + 22);
    v10 = *((_DWORD *)v6 + 26);
    v11 = v6[12];
    v141 = (unsigned int)v142;
    v12 = v8 % (v9 - 2) + 1;
    LODWORD(v143) = v9 - v12;
    v13 = v8 % v9;
    v14 = v6;
    v15 = v12 - v9;
    v16 = v10;
    v17 = v12;
    while ( 1 )
    {
      v18 = *(_DWORD *)(v11 + 4LL * v13);
      v19 = _byteswap_ulong(v18);
      if ( v16 )
        v18 = v19;
      if ( !v18 )
        return 0LL;
      v20 = v18 - 1;
      if ( (unsigned int)v144 <= (unsigned int)v20 )
      {
        v44 = (unsigned __int64 *)(v14[9] + 16LL * (unsigned int)(v20 - (_DWORD)v144));
        if ( *v44 <= v141 )
          goto LABEL_37;
        LODWORD(v138) = v15;
        v25 = v44[1];
        v139 = v11;
      }
      else
      {
        v21 = (unsigned int *)(v14[6] + 8 * v20);
        v22 = *v21;
        if ( *((_DWORD *)v14 + 6) )
        {
          if ( (unsigned int)v142 > _byteswap_ulong(v22) )
            goto LABEL_37;
          v23 = *v14;
          v24 = _byteswap_ulong(v21[1]);
        }
        else
        {
          if ( (unsigned int)v142 > v22 )
            goto LABEL_37;
          v23 = *v14;
          v24 = v21[1];
        }
        LODWORD(v138) = v15;
        v25 = v23 + v24;
        v139 = v11;
      }
      v26 = j_strcmp_ifunc(v145, v25);
      v11 = v139;
      v15 = v138;
      if ( !v26 )
      {
        v6 = v14;
        v29 = v20;
        v141 = (unsigned int)v144;
        goto LABEL_16;
      }
LABEL_37:
      v43 = v13 + v15;
      if ( (unsigned int)v143 > v13 )
        v43 = v13 + v17;
      v13 = v43;
    }
  }
  v34 = 0LL;
  v141 = (unsigned int)v144;
  v35 = (unsigned int)v144;
  while ( 1 )
  {
    if ( v35 <= v34 )
      return 0LL;
    v36 = v6[6];
    v143 = (_QWORD *)*v6;
    v37 = v36;
    v38 = v35;
    LODWORD(v142) = *((_DWORD *)v6 + 6);
    while ( 1 )
    {
      v39 = (v34 + v38) >> 1;
      v40 = *(unsigned int *)(v37 + 8 * v39 + 4);
      v41 = _byteswap_ulong(*(_DWORD *)(v37 + 8 * v39 + 4));
      if ( (_DWORD)v142 )
        v40 = v41;
      v25 = (__int64)v143 + v40;
      v42 = j_strcmp_ifunc(v145, v25);
      if ( v42 >= 0 )
        break;
      v38 = (v34 + v38) >> 1;
      if ( v34 >= v39 )
        return 0LL;
    }
    v35 = v38;
    if ( !v42 )
      break;
    v34 = ((v34 + v38) >> 1) + 1;
  }
  v29 = (v34 + v38) >> 1;
LABEL_16:
  if ( v29 < v141 )
  {
    v45 = *v6;
    v46 = (unsigned int *)(v6[7] + 8 * v29);
    v47 = v46[1];
    v48 = *v46;
    if ( *((_DWORD *)v6 + 6) )
    {
      v48 = _byteswap_ulong(v48);
      v31 = (__int64 *)(_byteswap_ulong(v47) + v45);
    }
    else
    {
      v31 = (__int64 *)(v47 + v45);
    }
    v145 = (unsigned __int8 *)(v48 + 1);
  }
  else
  {
    v30 = v6[10] + 16 * (v29 - v141);
    v31 = *(__int64 **)(v30 + 8);
    v145 = *(unsigned __int8 **)v30;
  }
  v32 = v136;
  if ( !v136 )
  {
LABEL_19:
    *(_QWORD *)v135 = v145;
    return (__int64)v31;
  }
  if ( !v137 || (v143 = *(_QWORD **)(v137 + 16)) == 0LL )
  {
    if ( output_charset_cached_11676 )
    {
      v143 = (_QWORD *)output_charset_cache_11675;
    }
    else
    {
      v62 = getenv("OUTPUT_CHARSET");
      v63 = v62;
      if ( v62 && *v62 )
      {
        v114 = j_strlen_ifunc(v62) + 1;
        v119 = malloc(v114, v25, v115, v116, v117, v118);
        v143 = v119;
        if ( v119 )
        {
          v25 = (__int64)v63;
          j_memcpy(v119, v63, v114);
        }
        output_charset_cache_11675 = (__int64)v143;
      }
      else
      {
        v143 = (_QWORD *)output_charset_cache_11675;
      }
      output_charset_cached_11676 = 1;
    }
    if ( !v143 )
      v143 = *(_QWORD **)(*(_QWORD *)__readfsqword(0xFFFFFFA0) + 176LL);
  }
  v49 = v6[15];
  if ( !v49 )
  {
LABEL_66:
    v57 = v6[15];
    v54 = v6[14];
    v139 = v54;
    if ( v57 )
    {
      v142 = v6;
      v138 = v57;
      v141 = (unsigned __int64)v31;
      v58 = (_QWORD *)(v54 + 24 * v57 - 24);
      v59 = v57;
      do
      {
        v25 = (__int64)v143;
        --v59;
        v53 = (__int64)v58;
        if ( !(unsigned int)j_strcmp_ifunc(*v58, v143) )
          goto LABEL_54;
        v58 -= 3;
      }
      while ( v59 );
      v6 = v142;
      v57 = v138;
      v31 = (__int64 *)v141;
    }
    v77 = 3 * v57 + 3;
    if ( v139 )
    {
      v25 = 8 * (3 * v57 + 3);
      v78 = realloc(v139, v25, (_QWORD *)v32, v54, v27, v28);
    }
    else
    {
      v78 = malloc(8 * (3 * v57 + 3), v25, (_QWORD *)v32, v54, v27, v28);
    }
    if ( !v78 )
      return -1LL;
    v6[14] = (__int64)v78;
    v142 = v78;
    v79 = (char *)strdup((__int64)v143, v25);
    if ( !v79 )
      return -1LL;
    v80 = v140;
    v81 = v137;
    v82 = &v142[v77 - 3];
    *v82 = (__int64)v79;
    v82[1] = -1LL;
    v143 = v82;
    msg = nl_find_msg(v80, v81, byte_493255, 0, (u32 *)v148);
    if ( msg != -1 )
    {
      if ( !msg )
        goto LABEL_133;
      v84 = j_strstr(msg, "charset=");
      if ( !v84 )
        goto LABEL_133;
      v142 = (__int64 *)(v84 + 8);
      v85 = j_strcspn_ifunc(v84 + 8, " \t\n");
      v86 = v142;
      v87 = (__int64 *)((char *)&v134 - ((v85 + 24) & 0xFFFFFFFFFFFFF000LL));
      if ( &v134 != v87 )
      {
        while ( v133 != (_BYTE *)v87 )
          ;
      }
      if ( (((_WORD)v85 + 24) & 0xFF0) != 0 )
      {
        v88 = alloca(((_WORD)v85 + 24) & 0xFF0);
        *(_QWORD *)&v132[(((_WORD)v85 + 24) & 0xFF0) + 4088] = *(_QWORD *)&v132[(((_WORD)v85 + 24) & 0xFF0) + 4088];
      }
      v89 = v133;
      v142 = (__int64 *)v133;
      v90 = (_BYTE *)j_mempcpy(v133, v86, v85);
      v91 = 0LL;
      v92 = v142;
      *v90 = 0;
      for ( i = v79; ; ++i )
      {
        v94 = *i;
        if ( !*i )
          break;
        v91 += v94 == 47;
      }
      v95 = i - v79 + 34;
      v96 = &v133[-(v95 & 0xFFFFFFFFFFFFF000LL)];
      v97 = v95 & 0xFFF0;
      if ( v133 != v96 )
      {
        while ( v132 != v96 )
          ;
      }
      v98 = v97 & 0xFFF;
      if ( (v97 & 0xFFF) != 0 )
      {
        v99 = alloca(v98);
        *(_QWORD *)&v131[v98 + 4088] = *(_QWORD *)&v131[v98 + 4088];
      }
      v100 = *v79;
      if ( (_BYTE)v100 )
      {
        v101 = v79;
        v102 = v132;
        do
        {
          ++v101;
          *v102++ = dword_4866E0[v100];
          v100 = *v101;
        }
        while ( (_BYTE)v100 );
      }
      else
      {
        v102 = v132;
      }
      if ( v91 <= 1 )
      {
        *v102 = 47;
        if ( v91 )
        {
          ++v102;
        }
        else
        {
          v102[1] = 47;
          v102 += 10;
          *((_QWORD *)v102 - 1) = 0x54494C534E415254LL;
        }
      }
      *v102 = 0;
      v103 = v92;
      for ( j = 0LL; ; j += v105 == 47 )
      {
        v105 = *(_BYTE *)v103;
        if ( !*(_BYTE *)v103 )
          break;
        v103 = (__int64 *)((char *)v103 + 1);
      }
      v106 = (char *)v103 - (char *)v92 + 26;
      v107 = &v132[-(v106 & 0xFFFFFFFFFFFFF000LL)];
      v108 = v106 & 0xFFF0;
      if ( v132 != v107 )
      {
        while ( v131 != v107 )
          ;
      }
      v109 = v108 & 0xFFF;
      if ( (v108 & 0xFFF) != 0 )
      {
        v110 = alloca(v109);
        *(_QWORD *)&v131[v109 - 8] = *(_QWORD *)&v131[v109 - 8];
      }
      v111 = *(char *)v92;
      if ( (_BYTE)v111 )
      {
        v112 = v131;
        do
        {
          ++v89;
          *v112++ = dword_4866E0[v111];
          v111 = *v89;
        }
        while ( (_BYTE)v111 );
      }
      else
      {
        v112 = v131;
      }
      if ( j <= 1 )
      {
        *v112 = 47;
        if ( j )
        {
          ++v112;
        }
        else
        {
          v112[1] = 47;
          v112 += 2;
        }
      }
      *v112 = 0;
      v113 = _gconv_open(v132, v131, v143 + 1, 1);
      if ( !v113 )
        goto LABEL_133;
      if ( v113 == -1 )
      {
        v143[1] = -1LL;
LABEL_133:
        v143[2] = 0LL;
        ++v6[15];
        goto LABEL_55;
      }
      free((__int64)v79, (__int64)v131, v32, v54, v27, v28);
      return 0LL;
    }
    return msg;
  }
  v50 = v6[14];
  v142 = v6;
  v141 = (unsigned __int64)v31;
  v51 = v49;
  v52 = (_QWORD *)(v50 + 24 * v49 - 24);
  while ( 1 )
  {
    v25 = (__int64)v143;
    --v51;
    v53 = (__int64)v52;
    if ( !(unsigned int)j_strcmp_ifunc(*v52, v143) )
      break;
    v52 -= 3;
    if ( !v51 )
    {
      v6 = v142;
      v31 = (__int64 *)v141;
      goto LABEL_66;
    }
  }
LABEL_54:
  v6 = v142;
  v31 = (__int64 *)v141;
  v143 = (_QWORD *)v53;
LABEL_55:
  if ( v143[1] == -1LL )
    goto LABEL_19;
  v55 = v143[2];
  if ( !v55 )
  {
    _RSI = 1LL;
    if ( _libc_multiple_threads )
    {
      if ( !_InterlockedCompareExchange(&lock_11628, 1, 0) )
      {
LABEL_139:
        if ( !v143[2] )
        {
          _RSI = 8LL;
          v129 = calloc((unsigned int)(*((_DWORD *)v6 + 16) + (_DWORD)v144), 8uLL, v32, v54, v27, v28);
          if ( v129 )
          {
            v143[2] = v129;
            goto LABEL_87;
          }
          v143[2] = -1LL;
        }
        if ( _libc_multiple_threads )
        {
          if ( !_InterlockedDecrement(&lock_11628) )
            goto LABEL_145;
        }
        else if ( !--lock_11628 )
        {
LABEL_145:
          v55 = v143[2];
          goto LABEL_57;
        }
        _lll_unlock_wake_private((u32 *)&lock_11628, _RSI, v32, v54, v27, v28);
        goto LABEL_145;
      }
    }
    else
    {
      __asm { cmpxchg cs:lock_11628, esi }
      if ( !_libc_multiple_threads )
        goto LABEL_139;
    }
    _lll_lock_wait_private((u32 *)&lock_11628, 1LL, v32, v54, v27, v28);
    goto LABEL_139;
  }
LABEL_57:
  if ( v55 == -1 )
    return -1LL;
  v56 = *(unsigned __int8 ***)(v55 + 8 * v29);
  if ( v56 )
  {
LABEL_59:
    v31 = (__int64 *)(v56 + 1);
    v145 = *v56;
    goto LABEL_19;
  }
  _RSI = 1LL;
  if ( _libc_multiple_threads )
  {
    if ( !_InterlockedCompareExchange(&lock_11628, 1, 0) )
      goto LABEL_87;
    goto LABEL_86;
  }
  __asm { cmpxchg cs:lock_11628, esi }
  if ( _libc_multiple_threads )
LABEL_86:
    _lll_lock_wait_private((u32 *)&lock_11628, 1LL, v32, v54, v27, v28);
LABEL_87:
  v65 = (__int64)v143;
  v140 = v29;
  v146 = (__int64)v31;
  v66 = 0;
  v67 = freemem_size_11636;
  v68 = (__int64)v31;
  v147 = (__int64 *)(freemem_11635 + 8);
  v144 = v148;
  v142 = (__int64 *)&v147;
  v141 = (unsigned __int64)&v146;
  while ( 1 )
  {
    if ( v67 <= 7 )
      goto LABEL_95;
    _RSI = v141;
    v75 = _gconv(
            *(_QWORD **)(v65 + 8),
            (__int64 *)v141,
            (unsigned __int64)&v145[v146],
            v142,
            (__int64)v147 + v67 - 8,
            v144);
    if ( (v75 & 0xFFFFFFFB) == 0 )
    {
      v120 = (__int64)v147;
      v121 = freemem_11635;
      v122 = (__int64)v143;
      v123 = v140;
      v124 = (char *)v147 - freemem_11635;
      *(_QWORD *)freemem_11635 = (char *)v147 - freemem_11635 - 8;
      v125 = *(_QWORD *)(v122 + 16);
      *(_QWORD *)(v125 + 8 * v123) = v121;
      v126 = (freemem_size_11636 - (_QWORD)v124) & 0xFFFFFFFFFFFFFFF8LL;
      v127 = ((_BYTE)freemem_size_11636 - (_BYTE)v124) & 7;
      freemem_size_11636 = v126;
      v128 = v127 + v120;
      freemem_11635 = v128;
      if ( _libc_multiple_threads )
      {
        if ( !_InterlockedDecrement(&lock_11628) )
          goto LABEL_156;
      }
      else if ( !--lock_11628 )
      {
LABEL_156:
        v56 = *(unsigned __int8 ***)(*(_QWORD *)(v122 + 16) + 8 * v123);
        goto LABEL_59;
      }
      _lll_unlock_wake_private((u32 *)&lock_11628, v125, v128, v127, v27, v28);
      goto LABEL_156;
    }
    if ( v75 != 5 )
      break;
    v146 = v68;
LABEL_95:
    if ( v66 )
    {
      ++v66;
      v69 = (__int64 *)transmem_list;
      v70 = (unsigned int)(4080 * v66);
      v71 = (int)v70;
      _RSI = (int)v70;
      freemem_size_11636 = (int)v70;
      v72 = realloc(transmem_list, (int)v70, (_QWORD *)v32, v70, v27, v28);
      if ( v72 )
      {
        transmem_list = (__int64)v72;
        v67 = v71 - 8;
        goto LABEL_90;
      }
      transmem_list = *v69;
      free((__int64)v69, _RSI, v73, v74, v27, v28);
LABEL_72:
      freemem_11635 = 0LL;
      freemem_size_11636 = 0LL;
      if ( _libc_multiple_threads )
      {
        if ( !_InterlockedDecrement(&lock_11628) )
          return -1LL;
      }
      else if ( !--lock_11628 )
      {
        return -1LL;
      }
      _lll_unlock_wake_private((u32 *)&lock_11628, _RSI, v60, v61, v27, v28);
      return -1LL;
    }
    freemem_size_11636 = 4080LL;
    v72 = malloc(0xFF0uLL, _RSI, (_QWORD *)v32, v67, v27, v28);
    if ( !v72 )
      goto LABEL_72;
    v76 = transmem_list;
    v67 = 4072LL;
    transmem_list = (__int64)v72;
    v66 = 1;
    *v72 = v76;
LABEL_90:
    v32 = (__int64)(v72 + 1);
    freemem_size_11636 = v67;
    freemem_11635 = (__int64)(v72 + 1);
    v147 = v72 + 2;
  }
  if ( _libc_multiple_threads )
  {
    if ( !_InterlockedDecrement(&lock_11628) )
      return 0LL;
  }
  else if ( !--lock_11628 )
  {
    return 0LL;
  }
  _lll_unlock_wake_private((u32 *)&lock_11628, _RSI, v32, v67, v27, v28);
  return 0LL;
}
// 403080: variable 'v32' is possibly undefined
// 403080: variable 'v67' is possibly undefined
// 403080: variable 'v27' is possibly undefined
// 403080: variable 'v28' is possibly undefined
// 403406: variable 'v73' is possibly undefined
// 403406: variable 'v74' is possibly undefined
// 40344B: variable 'v60' is possibly undefined
// 40344B: variable 'v61' is possibly undefined
// 4034CB: variable 'v54' is possibly undefined
// 403974: variable 'v115' is possibly undefined
// 403974: variable 'v116' is possibly undefined
// 403974: variable 'v117' is possibly undefined
// 403974: variable 'v118' is possibly undefined
// 401040: using guessed type __int64 __fastcall j_memcpy(_QWORD, _QWORD, _QWORD);
// 401070: using guessed type __int64 __fastcall j_strstr(_QWORD, _QWORD);
// 4010A0: using guessed type __int64 __fastcall j_strcmp_ifunc(_QWORD, _QWORD);
// 4010B0: using guessed type __int64 __fastcall j_mempcpy(_QWORD, _QWORD, _QWORD);
// 4010B8: using guessed type __int64 __fastcall j_strcspn_ifunc(_QWORD, _QWORD);
// 4010C8: using guessed type __int64 __fastcall j_strlen_ifunc(_QWORD);
// 4866E0: using guessed type unsigned int dword_4866E0[256];
// 493255: using guessed type unsigned __int8 byte_493255[1707];
// 4AA7B8: using guessed type __int64 output_charset_cache_11675;
// 4AA7C0: using guessed type int output_charset_cached_11676;
// 4AA7C8: using guessed type __int64 freemem_size_11636;
// 4AA7D0: using guessed type __int64 freemem_11635;
// 4AA7D8: using guessed type int lock_11628;
// 4AA7E0: using guessed type __int64 transmem_list;
// 4AB820: using guessed type int _libc_multiple_threads;
// 402EA0: using guessed type char var_40[8];

//----- (0000000000403B40) ----------------------------------------------------
unsigned __int8 *__fastcall _dcigettext(char *a1, unsigned __int8 *a2, __int64 a3, int a4, __int64 a5, unsigned int a6)
{
  char *v6; // r13
  _QWORD *v7; // rax
  __off_t v8; // rbx
  char *v9; // r12
  const char *v10; // r14
  char *v11; // rax
  __int64 v12; // rdx
  __int64 *v13; // rcx
  __int16 v14; // dx
  unsigned int v15; // edx
  void *v16; // rsp
  _WORD *v17; // rax
  __int64 v18; // rdx
  __int64 v19; // rax
  u32 *v20; // r8
  unsigned __int64 v21; // r9
  __int16 v22; // dx
  __int64 *v23; // rax
  __int64 v24; // rdx
  void *v25; // rsp
  char *v26; // r12
  char v27; // al
  bool v28; // cf
  bool v29; // zf
  __int64 v30; // rcx
  const char *v31; // rsi
  const char *v32; // rdi
  char v33; // al
  bool v34; // cf
  bool v35; // zf
  const char *v36; // rdi
  __int64 *domain; // rax
  __int64 *v38; // r15
  __int64 msg; // rax
  unsigned __int8 *v40; // r8
  __int64 v41; // rax
  __int64 v42; // rdx
  int v44; // eax
  _QWORD *v45; // rdx
  __int64 v46; // rcx
  u32 *v47; // r8
  __int64 v48; // r9
  char *v49; // rax
  __int64 v50; // r12
  int v51; // er14
  __int64 v52; // rdx
  __int64 v53; // rcx
  u32 *v54; // r8
  unsigned __int64 v55; // r9
  __int64 v56; // rdi
  __int64 v57; // r13
  u32 *v58; // r12
  int v59; // er14
  __int64 v60; // rax
  __int64 v61; // rax
  __int64 v62; // rbx
  __int64 v63; // rax
  __int64 v64; // r14
  _QWORD *v65; // rdx
  __int64 v66; // rcx
  u32 *v67; // r8
  __int64 v68; // r9
  _QWORD *v69; // rax
  __int64 v70; // r12
  __int64 v71; // r14
  __int64 v72; // rbx
  __int64 v73; // r14
  int v74; // eax
  unsigned __int8 *v75; // r8
  int v76; // eax
  __int64 v77; // rax
  __int64 v78; // rcx
  __int64 v79; // r9
  _QWORD *v80; // rax
  __int64 v81; // rdx
  __int64 v82; // rcx
  unsigned __int64 v83; // r9
  __int64 v84; // [rsp+0h] [rbp-2108h]
  __int64 v85; // [rsp+8h] [rbp-2100h] BYREF
  _BYTE v86[4088]; // [rsp+10h] [rbp-20F8h] BYREF
  __int64 v87; // [rsp+1008h] [rbp-1100h] BYREF
  _BYTE v88[7]; // [rsp+1010h] [rbp-10F8h] BYREF
  char *v89; // [rsp+2008h] [rbp-100h] BYREF
  const char *v90; // [rsp+2010h] [rbp-F8h]
  char *v91; // [rsp+2018h] [rbp-F0h]
  __int64 v92; // [rsp+2020h] [rbp-E8h]
  __int64 v93; // [rsp+2028h] [rbp-E0h]
  unsigned int v94; // [rsp+2034h] [rbp-D4h]
  unsigned __int64 v95; // [rsp+2038h] [rbp-D0h]
  __int64 v96; // [rsp+2040h] [rbp-C8h]
  __int64 v97; // [rsp+2048h] [rbp-C0h]
  u32 *v98; // [rsp+2050h] [rbp-B8h]
  int v99; // [rsp+2058h] [rbp-B0h]
  int v100; // [rsp+205Ch] [rbp-ACh]
  _BYTE *v101; // [rsp+2060h] [rbp-A8h]
  char *v102; // [rsp+2068h] [rbp-A0h]
  unsigned __int8 *v103; // [rsp+2070h] [rbp-98h]
  const char *v104; // [rsp+2078h] [rbp-90h] BYREF
  __int64 v105; // [rsp+2080h] [rbp-88h] BYREF
  char *v106; // [rsp+2088h] [rbp-80h] BYREF
  int v107; // [rsp+2090h] [rbp-78h]
  __int64 v108; // [rsp+2098h] [rbp-70h]
  __int64 v109; // [rsp+20A8h] [rbp-60h]
  unsigned __int8 *v110; // [rsp+20C0h] [rbp-48h]
  unsigned __int64 v111; // [rsp+20D0h] [rbp-38h]

  v103 = a2;
  v96 = a3;
  v99 = a4;
  v97 = a5;
  v100 = a6;
  v111 = __readfsqword(0x28u);
  v104 = 0LL;
  if ( !a2 )
    return 0LL;
  if ( a6 > 0xC || a6 == 6 )
  {
    if ( v99 && v97 != 1 )
      return (unsigned __int8 *)v96;
    return v103;
  }
  v6 = a1;
  v94 = __readfsdword(0xFFFFFFC0);
  if ( !a1 )
    v6 = nl_current_default_domain;
  v109 = 0LL;
  v110 = v103;
  v106 = v6;
  v107 = v100;
  v93 = _current_locale_name(v100);
  v108 = v93;
  v95 = tfind((__int64)&v106, &root, transcmp);
  if ( v95 )
  {
    v7 = *(_QWORD **)v95;
    if ( *(_DWORD *)(*(_QWORD *)v95 + 24LL) == nl_msg_cat_cntr )
    {
      v40 = (unsigned __int8 *)v7[5];
      if ( v99 )
        v40 = (unsigned __int8 *)plural_lookup_isra_2(*(_QWORD *)(v7[4] + 16LL), v97, (unsigned __int64)v40, v7[6]);
      __writefsdword(0xFFFFFFC0, v94);
      return v40;
    }
  }
  v8 = nl_domain_bindings;
  if ( !nl_domain_bindings )
  {
LABEL_9:
    v102 = "/usr/share/locale";
    goto LABEL_10;
  }
  while ( 1 )
  {
    v44 = j_strcmp_ifunc(v6, v8 + 24);
    if ( !v44 )
      break;
    if ( v44 < 0 )
    {
      v8 = 0LL;
      goto LABEL_9;
    }
    v8 = *(_QWORD *)v8;
    if ( !v8 )
      goto LABEL_9;
  }
  v29 = **(_BYTE **)(v8 + 8) == 47;
  v102 = *(char **)(v8 + 8);
  if ( v29 )
    goto LABEL_10;
  v31 = 0LL;
  v49 = getcwd(0LL, 0LL, v45, v46, v47, v48);
  v50 = (__int64)v49;
  if ( !v49
    || (v31 = "%s/%s",
        v51 = asprintf((__int64 *)&v104, (unsigned __int64)"%s/%s", v49, v102),
        free(v50, (__int64)"%s/%s", v52, v53, v54, v55),
        v51 < 0) )
  {
LABEL_56:
    free((__int64)v104, (__int64)v31, v24, v30, v20, v21);
    __writefsdword(0xFFFFFFC0, v94);
    if ( v97 != 1 && v99 )
      return (unsigned __int8 *)v96;
    return v103;
  }
  v102 = (char *)v104;
LABEL_10:
  v9 = &nl_category_names[nl_category_name_idxs[v100]];
  v10 = (const char *)_current_locale_name(v100);
  if ( strcmp(v10, "C") )
  {
    v11 = getenv("LANGUAGE");
    if ( v11 )
    {
      if ( *v11 )
        v10 = v11;
    }
  }
  v92 = j_strlen_ifunc(v6);
  v12 = v92 + j_strlen_ifunc(v9) + 28;
  v13 = (__int64 *)((char *)&v89 - (v12 & 0xFFFFFFFFFFFFF000LL));
  v14 = v12 & 0xFFF0;
  if ( &v89 != (char **)v13 )
  {
    while ( &v87 != v13 )
      ;
  }
  v15 = v14 & 0xFFF;
  if ( v15 )
  {
    v16 = alloca(v15);
    *(_QWORD *)&v86[v15 + 4080] = *(_QWORD *)&v86[v15 + 4080];
  }
  v101 = v88;
  v17 = (_WORD *)j_stpcpy(v88);
  v18 = v92;
  *v17 = 47;
  *(_DWORD *)j_mempcpy((char *)v17 + 1, v6, v18) = 7302446;
  v19 = j_strlen_ifunc(v10);
  v22 = (v19 + 24) & 0xFFF0;
  v23 = (__int64 *)&v88[-((v19 + 24) & 0xFFFFFFFFFFFFF000LL) - 8];
  if ( &v87 != v23 )
  {
    while ( &v85 != v23 )
      ;
  }
  v24 = v22 & 0xFFF;
  if ( (_DWORD)v24 )
  {
    v25 = alloca((unsigned int)v24);
    *(__int64 *)((char *)&v84 + (unsigned int)v24) = *(__int64 *)((char *)&v84 + (unsigned int)v24);
  }
  v98 = (u32 *)&v105;
  v26 = v86;
  while ( 1 )
  {
    do
    {
      do
      {
LABEL_23:
        while ( 1 )
        {
          v27 = *v10;
          if ( *v10 != 58 )
            break;
          ++v10;
        }
        v28 = 0;
        v29 = v27 == 0;
        if ( !v27 )
        {
          *(_WORD *)v26 = 67;
          break;
        }
        v24 = (__int64)v26;
        do
        {
          ++v10;
          *(_BYTE *)v24++ = v27;
          v27 = *v10;
        }
        while ( *v10 && v27 != 58 );
        *(_BYTE *)v24 = 0;
        v28 = 0;
        v29 = _libc_enable_secure == 0;
        if ( !_libc_enable_secure )
          break;
        v61 = j_strchr_ifunc(v26, 47LL);
        v28 = 0;
        v29 = v61 == 0;
      }
      while ( v61 );
      v30 = 2LL;
      v31 = v26;
      v32 = "C";
      do
      {
        if ( !v30 )
          break;
        v28 = *v31 < (unsigned int)*v32;
        v29 = *v31++ == *v32++;
        --v30;
      }
      while ( v29 );
      v33 = (!v28 && !v29) - v28;
      v34 = 0;
      v35 = v33 == 0;
      if ( !v33 )
        goto LABEL_56;
      v30 = 6LL;
      v31 = v26;
      v36 = "POSIX";
      do
      {
        if ( !v30 )
          break;
        v34 = *v31 < (unsigned int)*v36;
        v35 = *v31++ == *v36++;
        --v30;
      }
      while ( v35 );
      if ( (!v34 && !v35) == v34 )
        goto LABEL_56;
      domain = nl_find_domain((__int64)v102, (__int64)v26, (__int64)v101, v8);
      v38 = domain;
    }
    while ( !domain );
    v31 = (const char *)v8;
    msg = nl_find_msg((__int64)domain, v8, v103, 1u, v98);
    if ( msg )
      break;
    v56 = v38[4];
    if ( v56 )
    {
      v91 = v6;
      v89 = v26;
      v57 = 0LL;
      v58 = v98;
      v90 = v10;
      while ( 1 )
      {
        v31 = (const char *)v8;
        v59 = v57;
        v60 = nl_find_msg(v56, v8, v103, 1u, v58);
        if ( v60 == -1 )
          goto LABEL_56;
        if ( v60 )
        {
          v20 = (u32 *)v60;
          v6 = v91;
          v38 = (__int64 *)v38[v59 + 4];
          goto LABEL_37;
        }
        v56 = v38[++v57 + 4];
        if ( !v56 )
        {
          v10 = v90;
          v6 = v91;
          v26 = v89;
          goto LABEL_23;
        }
      }
    }
  }
  v20 = (u32 *)msg;
  if ( msg == -1 )
    goto LABEL_56;
LABEL_37:
  v102 = (char *)v20;
  free((__int64)v104, (__int64)v31, v24, v30, v20, v21);
  v40 = (unsigned __int8 *)v102;
  if ( v95 )
  {
    v41 = *(_QWORD *)v95;
    *(_DWORD *)(v41 + 24) = nl_msg_cat_cntr;
    v42 = v105;
    *(_QWORD *)(v41 + 32) = v38;
    *(_QWORD *)(v41 + 40) = v40;
    *(_QWORD *)(v41 + 48) = v42;
  }
  else
  {
    v62 = j_strlen_ifunc(v103) + 1;
    v63 = j_strlen_ifunc(v93);
    v64 = v92;
    v69 = malloc(v62 + v92 + v63 + 58, (__int64)v31, v65, v66, v67, v68);
    v40 = (unsigned __int8 *)v102;
    v70 = (__int64)v69;
    if ( v69 )
    {
      v71 = v64 + 1;
      v72 = j_mempcpy(v69 + 7, v103, v62);
      j_memcpy(v72, v6, v71);
      v73 = v72 + v71;
      strcpy_ifunc(v73, v93);
      v74 = v100;
      v75 = (unsigned __int8 *)v102;
      *(_QWORD *)v70 = v72;
      *(_QWORD *)(v70 + 16) = v73;
      *(_DWORD *)(v70 + 8) = v74;
      v76 = nl_msg_cat_cntr;
      *(_QWORD *)(v70 + 32) = v38;
      *(_DWORD *)(v70 + 24) = v76;
      v77 = v105;
      *(_QWORD *)(v70 + 40) = v75;
      *(_QWORD *)(v70 + 48) = v77;
      v103 = v75;
      v80 = tsearch(v70, &root, transcmp, v78, (u32 *)v75, v79);
      v40 = v103;
      if ( !v80 || *v80 != v70 )
      {
        free(v70, (__int64)&root, v81, v82, (u32 *)v103, v83);
        v40 = v103;
      }
    }
  }
  __writefsdword(0xFFFFFFC0, v94);
  if ( v99 )
    return (unsigned __int8 *)plural_lookup_isra_2(v38[2], v97, (unsigned __int64)v40, v105);
  return v40;
}
// 403ECD: variable 'v24' is possibly undefined
// 403ECD: variable 'v30' is possibly undefined
// 403ECD: variable 'v21' is possibly undefined
// 403FC2: variable 'v45' is possibly undefined
// 403FC2: variable 'v46' is possibly undefined
// 403FC2: variable 'v47' is possibly undefined
// 403FC2: variable 'v48' is possibly undefined
// 403FF8: variable 'v52' is possibly undefined
// 403FF8: variable 'v53' is possibly undefined
// 403FF8: variable 'v54' is possibly undefined
// 403FF8: variable 'v55' is possibly undefined
// 40409F: variable 'v20' is possibly undefined
// 4042AC: variable 'v65' is possibly undefined
// 4042AC: variable 'v66' is possibly undefined
// 4042AC: variable 'v67' is possibly undefined
// 4042AC: variable 'v68' is possibly undefined
// 404376: variable 'v78' is possibly undefined
// 404376: variable 'v79' is possibly undefined
// 4043BA: variable 'v81' is possibly undefined
// 4043BA: variable 'v82' is possibly undefined
// 4043BA: variable 'v83' is possibly undefined
// 401020: using guessed type __int64 __fastcall strcpy_ifunc(_QWORD, _QWORD);
// 401040: using guessed type __int64 __fastcall j_memcpy(_QWORD, _QWORD, _QWORD);
// 401058: using guessed type __int64 __fastcall j_stpcpy(_QWORD);
// 4010A0: using guessed type __int64 __fastcall j_strcmp_ifunc(_QWORD, _QWORD);
// 4010B0: using guessed type __int64 __fastcall j_mempcpy(_QWORD, _QWORD, _QWORD);
// 4010C8: using guessed type __int64 __fastcall j_strlen_ifunc(_QWORD);
// 4010D0: using guessed type __int64 __fastcall j_strchr_ifunc(_QWORD, _QWORD);
// 484F10: using guessed type unsigned __int8 nl_category_name_idxs[16];
// 4A7AD8: using guessed type int _libc_enable_secure;
// 4A80F0: using guessed type char *nl_current_default_domain;
// 4AA7E8: using guessed type __int64 root;
// 4AB800: using guessed type __int64 nl_domain_bindings;
// 4AB808: using guessed type int nl_msg_cat_cntr;

//----- (00000000004043D0) ----------------------------------------------------
__int64 *__fastcall nl_find_domain(__int64 a1, __int64 a2, __int64 a3, __off_t a4)
{
  unsigned __int8 *v6; // rbp
  __int64 v7; // rax
  __int64 v8; // rdx
  __int64 v9; // rcx
  u32 *v10; // r8
  unsigned __int64 v11; // r9
  __int64 *l10nflist; // r14
  __int64 v14; // rdi
  __int64 *v15; // rbx
  __int64 v16; // rcx
  __int64 v17; // rax
  unsigned __int64 v18; // r15
  _QWORD *v19; // rdx
  __int64 v20; // rcx
  u32 *v21; // r8
  __int64 v22; // r9
  unsigned __int8 *v23; // rax
  int v24; // er15
  __int64 v25; // rax
  __int64 v26; // rsi
  __int64 v27; // rdx
  __int64 v28; // rcx
  u32 *v29; // r8
  unsigned __int64 v30; // r9
  __int64 v31; // rdi
  __int64 *v32; // rbx
  __int64 v33; // [rsp+8h] [rbp-70h]
  unsigned __int8 *v34; // [rsp+10h] [rbp-68h] BYREF
  __int64 v35; // [rsp+18h] [rbp-60h] BYREF
  unsigned __int8 *v36; // [rsp+20h] [rbp-58h] BYREF
  __int64 v37; // [rsp+28h] [rbp-50h] BYREF
  __int64 v38[9]; // [rsp+30h] [rbp-48h] BYREF

  v6 = (unsigned __int8 *)a2;
  v38[1] = __readfsqword(0x28u);
  v7 = j_strlen_ifunc(a1);
  l10nflist = nl_make_l10nflist((__int64 **)&nl_loaded_domains, a1, v7 + 1, 0, a2, 0LL, 0LL, 0LL, 0LL, a3, 0);
  if ( l10nflist )
  {
    if ( *((int *)l10nflist + 2) <= 0 )
      nl_load_domain((__int64)l10nflist, a4, v8, v9, v10, v11);
    if ( !l10nflist[2] )
    {
      v14 = l10nflist[4];
      if ( v14 )
      {
        v15 = l10nflist + 4;
        do
        {
          v16 = *(unsigned int *)(v14 + 8);
          if ( (int)v16 <= 0 )
            nl_load_domain(v14, a4, v8, v16, v10, v11);
          if ( *(_QWORD *)(*v15 + 16) )
            break;
          v14 = *++v15;
        }
        while ( *v15 );
      }
    }
  }
  else
  {
    v17 = nl_expand_alias(a2, a1, v8, v9, v10, v11);
    v33 = v17;
    if ( v17 )
    {
      v18 = j_strlen_ifunc(v17) + 1;
      v23 = (unsigned __int8 *)malloc(v18, a1, v19, v20, v21, v22);
      v6 = v23;
      if ( !v23 )
        return l10nflist;
      j_memcpy(v23, v33, v18);
    }
    v24 = nl_explode_name(v6, &v34, &v35, &v36, &v37, v38);
    if ( v24 != -1 )
    {
      v25 = j_strlen_ifunc(a1);
      v26 = a1;
      l10nflist = nl_make_l10nflist(
                    (__int64 **)&nl_loaded_domains,
                    a1,
                    v25 + 1,
                    v24,
                    (__int64)v34,
                    (__int64)v36,
                    v37,
                    v38[0],
                    v35,
                    a3,
                    1);
      if ( l10nflist )
      {
        v27 = *((unsigned int *)l10nflist + 2);
        if ( (int)v27 <= 0 )
        {
          v26 = a4;
          nl_load_domain((__int64)l10nflist, a4, v27, v28, v29, v30);
        }
        if ( !l10nflist[2] )
        {
          v31 = l10nflist[4];
          if ( v31 )
          {
            v32 = l10nflist + 4;
            do
            {
              if ( *(int *)(v31 + 8) <= 0 )
              {
                v26 = a4;
                nl_load_domain(v31, a4, v27, v28, v29, v30);
              }
              if ( *(_QWORD *)(*v32 + 16) )
                break;
              v31 = *++v32;
            }
            while ( *v32 );
          }
        }
        if ( v33 )
          free((__int64)v6, v26, v27, v28, v29, v30);
      }
      if ( (v24 & 1) != 0 )
        free(v38[0], v26, v27, v28, v29, v30);
    }
  }
  return l10nflist;
}
// 4044E6: variable 'v8' is possibly undefined
// 4044E6: variable 'v9' is possibly undefined
// 4044E6: variable 'v10' is possibly undefined
// 4044E6: variable 'v11' is possibly undefined
// 404511: variable 'v19' is possibly undefined
// 404511: variable 'v20' is possibly undefined
// 404511: variable 'v21' is possibly undefined
// 404511: variable 'v22' is possibly undefined
// 404656: variable 'v28' is possibly undefined
// 404656: variable 'v29' is possibly undefined
// 404656: variable 'v30' is possibly undefined
// 4045ED: variable 'v27' is possibly undefined
// 401040: using guessed type __int64 __fastcall j_memcpy(_QWORD, _QWORD, _QWORD);
// 4010C8: using guessed type __int64 __fastcall j_strlen_ifunc(_QWORD);
// 4AA878: using guessed type __int64 nl_loaded_domains;

//----- (0000000000404670) ----------------------------------------------------
unsigned __int64 __fastcall nl_load_domain(
        __int64 a1,
        __off_t _RSI,
        __int64 a3,
        __int64 a4,
        u32 *a5,
        unsigned __int64 a6)
{
  __off_t v6; // r15
  __int64 v7; // rbx
  __int64 v8; // rdx
  int v9; // eax
  u32 *v10; // r8
  __int64 v11; // rdx
  const char *v12; // rdi
  unsigned int v13; // eax
  unsigned int v14; // ebp
  _QWORD *v15; // rdx
  __int64 v16; // rcx
  u32 *v17; // r8
  __int64 v18; // r9
  _DWORD *v19; // r13
  _QWORD *v20; // rdx
  __int64 v21; // rcx
  u32 *v22; // r8
  unsigned __int64 v23; // r9
  int v24; // er14
  _BOOL4 v25; // ebp
  int v26; // er12
  _QWORD *v27; // rax
  unsigned int v28; // eax
  __int64 v29; // rdx
  size_t v30; // r14
  _QWORD *v31; // rax
  unsigned int v32; // er12
  char *v33; // rbp
  signed __int64 nocancel; // rax
  unsigned int v35; // ebp
  __int64 v37; // rdx
  __int64 v38; // rdi
  __int64 v39; // rdx
  __int64 v40; // rcx
  u32 *v41; // r8
  __int64 v42; // rdx
  __int64 v43; // rcx
  u32 *v44; // r8
  int v45; // eax
  __int64 msg; // rax
  __int64 v47; // rbp
  unsigned __int64 v48; // rdi
  char *v49; // rbp
  u32 *v50; // rax
  __int64 v51; // r11
  __int64 v52; // rdx
  u32 *v53; // r8
  char *v54; // rcx
  __int64 v55; // rcx
  _BYTE *v56; // rax
  int v57; // er15
  unsigned int v58; // edi
  unsigned int v59; // er15
  __int64 v60; // rdx
  __int64 v61; // rax
  __int64 v62; // rdx
  __int64 v63; // rcx
  unsigned int v64; // ebp
  __int64 v65; // rax
  __int64 v66; // r12
  __int64 i; // rbx
  unsigned int *v68; // rax
  char *v69; // r13
  bool v70; // al
  __int64 v71; // r15
  __int64 v72; // r11
  unsigned __int64 v73; // r9
  __int64 v74; // r13
  unsigned int *v75; // r13
  __int64 j; // rax
  __int64 v77; // rdi
  __int64 v78; // rdi
  bool v79; // zf
  _QWORD *v80; // rax
  __int64 v81; // rax
  __int64 v82; // r11
  unsigned int *v83; // r9
  unsigned __int64 v84; // r15
  int v85; // ecx
  int v86; // ebp
  unsigned int *v87; // rax
  bool v88; // al
  __int64 v89; // rax
  _QWORD *v90; // rcx
  _DWORD *v91; // rax
  int v92; // er13
  _DWORD *v93; // rbp
  _QWORD *v94; // r14
  unsigned __int32 v95; // ebx
  unsigned int *v96; // rbx
  __off_t v97; // r12
  __int64 v98; // rax
  unsigned int *v99; // rbx
  __int64 v100; // rbp
  unsigned int v101; // eax
  unsigned int v102; // ebp
  __int64 v103; // rdx
  unsigned int v104; // eax
  int v105; // eax
  int v106; // er8
  __int64 v107; // rdi
  __int64 k; // rax
  unsigned int v109; // edx
  unsigned __int32 v110; // ecx
  int v111; // ebp
  unsigned __int8 **v112; // r12
  unsigned int v113; // eax
  unsigned int v114; // er8
  unsigned int v115; // edi
  unsigned int v116; // eax
  _DWORD *v117; // rax
  __off_t st_size; // [rsp+0h] [rbp-188h]
  unsigned int v119; // [rsp+8h] [rbp-180h]
  unsigned __int64 v120; // [rsp+8h] [rbp-180h]
  unsigned __int64 v121; // [rsp+8h] [rbp-180h]
  unsigned __int64 v122; // [rsp+8h] [rbp-180h]
  unsigned int *v123; // [rsp+8h] [rbp-180h]
  unsigned __int64 v124; // [rsp+8h] [rbp-180h]
  unsigned int v125; // [rsp+8h] [rbp-180h]
  unsigned __int32 v126; // [rsp+10h] [rbp-178h]
  unsigned int *v127; // [rsp+10h] [rbp-178h]
  __int64 v128; // [rsp+10h] [rbp-178h]
  __int64 v129; // [rsp+10h] [rbp-178h]
  __int64 v130; // [rsp+10h] [rbp-178h]
  unsigned __int32 v131; // [rsp+18h] [rbp-170h]
  __int64 v132; // [rsp+18h] [rbp-170h]
  unsigned __int64 v133; // [rsp+18h] [rbp-170h]
  unsigned __int64 v134; // [rsp+20h] [rbp-168h]
  __off_t v135; // [rsp+20h] [rbp-168h]
  _DWORD *v136; // [rsp+20h] [rbp-168h]
  unsigned int v137; // [rsp+20h] [rbp-168h]
  char v138; // [rsp+28h] [rbp-160h]
  __int64 v139; // [rsp+28h] [rbp-160h]
  __off_t v140; // [rsp+30h] [rbp-158h]
  _QWORD *v141; // [rsp+30h] [rbp-158h]
  int v142; // [rsp+38h] [rbp-150h]
  unsigned int *v143; // [rsp+38h] [rbp-150h]
  unsigned __int64 v144; // [rsp+40h] [rbp-148h]
  unsigned int *v145; // [rsp+40h] [rbp-148h]
  _QWORD *v146; // [rsp+48h] [rbp-140h]
  unsigned int *v147; // [rsp+50h] [rbp-138h]
  _QWORD *v148; // [rsp+50h] [rbp-138h]
  u32 *v149; // [rsp+58h] [rbp-130h]
  __int64 v150; // [rsp+58h] [rbp-130h]
  __off_t v151; // [rsp+60h] [rbp-128h]
  __int64 v152; // [rsp+60h] [rbp-128h]
  char v153; // [rsp+68h] [rbp-120h]
  unsigned int v154; // [rsp+68h] [rbp-120h]
  int v155; // [rsp+6Ch] [rbp-11Ch]
  __int64 v156; // [rsp+70h] [rbp-118h]
  __off_t v157; // [rsp+78h] [rbp-110h]
  _DWORD *v158; // [rsp+88h] [rbp-100h]
  char v159[8]; // [rsp+98h] [rbp-F0h] BYREF
  __int64 v160[2]; // [rsp+A0h] [rbp-E8h]
  struct stat v161; // [rsp+B0h] [rbp-D8h] BYREF
  unsigned __int64 v162; // [rsp+148h] [rbp-40h]

  v6 = _RSI;
  v7 = a1;
  v8 = __readfsqword(0x10u);
  v162 = __readfsqword(0x28u);
  if ( qword_4AA888 != v8 )
  {
    _RSI = 1LL;
    if ( _libc_multiple_threads )
    {
      if ( !_InterlockedCompareExchange(&lock_10757, 1, 0) )
        goto LABEL_7;
    }
    else
    {
      __asm { cmpxchg cs:lock_10757, esi }
      if ( !_libc_multiple_threads )
      {
LABEL_7:
        qword_4AA888 = v8;
        goto LABEL_8;
      }
    }
    _lll_lock_wait_private((u32 *)&lock_10757, 1LL, v8, a4, a5, a6);
    goto LABEL_7;
  }
LABEL_8:
  v9 = dword_4AA884;
  v10 = (u32 *)*(unsigned int *)(a1 + 8);
  v11 = (unsigned int)++dword_4AA884;
  if ( (_DWORD)v10 )
    goto LABEL_30;
  v12 = *(const char **)a1;
  *(_DWORD *)(v7 + 8) = -1;
  *(_QWORD *)(v7 + 16) = 0LL;
  if ( !v12 )
    goto LABEL_29;
  _RSI = 0LL;
  v13 = _open_nocancel(v12, 0, v11);
  v14 = v13;
  if ( v13 == -1 )
    goto LABEL_42;
  _RSI = v13;
  if ( (unsigned int)fxstat(1u, v13, &v161) || (st_size = v161.st_size, v161.st_size <= 0x2FuLL) )
  {
LABEL_41:
    _close_nocancel(v14);
    goto LABEL_42;
  }
  _RSI = v161.st_size;
  v19 = (_DWORD *)mmap64(0LL, v161.st_size, 1uLL, 2uLL, v14, 0LL);
  if ( v19 == (_DWORD *)-1LL )
  {
    v30 = st_size;
    v31 = malloc(st_size, _RSI, v15, v16, v17, v18);
    v19 = v31;
    if ( !v31 )
      goto LABEL_41;
    v32 = v14;
    v33 = (char *)v31;
    do
    {
      while ( 1 )
      {
        _RSI = (__off_t)v33;
        nocancel = _read_nocancel(v32, v33, v30);
        if ( nocancel > 0 )
          break;
        if ( nocancel != -1 || __readfsdword(0xFFFFFFC0) != 4 )
        {
          v14 = v32;
          goto LABEL_41;
        }
      }
      v33 += nocancel;
      v30 -= nocancel;
    }
    while ( v30 );
    v35 = v32;
    v26 = 0;
    _close_nocancel(v35);
    v24 = *v19;
    v25 = *v19 != -1794895138;
    if ( *v19 != -569244523 && v24 != -1794895138 )
    {
      free((__int64)v19, _RSI, (__int64)v20, v21, v22, v23);
      v9 = dword_4AA884 - 1;
      goto LABEL_29;
    }
LABEL_17:
    v27 = malloc(0xC8uLL, _RSI, v20, v21, v22, v23);
    a6 = (unsigned __int64)v27;
    if ( v27 )
    {
      *v27 = v19;
      *((_DWORD *)v27 + 2) = v26;
      *(_QWORD *)(v7 + 16) = v27;
      *((_DWORD *)v27 + 6) = v25;
      v27[2] = st_size;
      v28 = v19[1];
      *(_QWORD *)(a6 + 32) = 0LL;
      if ( v24 == -1794895138 )
      {
        if ( v28 > 0x1FFFF )
          goto LABEL_46;
        a4 = (unsigned int)v19[5];
        *(_DWORD *)(a6 + 40) = v19[2];
        v119 = a4;
        *(_QWORD *)(a6 + 48) = (char *)v19 + (unsigned int)v19[3];
        v37 = (unsigned int)v19[4];
        *(_DWORD *)(a6 + 88) = a4;
        v11 = (__int64)v19 + v37;
        *(_QWORD *)(a6 + 56) = v11;
        if ( (unsigned int)a4 > 2 )
        {
          v29 = (unsigned int)v19[6];
LABEL_55:
          v11 = (__int64)v19 + v29;
          *(_DWORD *)(a6 + 104) = v25;
          *(_QWORD *)(a6 + 96) = v11;
          if ( (_WORD)v28 )
          {
            if ( !v11 )
              goto LABEL_46;
            v126 = v19[9];
            if ( v24 == -1794895138 )
            {
              if ( v126 )
              {
                v47 = (unsigned int)v19[8];
                v131 = v19[7];
                goto LABEL_60;
              }
            }
            else
            {
              v126 = _byteswap_ulong(v19[9]);
              if ( v126 )
              {
                v131 = _byteswap_ulong(v19[7]);
                v47 = _byteswap_ulong(v19[8]);
LABEL_60:
                LODWORD(v48) = v131;
                _RSI = 8LL;
                v134 = a6;
                v49 = (char *)v19 + v47;
                v50 = calloc(v131, 8uLL, v11, a4, v10, a6);
                a6 = v134;
                v51 = (__int64)v50;
                if ( v50 )
                {
                  v52 = 0LL;
                  v53 = (u32 *)(v131 - 1);
                  if ( v131 )
                  {
                    v135 = v6;
                    while ( 1 )
                    {
                      _RSI = *(unsigned int *)&v49[8 * v52];
                      v55 = *(unsigned int *)&v49[8 * v52 + 4];
                      v56 = (char *)v19 + v55;
                      if ( v24 != -1794895138 )
                      {
                        v55 = _byteswap_ulong(v55);
                        _RSI = _byteswap_ulong(_RSI);
                        v56 = (char *)v19 + (unsigned int)v55;
                      }
                      if ( !(_DWORD)_RSI || (v55 = (unsigned int)(_RSI - 1), v56[v55]) )
                      {
                        v122 = a6;
                        free(v51, _RSI, v52, v55, v53, a6);
                        v38 = 0LL;
                        a6 = v122;
                        goto LABEL_47;
                      }
                      if ( *v56 == 80 )
                      {
                        v54 = 0LL;
                        if ( v56[1] == 82 && v56[2] == 73 )
                        {
                          _RSI = (unsigned __int8)v56[3];
                          LOBYTE(v6) = (_BYTE)_RSI == 100;
                          LOBYTE(v48) = (_BYTE)_RSI == 105;
                          v57 = v48 | v6;
                          LOBYTE(v48) = (_BYTE)_RSI == 111;
                          v138 = v57;
                          v58 = v57 | v48;
                          v59 = v58;
                          v153 = v58;
                          LOBYTE(v58) = (_BYTE)_RSI == 117;
                          v48 = v59 | v58;
                          LODWORD(v6) = _RSI & 0xFFFFFFDF;
                          if ( (_RSI & 0xDF) == 88 || (_BYTE)v48 )
                          {
                            v54 = (char *)(unsigned __int8)v56[4];
                            switch ( (_BYTE)v54 )
                            {
                              case '8':
                                if ( v56[5] )
                                {
                                  v54 = 0LL;
                                }
                                else if ( (_BYTE)_RSI == 100 )
                                {
                                  v54 = "d";
                                }
                                else if ( v138 )
                                {
                                  v54 = "i";
                                }
                                else if ( v153 )
                                {
                                  v54 = (char *)"o";
                                }
                                else if ( (_BYTE)v48 )
                                {
                                  v54 = (char *)&unk_493152;
                                }
                                else if ( (_BYTE)_RSI == 120 )
                                {
                                  v54 = (char *)"x";
                                }
                                else
                                {
                                  if ( (_BYTE)_RSI != 88 )
                                    goto LABEL_393;
                                  v54 = "X";
                                }
                                break;
                              case '1':
                                v54 = 0LL;
                                if ( v56[5] == 54 && !v56[6] )
                                {
                                  if ( (_BYTE)_RSI == 100 )
                                  {
                                    v54 = "d";
                                  }
                                  else if ( v138 )
                                  {
                                    v54 = "i";
                                  }
                                  else if ( v153 )
                                  {
                                    v54 = (char *)"o";
                                  }
                                  else if ( (_BYTE)v48 )
                                  {
                                    v54 = (char *)&unk_493152;
                                  }
                                  else if ( (_BYTE)_RSI == 120 )
                                  {
                                    v54 = (char *)"x";
                                  }
                                  else
                                  {
                                    if ( (_BYTE)_RSI != 88 )
                                      goto LABEL_393;
                                    v54 = "X";
                                  }
                                }
                                break;
                              case '3':
                                v54 = 0LL;
                                if ( v56[5] == 50 && !v56[6] )
                                {
                                  if ( (_BYTE)_RSI == 100 )
                                  {
                                    v54 = "d";
                                  }
                                  else if ( v138 )
                                  {
                                    v54 = "i";
                                  }
                                  else if ( v153 )
                                  {
                                    v54 = (char *)"o";
                                  }
                                  else if ( (_BYTE)v48 )
                                  {
                                    v54 = (char *)&unk_493152;
                                  }
                                  else if ( (_BYTE)_RSI == 120 )
                                  {
                                    v54 = (char *)"x";
                                  }
                                  else
                                  {
                                    if ( (_BYTE)_RSI != 88 )
                                      goto LABEL_393;
                                    v54 = "X";
                                  }
                                }
                                break;
                              case '6':
                                v54 = 0LL;
                                if ( v56[5] == 52 && !v56[6] )
                                {
                                  if ( (_BYTE)_RSI == 100 )
                                  {
                                    v54 = "ld";
                                  }
                                  else if ( v138 )
                                  {
                                    v54 = "li";
                                  }
                                  else if ( v153 )
                                  {
                                    v54 = "lo";
                                  }
                                  else if ( (_BYTE)v48 )
                                  {
                                    v54 = "lu";
                                  }
                                  else if ( (_BYTE)_RSI == 120 )
                                  {
                                    v54 = "lx";
                                  }
                                  else
                                  {
                                    if ( (_BYTE)_RSI != 88 )
                                      goto LABEL_393;
                                    v54 = "lX";
                                  }
                                }
                                break;
                              case 'L':
                                v54 = 0LL;
                                if ( v56[5] == 69 && v56[6] == 65 && v56[7] == 83 && v56[8] == 84 )
                                {
                                  v54 = (char *)(unsigned __int8)v56[9];
                                  LODWORD(v6) = (unsigned __int8)v56[9];
                                  if ( (_BYTE)v54 == 56 )
                                  {
                                    if ( v56[10] )
                                    {
                                      v54 = 0LL;
                                    }
                                    else if ( (_BYTE)_RSI == 100 )
                                    {
                                      v54 = "d";
                                    }
                                    else if ( v138 )
                                    {
                                      v54 = "i";
                                    }
                                    else if ( v153 )
                                    {
                                      v54 = (char *)"o";
                                    }
                                    else if ( (_BYTE)v48 )
                                    {
                                      v54 = (char *)&unk_493152;
                                    }
                                    else if ( (_BYTE)_RSI == 120 )
                                    {
                                      v54 = (char *)"x";
                                    }
                                    else
                                    {
                                      if ( (_BYTE)_RSI != 88 )
                                        goto LABEL_393;
                                      v54 = "X";
                                    }
                                  }
                                  else if ( (_BYTE)v54 == 49 )
                                  {
                                    v54 = 0LL;
                                    if ( v56[10] == 54 && !v56[11] )
                                    {
                                      if ( (_BYTE)_RSI == 100 )
                                      {
                                        v54 = "d";
                                      }
                                      else if ( v138 )
                                      {
                                        v54 = "i";
                                      }
                                      else if ( v153 )
                                      {
                                        v54 = (char *)"o";
                                      }
                                      else if ( (_BYTE)v48 )
                                      {
                                        v54 = (char *)&unk_493152;
                                      }
                                      else if ( (_BYTE)_RSI == 120 )
                                      {
                                        v54 = (char *)"x";
                                      }
                                      else
                                      {
                                        if ( (_BYTE)_RSI != 88 )
                                          goto LABEL_393;
                                        v54 = "X";
                                      }
                                    }
                                  }
                                  else
                                  {
                                    v79 = (_BYTE)v54 == 51;
                                    v54 = 0LL;
                                    if ( v79 )
                                    {
                                      if ( v56[10] == 50 && !v56[11] )
                                      {
                                        if ( (_BYTE)_RSI == 100 )
                                        {
                                          v54 = "d";
                                        }
                                        else if ( v138 )
                                        {
                                          v54 = "i";
                                        }
                                        else if ( v153 )
                                        {
                                          v54 = (char *)"o";
                                        }
                                        else if ( (_BYTE)v48 )
                                        {
                                          v54 = (char *)&unk_493152;
                                        }
                                        else if ( (_BYTE)_RSI == 120 )
                                        {
                                          v54 = (char *)"x";
                                        }
                                        else
                                        {
                                          if ( (_BYTE)_RSI != 88 )
                                            goto LABEL_393;
                                          v54 = "X";
                                        }
                                      }
                                    }
                                    else if ( (_BYTE)v6 == 54 && v56[10] == 52 && !v56[11] )
                                    {
                                      if ( (_BYTE)_RSI == 100 )
                                      {
                                        v54 = "ld";
                                      }
                                      else if ( v138 )
                                      {
                                        v54 = "li";
                                      }
                                      else if ( v153 )
                                      {
                                        v54 = "lo";
                                      }
                                      else if ( (_BYTE)v48 )
                                      {
                                        v54 = "lu";
                                      }
                                      else if ( (_BYTE)_RSI == 120 )
                                      {
                                        v54 = "lx";
                                      }
                                      else
                                      {
                                        if ( (_BYTE)_RSI != 88 )
                                          goto LABEL_393;
                                        v54 = "lX";
                                      }
                                    }
                                  }
                                }
                                break;
                              case 'F':
                                v54 = 0LL;
                                if ( v56[5] == 65 && v56[6] == 83 && v56[7] == 84 )
                                {
                                  v54 = (char *)(unsigned __int8)v56[8];
                                  LODWORD(v6) = (unsigned __int8)v56[8];
                                  if ( (_BYTE)v54 == 56 )
                                  {
                                    if ( v56[9] )
                                    {
                                      v54 = 0LL;
                                    }
                                    else if ( (_BYTE)_RSI == 100 )
                                    {
                                      v54 = "d";
                                    }
                                    else if ( v138 )
                                    {
                                      v54 = "i";
                                    }
                                    else if ( v153 )
                                    {
                                      v54 = (char *)"o";
                                    }
                                    else if ( (_BYTE)v48 )
                                    {
                                      v54 = (char *)&unk_493152;
                                    }
                                    else if ( (_BYTE)_RSI == 120 )
                                    {
                                      v54 = (char *)"x";
                                    }
                                    else
                                    {
                                      if ( (_BYTE)_RSI != 88 )
                                        goto LABEL_393;
                                      v54 = "X";
                                    }
                                  }
                                  else if ( (_BYTE)v54 == 49 )
                                  {
                                    v54 = 0LL;
                                    if ( v56[9] == 54 && !v56[10] )
                                    {
                                      if ( (_BYTE)_RSI == 100 )
                                      {
                                        v54 = "ld";
                                      }
                                      else if ( v138 )
                                      {
                                        v54 = "li";
                                      }
                                      else if ( v153 )
                                      {
                                        v54 = "lo";
                                      }
                                      else if ( (_BYTE)v48 )
                                      {
                                        v54 = "lu";
                                      }
                                      else if ( (_BYTE)_RSI == 120 )
                                      {
                                        v54 = "lx";
                                      }
                                      else
                                      {
                                        if ( (_BYTE)_RSI != 88 )
                                          goto LABEL_393;
                                        v54 = "lX";
                                      }
                                    }
                                  }
                                  else
                                  {
                                    v79 = (_BYTE)v54 == 51;
                                    v54 = 0LL;
                                    if ( v79 )
                                    {
                                      if ( v56[9] == 50 && !v56[10] )
                                      {
                                        if ( (_BYTE)_RSI == 100 )
                                        {
                                          v54 = "ld";
                                        }
                                        else if ( v138 )
                                        {
                                          v54 = "li";
                                        }
                                        else if ( v153 )
                                        {
                                          v54 = "lo";
                                        }
                                        else if ( (_BYTE)v48 )
                                        {
                                          v54 = "lu";
                                        }
                                        else if ( (_BYTE)_RSI == 120 )
                                        {
                                          v54 = "lx";
                                        }
                                        else
                                        {
                                          if ( (_BYTE)_RSI != 88 )
                                            goto LABEL_393;
                                          v54 = "lX";
                                        }
                                      }
                                    }
                                    else if ( (_BYTE)v6 == 54 && v56[9] == 52 && !v56[10] )
                                    {
                                      if ( (_BYTE)_RSI == 100 )
                                      {
                                        v54 = "ld";
                                      }
                                      else if ( v138 )
                                      {
                                        v54 = "li";
                                      }
                                      else if ( v153 )
                                      {
                                        v54 = "lo";
                                      }
                                      else if ( (_BYTE)v48 )
                                      {
                                        v54 = "lu";
                                      }
                                      else if ( (_BYTE)_RSI == 120 )
                                      {
                                        v54 = "lx";
                                      }
                                      else
                                      {
                                        if ( (_BYTE)_RSI != 88 )
                                          goto LABEL_393;
                                        v54 = "lX";
                                      }
                                    }
                                  }
                                }
                                break;
                              case 'M':
                                v54 = 0LL;
                                if ( v56[5] == 65 && v56[6] == 88 )
                                {
                                  if ( v56[7] )
                                  {
                                    v54 = 0LL;
                                  }
                                  else if ( (_BYTE)_RSI == 100 )
                                  {
                                    v54 = "ld";
                                  }
                                  else if ( v138 )
                                  {
                                    v54 = "li";
                                  }
                                  else if ( v153 )
                                  {
                                    v54 = "lo";
                                  }
                                  else if ( (_BYTE)v48 )
                                  {
                                    v54 = "lu";
                                  }
                                  else if ( (_BYTE)_RSI == 120 )
                                  {
                                    v54 = "lx";
                                  }
                                  else
                                  {
                                    if ( (_BYTE)_RSI != 88 )
                                      goto LABEL_393;
                                    v54 = "lX";
                                  }
                                }
                                break;
                              default:
                                v79 = (_BYTE)v54 == 80;
                                v54 = 0LL;
                                if ( v79 && v56[5] == 84 && v56[6] == 82 )
                                {
                                  if ( v56[7] )
                                  {
                                    v54 = 0LL;
                                  }
                                  else if ( (_BYTE)_RSI == 100 )
                                  {
                                    v54 = "ld";
                                  }
                                  else if ( v138 )
                                  {
                                    v54 = "li";
                                  }
                                  else if ( v153 )
                                  {
                                    v54 = "lo";
                                  }
                                  else if ( (_BYTE)v48 )
                                  {
                                    v54 = "lu";
                                  }
                                  else if ( (_BYTE)_RSI == 120 )
                                  {
                                    v54 = "lx";
                                  }
                                  else
                                  {
                                    if ( (_BYTE)_RSI != 88 )
                                      goto LABEL_393;
                                    v54 = "lX";
                                  }
                                }
                                break;
                            }
                          }
                        }
                      }
                      else if ( *v56 == 73 )
                      {
                        v54 = 0LL;
                        if ( !v56[1] )
                          v54 = "I";
                      }
                      else
                      {
                        v54 = 0LL;
                      }
                      *(_QWORD *)(v51 + 8 * v52) = v54;
                      if ( v53 == (u32 *)v52 )
                        break;
                      ++v52;
                    }
                    v6 = v135;
                  }
                  v60 = (unsigned int)v19[10];
                  v61 = (unsigned int)v19[11];
                  if ( v24 == -1794895138 )
                  {
                    v62 = (__int64)v19 + v60;
                  }
                  else
                  {
                    v61 = _byteswap_ulong(v61);
                    v62 = (__int64)v19 + _byteswap_ulong(v60);
                  }
                  v63 = v119;
                  v149 = (u32 *)v62;
                  v64 = v131;
                  v147 = (_DWORD *)((char *)v19 + v61);
                  v65 = v126 - 1;
                  _RSI = 4LL * v119;
                  v127 = v147;
                  v139 = v62 + 4 * v65 + 4;
                  v123 = (unsigned int *)v62;
                  v140 = _RSI;
                  v154 = 0;
                  v136 = v19;
                  v144 = a6;
                  v132 = v7;
                  v151 = v6;
                  v142 = v26;
                  v66 = v51;
                  do
                  {
                    for ( i = 0LL; ; i = 1LL )
                    {
                      if ( v24 == -1794895138 )
                      {
                        if ( i )
                          v74 = *v127;
                        else
                          v74 = *v123;
                        v69 = (char *)v136 + v74;
                        v70 = *((_DWORD *)v69 + 2) != -1;
                      }
                      else
                      {
                        v68 = v127;
                        if ( !i )
                          v68 = v123;
                        v69 = (char *)v136 + _byteswap_ulong(*v68);
                        v70 = *((_DWORD *)v69 + 2) != -1;
                      }
                      v71 = 0LL;
                      if ( v70 )
                      {
                        v75 = (unsigned int *)(v69 + 4);
                        for ( j = 0LL; ; j = v71 + j_strlen_ifunc(v77) )
                        {
                          v62 = v75[1];
                          v63 = *v75;
                          v71 = j + v63;
                          if ( v24 != -1794895138 )
                          {
                            v63 = _byteswap_ulong(v63);
                            v62 = _byteswap_ulong(v62);
                            v71 = (unsigned int)v63 + j;
                          }
                          if ( (_DWORD)v62 == -1 )
                            goto LABEL_105;
                          if ( (unsigned int)v62 >= v64 )
                            break;
                          v62 = (unsigned int)v62;
                          v77 = *(_QWORD *)(v66 + 8LL * (unsigned int)v62);
                          if ( !v77 )
                            goto LABEL_107;
                          v75 += 2;
                        }
                        v19 = v136;
                        v78 = v66;
                        v26 = v142;
                        v7 = v132;
                        free(v78, _RSI, v62, v63, v53, v144);
                        v38 = 0LL;
                        a6 = v144;
                        goto LABEL_47;
                      }
LABEL_105:
                      v160[i] = v71;
                      if ( i == 1 )
                        break;
                    }
                    ++v154;
                    v140 += v160[0] + v160[1];
LABEL_107:
                    ++v123;
                    ++v127;
                  }
                  while ( (unsigned int *)v139 != v123 );
                  v72 = v66;
                  v19 = v136;
                  v73 = v144;
                  v26 = v142;
                  v7 = v132;
                  v6 = v151;
                  if ( !v154 )
                  {
                    *(_DWORD *)(v144 + 64) = 0;
                    *(_QWORD *)(v144 + 72) = 0LL;
                    *(_QWORD *)(v144 + 80) = 0LL;
                    goto LABEL_110;
                  }
                  v48 = v140 + 32LL * v154;
                  v128 = v72;
                  v80 = malloc(v48, _RSI, (_QWORD *)v62, v63, v53, v144);
                  a6 = v144;
                  a4 = (__int64)v80;
                  v141 = v80;
                  if ( v80 )
                  {
                    *(_QWORD *)(v144 + 32) = v80;
                    v53 = v149;
                    v81 = 16LL * v154;
                    v155 = v142;
                    v82 = v128;
                    v137 = 0;
                    v152 = v81 + a4;
                    v156 = v81 + a4 + v81;
                    v150 = v132;
                    v133 = v144;
                    v83 = v147;
                    v157 = v6;
                    v84 = v156 + _RSI;
                    do
                    {
                      v85 = 0;
                      v86 = *(_DWORD *)(v133 + 24);
                      while ( 1 )
                      {
                        if ( v86 )
                        {
                          v87 = v83;
                          if ( !v85 )
                            v87 = v53;
                          v52 = (__int64)v19 + _byteswap_ulong(*v87);
                          v88 = *(_DWORD *)(v52 + 8) != -1;
                        }
                        else
                        {
                          if ( v85 )
                            v103 = *v83;
                          else
                            v103 = *v53;
                          v52 = (__int64)v19 + v103;
                          v88 = *(_DWORD *)(v52 + 8) != -1;
                        }
                        if ( v88 )
                        {
                          for ( v52 += 4LL; ; v52 += 8LL )
                          {
                            v104 = *(_DWORD *)(v52 + 4);
                            _RSI = _byteswap_ulong(v104);
                            if ( v86 )
                              v104 = _RSI;
                            if ( v104 == -1 )
                              break;
                            if ( !*(_QWORD *)(v82 + 8LL * v104) )
                              goto LABEL_244;
                          }
                        }
                        if ( v85 == 1 )
                          break;
                        v85 = 1;
                      }
                      v129 = v82;
                      v125 = 0;
                      v89 = 2LL * v137;
                      v143 = v83;
                      v90 = &v141[v89];
                      v145 = v53;
                      v148 = (_QWORD *)(v152 + v89 * 8);
                      v91 = v19;
                      v92 = *(_DWORD *)(v133 + 24);
                      v146 = v90;
                      v93 = v91;
                      if ( v92 )
                      {
LABEL_218:
                        _RSI = v125;
                        if ( v125 )
                        {
                          v94 = v148;
                          v95 = _byteswap_ulong(*v143);
                        }
                        else
                        {
                          v94 = v146;
                          v95 = _byteswap_ulong(*v145);
                        }
                        v96 = (_DWORD *)((char *)v93 + v95);
                        v97 = (__off_t)v93 + _byteswap_ulong(*v96);
                        v98 = _byteswap_ulong(v96[1]);
                        if ( v96[2] != -1 )
                          goto LABEL_227;
LABEL_221:
                        *v94 = v98;
                        v94[1] = v97;
                        goto LABEL_222;
                      }
                      while ( 1 )
                      {
                        if ( v125 )
                        {
                          v94 = v148;
                          v96 = (_DWORD *)((char *)v93 + *v143);
                        }
                        else
                        {
                          v94 = v146;
                          v96 = (_DWORD *)((char *)v93 + *v145);
                        }
                        v97 = (__off_t)v93 + *v96;
                        v98 = v96[1];
                        if ( v96[2] == -1 )
                          goto LABEL_221;
LABEL_227:
                        v94[1] = v84;
                        v99 = v96 + 1;
                        v158 = v93;
                        while ( 1 )
                        {
                          v101 = *v99;
                          v102 = v99[1];
                          if ( v92 )
                          {
                            v101 = _byteswap_ulong(v101);
                            v102 = _byteswap_ulong(v102);
                          }
                          if ( v101 )
                          {
                            _RSI = v97;
                            v48 = v84;
                            v84 += v101;
                            v97 += v101;
                            j_memcpy(v48, _RSI, v101);
                          }
                          if ( v102 == -1 )
                            break;
                          v99 += 2;
                          v48 = v84;
                          _RSI = *(_QWORD *)(v129 + 8LL * v102);
                          v100 = j_strlen_ifunc(_RSI);
                          j_memcpy(v84, _RSI, v100);
                          v84 += v100;
                        }
                        v93 = v158;
                        *v94 = v84 - v94[1];
LABEL_222:
                        if ( v125 == 1 )
                          break;
                        v125 = 1;
                        v92 = *(_DWORD *)(v133 + 24);
                        if ( v92 )
                          goto LABEL_218;
                      }
                      v19 = v93;
                      v82 = v129;
                      v83 = v143;
                      v53 = v145;
                      ++v137;
LABEL_244:
                      ++v53;
                      ++v83;
                    }
                    while ( (u32 *)v139 != v53 );
                    a6 = v133;
                    v6 = v157;
                    v54 = (char *)v137;
                    if ( v154 != v137 )
LABEL_393:
                      nl_load_domain_cold_0(v48, _RSI, v52, v54, v53, a6);
                    v105 = *(_DWORD *)(v133 + 88);
                    if ( v105 )
                    {
                      _RSI = (unsigned int)(v105 - 1);
                      v106 = *(_DWORD *)(v133 + 104);
                      v107 = *(_QWORD *)(v133 + 96);
                      for ( k = 0LL; ; ++k )
                      {
                        v109 = *(_DWORD *)(v107 + 4 * k);
                        v110 = _byteswap_ulong(v109);
                        if ( v106 )
                          v109 = v110;
                        *(_DWORD *)(v156 + 4 * k) = v109;
                        if ( _RSI == k )
                          break;
                      }
                    }
                    v130 = v82;
                    v111 = 0;
                    v112 = (unsigned __int8 **)(v141 + 1);
                    do
                    {
                      v113 = _hash_string(*v112);
                      v114 = *(_DWORD *)(v133 + 88);
                      v63 = v113 % v114;
                      v115 = v113 % (v114 - 2) + 1;
                      v53 = (u32 *)(v115 - v114);
                      while ( 1 )
                      {
                        v117 = (_DWORD *)(v156 + 4LL * (unsigned int)v63);
                        if ( !*v117 )
                          break;
                        v116 = v63 + (_DWORD)v53;
                        if ( *(_DWORD *)(v133 + 88) - v115 > (unsigned int)v63 )
                          v116 = v63 + v115;
                        v63 = v116;
                      }
                      v112 += 2;
                      v62 = (unsigned int)(v111 + *(_DWORD *)(v133 + 40) + 1);
                      ++v111;
                      *v117 = v62;
                    }
                    while ( v154 != v111 );
                    v73 = v133;
                    v26 = v155;
                    v72 = v130;
                    v7 = v150;
                    *(_QWORD *)(v133 + 96) = v156;
                    *(_DWORD *)(v133 + 64) = v154;
                    *(_DWORD *)(v133 + 104) = 0;
                    *(_QWORD *)(v133 + 72) = v141;
                    *(_QWORD *)(v133 + 80) = v152;
LABEL_110:
                    v124 = v73;
                    free(v72, _RSI, v62, v63, v53, v73);
                    a6 = v124;
LABEL_51:
                    *(_QWORD *)(a6 + 112) = 0LL;
                    *(_QWORD *)(a6 + 120) = 0LL;
                    _RSI = v6;
                    v121 = a6;
                    msg = nl_find_msg(v7, v6, byte_493255, 0, (u32 *)v159);
                    a6 = v121;
                    if ( msg != -1 )
                    {
                      _RSI = v121 + 184;
                      _gettext_extract_plural(msg, (unsigned __int8 **)(v121 + 184), (unsigned __int64 *)(v121 + 192));
                      v9 = dword_4AA884 - 1;
                      goto LABEL_29;
                    }
                    v38 = *(_QWORD *)(v121 + 32);
LABEL_47:
                    v120 = a6;
                    free(v38, _RSI, v11, a4, v10, a6);
                    if ( v26 )
                    {
                      _RSI = st_size;
                      munmap((unsigned __int64)v19, st_size);
                    }
                    else
                    {
                      free((__int64)v19, _RSI, v39, v40, v41, v120);
                    }
                    free(v120, _RSI, v42, v43, v44, v120);
                    v45 = dword_4AA884;
                    *(_QWORD *)(v7 + 16) = 0LL;
                    v9 = v45 - 1;
                    goto LABEL_29;
                  }
                }
LABEL_46:
                v38 = 0LL;
                goto LABEL_47;
              }
            }
          }
LABEL_50:
          *(_DWORD *)(a6 + 64) = 0;
          *(_QWORD *)(a6 + 72) = 0LL;
          *(_QWORD *)(a6 + 80) = 0LL;
          goto LABEL_51;
        }
      }
      else
      {
        v28 = _byteswap_ulong(v28);
        if ( v28 > 0x1FFFF )
          goto LABEL_46;
        *(_DWORD *)(a6 + 40) = _byteswap_ulong(v19[2]);
        *(_QWORD *)(a6 + 48) = (char *)v19 + _byteswap_ulong(v19[3]);
        *(_QWORD *)(a6 + 56) = (char *)v19 + _byteswap_ulong(v19[4]);
        v11 = _byteswap_ulong(v19[5]);
        v119 = v11;
        *(_DWORD *)(a6 + 88) = v11;
        if ( (unsigned int)v11 > 2 )
        {
          v29 = _byteswap_ulong(v19[6]);
          goto LABEL_55;
        }
      }
      *(_QWORD *)(a6 + 96) = 0LL;
      *(_DWORD *)(a6 + 104) = v25;
      if ( (_WORD)v28 )
        goto LABEL_46;
      goto LABEL_50;
    }
LABEL_42:
    v9 = dword_4AA884 - 1;
    goto LABEL_29;
  }
  _close_nocancel(v14);
  v24 = *v19;
  v25 = *v19 != -1794895138;
  if ( *v19 == -569244523 || v24 == -1794895138 )
  {
    v26 = 1;
    goto LABEL_17;
  }
  _RSI = st_size;
  munmap((unsigned __int64)v19, st_size);
  v9 = dword_4AA884 - 1;
LABEL_29:
  *(_DWORD *)(v7 + 8) = 1;
LABEL_30:
  dword_4AA884 = v9;
  if ( !v9 )
  {
    qword_4AA888 = 0LL;
    if ( _libc_multiple_threads )
    {
      if ( !_InterlockedDecrement(&lock_10757) )
        return __readfsqword(0x28u) ^ v162;
    }
    else if ( !--lock_10757 )
    {
      return __readfsqword(0x28u) ^ v162;
    }
    _lll_unlock_wake_private((u32 *)&lock_10757, _RSI, v11, a4, v10, a6);
  }
  return __readfsqword(0x28u) ^ v162;
}
// 4046ED: variable 'v8' is possibly undefined
// 4047CF: variable 'v20' is possibly undefined
// 4047CF: variable 'v21' is possibly undefined
// 4047CF: variable 'v22' is possibly undefined
// 4047CF: variable 'v23' is possibly undefined
// 404877: variable 'v15' is possibly undefined
// 404877: variable 'v16' is possibly undefined
// 404877: variable 'v17' is possibly undefined
// 404877: variable 'v18' is possibly undefined
// 404975: variable 'v11' is possibly undefined
// 404975: variable 'a4' is possibly undefined
// 404975: variable 'v10' is possibly undefined
// 404975: variable 'a6' is possibly undefined
// 404A2C: variable 'v39' is possibly undefined
// 404A2C: variable 'v40' is possibly undefined
// 404A2C: variable 'v41' is possibly undefined
// 404A38: variable 'v42' is possibly undefined
// 404A38: variable 'v43' is possibly undefined
// 404A38: variable 'v44' is possibly undefined
// 404EF0: variable 'v53' is possibly undefined
// 405CBA: variable 'v52' is possibly undefined
// 401040: using guessed type __int64 __fastcall j_memcpy(_QWORD, _QWORD, _QWORD);
// 4010C8: using guessed type __int64 __fastcall j_strlen_ifunc(_QWORD);
// 4010EF: using guessed type void __fastcall __noreturn nl_load_domain_cold_0(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 493255: using guessed type unsigned __int8 byte_493255[1707];
// 4AA880: using guessed type int lock_10757;
// 4AA884: using guessed type int dword_4AA884;
// 4AA888: using guessed type __int64 qword_4AA888;
// 4AB820: using guessed type int _libc_multiple_threads;
// 404670: using guessed type char var_F0[8];

//----- (0000000000405D00) ----------------------------------------------------
__int64 __fastcall alias_compare(_QWORD *a1, _QWORD *a2)
{
  return j_strcasecmp_l(*a1, *a2, nl_C_locobj);
}
// 401088: using guessed type __int64 __fastcall j_strcasecmp_l(_QWORD, _QWORD, _QWORD);
// 4A7DE0: using guessed type char **nl_C_locobj[6];

//----- (0000000000405D20) ----------------------------------------------------
__int64 __fastcall read_alias_file(__int64 a1, int a2)
{
  __int64 v2; // rcx
  __int64 *v3; // rbx
  __int16 v4; // cx
  unsigned int v5; // ecx
  __int64 v6; // rcx
  u32 *v7; // r8
  __int64 v8; // r9
  int *v9; // rax
  unsigned int *v10; // rcx
  u32 *v11; // r8
  unsigned __int64 v12; // r9
  int *v13; // r15
  unsigned int v14; // eax
  __int64 v15; // rdx
  __int64 v16; // rsi
  __int64 v17; // rdx
  unsigned int *v18; // rcx
  u32 *v19; // r8
  unsigned __int64 v20; // r9
  char *v21; // rbx
  __int64 v22; // rax
  char v23; // al
  __int64 v24; // r8
  unsigned __int64 v25; // r9
  unsigned __int8 *v27; // r12
  __int64 i; // rax
  __int16 v29; // ax
  char v30; // al
  unsigned __int8 v31; // al
  _QWORD *v32; // rdx
  __int64 v33; // rax
  u32 *v34; // rdx
  __int64 v35; // r11
  __int64 v36; // r10
  __int64 v37; // r9
  __int64 v38; // r13
  u32 *v39; // r8
  __int64 v40; // rsi
  __int64 *v41; // rax
  __int64 v42; // rcx
  __int64 *v43; // r13
  __int64 v44; // rax
  __int64 v45; // rdi
  __int64 v46; // r9
  __int64 v47; // r10
  __int64 v48; // rax
  __int64 v49; // r12
  unsigned __int8 *v50; // rax
  __int64 v51; // r13
  __int64 *v52; // rax
  void *v53; // rsp
  __int64 v54; // rdi
  signed __int64 v55; // r9
  _QWORD *v56; // rsi
  __int64 v57; // [rsp+0h] [rbp-1228h]
  __int64 v58; // [rsp+8h] [rbp-1220h] BYREF
  char v59[7]; // [rsp+10h] [rbp-1218h] BYREF
  __int64 v60; // [rsp+1008h] [rbp-220h] BYREF
  u32 *v61; // [rsp+1010h] [rbp-218h]
  __int64 v62; // [rsp+1018h] [rbp-210h]
  u32 *v63; // [rsp+1020h] [rbp-208h]
  u32 *v64; // [rsp+1028h] [rbp-200h]
  u32 *v65; // [rsp+1030h] [rbp-1F8h]
  unsigned __int64 v66; // [rsp+1038h] [rbp-1F0h]
  u32 *v67; // [rsp+1040h] [rbp-1E8h]
  __int64 v68; // [rsp+1048h] [rbp-1E0h]
  __int64 v69; // [rsp+1050h] [rbp-1D8h]
  char v70[408]; // [rsp+1058h] [rbp-1D0h] BYREF
  unsigned __int64 v71; // [rsp+11F0h] [rbp-38h]

  v71 = __readfsqword(0x28u);
  v2 = a2 + 37LL;
  v3 = (__int64 *)((char *)&v60 - (v2 & 0xFFFFFFFFFFFFF000LL));
  v4 = v2 & 0xFFF0;
  if ( &v60 != v3 )
  {
    while ( &v58 != v3 )
      ;
  }
  v5 = v4 & 0xFFF;
  if ( v5 )
  {
    v53 = alloca(v5);
    *(__int64 *)((char *)&v57 + v5) = *(__int64 *)((char *)&v57 + v5);
  }
  strcpy((char *)j_mempcpy(v59, a1, a2), "/locale.alias");
  v9 = (int *)fopen64(v59, "rce", 115LL, v6, v7, v8);
  v13 = v9;
  if ( !v9 )
    return 0LL;
  v14 = *v9;
  v69 = 0LL;
  v15 = v14;
  BYTE1(v15) = BYTE1(v14) | 0x80;
  *v13 = v15;
  if ( (v14 & 0x10) != 0 )
  {
    fclose((__int64)v13, (__int64)"rce", v15, v10, v11, v12);
  }
  else
  {
    do
    {
      v16 = 400LL;
      if ( !fgets_unlocked((__int64)v70, 400, v13) )
        break;
      v21 = v70;
      v22 = j_strchr_ifunc(v70, 10LL);
      v17 = (unsigned __int8)v70[0];
      v19 = (u32 *)v22;
      v16 = __readfsqword(0xFFFFFFF0);
      v23 = v70[0];
      if ( (*(_BYTE *)(v16 + 2LL * (unsigned __int8)v70[0] + 1) & 0x20) != 0 )
      {
        do
        {
          v17 = (unsigned __int8)*++v21;
          v23 = *v21;
        }
        while ( (*(_BYTE *)(v16 + 2 * v17 + 1) & 0x20) != 0 );
      }
      if ( v23 && v23 != 35 )
      {
        v27 = (unsigned __int8 *)(v21 + 1);
        for ( i = (unsigned __int8)v21[1]; ; i = *v27 )
        {
          v17 = i;
          v29 = *(_WORD *)(v16 + 2 * i) & 0x2000;
          if ( !(_BYTE)v17 )
          {
            if ( !v29 )
              goto LABEL_12;
            goto LABEL_25;
          }
          if ( v29 )
            break;
          ++v27;
        }
        v50 = v27++;
        v17 = v50[1];
        *v50 = 0;
        v30 = v17;
        if ( (*(_BYTE *)(v16 + 2 * v17 + 1) & 0x20) == 0 )
          goto LABEL_26;
        do
        {
LABEL_25:
          v17 = *++v27;
          v30 = *v27;
        }
        while ( (*(_BYTE *)(v16 + 2 * v17 + 1) & 0x20) != 0 );
LABEL_26:
        if ( v30 )
        {
          v31 = v27[1];
          v32 = v27 + 1;
          if ( v31 )
          {
            if ( (*(_BYTE *)(v16 + 2LL * v31 + 1) & 0x20) != 0 )
            {
LABEL_42:
              if ( v31 == 10 )
                *(_WORD *)v32 = 2560;
              else
                *(_BYTE *)v32 = 0;
            }
            else
            {
              while ( 1 )
              {
                v32 = (_QWORD *)((char *)v32 + 1);
                v31 = *(_BYTE *)v32;
                if ( !*(_BYTE *)v32 )
                  break;
                if ( (*(_BYTE *)(v16 + 2LL * v31 + 1) & 0x20) != 0 )
                  goto LABEL_42;
              }
            }
          }
          v68 = nmap;
          if ( nmap >= (unsigned __int64)maxmap )
          {
            if ( maxmap )
            {
              v51 = 2 * maxmap;
              v16 = 32 * maxmap;
            }
            else
            {
              v16 = 1600LL;
              v51 = 100LL;
            }
            v67 = v19;
            v52 = realloc(map, v16, v32, nmap, v19, v20);
            if ( !v52 )
              break;
            map = (__int64)v52;
            v19 = v67;
            maxmap = v51;
          }
          v65 = v19;
          v67 = (u32 *)(j_strlen_ifunc(v21) + 1);
          v33 = j_strlen_ifunc(v27);
          v34 = v67;
          v35 = string_space_act;
          v36 = v33 + 1;
          v37 = string_space;
          v38 = map;
          v39 = v65;
          v67 = (u32 *)((char *)v67 + string_space_act);
          v66 = (unsigned __int64)v67 + v33 + 1;
          if ( v66 > string_space_max )
          {
            v40 = (__int64)v34 + v36;
            v60 = string_space_act;
            v61 = v65;
            if ( (unsigned __int64)v34 + v36 < 0x400 )
              v40 = 1024LL;
            v62 = v33 + 1;
            v63 = v34;
            v65 = (u32 *)string_space;
            v16 = v40 + string_space_max;
            v64 = (u32 *)v16;
            v41 = realloc(string_space, v16, v34, v16, v39, string_space);
            if ( !v41 )
              break;
            v38 = map;
            v42 = (__int64)v64;
            v34 = v63;
            v36 = v62;
            v39 = v61;
            v35 = v60;
            if ( v41 != (__int64 *)v65 && v68 )
            {
              v54 = map + 16 * v68;
              v55 = (char *)v41 - (char *)v65;
              v56 = (_QWORD *)map;
              do
              {
                *v56 += v55;
                v56[1] += v55;
                v56 += 2;
              }
              while ( (_QWORD *)v54 != v56 );
            }
            string_space = (__int64)v41;
            v37 = (__int64)v41;
            string_space_max = v42;
          }
          v64 = v39;
          v63 = (u32 *)v36;
          v65 = (u32 *)v37;
          v43 = (__int64 *)(16 * v68 + v38);
          v44 = j_memcpy(v37 + v35, v21, v34);
          v45 = (__int64)v67;
          v46 = (__int64)v65;
          v16 = (__int64)v27;
          v47 = (__int64)v63;
          *v43 = v44;
          v48 = j_memcpy(v46 + v45, v27, v47);
          v49 = v68;
          v18 = (unsigned int *)v66;
          v43[1] = v48;
          v19 = v64;
          string_space_act = (__int64)v18;
          nmap = v49 + 1;
          ++v69;
        }
      }
LABEL_12:
      if ( !v19 )
      {
        do
        {
          v16 = 400LL;
          if ( !fgets_unlocked((__int64)v70, 400, v13) )
            break;
          v16 = 10LL;
        }
        while ( !j_strchr_ifunc(v70, 10LL) );
      }
    }
    while ( (*(_BYTE *)v13 & 0x10) == 0 );
    fclose((__int64)v13, v16, v17, v18, v19, v20);
    if ( v69 )
      qsort((char *)map, nmap, 0x10uLL, (int (__fastcall *)(char *, char *, __int64))alias_compare, v24, v25);
  }
  return v69;
}
// 405DC2: variable 'v6' is possibly undefined
// 405DC2: variable 'v7' is possibly undefined
// 405DC2: variable 'v8' is possibly undefined
// 405E73: variable 'v17' is possibly undefined
// 405E73: variable 'v18' is possibly undefined
// 405E73: variable 'v19' is possibly undefined
// 405E73: variable 'v20' is possibly undefined
// 405E9C: variable 'v24' is possibly undefined
// 405E9C: variable 'v25' is possibly undefined
// 406246: variable 'v10' is possibly undefined
// 406246: variable 'v11' is possibly undefined
// 406246: variable 'v12' is possibly undefined
// 401040: using guessed type __int64 __fastcall j_memcpy(_QWORD, _QWORD, _QWORD);
// 4010B0: using guessed type __int64 __fastcall j_mempcpy(_QWORD, _QWORD, _QWORD);
// 4010C8: using guessed type __int64 __fastcall j_strlen_ifunc(_QWORD);
// 4010D0: using guessed type __int64 __fastcall j_strchr_ifunc(_QWORD, _QWORD);
// 4AA898: using guessed type __int64 maxmap;
// 4AA8A0: using guessed type __int64 nmap;
// 4AA8A8: using guessed type __int64 string_space_max;
// 4AA8B0: using guessed type __int64 string_space_act;
// 4ABA18: using guessed type __int64 map;
// 4ABA20: using guessed type __int64 string_space;

//----- (0000000000406260) ----------------------------------------------------
__int64 __fastcall nl_expand_alias(__int64 a1, __int64 a2, __int64 a3, __int64 a4, u32 *a5, u32 a6)
{
  unsigned __int64 v8; // r15
  char *v9; // rsi
  char v10; // al
  char v11; // dl
  _BYTE *v12; // rax
  unsigned __int64 v13; // rdi
  char v14; // dl
  char *v15; // rax
  char v16; // dl
  __int64 v17; // rdx
  __int64 v19; // r14
  unsigned __int64 v20; // rbx
  char **v21; // r13
  int v22; // eax

  _ESI = 1;
  if ( !_libc_multiple_threads )
  {
    __asm { cmpxchg cs:lock_0, esi }
    if ( !_libc_multiple_threads )
      goto LABEL_6;
    goto LABEL_5;
  }
  if ( _InterlockedCompareExchange(&lock_0, 1, 0) )
LABEL_5:
    _lll_lock_wait_private((u32 *)&lock_0, 1LL, a3, a4, a5, a6);
LABEL_6:
  if ( !locale_alias_path_10130 )
    locale_alias_path_10130 = (__int64)"/usr/share/locale";
  v8 = nmap;
  if ( nmap )
    goto LABEL_30;
LABEL_9:
  while ( 1 )
  {
    v9 = (char *)locale_alias_path_10130;
    v10 = 0;
    v11 = *(_BYTE *)locale_alias_path_10130;
    if ( !*(_BYTE *)locale_alias_path_10130 )
      break;
    while ( 1 )
    {
      v12 = v9 + 1;
      v13 = (unsigned __int64)v9;
      if ( v11 != 58 )
        break;
      do
      {
        v13 = (unsigned __int64)v12++;
        v14 = *(v12 - 1);
      }
      while ( v14 == 58 );
      if ( v14 )
        break;
      v9 = (char *)v13;
LABEL_17:
      v11 = *v9;
      v10 = 1;
      if ( !*v9 )
        goto LABEL_18;
    }
    v15 = (char *)(v13 + 1);
    do
    {
      v16 = *v15;
      v9 = v15++;
    }
    while ( v16 && v16 != 58 );
    if ( (unsigned __int64)v9 <= v13 )
      goto LABEL_17;
    locale_alias_path_10130 = (__int64)v9;
    if ( read_alias_file(v13, (int)v9 - (int)v13) )
    {
      v8 = nmap;
      if ( nmap )
      {
LABEL_30:
        v19 = map;
        v20 = 0LL;
        while ( 1 )
        {
          v21 = (char **)(v19 + 16 * ((v8 + v20) >> 1));
          v9 = *v21;
          v22 = j_strcasecmp_l(a1, *v21, nl_C_locobj);
          if ( v22 >= 0 )
          {
            if ( !v22 )
            {
              v17 = (__int64)v21[1];
              goto LABEL_21;
            }
            v20 = ((v8 + v20) >> 1) + 1;
          }
          else
          {
            v8 = (v8 + v20) >> 1;
          }
          if ( v8 <= v20 )
            goto LABEL_9;
        }
      }
    }
  }
LABEL_18:
  if ( v10 )
    locale_alias_path_10130 = (__int64)v9;
  v17 = 0LL;
LABEL_21:
  if ( _libc_multiple_threads )
  {
    if ( !_InterlockedDecrement(&lock_0) )
      return v17;
LABEL_25:
    _lll_unlock_wake_private((u32 *)&lock_0, (__int64)v9, v17, a4, a5, a6);
  }
  else if ( --lock_0 )
  {
    goto LABEL_25;
  }
  return v17;
}
// 406373: variable 'a4' is possibly undefined
// 406373: variable 'a5' is possibly undefined
// 406373: variable 'a6' is possibly undefined
// 406383: variable 'v17' is possibly undefined
// 401088: using guessed type __int64 __fastcall j_strcasecmp_l(_QWORD, _QWORD, _QWORD);
// 4A7DE0: using guessed type char **nl_C_locobj[6];
// 4AA890: using guessed type __int64 locale_alias_path_10130;
// 4AA8A0: using guessed type __int64 nmap;
// 4AA8B8: using guessed type int lock_0;
// 4AB820: using guessed type int _libc_multiple_threads;
// 4ABA18: using guessed type __int64 map;

//----- (0000000000406430) ----------------------------------------------------
__int64 *__fastcall nl_make_l10nflist(
        __int64 **a1,
        __int64 a2,
        __int64 a3,
        int a4,
        __int64 a5,
        __int64 a6,
        __int64 a7,
        __int64 a8,
        __int64 a9,
        __int64 a10,
        int a11)
{
  char v12; // r14
  __int64 v13; // rbx
  __int64 v14; // rbp
  int v15; // er13
  __int64 v16; // r12
  __int64 v17; // rbp
  __int64 v18; // r14
  __int64 v19; // rbp
  __int64 v20; // rbx
  __int64 v21; // rbp
  __int64 v22; // r12
  __int64 v23; // r14
  _QWORD *v24; // rdx
  __int64 v25; // rcx
  u32 *v26; // r8
  __int64 v27; // r9
  _QWORD *v28; // rax
  __int64 v29; // rbp
  __int64 v30; // rbx
  _BYTE *v31; // r12
  __int64 v32; // rax
  _BYTE *v33; // rax
  _BYTE *v34; // rax
  _BYTE *v35; // rdi
  __int64 v36; // rsi
  _QWORD *v37; // rdx
  __int64 v38; // rcx
  u32 *v39; // r8
  unsigned __int64 v40; // r9
  __int64 *v41; // r12
  __int64 *v42; // r13
  int v43; // eax
  __int64 v44; // rbx
  __int64 v45; // r12
  __int64 v46; // r14
  __int64 v47; // rax
  _QWORD *v48; // rdx
  __int64 v49; // rcx
  u32 *v50; // r8
  __int64 v51; // r9
  __int64 *v52; // rax
  __int64 v53; // rdx
  __int64 v54; // rcx
  u32 *v55; // r8
  unsigned __int64 v56; // r9
  __int64 v57; // r14
  __int64 v58; // rbp
  __int64 v59; // rax
  _BOOL4 v60; // eax
  __int64 v61; // r13
  __int64 v62; // rbx
  __int64 v63; // rbp
  __int64 v64; // rax
  int v65; // ebx
  __int64 v66; // r14
  int v67; // er13
  __int64 v68; // r10
  __int64 *v69; // r15
  unsigned __int64 v70; // r12
  unsigned __int64 v72; // rbp
  __int64 v73; // rax
  __int64 *v74; // rax
  __int64 v76; // [rsp+0h] [rbp-78h]
  __int64 *v81; // [rsp+30h] [rbp-48h]

  v12 = a4;
  v13 = a3 + 2;
  v14 = j_strlen_ifunc(a5);
  v15 = v12 & 4;
  if ( (v12 & 4) != 0 )
    v16 = j_strlen_ifunc(a6) + 1;
  else
    v16 = 0LL;
  v17 = v13 + v14;
  v18 = 0LL;
  if ( (a4 & 2) != 0 )
    v18 = j_strlen_ifunc(a7) + 1;
  v19 = v16 + v17;
  v20 = 0LL;
  if ( (a4 & 1) != 0 )
    v20 = j_strlen_ifunc(a8) + 1;
  v21 = v18 + v19;
  v22 = 0LL;
  if ( (a4 & 8) != 0 )
    v22 = j_strlen_ifunc(a9) + 1;
  v23 = j_strlen_ifunc(a10);
  v28 = malloc(v23 + v22 + v20 + v21, a2, v24, v25, v26, v27);
  v29 = (__int64)v28;
  if ( !v28 )
    return 0LL;
  j_memcpy(v28, a2, a3);
  if ( a3 )
  {
    v30 = a3;
    v31 = (_BYTE *)v29;
    while ( 1 )
    {
      v32 = j_strlen_ifunc(v31);
      v30 += ~v32;
      if ( !v30 )
        break;
      v33 = &v31[v32];
      v31 = v33 + 1;
      *v33 = 58;
    }
  }
  *(_BYTE *)(v29 + a3 - 1) = 47;
  v34 = (_BYTE *)j_stpcpy(v29 + a3);
  if ( v15 )
  {
    *v34 = 95;
    v34 = (_BYTE *)j_stpcpy(v34 + 1);
  }
  v35 = v34 + 1;
  if ( (a4 & 2) != 0 )
  {
    *v34 = 46;
    v34 = (_BYTE *)j_stpcpy(v35);
    v35 = v34 + 1;
  }
  if ( (a4 & 1) != 0 )
  {
    *v34 = 46;
    v34 = (_BYTE *)j_stpcpy(v35);
    v35 = v34 + 1;
  }
  if ( (a4 & 8) != 0 )
  {
    *v34 = 64;
    v34 = (_BYTE *)j_stpcpy(v35);
    v35 = v34 + 1;
  }
  *v34 = 47;
  v36 = a10;
  j_memcpy(v35, a10, v23 + 1);
  v81 = *a1;
  if ( *a1 )
  {
    v41 = *a1;
    v42 = 0LL;
    while ( 1 )
    {
      if ( *v41 )
      {
        v36 = v29;
        v43 = j_strcmp_ifunc(*v41, v29);
        if ( !v43 )
          goto LABEL_60;
        if ( v43 < 0 )
          goto LABEL_29;
        v42 = v41;
      }
      v41 = (__int64 *)v41[3];
      if ( !v41 )
        goto LABEL_29;
    }
  }
  v42 = 0LL;
LABEL_29:
  if ( a11 )
  {
    v44 = a3;
    v45 = 0LL;
    v46 = a2;
    if ( a3 )
    {
      do
      {
        ++v45;
        v47 = j_strlen_ifunc(v46);
        v46 += v47 + 1;
        v44 += ~v47;
      }
      while ( v44 );
      v52 = malloc(
              8
            * (1 << ((((((a4 & 0x55) + ((a4 >> 1) & 0x55)) & 0x33)
                     + (((int)((a4 & 0x5555) + ((a4 >> 1) & 0xFFFFD555)) >> 2) & 0x33)
                     + ((int)((((a4 & 0x5555) + ((a4 >> 1) & 0xFFFFD555)) & 0x3333)
                            + (((int)((a4 & 0x5555) + ((a4 >> 1) & 0xFFFFD555)) >> 2) & 0xFFFFF333)) >> 4)) & 0xF)
                   + ((unsigned __int16)(((((a4 & 0x5555) + ((a4 >> 1) & 0xD555)) & 0x3333)
                                        + (((int)((a4 & 0x5555) + ((a4 >> 1) & 0xFFFFD555)) >> 2) & 0xF333)
                                        + ((int)((((a4 & 0x5555) + ((a4 >> 1) & 0xFFFFD555)) & 0x3333)
                                               + (((int)((a4 & 0x5555) + ((a4 >> 1) & 0xFFFFD555)) >> 2) & 0xFFFFF333)) >> 4)) & 0xF0F) >> 8)))
            * v45
            + 40,
              v36,
              v48,
              v49,
              v50,
              v51);
      v41 = v52;
      if ( v52 )
      {
        v57 = a2;
        *v52 = v29;
        v58 = a3;
        do
        {
          ++v44;
          v59 = j_strlen_ifunc(v57);
          v57 += v59 + 1;
          v58 += ~v59;
        }
        while ( v58 );
        v60 = 1;
        if ( v44 == 1 )
          v60 = (a4 & 3) == 3;
        goto LABEL_37;
      }
    }
    else
    {
      v74 = malloc(
              0x28uLL,
              v36,
              v37,
              (((((a4 & 0x5555) + ((a4 >> 1) & 0xD555)) & 0x3333)
              + (((int)((a4 & 0x5555) + ((a4 >> 1) & 0xFFFFD555)) >> 2) & 0xF333)
              + (unsigned __int16)((int)((((a4 & 0x5555) + ((a4 >> 1) & 0xFFFFD555)) & 0x3333)
                                       + (((int)((a4 & 0x5555) + ((a4 >> 1) & 0xFFFFD555)) >> 2) & 0xFFFFF333)) >> 4)) & 0xF0Fu)
            + ((((((a4 & 0x5555) + ((a4 >> 1) & 0xD555)) & 0x3333)
               + (((int)((a4 & 0x5555) + ((a4 >> 1) & 0xFFFFD555)) >> 2) & 0xF333)
               + (unsigned __int16)((int)((((a4 & 0x5555) + ((a4 >> 1) & 0xFFFFD555)) & 0x3333)
                                        + (((int)((a4 & 0x5555) + ((a4 >> 1) & 0xFFFFD555)) >> 2) & 0xFFFFF333)) >> 4)) & 0xF0F) >> 8),
              v39,
              v40);
      v41 = v74;
      if ( v74 )
      {
        *v74 = v29;
        v60 = 1;
LABEL_37:
        *((_DWORD *)v41 + 2) = v60;
        v41[2] = 0LL;
        if ( v42 )
        {
          v41[3] = v42[3];
          v42[3] = (__int64)v41;
        }
        else
        {
          v41[3] = (__int64)v81;
          *a1 = v41;
        }
        if ( a3 )
        {
          v61 = a2;
          v62 = a3;
          v63 = 0LL;
          do
          {
            ++v63;
            v64 = j_strlen_ifunc(v61);
            v61 += v64 + 1;
            v62 += ~v64;
          }
          while ( v62 );
          v65 = a4 - (v63 == 1);
        }
        else
        {
          v65 = a4;
        }
        v66 = 0LL;
        v67 = ~a4;
        v68 = a2 + a3;
        if ( v65 >= 0 )
        {
          v76 = a3;
          v69 = v41;
          v70 = v68;
          do
          {
            if ( (v67 & v65) == 0 )
            {
              while ( v76 )
              {
                v72 = a2;
                while ( 1 )
                {
                  ++v66;
                  v73 = j_strlen_ifunc(v72);
                  v69[v66 + 3] = (__int64)nl_make_l10nflist(a1, v72, v73 + 1, v65, a5, a6, a7, a8, a9, a10, 1);
                  if ( !v72 )
                    break;
                  if ( v72 < v70 )
                  {
                    v72 += j_strlen_ifunc(v72) + 1;
                    if ( v72 < v70 )
                    {
                      if ( v72 )
                        continue;
                    }
                  }
                  goto LABEL_46;
                }
              }
            }
LABEL_46:
            --v65;
          }
          while ( v65 != -1 );
          v41 = v69;
        }
        v41[v66 + 4] = 0LL;
        return v41;
      }
    }
    v41 = 0LL;
    free(v29, v36, v53, v54, v55, v56);
    return v41;
  }
  v41 = 0LL;
LABEL_60:
  free(v29, v36, (__int64)v37, v38, v39, v40);
  return v41;
}
// 40650B: variable 'v24' is possibly undefined
// 40650B: variable 'v25' is possibly undefined
// 40650B: variable 'v26' is possibly undefined
// 40650B: variable 'v27' is possibly undefined
// 40669F: variable 'v48' is possibly undefined
// 40669F: variable 'v49' is possibly undefined
// 40669F: variable 'v50' is possibly undefined
// 40669F: variable 'v51' is possibly undefined
// 4068F3: variable 'v37' is possibly undefined
// 4068F3: variable 'v38' is possibly undefined
// 4068F3: variable 'v39' is possibly undefined
// 4068F3: variable 'v40' is possibly undefined
// 40693E: variable 'v53' is possibly undefined
// 40693E: variable 'v54' is possibly undefined
// 40693E: variable 'v55' is possibly undefined
// 40693E: variable 'v56' is possibly undefined
// 401040: using guessed type __int64 __fastcall j_memcpy(_QWORD, _QWORD, _QWORD);
// 401058: using guessed type __int64 __fastcall j_stpcpy(_QWORD);
// 4010A0: using guessed type __int64 __fastcall j_strcmp_ifunc(_QWORD, _QWORD);
// 4010C8: using guessed type __int64 __fastcall j_strlen_ifunc(_QWORD);

//----- (0000000000406950) ----------------------------------------------------
_DWORD *__fastcall nl_normalize_codeset(
        unsigned __int8 *a1,
        unsigned __int64 a2,
        _QWORD *a3,
        __int64 a4,
        u32 *a5,
        __int64 a6)
{
  unsigned __int8 *v8; // rdx
  u32 *v9; // r8
  __int64 v10; // rsi
  __int64 v11; // rdi
  __int64 v12; // rcx
  _DWORD *result; // rax
  _BYTE *v14; // rdi
  unsigned __int64 v15; // rdx
  __int64 v16; // r8

  if ( a2 )
  {
    v8 = a1;
    v9 = (u32 *)&a1[a2];
    v10 = 1LL;
    v11 = 0LL;
    do
    {
      v12 = *v8;
      if ( (word_486FE0[v12] & 8) != 0 )
      {
        ++v11;
        if ( (unsigned int)(v12 - 48) >= 0xA )
          v10 = 0LL;
      }
      ++v8;
    }
    while ( v9 != (u32 *)v8 );
    if ( (_DWORD)v10 )
    {
      result = malloc(v11 + 4, v10, v8, v12, v9, 0LL);
      if ( result )
      {
        *result = 7304041;
        v14 = (char *)result + 3;
        goto LABEL_9;
      }
    }
    else
    {
      result = malloc(v11 + 1, v10, v8, v12, v9, 0LL);
      v14 = result;
      if ( result )
      {
LABEL_9:
        v15 = 0LL;
        while ( 1 )
        {
          while ( 1 )
          {
            v16 = a1[v15];
            if ( (word_486FE0[v16] & 0x400) == 0 )
              break;
            *v14++ = dword_4860E0[v16];
LABEL_11:
            if ( a2 <= ++v15 )
              goto LABEL_15;
          }
          if ( (unsigned int)(unsigned __int8)v16 - 48 > 9 )
            goto LABEL_11;
          ++v15;
          *v14++ = v16;
          if ( a2 <= v15 )
            goto LABEL_15;
        }
      }
    }
    return 0LL;
  }
  result = malloc(4uLL, 0LL, a3, a4, a5, a6);
  if ( !result )
    return 0LL;
  *result = 7304041;
  v14 = (char *)result + 3;
LABEL_15:
  *v14 = 0;
  return result;
}
// 4860E0: using guessed type _DWORD dword_4860E0[256];
// 486FE0: using guessed type _WORD word_486FE0[256];

//----- (0000000000406A60) ----------------------------------------------------
__int64 __fastcall nl_explode_name(
        unsigned __int8 *a1,
        unsigned __int8 **a2,
        _QWORD *a3,
        unsigned __int8 **a4,
        _QWORD *a5,
        _QWORD *a6)
{
  unsigned __int8 v6; // al
  unsigned __int8 *v7; // rsi
  unsigned __int8 v8; // al
  unsigned __int8 *v9; // rbx
  unsigned int v10; // er12
  unsigned __int8 *v12; // rsi
  unsigned __int8 *v13; // rdi
  unsigned __int8 *i; // rbp
  _DWORD *v15; // rax
  __int64 v16; // r14
  __int64 v17; // rsi
  int v18; // eax
  unsigned __int64 v19; // r9
  _QWORD *v21; // [rsp+8h] [rbp-40h]
  unsigned __int8 **v22; // [rsp+10h] [rbp-38h]
  _QWORD *v23; // [rsp+18h] [rbp-30h]

  *a3 = 0LL;
  *a4 = 0LL;
  *a5 = 0LL;
  *a6 = 0LL;
  *a2 = a1;
  v6 = *a1;
  if ( (*a1 & 0xBF) == 0 || v6 == 95 || v6 == 46 )
  {
LABEL_21:
    v10 = 0;
  }
  else
  {
    v7 = a1;
    while ( 1 )
    {
      v8 = v7[1];
      v9 = v7 + 1;
      if ( !v8 || v8 == 95 )
        break;
      ++v7;
      if ( v8 == 46 || v8 == 64 )
      {
        if ( a1 == v9 )
          goto LABEL_21;
        goto LABEL_10;
      }
    }
    if ( a1 == v9 )
      goto LABEL_21;
    if ( v8 != 95 )
    {
LABEL_10:
      v10 = 0;
      if ( v8 != 46 )
        goto LABEL_11;
      goto LABEL_29;
    }
    v12 = v7 + 2;
    *v9 = 0;
    *a4 = v12;
    v8 = v9[1];
    if ( (v8 & 0xBF) != 0 )
    {
      do
      {
        if ( v8 == 46 )
          break;
        v8 = *++v12;
      }
      while ( (*v12 & 0xBF) != 0 );
    }
    v9 = v12;
    v10 = 4;
    if ( v8 != 46 )
      goto LABEL_11;
LABEL_29:
    v13 = v9 + 1;
    *v9 = 0;
    *a5 = v9 + 1;
    v8 = v9[1];
    if ( (v8 & 0xBF) != 0 )
    {
      for ( i = v9 + 1; ; ++i )
      {
        v9 = i + 1;
        if ( (i[1] & 0xBF) == 0 )
          break;
      }
      if ( v13 == v9 )
      {
        v10 |= 2u;
      }
      else
      {
        v23 = a5;
        v22 = a4;
        v21 = a3;
        v15 = nl_normalize_codeset(v13, v9 - v13, a3, (__int64)a4, (u32 *)a5, (__int64)a6);
        v16 = (__int64)v15;
        *a6 = v15;
        if ( !v15 )
          return (unsigned int)-1;
        v17 = (__int64)v15;
        v18 = j_strcmp_ifunc(*v23, v15);
        a5 = v23;
        a3 = v21;
        a4 = v22;
        if ( v18 )
        {
          v10 |= 3u;
          v8 = i[1];
        }
        else
        {
          v10 |= 2u;
          free(v16, v17, (__int64)v21, (__int64)v22, (u32 *)v23, v19);
          v8 = i[1];
          a3 = v21;
          a4 = v22;
          a5 = v23;
        }
      }
    }
    else
    {
      v10 |= 2u;
      ++v9;
    }
LABEL_11:
    if ( v8 == 64 )
    {
      *v9 = 0;
      *a3 = v9 + 1;
      if ( v9[1] )
        v10 |= 8u;
    }
  }
  if ( *a4 && !**a4 )
    v10 &= ~4u;
  if ( *a5 && !*(_BYTE *)*a5 )
    v10 &= ~2u;
  return v10;
}
// 406C45: variable 'v19' is possibly undefined
// 4010A0: using guessed type __int64 __fastcall j_strcmp_ifunc(_QWORD, _QWORD);

//----- (0000000000406C80) ----------------------------------------------------
void __fastcall _gettext_free_exp(int *a1, __int64 a2, __int64 a3, __int64 a4, u32 *a5, unsigned __int64 a6)
{
  int v6; // eax
  __int64 v7; // rdx
  __int64 v8; // rcx
  u32 *v9; // r8
  unsigned __int64 v10; // r9

  if ( a1 )
  {
    v6 = *a1;
    if ( *a1 != 2 )
    {
      if ( v6 != 3 )
      {
        if ( v6 != 1 )
        {
          free((__int64)a1, a2, a3, a4, a5, a6);
          return;
        }
        goto LABEL_8;
      }
      _gettext_free_exp(*((int **)a1 + 3), a2, a3, a4, a5, a6);
    }
    _gettext_free_exp(*((int **)a1 + 2), a2, a3, a4, a5, a6);
LABEL_8:
    _gettext_free_exp(*((int **)a1 + 1), a2, a3, a4, a5, a6);
    free((__int64)a1, a2, v7, v8, v9, v10);
  }
}
// 406CBD: variable 'a3' is possibly undefined
// 406CBD: variable 'a4' is possibly undefined
// 406CBD: variable 'a5' is possibly undefined
// 406CBD: variable 'a6' is possibly undefined
// 406CCF: variable 'v7' is possibly undefined
// 406CCF: variable 'v8' is possibly undefined
// 406CCF: variable 'v9' is possibly undefined
// 406CCF: variable 'v10' is possibly undefined

//----- (0000000000406CE0) ----------------------------------------------------
int *__fastcall new_exp(int a1, __int64 a2, _QWORD *a3, __int64 a4, u32 *a5, unsigned __int64 a6)
{
  __int64 i; // rbx
  int *v8; // r12
  __int64 v9; // r13
  __int64 v10; // rax
  int *result; // rax
  __int64 v12; // r12

  if ( !a1 )
  {
    result = (int *)malloc(0x20uLL, a2, a3, a4, a5, a6);
    if ( result )
    {
      *result = 0;
      result[1] = a2;
      return result;
    }
    return 0LL;
  }
  LODWORD(i) = a1 - 2;
  v8 = (int *)a3[a1 - 1];
  v9 = a1 - 2;
  v10 = v9;
  if ( !v8 )
    goto LABEL_10;
  while ( (_DWORD)v10 != -1 )
  {
    if ( !a3[v10--] )
      goto LABEL_10;
  }
  result = (int *)malloc(0x20uLL, a2, a3, a4, a5, a6);
  if ( !result )
  {
LABEL_10:
    for ( i = (int)i; ; --i )
    {
      _gettext_free_exp(v8, a2, (__int64)a3, a4, a5, a6);
      if ( (_DWORD)i == -1 )
        break;
      v8 = (int *)a3[i];
    }
    return 0LL;
  }
  *result = a1;
  result[1] = a2;
  *(_QWORD *)&result[2 * (int)i + 4] = v8;
  if ( a1 != 1 )
  {
    do
    {
      v12 = a3[v9--];
      *(_QWORD *)&result[2 * v9 + 4] = v12;
    }
    while ( (_DWORD)v9 != -1 );
  }
  return result;
}
// 406D8C: variable 'a3' is possibly undefined
// 406D8C: variable 'a4' is possibly undefined
// 406D8C: variable 'a5' is possibly undefined
// 406D8C: variable 'a6' is possibly undefined

//----- (0000000000406DD0) ----------------------------------------------------
__int64 __fastcall _gettextparse(
        unsigned __int8 **a1,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        unsigned __int8 *a6)
{
  int v6; // er15
  unsigned __int64 v7; // rbp
  char *v8; // rbx
  unsigned __int8 *v9; // r8
  __int16 *v10; // r14
  __int64 v11; // rcx
  unsigned int v12; // edx
  int v13; // eax
  __int16 *v14; // rdx
  unsigned __int64 v15; // rax
  unsigned __int64 v16; // rdx
  __int64 v17; // rbx
  _QWORD *v18; // rax
  __int64 v19; // r14
  __int64 v20; // rdx
  __int64 v21; // rbx
  __int64 v22; // rax
  char *v23; // r10
  unsigned int v24; // ebx
  int v25; // eax
  unsigned int v26; // eax
  __int64 v28; // rax
  char *v29; // rdi
  unsigned __int8 v30; // al
  __int64 v31; // rdx
  char *v32; // [rsp+8h] [rbp-870h]
  __int64 v33; // [rsp+8h] [rbp-870h]
  int v34; // [rsp+18h] [rbp-860h]
  int v35; // [rsp+1Ch] [rbp-85Ch]
  unsigned __int8 *v36; // [rsp+20h] [rbp-858h]
  unsigned __int8 *v37; // [rsp+20h] [rbp-858h]
  u32 *v38; // [rsp+28h] [rbp-850h]
  __int64 v40; // [rsp+38h] [rbp-840h]
  __int16 v41[200]; // [rsp+60h] [rbp-818h] BYREF
  char v42[1608]; // [rsp+1F0h] [rbp-688h] BYREF
  unsigned __int64 v43; // [rsp+838h] [rbp-40h]

  v6 = 0;
  v7 = 200LL;
  v8 = v42;
  v43 = __readfsqword(0x28u);
  v41[0] = 0;
  v35 = 0;
  v9 = (unsigned __int8 *)v41;
  v10 = v41;
  v34 = -2;
  v32 = v42;
  while ( 1 )
  {
    v11 = v6;
    v12 = yypact[v6];
    if ( v12 == -10 )
      goto LABEL_22;
    if ( v34 == -2 )
    {
      a2 = (__int64)*a1;
      v30 = **a1;
      if ( !v30 )
        goto LABEL_54;
      if ( v30 == 9 || v30 == 32 )
      {
        while ( 1 )
        {
          v30 = *(_BYTE *)++a2;
          if ( !*(_BYTE *)a2 )
            break;
          if ( v30 != 32 && v30 != 9 )
            goto LABEL_52;
        }
LABEL_54:
        v34 = 0;
        *a1 = (unsigned __int8 *)a2;
        v13 = 0;
        goto LABEL_7;
      }
LABEL_52:
      a6 = (unsigned __int8 *)(a2 + 1);
      if ( v30 <= 0x7Cu )
        __asm { jmp     rdi }
      v34 = 256;
      *a1 = a6;
      v13 = 1;
    }
    else
    {
      a2 = (unsigned int)v34;
      if ( v34 <= 0 )
      {
        v13 = 0;
        v34 = 0;
        goto LABEL_7;
      }
      a2 = (__int64)yytranslate;
      v13 = yytranslate[v34];
    }
    v12 += v13;
LABEL_7:
    if ( v12 <= 0x36 )
    {
      a2 = (unsigned int)yycheck[v12];
      if ( (_DWORD)a2 == v13 )
      {
        v6 = yytable[v12];
        if ( yytable[v12] )
        {
          v34 = -2;
          v14 = v10;
          v8 += 8;
          v35 = (v35 == 0) + v35 - 1;
          *(_QWORD *)v8 = v40;
          goto LABEL_11;
        }
        v28 = *((_QWORD *)v8 + 1);
        v14 = v10;
        v29 = v8;
        a2 = 4294967280LL;
        goto LABEL_41;
      }
    }
LABEL_22:
    v16 = yydefact[v6];
    if ( !yydefact[v6] )
    {
      if ( v35 == 3 )
      {
        if ( v34 > 0 )
        {
          v34 = -2;
          goto LABEL_30;
        }
        if ( !v34 )
        {
          v10 = (__int16 *)v9;
          v24 = 1;
          goto LABEL_35;
        }
      }
      while ( 1 )
      {
LABEL_30:
        v25 = yypact[v11];
        if ( v25 == -10 )
          goto LABEL_28;
        v26 = v25 + 1;
        if ( v26 > 0x36 )
          goto LABEL_28;
        if ( yycheck[v26] == 1 )
          break;
        if ( v10 == (__int16 *)v9 )
        {
LABEL_34:
          v24 = 1;
          goto LABEL_35;
        }
LABEL_29:
        v11 = *--v10;
        v8 -= 8;
      }
      v6 = yytable[v26];
      if ( yytable[v26] )
      {
        v8 += 8;
        v14 = v10;
        v35 = 3;
        *(_QWORD *)v8 = v40;
        goto LABEL_11;
      }
LABEL_28:
      if ( v10 == (__int16 *)v9 )
        goto LABEL_34;
      goto LABEL_29;
    }
    v28 = *(_QWORD *)&v8[8 * (1 - yyr2[yydefact[v6]])];
    if ( (unsigned __int8)v16 <= 0xDu )
      __asm { jmp     rdx }
    v31 = yyr2[yydefact[v6]];
    a2 = (unsigned int)yyr1[yydefact[v6]] - 16;
    v6 = yypgoto[(int)a2];
    v29 = &v8[-8 * v31];
    v14 = &v10[-v31];
LABEL_41:
    *((_QWORD *)v29 + 1) = v28;
    v8 = v29 + 8;
    v11 = (unsigned int)(*v14 + v6);
    if ( (unsigned int)v11 <= 0x36 && (v11 = (int)v11, *v14 == yycheck[(int)v11]) )
    {
      v6 = yytable[(int)v11];
    }
    else
    {
      a2 = (int)a2;
      v6 = yydefgoto[(int)a2];
    }
LABEL_11:
    v15 = 2 * v7;
    v10 = v14 + 1;
    v14[1] = v6;
    v16 = (unsigned __int64)&v9[2 * v7 - 2];
    if ( (unsigned __int64)v10 < v16 )
      goto LABEL_20;
    v17 = (((char *)v10 - (char *)v9) >> 1) + 1;
    if ( v7 > 0x270F )
      break;
    v7 = 10000LL;
    v36 = v9;
    if ( v15 <= 0x2710 )
      v7 = v15;
    v18 = malloc(10 * v7 + 7, a2, (_QWORD *)v16, v11, (u32 *)v9, (__int64)a6);
    v9 = v36;
    if ( !v18 )
      break;
    v19 = 2 * v17;
    v38 = (u32 *)v36;
    v20 = 2 * v17;
    v21 = 8 * v17;
    a2 = (__int64)v32;
    v37 = (unsigned __int8 *)j_memcpy(v18, v36, v20);
    v22 = j_memcpy(&v37[2 * v7], v32, v21);
    v9 = (unsigned __int8 *)v38;
    v23 = (char *)v22;
    a6 = v37;
    if ( v38 != (u32 *)v41 )
    {
      v33 = v22;
      free((__int64)v38, a2, v16, v11, v38, (unsigned __int64)v37);
      a6 = v37;
      v23 = (char *)v33;
    }
    v10 = (__int16 *)&a6[v19 - 2];
    v8 = &v23[v21 - 8];
    if ( v10 >= (__int16 *)&a6[2 * v7 - 2] )
    {
      v10 = (__int16 *)a6;
      v24 = 1;
      goto LABEL_36;
    }
    v32 = v23;
    v9 = a6;
LABEL_20:
    if ( v6 == 9 )
    {
      v10 = (__int16 *)v9;
      v24 = 0;
      goto LABEL_35;
    }
  }
  v10 = (__int16 *)v9;
  v24 = 2;
LABEL_35:
  if ( v10 != v41 )
LABEL_36:
    free((__int64)v10, a2, v16, v11, (u32 *)v9, (unsigned __int64)a6);
  return v24;
}
// 406ED4: variable 'v40' is possibly undefined
// 406F8B: variable 'v16' is possibly undefined
// 406F8B: variable 'v11' is possibly undefined
// 407069: variable 'v9' is possibly undefined
// 407069: variable 'a6' is possibly undefined
// 401040: using guessed type __int64 __fastcall j_memcpy(_QWORD, _QWORD, _QWORD);
// 4805B0: using guessed type unsigned __int8 yyr2[16];
// 4805C0: using guessed type unsigned __int8 yyr1[32];
// 480620: using guessed type unsigned __int8 yytable[55];
// 480660: using guessed type unsigned __int8 yydefact[32];
// 4806A0: using guessed type unsigned __int8 yytranslate[263];

//----- (0000000000407670) ----------------------------------------------------
unsigned __int64 __fastcall _gettext_extract_plural(__int64 a1, unsigned __int8 **a2, unsigned __int64 *a3)
{
  __int64 v4; // r12
  __int64 v5; // rax
  char *v6; // r13
  unsigned __int8 v7; // al
  unsigned __int64 v8; // rcx
  unsigned __int64 v9; // rax
  __int64 v10; // rdx
  __int64 v11; // rcx
  __int64 v12; // r8
  unsigned __int8 *v13; // r9
  char *v15; // [rsp+8h] [rbp-50h] BYREF
  unsigned __int8 *v16[3]; // [rsp+10h] [rbp-48h] BYREF
  unsigned __int64 v17; // [rsp+28h] [rbp-30h]

  v17 = __readfsqword(0x28u);
  if ( !a1 )
    goto LABEL_12;
  v4 = j_strstr(a1, "plural=");
  v5 = j_strstr(a1, "nplurals=");
  if ( !v4 )
    goto LABEL_12;
  if ( !v5 )
    goto LABEL_12;
  v6 = (char *)(v5 + 9);
  v7 = *(_BYTE *)(v5 + 9);
  if ( !v7 )
    goto LABEL_12;
  v8 = __readfsqword(0xFFFFFFF0);
  while ( (*(_BYTE *)(v8 + 2LL * v7 + 1) & 0x20) != 0 )
  {
    v7 = *++v6;
    if ( !*v6 )
      goto LABEL_12;
  }
  if ( (unsigned __int8)(v7 - 48) <= 9u
    && (v9 = strtouq(v6, &v15, 10), v15 != v6)
    && (*a3 = v9,
        v16[0] = (unsigned __int8 *)(v4 + 7),
        !(unsigned int)_gettextparse(v16, (__int64)&v15, v10, v11, v12, v13)) )
  {
    *a2 = v16[1];
  }
  else
  {
LABEL_12:
    *a2 = (unsigned __int8 *)&_gettext_germanic_plural;
    *a3 = 2LL;
  }
  return __readfsqword(0x28u) ^ v17;
}
// 407730: variable 'v10' is possibly undefined
// 407730: variable 'v11' is possibly undefined
// 407730: variable 'v12' is possibly undefined
// 407730: variable 'v13' is possibly undefined
// 401070: using guessed type __int64 __fastcall j_strstr(_QWORD, _QWORD);

//----- (0000000000407780) ----------------------------------------------------
unsigned __int64 __fastcall _hash_string(unsigned __int8 *a1)
{
  unsigned __int64 result; // rax
  __int64 v2; // rdx

  result = 0LL;
  while ( 1 )
  {
    v2 = *a1;
    if ( !(_BYTE)v2 )
      break;
    while ( 1 )
    {
      ++a1;
      result = v2 + 16 * result;
      if ( (result & 0xF0000000) == 0 )
        break;
      result = ((unsigned __int64)((unsigned int)result & 0xF0000000) >> 24) ^ result & 0xFFFFFFFF0FFFFFFFLL;
      v2 = *a1;
      if ( !(_BYTE)v2 )
        return result;
    }
  }
  return result;
}

//----- (00000000004077C0) ----------------------------------------------------
int setjmp(jmp_buf env)
{
  __int64 v1; // rdx
  __int64 v2; // rcx
  __int64 v3; // r8
  __int64 v4; // r9
  char v6; // [rsp+8h] [rbp+8h]

  return _sigsetjmp(env, 0, v1, v2, v3, v4, v6);
}
// 4077C6: variable 'v1' is possibly undefined
// 4077C6: variable 'v2' is possibly undefined
// 4077C6: variable 'v3' is possibly undefined
// 4077C6: variable 'v4' is possibly undefined

//----- (00000000004077D0) ----------------------------------------------------
__int64 __fastcall raise(int sig)
{
  signed __int64 v2; // rax
  pid_t v3; // edi
  signed __int64 v4; // rax
  unsigned __int64 v5; // rax
  sigset_t *v6; // r9
  signed __int64 v7; // rax
  unsigned int v8; // er8
  sigset_t v10; // [rsp+0h] [rbp-118h] BYREF
  sigset_t nset; // [rsp+80h] [rbp-98h] BYREF
  unsigned __int64 v12; // [rsp+108h] [rbp-10h]

  v12 = __readfsqword(0x28u);
  memset(&nset.__val[1], 255, 120);
  nset.__val[0] = 0xFFFFFFFE7FFFFFFFLL;
  v2 = sys_rt_sigprocmask(0, &nset, &v10, 8uLL);
  v3 = sys_getpid();
  v4 = sys_gettid();
  v5 = sys_tgkill(v3, v4, sig);
  if ( v5 > 0xFFFFFFFFFFFFF000LL )
    __writefsdword(0xFFFFFFC0, -(int)v5);
  v7 = sys_rt_sigprocmask(2, v6, 0LL, 8uLL);
  return v8;
}
// 4078DD: variable 'v6' is possibly undefined
// 4078F0: variable 'v8' is possibly undefined

//----- (0000000000407920) ----------------------------------------------------
__int64 __fastcall msort_with_tmp_part_0(__int64 *a1, _QWORD *a2, unsigned __int64 a3)
{
  unsigned __int64 v3; // r12
  unsigned __int64 v4; // rbp
  _QWORD *v5; // rbx
  _QWORD *v6; // r13
  _QWORD *v7; // r15
  __int64 v8; // r14
  bool v9; // dl
  __int64 v10; // rax
  int v12; // eax
  _QWORD *v13; // r8
  _QWORD *v14; // rsi
  __int64 v15; // rax
  _QWORD *v16; // rsi
  _QWORD *v17; // rsi
  int v18; // eax
  __int64 v19; // rax
  int (__fastcall *v20)(_QWORD *, _QWORD *, __int64); // [rsp+0h] [rbp-68h]
  __int64 v21; // [rsp+8h] [rbp-60h]

  v3 = a3 >> 1;
  v4 = a3 - (a3 >> 1);
  v5 = (_QWORD *)((char *)a2 + (a3 >> 1) * *a1);
  if ( a3 > 3 )
    msort_with_tmp_part_0(a1, a2, a3 >> 1);
  if ( v4 > 1 )
    msort_with_tmp_part_0(a1, v5, v4);
  v6 = a2;
  v7 = (_QWORD *)a1[4];
  v8 = *a1;
  v9 = v4 != 0 && v3 != 0;
  v20 = (int (__fastcall *)(_QWORD *, _QWORD *, __int64))a1[2];
  v10 = a1[1];
  v21 = a1[3];
  if ( v10 == 1 )
  {
    if ( v9 )
    {
      do
      {
        if ( v20(v6, v5, v21) > 0 )
        {
          v19 = *v5;
          --v4;
          ++v5;
        }
        else
        {
          v19 = *v6;
          --v3;
          ++v6;
        }
        *v7++ = v19;
      }
      while ( v3 && v4 );
    }
  }
  else if ( v10 )
  {
    if ( v10 == 2 )
    {
      while ( v3 && v4 )
      {
        v12 = v20(v6, v5, v21);
        v13 = (_QWORD *)((char *)v7 + v8);
        if ( v12 <= 0 )
        {
          v14 = v6;
          --v3;
          v6 = (_QWORD *)((char *)v6 + v8);
        }
        else
        {
          v14 = v5;
          --v4;
          v5 = (_QWORD *)((char *)v5 + v8);
        }
        if ( (_QWORD *)((char *)v7 + v8) <= v7 )
        {
          v7 = (_QWORD *)((char *)v7 + v8);
        }
        else
        {
          do
            *v7++ = *v14++;
          while ( v13 > v7 );
          v7 = v13;
        }
      }
    }
    else if ( v10 == 3 )
    {
      if ( v9 )
      {
        do
        {
          if ( v20((_QWORD *)*v6, (_QWORD *)*v5, v21) > 0 )
          {
            v15 = *v5;
            --v4;
            ++v5;
          }
          else
          {
            v15 = *v6;
            --v3;
            ++v6;
          }
          *v7++ = v15;
        }
        while ( v3 && v4 );
      }
    }
    else
    {
LABEL_27:
      if ( v3 )
      {
        while ( v4 )
        {
          if ( v20(v6, v5, v21) <= 0 )
          {
            v16 = v6;
            v6 = (_QWORD *)((char *)v6 + v8);
            --v3;
            v7 = (_QWORD *)j_mempcpy(v7, v16, v8);
            goto LABEL_27;
          }
          v17 = v5;
          v5 = (_QWORD *)((char *)v5 + v8);
          --v4;
          v7 = (_QWORD *)j_mempcpy(v7, v17, v8);
        }
      }
    }
  }
  else if ( v9 )
  {
    do
    {
      if ( v20(v6, v5, v21) > 0 )
      {
        v18 = *(_DWORD *)v5;
        --v4;
        v5 = (_QWORD *)((char *)v5 + 4);
      }
      else
      {
        v18 = *(_DWORD *)v6;
        --v3;
        v6 = (_QWORD *)((char *)v6 + 4);
      }
      *(_DWORD *)v7 = v18;
      v7 = (_QWORD *)((char *)v7 + 4);
    }
    while ( v3 && v4 );
  }
  if ( v3 )
    j_memcpy(v7, v6, v8 * v3);
  return j_memcpy(a2, a1[4], v8 * (a3 - v4));
}
// 407B27: conditional instruction was optimized away because r12.8!=0
// 401040: using guessed type __int64 __fastcall j_memcpy(_QWORD, _QWORD, _QWORD);
// 4010B0: using guessed type __int64 __fastcall j_mempcpy(_QWORD, _QWORD, _QWORD);

//----- (0000000000407C20) ----------------------------------------------------
unsigned __int64 __fastcall qsort_r(
        char *a1,
        __int64 a2,
        unsigned __int64 a3,
        int (__fastcall *a4)(char *, char *, __int64),
        u32 *a5,
        unsigned __int64 a6)
{
  unsigned __int64 v9; // r12
  __int64 *v10; // rdx
  void *v11; // rsp
  int v12; // edx
  unsigned __int64 v13; // rax
  unsigned __int64 v14; // rdx
  _QWORD *v15; // rax
  unsigned __int64 v16; // rsi
  unsigned __int64 v17; // r15
  char *v18; // rdx
  unsigned __int64 v19; // rax
  __int64 v20; // rdx
  char *v21; // rbx
  char *v22; // r12
  char *v23; // rdi
  unsigned __int64 v24; // rsi
  unsigned __int64 v25; // rax
  unsigned __int64 v26; // r13
  char **v27; // rdx
  __int64 v29; // rax
  __int64 v30; // rdx
  __int64 v31; // [rsp+0h] [rbp-1098h]
  __int64 v32; // [rsp+8h] [rbp-1090h] BYREF
  __int64 v33; // [rsp+10h] [rbp-1088h] BYREF
  __int64 v34; // [rsp+1008h] [rbp-90h] BYREF
  _QWORD *v35; // [rsp+1010h] [rbp-88h]
  unsigned __int64 v36; // [rsp+1018h] [rbp-80h]
  unsigned __int64 v37; // [rsp+1020h] [rbp-78h]
  char *v38; // [rsp+1028h] [rbp-70h]
  unsigned __int64 v39; // [rsp+1030h] [rbp-68h]
  unsigned __int64 v40; // [rsp+1038h] [rbp-60h] BYREF
  __int64 v41; // [rsp+1040h] [rbp-58h]
  int (__fastcall *v42)(char *, char *, __int64); // [rsp+1048h] [rbp-50h]
  u32 *v43; // [rsp+1050h] [rbp-48h]
  __int64 *v44; // [rsp+1058h] [rbp-40h]
  unsigned __int64 v45; // [rsp+1060h] [rbp-38h]

  v38 = a1;
  v37 = a2;
  v45 = __readfsqword(0x28u);
  if ( a3 > 0x20 )
  {
    v9 = a3 + 16 * v37;
  }
  else
  {
    a2 *= a3;
    v9 = a2;
  }
  if ( v9 > 0x3FF )
  {
    v12 = pagesize_8690;
    if ( !pagesize_8690 )
    {
      v29 = sysconf(85, a2, pagesize_8690);
      v30 = 0x1FFFFFFFFFFFFFFFLL;
      if ( v29 != -1 )
        v30 = v29 / 4;
      phys_pages_8689 = v30;
      v12 = sysconf(30, a2, v30);
      pagesize_8690 = v12;
    }
    a2 = v12;
    v13 = v9 / v12;
    v14 = v9 % v12;
    if ( v13 > phys_pages_8689
      || (LODWORD(v14) = __readfsdword(0xFFFFFFC0),
          LODWORD(v39) = v14,
          v15 = malloc(v9, a2, (_QWORD *)v14, (__int64)a4, a5, a6),
          v35 = v15,
          __writefsdword(0xFFFFFFC0, v39),
          !v15) )
    {
      quicksort(v38, v37, a3, a4, (__int64)a5);
      return __readfsqword(0x28u) ^ v45;
    }
    v44 = v15;
  }
  else
  {
    v10 = (__int64 *)((char *)&v34 - ((v9 + 23) & 0xFFFFFFFFFFFFF000LL));
    if ( &v34 != v10 )
    {
      while ( &v32 != v10 )
        ;
    }
    if ( (((_WORD)v9 + 23) & 0xFF0) != 0 )
    {
      v11 = alloca(((_WORD)v9 + 23) & 0xFF0);
      *(__int64 *)((char *)&v31 + (((_WORD)v9 + 23) & 0xFF0)) = *(__int64 *)((char *)&v31 + (((_WORD)v9 + 23) & 0xFF0));
    }
    v35 = 0LL;
    v44 = &v33;
  }
  v40 = a3;
  v41 = 4LL;
  v42 = a4;
  v43 = a5;
  if ( a3 <= 0x20 )
  {
    if ( (((unsigned __int8)a3 | (unsigned __int8)v38) & 3) == 0 )
    {
      if ( a3 == 4 )
      {
        v41 = 0LL;
      }
      else if ( a3 != 8 || ((unsigned __int8)v38 & 7) != 0 )
      {
        if ( (((unsigned __int8)a3 | (unsigned __int8)v38) & 7) == 0 )
          v41 = 2LL;
      }
      else
      {
        v41 = 1LL;
      }
    }
    v20 = v37;
    if ( v37 > 1 )
    {
      a2 = (__int64)v38;
      msort_with_tmp_part_0((__int64 *)&v40, v38, v37);
    }
    goto LABEL_30;
  }
  v16 = v37;
  v17 = (unsigned __int64)&v44[v37];
  v36 = v17 + 8 * v37;
  if ( v17 >= v36 )
  {
    a2 = (__int64)&v44[v37];
  }
  else
  {
    v18 = v38;
    v19 = (unsigned __int64)&v44[v37];
    do
    {
      v19 += 8LL;
      *(_QWORD *)(v19 - 8) = v18;
      v18 += a3;
    }
    while ( v36 > v19 );
    a2 = (__int64)&v44[v16];
  }
  v20 = v37;
  v40 = 8LL;
  v41 = 3LL;
  if ( v37 > 1 )
  {
    msort_with_tmp_part_0((__int64 *)&v40, (_QWORD *)a2, v37);
    goto LABEL_20;
  }
  if ( v37 )
  {
LABEL_20:
    v21 = v38;
    v39 = 0LL;
    do
    {
      v22 = *(char **)(v17 + 8 * v39);
      if ( v22 != v21 )
      {
        j_memcpy(v36, v21, a3);
        v23 = v21;
        v24 = v39;
        while ( 1 )
        {
          v25 = v22 - v38;
          *(_QWORD *)(v17 + 8 * v24) = v23;
          v26 = v25 / a3;
          j_memcpy(v23, v22, a3);
          v27 = (char **)(v17 + 8 * v26);
          v24 = v26;
          v23 = v22;
          if ( *v27 == v21 )
            break;
          v22 = *v27;
        }
        *v27 = v22;
        a2 = v36;
        j_memcpy(v22, v36, a3);
      }
      ++v39;
      v21 += a3;
    }
    while ( v37 > v39 );
  }
LABEL_30:
  free((__int64)v35, a2, v20, (__int64)a4, a5, a6);
  return __readfsqword(0x28u) ^ v45;
}
// 407D08: variable 'a4' is possibly undefined
// 407D08: variable 'a5' is possibly undefined
// 407D08: variable 'a6' is possibly undefined
// 407E7D: variable 'v20' is possibly undefined
// 401040: using guessed type __int64 __fastcall j_memcpy(_QWORD, _QWORD, _QWORD);
// 4AA8E8: using guessed type __int64 phys_pages_8689;
// 4AA8F0: using guessed type int pagesize_8690;

//----- (0000000000407F90) ----------------------------------------------------
unsigned __int64 __fastcall qsort(
        char *a1,
        __int64 a2,
        unsigned __int64 a3,
        int (__fastcall *a4)(char *, char *, __int64),
        __int64 a5,
        unsigned __int64 a6)
{
  return qsort_r(a1, a2, a3, a4, 0LL, a6);
}

//----- (0000000000407FA0) ----------------------------------------------------
char *__fastcall getenv(_BYTE *a1)
{
  char **v1; // rbp
  char *v2; // rbx
  __int16 v3; // ax
  __int64 v5; // rax
  __int16 v6; // r12
  __int64 v7; // r15
  __int64 v8; // r14

  v1 = environ;
  if ( !environ || !*a1 )
    return 0LL;
  v2 = *environ;
  if ( a1[1] )
  {
    v5 = j_strlen_ifunc(a1);
    v6 = *(_WORD *)a1;
    v7 = v5;
    v8 = v5 - 2;
    if ( v2 )
    {
      while ( v6 != *(_WORD *)v2 || (unsigned int)j_strncmp_ifunc(v2 + 2, a1 + 2, v8) || v2[v7] != 61 )
      {
        v2 = *++v1;
        if ( !*v1 )
          return v2;
      }
      v2 += v7 + 1;
    }
  }
  else
  {
    HIBYTE(v3) = 61;
    if ( v2 )
    {
      while ( 1 )
      {
        LOBYTE(v3) = *a1;
        if ( v3 == *(_WORD *)v2 )
          break;
        v2 = *++v1;
        if ( !*v1 )
          return v2;
      }
      v2 += 2;
    }
  }
  return v2;
}
// 401078: using guessed type __int64 __fastcall j_strncmp_ifunc(_QWORD, _QWORD, _QWORD);
// 4010C8: using guessed type __int64 __fastcall j_strlen_ifunc(_QWORD);

//----- (0000000000408070) ----------------------------------------------------
void __fastcall __noreturn _run_exit_handlers(
        int *status,
        _QWORD **a2,
        __int64 a3,
        __int64 a4,
        u32 *a5,
        unsigned __int64 a6)
{
  char v6; // r13
  unsigned int v8; // ebp
  _QWORD *v10; // r14
  __int64 v12; // rax
  __int64 v13; // rdx
  __int64 v14; // r15
  _QWORD *v15; // rax
  __int64 v16; // rdx
  void (__fastcall *v17)(int *, _QWORD, _QWORD, __int64, u32 *); // rdx
  void (__fastcall *v18)(_QWORD, _QWORD, _QWORD, __int64, u32 *); // rdx
  _QWORD *v19; // rax
  __int64 (__fastcall **v20)(); // rbx

  v6 = a3;
  v8 = (unsigned int)status;
  while ( 1 )
  {
    _ESI = 1;
    if ( !_libc_multiple_threads )
      break;
    if ( _InterlockedCompareExchange(&_exit_funcs_lock, 1, 0) )
      goto LABEL_6;
LABEL_7:
    v10 = *a2;
    if ( !*a2 )
    {
      _exit_funcs_done = 1;
      if ( _libc_multiple_threads )
      {
        if ( !_InterlockedDecrement(&_exit_funcs_lock) )
          goto LABEL_40;
LABEL_39:
        status = &_exit_funcs_lock;
        _lll_unlock_wake_private((u32 *)&_exit_funcs_lock, 1LL, a3, a4, a5, a6);
      }
      else if ( --_exit_funcs_lock )
      {
        goto LABEL_39;
      }
LABEL_40:
      if ( v6 )
      {
        v20 = &_start___libc_atexit;
        if ( &_start___libc_atexit < (__int64 (__fastcall **)())&edata )
        {
          do
            ((void (__fastcall *)(int *, __int64, __int64, __int64, u32 *))*v20++)(status, 1LL, a3, a4, a5);
          while ( v20 != &_start___libc_atexit
                       + ((unsigned __int64)((_UNKNOWN *)((char *)&edata - 1) - (_UNKNOWN *)&_start___libc_atexit) >> 3)
                       + 1 );
        }
      }
      exit(v8);
    }
    while ( 1 )
    {
      v12 = v10[1];
      if ( !v12 )
        break;
      v13 = v12 - 1;
      v14 = _new_exitfn_called;
      v10[1] = v12 - 1;
      if ( !_libc_multiple_threads )
      {
        if ( !--_exit_funcs_lock )
          goto LABEL_23;
LABEL_22:
        status = &_exit_funcs_lock;
        _lll_unlock_wake_private((u32 *)&_exit_funcs_lock, 1LL, v13, a4, a5, a6);
        goto LABEL_23;
      }
      if ( _InterlockedDecrement(&_exit_funcs_lock) )
        goto LABEL_22;
LABEL_23:
      v15 = &v10[4 * v13];
      a3 = v15[2];
      switch ( a3 )
      {
        case 3LL:
          ((void (__fastcall *)(int *, __int64, __int64, __int64, u32 *))(__readfsqword(0x30u) ^ __ROR8__(v15[3], 17)))(
            status,
            1LL,
            3LL,
            a4,
            a5);
          break;
        case 4LL:
          v16 = v15[3];
          v15[2] = 0LL;
          v17 = (void (__fastcall *)(int *, _QWORD, _QWORD, __int64, u32 *))(__readfsqword(0x30u) ^ __ROR8__(v16, 17));
          status = (int *)v15[4];
          v17(status, v8, v17, a4, a5);
          break;
        case 2LL:
          status = (int *)v8;
          v18 = (void (__fastcall *)(_QWORD, _QWORD, _QWORD, __int64, u32 *))(__readfsqword(0x30u) ^ __ROR8__(v15[3], 17));
          v18(v8, v15[4], v18, a4, a5);
          break;
      }
      _ESI = 1;
      if ( _libc_multiple_threads )
      {
        if ( !_InterlockedCompareExchange(&_exit_funcs_lock, 1, 0) )
          goto LABEL_16;
LABEL_15:
        status = &_exit_funcs_lock;
        _lll_lock_wait_private((u32 *)&_exit_funcs_lock, 1LL, a3, a4, a5, a6);
        goto LABEL_16;
      }
      __asm { cmpxchg cs:__exit_funcs_lock, esi }
      if ( _libc_multiple_threads )
        goto LABEL_15;
LABEL_16:
      if ( _new_exitfn_called != v14 )
        goto LABEL_7;
    }
    v19 = (_QWORD *)*v10;
    *a2 = (_QWORD *)*v10;
    if ( v19 )
    {
      status = (int *)v10;
      free((__int64)v10, 1LL, a3, a4, a5, a6);
    }
    if ( _libc_multiple_threads )
    {
      if ( !_InterlockedDecrement(&_exit_funcs_lock) )
        continue;
LABEL_33:
      status = &_exit_funcs_lock;
      _lll_unlock_wake_private((u32 *)&_exit_funcs_lock, 1LL, a3, a4, a5, a6);
    }
    else if ( --_exit_funcs_lock )
    {
      goto LABEL_33;
    }
  }
  __asm { cmpxchg cs:__exit_funcs_lock, esi }
  if ( !_libc_multiple_threads )
    goto LABEL_7;
LABEL_6:
  status = &_exit_funcs_lock;
  _lll_lock_wait_private((u32 *)&_exit_funcs_lock, 1LL, a3, a4, a5, a6);
  goto LABEL_7;
}
// 4080D8: variable 'a3' is possibly undefined
// 4080D8: variable 'a4' is possibly undefined
// 4080D8: variable 'a5' is possibly undefined
// 4080D8: variable 'a6' is possibly undefined
// 40819C: variable 'v13' is possibly undefined
// 4AA2E8: using guessed type __int64 (__fastcall *_start___libc_atexit)();
// 4AA8F4: using guessed type char _exit_funcs_done;
// 4AB810: using guessed type int _exit_funcs_lock;
// 4AB818: using guessed type __int64 _new_exitfn_called;
// 4AB820: using guessed type int _libc_multiple_threads;

//----- (0000000000408300) ----------------------------------------------------
void __fastcall __noreturn exit(int *a1, __int64 a2, __int64 a3, __int64 a4, u32 *a5, unsigned __int64 a6)
{
  _run_exit_handlers(a1, (_QWORD **)&_exit_funcs, 1LL, 1LL, a5, a6);
}
// 4A80F8: using guessed type void *_exit_funcs;

//----- (0000000000408320) ----------------------------------------------------
u32 *__fastcall _new_exitfn(u32 **a1)
{
  u32 *v1; // rbp
  u32 *v2; // r8
  u32 *v3; // r9
  __int64 v4; // rax
  __int64 v5; // rdx
  __int64 v6; // rcx
  u32 *v7; // rax
  u32 *result; // rax
  u32 *v9; // rax

  if ( _exit_funcs_done )
    return 0LL;
  v1 = *a1;
  if ( !*a1 )
    _assert_fail((__int64)"l != NULL", (__int64)"cxa_atexit.c", 0x6Cu, "__new_exitfn");
  v2 = *a1;
  v3 = 0LL;
  while ( 1 )
  {
    v4 = *((_QWORD *)v2 + 1);
    if ( !v4 )
      goto LABEL_10;
    v5 = v4 - 1;
    v6 = 32 * (v4 - 1);
    if ( *(_QWORD *)((char *)v2 + v6 + 16) )
      break;
    while ( v5 )
    {
      v6 = v5 - 1;
      if ( *(_QWORD *)&v2[8 * v5 - 4] )
        goto LABEL_12;
      --v5;
    }
LABEL_10:
    v7 = *(u32 **)v2;
    *((_QWORD *)v2 + 1) = 0LL;
    v3 = v2;
    if ( !v7 )
      goto LABEL_18;
    v2 = v7;
  }
  v5 = *((_QWORD *)v2 + 1);
LABEL_12:
  if ( v5 != 32 )
  {
    *((_QWORD *)v2 + 1) = v5 + 1;
    result = &v2[8 * v5 + 4];
LABEL_14:
    *(_QWORD *)result = 1LL;
    ++_new_exitfn_called;
    return result;
  }
  v2 = v3;
  if ( v3 )
  {
LABEL_18:
    result = v2 + 4;
    *((_QWORD *)v2 + 1) = 1LL;
    goto LABEL_14;
  }
  v9 = calloc(1LL, 0x410uLL, 32LL, v6, 0LL, 0LL);
  v2 = v9;
  if ( v9 )
  {
    *(_QWORD *)v9 = v1;
    *a1 = v9;
    goto LABEL_18;
  }
  return 0LL;
}
// 4AA8F4: using guessed type char _exit_funcs_done;
// 4AB818: using guessed type __int64 _new_exitfn_called;

//----- (0000000000408450) ----------------------------------------------------
__int64 __fastcall _internal_atexit(__int64 a1, __int64 a2, __int64 a3, __int64 a4, u32 *a5, u32 a6)
{
  u32 **v7; // rdx
  u32 *v10; // rax
  __int64 v11; // rdx
  __int64 v12; // rcx
  u32 *v13; // r8
  u32 v14; // er9
  __int64 v15; // rdi

  v7 = (u32 **)a4;
  _ESI = 1;
  if ( !_libc_multiple_threads )
  {
    __asm { cmpxchg cs:__exit_funcs_lock, esi }
    if ( !_libc_multiple_threads )
      goto LABEL_6;
    goto LABEL_5;
  }
  if ( _InterlockedCompareExchange(&_exit_funcs_lock, 1, 0) )
LABEL_5:
    _lll_lock_wait_private((u32 *)&_exit_funcs_lock, 1LL, a4, a4, a5, a6);
LABEL_6:
  v10 = _new_exitfn(v7);
  if ( v10 )
  {
    *((_QWORD *)v10 + 2) = a2;
    v15 = __ROL8__(__readfsqword(0x30u) ^ a1, 17);
    *((_QWORD *)v10 + 3) = a3;
    *((_QWORD *)v10 + 1) = v15;
    *(_QWORD *)v10 = 4LL;
    if ( _libc_multiple_threads )
    {
      if ( !_InterlockedDecrement(&_exit_funcs_lock) )
        return 0LL;
    }
    else if ( !--_exit_funcs_lock )
    {
      return 0LL;
    }
    _lll_unlock_wake_private((u32 *)&_exit_funcs_lock, 1LL, v11, v12, v13, v14);
    return 0LL;
  }
  if ( _libc_multiple_threads )
  {
    if ( !_InterlockedDecrement(&_exit_funcs_lock) )
      return 0xFFFFFFFFLL;
    goto LABEL_17;
  }
  if ( --_exit_funcs_lock )
LABEL_17:
    _lll_unlock_wake_private((u32 *)&_exit_funcs_lock, 1LL, v11, v12, v13, v14);
  return 0xFFFFFFFFLL;
}
// 4084A6: variable 'v7' is possibly undefined
// 4084FD: variable 'v11' is possibly undefined
// 4084FD: variable 'v12' is possibly undefined
// 4084FD: variable 'v13' is possibly undefined
// 4084FD: variable 'v14' is possibly undefined
// 4AB810: using guessed type int _exit_funcs_lock;
// 4AB820: using guessed type int _libc_multiple_threads;

//----- (0000000000408550) ----------------------------------------------------
int __fastcall _cxa_atexit(void (__fastcall *lpfunc)(void *), void *obj, void *lpdso_handle)
{
  u32 *v3; // r8
  u32 v4; // er9

  return _internal_atexit((__int64)lpfunc, (__int64)obj, (__int64)lpdso_handle, (__int64)&_exit_funcs, v3, v4);
}
// 40855B: variable 'v3' is possibly undefined
// 40855B: variable 'v4' is possibly undefined
// 4A80F8: using guessed type void *_exit_funcs;

//----- (0000000000408560) ----------------------------------------------------
unsigned __int64 __fastcall _strtoull_internal(char *a1, char **a2, int a3, int a4)
{
  return ___strtoull_l_internal(a1, a2, a3, a4, __readfsqword(0xFFFFFFA8));
}

//----- (0000000000408580) ----------------------------------------------------
unsigned __int64 __fastcall strtouq(char *a1, char **a2, int a3)
{
  return ___strtoull_l_internal(a1, a2, a3, 0, __readfsqword(0xFFFFFFA8));
}

//----- (00000000004085A0) ----------------------------------------------------
unsigned __int64 __fastcall ___strtoull_l_internal(char *a1, char **a2, int a3, int a4, __int64 a5)
{
  char *v5; // r14
  char *v7; // r12
  __int64 v8; // rsi
  char *v9; // rbx
  __int64 i; // rax
  char *v11; // rbx
  unsigned __int8 v12; // r15
  int v13; // eax
  unsigned __int64 v14; // rbp
  __int64 v15; // rdi
  unsigned __int64 v16; // rcx
  char *v17; // r8
  unsigned __int64 result; // rax
  int v19; // er9
  char *v20; // rsi
  unsigned __int8 v21; // si
  __int64 v22; // rsi
  __int64 v23; // rax
  __int64 v24; // rcx
  unsigned __int64 v25; // rax
  __int64 v26; // rdx
  __int64 v27; // rdi
  unsigned __int64 v28; // rsi
  char v29; // cl
  unsigned __int64 j; // rdx
  unsigned __int64 v31; // rax
  unsigned __int8 v33; // [rsp+12h] [rbp-46h]
  int v34; // [rsp+14h] [rbp-44h]

  v5 = 0LL;
  v7 = 0LL;
  if ( a4 )
  {
    v24 = *(_QWORD *)(a5 + 8);
    v5 = *(char **)(v24 + 80);
    if ( (unsigned __int8)(*v5 - 1) > 0x7Du )
    {
      v5 = 0LL;
    }
    else
    {
      v7 = *(char **)(v24 + 72);
      if ( !*v7 )
      {
        v5 = 0LL;
        v7 = 0LL;
      }
    }
  }
  if ( a3 == 1 || (unsigned int)a3 > 0x24 )
  {
    __writefsdword(0xFFFFFFC0, 0x16u);
    return 0LL;
  }
  v8 = *(_QWORD *)(a5 + 104);
  v9 = a1;
  for ( i = *a1; (*(_BYTE *)(v8 + 2 * i + 1) & 0x20) != 0; i = *v9 )
    ++v9;
  if ( !(_BYTE)i )
  {
    if ( !a2 )
      return 0LL;
    goto LABEL_59;
  }
  if ( (_BYTE)i == 45 )
  {
    v11 = v9 + 1;
    v34 = 1;
  }
  else
  {
    v34 = 0;
    v11 = &v9[(_BYTE)i == 43];
  }
  v12 = *v11;
  if ( *v11 != 48 )
  {
    if ( a3 && a3 != 10 )
    {
      v13 = a3 - 2;
      v14 = 0LL;
      v5 = 0LL;
      goto LABEL_13;
    }
    if ( !v5 )
    {
      v13 = 8;
      a3 = 10;
      v14 = 0LL;
      goto LABEL_13;
    }
LABEL_51:
    v25 = j_strlen_ifunc(v7);
    v14 = v25;
    if ( !v25 )
      goto LABEL_56;
    if ( v12 == *v7 )
    {
      v26 = 0LL;
      while ( v25 != ++v26 )
      {
        if ( v7[v26] != v11[v26] )
          goto LABEL_73;
      }
      goto LABEL_56;
    }
LABEL_73:
    v27 = v12;
    v28 = (unsigned __int64)v11;
    if ( v12 )
    {
      v28 = (unsigned __int64)v11;
      do
      {
        if ( (unsigned __int8)(v27 - 48) > 9u )
        {
          v29 = *v7;
          for ( j = 0LL; *(_BYTE *)(v28 + j) == v29; v29 = v7[j] )
          {
            if ( v25 == ++j )
              goto LABEL_75;
          }
          if ( v25 > j && ((word_486FE0[v27] & 0x400) == 0 || (int)dword_4866E0[v27] > 64) )
            break;
        }
LABEL_75:
        v27 = *(unsigned __int8 *)++v28;
      }
      while ( (_BYTE)v27 );
    }
    v31 = _correctly_grouped_prefixmb((unsigned __int64)v11, v28, v7, v5);
    v12 = *v11;
    a3 = 10;
    v5 = (char *)v31;
    v13 = 8;
LABEL_13:
    v15 = v12;
    v16 = _strtol_ul_max_tab[v13];
    v33 = _strtol_ul_rem_tab[v13];
    if ( v12 && v5 != v11 )
      goto LABEL_15;
LABEL_56:
    if ( !a2 )
      return 0LL;
    if ( v11 - a1 > 1 && dword_4866E0[*(v11 - 1)] == 88 && *(v11 - 2) == 48 )
    {
      *a2 = v11 - 1;
      return 0LL;
    }
LABEL_59:
    *a2 = a1;
    return 0LL;
  }
  if ( (a3 & 0xFFFFFFEF) != 0 )
    goto LABEL_45;
  if ( dword_4866E0[v11[1]] == 88 )
  {
    v12 = v11[2];
    v13 = 14;
    v11 += 2;
    v14 = 0LL;
    a3 = 16;
    v5 = 0LL;
    goto LABEL_13;
  }
  if ( a3 )
  {
LABEL_45:
    if ( a3 == 10 )
    {
      if ( v5 )
        goto LABEL_51;
      v16 = 0x1999999999999999LL;
      v14 = 0LL;
      v15 = 48LL;
      v33 = 5;
    }
    else
    {
      v5 = 0LL;
      v14 = 0LL;
      v23 = a3 - 2;
      v15 = 48LL;
      v16 = _strtol_ul_max_tab[v23];
      v33 = _strtol_ul_rem_tab[v23];
    }
  }
  else
  {
    a3 = 8;
    v5 = 0LL;
    v14 = 0LL;
    v15 = 48LL;
    v16 = 0x1FFFFFFFFFFFFFFFLL;
    v33 = 7;
  }
LABEL_15:
  v17 = v11;
  result = 0LL;
  v19 = 0;
  do
  {
    v21 = v15 - 48;
    if ( (unsigned __int8)(v15 - 48) <= 9u )
      goto LABEL_25;
    if ( v14 )
    {
      v22 = 0LL;
      while ( v7[v22] == v17[v22] )
      {
        if ( ++v22 == v14 )
          goto LABEL_41;
      }
      v15 = (unsigned __int8)v15;
      if ( v14 == v22 )
      {
LABEL_41:
        v20 = &v17[v14 - 1];
        goto LABEL_19;
      }
    }
    if ( (word_486FE0[v15] & 0x400) == 0 )
      break;
    v21 = dword_4866E0[v15] - 55;
LABEL_25:
    if ( v21 >= a3 )
      break;
    if ( result > v16 || result == v16 && v21 > v33 )
    {
      v19 = 1;
      v15 = (unsigned __int8)*++v17;
      if ( !(_BYTE)v15 )
        break;
    }
    else
    {
      result = v21 + a3 * result;
      v20 = v17;
LABEL_19:
      v15 = (unsigned __int8)v20[1];
      v17 = v20 + 1;
      if ( !(_BYTE)v15 )
        break;
    }
  }
  while ( v17 != v5 );
  if ( v17 == v11 )
    goto LABEL_56;
  if ( a2 )
    *a2 = v17;
  if ( v19 )
  {
    __writefsdword(0xFFFFFFC0, 0x22u);
    return -1LL;
  }
  else if ( v34 )
  {
    return -(__int64)result;
  }
  return result;
}
// 4010C8: using guessed type __int64 __fastcall j_strlen_ifunc(_QWORD);
// 4866E0: using guessed type unsigned int dword_4866E0[256];
// 486FE0: using guessed type _WORD word_486FE0[256];
// 491220: using guessed type _BYTE _strtol_ul_rem_tab[6];
// 491260: using guessed type _QWORD _strtol_ul_max_tab[6];

//----- (0000000000408A80) ----------------------------------------------------
unsigned __int64 __fastcall strtoull_l(char *a1, char **a2, int a3, __int64 a4)
{
  return ___strtoull_l_internal(a1, a2, a3, 0, a4);
}

//----- (0000000000408A90) ----------------------------------------------------
unsigned __int64 __fastcall _correctly_grouped_prefixmb(unsigned __int64 a1, unsigned __int64 a2, char *a3, char *a4)
{
  unsigned __int64 v4; // r15
  __int64 v7; // rax
  unsigned __int64 v8; // rdx
  __int64 v9; // r12
  unsigned __int64 v10; // r10
  char v11; // r11
  char v12; // cl
  char *v13; // rcx
  char *v14; // rdi
  char v15; // r8
  char v16; // si
  __int64 v17; // rsi
  __int64 v18; // rcx
  bool v19; // cc
  char *v21; // r14
  unsigned __int64 v22; // r10
  signed __int64 v23; // r13
  unsigned __int64 v24; // r9
  char *v25; // rcx
  char *v26; // rdi
  char v27; // r8
  char v28; // si
  signed __int64 v29; // r10
  char *v30; // rcx
  char *v31; // rdi
  char v32; // r8
  char v33; // si
  unsigned __int64 v35; // [rsp+18h] [rbp-40h]

  v4 = a2;
  if ( a4 )
  {
    v7 = j_strlen_ifunc(a3);
    if ( a2 > a1 )
    {
      v8 = a1 - 1;
      v9 = v7 - 2;
LABEL_4:
      v10 = v4 - 1;
      if ( a1 > v4 - 1 )
        return v4;
      v11 = *a3;
      while ( 1 )
      {
        if ( *(_BYTE *)(v10 + v7 - 1) == v11 )
        {
          v12 = a3[1];
          if ( !v12 )
            goto LABEL_13;
          if ( *(_BYTE *)(v10 + v7 - 2) == v12 )
            break;
        }
LABEL_6:
        if ( --v10 == v8 )
          return v4;
      }
      v13 = a3 + 2;
      v14 = (char *)(v10 + v7 - 3);
      while ( 1 )
      {
        v16 = *v13;
        if ( !*v13 )
          break;
        v15 = *v14;
        ++v13;
        --v14;
        if ( v15 != v16 )
          goto LABEL_6;
      }
LABEL_13:
      if ( a1 > v10 )
        return v4;
      v17 = *a4;
      v18 = (int)v17 + 1;
      v19 = (__int64)(v4 - v10) <= v18;
      if ( v4 - v10 != v18 )
      {
        v4 = v10 + v17 + 1;
        if ( v19 )
          v4 = v10;
        goto LABEL_17;
      }
      v21 = a4;
      v22 = v10 - 1;
      v35 = v22;
      v23 = a4[1];
      if ( (_BYTE)v23 )
      {
LABEL_22:
        ++v21;
        v24 = v22;
        if ( (_BYTE)v23 == 127 )
          goto LABEL_34;
        goto LABEL_23;
      }
      while ( 1 )
      {
        v23 = *v21;
        v24 = v22;
        if ( (_BYTE)v23 == 127 )
          break;
LABEL_23:
        if ( (v23 & 0x80u) != 0LL )
          break;
        if ( a1 > v22 )
          return v4;
        while ( 1 )
        {
          if ( !v11 )
            goto LABEL_30;
          if ( v11 == *(_BYTE *)(v24 + v7 - 1) )
            break;
LABEL_42:
          if ( --v24 == v8 )
          {
            v29 = v22 - v8;
            goto LABEL_44;
          }
        }
        v25 = a3 + 1;
        v26 = (char *)(v24 + v9);
        while ( 1 )
        {
          v28 = *v25;
          if ( !*v25 )
            break;
          v27 = *v26;
          ++v25;
          --v26;
          if ( v27 != v28 )
            goto LABEL_42;
        }
LABEL_30:
        v29 = v22 - v24;
        if ( a1 > v24 )
        {
LABEL_44:
          if ( v23 >= v29 )
            return v4;
LABEL_45:
          v4 = v35;
LABEL_17:
          if ( a1 >= v4 )
            goto LABEL_18;
          goto LABEL_4;
        }
        if ( v29 != v23 )
          goto LABEL_45;
LABEL_32:
        v23 = v21[1];
        v22 = v24 - 1;
        if ( (_BYTE)v23 )
          goto LABEL_22;
      }
LABEL_34:
      if ( a1 > v22 )
        return v4;
      while ( v11 )
      {
        if ( v11 == *(_BYTE *)(v24 + v7 - 1) )
        {
          v30 = a3 + 1;
          v31 = (char *)(v24 + v9);
          do
          {
            v33 = *v30;
            if ( !*v30 )
              goto LABEL_40;
            v32 = *v31;
            ++v30;
            --v31;
          }
          while ( v32 == v33 );
        }
        if ( --v24 == v8 )
          return v4;
      }
LABEL_40:
      if ( a1 > v24 )
        return v4;
      goto LABEL_32;
    }
LABEL_18:
    if ( v4 < a1 )
      return a1;
  }
  return v4;
}
// 4010C8: using guessed type __int64 __fastcall j_strlen_ifunc(_QWORD);

//----- (0000000000408CC0) ----------------------------------------------------
__int64 printf(unsigned __int64 a1, ...)
{
  __va_list_tag va[1]; // [rsp+0h] [rbp-D8h] BYREF
  unsigned __int64 v3; // [rsp+18h] [rbp-C0h]

  va_start(va, a1);
  v3 = __readfsqword(0x28u);
  return vfprintf((__int64)stdout, a1, (__m128i *)va);
}
// 4A87A0: using guessed type void *stdout;

//----- (0000000000408D90) ----------------------------------------------------
__int64 asprintf(__int64 *a1, unsigned __int64 a2, ...)
{
  __va_list_tag va[1]; // [rsp+0h] [rbp-D8h] BYREF
  unsigned __int64 v4; // [rsp+18h] [rbp-C0h]
  __int64 v5; // [rsp+30h] [rbp-A8h]
  __int64 v6; // [rsp+38h] [rbp-A0h]
  u32 *v7; // [rsp+40h] [rbp-98h]
  __int64 v8; // [rsp+48h] [rbp-90h]

  va_start(va, a2);
  v5 = va_arg(va, _QWORD);
  v6 = va_arg(va, _QWORD);
  v7 = va_arg(va, u32 *);
  v8 = va_arg(va, _QWORD);
  va_end(va);
  va_start(va, a2);
  v4 = __readfsqword(0x28u);
  return vasprintf(a1, a2, (__m128i *)va, v6, v7, v8);
}

//----- (0000000000408E50) ----------------------------------------------------
__int64 __fastcall locked_vfxprintf(__int64 a1, __int64 a2, __m128i *a3)
{
  unsigned __int64 v4; // r14
  __int64 v5; // rbx
  _BOOL4 v6; // eax
  _QWORD *v7; // rdx
  __int64 v8; // rcx
  u32 *v9; // r8
  __int64 v10; // r9
  __int64 *v11; // rdx
  __int64 v12; // rcx
  u32 *v13; // r8
  __int64 v14; // r9
  void *v16; // rsp
  int *v17; // rax
  __int64 v18; // r8
  __int64 v19; // r9
  int *v20; // rbx
  __int64 *v21; // rsi
  unsigned int v22; // eax
  __int64 v23; // rdx
  __int64 v24; // rcx
  u32 *v25; // r8
  unsigned __int64 v26; // r9
  __int64 v27; // [rsp+0h] [rbp-1048h]
  __int64 v28; // [rsp+8h] [rbp-1040h] BYREF
  int v29; // [rsp+10h] [rbp-1038h] BYREF
  _BYTE v30[4]; // [rsp+1008h] [rbp-40h] BYREF
  unsigned int v31; // [rsp+100Ch] [rbp-3Ch]
  __int64 v32; // [rsp+1010h] [rbp-38h] BYREF
  __int64 v33[6]; // [rsp+1018h] [rbp-30h] BYREF

  v32 = a2;
  v33[1] = __readfsqword(0x28u);
  if ( *(int *)(a1 + 192) <= 0 )
    return vfprintf(a1, a2, a3);
  v4 = j_strlen_ifunc(a2) + 1;
  if ( v4 > 0x3FFFFFFFFFFFFFFFLL )
  {
    __writefsdword(0xFFFFFFC0, 0x4Bu);
    return 0xFFFFFFFFLL;
  }
  else
  {
    v5 = 4 * v4;
    v6 = _libc_alloca_cutoff(4 * v4);
    if ( 4 * v4 <= 0x1000 || v6 )
    {
      v11 = (__int64 *)&v30[-((v5 + 23) & 0xFFFFFFFFFFFFF000LL)];
      if ( v30 != (_BYTE *)v11 )
      {
        while ( &v28 != v11 )
          ;
      }
      if ( (((_WORD)v5 + 23) & 0xFF0) != 0 )
      {
        v16 = alloca(((_WORD)v5 + 23) & 0xFF0);
        *(__int64 *)((char *)&v27 + (((_WORD)v5 + 23) & 0xFF0)) = *(__int64 *)((char *)&v27 + (((_WORD)v5 + 23) & 0xFF0));
      }
      v33[0] = 0LL;
      if ( (unsigned int)mbsrtowcs((__int64)&v29, &v32, v4, v33, (__int64)v9, v10) == -1 )
        return 0xFFFFFFFFLL;
      return vfwprintf(a1, &v29, a3, v12, v13, v14);
    }
    else
    {
      v17 = (int *)malloc(4 * v4, a2, v7, v8, v9, v10);
      v20 = v17;
      if ( !v17 )
        return 0xFFFFFFFFLL;
      v21 = &v32;
      v33[0] = 0LL;
      v22 = mbsrtowcs((__int64)v17, &v32, v4, v33, v18, v19);
      if ( v22 != -1 )
      {
        v21 = (__int64 *)v20;
        v22 = vfwprintf(a1, v20, a3, v24, v25, v26);
      }
      v31 = v22;
      free((__int64)v20, (__int64)v21, v23, v24, v25, v26);
      return v31;
    }
  }
}
// 408F20: variable 'v9' is possibly undefined
// 408F20: variable 'v10' is possibly undefined
// 408F59: variable 'v12' is possibly undefined
// 408F59: variable 'v13' is possibly undefined
// 408F59: variable 'v14' is possibly undefined
// 408F98: variable 'v7' is possibly undefined
// 408F98: variable 'v8' is possibly undefined
// 408FBB: variable 'v18' is possibly undefined
// 408FBB: variable 'v19' is possibly undefined
// 408FCE: variable 'v24' is possibly undefined
// 408FCE: variable 'v25' is possibly undefined
// 408FCE: variable 'v26' is possibly undefined
// 408FD9: variable 'v23' is possibly undefined
// 4010C8: using guessed type __int64 __fastcall j_strlen_ifunc(_QWORD);

//----- (0000000000408FF0) ----------------------------------------------------
__int64 _fxprintf(_QWORD *a1, __int64 a2, ...)
{
  __int64 v2; // rcx
  u32 v3; // er9
  __int64 v4; // r10
  _QWORD *v5; // rbx
  u32 *v7; // r8
  bool v9; // zf
  __int64 v10; // rcx
  __int64 locked; // rsi
  u32 *v12; // r8
  u32 v13; // er9
  __int64 v14; // rdx
  __va_list_tag va[1]; // [rsp+0h] [rbp-D8h] BYREF
  unsigned __int64 v17; // [rsp+18h] [rbp-C0h]
  __int64 v18; // [rsp+30h] [rbp-A8h]
  __int64 v19; // [rsp+38h] [rbp-A0h]
  __int64 v20; // [rsp+40h] [rbp-98h]
  __int64 v21; // [rsp+48h] [rbp-90h]

  va_start(va, a2);
  v18 = va_arg(va, _QWORD);
  v19 = va_arg(va, _QWORD);
  v2 = v19;
  v20 = va_arg(va, _QWORD);
  v21 = va_arg(va, _QWORD);
  v3 = v21;
  va_end(va);
  v4 = a2;
  v5 = a1;
  v17 = __readfsqword(0x28u);
  if ( !a1 )
    v5 = stderr;
  va_start(va, a2);
  if ( (*(_DWORD *)v5 & 0x8000) == 0 )
  {
    _RDX = v5[17];
    v7 = (u32 *)__readfsqword(0x10u);
    if ( *(u32 **)(_RDX + 8) == v7 )
    {
LABEL_11:
      ++*(_DWORD *)(_RDX + 4);
      goto LABEL_12;
    }
    _ESI = 1;
    v9 = _libc_multiple_threads == 0;
    if ( _libc_multiple_threads )
    {
      if ( !_InterlockedCompareExchange((volatile signed __int32 *)_RDX, 1, 0) )
        goto LABEL_10;
    }
    else
    {
      __asm { cmpxchg [rdx], esi }
      if ( v9 )
      {
LABEL_10:
        _RDX = v5[17];
        *(_QWORD *)(_RDX + 8) = v7;
        goto LABEL_11;
      }
    }
    _lll_lock_wait_private((u32 *)_RDX, 1LL, _RDX, v2, v7, v3);
    goto LABEL_10;
  }
LABEL_12:
  locked = (unsigned int)locked_vfxprintf((__int64)v5, v4, (__m128i *)va);
  if ( (*(_DWORD *)v5 & 0x8000) == 0 )
  {
    v14 = v5[17];
    v9 = (*(_DWORD *)(v14 + 4))-- == 1;
    if ( v9 )
    {
      *(_QWORD *)(v14 + 8) = 0LL;
      if ( _libc_multiple_threads )
      {
        if ( !_InterlockedDecrement((volatile signed __int32 *)v14) )
          return (unsigned int)locked;
      }
      else
      {
        v9 = (*(_DWORD *)v14)-- == 1;
        if ( v9 )
          return (unsigned int)locked;
      }
      _lll_unlock_wake_private((u32 *)v14, locked, v14, v10, v12, v13);
    }
  }
  return (unsigned int)locked;
}
// 4090E9: variable 'v7' is possibly undefined
// 4090FA: variable 'v4' is possibly undefined
// 40915E: variable 'v10' is possibly undefined
// 40915E: variable 'v12' is possibly undefined
// 40915E: variable 'v13' is possibly undefined
// 4A8798: using guessed type void *stderr;
// 4AB820: using guessed type int _libc_multiple_threads;

//----- (0000000000409180) ----------------------------------------------------
__int64 _fxprintf_nocancel(_QWORD *a1, __int64 a2, ...)
{
  __int64 v2; // rcx
  u32 v3; // er9
  __int64 v4; // r10
  _QWORD *v5; // rbx
  u32 *v7; // r8
  bool v9; // zf
  int v10; // ebp
  unsigned int locked; // eax
  __int64 v12; // rcx
  u32 *v13; // r8
  u32 v14; // er9
  unsigned int v15; // esi
  __int64 v16; // rdx
  __va_list_tag va[1]; // [rsp+0h] [rbp-E8h] BYREF
  unsigned __int64 v19; // [rsp+18h] [rbp-D0h]
  __int64 v20; // [rsp+30h] [rbp-B8h]
  __int64 v21; // [rsp+38h] [rbp-B0h]
  __int64 v22; // [rsp+40h] [rbp-A8h]
  __int64 v23; // [rsp+48h] [rbp-A0h]

  va_start(va, a2);
  v20 = va_arg(va, _QWORD);
  v21 = va_arg(va, _QWORD);
  v2 = v21;
  v22 = va_arg(va, _QWORD);
  v23 = va_arg(va, _QWORD);
  v3 = v23;
  va_end(va);
  v4 = a2;
  v5 = a1;
  v19 = __readfsqword(0x28u);
  if ( !a1 )
    v5 = stderr;
  va_start(va, a2);
  if ( (*(_DWORD *)v5 & 0x8000) == 0 )
  {
    _RDX = v5[17];
    v7 = (u32 *)__readfsqword(0x10u);
    if ( *(u32 **)(_RDX + 8) == v7 )
    {
LABEL_11:
      ++*(_DWORD *)(_RDX + 4);
      goto LABEL_12;
    }
    _ESI = 1;
    v9 = _libc_multiple_threads == 0;
    if ( _libc_multiple_threads )
    {
      if ( !_InterlockedCompareExchange((volatile signed __int32 *)_RDX, 1, 0) )
        goto LABEL_10;
    }
    else
    {
      __asm { cmpxchg [rdx], esi }
      if ( v9 )
      {
LABEL_10:
        _RDX = v5[17];
        *(_QWORD *)(_RDX + 8) = v7;
        goto LABEL_11;
      }
    }
    _lll_lock_wait_private((u32 *)_RDX, 1LL, _RDX, v2, v7, v3);
    goto LABEL_10;
  }
LABEL_12:
  v10 = *((_DWORD *)v5 + 29);
  *((_DWORD *)v5 + 29) = v10 | 2;
  locked = locked_vfxprintf((__int64)v5, v4, (__m128i *)va);
  *((_DWORD *)v5 + 29) = v10;
  v15 = locked;
  if ( (*(_DWORD *)v5 & 0x8000) == 0 )
  {
    v16 = v5[17];
    v9 = (*(_DWORD *)(v16 + 4))-- == 1;
    if ( v9 )
    {
      *(_QWORD *)(v16 + 8) = 0LL;
      if ( _libc_multiple_threads )
      {
        if ( !_InterlockedDecrement((volatile signed __int32 *)v16) )
          return v15;
      }
      else
      {
        v9 = (*(_DWORD *)v16)-- == 1;
        if ( v9 )
          return v15;
      }
      _lll_unlock_wake_private((u32 *)v16, locked, v16, v12, v13, v14);
    }
  }
  return v15;
}
// 40927A: variable 'v7' is possibly undefined
// 409296: variable 'v4' is possibly undefined
// 4092FE: variable 'v12' is possibly undefined
// 4092FE: variable 'v13' is possibly undefined
// 4092FE: variable 'v14' is possibly undefined
// 4A8798: using guessed type void *stderr;
// 4AB820: using guessed type int _libc_multiple_threads;

//----- (0000000000409320) ----------------------------------------------------
__int64 __fastcall fclose(__int64 a1, __int64 _RSI, __int64 a3, unsigned int *a4, u32 *a5, unsigned __int64 a6)
{
  unsigned int v6; // eax
  __int64 v7; // rbx
  __int64 v8; // rdx
  unsigned int v9; // ebp
  __int64 v10; // r12
  u32 *v11; // rdx
  __int64 v12; // rcx
  __int64 v14; // rdx
  __int64 v15; // rcx
  u32 *v16; // r8
  unsigned __int64 v17; // r9
  bool v20; // zf
  __int64 v21; // rdx
  __int64 v22; // r12

  v6 = *(_DWORD *)a1;
  v7 = a1;
  if ( (*(_DWORD *)a1 & 0x2000) != 0 )
  {
    IO_un_link((unsigned int *)a1, _RSI, a3, a4, a5, a6);
    v6 = *(_DWORD *)a1;
    if ( (BYTE1(*(_DWORD *)a1) & 0x80u) != 0 )
      goto LABEL_23;
  }
  else
  {
    LODWORD(v8) = *(_DWORD *)a1 & 0x8000;
    if ( (v6 & 0x8000) != 0 )
      goto LABEL_3;
  }
  _RDX = *(_QWORD *)(a1 + 136);
  a5 = (u32 *)__readfsqword(0x10u);
  if ( *(u32 **)(_RDX + 8) != a5 )
  {
    _RSI = 1LL;
    v20 = _libc_multiple_threads == 0;
    if ( _libc_multiple_threads )
    {
      if ( !_InterlockedCompareExchange((volatile signed __int32 *)_RDX, 1, 0) )
        goto LABEL_21;
    }
    else
    {
      __asm { cmpxchg [rdx], esi }
      if ( v20 )
      {
LABEL_21:
        _RDX = *(_QWORD *)(v7 + 136);
        v6 = *(_DWORD *)v7;
        *(_QWORD *)(_RDX + 8) = a5;
        goto LABEL_22;
      }
    }
    a1 = _RDX;
    _lll_lock_wait_private((u32 *)_RDX, 1LL, _RDX, (__int64)a4, a5, a6);
    goto LABEL_21;
  }
LABEL_22:
  ++*(_DWORD *)(_RDX + 4);
LABEL_23:
  v8 = (unsigned __int16)v6 & 0x8000;
  if ( (v6 & 0x2000) == 0 )
  {
LABEL_3:
    v9 = (int)(v6 << 26) >> 31;
    if ( (_DWORD)v8 )
      goto LABEL_4;
    goto LABEL_25;
  }
  a1 = v7;
  v9 = IO_new_file_close_it(v7, _RSI, v8, (__int64)a4, a5, a6);
  if ( (*(_DWORD *)v7 & 0x8000) != 0 )
    goto LABEL_4;
LABEL_25:
  v21 = *(_QWORD *)(v7 + 136);
  v20 = (*(_DWORD *)(v21 + 4))-- == 1;
  if ( !v20 )
    goto LABEL_4;
  *(_QWORD *)(v21 + 8) = 0LL;
  if ( _libc_multiple_threads )
  {
    if ( !_InterlockedDecrement((volatile signed __int32 *)v21) )
      goto LABEL_4;
  }
  else
  {
    v20 = (*(_DWORD *)v21)-- == 1;
    if ( v20 )
      goto LABEL_4;
  }
  a1 = v21;
  _lll_unlock_wake_private((u32 *)v21, _RSI, v21, (__int64)a4, a5, a6);
LABEL_4:
  v10 = *(_QWORD *)(v7 + 216);
  v11 = _start___libc_IO_vtables;
  v12 = v10 - (_QWORD)_start___libc_IO_vtables;
  if ( (char *)&_start___libc_atexit - (char *)_start___libc_IO_vtables <= (unsigned __int64)(v10
                                                                                            - (_QWORD)_start___libc_IO_vtables) )
    IO_vtable_check(a1, _RSI, (__int64)_start___libc_IO_vtables, v12, a5, a6);
  _RSI = 0LL;
  (*(void (__fastcall **)(__int64, _QWORD, u32 *, __int64, u32 *))(v10 + 16))(v7, 0LL, v11, v12, a5);
  if ( *(int *)(v7 + 192) > 0 )
  {
    v22 = *(_QWORD *)(v7 + 152);
    _RSI = 1LL;
    if ( _libc_multiple_threads )
    {
      if ( !_InterlockedCompareExchange(&_gconv_lock, 1, 0) )
      {
LABEL_37:
        _gconv_release_step(*(_QWORD *)(v22 + 72));
        _gconv_release_step(*(_QWORD *)(v22 + 136));
        if ( _libc_multiple_threads )
        {
          if ( !_InterlockedDecrement(&_gconv_lock) )
            goto LABEL_9;
        }
        else if ( !--_gconv_lock )
        {
          goto LABEL_9;
        }
        _lll_unlock_wake_private((u32 *)&_gconv_lock, 1LL, v14, v15, v16, v17);
        goto LABEL_9;
      }
    }
    else
    {
      __asm { cmpxchg cs:__gconv_lock, esi }
      if ( !_libc_multiple_threads )
        goto LABEL_37;
    }
    _lll_lock_wait_private((u32 *)&_gconv_lock, 1LL, v14, v15, v16, v17);
    goto LABEL_37;
  }
  if ( *(_QWORD *)(v7 + 72) )
    IO_free_backup_area((int *)v7, 0LL, v14, v15, v16, v17);
LABEL_9:
  if ( stdin != (void *)v7 && stdout != (void *)v7 && stderr != (void *)v7 )
    free(v7, _RSI, v14, v15, v16, v17);
  return v9;
}
// 409550: variable 'a5' is possibly undefined
// 409550: variable 'a6' is possibly undefined
// 409380: variable 'v11' is possibly undefined
// 409380: variable 'v12' is possibly undefined
// 40939D: variable 'v14' is possibly undefined
// 40939D: variable 'v15' is possibly undefined
// 40939D: variable 'v16' is possibly undefined
// 40939D: variable 'v17' is possibly undefined
// 409419: variable 'a4' is possibly undefined
// 4A8798: using guessed type void *stderr;
// 4A87A0: using guessed type void *stdout;
// 4A87A8: using guessed type void *stdin;
// 4A9C40: using guessed type u32 _start___libc_IO_vtables[48];
// 4AA2E8: using guessed type __int64 (__fastcall *_start___libc_atexit)();
// 4AB820: using guessed type int _libc_multiple_threads;
// 4AB970: using guessed type int _gconv_lock;

//----- (0000000000409570) ----------------------------------------------------
__int64 __fastcall fflush(__int64 a1, unsigned __int64 _RSI, __int64 a3, __int64 a4, __int64 _R8, unsigned __int64 a6)
{
  __int64 v6; // rbx
  bool v7; // zf
  __int64 v8; // rbp
  u32 *v9; // rdx
  __int64 v10; // rcx
  __int64 v11; // rdx
  __int64 v12; // rcx
  u32 *v13; // r8
  u32 v14; // er9
  __int64 v15; // rsi

  if ( a1 )
  {
    v6 = a1;
    if ( (*(_DWORD *)a1 & 0x8000) != 0 )
      goto LABEL_11;
    _R8 = *(_QWORD *)(a1 + 136);
    a6 = __readfsqword(0x10u);
    if ( *(_QWORD *)(_R8 + 8) == a6 )
    {
LABEL_10:
      ++*(_DWORD *)(_R8 + 4);
LABEL_11:
      v8 = *(_QWORD *)(v6 + 216);
      v9 = _start___libc_IO_vtables;
      v10 = v8 - (_QWORD)_start___libc_IO_vtables;
      if ( (char *)&_start___libc_atexit - (char *)_start___libc_IO_vtables <= (unsigned __int64)(v8
                                                                                                - (_QWORD)_start___libc_IO_vtables) )
        IO_vtable_check(a1, _RSI, (__int64)_start___libc_IO_vtables, v10, (u32 *)_R8, a6);
      v11 = (unsigned int)-((*(unsigned int (__fastcall **)(__int64, unsigned __int64, u32 *, __int64, __int64))(v8 + 96))(
                              v6,
                              _RSI,
                              v9,
                              v10,
                              _R8) != 0);
      if ( (*(_DWORD *)v6 & 0x8000) != 0 )
        return (unsigned int)v11;
      v15 = *(_QWORD *)(v6 + 136);
      v7 = (*(_DWORD *)(v15 + 4))-- == 1;
      if ( !v7 )
        return (unsigned int)v11;
      *(_QWORD *)(v15 + 8) = 0LL;
      if ( _libc_multiple_threads )
      {
        if ( !_InterlockedDecrement((volatile signed __int32 *)v15) )
          return (unsigned int)v11;
      }
      else
      {
        v7 = (*(_DWORD *)v15)-- == 1;
        if ( v7 )
          return (unsigned int)v11;
      }
      _lll_unlock_wake_private((u32 *)v15, v15, v11, v12, v13, v14);
      return (unsigned int)v11;
    }
    _RSI = 1LL;
    v7 = _libc_multiple_threads == 0;
    if ( _libc_multiple_threads )
    {
      if ( !_InterlockedCompareExchange((volatile signed __int32 *)_R8, 1, 0) )
        goto LABEL_9;
    }
    else
    {
      __asm { cmpxchg [r8], esi }
      if ( v7 )
      {
LABEL_9:
        _R8 = *(_QWORD *)(v6 + 136);
        *(_QWORD *)(_R8 + 8) = a6;
        goto LABEL_10;
      }
    }
    a1 = _R8;
    _lll_lock_wait_private((u32 *)_R8, 1LL, a3, a4, (u32 *)_R8, a6);
    goto LABEL_9;
  }
  return IO_flush_all(0LL, _RSI, a3, a4, (u32 *)_R8, a6);
}
// 4095DF: variable 'a6' is possibly undefined
// 40960E: variable 'v9' is possibly undefined
// 40960E: variable 'v10' is possibly undefined
// 40960E: variable '_R8' is possibly undefined
// 409655: variable 'v12' is possibly undefined
// 409655: variable 'v13' is possibly undefined
// 409655: variable 'v14' is possibly undefined
// 409665: variable 'v11' is possibly undefined
// 4A9C40: using guessed type u32 _start___libc_IO_vtables[48];
// 4AA2E8: using guessed type __int64 (__fastcall *_start___libc_atexit)();
// 4AB820: using guessed type int _libc_multiple_threads;

//----- (0000000000409690) ----------------------------------------------------
__int64 __fastcall _fopen_maybe_mmap(__int64 a1)
{
  __int64 result; // rax
  u32 *v2; // rdx

  result = a1;
  if ( (*(_BYTE *)(a1 + 116) & 1) != 0 && (*(_BYTE *)a1 & 8) != 0 )
  {
    v2 = (u32 *)&IO_file_jumps_maybe_mmap;
    if ( *(int *)(a1 + 192) > 0 )
      v2 = _start___libc_IO_vtables;
    *(_QWORD *)(a1 + 216) = v2;
    *(_QWORD *)(*(_QWORD *)(a1 + 160) + 304LL) = _start___libc_IO_vtables;
  }
  return result;
}
// 4A9C40: using guessed type u32 _start___libc_IO_vtables[48];

//----- (00000000004096E0) ----------------------------------------------------
__int64 __fastcall _fopen_internal(const char *a1, _BYTE *a2, _QWORD *a3, __int64 a4, u32 *a5, __int64 a6)
{
  _QWORD *v6; // rax
  __int64 v7; // rbx
  __int64 v8; // rdx
  __int64 v9; // rcx
  __int64 v10; // r8
  u32 v11; // er9
  __int64 v12; // rdx
  unsigned int *v13; // rcx
  u32 *v14; // r8
  u32 v15; // er9
  u32 *v16; // rax
  __int64 v18; // rdx
  __int64 v19; // rcx
  u32 *v20; // r8
  unsigned __int64 v21; // r9

  v6 = malloc(0x228uLL, (__int64)a2, a3, a4, a5, a6);
  if ( !v6 )
    return 0LL;
  v7 = (__int64)v6;
  v6[17] = v6 + 28;
  IO_no_init((__int64)v6, 0);
  *(_QWORD *)(v7 + 216) = &IO_file_jumps;
  IO_new_file_init_internal(v7, 0LL, v8, v9, v10, v11);
  if ( IO_new_file_fopen(v7, a1, a2) )
  {
    if ( (*(_BYTE *)(v7 + 116) & 1) != 0 && (*(_BYTE *)v7 & 8) != 0 )
    {
      v16 = (u32 *)&IO_file_jumps_maybe_mmap;
      if ( *(int *)(v7 + 192) > 0 )
        v16 = _start___libc_IO_vtables;
      *(_QWORD *)(v7 + 216) = v16;
      *(_QWORD *)(*(_QWORD *)(v7 + 160) + 304LL) = _start___libc_IO_vtables;
    }
    return v7;
  }
  else
  {
    IO_un_link((unsigned int *)v7, (__int64)a1, v12, v13, v14, v15);
    free(v7, (__int64)a1, v18, v19, v20, v21);
    return 0LL;
  }
}
// 409747: variable 'v8' is possibly undefined
// 409747: variable 'v9' is possibly undefined
// 409747: variable 'v10' is possibly undefined
// 409747: variable 'v11' is possibly undefined
// 4097C5: variable 'v12' is possibly undefined
// 4097C5: variable 'v13' is possibly undefined
// 4097C5: variable 'v14' is possibly undefined
// 4097C5: variable 'v15' is possibly undefined
// 4097CD: variable 'v18' is possibly undefined
// 4097CD: variable 'v19' is possibly undefined
// 4097CD: variable 'v20' is possibly undefined
// 4097CD: variable 'v21' is possibly undefined
// 4A9C40: using guessed type u32 _start___libc_IO_vtables[48];

//----- (00000000004097E0) ----------------------------------------------------
__int64 __fastcall fopen64(const char *a1, _BYTE *a2, __int64 a3, __int64 a4, u32 *a5, __int64 a6)
{
  return _fopen_internal(a1, a2, (_QWORD *)1, a4, a5, a6);
}

//----- (00000000004097F0) ----------------------------------------------------
__int64 __fastcall puts(__int64 a1, __int64 _RSI)
{
  __int64 v3; // rax
  __int64 v4; // rcx
  u32 *v5; // r8
  __int64 v6; // r9
  _QWORD *v7; // rbp
  __int64 v8; // rbx
  _DWORD *v9; // rdi
  bool v11; // zf
  int v12; // eax
  __int64 v13; // r13
  __int64 v14; // rdx
  _BYTE *v15; // rax
  unsigned __int64 v16; // rbx
  __int64 v17; // rdx

  v3 = j_strlen_ifunc(a1);
  v7 = stdout;
  v8 = v3;
  v9 = stdout;
  if ( (*(_DWORD *)stdout & 0x8000) == 0 )
  {
    _RDX = *((_QWORD *)stdout + 17);
    v5 = (u32 *)__readfsqword(0x10u);
    if ( *(u32 **)(_RDX + 8) == v5 )
    {
LABEL_9:
      ++*(_DWORD *)(_RDX + 4);
      goto LABEL_10;
    }
    _RSI = 1LL;
    v11 = _libc_multiple_threads == 0;
    if ( _libc_multiple_threads )
    {
      if ( !_InterlockedCompareExchange((volatile signed __int32 *)_RDX, 1, 0) )
        goto LABEL_8;
    }
    else
    {
      __asm { cmpxchg [rdx], esi }
      if ( v11 )
      {
LABEL_8:
        _RDX = v7[17];
        v9 = stdout;
        *(_QWORD *)(_RDX + 8) = v5;
        goto LABEL_9;
      }
    }
    _lll_lock_wait_private((u32 *)_RDX, 1LL, _RDX, v4, v5, v6);
    goto LABEL_8;
  }
LABEL_10:
  v12 = v9[48];
  if ( v12 )
  {
    if ( v12 != -1 )
      goto LABEL_28;
  }
  else
  {
    v9[48] = -1;
  }
  v13 = *((_QWORD *)v9 + 27);
  if ( (char *)&_start___libc_atexit - (char *)_start___libc_IO_vtables <= (unsigned __int64)(v13
                                                                                            - (_QWORD)_start___libc_IO_vtables) )
  {
    IO_vtable_check(
      (__int64)v9,
      _RSI,
      (__int64)_start___libc_IO_vtables,
      v13 - (_QWORD)_start___libc_IO_vtables,
      v5,
      v6);
    v9 = stdout;
  }
  _RSI = a1;
  if ( v8 != (*(__int64 (__fastcall **)(_DWORD *, __int64, __int64))(v13 + 56))(v9, a1, v8) )
    goto LABEL_28;
  v15 = (_BYTE *)*((_QWORD *)stdout + 5);
  if ( (unsigned __int64)v15 < *((_QWORD *)stdout + 6) )
  {
    *((_QWORD *)stdout + 5) = v15 + 1;
    *v15 = 10;
    goto LABEL_17;
  }
  _RSI = 10LL;
  if ( (unsigned int)_overflow((__int64)stdout, 10LL, v14, v4, v5, v6) == -1 )
  {
LABEL_28:
    LODWORD(v16) = -1;
    goto LABEL_19;
  }
LABEL_17:
  v16 = v8 + 1;
  if ( v16 > 0x7FFFFFFF )
    LODWORD(v16) = 0x7FFFFFFF;
LABEL_19:
  if ( (*(_DWORD *)v7 & 0x8000) == 0 )
  {
    v17 = v7[17];
    v11 = (*(_DWORD *)(v17 + 4))-- == 1;
    if ( v11 )
    {
      *(_QWORD *)(v17 + 8) = 0LL;
      if ( _libc_multiple_threads )
      {
        if ( !_InterlockedDecrement((volatile signed __int32 *)v17) )
          return (unsigned int)v16;
        goto LABEL_25;
      }
      v11 = (*(_DWORD *)v17)-- == 1;
      if ( !v11 )
LABEL_25:
        _lll_unlock_wake_private((u32 *)v17, _RSI, v17, v4, v5, v6);
    }
  }
  return (unsigned int)v16;
}
// 409858: variable 'v4' is possibly undefined
// 409858: variable 'v6' is possibly undefined
// 409872: variable 'v5' is possibly undefined
// 40998D: variable 'v14' is possibly undefined
// 4010C8: using guessed type __int64 __fastcall j_strlen_ifunc(_QWORD);
// 4A87A0: using guessed type void *stdout;
// 4A9C40: using guessed type u32 _start___libc_IO_vtables[48];
// 4AA2E8: using guessed type __int64 (__fastcall *_start___libc_atexit)();
// 4AB820: using guessed type int _libc_multiple_threads;

//----- (00000000004099B0) ----------------------------------------------------
__int64 __fastcall adjust_wide_data(__int64 a1, char a2)
{
  __int64 v2; // rbp
  int v3; // eax
  _QWORD *v4; // rcx
  __int64 v5; // rax
  __int64 v6; // rdx
  _QWORD *v7; // rax
  __int64 v8; // r9
  int v9; // eax
  __int64 v11[5]; // [rsp+0h] [rbp-28h] BYREF

  v2 = *(_QWORD *)(a1 + 152);
  v11[1] = __readfsqword(0x28u);
  v3 = (*(__int64 (__fastcall **)(__int64))(v2 + 32))(v2);
  if ( a2 == 1 || v3 <= 0 )
  {
    v6 = *(_QWORD *)(a1 + 24);
    v11[0] = v6;
    while ( 1 )
    {
      v7 = *(_QWORD **)(a1 + 160);
      v8 = v7[2];
      v7[12] = v7[11];
      v9 = (*(__int64 (__fastcall **)(__int64, _QWORD *, __int64, _QWORD, __int64 *, __int64, _QWORD, _QWORD *))(v2 + 24))(
             v2,
             v7 + 11,
             v6,
             *(_QWORD *)(a1 + 8),
             v11,
             v8,
             v7[7],
             v7 + 1);
      if ( v9 == 2 )
        break;
      if ( v9 != 1 )
      {
        v4 = *(_QWORD **)(a1 + 160);
        v5 = v4[1];
        goto LABEL_8;
      }
      v6 = *(_QWORD *)(a1 + 24);
    }
    *(_DWORD *)a1 |= 0x20u;
    return 0xFFFFFFFFLL;
  }
  else
  {
    v4 = *(_QWORD **)(a1 + 160);
    v5 = v4[1] + 4 * ((*(_QWORD *)(a1 + 8) - *(_QWORD *)(a1 + 24)) / v3);
    v4[1] = v5;
LABEL_8:
    *v4 = v5;
    return 0LL;
  }
}

//----- (0000000000409AA0) ----------------------------------------------------
__int64 __fastcall IO_wfile_underflow(
        __int64 a1,
        unsigned __int64 _RSI,
        __int64 a3,
        __int64 a4,
        void *a5,
        unsigned __int64 _R9)
{
  int v6; // eax
  __int64 v7; // rbx
  unsigned int **v8; // rax
  unsigned __int64 v9; // rdx
  unsigned __int64 v10; // rcx
  __int64 v11; // r12
  unsigned int *v12; // r9
  unsigned int *v13; // rsi
  int v14; // eax
  unsigned int **v15; // rdx
  __int64 v16; // rax
  __int64 result; // rax
  __int64 v18; // rax
  unsigned __int64 v19; // r14
  __int64 v20; // rdx
  _QWORD *v21; // rbp
  unsigned __int64 v22; // r10
  bool v23; // zf
  char *v24; // rdi
  unsigned __int64 v25; // rbp
  char *v26; // rcx
  u32 *v27; // r8
  __int64 v28; // r9
  _QWORD *v29; // rax
  unsigned int **v30; // rdx
  unsigned __int64 v31; // r15
  __int64 v32; // r15
  __int64 v33; // rax
  __int64 v34; // rdx
  __int64 v35; // rcx
  _QWORD *v36; // r15
  __int64 v37; // rsi
  int v38; // eax
  int v39; // edx
  __int64 v40; // r8
  __int64 v41; // rax
  unsigned __int64 v42; // rdx
  __int64 v43; // rax
  __int64 v44; // r13
  __int64 v45; // rdi
  __int64 v46; // rdi
  unsigned __int64 v47; // [rsp+10h] [rbp-88h]
  char *v48; // [rsp+10h] [rbp-88h]
  unsigned __int64 v49; // [rsp+10h] [rbp-88h]
  __int64 v50; // [rsp+18h] [rbp-80h]
  unsigned __int64 v51; // [rsp+38h] [rbp-60h] BYREF
  char v52[24]; // [rsp+40h] [rbp-58h] BYREF
  unsigned __int64 v53; // [rsp+58h] [rbp-40h]

  v53 = __readfsqword(0x28u);
  v6 = *(_DWORD *)a1;
  if ( (*(_DWORD *)a1 & 0x10) != 0 )
    return 0xFFFFFFFFLL;
  v7 = a1;
  if ( (v6 & 4) != 0 )
  {
    *(_DWORD *)a1 = v6 | 0x20;
    __writefsdword(0xFFFFFFC0, 9u);
    return 0xFFFFFFFFLL;
  }
  v8 = *(unsigned int ***)(a1 + 160);
  if ( *v8 < v8[1] )
    return **v8;
  v9 = *(_QWORD *)(a1 + 8);
  v10 = *(_QWORD *)(a1 + 16);
  v11 = *(_QWORD *)(a1 + 152);
  if ( v9 >= v10 )
  {
    v16 = *(_QWORD *)(a1 + 56);
    *(_QWORD *)(a1 + 16) = v16;
    *(_QWORD *)(a1 + 8) = v16;
    *(_QWORD *)(a1 + 24) = v16;
  }
  else
  {
    v12 = v8[6];
    v13 = v8[11];
    v51 = *(_QWORD *)(a1 + 8);
    v8[12] = v13;
    *v8 = v12;
    v8[2] = v12;
    v14 = (*(__int64 (__fastcall **)(__int64, unsigned int **, unsigned __int64, unsigned __int64, unsigned __int64 *))(v11 + 24))(
            v11,
            v8 + 11,
            v9,
            v10,
            &v51);
    _RSI = v51;
    *(_QWORD *)(a1 + 24) = *(_QWORD *)(a1 + 8);
    v15 = *(unsigned int ***)(a1 + 160);
    *(_QWORD *)(a1 + 8) = _RSI;
    if ( *v15 < v15[1] )
      return **v15;
    if ( v14 == 2 )
    {
LABEL_9:
      __writefsdword(0xFFFFFFC0, 0x54u);
      *(_DWORD *)v7 |= 0x20u;
      return 0xFFFFFFFFLL;
    }
    a1 = *(_QWORD *)(a1 + 56);
    j_memmove(a1, _RSI, *(_QWORD *)(v7 + 16) - _RSI);
    v16 = *(_QWORD *)(v7 + 56);
    v9 = v16 + *(_QWORD *)(v7 + 16) - *(_QWORD *)(v7 + 8);
    *(_QWORD *)(v7 + 24) = v16;
    *(_QWORD *)(v7 + 16) = v9;
    *(_QWORD *)(v7 + 8) = v16;
  }
  if ( !v16 )
  {
    v46 = *(_QWORD *)(v7 + 72);
    if ( v46 )
    {
      free(v46, _RSI, v9, v10, (u32 *)a5, _R9);
      *(_DWORD *)v7 &= ~0x100u;
    }
    a1 = v7;
    IO_doallocbuf(v7, _RSI, v9, v10, (u32 *)a5, _R9);
    v16 = *(_QWORD *)(v7 + 56);
    *(_QWORD *)(v7 + 16) = v16;
    *(_QWORD *)(v7 + 8) = v16;
    *(_QWORD *)(v7 + 24) = v16;
  }
  *(_QWORD *)(v7 + 48) = v16;
  *(_QWORD *)(v7 + 40) = v16;
  *(_QWORD *)(v7 + 32) = v16;
  v18 = *(_QWORD *)(v7 + 160);
  if ( !*(_QWORD *)(v18 + 48) )
  {
    v45 = *(_QWORD *)(v18 + 64);
    if ( v45 )
    {
      free(v45, _RSI, v9, v10, (u32 *)a5, _R9);
      *(_DWORD *)v7 &= ~0x100u;
    }
    a1 = v7;
    IO_wdoallocbuf(v7, _RSI, v9, v10, (__int64)a5, _R9);
  }
  v19 = (char *)&_start___libc_atexit - (char *)_start___libc_IO_vtables;
  if ( (*(_DWORD *)v7 & 0x202) == 0 )
    goto LABEL_31;
  a5 = stdout;
  v20 = *(unsigned int *)stdout;
  v21 = stdout;
  if ( (*(_DWORD *)stdout & 0x8000) == 0 )
  {
    _R9 = *((_QWORD *)stdout + 17);
    v22 = __readfsqword(0x10u);
    if ( *(_QWORD *)(_R9 + 8) == v22 )
      goto LABEL_23;
    _RSI = 1LL;
    v23 = _libc_multiple_threads == 0;
    if ( _libc_multiple_threads )
    {
      if ( !_InterlockedCompareExchange((volatile signed __int32 *)_R9, 1, 0) )
        goto LABEL_22;
    }
    else
    {
      __asm { cmpxchg [r9], esi }
      if ( v23 )
      {
LABEL_22:
        _R9 = *((_QWORD *)a5 + 17);
        a5 = stdout;
        *(_QWORD *)(_R9 + 8) = v22;
        LODWORD(v20) = *(_DWORD *)a5;
LABEL_23:
        v9 = v20 & 0x288;
        ++*(_DWORD *)(_R9 + 4);
        if ( (_DWORD)v9 != 640 )
          goto LABEL_24;
        goto LABEL_64;
      }
    }
    a1 = _R9;
    _lll_lock_wait_private((u32 *)_R9, 1LL, v20, v10, (u32 *)a5, _R9);
    goto LABEL_22;
  }
  v9 = v20 & 0x288;
  if ( (_DWORD)v9 != 640 )
    goto LABEL_31;
LABEL_64:
  v44 = *((_QWORD *)a5 + 27);
  if ( v44 - (__int64)_start___libc_IO_vtables >= v19 )
  {
    IO_vtable_check(a1, _RSI, v9, v10, (u32 *)a5, _R9);
    a5 = stdout;
  }
  _RSI = 0xFFFFFFFFLL;
  (*(void (__fastcall **)(void *, __int64))(v44 + 24))(a5, 0xFFFFFFFFLL);
LABEL_24:
  if ( (*(_DWORD *)v21 & 0x8000) != 0 )
    goto LABEL_31;
  v9 = v21[17];
  v23 = (*(_DWORD *)(v9 + 4))-- == 1;
  if ( !v23 )
    goto LABEL_31;
  *(_QWORD *)(v9 + 8) = 0LL;
  if ( _libc_multiple_threads )
  {
    if ( !_InterlockedDecrement((volatile signed __int32 *)v9) )
      goto LABEL_31;
    goto LABEL_30;
  }
  v23 = (*(_DWORD *)v9)-- == 1;
  if ( !v23 )
LABEL_30:
    _lll_unlock_wake_private((u32 *)v9, _RSI, v9, v10, (u32 *)a5, _R9);
LABEL_31:
  v24 = (char *)v7;
  v25 = 0LL;
  IO_switch_to_get_mode(v7, _RSI, v9, v10, (u32 *)a5, _R9);
  v29 = *(_QWORD **)(v7 + 160);
  v30 = (unsigned int **)v29[6];
  *v29 = v30;
  v29[2] = v30;
  v29[1] = v30;
  v29[5] = v30;
  v29[4] = v30;
  v29[3] = v30;
  while ( 1 )
  {
    v32 = *(_QWORD *)(v7 + 216);
    if ( v32 - (__int64)_start___libc_IO_vtables >= v19 )
      IO_vtable_check((__int64)v24, _RSI, (__int64)v30, (__int64)v26, v27, v28);
    v33 = (*(__int64 (__fastcall **)(__int64, _QWORD, _QWORD))(v32 + 112))(
            v7,
            *(_QWORD *)(v7 + 16),
            *(_QWORD *)(v7 + 64) - *(_QWORD *)(v7 + 16));
    if ( v33 <= 0 )
      break;
    v34 = *(_QWORD *)(v7 + 144);
    v35 = v33 + *(_QWORD *)(v7 + 16);
    *(_QWORD *)(v7 + 16) = v35;
    if ( v34 != -1 )
      *(_QWORD *)(v7 + 144) = v33 + v34;
    v36 = *(_QWORD **)(v7 + 160);
    v37 = *(_QWORD *)(v7 + 8);
    v36[12] = v36[11];
    *(_QWORD *)(v7 + 24) = v37;
    if ( v25 )
    {
      v40 = 16 - v25;
      v48 = &v52[v25];
      if ( 16 - v25 > v33 )
        v40 = v33;
      v50 = v40;
      v41 = j_mempcpy(&v52[v25], v37, v40);
      v25 += v50;
      v38 = (*(__int64 (__fastcall **)(__int64, _QWORD *, char *, __int64, unsigned __int64 *, _QWORD, _QWORD, _QWORD *))(v11 + 24))(
              v11,
              v36 + 11,
              v52,
              v41,
              &v51,
              v36[1],
              v36[7],
              v36 + 1);
      if ( v25 )
      {
        v26 = (char *)v51;
        v42 = v51 - (_QWORD)v48;
        if ( (__int64)(v51 - (_QWORD)v48) < 0 )
          v42 = 0LL;
        _RSI = v42 + *(_QWORD *)(v7 + 8);
        goto LABEL_44;
      }
    }
    else
    {
      v38 = (*(__int64 (__fastcall **)(__int64, _QWORD *, __int64, __int64, unsigned __int64 *, _QWORD, _QWORD, _QWORD *))(v11 + 24))(
              v11,
              v36 + 11,
              v37,
              v35,
              &v51,
              v36[1],
              v36[7],
              v36 + 1);
    }
    v26 = (char *)v51;
    v25 = 0LL;
    _RSI = v51;
LABEL_44:
    v30 = *(unsigned int ***)(v7 + 160);
    *(_QWORD *)(v7 + 8) = _RSI;
    v24 = (char *)v30[6];
    if ( v30[1] != (unsigned int *)v24 )
      return **v30;
    if ( v38 == 2 )
      goto LABEL_9;
    if ( v38 != 1 )
      _assert_fail((__int64)"status == __codecvt_partial", (__int64)"wfileops.c", 0x122u, "_IO_wfile_underflow");
    if ( v25 )
    {
      if ( v26 != v52 )
      {
        v25 -= v26 - v52;
        _RSI = (unsigned __int64)v26;
        v24 = v52;
        j_memmove(v52, v26, v25);
      }
      if ( v25 == 16 )
        goto LABEL_9;
      v31 = *(_QWORD *)(v7 + 24);
LABEL_35:
      *(_QWORD *)(v7 + 16) = v31;
      *(_QWORD *)(v7 + 8) = v31;
    }
    else
    {
      v31 = *(_QWORD *)(v7 + 24);
      if ( v31 >= _RSI )
      {
        if ( *(_QWORD *)(v7 + 16) - _RSI > 0xF )
          goto LABEL_9;
        v24 = v52;
        v47 = *(_QWORD *)(v7 + 16) - _RSI;
        j_memcpy(v52, _RSI, v47);
        v26 = (char *)v47;
        v25 = v47;
        goto LABEL_35;
      }
      v24 = *(char **)(v7 + 24);
      v49 = *(_QWORD *)(v7 + 16) - _RSI;
      j_memmove(v24, _RSI, v49);
      v43 = *(_QWORD *)(v7 + 24);
      v26 = (char *)v49;
      *(_QWORD *)(v7 + 16) -= v49;
      *(_QWORD *)(v7 + 8) = v43;
    }
  }
  v39 = *(_DWORD *)v7;
  if ( !(v25 | v33) )
  {
    result = -1LL;
    *(_DWORD *)v7 = v39 | 0x10;
    *(_QWORD *)(v7 + 144) = -1LL;
    return result;
  }
  *(_DWORD *)v7 = v39 | 0x20;
  if ( v25 )
  {
    __writefsdword(0xFFFFFFC0, 0x54u);
    return 0xFFFFFFFFLL;
  }
  return 0xFFFFFFFFLL;
}
// 409C88: variable 'v10' is possibly undefined
// 409C94: variable 'a5' is possibly undefined
// 409CA2: variable 'v22' is possibly undefined
// 409CFC: variable '_R9' is possibly undefined
// 409D1A: variable 'v9' is possibly undefined
// 409F00: variable 'v30' is possibly undefined
// 409F00: variable 'v26' is possibly undefined
// 409F00: variable 'v27' is possibly undefined
// 409F00: variable 'v28' is possibly undefined
// 401030: using guessed type __int64 __fastcall j_memmove(_QWORD, _QWORD, _QWORD);
// 401040: using guessed type __int64 __fastcall j_memcpy(_QWORD, _QWORD, _QWORD);
// 4010B0: using guessed type __int64 __fastcall j_mempcpy(_QWORD, _QWORD, _QWORD);
// 4A87A0: using guessed type void *stdout;
// 4A9C40: using guessed type u32 _start___libc_IO_vtables[48];
// 4AA2E8: using guessed type __int64 (__fastcall *_start___libc_atexit)();
// 4AB820: using guessed type int _libc_multiple_threads;
// 409AA0: using guessed type char var_58[24];

//----- (000000000040A100) ----------------------------------------------------
__int64 __fastcall IO_wfile_seekoff(__int64 a1, __int64 a2, unsigned int a3, __int64 a4, u32 *a5, unsigned __int64 a6)
{
  __int64 v6; // r13
  u32 **v7; // rax
  __int64 v9; // rbx
  u32 *v10; // rcx
  __int64 v11; // rdx
  int v12; // er14
  __int64 result; // rax
  __int64 v14; // r15
  unsigned __int64 v15; // rbp
  int v16; // eax
  __int64 v17; // rdx
  __int64 v18; // rax
  __int64 v19; // rsi
  __int64 v20; // rcx
  __int64 v21; // r15
  __int64 v22; // r9
  __int64 v23; // r15
  __int64 v24; // rax
  __int64 (__fastcall *v25)(__int64, __int64, u32 *); // rax
  u32 *v26; // rdx
  __int64 v27; // rax
  __int64 v28; // r14
  __int64 v29; // rax
  __int64 v30; // rdx
  char *v31; // rcx
  _QWORD *v32; // rax
  __int64 v33; // rdx
  __int64 v34; // rdi
  __int64 v35; // rax
  __int64 *v36; // rax
  __int64 v37; // rbp
  int v38; // eax
  __int64 v39; // rax
  __int64 v40; // rdx
  __int64 v41; // rcx
  u32 *v42; // r8
  __int64 v43; // r9
  __int64 v44; // r14
  __int64 v45; // rdx
  _QWORD *v46; // rdx
  __int64 v47; // rcx
  int v48; // edx
  u32 *v49; // rbp
  u32 *v50; // rbx
  int v51; // er12
  __int64 v52; // r14
  __int64 v53; // rax
  u32 *v54; // r8
  u32 *v55; // r14
  __int64 v56; // r15
  int v57; // eax
  _QWORD *v58; // rdx
  __int64 v59; // rcx
  __int64 v60; // rbx
  __int64 *v61; // rsi
  __int64 v62; // rcx
  __int64 v63; // rdx
  __int64 v64; // rax
  __int64 v65; // r8
  __int64 v66; // r8
  int v67; // eax
  __int64 *v68; // rax
  __int64 v69; // rax
  _QWORD *v70; // rbp
  __int64 v71; // r14
  __int64 v72; // rbx
  __int64 v73; // rbx
  __int64 v74; // rax
  __int64 v75; // rax
  __int64 v76; // rbp
  __int64 v77; // rdx
  __int64 v78; // rax
  _QWORD *v79; // rax
  __int64 v80; // rdx
  __int64 v81; // rsi
  __int64 v82; // rbp
  u32 *v83; // r8
  unsigned __int64 v84; // r9
  __int64 v85; // [rsp-10h] [rbp-118h]
  __int64 v86; // [rsp-8h] [rbp-110h]
  u32 *v87; // [rsp+8h] [rbp-100h]
  __int64 v88; // [rsp+8h] [rbp-100h]
  u32 *v89; // [rsp+10h] [rbp-F8h]
  u32 *v90; // [rsp+10h] [rbp-F8h]
  u32 *v91; // [rsp+10h] [rbp-F8h]
  __int64 v92; // [rsp+10h] [rbp-F8h]
  __int64 v93; // [rsp+10h] [rbp-F8h]
  __int64 v94; // [rsp+10h] [rbp-F8h]
  u32 *v95; // [rsp+18h] [rbp-F0h]
  _QWORD *v96; // [rsp+20h] [rbp-E8h] BYREF
  __int64 v97; // [rsp+28h] [rbp-E0h] BYREF
  __int64 v98[3]; // [rsp+30h] [rbp-D8h] BYREF
  int v99; // [rsp+48h] [rbp-C0h]
  __int64 v100; // [rsp+60h] [rbp-A8h]
  unsigned __int64 v101; // [rsp+C8h] [rbp-40h]

  v6 = a1;
  v101 = __readfsqword(0x28u);
  v7 = *(u32 ***)(a1 + 160);
  if ( !(_DWORD)a4 )
  {
    if ( v7[6] )
    {
      v48 = *(_DWORD *)a1;
      v49 = v7[4];
      v50 = v7[3];
      v51 = *(_DWORD *)a1 & 0x1000;
      if ( v49 > v50 && v51 )
      {
        v52 = *(_QWORD *)(a1 + 216);
        if ( (char *)&_start___libc_atexit - (char *)_start___libc_IO_vtables <= (unsigned __int64)(v52
                                                                                                  - (_QWORD)_start___libc_IO_vtables) )
          IO_vtable_check(a1, v52 - (_QWORD)_start___libc_IO_vtables, (__int64)_start___libc_IO_vtables, a4, a5, a6);
        a2 = 0LL;
        v53 = (*(__int64 (__fastcall **)(__int64, _QWORD, __int64, __int64, u32 *))(v52 + 128))(a1, 0LL, 2LL, a4, a5);
        if ( v53 == -1 )
          return -1LL;
        *(_QWORD *)(a1 + 144) = v53;
        v48 = *(_DWORD *)a1;
        v7 = *(u32 ***)(a1 + 160);
      }
      v54 = *v7;
      v55 = v7[1];
      if ( (v48 & 0x100) != 0 )
      {
        if ( v54 < v55 )
        {
LABEL_68:
          __writefsdword(0xFFFFFFC0, 0x16u);
          return -1LL;
        }
        v54 = v7[8];
        v55 = v7[10];
        v91 = v54;
      }
      else
      {
        v91 = v7[2];
      }
      v56 = *(_QWORD *)(a1 + 152);
      v87 = v54;
      a1 = v56;
      v57 = (*(__int64 (__fastcall **)(__int64))(v56 + 32))(v56);
      if ( v49 > v50 )
      {
        v70 = *(_QWORD **)(v6 + 160);
        a4 = v70[4];
        v71 = v70[3];
        v72 = a4 - v71;
        if ( v57 <= 0 )
        {
          v94 = v70[4];
          v97 = v70[3];
          v96 = malloc(v94 - v71, a2, v58, a4, a5, a6);
          v98[0] = v70[12];
          v88 = (__int64)v96;
          if ( (*(unsigned int (__fastcall **)(__int64, __int64 *, __int64, __int64, __int64 *, _QWORD *, __int64, _QWORD **))(v56 + 8))(
                 v56,
                 v98,
                 v71,
                 v94,
                 &v97,
                 v96,
                 (__int64)v96 + v72,
                 &v96) )
          {
            free(v88, (__int64)v98, v85, v86, v83, v84);
            return 0xFFFFFFFFLL;
          }
          a1 = v88;
          v73 = (__int64)v96 - v88;
          free(v88, (__int64)v98, v85, v86, v83, v84);
        }
        else
        {
          v73 = v57 * (v72 >> 2);
        }
        v74 = *(_QWORD *)(v6 + 40);
        if ( v51 )
          v75 = v74 - *(_QWORD *)(v6 + 32);
        else
          v75 = v74 - *(_QWORD *)(v6 + 16);
        v60 = v75 + v73;
      }
      else
      {
        v59 = *(_QWORD *)(v6 + 16);
        a5 = v87;
        if ( v57 <= 0 )
        {
          a1 = v56;
          v77 = *(_QWORD *)(v6 + 24);
          v98[0] = *(_QWORD *)(*(_QWORD *)(v6 + 160) + 96LL);
          v60 = (*(int (__fastcall **)(__int64, __int64 *, __int64, __int64, signed __int64))(v56 + 48))(
                  v56,
                  v98,
                  v77,
                  v59,
                  v87 - v91)
              - (*(_QWORD *)(v6 + 16)
               - *(_QWORD *)(v6 + 24));
        }
        else
        {
          a4 = v59 - *(_QWORD *)(v6 + 8);
          v60 = -((v55 - v87) * v57) - a4;
        }
      }
    }
    else
    {
      v60 = 0LL;
    }
    v69 = *(_QWORD *)(v6 + 144);
    if ( v69 == -1 )
    {
      v76 = *(_QWORD *)(v6 + 216);
      if ( (char *)&_start___libc_atexit - (char *)_start___libc_IO_vtables <= (unsigned __int64)(v76
                                                                                                - (_QWORD)_start___libc_IO_vtables) )
        IO_vtable_check(a1, v76 - (_QWORD)_start___libc_IO_vtables, (__int64)_start___libc_IO_vtables, a4, a5, a6);
      v69 = (*(__int64 (__fastcall **)(__int64, _QWORD, __int64, __int64, u32 *))(v76 + 128))(v6, 0LL, 1LL, a4, a5);
      if ( v69 == -1 )
        return -1LL;
    }
    result = v60 + v69;
    if ( result >= 0 )
      return result;
    goto LABEL_68;
  }
  v9 = a2;
  v10 = v7[3];
  v11 = (__int64)v7[4];
  if ( v7[2] == v7[1] && v10 == (u32 *)v11 )
  {
    v12 = 1;
  }
  else
  {
    v12 = 0;
    if ( (unsigned __int64)v10 < v11 )
      goto LABEL_4;
  }
  if ( (*(_DWORD *)a1 & 0x800) == 0 )
  {
    if ( !v7[6] )
      goto LABEL_36;
    goto LABEL_6;
  }
LABEL_4:
  v11 = (unsigned int)IO_switch_to_wget_mode((int *)a1);
  result = 0xFFFFFFFFLL;
  if ( (_DWORD)v11 )
    return result;
  v7 = *(u32 ***)(a1 + 160);
  if ( !v7[6] )
  {
LABEL_36:
    v34 = (__int64)v7[2];
    if ( v34 )
    {
      free(v34, a2, v11, (__int64)v10, a5, a6);
      *(_DWORD *)v6 &= ~0x100u;
    }
    IO_doallocbuf(v6, a2, v11, (__int64)v10, a5, a6);
    v35 = *(_QWORD *)(v6 + 56);
    *(_QWORD *)(v6 + 40) = v35;
    *(_QWORD *)(v6 + 32) = v35;
    *(_QWORD *)(v6 + 48) = v35;
    *(_QWORD *)(v6 + 24) = v35;
    *(_QWORD *)(v6 + 8) = v35;
    *(_QWORD *)(v6 + 16) = v35;
    v36 = *(__int64 **)(v6 + 160);
    v11 = v36[6];
    v36[4] = v11;
    v36[3] = v11;
    v36[5] = v11;
    v36[2] = v11;
    *v36 = v11;
    v36[1] = v11;
    if ( a3 == 1 )
      goto LABEL_39;
LABEL_7:
    if ( a3 == 2 )
    {
      v14 = *(_QWORD *)(v6 + 216);
      v15 = (char *)&_start___libc_atexit - (char *)_start___libc_IO_vtables;
      if ( (char *)&_start___libc_atexit - (char *)_start___libc_IO_vtables <= (unsigned __int64)(v14
                                                                                                - (_QWORD)_start___libc_IO_vtables) )
        IO_vtable_check((__int64)_start___libc_IO_vtables, a2, v11, (__int64)v10, a5, a6);
      a2 = (__int64)v98;
      if ( (*(unsigned int (__fastcall **)(__int64, __int64 *))(v14 + 144))(v6, v98) || (v99 & 0xF000) != 0x8000 )
        goto LABEL_44;
      v9 += v100;
      a3 = 0;
    }
    goto LABEL_13;
  }
LABEL_6:
  if ( a3 != 1 )
    goto LABEL_7;
LABEL_39:
  v37 = *(_QWORD *)(v6 + 152);
  v38 = (*(__int64 (__fastcall **)(__int64))(v37 + 32))(v37);
  if ( v38 <= 0 )
  {
    v61 = *(__int64 **)(v6 + 160);
    v62 = *(_QWORD *)(v6 + 16);
    v63 = *(_QWORD *)(v6 + 24);
    v64 = v61[12];
    v65 = *v61;
    v61 += 11;
    v66 = v65 - *(v61 - 9);
    *v61 = v64;
    v67 = (*(__int64 (__fastcall **)(__int64, __int64 *, __int64, __int64, __int64))(v37 + 48))(
            v37,
            v61,
            v63,
            v62,
            v66 >> 2);
    v10 = *(u32 **)(v6 + 24);
    v11 = v67;
    *(_QWORD *)(v6 + 8) = (char *)v10 + v67;
    v68 = *(__int64 **)(v6 + 160);
    a2 = *v68;
    v68[1] = *v68;
    v9 -= *(_QWORD *)(v6 + 16) - (_QWORD)v10 - v11;
  }
  else
  {
    v10 = *(u32 **)(v6 + 160);
    v11 = v38 * ((__int64)(*((_QWORD *)v10 + 1) - *(_QWORD *)v10) >> 2);
    v9 = a2 - v11 - (*(_QWORD *)(v6 + 16) - *(_QWORD *)(v6 + 8));
  }
  v39 = *(_QWORD *)(v6 + 144);
  if ( v39 == -1 )
    goto LABEL_43;
  v9 += v39;
  a3 = 0;
LABEL_13:
  IO_free_wbackup_area((int *)v6, a2, v11, (__int64)v10, a5, a6);
  v11 = *(_QWORD *)(v6 + 144);
  v16 = *(_DWORD *)v6;
  if ( v11 == -1
    || !*(_QWORD *)(v6 + 24)
    || (v16 & 0x100) != 0
    || (v10 = *(u32 **)(v6 + 56), a2 = (__int64)v10 + v11 - *(_QWORD *)(v6 + 16), v9 < a2)
    || v11 <= v9 )
  {
    a5 = _start___libc_IO_vtables;
    v15 = (char *)&_start___libc_atexit - (char *)_start___libc_IO_vtables;
    if ( (v16 & 4) != 0 )
      goto LABEL_44;
    v17 = *(_QWORD *)(v6 + 56);
    v18 = *(_QWORD *)(v6 + 64);
    v19 = v9 & (v17 - v18);
    v20 = v9 - v19;
    if ( v18 - v17 < v9 - v19 )
    {
      v19 = v9;
      v20 = 0LL;
    }
    v21 = *(_QWORD *)(v6 + 216);
    if ( v21 - (__int64)_start___libc_IO_vtables >= v15 )
    {
      v93 = v20;
      IO_vtable_check(v6, v19, v17, v20, _start___libc_IO_vtables, a6);
      v20 = v93;
    }
    v89 = (u32 *)v20;
    v23 = (*(__int64 (__fastcall **)(__int64, __int64, _QWORD))(v21 + 128))(v6, v19, 0LL);
    if ( v23 >= 0 )
    {
      v10 = v89;
      if ( !v89 )
      {
        v28 = 0LL;
        v11 = 0LL;
        goto LABEL_30;
      }
      v24 = *(_QWORD *)(v6 + 216);
      if ( v24 - (__int64)_start___libc_IO_vtables >= v15 )
      {
        v95 = v89;
        v92 = *(_QWORD *)(v6 + 216);
        IO_vtable_check(v6, v19, v24 - (_QWORD)_start___libc_IO_vtables, (__int64)v10, _start___libc_IO_vtables, v22);
        v10 = v95;
        v24 = v92;
      }
      v25 = *(__int64 (__fastcall **)(__int64, __int64, u32 *))(v24 + 112);
      a2 = *(_QWORD *)(v6 + 56);
      v26 = v10;
      if ( !v12 )
        v26 = (u32 *)(*(_QWORD *)(v6 + 64) - a2);
      v90 = v10;
      v27 = v25(v6, a2, v26);
      v10 = v90;
      v28 = v27;
      v11 = v27;
      if ( (__int64)v90 <= v27 )
      {
LABEL_30:
        v29 = *(_QWORD *)(v6 + 56);
        a2 = 1LL;
        *(_QWORD *)(v6 + 24) = v29;
        v30 = v29 + v11;
        v31 = (char *)v10 + v29;
        *(_QWORD *)(v6 + 40) = v29;
        *(_QWORD *)(v6 + 32) = v29;
        *(_QWORD *)(v6 + 48) = v29;
        v32 = *(_QWORD **)(v6 + 160);
        *(_QWORD *)(v6 + 16) = v30;
        v33 = v32[6];
        *(_QWORD *)(v6 + 8) = v31;
        v32[2] = v33;
        *v32 = v33;
        v32[1] = v33;
        v32[4] = v33;
        v32[3] = v33;
        v32[5] = v33;
        if ( !(unsigned int)adjust_wide_data(v6, 1) )
        {
          *(_DWORD *)v6 &= ~0x10u;
          result = v9;
          *(_QWORD *)(v6 + 144) = v28 + v23;
          return result;
        }
        goto LABEL_44;
      }
      v9 = (__int64)v90;
      a3 = 1;
      if ( v27 != -1 )
      {
        v9 = (__int64)v90 - v27;
        a3 = 1;
      }
LABEL_44:
      IO_unsave_markers((int *)v6, a2, v11, (__int64)v10, a5, a6);
      v44 = *(_QWORD *)(v6 + 216);
      if ( v44 - (__int64)_start___libc_IO_vtables >= v15 )
        IO_vtable_check(v6, a2, v40, v41, v42, v43);
      result = (*(__int64 (__fastcall **)(__int64, __int64, _QWORD))(v44 + 128))(v6, v9, a3);
      if ( result != -1 )
      {
        v45 = *(_QWORD *)(v6 + 56);
        *(_DWORD *)v6 &= ~0x10u;
        *(_QWORD *)(v6 + 144) = result;
        *(_QWORD *)(v6 + 24) = v45;
        *(_QWORD *)(v6 + 8) = v45;
        *(_QWORD *)(v6 + 16) = v45;
        *(_QWORD *)(v6 + 40) = v45;
        *(_QWORD *)(v6 + 32) = v45;
        *(_QWORD *)(v6 + 48) = v45;
        v46 = *(_QWORD **)(v6 + 160);
        v47 = v46[6];
        v46[2] = v47;
        *v46 = v47;
        v46[1] = v47;
        v46[4] = v47;
        v46[3] = v47;
        v46[5] = v47;
      }
      return result;
    }
    return -1LL;
  }
  *(_QWORD *)(v6 + 24) = v10;
  v78 = v9 - a2;
  *(_QWORD *)(v6 + 40) = v10;
  a2 = 0LL;
  *(_QWORD *)(v6 + 32) = v10;
  *(_QWORD *)(v6 + 8) = (char *)v10 + v78;
  v79 = *(_QWORD **)(v6 + 160);
  *(_QWORD *)(v6 + 48) = v10;
  v80 = v79[6];
  v79[2] = v80;
  *v79 = v80;
  v79[1] = v80;
  v79[4] = v80;
  v79[3] = v80;
  v79[5] = v80;
  if ( (unsigned int)adjust_wide_data(v6, 0) )
  {
LABEL_43:
    v15 = (char *)&_start___libc_atexit - (char *)_start___libc_IO_vtables;
    goto LABEL_44;
  }
  v81 = *(_QWORD *)(v6 + 144);
  *(_DWORD *)v6 &= ~0x10u;
  if ( v81 >= 0 )
  {
    v82 = *(_QWORD *)(v6 + 216);
    if ( (char *)&_start___libc_atexit - (char *)_start___libc_IO_vtables <= (unsigned __int64)(v82
                                                                                              - (_QWORD)_start___libc_IO_vtables) )
    {
      IO_vtable_check(
        v82 - (_QWORD)_start___libc_IO_vtables,
        v81,
        (__int64)_start___libc_IO_vtables,
        (__int64)v10,
        a5,
        a6);
      v81 = *(_QWORD *)(v6 + 144);
    }
    (*(void (__fastcall **)(__int64, __int64, _QWORD))(v82 + 128))(v6, v81, 0LL);
  }
  return v9;
}
// 40A8F0: variable 'v10' is possibly undefined
// 40A8F0: variable 'a5' is possibly undefined
// 40A8F0: variable 'a6' is possibly undefined
// 40A203: variable 'v11' is possibly undefined
// 40A81A: variable 'v22' is possibly undefined
// 40A7B0: variable 'v40' is possibly undefined
// 40A7B0: variable 'v41' is possibly undefined
// 40A7B0: variable 'v42' is possibly undefined
// 40A7B0: variable 'v43' is possibly undefined
// 40A59A: variable 'a4' is possibly undefined
// 40A908: variable 'v58' is possibly undefined
// 40A964: variable 'v85' is possibly undefined
// 40A964: variable 'v86' is possibly undefined
// 40A964: variable 'v83' is possibly undefined
// 40A964: variable 'v84' is possibly undefined
// 4A9C40: using guessed type u32 _start___libc_IO_vtables[48];
// 4AA2E8: using guessed type __int64 (__fastcall *_start___libc_atexit)();

//----- (000000000040A9B0) ----------------------------------------------------
__int64 __fastcall IO_wfile_underflow_maybe_mmap(__int64 a1, __int64 a2, __int64 a3, __int64 a4, u32 *a5, __int64 a6)
{
  __int64 result; // rax

  result = IO_file_underflow_maybe_mmap(a1, a2, a3, a4, a5, a6);
  if ( (_DWORD)result != -1 )
    return (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)(*(_QWORD *)(a1 + 160) + 304LL) + 32LL))(a1);
  return result;
}

//----- (000000000040A9F0) ----------------------------------------------------
__int64 __fastcall IO_wfile_underflow_mmap(__int64 a1, __int64 a2, __int64 a3, __int64 a4, u32 *a5, __int64 a6)
{
  unsigned __int64 *v7; // rax
  unsigned int *v8; // rdx
  __int64 v9; // rbp
  unsigned __int64 v10; // rdx
  unsigned __int64 v11; // r9
  unsigned int *v12; // rcx
  unsigned int **v13; // rax
  __int64 result; // rax
  int v15; // edx
  __int64 v16; // rdi
  __int64 v17[5]; // [rsp+0h] [rbp-28h] BYREF

  v17[1] = __readfsqword(0x28u);
  if ( (*(_DWORD *)a1 & 4) != 0 )
  {
    *(_DWORD *)a1 |= 0x20u;
    __writefsdword(0xFFFFFFC0, 9u);
    return 0xFFFFFFFFLL;
  }
  v7 = *(unsigned __int64 **)(a1 + 160);
  v8 = (unsigned int *)*v7;
  if ( *v7 < v7[1] )
    return *v8;
  v9 = *(_QWORD *)(a1 + 152);
  v10 = *(_QWORD *)(a1 + 8);
  if ( v10 < *(_QWORD *)(a1 + 16) )
  {
    v11 = v7[6];
    v17[0] = *(_QWORD *)(a1 + 8);
    if ( v11 )
      goto LABEL_5;
LABEL_11:
    v16 = v7[8];
    if ( v16 )
    {
      free(v16, a2, v10, a4, a5, v11);
      *(_DWORD *)a1 &= ~0x100u;
    }
    IO_wdoallocbuf(a1, a2, v10, a4, (__int64)a5, v11);
    v7 = *(unsigned __int64 **)(a1 + 160);
    v10 = *(_QWORD *)(a1 + 8);
    v11 = v7[6];
LABEL_5:
    v12 = (unsigned int *)v7[11];
    *v7 = v11;
    v7[2] = v11;
    v7[12] = (unsigned __int64)v12;
    (*(void (__fastcall **)(__int64, unsigned int **, unsigned __int64, _QWORD, __int64 *))(v9 + 24))(
      v9,
      (unsigned int **)v7 + 11,
      v10,
      *(_QWORD *)(a1 + 16),
      v17);
    *(_QWORD *)(a1 + 8) = v17[0];
    v13 = *(unsigned int ***)(a1 + 160);
    v8 = *v13;
    if ( *v13 >= v13[1] )
    {
      __writefsdword(0xFFFFFFC0, 0x54u);
      result = 0xFFFFFFFFLL;
      *(_DWORD *)a1 |= 0x20u;
      return result;
    }
    return *v8;
  }
  v15 = IO_file_underflow_mmap(a1, a2, v10, a4, a5, a6);
  result = 0xFFFFFFFFLL;
  if ( v15 != -1 )
  {
    v7 = *(unsigned __int64 **)(a1 + 160);
    v10 = *(_QWORD *)(a1 + 8);
    v11 = v7[6];
    v17[0] = v10;
    if ( v11 )
      goto LABEL_5;
    goto LABEL_11;
  }
  return result;
}
// 40AB05: variable 'a4' is possibly undefined
// 40AB05: variable 'a5' is possibly undefined
// 40AB13: variable 'v10' is possibly undefined
// 40AB13: variable 'v11' is possibly undefined

//----- (000000000040AB60) ----------------------------------------------------
__int64 __fastcall IO_wdo_write(__int64 a1, __int64 a2, __int64 a3, __int64 a4, u32 *a5)
{
  __int64 v6; // r15
  char *v7; // r9
  char *v8; // rbp
  __int64 v9; // r12
  int v10; // er13
  __int64 v11; // rcx
  u32 *v12; // r8
  __int64 v13; // r9
  __int64 result; // rax
  _QWORD *v15; // rdx
  int v16; // eax
  __int64 v17; // rcx
  __int64 v18; // rcx
  __int64 v19; // [rsp+20h] [rbp-68h] BYREF
  char *v20; // [rsp+28h] [rbp-60h]
  char v21[24]; // [rsp+30h] [rbp-58h] BYREF
  unsigned __int64 v22; // [rsp+48h] [rbp-40h]

  v22 = __readfsqword(0x28u);
  if ( a3 )
  {
    v6 = a3;
    v7 = *(char **)(a1 + 40);
    v8 = *(char **)(a1 + 32);
    v9 = *(_QWORD *)(a1 + 152);
    if ( *(char **)(a1 + 48) != v7 || v7 == v8 )
      goto LABEL_11;
    result = IO_new_do_write(a1, *(_QWORD *)(a1 + 32), v7 - v8, a4, a5, (__int64)v7);
    if ( (_DWORD)result != -1 )
    {
      v7 = *(char **)(a1 + 40);
      v8 = *(char **)(a1 + 32);
LABEL_11:
      while ( 1 )
      {
        if ( (unsigned __int64)(v7 - v8) <= 0xF )
        {
          v8 = v21;
          v20 = v21;
          v7 = v21;
        }
        else
        {
          v20 = v7;
        }
        v10 = (*(__int64 (__fastcall **)(__int64, __int64, __int64, __int64, __int64 *, char *))(v9 + 8))(
                v9,
                *(_QWORD *)(a1 + 160) + 88LL,
                a2,
                a2 + 4 * v6,
                &v19,
                v7);
        result = IO_new_do_write(a1, (__int64)v8, v20 - v8, v11, v12, v13);
        if ( (_DWORD)result == -1 )
          break;
        v6 -= (v19 - a2) >> 2;
        if ( v10 && (v19 == a2 || v10 != 1) )
        {
          v15 = *(_QWORD **)(a1 + 160);
          v18 = v15[6];
          result = (unsigned int)-(v6 != 0);
          v15[2] = v18;
          *v15 = v18;
          v15[1] = v18;
          v15[4] = v18;
          v15[3] = v18;
          if ( (*(_DWORD *)a1 & 0x202) != 0 )
            goto LABEL_17;
          goto LABEL_16;
        }
        if ( !v6 )
          goto LABEL_13;
        v7 = *(char **)(a1 + 40);
        v8 = *(char **)(a1 + 32);
        a2 = v19;
      }
    }
  }
  else
  {
LABEL_13:
    v15 = *(_QWORD **)(a1 + 160);
    v16 = *(_DWORD *)a1;
    v17 = v15[6];
    v15[2] = v17;
    *v15 = v17;
    v15[1] = v17;
    v15[4] = v17;
    v15[3] = v17;
    result = v16 & 0x202;
    if ( (_DWORD)result )
    {
      v15[5] = v17;
      return 0LL;
    }
    else
    {
LABEL_16:
      v18 = v15[7];
LABEL_17:
      v15[5] = v18;
    }
  }
  return result;
}
// 40AC18: variable 'v11' is possibly undefined
// 40AC18: variable 'v12' is possibly undefined
// 40AC18: variable 'v13' is possibly undefined

//----- (000000000040AD40) ----------------------------------------------------
__int64 __fastcall IO_wfile_overflow(
        unsigned int *a1,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        u32 *a5,
        unsigned __int64 a6)
{
  __int64 v6; // rcx
  unsigned int v7; // ebp
  __int64 v9; // rdx
  u32 *v10; // rax
  __int64 v11; // rsi
  __int64 v12; // rdi
  __int64 v13; // rsi
  __int64 *v14; // rdi
  unsigned int *v15; // rcx
  _DWORD *v16; // rdx
  unsigned int v17; // eax
  bool v18; // al
  __int64 v20; // rcx
  bool v21; // al
  __int64 v22; // rdx
  __int64 v23; // rcx
  u32 *v24; // r8
  unsigned __int64 v25; // r9
  __int64 v26; // rcx
  u32 *v27; // r8
  __int64 v28; // r9
  bool v29; // zf

  v6 = *a1;
  if ( (v6 & 8) != 0 )
  {
    *a1 = v6 | 0x20;
    __writefsdword(0xFFFFFFC0, 9u);
    return 0xFFFFFFFFLL;
  }
  else
  {
    v7 = a2;
    if ( (v6 & 0x800) != 0 )
      goto LABEL_7;
    v9 = *((_QWORD *)a1 + 20);
    if ( *(_QWORD *)(v9 + 24) )
    {
      v10 = *(u32 **)v9;
      a6 = *(_QWORD *)(v9 + 56);
      if ( *(_QWORD *)v9 == a6 )
      {
        v11 = *((_QWORD *)a1 + 7);
        v10 = *(u32 **)(v9 + 48);
        *((_QWORD *)a1 + 2) = v11;
        a5 = v10;
        v12 = v11;
        *(_QWORD *)v9 = v10;
        *(_QWORD *)(v9 + 8) = v10;
      }
      else
      {
        v11 = *((_QWORD *)a1 + 1);
        a5 = *(u32 **)(v9 + 8);
        v12 = *((_QWORD *)a1 + 2);
      }
    }
    else
    {
      IO_wdoallocbuf((__int64)a1, a2, v9, v6, (__int64)a5, a6);
      IO_free_wbackup_area((int *)a1, a2, v22, v23, v24, v25);
      v9 = *((_QWORD *)a1 + 20);
      v29 = *((_QWORD *)a1 + 4) == 0LL;
      v10 = *(u32 **)(v9 + 48);
      *(_QWORD *)(v9 + 16) = v10;
      *(_QWORD *)v9 = v10;
      *(_QWORD *)(v9 + 8) = v10;
      if ( v29 )
      {
        IO_doallocbuf((__int64)a1, a2, v9, v26, v27, v28);
        v9 = *((_QWORD *)a1 + 20);
        v11 = *((_QWORD *)a1 + 7);
        LODWORD(v6) = *a1;
        v10 = *(u32 **)v9;
        a6 = *(_QWORD *)(v9 + 56);
        *((_QWORD *)a1 + 2) = v11;
        v12 = v11;
        a5 = *(u32 **)(v9 + 8);
      }
      else
      {
        a6 = *(_QWORD *)(v9 + 56);
        v11 = *((_QWORD *)a1 + 1);
        a5 = v10;
        v12 = *((_QWORD *)a1 + 2);
        LODWORD(v6) = *a1;
      }
    }
    *(_QWORD *)(v9 + 32) = v10;
    *(_QWORD *)(v9 + 24) = v10;
    *(_QWORD *)(v9 + 40) = a6;
    *(_QWORD *)v9 = a5;
    *(_QWORD *)(v9 + 16) = a5;
    *((_QWORD *)a1 + 5) = v11;
    *((_QWORD *)a1 + 4) = v11;
    v13 = *((_QWORD *)a1 + 8);
    *((_QWORD *)a1 + 1) = v12;
    *((_QWORD *)a1 + 6) = v13;
    *((_QWORD *)a1 + 3) = v12;
    *a1 = v6 | 0x800;
    if ( (v6 & 0x202) != 0 )
    {
      *(_QWORD *)(v9 + 40) = v10;
      if ( v7 != -1 )
      {
LABEL_8:
        v14 = (__int64 *)*((_QWORD *)a1 + 20);
        v15 = (unsigned int *)v14[4];
        if ( v15 == (unsigned int *)v14[7] )
        {
          if ( (int)a1[48] <= 0 )
            v21 = (unsigned int)IO_new_do_write(
                                  (__int64)a1,
                                  *((_QWORD *)a1 + 4),
                                  *((_QWORD *)a1 + 5) - *((_QWORD *)a1 + 4),
                                  (__int64)v15,
                                  a5,
                                  a6) == -1;
          else
            v21 = (unsigned int)IO_wdo_write(
                                  (__int64)a1,
                                  v14[3],
                                  ((__int64)v15 - v14[3]) >> 2,
                                  (__int64)v15 - v14[3],
                                  a5) == -1;
          if ( v21 )
            return 0xFFFFFFFFLL;
          v14 = (__int64 *)*((_QWORD *)a1 + 20);
          v15 = (unsigned int *)v14[4];
          v16 = v15 + 1;
          v14[4] = (__int64)(v15 + 1);
          *v15 = v7;
          v17 = *a1;
          if ( (*a1 & 2) != 0 )
            goto LABEL_10;
        }
        else
        {
          v16 = v15 + 1;
          v14[4] = (__int64)(v15 + 1);
          *v15 = v7;
          v17 = *a1;
          if ( (*a1 & 2) != 0 )
            goto LABEL_10;
        }
        if ( (v17 & 0x200) == 0 || v7 != 10 )
          return v7;
LABEL_10:
        if ( (int)a1[48] <= 0 )
          v18 = (unsigned int)IO_new_do_write(
                                (__int64)a1,
                                *((_QWORD *)a1 + 4),
                                *((_QWORD *)a1 + 5) - *((_QWORD *)a1 + 4),
                                (__int64)v15,
                                a5,
                                a6) == -1;
        else
          v18 = (unsigned int)IO_wdo_write((__int64)a1, v14[3], ((__int64)v16 - v14[3]) >> 2, (__int64)v15, a5) == -1;
        if ( v18 )
          return 0xFFFFFFFFLL;
        return v7;
      }
    }
    else
    {
LABEL_7:
      if ( v7 != -1 )
        goto LABEL_8;
    }
    v20 = a1[48];
    if ( (int)v20 <= 0 )
      return IO_new_do_write((__int64)a1, *((_QWORD *)a1 + 4), *((_QWORD *)a1 + 5) - *((_QWORD *)a1 + 4), v20, a5, a6);
    else
      return IO_wdo_write(
               (__int64)a1,
               *(_QWORD *)(*((_QWORD *)a1 + 20) + 24LL),
               (__int64)(*(_QWORD *)(*((_QWORD *)a1 + 20) + 32LL) - *(_QWORD *)(*((_QWORD *)a1 + 20) + 24LL)) >> 2,
               v20,
               a5);
  }
}
// 40AE18: variable 'a5' is possibly undefined
// 40AF1E: variable 'a6' is possibly undefined
// 40AF78: variable 'v22' is possibly undefined
// 40AF78: variable 'v23' is possibly undefined
// 40AF78: variable 'v24' is possibly undefined
// 40AF78: variable 'v25' is possibly undefined
// 40AFD3: variable 'v26' is possibly undefined
// 40AFD3: variable 'v27' is possibly undefined
// 40AFD3: variable 'v28' is possibly undefined

//----- (000000000040B000) ----------------------------------------------------
__int64 __fastcall IO_wfile_sync(__int64 a1, __int64 a2, __int64 a3, __int64 a4, u32 *a5, __int64 a6)
{
  __int64 *v7; // rax
  unsigned __int64 v8; // rdx
  unsigned __int64 v9; // rsi
  __int64 v10; // rbp
  __int64 v11; // r13
  __int64 v12; // r12
  __int64 v13; // rdi
  int v14; // eax
  u32 *v15; // r8
  __int64 v16; // r9
  __int64 v17; // rsi
  __int64 v18; // rbp
  __int64 *v20; // rsi
  __int64 v21; // rcx
  __int64 v22; // rdx
  __int64 v23; // rax
  __int64 v24; // r8
  __int64 v25; // r8
  int v26; // eax
  __int64 v27; // rdx
  __int64 v28; // rcx
  __int64 v29; // rdx

  v7 = *(__int64 **)(a1 + 160);
  v8 = v7[4];
  v9 = v7[3];
  if ( v8 <= v9 )
    goto LABEL_5;
  if ( *(int *)(a1 + 192) <= 0 )
  {
    v9 = *(_QWORD *)(a1 + 32);
    if ( !(unsigned int)IO_new_do_write(a1, v9, *(_QWORD *)(a1 + 40) - v9, a4, a5, a6) )
      goto LABEL_4;
    return 0xFFFFFFFFLL;
  }
  if ( (unsigned int)IO_wdo_write(a1, v9, (__int64)(v8 - v9) >> 2, a4, a5) )
    return 0xFFFFFFFFLL;
LABEL_4:
  v7 = *(__int64 **)(a1 + 160);
LABEL_5:
  v10 = *v7;
  v11 = v7[1];
  if ( *v7 == v11 )
  {
LABEL_12:
    *(_QWORD *)(a1 + 144) = -1LL;
    return 0LL;
  }
  v12 = *(_QWORD *)(a1 + 152);
  v13 = v12;
  v14 = (*(__int64 (__fastcall **)(__int64, unsigned __int64, unsigned __int64, __int64, u32 *))(v12 + 32))(
          v12,
          v9,
          v8,
          a4,
          a5);
  if ( v14 <= 0 )
  {
    v20 = *(__int64 **)(a1 + 160);
    v21 = *(_QWORD *)(a1 + 16);
    v13 = v12;
    v22 = *(_QWORD *)(a1 + 24);
    v23 = v20[12];
    v24 = *v20;
    v20 += 11;
    v25 = v24 - *(v20 - 9);
    *v20 = v23;
    v26 = (*(__int64 (__fastcall **)(__int64, __int64 *, __int64, __int64, __int64))(v12 + 48))(
            v12,
            v20,
            v22,
            v21,
            v25 >> 2);
    v27 = *(_QWORD *)(a1 + 24);
    v28 = v27 + v26;
    v29 = v27 - *(_QWORD *)(a1 + 16);
    *(_QWORD *)(a1 + 8) = v28;
    v17 = v29 + v26;
  }
  else
  {
    v17 = ((v10 - v11) >> 2) * v14;
  }
  v18 = *(_QWORD *)(a1 + 216);
  if ( (char *)&_start___libc_atexit - (char *)_start___libc_IO_vtables <= (unsigned __int64)(v18
                                                                                            - (_QWORD)_start___libc_IO_vtables) )
    IO_vtable_check(v13, v17, (__int64)_start___libc_IO_vtables, v18 - (_QWORD)_start___libc_IO_vtables, v15, v16);
  if ( (*(__int64 (__fastcall **)(__int64, __int64, __int64))(v18 + 128))(a1, v17, 1LL) != -1 )
  {
    *(_QWORD *)(*(_QWORD *)(a1 + 160) + 8LL) = **(_QWORD **)(a1 + 160);
    *(_QWORD *)(a1 + 16) = *(_QWORD *)(a1 + 8);
    goto LABEL_12;
  }
  if ( __readfsdword(0xFFFFFFC0) == 29 )
    goto LABEL_12;
  return 0xFFFFFFFFLL;
}
// 40B069: variable 'v8' is possibly undefined
// 40B069: variable 'a4' is possibly undefined
// 40B069: variable 'a5' is possibly undefined
// 40B195: variable 'v15' is possibly undefined
// 40B195: variable 'v16' is possibly undefined
// 4A9C40: using guessed type u32 _start___libc_IO_vtables[48];
// 4AA2E8: using guessed type __int64 (__fastcall *_start___libc_atexit)();

//----- (000000000040B1B0) ----------------------------------------------------
unsigned __int64 __fastcall IO_wfile_xsputn(
        __int64 a1,
        unsigned __int64 a2,
        unsigned __int64 a3,
        unsigned __int64 a4,
        u32 *a5,
        __int64 a6)
{
  __int64 v7; // r12
  unsigned __int64 v8; // rbp
  _QWORD *v9; // r14
  int v10; // edx
  __int64 v11; // rdi
  int v12; // er15
  unsigned __int64 v13; // rax
  unsigned __int64 v14; // rbx
  __int64 v15; // rax
  unsigned __int64 v16; // rsi
  unsigned __int64 v17; // rbx
  __int64 v18; // rax
  __int64 v19; // rdx
  __int64 v20; // rsi
  _DWORD *v22; // rdx

  if ( !a3 )
    return 0LL;
  v7 = a2;
  v8 = a3;
  v9 = *(_QWORD **)(a1 + 160);
  v10 = *(_DWORD *)a1 & 0xA00;
  v11 = v9[4];
  if ( v10 == 2560 )
  {
    v12 = 0;
    v13 = (v9[7] - v11) >> 2;
    if ( v8 <= v13 )
    {
      a4 = a2 + 4 * v8;
      if ( a2 < a4 )
      {
        v22 = (_DWORD *)(a4 - 4);
        if ( *(_DWORD *)(a4 - 4) == 10 )
        {
LABEL_28:
          v12 = 1;
          v13 = ((__int64)((__int64)v22 - a2) >> 2) + 1;
        }
        else
        {
          while ( a2 < (unsigned __int64)v22 )
          {
            if ( *--v22 == 10 )
              goto LABEL_28;
          }
          v12 = 0;
        }
      }
    }
  }
  else
  {
    v12 = 0;
    v13 = (v9[5] - v11) >> 2;
  }
  if ( v13 )
  {
    if ( v8 <= v13 )
      v13 = v8;
    v14 = v13;
    if ( v13 > 0x14 )
    {
      v7 = a2 + 4 * v13;
      v9[4] = wmempcpy(v11, a2, v13);
    }
    else
    {
      a4 = (unsigned int)(v13 - 1);
      v15 = 0LL;
      v16 = a4 + 1;
      while ( 1 )
      {
        *(_DWORD *)(v11 + 4 * v15) = *(_DWORD *)(v7 + 4 * v15);
        if ( v15 == a4 )
          break;
        ++v15;
      }
      v7 += 4 * v16;
      v9[4] = 4 * v16 + v11;
    }
    v17 = v8 - v14;
    if ( !v17 )
      goto LABEL_13;
  }
  else
  {
    v17 = v8;
  }
  v8 += IO_wdefault_xsputn(a1, v7, v17, a4, a5, a6) - v17;
LABEL_13:
  if ( v12 )
  {
    v18 = *(_QWORD *)(a1 + 160);
    v19 = *(_QWORD *)(v18 + 32);
    v20 = *(_QWORD *)(v18 + 24);
    if ( v19 != v20 )
      IO_wdo_write(a1, v20, (v19 - v20) >> 2, a4, a5);
  }
  return v8;
}
// 40B287: variable 'a4' is possibly undefined
// 40B287: variable 'a5' is possibly undefined
// 40B304: variable 'a6' is possibly undefined

//----- (000000000040B350) ----------------------------------------------------
__int64 __fastcall vasprintf(__int64 *a1, unsigned __int64 a2, __m128i *a3, __int64 a4, u32 *a5, __int64 a6)
{
  _QWORD *v7; // rax
  unsigned __int64 v8; // rbx
  u32 *v9; // r8
  unsigned __int64 v10; // r9
  _QWORD *v11; // rdx
  __int64 v12; // rcx
  int v13; // ebp
  u32 *v14; // r8
  unsigned __int64 v15; // r9
  __int64 v16; // r14
  __int64 v17; // rcx
  __int64 v18; // rbx
  unsigned __int64 v19; // r13
  __int64 v20; // rax
  _QWORD *v22; // rax
  __int64 v23; // rdx
  __int64 v24; // rcx
  u32 *v25; // r8
  unsigned __int64 v26; // r9
  int v27[8]; // [rsp+0h] [rbp-128h] BYREF
  __int64 v28; // [rsp+20h] [rbp-108h]
  __int64 v29; // [rsp+28h] [rbp-100h]
  __int64 v30; // [rsp+30h] [rbp-F8h]
  __int64 v31; // [rsp+38h] [rbp-F0h]
  __int64 v32; // [rsp+88h] [rbp-A0h]
  void *v33; // [rsp+D8h] [rbp-50h]
  _QWORD *(__fastcall *v34)(unsigned __int64, __int64, _QWORD *, __int64, u32 *, __int64); // [rsp+E0h] [rbp-48h]
  __int64 *(__fastcall *v35)(__int64, __int64, __int64, __int64, u32 *, unsigned __int64); // [rsp+E8h] [rbp-40h]
  unsigned __int64 v36; // [rsp+F8h] [rbp-30h]

  v36 = __readfsqword(0x28u);
  v7 = malloc(0x64uLL, a2, a3, a4, a5, a6);
  if ( !v7 )
    return (unsigned int)-1;
  v8 = (unsigned __int64)v7;
  v32 = 0LL;
  IO_no_init((__int64)v27, 0x8000);
  v33 = &IO_str_jumps;
  IO_str_init_static_internal((__int64)v27, v8, 100LL, v8, v9, v10);
  v27[0] &= ~1u;
  v34 = malloc;
  v35 = free;
  v13 = vfprintf((__int64)v27, a2, a3);
  if ( v13 < 0 )
  {
    free(v31, a2, (__int64)v11, v12, v14, v15);
    return (unsigned int)v13;
  }
  v16 = v31;
  v17 = v30 - v28;
  v18 = v29 - v28;
  v19 = v29 - v28 + 1;
  if ( (unsigned __int64)(v30 - v28) >> 1 > v19
    && (v22 = malloc(v29 - v28 + 1, a2, v11, v17, v14, v15), (*a1 = (__int64)v22) != 0) )
  {
    j_memcpy(v22, v16, v18);
    free(v16, v16, v23, v24, v25, v26);
    v20 = *a1;
    if ( !*a1 )
      goto LABEL_9;
  }
  else
  {
    v20 = (__int64)realloc(v16, v19, v11, v17, v14, v15);
    *a1 = v20;
    if ( !v20 )
    {
LABEL_9:
      v20 = v31;
      *a1 = v31;
    }
  }
  *(_BYTE *)(v20 + v18) = 0;
  return (unsigned int)v13;
}
// 40B3D8: variable 'v9' is possibly undefined
// 40B3D8: variable 'v10' is possibly undefined
// 40B446: variable 'v11' is possibly undefined
// 40B446: variable 'v17' is possibly undefined
// 40B446: variable 'v14' is possibly undefined
// 40B446: variable 'v15' is possibly undefined
// 40B4A2: variable 'v23' is possibly undefined
// 40B4A2: variable 'v24' is possibly undefined
// 40B4A2: variable 'v25' is possibly undefined
// 40B4A2: variable 'v26' is possibly undefined
// 40B4C5: variable 'v12' is possibly undefined
// 401040: using guessed type __int64 __fastcall j_memcpy(_QWORD, _QWORD, _QWORD);

//----- (000000000040B4F0) ----------------------------------------------------
unsigned __int64 __fastcall _libc_message(
        char a1,
        size_t iov_base,
        __int64 a3,
        __int64 a4,
        u32 *a5,
        __int64 a6,
        char a7)
{
  _BYTE *v8; // rbx
  __int64 v9; // rdi
  unsigned int v10; // er15
  char v11; // r13
  __int64 v12; // r14
  __int64 *v13; // r12
  char v14; // dl
  _BYTE *v15; // rax
  __int64 v16; // rcx
  __int64 v17; // r9
  unsigned __int64 v18; // r8
  __int64 *v19; // rdx
  __int64 v20; // rax
  __int64 *v21; // rsi
  __int64 v22; // r14
  __int64 v23; // rsi
  struct iovec *v24; // rax
  struct iovec *v25; // r13
  __int64 v26; // r9
  __int64 v27; // r12
  _DWORD *v28; // rax
  __int64 v29; // r15
  _BYTE *v30; // rax
  size_t iov_len; // rdx
  char *v33; // rax
  void *v34; // rsp
  __int64 v35; // [rsp+0h] [rbp-20B8h]
  __int64 v36; // [rsp+8h] [rbp-20B0h] BYREF
  struct iovec v37[255]; // [rsp+10h] [rbp-20A8h] BYREF
  __int64 v38; // [rsp+1008h] [rbp-10B0h] BYREF
  _QWORD v39[514]; // [rsp+1010h] [rbp-10A8h] BYREF
  __int64 v40; // [rsp+2028h] [rbp-90h]
  int v41; // [rsp+2034h] [rbp-84h]
  unsigned int v42; // [rsp+2038h] [rbp-80h]
  char *v43; // [rsp+2040h] [rbp-78h]
  char *v44; // [rsp+2048h] [rbp-70h]
  unsigned __int64 v45; // [rsp+2050h] [rbp-68h]
  char v46; // [rsp+2058h] [rbp-60h] BYREF
  __int64 v47; // [rsp+2068h] [rbp-50h]
  __int64 v48; // [rsp+2070h] [rbp-48h]
  u32 *v49; // [rsp+2078h] [rbp-40h]
  __int64 v50; // [rsp+2080h] [rbp-38h]

  v8 = (_BYTE *)iov_base;
  v47 = a3;
  v48 = a4;
  v49 = a5;
  v50 = a6;
  v45 = __readfsqword(0x28u);
  v9 = a1 & 2;
  v42 = 16;
  v43 = &a7;
  v44 = &v46;
  if ( !(_DWORD)v9
    || (v9 = (__int64)"LIBC_FATAL_STDERR_", (v33 = secure_getenv("LIBC_FATAL_STDERR_")) != 0LL) && *v33
    || (iov_base = 2306LL, v9 = (__int64)"/dev/tty", v10 = _open_nocancel("/dev/tty", 2306, a3), v10 == -1) )
  {
    v10 = 2;
  }
  v11 = *v8;
  v12 = 0LL;
  v41 = a1 & 1;
  v13 = 0LL;
  if ( v11 )
  {
    while ( 1 )
    {
      v14 = v11;
      v15 = v8;
      do
      {
        if ( v14 == 37 && v15[1] == 115 )
          break;
        v15 = (_BYTE *)j_strchrnul(v15 + 1, 37LL);
        v14 = *v15;
      }
      while ( *v15 );
      if ( v11 == 37 && v8[1] == 115 )
      {
        if ( v42 > 0x2F )
        {
          v19 = (__int64 *)v43;
          v43 += 8;
        }
        else
        {
          v19 = (__int64 *)&v44[v42];
          v42 += 8;
        }
        v8 += 2;
        v40 = *v19;
        v20 = j_strlen_ifunc(v40);
        v16 = v40;
        v17 = v20;
      }
      else
      {
        v16 = (__int64)v8;
        v17 = v15 - v8;
        v8 = v15;
      }
      LODWORD(v18) = v12 + 1;
      v39[0] = v16;
      v39[1] = v17;
      v39[2] = v13;
      v11 = *v8;
      if ( !*v8 )
        break;
      v12 = (int)v18;
      v13 = v39;
    }
    v18 = (int)v18;
    v21 = (_QWORD *)((char *)&v39[-1] - ((16LL * (int)v18 + 16) & 0xFFFFFFFFFFFFF000LL));
    if ( &v38 != v21 )
    {
      while ( &v36 != v21 )
        ;
    }
    if ( ((16 * (_WORD)v18 + 16) & 0xFFF) != 0 )
    {
      v34 = alloca((16 * (_WORD)v18 + 16) & 0xFFF);
      *(__int64 *)((char *)&v35 + ((16 * (_WORD)v18 + 16) & 0xFFF)) = *(__int64 *)((char *)&v35
                                                                                 + ((16 * (_WORD)v18 + 16) & 0xFFF));
    }
    v22 = v12;
    v23 = 0LL;
    v24 = &v37[v22];
    v25 = v37;
    while ( 1 )
    {
      v24->iov_len = v17;
      v24->iov_base = (void *)v16;
      v23 += v17;
      if ( v24 == v37 )
        break;
      v16 = *v13;
      v17 = v13[1];
      --v24;
      v13 = (__int64 *)v13[2];
    }
    while ( sys_writev(v10, v37, v18) == -4 )
      ;
    if ( v41 )
    {
      v9 = 0LL;
      v27 = -dl_pagesize & (v26 + dl_pagesize);
      iov_base = v27;
      v28 = (_DWORD *)mmap64(0LL, v27, 3uLL, 0x22uLL, 0xFFFFFFFFuLL, 0LL);
      v29 = (__int64)v28;
      if ( v28 != (_DWORD *)-1LL )
      {
        *v28 = v27;
        v30 = v28 + 1;
        do
        {
          iov_len = v25->iov_len;
          iov_base = (size_t)v25->iov_base;
          ++v25;
          v30 = (_BYTE *)j_mempcpy(v30, iov_base, iov_len);
        }
        while ( &v37[v22 + 1] != v25 );
        *v30 = 0;
        v9 = _InterlockedExchange64(&_abort_msg, v29);
        if ( v9 )
        {
          iov_base = *(unsigned int *)v9;
          munmap(v9, iov_base);
        }
      }
LABEL_30:
      abort(v9, iov_base, a3, a4, a5, a6);
    }
  }
  else if ( v41 )
  {
    goto LABEL_30;
  }
  return __readfsqword(0x28u) ^ v45;
}
// 40B6EC: variable 'v18' is possibly undefined
// 40B716: variable 'v26' is possibly undefined
// 40B782: variable 'a3' is possibly undefined
// 40B782: variable 'a4' is possibly undefined
// 40B782: variable 'a5' is possibly undefined
// 40B782: variable 'a6' is possibly undefined
// 401060: using guessed type __int64 __fastcall j_strchrnul(_QWORD, _QWORD);
// 4010B0: using guessed type __int64 __fastcall j_mempcpy(_QWORD, _QWORD, _QWORD);
// 4010C8: using guessed type __int64 __fastcall j_strlen_ifunc(_QWORD);
// 4A91F8: using guessed type __int64 dl_pagesize;
// 4AA8C0: using guessed type __int64 _abort_msg;

//----- (000000000040B820) ----------------------------------------------------
void __fastcall __noreturn _libc_fatal(__int64 a1, __int64 a2, __int64 a3, __int64 a4, u32 *a5, __int64 a6)
{
  char v6; // [rsp+0h] [rbp-18h]

  while ( 1 )
    _libc_message(3, (size_t)"%s", a1, a4, a5, a6, v6);
}
// 40B845: variable 'a4' is possibly undefined
// 40B845: variable 'a5' is possibly undefined
// 40B845: variable 'a6' is possibly undefined
// 40B845: variable 'v6' is possibly undefined

//----- (000000000040B850) ----------------------------------------------------
void __fastcall IO_vtable_check(__int64 a1, __int64 a2, __int64 a3, __int64 a4, u32 *a5, __int64 a6)
{
  if ( !_dlopen )
    _libc_fatal((__int64)"Fatal error: glibc detected an invalid stdio handle\n", a2, a3, a4, a5, a6);
}

//----- (000000000040B870) ----------------------------------------------------
__int64 __fastcall fgets_unlocked(__int64 a1, int a2, int *a3)
{
  char v4; // bp
  int v5; // ebp
  _BYTE *v6; // rax
  int v7; // edx
  __int64 result; // rax

  if ( a2 <= 0 )
    return 0LL;
  if ( a2 == 1 )
  {
    *(_BYTE *)a1 = 0;
    return a1;
  }
  v4 = *a3;
  *a3 &= ~0x20u;
  v5 = v4 & 0x20;
  v6 = IO_getline((__int64)a3, a1, a2 - 1, 0xAuLL, (u32 *)1);
  v7 = *a3;
  if ( v6 && ((v7 & 0x20) == 0 || __readfsdword(0xFFFFFFC0) == 11) )
  {
    v6[a1] = 0;
    result = a1;
    *a3 |= v5;
  }
  else
  {
    result = 0LL;
    *a3 = v7 | v5;
  }
  return result;
}

//----- (000000000040B920) ----------------------------------------------------
__int64 __fastcall IO_file_seekoff_maybe_mmap(__int64 a1, __int64 a2, __int64 a3, __int64 a4, u32 *a5, __int64 a6)
{
  __int64 v6; // rbp
  __int64 result; // rax

  v6 = *(_QWORD *)(a1 + 216);
  if ( (char *)&_start___libc_atexit - (char *)_start___libc_IO_vtables <= (unsigned __int64)(v6
                                                                                            - (_QWORD)_start___libc_IO_vtables) )
    IO_vtable_check(v6 - (_QWORD)_start___libc_IO_vtables, a2, a3, (__int64)_start___libc_IO_vtables, a5, a6);
  result = (*(__int64 (__fastcall **)(__int64))(v6 + 128))(a1);
  if ( result < 0 )
    return -1LL;
  *(_QWORD *)(a1 + 144) = result;
  return result;
}
// 4A9C40: using guessed type u32 _start___libc_IO_vtables[48];
// 4AA2E8: using guessed type __int64 (__fastcall *_start___libc_atexit)();

//----- (000000000040B990) ----------------------------------------------------
unsigned __int64 __fastcall IO_file_close(__int64 a1)
{
  return _close_nocancel(*(_DWORD *)(a1 + 112));
}

//----- (000000000040B9A0) ----------------------------------------------------
_QWORD *__fastcall IO_new_file_setbuf(_QWORD *a1, __int64 a2, __int64 a3, __int64 a4, u32 *a5, __int64 a6)
{
  _QWORD *result; // rax
  __int64 v7; // rax

  result = (_QWORD *)IO_default_setbuf((__int64)a1, a2, a3, a4, a5, a6);
  if ( result )
  {
    v7 = a1[7];
    a1[6] = v7;
    a1[5] = v7;
    a1[4] = v7;
    a1[3] = v7;
    a1[1] = v7;
    a1[2] = v7;
    return a1;
  }
  return result;
}

//----- (000000000040B9E0) ----------------------------------------------------
_QWORD *__fastcall IO_file_setbuf_mmap(_QWORD *a1, __int64 a2, __int64 a3, __int64 a4, u32 *a5, __int64 a6)
{
  _QWORD *result; // rax
  __int64 v7; // rax
  __int64 v8; // rdx

  a1[27] = &IO_file_jumps;
  *(_QWORD *)(a1[20] + 304LL) = &IO_wfile_jumps;
  result = (_QWORD *)IO_default_setbuf((__int64)a1, a2, a3, (__int64)&IO_wfile_jumps, a5, a6);
  if ( result )
  {
    v7 = a1[7];
    a1[6] = v7;
    a1[5] = v7;
    a1[4] = v7;
    a1[3] = v7;
    a1[1] = v7;
    a1[2] = v7;
    return a1;
  }
  else
  {
    v8 = a1[20];
    a1[27] = &IO_file_jumps_mmap;
    *(_QWORD *)(v8 + 304) = &IO_wfile_jumps_mmap;
  }
  return result;
}

//----- (000000000040BA70) ----------------------------------------------------
__int64 __fastcall new_do_write(__int64 a1, __int64 a2, __int64 a3, __int64 a4, u32 *a5, __int64 a6)
{
  __int64 v6; // r15
  unsigned __int64 v7; // r14
  __int64 v9; // r12
  unsigned __int64 v10; // rbp
  unsigned __int64 v11; // rax
  __int64 v12; // rax
  int v13; // edi
  __int64 v14; // r12
  __int64 v15; // rax
  int v16; // edx
  __int64 v18; // rax

  v6 = a3;
  v7 = a2;
  v9 = *(_QWORD *)(a1 + 216);
  v10 = (char *)&_start___libc_atexit - (char *)_start___libc_IO_vtables;
  v11 = v9 - (_QWORD)_start___libc_IO_vtables;
  if ( (*(_DWORD *)a1 & 0x1000) != 0 )
  {
    *(_QWORD *)(a1 + 144) = -1LL;
LABEL_3:
    if ( v10 <= v11 )
      IO_vtable_check(a1, a2, a3, a4, a5, a6);
    v12 = (*(__int64 (__fastcall **)(__int64, unsigned __int64, __int64, __int64, u32 *))(v9 + 120))(a1, v7, v6, a4, a5);
    v13 = *(unsigned __int16 *)(a1 + 128);
    v14 = v12;
    if ( (_WORD)v13 && v12 )
      *(_WORD *)(a1 + 128) = IO_adjust_column(v13 - 1, v7, v12) + 1;
    v15 = *(_QWORD *)(a1 + 56);
    v16 = *(_DWORD *)(a1 + 192);
    *(_QWORD *)(a1 + 24) = v15;
    *(_QWORD *)(a1 + 8) = v15;
    *(_QWORD *)(a1 + 16) = v15;
    *(_QWORD *)(a1 + 40) = v15;
    *(_QWORD *)(a1 + 32) = v15;
    if ( v16 > 0 || (*(_DWORD *)a1 & 0x202) == 0 )
      v15 = *(_QWORD *)(a1 + 64);
    *(_QWORD *)(a1 + 48) = v15;
    return v14;
  }
  a3 = *(_QWORD *)(a1 + 16);
  a2 = *(_QWORD *)(a1 + 32);
  if ( a3 == a2 )
    goto LABEL_3;
  if ( v10 <= v11 )
  {
    IO_vtable_check(a1, a2, a3, a4, a5, a6);
    a2 = *(_QWORD *)(a1 + 32);
    a3 = *(_QWORD *)(a1 + 16);
  }
  a2 -= a3;
  v18 = (*(__int64 (__fastcall **)(__int64, __int64, __int64, __int64, u32 *))(v9 + 128))(a1, a2, 1LL, a4, a5);
  v14 = 0LL;
  if ( v18 != -1 )
  {
    v9 = *(_QWORD *)(a1 + 216);
    *(_QWORD *)(a1 + 144) = v18;
    v11 = v9 - (_QWORD)_start___libc_IO_vtables;
    goto LABEL_3;
  }
  return v14;
}
// 40BBA0: variable 'a3' is possibly undefined
// 40BBA0: variable 'a4' is possibly undefined
// 40BBA0: variable 'a5' is possibly undefined
// 40BBA0: variable 'a6' is possibly undefined
// 4A9C40: using guessed type u32 _start___libc_IO_vtables[48];
// 4AA2E8: using guessed type __int64 (__fastcall *_start___libc_atexit)();

//----- (000000000040BBD0) ----------------------------------------------------
__int64 __fastcall IO_new_file_underflow(
        __int64 a1,
        __int64 _RSI,
        __int64 a3,
        __int64 a4,
        void *a5,
        unsigned __int64 _R9)
{
  int v6; // eax
  volatile signed __int32 *v7; // rdx
  __int64 v8; // rbx
  unsigned __int64 v9; // rbp
  __int64 v10; // rdx
  void *v11; // r13
  unsigned __int64 v12; // r10
  bool v13; // zf
  __int64 v14; // rdx
  __int64 v15; // rcx
  u32 *v16; // r8
  __int64 v17; // r9
  __int64 v18; // r13
  __int64 v19; // rsi
  __int64 v20; // rax
  __int64 v21; // rdx
  __int64 result; // rax
  int v23; // edx
  __int64 v24; // r14
  __int64 v25; // rdi

  v6 = *(_DWORD *)a1;
  if ( (*(_DWORD *)a1 & 0x10) != 0 )
    return 0xFFFFFFFFLL;
  if ( (v6 & 4) != 0 )
  {
    *(_DWORD *)a1 = v6 | 0x20;
    __writefsdword(0xFFFFFFC0, 9u);
    return 0xFFFFFFFFLL;
  }
  v7 = *(volatile signed __int32 **)(a1 + 8);
  if ( (unsigned __int64)v7 < *(_QWORD *)(a1 + 16) )
    return *(unsigned __int8 *)v7;
  v8 = a1;
  if ( !*(_QWORD *)(a1 + 56) )
  {
    v25 = *(_QWORD *)(a1 + 72);
    if ( v25 )
    {
      free(v25, _RSI, (__int64)v7, a4, (u32 *)a5, _R9);
      *(_DWORD *)v8 &= ~0x100u;
    }
    a1 = v8;
    IO_doallocbuf(v8, _RSI, (__int64)v7, a4, (u32 *)a5, _R9);
    v6 = *(_DWORD *)v8;
  }
  v9 = (char *)&_start___libc_atexit - (char *)_start___libc_IO_vtables;
  if ( (v6 & 0x202) != 0 )
  {
    a5 = stdout;
    v10 = *(unsigned int *)stdout;
    v11 = stdout;
    if ( (*(_DWORD *)stdout & 0x8000) == 0 )
    {
      _R9 = *((_QWORD *)stdout + 17);
      v12 = __readfsqword(0x10u);
      if ( *(_QWORD *)(_R9 + 8) == v12 )
        goto LABEL_14;
      _RSI = 1LL;
      v13 = _libc_multiple_threads == 0;
      if ( _libc_multiple_threads )
      {
        if ( !_InterlockedCompareExchange((volatile signed __int32 *)_R9, 1, 0) )
          goto LABEL_13;
      }
      else
      {
        __asm { cmpxchg [r9], esi }
        if ( v13 )
        {
LABEL_13:
          _R9 = *((_QWORD *)a5 + 17);
          a5 = stdout;
          *(_QWORD *)(_R9 + 8) = v12;
          LODWORD(v10) = *(_DWORD *)a5;
LABEL_14:
          v7 = (volatile signed __int32 *)(v10 & 0x288);
          ++*(_DWORD *)(_R9 + 4);
          if ( (_DWORD)v7 != 640 )
            goto LABEL_15;
          goto LABEL_28;
        }
      }
      a1 = _R9;
      _lll_lock_wait_private((u32 *)_R9, 1LL, v10, a4, (u32 *)a5, _R9);
      goto LABEL_13;
    }
    v7 = (volatile signed __int32 *)(v10 & 0x288);
    if ( (_DWORD)v7 == 640 )
    {
LABEL_28:
      v24 = *((_QWORD *)a5 + 27);
      if ( v24 - (__int64)_start___libc_IO_vtables >= v9 )
      {
        IO_vtable_check(a1, _RSI, (__int64)v7, a4, (u32 *)a5, _R9);
        a5 = stdout;
      }
      _RSI = 0xFFFFFFFFLL;
      (*(void (__fastcall **)(void *, __int64))(v24 + 24))(a5, 0xFFFFFFFFLL);
LABEL_15:
      if ( (*(_DWORD *)v11 & 0x8000) != 0 )
        goto LABEL_17;
      v7 = (volatile signed __int32 *)*((_QWORD *)v11 + 17);
      v13 = (*((_DWORD *)v7 + 1))-- == 1;
      if ( !v13 )
        goto LABEL_17;
      *((_QWORD *)v7 + 1) = 0LL;
      if ( _libc_multiple_threads )
      {
        if ( !_InterlockedDecrement(v7) )
          goto LABEL_17;
      }
      else
      {
        v13 = (*v7)-- == 1;
        if ( v13 )
          goto LABEL_17;
      }
      _lll_unlock_wake_private((u32 *)v7, _RSI, (__int64)v7, a4, (u32 *)a5, _R9);
    }
  }
LABEL_17:
  IO_switch_to_get_mode(v8, _RSI, (__int64)v7, a4, (u32 *)a5, _R9);
  v18 = *(_QWORD *)(v8 + 216);
  v19 = *(_QWORD *)(v8 + 56);
  *(_QWORD *)(v8 + 8) = v19;
  *(_QWORD *)(v8 + 24) = v19;
  *(_QWORD *)(v8 + 16) = v19;
  *(_QWORD *)(v8 + 48) = v19;
  *(_QWORD *)(v8 + 40) = v19;
  *(_QWORD *)(v8 + 32) = v19;
  if ( v18 - (__int64)_start___libc_IO_vtables >= v9 )
  {
    IO_vtable_check(v8, v19, v14, v15, v16, v17);
    v19 = *(_QWORD *)(v8 + 56);
  }
  v20 = (*(__int64 (__fastcall **)(__int64, __int64, __int64))(v18 + 112))(v8, v19, *(_QWORD *)(v8 + 64) - v19);
  if ( v20 <= 0 )
  {
    v23 = *(_DWORD *)v8 | 0x10;
    v13 = v20 == 0;
    result = -1LL;
    if ( !v13 )
      v23 = *(_DWORD *)v8 | 0x20;
    *(_QWORD *)(v8 + 144) = -1LL;
    *(_DWORD *)v8 = v23;
  }
  else
  {
    v21 = *(_QWORD *)(v8 + 144);
    *(_QWORD *)(v8 + 16) += v20;
    if ( v21 != -1 )
      *(_QWORD *)(v8 + 144) = v21 + v20;
    return **(unsigned __int8 **)(v8 + 8);
  }
  return result;
}
// 40BC7D: variable 'a4' is possibly undefined
// 40BC89: variable 'a5' is possibly undefined
// 40BC97: variable 'v12' is possibly undefined
// 40BCD3: variable 'v7' is possibly undefined
// 40BCD3: variable '_R9' is possibly undefined
// 40BE30: variable 'v14' is possibly undefined
// 40BE30: variable 'v15' is possibly undefined
// 40BE30: variable 'v16' is possibly undefined
// 40BE30: variable 'v17' is possibly undefined
// 4A87A0: using guessed type void *stdout;
// 4A9C40: using guessed type u32 _start___libc_IO_vtables[48];
// 4AA2E8: using guessed type __int64 (__fastcall *_start___libc_atexit)();
// 4AB820: using guessed type int _libc_multiple_threads;

//----- (000000000040BE90) ----------------------------------------------------
unsigned __int64 __fastcall IO_file_close_mmap(__int64 a1)
{
  unsigned int v2; // edi

  munmap(*(_QWORD *)(a1 + 56), *(_QWORD *)(a1 + 64) - *(_QWORD *)(a1 + 56));
  *(_QWORD *)(a1 + 64) = 0LL;
  v2 = *(_DWORD *)(a1 + 112);
  *(_QWORD *)(a1 + 56) = 0LL;
  return _close_nocancel(v2);
}

//----- (000000000040BED0) ----------------------------------------------------
__int64 __fastcall mmap_remap_check(__int64 a1, __int64 a2, __int64 a3, __int64 a4, u32 *a5, __int64 a6)
{
  __int64 v7; // rbp
  u32 *v8; // rdx
  __int64 v9; // rcx
  unsigned int v10; // eax
  unsigned __int64 v11; // r12
  unsigned int v12; // er13
  unsigned __int64 v13; // rbp
  int v14; // ecx
  void *v15; // rax
  off_t v17; // r14
  int v18; // eax
  unsigned __int64 v19; // r8
  __int64 v20; // rcx
  unsigned __int64 v21; // rdx
  unsigned __int64 v22; // rsi
  unsigned __int64 v23; // rdx
  __int64 v24; // rdi
  __int64 v25; // rax
  off_t v26; // rdi
  unsigned __int64 v27; // rax
  __int64 v28; // rdx
  unsigned __int64 v29; // rax
  _WORD v30[24]; // [rsp+0h] [rbp-C8h] BYREF
  off_t v31; // [rsp+30h] [rbp-98h]
  unsigned __int64 v32; // [rsp+98h] [rbp-30h]

  v7 = *(_QWORD *)(a1 + 216);
  v8 = _start___libc_IO_vtables;
  v32 = __readfsqword(0x28u);
  v9 = v7 - (_QWORD)_start___libc_IO_vtables;
  if ( (char *)&_start___libc_atexit - (char *)_start___libc_IO_vtables <= (unsigned __int64)(v7
                                                                                            - (_QWORD)_start___libc_IO_vtables) )
    IO_vtable_check(a1, a2, (__int64)_start___libc_IO_vtables, v9, a5, a6);
  v10 = (*(__int64 (__fastcall **)(__int64, _WORD *, u32 *, __int64, u32 *))(v7 + 144))(a1, v30, v8, v9, a5);
  v11 = *(_QWORD *)(a1 + 56);
  v12 = v10;
  v13 = *(_QWORD *)(a1 + 64) - v11;
  if ( !v10 && (v30[12] & 0xF000) == 0x8000 && (v17 = v31) != 0 )
  {
    v18 = getpagesize();
    v20 = -(__int64)v18;
    v21 = v20 & (v17 + v18 - 1);
    v22 = v20 & (v18 + v13 - 1);
    if ( v21 < v22 )
    {
      munmap(v11 + v21, v22 - v21);
      v11 = *(_QWORD *)(a1 + 56);
      v17 = v31;
      v23 = v11 + v31;
      *(_QWORD *)(a1 + 64) = v11 + v31;
LABEL_14:
      v24 = *(_QWORD *)(a1 + 144);
      v25 = *(_QWORD *)(a1 + 16);
      *(_QWORD *)(a1 + 24) = v11;
      v26 = v24 - (v25 - *(_QWORD *)(a1 + 8));
      *(_QWORD *)(a1 + 144) = v26;
      if ( v26 >= v17 )
      {
        *(_QWORD *)(a1 + 8) = v23;
        *(_QWORD *)(a1 + 16) = v23;
      }
      else
      {
        *(_QWORD *)(a1 + 16) = v23;
        *(_QWORD *)(a1 + 8) = v11 + v26;
        v27 = lseek64(*(_DWORD *)(a1 + 112), v17, 0);
        v28 = *(_QWORD *)(a1 + 64) - *(_QWORD *)(a1 + 56);
        if ( v28 == v27 )
          *(_QWORD *)(a1 + 144) = v28;
        else
          *(_DWORD *)a1 |= 0x20u;
      }
      return v12;
    }
    if ( v21 <= v22 )
    {
      v23 = v11 + v17;
      *(_QWORD *)(a1 + 64) = v11 + v17;
      goto LABEL_14;
    }
    v29 = mremap(v11, v22, v21, 1uLL, v19);
    v11 = v29;
    if ( v29 != -1LL )
    {
      v17 = v31;
      *(_QWORD *)(a1 + 56) = v29;
      v23 = v29 + v17;
      *(_QWORD *)(a1 + 64) = v29 + v17;
      goto LABEL_14;
    }
    munmap(*(_QWORD *)(a1 + 56), *(_QWORD *)(a1 + 64) - *(_QWORD *)(a1 + 56));
  }
  else
  {
    munmap(*(_QWORD *)(a1 + 56), *(_QWORD *)(a1 + 64) - v11);
  }
  v14 = *(_DWORD *)(a1 + 192);
  v15 = &IO_file_jumps;
  *(_QWORD *)(a1 + 64) = 0LL;
  *(_QWORD *)(a1 + 56) = 0LL;
  v12 = 1;
  *(_QWORD *)(a1 + 24) = 0LL;
  if ( v14 > 0 )
    v15 = &IO_wfile_jumps;
  *(_QWORD *)(a1 + 8) = 0LL;
  *(_QWORD *)(a1 + 16) = 0LL;
  *(_QWORD *)(a1 + 216) = v15;
  *(_QWORD *)(*(_QWORD *)(a1 + 160) + 304LL) = &IO_wfile_jumps;
  return v12;
}
// 40BF22: variable 'v8' is possibly undefined
// 40BF22: variable 'v9' is possibly undefined
// 40BF22: variable 'a5' is possibly undefined
// 40C082: variable 'v19' is possibly undefined
// 4A9C40: using guessed type u32 _start___libc_IO_vtables[48];
// 4AA2E8: using guessed type __int64 (__fastcall *_start___libc_atexit)();

//----- (000000000040C130) ----------------------------------------------------
unsigned __int64 __fastcall IO_file_seek(__int64 a1, off_t a2, unsigned int a3)
{
  return lseek64(*(_DWORD *)(a1 + 112), a2, a3);
}

//----- (000000000040C140) ----------------------------------------------------
__int64 __fastcall IO_file_sync_mmap(__int64 a1)
{
  unsigned __int64 v1; // rax
  __int64 v2; // rax

  v1 = *(_QWORD *)(a1 + 8) - *(_QWORD *)(a1 + 56);
  if ( *(_QWORD *)(a1 + 8) == *(_QWORD *)(a1 + 16)
    || (v1 = lseek64(*(_DWORD *)(a1 + 112), v1, 0), *(_QWORD *)(a1 + 8) - *(_QWORD *)(a1 + 56) == v1) )
  {
    *(_QWORD *)(a1 + 144) = v1;
    v2 = *(_QWORD *)(a1 + 24);
    *(_QWORD *)(a1 + 8) = v2;
    *(_QWORD *)(a1 + 16) = v2;
    return 0LL;
  }
  else
  {
    *(_DWORD *)a1 |= 0x20u;
    return 0xFFFFFFFFLL;
  }
}

//----- (000000000040C1A0) ----------------------------------------------------
unsigned __int64 __fastcall decide_maybe_mmap(__int64 a1, __int64 a2, __int64 a3, __int64 a4, u32 *a5, __int64 a6)
{
  __int64 v6; // rbp
  u32 *v7; // rdx
  __int64 v8; // rcx
  void *v9; // rax
  void *v10; // rdx
  signed __int64 v12; // rax
  unsigned __int64 v13; // rbp
  unsigned __int64 v14; // rax
  u32 *v15; // r8
  unsigned __int64 v16; // r9
  __int64 v17; // rdx
  unsigned __int64 v18; // rax
  bool v19; // zf
  unsigned __int64 v20; // rbp
  _WORD v21[24]; // [rsp+0h] [rbp-B8h] BYREF
  unsigned __int64 len; // [rsp+30h] [rbp-88h]
  unsigned __int64 v23; // [rsp+98h] [rbp-20h]

  v6 = *(_QWORD *)(a1 + 216);
  v7 = _start___libc_IO_vtables;
  v23 = __readfsqword(0x28u);
  v8 = v6 - (_QWORD)_start___libc_IO_vtables;
  if ( (char *)&_start___libc_atexit - (char *)_start___libc_IO_vtables <= (unsigned __int64)(v6
                                                                                            - (_QWORD)_start___libc_IO_vtables) )
    IO_vtable_check(a1, a2, (__int64)_start___libc_IO_vtables, v8, a5, a6);
  if ( (*(unsigned int (__fastcall **)(__int64, _WORD *, u32 *, __int64, u32 *))(v6 + 144))(a1, v21, v7, v8, a5) )
    goto LABEL_5;
  if ( (v21[12] & 0xF000) != 0x8000 )
    goto LABEL_5;
  if ( !len )
    goto LABEL_5;
  v12 = *(_QWORD *)(a1 + 144);
  if ( v12 != -1 && (__int64)len < v12 )
    goto LABEL_5;
  v13 = mmap64(0LL, len, 1uLL, 1uLL, *(unsigned int *)(a1 + 112), 0LL);
  if ( v13 == -1LL )
    goto LABEL_5;
  v14 = lseek64(*(_DWORD *)(a1 + 112), len, 0);
  if ( len != v14 )
  {
    munmap(v13, len);
    *(_QWORD *)(a1 + 144) = -1LL;
LABEL_5:
    v9 = &IO_file_jumps;
    v10 = &IO_wfile_jumps;
    goto LABEL_6;
  }
  IO_setb((int *)a1, v13, v13 + len, 0LL, v15, v16);
  v17 = *(_QWORD *)(a1 + 144);
  *(_QWORD *)(a1 + 24) = v13;
  v18 = v13 + v17;
  v19 = v17 == -1;
  v10 = &IO_wfile_jumps_mmap;
  if ( v19 )
    v18 = v13;
  *(_QWORD *)(a1 + 8) = v18;
  v20 = len + v13;
  *(_QWORD *)(a1 + 144) = len;
  v9 = &IO_file_jumps_mmap;
  *(_QWORD *)(a1 + 16) = v20;
LABEL_6:
  if ( *(int *)(a1 + 192) > 0 )
    v9 = v10;
  *(_QWORD *)(a1 + 216) = v9;
  *(_QWORD *)(*(_QWORD *)(a1 + 160) + 304LL) = v10;
  return __readfsqword(0x28u) ^ v23;
}
// 40C1EC: variable 'v7' is possibly undefined
// 40C1EC: variable 'v8' is possibly undefined
// 40C1EC: variable 'a5' is possibly undefined
// 40C2EF: variable 'v15' is possibly undefined
// 40C2EF: variable 'v16' is possibly undefined
// 4A9C40: using guessed type u32 _start___libc_IO_vtables[48];
// 4AA2E8: using guessed type __int64 (__fastcall *_start___libc_atexit)();

//----- (000000000040C340) ----------------------------------------------------
__int64 __fastcall IO_file_underflow_maybe_mmap(__int64 a1, __int64 a2, __int64 a3, __int64 a4, u32 *a5, __int64 a6)
{
  u32 *v6; // r8
  __int64 v7; // r9
  __int64 v8; // rbp

  decide_maybe_mmap(a1, a2, a3, a4, a5, a6);
  v8 = *(_QWORD *)(a1 + 216);
  if ( (char *)&_start___libc_atexit - (char *)_start___libc_IO_vtables <= (unsigned __int64)(v8
                                                                                            - (_QWORD)_start___libc_IO_vtables) )
    IO_vtable_check(a1, a2, (__int64)_start___libc_IO_vtables, v8 - (_QWORD)_start___libc_IO_vtables, v6, v7);
  return (*(__int64 (__fastcall **)(__int64))(v8 + 32))(a1);
}
// 40C388: variable 'v6' is possibly undefined
// 40C388: variable 'v7' is possibly undefined
// 4A9C40: using guessed type u32 _start___libc_IO_vtables[48];
// 4AA2E8: using guessed type __int64 (__fastcall *_start___libc_atexit)();

//----- (000000000040C390) ----------------------------------------------------
__int64 __fastcall IO_file_xsgetn_maybe_mmap(__int64 a1, __int64 a2, __int64 a3, __int64 a4, u32 *a5, __int64 a6)
{
  u32 *v7; // r8
  __int64 v8; // r9
  __int64 v9; // rbp

  decide_maybe_mmap(a1, a2, a3, a4, a5, a6);
  v9 = *(_QWORD *)(a1 + 216);
  if ( (char *)&_start___libc_atexit - (char *)_start___libc_IO_vtables <= (unsigned __int64)(v9
                                                                                            - (_QWORD)_start___libc_IO_vtables) )
    IO_vtable_check(a1, a2, v9 - (_QWORD)_start___libc_IO_vtables, (__int64)_start___libc_IO_vtables, v7, v8);
  return (*(__int64 (__fastcall **)(__int64, __int64, __int64))(v9 + 64))(a1, a2, a3);
}
// 40C3F0: variable 'v7' is possibly undefined
// 40C3F0: variable 'v8' is possibly undefined
// 4A9C40: using guessed type u32 _start___libc_IO_vtables[48];
// 4AA2E8: using guessed type __int64 (__fastcall *_start___libc_atexit)();

//----- (000000000040C400) ----------------------------------------------------
__int64 __fastcall IO_new_file_seekoff(__int64 a1, char *a2, unsigned int a3, u32 *a4, u32 *a5, unsigned __int64 a6)
{
  unsigned __int64 v8; // rax
  unsigned __int64 v9; // rdx
  __int64 v10; // rbp
  __int64 v11; // rdi
  int v12; // er15
  __int64 v13; // rax
  unsigned __int64 v14; // r12
  __int64 v15; // rdi
  __int64 v16; // rax
  __int64 v17; // rax
  int v18; // eax
  char *v19; // rcx
  __int64 v20; // rax
  __int64 v21; // rsi
  char *v22; // r13
  __int64 v23; // rax
  u32 *v24; // r8
  __int64 v25; // r9
  __int64 v26; // rax
  __int64 (__fastcall *v27)(__int64, char *, char *); // rax
  char *v28; // rdx
  __int64 v29; // rax
  __int64 v30; // rdx
  __int64 result; // rax
  __int64 v32; // rdx
  __int64 v33; // rcx
  u32 *v34; // r8
  __int64 v35; // r9
  __int64 v36; // r15
  __int64 v37; // rdx
  unsigned __int64 v38; // rbp
  int v39; // edx
  __int64 v40; // rbp
  __int64 v41; // rcx
  __int64 v42; // rax
  unsigned __int64 v43; // rbp
  __int64 v44; // r12
  __int64 v45; // r12
  u32 *v46; // [rsp+0h] [rbp-E8h]
  __int64 v47; // [rsp+0h] [rbp-E8h]
  __int64 v48; // [rsp+0h] [rbp-E8h]
  __int64 v49; // [rsp+0h] [rbp-E8h]
  u32 *v50; // [rsp+8h] [rbp-E0h]
  char v51[24]; // [rsp+10h] [rbp-D8h] BYREF
  int v52; // [rsp+28h] [rbp-C0h]
  __int64 v53; // [rsp+40h] [rbp-A8h]
  unsigned __int64 v54; // [rsp+A8h] [rbp-40h]

  v54 = __readfsqword(0x28u);
  if ( !(_DWORD)a4 )
  {
    if ( *(_QWORD *)(a1 + 56) )
    {
      v38 = *(_QWORD *)(a1 + 40);
      a4 = *(u32 **)(a1 + 32);
      v39 = *(_DWORD *)a1 & 0x1000;
      if ( v38 > (unsigned __int64)a4 && v39 )
      {
        v40 = *(_QWORD *)(a1 + 216);
        v41 = v40 - (_QWORD)_start___libc_IO_vtables;
        if ( (char *)&_start___libc_atexit - (char *)_start___libc_IO_vtables <= (unsigned __int64)(v40
                                                                                                  - (_QWORD)_start___libc_IO_vtables) )
          IO_vtable_check(a1, (__int64)a2, (__int64)_start___libc_IO_vtables, v41, a5, a6);
        a2 = 0LL;
        v42 = (*(__int64 (__fastcall **)(__int64, _QWORD, __int64, __int64, u32 *))(v40 + 128))(a1, 0LL, 2LL, v41, a5);
        if ( v42 == -1 )
          return -1LL;
        *(_QWORD *)(a1 + 144) = v42;
        v38 = *(_QWORD *)(a1 + 40);
        goto LABEL_57;
      }
      v42 = *(_QWORD *)(a1 + 144);
      if ( v38 > (unsigned __int64)a4 )
      {
        if ( v39 )
        {
LABEL_57:
          v43 = v38 - *(_QWORD *)(a1 + 32);
          goto LABEL_60;
        }
        v43 = v38 - *(_QWORD *)(a1 + 16);
      }
      else
      {
        v43 = *(_QWORD *)(a1 + 8) - *(_QWORD *)(a1 + 16);
      }
    }
    else
    {
      v42 = *(_QWORD *)(a1 + 144);
      v43 = 0LL;
    }
LABEL_60:
    if ( v42 == -1 )
    {
      v44 = *(_QWORD *)(a1 + 216);
      if ( (char *)&_start___libc_atexit - (char *)_start___libc_IO_vtables <= (unsigned __int64)(v44
                                                                                                - (_QWORD)_start___libc_IO_vtables) )
        IO_vtable_check(
          v44 - (_QWORD)_start___libc_IO_vtables,
          (__int64)a2,
          (__int64)_start___libc_IO_vtables,
          (__int64)a4,
          a5,
          a6);
      v42 = (*(__int64 (__fastcall **)(__int64, _QWORD, __int64))(v44 + 128))(a1, 0LL, 1LL);
      if ( v42 == -1 )
        return -1LL;
    }
    result = v43 + v42;
    if ( result >= 0 )
      return result;
    goto LABEL_62;
  }
  v8 = *(_QWORD *)(a1 + 32);
  v9 = *(_QWORD *)(a1 + 40);
  v10 = (__int64)a2;
  v11 = *(_QWORD *)(a1 + 16);
  if ( *(_QWORD *)(a1 + 24) == v11 && v9 == v8 )
  {
    v12 = 1;
  }
  else
  {
    v12 = 0;
    if ( v9 > v8 )
      goto LABEL_4;
  }
  if ( (*(_DWORD *)a1 & 0x800) == 0 )
  {
    if ( !*(_QWORD *)(a1 + 56) )
      goto LABEL_17;
LABEL_6:
    if ( a3 == 1 )
      goto LABEL_20;
    goto LABEL_7;
  }
LABEL_4:
  v11 = a1;
  if ( (unsigned int)IO_switch_to_get_mode(a1, (__int64)a2, v9, (__int64)a4, a5, a6) )
    return -1LL;
  if ( *(_QWORD *)(a1 + 56) )
    goto LABEL_6;
LABEL_17:
  v15 = *(_QWORD *)(a1 + 24);
  if ( v15 )
  {
    free(v15, (__int64)a2, v9, (__int64)a4, a5, a6);
    *(_DWORD *)a1 &= ~0x100u;
  }
  v11 = a1;
  IO_doallocbuf(a1, (__int64)a2, v9, (__int64)a4, a5, a6);
  v16 = *(_QWORD *)(a1 + 56);
  *(_QWORD *)(a1 + 40) = v16;
  *(_QWORD *)(a1 + 32) = v16;
  *(_QWORD *)(a1 + 48) = v16;
  *(_QWORD *)(a1 + 24) = v16;
  *(_QWORD *)(a1 + 8) = v16;
  *(_QWORD *)(a1 + 16) = v16;
  if ( a3 == 1 )
  {
LABEL_20:
    v10 = (__int64)&a2[-(*(_QWORD *)(a1 + 16) - *(_QWORD *)(a1 + 8))];
    v17 = *(_QWORD *)(a1 + 144);
    if ( v17 == -1 )
    {
      v14 = (char *)&_start___libc_atexit - (char *)_start___libc_IO_vtables;
      goto LABEL_45;
    }
    v10 += v17;
    if ( v10 >= 0 )
      goto LABEL_22;
LABEL_62:
    __writefsdword(0xFFFFFFC0, 0x16u);
    return -1LL;
  }
LABEL_7:
  if ( a3 == 2 )
  {
    v13 = *(_QWORD *)(a1 + 216);
    v14 = (char *)&_start___libc_atexit - (char *)_start___libc_IO_vtables;
    if ( (char *)&_start___libc_atexit - (char *)_start___libc_IO_vtables <= (unsigned __int64)(v13
                                                                                              - (_QWORD)_start___libc_IO_vtables) )
    {
      v48 = *(_QWORD *)(a1 + 216);
      IO_vtable_check(v11, (__int64)a2, v13 - (_QWORD)_start___libc_IO_vtables, (__int64)a4, a5, a6);
      v13 = v48;
    }
    a2 = v51;
    if ( (*(unsigned int (__fastcall **)(__int64, char *))(v13 + 144))(a1, v51) || (v52 & 0xF000) != 0x8000 )
      goto LABEL_45;
    v10 += v53;
LABEL_22:
    a3 = 0;
  }
  IO_free_backup_area((int *)a1, (__int64)a2, v9, (__int64)a4, a5, a6);
  a2 = *(char **)(a1 + 144);
  v18 = *(_DWORD *)a1;
  if ( a2 == (char *)-1LL
    || !*(_QWORD *)(a1 + 24)
    || (v18 & 0x100) != 0
    || (v9 = *(_QWORD *)(a1 + 56), v19 = &a2[v9 - *(_QWORD *)(a1 + 16)], v10 < (__int64)v19)
    || (__int64)a2 <= v10 )
  {
    a4 = _start___libc_IO_vtables;
    v14 = (char *)&_start___libc_atexit - (char *)_start___libc_IO_vtables;
    if ( (v18 & 4) == 0 )
    {
      v20 = *(_QWORD *)(a1 + 64);
      v21 = v10 & (*(_QWORD *)(a1 + 56) - v20);
      v22 = (char *)(v10 - v21);
      if ( v20 - *(_QWORD *)(a1 + 56) < v10 - v21 )
      {
        v21 = v10;
        v22 = 0LL;
      }
      v23 = *(_QWORD *)(a1 + 216);
      if ( v23 - (__int64)_start___libc_IO_vtables >= v14 )
      {
        v47 = *(_QWORD *)(a1 + 216);
        IO_vtable_check(a1, v21, v23 - (_QWORD)_start___libc_IO_vtables, (__int64)_start___libc_IO_vtables, a5, a6);
        v23 = v47;
      }
      v24 = (u32 *)(*(__int64 (__fastcall **)(__int64, __int64, _QWORD))(v23 + 128))(a1, v21, 0LL);
      if ( (__int64)v24 >= 0 )
      {
        if ( !v22 )
        {
          v29 = 0LL;
          goto LABEL_41;
        }
        v26 = *(_QWORD *)(a1 + 216);
        if ( v26 - (__int64)_start___libc_IO_vtables >= v14 )
        {
          v50 = v24;
          v49 = *(_QWORD *)(a1 + 216);
          IO_vtable_check(a1, v21, v26 - (_QWORD)_start___libc_IO_vtables, (__int64)_start___libc_IO_vtables, v24, v25);
          v24 = v50;
          v26 = v49;
        }
        v27 = *(__int64 (__fastcall **)(__int64, char *, char *))(v26 + 112);
        a2 = *(char **)(a1 + 56);
        v28 = v22;
        if ( !v12 )
          v28 = (char *)(*(_QWORD *)(a1 + 64) - (_QWORD)a2);
        v46 = v24;
        v29 = v27(a1, a2, v28);
        if ( (__int64)v22 <= v29 )
        {
          v24 = (u32 *)((char *)v46 + v29);
LABEL_41:
          v30 = *(_QWORD *)(a1 + 56);
          *(_DWORD *)a1 &= ~0x10u;
          *(_QWORD *)(a1 + 144) = v24;
          *(_QWORD *)(a1 + 24) = v30;
          *(_QWORD *)(a1 + 8) = &v22[v30];
          *(_QWORD *)(a1 + 16) = v30 + v29;
          *(_QWORD *)(a1 + 40) = v30;
          *(_QWORD *)(a1 + 32) = v30;
          *(_QWORD *)(a1 + 48) = v30;
          return v10;
        }
        v10 = (__int64)v22;
        a3 = 1;
        if ( v29 != -1 )
        {
          v10 -= v29;
          a3 = 1;
        }
        goto LABEL_45;
      }
      return -1LL;
    }
LABEL_45:
    IO_unsave_markers((int *)a1, (__int64)a2, v9, (__int64)a4, a5, a6);
    v36 = *(_QWORD *)(a1 + 216);
    if ( v36 - (__int64)_start___libc_IO_vtables >= v14 )
      IO_vtable_check(a1, (__int64)a2, v32, v33, v34, v35);
    result = (*(__int64 (__fastcall **)(__int64, __int64, _QWORD))(v36 + 128))(a1, v10, a3);
    if ( result != -1 )
    {
      v37 = *(_QWORD *)(a1 + 56);
      *(_DWORD *)a1 &= ~0x10u;
      *(_QWORD *)(a1 + 144) = result;
      *(_QWORD *)(a1 + 24) = v37;
      *(_QWORD *)(a1 + 8) = v37;
      *(_QWORD *)(a1 + 16) = v37;
      *(_QWORD *)(a1 + 40) = v37;
      *(_QWORD *)(a1 + 32) = v37;
      *(_QWORD *)(a1 + 48) = v37;
    }
    return result;
  }
  *(_QWORD *)(a1 + 24) = v9;
  *(_QWORD *)(a1 + 40) = v9;
  *(_QWORD *)(a1 + 32) = v9;
  *(_QWORD *)(a1 + 48) = v9;
  *(_QWORD *)(a1 + 8) = v9 + v10 - (_QWORD)v19;
  *(_DWORD *)a1 = v18 & 0xFFFFFFEF;
  if ( (__int64)a2 < 0 )
    return v10;
  v45 = *(_QWORD *)(a1 + 216);
  if ( (char *)&_start___libc_atexit - (char *)_start___libc_IO_vtables <= (unsigned __int64)(v45
                                                                                            - (_QWORD)_start___libc_IO_vtables) )
  {
    IO_vtable_check(
      v10 - (_QWORD)v19,
      (__int64)a2,
      (__int64)_start___libc_IO_vtables,
      v45 - (_QWORD)_start___libc_IO_vtables,
      a5,
      a6);
    a2 = *(char **)(a1 + 144);
  }
  (*(void (__fastcall **)(__int64, char *, _QWORD))(v45 + 128))(a1, a2, 0LL);
  return v10;
}
// 40C96C: variable 'a4' is possibly undefined
// 40C96C: variable 'a5' is possibly undefined
// 40C96C: variable 'a6' is possibly undefined
// 40C520: variable 'v9' is possibly undefined
// 40C989: variable 'v25' is possibly undefined
// 40C920: variable 'v32' is possibly undefined
// 40C920: variable 'v33' is possibly undefined
// 40C920: variable 'v34' is possibly undefined
// 40C920: variable 'v35' is possibly undefined
// 40C7B5: variable 'v41' is possibly undefined
// 4A9C40: using guessed type u32 _start___libc_IO_vtables[48];
// 4AA2E8: using guessed type __int64 (__fastcall *_start___libc_atexit)();

//----- (000000000040C9D0) ----------------------------------------------------
unsigned __int64 __fastcall IO_file_stat(__int64 a1, struct stat *a2)
{
  return fxstat(1u, *(_DWORD *)(a1 + 112), a2);
}

//----- (000000000040C9F0) ----------------------------------------------------
__int64 __fastcall IO_new_file_write(__int64 a1, const char *a2, __int64 a3)
{
  signed __int64 v6; // rbx
  signed __int64 v7; // rax
  unsigned int v8; // edi
  __int64 result; // rax
  __int64 v10; // rdx

  if ( a3 <= 0 )
  {
    result = 0LL;
  }
  else
  {
    v6 = a3;
    do
    {
      v8 = *(_DWORD *)(a1 + 112);
      if ( (*(_BYTE *)(a1 + 116) & 2) != 0 )
      {
        v7 = _write_nocancel(v8, a2, v6);
        if ( v7 < 0 )
        {
LABEL_7:
          *(_DWORD *)a1 |= 0x20u;
          result = a3 - v6;
          goto LABEL_8;
        }
      }
      else
      {
        v7 = write(v8, a2, v6);
        if ( v7 < 0 )
          goto LABEL_7;
      }
      v6 -= v7;
      a2 += v7;
    }
    while ( v6 > 0 );
    result = a3 - v6;
  }
LABEL_8:
  v10 = *(_QWORD *)(a1 + 144);
  if ( v10 >= 0 )
    *(_QWORD *)(a1 + 144) = result + v10;
  return result;
}

//----- (000000000040CA90) ----------------------------------------------------
__int64 __fastcall IO_file_xsgetn_mmap(__int64 a1, __int64 a2, unsigned __int64 a3, __int64 a4, u32 *a5, __int64 a6)
{
  __int64 v6; // r15
  unsigned __int64 v7; // r14
  __int64 v8; // r13
  __int64 v9; // r12
  unsigned __int64 v10; // rbx
  u32 *v11; // r8
  __int64 v12; // r9
  __int64 v14; // rax
  __int64 v15; // rbx
  __int64 v16; // r13

  v6 = a2;
  v7 = a3;
  v8 = a2;
  v9 = *(_QWORD *)(a1 + 8);
  v10 = *(_QWORD *)(a1 + 16) - v9;
  if ( v10 >= a3 )
  {
LABEL_6:
    if ( !v10 )
      return v8 - v6;
LABEL_9:
    if ( v10 > v7 )
      v10 = v7;
    v14 = j_mempcpy(v8, v9, v10);
    *(_QWORD *)(a1 + 8) = v9 + v10;
    v8 = v14;
    return v8 - v6;
  }
  if ( (*(_DWORD *)a1 & 0x100) != 0 )
  {
    a2 = *(_QWORD *)(a1 + 8);
    v7 = a3 - v10;
    v8 = j_mempcpy(v6, a2, *(_QWORD *)(a1 + 16) - v9);
    IO_switch_to_main_get_area(a1);
    v9 = *(_QWORD *)(a1 + 8);
    v10 = *(_QWORD *)(a1 + 16) - v9;
    if ( v7 <= v10 )
      goto LABEL_9;
  }
  if ( !(unsigned int)mmap_remap_check(a1, a2, a3, a4, a5, a6) )
  {
    v9 = *(_QWORD *)(a1 + 8);
    v10 = *(_QWORD *)(a1 + 16) - v9;
    if ( v10 >= v7 )
      goto LABEL_9;
    *(_DWORD *)a1 |= 0x10u;
    goto LABEL_6;
  }
  v15 = *(_QWORD *)(a1 + 216);
  v16 = v8 - v6;
  if ( (char *)&_start___libc_atexit - (char *)_start___libc_IO_vtables <= (unsigned __int64)(v15
                                                                                            - (_QWORD)_start___libc_IO_vtables) )
    IO_vtable_check(a1, a2, (__int64)_start___libc_IO_vtables, v15 - (_QWORD)_start___libc_IO_vtables, v11, v12);
  return v16 + (*(__int64 (__fastcall **)(__int64, __int64, unsigned __int64))(v15 + 64))(a1, v6, v7);
}
// 40CAC9: variable 'a3' is possibly undefined
// 40CAC9: variable 'a4' is possibly undefined
// 40CAC9: variable 'a5' is possibly undefined
// 40CAC9: variable 'a6' is possibly undefined
// 40CB8A: variable 'v11' is possibly undefined
// 40CB8A: variable 'v12' is possibly undefined
// 4010B0: using guessed type __int64 __fastcall j_mempcpy(_QWORD, _QWORD, _QWORD);
// 4A9C40: using guessed type u32 _start___libc_IO_vtables[48];
// 4AA2E8: using guessed type __int64 (__fastcall *_start___libc_atexit)();

//----- (000000000040CBA0) ----------------------------------------------------
unsigned __int64 __fastcall IO_file_xsgetn(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        u32 *a5,
        unsigned __int64 a6)
{
  __int64 v6; // r14
  unsigned __int64 v7; // r13
  __int64 v9; // rsi
  unsigned __int64 v10; // r12
  unsigned __int64 v11; // rbp
  __int64 v12; // rdx
  unsigned __int64 v13; // rcx
  __int64 v14; // rdx
  __int64 v15; // rbp
  __int64 v16; // rax
  __int64 v17; // rdx
  __int64 v18; // rax
  unsigned __int64 result; // rax
  int v20; // edx
  bool v21; // zf
  __int64 v22; // rdi
  __int64 v23; // [rsp+8h] [rbp-30h]

  v6 = a2;
  v7 = a3;
  if ( !*(_QWORD *)(a1 + 56) )
  {
    v22 = *(_QWORD *)(a1 + 72);
    if ( v22 )
    {
      free(v22, a2, a3, a4, a5, a6);
      *(_DWORD *)a1 &= ~0x100u;
    }
    IO_doallocbuf(a1, a2, a3, a4, a5, a6);
  }
  if ( !v7 )
    return v7;
  v9 = *(_QWORD *)(a1 + 8);
  v10 = v7;
  v11 = *(_QWORD *)(a1 + 16) - v9;
  if ( v7 <= v11 )
  {
LABEL_31:
    j_memcpy(v6, v9, v10);
    *(_QWORD *)(a1 + 8) += v10;
    return v7;
  }
  while ( 1 )
  {
    if ( v11 )
    {
      v10 -= v11;
      v18 = j_mempcpy(v6, v9, v11);
      *(_QWORD *)(a1 + 8) += v11;
      v6 = v18;
      if ( (*(_DWORD *)a1 & 0x100) != 0 )
      {
LABEL_18:
        IO_switch_to_main_get_area(a1);
        goto LABEL_14;
      }
    }
    else if ( (*(_DWORD *)a1 & 0x100) != 0 )
    {
      goto LABEL_18;
    }
    v12 = *(_QWORD *)(a1 + 56);
    if ( !v12 )
    {
      *(_QWORD *)(a1 + 24) = 0LL;
      *(_QWORD *)(a1 + 8) = 0LL;
      *(_QWORD *)(a1 + 16) = 0LL;
      *(_QWORD *)(a1 + 40) = 0LL;
      *(_QWORD *)(a1 + 32) = 0LL;
      *(_QWORD *)(a1 + 48) = 0LL;
      goto LABEL_20;
    }
    v13 = *(_QWORD *)(a1 + 64) - v12;
    if ( v13 <= v10 )
      break;
    if ( (unsigned int)_underflow(a1, v9, v12, v13, a5, a6) == -1 )
    {
      v7 -= v10;
      return v7;
    }
LABEL_14:
    if ( !v10 )
      return v7;
    v9 = *(_QWORD *)(a1 + 8);
    v11 = *(_QWORD *)(a1 + 16) - v9;
    if ( v10 <= v11 )
      goto LABEL_31;
  }
  *(_QWORD *)(a1 + 24) = v12;
  *(_QWORD *)(a1 + 8) = v12;
  *(_QWORD *)(a1 + 16) = v12;
  *(_QWORD *)(a1 + 40) = v12;
  *(_QWORD *)(a1 + 32) = v12;
  *(_QWORD *)(a1 + 48) = v12;
  if ( v13 > 0x7F )
  {
    v14 = v10 - v10 % v13;
    goto LABEL_10;
  }
LABEL_20:
  v14 = v10;
LABEL_10:
  v15 = *(_QWORD *)(a1 + 216);
  if ( (char *)&_start___libc_atexit - (char *)_start___libc_IO_vtables > (unsigned __int64)(v15
                                                                                           - (_QWORD)_start___libc_IO_vtables) )
  {
    v16 = (*(__int64 (__fastcall **)(__int64, __int64, __int64))(v15 + 112))(a1, v6, v14);
    if ( v16 <= 0 )
      goto LABEL_25;
    goto LABEL_12;
  }
  v23 = v14;
  IO_vtable_check(v15 - (_QWORD)_start___libc_IO_vtables, v9, v14, (__int64)_start___libc_IO_vtables, a5, a6);
  v16 = (*(__int64 (__fastcall **)(__int64, __int64, __int64))(v15 + 112))(a1, v6, v23);
  if ( v16 > 0 )
  {
LABEL_12:
    v17 = *(_QWORD *)(a1 + 144);
    v6 += v16;
    v10 -= v16;
    if ( v17 != -1 )
      *(_QWORD *)(a1 + 144) = v17 + v16;
    goto LABEL_14;
  }
LABEL_25:
  v20 = *(_DWORD *)a1 | 0x10;
  v21 = v16 == 0;
  result = v7 - v10;
  if ( !v21 )
    v20 = *(_DWORD *)a1 | 0x20;
  *(_DWORD *)a1 = v20;
  return result;
}
// 40CD33: variable 'a5' is possibly undefined
// 40CD33: variable 'a6' is possibly undefined
// 40CDB7: variable 'a3' is possibly undefined
// 40CDB7: variable 'a4' is possibly undefined
// 401040: using guessed type __int64 __fastcall j_memcpy(_QWORD, _QWORD, _QWORD);
// 4010B0: using guessed type __int64 __fastcall j_mempcpy(_QWORD, _QWORD, _QWORD);
// 4A9C40: using guessed type u32 _start___libc_IO_vtables[48];
// 4AA2E8: using guessed type __int64 (__fastcall *_start___libc_atexit)();

//----- (000000000040CDF0) ----------------------------------------------------
__int64 __fastcall IO_file_seekoff_mmap(__int64 a1, __int64 a2, int a3, __int64 a4, u32 *a5, __int64 a6)
{
  __int64 v6; // rbp
  __int64 v7; // r12
  __int64 v8; // rax
  __int64 v9; // rcx
  __int64 v10; // rdx
  __int64 v11; // rdx

  if ( !(_DWORD)a4 )
    return *(_QWORD *)(a1 + 144) - (*(_QWORD *)(a1 + 16) - *(_QWORD *)(a1 + 8));
  v6 = a2;
  if ( a3 == 1 )
  {
    v6 = *(_QWORD *)(a1 + 8) - *(_QWORD *)(a1 + 24) + a2;
  }
  else if ( a3 == 2 )
  {
    v6 = *(_QWORD *)(a1 + 64) - *(_QWORD *)(a1 + 56) + a2;
  }
  if ( v6 < 0 )
  {
    __writefsdword(0xFFFFFFC0, 0x16u);
    return -1LL;
  }
  else
  {
    v7 = *(_QWORD *)(a1 + 216);
    if ( (char *)&_start___libc_atexit - (char *)_start___libc_IO_vtables <= (unsigned __int64)(v7
                                                                                              - (_QWORD)_start___libc_IO_vtables) )
      IO_vtable_check(v7 - (_QWORD)_start___libc_IO_vtables, a2, (__int64)_start___libc_IO_vtables, a4, a5, a6);
    v8 = (*(__int64 (__fastcall **)(__int64, __int64, _QWORD, __int64, u32 *))(v7 + 128))(a1, v6, 0LL, a4, a5);
    if ( v8 < 0 )
    {
      return -1LL;
    }
    else
    {
      v9 = *(_QWORD *)(a1 + 64);
      v10 = *(_QWORD *)(a1 + 56);
      *(_QWORD *)(a1 + 24) = v10;
      if ( v6 > v9 - v10 )
      {
        *(_QWORD *)(a1 + 8) = v9;
        *(_QWORD *)(a1 + 16) = v9;
      }
      else
      {
        v11 = v6 + v10;
        *(_QWORD *)(a1 + 8) = v11;
        *(_QWORD *)(a1 + 16) = v11;
      }
      *(_DWORD *)a1 &= ~0x10u;
      *(_QWORD *)(a1 + 144) = v8;
      return v6;
    }
  }
}
// 40CE50: variable 'a4' is possibly undefined
// 40CE50: variable 'a5' is possibly undefined
// 4A9C40: using guessed type u32 _start___libc_IO_vtables[48];
// 4AA2E8: using guessed type __int64 (__fastcall *_start___libc_atexit)();

//----- (000000000040CF20) ----------------------------------------------------
__int64 __fastcall IO_file_underflow_mmap(__int64 a1, __int64 a2, __int64 a3, __int64 a4, u32 *a5, __int64 a6)
{
  unsigned __int8 *v6; // rax
  u32 *v8; // r8
  __int64 v9; // r9
  unsigned __int8 *v10; // rax
  __int64 v11; // rbp

  v6 = *(unsigned __int8 **)(a1 + 8);
  if ( (unsigned __int64)v6 < *(_QWORD *)(a1 + 16) )
    return *v6;
  if ( (unsigned int)mmap_remap_check(a1, a2, a3, a4, a5, a6) )
  {
    v11 = *(_QWORD *)(a1 + 216);
    if ( (char *)&_start___libc_atexit - (char *)_start___libc_IO_vtables <= (unsigned __int64)(v11
                                                                                              - (_QWORD)_start___libc_IO_vtables) )
      IO_vtable_check(a1, a2, (__int64)_start___libc_IO_vtables, v11 - (_QWORD)_start___libc_IO_vtables, v8, v9);
    return (*(__int64 (__fastcall **)(__int64))(v11 + 32))(a1);
  }
  else
  {
    v10 = *(unsigned __int8 **)(a1 + 8);
    if ( (unsigned __int64)v10 >= *(_QWORD *)(a1 + 16) )
    {
      *(_DWORD *)a1 |= 0x10u;
      return 0xFFFFFFFFLL;
    }
    else
    {
      return *v10;
    }
  }
}
// 40CFA2: variable 'v8' is possibly undefined
// 40CFA2: variable 'v9' is possibly undefined
// 4A9C40: using guessed type u32 _start___libc_IO_vtables[48];
// 4AA2E8: using guessed type __int64 (__fastcall *_start___libc_atexit)();

//----- (000000000040CFB0) ----------------------------------------------------
unsigned __int64 __fastcall IO_file_read(__int64 a1, char *a2, size_t a3)
{
  unsigned int v4; // edi

  v4 = *(_DWORD *)(a1 + 112);
  if ( (*(_BYTE *)(a1 + 116) & 2) != 0 )
    return _read_nocancel(v4, a2, a3);
  else
    return read(v4, a2, a3);
}

//----- (000000000040CFD0) ----------------------------------------------------
unsigned __int64 __fastcall IO_new_file_xsputn(
        _QWORD *a1,
        unsigned __int64 a2,
        unsigned __int64 a3,
        __int64 a4,
        u32 *a5,
        __int64 a6)
{
  __int64 v6; // r12
  __int64 v8; // r13
  unsigned __int64 v10; // rdi
  unsigned __int64 v11; // rax
  unsigned __int64 v12; // rdx
  __int64 v13; // r15
  unsigned __int64 v14; // r14
  unsigned __int64 v16; // rcx
  unsigned __int64 v17; // rax
  __int64 v18; // r12
  u32 *v19; // r8
  __int64 v20; // r9
  unsigned __int64 v21; // rcx
  unsigned __int64 v22; // r15
  unsigned __int64 v23; // rax
  unsigned __int64 v24; // rbp
  unsigned __int64 v25; // rax

  v6 = 0LL;
  if ( !a3 )
    return v6;
  v8 = a2;
  v10 = a1[5];
  if ( (*(_DWORD *)a1 & 0xA00) == 2560 )
  {
    v12 = a1[8] - v10;
    if ( a3 <= v12 )
    {
      v16 = a2 + a3;
      if ( a2 < a2 + a3 )
      {
        v17 = v16 - 1;
        if ( *(_BYTE *)(v16 - 1) == 10 )
        {
LABEL_33:
          v25 = v17 - a2;
          v12 = v25 + 1;
          if ( v25 == -1LL )
          {
            v14 = a3;
            v13 = 1LL;
            goto LABEL_9;
          }
          v13 = 1LL;
LABEL_6:
          if ( a3 <= v12 )
            v12 = a3;
          v8 = v12 + a2;
          v14 = a3 - v12;
          a1[5] = j_mempcpy(v10, a2, v12);
LABEL_9:
          if ( !(v14 + v13) )
            return a3 - v14;
          goto LABEL_20;
        }
        while ( a2 != v17 )
        {
          if ( *(_BYTE *)--v17 == 10 )
            goto LABEL_33;
        }
      }
      v13 = 0LL;
      goto LABEL_6;
    }
  }
  else
  {
    v11 = a1[6];
    if ( v11 <= v10 )
      goto LABEL_19;
    v12 = v11 - v10;
  }
  v13 = 0LL;
  if ( v12 )
    goto LABEL_6;
LABEL_19:
  v14 = a3;
LABEL_20:
  v18 = a1[27];
  if ( (char *)&_start___libc_atexit - (char *)_start___libc_IO_vtables <= (unsigned __int64)(v18
                                                                                            - (_QWORD)_start___libc_IO_vtables) )
    IO_vtable_check(v10, a2, (__int64)_start___libc_IO_vtables, v18 - (_QWORD)_start___libc_IO_vtables, a5, a6);
  if ( (*(unsigned int (__fastcall **)(_QWORD *, __int64))(v18 + 24))(a1, 0xFFFFFFFFLL) == -1 )
  {
    v24 = a3 - v14;
    v6 = -1LL;
    if ( v14 )
      return v24;
  }
  else
  {
    v21 = a1[8] - a1[7];
    v22 = v14;
    if ( v21 > 0x7F )
      v22 = v14 - v14 % v21;
    if ( v22 )
    {
      v23 = new_do_write((__int64)a1, v8, v22, v21, v19, v20);
      if ( v23 < v22 )
        return a3 - v14 + v23;
      v14 -= v23;
    }
    v6 = a3;
    if ( v14 )
      return IO_default_xsputn(a1, v8 + v22, v14, v21, v19, v20) - v14 + a3;
  }
  return v6;
}
// 40D190: variable 'a5' is possibly undefined
// 40D190: variable 'a6' is possibly undefined
// 40D11C: variable 'v21' is possibly undefined
// 40D11C: variable 'v19' is possibly undefined
// 40D11C: variable 'v20' is possibly undefined
// 4010B0: using guessed type __int64 __fastcall j_mempcpy(_QWORD, _QWORD, _QWORD);
// 4A9C40: using guessed type u32 _start___libc_IO_vtables[48];
// 4AA2E8: using guessed type __int64 (__fastcall *_start___libc_atexit)();

//----- (000000000040D1C0) ----------------------------------------------------
unsigned __int64 __fastcall IO_new_file_init_internal(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        u32 a6)
{
  unsigned __int64 result; // rax

  *(_DWORD *)a1 |= 0x240Cu;
  *(_QWORD *)(a1 + 144) = -1LL;
  result = IO_link_in((_QWORD *)a1, a2, a3, a4, a5, a6);
  *(_DWORD *)(a1 + 112) = -1;
  return result;
}

//----- (000000000040D1F0) ----------------------------------------------------
unsigned __int64 __fastcall IO_new_file_init(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, u32 a6)
{
  unsigned __int64 result; // rax

  *(_DWORD *)a1 |= 0x240Cu;
  *(_QWORD *)(a1 + 144) = -1LL;
  result = IO_link_in((_QWORD *)a1, a2, a3, a4, a5, a6);
  *(_DWORD *)(a1 + 112) = -1;
  return result;
}

//----- (000000000040D220) ----------------------------------------------------
int *__fastcall IO_file_open(int *a1, const char *a2, unsigned int a3, int a4, __int16 a5)
{
  __int64 v8; // rsi
  __int64 v9; // rcx
  u32 *v10; // r8
  __int64 v11; // r9
  signed int v12; // er12
  int v13; // eax
  __int64 v14; // rdx
  __int64 v15; // rbp

  v8 = a3;
  if ( (a1[29] & 2) != 0 )
    v12 = _open_nocancel(a2, a3, a4);
  else
    v12 = open64(a2, a3, a4);
  if ( v12 < 0 )
    return 0LL;
  v13 = *a1;
  a1[28] = v12;
  v14 = a5 & 0x100C;
  *a1 = v14 | v13 & 0xFFFFEFF3;
  if ( (a5 & 0x1004) != 4100 )
    goto LABEL_8;
  v15 = *((_QWORD *)a1 + 27);
  if ( (char *)&_start___libc_atexit - (char *)_start___libc_IO_vtables <= (unsigned __int64)(v15
                                                                                            - (_QWORD)_start___libc_IO_vtables) )
    IO_vtable_check(
      (__int64)a2,
      v8,
      (__int64)_start___libc_IO_vtables,
      v15 - (_QWORD)_start___libc_IO_vtables,
      v10,
      v11);
  v8 = 0LL;
  if ( (*(__int64 (__fastcall **)(int *, _QWORD, __int64))(v15 + 128))(a1, 0LL, 2LL) == -1
    && __readfsdword(0xFFFFFFC0) != 29 )
  {
    _close_nocancel(v12);
    return 0LL;
  }
  else
  {
LABEL_8:
    IO_link_in(a1, v8, v14, v9, (__int64)v10, v11);
    return a1;
  }
}
// 40D300: variable 'v10' is possibly undefined
// 40D300: variable 'v11' is possibly undefined
// 40D2B3: variable 'v14' is possibly undefined
// 40D2B3: variable 'v9' is possibly undefined
// 4A9C40: using guessed type u32 _start___libc_IO_vtables[48];
// 4AA2E8: using guessed type __int64 (__fastcall *_start___libc_atexit)();

//----- (000000000040D310) ----------------------------------------------------
__int64 __fastcall IO_new_file_attach(__int64 a1, __int64 a2, __int64 a3, __int64 a4, u32 *a5, __int64 a6)
{
  int v6; // eax
  __int64 v7; // r12
  unsigned int v8; // er13
  __int64 result; // rax

  if ( *(_DWORD *)(a1 + 112) != -1 )
    return 0LL;
  v6 = *(_DWORD *)a1;
  v7 = *(_QWORD *)(a1 + 216);
  *(_DWORD *)(a1 + 112) = a2;
  *(_QWORD *)(a1 + 144) = -1LL;
  *(_DWORD *)a1 = v6 & 0xFFFFFFB3 | 0x40;
  v8 = __readfsdword(0xFFFFFFC0);
  if ( (char *)&_start___libc_atexit - (char *)_start___libc_IO_vtables <= (unsigned __int64)(v7
                                                                                            - (_QWORD)_start___libc_IO_vtables) )
    IO_vtable_check(a1, a2, (__int64)_start___libc_IO_vtables, v7 - (_QWORD)_start___libc_IO_vtables, a5, a6);
  if ( (*(__int64 (__fastcall **)(__int64, _QWORD, __int64, __int64, u32 *))(v7 + 72))(a1, 0LL, 1LL, 3LL, a5) != -1
    || (result = 0LL, __readfsdword(0xFFFFFFC0) == 29) )
  {
    __writefsdword(0xFFFFFFC0, v8);
    return a1;
  }
  return result;
}
// 40D381: variable 'a5' is possibly undefined
// 4A9C40: using guessed type u32 _start___libc_IO_vtables[48];
// 4AA2E8: using guessed type __int64 (__fastcall *_start___libc_atexit)();

//----- (000000000040D3C0) ----------------------------------------------------
__int64 __fastcall IO_new_do_write(__int64 a1, __int64 a2, __int64 a3, __int64 a4, u32 *a5, __int64 a6)
{
  if ( a3 )
    return (unsigned int)-(a3 != new_do_write(a1, a2, a3, a4, a5, a6));
  else
    return 0LL;
}

//----- (000000000040D3F0) ----------------------------------------------------
__int64 __fastcall IO_new_file_close_it(__int64 a1, __int64 a2, __int64 a3, __int64 a4, u32 *a5, unsigned __int64 a6)
{
  unsigned int v6; // ebp
  unsigned int v7; // er12
  __int64 v8; // rdx
  __int64 v9; // rcx
  u32 *v10; // r8
  unsigned __int64 v11; // r9
  __int64 v12; // rbp
  _QWORD *v13; // rax
  __int64 v14; // rdx
  unsigned int *v15; // rcx
  u32 *v16; // r8
  u32 v17; // er9
  __int64 v19; // rax

  v6 = *(_DWORD *)(a1 + 112);
  if ( v6 != -1 )
  {
    v7 = 0;
    if ( (*(_DWORD *)a1 & 0x808) == 2048 )
    {
      if ( *(int *)(a1 + 192) <= 0 )
      {
        a2 = *(_QWORD *)(a1 + 32);
        v7 = IO_new_do_write(a1, a2, *(_QWORD *)(a1 + 40) - a2, a4, a5, a6);
      }
      else
      {
        v19 = *(_QWORD *)(a1 + 160);
        a2 = *(_QWORD *)(v19 + 24);
        v7 = IO_wdo_write(a1, a2, (*(_QWORD *)(v19 + 32) - a2) >> 2, a4, a5);
      }
    }
    v6 = 0;
    IO_unsave_markers((int *)a1, a2, a3, a4, a5, a6);
    if ( (*(_BYTE *)(a1 + 116) & 0x20) == 0 )
    {
      v12 = *(_QWORD *)(a1 + 216);
      if ( (char *)&_start___libc_atexit - (char *)_start___libc_IO_vtables <= (unsigned __int64)(v12
                                                                                                - (_QWORD)_start___libc_IO_vtables) )
        IO_vtable_check(a1, a2, (__int64)_start___libc_IO_vtables, v12 - (_QWORD)_start___libc_IO_vtables, v10, v11);
      v6 = (*(__int64 (__fastcall **)(__int64))(v12 + 136))(a1);
    }
    if ( *(int *)(a1 + 192) > 0 )
    {
      if ( *(_QWORD *)(*(_QWORD *)(a1 + 160) + 64LL) )
        IO_free_wbackup_area((int *)a1, a2, v8, v9, v10, v11);
      IO_wsetb(a1, 0LL, 0LL, 0LL, (__int64)v10, v11);
      v13 = *(_QWORD **)(a1 + 160);
      v13[2] = 0LL;
      *v13 = 0LL;
      v13[1] = 0LL;
      v13[4] = 0LL;
      v13[3] = 0LL;
      v13[5] = 0LL;
    }
    IO_setb((int *)a1, 0LL, 0LL, 0LL, v10, v11);
    *(_QWORD *)(a1 + 24) = 0LL;
    *(_QWORD *)(a1 + 8) = 0LL;
    *(_QWORD *)(a1 + 16) = 0LL;
    *(_QWORD *)(a1 + 40) = 0LL;
    *(_QWORD *)(a1 + 32) = 0LL;
    *(_QWORD *)(a1 + 48) = 0LL;
    IO_un_link((unsigned int *)a1, 0LL, v14, v15, v16, v17);
    *(_DWORD *)a1 = -72539124;
    *(_DWORD *)(a1 + 112) = -1;
    if ( !v6 )
      v6 = v7;
    *(_QWORD *)(a1 + 144) = -1LL;
  }
  return v6;
}
// 40D421: variable 'a3' is possibly undefined
// 40D421: variable 'a4' is possibly undefined
// 40D421: variable 'a5' is possibly undefined
// 40D421: variable 'a6' is possibly undefined
// 40D580: variable 'v10' is possibly undefined
// 40D580: variable 'v11' is possibly undefined
// 40D479: variable 'v8' is possibly undefined
// 40D479: variable 'v9' is possibly undefined
// 40D503: variable 'v14' is possibly undefined
// 40D503: variable 'v15' is possibly undefined
// 40D503: variable 'v16' is possibly undefined
// 40D503: variable 'v17' is possibly undefined
// 4A9C40: using guessed type u32 _start___libc_IO_vtables[48];
// 4AA2E8: using guessed type __int64 (__fastcall *_start___libc_atexit)();

//----- (000000000040D590) ----------------------------------------------------
int *__fastcall IO_new_file_fopen(__int64 a1, const char *a2, _BYTE *a3)
{
  char v3; // al
  int *v5; // rbp
  __int16 v7; // r8
  int v8; // er9
  int v9; // er10
  _BYTE *v10; // rdi
  _BYTE *v11; // r12
  char v12; // al
  __int64 v13; // rax
  __int64 v14; // r13
  __int64 v15; // r15
  __int64 v16; // r14
  _QWORD *v17; // rdx
  __int64 v18; // rcx
  u32 *v19; // r8
  __int64 v20; // r9
  unsigned __int8 *v21; // rax
  __int64 v22; // rdx
  __int64 v23; // rcx
  u32 *v24; // r8
  unsigned __int64 v25; // r9
  unsigned __int8 *v26; // r12
  __int64 v27; // rcx
  __int64 v28; // r8
  signed int v29; // er9
  __int64 v30; // rdx
  unsigned __int8 *v31; // rdi
  unsigned __int8 *v32; // rsi
  int v33; // eax
  unsigned int v34; // eax
  unsigned int v35; // er12
  _BYTE *v36; // rax
  __int64 v37; // rax
  __int64 v38; // rdx
  __int64 v39; // rcx
  u32 *v40; // r8
  unsigned __int64 v41; // r9
  _QWORD *v42; // rax
  __m128i v43; // xmm0
  __m128i v44; // xmm1
  __m128i v45; // xmm2
  __int64 v46; // rdx
  __m128i v47; // xmm3
  __m128i v48; // xmm4
  __m128i v49; // xmm5
  __m128i v50; // xmm6
  __m128i v51; // xmm7
  __int64 v52; // rax
  __int64 v53; // rdx
  __m128i v54; // xmm0
  __m128i v55; // xmm1
  __int64 v56; // rsi
  __int64 v57; // rcx
  __int64 v58; // rdx
  __int64 v59; // rcx
  u32 *v60; // r8
  unsigned __int64 v61; // r9
  __int64 v62[13]; // [rsp+0h] [rbp-68h] BYREF

  v62[5] = __readfsqword(0x28u);
  if ( *(_DWORD *)(a1 + 112) != -1 )
    return 0LL;
  v3 = *a3;
  if ( *a3 == 114 )
  {
    v7 = 8;
    v8 = 0;
    v9 = 0;
  }
  else if ( v3 == 119 )
  {
    v7 = 4;
    v8 = 1;
    v9 = 576;
  }
  else
  {
    if ( v3 != 97 )
    {
      v5 = 0LL;
      __writefsdword(0xFFFFFFC0, 0x16u);
      return v5;
    }
    v7 = 4100;
    v8 = 1;
    v9 = 1088;
  }
  v10 = a3 + 6;
  v11 = a3;
  do
  {
    v12 = *++a3;
    if ( *a3 == 99 )
    {
      *(_DWORD *)(a1 + 116) |= 2u;
    }
    else if ( v12 > 99 )
    {
      switch ( v12 )
      {
        case 'm':
          *(_DWORD *)(a1 + 116) |= 1u;
          break;
        case 'x':
          LOBYTE(v9) = v9 | 0x80;
          v11 = a3;
          break;
        case 'e':
          v9 |= 0x80000u;
          *(_DWORD *)(a1 + 116) |= 0x40u;
          break;
      }
    }
    else
    {
      switch ( v12 )
      {
        case 43:
          v7 &= 0x1000u;
          v11 = a3;
          v8 = 2;
          break;
        case 98:
          v11 = a3;
          break;
        case 0:
          goto LABEL_15;
      }
    }
  }
  while ( a3 != v10 );
LABEL_15:
  v5 = IO_file_open((int *)a1, a2, v8 | (unsigned int)v9, 438, v7);
  if ( !v5 )
    return 0LL;
  v13 = j_strstr(v11 + 1, ",ccs=");
  v14 = v13;
  if ( !v13 )
    return v5;
  v15 = v13 + 5;
  v16 = j_strchrnul(v13 + 5, 44LL) - (v13 + 5);
  v21 = (unsigned __int8 *)malloc(v16 + 3, 44LL, v17, v18, v19, v20);
  v26 = v21;
  if ( !v21 )
  {
    v35 = __readfsdword(0xFFFFFFC0);
    IO_new_file_close_it(a1, 44LL, v22, v23, v24, v25);
    __writefsdword(0xFFFFFFC0, v35);
    return 0LL;
  }
  *(_BYTE *)j_mempcpy(v21, v15, v16) = 0;
  v30 = *v26;
  if ( (_BYTE)v30 )
  {
    v31 = v26;
    v32 = v26;
    v29 = 0;
    do
    {
      v28 = (char)v30;
      v33 = (word_486FE0[(char)v30] >> 3) & 1;
      if ( (unsigned __int8)(v30 - 44) <= 0x33u )
        v33 |= (0x8000000004007uLL >> ((unsigned __int8)v30 - 44)) & 1;
      v27 = (unsigned int)(v29 + 1);
      if ( (_BYTE)v33 )
      {
        *v32++ = dword_4866E0[(char)v30];
      }
      else if ( (_BYTE)v30 == 47 )
      {
        if ( v29 == 2 )
          goto LABEL_43;
        v34 = v29 + 2;
        *v32 = 47;
        ++v29;
        ++v32;
        v27 = v34;
      }
      v30 = *++v31;
    }
    while ( (_BYTE)v30 );
    if ( v29 > 1 )
      goto LABEL_43;
    v36 = v32 + 1;
    *v32 = 47;
    if ( (_DWORD)v27 != 1 )
    {
      ++v32;
      goto LABEL_43;
    }
  }
  else
  {
    v36 = v26 + 1;
    *v26 = 47;
  }
  *v36 = 47;
  v32 = v36 + 1;
LABEL_43:
  *v32 = 0;
  if ( !v26[2] )
  {
    v27 = (__int64)dword_4866E0;
    v37 = 0LL;
    do
    {
      v30 = dword_4866E0[*(char *)(v14 + v37 + 5)];
      v26[v37++] = v30;
    }
    while ( (_BYTE)v30 );
  }
  if ( (unsigned int)_wcsmbs_named_conv(v62, v26, v30, v27, v28, v29) )
  {
    v5 = 0LL;
    IO_new_file_close_it(a1, (__int64)v26, v38, v39, v40, v41);
    free((__int64)v26, (__int64)v26, v58, v59, v60, v61);
    __writefsdword(0xFFFFFFC0, 0x16u);
  }
  else
  {
    free((__int64)v26, (__int64)v26, v38, v39, v40, v41);
    if ( v62[1] != 1 )
      _assert_fail((__int64)"fcts.towc_nsteps == 1", (__int64)"fileops.c", 0x142u, "_IO_new_file_fopen");
    if ( v62[3] != 1 )
      _assert_fail((__int64)"fcts.tomb_nsteps == 1", (__int64)"fileops.c", 0x143u, "_IO_new_file_fopen");
    v42 = *(_QWORD **)(a1 + 160);
    v43 = _mm_loadu_si128((const __m128i *)&_libio_codecvt);
    v44 = _mm_loadu_si128((const __m128i *)&xmmword_4A62F0);
    v45 = _mm_loadu_si128((const __m128i *)&xmmword_4A6300);
    v46 = v42[1];
    v42[11] = 0LL;
    v47 = _mm_loadu_si128(xmmword_4A6310);
    v48 = _mm_loadu_si128((const __m128i *)&xmmword_4A6330);
    *v42 = v46;
    v49 = _mm_loadu_si128((const __m128i *)&xmmword_4A6340);
    v50 = _mm_loadu_si128(xmmword_4A6350);
    v42[4] = v42[3];
    v51 = _mm_loadu_si128((const __m128i *)&xmmword_4A6370);
    *(_QWORD *)(*(_QWORD *)(a1 + 160) + 96LL) = 0LL;
    v52 = *(_QWORD *)(a1 + 160);
    *(_QWORD *)(a1 + 152) = v52 + 104;
    v53 = v62[0];
    *(__m128i *)(v52 + 104) = v43;
    v54 = _mm_loadu_si128((const __m128i *)&xmmword_4A6380);
    *(__m128i *)(v52 + 120) = v44;
    v55 = _mm_loadu_si128((const __m128i *)&xmmword_4A6390);
    *(__m128i *)(v52 + 136) = v45;
    *(__m128i *)(v52 + 152) = v47;
    *(__m128i *)(v52 + 184) = v48;
    *(__m128i *)(v52 + 200) = v49;
    *(__m128i *)(v52 + 216) = v50;
    *(__m128i *)(v52 + 248) = v51;
    *(__m128i *)(v52 + 264) = v54;
    *(__m128i *)(v52 + 280) = v55;
    *(_QWORD *)(v52 + 168) = 1LL;
    *(_QWORD *)(v52 + 176) = v53;
    v56 = *((_QWORD *)v5 + 20);
    *(_QWORD *)(v52 + 200) = 1LL;
    v57 = v62[2];
    *(_DWORD *)(v52 + 208) = 1;
    *(_QWORD *)(v52 + 216) = v56 + 88;
    *(_QWORD *)(v52 + 232) = 1LL;
    *(_QWORD *)(v52 + 240) = v57;
    *(_QWORD *)(v52 + 264) = 9LL;
    *(_DWORD *)(v52 + 272) = 1;
    *(_QWORD *)(v52 + 280) = v56 + 88;
    *(_QWORD *)(a1 + 216) = *(_QWORD *)(v52 + 304);
    v5[48] = 1;
  }
  return v5;
}
// 40D6C1: variable 'v17' is possibly undefined
// 40D6C1: variable 'v18' is possibly undefined
// 40D6C1: variable 'v19' is possibly undefined
// 40D6C1: variable 'v20' is possibly undefined
// 40D7DF: variable 'v22' is possibly undefined
// 40D7DF: variable 'v23' is possibly undefined
// 40D7DF: variable 'v24' is possibly undefined
// 40D7DF: variable 'v25' is possibly undefined
// 40D89B: variable 'v27' is possibly undefined
// 40D89B: variable 'v28' is possibly undefined
// 40D89B: variable 'v29' is possibly undefined
// 40D8AB: variable 'v38' is possibly undefined
// 40D8AB: variable 'v39' is possibly undefined
// 40D8AB: variable 'v40' is possibly undefined
// 40D8AB: variable 'v41' is possibly undefined
// 40DA4D: variable 'v58' is possibly undefined
// 40DA4D: variable 'v59' is possibly undefined
// 40DA4D: variable 'v60' is possibly undefined
// 40DA4D: variable 'v61' is possibly undefined
// 401060: using guessed type __int64 __fastcall j_strchrnul(_QWORD, _QWORD);
// 401070: using guessed type __int64 __fastcall j_strstr(_QWORD, _QWORD);
// 4010B0: using guessed type __int64 __fastcall j_mempcpy(_QWORD, _QWORD, _QWORD);
// 4866E0: using guessed type unsigned int dword_4866E0[256];
// 486FE0: using guessed type _WORD word_486FE0[256];
// 4A62E0: using guessed type __int128 _libio_codecvt;
// 4A62F0: using guessed type __int128 xmmword_4A62F0;
// 4A6300: using guessed type __int128 xmmword_4A6300;
// 4A6310: using guessed type __m128i xmmword_4A6310[2];
// 4A6330: using guessed type __int128 xmmword_4A6330;
// 4A6340: using guessed type __int128 xmmword_4A6340;
// 4A6350: using guessed type __m128i xmmword_4A6350[2];
// 4A6370: using guessed type __int128 xmmword_4A6370;
// 4A6380: using guessed type __int128 xmmword_4A6380;
// 4A6390: using guessed type __int128 xmmword_4A6390;

//----- (000000000040DAC0) ----------------------------------------------------
__int64 *__fastcall IO_new_file_finish(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        unsigned int *a4,
        u32 *a5,
        unsigned __int64 a6)
{
  __int64 v6; // rax
  __int64 v7; // rsi
  __int64 v8; // rbp

  if ( *(_DWORD *)(a1 + 112) != -1 )
  {
    if ( *(int *)(a1 + 192) <= 0 )
    {
      v7 = *(_QWORD *)(a1 + 32);
      IO_new_do_write(a1, v7, *(_QWORD *)(a1 + 40) - v7, (__int64)a4, a5, a6);
    }
    else
    {
      v6 = *(_QWORD *)(a1 + 160);
      v7 = *(_QWORD *)(v6 + 24);
      IO_wdo_write(a1, v7, (*(_QWORD *)(v6 + 32) - v7) >> 2, (__int64)a4, a5);
    }
    if ( (*(_BYTE *)a1 & 0x40) == 0 )
    {
      v8 = *(_QWORD *)(a1 + 216);
      if ( (char *)&_start___libc_atexit - (char *)_start___libc_IO_vtables <= (unsigned __int64)(v8
                                                                                                - (_QWORD)_start___libc_IO_vtables) )
        IO_vtable_check(a1, v7, (__int64)_start___libc_IO_vtables, v8 - (_QWORD)_start___libc_IO_vtables, a5, a6);
      (*(void (__fastcall **)(__int64))(v8 + 136))(a1);
    }
  }
  return IO_default_finish(a1, 0LL, a3, a4, a5, a6);
}
// 40DB58: variable 'a5' is possibly undefined
// 40DB58: variable 'a6' is possibly undefined
// 40DB34: variable 'a3' is possibly undefined
// 40DB34: variable 'a4' is possibly undefined
// 4A9C40: using guessed type u32 _start___libc_IO_vtables[48];
// 4AA2E8: using guessed type __int64 (__fastcall *_start___libc_atexit)();

//----- (000000000040DB60) ----------------------------------------------------
__int64 __fastcall IO_new_file_overflow(
        unsigned int *a1,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        u32 *a5,
        unsigned __int64 a6)
{
  __int64 v6; // rcx
  int v7; // ebp
  __int64 v8; // rax
  _BYTE *v9; // rdx
  _BYTE *v11; // rsi
  _BYTE *v12; // rax
  int v13; // esi
  unsigned int v14; // eax
  bool v15; // al
  unsigned __int64 v16; // r12
  __int64 v17; // rax

  v6 = *a1;
  if ( (v6 & 8) != 0 )
  {
    *a1 = v6 | 0x20;
    __writefsdword(0xFFFFFFC0, 9u);
    return 0xFFFFFFFFLL;
  }
  v7 = a2;
  v8 = *((_QWORD *)a1 + 4);
  if ( (v6 & 0x800) != 0 )
  {
    if ( v8 )
    {
      v9 = (_BYTE *)*((_QWORD *)a1 + 5);
      goto LABEL_5;
    }
  }
  else if ( v8 )
  {
    v9 = (_BYTE *)*((_QWORD *)a1 + 1);
    goto LABEL_14;
  }
  IO_doallocbuf((__int64)a1, a2, a3, v6, a5, a6);
  v9 = (_BYTE *)*((_QWORD *)a1 + 7);
  v6 = *a1;
  *((_QWORD *)a1 + 3) = v9;
  *((_QWORD *)a1 + 1) = v9;
  *((_QWORD *)a1 + 2) = v9;
LABEL_14:
  if ( (v6 & 0x100) != 0 )
  {
    v16 = *((_QWORD *)a1 + 2) - (_QWORD)v9;
    IO_free_backup_area((int *)a1, a2, (__int64)v9, v6, a5, a6);
    v17 = *((_QWORD *)a1 + 7) - *((_QWORD *)a1 + 3);
    v6 = *a1;
    if ( *((_QWORD *)a1 + 3) - *((_QWORD *)a1 + 7) > v16 )
      v17 = -(__int64)v16;
    v9 = (_BYTE *)(v17 + *((_QWORD *)a1 + 3));
    *((_QWORD *)a1 + 3) = v9;
    *((_QWORD *)a1 + 1) = v9;
  }
  v11 = (_BYTE *)*((_QWORD *)a1 + 8);
  if ( v11 == v9 )
  {
    v9 = (_BYTE *)*((_QWORD *)a1 + 7);
    *((_QWORD *)a1 + 2) = v9;
    v12 = v9;
  }
  else
  {
    v12 = (_BYTE *)*((_QWORD *)a1 + 2);
  }
  *((_QWORD *)a1 + 6) = v11;
  v13 = a1[48];
  *((_QWORD *)a1 + 1) = v12;
  *((_QWORD *)a1 + 3) = v12;
  v14 = v6;
  BYTE1(v14) = BYTE1(v6) | 8;
  *((_QWORD *)a1 + 5) = v9;
  *((_QWORD *)a1 + 4) = v9;
  *a1 = v14;
  if ( v13 <= 0 )
  {
    v6 &= 0x202u;
    if ( (_DWORD)v6 )
    {
      *((_QWORD *)a1 + 6) = v9;
      if ( v7 != -1 )
        goto LABEL_6;
      return IO_new_do_write((__int64)a1, *((_QWORD *)a1 + 4), (__int64)&v9[-*((_QWORD *)a1 + 4)], v6, a5, a6);
    }
  }
LABEL_5:
  if ( v7 == -1 )
    return IO_new_do_write((__int64)a1, *((_QWORD *)a1 + 4), (__int64)&v9[-*((_QWORD *)a1 + 4)], v6, a5, a6);
LABEL_6:
  if ( *((_BYTE **)a1 + 8) == v9 )
  {
    if ( (int)a1[48] <= 0 )
      v15 = (unsigned int)IO_new_do_write(
                            (__int64)a1,
                            *((_QWORD *)a1 + 4),
                            (__int64)&v9[-*((_QWORD *)a1 + 4)],
                            v6,
                            a5,
                            a6) == -1;
    else
      v15 = (unsigned int)IO_wdo_write(
                            (__int64)a1,
                            *(_QWORD *)(*((_QWORD *)a1 + 20) + 24LL),
                            (__int64)(*(_QWORD *)(*((_QWORD *)a1 + 20) + 32LL) - *(_QWORD *)(*((_QWORD *)a1 + 20) + 24LL)) >> 2,
                            v6,
                            a5) == -1;
    if ( v15 )
      return 0xFFFFFFFFLL;
    v9 = (_BYTE *)*((_QWORD *)a1 + 5);
  }
  *((_QWORD *)a1 + 5) = v9 + 1;
  *v9 = v7;
  if ( ((*a1 & 2) != 0 || (*a1 & 0x200) != 0 && v7 == 10)
    && (unsigned int)IO_new_do_write(
                       (__int64)a1,
                       *((_QWORD *)a1 + 4),
                       *((_QWORD *)a1 + 5) - *((_QWORD *)a1 + 4),
                       v6,
                       a5,
                       a6) == -1 )
  {
    return 0xFFFFFFFFLL;
  }
  return (unsigned __int8)v7;
}
// 40DC47: variable 'a5' is possibly undefined
// 40DC47: variable 'a6' is possibly undefined
// 40DC5E: variable 'v6' is possibly undefined

//----- (000000000040DD70) ----------------------------------------------------
__int64 __fastcall IO_new_file_sync(__int64 a1, __int64 a2, __int64 a3, __int64 a4, u32 *a5, __int64 a6)
{
  unsigned __int64 v6; // rdx
  unsigned __int64 v7; // rsi
  bool v8; // al
  __int64 v9; // rsi
  __int64 v10; // rbp
  __int64 v11; // rcx

  v6 = *(_QWORD *)(a1 + 40);
  v7 = *(_QWORD *)(a1 + 32);
  if ( v6 <= v7
    || (*(int *)(a1 + 192) <= 0 ? (v8 = (unsigned int)IO_new_do_write(a1, v7, v6 - v7, a4, a5, a6) != 0) : (v8 = (unsigned int)IO_wdo_write(a1, *(_QWORD *)(*(_QWORD *)(a1 + 160) + 24LL), (__int64)(*(_QWORD *)(*(_QWORD *)(a1 + 160) + 32LL) - *(_QWORD *)(*(_QWORD *)(a1 + 160) + 24LL)) >> 2, a4, a5) != 0),
        !v8) )
  {
    v9 = *(_QWORD *)(a1 + 8) - *(_QWORD *)(a1 + 16);
    if ( !v9 )
    {
LABEL_10:
      *(_QWORD *)(a1 + 144) = -1LL;
      return 0LL;
    }
    v10 = *(_QWORD *)(a1 + 216);
    v11 = v10 - (_QWORD)_start___libc_IO_vtables;
    if ( (char *)&_start___libc_atexit - (char *)_start___libc_IO_vtables <= (unsigned __int64)(v10
                                                                                              - (_QWORD)_start___libc_IO_vtables) )
      IO_vtable_check(a1, v9, (__int64)_start___libc_IO_vtables, v11, a5, a6);
    if ( (*(__int64 (__fastcall **)(__int64, __int64, __int64, __int64, u32 *))(v10 + 128))(a1, v9, 1LL, v11, a5) != -1 )
    {
      *(_QWORD *)(a1 + 16) = *(_QWORD *)(a1 + 8);
      goto LABEL_10;
    }
    if ( __readfsdword(0xFFFFFFC0) == 29 )
      goto LABEL_10;
  }
  return 0xFFFFFFFFLL;
}
// 40DE4D: variable 'a5' is possibly undefined
// 40DE4D: variable 'a6' is possibly undefined
// 40DDF5: variable 'v11' is possibly undefined
// 4A9C40: using guessed type u32 _start___libc_IO_vtables[48];
// 4AA2E8: using guessed type __int64 (__fastcall *_start___libc_atexit)();

//----- (000000000040DE60) ----------------------------------------------------
__int64 __fastcall save_for_backup(_QWORD *a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  u32 *v9; // r8
  __int64 v10; // rsi
  __int64 *v11; // rax
  __int64 v12; // r15
  __int64 v13; // rbp
  unsigned __int64 v14; // r14
  __int64 v15; // rbx
  __int64 **v16; // rdx
  __int64 v17; // rcx
  __int64 v18; // rdx
  __int64 v19; // rdi
  _QWORD *v21; // rax
  _QWORD *v22; // r14
  __int64 v23; // rsi
  __int64 v24; // rdx
  __int64 v25; // rcx
  u32 *v26; // r8
  unsigned __int64 v27; // r9
  __int64 v28; // rcx
  char *v29; // rsi
  __int64 v30; // rax
  char *v31; // [rsp+0h] [rbp-58h]
  __int64 v32; // [rsp+8h] [rbp-50h]
  char *v33; // [rsp+8h] [rbp-50h]
  __int64 v34; // [rsp+10h] [rbp-48h]
  __int64 v35; // [rsp+18h] [rbp-40h]

  v9 = (u32 *)a1[3];
  v10 = a1[11];
  v11 = (__int64 *)a1[12];
  v12 = a1[9];
  v13 = a2 - (_QWORD)v9;
  v14 = v10 - v12;
  v15 = v13;
  v16 = (__int64 **)v11;
  if ( !v11 )
  {
    if ( v13 >= 0 )
    {
      a1[10] = v10;
      return 0LL;
    }
    v19 = a1[11];
    goto LABEL_18;
  }
  do
  {
    v17 = *((int *)v16 + 4);
    v16 = (__int64 **)*v16;
    if ( v15 > v17 )
      v15 = v17;
  }
  while ( v16 );
  v18 = v13 - v15;
  if ( v13 - v15 <= v14 )
  {
    v14 -= v18;
    v19 = v12 + v14;
    if ( v15 >= 0 )
    {
      if ( !v18 )
      {
        a1[10] = v19;
        goto LABEL_9;
      }
      v29 = (char *)v9 + v15;
      goto LABEL_19;
    }
LABEL_18:
    j_memmove(v19, v15 + v10, -v15);
    v29 = (char *)a1[3];
    v19 = a1[9] + v14 - v15;
    v18 = a2 - (_QWORD)v29;
LABEL_19:
    j_memcpy(v19, v29, v18);
    v11 = (__int64 *)a1[12];
    v13 = a2 - a1[3];
    v28 = v14 + a1[9];
    goto LABEL_15;
  }
  v35 = a1[11];
  v34 = a1[3];
  v31 = (char *)(v18 + 100);
  v21 = malloc(v18 + 100, v10, (_QWORD *)v18, v17, v9, a6);
  v22 = v21;
  if ( v21 )
  {
    if ( v15 < 0 )
    {
      v33 = (char *)v21 + 100;
      v30 = j_mempcpy((char *)v21 + 100, v15 + v35, -v15);
      v23 = v34;
      j_memcpy(v30, v34, v13);
      v25 = (__int64)v33;
    }
    else
    {
      v23 = v34 + v15;
      v25 = j_memcpy((char *)v21 + 100, v34 + v15, v13 - v15);
    }
    v32 = v25;
    free(v12, v23, v24, v25, v26, v27);
    a1[9] = v22;
    v11 = (__int64 *)a1[12];
    v28 = v32;
    a1[11] = (char *)v22 + (_QWORD)v31;
    v13 = a2 - a1[3];
LABEL_15:
    a1[10] = v28;
    while ( v11 )
    {
LABEL_9:
      *((_DWORD *)v11 + 4) -= v13;
      v11 = (__int64 *)*v11;
    }
    return 0LL;
  }
  return 0xFFFFFFFFLL;
}
// 40DF5C: variable 'v24' is possibly undefined
// 40DF5C: variable 'v26' is possibly undefined
// 40DF5C: variable 'v27' is possibly undefined
// 401030: using guessed type __int64 __fastcall j_memmove(_QWORD, _QWORD, _QWORD);
// 401040: using guessed type __int64 __fastcall j_memcpy(_QWORD, _QWORD, _QWORD);
// 4010B0: using guessed type __int64 __fastcall j_mempcpy(_QWORD, _QWORD, _QWORD);

//----- (000000000040E040) ----------------------------------------------------
__int64 __fastcall flush_cleanup(__int64 a1, __int64 a2, __int64 a3, __int64 a4, u32 *a5, u32 a6)
{
  __int64 result; // rax
  bool v7; // zf

  result = run_fp;
  if ( run_fp )
  {
    if ( (*(_DWORD *)run_fp & 0x8000) == 0 )
    {
      a3 = *(_QWORD *)(run_fp + 136);
      v7 = (*(_DWORD *)(a3 + 4))-- == 1;
      if ( v7 )
      {
        *(_QWORD *)(a3 + 8) = 0LL;
        if ( _libc_multiple_threads )
        {
          if ( !_InterlockedDecrement((volatile signed __int32 *)a3) )
            goto LABEL_3;
        }
        else
        {
          v7 = (*(_DWORD *)a3)-- == 1;
          if ( v7 )
            goto LABEL_3;
        }
        result = _lll_unlock_wake_private((u32 *)a3, a2, a3, a4, a5, a6);
      }
    }
  }
LABEL_3:
  if ( --HIDWORD(list_all_lock) )
    return result;
  qword_4AAD38 = 0LL;
  if ( _libc_multiple_threads )
  {
    if ( !_InterlockedDecrement((volatile signed __int32 *)&list_all_lock) )
      return result;
  }
  else
  {
    LODWORD(list_all_lock) = list_all_lock - 1;
    if ( !(_DWORD)list_all_lock )
      return result;
  }
  return _lll_unlock_wake_private((u32 *)&list_all_lock, a2, a3, a4, a5, a6);
}
// 40E096: variable 'a3' is possibly undefined
// 40E096: variable 'a4' is possibly undefined
// 40E096: variable 'a5' is possibly undefined
// 40E096: variable 'a6' is possibly undefined
// 4AAD20: using guessed type __int64 run_fp;
// 4AAD30: using guessed type __int64 list_all_lock;
// 4AAD38: using guessed type __int64 qword_4AAD38;
// 4AB820: using guessed type int _libc_multiple_threads;

//----- (000000000040E0F0) ----------------------------------------------------
unsigned __int64 __fastcall IO_un_link_part_2(
        unsigned int *a1,
        __int64 a2,
        __int64 a3,
        unsigned int *a4,
        u32 *a5,
        u32 a6)
{
  __int64 v7; // rdx
  __int64 v9; // rsi
  __int64 v10; // rdx
  signed __int32 v11; // eax
  bool v14; // zf
  unsigned int *v15; // rdi
  unsigned int *v16; // rdx
  __int64 v17; // rdx
  unsigned __int64 v19; // [rsp+28h] [rbp-20h]

  v19 = __readfsqword(0x28u);
  v7 = __readfsqword(0x10u);
  if ( v7 != qword_4AAD38 )
  {
    _ESI = 1;
    if ( _libc_multiple_threads )
    {
      if ( !_InterlockedCompareExchange((volatile signed __int32 *)&list_all_lock, 1, 0) )
        goto LABEL_7;
    }
    else
    {
      __asm { cmpxchg dword ptr cs:list_all_lock, esi }
      if ( !_libc_multiple_threads )
      {
LABEL_7:
        qword_4AAD38 = v7;
        goto LABEL_8;
      }
    }
    _lll_lock_wait_private((u32 *)&list_all_lock, 1LL, v7, (__int64)a4, a5, a6);
    goto LABEL_7;
  }
LABEL_8:
  v9 = *a1;
  run_fp = (__int64)a1;
  LODWORD(v10) = ++HIDWORD(list_all_lock);
  v11 = v9 & 0x8000;
  if ( (v9 & 0x8000) == 0 )
  {
    _RDX = *((_QWORD *)a1 + 17);
    a5 = (u32 *)__readfsqword(0x10u);
    if ( a5 == *(u32 **)(_RDX + 8) )
      goto LABEL_16;
    _ESI = 1;
    v14 = _libc_multiple_threads == 0;
    if ( _libc_multiple_threads )
    {
      if ( v11 == _InterlockedCompareExchange((volatile signed __int32 *)_RDX, 1, v11) )
        goto LABEL_15;
    }
    else
    {
      __asm { cmpxchg [rdx], esi }
      if ( v14 )
      {
LABEL_15:
        _RDX = *((_QWORD *)a1 + 17);
        v9 = *a1;
        *(_QWORD *)(_RDX + 8) = a5;
        v11 = v9 & 0x8000;
LABEL_16:
        v15 = (unsigned int *)IO_list_all;
        ++*(_DWORD *)(_RDX + 4);
        if ( !v15 )
          goto LABEL_24;
        goto LABEL_17;
      }
    }
    _lll_lock_wait_private((u32 *)_RDX, 1LL, _RDX, (__int64)a4, a5, a6);
    goto LABEL_15;
  }
  v15 = (unsigned int *)IO_list_all;
  if ( IO_list_all )
  {
LABEL_17:
    a4 = (unsigned int *)*((_QWORD *)v15 + 13);
    if ( a1 == v15 )
    {
      IO_list_all = (void *)*((_QWORD *)v15 + 13);
    }
    else if ( a4 )
    {
      if ( a1 == a4 )
      {
        a4 = v15 + 26;
LABEL_43:
        *(_QWORD *)a4 = *((_QWORD *)a1 + 13);
      }
      else
      {
        while ( 1 )
        {
          v16 = (unsigned int *)*((_QWORD *)a4 + 13);
          if ( !v16 )
            break;
          if ( a1 == v16 )
          {
            a4 += 26;
            goto LABEL_43;
          }
          a4 = (unsigned int *)*((_QWORD *)a4 + 13);
        }
      }
    }
LABEL_24:
    LOBYTE(v9) = v9 & 0x7F;
    *a1 = v9;
    if ( !v11 )
    {
      v9 = *((_QWORD *)a1 + 17);
      v14 = (*(_DWORD *)(v9 + 4))-- == 1;
      v10 = HIDWORD(list_all_lock);
      if ( !v14 )
        goto LABEL_26;
      *(_QWORD *)(v9 + 8) = 0LL;
      if ( _libc_multiple_threads )
      {
        if ( !_InterlockedDecrement((volatile signed __int32 *)v9) )
          goto LABEL_38;
        goto LABEL_37;
      }
      v14 = (*(_DWORD *)v9)-- == 1;
      if ( !v14 )
LABEL_37:
        _lll_unlock_wake_private((u32 *)v9, v9, v10, (__int64)a4, a5, a6);
    }
LABEL_38:
    LODWORD(v10) = HIDWORD(list_all_lock);
    goto LABEL_26;
  }
  LOBYTE(v9) = v9 & 0x7F;
  *a1 = v9;
LABEL_26:
  run_fp = 0LL;
  v17 = (unsigned int)(v10 - 1);
  HIDWORD(list_all_lock) = v17;
  if ( !(_DWORD)v17 )
  {
    qword_4AAD38 = 0LL;
    if ( _libc_multiple_threads )
    {
      if ( !_InterlockedDecrement((volatile signed __int32 *)&list_all_lock) )
        return __readfsqword(0x28u) ^ v19;
      goto LABEL_31;
    }
    LODWORD(list_all_lock) = list_all_lock - 1;
    if ( (_DWORD)list_all_lock )
LABEL_31:
      _lll_unlock_wake_private((u32 *)&list_all_lock, v9, v17, (__int64)a4, a5, a6);
  }
  return __readfsqword(0x28u) ^ v19;
}
// 40E17B: variable 'v7' is possibly undefined
// 40E1E2: variable 'a4' is possibly undefined
// 40E1E2: variable 'a6' is possibly undefined
// 40E1F7: variable 'a5' is possibly undefined
// 4A8120: using guessed type void *IO_list_all;
// 4AAD20: using guessed type __int64 run_fp;
// 4AAD30: using guessed type __int64 list_all_lock;
// 4AAD38: using guessed type __int64 qword_4AAD38;
// 4AB820: using guessed type int _libc_multiple_threads;

//----- (000000000040E3A0) ----------------------------------------------------
unsigned __int64 __fastcall IO_un_link(unsigned int *a1, __int64 a2, __int64 a3, unsigned int *a4, u32 *a5, u32 a6)
{
  unsigned __int64 result; // rax

  if ( *(char *)a1 < 0 )
    return IO_un_link_part_2(a1, a2, a3, a4, a5, a6);
  return result;
}

//----- (000000000040E3C0) ----------------------------------------------------
unsigned __int64 __fastcall IO_link_in(_QWORD *a1, __int64 _RSI, __int64 a3, __int64 a4, __int64 _R8, u32 a6)
{
  int v6; // eax
  __int64 v7; // rdx
  int v8; // eax
  __int64 v9; // rdx
  __int64 v10; // rdx
  bool v11; // zf
  int v12; // eax
  void *v13; // rdx
  void *v14; // rax
  __int64 v15; // rdx
  void *v17; // rax
  unsigned __int64 v18; // [rsp+28h] [rbp-20h]

  v18 = __readfsqword(0x28u);
  v6 = *(_DWORD *)a1;
  if ( (*(_DWORD *)a1 & 0x80u) != 0 )
    return __readfsqword(0x28u) ^ v18;
  LOBYTE(v6) = v6 | 0x80;
  *(_DWORD *)a1 = v6;
  v7 = __readfsqword(0x10u);
  if ( qword_4AAD38 != v7 )
  {
    _RSI = 1LL;
    if ( _libc_multiple_threads )
    {
      if ( !_InterlockedCompareExchange((volatile signed __int32 *)&list_all_lock, 1, 0) )
        goto LABEL_8;
    }
    else
    {
      __asm { cmpxchg dword ptr cs:list_all_lock, esi }
      if ( !_libc_multiple_threads )
      {
LABEL_8:
        qword_4AAD38 = v7;
        goto LABEL_9;
      }
    }
    _lll_lock_wait_private((u32 *)&list_all_lock, 1LL, v7, a4, (u32 *)_R8, a6);
    goto LABEL_8;
  }
LABEL_9:
  v8 = *(_DWORD *)a1;
  run_fp = (__int64)a1;
  LODWORD(v9) = ++HIDWORD(list_all_lock);
  if ( (v8 & 0x8000) == 0 )
  {
    _R8 = a1[17];
    v10 = __readfsqword(0x10u);
    if ( *(_QWORD *)(_R8 + 8) == v10 )
    {
      v17 = IO_list_all;
      ++*(_DWORD *)(_R8 + 4);
      IO_list_all = a1;
      a1[13] = v17;
LABEL_17:
      v11 = (*(_DWORD *)(_R8 + 4))-- == 1;
      v9 = HIDWORD(list_all_lock);
      if ( !v11 )
        goto LABEL_25;
      *(_QWORD *)(_R8 + 8) = 0LL;
      if ( _libc_multiple_threads )
      {
        if ( !_InterlockedDecrement((volatile signed __int32 *)_R8) )
          goto LABEL_23;
        goto LABEL_22;
      }
      v11 = (*(_DWORD *)_R8)-- == 1;
      if ( !v11 )
LABEL_22:
        _lll_unlock_wake_private((u32 *)_R8, _RSI, v9, a4, (u32 *)_R8, a6);
LABEL_23:
      LODWORD(v9) = HIDWORD(list_all_lock);
      goto LABEL_25;
    }
    _RSI = 1LL;
    v11 = _libc_multiple_threads == 0;
    if ( _libc_multiple_threads )
    {
      if ( !_InterlockedCompareExchange((volatile signed __int32 *)_R8, 1, 0) )
      {
LABEL_16:
        _R8 = a1[17];
        v12 = *(_DWORD *)a1;
        *(_QWORD *)(_R8 + 8) = v10;
        v13 = IO_list_all;
        ++*(_DWORD *)(_R8 + 4);
        a1[13] = v13;
        IO_list_all = a1;
        if ( (v12 & 0x8000) != 0 )
          goto LABEL_23;
        goto LABEL_17;
      }
    }
    else
    {
      __asm { cmpxchg [r8], esi }
      if ( v11 )
        goto LABEL_16;
    }
    _lll_lock_wait_private((u32 *)_R8, 1LL, v10, a4, (u32 *)_R8, a6);
    goto LABEL_16;
  }
  v14 = IO_list_all;
  IO_list_all = a1;
  a1[13] = v14;
LABEL_25:
  run_fp = 0LL;
  v15 = (unsigned int)(v9 - 1);
  HIDWORD(list_all_lock) = v15;
  if ( !(_DWORD)v15 )
  {
    qword_4AAD38 = 0LL;
    if ( _libc_multiple_threads )
    {
      if ( !_InterlockedDecrement((volatile signed __int32 *)&list_all_lock) )
        return __readfsqword(0x28u) ^ v18;
      goto LABEL_30;
    }
    LODWORD(list_all_lock) = list_all_lock - 1;
    if ( (_DWORD)list_all_lock )
LABEL_30:
      _lll_unlock_wake_private((u32 *)&list_all_lock, _RSI, v15, a4, (u32 *)_R8, a6);
  }
  return __readfsqword(0x28u) ^ v18;
}
// 40E45D: variable 'v7' is possibly undefined
// 40E4C8: variable 'a4' is possibly undefined
// 40E4C8: variable 'a6' is possibly undefined
// 40E4DD: variable 'v10' is possibly undefined
// 40E5AD: variable '_R8' is possibly undefined
// 4A8120: using guessed type void *IO_list_all;
// 4AAD20: using guessed type __int64 run_fp;
// 4AAD30: using guessed type __int64 list_all_lock;
// 4AAD38: using guessed type __int64 qword_4AAD38;
// 4AB820: using guessed type int _libc_multiple_threads;

//----- (000000000040E630) ----------------------------------------------------
__int64 __fastcall IO_least_marker(__int64 a1, __int64 a2)
{
  __int64 **v2; // rdx
  __int64 result; // rax
  __int64 v4; // rcx

  v2 = *(__int64 ***)(a1 + 96);
  result = a2 - *(_QWORD *)(a1 + 24);
  while ( v2 )
  {
    v4 = *((int *)v2 + 4);
    v2 = (__int64 **)*v2;
    if ( result > v4 )
      result = v4;
  }
  return result;
}

//----- (000000000040E660) ----------------------------------------------------
__int64 __fastcall IO_switch_to_main_get_area(__int64 a1)
{
  __int64 v1; // rax
  __int64 v2; // rdx
  __int64 v3; // rdx
  __int64 result; // rax

  v1 = *(_QWORD *)(a1 + 16);
  v2 = *(_QWORD *)(a1 + 88);
  *(_DWORD *)a1 &= ~0x100u;
  *(_QWORD *)(a1 + 16) = v2;
  v3 = *(_QWORD *)(a1 + 24);
  *(_QWORD *)(a1 + 88) = v1;
  result = *(_QWORD *)(a1 + 72);
  *(_QWORD *)(a1 + 72) = v3;
  *(_QWORD *)(a1 + 24) = result;
  *(_QWORD *)(a1 + 8) = result;
  return result;
}

//----- (000000000040E690) ----------------------------------------------------
__int64 __fastcall IO_switch_to_backup_area(__int64 a1)
{
  __int64 v1; // rdx
  __int64 result; // rax
  __int64 v3; // rcx
  __int64 v4; // rdx

  v1 = *(_QWORD *)(a1 + 16);
  result = *(_QWORD *)(a1 + 88);
  v3 = *(_QWORD *)(a1 + 72);
  *(_DWORD *)a1 |= 0x100u;
  *(_QWORD *)(a1 + 88) = v1;
  v4 = *(_QWORD *)(a1 + 24);
  *(_QWORD *)(a1 + 16) = result;
  *(_QWORD *)(a1 + 24) = v3;
  *(_QWORD *)(a1 + 72) = v4;
  *(_QWORD *)(a1 + 8) = result;
  return result;
}

//----- (000000000040E6C0) ----------------------------------------------------
__int64 __fastcall IO_switch_to_get_mode(__int64 a1, __int64 a2, __int64 a3, __int64 a4, u32 *a5, __int64 a6)
{
  unsigned __int64 v6; // rax
  __int64 v7; // rbp
  __int64 result; // rax
  int v9; // edx

  v6 = *(_QWORD *)(a1 + 40);
  if ( v6 <= *(_QWORD *)(a1 + 32) )
  {
LABEL_6:
    v9 = *(_DWORD *)a1;
    if ( (*(_DWORD *)a1 & 0x100) != 0 )
    {
      *(_QWORD *)(a1 + 24) = *(_QWORD *)(a1 + 80);
    }
    else
    {
      *(_QWORD *)(a1 + 24) = *(_QWORD *)(a1 + 56);
      if ( *(_QWORD *)(a1 + 16) < v6 )
        *(_QWORD *)(a1 + 16) = v6;
    }
    BYTE1(v9) &= ~8u;
    *(_QWORD *)(a1 + 8) = v6;
    *(_DWORD *)a1 = v9;
    *(_QWORD *)(a1 + 48) = v6;
    *(_QWORD *)(a1 + 32) = v6;
    return 0LL;
  }
  v7 = *(_QWORD *)(a1 + 216);
  if ( (char *)&_start___libc_atexit - (char *)_start___libc_IO_vtables <= (unsigned __int64)(v7
                                                                                            - (_QWORD)_start___libc_IO_vtables) )
    IO_vtable_check(a1, v7 - (_QWORD)_start___libc_IO_vtables, (__int64)_start___libc_IO_vtables, a4, a5, a6);
  result = (*(__int64 (__fastcall **)(__int64, __int64))(v7 + 24))(a1, 0xFFFFFFFFLL);
  if ( (_DWORD)result != -1 )
  {
    v6 = *(_QWORD *)(a1 + 40);
    goto LABEL_6;
  }
  return result;
}
// 4A9C40: using guessed type u32 _start___libc_IO_vtables[48];
// 4AA2E8: using guessed type __int64 (__fastcall *_start___libc_atexit)();

//----- (000000000040E760) ----------------------------------------------------
__int64 *__fastcall IO_free_backup_area(int *a1, __int64 a2, __int64 a3, __int64 a4, u32 *a5, unsigned __int64 a6)
{
  int v6; // eax
  __int64 v8; // rdi
  __int64 v9; // rax
  __int64 *result; // rax

  v6 = *a1;
  v8 = *((_QWORD *)a1 + 9);
  if ( (v6 & 0x100) != 0 )
  {
    BYTE1(v6) &= ~1u;
    *((_QWORD *)a1 + 1) = v8;
    *a1 = v6;
    *((_QWORD *)a1 + 2) = *((_QWORD *)a1 + 11);
    v9 = *((_QWORD *)a1 + 3);
    *((_QWORD *)a1 + 3) = v8;
    v8 = v9;
  }
  result = free(v8, a2, a3, a4, a5, a6);
  *((_QWORD *)a1 + 9) = 0LL;
  *((_QWORD *)a1 + 11) = 0LL;
  *((_QWORD *)a1 + 10) = 0LL;
  return result;
}

//----- (000000000040E7B0) ----------------------------------------------------
__int64 __fastcall _overflow(__int64 a1, __int64 a2, __int64 a3, __int64 a4, u32 *a5, __int64 a6)
{
  __int64 v6; // rbx
  u32 *v7; // rdx
  __int64 v8; // rcx

  if ( !*(_DWORD *)(a1 + 192) )
    *(_DWORD *)(a1 + 192) = -1;
  v6 = *(_QWORD *)(a1 + 216);
  v7 = _start___libc_IO_vtables;
  v8 = v6 - (_QWORD)_start___libc_IO_vtables;
  if ( (char *)&_start___libc_atexit - (char *)_start___libc_IO_vtables <= (unsigned __int64)(v6
                                                                                            - (_QWORD)_start___libc_IO_vtables) )
  {
    IO_vtable_check(a1, a2, (__int64)_start___libc_IO_vtables, v8, a5, a6);
    a2 = (unsigned int)a2;
  }
  return (*(__int64 (__fastcall **)(__int64, __int64, u32 *, __int64, u32 *))(v6 + 24))(a1, a2, v7, v8, a5);
}
// 40E7F9: variable 'v7' is possibly undefined
// 40E7F9: variable 'v8' is possibly undefined
// 40E7F9: variable 'a5' is possibly undefined
// 4A9C40: using guessed type u32 _start___libc_IO_vtables[48];
// 4AA2E8: using guessed type __int64 (__fastcall *_start___libc_atexit)();

//----- (000000000040E820) ----------------------------------------------------
__int64 __fastcall _underflow(__int64 a1, __int64 a2, __int64 a3, unsigned __int64 a4, u32 *a5, unsigned __int64 a6)
{
  int v6; // eax
  unsigned __int8 *v7; // rax
  unsigned __int64 v8; // rdx
  int v9; // eax
  __int64 v10; // rbp

  v6 = *(_DWORD *)(a1 + 192);
  if ( v6 )
  {
    if ( v6 != -1 )
      return 0xFFFFFFFFLL;
  }
  else
  {
    *(_DWORD *)(a1 + 192) = -1;
  }
  if ( (*(_DWORD *)a1 & 0x800) != 0 && (unsigned int)IO_switch_to_get_mode(a1, a2, a3, a4, a5, a6) == -1 )
    return 0xFFFFFFFFLL;
  v7 = *(unsigned __int8 **)(a1 + 8);
  v8 = *(_QWORD *)(a1 + 16);
  if ( (unsigned __int64)v7 < v8 )
    return *v7;
  v9 = *(_DWORD *)a1;
  if ( (*(_DWORD *)a1 & 0x100) != 0 )
  {
    BYTE1(v9) &= ~1u;
    a4 = *(_QWORD *)(a1 + 88);
    *(_QWORD *)(a1 + 88) = v8;
    *(_DWORD *)a1 = v9;
    v8 = *(_QWORD *)(a1 + 24);
    v7 = *(unsigned __int8 **)(a1 + 72);
    *(_QWORD *)(a1 + 16) = a4;
    *(_QWORD *)(a1 + 72) = v8;
    *(_QWORD *)(a1 + 24) = v7;
    *(_QWORD *)(a1 + 8) = v7;
    if ( a4 > (unsigned __int64)v7 )
      return *v7;
  }
  if ( *(_QWORD *)(a1 + 96) )
  {
    if ( (unsigned int)save_for_backup((_QWORD *)a1, *(_QWORD *)(a1 + 16), v8, a4, (__int64)a5, a6) )
      return 0xFFFFFFFFLL;
  }
  else if ( *(_QWORD *)(a1 + 72) )
  {
    IO_free_backup_area((int *)a1, a2, v8, a4, a5, a6);
  }
  v10 = *(_QWORD *)(a1 + 216);
  if ( (char *)&_start___libc_atexit - (char *)_start___libc_IO_vtables <= (unsigned __int64)(v10
                                                                                            - (_QWORD)_start___libc_IO_vtables) )
    IO_vtable_check(a1, v10 - (_QWORD)_start___libc_IO_vtables, (__int64)_start___libc_IO_vtables, a4, a5, a6);
  return (*(__int64 (__fastcall **)(__int64))(v10 + 32))(a1);
}
// 40E8A1: variable 'a4' is possibly undefined
// 40E8A1: variable 'a5' is possibly undefined
// 40E8A1: variable 'a6' is possibly undefined
// 4A9C40: using guessed type u32 _start___libc_IO_vtables[48];
// 4AA2E8: using guessed type __int64 (__fastcall *_start___libc_atexit)();

//----- (000000000040E940) ----------------------------------------------------
__int64 __fastcall _uflow(__int64 a1, __int64 a2, __int64 a3, unsigned __int64 a4, u32 *a5, unsigned __int64 a6)
{
  int v6; // eax
  unsigned __int8 *v7; // rax
  unsigned __int64 v8; // rdx
  int v9; // eax
  __int64 v10; // rbp

  v6 = *(_DWORD *)(a1 + 192);
  if ( v6 )
  {
    if ( v6 != -1 )
      return 0xFFFFFFFFLL;
  }
  else
  {
    *(_DWORD *)(a1 + 192) = -1;
  }
  if ( (*(_DWORD *)a1 & 0x800) != 0 && (unsigned int)IO_switch_to_get_mode(a1, a2, a3, a4, a5, a6) == -1 )
    return 0xFFFFFFFFLL;
  v7 = *(unsigned __int8 **)(a1 + 8);
  v8 = *(_QWORD *)(a1 + 16);
  if ( (unsigned __int64)v7 < v8 )
    goto LABEL_17;
  v9 = *(_DWORD *)a1;
  if ( (*(_DWORD *)a1 & 0x100) == 0 )
    goto LABEL_8;
  BYTE1(v9) &= ~1u;
  a4 = *(_QWORD *)(a1 + 88);
  *(_QWORD *)(a1 + 88) = v8;
  *(_DWORD *)a1 = v9;
  v8 = *(_QWORD *)(a1 + 24);
  v7 = *(unsigned __int8 **)(a1 + 72);
  *(_QWORD *)(a1 + 16) = a4;
  *(_QWORD *)(a1 + 72) = v8;
  *(_QWORD *)(a1 + 24) = v7;
  if ( a4 > (unsigned __int64)v7 )
  {
LABEL_17:
    *(_QWORD *)(a1 + 8) = v7 + 1;
    return *v7;
  }
  *(_QWORD *)(a1 + 8) = v7;
LABEL_8:
  if ( *(_QWORD *)(a1 + 96) )
  {
    if ( (unsigned int)save_for_backup((_QWORD *)a1, *(_QWORD *)(a1 + 16), v8, a4, (__int64)a5, a6) )
      return 0xFFFFFFFFLL;
  }
  else if ( *(_QWORD *)(a1 + 72) )
  {
    IO_free_backup_area((int *)a1, a2, v8, a4, a5, a6);
  }
  v10 = *(_QWORD *)(a1 + 216);
  if ( (char *)&_start___libc_atexit - (char *)_start___libc_IO_vtables <= (unsigned __int64)(v10
                                                                                            - (_QWORD)_start___libc_IO_vtables) )
    IO_vtable_check(a1, v10 - (_QWORD)_start___libc_IO_vtables, (__int64)_start___libc_IO_vtables, a4, a5, a6);
  return (*(__int64 (__fastcall **)(__int64))(v10 + 40))(a1);
}
// 40E9C1: variable 'a4' is possibly undefined
// 40E9C1: variable 'a5' is possibly undefined
// 40E9C1: variable 'a6' is possibly undefined
// 4A9C40: using guessed type u32 _start___libc_IO_vtables[48];
// 4AA2E8: using guessed type __int64 (__fastcall *_start___libc_atexit)();

//----- (000000000040EA60) ----------------------------------------------------
__int64 __fastcall IO_setb(int *a1, __int64 a2, __int64 a3, __int64 a4, u32 *a5, unsigned __int64 a6)
{
  __int64 v7; // rdi
  int v8; // eax
  int v9; // edx
  __int64 result; // rax
  unsigned int v11; // edx
  __int64 v12; // [rsp+10h] [rbp-18h]
  int v13; // [rsp+1Ch] [rbp-Ch]

  v7 = *((_QWORD *)a1 + 7);
  v8 = *a1;
  if ( v7 && (v8 & 1) == 0 )
  {
    v13 = a4;
    v12 = a3;
    free(v7, a2, a3, a4, a5, a6);
    v8 = *a1;
    LODWORD(a4) = v13;
    a3 = v12;
  }
  *((_QWORD *)a1 + 8) = a3;
  v9 = v8;
  result = v8 | 1u;
  v11 = v9 & 0xFFFFFFFE;
  *((_QWORD *)a1 + 7) = a2;
  if ( (_DWORD)a4 )
    result = v11;
  *a1 = result;
  return result;
}

//----- (000000000040EAD0) ----------------------------------------------------
void __fastcall IO_doallocbuf(__int64 a1, __int64 a2, __int64 a3, __int64 a4, u32 *a5, __int64 a6)
{
  int v6; // eax
  __int64 v8; // rbp
  u32 *v9; // rdx
  __int64 v10; // rcx
  __int64 v11; // rdx
  __int64 v12; // rcx
  u32 *v13; // r8
  unsigned __int64 v14; // r9
  __int64 v15; // rdi
  __int64 v16; // r12
  __int64 v17; // rbp

  if ( !*(_QWORD *)(a1 + 56) )
  {
    v6 = *(_DWORD *)a1;
    if ( (*(_DWORD *)a1 & 2) != 0 && *(int *)(a1 + 192) <= 0 )
    {
      v16 = a1 + 132;
      v17 = a1 + 131;
LABEL_10:
      *(_QWORD *)(a1 + 56) = v17;
      *(_QWORD *)(a1 + 64) = v16;
      *(_DWORD *)a1 = v6 | 1;
      return;
    }
    v8 = *(_QWORD *)(a1 + 216);
    v9 = _start___libc_IO_vtables;
    v10 = v8 - (_QWORD)_start___libc_IO_vtables;
    if ( (char *)&_start___libc_atexit - (char *)_start___libc_IO_vtables <= (unsigned __int64)(v8
                                                                                              - (_QWORD)_start___libc_IO_vtables) )
      IO_vtable_check(a1, a2, (__int64)_start___libc_IO_vtables, v10, a5, a6);
    if ( (*(unsigned int (__fastcall **)(__int64, __int64, u32 *, __int64, u32 *))(v8 + 104))(a1, a2, v9, v10, a5) == -1 )
    {
      v15 = *(_QWORD *)(a1 + 56);
      v16 = a1 + 132;
      v17 = a1 + 131;
      v6 = *(_DWORD *)a1;
      if ( v15 )
      {
        if ( (v6 & 1) == 0 )
        {
          free(v15, a2, v11, v12, v13, v14);
          v6 = *(_DWORD *)a1;
        }
      }
      goto LABEL_10;
    }
  }
}
// 40EB1D: variable 'v9' is possibly undefined
// 40EB1D: variable 'v10' is possibly undefined
// 40EB1D: variable 'a5' is possibly undefined
// 40EB70: variable 'v11' is possibly undefined
// 40EB70: variable 'v12' is possibly undefined
// 40EB70: variable 'v13' is possibly undefined
// 40EB70: variable 'v14' is possibly undefined
// 4A9C40: using guessed type u32 _start___libc_IO_vtables[48];
// 4AA2E8: using guessed type __int64 (__fastcall *_start___libc_atexit)();

//----- (000000000040EB90) ----------------------------------------------------
__int64 IO_default_underflow()
{
  return 0xFFFFFFFFLL;
}
// 40EB90: using guessed type __int64 __fastcall IO_default_underflow();

//----- (000000000040EBA0) ----------------------------------------------------
__int64 __fastcall IO_default_uflow(__int64 a1, __int64 a2, __int64 a3, __int64 a4, u32 *a5, __int64 a6)
{
  __int64 v6; // rbp
  u32 *v7; // rdx
  __int64 v8; // rcx
  __int64 result; // rax
  unsigned __int8 *v10; // rax

  v6 = *(_QWORD *)(a1 + 216);
  v7 = _start___libc_IO_vtables;
  v8 = v6 - (_QWORD)_start___libc_IO_vtables;
  if ( (char *)&_start___libc_atexit - (char *)_start___libc_IO_vtables <= (unsigned __int64)(v6
                                                                                            - (_QWORD)_start___libc_IO_vtables) )
    IO_vtable_check(a1, a2, (__int64)_start___libc_IO_vtables, v8, a5, a6);
  result = (*(__int64 (__fastcall **)(__int64, __int64, u32 *, __int64, u32 *))(v6 + 32))(a1, a2, v7, v8, a5);
  if ( (_DWORD)result != -1 )
  {
    v10 = *(unsigned __int8 **)(a1 + 8);
    *(_QWORD *)(a1 + 8) = v10 + 1;
    return *v10;
  }
  return result;
}
// 40EBD3: variable 'v7' is possibly undefined
// 40EBD3: variable 'v8' is possibly undefined
// 40EBD3: variable 'a5' is possibly undefined
// 4A9C40: using guessed type u32 _start___libc_IO_vtables[48];
// 4AA2E8: using guessed type __int64 (__fastcall *_start___libc_atexit)();

//----- (000000000040EC00) ----------------------------------------------------
unsigned __int64 __fastcall IO_default_xsputn(
        _QWORD *a1,
        __int64 a2,
        unsigned __int64 a3,
        __int64 a4,
        u32 *a5,
        __int64 a6)
{
  unsigned __int64 v7; // r13
  unsigned __int8 *v8; // r12
  unsigned __int64 i; // rbp
  __int64 v10; // rbx
  unsigned __int64 v11; // rdi
  unsigned __int64 v12; // rbx
  unsigned __int64 v13; // rbx
  __int64 j; // rax

  if ( !a3 )
    return 0LL;
  v7 = a3;
  v8 = (unsigned __int8 *)a2;
  for ( i = a3; ; --i )
  {
    v11 = a1[5];
    v12 = a1[6];
    if ( v11 < v12 )
    {
      v13 = v12 - v11;
      if ( i <= v13 )
        v13 = i;
      if ( v13 <= 0x14 )
      {
        if ( v13 )
        {
          for ( j = 0LL; j != v13; ++j )
            *(_BYTE *)(v11 + j) = v8[j];
          v11 += v13;
          v8 += v13;
          a1[5] = v11;
        }
      }
      else
      {
        a2 = (__int64)v8;
        v8 += v13;
        a1[5] = j_mempcpy(v11, a2, v13);
      }
      i -= v13;
    }
    if ( !i )
      break;
    v10 = a1[27];
    if ( (char *)&_start___libc_atexit - (char *)_start___libc_IO_vtables <= (unsigned __int64)(v10
                                                                                              - (_QWORD)_start___libc_IO_vtables) )
      IO_vtable_check(v11, a2, (__int64)_start___libc_IO_vtables, v10 - (_QWORD)_start___libc_IO_vtables, a5, a6);
    a2 = *v8;
    if ( (*(unsigned int (__fastcall **)(_QWORD *, __int64))(v10 + 24))(a1, a2) == -1 )
    {
      v7 -= i;
      return v7;
    }
    ++v8;
  }
  return v7;
}
// 40ECD0: variable 'a5' is possibly undefined
// 40ECD0: variable 'a6' is possibly undefined
// 4010B0: using guessed type __int64 __fastcall j_mempcpy(_QWORD, _QWORD, _QWORD);
// 4A9C40: using guessed type u32 _start___libc_IO_vtables[48];
// 4AA2E8: using guessed type __int64 (__fastcall *_start___libc_atexit)();

//----- (000000000040ED20) ----------------------------------------------------
__int64 __fastcall IO_sgetn(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // rbx

  v6 = *(_QWORD *)(a1 + 216);
  if ( (char *)&_start___libc_atexit - (char *)_start___libc_IO_vtables <= (unsigned __int64)(v6
                                                                                            - (_QWORD)_start___libc_IO_vtables) )
    IO_vtable_check(a1, a2, a3, (__int64)_start___libc_IO_vtables, (u32 *)(v6 - (_QWORD)_start___libc_IO_vtables), a6);
  return (*(__int64 (**)(void))(v6 + 64))();
}
// 4A9C40: using guessed type u32 _start___libc_IO_vtables[48];
// 4AA2E8: using guessed type __int64 (__fastcall *_start___libc_atexit)();

//----- (000000000040ED90) ----------------------------------------------------
__int64 __fastcall IO_default_xsgetn(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        unsigned __int64 a4,
        u32 *a5,
        unsigned __int64 a6)
{
  unsigned __int64 v6; // r14
  __int64 v8; // r12
  unsigned __int64 v10; // rsi
  unsigned __int64 v11; // rax
  unsigned __int64 v12; // rax
  unsigned __int64 v13; // rbx
  __int64 v14; // rax
  __int64 v16; // rax
  unsigned __int64 v17; // rdi

  v6 = a3;
  v8 = a3;
  while ( 1 )
  {
    v10 = *(_QWORD *)(a1 + 8);
    v11 = *(_QWORD *)(a1 + 16);
    if ( v10 < v11 )
    {
      v12 = v11 - v10;
      if ( v6 <= v12 )
        v12 = v6;
      v13 = v12;
      if ( v12 <= 0x14 )
      {
        if ( v12 )
        {
          a4 = (unsigned int)(v12 - 1);
          v16 = 0LL;
          v17 = a4 + 1;
          while ( 1 )
          {
            *(_BYTE *)(a2 + v16) = *(_BYTE *)(v10 + v16);
            a3 = v16 + 1;
            if ( a4 == v16 )
              break;
            ++v16;
          }
          v10 += v17;
          a2 += v17;
          *(_QWORD *)(a1 + 8) = v10;
        }
      }
      else
      {
        v14 = j_mempcpy(a2, v10, v12);
        *(_QWORD *)(a1 + 8) += v13;
        a2 = v14;
      }
      v6 -= v13;
    }
    if ( !v6 )
      break;
    if ( (unsigned int)_underflow(a1, v10, a3, a4, a5, a6) == -1 )
    {
      v8 -= v6;
      return v8;
    }
  }
  return v8;
}
// 40EDC0: variable 'a3' is possibly undefined
// 40EDC0: variable 'a4' is possibly undefined
// 40EDC0: variable 'a5' is possibly undefined
// 40EDC0: variable 'a6' is possibly undefined
// 4010B0: using guessed type __int64 __fastcall j_mempcpy(_QWORD, _QWORD, _QWORD);

//----- (000000000040EE50) ----------------------------------------------------
__int64 __fastcall IO_default_setbuf(__int64 a1, __int64 a2, __int64 a3, __int64 a4, u32 *a5, __int64 a6)
{
  __int64 v8; // r12
  u32 *v9; // rdx
  __int64 v10; // rcx
  __int64 v11; // rcx
  u32 *v12; // r8
  unsigned __int64 v13; // r9
  int v14; // eax
  __int64 v15; // rdi
  int v16; // edx
  __int64 v17; // rdx
  __int64 v18; // rbp
  __int64 result; // rax
  __int64 v20; // rdx

  v8 = *(_QWORD *)(a1 + 216);
  v9 = _start___libc_IO_vtables;
  v10 = v8 - (_QWORD)_start___libc_IO_vtables;
  if ( (char *)&_start___libc_atexit - (char *)_start___libc_IO_vtables <= (unsigned __int64)(v8
                                                                                            - (_QWORD)_start___libc_IO_vtables) )
    IO_vtable_check(a1, a2, (__int64)_start___libc_IO_vtables, v10, a5, a6);
  if ( (*(unsigned int (__fastcall **)(__int64, __int64, u32 *, __int64, u32 *))(v8 + 96))(a1, a2, v9, v10, a5) == -1 )
    return 0LL;
  v14 = *(_DWORD *)a1;
  v15 = *(_QWORD *)(a1 + 56);
  v16 = *(_DWORD *)a1;
  if ( a2 && a3 )
  {
    v17 = v16 & 0xFFFFFFFD;
    v18 = a2 + a3;
    *(_DWORD *)a1 = v17;
    if ( v15 )
    {
      if ( (v14 & 1) == 0 )
      {
        free(v15, a2, v17, v11, v12, v13);
        LODWORD(v17) = *(_DWORD *)a1;
      }
    }
    *(_QWORD *)(a1 + 56) = a2;
    *(_QWORD *)(a1 + 64) = v18;
    *(_DWORD *)a1 = v17 | 1;
  }
  else
  {
    v20 = v16 | 2u;
    *(_DWORD *)a1 = v20;
    if ( v15 && (v14 & 1) == 0 )
    {
      free(v15, a2, v20, v11, v12, v13);
      LODWORD(v20) = *(_DWORD *)a1;
    }
    *(_QWORD *)(a1 + 56) = a1 + 131;
    *(_QWORD *)(a1 + 64) = a1 + 132;
    *(_DWORD *)a1 = v20 | 1;
  }
  *(_QWORD *)(a1 + 48) = 0LL;
  result = a1;
  *(_QWORD *)(a1 + 40) = 0LL;
  *(_QWORD *)(a1 + 32) = 0LL;
  *(_QWORD *)(a1 + 16) = 0LL;
  *(_QWORD *)(a1 + 8) = 0LL;
  *(_QWORD *)(a1 + 24) = 0LL;
  return result;
}
// 40EE91: variable 'v9' is possibly undefined
// 40EE91: variable 'v10' is possibly undefined
// 40EE91: variable 'a5' is possibly undefined
// 40EF40: variable 'v11' is possibly undefined
// 40EF40: variable 'v12' is possibly undefined
// 40EF40: variable 'v13' is possibly undefined
// 4A9C40: using guessed type u32 _start___libc_IO_vtables[48];
// 4AA2E8: using guessed type __int64 (__fastcall *_start___libc_atexit)();

//----- (000000000040EF80) ----------------------------------------------------
__int64 __fastcall IO_default_seekpos(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // rbx
  int v8; // [rsp+1Ch] [rbp-Ch]

  v6 = *(_QWORD *)(a1 + 216);
  if ( (char *)&_start___libc_atexit - (char *)_start___libc_IO_vtables <= (unsigned __int64)(v6
                                                                                            - (_QWORD)_start___libc_IO_vtables) )
  {
    v8 = a3;
    IO_vtable_check(a1, a2, a3, v6 - (_QWORD)_start___libc_IO_vtables, _start___libc_IO_vtables, a6);
    LODWORD(a3) = v8;
  }
  return (*(__int64 (__fastcall **)(__int64, __int64, _QWORD, _QWORD))(v6 + 72))(a1, a2, 0LL, (unsigned int)a3);
}
// 4A9C40: using guessed type u32 _start___libc_IO_vtables[48];
// 4AA2E8: using guessed type __int64 (__fastcall *_start___libc_atexit)();

//----- (000000000040EFF0) ----------------------------------------------------
__int64 __fastcall IO_default_doallocate(unsigned int *a1, __int64 a2, _QWORD *a3, __int64 a4, u32 *a5, __int64 a6)
{
  __int64 v7; // rcx
  _QWORD *v8; // rbp
  u32 *v9; // r8
  unsigned __int64 v10; // r9
  __int64 result; // rax
  __int64 v12; // rdi
  __int64 v13; // rdx

  v8 = malloc(0x2000uLL, a2, a3, a4, a5, a6);
  result = 0xFFFFFFFFLL;
  if ( v8 )
  {
    v12 = *((_QWORD *)a1 + 7);
    v13 = *a1;
    if ( v12 )
    {
      if ( (v13 & 1) == 0 )
      {
        free(v12, a2, v13, v7, v9, v10);
        LODWORD(v13) = *a1;
      }
    }
    *((_QWORD *)a1 + 7) = v8;
    result = 1LL;
    *((_QWORD *)a1 + 8) = v8 + 1024;
    *a1 = v13 & 0xFFFFFFFE;
  }
  return result;
}
// 40F040: variable 'v7' is possibly undefined
// 40F040: variable 'v9' is possibly undefined
// 40F040: variable 'v10' is possibly undefined

//----- (000000000040F050) ----------------------------------------------------
unsigned __int64 IO_enable_locks()
{
  unsigned __int64 result; // rax

  result = (unsigned int)stdio_needs_locking;
  if ( !stdio_needs_locking )
  {
    result = (unsigned __int64)IO_list_all;
    stdio_needs_locking = 1;
    if ( IO_list_all )
    {
      do
      {
        *(_DWORD *)(result + 116) |= 0x80u;
        result = *(_QWORD *)(result + 104);
      }
      while ( result );
    }
  }
  return result;
}
// 4A8120: using guessed type void *IO_list_all;
// 4AAD1C: using guessed type int stdio_needs_locking;

//----- (000000000040F090) ----------------------------------------------------
_QWORD *__fastcall IO_old_init(__int64 a1, int a2)
{
  int v2; // edx
  _QWORD *result; // rax

  v2 = stdio_needs_locking;
  *(_DWORD *)(a1 + 116) = 0;
  *(_DWORD *)a1 = a2 | 0xFBAD0000;
  if ( v2 )
    *(_DWORD *)(a1 + 116) = 128;
  *(_QWORD *)(a1 + 56) = 0LL;
  *(_WORD *)(a1 + 128) = 0;
  result = *(_QWORD **)(a1 + 136);
  *(_QWORD *)(a1 + 64) = 0LL;
  *(_QWORD *)(a1 + 24) = 0LL;
  *(_QWORD *)(a1 + 8) = 0LL;
  *(_QWORD *)(a1 + 16) = 0LL;
  *(_QWORD *)(a1 + 32) = 0LL;
  *(_QWORD *)(a1 + 40) = 0LL;
  *(_QWORD *)(a1 + 48) = 0LL;
  *(_QWORD *)(a1 + 104) = 0LL;
  *(_QWORD *)(a1 + 72) = 0LL;
  *(_QWORD *)(a1 + 80) = 0LL;
  *(_QWORD *)(a1 + 88) = 0LL;
  *(_QWORD *)(a1 + 96) = 0LL;
  if ( result )
  {
    *result = 0LL;
    result[1] = 0LL;
  }
  return result;
}
// 4AAD1C: using guessed type int stdio_needs_locking;

//----- (000000000040F150) ----------------------------------------------------
_QWORD *__fastcall IO_init_internal(__int64 a1, int a2)
{
  _QWORD *result; // rax

  result = IO_old_init(a1, a2);
  *(_DWORD *)(a1 + 192) = -1;
  *(_QWORD *)(a1 + 160) = -1LL;
  *(_QWORD *)(a1 + 168) = 0LL;
  return result;
}

//----- (000000000040F180) ----------------------------------------------------
_QWORD *__fastcall IO_init(__int64 a1, int a2)
{
  _QWORD *result; // rax

  result = IO_old_init(a1, a2);
  *(_DWORD *)(a1 + 192) = -1;
  *(_QWORD *)(a1 + 160) = -1LL;
  *(_QWORD *)(a1 + 168) = 0LL;
  return result;
}

//----- (000000000040F1B0) ----------------------------------------------------
_QWORD *__fastcall IO_no_init(__int64 a1, int a2)
{
  _QWORD *result; // rax
  _QWORD *v3; // rcx
  __int64 v4; // r8
  __int64 v5; // r9
  int v6; // er10

  result = IO_old_init(a1, a2);
  *(_DWORD *)(a1 + 192) = v6;
  if ( v6 < 0 )
  {
    *(_QWORD *)(a1 + 160) = -1LL;
  }
  else
  {
    *(_QWORD *)(a1 + 160) = v3;
    v3[6] = 0LL;
    v3[7] = 0LL;
    v3[2] = 0LL;
    *v3 = 0LL;
    v3[1] = 0LL;
    v3[3] = 0LL;
    v3[4] = 0LL;
    v3[5] = 0LL;
    v3[8] = 0LL;
    v3[9] = 0LL;
    v3[10] = 0LL;
    v3[38] = v4;
  }
  *(_QWORD *)(v5 + 168) = 0LL;
  return result;
}
// 40F1BF: variable 'v6' is possibly undefined
// 40F1CB: variable 'v3' is possibly undefined
// 40F229: variable 'v4' is possibly undefined
// 40F230: variable 'v5' is possibly undefined

//----- (000000000040F260) ----------------------------------------------------
__int64 IO_default_sync()
{
  return 0LL;
}
// 40F260: using guessed type __int64 __fastcall IO_default_sync();

//----- (000000000040F270) ----------------------------------------------------
__int64 *__fastcall IO_default_finish(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        unsigned int *a4,
        u32 *a5,
        unsigned __int64 a6)
{
  __int64 v7; // rdi
  __int64 *result; // rax
  __int64 v9; // rdi

  v7 = *(_QWORD *)(a1 + 56);
  if ( v7 && (*(_BYTE *)a1 & 1) == 0 )
  {
    free(v7, a2, a3, (__int64)a4, a5, a6);
    *(_QWORD *)(a1 + 64) = 0LL;
    *(_QWORD *)(a1 + 56) = 0LL;
  }
  for ( result = *(__int64 **)(a1 + 96); result; result = (__int64 *)*result )
    result[1] = 0LL;
  v9 = *(_QWORD *)(a1 + 72);
  if ( v9 )
  {
    result = free(v9, a2, a3, (__int64)a4, a5, a6);
    *(_QWORD *)(a1 + 72) = 0LL;
  }
  if ( *(char *)a1 < 0 )
    return (__int64 *)IO_un_link_part_2((unsigned int *)a1, a2, a3, a4, a5, a6);
  return result;
}
// 40F2A9: variable 'a3' is possibly undefined
// 40F2A9: variable 'a4' is possibly undefined
// 40F2A9: variable 'a5' is possibly undefined
// 40F2A9: variable 'a6' is possibly undefined

//----- (000000000040F2F0) ----------------------------------------------------
__int64 IO_default_seekoff()
{
  return -1LL;
}
// 40F2F0: using guessed type __int64 __fastcall IO_default_seekoff();

//----- (000000000040F300) ----------------------------------------------------
__int64 __fastcall IO_sputbackc(__int64 a1, __int64 a2, __int64 a3, __int64 a4, u32 *a5, __int64 a6)
{
  unsigned __int64 v6; // rax
  __int64 v7; // rbp
  u32 *v8; // rdx
  __int64 v9; // rcx
  __int64 result; // rax

  v6 = *(_QWORD *)(a1 + 8);
  if ( v6 > *(_QWORD *)(a1 + 24) && *(_BYTE *)(v6 - 1) == (_BYTE)a2 )
  {
    *(_QWORD *)(a1 + 8) = v6 - 1;
    result = (unsigned __int8)a2;
LABEL_6:
    *(_DWORD *)a1 &= ~0x10u;
    return result;
  }
  v7 = *(_QWORD *)(a1 + 216);
  v8 = _start___libc_IO_vtables;
  v9 = v7 - (_QWORD)_start___libc_IO_vtables;
  if ( (char *)&_start___libc_atexit - (char *)_start___libc_IO_vtables <= (unsigned __int64)(v7
                                                                                            - (_QWORD)_start___libc_IO_vtables) )
  {
    IO_vtable_check(a1, a2, (__int64)_start___libc_IO_vtables, v9, a5, a6);
    a2 = (unsigned int)a2;
  }
  result = (*(__int64 (__fastcall **)(__int64, __int64, u32 *, __int64, u32 *))(v7 + 48))(a1, a2, v8, v9, a5);
  if ( (_DWORD)result != -1 )
    goto LABEL_6;
  return result;
}
// 40F343: variable 'v8' is possibly undefined
// 40F343: variable 'v9' is possibly undefined
// 40F343: variable 'a5' is possibly undefined
// 4A9C40: using guessed type u32 _start___libc_IO_vtables[48];
// 4AA2E8: using guessed type __int64 (__fastcall *_start___libc_atexit)();

//----- (000000000040F380) ----------------------------------------------------
__int64 __fastcall IO_sungetc(__int64 a1, __int64 a2, __int64 a3, __int64 a4, u32 *a5, __int64 a6)
{
  unsigned __int64 v6; // rax
  __int64 result; // rax
  __int64 v8; // rbp
  u32 *v9; // rdx
  __int64 v10; // rcx

  v6 = *(_QWORD *)(a1 + 8);
  if ( v6 > *(_QWORD *)(a1 + 24) )
  {
    *(_QWORD *)(a1 + 8) = v6 - 1;
    result = *(unsigned __int8 *)(v6 - 1);
LABEL_3:
    *(_DWORD *)a1 &= ~0x10u;
    return result;
  }
  v8 = *(_QWORD *)(a1 + 216);
  v9 = _start___libc_IO_vtables;
  v10 = v8 - (_QWORD)_start___libc_IO_vtables;
  if ( (char *)&_start___libc_atexit - (char *)_start___libc_IO_vtables <= (unsigned __int64)(v8
                                                                                            - (_QWORD)_start___libc_IO_vtables) )
    IO_vtable_check(a1, a2, (__int64)_start___libc_IO_vtables, v10, a5, a6);
  result = (*(__int64 (__fastcall **)(__int64, __int64, u32 *, __int64, u32 *))(v8 + 48))(a1, 0xFFFFFFFFLL, v9, v10, a5);
  if ( (_DWORD)result != -1 )
    goto LABEL_3;
  return result;
}
// 40F3DB: variable 'v9' is possibly undefined
// 40F3DB: variable 'v10' is possibly undefined
// 40F3DB: variable 'a5' is possibly undefined
// 4A9C40: using guessed type u32 _start___libc_IO_vtables[48];
// 4AA2E8: using guessed type __int64 (__fastcall *_start___libc_atexit)();

//----- (000000000040F400) ----------------------------------------------------
__int64 __fastcall IO_adjust_column(int a1, unsigned __int64 a2, int a3)
{
  unsigned __int64 v3; // r8
  unsigned __int64 v4; // rcx

  v3 = a2 + a3;
  if ( a2 < v3 )
  {
    v4 = v3 - 1;
    if ( *(_BYTE *)(v3 - 1) == 10 )
      return 0LL;
    while ( a2 != v4 )
    {
      if ( *(_BYTE *)--v4 == 10 )
        return (unsigned int)(v3 - v4 - 1);
    }
  }
  return (unsigned int)(a3 + a1);
}

//----- (000000000040F450) ----------------------------------------------------
__int64 __fastcall IO_flush_all_lockp(__int64 *a1, unsigned __int64 _RSI, __int64 a3, __int64 a4, u32 *a5, __int64 a6)
{
  int v6; // er14
  __int64 v7; // rdx
  int v8; // eax
  int *v9; // rbx
  unsigned int v10; // ebp
  unsigned __int64 v12; // r12
  __int64 v13; // rax
  __int64 v14; // r15
  bool v15; // zf

  v6 = (int)a1;
  v7 = __readfsqword(0x10u);
  if ( qword_4AAD38 == v7 )
    goto LABEL_8;
  _RSI = 1LL;
  if ( _libc_multiple_threads )
  {
    if ( !_InterlockedCompareExchange((volatile signed __int32 *)&list_all_lock, 1, 0) )
      goto LABEL_7;
    goto LABEL_6;
  }
  __asm { cmpxchg dword ptr cs:list_all_lock, esi }
  if ( _libc_multiple_threads )
  {
LABEL_6:
    a1 = &list_all_lock;
    _lll_lock_wait_private((u32 *)&list_all_lock, 1LL, v7, a4, a5, a6);
  }
LABEL_7:
  qword_4AAD38 = v7;
LABEL_8:
  v8 = HIDWORD(list_all_lock);
  v9 = (int *)IO_list_all;
  v10 = 0;
  _RDX = (unsigned int)++HIDWORD(list_all_lock);
  if ( !IO_list_all )
    goto LABEL_38;
  v12 = __readfsqword(0x10u);
  do
  {
    run_fp = (__int64)v9;
    if ( v6 && (*v9 & 0x8000) == 0 )
    {
      _RDX = *((_QWORD *)v9 + 17);
      if ( *(_QWORD *)(_RDX + 8) == v12 )
      {
LABEL_33:
        ++*(_DWORD *)(_RDX + 4);
        goto LABEL_34;
      }
      _RSI = 1LL;
      v15 = _libc_multiple_threads == 0;
      if ( _libc_multiple_threads )
      {
        if ( !_InterlockedCompareExchange((volatile signed __int32 *)_RDX, 1, 0) )
          goto LABEL_32;
      }
      else
      {
        __asm { cmpxchg [rdx], esi }
        if ( v15 )
        {
LABEL_32:
          _RDX = *((_QWORD *)v9 + 17);
          *(_QWORD *)(_RDX + 8) = v12;
          goto LABEL_33;
        }
      }
      a1 = (__int64 *)_RDX;
      _lll_lock_wait_private((u32 *)_RDX, 1LL, _RDX, a4, a5, a6);
      goto LABEL_32;
    }
LABEL_34:
    if ( v9[48] > 0 )
    {
      v13 = *((_QWORD *)v9 + 20);
      _RSI = *(_QWORD *)(v13 + 24);
      if ( *(_QWORD *)(v13 + 32) <= _RSI )
        goto LABEL_15;
    }
    else if ( *((_QWORD *)v9 + 5) <= *((_QWORD *)v9 + 4) )
    {
      goto LABEL_15;
    }
    v14 = *((_QWORD *)v9 + 27);
    if ( (char *)&_start___libc_atexit - (char *)_start___libc_IO_vtables <= (unsigned __int64)(v14
                                                                                              - (_QWORD)_start___libc_IO_vtables) )
      IO_vtable_check(
        (__int64)a1,
        _RSI,
        (__int64)_start___libc_IO_vtables,
        v14 - (_QWORD)_start___libc_IO_vtables,
        a5,
        a6);
    _RSI = 0xFFFFFFFFLL;
    a1 = (__int64 *)v9;
    if ( (*(unsigned int (__fastcall **)(int *, __int64))(v14 + 24))(v9, 0xFFFFFFFFLL) == -1 )
      v10 = -1;
LABEL_15:
    if ( v6 )
    {
      if ( (*v9 & 0x8000) == 0 )
      {
        _RDX = *((_QWORD *)v9 + 17);
        v15 = (*(_DWORD *)(_RDX + 4))-- == 1;
        if ( v15 )
        {
          *(_QWORD *)(_RDX + 8) = 0LL;
          if ( !_libc_multiple_threads )
          {
            v15 = (*(_DWORD *)_RDX)-- == 1;
            if ( v15 )
              goto LABEL_23;
LABEL_22:
            a1 = (__int64 *)_RDX;
            _lll_unlock_wake_private((u32 *)_RDX, _RSI, _RDX, a4, a5, a6);
            goto LABEL_23;
          }
          if ( _InterlockedDecrement((volatile signed __int32 *)_RDX) )
            goto LABEL_22;
        }
      }
    }
LABEL_23:
    run_fp = 0LL;
    v9 = (int *)*((_QWORD *)v9 + 13);
  }
  while ( v9 );
  v8 = HIDWORD(list_all_lock) - 1;
LABEL_38:
  HIDWORD(list_all_lock) = v8;
  if ( !v8 )
  {
    qword_4AAD38 = 0LL;
    if ( _libc_multiple_threads )
    {
      if ( !_InterlockedDecrement((volatile signed __int32 *)&list_all_lock) )
        return v10;
LABEL_43:
      _lll_unlock_wake_private((u32 *)&list_all_lock, _RSI, _RDX, a4, a5, a6);
    }
    else
    {
      LODWORD(list_all_lock) = list_all_lock - 1;
      if ( (_DWORD)list_all_lock )
        goto LABEL_43;
    }
  }
  return v10;
}
// 40F4E7: variable 'v7' is possibly undefined
// 40F708: variable 'a5' is possibly undefined
// 40F708: variable 'a6' is possibly undefined
// 40F5AF: variable 'a4' is possibly undefined
// 40F6A8: variable '_RDX' is possibly undefined
// 4A8120: using guessed type void *IO_list_all;
// 4A9C40: using guessed type u32 _start___libc_IO_vtables[48];
// 4AA2E8: using guessed type __int64 (__fastcall *_start___libc_atexit)();
// 4AAD20: using guessed type __int64 run_fp;
// 4AAD30: using guessed type __int64 list_all_lock;
// 4AAD38: using guessed type __int64 qword_4AAD38;
// 4AB820: using guessed type int _libc_multiple_threads;

//----- (000000000040F720) ----------------------------------------------------
__int64 __fastcall IO_cleanup(__int64 a1, __int64 _RSI, __int64 a3, __int64 a4, u32 *a5, __int64 a6)
{
  __int64 *v6; // rdi
  __int64 v7; // rcx
  u32 *v8; // r8
  unsigned __int64 v9; // r9
  unsigned int v10; // er13
  __int64 v11; // rdx
  int v12; // eax
  __int64 *v13; // rbx
  __int64 v14; // rdx
  unsigned __int64 v15; // r14
  int v16; // ebp
  signed __int32 v18; // eax
  __int64 v20; // r15
  bool v21; // zf
  __int64 v23; // rax
  __int64 v24; // rax

  v6 = 0LL;
  v10 = IO_flush_all_lockp(0LL, _RSI, a3, a4, a5, a6);
  v11 = __readfsqword(0x10u);
  if ( v11 == qword_4AAD38 )
    goto LABEL_8;
  _RSI = 1LL;
  if ( _libc_multiple_threads )
  {
    if ( !_InterlockedCompareExchange((volatile signed __int32 *)&list_all_lock, 1, 0) )
      goto LABEL_7;
    goto LABEL_6;
  }
  __asm { cmpxchg dword ptr cs:list_all_lock, esi }
  if ( _libc_multiple_threads )
  {
LABEL_6:
    v6 = &list_all_lock;
    _lll_lock_wait_private((u32 *)&list_all_lock, 1LL, v11, v7, v8, v9);
  }
LABEL_7:
  qword_4AAD38 = v11;
LABEL_8:
  v12 = HIDWORD(list_all_lock);
  v13 = (__int64 *)IO_list_all;
  v14 = (unsigned int)++HIDWORD(list_all_lock);
  if ( !IO_list_all )
    goto LABEL_38;
  v15 = __readfsqword(0x10u);
  do
  {
    v16 = *(_DWORD *)v13 & 2;
    if ( !v16 )
    {
      v14 = *((unsigned int *)v13 + 48);
      if ( (_DWORD)v14 )
      {
        while ( 1 )
        {
          _RDX = v13[17];
          if ( !_RDX )
            break;
          if ( v15 == *(_QWORD *)(_RDX + 8) )
          {
            ++*(_DWORD *)(_RDX + 4);
            break;
          }
          v18 = 0;
          _ECX = 1;
          if ( _libc_multiple_threads )
            v18 = _InterlockedCompareExchange((volatile signed __int32 *)_RDX, 1, 0);
          else
            __asm { cmpxchg [rdx], ecx }
          if ( !v18 )
          {
            v24 = v13[17];
            *(_QWORD *)(v24 + 8) = v15;
            *(_DWORD *)(v24 + 4) = 1;
            break;
          }
          sched_yield();
          if ( v16 == 1 )
          {
            v16 = 2;
            break;
          }
          v16 = 1;
        }
        if ( !dealloc_buffers && (*(_DWORD *)v13 & 1) == 0 )
        {
          *(_DWORD *)v13 |= 1u;
          v23 = freeres_list;
          freeres_list = (__int64)v13;
          v13[21] = v23;
          v13[22] = v13[7];
        }
        v20 = v13[27];
        if ( (char *)&_start___libc_atexit - (char *)_start___libc_IO_vtables <= (unsigned __int64)(v20
                                                                                                  - (_QWORD)_start___libc_IO_vtables) )
          IO_vtable_check(
            (__int64)v6,
            _RSI,
            (__int64)_start___libc_IO_vtables,
            v20 - (_QWORD)_start___libc_IO_vtables,
            v8,
            v9);
        _RSI = 0LL;
        v6 = v13;
        (*(void (__fastcall **)(__int64 *, _QWORD, _QWORD))(v20 + 88))(v13, 0LL, 0LL);
        if ( *((int *)v13 + 48) > 0 )
        {
          _RSI = 0LL;
          v6 = v13;
          IO_wsetb((__int64)v13, 0LL, 0LL, 0LL, (__int64)v8, v9);
        }
        if ( v16 != 2 )
        {
          v14 = v13[17];
          if ( v14 )
          {
            v21 = (*(_DWORD *)(v14 + 4))-- == 1;
            if ( v21 )
            {
              *(_QWORD *)(v14 + 8) = 0LL;
              if ( _libc_multiple_threads )
              {
                if ( !_InterlockedDecrement((volatile signed __int32 *)v14) )
                  goto LABEL_10;
              }
              else
              {
                v21 = (*(_DWORD *)v14)-- == 1;
                if ( v21 )
                  goto LABEL_10;
              }
              v6 = (__int64 *)v14;
              _lll_unlock_wake_private((u32 *)v14, 0LL, v14, v7, v8, v9);
            }
          }
        }
      }
    }
LABEL_10:
    *((_DWORD *)v13 + 48) = -1;
    v13 = (__int64 *)v13[13];
  }
  while ( v13 );
  v12 = HIDWORD(list_all_lock) - 1;
LABEL_38:
  HIDWORD(list_all_lock) = v12;
  if ( !v12 )
  {
    qword_4AAD38 = 0LL;
    if ( _libc_multiple_threads )
    {
      if ( !_InterlockedDecrement((volatile signed __int32 *)&list_all_lock) )
        return v10;
LABEL_43:
      _lll_unlock_wake_private((u32 *)&list_all_lock, _RSI, v14, v7, v8, v9);
    }
    else
    {
      LODWORD(list_all_lock) = list_all_lock - 1;
      if ( (_DWORD)list_all_lock )
        goto LABEL_43;
    }
  }
  return v10;
}
// 40F7B2: variable 'v7' is possibly undefined
// 40F7B2: variable 'v8' is possibly undefined
// 40F7B2: variable 'v9' is possibly undefined
// 40F7BE: variable 'v11' is possibly undefined
// 40F968: variable 'v14' is possibly undefined
// 4A8120: using guessed type void *IO_list_all;
// 4A9C40: using guessed type u32 _start___libc_IO_vtables[48];
// 4AA2E8: using guessed type __int64 (__fastcall *_start___libc_atexit)();
// 4AAD10: using guessed type __int64 freeres_list;
// 4AAD18: using guessed type char dealloc_buffers;
// 4AAD30: using guessed type __int64 list_all_lock;
// 4AAD38: using guessed type __int64 qword_4AAD38;
// 4AB820: using guessed type int _libc_multiple_threads;

//----- (000000000040FA50) ----------------------------------------------------
__int64 __fastcall IO_flush_all(__int64 a1, unsigned __int64 a2, __int64 a3, __int64 a4, u32 *a5, __int64 a6)
{
  return IO_flush_all_lockp((__int64 *)1, a2, a3, a4, a5, a6);
}

//----- (000000000040FA60) ----------------------------------------------------
unsigned __int64 __fastcall flushlbf(__int64 *a1, __int64 _RSI, __int64 a3, __int64 a4, u32 *a5, __int64 a6)
{
  __int64 v6; // rdx
  int v7; // eax
  __int64 *v8; // rbx
  unsigned __int64 v10; // r12
  bool v11; // zf
  int v12; // eax
  int v13; // edx
  int v14; // eax
  __int64 v15; // r13
  unsigned __int64 v17; // [rsp+28h] [rbp-30h]

  v17 = __readfsqword(0x28u);
  v6 = __readfsqword(0x10u);
  if ( qword_4AAD38 == v6 )
    goto LABEL_8;
  _RSI = 1LL;
  if ( _libc_multiple_threads )
  {
    if ( !_InterlockedCompareExchange((volatile signed __int32 *)&list_all_lock, 1, 0) )
      goto LABEL_7;
    goto LABEL_6;
  }
  __asm { cmpxchg dword ptr cs:list_all_lock, esi }
  if ( _libc_multiple_threads )
  {
LABEL_6:
    a1 = &list_all_lock;
    _lll_lock_wait_private((u32 *)&list_all_lock, 1LL, v6, a4, a5, a6);
  }
LABEL_7:
  qword_4AAD38 = v6;
LABEL_8:
  v7 = HIDWORD(list_all_lock);
  v8 = (__int64 *)IO_list_all;
  _RDX = (unsigned int)++HIDWORD(list_all_lock);
  if ( !IO_list_all )
    goto LABEL_32;
  v10 = __readfsqword(0x10u);
  do
  {
    v13 = *(_DWORD *)v8;
    run_fp = (__int64)v8;
    v14 = v13 & 0x8000;
    if ( (v13 & 0x8000) == 0 )
    {
      _RDX = v8[17];
      if ( *(_QWORD *)(_RDX + 8) == v10 )
        goto LABEL_17;
      _RSI = 1LL;
      v11 = _libc_multiple_threads == 0;
      if ( _libc_multiple_threads )
      {
        if ( v14 == _InterlockedCompareExchange((volatile signed __int32 *)_RDX, 1, v14) )
          goto LABEL_16;
      }
      else
      {
        __asm { cmpxchg [rdx], esi }
        if ( v11 )
        {
LABEL_16:
          _RDX = v8[17];
          *(_QWORD *)(_RDX + 8) = v10;
LABEL_17:
          v12 = *(_DWORD *)v8;
          ++*(_DWORD *)(_RDX + 4);
          if ( (v12 & 0x208) != 512 )
            goto LABEL_18;
          goto LABEL_28;
        }
      }
      a1 = (__int64 *)_RDX;
      _lll_lock_wait_private((u32 *)_RDX, 1LL, _RDX, a4, a5, a6);
      goto LABEL_16;
    }
    _RDX = v13 & 0x208;
    if ( (_DWORD)_RDX != 512 )
      goto LABEL_25;
LABEL_28:
    v15 = v8[27];
    if ( (char *)&_start___libc_atexit - (char *)_start___libc_IO_vtables <= (unsigned __int64)(v15
                                                                                              - (_QWORD)_start___libc_IO_vtables) )
      IO_vtable_check(
        (__int64)a1,
        _RSI,
        (__int64)_start___libc_IO_vtables,
        v15 - (_QWORD)_start___libc_IO_vtables,
        a5,
        a6);
    _RSI = 0xFFFFFFFFLL;
    a1 = v8;
    (*(void (__fastcall **)(__int64 *, __int64))(v15 + 24))(v8, 0xFFFFFFFFLL);
LABEL_18:
    if ( (*(_DWORD *)v8 & 0x8000) == 0 )
    {
      _RDX = v8[17];
      v11 = (*(_DWORD *)(_RDX + 4))-- == 1;
      if ( v11 )
      {
        *(_QWORD *)(_RDX + 8) = 0LL;
        if ( !_libc_multiple_threads )
        {
          v11 = (*(_DWORD *)_RDX)-- == 1;
          if ( v11 )
            goto LABEL_25;
LABEL_24:
          a1 = (__int64 *)_RDX;
          _lll_unlock_wake_private((u32 *)_RDX, _RSI, _RDX, a4, a5, a6);
          goto LABEL_25;
        }
        if ( _InterlockedDecrement((volatile signed __int32 *)_RDX) )
          goto LABEL_24;
      }
    }
LABEL_25:
    run_fp = 0LL;
    v8 = (__int64 *)v8[13];
  }
  while ( v8 );
  v7 = HIDWORD(list_all_lock) - 1;
LABEL_32:
  HIDWORD(list_all_lock) = v7;
  if ( !v7 )
  {
    qword_4AAD38 = 0LL;
    if ( _libc_multiple_threads )
    {
      if ( !_InterlockedDecrement((volatile signed __int32 *)&list_all_lock) )
        return __readfsqword(0x28u) ^ v17;
LABEL_37:
      _lll_unlock_wake_private((u32 *)&list_all_lock, _RSI, _RDX, a4, a5, a6);
    }
    else
    {
      LODWORD(list_all_lock) = list_all_lock - 1;
      if ( (_DWORD)list_all_lock )
        goto LABEL_37;
    }
  }
  return __readfsqword(0x28u) ^ v17;
}
// 40FAF0: variable 'v6' is possibly undefined
// 40FB5A: variable 'a4' is possibly undefined
// 40FB5A: variable 'a5' is possibly undefined
// 40FB5A: variable 'a6' is possibly undefined
// 40FC88: variable '_RDX' is possibly undefined
// 4A8120: using guessed type void *IO_list_all;
// 4A9C40: using guessed type u32 _start___libc_IO_vtables[48];
// 4AA2E8: using guessed type __int64 (__fastcall *_start___libc_atexit)();
// 4AAD20: using guessed type __int64 run_fp;
// 4AAD30: using guessed type __int64 list_all_lock;
// 4AAD38: using guessed type __int64 qword_4AAD38;
// 4AB820: using guessed type int _libc_multiple_threads;

//----- (000000000040FCF0) ----------------------------------------------------
__int64 __fastcall IO_init_marker(__int64 a1, unsigned int *a2, __int64 a3, __int64 a4, u32 *a5, __int64 a6)
{
  __int64 v6; // rdx
  __int64 v7; // rax
  int v8; // eax
  __int64 result; // rax

  v6 = *a2;
  *(_QWORD *)(a1 + 8) = a2;
  if ( (v6 & 0x800) != 0 )
  {
    IO_switch_to_get_mode((__int64)a2, (__int64)a2, v6, a4, a5, a6);
    LODWORD(v6) = *a2;
  }
  v7 = *((_QWORD *)a2 + 1);
  if ( (v6 & 0x100) != 0 )
    v8 = v7 - a2[4];
  else
    v8 = v7 - a2[6];
  *(_DWORD *)(a1 + 16) = v8;
  result = *((_QWORD *)a2 + 12);
  *(_QWORD *)a1 = result;
  *((_QWORD *)a2 + 12) = a1;
  return result;
}

//----- (000000000040FD50) ----------------------------------------------------
_QWORD *__fastcall IO_remove_marker(_QWORD *a1)
{
  _QWORD *result; // rax
  _QWORD *v2; // rdx

  result = (_QWORD *)a1[1];
  v2 = (_QWORD *)result[12];
  if ( v2 )
  {
    if ( a1 == v2 )
    {
      v2 = result + 12;
LABEL_8:
      result = (_QWORD *)*a1;
      *v2 = *a1;
    }
    else
    {
      while ( 1 )
      {
        result = (_QWORD *)*v2;
        if ( !*v2 )
          break;
        if ( a1 == result )
          goto LABEL_8;
        v2 = (_QWORD *)*v2;
      }
    }
  }
  return result;
}

//----- (000000000040FD90) ----------------------------------------------------
__int64 __fastcall IO_marker_difference(__int64 a1, __int64 a2)
{
  return (unsigned int)(*(_DWORD *)(a1 + 16) - *(_DWORD *)(a2 + 16));
}

//----- (000000000040FDA0) ----------------------------------------------------
__int64 __fastcall IO_marker_delta(__int64 a1)
{
  __int64 v1; // rax
  __int64 v2; // rdx
  int v3; // edx

  v1 = *(_QWORD *)(a1 + 8);
  if ( !v1 )
    return 0xFFFFFFFFLL;
  v2 = *(_QWORD *)(v1 + 8);
  if ( (*(_DWORD *)v1 & 0x100) != 0 )
    v3 = v2 - *(_DWORD *)(v1 + 16);
  else
    v3 = v2 - *(_DWORD *)(v1 + 24);
  return (unsigned int)(*(_DWORD *)(a1 + 16) - v3);
}

//----- (000000000040FDE0) ----------------------------------------------------
__int64 __fastcall IO_seekmark(int *a1, __int64 a2)
{
  int v2; // edx
  __int64 v3; // rax
  int v4; // esi
  __int64 v5; // rcx
  __int64 v6; // rsi
  __int64 v7; // rdx
  __int64 v8; // rdx
  __int64 v10; // rsi
  __int64 v11; // rdx
  __int64 v12; // rcx

  if ( *(int **)(a2 + 8) != a1 )
    return 0xFFFFFFFFLL;
  v2 = *a1;
  v3 = *(int *)(a2 + 16);
  v4 = *a1 & 0x100;
  if ( (int)v3 >= 0 )
  {
    v5 = *((_QWORD *)a1 + 3);
    if ( v4 )
    {
      BYTE1(v2) &= ~1u;
      v6 = *((_QWORD *)a1 + 11);
      *a1 = v2;
      v7 = *((_QWORD *)a1 + 2);
      *((_QWORD *)a1 + 2) = v6;
      *((_QWORD *)a1 + 11) = v7;
      v8 = *((_QWORD *)a1 + 9);
      *((_QWORD *)a1 + 9) = v5;
      *((_QWORD *)a1 + 3) = v8;
      v5 = v8;
    }
    goto LABEL_5;
  }
  v5 = *((_QWORD *)a1 + 2);
  if ( v4 )
  {
LABEL_5:
    *((_QWORD *)a1 + 1) = v5 + v3;
    return 0LL;
  }
  BYTE1(v2) |= 1u;
  v10 = *((_QWORD *)a1 + 9);
  *a1 = v2;
  v11 = *((_QWORD *)a1 + 11);
  *((_QWORD *)a1 + 11) = v5;
  v12 = *((_QWORD *)a1 + 3);
  *((_QWORD *)a1 + 2) = v11;
  *((_QWORD *)a1 + 9) = v12;
  *((_QWORD *)a1 + 3) = v10;
  *((_QWORD *)a1 + 1) = v11 + v3;
  return 0LL;
}

//----- (000000000040FE90) ----------------------------------------------------
__int64 *__fastcall IO_unsave_markers(int *a1, __int64 a2, __int64 a3, __int64 a4, u32 *a5, unsigned __int64 a6)
{
  __int64 *result; // rax

  if ( *((_QWORD *)a1 + 12) )
    *((_QWORD *)a1 + 12) = 0LL;
  if ( *((_QWORD *)a1 + 9) )
    return IO_free_backup_area(a1, a2, a3, a4, a5, a6);
  return result;
}

//----- (000000000040FEC0) ----------------------------------------------------
__int64 __fastcall IO_default_pbackfail(_QWORD *a1, __int64 a2, _QWORD *a3, __int64 a4, u32 *a5, __int64 a6)
{
  int v6; // er13
  _QWORD *v7; // rbp
  unsigned __int64 v8; // r14
  int v9; // eax
  unsigned __int64 v11; // rdx
  __int64 v12; // r15
  _QWORD *v13; // rax
  _QWORD *v14; // r13
  __int64 v15; // rdx
  __int64 v16; // rcx
  u32 *v17; // r8
  unsigned __int64 v18; // r9
  _QWORD *v19; // rcx
  _QWORD *v20; // rax
  __int64 v21; // rdx
  _QWORD *v22; // [rsp+8h] [rbp-40h]

  v6 = *(_DWORD *)a1;
  v7 = (_QWORD *)a1[1];
  v8 = a1[3];
  v9 = *(_DWORD *)a1 & 0x100;
  if ( (unsigned __int64)v7 <= v8 )
  {
    if ( v9 )
    {
      v11 = a1[2] - v8;
      v12 = 2 * v11;
      v22 = (_QWORD *)v11;
      v13 = malloc(2 * v11, a2, (_QWORD *)v11, a4, a5, a6);
      v14 = v13;
      if ( v13 )
      {
        v7 = (_QWORD *)((char *)v13 + v12 - (_QWORD)v22);
        j_memcpy(v7, v8, v22);
        free(v8, v8, v15, v16, v17, v18);
        a1[3] = v14;
        a1[2] = (char *)v14 + v12;
        a1[10] = v7;
        goto LABEL_3;
      }
      return 0xFFFFFFFFLL;
    }
    v20 = (_QWORD *)a1[9];
    if ( v20 )
    {
      v19 = (_QWORD *)a1[1];
      v7 = (_QWORD *)a1[11];
      goto LABEL_14;
    }
    goto LABEL_15;
  }
  if ( v9 )
  {
LABEL_3:
    a1[1] = (char *)v7 - 1;
    *((_BYTE *)v7 - 1) = a2;
    return (unsigned __int8)a2;
  }
  if ( *((unsigned __int8 *)v7 - 1) == (_DWORD)a2 )
  {
    a1[1] = (char *)v7 - 1;
    return (unsigned __int8)a2;
  }
  if ( !a1[9] )
  {
LABEL_15:
    v20 = malloc(0x80uLL, a2, a3, a4, a5, a6);
    if ( v20 )
    {
      v19 = v7;
      a1[10] = v20 + 16;
      v7 = v20 + 16;
      goto LABEL_14;
    }
    return 0xFFFFFFFFLL;
  }
  if ( !(unsigned int)save_for_backup(a1, a1[1], (__int64)a3, a4, (__int64)a5, a6) )
  {
    v19 = (_QWORD *)a1[1];
    v6 = *(_DWORD *)a1;
    v7 = (_QWORD *)a1[11];
    v20 = (_QWORD *)a1[9];
LABEL_14:
    v21 = a1[2];
    a1[2] = v7;
    *(_DWORD *)a1 = v6 | 0x100;
    a1[11] = v21;
    a1[3] = v20;
    a1[9] = v19;
    goto LABEL_3;
  }
  return 0xFFFFFFFFLL;
}
// 40FF68: variable 'v15' is possibly undefined
// 40FF68: variable 'v16' is possibly undefined
// 40FF68: variable 'v17' is possibly undefined
// 40FF68: variable 'v18' is possibly undefined
// 401040: using guessed type __int64 __fastcall j_memcpy(_QWORD, _QWORD, _QWORD);

//----- (0000000000410040) ----------------------------------------------------
__int64 IO_default_seek()
{
  return -1LL;
}
// 410040: using guessed type __int64 __fastcall IO_default_seek();

//----- (0000000000410050) ----------------------------------------------------
__int64 IO_default_stat()
{
  return 0xFFFFFFFFLL;
}
// 410050: using guessed type __int64 __fastcall IO_default_stat();

//----- (0000000000410060) ----------------------------------------------------
__int64 IO_default_read()
{
  return -1LL;
}
// 410060: using guessed type __int64 __fastcall IO_default_read();

//----- (0000000000410070) ----------------------------------------------------
__int64 IO_default_write()
{
  return 0LL;
}
// 410070: using guessed type __int64 __fastcall IO_default_write();

//----- (0000000000410080) ----------------------------------------------------
__int64 IO_default_showmanyc()
{
  return 0xFFFFFFFFLL;
}
// 410080: using guessed type __int64 __fastcall IO_default_showmanyc();

//----- (0000000000410090) ----------------------------------------------------
void IO_default_imbue()
{
  ;
}

//----- (00000000004100A0) ----------------------------------------------------
void *IO_iter_begin()
{
  return IO_list_all;
}
// 4A8120: using guessed type void *IO_list_all;

//----- (00000000004100B0) ----------------------------------------------------
__int64 IO_iter_end()
{
  return 0LL;
}
// 4100B0: using guessed type __int64 __fastcall IO_iter_end();

//----- (00000000004100C0) ----------------------------------------------------
__int64 __fastcall IO_iter_next(__int64 a1)
{
  return *(_QWORD *)(a1 + 104);
}

//----- (00000000004100D0) ----------------------------------------------------
__int64 __fastcall IO_iter_file(__int64 a1)
{
  return a1;
}

//----- (00000000004100E0) ----------------------------------------------------
__int64 __fastcall IO_list_lock(__int64 a1, __int64 a2, __int64 a3, __int64 a4, u32 *a5, u32 a6)
{
  __int64 v6; // rdx
  __int64 result; // rax

  v6 = __readfsqword(0x10u);
  if ( qword_4AAD38 != v6 )
  {
    _ESI = 1;
    result = 0LL;
    if ( _libc_multiple_threads )
    {
      result = (unsigned int)_InterlockedCompareExchange((volatile signed __int32 *)&list_all_lock, 1, 0);
      if ( !(_DWORD)result )
        goto LABEL_7;
    }
    else
    {
      __asm { cmpxchg dword ptr cs:list_all_lock, esi }
      if ( !_libc_multiple_threads )
      {
LABEL_7:
        qword_4AAD38 = v6;
        goto LABEL_8;
      }
    }
    result = _lll_lock_wait_private((u32 *)&list_all_lock, 1LL, v6, a4, a5, a6);
    goto LABEL_7;
  }
LABEL_8:
  ++HIDWORD(list_all_lock);
  return result;
}
// 410135: variable 'v6' is possibly undefined
// 4AAD30: using guessed type __int64 list_all_lock;
// 4AAD38: using guessed type __int64 qword_4AAD38;
// 4AB820: using guessed type int _libc_multiple_threads;

//----- (0000000000410150) ----------------------------------------------------
signed __int64 __fastcall IO_list_unlock(__int64 a1, __int64 a2, __int64 a3, __int64 a4, u32 *a5, u32 a6)
{
  signed __int64 result; // rax

  if ( !--HIDWORD(list_all_lock) )
  {
    qword_4AAD38 = 0LL;
    if ( _libc_multiple_threads )
    {
      if ( !_InterlockedDecrement((volatile signed __int32 *)&list_all_lock) )
        return result;
    }
    else
    {
      LODWORD(list_all_lock) = list_all_lock - 1;
      if ( !(_DWORD)list_all_lock )
        return result;
    }
    return _lll_unlock_wake_private((u32 *)&list_all_lock, a2, a3, a4, a5, a6);
  }
  return result;
}
// 4AAD30: using guessed type __int64 list_all_lock;
// 4AAD38: using guessed type __int64 qword_4AAD38;
// 4AB820: using guessed type int _libc_multiple_threads;

//----- (00000000004101A0) ----------------------------------------------------
void IO_list_resetlock()
{
  list_all_lock = 0LL;
  qword_4AAD38 = 0LL;
}
// 4AAD30: using guessed type __int64 list_all_lock;
// 4AAD38: using guessed type __int64 qword_4AAD38;

//----- (00000000004101C0) ----------------------------------------------------
__int64 __fastcall IO_str_underflow(int *a1)
{
  unsigned __int8 *v1; // rax
  unsigned __int8 *v2; // rdx
  int v3; // ecx

  v1 = (unsigned __int8 *)*((_QWORD *)a1 + 5);
  v2 = (unsigned __int8 *)*((_QWORD *)a1 + 2);
  if ( v1 > v2 )
  {
    *((_QWORD *)a1 + 2) = v1;
    v2 = v1;
  }
  v3 = *a1;
  if ( (*a1 & 0xC00) == 3072 )
  {
    BYTE1(v3) &= ~8u;
    *((_QWORD *)a1 + 1) = v1;
    *a1 = v3;
    *((_QWORD *)a1 + 5) = *((_QWORD *)a1 + 6);
  }
  else
  {
    v1 = (unsigned __int8 *)*((_QWORD *)a1 + 1);
  }
  if ( v1 >= v2 )
    return 0xFFFFFFFFLL;
  else
    return *v1;
}

//----- (0000000000410220) ----------------------------------------------------
__int64 __fastcall IO_str_overflow(__int64 a1, __int64 a2, __int64 a3, __int64 a4, u32 *a5, __int64 a6)
{
  int v6; // edx
  _QWORD *v7; // rdx
  __int64 v8; // r15
  unsigned __int64 v9; // rbp
  unsigned __int64 v10; // rcx
  unsigned __int64 v11; // r14
  _QWORD *v12; // rax
  __int64 v13; // r13
  __int64 v14; // rdx
  __int64 v15; // rcx
  u32 *v16; // r8
  unsigned __int64 v17; // r9
  u32 *v18; // r8
  unsigned __int64 v19; // r9
  __int64 v20; // rax
  __int64 v21; // rdx
  __int64 v22; // rax
  __int64 result; // rax
  __int64 v24; // rax

  v6 = *(_DWORD *)a1;
  if ( (*(_DWORD *)a1 & 8) != 0 )
    return (unsigned int)-((_DWORD)a2 != -1);
  if ( (*(_DWORD *)a1 & 0xC00) == 1024 )
  {
    BYTE1(v6) |= 8u;
    v24 = *(_QWORD *)(a1 + 16);
    *(_DWORD *)a1 = v6;
    v7 = *(_QWORD **)(a1 + 8);
    *(_QWORD *)(a1 + 8) = v24;
    *(_QWORD *)(a1 + 40) = v7;
  }
  else
  {
    v7 = *(_QWORD **)(a1 + 40);
  }
  v8 = *(_QWORD *)(a1 + 56);
  v9 = *(_QWORD *)(a1 + 64) - v8;
  v10 = (unsigned __int64)v7 - *(_QWORD *)(a1 + 32);
  if ( v9 + ((_DWORD)a2 == -1) <= v10 )
  {
    if ( (*(_BYTE *)a1 & 1) != 0 )
      return 0xFFFFFFFFLL;
    v11 = 2 * v9 + 100;
    if ( v9 > v11 )
      return 0xFFFFFFFFLL;
    v12 = malloc(2 * v9 + 100, a2, v7, v10, a5, a6);
    v13 = (__int64)v12;
    if ( !v12 )
      return 0xFFFFFFFFLL;
    if ( v8 )
    {
      j_memcpy(v12, v8, v9);
      free(v8, v8, v14, v15, v16, v17);
      *(_QWORD *)(a1 + 56) = 0LL;
    }
    j_memset_ifunc(v13 + v9, 0LL, v11 - v9);
    IO_setb((int *)a1, v13, v13 + v11, 1LL, v18, v19);
    v20 = *(_QWORD *)(a1 + 24);
    v21 = *(_QWORD *)(a1 + 40);
    *(_QWORD *)(a1 + 32) = v13;
    v7 = (_QWORD *)(v13 + v21 - v8);
    *(_QWORD *)(a1 + 24) = v13 + v20 - v8;
    v22 = *(_QWORD *)(a1 + 8);
    *(_QWORD *)(a1 + 40) = v7;
    *(_QWORD *)(a1 + 8) = v13 + v22 - v8;
    *(_QWORD *)(a1 + 16) = v13 + *(_QWORD *)(a1 + 16) - v8;
    *(_QWORD *)(a1 + 48) = *(_QWORD *)(a1 + 64);
  }
  if ( (_DWORD)a2 != -1 )
  {
    *(_QWORD *)(a1 + 40) = (char *)v7 + 1;
    *(_BYTE *)v7 = a2;
    v7 = *(_QWORD **)(a1 + 40);
  }
  result = (unsigned int)a2;
  if ( *(_QWORD *)(a1 + 16) < (unsigned __int64)v7 )
    *(_QWORD *)(a1 + 16) = v7;
  return result;
}
// 4102C0: variable 'v14' is possibly undefined
// 4102C0: variable 'v15' is possibly undefined
// 4102C0: variable 'v16' is possibly undefined
// 4102C0: variable 'v17' is possibly undefined
// 4102EF: variable 'v18' is possibly undefined
// 4102EF: variable 'v19' is possibly undefined
// 401040: using guessed type __int64 __fastcall j_memcpy(_QWORD, _QWORD, _QWORD);
// 401090: using guessed type __int64 __fastcall j_memset_ifunc(_QWORD, _QWORD, _QWORD);

//----- (00000000004103B0) ----------------------------------------------------
__int64 __fastcall enlarge_userbuf(__int64 a1, __int64 a2, _QWORD *a3, __int64 a4, u32 *a5, __int64 a6)
{
  __int64 v6; // r14
  __int64 v7; // r13
  unsigned int v8; // er15
  _QWORD *v10; // rax
  u32 *v11; // r8
  unsigned __int64 v12; // r9
  __int64 v13; // r12
  __int64 v14; // rdx
  __int64 v15; // rcx
  u32 *v16; // r8
  unsigned __int64 v17; // r9
  __int64 v18; // r13
  __int64 v19; // rax
  __int64 v20; // rax
  __int64 v21; // [rsp+0h] [rbp-58h]
  __int64 v22; // [rsp+8h] [rbp-50h]
  int v23; // [rsp+1Ch] [rbp-3Ch]

  v6 = *(_QWORD *)(a1 + 56);
  v7 = *(_QWORD *)(a1 + 64) - v6;
  if ( v7 >= a2 )
    return 0;
  v8 = *(_DWORD *)a1 & 1;
  if ( !v8 )
  {
    v23 = (int)a3;
    v21 = *(_QWORD *)(a1 + 48);
    v22 = *(_QWORD *)(a1 + 32);
    v10 = malloc(a2 + 100, a2, a3, a4, a5, a6);
    v13 = (__int64)v10;
    if ( v10 )
    {
      if ( v6 )
      {
        j_memcpy(v10, v6, v7);
        free(v6, v6, v14, v15, v16, v17);
        *(_QWORD *)(a1 + 56) = 0LL;
      }
      v18 = v21 - v22;
      IO_setb((int *)a1, v13, v13 + a2 + 100, 1LL, v11, v12);
      if ( v23 )
      {
        v19 = *(_QWORD *)(a1 + 32);
        *(_QWORD *)(a1 + 24) = v13;
        *(_QWORD *)(a1 + 32) = v13 + v19 - v6;
        *(_QWORD *)(a1 + 40) = v13 + *(_QWORD *)(a1 + 40) - v6;
        *(_QWORD *)(a1 + 48) = v13 + *(_QWORD *)(a1 + 48) - v6;
        *(_QWORD *)(a1 + 8) = v13 + *(_QWORD *)(a1 + 8) - v6;
        *(_QWORD *)(a1 + 16) = *(_QWORD *)(a1 + 64);
        if ( a2 >= v18 )
        {
          j_memset_ifunc(v13 + v18, 0LL, a2 - v18);
          return v8;
        }
      }
      else
      {
        v20 = *(_QWORD *)(a1 + 24);
        *(_QWORD *)(a1 + 32) = v13;
        *(_QWORD *)(a1 + 24) = v13 + v20 - v6;
        *(_QWORD *)(a1 + 8) = v13 + *(_QWORD *)(a1 + 8) - v6;
        *(_QWORD *)(a1 + 16) = v13 + *(_QWORD *)(a1 + 16) - v6;
        *(_QWORD *)(a1 + 40) = v13 + *(_QWORD *)(a1 + 40) - v6;
        *(_QWORD *)(a1 + 48) = *(_QWORD *)(a1 + 64);
        if ( a2 >= v18 )
        {
          v8 = 0;
          j_memset_ifunc(v13 + v18, 0LL, a2 - v18);
          return v8;
        }
      }
      _assert_fail((__int64)"offset >= oldend", (__int64)"strops.c", 0xDEu, "enlarge_userbuf");
    }
  }
  return 1;
}
// 410442: variable 'v14' is possibly undefined
// 410442: variable 'v15' is possibly undefined
// 410442: variable 'v16' is possibly undefined
// 410442: variable 'v17' is possibly undefined
// 41046B: variable 'v11' is possibly undefined
// 41046B: variable 'v12' is possibly undefined
// 401040: using guessed type __int64 __fastcall j_memcpy(_QWORD, _QWORD, _QWORD);
// 401090: using guessed type __int64 __fastcall j_memset_ifunc(_QWORD, _QWORD, _QWORD);

//----- (0000000000410580) ----------------------------------------------------
__int64 __fastcall IO_str_seekoff(__int64 a1, __int64 a2, int a3, __int64 a4, u32 *a5, __int64 a6)
{
  int v8; // edx
  unsigned __int64 v9; // rsi
  unsigned __int64 v10; // rax
  __int64 v11; // rsi
  __int64 v12; // r14
  __int64 v13; // rbp
  __int64 v14; // rbp
  __int64 v16; // rcx
  __int64 v17; // rax
  __int64 v18; // rbp
  __int64 v19; // rax
  bool v20; // dl
  __int64 v21; // rbp
  int v22; // eax
  char v23; // [rsp+Ch] [rbp-2Ch]

  v8 = *(_DWORD *)a1;
  v9 = *(_QWORD *)(a1 + 32);
  v10 = *(_QWORD *)(a1 + 40);
  if ( (_DWORD)a4 )
  {
    if ( v9 >= v10 && (v8 & 0x800) == 0 )
    {
      v11 = *(_QWORD *)(a1 + 24);
      goto LABEL_28;
    }
LABEL_17:
    if ( (v8 & 0x100) == 0 )
    {
LABEL_18:
      v11 = *(_QWORD *)(a1 + 56);
      goto LABEL_19;
    }
LABEL_22:
    v11 = *(_QWORD *)(a1 + 80);
LABEL_19:
    BYTE1(v8) &= ~8u;
    *(_QWORD *)(a1 + 24) = v11;
    *(_QWORD *)(a1 + 16) = v10;
    *(_QWORD *)(a1 + 8) = v10;
    *(_DWORD *)a1 = v8;
    if ( !(_DWORD)a4 )
      return *(_QWORD *)(a1 + 8) - v11;
LABEL_28:
    if ( *(_QWORD *)(a1 + 16) >= v10 )
      v10 = *(_QWORD *)(a1 + 16);
    v14 = -1LL;
    v12 = v10 - v11;
    if ( (a4 & 1) == 0 )
      goto LABEL_31;
    goto LABEL_8;
  }
  a4 = v8 & 0x400;
  if ( (v8 & 0x400) == 0 )
  {
    if ( v9 >= v10 && (v8 & 0x800) == 0 )
    {
      v11 = *(_QWORD *)(a1 + 24);
      return *(_QWORD *)(a1 + 8) - v11;
    }
    goto LABEL_17;
  }
  if ( (v8 & 0x800) != 0 )
  {
    a4 = 2LL;
    if ( (v8 & 0x100) == 0 )
      goto LABEL_18;
    goto LABEL_22;
  }
  if ( v9 < v10 )
  {
    a4 = 1LL;
    goto LABEL_17;
  }
  if ( *(_QWORD *)(a1 + 16) >= v10 )
    v10 = *(_QWORD *)(a1 + 16);
  a4 = 1LL;
  v11 = *(_QWORD *)(a1 + 24);
  v12 = v10 - v11;
LABEL_8:
  if ( a3 )
  {
    v13 = v12;
    if ( a3 == 1 )
      v13 = *(_QWORD *)(a1 + 8) - v11;
    if ( -v13 > a2 || 0x7FFFFFFFFFFFFFFFLL - v13 < a2 )
      goto LABEL_50;
    v14 = a2 + v13;
  }
  else
  {
    if ( a2 < 0 )
    {
LABEL_50:
      v14 = -1LL;
      __writefsdword(0xFFFFFFC0, 0x16u);
      return v14;
    }
    v14 = a2;
  }
  if ( v14 > v12 )
  {
    v23 = a4;
    v22 = enlarge_userbuf(a1, v14, (_QWORD *)1, a4, a5, a6);
    LOBYTE(a4) = v23;
    if ( v22 )
      return -1LL;
    v11 = *(_QWORD *)(a1 + 24);
    v10 = v11 + v12;
  }
  *(_QWORD *)(a1 + 16) = v10;
  *(_QWORD *)(a1 + 8) = v14 + v11;
LABEL_31:
  v16 = a4 & 2;
  if ( !(_DWORD)v16 )
    return v14;
  if ( a3 )
  {
    if ( a3 == 1 )
    {
      v17 = *(_QWORD *)(a1 + 32);
      v18 = *(_QWORD *)(a1 + 40) - v17;
      v19 = v17 - *(_QWORD *)(a1 + 40);
      v20 = a2 > 0x7FFFFFFFFFFFFFFFLL - v18;
    }
    else
    {
      v18 = v12;
      v19 = -v12;
      v20 = a2 > 0x7FFFFFFFFFFFFFFFLL - v12;
    }
  }
  else
  {
    v20 = 0;
    v19 = 0LL;
    v18 = 0LL;
  }
  if ( a2 < v19 || v20 )
    goto LABEL_50;
  v21 = a2 + v18;
  if ( v21 > v12 && (unsigned int)enlarge_userbuf(a1, v21, 0LL, v16, a5, a6) )
    return -1LL;
  *(_QWORD *)(a1 + 40) = v21 + *(_QWORD *)(a1 + 32);
  return v21;
}
// 4107F0: variable 'a5' is possibly undefined
// 4107F0: variable 'a6' is possibly undefined

//----- (0000000000410840) ----------------------------------------------------
__int64 __fastcall IO_str_pbackfail(_QWORD *a1, __int64 a2, _QWORD *a3, __int64 a4, u32 *a5, __int64 a6)
{
  if ( (*(_BYTE *)a1 & 8) != 0 && (_DWORD)a2 != -1 )
    return 0xFFFFFFFFLL;
  else
    return IO_default_pbackfail(a1, a2, a3, a4, a5, a6);
}

//----- (0000000000410860) ----------------------------------------------------
__int64 *__fastcall IO_str_finish(__int64 a1, __int64 a2, __int64 a3, unsigned int *a4, u32 *a5, unsigned __int64 a6)
{
  __int64 v7; // rdi

  v7 = *(_QWORD *)(a1 + 56);
  if ( v7 && (*(_BYTE *)a1 & 1) == 0 )
    free(v7, a2, a3, (__int64)a4, a5, a6);
  *(_QWORD *)(a1 + 56) = 0LL;
  return IO_default_finish(a1, 0LL, a3, a4, a5, a6);
}
// 410884: variable 'a3' is possibly undefined
// 410884: variable 'a4' is possibly undefined
// 410884: variable 'a5' is possibly undefined
// 410884: variable 'a6' is possibly undefined

//----- (00000000004108A0) ----------------------------------------------------
__int64 __fastcall IO_str_init_static_internal(
        __int64 a1,
        unsigned __int64 a2,
        __int64 a3,
        __int64 a4,
        u32 *a5,
        unsigned __int64 a6)
{
  __int64 v7; // r12
  __int64 result; // rax
  unsigned __int64 v9; // rdx

  if ( a3 )
  {
    v9 = a2 + a3;
    v7 = -1LL;
    if ( a2 < v9 )
      v7 = v9;
  }
  else
  {
    v7 = j_rawmemchr(a2, 0LL);
  }
  result = IO_setb((int *)a1, a2, v7, 0LL, a5, a6);
  *(_QWORD *)(a1 + 32) = a2;
  *(_QWORD *)(a1 + 24) = a2;
  *(_QWORD *)(a1 + 8) = a2;
  if ( a4 )
  {
    *(_QWORD *)(a1 + 40) = a4;
    *(_QWORD *)(a1 + 48) = v7;
    *(_QWORD *)(a1 + 16) = a4;
  }
  else
  {
    *(_QWORD *)(a1 + 40) = a2;
    *(_QWORD *)(a1 + 48) = a2;
    *(_QWORD *)(a1 + 16) = v7;
  }
  *(_QWORD *)(a1 + 224) = 0LL;
  return result;
}
// 4108D4: variable 'a5' is possibly undefined
// 4108D4: variable 'a6' is possibly undefined
// 401038: using guessed type __int64 __fastcall j_rawmemchr(_QWORD, _QWORD);

//----- (0000000000410940) ----------------------------------------------------
__int64 __fastcall IO_str_init_static(
        __int64 a1,
        unsigned __int64 a2,
        int a3,
        __int64 a4,
        u32 *a5,
        unsigned __int64 a6)
{
  if ( a3 < 0 )
    a3 = -1;
  return IO_str_init_static_internal(a1, a2, a3, a4, a5, a6);
}

//----- (0000000000410960) ----------------------------------------------------
__int64 __fastcall IO_str_init_readonly(
        _DWORD *a1,
        unsigned __int64 a2,
        int a3,
        __int64 a4,
        u32 *a5,
        unsigned __int64 a6)
{
  __int64 result; // rax

  if ( a3 < 0 )
    a3 = -1;
  result = IO_str_init_static_internal((__int64)a1, a2, a3, 0LL, a5, a6);
  *a1 |= 8u;
  return result;
}

//----- (0000000000410990) ----------------------------------------------------
unsigned __int64 __fastcall IO_str_count(_QWORD *a1)
{
  unsigned __int64 v1; // rax

  v1 = a1[5];
  if ( a1[2] >= v1 )
    v1 = a1[2];
  return v1 - a1[3];
}

//----- (00000000004109B0) ----------------------------------------------------
_BOOL8 __fastcall _libc_alloca_cutoff(unsigned __int64 a1)
{
  unsigned __int64 v1; // rdx
  unsigned __int64 v2; // rax

  v1 = 0x10000LL;
  if ( (__readfsqword(0x698u) >> 2) - 1 <= 0xFFFF )
  {
    v2 = __readfsqword(0x698u);
    v1 = v2 >> 2;
    if ( v2 <= 3 )
      v1 = 0x40000LL;
  }
  return v1 >= a1;
}

//----- (0000000000410A00) ----------------------------------------------------
__int64 __fastcall _lll_lock_wait_private(u32 *a1, __int64 a2, __int64 a3, __int64 a4, u32 *a5, u32 a6)
{
  int v6; // eax
  struct timespec *v7; // r10
  unsigned __int32 v8; // edx
  signed __int64 v9; // rax
  __int64 result; // rax

  v7 = 0LL;
  v8 = 2;
  if ( v6 != 2 )
    goto LABEL_3;
  do
  {
    v9 = sys_futex(a1, 128, v8, v7, a5, a6);
LABEL_3:
    result = (unsigned int)_InterlockedExchange((volatile __int32 *)a1, v8);
  }
  while ( (_DWORD)result );
  return result;
}
// 410A12: variable 'v6' is possibly undefined
// 410A1A: variable 'v8' is possibly undefined
// 410A1A: variable 'v7' is possibly undefined
// 410A1A: variable 'a5' is possibly undefined
// 410A1A: variable 'a6' is possibly undefined

//----- (0000000000410A30) ----------------------------------------------------
signed __int64 __fastcall _lll_unlock_wake_private(u32 *a1, __int64 a2, __int64 a3, __int64 a4, u32 *a5, u32 a6)
{
  struct timespec *v6; // r10

  *a1 = 0;
  return sys_futex(a1, 129, 1u, v6, a5, a6);
}
// 410A47: variable 'v6' is possibly undefined

//----- (0000000000410A50) ----------------------------------------------------
__int64 __fastcall dl_tunable_set_arena_max(__int64 *a1)
{
  __int64 result; // rax

  result = *a1;
  qword_4A8800 = *a1;
  return result;
}
// 4A8800: using guessed type __int64 qword_4A8800;

//----- (0000000000410A60) ----------------------------------------------------
__int64 __fastcall dl_tunable_set_arena_test(__int64 *a1)
{
  __int64 result; // rax

  result = *a1;
  qword_4A87F8 = *a1;
  return result;
}
// 4A87F8: using guessed type __int64 qword_4A87F8;

//----- (0000000000410A70) ----------------------------------------------------
unsigned __int64 __fastcall dl_tunable_set_tcache_max(unsigned __int64 *a1)
{
  unsigned __int64 result; // rax
  __int64 v2; // rdx

  result = *a1;
  if ( *a1 <= 0x408 )
  {
    qword_4A8838 = *a1;
    result += 23LL;
    v2 = 1LL;
    if ( result > 0x1F )
    {
      result = ((result & 0xFFFFFFFFFFFFFFF0LL) - 17) >> 4;
      v2 = result + 1;
    }
    qword_4A8830 = v2;
  }
  return result;
}
// 4A8830: using guessed type __int64 qword_4A8830;
// 4A8838: using guessed type __int64 qword_4A8838;

//----- (0000000000410AB0) ----------------------------------------------------
__int64 __fastcall dl_tunable_set_tcache_count(__int64 *a1)
{
  __int64 result; // rax

  result = *a1;
  if ( (unsigned __int64)*a1 <= 0x7F )
    qword_4A8840 = *a1;
  return result;
}
// 4A8840: using guessed type __int64 qword_4A8840;

//----- (0000000000410AD0) ----------------------------------------------------
__int64 __fastcall dl_tunable_set_tcache_unsorted_limit(__int64 *a1)
{
  __int64 result; // rax

  result = *a1;
  qword_4A8848 = *a1;
  return result;
}
// 4A8848: using guessed type __int64 qword_4A8848;

//----- (0000000000410AE0) ----------------------------------------------------
__int64 __fastcall mem2mem_check(__int64 a1, unsigned __int64 a2)
{
  __int64 result; // rax
  unsigned __int64 v3; // rdx
  __int64 v4; // rdi
  unsigned __int8 v5; // r10
  unsigned __int64 v6; // rcx
  unsigned __int64 i; // rcx
  __int64 v8; // rdx

  result = a1;
  if ( a1 )
  {
    v3 = a1 - 16;
    v4 = *(_QWORD *)(a1 - 8);
    v5 = (v3 >> 11) ^ (v3 >> 3);
    if ( v5 == 1 )
      v5 = 2;
    v6 = (v4 & 0xFFFFFFFFFFFFFFF8LL) - 8;
    if ( (v4 & 2) != 0 )
      v6 = (v4 & 0xFFFFFFFFFFFFFFF8LL) - 16;
    for ( i = v6 - 1; a2 < i; i -= v8 )
    {
      v8 = i - a2;
      if ( i - a2 > 0xFF )
        v8 = 255LL;
      if ( v8 == v5 )
        v8 = v5 - 1LL;
      *(_BYTE *)(result + i) = v8;
    }
    *(_BYTE *)(result + a2) = v5;
  }
  return result;
}

//----- (0000000000410B80) ----------------------------------------------------
unsigned __int64 __fastcall mem2chunk_check(__int64 a1, _QWORD *a2)
{
  unsigned __int64 result; // rax
  __int64 v3; // r9
  char v4; // r8
  unsigned __int64 v5; // rcx
  __int64 v6; // r10
  unsigned __int64 v7; // rdx
  _BYTE *v8; // rdi
  __int64 v9; // rcx
  __int64 v10; // rdi
  unsigned __int64 v11; // r9
  unsigned __int64 v12; // rcx
  __int64 v13; // rdx

  if ( (a1 & 0xF) != 0 )
    return 0LL;
  result = a1 - 16;
  v3 = *(_QWORD *)(a1 - 8);
  v4 = ((unsigned __int64)(a1 - 16) >> 11) ^ ((unsigned __int64)(a1 - 16) >> 3);
  v5 = v3 & 0xFFFFFFFFFFFFFFF8LL;
  if ( v4 == 1 )
    v4 = 2;
  if ( (v3 & 2) != 0 )
  {
    v6 = (dl_pagesize - 1) & a1;
    if ( ((v6 - 16) & 0xFFFFFFFFFFFFFFEFLL) != 0
      && (unsigned __int64)(v6 - 1) <= 0x1FFE
      && ((v6 - 64) & 0xFFFFFFFFFFFFFFBFLL) != 0
      && ((v6 - 256) & 0xFFFFFFFFFFFFFEFFLL) != 0
      && ((v6 - 1024) & 0xFFFFFFFFFFFFFBFFLL) != 0
      && v6 != 4096 )
    {
      return 0LL;
    }
    if ( (v3 & 3) != 2 || ((dl_pagesize - 1) & ((result - *(_QWORD *)(a1 - 16)) | (v5 + *(_QWORD *)(a1 - 16)))) != 0 )
      return 0LL;
    v7 = v5 - 1;
    v8 = (_BYTE *)(result + v5 - 1);
    v9 = (unsigned __int8)*v8;
    if ( v4 != (_BYTE)v9 )
    {
      if ( !*v8 || v7 < v9 + 16 )
        return 0LL;
      while ( 1 )
      {
        v7 -= v9;
        v8 = (_BYTE *)(result + v7);
        v9 = *(unsigned __int8 *)(result + v7);
        if ( (_BYTE)v9 == v4 )
          break;
        if ( !*(_BYTE *)(result + v7) || v9 + 16 > v7 )
          return 0LL;
      }
    }
  }
  else
  {
    if ( (dword_4A8884 & 2) == 0 && (qword_4A8828 > result || result + v5 >= qword_4A9108 + qword_4A8828)
      || v5 <= 0x1F
      || (v3 & 8) != 0
      || (*(_BYTE *)(a1 + v5 - 8) & 1) == 0 )
    {
      return 0LL;
    }
    if ( (v3 & 1) == 0 )
    {
      v10 = *(_QWORD *)(a1 - 16);
      if ( (v10 & 0xF) != 0 )
        return 0LL;
      v11 = result - v10;
      if ( (dword_4A8884 & 2) == 0 && qword_4A8828 > v11 )
        return 0LL;
      if ( v10 != (*(_QWORD *)(v11 + 8) & 0xFFFFFFFFFFFFFFF8LL) )
        return 0LL;
    }
    v12 = v5 + 7;
    v8 = (_BYTE *)(result + v12);
    v13 = *(unsigned __int8 *)(result + v12);
    if ( v4 != (_BYTE)v13 )
    {
      if ( !*(_BYTE *)(result + v12) || v12 < v13 + 16 )
        return 0LL;
      while ( 1 )
      {
        v12 -= v13;
        v8 = (_BYTE *)(result + v12);
        v13 = *(unsigned __int8 *)(result + v12);
        if ( (_BYTE)v13 == v4 )
          break;
        if ( !*(_BYTE *)(result + v12) || v13 + 16 > v12 )
          return 0LL;
      }
    }
  }
  *v8 = ~v4;
  if ( a2 )
    *a2 = v8;
  return result;
}
// 4A8828: using guessed type __int64 qword_4A8828;
// 4A8884: using guessed type int dword_4A8884;
// 4A9108: using guessed type __int64 qword_4A9108;
// 4A91F8: using guessed type __int64 dl_pagesize;

//----- (0000000000410D90) ----------------------------------------------------
int *__fastcall int_mallinfo(__int64 a1, __int64 a2)
{
  int v2; // er11
  int v3; // er10
  __int64 *v6; // rsi
  __int64 *v7; // r9
  __int64 v8; // rbp
  __int64 i; // rax
  __int64 v10; // rdx
  int v11; // ecx
  int v12; // er8
  __int64 *j; // rax
  __int64 v14; // rdx
  __int64 v15; // rdx
  int v16; // eax
  int *result; // rax

  v2 = 0;
  v3 = 0;
  v6 = (__int64 *)(a1 + 16);
  v7 = (__int64 *)(a1 + 96);
  v8 = *(_QWORD *)(*(_QWORD *)(a1 + 96) + 8LL);
  do
  {
    for ( i = *v6; i; v3 += v10 & 0xFFFFFFF8 )
    {
      v10 = *(_QWORD *)(i + 8);
      i = *(_QWORD *)(i + 16);
      ++v2;
    }
    ++v6;
  }
  while ( v7 != v6 );
  v11 = v3 + (v8 & 0xFFFFFFF8);
  v12 = 1;
  do
  {
    for ( j = (__int64 *)v7[3]; j != v7; v11 += v14 & 0xFFFFFFF8 )
    {
      v14 = j[1];
      j = (__int64 *)j[3];
      ++v12;
    }
    v7 += 2;
  }
  while ( (__int64 *)(a1 + 2128) != v7 );
  v15 = *(_QWORD *)(a1 + 2184);
  v16 = *(_DWORD *)(a2 + 28);
  *(_DWORD *)(a2 + 8) += v2;
  *(_DWORD *)(a2 + 4) += v12;
  *(_DWORD *)(a2 + 32) += v11;
  *(_DWORD *)(a2 + 28) = v15 + v16 - v11;
  result = &main_arena;
  *(_DWORD *)a2 += v15;
  *(_DWORD *)(a2 + 24) += v3;
  if ( (int *)a1 == &main_arena )
  {
    *(_DWORD *)(a2 + 12) = dword_4A8808;
    result = (int *)qword_4A8818;
    *(_DWORD *)(a2 + 36) = v8 & 0xFFFFFFF8;
    *(_QWORD *)(a2 + 16) = (unsigned int)result;
  }
  return result;
}
// 4A8808: using guessed type int dword_4A8808;
// 4A8818: using guessed type __int64 qword_4A8818;
// 4A8880: using guessed type int main_arena;

//----- (0000000000410E80) ----------------------------------------------------
int *__fastcall malloc_init_state(__int64 a1)
{
  __int64 v1; // rax
  int *result; // rax

  v1 = a1 + 96;
  do
  {
    *(_QWORD *)(v1 + 24) = v1;
    *(_QWORD *)(v1 + 16) = v1;
    v1 += 16LL;
  }
  while ( a1 + 2128 != v1 );
  result = &main_arena;
  if ( (int *)a1 == &main_arena )
    global_max_fast = 128LL;
  else
    *(_DWORD *)(a1 + 4) |= 2u;
  *(_DWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 96) = a1 + 96;
  return result;
}
// 4A8880: using guessed type int main_arena;
// 4AADB8: using guessed type __int64 global_max_fast;

//----- (0000000000410ED0) ----------------------------------------------------
__int64 __fastcall dl_tunable_set_trim_threshold(__int64 *a1)
{
  __int64 result; // rax

  result = *a1;
  dword_4A8814 = 1;
  mp_ = result;
  return result;
}
// 4A87E0: using guessed type __int64 mp_;
// 4A8814: using guessed type int dword_4A8814;

//----- (0000000000410EF0) ----------------------------------------------------
__int64 __fastcall dl_tunable_set_top_pad(__int64 *a1)
{
  __int64 result; // rax

  result = *a1;
  dword_4A8814 = 1;
  qword_4A87E8 = result;
  return result;
}
// 4A87E8: using guessed type __int64 qword_4A87E8;
// 4A8814: using guessed type int dword_4A8814;

//----- (0000000000410F10) ----------------------------------------------------
__int64 __fastcall dl_tunable_set_mmap_threshold(__int64 *a1)
{
  __int64 result; // rax

  result = *a1;
  if ( (unsigned __int64)*a1 <= 0x2000000 )
  {
    dword_4A8814 = 1;
    qword_4A87F0 = result;
  }
  return result;
}
// 4A87F0: using guessed type __int64 qword_4A87F0;
// 4A8814: using guessed type int dword_4A8814;

//----- (0000000000410F40) ----------------------------------------------------
__int64 __fastcall dl_tunable_set_mmaps_max(__int64 *a1)
{
  __int64 result; // rax

  result = *a1;
  dword_4A8814 = 1;
  dword_4A880C = result;
  return result;
}
// 4A880C: using guessed type int dword_4A880C;
// 4A8814: using guessed type int dword_4A8814;

//----- (0000000000410F60) ----------------------------------------------------
__int64 __fastcall dl_tunable_set_perturb_byte(__int64 *a1)
{
  __int64 result; // rax

  result = *a1;
  perturb_byte = *a1;
  return result;
}
// 4AADB4: using guessed type int perturb_byte;

//----- (0000000000410F70) ----------------------------------------------------
void __fastcall __noreturn _malloc_assert(const char *a1, __int64 a2, unsigned int a3, __int64 a4)
{
  unsigned __int8 *v4; // rax
  void *v5; // rdi
  __int64 v6; // rdx
  __int64 v7; // rcx
  __int64 v8; // r8
  unsigned __int64 v9; // r9
  __int64 v10; // rdx
  __int64 v11; // rcx
  u32 *v12; // r8
  u32 v13; // er9

  v4 = byte_493255;
  if ( *(_BYTE *)program_invocation_short_name[0] )
    v4 = ": ";
  _fxprintf(
    0LL,
    (__int64)"%s%s%s:%u: %s%sAssertion `%s' failed.\n",
    program_invocation_short_name[0],
    v4,
    a2,
    a3,
    a4,
    ": ",
    a1);
  v5 = stderr;
  fflush((__int64)stderr, (unsigned __int64)"%s%s%s:%u: %s%sAssertion `%s' failed.\n", v6, v7, v8, v9);
  abort((__int64)v5, (__int64)"%s%s%s:%u: %s%sAssertion `%s' failed.\n", v10, v11, v12, v13);
}
// 410FBA: variable 'v6' is possibly undefined
// 410FBA: variable 'v7' is possibly undefined
// 410FBA: variable 'v8' is possibly undefined
// 410FBA: variable 'v9' is possibly undefined
// 410FBF: variable 'v10' is possibly undefined
// 410FBF: variable 'v11' is possibly undefined
// 410FBF: variable 'v12' is possibly undefined
// 410FBF: variable 'v13' is possibly undefined
// 493255: using guessed type unsigned __int8 byte_493255[1707];
// 4A8798: using guessed type void *stderr;
// 4A9168: using guessed type char (*program_invocation_short_name[2])[1707];

//----- (0000000000410FD0) ----------------------------------------------------
void __fastcall detach_arena(__int64 a1)
{
  __int64 v1; // rax

  if ( a1 )
  {
    v1 = *(_QWORD *)(a1 + 2176);
    if ( !v1 )
      _malloc_assert("replaced_arena->attached_threads > 0", (__int64)"arena.c", 0x2A3u, (__int64)"detach_arena");
    *(_QWORD *)(a1 + 2176) = v1 - 1;
  }
}

//----- (0000000000411020) ----------------------------------------------------
unsigned __int64 __fastcall get_free_list(__int64 a1, __int64 a2, __int64 a3, __int64 a4, u32 *a5, u32 a6)
{
  __int64 v8; // rdx
  bool v10; // zf

  _RBX = free_list;
  if ( !free_list )
    return _RBX;
  _ESI = 1;
  v8 = __readfsqword(0xFFFFFFD8);
  if ( !_libc_multiple_threads )
  {
    __asm { cmpxchg cs:free_list_lock, esi }
    if ( !_libc_multiple_threads )
      goto LABEL_7;
    goto LABEL_6;
  }
  if ( _InterlockedCompareExchange(&free_list_lock, 1, 0) )
LABEL_6:
    _lll_lock_wait_private((u32 *)&free_list_lock, 1LL, v8, a4, a5, a6);
LABEL_7:
  _RBX = free_list;
  if ( free_list )
  {
    v10 = *(_QWORD *)(free_list + 2176) == 0LL;
    free_list = *(_QWORD *)(free_list + 2168);
    if ( !v10 )
      _malloc_assert("result->attached_threads == 0", (__int64)"arena.c", 0x301u, (__int64)"get_free_list");
    *(_QWORD *)(_RBX + 2176) = 1LL;
    detach_arena(v8);
  }
  if ( !_libc_multiple_threads )
  {
    if ( !--free_list_lock )
      goto LABEL_15;
    goto LABEL_14;
  }
  if ( _InterlockedDecrement(&free_list_lock) )
LABEL_14:
    _lll_unlock_wake_private((u32 *)&free_list_lock, 1LL, v8, a4, a5, a6);
LABEL_15:
  if ( _RBX )
  {
    _ESI = 1;
    v10 = _libc_multiple_threads == 0;
    if ( _libc_multiple_threads )
    {
      if ( !_InterlockedCompareExchange((volatile signed __int32 *)_RBX, 1, 0) )
        goto LABEL_21;
    }
    else
    {
      __asm { cmpxchg [rbx], esi }
      if ( v10 )
      {
LABEL_21:
        __writefsqword(0xFFFFFFD8, _RBX);
        return _RBX;
      }
    }
    _lll_lock_wait_private((u32 *)_RBX, 1LL, v8, a4, a5, a6);
    goto LABEL_21;
  }
  return _RBX;
}
// 4110B7: variable 'v8' is possibly undefined
// 4110E6: variable 'a4' is possibly undefined
// 4110E6: variable 'a5' is possibly undefined
// 4110E6: variable 'a6' is possibly undefined
// 4AADA8: using guessed type __int64 free_list;
// 4AADB0: using guessed type int free_list_lock;
// 4AB820: using guessed type int _libc_multiple_threads;

//----- (0000000000411160) ----------------------------------------------------
__int64 *__fastcall malloc_printerr(__int64 a1, __int64 a2, __int64 a3, __int64 a4, u32 *a5, __int64 a6)
{
  __int64 v6; // rdx
  __int64 v7; // rcx
  u32 *v8; // r8
  __int64 v9; // r9
  char v11; // [rsp-8h] [rbp-8h]

  _libc_message(1, (size_t)"%s\n", a1, a4, a5, a6, v11);
  return top_check(1LL, (__int64)"%s\n", v6, v7, v8, v9);
}
// 411177: variable 'v11' is possibly undefined
// 41117D: variable 'v6' is possibly undefined
// 41117D: variable 'v7' is possibly undefined
// 41117D: variable 'v8' is possibly undefined
// 41117D: variable 'v9' is possibly undefined

//----- (0000000000411180) ----------------------------------------------------
__int64 *__fastcall top_check(__int64 a1, __int64 a2, __int64 a3, __int64 a4, u32 *a5, __int64 a6)
{
  __int64 *result; // rax
  __int64 v7; // rdx
  __int64 v8; // rdx
  _QWORD *v9; // rcx
  unsigned __int64 v10; // r8

  result = (__int64 *)qword_4A88E0;
  if ( (__int64 *)qword_4A88E0 != &qword_4A88E0 )
  {
    v7 = *(_QWORD *)(qword_4A88E0 + 8);
    if ( (v7 & 2) != 0
      || (a4 = v7 & 0xFFFFFFFFFFFFFFF8LL, (v7 & 0xFFFFFFFFFFFFFFF8LL) <= 0x1F)
      || (v7 = *(_QWORD *)(qword_4A88E0 + 8) & 1LL, !(_DWORD)v7)
      || (dword_4A8884 & 2) == 0
      && (result = (__int64 *)(a4 + qword_4A88E0),
          v7 = qword_4A8828 + qword_4A9108,
          a4 + qword_4A88E0 != qword_4A8828 + qword_4A9108) )
    {
      malloc_printerr((__int64)"malloc: top chunk is corrupt", a2, v7, a4, a5, a6);
      return malloc_consolidate("malloc: top chunk is corrupt", a2, v8, v9, v10);
    }
  }
  return result;
}
// 4111DF: variable 'v8' is possibly undefined
// 4111DF: variable 'v9' is possibly undefined
// 4111DF: variable 'v10' is possibly undefined
// 4A8828: using guessed type __int64 qword_4A8828;
// 4A8884: using guessed type int dword_4A8884;
// 4A88E0: using guessed type __int64 qword_4A88E0;
// 4A9108: using guessed type __int64 qword_4A9108;

//----- (00000000004111E0) ----------------------------------------------------
__int64 *__fastcall malloc_consolidate(const char *a1, __int64 a2, __int64 a3, _QWORD *a4, unsigned __int64 a5)
{
  unsigned __int64 v5; // r12
  unsigned __int64 v6; // r13
  const char *v7; // r11
  volatile __int64 *v8; // r9
  __int64 *result; // rax
  __int64 v10; // r10
  __int64 v11; // rsi
  const char *v12; // rdx
  __int64 *v13; // rbp
  unsigned __int64 v14; // rdx
  unsigned __int64 v15; // r10
  __int64 v16; // rsi
  __int64 v17; // r10
  __int64 v18; // r12

  v7 = a1 + 96;
  v8 = (volatile __int64 *)(a1 + 16);
  *((_DWORD *)a1 + 2) = 0;
  while ( 1 )
  {
    result = (__int64 *)_InterlockedExchange64(v8, 0LL);
    if ( result )
      break;
LABEL_3:
    if ( v7 == (const char *)++v8 )
      return result;
  }
  while ( 1 )
  {
    v11 = result[1];
    v12 = &a1[8 * ((unsigned int)v11 >> 4)];
    if ( v8 != (volatile __int64 *)v12 )
      break;
    v13 = (__int64 *)result[2];
    v14 = v11 & 0xFFFFFFFFFFFFFFF8LL;
    a4 = (__int64 *)((char *)result + (v11 & 0xFFFFFFFFFFFFFFF8LL));
    a5 = a4[1];
    v15 = a5 & 0xFFFFFFFFFFFFFFF8LL;
    if ( (v11 & 1) == 0 )
    {
      v16 = *result;
      result = (__int64 *)((char *)result - *result);
      v14 += v16;
      v6 = result[1];
      v5 = v6 & 0xFFFFFFFFFFFFFFF8LL;
      if ( (v6 & 0xFFFFFFFFFFFFFFF8LL) != v16 )
        goto LABEL_33;
      if ( v5 != *(__int64 *)((char *)result + v5) )
        goto LABEL_32;
      v16 = result[2];
      v5 = result[3];
      if ( *(__int64 **)(v16 + 24) != result || *(__int64 **)(v5 + 16) != result )
        goto LABEL_31;
      *(_QWORD *)(v16 + 24) = v5;
      *(_QWORD *)(v5 + 16) = v16;
      if ( v6 > 0x3FF )
      {
        v5 = result[4];
        if ( v5 )
        {
LABEL_34:
          if ( *(__int64 **)(v5 + 40) != result )
            goto LABEL_38;
          v6 = result[5];
          if ( *(__int64 **)(v6 + 32) != result )
            goto LABEL_38;
          if ( *(_QWORD *)(v16 + 32) )
          {
            *(_QWORD *)(v5 + 40) = v6;
            *(_QWORD *)(result[5] + 32) = v5;
          }
          else
          {
LABEL_39:
            if ( (__int64 *)v5 == result )
            {
              *(_QWORD *)(v16 + 40) = v16;
              *(_QWORD *)(v16 + 32) = v16;
            }
            else
            {
              *(_QWORD *)(v16 + 32) = v5;
              v18 = result[4];
              *(_QWORD *)(v16 + 40) = v6;
              *(_QWORD *)(v18 + 40) = v16;
              v5 = result[5];
              *(_QWORD *)(v5 + 32) = v16;
            }
          }
        }
      }
    }
    if ( *((_QWORD **)a1 + 12) != a4 )
    {
      v16 = (__int64)a4 + v15;
      if ( (*((_BYTE *)a4 + v15 + 8) & 1) != 0 )
      {
        a5 &= ~1uLL;
        a4[1] = a5;
        goto LABEL_10;
      }
      v14 += v15;
      if ( *(_QWORD *)v16 == v15 )
      {
        v16 = a4[2];
        v17 = a4[3];
        if ( *(_QWORD **)(v16 + 24) == a4 && *(_QWORD **)(v17 + 16) == a4 )
        {
          *(_QWORD *)(v16 + 24) = v17;
          *(_QWORD *)(v17 + 16) = v16;
          if ( a5 <= 0x3FF )
            goto LABEL_10;
          a5 = a4[4];
          if ( !a5 )
            goto LABEL_10;
          if ( *(_QWORD **)(a5 + 40) == a4 )
          {
            v10 = a4[5];
            if ( *(_QWORD **)(v10 + 32) == a4 )
            {
              if ( *(_QWORD *)(v16 + 32) )
              {
                *(_QWORD *)(a5 + 40) = v10;
                *(_QWORD *)(a4[5] + 32LL) = a5;
              }
              else if ( (_QWORD *)a5 == a4 )
              {
                *(_QWORD *)(v16 + 40) = v16;
                *(_QWORD *)(v16 + 32) = v16;
              }
              else
              {
                *(_QWORD *)(v16 + 32) = a5;
                a5 = a4[4];
                *(_QWORD *)(v16 + 40) = v10;
                *(_QWORD *)(a5 + 40) = v16;
                *(_QWORD *)(a4[5] + 32LL) = v16;
              }
LABEL_10:
              a4 = (_QWORD *)*((_QWORD *)a1 + 14);
              *((_QWORD *)a1 + 14) = result;
              a4[3] = result;
              if ( v14 > 0x3FF )
              {
                result[4] = 0LL;
                result[5] = 0LL;
              }
              result[3] = (__int64)v7;
              result[2] = (__int64)a4;
              result[1] = v14 | 1;
              *(__int64 *)((char *)result + v14) = v14;
              goto LABEL_13;
            }
          }
LABEL_38:
          a1 = "corrupted double-linked list (not small)";
          result = malloc_printerr(
                     (__int64)"corrupted double-linked list (not small)",
                     v16,
                     v14,
                     (__int64)a4,
                     (u32 *)a5,
                     (__int64)v8);
          goto LABEL_39;
        }
LABEL_31:
        malloc_printerr((__int64)"corrupted double-linked list", v16, v14, (__int64)a4, (u32 *)a5, (__int64)v8);
      }
LABEL_32:
      malloc_printerr((__int64)"corrupted size vs. prev_size", v16, v14, (__int64)a4, (u32 *)a5, (__int64)v8);
LABEL_33:
      a1 = "corrupted size vs. prev_size in fastbins";
      result = malloc_printerr(
                 (__int64)"corrupted size vs. prev_size in fastbins",
                 v16,
                 v14,
                 (__int64)a4,
                 (u32 *)a5,
                 (__int64)v8);
      goto LABEL_34;
    }
    result[1] = (v15 + v14) | 1;
    *((_QWORD *)a1 + 12) = result;
LABEL_13:
    result = v13;
    if ( !v13 )
      goto LABEL_3;
  }
  malloc_printerr(
    (__int64)"malloc_consolidate(): invalid chunk size",
    v11,
    (__int64)v12,
    (__int64)a4,
    (u32 *)a5,
    (__int64)v8);
  return (__int64 *)new_heap((unsigned __int64)"malloc_consolidate(): invalid chunk size", v11);
}
// 41120A: variable 'v8' is possibly undefined
// 411211: variable 'v7' is possibly undefined
// 411220: variable 'a4' is possibly undefined
// 411273: variable 'v14' is possibly undefined
// 41134E: variable 'v15' is possibly undefined
// 411383: variable 'a5' is possibly undefined
// 4113E8: variable 'v5' is possibly undefined
// 41142B: variable 'v6' is possibly undefined

//----- (0000000000411490) ----------------------------------------------------
unsigned __int64 __fastcall new_heap(unsigned __int64 a1, __int64 a2)
{
  unsigned __int64 v2; // rsi
  __int64 v3; // rbp
  unsigned __int64 v4; // rax
  unsigned __int64 v5; // rbx
  unsigned __int64 v6; // rax
  unsigned __int64 v7; // r13
  unsigned __int64 v9; // rax

  v2 = a1 + a2;
  if ( v2 <= 0x7FFF )
  {
    v2 = 0x8000LL;
  }
  else if ( v2 > 0x4000000 )
  {
    v2 = 0x4000000LL;
    if ( a1 > 0x4000000 )
      return 0LL;
  }
  v3 = (v2 + dl_pagesize - 1) & -dl_pagesize;
  if ( aligned_heap_area )
  {
    v4 = mmap64(aligned_heap_area, 0x4000000uLL, 0LL, 0x4022uLL, 0xFFFFFFFFuLL, 0LL);
    aligned_heap_area = 0LL;
    v5 = v4;
    if ( v4 != -1LL )
    {
      if ( (v4 & 0x3FFFFFF) == 0 )
        goto LABEL_11;
      munmap(v4, 0x4000000uLL);
    }
  }
  v6 = mmap64(0LL, 0x8000000uLL, 0LL, 0x4022uLL, 0xFFFFFFFFuLL, 0LL);
  if ( v6 != -1LL )
  {
    v5 = (v6 + 0x3FFFFFF) & 0xFFFFFFFFFC000000LL;
    v7 = v5 - v6;
    if ( v5 == v6 )
      aligned_heap_area = v5 + 0x4000000;
    else
      munmap(v6, v5 - v6);
    munmap(v5 + 0x4000000, 0x4000000 - v7);
    goto LABEL_11;
  }
  v9 = mmap64(0LL, 0x4000000uLL, 0LL, 0x4022uLL, 0xFFFFFFFFuLL, 0LL);
  v5 = v9;
  if ( v9 != -1LL )
  {
    if ( (v9 & 0x3FFFFFF) != 0 )
    {
LABEL_18:
      munmap(v5, 0x4000000uLL);
      return 0LL;
    }
LABEL_11:
    if ( !(unsigned int)mprotect(v5, v3, 3uLL) )
    {
      *(_QWORD *)(v5 + 16) = v3;
      *(_QWORD *)(v5 + 24) = v3;
      return v5;
    }
    goto LABEL_18;
  }
  return 0LL;
}
// 4A91F8: using guessed type __int64 dl_pagesize;

//----- (0000000000411630) ----------------------------------------------------
__int64 *__fastcall munmap_chunk(__int64 *a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  u32 *v6; // r8
  __int64 v7; // rsi
  unsigned __int64 v8; // rax
  unsigned __int64 v9; // rdi
  size_t v10; // rsi
  __int64 v11; // rax
  __int64 v12; // rdx

  v6 = (u32 *)(a1[1] & 0xFFFFFFFFFFFFFFF8LL);
  if ( (a1[1] & 2) == 0 )
    _malloc_assert("chunk_is_mmapped (p)", (__int64)"malloc.c", 0xB00u, (__int64)"munmap_chunk");
  v7 = *a1;
  v8 = (unsigned __int64)(a1 + 2);
  v9 = (unsigned __int64)a1 - *a1;
  v10 = (size_t)v6 + v7;
  v11 = (dl_pagesize - 1) & v8;
  v12 = (v11 - 1) & v11 | (v10 | v9) & (dl_pagesize - 1);
  if ( v12 )
  {
    malloc_printerr((__int64)"munmap_chunk(): invalid pointer", v10, v12, v11 - 1, v6, a6);
    return mremap_chunk((__int64 *)"munmap_chunk(): invalid pointer", v10);
  }
  else
  {
    _InterlockedDecrement(&dword_4A8808);
    _InterlockedAdd64(&qword_4A8818, -(__int64)v10);
    return (__int64 *)munmap(v9, v10);
  }
}
// 4A8808: using guessed type int dword_4A8808;
// 4A8818: using guessed type __int64 qword_4A8818;
// 4A91F8: using guessed type __int64 dl_pagesize;

//----- (00000000004116D0) ----------------------------------------------------
__int64 *__fastcall mremap_chunk(__int64 *a1, __int64 a2)
{
  __int64 v2; // r12
  unsigned __int64 v3; // rbp
  unsigned __int64 v4; // rax
  u32 *v5; // r8
  __int64 v6; // rbx
  unsigned __int64 v7; // rax
  unsigned __int64 v9; // rbx
  __int64 v10; // rtt

  v2 = *a1;
  if ( (a1[1] & 2) == 0 )
    _malloc_assert("chunk_is_mmapped (p)", (__int64)"malloc.c", 0xB26u, (__int64)"mremap_chunk");
  v3 = v2 + (a1[1] & 0xFFFFFFFFFFFFFFF8LL);
  v4 = (dl_pagesize - 1) & (unsigned __int64)(a1 + 2);
  v5 = (u32 *)((v4 - 1) & v4 | (dl_pagesize - 1) & (v3 | ((unsigned __int64)a1 - v2)));
  if ( v5 )
  {
    malloc_printerr((__int64)"mremap_chunk(): invalid pointer", a2, v4 - 1, dl_pagesize, v5, (__int64)a1 - v2);
    goto LABEL_16;
  }
  v6 = -dl_pagesize & (v2 + dl_pagesize + a2 + 7);
  if ( v3 == v6 )
    return a1;
  v7 = mremap((unsigned __int64)a1 - v2, v3, v6, 1uLL, 0LL);
  if ( v7 == -1LL )
    return 0LL;
  a1 = (__int64 *)(v7 + v2);
  if ( (((_BYTE)v7 + (_BYTE)v2) & 0xF) != 0 )
LABEL_16:
    _malloc_assert("aligned_OK (chunk2mem (p))", (__int64)"malloc.c", 0xB3Eu, (__int64)"mremap_chunk");
  if ( *a1 != v2 )
    _malloc_assert("prev_size (p) == offset", (__int64)"malloc.c", 0xB40u, (__int64)"mremap_chunk");
  a1[1] = (v6 - v2) | 2;
  v9 = _InterlockedExchangeAdd64(&qword_4A8818, v6 - v3) + v6 - v3;
  while ( v9 > qword_4A8820 )
  {
    v10 = qword_4A8820;
    if ( v10 == _InterlockedCompareExchange64(&qword_4A8820, v9, qword_4A8820) )
      return (__int64 *)(v7 + v2);
  }
  return a1;
}
// 4A8818: using guessed type __int64 qword_4A8818;
// 4A8820: using guessed type __int64 qword_4A8820;
// 4A91F8: using guessed type __int64 dl_pagesize;

//----- (0000000000411820) ----------------------------------------------------
unsigned __int64 ptmalloc_init_part_0()
{
  __int64 v1; // [rsp+0h] [rbp-18h] BYREF
  unsigned __int64 v2; // [rsp+8h] [rbp-10h]

  v2 = __readfsqword(0x28u);
  _libc_malloc_initialized = 0;
  __writefsqword(0xFFFFFFD8, (unsigned __int64)&main_arena);
  malloc_init_state((__int64)&main_arena);
  _tunable_get_val(0x17u, &v1, (__int64 (__fastcall *)(char **))dl_tunable_set_mallopt_check);
  _tunable_get_val(9u, &v1, (__int64 (__fastcall *)(char **))dl_tunable_set_top_pad);
  _tunable_get_val(3u, &v1, (__int64 (__fastcall *)(char **))dl_tunable_set_perturb_byte);
  _tunable_get_val(0x12u, &v1, (__int64 (__fastcall *)(char **))dl_tunable_set_mmap_threshold);
  _tunable_get_val(2u, &v1, (__int64 (__fastcall *)(char **))dl_tunable_set_trim_threshold);
  _tunable_get_val(0xAu, &v1, (__int64 (__fastcall *)(char **))dl_tunable_set_mmaps_max);
  _tunable_get_val(0x11u, &v1, (__int64 (__fastcall *)(char **))dl_tunable_set_arena_max);
  _tunable_get_val(0x14u, &v1, (__int64 (__fastcall *)(char **))dl_tunable_set_arena_test);
  _tunable_get_val(0x16u, &v1, (__int64 (__fastcall *)(char **))dl_tunable_set_tcache_max);
  _tunable_get_val(0x13u, &v1, (__int64 (__fastcall *)(char **))dl_tunable_set_tcache_count);
  _tunable_get_val(0xCu, &v1, (__int64 (__fastcall *)(char **))dl_tunable_set_tcache_unsorted_limit);
  _libc_malloc_initialized = 1;
  return __readfsqword(0x28u) ^ v2;
}
// 4A87C4: using guessed type int _libc_malloc_initialized;
// 4A8880: using guessed type int main_arena;

//----- (0000000000411960) ----------------------------------------------------
int *__fastcall arena_get2_part_4(__int64 a1, __int64 a2, __int64 a3, __int64 a4, u32 *a5, u32 a6)
{
  __int64 v6; // rax
  unsigned __int64 v7; // rdx
  signed __int32 v11; // eax
  __int64 v13; // rdx
  __int64 *v14; // rdx
  __int64 v15; // rcx
  u32 *v16; // r8
  u32 v17; // er9
  __int64 v18; // rax
  int nprocs; // eax
  bool v22; // zf
  unsigned __int64 v24; // rax
  _QWORD *v25; // r8
  __int64 v26; // r8
  u32 v27; // er9
  __int64 v28; // rax
  __int64 v29; // rdx
  __int64 v30; // rcx
  __int64 v32; // rdx
  __int64 v34; // rdx
  __int64 v35; // rcx
  u32 *v36; // r8
  u32 v37; // er9
  bool v39; // zf

  v6 = narenas_limit_12715;
  v7 = narenas;
  if ( !narenas_limit_12715 )
  {
    v6 = qword_4A8800;
    if ( qword_4A8800 )
    {
      narenas_limit_12715 = qword_4A8800;
    }
    else if ( qword_4A87F8 < (unsigned __int64)narenas )
    {
      nprocs = get_nprocs();
      if ( nprocs <= 0 )
      {
        narenas_limit_12715 = 16LL;
        v7 = narenas;
        v6 = 16LL;
      }
      else
      {
        v7 = narenas;
        v6 = 8 * nprocs;
        narenas_limit_12715 = (int)v6;
      }
    }
  }
  if ( v6 - 1 < v7 )
  {
    _RBX = (int *)next_to_use_12694;
    if ( !next_to_use_12694 )
    {
      _RBX = &main_arena;
      next_to_use_12694 = (__int64)&main_arena;
    }
    _RCX = 1LL;
    while ( 1 )
    {
      v11 = 0;
      if ( _libc_multiple_threads )
        v11 = _InterlockedCompareExchange(_RBX, 1, 0);
      else
        __asm { cmpxchg [rbx], ecx }
      if ( !v11 )
        break;
      _RBX = (int *)*((_QWORD *)_RBX + 270);
      _RDX = (volatile signed __int32 *)next_to_use_12694;
      if ( _RBX == (int *)next_to_use_12694 )
      {
        if ( a2 == next_to_use_12694 )
          _RDX = *(volatile signed __int32 **)(a2 + 2160);
        _ESI = 1;
        v22 = _libc_multiple_threads == 0;
        if ( _libc_multiple_threads )
        {
          if ( !_InterlockedCompareExchange(_RDX, 1, 0) )
            goto LABEL_43;
LABEL_42:
          _lll_lock_wait_private((u32 *)_RDX, 1LL, (__int64)_RDX, 1LL, a5, a6);
        }
        else
        {
          __asm { cmpxchg [rdx], esi }
          if ( !v22 )
            goto LABEL_42;
        }
LABEL_43:
        _RBX = (int *)_RDX;
        break;
      }
    }
    _ESI = 1;
    v13 = __readfsqword(0xFFFFFFD8);
    if ( _libc_multiple_threads )
    {
      if ( !_InterlockedCompareExchange(&free_list_lock, 1, 0) )
      {
LABEL_18:
        detach_arena(v13);
        v18 = free_list;
        if ( !free_list )
          goto LABEL_25;
        if ( *(_QWORD *)(free_list + 2176) )
LABEL_32:
          _malloc_assert("p->attached_threads == 0", (__int64)"arena.c", 0x31Bu, (__int64)"remove_from_free_list");
        if ( _RBX == (int *)free_list )
        {
          v14 = &free_list;
        }
        else
        {
          v14 = *(__int64 **)(free_list + 2168);
          if ( !v14 )
            goto LABEL_25;
          while ( 1 )
          {
            if ( v14[272] )
              goto LABEL_32;
            if ( _RBX == (int *)v14 )
              break;
            v18 = (__int64)v14;
            v14 = (__int64 *)v14[271];
            if ( !v14 )
              goto LABEL_25;
          }
          v14 = (__int64 *)(v18 + 2168);
          v18 = (__int64)_RBX;
        }
        *v14 = *(_QWORD *)(v18 + 2168);
LABEL_25:
        ++*((_QWORD *)_RBX + 272);
        if ( _libc_multiple_threads )
        {
          if ( !_InterlockedDecrement(&free_list_lock) )
            goto LABEL_30;
        }
        else if ( !--free_list_lock )
        {
LABEL_30:
          __writefsqword(0xFFFFFFD8, (unsigned __int64)_RBX);
          next_to_use_12694 = *((_QWORD *)_RBX + 270);
          return _RBX;
        }
        _lll_unlock_wake_private((u32 *)&free_list_lock, 1LL, (__int64)v14, v15, v16, v17);
        goto LABEL_30;
      }
    }
    else
    {
      __asm { cmpxchg cs:free_list_lock, esi }
      if ( !_libc_multiple_threads )
        goto LABEL_18;
    }
    _lll_lock_wait_private((u32 *)&free_list_lock, 1LL, v13, _RCX, a5, a6);
    goto LABEL_18;
  }
  _RCX = v7 + 1;
  if ( __readfsdword(0x18u) )
    __asm { lock }
  __asm { cmpxchg cs:narenas, rcx }
  v24 = new_heap(a1 + 2248, qword_4A87E8);
  v25 = (_QWORD *)v24;
  if ( v24 || (v25 = (_QWORD *)new_heap(0x8C8uLL, qword_4A87E8)) != 0LL )
  {
    _RBX = (int *)(v25 + 4);
    *v25 = v25 + 4;
    malloc_init_state((__int64)(v25 + 4));
    v28 = *(_QWORD *)(v26 + 16);
    *(_QWORD *)(v26 + 2208) = 1LL;
    v29 = v26 + 2232;
    *(_QWORD *)(v26 + 2224) = v28;
    *(_QWORD *)(v26 + 2216) = v28;
    v30 = ((_BYTE)v26 - 56) & 0xF;
    if ( (((_BYTE)v26 - 56) & 0xF) != 0 )
      v29 = v29 - v30 + 16;
    *(_QWORD *)(v26 + 128) = v29;
    *(_QWORD *)(v29 + 8) = (v26 + v28 - v29) | 1;
    _ESI = 1;
    v32 = __readfsqword(0xFFFFFFD8);
    __writefsqword(0xFFFFFFD8, (unsigned __int64)_RBX);
    *(_DWORD *)(v26 + 32) = 0;
    if ( _libc_multiple_threads )
    {
      if ( !_InterlockedCompareExchange(&list_lock, 1, 0) )
      {
LABEL_59:
        *(_QWORD *)(v26 + 2192) = off_4A90F0;
        off_4A90F0 = _RBX;
        if ( _libc_multiple_threads )
        {
          if ( !_InterlockedDecrement(&list_lock) )
          {
LABEL_64:
            _ESI = 1;
            if ( _libc_multiple_threads )
            {
              if ( !_InterlockedCompareExchange(&free_list_lock, 1, 0) )
              {
LABEL_69:
                detach_arena(v32);
                if ( _libc_multiple_threads )
                {
                  if ( !_InterlockedDecrement(&free_list_lock) )
                  {
LABEL_74:
                    _ESI = 1;
                    v39 = _libc_multiple_threads == 0;
                    if ( _libc_multiple_threads )
                    {
                      if ( !_InterlockedCompareExchange(_RBX, 1, 0) )
                      {
LABEL_79:
                        if ( _RBX )
                          return _RBX;
                        goto LABEL_80;
                      }
                    }
                    else
                    {
                      __asm { cmpxchg [rbx], esi }
                      if ( v39 )
                        goto LABEL_79;
                    }
                    _lll_lock_wait_private((u32 *)_RBX, 1LL, v34, v35, v36, v37);
                    goto LABEL_79;
                  }
                }
                else if ( !--free_list_lock )
                {
                  goto LABEL_74;
                }
                _lll_unlock_wake_private((u32 *)&free_list_lock, 1LL, v34, v35, v36, v37);
                goto LABEL_74;
              }
            }
            else
            {
              __asm { cmpxchg cs:free_list_lock, esi }
              if ( !_libc_multiple_threads )
                goto LABEL_69;
            }
            _lll_lock_wait_private((u32 *)&free_list_lock, 1LL, v32, v30, (u32 *)v26, v27);
            goto LABEL_69;
          }
        }
        else if ( !--list_lock )
        {
          goto LABEL_64;
        }
        _lll_unlock_wake_private((u32 *)&list_lock, 1LL, v32, v30, (u32 *)v26, v27);
        goto LABEL_64;
      }
    }
    else
    {
      __asm { cmpxchg cs:list_lock, esi }
      if ( !_libc_multiple_threads )
        goto LABEL_59;
    }
    _lll_lock_wait_private((u32 *)&list_lock, 1LL, v32, v30, (u32 *)v26, v27);
    goto LABEL_59;
  }
LABEL_80:
  if ( __readfsdword(0x18u) )
    __asm { lock }
  --narenas;
  return 0LL;
}
// 411A2E: variable '_RCX' is possibly undefined
// 411A2E: variable 'a5' is possibly undefined
// 411A2E: variable 'a6' is possibly undefined
// 411A3D: variable 'v13' is possibly undefined
// 411AC5: variable 'v14' is possibly undefined
// 411AC5: variable 'v15' is possibly undefined
// 411AC5: variable 'v16' is possibly undefined
// 411AC5: variable 'v17' is possibly undefined
// 411B81: variable '_RDX' is possibly undefined
// 411C68: variable 'v26' is possibly undefined
// 411D05: variable 'v27' is possibly undefined
// 411D50: variable 'v32' is possibly undefined
// 411D50: variable 'v30' is possibly undefined
// 411DCB: variable 'v34' is possibly undefined
// 411DCB: variable 'v35' is possibly undefined
// 411DCB: variable 'v36' is possibly undefined
// 411DCB: variable 'v37' is possibly undefined
// 4A87C8: using guessed type __int64 narenas;
// 4A87E8: using guessed type __int64 qword_4A87E8;
// 4A87F8: using guessed type __int64 qword_4A87F8;
// 4A8800: using guessed type __int64 qword_4A8800;
// 4A8880: using guessed type int main_arena;
// 4A90F0: using guessed type int *off_4A90F0;
// 4AAD80: using guessed type __int64 next_to_use_12694;
// 4AAD88: using guessed type __int64 narenas_limit_12715;
// 4AADA0: using guessed type int list_lock;
// 4AADA8: using guessed type __int64 free_list;
// 4AADB0: using guessed type int free_list_lock;
// 4AB820: using guessed type int _libc_multiple_threads;

//----- (0000000000411E50) ----------------------------------------------------
u32 *__fastcall arena_get_retry(volatile signed __int32 *a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, u32 a6)
{
  u32 *v6; // r8
  bool v7; // zf
  u32 *result; // rax
  __int64 v10; // rdx
  __int64 v11; // rcx
  u32 *v12; // r8
  u32 v13; // er9

  v6 = (u32 *)&main_arena;
  if ( a1 != &main_arena )
  {
    if ( _libc_multiple_threads )
    {
      if ( !_InterlockedDecrement(a1) )
      {
LABEL_7:
        _ESI = 1;
        if ( _libc_multiple_threads )
        {
          if ( !_InterlockedCompareExchange(&main_arena, 1, 0) )
            return v6;
        }
        else
        {
          __asm { cmpxchg cs:main_arena, esi }
          if ( !_libc_multiple_threads )
            return v6;
        }
        _lll_lock_wait_private((u32 *)&main_arena, 1LL, a3, a4, v6, a6);
        return v6;
      }
    }
    else
    {
      v7 = (*a1)-- == 1;
      if ( v7 )
        goto LABEL_7;
    }
    _lll_unlock_wake_private((u32 *)a1, a2, a3, a4, (u32 *)&main_arena, a6);
    goto LABEL_7;
  }
  if ( !_libc_multiple_threads )
  {
    v7 = (*a1)-- == 1;
    if ( v7 )
      goto LABEL_19;
    goto LABEL_18;
  }
  if ( _InterlockedDecrement(a1) )
LABEL_18:
    _lll_unlock_wake_private((u32 *)a1, a2, a3, a4, (u32 *)&main_arena, a6);
LABEL_19:
  result = (u32 *)get_free_list((__int64)a1, a2, a3, a4, v6, a6);
  if ( !result )
    return (u32 *)arena_get2_part_4(a2, (__int64)a1, v10, v11, v12, v13);
  return result;
}
// 411EC3: variable 'a3' is possibly undefined
// 411EC3: variable 'a4' is possibly undefined
// 411EC3: variable 'v6' is possibly undefined
// 411EC3: variable 'a6' is possibly undefined
// 411F23: variable 'v10' is possibly undefined
// 411F23: variable 'v11' is possibly undefined
// 411F23: variable 'v12' is possibly undefined
// 411F23: variable 'v13' is possibly undefined
// 4A8880: using guessed type int main_arena;
// 4AB820: using guessed type int _libc_multiple_threads;

//----- (0000000000411F30) ----------------------------------------------------
__int64 (__fastcall *__fastcall dl_tunable_set_mallopt_check(
        unsigned int *a1))(unsigned __int64 a1, int *a2, __int64 a3, __int64 a4, u32 *a5, __int64 a6, double a7)
{
  __int64 (__fastcall *result)(unsigned __int64, int *, __int64, __int64, u32 *, __int64, double); // rax

  result = (__int64 (__fastcall *)(unsigned __int64, int *, __int64, __int64, u32 *, __int64, double))*a1;
  if ( (_DWORD)result )
  {
    using_malloc_checking = 1;
    _malloc_hook = (__int64 (__fastcall *)(_QWORD, _QWORD))malloc_check;
    _free_hook = (__int64 (__fastcall *)(_QWORD, _QWORD))free_check;
    _realloc_hook = (__int64 (__fastcall *)(_QWORD, _QWORD, _QWORD))realloc_check;
    result = memalign_check;
    _memalign_hook = (__int64 (__fastcall *)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, double))memalign_check;
  }
  return result;
}
// 4A8860: using guessed type __int64 (__fastcall *_memalign_hook)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, double);
// 4A8868: using guessed type __int64 (__fastcall *_realloc_hook)(_QWORD, _QWORD, _QWORD);
// 4A8870: using guessed type __int64 (__fastcall *_malloc_hook)(_QWORD, _QWORD);
// 4AAD78: using guessed type __int64 (__fastcall *_free_hook)(_QWORD, _QWORD);
// 4AAD90: using guessed type int using_malloc_checking;

//----- (0000000000411F80) ----------------------------------------------------
__int64 __fastcall _malloc_info_part_8(__int64 a1)
{
  __int64 v1; // rdx
  __int64 v3; // rdx
  __int64 v4; // rcx
  u32 *v5; // r8
  u32 v6; // er9
  bool v9; // zf
  size_t *v10; // rcx
  __int64 *v11; // rsi
  __int64 v12; // r9
  __int64 v13; // r10
  char *v14; // rbx
  __int64 v15; // r8
  size_t v16; // rdx
  size_t v17; // rdx
  __int64 v18; // rax
  unsigned __int64 v19; // rdi
  __int64 v20; // r13
  __int64 v21; // r10
  size_t *v22; // rdi
  int *v23; // r9
  size_t v24; // r14
  size_t v25; // r14
  __int64 v26; // rdx
  unsigned __int64 v27; // rsi
  size_t v28; // rbp
  unsigned __int64 v29; // rax
  __int64 v30; // rbp
  __int64 v31; // r9
  __int64 v33; // rsi
  _QWORD *v34; // rax
  __int64 v35; // rax
  int *v36; // [rsp+0h] [rbp-11E8h]
  __int64 v37; // [rsp+8h] [rbp-11E0h]
  __int64 v38; // [rsp+10h] [rbp-11D8h]
  unsigned int v39; // [rsp+24h] [rbp-11C4h]
  __int64 v40; // [rsp+28h] [rbp-11C0h]
  __int64 v41; // [rsp+30h] [rbp-11B8h]
  __int64 v42; // [rsp+38h] [rbp-11B0h]
  __int64 v43; // [rsp+40h] [rbp-11A8h]
  __int64 v44; // [rsp+48h] [rbp-11A0h]
  __int64 v45; // [rsp+50h] [rbp-1198h]
  __int64 v46; // [rsp+58h] [rbp-1190h]
  __int64 v47; // [rsp+60h] [rbp-1188h]
  __int64 v48; // [rsp+68h] [rbp-1180h]
  size_t v49; // [rsp+70h] [rbp-1178h]
  __int64 v50; // [rsp+78h] [rbp-1170h]
  char v51[312]; // [rsp+80h] [rbp-1168h] BYREF
  size_t v52[3]; // [rsp+1C0h] [rbp-1028h] BYREF
  size_t v53; // [rsp+1D8h] [rbp-1010h]
  _QWORD v54[9]; // [rsp+11A0h] [rbp-48h] BYREF

  v1 = 0LL;
  v54[1] = __readfsqword(0x28u);
  v47 = 0LL;
  v36 = &main_arena;
  v46 = 0LL;
  v45 = 0LL;
  v44 = 0LL;
  v41 = 0LL;
  v43 = 0LL;
  v40 = 0LL;
  v42 = 0LL;
  do
  {
    v39 = v1 + 1;
    fprintf(a1, (unsigned __int64)"<heap nr=\"%d\">\n<sizes>\n", v1);
    _ESI = 1;
    _RBX = v36;
    v9 = _libc_multiple_threads == 0;
    if ( !_libc_multiple_threads )
    {
      __asm { cmpxchg [rbx], esi }
      if ( v9 )
        goto LABEL_7;
LABEL_6:
      _lll_lock_wait_private((u32 *)v36, 1LL, v3, v4, v5, v6);
      goto LABEL_7;
    }
    if ( _InterlockedCompareExchange(v36, 1, 0) )
      goto LABEL_6;
LABEL_7:
    v10 = (size_t *)v51;
    v11 = (__int64 *)(v36 + 4);
    v12 = 0LL;
    v13 = 0LL;
    v14 = v51;
    v15 = (__int64)v52;
    do
    {
      v18 = *v11;
      if ( *v11 )
      {
        v16 = 0LL;
        v19 = *(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8LL;
        do
        {
          v18 = *(_QWORD *)(v18 + 16);
          ++v16;
        }
        while ( v18 );
        v12 += v16;
        v10[1] = v19;
        v10[3] = v16;
        v13 += v16 * v19;
        *v10 = v19 - 15;
      }
      else
      {
        v10[3] = 0LL;
        v16 = 0LL;
        v10[1] = 0LL;
        *v10 = 0LL;
      }
      v17 = v10[1] * v16;
      v10 += 4;
      ++v11;
      *(v10 - 2) = v17;
    }
    while ( v10 != v52 );
    v37 = v12;
    v20 = 0LL;
    v38 = v13;
    v21 = 0LL;
    v22 = v52;
    v23 = v36 + 24;
    do
    {
      v26 = *((_QWORD *)v23 + 2);
      *v22 = -1LL;
      v22[3] = 0LL;
      v22[2] = 0LL;
      v22[1] = 0LL;
      if ( !v26 || (int *)v26 == v23 )
        goto LABEL_15;
      v15 = 1LL;
      v10 = 0LL;
      v27 = -1LL;
      v28 = 0LL;
      while ( 1 )
      {
        v29 = *(_QWORD *)(v26 + 8);
        v26 = *(_QWORD *)(v26 + 16);
        v28 += v29;
        if ( v27 > v29 )
          v27 = v29;
        if ( (unsigned __int64)v10 < v29 )
          v10 = (size_t *)v29;
        if ( (int *)v26 == v23 )
          break;
        ++v15;
      }
      v22[3] = v15;
      v20 += v15;
      v22[2] = v28;
      *v22 = v27;
      v22[1] = (size_t)v10;
      if ( !v15 )
LABEL_15:
        *v22 = 0LL;
      v24 = v22[2];
      v22 += 4;
      v23 += 4;
      v25 = v21 + v24;
      v21 = v25;
    }
    while ( v22 != v54 );
    if ( v36 == &main_arena )
    {
      v50 = 0LL;
      v49 = 0LL;
      v48 = 0LL;
    }
    else
    {
      v33 = 0LL;
      v10 = 0LL;
      v26 = 0LL;
      v34 = (_QWORD *)(*((_QWORD *)v36 + 12) & 0xFFFFFFFFFC000000LL);
      do
      {
        v26 += v34[2];
        v10 = (size_t *)((char *)v10 + v34[3]);
        ++v33;
        v34 = (_QWORD *)v34[1];
      }
      while ( v34 );
      v48 = v26;
      v49 = (size_t)v10;
      v50 = v33;
    }
    if ( _libc_multiple_threads )
    {
      if ( !_InterlockedDecrement(v36) )
        goto LABEL_35;
LABEL_34:
      _lll_unlock_wake_private((u32 *)v36, (__int64)v36, v26, (__int64)v10, (u32 *)v15, (u32)v23);
      goto LABEL_35;
    }
    v9 = (*v36)-- == 1;
    if ( !v9 )
      goto LABEL_34;
LABEL_35:
    v42 += v20;
    v30 = 0LL;
    v40 += v37;
    v43 += v25;
    v41 += v38;
    do
    {
      v31 = *((_QWORD *)v14 + 3);
      if ( v30 != 10 && v31 )
        fprintf(
          a1,
          (unsigned __int64)"\t\t\t\t\t\t\t        <size from=\"%zu\" to=\"%zu\" total=\"%zu\" count=\"%zu\"/>\n",
          *(_QWORD *)v14,
          *((_QWORD *)v14 + 1),
          *((_QWORD *)v14 + 2),
          v31);
      ++v30;
      v14 += 32;
    }
    while ( v30 != 137 );
    if ( v53 )
      fprintf(
        a1,
        (unsigned __int64)"  <unsorted from=\"%zu\" to=\"%zu\" total=\"%zu\" count=\"%zu\"/>\n",
        v52[0],
        v52[1],
        v52[2],
        v53);
    v44 += *((_QWORD *)v36 + 273);
    v45 += *((_QWORD *)v36 + 274);
    fprintf(
      a1,
      (unsigned __int64)"</sizes>\n"
                        "<total type=\"fast\" count=\"%zu\" size=\"%zu\"/>\n"
                        "<total type=\"rest\" count=\"%zu\" size=\"%zu\"/>\n"
                        "<system type=\"current\" size=\"%zu\"/>\n"
                        "<system type=\"max\" size=\"%zu\"/>\n",
      v37,
      v38,
      v20,
      v25,
      *((_QWORD *)v36 + 273),
      *((_QWORD *)v36 + 274));
    if ( v36 == &main_arena )
    {
      fprintf(
        a1,
        (unsigned __int64)"<aspace type=\"total\" size=\"%zu\"/>\n<aspace type=\"mprotect\" size=\"%zu\"/>\n",
        *((_QWORD *)v36 + 273),
        *((_QWORD *)v36 + 273));
      v35 = *((_QWORD *)v36 + 273);
      v46 += v35;
      v47 += v35;
    }
    else
    {
      fprintf(
        a1,
        (unsigned __int64)"<aspace type=\"total\" size=\"%zu\"/>\n"
                          "<aspace type=\"mprotect\" size=\"%zu\"/>\n"
                          "<aspace type=\"subheaps\" size=\"%zu\"/>\n",
        v48,
        v49,
        v50);
      v46 += v48;
      v47 += v49;
    }
    fputs((__int64)"</heap>\n", a1);
    v1 = v39;
    v36 = (int *)*((_QWORD *)v36 + 270);
  }
  while ( v36 != &main_arena );
  fprintf(
    a1,
    (unsigned __int64)"<total type=\"fast\" count=\"%zu\" size=\"%zu\"/>\n"
                      "<total type=\"rest\" count=\"%zu\" size=\"%zu\"/>\n"
                      "<total type=\"mmap\" count=\"%d\" size=\"%zu\"/>\n"
                      "<system type=\"current\" size=\"%zu\"/>\n"
                      "<system type=\"max\" size=\"%zu\"/>\n"
                      "<aspace type=\"total\" size=\"%zu\"/>\n"
                      "<aspace type=\"mprotect\" size=\"%zu\"/>\n"
                      "</malloc>\n",
    v40,
    v41,
    v42,
    v43,
    (unsigned int)dword_4A8808,
    qword_4A8818,
    v44,
    v45,
    v46,
    v47);
  return 0LL;
}
// 41205F: variable 'v3' is possibly undefined
// 41205F: variable 'v4' is possibly undefined
// 41205F: variable 'v5' is possibly undefined
// 41205F: variable 'v6' is possibly undefined
// 4A8808: using guessed type int dword_4A8808;
// 4A8818: using guessed type __int64 qword_4A8818;
// 4A8880: using guessed type int main_arena;
// 4AB820: using guessed type int _libc_multiple_threads;

//----- (0000000000412480) ----------------------------------------------------
__int64 __fastcall systrim_isra_1_constprop_9(unsigned __int64 a1, __int64 a2)
{
  unsigned __int64 v2; // rbx
  __int64 v3; // rbp
  __int64 v4; // r12
  __int64 v6; // rax
  __int64 v7; // r12

  v2 = *(_QWORD *)(qword_4A88E0 + 8) & 0xFFFFFFFFFFFFFFF8LL;
  if ( v2 - 33 <= a1 )
    return 0LL;
  v3 = (v2 - 33 - a1) & -dl_pagesize;
  if ( !v3 )
    return 0LL;
  v4 = _morecore(0LL);
  if ( v4 != v2 + qword_4A88E0 )
    return 0LL;
  _morecore(-v3);
  if ( _after_morecore_hook )
    _after_morecore_hook(-v3, a2);
  v6 = _morecore(0LL);
  if ( !v6 )
    return 0LL;
  v7 = v4 - v6;
  if ( !v7 )
    return 0LL;
  qword_4A9108 -= v7;
  *(_QWORD *)(qword_4A88E0 + 8) = (v2 - v7) | 1;
  return 1LL;
}
// 4A88E0: using guessed type __int64 qword_4A88E0;
// 4A9108: using guessed type __int64 qword_4A9108;
// 4A9118: using guessed type __int64 (__fastcall *_morecore)(_QWORD);
// 4A91F8: using guessed type __int64 dl_pagesize;
// 4AAD70: using guessed type __int64 (__fastcall *_after_morecore_hook)(_QWORD, _QWORD);

//----- (0000000000412530) ----------------------------------------------------
unsigned __int64 __fastcall int_free(
        __int64 a1,
        unsigned __int64 _RSI,
        unsigned __int64 a3,
        __int64 a4,
        unsigned __int64 a5,
        unsigned __int64 a6)
{
  _QWORD *v8; // r13
  int v9; // er14
  unsigned __int64 v10; // r15
  __int64 v11; // rax
  unsigned __int64 v12; // rbp
  unsigned __int64 v13; // rcx
  unsigned __int64 v14; // rax
  char *v15; // r8
  unsigned __int64 v16; // rax
  unsigned __int8 v17; // al
  __int64 v18; // rax
  unsigned __int64 v19; // rcx
  __int64 v20; // rdx
  __int64 *v22; // rax
  unsigned __int64 v23; // rax
  __int64 v24; // rax
  _QWORD *v25; // rax
  __int64 *v26; // rax
  __int64 v27; // rax
  unsigned __int64 v28; // rdx
  bool v30; // zf
  unsigned __int64 v31; // rax
  __int64 v32; // rax
  unsigned __int64 v34; // rax
  __int64 *v35; // r10
  _QWORD *v36; // rcx
  bool v37; // zf
  __int64 v38; // rdi
  _QWORD *v39; // rax
  __int64 v40; // rax
  __int64 v41; // rdi
  __int64 v42; // r11
  __int64 v43; // r11
  unsigned __int64 v44; // rdi
  _QWORD *v45; // rax
  __int64 v46; // r11
  __int64 v47; // rdx
  __int64 v48; // rax
  unsigned __int64 v49; // rax
  __int64 v50; // rax
  unsigned __int64 v51; // rbp
  __int64 v52; // r15
  bool v53; // al
  unsigned __int64 v54; // rdi
  __int64 *v55; // r10
  __int64 v56; // rdi
  int v57; // er13
  signed int v58; // eax
  __int64 v59; // rsi
  __int64 v60; // [rsp+0h] [rbp-68h]
  unsigned __int64 v61; // [rsp+0h] [rbp-68h]
  unsigned __int64 v62; // [rsp+8h] [rbp-60h]
  __int64 *v63; // [rsp+8h] [rbp-60h]
  __int64 *v64; // [rsp+8h] [rbp-60h]
  unsigned int v65; // [rsp+8h] [rbp-60h]
  unsigned __int64 v66; // [rsp+10h] [rbp-58h]
  __int64 *v67; // [rsp+10h] [rbp-58h]
  unsigned __int64 v68; // [rsp+18h] [rbp-50h]
  char v69; // [rsp+27h] [rbp-41h] BYREF
  unsigned __int64 v70; // [rsp+28h] [rbp-40h]

  v70 = __readfsqword(0x28u);
  v11 = *(_QWORD *)(_RSI + 8);
  v12 = v11 & 0xFFFFFFFFFFFFFFF8LL;
  v13 = -(__int64)(v11 & 0xFFFFFFFFFFFFFFF8LL);
  if ( _RSI > v13 || (_RBX = (__int64 *)_RSI, (_RSI & 0xF) != 0) )
  {
    malloc_printerr((__int64)"free(): invalid pointer", _RSI, a3, v13, (u32 *)a5, a6);
LABEL_60:
    malloc_printerr((__int64)"free(): invalid size", _RSI, a3, v13, (u32 *)a5, a6);
    goto LABEL_61;
  }
  if ( v12 <= 0x1F || (v11 & 8) != 0 )
    goto LABEL_60;
  v14 = __readfsqword(0xFFFFFFC8);
  _R12 = a1;
  if ( v14 )
  {
    _RSI = (v12 - 17) >> 4;
    if ( qword_4A8830 > _RSI )
    {
      a5 = (unsigned __int64)(_RBX + 2);
      if ( v14 == _RBX[3] )
      {
        v14 = __readfsqword(0xFFFFFFC8);
        v36 = *(_QWORD **)(v14 + 8 * _RSI + 64);
        if ( v36 )
        {
          while ( (_QWORD *)a5 != v36 )
          {
            v36 = (_QWORD *)*v36;
            if ( !v36 )
              goto LABEL_8;
          }
          malloc_printerr((__int64)"free(): double free detected in tcache 2", _RSI, a3, (__int64)v36, (u32 *)a5, a6);
          goto LABEL_103;
        }
      }
LABEL_8:
      a6 = *(char *)(v14 + _RSI);
      v13 = a6;
      if ( a6 < qword_4A8840 )
      {
        if ( v12 - 17 > 0x3FF )
          _malloc_assert("tc_idx < TCACHE_MAX_BINS", (__int64)"malloc.c", 0xB6Eu, (__int64)"tcache_put");
        v28 = v14 + 8 * _RSI;
        _RBX[3] = v14;
        _RBX[2] = *(_QWORD *)(v28 + 64);
        *(_QWORD *)(v28 + 64) = a5;
        *(_BYTE *)(v14 + _RSI) = a6 + 1;
        return __readfsqword(0x28u) ^ v70;
      }
    }
  }
  if ( v12 <= global_max_fast )
  {
    v15 = (char *)_RBX + v12;
    v16 = *(__int64 *)((char *)_RBX + v12 + 8);
    if ( v16 > 0x10 && (v16 & 0xFFFFFFFFFFFFFFF8LL) < *(_QWORD *)(a1 + 2184) )
    {
LABEL_12:
      v17 = perturb_byte;
      if ( !perturb_byte )
      {
LABEL_13:
        *(_DWORD *)(_R12 + 8) = 1;
        v12 = (unsigned int)v12 >> 4;
        _RSI = (unsigned int)(v12 - 2);
        v18 = _R12 + 8 * _RSI;
        v19 = *(_QWORD *)(v18 + 16);
        if ( _libc_multiple_threads )
          goto LABEL_84;
        if ( _RBX != (__int64 *)v19 )
        {
          _RBX[2] = v19;
          *(_QWORD *)(v18 + 16) = _RBX;
          while ( v19 )
          {
            v20 = a3 & 1;
            if ( !(_DWORD)v20 || (_DWORD)v12 == (unsigned int)*(_QWORD *)(v19 + 8) >> 4 )
              break;
            malloc_printerr((__int64)"invalid fastbin entry (free)", _RSI, v20, v19, (u32 *)v15, a6);
LABEL_83:
            malloc_printerr((__int64)"corrupted double-linked list", _RSI, a3, v13, (u32 *)a5, a6);
LABEL_84:
            if ( _RBX == (__int64 *)v19 )
              goto LABEL_88;
            _RDI = _R12 + 8 * _RSI + 16;
            _RBX[2] = v19;
            if ( __readfsdword(0x18u) )
              __asm { lock }
            __asm { cmpxchg [rdi], rbx }
            _RSI = v19;
          }
          return __readfsqword(0x28u) ^ v70;
        }
LABEL_88:
        malloc_printerr((__int64)"double free or corruption (fasttop)", _RSI, a3, v19, (u32 *)v15, a6);
        goto LABEL_89;
      }
LABEL_91:
      v34 = 0x101010101010101LL * v17;
      _RBX[2] = v34;
      *(__int64 *)((char *)_RBX + (unsigned int)(v12 - 16) + 8) = v34;
      memset64(
        (void *)((unsigned __int64)(_RBX + 3) & 0xFFFFFFFFFFFFFFF8LL),
        v34,
        ((unsigned int)_RBX - (((_DWORD)_RBX + 24) & 0xFFFFFFF8) + (unsigned int)v12) >> 3);
      goto LABEL_13;
    }
LABEL_61:
    if ( (_DWORD)a3 )
    {
LABEL_75:
      v26 = malloc_printerr((__int64)"free(): invalid next size (fast)", _RSI, a3, v13, (u32 *)v15, a6);
LABEL_76:
      a3 = (unsigned __int64)v26 & 0xFFFFFFFFFFFFFFF8LL;
      if ( a3 == *(_QWORD *)((char *)v8 + a3) )
      {
        a3 = v8[2];
        v13 = v8[3];
        if ( *(_QWORD **)(a3 + 24) != v8 || *(_QWORD **)(v13 + 16) != v8 )
          goto LABEL_83;
        *(_QWORD *)(a3 + 24) = v13;
        *(_QWORD *)(v13 + 16) = a3;
        if ( (unsigned __int64)v26 > 0x3FF )
        {
          v32 = v8[4];
          if ( v32 )
          {
            if ( *(_QWORD **)(v32 + 40) != v8 )
              goto LABEL_144;
            v13 = v8[5];
            if ( *(_QWORD **)(v13 + 32) != v8 )
              goto LABEL_144;
            if ( *(_QWORD *)(a3 + 32) )
            {
              *(_QWORD *)(v32 + 40) = v13;
              *(_QWORD *)(v8[5] + 32LL) = v32;
            }
            else if ( (_QWORD *)v32 == v8 )
            {
              *(_QWORD *)(a3 + 40) = a3;
              *(_QWORD *)(a3 + 32) = a3;
            }
            else
            {
              *(_QWORD *)(a3 + 32) = v32;
              v48 = v8[4];
              *(_QWORD *)(a3 + 40) = v13;
              *(_QWORD *)(v48 + 40) = a3;
              *(_QWORD *)(v8[5] + 32LL) = a3;
            }
          }
        }
        v12 += v10;
LABEL_44:
        v27 = *(_QWORD *)(_R12 + 112);
        a3 = _R12 + 96;
        if ( *(_QWORD *)(v27 + 24) == _R12 + 96 )
        {
          _RBX[2] = v27;
          _RBX[3] = a3;
          if ( v12 > 0x3FF )
          {
            _RBX[4] = 0LL;
            _RBX[5] = 0LL;
          }
          *(_QWORD *)(_R12 + 112) = _RBX;
          *(_QWORD *)(v27 + 24) = _RBX;
          _RBX[1] = v12 | 1;
          *(__int64 *)((char *)_RBX + v12) = v12;
          goto LABEL_48;
        }
LABEL_125:
        malloc_printerr((__int64)"free(): corrupted unsorted chunks", _RSI, a3, v13, (u32 *)a5, a6);
        goto LABEL_126;
      }
LABEL_114:
      malloc_printerr((__int64)"corrupted size vs. prev_size", _RSI, a3, v13, (u32 *)a5, a6);
      goto LABEL_115;
    }
    _ESI = 1;
    v30 = _libc_multiple_threads == 0;
    if ( _libc_multiple_threads )
    {
      if ( !_InterlockedCompareExchange((volatile signed __int32 *)_R12, 1, 0) )
      {
LABEL_67:
        v31 = *((_QWORD *)v15 + 1);
        _RSI = 1LL;
        if ( v31 > 0x10 )
          _RSI = (v31 & 0xFFFFFFFFFFFFFFF8LL) >= *(_QWORD *)(_R12 + 2184);
        if ( _libc_multiple_threads )
        {
          if ( !_InterlockedDecrement((volatile signed __int32 *)_R12) )
          {
LABEL_74:
            if ( !(_DWORD)_RSI )
              goto LABEL_12;
            goto LABEL_75;
          }
        }
        else
        {
          v30 = (*(_DWORD *)_R12)-- == 1;
          if ( v30 )
            goto LABEL_74;
        }
        _lll_unlock_wake_private((u32 *)_R12, _RSI, a3, v13, (u32 *)v15, a6);
        goto LABEL_74;
      }
    }
    else
    {
      __asm { cmpxchg [r12], esi }
      if ( v30 )
        goto LABEL_67;
    }
    _lll_lock_wait_private((u32 *)_R12, 1LL, a3, v13, (u32 *)v15, a6);
    goto LABEL_67;
  }
  if ( (_RBX[1] & 2) != 0 )
  {
    munmap_chunk(_RBX, _RSI, a3, v13, a5, a6);
    return __readfsqword(0x28u) ^ v70;
  }
  if ( !_libc_multiple_threads || (a3 &= 1u, (_DWORD)a3) )
  {
    v9 = 1;
    goto LABEL_24;
  }
  _RSI = 1LL;
  v37 = _libc_multiple_threads == 0;
  if ( _libc_multiple_threads )
  {
    if ( !_InterlockedCompareExchange((volatile signed __int32 *)a1, 1, 0) )
      goto LABEL_113;
    goto LABEL_112;
  }
  __asm { cmpxchg [r12], esi }
  if ( !v37 )
LABEL_112:
    _lll_lock_wait_private((u32 *)a1, 1LL, a3, v13, (u32 *)a5, a6);
LABEL_113:
  v9 = 0;
LABEL_24:
  v22 = *(__int64 **)(a1 + 96);
  v8 = (__int64 *)((char *)_RBX + v12);
  if ( v22 != _RBX )
  {
    if ( (*(_BYTE *)(a1 + 4) & 2) != 0 )
      goto LABEL_26;
    goto LABEL_104;
  }
LABEL_103:
  v22 = malloc_printerr((__int64)"double free or corruption (top)", _RSI, a3, v13, (u32 *)a5, a6);
LABEL_104:
  a3 = v22[1] & 0xFFFFFFFFFFFFFFF8LL;
  if ( v8 >= (__int64 *)((char *)v22 + a3) )
  {
    malloc_printerr((__int64)"double free or corruption (out)", _RSI, a3, v13, (u32 *)a5, a6);
    goto LABEL_106;
  }
LABEL_26:
  v23 = v8[1];
  if ( (v23 & 1) == 0 )
  {
LABEL_106:
    malloc_printerr((__int64)"double free or corruption (!prev)", _RSI, a3, v13, (u32 *)a5, a6);
LABEL_107:
    j_memset_ifunc(_RBX + 2, _RSI, v12 - 16);
    goto LABEL_30;
  }
  v10 = v23 & 0xFFFFFFFFFFFFFFF8LL;
  if ( v23 <= 0x10 || *(_QWORD *)(a1 + 2184) <= v10 )
  {
    v17 = (unsigned __int8)malloc_printerr((__int64)"free(): invalid next size (normal)", _RSI, a3, v13, (u32 *)a5, a6);
    goto LABEL_91;
  }
  _RSI = (unsigned int)perturb_byte;
  if ( perturb_byte )
    goto LABEL_107;
LABEL_30:
  if ( (_RBX[1] & 1) == 0 )
  {
    v24 = *_RBX;
    _RBX = (__int64 *)((char *)_RBX - *_RBX);
    v12 += v24;
    v13 = _RBX[1];
    a3 = v13 & 0xFFFFFFFFFFFFFFF8LL;
    if ( (v13 & 0xFFFFFFFFFFFFFFF8LL) != v24 )
    {
      malloc_printerr((__int64)"corrupted size vs. prev_size while consolidating", _RSI, a3, v13, (u32 *)a5, a6);
      goto LABEL_125;
    }
    if ( a3 != *(__int64 *)((char *)_RBX + a3) )
      goto LABEL_114;
    v25 = (_QWORD *)_RBX[2];
    a3 = _RBX[3];
    if ( (__int64 *)v25[3] != _RBX || *(__int64 **)(a3 + 16) != _RBX )
      goto LABEL_83;
    v25[3] = a3;
    *(_QWORD *)(a3 + 16) = v25;
    if ( v13 > 0x3FF )
    {
      a3 = _RBX[4];
      if ( a3 )
      {
        if ( *(__int64 **)(a3 + 40) != _RBX )
          goto LABEL_144;
        v13 = _RBX[5];
        if ( *(__int64 **)(v13 + 32) != _RBX )
          goto LABEL_144;
        if ( v25[4] )
        {
          *(_QWORD *)(a3 + 40) = v13;
          *(_QWORD *)(_RBX[5] + 32) = a3;
        }
        else if ( (__int64 *)a3 == _RBX )
        {
          v25[5] = v25;
          v25[4] = v25;
        }
        else
        {
          v25[4] = a3;
          v47 = _RBX[4];
          v25[5] = v13;
          *(_QWORD *)(v47 + 40) = v25;
          a3 = _RBX[5];
          *(_QWORD *)(a3 + 32) = v25;
        }
      }
    }
  }
  if ( *(_QWORD **)(a1 + 96) != v8 )
  {
    v26 = (__int64 *)v8[1];
    if ( (*((_BYTE *)v8 + v10 + 8) & 1) != 0 )
    {
      v8[1] = (unsigned __int64)v26 & 0xFFFFFFFFFFFFFFFELL;
      goto LABEL_44;
    }
    goto LABEL_76;
  }
LABEL_89:
  v12 += v10;
  _RBX[1] = v12 | 1;
  *(_QWORD *)(_R12 + 96) = _RBX;
LABEL_48:
  if ( v12 <= 0xFFFF )
    goto LABEL_49;
  if ( *(_DWORD *)(_R12 + 8) )
    malloc_consolidate((const char *)_R12, _RSI, a3, (_QWORD *)v13, a5);
  if ( (int *)_R12 == &main_arena )
  {
    if ( (*(_QWORD *)(*(_QWORD *)(_R12 + 96) + 8LL) & 0xFFFFFFFFFFFFFFF8LL) >= mp_ )
      systrim_isra_1_constprop_9(qword_4A87E8, _RSI);
    goto LABEL_49;
  }
  v35 = *(__int64 **)(_R12 + 96);
  _RBX = (__int64 *)((unsigned __int64)v35 & 0xFFFFFFFFFC000000LL);
  if ( *(_QWORD *)((unsigned __int64)v35 & 0xFFFFFFFFFC000000LL) != _R12 )
    _malloc_assert("heap->ar_ptr == av", (__int64)"malloc.c", 0x1144u, (__int64)"_int_free");
LABEL_115:
  a3 = qword_4A87E8;
  v10 = dl_pagesize;
  if ( v35 == _RBX + 4 )
  {
    v12 = _RBX[1];
    _RSI = *(_QWORD *)(v12 + 16);
    v38 = ((_BYTE)v12 + (_BYTE)_RSI - 16) & 0xF;
    v39 = (_QWORD *)(v12 + _RSI - 16 - v38);
    if ( v39[1] == 1LL )
    {
      a5 = 0x4000000LL;
      v13 = qword_4A87E8 + dl_pagesize + 32;
      a6 = dl_pagesize - 1;
      while ( 1 )
      {
        v8 = (_QWORD *)((char *)v39 - *v39);
        v40 = v8[1];
        v41 = (v40 & 0xFFFFFFFFFFFFFFF8LL) + v38;
        if ( (unsigned __int64)(v41 + 15) > 0x3E )
          _malloc_assert(
            "new_size > 0 && new_size < (long) (2 * MINSIZE)",
            (__int64)"arena.c",
            0x267u,
            (__int64)"heap_trim");
        v42 = v41 + 16;
        if ( (v40 & 1) == 0 )
        {
          v42 += *v8;
          if ( (unsigned __int64)(v42 - 1) > 0x3FFFFFE )
            _malloc_assert("new_size > 0 && new_size < HEAP_MAX_SIZE", (__int64)"arena.c", 0x26Au, (__int64)"heap_trim");
        }
        if ( v42 + a5 - _RSI < v13 )
          goto LABEL_155;
        *(_QWORD *)(_R12 + 2184) -= _RBX[2];
        if ( (__int64 *)aligned_heap_area == _RBX + 0x800000 )
          aligned_heap_area = 0LL;
        _RSI = 0x4000000LL;
        v68 = a6;
        v66 = v13;
        v62 = a3;
        v60 = v42;
        munmap((unsigned __int64)_RBX, 0x4000000uLL);
        v43 = v60;
        a5 = 0x4000000LL;
        a3 = v62;
        v13 = v66;
        a6 = v68;
        if ( (v8[1] & 1) == 0 )
        {
          v8 = (_QWORD *)((char *)v8 - *v8);
          v44 = v8[1];
          if ( (v44 & 0xFFFFFFFFFFFFFFF8LL) != *(_QWORD *)((char *)v8 + (v44 & 0xFFFFFFFFFFFFFFF8LL)) )
            goto LABEL_114;
          v45 = (_QWORD *)v8[2];
          _RSI = v8[3];
          if ( v8 != (_QWORD *)v45[3] || v8 != *(_QWORD **)(_RSI + 16) )
            goto LABEL_83;
          v45[3] = _RSI;
          *(_QWORD *)(_RSI + 16) = v45;
          if ( v44 > 0x3FF )
          {
            _RSI = v8[4];
            if ( _RSI )
            {
              if ( v8 != *(_QWORD **)(_RSI + 40) || (v56 = v8[5], v8 != *(_QWORD **)(v56 + 32)) )
              {
LABEL_144:
                malloc_printerr((__int64)"corrupted double-linked list (not small)", _RSI, a3, v13, (u32 *)a5, a6);
                goto LABEL_145;
              }
              if ( v45[4] )
              {
                *(_QWORD *)(_RSI + 40) = v56;
                *(_QWORD *)(v8[5] + 32LL) = _RSI;
              }
              else if ( v8 == (_QWORD *)_RSI )
              {
                v45[5] = v45;
                v45[4] = v45;
              }
              else
              {
                v45[4] = _RSI;
                v59 = v8[4];
                v45[5] = v56;
                *(_QWORD *)(v59 + 40) = v45;
                *(_QWORD *)(v8[5] + 32LL) = v45;
              }
            }
          }
        }
        if ( (v68 & ((unsigned __int64)v8 + v60)) != 0 )
          _malloc_assert(
            "((unsigned long) ((char *) p + new_size) & (pagesz - 1)) == 0",
            (__int64)"arena.c",
            0x276u,
            (__int64)"heap_trim");
        _RSI = v12 + *(_QWORD *)(v12 + 16);
        if ( (_QWORD *)((char *)v8 + v60) != (_QWORD *)_RSI )
          _malloc_assert(
            "((char *) p + new_size) == ((char *) heap + heap->size)",
            (__int64)"arena.c",
            0x277u,
            (__int64)"heap_trim");
LABEL_145:
        *(_QWORD *)(_R12 + 96) = v8;
        v8[1] = v43 | 1;
        if ( v8 != (_QWORD *)(v12 + 32) )
        {
          v35 = v8;
          _RBX = (__int64 *)v12;
          goto LABEL_155;
        }
        v46 = *(_QWORD *)(v12 + 8);
        _RBX = (__int64 *)v12;
        v35 = v8;
        _RSI = *(_QWORD *)(v46 + 16);
        v38 = ((_BYTE)v46 + (_BYTE)_RSI - 16) & 0xF;
        v39 = (_QWORD *)(v46 + _RSI - 16 - v38);
        if ( v39[1] != 1LL )
          break;
        v12 = *(_QWORD *)(v12 + 8);
      }
    }
LABEL_126:
    _malloc_assert("chunksize_nomask (p) == (0 | PREV_INUSE)", (__int64)"arena.c", 0x264u, (__int64)"heap_trim");
  }
LABEL_155:
  v49 = v35[1] & 0xFFFFFFFFFFFFFFF8LL;
  v61 = v49;
  if ( mp_ <= v49 )
  {
    v50 = v49 - 33;
    if ( v50 >= 0 && a3 < v50 )
    {
      v51 = -(__int64)v10 & (v50 - a3);
      if ( v51 )
      {
        v52 = _RBX[2] - v51;
        if ( v52 > 31 )
        {
          if ( may_shrink_heap_11587 < 0 )
          {
            v57 = _libc_enable_secure;
            may_shrink_heap_11587 = _libc_enable_secure;
            if ( !_libc_enable_secure )
            {
              v64 = v35;
              v58 = _open_nocancel("/proc/sys/vm/overcommit_memory", 0x80000, a3);
              v35 = v64;
              if ( v58 >= 0 )
              {
                v65 = v58;
                v67 = v35;
                if ( (__int64)_read_nocancel(v58, &v69, 1uLL) > 0 )
                  v57 = v69 == 50;
                may_shrink_heap_11587 = v57;
                _close_nocancel(v65);
                v35 = v67;
              }
            }
            v53 = may_shrink_heap_11587 != 0;
          }
          else
          {
            v53 = may_shrink_heap_11587 != 0;
          }
          v54 = (unsigned __int64)_RBX + v52;
          v63 = v35;
          if ( !v53 )
          {
            _RSI = v51;
            madvise(v54, v51, 4);
            v55 = v63;
LABEL_164:
            _RBX[2] = v52;
            *(_QWORD *)(_R12 + 2184) -= v51;
            v55[1] = (v61 - v51) | 1;
            goto LABEL_49;
          }
          _RSI = v51;
          if ( mmap64(v54, v51, 0LL, 0x32uLL, 0xFFFFFFFFuLL, 0LL) != -1LL )
          {
            _RBX[3] = v52;
            v55 = v63;
            goto LABEL_164;
          }
        }
      }
    }
  }
LABEL_49:
  if ( !v9 )
  {
    if ( _libc_multiple_threads )
    {
      if ( !_InterlockedDecrement((volatile signed __int32 *)_R12) )
        return __readfsqword(0x28u) ^ v70;
    }
    else
    {
      v30 = (*(_DWORD *)_R12)-- == 1;
      if ( v30 )
        return __readfsqword(0x28u) ^ v70;
    }
    _lll_unlock_wake_private((u32 *)_R12, _RSI, a3, v13, (u32 *)a5, a6);
  }
  return __readfsqword(0x28u) ^ v70;
}
// 41260E: variable '_R12' is possibly undefined
// 412636: variable '_RBX' is possibly undefined
// 412647: variable 'v19' is possibly undefined
// 412649: variable 'a3' is possibly undefined
// 4126C1: variable 'v8' is possibly undefined
// 41279F: variable 'v10' is possibly undefined
// 412810: variable 'v9' is possibly undefined
// 412839: variable 'v13' is possibly undefined
// 412839: variable 'a5' is possibly undefined
// 412839: variable 'a6' is possibly undefined
// 4128E4: variable 'v15' is possibly undefined
// 412C40: variable 'v35' is possibly undefined
// 412EA8: variable 'v43' is possibly undefined
// 401090: using guessed type __int64 __fastcall j_memset_ifunc(_QWORD, _QWORD, _QWORD);
// 4A7AD8: using guessed type int _libc_enable_secure;
// 4A87C0: using guessed type int may_shrink_heap_11587;
// 4A87E0: using guessed type __int64 mp_;
// 4A87E8: using guessed type __int64 qword_4A87E8;
// 4A8830: using guessed type __int64 qword_4A8830;
// 4A8840: using guessed type __int64 qword_4A8840;
// 4A8880: using guessed type int main_arena;
// 4A91F8: using guessed type __int64 dl_pagesize;
// 4AADB4: using guessed type int perturb_byte;
// 4AADB8: using guessed type __int64 global_max_fast;
// 4AB820: using guessed type int _libc_multiple_threads;

//----- (0000000000413150) ----------------------------------------------------
_QWORD *__fastcall sysmalloc(unsigned __int64 a1, __int64 a2)
{
  unsigned __int64 v2; // rbp
  signed __int64 v3; // r12
  char v5; // cl
  __int64 v6; // r10
  unsigned __int64 v7; // r15
  unsigned __int64 v8; // r13
  __int64 v9; // rax
  unsigned __int64 v10; // r14
  unsigned __int64 v11; // r11
  unsigned __int64 v12; // r9
  __int64 v13; // r11
  __int64 v14; // rax
  unsigned __int64 v15; // r8
  unsigned __int64 v16; // rdi
  __int64 v17; // rax
  unsigned __int64 v18; // rdx
  unsigned __int64 v19; // rcx
  unsigned __int64 v20; // rax
  unsigned __int64 v21; // rcx
  unsigned __int64 v22; // rax
  _QWORD *v23; // rdx
  _QWORD *v24; // rax
  signed __int32 v25; // ecx
  int v26; // eax
  unsigned __int64 v27; // r13
  __int64 v28; // rtt
  _QWORD *v30; // rax
  unsigned __int64 v31; // r8
  __int64 v32; // rsi
  __int64 v33; // rcx
  unsigned __int64 v34; // r14
  unsigned __int64 v35; // rax
  unsigned __int64 *v36; // rsi
  int v37; // eax
  signed __int64 v38; // r10
  __int64 v39; // rax
  u32 *v40; // r8
  unsigned __int64 v41; // r9
  __int64 v42; // rsi
  __int64 v43; // rax
  unsigned __int64 v44; // rax
  unsigned __int64 v45; // rdi
  unsigned __int64 v46; // rdx
  unsigned __int64 v47; // rdi
  unsigned __int64 v48; // r12
  bool v49; // sf
  unsigned __int64 v50; // rdi
  unsigned __int64 v51; // r12
  unsigned __int64 v52; // r14
  unsigned __int64 v53; // rax
  unsigned __int64 v54; // [rsp+0h] [rbp-68h]
  __int64 v55; // [rsp+0h] [rbp-68h]
  char v56; // [rsp+8h] [rbp-60h]
  unsigned __int64 v57; // [rsp+8h] [rbp-60h]
  unsigned __int64 v58; // [rsp+8h] [rbp-60h]
  __int64 v59; // [rsp+10h] [rbp-58h]
  char v60; // [rsp+10h] [rbp-58h]
  signed __int64 v61; // [rsp+10h] [rbp-58h]
  signed __int64 v62; // [rsp+10h] [rbp-58h]
  __int64 v63; // [rsp+10h] [rbp-58h]
  unsigned __int64 v64; // [rsp+18h] [rbp-50h]
  __int64 v65; // [rsp+18h] [rbp-50h]
  unsigned __int64 v66; // [rsp+20h] [rbp-48h]
  unsigned __int64 v67; // [rsp+20h] [rbp-48h]
  __int64 v68; // [rsp+28h] [rbp-40h]

  v2 = a1;
  v3 = dl_pagesize;
  if ( a2 )
  {
    if ( qword_4A87F0 > a1 || dword_4A8808 >= dword_4A880C )
    {
      v5 = 0;
LABEL_4:
      v6 = a2 + 96;
      v7 = -v3 & (v3 + a1 + 7);
      while ( 1 )
      {
        v8 = *(_QWORD *)(a2 + 96);
        v9 = *(_QWORD *)(v8 + 8);
        v10 = v9 & 0xFFFFFFFFFFFFFFF8LL;
        v11 = v8 + (v9 & 0xFFFFFFFFFFFFFFF8LL);
        if ( (v8 != v6 || v10) && (v10 <= 0x1F || (v9 & 1) == 0 || ((v3 - 1) & v11) != 0) )
          _malloc_assert(
            "(old_top == initial_top (av) && old_size == 0) || ((unsigned long) (old_size) >= MINSIZE && prev_inuse (old_"
            "top) && ((unsigned long) old_end & (pagesize - 1)) == 0)",
            (__int64)"malloc.c",
            0x951u,
            (__int64)"sysmalloc");
        v54 = v2 + 32;
        if ( v2 + 32 <= v10 )
          _malloc_assert(
            "(unsigned long) (old_size) < (unsigned long) (nb + MINSIZE)",
            (__int64)"malloc.c",
            0x954u,
            (__int64)"sysmalloc");
        if ( (int *)a2 == &main_arena )
          break;
        v12 = v8 & 0xFFFFFFFFFC000000LL;
        if ( (__int64)(v54 - v10) > 0 )
        {
          v13 = *(_QWORD *)((v8 & 0xFFFFFFFFFC000000LL) + 0x10);
          v14 = (v54 - v10 + dl_pagesize - 1) & -dl_pagesize;
          v15 = v14 + v13;
          if ( (unsigned __int64)(v14 + v13) <= 0x4000000 )
          {
            v16 = *(_QWORD *)((v8 & 0xFFFFFFFFFC000000LL) + 0x18);
            if ( v15 <= v16 )
              goto LABEL_15;
            v65 = v6;
            v60 = v5;
            v68 = *(_QWORD *)((v8 & 0xFFFFFFFFFC000000LL) + 0x10);
            v66 = v14 + v13;
            v37 = mprotect(v12 + v16, v15 - v16, 3uLL);
            v12 = v8 & 0xFFFFFFFFFC000000LL;
            v5 = v60;
            v6 = v65;
            if ( !v37 )
            {
              v15 = v66;
              v13 = v68;
              *(_QWORD *)((v8 & 0xFFFFFFFFFC000000LL) + 0x18) = v66;
LABEL_15:
              *(_QWORD *)(v12 + 16) = v15;
              v17 = *(_QWORD *)(v12 + 16);
              v18 = *(_QWORD *)(a2 + 96);
              v19 = v17 + *(_QWORD *)(a2 + 2184) - v13;
              *(_QWORD *)(a2 + 2184) = v19;
              *(_QWORD *)(v8 + 8) = (v17 + v12 - v8) | 1;
              goto LABEL_16;
            }
          }
        }
        v59 = v6;
        v56 = v5;
        v64 = v12;
        v30 = (_QWORD *)new_heap(v2 + 64, qword_4A87E8);
        v6 = v59;
        if ( v30 )
        {
          v32 = v30[2];
          *v30 = a2;
          v33 = *(_QWORD *)(a2 + 2184);
          v18 = (unsigned __int64)(v30 + 4);
          v34 = (v10 - 32) & 0xFFFFFFFFFFFFFFF0LL;
          v30[1] = v64;
          v19 = v32 + v33;
          *(_QWORD *)(a2 + 96) = v30 + 4;
          *(_QWORD *)(a2 + 2184) = v19;
          v30[5] = (v32 - 32) | 1;
          v35 = v34 + 16;
          v36 = (unsigned __int64 *)(v8 + v34 + 16);
          v36[1] = 1LL;
          if ( v34 > 0x1F )
          {
            *(_QWORD *)(v8 + v34 + 8) = 17LL;
            *v36 = 16LL;
            *(_QWORD *)(v8 + 8) = v34 | 5;
            int_free(a2, v8, 1uLL, v19, v31, v64);
            v19 = *(_QWORD *)(a2 + 2184);
            v18 = *(_QWORD *)(a2 + 96);
          }
          else
          {
            *(_QWORD *)(v8 + 8) = v35 | 1;
            *v36 = v35;
          }
          goto LABEL_16;
        }
        if ( v56 )
        {
          v19 = *(_QWORD *)(a2 + 2184);
          v18 = *(_QWORD *)(a2 + 96);
          goto LABEL_16;
        }
        v8 = v7;
        if ( v7 > v2 )
          goto LABEL_98;
LABEL_96:
        v5 = 1;
      }
      v7 = v3 - 1;
      v38 = -v3;
      v39 = v2 + qword_4A87E8 + 32;
      if ( (*(_BYTE *)(a2 + 4) & 2) != 0 )
      {
        v3 = v38 & (v39 + v7);
        if ( v3 <= 0 )
          goto LABEL_57;
      }
      else
      {
        v3 = v38 & (v39 - v10 + v7);
        if ( v3 <= 0 )
        {
LABEL_80:
          v3 = v38 & (v10 + v7 + v3);
          goto LABEL_57;
        }
      }
      v61 = v38;
      v18 = _morecore(v3);
      v11 = v8 + v10;
      v38 = v61;
      if ( v18 )
      {
        v42 = 1LL;
        v43 = 0LL;
        if ( _after_morecore_hook )
        {
          v67 = v18;
          _after_morecore_hook(v3, 1LL);
          v11 = v8 + v10;
          v43 = 0LL;
          v38 = v61;
          v18 = v67;
          v42 = 1LL;
        }
LABEL_51:
        if ( !qword_4A8828 )
          qword_4A8828 = v18;
        v19 = v3 + qword_4A9108;
        qword_4A9108 += v3;
        if ( v11 == v18 && (_BYTE)v42 )
        {
          v18 = qword_4A88E0;
          *(_QWORD *)(v8 + 8) = (v3 + v10) | 1;
          goto LABEL_16;
        }
        if ( (dword_4A8884 & 2) != 0 )
        {
          if ( (v18 & 0xF) != 0 )
            _malloc_assert(
              "((unsigned long) chunk2mem (brk) & MALLOC_ALIGN_MASK) == 0",
              (__int64)"malloc.c",
              0xA4Bu,
              (__int64)"sysmalloc");
          v51 = 0LL;
          if ( !v43 )
          {
            v57 = v18;
            goto LABEL_87;
          }
LABEL_76:
          qword_4A88E0 = v18;
          *(_QWORD *)(v18 + 8) = (v51 + v43 - v18) | 1;
          qword_4A9108 = v19;
          if ( v10 )
          {
            v52 = (v10 - 32) & 0xFFFFFFFFFFFFFFF0LL;
            *(_QWORD *)(v8 + 8) = v52 | 1;
            *(_QWORD *)(v8 + v52 + 8) = 17LL;
            *(_QWORD *)(v8 + v52 + 24) = 17LL;
            if ( v52 > 0x1F )
            {
              int_free((__int64)&main_arena, v8, 1uLL, v19, (unsigned __int64)v40, v41);
LABEL_60:
              v19 = qword_4A9108;
              goto LABEL_61;
            }
          }
LABEL_16:
          if ( *(_QWORD *)(a2 + 2192) < v19 )
            *(_QWORD *)(a2 + 2192) = v19;
          v20 = *(_QWORD *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8LL;
          if ( v54 <= v20 )
          {
            v21 = v18 + v2;
            v22 = v20 - v2;
            *(_QWORD *)(a2 + 96) = v18 + v2;
            if ( (int *)a2 != &main_arena )
              v2 |= 4uLL;
            v23 = (_QWORD *)(v18 + 16);
            *(v23 - 1) = v2 | 1;
            *(_QWORD *)(v21 + 8) = v22 | 1;
            return v23;
          }
          __writefsdword(0xFFFFFFC0, 0xCu);
          return 0LL;
        }
        if ( !v10 || v11 <= v18 )
        {
          if ( v10 )
            qword_4A9108 = v18 - v11 + v19;
          v44 = v18 & 0xF;
          if ( (v18 & 0xF) != 0 )
          {
            v45 = v10 + 16 - v44;
            v57 = v18 + 16 - v44;
          }
          else
          {
            v45 = v10;
            v57 = v18;
          }
          v46 = v45 + v3 + v18;
          v47 = v45 - v46;
          v48 = v38 & (v46 + v7);
          v49 = (__int64)(v48 + v47) < 0;
          v50 = v48 + v47;
          v51 = v50;
          if ( v49 )
            _malloc_assert("correction >= 0", (__int64)"malloc.c", 0xA2Bu, (__int64)"sysmalloc");
          v43 = _morecore(v50);
          if ( v43 )
          {
            if ( _after_morecore_hook )
            {
              v63 = v43;
              _after_morecore_hook(v50, v42);
              v18 = v57;
              v43 = v63;
            }
            else
            {
              v18 = v57;
            }
            v19 = v50 + qword_4A9108;
            goto LABEL_76;
          }
LABEL_87:
          v43 = _morecore(0LL);
          v19 = qword_4A9108;
          if ( v43 )
          {
            v18 = v57;
            v51 = 0LL;
            goto LABEL_76;
          }
LABEL_61:
          v18 = qword_4A88E0;
          goto LABEL_16;
        }
        malloc_printerr((__int64)"break adjusted to free malloc space", v42, v18, v19, v40, v41);
LABEL_98:
        v55 = v6;
        v24 = (_QWORD *)mmap64(0LL, v7, 3uLL, 0x22uLL, 0xFFFFFFFFuLL, 0LL);
        v6 = v55;
        if ( v24 != (_QWORD *)-1LL )
          goto LABEL_28;
        goto LABEL_96;
      }
      if ( (dword_4A8884 & 2) == 0 )
        goto LABEL_80;
LABEL_57:
      if ( (unsigned __int64)v3 < 0x100000 )
        v3 = 0x100000LL;
      if ( v2 >= v3 )
        goto LABEL_60;
      v42 = v3;
      v62 = v38;
      v58 = v11;
      v53 = mmap64(0LL, v3, 3uLL, 0x22uLL, 0xFFFFFFFFuLL, 0LL);
      v11 = v58;
      v38 = v62;
      v18 = v53;
      if ( v53 == -1LL )
        goto LABEL_60;
      v43 = v53 + v3;
      dword_4A8884 |= 2u;
      if ( !v18 )
        goto LABEL_60;
      LOBYTE(v42) = v43 == 0;
      goto LABEL_51;
    }
    v8 = -dl_pagesize & (dl_pagesize + a1 + 7);
    if ( a1 >= v8 || (v24 = (_QWORD *)mmap64(0LL, v8, 3uLL, 0x22uLL, 0xFFFFFFFFuLL, 0LL), v24 == (_QWORD *)-1LL) )
    {
      v5 = 1;
      goto LABEL_4;
    }
  }
  else
  {
    v8 = -dl_pagesize & (dl_pagesize + a1 + 7);
    if ( v8 <= a1 )
      return 0LL;
    v24 = (_QWORD *)mmap64(0LL, v8, 3uLL, 0x22uLL, 0xFFFFFFFFuLL, 0LL);
    if ( v24 == (_QWORD *)-1LL )
      return 0LL;
  }
LABEL_28:
  v23 = v24 + 2;
  if ( (((_BYTE)v24 + 16) & 0xF) != 0 )
    _malloc_assert(
      "((INTERNAL_SIZE_T) chunk2mem (mm) & MALLOC_ALIGN_MASK) == 0",
      (__int64)"malloc.c",
      0x91Au,
      (__int64)"sysmalloc");
  *v24 = 0LL;
  v24[1] = v8 | 2;
  v25 = _InterlockedIncrement(&dword_4A8808);
  do
    v26 = dword_4A8810;
  while ( v25 > dword_4A8810 && v26 != _InterlockedCompareExchange(&dword_4A8810, v25, dword_4A8810) );
  v27 = _InterlockedExchangeAdd64(&qword_4A8818, v8) + v8;
  do
  {
    if ( v27 <= qword_4A8820 )
      break;
    v28 = qword_4A8820;
  }
  while ( v28 != _InterlockedCompareExchange64(&qword_4A8820, v27, qword_4A8820) );
  return v23;
}
// 41355B: variable 'v31' is possibly undefined
// 41377D: variable 'v40' is possibly undefined
// 41377D: variable 'v41' is possibly undefined
// 413952: variable 'v6' is possibly undefined
// 4A87E8: using guessed type __int64 qword_4A87E8;
// 4A87F0: using guessed type __int64 qword_4A87F0;
// 4A8808: using guessed type int dword_4A8808;
// 4A880C: using guessed type int dword_4A880C;
// 4A8810: using guessed type int dword_4A8810;
// 4A8818: using guessed type __int64 qword_4A8818;
// 4A8820: using guessed type __int64 qword_4A8820;
// 4A8828: using guessed type __int64 qword_4A8828;
// 4A8880: using guessed type int main_arena;
// 4A8884: using guessed type int dword_4A8884;
// 4A88E0: using guessed type __int64 qword_4A88E0;
// 4A9108: using guessed type __int64 qword_4A9108;
// 4A9118: using guessed type __int64 (__fastcall *_morecore)(_QWORD);
// 4A91F8: using guessed type __int64 dl_pagesize;
// 4AAD70: using guessed type __int64 (__fastcall *_after_morecore_hook)(_QWORD, _QWORD);

//----- (0000000000413970) ----------------------------------------------------
_QWORD *__fastcall int_malloc(int *a1, unsigned __int64 j, __int64 a3, __int64 a4, unsigned __int64 a5, __int64 a6)
{
  int *v6; // rbx
  unsigned __int64 v7; // rbp
  unsigned __int64 v8; // r15
  bool v9; // al
  unsigned __int64 v10; // r13
  unsigned int v12; // er12
  __int64 v13; // rax
  int *v14; // r8
  __int64 v15; // rcx
  unsigned __int64 v18; // r11
  unsigned __int64 v19; // r9
  __int64 v20; // rdx
  unsigned __int64 v21; // r10
  __int64 v22; // rax
  _QWORD *v23; // rdx
  unsigned __int64 v25; // rax
  __int64 v26; // rdx
  _QWORD *v27; // rcx
  __int64 v28; // r9
  unsigned int v29; // eax
  unsigned __int64 v30; // r10
  unsigned __int64 v31; // r11
  unsigned __int64 v32; // r8
  int *v33; // rax
  const char *v34; // rdi
  unsigned __int64 v35; // rcx
  unsigned __int64 *v36; // r9
  unsigned __int64 v37; // rdx
  unsigned __int64 v38; // rsi
  __int64 v39; // rdx
  unsigned __int64 v40; // rax
  _QWORD *v41; // rcx
  __int64 v42; // rax
  int *v43; // r8
  __int64 v44; // rax
  int *v45; // r11
  unsigned __int64 v46; // r10
  unsigned __int64 v47; // rdi
  __int64 *v48; // rax
  __int64 v49; // rsi
  unsigned __int64 v51; // rax
  unsigned __int64 v52; // r9
  unsigned __int64 v53; // rdx
  unsigned __int64 *v54; // r10
  unsigned __int64 v55; // rcx
  __int64 v56; // rdx
  int *v57; // rdx
  unsigned int v58; // edi
  unsigned int v59; // eax
  _QWORD *v60; // rdx
  unsigned __int64 v61; // rcx
  unsigned int v62; // eax
  char *i; // rcx
  unsigned __int64 v64; // rax
  unsigned int v65; // eax
  unsigned int v66; // ecx
  __int64 v67; // rdx
  _QWORD *v68; // rax
  __int64 v69; // rdx
  unsigned __int64 v70; // rcx
  __int64 v71; // rcx
  unsigned __int64 v72; // rdx
  unsigned __int64 v73; // rdi
  unsigned __int64 v74; // rax
  char *v75; // rdx
  const char *v76; // rdi
  unsigned __int64 v77; // rax
  __int64 v78; // rdi
  char *v79; // rdx
  unsigned __int64 v80; // rdi
  __int64 *v81; // rax
  unsigned __int64 v82; // rdi
  __int64 v83; // rdx
  char *v84; // rax
  __int64 v85; // rdi
  __int64 v86; // rdi
  __int64 v87; // rdx
  unsigned __int64 v88; // [rsp+8h] [rbp-B0h]
  unsigned __int64 v89; // [rsp+10h] [rbp-A8h]
  unsigned __int64 v90; // [rsp+18h] [rbp-A0h]
  unsigned __int64 v91; // [rsp+20h] [rbp-98h]
  unsigned int v92; // [rsp+28h] [rbp-90h]
  bool v93; // [rsp+2Fh] [rbp-89h]
  unsigned __int64 v94; // [rsp+30h] [rbp-88h]
  unsigned __int64 v95; // [rsp+38h] [rbp-80h]
  unsigned __int64 v96; // [rsp+40h] [rbp-78h]
  unsigned __int64 v97; // [rsp+48h] [rbp-70h]
  unsigned int v98; // [rsp+50h] [rbp-68h]
  unsigned int v99; // [rsp+54h] [rbp-64h]
  unsigned __int64 v100; // [rsp+58h] [rbp-60h]
  unsigned __int64 v101; // [rsp+60h] [rbp-58h]
  unsigned int v102; // [rsp+68h] [rbp-50h]
  unsigned int v103; // [rsp+6Ch] [rbp-4Ch]
  unsigned __int64 v104; // [rsp+70h] [rbp-48h]
  unsigned int v105; // [rsp+78h] [rbp-40h]
  unsigned int v106; // [rsp+7Ch] [rbp-3Ch]

  if ( j + 23 <= 0x1F )
  {
    v9 = 0;
    v8 = 32LL;
  }
  else
  {
    v8 = (j + 23) & 0xFFFFFFFFFFFFFFF0LL;
    v9 = v8 > 0xFFFFFFFFFFFFFFBFLL;
  }
  if ( v8 < j || v9 )
  {
    v41 = 0LL;
    __writefsdword(0xFFFFFFC0, 0xCu);
    return v41;
  }
  v10 = j;
  if ( !a1 )
    goto LABEL_85;
  v12 = (unsigned int)v8 >> 4;
  if ( v8 <= global_max_fast )
  {
    v13 = v12 - 2;
    v14 = &a1[2 * v13];
    v15 = *((_QWORD *)v14 + 2);
    if ( v15 )
    {
      j = (unsigned int)_libc_multiple_threads;
      _RDI = &a1[2 * v13 + 4];
      _RDX = *(_QWORD *)(v15 + 16);
      if ( _libc_multiple_threads )
      {
        if ( __readfsdword(0x18u) )
          __asm { lock }
        __asm { cmpxchg [rdi], rdx }
      }
      else
      {
        *((_QWORD *)v14 + 2) = _RDX;
      }
      if ( *(_DWORD *)(v15 + 8) >> 4 != v12 )
        goto LABEL_140;
      v18 = __readfsqword(0xFFFFFFC8);
      if ( v18 )
      {
        v19 = (v8 - 17) >> 4;
        if ( qword_4A8830 > v19 && *(char *)(v18 + v19) < (unsigned __int64)qword_4A8840 )
        {
          v20 = *((_QWORD *)v14 + 2);
          if ( v20 )
          {
            v21 = v18 + 8 * v19;
            do
            {
              _RSI = *(_QWORD *)(v20 + 16);
              if ( _libc_multiple_threads )
              {
                if ( __readfsdword(0x18u) )
                  __asm { lock }
                __asm { cmpxchg [rdi], rsi }
              }
              else
              {
                *((_QWORD *)v14 + 2) = _RSI;
              }
              v22 = *(_QWORD *)(v21 + 64);
              *(_QWORD *)(v20 + 24) = v18;
              v23 = (_QWORD *)(v20 + 16);
              *v23 = v22;
              *(_QWORD *)(v21 + 64) = v23;
              LOBYTE(v22) = *(_BYTE *)(v18 + v19) + 1;
              *(_BYTE *)(v18 + v19) = v22;
              if ( (char)v22 >= (unsigned __int64)qword_4A8840 )
                break;
              v20 = *((_QWORD *)v14 + 2);
            }
            while ( v20 );
          }
        }
      }
LABEL_68:
      v49 = (unsigned int)perturb_byte;
      v41 = (_QWORD *)(v15 + 16);
      if ( perturb_byte )
        goto LABEL_87;
      return v41;
    }
    goto LABEL_58;
  }
  if ( v8 <= 0x3FF )
  {
LABEL_58:
    v42 = 2 * (v12 + 0x7FFFFFFF);
    v43 = &a1[2 * v42 + 28];
    v15 = *(_QWORD *)&a1[2 * v42 + 30];
    v28 = (__int64)&a1[2 * v42 + 24];
    if ( v28 != v15 )
    {
      v44 = *(_QWORD *)(v15 + 24);
      if ( *(_QWORD *)(v44 + 16) != v15 )
      {
        v34 = "malloc(): smallbin double linked list corrupted";
        v33 = (int *)malloc_printerr(
                       (__int64)"malloc(): smallbin double linked list corrupted",
                       j,
                       a3,
                       v15,
                       (u32 *)v43,
                       v28);
        goto LABEL_143;
      }
      v45 = &main_arena;
      *(_QWORD *)(v15 + v8 + 8) |= 1uLL;
      *((_QWORD *)v43 + 1) = v44;
      *(_QWORD *)(v44 + 16) = v28;
      if ( a1 != &main_arena )
        *(_QWORD *)(v15 + 8) |= 4uLL;
      v46 = __readfsqword(0xFFFFFFC8);
      if ( v46 )
      {
        v47 = (v8 - 17) >> 4;
        if ( qword_4A8830 > v47 )
        {
          v38 = qword_4A8840;
          LOBYTE(v6) = *(_BYTE *)(v46 + v47);
          v7 = v46 + 8 * v47;
          goto LABEL_67;
        }
      }
      goto LABEL_68;
    }
    v26 = 2LL;
    v92 = (unsigned int)v8 >> 4;
    v97 = v8 >> 6;
    v99 = (v8 >> 6) + 48;
    v100 = v8 >> 9;
    v102 = (v8 >> 9) + 91;
    v104 = v8 >> 12;
    v103 = (v8 >> 12) + 110;
    v101 = v8 >> 15;
    v105 = (v8 >> 15) + 119;
    v51 = v8 >> 18;
    if ( v8 >> 18 > 2 )
      LODWORD(v51) = 2;
    v106 = v51 + 124;
    goto LABEL_30;
  }
  v25 = v8 >> 18;
  v26 = 2LL;
  v27 = (_QWORD *)(v8 >> 12);
  v97 = v8 >> 6;
  j = v8 >> 15;
  v100 = v8 >> 9;
  if ( v8 >> 18 > 2 )
    LODWORD(v25) = 2;
  v28 = (unsigned int)((_DWORD)v27 + 110);
  v99 = (v8 >> 6) + 48;
  v104 = v8 >> 12;
  v29 = v25 + 124;
  v101 = v8 >> 15;
  v102 = (v8 >> 9) + 91;
  v103 = (_DWORD)v27 + 110;
  v105 = j + 119;
  v106 = v29;
  v92 = v99;
  if ( v8 >> 6 > 0x30 )
  {
    v92 = (v8 >> 9) + 91;
    if ( v8 >> 9 > 0x14 )
    {
      v92 = (_DWORD)v27 + 110;
      if ( (unsigned __int64)v27 > 0xA )
      {
        if ( j < 5 )
          v29 = j + 119;
        v92 = v29;
      }
    }
  }
  if ( a1[2] )
    malloc_consolidate((const char *)a1, j, 2LL, v27, (unsigned int)(j + 119));
LABEL_30:
  v30 = 0LL;
  v95 = v8 - 17;
  v31 = __readfsqword(0xFFFFFFC8);
  v7 = (v8 - 17) >> 4;
  if ( v31 && qword_4A8830 > v7 )
    v30 = v8;
  v88 = 0LL;
  v6 = a1 + 24;
  v90 = v30;
  v98 = (unsigned int)v8 >> 4;
  v91 = v10;
LABEL_34:
  v32 = qword_4A8848;
  v96 = v8 + 32;
  v94 = v31 + 8 * v7;
  v89 = qword_4A8840;
  v33 = (int *)*((_QWORD *)a1 + 15);
  v93 = qword_4A8848 != 0;
  LODWORD(v34) = 0;
  v12 = 0;
  while ( 1 )
  {
    if ( v33 == v6 )
    {
      if ( v12 )
      {
LABEL_52:
        v40 = v31 + 8 * v7;
        v41 = *(_QWORD **)(v40 + 64);
        if ( v95 > 0x3FF )
          goto LABEL_188;
        if ( !v41 )
          _malloc_assert("tcache->entries[tc_idx] > 0", (__int64)"malloc.c", 0xB80u, (__int64)"tcache_get");
        *(_QWORD *)(v40 + 64) = *v41;
        --*(_BYTE *)(v31 + v7);
        v41[1] = 0LL;
        return v41;
      }
LABEL_97:
      if ( v8 > 0x3FF )
      {
        v56 = *(_QWORD *)&a1[4 * v92 + 0x200000018LL];
        if ( (int *)v56 != &a1[4 * v92 + 0x200000014LL] && *(_QWORD *)(v56 + 8) >= v8 )
        {
          v10 = v91;
          for ( i = *(char **)(v56 + 40); ; i = (char *)*((_QWORD *)i + 5) )
          {
            v57 = (int *)*((_QWORD *)i + 1);
            j = (unsigned __int64)v57 & 0xFFFFFFFFFFFFFFF8LL;
            if ( v8 <= ((unsigned __int64)v57 & 0xFFFFFFFFFFFFFFF8LL) )
              break;
          }
          if ( *(char **)&a1[4 * v92 + 0x20000001ALL] != i && v57 == *(int **)(*((_QWORD *)i + 2) + 8LL) )
            i = (char *)*((_QWORD *)i + 2);
          v80 = *((_QWORD *)i + 1);
          if ( (v80 & 0xFFFFFFFFFFFFFFF8LL) != *(_QWORD *)&i[v80 & 0xFFFFFFFFFFFFFFF8LL] )
            goto LABEL_187;
          v81 = (__int64 *)*((_QWORD *)i + 2);
          v75 = (char *)*((_QWORD *)i + 3);
          if ( (char *)v81[3] != i || *((char **)v75 + 2) != i )
            goto LABEL_186;
          v81[3] = (__int64)v75;
          *((_QWORD *)v75 + 2) = v81;
          if ( v80 > 0x3FF )
          {
            v75 = (char *)*((_QWORD *)i + 4);
            if ( v75 )
            {
LABEL_223:
              if ( *((char **)v75 + 5) != i || (v86 = *((_QWORD *)i + 5), *(char **)(v86 + 32) != i) )
              {
LABEL_220:
                v74 = (unsigned __int64)malloc_printerr(
                                          (__int64)"corrupted double-linked list (not small)",
                                          j,
                                          (__int64)v75,
                                          (__int64)i,
                                          (u32 *)v32,
                                          v28);
LABEL_221:
                *((_QWORD *)v75 + 5) = v75;
                *((_QWORD *)v75 + 4) = v75;
                goto LABEL_172;
              }
              if ( v81[4] )
              {
                *((_QWORD *)v75 + 5) = v86;
                *(_QWORD *)(*((_QWORD *)i + 5) + 32LL) = v75;
              }
              else if ( v75 == i )
              {
                v81[5] = (__int64)v81;
                v81[4] = (__int64)v81;
              }
              else
              {
                v81[4] = (__int64)v75;
                v87 = *((_QWORD *)i + 4);
                v81[5] = v86;
                *(_QWORD *)(v87 + 40) = v81;
                *(_QWORD *)(*((_QWORD *)i + 5) + 32LL) = v81;
              }
            }
          }
          v82 = j - v8;
          if ( j - v8 > 0x1F )
          {
            v83 = *((_QWORD *)a1 + 14);
            v84 = &i[v8];
            if ( *(int **)(v83 + 24) == v6 )
            {
              *((_QWORD *)v84 + 3) = v6;
              *((_QWORD *)v84 + 2) = v83;
              *((_QWORD *)a1 + 14) = v84;
              *(_QWORD *)(v83 + 24) = v84;
              if ( v82 > 0x3FF )
              {
                *((_QWORD *)v84 + 4) = 0LL;
                *((_QWORD *)v84 + 5) = 0LL;
              }
              *((_QWORD *)i + 1) = v8 | (4LL * (a1 != &main_arena)) | 1;
              *((_QWORD *)v84 + 1) = v82 | 1;
              *(_QWORD *)&i[j] = v82;
              goto LABEL_179;
            }
            malloc_printerr((__int64)"malloc(): corrupted unsorted chunks", j, v83, (__int64)i, (u32 *)v32, v28);
          }
          *(_QWORD *)&i[j + 8] |= 1uLL;
          if ( a1 != &main_arena )
            goto LABEL_185;
LABEL_179:
          v62 = perturb_byte;
          v41 = i + 16;
          if ( !perturb_byte )
            return v41;
LABEL_115:
          LOBYTE(v62) = ~(_BYTE)v62;
          return (_QWORD *)j_memset_ifunc(v41, v62, v10);
        }
      }
      v57 = &a1[4 * v92 + 24];
      v58 = (v92 + 1) >> 5;
      v59 = 1 << (v92 + 1);
      v32 = v58;
      for ( j = (unsigned int)a1[v58 + 536]; v59 <= (unsigned int)j && v59; a1[v32 + 536] = j )
      {
LABEL_103:
        while ( ((unsigned int)j & v59) == 0 )
        {
          v57 += 4;
          v59 *= 2;
          if ( !v59 )
            _malloc_assert("bit != 0", (__int64)"malloc.c", 0xFB8u, (__int64)"_int_malloc");
        }
        i = (char *)*((_QWORD *)v57 + 3);
        if ( v57 != (int *)i )
        {
          v73 = *((_QWORD *)i + 1);
          v10 = v91;
          v74 = v73 & 0xFFFFFFFFFFFFFFF8LL;
          if ( v8 > (v73 & 0xFFFFFFFFFFFFFFF8LL) )
            _malloc_assert(
              "(unsigned long) (size) >= (unsigned long) (nb)",
              (__int64)"malloc.c",
              0xFCBu,
              (__int64)"_int_malloc");
          j = (unsigned __int64)&i[v74];
          if ( *(_QWORD *)&i[v74] == v74 )
          {
            v75 = (char *)*((_QWORD *)i + 2);
            v32 = *((_QWORD *)i + 3);
            if ( *((char **)v75 + 3) == i && *(char **)(v32 + 16) == i )
            {
              *((_QWORD *)v75 + 3) = v32;
              *(_QWORD *)(v32 + 16) = v75;
              if ( v73 > 0x3FF )
              {
                v76 = (const char *)*((_QWORD *)i + 4);
                if ( v76 )
                  goto LABEL_195;
              }
LABEL_172:
              while ( 1 )
              {
                v77 = v74 - v8;
                if ( v77 <= 0x1F )
                  break;
                v78 = *((_QWORD *)a1 + 14);
                v79 = &i[v8];
                if ( *(int **)(v78 + 24) == v6 )
                {
                  *((_QWORD *)v79 + 3) = v6;
                  *((_QWORD *)v79 + 2) = v78;
                  *((_QWORD *)a1 + 14) = v79;
                  *(_QWORD *)(v78 + 24) = v79;
                  if ( v8 <= 0x3FF )
                    *((_QWORD *)a1 + 13) = v79;
                  if ( v77 > 0x3FF )
                  {
                    *((_QWORD *)v79 + 4) = 0LL;
                    *((_QWORD *)v79 + 5) = 0LL;
                  }
                  *((_QWORD *)i + 1) = v8 | (4LL * (a1 != &main_arena)) | 1;
                  *((_QWORD *)v79 + 1) = v77 | 1;
                  *(_QWORD *)j = v77;
                  goto LABEL_179;
                }
                v76 = "malloc(): corrupted unsorted chunks 2";
                v74 = (unsigned __int64)malloc_printerr(
                                          (__int64)"malloc(): corrupted unsorted chunks 2",
                                          j,
                                          (__int64)v79,
                                          (__int64)i,
                                          (u32 *)v32,
                                          v28);
LABEL_195:
                if ( *((char **)v76 + 5) != i )
                  goto LABEL_220;
                v32 = *((_QWORD *)i + 5);
                if ( *(char **)(v32 + 32) != i )
                  goto LABEL_220;
                if ( *((_QWORD *)v75 + 4) )
                {
                  *((_QWORD *)v76 + 5) = v32;
                  *(_QWORD *)(*((_QWORD *)i + 5) + 32LL) = v76;
                }
                else
                {
                  if ( v76 == i )
                    goto LABEL_221;
                  *((_QWORD *)v75 + 4) = v76;
                  v85 = *((_QWORD *)i + 4);
                  *((_QWORD *)v75 + 5) = v32;
                  *(_QWORD *)(v85 + 40) = v75;
                  *(_QWORD *)(*((_QWORD *)i + 5) + 32LL) = v75;
                }
              }
LABEL_184:
              *(_QWORD *)(j + 8) |= 1uLL;
              if ( a1 != &main_arena )
LABEL_185:
                *((_QWORD *)i + 1) |= 4uLL;
              goto LABEL_179;
            }
LABEL_186:
            malloc_printerr((__int64)"corrupted double-linked list", j, (__int64)v75, (__int64)i, (u32 *)v32, v28);
          }
LABEL_187:
          malloc_printerr((__int64)"corrupted size vs. prev_size", j, (__int64)v57, (__int64)i, (u32 *)v32, v28);
LABEL_188:
          _malloc_assert("tc_idx < TCACHE_MAX_BINS", (__int64)"malloc.c", 0xB7Fu, (__int64)"tcache_get");
        }
        v66 = v59;
        v57 += 4;
        v59 *= 2;
        j = ~v66 & (unsigned int)j;
      }
      while ( ++v58 != 4 )
      {
        v32 = v58;
        j = (unsigned int)a1[v58 + 536];
        if ( (_DWORD)j )
        {
          v57 = &a1[128 * v58 + 20];
          v59 = 1;
          goto LABEL_103;
        }
      }
      i = (char *)*((_QWORD *)a1 + 12);
      v64 = *((_QWORD *)i + 1) & 0xFFFFFFFFFFFFFFF8LL;
      if ( *((_QWORD *)a1 + 273) < v64 )
        goto LABEL_183;
      if ( v8 + 32 <= v64 )
      {
        v10 = v91;
        *((_QWORD *)a1 + 12) = &i[v8];
        *((_QWORD *)i + 1) = v8 | (4LL * (a1 != &main_arena)) | 1;
        *(_QWORD *)&i[v8 + 8] = (v64 - v8) | 1;
        goto LABEL_179;
      }
      if ( !a1[2] )
      {
        v10 = v91;
        v41 = sysmalloc(v8, (__int64)a1);
        if ( v41 )
        {
          v62 = perturb_byte;
          if ( !perturb_byte )
            return v41;
          goto LABEL_115;
        }
        return 0LL;
      }
      malloc_consolidate((const char *)a1, j, v8 + 32, i, v32);
      v92 = v98;
      if ( v8 > 0x3FF )
      {
        v92 = v99;
        if ( v97 > 0x30 )
        {
          v92 = v102;
          if ( v100 > 0x14 )
          {
            v92 = v103;
            if ( v104 > 0xA )
            {
              v65 = v105;
              if ( v101 > 4 )
                v65 = v106;
              v92 = v65;
            }
          }
        }
      }
      v31 = __readfsqword(0xFFFFFFC8);
      goto LABEL_34;
    }
    v35 = *((_QWORD *)v33 + 1) & 0xFFFFFFFFFFFFFFF8LL;
    v36 = (unsigned __int64 *)((char *)v33 + v35);
    if ( v35 <= 0x10 )
      break;
    j = *((_QWORD *)a1 + 273);
    if ( j < v35 )
      break;
    v37 = v36[1];
    if ( v37 <= 0xF || j < v37 )
    {
      v34 = "malloc(): invalid next size (unsorted)";
      v33 = (int *)malloc_printerr(
                     (__int64)"malloc(): invalid next size (unsorted)",
                     j,
                     v37,
                     v35,
                     (u32 *)v32,
                     (__int64)v36);
      goto LABEL_89;
    }
    v38 = *v36 & 0xFFFFFFFFFFFFFFF8LL;
    if ( v38 != v35 )
    {
      v47 = (unsigned __int64)"malloc(): mismatching next->prev_size (unsorted)";
      v48 = malloc_printerr(
              (__int64)"malloc(): mismatching next->prev_size (unsorted)",
              v38,
              v37,
              v35,
              (u32 *)v32,
              (__int64)v36);
LABEL_135:
      v67 = v48[3];
      *(__int64 *)((char *)v48 + v8 + 8) |= 1uLL;
      if ( a1 != v45 )
        v48[1] |= 4uLL;
      *((_QWORD *)v43 + 1) = v67;
      v68 = v48 + 2;
      LOBYTE(v6) = (_BYTE)v6 + 1;
      *(_QWORD *)(v67 + 16) = v28;
      v69 = *(_QWORD *)(v7 + 64);
      v68[1] = v46;
      *v68 = v69;
      *(_QWORD *)(v7 + 64) = v68;
      *(_BYTE *)(v46 + v47) = (_BYTE)v6;
LABEL_67:
      while ( (char)v6 < v38 )
      {
        v48 = (__int64 *)*((_QWORD *)v43 + 1);
        if ( (__int64 *)v28 == v48 )
          break;
        if ( v48 )
          goto LABEL_135;
      }
      goto LABEL_68;
    }
    j = *((_QWORD *)v33 + 3);
    if ( *(int **)(j + 16) != v33 || *((int **)v33 + 2) != v6 )
    {
      v34 = "malloc(): unsorted double linked list corrupted";
      v33 = (int *)malloc_printerr(
                     (__int64)"malloc(): unsorted double linked list corrupted",
                     j,
                     v37,
                     v35,
                     (u32 *)v32,
                     (__int64)v36);
LABEL_107:
      v39 = (unsigned int)(v53 + 48);
      goto LABEL_92;
    }
    if ( (v37 & 1) != 0 )
    {
      malloc_printerr((__int64)"malloc(): invalid next->prev_inuse (unsorted)", j, v37, v35, (u32 *)v32, (__int64)v36);
LABEL_140:
      v34 = "malloc(): memory corruption (fast)";
      v33 = (int *)malloc_printerr((__int64)"malloc(): memory corruption (fast)", j, _RDX, v15, (u32 *)v14, a6);
LABEL_141:
      *((_QWORD *)v33 + 5) = v33;
      LOBYTE(v35) = v39;
      v28 = j;
      *((_QWORD *)v33 + 4) = v33;
      goto LABEL_49;
    }
    if ( v8 <= 0x3FF && (int *)j == v6 && *((int **)a1 + 13) == v33 && v96 < v35 )
    {
      v60 = (_QWORD *)((char *)v33 + v8);
      v61 = v35 - v8;
      v10 = v91;
      *((_QWORD *)a1 + 14) = (char *)v33 + v8;
      *((_QWORD *)a1 + 15) = (char *)v33 + v8;
      *((_QWORD *)a1 + 13) = (char *)v33 + v8;
      v60[2] = v6;
      v60[3] = v6;
      if ( v61 > 0x3FF )
      {
        v60[4] = 0LL;
        v60[5] = 0LL;
      }
      *((_QWORD *)v33 + 1) = v8 | (4LL * (a1 != &main_arena)) | 1;
      v60[1] = v61 | 1;
      *v36 = v61;
      v41 = v33 + 4;
      v62 = perturb_byte;
      if ( !perturb_byte )
        return v41;
      goto LABEL_115;
    }
    *((_QWORD *)a1 + 15) = j;
    *(_QWORD *)(j + 16) = v6;
    if ( v8 == v35 )
    {
      v36[1] = v37 | 1;
      if ( a1 != &main_arena )
        *((_QWORD *)v33 + 1) |= 4uLL;
      v41 = v33 + 4;
      if ( !v90 || (v52 = *(char *)(v31 + v7), v52 >= v89) )
      {
        v10 = v91;
        goto LABEL_86;
      }
      if ( v95 > 0x3FF )
        _malloc_assert("tc_idx < TCACHE_MAX_BINS", (__int64)"malloc.c", 0xB6Eu, (__int64)"tcache_put");
      v26 = (unsigned int)(v52 + 1);
      *((_QWORD *)v33 + 3) = v31;
      v12 = 1;
      v28 = *(_QWORD *)(v94 + 64);
      *((_QWORD *)v33 + 2) = v28;
      v33 = (int *)j;
      *(_QWORD *)(v94 + 64) = v41;
      *(_BYTE *)(v31 + v7) = v26;
    }
    else
    {
      if ( v35 <= 0x3FF )
      {
        LODWORD(v35) = (unsigned int)v35 >> 4;
        LODWORD(v39) = v35;
        v28 = (__int64)&a1[4 * (int)v35 + 20];
        j = *(_QWORD *)&a1[4 * (int)v35 + 24];
        goto LABEL_49;
      }
LABEL_89:
      v53 = v35 >> 6;
      if ( v35 >> 6 <= 0x30 )
        goto LABEL_107;
      if ( v35 >> 9 > 0x14 )
      {
LABEL_143:
        if ( v35 >> 12 > 0xA )
        {
          if ( v35 >> 15 > 4 )
          {
            v72 = v35 >> 18;
            if ( v35 >> 18 > 2 )
              LODWORD(v72) = 2;
            v39 = (unsigned int)(v72 + 124);
          }
          else
          {
            v39 = (unsigned int)(v35 >> 15) + 119;
          }
        }
        else
        {
          v39 = (unsigned int)(v35 >> 12) + 110;
        }
      }
      else
      {
        v39 = (unsigned int)(v35 >> 9) + 91;
      }
LABEL_92:
      v54 = *(unsigned __int64 **)&a1[4 * (int)v39 + 24];
      j = (unsigned __int64)&a1[4 * (int)v39 + 20];
      if ( (unsigned __int64 *)j == v54 )
        goto LABEL_141;
      v28 = *(_QWORD *)&a1[4 * (int)v39 + 26];
      v55 = v35 | 1;
      v10 = *(_QWORD *)(v28 + 8);
      if ( (v10 & 4) != 0 )
        _malloc_assert("chunk_main_arena (bck->bk)", (__int64)"malloc.c", 0xF06u, (__int64)"_int_malloc");
      if ( v10 <= v55 )
      {
        j = v54[1];
        if ( (j & 4) != 0 )
          _malloc_assert("chunk_main_arena (fwd)", (__int64)"malloc.c", 0xF13u, (__int64)"_int_malloc");
        while ( v55 < j )
        {
          v54 = (unsigned __int64 *)v54[4];
          j = v54[1];
          if ( (j & 4) != 0 )
            _malloc_assert("chunk_main_arena (fwd)", (__int64)"malloc.c", 0xF17u, (__int64)"_int_malloc");
        }
        if ( v55 == j )
        {
          j = v54[2];
        }
        else
        {
          v70 = v54[5];
          *((_QWORD *)v33 + 4) = v54;
          *((_QWORD *)v33 + 5) = v70;
          v71 = v54[5];
          if ( *(unsigned __int64 **)(v71 + 32) != v54 )
          {
            malloc_printerr(
              (__int64)"malloc(): largebin double linked list corrupted (nextsize)",
              j,
              v39,
              v71,
              (u32 *)v32,
              v28);
LABEL_183:
            malloc_printerr((__int64)"malloc(): corrupted top size", j, (__int64)v57, (__int64)i, (u32 *)v32, v28);
            goto LABEL_184;
          }
          v54[5] = (unsigned __int64)v33;
          v55 = *((_QWORD *)v33 + 5);
          j = (unsigned __int64)v54;
          *(_QWORD *)(v55 + 32) = v33;
        }
        v28 = *(_QWORD *)(j + 24);
        if ( *(_QWORD *)(v28 + 16) != j )
        {
          v81 = malloc_printerr(
                  (__int64)"malloc(): largebin double linked list corrupted (bk)",
                  j,
                  v39,
                  v55,
                  (u32 *)v32,
                  v28);
          goto LABEL_223;
        }
        LOBYTE(v35) = v39;
      }
      else
      {
        v35 = v54[5];
        *((_QWORD *)v33 + 4) = v54;
        *((_QWORD *)v33 + 5) = v35;
        *(_QWORD *)(v35 + 32) = v33;
        LOBYTE(v35) = v39;
        v54[5] = (unsigned __int64)v33;
      }
LABEL_49:
      ++v88;
      v26 = (int)v39 >> 5;
      a1[v26 + 536] |= 1 << v35;
      *((_QWORD *)v33 + 3) = v28;
      *((_QWORD *)v33 + 2) = j;
      *(_QWORD *)(j + 24) = v33;
      *(_QWORD *)(v28 + 16) = v33;
      if ( v12 )
      {
        if ( v32 < v88 && v93 )
          goto LABEL_52;
        LODWORD(v34) = (_DWORD)v34 + 1;
        if ( (int)v34 > 9999 )
          goto LABEL_52;
      }
      else
      {
        LODWORD(v34) = (_DWORD)v34 + 1;
        if ( (int)v34 > 9999 )
          goto LABEL_97;
      }
      v33 = (int *)*((_QWORD *)a1 + 15);
    }
  }
  malloc_printerr((__int64)"malloc(): invalid size (unsorted)", j, v26, v35, (u32 *)v32, (__int64)v36);
LABEL_85:
  v41 = sysmalloc(v8, 0LL);
  if ( !v41 )
    return 0LL;
LABEL_86:
  v49 = (unsigned int)perturb_byte;
  if ( perturb_byte )
  {
LABEL_87:
    LOBYTE(v49) = ~(_BYTE)v49;
    return (_QWORD *)j_memset_ifunc(v41, v49, v10);
  }
  return v41;
}
// 413BDB: variable 'v7' is possibly undefined
// 413BFD: variable 'v6' is possibly undefined
// 413CC2: variable 'v88' is possibly undefined
// 413CB9: variable 'v39' is possibly undefined
// 413CF7: variable 'v32' is possibly undefined
// 413D02: variable 'v93' is possibly undefined
// 413D11: variable 'v31' is possibly undefined
// 413D19: variable 'v95' is possibly undefined
// 413DF8: variable 'v43' is possibly undefined
// 413DFF: variable 'v28' is possibly undefined
// 413E16: variable 'v15' is possibly undefined
// 413F23: variable 'v90' is possibly undefined
// 413F32: variable 'v89' is possibly undefined
// 413F38: variable 'v91' is possibly undefined
// 413F7F: variable 'v26' is possibly undefined
// 413FE3: variable 'v35' is possibly undefined
// 41407D: variable 'v92' is possibly undefined
// 414120: variable 'v53' is possibly undefined
// 414151: variable 'v94' is possibly undefined
// 41417F: variable 'v96' is possibly undefined
// 414291: variable 'v98' is possibly undefined
// 4142A8: variable 'v99' is possibly undefined
// 4142AC: variable 'v97' is possibly undefined
// 4142B8: variable 'v102' is possibly undefined
// 4142BC: variable 'v100' is possibly undefined
// 4142C8: variable 'v103' is possibly undefined
// 4142CC: variable 'v104' is possibly undefined
// 4142D4: variable 'v105' is possibly undefined
// 4142D8: variable 'v101' is possibly undefined
// 4142D8: variable 'v106' is possibly undefined
// 41433D: variable 'v45' is possibly undefined
// 414357: variable 'v46' is possibly undefined
// 414397: variable '_RDX' is possibly undefined
// 414397: variable 'v14' is possibly undefined
// 414397: variable 'a6' is possibly undefined
// 4145B1: variable 'i' is possibly undefined
// 41466C: variable 'v57' is possibly undefined
// 41476E: variable 'v75' is possibly undefined
// 401090: using guessed type __int64 __fastcall j_memset_ifunc(_QWORD, _QWORD, _QWORD);
// 4A8830: using guessed type __int64 qword_4A8830;
// 4A8840: using guessed type __int64 qword_4A8840;
// 4A8848: using guessed type __int64 qword_4A8848;
// 4A8880: using guessed type int main_arena;
// 4AADB4: using guessed type int perturb_byte;
// 4AADB8: using guessed type __int64 global_max_fast;
// 4AB820: using guessed type int _libc_multiple_threads;

//----- (0000000000414950) ----------------------------------------------------
__int64 __fastcall malloc_check(int *a1, __int64 a2, __int64 a3, __int64 a4, u32 *a5, __int64 a6)
{
  int *v7; // rbx
  __int64 v8; // rdx
  __int64 v9; // rcx
  unsigned __int64 v10; // r8
  __int64 v11; // r9
  _QWORD *v12; // rdx
  __int64 v13; // rcx
  u32 *v14; // r8
  u32 v15; // er9

  if ( a1 != (int *)-1LL )
  {
    _ESI = 1;
    v7 = a1;
    if ( _libc_multiple_threads )
    {
      if ( !_InterlockedCompareExchange(&main_arena, 1, 0) )
      {
LABEL_7:
        top_check((__int64)a1, 1LL, a3, a4, a5, a6);
        v12 = int_malloc(&main_arena, (unsigned __int64)v7 + 1, v8, v9, v10, v11);
        if ( _libc_multiple_threads )
        {
          if ( !_InterlockedDecrement(&main_arena) )
            return mem2mem_check((__int64)v12, (unsigned __int64)v7);
        }
        else if ( !--main_arena )
        {
          return mem2mem_check((__int64)v12, (unsigned __int64)v7);
        }
        _lll_unlock_wake_private((u32 *)&main_arena, (__int64)v7 + 1, (__int64)v12, v13, v14, v15);
        return mem2mem_check((__int64)v12, (unsigned __int64)v7);
      }
    }
    else
    {
      __asm { cmpxchg cs:main_arena, esi }
      if ( !_libc_multiple_threads )
        goto LABEL_7;
    }
    a1 = &main_arena;
    _lll_lock_wait_private((u32 *)&main_arena, 1LL, a3, a4, a5, a6);
    goto LABEL_7;
  }
  __writefsdword(0xFFFFFFC0, 0xCu);
  return 0LL;
}
// 4149A1: variable 'a3' is possibly undefined
// 4149A1: variable 'a4' is possibly undefined
// 4149A1: variable 'a5' is possibly undefined
// 4149A1: variable 'a6' is possibly undefined
// 4149B1: variable 'v8' is possibly undefined
// 4149B1: variable 'v9' is possibly undefined
// 4149B1: variable 'v10' is possibly undefined
// 4149B1: variable 'v11' is possibly undefined
// 4149E3: variable 'v13' is possibly undefined
// 4149E3: variable 'v14' is possibly undefined
// 4149E3: variable 'v15' is possibly undefined
// 4149F6: variable 'v12' is possibly undefined
// 4A8880: using guessed type int main_arena;
// 4AB820: using guessed type int _libc_multiple_threads;

//----- (0000000000414A20) ----------------------------------------------------
_QWORD *__fastcall tcache_init_part_5(__int64 a1, __int64 a2, __int64 a3, __int64 a4, u32 *a5, __int64 a6)
{
  bool v8; // zf
  _QWORD *result; // rax
  __int64 v10; // rcx
  u32 *v11; // r8
  u32 v12; // er9
  _QWORD *v13; // rdx
  __int64 v14; // rdx
  __int64 v15; // rcx
  unsigned __int64 v16; // r8
  __int64 v17; // r9
  __int64 v18; // rdx
  __int64 v19; // rcx
  unsigned __int64 v20; // r8
  __int64 v21; // r9

  _RBX = (int *)__readfsqword(0xFFFFFFD8);
  if ( _RBX )
  {
    _ESI = 1;
    v8 = _libc_multiple_threads == 0;
    if ( _libc_multiple_threads )
    {
      if ( !_InterlockedCompareExchange(_RBX, 1, 0) )
      {
LABEL_7:
        result = int_malloc(_RBX, 0x240uLL, a3, a4, (unsigned __int64)a5, a6);
        v13 = result;
        if ( result )
          goto LABEL_8;
        goto LABEL_19;
      }
    }
    else
    {
      __asm { cmpxchg [rbx], esi }
      if ( v8 )
        goto LABEL_7;
    }
    _lll_lock_wait_private((u32 *)_RBX, 1LL, a3, a4, a5, a6);
    goto LABEL_7;
  }
  _RBX = (int *)get_free_list(a1, a2, a3, a4, a5, a6);
  if ( _RBX )
    goto LABEL_7;
  _RBX = arena_get2_part_4(576LL, 0LL, a3, a4, a5, a6);
  result = int_malloc(_RBX, 0x240uLL, v14, v15, v16, v17);
  v13 = result;
  if ( !result && _RBX )
  {
LABEL_19:
    _RBX = (int *)arena_get_retry(_RBX, 576LL, (__int64)v13, v10, (__int64)v11, v12);
    result = int_malloc(_RBX, 0x240uLL, v18, v19, v20, v21);
    v13 = result;
  }
  if ( !_RBX )
    goto LABEL_13;
LABEL_8:
  if ( !_libc_multiple_threads )
  {
    v8 = (*_RBX)-- == 1;
    if ( v8 )
      goto LABEL_13;
    goto LABEL_12;
  }
  if ( _InterlockedDecrement(_RBX) )
LABEL_12:
    result = (_QWORD *)_lll_unlock_wake_private((u32 *)_RBX, 576LL, (__int64)v13, v10, v11, v12);
LABEL_13:
  if ( v13 )
  {
    __writefsqword(0xFFFFFFC8, (unsigned __int64)v13);
    result = 0LL;
    *v13 = 0LL;
    v13[71] = 0LL;
    memset(
      (void *)((unsigned __int64)(v13 + 1) & 0xFFFFFFFFFFFFFFF8LL),
      0,
      8LL * (((unsigned int)v13 - (((_DWORD)v13 + 8) & 0xFFFFFFF8) + 576) >> 3));
  }
  return result;
}
// 414A70: variable 'a3' is possibly undefined
// 414A70: variable 'a4' is possibly undefined
// 414A70: variable 'a5' is possibly undefined
// 414A70: variable 'a6' is possibly undefined
// 414A9F: variable 'v10' is possibly undefined
// 414A9F: variable 'v11' is possibly undefined
// 414A9F: variable 'v12' is possibly undefined
// 414AAE: variable 'v13' is possibly undefined
// 414B18: variable 'v14' is possibly undefined
// 414B18: variable 'v15' is possibly undefined
// 414B18: variable 'v16' is possibly undefined
// 414B18: variable 'v17' is possibly undefined
// 414B48: variable 'v18' is possibly undefined
// 414B48: variable 'v19' is possibly undefined
// 414B48: variable 'v20' is possibly undefined
// 414B48: variable 'v21' is possibly undefined
// 4AB820: using guessed type int _libc_multiple_threads;

//----- (0000000000414B60) ----------------------------------------------------
_QWORD *__fastcall int_memalign(
        int *a1,
        __int64 a2,
        unsigned __int64 a3,
        __int64 a4,
        unsigned __int64 a5,
        __int64 a6,
        double a7)
{
  unsigned __int64 v7; // rbx
  bool v8; // al
  unsigned __int64 v10; // rax
  unsigned __int64 v11; // r8
  unsigned __int64 v12; // r9
  _QWORD *v13; // rbp
  unsigned __int64 v14; // rcx
  __int64 v15; // rax
  unsigned __int64 v16; // rax
  unsigned __int64 v17; // rax
  unsigned __int64 v18; // rsi
  unsigned __int64 *v20; // r13
  unsigned __int64 v21; // rsi
  unsigned __int64 v22; // r15
  __int64 v23; // rax
  __int64 v24; // rdx
  unsigned __int64 v25; // rsi

  if ( a3 + 23 <= 0x1F )
  {
    v8 = 0;
    v7 = 32LL;
  }
  else
  {
    v7 = (a3 + 23) & 0xFFFFFFFFFFFFFFF0LL;
    v8 = v7 > 0xFFFFFFFFFFFFFFBFLL;
  }
  if ( v7 < a3 || v8 || -33 - a2 < v7 )
  {
    v13 = 0LL;
    __writefsdword(0xFFFFFFC0, 0xCu);
  }
  else
  {
    v10 = (unsigned __int64)int_malloc(a1, v7 + a2 + 32, a3, a4, a5, a6);
    v13 = (_QWORD *)v10;
    if ( v10 )
    {
      v14 = v10 - 16;
      if ( v10 % a2 )
      {
        v20 = (unsigned __int64 *)((-a2 & (v10 + a2 - 1)) - 16);
        v21 = (-a2 & (v10 + a2 - 1)) - v10;
        if ( v21 <= 0x1F )
        {
          v20 = (unsigned __int64 *)((char *)v20 + a2);
          v21 = (unsigned __int64)v20 - v14;
        }
        v22 = (*(_QWORD *)(v10 - 8) & 0xFFFFFFFFFFFFFFF8LL) - v21;
        v23 = *(_QWORD *)(v10 - 8) & 2LL;
        if ( (*(v13 - 1) & 2) != 0 )
        {
          v25 = *(v13 - 2) + v21;
          v13 = v20 + 2;
          *v20 = v25;
          v20[1] = v22 | 2;
          return v13;
        }
        v24 = (*(v13 - 1) & 0xFFFFFFFFFFFFFFF8LL) - v21;
        if ( a1 != &main_arena )
        {
          v24 = v22 | 4;
          v23 = 4LL;
        }
        v20[1] = v24 | 1;
        *(unsigned __int64 *)((char *)v20 + v22 + 8) |= 1uLL;
        *(v13 - 1) = v21 | *(v13 - 1) & 7LL | v23;
        int_free((__int64)a1, v14, 1uLL, v14, v11, v12);
        if ( v7 > v22 || (v13 = v20 + 2, (unsigned __int64)(v20 + 2) % a2) )
          _malloc_assert(
            "newsize >= nb && (((unsigned long) (chunk2mem (p))) % alignment) == 0",
            (__int64)"malloc.c",
            0x1286u,
            (__int64)"_int_memalign");
        v14 = (unsigned __int64)v20;
      }
      v15 = *(_QWORD *)(v14 + 8);
      if ( (v15 & 2) == 0 )
      {
        v16 = v15 & 0xFFFFFFFFFFFFFFF8LL;
        if ( v7 + 32 < v16 )
        {
          v17 = v16 - v7;
          v18 = v14 + v7;
          if ( a1 != &main_arena )
            v17 |= 4uLL;
          *(_QWORD *)(v18 + 8) = v17 | 1;
          *(_QWORD *)(v14 + 8) = *(_QWORD *)(v14 + 8) & 7LL | v7;
          int_free((__int64)a1, v18, 1uLL, v14, v11, v12);
        }
      }
    }
  }
  return v13;
}
// 414C20: variable 'v11' is possibly undefined
// 414C20: variable 'v12' is possibly undefined
// 4A8880: using guessed type int main_arena;

//----- (0000000000414D50) ----------------------------------------------------
__int64 __fastcall memalign_check(unsigned __int64 a1, int *a2, __int64 a3, __int64 a4, u32 *a5, __int64 a6, double a7)
{
  unsigned __int64 v8; // rbx
  __int64 v10; // rcx
  unsigned __int64 v11; // r8
  __int64 v12; // r9
  _QWORD *v13; // rdx
  __int64 v14; // rcx
  u32 *v15; // r8
  u32 v16; // er9

  if ( a1 <= 0x10 )
    return malloc_check(a2, 0LL, a3, a4, a5, a6);
  if ( a1 <= 0x1F )
  {
    v8 = 32LL;
    if ( (unsigned __int64)a2 <= 0xFFFFFFFFFFFFFFBFLL )
      goto LABEL_10;
  }
  else
  {
    if ( a1 > 0x8000000000000000LL )
    {
      __writefsdword(0xFFFFFFC0, 0x16u);
      return 0LL;
    }
    if ( -33LL - a1 >= (unsigned __int64)a2 )
    {
      a3 = a1 - 1;
      if ( (a1 & (a1 - 1)) != 0 )
      {
        v8 = 32LL;
        if ( a1 != 32 )
        {
          do
            v8 *= 2LL;
          while ( a1 > v8 );
        }
      }
      else
      {
        v8 = a1;
      }
LABEL_10:
      _ESI = 1;
      if ( _libc_multiple_threads )
      {
        if ( !_InterlockedCompareExchange(&main_arena, 1, 0) )
        {
LABEL_15:
          top_check(a1, 1LL, a3, a4, a5, a6);
          v13 = int_memalign(&main_arena, v8, (unsigned __int64)a2 + 1, v10, v11, v12, a7);
          if ( _libc_multiple_threads )
          {
            if ( !_InterlockedDecrement(&main_arena) )
              return mem2mem_check((__int64)v13, (unsigned __int64)a2);
          }
          else if ( !--main_arena )
          {
            return mem2mem_check((__int64)v13, (unsigned __int64)a2);
          }
          _lll_unlock_wake_private((u32 *)&main_arena, v8, (__int64)v13, v14, v15, v16);
          return mem2mem_check((__int64)v13, (unsigned __int64)a2);
        }
      }
      else
      {
        __asm { cmpxchg cs:main_arena, esi }
        if ( !_libc_multiple_threads )
          goto LABEL_15;
      }
      a1 = (unsigned __int64)&main_arena;
      _lll_lock_wait_private((u32 *)&main_arena, 1LL, a3, a4, a5, a6);
      goto LABEL_15;
    }
  }
  __writefsdword(0xFFFFFFC0, 0xCu);
  return 0LL;
}
// 414E0E: variable 'a3' is possibly undefined
// 414E0E: variable 'a4' is possibly undefined
// 414E0E: variable 'a5' is possibly undefined
// 414E0E: variable 'a6' is possibly undefined
// 414E21: variable 'v10' is possibly undefined
// 414E21: variable 'v11' is possibly undefined
// 414E21: variable 'v12' is possibly undefined
// 414E53: variable 'v14' is possibly undefined
// 414E53: variable 'v15' is possibly undefined
// 414E53: variable 'v16' is possibly undefined
// 414E6B: variable 'v13' is possibly undefined
// 4A8880: using guessed type int main_arena;
// 4AB820: using guessed type int _libc_multiple_threads;

//----- (0000000000414EC0) ----------------------------------------------------
__int64 *__fastcall free_check_part_2(__int64 a1, __int64 a2, __int64 a3, __int64 a4, u32 *a5, u32 a6)
{
  __int64 v6; // rdx
  unsigned __int64 v8; // rax
  __int64 v9; // rdx
  __int64 v10; // rcx
  u32 *v11; // r8
  unsigned __int64 v12; // r9
  __int64 *v13; // rsi
  __int64 *result; // rax
  __int64 v15; // rdx
  __int64 v16; // rcx
  u32 *v17; // r8
  u32 v18; // er9
  __int64 v19; // rdx
  __int64 v20; // rcx
  u32 *v21; // r8
  u32 v22; // er9

  v6 = a1;
  _ESI = 1;
  if ( !_libc_multiple_threads )
  {
    __asm { cmpxchg cs:main_arena, esi }
    if ( !_libc_multiple_threads )
      goto LABEL_6;
    goto LABEL_5;
  }
  if ( _InterlockedCompareExchange(&main_arena, 1, 0) )
LABEL_5:
    _lll_lock_wait_private((u32 *)&main_arena, 1LL, a1, a4, a5, a6);
LABEL_6:
  v8 = mem2chunk_check(v6, 0LL);
  if ( !v8 )
  {
    malloc_printerr((__int64)"free(): invalid pointer", 0LL, v9, v10, v11, v12);
    return free_check((__int64)"free(): invalid pointer", 0LL, v19, v20, v21, v22);
  }
  v13 = (__int64 *)v8;
  if ( (*(_BYTE *)(v8 + 8) & 2) != 0 )
  {
    if ( _libc_multiple_threads )
    {
      if ( !_InterlockedDecrement(&main_arena) )
        return munmap_chunk(v13, (__int64)v13, v9, v10, (__int64)v11, v12);
    }
    else if ( !--main_arena )
    {
      return munmap_chunk(v13, (__int64)v13, v9, v10, (__int64)v11, v12);
    }
    _lll_unlock_wake_private((u32 *)&main_arena, v8, v9, v10, v11, v12);
    return munmap_chunk(v13, (__int64)v13, v9, v10, (__int64)v11, v12);
  }
  result = (__int64 *)int_free((__int64)&main_arena, v8, 1uLL, v10, (unsigned __int64)v11, v12);
  if ( _libc_multiple_threads )
  {
    if ( !_InterlockedDecrement(&main_arena) )
      return result;
  }
  else if ( !--main_arena )
  {
    return result;
  }
  return (__int64 *)_lll_unlock_wake_private((u32 *)&main_arena, (__int64)v13, v15, v16, v17, v18);
}
// 414F0B: variable 'v6' is possibly undefined
// 414F2E: variable 'v10' is possibly undefined
// 414F2E: variable 'v11' is possibly undefined
// 414F2E: variable 'v12' is possibly undefined
// 414F5D: variable 'v15' is possibly undefined
// 414F5D: variable 'v16' is possibly undefined
// 414F5D: variable 'v17' is possibly undefined
// 414F5D: variable 'v18' is possibly undefined
// 414F9A: variable 'v9' is possibly undefined
// 414FBF: variable 'v19' is possibly undefined
// 414FBF: variable 'v20' is possibly undefined
// 414FBF: variable 'v21' is possibly undefined
// 414FBF: variable 'v22' is possibly undefined
// 4A8880: using guessed type int main_arena;
// 4AB820: using guessed type int _libc_multiple_threads;

//----- (0000000000414FC0) ----------------------------------------------------
__int64 *__fastcall free_check(__int64 a1, __int64 a2, __int64 a3, __int64 a4, u32 *a5, u32 a6)
{
  __int64 *result; // rax

  if ( a1 )
    return free_check_part_2(a1, a2, a3, a4, a5, a6);
  return result;
}

//----- (0000000000414FE0) ----------------------------------------------------
_QWORD *__fastcall int_realloc(
        __int64 a1,
        unsigned __int64 a2,
        unsigned __int64 a3,
        unsigned __int64 a4,
        u32 *a5,
        unsigned __int64 a6)
{
  unsigned __int64 v6; // rbx
  __int64 v7; // r12
  __int64 v8; // r13
  unsigned __int64 v9; // rax
  u32 *v10; // rbp
  unsigned __int64 v11; // rdi
  u32 *v12; // r8
  u32 **v13; // rsi
  u32 *v14; // rdx
  unsigned __int64 v15; // rax
  unsigned __int64 v16; // rdi
  _QWORD *v17; // r14
  unsigned __int64 v19; // rsi
  _QWORD *v20; // rax
  unsigned __int64 v21; // rax
  __int64 v22; // rcx
  unsigned __int64 v23; // r8
  unsigned __int64 v24; // r9
  unsigned __int64 v25; // rax
  __int64 v26; // rdi
  __int64 v27; // rdx
  __int64 v28; // rsi
  __int64 v29; // rsi
  unsigned __int64 v30; // [rsp+0h] [rbp-38h]
  unsigned __int64 v31; // [rsp+8h] [rbp-30h]

  v9 = *(_QWORD *)(a2 + 8);
  if ( v9 <= 0x10 || (v6 = a2, a2 = *(_QWORD *)(a1 + 2184), v7 = a1, a2 <= a3) )
  {
    malloc_printerr((__int64)"realloc(): invalid old size", a2, a3, a4, a5, a6);
LABEL_33:
    LOBYTE(v9) = (unsigned __int8)malloc_printerr((__int64)"realloc(): invalid next size", a2, a3, a4, v12, a6);
    goto LABEL_34;
  }
  v8 = v9 & 2;
  if ( (v9 & 2) != 0 )
    _malloc_assert("!chunk_is_mmapped (oldp)", (__int64)"malloc.c", 0x11DAu, (__int64)"_int_realloc");
  v10 = (u32 *)(v6 + a3);
  v11 = *(_QWORD *)(v6 + a3 + 8);
  v12 = (u32 *)(v11 & 0xFFFFFFFFFFFFFFF8LL);
  if ( v11 <= 0x10 || a2 <= (unsigned __int64)v12 )
    goto LABEL_33;
  if ( a3 >= a4 )
  {
LABEL_16:
    v15 = v9 & 7;
    v16 = a3 - a4;
    if ( a3 - a4 > 0x1F )
    {
      v19 = v6 + a4;
      if ( (int *)v7 != &main_arena )
      {
        v16 |= 4uLL;
        v8 = 4LL;
      }
      *(_QWORD *)(v6 + 8) = v8 | a4 | v15;
      *(_QWORD *)(v19 + 8) = v16 | 1;
      *((_QWORD *)v10 + 1) |= 1uLL;
      int_free(v7, v19, 1uLL, a4, (unsigned __int64)v12, a6);
    }
    else
    {
      if ( (int *)v7 != &main_arena )
        v8 = 4LL;
      *(_QWORD *)(v6 + 8) = v8 | a3 | v15;
      *((_QWORD *)v10 + 1) |= 1uLL;
    }
    return (_QWORD *)(v6 + 16);
  }
  if ( *(u32 **)(v7 + 96) != v10 )
  {
    v13 = (u32 **)((char *)v12 + (_QWORD)v10);
    if ( (*((_BYTE *)v12 + (_QWORD)v10 + 8) & 1) == 0 )
    {
      a6 = (unsigned __int64)v12 + a3;
      if ( a4 <= (unsigned __int64)v12 + a3 )
      {
        if ( *v13 == v12 )
        {
          v14 = (u32 *)*((_QWORD *)v10 + 2);
          v13 = (u32 **)*((_QWORD *)v10 + 3);
          if ( *((u32 **)v14 + 3) == v10 && v13[2] == v10 )
          {
            *((_QWORD *)v14 + 3) = v13;
            v13[2] = v14;
            if ( v11 <= 0x3FF || (v13 = (u32 **)*((_QWORD *)v10 + 4)) == 0LL )
            {
              v10 = (u32 *)(v6 + a6);
              a3 = a6;
              goto LABEL_16;
            }
LABEL_39:
            if ( v13[5] == v10 && (v26 = *((_QWORD *)v10 + 5), *(u32 **)(v26 + 32) == v10) )
            {
              v12 = (u32 *)(v6 + a6);
              if ( *((_QWORD *)v14 + 4) )
              {
                v13[5] = (u32 *)v26;
                v27 = *((_QWORD *)v10 + 5);
                v10 = (u32 *)(v6 + a6);
                *(_QWORD *)(v27 + 32) = v13;
                a3 = a6;
                goto LABEL_16;
              }
              if ( v13 != (u32 **)v10 )
              {
                *((_QWORD *)v14 + 4) = v13;
                v28 = *((_QWORD *)v10 + 4);
                *((_QWORD *)v14 + 5) = v26;
                *(_QWORD *)(v28 + 40) = v14;
                v29 = *((_QWORD *)v10 + 5);
                v10 = (u32 *)(v6 + a6);
                *(_QWORD *)(v29 + 32) = v14;
                a3 = a6;
                goto LABEL_16;
              }
            }
            else
            {
              LOBYTE(v9) = (unsigned __int8)malloc_printerr(
                                              (__int64)"corrupted double-linked list (not small)",
                                              (__int64)v13,
                                              (__int64)v14,
                                              a4,
                                              v12,
                                              a6);
            }
            *((_QWORD *)v14 + 5) = v14;
            v10 = v12;
            *((_QWORD *)v14 + 4) = v14;
            a3 = a6;
            goto LABEL_16;
          }
          malloc_printerr((__int64)"corrupted double-linked list", (__int64)v13, (__int64)v14, a4, v12, a6);
        }
        LOBYTE(v9) = (unsigned __int8)malloc_printerr(
                                        (__int64)"corrupted size vs. prev_size",
                                        (__int64)v13,
                                        a3,
                                        a4,
                                        v12,
                                        a6);
        goto LABEL_39;
      }
    }
LABEL_26:
    v30 = a3;
    v31 = a4;
    v20 = int_malloc((int *)v7, a4 - 15, a3, a4, (unsigned __int64)v12, a6);
    v17 = v20;
    if ( !v20 )
      return v17;
    v21 = *(v20 - 1) & 0xFFFFFFFFFFFFFFF8LL;
    if ( v10 != (u32 *)(v17 - 2) )
    {
      j_memcpy(v17, v6 + 16, v30 - 8);
      int_free(v7, v6, 1uLL, v22, v23, v24);
      return v17;
    }
    a4 = v31;
    a3 = v21 + v30;
    if ( v31 > v21 + v30 )
      _malloc_assert(
        "(unsigned long) (newsize) >= (unsigned long) (nb)",
        (__int64)"malloc.c",
        0x121Fu,
        (__int64)"_int_realloc");
    v9 = *(_QWORD *)(v6 + 8);
    v10 = (u32 *)(v6 + a3);
    goto LABEL_16;
  }
  v12 = (u32 *)((char *)v12 + a3);
  if ( a4 + 32 > (unsigned __int64)v12 )
    goto LABEL_26;
LABEL_34:
  v25 = v9 & 7;
  v17 = (_QWORD *)(v6 + 16);
  if ( (int *)v7 != &main_arena )
    v8 = 4LL;
  *(_QWORD *)(v6 + 8) = v8 | a4 | v25;
  *(_QWORD *)(v7 + 96) = v6 + a4;
  *(_QWORD *)(v6 + a4 + 8) = ((unsigned __int64)v12 - a4) | 1;
  return v17;
}
// 4150BE: variable 'a4' is possibly undefined
// 415139: variable 'v12' is possibly undefined
// 415139: variable 'a6' is possibly undefined
// 4151FB: variable 'v22' is possibly undefined
// 4151FB: variable 'v23' is possibly undefined
// 4151FB: variable 'v24' is possibly undefined
// 41521F: variable 'a3' is possibly undefined
// 415232: variable 'v6' is possibly undefined
// 41523E: variable 'v7' is possibly undefined
// 41524C: variable 'v8' is possibly undefined
// 415290: variable 'v14' is possibly undefined
// 401040: using guessed type __int64 __fastcall j_memcpy(_QWORD, _QWORD, _QWORD);
// 4A8880: using guessed type int main_arena;

//----- (0000000000415310) ----------------------------------------------------
// bad sp value at call has been detected, the output may be wrong!
__int64 __fastcall realloc_check(int *a1, int *a2, __int64 a3, __int64 a4, u32 *a5, __int64 a6)
{
  char *v6; // rbp
  __int64 v9; // rdx
  __int64 v10; // rcx
  u32 *v11; // r8
  __int64 v12; // r9
  __int64 *v13; // r14
  char *v14; // r15
  unsigned __int64 v15; // r12
  unsigned __int64 v17; // r13
  char *v18; // rsi
  __int64 *v19; // rax
  __int64 v20; // rdx
  __int64 v21; // rcx
  u32 *v22; // r8
  __int64 v23; // r9
  u32 *v25; // r8
  unsigned __int64 v26; // r9
  __int64 v27; // rdx
  __int64 v28; // rcx
  unsigned __int64 v29; // r8
  __int64 v30; // r9
  char *v31; // rax
  __int64 v32; // rdx
  __int64 v33; // rcx
  __int64 v34; // r8
  __int64 v35; // r9
  __int64 v36; // rdx
  __int64 v37; // rcx
  u32 *v38; // r8
  u32 v39; // er9
  __int64 v40[9]; // [rsp+0h] [rbp-48h] BYREF

  v40[1] = __readfsqword(0x28u);
  if ( a2 == (int *)-1LL )
    goto LABEL_29;
  v6 = (char *)a1;
  if ( !a1 )
    return malloc_check(a2, 0LL, a3, a4, a5, a6);
  if ( !a2 )
  {
    free_check_part_2((__int64)a1, 0LL, a3, a4, a5, a6);
    return 0LL;
  }
  _ESI = 1;
  if ( !_libc_multiple_threads )
  {
    __asm { cmpxchg cs:main_arena, esi }
    if ( !_libc_multiple_threads )
      goto LABEL_9;
    goto LABEL_8;
  }
  if ( _InterlockedCompareExchange(&main_arena, 1, 0) )
LABEL_8:
    _lll_lock_wait_private((u32 *)&main_arena, 1LL, a3, a4, a5, a6);
LABEL_9:
  v13 = (__int64 *)mem2chunk_check((__int64)a1, v40);
  if ( _libc_multiple_threads )
  {
    if ( !_InterlockedDecrement(&main_arena) )
      goto LABEL_14;
    goto LABEL_13;
  }
  if ( --main_arena )
  {
LABEL_13:
    a1 = &main_arena;
    _lll_unlock_wake_private((u32 *)&main_arena, (__int64)v40, v9, v10, v11, v12);
  }
LABEL_14:
  if ( v13 )
  {
    v14 = (char *)a2 + 1;
    if ( (unsigned __int64)(a2 + 6) > 0x1F )
    {
      v15 = (unsigned __int64)(a2 + 6) & 0xFFFFFFFFFFFFFFF0LL;
      if ( v15 <= 0xFFFFFFFFFFFFFFBFLL && v15 >= (unsigned __int64)v14 )
      {
LABEL_18:
        _ESI = 1;
        v17 = v13[1] & 0xFFFFFFFFFFFFFFF8LL;
        if ( _libc_multiple_threads )
        {
          if ( !_InterlockedCompareExchange(&main_arena, 1, 0) )
          {
LABEL_23:
            if ( (v13[1] & 2) != 0 )
            {
              v18 = (char *)v15;
              v19 = mremap_chunk(v13, v15);
              if ( v19 )
              {
                v6 = (char *)(v19 + 2);
                if ( v19 != (__int64 *)-16LL )
                  goto LABEL_31;
                goto LABEL_26;
              }
              if ( v17 - 8 >= v15 )
              {
LABEL_31:
                if ( _libc_multiple_threads )
                {
                  if ( !_InterlockedDecrement(&main_arena) )
                    return mem2mem_check((__int64)v6, (unsigned __int64)a2);
                }
                else if ( !--main_arena )
                {
                  return mem2mem_check((__int64)v6, (unsigned __int64)a2);
                }
                _lll_unlock_wake_private((u32 *)&main_arena, (__int64)v18, v20, v21, v22, v23);
                return mem2mem_check((__int64)v6, (unsigned __int64)a2);
              }
              top_check((__int64)v13, v15, v20, v21, v22, v23);
              v18 = (char *)a2 + 1;
              v31 = (char *)int_malloc(&main_arena, (unsigned __int64)a2 + 1, v27, v28, v29, v30);
              if ( v31 )
              {
                v18 = v6;
                v6 = v31;
                j_memcpy(v31, v18, v17 - 16);
                munmap_chunk(v13, (__int64)v18, v32, v33, v34, v35);
                goto LABEL_31;
              }
            }
            else
            {
              top_check((__int64)a1, 1LL, v9, v10, v11, v12);
              v18 = (char *)v13;
              v6 = (char *)int_realloc((__int64)&main_arena, (unsigned __int64)v13, v17, v15, v25, v26);
              if ( v6 )
                goto LABEL_31;
            }
LABEL_26:
            v6 = 0LL;
            *(_BYTE *)v40[0] = ~*(_BYTE *)v40[0];
            goto LABEL_31;
          }
        }
        else
        {
          __asm { cmpxchg cs:main_arena, esi }
          if ( !_libc_multiple_threads )
            goto LABEL_23;
        }
        a1 = &main_arena;
        _lll_lock_wait_private((u32 *)&main_arena, 1LL, v9, v10, v11, v12);
        goto LABEL_23;
      }
    }
    else if ( (unsigned __int64)v14 <= 0x20 )
    {
      v15 = 32LL;
      goto LABEL_18;
    }
LABEL_29:
    __writefsdword(0xFFFFFFC0, 0xCu);
    return 0LL;
  }
  malloc_printerr((__int64)"realloc(): invalid pointer", (__int64)v40, v9, v10, v11, v12);
  return _malloc_fork_lock_parent((__int64)"realloc(): invalid pointer", (__int64)v40, v36, v37, v38, v39);
}
// 4155BC: bad sp value at call
// 4153CB: variable 'v9' is possibly undefined
// 4153CB: variable 'v10' is possibly undefined
// 4153CB: variable 'v11' is possibly undefined
// 4153CB: variable 'v12' is possibly undefined
// 4154E5: variable 'v25' is possibly undefined
// 4154E5: variable 'v26' is possibly undefined
// 415520: variable 'v20' is possibly undefined
// 415520: variable 'v21' is possibly undefined
// 415520: variable 'v22' is possibly undefined
// 415520: variable 'v23' is possibly undefined
// 415558: variable 'v27' is possibly undefined
// 415558: variable 'v28' is possibly undefined
// 415558: variable 'v29' is possibly undefined
// 415558: variable 'v30' is possibly undefined
// 41557E: variable 'v32' is possibly undefined
// 41557E: variable 'v33' is possibly undefined
// 41557E: variable 'v34' is possibly undefined
// 41557E: variable 'v35' is possibly undefined
// 4155BC: variable 'v36' is possibly undefined
// 4155BC: variable 'v37' is possibly undefined
// 4155BC: variable 'v38' is possibly undefined
// 4155BC: variable 'v39' is possibly undefined
// 401040: using guessed type __int64 __fastcall j_memcpy(_QWORD, _QWORD, _QWORD);
// 4A8880: using guessed type int main_arena;
// 4AB820: using guessed type int _libc_multiple_threads;

//----- (00000000004155C0) ----------------------------------------------------
__int64 __fastcall _malloc_fork_lock_parent(__int64 a1, __int64 a2, __int64 a3, __int64 a4, u32 *a5, u32 a6)
{
  __int64 result; // rax
  u32 *v8; // r8
  unsigned __int32 v9; // er10
  unsigned __int32 v10; // er9
  bool v13; // zf

  result = (unsigned int)_libc_malloc_initialized;
  if ( _libc_malloc_initialized > 0 )
  {
    _ESI = 1;
    if ( _libc_multiple_threads )
    {
      if ( !_InterlockedCompareExchange(&list_lock, 1, 0) )
        goto LABEL_7;
    }
    else
    {
      __asm { cmpxchg cs:list_lock, esi }
      if ( !_libc_multiple_threads )
      {
LABEL_7:
        v8 = (u32 *)&main_arena;
        v9 = 1;
        v10 = 0;
        _RDX = &main_arena;
        while ( 1 )
        {
          _ESI = v9;
          result = v10;
          v13 = _libc_multiple_threads == 0;
          if ( _libc_multiple_threads )
            break;
          __asm { cmpxchg [rdx], esi }
          if ( !v13 )
            goto LABEL_12;
LABEL_13:
          _RDX = (int *)*((_QWORD *)_RDX + 270);
          if ( _RDX == (int *)v8 )
            return result;
        }
        result = (unsigned int)_InterlockedCompareExchange(_RDX, v9, v10);
        if ( v10 == (_DWORD)result )
          goto LABEL_13;
LABEL_12:
        result = _lll_lock_wait_private((u32 *)_RDX, v9, (__int64)_RDX, a4, v8, v10);
        goto LABEL_13;
      }
    }
    _lll_lock_wait_private((u32 *)&list_lock, 1LL, a3, a4, a5, a6);
    goto LABEL_7;
  }
  return result;
}
// 415628: variable 'v9' is possibly undefined
// 41562B: variable 'v10' is possibly undefined
// 41564E: variable 'a4' is possibly undefined
// 41564E: variable 'v8' is possibly undefined
// 41565A: variable '_RDX' is possibly undefined
// 4A87C4: using guessed type int _libc_malloc_initialized;
// 4A8880: using guessed type int main_arena;
// 4AADA0: using guessed type int list_lock;
// 4AB820: using guessed type int _libc_multiple_threads;

//----- (0000000000415670) ----------------------------------------------------
signed __int64 __fastcall _malloc_fork_unlock_parent(__int64 a1, __int64 a2, __int64 a3, __int64 a4, u32 *a5, u32 a6)
{
  signed __int64 result; // rax
  int *v7; // rdx

  result = (unsigned int)_libc_malloc_initialized;
  if ( _libc_malloc_initialized > 0 )
  {
    v7 = &main_arena;
    while ( !_libc_multiple_threads )
    {
      if ( (*v7)-- != 1 )
        goto LABEL_7;
LABEL_8:
      v7 = (int *)*((_QWORD *)v7 + 270);
      if ( v7 == &main_arena )
      {
        if ( _libc_multiple_threads )
        {
          if ( !_InterlockedDecrement(&list_lock) )
            return result;
        }
        else if ( !--list_lock )
        {
          return result;
        }
        return _lll_unlock_wake_private((u32 *)&list_lock, (__int64)&main_arena, (__int64)v7, a4, a5, a6);
      }
    }
    if ( !_InterlockedDecrement(v7) )
      goto LABEL_8;
LABEL_7:
    result = _lll_unlock_wake_private((u32 *)v7, (__int64)&main_arena, (__int64)v7, a4, a5, a6);
    goto LABEL_8;
  }
  return result;
}
// 4156AE: variable 'a4' is possibly undefined
// 4156AE: variable 'a5' is possibly undefined
// 4156AE: variable 'a6' is possibly undefined
// 4156BA: variable 'v7' is possibly undefined
// 4A87C4: using guessed type int _libc_malloc_initialized;
// 4A8880: using guessed type int main_arena;
// 4AADA0: using guessed type int list_lock;
// 4AB820: using guessed type int _libc_multiple_threads;

//----- (0000000000415700) ----------------------------------------------------
int *_malloc_fork_unlock_child()
{
  int *result; // rax
  unsigned __int64 v1; // rcx
  char v2; // di
  int *v3; // rdx

  result = (int *)(unsigned int)_libc_malloc_initialized;
  if ( _libc_malloc_initialized > 0 )
  {
    free_list_lock = 0;
    v1 = __readfsqword(0xFFFFFFD8);
    if ( v1 )
      *(_QWORD *)(v1 + 2176) = 1LL;
    free_list = 0LL;
    v2 = 0;
    v3 = 0LL;
    result = &main_arena;
    do
    {
      *result = 0;
      if ( (int *)v1 != result )
      {
        *((_QWORD *)result + 272) = 0LL;
        v2 = 1;
        *((_QWORD *)result + 271) = v3;
        v3 = result;
      }
      result = (int *)*((_QWORD *)result + 270);
    }
    while ( result != &main_arena );
    if ( v2 )
      free_list = (__int64)v3;
    list_lock = 0;
  }
  return result;
}
// 4A87C4: using guessed type int _libc_malloc_initialized;
// 4A8880: using guessed type int main_arena;
// 4AADA0: using guessed type int list_lock;
// 4AADA8: using guessed type __int64 free_list;
// 4AADB0: using guessed type int free_list_lock;

//----- (00000000004157A0) ----------------------------------------------------
__int64 (__fastcall *_malloc_check_init())(unsigned __int64 a1, int *a2, __int64 a3, __int64 a4, u32 *a5, __int64 a6, double a7)
{
  __int64 (__fastcall *result)(unsigned __int64, int *, __int64, __int64, u32 *, __int64, double); // rax

  using_malloc_checking = 1;
  _malloc_hook = (__int64 (__fastcall *)(_QWORD, _QWORD))malloc_check;
  _free_hook = (__int64 (__fastcall *)(_QWORD, _QWORD))free_check;
  _realloc_hook = (__int64 (__fastcall *)(_QWORD, _QWORD, _QWORD))realloc_check;
  result = memalign_check;
  _memalign_hook = (__int64 (__fastcall *)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, double))memalign_check;
  return result;
}
// 4A8860: using guessed type __int64 (__fastcall *_memalign_hook)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, double);
// 4A8868: using guessed type __int64 (__fastcall *_realloc_hook)(_QWORD, _QWORD, _QWORD);
// 4A8870: using guessed type __int64 (__fastcall *_malloc_hook)(_QWORD, _QWORD);
// 4AAD78: using guessed type __int64 (__fastcall *_free_hook)(_QWORD, _QWORD);
// 4AAD90: using guessed type int using_malloc_checking;

//----- (00000000004157F0) ----------------------------------------------------
_QWORD *__fastcall malloc(unsigned __int64 a1, __int64 a2, _QWORD *a3, __int64 a4, u32 *a5, __int64 a6)
{
  unsigned __int64 v6; // rax
  unsigned __int64 v7; // rbx
  unsigned __int64 v8; // rax
  unsigned __int64 v9; // r12
  _QWORD *v10; // rax
  __int64 v11; // rax
  bool v15; // zf
  __int64 v16; // rsi
  __int64 v17; // rcx
  u32 *v18; // r8
  u32 v19; // er9
  __int64 v20; // rax
  int *v21; // rcx
  __int64 v22; // rdx
  __int64 v23; // rcx
  unsigned __int64 v24; // r8
  __int64 v25; // r9
  __int64 v26; // rdx
  __int64 v27; // rcx
  unsigned __int64 v28; // r8
  __int64 v29; // r9
  void *retaddr; // [rsp+18h] [rbp+0h]

  if ( _malloc_hook )
    return (_QWORD *)_malloc_hook(a1, retaddr);
  if ( a1 + 23 > 0x1F )
  {
    v6 = (a1 + 23) & 0xFFFFFFFFFFFFFFF0LL;
    LOBYTE(a3) = v6 > 0xFFFFFFFFFFFFFFBFLL;
  }
  else
  {
    a3 = 0LL;
    v6 = 32LL;
  }
  if ( v6 >= a1 && !(_BYTE)a3 )
  {
    v7 = v6 - 17;
    v8 = __readfsqword(0xFFFFFFC8);
    v9 = v7 >> 4;
    if ( v8 )
    {
      if ( v9 >= qword_4A8830 )
        goto LABEL_8;
    }
    else
    {
      if ( __readfsbyte(0xFFFFFFD0) )
        goto LABEL_8;
      tcache_init_part_5(a1, a2, (__int64)a3, a4, a5, a6);
      if ( qword_4A8830 <= v9 )
        goto LABEL_8;
      v8 = __readfsqword(0xFFFFFFC8);
      if ( !v8 )
        goto LABEL_8;
    }
    a4 = v8 + 8 * v9;
    a3 = *(_QWORD **)(a4 + 64);
    if ( a3 )
    {
      if ( v7 > 0x3FF )
        _malloc_assert("tc_idx < TCACHE_MAX_BINS", (__int64)"malloc.c", 0xB7Fu, (__int64)"tcache_get");
      *(_QWORD *)(a4 + 64) = *a3;
      --*(_BYTE *)(v8 + v9);
      a3[1] = 0LL;
      return a3;
    }
LABEL_8:
    if ( !_libc_multiple_threads )
    {
      v10 = int_malloc(&main_arena, a1, (__int64)a3, a4, (unsigned __int64)a5, a6);
      a3 = v10;
      if ( v10 )
      {
        v11 = *(v10 - 1);
        if ( (v11 & 2) == 0
          && (v11 & 4) != 0
          && *(int **)((unsigned __int64)(a3 - 2) & 0xFFFFFFFFFC000000LL) != &main_arena )
        {
          _malloc_assert(
            "!victim || chunk_is_mmapped (mem2chunk (victim)) || &main_arena == arena_for_chunk (mem2chunk (victim))",
            (__int64)"malloc.c",
            0xBF6u,
            (__int64)"__libc_malloc");
        }
        return a3;
      }
      return 0LL;
    }
    _RBX = (volatile signed __int32 *)__readfsqword(0xFFFFFFD8);
    if ( _RBX )
    {
      _ESI = 1;
      v15 = _libc_multiple_threads == 0;
      if ( _libc_multiple_threads )
      {
        if ( !_InterlockedCompareExchange(_RBX, 1, 0) )
          goto LABEL_31;
      }
      else
      {
        __asm { cmpxchg [rbx], esi }
        if ( v15 )
          goto LABEL_31;
      }
      _lll_lock_wait_private((u32 *)_RBX, 1LL, (__int64)a3, a4, a5, a6);
      goto LABEL_31;
    }
    _RBX = (volatile signed __int32 *)get_free_list(a1, a2, (__int64)a3, a4, a5, a6);
    if ( !_RBX )
    {
      v16 = a1;
      _RBX = arena_get2_part_4(a1, 0LL, (__int64)a3, a4, a5, a6);
      a3 = int_malloc((int *)_RBX, a1, v22, v23, v24, v25);
      if ( a3 || !_RBX )
      {
LABEL_47:
        if ( !_RBX )
          goto LABEL_37;
LABEL_32:
        if ( _libc_multiple_threads )
        {
          if ( !_InterlockedDecrement(_RBX) )
          {
LABEL_37:
            if ( a3 )
            {
              v20 = *(a3 - 1);
              if ( (v20 & 2) == 0 )
              {
                v21 = &main_arena;
                if ( (v20 & 4) != 0 )
                  v21 = *(int **)((unsigned __int64)(a3 - 2) & 0xFFFFFFFFFC000000LL);
                if ( v21 != _RBX )
                  _malloc_assert(
                    "!victim || chunk_is_mmapped (mem2chunk (victim)) || ar_ptr == arena_for_chunk (mem2chunk (victim))",
                    (__int64)"malloc.c",
                    0xC0Au,
                    (__int64)"__libc_malloc");
              }
              return a3;
            }
            return 0LL;
          }
        }
        else
        {
          v15 = (*_RBX)-- == 1;
          if ( v15 )
            goto LABEL_37;
        }
        _lll_unlock_wake_private((u32 *)_RBX, v16, (__int64)a3, v17, v18, v19);
        goto LABEL_37;
      }
LABEL_46:
      v16 = a1;
      _RBX = (volatile signed __int32 *)arena_get_retry(_RBX, a1, (__int64)a3, v17, (__int64)v18, v19);
      a3 = int_malloc((int *)_RBX, a1, v26, v27, v28, v29);
      goto LABEL_47;
    }
LABEL_31:
    v16 = a1;
    a3 = int_malloc((int *)_RBX, a1, (__int64)a3, a4, (unsigned __int64)a5, a6);
    if ( a3 )
      goto LABEL_32;
    goto LABEL_46;
  }
  __writefsdword(0xFFFFFFC0, 0xCu);
  return 0LL;
}
// 415873: variable 'a3' is possibly undefined
// 415873: variable 'a4' is possibly undefined
// 415873: variable 'a5' is possibly undefined
// 415873: variable 'a6' is possibly undefined
// 415A1C: variable 'v17' is possibly undefined
// 415A1C: variable 'v18' is possibly undefined
// 415A1C: variable 'v19' is possibly undefined
// 415AA4: variable 'v22' is possibly undefined
// 415AA4: variable 'v23' is possibly undefined
// 415AA4: variable 'v24' is possibly undefined
// 415AA4: variable 'v25' is possibly undefined
// 415AD5: variable 'v26' is possibly undefined
// 415AD5: variable 'v27' is possibly undefined
// 415AD5: variable 'v28' is possibly undefined
// 415AD5: variable 'v29' is possibly undefined
// 4A8830: using guessed type __int64 qword_4A8830;
// 4A8870: using guessed type __int64 (__fastcall *_malloc_hook)(_QWORD, _QWORD);
// 4A8880: using guessed type int main_arena;
// 4AB820: using guessed type int _libc_multiple_threads;

//----- (0000000000415B10) ----------------------------------------------------
_QWORD *__fastcall malloc_hook_ini(unsigned __int64 a1, __int64 a2, _QWORD *a3, __int64 a4, u32 *a5, __int64 a6)
{
  _malloc_hook = 0LL;
  if ( _libc_malloc_initialized < 0 )
    ptmalloc_init_part_0();
  return malloc(a1, a2, a3, a4, a5, a6);
}
// 415B29: variable 'a3' is possibly undefined
// 415B29: variable 'a4' is possibly undefined
// 415B29: variable 'a5' is possibly undefined
// 415B29: variable 'a6' is possibly undefined
// 4A87C4: using guessed type int _libc_malloc_initialized;
// 4A8870: using guessed type __int64 (__fastcall *_malloc_hook)(_QWORD, _QWORD);

//----- (0000000000415B50) ----------------------------------------------------
_QWORD *__fastcall mid_memalign(
        unsigned __int64 a1,
        unsigned __int64 a2,
        _QWORD *a3,
        __int64 a4,
        u32 *a5,
        __int64 a6,
        double a7)
{
  unsigned __int64 v7; // rbx
  _QWORD *v9; // rax
  _QWORD *v10; // rdx
  __int64 v11; // rax
  bool v15; // zf
  __int64 v16; // rsi
  __int64 v17; // rcx
  u32 *v18; // r8
  u32 v19; // er9
  __int64 v20; // rax
  int *v21; // rcx
  __int64 v22; // rdx
  int *v23; // rax
  __int64 v24; // rcx
  unsigned __int64 v25; // r8
  __int64 v26; // r9
  __int64 v27; // rcx
  unsigned __int64 v28; // r8
  __int64 v29; // r9

  if ( !_memalign_hook )
  {
    if ( a1 <= 0x10 )
      return malloc(a2, a2, a3, a4, a5, a6);
    if ( a1 <= 0x1F )
    {
      v7 = 32LL;
      if ( a2 <= 0xFFFFFFFFFFFFFFBFLL )
        goto LABEL_11;
    }
    else
    {
      if ( a1 > 0x8000000000000000LL )
      {
        v10 = 0LL;
        __writefsdword(0xFFFFFFC0, 0x16u);
        return v10;
      }
      if ( -33LL - a1 >= a2 )
      {
        if ( (a1 & (a1 - 1)) != 0 )
        {
          v7 = 32LL;
          if ( a1 != 32 )
          {
            do
              v7 *= 2LL;
            while ( a1 > v7 );
          }
        }
        else
        {
          v7 = a1;
        }
LABEL_11:
        if ( !_libc_multiple_threads )
        {
          v9 = int_memalign(&main_arena, v7, a2, a4, (unsigned __int64)a5, a6, a7);
          v10 = v9;
          if ( v9 )
          {
            v11 = *(v9 - 1);
            if ( (v11 & 2) == 0
              && (v11 & 4) != 0
              && *(int **)((unsigned __int64)(v10 - 2) & 0xFFFFFFFFFC000000LL) != &main_arena )
            {
              _malloc_assert(
                "!p || chunk_is_mmapped (mem2chunk (p)) || &main_arena == arena_for_chunk (mem2chunk (p))",
                (__int64)"malloc.c",
                0xCEEu,
                (__int64)"_mid_memalign");
            }
            return v10;
          }
          return 0LL;
        }
        _R12 = (volatile signed __int32 *)__readfsqword(0xFFFFFFD8);
        if ( _R12 )
        {
          _ESI = 1;
          v15 = _libc_multiple_threads == 0;
          if ( _libc_multiple_threads )
          {
            if ( !_InterlockedCompareExchange(_R12, 1, 0) )
              goto LABEL_29;
          }
          else
          {
            __asm { cmpxchg [r12], esi }
            if ( v15 )
              goto LABEL_29;
          }
          _lll_lock_wait_private((u32 *)_R12, 1LL, (__int64)a3, a4, a5, a6);
          goto LABEL_29;
        }
        _R12 = (volatile signed __int32 *)get_free_list(a1, a2, (__int64)a3, a4, a5, a6);
        if ( !_R12 )
        {
          v23 = arena_get2_part_4(v7 + a2 + 32, 0LL, v22, a4, a5, a6);
          v16 = v7;
          _R12 = v23;
          v10 = int_memalign(v23, v7, a2, v24, v25, v26, a7);
          if ( v10 || !_R12 )
          {
LABEL_45:
            if ( !_R12 )
              goto LABEL_35;
LABEL_30:
            if ( _libc_multiple_threads )
            {
              if ( !_InterlockedDecrement(_R12) )
              {
LABEL_35:
                if ( v10 )
                {
                  v20 = *(v10 - 1);
                  if ( (v20 & 2) == 0 )
                  {
                    v21 = &main_arena;
                    if ( (v20 & 4) != 0 )
                      v21 = *(int **)((unsigned __int64)(v10 - 2) & 0xFFFFFFFFFC000000LL);
                    if ( v21 != _R12 )
                      _malloc_assert(
                        "!p || chunk_is_mmapped (mem2chunk (p)) || ar_ptr == arena_for_chunk (mem2chunk (p))",
                        (__int64)"malloc.c",
                        0xD01u,
                        (__int64)"_mid_memalign");
                  }
                  return v10;
                }
                return 0LL;
              }
            }
            else
            {
              v15 = (*_R12)-- == 1;
              if ( v15 )
                goto LABEL_35;
            }
            _lll_unlock_wake_private((u32 *)_R12, v16, (__int64)v10, v17, v18, v19);
            goto LABEL_35;
          }
LABEL_44:
          v16 = v7;
          _R12 = (volatile signed __int32 *)arena_get_retry(_R12, a2, (__int64)v10, v17, (__int64)v18, v19);
          v10 = int_memalign((int *)_R12, v7, a2, v27, v28, v29, a7);
          goto LABEL_45;
        }
LABEL_29:
        v16 = v7;
        v10 = int_memalign((int *)_R12, v7, a2, a4, (unsigned __int64)a5, a6, a7);
        if ( v10 )
          goto LABEL_30;
        goto LABEL_44;
      }
    }
    v10 = 0LL;
    __writefsdword(0xFFFFFFC0, 0xCu);
    return v10;
  }
  return (_QWORD *)_memalign_hook(a1, a2, a3, a4, a5, a7);
}
// 4A8860: invalid function type has been ignored
// 415C51: variable 'v10' is possibly undefined
// 415CF5: variable 'a4' is possibly undefined
// 415CF5: variable 'a5' is possibly undefined
// 415CF5: variable 'a6' is possibly undefined
// 415D29: variable 'v17' is possibly undefined
// 415D29: variable 'v18' is possibly undefined
// 415D29: variable 'v19' is possibly undefined
// 415DA2: variable 'v22' is possibly undefined
// 415DB3: variable 'v24' is possibly undefined
// 415DB3: variable 'v25' is possibly undefined
// 415DB3: variable 'v26' is possibly undefined
// 415DDD: variable 'v27' is possibly undefined
// 415DDD: variable 'v28' is possibly undefined
// 415DDD: variable 'v29' is possibly undefined
// 4A8860: using guessed type __int64 (__fastcall *_memalign_hook)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, double);
// 4A8880: using guessed type int main_arena;
// 4AB820: using guessed type int _libc_multiple_threads;

//----- (0000000000415E00) ----------------------------------------------------
_QWORD *__fastcall memalign_hook_ini(
        unsigned __int64 a1,
        unsigned __int64 a2,
        double a3,
        __int64 a4,
        __int64 a5,
        u32 *a6,
        __int64 a7)
{
  _QWORD *retaddr; // [rsp+18h] [rbp+0h]

  _memalign_hook = 0LL;
  if ( _libc_malloc_initialized < 0 )
    ptmalloc_init_part_0();
  return mid_memalign(a1, a2, retaddr, a5, a6, a7, a3);
}
// 415E3D: variable 'a5' is possibly undefined
// 415E3D: variable 'a6' is possibly undefined
// 415E3D: variable 'a7' is possibly undefined
// 4A87C4: using guessed type int _libc_malloc_initialized;
// 4A8860: using guessed type __int64 (__fastcall *_memalign_hook)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, double);

//----- (0000000000415E50) ----------------------------------------------------
__int64 *__fastcall free(__int64 a1, __int64 a2, __int64 a3, __int64 a4, u32 *a5, unsigned __int64 a6)
{
  __int64 *result; // rax
  unsigned __int64 v7; // rax
  unsigned __int64 v8; // rsi
  int *v9; // rdi
  __int64 v10; // rdx
  void *retaddr; // [rsp+18h] [rbp+0h]

  result = (__int64 *)_free_hook;
  if ( _free_hook )
    return (__int64 *)_free_hook(a1, retaddr);
  if ( a1 )
  {
    v7 = *(_QWORD *)(a1 - 8);
    v8 = a1 - 16;
    if ( (v7 & 2) != 0 )
    {
      v10 = (unsigned int)dword_4A8814;
      if ( !dword_4A8814 && v7 > qword_4A87F0 && v7 <= 0x2000000 )
      {
        v10 = 2 * (*(_QWORD *)(a1 - 8) & 0x3FFFFF8LL);
        qword_4A87F0 = *(_QWORD *)(a1 - 8) & 0x3FFFFF8LL;
        mp_ = v10;
      }
      return munmap_chunk((__int64 *)(a1 - 16), v8, v10, a4, (__int64)a5, a6);
    }
    else
    {
      if ( !__readfsqword(0xFFFFFFC8) && !__readfsbyte(0xFFFFFFD0) )
      {
        tcache_init_part_5(a1, v8, a3, a4, a5, a6);
        v7 = *(_QWORD *)(a1 - 8);
        v8 = a1 - 16;
      }
      v9 = &main_arena;
      if ( (v7 & 4) != 0 )
        v9 = *(int **)(v8 & 0xFFFFFFFFFC000000LL);
      return (__int64 *)int_free((__int64)v9, v8, 0LL, a4, (unsigned __int64)a5, a6);
    }
  }
  return result;
}
// 415F00: mask 0xFFFFFFFFFFFFFFF8 is shortened because rax.8 <= 0x2000000
// 415EA8: variable 'a4' is possibly undefined
// 415EA8: variable 'a5' is possibly undefined
// 415EA8: variable 'a6' is possibly undefined
// 4A87E0: using guessed type __int64 mp_;
// 4A87F0: using guessed type __int64 qword_4A87F0;
// 4A8814: using guessed type int dword_4A8814;
// 4A8880: using guessed type int main_arena;
// 4AAD78: using guessed type __int64 (__fastcall *_free_hook)(_QWORD, _QWORD);

//----- (0000000000415F50) ----------------------------------------------------
signed __int64 __fastcall _malloc_arena_thread_freeres(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        u32 *a5,
        unsigned __int64 a6)
{
  __int64 v6; // rbp
  _QWORD **v7; // rbx
  _QWORD *v8; // rdi
  signed __int64 result; // rax
  __int64 v10; // rdx
  __int64 v12; // rax

  v6 = __readfsqword(0xFFFFFFC8);
  if ( v6 )
  {
    __writefsbyte(0xFFFFFFD0, 1u);
    v7 = (_QWORD **)(v6 + 64);
    __writefsqword(0xFFFFFFC8, 0LL);
    do
    {
      while ( 1 )
      {
        v8 = *v7;
        if ( !*v7 )
          break;
        *v7 = (_QWORD *)*v8;
        free((__int64)v8, a2, a3, a4, a5, a6);
      }
      ++v7;
    }
    while ( v7 != (_QWORD **)(v6 + 576) );
    free(v6, a2, a3, a4, a5, a6);
  }
  result = -40LL;
  v10 = __readfsqword(0xFFFFFFD8);
  __writefsqword(0xFFFFFFD8, 0LL);
  if ( !v10 )
    return result;
  _ESI = 1;
  if ( _libc_multiple_threads )
  {
    if ( !_InterlockedCompareExchange(&free_list_lock, 1, 0) )
      goto LABEL_13;
    goto LABEL_12;
  }
  __asm { cmpxchg cs:free_list_lock, esi }
  if ( _libc_multiple_threads )
LABEL_12:
    _lll_lock_wait_private((u32 *)&free_list_lock, 1LL, v10, a4, a5, a6);
LABEL_13:
  v12 = *(_QWORD *)(v10 + 2176);
  if ( !v12 )
    _malloc_assert("a->attached_threads > 0", (__int64)"arena.c", 0x3C0u, (__int64)"__malloc_arena_thread_freeres");
  result = v12 - 1;
  *(_QWORD *)(v10 + 2176) = result;
  if ( !result )
  {
    result = free_list;
    free_list = v10;
    *(_QWORD *)(v10 + 2168) = result;
  }
  if ( _libc_multiple_threads )
  {
    if ( !_InterlockedDecrement(&free_list_lock) )
      return result;
  }
  else if ( !--free_list_lock )
  {
    return result;
  }
  return _lll_unlock_wake_private((u32 *)&free_list_lock, 1LL, v10, a4, a5, a6);
}
// 415F96: variable 'a3' is possibly undefined
// 415F96: variable 'a4' is possibly undefined
// 415F96: variable 'a5' is possibly undefined
// 415F96: variable 'a6' is possibly undefined
// 41600F: variable 'v10' is possibly undefined
// 4AADA8: using guessed type __int64 free_list;
// 4AADB0: using guessed type int free_list_lock;
// 4AB820: using guessed type int _libc_multiple_threads;

//----- (00000000004160A0) ----------------------------------------------------
__int64 *__fastcall realloc(__int64 a1, unsigned __int64 a2, _QWORD *a3, __int64 a4, u32 *a5, unsigned __int64 a6)
{
  bool v7; // al
  __int64 v8; // rcx
  unsigned __int64 v9; // r12
  unsigned __int64 v11; // r15
  unsigned __int64 v12; // rdx
  unsigned __int64 v13; // r14
  __int64 v14; // rcx
  _QWORD *v15; // rax
  __int64 v16; // r13
  __int64 v17; // rax
  int *v18; // rdx
  __int64 *v19; // rax
  _QWORD *v20; // rdx
  __int64 v21; // rcx
  u32 *v22; // r8
  __int64 v23; // r9
  _QWORD *v25; // rax
  __int64 v26; // rdx
  __int64 v27; // rcx
  __int64 v28; // r8
  __int64 v29; // r9
  bool v31; // zf
  _QWORD *v32; // rax
  _QWORD *v33; // rdx
  __int64 v34; // rcx
  __int64 v35; // r9
  u32 *v36; // r8
  __int64 v37; // rax
  int *v38; // rdx
  _QWORD *v39; // rax
  __int64 v40; // rcx
  unsigned __int64 v41; // r9
  _QWORD *v42; // rdx
  __int64 v43; // rcx
  u32 *v44; // r8
  unsigned __int64 v45; // r9
  int *v46; // [rsp+8h] [rbp-40h]
  volatile signed __int32 *v47; // [rsp+8h] [rbp-40h]
  unsigned __int64 v48; // [rsp+8h] [rbp-40h]
  void *retaddr; // [rsp+48h] [rbp+0h]

  if ( _realloc_hook )
    return (__int64 *)_realloc_hook(a1, a2, retaddr);
  LOBYTE(a3) = a1 != 0;
  v7 = a1 != 0 && a2 == 0;
  if ( v7 )
  {
    free(a1, a2, (__int64)a3, a4, a5, a6);
    return 0LL;
  }
  if ( !a1 )
    return malloc(a2, a2, a3, a4, a5, a6);
  v8 = *(_QWORD *)(a1 - 8);
  v9 = a1 - 16;
  _R8 = 0LL;
  v11 = v8 & 0xFFFFFFFFFFFFFFF8LL;
  if ( (v8 & 2) == 0 )
  {
    if ( !__readfsqword(0xFFFFFFC8) && !__readfsbyte(0xFFFFFFD0) )
    {
      tcache_init_part_5(a1, a2, (__int64)a3, v8, 0LL, a6);
      v8 = *(_QWORD *)(a1 - 8);
      v7 = a1 != 0 && a2 == 0;
    }
    _R8 = (u32 *)&main_arena;
    if ( (v8 & 4) != 0 )
      _R8 = *(u32 **)(v9 & 0xFFFFFFFFFC000000LL);
  }
  if ( -(__int64)v11 >= v9 && (v9 & 0xF) == 0 )
  {
    v12 = a2 + 23;
    v13 = 32LL;
    if ( a2 + 23 > 0x1F )
    {
      v12 &= 0xFFFFFFFFFFFFFFF0LL;
      v13 = v12;
      v7 = v12 > 0xFFFFFFFFFFFFFFBFLL;
    }
    if ( v13 >= a2 && !v7 )
    {
      v14 = v8 & 2;
      if ( (_DWORD)v14 )
      {
        v19 = mremap_chunk((__int64 *)(a1 - 16), v13);
        v16 = (__int64)(v19 + 2);
        if ( !v19 )
        {
          v16 = a1;
          if ( v11 - 8 < v13 )
          {
            v25 = malloc(a2, v13, v20, v21, v22, v23);
            v16 = (__int64)v25;
            if ( v25 )
            {
              j_memcpy(v25, a1, v11 - 16);
              munmap_chunk((__int64 *)v9, a1, v26, v27, v28, v29);
            }
          }
        }
        return (__int64 *)v16;
      }
      if ( !_libc_multiple_threads )
      {
        v46 = (int *)_R8;
        v15 = int_realloc((__int64)_R8, a1 - 16, v11, v13, _R8, a6);
        v16 = (__int64)v15;
        if ( v15 )
        {
          v17 = *(v15 - 1);
          if ( (v17 & 2) == 0 )
          {
            v18 = &main_arena;
            if ( (v17 & 4) != 0 )
              v18 = *(int **)((v16 - 16) & 0xFFFFFFFFFC000000LL);
            if ( v46 != v18 )
              _malloc_assert(
                "!newp || chunk_is_mmapped (mem2chunk (newp)) || ar_ptr == arena_for_chunk (mem2chunk (newp))",
                (__int64)"malloc.c",
                0xC9Au,
                (__int64)"__libc_realloc");
          }
        }
        return (__int64 *)v16;
      }
      _ESI = 1;
      v31 = _libc_multiple_threads == 0;
      if ( _libc_multiple_threads )
      {
        if ( !_InterlockedCompareExchange((volatile signed __int32 *)_R8, 1, 0) )
        {
LABEL_38:
          v47 = (volatile signed __int32 *)_R8;
          v32 = int_realloc((__int64)_R8, v9, v11, v13, _R8, a6);
          v36 = (u32 *)v47;
          v16 = (__int64)v32;
          if ( _libc_multiple_threads )
          {
            if ( !_InterlockedDecrement(v47) )
            {
LABEL_43:
              if ( v16 )
              {
                v37 = *(_QWORD *)(v16 - 8);
                if ( (v37 & 2) == 0 )
                {
                  v38 = &main_arena;
                  if ( (v37 & 4) != 0 )
                    v38 = *(int **)((v16 - 16) & 0xFFFFFFFFFC000000LL);
                  if ( v36 != (u32 *)v38 )
                    _malloc_assert(
                      "!newp || chunk_is_mmapped (mem2chunk (newp)) || ar_ptr == arena_for_chunk (mem2chunk (newp))",
                      (__int64)"malloc.c",
                      0xCA5u,
                      (__int64)"__libc_realloc");
                }
              }
              else
              {
                v48 = (unsigned __int64)v36;
                v39 = malloc(a2, v9, v33, v34, v36, v35);
                v16 = (__int64)v39;
                if ( v39 )
                {
                  j_memcpy(v39, a1, v11 - 8);
                  int_free(v48, v9, 0LL, v40, v48, v41);
                }
              }
              return (__int64 *)v16;
            }
          }
          else
          {
            v31 = (*v47)-- == 1;
            if ( v31 )
              goto LABEL_43;
          }
          _lll_unlock_wake_private((u32 *)v47, v9, (__int64)v33, v34, (u32 *)v47, v35);
          goto LABEL_43;
        }
      }
      else
      {
        __asm { cmpxchg [r8], esi }
        if ( v31 )
          goto LABEL_38;
      }
      _lll_lock_wait_private(_R8, 1LL, v12, v14, _R8, a6);
      goto LABEL_38;
    }
    v16 = 0LL;
    __writefsdword(0xFFFFFFC0, 0xCu);
    return (__int64 *)v16;
  }
  malloc_printerr((__int64)"realloc(): invalid pointer", a2, -(__int64)v11, v8, _R8, a6);
  return realloc_hook_ini((__int64)"realloc(): invalid pointer", a2, v42, v43, v44, v45);
}
// 416166: variable 'a6' is possibly undefined
// 41624F: variable 'v20' is possibly undefined
// 41624F: variable 'v21' is possibly undefined
// 41624F: variable 'v22' is possibly undefined
// 41624F: variable 'v23' is possibly undefined
// 41626E: variable 'v26' is possibly undefined
// 41626E: variable 'v27' is possibly undefined
// 41626E: variable 'v28' is possibly undefined
// 41626E: variable 'v29' is possibly undefined
// 416351: variable '_R8' is possibly undefined
// 416383: variable 'v33' is possibly undefined
// 416383: variable 'v34' is possibly undefined
// 416383: variable 'v35' is possibly undefined
// 4163BB: variable 'v36' is possibly undefined
// 416420: variable 'v40' is possibly undefined
// 416420: variable 'v41' is possibly undefined
// 416437: variable 'v42' is possibly undefined
// 416437: variable 'v43' is possibly undefined
// 416437: variable 'v44' is possibly undefined
// 416437: variable 'v45' is possibly undefined
// 401040: using guessed type __int64 __fastcall j_memcpy(_QWORD, _QWORD, _QWORD);
// 4A8868: using guessed type __int64 (__fastcall *_realloc_hook)(_QWORD, _QWORD, _QWORD);
// 4A8880: using guessed type int main_arena;
// 4AB820: using guessed type int _libc_multiple_threads;

//----- (0000000000416440) ----------------------------------------------------
__int64 *__fastcall realloc_hook_ini(
        __int64 a1,
        unsigned __int64 a2,
        _QWORD *a3,
        __int64 a4,
        u32 *a5,
        unsigned __int64 a6)
{
  _malloc_hook = 0LL;
  _realloc_hook = 0LL;
  if ( _libc_malloc_initialized < 0 )
    ptmalloc_init_part_0();
  return realloc(a1, a2, a3, a4, a5, a6);
}
// 416464: variable 'a3' is possibly undefined
// 416464: variable 'a4' is possibly undefined
// 416464: variable 'a5' is possibly undefined
// 416464: variable 'a6' is possibly undefined
// 4A87C4: using guessed type int _libc_malloc_initialized;
// 4A8868: using guessed type __int64 (__fastcall *_realloc_hook)(_QWORD, _QWORD, _QWORD);
// 4A8870: using guessed type __int64 (__fastcall *_malloc_hook)(_QWORD, _QWORD);

//----- (00000000004164A0) ----------------------------------------------------
_QWORD *__fastcall memalign(
        unsigned __int64 a1,
        unsigned __int64 a2,
        double a3,
        __int64 a4,
        __int64 a5,
        u32 *a6,
        __int64 a7)
{
  _QWORD *retaddr; // [rsp+0h] [rbp+0h]

  return mid_memalign(a1, a2, retaddr, a5, a6, a7, a3);
}

//----- (00000000004164B0) ----------------------------------------------------
_QWORD *__fastcall valloc(unsigned __int64 a1, double a2, __int64 a3, __int64 a4, __int64 a5, u32 *a6, __int64 a7)
{
  _QWORD *retaddr; // [rsp+8h] [rbp+0h]

  if ( _libc_malloc_initialized < 0 )
    ptmalloc_init_part_0();
  return mid_memalign(dl_pagesize, a1, retaddr, a5, a6, a7, a2);
}
// 4164D2: variable 'a5' is possibly undefined
// 4164D2: variable 'a6' is possibly undefined
// 4164D2: variable 'a7' is possibly undefined
// 4A87C4: using guessed type int _libc_malloc_initialized;
// 4A91F8: using guessed type __int64 dl_pagesize;

//----- (00000000004164F0) ----------------------------------------------------
_QWORD *__fastcall pvalloc(unsigned __int64 a1, double a2, __int64 a3, __int64 a4, __int64 a5, u32 *a6, __int64 a7)
{
  _QWORD *retaddr; // [rsp+8h] [rbp+0h]

  if ( _libc_malloc_initialized < 0 )
    ptmalloc_init_part_0();
  if ( -33 - 2 * dl_pagesize >= a1 )
    return mid_memalign(dl_pagesize, -dl_pagesize & (dl_pagesize + a1 - 1), retaddr, 2 * dl_pagesize, a6, a7, a2);
  __writefsdword(0xFFFFFFC0, 0xCu);
  return 0LL;
}
// 416530: variable 'a6' is possibly undefined
// 416530: variable 'a7' is possibly undefined
// 4A87C4: using guessed type int _libc_malloc_initialized;
// 4A91F8: using guessed type __int64 dl_pagesize;

//----- (0000000000416560) ----------------------------------------------------
u32 *__fastcall calloc(__int64 a1, unsigned __int64 a2, __int64 a3, __int64 a4, u32 *a5, __int64 a6)
{
  __int64 v6; // rdx
  unsigned __int64 v7; // r12
  unsigned __int64 v8; // r8
  __int64 v9; // r13
  unsigned __int64 v11; // rbp
  __int64 v12; // rsi
  u32 *v13; // rax
  __int64 v14; // rdx
  __int64 v15; // rcx
  u32 v16; // er9
  u32 *v17; // r8
  __int64 v18; // rdx
  int v19; // eax
  int *v21; // rax
  unsigned __int64 v22; // rdx
  unsigned __int64 v23; // rdx
  __int64 v24; // rax
  bool v26; // zf
  __int64 v27; // rdx
  __int64 v28; // rcx
  unsigned __int64 v29; // r8
  __int64 v30; // r9
  void *retaddr; // [rsp+28h] [rbp+0h]

  v6 = a2 | a1;
  v7 = a2 * a1;
  if ( (a2 | a1) > 0xFFFFFFFF )
  {
    if ( a2 )
    {
      v6 = v7 % a2;
      if ( v7 / a2 != a1 )
      {
        v17 = 0LL;
        __writefsdword(0xFFFFFFC0, 0xCu);
        return v17;
      }
    }
  }
  if ( _malloc_hook )
  {
    v24 = _malloc_hook(v7, retaddr);
    if ( v24 )
      return (u32 *)j_memset_ifunc(v24, 0LL, v7);
    return 0LL;
  }
  if ( !__readfsqword(0xFFFFFFC8) && !__readfsbyte(0xFFFFFFD0) )
    tcache_init_part_5(a1, a2, v6, a4, a5, a6);
  v8 = (unsigned int)_libc_multiple_threads;
  if ( !_libc_multiple_threads )
  {
    v9 = qword_4A88E0;
    _RBX = &main_arena;
    v11 = *(_QWORD *)(qword_4A88E0 + 8) & 0xFFFFFFFFFFFFFFF8LL;
    goto LABEL_7;
  }
  _RBX = (int *)__readfsqword(0xFFFFFFD8);
  if ( _RBX )
  {
    _ESI = 1;
    v26 = _libc_multiple_threads == 0;
    if ( _libc_multiple_threads )
    {
      if ( !_InterlockedCompareExchange(_RBX, 1, 0) )
        goto LABEL_45;
      goto LABEL_44;
    }
    __asm { cmpxchg [rbx], esi }
    if ( !v26 )
LABEL_44:
      _lll_lock_wait_private((u32 *)_RBX, 1LL, v6, a4, (u32 *)v8, a6);
  }
  else
  {
    _RBX = (int *)get_free_list(a1, a2, v6, a4, (u32 *)(unsigned int)_libc_multiple_threads, a6);
    if ( !_RBX )
    {
      _RBX = arena_get2_part_4(v7, 0LL, v6, a4, (u32 *)v8, a6);
      if ( !_RBX )
      {
        v9 = 0LL;
        v11 = 0LL;
        goto LABEL_7;
      }
    }
  }
LABEL_45:
  v9 = *((_QWORD *)_RBX + 12);
  v11 = *(_QWORD *)(v9 + 8) & 0xFFFFFFFFFFFFFFF8LL;
  if ( _RBX != &main_arena && v11 < *(_QWORD *)((v9 & 0xFFFFFFFFFC000000LL) + 0x18) + (v9 & 0xFFFFFFFFFC000000LL) - v9 )
    v11 = *(_QWORD *)((v9 & 0xFFFFFFFFFC000000LL) + 0x18) + (v9 & 0xFFFFFFFFFC000000LL) - v9;
LABEL_7:
  v12 = v7;
  v13 = (u32 *)int_malloc(_RBX, v7, v6, a4, v8, a6);
  v17 = v13;
  if ( !v13 )
  {
    if ( !_libc_multiple_threads || !_RBX )
      return 0LL;
    v12 = v7;
    _RBX = (int *)arena_get_retry(_RBX, v7, v14, v15, 0LL, v16);
    v17 = (u32 *)int_malloc(_RBX, v7, v27, v28, v29, v30);
    if ( !_RBX )
      goto LABEL_56;
LABEL_51:
    if ( _libc_multiple_threads )
    {
      if ( !_InterlockedDecrement(_RBX) )
      {
LABEL_56:
        if ( v17 )
        {
          v18 = *((_QWORD *)v17 - 1);
          v19 = perturb_byte;
          if ( (v18 & 2) != 0 )
            goto LABEL_11;
LABEL_22:
          v22 = v18 & 0xFFFFFFFFFFFFFFF8LL;
          if ( !v19 && (u32 *)v9 == v17 - 4 && v11 < v22 )
            v22 = v11;
          v23 = v22 - 8;
          if ( v23 <= 0x17 )
            _malloc_assert("nclears >= 3", (__int64)"malloc.c", 0xDA0u, (__int64)"__libc_calloc");
          if ( v23 > 0x4F )
            return (u32 *)j_memset_ifunc(v17, 0LL, v23);
          *(_QWORD *)v17 = 0LL;
          *((_QWORD *)v17 + 1) = 0LL;
          *((_QWORD *)v17 + 2) = 0LL;
          if ( v23 > 0x27 )
          {
            *((_QWORD *)v17 + 3) = 0LL;
            *((_QWORD *)v17 + 4) = 0LL;
            if ( v23 > 0x37 )
            {
              *((_QWORD *)v17 + 5) = 0LL;
              *((_QWORD *)v17 + 6) = 0LL;
              if ( v23 > 0x47 )
              {
                *((_QWORD *)v17 + 7) = 0LL;
                *((_QWORD *)v17 + 8) = 0LL;
              }
            }
          }
          return v17;
        }
        return 0LL;
      }
    }
    else
    {
      v26 = (*_RBX)-- == 1;
      if ( v26 )
        goto LABEL_56;
    }
    _lll_unlock_wake_private((u32 *)_RBX, v12, v18, v15, v17, v16);
    goto LABEL_56;
  }
  v18 = *((_QWORD *)v13 - 1);
  if ( (v18 & 2) == 0 )
  {
    v21 = &main_arena;
    if ( (v18 & 4) != 0 )
      v21 = *(int **)((unsigned __int64)(v17 - 4) & 0xFFFFFFFFFC000000LL);
    if ( v21 != _RBX )
      _malloc_assert(
        "!mem || chunk_is_mmapped (mem2chunk (mem)) || av == arena_for_chunk (mem2chunk (mem))",
        (__int64)"malloc.c",
        0xD72u,
        (__int64)"__libc_calloc");
    v15 = (unsigned int)_libc_multiple_threads;
    if ( !_libc_multiple_threads || !v21 )
    {
      v19 = perturb_byte;
      goto LABEL_22;
    }
    goto LABEL_51;
  }
  v12 = (unsigned int)_libc_multiple_threads;
  if ( _libc_multiple_threads && _RBX )
    goto LABEL_51;
  v19 = perturb_byte;
LABEL_11:
  if ( !v19 )
    return v17;
  return (u32 *)j_memset_ifunc(v17, 0LL, v7);
}
// 4165DA: variable 'v6' is possibly undefined
// 4165DA: variable 'a4' is possibly undefined
// 4165DA: variable 'v8' is possibly undefined
// 4165DA: variable 'a6' is possibly undefined
// 416610: variable 'v17' is possibly undefined
// 41686F: variable 'v14' is possibly undefined
// 41686F: variable 'v15' is possibly undefined
// 41686F: variable 'v16' is possibly undefined
// 41687D: variable 'v27' is possibly undefined
// 41687D: variable 'v28' is possibly undefined
// 41687D: variable 'v29' is possibly undefined
// 41687D: variable 'v30' is possibly undefined
// 4168A8: variable 'v18' is possibly undefined
// 401090: using guessed type __int64 __fastcall j_memset_ifunc(_QWORD, _QWORD, _QWORD);
// 4A8870: using guessed type __int64 (__fastcall *_malloc_hook)(_QWORD, _QWORD);
// 4A8880: using guessed type int main_arena;
// 4A88E0: using guessed type __int64 qword_4A88E0;
// 4AADB4: using guessed type int perturb_byte;
// 4AB820: using guessed type int _libc_multiple_threads;

//----- (0000000000416940) ----------------------------------------------------
__int64 __fastcall malloc_trim(
        unsigned __int64 a1,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        unsigned __int64 a6)
{
  bool v8; // zf
  u32 *v9; // r8
  unsigned __int64 v10; // r10
  int v11; // ebx
  u32 *v12; // r12
  __int64 v13; // r15
  __int64 i; // rbp
  unsigned __int64 v15; // rdi
  unsigned __int64 v17; // rcx
  int v18; // eax
  u32 *v19; // [rsp+0h] [rbp-68h]
  u32 *v20; // [rsp+0h] [rbp-68h]
  unsigned int v21; // [rsp+0h] [rbp-68h]
  unsigned int v22; // [rsp+Ch] [rbp-5Ch]
  unsigned int v24; // [rsp+18h] [rbp-50h]
  u32 *v25; // [rsp+18h] [rbp-50h]
  unsigned __int64 v26; // [rsp+20h] [rbp-48h]
  unsigned __int64 v27; // [rsp+28h] [rbp-40h]

  if ( _libc_malloc_initialized < 0 )
    ptmalloc_init_part_0();
  v22 = 0;
  _R8 = (u32 *)&main_arena;
  do
  {
    _RSI = 1LL;
    v8 = _libc_multiple_threads == 0;
    if ( !_libc_multiple_threads )
    {
      __asm { cmpxchg [r8], esi }
      if ( v8 )
        goto LABEL_9;
LABEL_8:
      _lll_lock_wait_private(_R8, 1LL, a3, a4, _R8, a6);
      goto LABEL_9;
    }
    if ( _InterlockedCompareExchange((volatile signed __int32 *)_R8, 1, 0) )
      goto LABEL_8;
LABEL_9:
    v19 = _R8;
    malloc_consolidate((const char *)_R8, 1LL, a3, (_QWORD *)a4, (unsigned __int64)_R8);
    v9 = v19;
    if ( (unsigned __int64)dl_pagesize > 0x3FF )
    {
      if ( (unsigned __int64)dl_pagesize >> 6 > 0x30 )
      {
        if ( (unsigned __int64)dl_pagesize >> 9 <= 0x14 )
        {
          a4 = (unsigned int)((unsigned __int64)dl_pagesize >> 9) + 91;
        }
        else if ( (unsigned __int64)dl_pagesize >> 12 > 0xA )
        {
          if ( (unsigned __int64)dl_pagesize >> 15 > 4 )
          {
            v17 = (unsigned __int64)dl_pagesize >> 18;
            if ( (unsigned __int64)dl_pagesize >> 18 > 2 )
              LODWORD(v17) = 2;
            a4 = (unsigned int)(v17 + 124);
          }
          else
          {
            a4 = (unsigned int)((unsigned __int64)dl_pagesize >> 15) + 119;
          }
        }
        else
        {
          a4 = (unsigned int)((unsigned __int64)dl_pagesize >> 12) + 110;
        }
      }
      else
      {
        a4 = (unsigned int)((unsigned __int64)dl_pagesize >> 6) + 48;
      }
    }
    else
    {
      a4 = (unsigned int)dl_pagesize >> 4;
    }
    v10 = dl_pagesize - 1;
    a6 = dl_pagesize + 47;
    a3 = 0LL;
    v11 = 1;
    v12 = v19 + 24;
    v13 = -dl_pagesize;
    do
    {
      if ( v11 == 1 || (int)a4 <= v11 )
      {
        for ( i = *((_QWORD *)v12 + 3); v12 != (u32 *)i; i = *(_QWORD *)(i + 24) )
        {
          _RSI = *(_QWORD *)(i + 8) & 0xFFFFFFFFFFFFFFF8LL;
          if ( _RSI > a6 )
          {
            v15 = v13 & (i + a6);
            if ( v15 < i + 48 )
              _malloc_assert(
                "(char *) chunk2mem (p) + 4 * SIZE_SZ <= paligned_mem",
                (__int64)"malloc.c",
                0x12BCu,
                (__int64)"mtrim");
            if ( v15 >= i + _RSI )
              _malloc_assert("(char *) p + size > paligned_mem", (__int64)"malloc.c", 0x12BDu, (__int64)"mtrim");
            _RSI -= v15 - i;
            if ( v10 < _RSI )
            {
              _RSI &= v13;
              v27 = a6;
              v26 = v10;
              v24 = a4;
              v20 = v9;
              madvise(v15, _RSI, 4);
              a3 = 1LL;
              a6 = v27;
              v10 = v26;
              a4 = v24;
              v9 = v20;
            }
          }
        }
      }
      ++v11;
      v12 += 4;
    }
    while ( v11 != 128 );
    if ( v9 == (u32 *)&main_arena )
    {
      v25 = v9;
      v21 = a3;
      v18 = systrim_isra_1_constprop_9(a1, _RSI);
      v9 = v25;
      a3 = v18 | v21;
    }
    v22 |= a3;
    if ( !_libc_multiple_threads )
    {
      v8 = (*v9)-- == 1;
      if ( v8 )
        goto LABEL_40;
LABEL_39:
      _lll_unlock_wake_private(v9, _RSI, a3, a4, v9, a6);
      goto LABEL_40;
    }
    if ( _InterlockedDecrement((volatile signed __int32 *)v9) )
      goto LABEL_39;
LABEL_40:
    _R8 = (u32 *)*((_QWORD *)v9 + 270);
  }
  while ( _R8 != (u32 *)&main_arena );
  return v22;
}
// 4169A4: variable 'a3' is possibly undefined
// 4169A4: variable 'a4' is possibly undefined
// 4169A4: variable 'a6' is possibly undefined
// 4169B3: variable '_R8' is possibly undefined
// 416BA2: variable 'v9' is possibly undefined
// 4A87C4: using guessed type int _libc_malloc_initialized;
// 4A8880: using guessed type int main_arena;
// 4A91F8: using guessed type __int64 dl_pagesize;
// 4AB820: using guessed type int _libc_multiple_threads;

//----- (0000000000416C10) ----------------------------------------------------
__m128i *__fastcall malloc_usable_size(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  unsigned __int64 v6; // rsi
  unsigned __int64 v7; // rax
  __int64 v8; // rcx
  __m128i *result; // rax
  unsigned __int64 v10; // rdx
  __int64 v11; // r8
  unsigned __int64 v12; // rax
  __int64 v13; // rdx
  __int64 v14; // rdx
  __int64 v15; // rcx
  u32 *v16; // r8
  u32 v17; // er9

  if ( !a1 )
    return 0LL;
  v6 = a1 - 16;
  v7 = *(_QWORD *)(a1 - 8) & 0xFFFFFFFFFFFFFFF8LL;
  v8 = *(_QWORD *)(a1 - 8) & 2LL;
  if ( using_malloc_checking == 1 )
  {
    v11 = (unsigned int)(v6 >> 11) ^ (unsigned int)(v6 >> 3);
    if ( ((unsigned __int8)(v6 >> 11) ^ (unsigned __int8)(v6 >> 3)) == 1 )
      v11 = 2LL;
    v12 = v7 + 8LL * (v8 == 0) - 1;
    v13 = *(unsigned __int8 *)(a1 + v12 - 16);
    if ( (_BYTE)v13 != (_BYTE)v11 )
    {
      if ( !(_BYTE)v13 || (v8 = v13 + 16, v12 < v13 + 16) )
      {
LABEL_19:
        malloc_printerr((__int64)"malloc_check_get_size: memory corruption", v6, v13, v8, (u32 *)v11, a6);
        return mallinfo((__m128i *)"malloc_check_get_size: memory corruption", v6, v14, v15, v16, v17);
      }
      while ( 1 )
      {
        v12 -= v13;
        v13 = *(unsigned __int8 *)(v6 + v12);
        if ( (_BYTE)v13 == (_BYTE)v11 )
          break;
        if ( (_BYTE)v13 )
        {
          v8 = v13 + 16;
          if ( v13 + 16 <= v12 )
            continue;
        }
        goto LABEL_19;
      }
    }
    return (__m128i *)(v12 - 16);
  }
  if ( v8 )
    return (__m128i *)(v7 - 16);
  v10 = v7 - 8;
  result = (__m128i *)(*(_QWORD *)(a1 + v7 - 8) & 1LL);
  if ( (_DWORD)result )
    return (__m128i *)v10;
  return result;
}
// 416CDC: variable 'v14' is possibly undefined
// 416CDC: variable 'v15' is possibly undefined
// 416CDC: variable 'v16' is possibly undefined
// 416CDC: variable 'v17' is possibly undefined
// 4AAD90: using guessed type int using_malloc_checking;

//----- (0000000000416CE0) ----------------------------------------------------
__m128i *__fastcall mallinfo(__m128i *a1, __int64 a2, __int64 a3, __int64 a4, u32 *a5, u32 a6)
{
  bool v8; // zf
  __m128i v9; // xmm1
  __m128i v10; // xmm2
  __m128i *result; // rax
  __m128i v12; // [rsp+0h] [rbp-58h] BYREF
  __m128i v13; // [rsp+10h] [rbp-48h] BYREF
  __int64 v14; // [rsp+20h] [rbp-38h]
  unsigned __int64 v15; // [rsp+28h] [rbp-30h]

  v15 = __readfsqword(0x28u);
  if ( _libc_malloc_initialized < 0 )
    ptmalloc_init_part_0();
  v14 = 0LL;
  v12 = 0LL;
  v13 = 0LL;
  _RBX = &main_arena;
  do
  {
    _ESI = 1;
    v8 = _libc_multiple_threads == 0;
    if ( !_libc_multiple_threads )
    {
      __asm { cmpxchg [rbx], esi }
      if ( v8 )
        goto LABEL_9;
LABEL_8:
      _lll_lock_wait_private((u32 *)_RBX, 1LL, a3, a4, a5, a6);
      goto LABEL_9;
    }
    if ( _InterlockedCompareExchange(_RBX, 1, 0) )
      goto LABEL_8;
LABEL_9:
    int_mallinfo((__int64)_RBX, (__int64)&v12);
    if ( !_libc_multiple_threads )
    {
      v8 = (*_RBX)-- == 1;
      if ( v8 )
        goto LABEL_14;
LABEL_13:
      _lll_unlock_wake_private((u32 *)_RBX, (__int64)&v12, a3, a4, a5, a6);
      goto LABEL_14;
    }
    if ( _InterlockedDecrement(_RBX) )
      goto LABEL_13;
LABEL_14:
    _RBX = (int *)*((_QWORD *)_RBX + 270);
  }
  while ( _RBX != &main_arena );
  v9 = _mm_load_si128(&v12);
  v10 = _mm_load_si128(&v13);
  a1[2].m128i_i64[0] = v14;
  result = a1;
  *a1 = v9;
  a1[1] = v10;
  return result;
}
// 416D65: variable 'a3' is possibly undefined
// 416D65: variable 'a4' is possibly undefined
// 416D65: variable 'a5' is possibly undefined
// 416D65: variable 'a6' is possibly undefined
// 4A87C4: using guessed type int _libc_malloc_initialized;
// 4A8880: using guessed type int main_arena;
// 4AB820: using guessed type int _libc_multiple_threads;

//----- (0000000000416E00) ----------------------------------------------------
unsigned __int64 __fastcall malloc_stats(__int64 a1, __int64 a2, __int64 a3, __int64 a4, u32 *a5, __int64 a6)
{
  unsigned int v6; // ebp
  unsigned int v7; // er12
  unsigned int v8; // ebx
  __int64 v10; // rcx
  __int64 v11; // rdx
  bool v13; // zf
  unsigned int v15; // [rsp+Ch] [rbp-6Ch]
  __int128 v16; // [rsp+10h] [rbp-68h] BYREF
  __int128 v17; // [rsp+20h] [rbp-58h]
  __int64 v18; // [rsp+30h] [rbp-48h]
  unsigned __int64 v19; // [rsp+38h] [rbp-40h]

  v6 = qword_4A8818;
  v19 = __readfsqword(0x28u);
  v7 = qword_4A8818;
  if ( _libc_malloc_initialized < 0 )
    ptmalloc_init_part_0();
  v8 = 0;
  _R14 = &main_arena;
  v15 = *((_DWORD *)stderr + 29);
  v10 = v15;
  v11 = v15 | 2;
  *((_DWORD *)stderr + 29) = v11;
  while ( 1 )
  {
    v18 = 0LL;
    _ESI = 1;
    v16 = 0LL;
    v17 = 0LL;
    v13 = _libc_multiple_threads == 0;
    if ( !_libc_multiple_threads )
    {
      __asm { cmpxchg [r14], esi }
      if ( v13 )
        goto LABEL_10;
LABEL_9:
      _lll_lock_wait_private((u32 *)_R14, 1LL, v11, v10, a5, a6);
      goto LABEL_10;
    }
    if ( _InterlockedCompareExchange(_R14, 1, 0) )
      goto LABEL_9;
LABEL_10:
    int_mallinfo((__int64)_R14, (__int64)&v16);
    fprintf((__int64)stderr, (unsigned __int64)"Arena %d:\n", v8);
    fprintf((__int64)stderr, (unsigned __int64)"system bytes     = %10u\n", (unsigned int)v16);
    fprintf((__int64)stderr, (unsigned __int64)"in use bytes     = %10u\n", HIDWORD(v17));
    v7 += v16;
    v6 += HIDWORD(v17);
    if ( !_libc_multiple_threads )
    {
      v13 = (*_R14)-- == 1;
      if ( v13 )
        goto LABEL_15;
LABEL_14:
      _lll_unlock_wake_private((u32 *)_R14, (__int64)"in use bytes     = %10u\n", v11, v10, a5, a6);
      goto LABEL_15;
    }
    if ( _InterlockedDecrement(_R14) )
      goto LABEL_14;
LABEL_15:
    _R14 = (int *)*((_QWORD *)_R14 + 270);
    if ( _R14 == &main_arena )
      break;
    ++v8;
  }
  fwrite((__int64)"Total (incl. mmap):\n", 1LL, 20LL, (__int64)stderr, (__int64)a5, a6);
  fprintf((__int64)stderr, (unsigned __int64)"system bytes     = %10u\n", v7);
  fprintf((__int64)stderr, (unsigned __int64)"in use bytes     = %10u\n", v6);
  fprintf((__int64)stderr, (unsigned __int64)"max mmap regions = %10u\n", (unsigned int)dword_4A8810);
  fprintf((__int64)stderr, (unsigned __int64)"max mmap bytes   = %10lu\n", qword_4A8820);
  *((_DWORD *)stderr + 29) = v15;
  return __readfsqword(0x28u) ^ v19;
}
// 416EA9: variable 'v11' is possibly undefined
// 416EA9: variable 'v10' is possibly undefined
// 416EA9: variable 'a5' is possibly undefined
// 416EA9: variable 'a6' is possibly undefined
// 4A8798: using guessed type void *stderr;
// 4A87C4: using guessed type int _libc_malloc_initialized;
// 4A8810: using guessed type int dword_4A8810;
// 4A8818: using guessed type __int64 qword_4A8818;
// 4A8820: using guessed type __int64 qword_4A8820;
// 4A8880: using guessed type int main_arena;
// 4AB820: using guessed type int _libc_multiple_threads;

//----- (0000000000417020) ----------------------------------------------------
__int64 __fastcall mallopt(int a1, __int64 a2, __int64 a3, _QWORD *a4, u32 *a5, u32 a6)
{
  __int64 v7; // rcx
  u32 *v8; // r8
  u32 v9; // er9
  __int64 v10; // rax
  unsigned int v11; // edx

  if ( _libc_malloc_initialized < 0 )
    ptmalloc_init_part_0();
  _ESI = 1;
  if ( !_libc_multiple_threads )
  {
    __asm { cmpxchg cs:main_arena, esi }
    if ( !_libc_multiple_threads )
      goto LABEL_8;
    goto LABEL_7;
  }
  if ( _InterlockedCompareExchange(&main_arena, 1, 0) )
LABEL_7:
    _lll_lock_wait_private((u32 *)&main_arena, 1LL, a3, (__int64)a4, a5, a6);
LABEL_8:
  malloc_consolidate((const char *)&main_arena, 1LL, a3, a4, (unsigned __int64)a5);
  v10 = (unsigned int)(a1 + 8);
  if ( (unsigned int)v10 <= 9 )
    __asm { jmp     rax }
  v11 = 1;
  if ( _libc_multiple_threads )
  {
    if ( !_InterlockedDecrement(&main_arena) )
      return v11;
    goto LABEL_14;
  }
  if ( --main_arena )
LABEL_14:
    _lll_unlock_wake_private((u32 *)&main_arena, 1LL, 1LL, v7, v8, v9);
  return v11;
}
// 41706C: variable 'a3' is possibly undefined
// 41706C: variable 'a4' is possibly undefined
// 41706C: variable 'a5' is possibly undefined
// 41706C: variable 'a6' is possibly undefined
// 4170F1: variable 'v7' is possibly undefined
// 4170F1: variable 'v8' is possibly undefined
// 4170F1: variable 'v9' is possibly undefined
// 417101: variable 'v11' is possibly undefined
// 4A87C4: using guessed type int _libc_malloc_initialized;
// 4A8880: using guessed type int main_arena;
// 4AB820: using guessed type int _libc_multiple_threads;

//----- (0000000000417210) ----------------------------------------------------
__int64 __fastcall posix_memalign(
        __int64 *a1,
        unsigned __int64 a2,
        unsigned __int64 a3,
        double a4,
        __int64 a5,
        u32 *a6,
        __int64 a7)
{
  _QWORD *v7; // rdx
  __int64 result; // rax
  _QWORD *retaddr; // [rsp+0h] [rbp+0h]

  if ( a2 & 7 | (a2 >> 3) & ((a2 >> 3) - 1) || !a2 )
    return 22LL;
  v7 = mid_memalign(a2, a3, retaddr, a3, a6, a7, a4);
  result = 12LL;
  if ( v7 )
  {
    *a1 = (__int64)v7;
    return 0LL;
  }
  return result;
}

//----- (0000000000417270) ----------------------------------------------------
__int64 __fastcall malloc_info(int a1, __int64 a2)
{
  if ( a1 )
    return 22LL;
  if ( _libc_malloc_initialized < 0 )
    ptmalloc_init_part_0();
  fputs((__int64)"<malloc version=\"1\">\n", a2);
  return _malloc_info_part_8(a2);
}
// 4A87C4: using guessed type int _libc_malloc_initialized;

//----- (00000000004172C0) ----------------------------------------------------
unsigned __int64 __fastcall _default_morecore(__int64 a1)
{
  unsigned __int64 result; // rax

  result = sbrk(a1);
  if ( result == -1LL )
    return 0LL;
  return result;
}

//----- (00000000004172E0) ----------------------------------------------------
const __m128i *(__fastcall *strchr_ifunc())(__int64 a1, unsigned int a2)
{
  const __m128i *(__fastcall *result)(__int64, unsigned int); // rax

  result = (const __m128i *(__fastcall *)(__int64, unsigned int))_strchr_avx2;
  if ( (dword_4AAE4C & 0x20C00) != 3072 )
  {
    result = (const __m128i *(__fastcall *)(__int64, unsigned int))_strchr_sse2;
    if ( (dword_4AAE4C & 4) != 0 )
      return _strchr_sse2_no_bsf;
  }
  return result;
}
// 4AAE4C: using guessed type int dword_4AAE4C;

//----- (0000000000417320) ----------------------------------------------------
__int64 (__fastcall *strcmp_ifunc())(__int64 *a1, __int64 *a2)
{
  __int64 (__fastcall *result)(__int64 *, __int64 *); // rax

  result = (__int64 (__fastcall *)(__int64 *, __int64 *))_strcmp_avx2;
  if ( (dword_4AAE4C & 0x20C00) != 3072 )
  {
    result = (__int64 (__fastcall *)(__int64 *, __int64 *))_strcmp_sse2_unaligned;
    if ( (dword_4AAE4C & 0x10) == 0 )
    {
      result = _strcmp_sse2;
      if ( (dword_4AAE10 & 0x200) != 0 )
        return _strcmp_ssse3;
    }
  }
  return result;
}
// 4AAE10: using guessed type int dword_4AAE10;
// 4AAE4C: using guessed type int dword_4AAE4C;

//----- (0000000000417370) ----------------------------------------------------
void *strcpy_ifunc()
{
  void *result; // rax

  result = _strcpy_sse2_unaligned;
  if ( (dword_4AAE4C & 0x10) == 0 )
  {
    result = _strcpy_sse2;
    if ( (dword_4AAE10 & 0x200) != 0 )
      return _strcpy_ssse3;
  }
  return result;
}
// 4AAE10: using guessed type int dword_4AAE10;
// 4AAE4C: using guessed type int dword_4AAE4C;

//----- (00000000004173A0) ----------------------------------------------------
_BYTE *(__fastcall *strcspn_ifunc())(__int64 a1, __m128i *a2)
{
  _BYTE *(__fastcall *result)(__int64, __m128i *); // rax

  result = (_BYTE *(__fastcall *)(__int64, __m128i *))_strcspn_sse2;
  if ( (dword_4AAE10 & 0x100000) != 0 )
    return _strcspn_sse42;
  return result;
}
// 4AAE10: using guessed type int dword_4AAE10;

//----- (00000000004173C0) ----------------------------------------------------
__int64 __fastcall strdup(__int64 a1, __int64 a2)
{
  unsigned __int64 v2; // rbx
  _QWORD *v3; // rdx
  __int64 v4; // rcx
  u32 *v5; // r8
  __int64 v6; // r9
  _QWORD *v7; // rax

  v2 = j_strlen_ifunc(a1) + 1;
  v7 = malloc(v2, a2, v3, v4, v5, v6);
  if ( v7 )
    return j_memcpy(v7, a1, v2);
  else
    return 0LL;
}
// 4173D9: variable 'v3' is possibly undefined
// 4173D9: variable 'v4' is possibly undefined
// 4173D9: variable 'v5' is possibly undefined
// 4173D9: variable 'v6' is possibly undefined
// 401040: using guessed type __int64 __fastcall j_memcpy(_QWORD, _QWORD, _QWORD);
// 4010C8: using guessed type __int64 __fastcall j_strlen_ifunc(_QWORD);

//----- (0000000000417410) ----------------------------------------------------
int (__fastcall *strlen_ifunc())(const __m128i *a1)
{
  int (__fastcall *result)(const __m128i *); // rax

  result = _strlen_sse2;
  if ( (dword_4AAE4C & 0x20C00) == 3072 )
    return (int (__fastcall *)(const __m128i *))_strlen_avx2;
  return result;
}
// 4AAE4C: using guessed type int dword_4AAE4C;

//----- (0000000000417440) ----------------------------------------------------
__int64 (__fastcall *strncmp_ifunc())(__int64 *a1, __int64 *a2, unsigned __int64 a3)
{
  __int64 (__fastcall *result)(__int64 *, __int64 *, unsigned __int64); // rax

  result = (__int64 (__fastcall *)(__int64 *, __int64 *, unsigned __int64))_strncmp_avx2;
  if ( (dword_4AAE4C & 0x20C00) != 3072 )
  {
    if ( (dword_4AAE10 & 0x100000) == 0
      || (result = (__int64 (__fastcall *)(__int64 *, __int64 *, unsigned __int64))_strncmp_sse42,
          (dword_4AAE4C & 0x200) != 0) )
    {
      result = _strncmp_sse2;
      if ( (dword_4AAE10 & 0x200) != 0 )
        return _strncmp_ssse3;
    }
  }
  return result;
}
// 4AAE10: using guessed type int dword_4AAE10;
// 4AAE4C: using guessed type int dword_4AAE4C;

//----- (00000000004174A0) ----------------------------------------------------
unsigned __int64 __fastcall critical_factorization(__int64 a1, unsigned __int64 a2, __int64 *a3)
{
  __int64 v3; // r11
  __int64 v4; // r8
  __int64 v5; // r9
  __int64 v6; // rax
  unsigned __int64 v7; // rcx
  unsigned __int8 v8; // bl
  unsigned __int64 v9; // r11
  __int64 v10; // rbx
  __int64 v11; // r8
  __int64 v12; // r9
  __int64 v13; // r10
  unsigned __int64 v14; // rcx
  unsigned __int8 v15; // r11
  unsigned __int64 v16; // rbx
  unsigned __int64 v17; // r10
  unsigned __int64 result; // rax

  v3 = 1LL;
  v4 = 1LL;
  v5 = 0LL;
  v6 = -1LL;
  while ( 1 )
  {
    v7 = v5 + v4;
    if ( v5 + v4 >= a2 )
      break;
    while ( 1 )
    {
      v8 = *(_BYTE *)(a1 + v6 + v4);
      if ( *(_BYTE *)(a1 + v7) >= v8 )
        break;
      v5 = v7;
      v4 = 1LL;
      v9 = v7++;
      v3 = v9 - v6;
      if ( v7 >= a2 )
        goto LABEL_5;
    }
    if ( *(_BYTE *)(a1 + v7) == v8 )
    {
      if ( v4 == v3 )
      {
        v5 = v7;
        v4 = 1LL;
      }
      else
      {
        ++v4;
      }
    }
    else
    {
      v6 = v5;
      v3 = 1LL;
      ++v5;
      v4 = 1LL;
    }
  }
LABEL_5:
  *a3 = v3;
  v10 = 1LL;
  v11 = 1LL;
  v12 = 0LL;
  v13 = -1LL;
  while ( 1 )
  {
    v14 = v12 + v11;
    if ( v12 + v11 >= a2 )
      break;
    while ( 1 )
    {
      v15 = *(_BYTE *)(a1 + v13 + v11);
      if ( *(_BYTE *)(a1 + v14) <= v15 )
        break;
      v12 = v14;
      v11 = 1LL;
      v16 = v14++;
      v10 = v16 - v13;
      if ( v14 >= a2 )
        goto LABEL_9;
    }
    if ( *(_BYTE *)(a1 + v14) == v15 )
    {
      if ( v11 == v10 )
      {
        v12 = v14;
        v11 = 1LL;
      }
      else
      {
        ++v11;
      }
    }
    else
    {
      v13 = v12;
      v10 = 1LL;
      ++v12;
      v11 = 1LL;
    }
  }
LABEL_9:
  v17 = v13 + 1;
  result = v6 + 1;
  if ( v17 >= result )
  {
    *a3 = v10;
    return v17;
  }
  return result;
}

//----- (00000000004175D0) ----------------------------------------------------
__int64 __fastcall two_way_long_needle(__int64 a1, unsigned __int64 a2, __int64 a3, unsigned __int64 a4)
{
  unsigned __int64 v6; // r13
  char *v7; // rax
  unsigned __int8 *v8; // rax
  __int64 v9; // rdx
  __int64 v10; // rcx
  unsigned __int64 v11; // rcx
  unsigned __int64 v12; // r15
  unsigned __int64 v13; // r8
  unsigned __int64 v14; // rax
  __int64 v15; // rbx
  unsigned __int64 v16; // rax
  unsigned __int64 v17; // r13
  unsigned __int64 v18; // r12
  unsigned __int64 v19; // rax
  unsigned __int64 v20; // rdx
  __int64 v21; // rax
  unsigned __int64 v22; // rdx
  _BYTE *v23; // rax
  unsigned __int64 v25; // rcx
  unsigned __int64 v26; // r8
  unsigned __int64 v27; // rax
  __int64 v28; // r15
  unsigned __int64 v29; // rax
  unsigned __int64 v30; // rbx
  _BYTE *v31; // r11
  unsigned __int64 v32; // rax
  unsigned __int64 v33; // r13
  __int64 v34; // r12
  unsigned __int64 v35; // rbp
  __int64 v36; // rax
  __int64 v37; // rax
  _BYTE *v38; // rsi
  __int64 v39; // rax
  char v40; // dl
  unsigned __int64 v41; // [rsp+8h] [rbp-8A0h]
  unsigned __int64 v42; // [rsp+8h] [rbp-8A0h]
  unsigned __int64 v43; // [rsp+10h] [rbp-898h]
  unsigned __int64 v44; // [rsp+10h] [rbp-898h]
  unsigned __int64 v45; // [rsp+18h] [rbp-890h]
  _BYTE *v46; // [rsp+18h] [rbp-890h]
  unsigned __int64 v47; // [rsp+20h] [rbp-888h]
  unsigned __int64 v48; // [rsp+20h] [rbp-888h]
  unsigned __int64 v49; // [rsp+28h] [rbp-880h]
  _BYTE *v50; // [rsp+28h] [rbp-880h]
  unsigned __int64 v51; // [rsp+30h] [rbp-878h]
  unsigned __int64 v52; // [rsp+30h] [rbp-878h]
  unsigned __int64 v53; // [rsp+38h] [rbp-870h]
  unsigned __int64 v54; // [rsp+38h] [rbp-870h]
  unsigned __int64 v55; // [rsp+40h] [rbp-868h]
  unsigned __int64 v56; // [rsp+40h] [rbp-868h]
  _BYTE *v57; // [rsp+48h] [rbp-860h]
  __int64 v58; // [rsp+48h] [rbp-860h]
  unsigned __int64 v59; // [rsp+58h] [rbp-850h] BYREF
  __int64 v60[256]; // [rsp+60h] [rbp-848h] BYREF
  char v61; // [rsp+860h] [rbp-48h] BYREF
  unsigned __int64 v62; // [rsp+868h] [rbp-40h]

  v62 = __readfsqword(0x28u);
  v6 = critical_factorization(a3, a4, (__int64 *)&v59);
  v7 = (char *)v60;
  do
  {
    *(_QWORD *)v7 = a4;
    v7 += 8;
  }
  while ( v7 != &v61 );
  if ( a4 )
  {
    v8 = (unsigned __int8 *)a3;
    do
    {
      v9 = *v8;
      v10 = a3 + a4 - 1 - (_QWORD)v8++;
      v60[v9] = v10;
    }
    while ( v8 != (unsigned __int8 *)(a4 + a3) );
  }
  v47 = v59;
  if ( !(unsigned int)j_memcmp_ifunc(a3, a3 + v59, v6) )
  {
    v11 = v6;
    v49 = a4 + 512;
    v12 = a4 - 1;
    v13 = a4;
    v55 = v6 - 1;
    v57 = (_BYTE *)(a3 + v6 - 1);
    v14 = a4 - v47;
    v15 = 0LL;
    v51 = v14;
    v16 = 1 - v6;
    v17 = a2;
    v18 = 0LL;
    v53 = v16;
    while ( 1 )
    {
      while ( 1 )
      {
        v20 = v15 + v13;
        if ( v15 + v13 > v17 )
        {
          v45 = v13;
          v43 = v11;
          v41 = v15 + v13;
          v21 = j_strnlen(a1 + v17, v49);
          v20 = v41;
          v11 = v43;
          v17 += v21;
          v13 = v45;
          if ( v41 > v17 )
            return 0LL;
        }
        v19 = v60[*(unsigned __int8 *)(a1 + v20 - 1)];
        if ( !v19 )
          break;
        if ( v18 && v47 > v19 )
          v19 = v51;
LABEL_11:
        v15 += v19;
        v18 = 0LL;
      }
      v19 = v11;
      if ( v18 >= v11 )
        v19 = v18;
      if ( v19 >= v12 )
        goto LABEL_22;
      if ( *(_BYTE *)(a1 + v15 + v19) != *(_BYTE *)(a3 + v19) )
      {
LABEL_30:
        v15 += v53;
        goto LABEL_11;
      }
      while ( ++v19 < v12 )
      {
        if ( *(_BYTE *)(a3 + v19) != *(_BYTE *)(a1 + v15 + v19) )
          goto LABEL_30;
      }
LABEL_22:
      v22 = v55;
      v23 = (_BYTE *)(a1 + v15 + v55);
      if ( v18 < v11 && *v23 == *v57 )
      {
        while ( v18 != v22 && *(_BYTE *)(a3 + v22 - 1) == v23[v22 - v11] )
          --v22;
      }
      else
      {
        v22 = v11;
      }
      if ( v18 + 1 > v22 )
        return a1 + v15;
      v15 += v47;
      v18 = v51;
    }
  }
  v25 = v6;
  v26 = a4;
  v27 = a4 - v6;
  if ( a4 - v6 < v6 )
    v27 = v6;
  v28 = 0LL;
  v56 = v27 + 1;
  v59 = v27 + 1;
  v29 = a4 + 512;
  v30 = a4 - 1;
  v48 = v29;
  v50 = (_BYTE *)(a3 + v6);
  v54 = v6 - 1;
  v31 = (_BYTE *)(a3 + v6 - 1);
  v58 = -(__int64)v6;
  v32 = 1 - v6;
  v33 = a2;
  v34 = a3;
  v52 = v32;
  while ( 1 )
  {
    while ( 1 )
    {
      v35 = v28 + v26;
      if ( v28 + v26 > v33 )
      {
        v46 = v31;
        v44 = v26;
        v42 = v25;
        v36 = j_strnlen(a1 + v33, v48);
        v25 = v42;
        v26 = v44;
        v33 += v36;
        v31 = v46;
        if ( v35 > v33 )
          return 0LL;
      }
      v37 = v60[*(unsigned __int8 *)(a1 + v35 - 1)];
      if ( !v37 )
        break;
LABEL_35:
      v28 += v37;
    }
    if ( v25 >= v30 )
      goto LABEL_44;
    v37 = v25;
    if ( *v50 != *(_BYTE *)(a1 + v28 + v25) )
    {
LABEL_50:
      v28 += v52;
      goto LABEL_35;
    }
    while ( ++v37 < v30 )
    {
      if ( *(_BYTE *)(v34 + v37) != *(_BYTE *)(a1 + v28 + v37) )
        goto LABEL_50;
    }
LABEL_44:
    v38 = (_BYTE *)(a1 + v28 + v54);
    if ( v54 == -1LL )
      return a1 + v28;
    v39 = -1LL;
    if ( *v31 == *v38 )
      break;
LABEL_51:
    v28 += v56;
  }
  while ( v58 != v39 )
  {
    v40 = v31[v39--];
    if ( v40 != v38[v39 + 1] )
      goto LABEL_51;
  }
  return a1 + v28;
}
// 401028: using guessed type __int64 __fastcall j_strnlen(_QWORD, _QWORD);
// 401080: using guessed type __int64 __fastcall j_memcmp_ifunc(_QWORD, _QWORD, _QWORD);
// 4175D0: using guessed type __int64 var_848[256];

//----- (00000000004179A0) ----------------------------------------------------
char *__fastcall _strstr_sse2(char *a1, char *a2)
{
  char v3; // r9
  char v4; // al
  char *v5; // rdx
  char *v6; // rbx
  char v7; // cl
  char v8; // di
  bool v9; // al
  char *v10; // r14
  unsigned __int64 v11; // rbp
  unsigned __int64 v12; // r9
  unsigned __int64 v13; // r12
  int v15; // eax
  unsigned __int64 v16; // r10
  unsigned __int64 v17; // r15
  __int64 i; // r13
  __int64 v19; // rax
  unsigned __int64 v20; // rax
  unsigned __int64 v21; // rdx
  char *v22; // rcx
  char *v23; // rcx
  unsigned __int8 v24; // di
  char *v25; // r13
  unsigned __int64 v26; // rax
  __int64 v27; // r15
  char *v28; // rcx
  unsigned __int64 v29; // rbx
  char *v30; // rax
  _BYTE *v31; // r14
  char *v32; // r12
  __int64 v33; // rax
  char *v34; // rax
  char *v35; // rdi
  __int64 v36; // rax
  unsigned __int64 v37; // rdx
  char *v38; // rsi
  char v39; // al
  char *v40; // rdi
  char v41; // dl
  __int64 v42; // rax
  char v43; // si
  __int64 v44; // r8
  unsigned __int64 v45; // [rsp+8h] [rbp-A0h]
  char *v46; // [rsp+8h] [rbp-A0h]
  unsigned __int64 v47; // [rsp+10h] [rbp-98h]
  unsigned __int8 v48; // [rsp+10h] [rbp-98h]
  char *v50; // [rsp+20h] [rbp-88h]
  __int64 v51; // [rsp+28h] [rbp-80h]
  unsigned __int64 v52; // [rsp+28h] [rbp-80h]
  unsigned int v53; // [rsp+30h] [rbp-78h]
  char *v54; // [rsp+38h] [rbp-70h]
  unsigned __int64 v55; // [rsp+48h] [rbp-60h]
  unsigned __int64 v56; // [rsp+50h] [rbp-58h]
  __int64 v57; // [rsp+58h] [rbp-50h]
  __int64 v58[9]; // [rsp+60h] [rbp-48h] BYREF

  v3 = *a2;
  v58[1] = __readfsqword(0x28u);
  v4 = *a1;
  if ( !*a1 )
  {
    v44 = 0LL;
    if ( !v3 )
      return a1;
    return (char *)v44;
  }
  if ( !v3 )
    return a1;
  v5 = a1;
  v6 = a2;
  v7 = v3;
  v8 = 1;
  while ( 1 )
  {
    ++v5;
    ++v6;
    v9 = v4 == v7;
    v7 = *v6;
    v8 &= v9;
    v4 = *v5;
    if ( !*v5 )
      break;
    if ( !v7 )
      goto LABEL_7;
  }
  v10 = 0LL;
  if ( v7 )
    return v10;
LABEL_7:
  v10 = a1;
  if ( v8 )
    return v10;
  v11 = v6 - a2;
  v10 = (char *)j_strchr_ifunc(a1 + 1, (unsigned int)v3);
  if ( !v10 || v11 == 1 )
    return v10;
  v12 = &a1[v11] - v10;
  if ( &a1[v11] < v10 )
    v12 = 1LL;
  v13 = v12;
  if ( v11 > 0x1F )
    return (char *)two_way_long_needle((__int64)v10, v12, (__int64)a2, v11);
  v45 = critical_factorization((__int64)a2, v11, v58);
  v51 = v58[0];
  v15 = j_memcmp_ifunc(a2, &a2[v58[0]], v45);
  v16 = v45;
  if ( !v15 )
  {
    v17 = 0LL;
    for ( i = 0LL; ; i += v20 + 1 - v45 )
    {
      while ( 1 )
      {
        if ( v11 + i > v13 )
        {
          v47 = v16;
          v19 = j_strnlen(&v10[v13], v11 + 512);
          v16 = v47;
          v13 += v19;
          if ( v11 + i > v13 )
            return 0LL;
        }
        v20 = v17;
        if ( v16 >= v17 )
          v20 = v16;
        if ( v11 > v20 )
          break;
LABEL_26:
        v21 = v45 - 1;
        v22 = &v10[i - 1 + v45];
        if ( v16 > v17 && a2[v45 - 1] == *v22 )
        {
          v23 = &v22[-v16];
          while ( v17 != v21 && a2[v21 - 1] == v23[v21] )
            --v21;
        }
        else
        {
          v21 = v16;
        }
        if ( v17 + 1 > v21 )
        {
          v10 += i;
          return v10;
        }
        i += v51;
        v17 = v11 - v51;
      }
      if ( v10[v20 + i] == a2[v20] )
      {
        while ( v11 != ++v20 )
        {
          if ( a2[v20] != v10[i + v20] )
            goto LABEL_34;
        }
        goto LABEL_26;
      }
LABEL_34:
      v17 = 0LL;
    }
  }
  v24 = a2[v45];
  v25 = a2 + 1;
  v26 = v11 - v45;
  v48 = v24;
  if ( v11 - v45 < v45 )
    v26 = v45;
  v27 = 0LL;
  v52 = 1 - v45;
  v56 = v26 + 1;
  v58[0] = v26 + 1;
  v53 = v24;
  v54 = &v10[v45];
  v28 = &a2[v45 - 1];
  v55 = v45 - 1;
  v29 = v45;
  v57 = -(__int64)v45;
  v30 = v10;
  v31 = (_BYTE *)v13;
  v32 = v30;
  while ( 1 )
  {
    while ( 1 )
    {
      if ( v11 + v27 > (unsigned __int64)v31 )
      {
        v50 = v28;
        v33 = j_strnlen(&v31[(_QWORD)v32], v11 + 512);
        v28 = v50;
        v31 += v33;
        if ( v11 + v27 > (unsigned __int64)v31 )
          return 0LL;
      }
      v34 = &v32[v29 + v27];
      v35 = v34 + 1;
      if ( v48 != *v34 )
      {
        v46 = v28;
        v36 = j_strchr_ifunc(v35, v53);
        if ( !v36 )
          return 0LL;
        v28 = v46;
        v35 = (char *)(v36 + 1);
        v27 = v36 - (_QWORD)v54;
      }
      v37 = v29 + 1;
      if ( v11 <= v29 + 1 )
      {
        v38 = v35;
        goto LABEL_49;
      }
      v38 = v35 + 1;
      v39 = *v35;
      if ( *v35 == a2[v29 + 1] )
      {
        while ( v11 > ++v37 )
        {
          v39 = *v38++;
          if ( v25[v37 - 1] != v39 )
            goto LABEL_56;
        }
LABEL_49:
        if ( v38 <= &v31[(_QWORD)v32] )
          break;
LABEL_58:
        v31 = (_BYTE *)(v38 - v32);
        goto LABEL_59;
      }
LABEL_56:
      if ( !v39 )
        return 0LL;
      if ( v38 > &v31[(_QWORD)v32] )
        goto LABEL_58;
LABEL_59:
      if ( v11 <= v37 )
        break;
      v27 += v37 + v52;
    }
    v40 = &v32[v55 + v27];
    if ( v55 == -1LL )
      return &v32[v27];
    v41 = *v40;
    v42 = -1LL;
    if ( *v28 == *v40 )
      break;
LABEL_61:
    if ( !v41 )
      return 0LL;
    v27 += v56;
  }
  while ( v57 != v42 )
  {
    v43 = v28[v42--];
    v41 = v40[v42 + 1];
    if ( v43 != v41 )
      goto LABEL_61;
  }
  return &v32[v27];
}
// 401028: using guessed type __int64 __fastcall j_strnlen(_QWORD, _QWORD);
// 401080: using guessed type __int64 __fastcall j_memcmp_ifunc(_QWORD, _QWORD, _QWORD);
// 4010D0: using guessed type __int64 __fastcall j_strchr_ifunc(_QWORD, _QWORD);

//----- (0000000000417E40) ----------------------------------------------------
__int8 *(__fastcall *strstr())(__int64, char *)
{
  __int8 *(__fastcall *result)(__int64, char *); // rax

  result = _strstr_sse2_unaligned;
  if ( (dword_4AAE4C & 0x10) == 0 )
    return (__int8 *(__fastcall *)(__int64, char *))_strstr_sse2;
  return result;
}
// 4AAE4C: using guessed type int dword_4AAE4C;

//----- (0000000000417E60) ----------------------------------------------------
__int64 (__fastcall *memcmp_ifunc())(const __m128i *a1, const __m128i *a2, unsigned __int64 a3)
{
  __int64 (__fastcall *result)(const __m128i *, const __m128i *, unsigned __int64); // rax

  if ( (dword_4AAE4C & 0x20400) != 1024
    || (dword_4AAE10 & 0x400000) == 0
    || (result = (__int64 (__fastcall *)(const __m128i *, const __m128i *, unsigned __int64))_memcmp_avx2_movbe,
        (dword_4AAE4C & 0x800) == 0) )
  {
    result = (__int64 (__fastcall *)(const __m128i *, const __m128i *, unsigned __int64))_memcmp_sse4_1;
    if ( (dword_4AAE10 & 0x80000) == 0 )
    {
      result = (__int64 (__fastcall *)(const __m128i *, const __m128i *, unsigned __int64))_memcmp_sse2;
      if ( (dword_4AAE10 & 0x200) != 0 )
        return _memcmp_ssse3;
    }
  }
  return result;
}
// 4AAE10: using guessed type int dword_4AAE10;
// 4AAE4C: using guessed type int dword_4AAE4C;

//----- (0000000000417EC0) ----------------------------------------------------
__int64 (__fastcall *memmove())(__int64 _RDI, __int64 _RSI, unsigned __int64 _RDX)
{
  __int64 (__fastcall *result)(__int64, __int64, unsigned __int64); // rax

  result = (__int64 (__fastcall *)(__int64, __int64, unsigned __int64))_memmove_erms;
  if ( (dword_4AAE4C & 0x880000) == 0 )
  {
    if ( (dword_4AAE4C & 0x101000) == 4096 )
    {
      result = (__int64 (__fastcall *)(__int64, __int64, unsigned __int64))_memmove_avx512_no_vzeroupper;
      if ( (dword_4AAE4C & 0x20000) == 0 )
      {
        result = (__int64 (__fastcall *)(__int64, __int64, unsigned __int64))_memmove_avx512_unaligned_erms;
        if ( (dword_4AAE1C & 0x200) == 0 )
          return _memmove_avx512_unaligned;
      }
    }
    else if ( (dword_4AAE4C & 0x800) != 0 )
    {
      result = (__int64 (__fastcall *)(__int64, __int64, unsigned __int64))_memmove_avx_unaligned_erms;
      if ( (dword_4AAE1C & 0x200) == 0 )
        return _memmove_avx_unaligned;
    }
    else if ( (dword_4AAE10 & 0x200) == 0 || (dword_4AAE4C & 0x40000) != 0 )
    {
      result = (__int64 (__fastcall *)(__int64, __int64, unsigned __int64))_memmove_sse2_unaligned_erms;
      if ( (dword_4AAE1C & 0x200) == 0 )
        return (__int64 (__fastcall *)(__int64, __int64, unsigned __int64))_memmove_sse2_unaligned;
    }
    else
    {
      result = (__int64 (__fastcall *)(__int64, __int64, unsigned __int64))_memmove_ssse3;
      if ( (dword_4AAE4C & 2) != 0 )
        return (__int64 (__fastcall *)(__int64, __int64, unsigned __int64))_memmove_ssse3_back;
    }
  }
  return result;
}
// 4AAE10: using guessed type int dword_4AAE10;
// 4AAE1C: using guessed type int dword_4AAE1C;
// 4AAE4C: using guessed type int dword_4AAE4C;

//----- (0000000000417F90) ----------------------------------------------------
__int64 (__fastcall *memset_ifunc())(__int64 _RDI, int _ESI, unsigned __int64 _RDX)
{
  __int64 (__fastcall *result)(__int64, int, unsigned __int64); // rax
  int v1; // eax
  bool v2; // zf

  result = (__int64 (__fastcall *)(__int64, int, unsigned __int64))_memset_erms;
  if ( (dword_4AAE4C & 0x80000) == 0 )
  {
    if ( (dword_4AAE4C & 0x101000) == 4096 )
    {
      result = (__int64 (__fastcall *)(__int64, int, unsigned __int64))_memset_avx512_no_vzeroupper;
      if ( (dword_4AAE4C & 0x20000) == 0 )
      {
        result = (__int64 (__fastcall *)(__int64, int, unsigned __int64))_memset_avx512_unaligned_erms;
        if ( (dword_4AAE1C & 0x200) == 0 )
          return _memset_avx512_unaligned;
      }
    }
    else
    {
      v1 = dword_4AAE1C & 0x200;
      if ( (dword_4AAE4C & 0x400) != 0 )
      {
        v2 = v1 == 0;
        result = (__int64 (__fastcall *)(__int64, int, unsigned __int64))_memset_avx2_unaligned_erms;
        if ( v2 )
          return _memset_avx2_unaligned;
      }
      else
      {
        v2 = v1 == 0;
        result = (__int64 (__fastcall *)(__int64, int, unsigned __int64))_memset_sse2_unaligned;
        if ( !v2 )
          return (__int64 (__fastcall *)(__int64, int, unsigned __int64))_memset_sse2_unaligned_erms;
      }
    }
  }
  return result;
}
// 4AAE1C: using guessed type int dword_4AAE1C;
// 4AAE4C: using guessed type int dword_4AAE4C;

//----- (0000000000418030) ----------------------------------------------------
void (*mempcpy())()
{
  void (*result)(); // rax

  result = (void (*)())_mempcpy_erms;
  if ( (dword_4AAE4C & 0x880000) == 0 )
  {
    if ( (dword_4AAE4C & 0x101000) == 4096 )
    {
      result = _mempcpy_avx512_no_vzeroupper;
      if ( (dword_4AAE4C & 0x20000) == 0 )
      {
        result = _mempcpy_avx512_unaligned_erms;
        if ( (dword_4AAE1C & 0x200) == 0 )
          return _mempcpy_avx512_unaligned;
      }
    }
    else if ( (dword_4AAE4C & 0x800) != 0 )
    {
      result = _mempcpy_avx_unaligned_erms;
      if ( (dword_4AAE1C & 0x200) == 0 )
        return _mempcpy_avx_unaligned;
    }
    else if ( (dword_4AAE10 & 0x200) == 0 || (dword_4AAE4C & 0x40000) != 0 )
    {
      result = _mempcpy_sse2_unaligned_erms;
      if ( (dword_4AAE1C & 0x200) == 0 )
        return _mempcpy_sse2_unaligned;
    }
    else
    {
      result = _mempcpy_ssse3;
      if ( (dword_4AAE4C & 2) != 0 )
        return _mempcpy_ssse3_back;
    }
  }
  return result;
}
// 4AAE10: using guessed type int dword_4AAE10;
// 4AAE1C: using guessed type int dword_4AAE1C;
// 4AAE4C: using guessed type int dword_4AAE4C;

//----- (0000000000418100) ----------------------------------------------------
void *stpcpy()
{
  void *result; // rax

  result = _stpcpy_sse2_unaligned;
  if ( (dword_4AAE4C & 0x10) == 0 )
  {
    result = _stpcpy_sse2;
    if ( (dword_4AAE10 & 0x200) != 0 )
      return _stpcpy_ssse3;
  }
  return result;
}
// 4AAE10: using guessed type int dword_4AAE10;
// 4AAE4C: using guessed type int dword_4AAE4C;

//----- (0000000000418130) ----------------------------------------------------
__int64 (__fastcall *strcasecmp_l())(__int64 a1, __int64 a2, __int64 a3, __m128i a4, __m128i a5, __m128i a6, double a7, double a8)
{
  __int64 (__fastcall *result)(__int64, __int64, __int64, __m128i, __m128i, __m128i, double, double); // rax

  result = (__int64 (__fastcall *)(__int64, __int64, __int64, __m128i, __m128i, __m128i, double, double))_strcasecmp_l_avx;
  if ( (dword_4AAE4C & 0x40) == 0 )
  {
    if ( (dword_4AAE10 & 0x100000) == 0
      || (result = (__int64 (__fastcall *)(__int64, __int64, __int64, __m128i, __m128i, __m128i, double, double))_strcasecmp_l_sse42,
          (dword_4AAE4C & 0x200) != 0) )
    {
      result = _strcasecmp_l_sse2;
      if ( (dword_4AAE10 & 0x200) != 0 )
        return _strcasecmp_l_ssse3;
    }
  }
  return result;
}
// 4AAE10: using guessed type int dword_4AAE10;
// 4AAE4C: using guessed type int dword_4AAE4C;

//----- (0000000000418180) ----------------------------------------------------
__int64 (__fastcall *memcpy())(__int64 _RDI, __int64 _RSI, unsigned __int64 _RDX)
{
  __int64 (__fastcall *result)(__int64, __int64, unsigned __int64); // rax

  result = (__int64 (__fastcall *)(__int64, __int64, unsigned __int64))_memmove_erms;
  if ( (dword_4AAE4C & 0x880000) == 0 )
  {
    if ( (dword_4AAE4C & 0x101000) == 4096 )
    {
      result = (__int64 (__fastcall *)(__int64, __int64, unsigned __int64))_memmove_avx512_no_vzeroupper;
      if ( (dword_4AAE4C & 0x20000) == 0 )
      {
        result = (__int64 (__fastcall *)(__int64, __int64, unsigned __int64))_memmove_avx512_unaligned_erms;
        if ( (dword_4AAE1C & 0x200) == 0 )
          return _memmove_avx512_unaligned;
      }
    }
    else if ( (dword_4AAE4C & 0x800) != 0 )
    {
      result = (__int64 (__fastcall *)(__int64, __int64, unsigned __int64))_memmove_avx_unaligned_erms;
      if ( (dword_4AAE1C & 0x200) == 0 )
        return _memmove_avx_unaligned;
    }
    else if ( (dword_4AAE10 & 0x200) == 0 || (dword_4AAE4C & 0x40000) != 0 )
    {
      result = (__int64 (__fastcall *)(__int64, __int64, unsigned __int64))_memmove_sse2_unaligned_erms;
      if ( (dword_4AAE1C & 0x200) == 0 )
        return (__int64 (__fastcall *)(__int64, __int64, unsigned __int64))_memmove_sse2_unaligned;
    }
    else
    {
      result = (__int64 (__fastcall *)(__int64, __int64, unsigned __int64))_memcpy_ssse3;
      if ( (dword_4AAE4C & 2) != 0 )
        return (__int64 (__fastcall *)(__int64, __int64, unsigned __int64))_memcpy_ssse3_back;
    }
  }
  return result;
}
// 4AAE10: using guessed type int dword_4AAE10;
// 4AAE1C: using guessed type int dword_4AAE1C;
// 4AAE4C: using guessed type int dword_4AAE4C;

//----- (0000000000418250) ----------------------------------------------------
__int64 (__fastcall *rawmemchr())(const __m128i *a1, unsigned __int64 a2)
{
  __int64 (__fastcall *result)(const __m128i *, unsigned __int64); // rax

  result = _rawmemchr_sse2;
  if ( (dword_4AAE4C & 0x20C00) == 3072 )
    return (__int64 (__fastcall *)(const __m128i *, unsigned __int64))_rawmemchr_avx2;
  return result;
}
// 4AAE4C: using guessed type int dword_4AAE4C;

//----- (0000000000418280) ----------------------------------------------------
unsigned __int64 (__fastcall *strchrnul())(unsigned __int64 _RDI, int _ESI)
{
  unsigned __int64 (__fastcall *result)(unsigned __int64, int); // rax

  result = (unsigned __int64 (__fastcall *)(unsigned __int64, int))_strchrnul_sse2;
  if ( (dword_4AAE4C & 0x20C00) == 3072 )
    return _strchrnul_avx2;
  return result;
}
// 4AAE4C: using guessed type int dword_4AAE4C;

//----- (00000000004182B0) ----------------------------------------------------
__int64 __fastcall _strcmp_sse2(__int64 *a1, __int64 *a2)
{
  unsigned int v2; // ecx
  unsigned int v3; // eax
  __m128i v4; // xmm1
  __m128i v5; // xmm2
  unsigned __int64 v6; // rdx
  const __m128i *v7; // rsi
  __m128i *v8; // rdi
  __int64 v9; // r8
  __int64 v10; // rcx
  __int64 v11; // rax
  unsigned int v12; // et0
  __m128i *v13; // rt1
  __m128i si128; // xmm1
  __m128i v16; // xmm0
  __m128i v17; // xmm1
  __m128i v18; // xmm0
  __m128i v19; // xmm1

  v2 = (unsigned __int8)a2 & 0x3F;
  v3 = (unsigned __int8)a1 & 0x3F;
  if ( v2 <= 0x30 && v3 <= 0x30 )
  {
    v4.m128i_i64[0] = *a1;
    v5.m128i_i64[0] = *a2;
    v4.m128i_i64[1] = a1[1];
    v5.m128i_i64[1] = a2[1];
    v6 = (unsigned int)(_mm_movemask_epi8(_mm_sub_epi8(_mm_cmpeq_epi8(v4, v5), _mm_cmpeq_epi8((__m128i)0LL, v4)))
                      - 0xFFFF);
    if ( (_DWORD)v6 )
    {
LABEL_16:
      _BitScanForward64(&v6, v6);
      return *((unsigned __int8 *)a1 + v6) - (unsigned int)*((unsigned __int8 *)a2 + v6);
    }
    a2 += 2;
    a1 += 2;
  }
  v7 = (const __m128i *)((unsigned __int64)a2 & 0xFFFFFFFFFFFFFFF0LL);
  v8 = (__m128i *)((unsigned __int64)a1 & 0xFFFFFFFFFFFFFFF0LL);
  v9 = 0LL;
  v10 = v2 & 0xF;
  v11 = v3 & 0xF;
  if ( (_DWORD)v10 == (_DWORD)v11 )
  {
    si128 = _mm_load_si128(v7);
    v6 = (0xFFFFu >> v10)
       - ((unsigned int)_mm_movemask_epi8(_mm_sub_epi8(_mm_cmpeq_epi8(si128, *v8), _mm_cmpeq_epi8((__m128i)0LL, si128))) >> v10);
    if ( !(_DWORD)v6 )
    {
      v10 = 16LL;
      v16 = 0LL;
      while ( 1 )
      {
        v17 = _mm_load_si128((const __m128i *)((char *)v7 + v10));
        v18 = _mm_cmpeq_epi8(v16, v17);
        v6 = (unsigned int)(_mm_movemask_epi8(_mm_sub_epi8(_mm_cmpeq_epi8(v17, _mm_load_si128((__m128i *)((char *)v8 + v10))), v18))
                          - 0xFFFF);
        if ( (_DWORD)v6 )
          break;
        v10 += 16LL;
        v19 = _mm_load_si128((const __m128i *)((char *)v7 + v10));
        v16 = _mm_cmpeq_epi8(v18, v19);
        v6 = (unsigned int)(_mm_movemask_epi8(_mm_sub_epi8(_mm_cmpeq_epi8(v19, _mm_load_si128((__m128i *)((char *)v8 + v10))), v16))
                          - 0xFFFF);
        if ( (_DWORD)v6 )
          break;
        v10 += 16LL;
      }
      v11 = v10;
    }
    a1 = (__int64 *)((char *)v8->m128i_i64 + v11);
    a2 = (__int64 *)((char *)v7->m128i_i64 + v10);
    goto LABEL_16;
  }
  if ( (unsigned int)v10 <= (unsigned int)v11 )
  {
    v9 = 0xFFFFLL;
    v12 = v11;
    v11 = (unsigned int)v10;
    v10 = v12;
    v13 = (__m128i *)v7;
    v7 = v8;
    v8 = v13;
  }
  return ((__int64 (__fastcall *)(__m128i *, const __m128i *, __int64, __int64, __int64))((char *)dword_481BB0
                                                                                        + dword_481BB0[v11 + 15 - v10]))(
           v8,
           v7,
           0xFFFFLL,
           v10,
           v9);
}
// 481BB0: using guessed type int dword_481BB0[16];

//----- (0000000000419700) ----------------------------------------------------
__int64 __fastcall _strcmp_sse2_unaligned(const __m128i *a1, const __m128i *a2)
{
  __int64 v2; // rdx
  __m128i v3; // xmm1
  unsigned __int64 v4; // rax
  unsigned __int64 v5; // rdx
  __m128i v7; // xmm6
  __m128i v8; // xmm5
  __m128i v9; // xmm4
  const __m128i *v10; // rax
  const __m128i *v11; // rdx
  unsigned __int64 v12; // rsi
  __m128i si128; // xmm2
  __m128i v15; // xmm3
  __m128i v16; // xmm0
  __m128i v17; // xmm1
  __m128i v18; // xmm2
  __m128i v19; // xmm3
  __m128i v20; // xmm5
  __m128i v21; // xmm6
  __m128i v22; // xmm2
  unsigned __int64 v23; // rcx
  __int64 v24; // r9
  __m128i v25; // xmm2
  __m128i v26; // xmm3
  __m128i v27; // xmm0
  __m128i v28; // xmm1
  __m128i v29; // xmm2
  __m128i v30; // xmm3
  unsigned __int64 v31; // rdi
  unsigned __int64 v32; // rcx
  int v33; // eax
  int v34; // ecx

  v2 = 0LL;
  if ( (((unsigned __int16)a2 | (unsigned __int16)a1) & 0xFFFu) > 0xFC0 )
  {
    while ( 1 )
    {
      v33 = a1->m128i_u8[v2];
      v34 = a2->m128i_u8[v2];
      if ( !(_BYTE)v33 )
        break;
      if ( (_BYTE)v33 != (_BYTE)v34 )
        return (unsigned int)(v33 - v34);
      if ( ++v2 == 64 )
        goto LABEL_5;
    }
    v33 = 0;
    return (unsigned int)(v33 - v34);
  }
  else
  {
    v3 = _mm_loadu_si128(a1);
    v4 = (unsigned int)_mm_movemask_epi8(_mm_cmpeq_epi8(_mm_min_epu8(_mm_cmpeq_epi8(_mm_loadu_si128(a2), v3), v3), (__m128i)0LL));
    if ( (_DWORD)v4
      || (v7 = _mm_loadu_si128(a1 + 1),
          v8 = _mm_loadu_si128(a1 + 2),
          v9 = _mm_loadu_si128(a1 + 3),
          (v4 = ((unsigned __int64)(unsigned int)_mm_movemask_epi8(
                                                   _mm_cmpeq_epi8(
                                                     _mm_min_epu8(_mm_cmpeq_epi8(_mm_loadu_si128(a2 + 3), v9), v9),
                                                     (__m128i)0LL)) << 48) | ((unsigned __int64)(unsigned int)_mm_movemask_epi8(_mm_cmpeq_epi8(_mm_min_epu8(_mm_cmpeq_epi8(_mm_loadu_si128(a2 + 1), v7), v7), (__m128i)0LL)) << 16) | ((unsigned __int64)(unsigned int)_mm_movemask_epi8(_mm_cmpeq_epi8(_mm_min_epu8(_mm_cmpeq_epi8(_mm_loadu_si128(a2 + 2), v8), v8), (__m128i)0LL)) << 32)) != 0) )
    {
      _BitScanForward64(&v5, v4);
      return a1->m128i_u8[v5] - (unsigned int)a2->m128i_u8[v5];
    }
    else
    {
LABEL_5:
      v10 = (const __m128i *)((unsigned __int64)&a1[4] & 0xFFFFFFFFFFFFFFC0LL);
      v11 = (const __m128i *)((char *)a2 + (char *)v10 - (char *)a1);
      v12 = (4096 - (unsigned __int64)(((_WORD)a2 + (((_WORD)a1 + 64) & 0xFFC0) - (_WORD)a1) & 0xFFF)) >> 6;
      while ( 1 )
      {
        if ( v12-- == 0 )
        {
          v24 = (unsigned __int8)v11 & 0x3F;
          v25 = _mm_loadu_si128((const __m128i *)((char *)v10 - v24));
          v26 = _mm_loadu_si128((const __m128i *)((char *)v10 - v24 + 16));
          v27 = _mm_min_epu8(_mm_cmpeq_epi8(_mm_load_si128((const __m128i *)((char *)v11 - v24)), v25), v25);
          v28 = _mm_min_epu8(_mm_cmpeq_epi8(_mm_load_si128((const __m128i *)((char *)v11 - v24 + 16)), v26), v26);
          v29 = _mm_loadu_si128((const __m128i *)((char *)v10 - v24 + 32));
          v30 = _mm_loadu_si128((const __m128i *)((char *)v10 - v24 + 48));
          v12 = 63LL;
          v31 = (((unsigned __int64)(unsigned int)_mm_movemask_epi8(
                                                    _mm_cmpeq_epi8(
                                                      _mm_min_epu8(
                                                        _mm_cmpeq_epi8(
                                                          _mm_load_si128((const __m128i *)((char *)v11 - v24 + 48)),
                                                          v30),
                                                        v30),
                                                      (__m128i)0LL)) << 48) | ((unsigned __int64)(unsigned int)_mm_movemask_epi8(_mm_cmpeq_epi8(v28, (__m128i)0LL)) << 16) | ((unsigned __int64)(unsigned int)_mm_movemask_epi8(_mm_cmpeq_epi8(_mm_min_epu8(_mm_cmpeq_epi8(_mm_load_si128((const __m128i *)((char *)v11 - v24 + 32)), v29), v29), (__m128i)0LL)) << 32) | (unsigned int)_mm_movemask_epi8(_mm_cmpeq_epi8(v27, (__m128i)0LL))) >> ((unsigned __int8)v11 & 0x3F);
          if ( v31 )
            break;
        }
        si128 = _mm_load_si128(v10);
        v15 = _mm_load_si128(v10 + 1);
        v16 = _mm_min_epu8(_mm_cmpeq_epi8(_mm_loadu_si128(v11), si128), si128);
        v17 = _mm_min_epu8(_mm_cmpeq_epi8(_mm_loadu_si128(v11 + 1), v15), v15);
        v18 = _mm_load_si128(v10 + 2);
        v19 = _mm_load_si128(v10 + 3);
        v20 = _mm_min_epu8(_mm_cmpeq_epi8(_mm_loadu_si128(v11 + 2), v18), v18);
        v21 = _mm_min_epu8(_mm_cmpeq_epi8(_mm_loadu_si128(v11 + 3), v19), v19);
        if ( _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_min_epu8(_mm_min_epu8(_mm_min_epu8(v16, v17), v20), v21), (__m128i)0LL)) )
        {
          v22 = _mm_load_si128(v10);
          _BitScanForward64(
            &v23,
            ((unsigned __int64)(unsigned int)_mm_movemask_epi8(_mm_cmpeq_epi8(v21, (__m128i)0LL)) << 48) | (unsigned int)_mm_movemask_epi8(_mm_cmpeq_epi8(_mm_min_epu8(_mm_cmpeq_epi8(_mm_loadu_si128(v11), v22), v22), (__m128i)0LL)) | ((unsigned __int64)(unsigned int)_mm_movemask_epi8(_mm_cmpeq_epi8(v20, (__m128i)0LL)) << 32) | ((unsigned __int64)(unsigned int)_mm_movemask_epi8(_mm_cmpeq_epi8(v17, (__m128i)0LL)) << 16));
          return v10->m128i_u8[v23] - (unsigned int)v11->m128i_u8[v23];
        }
        v10 += 4;
        v11 += 4;
      }
      _BitScanForward64(&v32, v31);
      return v10->m128i_u8[v32] - (unsigned int)v11->m128i_u8[v32];
    }
  }
}

//----- (00000000004199B0) ----------------------------------------------------
__int64 __fastcall _strcmp_ssse3(__int64 *a1, __int64 *a2)
{
  unsigned int v2; // ecx
  unsigned int v3; // eax
  __m128i v4; // xmm1
  __m128i v5; // xmm2
  unsigned __int64 v6; // rdx
  const __m128i *v7; // rsi
  __m128i *v8; // rdi
  __int64 v9; // r8
  __int64 v10; // rcx
  __int64 v11; // rax
  unsigned int v12; // et0
  __m128i *v13; // rt1
  __m128i si128; // xmm1
  __m128i v16; // xmm0
  __m128i v17; // xmm1
  __m128i v18; // xmm0
  __m128i v19; // xmm1

  v2 = (unsigned __int8)a2 & 0x3F;
  v3 = (unsigned __int8)a1 & 0x3F;
  if ( v2 <= 0x30 && v3 <= 0x30 )
  {
    v4.m128i_i64[0] = *a1;
    v5.m128i_i64[0] = *a2;
    v4.m128i_i64[1] = a1[1];
    v5.m128i_i64[1] = a2[1];
    v6 = (unsigned int)(_mm_movemask_epi8(_mm_sub_epi8(_mm_cmpeq_epi8(v4, v5), _mm_cmpeq_epi8((__m128i)0LL, v4)))
                      - 0xFFFF);
    if ( (_DWORD)v6 )
    {
LABEL_16:
      _BitScanForward64(&v6, v6);
      return *((unsigned __int8 *)a1 + v6) - (unsigned int)*((unsigned __int8 *)a2 + v6);
    }
    a2 += 2;
    a1 += 2;
  }
  v7 = (const __m128i *)((unsigned __int64)a2 & 0xFFFFFFFFFFFFFFF0LL);
  v8 = (__m128i *)((unsigned __int64)a1 & 0xFFFFFFFFFFFFFFF0LL);
  v9 = 0LL;
  v10 = v2 & 0xF;
  v11 = v3 & 0xF;
  if ( (_DWORD)v10 == (_DWORD)v11 )
  {
    si128 = _mm_load_si128(v7);
    v6 = (0xFFFFu >> v10)
       - ((unsigned int)_mm_movemask_epi8(_mm_sub_epi8(_mm_cmpeq_epi8(si128, *v8), _mm_cmpeq_epi8((__m128i)0LL, si128))) >> v10);
    if ( !(_DWORD)v6 )
    {
      v10 = 16LL;
      v16 = 0LL;
      while ( 1 )
      {
        v17 = _mm_load_si128((const __m128i *)((char *)v7 + v10));
        v18 = _mm_cmpeq_epi8(v16, v17);
        v6 = (unsigned int)(_mm_movemask_epi8(_mm_sub_epi8(_mm_cmpeq_epi8(v17, _mm_load_si128((__m128i *)((char *)v8 + v10))), v18))
                          - 0xFFFF);
        if ( (_DWORD)v6 )
          break;
        v10 += 16LL;
        v19 = _mm_load_si128((const __m128i *)((char *)v7 + v10));
        v16 = _mm_cmpeq_epi8(v18, v19);
        v6 = (unsigned int)(_mm_movemask_epi8(_mm_sub_epi8(_mm_cmpeq_epi8(v19, _mm_load_si128((__m128i *)((char *)v8 + v10))), v16))
                          - 0xFFFF);
        if ( (_DWORD)v6 )
          break;
        v10 += 16LL;
      }
      v11 = v10;
    }
    a1 = (__int64 *)((char *)v8->m128i_i64 + v11);
    a2 = (__int64 *)((char *)v7->m128i_i64 + v10);
    goto LABEL_16;
  }
  if ( (unsigned int)v10 <= (unsigned int)v11 )
  {
    v9 = 0xFFFFLL;
    v12 = v11;
    v11 = (unsigned int)v10;
    v10 = v12;
    v13 = (__m128i *)v7;
    v7 = v8;
    v8 = v13;
  }
  return ((__int64 (__fastcall *)(__m128i *, const __m128i *, __int64, __int64, __int64))((char *)dword_481BF0
                                                                                        + dword_481BF0[v11 + 15 - v10]))(
           v8,
           v7,
           0xFFFFLL,
           v10,
           v9);
}
// 481BF0: using guessed type int dword_481BF0[16];

//----- (000000000041AC20) ----------------------------------------------------
__int64 __fastcall _strcmp_avx2(unsigned __int64 _RDI, __int64 _RSI)
{
  int v5; // eax
  __int64 result; // rax
  unsigned __int64 v29; // rdx
  bool v31; // zf
  unsigned __int64 v57; // rcx
  __int64 v76; // r8
  int v78; // eax
  int v79; // ecx
  __int64 v80; // rdi
  __int64 v81; // rsi

  _RDX = 0LL;
  __asm { vpxor   ymm7, ymm7, ymm7 }
  v5 = ((unsigned __int16)_RSI | (unsigned __int16)_RDI) & 0xFFF;
  if ( (unsigned int)v5 <= 0xF80 )
  {
    __asm
    {
      vmovdqu ymm1, ymmword ptr [rdi]
      vpcmpeqb ymm0, ymm1, ymmword ptr [rsi]
      vpminub ymm0, ymm0, ymm1
      vpcmpeqb ymm0, ymm0, ymm7
      vpmovmskb ecx, ymm0
    }
    if ( _ECX )
    {
      __asm { tzcnt   edx, ecx }
      result = *(unsigned __int8 *)(_RDI + _RDX) - (unsigned int)*(unsigned __int8 *)(_RSI + _RDX);
      __asm { vzeroupper }
    }
    else
    {
      __asm
      {
        vmovdqu ymm6, ymmword ptr [rdi+20h]
        vpcmpeqb ymm3, ymm6, ymmword ptr [rsi+20h]
        vpminub ymm3, ymm3, ymm6
        vpcmpeqb ymm3, ymm3, ymm7
        vpmovmskb ecx, ymm3
      }
      if ( _ECX )
      {
        __asm { tzcnt   edx, ecx }
        result = *(unsigned __int8 *)(_RDI + _RDX + 32) - (unsigned int)*(unsigned __int8 *)(_RSI + _RDX + 32);
        __asm { vzeroupper }
      }
      else
      {
        __asm
        {
          vmovdqu ymm5, ymmword ptr [rdi+40h]
          vmovdqu ymm4, ymmword ptr [rdi+60h]
          vmovdqu ymm0, ymmword ptr [rsi+60h]
          vpcmpeqb ymm2, ymm5, ymmword ptr [rsi+40h]
          vpminub ymm2, ymm2, ymm5
          vpcmpeqb ymm0, ymm0, ymm4
          vpcmpeqb ymm2, ymm2, ymm7
          vpmovmskb ecx, ymm2
        }
        if ( _ECX )
        {
          __asm { tzcnt   edx, ecx }
          result = *(unsigned __int8 *)(_RDI + _RDX + 64) - (unsigned int)*(unsigned __int8 *)(_RSI + _RDX + 64);
          __asm { vzeroupper }
        }
        else
        {
          __asm
          {
            vpminub ymm0, ymm0, ymm4
            vpcmpeqb ymm0, ymm0, ymm7
            vpmovmskb ecx, ymm0
          }
          if ( _ECX )
          {
            __asm { tzcnt   edx, ecx }
            result = *(unsigned __int8 *)(_RDI + _RDX + 96) - (unsigned int)*(unsigned __int8 *)(_RSI + _RDX + 96);
            __asm { vzeroupper }
          }
          else
          {
LABEL_10:
            _RAX = (_RDI + 128) & 0xFFFFFFFFFFFFFF80LL;
            v29 = _RSI + _RAX - _RDI;
            _RCX = (4096 - (unsigned __int64)(((_WORD)_RSI + (((_WORD)_RDI + 128) & 0xFF80) - (_WORD)_RDI) & 0xFFF)) >> 7;
            LODWORD(_RSI) = _RCX;
            while ( 1 )
            {
              v31 = (_DWORD)_RSI == 0;
              _RSI = (unsigned int)(_RSI - 1);
              if ( v31 )
              {
                v57 = v29 & 0x7F;
                _R10 = -(__int64)v57;
                if ( (v29 & 0x7F) < 0x40 )
                {
                  __asm
                  {
                    vmovdqu ymm2, ymmword ptr [rax+r10]
                    vmovdqu ymm3, ymmword ptr [rax+r10+20h]
                    vpcmpeqb ymm0, ymm2, ymmword ptr [rdx+r10]
                    vpcmpeqb ymm1, ymm3, ymmword ptr [rdx+r10+20h]
                    vpminub ymm0, ymm0, ymm2
                    vpminub ymm1, ymm1, ymm3
                    vpcmpeqb ymm0, ymm0, ymm7
                    vpcmpeqb ymm1, ymm1, ymm7
                    vpmovmskb edi, ymm0
                    vpmovmskb esi, ymm1
                  }
                  _RSI <<= 32;
                  _RDI = (_RSI ^ _RDI) >> v57;
                  if ( _RDI )
                  {
                    __asm { tzcnt   rcx, rdi }
                    result = *(unsigned __int8 *)(_RAX + _RCX) - (unsigned int)*(unsigned __int8 *)(v29 + _RCX);
                    __asm { vzeroupper }
                    return result;
                  }
                }
                __asm
                {
                  vmovdqu ymm2, ymmword ptr [rax+r10+40h]
                  vmovdqu ymm3, ymmword ptr [rax+r10+60h]
                  vpcmpeqb ymm5, ymm2, ymmword ptr [rdx+r10+40h]
                  vpminub ymm5, ymm5, ymm2
                  vpcmpeqb ymm6, ymm3, ymmword ptr [rdx+r10+60h]
                  vpcmpeqb ymm5, ymm5, ymm7
                  vpminub ymm6, ymm6, ymm3
                  vpcmpeqb ymm6, ymm6, ymm7
                  vpmovmskb edi, ymm5
                  vpmovmskb esi, ymm6
                }
                _RDI ^= _RSI << 32;
                v76 = 0LL;
                _RCX = (unsigned int)(v57 - 64);
                if ( (v29 & 0x7F) > 0x40 )
                {
                  _RDI >>= _RCX;
                  v76 = (unsigned int)_RCX;
                }
                LODWORD(_RSI) = 31;
                if ( _RDI )
                {
                  __asm { tzcnt   rcx, rdi }
                  result = *(unsigned __int8 *)(_RAX + v76 + _R10 + _RCX + 64)
                         - (unsigned int)*(unsigned __int8 *)(v29 + v76 + _R10 + _RCX + 64);
                  __asm { vzeroupper }
                  return result;
                }
              }
              __asm
              {
                vmovdqa ymm0, ymmword ptr [rax]
                vmovdqa ymm3, ymmword ptr [rax+20h]
                vpcmpeqb ymm4, ymm0, ymmword ptr [rdx]
                vpcmpeqb ymm1, ymm3, ymmword ptr [rdx+20h]
                vpminub ymm4, ymm4, ymm0
                vpminub ymm1, ymm1, ymm3
                vmovdqa ymm2, ymmword ptr [rax+40h]
                vpminub ymm0, ymm4, ymm1
                vmovdqa ymm3, ymmword ptr [rax+60h]
                vpcmpeqb ymm5, ymm2, ymmword ptr [rdx+40h]
                vpcmpeqb ymm6, ymm3, ymmword ptr [rdx+60h]
                vpminub ymm5, ymm5, ymm2
                vpminub ymm6, ymm6, ymm3
                vpminub ymm0, ymm0, ymm5
                vpminub ymm0, ymm0, ymm6
                vpcmpeqb ymm0, ymm0, ymm7
                vpmovmskb ecx, ymm0
              }
              if ( _ECX )
                break;
              _RAX += 128LL;
              v29 += 128LL;
            }
            __asm
            {
              vpcmpeqb ymm0, ymm4, ymm7
              vpmovmskb edi, ymm0
            }
            if ( _EDI )
            {
              __asm { tzcnt   ecx, edi }
              result = *(unsigned __int8 *)(_RAX + _RCX) - (unsigned int)*(unsigned __int8 *)(v29 + _RCX);
              __asm { vzeroupper }
            }
            else
            {
              __asm
              {
                vpcmpeqb ymm1, ymm1, ymm7
                vpmovmskb ecx, ymm1
              }
              if ( _ECX )
              {
                __asm { tzcnt   edi, ecx }
                result = *(unsigned __int8 *)(_RAX + _RDI + 32) - (unsigned int)*(unsigned __int8 *)(v29 + _RDI + 32);
                __asm { vzeroupper }
              }
              else
              {
                __asm
                {
                  vpcmpeqb ymm5, ymm5, ymm7
                  vpmovmskb ecx, ymm5
                }
                if ( _ECX )
                {
                  __asm { tzcnt   edi, ecx }
                  result = *(unsigned __int8 *)(_RAX + _RDI + 64) - (unsigned int)*(unsigned __int8 *)(v29 + _RDI + 64);
                  __asm { vzeroupper }
                }
                else
                {
                  __asm
                  {
                    vpcmpeqb ymm6, ymm6, ymm7
                    vpmovmskb esi, ymm6
                    tzcnt   ecx, esi
                  }
                  result = *(unsigned __int8 *)(_RAX + _RCX + 96) - (unsigned int)*(unsigned __int8 *)(v29 + _RCX + 96);
                  __asm { vzeroupper }
                }
              }
            }
          }
        }
      }
    }
    return result;
  }
  if ( (((unsigned __int16)_RSI | (unsigned __int16)_RDI) & 0xFFFu) <= 0xFE0 )
  {
    do
    {
      __asm
      {
        vmovdqu ymm1, ymmword ptr [rdi+rdx]
        vpcmpeqb ymm0, ymm1, ymmword ptr [rsi+rdx]
        vpminub ymm0, ymm0, ymm1
        vpcmpeqb ymm0, ymm0, ymm7
        vpmovmskb ecx, ymm0
      }
      if ( _ECX )
        goto LABEL_33;
      _RDX = (unsigned int)(_RDX + 32);
      v5 += 32;
    }
    while ( v5 <= 4064 );
  }
  if ( v5 <= 4080 )
  {
    __asm
    {
      vmovdqu xmm1, xmmword ptr [rdi+rdx]
      vpcmpeqb xmm0, xmm1, xmmword ptr [rsi+rdx]
      vpminub xmm0, xmm0, xmm1
      vpcmpeqb xmm0, xmm0, xmm7
      vpmovmskb ecx, xmm0
    }
    if ( _ECX )
      goto LABEL_33;
    _RDX = (unsigned int)(_RDX + 16);
    v5 += 16;
  }
  if ( v5 <= 4088 )
  {
    __asm
    {
      vmovq   xmm1, qword ptr [rdi+rdx]
      vmovq   xmm0, qword ptr [rsi+rdx]
      vpcmpeqb xmm0, xmm1, xmm0
      vpminub xmm0, xmm0, xmm1
      vpcmpeqb xmm0, xmm0, xmm7
      vpmovmskb ecx, xmm0
    }
    _ECX = (unsigned __int8)_ECX;
    if ( (_BYTE)_ECX )
      goto LABEL_33;
    _RDX = (unsigned int)(_RDX + 8);
    v5 += 8;
  }
  if ( v5 > 4092 )
    goto LABEL_46;
  __asm
  {
    vmovd   xmm1, dword ptr [rdi+rdx]
    vmovd   xmm0, dword ptr [rsi+rdx]
    vpcmpeqb xmm0, xmm1, xmm0
    vpminub xmm0, xmm0, xmm1
    vpcmpeqb xmm0, xmm0, xmm7
    vpmovmskb ecx, xmm0
  }
  _ECX = _ECX & 0xF;
  if ( _ECX )
  {
LABEL_33:
    v80 = _RDX + _RDI;
    v81 = _RDX + _RSI;
    __asm { tzcnt   edx, ecx }
    result = *(unsigned __int8 *)(v80 + _RDX) - (unsigned int)*(unsigned __int8 *)(v81 + _RDX);
    __asm { vzeroupper }
    return result;
  }
  _RDX = (unsigned int)(_RDX + 4);
LABEL_46:
  v78 = *(unsigned __int8 *)(_RDI + _RDX);
  v79 = *(unsigned __int8 *)(_RSI + _RDX);
  if ( *(_BYTE *)(_RDI + _RDX) )
  {
    while ( 1 )
    {
      result = (unsigned int)(v78 - v79);
      if ( (_DWORD)result )
        break;
      _RDX = (unsigned int)(_RDX + 1);
      if ( (_DWORD)_RDX == 128 )
        goto LABEL_10;
      v78 = *(unsigned __int8 *)(_RDI + _RDX);
      v79 = *(unsigned __int8 *)(_RSI + _RDX);
      if ( !*(_BYTE *)(_RDI + _RDX) )
      {
        result = (unsigned int)(v78 - v79);
        break;
      }
    }
    __asm { vzeroupper }
  }
  else
  {
    result = (unsigned int)(v78 - v79);
    __asm { vzeroupper }
  }
  return result;
}

//----- (000000000041B060) ----------------------------------------------------
__int64 __fastcall _strncmp_sse2(__int64 *a1, __int64 *a2, unsigned __int64 a3)
{
  unsigned __int64 v3; // r11
  unsigned int v4; // ecx
  unsigned int v5; // eax
  __m128i v6; // xmm1
  __m128i v7; // xmm2
  unsigned __int64 v8; // rdx
  bool v9; // cc
  const __m128i *v10; // rsi
  __m128i *v11; // rdi
  __int64 v12; // r8
  __int64 v13; // rcx
  __int64 v14; // rax
  unsigned int v15; // et0
  __m128i *v16; // rt1
  __m128i si128; // xmm1
  __m128i v19; // xmm0
  __m128i v20; // xmm1
  __m128i v21; // xmm0
  __m128i v22; // xmm1

  if ( !a3 )
    return 0LL;
  if ( a3 == 1 )
    return *(unsigned __int8 *)a1 - (unsigned int)*(unsigned __int8 *)a2;
  v3 = a3;
  v4 = (unsigned __int8)a2 & 0x3F;
  v5 = (unsigned __int8)a1 & 0x3F;
  if ( v4 <= 0x30 && v5 <= 0x30 )
  {
    v6.m128i_i64[0] = *a1;
    v7.m128i_i64[0] = *a2;
    v6.m128i_i64[1] = a1[1];
    v7.m128i_i64[1] = a2[1];
    v8 = (unsigned int)(_mm_movemask_epi8(_mm_sub_epi8(_mm_cmpeq_epi8(v6, v7), _mm_cmpeq_epi8((__m128i)0LL, v6)))
                      - 0xFFFF);
    if ( (_DWORD)v8 )
      goto LABEL_23;
    v9 = v3 <= 0x10;
    v3 -= 16LL;
    if ( v9 )
      return 0LL;
    a2 += 2;
    a1 += 2;
  }
  v10 = (const __m128i *)((unsigned __int64)a2 & 0xFFFFFFFFFFFFFFF0LL);
  v11 = (__m128i *)((unsigned __int64)a1 & 0xFFFFFFFFFFFFFFF0LL);
  v12 = 0LL;
  v13 = v4 & 0xF;
  v14 = v5 & 0xF;
  if ( (_DWORD)v13 == (_DWORD)v14 )
  {
    si128 = _mm_load_si128(v10);
    v8 = (0xFFFFu >> v13)
       - ((unsigned int)_mm_movemask_epi8(_mm_sub_epi8(_mm_cmpeq_epi8(si128, *v11), _mm_cmpeq_epi8((__m128i)0LL, si128))) >> v13);
    if ( (_DWORD)v8 )
    {
LABEL_22:
      a1 = (__int64 *)((char *)v11->m128i_i64 + v14);
      a2 = (__int64 *)((char *)v10->m128i_i64 + v13);
LABEL_23:
      _BitScanForward64(&v8, v8);
      if ( v3 > v8 )
        return *((unsigned __int8 *)a1 + v8) - (unsigned int)*((unsigned __int8 *)a2 + v8);
      return 0LL;
    }
    if ( v3 >= v13 + v3 - 16 && v13 + v3 != 16 )
    {
      v3 = v13 + v3 - 16;
      v13 = 16LL;
      v19 = 0LL;
      while ( 1 )
      {
        v20 = _mm_load_si128((const __m128i *)((char *)v10 + v13));
        v21 = _mm_cmpeq_epi8(v19, v20);
        v8 = (unsigned int)(_mm_movemask_epi8(_mm_sub_epi8(_mm_cmpeq_epi8(v20, _mm_load_si128((__m128i *)((char *)v11 + v13))), v21))
                          - 0xFFFF);
        if ( (_DWORD)v8 )
          break;
        v9 = v3 <= 0x10;
        v3 -= 16LL;
        if ( v9 )
          return 0LL;
        v13 += 16LL;
        v22 = _mm_load_si128((const __m128i *)((char *)v10 + v13));
        v19 = _mm_cmpeq_epi8(v21, v22);
        v8 = (unsigned int)(_mm_movemask_epi8(_mm_sub_epi8(_mm_cmpeq_epi8(v22, _mm_load_si128((__m128i *)((char *)v11 + v13))), v19))
                          - 0xFFFF);
        if ( (_DWORD)v8 )
          break;
        v9 = v3 <= 0x10;
        v3 -= 16LL;
        if ( v9 )
          return 0LL;
        v13 += 16LL;
      }
      v14 = v13;
      goto LABEL_22;
    }
    return 0LL;
  }
  if ( (unsigned int)v13 <= (unsigned int)v14 )
  {
    v12 = 0xFFFFLL;
    v15 = v14;
    v14 = (unsigned int)v13;
    v13 = v15;
    v16 = (__m128i *)v10;
    v10 = v11;
    v11 = v16;
  }
  return ((__int64 (__fastcall *)(__m128i *, const __m128i *, __int64, __int64, __int64))((char *)dword_481C30
                                                                                        + dword_481C30[v14 + 15 - v13]))(
           v11,
           v10,
           0xFFFFLL,
           v13,
           v12);
}
// 481C30: using guessed type int dword_481C30[16];

//----- (000000000041C8C0) ----------------------------------------------------
__int64 __fastcall _strncmp_ssse3(__int64 *a1, __int64 *a2, unsigned __int64 a3)
{
  unsigned __int64 v3; // r11
  unsigned int v4; // ecx
  unsigned int v5; // eax
  __m128i v6; // xmm1
  __m128i v7; // xmm2
  unsigned __int64 v8; // rdx
  bool v9; // cc
  const __m128i *v10; // rsi
  __m128i *v11; // rdi
  __int64 v12; // r8
  __int64 v13; // rcx
  __int64 v14; // rax
  unsigned int v15; // et0
  __m128i *v16; // rt1
  __m128i si128; // xmm1
  __m128i v19; // xmm0
  __m128i v20; // xmm1
  __m128i v21; // xmm0
  __m128i v22; // xmm1

  if ( !a3 )
    return 0LL;
  if ( a3 == 1 )
    return *(unsigned __int8 *)a1 - (unsigned int)*(unsigned __int8 *)a2;
  v3 = a3;
  v4 = (unsigned __int8)a2 & 0x3F;
  v5 = (unsigned __int8)a1 & 0x3F;
  if ( v4 <= 0x30 && v5 <= 0x30 )
  {
    v6.m128i_i64[0] = *a1;
    v7.m128i_i64[0] = *a2;
    v6.m128i_i64[1] = a1[1];
    v7.m128i_i64[1] = a2[1];
    v8 = (unsigned int)(_mm_movemask_epi8(_mm_sub_epi8(_mm_cmpeq_epi8(v6, v7), _mm_cmpeq_epi8((__m128i)0LL, v6)))
                      - 0xFFFF);
    if ( (_DWORD)v8 )
      goto LABEL_23;
    v9 = v3 <= 0x10;
    v3 -= 16LL;
    if ( v9 )
      return 0LL;
    a2 += 2;
    a1 += 2;
  }
  v10 = (const __m128i *)((unsigned __int64)a2 & 0xFFFFFFFFFFFFFFF0LL);
  v11 = (__m128i *)((unsigned __int64)a1 & 0xFFFFFFFFFFFFFFF0LL);
  v12 = 0LL;
  v13 = v4 & 0xF;
  v14 = v5 & 0xF;
  if ( (_DWORD)v13 == (_DWORD)v14 )
  {
    si128 = _mm_load_si128(v10);
    v8 = (0xFFFFu >> v13)
       - ((unsigned int)_mm_movemask_epi8(_mm_sub_epi8(_mm_cmpeq_epi8(si128, *v11), _mm_cmpeq_epi8((__m128i)0LL, si128))) >> v13);
    if ( (_DWORD)v8 )
    {
LABEL_22:
      a1 = (__int64 *)((char *)v11->m128i_i64 + v14);
      a2 = (__int64 *)((char *)v10->m128i_i64 + v13);
LABEL_23:
      _BitScanForward64(&v8, v8);
      if ( v3 > v8 )
        return *((unsigned __int8 *)a1 + v8) - (unsigned int)*((unsigned __int8 *)a2 + v8);
      return 0LL;
    }
    if ( v3 >= v13 + v3 - 16 && v13 + v3 != 16 )
    {
      v3 = v13 + v3 - 16;
      v13 = 16LL;
      v19 = 0LL;
      while ( 1 )
      {
        v20 = _mm_load_si128((const __m128i *)((char *)v10 + v13));
        v21 = _mm_cmpeq_epi8(v19, v20);
        v8 = (unsigned int)(_mm_movemask_epi8(_mm_sub_epi8(_mm_cmpeq_epi8(v20, _mm_load_si128((__m128i *)((char *)v11 + v13))), v21))
                          - 0xFFFF);
        if ( (_DWORD)v8 )
          break;
        v9 = v3 <= 0x10;
        v3 -= 16LL;
        if ( v9 )
          return 0LL;
        v13 += 16LL;
        v22 = _mm_load_si128((const __m128i *)((char *)v10 + v13));
        v19 = _mm_cmpeq_epi8(v21, v22);
        v8 = (unsigned int)(_mm_movemask_epi8(_mm_sub_epi8(_mm_cmpeq_epi8(v22, _mm_load_si128((__m128i *)((char *)v11 + v13))), v19))
                          - 0xFFFF);
        if ( (_DWORD)v8 )
          break;
        v9 = v3 <= 0x10;
        v3 -= 16LL;
        if ( v9 )
          return 0LL;
        v13 += 16LL;
      }
      v14 = v13;
      goto LABEL_22;
    }
    return 0LL;
  }
  if ( (unsigned int)v13 <= (unsigned int)v14 )
  {
    v12 = 0xFFFFLL;
    v15 = v14;
    v14 = (unsigned int)v13;
    v13 = v15;
    v16 = (__m128i *)v10;
    v10 = v11;
    v11 = v16;
  }
  return ((__int64 (__fastcall *)(__m128i *, const __m128i *, __int64, __int64, __int64))((char *)dword_481C70
                                                                                        + dword_481C70[v14 + 15 - v13]))(
           v11,
           v10,
           0xFFFFLL,
           v13,
           v12);
}
// 481C70: using guessed type int dword_481C70[16];

//----- (000000000041E030) ----------------------------------------------------
__int64 __fastcall _strncmp_sse42(const __m128i *a1, const __m128i *a2, unsigned __int64 a3)
{
  unsigned __int64 v3; // r11
  unsigned int v4; // ecx
  unsigned int v5; // eax
  __m128i v6; // xmm1
  unsigned __int64 v7; // rdx
  char v8; // cc
  const __m128i *v9; // rsi
  const __m128i *v10; // rdi
  __int64 v11; // r8
  __int64 v12; // rcx
  __int64 v13; // rax
  unsigned int v14; // et0
  const __m128i *v15; // rt1
  __m128i v16; // xmm1
  __m128i si128; // xmm1
  unsigned __int64 v19; // r11
  __int64 v20; // rdx
  __m128i v21; // xmm0
  unsigned __int8 v22; // cf
  unsigned __int64 v23; // rcx
  __m128i v24; // xmm0

  if ( !a3 )
    return 0LL;
  if ( a3 == 1 )
    return a1->m128i_u8[0] - (unsigned int)a2->m128i_u8[0];
  v3 = a3;
  v4 = (unsigned __int8)a2 & 0x3F;
  v5 = (unsigned __int8)a1 & 0x3F;
  if ( v4 <= 0x30 && v5 <= 0x30 )
  {
    v6 = _mm_loadu_si128(a1);
    v7 = (unsigned int)(_mm_movemask_epi8(_mm_sub_epi8(_mm_cmpeq_epi8(v6, _mm_loadu_si128(a2)), _mm_cmpeq_epi8((__m128i)0LL, v6)))
                      - 0xFFFF);
    if ( (_DWORD)v7 )
      goto LABEL_25;
    v8 = v3 <= 0x10;
    v3 -= 16LL;
    if ( !v8 )
    {
      ++a2;
      ++a1;
      goto LABEL_8;
    }
    return 0LL;
  }
LABEL_8:
  v9 = (const __m128i *)((unsigned __int64)a2 & 0xFFFFFFFFFFFFFFF0LL);
  v10 = (const __m128i *)((unsigned __int64)a1 & 0xFFFFFFFFFFFFFFF0LL);
  v11 = 0LL;
  v12 = v4 & 0xF;
  v13 = v5 & 0xF;
  if ( (_DWORD)v12 == (_DWORD)v13 )
  {
    si128 = _mm_load_si128(v9);
    v7 = (0xFFFFu >> v12)
       - ((unsigned int)_mm_movemask_epi8(_mm_sub_epi8(_mm_cmpeq_epi8(si128, *v10), _mm_cmpeq_epi8((__m128i)0LL, si128))) >> v12);
    if ( !(_DWORD)v7 )
    {
      if ( v3 >= v12 + v3 - 16 && v12 + v3 != 16 )
      {
        v19 = v12 + v3 - 16;
        v20 = 1LL;
        while ( 1 )
        {
          v21 = _mm_load_si128(&v10[v20]);
          v23 = (unsigned int)_mm_cmpistri(v21, v9[v20], 26);
          v22 = _mm_cmpistrc(v21, v9[v20], 26);
          v8 = v22 | _mm_cmpistrz(v21, v9[v20++], 26);
          if ( v8 )
            break;
          v8 = v19 <= 0x10;
          v19 -= 16LL;
          if ( v8 )
            return 0LL;
          v24 = _mm_load_si128(&v10[v20]);
          v23 = (unsigned int)_mm_cmpistri(v24, v9[v20], 26);
          v22 = _mm_cmpistrc(v24, v9[v20], 26);
          v8 = v22 | _mm_cmpistrz(v24, v9[v20++], 26);
          if ( v8 )
            break;
          v8 = v19 <= 0x10;
          v19 -= 16LL;
          if ( v8 )
            return 0LL;
        }
        if ( v22 && v19 > v23 )
          return v10[v20 - 1].m128i_u8[v23] - (unsigned int)v9[v20 - 1].m128i_u8[v23];
      }
      return 0LL;
    }
    a1 = (const __m128i *)((char *)v10 + v13);
    a2 = (const __m128i *)((char *)v9 + v12);
LABEL_25:
    _BitScanForward64(&v7, v7);
    if ( v3 > v7 )
      return a1->m128i_u8[v7] - (unsigned int)a2->m128i_u8[v7];
    return 0LL;
  }
  if ( (unsigned int)v12 <= (unsigned int)v13 )
  {
    v11 = 0xFFFFLL;
    v14 = v13;
    v13 = (unsigned int)v12;
    v12 = v14;
    v15 = v9;
    v9 = v10;
    v10 = v15;
  }
  v16 = _mm_load_si128(v9);
  return ((__int64 (__fastcall *)(const __m128i *, const __m128i *, __int64, __int64, __int64, double, double, double))((char *)dword_481CB0 + dword_481CB0[v13 + 15 - v12]))(
           v10,
           v9,
           0xFFFFLL,
           v12,
           v11,
           *(double *)_mm_cmpeq_epi8((__m128i)0LL, v16).m128i_i64,
           *(double *)v16.m128i_i64,
           *(double *)_mm_load_si128(v10).m128i_i64);
}
// 481CB0: using guessed type int dword_481CB0[16];

//----- (000000000041F010) ----------------------------------------------------
__int64 __fastcall _strncmp_avx2(unsigned __int64 _RDI, unsigned __int64 _RSI, unsigned __int64 a3)
{
  int v7; // eax
  __int64 result; // rax
  unsigned __int64 v14; // rdx
  unsigned __int64 v15; // rdx
  unsigned __int64 v16; // rdx
  unsigned __int64 v33; // rdx
  bool v35; // cc
  unsigned __int64 v36; // r11
  unsigned __int64 v37; // rdx
  bool v39; // zf
  unsigned __int64 v61; // rdi
  unsigned __int64 v64; // rdi
  unsigned __int64 v67; // rcx
  unsigned __int64 v68; // rcx
  __int64 v87; // r8
  unsigned __int64 v89; // rcx
  int v90; // eax
  int v91; // ecx
  unsigned __int64 v92; // rdi
  unsigned __int64 v93; // rsi
  unsigned __int64 v94; // r11

  if ( a3 == 1 )
  {
    result = *(unsigned __int8 *)_RDI - (unsigned int)*(unsigned __int8 *)_RSI;
    __asm { vzeroupper }
    return result;
  }
  if ( !a3 )
    goto LABEL_51;
  _RDX = 0LL;
  __asm { vpxor   ymm7, ymm7, ymm7 }
  v7 = ((unsigned __int16)_RSI | (unsigned __int16)_RDI) & 0xFFF;
  if ( (unsigned int)v7 <= 0xF80 )
  {
    __asm
    {
      vmovdqu ymm1, ymmword ptr [rdi]
      vpcmpeqb ymm0, ymm1, ymmword ptr [rsi]
      vpminub ymm0, ymm0, ymm1
      vpcmpeqb ymm0, ymm0, ymm7
      vpmovmskb ecx, ymm0
    }
    if ( _ECX )
    {
      __asm { tzcnt   edx, ecx }
      if ( _RDX < a3 )
      {
        result = *(unsigned __int8 *)(_RDI + _RDX) - (unsigned int)*(unsigned __int8 *)(_RSI + _RDX);
        __asm { vzeroupper }
        return result;
      }
    }
    else
    {
      __asm
      {
        vmovdqu ymm6, ymmword ptr [rdi+20h]
        vpcmpeqb ymm3, ymm6, ymmword ptr [rsi+20h]
        vpminub ymm3, ymm3, ymm6
        vpcmpeqb ymm3, ymm3, ymm7
        vpmovmskb ecx, ymm3
      }
      if ( _ECX )
      {
        __asm { tzcnt   edx, ecx }
        v14 = _RDX + 32;
        if ( v14 < a3 )
        {
          result = *(unsigned __int8 *)(_RDI + v14) - (unsigned int)*(unsigned __int8 *)(_RSI + v14);
          __asm { vzeroupper }
          return result;
        }
      }
      else
      {
        __asm
        {
          vmovdqu ymm5, ymmword ptr [rdi+40h]
          vmovdqu ymm4, ymmword ptr [rdi+60h]
          vmovdqu ymm0, ymmword ptr [rsi+60h]
          vpcmpeqb ymm2, ymm5, ymmword ptr [rsi+40h]
          vpminub ymm2, ymm2, ymm5
          vpcmpeqb ymm0, ymm0, ymm4
          vpcmpeqb ymm2, ymm2, ymm7
          vpmovmskb ecx, ymm2
        }
        if ( _ECX )
        {
          __asm { tzcnt   edx, ecx }
          v15 = _RDX + 64;
          if ( v15 < a3 )
          {
            result = *(unsigned __int8 *)(_RDI + v15) - (unsigned int)*(unsigned __int8 *)(_RSI + v15);
            __asm { vzeroupper }
            return result;
          }
        }
        else
        {
          __asm
          {
            vpminub ymm0, ymm0, ymm4
            vpcmpeqb ymm0, ymm0, ymm7
            vpmovmskb ecx, ymm0
          }
          if ( _ECX )
          {
            __asm { tzcnt   edx, ecx }
            v16 = _RDX + 96;
            if ( v16 < a3 )
            {
              result = *(unsigned __int8 *)(_RDI + v16) - (unsigned int)*(unsigned __int8 *)(_RSI + v16);
              __asm { vzeroupper }
              return result;
            }
          }
          else
          {
LABEL_16:
            v33 = ((_RDI + 128) & 0xFFFFFFFFFFFFFF80LL) - _RDI;
            _RAX = (_RDI + 128) & 0xFFFFFFFFFFFFFF80LL;
            v35 = a3 <= v33;
            v36 = a3 - v33;
            if ( !v35 )
            {
              v37 = _RSI + v33;
              _RCX = (4096 - (v37 & 0xFFF)) >> 7;
              LODWORD(_RSI) = _RCX;
              while ( 1 )
              {
                v39 = (_DWORD)_RSI == 0;
                _RSI = (unsigned int)(_RSI - 1);
                if ( v39 )
                {
                  v68 = v37 & 0x7F;
                  _R10 = -(__int64)v68;
                  if ( (v37 & 0x7F) < 0x40 )
                  {
                    __asm
                    {
                      vmovdqu ymm2, ymmword ptr [rax+r10]
                      vmovdqu ymm3, ymmword ptr [rax+r10+20h]
                      vpcmpeqb ymm0, ymm2, ymmword ptr [rdx+r10]
                      vpcmpeqb ymm1, ymm3, ymmword ptr [rdx+r10+20h]
                      vpminub ymm0, ymm0, ymm2
                      vpminub ymm1, ymm1, ymm3
                      vpcmpeqb ymm0, ymm0, ymm7
                      vpcmpeqb ymm1, ymm1, ymm7
                      vpmovmskb edi, ymm0
                      vpmovmskb esi, ymm1
                    }
                    _RSI <<= 32;
                    _RDI = (_RSI ^ _RDI) >> v68;
                    if ( _RDI )
                    {
                      __asm { tzcnt   rcx, rdi }
                      if ( v36 <= _RCX )
                        goto LABEL_51;
                      result = *(unsigned __int8 *)(_RAX + _RCX) - (unsigned int)*(unsigned __int8 *)(v37 + _RCX);
                      __asm { vzeroupper }
                      return result;
                    }
                  }
                  __asm
                  {
                    vmovdqu ymm2, ymmword ptr [rax+r10+40h]
                    vmovdqu ymm3, ymmword ptr [rax+r10+60h]
                    vpcmpeqb ymm5, ymm2, ymmword ptr [rdx+r10+40h]
                    vpminub ymm5, ymm5, ymm2
                    vpcmpeqb ymm6, ymm3, ymmword ptr [rdx+r10+60h]
                    vpcmpeqb ymm5, ymm5, ymm7
                    vpminub ymm6, ymm6, ymm3
                    vpcmpeqb ymm6, ymm6, ymm7
                    vpmovmskb edi, ymm5
                    vpmovmskb esi, ymm6
                  }
                  _RDI ^= _RSI << 32;
                  v87 = 0LL;
                  _RCX = (unsigned int)(v68 - 64);
                  if ( (v37 & 0x7F) > 0x40 )
                  {
                    _RDI >>= _RCX;
                    v87 = (unsigned int)_RCX;
                  }
                  LODWORD(_RSI) = 31;
                  if ( _RDI )
                  {
                    __asm { tzcnt   rcx, rdi }
                    v89 = v87 + _R10 + _RCX + 64;
                    if ( v36 <= v89 )
                      goto LABEL_51;
                    result = *(unsigned __int8 *)(_RAX + v89) - (unsigned int)*(unsigned __int8 *)(v37 + v89);
                    __asm { vzeroupper }
                    return result;
                  }
                }
                __asm
                {
                  vmovdqa ymm0, ymmword ptr [rax]
                  vmovdqa ymm3, ymmword ptr [rax+20h]
                  vpcmpeqb ymm4, ymm0, ymmword ptr [rdx]
                  vpcmpeqb ymm1, ymm3, ymmword ptr [rdx+20h]
                  vpminub ymm4, ymm4, ymm0
                  vpminub ymm1, ymm1, ymm3
                  vmovdqa ymm2, ymmword ptr [rax+40h]
                  vpminub ymm0, ymm4, ymm1
                  vmovdqa ymm3, ymmword ptr [rax+60h]
                  vpcmpeqb ymm5, ymm2, ymmword ptr [rdx+40h]
                  vpcmpeqb ymm6, ymm3, ymmword ptr [rdx+60h]
                  vpminub ymm5, ymm5, ymm2
                  vpminub ymm6, ymm6, ymm3
                  vpminub ymm0, ymm0, ymm5
                  vpminub ymm0, ymm0, ymm6
                  vpcmpeqb ymm0, ymm0, ymm7
                  vpmovmskb ecx, ymm0
                }
                if ( _ECX )
                  break;
                v35 = v36 <= 0x80;
                v36 -= 128LL;
                if ( v35 )
                  goto LABEL_51;
                _RAX += 128LL;
                v37 += 128LL;
              }
              __asm
              {
                vpcmpeqb ymm0, ymm4, ymm7
                vpmovmskb edi, ymm0
              }
              if ( _EDI )
              {
                __asm { tzcnt   ecx, edi }
                if ( v36 <= _RCX )
                  goto LABEL_51;
                result = *(unsigned __int8 *)(_RAX + _RCX) - (unsigned int)*(unsigned __int8 *)(v37 + _RCX);
                __asm { vzeroupper }
                return result;
              }
              if ( v36 <= 0x20 )
                goto LABEL_51;
              __asm
              {
                vpcmpeqb ymm1, ymm1, ymm7
                vpmovmskb ecx, ymm1
              }
              if ( _ECX )
              {
                __asm { tzcnt   edi, ecx }
                v61 = _RDI + 32;
                if ( v36 <= v61 )
                  goto LABEL_51;
                result = *(unsigned __int8 *)(_RAX + v61) - (unsigned int)*(unsigned __int8 *)(v37 + v61);
                __asm { vzeroupper }
                return result;
              }
              if ( v36 <= 0x40 )
                goto LABEL_51;
              __asm
              {
                vpcmpeqb ymm5, ymm5, ymm7
                vpmovmskb ecx, ymm5
              }
              if ( _ECX )
              {
                __asm { tzcnt   edi, ecx }
                v64 = _RDI + 64;
                if ( v36 <= v64 )
                  goto LABEL_51;
                result = *(unsigned __int8 *)(_RAX + v64) - (unsigned int)*(unsigned __int8 *)(v37 + v64);
                __asm { vzeroupper }
                return result;
              }
              if ( v36 > 0x60 )
              {
                __asm
                {
                  vpcmpeqb ymm6, ymm6, ymm7
                  vpmovmskb esi, ymm6
                  tzcnt   ecx, esi
                }
                v67 = _RCX + 96;
                if ( v36 > v67 )
                {
                  result = *(unsigned __int8 *)(_RAX + v67) - (unsigned int)*(unsigned __int8 *)(v37 + v67);
                  __asm { vzeroupper }
                  return result;
                }
              }
            }
          }
        }
      }
    }
    goto LABEL_51;
  }
  if ( (((unsigned __int16)_RSI | (unsigned __int16)_RDI) & 0xFFFu) <= 0xFE0 )
  {
    while ( 1 )
    {
      __asm
      {
        vmovdqu ymm1, ymmword ptr [rdi+rdx]
        vpcmpeqb ymm0, ymm1, ymmword ptr [rsi+rdx]
        vpminub ymm0, ymm0, ymm1
        vpcmpeqb ymm0, ymm0, ymm7
        vpmovmskb ecx, ymm0
      }
      if ( _ECX )
        break;
      _RDX = (unsigned int)(_RDX + 32);
      v7 += 32;
      if ( _RDX >= a3 )
        goto LABEL_51;
      if ( v7 > 4064 )
        goto LABEL_59;
    }
LABEL_53:
    v92 = _RDX + _RDI;
    v93 = _RDX + _RSI;
    v94 = a3 - _RDX;
    __asm { tzcnt   edx, ecx }
    if ( _RDX < v94 )
    {
      result = *(unsigned __int8 *)(v92 + _RDX) - (unsigned int)*(unsigned __int8 *)(v93 + _RDX);
      __asm { vzeroupper }
      return result;
    }
LABEL_51:
    result = 0LL;
    __asm { vzeroupper }
    return result;
  }
LABEL_59:
  if ( v7 <= 4080 )
  {
    __asm
    {
      vmovdqu xmm1, xmmword ptr [rdi+rdx]
      vpcmpeqb xmm0, xmm1, xmmword ptr [rsi+rdx]
      vpminub xmm0, xmm0, xmm1
      vpcmpeqb xmm0, xmm0, xmm7
      vpmovmskb ecx, xmm0
    }
    if ( _ECX )
      goto LABEL_53;
    _RDX = (unsigned int)(_RDX + 16);
    v7 += 16;
    if ( _RDX >= a3 )
      goto LABEL_51;
  }
  if ( v7 <= 4088 )
  {
    __asm
    {
      vmovq   xmm1, qword ptr [rdi+rdx]
      vmovq   xmm0, qword ptr [rsi+rdx]
      vpcmpeqb xmm0, xmm1, xmm0
      vpminub xmm0, xmm0, xmm1
      vpcmpeqb xmm0, xmm0, xmm7
      vpmovmskb ecx, xmm0
    }
    _ECX = (unsigned __int8)_ECX;
    if ( (_BYTE)_ECX )
      goto LABEL_53;
    _RDX = (unsigned int)(_RDX + 8);
    v7 += 8;
    if ( _RDX >= a3 )
      goto LABEL_51;
  }
  if ( v7 <= 4092 )
  {
    __asm
    {
      vmovd   xmm1, dword ptr [rdi+rdx]
      vmovd   xmm0, dword ptr [rsi+rdx]
      vpcmpeqb xmm0, xmm1, xmm0
      vpminub xmm0, xmm0, xmm1
      vpcmpeqb xmm0, xmm0, xmm7
      vpmovmskb ecx, xmm0
    }
    _ECX = _ECX & 0xF;
    if ( _ECX )
      goto LABEL_53;
    _RDX = (unsigned int)(_RDX + 4);
    if ( _RDX >= a3 )
      goto LABEL_51;
  }
  if ( _RDX >= a3 )
    goto LABEL_51;
  v90 = *(unsigned __int8 *)(_RDI + _RDX);
  v91 = *(unsigned __int8 *)(_RSI + _RDX);
  if ( *(_BYTE *)(_RDI + _RDX) )
  {
    while ( 1 )
    {
      result = (unsigned int)(v90 - v91);
      if ( (_DWORD)result )
        break;
      _RDX = (unsigned int)(_RDX + 1);
      if ( (_DWORD)_RDX == 128 )
        goto LABEL_16;
      if ( _RDX >= a3 )
        goto LABEL_51;
      v90 = *(unsigned __int8 *)(_RDI + _RDX);
      v91 = *(unsigned __int8 *)(_RSI + _RDX);
      if ( !*(_BYTE *)(_RDI + _RDX) )
      {
        result = (unsigned int)(v90 - v91);
        break;
      }
    }
    __asm { vzeroupper }
  }
  else
  {
    result = (unsigned int)(v90 - v91);
    __asm { vzeroupper }
  }
  return result;
}

//----- (000000000041F530) ----------------------------------------------------
__int64 __fastcall _rawmemchr_sse2(const __m128i *a1, unsigned __int64 a2)
{
  __m128i v2; // xmm1
  __m128i v3; // xmm1
  __int64 v4; // rax
  __int64 v5; // rcx
  const __m128i *v6; // rdi
  __int64 v7; // rax
  __int64 v9; // rax
  __int64 v10; // rax
  __m128i v11; // xmm4
  __int64 v12; // rax
  __m128i v13; // xmm0
  __m128i v14; // xmm2
  int v15; // eax
  __m128i v16; // xmm3
  __m128i v17; // xmm1
  __int64 v18; // rax

  v2 = _mm_unpacklo_epi8((__m128i)a2, (__m128i)a2);
  v3 = _mm_shuffle_epi32(_mm_unpacklo_epi8(v2, v2), 0);
  if ( ((unsigned __int8)a1 & 0x3Fu) > 0x30uLL )
  {
    v5 = (unsigned __int8)a1 & 0xF;
    v6 = (const __m128i *)((unsigned __int64)a1 & 0xFFFFFFFFFFFFFFF0LL);
    LODWORD(v7) = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_load_si128(v6), v3)) >> v5;
    if ( (_DWORD)v7 )
    {
      _BitScanForward((unsigned int *)&v7, v7);
      return (__int64)v6 + v7 + v5;
    }
    a1 = v6 + 1;
  }
  else
  {
    LODWORD(v4) = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_loadu_si128(a1), v3));
    if ( (_DWORD)v4 )
      goto LABEL_23;
    a1 = (const __m128i *)((unsigned __int64)&a1[1] & 0xFFFFFFFFFFFFFFF0LL);
  }
  LODWORD(v4) = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_load_si128(a1), v3));
  if ( (_DWORD)v4 )
    goto LABEL_23;
  LODWORD(v9) = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_load_si128(a1 + 1), v3));
  if ( (_DWORD)v9 )
    goto LABEL_24;
  LODWORD(v10) = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_load_si128(a1 + 2), v3));
  if ( !(_DWORD)v10 )
  {
    v11 = _mm_cmpeq_epi8(_mm_load_si128(a1 + 3), v3);
    a1 += 4;
    LODWORD(v12) = _mm_movemask_epi8(v11);
    if ( (_DWORD)v12 )
      goto LABEL_22;
    if ( ((unsigned __int8)a1 & 0x3F) == 0 )
      goto LABEL_17;
    LODWORD(v4) = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_load_si128(a1), v3));
    if ( (_DWORD)v4 )
      goto LABEL_23;
    LODWORD(v9) = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_load_si128(a1 + 1), v3));
    if ( (_DWORD)v9 )
      goto LABEL_24;
    LODWORD(v10) = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_load_si128(a1 + 2), v3));
    if ( !(_DWORD)v10 )
    {
      LODWORD(v12) = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_load_si128(a1 + 3), v3));
      a1 += 4;
      if ( !(_DWORD)v12 )
      {
        a1 = (const __m128i *)((unsigned __int64)a1 & 0xFFFFFFFFFFFFFFC0LL);
        do
        {
LABEL_17:
          v13 = _mm_cmpeq_epi8(_mm_load_si128(a1), v3);
          v14 = _mm_cmpeq_epi8(_mm_load_si128(a1 + 1), v3);
          v15 = _mm_movemask_epi8(
                  _mm_max_epu8(
                    _mm_max_epu8(_mm_cmpeq_epi8(_mm_load_si128(a1 + 3), v3), v14),
                    _mm_max_epu8(_mm_cmpeq_epi8(_mm_load_si128(a1 + 2), v3), v13)));
          a1 += 4;
        }
        while ( !v15 );
        a1 -= 4;
        LODWORD(v4) = _mm_movemask_epi8(v13);
        if ( !(_DWORD)v4 )
        {
          LODWORD(v9) = _mm_movemask_epi8(v14);
          if ( !(_DWORD)v9 )
          {
            v16 = _mm_cmpeq_epi8(_mm_load_si128(a1 + 2), v3);
            v17 = _mm_cmpeq_epi8(v3, a1[3]);
            LODWORD(v10) = _mm_movemask_epi8(v16);
            if ( !(_DWORD)v10 )
            {
              _BitScanForward((unsigned int *)&v18, _mm_movemask_epi8(v17));
              return (__int64)&a1[3] + v18;
            }
            goto LABEL_25;
          }
LABEL_24:
          _BitScanForward((unsigned int *)&v9, v9);
          return (__int64)&a1[1] + v9;
        }
LABEL_23:
        _BitScanForward((unsigned int *)&v4, v4);
        return (__int64)a1 + v4;
      }
LABEL_22:
      _BitScanForward((unsigned int *)&v12, v12);
      return (__int64)&a1[-1] + v12;
    }
  }
LABEL_25:
  _BitScanForward((unsigned int *)&v10, v10);
  return (__int64)&a1[2] + v10;
}
// 41F59D: variable 'v7' is possibly undefined
// 41F6EC: variable 'v18' is possibly undefined
// 41F703: variable 'v12' is possibly undefined
// 41F713: variable 'v4' is possibly undefined
// 41F723: variable 'v9' is possibly undefined
// 41F733: variable 'v10' is possibly undefined

//----- (000000000041F740) ----------------------------------------------------
unsigned __int64 __fastcall _rawmemchr_avx2(unsigned __int64 i, int _ESI)
{
  unsigned __int64 v6; // rcx
  unsigned __int64 v7; // rdi
  unsigned __int64 result; // rax

  __asm
  {
    vmovd   xmm0, esi
    vpbroadcastb ymm0, xmm0
  }
  if ( (i & 0x3F) > 0x20 )
  {
    v6 = i & 0x1F;
    v7 = i & 0xFFFFFFFFFFFFFFE0LL;
    __asm
    {
      vpcmpeqb ymm1, ymm0, ymmword ptr [rdi]
      vpmovmskb eax, ymm1
    }
    _RAX = (unsigned int)(_EAX >> v6);
    if ( (_DWORD)_RAX )
    {
      __asm { tzcnt   eax, eax }
      result = v6 + v7 + _RAX;
      __asm { vzeroupper }
      return result;
    }
    i = v7 + 32;
  }
  else
  {
    __asm
    {
      vpcmpeqb ymm1, ymm0, ymmword ptr [rdi]
      vpmovmskb eax, ymm1
    }
    if ( (_DWORD)_RAX )
      goto LABEL_14;
    i = (i + 32) & 0xFFFFFFFFFFFFFFE0LL;
  }
  __asm
  {
    vpcmpeqb ymm1, ymm0, ymmword ptr [rdi]
    vpmovmskb eax, ymm1
  }
  if ( (_DWORD)_RAX )
    goto LABEL_14;
  __asm
  {
    vpcmpeqb ymm1, ymm0, ymmword ptr [rdi+20h]
    vpmovmskb eax, ymm1
  }
  if ( (_DWORD)_RAX )
    goto LABEL_15;
  __asm
  {
    vpcmpeqb ymm1, ymm0, ymmword ptr [rdi+40h]
    vpmovmskb eax, ymm1
  }
  if ( (_DWORD)_RAX )
    goto LABEL_16;
  __asm
  {
    vpcmpeqb ymm1, ymm0, ymmword ptr [rdi+60h]
    vpmovmskb eax, ymm1
  }
  if ( !(_DWORD)_RAX )
  {
    for ( i = (i + 128) & 0xFFFFFFFFFFFFFF80LL; ; i += 128LL )
    {
      __asm
      {
        vpcmpeqb ymm1, ymm0, ymmword ptr [rdi]
        vpcmpeqb ymm2, ymm0, ymmword ptr [rdi+20h]
        vpcmpeqb ymm3, ymm0, ymmword ptr [rdi+40h]
        vpcmpeqb ymm4, ymm0, ymmword ptr [rdi+60h]
        vpor    ymm5, ymm2, ymm1
        vpor    ymm6, ymm4, ymm3
        vpor    ymm5, ymm6, ymm5
        vpmovmskb eax, ymm5
      }
      if ( _EAX )
        break;
    }
    __asm { vpmovmskb eax, ymm1 }
    if ( !(_DWORD)_RAX )
    {
      __asm { vpmovmskb eax, ymm2 }
      if ( !(_DWORD)_RAX )
      {
        __asm { vpmovmskb eax, ymm3 }
        if ( !(_DWORD)_RAX )
        {
          __asm { vpmovmskb eax, ymm4 }
          goto LABEL_21;
        }
LABEL_16:
        __asm { tzcnt   eax, eax }
        result = i + _RAX + 64;
        __asm { vzeroupper }
        return result;
      }
LABEL_15:
      __asm { tzcnt   eax, eax }
      result = i + _RAX + 32;
      __asm { vzeroupper }
      return result;
    }
LABEL_14:
    __asm { tzcnt   eax, eax }
    result = i + _RAX;
    __asm { vzeroupper }
    return result;
  }
LABEL_21:
  __asm { tzcnt   eax, eax }
  result = i + _RAX + 96;
  __asm { vzeroupper }
  return result;
}
// 41F834: variable '_RAX' is possibly undefined

//----- (000000000041F890) ----------------------------------------------------
__int64 __fastcall _memcmp_sse2(const __m128i *a1, unsigned __int8 *a2, unsigned __int64 a3)
{
  signed __int64 v3; // rsi
  unsigned __int64 v4; // r10
  int v5; // eax
  int v6; // edx
  __int64 result; // rax
  __int64 v8; // rax
  __int64 v9; // rdx
  unsigned int v10; // edx
  __int64 v11; // rcx
  unsigned __int8 *v12; // rcx
  __int64 v13; // rcx
  unsigned __int64 v14; // r11
  unsigned int v15; // edx
  unsigned __int64 v16; // r11
  __int64 v17; // rcx
  const __m128i *v18; // r10
  unsigned __int64 v19; // r11

  if ( !a3 )
    return 0LL;
  if ( a3 <= 1 )
  {
    v5 = a1->m128i_u8[0];
    v6 = *a2;
    return (unsigned int)(v5 - v6);
  }
  v3 = a2 - (unsigned __int8 *)a1;
  v4 = a3;
  if ( a3 < 0x20 )
    goto LABEL_4;
  v14 = (unsigned __int64)a1->m128i_u64 + a3;
  if ( ((unsigned __int8)a1 & 0xF) != 0 )
  {
    v15 = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_loadu_si128(a1), _mm_loadu_si128((const __m128i *)((char *)a1 + v3))))
        - 0xFFFF;
    if ( v15 )
      goto LABEL_48;
    a1 = (const __m128i *)((char *)a1 - ((unsigned __int8)a1 & 0xF) + 16);
  }
  if ( (v3 & 0xF) == 0 )
  {
    if ( (unsigned __int64)a1 >= (v14 & 0xFFFFFFFFFFFFFFE0LL) )
      goto LABEL_46;
    if ( ((unsigned __int8)a1 & 0x10) != 0 )
    {
      v15 = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_load_si128((const __m128i *)((char *)a1 + v3)), *a1)) - 0xFFFF;
      if ( v15 )
        goto LABEL_48;
      if ( (const __m128i *)(v14 & 0xFFFFFFFFFFFFFFE0LL) == ++a1 )
        goto LABEL_46;
    }
    v18 = (const __m128i *)(v14 & 0xFFFFFFFFFFFFFFC0LL);
    if ( ((unsigned __int8)a1 & 0x20) != 0 )
    {
      v15 = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_load_si128((const __m128i *)((char *)a1 + v3)), *a1)) - 0xFFFF;
      if ( v15 )
        goto LABEL_48;
      ++a1;
      v15 = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_load_si128((const __m128i *)((char *)a1 + v3)), *a1)) - 0xFFFF;
      if ( v15 )
        goto LABEL_48;
      ++a1;
    }
    if ( v18 != a1 )
    {
      while ( 1 )
      {
        v15 = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_load_si128((const __m128i *)((char *)a1 + v3)), *a1)) - 0xFFFF;
        if ( v15 )
          goto LABEL_48;
        ++a1;
        v15 = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_load_si128((const __m128i *)((char *)a1 + v3)), *a1)) - 0xFFFF;
        if ( v15 )
          goto LABEL_48;
        ++a1;
        v15 = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_load_si128((const __m128i *)((char *)a1 + v3)), *a1)) - 0xFFFF;
        if ( v15 )
          goto LABEL_48;
        ++a1;
        v15 = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_load_si128((const __m128i *)((char *)a1 + v3)), *a1)) - 0xFFFF;
        if ( v15 )
          goto LABEL_48;
        if ( v18 == ++a1 )
        {
          if ( (unsigned __int64)a1 >= (v14 & 0xFFFFFFFFFFFFFFE0LL) )
            goto LABEL_46;
          while ( 1 )
          {
            v15 = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_load_si128((const __m128i *)((char *)a1 + v3)), *a1)) - 0xFFFF;
            if ( v15 )
              goto LABEL_48;
            ++a1;
            v15 = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_load_si128((const __m128i *)((char *)a1 + v3)), *a1)) - 0xFFFF;
            if ( v15 )
              goto LABEL_48;
            if ( ++a1 == (const __m128i *)(v14 & 0xFFFFFFFFFFFFFFE0LL) )
            {
              v19 = v14 - (_QWORD)a1;
              if ( !v19 )
                return 0LL;
              v4 = v19;
              goto LABEL_4;
            }
          }
        }
      }
    }
    goto LABEL_42;
  }
  if ( ((unsigned __int8)a1 & 0x10) != 0 )
  {
    v15 = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_loadu_si128((const __m128i *)((char *)a1 + v3)), *a1)) - 0xFFFF;
    if ( v15 )
      goto LABEL_48;
    ++a1;
  }
  if ( (unsigned __int64)a1 >= (v14 & 0xFFFFFFFFFFFFFFE0LL) )
    goto LABEL_46;
  if ( ((unsigned __int8)a1 & 0x20) == 0 )
    goto LABEL_36;
  v15 = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_loadu_si128((const __m128i *)((char *)a1 + v3)), *a1)) - 0xFFFF;
  if ( v15
    || (++a1,
        (v15 = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_loadu_si128((const __m128i *)((char *)a1 + v3)), *a1)) - 0xFFFF) != 0) )
  {
LABEL_48:
    _BitScanForward((unsigned int *)&v17, v15);
    v5 = a1->m128i_u8[v17];
    v6 = a1->m128i_u8[v3 + v17];
    return (unsigned int)(v5 - v6);
  }
  ++a1;
LABEL_36:
  if ( (unsigned __int64)a1 < (v14 & 0xFFFFFFFFFFFFFFC0LL) )
  {
    do
    {
      v15 = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_loadu_si128((const __m128i *)((char *)a1 + v3)), *a1)) - 0xFFFF;
      if ( v15 )
        goto LABEL_48;
      ++a1;
      v15 = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_loadu_si128((const __m128i *)((char *)a1 + v3)), *a1)) - 0xFFFF;
      if ( v15 )
        goto LABEL_48;
      ++a1;
      v15 = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_loadu_si128((const __m128i *)((char *)a1 + v3)), *a1)) - 0xFFFF;
      if ( v15 )
        goto LABEL_48;
      ++a1;
      v15 = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_loadu_si128((const __m128i *)((char *)a1 + v3)), *a1)) - 0xFFFF;
      if ( v15 )
        goto LABEL_48;
      ++a1;
    }
    while ( (const __m128i *)(v14 & 0xFFFFFFFFFFFFFFC0LL) != a1 );
  }
LABEL_42:
  if ( (unsigned __int64)a1 < (v14 & 0xFFFFFFFFFFFFFFE0LL) )
  {
    do
    {
      v15 = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_loadu_si128((const __m128i *)((char *)a1 + v3)), *a1)) - 0xFFFF;
      if ( v15 )
        goto LABEL_48;
      ++a1;
      v15 = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_loadu_si128((const __m128i *)((char *)a1 + v3)), *a1)) - 0xFFFF;
      if ( v15 )
        goto LABEL_48;
      ++a1;
    }
    while ( (const __m128i *)(v14 & 0xFFFFFFFFFFFFFFE0LL) != a1 );
  }
LABEL_46:
  v16 = v14 - (_QWORD)a1;
  if ( !v16 )
    return 0LL;
  v4 = v16;
LABEL_4:
  if ( (v4 & 1) == 0 )
    goto LABEL_7;
  v5 = a1->m128i_u8[0];
  v6 = a1->m128i_u8[v3];
  if ( --v4 )
  {
    a1 = (const __m128i *)((char *)a1 + 1);
    result = (unsigned int)(v5 - v6);
    if ( (_DWORD)result )
      return result;
    if ( (v4 & 2) != 0 )
    {
      v8 = a1->m128i_u16[0];
      v9 = *(unsigned __int16 *)((char *)a1->m128i_u16 + v3);
      v4 -= 2LL;
      if ( !v4 )
        goto LABEL_21;
      a1 = (const __m128i *)((char *)a1 + 2);
      if ( (_DWORD)v8 != (_DWORD)v9 )
        goto LABEL_21;
    }
LABEL_7:
    if ( ((v4 & 4) == 0
       || (v8 = a1->m128i_u32[0], v9 = *(unsigned int *)((char *)a1->m128i_u32 + v3), (v4 -= 4LL) != 0)
       && (a1 = (const __m128i *)((char *)a1 + 4), (_DWORD)v8 == (_DWORD)v9))
      && ((v4 & 8) == 0
       || (v8 = a1->m128i_i64[0], v9 = *(__int64 *)((char *)a1->m128i_i64 + v3), v4 != 8)
       && (a1 = (const __m128i *)((char *)a1 + 8), v8 == v9)) )
    {
      v10 = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_loadu_si128(a1), _mm_loadu_si128((const __m128i *)((char *)a1 + v3))))
          - 0xFFFF;
      if ( v10 )
      {
        _BitScanForward((unsigned int *)&v11, v10);
        v12 = &a1->m128i_u8[v11];
        v5 = *v12;
        v6 = v12[v3];
        return (unsigned int)(v5 - v6);
      }
    }
    else
    {
LABEL_21:
      if ( v8 != v9 )
      {
        _BitScanForward64((unsigned __int64 *)&v13, v8 - v9);
        return (unsigned __int8)(v8 >> (8 * (unsigned __int8)(v13 >> 3)))
             - (unsigned int)(unsigned __int8)(v9 >> (8 * (unsigned __int8)(v13 >> 3)));
      }
    }
    return 0LL;
  }
  return (unsigned int)(v5 - v6);
}
// 41F954: variable 'v11' is possibly undefined
// 41FB23: variable 'v17' is possibly undefined

//----- (000000000041FC90) ----------------------------------------------------
unsigned __int64 __fastcall _memcmp_avx2_movbe(__int64 _RDI, __int64 _RSI, unsigned __int64 _RDX, __int64 _RCX)
{
  unsigned __int64 result; // rax
  unsigned __int64 v36; // rax
  unsigned __int64 v37; // rcx
  unsigned __int32 v39; // eax
  unsigned __int32 v40; // ecx

  if ( _RDX >= 0x20 )
  {
    __asm
    {
      vmovdqu ymm2, ymmword ptr [rsi]
      vpcmpeqb ymm2, ymm2, ymmword ptr [rdi]
      vpmovmskb eax, ymm2
    }
    LODWORD(result) = _EAX + 1;
    if ( (_DWORD)result )
      goto LABEL_12;
    if ( _RDX <= 0x40 )
    {
LABEL_10:
      _RDI = _RDI + _RDX - 32;
      _RSI = _RSI + _RDX - 32;
      __asm
      {
        vmovdqu ymm2, ymmword ptr [rsi]
        vpcmpeqb ymm2, ymm2, ymmword ptr [rdi]
        vpmovmskb eax, ymm2
      }
      result = (unsigned int)(_EAX + 1);
      if ( !(_DWORD)result )
      {
        __asm { vzeroupper }
        return result;
      }
      goto LABEL_12;
    }
    __asm { vpcmpeqb ymm0, ymm0, ymm0 }
    if ( _RDX > 0x100 )
    {
      __asm
      {
        vmovdqu ymm2, ymmword ptr [rsi]
        vpcmpeqb ymm2, ymm2, ymmword ptr [rdi]
        vpmovmskb eax, ymm2
      }
      LODWORD(result) = _EAX + 1;
      if ( (_DWORD)result )
        goto LABEL_12;
      _RCX = (_RDI & 0x1F) - 32;
      _RSI -= _RCX;
      _RDI -= _RCX;
      _RDX += _RCX;
      while ( 1 )
      {
        __asm
        {
          vmovdqu ymm1, ymmword ptr [rsi]
          vpcmpeqb ymm1, ymm1, ymmword ptr [rdi]
          vmovdqu ymm2, ymmword ptr [rsi+20h]
          vpcmpeqb ymm2, ymm2, ymmword ptr [rdi+20h]
          vpand   ymm5, ymm1, ymm2
          vmovdqu ymm3, ymmword ptr [rsi+40h]
          vpcmpeqb ymm3, ymm3, ymmword ptr [rdi+40h]
          vpand   ymm5, ymm5, ymm3
          vmovdqu ymm4, ymmword ptr [rsi+60h]
          vpcmpeqb ymm4, ymm4, ymmword ptr [rdi+60h]
          vpand   ymm5, ymm5, ymm4
          vptest  ymm5, ymm0
        }
        if ( !_CF )
          break;
        _RDI += 128LL;
        _RSI += 128LL;
        _RDX -= 128LL;
        if ( _RDX < 0x80 )
        {
          if ( _RDX <= 0x20 )
            goto LABEL_10;
          if ( _RDX <= 0x40 )
          {
            __asm
            {
              vmovdqu ymm2, ymmword ptr [rsi]
              vpcmpeqb ymm2, ymm2, ymmword ptr [rdi]
              vpmovmskb eax, ymm2
            }
            LODWORD(result) = _EAX + 1;
            if ( (_DWORD)result )
              goto LABEL_12;
            goto LABEL_10;
          }
          goto LABEL_36;
        }
      }
    }
    else
    {
      if ( _RDX < 0x80 )
      {
LABEL_36:
        __asm
        {
          vmovdqu ymm2, ymmword ptr [rsi]
          vpcmpeqb ymm2, ymm2, ymmword ptr [rdi]
          vpmovmskb eax, ymm2
        }
        LODWORD(result) = _EAX + 1;
        if ( !(_DWORD)result )
        {
          _RDI += 32LL;
          _RSI += 32LL;
          __asm
          {
            vmovdqu ymm2, ymmword ptr [rsi]
            vpcmpeqb ymm2, ymm2, ymmword ptr [rdi]
            vpmovmskb eax, ymm2
          }
          LODWORD(result) = _EAX + 1;
          if ( !(_DWORD)result )
          {
            _RDI = _RDI + _RDX - 96;
            _RSI = _RSI + _RDX - 96;
            __asm
            {
              vmovdqu ymm2, ymmword ptr [rsi]
              vpcmpeqb ymm2, ymm2, ymmword ptr [rdi]
              vpmovmskb eax, ymm2
            }
            LODWORD(result) = _EAX + 1;
            if ( !(_DWORD)result )
            {
              _RDI += 32LL;
              _RSI += 32LL;
              __asm
              {
                vmovdqu ymm2, ymmword ptr [rsi]
                vpcmpeqb ymm2, ymm2, ymmword ptr [rdi]
                vpmovmskb eax, ymm2
              }
              result = (unsigned int)(_EAX + 1);
              if ( !(_DWORD)result )
              {
                __asm { vzeroupper }
                return result;
              }
            }
          }
        }
        goto LABEL_12;
      }
      __asm
      {
        vmovdqu ymm1, ymmword ptr [rsi]
        vpcmpeqb ymm1, ymm1, ymmword ptr [rdi]
        vmovdqu ymm2, ymmword ptr [rsi+20h]
        vpcmpeqb ymm2, ymm2, ymmword ptr [rdi+20h]
        vmovdqu ymm3, ymmword ptr [rsi+40h]
        vpcmpeqb ymm3, ymm3, ymmword ptr [rdi+40h]
        vmovdqu ymm4, ymmword ptr [rsi+60h]
        vpcmpeqb ymm4, ymm4, ymmword ptr [rdi+60h]
        vpand   ymm5, ymm2, ymm1
        vpand   ymm6, ymm4, ymm3
        vpand   ymm5, ymm6, ymm5
        vptest  ymm5, ymm0
      }
      if ( _CF )
      {
        _RDI = _RDI + _RDX - 128;
        _RSI = _RSI + _RDX - 128;
        __asm
        {
          vmovdqu ymm1, ymmword ptr [rsi]
          vpcmpeqb ymm1, ymm1, ymmword ptr [rdi]
          vmovdqu ymm2, ymmword ptr [rsi+20h]
          vpcmpeqb ymm2, ymm2, ymmword ptr [rdi+20h]
          vpand   ymm5, ymm1, ymm2
          vmovdqu ymm3, ymmword ptr [rsi+40h]
          vpcmpeqb ymm3, ymm3, ymmword ptr [rdi+40h]
          vpand   ymm5, ymm5, ymm3
          vmovdqu ymm4, ymmword ptr [rsi+60h]
          vpcmpeqb ymm4, ymm4, ymmword ptr [rdi+60h]
          vpand   ymm5, ymm5, ymm4
          vptest  ymm5, ymm0
        }
        if ( _CF )
        {
          result = 0LL;
          __asm { vzeroupper }
          return result;
        }
      }
    }
    __asm { vpmovmskb eax, ymm1 }
    LODWORD(result) = _EAX + 1;
    if ( !(_DWORD)result )
    {
      __asm { vpmovmskb eax, ymm2 }
      if ( _EAX + 1 )
      {
        __asm { tzcnt   ecx, eax }
        result = *(unsigned __int8 *)(_RDI + _RCX + 32) - (unsigned int)*(unsigned __int8 *)(_RSI + _RCX + 32);
        __asm { vzeroupper }
      }
      else
      {
        __asm { vpmovmskb eax, ymm3 }
        if ( _EAX + 1 )
        {
          __asm { tzcnt   ecx, eax }
          result = *(unsigned __int8 *)(_RDI + _RCX + 64) - (unsigned int)*(unsigned __int8 *)(_RSI + _RCX + 64);
          __asm { vzeroupper }
        }
        else
        {
          __asm { vpmovmskb eax, ymm4 }
          ++_EAX;
          __asm { tzcnt   ecx, eax }
          result = *(unsigned __int8 *)(_RDI + _RCX + 96) - (unsigned int)*(unsigned __int8 *)(_RSI + _RCX + 96);
          __asm { vzeroupper }
        }
      }
      return result;
    }
LABEL_12:
    __asm { tzcnt   ecx, eax }
    result = *(unsigned __int8 *)(_RDI + _RCX) - (unsigned int)*(unsigned __int8 *)(_RSI + _RCX);
    __asm { vzeroupper }
    return result;
  }
  if ( (_BYTE)_RDX == 1 )
    return *(unsigned __int8 *)_RDI - (unsigned int)*(unsigned __int8 *)_RSI;
  if ( !(_BYTE)_RDX )
    return 0LL;
  if ( (unsigned __int8)_RDX < 4u )
  {
    v39 = _byteswap_ulong(*(unsigned __int16 *)_RDI << 8);
    v40 = _byteswap_ulong(*(unsigned __int16 *)_RSI << 8);
    LOBYTE(v39) = *(_BYTE *)(_RDI + _RDX - 1);
    LOBYTE(v40) = *(_BYTE *)(_RSI + _RDX - 1);
    return v39 - v40;
  }
  if ( (unsigned __int8)_RDX < 8u )
  {
    __asm
    {
      movbe   eax, [rdi]
      movbe   ecx, [rsi]
      movbe   edi, [rdi+rdx-4]
      movbe   esi, [rsi+rdx-4]
    }
    v36 = _RDI | (_RAX << 32);
    v37 = _RSI | (_RCX << 32);
    _CF = v36 < v37;
    result = v36 - v37;
    if ( result )
      return _CF ? -1 : 1;
  }
  else if ( (unsigned __int8)_RDX >= 0x10u )
  {
    __asm
    {
      vmovdqu xmm2, xmmword ptr [rsi]
      vpcmpeqb xmm2, xmm2, xmmword ptr [rdi]
      vpmovmskb eax, xmm2
    }
    LODWORD(result) = _EAX - 0xFFFF;
    if ( (_DWORD)result )
      goto LABEL_12;
    _RDI = _RDI + _RDX - 16;
    _RSI = _RSI + _RDX - 16;
    __asm
    {
      vmovdqu xmm2, xmmword ptr [rsi]
      vpcmpeqb xmm2, xmm2, xmmword ptr [rdi]
      vpmovmskb eax, xmm2
    }
    result = (unsigned int)(_EAX - 0xFFFF);
    if ( (_DWORD)result )
      goto LABEL_12;
  }
  else
  {
    __asm
    {
      vmovq   xmm1, qword ptr [rdi]
      vmovq   xmm2, qword ptr [rsi]
      vpcmpeqb xmm2, xmm2, xmm1
      vpmovmskb eax, xmm2
    }
    LODWORD(result) = _EAX - 0xFFFF;
    if ( (_DWORD)result )
      goto LABEL_12;
    _RDI = _RDI + _RDX - 8;
    _RSI = _RSI + _RDX - 8;
    __asm
    {
      vmovq   xmm1, qword ptr [rdi]
      vmovq   xmm2, qword ptr [rsi]
      vpcmpeqb xmm2, xmm2, xmm1
      vpmovmskb eax, xmm2
    }
    result = (unsigned int)(_EAX - 0xFFFF);
    if ( (_DWORD)result )
      goto LABEL_12;
  }
  return result;
}
// 41FDC8: variable '_RAX' is possibly undefined

//----- (0000000000420070) ----------------------------------------------------
__int64 __fastcall _memcmp_sse4_1(const __m128i *_RDI, __m128i *_RSI, unsigned __int64 a3)
{
  __m128i *v4; // rcx
  signed __int64 v5; // rcx
  unsigned __int64 v6; // rdx
  unsigned __int64 v7; // rdx
  __m128i v8; // xmm2
  __m128i v9; // xmm3
  __m128i v10; // xmm4
  bool v11; // cf
  const __m128i *v12; // rdi
  __m128i *v13; // rsi
  unsigned __int64 v14; // rax
  unsigned __int64 v15; // rcx

  if ( a3 <= 0x4F )
  {
    if ( a3 == 1 )
      return _RDI->m128i_u8[0] - (unsigned int)_RSI->m128i_u8[0];
    return ((__int64 (__fastcall *)(__int8 *, __int8 *, double))((char *)dword_481CF0 + dword_481CF0[a3]))(
             &_RDI->m128i_i8[a3],
             &_RSI->m128i_i8[a3],
             0.0);
  }
  if ( !_mm_testc_si128((__m128i)0LL, _mm_xor_si128(_mm_loadu_si128(_RDI), _mm_loadu_si128(_RSI))) )
    goto LABEL_141;
  v4 = _RSI;
  _RSI = (__m128i *)(((unsigned __int64)_RSI & 0xFFFFFFFFFFFFFFF0LL) + 16);
  v5 = (char *)v4 - (char *)_RSI;
  _RDI = (const __m128i *)((char *)_RDI - v5);
  a3 += v5;
  if ( ((unsigned __int8)_RDI & 0xF) != 0 )
  {
    if ( a3 <= 0x80 )
      goto LABEL_7;
    if ( a3 <= 0x200 )
    {
      if ( a3 <= 0x100 )
        goto LABEL_18;
      a3 -= 256LL;
      if ( !_mm_testc_si128((__m128i)0LL, _mm_xor_si128(_mm_loadu_si128(_RDI), *_RSI)) )
        goto LABEL_141;
      if ( !_mm_testc_si128((__m128i)0LL, _mm_xor_si128(_mm_loadu_si128(_RDI + 1), _RSI[1])) )
        goto LABEL_140;
      if ( !_mm_testc_si128((__m128i)0LL, _mm_xor_si128(_mm_loadu_si128(_RDI + 2), _RSI[2])) )
        goto LABEL_139;
      if ( !_mm_testc_si128((__m128i)0LL, _mm_xor_si128(_mm_loadu_si128(_RDI + 3), _RSI[3])) )
        goto LABEL_138;
      if ( !_mm_testc_si128((__m128i)0LL, _mm_xor_si128(_mm_loadu_si128(_RDI + 4), _RSI[4])) )
        goto LABEL_137;
      if ( !_mm_testc_si128((__m128i)0LL, _mm_xor_si128(_mm_loadu_si128(_RDI + 5), _RSI[5])) )
        goto LABEL_136;
      if ( !_mm_testc_si128((__m128i)0LL, _mm_xor_si128(_mm_loadu_si128(_RDI + 6), _RSI[6])) )
        goto LABEL_135;
      if ( _mm_testc_si128((__m128i)0LL, _mm_xor_si128(_mm_loadu_si128(_RDI + 7), _RSI[7])) )
      {
        if ( _mm_testc_si128((__m128i)0LL, _mm_xor_si128(_mm_loadu_si128(_RDI + 8), _RSI[8])) )
        {
          if ( _mm_testc_si128((__m128i)0LL, _mm_xor_si128(_mm_loadu_si128(_RDI + 9), _RSI[9])) )
          {
            if ( _mm_testc_si128((__m128i)0LL, _mm_xor_si128(_mm_loadu_si128(_RDI + 10), _RSI[10])) )
            {
              if ( _mm_testc_si128((__m128i)0LL, _mm_xor_si128(_mm_loadu_si128(_RDI + 11), _RSI[11])) )
              {
                if ( _mm_testc_si128((__m128i)0LL, _mm_xor_si128(_mm_loadu_si128(_RDI + 12), _RSI[12])) )
                {
                  if ( _mm_testc_si128((__m128i)0LL, _mm_xor_si128(_mm_loadu_si128(_RDI + 13), _RSI[13])) )
                  {
                    if ( _mm_testc_si128((__m128i)0LL, _mm_xor_si128(_mm_loadu_si128(_RDI + 14), _RSI[14])) )
                    {
                      if ( _mm_testc_si128((__m128i)0LL, _mm_xor_si128(_mm_loadu_si128(_RDI + 15), _RSI[15])) )
                      {
                        _RSI += 16;
                        _RDI += 16;
                        if ( a3 < 0x80 )
                        {
                          if ( a3 < 0x40 )
                          {
                            if ( a3 >= 0x20 )
                            {
                              if ( !_mm_testc_si128((__m128i)0LL, _mm_xor_si128(_mm_loadu_si128(_RDI), *_RSI)) )
                                goto LABEL_141;
                              if ( !_mm_testc_si128((__m128i)0LL, _mm_xor_si128(_mm_loadu_si128(_RDI + 1), _RSI[1])) )
                                goto LABEL_140;
                              a3 -= 32LL;
                              _RDI += 2;
                              _RSI += 2;
                            }
                            return ((__int64 (__fastcall *)(__int8 *, __int8 *, double))((char *)dword_481CF0
                                                                                       + dword_481CF0[a3]))(
                                     &_RDI->m128i_i8[a3],
                                     &_RSI->m128i_i8[a3],
                                     0.0);
                          }
LABEL_7:
                          v6 = a3 - 64;
                          if ( _mm_testc_si128((__m128i)0LL, _mm_xor_si128(_mm_loadu_si128(_RDI), *_RSI)) )
                          {
                            if ( _mm_testc_si128((__m128i)0LL, _mm_xor_si128(_mm_loadu_si128(_RDI + 1), _RSI[1])) )
                            {
                              if ( _mm_testc_si128((__m128i)0LL, _mm_xor_si128(_mm_loadu_si128(_RDI + 2), _RSI[2])) )
                              {
                                if ( _mm_testc_si128((__m128i)0LL, _mm_xor_si128(_mm_loadu_si128(_RDI + 3), _RSI[3])) )
                                {
                                  if ( v6 < 0x20 )
                                    return ((__int64 (__fastcall *)(__int8 *, __int8 *, double))((char *)dword_481CF0
                                                                                               + dword_481CF0[v6]))(
                                             &_RDI[4].m128i_i8[v6],
                                             &_RSI[4].m128i_i8[v6],
                                             0.0);
                                  if ( _mm_testc_si128((__m128i)0LL, _mm_xor_si128(_mm_loadu_si128(_RDI + 4), _RSI[4])) )
                                  {
                                    if ( _mm_testc_si128(
                                           (__m128i)0LL,
                                           _mm_xor_si128(_mm_loadu_si128(_RDI + 5), _RSI[5])) )
                                    {
                                      v6 -= 32LL;
                                      _RDI += 2;
                                      _RSI += 2;
                                      return ((__int64 (__fastcall *)(__int8 *, __int8 *, double))((char *)dword_481CF0
                                                                                                 + dword_481CF0[v6]))(
                                               &_RDI[4].m128i_i8[v6],
                                               &_RSI[4].m128i_i8[v6],
                                               0.0);
                                    }
                                    goto LABEL_136;
                                  }
LABEL_137:
                                  v12 = _RDI + 5;
                                  v13 = _RSI + 5;
                                  goto LABEL_142;
                                }
LABEL_138:
                                v12 = _RDI + 4;
                                v13 = _RSI + 4;
                                goto LABEL_142;
                              }
                              goto LABEL_139;
                            }
LABEL_140:
                            ++_RDI;
                            ++_RSI;
                          }
LABEL_141:
                          v12 = _RDI + 1;
                          v13 = _RSI + 1;
                          goto LABEL_142;
                        }
LABEL_18:
                        a3 -= 128LL;
                        if ( !_mm_testc_si128((__m128i)0LL, _mm_xor_si128(_mm_loadu_si128(_RDI), *_RSI)) )
                          goto LABEL_141;
                        if ( !_mm_testc_si128((__m128i)0LL, _mm_xor_si128(_mm_loadu_si128(_RDI + 1), _RSI[1])) )
                          goto LABEL_140;
                        if ( _mm_testc_si128((__m128i)0LL, _mm_xor_si128(_mm_loadu_si128(_RDI + 2), _RSI[2])) )
                        {
                          if ( !_mm_testc_si128((__m128i)0LL, _mm_xor_si128(_mm_loadu_si128(_RDI + 3), _RSI[3])) )
                            goto LABEL_138;
                          if ( !_mm_testc_si128((__m128i)0LL, _mm_xor_si128(_mm_loadu_si128(_RDI + 4), _RSI[4])) )
                            goto LABEL_137;
                          if ( _mm_testc_si128((__m128i)0LL, _mm_xor_si128(_mm_loadu_si128(_RDI + 5), _RSI[5])) )
                          {
                            if ( _mm_testc_si128((__m128i)0LL, _mm_xor_si128(_mm_loadu_si128(_RDI + 6), _RSI[6])) )
                            {
                              if ( _mm_testc_si128((__m128i)0LL, _mm_xor_si128(_mm_loadu_si128(_RDI + 7), _RSI[7])) )
                              {
                                _RSI += 8;
                                _RDI += 8;
                                if ( a3 < 0x40 )
                                {
                                  if ( a3 >= 0x20 )
                                  {
                                    if ( !_mm_testc_si128((__m128i)0LL, _mm_xor_si128(_mm_loadu_si128(_RDI), *_RSI)) )
                                      goto LABEL_141;
                                    if ( !_mm_testc_si128(
                                            (__m128i)0LL,
                                            _mm_xor_si128(_mm_loadu_si128(_RDI + 1), _RSI[1])) )
                                      goto LABEL_140;
                                    a3 -= 32LL;
                                    _RDI += 2;
                                    _RSI += 2;
                                  }
                                  return ((__int64 (__fastcall *)(_QWORD, _QWORD, double))((char *)dword_481CF0
                                                                                         + dword_481CF0[a3]))(
                                           &_RDI->m128i_i8[a3],
                                           &_RSI->m128i_i8[a3],
                                           0.0);
                                }
                                goto LABEL_7;
                              }
                              goto LABEL_134;
                            }
LABEL_135:
                            v12 = _RDI + 7;
                            v13 = _RSI + 7;
                            goto LABEL_142;
                          }
LABEL_136:
                          v12 = _RDI + 6;
                          v13 = _RSI + 6;
                          goto LABEL_142;
                        }
LABEL_139:
                        ++_RDI;
                        ++_RSI;
                        goto LABEL_140;
                      }
                      goto LABEL_126;
                    }
LABEL_127:
                    v12 = _RDI + 15;
                    v13 = _RSI + 15;
                    goto LABEL_142;
                  }
LABEL_128:
                  v12 = _RDI + 14;
                  v13 = _RSI + 14;
                  goto LABEL_142;
                }
LABEL_129:
                v12 = _RDI + 13;
                v13 = _RSI + 13;
                goto LABEL_142;
              }
LABEL_130:
              v12 = _RDI + 12;
              v13 = _RSI + 12;
              goto LABEL_142;
            }
LABEL_131:
            v12 = _RDI + 11;
            v13 = _RSI + 11;
            goto LABEL_142;
          }
LABEL_132:
          v12 = _RDI + 10;
          v13 = _RSI + 10;
          goto LABEL_142;
        }
LABEL_133:
        v12 = _RDI + 9;
        v13 = _RSI + 9;
        goto LABEL_142;
      }
LABEL_134:
      v12 = _RDI + 8;
      v13 = _RSI + 8;
      goto LABEL_142;
    }
    if ( a3 > _x86_data_cache_size_half + ((unsigned __int64)_x86_data_cache_size_half >> 1) )
    {
      v7 = a3 - 64;
      while ( 1 )
      {
        __asm
        {
          prefetchnta byte ptr [rdi+1C0h]
          prefetchnta byte ptr [rsi+1C0h]
        }
        v8 = _mm_xor_si128(_mm_loadu_si128(_RDI), *_RSI);
        v9 = _mm_xor_si128(_mm_loadu_si128(_RDI + 1), _RSI[1]);
        v10 = _mm_xor_si128(_mm_loadu_si128(_RDI + 2), _RSI[2]);
        if ( !_mm_testc_si128(
                (__m128i)0LL,
                _mm_or_si128(_mm_or_si128(_mm_or_si128(v8, v9), v10), _mm_xor_si128(_mm_loadu_si128(_RDI + 3), _RSI[3]))) )
          break;
        _RSI += 4;
        _RDI += 4;
        v11 = v7 < 0x40;
        v7 -= 64LL;
        if ( v11 )
          return ((__int64 (__fastcall *)(__int8 *, __int8 *, double))((char *)dword_481CF0 + dword_481CF0[v7 + 64]))(
                   &_RDI[4].m128i_i8[v7],
                   &_RSI[4].m128i_i8[v7],
                   0.0);
      }
    }
    else
    {
      v7 = a3 - 64;
      while ( 1 )
      {
        v8 = _mm_xor_si128(_mm_loadu_si128(_RDI), *_RSI);
        v9 = _mm_xor_si128(_mm_loadu_si128(_RDI + 1), _RSI[1]);
        v10 = _mm_xor_si128(_mm_loadu_si128(_RDI + 2), _RSI[2]);
        if ( !_mm_testc_si128(
                (__m128i)0LL,
                _mm_or_si128(_mm_or_si128(_mm_or_si128(v8, v9), v10), _mm_xor_si128(_mm_loadu_si128(_RDI + 3), _RSI[3]))) )
          break;
        _RSI += 4;
        _RDI += 4;
        v11 = v7 < 0x40;
        v7 -= 64LL;
        if ( v11 )
          return ((__int64 (__fastcall *)(__int8 *, __int8 *, double))((char *)dword_481CF0 + dword_481CF0[v7 + 64]))(
                   &_RDI[4].m128i_i8[v7],
                   &_RSI[4].m128i_i8[v7],
                   0.0);
      }
    }
LABEL_122:
    v12 = _RDI + 1;
    v13 = _RSI + 1;
    if ( _mm_testc_si128((__m128i)0LL, v8) )
    {
      ++v12;
      ++v13;
      if ( _mm_testc_si128((__m128i)0LL, v9) )
      {
        ++v12;
        ++v13;
        if ( _mm_testc_si128((__m128i)0LL, v10) )
        {
          ++v12;
          ++v13;
        }
      }
    }
    goto LABEL_142;
  }
  if ( a3 <= 0x80 )
  {
LABEL_65:
    v6 = a3 - 64;
    if ( !_mm_testc_si128((__m128i)0LL, _mm_xor_si128(_mm_load_si128(_RDI), *_RSI)) )
      goto LABEL_141;
    if ( !_mm_testc_si128((__m128i)0LL, _mm_xor_si128(_mm_load_si128(_RDI + 1), _RSI[1])) )
      goto LABEL_140;
    if ( _mm_testc_si128((__m128i)0LL, _mm_xor_si128(_mm_load_si128(_RDI + 2), _RSI[2])) )
    {
      if ( !_mm_testc_si128((__m128i)0LL, _mm_xor_si128(_mm_load_si128(_RDI + 3), _RSI[3])) )
        goto LABEL_138;
      if ( v6 < 0x20 )
        return ((__int64 (__fastcall *)(_QWORD, _QWORD, double))((char *)dword_481CF0 + dword_481CF0[v6]))(
                 &_RDI[4].m128i_i8[v6],
                 &_RSI[4].m128i_i8[v6],
                 0.0);
      if ( !_mm_testc_si128((__m128i)0LL, _mm_xor_si128(_mm_load_si128(_RDI + 4), _RSI[4])) )
        goto LABEL_137;
      if ( _mm_testc_si128((__m128i)0LL, _mm_xor_si128(_mm_load_si128(_RDI + 5), _RSI[5])) )
      {
        v6 -= 32LL;
        _RDI += 2;
        _RSI += 2;
        return ((__int64 (__fastcall *)(_QWORD, _QWORD, double))((char *)dword_481CF0 + dword_481CF0[v6]))(
                 &_RDI[4].m128i_i8[v6],
                 &_RSI[4].m128i_i8[v6],
                 0.0);
      }
      goto LABEL_136;
    }
    goto LABEL_139;
  }
  if ( a3 > 0x200 )
  {
    if ( a3 > _x86_data_cache_size_half + ((unsigned __int64)_x86_data_cache_size_half >> 1) )
    {
      v7 = a3 - 64;
      while ( 1 )
      {
        __asm
        {
          prefetchnta byte ptr [rdi+1C0h]
          prefetchnta byte ptr [rsi+1C0h]
        }
        v8 = _mm_xor_si128(_mm_load_si128(_RDI), *_RSI);
        v9 = _mm_xor_si128(_mm_load_si128(_RDI + 1), _RSI[1]);
        v10 = _mm_xor_si128(_mm_load_si128(_RDI + 2), _RSI[2]);
        if ( !_mm_testc_si128(
                (__m128i)0LL,
                _mm_or_si128(_mm_or_si128(_mm_or_si128(v8, v9), v10), _mm_xor_si128(_mm_load_si128(_RDI + 3), _RSI[3]))) )
          break;
        _RSI += 4;
        _RDI += 4;
        v11 = v7 < 0x40;
        v7 -= 64LL;
        if ( v11 )
          return ((__int64 (__fastcall *)(_QWORD, _QWORD, double))((char *)dword_481CF0 + dword_481CF0[v7 + 64]))(
                   &_RDI[4].m128i_i8[v7],
                   &_RSI[4].m128i_i8[v7],
                   0.0);
      }
    }
    else
    {
      v7 = a3 - 64;
      while ( 1 )
      {
        v8 = _mm_xor_si128(_mm_load_si128(_RDI), *_RSI);
        v9 = _mm_xor_si128(_mm_load_si128(_RDI + 1), _RSI[1]);
        v10 = _mm_xor_si128(_mm_load_si128(_RDI + 2), _RSI[2]);
        if ( !_mm_testc_si128(
                (__m128i)0LL,
                _mm_or_si128(_mm_or_si128(_mm_or_si128(v8, v9), v10), _mm_xor_si128(_mm_load_si128(_RDI + 3), _RSI[3]))) )
          break;
        _RSI += 4;
        _RDI += 4;
        v11 = v7 < 0x40;
        v7 -= 64LL;
        if ( v11 )
          return ((__int64 (__fastcall *)(_QWORD, _QWORD, double))((char *)dword_481CF0 + dword_481CF0[v7 + 64]))(
                   &_RDI[4].m128i_i8[v7],
                   &_RSI[4].m128i_i8[v7],
                   0.0);
      }
    }
    goto LABEL_122;
  }
  if ( a3 <= 0x100 )
  {
LABEL_76:
    a3 -= 128LL;
    if ( !_mm_testc_si128((__m128i)0LL, _mm_xor_si128(_mm_load_si128(_RDI), *_RSI)) )
      goto LABEL_141;
    if ( !_mm_testc_si128((__m128i)0LL, _mm_xor_si128(_mm_load_si128(_RDI + 1), _RSI[1])) )
      goto LABEL_140;
    if ( !_mm_testc_si128((__m128i)0LL, _mm_xor_si128(_mm_load_si128(_RDI + 2), _RSI[2])) )
      goto LABEL_139;
    if ( !_mm_testc_si128((__m128i)0LL, _mm_xor_si128(_mm_load_si128(_RDI + 3), _RSI[3])) )
      goto LABEL_138;
    if ( !_mm_testc_si128((__m128i)0LL, _mm_xor_si128(_mm_load_si128(_RDI + 4), _RSI[4])) )
      goto LABEL_137;
    if ( !_mm_testc_si128((__m128i)0LL, _mm_xor_si128(_mm_load_si128(_RDI + 5), _RSI[5])) )
      goto LABEL_136;
    if ( !_mm_testc_si128((__m128i)0LL, _mm_xor_si128(_mm_load_si128(_RDI + 6), _RSI[6])) )
      goto LABEL_135;
    if ( !_mm_testc_si128((__m128i)0LL, _mm_xor_si128(_mm_load_si128(_RDI + 7), _RSI[7])) )
      goto LABEL_134;
    _RSI += 8;
    _RDI += 8;
    if ( a3 < 0x40 )
    {
      if ( a3 >= 0x20 )
      {
        if ( !_mm_testc_si128((__m128i)0LL, _mm_xor_si128(_mm_loadu_si128(_RDI), *_RSI)) )
          goto LABEL_141;
        if ( !_mm_testc_si128((__m128i)0LL, _mm_xor_si128(_mm_loadu_si128(_RDI + 1), _RSI[1])) )
          goto LABEL_140;
        a3 -= 32LL;
        _RDI += 2;
        _RSI += 2;
      }
      return ((__int64 (__fastcall *)(_QWORD, _QWORD, double))((char *)dword_481CF0 + dword_481CF0[a3]))(
               &_RDI->m128i_i8[a3],
               &_RSI->m128i_i8[a3],
               0.0);
    }
    goto LABEL_65;
  }
  a3 -= 256LL;
  if ( !_mm_testc_si128((__m128i)0LL, _mm_xor_si128(_mm_load_si128(_RDI), *_RSI)) )
    goto LABEL_141;
  if ( !_mm_testc_si128((__m128i)0LL, _mm_xor_si128(_mm_load_si128(_RDI + 1), _RSI[1])) )
    goto LABEL_140;
  if ( !_mm_testc_si128((__m128i)0LL, _mm_xor_si128(_mm_load_si128(_RDI + 2), _RSI[2])) )
    goto LABEL_139;
  if ( !_mm_testc_si128((__m128i)0LL, _mm_xor_si128(_mm_load_si128(_RDI + 3), _RSI[3])) )
    goto LABEL_138;
  if ( !_mm_testc_si128((__m128i)0LL, _mm_xor_si128(_mm_load_si128(_RDI + 4), _RSI[4])) )
    goto LABEL_137;
  if ( !_mm_testc_si128((__m128i)0LL, _mm_xor_si128(_mm_load_si128(_RDI + 5), _RSI[5])) )
    goto LABEL_136;
  if ( !_mm_testc_si128((__m128i)0LL, _mm_xor_si128(_mm_load_si128(_RDI + 6), _RSI[6])) )
    goto LABEL_135;
  if ( !_mm_testc_si128((__m128i)0LL, _mm_xor_si128(_mm_load_si128(_RDI + 7), _RSI[7])) )
    goto LABEL_134;
  if ( !_mm_testc_si128((__m128i)0LL, _mm_xor_si128(_mm_load_si128(_RDI + 8), _RSI[8])) )
    goto LABEL_133;
  if ( !_mm_testc_si128((__m128i)0LL, _mm_xor_si128(_mm_load_si128(_RDI + 9), _RSI[9])) )
    goto LABEL_132;
  if ( !_mm_testc_si128((__m128i)0LL, _mm_xor_si128(_mm_load_si128(_RDI + 10), _RSI[10])) )
    goto LABEL_131;
  if ( !_mm_testc_si128((__m128i)0LL, _mm_xor_si128(_mm_load_si128(_RDI + 11), _RSI[11])) )
    goto LABEL_130;
  if ( !_mm_testc_si128((__m128i)0LL, _mm_xor_si128(_mm_load_si128(_RDI + 12), _RSI[12])) )
    goto LABEL_129;
  if ( !_mm_testc_si128((__m128i)0LL, _mm_xor_si128(_mm_load_si128(_RDI + 13), _RSI[13])) )
    goto LABEL_128;
  if ( !_mm_testc_si128((__m128i)0LL, _mm_xor_si128(_mm_load_si128(_RDI + 14), _RSI[14])) )
    goto LABEL_127;
  if ( _mm_testc_si128((__m128i)0LL, _mm_xor_si128(_mm_load_si128(_RDI + 15), _RSI[15])) )
  {
    _RSI += 16;
    _RDI += 16;
    if ( a3 < 0x80 )
    {
      if ( a3 < 0x40 )
      {
        if ( a3 >= 0x20 )
        {
          if ( !_mm_testc_si128((__m128i)0LL, _mm_xor_si128(_mm_load_si128(_RDI), *_RSI)) )
            goto LABEL_141;
          if ( !_mm_testc_si128((__m128i)0LL, _mm_xor_si128(_mm_load_si128(_RDI + 1), _RSI[1])) )
            goto LABEL_140;
          a3 -= 32LL;
          _RDI += 2;
          _RSI += 2;
        }
        return ((__int64 (__fastcall *)(_QWORD, _QWORD, double))((char *)dword_481CF0 + dword_481CF0[a3]))(
                 &_RDI->m128i_i8[a3],
                 &_RSI->m128i_i8[a3],
                 0.0);
      }
      goto LABEL_65;
    }
    goto LABEL_76;
  }
LABEL_126:
  v12 = _RDI + 16;
  v13 = _RSI + 16;
LABEL_142:
  v14 = v12[-1].m128i_u64[0];
  v15 = v13[-1].m128i_u64[0];
  if ( v15 == v14 )
  {
    v14 = v12[-1].m128i_u64[1];
    v15 = v13[-1].m128i_u64[1];
    if ( v15 == v14 )
      return 0LL;
  }
  if ( (_DWORD)v15 == (_DWORD)v14 )
  {
    v15 >>= 32;
    v14 >>= 32;
  }
  if ( (_WORD)v14 == (_WORD)v15 )
  {
    LODWORD(v15) = WORD1(v15);
    LODWORD(v14) = WORD1(v14);
  }
  if ( (_BYTE)v14 == (_BYTE)v15 )
  {
    LODWORD(v14) = (unsigned __int16)v14;
    LODWORD(v15) = (unsigned __int16)v15;
  }
  else
  {
    LODWORD(v14) = (unsigned __int8)v14;
    LODWORD(v15) = (unsigned __int8)v15;
  }
  return (unsigned int)(v14 - v15);
}
// 481CF0: using guessed type int dword_481CF0[80];
// 4A9158: using guessed type __int64 _x86_data_cache_size_half;

//----- (00000000004216B0) ----------------------------------------------------
void __fastcall _mempcpy_chk_ssse3(
        __int64 a1,
        __int64 a2,
        unsigned __int64 a3,
        unsigned __int64 a4,
        u32 *a5,
        __int64 a6)
{
  if ( a4 < a3 )
    _chk_fail(a1, a2, a3, a4, a5, a6);
  _mempcpy_ssse3();
}

//----- (00000000004216C0) ----------------------------------------------------
void _mempcpy_ssse3()
{
  JUMPOUT(0x4216E7LL);
}
// 4216CA: control flows out of bounds to 4216E7

//----- (00000000004216D0) ----------------------------------------------------
__int64 __fastcall _memcpy_chk_ssse3(
        __m128i *a1,
        const __m128i *_RSI,
        unsigned __int64 a3,
        unsigned __int64 a4,
        u32 *a5,
        __int64 a6)
{
  if ( a4 < a3 )
    _chk_fail((__int64)a1, (__int64)_RSI, a3, a4, a5, a6);
  return _memcpy_ssse3(a1, _RSI, a3);
}

//----- (00000000004216E0) ----------------------------------------------------
__int64 __fastcall _memcpy_ssse3(__m128i *a1, const __m128i *_RSI, unsigned __int64 a3)
{
  __m128i v3; // xmm0
  __m128i *v4; // rcx
  __m128i *v5; // rdi
  __m128i *v6; // r8
  signed __int64 v7; // rcx
  unsigned __int64 v8; // rdx
  const __m128i *v9; // rsi
  __int64 v10; // rcx
  const __m128i *v11; // r9
  __m128i v13; // xmm0
  __int8 *v14; // rsi
  __m128i *v15; // r8
  unsigned __int64 v16; // rdi
  unsigned __int64 v17; // rcx
  unsigned __int64 v18; // rdi
  unsigned __int64 v19; // rdx
  const __m128i *v20; // rsi
  __int64 v21; // rcx
  const __m128i *v22; // r9
  __m128i v23; // xmm1
  __m128i v24; // xmm1
  __m128i v25; // xmm2
  __m128i v26; // xmm3
  bool v27; // cf
  unsigned __int64 v28; // rdx
  __m128i v29; // xmm1
  __m128i v30; // xmm2
  __m128i v31; // xmm3
  __m128i v32; // xmm4
  __m128i v33; // xmm5
  __m128i v34; // xmm6
  __m128i v35; // xmm7
  bool v36; // cc
  __m128i v37; // xmm1
  __m128i v38; // xmm4
  __m128i v39; // xmm1
  __m128i v40; // xmm0
  __m128i v41; // xmm1
  __m128i v42; // xmm2
  __m128i v43; // xmm3
  __m128i v44; // xmm4
  __m128i v45; // xmm5
  __m128i v46; // xmm6
  __m128i v47; // xmm7
  __m128i v48; // xmm1
  __m128i v49; // xmm0
  __m128i v50; // xmm1
  __m128i v51; // xmm0
  __m128i v52; // xmm1
  unsigned __int64 v53; // rdx
  __m128i si128; // xmm1
  unsigned __int64 v56; // rdi
  __int128 v57; // xmm1
  __int128 v58; // xmm2
  __int128 v59; // xmm3
  unsigned __int64 v60; // rdx
  __int128 v61; // xmm1
  __int128 v62; // xmm2
  __int128 v63; // xmm3
  __int128 v64; // xmm4
  __int128 v65; // xmm5
  __int128 v66; // xmm6
  __int128 v67; // xmm7
  __m128i v68; // xmm1
  __m128i v69; // xmm0
  __m128i v70; // xmm1
  __m128i v71; // xmm0
  __m128i v72; // xmm1
  __m128i v73; // xmm2
  __m128i v74; // xmm3
  __m128i v75; // xmm4
  __m128i v76; // xmm5
  __m128i v77; // xmm6
  __m128i v78; // xmm7
  __m128i v79; // xmm1
  __m128i v80; // xmm0
  __m128i v81; // xmm1
  __m128i v82; // xmm0
  __m128i v83; // xmm1
  __m128i v84; // xmm1
  const __m128i *v85; // rsi
  __m128i *v86; // rdi
  __int64 v87; // rdx
  __m128i v88; // xmm0
  __m128i v89; // xmm1
  __m128i v90; // xmm2
  __m128i v91; // xmm3
  __m128i v92; // xmm4
  __m128i v93; // xmm5
  __m128i v94; // xmm6
  __m128i v95; // xmm7
  __int64 v96; // rdx
  __m128i v97; // xmm0
  __m128i v98; // xmm1
  __m128i v99; // xmm2
  __m128i v100; // xmm3
  __int8 *v101; // rsi
  __int8 *v102; // rdi
  __int64 (__fastcall *v103)(__int8 *, __int8 *, char *, __int64, __m128i *, const __m128i *); // rdx
  __m128i v104; // xmm1
  char *m128i_i8; // rsi
  unsigned __int64 v106; // rdi
  __int64 v107; // rdx
  __m128i v108; // xmm0
  __m128i v109; // xmm1
  __m128i v110; // xmm2
  __m128i v111; // xmm3
  __m128i v112; // xmm4
  __m128i v113; // xmm5
  __m128i v114; // xmm6
  __m128i v115; // xmm7
  __int64 v116; // rdx
  __m128i v117; // xmm0
  __m128i v118; // xmm1
  __m128i v119; // xmm2
  __m128i v120; // xmm3
  __int64 (__fastcall *v121)(unsigned __int64, char *, char *, __int64, __m128i *, const __m128i *); // rdx

  if ( a3 <= 0x4F )
    return ((__int64 (__fastcall *)(__int8 *, __int8 *))((char *)dword_481E30 + dword_481E30[a3]))(
             &a1->m128i_i8[a3],
             &_RSI->m128i_i8[a3]);
  if ( (char)_RSI <= (char)a1 )
  {
    v13 = _mm_loadu_si128((const __m128i *)((char *)_RSI + a3 - 16));
    v14 = &_RSI->m128i_i8[a3];
    v15 = (__m128i *)((char *)a1 + a3 - 16);
    v16 = (unsigned __int64)a1->m128i_u64 + a3;
    v17 = v16 & 0xF;
    v18 = v17 ^ v16;
    v19 = a3 - v17;
    v20 = (const __m128i *)&v14[-v17];
    v21 = _x86_shared_cache_size_half;
    v22 = v20;
    if ( v19 > _x86_shared_cache_size_half )
    {
      v104 = _mm_loadu_si128(v20 - 1);
      m128i_i8 = v20[-1].m128i_i8;
      *v15 = v13;
      *(__m128i *)(v18 - 16) = v104;
      v106 = v18 - 16;
      v107 = v19 - 144;
      do
      {
        v108 = _mm_loadu_si128((const __m128i *)m128i_i8 - 1);
        v109 = _mm_loadu_si128((const __m128i *)m128i_i8 - 2);
        v110 = _mm_loadu_si128((const __m128i *)m128i_i8 - 3);
        v111 = _mm_loadu_si128((const __m128i *)m128i_i8 - 4);
        v112 = _mm_loadu_si128((const __m128i *)m128i_i8 - 5);
        v113 = _mm_loadu_si128((const __m128i *)m128i_i8 - 6);
        v114 = _mm_loadu_si128((const __m128i *)m128i_i8 - 7);
        v115 = _mm_loadu_si128((const __m128i *)m128i_i8 - 8);
        m128i_i8 -= 128;
        v27 = (unsigned __int64)v107 < 0x80;
        v107 -= 128LL;
        _mm_stream_si128((__m128i *)(v106 - 16), v108);
        _mm_stream_si128((__m128i *)(v106 - 32), v109);
        _mm_stream_si128((__m128i *)(v106 - 48), v110);
        _mm_stream_si128((__m128i *)(v106 - 64), v111);
        _mm_stream_si128((__m128i *)(v106 - 80), v112);
        _mm_stream_si128((__m128i *)(v106 - 96), v113);
        _mm_stream_si128((__m128i *)(v106 - 112), v114);
        _mm_stream_si128((__m128i *)(v106 - 128), v115);
        v106 -= 128LL;
      }
      while ( !v27 );
      v36 = v107 < -64;
      v116 = v107 + 128;
      if ( !v36 )
      {
        v117 = _mm_loadu_si128((const __m128i *)m128i_i8 - 1);
        v118 = _mm_loadu_si128((const __m128i *)m128i_i8 - 2);
        v119 = _mm_loadu_si128((const __m128i *)m128i_i8 - 3);
        v120 = _mm_loadu_si128((const __m128i *)m128i_i8 - 4);
        m128i_i8 -= 64;
        _mm_stream_si128((__m128i *)(v106 - 16), v117);
        _mm_stream_si128((__m128i *)(v106 - 32), v118);
        _mm_stream_si128((__m128i *)(v106 - 48), v119);
        _mm_stream_si128((__m128i *)(v106 - 64), v120);
        v106 -= 64LL;
        v116 -= 64LL;
      }
      _mm_sfence();
      v121 = (__int64 (__fastcall *)(unsigned __int64, char *, char *, __int64, __m128i *, const __m128i *))((char *)dword_481E30 + dword_481E30[v116]);
      return v121(v106, m128i_i8, (char *)v121, v21, v15, v22);
    }
    else if ( ((unsigned __int8)v20 & 0xF) != 0 )
    {
      return ((__int64 (__fastcall *)(unsigned __int64, const __m128i *, unsigned __int64, __int64, __m128i *, double))((char *)dword_481FB0 + dword_481FB0[(unsigned __int8)v20 & 0xF]))(
               v18,
               v20,
               v19,
               _x86_data_cache_size_half,
               v15,
               *(double *)v13.m128i_i64);
    }
    else
    {
      v53 = v19 - 16;
      si128 = _mm_load_si128(v20 - 1);
      _RSI = v20[-1].m128i_i8;
      *(__m128i *)(v18 - 16) = si128;
      v56 = v18 - 16;
      *v15 = v13;
      if ( v53 > 0x80 )
      {
        v27 = v53 < _x86_data_cache_size_half;
        v60 = v53 - 128;
        if ( v27 )
        {
          do
          {
            v61 = *((_OWORD *)_RSI - 2);
            v62 = *((_OWORD *)_RSI - 3);
            v63 = *((_OWORD *)_RSI - 4);
            *(__m128i *)(v56 - 16) = _mm_load_si128((const __m128i *)_RSI - 1);
            *(_OWORD *)(v56 - 32) = v61;
            *(_OWORD *)(v56 - 48) = v62;
            *(_OWORD *)(v56 - 64) = v63;
            v27 = v60 < 0x80;
            v60 -= 128LL;
            v64 = *((_OWORD *)_RSI - 5);
            v65 = *((_OWORD *)_RSI - 6);
            v66 = *((_OWORD *)_RSI - 7);
            v67 = *((_OWORD *)_RSI - 8);
            _RSI -= 128;
            *(_OWORD *)(v56 - 80) = v64;
            *(_OWORD *)(v56 - 96) = v65;
            *(_OWORD *)(v56 - 112) = v66;
            *(_OWORD *)(v56 - 128) = v67;
            v56 -= 128LL;
          }
          while ( !v27 );
          v36 = (__int64)v60 < -64;
          v53 = v60 + 128;
          if ( !v36 )
          {
            v53 -= 64LL;
            v68 = _mm_load_si128((const __m128i *)_RSI - 2);
            *(__m128i *)(v56 - 16) = _mm_load_si128((const __m128i *)_RSI - 1);
            *(__m128i *)(v56 - 32) = v68;
            v69 = _mm_load_si128((const __m128i *)_RSI - 3);
            v70 = _mm_load_si128((const __m128i *)_RSI - 4);
            _RSI -= 64;
            *(__m128i *)(v56 - 48) = v69;
            *(__m128i *)(v56 - 64) = v70;
            v56 -= 64LL;
          }
        }
        else
        {
          do
          {
            __asm
            {
              prefetcht0 byte ptr [rsi-1C0h]
              prefetcht0 byte ptr [rsi-280h]
            }
            v71 = _mm_load_si128((const __m128i *)_RSI - 1);
            v72 = _mm_load_si128((const __m128i *)_RSI - 2);
            v73 = _mm_load_si128((const __m128i *)_RSI - 3);
            v74 = _mm_load_si128((const __m128i *)_RSI - 4);
            v75 = _mm_load_si128((const __m128i *)_RSI - 5);
            v76 = _mm_load_si128((const __m128i *)_RSI - 6);
            v77 = _mm_load_si128((const __m128i *)_RSI - 7);
            v78 = _mm_load_si128((const __m128i *)_RSI - 8);
            _RSI -= 128;
            v27 = v60 < 0x80;
            v60 -= 128LL;
            *(__m128i *)(v56 - 16) = v71;
            *(__m128i *)(v56 - 32) = v72;
            *(__m128i *)(v56 - 48) = v73;
            *(__m128i *)(v56 - 64) = v74;
            *(__m128i *)(v56 - 80) = v75;
            *(__m128i *)(v56 - 96) = v76;
            *(__m128i *)(v56 - 112) = v77;
            *(__m128i *)(v56 - 128) = v78;
            v56 -= 128LL;
          }
          while ( !v27 );
          v36 = (__int64)v60 < -64;
          v53 = v60 + 128;
          if ( !v36 )
          {
            v53 -= 64LL;
            v79 = _mm_load_si128((const __m128i *)_RSI - 2);
            *(__m128i *)(v56 - 16) = _mm_load_si128((const __m128i *)_RSI - 1);
            *(__m128i *)(v56 - 32) = v79;
            v80 = _mm_load_si128((const __m128i *)_RSI - 3);
            v81 = _mm_load_si128((const __m128i *)_RSI - 4);
            _RSI -= 64;
            *(__m128i *)(v56 - 48) = v80;
            *(__m128i *)(v56 - 64) = v81;
            v56 -= 64LL;
          }
          if ( v53 >= 0x20 )
          {
            v82 = _mm_load_si128((const __m128i *)_RSI - 1);
            v53 -= 32LL;
            v83 = _mm_load_si128((const __m128i *)_RSI - 2);
            _RSI -= 32;
            *(__m128i *)(v56 - 16) = v82;
            *(__m128i *)(v56 - 32) = v83;
            v56 -= 32LL;
          }
        }
      }
      else if ( v53 >= 0x40 )
      {
        v57 = *((_OWORD *)_RSI - 2);
        v58 = *((_OWORD *)_RSI - 3);
        v59 = *((_OWORD *)_RSI - 4);
        *(_OWORD *)(v56 - 16) = *((_OWORD *)_RSI - 1);
        *(_OWORD *)(v56 - 32) = v57;
        *(_OWORD *)(v56 - 48) = v58;
        *(_OWORD *)(v56 - 64) = v59;
        v53 -= 64LL;
        _RSI -= 64;
        v56 -= 64LL;
      }
      return ((__int64 (__fastcall *)(unsigned __int64, char *))((char *)dword_481E30 + dword_481E30[v53]))(v56, _RSI);
    }
  }
  else
  {
    v3 = _mm_loadu_si128(_RSI);
    v4 = a1;
    v5 = (__m128i *)(((unsigned __int64)a1 & 0xFFFFFFFFFFFFFFF0LL) + 16);
    v6 = v4;
    v7 = (char *)v4 - (char *)v5;
    v8 = v7 + a3;
    v9 = (const __m128i *)((char *)_RSI - v7);
    v10 = _x86_shared_cache_size_half;
    v11 = v9;
    if ( v8 <= _x86_shared_cache_size_half )
    {
      if ( ((unsigned __int8)v9 & 0xF) != 0 )
        return ((__int64 (__fastcall *)(__m128i *, const __m128i *, unsigned __int64, __int64, __m128i *, double))((char *)dword_481F70 + dword_481F70[(unsigned __int8)v9 & 0xF]))(
                 v5,
                 v9,
                 v8,
                 _x86_data_cache_size_half,
                 v6,
                 *(double *)v3.m128i_i64);
      a3 = v8 - 16;
      v23 = _mm_load_si128(v9);
      _RSI = v9 + 1;
      *v5 = v23;
      a1 = v5 + 1;
      *v6 = v3;
      if ( a3 > 0x80 )
      {
        v27 = a3 < _x86_data_cache_size_half;
        v28 = a3 - 128;
        if ( v27 )
        {
          do
          {
            v29 = _RSI[1];
            v30 = _RSI[2];
            v31 = _RSI[3];
            *a1 = _mm_load_si128(_RSI);
            a1[1] = v29;
            a1[2] = v30;
            a1[3] = v31;
            v27 = v28 < 0x80;
            v28 -= 128LL;
            v32 = _RSI[4];
            v33 = _RSI[5];
            v34 = _RSI[6];
            v35 = _RSI[7];
            _RSI += 8;
            a1[4] = v32;
            a1[5] = v33;
            a1[6] = v34;
            a1[7] = v35;
            a1 += 8;
          }
          while ( !v27 );
          v36 = (__int64)v28 < -64;
          a3 = v28 + 128;
          if ( !v36 )
          {
            a3 -= 64LL;
            v37 = _mm_load_si128(_RSI + 1);
            *a1 = _mm_load_si128(_RSI);
            a1[1] = v37;
            v38 = _mm_load_si128(_RSI + 2);
            v39 = _mm_load_si128(_RSI + 3);
            _RSI += 4;
            a1[2] = v38;
            a1[3] = v39;
            a1 += 4;
          }
        }
        else
        {
          do
          {
            __asm
            {
              prefetcht0 byte ptr [rsi+1C0h]
              prefetcht0 byte ptr [rsi+280h]
            }
            v40 = _mm_load_si128(_RSI);
            v41 = _mm_load_si128(_RSI + 1);
            v42 = _mm_load_si128(_RSI + 2);
            v43 = _mm_load_si128(_RSI + 3);
            v44 = _mm_load_si128(_RSI + 4);
            v45 = _mm_load_si128(_RSI + 5);
            v46 = _mm_load_si128(_RSI + 6);
            v47 = _mm_load_si128(_RSI + 7);
            _RSI += 8;
            v27 = v28 < 0x80;
            v28 -= 128LL;
            *a1 = v40;
            a1[1] = v41;
            a1[2] = v42;
            a1[3] = v43;
            a1[4] = v44;
            a1[5] = v45;
            a1[6] = v46;
            a1[7] = v47;
            a1 += 8;
          }
          while ( !v27 );
          v36 = (__int64)v28 < -64;
          a3 = v28 + 128;
          if ( !v36 )
          {
            a3 -= 64LL;
            v48 = _mm_load_si128(_RSI + 1);
            *a1 = _mm_load_si128(_RSI);
            a1[1] = v48;
            v49 = _mm_load_si128(_RSI + 2);
            v50 = _mm_load_si128(_RSI + 3);
            _RSI += 4;
            a1[2] = v49;
            a1[3] = v50;
            a1 += 4;
          }
          if ( a3 >= 0x20 )
          {
            v51 = _mm_load_si128(_RSI);
            a3 -= 32LL;
            v52 = _mm_load_si128(_RSI + 1);
            _RSI += 2;
            *a1 = v51;
            a1[1] = v52;
            a1 += 2;
          }
        }
      }
      else if ( a3 >= 0x40 )
      {
        v24 = _RSI[1];
        v25 = _RSI[2];
        v26 = _RSI[3];
        *a1 = *_RSI;
        a1[1] = v24;
        a1[2] = v25;
        a1[3] = v26;
        a3 -= 64LL;
        _RSI += 4;
        a1 += 4;
      }
      return ((__int64 (__fastcall *)(__int8 *, __int8 *))((char *)dword_481E30 + dword_481E30[a3]))(
               &a1->m128i_i8[a3],
               &_RSI->m128i_i8[a3]);
    }
    v84 = _mm_loadu_si128(v9);
    v85 = v9 + 1;
    *v6 = v3;
    _mm_stream_si128(v5, v84);
    v86 = v5 + 1;
    v87 = v8 - 144;
    do
    {
      v88 = _mm_loadu_si128(v85);
      v89 = _mm_loadu_si128(v85 + 1);
      v90 = _mm_loadu_si128(v85 + 2);
      v91 = _mm_loadu_si128(v85 + 3);
      v92 = _mm_loadu_si128(v85 + 4);
      v93 = _mm_loadu_si128(v85 + 5);
      v94 = _mm_loadu_si128(v85 + 6);
      v95 = _mm_loadu_si128(v85 + 7);
      v85 += 8;
      v27 = (unsigned __int64)v87 < 0x80;
      v87 -= 128LL;
      _mm_stream_si128(v86, v88);
      _mm_stream_si128(v86 + 1, v89);
      _mm_stream_si128(v86 + 2, v90);
      _mm_stream_si128(v86 + 3, v91);
      _mm_stream_si128(v86 + 4, v92);
      _mm_stream_si128(v86 + 5, v93);
      _mm_stream_si128(v86 + 6, v94);
      _mm_stream_si128(v86 + 7, v95);
      v86 += 8;
    }
    while ( !v27 );
    v36 = v87 < -64;
    v96 = v87 + 128;
    if ( !v36 )
    {
      v97 = _mm_loadu_si128(v85);
      v98 = _mm_loadu_si128(v85 + 1);
      v99 = _mm_loadu_si128(v85 + 2);
      v100 = _mm_loadu_si128(v85 + 3);
      v85 += 4;
      _mm_stream_si128(v86, v97);
      _mm_stream_si128(v86 + 1, v98);
      _mm_stream_si128(v86 + 2, v99);
      _mm_stream_si128(v86 + 3, v100);
      v86 += 4;
      v96 -= 64LL;
    }
    v101 = &v85->m128i_i8[v96];
    v102 = &v86->m128i_i8[v96];
    _mm_sfence();
    v103 = (__int64 (__fastcall *)(__int8 *, __int8 *, char *, __int64, __m128i *, const __m128i *))((char *)dword_481E30 + dword_481E30[v96]);
    return v103(v102, v101, (char *)v103, v10, v6, v11);
  }
}
// 481E30: using guessed type int dword_481E30[80];
// 481F70: using guessed type int dword_481F70[16];
// 481FB0: using guessed type int dword_481FB0[16];
// 4A9138: using guessed type __int64 _x86_shared_cache_size_half;
// 4A9158: using guessed type __int64 _x86_data_cache_size_half;

//----- (00000000004240B0) ----------------------------------------------------
__m128i *__fastcall _memmove_chk_ssse3(
        __m128i *a1,
        const __m128i *_RSI,
        unsigned __int64 a3,
        unsigned __int64 a4,
        u32 *a5,
        __int64 a6)
{
  if ( a4 < a3 )
    _chk_fail((__int64)a1, (__int64)_RSI, a3, a4, a5, a6);
  return _memmove_ssse3(a1, _RSI, a3);
}

//----- (00000000004240C0) ----------------------------------------------------
__m128i *__fastcall _memmove_ssse3(__m128i *a1, const __m128i *_RSI, unsigned __int64 a3)
{
  __m128i *result; // rax
  __m128i v4; // xmm0
  __m128i *v5; // rcx
  __m128i *v6; // rdi
  __m128i *v7; // r8
  signed __int64 v8; // rcx
  unsigned __int64 v9; // rdx
  const __m128i *v10; // rsi
  __int64 v11; // rcx
  __m128i v12; // xmm0
  __int8 *v13; // rsi
  __m128i *v14; // r8
  unsigned __int64 v15; // rdi
  unsigned __int64 v16; // rcx
  unsigned __int64 v17; // rdi
  unsigned __int64 v18; // rdx
  const __m128i *v19; // rsi
  unsigned __int64 v20; // rcx
  __m128i si128; // xmm1
  __m128i v22; // xmm1
  __m128i v23; // xmm2
  __m128i v24; // xmm3
  bool v25; // cf
  unsigned __int64 v26; // rdx
  __m128i v27; // xmm1
  __m128i v28; // xmm2
  __m128i v29; // xmm3
  __m128i v30; // xmm4
  __m128i v31; // xmm5
  __m128i v32; // xmm6
  __m128i v33; // xmm7
  bool v34; // cc
  __m128i v35; // xmm1
  __m128i v36; // xmm4
  __m128i v37; // xmm1
  __m128i v38; // xmm0
  __m128i v39; // xmm1
  __m128i v40; // xmm2
  __m128i v41; // xmm3
  __m128i v42; // xmm4
  __m128i v43; // xmm5
  __m128i v44; // xmm6
  __m128i v45; // xmm7
  __m128i v46; // xmm1
  __m128i v47; // xmm0
  __m128i v48; // xmm1
  __m128i v49; // xmm0
  __m128i v50; // xmm1
  unsigned __int64 v51; // rdx
  __m128i v52; // xmm1
  unsigned __int64 v54; // rdi
  __int128 v55; // xmm1
  __int128 v56; // xmm2
  __int128 v57; // xmm3
  unsigned __int64 v58; // rdx
  __int128 v59; // xmm1
  __int128 v60; // xmm2
  __int128 v61; // xmm3
  __int128 v62; // xmm4
  __int128 v63; // xmm5
  __int128 v64; // xmm6
  __int128 v65; // xmm7
  __m128i v66; // xmm1
  __m128i v67; // xmm0
  __m128i v68; // xmm1
  __m128i v69; // xmm0
  __m128i v70; // xmm1
  __m128i v71; // xmm2
  __m128i v72; // xmm3
  __m128i v73; // xmm4
  __m128i v74; // xmm5
  __m128i v75; // xmm6
  __m128i v76; // xmm7
  __m128i v77; // xmm1
  __m128i v78; // xmm0
  __m128i v79; // xmm1
  __m128i v80; // xmm0
  __m128i v81; // xmm1
  __m128i v82; // xmm1
  unsigned __int64 v83; // rdx
  __m128i v84; // xmm0
  __m128i v85; // xmm1
  __m128i v86; // xmm2
  __m128i v87; // xmm3
  __m128i v88; // xmm4
  __m128i v89; // xmm5
  __m128i v90; // xmm6
  __m128i v91; // xmm7
  unsigned __int64 v92; // rdx
  __m128i v93; // xmm0
  __m128i v94; // xmm1
  __m128i v95; // xmm2
  __m128i v96; // xmm3
  __m128i v97; // xmm0
  __m128i v98; // xmm1
  __m128i v99; // xmm2
  __m128i v100; // xmm3
  __m128i v101; // xmm4
  __m128i v102; // xmm5
  __m128i v103; // xmm6
  __m128i v104; // xmm7
  __m128i v105; // xmm0
  __m128i v106; // xmm1
  __m128i v107; // xmm2
  __m128i v108; // xmm3
  __m128i v109; // xmm1
  unsigned __int64 v110; // rdx
  __m128i v111; // xmm0
  __m128i v112; // xmm1
  __m128i v113; // xmm2
  __m128i v114; // xmm3
  __m128i v115; // xmm4
  __m128i v116; // xmm5
  __m128i v117; // xmm6
  __m128i v118; // xmm7
  unsigned __int64 v119; // rdx
  __m128i v120; // xmm0
  __m128i v121; // xmm1
  __m128i v122; // xmm2
  __m128i v123; // xmm3
  __m128i v124; // xmm0
  __m128i v125; // xmm1
  __m128i v126; // xmm2
  __m128i v127; // xmm3
  __m128i v128; // xmm4
  __m128i v129; // xmm5
  __m128i v130; // xmm6
  __m128i v131; // xmm7
  __m128i v132; // xmm0
  __m128i v133; // xmm1
  __m128i v134; // xmm2
  __m128i v135; // xmm3

  result = a1;
  if ( a1 < _RSI )
    goto LABEL_4;
  if ( a1 == _RSI )
    return result;
  if ( a3 <= 0x4F )
  {
LABEL_4:
    if ( a3 > 0x4F )
    {
      v4 = _mm_loadu_si128(_RSI);
      v5 = a1;
      v6 = (__m128i *)(((unsigned __int64)a1 & 0xFFFFFFFFFFFFFFF0LL) + 16);
      v7 = v5;
      v8 = (char *)v5 - (char *)v6;
      v9 = v8 + a3;
      v10 = (const __m128i *)((char *)_RSI - v8);
      v11 = _x86_shared_cache_size_half;
      if ( v9 <= _x86_shared_cache_size_half )
      {
        if ( ((unsigned __int8)v10 & 0xF) != 0 )
          return (__m128i *)((__int64 (__fastcall *)(__m128i *, const __m128i *, unsigned __int64, __int64, __m128i *, double))((char *)dword_482130 + dword_482130[(unsigned __int8)v10 & 0xF]))(
                              v6,
                              v10,
                              v9,
                              _x86_data_cache_size_half,
                              v7,
                              *(double *)v4.m128i_i64);
        a3 = v9 - 16;
        si128 = _mm_load_si128(v10);
        _RSI = v10 + 1;
        *v6 = si128;
        a1 = v6 + 1;
        *v7 = v4;
        if ( a3 > 0x80 )
        {
          v25 = a3 < _x86_data_cache_size_half;
          v26 = a3 - 128;
          if ( v25 )
          {
            do
            {
              v27 = _RSI[1];
              v28 = _RSI[2];
              v29 = _RSI[3];
              *a1 = _mm_load_si128(_RSI);
              a1[1] = v27;
              a1[2] = v28;
              a1[3] = v29;
              v25 = v26 < 0x80;
              v26 -= 128LL;
              v30 = _RSI[4];
              v31 = _RSI[5];
              v32 = _RSI[6];
              v33 = _RSI[7];
              _RSI += 8;
              a1[4] = v30;
              a1[5] = v31;
              a1[6] = v32;
              a1[7] = v33;
              a1 += 8;
            }
            while ( !v25 );
            v34 = (__int64)v26 < -64;
            a3 = v26 + 128;
            if ( !v34 )
            {
              a3 -= 64LL;
              v35 = _mm_load_si128(_RSI + 1);
              *a1 = _mm_load_si128(_RSI);
              a1[1] = v35;
              v36 = _mm_load_si128(_RSI + 2);
              v37 = _mm_load_si128(_RSI + 3);
              _RSI += 4;
              a1[2] = v36;
              a1[3] = v37;
              a1 += 4;
            }
          }
          else
          {
            do
            {
              __asm
              {
                prefetcht0 byte ptr [rsi+1C0h]
                prefetcht0 byte ptr [rsi+280h]
              }
              v38 = _mm_load_si128(_RSI);
              v39 = _mm_load_si128(_RSI + 1);
              v40 = _mm_load_si128(_RSI + 2);
              v41 = _mm_load_si128(_RSI + 3);
              v42 = _mm_load_si128(_RSI + 4);
              v43 = _mm_load_si128(_RSI + 5);
              v44 = _mm_load_si128(_RSI + 6);
              v45 = _mm_load_si128(_RSI + 7);
              _RSI += 8;
              v25 = v26 < 0x80;
              v26 -= 128LL;
              *a1 = v38;
              a1[1] = v39;
              a1[2] = v40;
              a1[3] = v41;
              a1[4] = v42;
              a1[5] = v43;
              a1[6] = v44;
              a1[7] = v45;
              a1 += 8;
            }
            while ( !v25 );
            v34 = (__int64)v26 < -64;
            a3 = v26 + 128;
            if ( !v34 )
            {
              a3 -= 64LL;
              v46 = _mm_load_si128(_RSI + 1);
              *a1 = _mm_load_si128(_RSI);
              a1[1] = v46;
              v47 = _mm_load_si128(_RSI + 2);
              v48 = _mm_load_si128(_RSI + 3);
              _RSI += 4;
              a1[2] = v47;
              a1[3] = v48;
              a1 += 4;
            }
            if ( a3 >= 0x20 )
            {
              v49 = _mm_load_si128(_RSI);
              a3 -= 32LL;
              v50 = _mm_load_si128(_RSI + 1);
              _RSI += 2;
              *a1 = v49;
              a1[1] = v50;
              a1 += 2;
            }
          }
        }
        else if ( a3 >= 0x40 )
        {
          v22 = _RSI[1];
          v23 = _RSI[2];
          v24 = _RSI[3];
          *a1 = *_RSI;
          a1[1] = v22;
          a1[2] = v23;
          a1[3] = v24;
          a3 -= 64LL;
          _RSI += 4;
          a1 += 4;
        }
        return (__m128i *)((__int64 (__fastcall *)(__int8 *, __int8 *))((char *)dword_481FF0 + dword_481FF0[a3]))(
                            &a1->m128i_i8[a3],
                            &_RSI->m128i_i8[a3]);
      }
      v82 = _mm_loadu_si128(v10);
      _RSI = v10 + 1;
      *v7 = v4;
      _mm_stream_si128(v6, v82);
      a1 = v6 + 1;
      v83 = v9 - 144;
      if ( (char *)_RSI - (char *)a1 >= v83 || v83 >= 4 * v11 )
      {
        do
        {
          v84 = _mm_loadu_si128(_RSI);
          v85 = _mm_loadu_si128(_RSI + 1);
          v86 = _mm_loadu_si128(_RSI + 2);
          v87 = _mm_loadu_si128(_RSI + 3);
          v88 = _mm_loadu_si128(_RSI + 4);
          v89 = _mm_loadu_si128(_RSI + 5);
          v90 = _mm_loadu_si128(_RSI + 6);
          v91 = _mm_loadu_si128(_RSI + 7);
          _RSI += 8;
          v25 = v83 < 0x80;
          v83 -= 128LL;
          _mm_stream_si128(a1, v84);
          _mm_stream_si128(a1 + 1, v85);
          _mm_stream_si128(a1 + 2, v86);
          _mm_stream_si128(a1 + 3, v87);
          _mm_stream_si128(a1 + 4, v88);
          _mm_stream_si128(a1 + 5, v89);
          _mm_stream_si128(a1 + 6, v90);
          _mm_stream_si128(a1 + 7, v91);
          a1 += 8;
        }
        while ( !v25 );
        v34 = (__int64)v83 < -64;
        v92 = v83 + 128;
        if ( !v34 )
        {
          v93 = _mm_loadu_si128(_RSI);
          v94 = _mm_loadu_si128(_RSI + 1);
          v95 = _mm_loadu_si128(_RSI + 2);
          v96 = _mm_loadu_si128(_RSI + 3);
          _RSI += 4;
          _mm_stream_si128(a1, v93);
          _mm_stream_si128(a1 + 1, v94);
          _mm_stream_si128(a1 + 2, v95);
          _mm_stream_si128(a1 + 3, v96);
          a1 += 4;
          v92 -= 64LL;
        }
        _mm_sfence();
        return (__m128i *)((__int64 (__fastcall *)(__int8 *, __int8 *))((char *)dword_481FF0 + dword_481FF0[v92]))(
                            &a1->m128i_i8[v92],
                            &_RSI->m128i_i8[v92]);
      }
      do
      {
        __asm
        {
          prefetcht0 byte ptr [rsi+1C0h]
          prefetcht0 byte ptr [rsi+200h]
        }
        v97 = _mm_loadu_si128(_RSI);
        v98 = _mm_loadu_si128(_RSI + 1);
        v99 = _mm_loadu_si128(_RSI + 2);
        v100 = _mm_loadu_si128(_RSI + 3);
        v101 = _mm_loadu_si128(_RSI + 4);
        v102 = _mm_loadu_si128(_RSI + 5);
        v103 = _mm_loadu_si128(_RSI + 6);
        v104 = _mm_loadu_si128(_RSI + 7);
        _RSI += 8;
        v25 = v83 < 0x80;
        v83 -= 128LL;
        *a1 = v97;
        a1[1] = v98;
        a1[2] = v99;
        a1[3] = v100;
        a1[4] = v101;
        a1[5] = v102;
        a1[6] = v103;
        a1[7] = v104;
        a1 += 8;
      }
      while ( !v25 );
      v34 = (__int64)v83 < -64;
      a3 = v83 + 128;
      if ( !v34 )
      {
        v105 = _mm_loadu_si128(_RSI);
        v106 = _mm_loadu_si128(_RSI + 1);
        v107 = _mm_loadu_si128(_RSI + 2);
        v108 = _mm_loadu_si128(_RSI + 3);
        _RSI += 4;
        *a1 = v105;
        a1[1] = v106;
        a1[2] = v107;
        a1[3] = v108;
        a1 += 4;
        a3 -= 64LL;
      }
    }
    return (__m128i *)((__int64 (__fastcall *)(__int8 *, __int8 *))((char *)dword_481FF0 + dword_481FF0[a3]))(
                        &a1->m128i_i8[a3],
                        &_RSI->m128i_i8[a3]);
  }
  v12 = _mm_loadu_si128((const __m128i *)((char *)_RSI + a3 - 16));
  v13 = &_RSI->m128i_i8[a3];
  v14 = (__m128i *)((char *)a1 + a3 - 16);
  v15 = (unsigned __int64)a1->m128i_u64 + a3;
  v16 = v15 & 0xF;
  v17 = v16 ^ v15;
  v18 = a3 - v16;
  v19 = (const __m128i *)&v13[-v16];
  v20 = _x86_shared_cache_size_half;
  if ( v18 <= _x86_shared_cache_size_half )
  {
    if ( ((unsigned __int8)v19 & 0xF) != 0 )
      return (__m128i *)((__int64 (__fastcall *)(unsigned __int64, const __m128i *, unsigned __int64, __int64, __m128i *, double))((char *)dword_482170 + dword_482170[(unsigned __int8)v19 & 0xF]))(
                          v17,
                          v19,
                          v18,
                          _x86_data_cache_size_half,
                          v14,
                          *(double *)v12.m128i_i64);
    v51 = v18 - 16;
    v52 = _mm_load_si128(v19 - 1);
    _RSI = v19[-1].m128i_i8;
    *(__m128i *)(v17 - 16) = v52;
    v54 = v17 - 16;
    *v14 = v12;
    if ( v51 > 0x80 )
    {
      v25 = v51 < _x86_data_cache_size_half;
      v58 = v51 - 128;
      if ( v25 )
      {
        do
        {
          v59 = *((_OWORD *)_RSI - 2);
          v60 = *((_OWORD *)_RSI - 3);
          v61 = *((_OWORD *)_RSI - 4);
          *(__m128i *)(v54 - 16) = _mm_load_si128((const __m128i *)_RSI - 1);
          *(_OWORD *)(v54 - 32) = v59;
          *(_OWORD *)(v54 - 48) = v60;
          *(_OWORD *)(v54 - 64) = v61;
          v25 = v58 < 0x80;
          v58 -= 128LL;
          v62 = *((_OWORD *)_RSI - 5);
          v63 = *((_OWORD *)_RSI - 6);
          v64 = *((_OWORD *)_RSI - 7);
          v65 = *((_OWORD *)_RSI - 8);
          _RSI -= 128;
          *(_OWORD *)(v54 - 80) = v62;
          *(_OWORD *)(v54 - 96) = v63;
          *(_OWORD *)(v54 - 112) = v64;
          *(_OWORD *)(v54 - 128) = v65;
          v54 -= 128LL;
        }
        while ( !v25 );
        v34 = (__int64)v58 < -64;
        v51 = v58 + 128;
        if ( !v34 )
        {
          v51 -= 64LL;
          v66 = _mm_load_si128((const __m128i *)_RSI - 2);
          *(__m128i *)(v54 - 16) = _mm_load_si128((const __m128i *)_RSI - 1);
          *(__m128i *)(v54 - 32) = v66;
          v67 = _mm_load_si128((const __m128i *)_RSI - 3);
          v68 = _mm_load_si128((const __m128i *)_RSI - 4);
          _RSI -= 64;
          *(__m128i *)(v54 - 48) = v67;
          *(__m128i *)(v54 - 64) = v68;
          v54 -= 64LL;
        }
      }
      else
      {
        do
        {
          __asm
          {
            prefetcht0 byte ptr [rsi-1C0h]
            prefetcht0 byte ptr [rsi-280h]
          }
          v69 = _mm_load_si128((const __m128i *)_RSI - 1);
          v70 = _mm_load_si128((const __m128i *)_RSI - 2);
          v71 = _mm_load_si128((const __m128i *)_RSI - 3);
          v72 = _mm_load_si128((const __m128i *)_RSI - 4);
          v73 = _mm_load_si128((const __m128i *)_RSI - 5);
          v74 = _mm_load_si128((const __m128i *)_RSI - 6);
          v75 = _mm_load_si128((const __m128i *)_RSI - 7);
          v76 = _mm_load_si128((const __m128i *)_RSI - 8);
          _RSI -= 128;
          v25 = v58 < 0x80;
          v58 -= 128LL;
          *(__m128i *)(v54 - 16) = v69;
          *(__m128i *)(v54 - 32) = v70;
          *(__m128i *)(v54 - 48) = v71;
          *(__m128i *)(v54 - 64) = v72;
          *(__m128i *)(v54 - 80) = v73;
          *(__m128i *)(v54 - 96) = v74;
          *(__m128i *)(v54 - 112) = v75;
          *(__m128i *)(v54 - 128) = v76;
          v54 -= 128LL;
        }
        while ( !v25 );
        v34 = (__int64)v58 < -64;
        v51 = v58 + 128;
        if ( !v34 )
        {
          v51 -= 64LL;
          v77 = _mm_load_si128((const __m128i *)_RSI - 2);
          *(__m128i *)(v54 - 16) = _mm_load_si128((const __m128i *)_RSI - 1);
          *(__m128i *)(v54 - 32) = v77;
          v78 = _mm_load_si128((const __m128i *)_RSI - 3);
          v79 = _mm_load_si128((const __m128i *)_RSI - 4);
          _RSI -= 64;
          *(__m128i *)(v54 - 48) = v78;
          *(__m128i *)(v54 - 64) = v79;
          v54 -= 64LL;
        }
        if ( v51 >= 0x20 )
        {
          v80 = _mm_load_si128((const __m128i *)_RSI - 1);
          v51 -= 32LL;
          v81 = _mm_load_si128((const __m128i *)_RSI - 2);
          _RSI -= 32;
          *(__m128i *)(v54 - 16) = v80;
          *(__m128i *)(v54 - 32) = v81;
          v54 -= 32LL;
        }
      }
    }
    else if ( v51 >= 0x40 )
    {
      v55 = *((_OWORD *)_RSI - 2);
      v56 = *((_OWORD *)_RSI - 3);
      v57 = *((_OWORD *)_RSI - 4);
      *(_OWORD *)(v54 - 16) = *((_OWORD *)_RSI - 1);
      *(_OWORD *)(v54 - 32) = v55;
      *(_OWORD *)(v54 - 48) = v56;
      *(_OWORD *)(v54 - 64) = v57;
      v51 -= 64LL;
      _RSI -= 64;
      v54 -= 64LL;
    }
    return (__m128i *)((__int64 (__fastcall *)(unsigned __int64, char *))((char *)dword_481FF0 + dword_481FF0[v51]))(
                        v54,
                        _RSI);
  }
  v109 = _mm_loadu_si128(v19 - 1);
  _RSI = v19[-1].m128i_i8;
  *v14 = v12;
  *(__m128i *)(v17 - 16) = v109;
  v54 = v17 - 16;
  v110 = v18 - 144;
  if ( v54 - (unsigned __int64)_RSI < v110 && v54 - (unsigned __int64)_RSI < v20 )
  {
    do
    {
      __asm
      {
        prefetcht0 byte ptr [rsi-1C0h]
        prefetcht0 byte ptr [rsi-200h]
      }
      v124 = _mm_loadu_si128((const __m128i *)_RSI - 1);
      v125 = _mm_loadu_si128((const __m128i *)_RSI - 2);
      v126 = _mm_loadu_si128((const __m128i *)_RSI - 3);
      v127 = _mm_loadu_si128((const __m128i *)_RSI - 4);
      v128 = _mm_loadu_si128((const __m128i *)_RSI - 5);
      v129 = _mm_loadu_si128((const __m128i *)_RSI - 6);
      v130 = _mm_loadu_si128((const __m128i *)_RSI - 7);
      v131 = _mm_loadu_si128((const __m128i *)_RSI - 8);
      _RSI -= 128;
      v25 = v110 < 0x80;
      v110 -= 128LL;
      *(__m128i *)(v54 - 16) = v124;
      *(__m128i *)(v54 - 32) = v125;
      *(__m128i *)(v54 - 48) = v126;
      *(__m128i *)(v54 - 64) = v127;
      *(__m128i *)(v54 - 80) = v128;
      *(__m128i *)(v54 - 96) = v129;
      *(__m128i *)(v54 - 112) = v130;
      *(__m128i *)(v54 - 128) = v131;
      v54 -= 128LL;
    }
    while ( !v25 );
    v34 = (__int64)v110 < -64;
    v51 = v110 + 128;
    if ( !v34 )
    {
      v132 = _mm_loadu_si128((const __m128i *)_RSI - 1);
      v133 = _mm_loadu_si128((const __m128i *)_RSI - 2);
      v134 = _mm_loadu_si128((const __m128i *)_RSI - 3);
      v135 = _mm_loadu_si128((const __m128i *)_RSI - 4);
      _RSI -= 64;
      *(__m128i *)(v54 - 16) = v132;
      *(__m128i *)(v54 - 32) = v133;
      *(__m128i *)(v54 - 48) = v134;
      *(__m128i *)(v54 - 64) = v135;
      v54 -= 64LL;
      v51 -= 64LL;
    }
    return (__m128i *)((__int64 (__fastcall *)(unsigned __int64, char *))((char *)dword_481FF0 + dword_481FF0[v51]))(
                        v54,
                        _RSI);
  }
  do
  {
    v111 = _mm_loadu_si128((const __m128i *)_RSI - 1);
    v112 = _mm_loadu_si128((const __m128i *)_RSI - 2);
    v113 = _mm_loadu_si128((const __m128i *)_RSI - 3);
    v114 = _mm_loadu_si128((const __m128i *)_RSI - 4);
    v115 = _mm_loadu_si128((const __m128i *)_RSI - 5);
    v116 = _mm_loadu_si128((const __m128i *)_RSI - 6);
    v117 = _mm_loadu_si128((const __m128i *)_RSI - 7);
    v118 = _mm_loadu_si128((const __m128i *)_RSI - 8);
    _RSI -= 128;
    v25 = v110 < 0x80;
    v110 -= 128LL;
    _mm_stream_si128((__m128i *)(v54 - 16), v111);
    _mm_stream_si128((__m128i *)(v54 - 32), v112);
    _mm_stream_si128((__m128i *)(v54 - 48), v113);
    _mm_stream_si128((__m128i *)(v54 - 64), v114);
    _mm_stream_si128((__m128i *)(v54 - 80), v115);
    _mm_stream_si128((__m128i *)(v54 - 96), v116);
    _mm_stream_si128((__m128i *)(v54 - 112), v117);
    _mm_stream_si128((__m128i *)(v54 - 128), v118);
    v54 -= 128LL;
  }
  while ( !v25 );
  v34 = (__int64)v110 < -64;
  v119 = v110 + 128;
  if ( !v34 )
  {
    v120 = _mm_loadu_si128((const __m128i *)_RSI - 1);
    v121 = _mm_loadu_si128((const __m128i *)_RSI - 2);
    v122 = _mm_loadu_si128((const __m128i *)_RSI - 3);
    v123 = _mm_loadu_si128((const __m128i *)_RSI - 4);
    _RSI -= 64;
    _mm_stream_si128((__m128i *)(v54 - 16), v120);
    _mm_stream_si128((__m128i *)(v54 - 32), v121);
    _mm_stream_si128((__m128i *)(v54 - 48), v122);
    _mm_stream_si128((__m128i *)(v54 - 64), v123);
    v54 -= 64LL;
    v119 -= 64LL;
  }
  _mm_sfence();
  return (__m128i *)((__int64 (__fastcall *)(unsigned __int64, char *))((char *)dword_481FF0 + dword_481FF0[v119]))(
                      v54,
                      _RSI);
}
// 481FF0: using guessed type int dword_481FF0[80];
// 482130: using guessed type int dword_482130[16];
// 482170: using guessed type int dword_482170[16];
// 4A9138: using guessed type __int64 _x86_shared_cache_size_half;
// 4A9158: using guessed type __int64 _x86_data_cache_size_half;

//----- (0000000000426C40) ----------------------------------------------------
void __fastcall _mempcpy_chk_ssse3_back(
        __int64 a1,
        __int64 a2,
        unsigned __int64 a3,
        unsigned __int64 a4,
        u32 *a5,
        __int64 a6)
{
  if ( a4 < a3 )
    _chk_fail(a1, a2, a3, a4, a5, a6);
  _mempcpy_ssse3_back();
}

//----- (0000000000426C50) ----------------------------------------------------
void _mempcpy_ssse3_back()
{
  JUMPOUT(0x426C77LL);
}
// 426C5A: control flows out of bounds to 426C77

//----- (0000000000426C60) ----------------------------------------------------
__int64 __fastcall _memcpy_chk_ssse3_back(
        __m128i *a1,
        const __m128i *a2,
        unsigned __int64 a3,
        unsigned __int64 a4,
        u32 *a5,
        __int64 a6)
{
  if ( a4 < a3 )
    _chk_fail((__int64)a1, (__int64)a2, a3, a4, a5, a6);
  return _memcpy_ssse3_back(a1, a2, a3);
}

//----- (0000000000426C70) ----------------------------------------------------
__int64 __fastcall _memcpy_ssse3_back(__m128i *a1, const __m128i *a2, unsigned __int64 a3)
{
  __m128i v4; // xmm0
  __m128i *v6; // rdi
  unsigned __int64 v7; // rdx
  const __m128i *v8; // rsi
  unsigned __int64 v9; // rdi
  const __m128i *v10; // rsi
  __m128i v11; // xmm0
  __m128i *v12; // r8
  unsigned __int64 v13; // r9
  unsigned __int64 v16; // rdx
  unsigned __int64 v17; // rdx
  bool v18; // cf
  unsigned __int64 v19; // rdx
  __m128i v20; // xmm1
  unsigned __int64 v21; // rdx
  unsigned __int64 v24; // rcx
  unsigned __int64 v25; // rdx
  unsigned __int64 v26; // rdx
  __m128i v27; // xmm0
  __m128i v28; // xmm1
  __m128i v29; // xmm2
  __m128i v30; // xmm3
  __m128i v31; // xmm4
  __m128i v32; // xmm5
  __m128i v33; // xmm6
  __m128i v34; // xmm7
  __m128i v35; // xmm1
  __m128i v36; // xmm2
  __m128i v37; // xmm3
  __m128i v38; // xmm4
  __m128i v39; // xmm5
  __m128i v40; // xmm6
  __m128i v41; // xmm7
  const __m128i *v42; // rsi
  unsigned __int64 v43; // rdi
  unsigned __int64 v44; // r9
  unsigned __int64 v45; // r9
  unsigned __int64 v46; // rdx
  unsigned __int64 v47; // rcx
  unsigned __int64 v48; // rdx
  __m128i v49; // xmm1
  __m128i v50; // xmm2
  __m128i v51; // xmm3
  __m128i v52; // xmm4
  __m128i v53; // xmm5
  __m128i v54; // xmm6
  __m128i v55; // xmm7
  __m128i v56; // xmm8
  __m128i v57; // xmm2
  __m128i v58; // xmm3
  __m128i v59; // xmm4
  __m128i v60; // xmm5
  __m128i v61; // xmm6
  __m128i v62; // xmm7
  __m128i v63; // xmm8

  if ( a3 < 0x90 )
  {
    if ( (unsigned __int8)a2 <= (unsigned __int8)a1 )
      return ((__int64 (*)(void))((char *)dword_4821B0 + dword_4821B0[a3]))();
    else
      return ((__int64 (__fastcall *)(__int8 *, __int8 *))((char *)dword_4823F0 + dword_4823F0[a3]))(
               &a1->m128i_i8[a3],
               &a2->m128i_i8[a3]);
  }
  if ( (char)a2 <= (char)a1 )
  {
    if ( a3 <= 2 * _x86_data_cache_size )
    {
      v9 = (unsigned __int64)a1->m128i_u64 + a3;
      v10 = (const __m128i *)((char *)a2 + a3);
      v11 = _mm_loadu_si128(v10 - 1);
      v12 = (__m128i *)(v9 - 16);
      v13 = v9 & 0xF;
      _RDI = v13 ^ v9;
      _RSI = &v10->m128i_i8[-v13];
      v16 = a3 - v13;
      if ( ((unsigned __int8)_RSI & 0xF) != 0 )
        return ((__int64 (__fastcall *)(unsigned __int64, char *, unsigned __int64, __int64, __m128i *, double))((char *)dword_482670 + dword_482670[(unsigned __int8)_RSI & 0xF]))(
                 _RDI,
                 _RSI,
                 v16 - 128,
                 2 * _x86_data_cache_size,
                 v12,
                 *(double *)v11.m128i_i64);
      v19 = v16 - 128;
      do
      {
        *(_OWORD *)(_RDI - 16) = *((_OWORD *)_RSI - 1);
        *(_OWORD *)(_RDI - 32) = *((_OWORD *)_RSI - 2);
        *(_OWORD *)(_RDI - 48) = *((_OWORD *)_RSI - 3);
        *(_OWORD *)(_RDI - 64) = *((_OWORD *)_RSI - 4);
        *(_OWORD *)(_RDI - 80) = *((_OWORD *)_RSI - 5);
        *(_OWORD *)(_RDI - 96) = *((_OWORD *)_RSI - 6);
        *(_OWORD *)(_RDI - 112) = *((_OWORD *)_RSI - 7);
        *(_OWORD *)(_RDI - 128) = *((_OWORD *)_RSI - 8);
        v18 = v19 < 0x80;
        v19 -= 128LL;
        _RDI -= 128LL;
        _RSI -= 128;
      }
      while ( !v18 );
      goto LABEL_42;
    }
    v42 = (const __m128i *)((char *)a2 + a3);
    v43 = (unsigned __int64)a1->m128i_u64 + a3;
    v11 = _mm_loadu_si128(v42 - 1);
    v12 = (__m128i *)(v43 - 16);
    v44 = v43;
    _RDI = v43 & 0xFFFFFFFFFFFFFFF0LL;
    v45 = v44 - _RDI;
    _RSI = &v42->m128i_i8[-v45];
    v46 = a3 - v45;
    v47 = _x86_shared_cache_size_half;
    if ( v46 <= _x86_shared_cache_size_half )
      v47 = v46;
    v48 = v46 - v47;
    if ( v48 > 0x1000 )
    {
      if ( v48 > 8 * v47 )
      {
        v48 += v47;
        v47 = 0LL;
      }
      v19 = v48 - 128;
      do
      {
        v18 = v19 < 0x80;
        v19 -= 128LL;
        __asm
        {
          prefetcht0 byte ptr [rsi-200h]
          prefetcht0 byte ptr [rsi-300h]
        }
        v49 = _mm_loadu_si128((const __m128i *)_RSI - 1);
        v50 = _mm_loadu_si128((const __m128i *)_RSI - 2);
        v51 = _mm_loadu_si128((const __m128i *)_RSI - 3);
        v52 = _mm_loadu_si128((const __m128i *)_RSI - 4);
        v53 = _mm_loadu_si128((const __m128i *)_RSI - 5);
        v54 = _mm_loadu_si128((const __m128i *)_RSI - 6);
        v55 = _mm_loadu_si128((const __m128i *)_RSI - 7);
        v56 = _mm_loadu_si128((const __m128i *)_RSI - 8);
        _mm_lfence();
        _mm_stream_si128((__m128i *)(_RDI - 16), v49);
        _mm_stream_si128((__m128i *)(_RDI - 32), v50);
        _mm_stream_si128((__m128i *)(_RDI - 48), v51);
        _mm_stream_si128((__m128i *)(_RDI - 64), v52);
        _mm_stream_si128((__m128i *)(_RDI - 80), v53);
        _mm_stream_si128((__m128i *)(_RDI - 96), v54);
        _mm_stream_si128((__m128i *)(_RDI - 112), v55);
        _mm_stream_si128((__m128i *)(_RDI - 128), v56);
        _RSI -= 128;
        _RDI -= 128LL;
      }
      while ( !v18 );
      _mm_sfence();
      if ( v47 < 0x80 )
        goto LABEL_42;
      v48 = v19 + 128;
    }
    v19 = v47 + v48 - 128;
    do
    {
      __asm
      {
        prefetchnta byte ptr [rsi-1C0h]
        prefetchnta byte ptr [rsi-280h]
        prefetchnta byte ptr [rdi-1C0h]
        prefetchnta byte ptr [rdi-280h]
      }
      v18 = v19 < 0x80;
      v19 -= 128LL;
      v57 = _mm_loadu_si128((const __m128i *)_RSI - 2);
      v58 = _mm_loadu_si128((const __m128i *)_RSI - 3);
      v59 = _mm_loadu_si128((const __m128i *)_RSI - 4);
      v60 = _mm_loadu_si128((const __m128i *)_RSI - 5);
      v61 = _mm_loadu_si128((const __m128i *)_RSI - 6);
      v62 = _mm_loadu_si128((const __m128i *)_RSI - 7);
      v63 = _mm_loadu_si128((const __m128i *)_RSI - 8);
      *(__m128i *)(_RDI - 16) = _mm_loadu_si128((const __m128i *)_RSI - 1);
      *(__m128i *)(_RDI - 32) = v57;
      *(__m128i *)(_RDI - 48) = v58;
      *(__m128i *)(_RDI - 64) = v59;
      *(__m128i *)(_RDI - 80) = v60;
      *(__m128i *)(_RDI - 96) = v61;
      *(__m128i *)(_RDI - 112) = v62;
      *(__m128i *)(_RDI - 128) = v63;
      _RSI -= 128;
      _RDI -= 128LL;
    }
    while ( !v18 );
LABEL_42:
    *v12 = v11;
    return ((__int64 (__fastcall *)(unsigned __int64, char *))((char *)dword_4821B0 + dword_4821B0[v19 + 128]))(
             _RDI - (v19 + 128),
             &_RSI[-v19 - 128]);
  }
  v4 = _mm_loadu_si128(a2);
  v6 = (__m128i *)(((unsigned __int64)a1 & 0xFFFFFFFFFFFFFFF0LL) + 16);
  v7 = a3 - ((char *)v6 - (char *)a1);
  v8 = (const __m128i *)((char *)a2 + (char *)v6 - (char *)a1);
  if ( ((unsigned __int8)v8 & 0xF) != 0 )
  {
    if ( v7 < _x86_data_cache_size )
      return ((__int64 (__fastcall *)(__m128i *, const __m128i *, unsigned __int64, double))((char *)dword_482630
                                                                                           + dword_482630[(unsigned __int8)v8 & 0xF]))(
               v6,
               v8,
               v7 - 128,
               *(double *)v4.m128i_i64);
LABEL_19:
    v20 = _mm_loadu_si128(v8);
    *a1 = v4;
    *v6 = v20;
    v21 = v7 - 16;
    _RSI = v8 + 1;
    _RDI = v6 + 1;
    v24 = _x86_shared_cache_size_half;
    if ( v21 <= _x86_shared_cache_size_half )
      v24 = v21;
    v25 = v21 - v24;
    if ( v25 > 0x1000 )
    {
      if ( v25 > 8 * v24 )
      {
        v25 += v24;
        v24 = 0LL;
      }
      v26 = v25 - 128;
      do
      {
        v18 = v26 < 0x80;
        v26 -= 128LL;
        __asm
        {
          prefetcht0 byte ptr [rsi+200h]
          prefetcht0 byte ptr [rsi+300h]
        }
        v27 = _mm_loadu_si128(_RSI);
        v28 = _mm_loadu_si128(_RSI + 1);
        v29 = _mm_loadu_si128(_RSI + 2);
        v30 = _mm_loadu_si128(_RSI + 3);
        v31 = _mm_loadu_si128(_RSI + 4);
        v32 = _mm_loadu_si128(_RSI + 5);
        v33 = _mm_loadu_si128(_RSI + 6);
        v34 = _mm_loadu_si128(_RSI + 7);
        _mm_lfence();
        _mm_stream_si128(_RDI, v27);
        _mm_stream_si128(_RDI + 1, v28);
        _mm_stream_si128(_RDI + 2, v29);
        _mm_stream_si128(_RDI + 3, v30);
        _mm_stream_si128(_RDI + 4, v31);
        _mm_stream_si128(_RDI + 5, v32);
        _mm_stream_si128(_RDI + 6, v33);
        _mm_stream_si128(_RDI + 7, v34);
        _RSI += 8;
        _RDI += 8;
      }
      while ( !v18 );
      _mm_sfence();
      if ( v24 < 0x80 )
        return ((__int64 (__fastcall *)(__int8 *, __int8 *))((char *)dword_4823F0 + dword_4823F0[v26 + 128]))(
                 &_RDI[8].m128i_i8[v26],
                 &_RSI[8].m128i_i8[v26]);
      v25 = v26 + 128;
    }
    v26 = v24 + v25 - 128;
    do
    {
      __asm
      {
        prefetchnta byte ptr [rsi+1C0h]
        prefetchnta byte ptr [rsi+280h]
        prefetchnta byte ptr [rdi+1C0h]
        prefetchnta byte ptr [rdi+280h]
      }
      v18 = v26 < 0x80;
      v26 -= 128LL;
      v35 = _mm_loadu_si128(_RSI + 1);
      v36 = _mm_loadu_si128(_RSI + 2);
      v37 = _mm_loadu_si128(_RSI + 3);
      v38 = _mm_loadu_si128(_RSI + 4);
      v39 = _mm_loadu_si128(_RSI + 5);
      v40 = _mm_loadu_si128(_RSI + 6);
      v41 = _mm_loadu_si128(_RSI + 7);
      *_RDI = _mm_loadu_si128(_RSI);
      _RDI[1] = v35;
      _RDI[2] = v36;
      _RDI[3] = v37;
      _RDI[4] = v38;
      _RDI[5] = v39;
      _RDI[6] = v40;
      _RDI[7] = v41;
      _RSI += 8;
      _RDI += 8;
    }
    while ( !v18 );
    return ((__int64 (__fastcall *)(__int8 *, __int8 *))((char *)dword_4823F0 + dword_4823F0[v26 + 128]))(
             &_RDI[8].m128i_i8[v26],
             &_RSI[8].m128i_i8[v26]);
  }
  if ( v7 + (v7 >> 8) >= _x86_data_cache_size_half )
    goto LABEL_19;
  v17 = v7 - 128;
  do
  {
    *v6 = _mm_load_si128(v8);
    v6[1] = v8[1];
    v6[2] = v8[2];
    v6[3] = v8[3];
    v6[4] = v8[4];
    v6[5] = v8[5];
    v6[6] = v8[6];
    v6[7] = v8[7];
    v18 = v17 < 0x80;
    v17 -= 128LL;
    v8 += 8;
    v6 += 8;
  }
  while ( !v18 );
  *a1 = v4;
  return ((__int64 (__fastcall *)(__int8 *, __int8 *))((char *)dword_4823F0 + dword_4823F0[v17 + 128]))(
           &v6[8].m128i_i8[v17],
           &v8[8].m128i_i8[v17]);
}
// 4821B0: using guessed type int dword_4821B0[144];
// 4823F0: using guessed type int dword_4823F0[144];
// 482630: using guessed type int dword_482630[16];
// 482670: using guessed type int dword_482670[16];
// 4A9138: using guessed type __int64 _x86_shared_cache_size_half;
// 4A9150: using guessed type __int64 _x86_data_cache_size;
// 4A9158: using guessed type __int64 _x86_data_cache_size_half;

//----- (0000000000429750) ----------------------------------------------------
__m128i *__fastcall _memmove_chk_ssse3_back(
        __m128i *a1,
        const __m128i *a2,
        unsigned __int64 a3,
        unsigned __int64 a4,
        u32 *a5,
        __int64 a6)
{
  if ( a4 < a3 )
    _chk_fail((__int64)a1, (__int64)a2, a3, a4, a5, a6);
  return _memmove_ssse3_back(a1, a2, a3);
}

//----- (0000000000429760) ----------------------------------------------------
__m128i *__fastcall _memmove_ssse3_back(__m128i *a1, const __m128i *a2, unsigned __int64 a3)
{
  __m128i *result; // rax
  __m128i v4; // xmm0
  __m128i *v6; // rdi
  unsigned __int64 v7; // rdx
  const __m128i *v8; // rsi
  unsigned __int64 v9; // rdi
  const __m128i *v10; // rsi
  __m128i v11; // xmm0
  __m128i *v12; // r8
  unsigned __int64 v13; // r9
  unsigned __int64 v16; // rdx
  unsigned __int64 v17; // rdx
  bool v18; // cf
  unsigned __int64 v19; // rdx
  __m128i v20; // xmm1
  unsigned __int64 v21; // rdx
  unsigned __int64 v24; // rcx
  unsigned __int64 v25; // rdx
  unsigned __int64 v26; // rdx
  __m128i v27; // xmm0
  __m128i v28; // xmm1
  __m128i v29; // xmm2
  __m128i v30; // xmm3
  __m128i v31; // xmm4
  __m128i v32; // xmm5
  __m128i v33; // xmm6
  __m128i v34; // xmm7
  __m128i v35; // xmm1
  __m128i v36; // xmm2
  __m128i v37; // xmm3
  __m128i v38; // xmm4
  __m128i v39; // xmm5
  __m128i v40; // xmm6
  __m128i v41; // xmm7
  const __m128i *v42; // rsi
  unsigned __int64 v43; // rdi
  unsigned __int64 v44; // r9
  unsigned __int64 v45; // r9
  unsigned __int64 v46; // rdx
  unsigned __int64 v47; // rcx
  unsigned __int64 v48; // rdx
  __m128i v49; // xmm1
  __m128i v50; // xmm2
  __m128i v51; // xmm3
  __m128i v52; // xmm4
  __m128i v53; // xmm5
  __m128i v54; // xmm6
  __m128i v55; // xmm7
  __m128i v56; // xmm8
  __m128i v57; // xmm2
  __m128i v58; // xmm3
  __m128i v59; // xmm4
  __m128i v60; // xmm5
  __m128i v61; // xmm6
  __m128i v62; // xmm7
  __m128i v63; // xmm8

  result = a1;
  if ( a1 >= a2 )
  {
    if ( a1 == a2 )
      return result;
    if ( a3 < 0x90 )
      return (__m128i *)((__int64 (*)(void))((char *)dword_4826B0 + dword_4826B0[a3]))();
    if ( a3 <= 2 * _x86_data_cache_size )
    {
      v9 = (unsigned __int64)a1->m128i_u64 + a3;
      v10 = (const __m128i *)((char *)a2 + a3);
      v11 = _mm_loadu_si128(v10 - 1);
      v12 = (__m128i *)(v9 - 16);
      v13 = v9 & 0xF;
      _RDI = v13 ^ v9;
      _RSI = &v10->m128i_i8[-v13];
      v16 = a3 - v13;
      if ( ((unsigned __int8)_RSI & 0xF) != 0 )
        return (__m128i *)((__int64 (__fastcall *)(unsigned __int64, char *, unsigned __int64, __int64, __m128i *, double))((char *)dword_482B70 + dword_482B70[(unsigned __int8)_RSI & 0xF]))(
                            _RDI,
                            _RSI,
                            v16 - 128,
                            2 * _x86_data_cache_size,
                            v12,
                            *(double *)v11.m128i_i64);
      v19 = v16 - 128;
      do
      {
        *(_OWORD *)(_RDI - 16) = *((_OWORD *)_RSI - 1);
        *(_OWORD *)(_RDI - 32) = *((_OWORD *)_RSI - 2);
        *(_OWORD *)(_RDI - 48) = *((_OWORD *)_RSI - 3);
        *(_OWORD *)(_RDI - 64) = *((_OWORD *)_RSI - 4);
        *(_OWORD *)(_RDI - 80) = *((_OWORD *)_RSI - 5);
        *(_OWORD *)(_RDI - 96) = *((_OWORD *)_RSI - 6);
        *(_OWORD *)(_RDI - 112) = *((_OWORD *)_RSI - 7);
        *(_OWORD *)(_RDI - 128) = *((_OWORD *)_RSI - 8);
        v18 = v19 < 0x80;
        v19 -= 128LL;
        _RDI -= 128LL;
        _RSI -= 128;
      }
      while ( !v18 );
      goto LABEL_49;
    }
    v42 = (const __m128i *)((char *)a2 + a3);
    v43 = (unsigned __int64)a1->m128i_u64 + a3;
    v11 = _mm_loadu_si128(v42 - 1);
    v12 = (__m128i *)(v43 - 16);
    v44 = v43;
    _RDI = v43 & 0xFFFFFFFFFFFFFFF0LL;
    v45 = v44 - _RDI;
    _RSI = &v42->m128i_i8[-v45];
    v46 = a3 - v45;
    v47 = _x86_shared_cache_size_half;
    if ( _RDI - (unsigned __int64)_RSI >= v46 || _RDI - (unsigned __int64)_RSI > _x86_shared_cache_size_half )
    {
      if ( v46 <= _x86_shared_cache_size_half )
        v47 = v46;
      v48 = v46 - v47;
      if ( v48 > 0x1000 )
      {
        if ( v48 > 8 * v47 )
        {
          v48 += v47;
          v47 = 0LL;
        }
        v19 = v48 - 128;
        do
        {
          v18 = v19 < 0x80;
          v19 -= 128LL;
          __asm
          {
            prefetcht0 byte ptr [rsi-200h]
            prefetcht0 byte ptr [rsi-300h]
          }
          v49 = _mm_loadu_si128((const __m128i *)_RSI - 1);
          v50 = _mm_loadu_si128((const __m128i *)_RSI - 2);
          v51 = _mm_loadu_si128((const __m128i *)_RSI - 3);
          v52 = _mm_loadu_si128((const __m128i *)_RSI - 4);
          v53 = _mm_loadu_si128((const __m128i *)_RSI - 5);
          v54 = _mm_loadu_si128((const __m128i *)_RSI - 6);
          v55 = _mm_loadu_si128((const __m128i *)_RSI - 7);
          v56 = _mm_loadu_si128((const __m128i *)_RSI - 8);
          _mm_lfence();
          _mm_stream_si128((__m128i *)(_RDI - 16), v49);
          _mm_stream_si128((__m128i *)(_RDI - 32), v50);
          _mm_stream_si128((__m128i *)(_RDI - 48), v51);
          _mm_stream_si128((__m128i *)(_RDI - 64), v52);
          _mm_stream_si128((__m128i *)(_RDI - 80), v53);
          _mm_stream_si128((__m128i *)(_RDI - 96), v54);
          _mm_stream_si128((__m128i *)(_RDI - 112), v55);
          _mm_stream_si128((__m128i *)(_RDI - 128), v56);
          _RSI -= 128;
          _RDI -= 128LL;
        }
        while ( !v18 );
        _mm_sfence();
        if ( v47 < 0x80 )
          goto LABEL_49;
        v48 = v19 + 128;
      }
      v46 = v47 + v48;
    }
    v19 = v46 - 128;
    do
    {
      __asm
      {
        prefetchnta byte ptr [rsi-1C0h]
        prefetchnta byte ptr [rsi-280h]
        prefetchnta byte ptr [rdi-1C0h]
        prefetchnta byte ptr [rdi-280h]
      }
      v18 = v19 < 0x80;
      v19 -= 128LL;
      v57 = _mm_loadu_si128((const __m128i *)_RSI - 2);
      v58 = _mm_loadu_si128((const __m128i *)_RSI - 3);
      v59 = _mm_loadu_si128((const __m128i *)_RSI - 4);
      v60 = _mm_loadu_si128((const __m128i *)_RSI - 5);
      v61 = _mm_loadu_si128((const __m128i *)_RSI - 6);
      v62 = _mm_loadu_si128((const __m128i *)_RSI - 7);
      v63 = _mm_loadu_si128((const __m128i *)_RSI - 8);
      *(__m128i *)(_RDI - 16) = _mm_loadu_si128((const __m128i *)_RSI - 1);
      *(__m128i *)(_RDI - 32) = v57;
      *(__m128i *)(_RDI - 48) = v58;
      *(__m128i *)(_RDI - 64) = v59;
      *(__m128i *)(_RDI - 80) = v60;
      *(__m128i *)(_RDI - 96) = v61;
      *(__m128i *)(_RDI - 112) = v62;
      *(__m128i *)(_RDI - 128) = v63;
      _RSI -= 128;
      _RDI -= 128LL;
    }
    while ( !v18 );
LABEL_49:
    *v12 = v11;
    return (__m128i *)((__int64 (__fastcall *)(unsigned __int64, char *))((char *)dword_4826B0 + dword_4826B0[v19 + 128]))(
                        _RDI - (v19 + 128),
                        &_RSI[-v19 - 128]);
  }
  if ( a3 < 0x90 )
    return (__m128i *)((__int64 (__fastcall *)(__int8 *, __int8 *))((char *)dword_4828F0 + dword_4828F0[a3]))(
                        &a1->m128i_i8[a3],
                        &a2->m128i_i8[a3]);
  v4 = _mm_loadu_si128(a2);
  v6 = (__m128i *)(((unsigned __int64)a1 & 0xFFFFFFFFFFFFFFF0LL) + 16);
  v7 = a3 - ((char *)v6 - (char *)a1);
  v8 = (const __m128i *)((char *)a2 + (char *)v6 - (char *)a1);
  if ( ((unsigned __int8)v8 & 0xF) != 0 )
  {
    if ( v7 < _x86_data_cache_size )
      return (__m128i *)((__int64 (__fastcall *)(__m128i *, const __m128i *, unsigned __int64, double))((char *)dword_482B30 + dword_482B30[(unsigned __int8)v8 & 0xF]))(
                          v6,
                          v8,
                          v7 - 128,
                          *(double *)v4.m128i_i64);
LABEL_20:
    v20 = _mm_loadu_si128(v8);
    *a1 = v4;
    *v6 = v20;
    v21 = v7 - 16;
    _RSI = v8 + 1;
    _RDI = v6 + 1;
    v24 = _x86_shared_cache_size_half;
    if ( (char *)_RSI - (char *)_RDI >= v21
      || (char *)_RSI - (char *)_RDI > (unsigned __int64)_x86_shared_cache_size_half )
    {
      if ( v21 <= _x86_shared_cache_size_half )
        v24 = v21;
      v25 = v21 - v24;
      if ( v25 > 0x1000 )
      {
        if ( v25 > 8 * v24 )
        {
          v25 += v24;
          v24 = 0LL;
        }
        v26 = v25 - 128;
        do
        {
          v18 = v26 < 0x80;
          v26 -= 128LL;
          __asm
          {
            prefetcht0 byte ptr [rsi+200h]
            prefetcht0 byte ptr [rsi+300h]
          }
          v27 = _mm_loadu_si128(_RSI);
          v28 = _mm_loadu_si128(_RSI + 1);
          v29 = _mm_loadu_si128(_RSI + 2);
          v30 = _mm_loadu_si128(_RSI + 3);
          v31 = _mm_loadu_si128(_RSI + 4);
          v32 = _mm_loadu_si128(_RSI + 5);
          v33 = _mm_loadu_si128(_RSI + 6);
          v34 = _mm_loadu_si128(_RSI + 7);
          _mm_lfence();
          _mm_stream_si128(_RDI, v27);
          _mm_stream_si128(_RDI + 1, v28);
          _mm_stream_si128(_RDI + 2, v29);
          _mm_stream_si128(_RDI + 3, v30);
          _mm_stream_si128(_RDI + 4, v31);
          _mm_stream_si128(_RDI + 5, v32);
          _mm_stream_si128(_RDI + 6, v33);
          _mm_stream_si128(_RDI + 7, v34);
          _RSI += 8;
          _RDI += 8;
        }
        while ( !v18 );
        _mm_sfence();
        if ( v24 < 0x80 )
          return (__m128i *)((__int64 (__fastcall *)(__int8 *, __int8 *))((char *)dword_4828F0 + dword_4828F0[v26 + 128]))(
                              &_RDI[8].m128i_i8[v26],
                              &_RSI[8].m128i_i8[v26]);
        v25 = v26 + 128;
      }
      v21 = v24 + v25;
    }
    v26 = v21 - 128;
    do
    {
      __asm
      {
        prefetchnta byte ptr [rsi+1C0h]
        prefetchnta byte ptr [rsi+280h]
        prefetchnta byte ptr [rdi+1C0h]
        prefetchnta byte ptr [rdi+280h]
      }
      v18 = v26 < 0x80;
      v26 -= 128LL;
      v35 = _mm_loadu_si128(_RSI + 1);
      v36 = _mm_loadu_si128(_RSI + 2);
      v37 = _mm_loadu_si128(_RSI + 3);
      v38 = _mm_loadu_si128(_RSI + 4);
      v39 = _mm_loadu_si128(_RSI + 5);
      v40 = _mm_loadu_si128(_RSI + 6);
      v41 = _mm_loadu_si128(_RSI + 7);
      *_RDI = _mm_loadu_si128(_RSI);
      _RDI[1] = v35;
      _RDI[2] = v36;
      _RDI[3] = v37;
      _RDI[4] = v38;
      _RDI[5] = v39;
      _RDI[6] = v40;
      _RDI[7] = v41;
      _RSI += 8;
      _RDI += 8;
    }
    while ( !v18 );
    return (__m128i *)((__int64 (__fastcall *)(__int8 *, __int8 *))((char *)dword_4828F0 + dword_4828F0[v26 + 128]))(
                        &_RDI[8].m128i_i8[v26],
                        &_RSI[8].m128i_i8[v26]);
  }
  if ( v7 + (v7 >> 8) >= _x86_data_cache_size_half )
    goto LABEL_20;
  v17 = v7 - 128;
  do
  {
    *v6 = _mm_load_si128(v8);
    v6[1] = v8[1];
    v6[2] = v8[2];
    v6[3] = v8[3];
    v6[4] = v8[4];
    v6[5] = v8[5];
    v6[6] = v8[6];
    v6[7] = v8[7];
    v18 = v17 < 0x80;
    v17 -= 128LL;
    v8 += 8;
    v6 += 8;
  }
  while ( !v18 );
  *a1 = v4;
  return (__m128i *)((__int64 (__fastcall *)(__int8 *, __int8 *))((char *)dword_4828F0 + dword_4828F0[v17 + 128]))(
                      &v6[8].m128i_i8[v17],
                      &v8[8].m128i_i8[v17]);
}
// 4826B0: using guessed type int dword_4826B0[144];
// 4828F0: using guessed type int dword_4828F0[144];
// 482B30: using guessed type int dword_482B30[16];
// 482B70: using guessed type int dword_482B70[16];
// 4A9138: using guessed type __int64 _x86_shared_cache_size_half;
// 4A9150: using guessed type __int64 _x86_data_cache_size;
// 4A9158: using guessed type __int64 _x86_data_cache_size_half;

//----- (000000000042C280) ----------------------------------------------------
void __fastcall _mempcpy_chk_avx512_no_vzeroupper(
        __int64 a1,
        __int64 a2,
        unsigned __int64 a3,
        unsigned __int64 a4,
        u32 *a5,
        __int64 a6)
{
  if ( a4 < a3 )
    _chk_fail(a1, a2, a3, a4, a5, a6);
  _mempcpy_avx512_no_vzeroupper();
}

//----- (000000000042C290) ----------------------------------------------------
void _mempcpy_avx512_no_vzeroupper()
{
  JUMPOUT(0x42C2B7LL);
}
// 42C29A: control flows out of bounds to 42C2B7

//----- (000000000042C2A0) ----------------------------------------------------
unsigned __int64 __fastcall _memmove_chk_avx512_no_vzeroupper(
        unsigned __int64 _RDI,
        _BYTE *_RSI,
        unsigned __int64 a3,
        unsigned __int64 a4,
        u32 *a5,
        __int64 a6)
{
  if ( a4 < a3 )
    _chk_fail(_RDI, (__int64)_RSI, a3, a4, a5, a6);
  return _memmove_avx512_no_vzeroupper(_RDI, _RSI, a3);
}

//----- (000000000042C2B0) ----------------------------------------------------
unsigned __int64 __fastcall _memmove_avx512_no_vzeroupper(unsigned __int64 _RDI, _BYTE *_RSI, unsigned __int64 a3)
{
  unsigned __int64 result; // rax
  __int64 v26; // rcx
  int v27; // ecx
  __int16 v28; // cx
  unsigned __int64 v82; // r8
  unsigned __int64 v83; // r8
  unsigned __int64 v90; // r8

  result = _RDI;
  _RCX = &_RSI[a3];
  _R9 = _RDI + a3;
  if ( a3 > 0x200 )
  {
    if ( a3 < _x86_shared_cache_size_half )
    {
      if ( a3 > 0x400 )
      {
        if ( _RDI > (unsigned __int64)_RSI )
        {
          _RDI = _RDI + 512;
          __asm
          {
            vmovups zmm8, zmmword ptr [rsi+1C0h]
            vmovups zmm9, zmmword ptr [rsi+180h]
            vmovups zmm10, zmmword ptr [rsi+140h]
            vmovups zmm11, zmmword ptr [rsi+100h]
            vmovups zmm12, zmmword ptr [rsi+0C0h]
            vmovups zmm13, zmmword ptr [rsi+80h]
            vmovups zmm14, zmmword ptr [rsi+40h]
            vmovups zmm15, zmmword ptr [rsi]
            prefetcht1 byte ptr [rcx-40h]
            prefetcht1 byte ptr [rcx-80h]
            prefetcht1 byte ptr [rcx-0C0h]
            prefetcht1 byte ptr [rcx-100h]
            prefetcht1 byte ptr [rcx-140h]
            prefetcht1 byte ptr [rcx-180h]
            prefetcht1 byte ptr [rcx-1C0h]
            prefetcht1 byte ptr [rcx-200h]
          }
          do
          {
            __asm
            {
              vmovups zmm0, zmmword ptr [rcx-40h]
              vmovups zmm1, zmmword ptr [rcx-80h]
              vmovups zmm2, zmmword ptr [rcx-0C0h]
              vmovups zmm3, zmmword ptr [rcx-100h]
              vmovups zmm4, zmmword ptr [rcx-140h]
              vmovups zmm5, zmmword ptr [rcx-180h]
              vmovups zmm6, zmmword ptr [rcx-1C0h]
              vmovups zmm7, zmmword ptr [rcx-200h]
            }
            _RCX -= 512;
            __asm
            {
              prefetcht1 byte ptr [rcx-40h]
              prefetcht1 byte ptr [rcx-80h]
              prefetcht1 byte ptr [rcx-0C0h]
              prefetcht1 byte ptr [rcx-100h]
              prefetcht1 byte ptr [rcx-140h]
              prefetcht1 byte ptr [rcx-180h]
              prefetcht1 byte ptr [rcx-1C0h]
              prefetcht1 byte ptr [rcx-200h]
              vmovups zmmword ptr [r9-40h], zmm0
              vmovups zmmword ptr [r9-80h], zmm1
              vmovups zmmword ptr [r9-0C0h], zmm2
              vmovups zmmword ptr [r9-100h], zmm3
              vmovups zmmword ptr [r9-140h], zmm4
              vmovups zmmword ptr [r9-180h], zmm5
              vmovups zmmword ptr [r9-1C0h], zmm6
              vmovups zmmword ptr [r9-200h], zmm7
            }
            _R9 -= 512LL;
          }
          while ( _R9 > _RDI );
          __asm
          {
            vmovups zmmword ptr [rdi-40h], zmm8
            vmovups zmmword ptr [rdi-80h], zmm9
            vmovups zmmword ptr [rdi-0C0h], zmm10
            vmovups zmmword ptr [rdi-100h], zmm11
            vmovups zmmword ptr [rdi-140h], zmm12
            vmovups zmmword ptr [rdi-180h], zmm13
            vmovups zmmword ptr [rdi-1C0h], zmm14
            vmovups zmmword ptr [rdi-200h], zmm15
          }
        }
        else
        {
          _R9 = _R9 - 512;
          __asm
          {
            vmovups zmm8, zmmword ptr [rcx-200h]
            vmovups zmm9, zmmword ptr [rcx-1C0h]
            vmovups zmm10, zmmword ptr [rcx-180h]
            vmovups zmm11, zmmword ptr [rcx-140h]
            vmovups zmm12, zmmword ptr [rcx-100h]
            vmovups zmm13, zmmword ptr [rcx-0C0h]
            vmovups zmm14, zmmword ptr [rcx-80h]
            vmovups zmm15, zmmword ptr [rcx-40h]
            prefetcht1 byte ptr [rsi]
            prefetcht1 byte ptr [rsi+40h]
            prefetcht1 byte ptr [rsi+80h]
            prefetcht1 byte ptr [rsi+0C0h]
            prefetcht1 byte ptr [rsi+100h]
            prefetcht1 byte ptr [rsi+140h]
            prefetcht1 byte ptr [rsi+180h]
            prefetcht1 byte ptr [rsi+1C0h]
          }
          do
          {
            __asm
            {
              vmovups zmm0, zmmword ptr [rsi]
              vmovups zmm1, zmmword ptr [rsi+40h]
              vmovups zmm2, zmmword ptr [rsi+80h]
              vmovups zmm3, zmmword ptr [rsi+0C0h]
              vmovups zmm4, zmmword ptr [rsi+100h]
              vmovups zmm5, zmmword ptr [rsi+140h]
              vmovups zmm6, zmmword ptr [rsi+180h]
              vmovups zmm7, zmmword ptr [rsi+1C0h]
            }
            _RSI += 512;
            __asm
            {
              prefetcht1 byte ptr [rsi]
              prefetcht1 byte ptr [rsi+40h]
              prefetcht1 byte ptr [rsi+80h]
              prefetcht1 byte ptr [rsi+0C0h]
              prefetcht1 byte ptr [rsi+100h]
              prefetcht1 byte ptr [rsi+140h]
              prefetcht1 byte ptr [rsi+180h]
              prefetcht1 byte ptr [rsi+1C0h]
              vmovups zmmword ptr [rdi], zmm0
              vmovups zmmword ptr [rdi+40h], zmm1
              vmovups zmmword ptr [rdi+80h], zmm2
              vmovups zmmword ptr [rdi+0C0h], zmm3
              vmovups zmmword ptr [rdi+100h], zmm4
              vmovups zmmword ptr [rdi+140h], zmm5
              vmovups zmmword ptr [rdi+180h], zmm6
              vmovups zmmword ptr [rdi+1C0h], zmm7
            }
            _RDI += 512LL;
          }
          while ( _RDI < _R9 );
          __asm
          {
            vmovups zmmword ptr [r9], zmm8
            vmovups zmmword ptr [r9+40h], zmm9
            vmovups zmmword ptr [r9+80h], zmm10
            vmovups zmmword ptr [r9+0C0h], zmm11
            vmovups zmmword ptr [r9+100h], zmm12
            vmovups zmmword ptr [r9+140h], zmm13
            vmovups zmmword ptr [r9+180h], zmm14
            vmovups zmmword ptr [r9+1C0h], zmm15
          }
        }
      }
      else
      {
        __asm
        {
          prefetcht1 byte ptr [rsi]
          prefetcht1 byte ptr [rsi+40h]
          prefetcht1 byte ptr [rsi+80h]
          prefetcht1 byte ptr [rsi+0C0h]
          prefetcht1 byte ptr [rsi+100h]
          prefetcht1 byte ptr [rsi+140h]
          prefetcht1 byte ptr [rsi+180h]
          prefetcht1 byte ptr [rsi+1C0h]
          prefetcht1 byte ptr [rcx-200h]
          prefetcht1 byte ptr [rcx-1C0h]
          prefetcht1 byte ptr [rcx-180h]
          prefetcht1 byte ptr [rcx-140h]
          prefetcht1 byte ptr [rcx-100h]
          prefetcht1 byte ptr [rcx-0C0h]
          prefetcht1 byte ptr [rcx-80h]
          prefetcht1 byte ptr [rcx-40h]
          vmovups zmm0, zmmword ptr [rsi]
          vmovups zmm1, zmmword ptr [rsi+40h]
          vmovups zmm2, zmmword ptr [rsi+80h]
          vmovups zmm3, zmmword ptr [rsi+0C0h]
          vmovups zmm4, zmmword ptr [rsi+100h]
          vmovups zmm5, zmmword ptr [rsi+140h]
          vmovups zmm6, zmmword ptr [rsi+180h]
          vmovups zmm7, zmmword ptr [rsi+1C0h]
          vmovups zmm8, zmmword ptr [rcx-200h]
          vmovups zmm9, zmmword ptr [rcx-1C0h]
          vmovups zmm10, zmmword ptr [rcx-180h]
          vmovups zmm11, zmmword ptr [rcx-140h]
          vmovups zmm12, zmmword ptr [rcx-100h]
          vmovups zmm13, zmmword ptr [rcx-0C0h]
          vmovups zmm14, zmmword ptr [rcx-80h]
          vmovups zmm15, zmmword ptr [rcx-40h]
          vmovups zmmword ptr [rdi], zmm0
          vmovups zmmword ptr [rdi+40h], zmm1
          vmovups zmmword ptr [rdi+80h], zmm2
          vmovups zmmword ptr [rdi+0C0h], zmm3
          vmovups zmmword ptr [rdi+100h], zmm4
          vmovups zmmword ptr [rdi+140h], zmm5
          vmovups zmmword ptr [rdi+180h], zmm6
          vmovups zmmword ptr [rdi+1C0h], zmm7
          vmovups zmmword ptr [r9-200h], zmm8
          vmovups zmmword ptr [r9-1C0h], zmm9
          vmovups zmmword ptr [r9-180h], zmm10
          vmovups zmmword ptr [r9-140h], zmm11
          vmovups zmmword ptr [r9-100h], zmm12
          vmovups zmmword ptr [r9-0C0h], zmm13
          vmovups zmmword ptr [r9-80h], zmm14
          vmovups zmmword ptr [r9-40h], zmm15
        }
      }
      return result;
    }
    if ( _RDI > (unsigned __int64)_RSI )
    {
      __asm
      {
        vmovups zmm4, zmmword ptr [rcx-80h]
        vmovups zmm5, zmmword ptr [rcx-40h]
      }
      _R9 &= 0xFFFFFFFFFFFFFF80LL;
      v90 = _RDI + a3 - _R9;
      _RCX -= v90;
      a3 = _R9 - _RDI;
      _R8 = _R9 + v90;
      do
      {
        __asm
        {
          prefetcht1 byte ptr [rcx-400h]
          prefetcht1 byte ptr [rcx-3C0h]
          prefetcht1 byte ptr [rcx-380h]
          prefetcht1 byte ptr [rcx-340h]
          prefetcht1 byte ptr [rcx-300h]
          prefetcht1 byte ptr [rcx-2C0h]
          prefetcht1 byte ptr [rcx-280h]
          prefetcht1 byte ptr [rcx-240h]
          vmovdqu64 zmm0, zmmword ptr [rcx-100h]
          vmovdqu64 zmm1, zmmword ptr [rcx-0C0h]
          vmovdqu64 zmm2, zmmword ptr [rcx-80h]
          vmovdqu64 zmm3, zmmword ptr [rcx-40h]
          vmovntdq zmmword ptr [r9-100h], zmm0
          vmovntdq zmmword ptr [r9-0C0h], zmm1
          vmovntdq zmmword ptr [r9-80h], zmm2
          vmovntdq zmmword ptr [r9-40h], zmm3
        }
        a3 -= 256LL;
        _RCX -= 256;
        _R9 -= 256LL;
      }
      while ( a3 > 0x100 );
      _mm_sfence();
      __asm
      {
        vmovups zmmword ptr [r8-80h], zmm4
        vmovups zmmword ptr [r8-40h], zmm5
      }
    }
    else
    {
      __asm
      {
        vmovups zmm4, zmmword ptr [rsi]
        vmovups zmm5, zmmword ptr [rsi+40h]
      }
      _R11 = _RDI;
      v82 = _RDI;
      _RDI = (_RDI & 0xFFFFFFFFFFFFFF80LL) + 128;
      v83 = v82 - _RDI;
      _RSI -= v83;
      a3 += v83;
      do
      {
        __asm
        {
          prefetcht1 byte ptr [rsi+200h]
          prefetcht1 byte ptr [rsi+240h]
          prefetcht1 byte ptr [rsi+280h]
          prefetcht1 byte ptr [rsi+2C0h]
          prefetcht1 byte ptr [rsi+300h]
          prefetcht1 byte ptr [rsi+340h]
          prefetcht1 byte ptr [rsi+380h]
          prefetcht1 byte ptr [rsi+3C0h]
          vmovdqu64 zmm0, zmmword ptr [rsi]
          vmovdqu64 zmm1, zmmword ptr [rsi+40h]
          vmovdqu64 zmm2, zmmword ptr [rsi+80h]
          vmovdqu64 zmm3, zmmword ptr [rsi+0C0h]
          vmovntdq zmmword ptr [rdi], zmm0
          vmovntdq zmmword ptr [rdi+40h], zmm1
          vmovntdq zmmword ptr [rdi+80h], zmm2
          vmovntdq zmmword ptr [rdi+0C0h], zmm3
        }
        a3 -= 256LL;
        _RSI += 256;
        _RDI += 256LL;
      }
      while ( a3 > 0x100 );
      _mm_sfence();
      __asm
      {
        vmovups zmmword ptr [r11], zmm4
        vmovups zmmword ptr [r11+40h], zmm5
      }
    }
  }
  if ( a3 <= 0x10 )
  {
    if ( (unsigned __int8)a3 < 8u )
    {
      if ( (unsigned __int8)a3 < 4u )
      {
        if ( (unsigned __int8)a3 < 2u )
        {
          if ( (_BYTE)a3 )
            *(_BYTE *)_RDI = *_RSI;
        }
        else
        {
          v28 = *((_WORD *)_RCX - 1);
          *(_WORD *)_RDI = *(_WORD *)_RSI;
          *(_WORD *)(_R9 - 2) = v28;
        }
      }
      else
      {
        v27 = *((_DWORD *)_RCX - 1);
        *(_DWORD *)_RDI = *(_DWORD *)_RSI;
        *(_DWORD *)(_R9 - 4) = v27;
      }
    }
    else
    {
      v26 = *((_QWORD *)_RCX - 1);
      *(_QWORD *)_RDI = *(_QWORD *)_RSI;
      *(_QWORD *)(_R9 - 8) = v26;
    }
  }
  else if ( a3 < 0x100 )
  {
    if ( (unsigned __int8)a3 < 0x80u )
    {
      if ( (unsigned __int8)a3 < 0x40u )
      {
        if ( (unsigned __int8)a3 < 0x20u )
        {
          __asm
          {
            vmovdqu xmm0, xmmword ptr [rsi]
            vmovdqu xmm1, xmmword ptr [rcx-10h]
            vmovdqu xmmword ptr [rdi], xmm0
            vmovdqu xmmword ptr [r9-10h], xmm1
          }
        }
        else
        {
          __asm
          {
            vmovdqu ymm0, ymmword ptr [rsi]
            vmovdqu ymm1, ymmword ptr [rcx-20h]
            vmovdqu ymmword ptr [rdi], ymm0
            vmovdqu ymmword ptr [r9-20h], ymm1
          }
        }
      }
      else
      {
        __asm
        {
          vmovdqu ymm0, ymmword ptr [rsi]
          vmovdqu ymm1, ymmword ptr [rsi+20h]
          vmovdqu ymm2, ymmword ptr [rcx-40h]
          vmovdqu ymm3, ymmword ptr [rcx-20h]
          vmovdqu ymmword ptr [rdi], ymm0
          vmovdqu ymmword ptr [rdi+20h], ymm1
          vmovdqu ymmword ptr [r9-40h], ymm2
          vmovdqu ymmword ptr [r9-20h], ymm3
        }
      }
    }
    else
    {
      __asm
      {
        vmovups zmm0, zmmword ptr [rsi]
        vmovups zmm1, zmmword ptr [rsi+40h]
        vmovups zmm2, zmmword ptr [rcx-80h]
        vmovups zmm3, zmmword ptr [rcx-40h]
        vmovups zmmword ptr [rdi], zmm0
        vmovups zmmword ptr [rdi+40h], zmm1
        vmovups zmmword ptr [r9-80h], zmm2
        vmovups zmmword ptr [r9-40h], zmm3
      }
    }
  }
  else
  {
    __asm
    {
      vmovups zmm0, zmmword ptr [rsi]
      vmovups zmm1, zmmword ptr [rsi+40h]
      vmovups zmm2, zmmword ptr [rsi+80h]
      vmovups zmm3, zmmword ptr [rsi+0C0h]
      vmovups zmm4, zmmword ptr [rcx-100h]
      vmovups zmm5, zmmword ptr [rcx-0C0h]
      vmovups zmm6, zmmword ptr [rcx-80h]
      vmovups zmm7, zmmword ptr [rcx-40h]
      vmovups zmmword ptr [rdi], zmm0
      vmovups zmmword ptr [rdi+40h], zmm1
      vmovups zmmword ptr [rdi+80h], zmm2
      vmovups zmmword ptr [rdi+0C0h], zmm3
      vmovups zmmword ptr [r9-100h], zmm4
      vmovups zmmword ptr [r9-0C0h], zmm5
      vmovups zmmword ptr [r9-80h], zmm6
      vmovups zmmword ptr [r9-40h], zmm7
    }
  }
  return result;
}
// 42C2B0: unsupported processor register 'zmm0'
// 4A9138: using guessed type __int64 _x86_shared_cache_size_half;

//----- (000000000042C9F0) ----------------------------------------------------
__int64 __fastcall _strcasecmp_sse2(__int64 a1, __int64 a2, __m128i a3, __m128i a4, __m128i a5, double a6, double a7)
{
  return _strcasecmp_l_sse2(a1, a2, __readfsqword(0xFFFFFFA8), a3, a4, a5, a6, a7);
}

//----- (000000000042CA10) ----------------------------------------------------
__int64 __fastcall _strcasecmp_l_sse2(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        __m128i a4,
        __m128i a5,
        __m128i a6,
        double a7,
        double a8)
{
  unsigned int v8; // ecx
  unsigned int v9; // eax
  __m128i si128; // xmm5
  __m128i v11; // xmm6
  __m128i v12; // xmm7
  __m128i v13; // xmm1
  __m128i v14; // xmm2
  __m128i v15; // xmm1
  unsigned __int64 v16; // rdx
  const __m128i *v17; // rsi
  const __m128i *v18; // rdi
  __int64 v19; // r8
  __int64 v20; // rcx
  __int64 v21; // rax
  unsigned int v22; // et0
  const __m128i *v23; // rt1
  __m128i v25; // xmm1
  __m128i v26; // xmm2
  __m128i v27; // xmm0
  __m128i v28; // xmm1
  __m128i v29; // xmm2
  __m128i v30; // xmm1
  __m128i v31; // xmm0
  __m128i v32; // xmm1
  __m128i v33; // xmm2
  __m128i v34; // xmm1

  if ( (*(_DWORD *)(*(_QWORD *)a3 + 632LL) & 1) != 0 )
    return _strcasecmp_l_nonascii(a1, a2, a3);
  v8 = a2 & 0x3F;
  v9 = a1 & 0x3F;
  si128 = _mm_load_si128((const __m128i *)&xmmword_482BB0);
  v11 = _mm_load_si128((const __m128i *)&xmmword_482BC0);
  v12 = _mm_load_si128((const __m128i *)&blanks);
  if ( v8 <= 0x30 && v9 <= 0x30 )
  {
    v13.m128i_i64[0] = *(__int64 *)a1;
    v14.m128i_i64[0] = *(__int64 *)a2;
    v13.m128i_i64[1] = *(__int64 *)(a1 + 8);
    v14.m128i_i64[1] = *(__int64 *)(a2 + 8);
    v15 = _mm_or_si128(v13, _mm_and_si128(_mm_and_si128(_mm_cmpgt_epi8(v13, si128), _mm_cmpgt_epi8(v11, v13)), v12));
    a6 = _mm_or_si128(v14, _mm_and_si128(_mm_and_si128(_mm_cmpgt_epi8(v14, si128), _mm_cmpgt_epi8(v11, v14)), v12));
    a4 = _mm_cmpeq_epi8((__m128i)0LL, v15);
    a5 = _mm_sub_epi8(_mm_cmpeq_epi8(v15, a6), a4);
    v16 = (unsigned int)(_mm_movemask_epi8(a5) - 0xFFFF);
    if ( (_DWORD)v16 )
    {
LABEL_17:
      _BitScanForward64(&v16, v16);
      return (unsigned int)(dword_4860E0[*(unsigned __int8 *)(a1 + v16)] - dword_4860E0[*(unsigned __int8 *)(a2 + v16)]);
    }
    a2 += 16LL;
    a1 += 16LL;
  }
  v17 = (const __m128i *)(a2 & 0xFFFFFFFFFFFFFFF0LL);
  v18 = (const __m128i *)(a1 & 0xFFFFFFFFFFFFFFF0LL);
  v19 = 0LL;
  v20 = v8 & 0xF;
  v21 = v9 & 0xF;
  if ( (_DWORD)v20 == (_DWORD)v21 )
  {
    v25 = _mm_load_si128(v17);
    v26 = _mm_load_si128(v18);
    v16 = (0xFFFFu >> v20)
        - ((unsigned int)_mm_movemask_epi8(
                           _mm_sub_epi8(
                             _mm_cmpeq_epi8(
                               _mm_or_si128(
                                 v25,
                                 _mm_and_si128(_mm_and_si128(_mm_cmpgt_epi8(v25, si128), _mm_cmpgt_epi8(v11, v25)), v12)),
                               _mm_or_si128(
                                 v26,
                                 _mm_and_si128(_mm_and_si128(_mm_cmpgt_epi8(v26, si128), _mm_cmpgt_epi8(v11, v26)), v12))),
                             _mm_cmpeq_epi8((__m128i)0LL, v25))) >> v20);
    if ( !(_DWORD)v16 )
    {
      v20 = 16LL;
      v27 = 0LL;
      while ( 1 )
      {
        v28 = _mm_load_si128((const __m128i *)((char *)v17 + v20));
        v29 = _mm_load_si128((const __m128i *)((char *)v18 + v20));
        v30 = _mm_or_si128(v28, _mm_and_si128(_mm_and_si128(_mm_cmpgt_epi8(v28, si128), _mm_cmpgt_epi8(v11, v28)), v12));
        v31 = _mm_cmpeq_epi8(v27, v30);
        v16 = (unsigned int)(_mm_movemask_epi8(
                               _mm_sub_epi8(
                                 _mm_cmpeq_epi8(
                                   v30,
                                   _mm_or_si128(
                                     v29,
                                     _mm_and_si128(
                                       _mm_and_si128(_mm_cmpgt_epi8(v29, si128), _mm_cmpgt_epi8(v11, v29)),
                                       v12))),
                                 v31))
                           - 0xFFFF);
        if ( (_DWORD)v16 )
          break;
        v20 += 16LL;
        v32 = _mm_load_si128((const __m128i *)((char *)v17 + v20));
        v33 = _mm_load_si128((const __m128i *)((char *)v18 + v20));
        v34 = _mm_or_si128(v32, _mm_and_si128(_mm_and_si128(_mm_cmpgt_epi8(v32, si128), _mm_cmpgt_epi8(v11, v32)), v12));
        v27 = _mm_cmpeq_epi8(v31, v34);
        v16 = (unsigned int)(_mm_movemask_epi8(
                               _mm_sub_epi8(
                                 _mm_cmpeq_epi8(
                                   v34,
                                   _mm_or_si128(
                                     v33,
                                     _mm_and_si128(
                                       _mm_and_si128(_mm_cmpgt_epi8(v33, si128), _mm_cmpgt_epi8(v11, v33)),
                                       v12))),
                                 v27))
                           - 0xFFFF);
        if ( (_DWORD)v16 )
          break;
        v20 += 16LL;
      }
      v21 = v20;
    }
    a1 = (__int64)v18->m128i_i64 + v21;
    a2 = (__int64)v17->m128i_i64 + v20;
    goto LABEL_17;
  }
  if ( (unsigned int)v20 <= (unsigned int)v21 )
  {
    v19 = 0xFFFFLL;
    v22 = v21;
    v21 = (unsigned int)v20;
    v20 = v22;
    v23 = v17;
    v17 = v18;
    v18 = v23;
  }
  return ((__int64 (__fastcall *)(const __m128i *, const __m128i *, __int64, __int64, __int64, double, double, double, double, double, double, double, double))((char *)dword_482BE0 + dword_482BE0[v21 + 15 - v20]))(
           v18,
           v17,
           0xFFFFLL,
           v20,
           v19,
           *(double *)a4.m128i_i64,
           *(double *)a5.m128i_i64,
           *(double *)a6.m128i_i64,
           a7,
           a8,
           *(double *)si128.m128i_i64,
           *(double *)v11.m128i_i64,
           *(double *)v12.m128i_i64);
}
// 482BB0: using guessed type __int128 xmmword_482BB0;
// 482BC0: using guessed type __int128 xmmword_482BC0;
// 482BD0: using guessed type __int128 blanks;
// 482BE0: using guessed type int dword_482BE0[16];
// 4860E0: using guessed type _DWORD dword_4860E0[256];

//----- (000000000042EC40) ----------------------------------------------------
__int64 __fastcall _strcasecmp_ssse3(__int64 a1, __int64 a2, __m128i a3, __m128i a4, __m128i a5, double a6, double a7)
{
  return _strcasecmp_l_ssse3(a1, a2, __readfsqword(0xFFFFFFA8), a3, a4, a5, a6, a7);
}

//----- (000000000042EC60) ----------------------------------------------------
__int64 __fastcall _strcasecmp_l_ssse3(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        __m128i a4,
        __m128i a5,
        __m128i a6,
        double a7,
        double a8)
{
  unsigned int v8; // ecx
  unsigned int v9; // eax
  __m128i si128; // xmm5
  __m128i v11; // xmm6
  __m128i v12; // xmm7
  __m128i v13; // xmm1
  __m128i v14; // xmm2
  __m128i v15; // xmm1
  unsigned __int64 v16; // rdx
  const __m128i *v17; // rsi
  const __m128i *v18; // rdi
  __int64 v19; // r8
  __int64 v20; // rcx
  __int64 v21; // rax
  unsigned int v22; // et0
  const __m128i *v23; // rt1
  __m128i v25; // xmm1
  __m128i v26; // xmm2
  __m128i v27; // xmm0
  __m128i v28; // xmm1
  __m128i v29; // xmm2
  __m128i v30; // xmm1
  __m128i v31; // xmm0
  __m128i v32; // xmm1
  __m128i v33; // xmm2
  __m128i v34; // xmm1

  if ( (*(_DWORD *)(*(_QWORD *)a3 + 632LL) & 1) != 0 )
    return _strcasecmp_l_nonascii(a1, a2, a3);
  v8 = a2 & 0x3F;
  v9 = a1 & 0x3F;
  si128 = _mm_load_si128((const __m128i *)&xmmword_482BB0);
  v11 = _mm_load_si128((const __m128i *)&xmmword_482BC0);
  v12 = _mm_load_si128((const __m128i *)&blanks);
  if ( v8 <= 0x30 && v9 <= 0x30 )
  {
    v13.m128i_i64[0] = *(__int64 *)a1;
    v14.m128i_i64[0] = *(__int64 *)a2;
    v13.m128i_i64[1] = *(__int64 *)(a1 + 8);
    v14.m128i_i64[1] = *(__int64 *)(a2 + 8);
    v15 = _mm_or_si128(v13, _mm_and_si128(_mm_and_si128(_mm_cmpgt_epi8(v13, si128), _mm_cmpgt_epi8(v11, v13)), v12));
    a6 = _mm_or_si128(v14, _mm_and_si128(_mm_and_si128(_mm_cmpgt_epi8(v14, si128), _mm_cmpgt_epi8(v11, v14)), v12));
    a4 = _mm_cmpeq_epi8((__m128i)0LL, v15);
    a5 = _mm_sub_epi8(_mm_cmpeq_epi8(v15, a6), a4);
    v16 = (unsigned int)(_mm_movemask_epi8(a5) - 0xFFFF);
    if ( (_DWORD)v16 )
    {
LABEL_17:
      _BitScanForward64(&v16, v16);
      return (unsigned int)(dword_4860E0[*(unsigned __int8 *)(a1 + v16)] - dword_4860E0[*(unsigned __int8 *)(a2 + v16)]);
    }
    a2 += 16LL;
    a1 += 16LL;
  }
  v17 = (const __m128i *)(a2 & 0xFFFFFFFFFFFFFFF0LL);
  v18 = (const __m128i *)(a1 & 0xFFFFFFFFFFFFFFF0LL);
  v19 = 0LL;
  v20 = v8 & 0xF;
  v21 = v9 & 0xF;
  if ( (_DWORD)v20 == (_DWORD)v21 )
  {
    v25 = _mm_load_si128(v17);
    v26 = _mm_load_si128(v18);
    v16 = (0xFFFFu >> v20)
        - ((unsigned int)_mm_movemask_epi8(
                           _mm_sub_epi8(
                             _mm_cmpeq_epi8(
                               _mm_or_si128(
                                 v25,
                                 _mm_and_si128(_mm_and_si128(_mm_cmpgt_epi8(v25, si128), _mm_cmpgt_epi8(v11, v25)), v12)),
                               _mm_or_si128(
                                 v26,
                                 _mm_and_si128(_mm_and_si128(_mm_cmpgt_epi8(v26, si128), _mm_cmpgt_epi8(v11, v26)), v12))),
                             _mm_cmpeq_epi8((__m128i)0LL, v25))) >> v20);
    if ( !(_DWORD)v16 )
    {
      v20 = 16LL;
      v27 = 0LL;
      while ( 1 )
      {
        v28 = _mm_load_si128((const __m128i *)((char *)v17 + v20));
        v29 = _mm_load_si128((const __m128i *)((char *)v18 + v20));
        v30 = _mm_or_si128(v28, _mm_and_si128(_mm_and_si128(_mm_cmpgt_epi8(v28, si128), _mm_cmpgt_epi8(v11, v28)), v12));
        v31 = _mm_cmpeq_epi8(v27, v30);
        v16 = (unsigned int)(_mm_movemask_epi8(
                               _mm_sub_epi8(
                                 _mm_cmpeq_epi8(
                                   v30,
                                   _mm_or_si128(
                                     v29,
                                     _mm_and_si128(
                                       _mm_and_si128(_mm_cmpgt_epi8(v29, si128), _mm_cmpgt_epi8(v11, v29)),
                                       v12))),
                                 v31))
                           - 0xFFFF);
        if ( (_DWORD)v16 )
          break;
        v20 += 16LL;
        v32 = _mm_load_si128((const __m128i *)((char *)v17 + v20));
        v33 = _mm_load_si128((const __m128i *)((char *)v18 + v20));
        v34 = _mm_or_si128(v32, _mm_and_si128(_mm_and_si128(_mm_cmpgt_epi8(v32, si128), _mm_cmpgt_epi8(v11, v32)), v12));
        v27 = _mm_cmpeq_epi8(v31, v34);
        v16 = (unsigned int)(_mm_movemask_epi8(
                               _mm_sub_epi8(
                                 _mm_cmpeq_epi8(
                                   v34,
                                   _mm_or_si128(
                                     v33,
                                     _mm_and_si128(
                                       _mm_and_si128(_mm_cmpgt_epi8(v33, si128), _mm_cmpgt_epi8(v11, v33)),
                                       v12))),
                                 v27))
                           - 0xFFFF);
        if ( (_DWORD)v16 )
          break;
        v20 += 16LL;
      }
      v21 = v20;
    }
    a1 = (__int64)v18->m128i_i64 + v21;
    a2 = (__int64)v17->m128i_i64 + v20;
    goto LABEL_17;
  }
  if ( (unsigned int)v20 <= (unsigned int)v21 )
  {
    v19 = 0xFFFFLL;
    v22 = v21;
    v21 = (unsigned int)v20;
    v20 = v22;
    v23 = v17;
    v17 = v18;
    v18 = v23;
  }
  return ((__int64 (__fastcall *)(const __m128i *, const __m128i *, __int64, __int64, __int64, double, double, double, double, double, double, double, double))((char *)dword_482C20 + dword_482C20[v21 + 15 - v20]))(
           v18,
           v17,
           0xFFFFLL,
           v20,
           v19,
           *(double *)a4.m128i_i64,
           *(double *)a5.m128i_i64,
           *(double *)a6.m128i_i64,
           a7,
           a8,
           *(double *)si128.m128i_i64,
           *(double *)v11.m128i_i64,
           *(double *)v12.m128i_i64);
}
// 482BB0: using guessed type __int128 xmmword_482BB0;
// 482BC0: using guessed type __int128 xmmword_482BC0;
// 482BD0: using guessed type __int128 blanks;
// 482C20: using guessed type int dword_482C20[16];
// 4860E0: using guessed type _DWORD dword_4860E0[256];

//----- (0000000000430DA0) ----------------------------------------------------
__int64 __fastcall _strcasecmp_sse42(__int64 a1, __int64 a2, double a3, double a4, double a5, double a6)
{
  return _strcasecmp_l_sse42(a1, a2, __readfsqword(0xFFFFFFA8), a3, a4, a5, a6);
}

//----- (0000000000430DB4) ----------------------------------------------------
__int64 __fastcall _strcasecmp_l_sse42(__int64 a1, __int64 a2, __int64 a3, double a4, double a5, double a6, double a7)
{
  unsigned int v7; // ecx
  unsigned int v8; // eax
  __m128i si128; // xmm4
  __m128i v10; // xmm5
  __m128i v11; // xmm6
  __m128i v12; // xmm1
  __m128i v13; // xmm2
  __m128i v14; // xmm1
  unsigned __int64 v15; // rdx
  const __m128i *v16; // rsi
  const __m128i *v17; // rdi
  __int64 v18; // r8
  __int64 v19; // rcx
  __int64 v20; // rax
  unsigned int v21; // et0
  const __m128i *v22; // rt1
  __m128i v23; // xmm1
  __m128i v25; // xmm1
  __m128i v26; // xmm2
  __int64 v27; // rdx
  __m128i v28; // xmm0
  __m128i v29; // xmm1
  __m128i v30; // xmm0
  __m128i v31; // xmm1
  unsigned __int8 v32; // cf
  __int64 v33; // rcx
  __m128i v34; // xmm0
  __m128i v35; // xmm1
  __m128i v36; // xmm0
  __m128i v37; // xmm1

  if ( (*(_DWORD *)(*(_QWORD *)a3 + 632LL) & 1) != 0 )
    return _strcasecmp_l_nonascii(a1, a2, a3);
  v7 = a2 & 0x3F;
  v8 = a1 & 0x3F;
  si128 = _mm_load_si128((const __m128i *)&xmmword_482BB0);
  v10 = _mm_load_si128((const __m128i *)&xmmword_482BC0);
  v11 = _mm_load_si128((const __m128i *)&blanks);
  if ( v7 <= 0x30 && v8 <= 0x30 )
  {
    v12 = _mm_loadu_si128((const __m128i *)a1);
    v13 = _mm_loadu_si128((const __m128i *)a2);
    v14 = _mm_or_si128(v12, _mm_and_si128(_mm_and_si128(_mm_cmpgt_epi8(v12, si128), _mm_cmpgt_epi8(v10, v12)), v11));
    v15 = (unsigned int)(_mm_movemask_epi8(
                           _mm_sub_epi8(
                             _mm_cmpeq_epi8(
                               v14,
                               _mm_or_si128(
                                 v13,
                                 _mm_and_si128(_mm_and_si128(_mm_cmpgt_epi8(v13, si128), _mm_cmpgt_epi8(v10, v13)), v11))),
                             _mm_cmpeq_epi8((__m128i)0LL, v14)))
                       - 0xFFFF);
    if ( (_DWORD)v15 )
    {
LABEL_18:
      _BitScanForward64(&v15, v15);
      return (unsigned int)(dword_4860E0[*(unsigned __int8 *)(a1 + v15)] - dword_4860E0[*(unsigned __int8 *)(a2 + v15)]);
    }
    a2 += 16LL;
    a1 += 16LL;
  }
  v16 = (const __m128i *)(a2 & 0xFFFFFFFFFFFFFFF0LL);
  v17 = (const __m128i *)(a1 & 0xFFFFFFFFFFFFFFF0LL);
  v18 = 0LL;
  v19 = v7 & 0xF;
  v20 = v8 & 0xF;
  if ( (_DWORD)v19 != (_DWORD)v20 )
  {
    if ( (unsigned int)v19 <= (unsigned int)v20 )
    {
      v18 = 0xFFFFLL;
      v21 = v20;
      v20 = (unsigned int)v19;
      v19 = v21;
      v22 = v16;
      v16 = v17;
      v17 = v22;
    }
    v23 = _mm_load_si128(v16);
    return ((__int64 (__fastcall *)(const __m128i *, const __m128i *, __int64, __int64, __int64, double, double, double, double, double, double, double))((char *)dword_482C60 + dword_482C60[v20 + 15 - v19]))(
             v17,
             v16,
             0xFFFFLL,
             v19,
             v18,
             *(double *)_mm_cmpeq_epi8((__m128i)0LL, v23).m128i_i64,
             *(double *)v23.m128i_i64,
             *(double *)_mm_load_si128(v17).m128i_i64,
             a7,
             *(double *)si128.m128i_i64,
             *(double *)v10.m128i_i64,
             *(double *)v11.m128i_i64);
  }
  v25 = _mm_load_si128(v16);
  v26 = _mm_load_si128(v17);
  v15 = (0xFFFFu >> v19)
      - ((unsigned int)_mm_movemask_epi8(
                         _mm_sub_epi8(
                           _mm_cmpeq_epi8(
                             _mm_or_si128(
                               v25,
                               _mm_and_si128(_mm_and_si128(_mm_cmpgt_epi8(v25, si128), _mm_cmpgt_epi8(v10, v25)), v11)),
                             _mm_or_si128(
                               v26,
                               _mm_and_si128(_mm_and_si128(_mm_cmpgt_epi8(v26, si128), _mm_cmpgt_epi8(v10, v26)), v11))),
                           _mm_cmpeq_epi8((__m128i)0LL, v25))) >> v19);
  if ( (_DWORD)v15 )
  {
    a1 = (__int64)v17->m128i_i64 + v20;
    a2 = (__int64)v16->m128i_i64 + v19;
    goto LABEL_18;
  }
  v27 = 1LL;
  do
  {
    v28 = _mm_load_si128(&v17[v27]);
    v29 = _mm_load_si128(&v16[v27]);
    v30 = _mm_or_si128(v28, _mm_and_si128(_mm_and_si128(_mm_cmpgt_epi8(v28, si128), _mm_cmpgt_epi8(v10, v28)), v11));
    v31 = _mm_or_si128(v29, _mm_and_si128(_mm_and_si128(_mm_cmpgt_epi8(v29, si128), _mm_cmpgt_epi8(v10, v29)), v11));
    v33 = (unsigned int)_mm_cmpistri(v30, v31, 26);
    v32 = _mm_cmpistrc(v30, v31, 26);
    ++v27;
    if ( v32 | _mm_cmpistrz(v30, v31, 26) )
      break;
    v34 = _mm_load_si128(&v17[v27]);
    v35 = _mm_load_si128(&v16[v27]);
    v36 = _mm_or_si128(v34, _mm_and_si128(_mm_and_si128(_mm_cmpgt_epi8(v34, si128), _mm_cmpgt_epi8(v10, v34)), v11));
    v37 = _mm_or_si128(v35, _mm_and_si128(_mm_and_si128(_mm_cmpgt_epi8(v35, si128), _mm_cmpgt_epi8(v10, v35)), v11));
    v33 = (unsigned int)_mm_cmpistri(v36, v37, 26);
    v32 = _mm_cmpistrc(v36, v37, 26);
    ++v27;
  }
  while ( !(v32 | _mm_cmpistrz(v36, v37, 26)) );
  if ( v32 )
    return (unsigned int)(dword_4860E0[v17[v27 - 1].m128i_u8[v33]] - dword_4860E0[v16[v27 - 1].m128i_u8[v33]]);
  else
    return 0LL;
}
// 482BB0: using guessed type __int128 xmmword_482BB0;
// 482BC0: using guessed type __int128 xmmword_482BC0;
// 482BD0: using guessed type __int128 blanks;
// 482C60: using guessed type int dword_482C60[16];
// 4860E0: using guessed type _DWORD dword_4860E0[256];

//----- (0000000000432950) ----------------------------------------------------
__int64 __fastcall _strcasecmp_avx(__int64 a1, __int64 a2, __m128 a3, double a4, double a5, double a6)
{
  return _strcasecmp_l_avx(a1, a2, __readfsqword(0xFFFFFFA8), a3, a4, a5, a6);
}

//----- (0000000000432964) ----------------------------------------------------
__int64 __fastcall _strcasecmp_l_avx(
        __int64 _RDI,
        __int64 _RSI,
        __int64 a3,
        __m128 _XMM0,
        double a5,
        double a6,
        double a7)
{
  unsigned int v7; // ecx
  unsigned int v8; // eax
  unsigned __int64 v28; // rdx
  __int64 v31; // r8
  __int64 v32; // rcx
  __int64 v33; // rax
  unsigned int v35; // et0
  unsigned __int64 v36; // rt1
  unsigned int v57; // er9

  if ( (*(_DWORD *)(*(_QWORD *)a3 + 632LL) & 1) != 0 )
    return _strcasecmp_l_nonascii(_RDI, _RSI, a3);
  v7 = _RSI & 0x3F;
  v8 = _RDI & 0x3F;
  __asm
  {
    vmovdqa xmm4, cs:xmmword_482BB0
    vmovdqa xmm5, cs:xmmword_482CA0
    vmovdqa xmm6, cs:blanks
  }
  if ( v7 <= 0x30 && v8 <= 0x30 )
  {
    __asm
    {
      vmovdqu xmm1, xmmword ptr [rdi]
      vmovdqu xmm2, xmmword ptr [rsi]
      vpcmpgtb xmm7, xmm1, xmm4
      vpcmpgtb xmm8, xmm1, xmm5
      vpcmpgtb xmm9, xmm2, xmm4
      vpcmpgtb xmm10, xmm2, xmm5
      vpandn  xmm8, xmm8, xmm7
      vpandn  xmm10, xmm10, xmm9
      vpand   xmm8, xmm8, xmm6
      vpand   xmm10, xmm10, xmm6
      vpor    xmm1, xmm8, xmm1
      vpor    xmm2, xmm10, xmm2
      vpxor   xmm0, xmm0, xmm0
      vpcmpeqb xmm0, xmm0, xmm1
      vpcmpeqb xmm1, xmm1, xmm2
      vpsubb  xmm1, xmm1, xmm0
      vpmovmskb edx, xmm1
    }
    v28 = (unsigned int)(_EDX - 0xFFFF);
    if ( (_DWORD)v28 )
    {
LABEL_17:
      _BitScanForward64(&v28, v28);
      return (unsigned int)(dword_4860E0[*(unsigned __int8 *)(_RDI + v28)]
                          - dword_4860E0[*(unsigned __int8 *)(_RSI + v28)]);
    }
    _RSI += 16LL;
    _RDI += 16LL;
  }
  _RSI = _RSI & 0xFFFFFFFFFFFFFFF0LL;
  _RDI = _RDI & 0xFFFFFFFFFFFFFFF0LL;
  v31 = 0LL;
  v32 = v7 & 0xF;
  v33 = v8 & 0xF;
  __asm { vpxor   xmm0, xmm0, xmm0 }
  if ( (_DWORD)v32 != (_DWORD)v33 )
  {
    if ( (unsigned int)v32 <= (unsigned int)v33 )
    {
      v31 = 0xFFFFLL;
      v35 = v33;
      v33 = (unsigned int)v32;
      v32 = v35;
      v36 = _RSI;
      _RSI = _RDI;
      _RDI = v36;
    }
    __asm
    {
      vmovdqa xmm2, xmmword ptr [rdi]
      vmovdqa xmm1, xmmword ptr [rsi]
      vpcmpeqb xmm0, xmm0, xmm1
    }
    return ((__int64 (__fastcall *)(unsigned __int64, unsigned __int64, __int64, __int64, __int64, double, double, double, double, double, double, double))((char *)dword_482CB0 + dword_482CB0[v33 + 15 - v32]))(
             _RDI,
             _RSI,
             0xFFFFLL,
             v32,
             v31,
             *(double *)&_XMM0,
             *(double *)&_XMM1,
             *(double *)&_XMM2,
             a7,
             *(double *)&_XMM4,
             *(double *)&_XMM5,
             *(double *)&_XMM6);
  }
  __asm
  {
    vmovdqa xmm1, xmmword ptr [rsi]
    vpcmpeqb xmm0, xmm0, xmm1
    vmovdqa xmm2, xmmword ptr [rdi]
    vpcmpgtb xmm7, xmm1, xmm4
    vpcmpgtb xmm8, xmm1, xmm5
    vpcmpgtb xmm9, xmm2, xmm4
    vpcmpgtb xmm10, xmm2, xmm5
    vpandn  xmm8, xmm8, xmm7
    vpandn  xmm10, xmm10, xmm9
    vpand   xmm8, xmm8, xmm6
    vpand   xmm10, xmm10, xmm6
    vpor    xmm1, xmm8, xmm1
    vpor    xmm2, xmm10, xmm2
    vpcmpeqb xmm1, xmm1, xmm2
    vpsubb  xmm1, xmm1, xmm0
    vpmovmskb r9d, xmm1
  }
  v57 = _ER9 >> v32;
  v28 = (0xFFFFu >> v32) - v57;
  if ( (_DWORD)v28 )
  {
    _RDI = _RDI + v33;
    _RSI = _RSI + v32;
    goto LABEL_17;
  }
  _RDX = 16LL;
  do
  {
    __asm
    {
      vmovdqa xmm0, xmmword ptr [rdi+rdx]
      vmovdqa xmm1, xmmword ptr [rsi+rdx]
      vpcmpgtb xmm7, xmm0, xmm4
      vpcmpgtb xmm8, xmm0, xmm5
      vpcmpgtb xmm9, xmm1, xmm4
      vpcmpgtb xmm10, xmm1, xmm5
      vpandn  xmm8, xmm8, xmm7
      vpandn  xmm10, xmm10, xmm9
      vpand   xmm8, xmm8, xmm6
      vpand   xmm10, xmm10, xmm6
      vpor    xmm0, xmm8, xmm0
      vpor    xmm1, xmm10, xmm1
      vpcmpistri xmm0, xmm1, 1Ah
    }
    _RDX += 16LL;
    if ( 0xFFFFu >> v32 <= v57 )
      break;
    __asm
    {
      vmovdqa xmm0, xmmword ptr [rdi+rdx]
      vmovdqa xmm1, xmmword ptr [rsi+rdx]
      vpcmpgtb xmm7, xmm0, xmm4
      vpcmpgtb xmm8, xmm0, xmm5
      vpcmpgtb xmm9, xmm1, xmm4
      vpcmpgtb xmm10, xmm1, xmm5
      vpandn  xmm8, xmm8, xmm7
      vpandn  xmm10, xmm10, xmm9
      vpand   xmm8, xmm8, xmm6
      vpand   xmm10, xmm10, xmm6
      vpor    xmm0, xmm8, xmm0
      vpor    xmm1, xmm10, xmm1
      vpcmpistri xmm0, xmm1, 1Ah
    }
    _RDX += 16LL;
  }
  while ( 0xFFFFu >> v32 > v57 );
  if ( 0xFFFFu >> v32 >= v57 )
    return 0LL;
  else
    return (unsigned int)(dword_4860E0[*(unsigned __int8 *)(_RDI + _RDX)]
                        - dword_4860E0[*(unsigned __int8 *)(_RSI + _RDX)]);
}
// 482BB0: using guessed type __int128 xmmword_482BB0;
// 482BD0: using guessed type __int128 blanks;
// 482CB0: using guessed type int dword_482CB0[16];
// 4860E0: using guessed type _DWORD dword_4860E0[256];

//----- (0000000000433FD0) ----------------------------------------------------
__int8 *__fastcall _strchr_sse2(const __m128i *a1, char a2)
{
  __m128i v2; // xmm1
  __m128i v3; // xmm1
  __m128i v4; // xmm1
  __m128i v5; // xmm4
  __int64 v6; // rax
  __int8 *result; // rax
  __m128i v8; // xmm4
  unsigned int v9; // ecx
  __m128i v10; // xmm4
  __m128i v11; // xmm0
  unsigned __int64 v12; // rax
  __m128i v13; // xmm2
  __m128i v14; // xmm3
  __m128i v15; // xmm4
  __m128i v16; // xmm0
  __m128i si128; // xmm4
  unsigned int v18; // er8
  __m128i v19; // xmm4
  unsigned int v20; // eax
  __m128i v21; // xmm4
  __m128i v22; // xmm3

  v2 = _mm_cvtsi32_si128(a2);
  v3 = _mm_unpacklo_epi8(v2, v2);
  v4 = _mm_shuffle_epi32(_mm_unpacklo_epi16(v3, v3), 0);
  if ( ((unsigned __int16)a1 & 0xFFFu) > 0xFC0 )
  {
    si128 = _mm_load_si128((const __m128i *)((unsigned __int64)a1 & 0xFFFFFFFFFFFFFFC0LL));
    v18 = _mm_movemask_epi8(_mm_or_si128(_mm_cmpeq_epi8(si128, v4), _mm_cmpeq_epi8(si128, (__m128i)0LL)));
    v19 = _mm_load_si128((const __m128i *)(((unsigned __int64)a1 & 0xFFFFFFFFFFFFFFC0LL) + 16));
    v20 = _mm_movemask_epi8(_mm_or_si128(_mm_cmpeq_epi8(v19, v4), _mm_cmpeq_epi8(v19, (__m128i)0LL)));
    v21 = _mm_load_si128((const __m128i *)(((unsigned __int64)a1 & 0xFFFFFFFFFFFFFFC0LL) + 32));
    v22 = _mm_load_si128((const __m128i *)(((unsigned __int64)a1 & 0xFFFFFFFFFFFFFFC0LL) + 48));
    v12 = (((unsigned __int64)(unsigned int)_mm_movemask_epi8(_mm_or_si128(_mm_cmpeq_epi8(v4, v22), _mm_cmpeq_epi8((__m128i)0LL, v22))) << 48) | v18 | ((unsigned __int64)(unsigned int)_mm_movemask_epi8(_mm_or_si128(_mm_cmpeq_epi8(v21, v4), _mm_cmpeq_epi8(v21, (__m128i)0LL))) << 32) | ((unsigned __int64)v20 << 16)) >> ((unsigned __int8)a1 - ((unsigned __int8)a1 & 0xC0u));
    if ( v12 )
      goto LABEL_10;
    goto LABEL_7;
  }
  v5 = _mm_loadu_si128(a1);
  LODWORD(v6) = _mm_movemask_epi8(_mm_or_si128(_mm_cmpeq_epi8(v5, v4), _mm_cmpeq_epi8(v5, (__m128i)0LL)));
  if ( (_DWORD)v6 )
  {
    _BitScanForward((unsigned int *)&v6, v6);
    result = &a1->m128i_i8[v6];
    if ( *result != a2 )
      return 0LL;
    return result;
  }
  v8 = _mm_loadu_si128(a1 + 1);
  v9 = _mm_movemask_epi8(_mm_or_si128(_mm_cmpeq_epi8(v8, v4), _mm_cmpeq_epi8(v8, (__m128i)0LL)));
  v10 = _mm_loadu_si128(a1 + 2);
  v11 = _mm_loadu_si128(a1 + 3);
  v12 = ((unsigned __int64)(unsigned int)_mm_movemask_epi8(_mm_or_si128(_mm_cmpeq_epi8(v11, v4), _mm_cmpeq_epi8((__m128i)0LL, v11))) << 48) | ((unsigned __int64)v9 << 16) | ((unsigned __int64)(unsigned int)_mm_movemask_epi8(_mm_or_si128(_mm_cmpeq_epi8(v10, v4), _mm_cmpeq_epi8(v10, (__m128i)0LL))) << 32);
  if ( !v12 )
  {
LABEL_7:
    a1 = (const __m128i *)((unsigned __int64)a1 & 0xFFFFFFFFFFFFFFC0LL);
    do
    {
      a1 += 4;
      v13 = _mm_min_epu8(_mm_xor_si128(_mm_load_si128(a1 + 1), v4), a1[1]);
      v14 = _mm_min_epu8(_mm_xor_si128(_mm_load_si128(a1 + 2), v4), a1[2]);
      v15 = _mm_min_epu8(_mm_xor_si128(_mm_load_si128(a1 + 3), v4), a1[3]);
    }
    while ( !_mm_movemask_epi8(
               _mm_cmpeq_epi8(
                 _mm_min_epu8(
                   _mm_min_epu8(_mm_min_epu8(_mm_min_epu8(_mm_xor_si128(_mm_load_si128(a1), v4), *a1), v13), v14),
                   v15),
                 (__m128i)0LL)) );
    v16 = _mm_load_si128(a1);
    v12 = ((unsigned __int64)(unsigned int)_mm_movemask_epi8(_mm_cmpeq_epi8(v15, (__m128i)0LL)) << 48) | (unsigned int)_mm_movemask_epi8(_mm_or_si128(_mm_cmpeq_epi8(v16, v4), _mm_cmpeq_epi8(v16, (__m128i)0LL))) | ((unsigned __int64)(unsigned int)_mm_movemask_epi8(_mm_cmpeq_epi8(v14, (__m128i)0LL)) << 32) | ((unsigned __int64)(unsigned int)_mm_movemask_epi8(_mm_cmpeq_epi8(v13, (__m128i)0LL)) << 16);
  }
LABEL_10:
  _BitScanForward64(&v12, v12);
  result = &a1->m128i_i8[v12];
  if ( *result != a2 )
    return 0LL;
  return result;
}
// 43401F: variable 'v6' is possibly undefined

//----- (0000000000434200) ----------------------------------------------------
char *__fastcall _strchrnul_sse2(const __m128i *a1, unsigned int a2)
{
  __m128i v2; // xmm1
  __m128i v3; // xmm1
  __m128i v4; // xmm1
  __m128i v5; // xmm4
  __int64 v6; // rax
  __m128i v8; // xmm4
  unsigned int v9; // ecx
  __m128i v10; // xmm4
  __m128i v11; // xmm0
  unsigned __int64 v12; // rax
  __m128i v13; // xmm2
  __m128i v14; // xmm3
  __m128i v15; // xmm4
  __m128i v16; // xmm0
  __m128i si128; // xmm4
  unsigned int v18; // er8
  __m128i v19; // xmm4
  unsigned int v20; // eax
  __m128i v21; // xmm4
  __m128i v22; // xmm3

  v2 = _mm_cvtsi32_si128(a2);
  v3 = _mm_unpacklo_epi8(v2, v2);
  v4 = _mm_shuffle_epi32(_mm_unpacklo_epi16(v3, v3), 0);
  if ( ((unsigned __int16)a1 & 0xFFFu) > 0xFC0 )
  {
    si128 = _mm_load_si128((const __m128i *)((unsigned __int64)a1 & 0xFFFFFFFFFFFFFFC0LL));
    v18 = _mm_movemask_epi8(_mm_or_si128(_mm_cmpeq_epi8(si128, v4), _mm_cmpeq_epi8(si128, (__m128i)0LL)));
    v19 = _mm_load_si128((const __m128i *)(((unsigned __int64)a1 & 0xFFFFFFFFFFFFFFC0LL) + 16));
    v20 = _mm_movemask_epi8(_mm_or_si128(_mm_cmpeq_epi8(v19, v4), _mm_cmpeq_epi8(v19, (__m128i)0LL)));
    v21 = _mm_load_si128((const __m128i *)(((unsigned __int64)a1 & 0xFFFFFFFFFFFFFFC0LL) + 32));
    v22 = _mm_load_si128((const __m128i *)(((unsigned __int64)a1 & 0xFFFFFFFFFFFFFFC0LL) + 48));
    v12 = (((unsigned __int64)(unsigned int)_mm_movemask_epi8(_mm_or_si128(_mm_cmpeq_epi8(v4, v22), _mm_cmpeq_epi8((__m128i)0LL, v22))) << 48) | v18 | ((unsigned __int64)(unsigned int)_mm_movemask_epi8(_mm_or_si128(_mm_cmpeq_epi8(v21, v4), _mm_cmpeq_epi8(v21, (__m128i)0LL))) << 32) | ((unsigned __int64)v20 << 16)) >> ((unsigned __int8)a1 - ((unsigned __int8)a1 & 0xC0u));
    if ( !v12 )
    {
LABEL_5:
      a1 = (const __m128i *)((unsigned __int64)a1 & 0xFFFFFFFFFFFFFFC0LL);
      do
      {
        a1 += 4;
        v13 = _mm_min_epu8(_mm_xor_si128(_mm_load_si128(a1 + 1), v4), a1[1]);
        v14 = _mm_min_epu8(_mm_xor_si128(_mm_load_si128(a1 + 2), v4), a1[2]);
        v15 = _mm_min_epu8(_mm_xor_si128(_mm_load_si128(a1 + 3), v4), a1[3]);
      }
      while ( !_mm_movemask_epi8(
                 _mm_cmpeq_epi8(
                   _mm_min_epu8(
                     _mm_min_epu8(_mm_min_epu8(_mm_min_epu8(_mm_xor_si128(_mm_load_si128(a1), v4), *a1), v13), v14),
                     v15),
                   (__m128i)0LL)) );
      v16 = _mm_load_si128(a1);
      v12 = ((unsigned __int64)(unsigned int)_mm_movemask_epi8(_mm_cmpeq_epi8(v15, (__m128i)0LL)) << 48) | (unsigned int)_mm_movemask_epi8(_mm_or_si128(_mm_cmpeq_epi8(v16, v4), _mm_cmpeq_epi8(v16, (__m128i)0LL))) | ((unsigned __int64)(unsigned int)_mm_movemask_epi8(_mm_cmpeq_epi8(v14, (__m128i)0LL)) << 32) | ((unsigned __int64)(unsigned int)_mm_movemask_epi8(_mm_cmpeq_epi8(v13, (__m128i)0LL)) << 16);
    }
  }
  else
  {
    v5 = _mm_loadu_si128(a1);
    LODWORD(v6) = _mm_movemask_epi8(_mm_or_si128(_mm_cmpeq_epi8(v5, v4), _mm_cmpeq_epi8(v5, (__m128i)0LL)));
    if ( (_DWORD)v6 )
    {
      _BitScanForward((unsigned int *)&v6, v6);
      return (char *)a1 + v6;
    }
    v8 = _mm_loadu_si128(a1 + 1);
    v9 = _mm_movemask_epi8(_mm_or_si128(_mm_cmpeq_epi8(v8, v4), _mm_cmpeq_epi8(v8, (__m128i)0LL)));
    v10 = _mm_loadu_si128(a1 + 2);
    v11 = _mm_loadu_si128(a1 + 3);
    v12 = ((unsigned __int64)(unsigned int)_mm_movemask_epi8(_mm_or_si128(_mm_cmpeq_epi8(v11, v4), _mm_cmpeq_epi8((__m128i)0LL, v11))) << 48) | ((unsigned __int64)v9 << 16) | ((unsigned __int64)(unsigned int)_mm_movemask_epi8(_mm_or_si128(_mm_cmpeq_epi8(v10, v4), _mm_cmpeq_epi8(v10, (__m128i)0LL))) << 32);
    if ( !v12 )
      goto LABEL_5;
  }
  _BitScanForward64(&v12, v12);
  return (char *)a1 + v12;
}
// 43424A: variable 'v6' is possibly undefined

//----- (0000000000434410) ----------------------------------------------------
__int64 __fastcall _strchr_avx2(unsigned __int64 _RDI, int _ESI)
{
  unsigned __int64 v12; // rcx
  __int128 v19; // rax

  __asm
  {
    vmovd   xmm0, esi
    vpxor   xmm9, xmm9, xmm9
    vpbroadcastb ymm0, xmm0
  }
  if ( (_RDI & 0x3F) <= 0x20 )
  {
    __asm
    {
      vmovdqu ymm8, ymmword ptr [rdi]
      vpcmpeqb ymm1, ymm0, ymm8
      vpcmpeqb ymm2, ymm9, ymm8
      vpor    ymm1, ymm2, ymm1
      vpmovmskb eax, ymm1
    }
    if ( (_DWORD)_RAX )
    {
LABEL_16:
      __asm { tzcnt   eax, eax }
      v19 = _RDI + _RAX;
      if ( (_BYTE)_ESI != *(_BYTE *)v19 )
        *(_QWORD *)&v19 = *((_QWORD *)&v19 + 1);
      __asm { vzeroupper }
      return v19;
    }
    _RDI = (_RDI + 32) & 0xFFFFFFFFFFFFFFE0LL;
LABEL_9:
    __asm
    {
      vmovdqa ymm8, ymmword ptr [rdi]
      vpcmpeqb ymm1, ymm0, ymm8
      vpcmpeqb ymm2, ymm9, ymm8
      vpor    ymm1, ymm2, ymm1
      vpmovmskb eax, ymm1
    }
    if ( !(_DWORD)_RAX )
    {
      __asm
      {
        vmovdqa ymm8, ymmword ptr [rdi+20h]
        vpcmpeqb ymm1, ymm0, ymm8
        vpcmpeqb ymm2, ymm9, ymm8
        vpor    ymm1, ymm2, ymm1
        vpmovmskb eax, ymm1
      }
      if ( (_DWORD)_RAX )
      {
LABEL_19:
        __asm { tzcnt   eax, eax }
        v19 = _RDI + _RAX + 32;
        if ( (_BYTE)_ESI != *(_BYTE *)v19 )
          *(_QWORD *)&v19 = *((_QWORD *)&v19 + 1);
        __asm { vzeroupper }
        return v19;
      }
      __asm
      {
        vmovdqa ymm8, ymmword ptr [rdi+40h]
        vpcmpeqb ymm1, ymm0, ymm8
        vpcmpeqb ymm2, ymm9, ymm8
        vpor    ymm1, ymm2, ymm1
        vpmovmskb eax, ymm1
      }
      if ( (_DWORD)_RAX )
      {
LABEL_22:
        __asm { tzcnt   eax, eax }
        v19 = _RDI + _RAX + 64;
        if ( (_BYTE)_ESI != *(_BYTE *)v19 )
          *(_QWORD *)&v19 = *((_QWORD *)&v19 + 1);
        __asm { vzeroupper }
        return v19;
      }
      __asm
      {
        vmovdqa ymm8, ymmword ptr [rdi+60h]
        vpcmpeqb ymm1, ymm0, ymm8
        vpcmpeqb ymm2, ymm9, ymm8
        vpor    ymm1, ymm2, ymm1
        vpmovmskb eax, ymm1
      }
      if ( (_DWORD)_RAX )
      {
LABEL_29:
        __asm { tzcnt   eax, eax }
        v19 = _RDI + _RAX + 96;
        if ( (_BYTE)_ESI != *(_BYTE *)v19 )
          *(_QWORD *)&v19 = *((_QWORD *)&v19 + 1);
        __asm { vzeroupper }
        return v19;
      }
      for ( _RDI = (_RDI + 128) & 0xFFFFFFFFFFFFFF80LL; ; _RDI += 128LL )
      {
        __asm
        {
          vmovdqa ymm5, ymmword ptr [rdi]
          vmovdqa ymm6, ymmword ptr [rdi+20h]
          vmovdqa ymm7, ymmword ptr [rdi+40h]
          vmovdqa ymm8, ymmword ptr [rdi+60h]
          vpcmpeqb ymm1, ymm0, ymm5
          vpcmpeqb ymm2, ymm0, ymm6
          vpcmpeqb ymm3, ymm0, ymm7
          vpcmpeqb ymm4, ymm0, ymm8
          vpcmpeqb ymm5, ymm9, ymm5
          vpcmpeqb ymm6, ymm9, ymm6
          vpcmpeqb ymm7, ymm9, ymm7
          vpcmpeqb ymm8, ymm9, ymm8
          vpor    ymm1, ymm5, ymm1
          vpor    ymm2, ymm6, ymm2
          vpor    ymm3, ymm7, ymm3
          vpor    ymm4, ymm8, ymm4
          vpor    ymm5, ymm2, ymm1
          vpor    ymm6, ymm4, ymm3
          vpor    ymm5, ymm6, ymm5
          vpmovmskb eax, ymm5
        }
        if ( _EAX )
          break;
      }
      __asm { vpmovmskb eax, ymm1 }
      if ( !(_DWORD)_RAX )
      {
        __asm { vpmovmskb eax, ymm2 }
        if ( !(_DWORD)_RAX )
        {
          __asm { vpmovmskb eax, ymm3 }
          if ( !(_DWORD)_RAX )
          {
            __asm { vpmovmskb eax, ymm4 }
            goto LABEL_29;
          }
          goto LABEL_22;
        }
        goto LABEL_19;
      }
    }
    goto LABEL_16;
  }
  v12 = _RDI & 0x1F;
  _RDI = _RDI & 0xFFFFFFFFFFFFFFE0LL;
  __asm
  {
    vmovdqu ymm8, ymmword ptr [rdi]
    vpcmpeqb ymm1, ymm0, ymm8
    vpcmpeqb ymm2, ymm9, ymm8
    vpor    ymm1, ymm2, ymm1
    vpmovmskb eax, ymm1
  }
  _RAX = (unsigned int)(_EAX >> v12);
  if ( !(_DWORD)_RAX )
  {
    _RDI = _RDI + 32;
    goto LABEL_9;
  }
  __asm { tzcnt   eax, eax }
  v19 = _RDI + v12 + _RAX;
  if ( (_BYTE)_ESI != *(_BYTE *)v19 )
    *(_QWORD *)&v19 = *((_QWORD *)&v19 + 1);
  __asm { vzeroupper }
  return v19;
}
// 4345A4: variable '_RAX' is possibly undefined

//----- (0000000000434640) ----------------------------------------------------
unsigned __int64 __fastcall _strchrnul_avx2(unsigned __int64 _RDI, int _ESI)
{
  unsigned __int64 v12; // rcx
  unsigned __int64 result; // rax

  __asm
  {
    vmovd   xmm0, esi
    vpxor   xmm9, xmm9, xmm9
    vpbroadcastb ymm0, xmm0
  }
  if ( (_RDI & 0x3F) > 0x20 )
  {
    v12 = _RDI & 0x1F;
    _RDI = _RDI & 0xFFFFFFFFFFFFFFE0LL;
    __asm
    {
      vmovdqu ymm8, ymmword ptr [rdi]
      vpcmpeqb ymm1, ymm0, ymm8
      vpcmpeqb ymm2, ymm9, ymm8
      vpor    ymm1, ymm2, ymm1
      vpmovmskb eax, ymm1
    }
    _RAX = (unsigned int)(_EAX >> v12);
    if ( (_DWORD)_RAX )
    {
      __asm { tzcnt   eax, eax }
      result = _RDI + v12 + _RAX;
      __asm { vzeroupper }
      return result;
    }
    _RDI = _RDI + 32;
  }
  else
  {
    __asm
    {
      vmovdqu ymm8, ymmword ptr [rdi]
      vpcmpeqb ymm1, ymm0, ymm8
      vpcmpeqb ymm2, ymm9, ymm8
      vpor    ymm1, ymm2, ymm1
      vpmovmskb eax, ymm1
    }
    if ( (_DWORD)_RAX )
      goto LABEL_14;
    _RDI = (_RDI + 32) & 0xFFFFFFFFFFFFFFE0LL;
  }
  __asm
  {
    vmovdqa ymm8, ymmword ptr [rdi]
    vpcmpeqb ymm1, ymm0, ymm8
    vpcmpeqb ymm2, ymm9, ymm8
    vpor    ymm1, ymm2, ymm1
    vpmovmskb eax, ymm1
  }
  if ( (_DWORD)_RAX )
    goto LABEL_14;
  __asm
  {
    vmovdqa ymm8, ymmword ptr [rdi+20h]
    vpcmpeqb ymm1, ymm0, ymm8
    vpcmpeqb ymm2, ymm9, ymm8
    vpor    ymm1, ymm2, ymm1
    vpmovmskb eax, ymm1
  }
  if ( (_DWORD)_RAX )
    goto LABEL_15;
  __asm
  {
    vmovdqa ymm8, ymmword ptr [rdi+40h]
    vpcmpeqb ymm1, ymm0, ymm8
    vpcmpeqb ymm2, ymm9, ymm8
    vpor    ymm1, ymm2, ymm1
    vpmovmskb eax, ymm1
  }
  if ( (_DWORD)_RAX )
    goto LABEL_16;
  __asm
  {
    vmovdqa ymm8, ymmword ptr [rdi+60h]
    vpcmpeqb ymm1, ymm0, ymm8
    vpcmpeqb ymm2, ymm9, ymm8
    vpor    ymm1, ymm2, ymm1
    vpmovmskb eax, ymm1
  }
  if ( !(_DWORD)_RAX )
  {
    for ( _RDI = (_RDI + 128) & 0xFFFFFFFFFFFFFF80LL; ; _RDI += 128LL )
    {
      __asm
      {
        vmovdqa ymm5, ymmword ptr [rdi]
        vmovdqa ymm6, ymmword ptr [rdi+20h]
        vmovdqa ymm7, ymmword ptr [rdi+40h]
        vmovdqa ymm8, ymmword ptr [rdi+60h]
        vpcmpeqb ymm1, ymm0, ymm5
        vpcmpeqb ymm2, ymm0, ymm6
        vpcmpeqb ymm3, ymm0, ymm7
        vpcmpeqb ymm4, ymm0, ymm8
        vpcmpeqb ymm5, ymm9, ymm5
        vpcmpeqb ymm6, ymm9, ymm6
        vpcmpeqb ymm7, ymm9, ymm7
        vpcmpeqb ymm8, ymm9, ymm8
        vpor    ymm1, ymm5, ymm1
        vpor    ymm2, ymm6, ymm2
        vpor    ymm3, ymm7, ymm3
        vpor    ymm4, ymm8, ymm4
        vpor    ymm5, ymm2, ymm1
        vpor    ymm6, ymm4, ymm3
        vpor    ymm5, ymm6, ymm5
        vpmovmskb eax, ymm5
      }
      if ( _EAX )
        break;
    }
    __asm { vpmovmskb eax, ymm1 }
    if ( !(_DWORD)_RAX )
    {
      __asm { vpmovmskb eax, ymm2 }
      if ( !(_DWORD)_RAX )
      {
        __asm { vpmovmskb eax, ymm3 }
        if ( !(_DWORD)_RAX )
        {
          __asm { vpmovmskb eax, ymm4 }
          goto LABEL_21;
        }
LABEL_16:
        __asm { tzcnt   eax, eax }
        result = _RDI + _RAX + 64;
        __asm { vzeroupper }
        return result;
      }
LABEL_15:
      __asm { tzcnt   eax, eax }
      result = _RDI + _RAX + 32;
      __asm { vzeroupper }
      return result;
    }
LABEL_14:
    __asm { tzcnt   eax, eax }
    result = _RDI + _RAX;
    __asm { vzeroupper }
    return result;
  }
LABEL_21:
  __asm { tzcnt   eax, eax }
  result = _RDI + _RAX + 96;
  __asm { vzeroupper }
  return result;
}
// 4347D4: variable '_RAX' is possibly undefined

//----- (0000000000434830) ----------------------------------------------------
int __fastcall _strlen_sse2(const __m128i *a1)
{
  unsigned int v1; // edx
  __m128i *v2; // rax
  __m128i v3; // xmm1
  __m128i v4; // xmm2
  __m128i v5; // xmm3
  __int64 v6; // rdx
  unsigned __int64 v7; // rdx

  if ( ((unsigned __int16)a1 & 0xFFFu) <= 0xFCFuLL )
  {
    v1 = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_loadu_si128(a1), (__m128i)0LL));
    if ( v1 )
    {
      _BitScanForward((unsigned int *)&v2, v1);
      return (int)v2;
    }
    v3 = _mm_cmpeq_epi8((__m128i)0LL, *(__m128i *)(((unsigned __int64)a1 & 0xFFFFFFFFFFFFFFF0LL) + 0x10));
    v4 = _mm_cmpeq_epi8((__m128i)0LL, *(__m128i *)(((unsigned __int64)a1 & 0xFFFFFFFFFFFFFFF0LL) + 0x20));
    v5 = _mm_cmpeq_epi8((__m128i)0LL, *(__m128i *)(((unsigned __int64)a1 & 0xFFFFFFFFFFFFFFF0LL) + 0x30));
    v2 = (__m128i *)((unsigned __int64)a1 & 0xFFFFFFFFFFFFFFC0LL);
    v6 = (__int64)((((unsigned int)_mm_movemask_epi8(v4) | ((unsigned __int64)(unsigned int)_mm_movemask_epi8(v5) << 16)) << 32) | ((unsigned __int64)(unsigned int)_mm_movemask_epi8(v3) << 16)) >> ((unsigned __int8)a1 & 0xF0u ^ (unsigned __int8)a1);
    if ( !v6 )
      goto LABEL_8;
LABEL_5:
    _BitScanForward64((unsigned __int64 *)&v2, v6);
    return (int)v2;
  }
  v2 = (__m128i *)((unsigned __int64)a1 & 0xFFFFFFFFFFFFFFC0LL);
  v6 = (__int64)((((unsigned int)_mm_movemask_epi8(
                                   _mm_cmpeq_epi8(
                                     (__m128i)0LL,
                                     *(__m128i *)(((unsigned __int64)a1 & 0xFFFFFFFFFFFFFFC0LL) + 0x20))) | ((unsigned __int64)(unsigned int)_mm_movemask_epi8(_mm_cmpeq_epi8((__m128i)0LL, *(__m128i *)(((unsigned __int64)a1 & 0xFFFFFFFFFFFFFFC0LL) + 0x30))) << 16)) << 32) | (unsigned int)_mm_movemask_epi8(_mm_cmpeq_epi8((__m128i)0LL, *(__m128i *)((unsigned __int64)a1 & 0xFFFFFFFFFFFFFFC0LL))) | ((unsigned __int64)(unsigned int)_mm_movemask_epi8(_mm_cmpeq_epi8((__m128i)0LL, *(__m128i *)(((unsigned __int64)a1 & 0xFFFFFFFFFFFFFFC0LL) + 0x10))) << 16)) >> ((unsigned __int8)a1 & 0xC0u ^ (unsigned __int8)a1);
  if ( v6 )
    goto LABEL_5;
  v3 = 0LL;
  v4 = 0LL;
  v5 = 0LL;
LABEL_8:
  while ( !_mm_movemask_epi8(_mm_cmpeq_epi8(_mm_min_epu8(_mm_min_epu8(_mm_min_epu8(_mm_load_si128(v2 + 4), v2[5]), v2[6]), v2[7]), v5)) )
  {
    v2 += 8;
    if ( _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_min_epu8(_mm_min_epu8(_mm_min_epu8(_mm_load_si128(v2), v2[1]), v2[2]), v2[3]), v5)) )
      goto LABEL_12;
  }
  v2 += 4;
LABEL_12:
  _BitScanForward64(
    &v7,
    (((unsigned int)_mm_movemask_epi8(_mm_cmpeq_epi8(v4, v2[2])) | ((unsigned __int64)(unsigned int)_mm_movemask_epi8(_mm_cmpeq_epi8(v5, v2[3])) << 16)) << 32) | (unsigned int)_mm_movemask_epi8(_mm_cmpeq_epi8((__m128i)0LL, *v2)) | ((unsigned __int64)(unsigned int)_mm_movemask_epi8(_mm_cmpeq_epi8(v3, v2[1])) << 16));
  LODWORD(v2) = v7 + (_DWORD)v2 - (_DWORD)a1;
  return (int)v2;
}

//----- (00000000004349D0) ----------------------------------------------------
unsigned __int64 __fastcall _strlen_avx2(unsigned __int64 _RDI, __m128 _XMM0)
{
  unsigned __int64 v4; // rdx
  unsigned __int64 v7; // rcx
  unsigned __int64 v8; // rdi
  unsigned __int64 result; // rax

  v4 = _RDI;
  __asm { vpxor   xmm0, xmm0, xmm0 }
  if ( (_RDI & 0x3F) > 0x20 )
  {
    v7 = _RDI & 0x1F;
    v8 = _RDI & 0xFFFFFFFFFFFFFFE0LL;
    __asm
    {
      vpcmpeqb ymm1, ymm0, ymmword ptr [rdi]
      vpmovmskb eax, ymm1
    }
    _RAX = (unsigned int)(_EAX >> v7);
    if ( (_DWORD)_RAX )
    {
      __asm { tzcnt   eax, eax }
      result = v7 + v8 + _RAX - v4;
      __asm { vzeroupper }
      return result;
    }
    _RDI = v8 + 32;
  }
  else
  {
    __asm
    {
      vpcmpeqb ymm1, ymm0, ymmword ptr [rdi]
      vpmovmskb eax, ymm1
    }
    if ( (_DWORD)_RAX )
      goto LABEL_14;
    _RDI = (_RDI + 32) & 0xFFFFFFFFFFFFFFE0LL;
  }
  __asm
  {
    vpcmpeqb ymm1, ymm0, ymmword ptr [rdi]
    vpmovmskb eax, ymm1
  }
  if ( (_DWORD)_RAX )
    goto LABEL_14;
  __asm
  {
    vpcmpeqb ymm1, ymm0, ymmword ptr [rdi+20h]
    vpmovmskb eax, ymm1
  }
  if ( (_DWORD)_RAX )
    goto LABEL_15;
  __asm
  {
    vpcmpeqb ymm1, ymm0, ymmword ptr [rdi+40h]
    vpmovmskb eax, ymm1
  }
  if ( (_DWORD)_RAX )
    goto LABEL_16;
  __asm
  {
    vpcmpeqb ymm1, ymm0, ymmword ptr [rdi+60h]
    vpmovmskb eax, ymm1
  }
  if ( !(_DWORD)_RAX )
  {
    for ( _RDI = (_RDI + 128) & 0xFFFFFFFFFFFFFF80LL; ; _RDI += 128LL )
    {
      __asm
      {
        vmovdqa ymm1, ymmword ptr [rdi]
        vmovdqa ymm2, ymmword ptr [rdi+20h]
        vmovdqa ymm3, ymmword ptr [rdi+40h]
        vmovdqa ymm4, ymmword ptr [rdi+60h]
        vpminub ymm5, ymm2, ymm1
        vpminub ymm6, ymm4, ymm3
        vpminub ymm5, ymm6, ymm5
        vpcmpeqb ymm5, ymm0, ymm5
        vpmovmskb eax, ymm5
      }
      if ( _EAX )
        break;
    }
    __asm
    {
      vpcmpeqb ymm1, ymm0, ymm1
      vpmovmskb eax, ymm1
    }
    if ( !(_DWORD)_RAX )
    {
      __asm
      {
        vpcmpeqb ymm2, ymm0, ymm2
        vpmovmskb eax, ymm2
      }
      if ( !(_DWORD)_RAX )
      {
        __asm
        {
          vpcmpeqb ymm3, ymm0, ymm3
          vpmovmskb eax, ymm3
        }
        if ( !(_DWORD)_RAX )
        {
          __asm
          {
            vpcmpeqb ymm4, ymm0, ymm4
            vpmovmskb eax, ymm4
          }
          goto LABEL_21;
        }
LABEL_16:
        __asm { tzcnt   eax, eax }
        result = _RDI + _RAX + 64 - v4;
        __asm { vzeroupper }
        return result;
      }
LABEL_15:
      __asm { tzcnt   eax, eax }
      result = _RDI + _RAX + 32 - v4;
      __asm { vzeroupper }
      return result;
    }
LABEL_14:
    __asm { tzcnt   eax, eax }
    result = _RDI + _RAX - v4;
    __asm { vzeroupper }
    return result;
  }
LABEL_21:
  __asm { tzcnt   eax, eax }
  result = _RDI + _RAX + 96 - v4;
  __asm { vzeroupper }
  return result;
}
// 434AE4: variable '_RAX' is possibly undefined

//----- (0000000000434B70) ----------------------------------------------------
_BYTE *__fastcall _strcpy_sse2(_BYTE *a1, _BYTE *a2)
{
  _BYTE *v2; // rdx
  int v3; // ecx
  bool v4; // zf
  unsigned __int64 v5; // rax
  unsigned __int64 *v6; // rsi
  unsigned __int64 *v7; // rsi
  _QWORD *v8; // rsi
  _BYTE *v9; // rdx

  v2 = a1;
  if ( ((unsigned __int8)a2 & 7) != 0 )
  {
    v3 = 8 - ((unsigned __int8)a2 & 7);
    while ( 1 )
    {
      v4 = *a2 == 0;
      *v2 = *a2;
      if ( v4 )
        break;
      ++a2;
      ++v2;
      if ( !--v3 )
        goto LABEL_5;
    }
  }
  else
  {
LABEL_5:
    while ( 1 )
    {
      v5 = *(_QWORD *)a2;
      v6 = (unsigned __int64 *)(a2 + 8);
      if ( v5 < 0x101010101010101LL )
        break;
      if ( (v5 ^ (v5 - 0x101010101010101LL) | 0xFEFEFEFEFEFEFEFFLL) != -1LL )
        break;
      *(_QWORD *)v2 = v5;
      v2 += 8;
      v5 = *v6;
      v7 = v6 + 1;
      if ( v5 < 0x101010101010101LL )
        break;
      if ( (v5 ^ (v5 - 0x101010101010101LL) | 0xFEFEFEFEFEFEFEFFLL) != -1LL )
        break;
      *(_QWORD *)v2 = v5;
      v2 += 8;
      v5 = *v7;
      v8 = v7 + 1;
      if ( v5 < 0x101010101010101LL )
        break;
      if ( (v5 ^ (v5 - 0x101010101010101LL) | 0xFEFEFEFEFEFEFEFFLL) != -1LL )
        break;
      *(_QWORD *)v2 = v5;
      v2 += 8;
      v5 = *v8;
      a2 = v8 + 1;
      if ( v5 < 0x101010101010101LL || (v5 ^ (v5 - 0x101010101010101LL) | 0xFEFEFEFEFEFEFEFFLL) != -1LL )
        break;
      *(_QWORD *)v2 = v5;
      v2 += 8;
    }
    while ( 1 )
    {
      *v2 = v5;
      if ( !(_BYTE)v5 )
        break;
      v9 = v2 + 1;
      *v9 = BYTE1(v5);
      if ( !BYTE1(v5) )
        break;
      v2 = v9 + 1;
      v5 >>= 16;
    }
  }
  return a1;
}

//----- (0000000000434C60) ----------------------------------------------------
_BYTE *__fastcall _stpcpy_sse2(_BYTE *a1, _BYTE *a2)
{
  int v3; // ecx
  bool v4; // zf
  unsigned __int64 v5; // rax
  unsigned __int64 *v6; // rsi
  unsigned __int64 *v7; // rsi
  _QWORD *v8; // rsi

  if ( ((unsigned __int8)a2 & 7) != 0 )
  {
    v3 = 8 - ((unsigned __int8)a2 & 7);
    while ( 1 )
    {
      v4 = *a2 == 0;
      *a1 = *a2;
      if ( v4 )
        break;
      ++a2;
      ++a1;
      if ( !--v3 )
        goto LABEL_5;
    }
  }
  else
  {
LABEL_5:
    while ( 1 )
    {
      v5 = *(_QWORD *)a2;
      v6 = (unsigned __int64 *)(a2 + 8);
      if ( v5 < 0x101010101010101LL )
        break;
      if ( (v5 ^ (v5 - 0x101010101010101LL) | 0xFEFEFEFEFEFEFEFFLL) != -1LL )
        break;
      *(_QWORD *)a1 = v5;
      a1 += 8;
      v5 = *v6;
      v7 = v6 + 1;
      if ( v5 < 0x101010101010101LL )
        break;
      if ( (v5 ^ (v5 - 0x101010101010101LL) | 0xFEFEFEFEFEFEFEFFLL) != -1LL )
        break;
      *(_QWORD *)a1 = v5;
      a1 += 8;
      v5 = *v7;
      v8 = v7 + 1;
      if ( v5 < 0x101010101010101LL )
        break;
      if ( (v5 ^ (v5 - 0x101010101010101LL) | 0xFEFEFEFEFEFEFEFFLL) != -1LL )
        break;
      *(_QWORD *)a1 = v5;
      a1 += 8;
      v5 = *v8;
      a2 = v8 + 1;
      if ( v5 < 0x101010101010101LL || (v5 ^ (v5 - 0x101010101010101LL) | 0xFEFEFEFEFEFEFEFFLL) != -1LL )
        break;
      *(_QWORD *)a1 = v5;
      a1 += 8;
    }
    while ( 1 )
    {
      *a1 = v5;
      if ( !(_BYTE)v5 )
        break;
      *++a1 = BYTE1(v5);
      if ( !BYTE1(v5) )
        break;
      ++a1;
      v5 >>= 16;
    }
  }
  return a1;
}

//----- (0000000000434D50) ----------------------------------------------------
_QWORD *__fastcall _strcpy_ssse3(_QWORD *a1, _BYTE *a2)
{
  unsigned __int64 v2; // rcx
  unsigned __int64 v3; // rdx
  __m128i *v4; // rsi
  __m128i v5; // xmm0
  int v6; // eax
  __int64 v7; // rsi
  unsigned __int64 v8; // rax
  __m128i v9; // xmm2
  __m128i v10; // xmm0
  __m128i v11; // xmm3
  __m128i v12; // xmm0
  __m128i v13; // xmm4
  __m128i v14; // xmm0
  __m128i v15; // xmm1
  __m128i v16; // xmm0
  __m128i v17; // xmm2
  __m128i v18; // xmm0
  __m128i v19; // xmm3
  __m128i v20; // xmm0
  unsigned __int64 v21; // rax
  __m128i v22; // xmm4
  __m128i v23; // xmm5
  __m128i v24; // xmm6
  __m128i v25; // xmm7
  int v26; // eax
  __m128i v27; // xmm0
  __m128i v28; // xmm0
  __m128i v29; // xmm0
  __m128i v30; // xmm1
  __m128i v31; // xmm2
  __m128i v32; // xmm0
  __m128i v33; // xmm3
  __m128i v34; // xmm2
  __m128i v35; // xmm0
  __m128i v36; // xmm1
  __m128i v37; // xmm2
  __m128i v38; // xmm0
  __m128i v39; // xmm3
  __m128i v40; // xmm2
  unsigned __int64 v41; // rax
  unsigned __int64 v42; // rcx
  unsigned __int64 v43; // rax
  __m128i v44; // xmm3
  __m128i v45; // xmm4
  __m128i v46; // xmm5
  int v47; // eax
  __m128i v48; // xmm7
  __m128i v49; // xmm5
  __m128i v50; // xmm4
  __m128i v51; // xmm3
  __m128i v52; // xmm2
  __m128i v53; // xmm1
  __m128i v54; // xmm2
  __m128i v55; // xmm0
  __m128i v56; // xmm3
  __m128i v57; // xmm2
  __m128i v58; // xmm0
  __m128i v59; // xmm1
  __m128i v60; // xmm2
  __m128i v61; // xmm0
  __m128i v62; // xmm3
  __m128i v63; // xmm2
  unsigned __int64 v64; // rax
  unsigned __int64 v65; // rcx
  unsigned __int64 v66; // rax
  __m128i v67; // xmm3
  __m128i v68; // xmm4
  __m128i v69; // xmm5
  int v70; // eax
  __m128i v71; // xmm7
  __m128i v72; // xmm5
  __m128i v73; // xmm4
  __m128i v74; // xmm3
  __m128i v75; // xmm2
  __m128i v76; // xmm1
  __m128i v77; // xmm2
  __m128i v78; // xmm0
  __m128i v79; // xmm3
  __m128i v80; // xmm2
  __m128i v81; // xmm0
  __m128i v82; // xmm1
  __m128i v83; // xmm2
  __m128i v84; // xmm0
  __m128i v85; // xmm3
  __m128i v86; // xmm2
  unsigned __int64 v87; // rax
  unsigned __int64 v88; // rcx
  unsigned __int64 v89; // rax
  __m128i v90; // xmm3
  __m128i v91; // xmm4
  __m128i v92; // xmm5
  int v93; // eax
  __m128i v94; // xmm7
  __m128i v95; // xmm5
  __m128i v96; // xmm4
  __m128i v97; // xmm3
  __m128i v98; // xmm2
  __m128i v99; // xmm1
  __m128i v100; // xmm2
  __m128i v101; // xmm0
  __m128i v102; // xmm3
  __m128i v103; // xmm2
  __m128i v104; // xmm0
  __m128i v105; // xmm1
  __m128i v106; // xmm2
  __m128i v107; // xmm0
  __m128i v108; // xmm3
  __m128i v109; // xmm2
  unsigned __int64 v110; // rax
  unsigned __int64 v111; // rcx
  unsigned __int64 v112; // rax
  __m128i v113; // xmm3
  __m128i v114; // xmm4
  __m128i v115; // xmm5
  int v116; // eax
  __m128i v117; // xmm7
  __m128i v118; // xmm5
  __m128i v119; // xmm4
  __m128i v120; // xmm3
  __m128i v121; // xmm2
  __m128i v122; // xmm1
  __m128i v123; // xmm2
  __m128i v124; // xmm0
  __m128i v125; // xmm3
  __m128i v126; // xmm2
  __m128i v127; // xmm0
  __m128i v128; // xmm1
  __m128i v129; // xmm2
  __m128i v130; // xmm0
  __m128i v131; // xmm3
  __m128i v132; // xmm2
  unsigned __int64 v133; // rax
  unsigned __int64 v134; // rcx
  unsigned __int64 v135; // rax
  __m128i v136; // xmm3
  __m128i v137; // xmm4
  __m128i v138; // xmm5
  int v139; // eax
  __m128i v140; // xmm7
  __m128i v141; // xmm5
  __m128i v142; // xmm4
  __m128i v143; // xmm3
  __m128i v144; // xmm2
  __m128i v145; // xmm1
  __m128i v146; // xmm2
  __m128i v147; // xmm0
  __m128i v148; // xmm3
  __m128i v149; // xmm2
  __m128i v150; // xmm0
  __m128i v151; // xmm1
  __m128i v152; // xmm2
  __m128i v153; // xmm0
  __m128i v154; // xmm3
  __m128i v155; // xmm2
  unsigned __int64 v156; // rax
  unsigned __int64 v157; // rcx
  unsigned __int64 v158; // rax
  __m128i v159; // xmm3
  __m128i v160; // xmm4
  __m128i v161; // xmm5
  int v162; // eax
  __m128i v163; // xmm7
  __m128i v164; // xmm5
  __m128i v165; // xmm4
  __m128i v166; // xmm3
  __m128i v167; // xmm2
  int v168; // esi
  __m128i v169; // xmm1
  __m128i v170; // xmm2
  __m128i v171; // xmm0
  __m128i v172; // xmm3
  __m128i v173; // xmm2
  __m128i v174; // xmm0
  __m128i v175; // xmm1
  __m128i v176; // xmm2
  __m128i v177; // xmm0
  __m128i v178; // xmm3
  __m128i v179; // xmm2
  unsigned __int64 v180; // rax
  unsigned __int64 v181; // rcx
  unsigned __int64 v182; // rax
  __m128i v183; // xmm3
  __m128i v184; // xmm4
  __m128i v185; // xmm5
  int v186; // eax
  __m128i v187; // xmm7
  __m128i v188; // xmm5
  __m128i v189; // xmm4
  __m128i v190; // xmm3
  __m128i v191; // xmm2
  int v192; // esi
  __m128i v193; // xmm1
  __m128i v194; // xmm2
  __m128i v195; // xmm0
  __m128i v196; // xmm3
  __m128i v197; // xmm2
  __m128i v198; // xmm0
  __m128i v199; // xmm1
  __m128i v200; // xmm2
  __m128i v201; // xmm0
  __m128i v202; // xmm3
  __m128i v203; // xmm2
  unsigned __int64 v204; // rax
  unsigned __int64 v205; // rcx
  unsigned __int64 v206; // rax
  __m128i v207; // xmm3
  __m128i v208; // xmm4
  __m128i v209; // xmm5
  int v210; // eax
  __m128i v211; // xmm7
  __m128i v212; // xmm5
  __m128i v213; // xmm4
  __m128i v214; // xmm3
  __m128i v215; // xmm2
  __m128i v216; // xmm1
  __m128i v217; // xmm2
  __m128i v218; // xmm0
  __m128i v219; // xmm3
  __m128i v220; // xmm2
  __m128i v221; // xmm0
  __m128i v222; // xmm1
  __m128i v223; // xmm2
  __m128i v224; // xmm0
  __m128i v225; // xmm3
  __m128i v226; // xmm2
  unsigned __int64 v227; // rax
  unsigned __int64 v228; // rcx
  unsigned __int64 v229; // rax
  __m128i v230; // xmm3
  __m128i v231; // xmm4
  __m128i v232; // xmm5
  int v233; // eax
  __m128i v234; // xmm7
  __m128i v235; // xmm5
  __m128i v236; // xmm4
  __m128i v237; // xmm3
  __m128i v238; // xmm2
  __m128i v239; // xmm1
  __m128i v240; // xmm2
  __m128i v241; // xmm0
  __m128i v242; // xmm3
  __m128i v243; // xmm2
  __m128i v244; // xmm0
  __m128i v245; // xmm1
  __m128i v246; // xmm2
  __m128i v247; // xmm0
  __m128i v248; // xmm3
  __m128i v249; // xmm2
  unsigned __int64 v250; // rax
  unsigned __int64 v251; // rcx
  unsigned __int64 v252; // rax
  __m128i v253; // xmm3
  __m128i v254; // xmm4
  __m128i v255; // xmm5
  int v256; // eax
  __m128i v257; // xmm7
  __m128i v258; // xmm5
  __m128i v259; // xmm4
  __m128i v260; // xmm3
  __m128i v261; // xmm2
  __m128i v262; // xmm1
  __m128i v263; // xmm2
  __m128i v264; // xmm0
  __m128i v265; // xmm3
  __m128i v266; // xmm2
  __m128i v267; // xmm0
  __m128i v268; // xmm1
  __m128i v269; // xmm2
  __m128i v270; // xmm0
  __m128i v271; // xmm3
  __m128i v272; // xmm2
  unsigned __int64 v273; // rax
  unsigned __int64 v274; // rcx
  unsigned __int64 v275; // rax
  __m128i v276; // xmm3
  __m128i v277; // xmm4
  __m128i v278; // xmm5
  int v279; // eax
  __m128i v280; // xmm7
  __m128i v281; // xmm5
  __m128i v282; // xmm4
  __m128i v283; // xmm3
  __m128i v284; // xmm2
  __m128i v285; // xmm1
  __m128i v286; // xmm2
  __m128i v287; // xmm0
  __m128i v288; // xmm3
  __m128i v289; // xmm2
  __m128i v290; // xmm0
  __m128i v291; // xmm1
  __m128i v292; // xmm2
  __m128i v293; // xmm0
  __m128i v294; // xmm3
  __m128i v295; // xmm2
  unsigned __int64 v296; // rax
  unsigned __int64 v297; // rcx
  unsigned __int64 v298; // rax
  __m128i v299; // xmm3
  __m128i v300; // xmm4
  __m128i v301; // xmm5
  int v302; // eax
  __m128i v303; // xmm7
  __m128i v304; // xmm5
  __m128i v305; // xmm4
  __m128i v306; // xmm3
  __m128i v307; // xmm2
  __m128i v308; // xmm1
  __m128i v309; // xmm2
  __m128i v310; // xmm0
  __m128i v311; // xmm3
  __m128i v312; // xmm2
  __m128i v313; // xmm0
  __m128i v314; // xmm1
  __m128i v315; // xmm2
  __m128i v316; // xmm0
  __m128i v317; // xmm3
  __m128i v318; // xmm2
  unsigned __int64 v319; // rax
  unsigned __int64 v320; // rcx
  unsigned __int64 v321; // rax
  __m128i v322; // xmm3
  __m128i v323; // xmm4
  __m128i v324; // xmm5
  int v325; // eax
  __m128i v326; // xmm7
  __m128i v327; // xmm5
  __m128i v328; // xmm4
  __m128i v329; // xmm3
  __m128i v330; // xmm2
  __m128i v331; // xmm1
  __m128i v332; // xmm2
  __m128i v333; // xmm0
  __m128i v334; // xmm3
  __m128i v335; // xmm2
  __m128i v336; // xmm0
  __m128i v337; // xmm1
  __m128i v338; // xmm2
  __m128i v339; // xmm0
  __m128i v340; // xmm3
  __m128i v341; // xmm2
  unsigned __int64 v342; // rax
  unsigned __int64 v343; // rcx
  unsigned __int64 v344; // rax
  __m128i v345; // xmm3
  __m128i v346; // xmm4
  __m128i v347; // xmm5
  int v348; // eax
  __m128i v349; // xmm7
  __m128i v350; // xmm5
  __m128i v351; // xmm4
  __m128i v352; // xmm3
  __m128i v353; // xmm2
  __m128i v354; // xmm1
  __m128i v355; // xmm2
  __m128i v356; // xmm0
  __m128i v357; // xmm3
  __m128i v358; // xmm2
  __m128i v359; // xmm0
  __m128i v360; // xmm1
  __m128i v361; // xmm2
  __m128i v362; // xmm0
  __m128i v363; // xmm3
  __m128i v364; // xmm2
  unsigned __int64 v365; // rax
  unsigned __int64 v366; // rcx
  unsigned __int64 v367; // rax
  __m128i v368; // xmm3
  __m128i v369; // xmm4
  __m128i v370; // xmm5
  int v371; // eax
  __m128i v372; // xmm7
  __m128i v373; // xmm5
  __m128i v374; // xmm4
  __m128i v375; // xmm3
  __m128i v376; // xmm2

  v2 = (unsigned __int64)a2;
  v3 = (unsigned __int64)a1;
  if ( !*a2 )
    goto LABEL_198;
  if ( !a2[1] )
    goto LABEL_199;
  if ( !a2[2] )
    goto LABEL_200;
  if ( !a2[3] )
    goto LABEL_201;
  if ( !a2[4] )
    goto LABEL_202;
  if ( !a2[5] )
    goto LABEL_203;
  if ( !a2[6] )
  {
LABEL_204:
    *(_DWORD *)v3 = *(_DWORD *)v2;
    *(_DWORD *)(v3 + 3) = *(_DWORD *)(v2 + 3);
    return a1;
  }
  if ( !a2[7] )
  {
LABEL_189:
    *(_QWORD *)v3 = *(_QWORD *)v2;
    return a1;
  }
  if ( !a2[8] )
    goto LABEL_205;
  if ( !a2[9] )
    goto LABEL_206;
  if ( !a2[10] )
    goto LABEL_207;
  if ( !a2[11] )
    goto LABEL_208;
  if ( !a2[12] )
    goto LABEL_209;
  if ( !a2[13] )
    goto LABEL_210;
  if ( a2[14] )
  {
    if ( !a2[15] )
    {
LABEL_197:
      *(_QWORD *)v3 = *(_QWORD *)v2;
      *(_QWORD *)(v3 + 8) = *(_QWORD *)(v2 + 8);
      return a1;
    }
    v4 = (__m128i *)((unsigned __int64)(a2 + 16) & 0xFFFFFFFFFFFFFFF0LL);
    *a1 = *(_QWORD *)v2;
    v5 = _mm_cmpeq_epi8((__m128i)0LL, *v4);
    a1[1] = *(_QWORD *)(v2 + 8);
    v6 = _mm_movemask_epi8(v5);
    v7 = (__int64)v4->m128i_i64 - v2;
    if ( !v6 )
    {
      v3 = (unsigned __int64)(a1 + 2) & 0xFFFFFFFFFFFFFFF0LL;
      v2 -= (unsigned __int64)a1 - v3;
      v8 = v2 & 0xF;
      if ( (v2 & 0xF) != 0 )
      {
        if ( v8 >= 8 )
        {
          switch ( v8 )
          {
            case 8uLL:
              v193 = *(__m128i *)(v2 - 8);
              v194 = *(__m128i *)(v2 + 8);
              while ( 1 )
              {
                v195 = _mm_cmpeq_epi8(v5, v194);
                v6 = _mm_movemask_epi8(v195);
                v196 = v194;
                if ( v6 )
                  break;
                *(__m128i *)v3 = _mm_alignr_epi8(v194, v193, 8);
                v197 = *(__m128i *)(v2 + 24);
                v198 = _mm_cmpeq_epi8(v195, v197);
                v3 += 16LL;
                v6 = _mm_movemask_epi8(v198);
                v2 += 16LL;
                v199 = v197;
                if ( v6 )
                  break;
                *(__m128i *)v3 = _mm_alignr_epi8(v197, v196, 8);
                v200 = *(__m128i *)(v2 + 24);
                v201 = _mm_cmpeq_epi8(v198, v200);
                v3 += 16LL;
                v6 = _mm_movemask_epi8(v201);
                v2 += 16LL;
                v202 = v200;
                if ( v6 )
                  break;
                *(__m128i *)v3 = _mm_alignr_epi8(v200, v199, 8);
                v203 = *(__m128i *)(v2 + 24);
                v5 = _mm_cmpeq_epi8(v201, v203);
                v3 += 16LL;
                v6 = _mm_movemask_epi8(v5);
                v2 += 16LL;
                if ( v6 )
                  break;
                *(__m128i *)v3 = _mm_alignr_epi8(v203, v202, 8);
                v204 = v2 + 24;
                v205 = (v2 + 24) & 0xFFFFFFFFFFFFFFC0LL;
                v206 = v204 - v205;
                v2 = v205 - 8;
                v3 = v3 + 16 - v206;
                v193 = *(__m128i *)(v2 - 8);
                while ( 1 )
                {
                  v194 = *(__m128i *)(v2 + 8);
                  v207 = *(__m128i *)(v2 + 24);
                  v208 = *(__m128i *)(v2 + 40);
                  v209 = *(__m128i *)(v2 + 56);
                  v210 = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_min_epu8(_mm_min_epu8(v208, v209), _mm_min_epu8(v207, v194)), v5));
                  v211 = v209;
                  v212 = _mm_alignr_epi8(v209, v208, 8);
                  v213 = _mm_alignr_epi8(v208, v207, 8);
                  if ( v210 )
                    break;
                  v214 = _mm_alignr_epi8(v207, v194, 8);
                  v2 += 64LL;
                  v215 = _mm_alignr_epi8(v194, v193, 8);
                  v193 = v211;
                  *(__m128i *)(v3 + 48) = v212;
                  *(__m128i *)(v3 + 32) = v213;
                  *(__m128i *)(v3 + 16) = v214;
                  *(__m128i *)v3 = v215;
                  v3 += 64LL;
                }
              }
              v7 = 8LL;
              *(_QWORD *)v3 = *(_QWORD *)v2;
              break;
            case 9uLL:
              v216 = *(__m128i *)(v2 - 9);
              v217 = *(__m128i *)(v2 + 7);
              while ( 1 )
              {
                v218 = _mm_cmpeq_epi8(v5, v217);
                v6 = _mm_movemask_epi8(v218);
                v219 = v217;
                if ( v6 )
                  break;
                *(__m128i *)v3 = _mm_alignr_epi8(v217, v216, 9);
                v220 = *(__m128i *)(v2 + 23);
                v221 = _mm_cmpeq_epi8(v218, v220);
                v3 += 16LL;
                v6 = _mm_movemask_epi8(v221);
                v2 += 16LL;
                v222 = v220;
                if ( v6 )
                  break;
                *(__m128i *)v3 = _mm_alignr_epi8(v220, v219, 9);
                v223 = *(__m128i *)(v2 + 23);
                v224 = _mm_cmpeq_epi8(v221, v223);
                v3 += 16LL;
                v6 = _mm_movemask_epi8(v224);
                v2 += 16LL;
                v225 = v223;
                if ( v6 )
                  break;
                *(__m128i *)v3 = _mm_alignr_epi8(v223, v222, 9);
                v226 = *(__m128i *)(v2 + 23);
                v5 = _mm_cmpeq_epi8(v224, v226);
                v3 += 16LL;
                v6 = _mm_movemask_epi8(v5);
                v2 += 16LL;
                if ( v6 )
                  break;
                *(__m128i *)v3 = _mm_alignr_epi8(v226, v225, 9);
                v227 = v2 + 23;
                v228 = (v2 + 23) & 0xFFFFFFFFFFFFFFC0LL;
                v229 = v227 - v228;
                v2 = v228 - 7;
                v3 = v3 + 16 - v229;
                v216 = *(__m128i *)(v2 - 9);
                while ( 1 )
                {
                  v217 = *(__m128i *)(v2 + 7);
                  v230 = *(__m128i *)(v2 + 23);
                  v231 = *(__m128i *)(v2 + 39);
                  v232 = *(__m128i *)(v2 + 55);
                  v233 = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_min_epu8(_mm_min_epu8(v231, v232), _mm_min_epu8(v230, v217)), v5));
                  v234 = v232;
                  v235 = _mm_alignr_epi8(v232, v231, 9);
                  v236 = _mm_alignr_epi8(v231, v230, 9);
                  if ( v233 )
                    break;
                  v237 = _mm_alignr_epi8(v230, v217, 9);
                  v2 += 64LL;
                  v238 = _mm_alignr_epi8(v217, v216, 9);
                  v216 = v234;
                  *(__m128i *)(v3 + 48) = v235;
                  *(__m128i *)(v3 + 32) = v236;
                  *(__m128i *)(v3 + 16) = v237;
                  *(__m128i *)v3 = v238;
                  v3 += 64LL;
                }
              }
              v7 = 7LL;
              *(_QWORD *)(v3 - 1) = *(_QWORD *)(v2 - 1);
              break;
            case 0xAuLL:
              v239 = *(__m128i *)(v2 - 10);
              v240 = *(__m128i *)(v2 + 6);
              while ( 1 )
              {
                v241 = _mm_cmpeq_epi8(v5, v240);
                v6 = _mm_movemask_epi8(v241);
                v242 = v240;
                if ( v6 )
                  break;
                *(__m128i *)v3 = _mm_alignr_epi8(v240, v239, 10);
                v243 = *(__m128i *)(v2 + 22);
                v244 = _mm_cmpeq_epi8(v241, v243);
                v3 += 16LL;
                v6 = _mm_movemask_epi8(v244);
                v2 += 16LL;
                v245 = v243;
                if ( v6 )
                  break;
                *(__m128i *)v3 = _mm_alignr_epi8(v243, v242, 10);
                v246 = *(__m128i *)(v2 + 22);
                v247 = _mm_cmpeq_epi8(v244, v246);
                v3 += 16LL;
                v6 = _mm_movemask_epi8(v247);
                v2 += 16LL;
                v248 = v246;
                if ( v6 )
                  break;
                *(__m128i *)v3 = _mm_alignr_epi8(v246, v245, 10);
                v249 = *(__m128i *)(v2 + 22);
                v5 = _mm_cmpeq_epi8(v247, v249);
                v3 += 16LL;
                v6 = _mm_movemask_epi8(v5);
                v2 += 16LL;
                if ( v6 )
                  break;
                *(__m128i *)v3 = _mm_alignr_epi8(v249, v248, 10);
                v250 = v2 + 22;
                v251 = (v2 + 22) & 0xFFFFFFFFFFFFFFC0LL;
                v252 = v250 - v251;
                v2 = v251 - 6;
                v3 = v3 + 16 - v252;
                v239 = *(__m128i *)(v2 - 10);
                while ( 1 )
                {
                  v240 = *(__m128i *)(v2 + 6);
                  v253 = *(__m128i *)(v2 + 22);
                  v254 = *(__m128i *)(v2 + 38);
                  v255 = *(__m128i *)(v2 + 54);
                  v256 = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_min_epu8(_mm_min_epu8(v254, v255), _mm_min_epu8(v253, v240)), v5));
                  v257 = v255;
                  v258 = _mm_alignr_epi8(v255, v254, 10);
                  v259 = _mm_alignr_epi8(v254, v253, 10);
                  if ( v256 )
                    break;
                  v260 = _mm_alignr_epi8(v253, v240, 10);
                  v2 += 64LL;
                  v261 = _mm_alignr_epi8(v240, v239, 10);
                  v239 = v257;
                  *(__m128i *)(v3 + 48) = v258;
                  *(__m128i *)(v3 + 32) = v259;
                  *(__m128i *)(v3 + 16) = v260;
                  *(__m128i *)v3 = v261;
                  v3 += 64LL;
                }
              }
              v7 = 6LL;
              *(_QWORD *)(v3 - 2) = *(_QWORD *)(v2 - 2);
              break;
            case 0xBuLL:
              v262 = *(__m128i *)(v2 - 11);
              v263 = *(__m128i *)(v2 + 5);
              while ( 1 )
              {
                v264 = _mm_cmpeq_epi8(v5, v263);
                v6 = _mm_movemask_epi8(v264);
                v265 = v263;
                if ( v6 )
                  break;
                *(__m128i *)v3 = _mm_alignr_epi8(v263, v262, 11);
                v266 = *(__m128i *)(v2 + 21);
                v267 = _mm_cmpeq_epi8(v264, v266);
                v3 += 16LL;
                v6 = _mm_movemask_epi8(v267);
                v2 += 16LL;
                v268 = v266;
                if ( v6 )
                  break;
                *(__m128i *)v3 = _mm_alignr_epi8(v266, v265, 11);
                v269 = *(__m128i *)(v2 + 21);
                v270 = _mm_cmpeq_epi8(v267, v269);
                v3 += 16LL;
                v6 = _mm_movemask_epi8(v270);
                v2 += 16LL;
                v271 = v269;
                if ( v6 )
                  break;
                *(__m128i *)v3 = _mm_alignr_epi8(v269, v268, 11);
                v272 = *(__m128i *)(v2 + 21);
                v5 = _mm_cmpeq_epi8(v270, v272);
                v3 += 16LL;
                v6 = _mm_movemask_epi8(v5);
                v2 += 16LL;
                if ( v6 )
                  break;
                *(__m128i *)v3 = _mm_alignr_epi8(v272, v271, 11);
                v273 = v2 + 21;
                v274 = (v2 + 21) & 0xFFFFFFFFFFFFFFC0LL;
                v275 = v273 - v274;
                v2 = v274 - 5;
                v3 = v3 + 16 - v275;
                v262 = *(__m128i *)(v2 - 11);
                while ( 1 )
                {
                  v263 = *(__m128i *)(v2 + 5);
                  v276 = *(__m128i *)(v2 + 21);
                  v277 = *(__m128i *)(v2 + 37);
                  v278 = *(__m128i *)(v2 + 53);
                  v279 = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_min_epu8(_mm_min_epu8(v277, v278), _mm_min_epu8(v276, v263)), v5));
                  v280 = v278;
                  v281 = _mm_alignr_epi8(v278, v277, 11);
                  v282 = _mm_alignr_epi8(v277, v276, 11);
                  if ( v279 )
                    break;
                  v283 = _mm_alignr_epi8(v276, v263, 11);
                  v2 += 64LL;
                  v284 = _mm_alignr_epi8(v263, v262, 11);
                  v262 = v280;
                  *(__m128i *)(v3 + 48) = v281;
                  *(__m128i *)(v3 + 32) = v282;
                  *(__m128i *)(v3 + 16) = v283;
                  *(__m128i *)v3 = v284;
                  v3 += 64LL;
                }
              }
              v7 = 5LL;
              *(_QWORD *)(v3 - 3) = *(_QWORD *)(v2 - 3);
              break;
            case 0xCuLL:
              v285 = *(__m128i *)(v2 - 12);
              v286 = *(__m128i *)(v2 + 4);
              while ( 1 )
              {
                v287 = _mm_cmpeq_epi8(v5, v286);
                v6 = _mm_movemask_epi8(v287);
                v288 = v286;
                if ( v6 )
                  break;
                *(__m128i *)v3 = _mm_alignr_epi8(v286, v285, 12);
                v289 = *(__m128i *)(v2 + 20);
                v290 = _mm_cmpeq_epi8(v287, v289);
                v3 += 16LL;
                v6 = _mm_movemask_epi8(v290);
                v2 += 16LL;
                v291 = v289;
                if ( v6 )
                  break;
                *(__m128i *)v3 = _mm_alignr_epi8(v289, v288, 12);
                v292 = *(__m128i *)(v2 + 20);
                v293 = _mm_cmpeq_epi8(v290, v292);
                v3 += 16LL;
                v6 = _mm_movemask_epi8(v293);
                v2 += 16LL;
                v294 = v292;
                if ( v6 )
                  break;
                *(__m128i *)v3 = _mm_alignr_epi8(v292, v291, 12);
                v295 = *(__m128i *)(v2 + 20);
                v5 = _mm_cmpeq_epi8(v293, v295);
                v3 += 16LL;
                v6 = _mm_movemask_epi8(v5);
                v2 += 16LL;
                if ( v6 )
                  break;
                *(__m128i *)v3 = _mm_alignr_epi8(v295, v294, 12);
                v296 = v2 + 20;
                v297 = (v2 + 20) & 0xFFFFFFFFFFFFFFC0LL;
                v298 = v296 - v297;
                v2 = v297 - 4;
                v3 = v3 + 16 - v298;
                v285 = *(__m128i *)(v2 - 12);
                while ( 1 )
                {
                  v286 = *(__m128i *)(v2 + 4);
                  v299 = *(__m128i *)(v2 + 20);
                  v300 = *(__m128i *)(v2 + 36);
                  v301 = *(__m128i *)(v2 + 52);
                  v302 = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_min_epu8(_mm_min_epu8(v300, v301), _mm_min_epu8(v299, v286)), v5));
                  v303 = v301;
                  v304 = _mm_alignr_epi8(v301, v300, 12);
                  v305 = _mm_alignr_epi8(v300, v299, 12);
                  if ( v302 )
                    break;
                  v306 = _mm_alignr_epi8(v299, v286, 12);
                  v2 += 64LL;
                  v307 = _mm_alignr_epi8(v286, v285, 12);
                  v285 = v303;
                  *(__m128i *)(v3 + 48) = v304;
                  *(__m128i *)(v3 + 32) = v305;
                  *(__m128i *)(v3 + 16) = v306;
                  *(__m128i *)v3 = v307;
                  v3 += 64LL;
                }
              }
              v7 = 4LL;
              *(_DWORD *)v3 = *(_DWORD *)v2;
              break;
            case 0xDuLL:
              v308 = *(__m128i *)(v2 - 13);
              v309 = *(__m128i *)(v2 + 3);
              while ( 1 )
              {
                v310 = _mm_cmpeq_epi8(v5, v309);
                v6 = _mm_movemask_epi8(v310);
                v311 = v309;
                if ( v6 )
                  break;
                *(__m128i *)v3 = _mm_alignr_epi8(v309, v308, 13);
                v312 = *(__m128i *)(v2 + 19);
                v313 = _mm_cmpeq_epi8(v310, v312);
                v3 += 16LL;
                v6 = _mm_movemask_epi8(v313);
                v2 += 16LL;
                v314 = v312;
                if ( v6 )
                  break;
                *(__m128i *)v3 = _mm_alignr_epi8(v312, v311, 13);
                v315 = *(__m128i *)(v2 + 19);
                v316 = _mm_cmpeq_epi8(v313, v315);
                v3 += 16LL;
                v6 = _mm_movemask_epi8(v316);
                v2 += 16LL;
                v317 = v315;
                if ( v6 )
                  break;
                *(__m128i *)v3 = _mm_alignr_epi8(v315, v314, 13);
                v318 = *(__m128i *)(v2 + 19);
                v5 = _mm_cmpeq_epi8(v316, v318);
                v3 += 16LL;
                v6 = _mm_movemask_epi8(v5);
                v2 += 16LL;
                if ( v6 )
                  break;
                *(__m128i *)v3 = _mm_alignr_epi8(v318, v317, 13);
                v319 = v2 + 19;
                v320 = (v2 + 19) & 0xFFFFFFFFFFFFFFC0LL;
                v321 = v319 - v320;
                v2 = v320 - 3;
                v3 = v3 + 16 - v321;
                v308 = *(__m128i *)(v2 - 13);
                while ( 1 )
                {
                  v309 = *(__m128i *)(v2 + 3);
                  v322 = *(__m128i *)(v2 + 19);
                  v323 = *(__m128i *)(v2 + 35);
                  v324 = *(__m128i *)(v2 + 51);
                  v325 = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_min_epu8(_mm_min_epu8(v323, v324), _mm_min_epu8(v322, v309)), v5));
                  v326 = v324;
                  v327 = _mm_alignr_epi8(v324, v323, 13);
                  v328 = _mm_alignr_epi8(v323, v322, 13);
                  if ( v325 )
                    break;
                  v329 = _mm_alignr_epi8(v322, v309, 13);
                  v2 += 64LL;
                  v330 = _mm_alignr_epi8(v309, v308, 13);
                  v308 = v326;
                  *(__m128i *)(v3 + 48) = v327;
                  *(__m128i *)(v3 + 32) = v328;
                  *(__m128i *)(v3 + 16) = v329;
                  *(__m128i *)v3 = v330;
                  v3 += 64LL;
                }
              }
              v7 = 3LL;
              *(_DWORD *)(v3 - 1) = *(_DWORD *)(v2 - 1);
              break;
            case 0xEuLL:
              v331 = *(__m128i *)(v2 - 14);
              v332 = *(__m128i *)(v2 + 2);
              while ( 1 )
              {
                v333 = _mm_cmpeq_epi8(v5, v332);
                v6 = _mm_movemask_epi8(v333);
                v334 = v332;
                if ( v6 )
                  break;
                *(__m128i *)v3 = _mm_alignr_epi8(v332, v331, 14);
                v335 = *(__m128i *)(v2 + 18);
                v336 = _mm_cmpeq_epi8(v333, v335);
                v3 += 16LL;
                v6 = _mm_movemask_epi8(v336);
                v2 += 16LL;
                v337 = v335;
                if ( v6 )
                  break;
                *(__m128i *)v3 = _mm_alignr_epi8(v335, v334, 14);
                v338 = *(__m128i *)(v2 + 18);
                v339 = _mm_cmpeq_epi8(v336, v338);
                v3 += 16LL;
                v6 = _mm_movemask_epi8(v339);
                v2 += 16LL;
                v340 = v338;
                if ( v6 )
                  break;
                *(__m128i *)v3 = _mm_alignr_epi8(v338, v337, 14);
                v341 = *(__m128i *)(v2 + 18);
                v5 = _mm_cmpeq_epi8(v339, v341);
                v3 += 16LL;
                v6 = _mm_movemask_epi8(v5);
                v2 += 16LL;
                if ( v6 )
                  break;
                *(__m128i *)v3 = _mm_alignr_epi8(v341, v340, 14);
                v342 = v2 + 18;
                v343 = (v2 + 18) & 0xFFFFFFFFFFFFFFC0LL;
                v344 = v342 - v343;
                v2 = v343 - 2;
                v3 = v3 + 16 - v344;
                v331 = *(__m128i *)(v2 - 14);
                while ( 1 )
                {
                  v332 = *(__m128i *)(v2 + 2);
                  v345 = *(__m128i *)(v2 + 18);
                  v346 = *(__m128i *)(v2 + 34);
                  v347 = *(__m128i *)(v2 + 50);
                  v348 = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_min_epu8(_mm_min_epu8(v346, v347), _mm_min_epu8(v345, v332)), v5));
                  v349 = v347;
                  v350 = _mm_alignr_epi8(v347, v346, 14);
                  v351 = _mm_alignr_epi8(v346, v345, 14);
                  if ( v348 )
                    break;
                  v352 = _mm_alignr_epi8(v345, v332, 14);
                  v2 += 64LL;
                  v353 = _mm_alignr_epi8(v332, v331, 14);
                  v331 = v349;
                  *(__m128i *)(v3 + 48) = v350;
                  *(__m128i *)(v3 + 32) = v351;
                  *(__m128i *)(v3 + 16) = v352;
                  *(__m128i *)v3 = v353;
                  v3 += 64LL;
                }
              }
              v7 = 2LL;
              *(_DWORD *)(v3 - 2) = *(_DWORD *)(v2 - 2);
              break;
            default:
              v354 = *(__m128i *)(v2 - 15);
              v355 = *(__m128i *)(v2 + 1);
              while ( 1 )
              {
                v356 = _mm_cmpeq_epi8(v5, v355);
                v6 = _mm_movemask_epi8(v356);
                v357 = v355;
                if ( v6 )
                  break;
                *(__m128i *)v3 = _mm_alignr_epi8(v355, v354, 15);
                v358 = *(__m128i *)(v2 + 17);
                v359 = _mm_cmpeq_epi8(v356, v358);
                v3 += 16LL;
                v6 = _mm_movemask_epi8(v359);
                v2 += 16LL;
                v360 = v358;
                if ( v6 )
                  break;
                *(__m128i *)v3 = _mm_alignr_epi8(v358, v357, 15);
                v361 = *(__m128i *)(v2 + 17);
                v362 = _mm_cmpeq_epi8(v359, v361);
                v3 += 16LL;
                v6 = _mm_movemask_epi8(v362);
                v2 += 16LL;
                v363 = v361;
                if ( v6 )
                  break;
                *(__m128i *)v3 = _mm_alignr_epi8(v361, v360, 15);
                v364 = *(__m128i *)(v2 + 17);
                v5 = _mm_cmpeq_epi8(v362, v364);
                v3 += 16LL;
                v6 = _mm_movemask_epi8(v5);
                v2 += 16LL;
                if ( v6 )
                  break;
                *(__m128i *)v3 = _mm_alignr_epi8(v364, v363, 15);
                v365 = v2 + 17;
                v366 = (v2 + 17) & 0xFFFFFFFFFFFFFFC0LL;
                v367 = v365 - v366;
                v2 = v366 - 1;
                v3 = v3 + 16 - v367;
                v354 = *(__m128i *)(v2 - 15);
                while ( 1 )
                {
                  v355 = *(__m128i *)(v2 + 1);
                  v368 = *(__m128i *)(v2 + 17);
                  v369 = *(__m128i *)(v2 + 33);
                  v370 = *(__m128i *)(v2 + 49);
                  v371 = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_min_epu8(_mm_min_epu8(v369, v370), _mm_min_epu8(v368, v355)), v5));
                  v372 = v370;
                  v373 = _mm_alignr_epi8(v370, v369, 15);
                  v374 = _mm_alignr_epi8(v369, v368, 15);
                  if ( v371 )
                    break;
                  v375 = _mm_alignr_epi8(v368, v355, 15);
                  v2 += 64LL;
                  v376 = _mm_alignr_epi8(v355, v354, 15);
                  v354 = v372;
                  *(__m128i *)(v3 + 48) = v373;
                  *(__m128i *)(v3 + 32) = v374;
                  *(__m128i *)(v3 + 16) = v375;
                  *(__m128i *)v3 = v376;
                  v3 += 64LL;
                }
              }
              v7 = 1LL;
              *(_DWORD *)(v3 - 3) = *(_DWORD *)(v2 - 3);
              break;
          }
        }
        else
        {
          switch ( v8 )
          {
            case 1uLL:
              v30 = *(__m128i *)(v2 - 1);
              v31 = *(__m128i *)(v2 + 15);
              while ( 1 )
              {
                v32 = _mm_cmpeq_epi8(v5, v31);
                v6 = _mm_movemask_epi8(v32);
                v33 = v31;
                if ( v6 )
                  break;
                *(__m128i *)v3 = _mm_alignr_epi8(v31, v30, 1);
                v34 = *(__m128i *)(v2 + 31);
                v35 = _mm_cmpeq_epi8(v32, v34);
                v3 += 16LL;
                v6 = _mm_movemask_epi8(v35);
                v2 += 16LL;
                v36 = v34;
                if ( v6 )
                  break;
                *(__m128i *)v3 = _mm_alignr_epi8(v34, v33, 1);
                v37 = *(__m128i *)(v2 + 31);
                v38 = _mm_cmpeq_epi8(v35, v37);
                v3 += 16LL;
                v6 = _mm_movemask_epi8(v38);
                v2 += 16LL;
                v39 = v37;
                if ( v6 )
                  break;
                *(__m128i *)v3 = _mm_alignr_epi8(v37, v36, 1);
                v40 = *(__m128i *)(v2 + 31);
                v5 = _mm_cmpeq_epi8(v38, v40);
                v3 += 16LL;
                v6 = _mm_movemask_epi8(v5);
                v2 += 16LL;
                if ( v6 )
                  break;
                *(__m128i *)v3 = _mm_alignr_epi8(v40, v39, 1);
                v41 = v2 + 31;
                v42 = (v2 + 31) & 0xFFFFFFFFFFFFFFC0LL;
                v43 = v41 - v42;
                v2 = v42 - 15;
                v3 = v3 + 16 - v43;
                v30 = *(__m128i *)(v2 - 1);
                while ( 1 )
                {
                  v31 = *(__m128i *)(v2 + 15);
                  v44 = *(__m128i *)(v2 + 31);
                  v45 = *(__m128i *)(v2 + 47);
                  v46 = *(__m128i *)(v2 + 63);
                  v47 = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_min_epu8(_mm_min_epu8(v45, v46), _mm_min_epu8(v44, v31)), v5));
                  v48 = v46;
                  v49 = _mm_alignr_epi8(v46, v45, 1);
                  v50 = _mm_alignr_epi8(v45, v44, 1);
                  if ( v47 )
                    break;
                  v51 = _mm_alignr_epi8(v44, v31, 1);
                  v2 += 64LL;
                  v52 = _mm_alignr_epi8(v31, v30, 1);
                  v30 = v48;
                  *(__m128i *)(v3 + 48) = v49;
                  *(__m128i *)(v3 + 32) = v50;
                  *(__m128i *)(v3 + 16) = v51;
                  *(__m128i *)v3 = v52;
                  v3 += 64LL;
                }
              }
              v7 = 15LL;
              *(__m128i *)(v3 - 1) = _mm_loadu_si128((const __m128i *)(v2 - 1));
              break;
            case 2uLL:
              v53 = *(__m128i *)(v2 - 2);
              v54 = *(__m128i *)(v2 + 14);
              while ( 1 )
              {
                v55 = _mm_cmpeq_epi8(v5, v54);
                v6 = _mm_movemask_epi8(v55);
                v56 = v54;
                if ( v6 )
                  break;
                *(__m128i *)v3 = _mm_alignr_epi8(v54, v53, 2);
                v57 = *(__m128i *)(v2 + 30);
                v58 = _mm_cmpeq_epi8(v55, v57);
                v3 += 16LL;
                v6 = _mm_movemask_epi8(v58);
                v2 += 16LL;
                v59 = v57;
                if ( v6 )
                  break;
                *(__m128i *)v3 = _mm_alignr_epi8(v57, v56, 2);
                v60 = *(__m128i *)(v2 + 30);
                v61 = _mm_cmpeq_epi8(v58, v60);
                v3 += 16LL;
                v6 = _mm_movemask_epi8(v61);
                v2 += 16LL;
                v62 = v60;
                if ( v6 )
                  break;
                *(__m128i *)v3 = _mm_alignr_epi8(v60, v59, 2);
                v63 = *(__m128i *)(v2 + 30);
                v5 = _mm_cmpeq_epi8(v61, v63);
                v3 += 16LL;
                v6 = _mm_movemask_epi8(v5);
                v2 += 16LL;
                if ( v6 )
                  break;
                *(__m128i *)v3 = _mm_alignr_epi8(v63, v62, 2);
                v64 = v2 + 30;
                v65 = (v2 + 30) & 0xFFFFFFFFFFFFFFC0LL;
                v66 = v64 - v65;
                v2 = v65 - 14;
                v3 = v3 + 16 - v66;
                v53 = *(__m128i *)(v2 - 2);
                while ( 1 )
                {
                  v54 = *(__m128i *)(v2 + 14);
                  v67 = *(__m128i *)(v2 + 30);
                  v68 = *(__m128i *)(v2 + 46);
                  v69 = *(__m128i *)(v2 + 62);
                  v70 = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_min_epu8(_mm_min_epu8(v68, v69), _mm_min_epu8(v67, v54)), v5));
                  v71 = v69;
                  v72 = _mm_alignr_epi8(v69, v68, 2);
                  v73 = _mm_alignr_epi8(v68, v67, 2);
                  if ( v70 )
                    break;
                  v74 = _mm_alignr_epi8(v67, v54, 2);
                  v2 += 64LL;
                  v75 = _mm_alignr_epi8(v54, v53, 2);
                  v53 = v71;
                  *(__m128i *)(v3 + 48) = v72;
                  *(__m128i *)(v3 + 32) = v73;
                  *(__m128i *)(v3 + 16) = v74;
                  *(__m128i *)v3 = v75;
                  v3 += 64LL;
                }
              }
              v7 = 14LL;
              *(__m128i *)(v3 - 2) = _mm_loadu_si128((const __m128i *)(v2 - 2));
              break;
            case 3uLL:
              v76 = *(__m128i *)(v2 - 3);
              v77 = *(__m128i *)(v2 + 13);
              while ( 1 )
              {
                v78 = _mm_cmpeq_epi8(v5, v77);
                v6 = _mm_movemask_epi8(v78);
                v79 = v77;
                if ( v6 )
                  break;
                *(__m128i *)v3 = _mm_alignr_epi8(v77, v76, 3);
                v80 = *(__m128i *)(v2 + 29);
                v81 = _mm_cmpeq_epi8(v78, v80);
                v3 += 16LL;
                v6 = _mm_movemask_epi8(v81);
                v2 += 16LL;
                v82 = v80;
                if ( v6 )
                  break;
                *(__m128i *)v3 = _mm_alignr_epi8(v80, v79, 3);
                v83 = *(__m128i *)(v2 + 29);
                v84 = _mm_cmpeq_epi8(v81, v83);
                v3 += 16LL;
                v6 = _mm_movemask_epi8(v84);
                v2 += 16LL;
                v85 = v83;
                if ( v6 )
                  break;
                *(__m128i *)v3 = _mm_alignr_epi8(v83, v82, 3);
                v86 = *(__m128i *)(v2 + 29);
                v5 = _mm_cmpeq_epi8(v84, v86);
                v3 += 16LL;
                v6 = _mm_movemask_epi8(v5);
                v2 += 16LL;
                if ( v6 )
                  break;
                *(__m128i *)v3 = _mm_alignr_epi8(v86, v85, 3);
                v87 = v2 + 29;
                v88 = (v2 + 29) & 0xFFFFFFFFFFFFFFC0LL;
                v89 = v87 - v88;
                v2 = v88 - 13;
                v3 = v3 + 16 - v89;
                v76 = *(__m128i *)(v2 - 3);
                while ( 1 )
                {
                  v77 = *(__m128i *)(v2 + 13);
                  v90 = *(__m128i *)(v2 + 29);
                  v91 = *(__m128i *)(v2 + 45);
                  v92 = *(__m128i *)(v2 + 61);
                  v93 = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_min_epu8(_mm_min_epu8(v91, v92), _mm_min_epu8(v90, v77)), v5));
                  v94 = v92;
                  v95 = _mm_alignr_epi8(v92, v91, 3);
                  v96 = _mm_alignr_epi8(v91, v90, 3);
                  if ( v93 )
                    break;
                  v97 = _mm_alignr_epi8(v90, v77, 3);
                  v2 += 64LL;
                  v98 = _mm_alignr_epi8(v77, v76, 3);
                  v76 = v94;
                  *(__m128i *)(v3 + 48) = v95;
                  *(__m128i *)(v3 + 32) = v96;
                  *(__m128i *)(v3 + 16) = v97;
                  *(__m128i *)v3 = v98;
                  v3 += 64LL;
                }
              }
              v7 = 13LL;
              *(__m128i *)(v3 - 3) = _mm_loadu_si128((const __m128i *)(v2 - 3));
              break;
            case 4uLL:
              v99 = *(__m128i *)(v2 - 4);
              v100 = *(__m128i *)(v2 + 12);
              while ( 1 )
              {
                v101 = _mm_cmpeq_epi8(v5, v100);
                v6 = _mm_movemask_epi8(v101);
                v102 = v100;
                if ( v6 )
                  break;
                *(__m128i *)v3 = _mm_alignr_epi8(v100, v99, 4);
                v103 = *(__m128i *)(v2 + 28);
                v104 = _mm_cmpeq_epi8(v101, v103);
                v3 += 16LL;
                v6 = _mm_movemask_epi8(v104);
                v2 += 16LL;
                v105 = v103;
                if ( v6 )
                  break;
                *(__m128i *)v3 = _mm_alignr_epi8(v103, v102, 4);
                v106 = *(__m128i *)(v2 + 28);
                v107 = _mm_cmpeq_epi8(v104, v106);
                v3 += 16LL;
                v6 = _mm_movemask_epi8(v107);
                v2 += 16LL;
                v108 = v106;
                if ( v6 )
                  break;
                *(__m128i *)v3 = _mm_alignr_epi8(v106, v105, 4);
                v109 = *(__m128i *)(v2 + 28);
                v5 = _mm_cmpeq_epi8(v107, v109);
                v3 += 16LL;
                v6 = _mm_movemask_epi8(v5);
                v2 += 16LL;
                if ( v6 )
                  break;
                *(__m128i *)v3 = _mm_alignr_epi8(v109, v108, 4);
                v110 = v2 + 28;
                v111 = (v2 + 28) & 0xFFFFFFFFFFFFFFC0LL;
                v112 = v110 - v111;
                v2 = v111 - 12;
                v3 = v3 + 16 - v112;
                v99 = *(__m128i *)(v2 - 4);
                while ( 1 )
                {
                  v100 = *(__m128i *)(v2 + 12);
                  v113 = *(__m128i *)(v2 + 28);
                  v114 = *(__m128i *)(v2 + 44);
                  v115 = *(__m128i *)(v2 + 60);
                  v116 = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_min_epu8(_mm_min_epu8(v114, v115), _mm_min_epu8(v113, v100)), v5));
                  v117 = v115;
                  v118 = _mm_alignr_epi8(v115, v114, 4);
                  v119 = _mm_alignr_epi8(v114, v113, 4);
                  if ( v116 )
                    break;
                  v120 = _mm_alignr_epi8(v113, v100, 4);
                  v2 += 64LL;
                  v121 = _mm_alignr_epi8(v100, v99, 4);
                  v99 = v117;
                  *(__m128i *)(v3 + 48) = v118;
                  *(__m128i *)(v3 + 32) = v119;
                  *(__m128i *)(v3 + 16) = v120;
                  *(__m128i *)v3 = v121;
                  v3 += 64LL;
                }
              }
              v7 = 12LL;
              *(__m128i *)(v3 - 4) = _mm_loadu_si128((const __m128i *)(v2 - 4));
              break;
            case 5uLL:
              v122 = *(__m128i *)(v2 - 5);
              v123 = *(__m128i *)(v2 + 11);
              while ( 1 )
              {
                v124 = _mm_cmpeq_epi8(v5, v123);
                v6 = _mm_movemask_epi8(v124);
                v125 = v123;
                if ( v6 )
                  break;
                *(__m128i *)v3 = _mm_alignr_epi8(v123, v122, 5);
                v126 = *(__m128i *)(v2 + 27);
                v127 = _mm_cmpeq_epi8(v124, v126);
                v3 += 16LL;
                v6 = _mm_movemask_epi8(v127);
                v2 += 16LL;
                v128 = v126;
                if ( v6 )
                  break;
                *(__m128i *)v3 = _mm_alignr_epi8(v126, v125, 5);
                v129 = *(__m128i *)(v2 + 27);
                v130 = _mm_cmpeq_epi8(v127, v129);
                v3 += 16LL;
                v6 = _mm_movemask_epi8(v130);
                v2 += 16LL;
                v131 = v129;
                if ( v6 )
                  break;
                *(__m128i *)v3 = _mm_alignr_epi8(v129, v128, 5);
                v132 = *(__m128i *)(v2 + 27);
                v5 = _mm_cmpeq_epi8(v130, v132);
                v3 += 16LL;
                v6 = _mm_movemask_epi8(v5);
                v2 += 16LL;
                if ( v6 )
                  break;
                *(__m128i *)v3 = _mm_alignr_epi8(v132, v131, 5);
                v133 = v2 + 27;
                v134 = (v2 + 27) & 0xFFFFFFFFFFFFFFC0LL;
                v135 = v133 - v134;
                v2 = v134 - 11;
                v3 = v3 + 16 - v135;
                v122 = *(__m128i *)(v2 - 5);
                while ( 1 )
                {
                  v123 = *(__m128i *)(v2 + 11);
                  v136 = *(__m128i *)(v2 + 27);
                  v137 = *(__m128i *)(v2 + 43);
                  v138 = *(__m128i *)(v2 + 59);
                  v139 = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_min_epu8(_mm_min_epu8(v137, v138), _mm_min_epu8(v136, v123)), v5));
                  v140 = v138;
                  v141 = _mm_alignr_epi8(v138, v137, 5);
                  v142 = _mm_alignr_epi8(v137, v136, 5);
                  if ( v139 )
                    break;
                  v143 = _mm_alignr_epi8(v136, v123, 5);
                  v2 += 64LL;
                  v144 = _mm_alignr_epi8(v123, v122, 5);
                  v122 = v140;
                  *(__m128i *)(v3 + 48) = v141;
                  *(__m128i *)(v3 + 32) = v142;
                  *(__m128i *)(v3 + 16) = v143;
                  *(__m128i *)v3 = v144;
                  v3 += 64LL;
                }
              }
              v7 = 11LL;
              *(__m128i *)(v3 - 5) = _mm_loadu_si128((const __m128i *)(v2 - 5));
              break;
            case 6uLL:
              v145 = *(__m128i *)(v2 - 6);
              v146 = *(__m128i *)(v2 + 10);
              while ( 1 )
              {
                v147 = _mm_cmpeq_epi8(v5, v146);
                v6 = _mm_movemask_epi8(v147);
                v148 = v146;
                if ( v6 )
                  break;
                *(__m128i *)v3 = _mm_alignr_epi8(v146, v145, 6);
                v149 = *(__m128i *)(v2 + 26);
                v150 = _mm_cmpeq_epi8(v147, v149);
                v3 += 16LL;
                v6 = _mm_movemask_epi8(v150);
                v2 += 16LL;
                v151 = v149;
                if ( v6 )
                  break;
                *(__m128i *)v3 = _mm_alignr_epi8(v149, v148, 6);
                v152 = *(__m128i *)(v2 + 26);
                v153 = _mm_cmpeq_epi8(v150, v152);
                v3 += 16LL;
                v6 = _mm_movemask_epi8(v153);
                v2 += 16LL;
                v154 = v152;
                if ( v6 )
                  break;
                *(__m128i *)v3 = _mm_alignr_epi8(v152, v151, 6);
                v155 = *(__m128i *)(v2 + 26);
                v5 = _mm_cmpeq_epi8(v153, v155);
                v3 += 16LL;
                v6 = _mm_movemask_epi8(v5);
                v2 += 16LL;
                if ( v6 )
                  break;
                *(__m128i *)v3 = _mm_alignr_epi8(v155, v154, 6);
                v156 = v2 + 26;
                v157 = (v2 + 26) & 0xFFFFFFFFFFFFFFC0LL;
                v158 = v156 - v157;
                v2 = v157 - 10;
                v3 = v3 + 16 - v158;
                v145 = *(__m128i *)(v2 - 6);
                while ( 1 )
                {
                  v146 = *(__m128i *)(v2 + 10);
                  v159 = *(__m128i *)(v2 + 26);
                  v160 = *(__m128i *)(v2 + 42);
                  v161 = *(__m128i *)(v2 + 58);
                  v162 = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_min_epu8(_mm_min_epu8(v160, v161), _mm_min_epu8(v159, v146)), v5));
                  v163 = v161;
                  v164 = _mm_alignr_epi8(v161, v160, 6);
                  v165 = _mm_alignr_epi8(v160, v159, 6);
                  if ( v162 )
                    break;
                  v166 = _mm_alignr_epi8(v159, v146, 6);
                  v2 += 64LL;
                  v167 = _mm_alignr_epi8(v146, v145, 6);
                  v145 = v163;
                  *(__m128i *)(v3 + 48) = v164;
                  *(__m128i *)(v3 + 32) = v165;
                  *(__m128i *)(v3 + 16) = v166;
                  *(__m128i *)v3 = v167;
                  v3 += 64LL;
                }
              }
              v168 = *(_DWORD *)(v2 + 6);
              *(_QWORD *)v3 = *(_QWORD *)v2;
              *(_DWORD *)(v3 + 6) = v168;
              v7 = 10LL;
              break;
            default:
              v169 = *(__m128i *)(v2 - 7);
              v170 = *(__m128i *)(v2 + 9);
              while ( 1 )
              {
                v171 = _mm_cmpeq_epi8(v5, v170);
                v6 = _mm_movemask_epi8(v171);
                v172 = v170;
                if ( v6 )
                  break;
                *(__m128i *)v3 = _mm_alignr_epi8(v170, v169, 7);
                v173 = *(__m128i *)(v2 + 25);
                v174 = _mm_cmpeq_epi8(v171, v173);
                v3 += 16LL;
                v6 = _mm_movemask_epi8(v174);
                v2 += 16LL;
                v175 = v173;
                if ( v6 )
                  break;
                *(__m128i *)v3 = _mm_alignr_epi8(v173, v172, 7);
                v176 = *(__m128i *)(v2 + 25);
                v177 = _mm_cmpeq_epi8(v174, v176);
                v3 += 16LL;
                v6 = _mm_movemask_epi8(v177);
                v2 += 16LL;
                v178 = v176;
                if ( v6 )
                  break;
                *(__m128i *)v3 = _mm_alignr_epi8(v176, v175, 7);
                v179 = *(__m128i *)(v2 + 25);
                v5 = _mm_cmpeq_epi8(v177, v179);
                v3 += 16LL;
                v6 = _mm_movemask_epi8(v5);
                v2 += 16LL;
                if ( v6 )
                  break;
                *(__m128i *)v3 = _mm_alignr_epi8(v179, v178, 7);
                v180 = v2 + 25;
                v181 = (v2 + 25) & 0xFFFFFFFFFFFFFFC0LL;
                v182 = v180 - v181;
                v2 = v181 - 9;
                v3 = v3 + 16 - v182;
                v169 = *(__m128i *)(v2 - 7);
                while ( 1 )
                {
                  v170 = *(__m128i *)(v2 + 9);
                  v183 = *(__m128i *)(v2 + 25);
                  v184 = *(__m128i *)(v2 + 41);
                  v185 = *(__m128i *)(v2 + 57);
                  v186 = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_min_epu8(_mm_min_epu8(v184, v185), _mm_min_epu8(v183, v170)), v5));
                  v187 = v185;
                  v188 = _mm_alignr_epi8(v185, v184, 7);
                  v189 = _mm_alignr_epi8(v184, v183, 7);
                  if ( v186 )
                    break;
                  v190 = _mm_alignr_epi8(v183, v170, 7);
                  v2 += 64LL;
                  v191 = _mm_alignr_epi8(v170, v169, 7);
                  v169 = v187;
                  *(__m128i *)(v3 + 48) = v188;
                  *(__m128i *)(v3 + 32) = v189;
                  *(__m128i *)(v3 + 16) = v190;
                  *(__m128i *)v3 = v191;
                  v3 += 64LL;
                }
              }
              v192 = *(_DWORD *)(v2 + 5);
              *(_QWORD *)v3 = *(_QWORD *)v2;
              *(_DWORD *)(v3 + 5) = v192;
              v7 = 9LL;
              break;
          }
        }
      }
      else
      {
        v9 = *(__m128i *)(v2 + 16);
        *(_OWORD *)v3 = *(_OWORD *)v2;
        v10 = _mm_cmpeq_epi8(v5, v9);
        v6 = _mm_movemask_epi8(v10);
        v7 = 16LL;
        if ( !v6 )
        {
          v11 = *(__m128i *)(v2 + 32);
          *(__m128i *)(((unsigned __int64)(a1 + 2) & 0xFFFFFFFFFFFFFFF0LL) + 0x10) = v9;
          v12 = _mm_cmpeq_epi8(v10, v11);
          v6 = _mm_movemask_epi8(v12);
          v7 = 32LL;
          if ( !v6 )
          {
            v13 = *(__m128i *)(v2 + 48);
            *(__m128i *)(((unsigned __int64)(a1 + 2) & 0xFFFFFFFFFFFFFFF0LL) + 0x20) = v11;
            v14 = _mm_cmpeq_epi8(v12, v13);
            v6 = _mm_movemask_epi8(v14);
            v7 = 48LL;
            if ( !v6 )
            {
              v15 = *(__m128i *)(v2 + 64);
              *(__m128i *)(((unsigned __int64)(a1 + 2) & 0xFFFFFFFFFFFFFFF0LL) + 0x30) = v13;
              v16 = _mm_cmpeq_epi8(v14, v15);
              v6 = _mm_movemask_epi8(v16);
              v7 = 64LL;
              if ( !v6 )
              {
                v17 = *(__m128i *)(v2 + 80);
                *(__m128i *)(((unsigned __int64)(a1 + 2) & 0xFFFFFFFFFFFFFFF0LL) + 0x40) = v15;
                v18 = _mm_cmpeq_epi8(v16, v17);
                v6 = _mm_movemask_epi8(v18);
                v7 = 80LL;
                if ( !v6 )
                {
                  v19 = *(__m128i *)(v2 + 96);
                  *(__m128i *)(((unsigned __int64)(a1 + 2) & 0xFFFFFFFFFFFFFFF0LL) + 0x50) = v17;
                  v20 = _mm_cmpeq_epi8(v18, v19);
                  v6 = _mm_movemask_epi8(v20);
                  v7 = 96LL;
                  if ( !v6 )
                  {
                    *(__m128i *)(((unsigned __int64)(a1 + 2) & 0xFFFFFFFFFFFFFFF0LL) + 0x60) = v19;
                    v21 = v2;
                    v2 = (v2 + 112) & 0xFFFFFFFFFFFFFFC0LL;
                    v3 -= v21 - v2;
                    v7 = -64LL;
                    while ( 1 )
                    {
                      v22 = *(__m128i *)v2;
                      v23 = *(__m128i *)(v2 + 16);
                      v24 = *(__m128i *)(v2 + 32);
                      v25 = *(__m128i *)(v2 + 48);
                      v26 = _mm_movemask_epi8(
                              _mm_cmpeq_epi8(
                                _mm_min_epu8(_mm_min_epu8(v24, v25), _mm_min_epu8(*(__m128i *)v2, v23)),
                                v20));
                      v3 += 64LL;
                      v2 += 64LL;
                      if ( v26 )
                        break;
                      *(__m128i *)(v3 - 64) = v22;
                      *(__m128i *)(v3 - 48) = v23;
                      *(__m128i *)(v3 - 32) = v24;
                      *(__m128i *)(v3 - 16) = v25;
                    }
                    v27 = _mm_cmpeq_epi8(v20, v22);
                    v6 = _mm_movemask_epi8(v27);
                    if ( !v6 )
                    {
                      v28 = _mm_cmpeq_epi8(v27, v23);
                      v6 = _mm_movemask_epi8(v28);
                      *(__m128i *)(v3 - 64) = v22;
                      v7 = -48LL;
                      if ( !v6 )
                      {
                        v29 = _mm_cmpeq_epi8(v28, v24);
                        v6 = _mm_movemask_epi8(v29);
                        *(__m128i *)(v3 - 48) = v23;
                        v7 = -32LL;
                        if ( !v6 )
                        {
                          *(__m128i *)(v3 - 32) = v24;
                          LOWORD(v6) = _mm_movemask_epi8(_mm_cmpeq_epi8(v29, v25));
                          v7 = -16LL;
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    v3 += v7;
    v2 += v7;
    if ( (_BYTE)v6 )
    {
      if ( (v6 & 1) == 0 )
      {
        if ( (v6 & 2) == 0 )
        {
          if ( (v6 & 4) == 0 )
          {
            if ( (v6 & 8) == 0 )
            {
              if ( (v6 & 0x10) == 0 )
              {
                if ( (v6 & 0x20) == 0 )
                {
                  if ( (v6 & 0x40) == 0 )
                    goto LABEL_189;
                  goto LABEL_204;
                }
LABEL_203:
                *(_DWORD *)v3 = *(_DWORD *)v2;
                *(_WORD *)(v3 + 4) = *(_WORD *)(v2 + 4);
                return a1;
              }
LABEL_202:
              *(_DWORD *)v3 = *(_DWORD *)v2;
              *(_BYTE *)(v3 + 4) = *(_BYTE *)(v2 + 4);
              return a1;
            }
LABEL_201:
            *(_DWORD *)v3 = *(_DWORD *)v2;
            return a1;
          }
LABEL_200:
          *(_WORD *)v3 = *(_WORD *)v2;
          *(_BYTE *)(v3 + 2) = *(_BYTE *)(v2 + 2);
          return a1;
        }
LABEL_199:
        *(_WORD *)v3 = *(_WORD *)v2;
        return a1;
      }
LABEL_198:
      *(_BYTE *)v3 = *(_BYTE *)v2;
      return a1;
    }
    if ( (v6 & 0x100) == 0 )
    {
      if ( (v6 & 0x200) == 0 )
      {
        if ( (v6 & 0x400) == 0 )
        {
          if ( (v6 & 0x800) == 0 )
          {
            if ( (v6 & 0x1000) == 0 )
            {
              if ( (v6 & 0x2000) == 0 )
              {
                if ( (v6 & 0x4000) == 0 )
                  goto LABEL_197;
                goto LABEL_211;
              }
LABEL_210:
              *(_QWORD *)v3 = *(_QWORD *)v2;
              *(_QWORD *)(v3 + 6) = *(_QWORD *)(v2 + 6);
              return a1;
            }
LABEL_209:
            *(_QWORD *)v3 = *(_QWORD *)v2;
            *(_QWORD *)(v3 + 5) = *(_QWORD *)(v2 + 5);
            return a1;
          }
LABEL_208:
          *(_QWORD *)v3 = *(_QWORD *)v2;
          *(_DWORD *)(v3 + 8) = *(_DWORD *)(v2 + 8);
          return a1;
        }
LABEL_207:
        *(_QWORD *)v3 = *(_QWORD *)v2;
        *(_DWORD *)(v3 + 7) = *(_DWORD *)(v2 + 7);
        return a1;
      }
LABEL_206:
      *(_QWORD *)v3 = *(_QWORD *)v2;
      *(_DWORD *)(v3 + 6) = *(_DWORD *)(v2 + 6);
      return a1;
    }
LABEL_205:
    *(_QWORD *)v3 = *(_QWORD *)v2;
    *(_DWORD *)(v3 + 5) = *(_DWORD *)(v2 + 5);
    return a1;
  }
LABEL_211:
  *(_QWORD *)v3 = *(_QWORD *)v2;
  *(_QWORD *)(v3 + 7) = *(_QWORD *)(v2 + 7);
  return a1;
}

//----- (0000000000436500) ----------------------------------------------------
unsigned __int64 __fastcall _stpcpy_ssse3(_QWORD *a1, _BYTE *a2)
{
  unsigned __int64 v2; // rcx
  unsigned __int64 v3; // rdx
  __m128i *v4; // rsi
  __m128i v5; // xmm0
  int v6; // eax
  __int64 v7; // rsi
  unsigned __int64 v8; // rax
  __m128i v9; // xmm2
  __m128i v10; // xmm0
  __m128i v11; // xmm3
  __m128i v12; // xmm0
  __m128i v13; // xmm4
  __m128i v14; // xmm0
  __m128i v15; // xmm1
  __m128i v16; // xmm0
  __m128i v17; // xmm2
  __m128i v18; // xmm0
  __m128i v19; // xmm3
  __m128i v20; // xmm0
  unsigned __int64 v21; // rax
  __m128i v22; // xmm4
  __m128i v23; // xmm5
  __m128i v24; // xmm6
  __m128i v25; // xmm7
  int v26; // eax
  __m128i v27; // xmm0
  __m128i v28; // xmm0
  __m128i v29; // xmm0
  __m128i v30; // xmm1
  __m128i v31; // xmm2
  __m128i v32; // xmm0
  __m128i v33; // xmm3
  __m128i v34; // xmm2
  __m128i v35; // xmm0
  __m128i v36; // xmm1
  __m128i v37; // xmm2
  __m128i v38; // xmm0
  __m128i v39; // xmm3
  __m128i v40; // xmm2
  unsigned __int64 v41; // rax
  unsigned __int64 v42; // rcx
  unsigned __int64 v43; // rax
  __m128i v44; // xmm3
  __m128i v45; // xmm4
  __m128i v46; // xmm5
  int v47; // eax
  __m128i v48; // xmm7
  __m128i v49; // xmm5
  __m128i v50; // xmm4
  __m128i v51; // xmm3
  __m128i v52; // xmm2
  __m128i v53; // xmm1
  __m128i v54; // xmm2
  __m128i v55; // xmm0
  __m128i v56; // xmm3
  __m128i v57; // xmm2
  __m128i v58; // xmm0
  __m128i v59; // xmm1
  __m128i v60; // xmm2
  __m128i v61; // xmm0
  __m128i v62; // xmm3
  __m128i v63; // xmm2
  unsigned __int64 v64; // rax
  unsigned __int64 v65; // rcx
  unsigned __int64 v66; // rax
  __m128i v67; // xmm3
  __m128i v68; // xmm4
  __m128i v69; // xmm5
  int v70; // eax
  __m128i v71; // xmm7
  __m128i v72; // xmm5
  __m128i v73; // xmm4
  __m128i v74; // xmm3
  __m128i v75; // xmm2
  __m128i v76; // xmm1
  __m128i v77; // xmm2
  __m128i v78; // xmm0
  __m128i v79; // xmm3
  __m128i v80; // xmm2
  __m128i v81; // xmm0
  __m128i v82; // xmm1
  __m128i v83; // xmm2
  __m128i v84; // xmm0
  __m128i v85; // xmm3
  __m128i v86; // xmm2
  unsigned __int64 v87; // rax
  unsigned __int64 v88; // rcx
  unsigned __int64 v89; // rax
  __m128i v90; // xmm3
  __m128i v91; // xmm4
  __m128i v92; // xmm5
  int v93; // eax
  __m128i v94; // xmm7
  __m128i v95; // xmm5
  __m128i v96; // xmm4
  __m128i v97; // xmm3
  __m128i v98; // xmm2
  __m128i v99; // xmm1
  __m128i v100; // xmm2
  __m128i v101; // xmm0
  __m128i v102; // xmm3
  __m128i v103; // xmm2
  __m128i v104; // xmm0
  __m128i v105; // xmm1
  __m128i v106; // xmm2
  __m128i v107; // xmm0
  __m128i v108; // xmm3
  __m128i v109; // xmm2
  unsigned __int64 v110; // rax
  unsigned __int64 v111; // rcx
  unsigned __int64 v112; // rax
  __m128i v113; // xmm3
  __m128i v114; // xmm4
  __m128i v115; // xmm5
  int v116; // eax
  __m128i v117; // xmm7
  __m128i v118; // xmm5
  __m128i v119; // xmm4
  __m128i v120; // xmm3
  __m128i v121; // xmm2
  __m128i v122; // xmm1
  __m128i v123; // xmm2
  __m128i v124; // xmm0
  __m128i v125; // xmm3
  __m128i v126; // xmm2
  __m128i v127; // xmm0
  __m128i v128; // xmm1
  __m128i v129; // xmm2
  __m128i v130; // xmm0
  __m128i v131; // xmm3
  __m128i v132; // xmm2
  unsigned __int64 v133; // rax
  unsigned __int64 v134; // rcx
  unsigned __int64 v135; // rax
  __m128i v136; // xmm3
  __m128i v137; // xmm4
  __m128i v138; // xmm5
  int v139; // eax
  __m128i v140; // xmm7
  __m128i v141; // xmm5
  __m128i v142; // xmm4
  __m128i v143; // xmm3
  __m128i v144; // xmm2
  __m128i v145; // xmm1
  __m128i v146; // xmm2
  __m128i v147; // xmm0
  __m128i v148; // xmm3
  __m128i v149; // xmm2
  __m128i v150; // xmm0
  __m128i v151; // xmm1
  __m128i v152; // xmm2
  __m128i v153; // xmm0
  __m128i v154; // xmm3
  __m128i v155; // xmm2
  unsigned __int64 v156; // rax
  unsigned __int64 v157; // rcx
  unsigned __int64 v158; // rax
  __m128i v159; // xmm3
  __m128i v160; // xmm4
  __m128i v161; // xmm5
  int v162; // eax
  __m128i v163; // xmm7
  __m128i v164; // xmm5
  __m128i v165; // xmm4
  __m128i v166; // xmm3
  __m128i v167; // xmm2
  int v168; // esi
  __m128i v169; // xmm1
  __m128i v170; // xmm2
  __m128i v171; // xmm0
  __m128i v172; // xmm3
  __m128i v173; // xmm2
  __m128i v174; // xmm0
  __m128i v175; // xmm1
  __m128i v176; // xmm2
  __m128i v177; // xmm0
  __m128i v178; // xmm3
  __m128i v179; // xmm2
  unsigned __int64 v180; // rax
  unsigned __int64 v181; // rcx
  unsigned __int64 v182; // rax
  __m128i v183; // xmm3
  __m128i v184; // xmm4
  __m128i v185; // xmm5
  int v186; // eax
  __m128i v187; // xmm7
  __m128i v188; // xmm5
  __m128i v189; // xmm4
  __m128i v190; // xmm3
  __m128i v191; // xmm2
  int v192; // esi
  __m128i v193; // xmm1
  __m128i v194; // xmm2
  __m128i v195; // xmm0
  __m128i v196; // xmm3
  __m128i v197; // xmm2
  __m128i v198; // xmm0
  __m128i v199; // xmm1
  __m128i v200; // xmm2
  __m128i v201; // xmm0
  __m128i v202; // xmm3
  __m128i v203; // xmm2
  unsigned __int64 v204; // rax
  unsigned __int64 v205; // rcx
  unsigned __int64 v206; // rax
  __m128i v207; // xmm3
  __m128i v208; // xmm4
  __m128i v209; // xmm5
  int v210; // eax
  __m128i v211; // xmm7
  __m128i v212; // xmm5
  __m128i v213; // xmm4
  __m128i v214; // xmm3
  __m128i v215; // xmm2
  __m128i v216; // xmm1
  __m128i v217; // xmm2
  __m128i v218; // xmm0
  __m128i v219; // xmm3
  __m128i v220; // xmm2
  __m128i v221; // xmm0
  __m128i v222; // xmm1
  __m128i v223; // xmm2
  __m128i v224; // xmm0
  __m128i v225; // xmm3
  __m128i v226; // xmm2
  unsigned __int64 v227; // rax
  unsigned __int64 v228; // rcx
  unsigned __int64 v229; // rax
  __m128i v230; // xmm3
  __m128i v231; // xmm4
  __m128i v232; // xmm5
  int v233; // eax
  __m128i v234; // xmm7
  __m128i v235; // xmm5
  __m128i v236; // xmm4
  __m128i v237; // xmm3
  __m128i v238; // xmm2
  __m128i v239; // xmm1
  __m128i v240; // xmm2
  __m128i v241; // xmm0
  __m128i v242; // xmm3
  __m128i v243; // xmm2
  __m128i v244; // xmm0
  __m128i v245; // xmm1
  __m128i v246; // xmm2
  __m128i v247; // xmm0
  __m128i v248; // xmm3
  __m128i v249; // xmm2
  unsigned __int64 v250; // rax
  unsigned __int64 v251; // rcx
  unsigned __int64 v252; // rax
  __m128i v253; // xmm3
  __m128i v254; // xmm4
  __m128i v255; // xmm5
  int v256; // eax
  __m128i v257; // xmm7
  __m128i v258; // xmm5
  __m128i v259; // xmm4
  __m128i v260; // xmm3
  __m128i v261; // xmm2
  __m128i v262; // xmm1
  __m128i v263; // xmm2
  __m128i v264; // xmm0
  __m128i v265; // xmm3
  __m128i v266; // xmm2
  __m128i v267; // xmm0
  __m128i v268; // xmm1
  __m128i v269; // xmm2
  __m128i v270; // xmm0
  __m128i v271; // xmm3
  __m128i v272; // xmm2
  unsigned __int64 v273; // rax
  unsigned __int64 v274; // rcx
  unsigned __int64 v275; // rax
  __m128i v276; // xmm3
  __m128i v277; // xmm4
  __m128i v278; // xmm5
  int v279; // eax
  __m128i v280; // xmm7
  __m128i v281; // xmm5
  __m128i v282; // xmm4
  __m128i v283; // xmm3
  __m128i v284; // xmm2
  __m128i v285; // xmm1
  __m128i v286; // xmm2
  __m128i v287; // xmm0
  __m128i v288; // xmm3
  __m128i v289; // xmm2
  __m128i v290; // xmm0
  __m128i v291; // xmm1
  __m128i v292; // xmm2
  __m128i v293; // xmm0
  __m128i v294; // xmm3
  __m128i v295; // xmm2
  unsigned __int64 v296; // rax
  unsigned __int64 v297; // rcx
  unsigned __int64 v298; // rax
  __m128i v299; // xmm3
  __m128i v300; // xmm4
  __m128i v301; // xmm5
  int v302; // eax
  __m128i v303; // xmm7
  __m128i v304; // xmm5
  __m128i v305; // xmm4
  __m128i v306; // xmm3
  __m128i v307; // xmm2
  __m128i v308; // xmm1
  __m128i v309; // xmm2
  __m128i v310; // xmm0
  __m128i v311; // xmm3
  __m128i v312; // xmm2
  __m128i v313; // xmm0
  __m128i v314; // xmm1
  __m128i v315; // xmm2
  __m128i v316; // xmm0
  __m128i v317; // xmm3
  __m128i v318; // xmm2
  unsigned __int64 v319; // rax
  unsigned __int64 v320; // rcx
  unsigned __int64 v321; // rax
  __m128i v322; // xmm3
  __m128i v323; // xmm4
  __m128i v324; // xmm5
  int v325; // eax
  __m128i v326; // xmm7
  __m128i v327; // xmm5
  __m128i v328; // xmm4
  __m128i v329; // xmm3
  __m128i v330; // xmm2
  __m128i v331; // xmm1
  __m128i v332; // xmm2
  __m128i v333; // xmm0
  __m128i v334; // xmm3
  __m128i v335; // xmm2
  __m128i v336; // xmm0
  __m128i v337; // xmm1
  __m128i v338; // xmm2
  __m128i v339; // xmm0
  __m128i v340; // xmm3
  __m128i v341; // xmm2
  unsigned __int64 v342; // rax
  unsigned __int64 v343; // rcx
  unsigned __int64 v344; // rax
  __m128i v345; // xmm3
  __m128i v346; // xmm4
  __m128i v347; // xmm5
  int v348; // eax
  __m128i v349; // xmm7
  __m128i v350; // xmm5
  __m128i v351; // xmm4
  __m128i v352; // xmm3
  __m128i v353; // xmm2
  __m128i v354; // xmm1
  __m128i v355; // xmm2
  __m128i v356; // xmm0
  __m128i v357; // xmm3
  __m128i v358; // xmm2
  __m128i v359; // xmm0
  __m128i v360; // xmm1
  __m128i v361; // xmm2
  __m128i v362; // xmm0
  __m128i v363; // xmm3
  __m128i v364; // xmm2
  unsigned __int64 v365; // rax
  unsigned __int64 v366; // rcx
  unsigned __int64 v367; // rax
  __m128i v368; // xmm3
  __m128i v369; // xmm4
  __m128i v370; // xmm5
  int v371; // eax
  __m128i v372; // xmm7
  __m128i v373; // xmm5
  __m128i v374; // xmm4
  __m128i v375; // xmm3
  __m128i v376; // xmm2

  v2 = (unsigned __int64)a2;
  v3 = (unsigned __int64)a1;
  if ( !*a2 )
    goto LABEL_198;
  if ( !a2[1] )
    goto LABEL_199;
  if ( !a2[2] )
    goto LABEL_200;
  if ( !a2[3] )
    goto LABEL_201;
  if ( !a2[4] )
    goto LABEL_202;
  if ( !a2[5] )
    goto LABEL_203;
  if ( !a2[6] )
  {
LABEL_204:
    *(_DWORD *)v3 = *(_DWORD *)v2;
    *(_DWORD *)(v3 + 3) = *(_DWORD *)(v2 + 3);
    return v3 + 6;
  }
  if ( !a2[7] )
  {
LABEL_189:
    *(_QWORD *)v3 = *(_QWORD *)v2;
    return v3 + 7;
  }
  if ( !a2[8] )
    goto LABEL_205;
  if ( !a2[9] )
    goto LABEL_206;
  if ( !a2[10] )
    goto LABEL_207;
  if ( !a2[11] )
    goto LABEL_208;
  if ( !a2[12] )
    goto LABEL_209;
  if ( !a2[13] )
    goto LABEL_210;
  if ( a2[14] )
  {
    if ( !a2[15] )
    {
LABEL_197:
      *(_QWORD *)v3 = *(_QWORD *)v2;
      *(_QWORD *)(v3 + 8) = *(_QWORD *)(v2 + 8);
      return v3 + 15;
    }
    v4 = (__m128i *)((unsigned __int64)(a2 + 16) & 0xFFFFFFFFFFFFFFF0LL);
    *a1 = *(_QWORD *)v2;
    v5 = _mm_cmpeq_epi8((__m128i)0LL, *v4);
    a1[1] = *(_QWORD *)(v2 + 8);
    v6 = _mm_movemask_epi8(v5);
    v7 = (__int64)v4->m128i_i64 - v2;
    if ( !v6 )
    {
      v3 = (unsigned __int64)(a1 + 2) & 0xFFFFFFFFFFFFFFF0LL;
      v2 -= (unsigned __int64)a1 - v3;
      v8 = v2 & 0xF;
      if ( (v2 & 0xF) != 0 )
      {
        if ( v8 >= 8 )
        {
          switch ( v8 )
          {
            case 8uLL:
              v193 = *(__m128i *)(v2 - 8);
              v194 = *(__m128i *)(v2 + 8);
              while ( 1 )
              {
                v195 = _mm_cmpeq_epi8(v5, v194);
                v6 = _mm_movemask_epi8(v195);
                v196 = v194;
                if ( v6 )
                  break;
                *(__m128i *)v3 = _mm_alignr_epi8(v194, v193, 8);
                v197 = *(__m128i *)(v2 + 24);
                v198 = _mm_cmpeq_epi8(v195, v197);
                v3 += 16LL;
                v6 = _mm_movemask_epi8(v198);
                v2 += 16LL;
                v199 = v197;
                if ( v6 )
                  break;
                *(__m128i *)v3 = _mm_alignr_epi8(v197, v196, 8);
                v200 = *(__m128i *)(v2 + 24);
                v201 = _mm_cmpeq_epi8(v198, v200);
                v3 += 16LL;
                v6 = _mm_movemask_epi8(v201);
                v2 += 16LL;
                v202 = v200;
                if ( v6 )
                  break;
                *(__m128i *)v3 = _mm_alignr_epi8(v200, v199, 8);
                v203 = *(__m128i *)(v2 + 24);
                v5 = _mm_cmpeq_epi8(v201, v203);
                v3 += 16LL;
                v6 = _mm_movemask_epi8(v5);
                v2 += 16LL;
                if ( v6 )
                  break;
                *(__m128i *)v3 = _mm_alignr_epi8(v203, v202, 8);
                v204 = v2 + 24;
                v205 = (v2 + 24) & 0xFFFFFFFFFFFFFFC0LL;
                v206 = v204 - v205;
                v2 = v205 - 8;
                v3 = v3 + 16 - v206;
                v193 = *(__m128i *)(v2 - 8);
                while ( 1 )
                {
                  v194 = *(__m128i *)(v2 + 8);
                  v207 = *(__m128i *)(v2 + 24);
                  v208 = *(__m128i *)(v2 + 40);
                  v209 = *(__m128i *)(v2 + 56);
                  v210 = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_min_epu8(_mm_min_epu8(v208, v209), _mm_min_epu8(v207, v194)), v5));
                  v211 = v209;
                  v212 = _mm_alignr_epi8(v209, v208, 8);
                  v213 = _mm_alignr_epi8(v208, v207, 8);
                  if ( v210 )
                    break;
                  v214 = _mm_alignr_epi8(v207, v194, 8);
                  v2 += 64LL;
                  v215 = _mm_alignr_epi8(v194, v193, 8);
                  v193 = v211;
                  *(__m128i *)(v3 + 48) = v212;
                  *(__m128i *)(v3 + 32) = v213;
                  *(__m128i *)(v3 + 16) = v214;
                  *(__m128i *)v3 = v215;
                  v3 += 64LL;
                }
              }
              v7 = 8LL;
              *(_QWORD *)v3 = *(_QWORD *)v2;
              break;
            case 9uLL:
              v216 = *(__m128i *)(v2 - 9);
              v217 = *(__m128i *)(v2 + 7);
              while ( 1 )
              {
                v218 = _mm_cmpeq_epi8(v5, v217);
                v6 = _mm_movemask_epi8(v218);
                v219 = v217;
                if ( v6 )
                  break;
                *(__m128i *)v3 = _mm_alignr_epi8(v217, v216, 9);
                v220 = *(__m128i *)(v2 + 23);
                v221 = _mm_cmpeq_epi8(v218, v220);
                v3 += 16LL;
                v6 = _mm_movemask_epi8(v221);
                v2 += 16LL;
                v222 = v220;
                if ( v6 )
                  break;
                *(__m128i *)v3 = _mm_alignr_epi8(v220, v219, 9);
                v223 = *(__m128i *)(v2 + 23);
                v224 = _mm_cmpeq_epi8(v221, v223);
                v3 += 16LL;
                v6 = _mm_movemask_epi8(v224);
                v2 += 16LL;
                v225 = v223;
                if ( v6 )
                  break;
                *(__m128i *)v3 = _mm_alignr_epi8(v223, v222, 9);
                v226 = *(__m128i *)(v2 + 23);
                v5 = _mm_cmpeq_epi8(v224, v226);
                v3 += 16LL;
                v6 = _mm_movemask_epi8(v5);
                v2 += 16LL;
                if ( v6 )
                  break;
                *(__m128i *)v3 = _mm_alignr_epi8(v226, v225, 9);
                v227 = v2 + 23;
                v228 = (v2 + 23) & 0xFFFFFFFFFFFFFFC0LL;
                v229 = v227 - v228;
                v2 = v228 - 7;
                v3 = v3 + 16 - v229;
                v216 = *(__m128i *)(v2 - 9);
                while ( 1 )
                {
                  v217 = *(__m128i *)(v2 + 7);
                  v230 = *(__m128i *)(v2 + 23);
                  v231 = *(__m128i *)(v2 + 39);
                  v232 = *(__m128i *)(v2 + 55);
                  v233 = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_min_epu8(_mm_min_epu8(v231, v232), _mm_min_epu8(v230, v217)), v5));
                  v234 = v232;
                  v235 = _mm_alignr_epi8(v232, v231, 9);
                  v236 = _mm_alignr_epi8(v231, v230, 9);
                  if ( v233 )
                    break;
                  v237 = _mm_alignr_epi8(v230, v217, 9);
                  v2 += 64LL;
                  v238 = _mm_alignr_epi8(v217, v216, 9);
                  v216 = v234;
                  *(__m128i *)(v3 + 48) = v235;
                  *(__m128i *)(v3 + 32) = v236;
                  *(__m128i *)(v3 + 16) = v237;
                  *(__m128i *)v3 = v238;
                  v3 += 64LL;
                }
              }
              v7 = 7LL;
              *(_QWORD *)(v3 - 1) = *(_QWORD *)(v2 - 1);
              break;
            case 0xAuLL:
              v239 = *(__m128i *)(v2 - 10);
              v240 = *(__m128i *)(v2 + 6);
              while ( 1 )
              {
                v241 = _mm_cmpeq_epi8(v5, v240);
                v6 = _mm_movemask_epi8(v241);
                v242 = v240;
                if ( v6 )
                  break;
                *(__m128i *)v3 = _mm_alignr_epi8(v240, v239, 10);
                v243 = *(__m128i *)(v2 + 22);
                v244 = _mm_cmpeq_epi8(v241, v243);
                v3 += 16LL;
                v6 = _mm_movemask_epi8(v244);
                v2 += 16LL;
                v245 = v243;
                if ( v6 )
                  break;
                *(__m128i *)v3 = _mm_alignr_epi8(v243, v242, 10);
                v246 = *(__m128i *)(v2 + 22);
                v247 = _mm_cmpeq_epi8(v244, v246);
                v3 += 16LL;
                v6 = _mm_movemask_epi8(v247);
                v2 += 16LL;
                v248 = v246;
                if ( v6 )
                  break;
                *(__m128i *)v3 = _mm_alignr_epi8(v246, v245, 10);
                v249 = *(__m128i *)(v2 + 22);
                v5 = _mm_cmpeq_epi8(v247, v249);
                v3 += 16LL;
                v6 = _mm_movemask_epi8(v5);
                v2 += 16LL;
                if ( v6 )
                  break;
                *(__m128i *)v3 = _mm_alignr_epi8(v249, v248, 10);
                v250 = v2 + 22;
                v251 = (v2 + 22) & 0xFFFFFFFFFFFFFFC0LL;
                v252 = v250 - v251;
                v2 = v251 - 6;
                v3 = v3 + 16 - v252;
                v239 = *(__m128i *)(v2 - 10);
                while ( 1 )
                {
                  v240 = *(__m128i *)(v2 + 6);
                  v253 = *(__m128i *)(v2 + 22);
                  v254 = *(__m128i *)(v2 + 38);
                  v255 = *(__m128i *)(v2 + 54);
                  v256 = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_min_epu8(_mm_min_epu8(v254, v255), _mm_min_epu8(v253, v240)), v5));
                  v257 = v255;
                  v258 = _mm_alignr_epi8(v255, v254, 10);
                  v259 = _mm_alignr_epi8(v254, v253, 10);
                  if ( v256 )
                    break;
                  v260 = _mm_alignr_epi8(v253, v240, 10);
                  v2 += 64LL;
                  v261 = _mm_alignr_epi8(v240, v239, 10);
                  v239 = v257;
                  *(__m128i *)(v3 + 48) = v258;
                  *(__m128i *)(v3 + 32) = v259;
                  *(__m128i *)(v3 + 16) = v260;
                  *(__m128i *)v3 = v261;
                  v3 += 64LL;
                }
              }
              v7 = 6LL;
              *(_QWORD *)(v3 - 2) = *(_QWORD *)(v2 - 2);
              break;
            case 0xBuLL:
              v262 = *(__m128i *)(v2 - 11);
              v263 = *(__m128i *)(v2 + 5);
              while ( 1 )
              {
                v264 = _mm_cmpeq_epi8(v5, v263);
                v6 = _mm_movemask_epi8(v264);
                v265 = v263;
                if ( v6 )
                  break;
                *(__m128i *)v3 = _mm_alignr_epi8(v263, v262, 11);
                v266 = *(__m128i *)(v2 + 21);
                v267 = _mm_cmpeq_epi8(v264, v266);
                v3 += 16LL;
                v6 = _mm_movemask_epi8(v267);
                v2 += 16LL;
                v268 = v266;
                if ( v6 )
                  break;
                *(__m128i *)v3 = _mm_alignr_epi8(v266, v265, 11);
                v269 = *(__m128i *)(v2 + 21);
                v270 = _mm_cmpeq_epi8(v267, v269);
                v3 += 16LL;
                v6 = _mm_movemask_epi8(v270);
                v2 += 16LL;
                v271 = v269;
                if ( v6 )
                  break;
                *(__m128i *)v3 = _mm_alignr_epi8(v269, v268, 11);
                v272 = *(__m128i *)(v2 + 21);
                v5 = _mm_cmpeq_epi8(v270, v272);
                v3 += 16LL;
                v6 = _mm_movemask_epi8(v5);
                v2 += 16LL;
                if ( v6 )
                  break;
                *(__m128i *)v3 = _mm_alignr_epi8(v272, v271, 11);
                v273 = v2 + 21;
                v274 = (v2 + 21) & 0xFFFFFFFFFFFFFFC0LL;
                v275 = v273 - v274;
                v2 = v274 - 5;
                v3 = v3 + 16 - v275;
                v262 = *(__m128i *)(v2 - 11);
                while ( 1 )
                {
                  v263 = *(__m128i *)(v2 + 5);
                  v276 = *(__m128i *)(v2 + 21);
                  v277 = *(__m128i *)(v2 + 37);
                  v278 = *(__m128i *)(v2 + 53);
                  v279 = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_min_epu8(_mm_min_epu8(v277, v278), _mm_min_epu8(v276, v263)), v5));
                  v280 = v278;
                  v281 = _mm_alignr_epi8(v278, v277, 11);
                  v282 = _mm_alignr_epi8(v277, v276, 11);
                  if ( v279 )
                    break;
                  v283 = _mm_alignr_epi8(v276, v263, 11);
                  v2 += 64LL;
                  v284 = _mm_alignr_epi8(v263, v262, 11);
                  v262 = v280;
                  *(__m128i *)(v3 + 48) = v281;
                  *(__m128i *)(v3 + 32) = v282;
                  *(__m128i *)(v3 + 16) = v283;
                  *(__m128i *)v3 = v284;
                  v3 += 64LL;
                }
              }
              v7 = 5LL;
              *(_QWORD *)(v3 - 3) = *(_QWORD *)(v2 - 3);
              break;
            case 0xCuLL:
              v285 = *(__m128i *)(v2 - 12);
              v286 = *(__m128i *)(v2 + 4);
              while ( 1 )
              {
                v287 = _mm_cmpeq_epi8(v5, v286);
                v6 = _mm_movemask_epi8(v287);
                v288 = v286;
                if ( v6 )
                  break;
                *(__m128i *)v3 = _mm_alignr_epi8(v286, v285, 12);
                v289 = *(__m128i *)(v2 + 20);
                v290 = _mm_cmpeq_epi8(v287, v289);
                v3 += 16LL;
                v6 = _mm_movemask_epi8(v290);
                v2 += 16LL;
                v291 = v289;
                if ( v6 )
                  break;
                *(__m128i *)v3 = _mm_alignr_epi8(v289, v288, 12);
                v292 = *(__m128i *)(v2 + 20);
                v293 = _mm_cmpeq_epi8(v290, v292);
                v3 += 16LL;
                v6 = _mm_movemask_epi8(v293);
                v2 += 16LL;
                v294 = v292;
                if ( v6 )
                  break;
                *(__m128i *)v3 = _mm_alignr_epi8(v292, v291, 12);
                v295 = *(__m128i *)(v2 + 20);
                v5 = _mm_cmpeq_epi8(v293, v295);
                v3 += 16LL;
                v6 = _mm_movemask_epi8(v5);
                v2 += 16LL;
                if ( v6 )
                  break;
                *(__m128i *)v3 = _mm_alignr_epi8(v295, v294, 12);
                v296 = v2 + 20;
                v297 = (v2 + 20) & 0xFFFFFFFFFFFFFFC0LL;
                v298 = v296 - v297;
                v2 = v297 - 4;
                v3 = v3 + 16 - v298;
                v285 = *(__m128i *)(v2 - 12);
                while ( 1 )
                {
                  v286 = *(__m128i *)(v2 + 4);
                  v299 = *(__m128i *)(v2 + 20);
                  v300 = *(__m128i *)(v2 + 36);
                  v301 = *(__m128i *)(v2 + 52);
                  v302 = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_min_epu8(_mm_min_epu8(v300, v301), _mm_min_epu8(v299, v286)), v5));
                  v303 = v301;
                  v304 = _mm_alignr_epi8(v301, v300, 12);
                  v305 = _mm_alignr_epi8(v300, v299, 12);
                  if ( v302 )
                    break;
                  v306 = _mm_alignr_epi8(v299, v286, 12);
                  v2 += 64LL;
                  v307 = _mm_alignr_epi8(v286, v285, 12);
                  v285 = v303;
                  *(__m128i *)(v3 + 48) = v304;
                  *(__m128i *)(v3 + 32) = v305;
                  *(__m128i *)(v3 + 16) = v306;
                  *(__m128i *)v3 = v307;
                  v3 += 64LL;
                }
              }
              v7 = 4LL;
              *(_DWORD *)v3 = *(_DWORD *)v2;
              break;
            case 0xDuLL:
              v308 = *(__m128i *)(v2 - 13);
              v309 = *(__m128i *)(v2 + 3);
              while ( 1 )
              {
                v310 = _mm_cmpeq_epi8(v5, v309);
                v6 = _mm_movemask_epi8(v310);
                v311 = v309;
                if ( v6 )
                  break;
                *(__m128i *)v3 = _mm_alignr_epi8(v309, v308, 13);
                v312 = *(__m128i *)(v2 + 19);
                v313 = _mm_cmpeq_epi8(v310, v312);
                v3 += 16LL;
                v6 = _mm_movemask_epi8(v313);
                v2 += 16LL;
                v314 = v312;
                if ( v6 )
                  break;
                *(__m128i *)v3 = _mm_alignr_epi8(v312, v311, 13);
                v315 = *(__m128i *)(v2 + 19);
                v316 = _mm_cmpeq_epi8(v313, v315);
                v3 += 16LL;
                v6 = _mm_movemask_epi8(v316);
                v2 += 16LL;
                v317 = v315;
                if ( v6 )
                  break;
                *(__m128i *)v3 = _mm_alignr_epi8(v315, v314, 13);
                v318 = *(__m128i *)(v2 + 19);
                v5 = _mm_cmpeq_epi8(v316, v318);
                v3 += 16LL;
                v6 = _mm_movemask_epi8(v5);
                v2 += 16LL;
                if ( v6 )
                  break;
                *(__m128i *)v3 = _mm_alignr_epi8(v318, v317, 13);
                v319 = v2 + 19;
                v320 = (v2 + 19) & 0xFFFFFFFFFFFFFFC0LL;
                v321 = v319 - v320;
                v2 = v320 - 3;
                v3 = v3 + 16 - v321;
                v308 = *(__m128i *)(v2 - 13);
                while ( 1 )
                {
                  v309 = *(__m128i *)(v2 + 3);
                  v322 = *(__m128i *)(v2 + 19);
                  v323 = *(__m128i *)(v2 + 35);
                  v324 = *(__m128i *)(v2 + 51);
                  v325 = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_min_epu8(_mm_min_epu8(v323, v324), _mm_min_epu8(v322, v309)), v5));
                  v326 = v324;
                  v327 = _mm_alignr_epi8(v324, v323, 13);
                  v328 = _mm_alignr_epi8(v323, v322, 13);
                  if ( v325 )
                    break;
                  v329 = _mm_alignr_epi8(v322, v309, 13);
                  v2 += 64LL;
                  v330 = _mm_alignr_epi8(v309, v308, 13);
                  v308 = v326;
                  *(__m128i *)(v3 + 48) = v327;
                  *(__m128i *)(v3 + 32) = v328;
                  *(__m128i *)(v3 + 16) = v329;
                  *(__m128i *)v3 = v330;
                  v3 += 64LL;
                }
              }
              v7 = 3LL;
              *(_DWORD *)(v3 - 1) = *(_DWORD *)(v2 - 1);
              break;
            case 0xEuLL:
              v331 = *(__m128i *)(v2 - 14);
              v332 = *(__m128i *)(v2 + 2);
              while ( 1 )
              {
                v333 = _mm_cmpeq_epi8(v5, v332);
                v6 = _mm_movemask_epi8(v333);
                v334 = v332;
                if ( v6 )
                  break;
                *(__m128i *)v3 = _mm_alignr_epi8(v332, v331, 14);
                v335 = *(__m128i *)(v2 + 18);
                v336 = _mm_cmpeq_epi8(v333, v335);
                v3 += 16LL;
                v6 = _mm_movemask_epi8(v336);
                v2 += 16LL;
                v337 = v335;
                if ( v6 )
                  break;
                *(__m128i *)v3 = _mm_alignr_epi8(v335, v334, 14);
                v338 = *(__m128i *)(v2 + 18);
                v339 = _mm_cmpeq_epi8(v336, v338);
                v3 += 16LL;
                v6 = _mm_movemask_epi8(v339);
                v2 += 16LL;
                v340 = v338;
                if ( v6 )
                  break;
                *(__m128i *)v3 = _mm_alignr_epi8(v338, v337, 14);
                v341 = *(__m128i *)(v2 + 18);
                v5 = _mm_cmpeq_epi8(v339, v341);
                v3 += 16LL;
                v6 = _mm_movemask_epi8(v5);
                v2 += 16LL;
                if ( v6 )
                  break;
                *(__m128i *)v3 = _mm_alignr_epi8(v341, v340, 14);
                v342 = v2 + 18;
                v343 = (v2 + 18) & 0xFFFFFFFFFFFFFFC0LL;
                v344 = v342 - v343;
                v2 = v343 - 2;
                v3 = v3 + 16 - v344;
                v331 = *(__m128i *)(v2 - 14);
                while ( 1 )
                {
                  v332 = *(__m128i *)(v2 + 2);
                  v345 = *(__m128i *)(v2 + 18);
                  v346 = *(__m128i *)(v2 + 34);
                  v347 = *(__m128i *)(v2 + 50);
                  v348 = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_min_epu8(_mm_min_epu8(v346, v347), _mm_min_epu8(v345, v332)), v5));
                  v349 = v347;
                  v350 = _mm_alignr_epi8(v347, v346, 14);
                  v351 = _mm_alignr_epi8(v346, v345, 14);
                  if ( v348 )
                    break;
                  v352 = _mm_alignr_epi8(v345, v332, 14);
                  v2 += 64LL;
                  v353 = _mm_alignr_epi8(v332, v331, 14);
                  v331 = v349;
                  *(__m128i *)(v3 + 48) = v350;
                  *(__m128i *)(v3 + 32) = v351;
                  *(__m128i *)(v3 + 16) = v352;
                  *(__m128i *)v3 = v353;
                  v3 += 64LL;
                }
              }
              v7 = 2LL;
              *(_DWORD *)(v3 - 2) = *(_DWORD *)(v2 - 2);
              break;
            default:
              v354 = *(__m128i *)(v2 - 15);
              v355 = *(__m128i *)(v2 + 1);
              while ( 1 )
              {
                v356 = _mm_cmpeq_epi8(v5, v355);
                v6 = _mm_movemask_epi8(v356);
                v357 = v355;
                if ( v6 )
                  break;
                *(__m128i *)v3 = _mm_alignr_epi8(v355, v354, 15);
                v358 = *(__m128i *)(v2 + 17);
                v359 = _mm_cmpeq_epi8(v356, v358);
                v3 += 16LL;
                v6 = _mm_movemask_epi8(v359);
                v2 += 16LL;
                v360 = v358;
                if ( v6 )
                  break;
                *(__m128i *)v3 = _mm_alignr_epi8(v358, v357, 15);
                v361 = *(__m128i *)(v2 + 17);
                v362 = _mm_cmpeq_epi8(v359, v361);
                v3 += 16LL;
                v6 = _mm_movemask_epi8(v362);
                v2 += 16LL;
                v363 = v361;
                if ( v6 )
                  break;
                *(__m128i *)v3 = _mm_alignr_epi8(v361, v360, 15);
                v364 = *(__m128i *)(v2 + 17);
                v5 = _mm_cmpeq_epi8(v362, v364);
                v3 += 16LL;
                v6 = _mm_movemask_epi8(v5);
                v2 += 16LL;
                if ( v6 )
                  break;
                *(__m128i *)v3 = _mm_alignr_epi8(v364, v363, 15);
                v365 = v2 + 17;
                v366 = (v2 + 17) & 0xFFFFFFFFFFFFFFC0LL;
                v367 = v365 - v366;
                v2 = v366 - 1;
                v3 = v3 + 16 - v367;
                v354 = *(__m128i *)(v2 - 15);
                while ( 1 )
                {
                  v355 = *(__m128i *)(v2 + 1);
                  v368 = *(__m128i *)(v2 + 17);
                  v369 = *(__m128i *)(v2 + 33);
                  v370 = *(__m128i *)(v2 + 49);
                  v371 = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_min_epu8(_mm_min_epu8(v369, v370), _mm_min_epu8(v368, v355)), v5));
                  v372 = v370;
                  v373 = _mm_alignr_epi8(v370, v369, 15);
                  v374 = _mm_alignr_epi8(v369, v368, 15);
                  if ( v371 )
                    break;
                  v375 = _mm_alignr_epi8(v368, v355, 15);
                  v2 += 64LL;
                  v376 = _mm_alignr_epi8(v355, v354, 15);
                  v354 = v372;
                  *(__m128i *)(v3 + 48) = v373;
                  *(__m128i *)(v3 + 32) = v374;
                  *(__m128i *)(v3 + 16) = v375;
                  *(__m128i *)v3 = v376;
                  v3 += 64LL;
                }
              }
              v7 = 1LL;
              *(_DWORD *)(v3 - 3) = *(_DWORD *)(v2 - 3);
              break;
          }
        }
        else
        {
          switch ( v8 )
          {
            case 1uLL:
              v30 = *(__m128i *)(v2 - 1);
              v31 = *(__m128i *)(v2 + 15);
              while ( 1 )
              {
                v32 = _mm_cmpeq_epi8(v5, v31);
                v6 = _mm_movemask_epi8(v32);
                v33 = v31;
                if ( v6 )
                  break;
                *(__m128i *)v3 = _mm_alignr_epi8(v31, v30, 1);
                v34 = *(__m128i *)(v2 + 31);
                v35 = _mm_cmpeq_epi8(v32, v34);
                v3 += 16LL;
                v6 = _mm_movemask_epi8(v35);
                v2 += 16LL;
                v36 = v34;
                if ( v6 )
                  break;
                *(__m128i *)v3 = _mm_alignr_epi8(v34, v33, 1);
                v37 = *(__m128i *)(v2 + 31);
                v38 = _mm_cmpeq_epi8(v35, v37);
                v3 += 16LL;
                v6 = _mm_movemask_epi8(v38);
                v2 += 16LL;
                v39 = v37;
                if ( v6 )
                  break;
                *(__m128i *)v3 = _mm_alignr_epi8(v37, v36, 1);
                v40 = *(__m128i *)(v2 + 31);
                v5 = _mm_cmpeq_epi8(v38, v40);
                v3 += 16LL;
                v6 = _mm_movemask_epi8(v5);
                v2 += 16LL;
                if ( v6 )
                  break;
                *(__m128i *)v3 = _mm_alignr_epi8(v40, v39, 1);
                v41 = v2 + 31;
                v42 = (v2 + 31) & 0xFFFFFFFFFFFFFFC0LL;
                v43 = v41 - v42;
                v2 = v42 - 15;
                v3 = v3 + 16 - v43;
                v30 = *(__m128i *)(v2 - 1);
                while ( 1 )
                {
                  v31 = *(__m128i *)(v2 + 15);
                  v44 = *(__m128i *)(v2 + 31);
                  v45 = *(__m128i *)(v2 + 47);
                  v46 = *(__m128i *)(v2 + 63);
                  v47 = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_min_epu8(_mm_min_epu8(v45, v46), _mm_min_epu8(v44, v31)), v5));
                  v48 = v46;
                  v49 = _mm_alignr_epi8(v46, v45, 1);
                  v50 = _mm_alignr_epi8(v45, v44, 1);
                  if ( v47 )
                    break;
                  v51 = _mm_alignr_epi8(v44, v31, 1);
                  v2 += 64LL;
                  v52 = _mm_alignr_epi8(v31, v30, 1);
                  v30 = v48;
                  *(__m128i *)(v3 + 48) = v49;
                  *(__m128i *)(v3 + 32) = v50;
                  *(__m128i *)(v3 + 16) = v51;
                  *(__m128i *)v3 = v52;
                  v3 += 64LL;
                }
              }
              v7 = 15LL;
              *(__m128i *)(v3 - 1) = _mm_loadu_si128((const __m128i *)(v2 - 1));
              break;
            case 2uLL:
              v53 = *(__m128i *)(v2 - 2);
              v54 = *(__m128i *)(v2 + 14);
              while ( 1 )
              {
                v55 = _mm_cmpeq_epi8(v5, v54);
                v6 = _mm_movemask_epi8(v55);
                v56 = v54;
                if ( v6 )
                  break;
                *(__m128i *)v3 = _mm_alignr_epi8(v54, v53, 2);
                v57 = *(__m128i *)(v2 + 30);
                v58 = _mm_cmpeq_epi8(v55, v57);
                v3 += 16LL;
                v6 = _mm_movemask_epi8(v58);
                v2 += 16LL;
                v59 = v57;
                if ( v6 )
                  break;
                *(__m128i *)v3 = _mm_alignr_epi8(v57, v56, 2);
                v60 = *(__m128i *)(v2 + 30);
                v61 = _mm_cmpeq_epi8(v58, v60);
                v3 += 16LL;
                v6 = _mm_movemask_epi8(v61);
                v2 += 16LL;
                v62 = v60;
                if ( v6 )
                  break;
                *(__m128i *)v3 = _mm_alignr_epi8(v60, v59, 2);
                v63 = *(__m128i *)(v2 + 30);
                v5 = _mm_cmpeq_epi8(v61, v63);
                v3 += 16LL;
                v6 = _mm_movemask_epi8(v5);
                v2 += 16LL;
                if ( v6 )
                  break;
                *(__m128i *)v3 = _mm_alignr_epi8(v63, v62, 2);
                v64 = v2 + 30;
                v65 = (v2 + 30) & 0xFFFFFFFFFFFFFFC0LL;
                v66 = v64 - v65;
                v2 = v65 - 14;
                v3 = v3 + 16 - v66;
                v53 = *(__m128i *)(v2 - 2);
                while ( 1 )
                {
                  v54 = *(__m128i *)(v2 + 14);
                  v67 = *(__m128i *)(v2 + 30);
                  v68 = *(__m128i *)(v2 + 46);
                  v69 = *(__m128i *)(v2 + 62);
                  v70 = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_min_epu8(_mm_min_epu8(v68, v69), _mm_min_epu8(v67, v54)), v5));
                  v71 = v69;
                  v72 = _mm_alignr_epi8(v69, v68, 2);
                  v73 = _mm_alignr_epi8(v68, v67, 2);
                  if ( v70 )
                    break;
                  v74 = _mm_alignr_epi8(v67, v54, 2);
                  v2 += 64LL;
                  v75 = _mm_alignr_epi8(v54, v53, 2);
                  v53 = v71;
                  *(__m128i *)(v3 + 48) = v72;
                  *(__m128i *)(v3 + 32) = v73;
                  *(__m128i *)(v3 + 16) = v74;
                  *(__m128i *)v3 = v75;
                  v3 += 64LL;
                }
              }
              v7 = 14LL;
              *(__m128i *)(v3 - 2) = _mm_loadu_si128((const __m128i *)(v2 - 2));
              break;
            case 3uLL:
              v76 = *(__m128i *)(v2 - 3);
              v77 = *(__m128i *)(v2 + 13);
              while ( 1 )
              {
                v78 = _mm_cmpeq_epi8(v5, v77);
                v6 = _mm_movemask_epi8(v78);
                v79 = v77;
                if ( v6 )
                  break;
                *(__m128i *)v3 = _mm_alignr_epi8(v77, v76, 3);
                v80 = *(__m128i *)(v2 + 29);
                v81 = _mm_cmpeq_epi8(v78, v80);
                v3 += 16LL;
                v6 = _mm_movemask_epi8(v81);
                v2 += 16LL;
                v82 = v80;
                if ( v6 )
                  break;
                *(__m128i *)v3 = _mm_alignr_epi8(v80, v79, 3);
                v83 = *(__m128i *)(v2 + 29);
                v84 = _mm_cmpeq_epi8(v81, v83);
                v3 += 16LL;
                v6 = _mm_movemask_epi8(v84);
                v2 += 16LL;
                v85 = v83;
                if ( v6 )
                  break;
                *(__m128i *)v3 = _mm_alignr_epi8(v83, v82, 3);
                v86 = *(__m128i *)(v2 + 29);
                v5 = _mm_cmpeq_epi8(v84, v86);
                v3 += 16LL;
                v6 = _mm_movemask_epi8(v5);
                v2 += 16LL;
                if ( v6 )
                  break;
                *(__m128i *)v3 = _mm_alignr_epi8(v86, v85, 3);
                v87 = v2 + 29;
                v88 = (v2 + 29) & 0xFFFFFFFFFFFFFFC0LL;
                v89 = v87 - v88;
                v2 = v88 - 13;
                v3 = v3 + 16 - v89;
                v76 = *(__m128i *)(v2 - 3);
                while ( 1 )
                {
                  v77 = *(__m128i *)(v2 + 13);
                  v90 = *(__m128i *)(v2 + 29);
                  v91 = *(__m128i *)(v2 + 45);
                  v92 = *(__m128i *)(v2 + 61);
                  v93 = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_min_epu8(_mm_min_epu8(v91, v92), _mm_min_epu8(v90, v77)), v5));
                  v94 = v92;
                  v95 = _mm_alignr_epi8(v92, v91, 3);
                  v96 = _mm_alignr_epi8(v91, v90, 3);
                  if ( v93 )
                    break;
                  v97 = _mm_alignr_epi8(v90, v77, 3);
                  v2 += 64LL;
                  v98 = _mm_alignr_epi8(v77, v76, 3);
                  v76 = v94;
                  *(__m128i *)(v3 + 48) = v95;
                  *(__m128i *)(v3 + 32) = v96;
                  *(__m128i *)(v3 + 16) = v97;
                  *(__m128i *)v3 = v98;
                  v3 += 64LL;
                }
              }
              v7 = 13LL;
              *(__m128i *)(v3 - 3) = _mm_loadu_si128((const __m128i *)(v2 - 3));
              break;
            case 4uLL:
              v99 = *(__m128i *)(v2 - 4);
              v100 = *(__m128i *)(v2 + 12);
              while ( 1 )
              {
                v101 = _mm_cmpeq_epi8(v5, v100);
                v6 = _mm_movemask_epi8(v101);
                v102 = v100;
                if ( v6 )
                  break;
                *(__m128i *)v3 = _mm_alignr_epi8(v100, v99, 4);
                v103 = *(__m128i *)(v2 + 28);
                v104 = _mm_cmpeq_epi8(v101, v103);
                v3 += 16LL;
                v6 = _mm_movemask_epi8(v104);
                v2 += 16LL;
                v105 = v103;
                if ( v6 )
                  break;
                *(__m128i *)v3 = _mm_alignr_epi8(v103, v102, 4);
                v106 = *(__m128i *)(v2 + 28);
                v107 = _mm_cmpeq_epi8(v104, v106);
                v3 += 16LL;
                v6 = _mm_movemask_epi8(v107);
                v2 += 16LL;
                v108 = v106;
                if ( v6 )
                  break;
                *(__m128i *)v3 = _mm_alignr_epi8(v106, v105, 4);
                v109 = *(__m128i *)(v2 + 28);
                v5 = _mm_cmpeq_epi8(v107, v109);
                v3 += 16LL;
                v6 = _mm_movemask_epi8(v5);
                v2 += 16LL;
                if ( v6 )
                  break;
                *(__m128i *)v3 = _mm_alignr_epi8(v109, v108, 4);
                v110 = v2 + 28;
                v111 = (v2 + 28) & 0xFFFFFFFFFFFFFFC0LL;
                v112 = v110 - v111;
                v2 = v111 - 12;
                v3 = v3 + 16 - v112;
                v99 = *(__m128i *)(v2 - 4);
                while ( 1 )
                {
                  v100 = *(__m128i *)(v2 + 12);
                  v113 = *(__m128i *)(v2 + 28);
                  v114 = *(__m128i *)(v2 + 44);
                  v115 = *(__m128i *)(v2 + 60);
                  v116 = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_min_epu8(_mm_min_epu8(v114, v115), _mm_min_epu8(v113, v100)), v5));
                  v117 = v115;
                  v118 = _mm_alignr_epi8(v115, v114, 4);
                  v119 = _mm_alignr_epi8(v114, v113, 4);
                  if ( v116 )
                    break;
                  v120 = _mm_alignr_epi8(v113, v100, 4);
                  v2 += 64LL;
                  v121 = _mm_alignr_epi8(v100, v99, 4);
                  v99 = v117;
                  *(__m128i *)(v3 + 48) = v118;
                  *(__m128i *)(v3 + 32) = v119;
                  *(__m128i *)(v3 + 16) = v120;
                  *(__m128i *)v3 = v121;
                  v3 += 64LL;
                }
              }
              v7 = 12LL;
              *(__m128i *)(v3 - 4) = _mm_loadu_si128((const __m128i *)(v2 - 4));
              break;
            case 5uLL:
              v122 = *(__m128i *)(v2 - 5);
              v123 = *(__m128i *)(v2 + 11);
              while ( 1 )
              {
                v124 = _mm_cmpeq_epi8(v5, v123);
                v6 = _mm_movemask_epi8(v124);
                v125 = v123;
                if ( v6 )
                  break;
                *(__m128i *)v3 = _mm_alignr_epi8(v123, v122, 5);
                v126 = *(__m128i *)(v2 + 27);
                v127 = _mm_cmpeq_epi8(v124, v126);
                v3 += 16LL;
                v6 = _mm_movemask_epi8(v127);
                v2 += 16LL;
                v128 = v126;
                if ( v6 )
                  break;
                *(__m128i *)v3 = _mm_alignr_epi8(v126, v125, 5);
                v129 = *(__m128i *)(v2 + 27);
                v130 = _mm_cmpeq_epi8(v127, v129);
                v3 += 16LL;
                v6 = _mm_movemask_epi8(v130);
                v2 += 16LL;
                v131 = v129;
                if ( v6 )
                  break;
                *(__m128i *)v3 = _mm_alignr_epi8(v129, v128, 5);
                v132 = *(__m128i *)(v2 + 27);
                v5 = _mm_cmpeq_epi8(v130, v132);
                v3 += 16LL;
                v6 = _mm_movemask_epi8(v5);
                v2 += 16LL;
                if ( v6 )
                  break;
                *(__m128i *)v3 = _mm_alignr_epi8(v132, v131, 5);
                v133 = v2 + 27;
                v134 = (v2 + 27) & 0xFFFFFFFFFFFFFFC0LL;
                v135 = v133 - v134;
                v2 = v134 - 11;
                v3 = v3 + 16 - v135;
                v122 = *(__m128i *)(v2 - 5);
                while ( 1 )
                {
                  v123 = *(__m128i *)(v2 + 11);
                  v136 = *(__m128i *)(v2 + 27);
                  v137 = *(__m128i *)(v2 + 43);
                  v138 = *(__m128i *)(v2 + 59);
                  v139 = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_min_epu8(_mm_min_epu8(v137, v138), _mm_min_epu8(v136, v123)), v5));
                  v140 = v138;
                  v141 = _mm_alignr_epi8(v138, v137, 5);
                  v142 = _mm_alignr_epi8(v137, v136, 5);
                  if ( v139 )
                    break;
                  v143 = _mm_alignr_epi8(v136, v123, 5);
                  v2 += 64LL;
                  v144 = _mm_alignr_epi8(v123, v122, 5);
                  v122 = v140;
                  *(__m128i *)(v3 + 48) = v141;
                  *(__m128i *)(v3 + 32) = v142;
                  *(__m128i *)(v3 + 16) = v143;
                  *(__m128i *)v3 = v144;
                  v3 += 64LL;
                }
              }
              v7 = 11LL;
              *(__m128i *)(v3 - 5) = _mm_loadu_si128((const __m128i *)(v2 - 5));
              break;
            case 6uLL:
              v145 = *(__m128i *)(v2 - 6);
              v146 = *(__m128i *)(v2 + 10);
              while ( 1 )
              {
                v147 = _mm_cmpeq_epi8(v5, v146);
                v6 = _mm_movemask_epi8(v147);
                v148 = v146;
                if ( v6 )
                  break;
                *(__m128i *)v3 = _mm_alignr_epi8(v146, v145, 6);
                v149 = *(__m128i *)(v2 + 26);
                v150 = _mm_cmpeq_epi8(v147, v149);
                v3 += 16LL;
                v6 = _mm_movemask_epi8(v150);
                v2 += 16LL;
                v151 = v149;
                if ( v6 )
                  break;
                *(__m128i *)v3 = _mm_alignr_epi8(v149, v148, 6);
                v152 = *(__m128i *)(v2 + 26);
                v153 = _mm_cmpeq_epi8(v150, v152);
                v3 += 16LL;
                v6 = _mm_movemask_epi8(v153);
                v2 += 16LL;
                v154 = v152;
                if ( v6 )
                  break;
                *(__m128i *)v3 = _mm_alignr_epi8(v152, v151, 6);
                v155 = *(__m128i *)(v2 + 26);
                v5 = _mm_cmpeq_epi8(v153, v155);
                v3 += 16LL;
                v6 = _mm_movemask_epi8(v5);
                v2 += 16LL;
                if ( v6 )
                  break;
                *(__m128i *)v3 = _mm_alignr_epi8(v155, v154, 6);
                v156 = v2 + 26;
                v157 = (v2 + 26) & 0xFFFFFFFFFFFFFFC0LL;
                v158 = v156 - v157;
                v2 = v157 - 10;
                v3 = v3 + 16 - v158;
                v145 = *(__m128i *)(v2 - 6);
                while ( 1 )
                {
                  v146 = *(__m128i *)(v2 + 10);
                  v159 = *(__m128i *)(v2 + 26);
                  v160 = *(__m128i *)(v2 + 42);
                  v161 = *(__m128i *)(v2 + 58);
                  v162 = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_min_epu8(_mm_min_epu8(v160, v161), _mm_min_epu8(v159, v146)), v5));
                  v163 = v161;
                  v164 = _mm_alignr_epi8(v161, v160, 6);
                  v165 = _mm_alignr_epi8(v160, v159, 6);
                  if ( v162 )
                    break;
                  v166 = _mm_alignr_epi8(v159, v146, 6);
                  v2 += 64LL;
                  v167 = _mm_alignr_epi8(v146, v145, 6);
                  v145 = v163;
                  *(__m128i *)(v3 + 48) = v164;
                  *(__m128i *)(v3 + 32) = v165;
                  *(__m128i *)(v3 + 16) = v166;
                  *(__m128i *)v3 = v167;
                  v3 += 64LL;
                }
              }
              v168 = *(_DWORD *)(v2 + 6);
              *(_QWORD *)v3 = *(_QWORD *)v2;
              *(_DWORD *)(v3 + 6) = v168;
              v7 = 10LL;
              break;
            default:
              v169 = *(__m128i *)(v2 - 7);
              v170 = *(__m128i *)(v2 + 9);
              while ( 1 )
              {
                v171 = _mm_cmpeq_epi8(v5, v170);
                v6 = _mm_movemask_epi8(v171);
                v172 = v170;
                if ( v6 )
                  break;
                *(__m128i *)v3 = _mm_alignr_epi8(v170, v169, 7);
                v173 = *(__m128i *)(v2 + 25);
                v174 = _mm_cmpeq_epi8(v171, v173);
                v3 += 16LL;
                v6 = _mm_movemask_epi8(v174);
                v2 += 16LL;
                v175 = v173;
                if ( v6 )
                  break;
                *(__m128i *)v3 = _mm_alignr_epi8(v173, v172, 7);
                v176 = *(__m128i *)(v2 + 25);
                v177 = _mm_cmpeq_epi8(v174, v176);
                v3 += 16LL;
                v6 = _mm_movemask_epi8(v177);
                v2 += 16LL;
                v178 = v176;
                if ( v6 )
                  break;
                *(__m128i *)v3 = _mm_alignr_epi8(v176, v175, 7);
                v179 = *(__m128i *)(v2 + 25);
                v5 = _mm_cmpeq_epi8(v177, v179);
                v3 += 16LL;
                v6 = _mm_movemask_epi8(v5);
                v2 += 16LL;
                if ( v6 )
                  break;
                *(__m128i *)v3 = _mm_alignr_epi8(v179, v178, 7);
                v180 = v2 + 25;
                v181 = (v2 + 25) & 0xFFFFFFFFFFFFFFC0LL;
                v182 = v180 - v181;
                v2 = v181 - 9;
                v3 = v3 + 16 - v182;
                v169 = *(__m128i *)(v2 - 7);
                while ( 1 )
                {
                  v170 = *(__m128i *)(v2 + 9);
                  v183 = *(__m128i *)(v2 + 25);
                  v184 = *(__m128i *)(v2 + 41);
                  v185 = *(__m128i *)(v2 + 57);
                  v186 = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_min_epu8(_mm_min_epu8(v184, v185), _mm_min_epu8(v183, v170)), v5));
                  v187 = v185;
                  v188 = _mm_alignr_epi8(v185, v184, 7);
                  v189 = _mm_alignr_epi8(v184, v183, 7);
                  if ( v186 )
                    break;
                  v190 = _mm_alignr_epi8(v183, v170, 7);
                  v2 += 64LL;
                  v191 = _mm_alignr_epi8(v170, v169, 7);
                  v169 = v187;
                  *(__m128i *)(v3 + 48) = v188;
                  *(__m128i *)(v3 + 32) = v189;
                  *(__m128i *)(v3 + 16) = v190;
                  *(__m128i *)v3 = v191;
                  v3 += 64LL;
                }
              }
              v192 = *(_DWORD *)(v2 + 5);
              *(_QWORD *)v3 = *(_QWORD *)v2;
              *(_DWORD *)(v3 + 5) = v192;
              v7 = 9LL;
              break;
          }
        }
      }
      else
      {
        v9 = *(__m128i *)(v2 + 16);
        *(_OWORD *)v3 = *(_OWORD *)v2;
        v10 = _mm_cmpeq_epi8(v5, v9);
        v6 = _mm_movemask_epi8(v10);
        v7 = 16LL;
        if ( !v6 )
        {
          v11 = *(__m128i *)(v2 + 32);
          *(__m128i *)(((unsigned __int64)(a1 + 2) & 0xFFFFFFFFFFFFFFF0LL) + 0x10) = v9;
          v12 = _mm_cmpeq_epi8(v10, v11);
          v6 = _mm_movemask_epi8(v12);
          v7 = 32LL;
          if ( !v6 )
          {
            v13 = *(__m128i *)(v2 + 48);
            *(__m128i *)(((unsigned __int64)(a1 + 2) & 0xFFFFFFFFFFFFFFF0LL) + 0x20) = v11;
            v14 = _mm_cmpeq_epi8(v12, v13);
            v6 = _mm_movemask_epi8(v14);
            v7 = 48LL;
            if ( !v6 )
            {
              v15 = *(__m128i *)(v2 + 64);
              *(__m128i *)(((unsigned __int64)(a1 + 2) & 0xFFFFFFFFFFFFFFF0LL) + 0x30) = v13;
              v16 = _mm_cmpeq_epi8(v14, v15);
              v6 = _mm_movemask_epi8(v16);
              v7 = 64LL;
              if ( !v6 )
              {
                v17 = *(__m128i *)(v2 + 80);
                *(__m128i *)(((unsigned __int64)(a1 + 2) & 0xFFFFFFFFFFFFFFF0LL) + 0x40) = v15;
                v18 = _mm_cmpeq_epi8(v16, v17);
                v6 = _mm_movemask_epi8(v18);
                v7 = 80LL;
                if ( !v6 )
                {
                  v19 = *(__m128i *)(v2 + 96);
                  *(__m128i *)(((unsigned __int64)(a1 + 2) & 0xFFFFFFFFFFFFFFF0LL) + 0x50) = v17;
                  v20 = _mm_cmpeq_epi8(v18, v19);
                  v6 = _mm_movemask_epi8(v20);
                  v7 = 96LL;
                  if ( !v6 )
                  {
                    *(__m128i *)(((unsigned __int64)(a1 + 2) & 0xFFFFFFFFFFFFFFF0LL) + 0x60) = v19;
                    v21 = v2;
                    v2 = (v2 + 112) & 0xFFFFFFFFFFFFFFC0LL;
                    v3 -= v21 - v2;
                    v7 = -64LL;
                    while ( 1 )
                    {
                      v22 = *(__m128i *)v2;
                      v23 = *(__m128i *)(v2 + 16);
                      v24 = *(__m128i *)(v2 + 32);
                      v25 = *(__m128i *)(v2 + 48);
                      v26 = _mm_movemask_epi8(
                              _mm_cmpeq_epi8(
                                _mm_min_epu8(_mm_min_epu8(v24, v25), _mm_min_epu8(*(__m128i *)v2, v23)),
                                v20));
                      v3 += 64LL;
                      v2 += 64LL;
                      if ( v26 )
                        break;
                      *(__m128i *)(v3 - 64) = v22;
                      *(__m128i *)(v3 - 48) = v23;
                      *(__m128i *)(v3 - 32) = v24;
                      *(__m128i *)(v3 - 16) = v25;
                    }
                    v27 = _mm_cmpeq_epi8(v20, v22);
                    v6 = _mm_movemask_epi8(v27);
                    if ( !v6 )
                    {
                      v28 = _mm_cmpeq_epi8(v27, v23);
                      v6 = _mm_movemask_epi8(v28);
                      *(__m128i *)(v3 - 64) = v22;
                      v7 = -48LL;
                      if ( !v6 )
                      {
                        v29 = _mm_cmpeq_epi8(v28, v24);
                        v6 = _mm_movemask_epi8(v29);
                        *(__m128i *)(v3 - 48) = v23;
                        v7 = -32LL;
                        if ( !v6 )
                        {
                          *(__m128i *)(v3 - 32) = v24;
                          LOWORD(v6) = _mm_movemask_epi8(_mm_cmpeq_epi8(v29, v25));
                          v7 = -16LL;
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    v3 += v7;
    v2 += v7;
    if ( (_BYTE)v6 )
    {
      if ( (v6 & 1) == 0 )
      {
        if ( (v6 & 2) == 0 )
        {
          if ( (v6 & 4) == 0 )
          {
            if ( (v6 & 8) == 0 )
            {
              if ( (v6 & 0x10) == 0 )
              {
                if ( (v6 & 0x20) == 0 )
                {
                  if ( (v6 & 0x40) == 0 )
                    goto LABEL_189;
                  goto LABEL_204;
                }
LABEL_203:
                *(_DWORD *)v3 = *(_DWORD *)v2;
                *(_WORD *)(v3 + 4) = *(_WORD *)(v2 + 4);
                return v3 + 5;
              }
LABEL_202:
              *(_DWORD *)v3 = *(_DWORD *)v2;
              *(_BYTE *)(v3 + 4) = *(_BYTE *)(v2 + 4);
              return v3 + 4;
            }
LABEL_201:
            *(_DWORD *)v3 = *(_DWORD *)v2;
            return v3 + 3;
          }
LABEL_200:
          *(_WORD *)v3 = *(_WORD *)v2;
          *(_BYTE *)(v3 + 2) = *(_BYTE *)(v2 + 2);
          return v3 + 2;
        }
LABEL_199:
        *(_WORD *)v3 = *(_WORD *)v2;
        return v3 + 1;
      }
LABEL_198:
      *(_BYTE *)v3 = *(_BYTE *)v2;
      return v3;
    }
    if ( (v6 & 0x100) == 0 )
    {
      if ( (v6 & 0x200) == 0 )
      {
        if ( (v6 & 0x400) == 0 )
        {
          if ( (v6 & 0x800) == 0 )
          {
            if ( (v6 & 0x1000) == 0 )
            {
              if ( (v6 & 0x2000) == 0 )
              {
                if ( (v6 & 0x4000) == 0 )
                  goto LABEL_197;
                goto LABEL_211;
              }
LABEL_210:
              *(_QWORD *)v3 = *(_QWORD *)v2;
              *(_QWORD *)(v3 + 6) = *(_QWORD *)(v2 + 6);
              return v3 + 13;
            }
LABEL_209:
            *(_QWORD *)v3 = *(_QWORD *)v2;
            *(_QWORD *)(v3 + 5) = *(_QWORD *)(v2 + 5);
            return v3 + 12;
          }
LABEL_208:
          *(_QWORD *)v3 = *(_QWORD *)v2;
          *(_DWORD *)(v3 + 8) = *(_DWORD *)(v2 + 8);
          return v3 + 11;
        }
LABEL_207:
        *(_QWORD *)v3 = *(_QWORD *)v2;
        *(_DWORD *)(v3 + 7) = *(_DWORD *)(v2 + 7);
        return v3 + 10;
      }
LABEL_206:
      *(_QWORD *)v3 = *(_QWORD *)v2;
      *(_DWORD *)(v3 + 6) = *(_DWORD *)(v2 + 6);
      return v3 + 9;
    }
LABEL_205:
    *(_QWORD *)v3 = *(_QWORD *)v2;
    *(_DWORD *)(v3 + 5) = *(_DWORD *)(v2 + 5);
    return v3 + 8;
  }
LABEL_211:
  *(_QWORD *)v3 = *(_QWORD *)v2;
  *(_QWORD *)(v3 + 7) = *(_QWORD *)(v2 + 7);
  return v3 + 14;
}

//----- (0000000000437D10) ----------------------------------------------------
__int64 __fastcall _strcpy_sse2_unaligned(__m128i *a1, const __m128i *a2)
{
  unsigned __int64 v2; // rcx
  unsigned __int64 v3; // rsi
  unsigned __int64 v4; // rcx
  unsigned __int64 v5; // rdx
  __m128i v6; // xmm0
  __int64 v7; // rdx
  __m128i *v8; // rdi
  __m128i v9; // xmm2
  __m128i v10; // xmm0
  unsigned __int64 v11; // rdx
  __int64 v12; // rcx
  __m128i v13; // xmm3
  __m128i v14; // xmm0
  __m128i v15; // xmm4
  __m128i v16; // xmm0
  __m128i v17; // xmm1
  __m128i v18; // xmm0
  __m128i v19; // xmm2
  __m128i v20; // xmm0
  __m128i v21; // xmm3
  __m128i v22; // xmm0
  unsigned __int64 v23; // rdx
  unsigned __int64 v24; // rsi
  __m128i *v25; // rdi
  __m128i v26; // xmm4
  __m128i v27; // xmm5
  __m128i v28; // xmm6
  __m128i v29; // xmm7
  __m128i v30; // xmm2
  __m128i i; // xmm3
  __m128i v32; // xmm3
  __m128i v33; // xmm0
  __m128i v34; // xmm1
  __int64 v35; // rdx
  unsigned int v36; // ecx
  __int64 v37; // rdx
  unsigned int v38; // ecx
  unsigned __int64 v39; // rdx
  __m128i v41; // xmm1
  __m128i v42; // xmm2
  unsigned __int64 v43; // rdx
  unsigned __int64 v44; // rdx

  v2 = (unsigned __int8)a2 & 0x3F;
  if ( v2 <= 0x20 )
  {
    v41 = _mm_loadu_si128(a2);
    v42 = _mm_loadu_si128(a2 + 1);
    v6 = _mm_cmpeq_epi8((__m128i)0LL, v41);
    v43 = (unsigned int)_mm_movemask_epi8(v6);
    if ( !(_DWORD)v43 )
    {
      v6 = _mm_cmpeq_epi8(v6, v42);
      *a1 = v41;
      v43 = (unsigned int)_mm_movemask_epi8(v6);
      if ( !(_DWORD)v43 )
      {
        v3 = (unsigned __int64)a2 & 0xFFFFFFFFFFFFFFF0LL;
        v4 = v2 & 0xF;
        goto LABEL_5;
      }
      ++a2;
      ++a1;
    }
    _BitScanForward64(&v43, v43);
    return ((__int64 (__fastcall *)(__m128i *, const __m128i *, double, double, double))((char *)dword_482CF0
                                                                                       + dword_482CF0[v43]))(
             a1,
             a2,
             *(double *)v6.m128i_i64,
             *(double *)v41.m128i_i64,
             *(double *)v42.m128i_i64);
  }
  v3 = (unsigned __int64)a2 & 0xFFFFFFFFFFFFFFF0LL;
  v4 = v2 & 0xF;
  v5 = (unsigned int)_mm_movemask_epi8(_mm_cmpeq_epi8((__m128i)0LL, *(__m128i *)v3)) >> v4;
  if ( v5 )
  {
    _BitScanForward64(&v5, v5);
    return ((__int64 (__fastcall *)(__m128i *, unsigned __int64, double))((char *)dword_482CF0 + dword_482CF0[v5]))(
             a1,
             v4 + v3,
             0.0);
  }
  v6 = _mm_cmpeq_epi8((__m128i)0LL, *(__m128i *)(v3 + 16));
  LODWORD(v7) = _mm_movemask_epi8(v6);
  if ( (_DWORD)v7 )
  {
    _BitScanForward64((unsigned __int64 *)&v7, (unsigned int)v7);
    return ((__int64 (__fastcall *)(__m128i *, unsigned __int64))((char *)dword_482CF0 + dword_482CF0[v7 + 16 - v4]))(
             a1,
             v4 + v3);
  }
  *a1 = _mm_loadu_si128((const __m128i *)(v3 + v4));
LABEL_5:
  v8 = (__m128i *)((char *)a1 - v4);
  v9 = *(__m128i *)(v3 + 32);
  v8[1] = _mm_load_si128((const __m128i *)(v3 + 16));
  v10 = _mm_cmpeq_epi8(v6, v9);
  v11 = (unsigned int)_mm_movemask_epi8(v10);
  v12 = 2LL;
  if ( (_DWORD)v11 )
    goto LABEL_20;
  v13 = *(__m128i *)(v3 + 48);
  v8[2] = v9;
  v14 = _mm_cmpeq_epi8(v10, v13);
  v11 = (unsigned int)_mm_movemask_epi8(v14);
  v12 = 3LL;
  if ( (_DWORD)v11 )
    goto LABEL_20;
  v15 = *(__m128i *)(v3 + 64);
  v8[3] = v13;
  v16 = _mm_cmpeq_epi8(v14, v15);
  v11 = (unsigned int)_mm_movemask_epi8(v16);
  v12 = 4LL;
  if ( (_DWORD)v11 )
    goto LABEL_20;
  v17 = *(__m128i *)(v3 + 80);
  v8[4] = v15;
  v18 = _mm_cmpeq_epi8(v16, v17);
  v11 = (unsigned int)_mm_movemask_epi8(v18);
  v12 = 5LL;
  if ( (_DWORD)v11 )
    goto LABEL_20;
  v19 = *(__m128i *)(v3 + 96);
  v8[5] = v17;
  v20 = _mm_cmpeq_epi8(v18, v19);
  v11 = (unsigned int)_mm_movemask_epi8(v20);
  v12 = 6LL;
  if ( (_DWORD)v11
    || (v21 = *(__m128i *)(v3 + 112),
        v8[6] = v19,
        v22 = _mm_cmpeq_epi8(v20, v21),
        v11 = (unsigned int)_mm_movemask_epi8(v22),
        v12 = 7LL,
        (_DWORD)v11) )
  {
LABEL_20:
    _BitScanForward64(&v11, v11);
    return ((__int64 (__fastcall *)(__m128i *, unsigned __int64))((char *)dword_482CF0 + dword_482CF0[v11]))(
             &v8[v12],
             v12 * 16 + v3);
  }
  else
  {
    v8[7] = v21;
    v23 = v3;
    v24 = (v3 + 128) & 0xFFFFFFFFFFFFFFC0LL;
    v25 = (__m128i *)((char *)v8 - (v23 - v24));
    v26 = *(__m128i *)v24;
    v27 = *(__m128i *)(v24 + 16);
    v28 = *(__m128i *)(v24 + 32);
    v29 = *(__m128i *)(v24 + 48);
    v30 = _mm_min_epu8(*(__m128i *)v24, v27);
    for ( i = _mm_cmpeq_epi8(_mm_min_epu8(_mm_min_epu8(v28, v29), v30), v22);
          !_mm_movemask_epi8(i);
          i = _mm_cmpeq_epi8(_mm_min_epu8(_mm_min_epu8(v32, v29), v30), v22) )
    {
      v25 += 4;
      v24 += 64LL;
      v25[-4] = v26;
      v26 = *(__m128i *)v24;
      v25[-3] = v27;
      v27 = *(__m128i *)(v24 + 16);
      v30 = _mm_min_epu8(v26, v27);
      v32 = *(__m128i *)(v24 + 32);
      v25[-2] = v28;
      v28 = v32;
      v25[-1] = v29;
      v29 = *(__m128i *)(v24 + 48);
    }
    v33 = _mm_cmpeq_epi8(v22, v26);
    v34 = _mm_cmpeq_epi8((__m128i)0LL, v27);
    LODWORD(v35) = _mm_movemask_epi8(v33);
    v36 = _mm_movemask_epi8(v34);
    if ( (_DWORD)v35 )
    {
      _BitScanForward64((unsigned __int64 *)&v35, (unsigned int)v35);
      return ((__int64 (__fastcall *)(__m128i *, double, double, double, double, double, double, double))((char *)dword_482CF0 + dword_482CF0[v35]))(
               v25,
               *(double *)v33.m128i_i64,
               *(double *)v34.m128i_i64,
               *(double *)v30.m128i_i64,
               *(double *)i.m128i_i64,
               *(double *)v26.m128i_i64,
               *(double *)v27.m128i_i64,
               *(double *)v28.m128i_i64);
    }
    else if ( v36 )
    {
      _BitScanForward64(&v44, v36);
      *v25 = v26;
      return ((__int64 (__fastcall *)(__m128i *, unsigned __int64, double, double, double, double, double, double, double))((char *)dword_482CF0 + dword_482CF0[v44]))(
               &v25[1],
               v24 + 16,
               *(double *)v33.m128i_i64,
               *(double *)v34.m128i_i64,
               *(double *)v30.m128i_i64,
               *(double *)i.m128i_i64,
               *(double *)v26.m128i_i64,
               *(double *)v27.m128i_i64,
               *(double *)v28.m128i_i64);
    }
    else
    {
      LODWORD(v37) = _mm_movemask_epi8(_mm_cmpeq_epi8(v33, v28));
      v38 = _mm_movemask_epi8(_mm_cmpeq_epi8(v34, v29));
      if ( (_DWORD)v37 )
      {
        _BitScanForward64((unsigned __int64 *)&v37, (unsigned int)v37);
        *v25 = v26;
        v25[1] = v27;
        return ((__int64 (__fastcall *)(__m128i *, unsigned __int64))((char *)dword_482CF0 + dword_482CF0[v37]))(
                 &v25[2],
                 v24 + 32);
      }
      else
      {
        _BitScanForward64(&v39, v38);
        *v25 = v26;
        v25[1] = v27;
        v25[2] = v28;
        return ((__int64 (__fastcall *)(__m128i *, unsigned __int64))((char *)dword_482CF0 + dword_482CF0[v39]))(
                 &v25[3],
                 v24 + 48);
      }
    }
  }
}
// 482CF0: using guessed type int dword_482CF0[32];

//----- (0000000000438340) ----------------------------------------------------
__int64 __fastcall _stpcpy_sse2_unaligned(__m128i *a1, const __m128i *a2)
{
  unsigned __int64 v2; // rcx
  unsigned __int64 v3; // rsi
  unsigned __int64 v4; // rcx
  unsigned __int64 v5; // rdx
  __m128i v6; // xmm0
  __int64 v7; // rdx
  __m128i *v8; // rdi
  __m128i v9; // xmm2
  __m128i v10; // xmm0
  unsigned __int64 v11; // rdx
  __int64 v12; // rcx
  __m128i v13; // xmm3
  __m128i v14; // xmm0
  __m128i v15; // xmm4
  __m128i v16; // xmm0
  __m128i v17; // xmm1
  __m128i v18; // xmm0
  __m128i v19; // xmm2
  __m128i v20; // xmm0
  __m128i v21; // xmm3
  __m128i v22; // xmm0
  unsigned __int64 v23; // rdx
  unsigned __int64 v24; // rsi
  __m128i *v25; // rdi
  __m128i v26; // xmm4
  __m128i v27; // xmm5
  __m128i v28; // xmm6
  __m128i v29; // xmm7
  __m128i v30; // xmm2
  __m128i i; // xmm3
  __m128i v32; // xmm3
  __m128i v33; // xmm0
  __m128i v34; // xmm1
  __int64 v35; // rdx
  unsigned int v36; // ecx
  __int64 v37; // rdx
  unsigned int v38; // ecx
  unsigned __int64 v39; // rdx
  __m128i v41; // xmm1
  __m128i v42; // xmm2
  unsigned __int64 v43; // rdx
  unsigned __int64 v44; // rdx

  v2 = (unsigned __int8)a2 & 0x3F;
  if ( v2 <= 0x20 )
  {
    v41 = _mm_loadu_si128(a2);
    v42 = _mm_loadu_si128(a2 + 1);
    v6 = _mm_cmpeq_epi8((__m128i)0LL, v41);
    v43 = (unsigned int)_mm_movemask_epi8(v6);
    if ( !(_DWORD)v43 )
    {
      v6 = _mm_cmpeq_epi8(v6, v42);
      *a1 = v41;
      v43 = (unsigned int)_mm_movemask_epi8(v6);
      if ( !(_DWORD)v43 )
      {
        v3 = (unsigned __int64)a2 & 0xFFFFFFFFFFFFFFF0LL;
        v4 = v2 & 0xF;
        goto LABEL_5;
      }
      ++a2;
      ++a1;
    }
    _BitScanForward64(&v43, v43);
    return ((__int64 (__fastcall *)(__m128i *, const __m128i *, double, double, double))((char *)dword_482D70
                                                                                       + dword_482D70[v43]))(
             a1,
             a2,
             *(double *)v6.m128i_i64,
             *(double *)v41.m128i_i64,
             *(double *)v42.m128i_i64);
  }
  v3 = (unsigned __int64)a2 & 0xFFFFFFFFFFFFFFF0LL;
  v4 = v2 & 0xF;
  v5 = (unsigned int)_mm_movemask_epi8(_mm_cmpeq_epi8((__m128i)0LL, *(__m128i *)v3)) >> v4;
  if ( v5 )
  {
    _BitScanForward64(&v5, v5);
    return ((__int64 (__fastcall *)(__m128i *, unsigned __int64, double))((char *)dword_482D70 + dword_482D70[v5]))(
             a1,
             v4 + v3,
             0.0);
  }
  v6 = _mm_cmpeq_epi8((__m128i)0LL, *(__m128i *)(v3 + 16));
  LODWORD(v7) = _mm_movemask_epi8(v6);
  if ( (_DWORD)v7 )
  {
    _BitScanForward64((unsigned __int64 *)&v7, (unsigned int)v7);
    return ((__int64 (__fastcall *)(__m128i *, unsigned __int64))((char *)dword_482D70 + dword_482D70[v7 + 16 - v4]))(
             a1,
             v4 + v3);
  }
  *a1 = _mm_loadu_si128((const __m128i *)(v3 + v4));
LABEL_5:
  v8 = (__m128i *)((char *)a1 - v4);
  v9 = *(__m128i *)(v3 + 32);
  v8[1] = _mm_load_si128((const __m128i *)(v3 + 16));
  v10 = _mm_cmpeq_epi8(v6, v9);
  v11 = (unsigned int)_mm_movemask_epi8(v10);
  v12 = 2LL;
  if ( (_DWORD)v11 )
    goto LABEL_20;
  v13 = *(__m128i *)(v3 + 48);
  v8[2] = v9;
  v14 = _mm_cmpeq_epi8(v10, v13);
  v11 = (unsigned int)_mm_movemask_epi8(v14);
  v12 = 3LL;
  if ( (_DWORD)v11 )
    goto LABEL_20;
  v15 = *(__m128i *)(v3 + 64);
  v8[3] = v13;
  v16 = _mm_cmpeq_epi8(v14, v15);
  v11 = (unsigned int)_mm_movemask_epi8(v16);
  v12 = 4LL;
  if ( (_DWORD)v11 )
    goto LABEL_20;
  v17 = *(__m128i *)(v3 + 80);
  v8[4] = v15;
  v18 = _mm_cmpeq_epi8(v16, v17);
  v11 = (unsigned int)_mm_movemask_epi8(v18);
  v12 = 5LL;
  if ( (_DWORD)v11 )
    goto LABEL_20;
  v19 = *(__m128i *)(v3 + 96);
  v8[5] = v17;
  v20 = _mm_cmpeq_epi8(v18, v19);
  v11 = (unsigned int)_mm_movemask_epi8(v20);
  v12 = 6LL;
  if ( (_DWORD)v11
    || (v21 = *(__m128i *)(v3 + 112),
        v8[6] = v19,
        v22 = _mm_cmpeq_epi8(v20, v21),
        v11 = (unsigned int)_mm_movemask_epi8(v22),
        v12 = 7LL,
        (_DWORD)v11) )
  {
LABEL_20:
    _BitScanForward64(&v11, v11);
    return ((__int64 (__fastcall *)(__m128i *, unsigned __int64))((char *)dword_482D70 + dword_482D70[v11]))(
             &v8[v12],
             v12 * 16 + v3);
  }
  else
  {
    v8[7] = v21;
    v23 = v3;
    v24 = (v3 + 128) & 0xFFFFFFFFFFFFFFC0LL;
    v25 = (__m128i *)((char *)v8 - (v23 - v24));
    v26 = *(__m128i *)v24;
    v27 = *(__m128i *)(v24 + 16);
    v28 = *(__m128i *)(v24 + 32);
    v29 = *(__m128i *)(v24 + 48);
    v30 = _mm_min_epu8(*(__m128i *)v24, v27);
    for ( i = _mm_cmpeq_epi8(_mm_min_epu8(_mm_min_epu8(v28, v29), v30), v22);
          !_mm_movemask_epi8(i);
          i = _mm_cmpeq_epi8(_mm_min_epu8(_mm_min_epu8(v32, v29), v30), v22) )
    {
      v25 += 4;
      v24 += 64LL;
      v25[-4] = v26;
      v26 = *(__m128i *)v24;
      v25[-3] = v27;
      v27 = *(__m128i *)(v24 + 16);
      v30 = _mm_min_epu8(v26, v27);
      v32 = *(__m128i *)(v24 + 32);
      v25[-2] = v28;
      v28 = v32;
      v25[-1] = v29;
      v29 = *(__m128i *)(v24 + 48);
    }
    v33 = _mm_cmpeq_epi8(v22, v26);
    v34 = _mm_cmpeq_epi8((__m128i)0LL, v27);
    LODWORD(v35) = _mm_movemask_epi8(v33);
    v36 = _mm_movemask_epi8(v34);
    if ( (_DWORD)v35 )
    {
      _BitScanForward64((unsigned __int64 *)&v35, (unsigned int)v35);
      return ((__int64 (__fastcall *)(__m128i *, double, double, double, double, double, double, double))((char *)dword_482D70 + dword_482D70[v35]))(
               v25,
               *(double *)v33.m128i_i64,
               *(double *)v34.m128i_i64,
               *(double *)v30.m128i_i64,
               *(double *)i.m128i_i64,
               *(double *)v26.m128i_i64,
               *(double *)v27.m128i_i64,
               *(double *)v28.m128i_i64);
    }
    else if ( v36 )
    {
      _BitScanForward64(&v44, v36);
      *v25 = v26;
      return ((__int64 (__fastcall *)(__m128i *, unsigned __int64, double, double, double, double, double, double, double))((char *)dword_482D70 + dword_482D70[v44]))(
               &v25[1],
               v24 + 16,
               *(double *)v33.m128i_i64,
               *(double *)v34.m128i_i64,
               *(double *)v30.m128i_i64,
               *(double *)i.m128i_i64,
               *(double *)v26.m128i_i64,
               *(double *)v27.m128i_i64,
               *(double *)v28.m128i_i64);
    }
    else
    {
      LODWORD(v37) = _mm_movemask_epi8(_mm_cmpeq_epi8(v33, v28));
      v38 = _mm_movemask_epi8(_mm_cmpeq_epi8(v34, v29));
      if ( (_DWORD)v37 )
      {
        _BitScanForward64((unsigned __int64 *)&v37, (unsigned int)v37);
        *v25 = v26;
        v25[1] = v27;
        return ((__int64 (__fastcall *)(__m128i *, unsigned __int64))((char *)dword_482D70 + dword_482D70[v37]))(
                 &v25[2],
                 v24 + 32);
      }
      else
      {
        _BitScanForward64(&v39, v38);
        *v25 = v26;
        v25[1] = v27;
        v25[2] = v28;
        return ((__int64 (__fastcall *)(__m128i *, unsigned __int64))((char *)dword_482D70 + dword_482D70[v39]))(
                 &v25[3],
                 v24 + 48);
      }
    }
  }
}
// 482D70: using guessed type int dword_482D70[32];

//----- (0000000000438A00) ----------------------------------------------------
const __m128i *__fastcall _strchr_sse2_no_bsf(__int64 a1, unsigned int a2)
{
  __m128i v2; // xmm1
  __m128i v3; // xmm1
  __m128i v4; // xmm1
  char v5; // cl
  __m128i si128; // xmm3
  const __m128i *v7; // rdi
  int v8; // eax
  int v9; // edx
  __m128i v10; // xmm0
  __m128i v11; // xmm3
  const __m128i *v13; // rdi

  v2 = _mm_cvtsi32_si128(a2);
  v3 = _mm_unpacklo_epi8(v2, v2);
  v4 = _mm_shuffle_epi32(_mm_unpacklo_epi8(v3, v3), 0);
  v5 = a1 - (a1 & 0xF0);
  si128 = _mm_load_si128((const __m128i *)(a1 & 0xFFFFFFFFFFFFFFF0LL));
  v7 = (const __m128i *)((a1 & 0xFFFFFFFFFFFFFFF0LL) + 16);
  v8 = (-1 << v5) & _mm_movemask_epi8(_mm_cmpeq_epi8(si128, v4));
  v9 = (-1 << v5) & _mm_movemask_epi8(_mm_cmpeq_epi8(si128, (__m128i)0LL));
  if ( !v8 )
  {
    if ( v9 )
      return 0LL;
    do
    {
      v10 = _mm_load_si128(v7++);
      v11 = _mm_cmpeq_epi8(v10, (__m128i)0LL);
      v8 = _mm_movemask_epi8(_mm_cmpeq_epi8(v10, v4));
    }
    while ( !(v8 | _mm_movemask_epi8(v11)) );
    v9 = _mm_movemask_epi8(v11);
    if ( !v8 )
      return 0LL;
  }
  v13 = v7 - 1;
  if ( !v9 )
  {
    if ( (_BYTE)v8 )
    {
      if ( (v8 & 1) == 0 )
      {
        if ( (v8 & 2) == 0 )
        {
          if ( (v8 & 4) == 0 )
          {
            if ( (v8 & 8) != 0 )
              return (const __m128i *)&v13->m128i_i8[3];
            if ( (v8 & 0x10) == 0 )
            {
              if ( (v8 & 0x20) == 0 )
              {
                if ( (v8 & 0x40) == 0 )
                  return (const __m128i *)&v13->m128i_i8[7];
                return (const __m128i *)&v13->m128i_i8[6];
              }
              return (const __m128i *)&v13->m128i_i8[5];
            }
            return (const __m128i *)&v13->m128i_i8[4];
          }
          return (const __m128i *)&v13->m128i_i8[2];
        }
        return (const __m128i *)&v13->m128i_i8[1];
      }
      return v13;
    }
    if ( (v8 & 0x100) == 0 )
    {
      if ( (v8 & 0x200) == 0 )
      {
        if ( (v8 & 0x400) == 0 )
        {
          if ( (v8 & 0x800) != 0 )
            return (const __m128i *)&v13->m128i_i8[11];
          if ( (v8 & 0x1000) == 0 )
          {
            if ( (v8 & 0x2000) == 0 )
            {
              if ( (v8 & 0x4000) == 0 )
                return (const __m128i *)&v13->m128i_i8[15];
              return (const __m128i *)&v13->m128i_i8[14];
            }
            return (const __m128i *)&v13->m128i_i8[13];
          }
          return (const __m128i *)&v13->m128i_i8[12];
        }
        return (const __m128i *)&v13->m128i_i8[10];
      }
      return (const __m128i *)&v13->m128i_i8[9];
    }
    return (const __m128i *)&v13->m128i_i8[8];
  }
  if ( !(_BYTE)v8 )
  {
    if ( (_BYTE)v9 )
      return 0LL;
    if ( (v8 & 0xF00) == 0 )
    {
      if ( (v9 & 0xF00) != 0 )
        return 0LL;
      if ( (v8 & 0x1000) == 0 )
      {
        if ( (v9 & 0x1000) != 0 )
          return 0LL;
        if ( (v8 & 0x2000) == 0 )
        {
          if ( (v9 & 0x2000) != 0 )
            return 0LL;
          if ( (v8 & 0x4000) == 0 )
          {
            if ( (v9 & 0x4000) != 0 )
              return 0LL;
            return (const __m128i *)&v13->m128i_i8[15];
          }
          return (const __m128i *)&v13->m128i_i8[14];
        }
        return (const __m128i *)&v13->m128i_i8[13];
      }
      return (const __m128i *)&v13->m128i_i8[12];
    }
    if ( (v8 & 0x100) == 0 )
    {
      if ( (v9 & 0x100) != 0 )
        return 0LL;
      if ( (v8 & 0x200) == 0 )
      {
        if ( (v9 & 0x200) != 0 )
          return 0LL;
        if ( (v8 & 0x400) == 0 )
        {
          if ( (v9 & 0x400) != 0 )
            return 0LL;
          return (const __m128i *)&v13->m128i_i8[11];
        }
        return (const __m128i *)&v13->m128i_i8[10];
      }
      return (const __m128i *)&v13->m128i_i8[9];
    }
    return (const __m128i *)&v13->m128i_i8[8];
  }
  if ( (v8 & 0xF) == 0 )
  {
    if ( (v9 & 0xF) != 0 )
      return 0LL;
    if ( (v8 & 0x10) == 0 )
    {
      if ( (v9 & 0x10) != 0 )
        return 0LL;
      if ( (v8 & 0x20) == 0 )
      {
        if ( (v9 & 0x20) != 0 )
          return 0LL;
        if ( (v8 & 0x40) == 0 )
        {
          if ( (v9 & 0x40) == 0 )
            return (const __m128i *)&v13->m128i_i8[7];
          return 0LL;
        }
        return (const __m128i *)&v13->m128i_i8[6];
      }
      return (const __m128i *)&v13->m128i_i8[5];
    }
    return (const __m128i *)&v13->m128i_i8[4];
  }
  if ( (v8 & 1) != 0 )
    return v13;
  if ( (v9 & 1) != 0 )
    return 0LL;
  if ( (v8 & 2) != 0 )
    return (const __m128i *)&v13->m128i_i8[1];
  if ( (v9 & 2) != 0 )
    return 0LL;
  if ( (v8 & 4) != 0 )
    return (const __m128i *)&v13->m128i_i8[2];
  if ( (v9 & 4) != 0 )
    return 0LL;
  return (const __m128i *)&v13->m128i_i8[3];
}

//----- (0000000000438D20) ----------------------------------------------------
__int64 __fastcall _memcmp_ssse3(const __m128i *a1, const __m128i *a2, unsigned __int64 a3)
{
  __int64 v3; // rcx
  __int8 *v4; // rsi
  __int8 *v5; // rdi
  int v6; // edx
  unsigned __int64 v7; // rdi
  const __m128i *v8; // rsi
  int v9; // edx
  unsigned __int64 v10; // rdx
  __m128i *v11; // rsi
  unsigned __int64 v12; // rcx
  __int64 v13; // rdx
  __int64 v14; // rax
  __m128i v15; // xmm1
  int v16; // edx
  __m128i v17; // xmm0
  __m128i v18; // xmm2
  __m128i v19; // xmm2
  __m128i si128; // xmm2
  int v21; // edx
  __m128i v22; // xmm0
  __m128i v23; // xmm3
  int v24; // edx
  __m128i v25; // xmm3
  __m128i v26; // xmm3
  __m128i v27; // xmm2
  int v28; // edx
  __m128i v29; // xmm0
  __m128i v30; // xmm3
  int v31; // edx
  __m128i v32; // xmm3
  __m128i v33; // xmm3
  __m128i v34; // xmm2
  int v35; // edx
  __m128i v36; // xmm0
  __m128i v37; // xmm3
  int v38; // edx
  __m128i v39; // xmm3
  __m128i v40; // xmm3
  __m128i v41; // xmm2
  int v42; // edx
  __m128i v43; // xmm0
  __m128i v44; // xmm3
  int v45; // edx
  __m128i v46; // xmm3
  __m128i v47; // xmm3
  __m128i v48; // xmm2
  int v49; // edx
  __m128i v50; // xmm0
  __m128i v51; // xmm3
  int v52; // edx
  __m128i v53; // xmm3
  __m128i v54; // xmm3
  __m128i v55; // xmm2
  int v56; // edx
  __m128i v57; // xmm0
  __m128i v58; // xmm3
  int v59; // edx
  __m128i v60; // xmm3
  __m128i v61; // xmm3
  __m128i v62; // xmm2
  int v63; // edx
  __m128i v64; // xmm0
  __m128i v65; // xmm3
  int v66; // edx
  __m128i v67; // xmm3
  __m128i v68; // xmm3
  __m128i v69; // xmm2
  int v70; // edx
  __m128i v71; // xmm0
  __m128i v72; // xmm3
  int v73; // edx
  __m128i v74; // xmm3
  __m128i v75; // xmm3
  __m128i v76; // xmm2
  int v77; // edx
  __m128i v78; // xmm0
  __m128i v79; // xmm3
  int v80; // edx
  __m128i v81; // xmm3
  __m128i v82; // xmm3
  __m128i v83; // xmm2
  int v84; // edx
  __m128i v85; // xmm0
  __m128i v86; // xmm3
  int v87; // edx
  __m128i v88; // xmm3
  __m128i v89; // xmm3
  __m128i v90; // xmm2
  int v91; // edx
  __m128i v92; // xmm0
  __m128i v93; // xmm3
  int v94; // edx
  __m128i v95; // xmm3
  __m128i v96; // xmm3
  __m128i v97; // xmm2
  int v98; // edx
  __m128i v99; // xmm0
  __m128i v100; // xmm3
  int v101; // edx
  __m128i v102; // xmm3
  __m128i v103; // xmm3
  __m128i v104; // xmm2
  int v105; // edx
  __m128i v106; // xmm0
  __m128i v107; // xmm3
  int v108; // edx
  __m128i v109; // xmm3
  __m128i v110; // xmm3
  __m128i v111; // xmm2
  int v112; // edx
  __m128i v113; // xmm0
  __m128i v114; // xmm3
  int v115; // edx
  __m128i v116; // xmm3
  __m128i v117; // xmm3
  __m128i v118; // xmm2
  int v119; // edx
  __m128i v120; // xmm0
  __m128i v121; // xmm3
  int v122; // edx
  __m128i v123; // xmm3
  __m128i v124; // xmm3
  int v125; // er8
  unsigned int v127; // eax
  unsigned int v128; // ecx
  unsigned __int8 v129; // al
  bool v130; // cf
  unsigned int v131; // eax
  unsigned int v132; // ecx
  unsigned int v133; // eax
  unsigned int v134; // ecx
  unsigned __int8 v135; // al
  unsigned int v136; // eax
  unsigned int v137; // ecx

  v3 = a3;
  if ( a3 < 0x30 )
  {
    v4 = &a2->m128i_i8[a3];
    v5 = &a1->m128i_i8[a3];
    goto LABEL_209;
  }
  v6 = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_loadu_si128(a1), _mm_loadu_si128(a2)));
  v7 = (unsigned __int64)&a1[1];
  v8 = a2 + 1;
  v9 = v6 - 0xFFFF;
  if ( v9 )
  {
LABEL_185:
    if ( (_BYTE)v9 )
    {
      if ( (v9 & 1) == 0 )
      {
        if ( (v9 & 2) == 0 )
        {
          if ( (v9 & 4) == 0 )
          {
            if ( (v9 & 8) == 0 )
            {
              if ( (v9 & 0x10) == 0 )
              {
                if ( (v9 & 0x20) == 0 )
                {
                  if ( (v9 & 0x40) == 0 )
                    return *(unsigned __int8 *)(v7 - 9) - (unsigned int)v8[-1].m128i_u8[7];
                  return *(unsigned __int8 *)(v7 - 10) - (unsigned int)v8[-1].m128i_u8[6];
                }
                return *(unsigned __int8 *)(v7 - 11) - (unsigned int)v8[-1].m128i_u8[5];
              }
              return *(unsigned __int8 *)(v7 - 12) - (unsigned int)v8[-1].m128i_u8[4];
            }
            return *(unsigned __int8 *)(v7 - 13) - (unsigned int)v8[-1].m128i_u8[3];
          }
          return *(unsigned __int8 *)(v7 - 14) - (unsigned int)v8[-1].m128i_u8[2];
        }
        return *(unsigned __int8 *)(v7 - 15) - (unsigned int)v8[-1].m128i_u8[1];
      }
    }
    else
    {
      v7 += 8LL;
      v8 = (const __m128i *)((char *)v8 + 8);
      if ( (v9 & 0x100) == 0 )
      {
        if ( (v9 & 0x200) == 0 )
        {
          if ( (v9 & 0x400) == 0 )
          {
            if ( (v9 & 0x800) == 0 )
            {
              if ( (v9 & 0x1000) == 0 )
              {
                if ( (v9 & 0x2000) == 0 )
                {
                  if ( (v9 & 0x4000) == 0 )
                    return *(unsigned __int8 *)(v7 - 9) - (unsigned int)v8[-1].m128i_u8[7];
                  return *(unsigned __int8 *)(v7 - 10) - (unsigned int)v8[-1].m128i_u8[6];
                }
                return *(unsigned __int8 *)(v7 - 11) - (unsigned int)v8[-1].m128i_u8[5];
              }
              return *(unsigned __int8 *)(v7 - 12) - (unsigned int)v8[-1].m128i_u8[4];
            }
            return *(unsigned __int8 *)(v7 - 13) - (unsigned int)v8[-1].m128i_u8[3];
          }
          return *(unsigned __int8 *)(v7 - 14) - (unsigned int)v8[-1].m128i_u8[2];
        }
        return *(unsigned __int8 *)(v7 - 15) - (unsigned int)v8[-1].m128i_u8[1];
      }
    }
    return *(unsigned __int8 *)(v7 - 16) - (unsigned int)v8[-1].m128i_u8[0];
  }
  v10 = v7 & 0xF;
  v7 ^= v10;
  v11 = (__m128i *)((char *)v8 - v10);
  v12 = v10 + v3;
  v13 = (unsigned __int8)v11 & 0xF;
  if ( ((unsigned __int8)v11 & 0xF) == 0 )
    goto LABEL_22;
  v11 = (__m128i *)(v13 ^ (unsigned __int64)v11);
  if ( (unsigned int)v13 < 8 )
  {
    if ( (_DWORD)v13 )
    {
      switch ( (_DWORD)v13 )
      {
        case 1:
          v130 = v12 < 0x50;
          v3 = v12 - 48;
          v14 = 1LL;
          if ( v130 )
          {
            si128 = _mm_load_si128(v11 + 1);
            v15 = _mm_cmpeq_epi8(_mm_alignr_epi8(si128, *v11, 1), *(__m128i *)v7);
            v21 = _mm_movemask_epi8(
                    _mm_and_si128(
                      _mm_cmpeq_epi8(_mm_alignr_epi8(_mm_load_si128(v11 + 2), si128, 1), *(__m128i *)(v7 + 16)),
                      v15));
            v7 += 32LL;
            v11 += 2;
            v9 = v21 - 0xFFFF;
            if ( !v9 )
            {
              v4 = &v11->m128i_i8[v3 + 1];
              v5 = (__int8 *)(v3 + v7);
              goto LABEL_209;
            }
          }
          else
          {
            v3 -= 32LL;
            v22 = _mm_cmpeq_epi8(_mm_alignr_epi8(_mm_load_si128(v11 + 1), *v11, 1), *(__m128i *)v7);
            v23 = _mm_cmpeq_epi8(_mm_alignr_epi8(_mm_load_si128(v11 + 2), v11[1], 1), *(__m128i *)(v7 + 16));
            do
            {
              v130 = (unsigned __int64)v3 < 0x20;
              v3 -= 32LL;
              v24 = _mm_movemask_epi8(_mm_and_si128(v23, v22));
              v15 = v22;
              v25 = _mm_alignr_epi8(_mm_load_si128(v11 + 4), v11[3], 1);
              v9 = v24 - (v130 + 0xFFFF);
              v22 = _mm_cmpeq_epi8(_mm_alignr_epi8(_mm_load_si128(v11 + 3), v11[2], 1), *(__m128i *)(v7 + 32));
              v11 += 2;
              v23 = _mm_cmpeq_epi8(v25, *(__m128i *)(v7 + 48));
              v7 += 32LL;
            }
            while ( !v9 );
            v26 = _mm_and_si128(v23, v22);
            if ( v3 < 0 )
            {
              ++v9;
              v3 += 32LL;
            }
            if ( !v9 )
            {
              v15 = v22;
              v7 += 32LL;
              v11 += 2;
              v9 = _mm_movemask_epi8(v26) - 0xFFFF;
              if ( !v9 )
              {
                v4 = &v11->m128i_i8[v3 + 1];
                v5 = (__int8 *)(v3 + v7);
                goto LABEL_209;
              }
            }
          }
          break;
        case 2:
          v130 = v12 < 0x50;
          v3 = v12 - 48;
          v14 = 2LL;
          if ( v130 )
          {
            v27 = _mm_load_si128(v11 + 1);
            v15 = _mm_cmpeq_epi8(_mm_alignr_epi8(v27, *v11, 2), *(__m128i *)v7);
            v28 = _mm_movemask_epi8(
                    _mm_and_si128(
                      _mm_cmpeq_epi8(_mm_alignr_epi8(_mm_load_si128(v11 + 2), v27, 2), *(__m128i *)(v7 + 16)),
                      v15));
            v7 += 32LL;
            v11 += 2;
            v9 = v28 - 0xFFFF;
            if ( !v9 )
            {
              v4 = &v11->m128i_i8[v3 + 2];
              v5 = (__int8 *)(v3 + v7);
              goto LABEL_209;
            }
          }
          else
          {
            v3 -= 32LL;
            v29 = _mm_cmpeq_epi8(_mm_alignr_epi8(_mm_load_si128(v11 + 1), *v11, 2), *(__m128i *)v7);
            v30 = _mm_cmpeq_epi8(_mm_alignr_epi8(_mm_load_si128(v11 + 2), v11[1], 2), *(__m128i *)(v7 + 16));
            do
            {
              v130 = (unsigned __int64)v3 < 0x20;
              v3 -= 32LL;
              v31 = _mm_movemask_epi8(_mm_and_si128(v30, v29));
              v15 = v29;
              v32 = _mm_alignr_epi8(_mm_load_si128(v11 + 4), v11[3], 2);
              v9 = v31 - (v130 + 0xFFFF);
              v29 = _mm_cmpeq_epi8(_mm_alignr_epi8(_mm_load_si128(v11 + 3), v11[2], 2), *(__m128i *)(v7 + 32));
              v11 += 2;
              v30 = _mm_cmpeq_epi8(v32, *(__m128i *)(v7 + 48));
              v7 += 32LL;
            }
            while ( !v9 );
            v33 = _mm_and_si128(v30, v29);
            if ( v3 < 0 )
            {
              ++v9;
              v3 += 32LL;
            }
            if ( !v9 )
            {
              v15 = v29;
              v7 += 32LL;
              v11 += 2;
              v9 = _mm_movemask_epi8(v33) - 0xFFFF;
              if ( !v9 )
              {
                v4 = &v11->m128i_i8[v3 + 2];
                v5 = (__int8 *)(v3 + v7);
                goto LABEL_209;
              }
            }
          }
          break;
        case 3:
          v130 = v12 < 0x50;
          v3 = v12 - 48;
          v14 = 3LL;
          if ( v130 )
          {
            v34 = _mm_load_si128(v11 + 1);
            v15 = _mm_cmpeq_epi8(_mm_alignr_epi8(v34, *v11, 3), *(__m128i *)v7);
            v35 = _mm_movemask_epi8(
                    _mm_and_si128(
                      _mm_cmpeq_epi8(_mm_alignr_epi8(_mm_load_si128(v11 + 2), v34, 3), *(__m128i *)(v7 + 16)),
                      v15));
            v7 += 32LL;
            v11 += 2;
            v9 = v35 - 0xFFFF;
            if ( !v9 )
            {
              v4 = &v11->m128i_i8[v3 + 3];
              v5 = (__int8 *)(v3 + v7);
              goto LABEL_209;
            }
          }
          else
          {
            v3 -= 32LL;
            v36 = _mm_cmpeq_epi8(_mm_alignr_epi8(_mm_load_si128(v11 + 1), *v11, 3), *(__m128i *)v7);
            v37 = _mm_cmpeq_epi8(_mm_alignr_epi8(_mm_load_si128(v11 + 2), v11[1], 3), *(__m128i *)(v7 + 16));
            do
            {
              v130 = (unsigned __int64)v3 < 0x20;
              v3 -= 32LL;
              v38 = _mm_movemask_epi8(_mm_and_si128(v37, v36));
              v15 = v36;
              v39 = _mm_alignr_epi8(_mm_load_si128(v11 + 4), v11[3], 3);
              v9 = v38 - (v130 + 0xFFFF);
              v36 = _mm_cmpeq_epi8(_mm_alignr_epi8(_mm_load_si128(v11 + 3), v11[2], 3), *(__m128i *)(v7 + 32));
              v11 += 2;
              v37 = _mm_cmpeq_epi8(v39, *(__m128i *)(v7 + 48));
              v7 += 32LL;
            }
            while ( !v9 );
            v40 = _mm_and_si128(v37, v36);
            if ( v3 < 0 )
            {
              ++v9;
              v3 += 32LL;
            }
            if ( !v9 )
            {
              v15 = v36;
              v7 += 32LL;
              v11 += 2;
              v9 = _mm_movemask_epi8(v40) - 0xFFFF;
              if ( !v9 )
              {
                v4 = &v11->m128i_i8[v3 + 3];
                v5 = (__int8 *)(v3 + v7);
                goto LABEL_209;
              }
            }
          }
          break;
        case 4:
          v130 = v12 < 0x50;
          v3 = v12 - 48;
          v14 = 4LL;
          if ( v130 )
          {
            v41 = _mm_load_si128(v11 + 1);
            v15 = _mm_cmpeq_epi8(_mm_alignr_epi8(v41, *v11, 4), *(__m128i *)v7);
            v42 = _mm_movemask_epi8(
                    _mm_and_si128(
                      _mm_cmpeq_epi8(_mm_alignr_epi8(_mm_load_si128(v11 + 2), v41, 4), *(__m128i *)(v7 + 16)),
                      v15));
            v7 += 32LL;
            v11 += 2;
            v9 = v42 - 0xFFFF;
            if ( !v9 )
            {
              v4 = &v11->m128i_i8[v3 + 4];
              v5 = (__int8 *)(v3 + v7);
              goto LABEL_209;
            }
          }
          else
          {
            v3 -= 32LL;
            v43 = _mm_cmpeq_epi8(_mm_alignr_epi8(_mm_load_si128(v11 + 1), *v11, 4), *(__m128i *)v7);
            v44 = _mm_cmpeq_epi8(_mm_alignr_epi8(_mm_load_si128(v11 + 2), v11[1], 4), *(__m128i *)(v7 + 16));
            do
            {
              v130 = (unsigned __int64)v3 < 0x20;
              v3 -= 32LL;
              v45 = _mm_movemask_epi8(_mm_and_si128(v44, v43));
              v15 = v43;
              v46 = _mm_alignr_epi8(_mm_load_si128(v11 + 4), v11[3], 4);
              v9 = v45 - (v130 + 0xFFFF);
              v43 = _mm_cmpeq_epi8(_mm_alignr_epi8(_mm_load_si128(v11 + 3), v11[2], 4), *(__m128i *)(v7 + 32));
              v11 += 2;
              v44 = _mm_cmpeq_epi8(v46, *(__m128i *)(v7 + 48));
              v7 += 32LL;
            }
            while ( !v9 );
            v47 = _mm_and_si128(v44, v43);
            if ( v3 < 0 )
            {
              ++v9;
              v3 += 32LL;
            }
            if ( !v9 )
            {
              v15 = v43;
              v7 += 32LL;
              v11 += 2;
              v9 = _mm_movemask_epi8(v47) - 0xFFFF;
              if ( !v9 )
              {
                v4 = &v11->m128i_i8[v3 + 4];
                v5 = (__int8 *)(v3 + v7);
                goto LABEL_209;
              }
            }
          }
          break;
        case 5:
          v130 = v12 < 0x50;
          v3 = v12 - 48;
          v14 = 5LL;
          if ( v130 )
          {
            v48 = _mm_load_si128(v11 + 1);
            v15 = _mm_cmpeq_epi8(_mm_alignr_epi8(v48, *v11, 5), *(__m128i *)v7);
            v49 = _mm_movemask_epi8(
                    _mm_and_si128(
                      _mm_cmpeq_epi8(_mm_alignr_epi8(_mm_load_si128(v11 + 2), v48, 5), *(__m128i *)(v7 + 16)),
                      v15));
            v7 += 32LL;
            v11 += 2;
            v9 = v49 - 0xFFFF;
            if ( !v9 )
            {
              v4 = &v11->m128i_i8[v3 + 5];
              v5 = (__int8 *)(v3 + v7);
              goto LABEL_209;
            }
          }
          else
          {
            v3 -= 32LL;
            v50 = _mm_cmpeq_epi8(_mm_alignr_epi8(_mm_load_si128(v11 + 1), *v11, 5), *(__m128i *)v7);
            v51 = _mm_cmpeq_epi8(_mm_alignr_epi8(_mm_load_si128(v11 + 2), v11[1], 5), *(__m128i *)(v7 + 16));
            do
            {
              v130 = (unsigned __int64)v3 < 0x20;
              v3 -= 32LL;
              v52 = _mm_movemask_epi8(_mm_and_si128(v51, v50));
              v15 = v50;
              v53 = _mm_alignr_epi8(_mm_load_si128(v11 + 4), v11[3], 5);
              v9 = v52 - (v130 + 0xFFFF);
              v50 = _mm_cmpeq_epi8(_mm_alignr_epi8(_mm_load_si128(v11 + 3), v11[2], 5), *(__m128i *)(v7 + 32));
              v11 += 2;
              v51 = _mm_cmpeq_epi8(v53, *(__m128i *)(v7 + 48));
              v7 += 32LL;
            }
            while ( !v9 );
            v54 = _mm_and_si128(v51, v50);
            if ( v3 < 0 )
            {
              ++v9;
              v3 += 32LL;
            }
            if ( !v9 )
            {
              v15 = v50;
              v7 += 32LL;
              v11 += 2;
              v9 = _mm_movemask_epi8(v54) - 0xFFFF;
              if ( !v9 )
              {
                v4 = &v11->m128i_i8[v3 + 5];
                v5 = (__int8 *)(v3 + v7);
                goto LABEL_209;
              }
            }
          }
          break;
        case 6:
          v130 = v12 < 0x50;
          v3 = v12 - 48;
          v14 = 6LL;
          if ( v130 )
          {
            v55 = _mm_load_si128(v11 + 1);
            v15 = _mm_cmpeq_epi8(_mm_alignr_epi8(v55, *v11, 6), *(__m128i *)v7);
            v56 = _mm_movemask_epi8(
                    _mm_and_si128(
                      _mm_cmpeq_epi8(_mm_alignr_epi8(_mm_load_si128(v11 + 2), v55, 6), *(__m128i *)(v7 + 16)),
                      v15));
            v7 += 32LL;
            v11 += 2;
            v9 = v56 - 0xFFFF;
            if ( !v9 )
            {
              v4 = &v11->m128i_i8[v3 + 6];
              v5 = (__int8 *)(v3 + v7);
              goto LABEL_209;
            }
          }
          else
          {
            v3 -= 32LL;
            v57 = _mm_cmpeq_epi8(_mm_alignr_epi8(_mm_load_si128(v11 + 1), *v11, 6), *(__m128i *)v7);
            v58 = _mm_cmpeq_epi8(_mm_alignr_epi8(_mm_load_si128(v11 + 2), v11[1], 6), *(__m128i *)(v7 + 16));
            do
            {
              v130 = (unsigned __int64)v3 < 0x20;
              v3 -= 32LL;
              v59 = _mm_movemask_epi8(_mm_and_si128(v58, v57));
              v15 = v57;
              v60 = _mm_alignr_epi8(_mm_load_si128(v11 + 4), v11[3], 6);
              v9 = v59 - (v130 + 0xFFFF);
              v57 = _mm_cmpeq_epi8(_mm_alignr_epi8(_mm_load_si128(v11 + 3), v11[2], 6), *(__m128i *)(v7 + 32));
              v11 += 2;
              v58 = _mm_cmpeq_epi8(v60, *(__m128i *)(v7 + 48));
              v7 += 32LL;
            }
            while ( !v9 );
            v61 = _mm_and_si128(v58, v57);
            if ( v3 < 0 )
            {
              ++v9;
              v3 += 32LL;
            }
            if ( !v9 )
            {
              v15 = v57;
              v7 += 32LL;
              v11 += 2;
              v9 = _mm_movemask_epi8(v61) - 0xFFFF;
              if ( !v9 )
              {
                v4 = &v11->m128i_i8[v3 + 6];
                v5 = (__int8 *)(v3 + v7);
                goto LABEL_209;
              }
            }
          }
          break;
        default:
          v130 = v12 < 0x50;
          v3 = v12 - 48;
          v14 = (unsigned int)v13;
          if ( v130 )
          {
            v62 = _mm_load_si128(v11 + 1);
            v15 = _mm_cmpeq_epi8(_mm_alignr_epi8(v62, *v11, 7), *(__m128i *)v7);
            v63 = _mm_movemask_epi8(
                    _mm_and_si128(
                      _mm_cmpeq_epi8(_mm_alignr_epi8(_mm_load_si128(v11 + 2), v62, 7), *(__m128i *)(v7 + 16)),
                      v15));
            v7 += 32LL;
            v11 += 2;
            v9 = v63 - 0xFFFF;
            if ( !v9 )
            {
              v4 = &v11->m128i_i8[v3 + 7];
              v5 = (__int8 *)(v3 + v7);
              goto LABEL_209;
            }
            break;
          }
          v3 -= 32LL;
          v64 = _mm_cmpeq_epi8(_mm_alignr_epi8(_mm_load_si128(v11 + 1), *v11, 7), *(__m128i *)v7);
          v65 = _mm_cmpeq_epi8(_mm_alignr_epi8(_mm_load_si128(v11 + 2), v11[1], 7), *(__m128i *)(v7 + 16));
          do
          {
            v130 = (unsigned __int64)v3 < 0x20;
            v3 -= 32LL;
            v66 = _mm_movemask_epi8(_mm_and_si128(v65, v64));
            v15 = v64;
            v67 = _mm_alignr_epi8(_mm_load_si128(v11 + 4), v11[3], 7);
            v9 = v66 - (v130 + 0xFFFF);
            v64 = _mm_cmpeq_epi8(_mm_alignr_epi8(_mm_load_si128(v11 + 3), v11[2], 7), *(__m128i *)(v7 + 32));
            v11 += 2;
            v65 = _mm_cmpeq_epi8(v67, *(__m128i *)(v7 + 48));
            v7 += 32LL;
          }
          while ( !v9 );
          v68 = _mm_and_si128(v65, v64);
          if ( v3 < 0 )
          {
            ++v9;
            v3 += 32LL;
          }
          if ( !v9 )
          {
            v15 = v64;
            v7 += 32LL;
            v11 += 2;
            v9 = _mm_movemask_epi8(v68) - 0xFFFF;
            if ( !v9 )
            {
              v4 = &v11->m128i_i8[v3 + 7];
              v5 = (__int8 *)(v3 + v7);
              goto LABEL_209;
            }
          }
          break;
      }
LABEL_182:
      v125 = _mm_movemask_epi8(v15) - 0xFFFF;
      if ( v125 )
      {
        --v11;
        v7 -= 16LL;
        LOWORD(v9) = v125;
      }
      v8 = (__m128i *)((char *)v11 + v14);
      goto LABEL_185;
    }
LABEL_22:
    v130 = v12 < 0x50;
    v3 = v12 - 48;
    if ( v130 )
    {
      v14 = 0LL;
      v15 = _mm_cmpeq_epi8(_mm_load_si128(v11), *(__m128i *)v7);
      v16 = _mm_movemask_epi8(_mm_and_si128(_mm_cmpeq_epi8(_mm_load_si128(v11 + 1), *(__m128i *)(v7 + 16)), v15));
      v7 += 32LL;
      v11 += 2;
      v9 = v16 - 0xFFFF;
      if ( !v9 )
      {
        v4 = &v11->m128i_i8[v3];
        v5 = (__int8 *)(v3 + v7);
        goto LABEL_209;
      }
    }
    else
    {
      v14 = 0LL;
      v17 = _mm_cmpeq_epi8(_mm_load_si128(v11), *(__m128i *)v7);
      v3 -= 32LL;
      v18 = _mm_cmpeq_epi8(_mm_load_si128(v11 + 1), *(__m128i *)(v7 + 16));
      do
      {
        v130 = (unsigned __int64)v3 < 0x20;
        v3 -= 32LL;
        v15 = v17;
        v9 = _mm_movemask_epi8(_mm_and_si128(v18, v17)) - (v130 + 0xFFFF);
        v17 = _mm_cmpeq_epi8(_mm_load_si128(v11 + 2), *(__m128i *)(v7 + 32));
        v18 = _mm_cmpeq_epi8(_mm_load_si128(v11 + 3), *(__m128i *)(v7 + 48));
        v7 += 32LL;
        v11 += 2;
      }
      while ( !v9 );
      v19 = _mm_and_si128(v18, v17);
      if ( v3 < 0 )
      {
        ++v9;
        v3 += 32LL;
      }
      if ( !v9 )
      {
        v15 = v17;
        v7 += 32LL;
        v11 += 2;
        v9 = _mm_movemask_epi8(v19) - 0xFFFF;
        if ( !v9 )
        {
          v4 = &v11->m128i_i8[v3];
          v5 = (__int8 *)(v3 + v7);
          goto LABEL_209;
        }
      }
    }
    goto LABEL_182;
  }
  switch ( (_DWORD)v13 )
  {
    case 8:
      v130 = v12 < 0x50;
      v3 = v12 - 48;
      v14 = 8LL;
      if ( v130 )
      {
        v69 = _mm_load_si128(v11 + 1);
        v15 = _mm_cmpeq_epi8(_mm_alignr_epi8(v69, *v11, 8), *(__m128i *)v7);
        v70 = _mm_movemask_epi8(
                _mm_and_si128(
                  _mm_cmpeq_epi8(_mm_alignr_epi8(_mm_load_si128(v11 + 2), v69, 8), *(__m128i *)(v7 + 16)),
                  v15));
        v7 += 32LL;
        v11 += 2;
        v9 = v70 - 0xFFFF;
        if ( v9 )
          goto LABEL_182;
        v4 = &v11->m128i_i8[v3 + 8];
        v5 = (__int8 *)(v3 + v7);
      }
      else
      {
        v3 -= 32LL;
        v71 = _mm_cmpeq_epi8(_mm_alignr_epi8(_mm_load_si128(v11 + 1), *v11, 8), *(__m128i *)v7);
        v72 = _mm_cmpeq_epi8(_mm_alignr_epi8(_mm_load_si128(v11 + 2), v11[1], 8), *(__m128i *)(v7 + 16));
        do
        {
          v130 = (unsigned __int64)v3 < 0x20;
          v3 -= 32LL;
          v73 = _mm_movemask_epi8(_mm_and_si128(v72, v71));
          v15 = v71;
          v74 = _mm_alignr_epi8(_mm_load_si128(v11 + 4), v11[3], 8);
          v9 = v73 - (v130 + 0xFFFF);
          v71 = _mm_cmpeq_epi8(_mm_alignr_epi8(_mm_load_si128(v11 + 3), v11[2], 8), *(__m128i *)(v7 + 32));
          v11 += 2;
          v72 = _mm_cmpeq_epi8(v74, *(__m128i *)(v7 + 48));
          v7 += 32LL;
        }
        while ( !v9 );
        v75 = _mm_and_si128(v72, v71);
        if ( v3 < 0 )
        {
          ++v9;
          v3 += 32LL;
        }
        if ( v9 )
          goto LABEL_182;
        v15 = v71;
        v7 += 32LL;
        v11 += 2;
        v9 = _mm_movemask_epi8(v75) - 0xFFFF;
        if ( v9 )
          goto LABEL_182;
        v4 = &v11->m128i_i8[v3 + 8];
        v5 = (__int8 *)(v3 + v7);
      }
      break;
    case 9:
      v130 = v12 < 0x50;
      v3 = v12 - 48;
      v14 = 9LL;
      if ( v130 )
      {
        v76 = _mm_load_si128(v11 + 1);
        v15 = _mm_cmpeq_epi8(_mm_alignr_epi8(v76, *v11, 9), *(__m128i *)v7);
        v77 = _mm_movemask_epi8(
                _mm_and_si128(
                  _mm_cmpeq_epi8(_mm_alignr_epi8(_mm_load_si128(v11 + 2), v76, 9), *(__m128i *)(v7 + 16)),
                  v15));
        v7 += 32LL;
        v11 += 2;
        v9 = v77 - 0xFFFF;
        if ( v9 )
          goto LABEL_182;
        v4 = &v11->m128i_i8[v3 + 9];
        v5 = (__int8 *)(v3 + v7);
      }
      else
      {
        v3 -= 32LL;
        v78 = _mm_cmpeq_epi8(_mm_alignr_epi8(_mm_load_si128(v11 + 1), *v11, 9), *(__m128i *)v7);
        v79 = _mm_cmpeq_epi8(_mm_alignr_epi8(_mm_load_si128(v11 + 2), v11[1], 9), *(__m128i *)(v7 + 16));
        do
        {
          v130 = (unsigned __int64)v3 < 0x20;
          v3 -= 32LL;
          v80 = _mm_movemask_epi8(_mm_and_si128(v79, v78));
          v15 = v78;
          v81 = _mm_alignr_epi8(_mm_load_si128(v11 + 4), v11[3], 9);
          v9 = v80 - (v130 + 0xFFFF);
          v78 = _mm_cmpeq_epi8(_mm_alignr_epi8(_mm_load_si128(v11 + 3), v11[2], 9), *(__m128i *)(v7 + 32));
          v11 += 2;
          v79 = _mm_cmpeq_epi8(v81, *(__m128i *)(v7 + 48));
          v7 += 32LL;
        }
        while ( !v9 );
        v82 = _mm_and_si128(v79, v78);
        if ( v3 < 0 )
        {
          ++v9;
          v3 += 32LL;
        }
        if ( v9 )
          goto LABEL_182;
        v15 = v78;
        v7 += 32LL;
        v11 += 2;
        v9 = _mm_movemask_epi8(v82) - 0xFFFF;
        if ( v9 )
          goto LABEL_182;
        v4 = &v11->m128i_i8[v3 + 9];
        v5 = (__int8 *)(v3 + v7);
      }
      break;
    case 0xA:
      v130 = v12 < 0x50;
      v3 = v12 - 48;
      v14 = 10LL;
      if ( v130 )
      {
        v83 = _mm_load_si128(v11 + 1);
        v15 = _mm_cmpeq_epi8(_mm_alignr_epi8(v83, *v11, 10), *(__m128i *)v7);
        v84 = _mm_movemask_epi8(
                _mm_and_si128(
                  _mm_cmpeq_epi8(_mm_alignr_epi8(_mm_load_si128(v11 + 2), v83, 10), *(__m128i *)(v7 + 16)),
                  v15));
        v7 += 32LL;
        v11 += 2;
        v9 = v84 - 0xFFFF;
        if ( v9 )
          goto LABEL_182;
        v4 = &v11->m128i_i8[v3 + 10];
        v5 = (__int8 *)(v3 + v7);
      }
      else
      {
        v3 -= 32LL;
        v85 = _mm_cmpeq_epi8(_mm_alignr_epi8(_mm_load_si128(v11 + 1), *v11, 10), *(__m128i *)v7);
        v86 = _mm_cmpeq_epi8(_mm_alignr_epi8(_mm_load_si128(v11 + 2), v11[1], 10), *(__m128i *)(v7 + 16));
        do
        {
          v130 = (unsigned __int64)v3 < 0x20;
          v3 -= 32LL;
          v87 = _mm_movemask_epi8(_mm_and_si128(v86, v85));
          v15 = v85;
          v88 = _mm_alignr_epi8(_mm_load_si128(v11 + 4), v11[3], 10);
          v9 = v87 - (v130 + 0xFFFF);
          v85 = _mm_cmpeq_epi8(_mm_alignr_epi8(_mm_load_si128(v11 + 3), v11[2], 10), *(__m128i *)(v7 + 32));
          v11 += 2;
          v86 = _mm_cmpeq_epi8(v88, *(__m128i *)(v7 + 48));
          v7 += 32LL;
        }
        while ( !v9 );
        v89 = _mm_and_si128(v86, v85);
        if ( v3 < 0 )
        {
          ++v9;
          v3 += 32LL;
        }
        if ( v9 )
          goto LABEL_182;
        v15 = v85;
        v7 += 32LL;
        v11 += 2;
        v9 = _mm_movemask_epi8(v89) - 0xFFFF;
        if ( v9 )
          goto LABEL_182;
        v4 = &v11->m128i_i8[v3 + 10];
        v5 = (__int8 *)(v3 + v7);
      }
      break;
    case 0xB:
      v130 = v12 < 0x50;
      v3 = v12 - 48;
      v14 = 11LL;
      if ( v130 )
      {
        v90 = _mm_load_si128(v11 + 1);
        v15 = _mm_cmpeq_epi8(_mm_alignr_epi8(v90, *v11, 11), *(__m128i *)v7);
        v91 = _mm_movemask_epi8(
                _mm_and_si128(
                  _mm_cmpeq_epi8(_mm_alignr_epi8(_mm_load_si128(v11 + 2), v90, 11), *(__m128i *)(v7 + 16)),
                  v15));
        v7 += 32LL;
        v11 += 2;
        v9 = v91 - 0xFFFF;
        if ( v9 )
          goto LABEL_182;
        v4 = &v11->m128i_i8[v3 + 11];
        v5 = (__int8 *)(v3 + v7);
      }
      else
      {
        v3 -= 32LL;
        v92 = _mm_cmpeq_epi8(_mm_alignr_epi8(_mm_load_si128(v11 + 1), *v11, 11), *(__m128i *)v7);
        v93 = _mm_cmpeq_epi8(_mm_alignr_epi8(_mm_load_si128(v11 + 2), v11[1], 11), *(__m128i *)(v7 + 16));
        do
        {
          v130 = (unsigned __int64)v3 < 0x20;
          v3 -= 32LL;
          v94 = _mm_movemask_epi8(_mm_and_si128(v93, v92));
          v15 = v92;
          v95 = _mm_alignr_epi8(_mm_load_si128(v11 + 4), v11[3], 11);
          v9 = v94 - (v130 + 0xFFFF);
          v92 = _mm_cmpeq_epi8(_mm_alignr_epi8(_mm_load_si128(v11 + 3), v11[2], 11), *(__m128i *)(v7 + 32));
          v11 += 2;
          v93 = _mm_cmpeq_epi8(v95, *(__m128i *)(v7 + 48));
          v7 += 32LL;
        }
        while ( !v9 );
        v96 = _mm_and_si128(v93, v92);
        if ( v3 < 0 )
        {
          ++v9;
          v3 += 32LL;
        }
        if ( v9 )
          goto LABEL_182;
        v15 = v92;
        v7 += 32LL;
        v11 += 2;
        v9 = _mm_movemask_epi8(v96) - 0xFFFF;
        if ( v9 )
          goto LABEL_182;
        v4 = &v11->m128i_i8[v3 + 11];
        v5 = (__int8 *)(v3 + v7);
      }
      break;
    case 0xC:
      v130 = v12 < 0x50;
      v3 = v12 - 48;
      v14 = 12LL;
      if ( v130 )
      {
        v97 = _mm_load_si128(v11 + 1);
        v15 = _mm_cmpeq_epi8(_mm_alignr_epi8(v97, *v11, 12), *(__m128i *)v7);
        v98 = _mm_movemask_epi8(
                _mm_and_si128(
                  _mm_cmpeq_epi8(_mm_alignr_epi8(_mm_load_si128(v11 + 2), v97, 12), *(__m128i *)(v7 + 16)),
                  v15));
        v7 += 32LL;
        v11 += 2;
        v9 = v98 - 0xFFFF;
        if ( v9 )
          goto LABEL_182;
        v4 = &v11->m128i_i8[v3 + 12];
        v5 = (__int8 *)(v3 + v7);
      }
      else
      {
        v3 -= 32LL;
        v99 = _mm_cmpeq_epi8(_mm_alignr_epi8(_mm_load_si128(v11 + 1), *v11, 12), *(__m128i *)v7);
        v100 = _mm_cmpeq_epi8(_mm_alignr_epi8(_mm_load_si128(v11 + 2), v11[1], 12), *(__m128i *)(v7 + 16));
        do
        {
          v130 = (unsigned __int64)v3 < 0x20;
          v3 -= 32LL;
          v101 = _mm_movemask_epi8(_mm_and_si128(v100, v99));
          v15 = v99;
          v102 = _mm_alignr_epi8(_mm_load_si128(v11 + 4), v11[3], 12);
          v9 = v101 - (v130 + 0xFFFF);
          v99 = _mm_cmpeq_epi8(_mm_alignr_epi8(_mm_load_si128(v11 + 3), v11[2], 12), *(__m128i *)(v7 + 32));
          v11 += 2;
          v100 = _mm_cmpeq_epi8(v102, *(__m128i *)(v7 + 48));
          v7 += 32LL;
        }
        while ( !v9 );
        v103 = _mm_and_si128(v100, v99);
        if ( v3 < 0 )
        {
          ++v9;
          v3 += 32LL;
        }
        if ( v9 )
          goto LABEL_182;
        v15 = v99;
        v7 += 32LL;
        v11 += 2;
        v9 = _mm_movemask_epi8(v103) - 0xFFFF;
        if ( v9 )
          goto LABEL_182;
        v4 = &v11->m128i_i8[v3 + 12];
        v5 = (__int8 *)(v3 + v7);
      }
      break;
    case 0xD:
      v130 = v12 < 0x50;
      v3 = v12 - 48;
      v14 = 13LL;
      if ( v130 )
      {
        v104 = _mm_load_si128(v11 + 1);
        v15 = _mm_cmpeq_epi8(_mm_alignr_epi8(v104, *v11, 13), *(__m128i *)v7);
        v105 = _mm_movemask_epi8(
                 _mm_and_si128(
                   _mm_cmpeq_epi8(_mm_alignr_epi8(_mm_load_si128(v11 + 2), v104, 13), *(__m128i *)(v7 + 16)),
                   v15));
        v7 += 32LL;
        v11 += 2;
        v9 = v105 - 0xFFFF;
        if ( v9 )
          goto LABEL_182;
        v4 = &v11->m128i_i8[v3 + 13];
        v5 = (__int8 *)(v3 + v7);
      }
      else
      {
        v3 -= 32LL;
        v106 = _mm_cmpeq_epi8(_mm_alignr_epi8(_mm_load_si128(v11 + 1), *v11, 13), *(__m128i *)v7);
        v107 = _mm_cmpeq_epi8(_mm_alignr_epi8(_mm_load_si128(v11 + 2), v11[1], 13), *(__m128i *)(v7 + 16));
        do
        {
          v130 = (unsigned __int64)v3 < 0x20;
          v3 -= 32LL;
          v108 = _mm_movemask_epi8(_mm_and_si128(v107, v106));
          v15 = v106;
          v109 = _mm_alignr_epi8(_mm_load_si128(v11 + 4), v11[3], 13);
          v9 = v108 - (v130 + 0xFFFF);
          v106 = _mm_cmpeq_epi8(_mm_alignr_epi8(_mm_load_si128(v11 + 3), v11[2], 13), *(__m128i *)(v7 + 32));
          v11 += 2;
          v107 = _mm_cmpeq_epi8(v109, *(__m128i *)(v7 + 48));
          v7 += 32LL;
        }
        while ( !v9 );
        v110 = _mm_and_si128(v107, v106);
        if ( v3 < 0 )
        {
          ++v9;
          v3 += 32LL;
        }
        if ( v9 )
          goto LABEL_182;
        v15 = v106;
        v7 += 32LL;
        v11 += 2;
        v9 = _mm_movemask_epi8(v110) - 0xFFFF;
        if ( v9 )
          goto LABEL_182;
        v4 = &v11->m128i_i8[v3 + 13];
        v5 = (__int8 *)(v3 + v7);
      }
      break;
    case 0xE:
      v130 = v12 < 0x50;
      v3 = v12 - 48;
      v14 = 14LL;
      if ( v130 )
      {
        v111 = _mm_load_si128(v11 + 1);
        v15 = _mm_cmpeq_epi8(_mm_alignr_epi8(v111, *v11, 14), *(__m128i *)v7);
        v112 = _mm_movemask_epi8(
                 _mm_and_si128(
                   _mm_cmpeq_epi8(_mm_alignr_epi8(_mm_load_si128(v11 + 2), v111, 14), *(__m128i *)(v7 + 16)),
                   v15));
        v7 += 32LL;
        v11 += 2;
        v9 = v112 - 0xFFFF;
        if ( v9 )
          goto LABEL_182;
        v4 = &v11->m128i_i8[v3 + 14];
        v5 = (__int8 *)(v3 + v7);
      }
      else
      {
        v3 -= 32LL;
        v113 = _mm_cmpeq_epi8(_mm_alignr_epi8(_mm_load_si128(v11 + 1), *v11, 14), *(__m128i *)v7);
        v114 = _mm_cmpeq_epi8(_mm_alignr_epi8(_mm_load_si128(v11 + 2), v11[1], 14), *(__m128i *)(v7 + 16));
        do
        {
          v130 = (unsigned __int64)v3 < 0x20;
          v3 -= 32LL;
          v115 = _mm_movemask_epi8(_mm_and_si128(v114, v113));
          v15 = v113;
          v116 = _mm_alignr_epi8(_mm_load_si128(v11 + 4), v11[3], 14);
          v9 = v115 - (v130 + 0xFFFF);
          v113 = _mm_cmpeq_epi8(_mm_alignr_epi8(_mm_load_si128(v11 + 3), v11[2], 14), *(__m128i *)(v7 + 32));
          v11 += 2;
          v114 = _mm_cmpeq_epi8(v116, *(__m128i *)(v7 + 48));
          v7 += 32LL;
        }
        while ( !v9 );
        v117 = _mm_and_si128(v114, v113);
        if ( v3 < 0 )
        {
          ++v9;
          v3 += 32LL;
        }
        if ( v9 )
          goto LABEL_182;
        v15 = v113;
        v7 += 32LL;
        v11 += 2;
        v9 = _mm_movemask_epi8(v117) - 0xFFFF;
        if ( v9 )
          goto LABEL_182;
        v4 = &v11->m128i_i8[v3 + 14];
        v5 = (__int8 *)(v3 + v7);
      }
      break;
    default:
      v130 = v12 < 0x50;
      v3 = v12 - 48;
      v14 = (unsigned int)v13;
      if ( v130 )
      {
        v118 = _mm_load_si128(v11 + 1);
        v15 = _mm_cmpeq_epi8(_mm_alignr_epi8(v118, *v11, 15), *(__m128i *)v7);
        v119 = _mm_movemask_epi8(
                 _mm_and_si128(
                   _mm_cmpeq_epi8(_mm_alignr_epi8(_mm_load_si128(v11 + 2), v118, 15), *(__m128i *)(v7 + 16)),
                   v15));
        v7 += 32LL;
        v11 += 2;
        v9 = v119 - 0xFFFF;
        if ( v9 )
          goto LABEL_182;
        v4 = &v11->m128i_i8[v3 + 15];
        v5 = (__int8 *)(v3 + v7);
      }
      else
      {
        v3 -= 32LL;
        v120 = _mm_cmpeq_epi8(_mm_alignr_epi8(_mm_load_si128(v11 + 1), *v11, 15), *(__m128i *)v7);
        v121 = _mm_cmpeq_epi8(_mm_alignr_epi8(_mm_load_si128(v11 + 2), v11[1], 15), *(__m128i *)(v7 + 16));
        do
        {
          v130 = (unsigned __int64)v3 < 0x20;
          v3 -= 32LL;
          v122 = _mm_movemask_epi8(_mm_and_si128(v121, v120));
          v15 = v120;
          v123 = _mm_alignr_epi8(_mm_load_si128(v11 + 4), v11[3], 15);
          v9 = v122 - (v130 + 0xFFFF);
          v120 = _mm_cmpeq_epi8(_mm_alignr_epi8(_mm_load_si128(v11 + 3), v11[2], 15), *(__m128i *)(v7 + 32));
          v11 += 2;
          v121 = _mm_cmpeq_epi8(v123, *(__m128i *)(v7 + 48));
          v7 += 32LL;
        }
        while ( !v9 );
        v124 = _mm_and_si128(v121, v120);
        if ( v3 < 0 )
        {
          ++v9;
          v3 += 32LL;
        }
        if ( v9 )
          goto LABEL_182;
        v15 = v120;
        v7 += 32LL;
        v11 += 2;
        v9 = _mm_movemask_epi8(v124) - 0xFFFF;
        if ( v9 )
          goto LABEL_182;
        v4 = &v11->m128i_i8[v3 + 15];
        v5 = (__int8 *)(v3 + v7);
      }
      break;
  }
LABEL_209:
  if ( (unsigned int)v3 >= 8 )
  {
    if ( (unsigned int)v3 < 0x10 )
    {
      switch ( (_DWORD)v3 )
      {
        case 8:
LABEL_271:
          v127 = *((_DWORD *)v5 - 2);
          v128 = *((_DWORD *)v4 - 2);
          if ( v127 != v128 )
            goto LABEL_316;
LABEL_272:
          v127 = *((_DWORD *)v5 - 1);
          v128 = *((_DWORD *)v4 - 1);
          if ( v127 != v128 )
            goto LABEL_316;
          return 0LL;
        case 9:
LABEL_283:
          v127 = *(_DWORD *)(v5 - 9);
          v128 = *(_DWORD *)(v4 - 9);
          if ( v127 != v128 )
            goto LABEL_316;
LABEL_284:
          v127 = *(_DWORD *)(v5 - 5);
          v128 = *(_DWORD *)(v4 - 5);
          if ( v127 != v128 )
            goto LABEL_316;
LABEL_285:
          v129 = *(v5 - 1);
          v130 = v129 < (unsigned __int8)*(v4 - 1);
          if ( v129 == *(v4 - 1) )
            return 0LL;
          return -v130 - ((unsigned int)v130 - 1);
        case 0xA:
LABEL_296:
          v127 = *(_DWORD *)(v5 - 10);
          v128 = *(_DWORD *)(v4 - 10);
          if ( v127 != v128 )
            goto LABEL_316;
LABEL_297:
          v127 = *(_DWORD *)(v5 - 6);
          v128 = *(_DWORD *)(v4 - 6);
          if ( v127 != v128 )
            goto LABEL_316;
LABEL_298:
          v131 = *((unsigned __int16 *)v5 - 1);
          v132 = *((unsigned __int16 *)v4 - 1);
          v130 = (unsigned __int8)v131 < (unsigned __int8)v132;
          if ( (_BYTE)v131 == (_BYTE)v132 )
          {
            v130 = v131 < v132;
            if ( v131 == v132 )
              return 0LL;
          }
          return -v130 - ((unsigned int)v130 - 1);
        case 0xB:
LABEL_310:
          v127 = *(_DWORD *)(v5 - 11);
          v128 = *(_DWORD *)(v4 - 11);
          if ( v127 != v128 )
            goto LABEL_316;
          goto LABEL_311;
      }
      if ( (_DWORD)v3 != 12 )
      {
        if ( (_DWORD)v3 != 13 )
        {
          if ( (_DWORD)v3 != 14 )
          {
LABEL_309:
            v127 = *(_DWORD *)(v5 - 15);
            v128 = *(_DWORD *)(v4 - 15);
            if ( v127 != v128 )
              goto LABEL_316;
            goto LABEL_310;
          }
          goto LABEL_295;
        }
        goto LABEL_282;
      }
LABEL_270:
      v127 = *((_DWORD *)v5 - 3);
      v128 = *((_DWORD *)v4 - 3);
      if ( v127 != v128 )
        goto LABEL_316;
      goto LABEL_271;
    }
    if ( (unsigned int)v3 < 0x18 )
    {
      switch ( (_DWORD)v3 )
      {
        case 0x10:
LABEL_269:
          v127 = *((_DWORD *)v5 - 4);
          v128 = *((_DWORD *)v4 - 4);
          if ( v127 != v128 )
            goto LABEL_316;
          goto LABEL_270;
        case 0x11:
LABEL_281:
          v127 = *(_DWORD *)(v5 - 17);
          v128 = *(_DWORD *)(v4 - 17);
          if ( v127 != v128 )
            goto LABEL_316;
LABEL_282:
          v127 = *(_DWORD *)(v5 - 13);
          v128 = *(_DWORD *)(v4 - 13);
          if ( v127 != v128 )
            goto LABEL_316;
          goto LABEL_283;
        case 0x12:
LABEL_294:
          v127 = *(_DWORD *)(v5 - 18);
          v128 = *(_DWORD *)(v4 - 18);
          if ( v127 != v128 )
            goto LABEL_316;
LABEL_295:
          v127 = *(_DWORD *)(v5 - 14);
          v128 = *(_DWORD *)(v4 - 14);
          if ( v127 != v128 )
            goto LABEL_316;
          goto LABEL_296;
        case 0x13:
LABEL_308:
          v127 = *(_DWORD *)(v5 - 19);
          v128 = *(_DWORD *)(v4 - 19);
          if ( v127 != v128 )
            goto LABEL_316;
          goto LABEL_309;
      }
      if ( (_DWORD)v3 != 20 )
      {
        if ( (_DWORD)v3 != 21 )
        {
          if ( (_DWORD)v3 != 22 )
          {
LABEL_307:
            v127 = *(_DWORD *)(v5 - 23);
            v128 = *(_DWORD *)(v4 - 23);
            if ( v127 != v128 )
              goto LABEL_316;
            goto LABEL_308;
          }
          goto LABEL_293;
        }
        goto LABEL_280;
      }
LABEL_268:
      v127 = *((_DWORD *)v5 - 5);
      v128 = *((_DWORD *)v4 - 5);
      if ( v127 != v128 )
        goto LABEL_316;
      goto LABEL_269;
    }
    if ( (unsigned int)v3 < 0x20 )
    {
      switch ( (_DWORD)v3 )
      {
        case 0x18:
LABEL_267:
          v127 = *((_DWORD *)v5 - 6);
          v128 = *((_DWORD *)v4 - 6);
          if ( v127 != v128 )
            goto LABEL_316;
          goto LABEL_268;
        case 0x19:
LABEL_279:
          v127 = *(_DWORD *)(v5 - 25);
          v128 = *(_DWORD *)(v4 - 25);
          if ( v127 != v128 )
            goto LABEL_316;
LABEL_280:
          v127 = *(_DWORD *)(v5 - 21);
          v128 = *(_DWORD *)(v4 - 21);
          if ( v127 != v128 )
            goto LABEL_316;
          goto LABEL_281;
        case 0x1A:
LABEL_292:
          v127 = *(_DWORD *)(v5 - 26);
          v128 = *(_DWORD *)(v4 - 26);
          if ( v127 != v128 )
            goto LABEL_316;
LABEL_293:
          v127 = *(_DWORD *)(v5 - 22);
          v128 = *(_DWORD *)(v4 - 22);
          if ( v127 != v128 )
            goto LABEL_316;
          goto LABEL_294;
        case 0x1B:
LABEL_306:
          v127 = *(_DWORD *)(v5 - 27);
          v128 = *(_DWORD *)(v4 - 27);
          if ( v127 != v128 )
            goto LABEL_316;
          goto LABEL_307;
      }
      if ( (_DWORD)v3 != 28 )
      {
        if ( (_DWORD)v3 != 29 )
        {
          if ( (_DWORD)v3 != 30 )
          {
LABEL_305:
            v127 = *(_DWORD *)(v5 - 31);
            v128 = *(_DWORD *)(v4 - 31);
            if ( v127 != v128 )
              goto LABEL_316;
            goto LABEL_306;
          }
          goto LABEL_291;
        }
        goto LABEL_278;
      }
LABEL_266:
      v127 = *((_DWORD *)v5 - 7);
      v128 = *((_DWORD *)v4 - 7);
      if ( v127 != v128 )
        goto LABEL_316;
      goto LABEL_267;
    }
    if ( (unsigned int)v3 < 0x28 )
    {
      switch ( (_DWORD)v3 )
      {
        case ' ':
LABEL_265:
          v127 = *((_DWORD *)v5 - 8);
          v128 = *((_DWORD *)v4 - 8);
          if ( v127 != v128 )
            goto LABEL_316;
          goto LABEL_266;
        case '!':
LABEL_277:
          v127 = *(_DWORD *)(v5 - 33);
          v128 = *(_DWORD *)(v4 - 33);
          if ( v127 != v128 )
            goto LABEL_316;
LABEL_278:
          v127 = *(_DWORD *)(v5 - 29);
          v128 = *(_DWORD *)(v4 - 29);
          if ( v127 != v128 )
            goto LABEL_316;
          goto LABEL_279;
        case '"':
LABEL_290:
          v127 = *(_DWORD *)(v5 - 34);
          v128 = *(_DWORD *)(v4 - 34);
          if ( v127 != v128 )
            goto LABEL_316;
LABEL_291:
          v127 = *(_DWORD *)(v5 - 30);
          v128 = *(_DWORD *)(v4 - 30);
          if ( v127 != v128 )
            goto LABEL_316;
          goto LABEL_292;
        case '#':
LABEL_304:
          v127 = *(_DWORD *)(v5 - 35);
          v128 = *(_DWORD *)(v4 - 35);
          if ( v127 != v128 )
            goto LABEL_316;
          goto LABEL_305;
      }
      if ( (_DWORD)v3 != 36 )
      {
        if ( (_DWORD)v3 != 37 )
        {
          if ( (_DWORD)v3 != 38 )
          {
LABEL_303:
            v127 = *(_DWORD *)(v5 - 39);
            v128 = *(_DWORD *)(v4 - 39);
            if ( v127 != v128 )
              goto LABEL_316;
            goto LABEL_304;
          }
          goto LABEL_289;
        }
        goto LABEL_276;
      }
LABEL_264:
      v127 = *((_DWORD *)v5 - 9);
      v128 = *((_DWORD *)v4 - 9);
      if ( v127 != v128 )
        goto LABEL_316;
      goto LABEL_265;
    }
    if ( (_DWORD)v3 != 40 )
    {
      switch ( (_DWORD)v3 )
      {
        case ')':
          goto LABEL_275;
        case '*':
          goto LABEL_288;
        case '+':
LABEL_302:
          v127 = *(_DWORD *)(v5 - 43);
          v128 = *(_DWORD *)(v4 - 43);
          if ( v127 != v128 )
            goto LABEL_316;
          goto LABEL_303;
      }
      if ( (_DWORD)v3 != 44 )
      {
        if ( (_DWORD)v3 != 45 )
        {
          if ( (_DWORD)v3 != 46 )
          {
            v127 = *(_DWORD *)(v5 - 47);
            v128 = *(_DWORD *)(v4 - 47);
            if ( v127 != v128 )
              goto LABEL_316;
            goto LABEL_302;
          }
          v127 = *(_DWORD *)(v5 - 46);
          v128 = *(_DWORD *)(v4 - 46);
          if ( v127 != v128 )
            goto LABEL_316;
LABEL_288:
          v127 = *(_DWORD *)(v5 - 42);
          v128 = *(_DWORD *)(v4 - 42);
          if ( v127 != v128 )
            goto LABEL_316;
LABEL_289:
          v127 = *(_DWORD *)(v5 - 38);
          v128 = *(_DWORD *)(v4 - 38);
          if ( v127 != v128 )
            goto LABEL_316;
          goto LABEL_290;
        }
        v127 = *(_DWORD *)(v5 - 45);
        v128 = *(_DWORD *)(v4 - 45);
        if ( v127 != v128 )
          goto LABEL_316;
LABEL_275:
        v127 = *(_DWORD *)(v5 - 41);
        v128 = *(_DWORD *)(v4 - 41);
        if ( v127 != v128 )
          goto LABEL_316;
LABEL_276:
        v127 = *(_DWORD *)(v5 - 37);
        v128 = *(_DWORD *)(v4 - 37);
        if ( v127 != v128 )
          goto LABEL_316;
        goto LABEL_277;
      }
      v127 = *((_DWORD *)v5 - 11);
      v128 = *((_DWORD *)v4 - 11);
      if ( v127 != v128 )
        goto LABEL_316;
    }
    v127 = *((_DWORD *)v5 - 10);
    v128 = *((_DWORD *)v4 - 10);
    if ( v127 != v128 )
      goto LABEL_316;
    goto LABEL_264;
  }
  switch ( (_DWORD)v3 )
  {
    case 0:
      return 0LL;
    case 1:
      goto LABEL_285;
    case 2:
      goto LABEL_298;
  }
  if ( (_DWORD)v3 != 3 )
  {
    if ( (_DWORD)v3 != 4 )
    {
      if ( (_DWORD)v3 != 5 )
      {
        if ( (_DWORD)v3 != 6 )
        {
LABEL_311:
          v127 = *(_DWORD *)(v5 - 7);
          v128 = *(_DWORD *)(v4 - 7);
          if ( v127 == v128 )
            goto LABEL_312;
LABEL_316:
          v130 = (unsigned __int8)v127 < (unsigned __int8)v128;
          if ( (_BYTE)v127 == (_BYTE)v128 )
          {
            v130 = (unsigned __int16)v127 < (unsigned __int16)v128;
            if ( (_WORD)v127 == (_WORD)v128 )
            {
              v136 = HIWORD(v127);
              v137 = HIWORD(v128);
              v130 = (unsigned __int8)v136 < (unsigned __int8)v137;
              if ( (_BYTE)v136 == (_BYTE)v137 )
                v130 = v136 < v137;
            }
          }
          return -v130 - ((unsigned int)v130 - 1);
        }
        goto LABEL_297;
      }
      goto LABEL_284;
    }
    goto LABEL_272;
  }
LABEL_312:
  v133 = *(unsigned __int16 *)(v5 - 3);
  v134 = *(unsigned __int16 *)(v4 - 3);
  v130 = (unsigned __int8)v133 < (unsigned __int8)v134;
  if ( (_BYTE)v133 == (_BYTE)v134 )
  {
    v130 = v133 < v134;
    if ( v133 == v134 )
    {
      v135 = *(v5 - 1);
      v130 = v135 < (unsigned __int8)*(v4 - 1);
      if ( v135 == *(v4 - 1) )
        return 0LL;
    }
  }
  return -v130 - ((unsigned int)v130 - 1);
}

//----- (000000000043A490) ----------------------------------------------------
__int8 *__fastcall _strstr_sse2_unaligned(__int64 a1, char *a2)
{
  unsigned int v2; // eax
  unsigned int v3; // edx
  __m128i v4; // xmm1
  __m128i v5; // xmm2
  __m128i v6; // xmm1
  __m128i v7; // xmm2
  __m128i v8; // xmm1
  __m128i v9; // xmm2
  __m128i v10; // xmm6
  __m128i v11; // xmm0
  unsigned __int64 v12; // r8
  unsigned __int64 v13; // rax
  __int8 *result; // rax
  char v15; // dl
  __int64 v16; // rdx
  char v17; // cl
  __m128i v18; // xmm6
  __m128i v19; // xmm0
  unsigned __int64 v20; // r8
  unsigned __int64 v21; // rax
  char v22; // dl
  __int64 v23; // rdx
  char v24; // cl
  __int64 v25; // r11
  unsigned __int64 v27; // rdi
  __m128i v28; // xmm0
  __m128i v29; // xmm10
  __m128i v30; // xmm6
  __m128i v31; // xmm9
  __m128i v32; // xmm3
  __m128i v33; // xmm8
  __m128i v34; // xmm4
  __m128i v35; // xmm5
  __m128i v36; // xmm8
  unsigned __int64 v37; // r8
  unsigned __int64 v38; // rcx
  _BYTE *v39; // rcx
  __int64 v40; // rax
  char v41; // dl
  char v42; // dl
  __m128i si128; // xmm3
  __m128i v44; // xmm5
  __m128i v45; // xmm8
  __m128i v46; // xmm7
  __m128i v47; // xmm3
  __m128i v48; // xmm5
  unsigned __int64 i; // r8
  unsigned __int64 v50; // rax
  _BYTE *v51; // rax
  char v52; // dl
  __int64 v53; // rdx
  char v54; // cl

  v2 = (unsigned __int8)*a2;
  if ( !(_BYTE)v2 )
    return (__int8 *)a1;
  v3 = (unsigned __int8)a2[1];
  if ( !(_BYTE)v3 )
    return _strchr_sse2((const __m128i *)a1, v2);
  v4 = _mm_cvtsi32_si128(v2);
  v5 = _mm_cvtsi32_si128(v3);
  v6 = _mm_unpacklo_epi8(v4, v4);
  v7 = _mm_unpacklo_epi8(v5, v5);
  v8 = _mm_shuffle_epi32(_mm_unpacklo_epi16(v6, v6), 0);
  v9 = _mm_shuffle_epi32(_mm_unpacklo_epi16(v7, v7), 0);
  if ( ((unsigned __int16)a1 & 0xFFFu) > 0xFBFuLL )
  {
    si128 = _mm_load_si128((const __m128i *)(a1 & 0xFFFFFFFFFFFFFFC0LL));
    v44 = _mm_load_si128((const __m128i *)((a1 & 0xFFFFFFFFFFFFFFC0LL) + 16));
    v45 = _mm_or_si128(
            _mm_cmpeq_epi8(si128, (__m128i)0LL),
            _mm_min_epu8(
              _mm_cmpeq_epi8(si128, v9),
              _mm_cmpeq_epi8(_mm_loadu_si128((const __m128i *)((a1 & 0xFFFFFFFFFFFFFFC0LL) - 1)), v8)));
    v46 = _mm_or_si128(
            _mm_cmpeq_epi8(v44, (__m128i)0LL),
            _mm_min_epu8(
              _mm_cmpeq_epi8(v44, v9),
              _mm_cmpeq_epi8(_mm_loadu_si128((const __m128i *)((a1 & 0xFFFFFFFFFFFFFFC0LL) + 15)), v8)));
    v47 = _mm_load_si128((const __m128i *)((a1 & 0xFFFFFFFFFFFFFFC0LL) + 32));
    v48 = _mm_load_si128((const __m128i *)((a1 & 0xFFFFFFFFFFFFFFC0LL) + 48));
    for ( i = (((unsigned __int64)(unsigned int)_mm_movemask_epi8(
                                                  _mm_or_si128(
                                                    _mm_cmpeq_epi8((__m128i)0LL, v48),
                                                    _mm_min_epu8(
                                                      _mm_cmpeq_epi8(v48, v9),
                                                      _mm_cmpeq_epi8(
                                                        _mm_loadu_si128((const __m128i *)((a1 & 0xFFFFFFFFFFFFFFC0LL)
                                                                                        + 47)),
                                                        v8)))) << 48) | (unsigned int)_mm_movemask_epi8(v45) | ((unsigned __int64)(unsigned int)_mm_movemask_epi8(_mm_or_si128(_mm_cmpeq_epi8(v47, (__m128i)0LL), _mm_min_epu8(_mm_cmpeq_epi8(v47, v9), _mm_cmpeq_epi8(_mm_loadu_si128((const __m128i *)((a1 & 0xFFFFFFFFFFFFFFC0LL) + 31)), v8)))) << 32) | ((unsigned __int64)(unsigned int)_mm_movemask_epi8(v46) << 16)) >> ((unsigned __int8)a1 - ((unsigned __int8)a1 & 0xC0u));
          i;
          i &= i - 1 )
    {
      _BitScanForward64(&v50, i);
      v51 = (_BYTE *)(a1 + v50);
      if ( !*v51 )
        return 0LL;
      if ( (_BYTE *)a1 != v51 )
      {
        v52 = a2[2];
        if ( !v52 )
          return v51 - 1;
        if ( v52 == v51[1] )
        {
          v53 = 0LL;
          do
          {
            v54 = a2[v53 + 3];
            if ( !v54 )
              return v51 - 1;
            ++v53;
          }
          while ( v54 == v51[v53 + 1] );
        }
      }
    }
LABEL_26:
    v25 = -512LL;
    v27 = a1 & 0xFFFFFFFFFFFFFFC0LL;
    do
    {
      do
      {
LABEL_27:
        v28 = _mm_load_si128((const __m128i *)(v27 + 64));
        v29 = _mm_load_si128((const __m128i *)(v27 + 80));
        v30 = _mm_or_si128(_mm_xor_si128(_mm_loadu_si128((const __m128i *)(v27 + 63)), v8), _mm_xor_si128(v28, v9));
        v31 = _mm_load_si128((const __m128i *)(v27 + 96));
        v32 = _mm_or_si128(_mm_xor_si128(_mm_loadu_si128((const __m128i *)(v27 + 79)), v8), _mm_xor_si128(v29, v9));
        v33 = _mm_load_si128((const __m128i *)(v27 + 112));
        v27 += 64LL;
        v34 = _mm_or_si128(_mm_xor_si128(_mm_loadu_si128((const __m128i *)(v27 + 31)), v8), _mm_xor_si128(v31, v9));
        v35 = _mm_or_si128(_mm_xor_si128(_mm_loadu_si128((const __m128i *)(v27 + 47)), v8), _mm_xor_si128(v33, v9));
      }
      while ( !_mm_movemask_epi8(
                 _mm_cmpeq_epi8(
                   _mm_min_epu8(
                     _mm_min_epu8(_mm_min_epu8(_mm_min_epu8(v28, v29), v31), v33),
                     _mm_min_epu8(_mm_min_epu8(_mm_min_epu8(v32, v30), v34), v35)),
                   (__m128i)0LL)) );
      v36 = _mm_load_si128((const __m128i *)(v27 + 16));
      v37 = ((unsigned __int64)(unsigned int)_mm_movemask_epi8(
                                               _mm_or_si128(
                                                 _mm_cmpeq_epi8(v36, (__m128i)0LL),
                                                 _mm_min_epu8(
                                                   _mm_cmpeq_epi8(v36, v9),
                                                   _mm_cmpeq_epi8(_mm_loadu_si128((const __m128i *)(v27 + 15)), v8)))) << 16) | ((unsigned __int64)(unsigned int)_mm_movemask_epi8(_mm_cmpeq_epi8(_mm_min_epu8(v34, *(__m128i *)(v27 + 32)), (__m128i)0LL)) << 32) | (unsigned int)_mm_movemask_epi8(_mm_cmpeq_epi8(_mm_min_epu8(v30, *(__m128i *)v27), (__m128i)0LL)) | ((unsigned __int64)(unsigned int)_mm_movemask_epi8(_mm_cmpeq_epi8(_mm_min_epu8(v35, *(__m128i *)(v27 + 48)), (__m128i)0LL)) << 48);
    }
    while ( !v37 );
    while ( 1 )
    {
      _BitScanForward64(&v38, v37);
      v39 = (_BYTE *)(v27 + v38);
      if ( !*v39 )
        return 0LL;
      v40 = 0LL;
      v41 = a2[2];
      if ( !v41 )
        return v39 - 1;
      if ( v41 == v39[1] )
      {
        do
        {
          v42 = a2[v40 + 3];
          if ( !v42 )
            return v39 - 1;
          ++v40;
        }
        while ( v42 == v39[v40 + 1] );
      }
      v25 += v40;
      if ( (__int64)(v27 - a1) < v25 )
        return _strstr_sse2((char *)v27, a2);
      v37 &= v37 - 1;
      if ( !v37 )
        goto LABEL_27;
    }
  }
  v10 = _mm_loadu_si128((const __m128i *)a1);
  v11 = _mm_loadu_si128((const __m128i *)(a1 + 16));
  v12 = ((unsigned __int64)(unsigned int)_mm_movemask_epi8(
                                           _mm_or_si128(
                                             _mm_min_epu8(
                                               _mm_cmpeq_epi8(v11, v8),
                                               _mm_cmpeq_epi8(_mm_loadu_si128((const __m128i *)(a1 + 17)), v9)),
                                             _mm_cmpeq_epi8((__m128i)0LL, v11))) << 16) | (unsigned int)_mm_movemask_epi8(_mm_or_si128(_mm_min_epu8(_mm_cmpeq_epi8(v10, v8), _mm_cmpeq_epi8(_mm_loadu_si128((const __m128i *)(a1 + 1)), v9)), _mm_cmpeq_epi8(v10, (__m128i)0LL)));
  if ( !v12 )
  {
LABEL_15:
    v18 = _mm_loadu_si128((const __m128i *)(a1 + 32));
    v19 = _mm_loadu_si128((const __m128i *)(a1 + 48));
    v20 = ((unsigned __int64)(unsigned int)_mm_movemask_epi8(
                                             _mm_or_si128(
                                               _mm_min_epu8(
                                                 _mm_cmpeq_epi8(v18, v8),
                                                 _mm_cmpeq_epi8(_mm_loadu_si128((const __m128i *)(a1 + 33)), v9)),
                                               _mm_cmpeq_epi8(v18, (__m128i)0LL))) << 32) | ((unsigned __int64)(unsigned int)_mm_movemask_epi8(_mm_or_si128(_mm_min_epu8(_mm_cmpeq_epi8(v19, v8), _mm_cmpeq_epi8(_mm_loadu_si128((const __m128i *)(a1 + 49)), v9)), _mm_cmpeq_epi8((__m128i)0LL, v19))) << 48);
    if ( v20 )
    {
      while ( 1 )
      {
        _BitScanForward64(&v21, v20);
        result = (__int8 *)(a1 + v21);
        if ( !*result )
          return 0LL;
        v22 = a2[2];
        if ( !v22 )
          return result;
        if ( v22 == result[2] )
          break;
LABEL_25:
        v20 &= v20 - 1;
        if ( !v20 )
          goto LABEL_26;
      }
      v23 = 0LL;
      while ( 1 )
      {
        v24 = a2[v23 + 3];
        if ( !v24 )
          return result;
        if ( v24 != result[++v23 + 2] )
          goto LABEL_25;
      }
    }
    goto LABEL_26;
  }
  while ( 1 )
  {
    _BitScanForward64(&v13, v12);
    result = (__int8 *)(a1 + v13);
    if ( !*result )
      return 0LL;
    v15 = a2[2];
    if ( !v15 )
      return result;
    if ( v15 == result[2] )
      break;
LABEL_14:
    v12 &= v12 - 1;
    if ( !v12 )
      goto LABEL_15;
  }
  v16 = 0LL;
  while ( 1 )
  {
    v17 = a2[v16 + 3];
    if ( !v17 )
      return result;
    if ( v17 != result[++v16 + 2] )
      goto LABEL_14;
  }
}

//----- (000000000043A930) ----------------------------------------------------
_BYTE *__fastcall _strcspn_sse2(__int64 a1, _BYTE *a2)
{
  __int64 v2; // rcx
  _BYTE *v4; // rax
  char v6[256]; // [rsp+0h] [rbp-100h] BYREF

  memset(v6, 0, sizeof(v6));
  v2 = 0LL;
  do
  {
    if ( !*a2 )
      break;
    LOBYTE(v2) = *a2;
    v6[v2] = *a2;
    LOBYTE(v2) = a2[1];
    if ( !(_BYTE)v2 )
      break;
    v6[v2] = v2;
    LOBYTE(v2) = a2[2];
    if ( !(_BYTE)v2 )
      break;
    v6[v2] = v2;
    LOBYTE(v2) = a2[3];
    a2 += 4;
    v6[v2] = v2;
  }
  while ( (_BYTE)v2 );
  v4 = (_BYTE *)(a1 - 4);
  while ( 1 )
  {
    v4 += 4;
    LOBYTE(v2) = *v4;
    if ( v6[v2] == *v4 )
      return &v4[-a1];
    LOBYTE(v2) = v4[1];
    if ( v6[v2] == (_BYTE)v2 )
      goto LABEL_13;
    LOBYTE(v2) = v4[2];
    if ( v6[v2] == (_BYTE)v2 )
      goto LABEL_12;
    LOBYTE(v2) = v4[3];
    if ( v6[v2] == (_BYTE)v2 )
    {
      ++v4;
LABEL_12:
      ++v4;
LABEL_13:
      ++v4;
      return &v4[-a1];
    }
  }
}
// 43A930: using guessed type char var_100[256];

//----- (000000000043A9E0) ----------------------------------------------------
_BYTE *__fastcall _strcspn_sse42(__int64 a1, __m128i *a2)
{
  int v2; // edx
  __m128i v3; // xmm1
  const __m128i *v4; // rdx
  __m128i v5; // xmm2
  signed int v6; // ecx
  __m128i v7; // xmm3
  int v8; // ecx
  int v9; // esi
  int v10; // er8
  __m128i si128; // xmm0
  int v13; // ecx

  if ( !a2->m128i_i8[0] )
    return (_BYTE *)j_strlen_ifunc(a1);
  v2 = (unsigned __int8)a2 & 0xF;
  if ( ((unsigned __int8)a2 & 0xF) != 0 )
  {
    v3 = _mm_shuffle_epi8(
           _mm_load_si128((const __m128i *)((unsigned __int64)a2 & 0xFFFFFFFFFFFFFFF0LL)),
           _mm_loadu_si128((const __m128i *)((char *)&__m128i_shift_right + ((unsigned __int8)a2 & 0xF))));
    if ( 16 - v2 == _mm_cmpistri(v3, v3, 58) )
    {
      si128 = _mm_load_si128((const __m128i *)(((unsigned __int64)a2 & 0xFFFFFFFFFFFFFFF0LL) + 16));
      v13 = _mm_cmpistri(si128, si128, 58);
      if ( v13 + 16 - v2 > 16 )
        return _strcspn_sse2(a1, a2);
      if ( v13 )
        v3 = _mm_loadu_si128(a2);
    }
  }
  else
  {
    v3 = _mm_load_si128(a2);
    if ( _mm_cmpistri(v3, v3, 58) == 16 && a2[1].m128i_i8[0] )
      return _strcspn_sse2(a1, a2);
  }
  v4 = (const __m128i *)a1;
  if ( (a1 & 0xF) == 0
    || (v5 = _mm_shuffle_epi8(
               _mm_load_si128((const __m128i *)(a1 & 0xFFFFFFFFFFFFFFF0LL)),
               _mm_loadu_si128((const __m128i *)((char *)&__m128i_shift_right + (a1 & 0xF)))),
        v6 = _mm_cmpistri(v3, v5, 2),
        !_mm_cmpistrc(v3, v5, 2))
    && (v6 = _mm_cmpistri(v5, v5, 58),
        v4 = (const __m128i *)((a1 & 0xFFFFFFFFFFFFFFF0LL) + 16),
        (int)(16 - (a1 & 0xF)) <= v6) )
  {
    v7 = _mm_load_si128(v4);
    v8 = _mm_cmpistri(v3, v7, 2);
    v9 = _mm_cmpistrz(v3, v7, 2);
    if ( !_mm_cmpistrc(v3, v7, 2) )
    {
      if ( v9 )
        return (char *)v4 + _mm_cmpistri(v7, v7, 58) - a1;
      while ( 1 )
      {
        v7 = _mm_load_si128(++v4);
        v8 = _mm_cmpistri(v3, v7, 2);
        v10 = _mm_cmpistrz(v3, v7, 2);
        if ( _mm_cmpistrc(v3, v7, 2) )
          break;
        if ( v10 )
          return (char *)v4 + _mm_cmpistri(v7, v7, 58) - a1;
      }
    }
    return (char *)v4 + v8 - a1;
  }
  return (_BYTE *)v6;
}
// 4010C8: using guessed type __int64 __fastcall j_strlen_ifunc(_QWORD);

//----- (000000000043AB60) ----------------------------------------------------
unsigned __int64 __fastcall _memset_chk_avx512_no_vzeroupper(
        unsigned __int64 _RDI,
        __int64 _ESI,
        unsigned __int64 a3,
        __m128 _XMM0,
        unsigned __int64 a5,
        u32 *a6,
        __int64 a7)
{
  if ( a5 < a3 )
    _chk_fail(_RDI, _ESI, a3, a5, a6, a7);
  return _memset_avx512_no_vzeroupper(_RDI, _ESI, a3, _XMM0);
}

//----- (000000000043AB70) ----------------------------------------------------
unsigned __int64 __fastcall _memset_avx512_no_vzeroupper(
        unsigned __int64 _RDI,
        int _ESI,
        unsigned __int64 a3,
        __m128 _XMM0)
{
  unsigned __int64 result; // rax

  __asm
  {
    vpxor   xmm0, xmm0, xmm0
    vmovd   xmm1, esi
  }
  _RSI = _RDI + a3;
  result = _RDI;
  __asm { vpshufb xmm0, xmm1, xmm0 }
  if ( a3 < 0x10 )
  {
    if ( (unsigned __int8)a3 < 8u )
    {
      __asm { vmovd   ecx, xmm0 }
      if ( (unsigned __int8)a3 < 4u )
      {
        if ( (unsigned __int8)a3 < 2u )
        {
          if ( (_BYTE)a3 )
            *(_BYTE *)_RDI = _ECX;
        }
        else
        {
          *(_WORD *)_RDI = _ECX;
          *(_WORD *)(_RSI - 2) = _ECX;
        }
      }
      else
      {
        *(_DWORD *)_RDI = _ECX;
        *(_DWORD *)(_RSI - 4) = _ECX;
      }
    }
    else
    {
      __asm
      {
        vmovq   qword ptr [rdi], xmm0
        vmovq   qword ptr [rsi-8], xmm0
      }
    }
  }
  else
  {
    __asm { vbroadcastss zmm2, xmm0 }
    if ( a3 > 0x200 )
    {
      if ( a3 > _x86_shared_cache_size_half )
      {
        _RDI = (_RDI & 0xFFFFFFFFFFFFFF80LL) + 128;
        __asm
        {
          vmovups zmmword ptr [rax], zmm2
          vmovups zmmword ptr [rax+40h], zmm2
        }
        _RSI = _RSI - 512;
        do
        {
          __asm
          {
            vmovntdq zmmword ptr [rdi], zmm2
            vmovntdq zmmword ptr [rdi+40h], zmm2
            vmovntdq zmmword ptr [rdi+80h], zmm2
            vmovntdq zmmword ptr [rdi+0C0h], zmm2
            vmovntdq zmmword ptr [rdi+100h], zmm2
            vmovntdq zmmword ptr [rdi+140h], zmm2
            vmovntdq zmmword ptr [rdi+180h], zmm2
            vmovntdq zmmword ptr [rdi+1C0h], zmm2
          }
          _RDI += 512LL;
        }
        while ( _RDI < _RSI );
        _mm_sfence();
        __asm
        {
          vmovups zmmword ptr [rsi], zmm2
          vmovups zmmword ptr [rsi+40h], zmm2
          vmovups zmmword ptr [rsi+80h], zmm2
          vmovups zmmword ptr [rsi+0C0h], zmm2
          vmovups zmmword ptr [rsi+100h], zmm2
          vmovups zmmword ptr [rsi+140h], zmm2
          vmovups zmmword ptr [rsi+180h], zmm2
          vmovups zmmword ptr [rsi+1C0h], zmm2
        }
      }
      else if ( a3 > 0x400 )
      {
        _RSI = _RSI - 256;
        __asm { vmovups zmmword ptr [rax], zmm2 }
        _RDI = (_RDI & 0xFFFFFFFFFFFFFFC0LL) + 64;
        do
        {
          __asm
          {
            vmovaps zmmword ptr [rdi], zmm2
            vmovaps zmmword ptr [rdi+40h], zmm2
            vmovaps zmmword ptr [rdi+80h], zmm2
            vmovaps zmmword ptr [rdi+0C0h], zmm2
          }
          _RDI += 256LL;
        }
        while ( _RDI < _RSI );
        __asm
        {
          vmovups zmmword ptr [rsi], zmm2
          vmovups zmmword ptr [rsi+40h], zmm2
          vmovups zmmword ptr [rsi+80h], zmm2
          vmovups zmmword ptr [rsi+0C0h], zmm2
        }
      }
      else
      {
        __asm
        {
          vmovups zmmword ptr [rdi], zmm2
          vmovups zmmword ptr [rdi+40h], zmm2
          vmovups zmmword ptr [rdi+80h], zmm2
          vmovups zmmword ptr [rdi+0C0h], zmm2
          vmovups zmmword ptr [rdi+100h], zmm2
          vmovups zmmword ptr [rdi+140h], zmm2
          vmovups zmmword ptr [rdi+180h], zmm2
          vmovups zmmword ptr [rdi+1C0h], zmm2
          vmovups zmmword ptr [rsi-200h], zmm2
          vmovups zmmword ptr [rsi-1C0h], zmm2
          vmovups zmmword ptr [rsi-180h], zmm2
          vmovups zmmword ptr [rsi-140h], zmm2
          vmovups zmmword ptr [rsi-100h], zmm2
          vmovups zmmword ptr [rsi-0C0h], zmm2
          vmovups zmmword ptr [rsi-80h], zmm2
          vmovups zmmword ptr [rsi-40h], zmm2
        }
      }
    }
    else if ( a3 < 0x100 )
    {
      if ( (unsigned __int8)a3 < 0x80u )
      {
        if ( (unsigned __int8)a3 < 0x40u )
        {
          if ( (unsigned __int8)a3 < 0x20u )
          {
            __asm
            {
              vmovdqu xmmword ptr [rdi], xmm0
              vmovdqu xmmword ptr [rsi-10h], xmm0
            }
          }
          else
          {
            __asm
            {
              vmovdqu ymmword ptr [rdi], ymm2
              vmovdqu ymmword ptr [rsi-20h], ymm2
            }
          }
        }
        else
        {
          __asm
          {
            vmovups zmmword ptr [rdi], zmm2
            vmovups zmmword ptr [rsi-40h], zmm2
          }
        }
      }
      else
      {
        __asm
        {
          vmovups zmmword ptr [rdi], zmm2
          vmovups zmmword ptr [rdi+40h], zmm2
          vmovups zmmword ptr [rsi-80h], zmm2
          vmovups zmmword ptr [rsi-40h], zmm2
        }
      }
    }
    else
    {
      __asm
      {
        vmovups zmmword ptr [rdi], zmm2
        vmovups zmmword ptr [rdi+40h], zmm2
        vmovups zmmword ptr [rdi+80h], zmm2
        vmovups zmmword ptr [rdi+0C0h], zmm2
        vmovups zmmword ptr [rsi-100h], zmm2
        vmovups zmmword ptr [rsi-0C0h], zmm2
        vmovups zmmword ptr [rsi-80h], zmm2
        vmovups zmmword ptr [rsi-40h], zmm2
      }
    }
  }
  return result;
}
// 43AB70: unsupported processor register 'zmm2'
// 4A9138: using guessed type __int64 _x86_shared_cache_size_half;

//----- (000000000043ADF0) ----------------------------------------------------
void _mempcpy_sse2_unaligned()
{
  JUMPOUT(0x43AE07LL);
}
// 43ADFA: control flows out of bounds to 43AE07

//----- (000000000043AE00) ----------------------------------------------------
_OWORD *__fastcall _memmove_sse2_unaligned(_OWORD *a1, _OWORD *a2, unsigned __int64 a3)
{
  _OWORD *result; // rax
  __int128 v4; // xmm1

  result = a1;
  if ( a3 < 0x10 )
    JUMPOUT(0x43AF0BLL);
  if ( a3 > 0x20 )
    JUMPOUT(0x43AF5ALL);
  v4 = *(_OWORD *)((char *)a2 + a3 - 16);
  *a1 = *a2;
  *(_OWORD *)((char *)a1 + a3 - 16) = v4;
  return result;
}
// 43AE0B: control flows out of bounds to 43AF0B
// 43AE15: control flows out of bounds to 43AF5A

//----- (000000000043AE30) ----------------------------------------------------
void __fastcall _mempcpy_chk_erms(
        __int64 a1,
        __int64 a2,
        unsigned __int64 a3,
        unsigned __int64 a4,
        u32 *a5,
        __int64 a6)
{
  if ( a4 < a3 )
    _chk_fail(a1, a2, a3, a4, a5, a6);
  _mempcpy_erms(a1, a2, a3);
}

//----- (000000000043AE40) ----------------------------------------------------
void __fastcall _mempcpy_erms(__int64 a1, __int64 a2, __int64 a3)
{
  if ( a3 )
    JUMPOUT(0x43AE7CLL);
  JUMPOUT(0x43AE91LL);
}
// 43AE4F: control flows out of bounds to 43AE7C
// 43AE4A: control flows out of bounds to 43AE91

//----- (000000000043AE60) ----------------------------------------------------
char *__fastcall _memmove_chk_erms(char *a1, char *a2, unsigned __int64 a3, unsigned __int64 a4, u32 *a5, __int64 a6)
{
  if ( a4 < a3 )
    _chk_fail((__int64)a1, (__int64)a2, a3, a4, a5, a6);
  return _memmove_erms(a1, a2, a3);
}

//----- (000000000043AE70) ----------------------------------------------------
char *__fastcall _memmove_erms(char *a1, char *a2, unsigned __int64 a3)
{
  char *result; // rax
  unsigned __int64 v4; // rcx
  char *v5; // rdi
  char *v6; // rsi

  result = a1;
  if ( a3 )
  {
    v4 = a3;
    if ( a1 < a2 )
    {
LABEL_5:
      qmemcpy(a1, a2, a3);
      return result;
    }
    if ( a1 != a2 )
    {
      if ( a1 >= &a2[a3] )
        goto LABEL_5;
      v5 = &a1[a3 - 1];
      v6 = &a2[a3 - 1];
      while ( v4 )
      {
        *v5-- = *v6--;
        --v4;
      }
    }
  }
  return result;
}

//----- (000000000043AEB0) ----------------------------------------------------
void _mempcpy_sse2_unaligned_erms()
{
  JUMPOUT(0x43AEC7LL);
}
// 43AEBA: control flows out of bounds to 43AEC7

//----- (000000000043AEC0) ----------------------------------------------------
_OWORD *__fastcall _memmove_sse2_unaligned_erms(_OWORD *a1, _OWORD *a2, unsigned __int64 a3)
{
  _OWORD *result; // rax
  __int128 v4; // xmm1
  __int64 v5; // rcx
  __int64 v6; // rsi
  int v7; // ecx
  int v8; // esi
  __int16 v9; // cx
  __int16 v10; // si
  __int128 v11; // xmm1
  __int128 v12; // xmm2
  __int128 v13; // xmm3
  __int128 v14; // xmm4
  __int128 v15; // xmm5
  __int128 v16; // xmm6
  __int128 v17; // xmm7
  __int128 v18; // xmm2
  __int128 v19; // xmm3
  __int128 v20; // xmm4
  __int128 v21; // xmm5
  __int128 v22; // xmm6
  __int128 v23; // xmm7
  __int128 v24; // xmm8
  _OWORD *v26; // rcx
  __int64 v27; // r8
  __m128i *v29; // rdi
  unsigned __int64 v30; // rdx
  __m128i v31; // xmm0
  __m128i v32; // xmm1
  __m128i v33; // xmm2
  __m128i v34; // xmm3
  __int128 v35; // xmm4
  __int128 v36; // xmm5
  __int128 v37; // xmm6
  __int128 v38; // xmm7
  __int128 v39; // xmm8
  _OWORD *v40; // r11
  __int64 v41; // r8
  __m128i *v43; // r9
  unsigned __int64 v44; // rdx
  __m128i v45; // xmm0
  __m128i v46; // xmm1
  __m128i v47; // xmm2
  __m128i v48; // xmm3
  __m128i v49; // xmm0
  __m128i v50; // xmm1
  __m128i v51; // xmm2
  __m128i v52; // xmm3
  __m128i v53; // xmm0
  __m128i v54; // xmm1
  __m128i v55; // xmm2
  __m128i v56; // xmm3

  result = a1;
  if ( a3 >= 0x10 )
  {
    if ( a3 <= 0x20 )
    {
      v4 = *(_OWORD *)((char *)a2 + a3 - 16);
      *a1 = *a2;
      *(_OWORD *)((char *)a1 + a3 - 16) = v4;
      return result;
    }
    if ( a3 > 0x800 )
    {
      if ( a3 < _x86_shared_non_temporal_threshold )
      {
        if ( a1 < a2 )
          goto LABEL_8;
        if ( a1 == a2 )
          return result;
        if ( a1 >= (_OWORD *)((char *)a2 + a3) )
        {
LABEL_8:
          qmemcpy(a1, a2, a3);
          return result;
        }
        goto LABEL_29;
      }
    }
    else if ( a3 <= 0x80 )
    {
      v11 = a2[1];
      if ( a3 < 0x40 )
      {
        v18 = *(_OWORD *)((char *)a2 + a3 - 16);
        v19 = *(_OWORD *)((char *)a2 + a3 - 32);
        *a1 = *a2;
        a1[1] = v11;
        *(_OWORD *)((char *)a1 + a3 - 16) = v18;
        *(_OWORD *)((char *)a1 + a3 - 32) = v19;
      }
      else
      {
        v12 = a2[2];
        v13 = a2[3];
        v14 = *(_OWORD *)((char *)a2 + a3 - 16);
        v15 = *(_OWORD *)((char *)a2 + a3 - 32);
        v16 = *(_OWORD *)((char *)a2 + a3 - 48);
        v17 = *(_OWORD *)((char *)a2 + a3 - 64);
        *a1 = *a2;
        a1[1] = v11;
        a1[2] = v12;
        a1[3] = v13;
        *(_OWORD *)((char *)a1 + a3 - 16) = v14;
        *(_OWORD *)((char *)a1 + a3 - 32) = v15;
        *(_OWORD *)((char *)a1 + a3 - 48) = v16;
        *(_OWORD *)((char *)a1 + a3 - 64) = v17;
      }
      return result;
    }
    if ( a1 <= a2 )
    {
      if ( a1 != a2 )
      {
        v20 = *a2;
        v21 = *(_OWORD *)((char *)a2 + a3 - 16);
        v22 = *(_OWORD *)((char *)a2 + a3 - 32);
        v23 = *(_OWORD *)((char *)a2 + a3 - 48);
        v24 = *(_OWORD *)((char *)a2 + a3 - 64);
        v26 = (_OWORD *)((char *)a1 + a3 - 16);
        v27 = ((unsigned __int8)a1 & 0xF) - 16LL;
        _RSI = (__m128i *)((char *)a2 - v27);
        v29 = (__m128i *)((char *)a1 - v27);
        v30 = v27 + a3;
        if ( v30 <= _x86_shared_non_temporal_threshold || _RSI < (__m128i *)&v29->m128i_i8[v30] )
        {
          do
          {
            v31 = *_RSI;
            v32 = _RSI[1];
            v33 = _RSI[2];
            v34 = _RSI[3];
            _RSI += 4;
            v30 -= 64LL;
            *v29 = v31;
            v29[1] = v32;
            v29[2] = v33;
            v29[3] = v34;
            v29 += 4;
          }
          while ( v30 > 0x40 );
          *v26 = v21;
          *(v26 - 1) = v22;
          *(v26 - 2) = v23;
          *(v26 - 3) = v24;
          *a1 = v20;
        }
        else
        {
          do
          {
            __asm
            {
              prefetcht0 byte ptr [rsi+80h]
              prefetcht0 byte ptr [rsi+0C0h]
            }
            v49 = *_RSI;
            v50 = _RSI[1];
            v51 = _RSI[2];
            v52 = _RSI[3];
            _RSI += 4;
            v30 -= 64LL;
            _mm_stream_si128(v29, v49);
            _mm_stream_si128(v29 + 1, v50);
            _mm_stream_si128(v29 + 2, v51);
            _mm_stream_si128(v29 + 3, v52);
            v29 += 4;
          }
          while ( v30 > 0x40 );
          _mm_sfence();
          *v26 = v21;
          *(v26 - 1) = v22;
          *(v26 - 2) = v23;
          *(v26 - 3) = v24;
          *a1 = v20;
        }
      }
      return result;
    }
LABEL_29:
    v35 = *a2;
    v36 = a2[1];
    v37 = a2[2];
    v38 = a2[3];
    v39 = *(_OWORD *)((char *)a2 + a3 - 16);
    v40 = (_OWORD *)((char *)a1 + a3 - 16);
    v41 = ((_BYTE)a1 + (_BYTE)a3 - 16) & 0xF;
    _RCX = (__m128i *)((char *)a2 + a3 - v41 - 16);
    v43 = (__m128i *)((char *)v40 - v41);
    v44 = a3 - v41;
    if ( v44 <= _x86_shared_non_temporal_threshold || v43 < (__m128i *)&_RCX->m128i_i8[v44] )
    {
      do
      {
        v45 = *_RCX;
        v46 = _RCX[-1];
        v47 = _RCX[-2];
        v48 = _RCX[-3];
        _RCX -= 4;
        v44 -= 64LL;
        *v43 = v45;
        v43[-1] = v46;
        v43[-2] = v47;
        v43[-3] = v48;
        v43 -= 4;
      }
      while ( v44 > 0x40 );
      *a1 = v35;
      a1[1] = v36;
      a1[2] = v37;
      a1[3] = v38;
      *v40 = v39;
    }
    else
    {
      do
      {
        __asm
        {
          prefetcht0 byte ptr [rcx-80h]
          prefetcht0 byte ptr [rcx-0C0h]
        }
        v53 = *_RCX;
        v54 = _RCX[-1];
        v55 = _RCX[-2];
        v56 = _RCX[-3];
        _RCX -= 4;
        v44 -= 64LL;
        _mm_stream_si128(v43, v53);
        _mm_stream_si128(v43 - 1, v54);
        _mm_stream_si128(v43 - 2, v55);
        _mm_stream_si128(v43 - 3, v56);
        v43 -= 4;
      }
      while ( v44 > 0x40 );
      _mm_sfence();
      *a1 = v35;
      a1[1] = v36;
      a1[2] = v37;
      a1[3] = v38;
      *v40 = v39;
    }
    return result;
  }
  if ( (unsigned __int8)a3 >= 8u )
  {
    v5 = *(_QWORD *)((char *)a2 + a3 - 8);
    v6 = *(_QWORD *)a2;
    *(_QWORD *)((char *)a1 + a3 - 8) = v5;
    *(_QWORD *)a1 = v6;
  }
  else if ( (unsigned __int8)a3 >= 4u )
  {
    v7 = *(_DWORD *)((char *)a2 + a3 - 4);
    v8 = *(_DWORD *)a2;
    *(_DWORD *)((char *)a1 + a3 - 4) = v7;
    *(_DWORD *)a1 = v8;
  }
  else if ( (unsigned __int8)a3 > 1u )
  {
    v9 = *(_WORD *)((char *)a2 + a3 - 2);
    v10 = *(_WORD *)a2;
    *(_WORD *)((char *)a1 + a3 - 2) = v9;
    *(_WORD *)a1 = v10;
  }
  else if ( (_BYTE)a3 )
  {
    *(_BYTE *)a1 = *(_BYTE *)a2;
  }
  return result;
}
// 4AB828: using guessed type __int64 _x86_shared_non_temporal_threshold;

//----- (000000000043B1C0) ----------------------------------------------------
void _mempcpy_avx_unaligned()
{
  JUMPOUT(0x43B1D7LL);
}
// 43B1CA: control flows out of bounds to 43B1D7

//----- (000000000043B1D0) ----------------------------------------------------
__int64 __fastcall _memmove_avx_unaligned(__int64 _RDI, __int64 _RSI, unsigned __int64 _RDX)
{
  __int64 result; // rax

  result = _RDI;
  if ( _RDX < 0x20 )
    JUMPOUT(0x43B276LL);
  if ( _RDX > 0x40 )
    JUMPOUT(0x43B2E3LL);
  __asm
  {
    vmovdqu ymm0, ymmword ptr [rsi]
    vmovdqu ymm1, ymmword ptr [rsi+rdx-20h]
    vmovdqu ymmword ptr [rdi], ymm0
    vmovdqu ymmword ptr [rdi+rdx-20h], ymm1
    vzeroupper
  }
  return result;
}
// 43B1DB: control flows out of bounds to 43B276
// 43B1E5: control flows out of bounds to 43B2E3

//----- (000000000043B210) ----------------------------------------------------
void _mempcpy_avx_unaligned_erms()
{
  JUMPOUT(0x43B227LL);
}
// 43B21A: control flows out of bounds to 43B227

//----- (000000000043B220) ----------------------------------------------------
__int64 *__fastcall _memmove_avx_unaligned_erms(__int64 *_RDI, __int64 *_RSI, unsigned __int64 _RDX)
{
  __int64 *result; // rax
  __int64 v8; // rcx
  __int64 v9; // rsi
  int v10; // ecx
  int v11; // esi
  __int16 v12; // cx
  __int16 v13; // si
  __int64 v33; // r8
  unsigned __int64 v36; // rdx
  __int64 v47; // r8
  unsigned __int64 v50; // rdx

  result = _RDI;
  if ( _RDX >= 0x20 )
  {
    if ( _RDX <= 0x40 )
    {
      __asm
      {
        vmovdqu ymm0, ymmword ptr [rsi]
        vmovdqu ymm1, ymmword ptr [rsi+rdx-20h]
        vmovdqu ymmword ptr [rdi], ymm0
        vmovdqu ymmword ptr [rdi+rdx-20h], ymm1
        vzeroupper
      }
      return result;
    }
    if ( _RDX > 0x1000 )
    {
      if ( _RDX < _x86_shared_non_temporal_threshold )
      {
        if ( _RDI < _RSI )
          goto LABEL_8;
        if ( _RDI == _RSI )
          return result;
        if ( _RDI >= (__int64 *)((char *)_RSI + _RDX) )
        {
LABEL_8:
          qmemcpy(_RDI, _RSI, _RDX);
          return result;
        }
        goto LABEL_31;
      }
    }
    else if ( _RDX <= 0x100 )
    {
      if ( _RDX < 0x80 )
      {
        __asm
        {
          vmovdqu ymm0, ymmword ptr [rsi]
          vmovdqu ymm1, ymmword ptr [rsi+20h]
          vmovdqu ymm2, ymmword ptr [rsi+rdx-20h]
          vmovdqu ymm3, ymmword ptr [rsi+rdx-40h]
          vmovdqu ymmword ptr [rdi], ymm0
          vmovdqu ymmword ptr [rdi+20h], ymm1
          vmovdqu ymmword ptr [rdi+rdx-20h], ymm2
          vmovdqu ymmword ptr [rdi+rdx-40h], ymm3
          vzeroupper
        }
      }
      else
      {
        __asm
        {
          vmovdqu ymm0, ymmword ptr [rsi]
          vmovdqu ymm1, ymmword ptr [rsi+20h]
          vmovdqu ymm2, ymmword ptr [rsi+40h]
          vmovdqu ymm3, ymmword ptr [rsi+60h]
          vmovdqu ymm4, ymmword ptr [rsi+rdx-20h]
          vmovdqu ymm5, ymmword ptr [rsi+rdx-40h]
          vmovdqu ymm6, ymmword ptr [rsi+rdx-60h]
          vmovdqu ymm7, ymmword ptr [rsi+rdx-80h]
          vmovdqu ymmword ptr [rdi], ymm0
          vmovdqu ymmword ptr [rdi+20h], ymm1
          vmovdqu ymmword ptr [rdi+40h], ymm2
          vmovdqu ymmword ptr [rdi+60h], ymm3
          vmovdqu ymmword ptr [rdi+rdx-20h], ymm4
          vmovdqu ymmword ptr [rdi+rdx-40h], ymm5
          vmovdqu ymmword ptr [rdi+rdx-60h], ymm6
          vmovdqu ymmword ptr [rdi+rdx-80h], ymm7
          vzeroupper
        }
      }
      return result;
    }
    if ( _RDI <= _RSI )
    {
      if ( _RDI != _RSI )
      {
        __asm
        {
          vmovdqu ymm4, ymmword ptr [rsi]
          vmovdqu ymm5, ymmword ptr [rsi+rdx-20h]
          vmovdqu ymm6, ymmword ptr [rsi+rdx-40h]
          vmovdqu ymm7, ymmword ptr [rsi+rdx-60h]
          vmovdqu ymm8, ymmword ptr [rsi+rdx-80h]
        }
        _R11 = _RDI;
        _RCX = (char *)_RDI + _RDX - 32;
        v33 = ((unsigned __int8)_RDI & 0x1F) - 32LL;
        _RSI = (char *)_RSI - v33;
        _RDI = (char *)_RDI - v33;
        v36 = v33 + _RDX;
        if ( v36 <= _x86_shared_non_temporal_threshold || _RSI < &_RDI[v36] )
        {
          do
          {
            __asm
            {
              vmovdqu ymm0, ymmword ptr [rsi]
              vmovdqu ymm1, ymmword ptr [rsi+20h]
              vmovdqu ymm2, ymmword ptr [rsi+40h]
              vmovdqu ymm3, ymmword ptr [rsi+60h]
            }
            _RSI += 128;
            v36 -= 128LL;
            __asm
            {
              vmovdqa ymmword ptr [rdi], ymm0
              vmovdqa ymmword ptr [rdi+20h], ymm1
              vmovdqa ymmword ptr [rdi+40h], ymm2
              vmovdqa ymmword ptr [rdi+60h], ymm3
            }
            _RDI += 128;
          }
          while ( v36 > 0x80 );
          __asm
          {
            vmovdqu ymmword ptr [rcx], ymm5
            vmovdqu ymmword ptr [rcx-20h], ymm6
            vmovdqu ymmword ptr [rcx-40h], ymm7
            vmovdqu ymmword ptr [rcx-60h], ymm8
            vmovdqu ymmword ptr [r11], ymm4
            vzeroupper
          }
        }
        else
        {
          do
          {
            __asm
            {
              prefetcht0 byte ptr [rsi+100h]
              prefetcht0 byte ptr [rsi+140h]
              prefetcht0 byte ptr [rsi+180h]
              prefetcht0 byte ptr [rsi+1C0h]
              vmovdqu ymm0, ymmword ptr [rsi]
              vmovdqu ymm1, ymmword ptr [rsi+20h]
              vmovdqu ymm2, ymmword ptr [rsi+40h]
              vmovdqu ymm3, ymmword ptr [rsi+60h]
            }
            _RSI += 128;
            v36 -= 128LL;
            __asm
            {
              vmovntdq ymmword ptr [rdi], ymm0
              vmovntdq ymmword ptr [rdi+20h], ymm1
              vmovntdq ymmword ptr [rdi+40h], ymm2
              vmovntdq ymmword ptr [rdi+60h], ymm3
            }
            _RDI += 128;
          }
          while ( v36 > 0x80 );
          _mm_sfence();
          __asm
          {
            vmovdqu ymmword ptr [rcx], ymm5
            vmovdqu ymmword ptr [rcx-20h], ymm6
            vmovdqu ymmword ptr [rcx-40h], ymm7
            vmovdqu ymmword ptr [rcx-60h], ymm8
            vmovdqu ymmword ptr [r11], ymm4
            vzeroupper
          }
        }
      }
      return result;
    }
LABEL_31:
    __asm
    {
      vmovdqu ymm4, ymmword ptr [rsi]
      vmovdqu ymm5, ymmword ptr [rsi+20h]
      vmovdqu ymm6, ymmword ptr [rsi+40h]
      vmovdqu ymm7, ymmword ptr [rsi+60h]
      vmovdqu ymm8, ymmword ptr [rsi+rdx-20h]
    }
    _R11 = (char *)_RDI + _RDX - 32;
    v47 = ((_BYTE)_RDI + (_BYTE)_RDX - 32) & 0x1F;
    _RCX = (char *)_RSI + _RDX - v47 - 32;
    _R9 = &_R11[-v47];
    v50 = _RDX - v47;
    if ( v50 <= _x86_shared_non_temporal_threshold || _R9 < &_RCX[v50] )
    {
      do
      {
        __asm
        {
          vmovdqu ymm0, ymmword ptr [rcx]
          vmovdqu ymm1, ymmword ptr [rcx-20h]
          vmovdqu ymm2, ymmword ptr [rcx-40h]
          vmovdqu ymm3, ymmword ptr [rcx-60h]
        }
        _RCX -= 128;
        v50 -= 128LL;
        __asm
        {
          vmovdqa ymmword ptr [r9], ymm0
          vmovdqa ymmword ptr [r9-20h], ymm1
          vmovdqa ymmword ptr [r9-40h], ymm2
          vmovdqa ymmword ptr [r9-60h], ymm3
        }
        _R9 -= 128;
      }
      while ( v50 > 0x80 );
      __asm
      {
        vmovdqu ymmword ptr [rdi], ymm4
        vmovdqu ymmword ptr [rdi+20h], ymm5
        vmovdqu ymmword ptr [rdi+40h], ymm6
        vmovdqu ymmword ptr [rdi+60h], ymm7
        vmovdqu ymmword ptr [r11], ymm8
        vzeroupper
      }
    }
    else
    {
      do
      {
        __asm
        {
          prefetcht0 byte ptr [rcx-100h]
          prefetcht0 byte ptr [rcx-140h]
          prefetcht0 byte ptr [rcx-180h]
          prefetcht0 byte ptr [rcx-1C0h]
          vmovdqu ymm0, ymmword ptr [rcx]
          vmovdqu ymm1, ymmword ptr [rcx-20h]
          vmovdqu ymm2, ymmword ptr [rcx-40h]
          vmovdqu ymm3, ymmword ptr [rcx-60h]
        }
        _RCX -= 128;
        v50 -= 128LL;
        __asm
        {
          vmovntdq ymmword ptr [r9], ymm0
          vmovntdq ymmword ptr [r9-20h], ymm1
          vmovntdq ymmword ptr [r9-40h], ymm2
          vmovntdq ymmword ptr [r9-60h], ymm3
        }
        _R9 -= 128;
      }
      while ( v50 > 0x80 );
      _mm_sfence();
      __asm
      {
        vmovdqu ymmword ptr [rdi], ymm4
        vmovdqu ymmword ptr [rdi+20h], ymm5
        vmovdqu ymmword ptr [rdi+40h], ymm6
        vmovdqu ymmword ptr [rdi+60h], ymm7
        vmovdqu ymmword ptr [r11], ymm8
        vzeroupper
      }
    }
    return result;
  }
  if ( (unsigned __int8)_RDX >= 0x10u )
  {
    __asm
    {
      vmovdqu xmm0, xmmword ptr [rsi]
      vmovdqu xmm1, xmmword ptr [rsi+rdx-10h]
      vmovdqu xmmword ptr [rdi], xmm0
      vmovdqu xmmword ptr [rdi+rdx-10h], xmm1
    }
  }
  else if ( (unsigned __int8)_RDX >= 8u )
  {
    v8 = *(__int64 *)((char *)_RSI + _RDX - 8);
    v9 = *_RSI;
    *(__int64 *)((char *)_RDI + _RDX - 8) = v8;
    *_RDI = v9;
  }
  else if ( (unsigned __int8)_RDX >= 4u )
  {
    v10 = *(_DWORD *)((char *)_RSI + _RDX - 4);
    v11 = *(_DWORD *)_RSI;
    *(_DWORD *)((char *)_RDI + _RDX - 4) = v10;
    *(_DWORD *)_RDI = v11;
  }
  else if ( (unsigned __int8)_RDX > 1u )
  {
    v12 = *(_WORD *)((char *)_RSI + _RDX - 2);
    v13 = *(_WORD *)_RSI;
    *(_WORD *)((char *)_RDI + _RDX - 2) = v12;
    *(_WORD *)_RDI = v13;
  }
  else if ( (_BYTE)_RDX )
  {
    *(_BYTE *)_RDI = *(_BYTE *)_RSI;
  }
  return result;
}
// 4AB828: using guessed type __int64 _x86_shared_non_temporal_threshold;

//----- (000000000043B600) ----------------------------------------------------
void _mempcpy_avx512_unaligned()
{
  JUMPOUT(0x43B617LL);
}
// 43B60A: control flows out of bounds to 43B617

//----- (000000000043B610) ----------------------------------------------------
__int64 __fastcall _memmove_avx512_unaligned(__int64 _RDI, __int64 _RSI, unsigned __int64 _RDX)
{
  __int64 result; // rax

  result = _RDI;
  if ( _RDX < 0x40 )
    JUMPOUT(0x43B6C1LL);
  if ( _RDX > 0x80 )
    JUMPOUT(0x43B74BLL);
  __asm
  {
    vmovdqu64 zmm0, zmmword ptr [rsi]
    vmovdqu64 zmm1, zmmword ptr [rsi+rdx-40h]
    vmovdqu64 zmmword ptr [rdi], zmm0
    vmovdqu64 zmmword ptr [rdi+rdx-40h], zmm1
    vzeroupper
  }
  return result;
}
// 43B61B: control flows out of bounds to 43B6C1
// 43B628: control flows out of bounds to 43B74B
// 43B610: unsupported processor register 'zmm0'

//----- (000000000043B650) ----------------------------------------------------
void _mempcpy_avx512_unaligned_erms()
{
  JUMPOUT(0x43B667LL);
}
// 43B65A: control flows out of bounds to 43B667

//----- (000000000043B660) ----------------------------------------------------
__int64 *__fastcall _memmove_avx512_unaligned_erms(__int64 *_RDI, __int64 *_RSI, unsigned __int64 _RDX)
{
  __int64 *result; // rax
  __int64 v10; // rcx
  __int64 v11; // rsi
  int v12; // ecx
  int v13; // esi
  __int16 v14; // cx
  __int16 v15; // si
  __int64 v35; // r8
  unsigned __int64 v38; // rdx
  __int64 v49; // r8
  unsigned __int64 v52; // rdx

  result = _RDI;
  if ( _RDX >= 0x40 )
  {
    if ( _RDX <= 0x80 )
    {
      __asm
      {
        vmovdqu64 zmm0, zmmword ptr [rsi]
        vmovdqu64 zmm1, zmmword ptr [rsi+rdx-40h]
        vmovdqu64 zmmword ptr [rdi], zmm0
        vmovdqu64 zmmword ptr [rdi+rdx-40h], zmm1
        vzeroupper
      }
      return result;
    }
    if ( _RDX > 0x2000 )
    {
      if ( _RDX < _x86_shared_non_temporal_threshold )
      {
        if ( _RDI < _RSI )
          goto LABEL_8;
        if ( _RDI == _RSI )
          return result;
        if ( _RDI >= (__int64 *)((char *)_RSI + _RDX) )
        {
LABEL_8:
          qmemcpy(_RDI, _RSI, _RDX);
          return result;
        }
        goto LABEL_33;
      }
    }
    else if ( _RDX <= 0x200 )
    {
      if ( _RDX < 0x100 )
      {
        __asm
        {
          vmovdqu64 zmm0, zmmword ptr [rsi]
          vmovdqu64 zmm1, zmmword ptr [rsi+40h]
          vmovdqu64 zmm2, zmmword ptr [rsi+rdx-40h]
          vmovdqu64 zmm3, zmmword ptr [rsi+rdx-80h]
          vmovdqu64 zmmword ptr [rdi], zmm0
          vmovdqu64 zmmword ptr [rdi+40h], zmm1
          vmovdqu64 zmmword ptr [rdi+rdx-40h], zmm2
          vmovdqu64 zmmword ptr [rdi+rdx-80h], zmm3
          vzeroupper
        }
      }
      else
      {
        __asm
        {
          vmovdqu64 zmm0, zmmword ptr [rsi]
          vmovdqu64 zmm1, zmmword ptr [rsi+40h]
          vmovdqu64 zmm2, zmmword ptr [rsi+80h]
          vmovdqu64 zmm3, zmmword ptr [rsi+0C0h]
          vmovdqu64 zmm4, zmmword ptr [rsi+rdx-40h]
          vmovdqu64 zmm5, zmmword ptr [rsi+rdx-80h]
          vmovdqu64 zmm6, zmmword ptr [rsi+rdx-0C0h]
          vmovdqu64 zmm7, zmmword ptr [rsi+rdx-100h]
          vmovdqu64 zmmword ptr [rdi], zmm0
          vmovdqu64 zmmword ptr [rdi+40h], zmm1
          vmovdqu64 zmmword ptr [rdi+80h], zmm2
          vmovdqu64 zmmword ptr [rdi+0C0h], zmm3
          vmovdqu64 zmmword ptr [rdi+rdx-40h], zmm4
          vmovdqu64 zmmword ptr [rdi+rdx-80h], zmm5
          vmovdqu64 zmmword ptr [rdi+rdx-0C0h], zmm6
          vmovdqu64 zmmword ptr [rdi+rdx-100h], zmm7
          vzeroupper
        }
      }
      return result;
    }
    if ( _RDI <= _RSI )
    {
      if ( _RDI != _RSI )
      {
        __asm
        {
          vmovdqu64 zmm4, zmmword ptr [rsi]
          vmovdqu64 zmm5, zmmword ptr [rsi+rdx-40h]
          vmovdqu64 zmm6, zmmword ptr [rsi+rdx-80h]
          vmovdqu64 zmm7, zmmword ptr [rsi+rdx-0C0h]
          vmovdqu64 zmm8, zmmword ptr [rsi+rdx-100h]
        }
        _R11 = _RDI;
        _RCX = (char *)_RDI + _RDX - 64;
        v35 = ((unsigned __int8)_RDI & 0x3F) - 64LL;
        _RSI = (char *)_RSI - v35;
        _RDI = (char *)_RDI - v35;
        v38 = v35 + _RDX;
        if ( v38 <= _x86_shared_non_temporal_threshold || _RSI < &_RDI[v38] )
        {
          do
          {
            __asm
            {
              vmovdqu64 zmm0, zmmword ptr [rsi]
              vmovdqu64 zmm1, zmmword ptr [rsi+40h]
              vmovdqu64 zmm2, zmmword ptr [rsi+80h]
              vmovdqu64 zmm3, zmmword ptr [rsi+0C0h]
            }
            _RSI += 256;
            v38 -= 256LL;
            __asm
            {
              vmovdqa64 zmmword ptr [rdi], zmm0
              vmovdqa64 zmmword ptr [rdi+40h], zmm1
              vmovdqa64 zmmword ptr [rdi+80h], zmm2
              vmovdqa64 zmmword ptr [rdi+0C0h], zmm3
            }
            _RDI += 256;
          }
          while ( v38 > 0x100 );
          __asm
          {
            vmovdqu64 zmmword ptr [rcx], zmm5
            vmovdqu64 zmmword ptr [rcx-40h], zmm6
            vmovdqu64 zmmword ptr [rcx-80h], zmm7
            vmovdqu64 zmmword ptr [rcx-0C0h], zmm8
            vmovdqu64 zmmword ptr [r11], zmm4
            vzeroupper
          }
        }
        else
        {
          do
          {
            __asm
            {
              prefetcht0 byte ptr [rsi+200h]
              prefetcht0 byte ptr [rsi+240h]
              prefetcht0 byte ptr [rsi+280h]
              prefetcht0 byte ptr [rsi+2C0h]
              prefetcht0 byte ptr [rsi+300h]
              prefetcht0 byte ptr [rsi+340h]
              prefetcht0 byte ptr [rsi+380h]
              prefetcht0 byte ptr [rsi+3C0h]
              vmovdqu64 zmm0, zmmword ptr [rsi]
              vmovdqu64 zmm1, zmmword ptr [rsi+40h]
              vmovdqu64 zmm2, zmmword ptr [rsi+80h]
              vmovdqu64 zmm3, zmmword ptr [rsi+0C0h]
            }
            _RSI += 256;
            v38 -= 256LL;
            __asm
            {
              vmovntdq zmmword ptr [rdi], zmm0
              vmovntdq zmmword ptr [rdi+40h], zmm1
              vmovntdq zmmword ptr [rdi+80h], zmm2
              vmovntdq zmmword ptr [rdi+0C0h], zmm3
            }
            _RDI += 256;
          }
          while ( v38 > 0x100 );
          _mm_sfence();
          __asm
          {
            vmovdqu64 zmmword ptr [rcx], zmm5
            vmovdqu64 zmmword ptr [rcx-40h], zmm6
            vmovdqu64 zmmword ptr [rcx-80h], zmm7
            vmovdqu64 zmmword ptr [rcx-0C0h], zmm8
            vmovdqu64 zmmword ptr [r11], zmm4
            vzeroupper
          }
        }
      }
      return result;
    }
LABEL_33:
    __asm
    {
      vmovdqu64 zmm4, zmmword ptr [rsi]
      vmovdqu64 zmm5, zmmword ptr [rsi+40h]
      vmovdqu64 zmm6, zmmword ptr [rsi+80h]
      vmovdqu64 zmm7, zmmword ptr [rsi+0C0h]
      vmovdqu64 zmm8, zmmword ptr [rsi+rdx-40h]
    }
    _R11 = (char *)_RDI + _RDX - 64;
    v49 = ((_BYTE)_RDI + (_BYTE)_RDX - 64) & 0x3F;
    _RCX = (char *)_RSI + _RDX - v49 - 64;
    _R9 = &_R11[-v49];
    v52 = _RDX - v49;
    if ( v52 <= _x86_shared_non_temporal_threshold || _R9 < &_RCX[v52] )
    {
      do
      {
        __asm
        {
          vmovdqu64 zmm0, zmmword ptr [rcx]
          vmovdqu64 zmm1, zmmword ptr [rcx-40h]
          vmovdqu64 zmm2, zmmword ptr [rcx-80h]
          vmovdqu64 zmm3, zmmword ptr [rcx-0C0h]
        }
        _RCX -= 256;
        v52 -= 256LL;
        __asm
        {
          vmovdqa64 zmmword ptr [r9], zmm0
          vmovdqa64 zmmword ptr [r9-40h], zmm1
          vmovdqa64 zmmword ptr [r9-80h], zmm2
          vmovdqa64 zmmword ptr [r9-0C0h], zmm3
        }
        _R9 -= 256;
      }
      while ( v52 > 0x100 );
      __asm
      {
        vmovdqu64 zmmword ptr [rdi], zmm4
        vmovdqu64 zmmword ptr [rdi+40h], zmm5
        vmovdqu64 zmmword ptr [rdi+80h], zmm6
        vmovdqu64 zmmword ptr [rdi+0C0h], zmm7
        vmovdqu64 zmmword ptr [r11], zmm8
        vzeroupper
      }
    }
    else
    {
      do
      {
        __asm
        {
          prefetcht0 byte ptr [rcx-200h]
          prefetcht0 byte ptr [rcx-240h]
          prefetcht0 byte ptr [rcx-280h]
          prefetcht0 byte ptr [rcx-2C0h]
          prefetcht0 byte ptr [rcx-300h]
          prefetcht0 byte ptr [rcx-340h]
          prefetcht0 byte ptr [rcx-380h]
          prefetcht0 byte ptr [rcx-3C0h]
          vmovdqu64 zmm0, zmmword ptr [rcx]
          vmovdqu64 zmm1, zmmword ptr [rcx-40h]
          vmovdqu64 zmm2, zmmword ptr [rcx-80h]
          vmovdqu64 zmm3, zmmword ptr [rcx-0C0h]
        }
        _RCX -= 256;
        v52 -= 256LL;
        __asm
        {
          vmovntdq zmmword ptr [r9], zmm0
          vmovntdq zmmword ptr [r9-40h], zmm1
          vmovntdq zmmword ptr [r9-80h], zmm2
          vmovntdq zmmword ptr [r9-0C0h], zmm3
        }
        _R9 -= 256;
      }
      while ( v52 > 0x100 );
      _mm_sfence();
      __asm
      {
        vmovdqu64 zmmword ptr [rdi], zmm4
        vmovdqu64 zmmword ptr [rdi+40h], zmm5
        vmovdqu64 zmmword ptr [rdi+80h], zmm6
        vmovdqu64 zmmword ptr [rdi+0C0h], zmm7
        vmovdqu64 zmmword ptr [r11], zmm8
        vzeroupper
      }
    }
    return result;
  }
  if ( (unsigned __int8)_RDX >= 0x20u )
  {
    __asm
    {
      vmovdqu ymm0, ymmword ptr [rsi]
      vmovdqu ymm1, ymmword ptr [rsi+rdx-20h]
      vmovdqu ymmword ptr [rdi], ymm0
      vmovdqu ymmword ptr [rdi+rdx-20h], ymm1
      vzeroupper
    }
  }
  else if ( (unsigned __int8)_RDX >= 0x10u )
  {
    __asm
    {
      vmovdqu xmm0, xmmword ptr [rsi]
      vmovdqu xmm1, xmmword ptr [rsi+rdx-10h]
      vmovdqu xmmword ptr [rdi], xmm0
      vmovdqu xmmword ptr [rdi+rdx-10h], xmm1
    }
  }
  else if ( (unsigned __int8)_RDX >= 8u )
  {
    v10 = *(__int64 *)((char *)_RSI + _RDX - 8);
    v11 = *_RSI;
    *(__int64 *)((char *)_RDI + _RDX - 8) = v10;
    *_RDI = v11;
  }
  else if ( (unsigned __int8)_RDX >= 4u )
  {
    v12 = *(_DWORD *)((char *)_RSI + _RDX - 4);
    v13 = *(_DWORD *)_RSI;
    *(_DWORD *)((char *)_RDI + _RDX - 4) = v12;
    *(_DWORD *)_RDI = v13;
  }
  else if ( (unsigned __int8)_RDX > 1u )
  {
    v14 = *(_WORD *)((char *)_RSI + _RDX - 2);
    v15 = *(_WORD *)_RSI;
    *(_WORD *)((char *)_RDI + _RDX - 2) = v14;
    *(_WORD *)_RDI = v15;
  }
  else if ( (_BYTE)_RDX )
  {
    *(_BYTE *)_RDI = *(_BYTE *)_RSI;
  }
  return result;
}
// 43B660: unsupported processor register 'zmm0'
// 4AB828: using guessed type __int64 _x86_shared_non_temporal_threshold;

//----- (000000000043BB40) ----------------------------------------------------
void bzero()
{
  JUMPOUT(0x43BB88LL);
}
// 43BB4E: control flows out of bounds to 43BB88

//----- (000000000043BB50) ----------------------------------------------------
void _wmemset_sse2_unaligned()
{
  JUMPOUT(0x43BB88LL);
}
// 43BB64: control flows out of bounds to 43BB88

//----- (000000000043BB70) ----------------------------------------------------
__m128i *__fastcall _memset_sse2_unaligned(__m128i *a1, unsigned int a2, unsigned __int64 a3)
{
  __m128i v3; // xmm0
  __m128i *result; // rax
  __m128i v5; // xmm0
  __m128i v6; // xmm0

  v3 = _mm_cvtsi32_si128(a2);
  result = a1;
  v5 = _mm_unpacklo_epi8(v3, v3);
  v6 = _mm_shuffle_epi32(_mm_unpacklo_epi16(v5, v5), 0);
  if ( a3 < 0x10 )
    JUMPOUT(0x43BC95LL);
  if ( a3 > 0x20 )
    JUMPOUT(0x43BC1CLL);
  *(__m128i *)((char *)&a1[-1] + a3) = v6;
  *a1 = v6;
  return result;
}
// 43BB8C: control flows out of bounds to 43BC95
// 43BB96: control flows out of bounds to 43BC1C

//----- (000000000043BBB0) ----------------------------------------------------
void *__fastcall _memset_chk_erms(void *a1, __int64 a2, unsigned __int64 a3, unsigned __int64 a4, u32 *a5, __int64 a6)
{
  if ( a4 < a3 )
    _chk_fail((__int64)a1, a2, a3, a4, a5, a6);
  return _memset_erms(a1, a2, a3);
}

//----- (000000000043BBC0) ----------------------------------------------------
void *__fastcall _memset_erms(void *a1, char a2, unsigned __int64 a3)
{
  if ( a3 )
    memset(a1, a2, a3);
  return a1;
}

//----- (000000000043BBE0) ----------------------------------------------------
__m128i *__fastcall _memset_sse2_unaligned_erms(__m128i *a1, unsigned int a2, unsigned __int64 a3)
{
  __m128i v3; // xmm0
  __m128i *result; // rax
  __m128i v5; // xmm0
  __m128i v6; // xmm0
  _OWORD *v7; // rcx
  unsigned __int64 i; // rdx

  v3 = _mm_cvtsi32_si128(a2);
  result = a1;
  v5 = _mm_unpacklo_epi8(v3, v3);
  v6 = _mm_shuffle_epi32(_mm_unpacklo_epi16(v5, v5), 0);
  if ( a3 < 0x10 )
  {
    if ( (unsigned __int8)a3 >= 8u )
    {
      *(__int64 *)((char *)&a1->m128i_i64[-1] + a3) = v6.m128i_i64[0];
      a1->m128i_i64[0] = v6.m128i_i64[0];
    }
    else if ( (unsigned __int8)a3 >= 4u )
    {
      *(__int32 *)((char *)&a1->m128i_i32[-1] + a3) = v6.m128i_i32[0];
      a1->m128i_i32[0] = v6.m128i_i32[0];
    }
    else if ( (unsigned __int8)a3 > 1u )
    {
      *(__int16 *)((char *)&a1->m128i_i16[-1] + a3) = v6.m128i_i16[0];
      a1->m128i_i16[0] = v6.m128i_i16[0];
    }
    else if ( (_BYTE)a3 )
    {
      a1->m128i_i8[0] = v6.m128i_i8[0];
    }
  }
  else if ( a3 > 0x20 )
  {
    if ( a3 > 0x800 )
      JUMPOUT(0x43BBCDLL);
    if ( a3 > 0x40 )
    {
      *a1 = v6;
      v7 = (_OWORD *)((unsigned __int64)&a1[4] & 0xFFFFFFFFFFFFFFC0LL);
      *(__m128i *)((char *)&a1[-1] + a3) = v6;
      a1[1] = v6;
      *(__m128i *)((char *)&a1[-2] + a3) = v6;
      a1[2] = v6;
      *(__m128i *)((char *)&a1[-3] + a3) = v6;
      a1[3] = v6;
      *(__m128i *)((char *)&a1[-4] + a3) = v6;
      for ( i = ((unsigned __int64)a1->m128i_u64 + a3) & 0xFFFFFFFFFFFFFFC0LL; (_OWORD *)i != v7; v7 += 4 )
      {
        *v7 = v6;
        v7[1] = v6;
        v7[2] = v6;
        v7[3] = v6;
      }
    }
    else
    {
      *a1 = v6;
      a1[1] = v6;
      *(__m128i *)((char *)&a1[-1] + a3) = v6;
      *(__m128i *)((char *)&a1[-2] + a3) = v6;
    }
  }
  else
  {
    *(__m128i *)((char *)&a1[-1] + a3) = v6;
    *a1 = v6;
  }
  return result;
}
// 43BC1A: control flows out of bounds to 43BBCD

//----- (000000000043BCD0) ----------------------------------------------------
void __fastcall _wmemset_avx2_unaligned(__int64 a1, int _ESI)
{
  __asm
  {
    vmovd   xmm0, esi
    vpbroadcastd ymm0, xmm0
  }
  JUMPOUT(0x43BD00LL);
}
// 43BCE4: control flows out of bounds to 43BD00

//----- (000000000043BCF0) ----------------------------------------------------
__int64 __fastcall _memset_avx2_unaligned(__int64 _RDI, int _ESI, unsigned __int64 _RDX)
{
  __int64 result; // rax

  __asm { vmovd   xmm0, esi }
  result = _RDI;
  __asm { vpbroadcastb ymm0, xmm0 }
  if ( _RDX < 0x20 )
    JUMPOUT(0x43BDFELL);
  if ( _RDX > 0x40 )
    JUMPOUT(0x43BD77LL);
  __asm
  {
    vmovdqu ymmword ptr [rdi+rdx-20h], ymm0
    vmovdqu ymmword ptr [rdi], ymm0
    vzeroupper
  }
  return result;
}
// 43BD04: control flows out of bounds to 43BDFE
// 43BD0E: control flows out of bounds to 43BD77

//----- (000000000043BD20) ----------------------------------------------------
void *__fastcall _memset_avx2_erms(void *a1, char a2, unsigned __int64 a3)
{
  __asm { vzeroupper }
  memset(a1, a2, a3);
  return a1;
}

//----- (000000000043BD40) ----------------------------------------------------
_QWORD *__fastcall _memset_avx2_unaligned_erms(_QWORD *_RDI, int _ESI, unsigned __int64 _RDX)
{
  _QWORD *result; // rax
  unsigned __int64 v7; // rdx

  __asm { vmovd   xmm0, esi }
  result = _RDI;
  __asm { vpbroadcastb ymm0, xmm0 }
  if ( _RDX < 0x20 )
  {
    if ( (unsigned __int8)_RDX >= 0x10u )
    {
      __asm
      {
        vmovdqu xmmword ptr [rdi+rdx-10h], xmm0
        vmovdqu xmmword ptr [rdi], xmm0
        vzeroupper
      }
    }
    else
    {
      __asm { vmovq   rcx, xmm0 }
      if ( (unsigned __int8)_RDX >= 8u )
      {
        *(_QWORD *)((char *)_RDI + _RDX - 8) = _RCX;
        *_RDI = _RCX;
        __asm { vzeroupper }
      }
      else if ( (unsigned __int8)_RDX >= 4u )
      {
        *(_DWORD *)((char *)_RDI + _RDX - 4) = _RCX;
        *(_DWORD *)_RDI = _RCX;
        __asm { vzeroupper }
      }
      else if ( (unsigned __int8)_RDX > 1u )
      {
        *(_WORD *)((char *)_RDI + _RDX - 2) = _RCX;
        *(_WORD *)_RDI = _RCX;
        __asm { vzeroupper }
      }
      else
      {
        if ( (_BYTE)_RDX )
          *(_BYTE *)_RDI = _RCX;
        __asm { vzeroupper }
      }
    }
  }
  else
  {
    if ( _RDX <= 0x40 )
    {
      __asm
      {
        vmovdqu ymmword ptr [rdi+rdx-20h], ymm0
        vmovdqu ymmword ptr [rdi], ymm0
        vzeroupper
      }
      return result;
    }
    if ( _RDX > 0x800 )
      JUMPOUT(0x43BD24LL);
    if ( _RDX <= 0x80 )
    {
      __asm
      {
        vmovdqu ymmword ptr [rdi], ymm0
        vmovdqu ymmword ptr [rdi+20h], ymm0
        vmovdqu ymmword ptr [rdi+rdx-20h], ymm0
        vmovdqu ymmword ptr [rdi+rdx-40h], ymm0
      }
LABEL_7:
      __asm { vzeroupper }
      return result;
    }
    __asm { vmovdqu ymmword ptr [rdi], ymm0 }
    _RCX = (unsigned __int64)(_RDI + 16) & 0xFFFFFFFFFFFFFF80LL;
    __asm
    {
      vmovdqu ymmword ptr [rdi+rdx-20h], ymm0
      vmovdqu ymmword ptr [rdi+20h], ymm0
      vmovdqu ymmword ptr [rdi+rdx-40h], ymm0
      vmovdqu ymmword ptr [rdi+40h], ymm0
      vmovdqu ymmword ptr [rdi+rdx-60h], ymm0
      vmovdqu ymmword ptr [rdi+60h], ymm0
      vmovdqu ymmword ptr [rdi+rdx-80h], ymm0
    }
    v7 = ((unsigned __int64)_RDI + _RDX) & 0xFFFFFFFFFFFFFF80LL;
    if ( _RCX == v7 )
      goto LABEL_7;
    do
    {
      __asm
      {
        vmovdqa ymmword ptr [rcx], ymm0
        vmovdqa ymmword ptr [rcx+20h], ymm0
        vmovdqa ymmword ptr [rcx+40h], ymm0
        vmovdqa ymmword ptr [rcx+60h], ymm0
      }
      _RCX += 128LL;
    }
    while ( v7 != _RCX );
    __asm { vzeroupper }
  }
  return result;
}
// 43BD75: control flows out of bounds to 43BD24

//----- (000000000043BE50) ----------------------------------------------------
void __fastcall _wmemset_avx512_unaligned(__int64 a1, int _ESI)
{
  __asm
  {
    vmovd   xmm0, esi
    vpbroadcastd xmm0, xmm0
    vpbroadcastq zmm0, xmm0
  }
  JUMPOUT(0x43BE86LL);
}
// 43BE6A: control flows out of bounds to 43BE86
// 43BE50: unsupported processor register 'zmm0'

//----- (000000000043BE70) ----------------------------------------------------
__int64 __fastcall _memset_avx512_unaligned(__int64 _RDI, int _ESI, unsigned __int64 _RDX)
{
  __int64 result; // rax

  __asm { vmovd   xmm0, esi }
  result = _RDI;
  __asm
  {
    vpbroadcastb xmm0, xmm0
    vpbroadcastq zmm0, xmm0
  }
  if ( _RDX < 0x40 )
    JUMPOUT(0x43BFC1LL);
  if ( _RDX > 0x80 )
    JUMPOUT(0x43BF14LL);
  __asm
  {
    vmovdqu64 zmmword ptr [rdi+rdx-40h], zmm0
    vmovdqu64 zmmword ptr [rdi], zmm0
    vzeroupper
  }
  return result;
}
// 43BE8A: control flows out of bounds to 43BFC1
// 43BE97: control flows out of bounds to 43BF14
// 43BE70: unsupported processor register 'zmm0'

//----- (000000000043BEB0) ----------------------------------------------------
void *__fastcall _memset_avx512_erms(void *a1, char a2, unsigned __int64 a3)
{
  __asm { vzeroupper }
  memset(a1, a2, a3);
  return a1;
}

//----- (000000000043BED0) ----------------------------------------------------
_QWORD *__fastcall _memset_avx512_unaligned_erms(_QWORD *_RDI, int _ESI, unsigned __int64 _RDX)
{
  _QWORD *result; // rax
  unsigned __int64 v8; // rdx

  __asm { vmovd   xmm0, esi }
  result = _RDI;
  __asm
  {
    vpbroadcastb xmm0, xmm0
    vpbroadcastq zmm0, xmm0
  }
  if ( _RDX < 0x40 )
  {
    if ( (unsigned __int8)_RDX >= 0x20u )
    {
      __asm
      {
        vmovdqu ymmword ptr [rdi+rdx-20h], ymm0
        vmovdqu ymmword ptr [rdi], ymm0
        vzeroupper
      }
    }
    else if ( (unsigned __int8)_RDX >= 0x10u )
    {
      __asm
      {
        vmovdqu xmmword ptr [rdi+rdx-10h], xmm0
        vmovdqu xmmword ptr [rdi], xmm0
        vzeroupper
      }
    }
    else
    {
      __asm { vmovq   rcx, xmm0 }
      if ( (unsigned __int8)_RDX >= 8u )
      {
        *(_QWORD *)((char *)_RDI + _RDX - 8) = _RCX;
        *_RDI = _RCX;
        __asm { vzeroupper }
      }
      else if ( (unsigned __int8)_RDX >= 4u )
      {
        *(_DWORD *)((char *)_RDI + _RDX - 4) = _RCX;
        *(_DWORD *)_RDI = _RCX;
        __asm { vzeroupper }
      }
      else if ( (unsigned __int8)_RDX > 1u )
      {
        *(_WORD *)((char *)_RDI + _RDX - 2) = _RCX;
        *(_WORD *)_RDI = _RCX;
        __asm { vzeroupper }
      }
      else
      {
        if ( (_BYTE)_RDX )
          *(_BYTE *)_RDI = _RCX;
        __asm { vzeroupper }
      }
    }
  }
  else
  {
    if ( _RDX <= 0x80 )
    {
      __asm
      {
        vmovdqu64 zmmword ptr [rdi+rdx-40h], zmm0
        vmovdqu64 zmmword ptr [rdi], zmm0
        vzeroupper
      }
      return result;
    }
    if ( _RDX > 0x800 )
      JUMPOUT(0x43BEB4LL);
    if ( _RDX <= 0x100 )
    {
      __asm
      {
        vmovdqu64 zmmword ptr [rdi], zmm0
        vmovdqu64 zmmword ptr [rdi+40h], zmm0
        vmovdqu64 zmmword ptr [rdi+rdx-40h], zmm0
        vmovdqu64 zmmword ptr [rdi+rdx-80h], zmm0
      }
LABEL_7:
      __asm { vzeroupper }
      return result;
    }
    __asm { vmovdqu64 zmmword ptr [rdi], zmm0 }
    _RCX = (unsigned __int64)(_RDI + 32) & 0xFFFFFFFFFFFFFF00LL;
    __asm
    {
      vmovdqu64 zmmword ptr [rdi+rdx-40h], zmm0
      vmovdqu64 zmmword ptr [rdi+40h], zmm0
      vmovdqu64 zmmword ptr [rdi+rdx-80h], zmm0
      vmovdqu64 zmmword ptr [rdi+80h], zmm0
      vmovdqu64 zmmword ptr [rdi+rdx-0C0h], zmm0
      vmovdqu64 zmmword ptr [rdi+0C0h], zmm0
      vmovdqu64 zmmword ptr [rdi+rdx-100h], zmm0
    }
    v8 = ((unsigned __int64)_RDI + _RDX) & 0xFFFFFFFFFFFFFF00LL;
    if ( _RCX == v8 )
      goto LABEL_7;
    do
    {
      __asm
      {
        vmovdqa64 zmmword ptr [rcx], zmm0
        vmovdqa64 zmmword ptr [rcx+40h], zmm0
        vmovdqa64 zmmword ptr [rcx+80h], zmm0
        vmovdqa64 zmmword ptr [rcx+0C0h], zmm0
      }
      _RCX += 256LL;
    }
    while ( v8 != _RCX );
    __asm { vzeroupper }
  }
  return result;
}
// 43BF12: control flows out of bounds to 43BEB4
// 43BED0: unsupported processor register 'zmm0'

//----- (000000000043C030) ----------------------------------------------------
__int64 __fastcall handle_amd(int a1)
{
  __int64 v11; // rdi

  _RAX = 0x80000000LL;
  __asm { cpuid }
  if ( a1 <= 196 )
  {
    if ( a1 > 190 )
    {
      if ( (unsigned int)_RAX > 0x80000005 )
      {
        _RAX = 2147483654LL;
        __asm { cpuid }
        goto LABEL_6;
      }
    }
    else if ( (unsigned int)_RAX > 0x80000004 )
    {
      _RAX = 2147483653LL;
      __asm { cpuid }
      if ( a1 <= 187 )
        a1 += 3;
LABEL_6:
      v11 = (unsigned int)(a1 - 188);
      if ( (unsigned int)v11 <= 8 )
        __asm { jmp     rax }
      _assert_fail((__int64)"! \"cannot happen\"", (__int64)"../sysdeps/x86/cacheinfo.c", 0x1B1u, "handle_amd");
    }
  }
  return 0LL;
}

//----- (000000000043C240) ----------------------------------------------------
__int64 __fastcall intel_check_word_isra_0(int a1, int a2, _BYTE *a3, _BYTE *a4, _DWORD *a5, _DWORD *a6)
{
  int v7; // ebp
  unsigned __int64 v8; // r10
  unsigned __int64 v9; // rdx
  unsigned __int64 v10; // rax
  unsigned __int8 *v11; // r11
  int v12; // edx
  int v19; // edx
  int v20; // esi
  int v23; // eax
  int v24; // eax
  int v25; // eax

  if ( a2 < 0 )
    return 0LL;
  v7 = 3 * ((a1 - 185) / 3);
  if ( !a2 )
    return 0LL;
  while ( 1 )
  {
    if ( (unsigned __int8)a2 == 64 )
    {
      *a4 = 1;
      if ( v7 == 9 )
        return 0LL;
      goto LABEL_5;
    }
    if ( (unsigned __int8)a2 == 255 )
      break;
    if ( (unsigned __int8)a2 == 73 && v7 == 9 )
    {
      if ( *a5 == 15 && *a6 == 6 )
      {
        a1 -= 3;
        v7 = 6;
      }
      else
      {
        v7 = 9;
      }
    }
    v8 = 68LL;
    v9 = 0LL;
    while ( 1 )
    {
      v10 = (v9 + v8) >> 1;
      v11 = (unsigned __int8 *)&intel_02_known + 8 * v10;
      if ( (_BYTE)a2 == *v11 )
        break;
      if ( (unsigned __int8)a2 < *v11 )
        v8 = (v9 + v8) >> 1;
      else
        v9 = v10 + 1;
      if ( v8 <= v9 )
        goto LABEL_5;
    }
    v12 = v11[3];
    if ( v12 == v7 )
    {
      v25 = a1 - 185 - v7;
      if ( a1 - 185 == v7 )
        return *((unsigned int *)v11 + 1);
      if ( v25 == 1 )
        return v11[1];
      if ( v25 != 2 )
        _assert_fail((__int64)"offset == 2", (__int64)"../sysdeps/x86/cacheinfo.c", 0xF0u, "intel_check_word");
      return v11[2];
    }
    if ( (_BYTE)v12 == 6 )
    {
      a2 = (unsigned int)a2 >> 8;
      *a3 = 1;
      if ( !a2 )
        return 0LL;
    }
    else
    {
LABEL_5:
      a2 = (unsigned int)a2 >> 8;
      if ( !a2 )
        return 0LL;
    }
  }
  _RAX = 4LL;
  __asm { cpuid }
  v19 = _RAX & 0x1F;
  if ( (_RAX & 0x1F) == 0 )
    return 0LL;
  v20 = 0;
  while ( 1 )
  {
    v23 = (unsigned __int8)_RAX >> 5;
    if ( v19 == 1 && v23 == 1 )
    {
      if ( v7 == 3 )
        goto LABEL_35;
      goto LABEL_30;
    }
    if ( v19 != 2 || v23 != 1 )
      break;
    if ( !v7 )
      goto LABEL_35;
LABEL_30:
    ++v20;
    _RAX = 4LL;
    __asm { cpuid }
    v19 = _RAX & 0x1F;
    if ( (_RAX & 0x1F) == 0 )
      return 0LL;
  }
  if ( (v23 != 2 || v7 != 6) && (v23 != 3 || v7 != 9) && (v23 != 4 || v7 != 12) )
    goto LABEL_30;
LABEL_35:
  v24 = a1 - 185 - v7;
  if ( a1 - 185 == v7 )
    return ((((unsigned int)_RBX >> 12) & 0x3FF) + 1)
         * ((int)_RCX + 1)
         * ((_RBX & 0xFFF) + 1)
         * (((unsigned int)_RBX >> 22) + 1);
  if ( v24 == 1 )
    return ((unsigned int)_RBX >> 22) + 1;
  if ( v24 != 2 )
    _assert_fail((__int64)"offset == 2", (__int64)"../sysdeps/x86/cacheinfo.c", 0xC0u, "intel_check_word");
  return (_RBX & 0xFFF) + 1;
}

//----- (000000000043C4C0) ----------------------------------------------------
__int64 __fastcall handle_intel_constprop_1(int a1)
{
  unsigned int v1; // er14
  int v7; // er15
  int v8; // esi
  __int64 result; // rax
  int v10; // [rsp+8h] [rbp-50h]
  unsigned int v11; // [rsp+Ch] [rbp-4Ch]
  unsigned __int8 v12; // [rsp+16h] [rbp-42h] BYREF
  char v13; // [rsp+17h] [rbp-41h] BYREF
  unsigned __int64 v14; // [rsp+18h] [rbp-40h]

  v14 = __readfsqword(0x28u);
  if ( (unsigned int)dword_4AAE04 <= 1 )
    return -1LL;
  v12 = 0;
  v1 = 1;
  v13 = 0;
  v11 = 1;
  while ( 1 )
  {
    _RAX = 2LL;
    __asm { cpuid }
    v10 = _RDX;
    v7 = _RCX;
    v8 = _RAX;
    if ( v1 == 1 )
    {
      LOBYTE(v8) = 0;
      v11 = (unsigned __int8)_RAX;
    }
    result = intel_check_word_isra_0(a1, v8, &v13, &v12, &dword_4AAE3C - 1, &dword_4AAE3C);
    if ( result )
      break;
    result = intel_check_word_isra_0(a1, _RBX, &v13, &v12, &dword_4AAE3C - 1, &dword_4AAE3C);
    if ( result )
      break;
    result = intel_check_word_isra_0(a1, v7, &v13, &v12, &dword_4AAE3C - 1, &dword_4AAE3C);
    if ( result )
      break;
    result = intel_check_word_isra_0(a1, v10, &v13, &v12, &dword_4AAE3C - 1, &dword_4AAE3C);
    if ( result )
      break;
    if ( v11 <= v1 )
    {
      if ( (unsigned int)(a1 - 191) <= 5 )
        return -(__int64)v12;
      return result;
    }
    ++v1;
  }
  return result;
}
// 4AAE04: using guessed type int dword_4AAE04;
// 4AAE3C: using guessed type int dword_4AAE3C;

//----- (000000000043C620) ----------------------------------------------------
__int64 __fastcall _cache_sysconf(int a1)
{
  if ( dl_x86_cpu_features == 1 )
    return handle_intel_constprop_1(a1);
  if ( dl_x86_cpu_features == 2 )
    return handle_amd(a1);
  return 0LL;
}
// 4AAE00: using guessed type int dl_x86_cpu_features;

//----- (000000000043C650) ----------------------------------------------------
__int64 __fastcall _strcasecmp_l_nonascii(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v3; // rcx
  __int64 v4; // rdx
  __int64 v5; // r9
  __int64 result; // rax

  if ( a1 == a2 )
    return 0LL;
  v3 = *(_QWORD *)(a3 + 112);
  v4 = 0LL;
  do
  {
    v5 = *(unsigned __int8 *)(a1 + v4);
    result = (unsigned int)(*(_DWORD *)(v3 + 4 * v5) - *(_DWORD *)(v3 + 4LL * *(unsigned __int8 *)(a2 + v4)));
    if ( (_DWORD)result )
      break;
    ++v4;
  }
  while ( (_BYTE)v5 );
  return result;
}

//----- (000000000043C6A0) ----------------------------------------------------
__int64 __fastcall wmempcpy(__int64 a1, __int64 a2, __int64 a3)
{
  return j_mempcpy(a1, a2, 4 * a3);
}
// 4010B0: using guessed type __int64 __fastcall j_mempcpy(_QWORD, _QWORD, _QWORD);

//----- (000000000043C6B0) ----------------------------------------------------
__int64 __fastcall mbsrtowcs(__int64 a1, __int64 *a2, __int64 a3, void *a4, __int64 a5, __int64 a6)
{
  if ( !a4 )
    a4 = &state;
  return _mbsrtowcs_l(a1, a2, a3, (__int64)a4, (__int64 *)__readfsqword(0xFFFFFFA8), a6);
}

//----- (000000000043C6E0) ----------------------------------------------------
__int64 *__fastcall nl_cleanup_ctype(__int64 a1, __int64 a2, __int64 a3, __int64 a4, u32 *a5, unsigned __int64 a6)
{
  __int64 *v6; // rbx
  __int64 v7; // rsi
  __int64 v8; // rsi
  __int64 v9; // rdx
  __int64 v10; // rcx
  u32 *v11; // r8
  unsigned __int64 v12; // r9
  __int64 v13; // rdx
  __int64 v14; // rcx
  u32 *v15; // r8
  unsigned __int64 v16; // r9
  __int64 *result; // rax

  v6 = *(__int64 **)(a1 + 40);
  if ( v6 )
  {
    *(_QWORD *)(a1 + 40) = 0LL;
    v7 = v6[3];
    *(_QWORD *)(a1 + 32) = 0LL;
    _gconv_close_transform(v6[2], v7, a3, a4, a5, a6);
    v8 = v6[1];
    _gconv_close_transform(*v6, v8, v9, v10, v11, v12);
    return free((__int64)v6, v8, v13, v14, v15, v16);
  }
  return result;
}
// 43C712: variable 'v9' is possibly undefined
// 43C712: variable 'v10' is possibly undefined
// 43C712: variable 'v11' is possibly undefined
// 43C712: variable 'v12' is possibly undefined
// 43C71B: variable 'v13' is possibly undefined
// 43C71B: variable 'v14' is possibly undefined
// 43C71B: variable 'v15' is possibly undefined
// 43C71B: variable 'v16' is possibly undefined

//----- (000000000043C730) ----------------------------------------------------
__int64 __fastcall _wcsmbs_getfct(
        unsigned __int8 *a1,
        unsigned __int8 *a2,
        unsigned __int64 *a3,
        __int64 a4,
        __int64 a5,
        u32 a6)
{
  __int64 v7; // rdx
  __int64 v8; // rcx
  u32 *v9; // r8
  unsigned __int64 v10; // r9
  __int64 result; // rax
  unsigned __int64 v12; // [rsp+8h] [rbp-20h] BYREF
  __int64 v13[3]; // [rsp+10h] [rbp-18h] BYREF

  v13[1] = __readfsqword(0x28u);
  if ( (unsigned int)_gconv_find_transform(a1, a2, v13, (__int64 *)&v12, 0LL, a6) )
    return 0LL;
  result = v13[0];
  if ( v12 > 1 )
  {
    _gconv_close_transform(v13[0], v12, v7, v8, v9, v10);
    return 0LL;
  }
  else
  {
    *a3 = v12;
  }
  return result;
}
// 43C793: variable 'v7' is possibly undefined
// 43C793: variable 'v8' is possibly undefined
// 43C793: variable 'v9' is possibly undefined
// 43C793: variable 'v10' is possibly undefined

//----- (000000000043C7B0) ----------------------------------------------------
unsigned __int64 __fastcall _wcsmbs_load_conv(__int64 a1, __int64 a2, __int64 a3, __int64 a4, u32 *a5, __int64 a6)
{
  u32 *v7; // r12
  unsigned __int8 *v8; // rsi
  __int64 v9; // rcx
  __int64 v10; // r9
  char *v11; // rax
  unsigned __int64 i; // r8
  char v13; // dl
  unsigned __int64 v14; // rax
  __int16 v15; // dx
  __int64 *v16; // rax
  unsigned int v17; // edx
  __int64 v18; // rax
  unsigned __int8 *v19; // rdx
  unsigned __int8 *v20; // rsi
  __int64 v21; // rax
  __int64 v22; // rdx
  __int64 v23; // rcx
  u32 *v24; // r8
  unsigned __int64 v25; // r9
  __int64 v26; // rax
  _QWORD *v28; // rax
  void *v29; // rsp
  unsigned __int64 v30; // rdx
  signed __int64 v31; // rsi
  unsigned int v32; // edi
  __int64 v33; // [rsp+0h] [rbp-1038h]
  __int64 v34; // [rsp+8h] [rbp-1030h] BYREF
  unsigned __int8 v35[7]; // [rsp+10h] [rbp-1028h] BYREF
  __int64 v36; // [rsp+1008h] [rbp-30h] BYREF
  unsigned __int64 v37; // [rsp+1010h] [rbp-28h]

  v37 = __readfsqword(0x28u);
  if ( !*(_QWORD *)(a1 + 40) )
  {
    v7 = calloc(1LL, 0x20uLL, a3, a4, a5, a6);
    if ( v7 )
    {
      v8 = "TRANSLIT";
      v9 = *(_QWORD *)(a1 + 176);
      v10 = *(_DWORD *)(a1 + 52) != 0 ? 8 : 0;
      if ( !*(_DWORD *)(a1 + 52) )
        v8 = byte_493255;
      v11 = *(char **)(a1 + 176);
      for ( i = 0LL; ; i += v13 == 47 )
      {
        v13 = *v11;
        if ( !*v11 )
          break;
        ++v11;
      }
      v14 = (unsigned __int64)&v11[(-(__int64)(*(_DWORD *)(a1 + 52) == 0) & 0xFFFFFFFFFFFFFFF8LL) + 11 - v9 + 23];
      v15 = v14 & 0xFFF0;
      v16 = (__int64 *)((char *)&v36 - (v14 & 0xFFFFFFFFFFFFF000LL));
      if ( &v36 != v16 )
      {
        while ( &v34 != v16 )
          ;
      }
      v17 = v15 & 0xFFF;
      if ( v17 )
      {
        v29 = alloca(v17);
        *(__int64 *)((char *)&v33 + v17) = *(__int64 *)((char *)&v33 + v17);
      }
      v18 = *(char *)v9;
      if ( (_BYTE)v18 )
      {
        v19 = v35;
        do
        {
          ++v9;
          *v19++ = dword_4866E0[v18];
          v18 = *(char *)v9;
        }
        while ( (_BYTE)v18 );
      }
      else
      {
        v19 = v35;
      }
      if ( i <= 1 )
      {
        *v19 = 47;
        if ( i )
        {
          ++v19;
        }
        else
        {
          v28 = v19 + 2;
          v19[1] = 47;
          if ( v10 )
          {
            v9 = (unsigned int)v10;
            if ( (unsigned int)v10 >= 8 )
            {
              v30 = (unsigned __int64)(v19 + 10) & 0xFFFFFFFFFFFFFFF8LL;
              *v28 = *(_QWORD *)v8;
              *(_QWORD *)((char *)v28 + (unsigned int)v10 - 8) = *(_QWORD *)&v8[(unsigned int)v10 - 8];
              v31 = v8 - ((unsigned __int8 *)v28 - v30);
              v9 = ((_DWORD)v10 + (_DWORD)v28 - (_DWORD)v30) & 0xFFFFFFF8;
              if ( (unsigned int)v9 >= 8 )
              {
                v9 = ((_DWORD)v10 + (_DWORD)v28 - (_DWORD)v30) & 0xFFFFFFF8;
                v32 = 0;
                do
                {
                  i = v32;
                  v32 += 8;
                  *(_QWORD *)(v30 + i) = *(_QWORD *)(v31 + i);
                }
                while ( v32 < (unsigned int)v9 );
              }
            }
            else if ( (v10 & 4) != 0 )
            {
              *(_DWORD *)v28 = *(_DWORD *)v8;
              *(_DWORD *)((char *)v28 + (unsigned int)v10 - 4) = *(_DWORD *)&v8[(unsigned int)v10 - 4];
            }
            else
            {
              *(_BYTE *)v28 = *v8;
              if ( (v10 & 2) != 0 )
                *(_WORD *)&v19[(unsigned int)v10] = *(_WORD *)&v8[(unsigned int)v10 - 2];
            }
            v19 = (unsigned __int8 *)v28 + v10;
          }
          else
          {
            v19 += 2;
          }
        }
      }
      *v19 = 0;
      v20 = v35;
      v21 = _wcsmbs_getfct("INTERNAL", v35, (unsigned __int64 *)v7 + 1, v9, i, v10);
      *(_QWORD *)v7 = v21;
      if ( v21 )
      {
        v20 = "INTERNAL";
        v26 = _wcsmbs_getfct(v35, "INTERNAL", (unsigned __int64 *)v7 + 3, v23, (__int64)v24, v25);
        *((_QWORD *)v7 + 2) = v26;
        if ( v26 )
        {
LABEL_18:
          *(_QWORD *)(a1 + 40) = v7;
          *(_QWORD *)(a1 + 32) = nl_cleanup_ctype;
          return __readfsqword(0x28u) ^ v37;
        }
        if ( *(_QWORD *)v7 )
        {
          v20 = (unsigned __int8 *)*((_QWORD *)v7 + 1);
          _gconv_close_transform(*(_QWORD *)v7, (__int64)v20, v22, v23, v24, v25);
        }
      }
      else if ( *((_QWORD *)v7 + 2) )
      {
        goto LABEL_18;
      }
      free((__int64)v7, (__int64)v20, v22, v23, v24, v25);
    }
    *(_QWORD *)(a1 + 40) = &_wcsmbs_gconv_fcts_c;
  }
  return __readfsqword(0x28u) ^ v37;
}
// 43CA27: conditional instruction was optimized away because ecx.4 is in (1..FF)
// 43C92B: variable 'v23' is possibly undefined
// 43C92B: variable 'v24' is possibly undefined
// 43C92B: variable 'v25' is possibly undefined
// 43C98E: variable 'v22' is possibly undefined
// 4866E0: using guessed type unsigned int dword_4866E0[256];
// 493255: using guessed type unsigned __int8 byte_493255[1707];
// 4A5140: using guessed type void *_wcsmbs_gconv_fcts_c;

//----- (000000000043CAB0) ----------------------------------------------------
__int64 __fastcall _wcsmbs_clone_conv(__m128i *a1, __int64 a2, __int64 a3, __int64 a4, u32 *a5, __int64 a6)
{
  __int64 v6; // rbp
  const __m128i *v7; // rax
  __m128i v8; // xmm1
  __int64 v9; // rax
  bool v10; // zf
  __int64 result; // rax

  v6 = *(_QWORD *)__readfsqword(0xFFFFFFA0);
  v7 = *(const __m128i **)(v6 + 40);
  if ( !v7 )
  {
    if ( (char **)v6 == &nl_C_LC_CTYPE )
    {
      v7 = (const __m128i *)&_wcsmbs_gconv_fcts_c;
    }
    else
    {
      _wcsmbs_load_conv(v6, a2, a3, a4, a5, a6);
      v7 = *(const __m128i **)(v6 + 40);
    }
  }
  *a1 = _mm_loadu_si128(v7);
  v8 = _mm_loadu_si128(v7 + 1);
  v9 = a1->m128i_i64[0];
  v10 = *(_QWORD *)a1->m128i_i64[0] == 0LL;
  a1[1] = v8;
  if ( !v10 )
    ++*(_DWORD *)(v9 + 16);
  result = a1[1].m128i_i64[0];
  if ( *(_QWORD *)result )
    ++*(_DWORD *)(result + 16);
  return result;
}
// 4A5140: using guessed type void *_wcsmbs_gconv_fcts_c;
// 4A51E0: using guessed type char *nl_C_LC_CTYPE;

//----- (000000000043CB40) ----------------------------------------------------
__int64 __fastcall _wcsmbs_named_conv(__int64 *a1, unsigned __int8 *a2, __int64 a3, __int64 a4, __int64 a5, u32 a6)
{
  __int64 v6; // rax
  __int64 v7; // r8
  u32 v8; // er9
  unsigned int v9; // ecx
  __int64 v10; // rax
  __int64 v11; // rdx
  u32 *v12; // r8
  unsigned __int64 v13; // r9

  v6 = _wcsmbs_getfct("INTERNAL", a2, (unsigned __int64 *)a1 + 1, a4, a5, a6);
  v9 = 1;
  *a1 = v6;
  if ( v6 )
  {
    v10 = _wcsmbs_getfct(a2, "INTERNAL", (unsigned __int64 *)a1 + 3, 1LL, v7, v8);
    v9 = 0;
    a1[2] = v10;
    if ( !v10 )
    {
      _gconv_close_transform(*a1, a1[1], v11, 0LL, v12, v13);
      return 1;
    }
  }
  return v9;
}
// 43CB7B: variable 'v7' is possibly undefined
// 43CB7B: variable 'v8' is possibly undefined
// 43CB9F: variable 'v11' is possibly undefined
// 43CB9F: variable 'v12' is possibly undefined
// 43CB9F: variable 'v13' is possibly undefined

//----- (000000000043CBB0) ----------------------------------------------------
__int64 __fastcall _mbsrtowcs_l(__int64 a1, __int64 *a2, __int64 a3, __int64 a4, __int64 *a5, __int64 a6)
{
  __int64 v6; // rbx
  __int64 v7; // rsi
  void **v8; // rax
  void *v9; // r12
  __int64 (__fastcall *v10)(void *, char **, __int64 *, __int64, _QWORD, char *, _QWORD, __int64); // rbp
  __int64 v11; // r13
  __int64 v12; // rbx
  unsigned __int64 v13; // rax
  __int64 v14; // rcx
  __int64 v15; // rdx
  __int64 v16; // rbx
  __int64 v17; // rdx
  __int64 v20; // [rsp+10h] [rbp-1A8h]
  char v22[8]; // [rsp+28h] [rbp-190h] BYREF
  __int64 v23; // [rsp+30h] [rbp-188h] BYREF
  __int64 v24; // [rsp+38h] [rbp-180h] BYREF
  char *v25; // [rsp+40h] [rbp-178h] BYREF
  char *v26; // [rsp+48h] [rbp-170h]
  __int64 v27; // [rsp+50h] [rbp-168h]
  int v28; // [rsp+58h] [rbp-160h]
  __int64 *v29; // [rsp+60h] [rbp-158h]
  char v30[256]; // [rsp+70h] [rbp-148h] BYREF
  _QWORD v31[9]; // [rsp+170h] [rbp-48h] BYREF

  v6 = *a5;
  v7 = a3;
  v31[1] = __readfsqword(0x28u);
  v8 = *(void ***)(v6 + 40);
  v28 = 1;
  v27 = 1LL;
  v29 = (__int64 *)a4;
  if ( !v8 )
  {
    if ( (char **)v6 == &nl_C_LC_CTYPE )
    {
      v8 = &_wcsmbs_gconv_fcts_c;
    }
    else
    {
      _wcsmbs_load_conv(v6, a3, a3, a4, (u32 *)a5, a6);
      v8 = *(void ***)(v6 + 40);
      v7 = a3;
    }
  }
  v9 = *v8;
  v10 = (__int64 (__fastcall *)(void *, char **, __int64 *, __int64, _QWORD, char *, _QWORD, __int64))*((_QWORD *)*v8 + 5);
  if ( *(_QWORD *)*v8 )
    v10 = (__int64 (__fastcall *)(void *, char **, __int64 *, __int64, _QWORD, char *, _QWORD, __int64))(__readfsqword(0x30u) ^ __ROR8__(v10, 17));
  v11 = *a2;
  v23 = *a2;
  if ( a1 )
  {
    v25 = (char *)a1;
    v26 = (char *)(a1 + 4 * v7);
    if ( !v7 )
      return 0LL;
    do
    {
      v12 = v11 + j_strnlen(v11, v7) + 1;
      dl_mcount_wrapper_check((__int64)v10);
      v13 = v10(v9, &v25, &v23, v12, 0LL, v22, 0LL, 1LL);
      v11 = v23;
      v14 = (__int64)v25;
      if ( (_DWORD)v13 != 4 && (_DWORD)v13 != 7 )
        break;
      if ( v23 != v12 )
        break;
      if ( !*(_BYTE *)(v12 - 1) )
        break;
      v7 = (v26 - v25) >> 2;
    }
    while ( v7 );
    v15 = (__int64)&v25[-a1] >> 2;
    *a2 = v23;
    v16 = v15;
    if ( (v13 & 0xFFFFFFFB) != 0 )
    {
      if ( (unsigned int)(v13 - 4) <= 3 )
        goto LABEL_19;
LABEL_23:
      _assert_fail(
        (__int64)"status == __GCONV_OK || status == __GCONV_EMPTY_INPUT || status == __GCONV_ILLEGAL_INPUT || status == _"
                 "_GCONV_INCOMPLETE_INPUT || status == __GCONV_FULL_OUTPUT",
        (__int64)"mbsrtowcs_l.c",
        0x99u,
        "__mbsrtowcs_l");
    }
    if ( !*(_DWORD *)(v14 - 4) )
    {
      if ( !v15 )
        _assert_fail((__int64)"result > 0", (__int64)"mbsrtowcs_l.c", 0x8Du, "__mbsrtowcs_l");
      if ( *(_DWORD *)v29 )
        _assert_fail((__int64)"__mbsinit (data.__statep)", (__int64)"mbsrtowcs_l.c", 0x8Eu, "__mbsrtowcs_l");
      *a2 = 0LL;
LABEL_17:
      --v16;
    }
  }
  else
  {
    v16 = 0LL;
    v20 = v11 + j_strlen_ifunc(v11) + 1;
    v24 = *v29;
    v29 = &v24;
    v26 = (char *)v31;
    do
    {
      v25 = v30;
      dl_mcount_wrapper_check((__int64)v10);
      v13 = v10(v9, &v25, &v23, v20, 0LL, v22, 0LL, 1LL);
      v16 += (v25 - v30) >> 2;
    }
    while ( (_DWORD)v13 == 5 );
    if ( (v13 & 0xFFFFFFFB) == 0 )
    {
      if ( *((_DWORD *)v25 - 1) )
        _assert_fail(
          (__int64)"((wchar_t *) data.__outbuf)[-1] == L'\\0'",
          (__int64)"mbsrtowcs_l.c",
          0x5Eu,
          "__mbsrtowcs_l");
      goto LABEL_17;
    }
  }
  if ( (_DWORD)v13 != 0 && (unsigned int)(v13 - 4) > 3 )
    goto LABEL_23;
LABEL_19:
  if ( (unsigned int)v13 > 7 || (v17 = 177LL, !_bittest64(&v17, v13)) )
  {
    v16 = -1LL;
    __writefsdword(0xFFFFFFC0, 0x54u);
  }
  return v16;
}
// 401028: using guessed type __int64 __fastcall j_strnlen(_QWORD, _QWORD);
// 4010C8: using guessed type __int64 __fastcall j_strlen_ifunc(_QWORD);
// 4A5140: using guessed type void *_wcsmbs_gconv_fcts_c;
// 4A51E0: using guessed type char *nl_C_LC_CTYPE;
// 43CBB0: using guessed type char var_190[8];

//----- (000000000043CF20) ----------------------------------------------------
void __noreturn exit(int status)
{
  unsigned __int64 v1; // rax
  unsigned int v2; // er9
  unsigned __int64 v3; // rax
  int v4; // edx
  unsigned int v5; // er9

  v3 = sys_exit_group(status);
  if ( v3 > 0xFFFFFFFFFFFFF000LL )
    __writefsdword(v5, -(int)v3);
  v1 = sys_exit(v4);
  if ( v1 > 0xFFFFFFFFFFFFF000LL )
    __writefsdword(v2, -(int)v1);
  __halt();
}
// 43CF44: variable 'v4' is possibly undefined
// 43CF72: variable 'v2' is possibly undefined
// 43CF60: variable 'v5' is possibly undefined

//----- (000000000043CF80) ----------------------------------------------------
__int64 __fastcall _sysconf_check_spec(__int64 a1)
{
  unsigned int v1; // er14
  char *v2; // rax
  const char *v3; // rbx
  __int64 v4; // r12
  __int64 v5; // r15
  __int64 v6; // rcx
  char *v7; // rsi
  __int16 v8; // cx
  unsigned int v9; // ecx
  char *v10; // rax
  int v11; // eax
  void *v13; // rsp
  char v15[4088]; // [rsp+8h] [rbp-10D0h] BYREF
  stat v16; // [rsp+1008h] [rbp-D0h] BYREF
  unsigned __int64 v17; // [rsp+10A0h] [rbp-38h]

  v17 = __readfsqword(0x28u);
  v1 = __readfsdword(0xFFFFFFC0);
  v2 = secure_getenv("GETCONF_DIR");
  if ( v2 )
  {
    v3 = v2;
    v4 = j_strlen_ifunc(v2);
  }
  else
  {
    v4 = 20LL;
    v3 = "/usr/libexec/getconf";
  }
  v5 = j_strlen_ifunc(a1);
  v6 = v4 + v5 + 26;
  v7 = (char *)&v16 - (v6 & 0xFFFFFFFFFFFFF000LL);
  v8 = v6 & 0xFFF0;
  if ( &v16 != (stat *)v7 )
  {
    while ( v15 != v7 )
      ;
  }
  v9 = v8 & 0xFFF;
  if ( v9 )
  {
    v13 = alloca(v9);
    *(_QWORD *)&v15[v9 - 8] = *(_QWORD *)&v15[v9 - 8];
  }
  v10 = (char *)j_mempcpy(v15, v3, v4);
  qmemcpy(v10, "/POSIX_V6_", 10);
  j_memcpy(v10 + 10, a1, v5 + 1);
  v11 = xstat(1u, v15, &v16);
  __writefsdword(0xFFFFFFC0, v1);
  return ((__int64)v11 >> 63) | 1;
}
// 401040: using guessed type __int64 __fastcall j_memcpy(_QWORD, _QWORD, _QWORD);
// 4010B0: using guessed type __int64 __fastcall j_mempcpy(_QWORD, _QWORD, _QWORD);
// 4010C8: using guessed type __int64 __fastcall j_strlen_ifunc(_QWORD);
// 43CF80: using guessed type struct stat var_D0;

//----- (000000000043D0D0) ----------------------------------------------------
__int64 __fastcall sysconf(int a1, __int64 a2, int a3)
{
  unsigned __int64 tv_sec; // rdx
  signed __int64 v4; // rax
  unsigned int v6; // eax
  unsigned int v7; // er12
  signed __int64 nocancel; // rbp
  int v9; // eax
  int v10; // eax
  struct timespec v11; // [rsp+0h] [rbp-68h] BYREF
  char v12[40]; // [rsp+10h] [rbp-58h] BYREF
  unsigned __int64 v13; // [rsp+38h] [rbp-30h]

  v13 = __readfsqword(0x28u);
  if ( (unsigned int)(a1 - 185) <= 0xE )
    return _cache_sysconf(a1);
  if ( a1 != 34 )
  {
    if ( a1 > 34 )
    {
      if ( a1 >= 138 )
      {
        tv_sec = 200809LL;
        if ( a1 <= 139 )
          return tv_sec;
        if ( a1 == 149 )
        {
          v4 = sys_clock_getres(1, &v11);
          if ( (unsigned int)v4 > 0xFFFFF000 )
            return -1LL;
          return tv_sec;
        }
      }
      goto LABEL_20;
    }
    if ( !a1 )
    {
      v9 = getrlimit64(3u, (struct rlimit64 *)&v11);
      tv_sec = 0x20000LL;
      if ( !v9 && v11.tv_sec > 0x7FFFFuLL )
        return (unsigned __int64)v11.tv_sec >> 2;
      return tv_sec;
    }
    if ( a1 == 3 )
    {
      v6 = _open_nocancel("/proc/sys/kernel/ngroups_max", 0, a3);
      tv_sec = 0x10000LL;
      v7 = v6;
      if ( v6 != -1 )
        goto LABEL_15;
      return tv_sec;
    }
LABEL_20:
    if ( (unsigned int)a1 <= 0xF6 )
      __asm { jmp     rax }
    tv_sec = -1LL;
    __writefsdword(0xFFFFFFC0, 0x16u);
    return tv_sec;
  }
  v10 = getrlimit64(0xBu, (struct rlimit64 *)&v11);
  tv_sec = v11.tv_sec;
  if ( v10 )
  {
    v7 = _open_nocancel("/proc/sys/kernel/rtsig-max", 0, v11.tv_sec);
    if ( v7 == -1 )
      return -1LL;
LABEL_15:
    while ( 1 )
    {
      nocancel = _read_nocancel(v7, v12, 0x1FuLL);
      if ( nocancel != -1 )
        break;
      if ( __readfsdword(0xFFFFFFC0) != 4 )
      {
        _close_nocancel(v7);
        goto LABEL_20;
      }
    }
    _close_nocancel(v7);
    if ( nocancel <= 0 )
      goto LABEL_20;
    v12[nocancel] = 0;
    tv_sec = strtoq(v12, (char **)&v11, 10);
    if ( (char *)v11.tv_sec == v12 || *(_BYTE *)v11.tv_sec && *(_BYTE *)v11.tv_sec != 10 )
      goto LABEL_20;
  }
  return tv_sec;
}
// 43D15E: variable 'tv_sec' is possibly undefined
// 43D0D0: using guessed type char var_58[40];

//----- (000000000043D4C0) ----------------------------------------------------
unsigned __int64 sched_yield()
{
  unsigned __int64 result; // rax

  result = sys_sched_yield();
  if ( result >= 0xFFFFFFFFFFFFF001LL )
  {
    __writefsdword(0xFFFFFFC0, -(int)result);
    return -1LL;
  }
  return result;
}

//----- (000000000043D4F0) ----------------------------------------------------
rlim64_t _get_child_max()
{
  rlimit64 v1; // [rsp+0h] [rbp-28h] BYREF
  unsigned __int64 v2; // [rsp+18h] [rbp-10h]

  v2 = __readfsqword(0x28u);
  if ( (unsigned int)getrlimit64(6u, &v1) )
    return -1LL;
  else
    return v1.rlim_cur;
}
// 43D4F0: using guessed type struct rlimit64 var_28;

//----- (000000000043D550) ----------------------------------------------------
unsigned __int64 __fastcall xstat(unsigned int a1, const char *a2, struct stat *a3)
{
  unsigned __int64 result; // rax

  if ( a1 > 1 )
  {
    __writefsdword(0xFFFFFFC0, 0x16u);
    return 0xFFFFFFFFLL;
  }
  else
  {
    result = sys_stat(a2, a3);
    if ( result > 0xFFFFFFFFFFFFF000LL )
    {
      __writefsdword(0xFFFFFFC0, -(int)result);
      return 0xFFFFFFFFLL;
    }
  }
  return result;
}

//----- (000000000043D5B0) ----------------------------------------------------
unsigned __int64 __fastcall fxstat(unsigned int a1, unsigned int a2, struct stat *a3)
{
  unsigned __int64 result; // rax

  if ( a1 > 1 )
  {
    __writefsdword(0xFFFFFFC0, 0x16u);
    return 0xFFFFFFFFLL;
  }
  else
  {
    result = sys_fstat(a2, a3);
    if ( result > 0xFFFFFFFFFFFFF000LL )
    {
      __writefsdword(0xFFFFFFC0, -(int)result);
      return 0xFFFFFFFFLL;
    }
  }
  return result;
}

//----- (000000000043D600) ----------------------------------------------------
unsigned __int64 __fastcall open64(const char *filename, int flags, int a3)
{
  int v3; // er10
  unsigned __int64 result; // rax
  unsigned __int64 v5; // rax
  u32 v6; // edx
  __int64 v7; // rcx
  u32 *v8; // r8
  u32 v9; // er9
  int mode; // [rsp+8h] [rbp-60h]
  unsigned int modea; // [rsp+8h] [rbp-60h]

  v3 = flags & 0x40;
  if ( (flags & 0x40) != 0 || (flags & 0x410000) == 4259840 )
  {
    v3 = a3;
    if ( !_libc_multiple_threads )
    {
LABEL_4:
      result = sys_openat(-100, filename, flags, v3);
      if ( result > 0xFFFFFFFFFFFFF000LL )
      {
        __writefsdword(0xFFFFFFC0, -(int)result);
        return 0xFFFFFFFFLL;
      }
      return result;
    }
  }
  else if ( !_libc_multiple_threads )
  {
    goto LABEL_4;
  }
  mode = v3;
  _libc_enable_asynccancel();
  v5 = sys_openat(-100, filename, flags, mode);
  if ( v5 > 0xFFFFFFFFFFFFF000LL )
  {
    v6 = -64;
    __writefsdword(0xFFFFFFC0, -(int)v5);
    LODWORD(v5) = -1;
  }
  modea = v5;
  _libc_disable_asynccancel((char)v8, (__int64)filename, v6, v7, v8, v9);
  return modea;
}
// 43D6E5: variable 'v8' is possibly undefined
// 43D6E5: variable 'v6' is possibly undefined
// 43D6E5: variable 'v7' is possibly undefined
// 43D6E5: variable 'v9' is possibly undefined
// 4AB820: using guessed type int _libc_multiple_threads;

//----- (000000000043D730) ----------------------------------------------------
unsigned __int64 __fastcall read(unsigned int fd, char *buf, size_t count)
{
  unsigned __int64 result; // rax
  unsigned __int64 v5; // rax
  u32 v6; // edx
  __int64 v7; // rcx
  u32 *v8; // r8
  u32 v9; // er9
  unsigned __int64 v10; // [rsp+0h] [rbp-20h]

  if ( _libc_multiple_threads )
  {
    _libc_enable_asynccancel();
    v5 = sys_read(fd, buf, count);
    if ( v5 > 0xFFFFFFFFFFFFF000LL )
    {
      v6 = -64;
      __writefsdword(0xFFFFFFC0, -(int)v5);
      v5 = -1LL;
    }
    v10 = v5;
    _libc_disable_asynccancel((char)v8, (__int64)buf, v6, v7, v8, v9);
    return v10;
  }
  else
  {
    result = sys_read(fd, buf, count);
    if ( result > 0xFFFFFFFFFFFFF000LL )
    {
      __writefsdword(0xFFFFFFC0, -(int)result);
      return -1LL;
    }
  }
  return result;
}
// 43D784: variable 'v8' is possibly undefined
// 43D784: variable 'v6' is possibly undefined
// 43D784: variable 'v7' is possibly undefined
// 43D784: variable 'v9' is possibly undefined
// 4AB820: using guessed type int _libc_multiple_threads;

//----- (000000000043D7D0) ----------------------------------------------------
unsigned __int64 __fastcall write(unsigned int fd, const char *buf, size_t count)
{
  unsigned __int64 result; // rax
  unsigned __int64 v5; // rax
  u32 v6; // edx
  __int64 v7; // rcx
  u32 *v8; // r8
  u32 v9; // er9
  unsigned __int64 v10; // [rsp+0h] [rbp-20h]

  if ( _libc_multiple_threads )
  {
    _libc_enable_asynccancel();
    v5 = sys_write(fd, buf, count);
    if ( v5 > 0xFFFFFFFFFFFFF000LL )
    {
      v6 = -64;
      __writefsdword(0xFFFFFFC0, -(int)v5);
      v5 = -1LL;
    }
    v10 = v5;
    _libc_disable_asynccancel((char)v8, (__int64)buf, v6, v7, v8, v9);
    return v10;
  }
  else
  {
    result = sys_write(fd, buf, count);
    if ( result > 0xFFFFFFFFFFFFF000LL )
    {
      __writefsdword(0xFFFFFFC0, -(int)result);
      return -1LL;
    }
  }
  return result;
}
// 43D827: variable 'v8' is possibly undefined
// 43D827: variable 'v6' is possibly undefined
// 43D827: variable 'v7' is possibly undefined
// 43D827: variable 'v9' is possibly undefined
// 4AB820: using guessed type int _libc_multiple_threads;

//----- (000000000043D870) ----------------------------------------------------
unsigned __int64 __fastcall lseek64(unsigned int a1, off_t a2, unsigned int a3)
{
  unsigned __int64 result; // rax

  result = sys_lseek(a1, a2, a3);
  if ( result > 0xFFFFFFFFFFFFF000LL )
  {
    __writefsdword(0xFFFFFFC0, -(int)result);
    return -1LL;
  }
  return result;
}

//----- (000000000043D8A0) ----------------------------------------------------
char *__fastcall getcwd(__int64 *a1, unsigned __int64 a2, _QWORD *a3, __int64 a4, u32 *a5, __int64 a6)
{
  __int64 *v6; // r15
  unsigned __int64 v7; // rbp
  int v8; // eax
  __int64 *v9; // r14
  unsigned __int64 v10; // rax
  __int64 v11; // rdx
  __int64 v12; // rcx
  u32 *v13; // r8
  unsigned __int64 v14; // r9
  unsigned __int64 v15; // rdx
  char *v16; // rsi
  char *v17; // rbx
  __int64 v18; // rdx
  __int64 v19; // rcx
  u32 *v20; // r8
  unsigned __int64 v21; // r9
  unsigned int v22; // eax
  unsigned __int64 v24; // rbx
  _QWORD *v25; // rdx
  __int64 v26; // rcx
  u32 *v27; // r8
  unsigned __int64 v28; // r9
  __int64 v29; // rdi
  _QWORD *v30; // rdx
  __int64 v31; // rcx
  u32 *v32; // r8
  __int64 v33; // r9
  unsigned int v34; // ebx
  __int64 v35; // [rsp+18h] [rbp-120h]
  unsigned int v36; // [rsp+3Ch] [rbp-FCh]
  __int64 *v37; // [rsp+40h] [rbp-F8h]
  unsigned __int64 v38; // [rsp+F8h] [rbp-40h]

  v6 = a1;
  v7 = a2;
  v38 = __readfsqword(0x28u);
  if ( a2 )
  {
    if ( a1 )
    {
      v9 = a1;
      goto LABEL_10;
    }
  }
  else
  {
    if ( a1 )
    {
      v6 = 0LL;
      __writefsdword(0xFFFFFFC0, 0x16u);
      return (char *)v6;
    }
    v8 = getpagesize();
    LODWORD(a2) = 4096;
    if ( v8 >= 4096 )
      LODWORD(a2) = v8;
    a2 = (int)a2;
  }
  v9 = malloc(a2, a2, a3, a4, a5, a6);
  if ( !v9 )
    return 0LL;
LABEL_10:
  v10 = sys_getcwd((char *)v9, a2);
  if ( v10 > 0xFFFFFFFFFFFFF000LL )
  {
    v22 = -(int)v10;
    __writefsdword(0xFFFFFFC0, v22);
    goto LABEL_21;
  }
  if ( (int)v10 <= 0 )
  {
    if ( !(_DWORD)v10 )
    {
LABEL_50:
      v15 = v7 | (unsigned __int64)a1;
      goto LABEL_13;
    }
    v22 = __readfsdword(0xFFFFFFC0);
LABEL_21:
    if ( v22 != 36 )
    {
      if ( v22 == 34 && !((unsigned __int64)a1 | v7) )
        _assert_fail(
          (__int64)"errno != ERANGE || buf != NULL || size != 0",
          (__int64)"../sysdeps/unix/sysv/linux/getcwd.c",
          0x79u,
          "__getcwd");
      if ( !a1 )
      {
        free((__int64)v9, a2, v11, v12, v13, v14);
        return (char *)v6;
      }
      return 0LL;
    }
    goto LABEL_50;
  }
  v15 = v7 | (unsigned __int64)a1;
  if ( *(_BYTE *)v9 == 47 )
  {
    if ( !v15 )
      v6 = realloc((__int64)v9, (int)v10, 0LL, v12, v13, v14);
    if ( !v6 )
      return (char *)v9;
    return (char *)v6;
  }
LABEL_13:
  if ( v15 )
  {
    if ( v7 )
    {
      v35 = v7;
      v6 = v9;
      v36 = __readfsdword(0xFFFFFFC0);
      goto LABEL_16;
    }
    __writefsdword(0xFFFFFFC0, 0x16u);
    return 0LL;
  }
  free((__int64)v9, a2, 0LL, v12, v13, v14);
  v36 = __readfsdword(0xFFFFFFC0);
  v9 = malloc(0x1001uLL, a2, v30, v31, v32, v33);
  if ( !v9 )
    return 0LL;
  v35 = 4097LL;
  v6 = 0LL;
LABEL_16:
  v16 = (char *)&unk_4836DD;
  v17 = (char *)v9 + v35;
  *((_BYTE *)v9 + v35 - 1) = 0;
  if ( (int)lxstat(1u) < 0 || (v16 = "/", (int)lxstat(1u) < 0) )
  {
    v34 = __readfsdword(0xFFFFFFC0);
    if ( !v6 )
      free((__int64)v9, (__int64)v16, v18, v19, v20, v21);
    __writefsdword(0xFFFFFFC0, v34);
    if ( v7 && !a1 )
    {
      v29 = (__int64)v6;
      v6 = 0LL;
      free(v29, (__int64)v16, v18, v19, v20, v21);
      return (char *)v6;
    }
    return 0LL;
  }
  v37 = (__int64 *)(v17 - 1);
  if ( v37 == (__int64 *)((char *)v9 + v35 - 1) )
  {
    *(v17 - 2) = 47;
    v37 = (__int64 *)(v17 - 2);
  }
  v24 = v17 - (char *)v37;
  j_memmove(v9, v37, v24);
  if ( !v7 )
    v6 = realloc((__int64)v9, v24, v25, v26, v27, v28);
  if ( !v6 )
    v6 = v9;
  __writefsdword(0xFFFFFFC0, v36);
  return (char *)v6;
}
// 43D8F8: variable 'a3' is possibly undefined
// 43D8F8: variable 'a4' is possibly undefined
// 43D8F8: variable 'a5' is possibly undefined
// 43D8F8: variable 'a6' is possibly undefined
// 43DF56: variable 'v25' is possibly undefined
// 43DF56: variable 'v26' is possibly undefined
// 43DF56: variable 'v27' is possibly undefined
// 43DF56: variable 'v28' is possibly undefined
// 43DEA3: variable 'v18' is possibly undefined
// 43DEA3: variable 'v19' is possibly undefined
// 43DEA3: variable 'v20' is possibly undefined
// 43DEA3: variable 'v21' is possibly undefined
// 43DDD3: variable 'v12' is possibly undefined
// 43DDD3: variable 'v13' is possibly undefined
// 43DDD3: variable 'v14' is possibly undefined
// 43DDE6: variable 'v30' is possibly undefined
// 43DDE6: variable 'v31' is possibly undefined
// 43DDE6: variable 'v32' is possibly undefined
// 43DDE6: variable 'v33' is possibly undefined
// 43DE93: variable 'v11' is possibly undefined
// 401030: using guessed type __int64 __fastcall j_memmove(_QWORD, _QWORD, _QWORD);
// 401040: using guessed type __int64 __fastcall j_memcpy(_QWORD, _QWORD, _QWORD);
// 4010C8: using guessed type __int64 __fastcall j_strlen_ifunc(_QWORD);

//----- (000000000043DFC0) ----------------------------------------------------
unsigned __int64 __fastcall _close_nocancel(unsigned int a1)
{
  unsigned __int64 result; // rax

  result = sys_close(a1);
  if ( result > 0xFFFFFFFFFFFFF000LL )
  {
    __writefsdword(0xFFFFFFC0, -(int)result);
    return 0xFFFFFFFFLL;
  }
  return result;
}

//----- (000000000043DFF0) ----------------------------------------------------
unsigned __int64 __fastcall _fcntl64_nocancel_adjusted(unsigned int a1, unsigned int a2, unsigned __int64 a3)
{
  unsigned __int64 result; // rax
  int v4; // [rsp+0h] [rbp-18h] BYREF
  unsigned int v5; // [rsp+4h] [rbp-14h]
  unsigned __int64 v6; // [rsp+8h] [rbp-10h]

  v6 = __readfsqword(0x28u);
  if ( a2 != 9 )
  {
    result = sys_fcntl(a1, a2, a3);
    if ( result <= 0xFFFFFFFFFFFFF000LL )
      return result;
LABEL_7:
    __writefsdword(0xFFFFFFC0, -(int)result);
    return 0xFFFFFFFFLL;
  }
  result = sys_fcntl(a1, 0x10u, (unsigned __int64)&v4);
  if ( (unsigned int)result > 0xFFFFF000 )
    goto LABEL_7;
  result = v5;
  if ( v4 == 2 )
    return -v5;
  return result;
}

//----- (000000000043E080) ----------------------------------------------------
unsigned __int64 __fastcall _fcntl64_nocancel(unsigned int a1, unsigned int a2, unsigned __int64 a3)
{
  return _fcntl64_nocancel_adjusted(a1, a2, a3);
}

//----- (000000000043E0E0) ----------------------------------------------------
unsigned __int64 __fastcall _open_nocancel(const char *filename, int flags, int a3)
{
  int v3; // er10
  unsigned __int64 result; // rax

  v3 = flags & 0x40;
  if ( (flags & 0x40) != 0 || (flags & 0x410000) == 4259840 )
    v3 = a3;
  result = sys_openat(-100, filename, flags, v3);
  if ( result > 0xFFFFFFFFFFFFF000LL )
  {
    __writefsdword(0xFFFFFFC0, -(int)result);
    return 0xFFFFFFFFLL;
  }
  return result;
}

//----- (000000000043E190) ----------------------------------------------------
unsigned __int64 __fastcall _openat_nocancel(int a1, const char *a2, int a3, int a4)
{
  int v4; // er10
  unsigned __int64 result; // rax

  if ( (a3 & 0x40) != 0 || (v4 = 0, (a3 & 0x410000) == 4259840) )
    v4 = a4;
  result = sys_openat(a1, a2, a3, v4);
  if ( result > 0xFFFFFFFFFFFFF000LL )
  {
    __writefsdword(0xFFFFFFC0, -(int)result);
    return 0xFFFFFFFFLL;
  }
  return result;
}

//----- (000000000043E230) ----------------------------------------------------
unsigned __int64 __fastcall _read_nocancel(unsigned int a1, char *a2, size_t a3)
{
  unsigned __int64 result; // rax

  result = sys_read(a1, a2, a3);
  if ( result > 0xFFFFFFFFFFFFF000LL )
  {
    __writefsdword(0xFFFFFFC0, -(int)result);
    return -1LL;
  }
  return result;
}

//----- (000000000043E260) ----------------------------------------------------
unsigned __int64 __fastcall _write_nocancel(unsigned int a1, const char *a2, size_t a3)
{
  unsigned __int64 result; // rax

  result = sys_write(a1, a2, a3);
  if ( result > 0xFFFFFFFFFFFFF000LL )
  {
    __writefsdword(0xFFFFFFC0, -(int)result);
    return -1LL;
  }
  return result;
}

//----- (000000000043E290) ----------------------------------------------------
unsigned __int64 __fastcall getrlimit64(unsigned int resource, struct rlimit64 *old_rlim)
{
  unsigned __int64 result; // rax

  result = sys_prlimit64(0, resource, 0LL, old_rlim);
  if ( result > 0xFFFFFFFFFFFFF000LL )
  {
    __writefsdword(0xFFFFFFC0, -(int)result);
    return 0xFFFFFFFFLL;
  }
  return result;
}

//----- (000000000043E2D0) ----------------------------------------------------
unsigned __int64 __fastcall sbrk(__int64 a1)
{
  unsigned __int64 v1; // rbx
  int v3; // eax

  v1 = _curbrk;
  if ( !_curbrk || _libc_multiple_libcs )
  {
    v3 = brk(0LL);
    v1 = _curbrk;
    if ( v3 < 0 )
      return -1LL;
  }
  if ( !a1 )
    return v1;
  if ( a1 <= 0 )
  {
    if ( -a1 > v1 )
      goto LABEL_6;
  }
  else if ( __CFADD__(a1, v1) )
  {
LABEL_6:
    __writefsdword(0xFFFFFFC0, 0xCu);
    return -1LL;
  }
  if ( (int)brk(v1 + a1) < 0 )
    return -1LL;
  return v1;
}
// 4A97B8: using guessed type int _libc_multiple_libcs;
// 4AB008: using guessed type __int64 _curbrk;

//----- (000000000043E370) ----------------------------------------------------
__int64 getpagesize()
{
  __int64 result; // rax

  result = dl_pagesize;
  if ( !dl_pagesize )
    _assert_fail(
      (__int64)"GLRO(dl_pagesize) != 0",
      (__int64)"../sysdeps/unix/sysv/linux/getpagesize.c",
      0x1Cu,
      "__getpagesize");
  return result;
}
// 4A91F8: using guessed type __int64 dl_pagesize;

//----- (000000000043E3B0) ----------------------------------------------------
__int64 getdtablesize()
{
  int v0; // eax
  unsigned int rlim_cur; // edx
  rlimit64 v3; // [rsp+0h] [rbp-28h] BYREF
  unsigned __int64 v4; // [rsp+18h] [rbp-10h]

  v4 = __readfsqword(0x28u);
  v0 = getrlimit64(7u, &v3);
  rlim_cur = v3.rlim_cur;
  if ( v0 < 0 )
    return 256;
  return rlim_cur;
}
// 43E3B0: using guessed type __int64 __fastcall getdtablesize();
// 43E3B0: using guessed type struct rlimit64 var_28;

//----- (000000000043E410) ----------------------------------------------------
unsigned __int64 __fastcall mmap64(
        unsigned __int64 addr,
        unsigned __int64 len,
        unsigned __int64 prot,
        unsigned __int64 flags,
        unsigned __int64 fd,
        unsigned __int64 off)
{
  unsigned int v6; // er15
  unsigned int v7; // er14
  unsigned int v8; // er12
  unsigned __int64 result; // rax

  if ( (off & 0xFFF) != 0 )
  {
    __writefsdword(0xFFFFFFC0, 0x16u);
    return -1LL;
  }
  v6 = fd;
  v7 = flags;
  v8 = prot;
  if ( !addr && (prot & 4) != 0 && (dword_4AAE4C & 0x10000) != 0 )
  {
    result = sys_mmap(0LL, len, prot, (unsigned int)flags | 0x40, fd, off);
    if ( result <= 0xFFFFFFFFFFFFF000LL )
      return result;
    __writefsdword(0xFFFFFFC0, -(int)result);
  }
  result = sys_mmap(addr, len, v8, v7, v6, off);
  if ( result > 0xFFFFFFFFFFFFF000LL )
  {
    __writefsdword(0xFFFFFFC0, -(int)result);
    return -1LL;
  }
  return result;
}
// 4AAE4C: using guessed type int dword_4AAE4C;

//----- (000000000043E4F0) ----------------------------------------------------
unsigned __int64 __fastcall munmap(unsigned __int64 a1, size_t a2)
{
  unsigned __int64 result; // rax

  result = sys_munmap(a1, a2);
  if ( result >= 0xFFFFFFFFFFFFF001LL )
  {
    __writefsdword(0xFFFFFFC0, -(int)result);
    return -1LL;
  }
  return result;
}

//----- (000000000043E520) ----------------------------------------------------
unsigned __int64 __fastcall mprotect(unsigned __int64 a1, size_t a2, unsigned __int64 a3)
{
  unsigned __int64 result; // rax

  result = sys_mprotect(a1, a2, a3);
  if ( result >= 0xFFFFFFFFFFFFF001LL )
  {
    __writefsdword(0xFFFFFFC0, -(int)result);
    return -1LL;
  }
  return result;
}

//----- (000000000043E550) ----------------------------------------------------
unsigned __int64 __fastcall madvise(unsigned __int64 a1, size_t a2, int a3)
{
  unsigned __int64 result; // rax

  result = sys_madvise(a1, a2, a3);
  if ( result >= 0xFFFFFFFFFFFFF001LL )
  {
    __writefsdword(0xFFFFFFC0, -(int)result);
    return -1LL;
  }
  return result;
}

//----- (000000000043E580) ----------------------------------------------------
__int64 __fastcall trecurse(__int64 a1, void (__fastcall *a2)(__int64, _QWORD), unsigned int a3)
{
  __int64 v4; // rsi
  __int64 v5; // rbx
  __int64 v7; // rdi
  __int64 v8; // rdi

  if ( (*(_QWORD *)(a1 + 8) & 0xFFFFFFFFFFFFFFFELL) != 0 || (v4 = 3LL, *(_QWORD *)(a1 + 16)) )
  {
    v5 = a1;
    a2(a1, 0LL);
    v7 = *(_QWORD *)(a1 + 8) & 0xFFFFFFFFFFFFFFFELL;
    if ( (*(_QWORD *)(v5 + 8) & 0xFFFFFFFFFFFFFFFELL) != 0 )
      trecurse(v7, a2, a3 + 1);
    ((void (__fastcall *)(__int64, __int64, _QWORD))a2)(v5, 1LL, a3);
    v8 = *(_QWORD *)(v5 + 16);
    if ( v8 )
      trecurse(v8, a2, a3 + 1);
    v4 = 2LL;
    a1 = v5;
  }
  return ((__int64 (__fastcall *)(__int64, __int64))a2)(a1, v4);
}

//----- (000000000043E600) ----------------------------------------------------
__int64 *__fastcall tdestroy_recurse(_QWORD *a1, void (__fastcall *a2)(_QWORD))
{
  _QWORD *v3; // rdi
  _QWORD *v4; // rdi
  __int64 v5; // rdx
  __int64 v6; // rcx
  u32 *v7; // r8
  unsigned __int64 v8; // r9

  v3 = (_QWORD *)(a1[1] & 0xFFFFFFFFFFFFFFFELL);
  if ( v3 )
  {
    tdestroy_recurse(v3, a2);
    v4 = (_QWORD *)a1[2];
    if ( !v4 )
      goto LABEL_3;
LABEL_5:
    tdestroy_recurse(v4, a2);
    goto LABEL_3;
  }
  v4 = (_QWORD *)a1[2];
  if ( v4 )
    goto LABEL_5;
LABEL_3:
  a2(*a1);
  return free((__int64)a1, (__int64)a2, v5, v6, v7, v8);
}
// 43E62D: variable 'v5' is possibly undefined
// 43E62D: variable 'v6' is possibly undefined
// 43E62D: variable 'v7' is possibly undefined
// 43E62D: variable 'v8' is possibly undefined

//----- (000000000043E650) ----------------------------------------------------
unsigned __int64 __fastcall maybe_split_for_insert_isra_0(
        __int64 a1,
        _QWORD *a2,
        unsigned __int64 *a3,
        int a4,
        int a5,
        int a6)
{
  unsigned __int64 v6; // rdi
  unsigned __int64 result; // rax
  __int64 v8; // r10
  unsigned __int64 v9; // r11
  __int64 v10; // rsi
  unsigned __int64 v11; // r9
  __int64 v12; // rsi
  __int64 v13; // rdx

  v6 = a1 & 0xFFFFFFFFFFFFFFFELL;
  result = *(_QWORD *)(v6 + 8);
  v8 = *(_QWORD *)(v6 + 16);
  v9 = result & 0xFFFFFFFFFFFFFFFELL;
  if ( a6 != 1 )
  {
    if ( !v8 || !v9 || (*(_BYTE *)(v8 + 8) & 1) == 0 || (*(_BYTE *)(v9 + 8) & 1) == 0 )
      return result;
    result |= 1uLL;
    *(_QWORD *)(v6 + 8) = result;
    goto LABEL_14;
  }
  result |= 1uLL;
  *(_QWORD *)(v6 + 8) = result;
  if ( v8 )
LABEL_14:
    *(_QWORD *)(v8 + 8) &= ~1uLL;
  if ( v9 )
    *(_QWORD *)(v9 + 8) &= ~1uLL;
  if ( a2 )
  {
    result = *a2 & 0xFFFFFFFFFFFFFFFELL;
    v10 = *(_QWORD *)(result + 8);
    if ( (v10 & 1) != 0 )
    {
      v11 = *a3 & 0xFFFFFFFFFFFFFFFELL;
      if ( a4 > 0 == a5 > 0 )
      {
        *a3 = result | *a3 & 1;
        *(_QWORD *)(result + 8) = v10 & 0xFFFFFFFFFFFFFFFELL;
        *(_QWORD *)(v11 + 8) |= 1uLL;
        if ( a4 < 0 )
        {
          *(_QWORD *)(v11 + 8) = *(_QWORD *)(result + 16) | 1LL;
          *(_QWORD *)(result + 16) = v11;
        }
        else
        {
          v13 = *(_QWORD *)(result + 8) & 1LL;
          *(_QWORD *)(v11 + 16) = *(_QWORD *)(result + 8) & 0xFFFFFFFFFFFFFFFELL;
          *(_QWORD *)(result + 8) = v13 | v11;
        }
      }
      else
      {
        *(_QWORD *)(result + 8) = v10 | 1;
        *(_QWORD *)(v11 + 8) |= 1uLL;
        v12 = v8 & 1;
        *(_QWORD *)(v6 + 8) &= ~1uLL;
        if ( a4 < 0 )
        {
          *(_QWORD *)(result + 8) = *(_QWORD *)(result + 8) & 1LL | v8;
          *(_QWORD *)(v6 + 16) = v12 | result;
          *(_QWORD *)(v11 + 16) = v9;
          *(_QWORD *)(v6 + 8) = v11;
        }
        else
        {
          *(_QWORD *)(result + 16) = v9;
          *(_QWORD *)(v6 + 8) = result;
          *(_QWORD *)(v11 + 8) = *(_QWORD *)(v11 + 8) & 1LL | v8;
          *(_QWORD *)(v6 + 16) = v12 | v11;
        }
        result = *a3 & 1;
        *a3 = result | v6;
      }
    }
  }
  return result;
}

//----- (000000000043E7C0) ----------------------------------------------------
_QWORD *__fastcall tsearch(
        __int64 a1,
        __int64 *a2,
        __int64 (__fastcall *a3)(__int64, _QWORD),
        __int64 a4,
        u32 *a5,
        __int64 a6)
{
  __int64 v6; // rbx
  __int64 *v7; // r12
  unsigned int v8; // er14
  unsigned __int64 *v9; // r15
  __int64 *v10; // r13
  __int64 v11; // rax
  __int64 *v12; // r10
  _QWORD *v13; // rbx
  int v14; // ebp
  unsigned __int64 v15; // rax
  int v17; // [rsp+0h] [rbp-58h]
  __int64 *v18; // [rsp+0h] [rbp-58h]
  _QWORD *v19; // [rsp+8h] [rbp-50h]

  if ( !a2 )
    return 0LL;
  v6 = *a2;
  v7 = a2;
  if ( (*a2 & 0xFFFFFFFFFFFFFFFELL) != 0 )
  {
    *(_QWORD *)((*a2 & 0xFFFFFFFFFFFFFFFELL) + 8) &= ~1uLL;
    a5 = 0LL;
    v8 = 0;
    v9 = 0LL;
    v10 = 0LL;
    while ( 1 )
    {
      v13 = (_QWORD *)(v6 & 0xFFFFFFFFFFFFFFFELL);
      if ( !v13 )
        break;
      v17 = (int)a5;
      v19 = v13;
      v14 = a3(a1, *v13);
      if ( !v14 )
        return v19;
      a2 = v10;
      maybe_split_for_insert_isra_0(*v7, v10, v9, v8, v17, 0);
      if ( v14 >= 0 )
      {
        v11 = v13[2];
        v12 = v13 + 2;
      }
      else
      {
        v12 = v13 + 1;
        v11 = v13[1];
      }
      if ( (v11 & 0xFFFFFFFFFFFFFFFELL) == 0 )
        goto LABEL_13;
      v6 = *v12;
      v9 = (unsigned __int64 *)v10;
      a5 = (u32 *)v8;
      v10 = v7;
      v8 = v14;
      v7 = v12;
    }
    v14 = v8;
  }
  else
  {
    v14 = 0;
    v10 = 0LL;
  }
  v8 = v14;
  v12 = v7;
LABEL_13:
  v18 = v12;
  v15 = (unsigned __int64)malloc(0x18uLL, (__int64)a2, a3, a4, a5, a6);
  v19 = (_QWORD *)v15;
  if ( !v15 )
    return 0LL;
  *v18 = v15 | *v18 & 1;
  *(_QWORD *)(v15 + 8) = 1LL;
  *(_QWORD *)v15 = a1;
  *(_QWORD *)(v15 + 16) = 0LL;
  if ( v18 != v7 )
    maybe_split_for_insert_isra_0(*v18, v7, (unsigned __int64 *)v10, v14, v8, 1);
  return v19;
}
// 43E89C: variable 'a3' is possibly undefined
// 43E89C: variable 'a4' is possibly undefined
// 43E89C: variable 'a5' is possibly undefined
// 43E89C: variable 'a6' is possibly undefined

//----- (000000000043E930) ----------------------------------------------------
unsigned __int64 __fastcall tfind(__int64 a1, _QWORD *a2, __int64 (__fastcall *a3)(__int64, _QWORD))
{
  unsigned __int64 v4; // r13
  int v5; // eax
  _QWORD *v6; // rbx
  _QWORD *v7; // rbx

  if ( a2 )
  {
    while ( 1 )
    {
      v7 = (_QWORD *)(*a2 & 0xFFFFFFFFFFFFFFFELL);
      if ( !v7 )
        break;
      v4 = *a2 & 0xFFFFFFFFFFFFFFFELL;
      v5 = a3(a1, *v7);
      if ( !v5 )
        return v4;
      a2 = v7 + 1;
      v6 = v7 + 2;
      if ( v5 >= 0 )
        a2 = v6;
    }
  }
  return 0LL;
}

//----- (000000000043E990) ----------------------------------------------------
unsigned __int64 __fastcall tdelete(__int64 a1, __int64 *a2, __int64 (__fastcall *a3)(__int64, _QWORD))
{
  __int64 *v4; // r12
  unsigned __int64 v5; // rbx
  _QWORD *v6; // rax
  __int64 v7; // r14
  int v8; // er13
  __int64 v9; // rdx
  __int64 v10; // rcx
  unsigned __int64 v11; // r8
  int v12; // er9
  __int64 v14; // rdx
  __int64 *v15; // rcx
  __int16 v16; // dx
  unsigned int v17; // edx
  void *v18; // rsp
  __int64 v19; // rax
  __int64 v20; // r11
  unsigned __int64 v21; // r9
  __int64 v22; // rsi
  _QWORD *v23; // r15
  __int64 v24; // r14
  _QWORD *v25; // rdi
  __int64 v26; // rdx
  __int64 *v27; // rdi
  __int16 v28; // dx
  unsigned int v29; // edx
  void *v30; // rsp
  __int64 v31; // rax
  __int64 v32; // rax
  __int64 v33; // r14
  unsigned __int64 *v34; // r11
  unsigned __int64 v35; // rax
  __int64 v36; // r8
  unsigned __int64 v37; // rsi
  unsigned __int64 v38; // r12
  unsigned __int64 v39; // rdx
  __int64 v40; // rdx
  __int64 v41; // rcx
  unsigned __int64 v42; // rsi
  __int64 v43; // rcx
  __int64 v44; // rcx
  __int64 v45; // r12
  unsigned __int64 v46; // rcx
  __int64 v47; // rcx
  __int64 v48; // rcx
  unsigned __int64 v49; // rax
  __int64 v50; // [rsp+0h] [rbp-21C8h]
  __int64 v51; // [rsp+8h] [rbp-21C0h] BYREF
  _BYTE v52[7]; // [rsp+10h] [rbp-21B8h] BYREF
  __int64 v53; // [rsp+1008h] [rbp-11C0h] BYREF
  __int64 v54; // [rsp+1010h] [rbp-11B8h] BYREF
  unsigned __int64 v55; // [rsp+2160h] [rbp-68h]
  __int64 v56; // [rsp+2168h] [rbp-60h]
  __int64 v57; // [rsp+2170h] [rbp-58h]
  __int64 *v58; // [rsp+2178h] [rbp-50h]
  int v59; // [rsp+2184h] [rbp-44h]
  unsigned __int64 v60; // [rsp+2190h] [rbp-38h]

  v4 = a2;
  v57 = a1;
  v60 = __readfsqword(0x28u);
  v58 = &v54;
  if ( !a2 )
    return 0LL;
  v5 = *a2 & 0xFFFFFFFFFFFFFFFELL;
  if ( !v5 )
    return 0LL;
  v6 = (_QWORD *)(*a2 & 0xFFFFFFFFFFFFFFFELL);
  v7 = 0LL;
  v59 = 40;
  while ( 1 )
  {
    v8 = v7;
    v12 = a3(v57, *v6);
    if ( !v12 )
      break;
    if ( v59 == (_DWORD)v7 )
    {
      v59 += 20;
      v14 = 8LL * v59 + 23;
      v15 = (__int64 *)((char *)&v53 - (v14 & 0xFFFFFFFFFFFFF000LL));
      v16 = v14 & 0xFFF0;
      if ( &v53 != v15 )
      {
        while ( &v51 != v15 )
          ;
      }
      v17 = v16 & 0xFFF;
      if ( v17 )
      {
        v18 = alloca(v17);
        *(__int64 *)((char *)&v50 + v17) = *(__int64 *)((char *)&v50 + v17);
      }
      LODWORD(v56) = v12;
      v19 = j_memcpy(v52, v58, 8 * v7);
      v12 = v56;
      v58 = (__int64 *)v19;
    }
    v58[v7] = (__int64)v4;
    v5 = *v4 & 0xFFFFFFFFFFFFFFFELL;
    if ( v12 >= 0 )
    {
      v6 = *(_QWORD **)(v5 + 16);
      v4 = (__int64 *)(v5 + 16);
      ++v7;
      if ( !v6 )
        return 0LL;
    }
    else
    {
      v4 = (__int64 *)(v5 + 8);
      ++v7;
      v6 = (_QWORD *)(*(_QWORD *)(v5 + 8) & 0xFFFFFFFFFFFFFFFELL);
      if ( !v6 )
        return 0LL;
    }
  }
  v20 = *v4;
  v21 = *v4 & 0xFFFFFFFFFFFFFFFELL;
  v22 = *(_QWORD *)(v21 + 8) & 0xFFFFFFFFFFFFFFFELL;
  if ( *(_QWORD *)(v21 + 16) && v22 )
  {
    v23 = (_QWORD *)(v21 + 16);
    v10 = (__int64)v4;
    v24 = (int)v7;
    while ( 1 )
    {
      if ( v59 == v8 )
      {
        v59 += 20;
        v26 = 8LL * v59 + 23;
        v27 = (__int64 *)((char *)&v53 - (v26 & 0xFFFFFFFFFFFFF000LL));
        v28 = v26 & 0xFFF0;
        if ( &v53 != v27 )
        {
          while ( &v51 != v27 )
            ;
        }
        v29 = v28 & 0xFFF;
        if ( v29 )
        {
          v30 = alloca(v29);
          *(__int64 *)((char *)&v50 + v29) = *(__int64 *)((char *)&v50 + v29);
        }
        v55 = v21;
        v56 = v10;
        v57 = v20;
        v31 = j_memcpy(v52, v58, v24 * 8);
        v21 = v55;
        v10 = v56;
        v58 = (__int64 *)v31;
        v20 = v57;
      }
      ++v8;
      v25 = (_QWORD *)(*v23 & 0xFFFFFFFFFFFFFFFELL);
      v58[v24++] = v10;
      if ( (v25[1] & 0xFFFFFFFFFFFFFFFELL) == 0 )
        break;
      v10 = (__int64)v23;
      v23 = v25 + 1;
    }
    goto LABEL_74;
  }
  v25 = (_QWORD *)(*v4 & 0xFFFFFFFFFFFFFFFELL);
  if ( !v22 )
LABEL_74:
    v22 = v25[2];
  if ( v8 )
  {
    v10 = (__int64)v58;
    v49 = *(_QWORD *)v58[v8 - 1] & 0xFFFFFFFFFFFFFFFELL;
    if ( v25 == *(_QWORD **)(v49 + 16) )
    {
      *(_QWORD *)(v49 + 16) = v22;
    }
    else
    {
      v9 = v22 | *(_QWORD *)(v49 + 8) & 1LL;
      *(_QWORD *)(v49 + 8) = v9;
    }
  }
  else
  {
    *v4 = v22 | v20 & 1;
  }
  if ( (_QWORD *)v21 != v25 )
    *(_QWORD *)v21 = *v25;
  if ( (v25[1] & 1) == 0 )
  {
    if ( v8 )
    {
      while ( 1 )
      {
        if ( v22 )
        {
          v32 = *(_QWORD *)(v22 + 8);
          if ( (v32 & 1) != 0 )
            goto LABEL_56;
        }
        v33 = v8;
        v34 = (unsigned __int64 *)v58[v8 - 1];
        v21 = *v34;
        v35 = *v34 & 0xFFFFFFFFFFFFFFFELL;
        v9 = *(_QWORD *)(v35 + 8) & 0xFFFFFFFFFFFFFFFELL;
        v10 = v9;
        if ( v9 == v22 )
        {
          v9 = *(_QWORD *)(v35 + 16);
          v41 = *(_QWORD *)(v9 + 8);
          v37 = v41 & 0xFFFFFFFFFFFFFFFELL;
          if ( (v41 & 1) != 0 )
          {
            *(_QWORD *)(v9 + 8) = v37;
            ++v8;
            *(_QWORD *)(v35 + 8) |= 1uLL;
            v21 = v9 | v21 & 1;
            v42 = *(_QWORD *)(v9 + 8) & 0xFFFFFFFFFFFFFFFELL;
            v43 = v35 | *(_QWORD *)(v9 + 8) & 1LL;
            *(_QWORD *)(v35 + 16) = v42;
            *(_QWORD *)(v9 + 8) = v43;
            v44 = (__int64)v58;
            *v34 = v21;
            v34 = (unsigned __int64 *)(v9 + 8);
            v9 = v42;
            *(_QWORD *)(v44 + 8 * v33) = v34;
            v41 = *(_QWORD *)(v42 + 8);
            v37 = v41 & 0xFFFFFFFFFFFFFFFELL;
          }
          if ( v37 )
          {
            v11 = *(_QWORD *)(v37 + 8);
            if ( (v11 & 1) != 0 )
            {
              v45 = *(_QWORD *)(v9 + 16);
              v21 = *(_QWORD *)(v35 + 8) & 1LL;
              if ( v45 && (*(_BYTE *)(v45 + 8) & 1) != 0 )
              {
LABEL_68:
                v48 = v41 | 1;
                if ( v21 )
                  v37 = v48;
                *(_QWORD *)(v9 + 8) = v37;
                *(_QWORD *)(v35 + 8) &= ~1uLL;
                *(_QWORD *)(v45 + 8) &= ~1uLL;
                v10 = *(_QWORD *)(v9 + 8) & 1LL;
                v22 = *(_QWORD *)(v9 + 8) & 0xFFFFFFFFFFFFFFFELL;
                *(_QWORD *)(v35 + 16) = v22;
                *(_QWORD *)(v9 + 8) = v10 | v35;
                v9 |= *v34 & 1;
                *v34 = v9;
                goto LABEL_46;
              }
              if ( v21 )
                v46 = v11 | 1;
              else
                v46 = v11 & 0xFFFFFFFFFFFFFFFELL;
              v11 &= ~1uLL;
              *(_QWORD *)(v37 + 8) = v46;
              v47 = *(_QWORD *)(v9 + 8);
              *(_QWORD *)(v35 + 16) = v11;
              v10 = *(_QWORD *)(v37 + 16) | v47 & 1;
              *(_QWORD *)(v9 + 8) = v10;
              *(_QWORD *)(v37 + 16) = v9;
              *(_QWORD *)(v37 + 8) = v35 | *(_QWORD *)(v37 + 8) & 1LL;
LABEL_45:
              v9 = *v34 & 1;
              v22 = v9 | v37;
              *v34 = v22;
              *(_QWORD *)(v35 + 8) &= ~1uLL;
              goto LABEL_46;
            }
          }
          v11 = *(_QWORD *)(v9 + 16);
          if ( v11 )
          {
            v45 = *(_QWORD *)(v9 + 16);
            if ( (*(_BYTE *)(v11 + 8) & 1) != 0 )
            {
              v21 = *(_QWORD *)(v35 + 8) & 1LL;
              goto LABEL_68;
            }
          }
          v10 = v41 | 1;
          *(_QWORD *)(v9 + 8) = v10;
        }
        else
        {
          v36 = *(_QWORD *)(v9 + 8);
          v37 = *(_QWORD *)(v9 + 16);
          v38 = v36 & 0xFFFFFFFFFFFFFFFELL;
          if ( (v36 & 1) != 0 )
          {
            *(_QWORD *)(v9 + 8) = v38;
            ++v8;
            v21 = v9 | v21 & 1;
            *(_QWORD *)(v35 + 8) = v37 | 1;
            *(_QWORD *)(v9 + 16) = v35;
            *v34 = v21;
            v34 = (unsigned __int64 *)(v9 + 16);
            v58[v33] = v9 + 16;
            v10 = v37 & 0xFFFFFFFFFFFFFFFELL;
            v36 = *(_QWORD *)((v37 & 0xFFFFFFFFFFFFFFFELL) + 8);
            v37 = *(_QWORD *)((v37 & 0xFFFFFFFFFFFFFFFELL) + 16);
            v38 = v36 & 0xFFFFFFFFFFFFFFFELL;
          }
          if ( v37 )
          {
            v9 = *(_QWORD *)(v37 + 8);
            if ( (v9 & 1) != 0 )
            {
              v21 = *(_QWORD *)(v35 + 8) & 1LL;
              if ( !v38 || (*(_BYTE *)(v38 + 8) & 1) == 0 )
              {
                v39 = v9 & 0xFFFFFFFFFFFFFFFELL;
                if ( v21 )
                  v39 = *(_QWORD *)(v37 + 8) | 1LL;
                *(_QWORD *)(v37 + 8) = v39;
                *(_QWORD *)(v35 + 8) = *(_QWORD *)(v37 + 16) | *(_QWORD *)(v35 + 8) & 1LL;
                v40 = *(_QWORD *)(v37 + 8) & 1LL;
                v11 = *(_QWORD *)(v37 + 8) & 0xFFFFFFFFFFFFFFFELL;
                *(_QWORD *)(v10 + 16) = v11;
                v10 |= v40;
                *(_QWORD *)(v37 + 8) = v10;
                *(_QWORD *)(v37 + 16) = v35;
                goto LABEL_45;
              }
LABEL_50:
              v11 = v36 | 1;
              if ( v21 )
                v38 = v11;
              *(_QWORD *)(v10 + 8) = v38;
              *(_QWORD *)(v35 + 8) &= ~1uLL;
              *(_QWORD *)((*(_QWORD *)(v10 + 8) & 0xFFFFFFFFFFFFFFFELL) + 8) &= ~1uLL;
              v9 = *(_QWORD *)(v35 + 8) & 1LL;
              v22 = v9 | v37;
              *(_QWORD *)(v35 + 8) = v22;
              *(_QWORD *)(v10 + 16) = v35;
              v10 |= *v34 & 1;
              *v34 = v10;
              goto LABEL_46;
            }
          }
          if ( v38 && (*(_BYTE *)(v38 + 8) & 1) != 0 )
          {
            v21 = *(_QWORD *)(v35 + 8) & 1LL;
            goto LABEL_50;
          }
          v11 = v36 | 1;
          *(_QWORD *)(v10 + 8) = v11;
        }
        v22 = v35;
        if ( !--v8 )
          goto LABEL_55;
      }
    }
    if ( v22 )
    {
LABEL_55:
      v32 = *(_QWORD *)(v22 + 8);
LABEL_56:
      *(_QWORD *)(v22 + 8) = v32 & 0xFFFFFFFFFFFFFFFELL;
    }
  }
LABEL_46:
  free((__int64)v25, v22, v9, v10, (u32 *)v11, v21);
  return v5;
}
// 43ED75: variable 'v9' is possibly undefined
// 43ED75: variable 'v10' is possibly undefined
// 43ED75: variable 'v11' is possibly undefined
// 401040: using guessed type __int64 __fastcall j_memcpy(_QWORD, _QWORD, _QWORD);

//----- (000000000043EFE0) ----------------------------------------------------
__int64 __fastcall twalk(__int64 a1, void (__fastcall *a2)(__int64, _QWORD))
{
  __int64 result; // rax

  if ( a1 )
  {
    if ( a2 )
      return trecurse(a1, a2, 0);
  }
  return result;
}

//----- (000000000043F000) ----------------------------------------------------
__int64 *__fastcall tdestroy(_QWORD *a1, void (__fastcall *a2)(_QWORD))
{
  __int64 *result; // rax

  if ( a1 )
    return tdestroy_recurse(a1, a2);
  return result;
}

//----- (000000000043F020) ----------------------------------------------------
char *__fastcall next_line(unsigned int a1, char *a2, _QWORD *a3, char **a4, char *a5)
{
  char *v7; // rbx
  char *v8; // r15
  __int64 v9; // rax
  signed __int64 nocancel; // rax
  char *v12; // rax
  char *v13; // r14
  char *v14; // r15
  signed __int64 v15; // rax
  signed __int64 v16; // rbx

  v7 = *a4;
  v8 = (char *)*a3;
  v9 = j_memchr_ifunc(*a3, 10LL, &(*a4)[-*a3]);
  if ( v9 )
  {
LABEL_2:
    v7 = (char *)(v9 + 1);
    goto LABEL_3;
  }
  if ( v8 != a2 && v7 == a5 )
  {
    j_memmove(a2, v8, v7 - v8);
    *a4 = &(*a4)[(_QWORD)a2 - *a3];
    *a3 = a2;
    nocancel = _read_nocancel(a1, *a4, a5 - *a4);
    if ( nocancel < 0 )
      return 0LL;
    v12 = &(*a4)[nocancel];
    *a4 = v12;
    v8 = (char *)*a3;
    v7 = v12;
    v9 = j_memchr_ifunc(*a3, 10LL, &v12[-*a3]);
    if ( v9 )
      goto LABEL_2;
    if ( v7 == a5 )
    {
      v13 = &a2[3 * (a5 - a2) / 4];
      while ( 1 )
      {
        *a4 = v13;
        v15 = _read_nocancel(a1, v13, a5 - v13);
        v16 = v15;
        if ( v15 < 0 )
          return 0LL;
        v14 = *a4;
        v9 = j_memchr_ifunc(*a4, 10LL, v15);
        *v14 = 10;
        v7 = &(*a4)[v16];
        *a4 = v7;
        if ( v9 )
        {
          v8 = (char *)*a3;
          goto LABEL_2;
        }
        if ( v7 != a5 )
        {
          v8 = (char *)*a3;
          break;
        }
      }
    }
  }
LABEL_3:
  *a3 = v7;
  if ( *a4 < v7 )
    _assert_fail((__int64)"*cp <= *re", (__int64)"../sysdeps/unix/sysv/linux/getsysstats.c", 0x77u, "next_line");
  if ( *a4 == v8 )
    return 0LL;
  return v8;
}
// 401030: using guessed type __int64 __fastcall j_memmove(_QWORD, _QWORD, _QWORD);
// 401068: using guessed type __int64 __fastcall j_memchr_ifunc(_QWORD, _QWORD, _QWORD);

//----- (000000000043F1C0) ----------------------------------------------------
unsigned __int64 __fastcall sysinfo_mempages(__int64 a1, unsigned int a2)
{
  unsigned int v2; // ebx
  unsigned __int64 v3; // rdx
  unsigned __int64 result; // rax

  v2 = a2;
  v3 = (int)getpagesize();
  if ( v3 > 1 && a2 > 1 )
  {
    do
    {
      v2 >>= 1;
      v3 >>= 1;
    }
    while ( v2 > 1 && v3 > 1 );
  }
  result = a1 * v2;
  if ( v3 > 1 )
  {
    do
    {
      v3 >>= 1;
      result >>= 1;
    }
    while ( v3 != 1 );
  }
  return result;
}

//----- (000000000043F220) ----------------------------------------------------
__int64 get_nprocs()
{
  _BOOL4 v0; // eax
  unsigned __int64 v1; // r12
  unsigned __int64 v2; // rax
  __int64 *v3; // rdx
  unsigned int v4; // eax
  char *v5; // r12
  int v6; // edx
  unsigned int v7; // edi
  char *v8; // r15
  unsigned int i; // ebx
  int v10; // eax
  char *v11; // rdx
  int v12; // er14
  int v13; // er14
  unsigned __int64 v14; // rdi
  int v15; // edx
  unsigned int v16; // er15
  char *v17; // rax
  char *v19; // r15
  void *v20; // rsp
  char *v21; // rsi
  __int64 v22; // [rsp+0h] [rbp-1078h]
  __int64 v23; // [rsp+8h] [rbp-1070h] BYREF
  char v24[7]; // [rsp+10h] [rbp-1068h] BYREF
  _BYTE v25[12]; // [rsp+1008h] [rbp-70h] BYREF
  unsigned int v26; // [rsp+1014h] [rbp-64h]
  __int64 v27; // [rsp+1018h] [rbp-60h]
  char *v28; // [rsp+1020h] [rbp-58h]
  char *v29; // [rsp+1028h] [rbp-50h] BYREF
  char *v30; // [rsp+1030h] [rbp-48h] BYREF
  char *v31[8]; // [rsp+1038h] [rbp-40h] BYREF

  v31[1] = (char *)__readfsqword(0x28u);
  v27 = time(0LL);
  if ( v27 != timestamp_11482 || (i = cached_result_11481, cached_result_11481 < 0) )
  {
    v0 = _libc_alloca_cutoff(0x2000uLL);
    v1 = (-(__int64)!v0 & 0xFFFFFFFFFFFFE200LL) + 0x2000;
    v2 = (-(__int64)!v0 & 0xFFFFFFFFFFFFE200LL) + 8208;
    v3 = (__int64 *)&v25[-(v2 & 0xFFFFFFFFFFFFF000LL)];
    if ( v25 != (_BYTE *)v3 )
    {
      while ( &v23 != v3 )
        ;
    }
    v4 = v2 & 0xFFF;
    if ( v4 )
    {
      v20 = alloca(v4);
      *(__int64 *)((char *)&v22 + v4) = *(__int64 *)((char *)&v22 + v4);
    }
    v5 = &v24[v1];
    v28 = v24;
    v29 = v5;
    v30 = v5;
    v7 = _open_nocancel("/sys/devices/system/cpu/online", 0x80000, (int)v3);
    v26 = v7;
    if ( v7 != -1 )
    {
      v8 = next_line(v7, v24, &v29, &v30, v5);
      if ( v8 )
      {
        i = 0;
        while ( 1 )
        {
          v10 = strtouq(v8, v31, 10);
          v11 = v31[0];
          v12 = v10;
          if ( v31[0] == v8 )
            break;
          if ( *v31[0] == 45 )
          {
            v19 = v31[0] + 1;
            v10 = strtouq(v31[0] + 1, v31, 10);
            v11 = v31[0];
            if ( v31[0] == v19 )
              break;
          }
          v13 = i + 1 - v12 + v10;
          i = v13;
          if ( v11 >= v30 )
            goto LABEL_16;
          v14 = __readfsqword(0xFFFFFFF0);
          if ( (*(_BYTE *)(v14 + 2LL * *v11 + 1) & 0x20) != 0 )
          {
            while ( ++v11 != v30 )
            {
              if ( (*(_BYTE *)(v14 + 2LL * *v11 + 1) & 0x20) == 0 )
                goto LABEL_25;
            }
LABEL_16:
            _close_nocancel(v26);
            if ( v13 > 0 )
              goto LABEL_23;
            goto LABEL_17;
          }
LABEL_25:
          v8 = v11;
        }
      }
      _close_nocancel(v26);
    }
LABEL_17:
    v29 = v5;
    v30 = v5;
    v16 = _open_nocancel("/proc/stat", 0x80000, v6);
    if ( v16 == -1 )
    {
      i = 2;
      v16 = _open_nocancel("/proc/cpuinfo", 0x80000, v15);
      if ( v16 == -1 )
        goto LABEL_23;
      for ( i = 0; ; i += memcmp(v21, "processor", 9uLL) == 0 )
      {
        v21 = next_line(v16, v28, &v29, &v30, v5);
        if ( !v21 )
          break;
      }
    }
    else
    {
      for ( i = 0; ; i += (unsigned int)(v17[3] - 48) < 0xA )
      {
        v17 = next_line(v16, v28, &v29, &v30, v5);
        if ( !v17 || memcmp(v17, "cpu", 3uLL) )
          break;
      }
    }
    _close_nocancel(v16);
LABEL_23:
    cached_result_11481 = i;
    timestamp_11482 = v27;
  }
  return i;
}
// 43F3CE: variable 'v6' is possibly undefined
// 43F4DF: variable 'v15' is possibly undefined
// 4A9160: using guessed type int cached_result_11481;
// 4AADD0: using guessed type __int64 timestamp_11482;

//----- (000000000043F550) ----------------------------------------------------
__int64 __fastcall get_nprocs_conf(__int64 a1, char **a2, int a3)
{
  unsigned int v3; // er13
  __int64 v4; // rdx
  __int64 v5; // rcx
  unsigned int *v6; // rbp
  u32 *v7; // r8
  unsigned __int64 v8; // r9
  __int64 v9; // rax
  bool v10; // cf
  bool v11; // zf
  char *v12; // rdi
  char *v13; // rbx
  char *v15[7]; // [rsp+0h] [rbp-38h] BYREF

  v3 = 0;
  v15[1] = (char *)__readfsqword(0x28u);
  v6 = (unsigned int *)opendir("/sys/devices/system/cpu", (__int64)a2, a3);
  if ( v6 )
  {
    while ( 1 )
    {
      v9 = readdir64((__int64)v6, (__int64)a2, v4, v5, v7, v8);
      if ( !v9 )
        break;
      while ( 1 )
      {
        v10 = *(_BYTE *)(v9 + 18) < 4u;
        v11 = *(_BYTE *)(v9 + 18) == 4;
        if ( *(_BYTE *)(v9 + 18) != 4 )
          break;
        a2 = (char **)(v9 + 19);
        v5 = 3LL;
        v12 = "cpu";
        do
        {
          if ( !v5 )
            break;
          v10 = *(_BYTE *)a2 < (unsigned __int8)*v12;
          v11 = *(_BYTE *)a2 == (unsigned __int8)*v12;
          a2 = (char **)((char *)a2 + 1);
          ++v12;
          --v5;
        }
        while ( v11 );
        LOBYTE(v4) = (!v10 && !v11) - v10;
        if ( (_BYTE)v4 )
          break;
        v13 = (char *)(v9 + 22);
        a2 = v15;
        if ( strtouq((char *)(v9 + 22), v15, 10) == -1LL || v13 == v15[0] )
          break;
        v3 += *v15[0] == 0;
        v9 = readdir64((__int64)v6, (__int64)v15, v4, v5, v7, v8);
        if ( !v9 )
          goto LABEL_11;
      }
    }
LABEL_11:
    closedir(v6, (__int64)a2, v4, v5, v7, v8);
  }
  else
  {
    return (unsigned int)get_nprocs();
  }
  return v3;
}
// 43F59B: variable 'v4' is possibly undefined
// 43F59B: variable 'v5' is possibly undefined
// 43F59B: variable 'v7' is possibly undefined
// 43F59B: variable 'v8' is possibly undefined

//----- (000000000043F640) ----------------------------------------------------
unsigned __int64 get_phys_pages()
{
  struct sysinfo v1; // [rsp+0h] [rbp-88h] BYREF
  unsigned __int64 v2; // [rsp+78h] [rbp-10h]

  v2 = __readfsqword(0x28u);
  sysinfo(&v1);
  return sysinfo_mempages(v1.totalram, v1.mem_unit);
}

//----- (000000000043F690) ----------------------------------------------------
unsigned __int64 get_avphys_pages()
{
  struct sysinfo v1; // [rsp+0h] [rbp-88h] BYREF
  unsigned __int64 v2; // [rsp+78h] [rbp-10h]

  v2 = __readfsqword(0x28u);
  sysinfo(&v1);
  return sysinfo_mempages(v1.freeram, v1.mem_unit);
}

//----- (000000000043F6E0) ----------------------------------------------------
__int64 _getclktck()
{
  __int64 result; // rax

  result = (unsigned int)dl_clktck;
  if ( !dl_clktck )
    return 100LL;
  return result;
}
// 43F6E0: using guessed type __int64 __fastcall _getclktck();
// 4AB8E8: using guessed type int dl_clktck;

//----- (000000000043F700) ----------------------------------------------------
void __fastcall _init_misc(__int64 a1, _QWORD *a2)
{
  char (*v2)[1707]; // rbp
  __int64 v3; // rax

  if ( a2 )
  {
    v2 = (char (*)[1707])*a2;
    if ( *a2 )
    {
      v3 = j_strrchr_ifunc(*a2, 47LL);
      if ( v3 )
        v2 = (char (*)[1707])(v3 + 1);
      program_invocation_short_name[0] = v2;
      program_invocation_name = (char (*)[1707])*a2;
    }
  }
}
// 401050: using guessed type __int64 __fastcall j_strrchr_ifunc(_QWORD, _QWORD);
// 4A9168: using guessed type char (*program_invocation_short_name[2])[1707];
// 4A9170: using guessed type char (*program_invocation_name)[1707];

//----- (000000000043F760) ----------------------------------------------------
unsigned __int64 __fastcall mremap(
        unsigned __int64 a1,
        unsigned __int64 a2,
        unsigned __int64 a3,
        unsigned __int64 a4,
        unsigned __int64 a5)
{
  unsigned __int64 result; // rax

  result = sys_mremap(a1, a2, a3, a4, a5);
  if ( result >= 0xFFFFFFFFFFFFF001LL )
  {
    __writefsdword(0xFFFFFFC0, -(int)result);
    return -1LL;
  }
  return result;
}

//----- (000000000043F790) ----------------------------------------------------
unsigned __int64 __fastcall sysinfo(struct sysinfo *a1)
{
  unsigned __int64 result; // rax

  result = sys_sysinfo(a1);
  if ( result >= 0xFFFFFFFFFFFFF001LL )
  {
    __writefsdword(0xFFFFFFC0, -(int)result);
    return -1LL;
  }
  return result;
}

//----- (000000000043F7C0) ----------------------------------------------------
void __fastcall __noreturn _chk_fail(__int64 a1, __int64 a2, __int64 a3, __int64 a4, u32 *a5, __int64 a6)
{
  _fortify_fail((__int64)"buffer overflow detected", a2, a3, a4, a5, a6);
}

//----- (000000000043F800) ----------------------------------------------------
void __fastcall __noreturn _fortify_fail_abort(char a1, __int64 a2, __int64 a3, __int64 a4, u32 *a5, __int64 a6)
{
  const char *v7; // rcx
  char v8; // di
  char v9; // [rsp+0h] [rbp-18h]

  while ( 1 )
  {
    if ( a1 )
    {
      v7 = *(const char **)_libc_argv;
      if ( !*(_QWORD *)_libc_argv )
        v7 = "<unknown>";
      v8 = 3;
    }
    else
    {
      v7 = "<unknown>";
      v8 = 1;
    }
    _libc_message(v8, (size_t)"*** %s ***: %s terminated\n", a2, (__int64)v7, a5, a6, v9);
  }
}
// 43F840: variable 'a5' is possibly undefined
// 43F840: variable 'a6' is possibly undefined
// 43F840: variable 'v9' is possibly undefined
// 4AB960: using guessed type __int64 _libc_argv;

//----- (000000000043F860) ----------------------------------------------------
void __fastcall __noreturn _fortify_fail(__int64 a1, __int64 a2, __int64 a3, __int64 a4, u32 *a5, __int64 a6)
{
  _fortify_fail_abort(1, a1, a3, a4, a5, a6);
}

//----- (000000000043F880) ----------------------------------------------------
void dl_debug_state()
{
  ;
}

//----- (000000000043F890) ----------------------------------------------------
void **__fastcall dl_debug_initialize(void *a1, __int64 a2)
{
  void **result; // rax
  void *v3; // rdx

  result = (void **)&r_debug;
  if ( a2 )
    result = &dl_ns + 18 * a2 + 13;
  if ( !result[1] )
  {
    *(_DWORD *)result = 1;
    if ( !a1 )
      a1 = (void *)qword_4AB860;
    goto LABEL_6;
  }
  if ( a1 )
  {
    *(_DWORD *)result = 1;
LABEL_6:
    result[4] = a1;
    v3 = *(&dl_ns + 18 * a2);
    result[2] = dl_debug_state;
    result[1] = v3;
  }
  return result;
}
// 4A9280: using guessed type void *dl_ns;
// 4AB860: using guessed type __int64 qword_4AB860;

//----- (000000000043F910) ----------------------------------------------------
__int64 __fastcall do_tunable_update_val(__int64 a1, unsigned __int64 *a2)
{
  __int64 result; // rax
  unsigned __int64 v3; // rdx

  result = *(unsigned int *)(a1 + 8);
  if ( (_DWORD)result == 3 )
  {
    *(_QWORD *)(a1 + 32) = a2;
    return result;
  }
  v3 = *a2;
  if ( (_DWORD)result == 1 )
  {
    if ( v3 < *(_QWORD *)(a1 + 16) )
      return result;
    goto LABEL_5;
  }
  if ( (_DWORD)result )
  {
    if ( v3 < *(_QWORD *)(a1 + 16) )
      return result;
LABEL_5:
    if ( v3 <= *(_QWORD *)(a1 + 24) )
    {
      *(_QWORD *)(a1 + 32) = v3;
      *(_BYTE *)(a1 + 40) = 1;
    }
    return result;
  }
  if ( (signed __int64)v3 >= *(_QWORD *)(a1 + 16) && (signed __int64)v3 <= *(_QWORD *)(a1 + 24) )
  {
    *(_QWORD *)(a1 + 32) = v3;
    *(_BYTE *)(a1 + 40) = 1;
  }
  return result;
}

//----- (000000000043F980) ----------------------------------------------------
__int64 __fastcall tunable_initialize(__int64 a1, char *a2)
{
  unsigned __int64 *v3; // rdi
  __int64 v5; // [rsp+8h] [rbp-10h] BYREF

  v3 = (unsigned __int64 *)a2;
  if ( *(_DWORD *)(a1 + 8) == 3 )
  {
    *(_BYTE *)(a1 + 40) = 1;
  }
  else
  {
    v3 = (unsigned __int64 *)&v5;
    v5 = dl_strtoul(a2, 0LL);
  }
  return do_tunable_update_val(a1, v3);
}

//----- (000000000043F9D0) ----------------------------------------------------
__int64 __fastcall _tunable_set_val(unsigned int a1, unsigned __int64 *a2)
{
  return do_tunable_update_val((__int64)&(&tunable_list)[7 * a1], a2);
}
// 4A7500: using guessed type char *tunable_list;

//----- (000000000043FA00) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
void __fastcall _tunables_init(__int64 *a1)
{
  char *v2; // rbx
  char v3; // r8
  __int64 *v4; // r12
  __int64 i; // rax
  char v6; // dl
  __int64 v7; // rbp
  char *v8; // r13
  _BYTE *v9; // rax
  const char *v10; // rsi
  char v11; // cl
  _QWORD *v12; // rdi
  int v13; // er8
  _BYTE *v14; // rsi
  char v15; // dl
  __int64 v16; // rax
  char v17; // cl
  int v18; // eax
  __int64 v19; // rdx
  __int64 v20; // r15
  __int64 v21; // rax
  bool v22; // zf
  _BYTE *v23; // rbp
  char v24; // r10
  _BYTE *v25; // rbx
  __int64 v26; // rdx
  char v27; // al
  _BYTE *v28; // r8
  char v29; // di
  __int64 v30; // rbp
  char **v31; // r11
  __int64 v32; // r9
  char v33; // al
  __int64 v34; // rax
  char v35; // cl
  char v36; // dl
  _BYTE *v37; // rax
  int v38; // edx
  char *v39; // rsi
  __int64 *v40; // r11
  char *j; // r9
  char v42; // dl
  __int64 v43; // rax
  char v44; // cl
  __int64 *v45; // rax
  __int64 v46; // rdx
  char *v47; // rdx
  _BYTE *v48; // rax
  char k; // cl
  signed __int64 v50; // rax
  __int64 v51; // [rsp+0h] [rbp-48h]
  _BYTE *v52; // [rsp+0h] [rbp-48h]
  _BYTE *v53; // [rsp+8h] [rbp-40h]

  if ( _libc_enable_secure )
  {
    v50 = sys_access("/etc/suid-debug", 0);
    if ( !(_DWORD)v50 || (unsigned int)v50 <= 0xFFFFF000 )
      dword_4A7A34 = 2;
  }
LABEL_2:
  while ( a1 )
  {
LABEL_3:
    v2 = (char *)*a1;
    if ( !*a1 )
      return;
    v3 = *v2;
    v4 = a1 + 1;
    if ( !*v2 )
      goto LABEL_38;
LABEL_5:
    if ( v3 != 61 )
    {
      for ( i = 1LL; ; ++i )
      {
        v6 = v2[i];
        if ( !v6 || v6 == 61 )
          break;
      }
      goto LABEL_10;
    }
LABEL_38:
    while ( 1 )
    {
      v6 = v3;
      i = 0LL;
LABEL_10:
      if ( v6 )
        break;
      if ( !v4 )
        return;
      v2 = (char *)*v4;
      a1 = v4;
      if ( !*v4 )
        return;
      v3 = *v2;
      ++v4;
      if ( *v2 )
        goto LABEL_5;
    }
    v7 = i + 1;
    v8 = &v2[i + 1];
    if ( !v4 )
      return;
    v9 = v2 + 1;
    v10 = "LIBC_TUNABLES";
    v11 = 76;
    if ( v3 != 71 )
      goto LABEL_17;
    do
    {
      if ( !*v9 || *v9 != v11 )
        goto LABEL_17;
      v11 = *++v10;
      ++v9;
    }
    while ( *v10 );
    if ( *v9 != 61 )
    {
LABEL_17:
      v12 = &unk_4A7528;
      v13 = 0;
      while ( 1 )
      {
        if ( !*(_BYTE *)v12 )
        {
          v14 = (_BYTE *)v12[1];
          if ( v14 )
          {
            v15 = *v2;
            if ( !*v14 )
              goto LABEL_27;
            if ( v15 && *v14 == v15 )
              break;
          }
        }
LABEL_28:
        ++v13;
        v12 += 7;
        if ( v13 == 24 )
        {
          a1 = v4;
          goto LABEL_3;
        }
      }
      v16 = 1LL;
      while ( 1 )
      {
        v17 = v14[v16];
        v15 = v2[v16];
        if ( !v17 )
          break;
        ++v16;
        if ( !v15 || v17 != v15 )
          goto LABEL_28;
      }
LABEL_27:
      if ( v15 != 61 )
        goto LABEL_28;
      if ( !_libc_enable_secure )
        goto LABEL_34;
      v18 = *((_DWORD *)v12 + 1);
      if ( v18 )
        goto LABEL_33;
      v40 = a1;
LABEL_81:
      for ( j = (char *)*v40; *v40; j = (char *)*v40 )
      {
        v42 = *j;
        if ( *v14 )
        {
          if ( !v42 || *v14 != v42 )
            goto LABEL_90;
          v43 = 1LL;
          while ( 1 )
          {
            v44 = v14[v43];
            v42 = j[v43];
            if ( !v44 )
              break;
            ++v43;
            if ( v44 != v42 || !v42 )
              goto LABEL_90;
          }
        }
        if ( v42 == 61 )
        {
          v45 = v40;
          do
          {
            v46 = v45[1];
            *v45++ = v46;
          }
          while ( v46 );
          goto LABEL_81;
        }
LABEL_90:
        ++v40;
      }
      v18 = *((_DWORD *)v12 + 1);
      v4 = a1;
LABEL_33:
      if ( v18 == 2 )
      {
LABEL_34:
        a1 = v4;
        tunable_initialize((__int64)&(&tunable_list)[7 * v13], v8);
        goto LABEL_2;
      }
      goto LABEL_28;
    }
    v19 = 0LL;
    while ( v3 )
      v3 = v2[++v19];
    v51 = v19;
    v20 = sbrk(v19 + 1);
    if ( v20 == -1 )
    {
      *a1 = 0LL;
      a1 = v4;
    }
    else
    {
      v21 = v51 - 1;
      if ( v51 )
      {
        do
        {
          *(_BYTE *)(v20 + v21) = v2[v21];
          --v21;
        }
        while ( v21 != -1 );
LABEL_45:
        v22 = v20 + v7 == 0;
        v23 = (_BYTE *)(v20 + v7);
        v53 = v23;
        if ( !v22 )
        {
          v24 = *v23;
          v25 = v23;
          if ( *v23 )
          {
            while ( 1 )
            {
              if ( v24 == 61 || v24 == 58 )
              {
                v27 = v24;
                v26 = 0LL;
              }
              else
              {
                if ( !v24 )
                  break;
                v26 = 0LL;
                while ( 1 )
                {
                  v27 = v25[++v26];
                  if ( v27 == 61 || v27 == 58 )
                    break;
                  if ( !v27 )
                    goto LABEL_54;
                }
              }
              v28 = &v25[v26 + 1];
              v29 = *v28;
              if ( v27 == 58 )
              {
                v24 = *v28;
                v25 += v26 + 1;
                continue;
              }
              v30 = 0LL;
              if ( v29 && v29 != 58 )
              {
                do
                  v29 = v28[++v30];
                while ( v29 != 58 && v29 );
              }
              v31 = &tunable_list;
              v32 = 0LL;
              while ( 1 )
              {
                v33 = **v31;
                if ( !v33 )
                {
                  v36 = v24;
                  goto LABEL_69;
                }
                if ( v33 == v24 )
                  break;
LABEL_70:
                ++v32;
                v31 += 7;
                if ( v32 == 24 )
                {
                  v37 = &v28[v30];
                  v25 = v28;
                  goto LABEL_72;
                }
              }
              v34 = 1LL;
              while ( 1 )
              {
                v35 = (*v31)[v34];
                v36 = v25[v34];
                if ( !v35 )
                  break;
                ++v34;
                if ( v35 != v36 || !v36 )
                  goto LABEL_70;
              }
LABEL_69:
              if ( v36 != 61 )
                goto LABEL_70;
              if ( !_libc_enable_secure )
              {
                v37 = &v28[v30];
                v25 = v28;
                goto LABEL_78;
              }
              v38 = *((_DWORD *)&tunable_list + 14 * v32 + 11);
              if ( v38 )
              {
                v37 = &v28[v30];
                v25 = v28;
              }
              else
              {
                if ( !v29 )
                {
                  *v25 = 0;
                  break;
                }
                v47 = &v28[v30 + 1];
                v48 = v25;
                for ( k = *v47; *v47; k = *v47 )
                {
                  ++v47;
                  *v48++ = k;
                }
                *v48 = 0;
                v30 = 0LL;
                v38 = *((_DWORD *)&tunable_list + 14 * v32 + 11);
                v37 = v25;
              }
              if ( v38 == 2 )
              {
LABEL_78:
                v52 = v37;
                v39 = &v8[v28 - v53];
                v39[v30] = 0;
                tunable_initialize((__int64)&(&tunable_list)[7 * v32], v39);
                v37 = v52;
              }
LABEL_72:
              if ( !*v37 )
                break;
              v25 += v30 + 1;
              v24 = *v25;
            }
          }
        }
LABEL_54:
        *a1 = v20;
        a1 = v4;
      }
      else
      {
        if ( v20 )
          goto LABEL_45;
        *a1 = 0LL;
        a1 = v4;
      }
    }
  }
}
// 43FED0: write access to const memory at 4A7A34 has been detected
// 43FB44: conditional instruction was optimized away because r12.8!=0
// 43FC82: conditional instruction was optimized away because al.1 is in (==3A|==3D)
// 43FCD7: conditional instruction was optimized away because r10.1!=0
// 4A7500: using guessed type char *tunable_list;
// 4A7A34: using guessed type int dword_4A7A34;
// 4A7AD8: using guessed type int _libc_enable_secure;

//----- (000000000043FF00) ----------------------------------------------------
__int64 __fastcall _tunable_get_val(unsigned int a1, _QWORD *a2, __int64 (__fastcall *a3)(char **))
{
  char **v3; // r8
  int v4; // eax
  __int64 result; // rax

  v3 = &(&tunable_list)[7 * a1];
  v4 = *((_DWORD *)v3 + 2);
  if ( v4 == 1 )
    goto LABEL_4;
  if ( v4 )
  {
    if ( v4 == 2 )
    {
LABEL_4:
      *a2 = (&tunable_list)[7 * a1 + 4];
      goto LABEL_5;
    }
    *a2 = v3[4];
  }
  else
  {
    *(_DWORD *)a2 = (unsigned int)v3[4];
  }
LABEL_5:
  result = 7LL * a1;
  if ( LOBYTE((&tunable_list)[result + 5]) )
  {
    if ( a3 )
      return a3(&(&tunable_list)[result + 4]);
  }
  return result * 8;
}
// 4A7500: using guessed type char *tunable_list;

//----- (000000000043FF90) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
__int64 __fastcall dl_aux_init(__int64 *a1)
{
  __int64 result; // rax
  unsigned __int64 v2; // rax

  result = *a1;
  dl_auxv = (__int64)a1;
  if ( result )
  {
    do
    {
      v2 = result - 3;
      if ( v2 <= 0x1E )
        __asm { jmp     rax }
      a1 += 2;
      result = *a1;
    }
    while ( *a1 );
  }
  return result;
}
// 44013F: write access to const memory at 4A7AD8 has been detected
// 440162: write access to const memory at 4A7AC0 has been detected
// 440180: write access to const memory at 4A7AD8 has been detected
// 4400ED: conditional instruction was optimized away because %var_61.1==0
// 440100: conditional instruction was optimized away because %var_46.1==0
// 440113: conditional instruction was optimized away because %var_45.1==0
// 440126: conditional instruction was optimized away because %var_34.1==0
// 440139: conditional instruction was optimized away because %var_33.1==0
// 44014A: conditional instruction was optimized away because %var_32.1==0
// 44015B: conditional instruction was optimized away because %var_31.1==0
// 4A7AC0: using guessed type __int64 dl_random;
// 4A7AD8: using guessed type int _libc_enable_secure;
// 4A91EC: using guessed type __int16 dl_fpu_control;
// 4A91F8: using guessed type __int64 dl_pagesize;
// 4AADE0: using guessed type __int64 dl_hwcap2;
// 4AADE8: using guessed type __int64 dl_hwcap;
// 4AB8A0: using guessed type __int64 dl_auxv;
// 4AB8E8: using guessed type int dl_clktck;
// 4AB8F0: using guessed type __int64 dl_sysinfo_dso;
// 4AB950: using guessed type int _libc_enable_secure_decided;

//----- (00000000004402F0) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
unsigned __int64 dl_non_dynamic_init()
{
  char *v0; // rax
  _BOOL4 v1; // edx
  u32 *v2; // rbx
  __int64 v3; // rdi
  __int64 v4; // rcx
  __int64 v5; // rsi
  __int64 v6; // rax
  int v7; // edx
  __int64 v8; // rdx
  __int64 v9; // rdi
  __int64 v10; // rcx
  bool v11; // zf
  unsigned __int64 *v12; // rdx
  unsigned __int64 v13; // rax
  u32 *v14; // rdi
  __int64 *v15; // rdx
  int v16; // eax
  __int64 *v17; // rsi
  __int64 v18; // rdx
  __int64 *v19; // rdx
  __int64 *v20; // rsi
  __int64 v21; // rdx
  __int64 *v22; // rdx
  __int64 *v23; // rsi
  __int64 v24; // rdx
  __int64 *v25; // rdx
  __int64 *v26; // rsi
  __int64 v27; // rdx
  __int64 *v28; // rdx
  __int64 *v29; // rsi
  __int64 v30; // rdx
  __int64 *v31; // rdx
  __int64 v32; // rdx
  __int64 *v33; // rdx
  __int64 *v34; // rdx
  __int64 *v35; // rax
  __int64 v36; // rax
  __int64 v37; // rax
  __int64 v38; // rdx
  __int64 v39; // rax
  __int64 v40; // rax
  __int64 v41; // rax
  __int64 v42; // rbp
  unsigned __int64 v43; // r12
  _QWORD *v44; // rdx
  __int64 v45; // rcx
  u32 *v46; // r8
  __int64 v47; // r9
  _QWORD *v48; // rax
  __int64 v49; // rax
  __int64 *v50; // rdx
  char *v51; // rax
  char *v52; // rax
  _BOOL4 v53; // edx
  char *v54; // rax
  _BOOL4 v55; // edx
  char *v56; // rax
  _BOOL4 v57; // edx
  char *v58; // rax
  char *v59; // rax
  char *v60; // rbx
  unsigned __int64 result; // rax
  char *v62; // rbx
  __int64 v63; // r13
  __int64 i; // rbp
  char v65; // si
  __int64 v66; // rdx
  unsigned __int64 v67; // rdx
  __int64 v68; // rcx
  __int64 v69; // rdx
  char *v70; // [rsp+8h] [rbp-30h] BYREF

  qword_4A9660 = dl_get_origin();
  qword_4A95C8 = dl_phdr;
  word_4A95D8 = dl_phnum;
  v0 = getenv("LD_WARN");
  v1 = 0;
  if ( v0 )
    v1 = *v0 != 0;
  dl_verbose = v1;
  if ( dl_sysinfo_dso )
  {
    v2 = dl_new_object(byte_493255, (__int64)byte_493255, 1, 0LL, 0, 0LL);
    if ( v2 )
    {
      v3 = dl_sysinfo_dso;
      v4 = 0LL;
      v5 = *(unsigned __int16 *)(dl_sysinfo_dso + 56);
      v6 = dl_sysinfo_dso + *(_QWORD *)(dl_sysinfo_dso + 32);
      *((_WORD *)v2 + 348) = v5;
      *((_QWORD *)v2 + 85) = v6;
      if ( v5 )
      {
        do
        {
          while ( 1 )
          {
            v7 = *(_DWORD *)v6;
            if ( *(_DWORD *)v6 != 2 )
              break;
            v8 = *(_QWORD *)(v6 + 16);
            ++v4;
            v6 += 56LL;
            *((_QWORD *)v2 + 2) = v8;
            *((_WORD *)v2 + 349) = *(_QWORD *)(v6 - 16) >> 4;
            if ( v4 == v5 )
              goto LABEL_12;
          }
          if ( v7 == 1 )
          {
            v66 = *(_QWORD *)(v6 + 16);
            if ( !*(_QWORD *)v2 )
              *(_QWORD *)v2 = v66;
            v67 = *(_QWORD *)(v6 + 40) + v66;
            if ( v67 >= *((_QWORD *)v2 + 106) )
              *((_QWORD *)v2 + 106) = v67;
            if ( (*(_BYTE *)(v6 + 4) & 1) != 0 && v67 >= *((_QWORD *)v2 + 107) )
              *((_QWORD *)v2 + 107) = v67;
          }
          else if ( v7 == 7 )
          {
            _assert_fail((__int64)"ph->p_type != PT_TLS", (__int64)"setup-vdso.h", 0x3Du, "setup_vdso");
          }
          ++v4;
          v6 += 56LL;
        }
        while ( v4 != v5 );
      }
LABEL_12:
      *((_QWORD *)v2 + 105) = v3;
      v9 = v3 - *(_QWORD *)v2;
      *((_QWORD *)v2 + 106) += v9;
      v10 = v9;
      *((_QWORD *)v2 + 107) += v9;
      v11 = *((_QWORD *)v2 + 2) + v9 == 0;
      v12 = (unsigned __int64 *)(*((_QWORD *)v2 + 2) + v9);
      *(_QWORD *)v2 = v9;
      *((_QWORD *)v2 + 2) = v12;
      if ( !v11 )
      {
        v13 = *v12;
        v14 = v2 + 16;
        if ( *v12 )
        {
          while ( 1 )
          {
            if ( v13 <= 0x22 )
              goto LABEL_16;
            if ( 1879048191 - v13 <= 0xF )
            {
              v5 = 1879048226 - v13;
              v13 = 1879048226 - v13;
LABEL_16:
              *(_QWORD *)&v14[2 * v13] = v12;
LABEL_17:
              v12 += 2;
              v13 = *v12;
              if ( !*v12 )
                break;
            }
            else
            {
              v5 = (unsigned int)((2 * (int)v13) >> 1);
              if ( (unsigned int)v5 <= 0xFFFFFFFC )
              {
                v5 = 1879047679 - v13;
                if ( 1879047679 - v13 > 0xB )
                {
                  v5 = 1879047935 - v13;
                  if ( 1879047935 - v13 <= 0xA )
                    *(_QWORD *)&v14[-2 * v13 + 3758096002u] = v12;
                }
                else
                {
                  *(_QWORD *)&v14[-2 * v13 + 3758095466u] = v12;
                }
                goto LABEL_17;
              }
              *(_QWORD *)&v14[2 * (unsigned int)(50 - v5)] = v12;
              v12 += 2;
              v13 = *v12;
              if ( !*v12 )
                break;
            }
          }
        }
        if ( v10 )
        {
          v15 = (__int64 *)*((_QWORD *)v2 + 12);
          v16 = 0;
          if ( v15 )
          {
            dyn_temp_10781[0] = *v15;
            qword_4A7A48 = v10 + v15[1];
            *((_QWORD *)v2 + 12) = dyn_temp_10781;
            v16 = 1;
          }
          v17 = (__int64 *)*((_QWORD *)v2 + 11);
          if ( v17 )
          {
            v18 = v16++;
            v19 = &dyn_temp_10781[2 * v18];
            *v19 = *v17;
            v19[1] = v10 + v17[1];
            *((_QWORD *)v2 + 11) = v19;
          }
          v20 = (__int64 *)*((_QWORD *)v2 + 13);
          if ( v20 )
          {
            v21 = v16++;
            v22 = &dyn_temp_10781[2 * v21];
            *v22 = *v20;
            v22[1] = v10 + v20[1];
            *((_QWORD *)v2 + 13) = v22;
          }
          v23 = (__int64 *)*((_QWORD *)v2 + 14);
          if ( v23 )
          {
            v24 = v16++;
            v25 = &dyn_temp_10781[2 * v24];
            *v25 = *v23;
            v25[1] = v10 + v23[1];
            *((_QWORD *)v2 + 14) = v25;
          }
          v26 = (__int64 *)*((_QWORD *)v2 + 15);
          if ( v26 )
          {
            v27 = v16++;
            v28 = &dyn_temp_10781[2 * v27];
            *v28 = *v26;
            v28[1] = v10 + v26[1];
            *((_QWORD *)v2 + 15) = v28;
          }
          v29 = (__int64 *)*((_QWORD *)v2 + 31);
          if ( v29 )
          {
            v30 = v16++;
            v31 = &dyn_temp_10781[2 * v30];
            *v31 = *v29;
            v31[1] = v10 + v29[1];
            *((_QWORD *)v2 + 31) = v31;
          }
          v5 = *((_QWORD *)v2 + 58);
          if ( v5 )
          {
            v32 = v16++;
            v33 = &dyn_temp_10781[2 * v32];
            *v33 = *(_QWORD *)v5;
            v33[1] = v10 + *(_QWORD *)(v5 + 8);
            *((_QWORD *)v2 + 58) = v33;
          }
          v34 = (__int64 *)*((_QWORD *)v2 + 84);
          if ( v34 )
          {
            v35 = &dyn_temp_10781[2 * v16];
            v5 = *v34;
            v35[1] = v34[1] + v10;
            *v35 = v5;
            *((_QWORD *)v2 + 84) = v35;
          }
        }
        v36 = *((_QWORD *)v2 + 28);
        if ( v36 && *(_QWORD *)(v36 + 8) != 7LL )
          _assert_fail(
            (__int64)"info[DT_PLTREL]->d_un.d_val == DT_RELA",
            (__int64)"get-dynamic-info.h",
            0x7Bu,
            "elf_get_dynamic_info");
        if ( *((_QWORD *)v2 + 15) && *(_QWORD *)(*((_QWORD *)v2 + 17) + 8LL) != 24LL )
          _assert_fail(
            (__int64)"info[DT_RELAENT]->d_un.d_val == sizeof (ElfW(Rela))",
            (__int64)"get-dynamic-info.h",
            0x83u,
            "elf_get_dynamic_info");
        v37 = *((_QWORD *)v2 + 38);
        if ( v37 )
        {
          v38 = *(_QWORD *)(v37 + 8);
          v2[248] = v38;
          if ( (v38 & 2) != 0 )
            *((_QWORD *)v2 + 24) = v37;
          if ( (v38 & 4) != 0 )
            *((_QWORD *)v2 + 30) = v37;
          if ( (v38 & 8) != 0 )
            *((_QWORD *)v2 + 32) = v37;
        }
        v39 = *((_QWORD *)v2 + 47);
        if ( v39 )
        {
          v5 = *(_QWORD *)(v39 + 8);
          LOBYTE(v39) = v5;
          v2[247] = v5;
          if ( (dl_debug_mask & 0x40) != 0 )
          {
            v5 = (unsigned int)v5 & 0xFFFFF716;
            if ( (_DWORD)v5 )
            {
              dl_debug_printf("\nWARNING: Unsupported flag value(s) of 0x%x in DT_FLAGS_1.\n", v5);
              LODWORD(v39) = v2[247];
            }
          }
          if ( (v39 & 1) != 0 )
            *((_QWORD *)v2 + 32) = *((_QWORD *)v2 + 47);
        }
        if ( *((_QWORD *)v2 + 37) )
          *((_QWORD *)v2 + 23) = 0LL;
      }
      dl_setup_hash((__int64)v2);
      v40 = *((_QWORD *)v2 + 114);
      *((_BYTE *)v2 + 796) |= 4u;
      v2[245] = 1;
      *(_DWORD *)(v40 + 8) = 1;
      *(_QWORD *)v40 = v2 + 10;
      v41 = *((_QWORD *)v2 + 22);
      if ( v41 )
      {
        v42 = *(_QWORD *)(*((_QWORD *)v2 + 13) + 8LL) + *(_QWORD *)(v41 + 8);
        v43 = j_strlen_ifunc(v42) + 1;
        v48 = malloc(v43, v5, v44, v45, v46, v47);
        if ( !v48 )
        {
          dl_dprintf(2, "out of memory\n");
          exit(127);
        }
        v49 = j_memcpy(v48, v42, v43);
        v50 = (__int64 *)*((_QWORD *)v2 + 7);
        *((_QWORD *)v2 + 1) = v49;
        *v50 = v49;
      }
      dl_add_to_namespace_list(v2, 0LL);
      dl_sysinfo_map = (__int64)v2;
      dl_nns = 1LL;
    }
  }
  v51 = getenv("LD_LIBRARY_PATH");
  dl_init_paths(v51);
  dl_init_all_dirs = dl_all_dirs;
  v52 = getenv("LD_BIND_NOW");
  v53 = 1;
  if ( v52 )
    v53 = *v52 == 0;
  dl_lazy = v53;
  v54 = getenv("LD_BIND_NOT");
  v55 = 0;
  if ( v54 )
    v55 = *v54 != 0;
  dl_bind_not = v55;
  v56 = getenv("LD_DYNAMIC_WEAK");
  v57 = 1;
  if ( v56 )
    v57 = *v56 == 0;
  dl_dynamic_weak = v57;
  v58 = getenv("LD_PROFILE_OUTPUT");
  dl_profile_output = (__int64)v58;
  if ( !v58 || !*v58 )
  {
    v59 = "/var/tmp";
    if ( _libc_enable_secure )
      v59 = &aVarTmp[9];
    dl_profile_output = (__int64)v59;
  }
  if ( _libc_enable_secure )
  {
    v60 = "GCONV_PATH";
    do
    {
      unsetenv(v60);
      v60 = (char *)(j_rawmemchr(v60, 0LL) + 1);
    }
    while ( v60 < &unsecure_envvars_10823[300] );
  }
  if ( dl_platform && !*(_BYTE *)dl_platform )
    dl_platform = 0LL;
  result = (unsigned __int64)getenv("LD_ASSUME_KERNEL");
  v62 = (char *)result;
  if ( result )
  {
    v63 = 0LL;
    for ( i = 0LL; ; ++i )
    {
      result = dl_strtoul(v62, &v70);
      if ( result > 0xFE || v70 == v62 )
        break;
      if ( i == 2 )
      {
        v63 |= result;
LABEL_94:
        if ( v63 )
          dl_osversion = v63;
        break;
      }
      v65 = *v70;
      if ( *v70 && v65 != 46 )
        break;
      result <<= -8 * (unsigned __int8)i + 16;
      v63 |= result;
      if ( !v65 )
        goto LABEL_94;
      v62 = v70 + 1;
    }
  }
  if ( dl_platform )
  {
    result = j_strlen_ifunc(dl_platform);
    dl_platformlen = result;
  }
  v68 = dl_phdr;
  if ( dl_phdr && dl_phnum )
  {
    v69 = 0LL;
    result = dl_phdr + 56;
    if ( *(_DWORD *)dl_phdr == 1685382481 )
    {
LABEL_107:
      result = *(unsigned int *)(v68 + 4);
      dl_stack_flags = *(_DWORD *)(v68 + 4);
    }
    else
    {
      while ( ++v69 != dl_phnum )
      {
        v68 = result;
        result += 56LL;
        if ( *(_DWORD *)(result - 56) == 1685382481 )
          goto LABEL_107;
      }
    }
  }
  return result;
}
// 4404D7: write access to const memory at 4A7A40 has been detected
// 4404E5: write access to const memory at 4A7A48 has been detected
// 440770: variable 'v44' is possibly undefined
// 440770: variable 'v45' is possibly undefined
// 440770: variable 'v46' is possibly undefined
// 440770: variable 'v47' is possibly undefined
// 401038: using guessed type __int64 __fastcall j_rawmemchr(_QWORD, _QWORD);
// 401040: using guessed type __int64 __fastcall j_memcpy(_QWORD, _QWORD, _QWORD);
// 4010C8: using guessed type __int64 __fastcall j_strlen_ifunc(_QWORD);
// 493255: using guessed type unsigned __int8 byte_493255[1707];
// 4A7A40: using guessed type __int64 dyn_temp_10781[];
// 4A7A48: using guessed type __int64 qword_4A7A48;
// 4A7AD8: using guessed type int _libc_enable_secure;
// 4A91E8: using guessed type int dl_stack_flags;
// 4A9210: using guessed type __int64 dl_nns;
// 4A95C8: using guessed type __int64 qword_4A95C8;
// 4A95D8: using guessed type __int16 word_4A95D8;
// 4A9660: using guessed type __int64 qword_4A9660;
// 4AB870: using guessed type __int64 dl_profile_output;
// 4AB878: using guessed type __int64 dl_platformlen;
// 4AB880: using guessed type int dl_debug_mask;
// 4AB898: using guessed type int dl_bind_not;
// 4AB8A8: using guessed type __int64 dl_platform;
// 4AB8B8: using guessed type int dl_lazy;
// 4AB8C0: using guessed type __int64 dl_sysinfo_map;
// 4AB8D0: using guessed type __int64 dl_phdr;
// 4AB8EC: using guessed type int dl_dynamic_weak;
// 4AB8F0: using guessed type __int64 dl_sysinfo_dso;
// 4AB8F8: using guessed type __int64 dl_init_all_dirs;
// 4AB900: using guessed type int dl_verbose;
// 4AB908: using guessed type __int64 dl_phnum;
// 4AB920: using guessed type __int64 dl_all_dirs;
// 4AB928: using guessed type int dl_osversion;

//----- (0000000000440B20) ----------------------------------------------------
void *dl_get_dl_main_map()
{
  return &dl_main_map;
}

//----- (0000000000440B30) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
signed __int64 _libc_init_secure()
{
  signed __int64 result; // rax
  int v1; // ebx
  _BOOL4 v2; // edx
  int v3; // ebx

  result = (unsigned int)_libc_enable_secure_decided;
  if ( !_libc_enable_secure_decided )
  {
    v1 = geteuid();
    result = getuid();
    v2 = 1;
    if ( v1 == (_DWORD)result )
    {
      v3 = getegid();
      result = getgid();
      v2 = v3 != result;
    }
    _libc_enable_secure = v2;
  }
  return result;
}
// 440B56: write access to const memory at 4A7AD8 has been detected
// 4A7AD8: using guessed type int _libc_enable_secure;
// 4AB950: using guessed type int _libc_enable_secure_decided;

//----- (0000000000440B80) ----------------------------------------------------
void __fastcall dl_mcount_wrapper(__int64 a1)
{
  __int64 retaddr; // [rsp+0h] [rbp+0h]

  dl_mcount(retaddr, a1);
}

//----- (0000000000440B90) ----------------------------------------------------
void __fastcall dl_mcount_wrapper_check(__int64 a1)
{
  __int64 retaddr; // [rsp+0h] [rbp+0h]

  if ( dl_profile_map )
    dl_mcount(retaddr, a1);
}
// 4AB910: using guessed type __int64 dl_profile_map;

//----- (0000000000440BC0) ----------------------------------------------------
void __fastcall dl_tunable_set_hwcaps(char **a1)
{
  char *v1; // r12
  char v2; // r13
  char *v3; // rax
  signed __int64 v4; // rax
  signed __int64 v5; // r14
  unsigned __int64 v6; // rax
  unsigned __int64 v7; // rax

  v1 = *a1;
  v2 = **a1;
  do
  {
    while ( v2 == 44 || !v2 )
    {
      v2 = *++v1;
      if ( !*v1 )
        return;
    }
    v3 = v1;
    do
      ++v3;
    while ( *v3 && *v3 != 44 );
    v4 = v3 - v1;
    v5 = v4 + 1;
    if ( v2 == 45 )
    {
      v7 = v4 - 4;
      if ( v7 <= 0x17 )
        __asm { jmp     rax }
    }
    else
    {
      v6 = v4 - 4;
      if ( v6 <= 0x16 )
        __asm { jmp     rax }
    }
    v1 += v5;
    v2 = *v1;
  }
  while ( *v1 );
}

//----- (0000000000441860) ----------------------------------------------------
__int64 __fastcall dl_tunable_set_x86_ibt(const __m128i **a1)
{
  __int64 result; // rax

  if ( (unsigned int)_memcmp_sse2(*a1, byte_493145, 3uLL) )
  {
    if ( (unsigned int)_memcmp_sse2(*a1, "off", 4uLL) )
    {
      result = _memcmp_sse2(*a1, "permissive", 0xBuLL);
      if ( !(_DWORD)result )
      {
        result = dword_4AB8B4 & 0xFFFFFFF8 | 3;
        dword_4AB8B4 = dword_4AB8B4 & 0xFFFFFFF8 | 3;
      }
    }
    else
    {
      result = dword_4AB8B4 & 0xFFFFFFF8 | 1;
      dword_4AB8B4 = dword_4AB8B4 & 0xFFFFFFF8 | 1;
    }
  }
  else
  {
    result = dword_4AB8B4 & 0xFFFFFFF8 | 2;
    dword_4AB8B4 = dword_4AB8B4 & 0xFFFFFFF8 | 2;
  }
  return result;
}
// 493145: using guessed type unsigned __int8 byte_493145[13];
// 4AB8B4: using guessed type int dword_4AB8B4;

//----- (0000000000441900) ----------------------------------------------------
__int64 __fastcall dl_tunable_set_x86_shstk(const __m128i **a1)
{
  __int64 result; // rax

  if ( (unsigned int)_memcmp_sse2(*a1, byte_493145, 3uLL) )
  {
    if ( (unsigned int)_memcmp_sse2(*a1, "off", 4uLL) )
    {
      result = _memcmp_sse2(*a1, "permissive", 0xBuLL);
      if ( !(_DWORD)result )
      {
        result = dword_4AB8B4 & 0xFFFFFFC7 | 0x18;
        dword_4AB8B4 = dword_4AB8B4 & 0xFFFFFFC7 | 0x18;
      }
    }
    else
    {
      result = dword_4AB8B4 & 0xFFFFFFC7 | 8;
      dword_4AB8B4 = dword_4AB8B4 & 0xFFFFFFC7 | 8;
    }
  }
  else
  {
    result = dword_4AB8B4 & 0xFFFFFFC7 | 0x10;
    dword_4AB8B4 = dword_4AB8B4 & 0xFFFFFFC7 | 0x10;
  }
  return result;
}
// 493145: using guessed type unsigned __int8 byte_493145[13];
// 4AB8B4: using guessed type int dword_4AB8B4;

//----- (00000000004419A0) ----------------------------------------------------
__int64 dl_discover_osversion()
{
  int v0; // edx
  char *release; // rsi
  int v2; // er8
  __int64 result; // rax
  int v4; // edx
  _BYTE *v5; // rdi
  int v6; // ecx
  signed int v7; // eax
  unsigned int v8; // er12
  signed __int64 nocancel; // rbp
  char v10[64]; // [rsp+0h] [rbp-1E8h] BYREF
  old_utsname v11; // [rsp+40h] [rbp-1A8h] BYREF

  release = v11.release;
  if ( (unsigned int)uname(&v11) )
  {
    v7 = _open_nocancel("/proc/sys/kernel/osrelease", 0, v0);
    v8 = v7;
    if ( v7 < 0 )
      return 0xFFFFFFFFLL;
    nocancel = _read_nocancel(v7, v10, 0x40uLL);
    _close_nocancel(v8);
    if ( nocancel <= 0 )
      return 0xFFFFFFFFLL;
    release = v10;
    if ( nocancel >= 63 )
      nocancel = 63LL;
    v10[nocancel] = 0;
  }
  v2 = 0;
  LODWORD(result) = 0;
  while ( (unsigned __int8)(*release - 48) <= 9u )
  {
    v4 = release[1];
    v5 = release + 1;
    v6 = *release - 48;
    if ( (unsigned __int8)(v4 - 48) <= 9u )
    {
      do
      {
        ++v5;
        v6 = v4 + 10 * v6 - 48;
        v4 = (char)*v5;
      }
      while ( (unsigned __int8)(*v5 - 48) <= 9u );
    }
    ++v2;
    release = v5 + 1;
    result = (unsigned int)v6 | ((_DWORD)result << 8);
    if ( (_BYTE)v4 != 46 )
    {
      if ( v2 == 3 )
        return result;
      return (unsigned int)((_DWORD)result << (8 * (3 - v2)));
    }
    if ( v2 == 3 )
      return result;
  }
  return (unsigned int)((_DWORD)result << (8 * (3 - v2)));
}
// 441A5B: variable 'v0' is possibly undefined
// 4419A0: using guessed type struct old_utsname var_1A8;
// 4419A0: using guessed type char var_1E8[64];

//----- (0000000000441AB0) ----------------------------------------------------
unsigned __int64 __fastcall _libc_init_first(unsigned int a1, _QWORD *a2, char **a3)
{
  if ( !dl_starting_up || dl_starting_up[0] )
  {
    _libc_multiple_libcs = 0;
    if ( _fpu_control != dl_fpu_control )
      _setfpucw();
  }
  else
  {
    _libc_multiple_libcs = 1;
  }
  _libc_argc = a1;
  _libc_argv = (__int64)a2;
  environ = a3;
  dl_non_dynamic_init();
  _init_misc(a1, a2);
  return _ctype_init();
}
// 4A91EC: using guessed type __int16 dl_fpu_control;
// 4A9200: using guessed type _DWORD dl_starting_up[2];
// 4A97B8: using guessed type int _libc_multiple_libcs;
// 4A9B48: using guessed type __int16 _fpu_control;
// 4AB958: using guessed type int _libc_argc;
// 4AB960: using guessed type __int64 _libc_argv;

//----- (0000000000441B40) ----------------------------------------------------
__int64 __fastcall _gconv_open(char *a1, char *a2, _QWORD *a3, int a4)
{
  char *v5; // r12
  __int64 v6; // rax
  __int64 v7; // rax
  int v8; // ebx
  __int64 v9; // rax
  u32 v10; // er9
  __int64 v11; // rax
  unsigned int transform; // eax
  _QWORD *v13; // rdx
  __int64 v14; // rcx
  u32 *v15; // r8
  __int64 v16; // r9
  _BYTE *v18; // r12
  __int64 v19; // r15
  _QWORD *v20; // rax
  __int64 v21; // rdx
  u32 *v22; // r8
  unsigned __int64 v23; // r9
  __int64 v24; // rcx
  _QWORD *v25; // r14
  const char *v26; // rsi
  u32 *v27; // r8
  unsigned __int64 v28; // r9
  _QWORD *v29; // r13
  unsigned __int64 v30; // r15
  __int64 v31; // r14
  __int64 v32; // rcx
  int v33; // eax
  _QWORD *v34; // rax
  __int64 v35; // rdx
  __int64 v36; // rcx
  bool v37; // zf
  __int64 v38; // rax
  __int64 *v39; // rcx
  __int64 v40; // rsi
  __int64 v41; // rax
  __int64 *v42; // rcx
  __int64 v43; // rsi
  __int64 v44; // rbx
  __int64 v45; // rdx
  __int64 *v46; // rax
  __int64 v47; // rax
  __int64 v48; // rdx
  __int16 v49; // cx
  __int64 *v50; // rax
  unsigned int v51; // ecx
  void *v52; // rsp
  __int64 v53; // rsi
  _BYTE *v54; // rax
  _BYTE *v55; // rax
  _BYTE *i; // r13
  __int64 v57; // rdx
  __int64 *v58; // rax
  void *v59; // rsp
  unsigned __int64 v60; // r14
  unsigned int v61; // er13
  __int64 v62; // rcx
  __int64 *v63; // r15
  __int64 v64; // rdi
  void *v65; // rsp
  void *v66; // rsp
  void *v67; // rsp
  __int64 v68; // [rsp+0h] [rbp-2088h]
  __int64 v69; // [rsp+8h] [rbp-2080h] BYREF
  _BYTE v70[4088]; // [rsp+10h] [rbp-2078h] BYREF
  __int64 v71; // [rsp+1008h] [rbp-1080h] BYREF
  _BYTE v72[7]; // [rsp+1010h] [rbp-1078h] BYREF
  _QWORD *v73; // [rsp+2008h] [rbp-80h] BYREF
  unsigned int v74; // [rsp+2014h] [rbp-74h]
  _QWORD *v75; // [rsp+2018h] [rbp-70h]
  __int64 v76; // [rsp+2020h] [rbp-68h]
  __int64 v77; // [rsp+2028h] [rbp-60h]
  __int64 v78; // [rsp+2030h] [rbp-58h]
  __int64 v79; // [rsp+2040h] [rbp-48h] BYREF
  _BYTE *v80[8]; // [rsp+2048h] [rbp-40h] BYREF

  v5 = a1;
  v73 = a3;
  LODWORD(v77) = a4;
  v80[1] = (_BYTE *)__readfsqword(0x28u);
  v6 = j_strchr_ifunc(a1, 47LL);
  if ( v6 && (v7 = j_strchr_ifunc(v6 + 1, 47LL)) != 0 && *(_BYTE *)(v7 + 1) )
  {
    v44 = v7 + 1;
    v45 = v7 + 1 - (_QWORD)a1;
    v46 = (__int64 *)((char *)&v73 - ((v45 + 24) & 0xFFFFFFFFFFFFF000LL));
    if ( &v73 != (_QWORD **)v46 )
    {
      while ( &v71 != v46 )
        ;
    }
    if ( (((_WORD)v45 + 24) & 0xFF0) != 0 )
    {
      v67 = alloca(((_WORD)v45 + 24) & 0xFF0);
      *(_QWORD *)&v70[(((_WORD)v45 + 24) & 0xFF0) + 4080] = *(_QWORD *)&v70[(((_WORD)v45 + 24) & 0xFF0) + 4080];
    }
    v80[0] = 0LL;
    v72[v45] = 0;
    v5 = (char *)j_memcpy(v72, a1, v45);
    v47 = j_strlen_ifunc(v44);
    v48 = v47 + 1;
    v49 = (v47 + 24) & 0xFFF0;
    v50 = (__int64 *)&v72[-((v47 + 24) & 0xFFFFFFFFFFFFF000LL) - 8];
    if ( &v71 != v50 )
    {
      while ( &v69 != v50 )
        ;
    }
    v51 = v49 & 0xFFF;
    if ( v51 )
    {
      v52 = alloca(v51);
      *(__int64 *)((char *)&v68 + v51) = *(__int64 *)((char *)&v68 + v51);
    }
    v53 = v44;
    v8 = 0;
    v54 = (_BYTE *)j_memcpy(v70, v53, v48);
    v55 = strtok_r(v54, (__int64)&unk_484270, v80);
    LOBYTE(v78) = 0;
    for ( i = v55; i; i = strtok_r(0LL, (__int64)&unk_484270, v80) )
    {
      if ( (unsigned int)j_strcasecmp_l(i, "TRANSLIT", nl_C_locobj) )
      {
        if ( !(unsigned int)j_strcasecmp_l(i, "IGNORE", nl_C_locobj) )
          v8 = 2;
      }
      else
      {
        LOBYTE(v78) = 1;
      }
    }
  }
  else
  {
    LOBYTE(v78) = 0;
    v8 = 0;
  }
  v9 = j_strchr_ifunc(a2, 47LL);
  if ( v9 )
  {
    v11 = j_strchr_ifunc(v9 + 1, 47LL);
    if ( v11 )
    {
      if ( *(_BYTE *)(v11 + 1) )
      {
        v57 = v11 + 1 - (_QWORD)a2;
        v58 = (__int64 *)((char *)&v73 - ((v57 + 24) & 0xFFFFFFFFFFFFF000LL));
        if ( &v73 != (_QWORD **)v58 )
        {
          while ( &v71 != v58 )
            ;
        }
        if ( (((_WORD)v57 + 24) & 0xFF0) != 0 )
        {
          v59 = alloca(((_WORD)v57 + 24) & 0xFF0);
          *(_QWORD *)&v70[(((_WORD)v57 + 24) & 0xFF0) + 4080] = *(_QWORD *)&v70[(((_WORD)v57 + 24) & 0xFF0) + 4080];
        }
        v72[v57] = 0;
        a2 = (char *)j_memcpy(v72, a2, v57);
      }
    }
  }
  if ( !strcmp(v5, "//") )
  {
    v76 = *(_QWORD *)(*(_QWORD *)__readfsqword(0xFFFFFFA0) + 176LL);
    v41 = j_strlen_ifunc(v76);
    v42 = (__int64 *)((char *)&v73 - ((v41 + 26) & 0xFFFFFFFFFFFFF000LL));
    v43 = v76;
    if ( &v73 != (_QWORD **)v42 )
    {
      while ( &v71 != v42 )
        ;
    }
    if ( (((_WORD)v41 + 26) & 0xFF0) != 0 )
    {
      v66 = alloca(((_WORD)v41 + 26) & 0xFF0);
      *(_QWORD *)&v70[(((_WORD)v41 + 26) & 0xFF0) + 4080] = *(_QWORD *)&v70[(((_WORD)v41 + 26) & 0xFF0) + 4080];
    }
    v5 = v72;
    strcpy((char *)j_mempcpy(v72, v43, v41), "//");
  }
  if ( !strcmp(a2, "//") )
  {
    v76 = *(_QWORD *)(*(_QWORD *)__readfsqword(0xFFFFFFA0) + 176LL);
    v38 = j_strlen_ifunc(v76);
    v39 = (__int64 *)((char *)&v73 - ((v38 + 26) & 0xFFFFFFFFFFFFF000LL));
    v40 = v76;
    if ( &v73 != (_QWORD **)v39 )
    {
      while ( &v71 != v39 )
        ;
    }
    if ( (((_WORD)v38 + 26) & 0xFF0) != 0 )
    {
      v65 = alloca(((_WORD)v38 + 26) & 0xFF0);
      *(_QWORD *)&v70[(((_WORD)v38 + 26) & 0xFF0) + 4080] = *(_QWORD *)&v70[(((_WORD)v38 + 26) & 0xFF0) + 4080];
    }
    a2 = v72;
    strcpy((char *)j_mempcpy(v72, v40, v38), "//");
  }
  transform = _gconv_find_transform(
                (unsigned __int8 *)v5,
                (unsigned __int8 *)a2,
                &v79,
                (__int64 *)v80,
                (u32 *)(unsigned int)v77,
                v10);
  v75 = 0LL;
  v74 = transform;
  if ( !transform )
  {
    v18 = v80[0];
    v19 = 48 * (__int64)v80[0];
    v20 = malloc(48 * (__int64)v80[0] + 16, (__int64)a2, v13, v14, v15, v16);
    v24 = v79;
    v25 = v20;
    v75 = v20;
    if ( v20 )
    {
      v20[1] = v79;
      v26 = 0LL;
      *v20 = v18;
      j_memset_ifunc(v20 + 2, 0LL, v19);
      if ( !v18 )
        goto LABEL_11;
      v29 = v25 + 7;
      v30 = 0LL;
      v31 = 0LL;
      while ( 1 )
      {
        v37 = (_BYTE)v78 == 0;
        *(v29 - 1) = v29;
        if ( !v37 )
        {
          v26 = "INTERNAL";
          if ( !(unsigned int)j_strcasecmp_l(*(_QWORD *)(v79 + v31 + 24), "INTERNAL", nl_C_locobj) )
            v8 |= 8u;
        }
        v18 = v80[0];
        if ( v80[0] - 1 <= (_BYTE *)v30 )
        {
          LODWORD(v75[6 * v30 + 4]) = v8 | 1;
          goto LABEL_11;
        }
        v32 = v79;
        *((_DWORD *)v29 - 6) = v8;
        v33 = 8160 * *(_DWORD *)(v32 + v31 + 84);
        v77 = v32;
        v76 = v33;
        v34 = malloc(v33, (__int64)v26, (_QWORD *)v33, v32, v27, v28);
        v36 = v77;
        *(v29 - 5) = v34;
        if ( !v34 )
          break;
        ++v30;
        v29 += 6;
        v31 += 104LL;
        *(v29 - 10) = (char *)v34 + v76;
        if ( (unsigned __int64)v18 <= v30 )
          goto LABEL_11;
      }
      v60 = v30 - 1;
      v61 = __readfsdword(0xFFFFFFC0);
      if ( v30 )
      {
        v62 = (__int64)v75;
        v63 = &v75[6 * v30 - 4];
        do
        {
          v64 = *v63;
          --v60;
          v63 -= 6;
          free(v64, (__int64)v26, v35, v62, v27, v28);
        }
        while ( v60 != -1LL );
        v18 = v80[0];
        v36 = v79;
      }
      v78 = v36;
      free((__int64)v75, (__int64)v26, v35, v36, v27, v28);
      v24 = v78;
    }
    else
    {
      v61 = __readfsdword(0xFFFFFFC0);
    }
    _gconv_close_transform(v24, (__int64)v18, v21, v24, v22, v23);
    __writefsdword(0xFFFFFFC0, v61);
    v74 = 3;
    v75 = 0LL;
  }
LABEL_11:
  *v73 = v75;
  return v74;
}
// 441C22: variable 'v10' is possibly undefined
// 441C80: variable 'v13' is possibly undefined
// 441C80: variable 'v14' is possibly undefined
// 441C80: variable 'v15' is possibly undefined
// 441C80: variable 'v16' is possibly undefined
// 441CF1: variable 'v27' is possibly undefined
// 441CF1: variable 'v28' is possibly undefined
// 4420A3: variable 'v35' is possibly undefined
// 4420A3: variable 'v62' is possibly undefined
// 4420CD: variable 'v21' is possibly undefined
// 4420CD: variable 'v22' is possibly undefined
// 4420CD: variable 'v23' is possibly undefined
// 401040: using guessed type __int64 __fastcall j_memcpy(_QWORD, _QWORD, _QWORD);
// 401088: using guessed type __int64 __fastcall j_strcasecmp_l(_QWORD, _QWORD, _QWORD);
// 401090: using guessed type __int64 __fastcall j_memset_ifunc(_QWORD, _QWORD, _QWORD);
// 4010B0: using guessed type __int64 __fastcall j_mempcpy(_QWORD, _QWORD, _QWORD);
// 4010C8: using guessed type __int64 __fastcall j_strlen_ifunc(_QWORD);
// 4010D0: using guessed type __int64 __fastcall j_strchr_ifunc(_QWORD, _QWORD);
// 4A7DE0: using guessed type char **nl_C_locobj[6];

//----- (0000000000442140) ----------------------------------------------------
__int64 __fastcall _gconv(_QWORD *a1, __int64 *a2, unsigned __int64 a3, __int64 *a4, __int64 a5, _QWORD *a6)
{
  __int64 v8; // rdx
  _QWORD *v9; // rax
  _QWORD *v10; // rax
  __int64 (__fastcall *v11)(_QWORD, _QWORD *, __int64 *, unsigned __int64, _QWORD, _QWORD *, _QWORD, _QWORD); // rbx
  __int64 v12; // r13
  __int64 result; // rax
  _DWORD *v14; // rcx
  unsigned __int64 v15; // rdx
  unsigned __int64 v16; // [rsp+8h] [rbp-48h]

  if ( a1 == (_QWORD *)-1LL )
    return 8LL;
  v16 = *a1 - 1LL;
  if ( !a6 )
    _assert_fail((__int64)"irreversible != NULL", (__int64)"gconv.c", 0x2Bu, "__gconv");
  *a6 = 0LL;
  v8 = 0LL;
  if ( a4 )
    v8 = *a4;
  v9 = &a1[6 * v16];
  v9[2] = v8;
  v9[3] = a5;
  v10 = (_QWORD *)a1[1];
  v11 = (__int64 (__fastcall *)(_QWORD, _QWORD *, __int64 *, unsigned __int64, _QWORD, _QWORD *, _QWORD, _QWORD))v10[5];
  if ( *v10 )
    v11 = (__int64 (__fastcall *)(_QWORD, _QWORD *, __int64 *, unsigned __int64, _QWORD, _QWORD *, _QWORD, _QWORD))(__readfsqword(0x30u) ^ __ROR8__(v11, 17));
  if ( a2 )
  {
    v12 = *a2;
    if ( *a2 )
    {
      if ( !a4 || !*a4 )
        _assert_fail((__int64)"outbuf != NULL && *outbuf != NULL", (__int64)"gconv.c", 0x49u, "__gconv");
      while ( 1 )
      {
        dl_mcount_wrapper_check((__int64)v11);
        result = v11(a1[1], a1 + 2, a2, a3, 0LL, a6, 0LL, 0LL);
        if ( (_DWORD)result != 4 || *a2 == v12 || a3 < *a2 + *(int *)(a1[1] + 72LL) )
          break;
        v12 = *a2;
      }
LABEL_16:
      if ( *a4 )
        *a4 = a1[6 * v16 + 2];
      return result;
    }
  }
  dl_mcount_wrapper_check((__int64)v11);
  result = v11(a1[1], a1 + 2, 0LL, 0LL, 0LL, a6, (unsigned int)(a1[6 * v16 + 2] == 0LL) + 1, 0LL);
  if ( !(_DWORD)result )
  {
    v14 = (_DWORD *)a1 + 9;
    v15 = 0LL;
    do
    {
      *v14 = 0;
      ++v15;
      v14 += 12;
    }
    while ( v16 >= v15 );
  }
  if ( a4 )
    goto LABEL_16;
  return result;
}

//----- (0000000000442350) ----------------------------------------------------
__int64 __fastcall _gconv_close(__int64 *a1, __int64 a2, __int64 a3, __int64 a4, u32 *a5, unsigned __int64 a6)
{
  __int64 *v7; // rbx
  __int64 v8; // r12
  __int64 v9; // r13
  __int64 v10; // rdx
  __int64 v11; // rcx
  u32 *v12; // r8
  unsigned __int64 v13; // r9
  __int64 v15; // rdi

  v7 = a1 + 2;
  v8 = a1[1];
  v9 = *a1;
  while ( (v7[2] & 1) == 0 )
  {
    v15 = *v7;
    v7 += 6;
    if ( v15 )
    {
      free(v15, a2, a3, a4, a5, a6);
      if ( (*(_BYTE *)(v7 - 4) & 1) != 0 )
        break;
    }
  }
  free((__int64)a1, a2, a3, a4, a5, a6);
  return _gconv_close_transform(v8, v9, v10, v11, v12, v13);
}
// 442379: variable 'a3' is possibly undefined
// 442379: variable 'a4' is possibly undefined
// 442379: variable 'a5' is possibly undefined
// 442379: variable 'a6' is possibly undefined
// 44238E: variable 'v10' is possibly undefined
// 44238E: variable 'v11' is possibly undefined
// 44238E: variable 'v12' is possibly undefined
// 44238E: variable 'v13' is possibly undefined

//----- (00000000004423C0) ----------------------------------------------------
__int64 __fastcall _gconv_alias_compare(_QWORD *a1, _QWORD *a2)
{
  return j_strcmp_ifunc(*a1, *a2);
}
// 4010A0: using guessed type __int64 __fastcall j_strcmp_ifunc(_QWORD, _QWORD);

//----- (00000000004423D0) ----------------------------------------------------
__int64 __fastcall derivation_compare(_QWORD *a1, _QWORD *a2)
{
  __int64 result; // rax

  result = j_strcmp_ifunc(*a1, *a2);
  if ( !(_DWORD)result )
    return j_strcmp_ifunc(a1[1], a2[1]);
  return result;
}
// 4010A0: using guessed type __int64 __fastcall j_strcmp_ifunc(_QWORD, _QWORD);

//----- (0000000000442410) ----------------------------------------------------
__int64 _gconv_get_modules_db()
{
  return _gconv_modules_db;
}
// 442410: using guessed type __int64 __fastcall _gconv_get_modules_db();
// 4AB968: using guessed type __int64 _gconv_modules_db;

//----- (0000000000442420) ----------------------------------------------------
__int64 _gconv_get_alias_db()
{
  return _gconv_alias_db;
}
// 442420: using guessed type __int64 __fastcall _gconv_get_alias_db();
// 4AB978: using guessed type __int64 _gconv_alias_db;

//----- (0000000000442430) ----------------------------------------------------
__int64 __fastcall _gconv_release_step(__int64 a1)
{
  __int64 v2; // rdi
  void (__fastcall *v4)(__int64); // rbp
  __int64 result; // rax

  v2 = *(_QWORD *)a1;
  if ( v2 )
  {
    if ( (*(_DWORD *)(a1 + 16))-- == 1 )
    {
      v4 = (void (__fastcall *)(__int64))(__readfsqword(0x30u) ^ __ROR8__(*(_QWORD *)(a1 + 64), 17));
      if ( v4 )
      {
        dl_mcount_wrapper_check((__int64)v4);
        v4(a1);
        v2 = *(_QWORD *)a1;
      }
      result = _gconv_release_shlib(v2);
      *(_QWORD *)a1 = 0LL;
    }
  }
  else if ( *(_QWORD *)(a1 + 64) )
  {
    _assert_fail((__int64)"step->__end_fct == NULL", (__int64)"gconv_db.c", 0xE2u, "__gconv_release_step");
  }
  return result;
}

//----- (00000000004424B0) ----------------------------------------------------
__int64 __fastcall find_derivation(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 *a5, unsigned __int64 *a6)
{
  __int64 v7; // rdx
  __int64 v8; // rsi
  __int64 *v9; // rax
  __int64 v10; // rax
  unsigned __int64 v11; // r15
  __int64 v12; // rcx
  unsigned __int64 *v13; // rax
  __int64 v14; // rbx
  unsigned __int64 v15; // r13
  int v16; // eax
  __int64 v17; // rdi
  _QWORD *shlib; // rax
  __int64 v19; // rcx
  __int64 v20; // r12
  __int64 v21; // rax
  __int64 v22; // r12
  unsigned int v23; // ecx
  __int64 v24; // rax
  __int64 v25; // rcx
  unsigned __int64 v26; // r8
  __int64 v27; // r9
  __int64 v28; // rax
  __int64 v29; // r14
  int v30; // er13
  __int64 v31; // rbx
  __int64 v32; // r12
  int v33; // eax
  const char *v34; // r12
  int v35; // er13
  __int64 v36; // r15
  int v37; // eax
  __int64 v38; // r15
  __int64 v39; // rax
  __int64 v40; // rdi
  __int64 v41; // rax
  __int64 v42; // rdx
  __int64 i; // rax
  __int64 v44; // rax
  int v45; // edi
  __int64 v46; // rcx
  int v47; // edx
  int v48; // eax
  __int64 v49; // rax
  __int64 v50; // rdx
  __int64 v51; // rax
  __int64 v52; // rax
  unsigned __int64 j; // r13
  unsigned __int64 v54; // r15
  _QWORD *v55; // rbx
  unsigned __int64 v56; // r12
  __int64 v57; // r13
  unsigned __int64 v58; // r14
  __int64 v59; // r15
  __int64 v60; // rax
  _BYTE *v61; // rdi
  __int64 *v62; // rax
  __int64 v63; // rdx
  u32 *v64; // r8
  unsigned __int64 v65; // r9
  __int64 v66; // rcx
  __int64 v67; // rcx
  __int64 v68; // rax
  __int64 v69; // rcx
  unsigned int v70; // eax
  __int64 v71; // rdx
  u32 *v72; // r8
  unsigned __int64 v73; // r9
  __int64 v74; // rax
  __int64 v75; // r12
  unsigned __int64 v76; // r15
  unsigned int v77; // ecx
  unsigned __int64 *v78; // r13
  _QWORD *v79; // rbx
  unsigned int v80; // er14
  __int64 v81; // rdi
  __int64 v82; // rdx
  __int64 v83; // rcx
  u32 *v84; // r8
  unsigned __int64 v85; // r9
  __int64 v86; // rbx
  __int64 v87; // rdx
  __int64 v88; // rcx
  u32 *v89; // r8
  unsigned __int64 v90; // r9
  __int64 v91; // rdx
  __int64 v92; // rcx
  u32 *v93; // r8
  unsigned __int64 v94; // r9
  int v95; // ecx
  __int64 v96; // rax
  unsigned __int64 v97; // r13
  __int64 v98; // rax
  __int64 v99; // r14
  __int64 v100; // r12
  __int64 v101; // rbx
  _QWORD *v102; // rdx
  __int64 v103; // rcx
  u32 *v104; // r8
  __int64 v105; // r9
  _QWORD *v106; // rax
  _QWORD *v107; // r13
  __int64 v108; // rsi
  __int64 v109; // rax
  __int64 v110; // rax
  __int64 v111; // rcx
  u32 *v112; // r8
  __int64 v113; // r9
  _QWORD *v114; // rax
  __int64 v115; // rdx
  u32 *v116; // r8
  unsigned __int64 v117; // r9
  __int64 v119; // rdx
  __int64 v120; // rcx
  u32 *v121; // r8
  unsigned __int64 v122; // r9
  __int64 v123; // rdx
  __int64 v124; // rcx
  u32 *v125; // r8
  unsigned __int64 v126; // r9
  unsigned __int64 v127; // r14
  __int64 v128; // rcx
  __int64 v129; // r13
  __int64 v130; // rbx
  __int64 v131; // rdi
  __int64 v132; // rdx
  __int64 v133; // rcx
  u32 *v134; // r8
  unsigned __int64 v135; // r9
  __int64 v136; // rdx
  __int64 v137; // rcx
  u32 *v138; // r8
  unsigned __int64 v139; // r9
  const char *v140; // [rsp-Eh] [rbp-3180h] BYREF
  __int64 v141; // [rsp-6h] [rbp-3178h]
  int v142; // [rsp+2h] [rbp-3170h]
  int v143; // [rsp+6h] [rbp-316Ch]
  __int64 v144; // [rsp+Ah] [rbp-3168h]
  __int64 v145; // [rsp+12h] [rbp-3160h]
  _QWORD *v146; // [rsp+1Ah] [rbp-3158h] BYREF
  _QWORD v147[5]; // [rsp+1032h] [rbp-2140h] BYREF
  __int64 v148; // [rsp+105Ah] [rbp-2118h] BYREF
  __int64 v149; // [rsp+2072h] [rbp-1100h] BYREF
  __int64 v150; // [rsp+207Ah] [rbp-10F8h]
  __int64 v151; // [rsp+2082h] [rbp-10F0h]
  __int64 v152; // [rsp+208Ah] [rbp-10E8h]
  __int64 v153; // [rsp+2092h] [rbp-10E0h]
  _QWORD *v154; // [rsp+209Ah] [rbp-10D8h] BYREF
  __int64 *v155; // [rsp+30B2h] [rbp-C0h]
  __int64 *v156; // [rsp+30BAh] [rbp-B8h]
  __int64 *v157; // [rsp+30C2h] [rbp-B0h]
  __int64 v158; // [rsp+30CAh] [rbp-A8h]
  __int64 v159; // [rsp+30D2h] [rbp-A0h]
  unsigned __int64 *v160; // [rsp+30DAh] [rbp-98h]
  _QWORD *v161; // [rsp+30E2h] [rbp-90h]
  __int64 v162; // [rsp+30EAh] [rbp-88h]
  __int64 v163; // [rsp+30F2h] [rbp-80h]
  const char *v164; // [rsp+30FAh] [rbp-78h]
  __int64 (__fastcall *v165)(__int64); // [rsp+3102h] [rbp-70h]
  _QWORD *v166; // [rsp+310Ah] [rbp-68h]
  __int64 v167; // [rsp+3112h] [rbp-60h] BYREF
  const char *v168; // [rsp+311Ah] [rbp-58h]
  __int64 v169; // [rsp+3122h] [rbp-50h]
  __int64 v170; // [rsp+312Ah] [rbp-48h]
  unsigned __int64 v171; // [rsp+313Ah] [rbp-38h]

  v162 = a1;
  v159 = a2;
  v158 = a4;
  v156 = a5;
  v160 = a6;
  v171 = __readfsqword(0x28u);
  v7 = a1;
  if ( a2 )
    v7 = a2;
  v164 = (const char *)v7;
  if ( a4 )
  {
    v169 = 0LL;
    v8 = (__int64)&known_derivations;
    v170 = 0LL;
    v167 = v158;
    v168 = v164;
    v9 = (__int64 *)tfind(
                      (__int64)&v167,
                      &known_derivations,
                      (__int64 (__fastcall *)(__int64, _QWORD))derivation_compare);
    if ( v9 )
      goto LABEL_5;
    v149 = v158;
    v157 = &v149;
    v24 = j_strlen_ifunc(v158);
    v151 = 0LL;
    v150 = v24;
    v152 = 0LL;
    v153 = 0LL;
    v154 = 0LL;
    v147[0] = a3;
    memset(&v147[2], 0, 24);
    v147[1] = j_strlen_ifunc(a3);
    v148 = 0LL;
    v154 = v147;
    v155 = &v148;
  }
  else
  {
    v167 = a3;
    v8 = (__int64)&known_derivations;
    v169 = 0LL;
    v168 = v164;
    v170 = 0LL;
    v9 = (__int64 *)tfind(
                      (__int64)&v167,
                      &known_derivations,
                      (__int64 (__fastcall *)(__int64, _QWORD))derivation_compare);
    if ( v9 )
    {
LABEL_5:
      v10 = *v9;
      v11 = *(_QWORD *)(v10 + 24);
      v12 = *(_QWORD *)(v10 + 16);
      v13 = v160;
      *v156 = v12;
      *v13 = v11;
      v166 = (_QWORD *)v12;
      v14 = v12 + 104 * v11 - 104;
      v15 = v11;
      if ( !v11 )
        return 0;
      while ( 1 )
      {
        v16 = *(_DWORD *)(v14 + 16);
        *(_DWORD *)(v14 + 16) = v16 + 1;
        if ( !v16 )
        {
          v17 = *(_QWORD *)(v14 + 8);
          if ( v17 )
          {
            shlib = (_QWORD *)_gconv_find_shlib(v17);
            *(_QWORD *)v14 = shlib;
            if ( !shlib )
            {
              v127 = v15;
              v128 = (__int64)v166;
              --*(_DWORD *)(v14 + 16);
              if ( v11 > v15 )
              {
                v129 = v128 + 104 * v11;
                v130 = v128 + 104 * v127;
                do
                {
                  v131 = v130;
                  v130 += 104LL;
                  _gconv_release_step(v131);
                }
                while ( v129 != v130 );
              }
              return 1;
            }
            v19 = shlib[3];
            v20 = shlib[4];
            v21 = shlib[5];
            *(_QWORD *)(v14 + 48) = 0LL;
            *(_QWORD *)(v14 + 56) = v20;
            *(_QWORD *)(v14 + 40) = v19;
            *(_QWORD *)(v14 + 64) = v21;
            v22 = __readfsqword(0x30u) ^ __ROR8__(v20, 17);
            if ( v22 )
            {
              dl_mcount_wrapper_check(v22);
              ((void (__fastcall *)(__int64))v22)(v14);
              v22 = *(_QWORD *)(v14 + 48);
            }
            *(_QWORD *)(v14 + 48) = __ROL8__(__readfsqword(0x30u) ^ v22, 17);
          }
        }
        --v15;
        v14 -= 104LL;
        if ( !v15 )
          return 0;
      }
    }
    v149 = a3;
    v157 = &v149;
    v28 = j_strlen_ifunc(a3);
    v151 = 0LL;
    v150 = v28;
    v152 = 0LL;
    v153 = 0LL;
    v154 = 0LL;
    v155 = (__int64 *)&v154;
    v158 = a3;
  }
  v29 = (__int64)v157;
  v30 = 0;
  LODWORD(v163) = 0x7FFFFFFF;
  LODWORD(v165) = 0x7FFFFFFF;
  v161 = 0LL;
  while ( 1 )
  {
    if ( v30 <= (int)v165 && (v30 != (_DWORD)v165 || *(_DWORD *)(v29 + 16) < (int)v163) )
    {
      v31 = _gconv_modules_db;
      if ( _gconv_modules_db )
      {
        v32 = *(_QWORD *)v29;
        while ( 1 )
        {
          v8 = *(_QWORD *)v31;
          v33 = j_strcmp_ifunc(v32, *(_QWORD *)v31);
          if ( !v33 )
            break;
          if ( v33 >= 0 )
            v31 = *(_QWORD *)(v31 + 48);
          else
            v31 = *(_QWORD *)(v31 + 32);
          if ( !v31 )
            goto LABEL_19;
        }
        while ( 1 )
        {
          v34 = *(const char **)(v31 + 8);
          v8 = v162;
          if ( !strcmp(v34, "-") )
            v34 = v164;
          v35 = *(_DWORD *)(v31 + 16) + v30;
          LODWORD(v166) = *(_DWORD *)(v31 + 20) + *(_DWORD *)(v29 + 16);
          if ( (unsigned int)j_strcmp_ifunc(v34, v162)
            && (!v159 || (v8 = v159, (unsigned int)j_strcmp_ifunc(v34, v159))) )
          {
            if ( (int)v165 > v35 || (_DWORD)v165 == v35 && (int)v163 > (int)v166 )
            {
              v38 = (__int64)v157;
              while ( 1 )
              {
                v8 = *(_QWORD *)v38;
                if ( !(unsigned int)j_strcmp_ifunc(v34, *(_QWORD *)v38) )
                  break;
                v38 = *(_QWORD *)(v38 + 40);
                if ( !v38 )
                {
                  v140 = v34;
                  v39 = j_strlen_ifunc(v34);
                  v143 = v35;
                  v141 = v39;
                  v144 = v31;
                  v142 = (int)v166;
                  v145 = v29;
                  v146 = 0LL;
                  *v155 = (__int64)&v140;
                  v155 = (__int64 *)&v146;
                  goto LABEL_35;
                }
              }
              if ( *(_DWORD *)(v38 + 20) > v35 || *(_DWORD *)(v38 + 20) == v35 && *(_DWORD *)(v38 + 16) > (int)v166 )
              {
                *(_QWORD *)(v38 + 24) = v31;
                v40 = (__int64)v157;
                *(_QWORD *)(v38 + 32) = v29;
                do
                {
                  while ( 1 )
                  {
                    v41 = *(_QWORD *)(v40 + 24);
                    if ( v41 )
                      break;
                    v40 = *(_QWORD *)(v40 + 40);
                    if ( !v40 )
                      goto LABEL_65;
                  }
                  v42 = *(_QWORD *)(v40 + 32);
                  v8 = *(unsigned int *)(v41 + 16);
                  v25 = *(unsigned int *)(v41 + 20);
                  for ( i = *(_QWORD *)(v42 + 24); i; i = *(_QWORD *)(v42 + 24) )
                  {
                    v42 = *(_QWORD *)(v42 + 32);
                    v8 = (unsigned int)(*(_DWORD *)(i + 16) + v8);
                    v25 = (unsigned int)(*(_DWORD *)(i + 20) + v25);
                  }
                  *(_DWORD *)(v40 + 20) = v8;
                  *(_DWORD *)(v40 + 16) = v25;
                  v40 = *(_QWORD *)(v40 + 40);
                }
                while ( v40 );
LABEL_65:
                v44 = (__int64)v161;
                if ( v161 )
                {
                  v26 = (unsigned int)v165;
                  v45 = v163;
                  do
                  {
                    while ( 1 )
                    {
                      v8 = *(_QWORD *)(v44 + 24);
                      v46 = *(_QWORD *)(v44 + 32);
                      v47 = *(_DWORD *)(v8 + 16) + *(_DWORD *)(v46 + 20);
                      v25 = (unsigned int)(*(_DWORD *)(v8 + 20) + *(_DWORD *)(v46 + 16));
                      *(_DWORD *)(v44 + 20) = v47;
                      *(_DWORD *)(v44 + 16) = v25;
                      if ( v47 >= (int)v26 )
                        break;
                      v44 = *(_QWORD *)(v44 + 40);
                      v45 = v25;
                      v26 = (unsigned int)v47;
                      if ( !v44 )
                        goto LABEL_73;
                    }
                    if ( v47 == (_DWORD)v26 && (int)v25 < v45 )
                      v45 = v25;
                    v44 = *(_QWORD *)(v44 + 40);
                  }
                  while ( v44 );
LABEL_73:
                  LODWORD(v165) = v26;
                  LODWORD(v163) = v45;
                }
              }
            }
          }
          else
          {
            if ( v161 )
            {
              v36 = (__int64)v161;
              while ( 1 )
              {
                v8 = *(_QWORD *)v36;
                if ( !(unsigned int)j_strcmp_ifunc(v34, *(_QWORD *)v36) )
                  break;
                v36 = *(_QWORD *)(v36 + 40);
                if ( !v36 )
                  goto LABEL_76;
              }
              if ( *(_DWORD *)(v36 + 20) > v35 || *(_DWORD *)(v36 + 20) == v35 && *(_DWORD *)(v36 + 16) > (int)v166 )
              {
                v48 = (int)v166;
                *(_QWORD *)(v36 + 24) = v31;
                *(_QWORD *)(v36 + 32) = v29;
                *(_DWORD *)(v36 + 20) = v35;
                *(_DWORD *)(v36 + 16) = v48;
              }
            }
            else
            {
LABEL_76:
              v140 = v34;
              v49 = j_strlen_ifunc(v34);
              v143 = v35;
              v141 = v49;
              v144 = v31;
              v142 = (int)v166;
              v145 = v29;
              v146 = v161;
              v161 = &v140;
            }
            if ( (int)v165 > v35 )
            {
              LODWORD(v165) = v35;
              LODWORD(v163) = (_DWORD)v166;
            }
            else if ( (_DWORD)v165 == v35 )
            {
              v37 = (int)v166;
              if ( (int)v163 <= (int)v166 )
                v37 = v163;
              LODWORD(v163) = v37;
            }
          }
LABEL_35:
          v31 = *(_QWORD *)(v31 + 40);
          if ( !v31 )
            break;
          v30 = *(_DWORD *)(v29 + 20);
        }
      }
    }
LABEL_19:
    v29 = *(_QWORD *)(v29 + 40);
    if ( !v29 )
      break;
    v30 = *(_DWORD *)(v29 + 20);
  }
  v50 = (__int64)v161;
  if ( !v161 )
  {
    v54 = 0LL;
    v95 = 1;
    *v156 = 0LL;
    *v160 = 0LL;
    goto LABEL_115;
  }
  v51 = v161[5];
  if ( v51 )
  {
    v50 = *((unsigned int *)v161 + 5);
    if ( *(_DWORD *)(v51 + 20) < (int)v50 )
    {
      v161 = (_QWORD *)v161[5];
    }
    else if ( *(_DWORD *)(v51 + 20) == (_DWORD)v50 )
    {
      v50 = (__int64)v161;
      v25 = *((unsigned int *)v161 + 4);
      if ( *(_DWORD *)(v51 + 16) >= (int)v25 )
        v51 = (__int64)v161;
      v161 = (_QWORD *)v51;
    }
  }
  v52 = v161[4];
  if ( !v52 )
  {
    v161 = malloc(0LL, v8, (_QWORD *)v50, v25, (u32 *)v26, v27);
    if ( v161 )
    {
      v54 = 0LL;
      *v160 = 0LL;
LABEL_121:
      v95 = 0;
      *v156 = (__int64)v161;
      goto LABEL_115;
    }
LABEL_125:
    v54 = 0LL;
    v95 = 3;
    v161 = 0LL;
    *v160 = 0LL;
    *v156 = 0LL;
    goto LABEL_115;
  }
  for ( j = 0LL; ; ++j )
  {
    v52 = *(_QWORD *)(v52 + 32);
    v54 = j + 1;
    if ( !v52 )
      break;
  }
  v55 = malloc(104 * v54, v8, (_QWORD *)v50, v25, (u32 *)v26, v27);
  if ( !v55 )
    goto LABEL_125;
  *v160 = v54;
  if ( j == -1LL )
  {
    v161 = v55;
    goto LABEL_121;
  }
  v163 = 0LL;
  v166 = 0LL;
  v56 = j;
  v57 = (__int64)&v55[13 * j];
  v58 = v54;
  v59 = (__int64)v161;
  while ( 1 )
  {
    if ( v56 )
    {
      *(_QWORD *)(v57 + 24) = **(_QWORD **)(v59 + 32);
    }
    else
    {
      v74 = strdup(v158, v8);
      v166 = (_QWORD *)v74;
      v55[3] = v74;
      if ( !v74 )
      {
        v75 = (__int64)v166;
        v76 = 1LL;
        goto LABEL_106;
      }
    }
    if ( *v160 != v58 )
    {
      *(_QWORD *)(v57 + 32) = v55[13 * v58 + 3];
      goto LABEL_98;
    }
    v96 = strdup(*(_QWORD *)v59, v8);
    v163 = v96;
    *(_QWORD *)(v57 + 32) = v96;
    if ( !v96 )
      break;
LABEL_98:
    v60 = *(_QWORD *)(v59 + 24);
    *(_DWORD *)(v57 + 16) = 1;
    *(_QWORD *)(v57 + 96) = 0LL;
    v61 = *(_BYTE **)(v60 + 24);
    if ( *v61 == 47 )
    {
      v62 = (__int64 *)_gconv_find_shlib((__int64)v61);
      if ( !v62 )
        break;
      v66 = *v62;
      *(_QWORD *)v57 = v62;
      *(_QWORD *)(v57 + 8) = v66;
      *(_QWORD *)(v57 + 40) = v62[3];
      v67 = v62[4];
      v68 = v62[5];
      *(_QWORD *)(v57 + 48) = 0LL;
      *(_QWORD *)(v57 + 56) = v67;
      *(_QWORD *)(v57 + 64) = v68;
      v69 = __readfsqword(0x30u) ^ __ROR8__(v67, 17);
      if ( v69 )
      {
        v165 = (__int64 (__fastcall *)(__int64))v69;
        dl_mcount_wrapper_check(v69);
        v70 = v165(v57);
        if ( v70 )
        {
          v77 = v70;
          v75 = (__int64)v166;
          *(_QWORD *)(v57 + 64) = __ROL8__(__readfsqword(0x30u), 17);
          v76 = v58 - 1;
          if ( *v160 <= v58 - 1 )
          {
            LODWORD(v166) = v70;
            v54 = 0LL;
            free((__int64)v55, v8, v71, v70, v72, v73);
            free(v75, v8, v119, v120, v121, v122);
            free(v163, v8, v123, v124, v125, v126);
            v95 = (int)v166;
            v161 = 0LL;
            *v160 = 0LL;
            *v156 = 0LL;
            goto LABEL_115;
          }
          goto LABEL_107;
        }
        v69 = *(_QWORD *)(v57 + 48);
      }
      *(_QWORD *)(v57 + 48) = __ROL8__(__readfsqword(0x30u) ^ v69, 17);
    }
    else
    {
      v8 = v57;
      _gconv_get_builtin_trans((__int64)v61, v57);
    }
    v59 = *(_QWORD *)(v59 + 32);
    v57 -= 104LL;
    v58 = v56;
    if ( !v56 )
    {
      v161 = v55;
      v54 = *v160;
      goto LABEL_121;
    }
    --v56;
  }
  v97 = v56;
  v75 = (__int64)v166;
  v76 = v97 + 1;
LABEL_106:
  v77 = 0;
  if ( *v160 <= v76 )
  {
    v54 = 0LL;
    free((__int64)v55, v8, v63, 0LL, v64, v65);
    free(v75, v8, v132, v133, v134, v135);
    free(v163, v8, v136, v137, v138, v139);
    v95 = 1;
    v161 = 0LL;
    *v160 = 0LL;
    *v156 = 0LL;
    goto LABEL_115;
  }
LABEL_107:
  v78 = v160;
  v166 = v55;
  v79 = &v55[13 * v76];
  v80 = v77;
  do
  {
    v81 = (__int64)v79;
    ++v76;
    v79 += 13;
    _gconv_release_step(v81);
  }
  while ( v76 < *v78 );
  v86 = (__int64)v166;
  LODWORD(v166) = v80;
  v54 = 0LL;
  free(v86, v8, v82, v83, v84, v85);
  free(v75, v8, v87, v88, v89, v90);
  free(v163, v8, v91, v92, v93, v94);
  v95 = (int)v166;
  v161 = 0LL;
  *v160 = 0LL;
  *v156 = 0LL;
  if ( !v95 )
    v95 = 1;
LABEL_115:
  LODWORD(v166) = v95;
  v98 = j_strlen_ifunc(v158);
  v99 = (__int64)v164;
  v100 = v98 + 1;
  v101 = j_strlen_ifunc(v164) + 1;
  v106 = malloc(v100 + v101 + 32, v8, v102, v103, v104, v105);
  v23 = (unsigned int)v166;
  v107 = v106;
  if ( v106 )
  {
    v108 = v158;
    *v106 = v106 + 4;
    v109 = j_mempcpy(v106 + 4, v108, v100);
    v110 = j_memcpy(v109, v99, v101);
    v107[3] = v54;
    v107[1] = v110;
    v107[2] = v161;
    v114 = tsearch(
             (__int64)v107,
             &known_derivations,
             (__int64 (__fastcall *)(__int64, _QWORD))derivation_compare,
             v111,
             v112,
             v113);
    v23 = (unsigned int)v166;
    if ( !v114 )
    {
      free((__int64)v107, (__int64)&known_derivations, v115, (unsigned int)v166, v116, v117);
      return (unsigned int)v166;
    }
  }
  return v23;
}
// 442C1C: variable 'v25' is possibly undefined
// 442C1C: variable 'v26' is possibly undefined
// 442C1C: variable 'v27' is possibly undefined
// 442DEA: variable 'v82' is possibly undefined
// 442DEA: variable 'v83' is possibly undefined
// 442DEA: variable 'v84' is possibly undefined
// 442DEA: variable 'v85' is possibly undefined
// 442DF2: variable 'v87' is possibly undefined
// 442DF2: variable 'v88' is possibly undefined
// 442DF2: variable 'v89' is possibly undefined
// 442DF2: variable 'v90' is possibly undefined
// 442DFB: variable 'v91' is possibly undefined
// 442DFB: variable 'v92' is possibly undefined
// 442DFB: variable 'v93' is possibly undefined
// 442DFB: variable 'v94' is possibly undefined
// 442EB5: variable 'v102' is possibly undefined
// 442EB5: variable 'v103' is possibly undefined
// 442EB5: variable 'v104' is possibly undefined
// 442EB5: variable 'v105' is possibly undefined
// 442F0D: variable 'v111' is possibly undefined
// 442F0D: variable 'v112' is possibly undefined
// 442F0D: variable 'v113' is possibly undefined
// 443042: variable 'v115' is possibly undefined
// 443042: variable 'v116' is possibly undefined
// 443042: variable 'v117' is possibly undefined
// 442FB0: variable 'v71' is possibly undefined
// 442FB0: variable 'v72' is possibly undefined
// 442FB0: variable 'v73' is possibly undefined
// 442FB8: variable 'v119' is possibly undefined
// 442FB8: variable 'v120' is possibly undefined
// 442FB8: variable 'v121' is possibly undefined
// 442FB8: variable 'v122' is possibly undefined
// 442FC1: variable 'v123' is possibly undefined
// 442FC1: variable 'v124' is possibly undefined
// 442FC1: variable 'v125' is possibly undefined
// 442FC1: variable 'v126' is possibly undefined
// 4430AB: variable 'v63' is possibly undefined
// 4430AB: variable 'v64' is possibly undefined
// 4430AB: variable 'v65' is possibly undefined
// 4430B3: variable 'v132' is possibly undefined
// 4430B3: variable 'v133' is possibly undefined
// 4430B3: variable 'v134' is possibly undefined
// 4430B3: variable 'v135' is possibly undefined
// 4430BC: variable 'v136' is possibly undefined
// 4430BC: variable 'v137' is possibly undefined
// 4430BC: variable 'v138' is possibly undefined
// 4430BC: variable 'v139' is possibly undefined
// 401040: using guessed type __int64 __fastcall j_memcpy(_QWORD, _QWORD, _QWORD);
// 4010A0: using guessed type __int64 __fastcall j_strcmp_ifunc(_QWORD, _QWORD);
// 4010B0: using guessed type __int64 __fastcall j_mempcpy(_QWORD, _QWORD, _QWORD);
// 4010C8: using guessed type __int64 __fastcall j_strlen_ifunc(_QWORD);
// 4AAE78: using guessed type __int64 known_derivations;
// 4AB968: using guessed type __int64 _gconv_modules_db;

//----- (0000000000443110) ----------------------------------------------------
__int64 __fastcall _gconv_compare_alias(unsigned __int8 *a1, unsigned __int8 *a2)
{
  unsigned __int8 *v2; // rbx
  unsigned __int8 *v4; // r12
  unsigned __int64 v5; // rax
  unsigned __int64 v6; // rax
  unsigned int v7; // [rsp+Ch] [rbp-4Ch] BYREF
  __int64 v8[9]; // [rsp+10h] [rbp-48h] BYREF

  v2 = a1;
  v8[3] = __readfsqword(0x28u);
  if ( !once_0 )
  {
    _gconv_read_conf((__int64)a1, (__int64)a2);
    once_0 |= 2u;
  }
  if ( !(unsigned int)_gconv_compare_alias_cache(a1, a2, &v7) )
    return v7;
  v8[0] = (__int64)a2;
  v4 = a2;
  v5 = tfind((__int64)v8, &_gconv_alias_db, (__int64 (__fastcall *)(__int64, _QWORD))_gconv_alias_compare);
  if ( v5 )
  {
    v4 = *(unsigned __int8 **)(*(_QWORD *)v5 + 8LL);
    if ( !v4 )
      v4 = a2;
  }
  v8[0] = (__int64)a1;
  v6 = tfind((__int64)v8, &_gconv_alias_db, (__int64 (__fastcall *)(__int64, _QWORD))_gconv_alias_compare);
  if ( v6 )
  {
    a1 = *(unsigned __int8 **)(*(_QWORD *)v6 + 8LL);
    if ( !a1 )
      a1 = v2;
  }
  return j_strcmp_ifunc(a1, v4);
}
// 4010A0: using guessed type __int64 __fastcall j_strcmp_ifunc(_QWORD, _QWORD);
// 4AAE70: using guessed type int once_0;
// 4AB978: using guessed type __int64 _gconv_alias_db;

//----- (0000000000443230) ----------------------------------------------------
__int64 __fastcall _gconv_find_transform(
        unsigned __int8 *a1,
        unsigned __int8 *a2,
        __int64 *a3,
        __int64 *a4,
        u32 *a5,
        u32 a6)
{
  char v7; // r13
  unsigned int v11; // eax
  __int64 v12; // rcx
  u32 *v13; // r8
  u32 v14; // er9
  __int64 derivation; // rdx
  unsigned __int64 v16; // rax
  unsigned __int64 v17; // rcx
  unsigned __int64 v18; // rax
  __int64 v19; // rcx
  __int64 v20; // r15
  __int64 v21; // rcx
  u32 *v22; // r8
  u32 v23; // er9
  unsigned __int8 *v25; // rsi
  __int64 v26; // rdx
  u32 *v27; // r8
  u32 v28; // er9
  int v29; // eax
  int v30; // eax
  __int64 v31; // [rsp+8h] [rbp-60h]
  unsigned __int8 *v32; // [rsp+8h] [rbp-60h]
  __int64 v33[11]; // [rsp+10h] [rbp-58h] BYREF

  v7 = (char)a5;
  v33[3] = __readfsqword(0x28u);
  if ( !once_0 )
  {
    _gconv_read_conf((__int64)a1, (__int64)a2);
    once_0 |= 2u;
  }
  _ESI = 1;
  if ( !_libc_multiple_threads )
  {
    __asm { cmpxchg cs:__gconv_lock, esi }
    if ( !_libc_multiple_threads )
      goto LABEL_7;
    goto LABEL_6;
  }
  if ( _InterlockedCompareExchange(&_gconv_lock, 1, 0) )
LABEL_6:
    _lll_lock_wait_private((u32 *)&_gconv_lock, 1LL, (__int64)a3, (__int64)a4, a5, a6);
LABEL_7:
  v11 = _gconv_lookup_cache(a1, a2, a3, a4, v7);
  LODWORD(derivation) = v11;
  if ( v11 != 2 )
  {
    if ( _libc_multiple_threads )
    {
      if ( !_InterlockedDecrement(&_gconv_lock) )
        return (unsigned int)derivation;
    }
    else if ( !--_gconv_lock )
    {
      return (unsigned int)derivation;
    }
    _lll_unlock_wake_private((u32 *)&_gconv_lock, (__int64)a2, v11, v12, v13, v14);
    return (unsigned int)derivation;
  }
  if ( !_gconv_modules_db )
  {
    if ( _libc_multiple_threads )
    {
      if ( !_InterlockedDecrement(&_gconv_lock) )
        goto LABEL_34;
    }
    else if ( !--_gconv_lock )
    {
LABEL_34:
      LODWORD(derivation) = 1;
      return (unsigned int)derivation;
    }
    _lll_unlock_wake_private((u32 *)&_gconv_lock, (__int64)a2, v11, v12, v13, v14);
    goto LABEL_34;
  }
  v33[0] = (__int64)a2;
  v16 = tfind((__int64)v33, &_gconv_alias_db, (__int64 (__fastcall *)(__int64, _QWORD))_gconv_alias_compare);
  v17 = v16;
  if ( v16 )
    v17 = *(_QWORD *)(*(_QWORD *)v16 + 8LL);
  v31 = v17;
  v33[0] = (__int64)a1;
  v18 = tfind((__int64)v33, &_gconv_alias_db, (__int64 (__fastcall *)(__int64, _QWORD))_gconv_alias_compare);
  v19 = v31;
  v20 = v18;
  if ( v18 )
    v20 = *(_QWORD *)(*(_QWORD *)v18 + 8LL);
  if ( (v7 & 1) != 0 )
  {
    v25 = a2;
    if ( !(unsigned int)j_strcmp_ifunc(a1, a2) )
      goto LABEL_42;
    v19 = v31;
    if ( v20 )
    {
      v25 = a2;
      v29 = j_strcmp_ifunc(v20, a2);
      v19 = v31;
      if ( !v29 )
        goto LABEL_42;
    }
    if ( v19 )
    {
      v25 = (unsigned __int8 *)v19;
      v32 = (unsigned __int8 *)v19;
      if ( !(unsigned int)j_strcmp_ifunc(a1, v19)
        || (v19 = (__int64)v32, v20) && (v25 = v32, v30 = j_strcmp_ifunc(v20, v32), v19 = (__int64)v32, !v30) )
      {
LABEL_42:
        if ( _libc_multiple_threads )
        {
          if ( !_InterlockedDecrement(&_gconv_lock) )
            goto LABEL_47;
        }
        else if ( !--_gconv_lock )
        {
LABEL_47:
          LODWORD(derivation) = -1;
          return (unsigned int)derivation;
        }
        _lll_unlock_wake_private((u32 *)&_gconv_lock, (__int64)v25, v26, v19, v27, v28);
        goto LABEL_47;
      }
    }
  }
  derivation = (unsigned int)find_derivation((__int64)a1, v20, (__int64)a2, v19, a3, (unsigned __int64 *)a4);
  if ( !_libc_multiple_threads )
  {
    if ( !--_gconv_lock )
      goto LABEL_19;
    goto LABEL_18;
  }
  if ( _InterlockedDecrement(&_gconv_lock) )
LABEL_18:
    _lll_unlock_wake_private((u32 *)&_gconv_lock, v20, derivation, v21, v22, v23);
LABEL_19:
  if ( !(_DWORD)derivation )
    LODWORD(derivation) = *a3 == 0;
  return (unsigned int)derivation;
}
// 4432B5: variable 'a3' is possibly undefined
// 4432B5: variable 'a4' is possibly undefined
// 4432B5: variable 'a5' is possibly undefined
// 4432B5: variable 'a6' is possibly undefined
// 44339B: variable 'v21' is possibly undefined
// 44339B: variable 'v22' is possibly undefined
// 44339B: variable 'v23' is possibly undefined
// 4433A9: variable 'derivation' is possibly undefined
// 4433EA: variable 'v12' is possibly undefined
// 4433EA: variable 'v13' is possibly undefined
// 4433EA: variable 'v14' is possibly undefined
// 44351F: variable 'v26' is possibly undefined
// 44351F: variable 'v19' is possibly undefined
// 44351F: variable 'v27' is possibly undefined
// 44351F: variable 'v28' is possibly undefined
// 4010A0: using guessed type __int64 __fastcall j_strcmp_ifunc(_QWORD, _QWORD);
// 4AAE70: using guessed type int once_0;
// 4AB820: using guessed type int _libc_multiple_threads;
// 4AB968: using guessed type __int64 _gconv_modules_db;
// 4AB970: using guessed type int _gconv_lock;
// 4AB978: using guessed type __int64 _gconv_alias_db;

//----- (0000000000443540) ----------------------------------------------------
__int64 __fastcall _gconv_close_transform(__int64 a1, __int64 a2, __int64 a3, __int64 a4, u32 *a5, unsigned __int64 a6)
{
  __int64 i; // rbx
  __int64 v9; // rdx
  __int64 v10; // rcx
  u32 *v11; // r8
  u32 v12; // er9

  _ESI = 1;
  if ( !_libc_multiple_threads )
  {
    __asm { cmpxchg cs:__gconv_lock, esi }
    if ( !_libc_multiple_threads )
      goto LABEL_6;
    goto LABEL_5;
  }
  if ( _InterlockedCompareExchange(&_gconv_lock, 1, 0) )
LABEL_5:
    _lll_lock_wait_private((u32 *)&_gconv_lock, 1LL, a3, a4, a5, a6);
LABEL_6:
  if ( a2 )
  {
    for ( i = a1 + 104 * a2 - 104; ; i -= 104LL )
    {
      _gconv_release_step(i);
      if ( i == a1 )
        break;
    }
  }
  _gconv_release_cache(a1, a2, a3, a4, a5, a6);
  if ( _libc_multiple_threads )
  {
    if ( !_InterlockedDecrement(&_gconv_lock) )
      return 0LL;
    goto LABEL_14;
  }
  if ( --_gconv_lock )
LABEL_14:
    _lll_unlock_wake_private((u32 *)&_gconv_lock, a2, v9, v10, v11, v12);
  return 0LL;
}
// 4435C2: variable 'a3' is possibly undefined
// 4435C2: variable 'a4' is possibly undefined
// 4435C2: variable 'a5' is possibly undefined
// 4435C2: variable 'a6' is possibly undefined
// 4435F1: variable 'v9' is possibly undefined
// 4435F1: variable 'v10' is possibly undefined
// 4435F1: variable 'v11' is possibly undefined
// 4435F1: variable 'v12' is possibly undefined
// 4AB820: using guessed type int _libc_multiple_threads;
// 4AB970: using guessed type int _gconv_lock;

//----- (0000000000443610) ----------------------------------------------------
void __fastcall insert_module(__int64 a1, int a2)
{
  _QWORD *v3; // r13
  __int64 *v4; // rbp
  __int64 v5; // r12
  int v6; // eax
  __int64 *v7; // rbx
  _QWORD *v8; // rbx
  __int64 v9; // r15
  __int64 v10; // rsi
  __int64 v11; // rdx
  __int64 v12; // rcx
  u32 *v13; // r8
  unsigned __int64 v14; // r9
  int v15; // eax

  v3 = (_QWORD *)a1;
  v4 = &_gconv_modules_db;
  while ( 1 )
  {
    v8 = (_QWORD *)*v4;
    if ( !*v4 )
      goto LABEL_6;
    v5 = *(_QWORD *)a1;
    v6 = j_strcmp_ifunc(*(_QWORD *)a1, *v8);
    if ( !v6 )
      break;
    v4 = v8 + 4;
    v7 = v8 + 6;
    if ( v6 >= 0 )
      v4 = v7;
  }
  v9 = *(_QWORD *)(a1 + 8);
  v10 = v8[1];
  if ( (unsigned int)j_strcmp_ifunc(v9, v10) )
  {
    while ( 1 )
    {
      v4 = v8 + 5;
      v8 = (_QWORD *)v8[5];
      if ( !v8 )
        break;
      if ( !(unsigned int)j_strcmp_ifunc(v5, *v8) )
      {
        v10 = v8[1];
        if ( !(unsigned int)j_strcmp_ifunc(v9, v10) )
          goto LABEL_12;
      }
    }
LABEL_6:
    *v4 = a1;
    return;
  }
LABEL_12:
  v15 = *((_DWORD *)v8 + 4);
  if ( *(_DWORD *)(a1 + 16) < v15 || *(_DWORD *)(a1 + 16) == v15 && *(_DWORD *)(a1 + 20) < *((_DWORD *)v8 + 5) )
  {
    a1 = (__int64)v8;
    v3[4] = v8[4];
    v3[6] = v8[6];
    v3[5] = v8[5];
    *v4 = (__int64)v3;
LABEL_18:
    free(a1, v10, v11, v12, v13, v14);
    return;
  }
  if ( a2 )
    goto LABEL_18;
}
// 4436FF: variable 'v11' is possibly undefined
// 4436FF: variable 'v12' is possibly undefined
// 4436FF: variable 'v13' is possibly undefined
// 4436FF: variable 'v14' is possibly undefined
// 4010A0: using guessed type __int64 __fastcall j_strcmp_ifunc(_QWORD, _QWORD);
// 4AB968: using guessed type __int64 _gconv_modules_db;

//----- (0000000000443710) ----------------------------------------------------
__int64 __fastcall detect_conflict(__int64 a1)
{
  _QWORD *v1; // rbx
  int v2; // eax

  v1 = (_QWORD *)_gconv_modules_db;
  if ( !_gconv_modules_db )
    return 0LL;
  while ( 1 )
  {
    v2 = j_strcmp_ifunc(a1, *v1);
    if ( !v2 )
      break;
    if ( v2 >= 0 )
    {
      v1 = (_QWORD *)v1[6];
      if ( !v1 )
        return 0LL;
    }
    else
    {
      v1 = (_QWORD *)v1[4];
      if ( !v1 )
        return 0LL;
    }
  }
  return 1LL;
}
// 4010A0: using guessed type __int64 __fastcall j_strcmp_ifunc(_QWORD, _QWORD);
// 4AB968: using guessed type __int64 _gconv_modules_db;

//----- (0000000000443770) ----------------------------------------------------
unsigned __int64 __fastcall add_module_isra_0(char *a1, __int64 a2, __int64 a3, int a4)
{
  char *v4; // r15
  __int64 v6; // rax
  char v7; // si
  char *i; // r10
  _BYTE *v9; // rdi
  __int64 v11; // rax
  __int64 v12; // r10
  char *v13; // r14
  char j; // di
  _BYTE *v15; // rbx
  _BYTE *v16; // r11
  char *v17; // rbx
  __int64 v18; // rsi
  char v19; // al
  char *k; // r12
  char *v21; // rsi
  _BYTE *v22; // r12
  char v23; // al
  int v24; // er14
  __int64 v25; // rax
  __int64 v26; // r10
  __int64 *v27; // rsi
  int v28; // ecx
  __int64 v29; // rdx
  __int64 v30; // rcx
  u32 *v31; // r8
  __int64 v32; // r9
  u32 *v33; // rax
  __int64 v34; // r12
  __int64 v35; // rdx
  __int64 v36; // rax
  __int64 v37; // r10
  __int64 v38; // rax
  int v39; // ecx
  __int64 v40; // rax
  int v41; // eax
  void *v42; // rsp
  __int64 v43; // [rsp+0h] [rbp-1088h]
  __int64 v44; // [rsp+8h] [rbp-1080h] BYREF
  _BYTE v45[7]; // [rsp+10h] [rbp-1078h] BYREF
  __int64 v46; // [rsp+1008h] [rbp-80h] BYREF
  __int64 v47; // [rsp+1010h] [rbp-78h]
  int v48; // [rsp+101Ch] [rbp-6Ch]
  _BYTE *v49; // [rsp+1020h] [rbp-68h]
  __int64 v50; // [rsp+1028h] [rbp-60h]
  __int64 v51; // [rsp+1030h] [rbp-58h]
  char *v52[3]; // [rsp+1038h] [rbp-50h] BYREF
  unsigned __int64 v53; // [rsp+1050h] [rbp-38h]

  v4 = a1;
  v51 = a2;
  v53 = __readfsqword(0x28u);
  v6 = *a1;
  if ( (word_486FE0[v6] & 0x2000) != 0 )
  {
    do
    {
      v6 = *++v4;
      v7 = *v4;
    }
    while ( (word_486FE0[v6] & 0x2000) != 0 );
  }
  else
  {
    v7 = *a1;
  }
  if ( v7 )
  {
    for ( i = v4; ; ++i )
    {
      v9 = i + 1;
      *i = dword_4866E0[v6];
      v6 = i[1];
      if ( !(_BYTE)v6 )
        break;
      if ( (word_486FE0[v6] & 0x2000) != 0 )
      {
        v11 = i[2];
        v12 = (__int64)(i + 2);
        *v9 = 0;
        v13 = (char *)v12;
        for ( j = v11; (word_486FE0[v11] & 0x2000) != 0; j = *v13 )
          v11 = *++v13;
        v15 = (_BYTE *)v12;
        if ( j )
        {
          while ( 1 )
          {
            ++v13;
            v16 = v15 + 1;
            *v15 = dword_4866E0[v11];
            v11 = *v13;
            if ( !(_BYTE)v11 )
              break;
            if ( (word_486FE0[v11] & 0x2000) != 0 )
            {
              *v16 = 0;
              v17 = v15 + 2;
              do
              {
                v18 = *++v13;
                v19 = *v13;
              }
              while ( (word_486FE0[v18] & 0x2000) != 0 );
              if ( (_BYTE)v18 )
              {
                for ( k = v17; ; ++k )
                {
                  ++v13;
                  v21 = k + 1;
                  *k = v19;
                  v19 = *v13;
                  if ( !*v13 )
                    break;
                  if ( (word_486FE0[v19] & 0x2000) != 0 )
                  {
                    *v21 = 0;
                    LODWORD(v47) = a4;
                    v22 = k + 2;
                    v49 = v16;
                    v50 = v12;
                    v41 = strtoq(v13, v52, 10);
                    v12 = v50;
                    v16 = v49;
                    a4 = v47;
                    v48 = v41;
                    if ( v52[0] == v13 || v41 <= 0 )
                      v48 = 1;
                    goto LABEL_25;
                  }
                }
              }
              else
              {
                v21 = v17;
              }
              *v21 = 0;
              v22 = v21 + 1;
              v48 = 1;
LABEL_25:
              v23 = v16[1];
              if ( v23 )
              {
                v24 = 3;
                if ( v23 == 47 )
                  a3 = 0LL;
                v47 = v22 - v17;
                if ( v22 - v17 > 3 )
                  v24 = 3 * (*((_DWORD *)v22 - 1) != 7303982);
                LODWORD(v49) = a4;
                v50 = v12;
                v46 = v12 - (_QWORD)v4;
                v25 = j_strnlen(v4, v12 - (_QWORD)v4);
                v26 = v50;
                v27 = (__int64 *)((char *)&v46 - ((v25 + 24) & 0xFFFFFFFFFFFFF000LL));
                v28 = (int)v49;
                if ( &v46 != v27 )
                {
                  while ( &v44 != v27 )
                    ;
                }
                if ( (((_WORD)v25 + 24) & 0xFF0) != 0 )
                {
                  v42 = alloca(((_WORD)v25 + 24) & 0xFF0);
                  *(__int64 *)((char *)&v43 + (((_WORD)v25 + 24) & 0xFF0)) = *(__int64 *)((char *)&v43
                                                                                        + (((_WORD)v25 + 24) & 0xFF0));
                }
                LODWORD(v49) = v28;
                v50 = v26;
                v45[v25] = 0;
                v52[0] = (char *)j_memcpy(v45, v4, v25);
                if ( !tfind(
                        (__int64)v52,
                        &_gconv_alias_db,
                        (__int64 (__fastcall *)(__int64, _QWORD))_gconv_alias_compare) )
                {
                  v33 = calloc(1LL, v24 + a3 + v22 - v4 + 56, v29, v30, v31, v32);
                  v34 = (__int64)v33;
                  if ( v33 )
                  {
                    v35 = v46;
                    *(_QWORD *)v33 = v33 + 14;
                    v36 = j_mempcpy(v33 + 14, v4, v35);
                    v37 = v50;
                    *(_QWORD *)(v34 + 8) = v36;
                    v38 = j_mempcpy(v36, v37, &v17[-v37]);
                    v39 = v48;
                    *(_QWORD *)(v34 + 24) = v38;
                    *(_DWORD *)(v34 + 16) = v39;
                    *(_DWORD *)(v34 + 20) = (_DWORD)v49;
                    if ( a3 )
                      v38 = j_mempcpy(v38, v51, a3);
                    v40 = j_mempcpy(v38, v17, v47);
                    if ( v24 )
                      *(_DWORD *)(v40 - 1) = gconv_module_ext;
                    insert_module(v34, 1);
                  }
                }
              }
              return __readfsqword(0x28u) ^ v53;
            }
            ++v15;
          }
        }
        return __readfsqword(0x28u) ^ v53;
      }
    }
  }
  return __readfsqword(0x28u) ^ v53;
}
// 4439E0: variable 'v29' is possibly undefined
// 4439E0: variable 'v30' is possibly undefined
// 4439E0: variable 'v31' is possibly undefined
// 4439E0: variable 'v32' is possibly undefined
// 401028: using guessed type __int64 __fastcall j_strnlen(_QWORD, _QWORD);
// 401040: using guessed type __int64 __fastcall j_memcpy(_QWORD, _QWORD, _QWORD);
// 4010B0: using guessed type __int64 __fastcall j_mempcpy(_QWORD, _QWORD, _QWORD);
// 484464: using guessed type int gconv_module_ext;
// 4866E0: using guessed type unsigned int dword_4866E0[256];
// 486FE0: using guessed type _WORD word_486FE0[256];
// 4AB978: using guessed type __int64 _gconv_alias_db;

//----- (0000000000443B20) ----------------------------------------------------
__int64 *__fastcall add_alias2_isra_1_part_2(__int64 a1, __int64 a2, __int64 a3, __int64 a4, u32 *a5, __int64 a6)
{
  _QWORD *v6; // rbp
  __int64 *result; // rax
  __int64 *v8; // rbx
  __int64 v9; // rax
  __int64 v10; // rcx
  u32 *v11; // r8
  __int64 v12; // r9
  __int64 v13; // rdx
  __int64 v14; // rcx
  u32 *v15; // r8
  unsigned __int64 v16; // r9

  v6 = (_QWORD *)(a3 - a1);
  result = malloc((unsigned __int64)(v6 + 2), a2, v6, a4, a5, a6);
  if ( result )
  {
    v8 = result;
    v9 = j_memcpy(result + 2, a1, v6);
    *v8 = v9;
    v8[1] = a2 - a1 + v9;
    result = tsearch(
               (__int64)v8,
               &_gconv_alias_db,
               (__int64 (__fastcall *)(__int64, _QWORD))_gconv_alias_compare,
               v10,
               v11,
               v12);
    if ( !result || v8 != (__int64 *)*result )
      return free((__int64)v8, (__int64)&_gconv_alias_db, v13, v14, v15, v16);
  }
  return result;
}
// 443B74: variable 'v10' is possibly undefined
// 443B74: variable 'v11' is possibly undefined
// 443B74: variable 'v12' is possibly undefined
// 443B90: variable 'v13' is possibly undefined
// 443B90: variable 'v14' is possibly undefined
// 443B90: variable 'v15' is possibly undefined
// 443B90: variable 'v16' is possibly undefined
// 401040: using guessed type __int64 __fastcall j_memcpy(_QWORD, _QWORD, _QWORD);
// 4AB978: using guessed type __int64 _gconv_alias_db;

//----- (0000000000443BB0) ----------------------------------------------------
unsigned __int64 __fastcall _gconv_get_path(__int64 a1, __int64 a2, __int64 a3, __int64 a4, u32 *a5, u32 a6)
{
  __int64 v7; // rbx
  __int64 v9; // r13
  __int64 v10; // rax
  __int64 v11; // rax
  __m128i si128; // xmm0
  __int64 v13; // rcx
  u32 *v14; // r8
  __int64 v15; // r9
  char *v16; // rax
  _QWORD *v17; // rdx
  __int64 v18; // rcx
  u32 *v19; // r8
  __int64 v20; // r9
  __int64 v21; // r15
  int v22; // er14
  int v23; // er12
  __int64 v24; // rax
  __int64 v25; // rdi
  __int64 v26; // r12
  __int64 v27; // r15
  __int64 v28; // rax
  _QWORD *v29; // rax
  __int64 v30; // rdx
  __int64 v31; // rcx
  u32 *v32; // r8
  unsigned __int64 v33; // r9
  _BYTE *v34; // r14
  _BYTE *v35; // r15
  _QWORD *v36; // rbx
  int v37; // er12
  _BYTE *v38; // rax
  _BYTE *v39; // rax
  unsigned __int64 v40; // rdx
  bool v41; // cc
  _QWORD *v42; // rax
  void *v43; // rsp
  __m128i v44; // [rsp-Eh] [rbp-1080h] BYREF
  char v45; // [rsp+2h] [rbp-1070h]
  __int64 v46; // [rsp+100Ah] [rbp-68h]
  __m128i *v47; // [rsp+1012h] [rbp-60h] BYREF
  __int64 v48; // [rsp+101Ah] [rbp-58h]
  __int64 v49; // [rsp+1022h] [rbp-50h]
  __int64 v50; // [rsp+102Ah] [rbp-48h]
  __m128i *v51; // [rsp+1032h] [rbp-40h] BYREF
  unsigned __int64 v52; // [rsp+103Ah] [rbp-38h]

  _RSI = 1LL;
  v52 = __readfsqword(0x28u);
  if ( !_libc_multiple_threads )
  {
    __asm { cmpxchg cs:lock_12717, esi }
    if ( !_libc_multiple_threads )
      goto LABEL_6;
    goto LABEL_5;
  }
  if ( _InterlockedCompareExchange(&lock_12717, 1, 0) )
LABEL_5:
    _lll_lock_wait_private((u32 *)&lock_12717, 1LL, a3, a4, a5, a6);
LABEL_6:
  v7 = _gconv_path_elem;
  if ( !_gconv_path_elem )
  {
    v9 = _gconv_path_envvar;
    if ( _gconv_path_envvar )
    {
      v10 = j_strlen_ifunc(_gconv_path_envvar);
      v50 = v10 + 18;
      while ( &v47 != (__m128i **)((char *)&v47 - ((v10 + 41) & 0xFFFFFFFFFFFFF000LL)) )
        ;
      if ( (((_WORD)v10 + 41) & 0xFF0) != 0 )
      {
        v43 = alloca(((_WORD)v10 + 41) & 0xFF0);
        *(__int64 *)((char *)&v46 + (((_WORD)v10 + 41) & 0xFF0)) = *(__int64 *)((char *)&v46
                                                                              + (((_WORD)v10 + 41) & 0xFF0));
      }
      v51 = (__m128i *)&v47;
      v11 = j_mempcpy(&v47, v9, v10);
      si128 = _mm_load_si128((const __m128i *)&default_gconv_path);
      *(_BYTE *)v11 = 58;
      *(_BYTE *)(v11 + 17) = 0;
      *(__m128i *)(v11 + 1) = si128;
      v16 = getcwd(0LL, 0LL, 0LL, v13, v14, v15);
      v9 = (__int64)v16;
      if ( v16 )
      {
        v49 = j_strlen_ifunc(v16);
        v47 = v51;
        v48 = v49 + 1;
      }
      else
      {
        v48 = 1LL;
        v49 = 0LL;
        v47 = v51;
      }
    }
    else
    {
      v48 = 1LL;
      v49 = 0LL;
      v44 = _mm_load_si128((const __m128i *)&default_gconv_path);
      v47 = &v44;
      v51 = &v44;
      v45 = 0;
      v50 = 17LL;
    }
    _RSI = 58LL;
    v21 = j_strchr_ifunc(v47, 58LL);
    if ( v21 )
    {
      v22 = 1;
      while ( 1 )
      {
        v23 = v22 + 1;
        if ( v21 != v7 + 1 )
        {
          v23 = v22 + 2;
          ++v22;
        }
        _RSI = 58LL;
        v7 = v21;
        v24 = j_strchr_ifunc(v21 + 1, 58LL);
        if ( !v24 )
          break;
        v21 = v24;
      }
      v25 = v23;
      v19 = (u32 *)(unsigned int)(v22 - 1);
      v26 = v22;
      v27 = (int)v19 * v48;
      v28 = 16 * v25;
    }
    else
    {
      v27 = 0LL;
      v26 = 1LL;
      v28 = 32LL;
    }
    v29 = malloc(v27 + v50 + v28 + v26, 58LL, v17, v18, v19, v20);
    v48 = (__int64)v29;
    if ( v29 )
    {
      _gconv_max_path_elem_len = 0LL;
      v34 = &v29[2 * v26 + 2];
      v50 = (__int64)&v51;
      v35 = strtok_r(v47, (__int64)":", (_BYTE **)&v51);
      if ( !v35 )
        _assert_fail((__int64)"elem != NULL", (__int64)"gconv_conf.c", 0x1EFu, "__gconv_get_path");
      v36 = (_QWORD *)v48;
      v37 = 0;
      do
      {
        *v36 = v34;
        if ( *v35 != 47 )
        {
          if ( !v9 )
            _assert_fail((__int64)"cwd != NULL", (__int64)"gconv_conf.c", 0x1F5u, "__gconv_get_path");
          v38 = (_BYTE *)j_mempcpy(v34, v9, v49);
          *v38 = 47;
          v34 = v38 + 1;
        }
        v39 = (_BYTE *)j_stpcpy(v34);
        if ( *(v39 - 1) != 47 )
          *v39++ = 47;
        v40 = (unsigned __int64)&v39[-*v36];
        v41 = v40 <= _gconv_max_path_elem_len;
        v36[1] = v40;
        if ( !v41 )
          _gconv_max_path_elem_len = v40;
        *v39 = 0;
        _RSI = (__int64)":";
        v34 = v39 + 1;
        ++v37;
        v36 += 2;
        v35 = strtok_r(0LL, (__int64)":", (_BYTE **)v50);
      }
      while ( v35 );
      v42 = (_QWORD *)(16LL * v37 + v48);
      *v42 = 0LL;
      v42[1] = 0LL;
    }
    else
    {
      v48 = (__int64)&empty_path_elem;
    }
    _gconv_path_elem = v48;
    free(v9, _RSI, v30, v31, v32, v33);
  }
  if ( _libc_multiple_threads )
  {
    if ( !_InterlockedDecrement(&lock_12717) )
      return __readfsqword(0x28u) ^ v52;
    goto LABEL_11;
  }
  if ( --lock_12717 )
LABEL_11:
    _lll_unlock_wake_private((u32 *)&lock_12717, _RSI, a3, a4, a5, a6);
  return __readfsqword(0x28u) ^ v52;
}
// 443C47: variable 'a3' is possibly undefined
// 443C47: variable 'a4' is possibly undefined
// 443C47: variable 'a5' is possibly undefined
// 443C47: variable 'a6' is possibly undefined
// 443D11: variable 'v13' is possibly undefined
// 443D11: variable 'v14' is possibly undefined
// 443D11: variable 'v15' is possibly undefined
// 443DB7: variable 'v17' is possibly undefined
// 443DB7: variable 'v18' is possibly undefined
// 443DB7: variable 'v19' is possibly undefined
// 443DB7: variable 'v20' is possibly undefined
// 443EC2: variable 'v30' is possibly undefined
// 443EC2: variable 'v31' is possibly undefined
// 443EC2: variable 'v32' is possibly undefined
// 443EC2: variable 'v33' is possibly undefined
// 401058: using guessed type __int64 __fastcall j_stpcpy(_QWORD);
// 4010B0: using guessed type __int64 __fastcall j_mempcpy(_QWORD, _QWORD, _QWORD);
// 4010C8: using guessed type __int64 __fastcall j_strlen_ifunc(_QWORD);
// 4010D0: using guessed type __int64 __fastcall j_strchr_ifunc(_QWORD, _QWORD);
// 484490: using guessed type __int128 default_gconv_path;
// 4AAE84: using guessed type int lock_12717;
// 4AB820: using guessed type int _libc_multiple_threads;
// 4AB980: using guessed type __int64 _gconv_path_envvar;
// 4AB988: using guessed type __int64 _gconv_max_path_elem_len;
// 4AB990: using guessed type __int64 _gconv_path_elem;

//----- (0000000000443FE0) ----------------------------------------------------
unsigned __int64 __fastcall _gconv_read_conf(__int64 a1, __int64 a2)
{
  __int64 v2; // rdx
  __int64 v3; // rcx
  u32 *v4; // r8
  u32 v5; // er9
  __int64 *v6; // rax
  __int64 *v7; // rax
  void *v8; // rsp
  __int64 j; // rsi
  u32 *v10; // r8
  __int64 v11; // r9
  unsigned int *v12; // rax
  __int64 v13; // rdx
  char *v14; // rcx
  u32 *v15; // r8
  unsigned __int64 v16; // r9
  unsigned int *v17; // rbx
  unsigned int v18; // eax
  __int64 v19; // r14
  char *v20; // r13
  char *v21; // rax
  __int64 v22; // rax
  char *v23; // r14
  unsigned int v24; // eax
  __int64 v25; // rdx
  unsigned int *v26; // rcx
  u32 *v27; // r8
  unsigned __int64 v28; // r9
  __int64 v29; // rdi
  __int64 *v30; // r14
  __int64 v31; // r13
  char **v32; // r12
  __int64 v33; // rdi
  const char *v34; // r12
  __int64 v35; // rbx
  __int64 v36; // r13
  __int64 v37; // rcx
  u32 *v38; // r8
  __int64 v39; // r9
  int v41; // ecx
  char *v42; // rdx
  __int64 i; // rax
  __int64 v44; // rax
  __int64 v45; // r13
  __int64 v46; // [rsp+0h] [rbp-10A8h]
  __int64 v47; // [rsp+8h] [rbp-10A0h] BYREF
  char v48[7]; // [rsp+10h] [rbp-1098h] BYREF
  _BYTE v49[12]; // [rsp+1008h] [rbp-A0h] BYREF
  unsigned int v50; // [rsp+1014h] [rbp-94h]
  __int64 v51; // [rsp+1018h] [rbp-90h]
  __int64 v52; // [rsp+1020h] [rbp-88h]
  __int64 v53; // [rsp+1028h] [rbp-80h]
  __int64 *v54; // [rsp+1030h] [rbp-78h]
  __int64 *v55; // [rsp+1038h] [rbp-70h]
  __int64 v56; // [rsp+1040h] [rbp-68h]
  char *v57; // [rsp+1050h] [rbp-58h] BYREF
  __int64 v58[3]; // [rsp+1058h] [rbp-50h] BYREF
  unsigned __int64 v59; // [rsp+1070h] [rbp-38h]

  v59 = __readfsqword(0x28u);
  v50 = __readfsdword(0xFFFFFFC0);
  if ( (unsigned int)_gconv_load_cache() )
  {
    v6 = (__int64 *)_gconv_path_elem;
    if ( !_gconv_path_elem )
    {
      _gconv_get_path(a1, a2, v2, v3, v4, v5);
      v6 = (__int64 *)_gconv_path_elem;
    }
    v53 = *v6;
    if ( v53 )
    {
      v56 = 16LL;
      v55 = v58;
      v54 = (__int64 *)&v57;
      do
      {
        v52 = v6[1];
        v7 = (__int64 *)&v49[-((v52 + 37) & 0xFFFFFFFFFFFFF000LL)];
        if ( v49 != (_BYTE *)v7 )
        {
          while ( &v47 != v7 )
            ;
        }
        if ( (((_WORD)v52 + 37) & 0xFF0) != 0 )
        {
          v8 = alloca(((_WORD)v52 + 37) & 0xFF0);
          *(__int64 *)((char *)&v46 + (((_WORD)v52 + 37) & 0xFF0)) = *(__int64 *)((char *)&v46
                                                                                + (((_WORD)v52 + 37) & 0xFF0));
        }
        j = (__int64)"rce";
        strcpy((char *)j_mempcpy(v48, v53, v52), "gconv-modules");
        v12 = (unsigned int *)fopen64(v48, "rce", *(__int64 *)"gconv-modules", *(unsigned __int16 *)"s", v10, v11);
        v57 = 0LL;
        v17 = v12;
        v58[0] = 0LL;
        if ( v12 )
        {
          v18 = *v12;
          BYTE1(v18) |= 0x80u;
          *v17 = v18;
          if ( (v18 & 0x10) == 0 )
          {
            do
            {
              j = (__int64)v55;
              v19 = getdelim(v54, (__int64)v55, 10LL, v17, v15, v16);
              if ( v19 < 0 )
                break;
              v20 = v57;
              j = 35LL;
              v21 = (char *)j_strchr_ifunc(v57, 35LL);
              if ( v21 )
              {
                *v21 = 0;
              }
              else
              {
                v42 = &v20[v19 - 1];
                if ( *v42 == 10 )
                  *v42 = 0;
              }
              while ( 1 )
              {
                v13 = *v20;
                if ( (word_486FE0[v13] & 0x2000) == 0 )
                  break;
                ++v20;
              }
              if ( v21 != v20 )
              {
                v22 = *v20;
                if ( (_BYTE)v22 )
                {
                  if ( (word_486FE0[v22] & 0x2000) == 0 )
                  {
                    v23 = v20;
                    do
                      v13 = (unsigned __int8)*++v23;
                    while ( (_BYTE)v13 && (word_486FE0[(char)v13] & 0x2000) == 0 );
                    if ( v23 - v20 == 5 )
                    {
                      if ( *(_DWORD *)v20 == 1634298977 && v20[4] == 115 )
                      {
                        for ( i = (char)v13; (word_486FE0[i] & 0x2000) != 0; v13 = i )
                          i = *++v23;
                        j = (__int64)v23;
                        if ( (_BYTE)v13 )
                        {
                          while ( 1 )
                          {
                            v13 = j + 1;
                            *(_BYTE *)j = dword_4866E0[i];
                            i = *(char *)(j + 1);
                            if ( !(_BYTE)i )
                              break;
                            if ( (word_486FE0[i] & 0x2000) != 0 )
                            {
                              v44 = *(char *)(j + 2);
                              v45 = j + 2;
                              *(_BYTE *)v13 = 0;
                              v14 = (char *)(j + 2);
                              for ( j = v44; (word_486FE0[v44] & 0x2000) != 0; j = v44 )
                                v44 = *++v14;
                              v13 = v45;
                              if ( (_BYTE)j )
                              {
                                while ( 1 )
                                {
                                  ++v14;
                                  j = v13 + 1;
                                  *(_BYTE *)v13 = dword_4866E0[v44];
                                  v44 = *v14;
                                  if ( !(_BYTE)v44 || (word_486FE0[v44] & 0x2000) != 0 )
                                    break;
                                  ++v13;
                                }
                                v51 = v13;
                                if ( v45 != j )
                                {
                                  *(_BYTE *)j = 0;
                                  if ( !(unsigned int)detect_conflict((__int64)v23) )
                                  {
                                    j = v45;
                                    add_alias2_isra_1_part_2((__int64)v23, v45, v51 + 2, (__int64)v14, v15, v16);
                                    v24 = *v17;
                                    goto LABEL_27;
                                  }
                                }
                              }
                              break;
                            }
                            ++j;
                          }
                        }
                      }
                    }
                    else if ( v23 - v20 == 6 && *(_DWORD *)v20 == 1969516397 && *((_WORD *)v20 + 2) == 25964 )
                    {
                      v41 = modcounter_12697;
                      j = v53;
                      ++modcounter_12697;
                      add_module_isra_0(v23, v53, v52, v41);
                      v24 = *v17;
                      continue;
                    }
                  }
                }
              }
              v24 = *v17;
LABEL_27:
              ;
            }
            while ( (v24 & 0x10) == 0 );
          }
          free((__int64)v57, j, v13, (__int64)v14, v15, v16);
          fclose((__int64)v17, j, v25, v26, v27, v28);
        }
        v6 = (__int64 *)(v56 + _gconv_path_elem);
        v29 = *(_QWORD *)(v56 + _gconv_path_elem);
        v56 += 16LL;
        v53 = v29;
      }
      while ( v29 );
    }
    else
    {
      v55 = v58;
    }
    v30 = (__int64 *)builtin_modules;
    v31 = (__int64)v55;
    v32 = &builtin_modules[84];
    do
    {
      while ( 1 )
      {
        v58[0] = *v30;
        if ( !tfind(v31, &_gconv_alias_db, (__int64 (__fastcall *)(__int64, _QWORD))_gconv_alias_compare) )
          break;
        v30 += 7;
        if ( v32 == (char **)v30 )
          goto LABEL_34;
      }
      v33 = (__int64)v30;
      v30 += 7;
      insert_module(v33, 0);
    }
    while ( v32 != (char **)v30 );
LABEL_34:
    v34 = "UCS4//";
    do
    {
      v35 = j_rawmemchr(v34, 0LL) + 1;
      v36 = j_rawmemchr(v35, 0LL);
      if ( !(unsigned int)detect_conflict((__int64)v34) )
        add_alias2_isra_1_part_2((__int64)v34, v35, v36 + 1, v37, v38, v39);
      v34 = (const char *)(v36 + 1);
    }
    while ( *(_BYTE *)(v36 + 1) );
  }
  __writefsdword(0xFFFFFFC0, v50);
  return __readfsqword(0x28u) ^ v59;
}
// 444498: variable 'v2' is possibly undefined
// 444498: variable 'v3' is possibly undefined
// 444498: variable 'v4' is possibly undefined
// 444498: variable 'v5' is possibly undefined
// 444107: variable 'v10' is possibly undefined
// 444107: variable 'v11' is possibly undefined
// 444150: variable 'v15' is possibly undefined
// 444150: variable 'v16' is possibly undefined
// 4441FE: variable 'v13' is possibly undefined
// 4441FE: variable 'v14' is possibly undefined
// 444206: variable 'v25' is possibly undefined
// 444206: variable 'v26' is possibly undefined
// 444206: variable 'v27' is possibly undefined
// 444206: variable 'v28' is possibly undefined
// 4442CC: variable 'v37' is possibly undefined
// 4442CC: variable 'v38' is possibly undefined
// 4442CC: variable 'v39' is possibly undefined
// 401038: using guessed type __int64 __fastcall j_rawmemchr(_QWORD, _QWORD);
// 4010B0: using guessed type __int64 __fastcall j_mempcpy(_QWORD, _QWORD, _QWORD);
// 4010D0: using guessed type __int64 __fastcall j_strchr_ifunc(_QWORD, _QWORD);
// 4866E0: using guessed type unsigned int dword_4866E0[256];
// 486FE0: using guessed type _WORD word_486FE0[256];
// 4A97C0: using guessed type char *builtin_modules[2];
// 4AAE80: using guessed type int modcounter_12697;
// 4AB978: using guessed type __int64 _gconv_alias_db;
// 4AB990: using guessed type __int64 _gconv_path_elem;

//----- (00000000004444C0) ----------------------------------------------------
__int64 __fastcall _gconv_get_builtin_trans(__int64 a1, __int64 a2)
{
  const char *v3; // rsi
  const char **v4; // rbp
  __int64 v5; // rbx
  char **v6; // rbx
  char *v7; // rax
  char *v8; // rax
  __int64 result; // rax

  v3 = "=INTERNAL->ucs4";
  v4 = (const char **)&off_4A7B00;
  v5 = 0LL;
  while ( (unsigned int)j_strcmp_ifunc(a1, v3) )
  {
    if ( ++v5 == 12 )
      _assert_fail(
        (__int64)"cnt < sizeof (map) / sizeof (map[0])",
        (__int64)"gconv_builtin.c",
        0x46u,
        "__gconv_get_builtin_trans");
    v3 = *v4;
    v4 += 4;
  }
  *(_QWORD *)(a2 + 56) = 0LL;
  v6 = &(&map_0)[4 * v5];
  *(_QWORD *)(a2 + 64) = 0LL;
  v7 = v6[1];
  *(_QWORD *)a2 = 0LL;
  *(_QWORD *)(a2 + 8) = 0LL;
  *(_QWORD *)(a2 + 40) = v7;
  v8 = v6[2];
  *(_DWORD *)(a2 + 88) = 0;
  *(_QWORD *)(a2 + 48) = v8;
  *(_DWORD *)(a2 + 72) = *((char *)v6 + 24);
  *(_DWORD *)(a2 + 76) = *((char *)v6 + 25);
  *(_DWORD *)(a2 + 80) = *((char *)v6 + 26);
  result = (unsigned int)*((char *)v6 + 27);
  *(_DWORD *)(a2 + 84) = result;
  return result;
}
// 4010A0: using guessed type __int64 __fastcall j_strcmp_ifunc(_QWORD, _QWORD);
// 4A7AE0: using guessed type char *map_0;
// 4A7B00: using guessed type char *off_4A7B00;

//----- (00000000004445B0) ----------------------------------------------------
__int64 __fastcall _gconv_btwoc_ascii(__int64 a1, char a2)
{
  __int64 result; // rax

  result = (unsigned __int8)a2;
  if ( a2 < 0 )
    return 0xFFFFFFFFLL;
  return result;
}

//----- (00000000004445D0) ----------------------------------------------------
__int64 __fastcall _gconv_transform_internal_ucs4(
        __int64 a1,
        unsigned __int64 *a2,
        unsigned __int64 *a3,
        unsigned __int64 a4,
        unsigned __int64 *a5,
        __int64 a6,
        unsigned int a7,
        unsigned int a8)
{
  unsigned int (__fastcall *v9)(__int64, unsigned __int64 *, __int64 *, unsigned __int64, _QWORD, __int64, _QWORD, _QWORD); // r15
  unsigned __int64 *v13; // rax
  unsigned __int64 v14; // r11
  unsigned __int64 v15; // rsi
  unsigned __int64 v16; // rcx
  int v17; // er8
  unsigned __int64 v18; // rdx
  unsigned __int64 v19; // rax
  unsigned __int64 v20; // r10
  unsigned __int64 v21; // r14
  unsigned __int64 v22; // rcx
  signed __int64 v23; // rax
  __int64 v24; // rbx
  __int64 v25; // rax
  __int64 v26; // rbx
  unsigned __int64 v27; // rbx
  unsigned int v28; // er12
  unsigned int v29; // eax
  unsigned __int64 v30; // r14
  unsigned __int64 v32; // rdx
  unsigned int *v33; // rcx
  unsigned __int64 v34; // rax
  _DWORD *v35; // rsi
  int v36; // eax
  unsigned __int64 v37; // [rsp+0h] [rbp-78h]
  unsigned __int64 *v38; // [rsp+8h] [rbp-70h]
  __int64 v39; // [rsp+10h] [rbp-68h]
  unsigned __int64 *v40; // [rsp+18h] [rbp-60h]
  __int64 v42[9]; // [rsp+30h] [rbp-48h] BYREF

  v9 = 0LL;
  v42[1] = __readfsqword(0x28u);
  v39 = a1 + 104;
  v40 = a2 + 6;
  if ( (a2[2] & 1) == 0 )
  {
    v9 = *(unsigned int (__fastcall **)(__int64, unsigned __int64 *, __int64 *, unsigned __int64, _QWORD, __int64, _QWORD, _QWORD))(a1 + 144);
    if ( *(_QWORD *)(a1 + 104) )
      v9 = (unsigned int (__fastcall *)(__int64, unsigned __int64 *, __int64 *, unsigned __int64, _QWORD, __int64, _QWORD, _QWORD))(__readfsqword(0x30u) ^ __ROR8__(v9, 17));
  }
  if ( a7 )
  {
    if ( a5 )
      _assert_fail(
        (__int64)"outbufstart == NULL",
        (__int64)"../iconv/skeleton.c",
        0x19Fu,
        "__gconv_transform_internal_ucs4");
    v28 = 0;
    *(_QWORD *)a2[4] = 0LL;
    if ( (a2[2] & 1) == 0 )
    {
      dl_mcount_wrapper_check((__int64)v9);
      return v9(v39, v40, 0LL, 0LL, 0LL, a6, a7, a8);
    }
    return v28;
  }
  v13 = a5;
  v14 = a2[1];
  if ( !a5 )
    v13 = a2;
  v15 = *v13;
  if ( !a8 )
    goto LABEL_17;
  v16 = a2[4];
  v17 = *(_DWORD *)v16;
  LODWORD(v18) = *(_DWORD *)v16 & 7;
  if ( !(_DWORD)v18 )
    goto LABEL_17;
  if ( a5 )
    _assert_fail(
      (__int64)"outbufstart == NULL",
      (__int64)"../iconv/skeleton.c",
      0x22Fu,
      "__gconv_transform_internal_ucs4");
  v19 = *a3;
  v18 = (int)v18;
  if ( *a3 >= a4 )
    goto LABEL_15;
  if ( (v17 & 4) == 0 )
  {
    while ( 1 )
    {
      ++v19;
      ++v18;
      *a3 = v19;
      *(_BYTE *)(v16 + v18 + 3) = *(_BYTE *)(v19 - 1);
      if ( a4 == v19 )
        break;
      if ( v18 == 4 )
        goto LABEL_16;
    }
LABEL_15:
    if ( v18 <= 3 )
    {
      v28 = 7;
      *(_DWORD *)v16 = v17 & 0xFFFFFFF8 | v18;
      return v28;
    }
  }
LABEL_16:
  v15 += 4LL;
  *(_BYTE *)(v15 - 4) = *(_BYTE *)(v16 + 7);
  *(_BYTE *)(v15 - 3) = *(_BYTE *)(v16 + 6);
  *(_BYTE *)(v15 - 2) = *(_BYTE *)(v16 + 5);
  *(_BYTE *)(v15 - 1) = *(_BYTE *)(v16 + 4);
  *(_DWORD *)v16 &= 0xFFFFFFF8;
LABEL_17:
  v38 = a5;
  v20 = a4;
  v21 = v14;
  while ( 1 )
  {
    v22 = *a3;
    v23 = v20 - *a3;
    if ( (__int64)(v21 - v15) <= v23 )
      v23 = v21 - v15;
    v24 = v23 / 4;
    if ( v23 / 4 )
    {
      v25 = 0LL;
      do
      {
        *(_DWORD *)(v15 + 4 * v25) = _byteswap_ulong(*(_DWORD *)(v22 + 4 * v25));
        ++v25;
      }
      while ( v24 != v25 );
      v26 = 4 * v24;
      v22 += v26;
      v27 = v15 + v26;
    }
    else
    {
      v27 = v15;
    }
    *a3 = v22;
    v28 = 4;
    if ( v22 != v20 )
      v28 = v21 < v27 + 4 ? 5 : 7;
    if ( v38 )
    {
      *v38 = v27;
      return v28;
    }
    ++*((_DWORD *)a2 + 5);
    if ( (a2[2] & 1) != 0 )
    {
      v30 = v20;
      *a2 = v27;
      goto LABEL_36;
    }
    if ( v27 <= v15 )
      goto LABEL_35;
    v37 = v20;
    v42[0] = *a2;
    dl_mcount_wrapper_check((__int64)v9);
    v29 = v9(v39, v40, v42, v27, 0LL, a6, 0LL, a8);
    v20 = v37;
    if ( v29 != 4 )
      break;
    if ( v28 != 5 )
    {
LABEL_35:
      v30 = v20;
      goto LABEL_36;
    }
LABEL_33:
    v15 = *a2;
  }
  if ( v27 != v42[0] )
    *a3 -= v27 - v42[0];
  if ( !v29 )
    goto LABEL_33;
  v30 = v37;
  v28 = v29;
LABEL_36:
  if ( a8 && v28 == 7 )
  {
    v32 = *a3;
    if ( (__int64)(v30 - *a3) > 3 )
      _assert_fail(
        (__int64)"inend - *inptrp < 4",
        (__int64)"../iconv/skeleton.c",
        0x309u,
        "__gconv_transform_internal_ucs4");
    v33 = (unsigned int *)a2[4];
    v34 = *a3;
    v35 = v33 + 1;
    if ( v32 >= v30 )
    {
      v36 = 0;
    }
    else
    {
      do
      {
        ++v34;
        v35 = (_DWORD *)((char *)v35 + 1);
        *a3 = v34;
        *((_BYTE *)v35 - 1) = *(_BYTE *)(v34 - 1);
      }
      while ( v34 != v30 );
      v36 = v34 - v32;
    }
    v28 = 7;
    *v33 = *v33 & 0xFFFFFFF8 | v36;
  }
  return v28;
}

//----- (0000000000444980) ----------------------------------------------------
__int64 __fastcall _gconv_transform_ucs4_internal(
        __int64 a1,
        __int64 a2,
        unsigned int **a3,
        unsigned int *a4,
        int **a5,
        _QWORD *a6,
        unsigned int a7,
        unsigned int a8)
{
  __int64 (__fastcall *v10)(__int64, __int64, __int64 *, int *, _QWORD, _QWORD *, _QWORD, _QWORD); // r14
  int v13; // eax
  int **v14; // rdx
  __int64 *v15; // r11
  int *v16; // rdx
  unsigned int *v17; // rdi
  unsigned int v18; // er8
  int v19; // er9
  unsigned int *v20; // rcx
  unsigned __int64 v21; // rsi
  unsigned int *v22; // rbx
  unsigned int **v23; // r15
  __int64 (__fastcall *v24)(__int64, __int64, __int64 *, int *, _QWORD, _QWORD *, _QWORD, _QWORD); // r13
  __int64 *v25; // r14
  unsigned int *v26; // r11
  unsigned int *v27; // rsi
  int *v28; // rbx
  signed __int64 v29; // rcx
  __int64 v30; // r8
  __int64 v31; // rdi
  int v32; // eax
  int v33; // ecx
  unsigned int v34; // er12
  unsigned int v36; // eax
  unsigned int **v37; // r13
  unsigned int *v38; // r15
  unsigned int *v39; // rdx
  unsigned int *v40; // rcx
  unsigned int *v41; // rax
  _BYTE *v42; // rsi
  int v43; // er15
  unsigned __int64 v44; // [rsp+8h] [rbp-90h]
  unsigned int *v45; // [rsp+10h] [rbp-88h]
  int **v46; // [rsp+18h] [rbp-80h]
  __int64 v48; // [rsp+28h] [rbp-70h]
  __int64 v49; // [rsp+30h] [rbp-68h]
  __int64 v50; // [rsp+48h] [rbp-50h] BYREF
  __int64 v51[9]; // [rsp+50h] [rbp-48h] BYREF

  v10 = 0LL;
  v51[1] = __readfsqword(0x28u);
  v48 = a1 + 104;
  v49 = a2 + 48;
  v13 = *(_DWORD *)(a2 + 16);
  if ( (v13 & 1) == 0 )
  {
    v10 = *(__int64 (__fastcall **)(__int64, __int64, __int64 *, int *, _QWORD, _QWORD *, _QWORD, _QWORD))(a1 + 144);
    if ( *(_QWORD *)(a1 + 104) )
      v10 = (__int64 (__fastcall *)(__int64, __int64, __int64 *, int *, _QWORD, _QWORD *, _QWORD, _QWORD))(__readfsqword(0x30u) ^ __ROR8__(v10, 17));
  }
  if ( a7 )
  {
    if ( a5 )
      _assert_fail(
        (__int64)"outbufstart == NULL",
        (__int64)"../iconv/skeleton.c",
        0x19Fu,
        "__gconv_transform_ucs4_internal");
    v34 = 0;
    **(_QWORD **)(a2 + 32) = 0LL;
    if ( (*(_BYTE *)(a2 + 16) & 1) == 0 )
    {
      dl_mcount_wrapper_check((__int64)v10);
      return (unsigned int)v10(v48, v49, 0LL, 0LL, 0LL, a6, a7, a8);
    }
    return v34;
  }
  v14 = a5;
  v15 = &v50;
  if ( !a5 )
    v14 = (int **)a2;
  if ( !a6 )
    v15 = 0LL;
  v16 = *v14;
  v44 = *(_QWORD *)(a2 + 8);
  v50 = 0LL;
  if ( !a8 )
    goto LABEL_22;
  v17 = *(unsigned int **)(a2 + 32);
  v18 = *v17;
  v19 = *v17 & 7;
  if ( !v19 )
    goto LABEL_22;
  if ( a5 )
    _assert_fail(
      (__int64)"outbufstart == NULL",
      (__int64)"../iconv/skeleton.c",
      0x22Fu,
      "__gconv_transform_ucs4_internal");
  v20 = *a3;
  v21 = v19;
  if ( *a3 >= a4 )
    goto LABEL_18;
  if ( (v18 & 4) == 0 )
  {
    while ( 1 )
    {
      v20 = (unsigned int *)((char *)v20 + 1);
      ++v21;
      *a3 = v20;
      *((_BYTE *)v17 + v21 + 3) = *((_BYTE *)v20 - 1);
      if ( a4 == v20 )
        break;
      if ( v21 == 4 )
        goto LABEL_19;
    }
    v20 = a4;
LABEL_18:
    if ( v21 <= 3 )
    {
      v34 = 7;
      *v17 = v18 & 0xFFFFFFF8 | v21;
      return v34;
    }
  }
LABEL_19:
  if ( *((_BYTE *)v17 + 4) > 0x80u )
  {
    if ( (v13 & 2) == 0 )
    {
      v34 = 6;
      *a3 = (unsigned int *)((char *)v20 + v19 - v21);
      return v34;
    }
  }
  else
  {
    *((_BYTE *)++v16 - 4) = *((_BYTE *)v17 + 7);
    *((_BYTE *)v16 - 3) = *((_BYTE *)v17 + 6);
    *((_BYTE *)v16 - 2) = *((_BYTE *)v17 + 5);
    *((_BYTE *)v16 - 1) = *((_BYTE *)v17 + 4);
    v18 = *v17;
  }
  v13 = *(_DWORD *)(a2 + 16);
  *v17 = v18 & 0xFFFFFFF8;
LABEL_22:
  v46 = a5;
  v22 = a4;
  v23 = a3;
  v24 = v10;
  v25 = v15;
  v26 = v22;
  while ( 1 )
  {
    v27 = *v23;
    v28 = v16;
    v29 = v44 - (_QWORD)v16;
    if ( (__int64)(v44 - (_QWORD)v16) > (char *)v26 - (char *)*v23 )
      v29 = (char *)v26 - (char *)*v23;
    v30 = v29 / 4;
    if ( v29 / 4 )
    {
      v31 = 0LL;
      v32 = v13 & 2;
      while ( 1 )
      {
        while ( 1 )
        {
          v33 = _byteswap_ulong(*v27);
          if ( v33 < 0 )
            break;
          ++v31;
          *v28 = v33;
          ++v27;
          ++v28;
          if ( v30 == v31 )
            goto LABEL_32;
        }
        if ( !v25 )
          break;
        if ( !v32 )
        {
          *v23 = v27;
          v34 = 6;
          goto LABEL_37;
        }
        ++v31;
        ++*v25;
        ++v27;
        if ( v30 == v31 )
          goto LABEL_32;
      }
      v28 = v16;
      v34 = 6;
    }
    else
    {
LABEL_32:
      *v23 = v27;
      v34 = 4;
      if ( v27 != v26 )
      {
        v34 = v44 < (unsigned __int64)(v28 + 1) ? 5 : 7;
        if ( v46 )
          goto LABEL_34;
        goto LABEL_38;
      }
    }
LABEL_37:
    if ( v46 )
    {
LABEL_34:
      *v46 = v28;
      return v34;
    }
LABEL_38:
    ++*(_DWORD *)(a2 + 20);
    if ( (*(_BYTE *)(a2 + 16) & 1) != 0 )
    {
      v37 = v23;
      *(_QWORD *)a2 = v28;
      v38 = v26;
      *a6 += v50;
      goto LABEL_47;
    }
    if ( v16 >= v28 )
      goto LABEL_46;
    v45 = v26;
    v51[0] = *(_QWORD *)a2;
    dl_mcount_wrapper_check((__int64)v24);
    v36 = v24(v48, v49, v51, v28, 0LL, a6, 0LL, a8);
    v26 = v45;
    if ( v36 != 4 )
      break;
    if ( v34 != 5 )
    {
LABEL_46:
      v37 = v23;
      v38 = v26;
      goto LABEL_47;
    }
LABEL_44:
    v13 = *(_DWORD *)(a2 + 16);
    v16 = *(int **)a2;
  }
  if ( (int *)v51[0] != v28 )
    *v23 = (unsigned int *)((char *)*v23 - ((unsigned __int64)v28 - v51[0]));
  if ( !v36 )
    goto LABEL_44;
  v37 = v23;
  v34 = v36;
  v38 = v45;
LABEL_47:
  if ( a8 && v34 == 7 )
  {
    v39 = *v37;
    if ( (char *)v38 - (char *)*v37 > 3 )
      _assert_fail(
        (__int64)"inend - *inptrp < 4",
        (__int64)"../iconv/skeleton.c",
        0x309u,
        "__gconv_transform_ucs4_internal");
    v40 = *(unsigned int **)(a2 + 32);
    v41 = (unsigned int *)((char *)v39 + 1);
    v42 = v40 + 1;
    if ( v39 >= v38 )
    {
      v43 = 0;
    }
    else
    {
      while ( 1 )
      {
        *v37 = v41;
        *v42++ = *((_BYTE *)v41 - 1);
        if ( v38 == v41 )
          break;
        v41 = (unsigned int *)((char *)v41 + 1);
      }
      v43 = (_DWORD)v38 - (_DWORD)v39;
    }
    *v40 = *v40 & 0xFFFFFFF8 | v43;
  }
  return v34;
}

//----- (0000000000444E10) ----------------------------------------------------
__int64 __fastcall _gconv_transform_internal_ucs4le(
        __int64 a1,
        __int64 a2,
        unsigned __int64 *a3,
        unsigned __int64 a4,
        unsigned __int64 *a5,
        __int64 a6,
        unsigned int a7,
        unsigned int a8)
{
  unsigned __int64 *v12; // rax
  unsigned __int64 v13; // rcx
  unsigned __int64 *v14; // r13
  unsigned __int64 i; // r14
  unsigned __int64 v16; // rsi
  unsigned int v17; // ebp
  __int64 v18; // rax
  __int64 v19; // rdx
  unsigned __int64 v20; // rdx
  unsigned __int64 v21; // rax
  unsigned __int64 v22; // r15
  unsigned int v23; // eax
  unsigned __int64 *v24; // r15
  int *v26; // rsi
  int v27; // er8
  unsigned __int64 v28; // rdx
  unsigned __int64 v29; // rax
  unsigned __int64 v30; // rsi
  unsigned int *v31; // rdi
  unsigned __int64 v32; // rax
  _DWORD *v33; // rdx
  int v34; // eax
  unsigned __int64 v35; // [rsp+8h] [rbp-80h]
  unsigned __int64 *v36; // [rsp+10h] [rbp-78h]
  unsigned int (__fastcall *v37)(__int64, __int64, __int64 *, unsigned __int64, _QWORD, __int64, _QWORD, _QWORD); // [rsp+18h] [rbp-70h]
  __int64 v38; // [rsp+20h] [rbp-68h]
  __int64 v39; // [rsp+28h] [rbp-60h]
  __int64 v41[9]; // [rsp+40h] [rbp-48h] BYREF

  v41[1] = __readfsqword(0x28u);
  v37 = 0LL;
  v38 = a1 + 104;
  v39 = a2 + 48;
  if ( (*(_BYTE *)(a2 + 16) & 1) == 0 )
  {
    v37 = *(unsigned int (__fastcall **)(__int64, __int64, __int64 *, unsigned __int64, _QWORD, __int64, _QWORD, _QWORD))(a1 + 144);
    if ( *(_QWORD *)(a1 + 104) )
      v37 = (unsigned int (__fastcall *)(__int64, __int64, __int64 *, unsigned __int64, _QWORD, __int64, _QWORD, _QWORD))(__readfsqword(0x30u) ^ __ROR8__(*(_QWORD *)(a1 + 144), 17));
  }
  if ( a7 )
  {
    if ( a5 )
      _assert_fail(
        (__int64)"outbufstart == NULL",
        (__int64)"../iconv/skeleton.c",
        0x19Fu,
        "__gconv_transform_internal_ucs4le");
    v17 = 0;
    **(_QWORD **)(a2 + 32) = 0LL;
    if ( (*(_BYTE *)(a2 + 16) & 1) == 0 )
    {
      dl_mcount_wrapper_check((__int64)v37);
      return v37(v38, v39, 0LL, 0LL, 0LL, a6, a7, a8);
    }
    return v17;
  }
  v12 = a5;
  if ( !a5 )
    v12 = (unsigned __int64 *)a2;
  v13 = *v12;
  v35 = *(_QWORD *)(a2 + 8);
  if ( !a8 )
    goto LABEL_8;
  v26 = *(int **)(a2 + 32);
  v27 = *v26;
  LODWORD(v28) = *v26 & 7;
  if ( !(_DWORD)v28 )
    goto LABEL_8;
  if ( a5 )
    _assert_fail(
      (__int64)"outbufstart == NULL",
      (__int64)"../iconv/skeleton.c",
      0x22Fu,
      "__gconv_transform_internal_ucs4le");
  v29 = *a3;
  v28 = (int)v28;
  if ( a4 <= *a3 )
    goto LABEL_35;
  if ( (v27 & 4) == 0 )
  {
    while ( 1 )
    {
      ++v29;
      ++v28;
      *a3 = v29;
      *((_BYTE *)v26 + v28 + 3) = *(_BYTE *)(v29 - 1);
      if ( a4 == v29 )
        break;
      if ( v28 == 4 )
        goto LABEL_36;
    }
LABEL_35:
    if ( v28 <= 3 )
    {
      v17 = 7;
      *v26 = v27 & 0xFFFFFFF8 | v28;
      return v17;
    }
  }
LABEL_36:
  v13 += 4LL;
  *(_BYTE *)(v13 - 4) = *((_BYTE *)v26 + 4);
  *(_BYTE *)(v13 - 3) = *((_BYTE *)v26 + 5);
  *(_BYTE *)(v13 - 2) = *((_BYTE *)v26 + 6);
  *(_BYTE *)(v13 - 1) = *((_BYTE *)v26 + 7);
  *v26 &= 0xFFFFFFF8;
LABEL_8:
  v36 = a5;
  v14 = a3;
  for ( i = v13; ; i = *(_QWORD *)a2 )
  {
    v16 = *v14;
    v17 = 4;
    v18 = a4 - *v14;
    if ( (__int64)(v35 - i) <= v18 )
      v18 = v35 - i;
    v19 = v18 + 3;
    if ( v18 >= 0 )
      v19 = v18;
    v20 = v19 & 0xFFFFFFFFFFFFFFFCLL;
    *v14 = v16 + v20;
    v21 = j_mempcpy(i, v16, v20);
    v22 = v21;
    if ( a4 != *v14 )
      v17 = v35 < v21 + 4 ? 5 : 7;
    if ( v36 )
    {
      *v36 = v21;
      return v17;
    }
    ++*(_DWORD *)(a2 + 20);
    if ( (*(_BYTE *)(a2 + 16) & 1) != 0 )
    {
      v24 = v14;
      *(_QWORD *)a2 = v21;
      goto LABEL_25;
    }
    if ( v21 <= i )
      goto LABEL_24;
    v41[0] = *(_QWORD *)a2;
    dl_mcount_wrapper_check((__int64)v37);
    v23 = v37(v38, v39, v41, v22, 0LL, a6, 0LL, a8);
    if ( v23 != 4 )
      break;
    if ( v17 != 5 )
    {
LABEL_24:
      v24 = v14;
      goto LABEL_25;
    }
LABEL_22:
    ;
  }
  if ( v41[0] != v22 )
    *v14 -= v22 - v41[0];
  if ( !v23 )
    goto LABEL_22;
  v24 = v14;
  v17 = v23;
LABEL_25:
  if ( v17 == 7 && a8 )
  {
    v30 = *v24;
    if ( (__int64)(a4 - *v24) > 3 )
      _assert_fail(
        (__int64)"inend - *inptrp < 4",
        (__int64)"../iconv/skeleton.c",
        0x309u,
        "__gconv_transform_internal_ucs4le");
    v31 = *(unsigned int **)(a2 + 32);
    v32 = *v24;
    v33 = v31 + 1;
    if ( v30 >= a4 )
    {
      v34 = 0;
    }
    else
    {
      do
      {
        ++v32;
        v33 = (_DWORD *)((char *)v33 + 1);
        *v24 = v32;
        *((_BYTE *)v33 - 1) = *(_BYTE *)(v32 - 1);
      }
      while ( v32 != a4 );
      v34 = v32 - v30;
    }
    v17 = 7;
    *v31 = *v31 & 0xFFFFFFF8 | v34;
  }
  return v17;
}
// 4010B0: using guessed type __int64 __fastcall j_mempcpy(_QWORD, _QWORD, _QWORD);

//----- (0000000000445200) ----------------------------------------------------
__int64 __fastcall _gconv_transform_ucs4le_internal(
        __int64 a1,
        __int64 a2,
        unsigned __int64 *a3,
        unsigned __int64 a4,
        _QWORD *a5,
        _QWORD *a6,
        unsigned int a7,
        unsigned int a8)
{
  __int64 (__fastcall *v8)(__int64, __int64, __int64 *, _DWORD *, _QWORD, _QWORD *, _QWORD, _QWORD); // r14
  int v12; // ecx
  _QWORD *v13; // rax
  __int64 *v14; // r11
  _DWORD *v15; // rdi
  unsigned __int64 v16; // rax
  unsigned int *v17; // rsi
  unsigned int v18; // er9
  unsigned __int64 v19; // rdx
  unsigned __int64 v20; // rax
  __int64 (__fastcall *v21)(__int64, __int64, __int64 *, _DWORD *, _QWORD, _QWORD *, _QWORD, _QWORD); // r15
  __int64 *v22; // r14
  int *v23; // rax
  _DWORD *v24; // rbx
  signed __int64 v25; // rdx
  __int64 v26; // r8
  __int64 v27; // rdx
  int v28; // ecx
  unsigned int v29; // er10
  unsigned int v31; // eax
  unsigned __int64 v32; // rdx
  unsigned int *v33; // rcx
  unsigned __int64 v34; // rax
  _DWORD *v35; // rsi
  int v36; // eax
  __int64 v37; // rax
  unsigned int v38; // [rsp+Ch] [rbp-8Ch]
  unsigned __int64 v39; // [rsp+10h] [rbp-88h]
  __int64 v42; // [rsp+28h] [rbp-70h]
  __int64 v43; // [rsp+30h] [rbp-68h]
  __int64 v44; // [rsp+48h] [rbp-50h] BYREF
  __int64 v45[9]; // [rsp+50h] [rbp-48h] BYREF

  v8 = 0LL;
  v12 = *(_DWORD *)(a2 + 16);
  v45[1] = __readfsqword(0x28u);
  v42 = a1 + 104;
  v43 = a2 + 48;
  if ( (v12 & 1) == 0 )
  {
    v8 = *(__int64 (__fastcall **)(__int64, __int64, __int64 *, _DWORD *, _QWORD, _QWORD *, _QWORD, _QWORD))(a1 + 144);
    if ( *(_QWORD *)(a1 + 104) )
      v8 = (__int64 (__fastcall *)(__int64, __int64, __int64 *, _DWORD *, _QWORD, _QWORD *, _QWORD, _QWORD))(__readfsqword(0x30u) ^ __ROR8__(v8, 17));
  }
  if ( a7 )
  {
    if ( a5 )
      _assert_fail(
        (__int64)"outbufstart == NULL",
        (__int64)"../iconv/skeleton.c",
        0x19Fu,
        "__gconv_transform_ucs4le_internal");
    v29 = 0;
    **(_QWORD **)(a2 + 32) = 0LL;
    if ( (*(_BYTE *)(a2 + 16) & 1) == 0 )
    {
      dl_mcount_wrapper_check((__int64)v8);
      return (unsigned int)v8(v42, v43, 0LL, 0LL, 0LL, a6, a7, a8);
    }
    return v29;
  }
  v13 = a5;
  v14 = &v44;
  if ( !a5 )
    v13 = (_QWORD *)a2;
  v15 = (_DWORD *)*v13;
  v16 = *(_QWORD *)(a2 + 8);
  v44 = 0LL;
  v39 = v16;
  if ( !a6 )
    v14 = 0LL;
  if ( !a8 )
    goto LABEL_21;
  v17 = *(unsigned int **)(a2 + 32);
  v18 = *v17;
  LODWORD(v19) = *v17 & 7;
  if ( !(_DWORD)v19 )
    goto LABEL_21;
  if ( a5 )
    _assert_fail(
      (__int64)"outbufstart == NULL",
      (__int64)"../iconv/skeleton.c",
      0x22Fu,
      "__gconv_transform_ucs4le_internal");
  v20 = *a3;
  v19 = (int)v19;
  if ( a4 <= *a3 )
    goto LABEL_17;
  if ( (v18 & 4) == 0 )
  {
    while ( 1 )
    {
      ++v20;
      ++v19;
      *a3 = v20;
      *((_BYTE *)v17 + v19 + 3) = *(_BYTE *)(v20 - 1);
      if ( a4 == v20 )
        break;
      if ( v19 == 4 )
        goto LABEL_18;
    }
LABEL_17:
    if ( v19 <= 3 )
    {
      v29 = 7;
      *v17 = v18 & 0xFFFFFFF8 | v19;
      return v29;
    }
  }
LABEL_18:
  if ( *((_BYTE *)v17 + 7) > 0x80u )
  {
    if ( (v12 & 2) == 0 )
      return 6;
  }
  else
  {
    *((_BYTE *)++v15 - 4) = *((_BYTE *)v17 + 4);
    *((_BYTE *)v15 - 3) = *((_BYTE *)v17 + 5);
    *((_BYTE *)v15 - 2) = *((_BYTE *)v17 + 6);
    *((_BYTE *)v15 - 1) = *((_BYTE *)v17 + 7);
    v18 = *v17;
  }
  v12 = *(_DWORD *)(a2 + 16);
  *v17 = v18 & 0xFFFFFFF8;
LABEL_21:
  v21 = v8;
  v22 = v14;
  while ( 1 )
  {
    v23 = (int *)*a3;
    v24 = v15;
    v25 = a4 - *a3;
    if ( (__int64)(v39 - (_QWORD)v15) <= v25 )
      v25 = v39 - (_QWORD)v15;
    v26 = v25 / 4;
    if ( v25 / 4 )
    {
      v27 = 0LL;
      v28 = v12 & 2;
      while ( 1 )
      {
        while ( *v23 >= 0 )
        {
          ++v27;
          *v24++ = *v23++;
          if ( v26 == v27 )
            goto LABEL_31;
        }
        if ( !v22 )
          break;
        if ( !v28 )
        {
          *a3 = (unsigned __int64)v23;
          v29 = 6;
          goto LABEL_38;
        }
        ++v27;
        ++*v22;
        ++v23;
        if ( v26 == v27 )
          goto LABEL_31;
      }
      v24 = v15;
      v29 = 6;
LABEL_38:
      if ( a5 )
        goto LABEL_35;
      goto LABEL_39;
    }
LABEL_31:
    *a3 = (unsigned __int64)v23;
    if ( v23 == (int *)a4 )
    {
      v29 = 4;
      goto LABEL_38;
    }
    if ( a4 < (unsigned __int64)(v23 + 1) )
    {
      v29 = 7;
      goto LABEL_38;
    }
    if ( v39 >= (unsigned __int64)(v24 + 1) )
      _assert_fail((__int64)"*outptrp + 4 > outend", (__int64)"gconv_simple.c", 0x294u, "ucs4le_internal_loop");
    v29 = 5;
    if ( a5 )
    {
LABEL_35:
      *a5 = v24;
      return v29;
    }
LABEL_39:
    ++*(_DWORD *)(a2 + 20);
    if ( (*(_BYTE *)(a2 + 16) & 1) != 0 )
    {
      v37 = v44;
      *(_QWORD *)a2 = v24;
      *a6 += v37;
      goto LABEL_47;
    }
    if ( v15 >= v24 )
      goto LABEL_47;
    v38 = v29;
    v45[0] = *(_QWORD *)a2;
    dl_mcount_wrapper_check((__int64)v21);
    v31 = v21(v42, v43, v45, v24, 0LL, a6, 0LL, a8);
    v29 = v38;
    if ( v31 != 4 )
      break;
    if ( v38 != 5 )
      goto LABEL_47;
LABEL_45:
    v12 = *(_DWORD *)(a2 + 16);
    v15 = *(_DWORD **)a2;
  }
  if ( (_DWORD *)v45[0] != v24 )
    *a3 -= (unsigned __int64)v24 - v45[0];
  if ( !v31 )
    goto LABEL_45;
  v29 = v31;
LABEL_47:
  if ( a8 && v29 == 7 )
  {
    v32 = *a3;
    if ( (__int64)(a4 - *a3) > 3 )
      _assert_fail(
        (__int64)"inend - *inptrp < 4",
        (__int64)"../iconv/skeleton.c",
        0x309u,
        "__gconv_transform_ucs4le_internal");
    v33 = *(unsigned int **)(a2 + 32);
    v34 = *a3;
    v35 = v33 + 1;
    if ( v32 >= a4 )
    {
      v36 = 0;
    }
    else
    {
      do
      {
        ++v34;
        v35 = (_DWORD *)((char *)v35 + 1);
        *a3 = v34;
        *((_BYTE *)v35 - 1) = *(_BYTE *)(v34 - 1);
      }
      while ( v34 != a4 );
      v36 = v34 - v32;
    }
    *v33 = *v33 & 0xFFFFFFF8 | v36;
  }
  return v29;
}

//----- (00000000004456B0) ----------------------------------------------------
__int64 __fastcall _gconv_transform_ascii_internal(
        __int64 a1,
        __int64 a2,
        unsigned __int8 **a3,
        unsigned __int8 *a4,
        _QWORD *a5,
        _QWORD *a6,
        unsigned int a7,
        unsigned int a8)
{
  unsigned int (__fastcall *v9)(__int64, __int64, __int64 *, _DWORD *, _QWORD, _QWORD *, _QWORD, _QWORD); // r15
  int v12; // er8
  _QWORD *v13; // rax
  unsigned __int8 *v15; // rcx
  unsigned __int64 v16; // r13
  _DWORD *v17; // rdi
  __int64 *v18; // rax
  _DWORD *v19; // rsi
  unsigned __int8 *v20; // rax
  _DWORD *v21; // rbx
  unsigned int v22; // er11
  int v23; // er8
  int v24; // edx
  unsigned int v25; // eax
  unsigned int v26; // er14
  __int64 v28; // rax
  unsigned int v29; // [rsp+Ch] [rbp-8Ch]
  _QWORD *v30; // [rsp+10h] [rbp-88h]
  __int64 v32; // [rsp+20h] [rbp-78h]
  __int64 v33; // [rsp+28h] [rbp-70h]
  __int64 *v34; // [rsp+38h] [rbp-60h]
  __int64 v35; // [rsp+48h] [rbp-50h] BYREF
  __int64 v36[9]; // [rsp+50h] [rbp-48h] BYREF

  v9 = 0LL;
  v12 = *(_DWORD *)(a2 + 16);
  v36[1] = __readfsqword(0x28u);
  v32 = a1 + 104;
  v33 = a2 + 48;
  if ( (v12 & 1) == 0 )
  {
    v9 = *(unsigned int (__fastcall **)(__int64, __int64, __int64 *, _DWORD *, _QWORD, _QWORD *, _QWORD, _QWORD))(a1 + 144);
    if ( *(_QWORD *)(a1 + 104) )
      v9 = (unsigned int (__fastcall *)(__int64, __int64, __int64 *, _DWORD *, _QWORD, _QWORD *, _QWORD, _QWORD))(__readfsqword(0x30u) ^ __ROR8__(v9, 17));
  }
  if ( a7 )
  {
    if ( a5 )
      _assert_fail(
        (__int64)"outbufstart == NULL",
        (__int64)"../iconv/skeleton.c",
        0x19Fu,
        "__gconv_transform_ascii_internal");
    v26 = 0;
    **(_QWORD **)(a2 + 32) = 0LL;
    if ( (*(_BYTE *)(a2 + 16) & 1) == 0 )
    {
      dl_mcount_wrapper_check((__int64)v9);
      return v9(v32, v33, 0LL, 0LL, 0LL, a6, a7, a8);
    }
  }
  else
  {
    v13 = a5;
    if ( !a5 )
      v13 = (_QWORD *)a2;
    v15 = *a3;
    v16 = *(_QWORD *)(a2 + 8);
    v17 = (_DWORD *)*v13;
    v18 = 0LL;
    v30 = a5;
    v35 = 0LL;
    if ( a6 )
      v18 = &v35;
    v34 = v18;
    if ( v15 == a4 )
      goto LABEL_26;
LABEL_10:
    v19 = v17 + 1;
    if ( (unsigned __int64)(v17 + 1) <= v16 )
    {
      v20 = v15;
      v21 = v17;
      v22 = 4;
      v23 = v12 & 2;
      while ( 1 )
      {
        v24 = *v20;
        v15 = v20;
        if ( (v24 & 0x80u) == 0 )
        {
          ++v20;
          *v21 = v24;
          v21 = v19;
          v15 = v20;
          if ( a4 == v20 )
            goto LABEL_18;
        }
        else
        {
          if ( !v34 || !v23 )
          {
            v22 = 6;
            goto LABEL_18;
          }
          ++v20;
          ++*v34;
          v22 = 6;
          v15 = v20;
          if ( a4 == v20 )
            goto LABEL_18;
        }
        v19 = v21 + 1;
        if ( v16 < (unsigned __int64)(v21 + 1) )
        {
          v22 = 5;
          goto LABEL_18;
        }
      }
    }
    v21 = v17;
    v22 = 5;
LABEL_18:
    for ( *a3 = v15; !v30; *a3 = a4 )
    {
      ++*(_DWORD *)(a2 + 20);
      if ( (*(_BYTE *)(a2 + 16) & 1) != 0 )
      {
        v28 = v35;
        *(_QWORD *)a2 = v21;
        v26 = v22;
        *a6 += v28;
        return v26;
      }
      if ( v21 <= v17 )
        return v22;
      v29 = v22;
      v36[0] = *(_QWORD *)a2;
      dl_mcount_wrapper_check((__int64)v9);
      v25 = v9(v32, v33, v36, v21, 0LL, a6, 0LL, a8);
      v22 = v29;
      if ( v25 == 4 )
      {
        if ( v29 != 5 )
          return v22;
      }
      else
      {
        if ( v21 != (_DWORD *)v36[0] )
          *a3 -= ((__int64)v21 - v36[0]) / 4;
        if ( v25 )
          return v25;
      }
      v15 = *a3;
      v12 = *(_DWORD *)(a2 + 16);
      v17 = *(_DWORD **)a2;
      if ( *a3 != a4 )
        goto LABEL_10;
LABEL_26:
      v21 = v17;
      v22 = 4;
    }
    v26 = v22;
    *v30 = v21;
  }
  return v26;
}

//----- (00000000004459D0) ----------------------------------------------------
__int64 __fastcall _gconv_transform_internal_ascii(
        _QWORD *a1,
        __int64 a2,
        unsigned int **a3,
        unsigned __int64 a4,
        _QWORD *a5,
        _QWORD *a6,
        unsigned int a7,
        unsigned int a8)
{
  __int64 *v8; // r11
  int v11; // er15
  unsigned int *v12; // rdx
  unsigned __int64 v13; // r14
  _QWORD *v14; // rax
  _BYTE *v15; // r13
  __int64 *v16; // rax
  _BYTE *v17; // rbx
  int v18; // er15
  int v19; // eax
  unsigned int v20; // ecx
  unsigned int v21; // er10
  unsigned int v23; // eax
  unsigned int *v24; // rbx
  unsigned int v25; // esi
  __int64 v26; // rcx
  __int64 v27; // rax
  unsigned int *v28; // rax
  unsigned __int64 v29; // rdi
  char v30; // r8
  unsigned int *v31; // r10
  unsigned int *v32; // rax
  __int64 v33; // rax
  unsigned int *v34; // rax
  __int64 v35; // rax
  unsigned __int64 v36; // rsi
  unsigned int *v37; // rdi
  __int64 v38; // rax
  _BYTE *v39; // rdx
  char *v40; // rax
  unsigned int *v41; // rax
  int v42; // ebp
  signed int v43; // eax
  unsigned int *v44; // rax
  _DWORD *v45; // rdx
  __int64 *v47; // [rsp+10h] [rbp-B8h]
  __int64 *v48; // [rsp+10h] [rbp-B8h]
  unsigned int v49; // [rsp+18h] [rbp-B0h]
  unsigned int (__fastcall *v51)(_QWORD *, __int64, _DWORD *, _BYTE *, _QWORD, _QWORD *, _QWORD, _QWORD); // [rsp+28h] [rbp-A0h]
  __int64 *v52; // [rsp+30h] [rbp-98h]
  _QWORD *v53; // [rsp+38h] [rbp-90h]
  __int64 v54; // [rsp+40h] [rbp-88h]
  __int64 *v55; // [rsp+48h] [rbp-80h]
  __int64 *v57; // [rsp+58h] [rbp-70h]
  __int64 v58; // [rsp+68h] [rbp-60h] BYREF
  unsigned int *v59; // [rsp+70h] [rbp-58h] BYREF
  _DWORD v60[3]; // [rsp+78h] [rbp-50h] BYREF
  unsigned int v61; // [rsp+84h] [rbp-44h] BYREF
  __int64 v62[8]; // [rsp+88h] [rbp-40h] BYREF

  v8 = (__int64 *)a3;
  v11 = *(_DWORD *)(a2 + 16);
  v62[0] = __readfsqword(0x28u);
  v51 = 0LL;
  v53 = a1 + 13;
  v54 = a2 + 48;
  if ( (v11 & 1) == 0 )
  {
    v51 = (unsigned int (__fastcall *)(_QWORD *, __int64, _DWORD *, _BYTE *, _QWORD, _QWORD *, _QWORD, _QWORD))a1[18];
    if ( a1[13] )
      v51 = (unsigned int (__fastcall *)(_QWORD *, __int64, _DWORD *, _BYTE *, _QWORD, _QWORD *, _QWORD, _QWORD))(__readfsqword(0x30u) ^ __ROR8__(a1[18], 17));
  }
  if ( a7 )
  {
    if ( a5 )
      _assert_fail(
        (__int64)"outbufstart == NULL",
        (__int64)"../iconv/skeleton.c",
        0x19Fu,
        "__gconv_transform_internal_ascii");
    v21 = 0;
    **(_QWORD **)(a2 + 32) = 0LL;
    if ( (*(_BYTE *)(a2 + 16) & 1) == 0 )
    {
      dl_mcount_wrapper_check((__int64)v51);
      return v51(v53, v54, 0LL, 0LL, 0LL, a6, a7, a8);
    }
    return v21;
  }
  v12 = *a3;
  v13 = *(_QWORD *)(a2 + 8);
  v14 = a5;
  if ( !a5 )
    v14 = (_QWORD *)a2;
  v15 = (_BYTE *)*v14;
  v16 = 0LL;
  v58 = 0LL;
  if ( a6 )
    v16 = &v58;
  v55 = v16;
  if ( !a8 )
    goto LABEL_10;
  v24 = *(unsigned int **)(a2 + 32);
  v25 = *v24;
  LODWORD(v26) = *v24 & 7;
  if ( !(_DWORD)v26 )
    goto LABEL_10;
  if ( a5 )
    _assert_fail(
      (__int64)"outbufstart == NULL",
      (__int64)"../iconv/skeleton.c",
      0x22Fu,
      "__gconv_transform_internal_ascii");
  v59 = v12;
  *(_QWORD *)v60 = v15;
  if ( (unsigned int)v26 > 4 )
    _assert_fail(
      (__int64)"(state->__count & 7) <= sizeof (state->__value)",
      (__int64)"../iconv/loop.c",
      0x18Bu,
      "internal_ascii_loop_single");
  v26 = (int)v26;
  v27 = 0LL;
  do
  {
    *((_BYTE *)&v61 + v27) = *((_BYTE *)v24 + v27 + 4);
    ++v27;
  }
  while ( v27 != (int)v26 );
  if ( a4 < (unsigned __int64)v12 - v27 + 4 )
  {
    *v8 = a4;
    if ( (unsigned __int64)v12 < a4 )
    {
      v40 = (char *)v24 + v27;
      do
      {
        v12 = (unsigned int *)((char *)v12 + 1);
        ++v40;
        v59 = v12;
        v40[3] = *((_BYTE *)v12 - 1);
      }
      while ( (unsigned int *)a4 != v12 );
    }
    return 7;
  }
  v28 = (unsigned int *)((char *)v12 + 1);
  v21 = 5;
  if ( (unsigned __int64)v15 >= v13 )
    return v21;
  v29 = (int)v26;
  do
  {
    v59 = v28;
    v30 = *((_BYTE *)v28 - 1);
    ++v29;
    v31 = v28;
    v28 = (unsigned int *)((char *)v28 + 1);
    *((_BYTE *)&v60[2] + v29 + 3) = v30;
  }
  while ( v29 <= 3 && a4 > (unsigned __int64)v31 );
  v59 = &v61;
  if ( v61 <= 0x7F )
  {
    *(_QWORD *)v60 = v15 + 1;
    *v15 = v61;
    v32 = v59 + 1;
    v59 = v32;
    if ( v32 != &v61 )
    {
      v33 = (char *)v32 - (char *)&v61;
      v25 = *v24;
      v26 = *v24 & 7;
LABEL_50:
      if ( v26 >= v33 )
        _assert_fail(
          (__int64)"inptr - bytebuf > (state->__count & 7)",
          (__int64)"../iconv/loop.c",
          0x1C9u,
          "internal_ascii_loop_single");
      v34 = (unsigned int *)(*v8 + v33 - v26);
      v15 = *(_BYTE **)v60;
      *v8 = (__int64)v34;
      v12 = v34;
      v11 = *(_DWORD *)(a2 + 16);
      *v24 = v25 & 0xFFFFFFF8;
      goto LABEL_10;
    }
    goto LABEL_69;
  }
  if ( v61 >> 7 == 7168 )
  {
    v59 = (unsigned int *)v62;
    v33 = 4LL;
    goto LABEL_50;
  }
  if ( !v55 )
    return 6;
  if ( (v11 & 8) == 0 )
  {
    v21 = 6;
    v41 = &v61;
    if ( (v11 & 2) == 0 )
      return v21;
    goto LABEL_78;
  }
  v57 = v8;
  v52 = (__int64 *)((char *)&v61 + v29);
  v21 = _gconv_transliterate(a1, a2, (__int64)v12, &v59, (unsigned __int64)&v61 + v29, (__int64 *)v60, v55);
  v8 = v57;
  v41 = v59;
  if ( v21 == 6 )
  {
    if ( (v11 & 2) == 0 )
    {
LABEL_79:
      if ( v41 != &v61 )
      {
LABEL_80:
        v25 = *v24;
        v33 = (char *)v41 - (char *)&v61;
        v26 = *v24 & 7;
        goto LABEL_50;
      }
      return 6;
    }
LABEL_78:
    v59 = ++v41;
    ++*v55;
    goto LABEL_79;
  }
  if ( v59 != &v61 )
    goto LABEL_80;
  if ( v21 == 7 )
  {
    if ( v52 == v62 )
      _assert_fail(
        (__int64)"inend != &bytebuf[MAX_NEEDED_INPUT]",
        (__int64)"../iconv/loop.c",
        0x1DBu,
        "internal_ascii_loop_single");
    v43 = *v24 & 0xFFFFFFF8;
    *v57 += v29 - (*v24 & 7);
    if ( v43 >= (__int64)v29 )
      _assert_fail(
        (__int64)"inend - inptr > (state->__count & ~7)",
        (__int64)"../iconv/loop.c",
        0x1E5u,
        "internal_ascii_loop_single");
    if ( v29 > 4 )
      _assert_fail(
        (__int64)"inend - inptr <= sizeof (state->__value)",
        (__int64)"../iconv/loop.c",
        0x1E6u,
        "internal_ascii_loop_single");
    *v24 = v29 | v43;
    v44 = &v61;
    if ( v52 > (__int64 *)&v61 )
    {
      v45 = v24 + 1;
      do
      {
        v44 = (unsigned int *)((char *)v44 + 1);
        v45 = (_DWORD *)((char *)v45 + 1);
        v59 = v44;
        *((_BYTE *)v45 - 1) = *((_BYTE *)v44 - 1);
      }
      while ( v52 != (__int64 *)v44 );
    }
    return 7;
  }
  if ( v21 )
    return v21;
LABEL_69:
  v12 = (unsigned int *)*v8;
  v11 = *(_DWORD *)(a2 + 16);
  while ( 1 )
  {
LABEL_10:
    v59 = v12;
    v17 = v15;
    v18 = v11 & 2;
    *(_QWORD *)v60 = v15;
    v19 = 4;
LABEL_11:
    if ( v12 != (unsigned int *)a4 )
    {
      while ( 1 )
      {
        if ( a4 < (unsigned __int64)(v12 + 1) )
        {
          v21 = 7;
          goto LABEL_20;
        }
        if ( v13 <= (unsigned __int64)v17 )
          break;
        v20 = *v12;
        if ( *v12 > 0x7F )
        {
          if ( v20 >> 7 == 7168 )
          {
            v59 = ++v12;
            goto LABEL_11;
          }
          if ( v55 )
          {
            if ( (*(_BYTE *)(a2 + 16) & 8) != 0 )
            {
              v48 = v8;
              v19 = _gconv_transliterate(a1, a2, *v8, &v59, a4, (__int64 *)v60, v55);
              v12 = v59;
              v17 = *(_BYTE **)v60;
              v8 = v48;
              if ( v19 != 6 )
              {
                if ( v19 != 5 )
                  goto LABEL_11;
                goto LABEL_16;
              }
            }
            if ( v18 )
            {
              v59 = ++v12;
              ++*v55;
              v19 = 6;
              goto LABEL_11;
            }
          }
          v21 = 6;
LABEL_20:
          *v8 = (__int64)v12;
          if ( a5 )
            goto LABEL_17;
          goto LABEL_21;
        }
        *(_QWORD *)v60 = v17 + 1;
        *v17 = v20;
        v17 = *(_BYTE **)v60;
        v12 = v59 + 1;
        v59 = v12;
        if ( v12 == (unsigned int *)a4 )
          goto LABEL_16;
      }
      v21 = 5;
      goto LABEL_20;
    }
LABEL_16:
    v21 = v19;
    *v8 = (__int64)v12;
    if ( a5 )
    {
LABEL_17:
      *a5 = v17;
      return v21;
    }
LABEL_21:
    ++*(_DWORD *)(a2 + 20);
    if ( (*(_BYTE *)(a2 + 16) & 1) != 0 )
      break;
    if ( v15 >= v17 )
    {
      v23 = v21;
      goto LABEL_26;
    }
    v49 = v21;
    v47 = v8;
    *(_QWORD *)v60 = *(_QWORD *)a2;
    dl_mcount_wrapper_check((__int64)v51);
    v23 = v51(v53, v54, v60, v17, 0LL, a6, 0LL, a8);
    v8 = v47;
    if ( v23 != 4 )
    {
      if ( *(_BYTE **)v60 != v17 )
        *v47 -= 4LL * (_QWORD)&v17[-*(_QWORD *)v60];
LABEL_26:
      if ( v23 )
        goto LABEL_36;
      goto LABEL_27;
    }
    v23 = v49;
    if ( v49 != 5 && v49 )
    {
LABEL_36:
      v21 = v23;
      goto LABEL_53;
    }
LABEL_27:
    v12 = (unsigned int *)*v8;
    v11 = *(_DWORD *)(a2 + 16);
    v15 = *(_BYTE **)a2;
  }
  v35 = v58;
  *(_QWORD *)a2 = v17;
  *a6 += v35;
LABEL_53:
  if ( v21 == 7 && a8 )
  {
    v36 = *v8;
    if ( (__int64)(a4 - *v8) > 3 )
      _assert_fail(
        (__int64)"inend - *inptrp < 4",
        (__int64)"../iconv/skeleton.c",
        0x309u,
        "__gconv_transform_internal_ascii");
    v37 = *(unsigned int **)(a2 + 32);
    v38 = v36 + 1;
    v39 = v37 + 1;
    if ( v36 >= a4 )
    {
      v42 = 0;
    }
    else
    {
      while ( 1 )
      {
        *v8 = v38;
        *v39++ = *(_BYTE *)(v38 - 1);
        if ( a4 == v38 )
          break;
        ++v38;
      }
      v42 = a4 - v36;
    }
    *v37 = v42 | *v37 & 0xFFFFFFF8;
  }
  return v21;
}

//----- (0000000000446210) ----------------------------------------------------
__int64 __fastcall _gconv_transform_internal_utf8(
        _QWORD *a1,
        __int64 a2,
        __int64 *a3,
        unsigned __int64 a4,
        _QWORD *a5,
        _QWORD *a6,
        unsigned int a7,
        unsigned int a8)
{
  int v10; // er15
  unsigned __int64 v11; // r13
  unsigned int *v12; // r12
  _QWORD *v13; // rax
  _BYTE *v14; // r14
  __int64 *v15; // rax
  int v16; // er11
  _BYTE *v17; // r15
  unsigned __int64 v18; // r14
  _BYTE *v19; // r13
  unsigned int *v20; // rax
  int v21; // er11
  unsigned int v22; // er10
  int v23; // edx
  unsigned int v24; // er11
  unsigned __int64 v25; // r10
  __int64 v27; // rcx
  char v28; // al
  unsigned __int64 v29; // r11
  __int64 v30; // rax
  unsigned int *v31; // rax
  char v32; // dl
  unsigned int *v33; // rcx
  unsigned int v34; // eax
  unsigned int *v35; // rax
  signed __int64 v36; // rax
  unsigned int v37; // edx
  signed __int64 v38; // rcx
  __int64 v39; // rax
  __int64 v40; // rax
  unsigned __int64 v41; // rsi
  unsigned int *v42; // rdi
  __int64 v43; // rax
  _BYTE *v44; // rdx
  int v45; // er13
  _BYTE *v46; // rdx
  int v47; // er13
  int v48; // esi
  int v49; // eax
  _BYTE *v50; // rax
  __int64 v51; // rdx
  __int64 v52; // rcx
  char v53; // di
  char *v54; // rax
  __int64 v55; // rcx
  char v56; // dl
  int v57; // ebx
  signed int v58; // eax
  unsigned int *v59; // rax
  _DWORD *v60; // rdx
  unsigned int (__fastcall *v62)(_QWORD *, __int64, _BYTE **, _BYTE *, _QWORD, _QWORD *, _QWORD, _QWORD); // [rsp+8h] [rbp-C0h]
  unsigned int v64; // [rsp+18h] [rbp-B0h]
  unsigned int *v65; // [rsp+18h] [rbp-B0h]
  unsigned __int64 v66; // [rsp+18h] [rbp-B0h]
  int v67; // [rsp+18h] [rbp-B0h]
  _QWORD *v69; // [rsp+28h] [rbp-A0h]
  __int64 v70; // [rsp+30h] [rbp-98h]
  __int64 *v71; // [rsp+38h] [rbp-90h]
  __int64 *v73; // [rsp+50h] [rbp-78h]
  unsigned int v74; // [rsp+58h] [rbp-70h]
  unsigned __int64 v75; // [rsp+58h] [rbp-70h]
  __int64 v76; // [rsp+60h] [rbp-68h] BYREF
  _BYTE *v77; // [rsp+68h] [rbp-60h] BYREF
  unsigned int *v78; // [rsp+70h] [rbp-58h] BYREF
  _DWORD v79[3]; // [rsp+78h] [rbp-50h] BYREF
  unsigned int v80; // [rsp+84h] [rbp-44h] BYREF
  unsigned __int64 v81; // [rsp+88h] [rbp-40h] BYREF

  v10 = *(_DWORD *)(a2 + 16);
  v81 = __readfsqword(0x28u);
  v62 = 0LL;
  v69 = a1 + 13;
  v70 = a2 + 48;
  if ( (v10 & 1) == 0 )
  {
    v62 = (unsigned int (__fastcall *)(_QWORD *, __int64, _BYTE **, _BYTE *, _QWORD, _QWORD *, _QWORD, _QWORD))a1[18];
    if ( a1[13] )
      v62 = (unsigned int (__fastcall *)(_QWORD *, __int64, _BYTE **, _BYTE *, _QWORD, _QWORD *, _QWORD, _QWORD))(__readfsqword(0x30u) ^ __ROR8__(a1[18], 17));
  }
  if ( a7 )
  {
    if ( a5 )
      _assert_fail(
        (__int64)"outbufstart == NULL",
        (__int64)"../iconv/skeleton.c",
        0x19Fu,
        "__gconv_transform_internal_utf8");
    v22 = 0;
    **(_QWORD **)(a2 + 32) = 0LL;
    if ( (*(_BYTE *)(a2 + 16) & 1) == 0 )
    {
      dl_mcount_wrapper_check((__int64)v62);
      return v62(v69, v70, 0LL, 0LL, 0LL, a6, a7, a8);
    }
    return v22;
  }
  v11 = *(_QWORD *)(a2 + 8);
  v12 = (unsigned int *)*a3;
  v13 = a5;
  if ( !a5 )
    v13 = (_QWORD *)a2;
  v14 = (_BYTE *)*v13;
  v15 = 0LL;
  v76 = 0LL;
  if ( a6 )
    v15 = &v76;
  v71 = v15;
  if ( !a8 )
    goto LABEL_10;
  v65 = *(unsigned int **)(a2 + 32);
  LODWORD(v29) = *v65 & 7;
  if ( (*v65 & 7) == 0 )
    goto LABEL_10;
  if ( a5 )
    _assert_fail(
      (__int64)"outbufstart == NULL",
      (__int64)"../iconv/skeleton.c",
      0x22Fu,
      "__gconv_transform_internal_utf8");
  v78 = v12;
  *(_QWORD *)v79 = v14;
  if ( (unsigned int)v29 > 4 )
    _assert_fail(
      (__int64)"(state->__count & 7) <= sizeof (state->__value)",
      (__int64)"../iconv/loop.c",
      0x18Bu,
      "internal_utf8_loop_single");
  v29 = (int)v29;
  v30 = 0LL;
  do
  {
    *((_BYTE *)&v80 + v30) = *((_BYTE *)v65 + v30 + 4);
    ++v30;
  }
  while ( v30 != (int)v29 );
  if ( a4 < (unsigned __int64)v12 - v30 + 4 )
  {
    *a3 = a4;
    if ( (unsigned __int64)v12 < a4 )
    {
      v54 = (char *)v65 + v30;
      do
      {
        v12 = (unsigned int *)((char *)v12 + 1);
        ++v54;
        v78 = v12;
        v54[3] = *((_BYTE *)v12 - 1);
      }
      while ( (unsigned int *)a4 != v12 );
    }
    return 7;
  }
  v31 = (unsigned int *)((char *)v12 + 1);
  if ( (unsigned __int64)v14 >= v11 )
    return 5;
  do
  {
    v78 = v31;
    v32 = *((_BYTE *)v31 - 1);
    ++v29;
    v33 = v31;
    v31 = (unsigned int *)((char *)v31 + 1);
    *((_BYTE *)&v79[2] + v29 + 3) = v32;
  }
  while ( v29 <= 3 && a4 > (unsigned __int64)v33 );
  v78 = &v80;
  v34 = v80;
  if ( v80 <= 0x7F )
  {
    *(_QWORD *)v79 = v14 + 1;
    *v14 = v80;
    goto LABEL_52;
  }
  if ( v80 - 55296 <= 0x7FF || (v80 & 0x80000000) != 0 )
  {
    if ( !v71 )
      return 6;
    if ( (v10 & 8) == 0 )
    {
      v22 = 6;
      if ( (v10 & 2) == 0 )
        return v22;
      goto LABEL_134;
    }
    v75 = v29;
    v73 = (__int64 *)((char *)&v80 + v29);
    v22 = _gconv_transliterate(a1, a2, (__int64)v12, &v78, (unsigned __int64)&v80 + v29, (__int64 *)v79, v71);
    if ( v22 == 6 )
    {
      if ( (v10 & 2) == 0 )
      {
LABEL_135:
        v35 = v78;
        if ( v78 != &v80 )
          goto LABEL_53;
        return 6;
      }
LABEL_134:
      ++v78;
      ++*v71;
      goto LABEL_135;
    }
    v35 = v78;
    if ( v78 != &v80 )
      goto LABEL_53;
    if ( v22 != 7 )
    {
      if ( v22 )
        return v22;
      goto LABEL_106;
    }
    if ( v73 == (__int64 *)&v81 )
      _assert_fail(
        (__int64)"inend != &bytebuf[MAX_NEEDED_INPUT]",
        (__int64)"../iconv/loop.c",
        0x1DBu,
        "internal_utf8_loop_single");
    v58 = *v65 & 0xFFFFFFF8;
    *a3 += v75 - (*v65 & 7);
    if ( (__int64)v75 <= v58 )
      _assert_fail(
        (__int64)"inend - inptr > (state->__count & ~7)",
        (__int64)"../iconv/loop.c",
        0x1E5u,
        "internal_utf8_loop_single");
    if ( v75 > 4 )
      _assert_fail(
        (__int64)"inend - inptr <= sizeof (state->__value)",
        (__int64)"../iconv/loop.c",
        0x1E6u,
        "internal_utf8_loop_single");
    *v65 = v75 | v58;
    v59 = &v80;
    if ( v73 > (__int64 *)&v80 )
    {
      v60 = v65 + 1;
      do
      {
        v59 = (unsigned int *)((char *)v59 + 1);
        v60 = (_DWORD *)((char *)v60 + 1);
        v78 = v59;
        *((_BYTE *)v60 - 1) = *((_BYTE *)v59 - 1);
      }
      while ( v73 != (__int64 *)v59 );
    }
    return 7;
  }
  if ( (v80 & 0xFFFFF800) != 0 )
  {
    if ( (v80 & 0xFFFF0000) != 0 )
    {
      if ( (v80 & 0xFFE00000) != 0 )
        v55 = ((v80 & 0xFC000000) != 0) + 5LL;
      else
        v55 = 4LL;
    }
    else
    {
      v55 = 3LL;
    }
  }
  else
  {
    v55 = 2LL;
  }
  if ( v11 < (unsigned __int64)&v14[v55] )
    return 5;
  *v14 = -256 >> v55;
  *(_QWORD *)v79 += v55;
  do
  {
    v56 = v34;
    --v55;
    v34 >>= 6;
    v14[v55] = v56 & 0x3F | 0x80;
  }
  while ( v55 != 1 );
  *v14 |= v34;
LABEL_52:
  v35 = v78 + 1;
  v78 = v35;
  if ( v35 == &v80 )
  {
LABEL_106:
    v10 = *(_DWORD *)(a2 + 16);
    v12 = (unsigned int *)*a3;
    goto LABEL_10;
  }
LABEL_53:
  v36 = (char *)v35 - (char *)&v80;
  v37 = *v65;
  v38 = *v65 & 7;
  if ( v36 <= v38 )
    _assert_fail(
      (__int64)"inptr - bytebuf > (state->__count & 7)",
      (__int64)"../iconv/loop.c",
      0x1C9u,
      "internal_utf8_loop_single");
  v14 = *(_BYTE **)v79;
  v10 = *(_DWORD *)(a2 + 16);
  v39 = *a3 + v36 - v38;
  *a3 = v39;
  v12 = (unsigned int *)v39;
  *v65 = v37 & 0xFFFFFFF8;
LABEL_10:
  LOBYTE(v16) = v10;
  v17 = v14;
  v18 = v11;
  while ( 2 )
  {
    v78 = v12;
    v19 = v17;
    v20 = v12;
    v21 = v16 & 2;
    *(_QWORD *)v79 = v17;
    v22 = 4;
    do
    {
      while ( 1 )
      {
        if ( (unsigned int *)a4 == v20 )
          goto LABEL_18;
        while ( 1 )
        {
          if ( a4 < (unsigned __int64)(v20 + 1) )
          {
            v22 = 7;
            *a3 = (__int64)v20;
            if ( !a5 )
              goto LABEL_19;
            goto LABEL_26;
          }
          if ( v18 <= (unsigned __int64)v19 )
            goto LABEL_28;
          v23 = *v20;
          if ( *v20 <= 0x7F )
          {
            *(_QWORD *)v79 = v19 + 1;
            *v19 = v23;
            goto LABEL_17;
          }
          if ( (unsigned int)(v23 - 55296) <= 0x7FF || v23 < 0 )
            break;
          if ( (v23 & 0xFFFFF800) != 0 )
          {
            if ( (v23 & 0xFFFF0000) != 0 )
            {
              if ( (v23 & 0xFFE00000) != 0 )
                v27 = ((v23 & 0xFC000000) != 0) + 5LL;
              else
                v27 = 4LL;
            }
            else
            {
              v27 = 3LL;
            }
          }
          else
          {
            v27 = 2LL;
          }
          if ( v18 < (unsigned __int64)&v19[v27] )
          {
LABEL_28:
            v22 = 5;
            goto LABEL_18;
          }
          *v19 = -256 >> v27;
          *(_QWORD *)v79 += v27;
          do
          {
            v28 = v23;
            --v27;
            v23 = (unsigned int)v23 >> 6;
            v19[v27] = v28 & 0x3F | 0x80;
          }
          while ( v27 != 1 );
          *v19 |= v23;
LABEL_17:
          v19 = *(_BYTE **)v79;
          v20 = v78 + 1;
          v78 = v20;
          if ( (unsigned int *)a4 == v20 )
            goto LABEL_18;
        }
        if ( !v71 )
          goto LABEL_75;
        if ( (*(_BYTE *)(a2 + 16) & 8) != 0 )
        {
          v67 = v21;
          v22 = _gconv_transliterate(a1, a2, *a3, &v78, a4, (__int64 *)v79, v71);
          v19 = *(_BYTE **)v79;
          v20 = v78;
          v21 = v67;
          if ( v22 != 6 )
            break;
        }
        if ( !v21 )
        {
LABEL_75:
          v22 = 6;
          goto LABEL_18;
        }
        ++v20;
        v22 = 6;
        v78 = v20;
        ++*v71;
      }
    }
    while ( v22 != 5 );
LABEL_18:
    *a3 = (__int64)v20;
    if ( a5 )
    {
LABEL_26:
      *a5 = v19;
      return v22;
    }
LABEL_19:
    ++*(_DWORD *)(a2 + 20);
    if ( (*(_BYTE *)(a2 + 16) & 1) != 0 )
    {
      v40 = v76;
      *(_QWORD *)a2 = v19;
      *a6 += v40;
      goto LABEL_56;
    }
    if ( v17 >= v19 )
    {
      v24 = v22;
      goto LABEL_23;
    }
    v64 = v22;
    v77 = *(_BYTE **)a2;
    dl_mcount_wrapper_check((__int64)v62);
    v24 = v62(v69, v70, &v77, v19, 0LL, a6, 0LL, a8);
    if ( v24 == 4 )
    {
      v24 = v64;
      if ( v64 != 5 )
        goto LABEL_23;
      goto LABEL_24;
    }
    v25 = (unsigned __int64)v77;
    if ( v77 == v19 )
      goto LABEL_23;
    v45 = *(_DWORD *)(a2 + 16);
    v78 = v12;
    v46 = v17;
    *(_QWORD *)v79 = v17;
    *a3 = (__int64)v12;
    v47 = v45 & 2;
    while ( 2 )
    {
      while ( 2 )
      {
        if ( v12 == (unsigned int *)a4 )
        {
LABEL_70:
          *a3 = a4;
          if ( v77 != v46 )
            goto LABEL_80;
          goto LABEL_71;
        }
        while ( 2 )
        {
          if ( a4 < (unsigned __int64)(v12 + 1) )
            goto LABEL_79;
          if ( v25 <= (unsigned __int64)v46 )
            goto LABEL_83;
          v48 = *v12;
          if ( *v12 <= 0x7F )
          {
            *(_QWORD *)v79 = v46 + 1;
            *v46 = v48;
LABEL_69:
            v46 = *(_BYTE **)v79;
            v12 = v78 + 1;
            v78 = v12;
            if ( v12 == (unsigned int *)a4 )
              goto LABEL_70;
            continue;
          }
          break;
        }
        if ( (unsigned int)(v48 - 55296) > 0x7FF && v48 >= 0 )
        {
          if ( (v48 & 0xFFFFF800) != 0 )
          {
            if ( (v48 & 0xFFFF0000) != 0 )
            {
              if ( (v48 & 0xFFE00000) != 0 )
                v52 = ((v48 & 0xFC000000) != 0) + 5LL;
              else
                v52 = 4LL;
            }
            else
            {
              v52 = 3LL;
            }
          }
          else
          {
            v52 = 2LL;
          }
          if ( v25 < (unsigned __int64)&v46[v52] )
            goto LABEL_83;
          *v46 = -256 >> v52;
          *(_QWORD *)v79 += v52;
          do
          {
            v53 = v48;
            --v52;
            v48 = (unsigned int)v48 >> 6;
            v46[v52] = v53 & 0x3F | 0x80;
          }
          while ( v52 != 1 );
          *v46 |= v48;
          goto LABEL_69;
        }
        if ( !v71 )
          goto LABEL_79;
        if ( (*(_BYTE *)(a2 + 16) & 8) == 0
          || (v74 = v24,
              v66 = v25,
              v49 = _gconv_transliterate(a1, a2, *a3, &v78, a4, (__int64 *)v79, v71),
              v12 = v78,
              v46 = *(_BYTE **)v79,
              v25 = v66,
              v24 = v74,
              v49 == 6) )
        {
          if ( !v47 )
          {
LABEL_79:
            *a3 = (__int64)v12;
            if ( v46 != v77 )
              goto LABEL_80;
LABEL_71:
            _assert_fail(
              (__int64)"nstatus == __GCONV_FULL_OUTPUT",
              (__int64)"../iconv/skeleton.c",
              0x2D8u,
              "__gconv_transform_internal_utf8");
          }
          v78 = ++v12;
          ++*v71;
          continue;
        }
        break;
      }
      if ( v49 != 5 )
        continue;
      break;
    }
LABEL_83:
    v50 = v46;
    v51 = (__int64)v77;
    *a3 = (__int64)v12;
    if ( v50 != (_BYTE *)v51 )
LABEL_80:
      _assert_fail(
        (__int64)"outbuf == outerr",
        (__int64)"../iconv/skeleton.c",
        0x2D7u,
        "__gconv_transform_internal_utf8");
    if ( v17 == (_BYTE *)v51 )
      --*(_DWORD *)(a2 + 20);
LABEL_23:
    if ( !v24 )
    {
LABEL_24:
      v16 = *(_DWORD *)(a2 + 16);
      v17 = *(_BYTE **)a2;
      v12 = (unsigned int *)*a3;
      continue;
    }
    break;
  }
  v22 = v24;
LABEL_56:
  if ( a8 && v22 == 7 )
  {
    v41 = *a3;
    if ( (__int64)(a4 - *a3) > 3 )
      _assert_fail(
        (__int64)"inend - *inptrp < 4",
        (__int64)"../iconv/skeleton.c",
        0x309u,
        "__gconv_transform_internal_utf8");
    v42 = *(unsigned int **)(a2 + 32);
    v43 = v41 + 1;
    v44 = v42 + 1;
    if ( v41 >= a4 )
    {
      v57 = 0;
    }
    else
    {
      while ( 1 )
      {
        *a3 = v43;
        *v44++ = *(_BYTE *)(v43 - 1);
        if ( a4 == v43 )
          break;
        ++v43;
      }
      v57 = a4 - v41;
    }
    *v42 = v57 | *v42 & 0xFFFFFFF8;
  }
  return v22;
}
// 446783: conditional instruction was optimized away because eax.4!=5

//----- (0000000000446DD0) ----------------------------------------------------
__int64 __fastcall _gconv_transform_utf8_internal(
        __int64 a1,
        __int64 a2,
        unsigned __int8 **a3,
        unsigned __int64 a4,
        unsigned int **a5,
        _QWORD *a6,
        unsigned int a7,
        unsigned int a8)
{
  int v10; // er9
  unsigned __int64 v11; // r12
  unsigned __int8 *v12; // r14
  unsigned int **v13; // rax
  unsigned int *v14; // r10
  __int64 *v15; // rax
  unsigned int *v16; // r15
  unsigned int *v17; // rdi
  unsigned __int8 *v18; // rdx
  unsigned int *v19; // rbx
  int v20; // er9
  unsigned int v21; // eax
  unsigned __int8 *v22; // r11
  unsigned __int8 v23; // cl
  __int64 v24; // r10
  unsigned __int8 *v25; // r8
  __int64 v26; // rsi
  unsigned __int8 v27; // cl
  unsigned int v28; // eax
  unsigned __int64 v29; // rsi
  unsigned int v30; // er15
  __int64 v32; // rcx
  _DWORD *v33; // r8
  unsigned __int8 *v34; // r9
  int v35; // edx
  unsigned __int64 v36; // r10
  int v37; // eax
  char v38; // si
  int v39; // edi
  unsigned __int8 *v40; // rdx
  char v41; // cl
  _DWORD *v42; // rdx
  unsigned __int64 v43; // rax
  int v44; // er11
  unsigned int v45; // esi
  unsigned __int64 v46; // rcx
  unsigned int *v47; // rbx
  unsigned __int8 v48; // si
  unsigned __int8 *v49; // rcx
  unsigned __int8 v50; // cl
  __int64 v51; // rsi
  __int64 v52; // rax
  int v53; // edx
  unsigned int *v54; // r8
  unsigned int *v55; // r9
  unsigned int v56; // edx
  unsigned __int8 *v57; // rbx
  unsigned __int8 v58; // cl
  __int64 v59; // r11
  __int64 v60; // rdi
  unsigned __int8 v61; // cl
  __int64 v62; // rdx
  unsigned int v63; // edi
  __int64 v64; // r8
  char v65; // al
  __int64 *v66; // rdi
  __int64 *v67; // rsi
  int v68; // er8
  int v69; // edi
  int v70; // esi
  char *v71; // r9
  char v72; // cl
  __int64 (__fastcall *v74)(__int64, __int64, _WORD *, unsigned int *, _QWORD, _QWORD *, _QWORD); // [rsp+8h] [rbp-A0h]
  __int64 v77; // [rsp+20h] [rbp-88h]
  __int64 v78; // [rsp+28h] [rbp-80h]
  __int64 v79; // [rsp+30h] [rbp-78h]
  __int64 *v80; // [rsp+38h] [rbp-70h]
  __int64 *v81; // [rsp+40h] [rbp-68h]
  int v82; // [rsp+48h] [rbp-60h]
  int v83; // [rsp+48h] [rbp-60h]
  int v84; // [rsp+48h] [rbp-60h]
  unsigned int v85; // [rsp+4Ch] [rbp-5Ch]
  __int64 v86; // [rsp+50h] [rbp-58h] BYREF
  _WORD v87[5]; // [rsp+58h] [rbp-50h] BYREF
  unsigned __int8 v88; // [rsp+62h] [rbp-46h] BYREF
  char v89; // [rsp+63h] [rbp-45h] BYREF
  int v90; // [rsp+64h] [rbp-44h] BYREF
  unsigned __int64 v91; // [rsp+68h] [rbp-40h] BYREF

  v10 = *(_DWORD *)(a2 + 16);
  v91 = __readfsqword(0x28u);
  v74 = 0LL;
  v77 = a1 + 104;
  v78 = a2 + 48;
  if ( (v10 & 1) == 0 )
  {
    v74 = *(__int64 (__fastcall **)(__int64, __int64, _WORD *, unsigned int *, _QWORD, _QWORD *, _QWORD))(a1 + 144);
    if ( *(_QWORD *)(a1 + 104) )
      v74 = (__int64 (__fastcall *)(__int64, __int64, _WORD *, unsigned int *, _QWORD, _QWORD *, _QWORD))(__readfsqword(0x30u) ^ __ROR8__(*(_QWORD *)(a1 + 144), 17));
  }
  if ( a7 )
  {
    if ( a5 )
      _assert_fail(
        (__int64)"outbufstart == NULL",
        (__int64)"../iconv/skeleton.c",
        0x19Fu,
        "__gconv_transform_utf8_internal");
    v30 = 0;
    **(_QWORD **)(a2 + 32) = 0LL;
    if ( (*(_BYTE *)(a2 + 16) & 1) == 0 )
    {
      dl_mcount_wrapper_check((__int64)v74);
      return ((unsigned int (__fastcall *)(__int64, __int64, _QWORD, _QWORD, _QWORD, _QWORD *, _QWORD, _QWORD))v74)(
               v77,
               v78,
               0LL,
               0LL,
               0LL,
               a6,
               a7,
               a8);
    }
    return v30;
  }
  v11 = *(_QWORD *)(a2 + 8);
  v12 = *a3;
  v13 = a5;
  if ( !a5 )
    v13 = (unsigned int **)a2;
  v14 = *v13;
  v15 = 0LL;
  v86 = 0LL;
  if ( a6 )
    v15 = &v86;
  v80 = v15;
  if ( !a8 )
    goto LABEL_10;
  v42 = *(_DWORD **)(a2 + 32);
  LODWORD(v43) = *v42;
  v44 = *v42 & 7;
  if ( !v44 )
    goto LABEL_10;
  if ( a5 )
    _assert_fail(
      (__int64)"outbufstart == NULL",
      (__int64)"../iconv/skeleton.c",
      0x22Fu,
      "__gconv_transform_utf8_internal");
  v45 = v42[1];
  v43 = (unsigned __int8)v43;
  v46 = (int)*v42 >> 8;
  v88 = inmask_11790[(int)v46 - 2];
  do
  {
    if ( v43 > --v46 )
      *(&v88 + v46) = v45 & 0x3F | 0x80;
    v45 >>= 6;
  }
  while ( v46 > 1 );
  v47 = v14 + 1;
  v48 = v88 | v45;
  if ( v11 < (unsigned __int64)(v14 + 1) )
    return 5;
  v88 = v48;
  v49 = v12;
  do
    *((_BYTE *)&v87[4] + ++v43 + 1) = *v49++;
  while ( a4 > (unsigned __int64)v49 && v43 <= 5 );
  v50 = v88;
  v83 = v88;
  if ( v88 > 0x7Fu )
  {
    v81 = (__int64 *)(&v88 + v43);
    v85 = v88 - 194;
    if ( v85 > 0x1D )
    {
      if ( (v88 & 0xF0) == 0xE0 )
      {
        v79 = 3LL;
        v63 = v88 & 0xF;
      }
      else if ( (v88 & 0xF8) == 0xF0 )
      {
        v79 = 4LL;
        v63 = v88 & 7;
      }
      else if ( (v88 & 0xFC) == 0xF8 )
      {
        v79 = 5LL;
        v63 = v88 & 3;
      }
      else
      {
        if ( (v88 & 0xFE) != 0xFC )
        {
          v64 = 0LL;
          do
            ++v64;
          while ( v81 > (__int64 *)(&v88 + v64) && (*(&v88 + v64) & 0xC0) == 0x80 && v64 != 5 );
          goto LABEL_131;
        }
        v79 = 6LL;
        v63 = v88 & 1;
      }
    }
    else
    {
      v79 = 2LL;
      v63 = v88 & 0x1F;
    }
    v64 = 1LL;
    if ( v81 >= (__int64 *)(&v88 + v79) )
    {
      while ( 1 )
      {
        v65 = *(&v88 + v64);
        if ( (v65 & 0xC0) != 0x80 )
          goto LABEL_131;
        ++v64;
        v63 = v65 & 0x3F | (v63 << 6);
        if ( v79 == v64 )
        {
          if ( v79 != 2 )
          {
            v51 = v79;
            if ( v63 >> (5 * v79 - 4) && v63 - 55296 > 0x7FF )
            {
              *v14 = v63;
              v44 = *v42 & 7;
              goto LABEL_72;
            }
            goto LABEL_131;
          }
          if ( v63 - 55296 <= 0x7FF )
            goto LABEL_131;
          *v14 = v63;
          v51 = 2LL;
          v44 = *v42 & 7;
          goto LABEL_72;
        }
      }
    }
    if ( v81 > (__int64 *)&v89 )
    {
      if ( (v89 & 0xC0) != 0x80 )
        goto LABEL_131;
      v66 = (__int64 *)&v90;
      while ( 1 )
      {
        ++v64;
        v67 = v66;
        if ( v81 <= v66 )
          break;
        v66 = (__int64 *)((char *)v66 + 1);
        if ( (*(_BYTE *)v67 & 0xC0) != 0x80 )
          goto LABEL_131;
      }
      if ( v81 != v66 )
        goto LABEL_131;
      if ( v81 == (__int64 *)&v91 )
        _assert_fail(
          (__int64)"inend != &bytebuf[MAX_NEEDED_INPUT]",
          (__int64)"../iconv/loop.c",
          0x1DBu,
          "utf8_internal_loop_single");
LABEL_149:
      *a3 = &v12[v43 - v44];
      *v42 = v43;
      if ( (unsigned int)(v83 - 192) <= 1 )
        _assert_fail(
          (__int64)"ch != 0xc0 && ch != 0xc1",
          (__int64)"../iconv/loop.c",
          0x1E1u,
          "utf8_internal_loop_single");
      if ( v85 > 0x1D )
      {
        if ( (v50 & 0xF0) == 0xE0 )
        {
          v68 = 768;
          v69 = 2;
          v70 = v50 & 0xF;
        }
        else if ( (v50 & 0xF8) == 0xF0 )
        {
          v68 = 1024;
          v69 = 3;
          v70 = v50 & 7;
        }
        else if ( (v50 & 0xFC) == 0xF8 )
        {
          v70 = v50 & 3;
          v68 = 1280;
          v69 = 4;
        }
        else
        {
          v70 = v50 & 1;
          v68 = 1536;
          v69 = 5;
        }
      }
      else
      {
        v68 = 512;
        v69 = 1;
        v70 = v50 & 0x1F;
      }
      if ( v81 > (__int64 *)&v89 )
      {
        v71 = &v89;
        do
        {
          v72 = *v71++;
          v70 = v72 & 0x3F | (v70 << 6);
        }
        while ( v81 != (__int64 *)v71 );
        v69 += (unsigned int)&v89 - (_DWORD)v81;
      }
      v30 = 7;
      *v42 = v68 | v43;
      v42[1] = v70 << (6 * v69);
      return v30;
    }
    if ( v81 == (__int64 *)&v89 )
      goto LABEL_149;
LABEL_131:
    if ( !v80 || (v10 & 2) == 0 )
      return 6;
    v51 = v64;
    v47 = v14;
    ++*v80;
    goto LABEL_72;
  }
  v51 = 1LL;
  *v14 = v88;
  v44 = *v42 & 7;
LABEL_72:
  if ( v44 >= v51 )
    _assert_fail(
      (__int64)"inptr - bytebuf > (state->__count & 7)",
      (__int64)"../iconv/loop.c",
      0x1C9u,
      "utf8_internal_loop_single");
  v10 = *(_DWORD *)(a2 + 16);
  v14 = v47;
  v12 += v51 - v44;
  *a3 = v12;
  *v42 = 0;
LABEL_10:
  v16 = v14;
  while ( 1 )
  {
    if ( (unsigned __int8 *)a4 == v12 )
    {
      v18 = (unsigned __int8 *)a4;
      v19 = v16;
      v82 = 4;
LABEL_30:
      *a3 = v18;
      if ( a5 )
      {
LABEL_38:
        v30 = v82;
        *a5 = v19;
        return v30;
      }
    }
    else
    {
      v17 = v16 + 1;
      v18 = v12;
      v19 = v16;
      if ( v11 >= (unsigned __int64)(v16 + 1) )
      {
        v82 = 4;
        v20 = v10 & 2;
        while ( 1 )
        {
          v21 = *v18;
          v22 = v18 + 1;
          v23 = *v18;
          if ( v21 <= 0x7F )
            goto LABEL_14;
          if ( v21 - 194 <= 0x1D )
            break;
          if ( (v23 & 0xF0) != 0xE0 )
          {
            if ( (v23 & 0xF8) == 0xF0 )
            {
              v24 = 4LL;
              v21 = v23 & 7;
            }
            else if ( (v23 & 0xFC) == 0xF8 )
            {
              v24 = 5LL;
              v21 = v23 & 3;
            }
            else
            {
              if ( (v23 & 0xFE) != 0xFC )
              {
                v26 = 0LL;
                do
                  ++v26;
                while ( a4 > (unsigned __int64)&v18[v26] && (v18[v26] & 0xC0) == 0x80 && v26 != 5 );
                goto LABEL_27;
              }
              v24 = 6LL;
              v21 = v23 & 1;
            }
            goto LABEL_19;
          }
          v24 = 3LL;
          v26 = 1LL;
          v25 = v18 + 3;
          v21 = v23 & 0xF;
          if ( a4 >= (unsigned __int64)(v18 + 3) )
          {
            do
            {
LABEL_20:
              v27 = v18[v26];
              if ( (v27 & 0xC0) != 0x80 )
                goto LABEL_27;
              ++v26;
              v21 = v27 & 0x3F | (v21 << 6);
            }
            while ( v24 != v26 );
            if ( (v26 == 2 || v21 >> (5 * v26 - 4)) && v21 - 55296 > 0x7FF )
            {
              v22 = v25;
LABEL_14:
              v18 = v22;
              *v19 = v21;
              v19 = v17;
              if ( (unsigned __int8 *)a4 == v22 )
                goto LABEL_30;
              goto LABEL_15;
            }
            goto LABEL_27;
          }
LABEL_42:
          if ( a4 <= (unsigned __int64)v22 )
          {
            v32 = 1LL;
LABEL_47:
            if ( (unsigned __int8 *)a4 == v22 )
            {
              v82 = 7;
              goto LABEL_30;
            }
            v26 = v32;
            goto LABEL_27;
          }
          if ( (v18[1] & 0xC0) == 0x80 )
          {
            v32 = a4 - (_QWORD)v18;
            do
            {
              v22 = &v18[++v26];
              if ( v26 == v32 )
                goto LABEL_47;
            }
            while ( (v18[v26] & 0xC0) == 0x80 );
          }
LABEL_27:
          if ( !v80 || !v20 )
          {
            v82 = 6;
            goto LABEL_30;
          }
          v18 += v26;
          ++*v80;
          v82 = 6;
          if ( (unsigned __int8 *)a4 == v18 )
            goto LABEL_30;
LABEL_15:
          v17 = v19 + 1;
          if ( v11 < (unsigned __int64)(v19 + 1) )
            goto LABEL_37;
        }
        v24 = 2LL;
        v21 = v23 & 0x1F;
LABEL_19:
        v25 = &v18[v24];
        v26 = 1LL;
        if ( a4 >= (unsigned __int64)&v18[v24] )
          goto LABEL_20;
        goto LABEL_42;
      }
LABEL_37:
      v82 = 5;
      *a3 = v18;
      if ( a5 )
        goto LABEL_38;
    }
    ++*(_DWORD *)(a2 + 20);
    if ( (*(_BYTE *)(a2 + 16) & 1) != 0 )
    {
      v52 = v86;
      v30 = v82;
      *(_QWORD *)a2 = v19;
      *a6 += v52;
      goto LABEL_51;
    }
    if ( v16 >= v19 )
      goto LABEL_50;
    *(_QWORD *)v87 = *(_QWORD *)a2;
    dl_mcount_wrapper_check((__int64)v74);
    v28 = v74(v77, v78, v87, v19, 0LL, a6, 0LL);
    if ( v28 == 4 )
      break;
    v29 = *(_QWORD *)v87;
    if ( *(unsigned int **)v87 == v19 )
      goto LABEL_35;
    v53 = *(_DWORD *)(a2 + 16);
    *a3 = v12;
    if ( (unsigned __int8 *)a4 == v12 )
      goto LABEL_96;
    v54 = v16 + 1;
    if ( v29 < (unsigned __int64)(v16 + 1) )
    {
      if ( (unsigned int *)v29 == v16 )
        goto LABEL_112;
      goto LABEL_97;
    }
    v55 = v16;
    v84 = v53 & 2;
    do
    {
      v56 = *v12;
      v57 = v12 + 1;
      v58 = *v12;
      if ( v56 <= 0x7F )
        goto LABEL_78;
      if ( v56 - 194 > 0x1D )
      {
        if ( (v58 & 0xF0) == 0xE0 )
        {
          v59 = 3LL;
          v56 = v58 & 0xF;
        }
        else if ( (v58 & 0xF8) == 0xF0 )
        {
          v59 = 4LL;
          v56 = v58 & 7;
        }
        else if ( (v58 & 0xFC) == 0xF8 )
        {
          v59 = 5LL;
          v56 = v58 & 3;
        }
        else
        {
          if ( (v58 & 0xFE) != 0xFC )
          {
            v60 = 0LL;
            do
              ++v60;
            while ( a4 > (unsigned __int64)&v12[v60] && (v12[v60] & 0xC0) == 0x80 && v60 != 5 );
            goto LABEL_93;
          }
          v59 = 6LL;
          v56 = v58 & 1;
        }
      }
      else
      {
        v59 = 2LL;
        v56 = v58 & 0x1F;
      }
      v60 = 1LL;
      if ( a4 < (unsigned __int64)&v12[v59] )
      {
        if ( a4 <= (unsigned __int64)v57 )
          goto LABEL_128;
        if ( (v12[1] & 0xC0) == 0x80 )
        {
          v62 = 1LL;
          v60 = a4 - (_QWORD)v12;
          while ( 1 )
          {
            v57 = &v12[++v62];
            if ( v62 == v60 )
              break;
            if ( (v12[v62] & 0xC0) != 0x80 )
              goto LABEL_92;
          }
LABEL_128:
          if ( v57 == (unsigned __int8 *)a4 )
            goto LABEL_95;
          goto LABEL_93;
        }
        v62 = 1LL;
LABEL_92:
        v60 = v62;
      }
      else
      {
        do
        {
          v61 = v12[v60];
          if ( (v61 & 0xC0) != 0x80 )
            goto LABEL_93;
          ++v60;
          v56 = v61 & 0x3F | (v56 << 6);
        }
        while ( v59 != v60 );
        if ( (v60 == 2 || v56 >> (5 * v60 - 4)) && v56 - 55296 > 0x7FF )
        {
          v57 = &v12[v59];
LABEL_78:
          *v55 = v56;
          v12 = v57;
          v55 = v54;
          goto LABEL_79;
        }
      }
LABEL_93:
      if ( !v80 || !v84 )
      {
LABEL_95:
        v16 = v55;
LABEL_96:
        *a3 = v12;
        if ( (unsigned int *)v29 == v16 )
          _assert_fail(
            (__int64)"nstatus == __GCONV_FULL_OUTPUT",
            (__int64)"../iconv/skeleton.c",
            0x2D8u,
            "__gconv_transform_utf8_internal");
LABEL_97:
        _assert_fail(
          (__int64)"outbuf == outerr",
          (__int64)"../iconv/skeleton.c",
          0x2D7u,
          "__gconv_transform_utf8_internal");
      }
      v12 += v60;
      ++*v80;
LABEL_79:
      if ( (unsigned __int8 *)a4 == v12 )
        goto LABEL_95;
      v54 = v55 + 1;
    }
    while ( v29 >= (unsigned __int64)(v55 + 1) );
    *a3 = v12;
    if ( (unsigned int *)v29 != v55 )
      goto LABEL_97;
    if ( (unsigned int *)v29 == v16 )
LABEL_112:
      --*(_DWORD *)(a2 + 20);
LABEL_35:
    if ( v28 )
    {
      v30 = v28;
      goto LABEL_51;
    }
LABEL_36:
    v10 = *(_DWORD *)(a2 + 16);
    v16 = *(unsigned int **)a2;
    v12 = *a3;
  }
  if ( v82 == 5 )
    goto LABEL_36;
LABEL_50:
  v30 = v82;
LABEL_51:
  if ( a8 && v30 == 7 )
  {
    v33 = *(_DWORD **)(a2 + 32);
    v34 = *a3;
    v35 = **a3;
    v36 = a4 - (_QWORD)*a3;
    *v33 = v36;
    if ( (unsigned int)(v35 - 192) <= 1 )
      _assert_fail(
        (__int64)"ch != 0xc0 && ch != 0xc1",
        (__int64)"../iconv/skeleton.c",
        0x305u,
        "__gconv_transform_utf8_internal");
    if ( (unsigned int)(v35 - 194) > 0x1D )
    {
      if ( (v35 & 0xF0) == 0xE0 )
      {
        v37 = v35 & 0xF;
        v38 = 2;
        v39 = 768;
      }
      else if ( (v35 & 0xF8) == 0xF0 )
      {
        v37 = v35 & 7;
        v38 = 3;
        v39 = 1024;
      }
      else if ( (v35 & 0xFC) == 0xF8 )
      {
        v37 = v35 & 3;
        v38 = 4;
        v39 = 1280;
      }
      else
      {
        v37 = v35 & 1;
        v38 = 5;
        v39 = 1536;
      }
    }
    else
    {
      v37 = v35 & 0x1F;
      v38 = 1;
      v39 = 512;
    }
    v40 = v34 + 1;
    *a3 = v34 + 1;
    if ( a4 > (unsigned __int64)(v34 + 1) )
    {
      do
      {
        v41 = *v40++;
        *a3 = v40;
        v37 = v41 & 0x3F | (v37 << 6);
      }
      while ( v40 != (unsigned __int8 *)a4 );
      v38 += (_BYTE)v34 - (_BYTE)v40 + 1;
    }
    *v33 = v36 | v39;
    v33[1] = v37 << (6 * v38);
  }
  return v30;
}
// 484E35: using guessed type _BYTE inmask_11790[5];

//----- (0000000000447B00) ----------------------------------------------------
__int64 __fastcall _gconv_transform_ucs2_internal(
        __int64 a1,
        __int64 a2,
        unsigned __int64 *a3,
        unsigned __int64 a4,
        char **a5,
        _QWORD *a6,
        unsigned int a7,
        unsigned int a8)
{
  __int64 (__fastcall *v9)(__int64, __int64, void **, char *, _QWORD, _QWORD *, _QWORD, _QWORD); // r15
  int v13; // ecx
  char **v14; // rax
  __int64 *v15; // rsi
  _BYTE *v16; // rdx
  unsigned __int64 v17; // r11
  char *v18; // rax
  __int64 (__fastcall *v19)(__int64, __int64, void **, char *, _QWORD, _QWORD *, _QWORD, _QWORD); // r13
  unsigned __int64 v20; // r15
  unsigned __int64 v21; // rsi
  char *v22; // rdi
  char *v23; // rbx
  int v24; // er10
  int v25; // ecx
  int v26; // edx
  unsigned int v27; // eax
  unsigned int v28; // er13
  unsigned __int64 v30; // rsi
  unsigned int *v31; // rdi
  unsigned __int64 v32; // rax
  _BYTE *v33; // rdx
  unsigned int *v34; // rsi
  unsigned int v35; // ebx
  int v36; // er13
  _BYTE *v37; // r8
  __int64 v38; // rdi
  __int64 v39; // rax
  unsigned __int64 v40; // rcx
  _BYTE *v41; // rdx
  unsigned __int64 v42; // rcx
  char v43; // al
  int v44; // eax
  int v45; // [rsp+Ch] [rbp-8Ch]
  char **v46; // [rsp+10h] [rbp-88h]
  __int64 v48; // [rsp+20h] [rbp-78h]
  __int64 v49; // [rsp+28h] [rbp-70h]
  __int64 *v50; // [rsp+38h] [rbp-60h]
  __int64 v51; // [rsp+40h] [rbp-58h] BYREF
  void *v52; // [rsp+48h] [rbp-50h] BYREF
  unsigned __int16 v53; // [rsp+56h] [rbp-42h]
  unsigned __int64 v54; // [rsp+58h] [rbp-40h]

  v9 = 0LL;
  v13 = *(_DWORD *)(a2 + 16);
  v54 = __readfsqword(0x28u);
  v48 = a1 + 104;
  v49 = a2 + 48;
  if ( (v13 & 1) == 0 )
  {
    v9 = *(__int64 (__fastcall **)(__int64, __int64, void **, char *, _QWORD, _QWORD *, _QWORD, _QWORD))(a1 + 144);
    if ( *(_QWORD *)(a1 + 104) )
      v9 = (__int64 (__fastcall *)(__int64, __int64, void **, char *, _QWORD, _QWORD *, _QWORD, _QWORD))(__readfsqword(0x30u) ^ __ROR8__(v9, 17));
  }
  if ( a7 )
  {
    if ( a5 )
      _assert_fail(
        (__int64)"outbufstart == NULL",
        (__int64)"../iconv/skeleton.c",
        0x19Fu,
        "__gconv_transform_ucs2_internal");
    v28 = 0;
    **(_QWORD **)(a2 + 32) = 0LL;
    if ( (*(_BYTE *)(a2 + 16) & 1) == 0 )
    {
      dl_mcount_wrapper_check((__int64)v9);
      return (unsigned int)v9(v48, v49, 0LL, 0LL, 0LL, a6, a7, a8);
    }
    return v28;
  }
  v14 = a5;
  v15 = 0LL;
  if ( !a5 )
    v14 = (char **)a2;
  v16 = (_BYTE *)*a3;
  if ( a6 )
    v15 = &v51;
  v17 = *(_QWORD *)(a2 + 8);
  v18 = *v14;
  v51 = 0LL;
  v50 = v15;
  if ( a8 )
  {
    v34 = *(unsigned int **)(a2 + 32);
    v35 = *v34;
    v36 = *v34 & 7;
    if ( v36 )
    {
      if ( a5 )
        _assert_fail(
          (__int64)"outbufstart == NULL",
          (__int64)"../iconv/skeleton.c",
          0x22Fu,
          "__gconv_transform_ucs2_internal");
      if ( (unsigned int)v36 > 4 )
        _assert_fail(
          (__int64)"(state->__count & 7) <= sizeof (state->__value)",
          (__int64)"../iconv/loop.c",
          0x18Bu,
          "ucs2_internal_loop_single");
      LOBYTE(v53) = *((_BYTE *)v34 + 4);
      if ( v36 == 1 )
      {
        v37 = v16 + 1;
        v38 = 1LL;
      }
      else
      {
        v37 = v16;
        HIBYTE(v53) = *((_BYTE *)v34 + 5);
        v38 = 2LL;
      }
      if ( a4 < (unsigned __int64)v37 )
      {
        *a3 = a4;
        if ( (unsigned __int64)v16 < a4 )
        {
          v40 = a4 - (_QWORD)v16;
          v41 = &v16[-v38];
          v42 = v38 + v40;
          do
          {
            v43 = v41[v38++];
            *((_BYTE *)v34 + v38 + 3) = v43;
          }
          while ( v42 != v38 );
        }
        return 7;
      }
      if ( v17 < (unsigned __int64)(v18 + 4) )
        return 5;
      *((_BYTE *)&v53 + v38) = *v16;
      if ( (unsigned __int16)(v53 + 10240) <= 0x7FFu )
      {
        if ( !v50 || (v13 & 2) == 0 )
          return 6;
        ++*v50;
      }
      else
      {
        *(_DWORD *)v18 = v53;
        v35 = *v34;
        v18 += 4;
        v36 = *v34 & 7;
      }
      if ( (v35 & 6) != 0 )
        _assert_fail(
          (__int64)"inptr - bytebuf > (state->__count & 7)",
          (__int64)"../iconv/loop.c",
          0x1C9u,
          "ucs2_internal_loop_single");
      v13 = *(_DWORD *)(a2 + 16);
      v16 = &v16[-v36 + 2];
      *a3 = (unsigned __int64)v16;
      *v34 = v35 & 0xFFFFFFF8;
    }
  }
  v46 = a5;
  v19 = v9;
  v20 = v17;
  while ( 1 )
  {
    if ( (_BYTE *)a4 == v16 )
    {
      v23 = v18;
      v21 = a4;
      v24 = 4;
    }
    else
    {
      v21 = (unsigned __int64)(v16 + 2);
      if ( a4 < (unsigned __int64)(v16 + 2) )
      {
        v23 = v18;
        v21 = (unsigned __int64)v16;
        v24 = 7;
      }
      else
      {
        v22 = v18 + 4;
        v23 = v18;
        if ( v20 >= (unsigned __int64)(v18 + 4) )
        {
          v24 = 4;
          v25 = v13 & 2;
          while ( 1 )
          {
            v26 = *(unsigned __int16 *)(v21 - 2);
            if ( (unsigned __int16)(v26 + 10240) <= 0x7FFu )
            {
              if ( !v50 || !v25 )
              {
                v21 -= 2LL;
                v24 = 6;
                goto LABEL_22;
              }
              ++*v50;
              v24 = 6;
            }
            else
            {
              *(_DWORD *)v23 = v26;
              v23 = v22;
            }
            if ( v21 == a4 )
              goto LABEL_22;
            if ( a4 < v21 + 2 )
              break;
            v22 = v23 + 4;
            if ( v20 < (unsigned __int64)(v23 + 4) )
            {
              v24 = 5;
              goto LABEL_22;
            }
            v21 += 2LL;
          }
          v24 = 7;
          *a3 = v21;
          if ( !v46 )
            goto LABEL_23;
LABEL_34:
          v28 = v24;
          *v46 = v23;
          return v28;
        }
        v21 = (unsigned __int64)v16;
        v24 = 5;
      }
    }
LABEL_22:
    *a3 = v21;
    if ( v46 )
      goto LABEL_34;
LABEL_23:
    ++*(_DWORD *)(a2 + 20);
    if ( (*(_BYTE *)(a2 + 16) & 1) != 0 )
    {
      v39 = v51;
      *(_QWORD *)a2 = v23;
      v28 = v24;
      *a6 += v39;
      goto LABEL_39;
    }
    if ( v23 <= v18 )
      goto LABEL_38;
    v45 = v24;
    v52 = *(void **)a2;
    dl_mcount_wrapper_check((__int64)v19);
    v27 = v19(v48, v49, &v52, v23, 0LL, a6, 0LL, a8);
    v24 = v45;
    if ( v27 != 4 )
      break;
    if ( v45 != 5 )
    {
LABEL_38:
      v28 = v24;
      goto LABEL_39;
    }
LABEL_29:
    v16 = (_BYTE *)*a3;
    v13 = *(_DWORD *)(a2 + 16);
    v18 = *(char **)a2;
  }
  if ( v52 != v23 )
    *a3 -= (v23 - (_BYTE *)v52) / 2;
  if ( !v27 )
    goto LABEL_29;
  v28 = v27;
LABEL_39:
  if ( a8 && v28 == 7 )
  {
    v30 = *a3;
    if ( (__int64)(a4 - *a3) > 3 )
      _assert_fail(
        (__int64)"inend - *inptrp < 4",
        (__int64)"../iconv/skeleton.c",
        0x309u,
        "__gconv_transform_ucs2_internal");
    v31 = *(unsigned int **)(a2 + 32);
    v32 = v30 + 1;
    v33 = v31 + 1;
    if ( v30 >= a4 )
    {
      v44 = 0;
    }
    else
    {
      while ( 1 )
      {
        *a3 = v32;
        *v33++ = *(_BYTE *)(v32 - 1);
        if ( v32 == a4 )
          break;
        ++v32;
      }
      v44 = v32 - v30;
    }
    *v31 = *v31 & 0xFFFFFFF8 | v44;
  }
  return v28;
}
// 447B00: using guessed type void *var_50;

//----- (0000000000448090) ----------------------------------------------------
__int64 __fastcall _gconv_transform_internal_ucs2(
        _QWORD *a1,
        __int64 a2,
        unsigned int **a3,
        unsigned __int64 a4,
        _QWORD *a5,
        _QWORD *a6,
        unsigned int a7,
        unsigned int a8)
{
  __int64 *v8; // r11
  int v11; // er14
  unsigned int *v12; // rdx
  unsigned __int64 v13; // r15
  _QWORD *v14; // rax
  _WORD *v15; // r13
  __int64 *v16; // rax
  _WORD *v17; // rbx
  int v18; // er14
  int v19; // eax
  unsigned int *v20; // rcx
  _WORD *v21; // rdi
  unsigned int v22; // esi
  unsigned int v23; // er10
  unsigned int v25; // eax
  unsigned int *v26; // rbx
  unsigned int v27; // esi
  __int64 v28; // rcx
  __int64 v29; // rax
  unsigned int *v30; // rax
  unsigned __int64 v31; // rdi
  __int64 v32; // rdx
  __int64 v33; // rax
  unsigned __int64 v34; // rsi
  unsigned int *v35; // rdi
  __int64 v36; // rax
  _BYTE *v37; // rdx
  char *v38; // rax
  unsigned int *v39; // rdx
  int v40; // ebp
  signed int v41; // eax
  unsigned int *v42; // rax
  _DWORD *v43; // rdx
  __int64 *v45; // [rsp+10h] [rbp-B8h]
  __int64 *v46; // [rsp+10h] [rbp-B8h]
  unsigned int v47; // [rsp+18h] [rbp-B0h]
  unsigned int (__fastcall *v49)(_QWORD *, __int64, _DWORD *, _WORD *, _QWORD, _QWORD *, _QWORD, _QWORD); // [rsp+28h] [rbp-A0h]
  __int64 *v50; // [rsp+30h] [rbp-98h]
  _QWORD *v51; // [rsp+38h] [rbp-90h]
  __int64 v52; // [rsp+40h] [rbp-88h]
  __int64 *v53; // [rsp+48h] [rbp-80h]
  __int64 *v55; // [rsp+58h] [rbp-70h]
  __int64 v56; // [rsp+68h] [rbp-60h] BYREF
  unsigned int *v57; // [rsp+70h] [rbp-58h] BYREF
  _DWORD v58[3]; // [rsp+78h] [rbp-50h] BYREF
  unsigned int v59; // [rsp+84h] [rbp-44h] BYREF
  __int64 v60[8]; // [rsp+88h] [rbp-40h] BYREF

  v8 = (__int64 *)a3;
  v11 = *(_DWORD *)(a2 + 16);
  v60[0] = __readfsqword(0x28u);
  v49 = 0LL;
  v51 = a1 + 13;
  v52 = a2 + 48;
  if ( (v11 & 1) == 0 )
  {
    v49 = (unsigned int (__fastcall *)(_QWORD *, __int64, _DWORD *, _WORD *, _QWORD, _QWORD *, _QWORD, _QWORD))a1[18];
    if ( a1[13] )
      v49 = (unsigned int (__fastcall *)(_QWORD *, __int64, _DWORD *, _WORD *, _QWORD, _QWORD *, _QWORD, _QWORD))(__readfsqword(0x30u) ^ __ROR8__(a1[18], 17));
  }
  if ( a7 )
  {
    if ( a5 )
      _assert_fail(
        (__int64)"outbufstart == NULL",
        (__int64)"../iconv/skeleton.c",
        0x19Fu,
        "__gconv_transform_internal_ucs2");
    v23 = 0;
    **(_QWORD **)(a2 + 32) = 0LL;
    if ( (*(_BYTE *)(a2 + 16) & 1) == 0 )
    {
      dl_mcount_wrapper_check((__int64)v49);
      return v49(v51, v52, 0LL, 0LL, 0LL, a6, a7, a8);
    }
    return v23;
  }
  v12 = *a3;
  v13 = *(_QWORD *)(a2 + 8);
  v14 = a5;
  if ( !a5 )
    v14 = (_QWORD *)a2;
  v15 = (_WORD *)*v14;
  v16 = 0LL;
  v56 = 0LL;
  if ( a6 )
    v16 = &v56;
  v53 = v16;
  if ( !a8 )
    goto LABEL_10;
  v26 = *(unsigned int **)(a2 + 32);
  v27 = *v26;
  LODWORD(v28) = *v26 & 7;
  if ( !(_DWORD)v28 )
    goto LABEL_10;
  if ( a5 )
    _assert_fail(
      (__int64)"outbufstart == NULL",
      (__int64)"../iconv/skeleton.c",
      0x22Fu,
      "__gconv_transform_internal_ucs2");
  v57 = v12;
  *(_QWORD *)v58 = v15;
  if ( (unsigned int)v28 > 4 )
    _assert_fail(
      (__int64)"(state->__count & 7) <= sizeof (state->__value)",
      (__int64)"../iconv/loop.c",
      0x18Bu,
      "internal_ucs2_loop_single");
  v28 = (int)v28;
  v29 = 0LL;
  do
  {
    *((_BYTE *)&v59 + v29) = *((_BYTE *)v26 + v29 + 4);
    ++v29;
  }
  while ( v29 != (int)v28 );
  if ( a4 < (unsigned __int64)v12 - v29 + 4 )
  {
    *v8 = a4;
    if ( (unsigned __int64)v12 < a4 )
    {
      v38 = (char *)v26 + v29;
      do
      {
        v12 = (unsigned int *)((char *)v12 + 1);
        ++v38;
        v57 = v12;
        v38[3] = *((_BYTE *)v12 - 1);
      }
      while ( (unsigned int *)a4 != v12 );
    }
    return 7;
  }
  v30 = v12;
  v23 = 5;
  if ( v13 < (unsigned __int64)(v15 + 1) )
    return v23;
  v31 = (int)v28;
  do
  {
    v30 = (unsigned int *)((char *)v30 + 1);
    ++v31;
    v57 = v30;
    *((_BYTE *)&v58[2] + v31 + 3) = *((_BYTE *)v30 - 1);
  }
  while ( v31 <= 3 && a4 > (unsigned __int64)v30 );
  v57 = &v59;
  if ( v59 <= 0xFFFF )
  {
    if ( v59 - 55296 > 0x7FF )
    {
      *v15 = v59;
      *(_QWORD *)v58 = v15 + 1;
LABEL_54:
      v32 = 4LL;
      v57 = (unsigned int *)v60;
LABEL_55:
      if ( v28 >= v32 )
        _assert_fail(
          (__int64)"inptr - bytebuf > (state->__count & 7)",
          (__int64)"../iconv/loop.c",
          0x1C9u,
          "internal_ucs2_loop_single");
      v12 = (unsigned int *)(*v8 + v32 - v28);
      v15 = *(_WORD **)v58;
      *v8 = (__int64)v12;
      v11 = *(_DWORD *)(a2 + 16);
      *v26 = v27 & 0xFFFFFFF8;
      goto LABEL_10;
    }
    if ( v53 && (v11 & 2) != 0 )
    {
      v32 = 4LL;
      v57 = (unsigned int *)v60;
      ++*v53;
      goto LABEL_55;
    }
    return 6;
  }
  if ( v59 >> 7 == 7168 )
    goto LABEL_54;
  if ( !v53 )
    return 6;
  if ( (v11 & 8) == 0 )
  {
    v23 = 6;
    v39 = &v59;
    if ( (v11 & 2) == 0 )
      return v23;
    goto LABEL_81;
  }
  v55 = v8;
  v50 = (__int64 *)((char *)&v59 + v31);
  v23 = _gconv_transliterate(a1, a2, (__int64)v12, &v57, (unsigned __int64)&v59 + v31, (__int64 *)v58, v53);
  v39 = v57;
  v8 = v55;
  if ( v23 == 6 )
  {
    if ( (v11 & 2) == 0 )
    {
LABEL_82:
      if ( v39 == &v59 )
        return 6;
LABEL_83:
      v27 = *v26;
      v32 = (char *)v39 - (char *)&v59;
      v28 = *v26 & 7;
      goto LABEL_55;
    }
LABEL_81:
    v57 = ++v39;
    ++*v53;
    goto LABEL_82;
  }
  if ( v57 != &v59 )
    goto LABEL_83;
  if ( v23 == 7 )
  {
    if ( v50 == v60 )
      _assert_fail(
        (__int64)"inend != &bytebuf[MAX_NEEDED_INPUT]",
        (__int64)"../iconv/loop.c",
        0x1DBu,
        "internal_ucs2_loop_single");
    v41 = *v26 & 0xFFFFFFF8;
    *v55 += v31 - (*v26 & 7);
    if ( v41 >= (__int64)v31 )
      _assert_fail(
        (__int64)"inend - inptr > (state->__count & ~7)",
        (__int64)"../iconv/loop.c",
        0x1E5u,
        "internal_ucs2_loop_single");
    if ( v31 > 4 )
      _assert_fail(
        (__int64)"inend - inptr <= sizeof (state->__value)",
        (__int64)"../iconv/loop.c",
        0x1E6u,
        "internal_ucs2_loop_single");
    *v26 = v31 | v41;
    v42 = &v59;
    if ( v50 > (__int64 *)&v59 )
    {
      v43 = v26 + 1;
      do
      {
        v42 = (unsigned int *)((char *)v42 + 1);
        v43 = (_DWORD *)((char *)v43 + 1);
        v57 = v42;
        *((_BYTE *)v43 - 1) = *((_BYTE *)v42 - 1);
      }
      while ( v50 != (__int64 *)v42 );
    }
    return 7;
  }
  if ( v23 )
    return v23;
  v12 = (unsigned int *)*v55;
  v11 = *(_DWORD *)(a2 + 16);
  while ( 1 )
  {
LABEL_10:
    v57 = v12;
    v17 = v15;
    v18 = v11 & 2;
    *(_QWORD *)v58 = v15;
    v19 = 4;
LABEL_11:
    if ( (unsigned int *)a4 != v12 )
    {
      while ( 1 )
      {
        v20 = v12 + 1;
        if ( a4 < (unsigned __int64)(v12 + 1) )
        {
          v23 = 7;
          goto LABEL_21;
        }
        v21 = v17 + 1;
        if ( v13 < (unsigned __int64)(v17 + 1) )
          break;
        v22 = *v12;
        if ( *v12 > 0xFFFF )
        {
          if ( v22 >> 7 == 7168 )
          {
            v57 = ++v12;
            goto LABEL_11;
          }
          if ( v53 )
          {
            if ( (*(_BYTE *)(a2 + 16) & 8) != 0 )
            {
              v46 = v8;
              v19 = _gconv_transliterate(a1, a2, *v8, &v57, a4, (__int64 *)v58, v53);
              v12 = v57;
              v17 = *(_WORD **)v58;
              v8 = v46;
              if ( v19 != 6 )
              {
                if ( v19 != 5 )
                  goto LABEL_11;
                goto LABEL_17;
              }
            }
            if ( v18 )
            {
              v57 = ++v12;
              ++*v53;
              v19 = 6;
              goto LABEL_11;
            }
          }
LABEL_34:
          v23 = 6;
LABEL_21:
          *v8 = (__int64)v12;
          if ( a5 )
            goto LABEL_18;
          goto LABEL_22;
        }
        if ( v22 - 55296 <= 0x7FF )
        {
          if ( v53 && v18 )
          {
            ++*v53;
            ++v12;
            v19 = 6;
            v57 = v20;
            goto LABEL_11;
          }
          goto LABEL_34;
        }
        ++v12;
        *v17++ = v22;
        *(_QWORD *)v58 = v21;
        v57 = v20;
        if ( (unsigned int *)a4 == v20 )
          goto LABEL_17;
      }
      v23 = 5;
      goto LABEL_21;
    }
LABEL_17:
    v23 = v19;
    *v8 = (__int64)v12;
    if ( a5 )
    {
LABEL_18:
      *a5 = v17;
      return v23;
    }
LABEL_22:
    ++*(_DWORD *)(a2 + 20);
    if ( (*(_BYTE *)(a2 + 16) & 1) != 0 )
      break;
    if ( v17 <= v15 )
    {
      v25 = v23;
      goto LABEL_27;
    }
    v47 = v23;
    v45 = v8;
    *(_QWORD *)v58 = *(_QWORD *)a2;
    dl_mcount_wrapper_check((__int64)v49);
    v25 = v49(v51, v52, v58, v17, 0LL, a6, 0LL, a8);
    v8 = v45;
    if ( v25 != 4 )
    {
      if ( v17 != *(_WORD **)v58 )
        *v45 -= 2LL * ((_QWORD)v17 - *(_QWORD *)v58);
LABEL_27:
      if ( v25 )
        goto LABEL_40;
      goto LABEL_28;
    }
    v25 = v47;
    if ( v47 != 5 && v47 )
    {
LABEL_40:
      v23 = v25;
      goto LABEL_59;
    }
LABEL_28:
    v12 = (unsigned int *)*v8;
    v11 = *(_DWORD *)(a2 + 16);
    v15 = *(_WORD **)a2;
  }
  v33 = v56;
  *(_QWORD *)a2 = v17;
  *a6 += v33;
LABEL_59:
  if ( v23 == 7 && a8 )
  {
    v34 = *v8;
    if ( (__int64)(a4 - *v8) > 3 )
      _assert_fail(
        (__int64)"inend - *inptrp < 4",
        (__int64)"../iconv/skeleton.c",
        0x309u,
        "__gconv_transform_internal_ucs2");
    v35 = *(unsigned int **)(a2 + 32);
    v36 = v34 + 1;
    v37 = v35 + 1;
    if ( v34 >= a4 )
    {
      v40 = 0;
    }
    else
    {
      while ( 1 )
      {
        *v8 = v36;
        *v37++ = *(_BYTE *)(v36 - 1);
        if ( a4 == v36 )
          break;
        ++v36;
      }
      v40 = a4 - v34;
    }
    *v35 = v40 | *v35 & 0xFFFFFFF8;
  }
  return v23;
}

//----- (0000000000448920) ----------------------------------------------------
__int64 __fastcall _gconv_transform_ucs2reverse_internal(
        __int64 a1,
        __int64 a2,
        unsigned __int64 *a3,
        unsigned __int64 a4,
        char **a5,
        _QWORD *a6,
        unsigned int a7,
        unsigned int a8)
{
  __int64 (__fastcall *v9)(__int64, __int64, void **, char *, _QWORD, _QWORD *, _QWORD, _QWORD); // r14
  int v13; // ecx
  char **v14; // rax
  __int64 *v15; // rsi
  _BYTE *v16; // rdx
  unsigned __int64 v17; // r11
  char *v18; // rax
  __int64 (__fastcall *v19)(__int64, __int64, void **, char *, _QWORD, _QWORD *, _QWORD, _QWORD); // r15
  unsigned __int64 v20; // r14
  unsigned __int64 v21; // rsi
  char *v22; // rdi
  char *v23; // rbx
  int v24; // ecx
  unsigned __int16 v25; // dx
  unsigned int v26; // er10
  unsigned int v27; // eax
  unsigned __int64 v29; // rsi
  unsigned int *v30; // rdi
  unsigned __int64 v31; // rax
  _BYTE *v32; // rdx
  unsigned int *v33; // rdi
  unsigned int v34; // er10
  int v35; // ebx
  _BYTE *v36; // r8
  __int64 v37; // rsi
  unsigned __int16 v38; // si
  __int64 v39; // rax
  unsigned __int64 v40; // rcx
  _BYTE *v41; // rdx
  unsigned __int64 v42; // rcx
  char v43; // al
  int v44; // ebp
  unsigned int v45; // [rsp+Ch] [rbp-8Ch]
  char **v46; // [rsp+10h] [rbp-88h]
  __int64 v48; // [rsp+20h] [rbp-78h]
  __int64 v49; // [rsp+28h] [rbp-70h]
  __int64 *v50; // [rsp+38h] [rbp-60h]
  __int64 v51; // [rsp+40h] [rbp-58h] BYREF
  void *v52; // [rsp+48h] [rbp-50h] BYREF
  __int16 v53; // [rsp+56h] [rbp-42h]
  unsigned __int64 v54; // [rsp+58h] [rbp-40h]

  v9 = 0LL;
  v13 = *(_DWORD *)(a2 + 16);
  v54 = __readfsqword(0x28u);
  v48 = a1 + 104;
  v49 = a2 + 48;
  if ( (v13 & 1) == 0 )
  {
    v9 = *(__int64 (__fastcall **)(__int64, __int64, void **, char *, _QWORD, _QWORD *, _QWORD, _QWORD))(a1 + 144);
    if ( *(_QWORD *)(a1 + 104) )
      v9 = (__int64 (__fastcall *)(__int64, __int64, void **, char *, _QWORD, _QWORD *, _QWORD, _QWORD))(__readfsqword(0x30u) ^ __ROR8__(v9, 17));
  }
  if ( a7 )
  {
    if ( a5 )
      _assert_fail(
        (__int64)"outbufstart == NULL",
        (__int64)"../iconv/skeleton.c",
        0x19Fu,
        "__gconv_transform_ucs2reverse_internal");
    v26 = 0;
    **(_QWORD **)(a2 + 32) = 0LL;
    if ( (*(_BYTE *)(a2 + 16) & 1) == 0 )
    {
      dl_mcount_wrapper_check((__int64)v9);
      return (unsigned int)v9(v48, v49, 0LL, 0LL, 0LL, a6, a7, a8);
    }
    return v26;
  }
  v14 = a5;
  v15 = 0LL;
  if ( !a5 )
    v14 = (char **)a2;
  v16 = (_BYTE *)*a3;
  if ( a6 )
    v15 = &v51;
  v17 = *(_QWORD *)(a2 + 8);
  v18 = *v14;
  v51 = 0LL;
  v50 = v15;
  if ( a8 )
  {
    v33 = *(unsigned int **)(a2 + 32);
    v34 = *v33;
    v35 = *v33 & 7;
    if ( v35 )
    {
      if ( a5 )
        _assert_fail(
          (__int64)"outbufstart == NULL",
          (__int64)"../iconv/skeleton.c",
          0x22Fu,
          "__gconv_transform_ucs2reverse_internal");
      if ( (unsigned int)v35 > 4 )
        _assert_fail(
          (__int64)"(state->__count & 7) <= sizeof (state->__value)",
          (__int64)"../iconv/loop.c",
          0x18Bu,
          "ucs2reverse_internal_loop_single");
      LOBYTE(v53) = *((_BYTE *)v33 + 4);
      if ( v35 == 1 )
      {
        v36 = v16 + 1;
        v37 = 1LL;
      }
      else
      {
        v36 = v16;
        HIBYTE(v53) = *((_BYTE *)v33 + 5);
        v37 = 2LL;
      }
      if ( a4 < (unsigned __int64)v36 )
      {
        *a3 = a4;
        if ( (unsigned __int64)v16 < a4 )
        {
          v40 = a4 - (_QWORD)v16;
          v41 = &v16[-v37];
          v42 = v37 + v40;
          do
          {
            v43 = v41[v37++];
            *((_BYTE *)v33 + v37 + 3) = v43;
          }
          while ( v42 != v37 );
        }
        return 7;
      }
      if ( v17 < (unsigned __int64)(v18 + 4) )
        return 5;
      *((_BYTE *)&v53 + v37) = *v16;
      v38 = __ROL2__(v53, 8);
      if ( (unsigned __int16)(v38 + 10240) <= 0x7FFu )
      {
        if ( !v50 || (v13 & 2) == 0 )
          return 6;
        ++*v50;
      }
      else
      {
        *(_DWORD *)v18 = v38;
        v34 = *v33;
        v18 += 4;
        v35 = *v33 & 7;
      }
      if ( (v34 & 6) != 0 )
        _assert_fail(
          (__int64)"inptr - bytebuf > (state->__count & 7)",
          (__int64)"../iconv/loop.c",
          0x1C9u,
          "ucs2reverse_internal_loop_single");
      v13 = *(_DWORD *)(a2 + 16);
      v16 = &v16[-v35 + 2];
      *a3 = (unsigned __int64)v16;
      *v33 = v34 & 0xFFFFFFF8;
    }
  }
  v46 = a5;
  v19 = v9;
  v20 = v17;
  while ( 1 )
  {
    if ( (_BYTE *)a4 == v16 )
    {
      v23 = v18;
      v21 = a4;
LABEL_55:
      v26 = 4;
    }
    else
    {
      v21 = (unsigned __int64)(v16 + 2);
      if ( a4 < (unsigned __int64)(v16 + 2) )
      {
        v23 = v18;
        v21 = (unsigned __int64)v16;
        v26 = 7;
      }
      else
      {
        v22 = v18 + 4;
        v23 = v18;
        if ( v20 >= (unsigned __int64)(v18 + 4) )
        {
          v24 = v13 & 2;
          while ( 1 )
          {
            v25 = __ROL2__(*(_WORD *)(v21 - 2), 8);
            if ( (unsigned __int16)(v25 + 10240) <= 0x7FFu )
            {
              if ( !v50 || !v24 )
              {
                v21 -= 2LL;
                v26 = 6;
                goto LABEL_23;
              }
              ++*v50;
              if ( v21 == a4 )
                goto LABEL_55;
            }
            else
            {
              *(_DWORD *)v23 = v25;
              v23 = v22;
              if ( v21 == a4 )
                goto LABEL_55;
            }
            if ( a4 < v21 + 2 )
              break;
            v22 = v23 + 4;
            if ( v20 < (unsigned __int64)(v23 + 4) )
            {
              v26 = 5;
              goto LABEL_23;
            }
            v21 += 2LL;
          }
          v26 = 7;
          *a3 = v21;
          if ( !v46 )
            goto LABEL_24;
LABEL_32:
          *v46 = v23;
          return v26;
        }
        v21 = (unsigned __int64)v16;
        v26 = 5;
      }
    }
LABEL_23:
    *a3 = v21;
    if ( v46 )
      goto LABEL_32;
LABEL_24:
    ++*(_DWORD *)(a2 + 20);
    if ( (*(_BYTE *)(a2 + 16) & 1) != 0 )
    {
      v39 = v51;
      *(_QWORD *)a2 = v23;
      *a6 += v39;
      goto LABEL_36;
    }
    if ( v23 <= v18 )
      goto LABEL_36;
    v45 = v26;
    v52 = *(void **)a2;
    dl_mcount_wrapper_check((__int64)v19);
    v27 = v19(v48, v49, &v52, v23, 0LL, a6, 0LL, a8);
    v26 = v45;
    if ( v27 != 4 )
      break;
    if ( v45 != 5 )
      goto LABEL_36;
LABEL_30:
    v16 = (_BYTE *)*a3;
    v13 = *(_DWORD *)(a2 + 16);
    v18 = *(char **)a2;
  }
  if ( v23 != v52 )
    *a3 -= (v23 - (_BYTE *)v52) / 2;
  if ( !v27 )
    goto LABEL_30;
  v26 = v27;
LABEL_36:
  if ( a8 && v26 == 7 )
  {
    v29 = *a3;
    if ( (__int64)(a4 - *a3) > 3 )
      _assert_fail(
        (__int64)"inend - *inptrp < 4",
        (__int64)"../iconv/skeleton.c",
        0x309u,
        "__gconv_transform_ucs2reverse_internal");
    v30 = *(unsigned int **)(a2 + 32);
    v31 = v29 + 1;
    v32 = v30 + 1;
    if ( v29 >= a4 )
    {
      v44 = 0;
    }
    else
    {
      while ( 1 )
      {
        *a3 = v31;
        *v32++ = *(_BYTE *)(v31 - 1);
        if ( a4 == v31 )
          break;
        ++v31;
      }
      v44 = a4 - v29;
    }
    *v30 = *v30 & 0xFFFFFFF8 | v44;
  }
  return v26;
}
// 448920: using guessed type void *var_50;

//----- (0000000000448ED0) ----------------------------------------------------
__int64 __fastcall _gconv_transform_internal_ucs2reverse(
        _QWORD *a1,
        __int64 a2,
        unsigned int **a3,
        unsigned __int64 a4,
        _QWORD *a5,
        _QWORD *a6,
        unsigned int a7,
        unsigned int a8)
{
  __int64 *v8; // r11
  int v11; // er14
  unsigned int *v12; // rdx
  unsigned __int64 v13; // r15
  _QWORD *v14; // rax
  _WORD *v15; // r13
  __int64 *v16; // rax
  _WORD *v17; // rbx
  int v18; // er14
  int v19; // eax
  unsigned int *v20; // rsi
  _WORD *v21; // rdi
  unsigned int v22; // ecx
  unsigned int v23; // er10
  unsigned int v25; // eax
  unsigned int *v26; // rbx
  unsigned int v27; // esi
  __int64 v28; // rcx
  __int64 v29; // rax
  unsigned int *v30; // rax
  unsigned __int64 v31; // rdi
  __int64 v32; // rdx
  __int64 v33; // rax
  unsigned __int64 v34; // rsi
  unsigned int *v35; // rdi
  __int64 v36; // rax
  _BYTE *v37; // rdx
  char *v38; // rax
  unsigned int *v39; // rdx
  int v40; // ebp
  signed int v41; // eax
  unsigned int *v42; // rax
  _DWORD *v43; // rdx
  __int64 *v45; // [rsp+10h] [rbp-B8h]
  __int64 *v46; // [rsp+10h] [rbp-B8h]
  unsigned int v47; // [rsp+18h] [rbp-B0h]
  unsigned int (__fastcall *v49)(_QWORD *, __int64, _DWORD *, _WORD *, _QWORD, _QWORD *, _QWORD, _QWORD); // [rsp+28h] [rbp-A0h]
  __int64 *v50; // [rsp+30h] [rbp-98h]
  _QWORD *v51; // [rsp+38h] [rbp-90h]
  __int64 v52; // [rsp+40h] [rbp-88h]
  __int64 *v53; // [rsp+48h] [rbp-80h]
  __int64 *v55; // [rsp+58h] [rbp-70h]
  __int64 v56; // [rsp+68h] [rbp-60h] BYREF
  unsigned int *v57; // [rsp+70h] [rbp-58h] BYREF
  _DWORD v58[3]; // [rsp+78h] [rbp-50h] BYREF
  unsigned int v59; // [rsp+84h] [rbp-44h] BYREF
  __int64 v60[8]; // [rsp+88h] [rbp-40h] BYREF

  v8 = (__int64 *)a3;
  v11 = *(_DWORD *)(a2 + 16);
  v60[0] = __readfsqword(0x28u);
  v49 = 0LL;
  v51 = a1 + 13;
  v52 = a2 + 48;
  if ( (v11 & 1) == 0 )
  {
    v49 = (unsigned int (__fastcall *)(_QWORD *, __int64, _DWORD *, _WORD *, _QWORD, _QWORD *, _QWORD, _QWORD))a1[18];
    if ( a1[13] )
      v49 = (unsigned int (__fastcall *)(_QWORD *, __int64, _DWORD *, _WORD *, _QWORD, _QWORD *, _QWORD, _QWORD))(__readfsqword(0x30u) ^ __ROR8__(a1[18], 17));
  }
  if ( a7 )
  {
    if ( a5 )
      _assert_fail(
        (__int64)"outbufstart == NULL",
        (__int64)"../iconv/skeleton.c",
        0x19Fu,
        "__gconv_transform_internal_ucs2reverse");
    v23 = 0;
    **(_QWORD **)(a2 + 32) = 0LL;
    if ( (*(_BYTE *)(a2 + 16) & 1) == 0 )
    {
      dl_mcount_wrapper_check((__int64)v49);
      return v49(v51, v52, 0LL, 0LL, 0LL, a6, a7, a8);
    }
    return v23;
  }
  v12 = *a3;
  v13 = *(_QWORD *)(a2 + 8);
  v14 = a5;
  if ( !a5 )
    v14 = (_QWORD *)a2;
  v15 = (_WORD *)*v14;
  v16 = 0LL;
  v56 = 0LL;
  if ( a6 )
    v16 = &v56;
  v53 = v16;
  if ( !a8 )
    goto LABEL_10;
  v26 = *(unsigned int **)(a2 + 32);
  v27 = *v26;
  LODWORD(v28) = *v26 & 7;
  if ( !(_DWORD)v28 )
    goto LABEL_10;
  if ( a5 )
    _assert_fail(
      (__int64)"outbufstart == NULL",
      (__int64)"../iconv/skeleton.c",
      0x22Fu,
      "__gconv_transform_internal_ucs2reverse");
  v57 = v12;
  *(_QWORD *)v58 = v15;
  if ( (unsigned int)v28 > 4 )
    _assert_fail(
      (__int64)"(state->__count & 7) <= sizeof (state->__value)",
      (__int64)"../iconv/loop.c",
      0x18Bu,
      "internal_ucs2reverse_loop_single");
  v28 = (int)v28;
  v29 = 0LL;
  do
  {
    *((_BYTE *)&v59 + v29) = *((_BYTE *)v26 + v29 + 4);
    ++v29;
  }
  while ( v29 != (int)v28 );
  if ( a4 < (unsigned __int64)v12 - v29 + 4 )
  {
    *v8 = a4;
    if ( (unsigned __int64)v12 < a4 )
    {
      v38 = (char *)v26 + v29;
      do
      {
        v12 = (unsigned int *)((char *)v12 + 1);
        ++v38;
        v57 = v12;
        v38[3] = *((_BYTE *)v12 - 1);
      }
      while ( (unsigned int *)a4 != v12 );
    }
    return 7;
  }
  v30 = v12;
  v23 = 5;
  if ( v13 < (unsigned __int64)(v15 + 1) )
    return v23;
  v31 = (int)v28;
  do
  {
    v30 = (unsigned int *)((char *)v30 + 1);
    ++v31;
    v57 = v30;
    *((_BYTE *)&v58[2] + v31 + 3) = *((_BYTE *)v30 - 1);
  }
  while ( v31 <= 3 && a4 > (unsigned __int64)v30 );
  v57 = &v59;
  if ( v59 <= 0xFFFF )
  {
    if ( v59 - 55296 > 0x7FF )
    {
      *v15 = __ROL2__(v59, 8);
      *(_QWORD *)v58 = v15 + 1;
LABEL_54:
      v32 = 4LL;
      v57 = (unsigned int *)v60;
LABEL_55:
      if ( v28 >= v32 )
        _assert_fail(
          (__int64)"inptr - bytebuf > (state->__count & 7)",
          (__int64)"../iconv/loop.c",
          0x1C9u,
          "internal_ucs2reverse_loop_single");
      v12 = (unsigned int *)(*v8 + v32 - v28);
      v15 = *(_WORD **)v58;
      *v8 = (__int64)v12;
      v11 = *(_DWORD *)(a2 + 16);
      *v26 = v27 & 0xFFFFFFF8;
      goto LABEL_10;
    }
    if ( v53 && (v11 & 2) != 0 )
    {
      v32 = 4LL;
      v57 = (unsigned int *)v60;
      ++*v53;
      goto LABEL_55;
    }
    return 6;
  }
  if ( v59 >> 7 == 7168 )
    goto LABEL_54;
  if ( !v53 )
    return 6;
  if ( (v11 & 8) == 0 )
  {
    v23 = 6;
    v39 = &v59;
    if ( (v11 & 2) == 0 )
      return v23;
    goto LABEL_81;
  }
  v55 = v8;
  v50 = (__int64 *)((char *)&v59 + v31);
  v23 = _gconv_transliterate(a1, a2, (__int64)v12, &v57, (unsigned __int64)&v59 + v31, (__int64 *)v58, v53);
  v39 = v57;
  v8 = v55;
  if ( v23 == 6 )
  {
    if ( (v11 & 2) == 0 )
    {
LABEL_82:
      if ( v39 == &v59 )
        return 6;
LABEL_83:
      v27 = *v26;
      v32 = (char *)v39 - (char *)&v59;
      v28 = *v26 & 7;
      goto LABEL_55;
    }
LABEL_81:
    v57 = ++v39;
    ++*v53;
    goto LABEL_82;
  }
  if ( v57 != &v59 )
    goto LABEL_83;
  if ( v23 == 7 )
  {
    if ( v50 == v60 )
      _assert_fail(
        (__int64)"inend != &bytebuf[MAX_NEEDED_INPUT]",
        (__int64)"../iconv/loop.c",
        0x1DBu,
        "internal_ucs2reverse_loop_single");
    v41 = *v26 & 0xFFFFFFF8;
    *v55 += v31 - (*v26 & 7);
    if ( v41 >= (__int64)v31 )
      _assert_fail(
        (__int64)"inend - inptr > (state->__count & ~7)",
        (__int64)"../iconv/loop.c",
        0x1E5u,
        "internal_ucs2reverse_loop_single");
    if ( v31 > 4 )
      _assert_fail(
        (__int64)"inend - inptr <= sizeof (state->__value)",
        (__int64)"../iconv/loop.c",
        0x1E6u,
        "internal_ucs2reverse_loop_single");
    *v26 = v31 | v41;
    v42 = &v59;
    if ( v50 > (__int64 *)&v59 )
    {
      v43 = v26 + 1;
      do
      {
        v42 = (unsigned int *)((char *)v42 + 1);
        v43 = (_DWORD *)((char *)v43 + 1);
        v57 = v42;
        *((_BYTE *)v43 - 1) = *((_BYTE *)v42 - 1);
      }
      while ( v50 != (__int64 *)v42 );
    }
    return 7;
  }
  if ( v23 )
    return v23;
  v12 = (unsigned int *)*v55;
  v11 = *(_DWORD *)(a2 + 16);
  while ( 1 )
  {
LABEL_10:
    v57 = v12;
    v17 = v15;
    v18 = v11 & 2;
    *(_QWORD *)v58 = v15;
    v19 = 4;
LABEL_11:
    if ( (unsigned int *)a4 != v12 )
    {
      while ( 1 )
      {
        v20 = v12 + 1;
        if ( a4 < (unsigned __int64)(v12 + 1) )
        {
          v23 = 7;
          goto LABEL_21;
        }
        v21 = v17 + 1;
        if ( v13 < (unsigned __int64)(v17 + 1) )
          break;
        v22 = *v12;
        if ( *v12 > 0xFFFF )
        {
          if ( v22 >> 7 == 7168 )
          {
            v57 = ++v12;
            goto LABEL_11;
          }
          if ( v53 )
          {
            if ( (*(_BYTE *)(a2 + 16) & 8) != 0 )
            {
              v46 = v8;
              v19 = _gconv_transliterate(a1, a2, *v8, &v57, a4, (__int64 *)v58, v53);
              v12 = v57;
              v17 = *(_WORD **)v58;
              v8 = v46;
              if ( v19 != 6 )
              {
                if ( v19 != 5 )
                  goto LABEL_11;
                goto LABEL_17;
              }
            }
            if ( v18 )
            {
              v57 = ++v12;
              ++*v53;
              v19 = 6;
              goto LABEL_11;
            }
          }
LABEL_34:
          v23 = 6;
LABEL_21:
          *v8 = (__int64)v12;
          if ( a5 )
            goto LABEL_18;
          goto LABEL_22;
        }
        if ( v22 - 55296 <= 0x7FF )
        {
          if ( v53 && v18 )
          {
            v57 = ++v12;
            ++*v53;
            goto LABEL_11;
          }
          goto LABEL_34;
        }
        ++v12;
        *v17++ = __ROL2__(v22, 8);
        *(_QWORD *)v58 = v21;
        v57 = v20;
        if ( (unsigned int *)a4 == v20 )
          goto LABEL_17;
      }
      v23 = 5;
      goto LABEL_21;
    }
LABEL_17:
    v23 = v19;
    *v8 = (__int64)v12;
    if ( a5 )
    {
LABEL_18:
      *a5 = v17;
      return v23;
    }
LABEL_22:
    ++*(_DWORD *)(a2 + 20);
    if ( (*(_BYTE *)(a2 + 16) & 1) != 0 )
      break;
    if ( v15 >= v17 )
    {
      v25 = v23;
      goto LABEL_27;
    }
    v47 = v23;
    v45 = v8;
    *(_QWORD *)v58 = *(_QWORD *)a2;
    dl_mcount_wrapper_check((__int64)v49);
    v25 = v49(v51, v52, v58, v17, 0LL, a6, 0LL, a8);
    v8 = v45;
    if ( v25 != 4 )
    {
      if ( *(_WORD **)v58 != v17 )
        *v45 -= 2LL * ((_QWORD)v17 - *(_QWORD *)v58);
LABEL_27:
      if ( v25 )
        goto LABEL_40;
      goto LABEL_28;
    }
    v25 = v47;
    if ( v47 != 5 && v47 )
    {
LABEL_40:
      v23 = v25;
      goto LABEL_59;
    }
LABEL_28:
    v12 = (unsigned int *)*v8;
    v11 = *(_DWORD *)(a2 + 16);
    v15 = *(_WORD **)a2;
  }
  v33 = v56;
  *(_QWORD *)a2 = v17;
  *a6 += v33;
LABEL_59:
  if ( v23 == 7 && a8 )
  {
    v34 = *v8;
    if ( (__int64)(a4 - *v8) > 3 )
      _assert_fail(
        (__int64)"inend - *inptrp < 4",
        (__int64)"../iconv/skeleton.c",
        0x309u,
        "__gconv_transform_internal_ucs2reverse");
    v35 = *(unsigned int **)(a2 + 32);
    v36 = v34 + 1;
    v37 = v35 + 1;
    if ( v34 >= a4 )
    {
      v40 = 0;
    }
    else
    {
      while ( 1 )
      {
        *v8 = v36;
        *v37++ = *(_BYTE *)(v36 - 1);
        if ( a4 == v36 )
          break;
        ++v36;
      }
      v40 = a4 - v34;
    }
    *v35 = v40 | *v35 & 0xFFFFFFF8;
  }
  return v23;
}

//----- (0000000000449760) ----------------------------------------------------
__int64 __fastcall _gconv_transliterate(
        _QWORD *a1,
        __int64 a2,
        __int64 a3,
        unsigned int **a4,
        unsigned __int64 a5,
        __int64 *a6,
        _QWORD *a7)
{
  unsigned __int64 v7; // r14
  unsigned __int64 v8; // rax
  __int64 v9; // rsi
  __int64 v10; // r13
  __int64 v11; // r11
  int v12; // ebx
  unsigned __int64 v13; // r15
  __int64 v14; // r12
  int v15; // edx
  unsigned int *v16; // rax
  unsigned int *v17; // rax
  unsigned __int64 v18; // rax
  int v19; // eax
  int v20; // edx
  unsigned int *v21; // rcx
  unsigned int v22; // edi
  __int64 result; // rax
  __int64 v24; // rax
  int v25; // edx
  int v26; // er12
  __int64 v27; // r14
  __int64 v28; // rsi
  __int64 v29; // rax
  int v30; // ebx
  __int64 v31; // r15
  __int64 v32; // rax
  __int64 v33; // rbx
  __int64 v34; // rbp
  unsigned int v35; // eax
  unsigned int *v36; // r8
  unsigned __int64 v37; // [rsp+8h] [rbp-E0h]
  unsigned __int64 v38; // [rsp+10h] [rbp-D8h]
  unsigned int *v39; // [rsp+18h] [rbp-D0h]
  __int64 v42; // [rsp+40h] [rbp-A8h]
  __int64 (__fastcall *v43)(_QWORD *, __int64, __int64 *, __int64, __int64 *, _QWORD, _QWORD, _QWORD); // [rsp+48h] [rbp-A0h]
  __int64 v46; // [rsp+68h] [rbp-80h]
  int v47; // [rsp+80h] [rbp-68h]
  int v48; // [rsp+84h] [rbp-64h]
  unsigned __int64 v49; // [rsp+88h] [rbp-60h]
  __int64 v50; // [rsp+98h] [rbp-50h] BYREF
  __int64 v51[9]; // [rsp+A0h] [rbp-48h] BYREF

  v7 = a5;
  v51[1] = __readfsqword(0x28u);
  v39 = *a4;
  v43 = (__int64 (__fastcall *)(_QWORD *, __int64, __int64 *, __int64, __int64 *, _QWORD, _QWORD, _QWORD))a1[5];
  if ( *a1 )
    v43 = (__int64 (__fastcall *)(_QWORD *, __int64, __int64 *, __int64, __int64 *, _QWORD, _QWORD, _QWORD))(__readfsqword(0x30u) ^ __ROR8__(a1[5], 17));
  v8 = __readfsqword(0xFFFFFFA0);
  v9 = *(_QWORD *)v8;
  v38 = *(unsigned int *)(*(_QWORD *)v8 + 552LL);
  if ( *(_DWORD *)(*(_QWORD *)v8 + 552LL) )
  {
    if ( a5 >= (unsigned __int64)(v39 + 1) )
    {
      v10 = *(_QWORD *)(v9 + 568);
      v37 = 0LL;
      v11 = *(_QWORD *)(v9 + 584);
      v42 = *(_QWORD *)(v9 + 560);
      v46 = *(_QWORD *)(v9 + 576);
      while ( 2 )
      {
        v12 = 0;
        v13 = (v38 + v37) >> 1;
        v14 = *(unsigned int *)(v42 + 4 * v13);
        v15 = *(_DWORD *)(v10 + 4 * v14);
        v16 = v39;
        while ( *v16 == v15 )
        {
          v15 = *(_DWORD *)(v10 + 4LL * (unsigned int)(++v12 + v14));
          if ( !v15 )
            goto LABEL_23;
          if ( v7 <= (unsigned __int64)++v16 )
            return 7LL;
        }
        if ( v12 )
        {
          if ( v15 )
            return 7LL;
LABEL_23:
          v47 = v12;
          v24 = *(unsigned int *)(v46 + 4 * v13);
          v48 = *(_DWORD *)(v42 + 4 * v13);
          v25 = *(_DWORD *)(v11 + 4 * v24);
          v49 = v7;
          v26 = *(_DWORD *)(v46 + 4 * v13);
          v27 = v11;
          while ( 1 )
          {
            v28 = v27 + 4 * v24;
            if ( v25 )
            {
              v29 = v27 + 4 * v24 + 4;
              v30 = 0;
              do
              {
                v31 = v29;
                v29 += 4LL;
                ++v30;
              }
              while ( *(_DWORD *)(v29 - 4) );
            }
            else
            {
              v31 = v27 + 4 * v24;
              v30 = 0;
            }
            v32 = *a6;
            v50 = v28;
            v51[0] = v32;
            dl_mcount_wrapper_check((__int64)v43);
            result = v43(a1, a2, &v50, v31, v51, 0LL, 0LL, 0LL);
            if ( (_DWORD)result != 6 )
              break;
            v24 = (unsigned int)(v26 + v30 + 1);
            v25 = *(_DWORD *)(v27 + 4 * v24);
            v26 += v30 + 1;
            if ( !v25 )
            {
              v11 = v27;
              v13 = (v38 + v37) >> 1;
              v12 = v47;
              LODWORD(v14) = v48;
              v17 = &v39[v47];
              v7 = v49;
              goto LABEL_12;
            }
          }
          if ( (_DWORD)result == 4 )
          {
            *a4 += v47;
            ++*a7;
            result = 0LL;
          }
          else if ( (_DWORD)result == 5 )
          {
            return result;
          }
          goto LABEL_37;
        }
        v17 = v39;
LABEL_12:
        if ( v7 <= (unsigned __int64)v17 || *(_DWORD *)(v10 + 4LL * (unsigned int)(v12 + v14)) < *v17 )
          v37 = v13 + 1;
        else
          v38 = v13;
        if ( v38 > v37 )
          continue;
        break;
      }
      v18 = __readfsqword(0xFFFFFFA0);
      v9 = *(_QWORD *)v18;
      v19 = *(_DWORD *)(*(_QWORD *)v18 + 608LL);
      if ( !v19 )
        goto LABEL_47;
      v20 = v19;
      v21 = *(unsigned int **)(v9 + 616);
      v39 = *a4;
      v22 = **a4;
      goto LABEL_40;
    }
    goto LABEL_18;
  }
  if ( *(_DWORD *)(v9 + 608) )
  {
    if ( a5 >= (unsigned __int64)(v39 + 1) )
    {
      v21 = *(unsigned int **)(v9 + 616);
      v22 = *v39;
      v20 = *(_DWORD *)(v9 + 608);
LABEL_40:
      if ( v20 > 0 )
      {
        v35 = *v21;
        if ( v22 >= *v21 )
        {
          v36 = &v21[3 * (v20 - 1) + 3];
          while ( v21[1] < v22 || (v22 - v35) % v21[2] )
          {
            v21 += 3;
            if ( v21 != v36 )
            {
              v35 = *v21;
              if ( *v21 <= v22 )
                continue;
            }
            goto LABEL_47;
          }
          *a4 = v39 + 1;
          ++*a7;
          return 0LL;
        }
      }
LABEL_47:
      v33 = *(unsigned int *)(v9 + 592);
      if ( !(_DWORD)v33 )
        return 6LL;
      v34 = *(_QWORD *)(v9 + 600);
      v50 = v34;
      goto LABEL_51;
    }
LABEL_18:
    result = 4LL;
    if ( v39 != (unsigned int *)a5 )
      return 7LL;
    return result;
  }
  v33 = *(unsigned int *)(v9 + 592);
  if ( !(_DWORD)v33 )
    return 6LL;
  v34 = *(_QWORD *)(v9 + 600);
  v50 = v34;
  if ( a5 < (unsigned __int64)(v39 + 1) )
    return 3 * (unsigned int)(v39 != (unsigned int *)a5) + 4;
LABEL_51:
  v51[0] = *a6;
  dl_mcount_wrapper_check((__int64)v43);
  result = v43(a1, a2, &v50, v34 + 4 * v33, v51, 0LL, 0LL, 0LL);
  if ( (_DWORD)result != 6 )
  {
    if ( (_DWORD)result == 4 )
    {
      ++*a7;
      ++*a4;
      result = 0LL;
    }
LABEL_37:
    *a6 = v51[0];
  }
  return result;
}

//----- (0000000000449C40) ----------------------------------------------------
__int64 __fastcall find_module_idx(unsigned __int8 *a1, _QWORD *a2)
{
  __int64 v2; // r14
  __int64 v3; // r12
  unsigned int v4; // eax
  unsigned int v5; // er13
  unsigned int v6; // ebx
  unsigned int v7; // ebp
  __int64 result; // rax
  unsigned int v9; // eax
  unsigned __int16 *v10; // r15
  __int64 v11; // rsi
  unsigned int v12; // [rsp+4h] [rbp-54h]
  __int64 v13; // [rsp+8h] [rbp-50h]

  v2 = gconv_cache;
  v3 = *(unsigned __int16 *)(gconv_cache + 6);
  v13 = *(unsigned __int16 *)(gconv_cache + 4);
  v4 = _hash_string(a1);
  v5 = *(unsigned __int16 *)(v2 + 8);
  v6 = v4 % v5;
  v12 = cache_size - *(unsigned __int16 *)(v2 + 4);
  v7 = v4 % (v5 - 2) + 1;
  while ( 1 )
  {
    v10 = (unsigned __int16 *)(v2 + v3 + 4LL * v6);
    v11 = *v10;
    if ( !(_WORD)v11 )
      return 0xFFFFFFFFLL;
    if ( (unsigned __int16)v11 < v12 )
    {
      result = j_strcmp_ifunc(a1, v2 + v13 + v11);
      if ( !(_DWORD)result )
        break;
    }
    v9 = v7 + v6;
    if ( v5 <= v7 + v6 )
      v9 = v7 + v6 - v5;
    v6 = v9;
  }
  *a2 = v10[1];
  return result;
}
// 4010A0: using guessed type __int64 __fastcall j_strcmp_ifunc(_QWORD, _QWORD);
// 4AAE90: using guessed type __int64 cache_size;
// 4AAE98: using guessed type __int64 gconv_cache;

//----- (0000000000449D20) ----------------------------------------------------
__int64 __fastcall find_module(__int64 a1, __int64 a2, _QWORD *a3)
{
  __int64 v4; // r15
  __int64 v5; // r12
  __int64 v6; // rax
  _BYTE *v7; // rdx
  __int16 v8; // ax
  unsigned int v9; // eax
  __int64 v10; // rax
  _QWORD *shlib; // rdx
  __int64 result; // rax
  __int64 v13; // rax
  __int64 v14; // r12
  __int64 v15; // rax
  __int64 (__fastcall *v16)(_QWORD *); // r12
  void *v17; // rsp
  _BYTE v19[4088]; // [rsp+8h] [rbp-1040h] BYREF
  _QWORD v20[8]; // [rsp+1008h] [rbp-40h] BYREF

  v20[1] = __readfsqword(0x28u);
  v4 = j_strlen_ifunc(a1);
  v5 = j_strlen_ifunc(a2) + 1;
  v6 = v5 + v4 + 15;
  v7 = (char *)v20 - (v6 & 0xFFFFFFFFFFFFF000LL);
  v8 = v6 & 0xFFF0;
  if ( v20 != (_QWORD *)v7 )
  {
    while ( v19 != v7 )
      ;
  }
  v9 = v8 & 0xFFF;
  if ( v9 )
  {
    v17 = alloca(v9);
    *(_QWORD *)&v19[v9 - 8] = *(_QWORD *)&v19[v9 - 8];
  }
  v10 = j_mempcpy(v19, a1, v4);
  j_memcpy(v10, a2, v5);
  shlib = (_QWORD *)_gconv_find_shlib((__int64)v19);
  *a3 = shlib;
  result = 1LL;
  if ( shlib )
  {
    v13 = shlib[3];
    v14 = shlib[4];
    a3[1] = 0LL;
    a3[5] = v13;
    v15 = shlib[5];
    a3[7] = v14;
    a3[8] = v15;
    result = 0LL;
    a3[6] = 0LL;
    a3[12] = 0LL;
    v16 = (__int64 (__fastcall *)(_QWORD *))(__readfsqword(0x30u) ^ __ROR8__(v14, 17));
    if ( v16 )
    {
      dl_mcount_wrapper_check((__int64)v16);
      result = v16(a3);
      a3[6] = __ROL8__(__readfsqword(0x30u) ^ a3[6], 17);
    }
  }
  return result;
}
// 401040: using guessed type __int64 __fastcall j_memcpy(_QWORD, _QWORD, _QWORD);
// 4010B0: using guessed type __int64 __fastcall j_mempcpy(_QWORD, _QWORD, _QWORD);
// 4010C8: using guessed type __int64 __fastcall j_strlen_ifunc(_QWORD);

//----- (0000000000449E70) ----------------------------------------------------
__int64 _gconv_get_cache()
{
  return gconv_cache;
}
// 449E70: using guessed type __int64 __fastcall _gconv_get_cache();
// 4AAE98: using guessed type __int64 gconv_cache;

//----- (0000000000449E80) ----------------------------------------------------
__int64 _gconv_load_cache()
{
  unsigned int v0; // eax
  unsigned int v1; // ebx
  __int64 st_size; // rsi
  __int64 v3; // rcx
  u32 *v4; // r8
  __int64 v5; // r9
  __int64 v6; // rdx
  unsigned __int64 v7; // rcx
  u32 *v8; // r8
  unsigned __int64 v9; // r9
  __int64 v10; // rax
  __int64 result; // rax
  char *v12; // rax
  unsigned __int64 v13; // r12
  __int64 v14; // rdx
  unsigned __int64 v15; // rax
  __int64 v16; // rdx
  __int64 v17; // rcx
  u32 *v18; // r8
  unsigned __int64 v19; // r9
  __int64 v20; // [rsp+8h] [rbp-C0h]
  struct stat v21; // [rsp+10h] [rbp-B8h] BYREF
  unsigned __int64 v22; // [rsp+A8h] [rbp-20h]

  v22 = __readfsqword(0x28u);
  _gconv_path_envvar = (__int64)getenv("GCONV_PATH");
  if ( _gconv_path_envvar )
    return 0xFFFFFFFFLL;
  v0 = _open_nocancel("/usr/lib64/gconv/gconv-modules.cache", 0, 0);
  v1 = v0;
  if ( v0 == -1 )
    return 0xFFFFFFFFLL;
  if ( (fxstat(1u, v0, &v21) & 0x80000000) != 0LL )
    goto LABEL_25;
  st_size = v21.st_size;
  if ( v21.st_size <= 0xFuLL )
    goto LABEL_25;
  cache_size = v21.st_size;
  gconv_cache = mmap64(0LL, v21.st_size, 1uLL, 1uLL, v1, 0LL);
  if ( gconv_cache != -1 )
    goto LABEL_6;
  v20 = cache_size;
  v12 = (char *)malloc(cache_size, st_size, (_QWORD *)cache_size, v3, v4, v5);
  gconv_cache = (__int64)v12;
  if ( !v12 )
  {
LABEL_25:
    _close_nocancel(v1);
    return 0xFFFFFFFFLL;
  }
  v13 = 0LL;
  v14 = v20;
  while ( 1 )
  {
    st_size = (__int64)&v12[v13];
    v15 = read(v1, &v12[v13], v14 - v13);
    if ( v15 == -1LL )
    {
      free(gconv_cache, st_size, v16, v17, v18, v19);
      gconv_cache = 0LL;
      goto LABEL_25;
    }
    v14 = cache_size;
    v13 += v15;
    if ( cache_size <= v13 )
      break;
    v12 = (char *)gconv_cache;
  }
  cache_malloced = 1;
LABEL_6:
  _close_nocancel(v1);
  if ( *(_DWORD *)gconv_cache != 536937252
    || (v6 = cache_size, *(unsigned __int16 *)(gconv_cache + 4) >= (unsigned __int64)cache_size)
    || (v7 = *(unsigned __int16 *)(gconv_cache + 6), cache_size <= v7)
    || (v10 = *(unsigned __int16 *)(gconv_cache + 8), !(_WORD)v10)
    || cache_size < v7 + 4 * v10
    || cache_size <= (unsigned __int64)*(unsigned __int16 *)(gconv_cache + 10)
    || (v7 = *(unsigned __int16 *)(gconv_cache + 12), result = 0LL, cache_size < v7) )
  {
    if ( cache_malloced )
    {
      free(gconv_cache, st_size, v6, v7, v8, v9);
      cache_malloced = 0;
    }
    else
    {
      munmap(gconv_cache, cache_size);
    }
    gconv_cache = 0LL;
    return 0xFFFFFFFFLL;
  }
  return result;
}
// 449FE0: variable 'v6' is possibly undefined
// 449FE0: variable 'v7' is possibly undefined
// 449FE0: variable 'v8' is possibly undefined
// 449FE0: variable 'v9' is possibly undefined
// 44A007: variable 'v3' is possibly undefined
// 44A007: variable 'v4' is possibly undefined
// 44A007: variable 'v5' is possibly undefined
// 44A059: variable 'v16' is possibly undefined
// 44A059: variable 'v17' is possibly undefined
// 44A059: variable 'v18' is possibly undefined
// 44A059: variable 'v19' is possibly undefined
// 4AAE88: using guessed type int cache_malloced;
// 4AAE90: using guessed type __int64 cache_size;
// 4AAE98: using guessed type __int64 gconv_cache;
// 4AB980: using guessed type __int64 _gconv_path_envvar;

//----- (000000000044A0A0) ----------------------------------------------------
__int64 __fastcall _gconv_compare_alias_cache(unsigned __int8 *a1, unsigned __int8 *a2, _DWORD *a3)
{
  __int64 result; // rax
  __int64 v5; // [rsp+8h] [rbp-30h] BYREF
  _QWORD v6[5]; // [rsp+10h] [rbp-28h] BYREF

  v6[1] = __readfsqword(0x28u);
  if ( !gconv_cache )
    return 0xFFFFFFFFLL;
  if ( (unsigned int)find_module_idx(a1, &v5) || (result = find_module_idx(a2, v6), (_DWORD)result) )
  {
    *a3 = j_strcmp_ifunc(a1, a2);
    return 0LL;
  }
  else
  {
    *a3 = v5 - LODWORD(v6[0]);
  }
  return result;
}
// 4010A0: using guessed type __int64 __fastcall j_strcmp_ifunc(_QWORD, _QWORD);
// 4AAE98: using guessed type __int64 gconv_cache;

//----- (000000000044A140) ----------------------------------------------------
__int64 __fastcall _gconv_lookup_cache(unsigned __int8 *a1, unsigned __int8 *a2, __int64 *a3, __int64 *a4, char a5)
{
  __int64 v5; // r14
  __int64 v8; // r12
  __int64 v9; // rbp
  unsigned int module_idx; // ebx
  __int64 v12; // rdx
  __int64 v13; // r9
  __int64 v14; // rcx
  __int64 v15; // rbp
  __int64 v16; // rsi
  u32 *v17; // r8
  __int64 v18; // rcx
  __int64 v19; // r12
  unsigned __int16 *v20; // r15
  _QWORD *v21; // rax
  unsigned __int16 *v22; // rcx
  __int64 v23; // rbp
  int v24; // er15
  __int64 v25; // rdx
  __int64 v26; // rax
  __int64 v27; // rdi
  _BYTE *v28; // rdi
  __int64 v29; // r12
  __int64 v30; // rsi
  unsigned int module; // eax
  __int64 v32; // rdx
  u32 *v33; // r8
  unsigned __int64 v34; // r9
  _QWORD *v35; // rax
  __int64 v36; // rdi
  __int64 v37; // rsi
  __int64 v38; // rax
  _BYTE *v39; // rdi
  __int64 v40; // rax
  bool v41; // zf
  _QWORD *v42; // rax
  __int64 v43; // r10
  int v44; // er14
  unsigned __int16 *v45; // r15
  __int64 v46; // rbx
  __int64 v47; // r13
  __int64 v48; // r12
  __int64 v49; // rsi
  __int64 v50; // rdx
  u32 *v51; // r8
  unsigned __int64 v52; // r9
  __int64 v53; // rax
  __int64 v54; // rdi
  _BYTE *v55; // rdi
  __int64 v56; // r10
  __int64 v57; // rax
  __int64 v58; // rax
  unsigned int v60; // [rsp+8h] [rbp-90h]
  unsigned int v61; // [rsp+8h] [rbp-90h]
  __int64 v62; // [rsp+10h] [rbp-88h]
  unsigned __int16 *v63; // [rsp+10h] [rbp-88h]
  unsigned __int16 *v64; // [rsp+10h] [rbp-88h]
  __int64 v65; // [rsp+10h] [rbp-88h]
  __int64 v66; // [rsp+18h] [rbp-80h]
  u32 *v67; // [rsp+20h] [rbp-78h]
  unsigned __int16 *v68; // [rsp+28h] [rbp-70h]
  __int64 *v69; // [rsp+38h] [rbp-60h]
  __int64 v70; // [rsp+48h] [rbp-50h] BYREF
  __int64 v71[9]; // [rsp+50h] [rbp-48h] BYREF

  v5 = gconv_cache;
  v71[1] = __readfsqword(0x28u);
  if ( !gconv_cache )
    return 2;
  v8 = *(unsigned __int16 *)(gconv_cache + 4);
  v9 = *(unsigned __int16 *)(gconv_cache + 10);
  if ( (unsigned int)find_module_idx(a2, &v70) )
    return 1;
  v62 = 4 * (3 * v70 + 3);
  if ( v62 + (unsigned __int64)*(unsigned __int16 *)(v5 + 10) > cache_size )
    return 1;
  module_idx = find_module_idx(a1, v71);
  if ( module_idx )
    return 1;
  v14 = 4 * (3 * v71[0] + 3);
  if ( v14 + (unsigned __int64)*(unsigned __int16 *)(v5 + 10) > cache_size )
    return 1;
  v15 = v5 + v9;
  v16 = v70;
  v17 = (u32 *)v62;
  v18 = v15 + v14 - 12;
  if ( (a5 & 1) != 0 && v71[0] == v70 )
    return (unsigned int)-1;
  v19 = v5 + v8;
  v20 = (unsigned __int16 *)(v15 + v62 - 12);
  if ( v71[0] && v70 )
  {
    v16 = v20[5];
    if ( (_WORD)v16 )
    {
      v17 = (u32 *)(gconv_cache + *(unsigned __int16 *)(v5 + 12) + v16 - 1);
      v12 = *(unsigned __int16 *)v17;
      if ( (_WORD)v12 )
      {
        while ( 1 )
        {
          v16 = *((unsigned __int16 *)v17 + 3 * (unsigned __int16)v12 - 2);
          if ( v71[0] == v16 )
            break;
          v17 = (u32 *)((char *)v17 + 6 * v12 + 2);
          v12 = *(unsigned __int16 *)v17;
          if ( !(_WORD)v12 )
            goto LABEL_21;
        }
        *a4 = v12;
        v67 = v17;
        v65 = v18;
        v42 = malloc(104 * v12, v16, (_QWORD *)v12, v18, v17, v13);
        v66 = (__int64)v42;
        *a3 = (__int64)v42;
        if ( v42 )
        {
          v43 = *v20;
          v44 = 0;
          v68 = v20;
          v45 = (unsigned __int16 *)v67 + 1;
          v46 = (__int64)v42;
          v69 = a4;
          v47 = v19;
          v48 = v19 + v43;
          while ( 1 )
          {
            v53 = *v45;
            v54 = v45[1];
            *(_QWORD *)(v46 + 24) = v48;
            v55 = (_BYTE *)(v47 + v54);
            v56 = *(unsigned __int16 *)(v15 + 12 * v53);
            v57 = v45[2];
            *(_DWORD *)(v46 + 16) = 1;
            *(_QWORD *)(v46 + 96) = 0LL;
            v48 = v47 + v56;
            v58 = v47 + v57;
            *(_QWORD *)(v46 + 32) = v47 + v56;
            if ( *v55 )
            {
              v49 = v58;
              if ( (unsigned int)find_module((__int64)v55, v58, (_QWORD *)v46) )
              {
                v19 = v47;
                v20 = v68;
                module_idx = 0;
                a4 = v69;
                free(v66, v49, v50, v65, v51, v52);
                v16 = v70;
                v18 = v65;
                goto LABEL_11;
              }
            }
            else
            {
              _gconv_get_builtin_trans(v58, v46);
            }
            ++v44;
            v46 += 104LL;
            v45 += 3;
            if ( *(unsigned __int16 *)v67 <= v44 )
              return 0;
          }
        }
        return 3;
      }
    }
LABEL_21:
    if ( !v20[2] )
      return 1;
LABEL_22:
    if ( !*(_WORD *)(v18 + 8) )
      return 1;
LABEL_23:
    v64 = (unsigned __int16 *)v18;
    v35 = malloc(0xD0uLL, v16, (_QWORD *)v12, v18, v17, v13);
    v23 = (__int64)v35;
    if ( v35 )
    {
      v36 = v20[3];
      v37 = v20[4];
      *a3 = (__int64)v35;
      v38 = *v20;
      v39 = (_BYTE *)(v19 + v36);
      *a4 = 0LL;
      *(_QWORD *)(v23 + 32) = "INTERNAL";
      *(_QWORD *)(v23 + 24) = v19 + v38;
      *(_DWORD *)(v23 + 16) = 1;
      *(_QWORD *)(v23 + 96) = 0LL;
      if ( *v39 )
      {
        v30 = v19 + v37;
        module = find_module((__int64)v39, v30, (_QWORD *)v23);
        v22 = v64;
        if ( module )
          goto LABEL_38;
      }
      else
      {
        _gconv_get_builtin_trans(v19 + v37, v23);
        v22 = v64;
      }
      v40 = *a4 + 1;
      v41 = v71[0] == 0;
      *a4 = v40;
      if ( v41 )
        return module_idx;
      v24 = v40;
      v25 = v23 + 104LL * (int)v40;
LABEL_16:
      v26 = *v22;
      v27 = v22[1];
      *(_QWORD *)(v25 + 24) = "INTERNAL";
      *(_DWORD *)(v25 + 16) = 1;
      v28 = (_BYTE *)(v19 + v27);
      *(_QWORD *)(v25 + 96) = 0LL;
      *(_QWORD *)(v25 + 32) = v19 + v26;
      v29 = v22[2] + v19;
      if ( !*v28 )
      {
        _gconv_get_builtin_trans(v29, v25);
        goto LABEL_18;
      }
      v30 = v29;
      module = find_module((__int64)v28, v29, (_QWORD *)v25);
      if ( !module )
      {
LABEL_18:
        ++*a4;
        return module_idx;
      }
      if ( v24 )
      {
        v60 = module;
        _gconv_release_step(v23);
        module = v60;
      }
LABEL_38:
      v61 = module;
      free(v23, v30, v32, (__int64)v22, v33, v34);
      return v61;
    }
    return 3;
  }
LABEL_11:
  if ( v16 )
  {
    if ( !v20[2] )
      return 1;
    if ( !v71[0] )
      goto LABEL_23;
    goto LABEL_22;
  }
  if ( v71[0] && *(_WORD *)(v18 + 8) )
  {
    v63 = (unsigned __int16 *)v18;
    v21 = malloc(0xD0uLL, 0LL, (_QWORD *)v12, v18, v17, v13);
    v22 = v63;
    v23 = (__int64)v21;
    if ( v21 )
    {
      v24 = 0;
      v25 = (__int64)v21;
      *a3 = (__int64)v21;
      *a4 = 0LL;
      goto LABEL_16;
    }
    return 3;
  }
  return 1;
}
// 44A27E: variable 'v12' is possibly undefined
// 44A27E: variable 'v17' is possibly undefined
// 44A27E: variable 'v13' is possibly undefined
// 44A47E: variable 'v32' is possibly undefined
// 44A47E: variable 'v22' is possibly undefined
// 44A47E: variable 'v33' is possibly undefined
// 44A47E: variable 'v34' is possibly undefined
// 44A5F0: variable 'v50' is possibly undefined
// 44A5F0: variable 'v51' is possibly undefined
// 44A5F0: variable 'v52' is possibly undefined
// 4AAE90: using guessed type __int64 cache_size;
// 4AAE98: using guessed type __int64 gconv_cache;

//----- (000000000044A610) ----------------------------------------------------
__int64 *__fastcall _gconv_release_cache(__int64 a1, __int64 a2, __int64 a3, __int64 a4, u32 *a5, unsigned __int64 a6)
{
  __int64 *result; // rax

  if ( gconv_cache )
    return free(a1, a2, a3, a4, a5, a6);
  return result;
}
// 4AAE98: using guessed type __int64 gconv_cache;

//----- (000000000044A630) ----------------------------------------------------
__int64 __fastcall known_compare(_QWORD *a1, _QWORD *a2)
{
  return j_strcmp_ifunc(*a1, *a2);
}
// 4010A0: using guessed type __int64 __fastcall j_strcmp_ifunc(_QWORD, _QWORD);

//----- (000000000044A640) ----------------------------------------------------
void __fastcall do_release_shlib(__int64 *a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // rbx
  int v7; // eax
  __int64 v8; // rdx
  int v9; // eax
  __int64 v10; // rdi

  if ( !(_DWORD)a2 || (_DWORD)a2 == 3 )
  {
    v6 = *a1;
    v7 = *(_DWORD *)(*a1 + 8);
    if ( release_handle == *a1 )
    {
      if ( v7 <= 0 )
        _assert_fail((__int64)"obj->counter > 0", (__int64)"gconv_dl.c", 0xAAu, "do_release_shlib");
      *(_DWORD *)(v6 + 8) = v7 - 1;
    }
    else
    {
      v8 = (unsigned int)(v7 + 2);
      if ( (unsigned int)v7 >= 0xFFFFFFFE || (_DWORD)v8 == 2 )
      {
        v9 = v7 - 1;
        *(_DWORD *)(v6 + 8) = v9;
        if ( v9 == -3 )
        {
          v10 = *(_QWORD *)(v6 + 16);
          if ( v10 )
          {
            _libc_dlclose(v10, a2, v8, a4, a5, a6);
            *(_QWORD *)(v6 + 16) = 0LL;
          }
        }
      }
    }
  }
}
// 4AAEA0: using guessed type __int64 release_handle;

//----- (000000000044A6C0) ----------------------------------------------------
__int64 __fastcall _gconv_find_shlib(__int64 a1)
{
  __int64 *v1; // rax
  __int64 v2; // rcx
  u32 *v3; // r8
  unsigned __int64 v4; // r9
  __int64 v5; // rbx
  int v6; // eax
  __int64 v7; // rdx
  __int64 v8; // rax
  __int64 v9; // rdx
  __int64 v10; // rcx
  __int64 v11; // r8
  __int64 v12; // r9
  __int64 v13; // rax
  __int64 v14; // rdx
  __int64 v15; // rcx
  __int64 v16; // r8
  __int64 v17; // r9
  __int64 v18; // rax
  __int64 v19; // rdi
  __int64 v20; // rdx
  __int64 v21; // rcx
  __int64 v22; // r8
  __int64 v23; // r9
  __int64 v24; // rax
  __int64 v25; // rdx
  __int64 v26; // rax
  __int64 v27; // rdx
  __int64 result; // rax
  __int64 v29; // r12
  __int64 v30; // rbp
  _QWORD *v31; // rdx
  __int64 v32; // rcx
  u32 *v33; // r8
  __int64 v34; // r9
  _QWORD *v35; // rax
  __int64 v36; // rax
  __int64 v37; // rcx
  u32 *v38; // r8
  __int64 v39; // r9
  __int64 v40; // rdx
  __int64 v41[4]; // [rsp+8h] [rbp-20h] BYREF

  v41[0] = a1;
  v1 = (__int64 *)tfind((__int64)v41, &loaded, (__int64 (__fastcall *)(__int64, _QWORD))known_compare);
  if ( v1 )
  {
    v5 = *v1;
    if ( !*v1 )
      return 0LL;
  }
  else
  {
    v29 = v41[0];
    v30 = j_strlen_ifunc(v41[0]);
    v35 = malloc(v30 + 49, (__int64)&loaded, v31, v32, v33, v34);
    v5 = (__int64)v35;
    if ( !v35 )
      return 0LL;
    v36 = j_memcpy(v35 + 6, v29, v30 + 1);
    *(_DWORD *)(v5 + 8) = -3;
    *(_QWORD *)v5 = v36;
    *(_QWORD *)(v5 + 16) = 0LL;
    if ( !tsearch(v5, &loaded, (__int64 (__fastcall *)(__int64, _QWORD))known_compare, v37, v38, v39) )
    {
      free(v5, (__int64)&loaded, v40, v2, v3, v4);
      return 0LL;
    }
  }
  v6 = *(_DWORD *)(v5 + 8);
  v7 = *(_QWORD *)(v5 + 16);
  if ( v6 >= -2 )
  {
    if ( v7 )
    {
      if ( v6 < 0 )
        v6 = 0;
      *(_DWORD *)(v5 + 8) = v6 + 1;
    }
    return v5;
  }
  if ( v7 )
    _assert_fail((__int64)"found->handle == NULL", (__int64)"gconv_dl.c", 0x72u, "__gconv_find_shlib");
  v8 = _libc_dlopen_mode(*(_QWORD *)v5, -2147483646, 0LL, v2, (__int64)v3, v4);
  *(_QWORD *)(v5 + 16) = v8;
  if ( v8 )
  {
    v13 = _libc_dlsym(v8, (__int64)"gconv", v9, v10, v11, v12);
    *(_QWORD *)(v5 + 24) = v13;
    if ( v13 )
    {
      v18 = _libc_dlsym(*(_QWORD *)(v5 + 16), (__int64)"gconv_init", v14, v15, v16, v17);
      v19 = *(_QWORD *)(v5 + 16);
      *(_QWORD *)(v5 + 32) = v18;
      v24 = _libc_dlsym(v19, (__int64)"gconv_end", v20, v21, v22, v23);
      v25 = *(_QWORD *)(v5 + 24);
      *(_DWORD *)(v5 + 8) = 1;
      v26 = __ROL8__(__readfsqword(0x30u) ^ v24, 17);
      *(_QWORD *)(v5 + 24) = __ROL8__(__readfsqword(0x30u) ^ v25, 17);
      v27 = *(_QWORD *)(v5 + 32);
      *(_QWORD *)(v5 + 40) = v26;
      result = v5;
      *(_QWORD *)(v5 + 32) = __ROL8__(__readfsqword(0x30u) ^ v27, 17);
      return result;
    }
    release_handle = v5;
    v5 = 0LL;
    twalk(loaded, (void (__fastcall *)(__int64, _QWORD))do_release_shlib);
    return v5;
  }
  return 0LL;
}
// 44A71F: variable 'v2' is possibly undefined
// 44A71F: variable 'v3' is possibly undefined
// 44A71F: variable 'v4' is possibly undefined
// 44A73B: variable 'v9' is possibly undefined
// 44A73B: variable 'v10' is possibly undefined
// 44A73B: variable 'v11' is possibly undefined
// 44A73B: variable 'v12' is possibly undefined
// 44A758: variable 'v14' is possibly undefined
// 44A758: variable 'v15' is possibly undefined
// 44A758: variable 'v16' is possibly undefined
// 44A758: variable 'v17' is possibly undefined
// 44A76C: variable 'v20' is possibly undefined
// 44A76C: variable 'v21' is possibly undefined
// 44A76C: variable 'v22' is possibly undefined
// 44A76C: variable 'v23' is possibly undefined
// 44A7FC: variable 'v31' is possibly undefined
// 44A7FC: variable 'v32' is possibly undefined
// 44A7FC: variable 'v33' is possibly undefined
// 44A7FC: variable 'v34' is possibly undefined
// 44A83C: variable 'v37' is possibly undefined
// 44A83C: variable 'v38' is possibly undefined
// 44A83C: variable 'v39' is possibly undefined
// 44A84D: variable 'v40' is possibly undefined
// 401040: using guessed type __int64 __fastcall j_memcpy(_QWORD, _QWORD, _QWORD);
// 4010C8: using guessed type __int64 __fastcall j_strlen_ifunc(_QWORD);
// 4AAEA0: using guessed type __int64 release_handle;
// 4AAEA8: using guessed type __int64 loaded;
// 44A6C0: using guessed type __int64 var_20[4];

//----- (000000000044A8A0) ----------------------------------------------------
__int64 __fastcall _gconv_release_shlib(__int64 a1)
{
  release_handle = a1;
  return twalk(loaded, (void (__fastcall *)(__int64, _QWORD))do_release_shlib);
}
// 4AAEA0: using guessed type __int64 release_handle;
// 4AAEA8: using guessed type __int64 loaded;

//----- (000000000044A8C0) ----------------------------------------------------
const char *__fastcall new_composite_name(int a1, __int64 a2)
{
  __int64 v2; // r14
  _BOOL4 v3; // er13
  unsigned __int64 v4; // r12
  char *v5; // rbp
  _QWORD *v6; // rdx
  __int64 v7; // rcx
  u32 *v8; // r8
  __int64 v9; // r9
  __int64 v10; // r15
  char *v11; // rbp
  _QWORD *v12; // rdx
  u32 *v13; // r8
  __int64 v14; // r9
  const char *v16; // rdi
  __int64 i; // r15
  _BYTE *v18; // rax
  _BYTE *v19; // rax
  _QWORD *v20; // rax
  char **v21; // [rsp+0h] [rbp-48h]
  const char *v22; // [rsp+8h] [rbp-40h]

  v2 = 0LL;
  v3 = 1;
  v4 = 0LL;
  v21 = (char **)a2;
  while ( 1 )
  {
    if ( v2 != 6 )
    {
      if ( a1 == 6 )
      {
        v5 = v21[v2];
      }
      else if ( a1 == (_DWORD)v2 )
      {
        v5 = *v21;
      }
      else
      {
        v5 = off_4A9AE0[v2];
      }
      v10 = j_strlen_ifunc(v5);
      v4 += v10 + nl_category_name_sizes[v2] + 2LL;
      if ( v3 )
      {
        a2 = (__int64)*v21;
        if ( *v21 != v5 )
          v3 = j_strcmp_ifunc(v5, a2) == 0;
      }
      if ( (_DWORD)v2 == 12 )
        break;
    }
    ++v2;
  }
  if ( !v3 )
  {
    v22 = (const char *)malloc(v4, a2, v6, v7, v8, v9);
    v16 = v22;
    if ( v22 )
    {
      for ( i = 0LL; ; ++i )
      {
        if ( i != 6 )
        {
          v18 = (_BYTE *)j_stpcpy(v16);
          *v18 = 61;
          v19 = (_BYTE *)j_stpcpy(v18 + 1);
          v16 = v19 + 1;
          *v19 = 59;
          if ( (_DWORD)i == 12 )
            break;
        }
      }
      *v19 = 0;
      return v22;
    }
    return 0LL;
  }
  v11 = *v21;
  if ( !(unsigned int)j_strcmp_ifunc(*v21, "C") )
    return "C";
  v22 = "C";
  if ( !(unsigned int)j_strcmp_ifunc(v11, "POSIX") )
    return v22;
  v20 = malloc(v10 + 1, (__int64)"POSIX", v12, (__int64)"C", v13, v14);
  if ( !v20 )
    return 0LL;
  return (const char *)j_memcpy(v20, v11, v10 + 1);
}
// 44A9E3: variable 'v6' is possibly undefined
// 44A9E3: variable 'v7' is possibly undefined
// 44A9E3: variable 'v8' is possibly undefined
// 44A9E3: variable 'v9' is possibly undefined
// 44AA87: variable 'v12' is possibly undefined
// 44AA87: variable 'v13' is possibly undefined
// 44AA87: variable 'v14' is possibly undefined
// 401040: using guessed type __int64 __fastcall j_memcpy(_QWORD, _QWORD, _QWORD);
// 401058: using guessed type __int64 __fastcall j_stpcpy(_QWORD);
// 4010A0: using guessed type __int64 __fastcall j_strcmp_ifunc(_QWORD, _QWORD);
// 4010C8: using guessed type __int64 __fastcall j_strlen_ifunc(_QWORD);
// 484F00: using guessed type unsigned __int8 nl_category_name_sizes[16];
// 4A9AE0: using guessed type char *off_4A9AE0[13];

//----- (000000000044AAC0) ----------------------------------------------------
char **__fastcall setlocale(int a1, const char *a2)
{
  __int64 v2; // rbp
  const char *v3; // rbx
  char *v5; // r15
  __int64 *v6; // rsi
  char *v8; // rax
  __int64 i; // rax
  int v10; // er15
  __int64 k; // rbx
  __int64 *v12; // rsi
  char **locale; // rax
  __int64 v14; // rdx
  char *v15; // rcx
  u32 *v16; // r8
  unsigned __int64 v17; // r9
  __int64 j; // r14
  void (__fastcall *v19)(); // rcx
  const char *v20; // rdi
  char **v21; // rax
  __int64 v22; // rdx
  __int64 v23; // rcx
  u32 *v24; // r8
  unsigned __int64 v25; // r9
  char **v26; // r15
  char *v27; // rbx
  void (__fastcall *v28)(); // rax
  char **v29; // r14
  const char *v30; // rdi
  const char *v31; // rdi
  __int64 v32; // rdx
  __int64 v33; // rcx
  u32 *v34; // r8
  unsigned __int64 v35; // r9
  __int64 m; // rax
  __int64 v37; // rax
  int v38; // eax
  __int64 v39; // rsi
  __int64 v40; // rax
  __int64 v41; // rdx
  __int64 v42; // rcx
  u32 *v43; // r8
  unsigned __int64 v44; // r9
  __int64 n; // r13
  int v46; // eax
  _BYTE *v47; // rax
  __int64 v48; // [rsp+0h] [rbp-148h]
  __int64 v49; // [rsp+0h] [rbp-148h]
  __int64 v50; // [rsp+0h] [rbp-148h]
  unsigned __int64 v51; // [rsp+0h] [rbp-148h]
  _BYTE *v52; // [rsp+8h] [rbp-140h]
  __int64 v53; // [rsp+10h] [rbp-138h]
  __int64 v54; // [rsp+18h] [rbp-130h]
  const char *v55; // [rsp+20h] [rbp-128h] BYREF
  __int64 *v56; // [rsp+28h] [rbp-120h] BYREF
  __int64 v57[14]; // [rsp+30h] [rbp-118h] BYREF
  __int64 v58[21]; // [rsp+A0h] [rbp-A8h] BYREF

  v2 = a1;
  v58[13] = __readfsqword(0x28u);
  if ( (unsigned __int64)a1 > 0xC )
    goto LABEL_81;
  v3 = a2;
  if ( !a2 )
    return nl_global_locale[a1 + 16];
  v5 = (char *)nl_global_locale[v2 + 16];
  v6 = (__int64 *)v5;
  if ( (unsigned int)j_strcmp_ifunc(a2, v5) )
  {
    v55 = 0LL;
    v56 = 0LL;
    v8 = getenv("LOCPATH");
    if ( v8 )
    {
      if ( *v8 )
      {
        if ( (unsigned int)argz_create_sep(v8, 58LL, (unsigned __int64 *)&v55, (__int64 *)&v56) )
          return 0LL;
        v6 = (__int64 *)&v56;
        if ( (unsigned int)argz_add_sep((__int64 *)&v55, &v56, "/usr/lib/locale", 58) )
          return 0LL;
      }
    }
    if ( (_DWORD)v2 == 6 )
    {
      for ( i = 0LL; ; ++i )
      {
        if ( i != 6 )
        {
          v57[i] = (__int64)v3;
          if ( (_DWORD)i == 12 )
            break;
        }
      }
      v53 = j_strchr_ifunc(v3, 59LL);
      if ( !v53 )
      {
LABEL_13:
        v10 = 13;
LABEL_14:
        while ( 2 )
        {
          LODWORD(k) = v10 - 1;
          if ( v10 )
          {
            while ( 1 )
            {
              if ( (_DWORD)k == 6 )
              {
                v10 = 5;
              }
              else
              {
                v38 = k;
                LODWORD(k) = v10;
                v10 = v38;
              }
              v12 = v56;
              locale = nl_find_locale(v55, (__int64)v56, v10, &v57[v10]);
              v58[v10] = (__int64)locale;
              if ( !locale )
              {
                if ( (const char *)v57[v10] == "C" )
                  goto LABEL_14;
                goto LABEL_65;
              }
              if ( *((_DWORD *)locale + 12) != -1 )
                *((_DWORD *)locale + 12) = -1;
              if ( (const char *)v57[v10] == "C" )
                goto LABEL_14;
              v48 = v57[v10];
              v12 = (__int64 *)nl_global_locale[v10 + 16];
              if ( (unsigned int)j_strcmp_ifunc(v48, v12) )
                break;
              LODWORD(k) = v10 - 1;
              v57[v10] = (__int64)v12;
              if ( !v10 )
                goto LABEL_23;
            }
            v37 = strdup(v48, (__int64)v12);
            v57[v10] = v37;
            if ( v37 )
              continue;
LABEL_65:
            if ( (_DWORD)k == 13 )
              goto LABEL_73;
          }
          else
          {
LABEL_23:
            v12 = v57;
            v5 = (char *)new_composite_name(6, (__int64)v57);
            if ( v5 )
            {
              for ( j = 0LL; ; ++j )
              {
                if ( j != 6 )
                {
                  if ( nl_current_used[j] )
                  {
                    nl_global_locale[j] = (char **)v58[j];
                    v19 = (void (__fastcall *)())nl_category_postload[j];
                    if ( v19 )
                      v19();
                  }
                  v15 = (char *)v57[j];
                  v20 = off_4A9AE0[j];
                  if ( v15 != v20 )
                  {
                    if ( v20 != "C" )
                    {
                      v49 = v57[j];
                      free((__int64)v20, (__int64)v57, v14, (__int64)v15, v16, v17);
                      v15 = (char *)v49;
                    }
                    off_4A9AE0[j] = v15;
                  }
                  if ( (_DWORD)j == 12 )
                    break;
                }
              }
              if ( v5 != off_4A9B10[0] )
              {
                if ( off_4A9B10[0] != "C" )
                  free((__int64)off_4A9B10[0], (__int64)v57, v14, (__int64)v15, v16, v17);
                off_4A9B10[0] = v5;
              }
              ++nl_msg_cat_cntr;
LABEL_74:
              free((__int64)v55, (__int64)v12, v14, (__int64)v15, v16, v17);
              free(v53, (__int64)v12, v32, v33, v34, v35);
              return (char **)v5;
            }
            LODWORD(k) = 0;
          }
          break;
        }
        for ( k = (int)k; ; ++k )
        {
          if ( (_DWORD)k != 6 )
          {
            v31 = (const char *)v57[k];
            if ( v31 != "C" && v31 != off_4A9AE0[k] )
              free((__int64)v31, (__int64)v12, v14, (__int64)v15, v16, v17);
            if ( (_DWORD)k == 12 )
              break;
          }
        }
LABEL_73:
        v5 = 0LL;
        goto LABEL_74;
      }
      v53 = strdup((__int64)v3, 59LL);
      v52 = (_BYTE *)v53;
      if ( !v53 )
        return 0LL;
LABEL_90:
      v39 = 61LL;
      v40 = j_strchr_ifunc(v52, 61LL);
      v44 = v40;
      v54 = v40;
      if ( !v40 )
      {
LABEL_75:
        for ( m = 0LL; ; ++m )
        {
          if ( m != 6 )
          {
            if ( (const char *)v57[m] == v3 )
              goto LABEL_80;
            if ( (_DWORD)m == 12 )
              goto LABEL_13;
          }
        }
      }
      v44 = v40 - (_QWORD)v52;
      for ( n = 0LL; ; ++n )
      {
        if ( n != 6 )
        {
          if ( nl_category_name_sizes[n] == v44 )
          {
            v51 = v44;
            v39 = (__int64)&nl_category_names[nl_category_name_idxs[n]];
            v46 = j_memcmp_ifunc(v52, v39, v44);
            v44 = v51;
            if ( !v46 )
            {
              v39 = 59LL;
              v57[(int)n] = v54 + 1;
              v47 = (_BYTE *)j_strchr_ifunc(v54 + 1, 59LL);
              if ( !v47 )
                goto LABEL_75;
              *v47 = 0;
              v52 = v47 + 1;
              goto LABEL_90;
            }
          }
          if ( (_DWORD)n == 12 )
            break;
        }
      }
LABEL_80:
      free(v53, v39, v41, v42, v43, v44);
LABEL_81:
      v5 = 0LL;
      __writefsdword(0xFFFFFFC0, 0x16u);
      return (char **)v5;
    }
    v58[0] = (__int64)v3;
    v50 = nl_current_used[v2];
    if ( v50 )
    {
      v6 = v56;
      v21 = nl_find_locale(v55, (__int64)v56, v2, v58);
      v26 = v21;
      if ( !v21 )
        goto LABEL_85;
      v3 = (const char *)v58[0];
      if ( *((_DWORD *)v21 + 12) != -1 )
        *((_DWORD *)v21 + 12) = -1;
    }
    else
    {
      v26 = 0LL;
    }
    if ( v3 == "C" || (v58[0] = strdup((__int64)v3, (__int64)v6)) != 0 )
    {
      v6 = v58;
      v27 = (char *)new_composite_name(v2, (__int64)v58);
      if ( v27 )
      {
        if ( v50 )
        {
          nl_global_locale[v2] = v26;
          v28 = (void (__fastcall *)())nl_category_postload[v2];
          if ( v28 )
            v28();
        }
        v29 = (char **)v58[0];
        v30 = (const char *)nl_global_locale[v2 + 16];
        if ( (const char *)v58[0] != v30 )
        {
          if ( v30 != "C" )
            free((__int64)v30, (__int64)v58, v22, v23, v24, v25);
          nl_global_locale[v2 + 16] = v29;
        }
        if ( v27 != off_4A9B10[0] )
        {
          if ( off_4A9B10[0] != "C" )
            free((__int64)off_4A9B10[0], (__int64)v58, v22, v23, v24, v25);
          off_4A9B10[0] = v27;
        }
        ++nl_msg_cat_cntr;
        goto LABEL_59;
      }
      if ( (const char *)v58[0] != "C" )
        free(v58[0], (__int64)v58, v22, v23, v24, v25);
    }
LABEL_85:
    v58[0] = 0LL;
LABEL_59:
    free((__int64)v55, (__int64)v6, v22, v23, v24, v25);
    return (char **)v58[0];
  }
  return (char **)v5;
}
// 44AD16: variable 'v14' is possibly undefined
// 44AD16: variable 'v16' is possibly undefined
// 44AD16: variable 'v17' is possibly undefined
// 44AE33: variable 'v22' is possibly undefined
// 44AE33: variable 'v23' is possibly undefined
// 44AE33: variable 'v24' is possibly undefined
// 44AE33: variable 'v25' is possibly undefined
// 44AF59: variable 'v15' is possibly undefined
// 44AF8B: variable 'v32' is possibly undefined
// 44AF8B: variable 'v33' is possibly undefined
// 44AF8B: variable 'v34' is possibly undefined
// 44AF8B: variable 'v35' is possibly undefined
// 44AFE5: variable 'v41' is possibly undefined
// 44AFE5: variable 'v42' is possibly undefined
// 44AFE5: variable 'v43' is possibly undefined
// 44AFE5: variable 'v44' is possibly undefined
// 401080: using guessed type __int64 __fastcall j_memcmp_ifunc(_QWORD, _QWORD, _QWORD);
// 4010A0: using guessed type __int64 __fastcall j_strcmp_ifunc(_QWORD, _QWORD);
// 4010D0: using guessed type __int64 __fastcall j_strchr_ifunc(_QWORD, _QWORD);
// 484F00: using guessed type unsigned __int8 nl_category_name_sizes[16];
// 484F10: using guessed type unsigned __int8 nl_category_name_idxs[16];
// 4A7C60: using guessed type __int64 (__fastcall *nl_category_postload[16])();
// 4A7CE0: using guessed type _QWORD nl_current_used[16];
// 4A9A60: using guessed type char **nl_global_locale[6];
// 4A9AE0: using guessed type char *off_4A9AE0[13];
// 4A9B10: using guessed type char *off_4A9B10[7];
// 4AB808: using guessed type int nl_msg_cat_cntr;
// 44AAC0: using guessed type __int64 var_118[14];

//----- (000000000044B190) ----------------------------------------------------
unsigned __int64 __fastcall strip(_BYTE *a1, char *a2)
{
  char v2; // dl
  int v3; // er9
  unsigned __int64 result; // rax
  int v5; // ecx

  v2 = *a2;
  if ( !*a2 )
  {
    result = (unsigned __int64)(a1 + 1);
    *a1 = 47;
    a1[1] = 47;
    a1[2] = 0;
    return result;
  }
  v3 = 0;
  do
  {
    while ( 1 )
    {
      result = (word_486FE0[v2] >> 3) & 1;
      if ( (unsigned __int8)(v2 - 44) <= 0x33u )
        result = (0x8000000004007uLL >> (v2 - 44)) & 1 | (unsigned int)result;
      v5 = v3 + 1;
      if ( !(_BYTE)result )
        break;
      result = dword_4866E0[v2];
      *a1++ = result;
LABEL_4:
      v2 = *++a2;
      if ( !*a2 )
        goto LABEL_11;
    }
    if ( v2 != 47 )
      goto LABEL_4;
    if ( v3 == 2 )
      goto LABEL_14;
    ++a2;
    *a1 = 47;
    result = (unsigned int)(v3 + 2);
    ++a1;
    v2 = *a2;
    ++v3;
    v5 = result;
  }
  while ( *a2 );
LABEL_11:
  if ( v3 <= 1 )
  {
    result = (unsigned __int64)(a1 + 1);
    *a1 = 47;
    if ( v5 == 1 )
    {
      *(_BYTE *)result = 47;
      a1 += 2;
    }
    else
    {
      ++a1;
    }
  }
LABEL_14:
  *a1 = 0;
  return result;
}
// 4866E0: using guessed type unsigned int dword_4866E0[256];
// 486FE0: using guessed type _WORD word_486FE0[256];

//----- (000000000044B270) ----------------------------------------------------
char **__fastcall nl_find_locale(const char *a1, __int64 a2, int a3, __int64 *a4)
{
  __int64 v6; // rbx
  const char *v7; // r14
  unsigned __int64 v8; // rax
  unsigned __int64 v9; // r13
  __int64 v10; // rdx
  __int64 v11; // rcx
  u32 *v12; // r8
  u32 v13; // er9
  const char *v14; // rdi
  __int64 v15; // rdx
  __int64 v16; // rcx
  u32 *v17; // r8
  u32 v18; // er9
  __int64 locale_from_archive; // r12
  char *v21; // rax
  char *v22; // rax
  char *v23; // rax
  const char *v24; // r14
  __int64 v25; // rax
  __int64 v26; // rdx
  __int16 v27; // cx
  __int64 *v28; // rax
  unsigned int v29; // ecx
  void *v30; // rsp
  unsigned __int8 *v31; // rax
  int v32; // eax
  __int64 v33; // r10
  const char *v34; // rsi
  __int64 *l10nflist; // rax
  __int64 v36; // rdx
  __int64 v37; // rcx
  u32 *v38; // r8
  unsigned __int64 v39; // r9
  char v40; // r11
  __int64 *v41; // r14
  __int64 v42; // rdx
  __int64 v43; // rax
  char *v44; // rbx
  __int64 v45; // rax
  __int64 *v46; // rcx
  void *v47; // rsp
  char *v48; // r13
  __int64 v49; // rax
  unsigned __int8 *v50; // rcx
  void *v51; // rsp
  unsigned __int8 *v52; // rax
  unsigned int v53; // edx
  unsigned __int8 *v54; // rax
  unsigned int v55; // edx
  int v56; // eax
  unsigned int v57; // eax
  int v58; // edx
  __int64 *v59; // rax
  __int64 v60; // rdi
  __int64 **v61; // r13
  __int64 *v62; // rax
  __int64 v63; // rax
  __int64 v64; // rdi
  __int64 v65; // rsi
  __int64 v66; // [rsp+0h] [rbp-3098h]
  __int64 v67; // [rsp+8h] [rbp-3090h] BYREF
  unsigned __int8 v68[4088]; // [rsp+10h] [rbp-3088h] BYREF
  __int64 v69; // [rsp+1008h] [rbp-2090h] BYREF
  unsigned __int8 v70[7]; // [rsp+1010h] [rbp-2088h] BYREF
  __int64 v71; // [rsp+1FF8h] [rbp-10A0h]
  __int64 v72; // [rsp+2000h] [rbp-1098h]
  __int64 v73; // [rsp+2008h] [rbp-1090h] BYREF
  __int64 v74; // [rsp+2010h] [rbp-1088h] BYREF
  __int64 v75; // [rsp+3008h] [rbp-90h] BYREF
  char *v76; // [rsp+3010h] [rbp-88h]
  int v77; // [rsp+301Ch] [rbp-7Ch]
  __int64 v78; // [rsp+3020h] [rbp-78h]
  const char *v79; // [rsp+3030h] [rbp-68h] BYREF
  unsigned __int8 *v80; // [rsp+3038h] [rbp-60h] BYREF
  __int64 v81; // [rsp+3040h] [rbp-58h] BYREF
  unsigned __int8 *v82; // [rsp+3048h] [rbp-50h] BYREF
  char *v83; // [rsp+3050h] [rbp-48h] BYREF
  __int64 v84[8]; // [rsp+3058h] [rbp-40h] BYREF

  v6 = a3;
  v78 = a2;
  v7 = (const char *)*a4;
  v84[1] = __readfsqword(0x28u);
  v79 = v7;
  if ( !*v7 )
  {
    v21 = getenv("LC_ALL");
    v79 = v21;
    if ( v21 && *v21 || (v23 = getenv(&nl_category_names[nl_category_name_idxs[(int)v6]]), (v79 = v23) != 0LL) && *v23 )
    {
      v22 = (char *)v79;
    }
    else
    {
      v22 = getenv("LANG");
      v79 = v22;
      if ( !v22 )
        goto LABEL_26;
    }
    if ( *v22 )
    {
      v7 = v79;
      goto LABEL_2;
    }
LABEL_26:
    v7 = "C";
    v79 = "C";
  }
LABEL_2:
  if ( !(unsigned int)j_strcmp_ifunc(v7, "C") || !(unsigned int)j_strcmp_ifunc(v7, "POSIX") )
  {
    *a4 = (__int64)"C";
    return nl_C[v6];
  }
  v8 = j_strlen_ifunc(v7);
  v9 = v8;
  if ( v8 > 0xFF || memmem((__int64)v7, v8, "/../", 4uLL) )
    goto LABEL_17;
  if ( v9 == 2 )
  {
    if ( *v7 == 46 )
    {
      if ( v7[1] == 46 || j_memchr_ifunc(v7, 47LL, 2LL) )
        goto LABEL_17;
      goto LABEL_11;
    }
  }
  else if ( v9 > 2
         && (*v7 == 46 && v7[1] == 46 && v7[2] == 47 || v7[v9 - 3] == 47 && v7[v9 - 2] == 46 && v7[v9 - 1] == 46) )
  {
    goto LABEL_17;
  }
  if ( j_memchr_ifunc(v7, 47LL, v9) && *v7 != 47 )
  {
LABEL_17:
    locale_from_archive = 0LL;
    __writefsdword(0xFFFFFFC0, 0x16u);
    return (char **)locale_from_archive;
  }
LABEL_11:
  v14 = v79;
  *a4 = (__int64)v79;
  if ( a1 )
  {
    v79 = (const char *)nl_expand_alias((__int64)v14, 47LL, v10, v11, v12, v13);
    v24 = v79;
    goto LABEL_29;
  }
  locale_from_archive = nl_load_locale_from_archive(v6, a4, v10);
  if ( locale_from_archive )
    return (char **)locale_from_archive;
  v79 = (const char *)nl_expand_alias(*a4, (__int64)a4, v15, v16, v17, v18);
  if ( v79 )
  {
    locale_from_archive = nl_load_locale_from_archive(v6, (__int64 *)&v79, v58);
    if ( locale_from_archive )
      return (char **)locale_from_archive;
    v24 = v79;
    v78 = 16LL;
    a1 = "/usr/lib/locale";
LABEL_29:
    if ( v24 )
      goto LABEL_30;
    goto LABEL_69;
  }
  v78 = 16LL;
  a1 = "/usr/lib/locale";
LABEL_69:
  v24 = (const char *)*a4;
  v79 = (const char *)*a4;
LABEL_30:
  v25 = j_strlen_ifunc(v24);
  v26 = v25 + 1;
  v27 = (v25 + 24) & 0xFFF0;
  v28 = (__int64 *)((char *)&v75 - ((v25 + 24) & 0xFFFFFFFFFFFFF000LL));
  if ( &v75 != v28 )
  {
    while ( &v73 != v28 )
      ;
  }
  v29 = v27 & 0xFFF;
  if ( v29 )
  {
    v30 = alloca(v29);
    *(__int64 *)((char *)&v72 + v29) = *(__int64 *)((char *)&v72 + v29);
  }
  v31 = (unsigned __int8 *)j_memcpy(&v74, v24, v26);
  v32 = nl_explode_name(v31, &v80, &v81, &v82, &v83, v84);
  if ( v32 == -1 )
    return 0LL;
  v71 = 0LL;
  v33 = nl_category_name_idxs[(int)v6];
  v34 = a1;
  v77 = v32;
  v76 = &nl_category_names[v33];
  l10nflist = nl_make_l10nflist(
                (__int64 **)&nl_locale_file_list[(int)v6],
                (__int64)a1,
                v78,
                v32,
                (__int64)v80,
                (__int64)v82,
                (__int64)v83,
                v84[0],
                v81,
                (__int64)&nl_category_names[v33],
                0);
  v40 = v77;
  v41 = l10nflist;
  if ( !l10nflist )
  {
    v34 = a1;
    v59 = nl_make_l10nflist(
            (__int64 **)&nl_locale_file_list[(int)v6],
            (__int64)a1,
            v78,
            v77,
            (__int64)v80,
            (__int64)v82,
            (__int64)v83,
            v84[0],
            v81,
            (__int64)v76,
            1);
    v40 = v77;
    v41 = v59;
    if ( !v59 )
      return 0LL;
  }
  if ( (v40 & 1) != 0 )
    free(v84[0], (__int64)v34, v36, v37, v38, v39);
  LODWORD(v42) = *((_DWORD *)v41 + 2);
  if ( !(_DWORD)v42 )
    nl_load_locale((const char **)v41, v6, 0);
  locale_from_archive = v41[2];
  if ( !locale_from_archive )
  {
    v60 = v41[4];
    if ( !v60 )
    {
LABEL_91:
      v41[4] = 0LL;
      return (char **)locale_from_archive;
    }
    v61 = (__int64 **)(v41 + 4);
    while ( 1 )
    {
      if ( !*(_DWORD *)(v60 + 8) )
        nl_load_locale((const char **)v60, v6, v42);
      v62 = *v61;
      v42 = (*v61)[2];
      if ( v42 )
        break;
      v60 = (__int64)*++v61;
      if ( !*v61 )
        goto LABEL_91;
    }
    v41[4] = (__int64)v62;
    locale_from_archive = v42;
    v41 = v62;
  }
  if ( v83 )
  {
    v43 = codeset_idx_10299[(int)v6];
    v44 = *(char **)(locale_from_archive + 8 * v43 + 64);
    if ( !v44 )
      _assert_fail((__int64)"locale_codeset != NULL", (__int64)"findlocale.c", 0x11Eu, "_nl_find_locale");
    v45 = j_strlen_ifunc(*(_QWORD *)(locale_from_archive + 8 * v43 + 64));
    v46 = (__int64 *)((char *)&v73 - ((v45 + 26) & 0xFFFFFFFFFFFFF000LL));
    if ( &v73 != v46 )
    {
      while ( &v69 != v46 )
        ;
    }
    if ( (((_WORD)v45 + 26) & 0xFF0) != 0 )
    {
      v47 = alloca(((_WORD)v45 + 26) & 0xFF0);
      *(_QWORD *)&v68[(((_WORD)v45 + 26) & 0xFF0) + 4080] = *(_QWORD *)&v68[(((_WORD)v45 + 26) & 0xFF0) + 4080];
    }
    strip(v70, v44);
    v48 = v83;
    v49 = j_strlen_ifunc(v83);
    v50 = &v70[-((v49 + 26) & 0xFFFFFFFFFFFFF000LL) - 8];
    if ( &v69 != (__int64 *)v50 )
    {
      while ( &v67 != (__int64 *)v50 )
        ;
    }
    if ( (((_WORD)v49 + 26) & 0xFF0) != 0 )
    {
      v51 = alloca(((_WORD)v49 + 26) & 0xFF0);
      *(__int64 *)((char *)&v66 + (((_WORD)v49 + 26) & 0xFF0)) = *(__int64 *)((char *)&v66 + (((_WORD)v49 + 26) & 0xFF0));
    }
    strip(v68, v48);
    v52 = v70;
    do
    {
      v53 = dword_4866E0[(char)*v52++];
      *(v52 - 1) = v53;
    }
    while ( (_BYTE)v53 );
    v54 = v68;
    do
    {
      v55 = dword_4866E0[(char)*v54++];
      *(v54 - 1) = v55;
    }
    while ( (_BYTE)v55 );
    if ( (unsigned int)_gconv_compare_alias(v68, v70) )
      return 0LL;
    locale_from_archive = v41[2];
  }
  if ( !*(_QWORD *)locale_from_archive )
  {
    v63 = j_strrchr_ifunc(*v41, 47LL);
    v64 = v63 - 1;
    if ( *(_BYTE *)(v63 - 2) == 47 )
    {
      v65 = 1LL;
    }
    else
    {
      do
        --v64;
      while ( *(_BYTE *)(v64 - 1) != 47 );
      v65 = v63 - v64;
    }
    *(_QWORD *)locale_from_archive = strndup(v64, v65);
  }
  if ( v81 )
  {
    v56 = j_strcasecmp_l(v81, "TRANSLIT", nl_C_locobj);
    locale_from_archive = v41[2];
    if ( !v56 )
      *(_DWORD *)(locale_from_archive + 52) = 1;
  }
  else
  {
    locale_from_archive = v41[2];
  }
  v57 = *(_DWORD *)(locale_from_archive + 48);
  if ( v57 <= 0xFFFFFFFD )
    *(_DWORD *)(locale_from_archive + 48) = v57 + 1;
  return (char **)locale_from_archive;
}
// 44B367: variable 'v10' is possibly undefined
// 44B480: variable 'v11' is possibly undefined
// 44B480: variable 'v12' is possibly undefined
// 44B480: variable 'v13' is possibly undefined
// 44B884: variable 'v36' is possibly undefined
// 44B884: variable 'v37' is possibly undefined
// 44B884: variable 'v38' is possibly undefined
// 44B884: variable 'v39' is possibly undefined
// 44B773: variable 'v15' is possibly undefined
// 44B773: variable 'v16' is possibly undefined
// 44B773: variable 'v17' is possibly undefined
// 44B773: variable 'v18' is possibly undefined
// 44B787: variable 'v58' is possibly undefined
// 44B8CB: variable 'v42' is possibly undefined
// 401040: using guessed type __int64 __fastcall j_memcpy(_QWORD, _QWORD, _QWORD);
// 401050: using guessed type __int64 __fastcall j_strrchr_ifunc(_QWORD, _QWORD);
// 401068: using guessed type __int64 __fastcall j_memchr_ifunc(_QWORD, _QWORD, _QWORD);
// 401088: using guessed type __int64 __fastcall j_strcasecmp_l(_QWORD, _QWORD, _QWORD);
// 4010A0: using guessed type __int64 __fastcall j_strcmp_ifunc(_QWORD, _QWORD);
// 4010C8: using guessed type __int64 __fastcall j_strlen_ifunc(_QWORD);
// 484F10: using guessed type unsigned __int8 nl_category_name_idxs[16];
// 485000: using guessed type int codeset_idx_10299[16];
// 4866E0: using guessed type unsigned int dword_4866E0[256];
// 4A7D60: using guessed type char **nl_C[6];
// 4A7DE0: using guessed type char **nl_C_locobj[6];
// 4AB9A0: using guessed type _QWORD nl_locale_file_list[13];

//----- (000000000044B970) ----------------------------------------------------
void __fastcall nl_remove_locale(int a1, size_t a2, __int64 a3, __int64 a4, u32 *a5, unsigned __int64 a6)
{
  __int64 i; // rax

  if ( (*(_DWORD *)(a2 + 48))-- == 1 )
  {
    if ( *(_DWORD *)(a2 + 24) != 2 )
    {
      for ( i = nl_locale_file_list[a1]; *(_QWORD *)(i + 16) != a2; i = *(_QWORD *)(i + 24) )
        ;
      *(_DWORD *)(i + 8) = 0;
      *(_QWORD *)(i + 16) = 0LL;
    }
    nl_unload_locale(a2, a2, a3, a4, a5, a6);
  }
}
// 4AB9A0: using guessed type _QWORD nl_locale_file_list[13];

//----- (000000000044B9D0) ----------------------------------------------------
_QWORD *__fastcall nl_intern_locale_data(
        unsigned int a1,
        unsigned int *a2,
        _QWORD *a3,
        __int64 a4,
        __int64 a5,
        __int64 a6)
{
  __int64 v6; // rcx
  int v7; // eax
  unsigned __int64 v8; // r14
  _QWORD *result; // rax
  __int64 v11; // rdx
  u32 *v12; // r8
  unsigned __int64 v13; // r9
  unsigned __int64 v14; // rcx

  if ( (unsigned __int64)a3 <= 7 )
    goto LABEL_11;
  v6 = *a2;
  v7 = 537202711;
  if ( a1 != 3 )
  {
    a5 = 537462560LL;
    v7 = a1 ^ 0x20031115;
    if ( !a1 )
      v7 = 537462560;
  }
  if ( (_DWORD)v6 != v7 )
    goto LABEL_11;
  v8 = a2[1];
  if ( v8 < nl_category_num_items[a1] || 4 * v8 + 8 >= (unsigned __int64)a3 )
    goto LABEL_11;
  result = malloc(8 * v8 + 64, (__int64)a2, a3, v6, (u32 *)a5, a6);
  if ( result )
  {
    result[1] = a2;
    result[2] = a3;
    result[4] = 0LL;
    result[5] = 0LL;
    result[6] = 0LL;
    *((_DWORD *)result + 14) = v8;
    if ( v8 )
    {
      v14 = a2[2];
      if ( v14 <= (unsigned __int64)a3 )
      {
        if ( a1 <= 0xC )
          __asm { jmp     rsi }
        _assert_fail((__int64)"category == LC_CTYPE", (__int64)"loadlocale.c", 0x90u, "_nl_intern_locale_data");
      }
      free((__int64)result, (__int64)a2, v11, v14, v12, v13);
LABEL_11:
      __writefsdword(0xFFFFFFC0, 0x16u);
      return 0LL;
    }
  }
  return result;
}
// 44BBD2: conditional instruction was optimized away because ebx.4>=Du
// 44BAA4: variable 'v11' is possibly undefined
// 44BAA4: variable 'v12' is possibly undefined
// 44BAA4: variable 'v13' is possibly undefined
// 4856E0: using guessed type _QWORD nl_category_num_items[14];

//----- (000000000044BC20) ----------------------------------------------------
unsigned __int64 __fastcall nl_load_locale(const char **a1, unsigned int a2, int a3)
{
  signed int v5; // eax
  unsigned int v6; // er14
  __int64 st_size; // rsi
  unsigned int v8; // er15
  _QWORD *v9; // rdx
  __int64 v10; // rcx
  u32 *v11; // r8
  __int64 v12; // r9
  unsigned int *v13; // r12
  __int64 v14; // rcx
  __int64 v15; // r8
  __int64 v16; // r9
  _QWORD *v17; // rax
  int v18; // edx
  signed __int64 v20; // r12
  char *v21; // r8
  __int64 v22; // rsi
  signed __int64 nocancel; // rax
  __int64 v24; // rdx
  __int64 v25; // rcx
  unsigned __int64 v26; // r9
  char *v27; // r8
  const char *v28; // r15
  __int64 v29; // rax
  __int64 v30; // r14
  __int64 v31; // rdi
  unsigned int **v32; // rsi
  __int16 v33; // di
  unsigned int v34; // edi
  void *v35; // rsp
  __int64 v36; // r14
  __int64 v37; // rcx
  __int64 v38; // rax
  char *v39; // r8
  unsigned int *v40; // rcx
  __int64 v41; // rdx
  signed int v42; // eax
  unsigned int *v43; // rax
  __int64 v44; // rcx
  __int64 v45; // r8
  __int64 v46; // r9
  unsigned __int64 v47; // rdi
  __int64 v48; // [rsp+0h] [rbp-10E8h]
  __int64 v49; // [rsp+8h] [rbp-10E0h] BYREF
  _BYTE v50[7]; // [rsp+10h] [rbp-10D8h] BYREF
  unsigned int *v51; // [rsp+1008h] [rbp-E0h] BYREF
  char *filename; // [rsp+1010h] [rbp-D8h]
  struct stat v53; // [rsp+1018h] [rbp-D0h] BYREF
  unsigned __int64 v54; // [rsp+10B0h] [rbp-38h]

  v54 = __readfsqword(0x28u);
  a1[2] = 0LL;
  v5 = _open_nocancel(*a1, 0x80000, a3);
  if ( v5 < 0 )
    return __readfsqword(0x28u) ^ v54;
  v6 = v5;
  if ( (fxstat(1u, v5, &v53) & 0x80000000) != 0LL )
    goto LABEL_14;
  if ( (v53.st_mode & 0xF000) == 0x4000 )
  {
    _close_nocancel(v6);
    v28 = *a1;
    v29 = j_strlen_ifunc(*a1);
    v30 = nl_category_name_sizes[a2];
    v31 = v29 + v30 + 29;
    v32 = (unsigned int **)((char *)&v51 - (v31 & 0xFFFFFFFFFFFFF000LL));
    v33 = v31 & 0xFFF0;
    if ( &v51 != v32 )
    {
      while ( &v49 != (__int64 *)v32 )
        ;
    }
    v34 = v33 & 0xFFF;
    if ( v34 )
    {
      v35 = alloca(v34);
      *(__int64 *)((char *)&v48 + v34) = *(__int64 *)((char *)&v48 + v34);
    }
    v36 = (unsigned int)(v30 + 1);
    v37 = nl_category_name_idxs[a2];
    filename = v50;
    v51 = (unsigned int *)&nl_category_names[v37];
    v38 = j_mempcpy(v50, v28, v29);
    v39 = filename;
    v40 = v51;
    *(_DWORD *)v38 = 1398362927;
    v41 = v38 + 5;
    *(_BYTE *)(v38 + 4) = 95;
    if ( (unsigned int)v36 >= 8 )
    {
      *(_QWORD *)(v38 + 5) = *(_QWORD *)v40;
      *(_QWORD *)(v41 + (unsigned int)v36 - 8) = *(_QWORD *)((char *)v40 + (unsigned int)v36 - 8);
      v47 = (v38 + 13) & 0xFFFFFFFFFFFFFFF8LL;
      v41 -= v47;
      qmemcpy((void *)v47, (char *)v40 - v41, 8LL * ((unsigned int)(v41 + v36) >> 3));
    }
    else if ( (v36 & 4) != 0 )
    {
      *(_DWORD *)(v38 + 5) = *v40;
      *(_DWORD *)(v41 + v36 - 4) = *(unsigned int *)((char *)v40 + v36 - 4);
    }
    else if ( (_DWORD)v36 )
    {
      *(_BYTE *)(v38 + 5) = *(_BYTE *)v40;
      if ( (v36 & 2) != 0 )
        *(_WORD *)(v41 + v36 - 2) = *(_WORD *)((char *)v40 + v36 - 2);
    }
    v42 = _open_nocancel(v39, 0x80000, v41);
    v6 = v42;
    if ( v42 < 0 )
      return __readfsqword(0x28u) ^ v54;
    if ( (fxstat(1u, v42, &v53) & 0x80000000) != 0LL )
    {
LABEL_14:
      _close_nocancel(v6);
      return __readfsqword(0x28u) ^ v54;
    }
  }
  st_size = v53.st_size;
  v8 = __readfsdword(0xFFFFFFC0);
  v13 = (unsigned int *)mmap64(0LL, v53.st_size, 1uLL, 2uLL, v6, 0LL);
  if ( v13 == (unsigned int *)-1LL )
  {
    if ( __readfsdword(0xFFFFFFC0) == 38 )
    {
      v20 = v53.st_size;
      v43 = (unsigned int *)malloc(v53.st_size, st_size, v9, v10, v11, v12);
      v51 = v43;
      if ( v43 )
      {
        v21 = (char *)v43;
        if ( v20 <= 0 )
        {
LABEL_30:
          __writefsdword(0xFFFFFFC0, v8);
          _close_nocancel(v6);
          v17 = nl_intern_locale_data(a2, v51, (_QWORD *)v53.st_size, v44, v45, v46);
          if ( !v17 )
            return __readfsqword(0x28u) ^ v54;
          v18 = 0;
          goto LABEL_8;
        }
        while ( 1 )
        {
          v22 = (__int64)v21;
          filename = v21;
          nocancel = _read_nocancel(v6, v21, v20);
          v27 = filename;
          if ( nocancel <= 0 )
            break;
          v20 -= nocancel;
          v21 = &filename[nocancel];
          if ( v20 <= 0 )
            goto LABEL_30;
        }
        filename = (char *)nocancel;
        free((__int64)v51, v22, v24, v25, (u32 *)v27, v26);
        if ( !filename )
          __writefsdword(0xFFFFFFC0, 0x16u);
      }
    }
    goto LABEL_14;
  }
  _close_nocancel(v6);
  if ( v13 )
  {
    v17 = nl_intern_locale_data(a2, v13, (_QWORD *)v53.st_size, v14, v15, v16);
    if ( !v17 )
    {
      munmap((unsigned __int64)v13, v53.st_size);
      return __readfsqword(0x28u) ^ v54;
    }
    v18 = 1;
LABEL_8:
    *v17 = 0LL;
    *((_DWORD *)v17 + 6) = v18;
    a1[2] = (const char *)v17;
    *((_DWORD *)a1 + 2) = 1;
  }
  return __readfsqword(0x28u) ^ v54;
}
// 44BCF1: variable 'v14' is possibly undefined
// 44BCF1: variable 'v15' is possibly undefined
// 44BCF1: variable 'v16' is possibly undefined
// 44BD7E: variable 'v24' is possibly undefined
// 44BD7E: variable 'v25' is possibly undefined
// 44BD7E: variable 'v26' is possibly undefined
// 44BEFB: variable 'v9' is possibly undefined
// 44BEFB: variable 'v10' is possibly undefined
// 44BEFB: variable 'v11' is possibly undefined
// 44BEFB: variable 'v12' is possibly undefined
// 44BF44: variable 'v44' is possibly undefined
// 44BF44: variable 'v45' is possibly undefined
// 44BF44: variable 'v46' is possibly undefined
// 4010B0: using guessed type __int64 __fastcall j_mempcpy(_QWORD, _QWORD, _QWORD);
// 4010C8: using guessed type __int64 __fastcall j_strlen_ifunc(_QWORD);
// 484F00: using guessed type unsigned __int8 nl_category_name_sizes[16];
// 484F10: using guessed type unsigned __int8 nl_category_name_idxs[16];

//----- (000000000044BFE0) ----------------------------------------------------
__int64 *__fastcall nl_unload_locale(__int64 a1, size_t a2, __int64 a3, __int64 a4, u32 *a5, unsigned __int64 a6)
{
  void (__fastcall *v6)(__int64, size_t, __int64, __int64, u32 *); // rax
  int v7; // eax

  v6 = *(void (__fastcall **)(__int64, size_t, __int64, __int64, u32 *))(a1 + 32);
  if ( v6 )
    v6(a1, a2, a3, a4, a5);
  v7 = *(_DWORD *)(a1 + 24);
  if ( v7 )
  {
    if ( v7 == 1 )
    {
      a2 = *(_QWORD *)(a1 + 16);
      munmap(*(_QWORD *)(a1 + 8), a2);
      v7 = *(_DWORD *)(a1 + 24);
    }
  }
  else
  {
    free(*(_QWORD *)(a1 + 8), a2, a3, a4, a5, a6);
    v7 = *(_DWORD *)(a1 + 24);
  }
  if ( v7 != 2 )
    free(*(_QWORD *)a1, a2, a3, a4, a5, a6);
  return free(a1, a2, a3, a4, a5, a6);
}
// 44C017: variable 'a3' is possibly undefined
// 44C017: variable 'a4' is possibly undefined
// 44C017: variable 'a5' is possibly undefined
// 44C017: variable 'a6' is possibly undefined

//----- (000000000044C040) ----------------------------------------------------
__int64 __fastcall nl_load_locale_from_archive(int a1, __int64 *a2, int a3)
{
  __int64 v3; // rbx
  _QWORD *v4; // r14
  __int64 v5; // r15
  __int64 v6; // r12
  __int64 v7; // r15
  __int64 v9; // rax
  int v10; // edx
  unsigned int *v11; // r14
  __int64 v12; // rax
  unsigned int v13; // er9
  unsigned __int8 *v14; // rdx
  unsigned __int8 *v15; // rcx
  int v16; // eax
  unsigned __int64 v17; // rcx
  unsigned int v18; // esi
  unsigned __int64 v19; // r10
  unsigned __int64 v20; // r8
  unsigned __int64 v21; // r13
  _DWORD *v22; // r15
  __int64 v23; // rsi
  int v24; // eax
  __int64 v25; // rax
  char *v26; // rdi
  __int64 v27; // r9
  _QWORD *v28; // rdx
  char *i; // rcx
  __int64 v30; // rax
  __int64 v31; // rsi
  u32 *v32; // r8
  _QWORD *v33; // rbx
  __int64 v34; // rdx
  __int64 v35; // rcx
  u32 *v36; // r8
  unsigned __int64 v37; // r9
  __int64 v38; // rax
  __int64 v39; // r14
  _QWORD *v40; // rax
  __int64 v41; // rdx
  __int64 v42; // r12
  signed int v43; // eax
  unsigned int v44; // er13
  unsigned __int8 *v45; // r14
  __int64 v46; // r13
  __int64 v47; // r15
  _QWORD *v48; // rdx
  __int64 v49; // rcx
  u32 *v50; // r8
  __int64 v51; // r9
  _DWORD *v52; // rax
  __int64 v53; // r12
  __int64 v54; // rsi
  __int64 v55; // rdx
  __int64 v56; // rcx
  u32 *v57; // r8
  unsigned __int64 v58; // r9
  unsigned __int8 *v59; // r14
  __int64 v60; // r15
  __int64 v61; // r8
  __int64 v62; // rsi
  __int64 *v63; // rcx
  __int16 v64; // si
  unsigned int v65; // esi
  void *v66; // rsp
  __int64 v67; // rax
  __int64 v68; // rax
  size_t v69; // r12
  unsigned __int64 v70; // rax
  __int64 v71; // rax
  __int64 v72; // [rsp+0h] [rbp-1148h]
  __int64 v73; // [rsp+8h] [rbp-1140h] BYREF
  _BYTE v74[7]; // [rsp+10h] [rbp-1138h] BYREF
  __int64 v75; // [rsp+1008h] [rbp-140h] BYREF
  __int64 v76; // [rsp+1010h] [rbp-138h]
  __int64 *v77; // [rsp+1018h] [rbp-130h]
  int v78; // [rsp+1020h] [rbp-128h]
  unsigned int v79; // [rsp+1024h] [rbp-124h]
  unsigned __int64 v80; // [rsp+1028h] [rbp-120h]
  _BYTE *v81; // [rsp+1030h] [rbp-118h]
  char v82[216]; // [rsp+1038h] [rbp-110h] BYREF
  unsigned __int64 v83; // [rsp+1110h] [rbp-38h]

  v78 = a1;
  v3 = *a2;
  v77 = a2;
  v83 = __readfsqword(0x28u);
  sysconf(30, (__int64)a2, a3);
  v4 = (_QWORD *)archloaded;
  if ( !archloaded )
  {
LABEL_8:
    v9 = j_strchr_ifunc(v3, 46LL);
    if ( v9 && (*(_BYTE *)(v9 + 1) & 0xBF) != 0 )
    {
      v45 = (unsigned __int8 *)(v9 + 1);
      v46 = j_strchrnul(v9 + 1, 64LL);
      v47 = v46 - (_QWORD)v45;
      v52 = nl_normalize_codeset(v45, v46 - (_QWORD)v45, v48, v49, v50, v51);
      v53 = (__int64)v52;
      if ( !v52 )
        return 0LL;
      v54 = (__int64)v45;
      if ( (unsigned int)j_strncmp_ifunc(v52, v45, v47) || *(_BYTE *)(v53 + v47) )
      {
        v59 = &v45[-v3];
        v60 = j_strlen_ifunc(v53);
        v61 = j_strlen_ifunc(v46) + 1;
        v62 = (__int64)&v59[v60 + 23 + v61];
        v63 = (__int64 *)((char *)&v75 - (v62 & 0xFFFFFFFFFFFFF000LL));
        v64 = v62 & 0xFFF0;
        if ( &v75 != v63 )
        {
          while ( &v73 != v63 )
            ;
        }
        v65 = v64 & 0xFFF;
        if ( v65 )
        {
          v66 = alloca(v65);
          *(__int64 *)((char *)&v72 + v65) = *(__int64 *)((char *)&v72 + v65);
        }
        v80 = v61;
        v81 = v74;
        v67 = j_mempcpy(v74, v3, v59);
        v68 = j_mempcpy(v67, v53, v60);
        v54 = v46;
        j_memcpy(v68, v46, v80);
        v56 = (__int64)v81;
        v3 = (__int64)v81;
      }
      free(v53, v54, v55, v56, v57, v58);
    }
    v7 = archmapped;
    if ( archmapped )
    {
      v11 = (unsigned int *)headmap;
      if ( headmap )
      {
LABEL_12:
        v12 = j_strlen_ifunc(v3);
        v13 = v12;
        if ( !v12 )
          goto LABEL_42;
        v14 = (unsigned __int8 *)v3;
        v15 = (unsigned __int8 *)(v12 + v3);
        do
        {
          v16 = *v14++;
          v13 = v16 + __ROL4__(v13, 9);
        }
        while ( v15 != v14 );
        v17 = v13;
        if ( !v13 )
        {
LABEL_42:
          v17 = 0xFFFFFFFFLL;
          v13 = -1;
        }
        v18 = v11[4];
        v76 = v11[2];
        if ( v18 )
        {
          v19 = v18;
          v20 = v17 % v18;
          v21 = v17 % (v18 - 2) + 1;
LABEL_18:
          v22 = (unsigned int *)((char *)&v11[3 * v20] + v76);
          while ( 1 )
          {
            v23 = (unsigned int)v22[1];
            if ( !(_DWORD)v23 )
              break;
            if ( *v22 == v13 )
            {
              v79 = v13;
              v80 = v20;
              v81 = (_BYTE *)v19;
              v24 = j_strcmp_ifunc(v3, (char *)v11 + v23);
              v19 = (unsigned __int64)v81;
              v20 = v80;
              v13 = v79;
              if ( !v24 )
              {
                v25 = (unsigned int)v22[2];
                if ( (_DWORD)v25 )
                {
                  v26 = (char *)v11 + v25;
                  v27 = (unsigned int)dword_4AAFBC;
                  if ( dword_4AAFBC != len )
                    _assert_fail(
                      (__int64)"headmap.len == archive_stat.st_size",
                      (__int64)"loadarchive.c",
                      0x136u,
                      "_nl_load_locale_from_archive");
                  v28 = 0LL;
                  for ( i = v82; ; i += 16 )
                  {
                    if ( v28 != (_QWORD *)6 )
                    {
                      v30 = *(unsigned int *)&v26[8 * (_QWORD)v28 + 4];
                      v31 = *(unsigned int *)&v26[8 * (_QWORD)v28 + 8];
                      v32 = (u32 *)(unsigned int)(v30 + v31);
                      if ( (unsigned int)v27 < (unsigned int)v32 )
                        return 0LL;
                      *(_QWORD *)i = (char *)v11 + v30;
                      *((_QWORD *)i + 1) = (unsigned int)v31;
                      if ( (_DWORD)v28 == 12 )
                        break;
                    }
                    v28 = (_QWORD *)((char *)v28 + 1);
                  }
                  v33 = malloc(0x78uLL, v31, v28, (__int64)i, v32, v27);
                  if ( v33 )
                  {
                    v7 = strdup(*v77, v31);
                    v33[1] = v7;
                    if ( v7 )
                    {
                      v38 = archloaded;
                      v39 = 0LL;
                      archloaded = (__int64)v33;
                      *v33 = v38;
                      while ( 1 )
                      {
                        if ( v39 != 6 )
                        {
                          v40 = nl_intern_locale_data(
                                  v39,
                                  *(unsigned int **)&v82[16 * v39],
                                  *(_QWORD **)&v82[16 * v39 + 8],
                                  v35,
                                  (__int64)v36,
                                  v37);
                          v33[v39 + 2] = v40;
                          if ( v40 )
                          {
                            v41 = v33[1];
                            *((_DWORD *)v40 + 6) = 2;
                            *((_DWORD *)v40 + 12) = -1;
                            *v40 = v41;
                          }
                          if ( (_DWORD)v39 == 12 )
                            break;
                        }
                        ++v39;
                      }
                      v42 = v78;
                      *v77 = v33[1];
                      return v33[v42 + 2];
                    }
                    else
                    {
                      free((__int64)v33, v31, v34, v35, v36, v37);
                    }
                    return v7;
                  }
                }
                return 0LL;
              }
            }
            v20 += v21;
            v22 += 3 * v21;
            if ( v19 <= v20 )
            {
              v20 -= v19;
              goto LABEL_18;
            }
          }
        }
      }
    }
    else
    {
      archmapped = (__int64)&headmap;
      v43 = _open_nocancel("/usr/lib/locale/locale-archive", 0x80000, v10);
      v44 = v43;
      if ( v43 >= 0 )
      {
        if ( (unsigned int)fxstat(1u, v43, (struct stat *)&archive_stat) != -1 )
        {
          v69 = len;
          v70 = mmap64(0LL, len, 1uLL, 2uLL, v44, 0LL);
          v11 = (unsigned int *)v70;
          if ( v70 != -1LL )
          {
            v71 = *(unsigned int *)(v70 + 8) + 12LL * *(unsigned int *)(v70 + 16);
            if ( v71 < v11[8] + 108LL * v11[9] )
              v71 = v11[8] + 108LL * v11[9];
            if ( v71 < v11[5] + v11[6] )
              v71 = v11[5] + v11[6];
            if ( v71 <= v69 )
            {
              _close_nocancel(v44);
              headmap = (__int64)v11;
              dword_4AAFBC = v69;
              goto LABEL_12;
            }
            munmap((unsigned __int64)v11, v69);
          }
        }
        _close_nocancel(v44);
        return v7;
      }
    }
    return 0LL;
  }
  while ( 1 )
  {
    v5 = v4[1];
    if ( v5 == v3 )
      break;
    if ( !(unsigned int)j_strcmp_ifunc(v3, v4[1]) )
    {
      v3 = v5;
      break;
    }
    v4 = (_QWORD *)*v4;
    if ( !v4 )
      goto LABEL_8;
  }
  v6 = v78;
  *v77 = v3;
  return v4[v6 + 2];
}
// 44C300: variable 'v35' is possibly undefined
// 44C300: variable 'v36' is possibly undefined
// 44C300: variable 'v37' is possibly undefined
// 44C374: variable 'v10' is possibly undefined
// 44C3C0: variable 'v48' is possibly undefined
// 44C3C0: variable 'v49' is possibly undefined
// 44C3C0: variable 'v50' is possibly undefined
// 44C3C0: variable 'v51' is possibly undefined
// 44C4A6: variable 'v55' is possibly undefined
// 44C4A6: variable 'v56' is possibly undefined
// 44C4A6: variable 'v57' is possibly undefined
// 44C4A6: variable 'v58' is possibly undefined
// 44C572: variable 'v34' is possibly undefined
// 401040: using guessed type __int64 __fastcall j_memcpy(_QWORD, _QWORD, _QWORD);
// 401060: using guessed type __int64 __fastcall j_strchrnul(_QWORD, _QWORD);
// 401078: using guessed type __int64 __fastcall j_strncmp_ifunc(_QWORD, _QWORD, _QWORD);
// 4010A0: using guessed type __int64 __fastcall j_strcmp_ifunc(_QWORD, _QWORD);
// 4010B0: using guessed type __int64 __fastcall j_mempcpy(_QWORD, _QWORD, _QWORD);
// 4010C8: using guessed type __int64 __fastcall j_strlen_ifunc(_QWORD);
// 4010D0: using guessed type __int64 __fastcall j_strchr_ifunc(_QWORD, _QWORD);
// 4AAF00: using guessed type __int64 archloaded;
// 4AAFB0: using guessed type __int64 headmap;
// 4AAFBC: using guessed type int dword_4AAFBC;
// 4AAFC8: using guessed type __int64 archmapped;

//----- (000000000044C5A0) ----------------------------------------------------
int (*nl_postload_ctype())[256]
{
  __int16 (*v0)[256]; // rcx
  char *v1; // rax
  char *v2; // rdx
  int (*result)[256]; // rax
  int (*v4)[256]; // rdx

  v0 = (__int16 (*)[256])(nl_global_locale[0][8] + 256);
  v1 = nl_global_locale[0][11];
  v2 = nl_global_locale[0][9];
  off_4A9AC8 = v0;
  result = (int (*)[256])(v1 + 512);
  v4 = (int (*)[256])(v2 + 512);
  off_4A9AD0[0] = result;
  off_4A9AD8 = v4;
  if ( (char ***)__readfsqword(0xFFFFFFA8) == nl_global_locale )
  {
    __writefsqword(0xFFFFFFF0, (unsigned __int64)v0);
    __writefsqword(0xFFFFFFE8, (unsigned __int64)v4);
    __writefsqword(0xFFFFFFE0, (unsigned __int64)result);
  }
  return result;
}
// 4A9A60: using guessed type char **nl_global_locale[6];
// 4A9AC8: using guessed type __int16 (*off_4A9AC8)[256];
// 4A9AD0: using guessed type int (*off_4A9AD0[2])[256];
// 4A9AD8: using guessed type int (*off_4A9AD8)[256];

//----- (000000000044C620) ----------------------------------------------------
__int64 __fastcall _current_locale_name(int a1)
{
  return *(_QWORD *)(__readfsqword(0xFFFFFFA8) + 8LL * a1 + 128);
}

//----- (000000000044C640) ----------------------------------------------------
unsigned __int64 _ctype_b_loc()
{
  return __readfsqword(0) - 16;
}

//----- (000000000044C660) ----------------------------------------------------
unsigned __int64 _ctype_toupper_loc()
{
  return __readfsqword(0) - 24;
}

//----- (000000000044C680) ----------------------------------------------------
unsigned __int64 _ctype_tolower_loc()
{
  return __readfsqword(0) - 32;
}

//----- (000000000044C6A0) ----------------------------------------------------
unsigned __int64 _ctype_init()
{
  _QWORD *v0; // rax
  unsigned __int64 result; // rax

  v0 = *(_QWORD **)__readfsqword(0xFFFFFFA0);
  __writefsqword(0xFFFFFFF0, v0[8] + 256LL);
  __writefsqword(0xFFFFFFE8, v0[9] + 512LL);
  result = v0[11] + 512LL;
  __writefsqword(0xFFFFFFE0, result);
  return result;
}

//----- (000000000044C700) ----------------------------------------------------
__int64 _setfpucw()
{
  return 0LL;
}

//----- (000000000044C750) ----------------------------------------------------
__int64 __fastcall _sigsetjmp(_QWORD *a1, int a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, char a7)
{
  __int64 v7; // rbx
  __int64 v8; // rbp
  __int64 v9; // r12
  __int64 v10; // r13
  __int64 v11; // r14
  __int64 v12; // r15
  unsigned __int64 retaddr; // [rsp+0h] [rbp+0h]

  *a1 = v7;
  a1[1] = __ROL8__(__readfsqword(0x30u) ^ v8, 17);
  a1[2] = v9;
  a1[3] = v10;
  a1[4] = v11;
  a1[5] = v12;
  a1[6] = __ROL8__(__readfsqword(0x30u) ^ (unsigned __int64)&a7, 17);
  a1[7] = __ROL8__(__readfsqword(0x30u) ^ retaddr, 17);
  __asm { rdsspq  rax }
  a1[11] = _RAX;
  return _sigjmp_save((__int64)a1, a2);
}
// 44C754: variable 'v7' is possibly undefined
// 44C75A: variable 'v8' is possibly undefined
// 44C76B: variable 'v9' is possibly undefined
// 44C76F: variable 'v10' is possibly undefined
// 44C773: variable 'v11' is possibly undefined
// 44C777: variable 'v12' is possibly undefined

//----- (000000000044C7C0) ----------------------------------------------------
__int64 __fastcall _sigjmp_save(__int64 a1, int a2)
{
  __int64 result; // rax
  _BOOL4 v3; // esi

  if ( a2 )
  {
    v3 = sigprocmask(0, 0LL, (sigset_t *)(a1 + 72)) == 0;
    result = 0LL;
    *(_DWORD *)(a1 + 64) = v3;
  }
  else
  {
    *(_DWORD *)(a1 + 64) = 0;
    return 0LL;
  }
  return result;
}

//----- (000000000044C810) ----------------------------------------------------
unsigned __int64 __fastcall _restore_rt(int a1, __int64 a2, __int64 a3)
{
  __asm { syscall; LINUX - sys_rt_sigreturn }
  return _libc_sigaction(a1, a2, a3);
}

//----- (000000000044C820) ----------------------------------------------------
unsigned __int64 __fastcall _libc_sigaction(int a1, __int64 a2, __int64 a3)
{
  __m128i v4; // xmm0
  struct sigaction *v5; // rdx
  __m128i v6; // xmm1
  __m128i v7; // xmm2
  __m128i v8; // xmm3
  __m128i v9; // xmm4
  int v10; // eax
  __m128i v11; // xmm5
  __m128i v12; // xmm6
  __m128i v13; // xmm7
  const struct sigaction *v14; // rsi
  unsigned __int64 result; // rax
  __int64 v16; // r8
  __m128i v17; // xmm0
  __m128i v18; // xmm1
  __m128i v19; // xmm2
  __m128i v20; // xmm3
  int v21; // edx
  __m128i v22; // xmm4
  __m128i v23; // xmm5
  __m128i v24; // xmm6
  __m128i v25; // xmm7
  __int64 v26; // rdx
  __int64 v27[3]; // [rsp+0h] [rbp-148h] BYREF
  __m128i v28; // [rsp+18h] [rbp-130h]
  __m128i v29; // [rsp+28h] [rbp-120h]
  __m128i v30; // [rsp+38h] [rbp-110h]
  __m128i v31; // [rsp+48h] [rbp-100h]
  __m128i v32; // [rsp+58h] [rbp-F0h]
  __m128i v33; // [rsp+68h] [rbp-E0h]
  __m128i v34; // [rsp+78h] [rbp-D0h]
  __m128i v35; // [rsp+88h] [rbp-C0h]
  __int64 v36; // [rsp+A0h] [rbp-A8h] BYREF
  __int64 v37; // [rsp+A8h] [rbp-A0h]
  __int64 v38; // [rsp+B0h] [rbp-98h]
  __m128i v39; // [rsp+B8h] [rbp-90h] BYREF
  __m128i v40; // [rsp+C8h] [rbp-80h] BYREF
  __m128i v41; // [rsp+D8h] [rbp-70h] BYREF
  __m128i v42; // [rsp+E8h] [rbp-60h] BYREF
  __m128i v43; // [rsp+F8h] [rbp-50h] BYREF
  __m128i v44; // [rsp+108h] [rbp-40h] BYREF
  __m128i v45; // [rsp+118h] [rbp-30h] BYREF
  __m128i v46; // [rsp+128h] [rbp-20h] BYREF
  unsigned __int64 v47; // [rsp+138h] [rbp-10h]

  v47 = __readfsqword(0x28u);
  if ( a2 )
  {
    v4 = _mm_loadu_si128((const __m128i *)(a2 + 8));
    v5 = (struct sigaction *)&v36;
    v6 = _mm_loadu_si128((const __m128i *)(a2 + 24));
    v7 = _mm_loadu_si128((const __m128i *)(a2 + 40));
    v8 = _mm_loadu_si128((const __m128i *)(a2 + 56));
    v9 = _mm_loadu_si128((const __m128i *)(a2 + 72));
    v27[0] = *(_QWORD *)a2;
    v10 = *(_DWORD *)(a2 + 136);
    v11 = _mm_loadu_si128((const __m128i *)(a2 + 88));
    v28 = v4;
    v12 = _mm_loadu_si128((const __m128i *)(a2 + 104));
    v13 = _mm_loadu_si128((const __m128i *)(a2 + 120));
    v29 = v6;
    v14 = (const struct sigaction *)v27;
    v30 = v7;
    v31 = v8;
    v27[1] = v10 | 0x4000000;
    v27[2] = (__int64)_restore_rt;
    if ( !a3 )
      v5 = 0LL;
    v32 = v9;
    v33 = v11;
    v34 = v12;
    v35 = v13;
  }
  else
  {
    v5 = 0LL;
    v14 = 0LL;
    if ( a3 )
    {
      v5 = (struct sigaction *)&v36;
      v14 = 0LL;
    }
  }
  result = sys_rt_sigaction(a1, v14, v5, 8uLL);
  if ( result > 0xFFFFFFFFFFFFF000LL )
  {
    __writefsdword(0xFFFFFFC0, -(int)result);
    return 0xFFFFFFFFLL;
  }
  else if ( v16 )
  {
    if ( (result & 0x80000000) == 0LL )
    {
      v17 = _mm_loadu_si128(&v39);
      v18 = _mm_loadu_si128(&v40);
      v19 = _mm_loadu_si128(&v41);
      v20 = _mm_loadu_si128(&v42);
      *(_QWORD *)v16 = v36;
      v21 = v37;
      *(__m128i *)(v16 + 8) = v17;
      v22 = _mm_loadu_si128(&v43);
      v23 = _mm_loadu_si128(&v44);
      *(__m128i *)(v16 + 24) = v18;
      v24 = _mm_loadu_si128(&v45);
      v25 = _mm_loadu_si128(&v46);
      *(_DWORD *)(v16 + 136) = v21;
      v26 = v38;
      *(__m128i *)(v16 + 40) = v19;
      *(__m128i *)(v16 + 56) = v20;
      *(_QWORD *)(v16 + 144) = v26;
      *(__m128i *)(v16 + 72) = v22;
      *(__m128i *)(v16 + 88) = v23;
      *(__m128i *)(v16 + 104) = v24;
      *(__m128i *)(v16 + 120) = v25;
    }
  }
  return result;
}
// 44C8F6: variable 'v16' is possibly undefined

//----- (000000000044CA00) ----------------------------------------------------
unsigned __int64 __fastcall sigaction(int a1, __int64 a2, __int64 a3)
{
  if ( (unsigned int)(a1 - 1) <= 0x3F && (unsigned int)(a1 - 32) > 1 )
    return _libc_sigaction(a1, a2, a3);
  __writefsdword(0xFFFFFFC0, 0x16u);
  return 0xFFFFFFFFLL;
}

//----- (000000000044CA40) ----------------------------------------------------
unsigned __int64 __fastcall sigprocmask(int a1, sigset_t *a2, sigset_t *a3)
{
  unsigned __int64 result; // rax

  result = sys_rt_sigprocmask(a1, a2, a3, 8uLL);
  if ( result > 0xFFFFFFFFFFFFF000LL )
  {
    __writefsdword(0xFFFFFFC0, -(int)result);
    return 0xFFFFFFFFLL;
  }
  return result;
}

//----- (000000000044CA80) ----------------------------------------------------
unsigned __int64 __fastcall quicksort(
        char *a1,
        unsigned __int64 a2,
        unsigned __int64 a3,
        int (__fastcall *a4)(char *, char *, __int64),
        __int64 a5)
{
  unsigned __int64 v5; // r14
  __int64 v8; // r13
  char *v9; // r12
  char *v10; // r15
  char *v11; // r14
  unsigned __int64 v12; // rax
  char *v13; // rdi
  char *v14; // r15
  char *v15; // rdi
  char *v16; // r12
  char *v17; // r15
  char *v18; // rax
  char *v19; // r13
  char *v20; // rcx
  char v21; // dl
  char v22; // si
  char *v23; // r12
  char *v24; // rsi
  char *v25; // rdi
  char *v26; // r9
  char v27; // r8
  char *v28; // rax
  char *v29; // rdx
  char *v31; // rax
  char *v32; // rdx
  char *v33; // rax
  char v34; // cl
  char v35; // si
  _QWORD *v36; // rax
  char *v37; // rdx
  char *v38; // r15
  char *v39; // rax
  char v40; // cl
  char v41; // si
  char *v42; // rdx
  char *v43; // rax
  char v44; // cl
  char v45; // si
  char *v46; // rdx
  char *v47; // rax
  char v48; // cl
  char v49; // si
  _QWORD *v50; // rax
  char *v51; // rdi
  unsigned __int64 v53; // [rsp+0h] [rbp-488h]
  char *v54; // [rsp+8h] [rbp-480h]
  char *v55; // [rsp+10h] [rbp-478h]
  char *v56; // [rsp+18h] [rbp-470h]
  char *v57; // [rsp+20h] [rbp-468h]
  unsigned __int64 v58; // [rsp+28h] [rbp-460h]
  __int64 v60[2]; // [rsp+40h] [rbp-448h] BYREF
  char v61; // [rsp+50h] [rbp-438h] BYREF
  unsigned __int64 v62; // [rsp+448h] [rbp-40h]

  v62 = __readfsqword(0x28u);
  if ( a2 )
  {
    v5 = a3;
    v58 = 4 * a3;
    v56 = &a1[a3 * (a2 - 1)];
    if ( a2 > 4 )
    {
      v54 = &a1[a3 * (a2 - 1)];
      v8 = -(__int64)a3;
      v60[0] = 0LL;
      v60[1] = 0LL;
      v55 = a1;
      v57 = &v61;
      while ( 1 )
      {
        v9 = &v55[a3 * (((v54 - v55) / a3) >> 1)];
        if ( a4(v9, v55, a5) < 0 )
        {
          v46 = v55;
          v47 = &v55[a3 * (((v54 - v55) / a3) >> 1)];
          do
          {
            v48 = *v47;
            v49 = *v46;
            ++v47;
            ++v46;
            *(v47 - 1) = v49;
            *(v46 - 1) = v48;
          }
          while ( v47 != &v9[a3] );
        }
        if ( a4(v54, v9, a5) < 0 )
        {
          v37 = v54;
          v38 = &v9[a3];
          v39 = &v55[a3 * (((v54 - v55) / a3) >> 1)];
          do
          {
            v40 = *v39;
            v41 = *v37;
            ++v39;
            ++v37;
            *(v39 - 1) = v41;
            *(v37 - 1) = v40;
          }
          while ( v39 != v38 );
          if ( a4(v9, v55, a5) < 0 )
          {
            v42 = v55;
            v43 = &v55[a3 * (((v54 - v55) / a3) >> 1)];
            do
            {
              v44 = *v43;
              v45 = *v42;
              ++v43;
              ++v42;
              *(v43 - 1) = v45;
              *(v42 - 1) = v44;
            }
            while ( v43 != v38 );
          }
        }
        v10 = &v55[a3];
        v11 = &v54[v8];
        while ( 1 )
        {
          while ( a4(v10, v9, a5) < 0 )
            v10 += a3;
          while ( a4(v9, v11, a5) < 0 )
            v11 += v8;
          if ( v10 < v11 )
          {
            v32 = v11;
            v33 = v10;
            do
            {
              v34 = *v33;
              v35 = *v32;
              ++v33;
              ++v32;
              *(v33 - 1) = v35;
              *(v32 - 1) = v34;
            }
            while ( v33 != &v10[a3] );
            if ( v10 == v9 )
            {
              v9 = v11;
            }
            else if ( v11 == v9 )
            {
              v9 = v10;
            }
            v11 += v8;
            v10 += a3;
            goto LABEL_13;
          }
          if ( v10 == v11 )
            break;
LABEL_13:
          if ( v10 > v11 )
            goto LABEL_14;
        }
        v10 += a3;
        v11 += v8;
LABEL_14:
        v12 = v54 - v10;
        if ( v11 - v55 > v58 )
        {
          if ( v58 >= v12 )
          {
            v54 = v11;
          }
          else if ( v11 - v55 <= (__int64)v12 )
          {
            v50 = v57;
            v51 = v54;
            v57 += 16;
            v54 = v11;
            *v50 = v10;
            v50[1] = v51;
          }
          else
          {
            v36 = v57;
            v57 += 16;
            v36[1] = v11;
            *v36 = v55;
            v55 = v10;
          }
        }
        else
        {
          v55 = v10;
          if ( v58 >= v12 )
          {
            v55 = (char *)*((_QWORD *)v57 - 2);
            v13 = (char *)*((_QWORD *)v57 - 1);
            v57 -= 16;
            v54 = v13;
          }
        }
        if ( v57 <= (char *)v60 )
        {
          v5 = a3;
          break;
        }
      }
    }
    v14 = &a1[v5];
    v15 = &a1[v58];
    v16 = &a1[v5];
    if ( v56 < &a1[v58] )
      v15 = v56;
    if ( v15 >= v14 )
    {
      v17 = a1;
      do
      {
        if ( a4(v16, v17, a5) < 0 )
          v17 = v16;
        v16 += v5;
      }
      while ( v15 >= v16 );
      v18 = a1;
      v19 = v17;
      v14 = &a1[v5];
      if ( v19 != a1 )
      {
        v20 = &v19[v5];
        do
        {
          v21 = *v19;
          v22 = *v18;
          ++v19;
          ++v18;
          *(v19 - 1) = v22;
          *(v18 - 1) = v21;
        }
        while ( v19 != v20 );
      }
    }
    v53 = v5 - 1;
    while ( 1 )
    {
      v23 = &v14[v5];
      if ( &v14[v5] > v56 )
        break;
      while ( 1 )
      {
        while ( a4(v23, v14, a5) < 0 )
          v14 -= v5;
        v14 += v5;
        if ( v23 == v14 )
          break;
        v24 = &v23[v53];
        if ( !__CFADD__(v23, v53) )
        {
          v25 = v23 - 1;
          v26 = v23 - 1;
          do
          {
            while ( 1 )
            {
              v27 = *v24;
              v28 = v25;
              if ( v25 >= v14 )
                break;
              v31 = v24--;
              --v25;
              *v31 = v27;
              if ( v24 == v26 )
                goto LABEL_42;
            }
            v29 = v24;
            while ( 1 )
            {
              *v29 = *v28;
              v29 -= v5;
              if ( v14 > &v28[-v5] )
                break;
              v28 -= v5;
            }
            --v24;
            *v28 = v27;
            --v25;
          }
          while ( v24 != v26 );
        }
LABEL_42:
        v14 = v23;
        v23 += v5;
        if ( v23 > v56 )
          return __readfsqword(0x28u) ^ v62;
      }
    }
  }
  return __readfsqword(0x28u) ^ v62;
}

//----- (000000000044CF00) ----------------------------------------------------
__int64 __fastcall _add_to_environ(__int64 a1, __int64 a2, char *a3, unsigned int a4)
{
  _QWORD *v5; // rdx
  __int64 v6; // rcx
  __int64 v7; // rbx
  u32 *v8; // r8
  unsigned __int64 v9; // r9
  char **v11; // r13
  char *v12; // r12
  __int64 i; // r14
  __int64 v14; // rsi
  __int64 v15; // r15
  char **v16; // r13
  __int64 *v17; // rax
  __int64 v18; // rdx
  __int64 v19; // r15
  char *v20; // rax
  __int64 v21; // rdx
  unsigned __int64 v23; // r15
  _BOOL4 v24; // eax
  _QWORD *v25; // rdx
  __int64 v26; // rcx
  u32 *v27; // r8
  __int64 v28; // r9
  __int64 *v29; // rcx
  _BYTE *v30; // rax
  __int64 v31; // rdx
  __int64 v32; // rsi
  char **v33; // rax
  __int64 v34; // rcx
  u32 *v35; // r8
  unsigned __int64 v36; // r9
  void *v37; // rsp
  __int64 v38; // rdx
  char *v39; // rbx
  _BYTE *v40; // rax
  __int64 v41; // rdx
  __int64 v42; // rsi
  char **v43; // rax
  __int64 v44; // rdx
  char *v45; // rbx
  _BYTE v47[15]; // [rsp+8h] [rbp-1070h] BYREF
  __int64 v48; // [rsp+1008h] [rbp-70h] BYREF
  __int64 v49; // [rsp+1010h] [rbp-68h]
  __int64 v50; // [rsp+1018h] [rbp-60h]
  unsigned int v51; // [rsp+1024h] [rbp-54h]
  char *v52; // [rsp+1028h] [rbp-50h]
  __int64 v53; // [rsp+1030h] [rbp-48h]
  unsigned __int64 v54; // [rsp+1040h] [rbp-38h]

  v53 = a1;
  v50 = a2;
  v52 = a3;
  v51 = a4;
  v54 = __readfsqword(0x28u);
  v7 = j_strlen_ifunc(a1);
  if ( !a3 )
    v49 = j_strlen_ifunc(v50) + 1;
  _ESI = 1;
  if ( _libc_multiple_threads )
  {
    if ( !_InterlockedCompareExchange(&envlock, 1, 0) )
      goto LABEL_8;
    goto LABEL_7;
  }
  __asm { cmpxchg cs:envlock, esi }
  if ( _libc_multiple_threads )
LABEL_7:
    _lll_lock_wait_private((u32 *)&envlock, 1LL, (__int64)v5, v6, v8, v9);
LABEL_8:
  v11 = environ;
  if ( environ && (v12 = *environ) != 0LL )
  {
    for ( i = 0LL; ; ++i )
    {
      v14 = v53;
      if ( !(unsigned int)j_strncmp_ifunc(v12, v53, v7) && v12[v7] == 61 )
        break;
      v12 = *++v11;
      v15 = i + 1;
      if ( !*v11 )
      {
        v14 = 8 * i + 24;
        goto LABEL_16;
      }
    }
    v20 = *v11;
    if ( *v11 )
      goto LABEL_20;
    v14 = 8 * i + 16;
    v15 = i;
  }
  else
  {
    v14 = 16LL;
    v15 = 0LL;
  }
LABEL_16:
  v16 = (char **)last_environ;
  v17 = realloc(last_environ, v14, v5, v6, v8, v9);
  v8 = (u32 *)v17;
  if ( !v17 )
    goto LABEL_44;
  v14 = (__int64)environ;
  v19 = 2 * v15;
  if ( v16 != environ )
    v8 = (u32 *)j_memcpy(v17, environ, v19 * 4);
  v11 = (char **)&v8[v19];
  last_environ = (__int64)v8;
  *(_QWORD *)&v8[v19] = 0LL;
  *(_QWORD *)&v8[v19 + 2] = 0LL;
  v20 = *(char **)&v8[v19];
  environ = (char **)v8;
LABEL_20:
  v21 = v51;
  if ( !v51 && v20 )
  {
LABEL_24:
    if ( _libc_multiple_threads )
    {
      if ( !_InterlockedDecrement(&envlock) )
        return 0LL;
    }
    else if ( !--envlock )
    {
      return 0LL;
    }
    _lll_unlock_wake_private((u32 *)&envlock, v14, v21, v6, v8, v9);
    return 0LL;
  }
  if ( v52 )
  {
LABEL_23:
    *v11 = v52;
    goto LABEL_24;
  }
  v23 = v49 + v7 + 1;
  v24 = _libc_alloca_cutoff(v23);
  if ( v23 <= 0x1000 || v24 )
  {
    v29 = (__int64 *)((char *)&v48 - ((v49 + v7 + 24) & 0xFFFFFFFFFFFFF000LL));
    if ( &v48 != v29 )
    {
      while ( v47 != (_BYTE *)v29 )
        ;
    }
    if ( (((_WORD)v23 + 23) & 0xFF0) != 0 )
    {
      v37 = alloca(((_WORD)v23 + 23) & 0xFF0);
      *(_QWORD *)&v47[(((_WORD)v23 + 23) & 0xFF0) - 8] = *(_QWORD *)&v47[(((_WORD)v23 + 23) & 0xFF0) - 8];
    }
    v30 = (_BYTE *)j_mempcpy(v47, v53, v7);
    v31 = v49;
    v32 = v50;
    *v30 = 61;
    j_memcpy(v30 + 1, v32, v31);
    v14 = (__int64)&known_values;
    v33 = (char **)tfind((__int64)v47, &known_values, j_strcmp_ifunc);
    if ( v33 )
    {
      v52 = *v33;
      if ( v52 )
        goto LABEL_23;
    }
    v52 = (char *)malloc(v23, (__int64)&known_values, (_QWORD *)v21, v6, v8, v9);
    if ( v52 )
    {
      j_memcpy(v52, v47, v23);
LABEL_43:
      v14 = (__int64)&known_values;
      tsearch((__int64)v52, &known_values, j_strcmp_ifunc, v34, v35, v36);
      goto LABEL_23;
    }
  }
  else
  {
    v52 = (char *)malloc(v23, v14, v25, v26, v27, v28);
    if ( v52 )
    {
      v38 = v7;
      v39 = v52;
      v40 = (_BYTE *)j_mempcpy(v52, v53, v38);
      v41 = v49;
      v42 = v50;
      *v40 = 61;
      j_memcpy(v40 + 1, v42, v41);
      v14 = (__int64)&known_values;
      v43 = (char **)tfind((__int64)v39, &known_values, j_strcmp_ifunc);
      if ( v43 )
      {
        v45 = *v43;
        if ( *v43 )
        {
          free((__int64)v52, (__int64)&known_values, v44, v34, v35, v36);
          v52 = v45;
          goto LABEL_23;
        }
      }
      goto LABEL_43;
    }
  }
LABEL_44:
  if ( _libc_multiple_threads )
  {
    if ( !_InterlockedDecrement(&envlock) )
      return 0xFFFFFFFFLL;
    goto LABEL_48;
  }
  if ( --envlock )
LABEL_48:
    _lll_unlock_wake_private((u32 *)&envlock, v14, v18, v6, v8, v9);
  return 0xFFFFFFFFLL;
}
// 44CF7A: variable 'v5' is possibly undefined
// 44CF7A: variable 'v6' is possibly undefined
// 44CF7A: variable 'v8' is possibly undefined
// 44CF7A: variable 'v9' is possibly undefined
// 44D093: variable 'v21' is possibly undefined
// 44D1FB: variable 'v34' is possibly undefined
// 44D1FB: variable 'v35' is possibly undefined
// 44D1FB: variable 'v36' is possibly undefined
// 44D23D: variable 'v18' is possibly undefined
// 44D256: variable 'v25' is possibly undefined
// 44D256: variable 'v26' is possibly undefined
// 44D256: variable 'v27' is possibly undefined
// 44D256: variable 'v28' is possibly undefined
// 44D2BA: variable 'v44' is possibly undefined
// 401040: using guessed type __int64 __fastcall j_memcpy(_QWORD, _QWORD, _QWORD);
// 401078: using guessed type __int64 __fastcall j_strncmp_ifunc(_QWORD, _QWORD, _QWORD);
// 4010A0: using guessed type __int64 __fastcall j_strcmp_ifunc(_QWORD, _QWORD);
// 4010B0: using guessed type __int64 __fastcall j_mempcpy(_QWORD, _QWORD, _QWORD);
// 4010C8: using guessed type __int64 __fastcall j_strlen_ifunc(_QWORD);
// 4AAFD0: using guessed type __int64 last_environ;
// 4AAFD8: using guessed type __int64 known_values;
// 4AAFE0: using guessed type int envlock;
// 4AB820: using guessed type int _libc_multiple_threads;

//----- (000000000044D2D0) ----------------------------------------------------
__int64 __fastcall setenv(_BYTE *a1, __int64 a2, unsigned int a3)
{
  if ( a1 && *a1 && !j_strchr_ifunc(a1, 61LL) )
    return _add_to_environ((__int64)a1, a2, 0LL, a3);
  __writefsdword(0xFFFFFFC0, 0x16u);
  return 0xFFFFFFFFLL;
}
// 4010D0: using guessed type __int64 __fastcall j_strchr_ifunc(_QWORD, _QWORD);

//----- (000000000044D330) ----------------------------------------------------
__int64 __fastcall unsetenv(_BYTE *a1)
{
  __int64 v2; // rdx
  __int64 v3; // rcx
  u32 *v4; // r8
  u32 v5; // er9
  __int64 v6; // r13
  char **v7; // rbp
  char *v8; // rbx
  char **v10; // rax

  if ( a1 && *a1 && !j_strchr_ifunc(a1, 61LL) )
  {
    _RSI = 1LL;
    v6 = j_strlen_ifunc(a1);
    if ( _libc_multiple_threads )
    {
      if ( !_InterlockedCompareExchange(&envlock, 1, 0) )
      {
LABEL_9:
        v7 = environ;
        if ( environ )
        {
          while ( 1 )
          {
            v8 = *v7;
            if ( !*v7 )
              break;
            _RSI = (__int64)a1;
            if ( !(unsigned int)j_strncmp_ifunc(*v7, a1, v6) && v8[v6] == 61 )
            {
              v10 = v7;
              do
              {
                v2 = (__int64)v10[1];
                *v10++ = (char *)v2;
              }
              while ( v2 );
            }
            else
            {
              ++v7;
            }
          }
        }
        if ( _libc_multiple_threads )
        {
          if ( !_InterlockedDecrement(&envlock) )
            return 0LL;
        }
        else if ( !--envlock )
        {
          return 0LL;
        }
        _lll_unlock_wake_private((u32 *)&envlock, _RSI, v2, v3, v4, v5);
        return 0LL;
      }
    }
    else
    {
      __asm { cmpxchg cs:envlock, esi }
      if ( !_libc_multiple_threads )
        goto LABEL_9;
    }
    _lll_lock_wait_private((u32 *)&envlock, 1LL, v2, v3, v4, v5);
    goto LABEL_9;
  }
  __writefsdword(0xFFFFFFC0, 0x16u);
  return 0xFFFFFFFFLL;
}
// 44D3A4: variable 'v2' is possibly undefined
// 44D3A4: variable 'v3' is possibly undefined
// 44D3A4: variable 'v4' is possibly undefined
// 44D3A4: variable 'v5' is possibly undefined
// 401078: using guessed type __int64 __fastcall j_strncmp_ifunc(_QWORD, _QWORD, _QWORD);
// 4010C8: using guessed type __int64 __fastcall j_strlen_ifunc(_QWORD);
// 4010D0: using guessed type __int64 __fastcall j_strchr_ifunc(_QWORD, _QWORD);
// 4AAFE0: using guessed type int envlock;
// 4AB820: using guessed type int _libc_multiple_threads;

//----- (000000000044D460) ----------------------------------------------------
__int64 __fastcall clearenv(__int64 a1, __int64 a2, __int64 a3, __int64 a4, u32 *a5, unsigned __int64 a6)
{
  _ESI = 1;
  if ( _libc_multiple_threads )
  {
    if ( !_InterlockedCompareExchange(&envlock, 1, 0) )
      goto LABEL_6;
    goto LABEL_5;
  }
  __asm { cmpxchg cs:envlock, esi }
  if ( _libc_multiple_threads )
LABEL_5:
    _lll_lock_wait_private((u32 *)&envlock, 1LL, a3, a4, a5, a6);
LABEL_6:
  if ( (char **)last_environ == environ && environ )
  {
    free((__int64)environ, 1LL, a3, a4, a5, a6);
    last_environ = 0LL;
  }
  environ = 0LL;
  if ( _libc_multiple_threads )
  {
    if ( !_InterlockedDecrement(&envlock) )
      return 0LL;
    goto LABEL_13;
  }
  if ( --envlock )
LABEL_13:
    _lll_unlock_wake_private((u32 *)&envlock, 1LL, a3, a4, a5, a6);
  return 0LL;
}
// 44D508: variable 'a3' is possibly undefined
// 44D508: variable 'a4' is possibly undefined
// 44D508: variable 'a5' is possibly undefined
// 44D508: variable 'a6' is possibly undefined
// 4AAFD0: using guessed type __int64 last_environ;
// 4AAFE0: using guessed type int envlock;
// 4AB820: using guessed type int _libc_multiple_threads;

//----- (000000000044D520) ----------------------------------------------------
char *__fastcall secure_getenv(_BYTE *a1)
{
  if ( _libc_enable_secure )
    return 0LL;
  else
    return getenv(a1);
}
// 4A7AD8: using guessed type int _libc_enable_secure;

//----- (000000000044D540) ----------------------------------------------------
unsigned __int64 __fastcall _strtoll_internal(char *a1, char **a2, int a3, int a4)
{
  return ___strtoll_l_internal(a1, a2, a3, a4, __readfsqword(0xFFFFFFA8));
}

//----- (000000000044D560) ----------------------------------------------------
unsigned __int64 __fastcall strtoq(char *a1, char **a2, int a3)
{
  return ___strtoll_l_internal(a1, a2, a3, 0, __readfsqword(0xFFFFFFA8));
}

//----- (000000000044D580) ----------------------------------------------------
unsigned __int64 __fastcall ___strtoll_l_internal(char *a1, char **a2, int a3, int a4, __int64 a5)
{
  char *v5; // r14
  char *v7; // r12
  __int64 v8; // rsi
  char *v9; // rbx
  __int64 i; // rax
  char *v11; // rbx
  unsigned __int8 v12; // r15
  unsigned __int64 v13; // rbp
  unsigned __int64 v14; // rcx
  __int64 v15; // rdi
  char *v16; // r8
  unsigned __int64 result; // rax
  int v18; // er9
  char *v19; // rsi
  unsigned __int8 v20; // si
  __int64 v21; // rax
  __int64 v22; // rsi
  __int64 v23; // rax
  __int64 v24; // rcx
  unsigned __int64 v25; // rax
  __int64 v26; // rdx
  __int64 v27; // rdi
  unsigned __int64 v28; // rsi
  char v29; // cl
  unsigned __int64 j; // rdx
  unsigned __int64 v31; // rax
  unsigned __int8 v33; // [rsp+12h] [rbp-46h]
  int v34; // [rsp+14h] [rbp-44h]

  v5 = 0LL;
  v7 = 0LL;
  if ( a4 )
  {
    v24 = *(_QWORD *)(a5 + 8);
    v5 = *(char **)(v24 + 80);
    if ( (unsigned __int8)(*v5 - 1) > 0x7Du )
    {
      v5 = 0LL;
    }
    else
    {
      v7 = *(char **)(v24 + 72);
      if ( !*v7 )
      {
        v5 = 0LL;
        v7 = 0LL;
      }
    }
  }
  if ( a3 == 1 || (unsigned int)a3 > 0x24 )
  {
    __writefsdword(0xFFFFFFC0, 0x16u);
    return 0LL;
  }
  v8 = *(_QWORD *)(a5 + 104);
  v9 = a1;
  for ( i = *a1; (*(_BYTE *)(v8 + 2 * i + 1) & 0x20) != 0; i = *v9 )
    ++v9;
  if ( !(_BYTE)i )
  {
    if ( !a2 )
      return 0LL;
    goto LABEL_65;
  }
  if ( (_BYTE)i == 45 )
  {
    v11 = v9 + 1;
    v34 = 1;
  }
  else
  {
    v34 = 0;
    v11 = &v9[(_BYTE)i == 43];
  }
  v12 = *v11;
  if ( *v11 != 48 )
  {
    if ( a3 && a3 != 10 )
    {
      v13 = 0LL;
      v5 = 0LL;
      v21 = a3 - 2;
      v33 = _strtol_ul_rem_tab[v21];
      v14 = _strtol_ul_max_tab[v21];
      goto LABEL_13;
    }
    if ( !v5 )
    {
      v33 = 5;
      a3 = 10;
      v13 = 0LL;
      v14 = 0x1999999999999999LL;
      goto LABEL_13;
    }
LABEL_57:
    v25 = j_strlen_ifunc(v7);
    v13 = v25;
    if ( !v25 )
      goto LABEL_62;
    if ( v12 == *v7 )
    {
      v26 = 0LL;
      while ( v25 != ++v26 )
      {
        if ( v7[v26] != v11[v26] )
          goto LABEL_78;
      }
      goto LABEL_62;
    }
LABEL_78:
    v27 = v12;
    v28 = (unsigned __int64)v11;
    if ( v12 )
    {
      v28 = (unsigned __int64)v11;
      do
      {
        if ( (unsigned __int8)(v27 - 48) > 9u )
        {
          v29 = *v7;
          for ( j = 0LL; *(_BYTE *)(v28 + j) == v29; v29 = v7[j] )
          {
            if ( v25 == ++j )
              goto LABEL_80;
          }
          if ( v25 > j && ((word_486FE0[v27] & 0x400) == 0 || (int)dword_4866E0[v27] > 64) )
            break;
        }
LABEL_80:
        v27 = *(unsigned __int8 *)++v28;
      }
      while ( (_BYTE)v27 );
    }
    v31 = _correctly_grouped_prefixmb((unsigned __int64)v11, v28, v7, v5);
    v12 = *v11;
    v33 = 5;
    v14 = 0x1999999999999999LL;
    v5 = (char *)v31;
    a3 = 10;
LABEL_13:
    v15 = v12;
    if ( v5 != v11 && v12 )
      goto LABEL_15;
LABEL_62:
    if ( !a2 )
      return 0LL;
    if ( v11 - a1 > 1 && dword_4866E0[*(v11 - 1)] == 88 && *(v11 - 2) == 48 )
    {
      *a2 = v11 - 1;
      return 0LL;
    }
LABEL_65:
    *a2 = a1;
    return 0LL;
  }
  if ( (a3 & 0xFFFFFFEF) != 0 )
    goto LABEL_49;
  if ( dword_4866E0[v11[1]] == 88 )
  {
    v12 = v11[2];
    v33 = 15;
    v11 += 2;
    v13 = 0LL;
    v14 = 0xFFFFFFFFFFFFFFFLL;
    a3 = 16;
    v5 = 0LL;
    goto LABEL_13;
  }
  if ( a3 )
  {
LABEL_49:
    if ( a3 == 10 )
    {
      if ( v5 )
        goto LABEL_57;
      v33 = 5;
      v13 = 0LL;
      v15 = 48LL;
      v14 = 0x1999999999999999LL;
    }
    else
    {
      v5 = 0LL;
      v13 = 0LL;
      v23 = a3 - 2;
      v15 = 48LL;
      v14 = _strtol_ul_max_tab[v23];
      v33 = _strtol_ul_rem_tab[v23];
    }
  }
  else
  {
    a3 = 8;
    v5 = 0LL;
    v13 = 0LL;
    v33 = 7;
    v14 = 0x1FFFFFFFFFFFFFFFLL;
    v15 = 48LL;
  }
LABEL_15:
  v16 = v11;
  result = 0LL;
  v18 = 0;
  do
  {
    v20 = v15 - 48;
    if ( (unsigned __int8)(v15 - 48) <= 9u )
      goto LABEL_25;
    if ( v13 )
    {
      v22 = 0LL;
      while ( v7[v22] == v16[v22] )
      {
        if ( ++v22 == v13 )
          goto LABEL_42;
      }
      v15 = (unsigned __int8)v15;
      if ( v13 == v22 )
      {
LABEL_42:
        v19 = &v16[v13 - 1];
        goto LABEL_19;
      }
    }
    if ( (word_486FE0[v15] & 0x400) == 0 )
      break;
    v20 = dword_4866E0[v15] - 55;
LABEL_25:
    if ( v20 >= a3 )
      break;
    if ( v14 < result || v14 == result && v20 > v33 )
    {
      v18 = 1;
      v15 = (unsigned __int8)*++v16;
      if ( v16 == v5 )
        break;
    }
    else
    {
      result = v20 + a3 * result;
      v19 = v16;
LABEL_19:
      v16 = v19 + 1;
      v15 = (unsigned __int8)v19[1];
      if ( v19 + 1 == v5 )
        break;
    }
  }
  while ( (_BYTE)v15 );
  if ( v16 == v11 )
    goto LABEL_62;
  if ( a2 )
    *a2 = v16;
  if ( v18 )
  {
    __writefsdword(0xFFFFFFC0, 0x22u);
    result = 0x8000000000000000LL;
    if ( !v34 )
      return 0x7FFFFFFFFFFFFFFFLL;
  }
  else if ( v34 )
  {
    if ( result > 0x8000000000000000LL )
    {
      __writefsdword(0xFFFFFFC0, 0x22u);
      return 0x8000000000000000LL;
    }
    else
    {
      return -(__int64)result;
    }
  }
  else if ( (result & 0x8000000000000000LL) != 0LL )
  {
    __writefsdword(0xFFFFFFC0, 0x22u);
    return 0x7FFFFFFFFFFFFFFFLL;
  }
  return result;
}
// 4010C8: using guessed type __int64 __fastcall j_strlen_ifunc(_QWORD);
// 4866E0: using guessed type unsigned int dword_4866E0[256];
// 486FE0: using guessed type _WORD word_486FE0[256];
// 491220: using guessed type _BYTE _strtol_ul_rem_tab[6];
// 491260: using guessed type _QWORD _strtol_ul_max_tab[6];

//----- (000000000044DAD0) ----------------------------------------------------
unsigned __int64 __fastcall strtoll_l(char *a1, char **a2, int a3, __int64 a4)
{
  return ___strtoll_l_internal(a1, a2, a3, 0, a4);
}

//----- (000000000044DAE0) ----------------------------------------------------
__int64 __fastcall read_int(_QWORD *a1)
{
  unsigned __int8 *v1; // rcx
  __int64 result; // rax
  int v3; // eax
  bool v4; // cc
  unsigned int v5; // edx

  v1 = (unsigned __int8 *)(*a1 + 1LL);
  result = (unsigned int)*(unsigned __int8 *)*a1 - 48;
  while ( 1 )
  {
    *a1 = v1;
    v5 = *v1 - 48;
    if ( v5 > 9 )
      break;
    if ( (int)result >= 0 )
    {
      if ( (int)result <= 214748364 )
      {
        v3 = 10 * result;
        v4 = (int)(0x7FFFFFFF - v5) < v3;
        result = v3 + v5;
        if ( v4 )
          result = 0xFFFFFFFFLL;
      }
      else
      {
        result = 0xFFFFFFFFLL;
      }
    }
    ++v1;
  }
  return result;
}

//----- (000000000044DB50) ----------------------------------------------------
_BYTE *__fastcall group_number(unsigned __int64 a1, _BYTE *a2, _BYTE *a3, _BYTE *a4, __int64 a5)
{
  _BYTE *v5; // rbx
  int v6; // ebp
  int v12; // eax
  _BYTE *v13; // rcx
  signed __int64 v14; // r13
  _BYTE *v15; // rsi
  _BYTE *v16; // rcx
  __int64 v17; // rdi
  char v18; // al
  int v19; // [rsp+0h] [rbp-48h]
  _BYTE *v20; // [rsp+8h] [rbp-40h]

  v5 = a2;
  v6 = (char)*a4;
  if ( (unsigned __int8)(*a4 - 1) <= 0x7Du )
  {
    v12 = j_strlen_ifunc(a5);
    v13 = a4 + 1;
    v14 = a3 - a2;
    v19 = v12;
    v20 = v13;
    j_memmove(a1, a2, a3 - a2);
    v15 = (_BYTE *)(a1 + a3 - a2);
    if ( a1 >= a1 + v14 )
      return a3;
    v16 = v20;
    while ( 1 )
    {
      --v15;
      v5 = a3 - 1;
      *(a3 - 1) = *v15;
      if ( --v6 )
      {
        if ( a1 >= (unsigned __int64)v15 )
          return v5;
      }
      else
      {
        if ( a1 >= (unsigned __int64)v15 )
          return v5;
        if ( v19 >= v5 - v15 )
          goto LABEL_18;
        v17 = v19;
        do
        {
          v18 = *(_BYTE *)(a5 + v17 - 1);
          --v5;
          --v17;
          *v5 = v18;
        }
        while ( (int)v17 > 0 );
        v6 = (char)*v16;
        if ( *v16 == 127 || (v6 & 0x80u) != 0 )
        {
LABEL_18:
          j_memmove(v5, v15, a1 - (_QWORD)v15);
          return v5;
        }
        if ( (_BYTE)v6 )
          ++v16;
        else
          v6 = (char)*(v16 - 1);
      }
      a3 = v5;
    }
  }
  return v5;
}
// 401030: using guessed type __int64 __fastcall j_memmove(_QWORD, _QWORD, _QWORD);
// 4010C8: using guessed type __int64 __fastcall j_strlen_ifunc(_QWORD);

//----- (000000000044DC70) ----------------------------------------------------
__int64 __fastcall i18n_number_rewrite(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v3; // r14
  _DWORD *v5; // rbx
  unsigned int v6; // er15
  unsigned int v7; // eax
  __int64 v8; // rcx
  u32 *v9; // r8
  unsigned __int64 v10; // r9
  __int64 v11; // r13
  unsigned __int64 v13; // r15
  __int64 v14; // rsi
  __int64 v15; // rdx
  __int64 v16; // rcx
  u32 *v17; // r8
  unsigned __int64 v18; // r9
  _BYTE *v19; // r13
  int v20; // eax
  __int64 v21; // r12
  __int64 v22; // rax
  __int16 *v23; // rdi
  __int16 *v24; // rdx
  int v25; // esi
  unsigned int v26; // eax
  bool v27; // zf
  __int64 v28; // rax
  __int64 v29; // rax
  u32 *v30; // r8
  __int64 v31; // r9
  __int64 v32; // rax
  unsigned int v33; // [rsp+0h] [rbp-498h]
  __int64 v34[2]; // [rsp+10h] [rbp-488h] BYREF
  _BYTE v35[1024]; // [rsp+20h] [rbp-478h] BYREF
  __int16 v36[16]; // [rsp+420h] [rbp-78h] BYREF
  __int16 v37[12]; // [rsp+440h] [rbp-58h] BYREF
  unsigned __int64 v38; // [rsp+458h] [rbp-40h]

  v3 = a1;
  v38 = __readfsqword(0x28u);
  v5 = (_DWORD *)wctrans((__int64)"to_outpunct");
  v6 = towctrans(0x2Eu, v5);
  v7 = towctrans(0x2Cu, v5);
  if ( v5 )
  {
    v33 = v7;
    v34[0] = 0LL;
    v29 = wcrtomb((char *)v36, v6, v34, v8, v9, v10);
    if ( v29 == -1 )
      v36[0] = 46;
    else
      *((_BYTE *)v36 + v29) = 0;
    v34[0] = 0LL;
    v32 = wcrtomb((char *)v37, v33, v34, v33, v30, v31);
    if ( v32 == -1 )
      v37[0] = 44;
    else
      *((_BYTE *)v37 + v32) = 0;
  }
  v11 = a2 - a1;
  v34[0] = (__int64)v35;
  v34[1] = 1024LL;
  if ( (unsigned __int8)_libc_scratch_buffer_set_array_size(v34, a2 - a1, 1LL, v8, v9, v10) )
  {
    v13 = v34[0];
    v14 = a1;
    v3 = a3;
    v19 = (_BYTE *)j_mempcpy(v34[0], a1, v11);
LABEL_5:
    while ( v13 <= (unsigned __int64)--v19 )
    {
      while ( 1 )
      {
        v20 = (char)*v19;
        v15 = (unsigned int)(v20 - 48);
        if ( (unsigned __int8)(*v19 - 48) <= 9u )
          break;
        if ( v5 )
        {
          v15 = v20 & 0xFFFFFFFD;
          if ( (v20 & 0xFD) == 44 )
          {
            v23 = v37;
            if ( (_BYTE)v20 == 46 )
              v23 = v36;
            v24 = v23;
            do
            {
              v25 = *(_DWORD *)v24;
              v24 += 2;
              v26 = ~v25 & (v25 - 16843009) & 0x80808080;
            }
            while ( !v26 );
            v27 = (~v25 & (v25 - 16843009) & 0x8080) == 0;
            if ( (~v25 & (v25 - 16843009) & 0x8080) == 0 )
              v26 >>= 16;
            v14 = (__int64)(v24 + 1);
            if ( v27 )
              ++v24;
            v16 = v26;
            LOBYTE(v16) = 2 * v26;
            v15 = (char *)v24 - __CFADD__((_BYTE)v26, (_BYTE)v26) - 3 - (char *)v23;
            v3 -= v15;
            v28 = v15 - 1;
            if ( v15 )
            {
              do
              {
                v15 = *((unsigned __int8 *)v23 + v28);
                *(_BYTE *)(v3 + v28--) = v15;
              }
              while ( v28 != -1 );
            }
            goto LABEL_5;
          }
        }
        --v19;
        *(_BYTE *)--v3 = v20;
        if ( v13 > (unsigned __int64)v19 )
          goto LABEL_9;
      }
      v21 = *(_QWORD *)(*(_QWORD *)__readfsqword(0xFFFFFFA0) + 8LL * (v20 - 7) + 64);
      v22 = j_strlen_ifunc(v21);
      v3 -= v22;
      v15 = v22 - 1;
      if ( v22 )
      {
        do
        {
          *(_BYTE *)(v3 + v15) = *(_BYTE *)(v21 + v15);
          --v15;
        }
        while ( v15 != -1 );
      }
    }
LABEL_9:
    if ( (_BYTE *)v34[0] != v35 )
      free(v34[0], v14, v15, v16, v17, v18);
  }
  return v3;
}
// 44DCF7: variable 'v8' is possibly undefined
// 44DCF7: variable 'v9' is possibly undefined
// 44DCF7: variable 'v10' is possibly undefined
// 44DDA4: variable 'v15' is possibly undefined
// 44DDA4: variable 'v16' is possibly undefined
// 44DDA4: variable 'v17' is possibly undefined
// 44DDA4: variable 'v18' is possibly undefined
// 44DEC6: variable 'v30' is possibly undefined
// 44DEC6: variable 'v31' is possibly undefined
// 4010B0: using guessed type __int64 __fastcall j_mempcpy(_QWORD, _QWORD, _QWORD);
// 4010C8: using guessed type __int64 __fastcall j_strlen_ifunc(_QWORD);

//----- (000000000044DF10) ----------------------------------------------------
__int64 __fastcall IO_helper_overflow(_QWORD *a1, unsigned __int8 a2, __int64 a3, __int64 a4, u32 *a5, __int64 a6)
{
  unsigned __int8 *v8; // rcx
  __int64 v9; // rsi
  int v10; // ebp
  __int64 v11; // rdi
  __int64 v12; // r13
  __int64 v13; // rcx
  __int64 v14; // r13
  __int64 result; // rax

  v8 = (unsigned __int8 *)a1[5];
  v9 = a1[4];
  v10 = (_DWORD)v8 - v9;
  if ( *((_DWORD *)a1 + 10) != (_DWORD)v9 )
  {
    v11 = a1[28];
    v12 = *(_QWORD *)(v11 + 216);
    v13 = v12 - (_QWORD)_start___libc_IO_vtables;
    if ( (char *)&_start___libc_atexit - (char *)_start___libc_IO_vtables <= (unsigned __int64)(v12
                                                                                              - (_QWORD)_start___libc_IO_vtables) )
    {
      IO_vtable_check(v11, v9, (__int64)_start___libc_IO_vtables, v13, a5, a6);
      v9 = a1[4];
    }
    v14 = (*(__int64 (__fastcall **)(__int64, __int64, _QWORD, __int64, u32 *))(v12 + 56))(v11, v9, v10, v13, a5);
    if ( (unsigned __int64)(v14 - 1) > 0xFFFFFFFFFFFFFFFDLL )
      return 0xFFFFFFFFLL;
    j_memmove(a1[4], a1[4] + v14, v10 - v14);
    v8 = (unsigned __int8 *)(a1[5] - v14);
    a1[5] = v8;
  }
  result = a2;
  if ( a1[6] <= (unsigned __int64)v8 )
    return _overflow((__int64)a1, a2, a3, (__int64)v8, a5, a6);
  a1[5] = v8 + 1;
  *v8 = a2;
  return result;
}
// 44DF66: variable 'v13' is possibly undefined
// 44DF66: variable 'a5' is possibly undefined
// 44DFDF: variable 'a3' is possibly undefined
// 44DFDF: variable 'a6' is possibly undefined
// 401030: using guessed type __int64 __fastcall j_memmove(_QWORD, _QWORD, _QWORD);
// 4A9C40: using guessed type u32 _start___libc_IO_vtables[48];
// 4AA2E8: using guessed type __int64 (__fastcall *_start___libc_atexit)();

//----- (000000000044DFF0) ----------------------------------------------------
__int64 __fastcall printf_positional(
        char *a1,
        __int64 a2,
        int a3,
        __int64 a4,
        u32 *a5,
        unsigned __int64 a6,
        int a7,
        _BYTE *a8,
        __int64 a9,
        int a10,
        char *a11,
        __int64 a12)
{
  __int64 *v12; // rcx
  _BYTE *v13; // r15
  unsigned __int64 v14; // rbx
  unsigned __int64 v15; // r14
  unsigned __int64 v16; // r12
  __int64 v17; // rax
  unsigned __int64 v18; // rsi
  __int64 v19; // r13
  __int64 v20; // rax
  _QWORD *v21; // rdx
  __int64 v22; // rdx
  unsigned __int64 i; // rcx
  __int64 v24; // r8
  __int64 v25; // r9
  __int64 v26; // r12
  unsigned __int64 v27; // r15
  __int64 v28; // rbx
  __int64 v29; // r13
  __int64 v30; // r12
  __int64 v31; // rax
  __int64 v32; // rax
  __int64 v33; // rdx
  __int64 v34; // r9
  __int64 v35; // rdi
  __int64 v36; // r13
  __int64 v37; // rax
  long double *v38; // rax
  int v39; // er14
  __int64 *v40; // r15
  unsigned __int8 v41; // al
  char v42; // dl
  char v43; // r13
  int v44; // edi
  __int64 v45; // rdx
  bool v46; // r13
  int v47; // er12
  __int64 v48; // rbx
  int v49; // er11
  __int64 v50; // rax
  int v51; // eax
  _BOOL4 v52; // eax
  __int64 *v53; // rdx
  void *v54; // rsp
  __int64 v55; // rax
  unsigned int v56; // eax
  unsigned int v57; // eax
  unsigned __int64 *v58; // rsi
  unsigned int v59; // eax
  unsigned int *v60; // rsi
  unsigned int v61; // eax
  unsigned int *v62; // rsi
  __int64 (__fastcall *v63)(char *, __int64 *, _BYTE *); // rax
  __int64 v64; // rdx
  __int64 *v65; // rbx
  __int16 v66; // dx
  __int64 v67; // rdx
  void *v68; // rsp
  int v69; // edi
  _BYTE *v70; // rax
  char v71; // al
  _BYTE *v72; // rax
  int v73; // ebx
  _BYTE *v74; // rax
  _BYTE *v75; // rax
  _BYTE *v76; // rax
  int v77; // eax
  _BYTE *v78; // rax
  unsigned __int64 v79; // r13
  unsigned __int8 *v80; // r12
  unsigned __int64 v81; // rax
  char *v82; // r13
  unsigned __int8 *v83; // r14
  _BYTE *v84; // rax
  unsigned int v85; // ebx
  unsigned int v87; // er10
  __int64 v88; // rax
  __int64 v89; // rbx
  char v90; // al
  unsigned __int64 v91; // rdi
  __int64 v92; // rcx
  __int64 *v93; // rsi
  __int16 v94; // cx
  unsigned int v95; // ecx
  int v96; // er10
  unsigned int v97; // ecx
  __int64 v98; // rsi
  __int64 v99; // r8
  int v100; // eax
  __int64 v101; // rbx
  __int64 v102; // rax
  char *v103; // rdi
  __int64 v104; // rax
  __int64 v105; // rax
  unsigned __int64 v106; // r13
  bool v107; // r12
  __int64 *v108; // rax
  __int64 *v109; // rcx
  int v110; // eax
  __int64 v111; // r9
  char v112; // al
  _BYTE *v113; // rax
  __int64 v114; // r13
  __int64 v115; // rbx
  char *v116; // rdi
  _BYTE *v117; // rax
  _BYTE *v118; // rax
  _BYTE *v119; // rax
  char v120; // di
  __int64 v121; // rcx
  int v122; // er13
  _BYTE *v123; // rax
  bool v124; // r13
  _BYTE *v125; // rax
  __int64 v126; // rax
  int v127; // ebx
  char v128; // al
  char *v129; // rdi
  _BYTE *v130; // rax
  _BYTE *v131; // rax
  _BYTE *v132; // rax
  int v133; // ebx
  __int64 v134; // rbx
  _QWORD *v135; // rax
  unsigned __int8 *v136; // rax
  const __m128i *v137; // r13
  int v138; // er12
  __int64 v139; // rax
  unsigned __int64 v140; // rbx
  int v141; // er11
  __int64 v142; // rcx
  unsigned __int64 *v143; // rax
  _QWORD *v144; // rax
  int v145; // er12
  _BYTE *v146; // rax
  _BYTE *v147; // rax
  void *v148; // rsp
  unsigned int v149; // er9
  _BYTE *v150; // r13
  _QWORD *v151; // rax
  _BYTE *v152; // rax
  __int64 *v153; // rax
  __int64 v154; // r12
  _BYTE *v155; // rax
  _BYTE *v156; // rax
  __int64 v157; // rsi
  __int64 *v158; // rdi
  __int16 v159; // si
  signed __int64 v160; // rax
  void *v161; // rsp
  _BYTE *v162; // rax
  _BOOL4 v163; // eax
  __int64 v164; // rcx
  _QWORD *v165; // rdx
  int v166; // er11
  __int64 *v167; // rbx
  void *v168; // rsp
  __int64 v169; // rax
  _BYTE *v170; // rax
  __int64 v171; // rax
  unsigned __int64 v172; // r13
  unsigned __int8 *v173; // r12
  unsigned __int64 v174; // rax
  char *v175; // r13
  unsigned __int8 *v176; // r14
  _BYTE *v177; // rax
  _BYTE *v178; // rax
  _BYTE *v179; // rax
  __int64 v180; // rax
  __int64 v181; // rax
  __int64 v182; // rbx
  _BYTE *v183; // r13
  __int64 v184; // rax
  unsigned __int64 v185; // rbx
  __int64 v186; // rdx
  __int64 v187; // rcx
  u32 *v188; // r8
  __int64 v189; // r9
  int v190; // eax
  __int64 v191; // rax
  _BOOL4 v192; // eax
  __int64 v193; // rcx
  _QWORD *v194; // rdx
  int v195; // er11
  __int64 *v196; // rcx
  void *v197; // rsp
  int v198; // eax
  int v199; // eax
  _QWORD *v200; // rax
  __int64 v201; // rax
  int v202; // eax
  int v203; // eax
  int v204; // eax
  int v205; // eax
  __int64 v206; // [rsp+0h] [rbp-2968h]
  __int64 v207; // [rsp+8h] [rbp-2960h] BYREF
  u32 v208[1022]; // [rsp+10h] [rbp-2958h] BYREF
  __int64 v209; // [rsp+1008h] [rbp-1960h] BYREF
  _BYTE v210[7]; // [rsp+1010h] [rbp-1958h] BYREF
  __int64 v211; // [rsp+2008h] [rbp-960h] BYREF
  _BYTE *v212; // [rsp+2010h] [rbp-958h]
  char *v213; // [rsp+2018h] [rbp-950h]
  _BYTE *v214; // [rsp+2020h] [rbp-948h]
  unsigned __int64 v215; // [rsp+2028h] [rbp-940h]
  __int64 v216; // [rsp+2030h] [rbp-938h]
  __int64 v217; // [rsp+2038h] [rbp-930h]
  unsigned int v218; // [rsp+2040h] [rbp-928h]
  int v219; // [rsp+2044h] [rbp-924h]
  bool v220; // [rsp+204Bh] [rbp-91Dh]
  unsigned int v221; // [rsp+204Ch] [rbp-91Ch]
  __int64 v222; // [rsp+2050h] [rbp-918h]
  __int64 v223; // [rsp+2058h] [rbp-910h]
  _BYTE *v224; // [rsp+2060h] [rbp-908h]
  unsigned int v225; // [rsp+2068h] [rbp-900h]
  int v226; // [rsp+206Ch] [rbp-8FCh]
  unsigned __int64 v227; // [rsp+2070h] [rbp-8F8h]
  unsigned __int64 v228; // [rsp+2078h] [rbp-8F0h]
  unsigned __int64 v229; // [rsp+2080h] [rbp-8E8h]
  char *v230; // [rsp+2088h] [rbp-8E0h]
  __int64 v231; // [rsp+2090h] [rbp-8D8h]
  __int64 v232; // [rsp+2098h] [rbp-8D0h]
  __int64 v233; // [rsp+20A0h] [rbp-8C8h]
  __int64 *v234; // [rsp+20A8h] [rbp-8C0h]
  unsigned __int64 v235; // [rsp+20B0h] [rbp-8B8h]
  char *v236; // [rsp+20B8h] [rbp-8B0h]
  __int64 *v237; // [rsp+20C0h] [rbp-8A8h]
  unsigned __int64 *v238; // [rsp+20C8h] [rbp-8A0h]
  __int64 *v239; // [rsp+20D0h] [rbp-898h]
  unsigned __int64 v240; // [rsp+20D8h] [rbp-890h] BYREF
  long double *v241; // [rsp+20E0h] [rbp-888h] BYREF
  const __m128i *v242; // [rsp+20E8h] [rbp-880h] BYREF
  __int64 v243; // [rsp+20F0h] [rbp-878h] BYREF
  __int64 *v244; // [rsp+20F8h] [rbp-870h] BYREF
  unsigned __int64 v245; // [rsp+2100h] [rbp-868h]
  __int64 v246; // [rsp+2108h] [rbp-860h] BYREF
  __int64 v247[2]; // [rsp+2508h] [rbp-460h] BYREF
  __int64 v248; // [rsp+2518h] [rbp-450h] BYREF
  char v249; // [rsp+2918h] [rbp-50h] BYREF
  _BYTE v250[68]; // [rsp+2924h] [rbp-44h] BYREF

  v12 = (__int64 *)a11;
  v236 = a1;
  v217 = a2;
  v13 = a8;
  v222 = a9;
  v219 = a3;
  v235 = (unsigned __int64)a5;
  LODWORD(v232) = a6;
  v230 = a11;
  v223 = a12;
  *(_QWORD *)&v250[12] = __readfsqword(0x28u);
  v245 = 1024LL;
  v237 = (__int64 *)&v244;
  v244 = &v246;
  v234 = v247;
  v247[0] = (__int64)&v248;
  v247[1] = 1024LL;
  v240 = 0LL;
  if ( a11 == (char *)-1LL )
  {
    v88 = *(_QWORD *)__readfsqword(0xFFFFFFB8);
    v89 = *(_QWORD *)(v88 + 72);
    v230 = *(char **)(v88 + 80);
    v90 = *v230;
    v223 = v89;
    if ( !v90 || v90 == 127 )
      v230 = 0LL;
  }
  v14 = 0LL;
  v15 = 0LL;
  if ( *a8 )
  {
    v16 = 14LL;
    v239 = v237 + 2;
    v238 = &v240;
    while ( 1 )
    {
      v17 = 9 * v15;
      v18 = v14;
      ++v15;
      v19 = (__int64)&v239[v17];
      v20 = _parse_one_specmb((__int64)v13, v14, v19);
      v13 = *(_BYTE **)(v19 + 32);
      v14 += v20;
      if ( !*v13 )
        break;
      if ( v16 == v15 )
      {
        if ( !(unsigned __int8)_libc_scratch_buffer_grow_preserve(v237, v18, v21, v12, a5, a6) )
          goto LABEL_124;
        v239 = v244;
        v16 = v245 / 0x48;
      }
    }
    if ( v240 >= v14 )
      v14 = v240;
  }
  else
  {
    v239 = v237 + 2;
  }
  v18 = v14;
  if ( !(unsigned __int8)_libc_scratch_buffer_set_array_size(v234, v14, 24LL, (__int64)v12, a5, a6) )
    goto LABEL_124;
  v26 = v247[0] + 16 * v14;
  v238 = (unsigned __int64 *)v247[0];
  v27 = v26 + 4 * v14;
  LODWORD(v233) = *((_DWORD *)v236 + 29);
  v18 = (unsigned int)((int)((_DWORD)v233 << 29) >> 31);
  j_memset_ifunc(v27, v18, 4 * v14);
  if ( !v15 )
  {
    if ( !v14 )
      goto LABEL_188;
LABEL_23:
    i = (unsigned __int64)v238;
    v22 = v235;
    v36 = 0LL;
    while ( 1 )
    {
      v37 = *(int *)(v27 + 4 * v36);
      if ( (int)v37 <= 5 )
        break;
      if ( (_DWORD)v37 == 256 )
        goto LABEL_63;
      if ( (int)v37 <= 256 )
      {
        if ( (int)v37 <= 7 )
        {
          v56 = *(_DWORD *)(v22 + 4);
          if ( v56 > 0xAF )
          {
            v18 = *(_QWORD *)(v22 + 8);
            *(_QWORD *)(v22 + 8) = v18 + 8;
          }
          else
          {
            v18 = *(_QWORD *)(v22 + 16) + v56;
            *(_DWORD *)(v22 + 4) = v56 + 16;
          }
          *(_QWORD *)(i + 16 * v36) = *(_QWORD *)v18;
          goto LABEL_37;
        }
        goto LABEL_62;
      }
      if ( (_DWORD)v37 == 512 )
        goto LABEL_63;
      if ( (_DWORD)v37 == 1024 )
        goto LABEL_70;
      if ( (_DWORD)v37 != 263 )
        goto LABEL_62;
      v38 = (long double *)((*(_QWORD *)(v22 + 8) + 15LL) & 0xFFFFFFFFFFFFFFF0LL);
      v18 = (unsigned __int64)(v38 + 1);
      *(_QWORD *)(v22 + 8) = v38 + 1;
      *(long double *)(i + 16 * v36) = *v38;
LABEL_37:
      if ( ++v36 >= v14 )
        goto LABEL_38;
    }
    if ( (int)v37 < 3 )
    {
      if ( (int)v37 > 1 )
      {
        v59 = *(_DWORD *)v22;
        if ( *(_DWORD *)v22 > 0x2Fu )
        {
          v60 = *(unsigned int **)(v22 + 8);
          *(_QWORD *)(v22 + 8) = v60 + 2;
        }
        else
        {
          v60 = (unsigned int *)(*(_QWORD *)(v22 + 16) + v59);
          *(_DWORD *)v22 = v59 + 8;
        }
        v18 = *v60;
        *(_DWORD *)(i + 16 * v36) = v18;
        goto LABEL_37;
      }
      if ( (int)v37 >= 0 )
      {
LABEL_70:
        v61 = *(_DWORD *)v22;
        if ( *(_DWORD *)v22 > 0x2Fu )
        {
          v62 = *(unsigned int **)(v22 + 8);
          *(_QWORD *)(v22 + 8) = v62 + 2;
        }
        else
        {
          v62 = (unsigned int *)(*(_QWORD *)(v22 + 16) + v61);
          *(_DWORD *)v22 = v61 + 8;
        }
        v18 = *v62;
        *(_DWORD *)(i + 16 * v36) = v18;
        goto LABEL_37;
      }
      if ( (_DWORD)v37 == -1 )
      {
        if ( (v236[116] & 4) != 0 )
          _libc_fatal((__int64)"*** invalid %N$ use detected ***\n", v18, v22, i, (u32 *)v24, v25);
        _assert_fail((__int64)"s->_flags2 & _IO_FLAGS2_FORTIFY", (__int64)"vfprintf.c", 0x75Fu, "printf_positional");
      }
LABEL_62:
      if ( (v37 & 0x800) == 0 )
      {
        v24 = _printf_va_arg_table;
        if ( _printf_va_arg_table && *(_QWORD *)(_printf_va_arg_table + 8 * v37 - 64) )
        {
          v157 = *(int *)(v26 + 4 * v36) + 23LL;
          v158 = (__int64 *)((char *)&v211 - (v157 & 0xFFFFFFFFFFFFF000LL));
          v159 = v157 & 0xFFF0;
          if ( &v211 != v158 )
          {
            while ( &v209 != v158 )
              ;
          }
          v160 = v159 & 0xFFF;
          if ( (v159 & 0xFFF) != 0 )
          {
            v161 = alloca(v160);
            *(_QWORD *)((char *)&v208[1020] + v160) = *(_QWORD *)((char *)&v208[1020] + v160);
          }
          v233 = i;
          v18 = v22;
          v235 = v22;
          *(_QWORD *)(i + 16 * v36) = v210;
          (*(void (__fastcall **)(_BYTE *, __int64))(v24 + 8LL * *(int *)(v27 + 4 * v36) - 64))(v210, v22);
          v22 = v235;
          i = v233;
        }
        else
        {
          *(long double *)(i + 16 * v36) = 0.0;
        }
        goto LABEL_37;
      }
    }
LABEL_63:
    v57 = *(_DWORD *)v22;
    if ( *(_DWORD *)v22 > 0x2Fu )
    {
      v58 = *(unsigned __int64 **)(v22 + 8);
      *(_QWORD *)(v22 + 8) = v58 + 1;
    }
    else
    {
      v58 = (unsigned __int64 *)(*(_QWORD *)(v22 + 16) + v57);
      *(_DWORD *)v22 = v57 + 8;
    }
    v18 = *v58;
    *(_QWORD *)(i + 16 * v36) = v18;
    goto LABEL_37;
  }
  i = (unsigned __int64)v239;
  v233 = v14;
  v28 = v26;
  v24 = (__int64)&v239[9 * v15];
  v29 = (__int64)v239;
  v30 = v24;
  do
  {
    while ( 1 )
    {
      v31 = *(int *)(v29 + 44);
      if ( (_DWORD)v31 != -1 )
        *(_DWORD *)(v27 + 4 * v31) = 0;
      v32 = *(int *)(v29 + 40);
      if ( (_DWORD)v32 != -1 )
        *(_DWORD *)(v27 + 4 * v32) = 0;
      v18 = *(_QWORD *)(v29 + 56);
      if ( !v18 )
        goto LABEL_14;
      if ( v18 != 1 )
        break;
      *(_DWORD *)(v27 + 4LL * *(int *)(v29 + 48)) = *(_DWORD *)(v29 + 52);
      v22 = *(unsigned int *)(v29 + 64);
      *(_DWORD *)(v28 + 4LL * *(int *)(v29 + 48)) = v22;
LABEL_14:
      v29 += 72LL;
      if ( v30 == v29 )
        goto LABEL_22;
    }
    v33 = *(int *)(v29 + 48);
    v34 = *(int *)(v29 + 8);
    v35 = v29;
    v29 += 72LL;
    (*(void (__fastcall **)(__int64, unsigned __int64, unsigned __int64, __int64))(_printf_arginfo_table + 8 * v34))(
      v35,
      v18,
      v27 + 4 * v33,
      v28 + 4 * v33);
  }
  while ( v30 != v29 );
LABEL_22:
  v26 = v28;
  v14 = v233;
  if ( v233 )
    goto LABEL_23;
LABEL_38:
  v235 = a7;
  if ( v15 <= a7 )
  {
LABEL_188:
    v85 = v232;
    goto LABEL_125;
  }
  v215 = v15;
  v39 = v232;
  v214 = (_BYTE *)(v222 + 1000);
  v40 = &v239[9 * v235];
  v213 = &v249;
  v212 = v250;
  while ( 2 )
  {
    v41 = *((_BYTE *)v40 + 12);
    v25 = *((unsigned int *)v40 + 2);
    LOBYTE(v232) = *((_DWORD *)v40 + 2);
    v42 = *((_BYTE *)v40 + 13);
    LOBYTE(v221) = (v41 & 8) != 0;
    v43 = v42;
    LODWORD(v231) = (v41 & 0x20) != 0;
    LOBYTE(v227) = (v41 & 2) != 0;
    LOBYTE(v229) = (v41 & 0x10) != 0;
    v44 = *((_DWORD *)v40 + 4);
    v220 = (v42 & 8) != 0;
    v45 = *((int *)v40 + 11);
    i = (v41 & 0x40) != 0;
    LOBYTE(v225) = v41 >> 7;
    v46 = (v43 & 2) != 0;
    LOBYTE(v228) = (v41 & 0x40) != 0;
    LOBYTE(v47) = (v41 & 4) != 0;
    v48 = *(int *)v40;
    v226 = v44;
    if ( (_DWORD)v45 == -1 )
    {
      v49 = *((_DWORD *)v40 + 1);
    }
    else
    {
      i = (unsigned __int64)v238;
      v49 = v238[2 * v45];
      if ( v49 < 0 )
      {
        LODWORD(v231) = 1;
        v49 = -v49;
        *((_DWORD *)v40 + 1) = v49;
        *((_BYTE *)v40 + 12) = v41 | 0x20;
      }
      else
      {
        *((_DWORD *)v40 + 1) = v49;
      }
    }
    v50 = *((int *)v40 + 10);
    if ( (_DWORD)v50 != -1 )
    {
      v48 = SLODWORD(v238[2 * v50]);
      if ( (int)v48 < 0 )
      {
        *(_DWORD *)v40 = -1;
        v48 = -1LL;
      }
      else
      {
        *(_DWORD *)v40 = v48;
      }
    }
    v51 = v48;
    if ( v49 >= (int)v48 )
      v51 = v49;
    if ( v51 <= 968 )
    {
      v233 = 0LL;
      v224 = v214;
    }
    else
    {
      LODWORD(v216) = v25;
      LODWORD(v224) = v49;
      v233 = v51 + 32;
      v218 = v51 + 32;
      v52 = _libc_alloca_cutoff(v233);
      v49 = (int)v224;
      v25 = (unsigned int)v216;
      if ( v52 || (i = v218, (int)v218 <= 4096) )
      {
        v53 = (__int64 *)((char *)&v211 - ((v233 + 23) & 0xFFFFFFFFFFFFF000LL));
        if ( &v211 != v53 )
        {
          while ( &v209 != v53 )
            ;
        }
        if ( (((_WORD)v233 + 23) & 0xFF0) != 0 )
        {
          v54 = alloca(((_WORD)v233 + 23) & 0xFF0);
          *(_QWORD *)((char *)&v208[1020] + (((_WORD)v233 + 23) & 0xFF0)) = *(_QWORD *)((char *)&v208[1020]
                                                                                      + (((_WORD)v233 + 23) & 0xFF0));
        }
        if ( v49 >= (int)v48 )
          v55 = v49 + 32LL;
        else
          v55 = (int)v48 + 32LL;
        v233 = 0LL;
        v224 = &v210[v55];
      }
      else
      {
        v200 = malloc(v233, v18, (_QWORD *)v233, v218, (u32 *)v24, (unsigned int)v216);
        v49 = (int)v224;
        v25 = (unsigned int)v216;
        v233 = (__int64)v200;
        if ( !v200 )
          goto LABEL_124;
        if ( (int)v224 >= (int)v48 )
          v201 = (int)v224 + 32LL;
        else
          v201 = (int)v48 + 32LL;
        v224 = (_BYTE *)(v233 + v201);
      }
    }
    if ( _printf_function_table )
    {
      v24 = (char)v232;
      v63 = *(__int64 (__fastcall **)(char *, __int64 *, _BYTE *))(_printf_function_table + 8LL * (char)v232);
      if ( v63 )
      {
        v91 = v40[7];
        v92 = 8 * v91 + 23;
        v93 = (__int64 *)&v210[-(v92 & 0xFFFFFFFFFFFFF000LL) - 8];
        v94 = v92 & 0xFFF0;
        while ( &v209 != v93 )
          ;
        v95 = v94 & 0xFFF;
        if ( v95 )
        {
          v148 = alloca(v95);
          *(_QWORD *)((char *)&v208[1020] + v95) = *(_QWORD *)((char *)&v208[1020] + v95);
        }
        if ( v91 )
        {
          v216 = v24;
          v96 = *((_DWORD *)v40 + 12);
          v97 = 0;
          v98 = 0LL;
          v99 = (__int64)v238;
          do
          {
            *(_QWORD *)&v210[8 * v98] = v99 + 16LL * (v96 + v97++);
            v98 = v97;
          }
          while ( v91 > v97 );
          v63 = *(__int64 (__fastcall **)(char *, __int64 *, _BYTE *))(_printf_function_table + 8 * v216);
        }
        v218 = v25;
        v18 = (unsigned __int64)v40;
        LODWORD(v216) = v49;
        v100 = v63(v236, v40, v210);
        v49 = v216;
        v25 = v218;
        if ( v100 != -2 )
        {
          if ( v100 < 0 )
            goto LABEL_122;
          if ( (unsigned int)v39 > 0x7FFFFFFE )
            _assert_fail(
              (__int64)"(unsigned int) done < (unsigned int) INT_MAX",
              (__int64)"vfprintf.c",
              0x7DAu,
              "printf_positional");
LABEL_149:
          v22 = (unsigned int)(0x7FFFFFFF - v39);
          if ( (unsigned int)v22 < v100 )
            goto LABEL_186;
          v39 += v100;
          goto LABEL_151;
        }
      }
    }
    if ( (unsigned __int8)(v25 - 32) > 0x5Au )
    {
LABEL_83:
      v18 = v40[7];
      v64 = 8 * v18 + 23;
      v65 = (__int64 *)&v210[-(v64 & 0xFFFFFFFFFFFFF000LL) - 8];
      v66 = v64 & 0xFFF0;
      if ( &v209 != v65 )
      {
        while ( &v207 != v65 )
          ;
      }
      v67 = v66 & 0xFFF;
      if ( (_DWORD)v67 )
      {
        v68 = alloca((unsigned int)v67);
        *(__int64 *)((char *)&v206 + (unsigned int)v67) = *(__int64 *)((char *)&v206 + (unsigned int)v67);
      }
      v24 = (__int64)v208;
      if ( v18 )
      {
        v69 = *((_DWORD *)v40 + 12);
        v25 = (__int64)v238;
        LODWORD(v67) = 0;
        for ( i = 0LL; i < v18; v67 = i )
        {
          *(_QWORD *)&v208[2 * i] = v25 + 16LL * (unsigned int)(v69 + v67);
          i = (unsigned int)(v67 + 1);
        }
      }
      v70 = (_BYTE *)*((_QWORD *)v236 + 5);
      if ( (unsigned __int64)v70 >= *((_QWORD *)v236 + 6) )
      {
        v18 = 37LL;
        if ( (unsigned int)_overflow((__int64)v236, 37LL, v67, i, v208, v25) == -1 )
          goto LABEL_122;
      }
      else
      {
        v22 = (__int64)(v70 + 1);
        *((_QWORD *)v236 + 5) = v70 + 1;
        *v70 = 37;
      }
      v71 = *((_BYTE *)v40 + 12);
      if ( (v71 & 8) != 0 )
      {
        v72 = (_BYTE *)*((_QWORD *)v236 + 5);
        if ( (unsigned __int64)v72 >= *((_QWORD *)v236 + 6) )
        {
          v18 = 35LL;
          if ( (unsigned int)_overflow((__int64)v236, 35LL, v22, i, (u32 *)v24, v25) == -1 )
            goto LABEL_122;
        }
        else
        {
          v22 = (__int64)(v72 + 1);
          *((_QWORD *)v236 + 5) = v72 + 1;
          *v72 = 35;
        }
        v71 = *((_BYTE *)v40 + 12);
        v73 = 2;
      }
      else
      {
        v73 = 1;
      }
      if ( v71 < 0 )
      {
        v170 = (_BYTE *)*((_QWORD *)v236 + 5);
        if ( (unsigned __int64)v170 >= *((_QWORD *)v236 + 6) )
        {
          v18 = 39LL;
          if ( (unsigned int)_overflow((__int64)v236, 39LL, v22, (__int64)v236, (u32 *)v24, v25) == -1 )
            goto LABEL_122;
        }
        else
        {
          i = (unsigned __int64)v236;
          v22 = (__int64)(v170 + 1);
          *((_QWORD *)v236 + 5) = v170 + 1;
          *v170 = 39;
        }
        ++v73;
        v71 = *((_BYTE *)v40 + 12);
      }
      if ( (v71 & 0x40) != 0 )
      {
        v74 = (_BYTE *)*((_QWORD *)v236 + 5);
        if ( (unsigned __int64)v74 >= *((_QWORD *)v236 + 6) )
        {
          v18 = 43LL;
          if ( (unsigned int)_overflow((__int64)v236, 43LL, v22, (__int64)v236, (u32 *)v24, v25) == -1 )
            goto LABEL_122;
        }
        else
        {
          i = (unsigned __int64)v236;
          v22 = (__int64)(v74 + 1);
          *((_QWORD *)v236 + 5) = v74 + 1;
          *v74 = 43;
        }
      }
      else
      {
        if ( (v71 & 0x10) == 0 )
          goto LABEL_101;
        v18 = (unsigned __int64)v236;
        v162 = (_BYTE *)*((_QWORD *)v236 + 5);
        if ( (unsigned __int64)v162 >= *((_QWORD *)v236 + 6) )
        {
          v18 = 32LL;
          if ( (unsigned int)_overflow((__int64)v236, 32LL, v22, i, (u32 *)v24, v25) == -1 )
            goto LABEL_122;
        }
        else
        {
          i = (unsigned __int64)v236;
          v22 = (__int64)(v162 + 1);
          *((_QWORD *)v236 + 5) = v162 + 1;
          *v162 = 32;
        }
      }
      v71 = *((_BYTE *)v40 + 12);
      ++v73;
LABEL_101:
      if ( (v71 & 0x20) != 0 )
      {
        v75 = (_BYTE *)*((_QWORD *)v236 + 5);
        if ( (unsigned __int64)v75 >= *((_QWORD *)v236 + 6) )
        {
          v18 = 45LL;
          if ( (unsigned int)_overflow((__int64)v236, 45LL, v22, i, (u32 *)v24, v25) == -1 )
            goto LABEL_122;
        }
        else
        {
          i = (unsigned __int64)v236;
          v22 = (__int64)(v75 + 1);
          *((_QWORD *)v236 + 5) = v75 + 1;
          *v75 = 45;
        }
        ++v73;
      }
      if ( *((_DWORD *)v40 + 4) == 48 )
      {
        v178 = (_BYTE *)*((_QWORD *)v236 + 5);
        if ( (unsigned __int64)v178 >= *((_QWORD *)v236 + 6) )
        {
          v18 = 48LL;
          if ( (unsigned int)_overflow((__int64)v236, 48LL, v22, (__int64)v236, (u32 *)v24, v25) == -1 )
            goto LABEL_122;
        }
        else
        {
          i = (unsigned __int64)v236;
          v22 = (__int64)(v178 + 1);
          *((_QWORD *)v236 + 5) = v178 + 1;
          *v178 = 48;
        }
        ++v73;
      }
      if ( (*((_BYTE *)v40 + 13) & 8) != 0 )
      {
        v18 = (unsigned __int64)v236;
        v76 = (_BYTE *)*((_QWORD *)v236 + 5);
        if ( (unsigned __int64)v76 >= *((_QWORD *)v236 + 6) )
        {
          v18 = 73LL;
          if ( (unsigned int)_overflow((__int64)v236, 73LL, v22, i, (u32 *)v24, v25) == -1 )
            goto LABEL_122;
        }
        else
        {
          i = (unsigned __int64)v236;
          v22 = (__int64)(v76 + 1);
          *((_QWORD *)v236 + 5) = v76 + 1;
          *v76 = 73;
        }
        ++v73;
      }
      v77 = *((_DWORD *)v40 + 1);
      if ( v77 )
      {
        v172 = (unsigned __int64)v212;
        v18 = (unsigned __int64)v212;
        v173 = (unsigned __int8 *)itoa_word(v77, (__int64)v212, 0xAu, 0);
        v174 = v172;
        if ( (unsigned __int64)v173 < v172 )
        {
          LODWORD(v232) = v39;
          v175 = v236;
          v176 = (unsigned __int8 *)v174;
          do
          {
            v22 = *v173++;
            v177 = (_BYTE *)*((_QWORD *)v175 + 5);
            if ( (unsigned __int64)v177 < *((_QWORD *)v175 + 6) )
            {
              i = (unsigned __int64)(v177 + 1);
              *((_QWORD *)v175 + 5) = v177 + 1;
              *v177 = v22;
            }
            else
            {
              v18 = (unsigned __int8)v22;
              if ( (unsigned int)_overflow((__int64)v175, (unsigned __int8)v22, v22, i, (u32 *)v24, v25) == -1 )
                goto LABEL_122;
            }
            if ( v73 == 0x7FFFFFFF )
              goto LABEL_122;
            ++v73;
          }
          while ( v173 != v176 );
          v39 = v232;
        }
      }
      if ( *(_DWORD *)v40 != -1 )
      {
        v78 = (_BYTE *)*((_QWORD *)v236 + 5);
        if ( (unsigned __int64)v78 >= *((_QWORD *)v236 + 6) )
        {
          v18 = 46LL;
          if ( (unsigned int)_overflow((__int64)v236, 46LL, v22, i, (u32 *)v24, v25) == -1 )
            goto LABEL_122;
        }
        else
        {
          v18 = (unsigned __int64)v236;
          v22 = (__int64)(v78 + 1);
          *((_QWORD *)v236 + 5) = v78 + 1;
          *v78 = 46;
        }
        if ( v73 == 0x7FFFFFFF )
          goto LABEL_122;
        v79 = (unsigned __int64)v212;
        ++v73;
        v18 = (unsigned __int64)v212;
        v80 = (unsigned __int8 *)itoa_word(*(int *)v40, (__int64)v212, 0xAu, 0);
        v81 = v79;
        if ( (unsigned __int64)v80 < v79 )
        {
          LODWORD(v232) = v39;
          v82 = v236;
          v83 = (unsigned __int8 *)v81;
          do
          {
            v22 = *v80++;
            v84 = (_BYTE *)*((_QWORD *)v82 + 5);
            if ( (unsigned __int64)v84 < *((_QWORD *)v82 + 6) )
            {
              i = (unsigned __int64)(v84 + 1);
              *((_QWORD *)v82 + 5) = v84 + 1;
              *v84 = v22;
            }
            else
            {
              v18 = (unsigned __int8)v22;
              if ( (unsigned int)_overflow((__int64)v82, (unsigned __int8)v22, v22, i, (u32 *)v24, v25) == -1 )
                goto LABEL_122;
            }
            if ( v73 == 0x7FFFFFFF )
              goto LABEL_122;
            ++v73;
          }
          while ( v80 != v83 );
          v39 = v232;
        }
      }
      v110 = *((_DWORD *)v40 + 2);
      if ( v110 )
      {
        v22 = *((_QWORD *)v236 + 5);
        if ( (unsigned __int64)v22 >= *((_QWORD *)v236 + 6) )
        {
          v18 = (unsigned __int8)v110;
          if ( (unsigned int)_overflow((__int64)v236, (unsigned __int8)v110, v22, (__int64)v236, (u32 *)v24, v25) == -1 )
            goto LABEL_122;
        }
        else
        {
          i = v22 + 1;
          *((_QWORD *)v236 + 5) = v22 + 1;
          *(_BYTE *)v22 = v110;
        }
        if ( v73 == 0x7FFFFFFF )
          goto LABEL_122;
        ++v73;
      }
      if ( (unsigned int)v39 > 0x7FFFFFFE )
        _assert_fail(
          (__int64)"(unsigned int) done < (unsigned int) INT_MAX",
          (__int64)"vfprintf.c",
          0x7FDu,
          "printf_positional");
      if ( 0x7FFFFFFF - v39 >= (unsigned int)v73 )
      {
LABEL_229:
        v39 += v73;
        goto LABEL_151;
      }
LABEL_186:
      __writefsdword(0xFFFFFFC0, 0x4Bu);
LABEL_122:
      if ( v233 )
        free(v233, v18, v22, i, (u32 *)v24, v25);
LABEL_124:
      v85 = -1;
      goto LABEL_125;
    }
    i = (unsigned __int64)jump_table;
    v87 = (unsigned __int8)v228;
    v22 = (unsigned __int8)v227;
    v47 = (unsigned __int8)v47;
    LODWORD(v216) = (unsigned __int8)v229;
    LOBYTE(v229) = v226;
    switch ( (char)v25 )
    {
      case ' ':
      case '!':
      case '"':
      case '#':
      case '$':
      case '&':
      case '\'':
      case '(':
      case ')':
      case '*':
      case '+':
      case ',':
      case '-':
      case '.':
      case '/':
      case '0':
      case '1':
      case '2':
      case '3':
      case '4':
      case '5':
      case '6':
      case '7':
      case '8':
      case '9':
      case ':':
      case ';':
      case '<':
      case '=':
      case '>':
      case '?':
      case '@':
      case 'B':
      case 'D':
      case 'H':
      case 'I':
      case 'J':
      case 'K':
      case 'L':
      case 'M':
      case 'N':
      case 'O':
      case 'P':
      case 'Q':
      case 'R':
      case 'T':
      case 'U':
      case 'V':
      case 'W':
      case 'Y':
      case 'Z':
      case '[':
      case '\\':
      case ']':
      case '^':
      case '_':
      case '`':
      case 'b':
      case 'h':
      case 'j':
      case 'k':
      case 'l':
      case 'q':
      case 'r':
      case 't':
      case 'v':
      case 'w':
      case 'y':
      case 'z':
        goto LABEL_83;
      case '%':
        v147 = (_BYTE *)*((_QWORD *)v236 + 5);
        if ( (unsigned __int64)v147 >= *((_QWORD *)v236 + 6) )
        {
          v18 = 37LL;
          if ( (unsigned int)_overflow((__int64)v236, 37LL, (unsigned __int8)v227, (__int64)jump_table, (u32 *)v24, v25) == -1 )
            goto LABEL_122;
        }
        else
        {
          v22 = (__int64)(v147 + 1);
          *((_QWORD *)v236 + 5) = v147 + 1;
          *v147 = 37;
        }
        if ( v39 == 0x7FFFFFFF )
          goto LABEL_122;
        ++v39;
        goto LABEL_151;
      case 'A':
      case 'a':
        v242 = (const __m128i *)&v238[2 * *((int *)v40 + 12)];
        *((_BYTE *)v40 + 13) &= ~0x10u;
        v18 = (unsigned __int64)&v239[9 * v235];
        v100 = _printf_fphex((__int64)v236, v18, &v242, (__int64)jump_table, v24, v25);
        if ( v100 >= 0 )
          goto LABEL_231;
        goto LABEL_122;
      case 'C':
        goto LABEL_160;
      case 'E':
      case 'F':
      case 'G':
      case 'e':
      case 'f':
      case 'g':
        v241 = (long double *)&v238[2 * *((int *)v40 + 12)];
        *((_BYTE *)v40 + 13) &= ~0x10u;
        v18 = (unsigned __int64)&v239[9 * v235];
        v100 = _printf_fp(v236, v18, &v241, (__int64)jump_table, (u32 *)v24, v25);
        if ( v100 < 0 )
          goto LABEL_122;
LABEL_231:
        if ( (unsigned int)v39 > 0x7FFFFFFE )
          goto LABEL_232;
        goto LABEL_149;
      case 'S':
      case 's':
        v18 = (unsigned __int64)v238;
        v137 = (const __m128i *)v238[2 * *((int *)v40 + 12)];
        goto LABEL_283;
      case 'X':
      case 'x':
        LODWORD(v227) = 16;
        goto LABEL_301;
      case 'c':
        if ( !(_BYTE)v47 )
        {
          v145 = v49 - 1;
          if ( !(_DWORD)v231 && v145 > 0 )
          {
            v18 = 32LL;
            if ( v145 != IO_padn(v236, (char *)0x20, v145, (__int64)jump_table, (u32 *)v24, v25) )
              goto LABEL_122;
            if ( (unsigned int)v39 > 0x7FFFFFFE )
LABEL_176:
              _assert_fail(
                (__int64)"(unsigned int) done < (unsigned int) INT_MAX",
                (__int64)"vfprintf.c",
                0x7E2u,
                "printf_positional");
            if ( 0x7FFFFFFF - v39 < (unsigned int)v145 )
              goto LABEL_186;
            v39 += v145;
          }
          v22 = LODWORD(v238[2 * *((int *)v40 + 12)]);
          v146 = (_BYTE *)*((_QWORD *)v236 + 5);
          if ( (unsigned __int64)v146 >= *((_QWORD *)v236 + 6) )
          {
            v18 = (unsigned __int8)v22;
            if ( (unsigned int)_overflow((__int64)v236, (unsigned __int8)v22, v22, (__int64)v236, (u32 *)v24, v25) == -1 )
              goto LABEL_122;
          }
          else
          {
            v18 = (unsigned __int64)v236;
            i = (unsigned __int64)(v146 + 1);
            *((_QWORD *)v236 + 5) = v146 + 1;
            *v146 = v22;
          }
          if ( v39 == 0x7FFFFFFF )
            goto LABEL_122;
          ++v39;
          if ( (_DWORD)v231 && v145 > 0 )
          {
            v18 = 32LL;
            if ( v145 != IO_padn(v236, (char *)0x20, v145, i, (u32 *)v24, v25) )
              goto LABEL_122;
            if ( (unsigned int)v39 > 0x7FFFFFFE )
              goto LABEL_176;
            if ( 0x7FFFFFFF - v39 < (unsigned int)v145 )
              goto LABEL_186;
            v39 += v145;
          }
          goto LABEL_151;
        }
LABEL_160:
        v103 = v213;
        v243 = 0LL;
        v104 = *((int *)v40 + 12);
        LODWORD(v232) = v49;
        v18 = LODWORD(v238[2 * v104]);
        v105 = wcrtomb(v213, v18, &v243, (__int64)jump_table, (u32 *)v24, v25);
        v106 = v105;
        if ( v105 == -1 )
          goto LABEL_122;
        v25 = (unsigned int)v231;
        v73 = v232 - v105;
        v107 = (int)v232 - (int)v105 > 0;
        if ( !(_DWORD)v231 && (int)v232 - (int)v105 > 0 )
        {
          v103 = v236;
          v18 = 32LL;
          v232 = v73;
          v108 = (__int64 *)IO_padn(v236, (char *)0x20, v73, v73, (u32 *)v24, (unsigned int)v231);
          i = v232;
          if ( (__int64 *)v232 != v108 )
            goto LABEL_122;
          if ( (unsigned int)v39 > 0x7FFFFFFE )
            goto LABEL_176;
          if ( 0x7FFFFFFF - v39 < (unsigned int)v73 )
            goto LABEL_186;
          v39 += v73;
        }
        if ( v39 < 0 )
          goto LABEL_502;
        v109 = (__int64 *)*((_QWORD *)v236 + 27);
        if ( (char *)&_start___libc_atexit - (char *)_start___libc_IO_vtables <= (unsigned __int64)((char *)v109
                                                                                                  - (char *)_start___libc_IO_vtables) )
        {
          v232 = *((_QWORD *)v236 + 27);
          IO_vtable_check(
            (__int64)v103,
            (char *)v109 - (char *)_start___libc_IO_vtables,
            (__int64)_start___libc_IO_vtables,
            (__int64)v109,
            (u32 *)v24,
            v25);
          v109 = (__int64 *)v232;
        }
        v18 = (unsigned __int64)v213;
        if ( v106 != ((__int64 (__fastcall *)(char *, char *, unsigned __int64))v109[7])(v236, v213, v106) )
          goto LABEL_122;
        i = 0x7FFFFFFFLL;
        if ( 0x7FFFFFFF - v39 < v106 )
          goto LABEL_186;
        v24 = (unsigned int)v231;
        v39 += v106;
        if ( !(_DWORD)v231 || !v107 )
          goto LABEL_151;
        v18 = 32LL;
        if ( v73 != IO_padn(v236, (char *)0x20, v73, 0x7FFFFFFFLL, (u32 *)(unsigned int)v231, v25) )
          goto LABEL_122;
        if ( (unsigned int)v39 > 0x7FFFFFFE )
          goto LABEL_176;
LABEL_228:
        i = 0x7FFFFFFFLL;
        if ( 0x7FFFFFFF - v39 < (unsigned int)v73 )
          goto LABEL_186;
        goto LABEL_229;
      case 'd':
      case 'i':
        if ( (_BYTE)v47 )
        {
          v18 = (unsigned __int64)v238;
          v111 = v238[2 * *((int *)v40 + 12)];
        }
        else
        {
          LODWORD(v111) = v238[2 * *((int *)v40 + 12)];
          if ( v46 )
          {
            v111 = (char)v111;
          }
          else
          {
            v181 = (int)v111;
            v111 = (__int16)v111;
            if ( !(_BYTE)v227 )
              v111 = v181;
          }
        }
        if ( v111 < 0 )
        {
          v47 = 1;
          LODWORD(v227) = 10;
          v228 = -v111;
        }
        else
        {
          v228 = v111;
          v47 = 0;
          LODWORD(v227) = 10;
        }
        goto LABEL_195;
      case 'm':
        v18 = v222;
        LODWORD(v229) = v25;
        LODWORD(v232) = v49;
        LOBYTE(v47) = 0;
        v136 = strerror_r(a10, v222, 0x3E8uLL);
        v49 = v232;
        v25 = (unsigned int)v229;
        v137 = (const __m128i *)v136;
LABEL_283:
        if ( !v137 )
        {
          if ( (_DWORD)v48 == -1 || (int)v48 > 5 )
          {
            v138 = 0;
            v140 = 6LL;
            LODWORD(v232) = 6;
            v137 = (const __m128i *)"(null)";
          }
          else
          {
            LODWORD(v232) = 0;
            v138 = 0;
            v140 = 0LL;
            v137 = (const __m128i *)byte_493255;
          }
          goto LABEL_288;
        }
        if ( (v47 & 1) == 0 && (_BYTE)v25 != 83 )
        {
          if ( (_DWORD)v48 != -1 )
            goto LABEL_287;
          LODWORD(v229) = v49;
          v138 = 0;
          v171 = j_strlen_ifunc(v137);
          v49 = v229;
          v140 = v171;
          LODWORD(v232) = v171;
          goto LABEL_288;
        }
        v242 = v137;
        v232 = (__int64)&v243;
        v243 = 0LL;
        if ( (int)v48 >= 0 )
          goto LABEL_388;
        v18 = (unsigned __int64)&v242;
        LODWORD(v228) = v49;
        v229 = (unsigned __int64)&v242;
        v191 = wcsrtombs(0LL, &v242, 0LL, (__int64 *)v232, (u32 *)v24, v25);
        v140 = v191;
        if ( v191 == -1 )
          goto LABEL_122;
        v138 = v243;
        if ( (_DWORD)v243 )
          _assert_fail((__int64)"__mbsinit (&mbstate)", (__int64)"vfprintf.c", 0x7E2u, "printf_positional");
        LODWORD(v227) = v228;
        v228 = v191 + 1;
        v242 = v137;
        v192 = _libc_alloca_cutoff(v191 + 1);
        v194 = (_QWORD *)v228;
        v195 = v227;
        if ( v192 || v228 <= 0x1000 )
        {
          v196 = (__int64 *)&v210[-((v228 + 23) & 0xFFFFFFFFFFFFF000LL) - 8];
          if ( &v209 != v196 )
          {
            while ( &v207 != v196 )
              ;
          }
          if ( (((_WORD)v228 + 23) & 0xFF0) != 0 )
          {
            v197 = alloca(((_WORD)v228 + 23) & 0xFF0);
            *(__int64 *)((char *)&v206 + (((_WORD)v228 + 23) & 0xFF0)) = *(__int64 *)((char *)&v206
                                                                                    + (((_WORD)v228 + 23) & 0xFF0));
          }
          v137 = (const __m128i *)v208;
        }
        else
        {
          v137 = (const __m128i *)malloc(v228, (__int64)&v242, (_QWORD *)v228, v193, (u32 *)v24, v25);
          if ( !v137 )
            goto LABEL_122;
          v138 = 1;
          v194 = (_QWORD *)v228;
          v195 = v227;
        }
        v18 = v229;
        LODWORD(v228) = v195;
        wcsrtombs((__int64)v137, (_QWORD *)v229, (__int64)v194, (__int64 *)v232, (u32 *)v24, v25);
        v49 = v228;
        goto LABEL_396;
      case 'n':
        if ( (v236[116] & 4) != 0 )
        {
          if ( !v219 )
          {
            v185 = v217;
            LODWORD(v232) = (unsigned __int8)v227;
            v18 = j_strlen_ifunc(v217) + 1;
            v190 = _readonly_area(v185, v18, v186, v187, v188, v189);
            v22 = (unsigned int)v232;
            v219 = v190;
          }
          if ( v219 < 0 )
            _libc_fatal((__int64)"*** %n in writable segment detected ***\n", v18, v22, i, (u32 *)v24, v25);
        }
        v135 = (_QWORD *)v238[2 * *((int *)v40 + 12)];
        if ( (_BYTE)v47 )
        {
          v22 = v39;
          *v135 = v39;
        }
        else if ( v46 )
        {
          *(_BYTE *)v135 = v39;
        }
        else if ( (_DWORD)v22 )
        {
          *(_WORD *)v135 = v39;
        }
        else
        {
          *(_DWORD *)v135 = v39;
        }
        goto LABEL_151;
      case 'o':
        LODWORD(v227) = 8;
        goto LABEL_301;
      case 'p':
        if ( !v238[2 * *((int *)v40 + 12)] )
        {
          v137 = (const __m128i *)"(nil)";
          if ( (int)v48 < 5 )
            LODWORD(v48) = 5;
          if ( (_BYTE)v25 == 83 )
          {
            v242 = (const __m128i *)"(nil)";
            v232 = (__int64)&v243;
            v243 = 0LL;
LABEL_388:
            LODWORD(v228) = v49;
            v229 = (int)v48;
            v163 = _libc_alloca_cutoff((int)v48);
            v165 = (_QWORD *)v229;
            v166 = v228;
            if ( v163 || (int)v48 <= 4096 )
            {
              v167 = (__int64 *)&v210[-((v229 + 23) & 0xFFFFFFFFFFFFF000LL) - 8];
              if ( &v209 != v167 )
              {
                while ( &v207 != v167 )
                  ;
              }
              if ( (((_WORD)v229 + 23) & 0xFF0) != 0 )
              {
                v168 = alloca(((_WORD)v229 + 23) & 0xFF0);
                *(__int64 *)((char *)&v206 + (((_WORD)v229 + 23) & 0xFF0)) = *(__int64 *)((char *)&v206
                                                                                        + (((_WORD)v229 + 23) & 0xFF0));
              }
              v138 = 0;
              v137 = (const __m128i *)v208;
            }
            else
            {
              v137 = (const __m128i *)malloc(v229, v18, (_QWORD *)v229, v164, (u32 *)v24, v25);
              if ( !v137 )
                goto LABEL_122;
              v138 = 1;
              v165 = (_QWORD *)v229;
              v166 = v228;
            }
            v18 = (unsigned __int64)&v242;
            LODWORD(v229) = v166;
            v169 = wcsrtombs((__int64)v137, &v242, (__int64)v165, (__int64 *)v232, (u32 *)v24, v25);
            v49 = v229;
            v140 = v169;
            if ( v169 == -1 )
              goto LABEL_122;
LABEL_396:
            LODWORD(v232) = v140;
          }
          else
          {
LABEL_287:
            v18 = (int)v48;
            LODWORD(v229) = v49;
            v138 = 0;
            v139 = j_strnlen(v137, (int)v48);
            v49 = v229;
            LODWORD(v232) = v139;
            v140 = v139;
          }
LABEL_288:
          v141 = v49 - v232;
          LODWORD(v228) = v141;
          if ( v141 < 0 )
          {
            if ( v39 < 0 )
LABEL_502:
              _assert_fail(
                (__int64)"(size_t) done <= (size_t) INT_MAX",
                (__int64)"vfprintf.c",
                0x7E2u,
                "printf_positional");
            v154 = *((_QWORD *)v236 + 27);
            if ( (char *)&_start___libc_atexit - (char *)_start___libc_IO_vtables <= (unsigned __int64)(v154 - (_QWORD)_start___libc_IO_vtables) )
              IO_vtable_check(
                v154 - (_QWORD)_start___libc_IO_vtables,
                v18,
                (__int64)_start___libc_IO_vtables,
                i,
                (u32 *)v24,
                v25);
            v18 = (unsigned __int64)v137;
            if ( v140 != (*(__int64 (__fastcall **)(char *, const __m128i *, unsigned __int64))(v154 + 56))(
                           v236,
                           v137,
                           v140) )
              goto LABEL_122;
            if ( 0x7FFFFFFF - v39 < v140 )
              goto LABEL_186;
            v39 += v232;
          }
          else
          {
            LOBYTE(v229) = v141 != 0;
            if ( !(_DWORD)v231 && v141 )
            {
              v18 = 32LL;
              v227 = (int)v228;
              v180 = IO_padn(v236, (char *)0x20, v228, (int)v228, (u32 *)v24, v25);
              i = v227;
              if ( v227 != v180 )
                goto LABEL_122;
              if ( (unsigned int)v39 > 0x7FFFFFFE )
                goto LABEL_176;
              i = (unsigned int)v228;
              if ( 0x7FFFFFFF - v39 < (unsigned int)v228 )
                goto LABEL_186;
              v39 += v228;
            }
            if ( v39 < 0 )
              goto LABEL_502;
            v142 = *((_QWORD *)v236 + 27);
            if ( (char *)&_start___libc_atexit - (char *)_start___libc_IO_vtables <= (unsigned __int64)(v142 - (_QWORD)_start___libc_IO_vtables) )
            {
              v227 = *((_QWORD *)v236 + 27);
              IO_vtable_check(
                v142 - (_QWORD)_start___libc_IO_vtables,
                v18,
                (__int64)_start___libc_IO_vtables,
                v142,
                (u32 *)v24,
                v25);
              v142 = v227;
            }
            v18 = (unsigned __int64)v137;
            if ( v140 != (*(__int64 (__fastcall **)(char *, const __m128i *, unsigned __int64))(v142 + 56))(
                           v236,
                           v137,
                           v140) )
              goto LABEL_122;
            i = 0x7FFFFFFFLL;
            if ( 0x7FFFFFFF - v39 < v140 )
              goto LABEL_186;
            v18 = (unsigned int)v231;
            v39 += v232;
            if ( (_DWORD)v231 && (_BYTE)v229 )
            {
              v182 = (int)v228;
              v18 = 32LL;
              if ( v182 != IO_padn(v236, (char *)0x20, v228, 0x7FFFFFFFLL, (u32 *)v24, v25) )
                goto LABEL_122;
              if ( (unsigned int)v39 > 0x7FFFFFFE )
                goto LABEL_176;
              i = (unsigned int)(0x7FFFFFFF - v39);
              if ( (unsigned int)i < (unsigned int)v228 )
                goto LABEL_186;
              v39 += v228;
            }
            if ( v138 )
              free((__int64)v137, v18, v22, i, (u32 *)v24, v25);
          }
          goto LABEL_151;
        }
        v228 = v238[2 * *((int *)v40 + 12)];
        if ( (int)v48 < 0 )
        {
          v183 = v224;
          LODWORD(v227) = v87;
          v48 = 1LL;
          v47 = 0;
          v18 = (unsigned __int64)v224;
          LODWORD(v232) = v49;
          v184 = itoa_word(v228, (__int64)v224, 0x10u, 0);
          v49 = v232;
          v87 = v227;
          LOBYTE(v232) = 120;
          v226 = 1;
          v114 = (__int64)&v183[-v184];
          v25 = v184;
          LODWORD(v227) = 16;
          if ( v114 <= 0 )
            goto LABEL_244;
        }
        else
        {
          if ( (_DWORD)v48 )
          {
            LOBYTE(v232) = 120;
            v47 = 0;
            v112 = 0;
            v226 = 1;
            LODWORD(v227) = 16;
LABEL_237:
            LOBYTE(v229) = 32;
            LOBYTE(v225) = v112 & 1;
          }
          else
          {
            LOBYTE(v232) = 120;
            v47 = 0;
            v112 = 0;
            v226 = 1;
            LODWORD(v227) = 16;
LABEL_359:
            v48 = 0LL;
            LOBYTE(v229) = 32;
            LOBYTE(v225) = v112 & 1;
          }
LABEL_238:
          v122 = v227;
          v18 = (unsigned __int64)v224;
          v218 = v87;
          v221 = v49;
          v123 = (_BYTE *)itoa_word(v228, (__int64)v224, v227, (_BYTE)v232 == 88);
          v49 = v221;
          v124 = v220 && v122 == 10;
          v25 = (__int64)v123;
          v87 = v218;
          if ( v230 && (_BYTE)v225 )
          {
            v18 = (unsigned __int64)v123;
            v221 = v218;
            v225 = v49;
            v125 = group_number(v222, v123, v224, v230, v223);
            v87 = v221;
            v49 = v225;
            v25 = (__int64)v125;
          }
          if ( v124 )
          {
            v18 = (unsigned __int64)v224;
            v221 = v87;
            v225 = v49;
            v126 = i18n_number_rewrite(v25, (__int64)v224, (__int64)v224);
            v87 = v221;
            v49 = v225;
            v25 = v126;
          }
          v114 = (__int64)&v224[-v25];
          if ( (__int64)&v224[-v25] < v48 )
          {
LABEL_244:
            v115 = v48 - v114;
            if ( v115 < 0 )
              LODWORD(v115) = 0;
            i = (unsigned int)v115;
            if ( !(_DWORD)v231 )
            {
              LODWORD(v231) = v114;
              v24 = (unsigned int)(v49 - v114 - v115);
              v127 = v49 - v114 - v115;
              if ( !v228 )
                goto LABEL_252;
              v128 = v226 & 1;
              goto LABEL_249;
            }
            goto LABEL_204;
          }
          if ( !v228 )
          {
LABEL_202:
            if ( !(_DWORD)v231 )
            {
              i = 0LL;
              LODWORD(v231) = v114;
              v228 = 0LL;
              v127 = v49 - v114;
              goto LABEL_252;
            }
            v228 = 0LL;
            i = 0LL;
            LODWORD(v115) = 0;
            goto LABEL_204;
          }
        }
        v128 = v226 & 1;
        if ( (_DWORD)v227 == 8 && v128 )
        {
          v150 = v224;
          *(_BYTE *)--v25 = 48;
          v114 = (__int64)&v150[-v25];
        }
        v115 = v48 - v114;
        if ( v115 < 0 )
          LODWORD(v115) = 0;
        v22 = (unsigned int)v231;
        i = (unsigned int)v115;
        if ( !(_DWORD)v231 )
        {
          LODWORD(v231) = v114;
          v24 = (unsigned int)(v49 - v114 - v115);
          v127 = v49 - v114 - v115;
LABEL_249:
          if ( (_DWORD)v227 == 16 )
          {
            v22 = (unsigned int)(v127 - 2);
            if ( v128 )
              v127 -= 2;
          }
LABEL_252:
          if ( v47 | v87 | (unsigned int)v216 )
          {
            --v127;
            if ( (_BYTE)v229 != 32 )
            {
LABEL_254:
              if ( v47 )
              {
                v129 = v236;
                v130 = (_BYTE *)*((_QWORD *)v236 + 5);
                if ( (unsigned __int64)v130 < *((_QWORD *)v236 + 6) )
                {
                  v22 = (__int64)(v130 + 1);
                  *((_QWORD *)v236 + 5) = v130 + 1;
                  *v130 = 45;
LABEL_257:
                  if ( v39 == 0x7FFFFFFF )
                    goto LABEL_122;
                  ++v39;
                  goto LABEL_259;
                }
                LODWORD(v224) = i;
                v18 = 45LL;
                v229 = v25;
                goto LABEL_455;
              }
              if ( v87 )
              {
                v155 = (_BYTE *)*((_QWORD *)v236 + 5);
                if ( (unsigned __int64)v155 < *((_QWORD *)v236 + 6) )
                {
                  v18 = (unsigned __int64)v236;
                  v22 = (__int64)(v155 + 1);
                  *((_QWORD *)v236 + 5) = v155 + 1;
                  *v155 = 43;
                  goto LABEL_257;
                }
                LODWORD(v224) = i;
                v18 = 43LL;
                v129 = v236;
                v229 = v25;
LABEL_455:
                v198 = _overflow((__int64)v129, v18, v22, i, (u32 *)v24, v25);
                v25 = v229;
                i = (unsigned int)v224;
                if ( v198 == -1 )
                  goto LABEL_122;
                goto LABEL_257;
              }
              if ( (_DWORD)v216 )
              {
                v129 = v236;
                v179 = (_BYTE *)*((_QWORD *)v236 + 5);
                if ( (unsigned __int64)v179 < *((_QWORD *)v236 + 6) )
                {
                  v22 = (__int64)(v179 + 1);
                  *((_QWORD *)v236 + 5) = v179 + 1;
                  *v179 = 32;
                  goto LABEL_257;
                }
                LODWORD(v224) = i;
                v18 = 32LL;
                v229 = v25;
                goto LABEL_455;
              }
LABEL_259:
              if ( v228 && (_DWORD)v227 == 16 && (v226 & 1) != 0 )
              {
                v131 = (_BYTE *)*((_QWORD *)v236 + 5);
                if ( (unsigned __int64)v131 >= *((_QWORD *)v236 + 6) )
                {
                  v18 = 48LL;
                  LODWORD(v228) = i;
                  v229 = v25;
                  v203 = _overflow((__int64)v236, 48LL, v22, i, (u32 *)v24, v25);
                  v25 = v229;
                  i = (unsigned int)v228;
                  if ( v203 == -1 )
                    goto LABEL_122;
                }
                else
                {
                  v18 = (unsigned __int64)v236;
                  v22 = (__int64)(v131 + 1);
                  *((_QWORD *)v236 + 5) = v131 + 1;
                  *v131 = 48;
                }
                if ( v39 == 0x7FFFFFFF )
                  goto LABEL_122;
                v132 = (_BYTE *)*((_QWORD *)v236 + 5);
                if ( (unsigned __int64)v132 >= *((_QWORD *)v236 + 6) )
                {
                  v18 = (unsigned __int8)v232;
                  LODWORD(v228) = i;
                  v229 = v25;
                  v202 = _overflow((__int64)v236, (unsigned __int8)v232, v22, i, (u32 *)v24, v25);
                  v25 = v229;
                  i = (unsigned int)v228;
                  if ( v202 == -1 )
                    goto LABEL_122;
                }
                else
                {
                  v18 = (unsigned __int8)v232;
                  v22 = (__int64)(v132 + 1);
                  *((_QWORD *)v236 + 5) = v132 + 1;
                  *v132 = v18;
                }
                if ( v39 == 2147483646 )
                  goto LABEL_122;
                v39 += 2;
              }
              v133 = i + v127;
              if ( v133 > 0 )
              {
                v18 = 48LL;
                v232 = v25;
                if ( v133 != IO_padn(v236, (char *)0x30, v133, i, (u32 *)v24, v25) )
                  goto LABEL_122;
                if ( (unsigned int)v39 > 0x7FFFFFFE )
LABEL_232:
                  _assert_fail(
                    (__int64)"(unsigned int) done < (unsigned int) INT_MAX",
                    (__int64)"vfprintf.c",
                    0x7E1u,
                    "printf_positional");
                if ( 0x7FFFFFFF - v39 < (unsigned int)v133 )
                  goto LABEL_186;
                v39 += v133;
                v25 = v232;
              }
              if ( v39 < 0 )
LABEL_503:
                _assert_fail(
                  (__int64)"(size_t) done <= (size_t) INT_MAX",
                  (__int64)"vfprintf.c",
                  0x7E1u,
                  "printf_positional");
              v134 = *((_QWORD *)v236 + 27);
              if ( (char *)&_start___libc_atexit - (char *)_start___libc_IO_vtables <= (unsigned __int64)(v134 - (_QWORD)_start___libc_IO_vtables) )
              {
                v232 = v25;
                IO_vtable_check(
                  v134 - (_QWORD)_start___libc_IO_vtables,
                  v18,
                  (__int64)_start___libc_IO_vtables,
                  i,
                  (u32 *)v24,
                  v25);
                v25 = v232;
              }
              v18 = v25;
              if ( v114 != (*(__int64 (__fastcall **)(char *, __int64, __int64))(v134 + 56))(v236, v25, v114) )
                goto LABEL_122;
              if ( 0x7FFFFFFF - v39 < v114 )
                goto LABEL_186;
              v39 += v231;
              goto LABEL_151;
            }
            if ( v127 <= 0 )
            {
              v127 = 0;
              goto LABEL_254;
            }
          }
          else
          {
            if ( (_BYTE)v229 != 32 )
              goto LABEL_259;
            if ( v127 <= 0 )
            {
              v127 = 0;
              goto LABEL_259;
            }
          }
          v18 = 32LL;
          v221 = v87;
          v229 = v127;
          v225 = i;
          v224 = (_BYTE *)v25;
          v151 = (_QWORD *)IO_padn(v236, (char *)0x20, v127, i, (u32 *)v127, v25);
          v24 = v229;
          if ( (_QWORD *)v229 != v151 )
            goto LABEL_122;
          v25 = (__int64)v224;
          i = v225;
          v87 = v221;
          if ( (unsigned int)v39 > 0x7FFFFFFE )
            goto LABEL_232;
          if ( 0x7FFFFFFF - v39 < (unsigned int)v127 )
            goto LABEL_186;
          v39 += v127;
          v127 = 0;
          goto LABEL_254;
        }
LABEL_204:
        if ( v47 )
        {
          v116 = v236;
          v117 = (_BYTE *)*((_QWORD *)v236 + 5);
          if ( (unsigned __int64)v117 < *((_QWORD *)v236 + 6) )
          {
            v18 = (unsigned __int64)v236;
            v22 = (__int64)(v117 + 1);
            *((_QWORD *)v236 + 5) = v117 + 1;
            *v117 = 45;
            goto LABEL_207;
          }
          LODWORD(v224) = i;
          v18 = 45LL;
          v229 = v25;
          LODWORD(v231) = v49;
        }
        else if ( v87 )
        {
          v116 = v236;
          v152 = (_BYTE *)*((_QWORD *)v236 + 5);
          if ( (unsigned __int64)v152 < *((_QWORD *)v236 + 6) )
          {
            v22 = (__int64)(v152 + 1);
            *((_QWORD *)v236 + 5) = v152 + 1;
            *v152 = 43;
            goto LABEL_207;
          }
          LODWORD(v224) = i;
          v18 = 43LL;
          v229 = v25;
          LODWORD(v231) = v49;
        }
        else
        {
          if ( !(_DWORD)v216 )
            goto LABEL_209;
          v116 = v236;
          v156 = (_BYTE *)*((_QWORD *)v236 + 5);
          if ( (unsigned __int64)v156 < *((_QWORD *)v236 + 6) )
          {
            v18 = (unsigned __int64)v236;
            v22 = (__int64)(v156 + 1);
            *((_QWORD *)v236 + 5) = v156 + 1;
            *v156 = 32;
            goto LABEL_207;
          }
          LODWORD(v224) = i;
          v18 = 32LL;
          v229 = v25;
          LODWORD(v231) = v49;
        }
        v199 = _overflow((__int64)v116, v18, v22, i, (u32 *)v24, v25);
        v49 = v231;
        v25 = v229;
        i = (unsigned int)v224;
        if ( v199 == -1 )
          goto LABEL_122;
LABEL_207:
        if ( v39 == 0x7FFFFFFF )
          goto LABEL_122;
        ++v39;
        --v49;
LABEL_209:
        if ( v228 && (_DWORD)v227 == 16 && (v226 & 1) != 0 )
        {
          v18 = (unsigned __int64)v236;
          v118 = (_BYTE *)*((_QWORD *)v236 + 5);
          if ( (unsigned __int64)v118 >= *((_QWORD *)v236 + 6) )
          {
            v18 = 48LL;
            LODWORD(v228) = i;
            v229 = v25;
            LODWORD(v231) = v49;
            v205 = _overflow((__int64)v236, 48LL, v22, i, (u32 *)v24, v25);
            v49 = v231;
            v25 = v229;
            i = (unsigned int)v228;
            if ( v205 == -1 )
              goto LABEL_122;
          }
          else
          {
            v22 = (__int64)(v118 + 1);
            *((_QWORD *)v236 + 5) = v118 + 1;
            *v118 = 48;
          }
          if ( v39 == 0x7FFFFFFF )
            goto LABEL_122;
          v119 = (_BYTE *)*((_QWORD *)v236 + 5);
          if ( (unsigned __int64)v119 >= *((_QWORD *)v236 + 6) )
          {
            v18 = (unsigned __int8)v232;
            LODWORD(v228) = i;
            v229 = v25;
            LODWORD(v231) = v49;
            v204 = _overflow((__int64)v236, (unsigned __int8)v232, v22, i, (u32 *)v24, v25);
            v49 = v231;
            v25 = v229;
            i = (unsigned int)v228;
            if ( v204 == -1 )
              goto LABEL_122;
          }
          else
          {
            v18 = (unsigned __int64)v236;
            v120 = v232;
            v22 = (__int64)(v119 + 1);
            *((_QWORD *)v236 + 5) = v119 + 1;
            *v119 = v120;
          }
          if ( v39 == 2147483646 )
            goto LABEL_122;
          v39 += 2;
          v49 -= 2;
        }
        v73 = v49 - (v114 + v115);
        if ( (int)i > 0 )
        {
          v18 = 48LL;
          v229 = v25;
          v232 = (int)i;
          LODWORD(v231) = i;
          v153 = (__int64 *)IO_padn(v236, (char *)0x30, i, i, (u32 *)(int)i, v25);
          v24 = v232;
          if ( (__int64 *)v232 != v153 )
            goto LABEL_122;
          if ( (unsigned int)v39 > 0x7FFFFFFE )
            goto LABEL_232;
          i = (unsigned int)v231;
          if ( 0x7FFFFFFF - v39 < (unsigned int)v231 )
            goto LABEL_186;
          v39 += v231;
          v25 = v229;
        }
        if ( v39 < 0 )
          goto LABEL_503;
        v121 = *((_QWORD *)v236 + 27);
        if ( (char *)&_start___libc_atexit - (char *)_start___libc_IO_vtables <= (unsigned __int64)(v121
                                                                                                  - (_QWORD)_start___libc_IO_vtables) )
        {
          v231 = *((_QWORD *)v236 + 27);
          v232 = v25;
          IO_vtable_check(
            v121 - (_QWORD)_start___libc_IO_vtables,
            v18,
            (__int64)_start___libc_IO_vtables,
            v121,
            (u32 *)v24,
            v25);
          v121 = v231;
          v25 = v232;
        }
        v18 = v25;
        if ( v114 != (*(__int64 (__fastcall **)(char *, __int64, __int64))(v121 + 56))(v236, v25, v114) )
          goto LABEL_122;
        i = 0x7FFFFFFFLL;
        if ( 0x7FFFFFFF - v39 < v114 )
          goto LABEL_186;
        v39 += v114;
        if ( v73 > 0 )
        {
          v18 = 32LL;
          if ( v73 != IO_padn(v236, (char *)0x20, v73, 0x7FFFFFFFLL, (u32 *)v24, v25) )
            goto LABEL_122;
          if ( (unsigned int)v39 > 0x7FFFFFFE )
            goto LABEL_232;
          goto LABEL_228;
        }
LABEL_151:
        if ( v233 )
          free(v233, v18, v22, i, (u32 *)v24, v25);
        if ( v39 < 0 )
          _assert_fail((__int64)"(size_t) done <= (size_t) INT_MAX", (__int64)"vfprintf.c", 0x809u, "printf_positional");
        v101 = *((_QWORD *)v236 + 27);
        if ( (char *)&_start___libc_atexit - (char *)_start___libc_IO_vtables <= (unsigned __int64)(v101
                                                                                                  - (_QWORD)_start___libc_IO_vtables) )
          IO_vtable_check(
            v101 - (_QWORD)_start___libc_IO_vtables,
            v18,
            (__int64)_start___libc_IO_vtables,
            i,
            (u32 *)v24,
            v25);
        v18 = v40[3];
        v102 = (*(__int64 (__fastcall **)(char *, unsigned __int64, unsigned __int64, unsigned __int64, __int64, __int64))(v101 + 56))(
                 v236,
                 v18,
                 v40[4] - v18,
                 i,
                 v24,
                 v25);
        v22 = v40[4] - v40[3];
        if ( v22 != v102 )
          goto LABEL_124;
        if ( v22 <= 0x7FFFFFFF - v39 )
        {
          ++v235;
          v39 += v22;
          v40 += 9;
          if ( v215 <= v235 )
          {
            v85 = v39;
            goto LABEL_125;
          }
          continue;
        }
        v85 = -1;
        __writefsdword(0xFFFFFFC0, 0x4Bu);
LABEL_125:
        if ( (__int64 *)v247[0] != v234 + 2 )
          free(v247[0], v18, v22, i, (u32 *)v24, v25);
        if ( v244 != v237 + 2 )
          free((__int64)v244, v18, v22, i, (u32 *)v24, v25);
        return v85;
      case 'u':
        LODWORD(v227) = 10;
LABEL_301:
        v143 = &v238[2 * *((int *)v40 + 12)];
        if ( (_BYTE)v47 )
        {
          v144 = (_QWORD *)*v143;
          v87 = 0;
          v47 = 0;
          LODWORD(v216) = 0;
          v228 = (unsigned __int64)v144;
        }
        else
        {
          v149 = *(_DWORD *)v143;
          if ( v46 )
          {
            v87 = 0;
            LODWORD(v216) = 0;
            v228 = (unsigned __int8)v149;
          }
          else if ( (_DWORD)v22 )
          {
            v87 = 0;
            LODWORD(v216) = 0;
            v228 = (unsigned __int16)v149;
          }
          else
          {
            LODWORD(v216) = 0;
            v87 = 0;
            v228 = v149;
          }
        }
LABEL_195:
        v226 = (unsigned __int8)v221;
        v112 = v225;
        if ( (int)v48 < 0 )
        {
          v48 = 1LL;
          goto LABEL_238;
        }
        if ( (_DWORD)v48 )
          goto LABEL_237;
        if ( v228 )
          goto LABEL_359;
        if ( (_DWORD)v227 == 8 && (_BYTE)v221 )
        {
          v113 = v224;
          v114 = 1LL;
          *(v224 - 1) = 48;
          v25 = (__int64)(v113 - 1);
        }
        else
        {
          v25 = (__int64)v224;
          v114 = 0LL;
        }
        LOBYTE(v229) = 32;
        goto LABEL_202;
    }
  }
}
// 44E131: variable 'v21' is possibly undefined
// 44E131: variable 'v12' is possibly undefined
// 44E131: variable 'a5' is possibly undefined
// 44E131: variable 'a6' is possibly undefined
// 44E2F4: variable 'v24' is possibly undefined
// 44E2F4: variable 'v25' is possibly undefined
// 44E9A8: variable 'i' is possibly undefined
// 44E9C9: variable 'v22' is possibly undefined
// 450213: variable 'v186' is possibly undefined
// 450213: variable 'v187' is possibly undefined
// 450213: variable 'v188' is possibly undefined
// 450213: variable 'v189' is possibly undefined
// 4507F3: variable 'v164' is possibly undefined
// 450820: variable 'v193' is possibly undefined
// 401028: using guessed type __int64 __fastcall j_strnlen(_QWORD, _QWORD);
// 401090: using guessed type __int64 __fastcall j_memset_ifunc(_QWORD, _QWORD, _QWORD);
// 4010C8: using guessed type __int64 __fastcall j_strlen_ifunc(_QWORD);
// 4914E0: using guessed type unsigned __int8 jump_table[91];
// 493255: using guessed type unsigned __int8 byte_493255[1707];
// 4A9C40: using guessed type u32 _start___libc_IO_vtables[48];
// 4AA2E8: using guessed type __int64 (__fastcall *_start___libc_atexit)();
// 4ABA08: using guessed type __int64 _printf_function_table;
// 4ABA28: using guessed type __int64 _printf_arginfo_table;
// 4ABA30: using guessed type __int64 _printf_va_arg_table;

//----- (00000000004508C0) ----------------------------------------------------
__int64 __fastcall vfprintf(__int64 a1, unsigned __int64 a2, __m128i *a3)
{
  int v6; // eax
  int v7; // er15
  int v8; // er14
  __int64 v9; // rax
  __int64 v11; // rdi
  __int64 v12; // rcx
  u32 *v13; // r8
  __int64 v14; // r9
  __int64 v15; // rax
  __int64 v16; // rsi
  __int64 v17; // r15
  __int64 v18; // rcx
  __int64 v19; // r8
  __int64 v20; // rdx
  unsigned __int64 v21; // r9
  char v22; // r15
  __int64 v23; // rdi
  unsigned int v24; // er11
  int v25; // er14
  __int64 v26; // rax
  bool v28; // zf
  __int64 v29; // rdx
  unsigned __int32 v31; // eax
  unsigned int *v32; // rsi
  char *v33; // rdi
  __int64 v34; // rax
  unsigned __int64 v35; // r14
  __int64 v36; // r9
  unsigned int v37; // er15
  __int64 (__fastcall **v38)(__int64, __int64, unsigned __int64); // rax
  __int64 v39; // r14
  __int64 v40; // rdi
  char *v41; // rax
  __int64 v42; // rcx
  u32 *v43; // r8
  int v44; // er9
  __int64 v45; // r15
  __int64 v46; // rax
  unsigned __int32 v47; // eax
  char *v48; // r8
  __int64 v49; // rax
  unsigned __int64 v50; // r15
  int v51; // er14
  __int64 v52; // rcx
  bool v53; // r15
  unsigned __int32 v54; // eax
  unsigned int *v55; // rdx
  _BYTE *v56; // rax
  unsigned __int8 *v57; // rax
  __int64 v58; // rax
  unsigned int v59; // eax
  unsigned __int64 v60; // r15
  _BOOL4 v61; // eax
  unsigned int *v62; // rax
  void *v63; // rsp
  unsigned __int32 v64; // eax
  int *v65; // rdi
  int v66; // eax
  unsigned __int64 v67; // r15
  _BOOL4 v68; // eax
  unsigned int *v69; // rax
  void *v70; // rsp
  char v71; // di
  __int64 v72; // rcx
  LONG_DOUBLE_16 *v73; // rax
  int v74; // eax
  unsigned __int32 v75; // eax
  _QWORD **v76; // rdx
  _QWORD *v77; // rax
  unsigned __int32 v78; // eax
  unsigned __int64 v79; // r11
  __int64 v80; // r14
  _BYTE *v81; // rax
  __int64 v82; // r10
  _BYTE *v83; // rax
  __int64 v84; // rax
  int v85; // er14
  char v86; // al
  _BYTE *v87; // rax
  _BYTE *v88; // rax
  char *v89; // rax
  int v90; // er14
  __int64 v91; // r14
  __int64 v92; // rax
  unsigned __int32 v93; // eax
  unsigned __int64 v94; // rax
  _BYTE *v95; // rax
  __int64 v96; // rcx
  LONG_DOUBLE_16 *v97; // rax
  unsigned __int32 v98; // eax
  __int64 v99; // r11
  signed __int64 v100; // rax
  _BYTE *v101; // rax
  _BYTE *v102; // rax
  char *v103; // rax
  int v104; // er15
  __int64 v105; // rax
  __int64 v106; // rax
  unsigned __int64 v107; // rax
  unsigned __int64 v108; // rax
  __int64 v109; // rax
  _BYTE *v110; // rax
  __int64 v111; // rax
  _BYTE *v112; // rax
  unsigned __int64 v113; // rax
  _BYTE *v114; // rax
  unsigned __int32 v115; // eax
  _QWORD *v116; // rdx
  unsigned __int32 v117; // eax
  _QWORD *v118; // rdx
  unsigned __int64 v119; // r15
  _BOOL4 v120; // eax
  _QWORD *v121; // rdx
  u32 *v122; // r8
  __int64 v123; // r9
  unsigned int *v124; // rax
  void *v125; // rsp
  __int64 v126; // rax
  unsigned __int64 v127; // rax
  unsigned __int32 v128; // eax
  unsigned int *v129; // rcx
  int v130; // eax
  unsigned __int64 v131; // r15
  _BOOL4 v132; // eax
  unsigned int *v133; // rax
  void *v134; // rsp
  int v135; // eax
  __int64 v136; // rax
  _BYTE *v137; // r15
  _BYTE *v138; // rdi
  char v139; // al
  _BYTE *v140; // rax
  _BYTE *v141; // rax
  _QWORD *v142; // rax
  _BYTE *v143; // rax
  __int64 v144; // r14
  unsigned int v145; // eax
  __int64 v146; // rdx
  __int64 v147; // rcx
  u32 *v148; // r8
  __int64 v149; // r9
  int v150; // eax
  __int64 v151; // rdx
  const char *v152; // r8
  _BOOL4 v153; // eax
  __int64 v154; // rcx
  u32 *v155; // r8
  _QWORD *v156; // rdx
  __int64 v157; // r9
  unsigned int *v158; // rax
  void *v159; // rsp
  __int64 v160; // rax
  int v161; // eax
  int v162; // eax
  int v163; // eax
  int v164; // eax
  int v165; // eax
  _QWORD *v166; // rax
  int v167; // eax
  int v168; // eax
  int v169; // eax
  int v170; // eax
  _QWORD *v171; // rax
  _QWORD *v172; // rax
  __int64 v173; // [rsp+0h] [rbp-1558h]
  __int64 v174; // [rsp+8h] [rbp-1550h] BYREF
  _BYTE v175[7]; // [rsp+10h] [rbp-1548h] BYREF
  unsigned int v176; // [rsp+1008h] [rbp-550h] BYREF
  unsigned int v177; // [rsp+100Ch] [rbp-54Ch]
  unsigned int v178; // [rsp+1010h] [rbp-548h]
  int v179; // [rsp+1014h] [rbp-544h]
  _BYTE *v180; // [rsp+1018h] [rbp-540h]
  unsigned int v181; // [rsp+1020h] [rbp-538h]
  unsigned int v182; // [rsp+1024h] [rbp-534h]
  char *v183; // [rsp+1028h] [rbp-530h]
  __int64 v184; // [rsp+1030h] [rbp-528h]
  unsigned int v185; // [rsp+1038h] [rbp-520h]
  int v186; // [rsp+103Ch] [rbp-51Ch]
  int v187; // [rsp+1040h] [rbp-518h]
  unsigned int v188; // [rsp+1044h] [rbp-514h]
  __int64 v189; // [rsp+1048h] [rbp-510h]
  unsigned __int64 v190; // [rsp+1050h] [rbp-508h]
  __int64 v191; // [rsp+1058h] [rbp-500h]
  signed __int64 v192; // [rsp+1060h] [rbp-4F8h]
  unsigned __int64 v193; // [rsp+1068h] [rbp-4F0h]
  __int64 v194; // [rsp+1070h] [rbp-4E8h]
  _QWORD *v195; // [rsp+1078h] [rbp-4E0h]
  unsigned __int64 v196; // [rsp+1080h] [rbp-4D8h]
  char *v197; // [rsp+1088h] [rbp-4D0h]
  unsigned int v198; // [rsp+1090h] [rbp-4C8h]
  int v199; // [rsp+1094h] [rbp-4C4h]
  char *v200; // [rsp+10A0h] [rbp-4B8h] BYREF
  LONG_DOUBLE_16 *v201; // [rsp+10A8h] [rbp-4B0h] BYREF
  LONG_DOUBLE_16 *v202; // [rsp+10B0h] [rbp-4A8h] BYREF
  LONG_DOUBLE_16 v203; // [rsp+10B8h] [rbp-4A0h] BYREF
  const char *v204; // [rsp+10C8h] [rbp-490h] BYREF
  int v205; // [rsp+10D0h] [rbp-488h]
  int v206; // [rsp+10D4h] [rbp-484h]
  int v207; // [rsp+10D8h] [rbp-480h]
  __int64 v208[4]; // [rsp+10E8h] [rbp-470h] BYREF
  __int64 v209; // [rsp+1108h] [rbp-450h] BYREF
  __m128i v210; // [rsp+1110h] [rbp-448h] BYREF
  __int64 v211; // [rsp+1120h] [rbp-438h]
  char v212[16]; // [rsp+1128h] [rbp-430h] BYREF
  char v213[1000]; // [rsp+1138h] [rbp-420h] BYREF
  __int64 v214[7]; // [rsp+1520h] [rbp-38h] BYREF

  v214[0] = __readfsqword(0x28u);
  v198 = __readfsdword(0xFFFFFFC0);
  v6 = *(_DWORD *)(a1 + 192);
  if ( v6 )
  {
    if ( v6 != -1 )
    {
      LODWORD(v21) = -1;
      return (unsigned int)v21;
    }
  }
  else
  {
    *(_DWORD *)(a1 + 192) = -1;
  }
  v7 = *(_DWORD *)a1;
  if ( (*(_DWORD *)a1 & 8) != 0 )
  {
    LODWORD(v21) = -1;
    *(_DWORD *)a1 = v7 | 0x20;
    __writefsdword(0xFFFFFFC0, 9u);
    return (unsigned int)v21;
  }
  if ( !a2 )
  {
    LODWORD(v21) = -1;
    __writefsdword(0xFFFFFFC0, 0x16u);
    return (unsigned int)v21;
  }
  v8 = *(_DWORD *)a1 & 2;
  if ( (v7 & 2) != 0 )
  {
    LODWORD(v21) = buffered_vfprintf(a1, a2, a3);
    return (unsigned int)v21;
  }
  v9 = a3[1].m128i_i64[0];
  _RSI = 37LL;
  v11 = a2;
  v210 = _mm_loadu_si128(a3);
  v211 = v9;
  v197 = (char *)j_strchrnul(a2, 37LL);
  v200 = v197;
  v199 = v7 & 0x8000;
  if ( (v7 & 0x8000) != 0 )
  {
    v199 = 0;
    goto LABEL_8;
  }
  v208[1] = a1;
  v208[0] = (__int64)funlockfile;
  _RDX = *(_QWORD *)(a1 + 136);
  v13 = (u32 *)__readfsqword(0x10u);
  if ( *(u32 **)(_RDX + 8) != v13 )
  {
    _RSI = 1LL;
    v28 = _libc_multiple_threads == 0;
    if ( _libc_multiple_threads )
    {
      if ( !_InterlockedCompareExchange((volatile signed __int32 *)_RDX, 1, 0) )
        goto LABEL_27;
    }
    else
    {
      __asm { cmpxchg [rdx], esi }
      if ( v28 )
      {
LABEL_27:
        _RDX = *(_QWORD *)(a1 + 136);
        *(_QWORD *)(_RDX + 8) = v13;
        goto LABEL_28;
      }
    }
    v11 = _RDX;
    _lll_lock_wait_private((u32 *)_RDX, 1LL, _RDX, v12, v13, v14);
    goto LABEL_27;
  }
LABEL_28:
  ++*(_DWORD *)(_RDX + 4);
LABEL_8:
  v15 = *(_QWORD *)(a1 + 216);
  v196 = (char *)&_start___libc_atexit - (char *)_start___libc_IO_vtables;
  if ( (char *)&_start___libc_atexit - (char *)_start___libc_IO_vtables <= (unsigned __int64)(v15
                                                                                            - (_QWORD)_start___libc_IO_vtables) )
  {
    v195 = (_QWORD *)v15;
    IO_vtable_check(
      v11,
      _RSI,
      v15 - (_QWORD)_start___libc_IO_vtables,
      (char *)&_start___libc_atexit - (char *)_start___libc_IO_vtables,
      v13,
      v14);
    v15 = (__int64)v195;
  }
  v16 = a2;
  v17 = (__int64)&v197[-a2];
  if ( &v197[-a2] != (char *)(*(__int64 (__fastcall **)(__int64, unsigned __int64, char *))(v15 + 56))(
                               a1,
                               a2,
                               &v197[-a2]) )
  {
LABEL_41:
    LODWORD(v21) = -1;
    goto LABEL_31;
  }
  if ( v17 > 0x7FFFFFFF )
  {
LABEL_50:
    LODWORD(v21) = -1;
    __writefsdword(0xFFFFFFC0, 0x4Bu);
    goto LABEL_31;
  }
  v20 = (__int64)v200;
  v21 = (unsigned int)v17;
  if ( *v200 )
  {
    v180 = (_BYTE *)_printf_function_table;
    if ( _printf_function_table )
    {
      v179 = 0;
      v180 = 0LL;
      v184 = -1LL;
      v183 = v213;
    }
    else if ( _printf_modifier_table )
    {
      v179 = 0;
      v184 = -1LL;
      v183 = v213;
    }
    else
    {
      v179 = 0;
      if ( _printf_va_arg_table )
      {
        v184 = -1LL;
        v183 = v213;
      }
      else
      {
        v187 = 0;
        v184 = -1LL;
        while ( 2 )
        {
          v200 = (char *)(v20 + 1);
          v22 = *(_BYTE *)(v20 + 1);
          if ( (unsigned __int8)(v22 - 32) <= 0x5Au )
          {
            v19 = 0LL;
            v20 = 0LL;
            v23 = (__int64)v213;
            v24 = 0;
            v25 = 0;
            v18 = 0xFFFFFFFFLL;
            v181 = 0;
            v26 = jump_table[v22 - 32];
            LODWORD(v194) = 0;
            v182 = 0;
            v16 = (__int64)v214;
            v188 = 0;
            v192 = (signed __int64)v214;
            LODWORD(v193) = 0;
            v186 = 0;
            v185 = 0;
            v195 = 0LL;
            LOBYTE(v191) = 32;
            v183 = v213;
            switch ( v26 )
            {
              case 0LL:
                goto LABEL_37;
              case 1LL:
LABEL_153:
                while ( 2 )
                {
                  v22 = *++v200;
                  if ( (unsigned __int8)(*v200 - 32) <= 0x5Au )
                  {
                    v23 = (__int64)jump_table;
                    v186 = 1;
                    switch ( v22 )
                    {
                      case ' ':
                        continue;
                      case '!':
                      case '"':
                      case '$':
                      case '&':
                      case '(':
                      case ')':
                      case ',':
                      case '/':
                      case ':':
                      case ';':
                      case '<':
                      case '=':
                      case '>':
                      case '?':
                      case '@':
                      case 'B':
                      case 'D':
                      case 'H':
                      case 'J':
                      case 'K':
                      case 'M':
                      case 'N':
                      case 'O':
                      case 'P':
                      case 'Q':
                      case 'R':
                      case 'T':
                      case 'U':
                      case 'V':
                      case 'W':
                      case 'Y':
                      case '[':
                      case '\\':
                      case ']':
                      case '^':
                      case '_':
                      case '`':
                      case 'b':
                      case 'k':
                      case 'r':
                      case 'v':
                      case 'w':
                      case 'y':
                        goto LABEL_37;
                      case '#':
                        goto LABEL_159;
                      case '%':
                        goto LABEL_225;
                      case '\'':
                        goto LABEL_161;
                      case '*':
                        goto LABEL_131;
                      case '+':
                        goto LABEL_151;
                      case '-':
                        goto LABEL_149;
                      case '.':
                        goto LABEL_115;
                      case '0':
                        goto LABEL_155;
                      case '1':
                      case '2':
                      case '3':
                      case '4':
                      case '5':
                      case '6':
                      case '7':
                      case '8':
                      case '9':
                        goto LABEL_119;
                      case 'A':
                      case 'a':
                        goto LABEL_164;
                      case 'C':
                        goto LABEL_55;
                      case 'E':
                      case 'F':
                      case 'G':
                      case 'e':
                      case 'f':
                      case 'g':
                        goto LABEL_231;
                      case 'I':
                        goto LABEL_147;
                      case 'L':
                      case 'q':
                        goto LABEL_107;
                      case 'S':
                      case 's':
                        goto LABEL_76;
                      case 'X':
                      case 'x':
                        goto LABEL_229;
                      case 'Z':
                      case 'j':
                      case 't':
                      case 'z':
                        goto LABEL_36;
                      case 'c':
                        goto LABEL_92;
                      case 'd':
                      case 'i':
                        goto LABEL_235;
                      case 'h':
                        goto LABEL_113;
                      case 'l':
                        goto LABEL_109;
                      case 'm':
                        goto LABEL_106;
                      case 'n':
                        goto LABEL_170;
                      case 'o':
                        goto LABEL_230;
                      case 'p':
                        goto LABEL_176;
                      case 'u':
                        goto LABEL_220;
                    }
                  }
                  goto LABEL_37;
                }
              case 2LL:
LABEL_151:
                v188 = 1;
                v22 = *++v200;
                if ( (unsigned __int8)(*v200 - 32) <= 0x5Au )
                  goto LABEL_148;
                goto LABEL_37;
              case 3LL:
LABEL_149:
                while ( 2 )
                {
                  v22 = *++v200;
                  if ( (unsigned __int8)(*v200 - 32) <= 0x5Au )
                  {
                    v23 = (__int64)jump_table;
                    LOBYTE(v191) = 32;
                    LODWORD(v193) = 1;
                    switch ( v22 )
                    {
                      case ' ':
                        goto LABEL_153;
                      case '!':
                      case '"':
                      case '$':
                      case '&':
                      case '(':
                      case ')':
                      case ',':
                      case '/':
                      case ':':
                      case ';':
                      case '<':
                      case '=':
                      case '>':
                      case '?':
                      case '@':
                      case 'B':
                      case 'D':
                      case 'H':
                      case 'J':
                      case 'K':
                      case 'M':
                      case 'N':
                      case 'O':
                      case 'P':
                      case 'Q':
                      case 'R':
                      case 'T':
                      case 'U':
                      case 'V':
                      case 'W':
                      case 'Y':
                      case '[':
                      case '\\':
                      case ']':
                      case '^':
                      case '_':
                      case '`':
                      case 'b':
                      case 'k':
                      case 'r':
                      case 'v':
                      case 'w':
                      case 'y':
                        goto LABEL_37;
                      case '#':
                        goto LABEL_159;
                      case '%':
                        goto LABEL_225;
                      case '\'':
                        goto LABEL_161;
                      case '*':
                        goto LABEL_131;
                      case '+':
                        goto LABEL_151;
                      case '-':
                        continue;
                      case '.':
                        goto LABEL_115;
                      case '0':
                        goto LABEL_155;
                      case '1':
                      case '2':
                      case '3':
                      case '4':
                      case '5':
                      case '6':
                      case '7':
                      case '8':
                      case '9':
                        goto LABEL_119;
                      case 'A':
                      case 'a':
                        goto LABEL_164;
                      case 'C':
                        goto LABEL_55;
                      case 'E':
                      case 'F':
                      case 'G':
                      case 'e':
                      case 'f':
                      case 'g':
                        goto LABEL_231;
                      case 'I':
                        goto LABEL_147;
                      case 'L':
                      case 'q':
                        goto LABEL_107;
                      case 'S':
                      case 's':
                        goto LABEL_76;
                      case 'X':
                      case 'x':
                        goto LABEL_229;
                      case 'Z':
                      case 'j':
                      case 't':
                      case 'z':
                        goto LABEL_36;
                      case 'c':
                        goto LABEL_92;
                      case 'd':
                      case 'i':
                        goto LABEL_235;
                      case 'h':
                        goto LABEL_113;
                      case 'l':
                        goto LABEL_109;
                      case 'm':
                        goto LABEL_106;
                      case 'n':
                        goto LABEL_170;
                      case 'o':
                        goto LABEL_230;
                      case 'p':
                        goto LABEL_176;
                      case 'u':
                        goto LABEL_220;
                    }
                  }
                  goto LABEL_37;
                }
              case 4LL:
LABEL_159:
                v185 = 1;
                v22 = *++v200;
                if ( (unsigned __int8)(*v200 - 32) <= 0x5Au )
                  goto LABEL_148;
                goto LABEL_37;
              case 5LL:
LABEL_155:
                v71 = v191;
                if ( !(_DWORD)v193 )
                  v71 = 48;
                LOBYTE(v191) = v71;
                v22 = *++v200;
                if ( (unsigned __int8)(*v200 - 32) <= 0x5Au )
                  goto LABEL_148;
                goto LABEL_37;
              case 6LL:
LABEL_161:
                if ( v184 == -1 )
                {
                  v136 = *(_QWORD *)__readfsqword(0xFFFFFFB8);
                  v137 = *(_BYTE **)(v136 + 80);
                  v138 = *(_BYTE **)(v136 + 72);
                  v139 = *v137;
                  v180 = v138;
                  if ( !v139 || v139 == 127 )
                  {
                    v184 = 0LL;
                  }
                  else
                  {
                    v140 = 0LL;
                    if ( *v138 )
                      v140 = v137;
                    v184 = (__int64)v140;
                  }
                }
                v182 = 1;
                v22 = *++v200;
                if ( (unsigned __int8)(*v200 - 32) <= 0x5Au )
                  goto LABEL_148;
                goto LABEL_37;
              case 7LL:
LABEL_131:
                v204 = ++v200;
                if ( (unsigned int)(unsigned __int8)*v200 - 48 > 9 )
                  goto LABEL_132;
                v177 = v21;
                v178 = 0;
                LODWORD(v189) = -1;
                LODWORD(v190) = 0;
                LODWORD(v194) = 0;
                v135 = read_int(&v204);
                v20 = (unsigned int)v194;
                v19 = (unsigned int)v190;
                v18 = (unsigned int)v189;
                v24 = v178;
                v16 = (__int64)step3a_jumps_13585;
                v21 = v177;
                if ( v135 == -1 )
                  goto LABEL_105;
                if ( v135 && *v204 == 36 )
                  goto LABEL_53;
LABEL_132:
                v64 = a3->m128i_i32[0];
                if ( a3->m128i_i32[0] > 0x2Fu )
                {
                  v65 = (int *)a3->m128i_i64[1];
                  a3->m128i_i64[1] = (__int64)(v65 + 2);
                }
                else
                {
                  v65 = (int *)(a3[1].m128i_i64[0] + v64);
                  a3->m128i_i32[0] = v64 + 8;
                }
                v66 = *v65;
                LODWORD(v194) = v66;
                if ( v66 < 0 )
                {
                  LOBYTE(v191) = 32;
                  LODWORD(v194) = -v66;
                  LODWORD(v193) = 1;
                }
                if ( (int)v194 > 2147483614 )
                  goto LABEL_105;
                if ( (int)v194 <= 967 )
                  goto LABEL_145;
                v177 = v21;
                v67 = (int)v194 + 32LL;
                v178 = v24;
                LODWORD(v189) = v18;
                LODWORD(v190) = v19;
                LODWORD(v192) = v20;
                v68 = _libc_alloca_cutoff(v67);
                v20 = (unsigned int)v192;
                v19 = (unsigned int)v190;
                v18 = (unsigned int)v189;
                v24 = v178;
                v16 = (__int64)step3a_jumps_13585;
                v21 = v177;
                if ( v67 <= 0x1000 || v68 )
                {
                  v192 = (v67 + 23) & 0xFFFFFFFFFFFFFFF0LL;
                  v69 = (unsigned int *)((char *)&v176 - ((v67 + 23) & 0xFFFFFFFFFFFFF000LL));
                  if ( &v176 != v69 )
                  {
                    while ( &v174 != (__int64 *)v69 )
                      ;
                  }
                  if ( (((_WORD)v67 + 23) & 0xFF0) != 0 )
                  {
                    v70 = alloca(((_WORD)v67 + 23) & 0xFF0);
                    *(__int64 *)((char *)&v173 + (((_WORD)v67 + 23) & 0xFF0)) = *(__int64 *)((char *)&v173
                                                                                           + (((_WORD)v67 + 23) & 0xFF0));
                  }
                  v192 = (signed __int64)&v175[v67];
                }
                else
                {
                  v172 = malloc(
                           v67,
                           (__int64)step3a_jumps_13585,
                           (_QWORD *)(unsigned int)v192,
                           (unsigned int)v189,
                           (u32 *)(unsigned int)v190,
                           v177);
                  v20 = (unsigned int)v192;
                  v19 = (unsigned int)v190;
                  v195 = v172;
                  v18 = (unsigned int)v189;
                  v16 = (__int64)step3a_jumps_13585;
                  v24 = v178;
                  v21 = v177;
                  if ( !v172 )
                    goto LABEL_41;
                  v192 = (signed __int64)v195 + v67;
                }
LABEL_145:
                v22 = *v200;
                if ( (unsigned __int8)(*v200 - 32) <= 0x5Au )
                {
LABEL_146:
                  v23 = jump_table[v22 - 32];
                  switch ( v22 )
                  {
                    case ' ':
                    case '!':
                    case '"':
                    case '#':
                    case '$':
                    case '&':
                    case '\'':
                    case '(':
                    case ')':
                    case '*':
                    case '+':
                    case ',':
                    case '-':
                    case '/':
                    case '0':
                    case '1':
                    case '2':
                    case '3':
                    case '4':
                    case '5':
                    case '6':
                    case '7':
                    case '8':
                    case '9':
                    case ':':
                    case ';':
                    case '<':
                    case '=':
                    case '>':
                    case '?':
                    case '@':
                    case 'B':
                    case 'D':
                    case 'H':
                    case 'I':
                    case 'J':
                    case 'K':
                    case 'M':
                    case 'N':
                    case 'O':
                    case 'P':
                    case 'Q':
                    case 'R':
                    case 'T':
                    case 'U':
                    case 'V':
                    case 'W':
                    case 'Y':
                    case '[':
                    case '\\':
                    case ']':
                    case '^':
                    case '_':
                    case '`':
                    case 'b':
                    case 'k':
                    case 'r':
                    case 'v':
                    case 'w':
                    case 'y':
                      goto LABEL_37;
                    case '%':
                      goto LABEL_225;
                    case '.':
                      goto LABEL_115;
                    case 'A':
                    case 'a':
                      goto LABEL_164;
                    case 'C':
                      goto LABEL_55;
                    case 'E':
                    case 'F':
                    case 'G':
                    case 'e':
                    case 'f':
                    case 'g':
                      goto LABEL_231;
                    case 'L':
                    case 'q':
                      goto LABEL_107;
                    case 'S':
                    case 's':
                      goto LABEL_76;
                    case 'X':
                    case 'x':
                      goto LABEL_229;
                    case 'Z':
                    case 'j':
                    case 't':
                    case 'z':
                      goto LABEL_36;
                    case 'c':
                      goto LABEL_92;
                    case 'd':
                    case 'i':
                      goto LABEL_235;
                    case 'h':
                      goto LABEL_113;
                    case 'l':
                      goto LABEL_109;
                    case 'm':
                      goto LABEL_106;
                    case 'n':
                      goto LABEL_170;
                    case 'o':
                      goto LABEL_230;
                    case 'p':
                      goto LABEL_176;
                    case 'u':
                      goto LABEL_220;
                  }
                }
                goto LABEL_37;
              case 8LL:
LABEL_119:
                v176 = v21;
                v177 = 0;
                v178 = -1;
                LODWORD(v189) = 0;
                LODWORD(v190) = 0;
                v59 = read_int(&v200);
                v20 = (unsigned int)v190;
                v19 = (unsigned int)v189;
                LODWORD(v194) = v59;
                v18 = v178;
                v16 = (__int64)step3a_jumps_13585;
                v24 = v177;
                v21 = v176;
                if ( v59 > 0x7FFFFFDE )
                  goto LABEL_105;
                if ( (int)v194 <= 967 )
                  goto LABEL_128;
                v177 = v176;
                v60 = (int)v194 + 32LL;
                v178 = v24;
                LODWORD(v189) = v18;
                LODWORD(v190) = v19;
                LODWORD(v192) = v20;
                v61 = _libc_alloca_cutoff(v60);
                v20 = (unsigned int)v192;
                v19 = (unsigned int)v190;
                v18 = (unsigned int)v189;
                v24 = v178;
                v16 = (__int64)step3a_jumps_13585;
                v21 = v177;
                if ( v61 || v60 <= 0x1000 )
                {
                  v192 = (v60 + 23) & 0xFFFFFFFFFFFFFFF0LL;
                  v62 = (unsigned int *)((char *)&v176 - ((v60 + 23) & 0xFFFFFFFFFFFFF000LL));
                  if ( &v176 != v62 )
                  {
                    while ( &v174 != (__int64 *)v62 )
                      ;
                  }
                  if ( (((_WORD)v60 + 23) & 0xFF0) != 0 )
                  {
                    v63 = alloca(((_WORD)v60 + 23) & 0xFF0);
                    *(__int64 *)((char *)&v173 + (((_WORD)v60 + 23) & 0xFF0)) = *(__int64 *)((char *)&v173
                                                                                           + (((_WORD)v60 + 23) & 0xFF0));
                  }
                  v192 = (signed __int64)&v175[v60];
                }
                else
                {
                  v171 = malloc(
                           v60,
                           (__int64)step3a_jumps_13585,
                           (_QWORD *)(unsigned int)v192,
                           (unsigned int)v189,
                           (u32 *)(unsigned int)v190,
                           v177);
                  v20 = (unsigned int)v192;
                  v19 = (unsigned int)v190;
                  v195 = v171;
                  v18 = (unsigned int)v189;
                  v16 = (__int64)step3a_jumps_13585;
                  v24 = v178;
                  v21 = v177;
                  if ( !v171 )
                    goto LABEL_41;
                  v192 = (signed __int64)v195 + v60;
                }
LABEL_128:
                v22 = *v200;
                if ( *v200 == 36 )
                  goto LABEL_53;
                if ( (unsigned __int8)(v22 - 32) <= 0x5Au )
                  goto LABEL_146;
                goto LABEL_37;
              case 9LL:
LABEL_115:
                v58 = (__int64)v200++;
                v22 = *v200;
                if ( *v200 == 42 )
                {
                  v200 = (char *)(v58 + 2);
                  v204 = (const char *)(v58 + 2);
                  if ( (unsigned int)*(unsigned __int8 *)(v58 + 2) - 48 <= 9 )
                  {
                    v177 = v21;
                    v178 = v24;
                    LODWORD(v189) = v19;
                    LODWORD(v190) = v20;
                    v163 = read_int(&v204);
                    v20 = (unsigned int)v190;
                    v19 = (unsigned int)v189;
                    v24 = v178;
                    v21 = v177;
                    v16 = (__int64)step3a_jumps_13585;
                    if ( v163 == -1 )
                      goto LABEL_105;
                    if ( v163 && *v204 == 36 )
                      goto LABEL_53;
                  }
                  v128 = a3->m128i_i32[0];
                  if ( a3->m128i_i32[0] > 0x2Fu )
                  {
                    v129 = (unsigned int *)a3->m128i_i64[1];
                    a3->m128i_i64[1] = (__int64)(v129 + 2);
                  }
                  else
                  {
                    v129 = (unsigned int *)(a3[1].m128i_i64[0] + v128);
                    a3->m128i_i32[0] = v128 + 8;
                  }
                  v18 = *v129;
                  if ( (int)v18 < 0 )
                    v18 = 0xFFFFFFFFLL;
                }
                else
                {
                  v18 = 0LL;
                  if ( (unsigned int)(unsigned __int8)v22 - 48 > 9 )
                    goto LABEL_117;
                  v177 = v21;
                  v178 = v24;
                  LODWORD(v189) = v19;
                  LODWORD(v190) = v20;
                  v145 = read_int(&v200);
                  v20 = (unsigned int)v190;
                  v19 = (unsigned int)v189;
                  v18 = v145;
                  v24 = v178;
                  v21 = v177;
                  v16 = (__int64)step3a_jumps_13585;
                  if ( v145 == -1 )
                    goto LABEL_105;
                }
                v130 = 968;
                if ( (int)v194 >= 968 )
                  v130 = v194;
                if ( v130 >= (int)v18 )
                {
LABEL_484:
                  v22 = *v200;
LABEL_117:
                  if ( (unsigned __int8)(v22 - 32) <= 0x5Au )
                  {
                    v23 = jump_table[v22 - 32];
                    switch ( v22 )
                    {
                      case ' ':
                      case '!':
                      case '"':
                      case '#':
                      case '$':
                      case '&':
                      case '\'':
                      case '(':
                      case ')':
                      case '*':
                      case '+':
                      case ',':
                      case '-':
                      case '.':
                      case '/':
                      case '0':
                      case '1':
                      case '2':
                      case '3':
                      case '4':
                      case '5':
                      case '6':
                      case '7':
                      case '8':
                      case '9':
                      case ':':
                      case ';':
                      case '<':
                      case '=':
                      case '>':
                      case '?':
                      case '@':
                      case 'B':
                      case 'D':
                      case 'H':
                      case 'I':
                      case 'J':
                      case 'K':
                      case 'M':
                      case 'N':
                      case 'O':
                      case 'P':
                      case 'Q':
                      case 'R':
                      case 'T':
                      case 'U':
                      case 'V':
                      case 'W':
                      case 'Y':
                      case '[':
                      case '\\':
                      case ']':
                      case '^':
                      case '_':
                      case '`':
                      case 'b':
                      case 'k':
                      case 'r':
                      case 'v':
                      case 'w':
                      case 'y':
                        goto LABEL_37;
                      case '%':
                        goto LABEL_225;
                      case 'A':
                      case 'a':
                        goto LABEL_164;
                      case 'C':
                        goto LABEL_55;
                      case 'E':
                      case 'F':
                      case 'G':
                      case 'e':
                      case 'f':
                      case 'g':
                        goto LABEL_231;
                      case 'L':
                      case 'q':
                        goto LABEL_107;
                      case 'S':
                      case 's':
                        goto LABEL_76;
                      case 'X':
                      case 'x':
                        goto LABEL_229;
                      case 'Z':
                      case 'j':
                      case 't':
                      case 'z':
                        goto LABEL_36;
                      case 'c':
                        goto LABEL_92;
                      case 'd':
                      case 'i':
                        goto LABEL_235;
                      case 'h':
                        goto LABEL_113;
                      case 'l':
                        goto LABEL_109;
                      case 'm':
                        goto LABEL_106;
                      case 'n':
                        goto LABEL_170;
                      case 'o':
                        goto LABEL_230;
                      case 'p':
                        goto LABEL_176;
                      case 'u':
                        goto LABEL_220;
                    }
                  }
                  goto LABEL_37;
                }
                if ( v195 )
                {
                  v177 = v21;
                  v178 = v24;
                  LODWORD(v189) = v18;
                  LODWORD(v190) = v19;
                  LODWORD(v192) = v20;
                  free((__int64)v195, v16, v20, v18, (u32 *)v19, v21);
                  LODWORD(v21) = v177;
                  v24 = v178;
                  v18 = (unsigned int)v189;
                  v19 = (unsigned int)v190;
                  LODWORD(v20) = v192;
                }
                if ( (int)v18 <= 2147483614 )
                {
                  v178 = v21;
                  v131 = (int)v18 + 32LL;
                  LODWORD(v189) = v24;
                  LODWORD(v190) = v19;
                  LODWORD(v192) = v20;
                  LODWORD(v195) = v18;
                  v132 = _libc_alloca_cutoff(v131);
                  v18 = (unsigned int)v195;
                  v20 = (unsigned int)v192;
                  v19 = (unsigned int)v190;
                  v24 = v189;
                  v16 = (__int64)step3a_jumps_13585;
                  v21 = v178;
                  if ( v131 <= 0x1000 || v132 )
                  {
                    v195 = (_QWORD *)((v131 + 23) & 0xFFFFFFFFFFFFFFF0LL);
                    v133 = (unsigned int *)((char *)&v176 - ((v131 + 23) & 0xFFFFFFFFFFFFF000LL));
                    if ( &v176 != v133 )
                    {
                      while ( &v174 != (__int64 *)v133 )
                        ;
                    }
                    if ( (((_WORD)v131 + 23) & 0xFF0) != 0 )
                    {
                      v134 = alloca(((_WORD)v131 + 23) & 0xFF0);
                      *(__int64 *)((char *)&v173 + (((_WORD)v131 + 23) & 0xFF0)) = *(__int64 *)((char *)&v173
                                                                                              + (((_WORD)v131 + 23) & 0xFF0));
                    }
                    v195 = 0LL;
                    v192 = (signed __int64)&v175[v131];
                    v22 = *v200;
                    goto LABEL_117;
                  }
                  v177 = v178;
                  v178 = v189;
                  LODWORD(v189) = (_DWORD)v195;
                  v166 = malloc(
                           v131,
                           (__int64)step3a_jumps_13585,
                           (_QWORD *)(unsigned int)v192,
                           (unsigned int)v195,
                           (u32 *)(unsigned int)v190,
                           v21);
                  v20 = (unsigned int)v192;
                  v19 = (unsigned int)v190;
                  v195 = v166;
                  v18 = (unsigned int)v189;
                  v16 = (__int64)step3a_jumps_13585;
                  v24 = v178;
                  v21 = v177;
                  if ( !v166 )
                    goto LABEL_41;
                  v192 = (signed __int64)v195 + v131;
                  goto LABEL_484;
                }
                break;
              case 10LL:
LABEL_113:
                v25 = 1;
                v22 = *++v200;
                if ( (unsigned __int8)(*v200 - 32) <= 0x5Au )
                {
                  v23 = (__int64)jump_table;
                  switch ( v22 )
                  {
                    case ' ':
                    case '!':
                    case '"':
                    case '#':
                    case '$':
                    case '&':
                    case '\'':
                    case '(':
                    case ')':
                    case '*':
                    case '+':
                    case ',':
                    case '-':
                    case '.':
                    case '/':
                    case '0':
                    case '1':
                    case '2':
                    case '3':
                    case '4':
                    case '5':
                    case '6':
                    case '7':
                    case '8':
                    case '9':
                    case ':':
                    case ';':
                    case '<':
                    case '=':
                    case '>':
                    case '?':
                    case '@':
                    case 'A':
                    case 'B':
                    case 'C':
                    case 'D':
                    case 'E':
                    case 'F':
                    case 'G':
                    case 'H':
                    case 'I':
                    case 'J':
                    case 'K':
                    case 'L':
                    case 'M':
                    case 'N':
                    case 'O':
                    case 'P':
                    case 'Q':
                    case 'R':
                    case 'S':
                    case 'T':
                    case 'U':
                    case 'V':
                    case 'W':
                    case 'Y':
                    case 'Z':
                    case '[':
                    case '\\':
                    case ']':
                    case '^':
                    case '_':
                    case '`':
                    case 'a':
                    case 'b':
                    case 'c':
                    case 'e':
                    case 'f':
                    case 'g':
                    case 'j':
                    case 'k':
                    case 'l':
                    case 'm':
                    case 'p':
                    case 'q':
                    case 'r':
                    case 's':
                    case 't':
                    case 'v':
                    case 'w':
                    case 'y':
                    case 'z':
                      goto LABEL_37;
                    case '%':
                      goto LABEL_225;
                    case 'X':
                    case 'x':
                      goto LABEL_229;
                    case 'd':
                    case 'i':
                      goto LABEL_235;
                    case 'h':
                      v22 = *++v200;
                      if ( (unsigned __int8)(*v200 - 32) <= 0x5Au )
                      {
                        v23 = (__int64)jump_table;
                        v25 = 0;
                        v19 = 1LL;
                        switch ( v22 )
                        {
                          case ' ':
                          case '!':
                          case '"':
                          case '#':
                          case '$':
                          case '&':
                          case '\'':
                          case '(':
                          case ')':
                          case '*':
                          case '+':
                          case ',':
                          case '-':
                          case '.':
                          case '/':
                          case '0':
                          case '1':
                          case '2':
                          case '3':
                          case '4':
                          case '5':
                          case '6':
                          case '7':
                          case '8':
                          case '9':
                          case ':':
                          case ';':
                          case '<':
                          case '=':
                          case '>':
                          case '?':
                          case '@':
                          case 'B':
                          case 'D':
                          case 'H':
                          case 'I':
                          case 'J':
                          case 'K':
                          case 'L':
                          case 'M':
                          case 'N':
                          case 'O':
                          case 'P':
                          case 'Q':
                          case 'R':
                          case 'T':
                          case 'U':
                          case 'V':
                          case 'W':
                          case 'Y':
                          case 'Z':
                          case '[':
                          case '\\':
                          case ']':
                          case '^':
                          case '_':
                          case '`':
                          case 'b':
                          case 'h':
                          case 'j':
                          case 'k':
                          case 'l':
                          case 'q':
                          case 'r':
                          case 't':
                          case 'v':
                          case 'w':
                          case 'y':
                          case 'z':
                            goto LABEL_37;
                          case '%':
                            goto LABEL_225;
                          case 'A':
                          case 'a':
                            goto LABEL_164;
                          case 'C':
                            goto LABEL_55;
                          case 'E':
                          case 'F':
                          case 'G':
                          case 'e':
                          case 'f':
                          case 'g':
                            goto LABEL_231;
                          case 'S':
                          case 's':
                            goto LABEL_76;
                          case 'X':
                          case 'x':
                            goto LABEL_229;
                          case 'c':
                            goto LABEL_92;
                          case 'd':
                          case 'i':
                            goto LABEL_235;
                          case 'm':
                            goto LABEL_106;
                          case 'n':
                            goto LABEL_170;
                          case 'o':
                            goto LABEL_230;
                          case 'p':
                            goto LABEL_176;
                          case 'u':
                            goto LABEL_220;
                        }
                      }
                      goto LABEL_37;
                    case 'n':
                      goto LABEL_170;
                    case 'o':
                      goto LABEL_230;
                    case 'u':
                      goto LABEL_220;
                  }
                }
                goto LABEL_37;
              case 11LL:
LABEL_109:
                v24 = 1;
                v22 = *++v200;
                if ( (unsigned __int8)(*v200 - 32) <= 0x5Au )
                {
                  v23 = (__int64)jump_table;
                  switch ( v22 )
                  {
                    case ' ':
                    case '!':
                    case '"':
                    case '#':
                    case '$':
                    case '&':
                    case '\'':
                    case '(':
                    case ')':
                    case '*':
                    case '+':
                    case ',':
                    case '-':
                    case '.':
                    case '/':
                    case '0':
                    case '1':
                    case '2':
                    case '3':
                    case '4':
                    case '5':
                    case '6':
                    case '7':
                    case '8':
                    case '9':
                    case ':':
                    case ';':
                    case '<':
                    case '=':
                    case '>':
                    case '?':
                    case '@':
                    case 'B':
                    case 'D':
                    case 'H':
                    case 'I':
                    case 'J':
                    case 'K':
                    case 'L':
                    case 'M':
                    case 'N':
                    case 'O':
                    case 'P':
                    case 'Q':
                    case 'R':
                    case 'T':
                    case 'U':
                    case 'V':
                    case 'W':
                    case 'Y':
                    case 'Z':
                    case '[':
                    case '\\':
                    case ']':
                    case '^':
                    case '_':
                    case '`':
                    case 'b':
                    case 'h':
                    case 'j':
                    case 'k':
                    case 'q':
                    case 'r':
                    case 't':
                    case 'v':
                    case 'w':
                    case 'y':
                    case 'z':
                      goto LABEL_37;
                    case '%':
                      goto LABEL_225;
                    case 'A':
                    case 'a':
                      goto LABEL_164;
                    case 'C':
                      goto LABEL_55;
                    case 'E':
                    case 'F':
                    case 'G':
                    case 'e':
                    case 'f':
                    case 'g':
                      goto LABEL_231;
                    case 'S':
                    case 's':
                      goto LABEL_76;
                    case 'X':
                    case 'x':
                      goto LABEL_229;
                    case 'c':
                      goto LABEL_92;
                    case 'd':
                    case 'i':
                      goto LABEL_235;
                    case 'l':
                      goto LABEL_107;
                    case 'm':
                      goto LABEL_106;
                    case 'n':
                      goto LABEL_170;
                    case 'o':
                      goto LABEL_230;
                    case 'p':
                      goto LABEL_176;
                    case 'u':
                      goto LABEL_220;
                  }
                }
                goto LABEL_37;
              case 12LL:
LABEL_107:
                v20 = (__int64)(v200 + 1);
                v200 = (char *)v20;
                v22 = *(_BYTE *)v20;
                if ( (unsigned __int8)(*(_BYTE *)v20 - 32) <= 0x5Au )
                {
                  v24 = 1;
                  v20 = 1LL;
                  v23 = (__int64)jump_table;
                  switch ( v22 )
                  {
                    case ' ':
                    case '!':
                    case '"':
                    case '#':
                    case '$':
                    case '&':
                    case '\'':
                    case '(':
                    case ')':
                    case '*':
                    case '+':
                    case ',':
                    case '-':
                    case '.':
                    case '/':
                    case '0':
                    case '1':
                    case '2':
                    case '3':
                    case '4':
                    case '5':
                    case '6':
                    case '7':
                    case '8':
                    case '9':
                    case ':':
                    case ';':
                    case '<':
                    case '=':
                    case '>':
                    case '?':
                    case '@':
                    case 'B':
                    case 'D':
                    case 'H':
                    case 'I':
                    case 'J':
                    case 'K':
                    case 'L':
                    case 'M':
                    case 'N':
                    case 'O':
                    case 'P':
                    case 'Q':
                    case 'R':
                    case 'T':
                    case 'U':
                    case 'V':
                    case 'W':
                    case 'Y':
                    case 'Z':
                    case '[':
                    case '\\':
                    case ']':
                    case '^':
                    case '_':
                    case '`':
                    case 'b':
                    case 'h':
                    case 'j':
                    case 'k':
                    case 'l':
                    case 'q':
                    case 'r':
                    case 't':
                    case 'v':
                    case 'w':
                    case 'y':
                    case 'z':
                      goto LABEL_37;
                    case '%':
                      goto LABEL_225;
                    case 'A':
                    case 'a':
                      goto LABEL_164;
                    case 'C':
                      goto LABEL_55;
                    case 'E':
                    case 'F':
                    case 'G':
                    case 'e':
                    case 'f':
                    case 'g':
                      goto LABEL_231;
                    case 'S':
                    case 's':
                      goto LABEL_76;
                    case 'X':
                    case 'x':
                      goto LABEL_229;
                    case 'c':
                      goto LABEL_92;
                    case 'd':
                    case 'i':
                      goto LABEL_235;
                    case 'm':
                      goto LABEL_106;
                    case 'n':
                      goto LABEL_170;
                    case 'o':
                      goto LABEL_230;
                    case 'p':
                      goto LABEL_176;
                    case 'u':
                      goto LABEL_220;
                  }
                }
                goto LABEL_37;
              case 13LL:
              case 27LL:
              case 28LL:
LABEL_36:
                v20 = (__int64)(v200 + 1);
                v200 = (char *)v20;
                v22 = *(_BYTE *)v20;
                if ( (unsigned __int8)(*(_BYTE *)v20 - 32) <= 0x5Au )
                {
                  v23 = (__int64)jump_table;
                  v20 = 0LL;
                  v24 = 1;
                  switch ( v22 )
                  {
                    case ' ':
                    case '!':
                    case '"':
                    case '#':
                    case '$':
                    case '&':
                    case '\'':
                    case '(':
                    case ')':
                    case '*':
                    case '+':
                    case ',':
                    case '-':
                    case '.':
                    case '/':
                    case '0':
                    case '1':
                    case '2':
                    case '3':
                    case '4':
                    case '5':
                    case '6':
                    case '7':
                    case '8':
                    case '9':
                    case ':':
                    case ';':
                    case '<':
                    case '=':
                    case '>':
                    case '?':
                    case '@':
                    case 'B':
                    case 'D':
                    case 'H':
                    case 'I':
                    case 'J':
                    case 'K':
                    case 'L':
                    case 'M':
                    case 'N':
                    case 'O':
                    case 'P':
                    case 'Q':
                    case 'R':
                    case 'T':
                    case 'U':
                    case 'V':
                    case 'W':
                    case 'Y':
                    case 'Z':
                    case '[':
                    case '\\':
                    case ']':
                    case '^':
                    case '_':
                    case '`':
                    case 'b':
                    case 'h':
                    case 'j':
                    case 'k':
                    case 'l':
                    case 'q':
                    case 'r':
                    case 't':
                    case 'v':
                    case 'w':
                    case 'y':
                    case 'z':
                      goto LABEL_37;
                    case '%':
                      goto LABEL_225;
                    case 'A':
                    case 'a':
                      goto LABEL_164;
                    case 'C':
                      goto LABEL_55;
                    case 'E':
                    case 'F':
                    case 'G':
                    case 'e':
                    case 'f':
                    case 'g':
                      goto LABEL_231;
                    case 'S':
                    case 's':
                      goto LABEL_76;
                    case 'X':
                    case 'x':
                      goto LABEL_229;
                    case 'c':
                      goto LABEL_92;
                    case 'd':
                    case 'i':
                      goto LABEL_235;
                    case 'm':
                      goto LABEL_106;
                    case 'n':
                      goto LABEL_170;
                    case 'o':
                      goto LABEL_230;
                    case 'p':
                      goto LABEL_176;
                    case 'u':
                      goto LABEL_220;
                  }
                }
                goto LABEL_37;
              case 14LL:
LABEL_225:
                v95 = *(_BYTE **)(a1 + 40);
                if ( (unsigned __int64)v95 >= *(_QWORD *)(a1 + 48) )
                {
                  v16 = 37LL;
                  LODWORD(v194) = v21;
                  v164 = _overflow(a1, 37LL, v20, v18, (u32 *)v19, v21);
                  v21 = (unsigned int)v194;
                  if ( v164 == -1 )
                    goto LABEL_39;
                }
                else
                {
                  v20 = (__int64)(v95 + 1);
                  *(_QWORD *)(a1 + 40) = v95 + 1;
                  *v95 = 37;
                }
                if ( (_DWORD)v21 == 0x7FFFFFFF )
                  goto LABEL_39;
                v21 = (unsigned int)(v21 + 1);
                goto LABEL_67;
              case 15LL:
LABEL_235:
                v98 = a3->m128i_i32[0];
                if ( v24 )
                {
                  if ( v98 > 0x2F )
                  {
                    v20 = a3->m128i_i64[1];
                    a3->m128i_i64[1] = v20 + 8;
                  }
                  else
                  {
                    v20 = a3[1].m128i_i64[0] + v98;
                    a3->m128i_i32[0] = v98 + 8;
                  }
                  v99 = *(_QWORD *)v20;
                }
                else if ( (_DWORD)v19 )
                {
                  if ( v98 > 0x2F )
                  {
                    v20 = a3->m128i_i64[1];
                    a3->m128i_i64[1] = v20 + 8;
                  }
                  else
                  {
                    v20 = a3[1].m128i_i64[0] + v98;
                    a3->m128i_i32[0] = v98 + 8;
                  }
                  v99 = *(char *)v20;
                }
                else if ( v25 )
                {
                  if ( v98 > 0x2F )
                  {
                    v20 = a3->m128i_i64[1];
                    a3->m128i_i64[1] = v20 + 8;
                  }
                  else
                  {
                    v20 = a3[1].m128i_i64[0] + v98;
                    a3->m128i_i32[0] = v98 + 8;
                  }
                  v99 = *(__int16 *)v20;
                }
                else
                {
                  if ( v98 > 0x2F )
                  {
                    v20 = a3->m128i_i64[1];
                    a3->m128i_i64[1] = v20 + 8;
                  }
                  else
                  {
                    v20 = a3[1].m128i_i64[0] + v98;
                    a3->m128i_i32[0] = v98 + 8;
                  }
                  v99 = *(int *)v20;
                }
                if ( v99 < 0 )
                {
                  LODWORD(v190) = 10;
                  v189 = -v99;
                  v24 = 1;
                }
                else
                {
                  v189 = v99;
                  v24 = 0;
                  LODWORD(v190) = 10;
                }
                goto LABEL_180;
              case 16LL:
LABEL_220:
                LODWORD(v190) = 10;
                goto LABEL_221;
              case 17LL:
LABEL_230:
                LODWORD(v190) = 8;
                goto LABEL_221;
              case 18LL:
LABEL_229:
                LODWORD(v190) = 16;
LABEL_221:
                v93 = a3->m128i_i32[0];
                if ( v24 )
                {
                  if ( v93 > 0x2F )
                  {
                    v20 = a3->m128i_i64[1];
                    a3->m128i_i64[1] = v20 + 8;
                  }
                  else
                  {
                    v20 = a3[1].m128i_i64[0] + v93;
                    a3->m128i_i32[0] = v93 + 8;
                  }
                  v188 = 0;
                  v94 = *(_QWORD *)v20;
                  v24 = 0;
                  v186 = 0;
                  v189 = v94;
                }
                else if ( (_DWORD)v19 )
                {
                  if ( v93 > 0x2F )
                  {
                    v20 = a3->m128i_i64[1];
                    a3->m128i_i64[1] = v20 + 8;
                  }
                  else
                  {
                    v20 = a3[1].m128i_i64[0] + v93;
                    a3->m128i_i32[0] = v93 + 8;
                  }
                  v188 = 0;
                  v107 = *(unsigned __int8 *)v20;
                  v186 = 0;
                  v189 = v107;
                }
                else if ( v25 )
                {
                  if ( v93 > 0x2F )
                  {
                    v20 = a3->m128i_i64[1];
                    a3->m128i_i64[1] = v20 + 8;
                  }
                  else
                  {
                    v20 = a3[1].m128i_i64[0] + v93;
                    a3->m128i_i32[0] = v93 + 8;
                  }
                  v188 = 0;
                  v127 = *(unsigned __int16 *)v20;
                  v24 = 0;
                  v186 = 0;
                  v189 = v127;
                }
                else
                {
                  if ( v93 > 0x2F )
                  {
                    v20 = a3->m128i_i64[1];
                    a3->m128i_i64[1] = v20 + 8;
                  }
                  else
                  {
                    v20 = a3[1].m128i_i64[0] + v93;
                    a3->m128i_i32[0] = v93 + 8;
                  }
                  v188 = 0;
                  v113 = *(unsigned int *)v20;
                  v24 = 0;
                  v186 = 0;
                  v189 = v113;
                }
                goto LABEL_180;
              case 19LL:
LABEL_231:
                v204 = (const char *)__PAIR64__(v194, v18);
                v205 = v22;
                v96 = (unsigned __int8)v182 << 7;
                v206 = (unsigned __int8)(((_BYTE)v182 << 7) | ((_BYTE)v188 << 6) | (32 * v193) | (16 * v186) | (8 * v185) | (4 * v24) | v20);
                BYTE1(v206) = 8 * v181;
                v207 = (unsigned __int8)v191;
                if ( (_DWORD)v20 )
                {
                  v97 = (LONG_DOUBLE_16 *)((a3->m128i_i64[1] + 15) & 0xFFFFFFFFFFFFFFF0LL);
                  a3->m128i_i64[1] = (__int64)&v97[1];
                  v203 = *v97;
                }
                else
                {
                  v115 = a3->m128i_u32[1];
                  if ( v115 > 0xAF )
                  {
                    v116 = (_QWORD *)a3->m128i_i64[1];
                    a3->m128i_i64[1] = (__int64)(v116 + 1);
                  }
                  else
                  {
                    v116 = (_QWORD *)(a3[1].m128i_i64[0] + v115);
                    a3->m128i_i32[1] = v115 + 16;
                  }
                  *(_QWORD *)&v203.value = *v116;
                }
                v16 = (__int64)&v204;
                LODWORD(v194) = v21;
                v201 = &v203;
                v74 = _printf_fp((char *)a1, (__int64)&v204, (long double **)&v201, v96, (u32 *)v19, v21);
                if ( v74 < 0 )
                  goto LABEL_39;
                goto LABEL_167;
              case 20LL:
LABEL_92:
                if ( v24 )
                  goto LABEL_55;
                v16 = (unsigned int)v193;
                v51 = v194 - 1;
                v53 = (int)v194 - 1 > 0;
                if ( (_DWORD)v193 || (int)v194 - 1 <= 0 )
                  goto LABEL_95;
                v16 = 32LL;
                LODWORD(v192) = v21;
                v194 = v51;
                v160 = IO_padn((char *)a1, (char *)0x20, v51, v51, (u32 *)v19, v21);
                v18 = v194;
                if ( v194 != v160 )
                  goto LABEL_39;
                v21 = (unsigned int)v192;
                if ( (unsigned int)v192 > 0x7FFFFFFE )
                  goto LABEL_506;
                if ( 0x7FFFFFFF - (int)v192 < (unsigned int)v51 )
                  goto LABEL_105;
                v21 = (unsigned int)(v51 + v192);
LABEL_95:
                v54 = a3->m128i_i32[0];
                if ( a3->m128i_i32[0] > 0x2Fu )
                {
                  v55 = (unsigned int *)a3->m128i_i64[1];
                  a3->m128i_i64[1] = (__int64)(v55 + 2);
                }
                else
                {
                  v55 = (unsigned int *)(a3[1].m128i_i64[0] + v54);
                  a3->m128i_i32[0] = v54 + 8;
                }
                v20 = *v55;
                v56 = *(_BYTE **)(a1 + 40);
                if ( (unsigned __int64)v56 >= *(_QWORD *)(a1 + 48) )
                {
                  v16 = (unsigned __int8)v20;
                  LODWORD(v194) = v21;
                  v165 = _overflow(a1, (unsigned __int8)v20, v20, v18, (u32 *)v19, v21);
                  v21 = (unsigned int)v194;
                  if ( v165 == -1 )
                    goto LABEL_39;
                }
                else
                {
                  v18 = (__int64)(v56 + 1);
                  *(_QWORD *)(a1 + 40) = v56 + 1;
                  *v56 = v20;
                }
                if ( (_DWORD)v21 == 0x7FFFFFFF )
                  goto LABEL_39;
                v18 = (unsigned int)v193;
                v21 = (unsigned int)(v21 + 1);
                if ( !(_DWORD)v193 || !v53 )
                  goto LABEL_67;
                v16 = 32LL;
                LODWORD(v194) = v21;
                if ( v51 != IO_padn((char *)a1, (char *)0x20, v51, (unsigned int)v193, (u32 *)v19, v21) )
                  goto LABEL_39;
                v21 = (unsigned int)v194;
                if ( (unsigned int)v194 > 0x7FFFFFFE )
                  goto LABEL_506;
                if ( 0x7FFFFFFF - (int)v194 < (unsigned int)v51 )
                  goto LABEL_105;
                goto LABEL_91;
              case 21LL:
LABEL_76:
                v47 = a3->m128i_i32[0];
                if ( a3->m128i_i32[0] > 0x2Fu )
                {
                  v20 = a3->m128i_i64[1];
                  a3->m128i_i64[1] = v20 + 8;
                }
                else
                {
                  v20 = a3[1].m128i_i64[0] + v47;
                  a3->m128i_i32[0] = v47 + 8;
                }
                v48 = *(char **)v20;
                goto LABEL_79;
              case 22LL:
LABEL_176:
                v78 = a3->m128i_i32[0];
                if ( a3->m128i_i32[0] > 0x2Fu )
                {
                  v20 = a3->m128i_i64[1];
                  a3->m128i_i64[1] = v20 + 8;
                }
                else
                {
                  v20 = a3[1].m128i_i64[0] + v78;
                  a3->m128i_i32[0] = v78 + 8;
                }
                v79 = *(_QWORD *)v20;
                if ( *(_QWORD *)v20 )
                {
                  v182 = 0;
                  v22 = 120;
                  v185 = 1;
                  LODWORD(v190) = 16;
                  v189 = v79;
                  v24 = 0;
LABEL_180:
                  if ( (int)v18 < 0 )
                  {
                    v80 = 1LL;
                    goto LABEL_183;
                  }
                  if ( (_DWORD)v18 )
                  {
                    LOBYTE(v191) = 32;
                    v80 = (int)v18;
LABEL_183:
                    v16 = v192;
                    v177 = v21;
                    v178 = v24;
                    v81 = (_BYTE *)itoa_word(v189, v192, v190, v22 == 88);
                    v24 = v178;
                    v82 = (__int64)v81;
                    v21 = v177;
                    if ( v184 )
                    {
                      v16 = v182;
                      if ( v182 )
                      {
                        v16 = (__int64)v81;
                        v178 = v177;
                        v182 = v24;
                        v83 = group_number((unsigned __int64)v183, v81, (_BYTE *)v192, (_BYTE *)v184, (__int64)v180);
                        v21 = v178;
                        v24 = v182;
                        v82 = (__int64)v83;
                      }
                    }
                    if ( (_DWORD)v190 == 10 )
                    {
                      v20 = v181;
                      if ( v181 )
                      {
                        v16 = v192;
                        v182 = v21;
                        LODWORD(v183) = v24;
                        v84 = i18n_number_rewrite(v82, v192, v192);
                        v21 = v182;
                        v24 = (unsigned int)v183;
                        v82 = v84;
                      }
                    }
                    v23 = v192;
                    v18 = v192 - v82;
                    if ( v80 > v192 - v82 )
                    {
                      LODWORD(v80) = v80 - v18;
                      v19 = (unsigned int)v80;
                      if ( !(_DWORD)v193 )
                      {
                        LODWORD(v193) = v192 - v82;
                        v85 = v194 - v18 - v80;
                        if ( v189 )
                        {
                          v86 = v185 & 1;
                          goto LABEL_193;
                        }
                        goto LABEL_196;
                      }
                      goto LABEL_247;
                    }
                    if ( v189 )
                    {
                      v86 = v185 & 1;
                      if ( (_DWORD)v190 == 8 && v86 )
                      {
                        *(_BYTE *)(v82 - 1) = 48;
                        v23 -= --v82;
                        v18 = v23;
                      }
                      v80 -= v18;
                      if ( v80 < 0 )
                        LODWORD(v80) = 0;
                      v20 = (unsigned int)v193;
                      v19 = (unsigned int)v80;
                      if ( !(_DWORD)v193 )
                      {
                        LODWORD(v193) = v18;
                        v20 = (unsigned int)(v194 - v18 - v80);
                        v85 = v194 - v18 - v80;
LABEL_193:
                        if ( (_DWORD)v190 == 16 )
                        {
                          v20 = (unsigned int)(v85 - 2);
                          if ( v86 )
                            v85 -= 2;
                        }
LABEL_196:
                        if ( v24 | v186 | v188 )
                        {
                          --v85;
                          if ( (_BYTE)v191 != 32 )
                            goto LABEL_198;
                          if ( v85 <= 0 )
                          {
                            v85 = 0;
                            goto LABEL_198;
                          }
LABEL_302:
                          v16 = 32LL;
                          v23 = a1;
                          v181 = v21;
                          v182 = v19;
                          LODWORD(v183) = v24;
                          v191 = v82;
                          v192 = v18;
                          v194 = v85;
                          v109 = IO_padn((char *)a1, (char *)0x20, v85, v18, (u32 *)v19, v21);
                          if ( v194 != v109 )
                            goto LABEL_39;
                          v21 = v181;
                          v18 = v192;
                          v82 = v191;
                          v24 = (unsigned int)v183;
                          v19 = v182;
                          if ( v181 > 0x7FFFFFFE )
                            goto LABEL_496;
                          if ( 0x7FFFFFFF - v181 < v85 )
                            goto LABEL_105;
                          v21 = v85 + v181;
                          v85 = 0;
LABEL_198:
                          if ( v24 )
                          {
                            v87 = *(_BYTE **)(a1 + 40);
                            if ( (unsigned __int64)v87 < *(_QWORD *)(a1 + 48) )
                            {
                              v20 = (__int64)(v87 + 1);
                              *(_QWORD *)(a1 + 40) = v87 + 1;
                              *v87 = 45;
                              goto LABEL_201;
                            }
                            v188 = v21;
                            v16 = 45LL;
                            LODWORD(v191) = v19;
                            v192 = v82;
                            v194 = v18;
LABEL_467:
                            v23 = a1;
                            v162 = _overflow(a1, v16, v20, v18, (u32 *)v19, v21);
                            v18 = v194;
                            v82 = v192;
                            v19 = (unsigned int)v191;
                            v21 = v188;
                            if ( v162 == -1 )
                              goto LABEL_39;
                            goto LABEL_201;
                          }
                          if ( v188 )
                          {
                            v112 = *(_BYTE **)(a1 + 40);
                            if ( (unsigned __int64)v112 >= *(_QWORD *)(a1 + 48) )
                            {
                              v188 = v21;
                              v16 = 43LL;
                              LODWORD(v191) = v19;
                              v192 = v82;
                              v194 = v18;
                              goto LABEL_467;
                            }
                            v20 = (__int64)(v112 + 1);
                            *(_QWORD *)(a1 + 40) = v112 + 1;
                            *v112 = 43;
LABEL_201:
                            if ( (_DWORD)v21 == 0x7FFFFFFF )
                              goto LABEL_39;
                            v21 = (unsigned int)(v21 + 1);
                          }
                          else if ( v186 )
                          {
                            v141 = *(_BYTE **)(a1 + 40);
                            if ( (unsigned __int64)v141 >= *(_QWORD *)(a1 + 48) )
                            {
                              v188 = v21;
                              v16 = 32LL;
                              LODWORD(v191) = v19;
                              v192 = v82;
                              v194 = v18;
                              goto LABEL_467;
                            }
                            v20 = (__int64)(v141 + 1);
                            *(_QWORD *)(a1 + 40) = v141 + 1;
                            *v141 = 32;
                            goto LABEL_201;
                          }
                        }
                        else if ( (_BYTE)v191 == 32 )
                        {
                          if ( v85 > 0 )
                            goto LABEL_302;
                          v85 = 0;
                        }
                        if ( v189 && (_DWORD)v190 == 16 && v185 )
                        {
                          v88 = *(_BYTE **)(a1 + 40);
                          if ( (unsigned __int64)v88 >= *(_QWORD *)(a1 + 48) )
                          {
                            v16 = 48LL;
                            v23 = a1;
                            LODWORD(v190) = v21;
                            LODWORD(v191) = v19;
                            v192 = v82;
                            v194 = v18;
                            v170 = _overflow(a1, 48LL, v20, v18, (u32 *)v19, v21);
                            v18 = v194;
                            v82 = v192;
                            v19 = (unsigned int)v191;
                            v21 = (unsigned int)v190;
                            if ( v170 == -1 )
                              goto LABEL_39;
                          }
                          else
                          {
                            v20 = (__int64)(v88 + 1);
                            *(_QWORD *)(a1 + 40) = v88 + 1;
                            *v88 = 48;
                          }
                          if ( (_DWORD)v21 == 0x7FFFFFFF )
                            goto LABEL_39;
                          v89 = *(char **)(a1 + 40);
                          if ( (unsigned __int64)v89 >= *(_QWORD *)(a1 + 48) )
                          {
                            v16 = (unsigned __int8)v22;
                            v23 = a1;
                            LODWORD(v190) = v21;
                            LODWORD(v191) = v19;
                            v192 = v82;
                            v194 = v18;
                            v169 = _overflow(a1, (unsigned __int8)v22, v20, v18, (u32 *)v19, v21);
                            v18 = v194;
                            v82 = v192;
                            v19 = (unsigned int)v191;
                            v21 = (unsigned int)v190;
                            if ( v169 == -1 )
                              goto LABEL_39;
                          }
                          else
                          {
                            v20 = (__int64)(v89 + 1);
                            *(_QWORD *)(a1 + 40) = v89 + 1;
                            *v89 = v22;
                          }
                          if ( (_DWORD)v21 == 2147483646 )
                            goto LABEL_39;
                          v21 = (unsigned int)(v21 + 2);
                        }
                        v90 = v19 + v85;
                        if ( v90 > 0 )
                        {
                          v16 = 48LL;
                          v23 = a1;
                          LODWORD(v191) = v21;
                          v192 = v82;
                          v194 = v18;
                          if ( v90 != IO_padn((char *)a1, (char *)0x30, v90, v18, (u32 *)v19, v21) )
                            goto LABEL_39;
                          v21 = (unsigned int)v191;
                          if ( (unsigned int)v191 > 0x7FFFFFFE )
LABEL_496:
                            _assert_fail(
                              (__int64)"(unsigned int) done < (unsigned int) INT_MAX",
                              (__int64)"vfprintf.c",
                              0x665u,
                              "_IO_vfprintf_internal");
                          v18 = v194;
                          v82 = v192;
                          if ( 0x7FFFFFFF - (int)v191 < (unsigned int)v90 )
                            goto LABEL_105;
                          v21 = (unsigned int)(v90 + v191);
                        }
                        if ( (v21 & 0x80000000) != 0LL )
                          goto LABEL_502;
                        v91 = *(_QWORD *)(a1 + 216);
                        if ( v196 <= v91 - (__int64)_start___libc_IO_vtables )
                        {
                          LODWORD(v191) = v21;
                          v192 = v82;
                          v194 = v18;
                          IO_vtable_check(v23, v16, v20, v18, (u32 *)v19, v21);
                          LODWORD(v21) = v191;
                          v82 = v192;
                          v18 = v194;
                        }
                        v194 = v18;
                        v16 = v82;
                        LODWORD(v192) = v21;
                        v92 = (*(__int64 (__fastcall **)(__int64, __int64, __int64))(v91 + 56))(a1, v82, v18);
                        v18 = v194;
                        if ( v194 != v92 )
                          goto LABEL_39;
                        v21 = (unsigned int)v192;
                        if ( 0x7FFFFFFF - (int)v192 < v194 )
                          goto LABEL_105;
                        v21 = (unsigned int)(v193 + v192);
                        goto LABEL_67;
                      }
LABEL_247:
                      if ( v24 )
                      {
                        v101 = *(_BYTE **)(a1 + 40);
                        if ( (unsigned __int64)v101 < *(_QWORD *)(a1 + 48) )
                        {
                          v20 = (__int64)(v101 + 1);
                          *(_QWORD *)(a1 + 40) = v101 + 1;
                          *v101 = 45;
                          goto LABEL_250;
                        }
                        v188 = v21;
                        v16 = 45LL;
                        LODWORD(v191) = v19;
                        v192 = v82;
                        v193 = v18;
LABEL_464:
                        v23 = a1;
                        v161 = _overflow(a1, v16, v20, v18, (u32 *)v19, v21);
                        v18 = v193;
                        v82 = v192;
                        v19 = (unsigned int)v191;
                        v21 = v188;
                        if ( v161 == -1 )
                          goto LABEL_39;
                        goto LABEL_250;
                      }
                      if ( v188 )
                      {
                        v110 = *(_BYTE **)(a1 + 40);
                        if ( (unsigned __int64)v110 >= *(_QWORD *)(a1 + 48) )
                        {
                          v188 = v21;
                          v16 = 43LL;
                          LODWORD(v191) = v19;
                          v192 = v82;
                          v193 = v18;
                          goto LABEL_464;
                        }
                        v20 = (__int64)(v110 + 1);
                        *(_QWORD *)(a1 + 40) = v110 + 1;
                        *v110 = 43;
LABEL_250:
                        if ( (_DWORD)v21 == 0x7FFFFFFF )
                          goto LABEL_39;
                        LODWORD(v194) = v194 - 1;
                        v21 = (unsigned int)(v21 + 1);
                      }
                      else if ( v186 )
                      {
                        v114 = *(_BYTE **)(a1 + 40);
                        if ( (unsigned __int64)v114 >= *(_QWORD *)(a1 + 48) )
                        {
                          v188 = v21;
                          v16 = 32LL;
                          LODWORD(v191) = v19;
                          v192 = v82;
                          v193 = v18;
                          goto LABEL_464;
                        }
                        v20 = (__int64)(v114 + 1);
                        *(_QWORD *)(a1 + 40) = v114 + 1;
                        *v114 = 32;
                        goto LABEL_250;
                      }
                      if ( v189 && (_DWORD)v190 == 16 && v185 )
                      {
                        v102 = *(_BYTE **)(a1 + 40);
                        if ( (unsigned __int64)v102 >= *(_QWORD *)(a1 + 48) )
                        {
                          v16 = 48LL;
                          v23 = a1;
                          LODWORD(v190) = v21;
                          LODWORD(v191) = v19;
                          v192 = v82;
                          v193 = v18;
                          v167 = _overflow(a1, 48LL, v20, v18, (u32 *)v19, v21);
                          v18 = v193;
                          v82 = v192;
                          v19 = (unsigned int)v191;
                          v21 = (unsigned int)v190;
                          if ( v167 == -1 )
                            goto LABEL_39;
                        }
                        else
                        {
                          v20 = (__int64)(v102 + 1);
                          *(_QWORD *)(a1 + 40) = v102 + 1;
                          *v102 = 48;
                        }
                        if ( (_DWORD)v21 == 0x7FFFFFFF )
                          goto LABEL_39;
                        v103 = *(char **)(a1 + 40);
                        if ( (unsigned __int64)v103 >= *(_QWORD *)(a1 + 48) )
                        {
                          v16 = (unsigned __int8)v22;
                          v23 = a1;
                          LODWORD(v190) = v21;
                          LODWORD(v191) = v19;
                          v192 = v82;
                          v193 = v18;
                          v168 = _overflow(a1, (unsigned __int8)v22, v20, v18, (u32 *)v19, v21);
                          v18 = v193;
                          v82 = v192;
                          v19 = (unsigned int)v191;
                          v21 = (unsigned int)v190;
                          if ( v168 == -1 )
                            goto LABEL_39;
                        }
                        else
                        {
                          v20 = (__int64)(v103 + 1);
                          *(_QWORD *)(a1 + 40) = v103 + 1;
                          *v103 = v22;
                        }
                        if ( (_DWORD)v21 == 2147483646 )
                          goto LABEL_39;
                        LODWORD(v194) = v194 - 2;
                        v21 = (unsigned int)(v21 + 2);
                      }
                      v104 = v18;
                      v51 = v194 - (v18 + v80);
                      if ( (int)v19 > 0 )
                      {
                        v16 = 48LL;
                        v23 = a1;
                        LODWORD(v190) = v21;
                        v194 = (int)v19;
                        v191 = v82;
                        v192 = v18;
                        LODWORD(v193) = v19;
                        v111 = IO_padn((char *)a1, (char *)0x30, v19, v18, (u32 *)v19, v21);
                        if ( v194 != v111 )
                          goto LABEL_39;
                        v21 = (unsigned int)v190;
                        if ( (unsigned int)v190 > 0x7FFFFFFE )
                          goto LABEL_496;
                        v19 = (unsigned int)v193;
                        v18 = v192;
                        v82 = v191;
                        if ( 0x7FFFFFFF - (int)v190 < (unsigned int)v193 )
                          goto LABEL_105;
                        v21 = (unsigned int)(v193 + v190);
                      }
                      if ( (v21 & 0x80000000) != 0LL )
LABEL_502:
                        _assert_fail(
                          (__int64)"(size_t) done <= (size_t) INT_MAX",
                          (__int64)"vfprintf.c",
                          0x665u,
                          "_IO_vfprintf_internal");
                      v105 = *(_QWORD *)(a1 + 216);
                      if ( v196 <= v105 - (__int64)_start___libc_IO_vtables )
                      {
                        LODWORD(v191) = v21;
                        v192 = v82;
                        v193 = v105;
                        v194 = v18;
                        IO_vtable_check(v23, v16, v105 - (_QWORD)_start___libc_IO_vtables, v18, (u32 *)v19, v21);
                        LODWORD(v21) = v191;
                        v82 = v192;
                        v105 = v193;
                        v18 = v194;
                      }
                      v194 = v18;
                      v16 = v82;
                      LODWORD(v193) = v21;
                      v106 = (*(__int64 (__fastcall **)(__int64, __int64, __int64))(v105 + 56))(a1, v82, v18);
                      v18 = v194;
                      if ( v194 != v106 )
                        goto LABEL_39;
                      v19 = 0x7FFFFFFFLL;
                      v21 = (unsigned int)v193;
                      if ( 0x7FFFFFFF - (int)v193 < v194 )
                        goto LABEL_105;
                      v21 = (unsigned int)(v104 + v193);
                      if ( v51 > 0 )
                      {
                        v16 = 32LL;
                        LODWORD(v194) = v104 + v193;
                        if ( v51 != IO_padn((char *)a1, (char *)0x20, v51, v18, (u32 *)0x7FFFFFFF, v21) )
                          goto LABEL_39;
                        v21 = (unsigned int)v194;
                        if ( (unsigned int)v194 > 0x7FFFFFFE )
                          goto LABEL_496;
                        v19 = (unsigned int)(0x7FFFFFFF - v194);
                        if ( (unsigned int)v19 < v51 )
                          goto LABEL_105;
                        goto LABEL_91;
                      }
                      goto LABEL_67;
                    }
                  }
                  else
                  {
                    if ( v189 )
                    {
                      v80 = 0LL;
                      LOBYTE(v191) = 32;
                      goto LABEL_183;
                    }
                    if ( (_DWORD)v190 == 8 && (v23 = v185) != 0 )
                    {
                      v100 = v192;
                      LOBYTE(v191) = 32;
                      v18 = 1LL;
                      *(_BYTE *)(v192 - 1) = 48;
                      v82 = v100 - 1;
                    }
                    else
                    {
                      v82 = v192;
                      v18 = 0LL;
                      LOBYTE(v191) = 32;
                    }
                  }
                  if ( !(_DWORD)v193 )
                  {
                    LODWORD(v193) = v18;
                    v19 = 0LL;
                    v85 = v194 - v18;
                    goto LABEL_196;
                  }
                  v19 = 0LL;
                  LODWORD(v80) = 0;
                  goto LABEL_247;
                }
                v48 = "(nil)";
                if ( (int)v18 < 5 )
                  LODWORD(v18) = 5;
                if ( v22 == 83 )
                {
                  v209 = 0LL;
                  v204 = "(nil)";
                  goto LABEL_352;
                }
LABEL_83:
                v16 = (int)v18;
                v23 = (__int64)v48;
                LODWORD(v190) = v21;
                v192 = (signed __int64)v48;
                v49 = j_strnlen(v48, (int)v18);
LABEL_84:
                LODWORD(v191) = 0;
                v19 = v192;
                v50 = v49;
                v51 = v49;
                v21 = (unsigned int)v190;
LABEL_85:
                LODWORD(v194) = v194 - v51;
                if ( (int)v194 >= 0 )
                {
LABEL_288:
                  LOBYTE(v192) = (_DWORD)v194 != 0;
                  if ( !(_DWORD)v193 && (_DWORD)v194 )
                  {
                    v16 = 32LL;
                    v23 = a1;
                    v188 = v21;
                    v189 = v19;
                    v190 = (int)v194;
                    v142 = (_QWORD *)IO_padn((char *)a1, (char *)0x20, v194, v18, (u32 *)v19, v21);
                    if ( (_QWORD *)v190 != v142 )
                      goto LABEL_39;
                    v21 = v188;
                    if ( v188 > 0x7FFFFFFE )
                      goto LABEL_506;
                    v19 = v189;
                    if ( 0x7FFFFFFF - v188 < (unsigned int)v194 )
                      goto LABEL_105;
                    v21 = (unsigned int)v194 + v188;
                  }
                  if ( (v21 & 0x80000000) != 0LL )
LABEL_507:
                    _assert_fail(
                      (__int64)"(size_t) done <= (size_t) INT_MAX",
                      (__int64)"vfprintf.c",
                      0x666u,
                      "_IO_vfprintf_internal");
                  v108 = *(_QWORD *)(a1 + 216);
                  if ( v196 <= v108 - (unsigned __int64)_start___libc_IO_vtables )
                  {
                    v188 = v21;
                    v189 = v108;
                    v190 = v19;
                    IO_vtable_check(v23, v16, v108 - (_QWORD)_start___libc_IO_vtables, v18, (u32 *)v19, v21);
                    LODWORD(v21) = v188;
                    v108 = v189;
                    v19 = v190;
                  }
                  LODWORD(v189) = v21;
                  v16 = v19;
                  v190 = v19;
                  if ( (*(__int64 (__fastcall **)(__int64, __int64, unsigned __int64))(v108 + 56))(a1, v19, v50) != v50 )
                    goto LABEL_39;
                  v21 = (unsigned int)v189;
                  v19 = v190;
                  if ( 0x7FFFFFFF - (int)v189 < v50 )
                    goto LABEL_105;
                  v21 = (unsigned int)(v51 + v189);
                  if ( (_DWORD)v193 && (_BYTE)v192 )
                  {
                    v144 = (int)v194;
                    v16 = 32LL;
                    LODWORD(v192) = v21;
                    v193 = v190;
                    if ( v144 != IO_padn((char *)a1, (char *)0x20, v194, v18, (u32 *)v190, v21) )
                      goto LABEL_39;
                    v21 = (unsigned int)v192;
                    if ( (unsigned int)v192 > 0x7FFFFFFE )
LABEL_506:
                      _assert_fail(
                        (__int64)"(unsigned int) done < (unsigned int) INT_MAX",
                        (__int64)"vfprintf.c",
                        0x666u,
                        "_IO_vfprintf_internal");
                    v19 = v193;
                    if ( 0x7FFFFFFF - (int)v192 < (unsigned int)v144 )
                    {
LABEL_105:
                      __writefsdword(0xFFFFFFC0, 0x4Bu);
                      goto LABEL_39;
                    }
                    v21 = (unsigned int)(v194 + v192);
                  }
                  v16 = (unsigned int)v191;
                  if ( (_DWORD)v191 )
                  {
                    LODWORD(v194) = v21;
                    free(v19, (unsigned int)v191, v20, v18, (u32 *)v19, v21);
                    v21 = (unsigned int)v194;
                  }
                }
                else
                {
                  if ( (v21 & 0x80000000) != 0LL )
                    goto LABEL_507;
                  v52 = *(_QWORD *)(a1 + 216);
                  if ( v196 <= v52 - (__int64)_start___libc_IO_vtables )
                  {
                    LODWORD(v192) = v21;
                    v193 = v52;
                    v194 = v19;
                    IO_vtable_check(v23, v16, v20, v52, (u32 *)v19, v21);
                    LODWORD(v21) = v192;
                    v52 = v193;
                    v19 = v194;
                  }
                  LODWORD(v194) = v21;
                  v16 = v19;
                  if ( v50 != (*(__int64 (__fastcall **)(__int64, __int64, unsigned __int64))(v52 + 56))(a1, v19, v50) )
                    goto LABEL_39;
                  v21 = (unsigned int)v194;
                  if ( v50 > 0x7FFFFFFF - (int)v194 )
                    goto LABEL_105;
LABEL_91:
                  v21 = (unsigned int)(v51 + v21);
                }
LABEL_67:
                ++v187;
                if ( v195 )
                {
                  LODWORD(v194) = v21;
                  free((__int64)v195, v16, v20, v18, (u32 *)v19, v21);
                  LODWORD(v21) = v194;
                }
                LODWORD(v195) = v21;
                v39 = (__int64)++v200;
                v40 = (__int64)v200;
                v41 = (char *)j_strchrnul(v200, 37LL);
                v44 = (int)v195;
                v200 = v41;
                if ( (int)v195 < 0 )
                  _assert_fail(
                    (__int64)"(size_t) done <= (size_t) INT_MAX",
                    (__int64)"vfprintf.c",
                    0x685u,
                    "_IO_vfprintf_internal");
                v45 = *(_QWORD *)(a1 + 216);
                if ( v196 <= v45 - (__int64)_start___libc_IO_vtables )
                {
                  IO_vtable_check(v40, 37LL, v45 - (_QWORD)_start___libc_IO_vtables, v42, v43, (unsigned int)v195);
                  v41 = v200;
                  v44 = (int)v195;
                }
                LODWORD(v195) = v44;
                v16 = v39;
                v46 = (*(__int64 (__fastcall **)(__int64, __int64, char *))(v45 + 56))(a1, v39, &v41[-v39]);
                v20 = (__int64)v200;
                v18 = (__int64)&v200[-v39];
                if ( &v200[-v39] != (char *)v46 )
                  goto LABEL_41;
                if ( v18 > 0x7FFFFFFF - (int)v195 )
                  goto LABEL_50;
                v21 = (unsigned int)(v18 + (_DWORD)v195);
                if ( !*v200 )
                  goto LABEL_31;
                continue;
              case 23LL:
LABEL_170:
                if ( (*(_BYTE *)(a1 + 116) & 4) != 0 && !v179 )
                {
                  LODWORD(v192) = v21;
                  LODWORD(v193) = v24;
                  LODWORD(v194) = v19;
                  v16 = j_strlen_ifunc(a2) + 1;
                  v150 = _readonly_area(a2, v16, v146, v147, v148, v149);
                  v19 = (unsigned int)v194;
                  v24 = v193;
                  v179 = v150;
                  v21 = (unsigned int)v192;
                  if ( v150 < 0 )
                    _libc_fatal(
                      (__int64)"*** %n in writable segment detected ***\n",
                      v16,
                      v151,
                      v18,
                      (u32 *)(unsigned int)v194,
                      (unsigned int)v192);
                }
                v75 = a3->m128i_i32[0];
                if ( v24 )
                {
                  if ( v75 > 0x2F )
                  {
                    v76 = (_QWORD **)a3->m128i_i64[1];
                    a3->m128i_i64[1] = (__int64)(v76 + 1);
                  }
                  else
                  {
                    v76 = (_QWORD **)(a3[1].m128i_i64[0] + v75);
                    a3->m128i_i32[0] = v75 + 8;
                  }
                  v77 = *v76;
                  v20 = (int)v21;
                  *v77 = (int)v21;
                }
                else if ( (_DWORD)v19 )
                {
                  if ( v75 > 0x2F )
                  {
                    v20 = a3->m128i_i64[1];
                    a3->m128i_i64[1] = v20 + 8;
                  }
                  else
                  {
                    v20 = a3[1].m128i_i64[0] + v75;
                    a3->m128i_i32[0] = v75 + 8;
                  }
                  **(_BYTE **)v20 = v21;
                }
                else if ( v25 )
                {
                  if ( v75 > 0x2F )
                  {
                    v20 = a3->m128i_i64[1];
                    a3->m128i_i64[1] = v20 + 8;
                  }
                  else
                  {
                    v20 = a3[1].m128i_i64[0] + v75;
                    a3->m128i_i32[0] = v75 + 8;
                  }
                  **(_WORD **)v20 = v21;
                }
                else
                {
                  if ( v75 > 0x2F )
                  {
                    v20 = a3->m128i_i64[1];
                    a3->m128i_i64[1] = v20 + 8;
                  }
                  else
                  {
                    v20 = a3[1].m128i_i64[0] + v75;
                    a3->m128i_i32[0] = v75 + 8;
                  }
                  **(_DWORD **)v20 = v21;
                }
                goto LABEL_67;
              case 24LL:
LABEL_106:
                v16 = (__int64)v183;
                v23 = v198;
                LODWORD(v191) = v21;
                LODWORD(v192) = v18;
                v57 = strerror_r(v198, (__int64)v183, 0x3E8uLL);
                v24 = 0;
                v18 = (unsigned int)v192;
                v21 = (unsigned int)v191;
                v48 = (char *)v57;
LABEL_79:
                if ( !v48 )
                {
                  LODWORD(v191) = 0;
                  if ( (_DWORD)v18 != -1 && (int)v18 <= 5 )
                  {
                    v51 = 0;
                    v19 = (__int64)byte_493255;
                    v50 = 0LL;
                    goto LABEL_288;
                  }
                  v51 = 6;
                  v50 = 6LL;
                  v19 = (__int64)"(null)";
                  goto LABEL_85;
                }
                if ( v24 || v22 == 83 )
                {
                  v204 = v48;
                  v209 = 0LL;
                  if ( (int)v18 < 0 )
                  {
                    v16 = (__int64)&v204;
                    LODWORD(v189) = v21;
                    v190 = (unsigned __int64)v48;
                    v192 = (signed __int64)&v204;
                    v50 = wcsrtombs(0LL, &v204, 0LL, &v209, (u32 *)v48, v21);
                    if ( v50 == -1LL )
                      goto LABEL_39;
                    v152 = (const char *)v190;
                    LODWORD(v191) = v209;
                    if ( (_DWORD)v209 )
                      _assert_fail(
                        (__int64)"__mbsinit (&mbstate)",
                        (__int64)"vfprintf.c",
                        0x666u,
                        "_IO_vfprintf_internal");
                    v190 = v50 + 1;
                    v204 = v152;
                    v153 = _libc_alloca_cutoff(v50 + 1);
                    v156 = (_QWORD *)v190;
                    v157 = (unsigned int)v189;
                    if ( v190 <= 0x1000 || v153 )
                    {
                      v158 = (unsigned int *)((char *)&v176 - ((v190 + 23) & 0xFFFFFFFFFFFFF000LL));
                      if ( &v176 != v158 )
                      {
                        while ( &v174 != (__int64 *)v158 )
                          ;
                      }
                      if ( (((_WORD)v190 + 23) & 0xFF0) != 0 )
                      {
                        v159 = alloca(((_WORD)v190 + 23) & 0xFF0);
                        *(__int64 *)((char *)&v173 + (((_WORD)v190 + 23) & 0xFF0)) = *(__int64 *)((char *)&v173
                                                                                                + (((_WORD)v190 + 23) & 0xFF0));
                      }
                      v19 = (__int64)v175;
                    }
                    else
                    {
                      v19 = (__int64)malloc(v190, (__int64)&v204, (_QWORD *)v190, v154, v155, (unsigned int)v189);
                      if ( !v19 )
                        goto LABEL_39;
                      v156 = (_QWORD *)v190;
                      v157 = (unsigned int)v189;
                      LODWORD(v191) = 1;
                    }
                    v16 = v192;
                    v23 = v19;
                    LODWORD(v190) = v157;
                    v192 = v19;
                    wcsrtombs(v19, (_QWORD *)v16, (__int64)v156, &v209, (u32 *)v19, v157);
                    v21 = (unsigned int)v190;
                    v19 = v192;
                  }
                  else
                  {
LABEL_352:
                    v119 = (int)v18;
                    LODWORD(v192) = v21;
                    LODWORD(v191) = v18;
                    v120 = _libc_alloca_cutoff((int)v18);
                    v123 = (unsigned int)v192;
                    if ( v120 || (int)v191 <= 4096 )
                    {
                      v124 = (unsigned int *)((char *)&v176 - ((v119 + 23) & 0xFFFFFFFFFFFFF000LL));
                      if ( &v176 != v124 )
                      {
                        while ( &v174 != (__int64 *)v124 )
                          ;
                      }
                      if ( (((_WORD)v119 + 23) & 0xFF0) != 0 )
                      {
                        v125 = alloca(((_WORD)v119 + 23) & 0xFF0);
                        *(__int64 *)((char *)&v173 + (((_WORD)v119 + 23) & 0xFF0)) = *(__int64 *)((char *)&v173
                                                                                                + (((_WORD)v119 + 23) & 0xFF0));
                      }
                      LODWORD(v191) = 0;
                      v19 = (__int64)v175;
                    }
                    else
                    {
                      v19 = (__int64)malloc(v119, v16, v121, (unsigned int)v191, v122, (unsigned int)v192);
                      if ( !v19 )
                        goto LABEL_39;
                      LODWORD(v191) = 1;
                      v123 = (unsigned int)v192;
                    }
                    v23 = v19;
                    v16 = (__int64)&v204;
                    LODWORD(v190) = v123;
                    v192 = v19;
                    v126 = wcsrtombs(v19, &v204, v119, &v209, (u32 *)v19, v123);
                    v19 = v192;
                    v21 = (unsigned int)v190;
                    v50 = v126;
                    if ( v126 == -1 )
                      goto LABEL_39;
                  }
                  v51 = v50;
                  goto LABEL_85;
                }
                if ( (_DWORD)v18 != -1 )
                  goto LABEL_83;
                v23 = (__int64)v48;
                LODWORD(v190) = v21;
                v192 = (signed __int64)v48;
                v49 = j_strlen_ifunc(v48);
                goto LABEL_84;
              case 25LL:
LABEL_55:
                v31 = a3->m128i_i32[0];
                v209 = 0LL;
                if ( v31 > 0x2F )
                {
                  v32 = (unsigned int *)a3->m128i_i64[1];
                  a3->m128i_i64[1] = (__int64)(v32 + 2);
                }
                else
                {
                  v32 = (unsigned int *)(a3[1].m128i_i64[0] + v31);
                  a3->m128i_i32[0] = v31 + 8;
                }
                v16 = *v32;
                LODWORD(v191) = v21;
                v33 = v212;
                v192 = (signed __int64)v212;
                v34 = wcrtomb(v212, v16, &v209, (__int64)v212, (u32 *)v19, v21);
                v35 = v34;
                if ( v34 == -1 )
                  goto LABEL_39;
                v18 = v192;
                v36 = (unsigned int)v191;
                v37 = v194 - v34;
                LOBYTE(v194) = (int)v194 - (int)v34 > 0;
                if ( (_DWORD)v193 || !(_BYTE)v194 )
                  goto LABEL_60;
                v16 = 32LL;
                v33 = (char *)a1;
                v190 = v192;
                v192 = (int)v37;
                v143 = (_BYTE *)IO_padn((char *)a1, (char *)0x20, v37, v18, (u32 *)v19, (unsigned int)v191);
                if ( (_BYTE *)v192 != v143 )
                  goto LABEL_39;
                v21 = (unsigned int)v191;
                if ( (unsigned int)v191 > 0x7FFFFFFE )
                  goto LABEL_506;
                v18 = v190;
                if ( 0x7FFFFFFF - (int)v191 < v37 )
                  goto LABEL_105;
                v36 = v37 + (unsigned int)v191;
LABEL_60:
                if ( (int)v36 < 0 )
                  goto LABEL_507;
                v38 = *(__int64 (__fastcall ***)(__int64, __int64, unsigned __int64))(a1 + 216);
                if ( v196 <= (char *)v38 - (char *)_start___libc_IO_vtables )
                {
                  v190 = v18;
                  LODWORD(v191) = v36;
                  v192 = (signed __int64)v38;
                  IO_vtable_check(
                    (__int64)v33,
                    v16,
                    (char *)v38 - (char *)_start___libc_IO_vtables,
                    v18,
                    (u32 *)v19,
                    v36);
                  v18 = v190;
                  LODWORD(v36) = v191;
                  v38 = (__int64 (__fastcall **)(__int64, __int64, unsigned __int64))v192;
                }
                LODWORD(v192) = v36;
                v16 = v18;
                if ( v35 != v38[7](a1, v18, v35) )
                  goto LABEL_39;
                v18 = 0x7FFFFFFFLL;
                v21 = (unsigned int)v192;
                if ( 0x7FFFFFFF - (int)v192 < v35 )
                  goto LABEL_105;
                v21 = (unsigned int)(v35 + v192);
                if ( !(_DWORD)v193 || !(_BYTE)v194 )
                  goto LABEL_67;
                v16 = 32LL;
                LODWORD(v194) = v35 + v192;
                if ( v37 != IO_padn((char *)a1, (char *)0x20, v37, 0x7FFFFFFFLL, (u32 *)v19, v21) )
                  goto LABEL_39;
                v21 = (unsigned int)v194;
                if ( (unsigned int)v194 > 0x7FFFFFFE )
                  goto LABEL_506;
                v18 = (unsigned int)(0x7FFFFFFF - v194);
                if ( (unsigned int)v18 < v37 )
                  goto LABEL_105;
                v21 = v37 + (unsigned int)v194;
                goto LABEL_67;
              case 26LL:
LABEL_164:
                v204 = (const char *)__PAIR64__(v194, v18);
                v205 = v22;
                v72 = (unsigned __int8)v182 << 7;
                v206 = (unsigned __int8)(((_BYTE)v182 << 7) | ((_BYTE)v188 << 6) | (32 * v193) | (16 * v186) | (8 * v185) | (4 * v24) | v20);
                v207 = (unsigned __int8)v191;
                if ( (_DWORD)v20 )
                {
                  v73 = (LONG_DOUBLE_16 *)((a3->m128i_i64[1] + 15) & 0xFFFFFFFFFFFFFFF0LL);
                  a3->m128i_i64[1] = (__int64)&v73[1];
                  v203 = *v73;
                }
                else
                {
                  v117 = a3->m128i_u32[1];
                  if ( v117 > 0xAF )
                  {
                    v118 = (_QWORD *)a3->m128i_i64[1];
                    a3->m128i_i64[1] = (__int64)(v118 + 1);
                  }
                  else
                  {
                    v118 = (_QWORD *)(a3[1].m128i_i64[0] + v117);
                    a3->m128i_i32[1] = v117 + 16;
                  }
                  *(_QWORD *)&v203.value = *v118;
                }
                v16 = (__int64)&v204;
                LODWORD(v194) = v21;
                v202 = &v203;
                v74 = _printf_fphex(a1, (__int64)&v204, (const __m128i **)&v202, v72, v19, v21);
                if ( v74 < 0 )
                  goto LABEL_39;
LABEL_167:
                v21 = (unsigned int)v194;
                if ( (unsigned int)v194 > 0x7FFFFFFE )
                  goto LABEL_496;
                v20 = (unsigned int)(0x7FFFFFFF - v194);
                if ( (unsigned int)v20 < v74 )
                  goto LABEL_105;
                v21 = (unsigned int)(v74 + v194);
                goto LABEL_67;
              case 29LL:
LABEL_147:
                while ( 2 )
                {
                  v181 = 1;
                  v22 = *++v200;
                  if ( (unsigned __int8)(*v200 - 32) <= 0x5Au )
                  {
LABEL_148:
                    v23 = (__int64)jump_table;
                    switch ( v22 )
                    {
                      case ' ':
                        goto LABEL_153;
                      case '!':
                      case '"':
                      case '$':
                      case '&':
                      case '(':
                      case ')':
                      case ',':
                      case '/':
                      case ':':
                      case ';':
                      case '<':
                      case '=':
                      case '>':
                      case '?':
                      case '@':
                      case 'B':
                      case 'D':
                      case 'H':
                      case 'J':
                      case 'K':
                      case 'M':
                      case 'N':
                      case 'O':
                      case 'P':
                      case 'Q':
                      case 'R':
                      case 'T':
                      case 'U':
                      case 'V':
                      case 'W':
                      case 'Y':
                      case '[':
                      case '\\':
                      case ']':
                      case '^':
                      case '_':
                      case '`':
                      case 'b':
                      case 'k':
                      case 'r':
                      case 'v':
                      case 'w':
                      case 'y':
                        goto LABEL_37;
                      case '#':
                        goto LABEL_159;
                      case '%':
                        goto LABEL_225;
                      case '\'':
                        goto LABEL_161;
                      case '*':
                        goto LABEL_131;
                      case '+':
                        goto LABEL_151;
                      case '-':
                        goto LABEL_149;
                      case '.':
                        goto LABEL_115;
                      case '0':
                        goto LABEL_155;
                      case '1':
                      case '2':
                      case '3':
                      case '4':
                      case '5':
                      case '6':
                      case '7':
                      case '8':
                      case '9':
                        goto LABEL_119;
                      case 'A':
                      case 'a':
                        goto LABEL_164;
                      case 'C':
                        goto LABEL_55;
                      case 'E':
                      case 'F':
                      case 'G':
                      case 'e':
                      case 'f':
                      case 'g':
                        goto LABEL_231;
                      case 'I':
                        continue;
                      case 'L':
                      case 'q':
                        goto LABEL_107;
                      case 'S':
                      case 's':
                        goto LABEL_76;
                      case 'X':
                      case 'x':
                        goto LABEL_229;
                      case 'Z':
                      case 'j':
                      case 't':
                      case 'z':
                        goto LABEL_36;
                      case 'c':
                        goto LABEL_92;
                      case 'd':
                      case 'i':
                        goto LABEL_235;
                      case 'h':
                        goto LABEL_113;
                      case 'l':
                        goto LABEL_109;
                      case 'm':
                        goto LABEL_106;
                      case 'n':
                        goto LABEL_170;
                      case 'o':
                        goto LABEL_230;
                      case 'p':
                        goto LABEL_176;
                      case 'u':
                        goto LABEL_220;
                    }
                  }
                  goto LABEL_37;
                }
            }
            goto LABEL_50;
          }
          break;
        }
        v195 = 0LL;
LABEL_37:
        if ( !v22 )
        {
          __writefsdword(0xFFFFFFC0, 0x16u);
LABEL_39:
          if ( v195 )
            free((__int64)v195, v16, v20, v18, (u32 *)v19, v21);
          goto LABEL_41;
        }
        v183 = v213;
LABEL_53:
        v8 = v187;
        if ( v195 )
        {
          LODWORD(v196) = v21;
          free((__int64)v195, v16, v20, v18, (u32 *)v19, v21);
          v21 = (unsigned int)v196;
        }
      }
    }
    v16 = a2;
    LODWORD(v21) = printf_positional(
                     (char *)a1,
                     a2,
                     v179,
                     (__int64)a3,
                     (u32 *)&v210,
                     v21,
                     v8,
                     v197,
                     (__int64)v183,
                     v198,
                     (char *)v184,
                     (__int64)v180);
  }
LABEL_31:
  if ( (*(_DWORD *)a1 & 0x8000) == 0 )
  {
    v29 = *(_QWORD *)(a1 + 136);
    v28 = (*(_DWORD *)(v29 + 4))-- == 1;
    if ( v28 )
    {
      *(_QWORD *)(v29 + 8) = 0LL;
      if ( _libc_multiple_threads )
      {
        if ( !_InterlockedDecrement((volatile signed __int32 *)v29) )
          goto LABEL_33;
      }
      else
      {
        v28 = (*(_DWORD *)v29)-- == 1;
        if ( v28 )
          goto LABEL_33;
      }
      _lll_unlock_wake_private((u32 *)v29, v16, v29, v18, (u32 *)v19, v21);
    }
  }
LABEL_33:
  if ( v199 )
  {
    v199 = v21;
    MEMORY[0](v208, 0LL);
    LODWORD(v21) = v199;
  }
  return (unsigned int)v21;
}
// 450DC7: variable 'v13' is possibly undefined
// 450DC7: variable 'v14' is possibly undefined
// 450BAF: variable 'v12' is possibly undefined
// 450D19: variable 'v21' is possibly undefined
// 450CF1: variable 'v20' is possibly undefined
// 450CF1: variable 'v18' is possibly undefined
// 450CF1: variable 'v19' is possibly undefined
// 452497: variable 'v42' is possibly undefined
// 452497: variable 'v43' is possibly undefined
// 45302D: variable 'v146' is possibly undefined
// 45302D: variable 'v147' is possibly undefined
// 45302D: variable 'v148' is possibly undefined
// 45302D: variable 'v149' is possibly undefined
// 45305C: variable 'v151' is possibly undefined
// 453837: variable 'v121' is possibly undefined
// 453837: variable 'v122' is possibly undefined
// 453950: variable 'v154' is possibly undefined
// 453950: variable 'v155' is possibly undefined
// 401028: using guessed type __int64 __fastcall j_strnlen(_QWORD, _QWORD);
// 401060: using guessed type __int64 __fastcall j_strchrnul(_QWORD, _QWORD);
// 4010C8: using guessed type __int64 __fastcall j_strlen_ifunc(_QWORD);
// 4914E0: using guessed type unsigned __int8 jump_table[91];
// 493255: using guessed type unsigned __int8 byte_493255[1707];
// 4A57E0: using guessed type void *step3a_jumps_13585[30];
// 4A9C40: using guessed type u32 _start___libc_IO_vtables[48];
// 4AA2E8: using guessed type __int64 (__fastcall *_start___libc_atexit)();
// 4AB820: using guessed type int _libc_multiple_threads;
// 4ABA08: using guessed type __int64 _printf_function_table;
// 4ABA10: using guessed type __int64 _printf_modifier_table;
// 4ABA30: using guessed type __int64 _printf_va_arg_table;
// 4508C0: using guessed type long double var_4A0;

//----- (0000000000453980) ----------------------------------------------------
__int64 __fastcall buffered_vfprintf(__int64 a1, __int64 _RSI, __m128i *a3)
{
  int v3; // eax
  int *v5; // rdi
  int v6; // eax
  __int64 v7; // rcx
  unsigned int v8; // ebp
  u32 *v9; // r8
  __int64 v10; // r9
  int v11; // er13
  __int64 v12; // r14
  __int64 v13; // rdx
  bool v16; // zf
  int v17; // eax
  int v18[8]; // [rsp+20h] [rbp-2138h] BYREF
  char *v19; // [rsp+40h] [rbp-2118h]
  char *v20; // [rsp+48h] [rbp-2110h]
  char *v21; // [rsp+50h] [rbp-2108h]
  int v22; // [rsp+94h] [rbp-20C4h]
  __int64 v23; // [rsp+A8h] [rbp-20B0h]
  int v24; // [rsp+E0h] [rbp-2078h]
  void *v25; // [rsp+F8h] [rbp-2060h]
  __int64 v26; // [rsp+100h] [rbp-2058h]
  char v27[16]; // [rsp+120h] [rbp-2038h] BYREF
  char v28; // [rsp+2120h] [rbp-38h] BYREF
  unsigned __int64 v29; // [rsp+2128h] [rbp-30h]

  v29 = __readfsqword(0x28u);
  v3 = *(_DWORD *)(a1 + 192);
  if ( v3 )
  {
    v8 = -1;
    if ( v3 != -1 )
      return v8;
  }
  else
  {
    *(_DWORD *)(a1 + 192) = -1;
  }
  v5 = v18;
  v26 = a1;
  v20 = v27;
  v19 = v27;
  v21 = &v28;
  v6 = *(_DWORD *)(a1 + 116);
  v24 = -1;
  v22 = v6;
  v18[0] = -72515580;
  v23 = 0LL;
  v25 = &IO_helper_jumps;
  v8 = vfprintf((__int64)v18, _RSI, a3);
  if ( (*(_DWORD *)a1 & 0x8000) == 0 )
  {
    _RDX = *(_QWORD *)(a1 + 136);
    v9 = (u32 *)__readfsqword(0x10u);
    if ( *(u32 **)(_RDX + 8) == v9 )
      goto LABEL_26;
    _RSI = 1LL;
    v16 = _libc_multiple_threads == 0;
    if ( _libc_multiple_threads )
    {
      if ( !_InterlockedCompareExchange((volatile signed __int32 *)_RDX, 1, 0) )
        goto LABEL_25;
    }
    else
    {
      __asm { cmpxchg [rdx], esi }
      if ( v16 )
      {
LABEL_25:
        _RDX = *(_QWORD *)(a1 + 136);
        *(_QWORD *)(_RDX + 8) = v9;
LABEL_26:
        v17 = (_DWORD)v20 - (_DWORD)v19;
        ++*(_DWORD *)(_RDX + 4);
        v11 = v17;
        if ( v17 <= 0 )
          goto LABEL_9;
        goto LABEL_5;
      }
    }
    v5 = (int *)_RDX;
    _lll_lock_wait_private((u32 *)_RDX, 1LL, _RDX, v7, v9, v10);
    goto LABEL_25;
  }
  v11 = (_DWORD)v20 - (_DWORD)v19;
  if ( (int)v20 - (int)v19 <= 0 )
    return v8;
LABEL_5:
  v12 = *(_QWORD *)(a1 + 216);
  if ( (char *)&_start___libc_atexit - (char *)_start___libc_IO_vtables <= (unsigned __int64)(v12
                                                                                            - (_QWORD)_start___libc_IO_vtables) )
    IO_vtable_check(
      (__int64)v5,
      _RSI,
      (__int64)_start___libc_IO_vtables,
      v12 - (_QWORD)_start___libc_IO_vtables,
      v9,
      v10);
  _RSI = (__int64)v19;
  if ( v11 != (*(unsigned int (__fastcall **)(__int64, char *, _QWORD))(v12 + 56))(a1, v19, v11) )
    v8 = -1;
LABEL_9:
  if ( (*(_DWORD *)a1 & 0x8000) == 0 )
  {
    v13 = *(_QWORD *)(a1 + 136);
    v16 = (*(_DWORD *)(v13 + 4))-- == 1;
    if ( v16 )
    {
      *(_QWORD *)(v13 + 8) = 0LL;
      if ( _libc_multiple_threads )
      {
        if ( !_InterlockedDecrement((volatile signed __int32 *)v13) )
          return v8;
        goto LABEL_15;
      }
      v16 = (*(_DWORD *)v13)-- == 1;
      if ( !v16 )
LABEL_15:
        _lll_unlock_wake_private((u32 *)v13, _RSI, v13, v7, v9, v10);
    }
  }
  return v8;
}
// 453BE8: variable 'v9' is possibly undefined
// 453BE8: variable 'v10' is possibly undefined
// 453B00: variable 'v7' is possibly undefined
// 4A9C40: using guessed type u32 _start___libc_IO_vtables[48];
// 4AA2E8: using guessed type __int64 (__fastcall *_start___libc_atexit)();
// 4AB820: using guessed type int _libc_multiple_threads;

//----- (0000000000453C00) ----------------------------------------------------
__int64 __fastcall hack_digit(__int64 a1)
{
  __int64 v1; // r9
  __int64 v3; // rdx
  unsigned __int64 *v4; // rdi
  __int64 v5; // rax
  __int64 *v6; // rcx
  __int64 v7; // rbp
  unsigned int v8; // ebp
  __int64 v9; // rax
  __int64 v11; // rax
  __int64 v12; // rdx
  __int64 v13; // rcx
  __int64 *v14; // rbx
  __int64 v15; // rbp
  int v16; // eax

  if ( *(_DWORD *)a1 )
  {
    if ( *(_DWORD *)(a1 + 4) == 102 )
    {
      v16 = *(_DWORD *)(a1 + 8);
      *(_DWORD *)(a1 + 8) = v16 - 1;
      if ( v16 > 0 )
        return 48LL;
    }
  }
  v1 = *(_QWORD *)(a1 + 40);
  v3 = *(_QWORD *)(a1 + 24);
  v4 = *(unsigned __int64 **)(a1 + 16);
  if ( !v1 )
  {
    v14 = (__int64 *)&v4[v3 - 1];
    v15 = *v14;
    *v14 = _mpn_mul_1(v4, v4, v3 - 1, 0xAuLL);
    return (unsigned int)(v15 + 48);
  }
  if ( v1 > v3 )
  {
    v8 = 48;
  }
  else
  {
    v5 = _mpn_divrem(*(_QWORD *)(a1 + 48), 0LL, v4, v3, *(__int64 **)(a1 + 32), v1);
    v6 = *(__int64 **)(a1 + 48);
    v6[*(_QWORD *)(a1 + 24) - *(_QWORD *)(a1 + 40)] = v5;
    v3 = *(_QWORD *)(a1 + 40);
    v7 = *v6;
    *(_QWORD *)(a1 + 24) = v3;
    if ( !v3 )
    {
      v8 = v7 + 48;
LABEL_10:
      *(_QWORD *)(a1 + 24) = 1LL;
      return v8;
    }
    v4 = *(unsigned __int64 **)(a1 + 16);
    v8 = v7 + 48;
    if ( !v4[v3 - 1] )
    {
      v9 = v3 - 1;
      do
      {
        v3 = v9;
        *(_QWORD *)(a1 + 24) = v9;
        if ( !v9 )
          goto LABEL_10;
        --v9;
      }
      while ( !v4[v9] );
    }
  }
  v11 = _mpn_mul_1(v4, v4, v3, 0xAuLL);
  if ( v11 )
  {
    v12 = *(_QWORD *)(a1 + 24);
    v13 = *(_QWORD *)(a1 + 16);
    *(_QWORD *)(a1 + 24) = v12 + 1;
    *(_QWORD *)(v13 + 8 * v12) = v11;
  }
  return v8;
}

//----- (0000000000453D40) ----------------------------------------------------
__int64 __fastcall i18n_number_rewrite_0(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v3; // r14
  _DWORD *v5; // rbx
  unsigned int v6; // er15
  unsigned int v7; // eax
  __int64 v8; // rcx
  u32 *v9; // r8
  unsigned __int64 v10; // r9
  __int64 v11; // r13
  unsigned __int64 v13; // r15
  __int64 v14; // rsi
  __int64 v15; // rdx
  __int64 v16; // rcx
  u32 *v17; // r8
  unsigned __int64 v18; // r9
  _BYTE *v19; // r13
  int v20; // eax
  __int64 v21; // r12
  __int64 v22; // rax
  __int16 *v23; // rdi
  __int16 *v24; // rdx
  int v25; // esi
  unsigned int v26; // eax
  bool v27; // zf
  __int64 v28; // rax
  __int64 v29; // rax
  u32 *v30; // r8
  __int64 v31; // r9
  __int64 v32; // rax
  unsigned int v33; // [rsp+0h] [rbp-498h]
  __int64 v34[2]; // [rsp+10h] [rbp-488h] BYREF
  _BYTE v35[1024]; // [rsp+20h] [rbp-478h] BYREF
  __int16 v36[16]; // [rsp+420h] [rbp-78h] BYREF
  __int16 v37[12]; // [rsp+440h] [rbp-58h] BYREF
  unsigned __int64 v38; // [rsp+458h] [rbp-40h]

  v3 = a1;
  v38 = __readfsqword(0x28u);
  v5 = (_DWORD *)wctrans((__int64)"to_outpunct");
  v6 = towctrans(0x2Eu, v5);
  v7 = towctrans(0x2Cu, v5);
  if ( v5 )
  {
    v33 = v7;
    v34[0] = 0LL;
    v29 = wcrtomb((char *)v36, v6, v34, v8, v9, v10);
    if ( v29 == -1 )
      v36[0] = 46;
    else
      *((_BYTE *)v36 + v29) = 0;
    v34[0] = 0LL;
    v32 = wcrtomb((char *)v37, v33, v34, v33, v30, v31);
    if ( v32 == -1 )
      v37[0] = 44;
    else
      *((_BYTE *)v37 + v32) = 0;
  }
  v11 = a2 - a1;
  v34[0] = (__int64)v35;
  v34[1] = 1024LL;
  if ( (unsigned __int8)_libc_scratch_buffer_set_array_size(v34, a2 - a1, 1LL, v8, v9, v10) )
  {
    v13 = v34[0];
    v14 = a1;
    v3 = a3;
    v19 = (_BYTE *)j_mempcpy(v34[0], a1, v11);
LABEL_5:
    while ( v13 <= (unsigned __int64)--v19 )
    {
      while ( 1 )
      {
        v20 = (char)*v19;
        v15 = (unsigned int)(v20 - 48);
        if ( (unsigned __int8)(*v19 - 48) <= 9u )
          break;
        if ( v5 )
        {
          v15 = v20 & 0xFFFFFFFD;
          if ( (v20 & 0xFD) == 44 )
          {
            v23 = v37;
            if ( (_BYTE)v20 == 46 )
              v23 = v36;
            v24 = v23;
            do
            {
              v25 = *(_DWORD *)v24;
              v24 += 2;
              v26 = ~v25 & (v25 - 16843009) & 0x80808080;
            }
            while ( !v26 );
            v27 = (~v25 & (v25 - 16843009) & 0x8080) == 0;
            if ( (~v25 & (v25 - 16843009) & 0x8080) == 0 )
              v26 >>= 16;
            v14 = (__int64)(v24 + 1);
            if ( v27 )
              ++v24;
            v16 = v26;
            LOBYTE(v16) = 2 * v26;
            v15 = (char *)v24 - __CFADD__((_BYTE)v26, (_BYTE)v26) - 3 - (char *)v23;
            v3 -= v15;
            v28 = v15 - 1;
            if ( v15 )
            {
              do
              {
                v15 = *((unsigned __int8 *)v23 + v28);
                *(_BYTE *)(v3 + v28--) = v15;
              }
              while ( v28 != -1 );
            }
            goto LABEL_5;
          }
        }
        --v19;
        *(_BYTE *)--v3 = v20;
        if ( v13 > (unsigned __int64)v19 )
          goto LABEL_9;
      }
      v21 = *(_QWORD *)(*(_QWORD *)__readfsqword(0xFFFFFFA0) + 8LL * (v20 - 7) + 64);
      v22 = j_strlen_ifunc(v21);
      v3 -= v22;
      v15 = v22 - 1;
      if ( v22 )
      {
        do
        {
          *(_BYTE *)(v3 + v15) = *(_BYTE *)(v21 + v15);
          --v15;
        }
        while ( v15 != -1 );
      }
    }
LABEL_9:
    if ( (_BYTE *)v34[0] != v35 )
      free(v34[0], v14, v15, v16, v17, v18);
  }
  return v3;
}
// 453DC7: variable 'v8' is possibly undefined
// 453DC7: variable 'v9' is possibly undefined
// 453DC7: variable 'v10' is possibly undefined
// 453E74: variable 'v15' is possibly undefined
// 453E74: variable 'v16' is possibly undefined
// 453E74: variable 'v17' is possibly undefined
// 453E74: variable 'v18' is possibly undefined
// 453F96: variable 'v30' is possibly undefined
// 453F96: variable 'v31' is possibly undefined
// 4010B0: using guessed type __int64 __fastcall j_mempcpy(_QWORD, _QWORD, _QWORD);
// 4010C8: using guessed type __int64 __fastcall j_strlen_ifunc(_QWORD);

//----- (0000000000453FE0) ----------------------------------------------------
__int64 __fastcall _guess_grouping_part_0(unsigned int a1, char *a2)
{
  char v2; // cl
  unsigned int v3; // er9
  unsigned int v4; // er8

  v2 = *a2;
  v3 = 0;
  do
  {
    v4 = v2;
    if ( a1 > v2 )
    {
      v2 = *++a2;
      ++v3;
      a1 -= v4;
      if ( *a2 != 127 && v2 >= 0 )
        continue;
    }
    return v3;
  }
  while ( v2 );
  return (a1 - 1) / v4 + v3;
}

//----- (0000000000454030) ----------------------------------------------------
__int64 __fastcall _printf_fp_l(char *a1, _QWORD *a2, __int64 a3, long double **a4, u32 *a5, __int64 a6)
{
  char v7; // r12
  char v8; // al
  char v9; // si
  __int64 v10; // rdx
  long double *v11; // rdx
  int v12; // ebx
  unsigned int *v13; // r13
  void *__ptr32 *v14; // r14
  __int64 v15; // rdx
  bool v16; // zf
  int v17; // er15
  char v18; // al
  int v19; // er15
  __int64 v20; // rax
  __int64 v21; // rdx
  char *v22; // rdx
  __int16 v23; // fps
  unsigned int *v25; // r12
  __int64 v26; // rax
  int v27; // ebx
  int v28; // ecx
  __int64 v29; // rdx
  __int64 *v30; // r11
  __int64 *v31; // r8
  void *v32; // rsp
  __int64 *v33; // r10
  void *v34; // rsp
  int v35; // esi
  int v36; // edx
  __int64 v37; // rdx
  __int64 v38; // rsi
  __int64 *v39; // rax
  __int64 *v40; // rdx
  __int64 v41; // rdx
  char *v42; // r15
  int v43; // er12
  int v44; // er14
  char *v45; // rbx
  int v46; // er13
  __int64 v47; // rax
  __int64 v48; // rdx
  bool v49; // zf
  __int64 v50; // rax
  __int64 v51; // rdx
  unsigned __int64 v52; // rax
  char v53; // cl
  __int64 *v54; // rdi
  unsigned __int64 v55; // rax
  int v57; // eax
  int v58; // er14
  __int64 *v59; // r11
  __int64 *v61; // r8
  __int64 j; // rax
  __int64 v65; // rbx
  unsigned __int64 *v66; // rsi
  int v70; // er15
  __int64 v71; // r14
  __int64 v72; // rbx
  __int64 v73; // rax
  __int64 v74; // rcx
  int v75; // ebx
  int v76; // edx
  int v77; // ebx
  __int32 v78; // eax
  __int64 v79; // rax
  __int64 v80; // rsi
  unsigned __int64 v81; // r15
  _QWORD *v82; // rdx
  __int64 v83; // rcx
  u32 *v84; // r8
  __int64 v85; // r9
  __int64 *v86; // rdx
  void *v87; // rsp
  char *v88; // r13
  _DWORD *v89; // r14
  __int64 v90; // r15
  __int64 v91; // rbx
  unsigned int *v92; // rax
  char *v93; // r15
  int v94; // er14
  int v95; // eax
  __m128d v96; // xmm0
  __int64 v97; // rax
  __int64 v98; // rax
  __int64 v99; // rax
  char *v100; // r12
  __int64 v101; // r14
  int v102; // ebx
  __int64 v103; // rax
  __int64 v104; // rsi
  bool v105; // al
  unsigned __int32 v106; // eax
  unsigned __int32 v107; // er12
  __int64 v108; // rbx
  __int64 v109; // rax
  char *v111; // rcx
  unsigned __int64 v112; // rax
  char *v113; // rdx
  bool v114; // zf
  char *v115; // r12
  __int64 v116; // rcx
  void *__ptr32 *v117; // r13
  __int64 v118; // rsi
  _BYTE *v119; // rax
  int v120; // eax
  __int64 v121; // rsi
  __int64 v122; // rdi
  int v123; // eax
  unsigned __int64 v124; // rdx
  __int64 v125; // rcx
  __int64 v126; // r8
  unsigned __int64 v127; // r9
  bool v128; // al
  int v129; // eax
  unsigned __int64 v130; // rax
  void *v131; // rsp
  unsigned __int64 v132; // rax
  int v133; // ebx
  int v134; // eax
  __int64 v135; // rdx
  __int64 v136; // rcx
  unsigned __int64 v137; // r9
  __int64 v138; // rsi
  __int64 v139; // rsi
  char *v140; // rax
  __int64 v141; // rbx
  __int64 v142; // r12
  unsigned __int64 v143; // r14
  char *v144; // rcx
  unsigned __int64 v145; // rax
  __int64 v146; // rdx
  __int64 v147; // rax
  char v148; // al
  int v149; // esi
  int v150; // eax
  int m; // ecx
  int v152; // eax
  int v153; // eax
  char v154; // r12
  __int64 v155; // rbx
  __int64 v156; // r12
  __int64 v157; // rax
  __int64 v158; // rax
  char v159; // al
  __int64 v160; // rax
  _QWORD *v161; // rdx
  __int64 v162; // r12
  __int64 v163; // rax
  __int64 v164; // r14
  void *v165; // rsp
  __int64 v166; // rbx
  _BYTE *v167; // rax
  unsigned int v168; // er14
  char *v169; // rbx
  __int64 v170; // r15
  int v171; // er12
  _QWORD *v172; // r14
  __int64 v173; // rax
  __int64 v174; // r12
  __int64 v175; // rdx
  __int64 (__fastcall *v176)(char *, char *, __int64); // rax
  __int64 v177; // rax
  __int64 v178; // r9
  __int64 v179; // rbx
  __int64 v180; // rsi
  __int64 v181; // rax
  char *v182; // rsi
  int v183; // edx
  unsigned __int64 v184; // rax
  __int64 v185; // rdx
  char *v186; // r15
  int v187; // er14
  bool v188; // al
  __int64 v189; // rax
  int v190; // eax
  __int64 v191; // rax
  __int64 v192; // rdx
  char v193; // r15
  unsigned __int64 v194; // rax
  __int64 v195; // rdx
  char *v196; // rbx
  int v197; // edi
  __int64 v198; // rax
  __int64 v199; // rdx
  unsigned __int64 v200; // rdx
  unsigned __int64 *v201; // rsi
  __int64 v202; // r8
  int v203; // er9
  unsigned __int64 *v204; // rax
  unsigned __int64 v205; // rcx
  int v206; // ecx
  int v207; // er12
  int v208; // er13
  __int64 v209; // rcx
  unsigned __int64 *v211; // rcx
  __int64 i; // rax
  unsigned __int64 *v214; // r13
  int v215; // er11
  __int64 v216; // r10
  __int64 v217; // r14
  __int64 v218; // rdx
  __int64 *v219; // r8
  unsigned __int64 *v220; // rcx
  __int64 v221; // rax
  unsigned __int64 v222; // rcx
  _BYTE *v223; // rax
  __int64 v224; // rax
  char *v225; // r13
  int v226; // er15
  __int64 v227; // rbx
  char *v228; // r12
  _BYTE *v229; // rax
  __int64 v230; // rcx
  char *v231; // rax
  int v232; // eax
  bool v233; // cf
  int v234; // eax
  unsigned __int64 v235; // rax
  bool v236; // sf
  int v237; // ebx
  int v238; // edx
  __int64 v239; // rsi
  __int64 v240; // rax
  int v241; // ecx
  int v243; // ecx
  unsigned __int64 v245; // rax
  __int64 v246; // rdx
  __int64 v247; // r13
  __int64 v248; // rbx
  __int64 v249; // r14
  unsigned __int64 *v251; // rdi
  char v252; // cl
  char v253; // al
  __int64 v254; // r12
  __int64 v255; // rsi
  int v256; // eax
  bool v257; // al
  _BYTE *v258; // rax
  __int64 v259; // rdx
  __int64 *v260; // r8
  __int64 k; // rsi
  __int64 v262; // rdx
  __int64 *v263; // rcx
  __int64 v264; // rax
  __int64 v265; // r12
  __int64 v266; // rax
  __int64 v267; // rdx
  __int64 v268; // rcx
  u32 *v269; // r8
  unsigned __int64 v270; // r9
  __int64 v271; // rsi
  int v272; // eax
  _BYTE *v273; // rax
  __int64 v274; // rax
  __int64 v275; // rax
  char *v276; // r12
  __int64 v277; // rax
  _QWORD *v278; // rax
  char v280; // al
  unsigned __int64 v281; // rax
  unsigned __int64 v282; // rax
  __int64 v283; // rdx
  int v284; // eax
  int v285; // esi
  int v286; // eax
  __int64 v287; // rsi
  int v288; // eax
  int v289; // eax
  char *v290; // rdx
  __int64 v291; // [rsp+0h] [rbp-5158h]
  __int64 v292; // [rsp+8h] [rbp-5150h] BYREF
  _BYTE v293[4088]; // [rsp+10h] [rbp-5148h] BYREF
  __int64 v294; // [rsp+1008h] [rbp-4150h] BYREF
  _BYTE v295[4088]; // [rsp+1010h] [rbp-4148h] BYREF
  __int64 v296; // [rsp+2008h] [rbp-3150h] BYREF
  _BYTE v297[4088]; // [rsp+2010h] [rbp-3148h] BYREF
  __int64 v298; // [rsp+3008h] [rbp-2150h] BYREF
  _BYTE v299[4088]; // [rsp+3010h] [rbp-2148h] BYREF
  __int64 v300; // [rsp+4008h] [rbp-1150h] BYREF
  _BYTE v301[7]; // [rsp+4010h] [rbp-1148h] BYREF
  __int64 v302; // [rsp+5008h] [rbp-150h] BYREF
  unsigned int v303; // [rsp+5010h] [rbp-148h]
  int v304; // [rsp+5014h] [rbp-144h]
  int v305; // [rsp+5018h] [rbp-140h]
  signed int v306; // [rsp+501Ch] [rbp-13Ch]
  char *v307; // [rsp+5020h] [rbp-138h]
  int v308; // [rsp+5028h] [rbp-130h]
  unsigned int v309; // [rsp+502Ch] [rbp-12Ch]
  unsigned __int64 v310; // [rsp+5030h] [rbp-128h]
  signed int v311; // [rsp+5038h] [rbp-120h]
  unsigned int v312; // [rsp+503Ch] [rbp-11Ch]
  _BYTE *v313; // [rsp+5040h] [rbp-118h]
  __int64 v314; // [rsp+5048h] [rbp-110h]
  char *v315; // [rsp+5050h] [rbp-108h]
  _QWORD *v316; // [rsp+5058h] [rbp-100h]
  unsigned __int64 *v317; // [rsp+5060h] [rbp-F8h]
  char *v318; // [rsp+5068h] [rbp-F0h]
  unsigned int v319; // [rsp+5070h] [rbp-E8h]
  _BOOL4 v320; // [rsp+5074h] [rbp-E4h]
  __m128 v321; // [rsp+5078h] [rbp-E0h] BYREF
  __m128 si128; // [rsp+5088h] [rbp-D0h] BYREF
  char *v323; // [rsp+5098h] [rbp-C0h]
  __int64 v324; // [rsp+50A0h] [rbp-B8h]
  unsigned __int16 v325; // [rsp+50B2h] [rbp-A6h]
  int v326; // [rsp+50B4h] [rbp-A4h] BYREF
  unsigned int v327; // [rsp+50B8h] [rbp-A0h] BYREF
  int v328; // [rsp+50BCh] [rbp-9Ch]
  int v329; // [rsp+50C0h] [rbp-98h] BYREF
  unsigned __int64 *v330; // [rsp+50C8h] [rbp-90h]
  __int64 v331; // [rsp+50D0h] [rbp-88h]
  __int64 *v332; // [rsp+50D8h] [rbp-80h]
  __int64 v333; // [rsp+50E0h] [rbp-78h]
  unsigned __int64 *v334; // [rsp+50E8h] [rbp-70h]
  __int64 v335; // [rsp+50F0h] [rbp-68h]
  __int64 v336[2]; // [rsp+50F8h] [rbp-60h] BYREF
  unsigned __int64 v337; // [rsp+5108h] [rbp-50h] BYREF
  unsigned __int64 v338; // [rsp+5110h] [rbp-48h]
  unsigned __int64 v339; // [rsp+5120h] [rbp-38h]

  v323 = a1;
  v316 = a2;
  v7 = *(_BYTE *)(a3 + 12);
  v324 = a3;
  v339 = __readfsqword(0x28u);
  v8 = *(_BYTE *)(a3 + 13);
  v326 = 0;
  v327 = 0;
  v320 = (v8 & 4) != 0;
  v9 = v8 & 1;
  if ( (v8 & 1) != 0 )
  {
    v21 = v316[4];
    v16 = **(_BYTE **)(v21 + 80) == 0;
    v314 = *(_QWORD *)(v21 + 80);
    if ( v16 )
      v314 = *(_QWORD *)(v316[1] + 64LL);
    v319 = *(_DWORD *)(v21 + 408);
    if ( !v319 )
      v319 = *(_DWORD *)(v316[1] + 88LL);
    if ( v7 >= 0 )
      goto LABEL_3;
    v318 = *(char **)(v21 + 96);
  }
  else
  {
    v10 = a2[1];
    v314 = *(_QWORD *)(v10 + 64);
    v319 = *(_DWORD *)(v10 + 88);
    if ( v7 >= 0 )
    {
LABEL_3:
      v318 = 0LL;
      v312 = 0;
      v313 = 0LL;
      goto LABEL_4;
    }
    v318 = *(char **)(v10 + 80);
  }
  si128.m128_i8[0] = *v318;
  if ( (unsigned __int8)(si128.m128_i8[0] - 1) > 0x7Du )
    goto LABEL_3;
  if ( v320 )
  {
    if ( v9 )
      v312 = *(_DWORD *)(v316[4] + 416LL);
    else
      v312 = *(_DWORD *)(v316[1] + 96LL);
    v313 = 0LL;
    v22 = 0LL;
    if ( v312 )
      v22 = v318;
    v318 = v22;
    v11 = *a4;
    if ( (v8 & 0x10) != 0 )
      goto LABEL_5;
LABEL_33:
    if ( (v7 & 1) != 0 )
    {
      _FST7 = *v11;
      __asm { fxam }
      v12 = v23 & 0x200;
      if ( (HIBYTE(v23) & 0x45) == 5 )
        goto LABEL_9;
      v25 = &v327;
      v26 = _mpn_extract_long_double(
              v336,
              2LL,
              &v329,
              &v326,
              (__int64)a5,
              a6,
              COERCE_UNSIGNED_INT128(*v11),
              WORD4(COERCE_UNSIGNED_INT128(*v11)));
      v331 = v26;
      v27 = ((_DWORD)v26 << 6) - 63;
    }
    else
    {
      v96 = (__m128d)*(unsigned __int64 *)v11;
      if ( fabs(v96.m128d_f64[0]) > 1.797693134862316e308 )
      {
        v12 = _mm_movemask_pd(v96) & 1;
        goto LABEL_9;
      }
      v25 = &v327;
      v26 = _mpn_extract_double(v336, v96.m128d_f64[0], 2LL, &v329, &v326);
      v331 = v26;
      v27 = ((_DWORD)v26 << 6) - 52;
    }
    goto LABEL_36;
  }
  if ( v9 )
    v313 = *(_BYTE **)(v316[4] + 88LL);
  else
    v313 = *(_BYTE **)(v316[1] + 72LL);
  v113 = 0LL;
  if ( *v313 )
    v113 = v318;
  v312 = *v313 != 0 ? 0xFFFFFFFE : 0;
  v318 = v113;
LABEL_4:
  v11 = *a4;
  if ( (v8 & 0x10) == 0 )
    goto LABEL_33;
LABEL_5:
  si128 = (__m128)_mm_load_si128((const __m128i *)v11);
  if ( _unordtf2(si128, si128) )
  {
    v12 = _mm_movemask_ps(si128) & 8;
    v326 = v12;
    v13 = (unsigned int *)&unk_49154C;
    v14 = (void *__ptr32 *)&unk_49153B;
    v15 = (__int64)&unk_49156C;
    v114 = (*(_WORD *)(__readfsqword(0xFFFFFFF0) + 2LL * *(int *)(v324 + 8)) & 0x100) == 0;
    if ( v114 )
    {
      v13 = (unsigned int *)&unk_49156C;
      if ( v114 )
        v14 = (void *__ptr32 *)&unk_491543;
    }
LABEL_12:
    v17 = *(_DWORD *)(v324 + 4);
    v18 = (((unsigned __int8)v7 >> 5) ^ 1) & 1;
    if ( v12 )
    {
      v19 = v17 - 4;
      LOBYTE(v15) = v19 > 0;
      if ( v19 <= 0 || !v18 )
      {
        v12 = 0;
LABEL_16:
        if ( v320 )
        {
          v20 = *((_QWORD *)v323 + 20);
          if ( v20 )
          {
            a4 = *(long double ***)(v20 + 32);
            if ( (unsigned __int64)a4 < *(_QWORD *)(v20 + 40) )
            {
              *(_QWORD *)(v20 + 32) = (char *)a4 + 4;
              *(_DWORD *)a4 = 45;
LABEL_151:
              ++v12;
LABEL_152:
              if ( v320 )
              {
                v100 = v323;
                v101 = 0LL;
                v102 = v12 + 1;
                while ( 1 )
                {
                  v103 = *((_QWORD *)v100 + 20);
                  v104 = v13[v101];
                  if ( v103 && (a4 = *(long double ***)(v103 + 32), (unsigned __int64)a4 < *(_QWORD *)(v103 + 40)) )
                  {
                    *(_QWORD *)(v103 + 32) = (char *)a4 + 4;
                    v105 = (_DWORD)v104 == -1;
                    *(_DWORD *)a4 = v104;
                  }
                  else
                  {
                    si128.m128_i8[0] = v15;
                    v120 = _woverflow((__int64)v100, v104, v15, (__int64)a4, a5, a6);
                    v15 = si128.m128_u8[0];
                    v105 = v120 == -1;
                  }
                  if ( v105 )
                    break;
                  v106 = v102 + v101++;
                  if ( v101 == 3 )
                  {
                    v107 = v106;
                    if ( (*(_BYTE *)(v324 + 12) & 0x20) != 0 && (_BYTE)v15 )
                    {
                      v108 = v19;
                      v109 = IO_wpadn(v323, 32LL, v19, (__int64)a4, a5, a6);
                      goto LABEL_162;
                    }
                    return v107;
                  }
                }
              }
              else
              {
                v115 = v323;
                v116 = (__int64)v14 + 3;
                v117 = v14;
                do
                {
                  v117 = (void *__ptr32 *)((char *)v117 + 1);
                  v118 = *((unsigned __int8 *)v117 - 1);
                  v119 = (_BYTE *)*((_QWORD *)v115 + 5);
                  if ( (unsigned __int64)v119 >= *((_QWORD *)v115 + 6) )
                  {
                    v321.m128_u64[0] = v116;
                    si128.m128_i8[0] = v15;
                    v129 = _overflow((__int64)v115, v118, v15, v116, a5, a6);
                    v15 = si128.m128_u8[0];
                    v116 = v321.m128_u64[0];
                    if ( v129 == -1 )
                      return (unsigned __int32)-1;
                  }
                  else
                  {
                    *((_QWORD *)v115 + 5) = v119 + 1;
                    *v119 = v118;
                  }
                }
                while ( v117 != (void *__ptr32 *)v116 );
                v107 = v12 + (_DWORD)v117 - (_DWORD)v14;
                if ( (*(_BYTE *)(v324 + 12) & 0x20) == 0 || !(_BYTE)v15 )
                  return v107;
                v108 = v19;
                v109 = IO_padn(v323, (char *)0x20, v19, v116, a5, a6);
LABEL_162:
                if ( v109 == v108 )
                {
                  v107 += v19;
                  return v107;
                }
              }
              return (unsigned __int32)-1;
            }
          }
          si128.m128_i8[0] = v15;
          v255 = 45LL;
          goto LABEL_477;
        }
        v111 = v323;
        v112 = *((_QWORD *)v323 + 5);
        if ( v112 < *((_QWORD *)v323 + 6) )
        {
          a4 = (long double **)(v112 + 1);
          *((_QWORD *)v323 + 5) = v112 + 1;
          *(_BYTE *)v112 = 45;
          goto LABEL_151;
        }
        si128.m128_i8[0] = v15;
        v271 = 45LL;
        goto LABEL_506;
      }
LABEL_133:
      if ( v320 )
        v97 = IO_wpadn(v323, 32LL, v19, (__int64)a4, a5, a6);
      else
        v97 = IO_padn(v323, (char *)0x20, v19, (__int64)a4, a5, a6);
      if ( v97 != v19 )
        return (unsigned __int32)-1;
      v12 = v19;
      v15 = 1LL;
      if ( v326 )
        goto LABEL_16;
      v7 = *(_BYTE *)(v324 + 12);
      if ( (v7 & 0x40) == 0 )
      {
LABEL_138:
        if ( (v7 & 0x10) == 0 )
          goto LABEL_152;
        if ( v320 )
        {
          v98 = *((_QWORD *)v323 + 20);
          if ( v98 )
          {
            a4 = *(long double ***)(v98 + 32);
            if ( (unsigned __int64)a4 < *(_QWORD *)(v98 + 40) )
            {
              *(_QWORD *)(v98 + 32) = (char *)a4 + 4;
              *(_DWORD *)a4 = 32;
              goto LABEL_151;
            }
          }
          si128.m128_i8[0] = v15;
          v255 = 32LL;
          goto LABEL_477;
        }
        v111 = v323;
        v132 = *((_QWORD *)v323 + 5);
        if ( v132 < *((_QWORD *)v323 + 6) )
        {
          a4 = (long double **)(v132 + 1);
          *((_QWORD *)v323 + 5) = v132 + 1;
          *(_BYTE *)v132 = 32;
          goto LABEL_151;
        }
        si128.m128_i8[0] = v15;
        v271 = 32LL;
        goto LABEL_506;
      }
LABEL_147:
      if ( v320 )
      {
        v99 = *((_QWORD *)v323 + 20);
        if ( v99 )
        {
          a4 = *(long double ***)(v99 + 32);
          if ( (unsigned __int64)a4 < *(_QWORD *)(v99 + 40) )
          {
            *(_QWORD *)(v99 + 32) = (char *)a4 + 4;
            *(_DWORD *)a4 = 43;
            goto LABEL_151;
          }
        }
        si128.m128_i8[0] = v15;
        v255 = 43LL;
LABEL_477:
        v256 = _woverflow((__int64)v323, v255, v15, (__int64)a4, a5, a6);
        v15 = si128.m128_u8[0];
        v257 = v256 == -1;
        goto LABEL_478;
      }
      v111 = v323;
      v130 = *((_QWORD *)v323 + 5);
      if ( v130 < *((_QWORD *)v323 + 6) )
      {
        a4 = (long double **)(v130 + 1);
        *((_QWORD *)v323 + 5) = v130 + 1;
        *(_BYTE *)v130 = 43;
        goto LABEL_151;
      }
      si128.m128_i8[0] = v15;
      v271 = 43LL;
LABEL_506:
      v272 = _overflow((__int64)v111, v271, v15, (__int64)v111, a5, a6);
      v15 = si128.m128_u8[0];
      v257 = v272 == -1;
LABEL_478:
      if ( v257 )
        return (unsigned __int32)-1;
      goto LABEL_151;
    }
    if ( (v7 & 0x50) != 0 )
    {
      v19 = v17 - 4;
      LOBYTE(v15) = v19 > 0;
      if ( v19 <= 0 )
        goto LABEL_146;
    }
    else
    {
      v19 = v17 - 3;
      LOBYTE(v15) = v19 > 0;
      if ( v19 <= 0 )
        goto LABEL_146;
    }
    if ( v18 )
      goto LABEL_133;
LABEL_146:
    if ( (v7 & 0x40) == 0 )
      goto LABEL_138;
    goto LABEL_147;
  }
  v321 = (__m128)_mm_and_si128(_mm_load_si128((const __m128i *)&si128), (__m128i)xmmword_4915B0);
  if ( !_unordtf2(v321, (__m128)_mm_load_si128((const __m128i *)&xmmword_4915C0))
    && _lttf2((__m128)_mm_load_si128((const __m128i *)&v321), (__m128)_mm_load_si128((const __m128i *)&xmmword_4915C0)) > 0 )
  {
    v12 = _mm_movemask_ps(si128) & 8;
LABEL_9:
    v326 = v12;
    v13 = (unsigned int *)&unk_49155C;
    v14 = &off_49153F;
    v15 = (__int64)&unk_49157C;
    v16 = (*(_WORD *)(__readfsqword(0xFFFFFFF0) + 2LL * *(int *)(v324 + 8)) & 0x100) == 0;
    if ( v16 )
    {
      v13 = (unsigned int *)&unk_49157C;
      if ( v16 )
        v14 = (void *__ptr32 *)&unk_491547;
    }
    goto LABEL_12;
  }
  v25 = &v327;
  v26 = _mpn_extract_float128(v336, _mm_load_si128((const __m128i *)&si128), 2LL, &v329, &v326);
  v331 = v26;
  v27 = ((_DWORD)v26 << 6) - 112;
LABEL_36:
  v28 = v329;
  v29 = 8LL * (((int)(abs32(v329) + 63) >> 6) + 4) + 23;
  v30 = (__int64 *)((char *)&v302 - (v29 & 0xFFFFFFFFFFFFF000LL));
  if ( &v302 != v30 )
  {
    while ( &v300 != v30 )
      ;
  }
  if ( (v29 & 0xFF0) != 0 )
  {
    v131 = alloca(v29 & 0xFF0);
    *(_QWORD *)&v299[(v29 & 0xFF0) + 4080] = *(_QWORD *)&v299[(v29 & 0xFF0) + 4080];
  }
  v330 = (unsigned __int64 *)v301;
  v31 = (__int64 *)&v301[-(v29 & 0xFFFFFFFFFFFFF000LL) - 8];
  if ( &v300 != v31 )
  {
    while ( &v298 != v31 )
      ;
  }
  if ( (v29 & 0xFF0) != 0 )
  {
    v32 = alloca(v29 & 0xFF0);
    *(_QWORD *)&v297[(v29 & 0xFF0) + 4080] = *(_QWORD *)&v297[(v29 & 0xFF0) + 4080];
  }
  v334 = (unsigned __int64 *)v299;
  v33 = (__int64 *)&v299[-(v29 & 0xFFFFFFFFFFFFF000LL) - 8];
  if ( &v298 != v33 )
  {
    while ( &v296 != v33 )
      ;
  }
  if ( (v29 & 0xFF0) != 0 )
  {
    v34 = alloca(v29 & 0xFF0);
    *(_QWORD *)&v295[(v29 & 0xFF0) + 4080] = *(_QWORD *)&v295[(v29 & 0xFF0) + 4080];
  }
  v333 = 0LL;
  v332 = (__int64 *)v297;
  if ( v28 <= 2 )
  {
    if ( v28 >= 0 )
    {
      v184 = _mpn_lshift((__int64)v301, (__int64)v336, v26, (unsigned __int8)v27 + (unsigned __int8)v28);
      v185 = v331++;
      v330[v185] = v184;
      v329 = 0;
      goto LABEL_87;
    }
    v193 = 12;
    v194 = _mpn_lshift((__int64)v301, (__int64)v336, v26, v27);
    v195 = v331;
    v196 = (char *)&unk_493F58;
    si128.m128_i32[0] = 0;
    v197 = -v329;
    v321.m128_u64[0] = (unsigned __int64)&v327;
    ++v331;
    v330[v195] = v194;
    v327 = 1;
    v329 = v197;
    v317 = &v337;
    while ( 1 )
    {
      v196 -= 24;
      if ( *((_DWORD *)v196 + 5) > v197 )
        goto LABEL_377;
      v209 = *(_QWORD *)v196;
      if ( v331 < *((_QWORD *)v196 + 1) - 1LL )
        v198 = _mpn_mul(v334, (__int64 *)&_tens[v209 + 1], *((_QWORD *)v196 + 1) - 1LL, v330, v331);
      else
        v198 = _mpn_mul(v334, (__int64 *)v330, v331, &_tens[v209 + 1], *((_QWORD *)v196 + 1) - 1LL);
      v199 = v331 + *((_QWORD *)v196 + 1);
      if ( v198 )
        v200 = v199 - 1;
      else
        v200 = v199 - 2;
      v335 = v200;
      v201 = v334;
      v202 = v200;
      v203 = v329;
      v204 = &v334[v200 - 1];
      _BitScanReverse64(&v205, *v204);
      v206 = v205 ^ 0x3F;
      v207 = v206;
      v208 = ~v206 + (((_DWORD)v200 - (_DWORD)v331 + 1) << 6);
      v197 = v329;
      if ( v329 + 3 == v208 )
      {
        if ( v206 > 60 )
        {
          v337 = 0xA000000000000000LL;
          v338 = 0LL;
          _mpn_lshift((__int64)v317, (__int64)v317, 2uLL, 64 - v206);
          v203 = v329;
          v197 = v329;
          if ( v329 + 2 >= v208 )
          {
            v201 = v334;
            v200 = v335;
            goto LABEL_384;
          }
          if ( v329 + 3 != v208 )
            goto LABEL_377;
          v200 = v335;
          v201 = v334;
          v222 = v338;
          v202 = v335;
          v204 = &v334[v335 - 1];
        }
        else
        {
          v337 = 0LL;
          v222 = 10LL << (60 - (unsigned __int8)v206);
          v338 = 10LL << (60 - (unsigned __int8)v207);
          if ( v208 <= v329 + 2 )
            goto LABEL_384;
        }
        if ( *v204 >= v222 && (*v204 != v222 || v201[v202 - 2] >= v337) )
        {
          v197 = v203;
          goto LABEL_377;
        }
      }
      else if ( v208 > v329 + 2 )
      {
        goto LABEL_377;
      }
LABEL_384:
      v197 = v203 - v208;
      si128.m128_i32[0] |= 1 << v193;
      v329 = v203 - v208;
      if ( v203 - v208 < 0 )
        v207 -= v203 - v208;
      _RAX = *v201;
      if ( !*v201 )
      {
        v211 = v201 + 1;
        for ( i = 1LL; ; ++i )
        {
          _R8 = *v211;
          v214 = v211;
          v215 = i - 1;
          v216 = (int)i;
          v217 = i;
          ++v211;
          if ( _R8 )
            break;
        }
        if ( v207 != 63 )
        {
          __asm { tzcnt   r8, r8 }
          v251 = v330;
          v252 = 63 - v207;
          v253 = 63 - v207;
          if ( 63 - v207 <= (int)_R8 )
          {
            v254 = (int)v216;
            v201 = v214;
            v252 = v253;
            v200 -= (int)v216;
          }
          else
          {
            v254 = v215;
            v201 = &v201[v217 - 1];
            v200 -= v215;
          }
          goto LABEL_474;
        }
        goto LABEL_391;
      }
      if ( v207 == 63 )
      {
        v216 = 0LL;
        i = 0LL;
LABEL_391:
        v218 = v200 - v216;
        if ( v218 > 0 )
        {
          v219 = (__int64 *)v330;
          v220 = &v201[i];
          v221 = 0LL;
          do
          {
            v219[v221] = v220[v221];
            ++v221;
            v218 = v335 - v216;
          }
          while ( v335 - v216 > v221 );
        }
        v331 = v218;
        goto LABEL_377;
      }
      v251 = v330;
      __asm { tzcnt   rcx, rax }
      v280 = 63 - v207;
      if ( 63 - v207 <= (int)_RCX )
      {
        v254 = 0LL;
        v252 = v280;
LABEL_474:
        _mpn_rshift(v251, v201, v200, v252);
        v197 = v329;
        v331 = v335 - v254;
        goto LABEL_377;
      }
      v281 = _mpn_lshift((__int64)v330, (__int64)v201, v200, (unsigned __int8)v207 + 1);
      v197 = v329;
      v331 = v335 + 1;
      v330[v335] = v281;
LABEL_377:
      --v193;
      if ( v196 == (char *)&unk_493E38 )
      {
        v25 = (unsigned int *)v321.m128_u64[0];
        if ( v197 > 0 )
        {
          _mpn_mul_1(v334, v330, v331, 0xAuLL);
          _RSI = v334;
          v243 = 4;
          v335 = v331;
          __asm { tzcnt   rax, [rsi] }
          if ( v329 <= 4 )
            v243 = v329;
          if ( v243 <= (int)_RAX )
          {
            _mpn_rshift(v330, v334, v331, v243);
          }
          else
          {
            v245 = _mpn_lshift((__int64)v330, (__int64)v334, v331, 64 - (unsigned __int8)v243);
            if ( v245 )
            {
              v246 = v335++;
              v330[v246] = v245;
            }
          }
          si128.m128_i32[0] |= 1u;
          v331 = v335;
        }
        goto LABEL_457;
      }
      if ( v197 <= 0 )
      {
        v25 = (unsigned int *)v321.m128_u64[0];
LABEL_457:
        v329 = si128.m128_i32[0];
        goto LABEL_87;
      }
    }
  }
  v35 = v27 + v28;
  v36 = v27 + v28 + 63;
  if ( v27 + v28 >= 0 )
    v36 = v27 + v28;
  LODWORD(v37) = v36 >> 6;
  if ( (v35 & 0x3F) != 0 )
  {
    v235 = _mpn_lshift((__int64)&v301[8 * (int)v37], (__int64)v336, v26, v35 % 64);
    v28 = v329;
    v236 = v329 + v27 < 0;
    v237 = v329 + v27;
    v238 = v237 + 63;
    if ( !v236 )
      v238 = v237;
    v37 = v238 >> 6;
    v239 = v37 + v331;
    v331 += v37;
    if ( v235 )
    {
      v331 = v239 + 1;
      v330[v239] = v235;
    }
  }
  else
  {
    v37 = (int)v37;
    v38 = v26 - 1;
    if ( v26 - 1 >= 0 )
    {
      do
      {
        *(_QWORD *)&v301[8 * (int)v37 + 8 * v38] = v336[v38];
        --v38;
      }
      while ( v38 != -1 );
    }
    v331 = (int)v37 + v26;
  }
  if ( v37 > 0 )
  {
    v39 = (__int64 *)v330;
    v40 = (__int64 *)&v330[v37];
    do
      *v39++ = 0LL;
    while ( v40 != v39 );
  }
  v41 = v333;
  v42 = (char *)&unk_493F58;
  si128.m128_u64[0] = (unsigned __int64)&v327;
  v43 = 0;
  v44 = 12;
  v45 = (char *)&unk_493F58 - 312;
  v46 = 0;
  while ( 1 )
  {
    v42 -= 24;
    if ( v43 + *((_DWORD *)v42 + 4) - 1 <= v28 )
      break;
LABEL_64:
    --v44;
    if ( v42 == v45 )
      goto LABEL_71;
LABEL_65:
    v28 = v329;
  }
  if ( !v41 )
  {
    v47 = *(_QWORD *)v42;
    if ( (*(_BYTE *)(v324 + 13) & 0x10) != 0 )
    {
      v335 = *((_QWORD *)v42 + 1) + 1LL;
      j_memcpy(v334 + 1, &_tens[v47], 8 * v335);
      *v334 = 0LL;
      v48 = v335;
      v329 += 64;
    }
    else
    {
      v335 = *((_QWORD *)v42 + 1);
      j_memcpy(v334, &_tens[v47], 8 * v335);
      v48 = v335;
    }
LABEL_61:
    v49 = v331 == v48;
    if ( v331 > v48 )
      goto LABEL_70;
    goto LABEL_62;
  }
  v50 = _mpn_mul(v334, v332, v41, &_tens[*(_QWORD *)v42 + 1], *((_QWORD *)v42 + 1) - 1LL);
  v51 = v333 + *((_QWORD *)v42 + 1);
  if ( !v50 )
  {
    v48 = v51 - 2;
    v335 = v48;
    goto LABEL_61;
  }
  v48 = v51 - 1;
  v335 = v48;
  v49 = v331 == v48;
  if ( v331 > v48 )
    goto LABEL_70;
LABEL_62:
  if ( !v49 || (int)_mpn_cmp((__int64)v330, (__int64)v334, v48) < 0 )
  {
    v41 = v333;
    goto LABEL_64;
  }
  v48 = v335;
LABEL_70:
  v333 = v48;
  j_memcpy(v332, v334, 8 * v48);
  v41 = v333;
  _BitScanReverse64(&v52, v332[v333 - 1]);
  v53 = v44--;
  v43 = ((_DWORD)v333 << 6) - 129 - (v52 ^ 0x3F);
  v46 |= 1 << v53;
  if ( v42 != v45 )
    goto LABEL_65;
LABEL_71:
  v25 = (unsigned int *)si128.m128_u64[0];
  v329 = v46;
  if ( v41 <= 0 )
    goto LABEL_87;
  v54 = v332;
  _BitScanReverse64(&v55, v332[v41 - 1]);
  _R13 = *v332;
  v57 = v55 ^ 0x3F;
  v58 = v57;
  if ( *v332 )
  {
    if ( !v57 )
      goto LABEL_87;
    __asm { tzcnt   rax, r13 }
    _RCX = *v330;
    if ( *v330 )
    {
      v66 = (unsigned __int64 *)v332;
      _R13 = 0LL;
      LODWORD(v65) = 0;
LABEL_80:
      __asm { tzcnt   rcx, rcx }
      if ( (int)_RAX > (int)_RCX )
        LODWORD(_RAX) = _RCX;
      v70 = 64 - v58;
      if ( (_DWORD)v65 )
        goto LABEL_460;
    }
    else
    {
      v66 = (unsigned __int64 *)v332;
      _R13 = 0LL;
      v70 = 64 - v58;
    }
LABEL_83:
    si128.m128_u64[0] = 0LL;
    LODWORD(v65) = 0;
    if ( (int)_RAX < v70 )
    {
      _mpn_lshift((__int64)v332, (__int64)v332, v41, v58);
      v282 = _mpn_lshift((__int64)v330, (__int64)v330, v331, v58);
      if ( v282 )
      {
        v283 = v331++;
        v330[v283] = v282;
      }
      goto LABEL_87;
    }
LABEL_84:
    v71 = si128.m128_u64[0];
    v72 = (int)v65 + 1;
    _mpn_rshift((unsigned __int64 *)v332, v66, v41 - si128.m128_u64[0], v70);
    v333 -= v72;
    _mpn_rshift(v330, (unsigned __int64 *)((char *)v330 + _R13), v331 - v71, v70);
    v73 = v331 - v71;
    if ( !v330[v331 - v71 - 1] )
      v73 = v331 - v72;
    goto LABEL_86;
  }
  v59 = (__int64 *)v330;
  _RAX = *v330;
  if ( *v330 )
  {
    if ( !v58 )
      goto LABEL_87;
    __asm { tzcnt   rax, rax }
    v66 = (unsigned __int64 *)v332;
    v70 = 64 - v58;
    goto LABEL_83;
  }
  v61 = v332 + 1;
  for ( j = 1LL; ; ++j )
  {
    _RCX = *v61;
    v65 = (int)j;
    _R13 = 8 * j;
    v66 = (unsigned __int64 *)v61;
    if ( *v61 )
      break;
    _R9 = v330[j];
    ++v61;
    if ( _R9 )
    {
      if ( v58 )
      {
        __asm { tzcnt   rax, r9 }
        v70 = 64 - v58;
        goto LABEL_460;
      }
      goto LABEL_484;
    }
  }
  if ( !v58 )
  {
LABEL_484:
    v259 = v41 - (int)j;
    if ( v259 > 0 )
    {
      v260 = &v332[j];
      for ( k = 0LL; ; _RCX = v260[k] )
      {
        v54[k++] = _RCX;
        v259 = v333 - (int)j;
        if ( v259 <= k )
          break;
      }
    }
    v333 = v259;
    v262 = v331 - (int)j;
    if ( v262 > 0 )
    {
      v263 = &v59[j];
      v264 = 0LL;
      do
      {
        v59[v264] = v263[v264];
        ++v264;
        v262 = v331 - v65;
      }
      while ( v331 - v65 > v264 );
    }
    v331 = v262;
    goto LABEL_87;
  }
  __asm { tzcnt   rax, rcx }
  _RCX = *(unsigned __int64 *)((char *)v330 + _R13);
  if ( _RCX )
    goto LABEL_80;
  v70 = 64 - v58;
LABEL_460:
  si128.m128_u64[0] = (int)v65;
  if ( v70 <= (int)_RAX )
    goto LABEL_84;
  v247 = _R13 - 8;
  v248 = (int)v65 - 1;
  _mpn_rshift((unsigned __int64 *)v332, (unsigned __int64 *)((char *)v332 + v247), v41 - v248, v70);
  v249 = si128.m128_u64[0];
  v333 -= si128.m128_u64[0];
  _mpn_rshift(v330, (unsigned __int64 *)((char *)v330 + v247), v331 - v248, v70);
  v73 = v331 - v248;
  if ( !v330[v331 - v248 - 1] )
    v73 = v331 - v249;
LABEL_86:
  v331 = v73;
LABEL_87:
  v74 = *(int *)(v324 + 8);
  v75 = *(_DWORD *)v324;
  v305 = *(_DWORD *)(v324 + 4);
  LODWORD(v317) = v75;
  v304 = *(_DWORD *)(__readfsqword(0xFFFFFFE0) + 4 * v74);
  if ( (_BYTE)v304 == 101 )
  {
    v328 = v74;
    if ( v75 < 0 )
    {
      v310 = 14LL;
      LODWORD(v317) = 6;
    }
    else
    {
      v310 = v75 + 8LL;
    }
    goto LABEL_353;
  }
  if ( (_BYTE)v304 == 102 )
  {
    v328 = 102;
    v192 = (int)v317;
    if ( (int)v317 < 0 )
    {
      LODWORD(v317) = 6;
      v192 = 6LL;
    }
    v309 = v327;
    if ( !v327 )
    {
      v77 = 1;
      v308 = 0x7FFFFFFF;
      v310 = v192 + v329 + 2;
      v311 = v329 + 1;
      v321.m128_i32[0] = (int)v317;
      if ( v318 )
        goto LABEL_101;
LABEL_104:
      if ( v310 <= 0x3FFFFFFFFFFFFFFCLL )
        goto LABEL_105;
      goto LABEL_420;
    }
    v310 = v192 + 2;
LABEL_353:
    v77 = 1;
    v308 = 0x7FFFFFFF;
    v311 = 1;
    v321.m128_i32[0] = (int)v317;
    goto LABEL_100;
  }
  v308 = 6;
  if ( (int)v317 >= 0 )
  {
    v76 = 1;
    if ( (_DWORD)v317 )
      v76 = (int)v317;
    v308 = v76;
  }
  if ( v327 )
  {
    if ( v329 <= 4 )
    {
      v328 = 102;
      v311 = 0;
      v321.m128_i32[0] = v308;
      goto LABEL_96;
    }
LABEL_419:
    v311 = 1;
    v328 = v74 - 2;
    v321.m128_i32[0] = v308 - 1;
    v310 = v308 - 1 + 8LL;
  }
  else
  {
    if ( v308 <= v329 )
      goto LABEL_419;
    v328 = 102;
    v311 = v329 + 1;
    v321.m128_i32[0] = v308 - (v329 + 1);
LABEL_96:
    v310 = v308 + 5LL;
  }
  v77 = 0;
  v78 = v321.m128_i32[0];
  if ( (*(_BYTE *)(v324 + 12) & 8) == 0 )
    v78 = 0;
  LODWORD(v317) = v78;
LABEL_100:
  if ( v318 )
  {
LABEL_101:
    si128.m128_i8[0] = *v318;
    if ( (unsigned __int8)(si128.m128_i8[0] - 1) > 0x7Du )
    {
      v309 = 0;
      v79 = 1LL;
    }
    else
    {
      v309 = _guess_grouping_part_0(v311, v318);
      v79 = (int)(v309 + 1);
    }
    v310 += v79;
    goto LABEL_104;
  }
  v309 = 0;
LABEL_105:
  v80 = v310;
  if ( v321.m128_i32[0] > v310 )
  {
LABEL_420:
    v107 = -1;
    __writefsdword(0xFFFFFFC0, 0x22u);
    return v107;
  }
  v81 = 4 * v310 + 8;
  if ( !_libc_alloca_cutoff(v81) && v81 > 0x1000 )
  {
    v307 = (char *)malloc(4 * v80 + 8, v80, v82, v83, v84, v85);
    if ( v307 )
    {
      v303 = 0;
      goto LABEL_113;
    }
    return (unsigned __int32)-1;
  }
  v86 = (__int64 *)&v297[-((4 * v80 + 31) & 0xFFFFFFFFFFFFF000LL) - 8];
  if ( &v296 != v86 )
  {
    while ( &v294 != v86 )
      ;
  }
  if ( ((4 * (_WORD)v80 + 31) & 0xFF0) != 0 )
  {
    v87 = alloca((4 * (_WORD)v80 + 31) & 0xFF0);
    *(_QWORD *)&v293[((4 * (_WORD)v80 + 31) & 0xFF0) + 4080] = *(_QWORD *)&v293[((4 * (_WORD)v80 + 31) & 0xFF0) + 4080];
  }
  v303 = 1;
  v307 = v295;
LABEL_113:
  v88 = v307 + 8;
  if ( v327 && v328 == 102 )
  {
    v240 = (__int64)v307;
    v241 = v319;
    v306 = 0;
    --v329;
    *((_DWORD *)v307 + 2) = 48;
    v93 = (char *)(v240 + 16);
    *(_DWORD *)(v240 + 12) = v241;
    goto LABEL_122;
  }
  if ( v311 <= 0 )
  {
    v306 = 0;
    v92 = (unsigned int *)(v307 + 8);
  }
  else
  {
    v89 = v307 + 8;
    v90 = (unsigned int)(v311 - 1);
    v91 = (__int64)&v307[4 * v90 + 12];
    do
      *v89++ = hack_digit((__int64)v25);
    while ( v89 != (_DWORD *)v91 );
    v92 = (unsigned int *)&v88[4 * v90 + 4];
    v306 = v311;
  }
  if ( (*(_BYTE *)(v324 + 12) & 8) != 0 || (int)v317 > 0 )
  {
LABEL_121:
    v93 = (char *)(v92 + 1);
    v77 = 1;
    *v92 = v319;
    goto LABEL_122;
  }
  if ( v321.m128_i32[0] <= 0 )
  {
    LODWORD(v315) = 0;
    v93 = (char *)v92;
    v94 = 0;
  }
  else
  {
    if ( v331 > 1 || *v330 )
      goto LABEL_121;
    v93 = (char *)v92;
    v77 = 1;
LABEL_122:
    v94 = 0;
    LODWORD(v315) = 0;
    si128.m128_i32[0] = (int)v317;
    while ( 1 )
    {
      if ( si128.m128_i32[0] > v94 )
        goto LABEL_126;
LABEL_124:
      if ( v321.m128_i32[0] <= v94 || v331 <= 1 && !*v330 )
        break;
LABEL_126:
      while ( 1 )
      {
        ++v94;
        v93 += 4;
        v95 = hack_digit((__int64)v25);
        *((_DWORD *)v93 - 1) = v95;
        if ( !v77 && v95 == 48 )
          break;
        v77 = 1;
        if ( si128.m128_i32[0] <= v94 )
          goto LABEL_124;
      }
      ++v321.m128_i32[0];
      if ( (int)v317 > 0 )
      {
        LODWORD(v315) = (_DWORD)v315 + 1;
        si128.m128_i32[0] = (_DWORD)v315 + (_DWORD)v317;
      }
    }
  }
  v133 = *((_DWORD *)v93 - 1);
  if ( v133 == v319 )
    v133 = *((_DWORD *)v93 - 2);
  v122 = (__int64)v25;
  v134 = hack_digit((__int64)v25);
  LOBYTE(v122) = v134 != 53 && v134 != 48;
  if ( !(_BYTE)v122 )
  {
    if ( v331 == 1 )
    {
      if ( *v330 )
        v122 = 1LL;
    }
    else
    {
      if ( v333 )
        goto LABEL_370;
      v138 = v331;
      if ( v331 )
      {
        v137 = (unsigned __int64)v330;
        if ( v330[v331 - 1] )
        {
LABEL_370:
          v122 = 1LL;
        }
        else
        {
          while ( --v138 )
          {
            if ( v330[v138 - 1] )
              goto LABEL_370;
          }
        }
      }
    }
  }
  v139 = v325;
  LOWORD(v139) = v325 & 0xC00;
  if ( (v325 & 0xC00) == 1024 )
  {
    if ( !v326 )
      goto LABEL_222;
LABEL_220:
    if ( v134 > 52 )
      goto LABEL_318;
LABEL_221:
    if ( !(_BYTE)v122 )
      goto LABEL_222;
    goto LABEL_318;
  }
  if ( (v325 & 0xC00u) > 0x400 )
  {
    if ( (_WORD)v139 == 2048 )
    {
      if ( !v326 )
        goto LABEL_220;
LABEL_222:
      v124 = (unsigned int)((_DWORD)v315 + (_DWORD)v317);
      goto LABEL_223;
    }
    if ( (_WORD)v139 == 3072 )
      goto LABEL_222;
LABEL_314:
    abort(v122, v139, v135, v136, (u32 *)v126, v137);
  }
  if ( (_WORD)v139 )
    goto LABEL_314;
  if ( v134 <= 52 )
    goto LABEL_222;
  if ( (v133 & 1) == 0 )
    goto LABEL_221;
LABEL_318:
  v140 = v93 - 4;
  v122 = *((unsigned int *)v93 - 1);
  v182 = v93 - 4;
  if ( !v94 )
  {
    v231 = v93;
    v124 = (unsigned int)((_DWORD)v315 + (_DWORD)v317);
LABEL_423:
    if ( (_DWORD)v122 == v319 )
    {
      v231 = v182;
      v182 -= 4;
    }
    if ( v88 <= v182 )
    {
      v232 = *((_DWORD *)v231 - 1);
      if ( v232 != 57 )
      {
LABEL_449:
        *(_DWORD *)v182 = v232 + 1;
        goto LABEL_223;
      }
      while ( 1 )
      {
        *(_DWORD *)v182 = 48;
        v182 -= 4;
        if ( v88 > v182 )
          break;
        v232 = *(_DWORD *)v182;
        if ( *(_DWORD *)v182 != 57 )
          goto LABEL_449;
      }
    }
    if ( v328 == 102 )
    {
      v274 = (__int64)v307;
      if ( v308 == v306 )
      {
        v285 = v319;
        *(_DWORD *)v307 = 49;
        *(_DWORD *)(v274 + 4) = v285;
        if ( (*(_BYTE *)(v324 + 12) & 8) != 0 || (v286 = 0, v94) )
        {
          *(_DWORD *)&v307[4 * v306 + 8] = 48;
          v286 = v94 + 1;
        }
        ++v329;
        v88 = v307;
        v94 = v286 + v306;
        v287 = *(int *)(v324 + 8);
        v306 = 1;
        v328 = (*(_WORD *)(__readfsqword(0xFFFFFFF0) + 2 * v287) & 0x100) == 0 ? 101 : 69;
      }
      else
      {
        v88 = v307 + 4;
        *((_DWORD *)v307 + 1) = 49;
        ++v306;
      }
    }
    else
    {
      v233 = v327 == 0;
      *((_DWORD *)v307 + 2) = 49;
      v329 += v233 ? 1 : -1;
      if ( !v329 )
        v327 = 0;
    }
    if ( v94 + v306 > v308 )
    {
      v234 = v94 + v306 - v308;
      v94 = v308 - v306;
      v93 -= 4 * v234;
    }
LABEL_223:
    if ( v94 > (int)v124 )
    {
      v140 = v93 - 4;
      if ( *((_DWORD *)v93 - 1) == 48 )
        goto LABEL_228;
    }
    goto LABEL_229;
  }
  v183 = v319;
  v137 = 0LL;
  if ( (_DWORD)v122 == v319 )
  {
LABEL_463:
    if ( (_DWORD)v137 == (_DWORD)v317 )
      LODWORD(v315) = ((int)v315 <= 0) + (_DWORD)v315 - 1;
    goto LABEL_465;
  }
  while ( (_DWORD)v122 == 57 )
  {
    *(_DWORD *)v182 = 48;
    v182 -= 4;
    LODWORD(v122) = *(_DWORD *)v182;
    v137 = (unsigned int)(v137 + 1);
    if ( *(_DWORD *)v182 == v183 )
      goto LABEL_463;
  }
  if ( (_DWORD)v137 == (_DWORD)v317 && (int)v315 > 0 && (LODWORD(v315) = (_DWORD)v315 - 1, (_DWORD)v122 == v319) )
  {
LABEL_465:
    v122 = *(unsigned int *)v182;
    if ( (_BYTE)v304 == 103 && v328 == 102 && (*(_BYTE *)(v324 + 12) & 8) != 0 )
    {
      v137 = (unsigned __int64)(v307 + 12);
      if ( v182 == v307 + 12 && *((_DWORD *)v307 + 2) == 48 )
        LODWORD(v315) = (_DWORD)v315 - 1;
    }
  }
  else
  {
    v122 = (unsigned int)(v122 + 1);
    *(_DWORD *)v182 = v122;
  }
  v124 = (unsigned int)((_DWORD)v315 + (_DWORD)v317);
  if ( (_DWORD)v122 == v319 )
  {
    v122 = *((unsigned int *)v182 - 1);
    v231 = v182;
    v182 -= 4;
    goto LABEL_423;
  }
  if ( v94 <= (int)v124 || *((_DWORD *)v93 - 1) != 48 )
    goto LABEL_233;
LABEL_228:
  while ( 1 )
  {
    --v94;
    v93 = v140;
    if ( v94 <= (int)v124 || *((_DWORD *)v140 - 1) != 48 )
      break;
    v140 -= 4;
  }
LABEL_229:
  if ( !v94 && (*(_BYTE *)(v324 + 12) & 8) == 0 && *((_DWORD *)v93 - 1) == v319 )
    v93 -= 4;
LABEL_233:
  v121 = (__int64)v318;
  if ( v318 )
  {
    v122 = (unsigned int)v306;
    LODWORD(v141) = v306;
    if ( v306 == v311 )
    {
LABEL_237:
      if ( v309 )
      {
        v142 = (int)v309;
        v143 = 4 * ((int)v309 + (unsigned __int64)(unsigned int)v306);
        wmemmove((__int64)&v88[v143], (__int64)&v88[4 * v306], (v93 - &v88[4 * v306]) >> 2);
        v144 = v318;
        v137 = (unsigned __int64)&v88[v143 - 4];
        v126 = v312;
        v122 = (unsigned int)*v318;
        do
        {
          v145 = v137;
          LODWORD(v121) = v141 - v122;
          do
          {
            v145 -= 4LL;
            v141 = (unsigned int)(v141 - 1);
            *(_DWORD *)(v145 + 4) = *(_DWORD *)&v88[4 * v141];
          }
          while ( (_DWORD)v141 != (_DWORD)v121 );
          v146 = (unsigned int)(v122 - 1);
          v147 = -v146;
          v124 = v137 + 4 * ~v146;
          v137 = v137 + 4 * v147 - 8;
          *(_DWORD *)v124 = v126;
          v148 = v144[1];
          if ( v148 == 127 || v148 < 0 )
            break;
          if ( v148 )
            ++v144;
          else
            v148 = *v144;
          v122 = (unsigned int)v148;
          LODWORD(v141) = v121;
        }
        while ( (unsigned int)v122 < (unsigned int)v121 );
        do
        {
          v137 -= 4LL;
          v121 = (unsigned int)(v121 - 1);
          *(_DWORD *)(v137 + 4) = *(_DWORD *)&v88[4 * v121];
        }
        while ( v137 > (unsigned __int64)v88 );
        v93 += 4 * v142;
      }
    }
    else
    {
      v309 = 0;
      si128.m128_i8[0] = *v318;
      if ( (unsigned __int8)(si128.m128_i8[0] - 1) <= 0x7Du )
      {
        v309 = _guess_grouping_part_0(v306, v318);
        goto LABEL_237;
      }
    }
  }
  if ( v328 != 102 )
  {
    v124 = v327;
    v149 = v329;
    if ( !v327 )
    {
      *(_DWORD *)v93 = v328;
      v150 = 43;
      goto LABEL_251;
    }
    if ( (_BYTE)v304 == 103 && v329 == 4 )
    {
      v121 = (__int64)&unk_49158C;
      v122 = (__int64)v88;
      wmemcpy((__int64)v88, (__int64)&unk_49158C, 6LL);
      *((_DWORD *)v88 + 1) = v319;
      if ( v88 + 8 <= v93 )
      {
        v290 = v93;
        v122 = (__int64)(v88 + 24);
        v121 = 48LL;
        v93 += 16;
        j_wmemset(v88 + 24, 48LL, (v290 - (v88 + 8)) >> 2);
      }
      else
      {
        v93 += 20;
      }
    }
    else
    {
      *(_DWORD *)v93 = v328;
      v150 = 45;
LABEL_251:
      v137 = (unsigned __int64)(v93 + 8);
      *((_DWORD *)v93 + 1) = v150;
      if ( v149 <= 9 )
      {
        v137 = (unsigned __int64)(v93 + 12);
        *((_DWORD *)v93 + 2) = 48;
      }
      else
      {
        for ( m = 10; m <= v149; m *= 10 )
          ;
        while ( 1 )
        {
          v137 += 4LL;
          v122 = (unsigned int)(m / 10);
          v124 = (unsigned int)(v149 >> 31);
          LODWORD(v124) = v149 % (int)v122;
          v152 = v149 / (int)v122 + 48;
          v149 %= (int)v122;
          *(_DWORD *)(v137 - 4) = v152;
          if ( m <= 109 )
            break;
          m /= 10;
        }
        v329 = v124;
      }
      v121 = (unsigned int)(v149 + 48);
      v93 = (char *)(v137 + 4);
      *(_DWORD *)v137 = v121;
    }
  }
  v153 = v326;
  v154 = *(_BYTE *)(v324 + 12);
  v155 = v93 - v88;
  if ( v326 || (v154 & 0x50) != 0 )
  {
    v124 = v155 >> 2;
    v125 = v305 - 1 - (unsigned int)(v155 >> 2);
    si128.m128_i32[0] = v305 - 1 - (v155 >> 2);
    if ( (v154 & 0x20) == 0 )
    {
      v122 = v324;
      v121 = *(unsigned int *)(v324 + 16);
      if ( (int)v125 > 0 && (_DWORD)v121 != 48 )
        goto LABEL_264;
    }
    v127 = 0LL;
LABEL_268:
    if ( !v153 )
    {
      v154 = *(_BYTE *)(v324 + 12);
      goto LABEL_357;
    }
    if ( v320 )
    {
      v158 = *((_QWORD *)v323 + 20);
      if ( v158 )
      {
        v124 = *(_QWORD *)(v158 + 32);
        if ( v124 < *(_QWORD *)(v158 + 40) )
        {
          v121 = v124 + 4;
          *(_QWORD *)(v158 + 32) = v124 + 4;
          *(_DWORD *)v124 = 45;
          goto LABEL_273;
        }
      }
      v321.m128_i32[0] = v127;
      v121 = 45LL;
      goto LABEL_190;
    }
    v122 = (__int64)v323;
    v223 = (_BYTE *)*((_QWORD *)v323 + 5);
    if ( (unsigned __int64)v223 >= *((_QWORD *)v323 + 6) )
    {
      v121 = 45LL;
      v321.m128_i32[0] = v127;
      v284 = _overflow((__int64)v323, 45LL, v124, v125, (u32 *)v126, v127);
      v127 = v321.m128_u32[0];
      v128 = v284 == -1;
      goto LABEL_191;
    }
    v122 = (__int64)v323;
    v124 = (unsigned __int64)(v223 + 1);
    *((_QWORD *)v323 + 5) = v223 + 1;
    *v223 = 45;
LABEL_273:
    v127 = (unsigned int)(v127 + 1);
    v159 = *(_BYTE *)(v324 + 12);
  }
  else
  {
    v125 = v305 - (unsigned int)(v155 >> 2);
    si128.m128_i32[0] = v305 - (v155 >> 2);
    if ( (v154 & 0x20) == 0 )
    {
      v121 = *(unsigned int *)(v324 + 16);
      if ( si128.m128_i32[0] > 0 && (_DWORD)v121 != 48 )
      {
LABEL_264:
        v156 = si128.m128_i32[0];
        v122 = (__int64)v323;
        if ( v320 )
          v157 = IO_wpadn(v323, v121, si128.m128_i32[0], v125, (u32 *)v126, v137);
        else
          v157 = IO_padn(v323, (char *)v121, si128.m128_i32[0], v125, (u32 *)v126, v137);
        if ( v157 == v156 )
        {
          v153 = v326;
          v127 = si128.m128_u32[0];
          goto LABEL_268;
        }
LABEL_192:
        v121 = v303;
        if ( !v303 )
LABEL_193:
          free((__int64)v307, v121, v124, v125, (u32 *)v126, v127);
        return (unsigned __int32)-1;
      }
    }
    v127 = 0LL;
LABEL_357:
    v159 = v154;
    if ( (v154 & 0x40) != 0 )
    {
      if ( v320 )
      {
        v191 = *((_QWORD *)v323 + 20);
        if ( v191 )
        {
          v124 = *(_QWORD *)(v191 + 32);
          if ( v124 < *(_QWORD *)(v191 + 40) )
          {
            v121 = v124 + 4;
            *(_QWORD *)(v191 + 32) = v124 + 4;
            *(_DWORD *)v124 = 43;
            goto LABEL_273;
          }
        }
        v321.m128_i32[0] = v127;
        v121 = 43LL;
LABEL_190:
        v122 = (__int64)v323;
        v123 = _woverflow((__int64)v323, v121, v124, v125, (u32 *)v126, v127);
        v127 = v321.m128_u32[0];
        v128 = v123 == -1;
LABEL_191:
        if ( v128 )
          goto LABEL_192;
      }
      else
      {
        v258 = (_BYTE *)*((_QWORD *)v323 + 5);
        if ( (unsigned __int64)v258 >= *((_QWORD *)v323 + 6) )
        {
          v122 = (__int64)v323;
          v121 = 43LL;
          v321.m128_i32[0] = v127;
          v288 = _overflow((__int64)v323, 43LL, v124, v125, (u32 *)v126, v127);
          v127 = v321.m128_u32[0];
          v128 = v288 == -1;
          goto LABEL_191;
        }
        v121 = (__int64)v323;
        v124 = (unsigned __int64)(v258 + 1);
        *((_QWORD *)v323 + 5) = v258 + 1;
        *v258 = 43;
      }
      goto LABEL_273;
    }
    if ( (v154 & 0x10) != 0 )
    {
      if ( v320 )
      {
        v224 = *((_QWORD *)v323 + 20);
        if ( !v224 || (v124 = *(_QWORD *)(v224 + 32), v124 >= *(_QWORD *)(v224 + 40)) )
        {
          v321.m128_i32[0] = v127;
          v121 = 32LL;
          goto LABEL_190;
        }
        v121 = v124 + 4;
        *(_QWORD *)(v224 + 32) = v124 + 4;
        *(_DWORD *)v124 = 32;
      }
      else
      {
        v122 = (__int64)v323;
        v273 = (_BYTE *)*((_QWORD *)v323 + 5);
        if ( (unsigned __int64)v273 >= *((_QWORD *)v323 + 6) )
        {
          v121 = 32LL;
          v321.m128_i32[0] = v127;
          v289 = _overflow((__int64)v323, 32LL, v124, v125, (u32 *)v126, v127);
          v127 = v321.m128_u32[0];
          v128 = v289 == -1;
          goto LABEL_191;
        }
        v121 = (__int64)v323;
        v124 = (unsigned __int64)(v273 + 1);
        *((_QWORD *)v323 + 5) = v273 + 1;
        *v273 = 32;
      }
      goto LABEL_273;
    }
  }
  if ( (v159 & 0x20) == 0 && *(_DWORD *)(v324 + 16) == 48 && si128.m128_i32[0] > 0 )
  {
    v265 = si128.m128_i32[0];
    v321.m128_i32[0] = v127;
    v121 = 48LL;
    v122 = (__int64)v323;
    if ( v320 )
      v266 = IO_wpadn(v323, 48LL, si128.m128_i32[0], v125, (u32 *)v126, v127);
    else
      v266 = IO_padn(v323, (char *)0x30, si128.m128_i32[0], v125, (u32 *)v126, v127);
    v127 = v321.m128_u32[0];
    if ( v266 != v265 )
      goto LABEL_192;
    v127 = (unsigned int)(si128.m128_i32[0] + v321.m128_i32[0]);
  }
  if ( v320 )
  {
    if ( (*(_BYTE *)(v324 + 13) & 8) != 0 )
    {
      v121 = 0LL;
      v122 = 0LL;
      v321.m128_i32[0] = v127;
      v275 = i18n_number_rewrite_0(0LL, 0LL, 0LL);
      v127 = v321.m128_u32[0];
      v172 = (_QWORD *)v275;
    }
    else
    {
      v172 = 0LL;
    }
    v166 = v155 >> 2;
    v126 = v166;
    if ( v93 != v88 )
    {
      v174 = *((_QWORD *)v323 + 27);
      v175 = v174 - (_QWORD)_start___libc_IO_vtables;
      if ( v174 - (__int64)_start___libc_IO_vtables >= (unsigned __int64)((char *)&_start___libc_atexit
                                                                        - (char *)_start___libc_IO_vtables) )
      {
        v166 = 0LL;
        goto LABEL_525;
      }
      v176 = *(__int64 (__fastcall **)(char *, char *, __int64))(v174 + 56);
      v166 = 0LL;
LABEL_300:
      LODWORD(v318) = v127;
      v121 = (__int64)v88;
      v321.m128_u64[0] = v126;
      v177 = v176(v323, v88, v126);
      v126 = v321.m128_u64[0];
      v127 = (unsigned int)v318;
      if ( v177 != v321.m128_u64[0] )
        goto LABEL_192;
      v107 = (_DWORD)v318 + v321.m128_i32[0];
LABEL_302:
      v178 = v303;
      if ( !v303 )
      {
        free(v166, v121, v124, v125, (u32 *)v126, 0LL);
        free((__int64)v307, v121, v267, v268, v269, v270);
      }
      if ( (*(_BYTE *)(v324 + 12) & 0x20) == 0 || si128.m128_i32[0] <= 0 )
        return v107;
      v179 = si128.m128_i32[0];
      v180 = *(unsigned int *)(v324 + 16);
      if ( v320 )
        v181 = IO_wpadn(v323, v180, si128.m128_i32[0], si128.m128_u32[0], (u32 *)v320, v178);
      else
        v181 = IO_padn(v323, (char *)v180, si128.m128_i32[0], si128.m128_u32[0], 0LL, v178);
      if ( v181 == v179 )
      {
        v107 += si128.m128_i32[0];
        return v107;
      }
      goto LABEL_192;
    }
    if ( v166 )
    {
      v125 = (unsigned int)(v166 + 1);
      v186 = v323;
      v187 = v127;
      do
      {
        v189 = *((_QWORD *)v186 + 20);
        v88 += 4;
        v121 = *((unsigned int *)v88 - 1);
        if ( v189 && (v124 = *(_QWORD *)(v189 + 32), v124 < *(_QWORD *)(v189 + 40)) )
        {
          *(_QWORD *)(v189 + 32) = v124 + 4;
          v188 = (_DWORD)v121 == -1;
          *(_DWORD *)v124 = v121;
        }
        else
        {
          v321.m128_i32[0] = v125;
          v190 = _woverflow((__int64)v186, v121, v124, v125, (u32 *)v126, v127);
          v125 = v321.m128_u32[0];
          v188 = v190 == -1;
        }
        if ( v188 )
          goto LABEL_192;
        v107 = v125 + v187 - v166--;
      }
      while ( v166 );
      v166 = 0LL;
      goto LABEL_302;
    }
LABEL_519:
    v107 = v127;
    goto LABEL_302;
  }
  if ( (*(_BYTE *)(v324 + 13) & 8) != 0 )
    v310 *= *(unsigned int *)(*v316 + 168LL);
  v321.m128_i32[0] = v127;
  v160 = j_strlen_ifunc(v314);
  v127 = v321.m128_u32[0];
  v162 = v160;
  if ( v313 )
  {
    LODWORD(v318) = v321.m128_i32[0];
    v163 = j_strlen_ifunc(v313);
    v127 = (unsigned int)v318;
    v321.m128_u64[0] = v163;
    v164 = v163 * (int)v309;
  }
  else
  {
    v321.m128_u64[0] = 0LL;
    v164 = 0LL;
  }
  v318 = (char *)(v164 + v310 + v162 + 2);
  if ( v303 )
  {
    v121 = (__int64)&v295[-((unsigned __int64)(v318 + 23) & 0xFFFFFFFFFFFFF000LL) - 8];
    if ( &v294 != (__int64 *)v121 )
    {
      while ( &v292 != (__int64 *)v121 )
        ;
    }
    v124 = ((_WORD)v318 + 23) & 0xFF0;
    if ( (((_WORD)v318 + 23) & 0xFF0) != 0 )
    {
      v165 = alloca(((_WORD)v318 + 23) & 0xFF0);
      *(__int64 *)((char *)&v291 + (((_WORD)v318 + 23) & 0xFF0)) = *(__int64 *)((char *)&v291
                                                                              + (((_WORD)v318 + 23) & 0xFF0));
    }
    v166 = (__int64)v293;
  }
  else
  {
    LODWORD(v317) = v127;
    v278 = malloc(v164 + v310 + v162 + 2, v121, v161, v125, (u32 *)v126, v127);
    v127 = (unsigned int)v317;
    v166 = (__int64)v278;
    if ( !v278 )
      goto LABEL_193;
  }
  if ( v93 <= v88 )
  {
    if ( (*(_BYTE *)(v324 + 13) & 8) != 0 )
    {
      v167 = (_BYTE *)v166;
      goto LABEL_523;
    }
    goto LABEL_519;
  }
  v167 = (_BYTE *)v166;
  v316 = (_QWORD *)v166;
  v168 = v312;
  v169 = v93;
  LODWORD(v317) = v127;
  v170 = v162;
  v171 = v319;
  v315 = v88;
  do
  {
    while ( 1 )
    {
      v124 = *(unsigned int *)v88;
      if ( (_DWORD)v124 != v171 )
        break;
      v121 = v314;
      v88 += 4;
      v167 = (_BYTE *)j_mempcpy(v167, v314, v170);
      if ( v169 <= v88 )
        goto LABEL_295;
    }
    if ( v168 == (_DWORD)v124 )
    {
      v121 = (__int64)v313;
      v167 = (_BYTE *)j_mempcpy(v167, v313, v321.m128_u64[0]);
    }
    else
    {
      *v167++ = v124;
    }
    v88 += 4;
  }
  while ( v169 > v88 );
LABEL_295:
  v122 = v324;
  v127 = (unsigned int)v317;
  v166 = (__int64)v316;
  v88 = v315;
  if ( (*(_BYTE *)(v324 + 13) & 8) == 0 )
  {
    v172 = v316;
    goto LABEL_297;
  }
LABEL_523:
  v121 = (__int64)v167;
  v122 = v166;
  v321.m128_i32[0] = v127;
  v276 = &v318[v166];
  v277 = i18n_number_rewrite_0(v166, (__int64)v167, (__int64)&v318[v166]);
  v127 = v321.m128_u32[0];
  v172 = (_QWORD *)v277;
  v167 = v276;
LABEL_297:
  v173 = v167 - (_BYTE *)v172;
  v126 = v173;
  if ( v173 > 20 )
  {
    v174 = *((_QWORD *)v323 + 27);
    v121 = (char *)&_start___libc_atexit - (char *)_start___libc_IO_vtables;
    v175 = v174 - (_QWORD)_start___libc_IO_vtables;
    if ( v174 - (__int64)_start___libc_IO_vtables < (unsigned __int64)((char *)&_start___libc_atexit
                                                                     - (char *)_start___libc_IO_vtables) )
    {
      v176 = *(__int64 (__fastcall **)(char *, char *, __int64))(v174 + 56);
      v88 = (char *)v172;
      goto LABEL_300;
    }
LABEL_525:
    v318 = (char *)v126;
    v321.m128_i32[0] = v127;
    IO_vtable_check(v122, v121, v175, v125, (u32 *)v126, v127);
    v176 = *(__int64 (__fastcall **)(char *, char *, __int64))(v174 + 56);
    v126 = (__int64)v318;
    LODWORD(v127) = v321.m128_i32[0];
    if ( !v320 )
      v88 = (char *)v172;
    goto LABEL_300;
  }
  v225 = (char *)v172;
  if ( !v173 )
    goto LABEL_519;
  v321.m128_u64[0] = v166;
  v226 = v127;
  v227 = v173;
  v228 = v323;
  while ( 1 )
  {
    v121 = (unsigned __int8)*v225++;
    v229 = (_BYTE *)*((_QWORD *)v228 + 5);
    if ( (unsigned __int64)v229 >= *((_QWORD *)v228 + 6) )
      break;
    *((_QWORD *)v228 + 5) = v229 + 1;
    *v229 = v121;
LABEL_414:
    v125 = v227 + (char *)v172 - v225;
    if ( !v125 )
    {
      v166 = v321.m128_u64[0];
      v107 = v226 + (_DWORD)v225 - (_DWORD)v172;
      goto LABEL_302;
    }
  }
  if ( (unsigned int)_overflow((__int64)v228, v121, v124, v125, (u32 *)v126, v127) != -1 )
    goto LABEL_414;
  v107 = -1;
  if ( v303 )
    return (unsigned __int32)-1;
  free((__int64)v307, v121, v124, v230, (u32 *)v126, v127);
  return v107;
}
// 454AF0: variable 'a4' is possibly undefined
// 454AF0: variable 'a5' is possibly undefined
// 454AF0: variable 'a6' is possibly undefined
// 454EF3: variable 'v124' is possibly undefined
// 454EF3: variable 'v125' is possibly undefined
// 454EF3: variable 'v126' is possibly undefined
// 454F1E: variable 'v127' is possibly undefined
// 4553EB: variable 'v137' is possibly undefined
// 4565E9: variable 'v267' is possibly undefined
// 4565E9: variable 'v268' is possibly undefined
// 4565E9: variable 'v269' is possibly undefined
// 4565E9: variable 'v270' is possibly undefined
// 4556F2: variable 'v178' is possibly undefined
// 45575B: variable 'v135' is possibly undefined
// 45575B: variable 'v136' is possibly undefined
// 455F36: variable 'v230' is possibly undefined
// 456531: variable 'v82' is possibly undefined
// 456531: variable 'v83' is possibly undefined
// 456531: variable 'v84' is possibly undefined
// 456531: variable 'v85' is possibly undefined
// 45678C: variable 'v161' is possibly undefined
// 401040: using guessed type __int64 __fastcall j_memcpy(_QWORD, _QWORD, _QWORD);
// 4010A8: using guessed type __int64 __fastcall j_wmemset(_QWORD, _QWORD, _QWORD);
// 4010B0: using guessed type __int64 __fastcall j_mempcpy(_QWORD, _QWORD, _QWORD);
// 4010C8: using guessed type __int64 __fastcall j_strlen_ifunc(_QWORD);
// 49153F: using guessed type void *__ptr32 off_49153F;
// 4915B0: using guessed type __int128 xmmword_4915B0;
// 4915C0: using guessed type __int128 xmmword_4915C0;
// 493FA0: using guessed type unsigned __int64 _tens[1728];
// 4A9C40: using guessed type u32 _start___libc_IO_vtables[48];
// 4AA2E8: using guessed type __int64 (__fastcall *_start___libc_atexit)();

//----- (0000000000456AB0) ----------------------------------------------------
__int64 __fastcall _printf_fp(char *a1, __int64 a2, long double **a3, __int64 a4, u32 *a5, __int64 a6)
{
  return _printf_fp_l(a1, (_QWORD *)__readfsqword(0xFFFFFFA8), a2, a3, a5, a6);
}

//----- (0000000000456AD0) ----------------------------------------------------
__int64 __fastcall _guess_grouping(unsigned int a1, char *a2)
{
  if ( (unsigned __int8)(*a2 - 1) > 0x7Du )
    return 0LL;
  else
    return _guess_grouping_part_0(a1, a2);
}

//----- (0000000000456AF0) ----------------------------------------------------
__int64 __fastcall register_printf_specifier(signed int a1, __int64 a2, __int64 a3, __int64 a4, u32 *a5, __int64 a6)
{
  __int64 v9; // rdx
  u32 *v10; // rax
  __int64 v11; // rdx

  if ( (unsigned int)a1 <= 0xFF )
  {
    _RSI = 1LL;
    if ( _libc_multiple_threads )
    {
      if ( !_InterlockedCompareExchange(&lock_1, 1, 0) )
      {
LABEL_7:
        v9 = _printf_function_table;
        if ( _printf_function_table )
        {
          v10 = (u32 *)_printf_arginfo_table;
        }
        else
        {
          _RSI = 16LL;
          v10 = calloc(256LL, 0x10uLL, _printf_function_table, a4, a5, a6);
          v11 = 0xFFFFFFFFLL;
          _printf_arginfo_table = (__int64)v10;
          if ( !v10 )
          {
LABEL_10:
            if ( _libc_multiple_threads )
            {
              if ( !_InterlockedDecrement(&lock_1) )
                return (unsigned int)v11;
            }
            else if ( !--lock_1 )
            {
              return (unsigned int)v11;
            }
            _lll_unlock_wake_private((u32 *)&lock_1, _RSI, v11, a4, a5, a6);
            return (unsigned int)v11;
          }
          v9 = (__int64)(v10 + 512);
          _printf_function_table = (__int64)(v10 + 512);
        }
        *(_QWORD *)(v9 + 8LL * a1) = a2;
        v11 = 0LL;
        *(_QWORD *)&v10[2 * a1] = a3;
        goto LABEL_10;
      }
    }
    else
    {
      __asm { cmpxchg cs:lock_1, esi }
      if ( !_libc_multiple_threads )
        goto LABEL_7;
    }
    _lll_lock_wait_private((u32 *)&lock_1, 1LL, a3, a4, a5, a6);
    goto LABEL_7;
  }
  __writefsdword(0xFFFFFFC0, 0x16u);
  return 0xFFFFFFFFLL;
}
// 456B95: variable 'a4' is possibly undefined
// 456B95: variable 'a5' is possibly undefined
// 456B95: variable 'a6' is possibly undefined
// 456BA2: variable 'v11' is possibly undefined
// 4AAFE4: using guessed type int lock_1;
// 4AB820: using guessed type int _libc_multiple_threads;
// 4ABA08: using guessed type __int64 _printf_function_table;
// 4ABA28: using guessed type __int64 _printf_arginfo_table;

//----- (0000000000456C00) ----------------------------------------------------
__int64 __fastcall register_printf_function(signed int a1, __int64 a2, __int64 a3, __int64 a4, u32 *a5, __int64 a6)
{
  return register_printf_specifier(a1, a2, a3, a4, a5, a6);
}

//----- (0000000000456C10) ----------------------------------------------------
__int64 __fastcall _printf_fphex(__int64 a1, __int64 a2, const __m128i **a3, __int64 a4, __int64 a5, __int64 a6)
{
  char *v6; // r12
  char v8; // al
  __int64 v9; // rcx
  const __m128i *v10; // rcx
  __int64 v11; // rbp
  int v12; // er13
  int v13; // ecx
  _DWORD *v14; // rbp
  unsigned __int64 v15; // rax
  int v16; // esi
  __int64 v17; // r8
  const char *v18; // rdi
  unsigned __int64 k; // rdx
  char *v20; // rdi
  _DWORD *v21; // rcx
  char *v22; // rdx
  char *v23; // rdi
  __m128i v24; // xmm5
  __int64 v25; // rax
  __int64 v26; // r9
  const char *v27; // rcx
  unsigned __int64 v28; // r14
  __int64 v29; // r8
  unsigned __int64 m; // rax
  char *v31; // rcx
  _DWORD *v32; // rdx
  char *v33; // rax
  char *v34; // rdx
  __int64 v35; // r8
  __int32 v36; // eax
  __int32 v37; // eax
  int v38; // er10
  u32 v39; // er9
  __int64 v40; // r11
  _BYTE *v41; // r15
  signed __int64 v42; // rax
  __int64 v43; // r8
  char v44; // dl
  int v45; // ecx
  __int64 v46; // rdi
  __int64 v47; // rsi
  __int64 v48; // rdx
  __int64 v49; // rcx
  __int16 v50; // ax
  unsigned __int64 v51; // r15
  __int64 v52; // rax
  __int64 v53; // r9
  char *v54; // r11
  __int64 v55; // r8
  char *v56; // rcx
  char v57; // r15
  int v58; // eax
  unsigned __int64 v59; // r8
  unsigned __int64 v60; // rdx
  int v61; // eax
  __int64 v62; // r15
  __int64 v63; // rax
  int v64; // er15
  __int64 v65; // rax
  __int64 v66; // rax
  _DWORD *v67; // rsi
  unsigned __int64 v68; // rdi
  unsigned __int8 *v69; // rdx
  __int64 v70; // rsi
  bool v71; // al
  int v72; // er15
  __int64 v73; // rax
  int v74; // esi
  bool v75; // al
  unsigned __int64 v76; // rdx
  unsigned __int8 *v77; // rbp
  __int64 v78; // rax
  __int64 v79; // r11
  int v80; // er14
  __int64 v81; // r15
  unsigned __int8 *v82; // r12
  int v83; // er13
  __int64 v84; // rsi
  _BYTE *v85; // rax
  unsigned int v86; // ebp
  __int64 v87; // rcx
  unsigned __int64 v88; // rdx
  __int16 v90; // fps
  u32 *v91; // r8
  void *__ptr32 *v92; // r15
  bool v93; // zf
  char v94; // al
  __int64 v95; // rcx
  _BYTE *v96; // rax
  __int64 v97; // r14
  int v98; // er13
  u32 *v99; // r15
  __int64 v100; // rax
  __int64 v101; // rsi
  bool v102; // al
  __int64 v103; // r12
  __int64 v104; // rax
  int v105; // ecx
  __int64 v107; // rbp
  __int64 v108; // rax
  __int64 v109; // rax
  int v110; // ecx
  const char *v111; // rsi
  __int64 v112; // r8
  unsigned __int64 j; // rax
  __int64 v114; // rax
  __int64 v115; // r8
  __int64 v116; // rax
  unsigned __int64 v117; // rdx
  bool v118; // zf
  unsigned int v119; // eax
  int v120; // ecx
  char *v121; // rax
  __int64 v122; // r8
  const char *v123; // rdi
  unsigned __int64 i; // rcx
  _DWORD *v125; // rdx
  char *v126; // rsi
  char *v127; // rcx
  __int64 v128; // rax
  __int64 v129; // rdx
  void *__ptr32 *v130; // r14
  __int64 v131; // rsi
  _BYTE *v132; // rax
  __int64 v133; // rax
  int v134; // eax
  int v135; // eax
  _BYTE *v136; // rax
  __int32 v137; // eax
  _BYTE *v138; // rax
  __int64 v139; // rax
  bool v140; // al
  __int64 v141; // r14
  int v142; // er12
  char *v143; // r13
  bool v144; // al
  __int64 v145; // rax
  __int64 v146; // rsi
  char v147; // al
  __int64 v148; // rax
  int v149; // eax
  _BYTE *v150; // rax
  unsigned __int8 v151; // al
  _BYTE *v152; // rax
  char v153; // di
  __int64 v154; // rsi
  __int64 v155; // rax
  _DWORD *v156; // rdi
  bool v157; // al
  __int64 v158; // rsi
  __int64 v159; // rax
  _DWORD *v160; // rdi
  u32 *v161; // r8
  unsigned __int64 v162; // rdx
  char *v163; // r14
  __int64 v164; // rcx
  int v165; // er15
  char *v166; // r13
  int v167; // er12
  bool v168; // al
  __int64 v169; // rax
  __int64 v170; // rsi
  __int64 v171; // rsi
  __int64 v172; // r12
  __int64 v173; // rax
  signed __int64 v174; // r14
  unsigned __int8 *v175; // rbp
  __int64 v176; // r13
  char *v177; // r15
  signed __int64 v178; // r13
  __int64 v179; // r14
  int v180; // er12
  __int64 v181; // rsi
  _BYTE *v182; // rax
  _BYTE *v183; // rax
  bool v184; // cf
  _BYTE *v185; // rax
  unsigned int v186; // er14
  unsigned __int8 *v187; // r13
  unsigned __int8 *v188; // r15
  unsigned int v189; // er12
  __int32 v190; // er14
  __int64 v191; // rsi
  _BYTE *v192; // rax
  __int64 v193; // rax
  _BYTE *v194; // rax
  __int64 v195; // rax
  bool v196; // zf
  unsigned int v197; // er15
  __int64 v198; // rax
  char *v199; // rsi
  char v200; // cl
  _BYTE *v201; // rax
  int v202; // edx
  __int64 v203; // rsi
  int v204; // eax
  bool v205; // al
  int v206; // eax
  int v207; // eax
  int v208; // eax
  _BYTE *v209; // rax
  int v210; // eax
  int v211; // eax
  __int64 v212; // rsi
  int v213; // eax
  __int64 v214; // r13
  __int64 v215; // rax
  int v216; // edx
  int v217; // eax
  int v218; // eax
  int v219; // eax
  __int64 v220; // rsi
  int v221; // eax
  bool v222; // al
  int v223; // eax
  int v224; // eax
  __int64 v225; // rsi
  int v226; // eax
  _BOOL4 v227; // [rsp+Ch] [rbp-19Ch]
  int v228; // [rsp+Ch] [rbp-19Ch]
  int v229; // [rsp+Ch] [rbp-19Ch]
  unsigned int v230; // [rsp+Ch] [rbp-19Ch]
  unsigned int v231; // [rsp+Ch] [rbp-19Ch]
  __m128 si128; // [rsp+10h] [rbp-198h] BYREF
  __int64 v233; // [rsp+20h] [rbp-188h]
  char *v234; // [rsp+28h] [rbp-180h]
  char *v235; // [rsp+30h] [rbp-178h]
  char *v236; // [rsp+38h] [rbp-170h]
  __m128 v237; // [rsp+40h] [rbp-168h] BYREF
  char *v238; // [rsp+50h] [rbp-158h]
  char *v239; // [rsp+58h] [rbp-150h]
  char *v240; // [rsp+60h] [rbp-148h]
  char *v241; // [rsp+68h] [rbp-140h]
  long double v242; // [rsp+70h] [rbp-138h]
  long double v243; // [rsp+80h] [rbp-128h]
  char v244; // [rsp+A4h] [rbp-104h] BYREF
  _DWORD v245[13]; // [rsp+FCh] [rbp-ACh] BYREF
  _BYTE v246[11]; // [rsp+130h] [rbp-78h] BYREF
  char v247; // [rsp+13Bh] [rbp-6Dh] BYREF
  char v248[32]; // [rsp+140h] [rbp-68h] BYREF
  char v249[8]; // [rsp+160h] [rbp-48h] BYREF
  unsigned __int64 v250; // [rsp+168h] [rbp-40h]

  v6 = (char *)a2;
  v250 = __readfsqword(0x28u);
  LODWORD(v233) = *(_DWORD *)a2;
  LODWORD(v236) = *(_DWORD *)(a2 + 4);
  v8 = *(_BYTE *)(a2 + 13);
  v227 = (v8 & 4) != 0;
  if ( (v8 & 1) != 0 )
  {
    v87 = *(_QWORD *)__readfsqword(0xFFFFFFB0);
    v235 = *(char **)(v87 + 80);
    LODWORD(v234) = *(_DWORD *)(v87 + 408);
  }
  else
  {
    v9 = *(_QWORD *)__readfsqword(0xFFFFFFB8);
    v235 = *(char **)(v9 + 64);
    LODWORD(v234) = *(_DWORD *)(v9 + 88);
  }
  if ( !*v235 || !(_DWORD)v234 )
    _assert_fail(
      (__int64)"*decimal != '\\0' && decimalwc != L'\\0'",
      (__int64)"../stdio-common/printf_fphex.c",
      0xA5u,
      "__printf_fphex");
  v10 = *a3;
  v11 = *(int *)(a2 + 8);
  if ( (v8 & 0x10) == 0 )
  {
    v88 = *(unsigned __int8 *)(a2 + 12);
    if ( (v88 & 1) != 0 )
    {
      _FST7 = *(long double *)v10;
      *(long double *)&si128 = _FST7;
      v242 = _FST7;
      __asm { fxam }
      v12 = v90 & 0x200;
      v237.m128_i32[0] = (HIBYTE(v90) & 0x45) == 5;
      if ( (HIBYTE(v90) & 0x45) == 5 )
      {
LABEL_100:
        v91 = (u32 *)&unk_49155C;
        v92 = &off_49153F;
        v93 = (*(_WORD *)(__readfsqword(0xFFFFFFF0) + 2 * v11) & 0x100) == 0;
        if ( v93 )
        {
          v91 = (u32 *)&unk_49157C;
          if ( v93 )
            v92 = (void *__ptr32 *)&unk_491547;
        }
        goto LABEL_103;
      }
      v238 = v248;
      v243 = *(long double *)&si128;
      v120 = v11 == 65;
      v14 = v246;
      LODWORD(v239) = si128.m128_u64[0] == 0;
      v121 = (char *)itoa_word(si128.m128_u64[0], (__int64)v249, 0x10u, v120);
      v122 = si128.m128_u64[0];
      v123 = "0";
      v39 = (unsigned int)v239;
      if ( *(_DWORD *)(a2 + 8) != 65 )
        v123 = "0";
      for ( i = si128.m128_u64[0]; ; i >>= 4 )
      {
        v125 = v14 - 1;
        *(v14 - 1) = *(_DWORD *)&v123[4 * (i & 0xF)];
        if ( i <= 0xF )
          break;
        --v14;
      }
      v126 = v238 + 16;
      if ( v121 <= v238 + 16 )
      {
        v28 = (unsigned __int64)(v121 + 1);
        LOBYTE(v239) = *v121;
      }
      else
      {
        v127 = v121;
        do
        {
          --v127;
          --v125;
          *v127 = 48;
          *v125 = 48;
        }
        while ( v127 != v126 );
        LOBYTE(v239) = 48;
        v14 += v127 - v121;
        v28 = (unsigned __int64)(v238 + 17);
      }
      v38 = WORD4(v243) & 0x7FFF;
      if ( (WORD4(v243) & 0x7FFF) != 0 )
      {
        if ( (WORD4(v243) & 0x7FFFu) <= 0x4001 )
        {
          v237.m128_i32[0] = 1;
          v38 = 16386 - v38;
        }
        else
        {
          v38 -= 16386;
        }
      }
      else
      {
        v237.m128_i32[0] = v122 != 0;
        if ( v122 )
          v38 = 16385;
      }
    }
    else
    {
      *(_QWORD *)&v242 = v10->m128i_i64[0];
      v12 = _mm_movemask_pd((__m128d)*(unsigned __int64 *)&v242) & 1;
      if ( fabs(*(double *)&v242) > 1.797693134862316e308 )
        goto LABEL_100;
      v110 = v11 == 65;
      v111 = "0";
      v112 = LODWORD(v242) | ((unsigned __int64)(DWORD1(v242) & 0xFFFFF) << 32);
      v93 = (_DWORD)v11 == 65;
      v14 = v246;
      if ( !v93 )
        v111 = "0";
      for ( j = LODWORD(v242) | ((unsigned __int64)(DWORD1(v242) & 0xFFFFF) << 32); ; j >>= 4 )
      {
        *--v14 = *(_DWORD *)&v111[4 * (j & 0xF)];
        if ( j <= 0xF )
          break;
      }
      v237.m128_i32[0] = v112 == 0;
      si128.m128_u64[0] = v112;
      v238 = v248;
      v114 = itoa_word(v112, (__int64)v249, 0x10u, v110);
      v115 = si128.m128_u64[0];
      v39 = v237.m128_i32[0];
      v28 = v114;
      if ( v14 > v245 )
      {
        v116 = 0LL;
        do
        {
          v14[v116 - 1] = 48;
          *(_BYTE *)(v28 + v116-- - 1) = 48;
        }
        while ( ~(((unsigned __int64)v14 + ~(unsigned __int64)v245) >> 2) != v116 );
        v117 = ~(((unsigned __int64)v14 + ~(unsigned __int64)v245) >> 2);
        v28 += v117;
        v14 += v117;
      }
      LOBYTE(v239) = ((WORD3(v242) & 0x7FF0) != 0) + 48;
      v237.m128_i32[0] = (WORD3(v242) >> 4) & 0x7FF;
      if ( ((WORD3(v242) >> 4) & 0x7FF) == 0 )
      {
        if ( v115 )
        {
          v40 = v28;
          v38 = 1022;
          v237.m128_i32[0] = 1;
LABEL_34:
          if ( v245[12] == 48 )
          {
            v41 = v246;
            v28 = (unsigned __int64)(v238 + 32);
            do
            {
              v41 -= 4;
              --v28;
            }
            while ( *((_DWORD *)v41 - 1) == 48 );
          }
          else
          {
            v28 = (unsigned __int64)(v238 + 32);
          }
          v42 = v28 - v40;
          if ( (_DWORD)v233 == -1 )
          {
            LODWORD(v233) = v28 - v40;
            goto LABEL_52;
          }
          v43 = (int)v233;
          if ( (int)v233 >= v42 )
          {
LABEL_52:
            v51 = v38;
            v240 = (char *)v40;
            v238 = &v247;
            v52 = itoa_word(v38, (__int64)v248, 0xAu, 0);
            v54 = v240;
            v55 = (__int64)v238;
            v56 = &v244;
            si128.m128_u64[0] = v52;
            while ( 1 )
            {
              v56 -= 4;
              *(_DWORD *)v56 = *(_DWORD *)&itowa_lower_digits[4 * (v51 % 0xA)];
              if ( v51 <= 9 )
                break;
              v51 /= 0xAuLL;
            }
            v57 = v6[12];
            v58 = 4;
            if ( !v12 )
              v58 = ((v57 & 0x50) != 0) + 3;
            v59 = v55 + 5;
            v238 = (char *)(v59 - si128.m128_u64[0]);
            v60 = (unsigned int)((_DWORD)v236 - 2 - (v59 - si128.m128_i32[0]) - (v233 + v58));
            if ( (int)v233 > 0 || (v57 & 8) != 0 )
            {
              v53 = v227;
              v61 = 1;
              if ( !v227 )
              {
                v241 = v56;
                LODWORD(v240) = v60;
                v236 = v54;
                v61 = j_strlen_ifunc(v235);
                v56 = v241;
                LODWORD(v60) = (_DWORD)v240;
                v54 = v236;
              }
              v60 = (unsigned int)(v60 - v61);
            }
            LODWORD(v236) = v60;
            if ( (v57 & 0x20) != 0 || *((_DWORD *)v6 + 4) == 48 || (int)v236 <= 0 )
            {
              v64 = 0;
              if ( v12 )
              {
LABEL_68:
                if ( v227 )
                {
                  v65 = *(_QWORD *)(a1 + 160);
                  if ( v65 )
                  {
                    v60 = *(_QWORD *)(v65 + 32);
                    if ( v60 < *(_QWORD *)(v65 + 40) )
                    {
                      *(_QWORD *)(v65 + 32) = v60 + 4;
                      *(_DWORD *)v60 = 45;
LABEL_72:
                      ++v64;
                      goto LABEL_73;
                    }
                  }
                  v241 = v56;
                  v220 = 45LL;
                  v240 = v54;
                  goto LABEL_364;
                }
                v194 = *(_BYTE **)(a1 + 40);
                if ( (unsigned __int64)v194 < *(_QWORD *)(a1 + 48) )
                {
                  v60 = (unsigned __int64)(v194 + 1);
                  *(_QWORD *)(a1 + 40) = v194 + 1;
                  *v194 = 45;
                  goto LABEL_72;
                }
                v241 = v56;
                v225 = 45LL;
                v240 = v54;
                goto LABEL_377;
              }
            }
            else
            {
              v62 = (int)v236;
              v241 = v56;
              v240 = v54;
              if ( v227 )
              {
                v63 = IO_wpadn((char *)a1, 32LL, (int)v236, (__int64)v56, (u32 *)v227, v53);
                v54 = v240;
                v56 = v241;
              }
              else
              {
                v63 = IO_padn((char *)a1, (char *)0x20, (int)v236, (__int64)v56, 0LL, v53);
                v56 = v241;
                v54 = v240;
              }
              if ( v63 != v62 )
                return (unsigned int)-1;
              v64 = (int)v236;
              if ( v12 )
                goto LABEL_68;
            }
            v147 = v6[12];
            if ( (v147 & 0x40) != 0 )
            {
              if ( v227 )
              {
                v148 = *(_QWORD *)(a1 + 160);
                if ( v148 )
                {
                  v60 = *(_QWORD *)(v148 + 32);
                  if ( v60 < *(_QWORD *)(v148 + 40) )
                  {
                    *(_QWORD *)(v148 + 32) = v60 + 4;
                    *(_DWORD *)v60 = 43;
                    goto LABEL_72;
                  }
                }
                v241 = v56;
                v220 = 43LL;
                v240 = v54;
                goto LABEL_364;
              }
              v201 = *(_BYTE **)(a1 + 40);
              if ( (unsigned __int64)v201 < *(_QWORD *)(a1 + 48) )
              {
                v60 = (unsigned __int64)(v201 + 1);
                *(_QWORD *)(a1 + 40) = v201 + 1;
                *v201 = 43;
                goto LABEL_72;
              }
              v241 = v56;
              v225 = 43LL;
              v240 = v54;
            }
            else
            {
              if ( (v147 & 0x10) == 0 )
              {
LABEL_73:
                if ( !v227 )
                {
                  v150 = *(_BYTE **)(a1 + 40);
                  if ( (unsigned __int64)v150 >= *(_QWORD *)(a1 + 48) )
                  {
                    v241 = v56;
                    v240 = v54;
                    v218 = _overflow(a1, 48LL, v60, (__int64)v56, (u32 *)v59, v53);
                    v54 = v240;
                    v56 = v241;
                    if ( v218 == -1 )
                      return (unsigned int)-1;
                    v151 = *((_DWORD *)v6 + 2) + 23;
                  }
                  else
                  {
                    *(_QWORD *)(a1 + 40) = v150 + 1;
                    *v150 = 48;
                    v151 = *((_DWORD *)v6 + 2) + 23;
                  }
                  v69 = *(unsigned __int8 **)(a1 + 40);
                  if ( (unsigned __int64)v69 < *(_QWORD *)(a1 + 48) )
                  {
                    v72 = v64 + 2;
                    *(_QWORD *)(a1 + 40) = v69 + 1;
                    *v69 = v151;
                    if ( (v6[12] & 0x20) != 0 || *((_DWORD *)v6 + 4) != 48 || (int)v236 <= 0 )
                      goto LABEL_233;
                    v214 = (int)v236;
                    goto LABEL_361;
                  }
                  v241 = v56;
                  v240 = v54;
                  v217 = _overflow(a1, v151, (__int64)v69, (__int64)v56, (u32 *)v59, v53);
                  v54 = v240;
                  v56 = v241;
                  v71 = v217 == -1;
LABEL_79:
                  if ( v71 )
                    return (unsigned int)-1;
                  v72 = v64 + 2;
                  if ( (v6[12] & 0x20) != 0 || *((_DWORD *)v6 + 4) != 48 || (int)v236 <= 0 )
                  {
LABEL_83:
                    if ( v227 )
                    {
                      v73 = *(_QWORD *)(a1 + 160);
                      if ( v73 && (v69 = *(unsigned __int8 **)(v73 + 32), (unsigned __int64)v69 < *(_QWORD *)(v73 + 40)) )
                      {
                        v74 = (char)v239;
                        *(_QWORD *)(v73 + 32) = v69 + 4;
                        *(_DWORD *)v69 = v74;
                        v75 = v74 == -1;
                      }
                      else
                      {
                        v241 = v56;
                        v240 = v54;
                        v208 = _woverflow(a1, (unsigned int)(char)v239, (__int64)v69, (__int64)v56, (u32 *)v59, v53);
                        v54 = v240;
                        v56 = v241;
                        v75 = v208 == -1;
                      }
                      goto LABEL_87;
                    }
LABEL_233:
                    v152 = *(_BYTE **)(a1 + 40);
                    if ( (unsigned __int64)v152 < *(_QWORD *)(a1 + 48) )
                    {
                      v153 = (char)v239;
                      *(_QWORD *)(a1 + 40) = v152 + 1;
                      v76 = (unsigned int)(v72 + 1);
                      *v152 = v153;
                      if ( (int)v233 > 0 )
                      {
LABEL_89:
                        LODWORD(v239) = v76;
                        if ( v227 )
                        {
                          v139 = *(_QWORD *)(a1 + 160);
                          if ( v139 && (v76 = *(_QWORD *)(v139 + 32), v76 < *(_QWORD *)(v139 + 40)) )
                          {
                            *(_QWORD *)(v139 + 32) = v76 + 4;
                            v93 = (_DWORD)v234 == -1;
                            *(_DWORD *)v76 = (_DWORD)v234;
                            v140 = v93;
                          }
                          else
                          {
                            v239 = v56;
                            v235 = v54;
                            v149 = _woverflow(a1, (unsigned int)v234, v76, (__int64)v56, (u32 *)v59, v53);
                            v54 = v235;
                            v56 = v239;
                            v140 = v149 == -1;
                          }
                          if ( v140 )
                            return (unsigned int)-1;
                          v59 = (unsigned int)(v72 + 2);
                          if ( (int)v233 <= 0 )
                            goto LABEL_383;
                          v141 = v28 - (_QWORD)v54;
                          v234 = (char *)v141;
                          v233 = (int)v233;
                          if ( (int)v233 <= v141 )
                            v141 = (int)v233;
                          if ( v141 )
                          {
                            v235 = v6;
                            v142 = v141 + 3;
                            v143 = v56;
                            while ( 1 )
                            {
                              v145 = *(_QWORD *)(a1 + 160);
                              v146 = (unsigned int)*v14++;
                              if ( v145 && (v76 = *(_QWORD *)(v145 + 32), v76 < *(_QWORD *)(v145 + 40)) )
                              {
                                *(_QWORD *)(v145 + 32) = v76 + 4;
                                v144 = (_DWORD)v146 == -1;
                                *(_DWORD *)v76 = v146;
                              }
                              else
                              {
                                v144 = (unsigned int)_woverflow(a1, v146, v76, (__int64)v56, (u32 *)v59, v53) == -1;
                              }
                              if ( v144 )
                                return (unsigned int)-1;
                              v59 = (unsigned int)(v142 + v72 - v141--);
                              if ( !v141 )
                              {
                                v6 = v235;
                                v56 = v143;
                                break;
                              }
                            }
                          }
                          v176 = v233 - (_QWORD)v234;
                          if ( v233 - (__int64)v234 <= 0 )
                          {
LABEL_383:
                            v76 = (unsigned int)v59;
                            v154 = (unsigned int)(*((_DWORD *)v6 + 2) + 15);
                            goto LABEL_237;
                          }
                          v202 = v233 - (_DWORD)v234;
                          v234 = v56;
                          LODWORD(v233) = v59;
                          v195 = IO_wpadn((char *)a1, 48LL, v202, (__int64)v56, (u32 *)v59, v53);
                          v59 = (unsigned int)v233;
                          v56 = v234;
                        }
                        else
                        {
                          v77 = (unsigned __int8 *)v235;
                          v240 = v56;
                          v234 = v54;
                          v78 = j_strlen_ifunc(v235);
                          v79 = (__int64)v234;
                          v56 = v240;
                          v76 = (unsigned int)v239;
                          if ( v78 )
                          {
                            v239 = (char *)v28;
                            v80 = v72;
                            v81 = (__int64)v240;
                            v240 = v6;
                            v82 = &v77[v78];
                            v83 = (int)v235;
                            do
                            {
                              v84 = *v77++;
                              v85 = *(_BYTE **)(a1 + 40);
                              if ( (unsigned __int64)v85 < *(_QWORD *)(a1 + 48) )
                              {
                                *(_QWORD *)(a1 + 40) = v85 + 1;
                                *v85 = v84;
                              }
                              else if ( (unsigned int)_overflow(a1, v84, v76, (__int64)v56, (u32 *)v59, v53) == -1 )
                              {
                                return (unsigned int)-1;
                              }
                              v76 = (unsigned int)(v80 + (_DWORD)v77 + 1 - v83);
                            }
                            while ( v82 != v77 );
                            v79 = (__int64)v234;
                            v28 = (unsigned __int64)v239;
                            v56 = (char *)v81;
                            v6 = v240;
                          }
                          if ( (int)v233 <= 0 )
                            goto LABEL_274;
                          v174 = v28 - v79;
                          v175 = (unsigned __int8 *)v79;
                          v59 = (unsigned int)v76;
                          v176 = (int)v233 - v174;
                          if ( (int)v233 <= v174 )
                            v174 = (int)v233;
                          if ( v174 )
                          {
                            v233 = v176;
                            v177 = v56;
                            v178 = v174;
                            v179 = v79;
                            v234 = v6;
                            v180 = v76;
                            do
                            {
                              v181 = *v175++;
                              v182 = *(_BYTE **)(a1 + 40);
                              if ( (unsigned __int64)v182 < *(_QWORD *)(a1 + 48) )
                              {
                                *(_QWORD *)(a1 + 40) = v182 + 1;
                                *v182 = v181;
                              }
                              else if ( (unsigned int)_overflow(a1, v181, v76, (__int64)v56, (u32 *)v59, v53) == -1 )
                              {
                                return (unsigned int)-1;
                              }
                              v59 = (unsigned int)(v180 + (_DWORD)v175 - v179);
                            }
                            while ( v178 + v179 - (_QWORD)v175 );
                            v176 = v233;
                            v6 = v234;
                            v56 = v177;
                          }
                          v76 = (unsigned int)v59;
                          if ( v176 <= 0 )
                          {
LABEL_274:
                            LODWORD(v154) = *((_DWORD *)v6 + 2) + 15;
                            goto LABEL_275;
                          }
                          v234 = v56;
                          LODWORD(v233) = v59;
                          v195 = IO_padn((char *)a1, (char *)0x30, v176, (__int64)v56, (u32 *)v59, v53);
                          v56 = v234;
                          v59 = (unsigned int)v233;
                        }
                        if ( v195 != v176 )
                          return (unsigned int)-1;
                        v76 = (unsigned int)(v59 + v195);
LABEL_236:
                        v154 = (unsigned int)(*((_DWORD *)v6 + 2) + 15);
                        if ( v227 )
                        {
LABEL_237:
                          v155 = *(_QWORD *)(a1 + 160);
                          if ( v155 && (v156 = *(_DWORD **)(v155 + 32), (unsigned __int64)v156 < *(_QWORD *)(v155 + 40)) )
                          {
                            v59 = (unsigned __int64)(v156 + 1);
                            *(_QWORD *)(v155 + 32) = v156 + 1;
                            v157 = (_DWORD)v154 == -1;
                            *v156 = v154;
                          }
                          else
                          {
                            v234 = v56;
                            LODWORD(v233) = v76;
                            v210 = _woverflow(a1, v154, v76, (__int64)v56, (u32 *)v59, v53);
                            v76 = (unsigned int)v233;
                            v56 = v234;
                            v157 = v210 == -1;
                          }
                          goto LABEL_240;
                        }
LABEL_275:
                        v183 = *(_BYTE **)(a1 + 40);
                        if ( (unsigned __int64)v183 < *(_QWORD *)(a1 + 48) )
                        {
                          v184 = v237.m128_i32[0] == 0;
                          v56 = v183 + 1;
                          *(_QWORD *)(a1 + 40) = v183 + 1;
                          *v183 = v154;
                          v158 = v184 ? 43 : 45;
                          goto LABEL_277;
                        }
                        v234 = v56;
                        LODWORD(v233) = v76;
                        v224 = _overflow(a1, (unsigned __int8)v154, v76, (__int64)v56, (u32 *)v59, v53);
                        v76 = (unsigned int)v233;
                        v56 = v234;
                        v157 = v224 == -1;
LABEL_240:
                        if ( v157 )
                          return (unsigned int)-1;
                        v53 = v227;
                        v158 = v237.m128_i32[0] == 0 ? 43 : 45;
                        if ( v227 )
                        {
                          v159 = *(_QWORD *)(a1 + 160);
                          if ( v159 )
                          {
                            v160 = *(_DWORD **)(v159 + 32);
                            if ( (unsigned __int64)v160 < *(_QWORD *)(v159 + 40) )
                            {
                              v161 = v160 + 1;
                              v162 = (unsigned int)(v76 + 2);
                              *(_QWORD *)(v159 + 32) = v160 + 1;
                              *v160 = v158;
                              goto LABEL_245;
                            }
                          }
                          si128.m128_u64[0] = (unsigned __int64)v56;
                          LODWORD(v233) = v76;
                          v211 = _woverflow(a1, v158, v76, (__int64)v56, (u32 *)v59, v227);
                          v56 = (char *)si128.m128_u64[0];
                          if ( v211 != -1 )
                          {
                            v162 = (unsigned int)(v233 + 2);
LABEL_245:
                            v163 = v56;
                            v86 = v162;
                            v164 = (unsigned int)(v162 + 1);
                            v165 = (_DWORD)v238 - 1;
                            v166 = v238 - 1;
                            if ( v238 )
                            {
                              v233 = (__int64)v6;
                              v167 = v162 + 1;
                              while ( 1 )
                              {
                                v169 = *(_QWORD *)(a1 + 160);
                                v170 = *(unsigned int *)v163;
                                if ( v169 && (v162 = *(_QWORD *)(v169 + 32), v162 < *(_QWORD *)(v169 + 40)) )
                                {
                                  *(_QWORD *)(v169 + 32) = v162 + 4;
                                  v168 = (_DWORD)v170 == -1;
                                  *(_DWORD *)v162 = v170;
                                }
                                else
                                {
                                  v168 = (unsigned int)_woverflow(a1, v170, v162, v164, v161, v53) == -1;
                                }
                                if ( v168 )
                                  return (unsigned int)-1;
                                v163 += 4;
                                v86 = v167 + v165 - (_DWORD)v166--;
                                if ( v166 == (char *)-1LL )
                                  goto LABEL_255;
                              }
                            }
                            goto LABEL_256;
                          }
                          return (unsigned int)-1;
                        }
LABEL_277:
                        v185 = *(_BYTE **)(a1 + 40);
                        if ( (unsigned __int64)v185 >= *(_QWORD *)(a1 + 48) )
                        {
                          LODWORD(v233) = v76;
                          v223 = _overflow(a1, v158, v76, (__int64)v56, (u32 *)v59, v53);
                          v76 = (unsigned int)v233;
                          if ( v223 == -1 )
                            return (unsigned int)-1;
                          v186 = v233 + 2;
                        }
                        else
                        {
                          v164 = (__int64)(v185 + 1);
                          v186 = v76 + 2;
                          *(_QWORD *)(a1 + 40) = v185 + 1;
                          *v185 = v158;
                        }
                        v187 = (unsigned __int8 *)si128.m128_u64[0];
                        v188 = (unsigned __int8 *)&v238[si128.m128_u64[0]];
                        if ( v238 )
                        {
                          v233 = (__int64)v6;
                          v189 = v186;
                          v190 = si128.m128_i32[0];
                          do
                          {
                            v191 = *v187++;
                            v192 = *(_BYTE **)(a1 + 40);
                            if ( (unsigned __int64)v192 < *(_QWORD *)(a1 + 48) )
                            {
                              v76 = (unsigned __int64)(v192 + 1);
                              *(_QWORD *)(a1 + 40) = v192 + 1;
                              *v192 = v191;
                            }
                            else if ( (unsigned int)_overflow(a1, v191, v76, v164, (u32 *)v59, v53) == -1 )
                            {
                              return (unsigned int)-1;
                            }
                            v86 = v189 + (_DWORD)v187 - v190;
                          }
                          while ( v188 != v187 );
LABEL_255:
                          v6 = (char *)v233;
                        }
                        else
                        {
                          v86 = v186;
                        }
LABEL_256:
                        if ( (v6[12] & 0x20) != 0 )
                        {
                          v171 = *((unsigned int *)v6 + 4);
                          if ( (_DWORD)v171 != 48 && (int)v236 > 0 )
                          {
                            v172 = (int)v236;
                            if ( v227 )
                              v173 = IO_wpadn((char *)a1, v171, (int)v236, v164, (u32 *)v227, v53);
                            else
                              v173 = IO_padn((char *)a1, (char *)v171, (int)v236, v164, 0LL, v53);
                            if ( v173 == v172 )
                            {
                              v86 += (unsigned int)v236;
                              return v86;
                            }
                            return (unsigned int)-1;
                          }
                        }
                        return v86;
                      }
LABEL_235:
                      if ( (v6[12] & 8) == 0 )
                        goto LABEL_236;
                      goto LABEL_89;
                    }
                    v241 = v56;
                    v240 = v54;
                    v219 = _overflow(a1, (unsigned __int8)v239, (__int64)v69, (__int64)v56, (u32 *)v59, v53);
                    v54 = v240;
                    v56 = v241;
                    v75 = v219 == -1;
LABEL_87:
                    if ( v75 )
                      return (unsigned int)-1;
                    v76 = (unsigned int)(v72 + 1);
                    if ( (int)v233 > 0 )
                      goto LABEL_89;
                    goto LABEL_235;
                  }
                  v214 = (int)v236;
                  if ( v227 )
                  {
                    v241 = v56;
                    v240 = v54;
                    v215 = IO_wpadn((char *)a1, 48LL, (int)v236, (__int64)v56, (u32 *)v59, v53);
                    v54 = v240;
                    v56 = v241;
LABEL_352:
                    if ( v214 != v215 )
                      return (unsigned int)-1;
                    v72 += (int)v236;
                    goto LABEL_83;
                  }
LABEL_361:
                  v241 = v56;
                  v240 = v54;
                  v215 = IO_padn((char *)a1, (char *)0x30, v214, (__int64)v56, (u32 *)v59, v53);
                  v56 = v241;
                  v54 = v240;
                  goto LABEL_352;
                }
                v66 = *(_QWORD *)(a1 + 160);
                if ( v66 && (v67 = *(_DWORD **)(v66 + 32), v68 = *(_QWORD *)(v66 + 40), (unsigned __int64)v67 < v68) )
                {
                  v69 = (unsigned __int8 *)(v67 + 1);
                  *(_QWORD *)(v66 + 32) = v67 + 1;
                  *v67 = 48;
                  v70 = (unsigned int)(*((_DWORD *)v6 + 2) + 23);
                }
                else
                {
                  v241 = v56;
                  v240 = v54;
                  v207 = _woverflow(a1, 48LL, v60, (__int64)v56, (u32 *)v59, v53);
                  v54 = v240;
                  v56 = v241;
                  if ( v207 == -1 )
                    return (unsigned int)-1;
                  v70 = (unsigned int)(*((_DWORD *)v6 + 2) + 23);
                  v66 = *(_QWORD *)(a1 + 160);
                  if ( !v66 )
                  {
LABEL_328:
                    v241 = v56;
                    v240 = v54;
                    v206 = _woverflow(a1, v70, (__int64)v69, (__int64)v56, (u32 *)v59, v53);
                    v54 = v240;
                    v56 = v241;
                    v71 = v206 == -1;
                    goto LABEL_79;
                  }
                  v69 = *(unsigned __int8 **)(v66 + 32);
                  v68 = *(_QWORD *)(v66 + 40);
                }
                if ( (unsigned __int64)v69 < v68 )
                {
                  *(_QWORD *)(v66 + 32) = v69 + 4;
                  v71 = (_DWORD)v70 == -1;
                  *(_DWORD *)v69 = v70;
                  goto LABEL_79;
                }
                goto LABEL_328;
              }
              v60 = v227;
              if ( v227 )
              {
                v193 = *(_QWORD *)(a1 + 160);
                if ( v193 )
                {
                  v60 = *(_QWORD *)(v193 + 32);
                  if ( v60 < *(_QWORD *)(v193 + 40) )
                  {
                    *(_QWORD *)(v193 + 32) = v60 + 4;
                    *(_DWORD *)v60 = 32;
                    goto LABEL_72;
                  }
                }
                v241 = v56;
                v220 = 32LL;
                v240 = v54;
LABEL_364:
                v221 = _woverflow(a1, v220, v60, (__int64)v56, (u32 *)v59, v53);
                v54 = v240;
                v56 = v241;
                v222 = v221 == -1;
                goto LABEL_365;
              }
              v209 = *(_BYTE **)(a1 + 40);
              if ( (unsigned __int64)v209 < *(_QWORD *)(a1 + 48) )
              {
                v60 = (unsigned __int64)(v209 + 1);
                *(_QWORD *)(a1 + 40) = v209 + 1;
                *v209 = 32;
                goto LABEL_72;
              }
              v241 = v56;
              v225 = 32LL;
              v240 = v54;
            }
LABEL_377:
            v226 = _overflow(a1, v225, v60, (__int64)v56, (u32 *)v59, v53);
            v54 = v240;
            v56 = v241;
            v222 = v226 == -1;
LABEL_365:
            if ( v222 )
              return (unsigned int)-1;
            goto LABEL_72;
          }
          v44 = (char)v239;
          if ( (int)v233 > 0 )
            v44 = *(_BYTE *)(v40 + (int)v233 - 1);
          v45 = *(unsigned __int8 *)(v40 + (int)v233);
          if ( (unsigned __int8)(v44 - 65) > 5u )
          {
            v46 = (unsigned int)(v44 - 87);
            if ( (unsigned __int8)(v44 - 97) > 5u )
              v46 = (unsigned int)(v44 - 48);
          }
          else
          {
            v46 = (unsigned int)(v44 - 55);
          }
          v47 = (unsigned int)(v45 - 65);
          if ( (unsigned __int8)(v45 - 65) > 5u )
          {
            if ( (unsigned __int8)(v45 - 97) > 5u )
            {
              v48 = (unsigned int)((char)v45 - 48);
              if ( (((_BYTE)v45 - 48) & 7) == 0 )
              {
                v47 = (unsigned int)v233;
                v49 = (int)v233 + 1 < v42;
LABEL_46:
                v50 = LOWORD(v243) & 0xC00;
                if ( (LOWORD(v243) & 0xC00) != 1024 )
                {
                  if ( (LOWORD(v243) & 0xC00u) <= 0x400 )
                  {
                    if ( !v50 )
                    {
                      if ( (int)v48 <= 7 || (((unsigned __int8)v46 | (unsigned __int8)v49) & 1) == 0 )
                        goto LABEL_52;
                      goto LABEL_308;
                    }
                  }
                  else
                  {
                    if ( v50 == 2048 )
                    {
                      if ( v12 )
                        goto LABEL_52;
LABEL_50:
                      if ( (int)v48 <= 7 && !(_DWORD)v49 )
                        goto LABEL_52;
LABEL_308:
                      v197 = v233 - 1;
                      if ( (int)v233 - 1 >= 0 )
                      {
                        v198 = (int)v197;
                        v199 = (char *)(v40 + (int)v197);
                        v200 = *v199;
                        if ( *v199 == 57 )
                        {
LABEL_355:
                          v216 = *((_DWORD *)v6 + 2);
                          v14[v198] = v216;
                          *v199 = v216;
                          goto LABEL_52;
                        }
                        if ( *(int *)(__readfsqword(0xFFFFFFE0) + 4LL * v200) <= 101 )
                        {
LABEL_356:
                          ++v14[v198];
                          *v199 = v200 + 1;
                          goto LABEL_52;
                        }
                        while ( 1 )
                        {
                          *(_BYTE *)(v40 + v198) = 48;
                          v14[v198] = 48;
                          if ( v43 - 1 - v197 == v198 )
                            break;
                          --v198;
                          v200 = *(_BYTE *)(v40 + v198);
                          v199 = (char *)(v40 + v198);
                          if ( v200 == 57 )
                            goto LABEL_355;
                          if ( *(int *)(__readfsqword(0xFFFFFFE0) + 4LL * v200) <= 101 )
                            goto LABEL_356;
                        }
                      }
                      if ( (_BYTE)v239 == 57 )
                      {
                        LOBYTE(v239) = v6[8];
                      }
                      else if ( *(int *)(__readfsqword(0xFFFFFFE0) + 4LL * (char)v239) > 101 )
                      {
                        if ( v237.m128_i32[0] )
                        {
                          if ( v38 - 4 <= 0 )
                          {
                            LOBYTE(v239) = 49;
                            v237.m128_i32[0] = 0;
                            v38 = 4 - v38;
                          }
                          else
                          {
                            v38 -= 4;
                            LOBYTE(v239) = 49;
                          }
                        }
                        else
                        {
                          v38 += 4;
                          LOBYTE(v239) = 49;
                        }
                      }
                      else
                      {
                        LOBYTE(v239) = (_BYTE)v239 + 1;
                      }
                      goto LABEL_52;
                    }
                    if ( v50 == 3072 )
                      goto LABEL_52;
                  }
                  abort(v46, v47, v48, v49, (u32 *)(int)v233, v39);
                }
                if ( !v12 )
                  goto LABEL_52;
                goto LABEL_50;
              }
            }
            else
            {
              v48 = (unsigned int)((char)v45 - 87);
            }
          }
          else
          {
            v48 = (unsigned int)((char)v45 - 55);
          }
          v49 = 1LL;
          goto LABEL_46;
        }
        v38 = 0;
LABEL_146:
        v40 = v28;
        if ( (_DWORD)v233 == -1 )
          LODWORD(v233) = 0;
        goto LABEL_52;
      }
      if ( v237.m128_i32[0] <= 1022 )
      {
        v137 = 1023 - v237.m128_i32[0];
        v237.m128_i32[0] = 1;
      }
      else
      {
        v137 = v237.m128_i32[0] - 1023;
        v237.m128_i32[0] = 0;
      }
      v38 = v137;
    }
LABEL_32:
    if ( !v39 )
    {
      v40 = v28;
      goto LABEL_34;
    }
    goto LABEL_146;
  }
  si128 = (__m128)_mm_load_si128(v10);
  if ( _unordtf2(si128, si128) )
  {
    v91 = (u32 *)&unk_49154C;
    v92 = (void *__ptr32 *)&unk_49153B;
    v12 = _mm_movemask_ps(si128) & 8;
    v196 = (*(_WORD *)(__readfsqword(0xFFFFFFF0) + 2 * v11) & 0x100) == 0;
    if ( v196 )
    {
      v91 = (u32 *)&unk_49156C;
      if ( v196 )
        v92 = (void *__ptr32 *)&unk_491543;
    }
  }
  else
  {
    v12 = _mm_movemask_ps(si128) & 8;
    v237 = (__m128)_mm_and_si128(_mm_load_si128((const __m128i *)&si128), (__m128i)xmmword_4915B0);
    if ( _unordtf2(v237, (__m128)_mm_load_si128((const __m128i *)&xmmword_4915C0))
      || _lttf2(
           (__m128)_mm_load_si128((const __m128i *)&v237),
           (__m128)_mm_load_si128((const __m128i *)&xmmword_4915C0)) <= 0 )
    {
      v13 = v11 == 65;
      v240 = (char *)si128.m128_u64[1];
      v237.m128_u64[0] = si128.m128_u64[0];
      v14 = v246;
      v238 = v248;
      v15 = itoa_word(si128.m128_u64[0], (__int64)v249, 0x10u, v13);
      v16 = *(_DWORD *)(a2 + 8);
      v17 = v237.m128_u64[0];
      v18 = "0";
      if ( v16 == 65 )
        v18 = "0";
      for ( k = v237.m128_u64[0]; ; k >>= 4 )
      {
        *--v14 = *(_DWORD *)&v18[4 * (k & 0xF)];
        if ( k <= 0xF )
          break;
      }
      if ( v15 > (unsigned __int64)(v238 + 16) )
      {
        v21 = v14;
        v22 = (char *)v15;
        v20 = v238 + 16;
        do
        {
          --v22;
          --v21;
          *v22 = 48;
          *v21 = 48;
        }
        while ( v22 != v20 );
        v16 = *((_DWORD *)v6 + 2);
        v23 = &v22[-v15];
        v15 = (unsigned __int64)v22;
        v14 += (__int64)v23;
      }
      v24 = _mm_load_si128((const __m128i *)&si128);
      v239 = (char *)v17;
      v237.m128_u64[0] = si128.m128_u32[2] | ((unsigned __int64)(unsigned int)_mm_extract_epi16(v24, 6) << 32);
      v25 = itoa_word(v237.m128_u64[0], v15, 0x10u, v16 == 65);
      v26 = v237.m128_u64[0];
      v27 = "0";
      v28 = v25;
      v29 = (__int64)v239;
      if ( *((_DWORD *)v6 + 2) != 65 )
        v27 = "0";
      for ( m = v237.m128_u64[0]; ; m >>= 4 )
      {
        *--v14 = *(_DWORD *)&v27[4 * (m & 0xF)];
        if ( m <= 0xF )
          break;
      }
      v31 = v238 + 4;
      if ( v28 > (unsigned __int64)(v238 + 4) )
      {
        v32 = v14;
        v33 = (char *)v28;
        do
        {
          --v33;
          --v32;
          *v33 = 48;
          *v32 = 48;
        }
        while ( v33 != v31 );
        v34 = &v33[-v28];
        v28 = (unsigned __int64)v33;
        v14 += (__int64)v34;
      }
      v35 = v26 | v29;
      LOBYTE(v239) = ((_mm_extract_epi16(_mm_load_si128((const __m128i *)&si128), 7) & 0x7FFF) != 0) + 48;
      v237.m128_i32[0] = HIWORD(v240) & 0x7FFF;
      if ( v237.m128_i32[0] )
      {
        v36 = v237.m128_i32[0];
        if ( v237.m128_i32[0] <= 16382 )
        {
          v37 = 0x3FFF - v237.m128_i32[0];
          v237.m128_i32[0] = 1;
        }
        else
        {
          v237.m128_i32[0] = 0;
          v37 = v36 - 0x3FFF;
        }
        v38 = v37;
      }
      else
      {
        v38 = v35 != 0 ? 0x3FFE : 0;
        v237.m128_i32[0] = v35 != 0;
      }
      v39 = v35 == 0;
      goto LABEL_32;
    }
    v91 = (u32 *)&unk_49155C;
    v92 = &off_49153F;
    v118 = (*(_WORD *)(__readfsqword(0xFFFFFFF0) + 2 * v11) & 0x100) == 0;
    if ( v118 )
    {
      v91 = (u32 *)&unk_49157C;
      if ( v118 )
        v92 = (void *__ptr32 *)&unk_491547;
    }
  }
  v88 = *(unsigned __int8 *)(a2 + 12);
LABEL_103:
  v94 = v88 & 0x20;
  if ( v12 )
  {
    v95 = (unsigned int)((_DWORD)v236 - 4);
    if ( v94 || (int)v95 <= 0 )
    {
      v12 = 0;
      if ( !v227 )
        goto LABEL_106;
      goto LABEL_130;
    }
  }
  else if ( (v88 & 0x50) != 0 )
  {
    v95 = (unsigned int)((_DWORD)v236 - 4);
    if ( v94 )
      goto LABEL_171;
    if ( (int)v95 <= 0 )
    {
      v119 = (_DWORD)v236 - 4;
      LODWORD(v95) = 0;
LABEL_170:
      v12 = v95;
      v95 = v119;
      goto LABEL_171;
    }
  }
  else
  {
    v95 = (unsigned int)((_DWORD)v236 - 3);
    if ( v94 || (int)v95 <= 0 )
    {
LABEL_171:
      if ( (v88 & 0x40) != 0 )
      {
        if ( !v227 )
        {
          v136 = *(_BYTE **)(a1 + 40);
          if ( (unsigned __int64)v136 < *(_QWORD *)(a1 + 48) )
          {
            v88 = (unsigned __int64)(v136 + 1);
            *(_QWORD *)(a1 + 40) = v136 + 1;
            *v136 = 43;
            goto LABEL_108;
          }
          si128.m128_i32[0] = v95;
          v212 = 43LL;
          v233 = (__int64)v91;
          goto LABEL_347;
        }
        v128 = *(_QWORD *)(a1 + 160);
        if ( v128 )
        {
          v88 = *(_QWORD *)(v128 + 32);
          if ( v88 < *(_QWORD *)(v128 + 40) )
          {
            *(_QWORD *)(v128 + 32) = v88 + 4;
            *(_DWORD *)v88 = 43;
            goto LABEL_108;
          }
        }
        si128.m128_i32[0] = v95;
        v203 = 43LL;
        v233 = (__int64)v91;
      }
      else
      {
        v88 &= 0x10u;
        if ( !(_DWORD)v88 )
          goto LABEL_109;
        if ( !v227 )
        {
          v138 = *(_BYTE **)(a1 + 40);
          if ( (unsigned __int64)v138 < *(_QWORD *)(a1 + 48) )
          {
            v88 = (unsigned __int64)(v138 + 1);
            *(_QWORD *)(a1 + 40) = v138 + 1;
            *v138 = 32;
            goto LABEL_108;
          }
          si128.m128_i32[0] = v95;
          v212 = 32LL;
          v233 = (__int64)v91;
          goto LABEL_347;
        }
        v133 = *(_QWORD *)(a1 + 160);
        if ( v133 )
        {
          v88 = *(_QWORD *)(v133 + 32);
          if ( v88 < *(_QWORD *)(v133 + 40) )
          {
            *(_QWORD *)(v133 + 32) = v88 + 4;
            *(_DWORD *)v88 = 32;
            goto LABEL_108;
          }
        }
        si128.m128_i32[0] = v95;
        v203 = 32LL;
        v233 = (__int64)v91;
      }
LABEL_324:
      v204 = _woverflow(a1, v203, v88, v95, v91, a6);
      v91 = (u32 *)v233;
      v95 = si128.m128_u32[0];
      v205 = v204 == -1;
      goto LABEL_325;
    }
  }
  v107 = (int)v95;
  si128.m128_i32[0] = v95;
  v233 = (__int64)v91;
  if ( v227 )
  {
    v108 = IO_wpadn((char *)a1, 32LL, v95, v95, v91, a6);
    v91 = (u32 *)v233;
    v95 = si128.m128_u32[0];
  }
  else
  {
    v108 = IO_padn((char *)a1, (char *)0x20, v95, v95, v91, a6);
    v95 = si128.m128_u32[0];
    v91 = (u32 *)v233;
  }
  if ( v107 != v108 )
    return (unsigned int)-1;
  if ( !v12 )
  {
    v88 = *(unsigned __int8 *)(a2 + 12);
    v119 = v95;
    goto LABEL_170;
  }
  v12 = v95;
  if ( v227 )
  {
LABEL_130:
    v109 = *(_QWORD *)(a1 + 160);
    if ( v109 )
    {
      v88 = *(_QWORD *)(v109 + 32);
      if ( v88 < *(_QWORD *)(v109 + 40) )
      {
        *(_QWORD *)(v109 + 32) = v88 + 4;
        *(_DWORD *)v88 = 45;
        goto LABEL_108;
      }
    }
    si128.m128_i32[0] = v95;
    v203 = 45LL;
    v233 = (__int64)v91;
    goto LABEL_324;
  }
LABEL_106:
  v96 = *(_BYTE **)(a1 + 40);
  if ( (unsigned __int64)v96 >= *(_QWORD *)(a1 + 48) )
  {
    si128.m128_i32[0] = v95;
    v212 = 45LL;
    v233 = (__int64)v91;
LABEL_347:
    v213 = _overflow(a1, v212, v88, v95, v91, a6);
    v91 = (u32 *)v233;
    v95 = si128.m128_u32[0];
    v205 = v213 == -1;
LABEL_325:
    if ( v205 )
      return (unsigned int)-1;
    goto LABEL_108;
  }
  v88 = (unsigned __int64)(v96 + 1);
  *(_QWORD *)(a1 + 40) = v96 + 1;
  *v96 = 45;
LABEL_108:
  ++v12;
LABEL_109:
  if ( v227 )
  {
    v97 = 0LL;
    v98 = v12 + 1;
    v99 = v91;
    while ( 1 )
    {
      v100 = *(_QWORD *)(a1 + 160);
      v101 = v99[v97];
      if ( v100 && (v88 = *(_QWORD *)(v100 + 32), v88 < *(_QWORD *)(v100 + 40)) )
      {
        *(_QWORD *)(v100 + 32) = v88 + 4;
        v102 = (_DWORD)v101 == -1;
        *(_DWORD *)v88 = v101;
      }
      else
      {
        v230 = v95;
        v134 = _woverflow(a1, v101, v88, v95, v91, a6);
        v95 = v230;
        v102 = v134 == -1;
      }
      if ( v102 )
        return (unsigned int)-1;
      v86 = v98 + v97++;
      if ( v97 == 3 )
      {
        if ( (v6[12] & 0x20) != 0 && (int)v95 > 0 )
        {
          v103 = (int)v95;
          v228 = v95;
          v104 = IO_wpadn((char *)a1, 32LL, v95, v95, v91, a6);
          v105 = v228;
          goto LABEL_119;
        }
        return v86;
      }
    }
  }
  v129 = (__int64)v92 + 3;
  v130 = v92;
  do
  {
    v130 = (void *__ptr32 *)((char *)v130 + 1);
    v131 = *((unsigned __int8 *)v130 - 1);
    v132 = *(_BYTE **)(a1 + 40);
    if ( (unsigned __int64)v132 >= *(_QWORD *)(a1 + 48) )
    {
      v233 = v129;
      v231 = v95;
      v135 = _overflow(a1, v131, v129, v95, v91, a6);
      v95 = v231;
      v129 = v233;
      if ( v135 == -1 )
        return (unsigned int)-1;
    }
    else
    {
      *(_QWORD *)(a1 + 40) = v132 + 1;
      *v132 = v131;
    }
    v86 = v12 + (_DWORD)v130 - (_DWORD)v92;
  }
  while ( (void *__ptr32 *)v129 != v130 );
  if ( (v6[12] & 0x20) != 0 && (int)v95 > 0 )
  {
    v103 = (int)v95;
    v229 = v95;
    v104 = IO_padn((char *)a1, (char *)0x20, v95, v95, v91, a6);
    v105 = v229;
LABEL_119:
    if ( v103 == v104 )
    {
      v86 += v105;
      return v86;
    }
    return (unsigned int)-1;
  }
  return v86;
}
// 457143: variable 'v53' is possibly undefined
// 457322: variable 'v56' is possibly undefined
// 457322: variable 'v59' is possibly undefined
// 4574B6: variable 'v91' is possibly undefined
// 4574B6: variable 'a6' is possibly undefined
// 4579D7: variable 'v88' is possibly undefined
// 457BE9: variable 'v76' is possibly undefined
// 457E31: variable 'v162' is possibly undefined
// 457E31: variable 'v164' is possibly undefined
// 457E31: variable 'v161' is possibly undefined
// 458335: variable 'v69' is possibly undefined
// 458362: variable 'v60' is possibly undefined
// 4010C8: using guessed type __int64 __fastcall j_strlen_ifunc(_QWORD);
// 49153F: using guessed type void *__ptr32 off_49153F;
// 4915B0: using guessed type __int128 xmmword_4915B0;
// 4915C0: using guessed type __int128 xmmword_4915C0;
// 456C10: using guessed type char var_48[8];

//----- (0000000000458820) ----------------------------------------------------
__int64 __fastcall register_printf_modifier(char *a1, __int64 a2, __int64 a3, __int64 a4, u32 *a5, __int64 a6)
{
  char *v6; // rbx
  __int64 v7; // rcx
  __int64 v8; // rdx
  __int64 v10; // rbx
  _QWORD *v11; // rax
  _QWORD *v12; // r12
  int v13; // ecx
  __int64 v14; // rdx

  if ( (unsigned int)(*(_DWORD *)a1 - 1) <= 0xFE )
  {
    v6 = a1;
    while ( 1 )
    {
      v6 += 4;
      if ( !*(_DWORD *)v6 )
        break;
      if ( *(_DWORD *)v6 > 0xFFu )
        goto LABEL_20;
    }
    v7 = (unsigned int)next_bit;
    v8 = (unsigned int)(next_bit - 16);
    if ( (unsigned int)v8 <= 7 )
    {
      LODWORD(v14) = -1;
      __writefsdword(0xFFFFFFC0, 0x1Cu);
      return (unsigned int)v14;
    }
    _RSI = 1LL;
    if ( _libc_multiple_threads )
    {
      if ( !_InterlockedCompareExchange(&lock_2, 1, 0) )
      {
LABEL_11:
        if ( (_printf_modifier_table
           || (_RSI = 8LL, (_printf_modifier_table = (__int64)calloc(255LL, 8uLL, v8, v7, a5, a6)) != 0))
          && (v10 = v6 - a1, v11 = malloc(v10 + 16, _RSI, (_QWORD *)v8, v7, a5, a6), (v12 = v11) != 0LL) )
        {
          _RSI = (__int64)(a1 + 4);
          v13 = next_bit;
          *v11 = *(_QWORD *)(_printf_modifier_table + 8LL * (unsigned __int8)*a1);
          next_bit = v13 + 1;
          *((_DWORD *)v11 + 2) = 1 << v13;
          wmemcpy((__int64)v11 + 12, (__int64)(a1 + 4), v10 >> 2);
          *(_QWORD *)(_printf_modifier_table + 8LL * (unsigned __int8)*a1) = v12;
          v14 = *((unsigned int *)v12 + 2);
        }
        else
        {
          v14 = 0xFFFFFFFFLL;
        }
        if ( _libc_multiple_threads )
        {
          if ( !_InterlockedDecrement(&lock_2) )
            return (unsigned int)v14;
        }
        else if ( !--lock_2 )
        {
          return (unsigned int)v14;
        }
        _lll_unlock_wake_private((u32 *)&lock_2, _RSI, v14, v7, a5, a6);
        return (unsigned int)v14;
      }
    }
    else
    {
      __asm { cmpxchg cs:lock_2, esi }
      if ( !_libc_multiple_threads )
        goto LABEL_11;
    }
    _lll_lock_wait_private((u32 *)&lock_2, 1LL, v8, (unsigned int)next_bit, a5, a6);
    goto LABEL_11;
  }
LABEL_20:
  __writefsdword(0xFFFFFFC0, 0x16u);
  return 0xFFFFFFFFLL;
}
// 4588BC: variable 'v8' is possibly undefined
// 4588BC: variable 'v7' is possibly undefined
// 4588BC: variable 'a5' is possibly undefined
// 4588BC: variable 'a6' is possibly undefined
// 45895B: variable 'v14' is possibly undefined
// 4AAFE8: using guessed type int next_bit;
// 4AAFEC: using guessed type int lock_2;
// 4AB820: using guessed type int _libc_multiple_threads;
// 4ABA10: using guessed type __int64 _printf_modifier_table;

//----- (00000000004589D0) ----------------------------------------------------
__int64 __fastcall _handle_registered_modifier_mb(unsigned __int8 **a1, __int64 a2)
{
  unsigned __int8 *v2; // rbp
  __int64 *v3; // r9
  unsigned __int8 *v4; // r14
  int v5; // er12
  int v6; // er13
  _DWORD *v7; // r8
  int v8; // edx
  unsigned __int8 *v9; // rcx
  int v10; // eax
  __int64 v11; // rax
  __int64 result; // rax

  v2 = *a1;
  v3 = *(__int64 **)(_printf_modifier_table + 8LL * **a1);
  if ( !v3 )
    return 1LL;
  v4 = 0LL;
  v5 = 0;
  v6 = 0;
  do
  {
    v7 = (_DWORD *)v3 + 3;
    v8 = *((_DWORD *)v3 + 3);
    if ( v2[1] )
    {
      if ( !v8 )
      {
        v9 = v2 + 1;
        v11 = 1LL;
        goto LABEL_12;
      }
      if ( v8 != v2[1] )
        goto LABEL_14;
      v9 = v2 + 1;
      while ( 1 )
      {
        v10 = *++v9;
        v8 = *++v7;
        if ( !(_BYTE)v10 )
          break;
        if ( !v8 )
          goto LABEL_11;
        if ( v10 != v8 )
          goto LABEL_14;
      }
    }
    else
    {
      v9 = v2 + 1;
    }
    if ( v8 )
      goto LABEL_14;
LABEL_11:
    v11 = v9 - v2;
LABEL_12:
    if ( v5 < v11 )
    {
      v6 = *((_DWORD *)v3 + 2);
      v5 = v11;
      v4 = v9;
    }
LABEL_14:
    v3 = (__int64 *)*v3;
  }
  while ( v3 );
  result = 1LL;
  if ( v6 )
  {
    *(_WORD *)(a2 + 14) |= v6;
    result = 0LL;
    *a1 = v4;
  }
  return result;
}
// 4ABA10: using guessed type __int64 _printf_modifier_table;

//----- (0000000000458AB0) ----------------------------------------------------
__int64 __fastcall _handle_registered_modifier_wc(unsigned int **a1, __int64 a2)
{
  unsigned int *v2; // rbx
  __int64 *v3; // r9
  unsigned int v4; // er10
  unsigned int *v5; // r13
  int v6; // ebp
  int v7; // er12
  _DWORD *v8; // rcx
  int v9; // eax
  unsigned int *v10; // rdx
  __int64 v11; // rax
  __int64 result; // rax

  v2 = *a1;
  v3 = *(__int64 **)(_printf_modifier_table + 8LL * **a1);
  if ( !v3 )
    return 1LL;
  v4 = v2[1];
  v5 = 0LL;
  v6 = 0;
  v7 = 0;
  do
  {
    v8 = (_DWORD *)v3 + 3;
    v9 = *((_DWORD *)v3 + 3);
    if ( v4 )
    {
      if ( !v9 )
      {
        v10 = v2 + 1;
        v11 = 1LL;
        goto LABEL_12;
      }
      if ( v9 != v4 )
        goto LABEL_14;
      v10 = v2 + 1;
      while ( 1 )
      {
        ++v10;
        v9 = *++v8;
        if ( !*v10 )
          break;
        if ( !v9 )
          goto LABEL_11;
        if ( v9 != *v10 )
          goto LABEL_14;
      }
    }
    else
    {
      v10 = v2 + 1;
    }
    if ( v9 )
      goto LABEL_14;
LABEL_11:
    v11 = v10 - v2;
LABEL_12:
    if ( v6 < v11 )
    {
      v7 = *((_DWORD *)v3 + 2);
      v6 = v11;
      v5 = v10;
    }
LABEL_14:
    v3 = (__int64 *)*v3;
  }
  while ( v3 );
  result = 1LL;
  if ( v7 )
  {
    *(_WORD *)(a2 + 14) |= v7;
    result = 0LL;
    *a1 = v5;
  }
  return result;
}
// 4ABA10: using guessed type __int64 _printf_modifier_table;

//----- (0000000000458B80) ----------------------------------------------------
__int64 __fastcall register_printf_type(__int64 a1, __int64 a2, __int64 a3, __int64 a4, u32 *a5, __int64 a6)
{
  __int64 v7; // rdx

  _RSI = 1LL;
  if ( _libc_multiple_threads )
  {
    if ( !_InterlockedCompareExchange(&lock_3, 1, 0) )
      goto LABEL_6;
    goto LABEL_5;
  }
  __asm { cmpxchg cs:lock_3, esi }
  if ( _libc_multiple_threads )
LABEL_5:
    _lll_lock_wait_private((u32 *)&lock_3, 1LL, a3, a4, a5, a6);
LABEL_6:
  if ( _printf_va_arg_table || (_RSI = 8LL, (_printf_va_arg_table = (__int64)calloc(248LL, 8uLL, a3, a4, a5, a6)) != 0) )
  {
    v7 = (unsigned int)pa_next_type;
    if ( pa_next_type == 256 )
    {
      v7 = 0xFFFFFFFFLL;
      __writefsdword(0xFFFFFFC0, 0x1Cu);
    }
    else
    {
      a4 = _printf_va_arg_table;
      ++pa_next_type;
      *(_QWORD *)(_printf_va_arg_table + 8LL * (int)v7 - 64) = a1;
    }
  }
  else
  {
    v7 = 0xFFFFFFFFLL;
  }
  if ( _libc_multiple_threads )
  {
    if ( !_InterlockedDecrement(&lock_3) )
      return (unsigned int)v7;
    goto LABEL_13;
  }
  if ( --lock_3 )
LABEL_13:
    _lll_unlock_wake_private((u32 *)&lock_3, _RSI, v7, a4, a5, a6);
  return (unsigned int)v7;
}
// 458C25: variable 'a4' is possibly undefined
// 458C25: variable 'a5' is possibly undefined
// 458C25: variable 'a6' is possibly undefined
// 458C31: variable 'v7' is possibly undefined
// 458C42: variable 'a3' is possibly undefined
// 4A9B4C: using guessed type int pa_next_type;
// 4AAFF0: using guessed type int lock_3;
// 4AB820: using guessed type int _libc_multiple_threads;
// 4ABA30: using guessed type __int64 _printf_va_arg_table;

//----- (0000000000458C80) ----------------------------------------------------
__int64 fprintf(__int64 a1, unsigned __int64 a2, ...)
{
  __va_list_tag va[1]; // [rsp+0h] [rbp-D8h] BYREF
  unsigned __int64 v4; // [rsp+18h] [rbp-C0h]

  va_start(va, a2);
  v4 = __readfsqword(0x28u);
  return vfprintf(a1, a2, (__m128i *)va);
}

//----- (0000000000458D40) ----------------------------------------------------
__int64 __fastcall read_int_0(_QWORD *a1)
{
  _DWORD *v1; // rdx
  _DWORD *v2; // rcx
  unsigned int v3; // esi
  __int64 result; // rax
  signed int v5; // eax
  _DWORD *v6; // rcx

  v1 = (_DWORD *)(*a1 + 4LL);
  v2 = v1;
  v3 = *v1 - 48;
  result = (unsigned int)(*(_DWORD *)*a1 - 48);
  if ( v3 > 9 )
  {
LABEL_7:
    *a1 = v2;
    return result;
  }
  while ( (int)result < 0 )
  {
LABEL_6:
    v2 = ++v1;
    v3 = *v1 - 48;
    if ( v3 > 9 )
      goto LABEL_7;
  }
  if ( (int)result <= 214748364 )
  {
    v5 = 10 * result;
    if ( (int)(0x7FFFFFFF - v3) >= v5 )
    {
      result = v3 + v5;
      goto LABEL_6;
    }
  }
  v6 = v2 + 1;
  if ( (unsigned int)(*v6 - 48) <= 9 )
  {
    v1 += 2;
    v6 = v1;
    if ( (unsigned int)(*v1 - 48) <= 9 )
    {
      result = 0xFFFFFFFFLL;
      goto LABEL_6;
    }
  }
  result = 0xFFFFFFFFLL;
  *a1 = v6;
  return result;
}

//----- (0000000000458DE0) ----------------------------------------------------
_DWORD *__fastcall group_number_0(__int64 a1, _DWORD *a2, _DWORD *a3, _BYTE *a4, int a5)
{
  _DWORD *v5; // r9
  int v6; // ebp
  _DWORD *v8; // r12
  _BYTE *v9; // r13
  signed __int64 v11; // rbx
  unsigned __int64 v12; // rax
  _DWORD *v13; // rsi

  v5 = a2;
  v6 = (char)*a4;
  if ( (unsigned __int8)(*a4 - 1) > 0x7Du )
    return v5;
  v8 = a3;
  v9 = a4 + 1;
  v11 = (char *)a3 - (char *)a2;
  v12 = j_memmove(a1, a2, (char *)a3 - (char *)a2);
  v5 = v8;
  v13 = (_DWORD *)(v12 + v11);
  if ( v12 >= v12 + v11 )
    return v5;
  while ( 1 )
  {
    --v13;
    v5 = v8 - 1;
    *(v8 - 1) = *v13;
    if ( !--v6 )
      break;
    if ( v12 >= (unsigned __int64)v13 )
      return v5;
LABEL_11:
    v8 = v5;
  }
  if ( v12 >= (unsigned __int64)v13 )
    return v5;
  if ( v13 != v5 )
  {
    *(v8 - 2) = a5;
    v6 = (char)*v9;
    v5 = v8 - 2;
    if ( *v9 != 127 && (v6 & 0x80u) == 0 )
    {
      if ( (_BYTE)v6 )
        ++v9;
      else
        v6 = (char)*(v9 - 1);
      goto LABEL_11;
    }
  }
  return (_DWORD *)j_memmove(v5, v13, v12 - (_QWORD)v13);
}
// 401030: using guessed type __int64 __fastcall j_memmove(_QWORD, _QWORD, _QWORD);

//----- (0000000000458EC0) ----------------------------------------------------
_DWORD *__fastcall i18n_number_rewrite_1(_DWORD *a1, __int64 a2, _DWORD *a3)
{
  _DWORD *v4; // r12
  __int64 v5; // rbp
  _DWORD *v6; // r13
  __int64 v7; // rcx
  u32 *v8; // r8
  unsigned __int64 v9; // r9
  unsigned __int64 v11; // r15
  __int64 v12; // rsi
  unsigned int *v13; // rax
  u32 *v14; // r8
  unsigned __int64 v15; // r9
  __int64 v16; // rdx
  __int64 *v17; // rdi
  bool v18; // zf
  unsigned int v19; // [rsp+8h] [rbp-460h]
  unsigned int v20; // [rsp+Ch] [rbp-45Ch]
  __int64 v21[2]; // [rsp+10h] [rbp-458h] BYREF
  _QWORD v22[137]; // [rsp+20h] [rbp-448h] BYREF

  v4 = a1;
  v5 = a2 - (_QWORD)a1;
  v22[129] = __readfsqword(0x28u);
  v6 = (_DWORD *)wctrans((__int64)"to_outpunct");
  v19 = towctrans(0x2Eu, v6);
  v20 = towctrans(0x2Cu, v6);
  v21[0] = (__int64)v22;
  v21[1] = 1024LL;
  if ( (unsigned __int8)_libc_scratch_buffer_set_array_size(v21, (a2 - (__int64)a1) >> 2, 4LL, v7, v8, v9) )
  {
    v11 = v21[0];
    v12 = (__int64)a1;
    v4 = a3;
    v13 = (unsigned int *)j_mempcpy(v21[0], a1, v5);
    v16 = -96LL;
    v17 = (__int64 *)__readfsqword(0xFFFFFFA0);
    while ( v11 <= (unsigned __int64)--v13 )
    {
      while ( 1 )
      {
        v16 = *v13;
        --v4;
        v12 = (unsigned int)(v16 - 48);
        if ( (unsigned int)v12 <= 9 )
          break;
        if ( v6 )
        {
          v12 = (unsigned int)v16 & 0xFFFFFFFD;
          if ( (_DWORD)v12 == 44 )
          {
            v18 = (_DWORD)v16 == 46;
            v16 = v19;
            if ( !v18 )
              v16 = v20;
          }
        }
        --v13;
        *v4 = v16;
        if ( v11 > (unsigned __int64)v13 )
          goto LABEL_8;
      }
      v12 = *v17;
      v16 = *(unsigned int *)(*v17 + 8LL * ((int)v16 + 3) + 64);
      *v4 = v16;
    }
LABEL_8:
    if ( (_QWORD *)v21[0] != v22 )
      free(v21[0], v12, v16, (__int64)v22, v14, v15);
  }
  return v4;
}
// 458F47: variable 'v7' is possibly undefined
// 458F47: variable 'v8' is possibly undefined
// 458F47: variable 'v9' is possibly undefined
// 458FDC: variable 'v14' is possibly undefined
// 458FDC: variable 'v15' is possibly undefined
// 4010B0: using guessed type __int64 __fastcall j_mempcpy(_QWORD, _QWORD, _QWORD);

//----- (0000000000459030) ----------------------------------------------------
__int64 __fastcall IO_helper_overflow_0(__int64 a1, unsigned int a2, __int64 a3, __int64 a4, u32 *a5, __int64 a6)
{
  _QWORD *v8; // rcx
  unsigned int *v9; // rdx
  __int64 v10; // rsi
  __int64 v11; // rbx
  __int64 v12; // rdi
  __int64 v13; // r13
  __int64 v14; // rcx
  __int64 v15; // rax
  __int64 v16; // r13
  __int64 result; // rax

  v8 = *(_QWORD **)(a1 + 160);
  v9 = (unsigned int *)v8[4];
  v10 = v8[3];
  v11 = ((__int64)v9 - v10) >> 2;
  if ( (_DWORD)v11 )
  {
    v12 = *(_QWORD *)(a1 + 536);
    v13 = *(_QWORD *)(v12 + 216);
    v14 = v13 - (_QWORD)_start___libc_IO_vtables;
    if ( (char *)&_start___libc_atexit - (char *)_start___libc_IO_vtables <= (unsigned __int64)(v13
                                                                                              - (_QWORD)_start___libc_IO_vtables) )
    {
      IO_vtable_check(v12, v10, (__int64)_start___libc_IO_vtables, v14, a5, a6);
      v10 = *(_QWORD *)(*(_QWORD *)(a1 + 160) + 24LL);
    }
    v15 = (*(__int64 (__fastcall **)(__int64, __int64, _QWORD, __int64, u32 *))(v13 + 56))(v12, v10, (int)v11, v14, a5);
    if ( !v15 || v15 == 0xFFFFFFFFLL )
      return 0xFFFFFFFFLL;
    v16 = 4 * v15;
    wmemmove(
      *(_QWORD *)(*(_QWORD *)(a1 + 160) + 24LL),
      *(_QWORD *)(*(_QWORD *)(a1 + 160) + 24LL) + 4 * v15,
      (int)v11 - v15);
    v8 = *(_QWORD **)(a1 + 160);
    v9 = (unsigned int *)(v8[4] - v16);
    v8[4] = v9;
  }
  if ( v8[5] <= (unsigned __int64)v9 )
    return _woverflow(a1, a2, (__int64)v9, (__int64)v8, a5, a6);
  v8[4] = v9 + 1;
  result = a2;
  *v9 = a2;
  return result;
}
// 459094: variable 'v14' is possibly undefined
// 459094: variable 'a5' is possibly undefined
// 45913F: variable 'a6' is possibly undefined
// 4A9C40: using guessed type u32 _start___libc_IO_vtables[48];
// 4AA2E8: using guessed type __int64 (__fastcall *_start___libc_atexit)();

//----- (0000000000459150) ----------------------------------------------------
__int64 __fastcall printf_positional_0(
        u32 *a1,
        unsigned __int64 a2,
        unsigned int a3,
        __int64 a4,
        u32 *a5,
        unsigned __int64 a6,
        int a7,
        _DWORD *a8,
        __int64 a9,
        unsigned int a10,
        _BYTE *a11,
        int a12)
{
  __int64 *v12; // rcx
  _DWORD *v13; // r15
  unsigned __int64 v14; // r14
  unsigned __int64 v15; // rbx
  unsigned __int64 v16; // r12
  __int64 v17; // rax
  unsigned __int64 v18; // rsi
  __int64 v19; // r13
  __int64 v20; // rax
  _QWORD *v21; // rdx
  unsigned __int64 v22; // rdx
  unsigned __int64 j; // rcx
  __int64 v24; // r8
  __int64 v25; // r9
  __int64 v26; // r12
  unsigned __int64 v27; // r15
  __int64 v28; // rbx
  __int64 v29; // r13
  __int64 v30; // r12
  __int64 v31; // rax
  __int64 v32; // rax
  __int64 v33; // rdx
  __int64 v34; // r9
  __int64 v35; // rdi
  __int64 v36; // r13
  __int64 v37; // rax
  long double *v38; // rax
  char *v39; // r13
  __int64 *v40; // r15
  unsigned int v41; // ebx
  unsigned __int8 v42; // al
  char v43; // r9
  __int64 v44; // r12
  char v45; // dl
  int v46; // edi
  char v47; // cl
  int v48; // er14
  __int64 v49; // rax
  int v50; // eax
  _BOOL4 v51; // eax
  __int64 v52; // rcx
  __int64 ***v53; // rdx
  void *v54; // rsp
  __int64 v55; // rax
  unsigned __int64 v56; // rsi
  __int64 v57; // rdx
  __int64 *v58; // rdi
  __int16 v59; // dx
  unsigned int v60; // eax
  unsigned int v61; // eax
  unsigned __int64 *v62; // rsi
  unsigned int v63; // eax
  unsigned int *v64; // rsi
  unsigned int v65; // eax
  unsigned int *v66; // rsi
  __int64 v67; // r11
  __int64 (__fastcall *v68)(char *, __int64 *, _BYTE *); // rax
  unsigned __int64 v69; // rdi
  __int64 v70; // rcx
  __int64 *v71; // rsi
  __int16 v72; // cx
  unsigned int v73; // ecx
  void *v74; // rsp
  int v75; // er10
  unsigned int v76; // ecx
  __int64 v77; // rsi
  __int64 *v78; // r8
  int v79; // eax
  int v80; // er14
  bool v81; // r12
  _QWORD *v82; // rax
  __int64 v83; // rax
  __int64 v85; // rax
  int v86; // ebx
  __int64 v87; // rdi
  const __m128i *v88; // r8
  unsigned __int64 v89; // r12
  _BOOL4 v90; // eax
  __int64 v91; // rcx
  u32 *v92; // r8
  _QWORD *v93; // rdx
  __int64 *v94; // rcx
  void *v95; // rsp
  char *v96; // rcx
  __int64 v97; // rax
  unsigned __int64 v98; // r12
  u32 *v99; // r8
  unsigned __int8 *v100; // rax
  unsigned __int64 v101; // rax
  int v102; // er11
  char v103; // al
  __int64 v104; // rax
  __int64 *v105; // rax
  __int64 v106; // rax
  __int64 v107; // rax
  u32 *v108; // r10
  __int64 v109; // rax
  __int64 v110; // rax
  _DWORD *v111; // rdi
  __int64 v112; // r8
  __int64 v113; // r12
  _QWORD *v114; // rax
  _QWORD *v115; // rax
  __int64 v116; // rax
  __int64 v117; // r12
  __int64 v118; // rax
  _QWORD *v119; // rax
  const char *v120; // rcx
  char v121; // di
  u32 *v122; // rax
  __int64 v123; // rdi
  __int64 v124; // rax
  int v125; // er14
  __int64 v126; // rax
  __int64 v127; // rax
  _DWORD *v128; // rdi
  int v129; // er12
  __int64 v130; // r12
  _QWORD *v131; // rax
  char v132; // al
  __int64 v133; // rdi
  __int64 v134; // rax
  unsigned __int64 i; // rax
  u32 *v136; // rax
  __int64 v137; // rax
  _DWORD *v138; // rax
  _QWORD *v139; // rax
  unsigned int v140; // eax
  __int64 v141; // rax
  __int64 v142; // rax
  int v143; // er14
  __int64 v144; // r9
  unsigned __int64 v145; // rdx
  void *v146; // rsp
  int v147; // edi
  __int64 v148; // rax
  unsigned __int64 v149; // rdx
  unsigned int v150; // er12
  __int64 v151; // rax
  __int64 v152; // rax
  __int64 v153; // rax
  __int64 **v154; // r14
  unsigned __int64 v155; // rbx
  __int64 v156; // rax
  __int64 v157; // rax
  __int64 v158; // r14
  __int64 v159; // rax
  __int64 v160; // rax
  __int64 **v161; // r14
  unsigned __int64 v162; // rbx
  __int64 v163; // rax
  __int64 v164; // rax
  __int64 v165; // rsi
  __int64 ***v166; // rdi
  __int16 v167; // si
  signed __int64 v168; // rax
  void *v169; // rsp
  __int64 v170; // rax
  __int64 v171; // rax
  __int64 v172; // rax
  u32 *v173; // rax
  __int64 v174; // rdx
  int v175; // eax
  int v176; // eax
  _QWORD *v177; // rax
  __int64 v178; // rdx
  __int64 v179; // rcx
  u32 *v180; // r8
  __int64 v181; // r9
  int v182; // eax
  int v183; // eax
  int v184; // eax
  int v185; // eax
  _QWORD *v186; // rax
  __int64 v187; // rax
  __int64 v188; // [rsp+0h] [rbp-2978h]
  __int64 v189; // [rsp+8h] [rbp-2970h] BYREF
  _BYTE v190[4088]; // [rsp+10h] [rbp-2968h] BYREF
  __int64 v191; // [rsp+1008h] [rbp-1970h] BYREF
  u32 v192; // [rsp+1010h] [rbp-1968h] BYREF
  __int64 **v193; // [rsp+2008h] [rbp-970h] BYREF
  unsigned __int8 v194; // [rsp+2017h] [rbp-961h]
  char *v195; // [rsp+2018h] [rbp-960h]
  _DWORD *v196; // [rsp+2020h] [rbp-958h]
  unsigned __int64 v197; // [rsp+2028h] [rbp-950h]
  unsigned __int64 v198; // [rsp+2030h] [rbp-948h]
  __int64 v199; // [rsp+2038h] [rbp-940h]
  unsigned __int64 v200; // [rsp+2040h] [rbp-938h]
  unsigned int v201; // [rsp+2048h] [rbp-930h]
  unsigned int v202; // [rsp+204Ch] [rbp-92Ch]
  int v203; // [rsp+2050h] [rbp-928h]
  _BOOL4 v204; // [rsp+2054h] [rbp-924h]
  u32 *v205; // [rsp+2058h] [rbp-920h]
  __int64 v206; // [rsp+2060h] [rbp-918h]
  unsigned __int64 v207; // [rsp+2068h] [rbp-910h]
  __int64 v208; // [rsp+2070h] [rbp-908h]
  __int64 v209; // [rsp+2078h] [rbp-900h]
  _BYTE *v210; // [rsp+2080h] [rbp-8F8h]
  u32 *v211; // [rsp+2088h] [rbp-8F0h]
  __int64 v212; // [rsp+2090h] [rbp-8E8h]
  __int64 *v213; // [rsp+2098h] [rbp-8E0h]
  unsigned __int64 v214; // [rsp+20A0h] [rbp-8D8h]
  __int64 v215; // [rsp+20A8h] [rbp-8D0h]
  __int64 *v216; // [rsp+20B0h] [rbp-8C8h]
  __int64 *v217; // [rsp+20B8h] [rbp-8C0h]
  __int64 *v218; // [rsp+20C0h] [rbp-8B8h]
  unsigned __int64 v219; // [rsp+20D0h] [rbp-8A8h] BYREF
  long double *v220; // [rsp+20D8h] [rbp-8A0h] BYREF
  const __m128i *v221; // [rsp+20E0h] [rbp-898h] BYREF
  char v222; // [rsp+20E8h] [rbp-890h] BYREF
  __int64 *v223; // [rsp+2118h] [rbp-860h] BYREF
  unsigned __int64 v224; // [rsp+2120h] [rbp-858h]
  __int64 v225; // [rsp+2128h] [rbp-850h] BYREF
  __int64 v226[2]; // [rsp+2528h] [rbp-450h] BYREF
  _QWORD v227[136]; // [rsp+2538h] [rbp-440h] BYREF

  v12 = (__int64 *)a11;
  v215 = (__int64)a1;
  v200 = a2;
  v13 = a8;
  v202 = a3;
  v214 = (unsigned __int64)a5;
  LODWORD(v211) = a6;
  v206 = a9;
  v210 = a11;
  v227[129] = __readfsqword(0x28u);
  v224 = 1024LL;
  v216 = (__int64 *)&v223;
  v223 = &v225;
  v213 = v226;
  v226[0] = (__int64)v227;
  v226[1] = 1024LL;
  v219 = 0LL;
  if ( a11 == (_BYTE *)-1LL )
  {
    v85 = *(_QWORD *)__readfsqword(0xFFFFFFB8);
    v86 = *(_DWORD *)(v85 + 96);
    v210 = *(_BYTE **)(v85 + 80);
    a12 = v86;
    if ( !*v210 || *v210 == 127 )
      v210 = 0LL;
  }
  if ( *a8 )
  {
    v14 = 0LL;
    v15 = 0LL;
    v16 = 14LL;
    v218 = v216 + 2;
    v217 = (__int64 *)&v219;
    while ( 1 )
    {
      v17 = 9 * v14;
      v18 = v15;
      ++v14;
      v19 = (__int64)&v218[v17];
      v20 = _parse_one_specwc((__int64)v13, v15, v19, v217);
      v13 = *(_DWORD **)(v19 + 32);
      v15 += v20;
      if ( !*v13 )
        break;
      if ( v16 == v14 )
      {
        if ( !(unsigned __int8)_libc_scratch_buffer_grow_preserve(v216, v18, v21, v12, a5, a6) )
          goto LABEL_119;
        v218 = v223;
        v16 = v224 / 0x48;
      }
    }
    if ( v219 >= v15 )
      v15 = v219;
  }
  else
  {
    v15 = 0LL;
    v14 = 0LL;
    v218 = v216 + 2;
  }
  v18 = v15;
  if ( !(unsigned __int8)_libc_scratch_buffer_set_array_size(v213, v15, 24LL, (__int64)v12, a5, a6) )
  {
LABEL_119:
    v41 = -1;
    goto LABEL_120;
  }
  v26 = v226[0] + 16 * v15;
  v217 = (__int64 *)v226[0];
  v27 = v26 + 4 * v15;
  LODWORD(v212) = *(_DWORD *)(v215 + 116);
  v18 = (unsigned int)((int)((_DWORD)v212 << 29) >> 31);
  j_memset_ifunc(v27, v18, 4 * v15);
  if ( !v14 )
  {
    if ( !v15 )
      goto LABEL_281;
LABEL_23:
    j = (unsigned __int64)v217;
    v22 = v214;
    v36 = 0LL;
    while ( 1 )
    {
      v37 = *(int *)(v27 + 4 * v36);
      if ( (int)v37 <= 5 )
        break;
      if ( (_DWORD)v37 == 256 )
        goto LABEL_67;
      if ( (int)v37 <= 256 )
      {
        if ( (int)v37 <= 7 )
        {
          v60 = *(_DWORD *)(v22 + 4);
          if ( v60 > 0xAF )
          {
            v18 = *(_QWORD *)(v22 + 8);
            *(_QWORD *)(v22 + 8) = v18 + 8;
          }
          else
          {
            v18 = *(_QWORD *)(v22 + 16) + v60;
            *(_DWORD *)(v22 + 4) = v60 + 16;
          }
          *(_QWORD *)(j + 16 * v36) = *(_QWORD *)v18;
          goto LABEL_37;
        }
        goto LABEL_66;
      }
      if ( (_DWORD)v37 == 512 )
        goto LABEL_67;
      if ( (_DWORD)v37 == 1024 )
        goto LABEL_74;
      if ( (_DWORD)v37 != 263 )
        goto LABEL_66;
      v38 = (long double *)((*(_QWORD *)(v22 + 8) + 15LL) & 0xFFFFFFFFFFFFFFF0LL);
      v18 = (unsigned __int64)(v38 + 1);
      *(_QWORD *)(v22 + 8) = v38 + 1;
      *(long double *)(j + 16 * v36) = *v38;
LABEL_37:
      if ( ++v36 >= v15 )
        goto LABEL_38;
    }
    if ( (int)v37 < 3 )
    {
      if ( (int)v37 > 1 )
      {
        v63 = *(_DWORD *)v22;
        if ( *(_DWORD *)v22 > 0x2Fu )
        {
          v64 = *(unsigned int **)(v22 + 8);
          *(_QWORD *)(v22 + 8) = v64 + 2;
        }
        else
        {
          v64 = (unsigned int *)(*(_QWORD *)(v22 + 16) + v63);
          *(_DWORD *)v22 = v63 + 8;
        }
        v18 = *v64;
        *(_DWORD *)(j + 16 * v36) = v18;
        goto LABEL_37;
      }
      if ( (int)v37 >= 0 )
      {
LABEL_74:
        v65 = *(_DWORD *)v22;
        if ( *(_DWORD *)v22 > 0x2Fu )
        {
          v66 = *(unsigned int **)(v22 + 8);
          *(_QWORD *)(v22 + 8) = v66 + 2;
        }
        else
        {
          v66 = (unsigned int *)(*(_QWORD *)(v22 + 16) + v65);
          *(_DWORD *)v22 = v65 + 8;
        }
        v18 = *v66;
        *(_DWORD *)(j + 16 * v36) = v18;
        goto LABEL_37;
      }
      if ( (_DWORD)v37 == -1 )
      {
        if ( (*(_BYTE *)(v215 + 116) & 4) != 0 )
          _libc_fatal((__int64)"*** invalid %N$ use detected ***\n", v18, v22, j, (u32 *)v24, v25);
        _assert_fail((__int64)"s->_flags2 & _IO_FLAGS2_FORTIFY", (__int64)"vfprintf.c", 0x75Fu, "printf_positional");
      }
LABEL_66:
      if ( (v37 & 0x800) == 0 )
      {
        v24 = _printf_va_arg_table;
        if ( _printf_va_arg_table && *(_QWORD *)(_printf_va_arg_table + 8 * v37 - 64) )
        {
          v165 = *(int *)(v26 + 4 * v36) + 23LL;
          v166 = (__int64 ***)((char *)&v193 - (v165 & 0xFFFFFFFFFFFFF000LL));
          v167 = v165 & 0xFFF0;
          if ( &v193 != v166 )
          {
            while ( &v191 != (__int64 *)v166 )
              ;
          }
          v168 = v167 & 0xFFF;
          if ( (v167 & 0xFFF) != 0 )
          {
            v169 = alloca(v168);
            *(_QWORD *)&v190[v168 + 4080] = *(_QWORD *)&v190[v168 + 4080];
          }
          v212 = j;
          v18 = v22;
          v214 = v22;
          *(_QWORD *)(j + 16 * v36) = &v192;
          (*(void (__fastcall **)(u32 *, unsigned __int64))(v24 + 8LL * *(int *)(v27 + 4 * v36) - 64))(&v192, v22);
          v22 = v214;
          j = v212;
        }
        else
        {
          *(long double *)(j + 16 * v36) = 0.0;
        }
        goto LABEL_37;
      }
    }
LABEL_67:
    v61 = *(_DWORD *)v22;
    if ( *(_DWORD *)v22 > 0x2Fu )
    {
      v62 = *(unsigned __int64 **)(v22 + 8);
      *(_QWORD *)(v22 + 8) = v62 + 1;
    }
    else
    {
      v62 = (unsigned __int64 *)(*(_QWORD *)(v22 + 16) + v61);
      *(_DWORD *)v22 = v61 + 8;
    }
    v18 = *v62;
    *(_QWORD *)(j + 16 * v36) = v18;
    goto LABEL_37;
  }
  v212 = v15;
  v28 = v26;
  v24 = (__int64)&v218[9 * v14];
  v29 = (__int64)v218;
  v30 = v24;
  do
  {
    while ( 1 )
    {
      v31 = *(int *)(v29 + 44);
      if ( (_DWORD)v31 != -1 )
        *(_DWORD *)(v27 + 4 * v31) = 0;
      v32 = *(int *)(v29 + 40);
      if ( (_DWORD)v32 != -1 )
        *(_DWORD *)(v27 + 4 * v32) = 0;
      v18 = *(_QWORD *)(v29 + 56);
      if ( !v18 )
        goto LABEL_14;
      if ( v18 != 1 )
        break;
      *(_DWORD *)(v27 + 4LL * *(int *)(v29 + 48)) = *(_DWORD *)(v29 + 52);
      v22 = *(unsigned int *)(v29 + 64);
      *(_DWORD *)(v28 + 4LL * *(int *)(v29 + 48)) = v22;
LABEL_14:
      v29 += 72LL;
      if ( v30 == v29 )
        goto LABEL_22;
    }
    v33 = *(int *)(v29 + 48);
    v34 = *(int *)(v29 + 8);
    v35 = v29;
    v29 += 72LL;
    (*(void (__fastcall **)(__int64, unsigned __int64, unsigned __int64, __int64))(_printf_arginfo_table + 8 * v34))(
      v35,
      v18,
      v27 + 4 * v33,
      v28 + 4 * v33);
  }
  while ( v30 != v29 );
LABEL_22:
  v26 = v28;
  v15 = v212;
  if ( v212 )
    goto LABEL_23;
LABEL_38:
  v214 = a7;
  if ( a7 >= v14 )
  {
LABEL_281:
    v41 = (unsigned int)v211;
    goto LABEL_120;
  }
  v198 = v14;
  v39 = (char *)v215;
  v196 = (_DWORD *)(v206 + 1000);
  v40 = &v218[9 * v214];
  v41 = (unsigned int)v211;
  v195 = &v222;
  v193 = &v223;
  while ( 1 )
  {
    v42 = *((_BYTE *)v40 + 12);
    v43 = *((_BYTE *)v40 + 13);
    v44 = *(int *)v40;
    v24 = (v42 & 8) != 0;
    v204 = (v42 & 0x10) != 0;
    LODWORD(v209) = (v42 & 0x20) != 0;
    LODWORD(v205) = (v42 & 0x40) != 0;
    LOBYTE(v207) = v42 >> 7;
    v45 = v43;
    v25 = (v43 & 8) != 0;
    v201 = (v42 & 2) != 0;
    LODWORD(v199) = (v45 & 2) != 0;
    v22 = *((int *)v40 + 11);
    v46 = *((_DWORD *)v40 + 2);
    LODWORD(v211) = (v42 & 4) != 0;
    v47 = *((_BYTE *)v40 + 16);
    LODWORD(v215) = v46;
    LOBYTE(v203) = v47;
    if ( (_DWORD)v22 == -1 )
    {
      v48 = *((_DWORD *)v40 + 1);
    }
    else
    {
      v22 *= 16LL;
      v48 = *(_DWORD *)((char *)v217 + v22);
      if ( v48 < 0 )
      {
        LODWORD(v209) = 1;
        v48 = -v48;
        *((_DWORD *)v40 + 1) = v48;
        *((_BYTE *)v40 + 12) = v42 | 0x20;
      }
      else
      {
        *((_DWORD *)v40 + 1) = v48;
      }
    }
    v49 = *((int *)v40 + 10);
    if ( (_DWORD)v49 != -1 )
    {
      v44 = SLODWORD(v217[2 * v49]);
      if ( (int)v44 < 0 )
      {
        *(_DWORD *)v40 = -1;
        v44 = -1LL;
      }
      else
      {
        *(_DWORD *)v40 = v44;
      }
    }
    v50 = v48;
    if ( (int)v44 >= v48 )
      v50 = v44;
    if ( v50 <= 218 )
    {
      v212 = 0LL;
      v208 = (__int64)v196;
    }
    else
    {
      LOBYTE(v197) = v25;
      LOBYTE(v208) = v24;
      v212 = 4LL * (v50 + 32);
      v51 = _libc_alloca_cutoff(v212);
      v24 = (unsigned __int8)v208;
      v25 = (unsigned __int8)v197;
      if ( v51 || (unsigned __int64)v212 <= 0x1000 )
      {
        v53 = (__int64 ***)((char *)&v193 - ((v212 + 23) & 0xFFFFFFFFFFFFF000LL));
        if ( &v193 != v53 )
        {
          while ( &v191 != (__int64 *)v53 )
            ;
        }
        if ( (((_WORD)v212 + 23) & 0xFF0) != 0 )
        {
          v54 = alloca(((_WORD)v212 + 23) & 0xFF0);
          *(_QWORD *)&v190[(((_WORD)v212 + 23) & 0xFF0) + 4080] = *(_QWORD *)&v190[(((_WORD)v212 + 23) & 0xFF0) + 4080];
        }
        v22 = (unsigned __int64)&v192;
        if ( (int)v44 <= v48 )
          v55 = 4LL * v48 + 128;
        else
          v55 = 4LL * (int)v44 + 128;
        j = (unsigned int)v215;
        v212 = 0LL;
        v208 = (__int64)&v192 + v55;
        if ( (int)v215 > 255 )
          goto LABEL_99;
        goto LABEL_85;
      }
      v186 = malloc(v212, v18, (_QWORD *)v212, v52, (u32 *)(unsigned __int8)v208, (unsigned __int8)v197);
      v24 = (unsigned __int8)v208;
      v25 = (unsigned __int8)v197;
      v212 = (__int64)v186;
      if ( !v186 )
        goto LABEL_119;
      v187 = (int)v44 <= v48 ? 4LL * v48 + 128 : 4LL * (int)v44 + 128;
      v208 = v212 + v187;
    }
    j = (unsigned int)v215;
    if ( (int)v215 > 255 )
      goto LABEL_99;
LABEL_85:
    if ( _printf_function_table )
    {
      v67 = (int)j;
      v68 = *(__int64 (__fastcall **)(char *, __int64 *, _BYTE *))(_printf_function_table + 8LL * (int)j);
      if ( v68 )
      {
        v69 = v40[7];
        v70 = 8 * v69 + 23;
        v71 = (__int64 *)((char *)&v191 - (v70 & 0xFFFFFFFFFFFFF000LL));
        v72 = v70 & 0xFFF0;
        if ( &v191 != v71 )
        {
          while ( &v189 != v71 )
            ;
        }
        v73 = v72 & 0xFFF;
        if ( v73 )
        {
          v74 = alloca(v73);
          *(__int64 *)((char *)&v188 + v73) = *(__int64 *)((char *)&v188 + v73);
        }
        if ( v69 )
        {
          LOBYTE(v197) = v24;
          v75 = *((_DWORD *)v40 + 12);
          v76 = 0;
          v77 = 0LL;
          v78 = v217;
          do
          {
            *(_QWORD *)&v190[8 * v77] = &v78[2 * v75 + 2 * v76++];
            v77 = v76;
          }
          while ( v69 > v76 );
          LOBYTE(v24) = v197;
          v68 = *(__int64 (__fastcall **)(char *, __int64 *, _BYTE *))(_printf_function_table + 8 * v67);
        }
        v194 = v25;
        v18 = (unsigned __int64)v40;
        LOBYTE(v197) = v24;
        v79 = v68(v39, v40, v190);
        v24 = (unsigned __int8)v197;
        v25 = v194;
        if ( v79 != -2 )
        {
          if ( v79 < 0 )
            goto LABEL_117;
          if ( v41 > 0x7FFFFFFE )
            _assert_fail(
              (__int64)"(unsigned int) done < (unsigned int) INT_MAX",
              (__int64)"vfprintf.c",
              0x7DAu,
              "printf_positional");
LABEL_209:
          v22 = 0x7FFFFFFF - v41;
          if ( (unsigned int)v22 < v79 )
            goto LABEL_116;
          v41 += v79;
          goto LABEL_211;
        }
      }
    }
LABEL_99:
    switch ( (int)v215 )
    {
      case '%':
        v104 = *((_QWORD *)v39 + 20);
        if ( v104 && (v22 = *(_QWORD *)(v104 + 32), v22 < *(_QWORD *)(v104 + 40)) )
        {
          j = v22 + 4;
          *(_QWORD *)(v104 + 32) = v22 + 4;
          *(_DWORD *)v22 = 37;
        }
        else
        {
          v18 = 37LL;
          if ( (unsigned int)_woverflow((__int64)v39, 37LL, v22, j, (u32 *)v24, v25) == -1 )
            goto LABEL_117;
        }
        if ( v41 == 0x7FFFFFFF )
          goto LABEL_117;
        ++v41;
        break;
      case 'A':
      case 'a':
        v221 = (const __m128i *)&v217[2 * *((int *)v40 + 12)];
        *((_BYTE *)v40 + 13) &= ~0x10u;
        v18 = (unsigned __int64)&v218[9 * v214];
        v79 = _printf_fphex((__int64)v39, v18, &v221, j, v24, v25);
        if ( v79 >= 0 )
          goto LABEL_208;
        goto LABEL_117;
      case 'C':
        goto LABEL_101;
      case 'E':
      case 'F':
      case 'G':
      case 'e':
      case 'f':
      case 'g':
        v220 = (long double *)&v217[2 * *((int *)v40 + 12)];
        *((_BYTE *)v40 + 13) &= ~0x10u;
        v18 = (unsigned __int64)&v218[9 * v214];
        v79 = _printf_fp(v39, v18, &v220, j, (u32 *)v24, v25);
        if ( v79 < 0 )
          goto LABEL_117;
LABEL_208:
        if ( v41 <= 0x7FFFFFFE )
          goto LABEL_209;
        goto LABEL_550;
      case 'S':
      case 's':
        v87 = (__int64)v217;
        v88 = (const __m128i *)v217[2 * *((int *)v40 + 12)];
        goto LABEL_132;
      case 'X':
      case 'x':
        v102 = 16;
        goto LABEL_164;
      case 'c':
        if ( (_DWORD)v211 )
        {
LABEL_101:
          v80 = v48 - 1;
          v81 = v80 > 0;
          if ( !(_DWORD)v209 && v80 > 0 )
          {
            v18 = 32LL;
            v215 = v80;
            v82 = (_QWORD *)IO_wpadn(v39, 32LL, v80, v80, (u32 *)v24, v25);
            j = v215;
            if ( (_QWORD *)v215 != v82 )
              goto LABEL_117;
            if ( v41 > 0x7FFFFFFE )
              goto LABEL_541;
            if ( 0x7FFFFFFF - v41 < v80 )
              goto LABEL_116;
            v41 += v80;
          }
          v18 = LODWORD(v217[2 * *((int *)v40 + 12)]);
          v83 = *((_QWORD *)v39 + 20);
          if ( v83 && (v22 = *(_QWORD *)(v83 + 32), v22 < *(_QWORD *)(v83 + 40)) )
          {
            j = v22 + 4;
            *(_QWORD *)(v83 + 32) = v22 + 4;
            *(_DWORD *)v22 = v18;
            if ( (_DWORD)v18 == -1 )
              goto LABEL_117;
          }
          else if ( (unsigned int)_woverflow((__int64)v39, v18, v22, (__int64)v217, (u32 *)v24, v25) == -1 )
          {
            goto LABEL_117;
          }
        }
        else
        {
          v80 = v48 - 1;
          v81 = v80 > 0;
          if ( !(_DWORD)v209 && v80 > 0 )
          {
            v18 = 32LL;
            v215 = v80;
            v177 = (_QWORD *)IO_wpadn(v39, 32LL, v80, v80, (u32 *)v24, v25);
            j = v215;
            if ( (_QWORD *)v215 != v177 )
              goto LABEL_117;
            if ( v41 > 0x7FFFFFFE )
LABEL_541:
              _assert_fail(
                (__int64)"(unsigned int) done < (unsigned int) INT_MAX",
                (__int64)"vfprintf.c",
                0x7E2u,
                "printf_positional");
            if ( 0x7FFFFFFF - v41 < v80 )
              goto LABEL_116;
            v41 += v80;
          }
          v140 = btowc(LOBYTE(v217[2 * *((int *)v40 + 12)]), v18, v22, (__int64)v217, (u32 *)v24, v25);
          v22 = *((_QWORD *)v39 + 20);
          if ( v22 && (j = *(_QWORD *)(v22 + 32), j < *(_QWORD *)(v22 + 40)) )
          {
            v18 = j + 4;
            *(_QWORD *)(v22 + 32) = j + 4;
            *(_DWORD *)j = v140;
            if ( v140 == -1 )
              goto LABEL_117;
          }
          else
          {
            v18 = v140;
            if ( (unsigned int)_woverflow((__int64)v39, v140, v22, j, (u32 *)v24, v25) == -1 )
              goto LABEL_117;
          }
        }
        if ( v41 == 0x7FFFFFFF )
          goto LABEL_117;
        ++v41;
        if ( !(_DWORD)v209 || !v81 )
          break;
        v18 = 32LL;
        if ( v80 != IO_wpadn(v39, 32LL, v80, j, (u32 *)v24, v25) )
          goto LABEL_117;
        if ( v41 > 0x7FFFFFFE )
          goto LABEL_541;
        if ( 0x7FFFFFFF - v41 < v80 )
          goto LABEL_116;
        goto LABEL_201;
      case 'd':
      case 'i':
        if ( (_DWORD)v211 )
        {
          v116 = v217[2 * *((int *)v40 + 12)];
        }
        else
        {
          LODWORD(v116) = v217[2 * *((int *)v40 + 12)];
          if ( (_DWORD)v199 )
          {
            v116 = (char)v116;
          }
          else
          {
            v174 = (int)v116;
            v116 = (__int16)v116;
            if ( !v201 )
              v116 = v174;
          }
        }
        if ( v116 < 0 )
        {
          v102 = 10;
          LODWORD(v211) = 1;
          v199 = -v116;
        }
        else
        {
          v199 = v116;
          v102 = 10;
          LODWORD(v211) = 0;
        }
        goto LABEL_166;
      case 'm':
        v18 = v206;
        v87 = a10;
        v100 = strerror_r(a10, v206, 0x3E8uLL);
        LODWORD(v211) = 0;
        v88 = (const __m128i *)v100;
LABEL_132:
        if ( v88 )
        {
          if ( (_DWORD)v211 || (_DWORD)v215 == 83 )
          {
            if ( (_DWORD)v44 != -1 )
              goto LABEL_333;
            v87 = (__int64)v88;
            v211 = (u32 *)v88;
            v157 = j_wcslen(v88);
            v99 = v211;
            LODWORD(v208) = 0;
            v98 = v157;
            LODWORD(v215) = v157;
          }
          else
          {
            v221 = v88;
            if ( (_DWORD)v44 == -1 )
            {
              v22 = j_strlen_ifunc(v88);
            }
            else
            {
              v18 = (int)v44;
              v22 = j_strnlen(v88, (int)v44);
            }
            if ( v22 > 0x3FFFFFFFFFFFFFFFLL )
              goto LABEL_116;
            v89 = 4 * v22;
            v215 = v22;
            v90 = _libc_alloca_cutoff(4 * v22);
            v93 = (_QWORD *)v215;
            if ( v90 || v89 <= 0x1000 )
            {
              v94 = (__int64 *)((char *)&v191 - ((v89 + 23) & 0xFFFFFFFFFFFFF000LL));
              if ( &v191 != v94 )
              {
                while ( &v189 != v94 )
                  ;
              }
              if ( (((_WORD)v89 + 23) & 0xFF0) != 0 )
              {
                v95 = alloca(((_WORD)v89 + 23) & 0xFF0);
                *(__int64 *)((char *)&v188 + (((_WORD)v89 + 23) & 0xFF0)) = *(__int64 *)((char *)&v188
                                                                                       + (((_WORD)v89 + 23) & 0xFF0));
              }
              LODWORD(v208) = 0;
              v24 = (__int64)v190;
            }
            else
            {
              v24 = (__int64)malloc(v89, v18, (_QWORD *)v215, v91, v92, v25);
              if ( !v24 )
                goto LABEL_117;
              LODWORD(v208) = 1;
              v93 = (_QWORD *)v215;
            }
            v96 = v195;
            v18 = (unsigned __int64)&v221;
            v87 = v24;
            v211 = (u32 *)v24;
            *(_QWORD *)v195 = 0LL;
            v97 = mbsrtowcs(v24, (__int64 *)&v221, (__int64)v93, v96, v24, v25);
            v98 = v97;
            if ( v97 == -1 )
              goto LABEL_117;
            LODWORD(v215) = v97;
            v99 = v211;
          }
        }
        else if ( (_DWORD)v44 == -1 || (int)v44 > 5 )
        {
          LODWORD(v215) = 6;
          v98 = 6LL;
          v99 = (u32 *)&null_0;
          LODWORD(v208) = 0;
        }
        else
        {
          LODWORD(v215) = 0;
          v98 = 0LL;
          v99 = (u32 *)&unk_491654;
          LODWORD(v208) = 0;
        }
        goto LABEL_334;
      case 'n':
        if ( (v39[116] & 4) != 0 )
        {
          v24 = v202;
          if ( !v202 )
          {
            v18 = 4 * j_wcslen(v200) + 4;
            v202 = _readonly_area(v200, v18, v178, v179, v180, v181);
          }
          if ( (v202 & 0x80000000) != 0 )
            _libc_fatal((__int64)"*** %n in writable segment detected ***\n", v18, v22, j, (u32 *)v24, v25);
        }
        v18 = (unsigned int)v211;
        v119 = (_QWORD *)v217[2 * *((int *)v40 + 12)];
        if ( (_DWORD)v211 )
        {
          v22 = (int)v41;
          *v119 = (int)v41;
        }
        else
        {
          j = (unsigned int)v199;
          if ( (_DWORD)v199 )
          {
            *(_BYTE *)v119 = v41;
          }
          else
          {
            v22 = v201;
            if ( v201 )
              *(_WORD *)v119 = v41;
            else
              *(_DWORD *)v119 = v41;
          }
        }
        break;
      case 'o':
        v102 = 8;
        goto LABEL_164;
      case 'p':
        if ( !v217[2 * *((int *)v40 + 12)] )
        {
          v88 = (const __m128i *)"(";
          if ( (int)v44 < 5 )
            LODWORD(v44) = 5;
LABEL_333:
          v18 = (int)v44;
          v87 = (__int64)v88;
          v211 = (u32 *)v88;
          v142 = j_wcsnlen(v88, (int)v44);
          v99 = v211;
          LODWORD(v208) = 0;
          LODWORD(v215) = v142;
          v98 = v142;
LABEL_334:
          v143 = v48 - v215;
          if ( v143 < 0 )
          {
            if ( (v41 & 0x80000000) != 0 )
LABEL_548:
              _assert_fail(
                (__int64)"(size_t) done <= (size_t) INT_MAX",
                (__int64)"vfprintf.c",
                0x7E2u,
                "printf_positional");
            v158 = *((_QWORD *)v39 + 27);
            if ( (char *)&_start___libc_atexit - (char *)_start___libc_IO_vtables <= (unsigned __int64)(v158 - (_QWORD)_start___libc_IO_vtables) )
            {
              v211 = v99;
              IO_vtable_check(
                v87,
                v18,
                (__int64)_start___libc_IO_vtables,
                v158 - (_QWORD)_start___libc_IO_vtables,
                v99,
                v25);
              v99 = v211;
            }
            v18 = (unsigned __int64)v99;
            if ( v98 != (*(__int64 (__fastcall **)(char *, u32 *, unsigned __int64))(v158 + 56))(v39, v99, v98) )
              goto LABEL_117;
            if ( (int)(0x7FFFFFFF - v41) < v98 )
              goto LABEL_116;
            v41 += v215;
          }
          else
          {
            LOBYTE(v211) = v143 != 0;
            if ( !(_DWORD)v209 && v143 )
            {
              v18 = 32LL;
              v87 = (__int64)v39;
              v205 = v99;
              v207 = v143;
              v173 = (u32 *)IO_wpadn(v39, 32LL, v143, j, v99, v143);
              v25 = v207;
              if ( (u32 *)v207 != v173 )
                goto LABEL_117;
              if ( v41 > 0x7FFFFFFE )
                goto LABEL_541;
              if ( 0x7FFFFFFF - v41 < v143 )
                goto LABEL_116;
              v41 += v143;
              v99 = v205;
            }
            if ( (v41 & 0x80000000) != 0 )
              goto LABEL_548;
            v144 = *((_QWORD *)v39 + 27);
            if ( (char *)&_start___libc_atexit - (char *)_start___libc_IO_vtables <= (unsigned __int64)(v144 - (_QWORD)_start___libc_IO_vtables) )
            {
              v205 = (u32 *)*((_QWORD *)v39 + 27);
              v207 = (unsigned __int64)v99;
              IO_vtable_check(
                v87,
                v18,
                (__int64)_start___libc_IO_vtables,
                v144 - (_QWORD)_start___libc_IO_vtables,
                v99,
                v144);
              v144 = (__int64)v205;
              v99 = (u32 *)v207;
            }
            v18 = (unsigned __int64)v99;
            v207 = (unsigned __int64)v99;
            if ( v98 != (*(__int64 (__fastcall **)(char *, u32 *, unsigned __int64))(v144 + 56))(v39, v99, v98) )
              goto LABEL_117;
            v25 = 0x7FFFFFFFLL;
            if ( (int)(0x7FFFFFFF - v41) < v98 )
              goto LABEL_116;
            v41 += v215;
            v24 = v207;
            if ( (_DWORD)v209 && (_BYTE)v211 )
            {
              v18 = 32LL;
              v215 = v207;
              if ( v143 != IO_wpadn(v39, 32LL, v143, j, (u32 *)v207, 0x7FFFFFFFLL) )
                goto LABEL_117;
              if ( v41 > 0x7FFFFFFE )
                goto LABEL_541;
              v25 = 0x7FFFFFFF - v41;
              if ( (unsigned int)v25 < v143 )
                goto LABEL_116;
              v41 += v143;
              v24 = v215;
            }
            if ( (_DWORD)v208 )
              free(v24, v18, v22, j, (u32 *)v24, v25);
          }
          break;
        }
        v101 = v217[2 * *((int *)v40 + 12)];
        if ( (int)v44 < 0 )
        {
          v199 = v217[2 * *((int *)v40 + 12)];
          v44 = 1LL;
          v121 = 0;
          v120 = "0";
          LODWORD(v215) = 120;
          LODWORD(v211) = 0;
          v201 = 1;
          goto LABEL_308;
        }
        v199 = v217[2 * *((int *)v40 + 12)];
        if ( (_DWORD)v44 )
        {
          LODWORD(v215) = 120;
          v102 = 16;
          v103 = 0;
          LODWORD(v211) = 0;
          v201 = 1;
LABEL_157:
          LOBYTE(v203) = 32;
          LOBYTE(v207) = v103 & 1;
        }
        else
        {
          LODWORD(v211) = 0;
          v103 = 0;
          v102 = 16;
          LODWORD(v215) = 120;
          v201 = 1;
LABEL_330:
          v44 = 0LL;
          LOBYTE(v203) = 32;
          LOBYTE(v207) = v103 & 1;
        }
LABEL_229:
        v120 = "0";
        v121 = v207 & (v210 != 0LL);
        if ( (_DWORD)v215 != 88 )
          v120 = "0";
        if ( v102 != 10 )
        {
          if ( v102 == 16 )
          {
            v101 = v199;
LABEL_308:
            v108 = (u32 *)v208;
            while ( 1 )
            {
              *--v108 = *(_DWORD *)&v120[4 * (v101 & 0xF)];
              if ( v101 <= 0xF )
                break;
              v101 >>= 4;
            }
            v102 = 16;
          }
          else
          {
            v108 = (u32 *)v208;
            for ( i = v199; ; i >>= 3 )
            {
              *--v108 = *(_DWORD *)&v120[4 * (i & 7)];
              if ( i <= 7 )
                break;
            }
          }
          if ( !v121 )
            goto LABEL_238;
LABEL_289:
          v18 = (unsigned __int64)v108;
          LODWORD(v197) = v102;
          LOBYTE(v207) = v25;
          v136 = group_number_0(v206, v108, (_DWORD *)v208, v210, a12);
          v102 = v197;
          v25 = (unsigned __int8)v207;
          v108 = v136;
          goto LABEL_235;
        }
        v108 = (u32 *)v208;
        v18 = v199;
        LOBYTE(v207) = v207 & (v210 != 0LL);
        while ( 1 )
        {
          *--v108 = *(_DWORD *)&v120[4 * (v18 % 0xA)];
          if ( v18 <= 9 )
            break;
          v18 /= 0xAuLL;
        }
        if ( (_BYTE)v207 )
          goto LABEL_289;
LABEL_235:
        if ( v102 == 10 && (_BYTE)v25 )
        {
          v18 = v208;
          LODWORD(v207) = 10;
          v122 = i18n_number_rewrite_1(v108, v208, (_DWORD *)v208);
          v102 = v207;
          v108 = v122;
        }
LABEL_238:
        v123 = v208;
        v24 = v208 - (_QWORD)v108;
        v124 = (v208 - (__int64)v108) >> 2;
        j = v124;
        if ( v124 >= v44 )
        {
          if ( v199 )
          {
            v132 = v201 & 1;
            if ( v102 == 8 && v132 )
            {
              *(v108 - 1) = 48;
              v133 = v123 - (_QWORD)--v108;
              v24 = v133;
            }
            j = v24 >> 2;
            v22 = v44 - (v24 >> 2);
            if ( (v22 & 0x8000000000000000LL) != 0LL )
              v22 = 0LL;
            v18 = (unsigned int)v209;
            LODWORD(v44) = v22;
            if ( !(_DWORD)v209 )
            {
              LODWORD(v209) = v24 >> 2;
              v125 = v48 - j - v22;
LABEL_276:
              if ( v102 == 16 )
              {
                v22 = (unsigned int)(v125 - 2);
                if ( v132 )
                  v125 -= 2;
              }
LABEL_243:
              if ( (unsigned int)v211 | (unsigned int)v205 | v204 )
              {
                --v125;
                if ( (_BYTE)v203 != 32 )
                  goto LABEL_245;
                if ( v125 <= 0 )
                {
                  v125 = 0;
                  goto LABEL_245;
                }
              }
              else
              {
                if ( (_BYTE)v203 != 32 )
                  goto LABEL_251;
                if ( v125 <= 0 )
                {
                  v125 = 0;
                  goto LABEL_251;
                }
              }
              v18 = 32LL;
              v197 = j;
              v208 = v125;
              v203 = v102;
              v207 = (unsigned __int64)v108;
              v138 = (_DWORD *)IO_wpadn(v39, 32LL, v125, j, (u32 *)v125, v25);
              v24 = v208;
              if ( (_DWORD *)v208 != v138 )
                goto LABEL_117;
              v108 = (u32 *)v207;
              v102 = v203;
              j = v197;
              if ( v41 > 0x7FFFFFFE )
                goto LABEL_550;
              if ( 0x7FFFFFFF - v41 < v125 )
                goto LABEL_116;
              v41 += v125;
              v125 = 0;
LABEL_245:
              if ( (_DWORD)v211 )
              {
                v126 = *((_QWORD *)v39 + 20);
                if ( v126 )
                {
                  v22 = *(_QWORD *)(v126 + 32);
                  if ( v22 < *(_QWORD *)(v126 + 40) )
                  {
                    v18 = v22 + 4;
                    *(_QWORD *)(v126 + 32) = v22 + 4;
                    *(_DWORD *)v22 = 45;
LABEL_249:
                    if ( v41 == 0x7FFFFFFF )
                      goto LABEL_117;
                    ++v41;
LABEL_251:
                    if ( !v199 || v102 != 16 || (v201 & 1) == 0 )
                    {
LABEL_261:
                      v129 = v125 + v44;
                      if ( v129 > 0 )
                      {
                        v18 = 48LL;
                        v211 = (u32 *)j;
                        v215 = (__int64)v108;
                        if ( v129 != IO_wpadn(v39, 48LL, v129, j, (u32 *)v24, v25) )
                          goto LABEL_117;
                        if ( v41 > 0x7FFFFFFE )
LABEL_550:
                          _assert_fail(
                            (__int64)"(unsigned int) done < (unsigned int) INT_MAX",
                            (__int64)"vfprintf.c",
                            0x7E1u,
                            "printf_positional");
                        if ( 0x7FFFFFFF - v41 < v129 )
                          goto LABEL_116;
                        v41 += v129;
                        j = (unsigned __int64)v211;
                        v108 = (u32 *)v215;
                      }
                      if ( (v41 & 0x80000000) != 0 )
LABEL_540:
                        _assert_fail(
                          (__int64)"(size_t) done <= (size_t) INT_MAX",
                          (__int64)"vfprintf.c",
                          0x7E1u,
                          "printf_positional");
                      v130 = *((_QWORD *)v39 + 27);
                      if ( (char *)&_start___libc_atexit - (char *)_start___libc_IO_vtables <= (unsigned __int64)(v130 - (_QWORD)_start___libc_IO_vtables) )
                      {
                        v211 = (u32 *)j;
                        v215 = (__int64)v108;
                        IO_vtable_check(
                          v130 - (_QWORD)_start___libc_IO_vtables,
                          v18,
                          (__int64)_start___libc_IO_vtables,
                          j,
                          (u32 *)v24,
                          v25);
                        j = (unsigned __int64)v211;
                        v108 = (u32 *)v215;
                      }
                      v215 = j;
                      v18 = (unsigned __int64)v108;
                      v131 = (_QWORD *)(*(__int64 (__fastcall **)(char *, u32 *, unsigned __int64, unsigned __int64, __int64, __int64))(v130 + 56))(
                                         v39,
                                         v108,
                                         j,
                                         j,
                                         v24,
                                         v25);
                      j = v215;
                      if ( (_QWORD *)v215 != v131 )
                        goto LABEL_117;
                      if ( (int)(0x7FFFFFFF - v41) < v215 )
                        goto LABEL_116;
                      v41 += v209;
                      break;
                    }
                    v127 = *((_QWORD *)v39 + 20);
                    if ( v127
                      && (v128 = *(_DWORD **)(v127 + 32), v18 = *(_QWORD *)(v127 + 40), (unsigned __int64)v128 < v18) )
                    {
                      v22 = (unsigned __int64)(v128 + 1);
                      *(_QWORD *)(v127 + 32) = v128 + 1;
                      *v128 = 48;
                      if ( v41 == 0x7FFFFFFF )
                        goto LABEL_117;
                    }
                    else
                    {
                      v18 = 48LL;
                      v208 = j;
                      v211 = v108;
                      v185 = _woverflow((__int64)v39, 48LL, v22, j, (u32 *)v24, v25);
                      v108 = v211;
                      j = v208;
                      if ( v185 == -1 || v41 == 0x7FFFFFFF )
                        goto LABEL_117;
                      v127 = *((_QWORD *)v39 + 20);
                      if ( !v127 )
                        goto LABEL_513;
                      v22 = *(_QWORD *)(v127 + 32);
                      v18 = *(_QWORD *)(v127 + 40);
                    }
                    if ( v18 > v22 )
                    {
                      v18 = v22 + 4;
                      *(_QWORD *)(v127 + 32) = v22 + 4;
                      *(_DWORD *)v22 = v215;
LABEL_259:
                      if ( v41 == 2147483646 )
                        goto LABEL_117;
                      v41 += 2;
                      goto LABEL_261;
                    }
LABEL_513:
                    v18 = (unsigned int)v215;
                    v208 = j;
                    v211 = v108;
                    v184 = _woverflow((__int64)v39, (unsigned int)v215, v22, j, (u32 *)v24, v25);
                    v108 = v211;
                    j = v208;
                    if ( v184 == -1 )
                      goto LABEL_117;
                    goto LABEL_259;
                  }
                }
                v207 = j;
                v18 = 45LL;
                LODWORD(v208) = v102;
                v211 = v108;
              }
              else if ( (_DWORD)v205 )
              {
                v159 = *((_QWORD *)v39 + 20);
                if ( v159 )
                {
                  v22 = *(_QWORD *)(v159 + 32);
                  if ( v22 < *(_QWORD *)(v159 + 40) )
                  {
                    v18 = v22 + 4;
                    *(_QWORD *)(v159 + 32) = v22 + 4;
                    *(_DWORD *)v22 = 43;
                    goto LABEL_249;
                  }
                }
                v207 = j;
                v18 = 43LL;
                LODWORD(v208) = v102;
                v211 = v108;
              }
              else
              {
                if ( !v204 )
                  goto LABEL_251;
                v172 = *((_QWORD *)v39 + 20);
                if ( v172 )
                {
                  v22 = *(_QWORD *)(v172 + 32);
                  if ( v22 < *(_QWORD *)(v172 + 40) )
                  {
                    v18 = v22 + 4;
                    *(_QWORD *)(v172 + 32) = v22 + 4;
                    *(_DWORD *)v22 = 32;
                    goto LABEL_249;
                  }
                }
                v207 = j;
                v18 = 32LL;
                LODWORD(v208) = v102;
                v211 = v108;
              }
              v176 = _woverflow((__int64)v39, v18, v22, j, (u32 *)v24, v25);
              v108 = v211;
              v102 = v208;
              j = v207;
              if ( v176 == -1 )
                goto LABEL_117;
              goto LABEL_249;
            }
          }
          else
          {
            v22 = v44 - v124;
            if ( v44 - v124 < 0 )
              v22 = v199;
            LODWORD(v44) = v22;
LABEL_173:
            if ( !(_DWORD)v209 )
            {
              v199 = 0LL;
              j = v24 >> 2;
              LODWORD(v209) = v24 >> 2;
              v125 = v48 - v22 - v209;
              goto LABEL_243;
            }
            v199 = 0LL;
          }
        }
        else
        {
          v22 = v44 - v124;
          if ( v44 - v124 < 0 )
            v22 = 0LL;
          LODWORD(v44) = v22;
          if ( !(_DWORD)v209 )
          {
            LODWORD(v209) = (v208 - (__int64)v108) >> 2;
            v125 = v48 - v124 - v22;
            if ( !v199 )
              goto LABEL_243;
            v132 = v201 & 1;
            goto LABEL_276;
          }
        }
        if ( (_DWORD)v211 )
        {
          v109 = *((_QWORD *)v39 + 20);
          if ( v109 )
          {
            j = *(_QWORD *)(v109 + 32);
            if ( j < *(_QWORD *)(v109 + 40) )
            {
              v18 = j + 4;
              *(_QWORD *)(v109 + 32) = j + 4;
              *(_DWORD *)j = 45;
              goto LABEL_179;
            }
          }
          LODWORD(v207) = v102;
          v18 = 45LL;
          v208 = v22;
          v209 = v24;
          v211 = v108;
        }
        else if ( (_DWORD)v205 )
        {
          v141 = *((_QWORD *)v39 + 20);
          if ( v141 )
          {
            j = *(_QWORD *)(v141 + 32);
            if ( j < *(_QWORD *)(v141 + 40) )
            {
              v18 = j + 4;
              *(_QWORD *)(v141 + 32) = j + 4;
              *(_DWORD *)j = 43;
              goto LABEL_179;
            }
          }
          LODWORD(v207) = v102;
          v18 = 43LL;
          v208 = v22;
          v209 = v24;
          v211 = v108;
        }
        else
        {
          v25 = v204;
          if ( !v204 )
            goto LABEL_181;
          v137 = *((_QWORD *)v39 + 20);
          if ( v137 )
          {
            j = *(_QWORD *)(v137 + 32);
            if ( j < *(_QWORD *)(v137 + 40) )
            {
              v18 = j + 4;
              *(_QWORD *)(v137 + 32) = j + 4;
              *(_DWORD *)j = 32;
              goto LABEL_179;
            }
          }
          LODWORD(v207) = v102;
          v18 = 32LL;
          v208 = v22;
          v209 = v24;
          v211 = v108;
        }
        v175 = _woverflow((__int64)v39, v18, v22, j, (u32 *)v24, v25);
        v108 = v211;
        v24 = v209;
        v22 = v208;
        v102 = v207;
        if ( v175 == -1 )
          goto LABEL_117;
LABEL_179:
        if ( v41 == 0x7FFFFFFF )
          goto LABEL_117;
        ++v41;
        --v48;
LABEL_181:
        if ( !v199 || v102 != 16 || (v201 & 1) == 0 )
          goto LABEL_191;
        v110 = *((_QWORD *)v39 + 20);
        if ( v110 && (v111 = *(_DWORD **)(v110 + 32), v18 = *(_QWORD *)(v110 + 40), (unsigned __int64)v111 < v18) )
        {
          j = (unsigned __int64)(v111 + 1);
          *(_QWORD *)(v110 + 32) = v111 + 1;
          *v111 = 48;
          if ( v41 == 0x7FFFFFFF )
            goto LABEL_117;
        }
        else
        {
          v18 = 48LL;
          v208 = v22;
          v209 = v24;
          v211 = v108;
          v183 = _woverflow((__int64)v39, 48LL, v22, j, (u32 *)v24, v25);
          v108 = v211;
          v24 = v209;
          v22 = v208;
          if ( v183 == -1 || v41 == 0x7FFFFFFF )
            goto LABEL_117;
          v110 = *((_QWORD *)v39 + 20);
          if ( !v110 )
            goto LABEL_507;
          j = *(_QWORD *)(v110 + 32);
          v18 = *(_QWORD *)(v110 + 40);
        }
        if ( j < v18 )
        {
          v18 = j + 4;
          *(_QWORD *)(v110 + 32) = j + 4;
          *(_DWORD *)j = v215;
          goto LABEL_189;
        }
LABEL_507:
        v18 = (unsigned int)v215;
        v208 = v22;
        v209 = v24;
        v211 = v108;
        v182 = _woverflow((__int64)v39, (unsigned int)v215, v22, j, (u32 *)v24, v25);
        v108 = v211;
        v24 = v209;
        v22 = v208;
        if ( v182 == -1 )
          goto LABEL_117;
LABEL_189:
        if ( v41 == 2147483646 )
          goto LABEL_117;
        v41 += 2;
        v48 -= 2;
LABEL_191:
        v112 = v24 >> 2;
        v80 = v48 - (v112 + v22);
        if ( (int)v44 > 0 )
        {
          v18 = 48LL;
          v209 = v112;
          v215 = (int)v44;
          v211 = v108;
          v139 = (_QWORD *)IO_wpadn(v39, 48LL, v44, (int)v44, (u32 *)v112, v25);
          j = v215;
          if ( (_QWORD *)v215 != v139 )
            goto LABEL_117;
          if ( v41 > 0x7FFFFFFE )
            goto LABEL_550;
          if ( 0x7FFFFFFF - v41 < (unsigned int)v44 )
            goto LABEL_116;
          v41 += v44;
          v112 = v209;
          v108 = v211;
        }
        if ( (v41 & 0x80000000) != 0 )
          goto LABEL_540;
        v113 = *((_QWORD *)v39 + 27);
        if ( (char *)&_start___libc_atexit - (char *)_start___libc_IO_vtables <= (unsigned __int64)(v113
                                                                                                  - (_QWORD)_start___libc_IO_vtables) )
        {
          v211 = (u32 *)v112;
          v215 = (__int64)v108;
          IO_vtable_check(
            v113 - (_QWORD)_start___libc_IO_vtables,
            v18,
            (__int64)_start___libc_IO_vtables,
            j,
            (u32 *)v112,
            v25);
          v112 = (__int64)v211;
          v108 = (u32 *)v215;
        }
        v215 = v112;
        v18 = (unsigned __int64)v108;
        v114 = (_QWORD *)(*(__int64 (__fastcall **)(char *, u32 *, __int64, unsigned __int64, __int64, __int64))(v113 + 56))(
                           v39,
                           v108,
                           v112,
                           j,
                           v112,
                           v25);
        v24 = v215;
        if ( (_QWORD *)v215 != v114 )
          goto LABEL_117;
        if ( v215 > (int)(0x7FFFFFFF - v41) )
          goto LABEL_116;
        v41 += v215;
        if ( v80 > 0 )
        {
          v18 = 32LL;
          v215 = v80;
          v115 = (_QWORD *)IO_wpadn(v39, 32LL, v80, v80, (u32 *)v24, v25);
          j = v215;
          if ( (_QWORD *)v215 != v115 )
            goto LABEL_117;
          if ( v41 > 0x7FFFFFFE )
            goto LABEL_550;
          if ( 0x7FFFFFFF - v41 < v80 )
            goto LABEL_116;
LABEL_201:
          v41 += v80;
        }
        break;
      case 'u':
        v102 = 10;
LABEL_164:
        v18 = (unsigned int)v211;
        v105 = &v217[2 * *((int *)v40 + 12)];
        if ( (_DWORD)v211 )
        {
          LODWORD(v205) = 0;
          v106 = *v105;
          v204 = 0;
          v199 = v106;
          LODWORD(v211) = 0;
        }
        else
        {
          j = (unsigned int)v199;
          v134 = *(unsigned int *)v105;
          if ( (_DWORD)v199 )
          {
            LODWORD(v205) = 0;
            v199 = (unsigned __int8)v134;
            v204 = 0;
          }
          else
          {
            if ( v201 )
              v134 = (unsigned __int16)v134;
            v199 = v134;
            LODWORD(v205) = 0;
            v204 = 0;
          }
        }
LABEL_166:
        v201 = (unsigned __int8)v24;
        v103 = v207;
        if ( (int)v44 < 0 )
        {
          v44 = 1LL;
          goto LABEL_229;
        }
        if ( (_DWORD)v44 )
          goto LABEL_157;
        if ( v199 )
          goto LABEL_330;
        if ( v102 == 8 && (_BYTE)v24 )
        {
          v107 = v208;
          v24 = 4LL;
          *(_DWORD *)(v208 - 4) = 48;
          v208 = v107 - 4;
        }
        else
        {
          v24 = 0LL;
        }
        LOBYTE(v203) = 32;
        v108 = (u32 *)v208;
        v22 = 0LL;
        goto LABEL_173;
      default:
        v56 = v40[7];
        v57 = 8 * v56 + 23;
        v58 = (__int64 *)((char *)&v191 - (v57 & 0xFFFFFFFFFFFFF000LL));
        v59 = v57 & 0xFFF0;
        while ( &v191 != v58 )
          ;
        v145 = v59 & 0xFFF;
        if ( (_DWORD)v145 )
        {
          v146 = alloca((unsigned int)v145);
          *(_QWORD *)&v190[(unsigned int)v145 + 4080] = *(_QWORD *)&v190[(unsigned int)v145 + 4080];
        }
        v24 = (__int64)&v192;
        if ( v56 )
        {
          v147 = *((_DWORD *)v40 + 12);
          v25 = (__int64)v217;
          LODWORD(v145) = 0;
          for ( j = 0LL; j < v56; v145 = j )
          {
            *((_QWORD *)&v192 + j) = v25 + 16LL * (unsigned int)(v145 + v147);
            j = (unsigned int)(v145 + 1);
          }
        }
        v148 = *((_QWORD *)v39 + 20);
        if ( v148 )
        {
          v145 = *(_QWORD *)(v148 + 32);
          v18 = *(_QWORD *)(v148 + 40);
          if ( v145 < v18 )
          {
            j = v145 + 4;
            *(_QWORD *)(v148 + 32) = v145 + 4;
            *(_DWORD *)v145 = 37;
            v149 = *((unsigned __int8 *)v40 + 12);
            if ( (v149 & 8) == 0 )
            {
              v150 = 1;
              if ( (v149 & 0x80u) == 0LL )
                goto LABEL_356;
LABEL_441:
              v149 = *(_QWORD *)(v148 + 32);
              if ( v149 < *(_QWORD *)(v148 + 40) )
              {
                j = v149 + 4;
                *(_QWORD *)(v148 + 32) = v149 + 4;
                *(_DWORD *)v149 = 39;
LABEL_443:
                ++v150;
                v149 = *((unsigned __int8 *)v40 + 12);
                goto LABEL_356;
              }
LABEL_495:
              v18 = 39LL;
              if ( (unsigned int)_woverflow((__int64)v39, 39LL, v149, j, (u32 *)v24, v25) == -1 )
                goto LABEL_117;
              goto LABEL_443;
            }
            goto LABEL_354;
          }
        }
        v18 = 37LL;
        if ( (unsigned int)_woverflow((__int64)v39, 37LL, v145, j, &v192, v25) == -1 )
          goto LABEL_117;
        v149 = *((unsigned __int8 *)v40 + 12);
        v150 = 1;
        if ( (v149 & 8) == 0 )
          goto LABEL_493;
        v148 = *((_QWORD *)v39 + 20);
        if ( v148 )
        {
          j = *(_QWORD *)(v148 + 32);
          v18 = *(_QWORD *)(v148 + 40);
LABEL_354:
          if ( v18 > j )
          {
            v150 = 2;
            *(_QWORD *)(v148 + 32) = j + 4;
            *(_DWORD *)j = 35;
            v149 = *((unsigned __int8 *)v40 + 12);
            if ( (v149 & 0x80u) == 0LL )
              goto LABEL_356;
            goto LABEL_441;
          }
        }
        v18 = 35LL;
        if ( (unsigned int)_woverflow((__int64)v39, 35LL, v149, j, (u32 *)v24, v25) == -1 )
          goto LABEL_117;
        v149 = *((unsigned __int8 *)v40 + 12);
        v150 = 2;
LABEL_493:
        if ( (v149 & 0x80u) != 0LL )
        {
          v148 = *((_QWORD *)v39 + 20);
          if ( !v148 )
            goto LABEL_495;
          goto LABEL_441;
        }
LABEL_356:
        if ( (v149 & 0x40) != 0 )
        {
          v151 = *((_QWORD *)v39 + 20);
          if ( v151 && (v149 = *(_QWORD *)(v151 + 32), v149 < *(_QWORD *)(v151 + 40)) )
          {
            j = v149 + 4;
            *(_QWORD *)(v151 + 32) = v149 + 4;
            *(_DWORD *)v149 = 43;
          }
          else
          {
            v18 = 43LL;
            if ( (unsigned int)_woverflow((__int64)v39, 43LL, v149, j, (u32 *)v24, v25) == -1 )
              goto LABEL_117;
          }
LABEL_360:
          LOBYTE(v149) = *((_BYTE *)v40 + 12);
          ++v150;
          goto LABEL_361;
        }
        if ( (v149 & 0x10) != 0 )
        {
          v164 = *((_QWORD *)v39 + 20);
          if ( v164 && (v149 = *(_QWORD *)(v164 + 32), v149 < *(_QWORD *)(v164 + 40)) )
          {
            j = v149 + 4;
            *(_QWORD *)(v164 + 32) = v149 + 4;
            *(_DWORD *)v149 = 32;
          }
          else
          {
            v18 = 32LL;
            if ( (unsigned int)_woverflow((__int64)v39, 32LL, v149, j, (u32 *)v24, v25) == -1 )
              goto LABEL_117;
          }
          goto LABEL_360;
        }
LABEL_361:
        v22 = v149 & 0x20;
        if ( (_DWORD)v22 )
        {
          v152 = *((_QWORD *)v39 + 20);
          if ( v152 && (v22 = *(_QWORD *)(v152 + 32), v22 < *(_QWORD *)(v152 + 40)) )
          {
            j = v22 + 4;
            *(_QWORD *)(v152 + 32) = v22 + 4;
            *(_DWORD *)v22 = 45;
          }
          else
          {
            v18 = 45LL;
            if ( (unsigned int)_woverflow((__int64)v39, 45LL, v22, j, (u32 *)v24, v25) == -1 )
              goto LABEL_117;
          }
          ++v150;
        }
        if ( *((_DWORD *)v40 + 4) == 48 )
        {
          v171 = *((_QWORD *)v39 + 20);
          if ( v171 && (v22 = *(_QWORD *)(v171 + 32), v22 < *(_QWORD *)(v171 + 40)) )
          {
            j = v22 + 4;
            *(_QWORD *)(v171 + 32) = v22 + 4;
            *(_DWORD *)v22 = 48;
          }
          else
          {
            v18 = 48LL;
            if ( (unsigned int)_woverflow((__int64)v39, 48LL, v22, j, (u32 *)v24, v25) == -1 )
              goto LABEL_117;
          }
          ++v150;
        }
        if ( (*((_BYTE *)v40 + 13) & 8) != 0 )
        {
          v153 = *((_QWORD *)v39 + 20);
          if ( v153 && (v22 = *(_QWORD *)(v153 + 32), v22 < *(_QWORD *)(v153 + 40)) )
          {
            *(_QWORD *)(v153 + 32) = v22 + 4;
            *(_DWORD *)v22 = 73;
          }
          else
          {
            v18 = 73LL;
            if ( (unsigned int)_woverflow((__int64)v39, 73LL, v22, j, (u32 *)v24, v25) == -1 )
              goto LABEL_117;
          }
          ++v150;
        }
        j = *((int *)v40 + 1);
        if ( (_DWORD)j )
        {
          v154 = (__int64 **)(v195 + 48);
          while ( 1 )
          {
            v154 = (__int64 **)((char *)v154 - 4);
            v22 = j / 0xA;
            v18 = *(unsigned int *)&itowa_lower_digits[4 * (j % 0xA)];
            *(_DWORD *)v154 = v18;
            if ( j <= 9 )
              break;
            j /= 0xAuLL;
          }
          if ( v154 < v193 )
          {
            LODWORD(v215) = v41;
            v155 = (unsigned __int64)v193;
            while ( 1 )
            {
              v156 = *((_QWORD *)v39 + 20);
              v154 = (__int64 **)((char *)v154 + 4);
              if ( v156 && (v22 = *(_QWORD *)(v156 + 32), v22 < *(_QWORD *)(v156 + 40)) )
              {
                j = v22 + 4;
                *(_QWORD *)(v156 + 32) = v22 + 4;
                *(_DWORD *)v22 = v18;
                if ( (_DWORD)v18 == -1 )
                  goto LABEL_117;
              }
              else if ( (unsigned int)_woverflow((__int64)v39, v18, v22, j, (u32 *)v24, v25) == -1 )
              {
                goto LABEL_117;
              }
              if ( v150 == 0x7FFFFFFF )
                goto LABEL_117;
              ++v150;
              if ( (unsigned __int64)v154 >= v155 )
                break;
              v18 = *(unsigned int *)v154;
            }
            v41 = v215;
          }
        }
        if ( *(_DWORD *)v40 != -1 )
        {
          v160 = *((_QWORD *)v39 + 20);
          if ( v160 && (v22 = *(_QWORD *)(v160 + 32), v22 < *(_QWORD *)(v160 + 40)) )
          {
            j = v22 + 4;
            *(_QWORD *)(v160 + 32) = v22 + 4;
            *(_DWORD *)v22 = 46;
          }
          else
          {
            v18 = 46LL;
            if ( (unsigned int)_woverflow((__int64)v39, 46LL, v22, j, (u32 *)v24, v25) == -1 )
              goto LABEL_117;
          }
          if ( v150 == 0x7FFFFFFF )
            goto LABEL_117;
          ++v150;
          j = *(int *)v40;
          v161 = (__int64 **)(v195 + 48);
          while ( 1 )
          {
            v161 = (__int64 **)((char *)v161 - 4);
            v22 = j / 0xA;
            v18 = *(unsigned int *)&itowa_lower_digits[4 * (j % 0xA)];
            *(_DWORD *)v161 = v18;
            if ( j <= 9 )
              break;
            j /= 0xAuLL;
          }
          if ( v161 < v193 )
          {
            LODWORD(v215) = v41;
            v162 = (unsigned __int64)v193;
            while ( 1 )
            {
              v163 = *((_QWORD *)v39 + 20);
              v161 = (__int64 **)((char *)v161 + 4);
              if ( v163 && (v22 = *(_QWORD *)(v163 + 32), v22 < *(_QWORD *)(v163 + 40)) )
              {
                j = v22 + 4;
                *(_QWORD *)(v163 + 32) = v22 + 4;
                *(_DWORD *)v22 = v18;
                if ( (_DWORD)v18 == -1 )
                  goto LABEL_117;
              }
              else if ( (unsigned int)_woverflow((__int64)v39, v18, v22, j, (u32 *)v24, v25) == -1 )
              {
                goto LABEL_117;
              }
              if ( v150 == 0x7FFFFFFF )
                goto LABEL_117;
              ++v150;
              if ( (unsigned __int64)v161 >= v162 )
                break;
              v18 = *(unsigned int *)v161;
            }
            v41 = v215;
          }
        }
        v18 = *((unsigned int *)v40 + 2);
        if ( (_DWORD)v18 )
        {
          v170 = *((_QWORD *)v39 + 20);
          if ( v170 && (v22 = *(_QWORD *)(v170 + 32), v22 < *(_QWORD *)(v170 + 40)) )
          {
            j = v22 + 4;
            *(_QWORD *)(v170 + 32) = v22 + 4;
            *(_DWORD *)v22 = v18;
            if ( (_DWORD)v18 == -1 )
              goto LABEL_117;
          }
          else if ( (unsigned int)_woverflow((__int64)v39, v18, v22, j, (u32 *)v24, v25) == -1 )
          {
            goto LABEL_117;
          }
          if ( v150 == 0x7FFFFFFF )
            goto LABEL_117;
          ++v150;
        }
        if ( v41 > 0x7FFFFFFE )
          _assert_fail(
            (__int64)"(unsigned int) done < (unsigned int) INT_MAX",
            (__int64)"vfprintf.c",
            0x7FDu,
            "printf_positional");
        if ( 0x7FFFFFFF - v41 < v150 )
        {
LABEL_116:
          __writefsdword(0xFFFFFFC0, 0x4Bu);
LABEL_117:
          if ( v212 )
            free(v212, v18, v22, j, (u32 *)v24, v25);
          goto LABEL_119;
        }
        v41 += v150;
        break;
    }
LABEL_211:
    if ( v212 )
      free(v212, v18, v22, j, (u32 *)v24, v25);
    if ( (v41 & 0x80000000) != 0 )
      _assert_fail((__int64)"(size_t) done <= (size_t) INT_MAX", (__int64)"vfprintf.c", 0x809u, "printf_positional");
    v117 = *((_QWORD *)v39 + 27);
    if ( (char *)&_start___libc_atexit - (char *)_start___libc_IO_vtables <= (unsigned __int64)(v117
                                                                                              - (_QWORD)_start___libc_IO_vtables) )
      IO_vtable_check(
        v117 - (_QWORD)_start___libc_IO_vtables,
        v18,
        (__int64)_start___libc_IO_vtables,
        j,
        (u32 *)v24,
        v25);
    v18 = v40[3];
    v118 = (*(__int64 (__fastcall **)(char *, unsigned __int64, __int64, unsigned __int64, __int64, __int64))(v117 + 56))(
             v39,
             v18,
             (__int64)(v40[4] - v18) >> 2,
             j,
             v24,
             v25);
    v22 = (v40[4] - v40[3]) >> 2;
    if ( v22 != v118 )
      goto LABEL_119;
    if ( (__int64)v22 > (int)(0x7FFFFFFF - v41) )
      break;
    ++v214;
    v41 += v22;
    v40 += 9;
    if ( v198 <= v214 )
      goto LABEL_120;
  }
  v41 = -1;
  __writefsdword(0xFFFFFFC0, 0x4Bu);
LABEL_120:
  if ( (__int64 *)v226[0] != v213 + 2 )
    free(v226[0], v18, v22, j, (u32 *)v24, v25);
  if ( v223 != v216 + 2 )
    free((__int64)v223, v18, v22, j, (u32 *)v24, v25);
  return v41;
}
// 45A392: conditional instruction was optimized away because er11.4==8
// 45928B: variable 'v21' is possibly undefined
// 45928B: variable 'v12' is possibly undefined
// 45928B: variable 'a5' is possibly undefined
// 45928B: variable 'a6' is possibly undefined
// 459444: variable 'v24' is possibly undefined
// 459444: variable 'v25' is possibly undefined
// 459B0F: variable 'j' is possibly undefined
// 459B54: variable 'v22' is possibly undefined
// 45B618: variable 'v178' is possibly undefined
// 45B618: variable 'v179' is possibly undefined
// 45B618: variable 'v180' is possibly undefined
// 45B618: variable 'v181' is possibly undefined
// 45B8BB: variable 'v52' is possibly undefined
// 45B9E9: variable 'v91' is possibly undefined
// 45B9E9: variable 'v92' is possibly undefined
// 401028: using guessed type __int64 __fastcall j_strnlen(_QWORD, _QWORD);
// 401048: using guessed type __int64 __fastcall j_wcslen(_QWORD);
// 401090: using guessed type __int64 __fastcall j_memset_ifunc(_QWORD, _QWORD, _QWORD);
// 401098: using guessed type __int64 __fastcall j_wcsnlen(_QWORD, _QWORD);
// 4010C8: using guessed type __int64 __fastcall j_strlen_ifunc(_QWORD);
// 4A9C40: using guessed type u32 _start___libc_IO_vtables[48];
// 4AA2E8: using guessed type __int64 (__fastcall *_start___libc_atexit)();
// 4ABA08: using guessed type __int64 _printf_function_table;
// 4ABA28: using guessed type __int64 _printf_arginfo_table;
// 4ABA30: using guessed type __int64 _printf_va_arg_table;

//----- (000000000045BAB0) ----------------------------------------------------
__int64 __fastcall vfwprintf(__int64 a1, int *a2, __m128i *a3, __int64 a4, u32 *a5, __int64 a6)
{
  __int64 v9; // rdx
  __int64 v10; // rcx
  u32 *v11; // r8
  __int64 v12; // r9
  __int64 v13; // rcx
  u32 *v14; // r8
  __int64 v15; // r9
  int v16; // er12
  __int64 v17; // rax
  int *v19; // rdi
  __int64 v20; // rcx
  u32 *v21; // r8
  __int64 v22; // r9
  __int64 v23; // rax
  unsigned __int64 j; // rsi
  unsigned __int64 v25; // rdi
  signed __int64 v26; // r12
  unsigned __int64 v27; // rcx
  __int64 v28; // r8
  __int64 v29; // r9
  int *v30; // rdx
  unsigned int v31; // er15
  unsigned int v32; // er11
  __int64 v33; // rdx
  char *v34; // r10
  bool v36; // zf
  __int64 v37; // rdx
  int v39; // eax
  int v40; // er15
  unsigned __int32 v41; // eax
  __int64 v42; // rax
  int *v43; // r15
  int *v44; // rdi
  int *v45; // rax
  u32 *v46; // r8
  __int64 v47; // r9
  __int64 v48; // rcx
  __int64 v49; // rax
  unsigned __int32 v50; // eax
  unsigned __int8 *v51; // rdx
  unsigned int v52; // eax
  __int64 v53; // rax
  unsigned __int8 *v54; // rax
  const char *v55; // r9
  unsigned __int64 v56; // r15
  _BOOL4 v57; // eax
  __int64 v58; // rcx
  u32 *v59; // r8
  __int64 v60; // r9
  _QWORD *v61; // rdx
  char **v62; // rcx
  void *v63; // rsp
  __int64 v64; // rax
  __int64 v65; // r8
  __int64 v66; // rax
  unsigned __int32 v67; // eax
  _QWORD **v68; // rdx
  _QWORD *v69; // rax
  unsigned __int32 v70; // eax
  __int64 *v71; // rdx
  const char *v72; // rcx
  _DWORD *v73; // rax
  _DWORD *v74; // rax
  __int64 v75; // rax
  _QWORD *v76; // r10
  int v77; // er10
  char v78; // al
  __int64 v79; // rax
  __int64 v80; // rax
  int v81; // er15
  __int64 v82; // r15
  __int64 v83; // rax
  __int64 v84; // r8
  LONG_DOUBLE_16 *v85; // rax
  int v86; // eax
  unsigned int v87; // eax
  u32 *v88; // r8
  LONG_DOUBLE_16 *v89; // rax
  unsigned __int32 v90; // eax
  __int64 *v91; // rdx
  __int64 v92; // rax
  int v93; // eax
  unsigned __int32 v94; // eax
  int v95; // eax
  unsigned __int64 v96; // r15
  _BOOL4 v97; // eax
  void *v98; // rsp
  unsigned int v99; // eax
  unsigned __int32 v100; // eax
  int *v101; // rax
  unsigned int v102; // eax
  unsigned __int64 v103; // r15
  _BOOL4 v104; // eax
  void *v105; // rsp
  unsigned __int32 v106; // eax
  __int64 *v107; // rdx
  __int64 v108; // rax
  __int64 v109; // rax
  int v110; // eax
  __int64 v111; // rax
  __int64 v112; // rax
  __int64 v113; // r15
  __int64 v114; // rax
  unsigned int v115; // er15
  __int64 v116; // rax
  __int64 v117; // rdx
  unsigned __int8 *v118; // rdx
  __int64 v119; // rax
  __int64 v120; // rax
  unsigned __int64 k; // rax
  unsigned __int64 i; // rax
  __int64 v123; // rax
  __int64 v124; // rax
  __int64 v125; // rax
  __int64 v126; // rax
  __int64 v127; // rax
  __int64 v128; // rax
  __int64 v129; // rax
  unsigned int *v130; // rdx
  __int64 v131; // rax
  __int64 v132; // rax
  __int64 v133; // rax
  __int64 v134; // rax
  unsigned __int32 v135; // eax
  _QWORD *v136; // rdx
  char *v137; // rdx
  unsigned __int32 v138; // eax
  _QWORD *v139; // rdx
  unsigned __int16 *v140; // rdx
  __int64 v141; // rax
  int v142; // eax
  unsigned __int32 v143; // eax
  int *v144; // rsi
  int v145; // esi
  unsigned int v146; // eax
  int v147; // eax
  unsigned __int64 v148; // r15
  _BOOL4 v149; // eax
  void *v150; // rsp
  __int64 v151; // rax
  __int64 v152; // rax
  __int64 v153; // rax
  __int64 v154; // rax
  int *v155; // rdx
  int v156; // eax
  __int64 v157; // r15
  int v158; // eax
  unsigned int v159; // eax
  int v160; // eax
  _QWORD *v161; // rax
  __int64 v162; // rdx
  __int64 v163; // rcx
  u32 *v164; // r8
  __int64 v165; // r9
  int v166; // eax
  __int16 *v167; // rdx
  int v168; // eax
  int v169; // eax
  int v170; // eax
  int v171; // eax
  int v172; // eax
  _QWORD *v173; // rax
  _QWORD *v174; // rax
  _QWORD *v175; // rax
  _BYTE v177[4096]; // [rsp+8h] [rbp-2550h] BYREF
  __int64 v178; // [rsp+1008h] [rbp-1550h] BYREF
  _BYTE v179[7]; // [rsp+1010h] [rbp-1548h] BYREF
  char *v180; // [rsp+2008h] [rbp-550h] BYREF
  char *v181; // [rsp+2010h] [rbp-548h]
  char *v182; // [rsp+2018h] [rbp-540h]
  int v183; // [rsp+2020h] [rbp-538h]
  int v184; // [rsp+2024h] [rbp-534h]
  unsigned __int64 v185; // [rsp+2028h] [rbp-530h]
  __int64 v186; // [rsp+2030h] [rbp-528h]
  unsigned int v187; // [rsp+2038h] [rbp-520h]
  unsigned int v188; // [rsp+203Ch] [rbp-51Ch]
  __int64 v189; // [rsp+2040h] [rbp-518h]
  int v190; // [rsp+2048h] [rbp-510h]
  int v191; // [rsp+204Ch] [rbp-50Ch]
  unsigned __int64 v192; // [rsp+2050h] [rbp-508h]
  __int64 v193; // [rsp+2058h] [rbp-500h]
  unsigned __int64 v194; // [rsp+2060h] [rbp-4F8h]
  __int64 v195; // [rsp+2068h] [rbp-4F0h]
  __int64 v196; // [rsp+2070h] [rbp-4E8h]
  __int64 v197; // [rsp+2078h] [rbp-4E0h]
  unsigned __int64 v198; // [rsp+2080h] [rbp-4D8h]
  _QWORD *v199; // [rsp+2088h] [rbp-4D0h]
  unsigned __int64 v200; // [rsp+2090h] [rbp-4C8h]
  int *v201; // [rsp+2098h] [rbp-4C0h]
  unsigned int v202; // [rsp+20A0h] [rbp-4B8h]
  int v203; // [rsp+20A4h] [rbp-4B4h]
  int *v204; // [rsp+20B0h] [rbp-4A8h] BYREF
  LONG_DOUBLE_16 *v205; // [rsp+20B8h] [rbp-4A0h] BYREF
  LONG_DOUBLE_16 *v206; // [rsp+20C0h] [rbp-498h] BYREF
  LONG_DOUBLE_16 v207; // [rsp+20C8h] [rbp-490h] BYREF
  _DWORD *v208; // [rsp+20D8h] [rbp-480h] BYREF
  unsigned int v209; // [rsp+20E0h] [rbp-478h]
  int v210; // [rsp+20E4h] [rbp-474h]
  int v211; // [rsp+20E8h] [rbp-470h]
  __int64 v212[4]; // [rsp+20F8h] [rbp-460h] BYREF
  __int64 v213; // [rsp+2118h] [rbp-440h] BYREF
  __m128i v214; // [rsp+2120h] [rbp-438h] BYREF
  __int64 v215; // [rsp+2130h] [rbp-428h]
  char v216[1000]; // [rsp+2138h] [rbp-420h] BYREF
  __int64 v217[7]; // [rsp+2520h] [rbp-38h] BYREF

  v217[0] = __readfsqword(0x28u);
  v202 = __readfsdword(0xFFFFFFC0);
  if ( (unsigned int)IO_fwide(a1, 1LL, (__int64)a3, a4, a5, a6) != 1 )
    goto LABEL_292;
  if ( (*(_DWORD *)a1 & 8) != 0 )
  {
    *(_DWORD *)a1 |= 0x20u;
    __writefsdword(0xFFFFFFC0, 9u);
LABEL_292:
    LODWORD(v26) = -1;
    return (unsigned int)v26;
  }
  if ( !a2 )
  {
    LODWORD(v26) = -1;
    __writefsdword(0xFFFFFFC0, 0x16u);
    return (unsigned int)v26;
  }
  if ( (unsigned int)IO_fwide(a1, 1LL, v9, v10, v11, v12) != 1 )
    goto LABEL_292;
  v16 = *(_DWORD *)a1;
  LODWORD(v198) = *(_DWORD *)a1 & 2;
  if ( (_DWORD)v198 )
  {
    LODWORD(v26) = buffered_vfprintf_0(a1, (__int64)a2, a3, v13, v14, v15);
    return (unsigned int)v26;
  }
  v17 = a3[1].m128i_i64[0];
  _RSI = 37LL;
  v19 = a2;
  v214 = _mm_loadu_si128(a3);
  v215 = v17;
  v201 = wcschrnul(a2, 37);
  v204 = v201;
  v203 = v16 & 0x8000;
  if ( (v16 & 0x8000) != 0 )
  {
    v203 = 0;
    goto LABEL_8;
  }
  v212[1] = a1;
  v212[0] = (__int64)funlockfile;
  _RDX = *(_QWORD *)(a1 + 136);
  v21 = (u32 *)__readfsqword(0x10u);
  if ( *(u32 **)(_RDX + 8) != v21 )
  {
    _RSI = 1LL;
    v36 = _libc_multiple_threads == 0;
    if ( _libc_multiple_threads )
    {
      if ( !_InterlockedCompareExchange((volatile signed __int32 *)_RDX, 1, 0) )
        goto LABEL_24;
    }
    else
    {
      __asm { cmpxchg [rdx], esi }
      if ( v36 )
      {
LABEL_24:
        _RDX = *(_QWORD *)(a1 + 136);
        *(_QWORD *)(_RDX + 8) = v21;
        goto LABEL_25;
      }
    }
    v19 = (int *)_RDX;
    _lll_lock_wait_private((u32 *)_RDX, 1LL, _RDX, v20, v21, v22);
    goto LABEL_24;
  }
LABEL_25:
  ++*(_DWORD *)(_RDX + 4);
LABEL_8:
  v23 = *(_QWORD *)(a1 + 216);
  v200 = (char *)&_start___libc_atexit - (char *)_start___libc_IO_vtables;
  if ( (char *)&_start___libc_atexit - (char *)_start___libc_IO_vtables <= (unsigned __int64)(v23
                                                                                            - (_QWORD)_start___libc_IO_vtables) )
  {
    v199 = (_QWORD *)v23;
    IO_vtable_check(
      (__int64)v19,
      _RSI,
      v23 - (_QWORD)_start___libc_IO_vtables,
      (char *)&_start___libc_atexit - (char *)_start___libc_IO_vtables,
      v21,
      v22);
    v23 = (__int64)v199;
  }
  j = (unsigned __int64)a2;
  v25 = a1;
  v26 = v201 - a2;
  if ( v26 != (*(__int64 (__fastcall **)(__int64, int *, signed __int64))(v23 + 56))(a1, a2, v26) )
  {
LABEL_38:
    LODWORD(v26) = -1;
    goto LABEL_28;
  }
  if ( (char *)v201 - (char *)a2 > 0x1FFFFFFFCLL )
    goto LABEL_47;
  v30 = v204;
  v28 = (unsigned int)*v204;
  if ( (_DWORD)v28 )
  {
    if ( _printf_function_table || _printf_modifier_table || _printf_va_arg_table )
    {
      v184 = 0;
      v34 = v216;
      v183 = 0;
      v189 = -1LL;
    }
    else
    {
      v183 = 0;
      v191 = 0;
      v184 = 0;
      v189 = -1LL;
      while ( 2 )
      {
        v31 = v30[1];
        v204 = v30 + 1;
        v29 = 0LL;
        v32 = 0;
        v33 = 0LL;
        v27 = 0LL;
        v34 = v216;
        j = (unsigned __int64)v217;
        v28 = 0xFFFFFFFFLL;
        LODWORD(v185) = 0;
        LODWORD(v198) = 0;
        v187 = 0;
        LODWORD(v193) = 0;
        LODWORD(v197) = 0;
        v190 = 0;
        v188 = 0;
        v199 = 0LL;
        LODWORD(v192) = 32;
        v196 = (__int64)v217;
        switch ( v31 )
        {
          case ' ':
LABEL_234:
            while ( 2 )
            {
              v31 = v204[1];
              j = (unsigned __int64)++v204;
              v190 = 1;
              switch ( v31 )
              {
                case ' ':
                  continue;
                case '#':
                  goto LABEL_230;
                case '%':
                  goto LABEL_236;
                case '\'':
                  goto LABEL_242;
                case '*':
                  goto LABEL_187;
                case '+':
                  goto LABEL_232;
                case '-':
                  goto LABEL_250;
                case '.':
                  goto LABEL_210;
                case '0':
                  goto LABEL_245;
                case '1':
                case '2':
                case '3':
                case '4':
                case '5':
                case '6':
                case '7':
                case '8':
                case '9':
                  goto LABEL_213;
                case 'A':
                case 'a':
                  goto LABEL_172;
                case 'C':
                  goto LABEL_54;
                case 'E':
                case 'F':
                case 'G':
                case 'e':
                case 'f':
                case 'g':
                  goto LABEL_178;
                case 'I':
                  goto LABEL_202;
                case 'L':
                case 'q':
                  goto LABEL_241;
                case 'S':
                case 's':
                  goto LABEL_204;
                case 'X':
                case 'x':
                  goto LABEL_182;
                case 'Z':
                case 'j':
                case 't':
                case 'z':
                  goto LABEL_33;
                case 'c':
                  goto LABEL_73;
                case 'd':
                case 'i':
                  goto LABEL_224;
                case 'h':
                  goto LABEL_209;
                case 'l':
                  goto LABEL_249;
                case 'm':
                  goto LABEL_88;
                case 'n':
                  goto LABEL_111;
                case 'o':
                  goto LABEL_207;
                case 'p':
                  goto LABEL_117;
                case 'u':
                  goto LABEL_235;
                default:
                  goto LABEL_34;
              }
            }
          case '!':
          case '"':
          case '$':
          case '&':
          case '(':
          case ')':
          case ',':
          case '/':
          case ':':
          case ';':
          case '<':
          case '=':
          case '>':
          case '?':
          case '@':
          case 'B':
          case 'D':
          case 'H':
          case 'J':
          case 'K':
          case 'M':
          case 'N':
          case 'O':
          case 'P':
          case 'Q':
          case 'R':
          case 'T':
          case 'U':
          case 'V':
          case 'W':
          case 'Y':
          case '[':
          case '\\':
          case ']':
          case '^':
          case '_':
          case '`':
          case 'b':
          case 'k':
          case 'r':
          case 'v':
          case 'w':
          case 'y':
            goto LABEL_34;
          case '#':
LABEL_230:
            v188 = 1;
            v31 = v204[1];
            j = (unsigned __int64)++v204;
            v99 = v31 - 32;
            if ( v31 - 32 <= 0x5A )
              goto LABEL_203;
            goto LABEL_34;
          case '%':
LABEL_236:
            v109 = *(_QWORD *)(a1 + 160);
            if ( v109 && (v33 = *(_QWORD *)(v109 + 32), (unsigned __int64)v33 < *(_QWORD *)(v109 + 40)) )
            {
              v27 = v33 + 4;
              *(_QWORD *)(v109 + 32) = v33 + 4;
              *(_DWORD *)v33 = 37;
            }
            else
            {
              j = 37LL;
              if ( (unsigned int)_woverflow(a1, 37LL, v33, v27, (u32 *)v28, v29) == -1 )
                goto LABEL_36;
            }
            if ( (_DWORD)v26 == 0x7FFFFFFF )
              goto LABEL_36;
            LODWORD(v26) = v26 + 1;
            goto LABEL_64;
          case '\'':
LABEL_242:
            if ( v189 == -1 )
            {
              v151 = *(_QWORD *)__readfsqword(0xFFFFFFB8);
              v25 = *(unsigned int *)(v151 + 96);
              v189 = *(_QWORD *)(v151 + 80);
              LOBYTE(v151) = *(_BYTE *)v189;
              v184 = v25;
              if ( (_BYTE)v151 == 127 || (_BYTE)v151 == 0 || !(_DWORD)v25 )
                v189 = 0LL;
            }
            v187 = 1;
            v31 = v204[1];
            j = (unsigned __int64)++v204;
            v99 = v31 - 32;
            if ( v31 - 32 <= 0x5A )
              goto LABEL_203;
            goto LABEL_34;
          case '*':
LABEL_187:
            j = (unsigned __int64)(v204 + 1);
            v93 = v204[1];
            v204 = (int *)j;
            v208 = (_DWORD *)j;
            if ( (unsigned int)(v93 - 48) > 9 )
              goto LABEL_188;
            v25 = (unsigned __int64)&v208;
            v181 = v216;
            LODWORD(v182) = 0;
            LODWORD(v186) = -1;
            LODWORD(v194) = 0;
            LODWORD(v195) = 0;
            LODWORD(v198) = 0;
            v39 = read_int_0(&v208);
            v27 = (unsigned int)v198;
            v32 = v195;
            v29 = (unsigned int)v194;
            v28 = (unsigned int)v186;
            v33 = (unsigned int)v182;
            v34 = v181;
            if ( v39 == -1 )
              goto LABEL_110;
            if ( v39 && *v208 == 36 )
              goto LABEL_52;
LABEL_188:
            v94 = a3->m128i_i32[0];
            if ( a3->m128i_i32[0] > 0x2Fu )
            {
              j = a3->m128i_u64[1];
              a3->m128i_i64[1] = j + 8;
            }
            else
            {
              j = a3[1].m128i_i64[0] + v94;
              a3->m128i_i32[0] = v94 + 8;
            }
            v95 = *(_DWORD *)j;
            LODWORD(v198) = v95;
            if ( v95 < 0 )
            {
              LODWORD(v197) = 1;
              LODWORD(v198) = -v95;
              LODWORD(v192) = 32;
            }
            if ( (int)v198 > 536870878 )
              goto LABEL_110;
            if ( (int)v198 <= 217 )
              goto LABEL_201;
            v96 = 4LL * (int)v198 + 128;
            v181 = v34;
            LODWORD(v182) = v33;
            LODWORD(v186) = v28;
            LODWORD(v194) = v29;
            LODWORD(v195) = v32;
            LODWORD(v196) = v27;
            v97 = _libc_alloca_cutoff(v96);
            v27 = (unsigned int)v196;
            v32 = v195;
            v29 = (unsigned int)v194;
            v28 = (unsigned int)v186;
            v33 = (unsigned int)v182;
            v34 = v181;
            if ( v97 || v96 <= 0x1000 )
            {
              v25 = (unsigned __int64)&v180 - ((v96 + 23) & 0xFFFFFFFFFFFFF000LL);
              if ( &v180 != (char **)v25 )
              {
                while ( &v178 != (__int64 *)v25 )
                  ;
              }
              j = ((_WORD)v96 + 23) & 0xFF0;
              if ( (((_WORD)v96 + 23) & 0xFF0) != 0 )
              {
                v98 = alloca(((_WORD)v96 + 23) & 0xFF0);
                *(_QWORD *)&v177[(((_WORD)v96 + 23) & 0xFF0) + 4088] = *(_QWORD *)&v177[(((_WORD)v96 + 23) & 0xFF0)
                                                                                      + 4088];
              }
              v196 = (__int64)&v179[v96];
LABEL_201:
              v31 = *v204;
              switch ( *v204 )
              {
                case '%':
                  goto LABEL_236;
                case '.':
                  goto LABEL_210;
                case 'A':
                case 'a':
                  goto LABEL_172;
                case 'C':
                  goto LABEL_54;
                case 'E':
                case 'F':
                case 'G':
                case 'e':
                case 'f':
                case 'g':
                  goto LABEL_178;
                case 'L':
                case 'q':
                  goto LABEL_241;
                case 'S':
                case 's':
                  goto LABEL_204;
                case 'X':
                case 'x':
                  goto LABEL_182;
                case 'Z':
                case 'j':
                case 't':
                case 'z':
                  goto LABEL_33;
                case 'c':
                  goto LABEL_73;
                case 'd':
                case 'i':
                  goto LABEL_224;
                case 'h':
                  goto LABEL_209;
                case 'l':
                  goto LABEL_249;
                case 'm':
                  goto LABEL_88;
                case 'n':
                  goto LABEL_111;
                case 'o':
                  goto LABEL_207;
                case 'p':
                  goto LABEL_117;
                case 'u':
                  goto LABEL_235;
                default:
                  goto LABEL_34;
              }
            }
            v25 = v96;
            v175 = malloc(
                     v96,
                     j,
                     (_QWORD *)(unsigned int)v182,
                     (unsigned int)v196,
                     (u32 *)(unsigned int)v186,
                     (unsigned int)v194);
            v27 = (unsigned int)v196;
            v32 = v195;
            v199 = v175;
            v29 = (unsigned int)v194;
            v28 = (unsigned int)v186;
            v33 = (unsigned int)v182;
            v34 = v181;
            if ( v175 )
            {
              v196 = (__int64)v199 + v96;
              goto LABEL_201;
            }
            goto LABEL_38;
          case '+':
LABEL_232:
            LODWORD(v193) = 1;
            v31 = v204[1];
            j = (unsigned __int64)++v204;
            v99 = v31 - 32;
            if ( v31 - 32 <= 0x5A )
              goto LABEL_203;
            goto LABEL_34;
          case '-':
LABEL_250:
            while ( 2 )
            {
              v31 = v204[1];
              j = (unsigned __int64)++v204;
              LODWORD(v197) = 1;
              LODWORD(v192) = 32;
              switch ( v31 )
              {
                case ' ':
                  goto LABEL_234;
                case '#':
                  goto LABEL_230;
                case '%':
                  goto LABEL_236;
                case '\'':
                  goto LABEL_242;
                case '*':
                  goto LABEL_187;
                case '+':
                  goto LABEL_232;
                case '-':
                  continue;
                case '.':
                  goto LABEL_210;
                case '0':
                  goto LABEL_245;
                case '1':
                case '2':
                case '3':
                case '4':
                case '5':
                case '6':
                case '7':
                case '8':
                case '9':
                  goto LABEL_213;
                case 'A':
                case 'a':
                  goto LABEL_172;
                case 'C':
                  goto LABEL_54;
                case 'E':
                case 'F':
                case 'G':
                case 'e':
                case 'f':
                case 'g':
                  goto LABEL_178;
                case 'I':
                  goto LABEL_202;
                case 'L':
                case 'q':
                  goto LABEL_241;
                case 'S':
                case 's':
                  goto LABEL_204;
                case 'X':
                case 'x':
                  goto LABEL_182;
                case 'Z':
                case 'j':
                case 't':
                case 'z':
                  goto LABEL_33;
                case 'c':
                  goto LABEL_73;
                case 'd':
                case 'i':
                  goto LABEL_224;
                case 'h':
                  goto LABEL_209;
                case 'l':
                  goto LABEL_249;
                case 'm':
                  goto LABEL_88;
                case 'n':
                  goto LABEL_111;
                case 'o':
                  goto LABEL_207;
                case 'p':
                  goto LABEL_117;
                case 'u':
                  goto LABEL_235;
                default:
                  goto LABEL_34;
              }
            }
          case '.':
LABEL_210:
            v101 = v204;
            v31 = v204[1];
            j = (unsigned __int64)++v204;
            if ( v31 != 42 )
            {
              v28 = 0LL;
              if ( v31 - 48 > 9 )
                goto LABEL_212;
              v25 = (unsigned __int64)&v204;
              v181 = v34;
              LODWORD(v182) = v33;
              LODWORD(v186) = v29;
              LODWORD(v194) = v32;
              LODWORD(v195) = v27;
              v159 = read_int_0(&v204);
              v27 = (unsigned int)v195;
              v32 = v194;
              v28 = v159;
              v29 = (unsigned int)v186;
              v33 = (unsigned int)v182;
              v34 = v181;
              if ( v159 == -1 )
                goto LABEL_110;
              goto LABEL_398;
            }
            j = (unsigned __int64)(v101 + 2);
            v142 = v101[2];
            v204 = (int *)j;
            v208 = (_DWORD *)j;
            if ( (unsigned int)(v142 - 48) > 9 )
              goto LABEL_393;
            v25 = (unsigned __int64)&v208;
            v181 = v34;
            LODWORD(v182) = v33;
            LODWORD(v186) = v29;
            LODWORD(v194) = v32;
            LODWORD(v195) = v27;
            v168 = read_int_0(&v208);
            v27 = (unsigned int)v195;
            v32 = v194;
            v29 = (unsigned int)v186;
            v33 = (unsigned int)v182;
            v34 = v181;
            if ( v168 == -1 )
            {
LABEL_110:
              __writefsdword(0xFFFFFFC0, 0x4Bu);
LABEL_36:
              if ( v199 )
                free((__int64)v199, j, v33, v27, (u32 *)v28, v29);
              goto LABEL_38;
            }
            if ( !v168 || *v208 != 36 )
            {
LABEL_393:
              v143 = a3->m128i_i32[0];
              if ( a3->m128i_i32[0] > 0x2Fu )
              {
                v144 = (int *)a3->m128i_i64[1];
                a3->m128i_i64[1] = (__int64)(v144 + 2);
              }
              else
              {
                v144 = (int *)(a3[1].m128i_i64[0] + v143);
                a3->m128i_i32[0] = v143 + 8;
              }
              v145 = *v144;
              v146 = -1;
              if ( v145 >= 0 )
                v146 = v145;
              v28 = v146;
LABEL_398:
              j = (unsigned int)v198;
              v147 = 218;
              if ( (int)v198 >= 218 )
                v147 = v198;
              if ( (int)v28 <= v147 )
                goto LABEL_499;
              if ( v199 )
              {
                v181 = v34;
                LODWORD(v182) = v33;
                LODWORD(v186) = v28;
                LODWORD(v194) = v29;
                LODWORD(v195) = v32;
                LODWORD(v196) = v27;
                free((__int64)v199, (unsigned int)v198, v33, v27, (u32 *)v28, v29);
                v34 = v181;
                LODWORD(v33) = (_DWORD)v182;
                v28 = (unsigned int)v186;
                LODWORD(v29) = v194;
                v32 = v195;
                v27 = (unsigned int)v196;
              }
              if ( (int)v28 <= 536870878 )
              {
                v182 = v34;
                v148 = 4LL * (int)v28 + 128;
                LODWORD(v186) = v33;
                LODWORD(v194) = v29;
                LODWORD(v195) = v32;
                LODWORD(v196) = v27;
                LODWORD(v199) = v28;
                v149 = _libc_alloca_cutoff(v148);
                v28 = (unsigned int)v199;
                v27 = (unsigned int)v196;
                v32 = v195;
                v29 = (unsigned int)v194;
                v33 = (unsigned int)v186;
                v34 = v182;
                if ( v148 <= 0x1000 || v149 )
                {
                  v25 = (unsigned __int64)&v179[-((v148 + 23) & 0xFFFFFFFFFFFFF000LL) - 8];
                  if ( &v178 != (__int64 *)v25 )
                  {
                    while ( v177 != (_BYTE *)v25 )
                      ;
                  }
                  j = ((_WORD)v148 + 23) & 0xFF0;
                  if ( (((_WORD)v148 + 23) & 0xFF0) != 0 )
                  {
                    v150 = alloca(((_WORD)v148 + 23) & 0xFF0);
                    *(_QWORD *)&v177[(((_WORD)v148 + 23) & 0xFF0) - 8] = *(_QWORD *)&v177[(((_WORD)v148 + 23) & 0xFF0)
                                                                                        - 8];
                  }
                  v199 = 0LL;
                  v196 = (__int64)&v177[v148 + 8];
                  v31 = *v204;
LABEL_212:
                  switch ( v31 )
                  {
                    case '%':
                      goto LABEL_236;
                    case 'A':
                    case 'a':
                      goto LABEL_172;
                    case 'C':
                      goto LABEL_54;
                    case 'E':
                    case 'F':
                    case 'G':
                    case 'e':
                    case 'f':
                    case 'g':
                      goto LABEL_178;
                    case 'L':
                    case 'q':
                      goto LABEL_241;
                    case 'S':
                    case 's':
                      goto LABEL_204;
                    case 'X':
                    case 'x':
                      goto LABEL_182;
                    case 'Z':
                    case 'j':
                    case 't':
                    case 'z':
                      goto LABEL_33;
                    case 'c':
                      goto LABEL_73;
                    case 'd':
                    case 'i':
                      goto LABEL_224;
                    case 'h':
                      goto LABEL_209;
                    case 'l':
                      goto LABEL_249;
                    case 'm':
                      goto LABEL_88;
                    case 'n':
                      goto LABEL_111;
                    case 'o':
                      goto LABEL_207;
                    case 'p':
                      goto LABEL_117;
                    case 'u':
                      goto LABEL_235;
                    default:
                      goto LABEL_34;
                  }
                }
                v25 = v148;
                v181 = v182;
                LODWORD(v182) = v186;
                LODWORD(v186) = (_DWORD)v199;
                v173 = malloc(v148, j, (_QWORD *)v33, (unsigned int)v196, (u32 *)(unsigned int)v199, (unsigned int)v194);
                v27 = (unsigned int)v196;
                v32 = v195;
                v199 = v173;
                v29 = (unsigned int)v194;
                v28 = (unsigned int)v186;
                v33 = (unsigned int)v182;
                v34 = v181;
                if ( !v173 )
                  goto LABEL_38;
                v196 = (__int64)v199 + v148;
LABEL_499:
                v31 = *v204;
                goto LABEL_212;
              }
LABEL_47:
              LODWORD(v26) = -1;
              __writefsdword(0xFFFFFFC0, 0x4Bu);
              goto LABEL_28;
            }
LABEL_52:
            LODWORD(v198) = v191;
            if ( v199 )
            {
              v200 = (unsigned __int64)v34;
              free((__int64)v199, j, v33, v27, (u32 *)v28, v29);
              v34 = (char *)v200;
            }
            break;
          case '0':
LABEL_245:
            v25 = (unsigned int)v197;
            v110 = 48;
            if ( (_DWORD)v197 )
              v110 = v192;
            LODWORD(v192) = v110;
            v31 = v204[1];
            j = (unsigned __int64)++v204;
            v99 = v31 - 32;
            if ( v31 - 32 <= 0x5A )
              goto LABEL_203;
            goto LABEL_34;
          case '1':
          case '2':
          case '3':
          case '4':
          case '5':
          case '6':
          case '7':
          case '8':
          case '9':
LABEL_213:
            v25 = (unsigned __int64)&v204;
            v180 = v216;
            LODWORD(v181) = 0;
            LODWORD(v182) = -1;
            LODWORD(v186) = 0;
            LODWORD(v194) = 0;
            LODWORD(v195) = 0;
            v102 = read_int_0(&v204);
            v27 = (unsigned int)v195;
            v32 = v194;
            LODWORD(v198) = v102;
            v29 = (unsigned int)v186;
            v28 = (unsigned int)v182;
            v33 = (unsigned int)v181;
            v34 = v180;
            if ( v102 > 0x1FFFFFDE )
              goto LABEL_110;
            if ( (int)v198 <= 217 )
              goto LABEL_222;
            v103 = 4LL * (int)v198 + 128;
            v181 = v180;
            LODWORD(v182) = v33;
            LODWORD(v186) = v28;
            LODWORD(v194) = v29;
            LODWORD(v195) = v32;
            LODWORD(v196) = v27;
            v104 = _libc_alloca_cutoff(v103);
            v27 = (unsigned int)v196;
            v32 = v195;
            v29 = (unsigned int)v194;
            v28 = (unsigned int)v186;
            v33 = (unsigned int)v182;
            v34 = v181;
            if ( v103 <= 0x1000 || v104 )
            {
              v25 = (unsigned __int64)&v180 - ((v103 + 23) & 0xFFFFFFFFFFFFF000LL);
              if ( &v180 != (char **)v25 )
              {
                while ( &v178 != (__int64 *)v25 )
                  ;
              }
              j = ((_WORD)v103 + 23) & 0xFF0;
              if ( (((_WORD)v103 + 23) & 0xFF0) != 0 )
              {
                v105 = alloca(((_WORD)v103 + 23) & 0xFF0);
                *(_QWORD *)&v177[(((_WORD)v103 + 23) & 0xFF0) + 4088] = *(_QWORD *)&v177[(((_WORD)v103 + 23) & 0xFF0)
                                                                                       + 4088];
              }
              v196 = (__int64)&v179[v103];
            }
            else
            {
              v25 = v103;
              v174 = malloc(
                       v103,
                       j,
                       (_QWORD *)(unsigned int)v182,
                       (unsigned int)v196,
                       (u32 *)(unsigned int)v186,
                       (unsigned int)v194);
              v27 = (unsigned int)v196;
              v32 = v195;
              v199 = v174;
              v29 = (unsigned int)v194;
              v28 = (unsigned int)v186;
              v33 = (unsigned int)v182;
              v34 = v181;
              if ( !v174 )
                goto LABEL_38;
              v196 = (__int64)v199 + v103;
            }
LABEL_222:
            v31 = *v204;
            if ( *v204 != 36 )
            {
              switch ( v31 )
              {
                case '%':
                  goto LABEL_236;
                case '.':
                  goto LABEL_210;
                case 'A':
                case 'a':
                  goto LABEL_172;
                case 'C':
                  goto LABEL_54;
                case 'E':
                case 'F':
                case 'G':
                case 'e':
                case 'f':
                case 'g':
                  goto LABEL_178;
                case 'L':
                case 'q':
                  goto LABEL_241;
                case 'S':
                case 's':
                  goto LABEL_204;
                case 'X':
                case 'x':
                  goto LABEL_182;
                case 'Z':
                case 'j':
                case 't':
                case 'z':
                  goto LABEL_33;
                case 'c':
                  goto LABEL_73;
                case 'd':
                case 'i':
                  goto LABEL_224;
                case 'h':
                  goto LABEL_209;
                case 'l':
                  goto LABEL_249;
                case 'm':
                  goto LABEL_88;
                case 'n':
                  goto LABEL_111;
                case 'o':
                  goto LABEL_207;
                case 'p':
                  goto LABEL_117;
                case 'u':
                  goto LABEL_235;
                default:
                  goto LABEL_34;
              }
            }
            goto LABEL_52;
          case 'A':
          case 'a':
LABEL_172:
            v208 = (_DWORD *)__PAIR64__(v198, v28);
            v210 = 1024;
            v209 = v31;
            v84 = ((unsigned __int8)v187 << 7) | ((unsigned __int8)v193 << 6) | (32 * (unsigned __int8)v197) | (16 * (unsigned __int8)v190) | (8 * (unsigned __int8)v188) | (4 * v32) | (unsigned int)v27 | (2 * (_DWORD)v33);
            LOBYTE(v210) = ((_BYTE)v187 << 7) | ((_BYTE)v193 << 6) | (32 * v197) | (16 * v190) | (8 * v188) | (4 * v32) | v27 | (2 * v33);
            v211 = v192;
            if ( (_DWORD)v27 )
            {
              v85 = (LONG_DOUBLE_16 *)((a3->m128i_i64[1] + 15) & 0xFFFFFFFFFFFFFFF0LL);
              a3->m128i_i64[1] = (__int64)&v85[1];
              v207 = *v85;
            }
            else
            {
              v135 = a3->m128i_u32[1];
              if ( v135 > 0xAF )
              {
                v136 = (_QWORD *)a3->m128i_i64[1];
                a3->m128i_i64[1] = (__int64)(v136 + 1);
              }
              else
              {
                v136 = (_QWORD *)(a3[1].m128i_i64[0] + v135);
                a3->m128i_i32[1] = v135 + 16;
              }
              *(_QWORD *)&v207.value = *v136;
            }
            j = (unsigned __int64)&v208;
            v206 = &v207;
            v86 = _printf_fphex(a1, (__int64)&v208, (const __m128i **)&v206, v27, v84, v29);
            if ( v86 >= 0 )
              goto LABEL_175;
            goto LABEL_36;
          case 'C':
            goto LABEL_54;
          case 'E':
          case 'F':
          case 'G':
          case 'e':
          case 'f':
          case 'g':
LABEL_178:
            v208 = (_DWORD *)__PAIR64__(v198, v28);
            v209 = v31;
            v87 = (32 * (unsigned __int8)v197) | (16 * (unsigned __int8)v190) | (8 * (unsigned __int8)v188) | (4 * v32) | v27 | (2 * v33);
            v88 = (u32 *)(((unsigned __int8)v187 << 7) | ((unsigned __int8)v193 << 6) | v87);
            v210 = (unsigned __int8)(((_BYTE)v187 << 7) | ((_BYTE)v193 << 6) | v87);
            BYTE1(v210) = (8 * v185) | 4;
            v211 = v192;
            if ( (_DWORD)v27 )
            {
              v89 = (LONG_DOUBLE_16 *)((a3->m128i_i64[1] + 15) & 0xFFFFFFFFFFFFFFF0LL);
              a3->m128i_i64[1] = (__int64)&v89[1];
              v207 = *v89;
            }
            else
            {
              v138 = a3->m128i_u32[1];
              if ( v138 > 0xAF )
              {
                v139 = (_QWORD *)a3->m128i_i64[1];
                a3->m128i_i64[1] = (__int64)(v139 + 1);
              }
              else
              {
                v139 = (_QWORD *)(a3[1].m128i_i64[0] + v138);
                a3->m128i_i32[1] = v138 + 16;
              }
              *(_QWORD *)&v207.value = *v139;
            }
            j = (unsigned __int64)&v208;
            v205 = &v207;
            v86 = _printf_fp((char *)a1, (__int64)&v208, (long double **)&v205, v27, v88, v29);
            if ( v86 < 0 )
              goto LABEL_36;
LABEL_175:
            if ( (unsigned int)v26 > 0x7FFFFFFE )
              goto LABEL_511;
            v33 = (unsigned int)(0x7FFFFFFF - v26);
            if ( (unsigned int)v33 < v86 )
              goto LABEL_110;
            LODWORD(v26) = v86 + v26;
            goto LABEL_64;
          case 'I':
LABEL_202:
            while ( 2 )
            {
              LODWORD(v185) = 1;
              v31 = v204[1];
              j = (unsigned __int64)++v204;
              v99 = v31 - 32;
LABEL_203:
              switch ( v99 )
              {
                case 0u:
                  goto LABEL_234;
                case 3u:
                  goto LABEL_230;
                case 5u:
                  goto LABEL_236;
                case 7u:
                  goto LABEL_242;
                case 0xAu:
                  goto LABEL_187;
                case 0xBu:
                  goto LABEL_232;
                case 0xDu:
                  goto LABEL_250;
                case 0xEu:
                  goto LABEL_210;
                case 0x10u:
                  goto LABEL_245;
                case 0x11u:
                case 0x12u:
                case 0x13u:
                case 0x14u:
                case 0x15u:
                case 0x16u:
                case 0x17u:
                case 0x18u:
                case 0x19u:
                  goto LABEL_213;
                case 0x21u:
                case 0x41u:
                  goto LABEL_172;
                case 0x23u:
                  goto LABEL_54;
                case 0x25u:
                case 0x26u:
                case 0x27u:
                case 0x45u:
                case 0x46u:
                case 0x47u:
                  goto LABEL_178;
                case 0x29u:
                  continue;
                case 0x2Cu:
                case 0x51u:
                  goto LABEL_241;
                case 0x33u:
                case 0x53u:
                  goto LABEL_204;
                case 0x38u:
                case 0x58u:
                  goto LABEL_182;
                case 0x3Au:
                case 0x4Au:
                case 0x54u:
                case 0x5Au:
                  goto LABEL_33;
                case 0x43u:
                  goto LABEL_73;
                case 0x44u:
                case 0x49u:
                  goto LABEL_224;
                case 0x48u:
                  goto LABEL_209;
                case 0x4Cu:
                  goto LABEL_249;
                case 0x4Du:
                  goto LABEL_88;
                case 0x4Eu:
                  goto LABEL_111;
                case 0x4Fu:
                  goto LABEL_207;
                case 0x50u:
                  goto LABEL_117;
                case 0x55u:
                  goto LABEL_235;
                default:
                  goto LABEL_34;
              }
            }
          case 'L':
          case 'q':
LABEL_241:
            v31 = v204[1];
            ++v204;
            v32 = 1;
            v27 = 1LL;
            switch ( v31 )
            {
              case '%':
                goto LABEL_236;
              case 'A':
              case 'a':
                goto LABEL_172;
              case 'C':
                goto LABEL_54;
              case 'E':
              case 'F':
              case 'G':
              case 'e':
              case 'f':
              case 'g':
                goto LABEL_178;
              case 'S':
              case 's':
                goto LABEL_204;
              case 'X':
              case 'x':
                goto LABEL_182;
              case 'c':
                goto LABEL_73;
              case 'd':
              case 'i':
                goto LABEL_224;
              case 'm':
                goto LABEL_88;
              case 'n':
                goto LABEL_111;
              case 'o':
                goto LABEL_207;
              case 'p':
                goto LABEL_117;
              case 'u':
                goto LABEL_235;
              default:
                goto LABEL_34;
            }
          case 'S':
          case 's':
LABEL_204:
            v100 = a3->m128i_i32[0];
            if ( a3->m128i_i32[0] > 0x2Fu )
            {
              v33 = a3->m128i_i64[1];
              a3->m128i_i64[1] = v33 + 8;
            }
            else
            {
              v33 = a3[1].m128i_i64[0] + v100;
              a3->m128i_i32[0] = v100 + 8;
            }
            v55 = *(const char **)v33;
            goto LABEL_89;
          case 'X':
          case 'x':
LABEL_182:
            LODWORD(v194) = 16;
            goto LABEL_183;
          case 'Z':
          case 'j':
          case 't':
          case 'z':
LABEL_33:
            v31 = v204[1];
            ++v204;
            v32 = 1;
            v27 = 0LL;
            switch ( v31 )
            {
              case '%':
                goto LABEL_236;
              case 'A':
              case 'a':
                goto LABEL_172;
              case 'C':
                goto LABEL_54;
              case 'E':
              case 'F':
              case 'G':
              case 'e':
              case 'f':
              case 'g':
                goto LABEL_178;
              case 'S':
              case 's':
                goto LABEL_204;
              case 'X':
              case 'x':
                goto LABEL_182;
              case 'c':
                goto LABEL_73;
              case 'd':
              case 'i':
                goto LABEL_224;
              case 'm':
                goto LABEL_88;
              case 'n':
                goto LABEL_111;
              case 'o':
                goto LABEL_207;
              case 'p':
                goto LABEL_117;
              case 'u':
                goto LABEL_235;
              default:
                goto LABEL_34;
            }
          case 'c':
LABEL_73:
            if ( v32 )
            {
LABEL_54:
              v40 = v198 - 1;
              LOBYTE(v27) = (int)v198 - 1 > 0;
              if ( !(_DWORD)v197 && (int)v198 - 1 > 0 )
              {
                j = 32LL;
                LOBYTE(v196) = (int)v198 - 1 > 0;
                v198 = v40;
                v153 = IO_wpadn((char *)a1, 32LL, v40, v27, (u32 *)v40, v29);
                v28 = v198;
                if ( v198 != v153 )
                  goto LABEL_36;
                if ( (unsigned int)v26 > 0x7FFFFFFE )
                  goto LABEL_513;
                v27 = (unsigned __int8)v196;
                if ( 0x7FFFFFFF - (int)v26 < (unsigned int)v40 )
                  goto LABEL_110;
                LODWORD(v26) = v40 + v26;
              }
              v41 = a3->m128i_i32[0];
              if ( a3->m128i_i32[0] > 0x2Fu )
              {
                v33 = a3->m128i_i64[1];
                a3->m128i_i64[1] = v33 + 8;
              }
              else
              {
                v33 = a3[1].m128i_i64[0] + v41;
                a3->m128i_i32[0] = v41 + 8;
              }
              v42 = *(_QWORD *)(a1 + 160);
              j = *(unsigned int *)v33;
              if ( v42 && (v33 = *(_QWORD *)(v42 + 32), (unsigned __int64)v33 < *(_QWORD *)(v42 + 40)) )
              {
                *(_QWORD *)(v42 + 32) = v33 + 4;
                *(_DWORD *)v33 = j;
                if ( (_DWORD)j == -1 )
                  goto LABEL_36;
              }
              else
              {
                LOBYTE(v198) = v27;
                v156 = _woverflow(a1, j, v33, v27, (u32 *)v28, v29);
                v27 = (unsigned __int8)v198;
                if ( v156 == -1 )
                  goto LABEL_36;
              }
              if ( (_DWORD)v26 == 0x7FFFFFFF )
                goto LABEL_36;
              j = (unsigned int)v197;
              LODWORD(v26) = v26 + 1;
              if ( (_DWORD)v197 && (_BYTE)v27 )
                goto LABEL_84;
            }
            else
            {
              v29 = (unsigned int)v197;
              v40 = v198 - 1;
              LOBYTE(v198) = (int)v198 - 1 > 0;
              if ( !(_DWORD)v197 && (_BYTE)v198 )
              {
                j = 32LL;
                v196 = v40;
                v161 = (_QWORD *)IO_wpadn((char *)a1, 32LL, v40, v40, (u32 *)v28, (unsigned int)v197);
                v27 = v196;
                if ( (_QWORD *)v196 != v161 )
                  goto LABEL_36;
                if ( (unsigned int)v26 > 0x7FFFFFFE )
LABEL_513:
                  _assert_fail(
                    (__int64)"(unsigned int) done < (unsigned int) INT_MAX",
                    (__int64)"vfprintf.c",
                    0x666u,
                    "_IO_vfwprintf");
                if ( 0x7FFFFFFF - (int)v26 < (unsigned int)v40 )
                  goto LABEL_110;
                LODWORD(v26) = v40 + v26;
              }
              v50 = a3->m128i_i32[0];
              if ( a3->m128i_i32[0] > 0x2Fu )
              {
                v51 = (unsigned __int8 *)a3->m128i_i64[1];
                a3->m128i_i64[1] = (__int64)(v51 + 8);
              }
              else
              {
                v51 = (unsigned __int8 *)(a3[1].m128i_i64[0] + v50);
                a3->m128i_i32[0] = v50 + 8;
              }
              v52 = btowc(*v51, j, (__int64)v51, v27, (u32 *)v28, v29);
              v33 = *(_QWORD *)(a1 + 160);
              if ( v33 && (v27 = *(_QWORD *)(v33 + 32), v27 < *(_QWORD *)(v33 + 40)) )
              {
                j = v27 + 4;
                *(_QWORD *)(v33 + 32) = v27 + 4;
                *(_DWORD *)v27 = v52;
                if ( v52 == -1 )
                  goto LABEL_36;
              }
              else
              {
                j = v52;
                if ( (unsigned int)_woverflow(a1, v52, v33, v27, (u32 *)v28, v29) == -1 )
                  goto LABEL_36;
              }
              if ( (_DWORD)v26 == 0x7FFFFFFF )
                goto LABEL_36;
              v28 = (unsigned int)v197;
              LODWORD(v26) = v26 + 1;
              if ( (_DWORD)v197 && (_BYTE)v198 )
              {
LABEL_84:
                j = 32LL;
                v198 = v40;
                v53 = IO_wpadn((char *)a1, 32LL, v40, v40, (u32 *)v28, v29);
                v27 = v198;
                if ( v198 != v53 )
                  goto LABEL_36;
                if ( (unsigned int)v26 > 0x7FFFFFFE )
                  goto LABEL_513;
                if ( 0x7FFFFFFF - (int)v26 < (unsigned int)v40 )
                  goto LABEL_110;
                goto LABEL_87;
              }
            }
            goto LABEL_64;
          case 'd':
          case 'i':
LABEL_224:
            v106 = a3->m128i_i32[0];
            if ( v32 )
            {
              if ( v106 > 0x2F )
              {
                v107 = (__int64 *)a3->m128i_i64[1];
                a3->m128i_i64[1] = (__int64)(v107 + 1);
              }
              else
              {
                v107 = (__int64 *)(a3[1].m128i_i64[0] + v106);
                a3->m128i_i32[0] = v106 + 8;
              }
              v108 = *v107;
            }
            else if ( (_DWORD)v29 )
            {
              if ( v106 > 0x2F )
              {
                v137 = (char *)a3->m128i_i64[1];
                a3->m128i_i64[1] = (__int64)(v137 + 8);
              }
              else
              {
                v137 = (char *)(a3[1].m128i_i64[0] + v106);
                a3->m128i_i32[0] = v106 + 8;
              }
              v108 = *v137;
            }
            else if ( (_DWORD)v33 )
            {
              if ( v106 > 0x2F )
              {
                v167 = (__int16 *)a3->m128i_i64[1];
                a3->m128i_i64[1] = (__int64)(v167 + 4);
              }
              else
              {
                v167 = (__int16 *)(a3[1].m128i_i64[0] + v106);
                a3->m128i_i32[0] = v106 + 8;
              }
              v108 = *v167;
            }
            else
            {
              if ( v106 > 0x2F )
              {
                v155 = (int *)a3->m128i_i64[1];
                a3->m128i_i64[1] = (__int64)(v155 + 2);
              }
              else
              {
                v155 = (int *)(a3[1].m128i_i64[0] + v106);
                a3->m128i_i32[0] = v106 + 8;
              }
              v108 = *v155;
            }
            if ( v108 < 0 )
            {
              v32 = 1;
              LODWORD(v194) = 10;
              v195 = -v108;
            }
            else
            {
              v195 = v108;
              v32 = 0;
              LODWORD(v194) = 10;
            }
            goto LABEL_121;
          case 'h':
LABEL_209:
            v31 = v204[1];
            ++v204;
            v33 = 1LL;
            switch ( v31 )
            {
              case '%':
                goto LABEL_236;
              case 'X':
              case 'x':
                goto LABEL_182;
              case 'd':
              case 'i':
                goto LABEL_224;
              case 'h':
                v31 = v204[1];
                ++v204;
                v29 = 1LL;
                v33 = 0LL;
                switch ( v31 )
                {
                  case '%':
                    goto LABEL_236;
                  case 'A':
                  case 'a':
                    goto LABEL_172;
                  case 'C':
                    goto LABEL_54;
                  case 'E':
                  case 'F':
                  case 'G':
                  case 'e':
                  case 'f':
                  case 'g':
                    goto LABEL_178;
                  case 'S':
                  case 's':
                    goto LABEL_204;
                  case 'X':
                  case 'x':
                    goto LABEL_182;
                  case 'c':
                    goto LABEL_73;
                  case 'd':
                  case 'i':
                    goto LABEL_224;
                  case 'm':
                    goto LABEL_88;
                  case 'n':
                    goto LABEL_111;
                  case 'o':
                    goto LABEL_207;
                  case 'p':
                    goto LABEL_117;
                  case 'u':
                    goto LABEL_235;
                  default:
                    goto LABEL_34;
                }
              case 'n':
                goto LABEL_111;
              case 'o':
                goto LABEL_207;
              case 'u':
                goto LABEL_235;
              default:
                goto LABEL_34;
            }
          case 'l':
LABEL_249:
            v32 = 1;
            v31 = v204[1];
            j = (unsigned __int64)++v204;
            switch ( v31 )
            {
              case '%':
                goto LABEL_236;
              case 'A':
              case 'a':
                goto LABEL_172;
              case 'C':
                goto LABEL_54;
              case 'E':
              case 'F':
              case 'G':
              case 'e':
              case 'f':
              case 'g':
                goto LABEL_178;
              case 'S':
              case 's':
                goto LABEL_204;
              case 'X':
              case 'x':
                goto LABEL_182;
              case 'c':
                goto LABEL_73;
              case 'd':
              case 'i':
                goto LABEL_224;
              case 'l':
                goto LABEL_241;
              case 'm':
                goto LABEL_88;
              case 'n':
                goto LABEL_111;
              case 'o':
                goto LABEL_207;
              case 'p':
                goto LABEL_117;
              case 'u':
                goto LABEL_235;
              default:
                goto LABEL_34;
            }
          case 'm':
LABEL_88:
            v25 = v202;
            j = (unsigned __int64)v34;
            LODWORD(v196) = v28;
            v54 = strerror_r(v202, (__int64)v34, 0x3E8uLL);
            v28 = (unsigned int)v196;
            v32 = 0;
            v55 = (const char *)v54;
LABEL_89:
            if ( v55 )
            {
              if ( v32 || v31 == 83 )
              {
                if ( (_DWORD)v28 != -1 )
                  goto LABEL_367;
                v25 = (unsigned __int64)v55;
                v196 = (__int64)v55;
                v133 = j_wcslen(v55);
                v29 = v196;
                LODWORD(v195) = 0;
                v27 = v133;
                v40 = v133;
              }
              else
              {
                v208 = v55;
                if ( (_DWORD)v28 == -1 )
                {
                  v33 = j_strlen_ifunc(v55);
                }
                else
                {
                  j = (int)v28;
                  v33 = j_strnlen(v55, (int)v28);
                }
                if ( (unsigned __int64)v33 > 0x3FFFFFFFFFFFFFFFLL )
                  goto LABEL_110;
                v56 = 4 * v33;
                v196 = v33;
                v57 = _libc_alloca_cutoff(4 * v33);
                v61 = (_QWORD *)v196;
                if ( v57 || v56 <= 0x1000 )
                {
                  v62 = (char **)((char *)&v180 - ((v56 + 23) & 0xFFFFFFFFFFFFF000LL));
                  if ( &v180 != v62 )
                  {
                    while ( &v178 != (__int64 *)v62 )
                      ;
                  }
                  if ( (((_WORD)v56 + 23) & 0xFF0) != 0 )
                  {
                    v63 = alloca(((_WORD)v56 + 23) & 0xFF0);
                    *(_QWORD *)&v177[(((_WORD)v56 + 23) & 0xFF0) + 4088] = *(_QWORD *)&v177[(((_WORD)v56 + 23) & 0xFF0)
                                                                                          + 4088];
                  }
                  LODWORD(v195) = 0;
                  v28 = (__int64)v179;
                  v29 = (__int64)v179;
                }
                else
                {
                  v29 = (__int64)malloc(v56, j, (_QWORD *)v196, v58, v59, v60);
                  if ( !v29 )
                    goto LABEL_36;
                  LODWORD(v195) = 1;
                  v61 = (_QWORD *)v196;
                }
                v25 = v29;
                j = (unsigned __int64)&v208;
                v213 = 0LL;
                v196 = v29;
                v64 = mbsrtowcs(v29, (__int64 *)&v208, (__int64)v61, &v213, v28, v29);
                v27 = v64;
                if ( v64 == -1 )
                  goto LABEL_36;
                v29 = v196;
                v40 = v64;
              }
            }
            else
            {
              LODWORD(v195) = 0;
              if ( (_DWORD)v28 != -1 && (int)v28 <= 5 )
              {
                v40 = 0;
                v29 = (__int64)&unk_491654;
                v27 = 0LL;
                goto LABEL_312;
              }
              v40 = 6;
              v27 = 6LL;
              v29 = (__int64)&null_0;
            }
            goto LABEL_104;
          case 'n':
LABEL_111:
            if ( (*(_BYTE *)(a1 + 116) & 4) != 0 && !v183 )
            {
              LODWORD(v196) = v33;
              LODWORD(v197) = v29;
              LODWORD(v198) = v32;
              j = 4 * j_wcslen(a2) + 4;
              v166 = _readonly_area((unsigned __int64)a2, j, v162, v163, v164, v165);
              v32 = v198;
              v29 = (unsigned int)v197;
              v183 = v166;
              LODWORD(v33) = v196;
              if ( v166 < 0 )
                _libc_fatal(
                  (__int64)"*** %n in writable segment detected ***\n",
                  j,
                  (unsigned int)v196,
                  v27,
                  (u32 *)v28,
                  (unsigned int)v197);
            }
            v67 = a3->m128i_i32[0];
            if ( v32 )
            {
              if ( v67 > 0x2F )
              {
                v68 = (_QWORD **)a3->m128i_i64[1];
                a3->m128i_i64[1] = (__int64)(v68 + 1);
              }
              else
              {
                v68 = (_QWORD **)(a3[1].m128i_i64[0] + v67);
                a3->m128i_i32[0] = v67 + 8;
              }
              v69 = *v68;
              v33 = (int)v26;
              *v69 = (int)v26;
            }
            else if ( (_DWORD)v29 )
            {
              if ( v67 > 0x2F )
              {
                v33 = a3->m128i_i64[1];
                a3->m128i_i64[1] = v33 + 8;
              }
              else
              {
                v33 = a3[1].m128i_i64[0] + v67;
                a3->m128i_i32[0] = v67 + 8;
              }
              **(_BYTE **)v33 = v26;
            }
            else if ( (_DWORD)v33 )
            {
              if ( v67 > 0x2F )
              {
                v33 = a3->m128i_i64[1];
                a3->m128i_i64[1] = v33 + 8;
              }
              else
              {
                v33 = a3[1].m128i_i64[0] + v67;
                a3->m128i_i32[0] = v67 + 8;
              }
              **(_WORD **)v33 = v26;
            }
            else
            {
              if ( v67 > 0x2F )
              {
                v33 = a3->m128i_i64[1];
                a3->m128i_i64[1] = v33 + 8;
              }
              else
              {
                v33 = a3[1].m128i_i64[0] + v67;
                a3->m128i_i32[0] = v67 + 8;
              }
              **(_DWORD **)v33 = v26;
            }
            goto LABEL_64;
          case 'o':
LABEL_207:
            LODWORD(v194) = 8;
            goto LABEL_183;
          case 'p':
LABEL_117:
            v70 = a3->m128i_i32[0];
            if ( a3->m128i_i32[0] > 0x2Fu )
            {
              v71 = (__int64 *)a3->m128i_i64[1];
              a3->m128i_i64[1] = (__int64)(v71 + 1);
            }
            else
            {
              v71 = (__int64 *)(a3[1].m128i_i64[0] + v70);
              a3->m128i_i32[0] = v70 + 8;
            }
            if ( *v71 )
            {
              v195 = *v71;
              v32 = 0;
              v31 = 120;
              v187 = 0;
              v188 = 1;
              LODWORD(v194) = 16;
LABEL_121:
              if ( (int)v28 < 0 )
              {
                v186 = 1LL;
              }
              else
              {
                if ( (_DWORD)v28 )
                {
                  LODWORD(v192) = 32;
                  v186 = (int)v28;
                  goto LABEL_124;
                }
                if ( !v195 )
                {
                  if ( (_DWORD)v194 == 8 && (j = v188) != 0 )
                  {
                    v120 = v196;
                    v76 = 0LL;
                    v33 = 4LL;
                    LODWORD(v192) = 32;
                    *(_DWORD *)(v196 - 4) = 48;
                    v29 = v120 - 4;
                  }
                  else
                  {
                    v29 = v196;
                    v76 = 0LL;
                    v33 = 0LL;
                    LODWORD(v192) = 32;
                  }
LABEL_297:
                  v27 = (unsigned int)v197;
                  if ( !(_DWORD)v197 )
                  {
                    v27 = v33 >> 2;
                    LODWORD(v197) = v33 >> 2;
                    v77 = v198 - (_DWORD)v76 - v197;
                    goto LABEL_147;
                  }
                  goto LABEL_251;
                }
                v186 = 0LL;
                LODWORD(v192) = 32;
              }
LABEL_124:
              v72 = "0";
              if ( v31 != 88 )
                v72 = "0";
              if ( (_DWORD)v194 == 10 )
              {
                v29 = v196;
                j = v195;
                v25 = 0xCCCCCCCCCCCCCCCDLL;
                while ( 1 )
                {
                  v29 -= 4LL;
                  *(_DWORD *)v29 = *(_DWORD *)&v72[4 * (j % 0xA)];
                  if ( j <= 9 )
                    break;
                  j /= 0xAuLL;
                }
LABEL_132:
                if ( v189 && v187 )
                  goto LABEL_134;
LABEL_135:
                if ( (_DWORD)v194 == 10 && (_DWORD)v185 )
                {
                  j = v196;
                  v25 = v29;
                  v187 = v32;
                  v74 = i18n_number_rewrite_1((_DWORD *)v29, v196, (_DWORD *)v196);
                  v32 = v187;
                  v29 = (__int64)v74;
                }
              }
              else
              {
                if ( (_DWORD)v194 == 16 )
                {
                  v29 = v196;
                  for ( i = v195; ; i >>= 4 )
                  {
                    v29 -= 4LL;
                    *(_DWORD *)v29 = *(_DWORD *)&v72[4 * (i & 0xF)];
                    if ( i <= 0xF )
                      break;
                  }
                }
                else
                {
                  if ( (_DWORD)v194 != 8 )
                  {
                    v25 = (int)v194;
                    v29 = v196;
                    for ( j = v195; ; j /= v25 )
                    {
                      v29 -= 4LL;
                      *(_DWORD *)v29 = *(_DWORD *)&v72[4 * (j % v25)];
                      if ( j < v25 )
                        break;
                    }
                    goto LABEL_132;
                  }
                  v29 = v196;
                  for ( k = v195; ; k >>= 3 )
                  {
                    v29 -= 4LL;
                    *(_DWORD *)v29 = *(_DWORD *)&v72[4 * (k & 7)];
                    if ( k <= 7 )
                      break;
                  }
                }
                if ( v189 && v187 )
                {
LABEL_134:
                  j = v29;
                  v25 = (unsigned __int64)v34;
                  v187 = v32;
                  v73 = group_number_0((__int64)v34, (_DWORD *)v29, (_DWORD *)v196, (_BYTE *)v189, v184);
                  v32 = v187;
                  v29 = (__int64)v73;
                  goto LABEL_135;
                }
              }
              v33 = v196 - v29;
              v75 = (v196 - v29) >> 2;
              v27 = v75;
              if ( v75 >= v186 )
              {
                if ( !v195 )
                {
                  v76 = (_QWORD *)(v186 - v75);
                  if ( v186 - v75 < 0 )
                    v76 = (_QWORD *)v195;
                  v28 = (unsigned int)v76;
                  goto LABEL_297;
                }
                v78 = v188 & 1;
                if ( (_DWORD)v194 == 8 && v78 )
                {
                  v117 = v196;
                  *(_DWORD *)(v29 - 4) = 48;
                  v29 -= 4LL;
                  v33 = v117 - v29;
                }
                v27 = v33 >> 2;
                v76 = (_QWORD *)(v186 - (v33 >> 2));
                if ( (__int64)v76 < 0 )
                  v76 = 0LL;
                j = (unsigned int)v197;
                v28 = (unsigned int)v76;
                if ( !(_DWORD)v197 )
                {
                  LODWORD(v197) = v33 >> 2;
                  v33 = (unsigned int)(v198 - v27 - (_DWORD)v76);
                  v77 = v198 - v27 - (_DWORD)v76;
LABEL_144:
                  if ( (_DWORD)v194 == 16 )
                  {
                    v33 = (unsigned int)(v77 - 2);
                    if ( v78 )
                      v77 -= 2;
                  }
LABEL_147:
                  if ( v32 | (unsigned int)v193 | v190 )
                  {
                    --v77;
                    if ( (_DWORD)v192 != 32 )
                      goto LABEL_149;
                    if ( v77 <= 0 )
                    {
                      v77 = 0;
                      goto LABEL_149;
                    }
LABEL_329:
                    j = 32LL;
                    v25 = a1;
                    v185 = v27;
                    v186 = v29;
                    v187 = v28;
                    LODWORD(v192) = v32;
                    LODWORD(v196) = v77;
                    v198 = v77;
                    v126 = IO_wpadn((char *)a1, 32LL, v77, v27, (u32 *)v28, v29);
                    if ( v198 != v126 )
                      goto LABEL_36;
                    v32 = v192;
                    v28 = v187;
                    v29 = v186;
                    v27 = v185;
                    if ( (unsigned int)v26 > 0x7FFFFFFE )
                      goto LABEL_511;
                    if ( 0x7FFFFFFF - (int)v26 < (unsigned int)v196 )
                      goto LABEL_110;
                    LODWORD(v26) = v196 + v26;
                    v77 = 0;
LABEL_149:
                    if ( v32 )
                    {
                      v79 = *(_QWORD *)(a1 + 160);
                      if ( v79 )
                      {
                        v33 = *(_QWORD *)(v79 + 32);
                        if ( (unsigned __int64)v33 < *(_QWORD *)(v79 + 40) )
                        {
                          j = v33 + 4;
                          *(_QWORD *)(v79 + 32) = v33 + 4;
                          *(_DWORD *)v33 = 45;
                          goto LABEL_153;
                        }
                      }
                      v192 = v27;
                      j = 45LL;
                      LODWORD(v193) = v77;
                      v196 = v29;
                      LODWORD(v198) = v28;
LABEL_453:
                      v25 = a1;
                      v160 = _woverflow(a1, j, v33, v27, (u32 *)v28, v29);
                      v28 = (unsigned int)v198;
                      v29 = v196;
                      v77 = v193;
                      v27 = v192;
                      if ( v160 == -1 )
                        goto LABEL_36;
                      goto LABEL_153;
                    }
                    if ( (_DWORD)v193 )
                    {
                      v129 = *(_QWORD *)(a1 + 160);
                      if ( !v129 || (v33 = *(_QWORD *)(v129 + 32), (unsigned __int64)v33 >= *(_QWORD *)(v129 + 40)) )
                      {
                        v192 = v27;
                        j = 43LL;
                        LODWORD(v193) = v77;
                        v196 = v29;
                        LODWORD(v198) = v28;
                        goto LABEL_453;
                      }
                      j = v33 + 4;
                      *(_QWORD *)(v129 + 32) = v33 + 4;
                      *(_DWORD *)v33 = 43;
LABEL_153:
                      if ( (_DWORD)v26 == 0x7FFFFFFF )
                        goto LABEL_36;
                      LODWORD(v26) = v26 + 1;
                    }
                    else if ( v190 )
                    {
                      v152 = *(_QWORD *)(a1 + 160);
                      if ( !v152 || (v33 = *(_QWORD *)(v152 + 32), (unsigned __int64)v33 >= *(_QWORD *)(v152 + 40)) )
                      {
                        v192 = v27;
                        j = 32LL;
                        LODWORD(v193) = v77;
                        v196 = v29;
                        LODWORD(v198) = v28;
                        goto LABEL_453;
                      }
                      j = v33 + 4;
                      *(_QWORD *)(v152 + 32) = v33 + 4;
                      *(_DWORD *)v33 = 32;
                      goto LABEL_153;
                    }
                  }
                  else if ( (_DWORD)v192 == 32 )
                  {
                    if ( v77 > 0 )
                      goto LABEL_329;
                    v77 = 0;
                  }
                  if ( v195 && (_DWORD)v194 == 16 && v188 )
                  {
                    v80 = *(_QWORD *)(a1 + 160);
                    if ( v80 && (j = *(_QWORD *)(v80 + 32), v25 = *(_QWORD *)(v80 + 40), j < v25) )
                    {
                      v33 = j + 4;
                      *(_QWORD *)(v80 + 32) = j + 4;
                      *(_DWORD *)j = 48;
                      if ( (_DWORD)v26 == 0x7FFFFFFF )
                        goto LABEL_36;
LABEL_161:
                      if ( v33 < v25 )
                      {
                        j = v33 + 4;
                        *(_QWORD *)(v80 + 32) = v33 + 4;
                        *(_DWORD *)v33 = v31;
                        if ( v31 == -1 )
                          goto LABEL_36;
                        goto LABEL_163;
                      }
                    }
                    else
                    {
                      j = 48LL;
                      v194 = v27;
                      LODWORD(v195) = v77;
                      v196 = v29;
                      LODWORD(v198) = v28;
                      v172 = _woverflow(a1, 48LL, v33, v27, (u32 *)v28, v29);
                      v28 = (unsigned int)v198;
                      v29 = v196;
                      v77 = v195;
                      v27 = v194;
                      if ( v172 == -1 || (_DWORD)v26 == 0x7FFFFFFF )
                        goto LABEL_36;
                      v80 = *(_QWORD *)(a1 + 160);
                      if ( v80 )
                      {
                        v33 = *(_QWORD *)(v80 + 32);
                        v25 = *(_QWORD *)(v80 + 40);
                        goto LABEL_161;
                      }
                    }
                    j = v31;
                    v25 = a1;
                    v194 = v27;
                    LODWORD(v195) = v77;
                    v196 = v29;
                    LODWORD(v198) = v28;
                    v171 = _woverflow(a1, v31, v33, v27, (u32 *)v28, v29);
                    v28 = (unsigned int)v198;
                    v29 = v196;
                    v77 = v195;
                    v27 = v194;
                    if ( v171 == -1 )
                      goto LABEL_36;
LABEL_163:
                    if ( (_DWORD)v26 == 2147483646 )
                      goto LABEL_36;
                    LODWORD(v26) = v26 + 2;
                  }
                  v81 = v77 + v28;
                  if ( v77 + (int)v28 > 0 )
                  {
                    j = 48LL;
                    v25 = a1;
                    v195 = v27;
                    v198 = v81;
                    v196 = v29;
                    v128 = IO_wpadn((char *)a1, 48LL, v81, v27, (u32 *)v81, v29);
                    v28 = v198;
                    if ( v198 != v128 )
                      goto LABEL_36;
                    if ( (unsigned int)v26 > 0x7FFFFFFE )
LABEL_511:
                      _assert_fail(
                        (__int64)"(unsigned int) done < (unsigned int) INT_MAX",
                        (__int64)"vfprintf.c",
                        0x665u,
                        "_IO_vfwprintf");
                    v29 = v196;
                    v27 = v195;
                    if ( 0x7FFFFFFF - (int)v26 < (unsigned int)v81 )
                      goto LABEL_110;
                    LODWORD(v26) = v81 + v26;
                  }
                  if ( (int)v26 < 0 )
                    goto LABEL_510;
                  v82 = *(_QWORD *)(a1 + 216);
                  if ( v200 <= v82 - (__int64)_start___libc_IO_vtables )
                  {
                    v196 = v27;
                    v198 = v29;
                    IO_vtable_check(v25, j, v33, v27, (u32 *)v28, v29);
                    v27 = v196;
                    v29 = v198;
                  }
                  v198 = v27;
                  j = v29;
                  v83 = (*(__int64 (__fastcall **)(__int64, __int64, unsigned __int64))(v82 + 56))(a1, v29, v27);
                  v27 = v198;
                  if ( v198 != v83 )
                    goto LABEL_36;
                  if ( 0x7FFFFFFF - (int)v26 < (__int64)v198 )
                    goto LABEL_110;
                  LODWORD(v26) = v197 + v26;
                  goto LABEL_64;
                }
              }
              else
              {
                v76 = (_QWORD *)(v186 - v75);
                if ( v186 - v75 < 0 )
                  v76 = 0LL;
                v28 = (unsigned int)v76;
                if ( !(_DWORD)v197 )
                {
                  LODWORD(v197) = (v196 - v29) >> 2;
                  v77 = v198 - v75 - (_DWORD)v76;
                  if ( v195 )
                  {
                    v78 = v188 & 1;
                    goto LABEL_144;
                  }
                  goto LABEL_147;
                }
              }
LABEL_251:
              if ( v32 )
              {
                v111 = *(_QWORD *)(a1 + 160);
                if ( v111 )
                {
                  v27 = *(_QWORD *)(v111 + 32);
                  if ( v27 < *(_QWORD *)(v111 + 40) )
                  {
                    j = v27 + 4;
                    *(_QWORD *)(v111 + 32) = v27 + 4;
                    *(_DWORD *)v27 = 45;
                    goto LABEL_255;
                  }
                }
                v192 = v29;
                j = 45LL;
                LODWORD(v193) = v28;
                v196 = (__int64)v76;
                v197 = v33;
LABEL_448:
                v25 = a1;
                v158 = _woverflow(a1, j, v33, v27, (u32 *)v28, v29);
                v33 = v197;
                v76 = (_QWORD *)v196;
                v28 = (unsigned int)v193;
                v29 = v192;
                if ( v158 == -1 )
                  goto LABEL_36;
                goto LABEL_255;
              }
              if ( (_DWORD)v193 )
              {
                v125 = *(_QWORD *)(a1 + 160);
                if ( !v125 || (v27 = *(_QWORD *)(v125 + 32), v27 >= *(_QWORD *)(v125 + 40)) )
                {
                  v192 = v29;
                  j = 43LL;
                  LODWORD(v193) = v28;
                  v196 = (__int64)v76;
                  v197 = v33;
                  goto LABEL_448;
                }
                j = v27 + 4;
                *(_QWORD *)(v125 + 32) = v27 + 4;
                *(_DWORD *)v27 = 43;
LABEL_255:
                if ( (_DWORD)v26 == 0x7FFFFFFF )
                  goto LABEL_36;
                LODWORD(v198) = v198 - 1;
                LODWORD(v26) = v26 + 1;
              }
              else if ( v190 )
              {
                v132 = *(_QWORD *)(a1 + 160);
                if ( !v132 || (v27 = *(_QWORD *)(v132 + 32), v27 >= *(_QWORD *)(v132 + 40)) )
                {
                  v192 = v29;
                  j = 32LL;
                  LODWORD(v193) = v28;
                  v196 = (__int64)v76;
                  v197 = v33;
                  goto LABEL_448;
                }
                j = v27 + 4;
                *(_QWORD *)(v132 + 32) = v27 + 4;
                *(_DWORD *)v27 = 32;
                goto LABEL_255;
              }
              if ( v195 && (_DWORD)v194 == 16 && v188 )
              {
                v112 = *(_QWORD *)(a1 + 160);
                if ( v112 && (j = *(_QWORD *)(v112 + 32), v25 = *(_QWORD *)(v112 + 40), j < v25) )
                {
                  v27 = j + 4;
                  *(_QWORD *)(v112 + 32) = j + 4;
                  *(_DWORD *)j = 48;
                  if ( (_DWORD)v26 == 0x7FFFFFFF )
                    goto LABEL_36;
LABEL_263:
                  if ( v25 > v27 )
                  {
                    j = v27 + 4;
                    *(_QWORD *)(v112 + 32) = v27 + 4;
                    *(_DWORD *)v27 = v31;
                    if ( v31 == -1 )
                      goto LABEL_36;
                    goto LABEL_265;
                  }
                }
                else
                {
                  j = 48LL;
                  v194 = v29;
                  LODWORD(v195) = v28;
                  v196 = (__int64)v76;
                  v197 = v33;
                  v169 = _woverflow(a1, 48LL, v33, v27, (u32 *)v28, v29);
                  v33 = v197;
                  v76 = (_QWORD *)v196;
                  v28 = (unsigned int)v195;
                  v29 = v194;
                  if ( v169 == -1 || (_DWORD)v26 == 0x7FFFFFFF )
                    goto LABEL_36;
                  v112 = *(_QWORD *)(a1 + 160);
                  if ( v112 )
                  {
                    v27 = *(_QWORD *)(v112 + 32);
                    v25 = *(_QWORD *)(v112 + 40);
                    goto LABEL_263;
                  }
                }
                j = v31;
                v25 = a1;
                v194 = v29;
                LODWORD(v195) = v28;
                v196 = (__int64)v76;
                v197 = v33;
                v170 = _woverflow(a1, v31, v33, v27, (u32 *)v28, v29);
                v33 = v197;
                LODWORD(v76) = v196;
                v28 = (unsigned int)v195;
                v29 = v194;
                if ( v170 == -1 )
                  goto LABEL_36;
LABEL_265:
                if ( (_DWORD)v26 == 2147483646 )
                  goto LABEL_36;
                LODWORD(v198) = v198 - 2;
                LODWORD(v26) = v26 + 2;
              }
              v113 = v33 >> 2;
              LODWORD(v198) = v198 - ((v33 >> 2) + (_DWORD)v76);
              if ( (int)v28 > 0 )
              {
                j = 48LL;
                v25 = a1;
                v195 = v29;
                v197 = (int)v28;
                LODWORD(v196) = v28;
                v127 = IO_wpadn((char *)a1, 48LL, v28, (int)v28, (u32 *)v28, v29);
                v27 = v197;
                if ( v197 != v127 )
                  goto LABEL_36;
                if ( (unsigned int)v26 > 0x7FFFFFFE )
                  goto LABEL_511;
                v28 = (unsigned int)v196;
                v29 = v195;
                if ( 0x7FFFFFFF - (int)v26 < (unsigned int)v196 )
                  goto LABEL_110;
                LODWORD(v26) = v196 + v26;
              }
              if ( (int)v26 < 0 )
LABEL_510:
                _assert_fail(
                  (__int64)"(size_t) done <= (size_t) INT_MAX",
                  (__int64)"vfprintf.c",
                  0x665u,
                  "_IO_vfwprintf");
              v114 = *(_QWORD *)(a1 + 216);
              if ( v200 <= v114 - (__int64)_start___libc_IO_vtables )
              {
                v196 = v29;
                v197 = v114;
                IO_vtable_check(v25, j, v114 - (_QWORD)_start___libc_IO_vtables, v27, (u32 *)v28, v29);
                v29 = v196;
                v114 = v197;
              }
              j = v29;
              if ( v113 != (*(__int64 (__fastcall **)(__int64, __int64, __int64))(v114 + 56))(a1, v29, v113) )
                goto LABEL_36;
              v28 = 0x7FFFFFFFLL;
              if ( v113 > 0x7FFFFFFF - (int)v26 )
                goto LABEL_110;
              LODWORD(v26) = v113 + v26;
              v115 = v198;
              if ( (int)v198 > 0 )
              {
                j = 32LL;
                v197 = (int)v198;
                v116 = IO_wpadn((char *)a1, 32LL, v198, (int)v198, (u32 *)0x7FFFFFFF, v29);
                v27 = v197;
                if ( v197 != v116 )
                  goto LABEL_36;
                if ( (unsigned int)v26 > 0x7FFFFFFE )
                  goto LABEL_511;
                v28 = (unsigned int)(0x7FFFFFFF - v26);
                if ( (unsigned int)v28 < v115 )
                  goto LABEL_110;
                LODWORD(v26) = v198 + v26;
              }
              goto LABEL_64;
            }
            v55 = "(";
            if ( (int)v28 < 5 )
              LODWORD(v28) = 5;
LABEL_367:
            v25 = (unsigned __int64)v55;
            j = (int)v28;
            v196 = (__int64)v55;
            v134 = j_wcsnlen(v55, (int)v28);
            v29 = v196;
            LODWORD(v195) = 0;
            v27 = v134;
            v40 = v134;
LABEL_104:
            LODWORD(v198) = v198 - v40;
            if ( (v198 & 0x80000000) == 0LL )
            {
LABEL_312:
              LOBYTE(v196) = (_DWORD)v198 != 0;
              if ( !(_DWORD)v197 && (_DWORD)v198 )
              {
                j = 32LL;
                v25 = a1;
                v192 = v29;
                v193 = v27;
                v194 = (int)v198;
                v154 = IO_wpadn((char *)a1, 32LL, v198, v27, (u32 *)v28, v29);
                if ( v194 != v154 )
                  goto LABEL_36;
                if ( (unsigned int)v26 > 0x7FFFFFFE )
                  goto LABEL_513;
                v27 = v193;
                v29 = v192;
                if ( 0x7FFFFFFF - (int)v26 < (unsigned int)v198 )
                  goto LABEL_110;
                LODWORD(v26) = v198 + v26;
              }
              if ( (int)v26 < 0 )
LABEL_514:
                _assert_fail(
                  (__int64)"(size_t) done <= (size_t) INT_MAX",
                  (__int64)"vfprintf.c",
                  0x666u,
                  "_IO_vfwprintf");
              v123 = *(_QWORD *)(a1 + 216);
              if ( v200 <= v123 - (__int64)_start___libc_IO_vtables )
              {
                v192 = *(_QWORD *)(a1 + 216);
                v193 = v29;
                v194 = v27;
                IO_vtable_check(v25, j, v123 - (_QWORD)_start___libc_IO_vtables, v27, (u32 *)v28, v29);
                v123 = v192;
                v29 = v193;
                v27 = v194;
              }
              v194 = v27;
              j = v29;
              v193 = v29;
              v124 = (*(__int64 (__fastcall **)(__int64, __int64, unsigned __int64))(v123 + 56))(a1, v29, v27);
              v27 = v194;
              if ( v124 != v194 )
                goto LABEL_36;
              v29 = v193;
              if ( 0x7FFFFFFF - (int)v26 < v194 )
                goto LABEL_110;
              LODWORD(v26) = v40 + v26;
              if ( (_DWORD)v197 && (_BYTE)v196 )
              {
                v157 = (int)v198;
                j = 32LL;
                v197 = v193;
                if ( v157 != IO_wpadn((char *)a1, 32LL, v198, v194, (u32 *)v28, v193) )
                  goto LABEL_36;
                if ( (unsigned int)v26 > 0x7FFFFFFE )
                  goto LABEL_513;
                v29 = v197;
                if ( 0x7FFFFFFF - (int)v26 < (unsigned int)v198 )
                  goto LABEL_110;
                LODWORD(v26) = v198 + v26;
              }
              if ( (_DWORD)v195 )
                free(v29, j, v33, v27, (u32 *)v28, v29);
            }
            else
            {
              if ( (int)v26 < 0 )
                goto LABEL_514;
              v65 = *(_QWORD *)(a1 + 216);
              if ( v200 <= v65 - (__int64)_start___libc_IO_vtables )
              {
                v196 = *(_QWORD *)(a1 + 216);
                v197 = v29;
                v198 = v27;
                IO_vtable_check(v25, j, v33, v27, (u32 *)v65, v29);
                v65 = v196;
                v29 = v197;
                v27 = v198;
              }
              v198 = v27;
              j = v29;
              v66 = (*(__int64 (__fastcall **)(__int64, __int64, unsigned __int64))(v65 + 56))(a1, v29, v27);
              v27 = v198;
              if ( v198 != v66 )
                goto LABEL_36;
              if ( v198 > 0x7FFFFFFF - (int)v26 )
                goto LABEL_110;
LABEL_87:
              LODWORD(v26) = v40 + v26;
            }
LABEL_64:
            ++v191;
            if ( v199 )
              free((__int64)v199, j, v33, v27, (u32 *)v28, v29);
            v43 = ++v204;
            v44 = v204;
            v45 = wcschrnul(v204, 37);
            v204 = v45;
            if ( (int)v26 < 0 )
              _assert_fail((__int64)"(size_t) done <= (size_t) INT_MAX", (__int64)"vfprintf.c", 0x685u, "_IO_vfwprintf");
            v48 = *(_QWORD *)(a1 + 216);
            if ( v200 <= v48 - (__int64)_start___libc_IO_vtables )
            {
              v199 = *(_QWORD **)(a1 + 216);
              IO_vtable_check((__int64)v44, 37LL, v48 - (_QWORD)_start___libc_IO_vtables, v48, v46, v47);
              v45 = v204;
              v48 = (__int64)v199;
            }
            j = (unsigned __int64)v43;
            v25 = a1;
            v49 = (*(__int64 (__fastcall **)(__int64, int *, signed __int64))(v48 + 56))(a1, v43, v45 - v43);
            v30 = v204;
            v27 = v204 - v43;
            if ( v27 != v49 )
              goto LABEL_38;
            if ( (__int64)v27 > 0x7FFFFFFF - (int)v26 )
              goto LABEL_47;
            v28 = (unsigned int)*v204;
            LODWORD(v26) = v27 + v26;
            if ( !(_DWORD)v28 )
              goto LABEL_28;
            continue;
          case 'u':
LABEL_235:
            LODWORD(v194) = 10;
LABEL_183:
            v90 = a3->m128i_i32[0];
            if ( v32 )
            {
              if ( v90 > 0x2F )
              {
                v91 = (__int64 *)a3->m128i_i64[1];
                a3->m128i_i64[1] = (__int64)(v91 + 1);
              }
              else
              {
                v91 = (__int64 *)(a3[1].m128i_i64[0] + v90);
                a3->m128i_i32[0] = v90 + 8;
              }
              LODWORD(v193) = 0;
              v92 = *v91;
              v32 = 0;
              v190 = 0;
              v195 = v92;
            }
            else if ( (_DWORD)v29 )
            {
              if ( v90 > 0x2F )
              {
                v118 = (unsigned __int8 *)a3->m128i_i64[1];
                a3->m128i_i64[1] = (__int64)(v118 + 8);
              }
              else
              {
                v118 = (unsigned __int8 *)(a3[1].m128i_i64[0] + v90);
                a3->m128i_i32[0] = v90 + 8;
              }
              LODWORD(v193) = 0;
              v119 = *v118;
              v190 = 0;
              v195 = v119;
            }
            else if ( (_DWORD)v33 )
            {
              if ( v90 > 0x2F )
              {
                v140 = (unsigned __int16 *)a3->m128i_i64[1];
                a3->m128i_i64[1] = (__int64)(v140 + 4);
              }
              else
              {
                v140 = (unsigned __int16 *)(a3[1].m128i_i64[0] + v90);
                a3->m128i_i32[0] = v90 + 8;
              }
              LODWORD(v193) = 0;
              v141 = *v140;
              v32 = 0;
              v190 = 0;
              v195 = v141;
            }
            else
            {
              if ( v90 > 0x2F )
              {
                v130 = (unsigned int *)a3->m128i_i64[1];
                a3->m128i_i64[1] = (__int64)(v130 + 2);
              }
              else
              {
                v130 = (unsigned int *)(a3[1].m128i_i64[0] + v90);
                a3->m128i_i32[0] = v90 + 8;
              }
              LODWORD(v193) = 0;
              v131 = *v130;
              v32 = 0;
              v190 = 0;
              v195 = v131;
            }
            goto LABEL_121;
          default:
            v199 = 0LL;
LABEL_34:
            v34 = v216;
            if ( v31 )
              goto LABEL_52;
            __writefsdword(0xFFFFFFC0, 0x16u);
            goto LABEL_36;
        }
        break;
      }
    }
    j = (unsigned __int64)a2;
    LODWORD(v26) = printf_positional_0(
                     (u32 *)a1,
                     (unsigned __int64)a2,
                     v183,
                     (__int64)a3,
                     (u32 *)&v214,
                     (unsigned int)v26,
                     v198,
                     v201,
                     (__int64)v34,
                     v202,
                     (_BYTE *)v189,
                     v184);
  }
LABEL_28:
  if ( (*(_DWORD *)a1 & 0x8000) == 0 )
  {
    v37 = *(_QWORD *)(a1 + 136);
    v36 = (*(_DWORD *)(v37 + 4))-- == 1;
    if ( v36 )
    {
      *(_QWORD *)(v37 + 8) = 0LL;
      if ( _libc_multiple_threads )
      {
        if ( !_InterlockedDecrement((volatile signed __int32 *)v37) )
          goto LABEL_30;
      }
      else
      {
        v36 = (*(_DWORD *)v37)-- == 1;
        if ( v36 )
          goto LABEL_30;
      }
      _lll_unlock_wake_private((u32 *)v37, j, v37, v27, (u32 *)v28, v29);
    }
  }
LABEL_30:
  if ( v203 )
    MEMORY[0](v212, 0LL);
  return (unsigned int)v26;
}
// 45BB1E: variable 'v9' is possibly undefined
// 45BB1E: variable 'v10' is possibly undefined
// 45BB1E: variable 'v11' is possibly undefined
// 45BB1E: variable 'v12' is possibly undefined
// 45BF97: variable 'v21' is possibly undefined
// 45BF97: variable 'v22' is possibly undefined
// 45BD8F: variable 'v20' is possibly undefined
// 45BED9: variable 'v33' is possibly undefined
// 45BED9: variable 'v27' is possibly undefined
// 45BED9: variable 'v28' is possibly undefined
// 45BED9: variable 'v29' is possibly undefined
// 45BF59: variable 'v13' is possibly undefined
// 45BF59: variable 'v14' is possibly undefined
// 45BF59: variable 'v15' is possibly undefined
// 45D847: variable 'v46' is possibly undefined
// 45D847: variable 'v47' is possibly undefined
// 45E359: variable 'v162' is possibly undefined
// 45E359: variable 'v163' is possibly undefined
// 45E359: variable 'v164' is possibly undefined
// 45E359: variable 'v165' is possibly undefined
// 45E843: variable 'v58' is possibly undefined
// 45E843: variable 'v59' is possibly undefined
// 45E843: variable 'v60' is possibly undefined
// 401028: using guessed type __int64 __fastcall j_strnlen(_QWORD, _QWORD);
// 401048: using guessed type __int64 __fastcall j_wcslen(_QWORD);
// 401098: using guessed type __int64 __fastcall j_wcsnlen(_QWORD, _QWORD);
// 4010C8: using guessed type __int64 __fastcall j_strlen_ifunc(_QWORD);
// 4A9C40: using guessed type u32 _start___libc_IO_vtables[48];
// 4AA2E8: using guessed type __int64 (__fastcall *_start___libc_atexit)();
// 4AB820: using guessed type int _libc_multiple_threads;
// 4ABA08: using guessed type __int64 _printf_function_table;
// 4ABA10: using guessed type __int64 _printf_modifier_table;
// 4ABA30: using guessed type __int64 _printf_va_arg_table;
// 45BAB0: using guessed type long double var_490;

//----- (000000000045E9D0) ----------------------------------------------------
// positive sp value has been detected, the output may be wrong!
__int64 __fastcall buffered_vfprintf_0(__int64 a1, __int64 _RSI, __m128i *a3, __int64 a4, u32 *a5, __int64 a6)
{
  __int64 v8; // rcx
  u32 *v9; // r8
  __int64 v10; // r9
  _DWORD *v11; // rdi
  int v12; // eax
  __int64 v13; // rcx
  unsigned int v14; // ebp
  u32 *v15; // r8
  __int64 v16; // r9
  _QWORD *v17; // rax
  int v18; // er13
  __int64 v19; // r14
  __int64 v20; // rdx
  bool v23; // zf
  _DWORD v24[34]; // [rsp-240h] [rbp-8268h] BYREF
  __int64 v25; // [rsp-1B8h] [rbp-81E0h]
  _QWORD *v26; // [rsp-1A0h] [rbp-81C8h]
  int v27; // [rsp-180h] [rbp-81A8h]
  void *v28; // [rsp-168h] [rbp-8190h]
  _QWORD v29[42]; // [rsp-160h] [rbp-8188h] BYREF
  _BYTE v30[16]; // [rsp-10h] [rbp-8038h] BYREF
  char v31; // [rsp+0h] [rbp-8028h] BYREF
  __int64 v32; // [rsp+1000h] [rbp-7028h] BYREF
  _QWORD v33[7]; // [rsp+7FF0h] [rbp-38h] BYREF

  while ( &v31 != (char *)(&v32 - 4096) )
    ;
  v33[1] = __readfsqword(0x28u);
  if ( (unsigned int)IO_fwide(a1, 1LL, (__int64)a3, a4, a5, a6) != 1 )
    return (unsigned int)-1;
  v11 = v24;
  v29[39] = a1;
  v27 = 1;
  v26 = v29;
  v29[4] = v30;
  v29[3] = v30;
  v29[5] = v33;
  v12 = *(_DWORD *)(a1 + 116);
  v24[0] = -72515580;
  v24[29] = v12;
  v25 = 0LL;
  v28 = &IO_helper_jumps_0;
  v14 = vfwprintf((__int64)v24, (int *)_RSI, a3, v8, v9, v10);
  if ( (*(_DWORD *)a1 & 0x8000) == 0 )
  {
    _RDX = *(_QWORD *)(a1 + 136);
    v15 = (u32 *)__readfsqword(0x10u);
    if ( *(u32 **)(_RDX + 8) == v15 )
      goto LABEL_24;
    _RSI = 1LL;
    v23 = _libc_multiple_threads == 0;
    if ( _libc_multiple_threads )
    {
      if ( !_InterlockedCompareExchange((volatile signed __int32 *)_RDX, 1, 0) )
        goto LABEL_23;
    }
    else
    {
      __asm { cmpxchg [rdx], esi }
      if ( v23 )
      {
LABEL_23:
        _RDX = *(_QWORD *)(a1 + 136);
        *(_QWORD *)(_RDX + 8) = v15;
LABEL_24:
        v17 = v26;
        ++*(_DWORD *)(_RDX + 4);
        v18 = (__int64)(v17[4] - v17[3]) >> 2;
        if ( v18 <= 0 )
          goto LABEL_9;
        goto LABEL_5;
      }
    }
    v11 = (_DWORD *)_RDX;
    _lll_lock_wait_private((u32 *)_RDX, 1LL, _RDX, v13, v15, v16);
    goto LABEL_23;
  }
  v17 = v26;
  v18 = (__int64)(v26[4] - v26[3]) >> 2;
  if ( v18 <= 0 )
    return v14;
LABEL_5:
  v19 = *(_QWORD *)(a1 + 216);
  if ( (char *)&_start___libc_atexit - (char *)_start___libc_IO_vtables <= (unsigned __int64)(v19
                                                                                            - (_QWORD)_start___libc_IO_vtables) )
  {
    IO_vtable_check(
      (__int64)v11,
      v19 - (_QWORD)_start___libc_IO_vtables,
      (char *)&_start___libc_atexit - (char *)_start___libc_IO_vtables,
      (__int64)_start___libc_IO_vtables,
      v15,
      v16);
    v17 = v26;
  }
  _RSI = v17[3];
  if ( v18 != (*(unsigned int (__fastcall **)(__int64, __int64, _QWORD))(v19 + 56))(a1, _RSI, v18) )
    v14 = -1;
LABEL_9:
  if ( (*(_DWORD *)a1 & 0x8000) == 0 )
  {
    v20 = *(_QWORD *)(a1 + 136);
    v23 = (*(_DWORD *)(v20 + 4))-- == 1;
    if ( v23 )
    {
      *(_QWORD *)(v20 + 8) = 0LL;
      if ( _libc_multiple_threads )
      {
        if ( !_InterlockedDecrement((volatile signed __int32 *)v20) )
          return v14;
        goto LABEL_15;
      }
      v23 = (*(_DWORD *)v20)-- == 1;
      if ( !v23 )
LABEL_15:
        _lll_unlock_wake_private((u32 *)v20, _RSI, v20, v13, v15, v16);
    }
  }
  return v14;
}
// 45EBBC: positive sp value 7000 has been found
// 45EAA9: variable 'v8' is possibly undefined
// 45EAA9: variable 'v9' is possibly undefined
// 45EAA9: variable 'v10' is possibly undefined
// 45EC58: variable 'v15' is possibly undefined
// 45EC58: variable 'v16' is possibly undefined
// 45EB79: variable 'v13' is possibly undefined
// 4A9C40: using guessed type u32 _start___libc_IO_vtables[48];
// 4AA2E8: using guessed type __int64 (__fastcall *_start___libc_atexit)();
// 4AB820: using guessed type int _libc_multiple_threads;

//----- (000000000045EC80) ----------------------------------------------------
signed __int64 __fastcall funlockfile(__int64 a1, __int64 a2, __int64 a3, __int64 a4, u32 *a5, u32 a6)
{
  __int64 v6; // rdx
  bool v7; // zf
  signed __int64 result; // rax

  v6 = *(_QWORD *)(a1 + 136);
  v7 = (*(_DWORD *)(v6 + 4))-- == 1;
  if ( v7 )
  {
    *(_QWORD *)(v6 + 8) = 0LL;
    if ( _libc_multiple_threads )
    {
      if ( !_InterlockedDecrement((volatile signed __int32 *)v6) )
        return result;
    }
    else
    {
      v7 = (*(_DWORD *)v6)-- == 1;
      if ( v7 )
        return result;
    }
    return _lll_unlock_wake_private((u32 *)v6, a2, v6, a4, a5, a6);
  }
  return result;
}
// 4AB820: using guessed type int _libc_multiple_threads;

//----- (000000000045ECD0) ----------------------------------------------------
__int64 __fastcall read_int_1(_QWORD *a1)
{
  unsigned __int8 *v1; // rcx
  __int64 result; // rax
  int v3; // eax
  bool v4; // cc
  unsigned int v5; // edx

  v1 = (unsigned __int8 *)(*a1 + 1LL);
  result = (unsigned int)*(unsigned __int8 *)*a1 - 48;
  while ( 1 )
  {
    *a1 = v1;
    v5 = *v1 - 48;
    if ( v5 > 9 )
      break;
    if ( (int)result >= 0 )
    {
      if ( (int)result <= 214748364 )
      {
        v3 = 10 * result;
        v4 = (int)(0x7FFFFFFF - v5) < v3;
        result = v3 + v5;
        if ( v4 )
          result = 0xFFFFFFFFLL;
      }
      else
      {
        result = 0xFFFFFFFFLL;
      }
    }
    ++v1;
  }
  return result;
}

//----- (000000000045ED40) ----------------------------------------------------
__int64 __fastcall _parse_one_specmb(__int64 a1, int a2, __int64 a3)
{
  unsigned __int8 *v3; // r10
  int v4; // ebp
  int v6; // eax
  unsigned __int8 v7; // al
  int v8; // eax
  __int64 v9; // r12
  __int64 v10; // rax
  __int64 v11; // rdx
  bool v12; // zf
  __int64 v13; // rax
  int int_1; // eax
  int v15; // eax
  unsigned __int8 *v16; // r12
  __int64 v17; // rax
  __int64 *v18; // r11
  unsigned __int8 *v19; // rdx
  int v20; // ecx
  __int64 result; // rax
  unsigned __int8 *v22; // rdi
  unsigned __int8 *v23; // rdi
  int v24; // eax
  unsigned __int8 *v25; // rax
  unsigned __int8 *v26; // rdx
  unsigned __int8 *v27; // r13
  __int64 v28; // rax
  __int64 *v29; // r11
  unsigned __int8 *v30; // rcx
  int v31; // edx
  __int64 (__fastcall *v32)(__int64, __int64, __int64, __int64); // rax
  int v33; // eax
  __int64 v34; // rax
  __int64 *v35; // r11
  unsigned __int8 *v36; // rcx
  int v37; // edx
  unsigned __int8 *v38[6]; // [rsp+8h] [rbp-30h] BYREF

  v3 = (unsigned __int8 *)(a1 + 1);
  v4 = a2;
  *(_DWORD *)(a3 + 48) = -1;
  v38[0] = (unsigned __int8 *)(a1 + 1);
  *(_DWORD *)(a3 + 16) = 32;
  *(_WORD *)(a3 + 12) &= 0xE207u;
  v6 = *(unsigned __int8 *)(a1 + 1);
  if ( (unsigned int)(v6 - 48) <= 9 )
  {
    LODWORD(v17) = read_int_1(v38);
    if ( (_DWORD)v17 && (v19 = v38[0], *v38[0] == 36) )
    {
      v3 = ++v38[0];
      if ( (_DWORD)v17 != -1 )
      {
        v20 = v17 - 1;
        v17 = (unsigned int)v17;
        if ( *v18 >= (unsigned __int64)(unsigned int)v17 )
          v17 = *v18;
        *(_DWORD *)(a3 + 48) = v20;
        *v18 = v17;
      }
      LOBYTE(v6) = v19[1];
    }
    else
    {
      v38[0] = v3;
      LOBYTE(v6) = *(_BYTE *)(a1 + 1);
    }
  }
  v7 = v6 - 32;
  if ( v7 <= 0x29u )
    __asm { jmp     rax }
  if ( (*(_BYTE *)(a3 + 12) & 0x20) != 0 )
    *(_DWORD *)(a3 + 16) = 32;
  *(_DWORD *)(a3 + 44) = -1;
  *(_DWORD *)(a3 + 4) = 0;
  v8 = *v3;
  if ( (_BYTE)v8 == 42 )
  {
    v16 = v3 + 1;
    v38[0] = v3 + 1;
    if ( (unsigned int)v3[1] - 48 > 9 )
      goto LABEL_22;
    LODWORD(v28) = read_int_1(v38);
    if ( (_DWORD)v28 && (v30 = v38[0], *v38[0] == 36) )
    {
      if ( (_DWORD)v28 == -1 )
      {
        v31 = *(_DWORD *)(a3 + 44);
      }
      else
      {
        v31 = v28 - 1;
        v28 = (unsigned int)v28;
        if ( *v29 >= (unsigned __int64)(unsigned int)v28 )
          v28 = *v29;
        *(_DWORD *)(a3 + 44) = v31;
        *v29 = v28;
      }
      v38[0] = v30 + 1;
    }
    else
    {
      v31 = *(_DWORD *)(a3 + 44);
    }
    if ( v31 < 0 )
    {
LABEL_22:
      *(_DWORD *)(a3 + 44) = a2;
      v3 = v16;
      v4 = a2 + 1;
      v38[0] = v16;
      v9 = 1LL;
    }
    else
    {
      v3 = v38[0];
      v9 = 0LL;
    }
  }
  else
  {
    v9 = 0LL;
    if ( (unsigned int)(v8 - 48) <= 9 )
    {
      int_1 = read_int_1(v38);
      if ( int_1 != -1 )
        *(_DWORD *)(a3 + 4) = int_1;
      v3 = v38[0];
    }
  }
  *(_DWORD *)(a3 + 40) = -1;
  *(_DWORD *)a3 = -1;
  if ( *v3 == 46 )
  {
    v38[0] = v3 + 1;
    v15 = v3[1];
    if ( (_BYTE)v15 == 42 )
    {
      v27 = v3 + 2;
      v38[0] = v3 + 2;
      if ( (unsigned int)v3[2] - 48 > 9 )
        goto LABEL_40;
      LODWORD(v34) = read_int_1(v38);
      if ( (_DWORD)v34 && (v36 = v38[0], *v38[0] == 36) )
      {
        if ( (_DWORD)v34 == -1 )
        {
          v37 = *(_DWORD *)(a3 + 40);
        }
        else
        {
          v37 = v34 - 1;
          v34 = (unsigned int)v34;
          if ( *v35 >= (unsigned __int64)(unsigned int)v34 )
            v34 = *v35;
          *(_DWORD *)(a3 + 40) = v37;
          *v35 = v34;
        }
        v38[0] = v36 + 1;
      }
      else
      {
        v37 = *(_DWORD *)(a3 + 40);
      }
      if ( v37 < 0 )
      {
LABEL_40:
        *(_DWORD *)(a3 + 40) = v4;
        ++v9;
        v3 = v27;
        ++v4;
        v38[0] = v27;
        goto LABEL_9;
      }
    }
    else
    {
      if ( (unsigned int)(v15 - 48) > 9 )
      {
        *(_DWORD *)a3 = 0;
        ++v3;
        goto LABEL_9;
      }
      v24 = read_int_1(v38);
      if ( v24 != -1 )
        *(_DWORD *)a3 = v24;
    }
    v3 = v38[0];
  }
LABEL_9:
  v10 = _printf_modifier_table;
  *(_DWORD *)(a3 + 12) &= 0xFDF8u;
  if ( v10 && *(_QWORD *)(v10 + 8LL * *v3) )
  {
    if ( !(unsigned int)_handle_registered_modifier_mb(v38, a3) )
    {
      v26 = v38[0];
      v25 = v38[0] + 1;
      goto LABEL_12;
    }
    v3 = v38[0];
  }
  v38[0] = v3 + 1;
  if ( (unsigned __int8)(*v3 - 76) <= 0x2Eu )
    __asm { jmp     rax }
  v25 = v3 + 1;
  v26 = v3;
LABEL_12:
  v38[0] = v25;
  v11 = *v26;
  v12 = _printf_function_table == 0;
  *(_DWORD *)(a3 + 64) = -1;
  *(_DWORD *)(a3 + 8) = v11;
  if ( v12
    || (v32 = *(__int64 (__fastcall **)(__int64, __int64, __int64, __int64))(_printf_arginfo_table + 8 * v11)) == 0LL
    || (v33 = v32(a3, 1LL, a3 + 52, a3 + 64), LODWORD(v11) = *(_DWORD *)(a3 + 8), *(_QWORD *)(a3 + 56) = v33, v33 < 0) )
  {
    v13 = (unsigned int)(v11 - 65);
    *(_QWORD *)(a3 + 56) = 1LL;
    if ( (unsigned int)v13 <= 0x37 )
      __asm { jmp     rax }
    *(_QWORD *)(a3 + 56) = 0LL;
  }
  else if ( *(_DWORD *)(a3 + 48) == -1 && v33 )
  {
    *(_DWORD *)(a3 + 48) = v4;
    v9 += v33;
  }
  v22 = v38[0];
  if ( (_DWORD)v11 )
  {
    *(unsigned __int8 **)(a3 + 24) = v38[0];
    *(_QWORD *)(a3 + 32) = j_strchrnul(v22, 37LL);
    return v9;
  }
  else
  {
    v23 = v38[0] - 1;
    result = v9;
    *(_QWORD *)(a3 + 32) = v38[0] - 1;
    *(_QWORD *)(a3 + 24) = v23;
  }
  return result;
}
// 45EDDC: variable 'v3' is possibly undefined
// 45EFC6: variable 'v18' is possibly undefined
// 45F2B7: variable 'v29' is possibly undefined
// 45F31A: variable 'v35' is possibly undefined
// 401060: using guessed type __int64 __fastcall j_strchrnul(_QWORD, _QWORD);
// 4ABA08: using guessed type __int64 _printf_function_table;
// 4ABA10: using guessed type __int64 _printf_modifier_table;
// 4ABA28: using guessed type __int64 _printf_arginfo_table;

//----- (000000000045F340) ----------------------------------------------------
__int64 __fastcall read_int_2(_QWORD *a1)
{
  _DWORD *v1; // rdx
  _DWORD *v2; // rcx
  unsigned int v3; // esi
  __int64 result; // rax
  signed int v5; // eax
  _DWORD *v6; // rcx

  v1 = (_DWORD *)(*a1 + 4LL);
  v2 = v1;
  v3 = *v1 - 48;
  result = (unsigned int)(*(_DWORD *)*a1 - 48);
  if ( v3 > 9 )
  {
LABEL_7:
    *a1 = v2;
    return result;
  }
  while ( (int)result < 0 )
  {
LABEL_6:
    v2 = ++v1;
    v3 = *v1 - 48;
    if ( v3 > 9 )
      goto LABEL_7;
  }
  if ( (int)result <= 214748364 )
  {
    v5 = 10 * result;
    if ( (int)(0x7FFFFFFF - v3) >= v5 )
    {
      result = v3 + v5;
      goto LABEL_6;
    }
  }
  v6 = v2 + 1;
  if ( (unsigned int)(*v6 - 48) <= 9 )
  {
    v1 += 2;
    v6 = v1;
    if ( (unsigned int)(*v1 - 48) <= 9 )
    {
      result = 0xFFFFFFFFLL;
      goto LABEL_6;
    }
  }
  result = 0xFFFFFFFFLL;
  *a1 = v6;
  return result;
}

//----- (000000000045F3E0) ----------------------------------------------------
__int64 __fastcall _parse_one_specwc(__int64 a1, int a2, __int64 a3, __int64 *a4)
{
  int v4; // er12
  __int16 v7; // ax
  unsigned int v8; // eax
  __int64 v9; // rax
  __int64 v10; // r13
  __int64 v11; // rax
  int v12; // ecx
  unsigned int *v13; // rdx
  __int64 v14; // rax
  unsigned int *v15; // r11
  bool v16; // zf
  __int64 v17; // rax
  int int_2; // eax
  unsigned int v19; // eax
  unsigned int v20; // eax
  unsigned int *v21; // r13
  __int64 v22; // rax
  unsigned int *v23; // r11
  unsigned int *v24; // rdx
  int v25; // ecx
  __int64 result; // rax
  int *v27; // rdi
  unsigned int *v28; // rdi
  int v29; // eax
  __int64 (__fastcall *v30)(__int64, __int64, __int64, __int64); // rax
  int v31; // eax
  unsigned int v32; // eax
  unsigned int *v33; // r14
  __int64 v34; // rax
  unsigned int *v35; // rcx
  int v36; // edx
  __int64 v37; // rax
  unsigned int *v38; // rcx
  int v39; // edx
  unsigned int *v40[6]; // [rsp+8h] [rbp-30h] BYREF

  v4 = a2;
  v7 = *(_WORD *)(a3 + 12);
  *(_DWORD *)(a3 + 48) = -1;
  *(_DWORD *)(a3 + 16) = 32;
  v7 &= 0xE207u;
  v40[0] = (unsigned int *)(a1 + 4);
  HIBYTE(v7) |= 4u;
  *(_WORD *)(a3 + 12) = v7;
  v8 = *(_DWORD *)(a1 + 4);
  if ( v8 - 48 <= 9 )
  {
    LODWORD(v22) = read_int_2(v40);
    if ( (_DWORD)v22 && (v24 = v40[0], *v40[0] == 36) )
    {
      ++v40[0];
      if ( (_DWORD)v22 != -1 )
      {
        v25 = v22 - 1;
        v22 = (unsigned int)v22;
        if ( *a4 >= (unsigned __int64)(unsigned int)v22 )
          v22 = *a4;
        *(_DWORD *)(a3 + 48) = v25;
        *a4 = v22;
      }
      v8 = v24[1];
    }
    else
    {
      v40[0] = v23;
      v8 = *(_DWORD *)(a1 + 4);
    }
  }
  v9 = v8 - 32;
  if ( (unsigned int)v9 <= 0x29 )
    __asm { jmp     rax }
  v15 = v40[0];
  if ( (*(_BYTE *)(a3 + 12) & 0x20) != 0 )
    *(_DWORD *)(a3 + 16) = 32;
  *(_DWORD *)(a3 + 44) = -1;
  *(_DWORD *)(a3 + 4) = 0;
  if ( *v15 == 42 )
  {
    v20 = v15[1];
    v21 = v15 + 1;
    v40[0] = v15 + 1;
    if ( v20 - 48 > 9 )
      goto LABEL_25;
    LODWORD(v34) = read_int_2(v40);
    if ( (_DWORD)v34 && (v35 = v40[0], *v40[0] == 36) )
    {
      if ( (_DWORD)v34 == -1 )
      {
        v36 = *(_DWORD *)(a3 + 44);
      }
      else
      {
        v36 = v34 - 1;
        v34 = (unsigned int)v34;
        if ( *a4 >= (unsigned __int64)(unsigned int)v34 )
          v34 = *a4;
        *(_DWORD *)(a3 + 44) = v36;
        *a4 = v34;
      }
      v40[0] = v35 + 1;
    }
    else
    {
      v36 = *(_DWORD *)(a3 + 44);
    }
    if ( v36 < 0 )
    {
LABEL_25:
      *(_DWORD *)(a3 + 44) = a2;
      v15 = v21;
      v4 = a2 + 1;
      v40[0] = v21;
      v10 = 1LL;
    }
    else
    {
      v15 = v40[0];
      v10 = 0LL;
    }
  }
  else
  {
    v10 = 0LL;
    if ( *v15 - 48 <= 9 )
    {
      int_2 = read_int_2(v40);
      if ( int_2 != -1 )
        *(_DWORD *)(a3 + 4) = int_2;
      v15 = v40[0];
    }
  }
  *(_DWORD *)(a3 + 40) = -1;
  *(_DWORD *)a3 = -1;
  if ( *v15 == 46 )
  {
    v19 = v15[1];
    v40[0] = v15 + 1;
    if ( v19 == 42 )
    {
      v32 = v15[2];
      v33 = v15 + 2;
      v40[0] = v15 + 2;
      if ( v32 - 48 > 9 )
        goto LABEL_47;
      LODWORD(v37) = read_int_2(v40);
      if ( (_DWORD)v37 && (v38 = v40[0], *v40[0] == 36) )
      {
        if ( (_DWORD)v37 == -1 )
        {
          v39 = *(_DWORD *)(a3 + 40);
        }
        else
        {
          v39 = v37 - 1;
          v37 = (unsigned int)v37;
          if ( *a4 >= (unsigned __int64)(unsigned int)v37 )
            v37 = *a4;
          *(_DWORD *)(a3 + 40) = v39;
          *a4 = v37;
        }
        v40[0] = v38 + 1;
      }
      else
      {
        v39 = *(_DWORD *)(a3 + 40);
      }
      if ( v39 < 0 )
      {
LABEL_47:
        *(_DWORD *)(a3 + 40) = v4;
        ++v10;
        v15 = v33;
        ++v4;
        v40[0] = v33;
        goto LABEL_9;
      }
    }
    else
    {
      if ( v19 - 48 > 9 )
      {
        *(_DWORD *)a3 = 0;
        ++v15;
        goto LABEL_9;
      }
      v29 = read_int_2(v40);
      if ( v29 != -1 )
        *(_DWORD *)a3 = v29;
    }
    v15 = v40[0];
  }
LABEL_9:
  v11 = _printf_modifier_table;
  *(_DWORD *)(a3 + 12) &= 0xFDF8u;
  if ( !v11 )
  {
LABEL_10:
    v12 = *v15;
    goto LABEL_11;
  }
  v12 = *v15;
  if ( *(_QWORD *)(v11 + 8LL * *v15) )
  {
    if ( !(unsigned int)_handle_registered_modifier_wc(v40, a3) )
    {
      v13 = v40[0] + 1;
      v12 = *v40[0];
      goto LABEL_14;
    }
    v15 = v40[0];
    goto LABEL_10;
  }
LABEL_11:
  v13 = v15 + 1;
  v14 = (unsigned int)(v12 - 76);
  v40[0] = v15 + 1;
  if ( (unsigned int)v14 <= 0x2E )
    __asm { jmp     rax }
LABEL_14:
  v16 = _printf_function_table == 0;
  v40[0] = v13;
  *(_DWORD *)(a3 + 8) = v12;
  *(_DWORD *)(a3 + 64) = -1;
  if ( v16
    || v12 > 255
    || (v30 = *(__int64 (__fastcall **)(__int64, __int64, __int64, __int64))(_printf_arginfo_table + 8LL * v12)) == 0LL
    || (v31 = v30(a3, 1LL, a3 + 52, a3 + 64), v12 = *(_DWORD *)(a3 + 8), *(_QWORD *)(a3 + 56) = v31, v31 < 0) )
  {
    v17 = (unsigned int)(v12 - 65);
    *(_QWORD *)(a3 + 56) = 1LL;
    if ( (unsigned int)v17 <= 0x37 )
      __asm { jmp     rax }
    *(_QWORD *)(a3 + 56) = 0LL;
  }
  else if ( *(_DWORD *)(a3 + 48) == -1 && v31 )
  {
    *(_DWORD *)(a3 + 48) = v4;
    v10 += v31;
  }
  v27 = (int *)v40[0];
  if ( v12 )
  {
    *(unsigned int **)(a3 + 24) = v40[0];
    *(_QWORD *)(a3 + 32) = wcschrnul(v27, 37);
    return v10;
  }
  else
  {
    v28 = v40[0] - 1;
    result = v10;
    *(_QWORD *)(a3 + 32) = v40[0] - 1;
    *(_QWORD *)(a3 + 24) = v28;
  }
  return result;
}
// 45F6D0: variable 'v23' is possibly undefined
// 4ABA08: using guessed type __int64 _printf_function_table;
// 4ABA10: using guessed type __int64 _printf_modifier_table;
// 4ABA28: using guessed type __int64 _printf_arginfo_table;

//----- (000000000045FA20) ----------------------------------------------------
__int64 __fastcall IO_file_doallocate(__int64 a1, _WORD *a2, _QWORD *a3, __int64 a4, u32 *a5, __int64 a6)
{
  __int64 v6; // rbx
  u32 *v7; // rdx
  __int64 v8; // rcx
  unsigned __int64 v9; // rbx
  _QWORD *v10; // rsi
  u32 *v11; // r8
  unsigned __int64 v12; // r9
  __int64 result; // rax
  unsigned int v14; // er12
  _BOOL4 v15; // eax
  _WORD v16[20]; // [rsp+0h] [rbp-B8h] BYREF
  unsigned __int64 v17; // [rsp+28h] [rbp-90h]
  unsigned __int64 v18; // [rsp+38h] [rbp-80h]
  unsigned __int64 v19; // [rsp+98h] [rbp-20h]

  v19 = __readfsqword(0x28u);
  if ( *(int *)(a1 + 112) < 0 )
    goto LABEL_10;
  v6 = *(_QWORD *)(a1 + 216);
  v7 = _start___libc_IO_vtables;
  v8 = v6 - (_QWORD)_start___libc_IO_vtables;
  if ( (char *)&_start___libc_atexit - (char *)_start___libc_IO_vtables <= (unsigned __int64)(v6
                                                                                            - (_QWORD)_start___libc_IO_vtables) )
    IO_vtable_check(a1, (__int64)a2, (__int64)_start___libc_IO_vtables, v8, a5, a6);
  a2 = v16;
  if ( (*(int (__fastcall **)(__int64, _WORD *, u32 *, __int64, u32 *))(v6 + 144))(a1, v16, v7, v8, a5) < 0 )
    goto LABEL_10;
  if ( (v16[12] & 0xF000) == 0x2000 )
  {
    a3 = (_QWORD *)((v17 >> 8) & 0xFFF);
    if ( ((unsigned int)a3 | HIDWORD(v17) & 0xFFFFF000) - 136 <= 7
      || (v14 = __readfsdword(0xFFFFFFC0), v15 = isatty(*(_DWORD *)(a1 + 112)), __writefsdword(0xFFFFFFC0, v14), v15) )
    {
      *(_DWORD *)a1 |= 0x200u;
    }
  }
  v9 = v18;
  if ( v18 - 1 > 0x1FFE )
LABEL_10:
    v9 = 0x2000LL;
  v10 = malloc(v9, (__int64)a2, a3, a4, a5, a6);
  result = 0xFFFFFFFFLL;
  if ( v10 )
  {
    IO_setb((int *)a1, (__int64)v10, (__int64)v10 + v9, 1LL, v11, v12);
    return 1LL;
  }
  return result;
}
// 45FA7D: variable 'v7' is possibly undefined
// 45FA7D: variable 'v8' is possibly undefined
// 45FA7D: variable 'a5' is possibly undefined
// 45FAAB: variable 'a3' is possibly undefined
// 45FAAB: variable 'a4' is possibly undefined
// 45FAAB: variable 'a6' is possibly undefined
// 45FAC9: variable 'v11' is possibly undefined
// 45FAC9: variable 'v12' is possibly undefined
// 4A9C40: using guessed type u32 _start___libc_IO_vtables[48];
// 4AA2E8: using guessed type __int64 (__fastcall *_start___libc_atexit)();

//----- (000000000045FB80) ----------------------------------------------------
__int64 __fastcall fputs(__int64 a1, __int64 _RSI)
{
  __int64 v2; // rbp
  __int64 v3; // rbx
  __int64 v4; // rcx
  u32 *v5; // r8
  __int64 v6; // r9
  __int64 v7; // r12
  bool v9; // zf
  int v10; // eax
  __int64 v11; // r13
  __int64 v12; // rsi
  __int64 v14; // rdx

  v2 = a1;
  v3 = _RSI;
  v7 = j_strlen_ifunc(a1);
  if ( (*(_DWORD *)_RSI & 0x8000) == 0 )
  {
    _RDX = *(_QWORD *)(_RSI + 136);
    v5 = (u32 *)__readfsqword(0x10u);
    if ( *(u32 **)(_RDX + 8) == v5 )
    {
LABEL_9:
      ++*(_DWORD *)(_RDX + 4);
      goto LABEL_10;
    }
    _RSI = 1LL;
    v9 = _libc_multiple_threads == 0;
    if ( _libc_multiple_threads )
    {
      if ( !_InterlockedCompareExchange((volatile signed __int32 *)_RDX, 1, 0) )
        goto LABEL_8;
    }
    else
    {
      __asm { cmpxchg [rdx], esi }
      if ( v9 )
      {
LABEL_8:
        _RDX = *(_QWORD *)(v3 + 136);
        *(_QWORD *)(_RDX + 8) = v5;
        goto LABEL_9;
      }
    }
    a1 = _RDX;
    _lll_lock_wait_private((u32 *)_RDX, 1LL, _RDX, v4, v5, v6);
    goto LABEL_8;
  }
LABEL_10:
  v10 = *(_DWORD *)(v3 + 192);
  if ( v10 )
  {
    if ( v10 != -1 )
      goto LABEL_18;
  }
  else
  {
    *(_DWORD *)(v3 + 192) = -1;
  }
  v11 = *(_QWORD *)(v3 + 216);
  if ( (char *)&_start___libc_atexit - (char *)_start___libc_IO_vtables <= (unsigned __int64)(v11
                                                                                            - (_QWORD)_start___libc_IO_vtables) )
    IO_vtable_check(a1, _RSI, (__int64)_start___libc_IO_vtables, v11 - (_QWORD)_start___libc_IO_vtables, v5, v6);
  v12 = 1LL;
  if ( v7 != (*(__int64 (__fastcall **)(__int64, __int64, __int64))(v11 + 56))(v3, v2, v7) )
  {
LABEL_18:
    v12 = 0xFFFFFFFFLL;
    if ( (*(_DWORD *)v3 & 0x8000) != 0 )
      return (unsigned int)v12;
    goto LABEL_19;
  }
  if ( (*(_DWORD *)v3 & 0x8000) != 0 )
    return (unsigned int)v12;
LABEL_19:
  v14 = *(_QWORD *)(v3 + 136);
  v9 = (*(_DWORD *)(v14 + 4))-- == 1;
  if ( !v9 )
    return (unsigned int)v12;
  *(_QWORD *)(v14 + 8) = 0LL;
  if ( _libc_multiple_threads )
  {
    if ( !_InterlockedDecrement((volatile signed __int32 *)v14) )
      return (unsigned int)v12;
    goto LABEL_24;
  }
  v9 = (*(_DWORD *)v14)-- == 1;
  if ( !v9 )
LABEL_24:
    _lll_unlock_wake_private((u32 *)v14, v12, v14, v4, v5, v6);
  return (unsigned int)v12;
}
// 45FBE0: variable 'v4' is possibly undefined
// 45FBE0: variable 'v6' is possibly undefined
// 45FBF3: variable 'v5' is possibly undefined
// 4010C8: using guessed type __int64 __fastcall j_strlen_ifunc(_QWORD);
// 4A9C40: using guessed type u32 _start___libc_IO_vtables[48];
// 4AA2E8: using guessed type __int64 (__fastcall *_start___libc_atexit)();
// 4AB820: using guessed type int _libc_multiple_threads;

//----- (000000000045FCF0) ----------------------------------------------------
__int64 __fastcall IO_wfile_doallocate(__int64 a1, _WORD *a2, _QWORD *a3, __int64 a4, u32 *a5, __int64 a6)
{
  __int64 v6; // rax
  unsigned __int64 v7; // rdx
  __int64 v8; // rbx
  _QWORD *v9; // rsi
  __int64 v10; // r8
  unsigned __int64 v11; // r9
  __int64 result; // rax

  v6 = *(_QWORD *)(a1 + 56);
  if ( !v6 )
  {
    IO_file_doallocate(a1, a2, a3, a4, a5, a6);
    v6 = *(_QWORD *)(a1 + 56);
  }
  v7 = *(_QWORD *)(a1 + 64) - v6;
  if ( (*(_BYTE *)a1 & 1) != 0 )
    v7 = (v7 + 3) >> 2;
  v8 = 4 * v7;
  v9 = malloc(4 * v7, (__int64)a2, (_QWORD *)v7, a4, a5, a6);
  result = 0xFFFFFFFFLL;
  if ( v9 )
  {
    IO_wsetb(a1, (__int64)v9, (__int64)v9 + v8, 1LL, v10, v11);
    return 1LL;
  }
  return result;
}
// 45FD28: variable 'a4' is possibly undefined
// 45FD28: variable 'a5' is possibly undefined
// 45FD28: variable 'a6' is possibly undefined
// 45FD46: variable 'v10' is possibly undefined
// 45FD46: variable 'v11' is possibly undefined

//----- (000000000045FD70) ----------------------------------------------------
__int64 __fastcall fwrite(__int64 a1, __int64 _RSI, __int64 a3, __int64 a4, __int64 _R8, __int64 a6)
{
  __int64 v6; // rbp
  __int64 v7; // r14
  unsigned __int64 v8; // r13
  unsigned __int64 v10; // r12
  bool v11; // zf
  int v12; // eax
  __int64 v13; // r12
  __int64 v14; // r15
  __int64 v15; // rcx
  unsigned __int64 v16; // rdx
  u32 *v17; // r8
  __int64 v18; // rsi

  v6 = a3 * _RSI;
  if ( !(a3 * _RSI) )
    return v6;
  v7 = a1;
  v8 = _RSI;
  if ( (*(_DWORD *)a4 & 0x8000) == 0 )
  {
    _R8 = *(_QWORD *)(a4 + 136);
    v10 = __readfsqword(0x10u);
    if ( *(_QWORD *)(_R8 + 8) == v10 )
    {
LABEL_10:
      ++*(_DWORD *)(_R8 + 4);
      goto LABEL_11;
    }
    _RSI = 1LL;
    v11 = _libc_multiple_threads == 0;
    if ( _libc_multiple_threads )
    {
      if ( !_InterlockedCompareExchange((volatile signed __int32 *)_R8, 1, 0) )
        goto LABEL_9;
    }
    else
    {
      __asm { cmpxchg [r8], esi }
      if ( v11 )
      {
LABEL_9:
        _R8 = *(_QWORD *)(a4 + 136);
        *(_QWORD *)(_R8 + 8) = v10;
        goto LABEL_10;
      }
    }
    a1 = _R8;
    _lll_lock_wait_private((u32 *)_R8, 1LL, a3, a4, (u32 *)_R8, a6);
    goto LABEL_9;
  }
LABEL_11:
  v12 = *(_DWORD *)(a4 + 192);
  v13 = a3;
  if ( v12 )
  {
    if ( v12 != -1 )
    {
      if ( (*(_DWORD *)a4 & 0x8000) != 0 )
        return 0LL;
      v18 = *(_QWORD *)(a4 + 136);
      v11 = (*(_DWORD *)(v18 + 4))-- == 1;
      if ( !v11 )
        return 0LL;
      v17 = 0LL;
      v16 = 0LL;
      goto LABEL_17;
    }
  }
  else
  {
    *(_DWORD *)(a4 + 192) = -1;
  }
  v14 = *(_QWORD *)(a4 + 216);
  v15 = v14 - (_QWORD)_start___libc_IO_vtables;
  if ( (char *)&_start___libc_atexit - (char *)_start___libc_IO_vtables <= (unsigned __int64)(v14
                                                                                            - (_QWORD)_start___libc_IO_vtables) )
    IO_vtable_check(a1, _RSI, (__int64)_start___libc_IO_vtables, v15, (u32 *)_R8, a6);
  v16 = (*(__int64 (__fastcall **)(__int64, __int64, __int64, __int64, __int64))(v14 + 56))(a4, v7, v6, v15, _R8);
  LOBYTE(v17) = v16 == -1LL;
  if ( (*(_DWORD *)a4 & 0x8000) != 0 )
    goto LABEL_22;
  v18 = *(_QWORD *)(a4 + 136);
  v11 = (*(_DWORD *)(v18 + 4))-- == 1;
  if ( !v11 )
    goto LABEL_22;
LABEL_17:
  *(_QWORD *)(v18 + 8) = 0LL;
  if ( _libc_multiple_threads )
  {
    if ( !_InterlockedDecrement((volatile signed __int32 *)v18) )
      goto LABEL_22;
    goto LABEL_21;
  }
  v11 = (*(_DWORD *)v18)-- == 1;
  if ( !v11 )
LABEL_21:
    _lll_unlock_wake_private((u32 *)v18, v18, v16, a4, v17, a6);
LABEL_22:
  if ( v6 == v16 || (_BYTE)v17 )
    return v13;
  else
    return v16 / v8;
}
// 45FE03: variable 'a3' is possibly undefined
// 45FF00: variable 'a6' is possibly undefined
// 45FE48: variable 'v15' is possibly undefined
// 45FE48: variable '_R8' is possibly undefined
// 45FE92: variable 'a4' is possibly undefined
// 45FE92: variable 'v17' is possibly undefined
// 45FEA1: variable 'v16' is possibly undefined
// 4A9C40: using guessed type u32 _start___libc_IO_vtables[48];
// 4AA2E8: using guessed type __int64 (__fastcall *_start___libc_atexit)();
// 4AB820: using guessed type int _libc_multiple_threads;

//----- (000000000045FF20) ----------------------------------------------------
__int64 __fastcall getdelim(__int64 *a1, __int64 _RSI, __int64 _RDX, unsigned int *a4, u32 *a5, unsigned __int64 a6)
{
  unsigned __int64 v7; // rcx
  _QWORD *v9; // rax
  __int64 v10; // r10
  __int64 v11; // r14
  __int64 v12; // r15
  __int64 v13; // rbp
  __int64 v14; // rdi
  unsigned __int64 v15; // rax
  _QWORD *v16; // rdx
  __int64 *v17; // rax
  __int64 v18; // r10
  __int64 v19; // rdx
  __int64 v20; // rax
  __int64 v21; // r13
  __int64 v22; // rax
  unsigned int v23; // eax
  bool v25; // zf
  unsigned __int64 *v26; // [rsp+8h] [rbp-50h]
  _QWORD *v27; // [rsp+10h] [rbp-48h]
  __int64 v28; // [rsp+10h] [rbp-48h]
  unsigned int v29; // [rsp+1Ch] [rbp-3Ch]

  if ( !a1 || !_RSI )
  {
    v13 = -1LL;
    __writefsdword(0xFFFFFFC0, 0x16u);
    return v13;
  }
  v7 = *a4;
  v29 = _RDX;
  v26 = (unsigned __int64 *)_RSI;
  if ( (v7 & 0x8000) != 0 )
  {
    v7 &= 0x20u;
    if ( (_DWORD)v7 )
      return -1LL;
    goto LABEL_5;
  }
  _RDX = *((_QWORD *)a4 + 17);
  a5 = (u32 *)__readfsqword(0x10u);
  if ( *(u32 **)(_RDX + 8) == a5 )
  {
    ++*(_DWORD *)(_RDX + 4);
    v7 &= 0x20u;
    if ( (_DWORD)v7 )
    {
      v13 = -1LL;
      goto LABEL_25;
    }
    goto LABEL_5;
  }
  _RSI = 1LL;
  v25 = _libc_multiple_threads == 0;
  if ( !_libc_multiple_threads )
  {
    __asm { cmpxchg [rdx], esi }
    if ( v25 )
      goto LABEL_38;
    goto LABEL_37;
  }
  if ( (v7 & 0x8000) != _InterlockedCompareExchange((volatile signed __int32 *)_RDX, 1, v7 & 0x8000) )
LABEL_37:
    _lll_lock_wait_private((u32 *)_RDX, 1LL, _RDX, v7, a5, a6);
LABEL_38:
  _RDX = *((_QWORD *)a4 + 17);
  v23 = *a4;
  *(_QWORD *)(_RDX + 8) = a5;
  ++*(_DWORD *)(_RDX + 4);
  if ( (v23 & 0x20) != 0 )
  {
    v13 = -1LL;
    goto LABEL_23;
  }
LABEL_5:
  if ( *a1 && *v26 || (*v26 = 120LL, v9 = malloc(0x78uLL, _RSI, (_QWORD *)_RDX, v7, a5, a6), (*a1 = (__int64)v9) != 0) )
  {
    v10 = *((_QWORD *)a4 + 1);
    v11 = *((_QWORD *)a4 + 2) - v10;
    if ( v11 > 0 )
      goto LABEL_9;
    if ( (unsigned int)_underflow((__int64)a4, _RSI, _RDX, v7, a5, a6) != -1 )
    {
      v10 = *((_QWORD *)a4 + 1);
      v11 = *((_QWORD *)a4 + 2) - v10;
LABEL_9:
      v12 = 0LL;
      while ( 1 )
      {
        _RSI = v29;
        v28 = v10;
        v20 = j_memchr_ifunc(v10, v29, v11);
        v18 = v28;
        v21 = v20;
        v22 = v20 - v28 + 1;
        if ( v21 )
          v11 = v22;
        if ( v11 >= 0x7FFFFFFFFFFFFFFFLL - v12 )
        {
          __writefsdword(0xFFFFFFC0, 0x4Bu);
          goto LABEL_22;
        }
        v13 = v12 + v11;
        v14 = *a1;
        v15 = v12 + v11 + 1;
        if ( *v26 < v15 )
        {
          v16 = (_QWORD *)(2 * *v26);
          if ( (unsigned __int64)v16 < v15 )
            v16 = (_QWORD *)(v12 + v11 + 1);
          _RSI = (__int64)v16;
          v27 = v16;
          v17 = realloc(v14, (unsigned __int64)v16, v16, (__int64)v26, a5, a6);
          v14 = (__int64)v17;
          if ( !v17 )
            goto LABEL_22;
          *a1 = (__int64)v17;
          v18 = *((_QWORD *)a4 + 1);
          *v26 = (unsigned __int64)v27;
        }
        _RSI = v18;
        j_memcpy(v12 + v14, v18, v11);
        *((_QWORD *)a4 + 1) += v11;
        if ( v21 || (unsigned int)_underflow((__int64)a4, _RSI, v19, v7, a5, a6) == -1 )
          break;
        v10 = *((_QWORD *)a4 + 1);
        v12 += v11;
        v11 = *((_QWORD *)a4 + 2) - v10;
      }
      *(_BYTE *)(*a1 + v13) = 0;
      v23 = *a4;
      goto LABEL_23;
    }
  }
LABEL_22:
  v23 = *a4;
  v13 = -1LL;
LABEL_23:
  if ( (v23 & 0x8000) != 0 )
    return v13;
  _RDX = *((_QWORD *)a4 + 17);
LABEL_25:
  v25 = (*(_DWORD *)(_RDX + 4))-- == 1;
  if ( v25 )
  {
    *(_QWORD *)(_RDX + 8) = 0LL;
    if ( _libc_multiple_threads )
    {
      if ( !_InterlockedDecrement((volatile signed __int32 *)_RDX) )
        return v13;
      goto LABEL_30;
    }
    v25 = (*(_DWORD *)_RDX)-- == 1;
    if ( !v25 )
LABEL_30:
      _lll_unlock_wake_private((u32 *)_RDX, _RSI, _RDX, v7, a5, a6);
  }
  return v13;
}
// 45FF8E: variable 'v7' is possibly undefined
// 45FF8E: variable 'a5' is possibly undefined
// 45FF8E: variable 'a6' is possibly undefined
// 46002F: variable 'v19' is possibly undefined
// 460193: variable '_RDX' is possibly undefined
// 401040: using guessed type __int64 __fastcall j_memcpy(_QWORD, _QWORD, _QWORD);
// 401068: using guessed type __int64 __fastcall j_memchr_ifunc(_QWORD, _QWORD, _QWORD);
// 4AB820: using guessed type int _libc_multiple_threads;

//----- (0000000000460200) ----------------------------------------------------
_BYTE *__fastcall IO_getline_info(
        __int64 a1,
        __int64 a2,
        unsigned __int64 a3,
        unsigned __int64 a4,
        u32 *a5,
        _DWORD *a6)
{
  unsigned int v7; // er12
  __int64 v8; // rdx
  _BYTE *v9; // rbp
  __int64 v10; // rbx
  __int64 v11; // rax
  __int64 v12; // r8
  __int64 v13; // r13
  int v14; // eax
  _BYTE *v15; // rbp
  _BYTE *v17; // rbx
  __int64 v18; // r12
  __int64 v19; // [rsp+8h] [rbp-50h]
  __int64 v20; // [rsp+8h] [rbp-50h]
  int v21; // [rsp+14h] [rbp-44h]

  v7 = a4;
  v19 = a2;
  v21 = (int)a5;
  if ( a6 )
    *a6 = 0;
  v8 = *(unsigned int *)(a1 + 192);
  if ( !(_DWORD)v8 )
    *(_DWORD *)(a1 + 192) = -1;
  if ( !a3 )
    return 0LL;
  v9 = (_BYTE *)a2;
  while ( 1 )
  {
    while ( 1 )
    {
      v13 = *(_QWORD *)(a1 + 8);
      v10 = *(_QWORD *)(a1 + 16) - v13;
      if ( v10 > 0 )
        break;
      v14 = _uflow(a1, a2, v8, a4, a5, (unsigned __int64)a6);
      if ( v14 == -1 )
      {
        v15 = &v9[-v19];
        if ( a6 )
          *a6 = -1;
        return v15;
      }
      if ( v14 == v7 )
      {
        if ( v21 <= 0 )
        {
          if ( v21 )
            IO_sputbackc(a1, v7, v8, a4, a5, (__int64)a6);
        }
        else
        {
          *v9++ = v7;
        }
        return &v9[-v19];
      }
      --a3;
      *v9++ = v14;
      if ( !a3 )
        return &v9[-v19];
    }
    if ( v10 > a3 )
      v10 = a3;
    v11 = j_memchr_ifunc(*(_QWORD *)(a1 + 8), v7, v10);
    v12 = v11;
    if ( v11 )
      break;
    a2 = v13;
    a3 -= v10;
    j_memcpy(v9, v13, v10);
    v9 += v10;
    *(_QWORD *)(a1 + 8) += v10;
    if ( !a3 )
      return &v9[-v19];
  }
  v17 = &v9[-v19];
  v18 = v11 - v13;
  if ( v21 >= 0 )
  {
    v12 = v11 + 1;
    v18 -= (v21 == 0) - 1LL;
  }
  v20 = v12;
  j_memcpy(v9, v13, v18);
  v15 = &v17[v18];
  *(_QWORD *)(a1 + 8) = v20;
  return v15;
}
// 4602A5: variable 'v8' is possibly undefined
// 4602A5: variable 'a4' is possibly undefined
// 4602A5: variable 'a5' is possibly undefined
// 4602A5: variable 'a6' is possibly undefined
// 401040: using guessed type __int64 __fastcall j_memcpy(_QWORD, _QWORD, _QWORD);
// 401068: using guessed type __int64 __fastcall j_memchr_ifunc(_QWORD, _QWORD, _QWORD);

//----- (0000000000460390) ----------------------------------------------------
_BYTE *__fastcall IO_getline(__int64 a1, __int64 a2, unsigned __int64 a3, unsigned __int64 a4, u32 *a5)
{
  return IO_getline_info(a1, a2, a3, a4, a5, 0LL);
}

//----- (00000000004603A0) ----------------------------------------------------
__int64 __fastcall IO_padn(char *a1, char *i, int a3, __int64 a4, u32 *a5, __int64 a6)
{
  char *v6; // r13
  char *v7; // rbx
  int v8; // ebp
  __int64 v9; // r12
  __int64 v10; // rax
  __int64 v11; // rax
  __int64 v12; // r14
  __int64 v14; // [rsp+8h] [rbp-60h]
  char v15[15]; // [rsp+10h] [rbp-58h] BYREF
  _BYTE v16[73]; // [rsp+1Fh] [rbp-49h] BYREF

  v6 = a1;
  v7 = (char *)&blanks;
  *(_QWORD *)&v16[9] = __readfsqword(0x28u);
  if ( (_DWORD)i != 32 )
  {
    v7 = (char *)&zeroes;
    if ( (_DWORD)i != 48 )
    {
      a1 = v15;
      a4 = (unsigned int)i;
      for ( i = v16; ; --i )
      {
        *i = a4;
        if ( i == v15 )
          break;
      }
      v7 = i;
    }
  }
  v8 = a3;
  if ( a3 <= 15 )
  {
    v9 = 0LL;
LABEL_14:
    if ( v8 > 0 )
    {
      v12 = *((_QWORD *)v6 + 27);
      if ( (char *)&_start___libc_atexit - (char *)_start___libc_IO_vtables <= (unsigned __int64)(v12
                                                                                                - (_QWORD)_start___libc_IO_vtables) )
        IO_vtable_check(
          (__int64)a1,
          (__int64)i,
          (__int64)_start___libc_IO_vtables,
          v12 - (_QWORD)_start___libc_IO_vtables,
          a5,
          a6);
      v9 += (*(__int64 (__fastcall **)(char *, char *, _QWORD))(v12 + 56))(v6, v7, v8);
    }
  }
  else
  {
    v9 = 0LL;
    while ( 1 )
    {
      v11 = *((_QWORD *)v6 + 27);
      if ( (char *)&_start___libc_atexit - (char *)_start___libc_IO_vtables <= (unsigned __int64)(v11
                                                                                                - (_QWORD)_start___libc_IO_vtables) )
      {
        v14 = *((_QWORD *)v6 + 27);
        IO_vtable_check((__int64)a1, (__int64)i, v11 - (_QWORD)_start___libc_IO_vtables, a4, a5, a6);
        v11 = v14;
      }
      i = v7;
      a1 = v6;
      v10 = (*(__int64 (__fastcall **)(char *, char *, __int64))(v11 + 56))(v6, v7, 16LL);
      v9 += v10;
      if ( v10 != 16 )
        break;
      v8 -= 16;
      if ( v8 <= 15 )
        goto LABEL_14;
    }
  }
  return v9;
}
// 460456: variable 'a4' is possibly undefined
// 460456: variable 'a5' is possibly undefined
// 460456: variable 'a6' is possibly undefined
// 482BD0: using guessed type __int128 blanks;
// 4A9C40: using guessed type u32 _start___libc_IO_vtables[48];
// 4AA2E8: using guessed type __int64 (__fastcall *_start___libc_atexit)();

//----- (00000000004604D0) ----------------------------------------------------
__int64 __fastcall IO_wpadn(char *a1, __int64 a2, int a3, __int64 a4, u32 *a5, __int64 a6)
{
  char *v6; // r13
  char *v7; // rbx
  char *i; // rax
  int v9; // ebp
  __int64 v10; // r12
  __int64 v11; // rax
  __int64 v12; // rax
  __int64 v13; // r14
  __int64 v15; // [rsp+8h] [rbp-90h]
  char v16[60]; // [rsp+10h] [rbp-88h] BYREF
  _BYTE v17[76]; // [rsp+4Ch] [rbp-4Ch] BYREF

  v6 = a1;
  v7 = (char *)&blanks_0;
  *(_QWORD *)&v17[12] = __readfsqword(0x28u);
  if ( (_DWORD)a2 != 32 )
  {
    v7 = (char *)&zeroes_0;
    if ( (_DWORD)a2 != 48 )
    {
      a1 = v16;
      for ( i = v17; ; i -= 4 )
      {
        *(_DWORD *)i = a2;
        a4 = (__int64)(i - 4);
        if ( i == v16 )
          break;
      }
      v7 = i;
    }
  }
  v9 = a3;
  if ( a3 <= 15 )
  {
    v10 = 0LL;
LABEL_14:
    if ( v9 > 0 )
    {
      v13 = *((_QWORD *)v6 + 27);
      if ( (char *)&_start___libc_atexit - (char *)_start___libc_IO_vtables <= (unsigned __int64)(v13
                                                                                                - (_QWORD)_start___libc_IO_vtables) )
        IO_vtable_check(
          (__int64)a1,
          a2,
          (__int64)_start___libc_IO_vtables,
          v13 - (_QWORD)_start___libc_IO_vtables,
          a5,
          a6);
      v10 += (*(__int64 (__fastcall **)(char *, char *, _QWORD))(v13 + 56))(v6, v7, v9);
    }
  }
  else
  {
    v10 = 0LL;
    while ( 1 )
    {
      v12 = *((_QWORD *)v6 + 27);
      if ( (char *)&_start___libc_atexit - (char *)_start___libc_IO_vtables <= (unsigned __int64)(v12
                                                                                                - (_QWORD)_start___libc_IO_vtables) )
      {
        v15 = *((_QWORD *)v6 + 27);
        IO_vtable_check((__int64)a1, a2, v12 - (_QWORD)_start___libc_IO_vtables, a4, a5, a6);
        v12 = v15;
      }
      a2 = (__int64)v7;
      a1 = v6;
      v11 = (*(__int64 (__fastcall **)(char *, char *, __int64))(v12 + 56))(v6, v7, 16LL);
      v10 += v11;
      if ( v11 != 16 )
        break;
      v9 -= 16;
      if ( v9 <= 15 )
        goto LABEL_14;
    }
  }
  return v10;
}
// 460586: variable 'a4' is possibly undefined
// 460586: variable 'a5' is possibly undefined
// 460586: variable 'a6' is possibly undefined
// 4A9C40: using guessed type u32 _start___libc_IO_vtables[48];
// 4AA2E8: using guessed type __int64 (__fastcall *_start___libc_atexit)();

//----- (0000000000460600) ----------------------------------------------------
__int64 __fastcall save_for_wbackup_isra_0(__int64 **a1, __int64 a2, __int64 a3)
{
  __int64 *v6; // rax
  _QWORD *v7; // rdx
  __int64 *v8; // r14
  __int64 v9; // r10
  __int64 v10; // r11
  __int64 v11; // rdi
  __int64 v12; // r12
  __int64 v13; // rbp
  unsigned __int64 v14; // rsi
  __int64 v15; // rbx
  __int64 v16; // rcx
  __int64 v17; // r8
  __int64 v18; // r12
  __int64 v19; // rsi
  __int64 v20; // r14
  __int64 v21; // r15
  __int64 v22; // rdi
  _QWORD *v24; // rax
  _QWORD *v25; // r15
  __int64 v26; // rsi
  _QWORD *v27; // r14
  __int64 v28; // rsi
  __int64 v29; // rdx
  __int64 v30; // rcx
  u32 *v31; // r8
  _QWORD *v32; // rdx
  __int64 v33; // rcx
  __int64 v34; // rax
  __int64 **v36; // [rsp+10h] [rbp-58h]
  __int64 **v37; // [rsp+10h] [rbp-58h]
  __int64 v38; // [rsp+18h] [rbp-50h]
  __int64 **v39; // [rsp+20h] [rbp-48h]
  __int64 v40; // [rsp+28h] [rbp-40h]

  v6 = *a1;
  v7 = *(_QWORD **)a2;
  v8 = v6;
  v9 = *(_QWORD *)(*(_QWORD *)a2 + 16LL);
  v10 = *(_QWORD *)(*(_QWORD *)a2 + 80LL);
  v11 = *(_QWORD *)(*(_QWORD *)a2 + 64LL);
  v12 = a3 - v9;
  v13 = v12 >> 2;
  v14 = (v10 - v11) >> 2;
  v15 = v12 >> 2;
  v16 = v12 >> 2;
  if ( !v6 )
  {
    v21 = (v10 - v11) >> 2;
    v20 = v10 - v11;
    if ( v12 >= 0 )
    {
      v7[9] = v10;
      return 0LL;
    }
    v22 = v10;
LABEL_18:
    v37 = a1;
    wmemmove(v22, v10 + 4 * v15, -v15);
    wmemcpy(
      *(_QWORD *)(*(_QWORD *)a2 + 64LL) + 4 * (v21 - v15),
      *(_QWORD *)(*(_QWORD *)a2 + 16LL),
      (a3 - *(_QWORD *)(*(_QWORD *)a2 + 16LL)) >> 2);
    v32 = *(_QWORD **)a2;
    v27 = (_QWORD *)(*(_QWORD *)(*(_QWORD *)a2 + 64LL) + v20);
    v16 = (a3 - *(_QWORD *)(*(_QWORD *)a2 + 16LL)) >> 2;
    v6 = *v37;
    goto LABEL_15;
  }
  do
  {
    v17 = *((int *)v8 + 4);
    v8 = (__int64 *)*v8;
    if ( v15 > v17 )
      v15 = v17;
  }
  while ( v8 );
  v18 = v13 - v15;
  if ( v13 - v15 <= v14 )
  {
    v19 = v14 - v18;
    v20 = 4 * v19;
    v21 = v19;
    v22 = 4 * v19 + v11;
    if ( v15 >= 0 )
    {
      v36 = a1;
      if ( !v18 )
      {
        v7[9] = v22;
        goto LABEL_9;
      }
      wmemcpy(v22, v9 + 4 * v15, v13 - v15);
      v32 = *(_QWORD **)a2;
      v27 = (_QWORD *)(*(_QWORD *)(*(_QWORD *)a2 + 64LL) + v20);
      v16 = (a3 - *(_QWORD *)(*(_QWORD *)a2 + 16LL)) >> 2;
      v6 = *v36;
      goto LABEL_15;
    }
    goto LABEL_18;
  }
  v39 = a1;
  v40 = v10;
  v38 = v9;
  v24 = malloc(4 * v18 + 400, v14, v7, v16, (u32 *)v17, (__int64)a1);
  v25 = v24;
  if ( v24 )
  {
    v26 = 4 * v15;
    v27 = v24 + 50;
    if ( v15 < 0 )
    {
      v34 = wmempcpy((__int64)(v24 + 50), v40 + v26, -v15);
      v28 = v38;
      wmempcpy(v34, v38, v13);
    }
    else
    {
      v28 = v38 + v26;
      wmemcpy((__int64)(v24 + 50), v28, v13 - v15);
    }
    free(*(_QWORD *)(*(_QWORD *)a2 + 64LL), v28, v29, v30, v31, (unsigned __int64)v39);
    v32 = *(_QWORD **)a2;
    v6 = *v39;
    v33 = a3 - *(_QWORD *)(*(_QWORD *)a2 + 16LL);
    v32[8] = v25;
    v16 = v33 >> 2;
    v32[10] = (char *)v25 + 4 * v18 + 400;
LABEL_15:
    v32[9] = v27;
    while ( v6 )
    {
LABEL_9:
      *((_DWORD *)v6 + 4) -= v16;
      v6 = (__int64 *)*v6;
    }
    return 0LL;
  }
  return 0xFFFFFFFFLL;
}
// 460747: variable 'v29' is possibly undefined
// 460747: variable 'v30' is possibly undefined
// 460747: variable 'v31' is possibly undefined

//----- (0000000000460890) ----------------------------------------------------
__int64 __fastcall IO_least_wmarker(__int64 a1, __int64 a2)
{
  __int64 **v2; // rdx
  __int64 result; // rax
  __int64 v4; // rcx

  v2 = *(__int64 ***)(a1 + 96);
  result = (a2 - *(_QWORD *)(*(_QWORD *)(a1 + 160) + 16LL)) >> 2;
  while ( v2 )
  {
    v4 = *((int *)v2 + 4);
    v2 = (__int64 **)*v2;
    if ( result > v4 )
      result = v4;
  }
  return result;
}

//----- (00000000004608D0) ----------------------------------------------------
_QWORD *__fastcall IO_switch_to_main_wget_area(__int64 a1)
{
  _QWORD *result; // rax
  __int64 v2; // rcx
  __int64 v3; // rdx
  __int64 v4; // rcx

  result = *(_QWORD **)(a1 + 160);
  *(_DWORD *)a1 &= ~0x100u;
  v2 = result[10];
  result[10] = result[1];
  v3 = result[8];
  result[1] = v2;
  v4 = result[2];
  *result = v3;
  result[2] = v3;
  result[8] = v4;
  return result;
}

//----- (0000000000460910) ----------------------------------------------------
_QWORD *__fastcall IO_switch_to_wbackup_area(__int64 a1)
{
  _QWORD *result; // rax
  __int64 v2; // rdx
  __int64 v3; // rsi
  __int64 v4; // rcx

  result = *(_QWORD **)(a1 + 160);
  *(_DWORD *)a1 |= 0x100u;
  v2 = result[10];
  v3 = result[8];
  result[10] = result[1];
  v4 = result[2];
  result[1] = v2;
  result[2] = v3;
  result[8] = v4;
  *result = v2;
  return result;
}

//----- (0000000000460950) ----------------------------------------------------
__int64 __fastcall IO_wsetb(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, unsigned __int64 a6)
{
  __int64 v7; // r8
  int v8; // eax
  __int64 v9; // rdi
  int v10; // edx
  __int64 result; // rax
  unsigned int v12; // edx
  __int64 v13; // [rsp+10h] [rbp-18h]
  int v14; // [rsp+1Ch] [rbp-Ch]

  v7 = *(_QWORD *)(a1 + 160);
  v8 = *(_DWORD *)(a1 + 116);
  v9 = *(_QWORD *)(v7 + 48);
  if ( v9 && (v8 & 8) == 0 )
  {
    v14 = a4;
    v13 = a3;
    free(v9, a2, a3, a4, (u32 *)v7, a6);
    v7 = *(_QWORD *)(a1 + 160);
    v8 = *(_DWORD *)(a1 + 116);
    LODWORD(a4) = v14;
    a3 = v13;
  }
  *(_QWORD *)(v7 + 56) = a3;
  v10 = v8;
  result = v8 | 8u;
  v12 = v10 & 0xFFFFFFF7;
  *(_QWORD *)(v7 + 48) = a2;
  if ( (_DWORD)a4 )
    result = v12;
  *(_DWORD *)(a1 + 116) = result;
  return result;
}

//----- (00000000004609D0) ----------------------------------------------------
__int64 __fastcall IO_wdefault_pbackfail(int *a1, __int64 a2, _QWORD *a3, __int64 a4, u32 *a5, __int64 a6)
{
  __int64 *v6; // rbx
  int v7; // er14
  __int64 v8; // rbp
  unsigned __int64 v9; // r15
  int v10; // eax
  __int64 result; // rax
  __int64 v12; // rbp
  __int64 v13; // rbx
  unsigned __int64 v14; // r14
  _QWORD *v15; // rax
  __int64 v16; // rdx
  __int64 v17; // rcx
  u32 *v18; // r8
  unsigned __int64 v19; // r9
  __int64 v20; // rcx
  _QWORD *v21; // rax
  __int64 v22; // rdx
  _QWORD *v23; // [rsp+8h] [rbp-40h]

  v6 = (__int64 *)*((_QWORD *)a1 + 20);
  v7 = *a1;
  v8 = *v6;
  v9 = v6[2];
  v10 = *a1 & 0x100;
  if ( *v6 > v9 )
  {
    if ( v10 )
    {
LABEL_3:
      *v6 = v8 - 4;
      result = (unsigned int)a2;
      *(_DWORD *)(v8 - 4) = a2;
      return result;
    }
    a3 = (_QWORD *)*((_QWORD *)a1 + 1);
    result = (unsigned int)*((char *)a3 - 1);
    if ( (_DWORD)result == (_DWORD)a2 )
    {
      *((_QWORD *)a1 + 1) = (char *)a3 - 1;
      return result;
    }
    if ( v6[8] )
    {
      if ( !(unsigned int)save_for_wbackup_isra_0((__int64 **)a1 + 12, (__int64)(a1 + 40), *v6) )
      {
        v6 = (__int64 *)*((_QWORD *)a1 + 20);
        v7 = *a1;
        v20 = *v6;
        v8 = v6[10];
        v21 = (_QWORD *)v6[8];
LABEL_13:
        v22 = v6[1];
        *a1 = v7 | 0x100;
        v6[1] = v8;
        v6[10] = v22;
        v6[2] = (__int64)v21;
        v6[8] = v20;
        *v6 = v8;
        goto LABEL_3;
      }
      return 0xFFFFFFFFLL;
    }
    goto LABEL_14;
  }
  if ( !v10 )
  {
    v21 = (_QWORD *)v6[8];
    if ( v21 )
    {
      v20 = *v6;
      v8 = v6[10];
      goto LABEL_13;
    }
LABEL_14:
    v21 = malloc(0x200uLL, a2, a3, a4, a5, a6);
    if ( v21 )
    {
      v20 = v8;
      v6[8] = (__int64)v21;
      v6[10] = (__int64)(v21 + 64);
      v8 = (__int64)(v21 + 64);
      v6[9] = (__int64)(v21 + 64);
      goto LABEL_13;
    }
    return 0xFFFFFFFFLL;
  }
  v12 = v6[1] - v9;
  v13 = v12 >> 2;
  v14 = v12 >> 2;
  v15 = malloc(v14 * 8, a2, a3, a4, a5, a6);
  if ( v15 )
  {
    v8 = (__int64)v15 + v12;
    v23 = v15;
    wmemcpy(v8, v9, v13);
    free(*(_QWORD *)(*((_QWORD *)a1 + 20) + 16LL), v9, v16, v17, v18, v19);
    v6 = (__int64 *)*((_QWORD *)a1 + 20);
    v6[2] = (__int64)v23;
    *v6 = v8;
    v6[1] = (__int64)&v23[v14];
    v6[9] = v8;
    goto LABEL_3;
  }
  return 0xFFFFFFFFLL;
}
// 460A80: variable 'v16' is possibly undefined
// 460A80: variable 'v17' is possibly undefined
// 460A80: variable 'v18' is possibly undefined
// 460A80: variable 'v19' is possibly undefined

//----- (0000000000460B90) ----------------------------------------------------
unsigned __int64 __fastcall IO_wdefault_finish(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        unsigned int *a4,
        u32 *a5,
        unsigned __int64 a6)
{
  _QWORD *v6; // rdx
  __int64 v8; // rdi
  _QWORD *i; // rax

  v6 = *(_QWORD **)(a1 + 160);
  v8 = v6[6];
  if ( v8 && (*(_BYTE *)(a1 + 116) & 8) == 0 )
  {
    free(v8, a2, (__int64)v6, (__int64)a4, a5, a6);
    v6 = *(_QWORD **)(a1 + 160);
    v6[7] = 0LL;
    v6[6] = 0LL;
  }
  for ( i = *(_QWORD **)(a1 + 96); i; i = (_QWORD *)*i )
    i[1] = 0LL;
  if ( *(_QWORD *)(a1 + 72) )
  {
    free(v6[8], a2, (__int64)v6, (__int64)a4, a5, a6);
    *(_QWORD *)(a1 + 72) = 0LL;
  }
  return IO_un_link((unsigned int *)a1, a2, (__int64)v6, a4, a5, a6);
}
// 460BDB: variable 'a4' is possibly undefined
// 460BDB: variable 'a5' is possibly undefined
// 460BDB: variable 'a6' is possibly undefined
// 460BEC: variable 'v6' is possibly undefined

//----- (0000000000460C20) ----------------------------------------------------
__int64 __fastcall IO_wdefault_uflow(__int64 a1, __int64 a2, __int64 a3, __int64 a4, u32 *a5, __int64 a6)
{
  __int64 v6; // rbp
  int v7; // eax
  unsigned int v8; // edx
  unsigned int **v9; // rdx
  unsigned int *v10; // rax

  v6 = *(_QWORD *)(a1 + 216);
  if ( (char *)&_start___libc_atexit - (char *)_start___libc_IO_vtables <= (unsigned __int64)(v6
                                                                                            - (_QWORD)_start___libc_IO_vtables) )
    IO_vtable_check(a1, v6 - (_QWORD)_start___libc_IO_vtables, (__int64)_start___libc_IO_vtables, a4, a5, a6);
  v7 = (*(__int64 (__fastcall **)(__int64))(v6 + 32))(a1);
  v8 = -1;
  if ( v7 != -1 )
  {
    v9 = *(unsigned int ***)(a1 + 160);
    v10 = (*v9)++;
    return *v10;
  }
  return v8;
}
// 4A9C40: using guessed type u32 _start___libc_IO_vtables[48];
// 4AA2E8: using guessed type __int64 (__fastcall *_start___libc_atexit)();

//----- (0000000000460C90) ----------------------------------------------------
__int64 __fastcall _woverflow(__int64 a1, __int64 a2, __int64 a3, __int64 a4, u32 *a5, __int64 a6)
{
  unsigned int v6; // er12
  __int64 v7; // rbp
  u32 *v8; // rdx
  __int64 v9; // rcx

  v6 = a2;
  if ( !*(_DWORD *)(a1 + 192) )
  {
    a2 = 1LL;
    IO_fwide(a1, 1LL, a3, a4, a5, a6);
  }
  v7 = *(_QWORD *)(a1 + 216);
  v8 = _start___libc_IO_vtables;
  v9 = v7 - (_QWORD)_start___libc_IO_vtables;
  if ( (char *)&_start___libc_atexit - (char *)_start___libc_IO_vtables <= (unsigned __int64)(v7
                                                                                            - (_QWORD)_start___libc_IO_vtables) )
    IO_vtable_check(a1, a2, (__int64)_start___libc_IO_vtables, v9, a5, a6);
  return (*(__int64 (__fastcall **)(__int64, _QWORD, u32 *, __int64, u32 *))(v7 + 24))(a1, v6, v8, v9, a5);
}
// 460CF0: variable 'a5' is possibly undefined
// 460CF0: variable 'a6' is possibly undefined
// 460CD9: variable 'v8' is possibly undefined
// 460CD9: variable 'v9' is possibly undefined
// 4A9C40: using guessed type u32 _start___libc_IO_vtables[48];
// 4AA2E8: using guessed type __int64 (__fastcall *_start___libc_atexit)();

//----- (0000000000460D00) ----------------------------------------------------
__int64 __fastcall IO_wdefault_xsputn(__int64 a1, __int64 a2, __int64 a3, __int64 a4, u32 *a5, __int64 a6)
{
  unsigned __int64 v7; // r13
  __int64 v8; // r12
  __int64 v10; // rcx
  unsigned int *v11; // r14
  __int64 v12; // rdi
  __int64 v13; // rax
  __int64 v14; // rbx
  __int64 v15; // rax
  __int64 v17; // rsi
  __int64 v18; // rax
  __int64 v19; // [rsp+0h] [rbp-40h]

  if ( !a3 )
    return 0LL;
  v7 = a3;
  v8 = a3;
  while ( 1 )
  {
    v10 = *(_QWORD *)(a1 + 160);
    v11 = (unsigned int *)a2;
    v12 = *(_QWORD *)(v10 + 32);
    if ( *(_QWORD *)(v10 + 40) - v12 <= 0 )
      goto LABEL_4;
    v13 = (*(_QWORD *)(v10 + 40) - v12) >> 2;
    if ( v13 > v7 )
      v13 = v7;
    v14 = v13;
    if ( v13 <= 20 )
    {
      if ( v13 )
      {
        v17 = 4 * v13;
        v18 = 0LL;
        do
        {
          a3 = *(unsigned int *)(a2 + v18);
          *(_DWORD *)(v12 + v18) = a3;
          v18 += 4LL;
        }
        while ( v17 != v18 );
        v11 = (unsigned int *)(a2 + v17);
        v7 -= v14;
        *(_QWORD *)(v10 + 32) = v17 + v12;
      }
LABEL_4:
      if ( !v7 )
        return v8;
      goto LABEL_5;
    }
    v19 = *(_QWORD *)(a1 + 160);
    v7 -= v13;
    v15 = wmempcpy(v12, a2, v13);
    v10 = v19;
    v11 = (unsigned int *)(a2 + 4 * v14);
    *(_QWORD *)(v19 + 32) = v15;
    if ( !v7 )
      return v8;
LABEL_5:
    a2 = (__int64)(v11 + 1);
    if ( (unsigned int)_woverflow(a1, *v11, a3, v10, a5, a6) == -1 )
      break;
    --v7;
  }
  v8 -= v7;
  return v8;
}
// 460D48: variable 'a3' is possibly undefined
// 460D48: variable 'a5' is possibly undefined
// 460D48: variable 'a6' is possibly undefined

//----- (0000000000460E10) ----------------------------------------------------
void __fastcall IO_wdoallocbuf(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, unsigned __int64 a6)
{
  __int64 v6; // rsi

  v6 = *(_QWORD *)(a1 + 160);
  if ( !*(_QWORD *)(v6 + 48) )
  {
    if ( (*(_BYTE *)a1 & 2) == 0 )
    {
      if ( (*(unsigned int (**)(void))(*(_QWORD *)(v6 + 304) + 104LL))() != -1 )
        return;
      v6 = *(_QWORD *)(a1 + 160);
    }
    IO_wsetb(a1, v6 + 296, v6 + 300, 0LL, a5, a6);
  }
}
// 460E63: variable 'a5' is possibly undefined
// 460E63: variable 'a6' is possibly undefined

//----- (0000000000460E70) ----------------------------------------------------
__int64 __fastcall IO_wdefault_doallocate(__int64 a1, __int64 a2, _QWORD *a3, __int64 a4, u32 *a5, __int64 a6)
{
  _QWORD *v6; // rsi
  __int64 v7; // r8
  unsigned __int64 v8; // r9
  __int64 result; // rax

  v6 = malloc(0x2000uLL, a2, a3, a4, a5, a6);
  result = 0xFFFFFFFFLL;
  if ( v6 )
  {
    IO_wsetb(a1, (__int64)v6, (__int64)(v6 + 4096), 1LL, v7, v8);
    return 1LL;
  }
  return result;
}
// 460E9E: variable 'v7' is possibly undefined
// 460E9E: variable 'v8' is possibly undefined

//----- (0000000000460EB0) ----------------------------------------------------
__int64 __fastcall IO_switch_to_wget_mode(int *a1)
{
  unsigned __int64 *v1; // rax
  unsigned __int64 v2; // rdx
  __int64 result; // rax
  int v4; // ecx

  v1 = (unsigned __int64 *)*((_QWORD *)a1 + 20);
  v2 = v1[4];
  if ( v2 > v1[3] )
  {
    result = (*(__int64 (__fastcall **)(int *, __int64))(v1[38] + 24))(a1, 0xFFFFFFFFLL);
    if ( (_DWORD)result == -1 )
      return result;
    v1 = (unsigned __int64 *)*((_QWORD *)a1 + 20);
    v2 = v1[4];
  }
  v4 = *a1;
  if ( (*a1 & 0x100) != 0 )
  {
    v1[2] = v1[9];
  }
  else
  {
    v1[2] = v1[6];
    if ( v1[1] < v2 )
      v1[1] = v2;
  }
  BYTE1(v4) &= ~8u;
  *v1 = v2;
  v1[5] = v2;
  v1[3] = v2;
  result = 0LL;
  *a1 = v4;
  return result;
}

//----- (0000000000460F30) ----------------------------------------------------
_QWORD *__fastcall IO_free_wbackup_area(int *a1, __int64 a2, __int64 a3, __int64 a4, u32 *a5, unsigned __int64 a6)
{
  __int64 v6; // rdx
  __int64 *v8; // rax
  __int64 v9; // rdi
  __int64 v10; // rdx
  _QWORD *result; // rax

  v6 = (unsigned int)*a1;
  v8 = (__int64 *)*((_QWORD *)a1 + 20);
  v9 = v8[8];
  if ( (v6 & 0x100) != 0 )
  {
    BYTE1(v6) &= ~1u;
    a4 = v8[10];
    *a1 = v6;
    v10 = v8[1];
    v8[1] = a4;
    v8[10] = v10;
    v6 = v8[2];
    *v8 = v9;
    v8[8] = v6;
    v8[2] = v9;
    v9 = v6;
  }
  free(v9, a2, v6, a4, a5, a6);
  result = (_QWORD *)*((_QWORD *)a1 + 20);
  result[8] = 0LL;
  result[10] = 0LL;
  result[9] = 0LL;
  return result;
}

//----- (0000000000460FA0) ----------------------------------------------------
__int64 __fastcall _wuflow(int *a1, unsigned __int64 a2, __int64 a3, __int64 a4, u32 *a5, unsigned __int64 a6)
{
  __int64 v6; // rdx
  int *v7; // rbx
  unsigned __int64 *v8; // rax
  unsigned __int64 v9; // rdx
  unsigned __int64 v10; // rcx
  __int64 v11; // rbp
  __int64 v13; // rdx
  __int64 v14; // rcx

  v6 = (unsigned int)a1[48];
  if ( (int)v6 < 0 )
    return 0xFFFFFFFFLL;
  v7 = a1;
  if ( !(_DWORD)v6 )
  {
    a2 = 1LL;
    if ( (unsigned int)IO_fwide((__int64)a1, 1LL, v6, a4, a5, a6) != 1 )
      return 0xFFFFFFFFLL;
    if ( !a1[48] )
    {
      a2 = 1LL;
      IO_fwide((__int64)a1, 1LL, v13, v14, a5, a6);
    }
  }
  if ( (*a1 & 0x800) != 0 && (unsigned int)IO_switch_to_wget_mode(a1) == -1 )
    return 0xFFFFFFFFLL;
  v8 = (unsigned __int64 *)*((_QWORD *)a1 + 20);
  v9 = *v8;
  v10 = v8[1];
  if ( *v8 < v10 )
    goto LABEL_15;
  v9 = (unsigned int)*a1;
  if ( (v9 & 0x100) == 0 )
    goto LABEL_8;
  BYTE1(v9) &= ~1u;
  a2 = v8[10];
  *a1 = v9;
  v9 = v8[8];
  v8[10] = v10;
  v10 = v8[2];
  v8[1] = a2;
  v8[2] = v9;
  v8[8] = v10;
  if ( a2 > v9 )
  {
LABEL_15:
    *v8 = v9 + 4;
    return *(unsigned int *)v9;
  }
  *v8 = v9;
LABEL_8:
  if ( !*((_QWORD *)a1 + 12) )
  {
    if ( v8[8] )
      IO_free_wbackup_area(a1, a2, v9, v10, a5, a6);
    goto LABEL_10;
  }
  a1 += 24;
  if ( (unsigned int)save_for_wbackup_isra_0((__int64 **)v7 + 12, (__int64)(v7 + 40), v8[1]) )
    return 0xFFFFFFFFLL;
LABEL_10:
  v11 = *((_QWORD *)v7 + 27);
  if ( (char *)&_start___libc_atexit - (char *)_start___libc_IO_vtables <= (unsigned __int64)(v11
                                                                                            - (_QWORD)_start___libc_IO_vtables) )
    IO_vtable_check((__int64)a1, v11 - (_QWORD)_start___libc_IO_vtables, (__int64)_start___libc_IO_vtables, v10, a5, a6);
  return (*(__int64 (__fastcall **)(int *))(v11 + 40))(v7);
}
// 4610F0: variable 'v10' is possibly undefined
// 4610F0: variable 'a5' is possibly undefined
// 4610F0: variable 'a6' is possibly undefined
// 4610C5: variable 'v13' is possibly undefined
// 4610C5: variable 'v14' is possibly undefined
// 4A9C40: using guessed type u32 _start___libc_IO_vtables[48];
// 4AA2E8: using guessed type __int64 (__fastcall *_start___libc_atexit)();

//----- (0000000000461100) ----------------------------------------------------
__int64 __fastcall _wunderflow(int *a1, unsigned __int64 a2, __int64 a3, __int64 a4, u32 *a5, unsigned __int64 a6)
{
  __int64 v6; // rdx
  int *v7; // rbx
  unsigned __int64 *v8; // rax
  unsigned __int64 v9; // rdx
  unsigned __int64 v10; // rcx
  __int64 v11; // rbp
  __int64 v13; // rdx
  __int64 v14; // rcx

  v6 = (unsigned int)a1[48];
  if ( (int)v6 < 0 )
    return 0xFFFFFFFFLL;
  v7 = a1;
  if ( !(_DWORD)v6 )
  {
    a2 = 1LL;
    if ( (unsigned int)IO_fwide((__int64)a1, 1LL, v6, a4, a5, a6) != 1 )
      return 0xFFFFFFFFLL;
    if ( !a1[48] )
    {
      a2 = 1LL;
      IO_fwide((__int64)a1, 1LL, v13, v14, a5, a6);
    }
  }
  if ( (*a1 & 0x800) != 0 && (unsigned int)IO_switch_to_wget_mode(a1) == -1 )
    return 0xFFFFFFFFLL;
  v8 = (unsigned __int64 *)*((_QWORD *)a1 + 20);
  v9 = *v8;
  v10 = v8[1];
  if ( *v8 < v10 )
    return *(unsigned int *)v9;
  v9 = (unsigned int)*a1;
  if ( (v9 & 0x100) != 0 )
  {
    BYTE1(v9) &= ~1u;
    a2 = v8[10];
    *a1 = v9;
    v9 = v8[8];
    v8[10] = v10;
    v10 = v8[2];
    v8[1] = a2;
    v8[2] = v9;
    v8[8] = v10;
    *v8 = v9;
    if ( a2 > v9 )
      return *(unsigned int *)v9;
  }
  if ( !*((_QWORD *)a1 + 12) )
  {
    if ( *((_QWORD *)a1 + 9) )
      IO_free_wbackup_area(a1, a2, v9, v10, a5, a6);
    goto LABEL_9;
  }
  a1 += 24;
  if ( (unsigned int)save_for_wbackup_isra_0((__int64 **)v7 + 12, (__int64)(v7 + 40), v8[1]) )
    return 0xFFFFFFFFLL;
LABEL_9:
  v11 = *((_QWORD *)v7 + 27);
  if ( (char *)&_start___libc_atexit - (char *)_start___libc_IO_vtables <= (unsigned __int64)(v11
                                                                                            - (_QWORD)_start___libc_IO_vtables) )
    IO_vtable_check((__int64)a1, v11 - (_QWORD)_start___libc_IO_vtables, (__int64)_start___libc_IO_vtables, v10, a5, a6);
  return (*(__int64 (__fastcall **)(int *))(v11 + 32))(v7);
}
// 461250: variable 'v10' is possibly undefined
// 461250: variable 'a5' is possibly undefined
// 461250: variable 'a6' is possibly undefined
// 461225: variable 'v13' is possibly undefined
// 461225: variable 'v14' is possibly undefined
// 4A9C40: using guessed type u32 _start___libc_IO_vtables[48];
// 4AA2E8: using guessed type __int64 (__fastcall *_start___libc_atexit)();

//----- (0000000000461260) ----------------------------------------------------
unsigned __int64 __fastcall IO_wdefault_xsgetn(
        __int64 a1,
        __int64 a2,
        unsigned __int64 a3,
        __int64 a4,
        u32 *a5,
        unsigned __int64 a6)
{
  unsigned __int64 v7; // r13
  unsigned __int64 *v10; // rdx
  unsigned __int64 v11; // rsi
  __int64 v12; // rax
  __int64 v13; // rbx
  __int64 v14; // rax
  __int64 v16; // rdi
  __int64 v17; // rax

  v7 = a3;
  do
  {
    v10 = *(unsigned __int64 **)(a1 + 160);
    v11 = *v10;
    if ( (__int64)(v10[1] - *v10) <= 0 )
      goto LABEL_3;
    v12 = (__int64)(v10[1] - *v10) >> 2;
    if ( v12 > v7 )
      v12 = v7;
    v13 = v12;
    if ( v12 <= 20 )
    {
      if ( v12 )
      {
        v16 = (unsigned int)(v12 - 1);
        v17 = 0LL;
        a5 = (u32 *)(v16 + 1);
        while ( 1 )
        {
          *(_DWORD *)(a2 + 4 * v17) = *(_DWORD *)(v11 + 4 * v17);
          a4 = v17 + 1;
          if ( v17 == v16 )
            break;
          ++v17;
        }
        v7 -= v13;
        v11 += 4LL * (_QWORD)a5;
        a2 += 4LL * (_QWORD)a5;
        *v10 = v11;
      }
LABEL_3:
      if ( !v7 )
        return a3;
      continue;
    }
    v7 -= v12;
    v14 = wmempcpy(a2, v11, v12);
    v10 = (unsigned __int64 *)(4 * v13);
    a2 = v14;
    **(_QWORD **)(a1 + 160) += 4 * v13;
    if ( !v7 )
      return a3;
  }
  while ( (unsigned int)_wunderflow((int *)a1, v11, (__int64)v10, a4, a5, a6) != -1 );
  return a3 - v7;
}
// 46128D: variable 'a4' is possibly undefined
// 46128D: variable 'a5' is possibly undefined
// 46128D: variable 'a6' is possibly undefined

//----- (0000000000461350) ----------------------------------------------------
__int64 __fastcall IO_sputbackwc(__int64 a1, __int64 a2, __int64 a3, __int64 a4, u32 *a5, __int64 a6)
{
  __int64 *v6; // rax
  __int64 v7; // rdx
  __int64 v8; // rbp
  u32 *v9; // rdx
  __int64 v10; // rcx
  __int64 result; // rax

  v6 = *(__int64 **)(a1 + 160);
  v7 = *v6;
  if ( *v6 > (unsigned __int64)v6[2] && *(_DWORD *)(v7 - 4) == (_DWORD)a2 )
  {
    *v6 = v7 - 4;
    result = (unsigned int)a2;
  }
  else
  {
    v8 = *(_QWORD *)(a1 + 216);
    v9 = _start___libc_IO_vtables;
    v10 = v8 - (_QWORD)_start___libc_IO_vtables;
    if ( (char *)&_start___libc_atexit - (char *)_start___libc_IO_vtables <= (unsigned __int64)(v8
                                                                                              - (_QWORD)_start___libc_IO_vtables) )
    {
      IO_vtable_check(a1, a2, (__int64)_start___libc_IO_vtables, v10, a5, a6);
      a2 = (unsigned int)a2;
    }
    result = (*(__int64 (__fastcall **)(__int64, __int64, u32 *, __int64, u32 *))(v8 + 48))(a1, a2, v9, v10, a5);
  }
  if ( (_DWORD)result != -1 )
    *(_DWORD *)a1 &= ~0x10u;
  return result;
}
// 461398: variable 'v9' is possibly undefined
// 461398: variable 'v10' is possibly undefined
// 461398: variable 'a5' is possibly undefined
// 4A9C40: using guessed type u32 _start___libc_IO_vtables[48];
// 4AA2E8: using guessed type __int64 (__fastcall *_start___libc_atexit)();

//----- (00000000004613D0) ----------------------------------------------------
__int64 __fastcall IO_sungetwc(__int64 a1, __int64 a2, __int64 a3, __int64 a4, u32 *a5, __int64 a6)
{
  __int64 *v6; // rax
  __int64 v7; // rdx
  __int64 result; // rax
  __int64 v9; // rbp

  v6 = *(__int64 **)(a1 + 160);
  v7 = *v6;
  if ( *v6 <= (unsigned __int64)v6[2] )
  {
    v9 = *(_QWORD *)(a1 + 216);
    if ( (char *)&_start___libc_atexit - (char *)_start___libc_IO_vtables <= (unsigned __int64)(v9
                                                                                              - (_QWORD)_start___libc_IO_vtables) )
      IO_vtable_check(a1, v9 - (_QWORD)_start___libc_IO_vtables, (__int64)_start___libc_IO_vtables, a4, a5, a6);
    result = (*(__int64 (__fastcall **)(__int64, __int64))(v9 + 48))(a1, 0xFFFFFFFFLL);
  }
  else
  {
    *v6 = v7 - 4;
    result = *(unsigned int *)(v7 - 4);
  }
  if ( (_DWORD)result != -1 )
    *(_DWORD *)a1 &= ~0x10u;
  return result;
}
// 4A9C40: using guessed type u32 _start___libc_IO_vtables[48];
// 4AA2E8: using guessed type __int64 (__fastcall *_start___libc_atexit)();

//----- (0000000000461450) ----------------------------------------------------
__int64 __fastcall IO_adjust_wcolumn(int a1, unsigned __int64 a2, int a3)
{
  unsigned __int64 v3; // r8
  _DWORD *v4; // rcx

  v3 = a2 + 4LL * a3;
  if ( a2 < v3 )
  {
    v4 = (_DWORD *)(v3 - 4);
    if ( *(_DWORD *)(v3 - 4) == 10 )
      return 0LL;
    while ( a2 < (unsigned __int64)v4 )
    {
      if ( *--v4 == 10 )
        return (unsigned int)((__int64)(v3 - (_QWORD)v4) >> 2) - 1;
    }
  }
  return (unsigned int)(a3 + a1);
}

//----- (00000000004614A0) ----------------------------------------------------
__int64 __fastcall IO_init_wmarker(__int64 a1, __int64 a2)
{
  int v2; // edx
  __int64 *v3; // rcx
  __int64 v4; // rax
  __int64 v5; // rax
  __int64 result; // rax

  v2 = *(_DWORD *)a2;
  *(_QWORD *)(a1 + 8) = a2;
  if ( (v2 & 0x800) != 0 )
  {
    IO_switch_to_wget_mode((int *)a2);
    v2 = *(_DWORD *)a2;
  }
  v3 = *(__int64 **)(a2 + 160);
  v4 = *v3;
  if ( (v2 & 0x100) != 0 )
    v5 = v4 - v3[1];
  else
    v5 = v4 - v3[2];
  *(_DWORD *)(a1 + 16) = v5 >> 2;
  result = *(_QWORD *)(a2 + 96);
  *(_QWORD *)a1 = result;
  *(_QWORD *)(a2 + 96) = a1;
  return result;
}

//----- (0000000000461510) ----------------------------------------------------
__int64 __fastcall IO_wmarker_delta(__int64 a1)
{
  __int64 v1; // rax
  __int64 *v2; // rcx
  __int64 v3; // rdx
  int v4; // eax
  __int64 v5; // rdx

  v1 = *(_QWORD *)(a1 + 8);
  if ( !v1 )
    return 0xFFFFFFFFLL;
  v2 = *(__int64 **)(v1 + 160);
  v3 = *v2;
  if ( (*(_DWORD *)v1 & 0x100) != 0 )
  {
    v4 = *(_DWORD *)(a1 + 16);
    v5 = (v3 - v2[1]) >> 2;
  }
  else
  {
    v4 = *(_DWORD *)(a1 + 16);
    v5 = (v3 - v2[2]) >> 2;
  }
  return (unsigned int)(v4 - v5);
}

//----- (0000000000461560) ----------------------------------------------------
__int64 __fastcall IO_seekwmark(int *a1, __int64 a2)
{
  int v2; // ecx
  __int64 v3; // rdx
  _QWORD *v4; // rax
  int v5; // esi
  __int64 v6; // r8
  __int64 v7; // rsi
  __int64 v8; // rcx
  __int64 v9; // rcx
  __int64 v11; // rsi
  __int64 v12; // rcx
  __int64 v13; // rdi

  if ( *(int **)(a2 + 8) != a1 )
    return 0xFFFFFFFFLL;
  v2 = *a1;
  v3 = *(int *)(a2 + 16);
  v4 = (_QWORD *)*((_QWORD *)a1 + 20);
  v5 = *a1 & 0x100;
  if ( (int)v3 >= 0 )
  {
    v6 = v4[2];
    if ( v5 )
    {
      BYTE1(v2) &= ~1u;
      v7 = v4[10];
      *a1 = v2;
      v8 = v4[1];
      v4[1] = v7;
      v4[10] = v8;
      v9 = v4[8];
      v4[8] = v6;
      v4[2] = v9;
      v6 = v9;
    }
    goto LABEL_5;
  }
  v6 = v4[1];
  if ( v5 )
  {
LABEL_5:
    *v4 = v6 + 4 * v3;
    return 0LL;
  }
  BYTE1(v2) |= 1u;
  v11 = v4[2];
  *a1 = v2;
  v12 = v4[10];
  v13 = v4[8];
  v4[10] = v6;
  v4[1] = v12;
  v4[2] = v13;
  v4[8] = v11;
  *v4 = v12 + 4 * v3;
  return 0LL;
}

//----- (0000000000461610) ----------------------------------------------------
_QWORD *__fastcall IO_unsave_wmarkers(int *a1, __int64 a2, __int64 a3, __int64 a4, u32 *a5, unsigned __int64 a6)
{
  _QWORD *result; // rax

  if ( *((_QWORD *)a1 + 12) )
    *((_QWORD *)a1 + 12) = 0LL;
  if ( *((_QWORD *)a1 + 9) )
    return IO_free_wbackup_area(a1, a2, a3, a4, a5, a6);
  return result;
}

//----- (0000000000461640) ----------------------------------------------------
__int64 __fastcall do_encoding(__int64 a1)
{
  _DWORD *v1; // rdx
  __int64 result; // rax

  v1 = *(_DWORD **)(a1 + 72);
  if ( v1[22] )
    return 0xFFFFFFFFLL;
  result = (unsigned int)v1[19];
  if ( v1[18] != (_DWORD)result )
    return 0LL;
  return result;
}

//----- (0000000000461670) ----------------------------------------------------
__int64 do_always_noconv()
{
  return 0LL;
}
// 461670: using guessed type __int64 __fastcall do_always_noconv();

//----- (0000000000461680) ----------------------------------------------------
__int64 __fastcall do_max_length(__int64 a1)
{
  return *(unsigned int *)(*(_QWORD *)(a1 + 72) + 76LL);
}

//----- (0000000000461690) ----------------------------------------------------
__int64 __fastcall do_in(
        _QWORD *a1,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        _QWORD *a5,
        __int64 a6,
        __int64 a7,
        _QWORD *a8)
{
  _QWORD *v10; // r12
  bool v11; // zf
  __int64 (__fastcall *v12)(_QWORD *, _QWORD *, __int64 *, __int64, _QWORD, char *, _QWORD, _QWORD); // rbx
  int v13; // eax
  unsigned int v14; // edx
  char v16[8]; // [rsp+8h] [rbp-50h] BYREF
  __int64 v17[9]; // [rsp+10h] [rbp-48h] BYREF

  v10 = (_QWORD *)a1[9];
  v17[1] = __readfsqword(0x28u);
  a1[10] = a6;
  v11 = *v10 == 0LL;
  v12 = (__int64 (__fastcall *)(_QWORD *, _QWORD *, __int64 *, __int64, _QWORD, char *, _QWORD, _QWORD))v10[5];
  v17[0] = a3;
  a1[11] = a7;
  a1[14] = a2;
  if ( !v11 )
    v12 = (__int64 (__fastcall *)(_QWORD *, _QWORD *, __int64 *, __int64, _QWORD, char *, _QWORD, _QWORD))(__readfsqword(0x30u) ^ __ROR8__(v12, 17));
  dl_mcount_wrapper_check((__int64)v12);
  v13 = v12(v10, a1 + 10, v17, a4, 0LL, v16, 0LL, 0LL);
  *a5 = v17[0];
  *a8 = a1[10];
  if ( v13 == 4 )
  {
    return 0;
  }
  else if ( v13 <= 4 )
  {
    return 2 * (unsigned int)(v13 != 0);
  }
  else
  {
    v14 = 1;
    if ( v13 != 5 )
      return (unsigned int)(v13 != 7) + 1;
  }
  return v14;
}
// 461690: using guessed type char var_50[8];

//----- (0000000000461790) ----------------------------------------------------
__int64 __fastcall do_unshift(_QWORD *a1, __int64 a2, __int64 a3, __int64 a4, _QWORD *a5)
{
  _QWORD *v6; // r12
  bool v7; // zf
  __int64 (__fastcall *v8)(_QWORD *, _QWORD *, _QWORD, _QWORD, _QWORD, char *, __int64, _QWORD); // rbx
  int v9; // eax
  unsigned int v10; // edx
  char v12[8]; // [rsp+0h] [rbp-38h] BYREF
  unsigned __int64 v13; // [rsp+8h] [rbp-30h]

  v6 = (_QWORD *)a1[17];
  v13 = __readfsqword(0x28u);
  a1[18] = a3;
  v7 = *v6 == 0LL;
  a1[19] = a4;
  a1[22] = a2;
  v8 = (__int64 (__fastcall *)(_QWORD *, _QWORD *, _QWORD, _QWORD, _QWORD, char *, __int64, _QWORD))v6[5];
  if ( !v7 )
    v8 = (__int64 (__fastcall *)(_QWORD *, _QWORD *, _QWORD, _QWORD, _QWORD, char *, __int64, _QWORD))(__readfsqword(0x30u) ^ __ROR8__(v8, 17));
  dl_mcount_wrapper_check((__int64)v8);
  v9 = v8(v6, a1 + 18, 0LL, 0LL, 0LL, v12, 1LL, 0LL);
  *a5 = a1[18];
  if ( v9 == 4 )
  {
    return 0;
  }
  else if ( v9 <= 4 )
  {
    return 2 * (unsigned int)(v9 != 0);
  }
  else
  {
    v10 = 1;
    if ( v9 != 5 )
      return (unsigned int)(v9 != 7) + 1;
  }
  return v10;
}
// 461790: using guessed type char var_38[8];

//----- (0000000000461880) ----------------------------------------------------
__int64 __fastcall do_out(
        _QWORD *a1,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        _QWORD *a5,
        __int64 a6,
        __int64 a7,
        _QWORD *a8)
{
  _QWORD *v10; // r12
  bool v11; // zf
  __int64 (__fastcall *v12)(_QWORD *, _QWORD *, __int64 *, __int64, _QWORD, char *, _QWORD, _QWORD); // rbx
  int v13; // eax
  unsigned int v14; // edx
  char v16[8]; // [rsp+8h] [rbp-50h] BYREF
  __int64 v17[9]; // [rsp+10h] [rbp-48h] BYREF

  v10 = (_QWORD *)a1[17];
  v17[1] = __readfsqword(0x28u);
  v17[0] = a3;
  v11 = *v10 == 0LL;
  a1[18] = a6;
  a1[19] = a7;
  v12 = (__int64 (__fastcall *)(_QWORD *, _QWORD *, __int64 *, __int64, _QWORD, char *, _QWORD, _QWORD))v10[5];
  a1[22] = a2;
  if ( !v11 )
    v12 = (__int64 (__fastcall *)(_QWORD *, _QWORD *, __int64 *, __int64, _QWORD, char *, _QWORD, _QWORD))(__readfsqword(0x30u) ^ __ROR8__(v12, 17));
  dl_mcount_wrapper_check((__int64)v12);
  v13 = v12(v10, a1 + 18, v17, a4, 0LL, v16, 0LL, 0LL);
  *a5 = v17[0];
  *a8 = a1[18];
  if ( v13 == 4 )
  {
    return 0;
  }
  else if ( v13 <= 4 )
  {
    return 2 * (unsigned int)(v13 != 0);
  }
  else
  {
    v14 = 1;
    if ( v13 != 5 )
      return (unsigned int)(v13 != 7) + 1;
  }
  return v14;
}
// 461880: using guessed type char var_50[8];

//----- (0000000000461990) ----------------------------------------------------
__int64 __fastcall do_length(_QWORD *a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5)
{
  __int64 v5; // r8
  __int64 *v8; // rcx
  _QWORD *v9; // r13
  bool v10; // zf
  void (__fastcall *v11)(_QWORD *, _QWORD *, __int64 *, __int64, _QWORD, char *, _QWORD, _QWORD); // rbx
  void *v13; // rsp
  _BYTE v15[4088]; // [rsp+8h] [rbp-1050h] BYREF
  __int64 v16; // [rsp+1008h] [rbp-50h] BYREF
  __int64 v17; // [rsp+1010h] [rbp-48h] BYREF
  char v18[8]; // [rsp+1018h] [rbp-40h] BYREF
  unsigned __int64 v19; // [rsp+1020h] [rbp-38h]

  v5 = 4 * a5;
  v19 = __readfsqword(0x28u);
  v17 = a3;
  v8 = (__int64 *)((char *)&v16 - ((v5 + 15) & 0xFFFFFFFFFFFFF000LL));
  if ( &v16 != v8 )
  {
    while ( v15 != (_BYTE *)v8 )
      ;
  }
  if ( (((_WORD)v5 + 15) & 0xFF0) != 0 )
  {
    v13 = alloca(((_WORD)v5 + 15) & 0xFF0);
    *(_QWORD *)&v15[(((_WORD)v5 + 15) & 0xFF0) - 8] = *(_QWORD *)&v15[(((_WORD)v5 + 15) & 0xFF0) - 8];
  }
  v9 = (_QWORD *)a1[9];
  a1[14] = a2;
  a1[10] = v15;
  v10 = *v9 == 0LL;
  v11 = (void (__fastcall *)(_QWORD *, _QWORD *, __int64 *, __int64, _QWORD, char *, _QWORD, _QWORD))v9[5];
  a1[11] = &v15[v5];
  if ( !v10 )
    v11 = (void (__fastcall *)(_QWORD *, _QWORD *, __int64 *, __int64, _QWORD, char *, _QWORD, _QWORD))(__readfsqword(0x30u) ^ __ROR8__(v11, 17));
  dl_mcount_wrapper_check((__int64)v11);
  v11(v9, a1 + 10, &v17, a4, 0LL, v18, 0LL, 0LL);
  return v17 - a3;
}
// 461990: using guessed type char var_40[8];

//----- (0000000000461AA0) ----------------------------------------------------
__int64 __fastcall IO_fwide(__int64 a1, __int64 a2, __int64 a3, __int64 a4, u32 *a5, __int64 a6)
{
  __int64 result; // rax
  __int64 v7; // rbx
  __int64 v8; // rax
  __int64 v9; // rax
  __int64 v10; // rcx
  __int64 v11; // rax
  __int64 v12; // rax
  __int64 v13; // rdx
  __int64 v14; // rax
  __m128i v15; // [rsp+0h] [rbp-48h] BYREF
  __int64 v16; // [rsp+10h] [rbp-38h]
  __int64 v17; // [rsp+18h] [rbp-30h]
  unsigned __int64 v18; // [rsp+28h] [rbp-20h]

  v18 = __readfsqword(0x28u);
  result = *(unsigned int *)(a1 + 192);
  if ( (int)a2 < 0 )
  {
    if ( (_DWORD)result )
      return result;
    result = 0xFFFFFFFFLL;
LABEL_7:
    *(_DWORD *)(a1 + 192) = result;
    return result;
  }
  if ( !(_DWORD)result && (_DWORD)a2 )
  {
    v7 = *(_QWORD *)(a1 + 160);
    v8 = *(_QWORD *)(v7 + 8);
    *(_QWORD *)(a1 + 152) = v7 + 104;
    *(_QWORD *)v7 = v8;
    v9 = *(_QWORD *)(v7 + 24);
    *(_QWORD *)(v7 + 88) = 0LL;
    *(_QWORD *)(v7 + 32) = v9;
    *(_QWORD *)(*(_QWORD *)(a1 + 160) + 96LL) = 0LL;
    _wcsmbs_clone_conv(&v15, a2, a3, a4, a5, a6);
    if ( v15.m128i_i64[1] != 1 )
      _assert_fail((__int64)"fcts.towc_nsteps == 1", (__int64)"iofwide.c", 0x77u, "_IO_fwide");
    if ( v17 != 1 )
      _assert_fail((__int64)"fcts.tomb_nsteps == 1", (__int64)"iofwide.c", 0x78u, "_IO_fwide");
    memset((void *)(v7 + 104), 0, 0xC0uLL);
    v10 = v16;
    *(_QWORD *)(v7 + 168) = 1LL;
    *(_QWORD *)(v7 + 112) = do_out;
    *(_QWORD *)(v7 + 120) = do_unshift;
    *(_QWORD *)(v7 + 128) = do_in;
    *(_QWORD *)(v7 + 136) = do_encoding;
    *(_QWORD *)(v7 + 144) = do_always_noconv;
    *(_QWORD *)(v7 + 152) = do_length;
    *(_QWORD *)(v7 + 160) = do_max_length;
    v11 = v15.m128i_i64[0];
    *(_DWORD *)(v7 + 208) = 1;
    *(_QWORD *)(v7 + 176) = v11;
    v12 = *(_QWORD *)(a1 + 160);
    *(_DWORD *)(v7 + 200) = 1;
    v13 = v12 + 88;
    v14 = *(_QWORD *)(v12 + 304);
    *(_QWORD *)(v7 + 232) = 1LL;
    *(_QWORD *)(v7 + 216) = v13;
    *(_QWORD *)(v7 + 240) = v10;
    *(_DWORD *)(v7 + 272) = 1;
    *(_DWORD *)(v7 + 264) = 9;
    *(_QWORD *)(v7 + 280) = v13;
    *(_QWORD *)(a1 + 216) = v14;
    result = 1LL;
    goto LABEL_7;
  }
  return result;
}
// 461670: using guessed type __int64 __fastcall do_always_noconv();

//----- (0000000000461CA0) ----------------------------------------------------
int _libc_enable_asynccancel()
{
  __int64 v0; // rax
  signed __int32 v1; // er11
  int v2; // ett

  LODWORD(v0) = __readfsdword(0x308u);
  while ( 1 )
  {
    v1 = v0 | 2;
    if ( ((unsigned int)v0 | 2) == (_DWORD)v0 )
      break;
    v2 = v0;
    LODWORD(v0) = _InterlockedCompareExchange(MK_FP(__FS__, 776LL), v1, v0);
    if ( v2 == (_DWORD)v0 )
    {
      if ( (v1 & 0xFFFFFFBB) == 10 )
      {
        __writefsqword(0x630u, 0xFFFFFFFFFFFFFFFFLL);
        _InterlockedOr(MK_FP(__FS__, 776LL), 0x10u);
        MEMORY[0](__readfsqword(0x300u));
        __halt();
      }
      return v0;
    }
  }
  return v0;
}

//----- (0000000000461D00) ----------------------------------------------------
void __fastcall _libc_disable_asynccancel(char a1, __int64 a2, u32 a3, __int64 a4, u32 *a5, u32 a6)
{
  char v7; // r11
  char i; // al
  signed __int64 v9; // rax

  if ( (a1 & 2) == 0 )
  {
    _InterlockedAnd(MK_FP(__FS__, 776LL), 0xFFFFFFFD);
    for ( i = v7; (i & 0xC) == 4; i = __readfsdword(0x308u) )
      v9 = sys_futex((u32 *)(__readfsqword(0) + 776), 128, a3, 0LL, a5, a6);
  }
}
// 461D28: variable 'v7' is possibly undefined
// 461D51: variable 'a3' is possibly undefined
// 461D51: variable 'a5' is possibly undefined
// 461D51: variable 'a6' is possibly undefined

//----- (0000000000461D60) ----------------------------------------------------
__int64 __fastcall _libc_scratch_buffer_grow_preserve(
        __int64 *a1,
        __int64 a2,
        _QWORD *a3,
        __int64 *a4,
        u32 *a5,
        unsigned __int64 a6)
{
  unsigned __int64 v6; // r13
  __int64 v7; // r12
  unsigned __int64 v8; // rbp
  __int64 result; // rax
  _QWORD *v10; // rcx

  v6 = a1[1];
  v7 = *a1;
  v8 = 2 * v6;
  if ( (__int64 *)*a1 != a1 + 2 )
  {
    if ( v6 > v8 )
    {
      __writefsdword(0xFFFFFFC0, 0xCu);
    }
    else
    {
      a2 = 2 * v6;
      a4 = realloc(*a1, 2 * v6, a3, (__int64)a4, a5, a6);
      if ( a4 )
      {
LABEL_4:
        *a1 = (__int64)a4;
        result = 1LL;
        a1[1] = v8;
        return result;
      }
      v7 = *a1;
    }
    free(v7, a2, (__int64)a3, (__int64)a4, a5, a6);
    *a1 = (__int64)(a1 + 2);
    result = 0LL;
    a1[1] = 1024LL;
    return result;
  }
  v10 = malloc(2 * v6, a2, a3, (__int64)a4, a5, a6);
  result = 0LL;
  if ( v10 )
  {
    a4 = (__int64 *)j_memcpy(v10, v7, v6);
    goto LABEL_4;
  }
  return result;
}
// 461DF1: variable 'a3' is possibly undefined
// 461DF1: variable 'a5' is possibly undefined
// 461DF1: variable 'a6' is possibly undefined
// 401040: using guessed type __int64 __fastcall j_memcpy(_QWORD, _QWORD, _QWORD);

//----- (0000000000461E10) ----------------------------------------------------
__int64 __fastcall _libc_scratch_buffer_set_array_size(
        __int64 *a1,
        unsigned __int64 a2,
        __int64 a3,
        __int64 a4,
        u32 *a5,
        unsigned __int64 a6)
{
  unsigned __int64 v6; // rbp
  __int64 result; // rax
  __int64 v9; // rdi
  __int64 *v10; // rdi

  v6 = a3 * a2;
  if ( (a3 | a2) >> 32 && a2 && (a4 = a3, a3 = v6 % a2, v6 / a2 != a4) )
  {
    v10 = (__int64 *)*a1;
    if ( v10 != a1 + 2 )
      free((__int64)v10, a2, a3, a4, a5, a6);
    *a1 = (__int64)(a1 + 2);
    a1[1] = 1024LL;
    __writefsdword(0xFFFFFFC0, 0xCu);
    return 0LL;
  }
  else
  {
    result = 1LL;
    if ( a1[1] < v6 )
    {
      v9 = *a1;
      if ( (__int64 *)*a1 != a1 + 2 )
        free(v9, a2, a3, a4, a5, a6);
      result = (__int64)malloc(v6, a2, (_QWORD *)a3, a4, a5, a6);
      if ( result )
      {
        a1[1] = v6;
        *a1 = result;
        return 1LL;
      }
      else
      {
        *a1 = (__int64)(a1 + 2);
        a1[1] = 1024LL;
      }
    }
  }
  return result;
}
// 461E52: variable 'a3' is possibly undefined
// 461E52: variable 'a4' is possibly undefined
// 461E52: variable 'a5' is possibly undefined
// 461E52: variable 'a6' is possibly undefined

//----- (0000000000461ED0) ----------------------------------------------------
__int64 __fastcall strndup(__int64 a1, __int64 a2)
{
  __int64 v2; // rbx
  _QWORD *v3; // rdx
  __int64 v4; // rcx
  u32 *v5; // r8
  __int64 v6; // r9
  _QWORD *v7; // rax

  v2 = j_strnlen(a1, a2);
  v7 = malloc(v2 + 1, a2, v3, v4, v5, v6);
  if ( !v7 )
    return 0LL;
  *((_BYTE *)v7 + v2) = 0;
  return j_memcpy(v7, a1, v2);
}
// 461EE9: variable 'v3' is possibly undefined
// 461EE9: variable 'v4' is possibly undefined
// 461EE9: variable 'v5' is possibly undefined
// 461EE9: variable 'v6' is possibly undefined
// 401028: using guessed type __int64 __fastcall j_strnlen(_QWORD, _QWORD);
// 401040: using guessed type __int64 __fastcall j_memcpy(_QWORD, _QWORD, _QWORD);

//----- (0000000000461F20) ----------------------------------------------------
unsigned __int8 *__fastcall strerror_r(int a1, __int64 a2, unsigned __int64 a3)
{
  unsigned __int8 *v5; // rsi
  unsigned __int8 *v7; // r15
  unsigned __int64 v8; // r13
  __int64 v9; // rax
  unsigned __int64 v10; // rdx
  __int64 v11; // rbx
  __int64 v12; // rax
  _BYTE *v13; // rdx
  unsigned __int64 v14; // r13
  __int64 v15; // rax
  _BYTE *v16; // rdx
  unsigned __int8 *v17; // r15
  __int64 v18; // rax
  unsigned __int64 v19; // rdx
  char v20; // [rsp+14h] [rbp-44h] BYREF
  _BYTE v21[67]; // [rsp+15h] [rbp-43h] BYREF

  *(_QWORD *)&v21[3] = __readfsqword(0x28u);
  if ( a1 >= 0 )
  {
    if ( sys_nerr > a1 )
    {
      v5 = (unsigned __int8 *)sys_errlist[a1];
      if ( v5 )
        return dcgettext("libc", v5, 5u);
    }
    v17 = dcgettext("libc", "Unknown error ", 5u);
    v14 = j_strlen_ifunc(v17);
    v20 = 0;
    v18 = itoa_word(a1, (__int64)&v20, 0xAu, 0);
    v19 = v14;
    if ( a3 <= v14 )
      v19 = a3;
    v11 = v18;
    v15 = j_mempcpy(a2, v17, v19);
    if ( a3 <= v14 )
    {
LABEL_17:
      if ( !a3 )
        return (unsigned __int8 *)a2;
      goto LABEL_12;
    }
LABEL_9:
    v16 = (_BYTE *)(a3 - v14);
    if ( a3 - v14 > (unsigned __int64)&v21[-v11] )
      v16 = &v21[-v11];
    j_memcpy(v15, v11, v16);
    goto LABEL_12;
  }
  v7 = dcgettext("libc", "Unknown error ", 5u);
  v8 = j_strlen_ifunc(v7);
  v20 = 0;
  v9 = itoa_word(-a1, (__int64)&v20, 0xAu, 0);
  v10 = a3;
  if ( v8 <= a3 )
    v10 = v8;
  v11 = v9;
  v12 = j_mempcpy(a2, v7, v10);
  v13 = (_BYTE *)v12;
  if ( v8 >= a3 )
    goto LABEL_17;
  v14 = v8 + 1;
  v15 = v12 + 1;
  *v13 = 45;
  if ( a3 > v14 )
    goto LABEL_9;
LABEL_12:
  *(_BYTE *)(a2 + a3 - 1) = 0;
  return (unsigned __int8 *)a2;
}
// 401040: using guessed type __int64 __fastcall j_memcpy(_QWORD, _QWORD, _QWORD);
// 4010B0: using guessed type __int64 __fastcall j_mempcpy(_QWORD, _QWORD, _QWORD);
// 4010C8: using guessed type __int64 __fastcall j_strlen_ifunc(_QWORD);
// 4983C8: using guessed type int sys_nerr;

//----- (00000000004620C0) ----------------------------------------------------
char *(__fastcall *strnlen())(__int64 a1, __int64 a2)
{
  char *(__fastcall *result)(__int64, __int64); // rax

  result = _strnlen_sse2;
  if ( (dword_4AAE4C & 0x20C00) == 3072 )
    return (char *(__fastcall *)(__int64, __int64))_strnlen_avx2;
  return result;
}
// 4AAE4C: using guessed type int dword_4AAE4C;

//----- (00000000004620F0) ----------------------------------------------------
__int64 (__fastcall *strrchr_ifunc())(__int64 _RDI, unsigned __int64 a2)
{
  __int64 (__fastcall *result)(__int64, unsigned __int64); // rax

  result = (__int64 (__fastcall *)(__int64, unsigned __int64))_strrchr_sse2;
  if ( (dword_4AAE4C & 0x20C00) == 3072 )
    return _strrchr_avx2;
  return result;
}
// 4AAE4C: using guessed type int dword_4AAE4C;

//----- (0000000000462120) ----------------------------------------------------
_BYTE *__fastcall strtok_r(_BYTE *a1, __int64 a2, _BYTE **a3)
{
  _BYTE *v4; // rbx
  _BYTE *v5; // rax

  v4 = a1;
  if ( !a1 )
    v4 = *a3;
  if ( *v4 && (v4 += j_strspn_ifunc(v4, a2), *v4) )
  {
    v5 = &v4[j_strcspn_ifunc(v4, a2)];
    if ( *v5 )
      *v5++ = 0;
    *a3 = v5;
    return v4;
  }
  else
  {
    *a3 = v4;
    return 0LL;
  }
}
// 4010B8: using guessed type __int64 __fastcall j_strcspn_ifunc(_QWORD, _QWORD);
// 4010C0: using guessed type __int64 __fastcall j_strspn_ifunc(_QWORD, _QWORD);

//----- (00000000004621A0) ----------------------------------------------------
__int64 (__fastcall *memchr_ifunc())(const __m128i *a1, unsigned int a2, unsigned __int64 a3)
{
  __int64 (__fastcall *result)(const __m128i *, unsigned int, unsigned __int64); // rax

  result = _memchr_sse2;
  if ( (dword_4AAE4C & 0x20C00) == 3072 )
    return (__int64 (__fastcall *)(const __m128i *, unsigned int, unsigned __int64))_memchr_avx2;
  return result;
}
// 4AAE4C: using guessed type int dword_4AAE4C;

//----- (00000000004621D0) ----------------------------------------------------
unsigned __int64 __fastcall critical_factorization_0(__int64 a1, unsigned __int64 a2, __int64 *a3)
{
  __int64 v3; // r11
  __int64 v4; // r8
  __int64 v5; // r9
  __int64 v6; // rax
  unsigned __int64 v7; // rcx
  unsigned __int8 v8; // bl
  unsigned __int64 v9; // r11
  __int64 v10; // rbx
  __int64 v11; // r8
  __int64 v12; // r9
  __int64 v13; // r10
  unsigned __int64 v14; // rcx
  unsigned __int8 v15; // r11
  unsigned __int64 v16; // rbx
  unsigned __int64 v17; // r10
  unsigned __int64 result; // rax

  v3 = 1LL;
  v4 = 1LL;
  v5 = 0LL;
  v6 = -1LL;
  while ( 1 )
  {
    v7 = v5 + v4;
    if ( v5 + v4 >= a2 )
      break;
    while ( 1 )
    {
      v8 = *(_BYTE *)(a1 + v6 + v4);
      if ( *(_BYTE *)(a1 + v7) >= v8 )
        break;
      v5 = v7;
      v4 = 1LL;
      v9 = v7++;
      v3 = v9 - v6;
      if ( v7 >= a2 )
        goto LABEL_5;
    }
    if ( *(_BYTE *)(a1 + v7) == v8 )
    {
      if ( v4 == v3 )
      {
        v5 = v7;
        v4 = 1LL;
      }
      else
      {
        ++v4;
      }
    }
    else
    {
      v6 = v5;
      v3 = 1LL;
      ++v5;
      v4 = 1LL;
    }
  }
LABEL_5:
  *a3 = v3;
  v10 = 1LL;
  v11 = 1LL;
  v12 = 0LL;
  v13 = -1LL;
  while ( 1 )
  {
    v14 = v12 + v11;
    if ( v12 + v11 >= a2 )
      break;
    while ( 1 )
    {
      v15 = *(_BYTE *)(a1 + v13 + v11);
      if ( *(_BYTE *)(a1 + v14) <= v15 )
        break;
      v12 = v14;
      v11 = 1LL;
      v16 = v14++;
      v10 = v16 - v13;
      if ( v14 >= a2 )
        goto LABEL_9;
    }
    if ( *(_BYTE *)(a1 + v14) == v15 )
    {
      if ( v11 == v10 )
      {
        v12 = v14;
        v11 = 1LL;
      }
      else
      {
        ++v11;
      }
    }
    else
    {
      v13 = v12;
      v10 = 1LL;
      ++v12;
      v11 = 1LL;
    }
  }
LABEL_9:
  v17 = v13 + 1;
  result = v6 + 1;
  if ( v17 >= result )
  {
    *a3 = v10;
    return v17;
  }
  return result;
}

//----- (0000000000462300) ----------------------------------------------------
__int64 __fastcall two_way_long_needle_0(__int64 a1, __int64 a2, __int64 a3, unsigned __int64 a4)
{
  unsigned __int64 v8; // r15
  char *v9; // rax
  unsigned __int64 v10; // rbp
  unsigned __int8 *v11; // rax
  __int64 v12; // rdx
  __int64 v13; // rcx
  unsigned __int64 v14; // rsi
  unsigned __int64 v15; // rcx
  unsigned __int64 v16; // r14
  unsigned __int64 v17; // rax
  __int64 v18; // rdx
  unsigned __int64 v19; // r11
  __int64 result; // rax
  unsigned __int64 v21; // rax
  _BYTE *v22; // rdi
  unsigned __int64 v23; // rdx
  unsigned __int64 v24; // r14
  __int64 v25; // rcx
  __int64 v26; // rcx
  char v27; // si
  unsigned __int64 v28; // [rsp+8h] [rbp-870h]
  unsigned __int64 v29; // [rsp+8h] [rbp-870h]
  unsigned __int64 v30; // [rsp+28h] [rbp-850h] BYREF
  __int64 v31[256]; // [rsp+30h] [rbp-848h] BYREF
  char v32; // [rsp+830h] [rbp-48h] BYREF
  unsigned __int64 v33; // [rsp+838h] [rbp-40h]

  v33 = __readfsqword(0x28u);
  v8 = critical_factorization_0(a3, a4, (__int64 *)&v30);
  v9 = (char *)v31;
  do
  {
    *(_QWORD *)v9 = a4;
    v9 += 8;
  }
  while ( v9 != &v32 );
  v10 = a4 - 1;
  v11 = (unsigned __int8 *)a3;
  if ( a4 )
  {
    do
    {
      v12 = *v11;
      v13 = a3 + a4 - 1 - (_QWORD)v11++;
      v31[v12] = v13;
    }
    while ( v11 != (unsigned __int8 *)(a4 + a3) );
  }
  v28 = v30;
  if ( !(unsigned int)j_memcmp_ifunc(a3, a3 + v30, v8) )
  {
    v14 = 0LL;
    v15 = 0LL;
    v16 = a2 - a4;
    while ( 1 )
    {
      while ( 1 )
      {
        v18 = a1 + v15;
        v17 = v31[*(unsigned __int8 *)(a1 + v15 + v10)];
        if ( v17 )
        {
          if ( v14 && v28 > v17 )
            v17 = a4 - v28;
          goto LABEL_10;
        }
        v17 = v8;
        if ( v14 >= v8 )
          v17 = v14;
        if ( v17 < v10 )
          break;
LABEL_19:
        v19 = v8 - 1;
        if ( v14 < v8 && *(_BYTE *)(a1 + v8 - 1 + v15) == *(_BYTE *)(a3 + v8 - 1) )
        {
          while ( v14 != v19 && *(_BYTE *)(a3 + v19 - 1) == *(_BYTE *)(v19 + a1 + v15 - 1) )
            --v19;
          v18 = a1 + v15;
        }
        else
        {
          v19 = v8;
        }
        if ( v14 + 1 > v19 )
          return v18;
        v15 += v28;
        v14 = a4 - v28;
        if ( v16 < v15 )
          return 0LL;
      }
      if ( *(_BYTE *)(a1 + v17 + v15) == *(_BYTE *)(a3 + v17) )
      {
        while ( ++v17 < v10 )
        {
          if ( *(_BYTE *)(a3 + v17) != *(_BYTE *)(v18 + v17) )
            goto LABEL_30;
        }
        goto LABEL_19;
      }
LABEL_30:
      v15 += 1 - v8;
LABEL_10:
      v15 += v17;
      v14 = 0LL;
      if ( v16 < v15 )
        return 0LL;
    }
  }
  v21 = a4 - v8;
  v22 = (_BYTE *)(a3 + v8 - 1);
  if ( a4 - v8 < v8 )
    v21 = v8;
  v23 = 0LL;
  v24 = a2 - a4;
  v29 = v21 + 1;
  while ( 1 )
  {
    result = a1 + v23;
    v25 = v31[*(unsigned __int8 *)(a1 + v23 + v10)];
    if ( !v25 )
      break;
LABEL_34:
    v23 += v25;
LABEL_35:
    if ( v23 > v24 )
      return 0LL;
  }
  if ( v8 >= v10 )
    goto LABEL_42;
  v25 = v8;
  if ( *(_BYTE *)(a3 + v8) != *(_BYTE *)(a1 + v23 + v8) )
  {
LABEL_47:
    v23 += 1 - v8;
    goto LABEL_34;
  }
  while ( ++v25 < v10 )
  {
    if ( *(_BYTE *)(a3 + v25) != *(_BYTE *)(result + v25) )
      goto LABEL_47;
  }
LABEL_42:
  if ( !v8 )
    return result;
  v26 = -1LL;
  if ( *(_BYTE *)(a1 + v23 + v8 - 1) != *v22 )
  {
LABEL_46:
    v23 += v29;
    goto LABEL_35;
  }
  while ( -(__int64)v8 != v26 )
  {
    v27 = v22[v26--];
    if ( v27 != *(_BYTE *)(a1 + v23 + v8 + v26) )
      goto LABEL_46;
  }
  return result;
}
// 401080: using guessed type __int64 __fastcall j_memcmp_ifunc(_QWORD, _QWORD, _QWORD);
// 462300: using guessed type __int64 var_848[256];

//----- (00000000004625F0) ----------------------------------------------------
__int64 __fastcall memmem(__int64 a1, unsigned __int64 a2, unsigned __int8 *a3, unsigned __int64 a4)
{
  __int64 result; // rax
  __int64 v7; // r15
  unsigned __int64 v8; // rbx
  unsigned __int64 v9; // rax
  __int64 v10; // rbp
  int v11; // eax
  unsigned __int64 v12; // r9
  unsigned __int64 v13; // rax
  unsigned __int64 v14; // rdi
  unsigned __int64 v15; // rbx
  unsigned __int64 v16; // rdx
  unsigned __int64 v17; // rsi
  unsigned __int8 v18; // r12
  unsigned __int64 v19; // rax
  unsigned __int64 v20; // rbx
  unsigned __int64 v21; // rdx
  unsigned int v22; // eax
  unsigned __int64 v23; // r12
  unsigned __int8 *v24; // r13
  unsigned __int8 *v25; // rbp
  unsigned __int64 v26; // r14
  _BYTE *v27; // rax
  _BYTE *v28; // rdi
  __int64 v29; // rax
  unsigned __int64 v30; // rcx
  _BYTE *v31; // rdi
  _BYTE *v32; // rcx
  __int64 v33; // rax
  unsigned __int8 v34; // si
  unsigned __int64 v35; // [rsp+8h] [rbp-80h]
  unsigned __int8 v36; // [rsp+8h] [rbp-80h]
  unsigned __int64 v37; // [rsp+10h] [rbp-78h]
  unsigned int v38; // [rsp+1Ch] [rbp-6Ch]
  unsigned __int64 v39; // [rsp+20h] [rbp-68h]
  unsigned __int64 v40; // [rsp+28h] [rbp-60h]
  unsigned __int64 v41; // [rsp+30h] [rbp-58h]
  __int64 v42; // [rsp+38h] [rbp-50h]
  __int64 v43[9]; // [rsp+40h] [rbp-48h] BYREF

  v43[1] = __readfsqword(0x28u);
  result = a1;
  if ( a4 )
  {
    if ( a4 > a2 )
    {
      return 0LL;
    }
    else
    {
      if ( a4 > 0x1F )
        return two_way_long_needle_0(a1, a2, (__int64)a3, a4);
      result = j_memchr_ifunc(a1, *a3, a2);
      v7 = result;
      if ( result )
      {
        if ( a4 != 1 )
        {
          v8 = a2 - (result - a1);
          result = 0LL;
          if ( a4 <= v8 )
          {
            v9 = critical_factorization_0((__int64)a3, a4, v43);
            v10 = v43[0];
            v35 = v9;
            v11 = j_memcmp_ifunc(a3, &a3[v43[0]], v9);
            v12 = v35;
            if ( !v11 )
            {
              v13 = 0LL;
              v14 = 0LL;
              v15 = v8 - a4;
              while ( 1 )
              {
                v16 = v14;
                if ( v35 >= v14 )
                  v16 = v35;
                if ( a4 > v16 )
                {
                  if ( a3[v16] != *(_BYTE *)(v7 + v16 + v13) )
                  {
LABEL_28:
                    v14 = 0LL;
                    v13 += v16 + 1 - v35;
                    goto LABEL_24;
                  }
                  while ( a4 != ++v16 )
                  {
                    if ( a3[v16] != *(_BYTE *)(v7 + v13 + v16) )
                      goto LABEL_28;
                  }
                }
                v17 = v35 - 1;
                if ( v35 > v14 && *(_BYTE *)(v7 + v35 - 1 + v13) == a3[v35 - 1] )
                {
                  while ( v17 != v14 && a3[v17 - 1] == *(_BYTE *)(v17 + v7 + v13 - 1) )
                    --v17;
                }
                else
                {
                  v17 = v35;
                }
                if ( v17 < v14 + 1 )
                  return v7 + v13;
                v14 = a4 - v10;
                v13 += v10;
LABEL_24:
                if ( v15 < v13 )
                  return 0LL;
              }
            }
            v18 = a3[v35];
            v19 = a4 - v35;
            v36 = v18;
            if ( a4 - v12 < v12 )
              v19 = v12;
            v20 = v8 - a4;
            v21 = 0LL;
            v41 = v19 + 1;
            v22 = v18;
            v23 = a4;
            v24 = a3;
            v38 = v22;
            v39 = v7 + v12;
            v25 = &a3[v12 - 1];
            v40 = v12 - 1;
            v26 = v12;
            v42 = -(__int64)v12;
            v37 = 1 - v12;
            while ( 1 )
            {
              v27 = (_BYTE *)(v7 + v26 + v21);
              v28 = v27 + 1;
              if ( v36 != *v27 )
              {
                v29 = j_memchr_ifunc(v28, v38, v20 - v21);
                if ( !v29 )
                  return 0LL;
                v28 = (_BYTE *)(v29 + 1);
                v21 = v29 - v39;
              }
              v30 = v26 + 1;
              if ( v23 > v26 + 1 )
              {
                if ( v24[v26 + 1] != *v28 )
                {
LABEL_46:
                  v21 += v30 + v37;
                  goto LABEL_47;
                }
                v31 = &v28[-v26];
                while ( v23 != ++v30 )
                {
                  if ( v24[v30] != v31[v30 - 1] )
                    goto LABEL_46;
                }
              }
              v32 = (_BYTE *)(v7 + v40 + v21);
              if ( v40 == -1LL )
                return v7 + v21;
              if ( *v25 == *v32 )
              {
                v33 = -1LL;
                while ( v33 != v42 )
                {
                  v34 = v25[v33--];
                  if ( v34 != v32[v33 + 1] )
                    goto LABEL_49;
                }
                return v7 + v21;
              }
LABEL_49:
              v21 += v41;
LABEL_47:
              if ( v20 < v21 )
                return 0LL;
            }
          }
        }
      }
    }
  }
  return result;
}
// 401068: using guessed type __int64 __fastcall j_memchr_ifunc(_QWORD, _QWORD, _QWORD);
// 401080: using guessed type __int64 __fastcall j_memcmp_ifunc(_QWORD, _QWORD, _QWORD);

//----- (0000000000462920) ----------------------------------------------------
__int64 __fastcall argz_create_sep(char *a1, __int64 a2, unsigned __int64 *a3, __int64 *a4)
{
  char *v6; // rbx
  __int64 v7; // rax
  _QWORD *v8; // rdx
  __int64 v9; // rcx
  u32 *v10; // r8
  __int64 v11; // r9
  __int64 v12; // rbp
  __int64 result; // rax
  char *v14; // rax
  unsigned __int64 v15; // r9
  char *v16; // rcx
  u32 *v17; // r8
  char v18; // dl

  v6 = a1;
  v7 = j_strlen_ifunc(a1);
  v12 = v7 + 1;
  if ( !v7 )
  {
    *a3 = 0LL;
    result = 0LL;
    *a4 = 0LL;
    return result;
  }
  v14 = (char *)malloc(v7 + 1, a2, v8, v9, v10, v11);
  *a3 = (unsigned __int64)v14;
  if ( !v14 )
    return 12LL;
  v16 = v14;
  do
  {
    while ( 1 )
    {
      v17 = (u32 *)(unsigned int)*v6;
      v18 = *v6;
      if ( (_DWORD)v17 == (_DWORD)a2 )
        break;
      *v16++ = *v6;
LABEL_6:
      ++v6;
      if ( !v18 )
        goto LABEL_11;
    }
    if ( v14 >= v16 || !*(v16 - 1) )
    {
      --v12;
      goto LABEL_6;
    }
    *v16 = 0;
    ++v6;
    ++v16;
  }
  while ( v18 );
LABEL_11:
  if ( !v12 )
  {
    free((__int64)v14, a2, (unsigned int)v17, (__int64)v16, v17, v15);
    *a3 = 0LL;
  }
  *a4 = v12;
  return 0LL;
}
// 46296B: variable 'v8' is possibly undefined
// 46296B: variable 'v9' is possibly undefined
// 46296B: variable 'v10' is possibly undefined
// 46296B: variable 'v11' is possibly undefined
// 4629E3: variable 'v15' is possibly undefined
// 4010C8: using guessed type __int64 __fastcall j_strlen_ifunc(_QWORD);

//----- (0000000000462A10) ----------------------------------------------------
__int64 __fastcall argz_add_sep(__int64 *a1, _QWORD *a2, char *a3, int a4)
{
  char *v7; // rbx
  _QWORD *v8; // rdx
  __int64 v9; // rcx
  u32 *v10; // r8
  unsigned __int64 v11; // r9
  __int64 v12; // r12
  __int64 result; // rax
  __int64 *v14; // rax
  _BYTE *v15; // rdx
  char v16; // si
  int v17; // edi
  char v18; // si

  v7 = a3;
  v12 = j_strlen_ifunc(a3) + 1;
  result = 0LL;
  if ( v12 != 1 )
  {
    v14 = realloc(*a1, v12 + *a2, v8, v9, v10, v11);
    *a1 = (__int64)v14;
    if ( v14 )
    {
      v15 = (char *)v14 + *a2;
      while ( 1 )
      {
        while ( 1 )
        {
          v17 = *v7;
          v16 = *v7;
          if ( v17 == a4 )
            break;
          *v15 = v17;
          v16 = *v7;
          ++v15;
LABEL_5:
          ++v7;
          if ( !v16 )
            goto LABEL_10;
        }
        if ( *a1 >= (unsigned __int64)v15 || !*(v15 - 1) )
        {
          --v12;
          goto LABEL_5;
        }
        *v15 = 0;
        v18 = *v7;
        ++v15;
        ++v7;
        if ( !v18 )
        {
LABEL_10:
          *a2 += v12;
          return 0LL;
        }
      }
    }
    return 12LL;
  }
  return result;
}
// 462A52: variable 'v8' is possibly undefined
// 462A52: variable 'v9' is possibly undefined
// 462A52: variable 'v10' is possibly undefined
// 462A52: variable 'v11' is possibly undefined
// 4010C8: using guessed type __int64 __fastcall j_strlen_ifunc(_QWORD);

//----- (0000000000462AE0) ----------------------------------------------------
__int64 __fastcall _memchr_sse2(const __m128i *a1, unsigned int a2, unsigned __int64 a3)
{
  __m128i v3; // xmm1
  __m128i v4; // xmm1
  unsigned int v5; // ecx
  __m128i v6; // xmm1
  unsigned __int64 v7; // rax
  char v8; // cc
  unsigned __int64 v9; // rdx
  unsigned __int64 v10; // rdx
  unsigned __int64 v11; // rdx
  __int64 v12; // rcx
  const __m128i *v13; // rdi
  unsigned __int64 v14; // rax
  unsigned __int64 v16; // rcx
  unsigned __int64 v17; // rdx
  __int64 v18; // rax
  __int64 v19; // rax
  __int64 v20; // rax
  __m128i v21; // xmm4
  __int64 v22; // rax
  char v23; // cl
  __m128i v24; // xmm0
  __m128i v25; // xmm2
  int v26; // eax
  __m128i v27; // xmm3
  __m128i v28; // xmm1
  __int64 v29; // rax
  unsigned __int64 v30; // rdx
  unsigned __int64 v31; // rax
  unsigned __int64 v32; // rdx
  unsigned __int64 v33; // rax
  unsigned __int64 v34; // rdx
  unsigned __int64 v35; // rax

  v3 = _mm_cvtsi32_si128(a2);
  v4 = _mm_unpacklo_epi8(v3, v3);
  if ( !a3 )
    return 0LL;
  v5 = (unsigned __int8)a1 & 0x3F;
  v6 = _mm_shuffle_epi32(_mm_unpacklo_epi8(v4, v4), 0);
  if ( v5 <= 0x30 )
  {
    LODWORD(v7) = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_loadu_si128(a1), v6));
    if ( (_DWORD)v7 )
      goto LABEL_44;
    v8 = a3 <= 0x10;
    v9 = a3 - 16;
    if ( v8 )
      return 0LL;
    a1 = (const __m128i *)((unsigned __int64)&a1[1] & 0xFFFFFFFFFFFFFFF0LL);
    v10 = (v5 & 0xF) + v9;
    v8 = v10 <= 0x40;
    v11 = v10 - 64;
    if ( v8 )
      goto LABEL_29;
    goto LABEL_12;
  }
  v12 = (unsigned __int8)a1 & 0xF;
  v13 = (const __m128i *)((unsigned __int64)a1 & 0xFFFFFFFFFFFFFFF0LL);
  LODWORD(v14) = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_load_si128(v13), v6)) >> v12;
  if ( (_DWORD)v14 )
  {
    _BitScanForward((unsigned int *)&v14, v14);
    if ( a3 > v14 )
      return (__int64)v13 + v14 + v12;
    return 0LL;
  }
  v16 = 16 - v12;
  v8 = a3 <= v16;
  v17 = a3 - v16;
  if ( !v8 )
  {
    a1 = v13 + 1;
    v8 = v17 <= 0x40;
    v11 = v17 - 64;
    if ( v8 )
      goto LABEL_29;
LABEL_12:
    LODWORD(v18) = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_load_si128(a1), v6));
    if ( (_DWORD)v18 )
      goto LABEL_41;
    LODWORD(v19) = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_load_si128(a1 + 1), v6));
    if ( (_DWORD)v19 )
      goto LABEL_42;
    LODWORD(v20) = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_load_si128(a1 + 2), v6));
    if ( (_DWORD)v20 )
      goto LABEL_43;
    v21 = _mm_cmpeq_epi8(_mm_load_si128(a1 + 3), v6);
    a1 += 4;
    LODWORD(v22) = _mm_movemask_epi8(v21);
    if ( (_DWORD)v22 )
      goto LABEL_40;
    if ( ((unsigned __int8)a1 & 0x3F) == 0 )
      goto LABEL_23;
    v8 = v11 <= 0x40;
    v11 -= 64LL;
    if ( !v8 )
    {
      LODWORD(v18) = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_load_si128(a1), v6));
      if ( (_DWORD)v18 )
        goto LABEL_41;
      LODWORD(v19) = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_load_si128(a1 + 1), v6));
      if ( (_DWORD)v19 )
        goto LABEL_42;
      LODWORD(v20) = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_load_si128(a1 + 2), v6));
      if ( !(_DWORD)v20 )
      {
        LODWORD(v22) = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_load_si128(a1 + 3), v6));
        a1 += 4;
        if ( !(_DWORD)v22 )
        {
          v23 = (char)a1;
          a1 = (const __m128i *)((unsigned __int64)a1 & 0xFFFFFFFFFFFFFFC0LL);
          v11 += v23 & 0x3F;
LABEL_23:
          while ( 1 )
          {
            v8 = v11 <= 0x40;
            v11 -= 64LL;
            if ( v8 )
              goto LABEL_29;
            v24 = _mm_cmpeq_epi8(_mm_load_si128(a1), v6);
            v25 = _mm_cmpeq_epi8(_mm_load_si128(a1 + 1), v6);
            v26 = _mm_movemask_epi8(
                    _mm_max_epu8(
                      _mm_max_epu8(_mm_cmpeq_epi8(_mm_load_si128(a1 + 3), v6), v25),
                      _mm_max_epu8(_mm_cmpeq_epi8(_mm_load_si128(a1 + 2), v6), v24)));
            a1 += 4;
            if ( v26 )
            {
              a1 -= 4;
              LODWORD(v18) = _mm_movemask_epi8(v24);
              if ( (_DWORD)v18 )
                goto LABEL_41;
              LODWORD(v19) = _mm_movemask_epi8(v25);
              if ( (_DWORD)v19 )
                goto LABEL_42;
              v27 = _mm_cmpeq_epi8(_mm_load_si128(a1 + 2), v6);
              v28 = _mm_cmpeq_epi8(v6, a1[3]);
              LODWORD(v20) = _mm_movemask_epi8(v27);
              if ( (_DWORD)v20 )
                goto LABEL_43;
              _BitScanForward((unsigned int *)&v29, _mm_movemask_epi8(v28));
              return (__int64)&a1[3] + v29;
            }
          }
        }
LABEL_40:
        _BitScanForward((unsigned int *)&v22, v22);
        return (__int64)&a1[-1] + v22;
      }
LABEL_43:
      _BitScanForward((unsigned int *)&v20, v20);
      return (__int64)&a1[2] + v20;
    }
LABEL_29:
    v8 = ((int)v11 + 32 < 0) ^ __OFADD__(32, (_DWORD)v11) | ((_DWORD)v11 == -32);
    v30 = (unsigned int)(v11 + 32);
    if ( !v8 )
    {
      LODWORD(v18) = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_load_si128(a1), v6));
      if ( !(_DWORD)v18 )
      {
        LODWORD(v19) = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_load_si128(a1 + 1), v6));
        if ( !(_DWORD)v19 )
        {
          LODWORD(v31) = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_load_si128(a1 + 2), v6));
          if ( (_DWORD)v31 )
          {
            _BitScanForward((unsigned int *)&v31, v31);
            if ( v30 > v31 )
              return (__int64)&a1[2] + v31;
          }
          else
          {
            v8 = (int)v30 <= 16;
            v32 = (unsigned int)(v30 - 16);
            if ( !v8 )
            {
              LODWORD(v33) = _mm_movemask_epi8(_mm_cmpeq_epi8(v6, a1[3]));
              if ( !(_DWORD)v33 )
                return 0LL;
              _BitScanForward((unsigned int *)&v33, v33);
              if ( v32 > v33 )
                return (__int64)&a1[3] + v33;
            }
          }
          return 0LL;
        }
LABEL_42:
        _BitScanForward((unsigned int *)&v19, v19);
        return (__int64)&a1[1] + v19;
      }
LABEL_41:
      _BitScanForward((unsigned int *)&v18, v18);
      return (__int64)a1 + v18;
    }
    a3 = (unsigned int)(v30 + 32);
    LODWORD(v7) = _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_load_si128(a1), v6));
    if ( !(_DWORD)v7 )
    {
      v8 = (unsigned int)a3 <= 0x10;
      v34 = (unsigned int)(a3 - 16);
      if ( !v8 )
      {
        LODWORD(v35) = _mm_movemask_epi8(_mm_cmpeq_epi8(v6, a1[1]));
        if ( !(_DWORD)v35 )
          return 0LL;
        _BitScanForward((unsigned int *)&v35, v35);
        if ( v34 > v35 )
          return (__int64)&a1[1] + v35;
      }
      return 0LL;
    }
LABEL_44:
    _BitScanForward((unsigned int *)&v7, v7);
    if ( a3 > v7 )
      return (__int64)a1 + v7;
  }
  return 0LL;
}
// 462B5F: variable 'v14' is possibly undefined
// 462CE2: variable 'v29' is possibly undefined
// 462D83: variable 'v22' is possibly undefined
// 462D93: variable 'v18' is possibly undefined
// 462DA3: variable 'v19' is possibly undefined
// 462DB3: variable 'v20' is possibly undefined
// 462DC6: variable 'v7' is possibly undefined
// 462DD6: variable 'v35' is possibly undefined
// 462DE6: variable 'v31' is possibly undefined
// 462DF6: variable 'v33' is possibly undefined

//----- (0000000000462E10) ----------------------------------------------------
unsigned __int64 __fastcall _memchr_avx2(unsigned __int64 a1, int _ESI, unsigned __int64 a3)
{
  unsigned int v6; // ecx
  char v8; // cc
  unsigned __int64 v9; // rdx
  unsigned __int64 v10; // rdx
  unsigned __int64 v11; // rdx
  unsigned __int64 v12; // rcx
  unsigned __int64 v13; // rdi
  unsigned __int64 result; // rax
  unsigned __int64 v17; // rcx
  unsigned __int64 v18; // rdx
  unsigned __int64 v23; // rcx
  unsigned __int64 v32; // rdx
  unsigned __int64 v36; // rdx
  unsigned __int64 v39; // rdx

  if ( !a3 )
    return 0LL;
  __asm
  {
    vmovd   xmm0, esi
    vpbroadcastb ymm0, xmm0
  }
  v6 = a1 & 0x3F;
  if ( v6 <= 0x20 )
  {
    __asm
    {
      vpcmpeqb ymm1, ymm0, ymmword ptr [rdi]
      vpmovmskb eax, ymm1
    }
    if ( (_DWORD)_RAX )
    {
LABEL_31:
      __asm { tzcnt   eax, eax }
      if ( a3 > _RAX )
      {
        result = a1 + _RAX;
        __asm { vzeroupper }
        return result;
      }
      goto LABEL_39;
    }
    v8 = a3 <= 0x20;
    v9 = a3 - 32;
    if ( !v8 )
    {
      a1 = (a1 + 32) & 0xFFFFFFFFFFFFFFE0LL;
      v10 = (v6 & 0x1F) + v9;
      v8 = v10 <= 0x80;
      v11 = v10 - 128;
      if ( v8 )
        goto LABEL_20;
      goto LABEL_12;
    }
    goto LABEL_39;
  }
  v12 = a1 & 0x1F;
  v13 = a1 & 0xFFFFFFFFFFFFFFE0LL;
  __asm
  {
    vpcmpeqb ymm1, ymm0, ymmword ptr [rdi]
    vpmovmskb eax, ymm1
  }
  _RAX = (unsigned int)(_EAX >> v12);
  if ( (_DWORD)_RAX )
  {
    __asm { tzcnt   eax, eax }
    if ( a3 > _RAX )
    {
      result = v12 + v13 + _RAX;
      __asm { vzeroupper }
      return result;
    }
    goto LABEL_39;
  }
  v17 = 32 - v12;
  v8 = a3 <= v17;
  v18 = a3 - v17;
  if ( v8 )
  {
LABEL_39:
    __asm { vzeroupper }
    return 0LL;
  }
  a1 = v13 + 32;
  v8 = v18 <= 0x80;
  v11 = v18 - 128;
  if ( v8 )
    goto LABEL_20;
LABEL_12:
  __asm
  {
    vpcmpeqb ymm1, ymm0, ymmword ptr [rdi]
    vpmovmskb eax, ymm1
  }
  if ( (_DWORD)_RAX )
    goto LABEL_41;
  __asm
  {
    vpcmpeqb ymm1, ymm0, ymmword ptr [rdi+20h]
    vpmovmskb eax, ymm1
  }
  if ( (_DWORD)_RAX )
    goto LABEL_42;
  __asm
  {
    vpcmpeqb ymm1, ymm0, ymmword ptr [rdi+40h]
    vpmovmskb eax, ymm1
  }
  if ( (_DWORD)_RAX )
    goto LABEL_43;
  __asm
  {
    vpcmpeqb ymm1, ymm0, ymmword ptr [rdi+60h]
    vpmovmskb eax, ymm1
  }
  if ( !(_DWORD)_RAX )
  {
    a1 += 128LL;
    v8 = v11 <= 0x80;
    v11 -= 128LL;
    if ( !v8 )
    {
      v23 = a1 & 0x7F;
      a1 &= 0xFFFFFFFFFFFFFF80LL;
      v11 += v23;
      while ( 1 )
      {
        __asm
        {
          vpcmpeqb ymm1, ymm0, ymmword ptr [rdi]
          vpcmpeqb ymm2, ymm0, ymmword ptr [rdi+20h]
          vpcmpeqb ymm3, ymm0, ymmword ptr [rdi+40h]
          vpcmpeqb ymm4, ymm0, ymmword ptr [rdi+60h]
          vpor    ymm5, ymm2, ymm1
          vpor    ymm6, ymm4, ymm3
          vpor    ymm5, ymm6, ymm5
          vpmovmskb eax, ymm5
        }
        if ( _EAX )
          break;
        a1 += 128LL;
        v8 = v11 <= 0x80;
        v11 -= 128LL;
        if ( v8 )
          goto LABEL_20;
      }
      __asm { vpmovmskb eax, ymm1 }
      if ( !(_DWORD)_RAX )
      {
        __asm { vpmovmskb eax, ymm2 }
        if ( !(_DWORD)_RAX )
        {
          __asm { vpmovmskb eax, ymm3 }
          if ( !(_DWORD)_RAX )
          {
            __asm { vpmovmskb eax, ymm4 }
            goto LABEL_48;
          }
LABEL_43:
          __asm { tzcnt   eax, eax }
          result = a1 + _RAX + 64;
          __asm { vzeroupper }
          return result;
        }
LABEL_42:
        __asm { tzcnt   eax, eax }
        result = a1 + _RAX + 32;
        __asm { vzeroupper }
        return result;
      }
LABEL_41:
      __asm { tzcnt   eax, eax }
      result = a1 + _RAX;
      __asm { vzeroupper }
      return result;
    }
LABEL_20:
    v8 = ((int)v11 + 64 < 0) ^ __OFADD__(64, (_DWORD)v11) | ((_DWORD)v11 == -64);
    v32 = (unsigned int)(v11 + 64);
    if ( !v8 )
    {
      __asm
      {
        vpcmpeqb ymm1, ymm0, ymmword ptr [rdi]
        vpmovmskb eax, ymm1
      }
      if ( (_DWORD)_RAX )
        goto LABEL_41;
      __asm
      {
        vpcmpeqb ymm1, ymm0, ymmword ptr [rdi+20h]
        vpmovmskb eax, ymm1
      }
      if ( (_DWORD)_RAX )
        goto LABEL_42;
      __asm
      {
        vpcmpeqb ymm1, ymm0, ymmword ptr [rdi+40h]
        vpmovmskb eax, ymm1
      }
      if ( (_DWORD)_RAX )
      {
        __asm { tzcnt   eax, eax }
        if ( v32 > _RAX )
        {
          result = a1 + _RAX + 64;
          __asm { vzeroupper }
          return result;
        }
      }
      else
      {
        v8 = (int)v32 <= 32;
        v36 = (unsigned int)(v32 - 32);
        if ( !v8 )
        {
          __asm
          {
            vpcmpeqb ymm1, ymm0, ymmword ptr [rdi+60h]
            vpmovmskb eax, ymm1
          }
          if ( !(_DWORD)_RAX )
          {
            result = 0LL;
            __asm { vzeroupper }
            return result;
          }
          __asm { tzcnt   eax, eax }
          if ( v36 > _RAX )
          {
            result = a1 + _RAX + 96;
            __asm { vzeroupper }
            return result;
          }
        }
      }
      goto LABEL_39;
    }
    a3 = (unsigned int)(v32 + 64);
    __asm
    {
      vpcmpeqb ymm1, ymm0, ymmword ptr [rdi]
      vpmovmskb eax, ymm1
    }
    if ( !(_DWORD)_RAX )
    {
      v8 = (int)a3 <= 32;
      v39 = (unsigned int)(a3 - 32);
      if ( !v8 )
      {
        __asm
        {
          vpcmpeqb ymm1, ymm0, ymmword ptr [rdi+20h]
          vpmovmskb eax, ymm1
        }
        if ( !(_DWORD)_RAX )
        {
          result = 0LL;
          __asm { vzeroupper }
          return result;
        }
        __asm { tzcnt   eax, eax }
        if ( v39 > _RAX )
        {
          result = a1 + _RAX + 32;
          __asm { vzeroupper }
          return result;
        }
      }
      goto LABEL_39;
    }
    goto LABEL_31;
  }
LABEL_48:
  __asm { tzcnt   eax, eax }
  result = a1 + _RAX + 96;
  __asm { vzeroupper }
  return result;
}
// 463007: variable '_RAX' is possibly undefined

//----- (00000000004630E0) ----------------------------------------------------
char *__fastcall _strrchr_sse2(const __m128i *a1, unsigned int a2)
{
  __m128i v2; // xmm1
  __m128i v3; // xmm1
  __m128i v4; // xmm1
  __m128i v5; // xmm3
  unsigned int v6; // ecx
  unsigned int v7; // edx
  unsigned __int64 v8; // rax
  __m128i v10; // xmm5
  __m128i v11; // xmm4
  __m128i v12; // xmm0
  unsigned int v13; // edx
  __m128i v14; // xmm5
  unsigned __int64 v15; // rsi
  unsigned __int64 v16; // rax
  __int64 v17; // rsi
  const __m128i *v18; // rcx
  const __m128i *i; // rdi
  __m128i si128; // xmm3
  __m128i v21; // xmm2
  __m128i v22; // xmm4
  __m128i v23; // xmm5
  unsigned __int64 v24; // rdx
  unsigned __int64 v25; // rax
  __int64 v26; // rdx
  __m128i v27; // xmm6
  __m128i v28; // xmm5
  unsigned int v29; // esi
  __m128i v30; // xmm6
  __m128i v31; // xmm2
  __m128i v32; // xmm4
  unsigned int v33; // edx
  __m128i v34; // xmm6
  unsigned __int64 v35; // rdx
  __int64 v36; // rsi
  unsigned __int64 v37; // rax

  v2 = _mm_cvtsi32_si128(a2);
  v3 = _mm_unpacklo_epi8(v2, v2);
  v4 = _mm_shuffle_epi32(_mm_unpacklo_epi16(v3, v3), 0);
  if ( ((unsigned __int16)a1 & 0xFFFu) <= 0xFC0uLL )
  {
    v5 = _mm_loadu_si128(a1);
    v6 = _mm_movemask_epi8(_mm_cmpeq_epi8(v5, v4));
    v7 = _mm_movemask_epi8(_mm_cmpeq_epi8(v5, (__m128i)0LL));
    if ( v7 )
    {
      if ( (v6 & (v7 ^ (v7 - 1LL))) != 0 )
      {
        _BitScanReverse64(&v8, v6 & (v7 ^ (v7 - 1LL)));
        return (char *)a1 + v8;
      }
      return 0LL;
    }
    v10 = _mm_loadu_si128(a1 + 1);
    v11 = _mm_cmpeq_epi8(v10, v4);
    v12 = _mm_loadu_si128(a1 + 3);
    v13 = _mm_movemask_epi8(_mm_cmpeq_epi8(v10, (__m128i)0LL));
    v14 = _mm_loadu_si128(a1 + 2);
    v15 = ((unsigned __int64)(unsigned int)_mm_movemask_epi8(_mm_cmpeq_epi8(v12, v4)) << 48) | v6 | ((unsigned __int64)(unsigned int)_mm_movemask_epi8(_mm_cmpeq_epi8(v14, v4)) << 32) | ((unsigned __int64)(unsigned int)_mm_movemask_epi8(v11) << 16);
    v16 = ((unsigned __int64)(unsigned int)_mm_movemask_epi8(_mm_cmpeq_epi8((__m128i)0LL, v12)) << 48) | ((unsigned __int64)v13 << 16) | ((unsigned __int64)(unsigned int)_mm_movemask_epi8(_mm_cmpeq_epi8(v14, (__m128i)0LL)) << 32);
    if ( v16 )
    {
      v17 = (v16 ^ (v16 - 1)) & v15;
      if ( v17 )
      {
        _BitScanReverse64((unsigned __int64 *)&v17, v17);
        return (char *)a1 + v17;
      }
      return 0LL;
    }
    goto LABEL_8;
  }
  v27 = _mm_loadu_si128((const __m128i *)((unsigned __int64)a1 & 0xFFFFFFFFFFFFFFC0LL));
  v28 = _mm_cmpeq_epi8(v27, v4);
  v29 = _mm_movemask_epi8(_mm_cmpeq_epi8(v27, (__m128i)0LL));
  v30 = _mm_loadu_si128((const __m128i *)(((unsigned __int64)a1 & 0xFFFFFFFFFFFFFFC0LL) + 16));
  v31 = _mm_loadu_si128((const __m128i *)(((unsigned __int64)a1 & 0xFFFFFFFFFFFFFFC0LL) + 48));
  v32 = _mm_cmpeq_epi8(v30, v4);
  v33 = _mm_movemask_epi8(_mm_cmpeq_epi8(v30, (__m128i)0LL));
  v34 = _mm_loadu_si128((const __m128i *)(((unsigned __int64)a1 & 0xFFFFFFFFFFFFFFC0LL) + 32));
  v35 = (((unsigned __int64)(unsigned int)_mm_movemask_epi8(_mm_cmpeq_epi8((__m128i)0LL, v31)) << 48) | v29 | ((unsigned __int64)(unsigned int)_mm_movemask_epi8(_mm_cmpeq_epi8(v34, (__m128i)0LL)) << 32) | ((unsigned __int64)v33 << 16)) >> ((unsigned __int8)a1 - ((unsigned __int8)a1 & 0xC0u));
  v15 = (((unsigned __int64)(unsigned int)_mm_movemask_epi8(_mm_cmpeq_epi8(v31, v4)) << 48) | (unsigned int)_mm_movemask_epi8(v28) | ((unsigned __int64)(unsigned int)_mm_movemask_epi8(_mm_cmpeq_epi8(v34, v4)) << 32) | ((unsigned __int64)(unsigned int)_mm_movemask_epi8(v32) << 16)) >> ((unsigned __int8)a1 - ((unsigned __int8)a1 & 0xC0u));
  if ( !v35 )
  {
LABEL_8:
    v18 = a1;
    if ( !v15 )
    {
      v15 = 1LL;
      v18 = 0LL;
    }
    for ( i = (const __m128i *)((unsigned __int64)&a1[4] & 0xFFFFFFFFFFFFFFC0LL); ; i += 4 )
    {
      si128 = _mm_load_si128(i + 2);
      v21 = _mm_load_si128(i + 3);
      v22 = _mm_load_si128(i + 1);
      v23 = _mm_load_si128(i);
      v24 = ((unsigned __int64)(unsigned int)_mm_movemask_epi8(_mm_cmpeq_epi8(v21, v4)) << 48) | (unsigned int)_mm_movemask_epi8(_mm_cmpeq_epi8(v23, v4)) | ((unsigned __int64)(unsigned int)_mm_movemask_epi8(_mm_cmpeq_epi8(si128, v4)) << 32) | ((unsigned __int64)(unsigned int)_mm_movemask_epi8(_mm_cmpeq_epi8(v22, v4)) << 16);
      if ( _mm_movemask_epi8(_mm_cmpeq_epi8(_mm_min_epu8(_mm_min_epu8(_mm_min_epu8(si128, v21), v22), v23), (__m128i)0LL)) )
        break;
      if ( v24 )
        v15 = v24;
      if ( v24 )
        v18 = i;
    }
    v25 = ((unsigned __int64)(unsigned int)_mm_movemask_epi8(_mm_cmpeq_epi8(v21, (__m128i)0LL)) << 48) | (unsigned int)_mm_movemask_epi8(_mm_cmpeq_epi8(v23, (__m128i)0LL)) | ((unsigned __int64)(unsigned int)_mm_movemask_epi8(_mm_cmpeq_epi8(si128, (__m128i)0LL)) << 32) | ((unsigned __int64)(unsigned int)_mm_movemask_epi8(_mm_cmpeq_epi8(v22, (__m128i)0LL)) << 16);
    v26 = (v25 ^ (v25 - 1)) & v24;
    if ( v26 )
      v18 = i;
    if ( v26 )
      v15 = v26;
    _BitScanReverse64(&v15, v15);
    return (char *)v18 + v15;
  }
  v36 = (v35 ^ (v35 - 1)) & v15;
  if ( !v36 )
    return 0LL;
  _BitScanReverse64(&v37, v36);
  return (char *)a1 + v37;
}

//----- (00000000004633E0) ----------------------------------------------------
__int64 __fastcall _strrchr_avx2(__int64 _RDI, unsigned __int64 a2)
{
  __int64 v11; // rdi
  unsigned int v13; // edx
  __int64 v14; // rcx
  __int64 v35; // rax
  __int64 result; // rax
  __int64 v38; // rax
  __int64 v39; // rax

  _XMM4 = _mm_cvtsi32_si128(a2);
  __asm
  {
    vpbroadcastb ymm4, xmm4
    vpxor   ymm0, ymm0, ymm0
  }
  if ( ((unsigned __int8)_RDI & 0x3Fu) > 0x20 )
  {
    v14 = _RDI & 0x1F;
    _RDI = _RDI & 0xFFFFFFFFFFFFFFE0LL;
    __asm
    {
      vmovdqa ymm1, ymmword ptr [rdi]
      vpcmpeqb ymm2, ymm0, ymm1
      vpcmpeqb ymm3, ymm4, ymm1
      vpmovmskb edx, ymm2
      vpmovmskb eax, ymm3
    }
    v13 = _EDX >> v14;
    _EAX = _EAX >> v14;
    _RDI = _RDI + 32;
    if ( !_EAX )
    {
      if ( !v13 )
        goto LABEL_12;
      goto LABEL_26;
    }
    if ( !v13 )
    {
      v13 = _EAX;
      a2 = _RDI + v14;
      goto LABEL_12;
    }
    v11 = v14 + _RDI;
    _ECX = v13;
LABEL_24:
    LODWORD(v39) = (_ECX ^ (_ECX - 1)) & _EAX;
    if ( (_DWORD)v39 )
    {
      _BitScanReverse((unsigned int *)&v39, v39);
      result = v11 + v39 - 32;
      __asm { vzeroupper }
      return result;
    }
    goto LABEL_26;
  }
  __asm
  {
    vmovdqu ymm1, ymmword ptr [rdi]
    vpcmpeqb ymm2, ymm0, ymm1
    vpcmpeqb ymm3, ymm4, ymm1
    vpmovmskb ecx, ymm2
    vpmovmskb eax, ymm3
  }
  v11 = _RDI + 32;
  if ( _EAX )
  {
    if ( !_ECX )
    {
      v13 = _EAX;
      a2 = v11;
      _RDI = v11 & 0xFFFFFFFFFFFFFFE0LL;
      goto LABEL_12;
    }
    goto LABEL_24;
  }
  if ( _ECX )
  {
LABEL_26:
    result = 0LL;
    __asm { vzeroupper }
    return result;
  }
  _RDI = v11 & 0xFFFFFFFFFFFFFFE0LL;
  v13 = 0;
  while ( 1 )
  {
    do
    {
LABEL_12:
      __asm
      {
        vmovdqa ymm1, ymmword ptr [rdi]
        vpcmpeqb ymm2, ymm0, ymm1
      }
      _RDI += 32LL;
      __asm
      {
        vpcmpeqb ymm3, ymm4, ymm1
        vpmovmskb ecx, ymm2
        vpmovmskb eax, ymm3
      }
      if ( _EAX | _ECX )
        break;
      __asm
      {
        vmovdqa ymm1, ymmword ptr [rdi]
        vpcmpeqb ymm2, ymm0, ymm1
      }
      _RDI += 32LL;
      __asm
      {
        vpcmpeqb ymm3, ymm4, ymm1
        vpmovmskb ecx, ymm2
        vpmovmskb eax, ymm3
      }
      if ( _EAX | _ECX )
        break;
      __asm
      {
        vmovdqa ymm1, ymmword ptr [rdi]
        vpcmpeqb ymm2, ymm0, ymm1
      }
      _RDI += 32LL;
      __asm
      {
        vpcmpeqb ymm3, ymm4, ymm1
        vpmovmskb ecx, ymm2
        vpmovmskb eax, ymm3
      }
      if ( _EAX | _ECX )
        break;
      __asm
      {
        vmovdqa ymm1, ymmword ptr [rdi]
        vpcmpeqb ymm2, ymm0, ymm1
      }
      _RDI += 32LL;
      __asm
      {
        vpcmpeqb ymm3, ymm4, ymm1
        vpmovmskb ecx, ymm2
        vpmovmskb eax, ymm3
      }
    }
    while ( !(_EAX | _ECX) );
    if ( !_EAX )
      break;
    __asm { vpmovmskb ecx, ymm2 }
    if ( _ECX )
    {
      LODWORD(v38) = (_ECX ^ (_ECX - 1)) & _EAX;
      if ( (_DWORD)v38 )
      {
        _BitScanReverse((unsigned int *)&v38, v38);
        result = _RDI + v38 - 32;
        __asm { vzeroupper }
        return result;
      }
      break;
    }
    v13 = _EAX;
    a2 = _RDI;
  }
  if ( !v13 )
    goto LABEL_26;
  _BitScanReverse((unsigned int *)&v35, v13);
  result = a2 + v35 - 32;
  __asm { vzeroupper }
  return result;
}
// 463524: variable 'v35' is possibly undefined
// 463564: variable 'v38' is possibly undefined
// 463589: variable 'v39' is possibly undefined

//----- (00000000004635B0) ----------------------------------------------------
char *__fastcall _strnlen_sse2(__int64 a1, __int64 a2)
{
  char *result; // rax
  __m128i *v3; // rsi
  unsigned __int64 v4; // r10
  __m128i *v5; // r11
  __m128i v6; // xmm1
  __m128i v7; // xmm2
  __m128i v8; // xmm3
  signed __int64 v9; // rdx
  char v10; // cl
  __int64 v11; // rsi
  __m128i *v12; // rax
  unsigned __int64 v13; // rdx
  unsigned __int64 v14; // rdx

  if ( !a2 )
    return 0LL;
  v3 = (__m128i *)(a1 + a2);
  v4 = (unsigned __int64)v3 & 0xFFFFFFFFFFFFFFC0LL;
  v5 = v3;
  if ( ((unsigned __int16)a1 & 0xFFFu) > 0xFCFuLL )
  {
    v9 = (((unsigned int)_mm_movemask_epi8(_mm_cmpeq_epi8((__m128i)0LL, *(__m128i *)((a1 & 0xFFFFFFFFFFFFFFC0LL) + 0x20))) | ((unsigned __int64)(unsigned int)_mm_movemask_epi8(_mm_cmpeq_epi8((__m128i)0LL, *(__m128i *)((a1 & 0xFFFFFFFFFFFFFFC0LL) + 0x30))) << 16)) << 32) | (unsigned int)_mm_movemask_epi8(_mm_cmpeq_epi8((__m128i)0LL, *(__m128i *)(a1 & 0xFFFFFFFFFFFFFFC0LL))) | ((unsigned __int64)(unsigned int)_mm_movemask_epi8(_mm_cmpeq_epi8((__m128i)0LL, *(__m128i *)((a1 & 0xFFFFFFFFFFFFFFC0LL) + 0x10))) << 16);
    v10 = a1 & 0xC0 ^ a1;
    v11 = (__int64)v3->m128i_i64 - (a1 & 0xFFFFFFFFFFFFFFC0LL);
    v12 = (__m128i *)(a1 & 0xFFFFFFFFFFFFFFC0LL);
    if ( (v11 & 0xFFFFFFFFFFFFFFC0LL) != 0 )
    {
      v13 = v9 >> v10;
      if ( v13 )
        goto LABEL_11;
      goto LABEL_12;
    }
  }
  else
  {
    v6 = _mm_cmpeq_epi8((__m128i)0LL, *(__m128i *)((a1 & 0xFFFFFFFFFFFFFFF0LL) + 0x10));
    v7 = _mm_cmpeq_epi8((__m128i)0LL, *(__m128i *)((a1 & 0xFFFFFFFFFFFFFFF0LL) + 0x20));
    v8 = _mm_cmpeq_epi8((__m128i)0LL, *(__m128i *)((a1 & 0xFFFFFFFFFFFFFFF0LL) + 0x30));
    v9 = (((unsigned int)_mm_movemask_epi8(v7) | ((unsigned __int64)(unsigned int)_mm_movemask_epi8(v8) << 16)) << 32) | (unsigned int)_mm_movemask_epi8(_mm_cmpeq_epi8((__m128i)0LL, *(__m128i *)(a1 & 0xFFFFFFFFFFFFFFF0LL))) | ((unsigned __int64)(unsigned int)_mm_movemask_epi8(v6) << 16);
    v10 = a1 & 0xF0 ^ a1;
    v11 = (__int64)v3->m128i_i64 - (a1 & 0xFFFFFFFFFFFFFFF0LL);
    v12 = (__m128i *)(a1 & 0xFFFFFFFFFFFFFFC0LL);
    if ( (v11 & 0xFFFFFFFFFFFFFFC0LL) != 0 )
    {
      v13 = v9 >> v10;
      if ( !v13 )
        goto LABEL_13;
      goto LABEL_11;
    }
  }
  v13 = (v9 | (1LL << v11)) >> v10;
  if ( v13 )
  {
LABEL_11:
    _BitScanForward64((unsigned __int64 *)&result, v13);
    return result;
  }
LABEL_12:
  v6 = 0LL;
  v7 = 0LL;
  v8 = 0LL;
LABEL_13:
  while ( 1 )
  {
    v12 += 4;
    if ( (__m128i *)v4 == v12 )
      break;
    v13 = (unsigned int)_mm_movemask_epi8(
                          _mm_cmpeq_epi8(
                            _mm_min_epu8(_mm_min_epu8(_mm_min_epu8(_mm_load_si128(v12), v12[1]), v12[2]), v12[3]),
                            v8));
    if ( (_DWORD)v13 )
    {
      _BitScanForward64(
        &v14,
        (((unsigned int)_mm_movemask_epi8(_mm_cmpeq_epi8(v7, v12[2])) | ((unsigned __int64)(unsigned int)_mm_movemask_epi8(_mm_cmpeq_epi8(v8, v12[3])) << 16)) << 32) | (unsigned int)_mm_movemask_epi8(_mm_cmpeq_epi8((__m128i)0LL, *v12)) | ((unsigned __int64)(unsigned int)_mm_movemask_epi8(_mm_cmpeq_epi8(v6, v12[1])) << 16));
      return (char *)v12 + v14 - a1;
    }
  }
  if ( v5 != v12 )
    v13 = (((unsigned int)_mm_movemask_epi8(_mm_cmpeq_epi8(v7, v12[2])) | ((unsigned __int64)(unsigned int)_mm_movemask_epi8(_mm_cmpeq_epi8(v8, v12[3])) << 16)) << 32) | (unsigned int)_mm_movemask_epi8(_mm_cmpeq_epi8((__m128i)0LL, *v12)) | ((unsigned __int64)(unsigned int)_mm_movemask_epi8(_mm_cmpeq_epi8(v6, v12[1])) << 16);
  _BitScanForward64(&v13, v13 | (1LL << (char)v5));
  return (char *)v12 + v13 - a1;
}

//----- (00000000004637D0) ----------------------------------------------------
unsigned __int64 __fastcall _strnlen_avx2(unsigned __int64 _RDI, unsigned __int64 a2, __m128 _XMM0)
{
  unsigned __int64 v5; // r8
  unsigned __int64 v6; // rdx
  unsigned int v8; // ecx
  char v10; // cc
  unsigned __int64 v11; // rsi
  unsigned __int64 v12; // rsi
  unsigned __int64 v13; // rsi
  unsigned __int64 v14; // rcx
  unsigned __int64 v15; // rdi
  unsigned __int64 result; // rax
  unsigned __int64 v19; // rcx
  unsigned __int64 v20; // rsi
  unsigned __int64 v25; // rcx
  unsigned __int64 v35; // rsi
  unsigned __int64 v39; // rsi
  unsigned __int64 v42; // rsi

  if ( !a2 )
    return 0LL;
  v5 = a2;
  v6 = _RDI;
  __asm { vpxor   xmm0, xmm0, xmm0 }
  v8 = _RDI & 0x3F;
  if ( v8 > 0x20 )
  {
    v14 = _RDI & 0x1F;
    v15 = _RDI & 0xFFFFFFFFFFFFFFE0LL;
    __asm
    {
      vpcmpeqb ymm1, ymm0, ymmword ptr [rdi]
      vpmovmskb eax, ymm1
    }
    _RAX = (unsigned int)(_EAX >> v14);
    if ( (_DWORD)_RAX )
    {
      __asm { tzcnt   eax, eax }
      if ( a2 > _RAX )
      {
        result = v14 + v15 + _RAX - v6;
        __asm { vzeroupper }
        return result;
      }
      goto LABEL_39;
    }
    v19 = 32 - v14;
    v10 = a2 <= v19;
    v20 = a2 - v19;
    if ( v10 )
    {
LABEL_39:
      result = v5;
      __asm { vzeroupper }
      return result;
    }
    _RDI = v15 + 32;
    v10 = v20 <= 0x80;
    v13 = v20 - 128;
    if ( v10 )
      goto LABEL_20;
  }
  else
  {
    __asm
    {
      vpcmpeqb ymm1, ymm0, ymmword ptr [rdi]
      vpmovmskb eax, ymm1
    }
    if ( (_DWORD)_RAX )
      goto LABEL_31;
    v10 = a2 <= 0x20;
    v11 = a2 - 32;
    if ( v10 )
      goto LABEL_39;
    _RDI = (_RDI + 32) & 0xFFFFFFFFFFFFFFE0LL;
    v12 = (v8 & 0x1F) + v11;
    v10 = v12 <= 0x80;
    v13 = v12 - 128;
    if ( v10 )
    {
LABEL_20:
      v10 = ((int)v13 + 64 < 0) ^ __OFADD__(64, (_DWORD)v13) | ((_DWORD)v13 == -64);
      v35 = (unsigned int)(v13 + 64);
      if ( !v10 )
      {
        __asm
        {
          vpcmpeqb ymm1, ymm0, ymmword ptr [rdi]
          vpmovmskb eax, ymm1
        }
        if ( (_DWORD)_RAX )
          goto LABEL_41;
        __asm
        {
          vpcmpeqb ymm1, ymm0, ymmword ptr [rdi+20h]
          vpmovmskb eax, ymm1
        }
        if ( (_DWORD)_RAX )
          goto LABEL_42;
        __asm
        {
          vpcmpeqb ymm1, ymm0, ymmword ptr [rdi+40h]
          vpmovmskb eax, ymm1
        }
        if ( (_DWORD)_RAX )
        {
          __asm { tzcnt   eax, eax }
          if ( v35 > _RAX )
          {
            result = _RDI + _RAX + 64 - v6;
            __asm { vzeroupper }
            return result;
          }
        }
        else
        {
          v10 = (int)v35 <= 32;
          v39 = (unsigned int)(v35 - 32);
          if ( !v10 )
          {
            __asm
            {
              vpcmpeqb ymm1, ymm0, ymmword ptr [rdi+60h]
              vpmovmskb eax, ymm1
            }
            if ( !(_DWORD)_RAX )
            {
              result = v5;
              __asm { vzeroupper }
              return result;
            }
            __asm { tzcnt   eax, eax }
            if ( v39 > _RAX )
            {
              result = _RDI + _RAX + 96 - v6;
              __asm { vzeroupper }
              return result;
            }
          }
        }
        goto LABEL_39;
      }
      a2 = (unsigned int)(v35 + 64);
      __asm
      {
        vpcmpeqb ymm1, ymm0, ymmword ptr [rdi]
        vpmovmskb eax, ymm1
      }
      if ( !(_DWORD)_RAX )
      {
        v10 = (int)a2 <= 32;
        v42 = (unsigned int)(a2 - 32);
        if ( !v10 )
        {
          __asm
          {
            vpcmpeqb ymm1, ymm0, ymmword ptr [rdi+20h]
            vpmovmskb eax, ymm1
          }
          if ( !(_DWORD)_RAX )
          {
            result = v5;
            __asm { vzeroupper }
            return result;
          }
          __asm { tzcnt   eax, eax }
          if ( v42 > _RAX )
          {
            result = _RDI + _RAX + 32 - v6;
            __asm { vzeroupper }
            return result;
          }
        }
        goto LABEL_39;
      }
LABEL_31:
      __asm { tzcnt   eax, eax }
      if ( a2 > _RAX )
      {
        result = _RDI + _RAX - v6;
        __asm { vzeroupper }
        return result;
      }
      goto LABEL_39;
    }
  }
  __asm
  {
    vpcmpeqb ymm1, ymm0, ymmword ptr [rdi]
    vpmovmskb eax, ymm1
  }
  if ( (_DWORD)_RAX )
    goto LABEL_41;
  __asm
  {
    vpcmpeqb ymm1, ymm0, ymmword ptr [rdi+20h]
    vpmovmskb eax, ymm1
  }
  if ( (_DWORD)_RAX )
    goto LABEL_42;
  __asm
  {
    vpcmpeqb ymm1, ymm0, ymmword ptr [rdi+40h]
    vpmovmskb eax, ymm1
  }
  if ( (_DWORD)_RAX )
    goto LABEL_43;
  __asm
  {
    vpcmpeqb ymm1, ymm0, ymmword ptr [rdi+60h]
    vpmovmskb eax, ymm1
  }
  if ( !(_DWORD)_RAX )
  {
    _RDI += 128LL;
    v10 = v13 <= 0x80;
    v13 -= 128LL;
    if ( !v10 )
    {
      v25 = _RDI & 0x7F;
      _RDI &= 0xFFFFFFFFFFFFFF80LL;
      v13 += v25;
      while ( 1 )
      {
        __asm
        {
          vmovdqa ymm1, ymmword ptr [rdi]
          vmovdqa ymm2, ymmword ptr [rdi+20h]
          vmovdqa ymm3, ymmword ptr [rdi+40h]
          vmovdqa ymm4, ymmword ptr [rdi+60h]
          vpminub ymm5, ymm2, ymm1
          vpminub ymm6, ymm4, ymm3
          vpminub ymm5, ymm6, ymm5
          vpcmpeqb ymm5, ymm0, ymm5
          vpmovmskb eax, ymm5
        }
        if ( _EAX )
          break;
        _RDI += 128LL;
        v10 = v13 <= 0x80;
        v13 -= 128LL;
        if ( v10 )
          goto LABEL_20;
      }
      __asm
      {
        vpcmpeqb ymm1, ymm0, ymm1
        vpmovmskb eax, ymm1
      }
      if ( !(_DWORD)_RAX )
      {
        __asm
        {
          vpcmpeqb ymm2, ymm0, ymm2
          vpmovmskb eax, ymm2
        }
        if ( !(_DWORD)_RAX )
        {
          __asm
          {
            vpcmpeqb ymm3, ymm0, ymm3
            vpmovmskb eax, ymm3
          }
          if ( !(_DWORD)_RAX )
          {
            __asm
            {
              vpcmpeqb ymm4, ymm0, ymm4
              vpmovmskb eax, ymm4
            }
            goto LABEL_48;
          }
LABEL_43:
          __asm { tzcnt   eax, eax }
          result = _RDI + _RAX + 64 - v6;
          __asm { vzeroupper }
          return result;
        }
LABEL_42:
        __asm { tzcnt   eax, eax }
        result = _RDI + _RAX + 32 - v6;
        __asm { vzeroupper }
        return result;
      }
LABEL_41:
      __asm { tzcnt   eax, eax }
      result = _RDI + _RAX - v6;
      __asm { vzeroupper }
      return result;
    }
    goto LABEL_20;
  }
LABEL_48:
  __asm { tzcnt   eax, eax }
  result = _RDI + _RAX + 96 - v6;
  __asm { vzeroupper }
  return result;
}
// 4639C7: variable '_RAX' is possibly undefined

//----- (0000000000463AF0) ----------------------------------------------------
unsigned __int64 (__fastcall *wcslen())(unsigned __int64 _RDI, __m128 _XMM0)
{
  unsigned __int64 (__fastcall *result)(unsigned __int64, __m128); // rax

  result = (unsigned __int64 (__fastcall *)(unsigned __int64, __m128))_wcslen_sse2;
  if ( (dword_4AAE4C & 0x20C00) == 3072 )
    return _wcslen_avx2;
  return result;
}
// 4AAE4C: using guessed type int dword_4AAE4C;

//----- (0000000000463B20) ----------------------------------------------------
__int64 __fastcall wmemcpy(__int64 a1, __int64 a2, __int64 a3)
{
  return j_memcpy(a1, a2, 4 * a3);
}
// 401040: using guessed type __int64 __fastcall j_memcpy(_QWORD, _QWORD, _QWORD);

//----- (0000000000463B30) ----------------------------------------------------
__int64 __fastcall wmemmove(__int64 a1, __int64 a2, __int64 a3)
{
  return j_memmove(a1, a2, 4 * a3);
}
// 401030: using guessed type __int64 __fastcall j_memmove(_QWORD, _QWORD, _QWORD);

//----- (0000000000463B40) ----------------------------------------------------
void (__fastcall *wmemset())(__int64 a1, int _ESI)
{
  void (__fastcall *result)(__int64, int); // rax

  result = (void (__fastcall *)(__int64, int))_wmemset_sse2_unaligned;
  if ( (dword_4AAE4C & 0x20C00) == 3072 )
  {
    result = _wmemset_avx512_unaligned;
    if ( (dword_4AAE4C & 0x101000) != 4096 )
      return _wmemset_avx2_unaligned;
  }
  return result;
}
// 4AAE4C: using guessed type int dword_4AAE4C;

//----- (0000000000463B90) ----------------------------------------------------
__int64 __fastcall btowc(unsigned int a1, __int64 a2, __int64 a3, __int64 a4, u32 *a5, __int64 a6)
{
  __int64 v6; // rdx
  __int64 result; // rax
  __int64 v8; // rbp
  void **v9; // r12
  __int64 (__fastcall *v10)(void *, _QWORD); // rbp
  _QWORD *v11; // rax
  bool v12; // zf
  __int64 (__fastcall *v13)(void *, __int64 *, char **, char *, _QWORD, char *, _QWORD); // rbx
  int v14; // edx
  unsigned int v15; // [rsp+Ch] [rbp-6Ch] BYREF
  char *v16; // [rsp+10h] [rbp-68h] BYREF
  char v17[8]; // [rsp+18h] [rbp-60h] BYREF
  __int64 v18[3]; // [rsp+20h] [rbp-58h] BYREF
  int v19; // [rsp+38h] [rbp-40h]
  __int64 *v20; // [rsp+40h] [rbp-38h]
  __int64 v21; // [rsp+48h] [rbp-30h] BYREF
  char v22; // [rsp+57h] [rbp-21h] BYREF
  unsigned __int64 v23; // [rsp+58h] [rbp-20h]

  v6 = a1 + 128;
  v23 = __readfsqword(0x28u);
  if ( (unsigned int)v6 > 0x17F || a1 == -1 )
    return 0xFFFFFFFFLL;
  result = a1;
  if ( (a1 & 0xFFFFFF80) != 0 )
  {
    v8 = *(_QWORD *)__readfsqword(0xFFFFFFA0);
    v9 = *(void ***)(v8 + 40);
    if ( !v9 )
    {
      if ( (char **)v8 == &nl_C_LC_CTYPE )
      {
        v9 = &_wcsmbs_gconv_fcts_c;
      }
      else
      {
        _wcsmbs_load_conv(v8, a2, v6, a4, a5, a6);
        v9 = *(void ***)(v8 + 40);
      }
    }
    v10 = (__int64 (__fastcall *)(void *, _QWORD))*((_QWORD *)*v9 + 6);
    if ( *(_QWORD *)*v9 )
      v10 = (__int64 (__fastcall *)(void *, _QWORD))(__readfsqword(0x30u) ^ __ROR8__(v10, 17));
    if ( v9[1] == (void *)1 && v10 )
    {
      dl_mcount_wrapper_check((__int64)v10);
      return v10(*v9, (unsigned __int8)a1);
    }
    else
    {
      v22 = a1;
      v16 = &v22;
      v18[0] = (__int64)&v15;
      v18[1] = (__int64)&v16;
      v21 = 0LL;
      v20 = &v21;
      v11 = *v9;
      v18[2] = 1LL;
      v12 = *v11 == 0LL;
      v13 = (__int64 (__fastcall *)(void *, __int64 *, char **, char *, _QWORD, char *, _QWORD))v11[5];
      v19 = 1;
      if ( !v12 )
        v13 = (__int64 (__fastcall *)(void *, __int64 *, char **, char *, _QWORD, char *, _QWORD))(__readfsqword(0x30u) ^ __ROR8__(v13, 17));
      dl_mcount_wrapper_check((__int64)v13);
      v14 = v13(*v9, v18, &v16, v16 + 1, 0LL, v17, 0LL);
      if ( (unsigned int)(v14 - 4) <= 1 )
        return v15;
      result = 0xFFFFFFFFLL;
      if ( !v14 )
        return v15;
    }
  }
  return result;
}
// 4A5140: using guessed type void *_wcsmbs_gconv_fcts_c;
// 4A51E0: using guessed type char *nl_C_LC_CTYPE;
// 463B90: using guessed type char var_60[8];

//----- (0000000000463D40) ----------------------------------------------------
__int64 __fastcall wcrtomb(char *a1, __int64 a2, void *a3, __int64 a4, u32 *a5, __int64 a6)
{
  char *v6; // rbp
  unsigned __int64 v7; // rax
  __int64 v8; // rbx
  void **v9; // r12
  _QWORD *v10; // rax
  __int64 (__fastcall *v11)(void *, __int64 *, int **, int *, _QWORD, char *, __int64, __int64); // rbx
  int v12; // eax
  _BYTE *v14; // rax
  int v15; // [rsp+Ch] [rbp-7Ch] BYREF
  char v16[8]; // [rsp+10h] [rbp-78h] BYREF
  int *v17; // [rsp+18h] [rbp-70h] BYREF
  __int64 v18[3]; // [rsp+20h] [rbp-68h] BYREF
  int v19; // [rsp+38h] [rbp-50h]
  void *v20; // [rsp+40h] [rbp-48h]
  char v21; // [rsp+50h] [rbp-38h] BYREF
  unsigned __int64 v22; // [rsp+68h] [rbp-20h]

  v6 = a1;
  v15 = a2;
  v22 = __readfsqword(0x28u);
  v18[2] = 1LL;
  if ( !a3 )
    a3 = &state_0;
  v19 = 1;
  v20 = a3;
  if ( !a1 )
  {
    v15 = 0;
    v6 = &v21;
  }
  v18[0] = (__int64)v6;
  v7 = __readfsqword(0xFFFFFFA0);
  v8 = *(_QWORD *)v7;
  v9 = *(void ***)(*(_QWORD *)v7 + 40LL);
  v18[1] = (__int64)&v6[*(unsigned int *)(*(_QWORD *)v7 + 168LL)];
  if ( !v9 )
  {
    if ( (char **)v8 == &nl_C_LC_CTYPE )
    {
      v9 = &_wcsmbs_gconv_fcts_c;
    }
    else
    {
      _wcsmbs_load_conv(v8, a2, (__int64)a3, a4, a5, a6);
      v9 = *(void ***)(v8 + 40);
    }
  }
  v10 = v9[2];
  v11 = (__int64 (__fastcall *)(void *, __int64 *, int **, int *, _QWORD, char *, __int64, __int64))v10[5];
  if ( *v10 )
    v11 = (__int64 (__fastcall *)(void *, __int64 *, int **, int *, _QWORD, char *, __int64, __int64))(__readfsqword(0x30u) ^ __ROR8__(v11, 17));
  if ( v15 )
  {
    v17 = &v15;
    dl_mcount_wrapper_check((__int64)v11);
    v12 = v11(v9[2], v18, &v17, v17 + 1, 0LL, v16, 0LL, 1LL);
    if ( (v12 & 0xFFFFFFFB) == 0 )
      return v18[0] - (_QWORD)v6;
  }
  else
  {
    dl_mcount_wrapper_check((__int64)v11);
    v12 = v11(v9[2], v18, 0LL, 0LL, 0LL, v16, 1LL, 1LL);
    if ( (v12 & 0xFFFFFFFB) == 0 )
    {
      v14 = (_BYTE *)v18[0]++;
      *v14 = 0;
      return v18[0] - (_QWORD)v6;
    }
  }
  if ( (unsigned int)(v12 - 5) > 2 )
    _assert_fail(
      (__int64)"status == __GCONV_OK || status == __GCONV_EMPTY_INPUT || status == __GCONV_ILLEGAL_INPUT || status == __G"
               "CONV_INCOMPLETE_INPUT || status == __GCONV_FULL_OUTPUT",
      (__int64)"wcrtomb.c",
      0x65u,
      "__wcrtomb");
  if ( v12 != 5 )
  {
    __writefsdword(0xFFFFFFC0, 0x54u);
    return -1LL;
  }
  return v18[0] - (_QWORD)v6;
}
// 4A5140: using guessed type void *_wcsmbs_gconv_fcts_c;
// 4A51E0: using guessed type char *nl_C_LC_CTYPE;
// 463D40: using guessed type char var_78[8];

//----- (0000000000463F30) ----------------------------------------------------
__int64 __fastcall wcsrtombs(__int64 a1, _QWORD *a2, __int64 a3, __int64 *a4, u32 *a5, __int64 a6)
{
  unsigned __int64 v7; // rax
  __int64 v8; // rbx
  void **v9; // rax
  _QWORD *v10; // rbp
  __int64 (__fastcall *v11)(_QWORD *, char **, __int64 *, __int64, _QWORD, char *, _QWORD, __int64); // rbx
  __int64 v12; // r13
  __int64 v13; // rax
  __int64 v14; // r13
  int v15; // eax
  __int64 v16; // r13
  unsigned int v17; // edx
  __int64 v19; // r15
  __int64 v20; // [rsp+18h] [rbp-190h] BYREF
  char v21[8]; // [rsp+20h] [rbp-188h] BYREF
  __int64 v22; // [rsp+28h] [rbp-180h] BYREF
  char *v23; // [rsp+30h] [rbp-178h] BYREF
  _QWORD *v24; // [rsp+38h] [rbp-170h]
  __int64 v25; // [rsp+40h] [rbp-168h]
  int v26; // [rsp+48h] [rbp-160h]
  __int64 *v27; // [rsp+50h] [rbp-158h]
  char v28[256]; // [rsp+60h] [rbp-148h] BYREF
  _QWORD v29[9]; // [rsp+160h] [rbp-48h] BYREF

  v29[1] = __readfsqword(0x28u);
  v25 = 1LL;
  if ( !a4 )
    a4 = (__int64 *)&state_1;
  v26 = 1;
  v27 = a4;
  v7 = __readfsqword(0xFFFFFFA0);
  v8 = *(_QWORD *)v7;
  v9 = *(void ***)(*(_QWORD *)v7 + 40LL);
  if ( !v9 )
  {
    if ( (char **)v8 == &nl_C_LC_CTYPE )
    {
      v9 = &_wcsmbs_gconv_fcts_c;
    }
    else
    {
      _wcsmbs_load_conv(v8, (__int64)a2, a3, (__int64)a4, a5, a6);
      v9 = *(void ***)(v8 + 40);
    }
  }
  v10 = v9[2];
  v11 = (__int64 (__fastcall *)(_QWORD *, char **, __int64 *, __int64, _QWORD, char *, _QWORD, __int64))v10[5];
  if ( *v10 )
    v11 = (__int64 (__fastcall *)(_QWORD *, char **, __int64 *, __int64, _QWORD, char *, _QWORD, __int64))(__readfsqword(0x30u) ^ __ROR8__(v11, 17));
  v12 = *a2;
  if ( a1 )
  {
    v13 = j_wcsnlen(*a2, a3);
    v23 = (char *)a1;
    v24 = (_QWORD *)(a1 + a3);
    v14 = v12 + 4 * v13 + 4;
    dl_mcount_wrapper_check((__int64)v11);
    v15 = ((__int64 (__fastcall *)(_QWORD *, char **, _QWORD *, __int64, _QWORD, char *, _QWORD))v11)(
            v10,
            &v23,
            a2,
            v14,
            0LL,
            v21,
            0LL);
    v16 = (__int64)&v23[-a1];
    if ( (v15 & 0xFFFFFFFB) == 0 && !*(v23 - 1) )
    {
      if ( v23 == (char *)a1 )
        _assert_fail((__int64)"data.__outbuf != (unsigned char *) dst", (__int64)"wcsrtombs.c", 0x7Au, "__wcsrtombs");
      if ( *(_DWORD *)v27 )
        _assert_fail((__int64)"__mbsinit (data.__statep)", (__int64)"wcsrtombs.c", 0x7Bu, "__wcsrtombs");
      *a2 = 0LL;
LABEL_23:
      --v16;
    }
  }
  else
  {
    v20 = *a2;
    v19 = v12 + 4 * j_wcslen(v20) + 4;
    v16 = 0LL;
    v22 = *v27;
    v27 = &v22;
    v24 = v29;
    do
    {
      v23 = v28;
      dl_mcount_wrapper_check((__int64)v11);
      v15 = v11(v10, &v23, &v20, v19, 0LL, v21, 0LL, 1LL);
      v16 += v23 - v28;
    }
    while ( v15 == 5 );
    if ( (v15 & 0xFFFFFFFB) == 0 )
    {
      if ( *(v23 - 1) )
        _assert_fail((__int64)"data.__outbuf[-1] == '\\0'", (__int64)"wcsrtombs.c", 0x5Eu, "__wcsrtombs");
      goto LABEL_23;
    }
  }
  v17 = v15 - 4;
  if ( v15 && v17 > 3 )
    _assert_fail(
      (__int64)"status == __GCONV_OK || status == __GCONV_EMPTY_INPUT || status == __GCONV_ILLEGAL_INPUT || status == __G"
               "CONV_INCOMPLETE_INPUT || status == __GCONV_FULL_OUTPUT",
      (__int64)"wcsrtombs.c",
      0x86u,
      "__wcsrtombs");
  if ( v15 && v17 > 1 )
  {
    v16 = -1LL;
    __writefsdword(0xFFFFFFC0, 0x54u);
  }
  return v16;
}
// 401048: using guessed type __int64 __fastcall j_wcslen(_QWORD);
// 401098: using guessed type __int64 __fastcall j_wcsnlen(_QWORD, _QWORD);
// 4A5140: using guessed type void *_wcsmbs_gconv_fcts_c;
// 4A51E0: using guessed type char *nl_C_LC_CTYPE;
// 463F30: using guessed type char var_188[8];

//----- (0000000000464220) ----------------------------------------------------
unsigned __int64 (__fastcall *wcsnlen())(__int64 a1, __int64 a2)
{
  unsigned __int64 (__fastcall *result)(__int64, __int64); // rax

  result = (unsigned __int64 (__fastcall *)(__int64, __int64))_wcsnlen_avx2;
  if ( (dword_4AAE4C & 0x20C00) != 3072 )
  {
    result = (unsigned __int64 (__fastcall *)(__int64, __int64))_wcsnlen_sse2;
    if ( (dword_4AAE10 & 0x80000) != 0 )
      return _wcsnlen_sse4_1;
  }
  return result;
}
// 4AAE10: using guessed type int dword_4AAE10;
// 4AAE4C: using guessed type int dword_4AAE4C;

//----- (0000000000464260) ----------------------------------------------------
int *__fastcall wcschrnul(int *a1, int a2)
{
  int v2; // edx
  int *result; // rax

  v2 = *a1;
  for ( result = a1; *result != a2; v2 = *result )
  {
    if ( !v2 )
      break;
    ++result;
  }
  return result;
}

//----- (0000000000464280) ----------------------------------------------------
unsigned __int64 __fastcall _wcsnlen_sse4_1(__int64 a1, __int64 a2)
{
  __m128i *v3; // rsi
  unsigned __int64 v4; // r10
  __m128i *v5; // r11
  __m128i v6; // xmm1
  __m128i v7; // xmm2
  __m128i v8; // xmm3
  signed __int64 v9; // rdx
  char v10; // cl
  __int64 v11; // rsi
  __m128i *v12; // rax
  unsigned __int64 v13; // rdx
  unsigned __int64 v14; // rax
  unsigned __int64 v15; // rdx

  if ( !a2 )
    return 0LL;
  v3 = (__m128i *)(a1 + 4 * a2);
  v4 = (unsigned __int64)v3 & 0xFFFFFFFFFFFFFFC0LL;
  v5 = v3;
  if ( ((unsigned __int16)a1 & 0xFFFu) > 0xFCFuLL )
  {
    v9 = (((unsigned int)_mm_movemask_epi8(_mm_cmpeq_epi32((__m128i)0LL, *(__m128i *)((a1 & 0xFFFFFFFFFFFFFFC0LL) + 0x20))) | ((unsigned __int64)(unsigned int)_mm_movemask_epi8(_mm_cmpeq_epi32((__m128i)0LL, *(__m128i *)((a1 & 0xFFFFFFFFFFFFFFC0LL) + 0x30))) << 16)) << 32) | (unsigned int)_mm_movemask_epi8(_mm_cmpeq_epi32((__m128i)0LL, *(__m128i *)(a1 & 0xFFFFFFFFFFFFFFC0LL))) | ((unsigned __int64)(unsigned int)_mm_movemask_epi8(_mm_cmpeq_epi32((__m128i)0LL, *(__m128i *)((a1 & 0xFFFFFFFFFFFFFFC0LL) + 0x10))) << 16);
    v10 = a1 & 0xC0 ^ a1;
    v11 = (__int64)v3->m128i_i64 - (a1 & 0xFFFFFFFFFFFFFFC0LL);
    v12 = (__m128i *)(a1 & 0xFFFFFFFFFFFFFFC0LL);
    if ( (v11 & 0xFFFFFFFFFFFFFFC0LL) != 0 )
    {
      v13 = v9 >> v10;
      if ( v13 )
        goto LABEL_11;
      goto LABEL_12;
    }
  }
  else
  {
    v6 = _mm_cmpeq_epi32((__m128i)0LL, *(__m128i *)((a1 & 0xFFFFFFFFFFFFFFF0LL) + 0x10));
    v7 = _mm_cmpeq_epi32((__m128i)0LL, *(__m128i *)((a1 & 0xFFFFFFFFFFFFFFF0LL) + 0x20));
    v8 = _mm_cmpeq_epi32((__m128i)0LL, *(__m128i *)((a1 & 0xFFFFFFFFFFFFFFF0LL) + 0x30));
    v9 = (((unsigned int)_mm_movemask_epi8(v7) | ((unsigned __int64)(unsigned int)_mm_movemask_epi8(v8) << 16)) << 32) | (unsigned int)_mm_movemask_epi8(_mm_cmpeq_epi32((__m128i)0LL, *(__m128i *)(a1 & 0xFFFFFFFFFFFFFFF0LL))) | ((unsigned __int64)(unsigned int)_mm_movemask_epi8(v6) << 16);
    v10 = a1 & 0xF0 ^ a1;
    v11 = (__int64)v3->m128i_i64 - (a1 & 0xFFFFFFFFFFFFFFF0LL);
    v12 = (__m128i *)(a1 & 0xFFFFFFFFFFFFFFC0LL);
    if ( (v11 & 0xFFFFFFFFFFFFFFC0LL) != 0 )
    {
      v13 = v9 >> v10;
      if ( !v13 )
        goto LABEL_13;
      goto LABEL_11;
    }
  }
  v13 = (v9 | (1LL << v11)) >> v10;
  if ( v13 )
  {
LABEL_11:
    _BitScanForward64(&v14, v13);
    return v14 >> 2;
  }
LABEL_12:
  v6 = 0LL;
  v7 = 0LL;
  v8 = 0LL;
LABEL_13:
  while ( 1 )
  {
    v12 += 4;
    if ( (__m128i *)v4 == v12 )
      break;
    v13 = (unsigned int)_mm_movemask_epi8(
                          _mm_cmpeq_epi32(
                            _mm_min_epu32(_mm_min_epu32(_mm_min_epu32(_mm_load_si128(v12), v12[1]), v12[2]), v12[3]),
                            v8));
    if ( (_DWORD)v13 )
    {
      _BitScanForward64(
        &v15,
        (((unsigned int)_mm_movemask_epi8(_mm_cmpeq_epi32(v7, v12[2])) | ((unsigned __int64)(unsigned int)_mm_movemask_epi8(_mm_cmpeq_epi32(v8, v12[3])) << 16)) << 32) | (unsigned int)_mm_movemask_epi8(_mm_cmpeq_epi32((__m128i)0LL, *v12)) | ((unsigned __int64)(unsigned int)_mm_movemask_epi8(_mm_cmpeq_epi32(v6, v12[1])) << 16));
      return ((unsigned __int64)v12->m128i_u64 + v15 - a1) >> 2;
    }
  }
  if ( v5 != v12 )
    v13 = (((unsigned int)_mm_movemask_epi8(_mm_cmpeq_epi32(v7, v12[2])) | ((unsigned __int64)(unsigned int)_mm_movemask_epi8(_mm_cmpeq_epi32(v8, v12[3])) << 16)) << 32) | (unsigned int)_mm_movemask_epi8(_mm_cmpeq_epi32((__m128i)0LL, *v12)) | ((unsigned __int64)(unsigned int)_mm_movemask_epi8(_mm_cmpeq_epi32(v6, v12[1])) << 16);
  _BitScanForward64(&v13, v13 | (1LL << (char)v5));
  return ((unsigned __int64)v12->m128i_u64 + v13 - a1) >> 2;
}

//----- (00000000004644A0) ----------------------------------------------------
__int64 __fastcall _wcsnlen_sse2(_DWORD *a1, __int64 a2)
{
  __int64 v2; // rdx
  __int64 result; // rax

  if ( !a2 || !*a1 )
    return 0LL;
  if ( a2 == 1 || !a1[1] )
    return 1LL;
  if ( a2 == 2 )
    return 2LL;
  v2 = 2LL;
  do
  {
    if ( !a1[v2] )
      break;
    result = v2 + 1;
    if ( a2 == 3 )
      return result;
    if ( !a1[v2 + 1] )
      return result;
    result = v2 + 2;
    a2 -= 4LL;
    if ( !a2 )
      return result;
    if ( !a1[v2 + 2] )
      return result;
    result = v2 + 3;
    if ( a2 == 1 || !a1[v2 + 3] )
      return result;
    v2 += 4LL;
  }
  while ( a2 != 2 );
  return v2;
}

//----- (0000000000464540) ----------------------------------------------------
unsigned __int64 __fastcall _wcslen_sse2(_DWORD *a1)
{
  char *v1; // rcx
  __m128i *v2; // rax
  __m128i v3; // xmm0
  int v4; // edx
  __m128i *v5; // rax
  __m128i v6; // xmm1
  __m128i v7; // xmm2
  __m128i v8; // xmm3
  __m128i v9; // xmm0
  __m128i v10; // xmm1
  __m128i v11; // xmm2
  __m128i v12; // xmm3
  __m128i v13; // xmm3
  __m128i v14; // xmm1
  __m128i v15; // xmm6
  int v16; // edx
  __m128i v17; // xmm3
  __m128i v18; // xmm3
  __m128i v19; // xmm3
  unsigned __int64 result; // rax

  if ( !*a1 )
    return 0LL;
  if ( !a1[1] )
    return 1LL;
  if ( !a1[2] )
    return 2LL;
  if ( !a1[3] )
    return 3LL;
  if ( !a1[4] )
    return 4LL;
  if ( !a1[5] )
    return 5LL;
  if ( !a1[6] )
    return 6LL;
  if ( !a1[7] )
    return 7LL;
  v1 = (char *)(a1 + 4);
  v2 = (__m128i *)((unsigned __int64)(a1 + 8) & 0xFFFFFFFFFFFFFFF0LL);
  v3 = _mm_cmpeq_epi32((__m128i)0LL, *v2);
  v4 = _mm_movemask_epi8(v3);
  v5 = v2 + 1;
  if ( !v4 )
  {
    v6 = _mm_cmpeq_epi32((__m128i)0LL, *v5);
    v4 = _mm_movemask_epi8(v6);
    ++v5;
    if ( !v4 )
    {
      v7 = _mm_cmpeq_epi32((__m128i)0LL, *v5);
      v4 = _mm_movemask_epi8(v7);
      ++v5;
      if ( !v4 )
      {
        v8 = _mm_cmpeq_epi32((__m128i)0LL, *v5);
        v4 = _mm_movemask_epi8(v8);
        ++v5;
        if ( !v4 )
        {
          v9 = _mm_cmpeq_epi32(v3, *v5);
          v4 = _mm_movemask_epi8(v9);
          ++v5;
          if ( !v4 )
          {
            v10 = _mm_cmpeq_epi32(v6, *v5);
            v4 = _mm_movemask_epi8(v10);
            ++v5;
            if ( !v4 )
            {
              v11 = _mm_cmpeq_epi32(v7, *v5);
              v4 = _mm_movemask_epi8(v11);
              ++v5;
              if ( !v4 )
              {
                v12 = _mm_cmpeq_epi32(v8, *v5);
                v4 = _mm_movemask_epi8(v12);
                ++v5;
                if ( !v4 )
                {
                  v4 = _mm_movemask_epi8(_mm_cmpeq_epi32(v9, *v5++));
                  if ( !v4 )
                  {
                    v4 = _mm_movemask_epi8(_mm_cmpeq_epi32(v10, *v5++));
                    if ( !v4 )
                    {
                      v4 = _mm_movemask_epi8(_mm_cmpeq_epi32(v11, *v5++));
                      if ( !v4 )
                      {
                        v13 = _mm_cmpeq_epi32(v12, *v5);
                        v4 = _mm_movemask_epi8(v13);
                        ++v5;
                        if ( !v4 )
                        {
                          v5 = (__m128i *)((unsigned __int64)v5 & 0xFFFFFFFFFFFFFFC0LL);
                          do
                          {
                            do
                            {
                              v14 = v5[1];
                              v15 = v5[3];
                              v16 = _mm_movemask_epi8(
                                      _mm_cmpeq_epi32(
                                        _mm_min_epu8(_mm_min_epu8(v5[2], v15), _mm_min_epu8(*v5, v14)),
                                        v13));
                              v5 += 4;
                            }
                            while ( !v16 );
                            v17 = _mm_cmpeq_epi32(v13, v5[-4]);
                            v4 = _mm_movemask_epi8(v17);
                            v1 += 48;
                            if ( v4 )
                              break;
                            v18 = _mm_cmpeq_epi32(v17, v14);
                            v4 = _mm_movemask_epi8(v18);
                            v1 -= 16;
                            if ( v4 )
                              break;
                            v19 = _mm_cmpeq_epi32(v18, v5[-2]);
                            v4 = _mm_movemask_epi8(v19);
                            v1 -= 16;
                            if ( v4 )
                              break;
                            v13 = _mm_cmpeq_epi32(v19, v15);
                            v4 = _mm_movemask_epi8(v13);
                            v1 -= 16;
                          }
                          while ( !v4 );
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  result = (unsigned __int64)((char *)v5 - v1) >> 2;
  if ( (_BYTE)v4 )
  {
    if ( (v4 & 0xF) == 0 )
      ++result;
  }
  else if ( (v4 & 0xF00) != 0 )
  {
    result += 2LL;
  }
  else
  {
    result += 3LL;
  }
  return result;
}

//----- (00000000004647E0) ----------------------------------------------------
unsigned __int64 __fastcall _wcslen_avx2(unsigned __int64 _RDI, __m128 _XMM0)
{
  unsigned __int64 v4; // rdx
  unsigned __int64 v7; // rcx
  unsigned __int64 v8; // rdi
  unsigned __int64 result; // rax

  v4 = _RDI;
  __asm { vpxor   xmm0, xmm0, xmm0 }
  if ( (_RDI & 0x3F) > 0x20 )
  {
    v7 = _RDI & 0x1F;
    v8 = _RDI & 0xFFFFFFFFFFFFFFE0LL;
    __asm
    {
      vpcmpeqd ymm1, ymm0, ymmword ptr [rdi]
      vpmovmskb eax, ymm1
    }
    _RAX = (unsigned int)(_EAX >> v7);
    if ( (_DWORD)_RAX )
    {
      __asm { tzcnt   eax, eax }
      result = (v7 + v8 + _RAX - v4) >> 2;
      __asm { vzeroupper }
      return result;
    }
    _RDI = v8 + 32;
  }
  else
  {
    __asm
    {
      vpcmpeqd ymm1, ymm0, ymmword ptr [rdi]
      vpmovmskb eax, ymm1
    }
    if ( (_DWORD)_RAX )
      goto LABEL_14;
    _RDI = (_RDI + 32) & 0xFFFFFFFFFFFFFFE0LL;
  }
  __asm
  {
    vpcmpeqd ymm1, ymm0, ymmword ptr [rdi]
    vpmovmskb eax, ymm1
  }
  if ( (_DWORD)_RAX )
    goto LABEL_14;
  __asm
  {
    vpcmpeqd ymm1, ymm0, ymmword ptr [rdi+20h]
    vpmovmskb eax, ymm1
  }
  if ( (_DWORD)_RAX )
    goto LABEL_15;
  __asm
  {
    vpcmpeqd ymm1, ymm0, ymmword ptr [rdi+40h]
    vpmovmskb eax, ymm1
  }
  if ( (_DWORD)_RAX )
    goto LABEL_16;
  __asm
  {
    vpcmpeqd ymm1, ymm0, ymmword ptr [rdi+60h]
    vpmovmskb eax, ymm1
  }
  if ( !(_DWORD)_RAX )
  {
    for ( _RDI = (_RDI + 128) & 0xFFFFFFFFFFFFFF80LL; ; _RDI += 128LL )
    {
      __asm
      {
        vmovdqa ymm1, ymmword ptr [rdi]
        vmovdqa ymm2, ymmword ptr [rdi+20h]
        vmovdqa ymm3, ymmword ptr [rdi+40h]
        vmovdqa ymm4, ymmword ptr [rdi+60h]
        vpminud ymm5, ymm2, ymm1
        vpminud ymm6, ymm4, ymm3
        vpminud ymm5, ymm6, ymm5
        vpcmpeqd ymm5, ymm0, ymm5
        vpmovmskb eax, ymm5
      }
      if ( _EAX )
        break;
    }
    __asm
    {
      vpcmpeqd ymm1, ymm0, ymm1
      vpmovmskb eax, ymm1
    }
    if ( !(_DWORD)_RAX )
    {
      __asm
      {
        vpcmpeqd ymm2, ymm0, ymm2
        vpmovmskb eax, ymm2
      }
      if ( !(_DWORD)_RAX )
      {
        __asm
        {
          vpcmpeqd ymm3, ymm0, ymm3
          vpmovmskb eax, ymm3
        }
        if ( !(_DWORD)_RAX )
        {
          __asm
          {
            vpcmpeqd ymm4, ymm0, ymm4
            vpmovmskb eax, ymm4
          }
          goto LABEL_21;
        }
LABEL_16:
        __asm { tzcnt   eax, eax }
        result = (_RDI + _RAX + 64 - v4) >> 2;
        __asm { vzeroupper }
        return result;
      }
LABEL_15:
      __asm { tzcnt   eax, eax }
      result = (_RDI + _RAX + 32 - v4) >> 2;
      __asm { vzeroupper }
      return result;
    }
LABEL_14:
    __asm { tzcnt   eax, eax }
    result = (_RDI + _RAX - v4) >> 2;
    __asm { vzeroupper }
    return result;
  }
LABEL_21:
  __asm { tzcnt   eax, eax }
  result = (_RDI + _RAX + 96 - v4) >> 2;
  __asm { vzeroupper }
  return result;
}
// 4648F4: variable '_RAX' is possibly undefined

//----- (00000000004649A0) ----------------------------------------------------
unsigned __int64 __fastcall _wcsnlen_avx2(unsigned __int64 _RDI, __int64 a2, __m128 _XMM0)
{
  unsigned __int64 v5; // rsi
  unsigned __int64 v6; // r8
  unsigned __int64 v7; // rdx
  unsigned int v9; // ecx
  char v11; // cc
  unsigned __int64 v12; // rsi
  unsigned __int64 v13; // rsi
  unsigned __int64 v14; // rsi
  unsigned __int64 v15; // rcx
  unsigned __int64 v16; // rdi
  unsigned __int64 result; // rax
  unsigned __int64 v20; // rcx
  unsigned __int64 v21; // rsi
  unsigned __int64 v26; // rcx
  unsigned __int64 v36; // rsi
  unsigned __int64 v40; // rsi
  unsigned __int64 v43; // rsi

  if ( !a2 )
    return 0LL;
  v5 = 4 * a2;
  v6 = v5;
  v7 = _RDI;
  __asm { vpxor   xmm0, xmm0, xmm0 }
  v9 = _RDI & 0x3F;
  if ( v9 > 0x20 )
  {
    v15 = _RDI & 0x1F;
    v16 = _RDI & 0xFFFFFFFFFFFFFFE0LL;
    __asm
    {
      vpcmpeqd ymm1, ymm0, ymmword ptr [rdi]
      vpmovmskb eax, ymm1
    }
    _RAX = (unsigned int)(_EAX >> v15);
    if ( (_DWORD)_RAX )
    {
      __asm { tzcnt   eax, eax }
      if ( v5 > _RAX )
      {
        result = (v15 + v16 + _RAX - v7) >> 2;
        __asm { vzeroupper }
        return result;
      }
      goto LABEL_39;
    }
    v20 = 32 - v15;
    v11 = v5 <= v20;
    v21 = v5 - v20;
    if ( v11 )
    {
LABEL_39:
      result = v6 >> 2;
      __asm { vzeroupper }
      return result;
    }
    _RDI = v16 + 32;
    v11 = v21 <= 0x80;
    v14 = v21 - 128;
    if ( v11 )
      goto LABEL_20;
  }
  else
  {
    __asm
    {
      vpcmpeqd ymm1, ymm0, ymmword ptr [rdi]
      vpmovmskb eax, ymm1
    }
    if ( (_DWORD)_RAX )
      goto LABEL_31;
    v11 = v5 <= 0x20;
    v12 = v5 - 32;
    if ( v11 )
      goto LABEL_39;
    _RDI = (_RDI + 32) & 0xFFFFFFFFFFFFFFE0LL;
    v13 = (v9 & 0x1F) + v12;
    v11 = v13 <= 0x80;
    v14 = v13 - 128;
    if ( v11 )
    {
LABEL_20:
      v11 = ((int)v14 + 64 < 0) ^ __OFADD__(64, (_DWORD)v14) | ((_DWORD)v14 == -64);
      v36 = (unsigned int)(v14 + 64);
      if ( !v11 )
      {
        __asm
        {
          vpcmpeqd ymm1, ymm0, ymmword ptr [rdi]
          vpmovmskb eax, ymm1
        }
        if ( (_DWORD)_RAX )
          goto LABEL_41;
        __asm
        {
          vpcmpeqd ymm1, ymm0, ymmword ptr [rdi+20h]
          vpmovmskb eax, ymm1
        }
        if ( (_DWORD)_RAX )
          goto LABEL_42;
        __asm
        {
          vpcmpeqd ymm1, ymm0, ymmword ptr [rdi+40h]
          vpmovmskb eax, ymm1
        }
        if ( (_DWORD)_RAX )
        {
          __asm { tzcnt   eax, eax }
          if ( v36 > _RAX )
          {
            result = (_RDI + _RAX + 64 - v7) >> 2;
            __asm { vzeroupper }
            return result;
          }
        }
        else
        {
          v11 = (int)v36 <= 32;
          v40 = (unsigned int)(v36 - 32);
          if ( !v11 )
          {
            __asm
            {
              vpcmpeqd ymm1, ymm0, ymmword ptr [rdi+60h]
              vpmovmskb eax, ymm1
            }
            if ( !(_DWORD)_RAX )
            {
              result = v6 >> 2;
              __asm { vzeroupper }
              return result;
            }
            __asm { tzcnt   eax, eax }
            if ( v40 > _RAX )
            {
              result = (_RDI + _RAX + 96 - v7) >> 2;
              __asm { vzeroupper }
              return result;
            }
          }
        }
        goto LABEL_39;
      }
      v5 = (unsigned int)(v36 + 64);
      __asm
      {
        vpcmpeqd ymm1, ymm0, ymmword ptr [rdi]
        vpmovmskb eax, ymm1
      }
      if ( !(_DWORD)_RAX )
      {
        v11 = (int)v5 <= 32;
        v43 = (unsigned int)(v5 - 32);
        if ( !v11 )
        {
          __asm
          {
            vpcmpeqd ymm1, ymm0, ymmword ptr [rdi+20h]
            vpmovmskb eax, ymm1
          }
          if ( !(_DWORD)_RAX )
          {
            result = v6 >> 2;
            __asm { vzeroupper }
            return result;
          }
          __asm { tzcnt   eax, eax }
          if ( v43 > _RAX )
          {
            result = (_RDI + _RAX + 32 - v7) >> 2;
            __asm { vzeroupper }
            return result;
          }
        }
        goto LABEL_39;
      }
LABEL_31:
      __asm { tzcnt   eax, eax }
      if ( v5 > _RAX )
      {
        result = (_RDI + _RAX - v7) >> 2;
        __asm { vzeroupper }
        return result;
      }
      goto LABEL_39;
    }
  }
  __asm
  {
    vpcmpeqd ymm1, ymm0, ymmword ptr [rdi]
    vpmovmskb eax, ymm1
  }
  if ( (_DWORD)_RAX )
    goto LABEL_41;
  __asm
  {
    vpcmpeqd ymm1, ymm0, ymmword ptr [rdi+20h]
    vpmovmskb eax, ymm1
  }
  if ( (_DWORD)_RAX )
    goto LABEL_42;
  __asm
  {
    vpcmpeqd ymm1, ymm0, ymmword ptr [rdi+40h]
    vpmovmskb eax, ymm1
  }
  if ( (_DWORD)_RAX )
    goto LABEL_43;
  __asm
  {
    vpcmpeqd ymm1, ymm0, ymmword ptr [rdi+60h]
    vpmovmskb eax, ymm1
  }
  if ( !(_DWORD)_RAX )
  {
    _RDI += 128LL;
    v11 = v14 <= 0x80;
    v14 -= 128LL;
    if ( !v11 )
    {
      v26 = _RDI & 0x7F;
      _RDI &= 0xFFFFFFFFFFFFFF80LL;
      v14 += v26;
      while ( 1 )
      {
        __asm
        {
          vmovdqa ymm1, ymmword ptr [rdi]
          vmovdqa ymm2, ymmword ptr [rdi+20h]
          vmovdqa ymm3, ymmword ptr [rdi+40h]
          vmovdqa ymm4, ymmword ptr [rdi+60h]
          vpminud ymm5, ymm2, ymm1
          vpminud ymm6, ymm4, ymm3
          vpminud ymm5, ymm6, ymm5
          vpcmpeqd ymm5, ymm0, ymm5
          vpmovmskb eax, ymm5
        }
        if ( _EAX )
          break;
        _RDI += 128LL;
        v11 = v14 <= 0x80;
        v14 -= 128LL;
        if ( v11 )
          goto LABEL_20;
      }
      __asm
      {
        vpcmpeqd ymm1, ymm0, ymm1
        vpmovmskb eax, ymm1
      }
      if ( !(_DWORD)_RAX )
      {
        __asm
        {
          vpcmpeqd ymm2, ymm0, ymm2
          vpmovmskb eax, ymm2
        }
        if ( !(_DWORD)_RAX )
        {
          __asm
          {
            vpcmpeqd ymm3, ymm0, ymm3
            vpmovmskb eax, ymm3
          }
          if ( !(_DWORD)_RAX )
          {
            __asm
            {
              vpcmpeqd ymm4, ymm0, ymm4
              vpmovmskb eax, ymm4
            }
            goto LABEL_48;
          }
LABEL_43:
          __asm { tzcnt   eax, eax }
          result = (_RDI + _RAX + 64 - v7) >> 2;
          __asm { vzeroupper }
          return result;
        }
LABEL_42:
        __asm { tzcnt   eax, eax }
        result = (_RDI + _RAX + 32 - v7) >> 2;
        __asm { vzeroupper }
        return result;
      }
LABEL_41:
      __asm { tzcnt   eax, eax }
      result = (_RDI + _RAX - v7) >> 2;
      __asm { vzeroupper }
      return result;
    }
    goto LABEL_20;
  }
LABEL_48:
  __asm { tzcnt   eax, eax }
  result = (_RDI + _RAX + 96 - v7) >> 2;
  __asm { vzeroupper }
  return result;
}
// 464BA7: variable '_RAX' is possibly undefined

//----- (0000000000464CF0) ----------------------------------------------------
signed __int64 __fastcall time(time_t *a1)
{
  return sys_time(a1);
}

//----- (0000000000464D00) ----------------------------------------------------
_QWORD *__fastcall _alloc_dir(unsigned int a1, __int64 a2, _QWORD *a3, __int64 a4, u32 *a5, __int64 a6)
{
  char v6; // r13
  unsigned __int64 v9; // rdi
  unsigned __int64 v10; // rbp
  _QWORD *v11; // rdx
  __int64 v12; // rcx
  _QWORD *v13; // rbx
  u32 *v14; // r8
  __int64 v15; // r9
  unsigned int v17; // er13

  v6 = a2;
  if ( !(_BYTE)a2 )
  {
    a2 = 2LL;
    if ( (_fcntl64_nocancel(a1, 2u, 1uLL) & 0x80000000) != 0LL )
      return 0LL;
  }
  v9 = 32816LL;
  v10 = 0x8000LL;
  if ( a4 )
  {
    v10 = 0x8000LL;
    if ( *(_QWORD *)(a4 + 56) >= 0x8000uLL )
      v10 = *(_QWORD *)(a4 + 56);
    if ( v10 > 0x100000 )
      v10 = 0x100000LL;
    v9 = v10 + 48;
  }
  v13 = malloc(v9, a2, a3, a4, a5, a6);
  if ( !v13 )
  {
    v10 = 0x2000LL;
    v13 = malloc(0x2030uLL, a2, v11, v12, v14, v15);
    if ( !v13 )
    {
      if ( v6 )
      {
        v17 = __readfsdword(0xFFFFFFC0);
        _close_nocancel(a1);
        __writefsdword(0xFFFFFFC0, v17);
        return v13;
      }
      return 0LL;
    }
  }
  *(_DWORD *)v13 = a1;
  *((_DWORD *)v13 + 1) = 0;
  v13[1] = v10;
  v13[2] = 0LL;
  v13[3] = 0LL;
  v13[4] = 0LL;
  *((_DWORD *)v13 + 10) = 0;
  return v13;
}
// 464D55: variable 'a3' is possibly undefined
// 464D55: variable 'a4' is possibly undefined
// 464D55: variable 'a5' is possibly undefined
// 464D55: variable 'a6' is possibly undefined
// 464DCA: variable 'v11' is possibly undefined
// 464DCA: variable 'v12' is possibly undefined
// 464DCA: variable 'v14' is possibly undefined
// 464DCA: variable 'v15' is possibly undefined

//----- (0000000000464E00) ----------------------------------------------------
_QWORD *__fastcall opendir_tail(signed int a1)
{
  u32 *v1; // r8
  __int64 v2; // r9
  struct stat v4; // [rsp+0h] [rbp-B8h] BYREF
  unsigned __int64 v5; // [rsp+98h] [rbp-20h]

  v5 = __readfsqword(0x28u);
  if ( a1 < 0 )
    return 0LL;
  if ( (fxstat(1u, a1, &v4) & 0x80000000) == 0LL )
  {
    if ( (v4.st_mode & 0xF000) == 0x4000 )
      return _alloc_dir(a1, 1LL, 0LL, (__int64)&v4, v1, v2);
    __writefsdword(0xFFFFFFC0, 0x14u);
  }
  _close_nocancel(a1);
  return 0LL;
}
// 464E58: variable 'v1' is possibly undefined
// 464E58: variable 'v2' is possibly undefined

//----- (0000000000464EB0) ----------------------------------------------------
_QWORD *__fastcall _opendirat(int a1, const char *a2, __int64 a3, int a4)
{
  signed int v4; // eax

  if ( *a2 )
  {
    v4 = _openat_nocancel(a1, a2, 591872, a4);
    return opendir_tail(v4);
  }
  else
  {
    __writefsdword(0xFFFFFFC0, 2u);
    return 0LL;
  }
}

//----- (0000000000464EF0) ----------------------------------------------------
_QWORD *__fastcall opendir(const char *a1, __int64 a2, int a3)
{
  signed int v3; // eax

  if ( *a1 )
  {
    v3 = _open_nocancel(a1, 591872, a3);
    return opendir_tail(v3);
  }
  else
  {
    __writefsdword(0xFFFFFFC0, 2u);
    return 0LL;
  }
}

//----- (0000000000464F30) ----------------------------------------------------
unsigned __int64 __fastcall closedir(
        unsigned int *a1,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        u32 *a5,
        unsigned __int64 a6)
{
  unsigned int v6; // ebx

  if ( a1 )
  {
    v6 = *a1;
    free((__int64)a1, a2, a3, a4, a5, a6);
    return _close_nocancel(v6);
  }
  else
  {
    __writefsdword(0xFFFFFFC0, 0x16u);
    return 0xFFFFFFFFLL;
  }
}

//----- (0000000000464F60) ----------------------------------------------------
unsigned __int64 __fastcall rewinddir(__int64 a1, __int64 a2, __int64 a3, __int64 a4, u32 *a5, u32 a6)
{
  bool v8; // zf
  unsigned __int64 result; // rax
  __int64 v10; // rdx
  __int64 v11; // rcx
  u32 *v12; // r8
  u32 v13; // er9

  _ESI = 1;
  _RBX = a1;
  v8 = _libc_multiple_threads == 0;
  if ( !_libc_multiple_threads )
  {
    __asm { cmpxchg [rbx+4], esi }
    if ( v8 )
      goto LABEL_6;
    goto LABEL_5;
  }
  if ( _InterlockedCompareExchange((volatile signed __int32 *)(a1 + 4), 1, 0) )
LABEL_5:
    _lll_lock_wait_private((u32 *)(a1 + 4), 1LL, a3, a4, a5, a6);
LABEL_6:
  result = lseek64(*(_DWORD *)a1, 0LL, 0);
  *(_QWORD *)(a1 + 32) = 0LL;
  *(_QWORD *)(a1 + 24) = 0LL;
  *(_QWORD *)(a1 + 16) = 0LL;
  *(_DWORD *)(a1 + 40) = 0;
  if ( !_libc_multiple_threads )
  {
    v8 = (*(_DWORD *)(a1 + 4))-- == 1;
    if ( v8 )
      return result;
    return _lll_unlock_wake_private((u32 *)(a1 + 4), 0LL, v10, v11, v12, v13);
  }
  if ( _InterlockedDecrement((volatile signed __int32 *)(a1 + 4)) )
    return _lll_unlock_wake_private((u32 *)(a1 + 4), 0LL, v10, v11, v12, v13);
  return result;
}
// 464FE9: variable 'v10' is possibly undefined
// 464FE9: variable 'v11' is possibly undefined
// 464FE9: variable 'v12' is possibly undefined
// 464FE9: variable 'v13' is possibly undefined
// 4AB820: using guessed type int _libc_multiple_threads;

//----- (0000000000465000) ----------------------------------------------------
__int64 __fastcall readdir64(__int64 a1, __int64 a2, __int64 a3, __int64 a4, u32 *a5, u32 a6)
{
  unsigned int v8; // er13
  bool v9; // zf
  unsigned __int64 v10; // rax
  __int64 v11; // rdx
  __int64 v12; // rcx
  __int64 v13; // rdx
  signed __int64 v14; // rax

  _RSI = 1LL;
  _RBX = a1;
  v8 = __readfsdword(0xFFFFFFC0);
  v9 = _libc_multiple_threads == 0;
  if ( _libc_multiple_threads )
  {
    if ( !_InterlockedCompareExchange((volatile signed __int32 *)(a1 + 4), 1, 0) )
      goto LABEL_6;
    goto LABEL_5;
  }
  __asm { cmpxchg [rbx+4], esi }
  if ( !v9 )
LABEL_5:
    _lll_lock_wait_private((u32 *)(a1 + 4), 1LL, a3, a4, a5, a6);
LABEL_6:
  v10 = *(_QWORD *)(a1 + 24);
  while ( 1 )
  {
    v13 = v10 + 48;
    if ( *(_QWORD *)(a1 + 16) <= v10 )
      break;
LABEL_7:
    v11 = a1 + v13;
    v10 += *(unsigned __int16 *)(v11 + 16);
    v12 = *(_QWORD *)(v11 + 8);
    v9 = *(_QWORD *)v11 == 0LL;
    *(_QWORD *)(a1 + 24) = v10;
    *(_QWORD *)(a1 + 32) = v12;
    if ( !v9 )
      goto LABEL_13;
  }
  _RSI = a1 + 48;
  v14 = _getdents64(*(_DWORD *)a1, (struct linux_dirent64 *)(a1 + 48), *(_QWORD *)(a1 + 8));
  if ( v14 > 0 )
  {
    *(_QWORD *)(a1 + 16) = v14;
    v13 = 48LL;
    v10 = 0LL;
    goto LABEL_7;
  }
  if ( !v14 || (v11 = 0LL, __readfsdword(0xFFFFFFC0) == 2) )
  {
    __writefsdword(0xFFFFFFC0, v8);
    v11 = 0LL;
  }
LABEL_13:
  if ( _libc_multiple_threads )
  {
    if ( !_InterlockedDecrement((volatile signed __int32 *)(a1 + 4)) )
      return v11;
LABEL_17:
    _lll_unlock_wake_private((u32 *)(a1 + 4), _RSI, v11, v12, a5, a6);
  }
  else
  {
    v9 = (*(_DWORD *)(a1 + 4))-- == 1;
    if ( !v9 )
      goto LABEL_17;
  }
  return v11;
}
// 4650DA: variable 'v12' is possibly undefined
// 4650DA: variable 'a5' is possibly undefined
// 4650DA: variable 'a6' is possibly undefined
// 4650EA: variable 'v11' is possibly undefined
// 4AB820: using guessed type int _libc_multiple_threads;

//----- (0000000000465100) ----------------------------------------------------
_QWORD *__fastcall fdopendir(unsigned int a1)
{
  unsigned __int64 v1; // rdx
  unsigned int v2; // eax
  u32 *v3; // r8
  __int64 v4; // r9
  struct stat _0; // [rsp+0h] [rbp+0h] BYREF
  unsigned __int64 vars98; // [rsp+98h] [rbp+98h]

  vars98 = __readfsqword(0x28u);
  if ( (fxstat(1u, a1, &_0) & 0x80000000) != 0LL )
    return 0LL;
  if ( (_0.st_mode & 0xF000) != 0x4000 )
  {
    __writefsdword(0xFFFFFFC0, 0x14u);
    return 0LL;
  }
  v2 = _fcntl64_nocancel(a1, 3u, v1);
  if ( v2 == -1 )
    return 0LL;
  if ( (v2 & 3) != 1 )
    return _alloc_dir(a1, 0LL, (_QWORD *)v2, (__int64)&_0, v3, v4);
  __writefsdword(0xFFFFFFC0, 0x16u);
  return 0LL;
}
// 465151: variable 'v1' is possibly undefined
// 46516E: variable 'v3' is possibly undefined
// 46516E: variable 'v4' is possibly undefined

//----- (00000000004651C0) ----------------------------------------------------
unsigned __int64 __fastcall uname(struct old_utsname *a1)
{
  unsigned __int64 result; // rax

  result = sys_uname(a1);
  if ( result >= 0xFFFFFFFFFFFFF001LL )
  {
    __writefsdword(0xFFFFFFC0, -(int)result);
    return -1LL;
  }
  return result;
}

//----- (00000000004651F0) ----------------------------------------------------
signed __int64 getuid()
{
  return sys_getuid();
}

//----- (0000000000465200) ----------------------------------------------------
signed __int64 geteuid()
{
  return sys_geteuid();
}

//----- (0000000000465210) ----------------------------------------------------
signed __int64 getgid()
{
  return sys_getgid();
}

//----- (0000000000465220) ----------------------------------------------------
signed __int64 getegid()
{
  return sys_getegid();
}

//----- (0000000000465230) ----------------------------------------------------
__int64 __fastcall lxstat(unsigned int a1)
{
  __int64 result; // rax

  if ( a1 > 1 )
  {
    __writefsdword(0xFFFFFFC0, 0x16u);
    return 0xFFFFFFFFLL;
  }
  else
  {
    result = 6LL;
    __asm { syscall; LINUX - sys_lstat }
  }
  return result;
}

//----- (0000000000465290) ----------------------------------------------------
unsigned __int64 __fastcall _fxstatat64(unsigned int a1, int a2, const char *a3, struct stat *a4, int a5)
{
  unsigned __int64 result; // rax

  if ( a1 > 1 )
  {
    __writefsdword(0xFFFFFFC0, 0x16u);
    return 0xFFFFFFFFLL;
  }
  else
  {
    result = sys_newfstatat(a2, a3, a4, a5);
    if ( result > 0xFFFFFFFFFFFFF000LL )
    {
      __writefsdword(0xFFFFFFC0, -(int)result);
      return 0xFFFFFFFFLL;
    }
  }
  return result;
}

//----- (00000000004652F0) ----------------------------------------------------
_BOOL8 __fastcall isatty(unsigned int a1)
{
  return (unsigned int)tcgetattr(a1) == 0;
}

//----- (0000000000465340) ----------------------------------------------------
unsigned __int64 __fastcall tcgetattr(unsigned int a1)
{
  unsigned __int64 result; // rax
  __int64 v2; // r8
  __int64 v3; // rdx
  __m128i v4; // xmm0
  __int16 v5; // si
  char v6; // cl
  __int64 v7; // rdx
  __int64 v8; // [rsp+0h] [rbp-38h] BYREF
  __int64 v9; // [rsp+8h] [rbp-30h]
  char v10; // [rsp+10h] [rbp-28h]
  __m128i v11; // [rsp+11h] [rbp-27h] BYREF
  __int16 v12; // [rsp+21h] [rbp-17h]
  char v13; // [rsp+23h] [rbp-15h]
  unsigned __int64 v14; // [rsp+28h] [rbp-10h]

  v14 = __readfsqword(0x28u);
  result = sys_ioctl(a1, 0x5401u, (unsigned __int64)&v8);
  if ( result > 0xFFFFFFFFFFFFF000LL )
  {
    __writefsdword(0xFFFFFFC0, -(int)result);
    return 0xFFFFFFFFLL;
  }
  else if ( !(_DWORD)result )
  {
    v3 = v8;
    v4 = _mm_loadu_si128(&v11);
    *(_QWORD *)(v2 + 36) = 0LL;
    v5 = v12;
    v6 = v13;
    *(_QWORD *)v2 = v3;
    v7 = v9;
    *(__m128i *)(v2 + 17) = v4;
    *(_QWORD *)(v2 + 8) = v7;
    LOBYTE(v7) = v10;
    *(_WORD *)(v2 + 33) = v5;
    *(_BYTE *)(v2 + 16) = v7;
    LOWORD(v7) = v9;
    *(_BYTE *)(v2 + 35) = v6;
    LODWORD(v7) = v7 & 0x100F;
    *(_DWORD *)(v2 + 52) = v7;
    *(_DWORD *)(v2 + 56) = v7;
    *(_DWORD *)(v2 + 44) = 0;
    *(_BYTE *)(v2 + 48) = 0;
  }
  return result;
}
// 465385: variable 'v2' is possibly undefined

//----- (0000000000465410) ----------------------------------------------------
__int64 __fastcall brk(unsigned __int64 a1)
{
  unsigned __int64 v1; // rax
  __int64 result; // rax

  v1 = sys_brk(a1);
  if ( v1 > 0xFFFFFFFFFFFFF000LL )
  {
    __writefsdword(0xFFFFFFC0, -(int)v1);
    result = 0LL;
    _curbrk = -1LL;
  }
  else
  {
    _curbrk = v1;
    if ( a1 > v1 )
    {
      __writefsdword(0xFFFFFFC0, 0xCu);
      return 0xFFFFFFFFLL;
    }
    else
    {
      return 0LL;
    }
  }
  return result;
}
// 4AB008: using guessed type __int64 _curbrk;

//----- (0000000000465470) ----------------------------------------------------
__int64 __fastcall wctrans(__int64 a1)
{
  unsigned __int64 v1; // rax
  __int64 v2; // r13
  _BYTE *v3; // rbx
  __int64 v4; // rbp

  v1 = __readfsqword(0xFFFFFFA0);
  v2 = *(_QWORD *)v1;
  v3 = *(_BYTE **)(*(_QWORD *)v1 + 152LL);
  if ( !*v3 )
    return 0LL;
  v4 = 0LL;
  while ( (unsigned int)j_strcmp_ifunc(a1, v3) )
  {
    ++v4;
    v3 += j_strlen_ifunc(v3) + 1;
    if ( !*v3 )
      return 0LL;
  }
  return *(_QWORD *)(v2 + 8 * (v4 + *(unsigned int *)(v2 + 208) + 8));
}
// 4010A0: using guessed type __int64 __fastcall j_strcmp_ifunc(_QWORD, _QWORD);
// 4010C8: using guessed type __int64 __fastcall j_strlen_ifunc(_QWORD);

//----- (0000000000465500) ----------------------------------------------------
__int64 __fastcall towctrans(unsigned int a1, _DWORD *a2)
{
  __int64 result; // rax
  unsigned int v3; // edx
  __int64 v4; // rdx
  __int64 v5; // rdx

  result = a1;
  if ( a2 )
  {
    v3 = a1 >> *a2;
    if ( v3 < a2[1] )
    {
      v4 = (unsigned int)a2[v3 + 5];
      if ( (_DWORD)v4 )
      {
        v5 = *(unsigned int *)((char *)&a2[a2[3] & (a1 >> a2[2])] + v4);
        if ( (_DWORD)v5 )
          return *(_DWORD *)((char *)&a2[a2[4] & a1] + v5) + a1;
      }
    }
  }
  return result;
}

//----- (0000000000465550) ----------------------------------------------------
__int64 __fastcall _readonly_area(
        unsigned __int64 a1,
        unsigned __int64 a2,
        __int64 a3,
        __int64 a4,
        u32 *a5,
        __int64 a6)
{
  const char *v8; // rsi
  unsigned int *v9; // rax
  unsigned int *v10; // rcx
  u32 *v11; // r8
  unsigned __int64 v12; // r9
  unsigned int *v13; // rbx
  unsigned int v14; // eax
  __int64 v15; // rdx
  unsigned __int64 v16; // r13
  unsigned __int64 v17; // r14
  char *v18; // rax
  char *v19; // rdi
  unsigned __int64 v20; // rax
  __int64 v21; // rdx
  __int64 v22; // rcx
  u32 *v23; // r8
  unsigned __int64 v24; // r9
  unsigned int v26; // eax
  char *v27; // [rsp+28h] [rbp-60h] BYREF
  __int64 v28; // [rsp+30h] [rbp-58h] BYREF
  char *v29; // [rsp+38h] [rbp-50h] BYREF
  char *v30[9]; // [rsp+40h] [rbp-48h] BYREF

  v8 = "rce";
  v30[1] = (char *)__readfsqword(0x28u);
  v9 = (unsigned int *)fopen64("/proc/self/maps", "rce", a3, a4, a5, a6);
  if ( v9 )
  {
    v13 = v9;
    v14 = *v9;
    v15 = v14;
    BYTE1(v15) = BYTE1(v14) | 0x80;
    *v13 = v15;
    v27 = 0LL;
    v28 = 0LL;
    if ( (v14 & 0x10) == 0 )
    {
      v16 = a1 + a2;
      do
      {
        v8 = (const char *)&v28;
        if ( getdelim((__int64 *)&v27, (__int64)&v28, 10LL, v13, v11, v12) <= 0 )
          break;
        v8 = (const char *)&v29;
        v17 = strtouq(v27, &v29, 16);
        v18 = v29;
        if ( v29 == v27 )
          break;
        v19 = ++v29;
        if ( *v18 != 45 )
          break;
        v8 = (const char *)v30;
        v20 = strtouq(v19, v30, 16);
        v15 = (__int64)v30[0];
        if ( v30[0] == v29 )
          break;
        v8 = ++v30[0];
        if ( *(_BYTE *)v15 != 32 )
          break;
        if ( v16 > v17 && a1 < v20 )
        {
          v8 = (const char *)(v15 + 2);
          v30[0] = (char *)(v15 + 2);
          if ( *(_BYTE *)(v15 + 1) != 114 )
            break;
          v8 = (const char *)(v15 + 3);
          v30[0] = (char *)(v15 + 3);
          if ( *(_BYTE *)(v15 + 2) != 45 )
            break;
          if ( a1 >= v17 && v16 <= v20 )
          {
            a2 = 0LL;
            break;
          }
          if ( a1 >= v17 )
          {
            a2 = a1 + a2 - v20;
          }
          else if ( v16 > v20 )
          {
            a2 = v17 + a2 - v20;
          }
          else
          {
            a2 = v17 + a2 - v16;
          }
          if ( !a2 )
            break;
        }
      }
      while ( (*(_BYTE *)v13 & 0x10) == 0 );
    }
    fclose((__int64)v13, (__int64)v8, v15, v10, v11, v12);
    free((__int64)v27, (__int64)v8, v21, v22, v23, v24);
    if ( a2 )
      return 0xFFFFFFFFLL;
  }
  else
  {
    v26 = __readfsdword(0xFFFFFFC0);
    if ( v26 != 2 && v26 != 13 )
      return 0xFFFFFFFFLL;
  }
  return 1LL;
}
// 465610: variable 'v11' is possibly undefined
// 465610: variable 'v12' is possibly undefined
// 4656DB: variable 'v15' is possibly undefined
// 4656DB: variable 'v10' is possibly undefined
// 4656E5: variable 'v21' is possibly undefined
// 4656E5: variable 'v22' is possibly undefined
// 4656E5: variable 'v23' is possibly undefined
// 4656E5: variable 'v24' is possibly undefined

//----- (0000000000465750) ----------------------------------------------------
__int64 __fastcall is_dst(_BYTE *a1, __int64 a2)
{
  __int64 v2; // rax
  __int64 v3; // rbx
  char v5; // dl
  __int64 v6; // r13

  v2 = j_strlen_ifunc(a2);
  v3 = v2;
  if ( *a1 != 123 )
  {
    if ( (unsigned int)j_strncmp_ifunc(a1, a2, v2) )
      return 0LL;
    v5 = a1[v3];
    if ( (unsigned __int8)((v5 & 0xDF) - 65) <= 0x19u || (unsigned __int8)(v5 - 48) <= 9u || v5 == 95 )
      return 0LL;
    return v3;
  }
  v6 = v2;
  v3 = 0LL;
  if ( (unsigned int)j_strncmp_ifunc(a1 + 1, a2, v2) || a1[v6 + 1] != 125 )
    return v3;
  return v6 + 2;
}
// 401078: using guessed type __int64 __fastcall j_strncmp_ifunc(_QWORD, _QWORD, _QWORD);
// 4010C8: using guessed type __int64 __fastcall j_strlen_ifunc(_QWORD);

//----- (0000000000465800) ----------------------------------------------------
_BOOL8 __fastcall is_trusted_path_normalize(char *a1, __int64 a2)
{
  __int64 v2; // rbp
  __int64 *v3; // rdx
  void *v4; // rsp
  char v5; // al
  __int64 *v6; // rdx
  char v7; // cl
  char *v8; // rax
  unsigned __int64 v9; // rax
  char v11; // r8
  char v12; // r8
  __int64 *v13; // rax
  __int64 v14; // [rsp+0h] [rbp-1010h]
  __int64 v15; // [rsp+8h] [rbp-1008h] BYREF
  __int64 v16; // [rsp+10h] [rbp-1000h] BYREF
  __int16 v17; // [rsp+18h] [rbp-FF8h]
  char v18; // [rsp+1Ah] [rbp-FF6h]
  __int64 v19; // [rsp+1008h] [rbp-8h] BYREF

  if ( !a2 )
    return 0LL;
  v19 = v2;
  v3 = (__int64 *)((char *)&v19 - ((a2 + 25) & 0xFFFFFFFFFFFFF000LL));
  if ( &v19 != v3 )
  {
    while ( &v15 != v3 )
      ;
  }
  if ( (((_WORD)a2 + 25) & 0xFF0) != 0 )
  {
    v4 = alloca(((_WORD)a2 + 25) & 0xFF0);
    *(__int64 *)((char *)&v14 + (((_WORD)a2 + 25) & 0xFF0)) = *(__int64 *)((char *)&v14 + (((_WORD)a2 + 25) & 0xFF0));
  }
  v5 = *a1;
  v6 = &v16;
LABEL_9:
  if ( v5 )
  {
    do
    {
      v7 = a1[1];
      if ( v5 != 47 )
      {
        ++a1;
LABEL_8:
        *(_BYTE *)v6 = v5;
        v5 = v7;
        v6 = (__int64 *)((char *)v6 + 1);
        goto LABEL_9;
      }
      if ( v7 == 46 )
      {
        v11 = a1[2];
        if ( v11 == 46 )
        {
          v12 = a1[3];
          if ( v12 == 47 || !v12 )
          {
            if ( v6 > &v16 )
            {
              v13 = (__int64 *)((char *)v6 - 1);
              if ( *((_BYTE *)v6 - 1) == 47 )
              {
LABEL_43:
                v6 = v13;
              }
              else
              {
                while ( &v16 != v13 )
                {
                  v13 = (__int64 *)((char *)v13 - 1);
                  if ( *(_BYTE *)v13 == 47 )
                    goto LABEL_43;
                }
                v6 = &v16;
              }
            }
            a1 += 3;
            v5 = v12;
            goto LABEL_9;
          }
        }
        else if ( v11 == 47 || !v11 )
        {
          a1 += 2;
          v5 = v11;
          goto LABEL_9;
        }
      }
      ++a1;
      if ( v6 <= &v16 || *((_BYTE *)v6 - 1) != 47 )
        goto LABEL_8;
      v5 = v7;
    }
    while ( v7 );
  }
  if ( v6 == &v16 || (v8 = (char *)v6, *((_BYTE *)v6 - 1) != 47) )
  {
    *(_BYTE *)v6 = 47;
    v8 = (char *)v6 + 1;
  }
  v9 = v8 - (char *)&v16;
  if ( v9 <= 6 )
    return 0LL;
  if ( (_DWORD)v16 == 1651076143 && WORD2(v16) == 13366 && BYTE6(v16) == 47 )
    return 1LL;
  if ( v9 <= 0xA || v16 != 0x62696C2F7273752FLL || v17 != 13366 )
    return 0LL;
  return v18 == 47;
}
// 465800: could not find valid save-restore pair for rbp
// 465809: variable 'v2' is possibly undefined

//----- (00000000004659B0) ----------------------------------------------------
__int64 __fastcall dl_process_pt_note(__int64 a1, _QWORD *a2, _QWORD *a3, _QWORD *a4, u32 *a5, unsigned __int64 a6)
{
  unsigned __int64 v8; // r12
  __int64 v9; // rsi
  unsigned int *v10; // rbx
  char *v11; // r14
  char *v12; // rax
  __int64 v13; // rdx
  __int64 v14; // r15
  __int64 v15; // rcx
  char v16; // al
  unsigned int *v17; // rax
  unsigned int v18; // edi
  unsigned int v19; // er10
  __int64 *v21; // rcx
  void *v22; // rsp
  unsigned int v23; // eax
  __int64 v24; // [rsp+0h] [rbp-1048h]
  __int64 v25; // [rsp+8h] [rbp-1040h] BYREF
  char v26[7]; // [rsp+10h] [rbp-1038h] BYREF
  _BYTE v27[4]; // [rsp+1008h] [rbp-40h] BYREF
  unsigned int v28; // [rsp+100Ch] [rbp-3Ch]
  unsigned int v29; // [rsp+1010h] [rbp-38h]
  int v30; // [rsp+1014h] [rbp-34h]

  v8 = a2[4];
  v9 = a2[1];
  if ( v9 + v8 <= *a4 )
  {
    if ( (*(_BYTE *)(a1 + 798) & 0xE) != 0 )
      return 0LL;
    if ( a2[6] != 8LL )
      return 0LL;
    v10 = (unsigned int *)((char *)a4 + v9 + 8);
    v11 = 0LL;
    v12 = (char *)v10;
    if ( v8 <= 0xC )
      return 0LL;
    goto LABEL_5;
  }
  if ( v8 > 0xFFFF )
  {
    v28 = (unsigned int)a3;
    v30 = HIDWORD(v9);
    v11 = (char *)malloc(v8, v9, a3, (__int64)a4, (u32 *)(unsigned int)a3, a6);
    v29 = v28;
    lseek64(v28, v9, 0);
    v9 = (__int64)v11;
    if ( _read_nocancel(v28, v11, v8) == v8 )
    {
      if ( (*(_BYTE *)(a1 + 798) & 0xE) != 0 || a2[6] != 8LL )
      {
LABEL_20:
        if ( v11 )
          free((__int64)v11, v9, v13, v15, a5, a6);
        return 0LL;
      }
      v12 = v11;
      v10 = (unsigned int *)v11;
LABEL_5:
      v29 = 0;
      v13 = 0LL;
      v14 = 12LL - (_QWORD)v12;
      while ( 1 )
      {
        v15 = *v10;
        if ( (_DWORD)v15 == 4 && v10[2] == 5 && v10[3] == 5590599 )
          break;
        v9 = v10[1];
LABEL_7:
        v10 = (unsigned int *)((char *)v10
                             + ((v9 + (((unsigned int)v15 + 19LL) & 0xFFFFFFFFFFFFFFF8LL) + 7) & 0xFFFFFFFFFFFFFFF8LL));
        if ( v8 <= (unsigned __int64)v10 + v14 )
        {
          v23 = v29 & 2;
          v15 = v29 & 1;
          if ( (v29 & 1) != 0 )
            *(_BYTE *)(a1 + 798) |= 4u;
          if ( v23 )
            *(_BYTE *)(a1 + 798) |= 8u;
          goto LABEL_20;
        }
      }
      v16 = *(_BYTE *)(a1 + 798);
      if ( (v16 & 0xE) == 0 )
      {
        *(_BYTE *)(a1 + 798) = v16 & 0xF1 | 2;
        v9 = v10[1];
        if ( (unsigned int)v9 > 7 && (v9 & 7) == 0 )
        {
          v17 = v10 + 4;
          a5 = (unsigned int *)((char *)v10 + v9 + 16);
          while ( 1 )
          {
            v18 = *v17;
            v19 = v17[1];
            if ( *v17 < (unsigned int)v13 )
              break;
            a6 = (unsigned __int64)(v17 + 2);
            v13 = v19;
            if ( a5 < (unsigned int *)((char *)v17 + v19 + 8) )
              break;
            if ( v18 == -1073741822 )
            {
              if ( v19 != 4 )
                goto LABEL_20;
              v13 = 3221225474LL;
              v29 = v17[2];
              goto LABEL_7;
            }
            if ( v18 > 0xC0000002 )
              goto LABEL_20;
            v17 = (unsigned int *)(a6 + ((v19 + 7LL) & 0xFFFFFFFFFFFFFFF8LL));
            v13 = v18;
            if ( (char *)a5 - (char *)v17 <= 7 )
              goto LABEL_7;
          }
        }
      }
      goto LABEL_20;
    }
    if ( v11 )
      free((__int64)v11, (__int64)v11, v13, v15, a5, a6);
  }
  else
  {
    v21 = (__int64 *)&v27[-((v8 + 23) & 0xFFFFFFFFFFFFF000LL)];
    if ( v27 != (_BYTE *)v21 )
    {
      while ( &v25 != v21 )
        ;
    }
    if ( (((_WORD)v8 + 23) & 0xFF0) != 0 )
    {
      v22 = alloca(((_WORD)v8 + 23) & 0xFF0);
      *(__int64 *)((char *)&v24 + (((_WORD)v8 + 23) & 0xFF0)) = *(__int64 *)((char *)&v24 + (((_WORD)v8 + 23) & 0xFF0));
    }
    v29 = (unsigned int)a3;
    lseek64((unsigned int)a3, v9, 0);
    v10 = (unsigned int *)v26;
    v9 = (__int64)v26;
    if ( v8 == _read_nocancel(v29, v26, v8) )
    {
      if ( (*(_BYTE *)(a1 + 798) & 0xE) != 0 )
        return 0LL;
      if ( a2[6] != 8LL )
        return 0LL;
      v12 = v26;
      if ( v8 <= 0xC )
        return 0LL;
      v11 = 0LL;
      goto LABEL_5;
    }
  }
  return 0xFFFFFFFFLL;
}
// 465AE8: variable 'v13' is possibly undefined
// 465AE8: variable 'v15' is possibly undefined
// 465AE8: variable 'a5' is possibly undefined
// 465AE8: variable 'a6' is possibly undefined

//----- (0000000000465C90) ----------------------------------------------------
void __fastcall __noreturn lose(int a1, __int64 a2, void *a3, __int64 a4, __int64 a5, const char *a6, __int64 a7)
{
  __int64 v12; // rdi
  __int64 v13; // rdx
  __int64 v14; // rcx
  u32 *v15; // r8
  unsigned __int64 v16; // r9

  if ( (_DWORD)a2 != -1 )
    _close_nocancel(a2);
  if ( a5 )
  {
    v12 = *(_QWORD *)(a5 + 832);
    if ( v12 != -1 )
      free(v12, a2, (__int64)a3, a4, (u32 *)a5, (unsigned __int64)a6);
  }
  free(a5, a2, (__int64)a3, a4, (u32 *)a5, (unsigned __int64)a6);
  free(a4, a2, v13, v14, v15, v16);
  if ( a7 )
  {
    *(_DWORD *)(a7 + 24) = 0;
    dl_debug_state();
  }
  dl_signal_error(a1, a3, 0LL, a6);
}
// 465CD0: variable 'a3' is possibly undefined
// 465CD0: variable 'a4' is possibly undefined
// 465CD0: variable 'a5' is possibly undefined
// 465CD0: variable 'a6' is possibly undefined
// 465CE0: variable 'v13' is possibly undefined
// 465CE0: variable 'v14' is possibly undefined
// 465CE0: variable 'v15' is possibly undefined
// 465CE0: variable 'v16' is possibly undefined

//----- (0000000000465D10) ----------------------------------------------------
__int64 __fastcall add_name_to_object_isra_5(_QWORD *a1, void *a2)
{
  __int64 *v3; // rbx
  __int64 v4; // rsi
  __int64 result; // rax
  __int64 v6; // rax
  __int64 v7; // r13
  _QWORD *v8; // rdx
  __int64 v9; // rcx
  u32 *v10; // r8
  __int64 v11; // r9
  _QWORD *v12; // rax
  _QWORD *v13; // r12
  __int64 v14; // rax
  _QWORD *v15; // rdx
  __int64 v16; // rcx
  u32 *v17; // r8
  __int64 v18; // r9

  v3 = a1;
  if ( !a1 )
  {
    v14 = j_strlen_ifunc(a2);
    if ( malloc(v14 + 25, (__int64)a2, v15, v16, v17, v18) )
      _assert_fail((__int64)"lastp != NULL", (__int64)"dl-load.c", 0x1AFu, "add_name_to_object");
    goto LABEL_10;
  }
  while ( 1 )
  {
    v4 = *v3;
    result = j_strcmp_ifunc(a2, *v3);
    if ( !(_DWORD)result )
      return result;
    if ( !v3[1] )
      break;
    v3 = (__int64 *)v3[1];
  }
  v6 = j_strlen_ifunc(a2);
  v7 = v6 + 1;
  v12 = malloc(v6 + 25, v4, v8, v9, v10, v11);
  v13 = v12;
  if ( !v12 )
LABEL_10:
    dl_signal_error(12, a2, 0LL, "cannot allocate name record");
  result = j_memcpy(v12 + 3, a2, v7);
  v13[1] = 0LL;
  *v13 = result;
  *((_DWORD *)v13 + 4) = 0;
  v3[1] = (__int64)v13;
  return result;
}
// 465D70: variable 'v8' is possibly undefined
// 465D70: variable 'v9' is possibly undefined
// 465D70: variable 'v10' is possibly undefined
// 465D70: variable 'v11' is possibly undefined
// 465DBE: variable 'v15' is possibly undefined
// 465DBE: variable 'v16' is possibly undefined
// 465DBE: variable 'v17' is possibly undefined
// 465DBE: variable 'v18' is possibly undefined
// 401040: using guessed type __int64 __fastcall j_memcpy(_QWORD, _QWORD, _QWORD);
// 4010A0: using guessed type __int64 __fastcall j_strcmp_ifunc(_QWORD, _QWORD);
// 4010C8: using guessed type __int64 __fastcall j_strlen_ifunc(_QWORD);

//----- (0000000000465E00) ----------------------------------------------------
__int64 __fastcall open_verify_constprop_9(const char *a1, unsigned __int64 a2, int a3, _BYTE *a4, int a5)
{
  unsigned int v8; // er13
  __int64 v9; // rax
  off_t v10; // rsi
  signed __int64 nocancel; // rax
  char *v12; // r8
  __int64 v13; // r9
  __int64 v14; // rcx
  unsigned __int8 v15; // dl
  __int64 v16; // r10
  unsigned int v17; // edi
  __int64 v18; // rdx
  unsigned __int64 v19; // rcx
  int v21; // ebx
  __int16 v22; // dx
  size_t v23; // rbx
  __int64 v24; // rdi
  unsigned __int64 v25; // rbx
  unsigned __int64 v26; // r15
  size_t v27; // r12
  unsigned __int64 v28; // r9
  unsigned __int64 *v29; // rax
  void *v30; // rsp
  char *v31; // r14
  unsigned __int64 v32; // rax
  __int64 v33; // rdx
  unsigned __int64 v34; // r9
  char *v35; // rsi
  char *v36; // rdi
  const char *v37; // rax
  const char *v38; // r12
  __int64 v39; // rax
  __int64 v40; // rdx
  __int16 v41; // cx
  __int64 *v42; // rax
  unsigned int v43; // ecx
  void *v44; // rsp
  char *v45; // r15
  char *v46; // rsi
  char *v47; // r14
  __int64 v48; // rdx
  __int64 v49; // rcx
  u32 *v50; // r8
  unsigned __int64 v51; // r9
  unsigned __int64 v52; // rax
  unsigned __int64 *v53; // rax
  void *v54; // rsp
  unsigned __int64 v55; // rax
  unsigned __int64 v56; // rsi
  __int64 *v57; // rax
  char v58; // dl
  bool v59; // al
  unsigned __int8 v60; // dl
  int v61; // eax
  __int64 v62; // [rsp+0h] [rbp-1068h]
  __int64 v63; // [rsp+8h] [rbp-1060h] BYREF
  _BYTE v64[7]; // [rsp+10h] [rbp-1058h] BYREF
  __int64 v65; // [rsp+1000h] [rbp-68h]
  unsigned __int64 v66; // [rsp+1008h] [rbp-60h] BYREF
  unsigned __int64 v67; // [rsp+1010h] [rbp-58h] BYREF
  char *v68; // [rsp+1018h] [rbp-50h]
  int v69; // [rsp+1024h] [rbp-44h]
  char *v70; // [rsp+1028h] [rbp-40h]
  __int64 v71; // [rsp+1030h] [rbp-38h]

  v70 = (char *)a1;
  v69 = a5;
  v8 = _open_nocancel(a1, 0x80000, a3);
  if ( v8 == -1 )
    return v8;
  __writefsdword(0xFFFFFFC0, 0);
  *(_QWORD *)a2 = 0LL;
  v71 = a2 + 8;
  v9 = 0LL;
  while ( 1 )
  {
    v10 = v9 + v71;
    nocancel = _read_nocancel(v8, (char *)(v9 + v71), 832 - v9);
    if ( nocancel <= 0 )
      break;
    v9 = *(_QWORD *)a2 + nocancel;
    *(_QWORD *)a2 = v9;
    if ( (unsigned __int64)v9 > 0x3F )
      goto LABEL_5;
  }
  v9 = *(_QWORD *)a2;
LABEL_5:
  if ( v9 <= 63 )
  {
    v21 = __readfsdword(0xFFFFFFC0);
    v37 = "cannot read file data";
    if ( !v21 )
      v37 = "file too short";
    v38 = v37;
    goto LABEL_49;
  }
  v14 = *(_QWORD *)(a2 + 8);
  if ( expected_11393 != v14 && expected2_11392 != v14
    || (v15 = *(_BYTE *)(a2 + 16)) != 0 && (*(_BYTE *)(a2 + 15) != 3 || v15 > 3u)
    || (v10 = 0LL, *(_DWORD *)(a2 + 17))
    || *(_WORD *)(a2 + 21)
    || *(_BYTE *)(a2 + 23) )
  {
    if ( *(_DWORD *)(a2 + 8) == 1179403647 )
    {
      if ( *(_BYTE *)(a2 + 12) != 2 )
      {
        *a4 = 1;
        v16 = 0LL;
        goto LABEL_12;
      }
      if ( *(_BYTE *)(a2 + 13) == 1 )
      {
        if ( *(_BYTE *)(a2 + 14) == 1 )
        {
          v58 = *(_BYTE *)(a2 + 15);
          v59 = v58 != 3;
          if ( !v58 || v58 == 3 )
          {
            v60 = *(_BYTE *)(a2 + 16);
            if ( v60 && (v60 > 3u || v59) )
            {
              v21 = 0;
              v38 = "ELF file ABI version invalid";
            }
            else
            {
              v61 = j_memcmp_ifunc(a2 + 17, &dword_4924B9, 7LL);
              v38 = "internal error";
              v21 = v61;
              if ( v61 )
              {
                v21 = 0;
                v38 = "nonzero padding in e_ident";
              }
            }
          }
          else
          {
            v21 = 0;
            v38 = "ELF file OS ABI invalid";
          }
        }
        else
        {
          v21 = 0;
          v38 = "ELF file version ident does not match current one";
        }
      }
      else
      {
        v21 = 0;
        v38 = "ELF file data encoding not little-endian";
      }
    }
    else
    {
      v21 = 0;
      v38 = "invalid ELF header";
    }
    goto LABEL_49;
  }
  v21 = 0;
  if ( *(_DWORD *)(a2 + 28) != 1 )
  {
    v38 = "ELF file version does not match current one";
    goto LABEL_49;
  }
  if ( *(_WORD *)(a2 + 26) != 62 )
  {
    v16 = 0LL;
    goto LABEL_12;
  }
  v22 = *(_WORD *)(a2 + 24);
  if ( (unsigned __int16)(v22 - 2) > 1u )
  {
    v38 = "only ET_DYN and ET_EXEC can be loaded";
    goto LABEL_49;
  }
  if ( v22 == 2 && (a3 & 0x20000000) == 0 )
  {
    v38 = "cannot dynamically load executable";
    goto LABEL_49;
  }
  if ( *(_WORD *)(a2 + 62) != 56 )
  {
    v38 = "ELF file's phentsize not the expected size";
    goto LABEL_49;
  }
  v18 = *(unsigned __int16 *)(a2 + 64);
  v10 = *(_QWORD *)(a2 + 40);
  v23 = 56 * v18;
  v24 = 56 * v18;
  if ( 56 * v18 + v10 > (unsigned __int64)v9 )
  {
    v53 = (unsigned __int64 *)((char *)&v66 - ((v23 + 23) & 0xFFFFFFFFFFFFF000LL));
    if ( &v66 != v53 )
    {
      while ( &v63 != (__int64 *)v53 )
        ;
    }
    if ( (((_WORD)v23 + 23) & 0xFF0) != 0 )
    {
      v54 = alloca(((_WORD)v23 + 23) & 0xFF0);
      *(__int64 *)((char *)&v62 + (((_WORD)v23 + 23) & 0xFF0)) = *(__int64 *)((char *)&v62 + (((_WORD)v23 + 23) & 0xFF0));
    }
    v68 = v64;
    lseek64(v8, v10, 0);
    v10 = (off_t)v68;
    v55 = _read_nocancel(v8, v68, v23);
    v19 = (unsigned __int64)v68;
    if ( v55 == v23 )
    {
      v18 = *(unsigned __int16 *)(a2 + 64);
      v24 = 56 * v18;
      goto LABEL_24;
    }
LABEL_85:
    v38 = "cannot read file data";
    v21 = __readfsdword(0xFFFFFFC0);
LABEL_49:
    if ( (_BYTE)v69 )
    {
      v39 = j_strlen_ifunc(v70);
      v40 = v39 + 1;
      v41 = (v39 + 24) & 0xFFF0;
      v42 = (__int64 *)((char *)&v66 - ((v39 + 24) & 0xFFFFFFFFFFFFF000LL));
      while ( &v66 != (unsigned __int64 *)v42 )
        ;
      v43 = v41 & 0xFFF;
      if ( v43 )
      {
        v44 = alloca(v43);
        *(__int64 *)((char *)&v65 + v43) = *(__int64 *)((char *)&v65 + v43);
      }
      v45 = v70;
      v46 = v70;
      v47 = (char *)j_memcpy(&v67, v70, v40);
      free((__int64)v45, (__int64)v46, v48, v49, v50, v51);
      v70 = v47;
    }
    v65 = 0LL;
    lose(v21, v8, v70, 0LL, 0LL, v38, 0LL);
  }
  v19 = v71 + v10;
LABEL_24:
  if ( v19 >= v19 + v24 )
  {
    v16 = 0LL;
    goto LABEL_13;
  }
  v25 = v19;
  v26 = v19;
  v16 = 0LL;
  v19 = a2;
  while ( 1 )
  {
    if ( *(_DWORD *)v25 != 4 )
      goto LABEL_26;
    v27 = *(_QWORD *)(v25 + 32);
    if ( v27 <= 0x1F )
      goto LABEL_26;
    v12 = *(char **)(v25 + 48);
    if ( (unsigned __int64)v12 <= 3 || ((unsigned __int64)(v12 - 4) & 0xFFFFFFFFFFFFFFFBLL) != 0 )
      goto LABEL_26;
    v28 = *(_QWORD *)(v25 + 8);
    if ( v27 + v28 <= *(_QWORD *)v19 )
    {
      v31 = (char *)(v71 + v28);
    }
    else
    {
      if ( v27 > 0xFFFF )
      {
        v56 = *(_QWORD *)(v25 + 32);
        v66 = v19;
        v67 = v28;
        v68 = v12;
        v57 = realloc(v16, v56, (_QWORD *)v18, v19, (u32 *)v12, v28);
        v31 = (char *)v57;
        if ( !v57 )
          goto LABEL_85;
        v16 = (__int64)v57;
        v19 = v66;
        v28 = v67;
        v12 = v68;
      }
      else
      {
        v29 = (unsigned __int64 *)((char *)&v66 - ((v27 + 23) & 0xFFFFFFFFFFFFF000LL));
        if ( &v66 != v29 )
        {
          while ( &v63 != (__int64 *)v29 )
            ;
        }
        if ( (((_WORD)v27 + 23) & 0xFF0) != 0 )
        {
          v30 = alloca(((_WORD)v27 + 23) & 0xFF0);
          *(__int64 *)((char *)&v62 + (((_WORD)v27 + 23) & 0xFF0)) = *(__int64 *)((char *)&v62
                                                                                + (((_WORD)v27 + 23) & 0xFF0));
        }
        v31 = v64;
      }
      v66 = v19;
      v67 = v16;
      v68 = v12;
      lseek64(v8, v28, 0);
      v32 = _read_nocancel(v8, v31, v27);
      v12 = v68;
      v16 = v67;
      v19 = v66;
      if ( v32 != v27 )
      {
        free(v67, (__int64)v31, v33, v66, (u32 *)v68, v34);
        goto LABEL_85;
      }
    }
    v35 = v12;
    v36 = v12 + 11;
    --v12;
    v10 = -(__int64)v35;
    while ( 1 )
    {
      v13 = expected_note_11399 ^ *(_QWORD *)v31 | *((_QWORD *)v31 + 1) ^ 0x554E4700000001LL;
      if ( !v13 )
        break;
      v13 = v27 - 32;
      v52 = v10 & (unsigned __int64)&v12[*((unsigned int *)v31 + 1)
                                       + (v10 & (unsigned __int64)&v36[*(unsigned int *)v31])];
      if ( v52 > v27 - 32 )
        goto LABEL_71;
      v27 -= v52;
      v31 += v52;
    }
    if ( v27 )
      break;
LABEL_71:
    v18 = *(unsigned __int16 *)(v19 + 64);
LABEL_26:
    v25 += 56LL;
    if ( v25 >= v26 + 56 * v18 )
      goto LABEL_13;
  }
  if ( *((_DWORD *)v31 + 4)
    || (v18 = (unsigned int)dl_osversion,
        v19 = (unsigned __int8)v31[28],
        (unsigned int)v19 + (((unsigned __int8)v31[24] + ((unsigned __int8)v31[20] << 8)) << 8) > dl_osversion)
    && dl_osversion )
  {
LABEL_12:
    v17 = v8;
    v71 = v16;
    v8 = -1;
    _close_nocancel(v17);
    __writefsdword(0xFFFFFFC0, 2u);
    v16 = v71;
  }
LABEL_13:
  free(v16, v10, v18, v19, (u32 *)v12, v13);
  return v8;
}
// 465F0C: variable 'v18' is possibly undefined
// 465F0C: variable 'v19' is possibly undefined
// 465F0C: variable 'v12' is possibly undefined
// 465F0C: variable 'v13' is possibly undefined
// 46622E: variable 'v48' is possibly undefined
// 46622E: variable 'v49' is possibly undefined
// 46622E: variable 'v50' is possibly undefined
// 46622E: variable 'v51' is possibly undefined
// 4663CE: variable 'v33' is possibly undefined
// 4663CE: variable 'v34' is possibly undefined
// 401040: using guessed type __int64 __fastcall j_memcpy(_QWORD, _QWORD, _QWORD);
// 401080: using guessed type __int64 __fastcall j_memcmp_ifunc(_QWORD, _QWORD, _QWORD);
// 4010C8: using guessed type __int64 __fastcall j_strlen_ifunc(_QWORD);
// 4924B0: using guessed type __int64 expected_11393;
// 4924B9: using guessed type int dword_4924B9;
// 4924C0: using guessed type __int64 expected2_11392;
// 4AB928: using guessed type int dl_osversion;

//----- (0000000000466490) ----------------------------------------------------
__int64 __fastcall open_path(
        __int64 a1,
        __int64 a2,
        int a3,
        __int64 *a4,
        __int64 *a5,
        unsigned __int64 a6,
        __int64 a7,
        int a8,
        _BYTE *a9)
{
  __int64 v9; // r10
  __int64 *v10; // rbx
  __int16 v11; // r10
  unsigned int v12; // er10
  const char *v13; // r13
  const char *v14; // r14
  int v15; // er12
  __int64 v16; // rsi
  int v17; // er12
  unsigned __int64 v18; // rbx
  u32 *v19; // r8
  unsigned __int64 v20; // r9
  __int64 v21; // r15
  unsigned __int64 i; // rax
  __int64 v23; // rax
  _QWORD *v24; // rdx
  __int64 v25; // rcx
  int v26; // eax
  unsigned int v27; // er15
  _QWORD *v28; // rax
  int v30; // eax
  unsigned int v31; // eax
  __int64 v32; // rdx
  int v33; // eax
  int v34; // edx
  int v35; // eax
  struct stat *v36; // rax
  __int64 v37; // rdx
  char *v38; // rsi
  __int16 v39; // dx
  unsigned int v40; // edx
  void *v41; // rsp
  const char *v42; // rax
  const char **v43; // r15
  __int64 v44; // r13
  unsigned __int64 v45; // r14
  char *v46; // rdi
  char *v47; // rax
  void *v48; // rsp
  struct stat *v49; // rax
  __int64 v50; // [rsp+0h] [rbp-2138h]
  char v51; // [rsp+8h] [rbp-2130h] BYREF
  _BYTE v52[4095]; // [rsp+9h] [rbp-212Fh] BYREF
  __int64 v53; // [rsp+1008h] [rbp-1130h] BYREF
  __int64 v54; // [rsp+1010h] [rbp-1128h] BYREF
  __int64 v55; // [rsp+2008h] [rbp-130h] BYREF
  __int64 *v56; // [rsp+2010h] [rbp-128h]
  const char *v57; // [rsp+2018h] [rbp-120h]
  const char *v58; // [rsp+2020h] [rbp-118h]
  __int64 *v59; // [rsp+2028h] [rbp-110h]
  __int64 *v60; // [rsp+2030h] [rbp-108h]
  struct stat *v61; // [rsp+2038h] [rbp-100h]
  const char **v62; // [rsp+2040h] [rbp-F8h]
  const char *v63; // [rsp+2048h] [rbp-F0h]
  unsigned __int64 v64; // [rsp+2050h] [rbp-E8h]
  __int64 v65; // [rsp+2058h] [rbp-E0h]
  __int64 v66; // [rsp+2060h] [rbp-D8h]
  unsigned int v67; // [rsp+2068h] [rbp-D0h]
  int v68; // [rsp+206Ch] [rbp-CCh]
  char *v69; // [rsp+2070h] [rbp-C8h]
  char v70; // [rsp+2078h] [rbp-C0h] BYREF
  __int16 v71; // [rsp+2090h] [rbp-A8h]

  v62 = (const char **)*a4;
  if ( !v62 )
    return (unsigned int)-1;
  v9 = a2 + max_dirnamelen + max_capstrlen + 23;
  v10 = (__int64 *)((char *)&v55 - (v9 & 0xFFFFFFFFFFFFF000LL));
  v11 = v9 & 0xFFF0;
  if ( &v55 != v10 )
  {
    while ( &v53 != v10 )
      ;
  }
  v12 = v11 & 0xFFF;
  if ( v12 )
  {
    v48 = alloca(v12);
    *(_QWORD *)&v52[v12 + 4087] = *(_QWORD *)&v52[v12 + 4087];
  }
  v64 = a6;
  v60 = a5;
  v13 = (const char *)&v54;
  v56 = a4;
  v68 = a3;
  v66 = a2;
  v14 = *v62;
  v65 = a1;
  v67 = 0;
  v58 = 0LL;
  do
  {
    v15 = dl_debug_mask & 1;
    if ( (dl_debug_mask & 1) != 0 )
    {
      v63 = (const char *)*((_QWORD *)v14 + 1);
      if ( v63 != v58 )
      {
        v36 = (struct stat *)*((_QWORD *)v14 + 2);
        v59 = &v53;
        v61 = v36;
        v37 = max_dirnamelen + max_capstrlen + 15;
        v38 = (char *)&v53 - (v37 & 0xFFFFFFFFFFFFF000LL);
        v39 = v37 & 0xFFF0;
        if ( &v53 != (__int64 *)v38 )
        {
          while ( &v51 != v38 )
            ;
        }
        v40 = v39 & 0xFFF;
        if ( v40 )
        {
          v41 = alloca(v40);
          *(__int64 *)((char *)&v50 + v40) = *(__int64 *)((char *)&v50 + v40);
        }
        dl_debug_printf(" search path=");
        v42 = *v62;
        if ( *v62 && v63 == *((const char **)v42 + 1) )
        {
          v58 = v14;
          v43 = v62;
          v57 = v13;
          do
          {
            v44 = j_mempcpy(&v51, *((_QWORD *)v42 + 3), *((_QWORD *)v42 + 4));
            if ( ncapstr )
            {
              v45 = 0LL;
              v69 = v52;
              do
              {
                if ( *(_DWORD *)&(*v43)[4 * v45 + 40] != 1 )
                {
                  v47 = (char *)j_mempcpy(v44, *(_QWORD *)(capstr + 16 * v45), *(_QWORD *)(capstr + 16 * v45 + 8));
                  if ( &v51 == v47 )
                  {
                    *v47 = 0;
                  }
                  else if ( v47 == v69 && v51 == 47 )
                  {
                    *v47 = 0;
                  }
                  else
                  {
                    *(v47 - 1) = 0;
                  }
                  v46 = ":%s";
                  if ( v15 )
                    v46 = "%s";
                  v15 = 0;
                  dl_debug_printf_c(v46, &v51);
                }
                ++v45;
              }
              while ( v45 < ncapstr );
            }
            v42 = *++v43;
          }
          while ( *v43 && v63 == *((const char **)v42 + 1) );
          v14 = v58;
          v13 = v57;
        }
        if ( v61 )
        {
          if ( !LOBYTE(v61->st_dev) )
          {
            v49 = (struct stat *)"<main program>";
            if ( program_invocation_short_name[0] )
              v49 = (struct stat *)program_invocation_short_name[0];
            v61 = v49;
          }
          dl_debug_printf_c("\t\t(%s from file %s)\n", v63, (const char *)v61);
        }
        else
        {
          dl_debug_printf_c("\t\t(%s)\n", v63);
        }
        v58 = v63;
      }
    }
    v16 = *((_QWORD *)v14 + 3);
    v17 = 0;
    v18 = 0LL;
    v21 = j_mempcpy(v13, v16, *((_QWORD *)v14 + 4));
    v61 = (struct stat *)&v70;
    LODWORD(v63) = v68 & 0x4000000;
LABEL_9:
    for ( i = ncapstr; v18 < i; ++v18 )
    {
      if ( *(_DWORD *)&v14[4 * v18 + 40] != 1 )
      {
        v23 = j_mempcpy(v21, *(_QWORD *)(capstr + 16 * v18), *(_QWORD *)(capstr + 16 * v18 + 8));
        v69 = (char *)(j_mempcpy(v23, v65, v66) - (_QWORD)v13);
        if ( (dl_debug_mask & 1) != 0 )
          dl_debug_printf("  trying file=%s\n", v13);
        v16 = v64;
        v25 = (unsigned int)open_verify_constprop_9(v13, v64, v68, a9, 0);
        v26 = *(_DWORD *)&v14[4 * v18 + 40];
        if ( v26 )
        {
          v17 |= v26 != 1;
          if ( (_DWORD)v25 == -1 )
            goto LABEL_39;
        }
        else
        {
          if ( (_DWORD)v25 == -1 )
          {
            if ( a7 && (*((_BYTE *)*(&dl_ns + 18 * *(_QWORD *)(a7 + 48)) + 797) & 8) != 0 )
            {
              v17 = 1;
            }
            else
            {
              v16 = (__int64)v13;
              v69[(_QWORD)v13 + ~v66] = 0;
              v33 = xstat(1u, v13, v61);
              v34 = 1;
              if ( !v33 )
              {
                v35 = v71 & 0xF000;
                v34 = (v35 == 0x4000) + 1;
                if ( v35 == 0x4000 )
                  v17 = 1;
              }
              *(_DWORD *)&v14[4 * v18 + 40] = v34;
            }
LABEL_39:
            ++v18;
            goto LABEL_9;
          }
          *(_DWORD *)&v14[4 * v18 + 40] = 2;
          v17 = 1;
        }
        if ( !(_DWORD)v63 )
          goto LABEL_19;
        v16 = (unsigned int)_libc_enable_secure;
        if ( !_libc_enable_secure
          || (v16 = (unsigned int)v25, LODWORD(v59) = v25, v30 = fxstat(1u, v25, v61), v25 = (unsigned int)v59, !v30)
          && (v71 & 0x800) != 0 )
        {
          ++v18;
          if ( (_DWORD)v25 == -1 )
            goto LABEL_9;
LABEL_19:
          v27 = v25;
          v28 = malloc((unsigned __int64)v69, v16, v24, v25, v19, v20);
          *v60 = (__int64)v28;
          if ( v28 )
          {
            j_memcpy(v28, v13, v69);
            return v27;
          }
          _close_nocancel(v27);
          return (unsigned int)-1;
        }
        _close_nocancel((unsigned int)v59);
        __writefsdword(0xFFFFFFC0, 2u);
        i = ncapstr;
      }
    }
    if ( v17 )
    {
      v31 = __readfsdword(0xFFFFFFC0);
      if ( v31 != 13 && v31 != 2 )
        return (unsigned int)-1;
    }
    ++v62;
    v67 |= v17;
    v14 = *v62;
  }
  while ( *v62 );
  if ( v67 )
    return (unsigned int)-1;
  v32 = *((unsigned int *)v56 + 2);
  if ( (_DWORD)v32 )
    free(*v56, v16, v32, v67, v19, v20);
  if ( v56 == &env_path_list || v56 == &rtld_search_dirs )
    return (unsigned int)-1;
  *v56 = -1LL;
  return (unsigned int)-1;
}
// 46668A: variable 'v24' is possibly undefined
// 46668A: variable 'v19' is possibly undefined
// 46668A: variable 'v20' is possibly undefined
// 401040: using guessed type __int64 __fastcall j_memcpy(_QWORD, _QWORD, _QWORD);
// 4010B0: using guessed type __int64 __fastcall j_mempcpy(_QWORD, _QWORD, _QWORD);
// 4A7AD8: using guessed type int _libc_enable_secure;
// 4A7ED0: using guessed type __int64 rtld_search_dirs;
// 4A7EE0: using guessed type __int64 max_capstrlen;
// 4A7EE8: using guessed type __int64 ncapstr;
// 4A7EF0: using guessed type __int64 capstr;
// 4A7F00: using guessed type __int64 env_path_list;
// 4A9168: using guessed type char (*program_invocation_short_name[2])[1707];
// 4A9280: using guessed type void *dl_ns;
// 4AB010: using guessed type __int64 max_dirnamelen;
// 4AB880: using guessed type int dl_debug_mask;

//----- (0000000000466B10) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
__int64 __fastcall dl_map_object_from_fd_constprop_10(
        const char *a1,
        unsigned int a2,
        char *a3,
        unsigned __int8 *a4,
        _QWORD *a5,
        char a6,
        int a7,
        __int64 a8,
        __int64 a9)
{
  __int64 v11; // rcx
  u32 *v12; // r8
  unsigned __int64 v13; // r9
  unsigned __int64 v14; // r14
  __int64 v15; // rbx
  __int64 v16; // rdx
  __int64 v17; // rcx
  u32 *v18; // r8
  unsigned __int64 v19; // r9
  int v21; // eax
  u32 *v22; // rax
  unsigned __int64 v23; // r8
  unsigned __int64 v24; // r9
  char *v25; // rdi
  off_t v26; // rsi
  char *v27; // r13
  __int64 v28; // rax
  size_t v29; // r12
  __int64 v30; // rdx
  __int64 v31; // rax
  __int64 *v32; // rcx
  unsigned int v33; // eax
  void *v34; // rsp
  unsigned __int64 v35; // rsi
  char *v36; // r12
  __int64 v37; // r14
  unsigned int v38; // eax
  __int64 v39; // rax
  __int64 v40; // rax
  __int64 v41; // rdx
  __int64 v42; // rax
  __int64 v43; // rax
  __int64 v44; // rsi
  __int64 v45; // rdi
  __int64 v46; // r9
  __int64 v47; // r11
  __int64 *v48; // rax
  __int64 v49; // rcx
  __int64 v50; // rdx
  __int64 v51; // rax
  const char *v52; // r9
  __int64 v53; // r15
  unsigned __int64 v54; // r14
  __int64 v55; // r12
  unsigned __int64 v56; // rdx
  unsigned __int64 v57; // r9
  unsigned __int64 v58; // rax
  unsigned __int64 v59; // rcx
  __int64 v60; // rdx
  __int64 v61; // rax
  bool v62; // zf
  __int64 v63; // rdi
  unsigned __int64 v64; // r12
  unsigned __int64 v65; // rax
  unsigned __int64 *v66; // rdx
  unsigned __int64 v67; // r11
  char *v68; // rdi
  unsigned __int64 v69; // rax
  __int64 *v70; // rcx
  void *v71; // rsp
  unsigned int v72; // er15
  __int64 v73; // rax
  unsigned __int64 v74; // rax
  __int64 v75; // rax
  __int64 v76; // rax
  __int64 v77; // rax
  __int64 v78; // rax
  __int64 v79; // rax
  __int64 v80; // rax
  __int64 v81; // rax
  __int64 v82; // rax
  __int64 v83; // rax
  unsigned __int64 v84; // rax
  __int64 v85; // rax
  __int64 v86; // rax
  __int64 v87; // rax
  u32 *v88; // r8
  __int64 v89; // rax
  __int64 v90; // rax
  unsigned __int64 v91; // rdx
  unsigned __int64 v92; // rax
  __int64 v93; // rdx
  __int64 v94; // rdx
  unsigned __int8 v95; // al
  unsigned __int64 v96; // r12
  _QWORD *v97; // rax
  __int64 v98; // rax
  __int64 v99; // rax
  __int64 v100; // rdi
  signed __int64 v101; // rdx
  __int64 v102; // rax
  _QWORD *v103; // rsi
  __int64 v104; // rax
  unsigned __int64 v105; // rdi
  size_t v106; // rsi
  __int64 v107; // rdx
  __int64 v108; // rcx
  u32 *v109; // r8
  unsigned __int64 v110; // r9
  __int64 v111; // rdi
  __int64 v112; // rdi
  _BYTE v114[7]; // [rsp+8h] [rbp-1140h] BYREF
  char v115; // [rsp+Fh] [rbp-1139h] BYREF
  char v116[4080]; // [rsp+10h] [rbp-1138h] BYREF
  __int64 v117; // [rsp+1008h] [rbp-140h] BYREF
  u32 *v118; // [rsp+1010h] [rbp-138h]
  int v119; // [rsp+101Ch] [rbp-12Ch]
  unsigned __int64 v120; // [rsp+1020h] [rbp-128h]
  _BYTE *v121; // [rsp+1028h] [rbp-120h]
  unsigned __int64 v122; // [rsp+1030h] [rbp-118h]
  __int64 *v123; // [rsp+1038h] [rbp-110h]
  unsigned int prot; // [rsp+1040h] [rbp-108h]
  char prot_7; // [rsp+1047h] [rbp-101h]
  u32 *v126; // [rsp+1048h] [rbp-100h]
  __int64 v127; // [rsp+1050h] [rbp-F8h]
  __int64 v128; // [rsp+1058h] [rbp-F0h]
  unsigned __int8 *v129; // [rsp+1060h] [rbp-E8h]
  char *v130; // [rsp+1068h] [rbp-E0h]
  void **v131; // [rsp+1070h] [rbp-D8h]
  char *v132; // [rsp+1078h] [rbp-D0h]
  unsigned int stack_executable_hook; // [rsp+1080h] [rbp-C8h]
  unsigned int fd[13]; // [rsp+1084h] [rbp-C4h] BYREF
  unsigned __int64 v135; // [rsp+10B8h] [rbp-90h]
  __int64 v136; // [rsp+1140h] [rbp-8h]

  fd[0] = a2;
  v130 = (char *)a1;
  v132 = a3;
  v129 = a4;
  v131 = dl_debug_initialize(0LL, a9);
  if ( (fxstat(1u, a2, (struct stat *)&fd[1]) & 0x80000000) != 0LL )
  {
    v52 = "cannot stat shared object";
    v15 = 0LL;
    stack_executable_hook = __readfsdword(0xFFFFFFC0);
LABEL_85:
    v131 = 0LL;
LABEL_83:
    v136 = a9;
    lose(stack_executable_hook, fd[0], v130, (__int64)v129, v15, v52, (__int64)v131);
  }
  v14 = *(_QWORD *)&fd[1];
  v128 = *(_QWORD *)&fd[3];
  v15 = (__int64)*(&dl_ns + 18 * a9);
  if ( !v15 )
  {
LABEL_10:
    stack_executable_hook = a7 & 4;
    if ( (a7 & 4) != 0 )
    {
      v15 = 0LL;
      free((__int64)v129, a2, (__int64)&dl_ns, v11, v12, v13);
      _close_nocancel(fd[0]);
      return v15;
    }
    if ( (dl_debug_mask & 0x40) != 0 )
      dl_debug_printf("file=%s [%lu];  generating link map\n", v130, a9);
    v21 = *((_DWORD *)v131 + 6);
    if ( v21 )
    {
      if ( v21 != 1 )
        _assert_fail((__int64)"r->r_state == RT_ADD", (__int64)"dl-load.c", 0x3E7u, "_dl_map_object_from_fd");
      prot_7 = 0;
    }
    else
    {
      *((_DWORD *)v131 + 6) = 1;
      dl_debug_state();
      prot_7 = 1;
    }
    v22 = dl_new_object(v129, (__int64)v130, a6, a5, a7, a9);
    v15 = (__int64)v22;
    if ( !v22 )
    {
      v52 = "cannot create shared object descriptor";
      goto LABEL_156;
    }
    v25 = v132;
    v26 = *((_QWORD *)v132 + 5);
    *((_QWORD *)v22 + 86) = *((_QWORD *)v132 + 4);
    v27 = &v25[v26 + 8];
    LOWORD(prot) = *((_WORD *)v25 + 12);
    v28 = *((unsigned __int16 *)v25 + 32);
    *(_WORD *)(v15 + 696) = v28;
    v29 = 56 * v28;
    v30 = 56 * v28;
    if ( (unsigned __int64)(56 * v28 + v26) > *(_QWORD *)v25 )
    {
      v70 = (__int64 *)((char *)&v117 - ((v29 + 23) & 0xFFFFFFFFFFFFF000LL));
      if ( &v117 != v70 )
      {
        while ( v114 != (_BYTE *)v70 )
          ;
      }
      if ( (((_WORD)v29 + 23) & 0xFF0) != 0 )
      {
        v71 = alloca(((_WORD)v29 + 23) & 0xFF0);
        *(_QWORD *)&v114[(((_WORD)v29 + 23) & 0xFF0) - 8] = *(_QWORD *)&v114[(((_WORD)v29 + 23) & 0xFF0) - 8];
      }
      v72 = fd[0];
      v27 = v116;
      lseek64(fd[0], v26, 0);
      if ( _read_nocancel(v72, v116, v29) != v29 )
      {
        v52 = "cannot read file data";
        goto LABEL_156;
      }
      v28 = *(unsigned __int16 *)(v15 + 696);
      v30 = 56 * v28;
    }
    v123 = &v117;
    v31 = 48 * v28;
    v32 = (__int64 *)((char *)&v117 - (v31 & 0xFFFFFFFFFFFFF000LL));
    if ( &v117 != v32 )
    {
      while ( v114 != (_BYTE *)v32 )
        ;
    }
    v33 = v31 & 0xFFF;
    if ( v33 )
    {
      v34 = alloca(v33);
      *(_QWORD *)&v114[v33 - 8] = *(_QWORD *)&v114[v33 - 8];
    }
    v35 = (unsigned __int64)v114;
    v120 = (unsigned __int64)&v115 >> 3;
    v121 = v114;
    if ( v27 >= &v27[v30] )
      goto LABEL_171;
    v36 = v27;
    v122 = v14;
    v127 = 7LL;
    v37 = 0LL;
    LOBYTE(v126) = 0;
    do
    {
      v38 = *(_DWORD *)v36;
      if ( *(_DWORD *)v36 == 6 )
      {
        *(_QWORD *)(v15 + 680) = *((_QWORD *)v36 + 2);
      }
      else if ( v38 <= 6 )
      {
        switch ( v38 )
        {
          case 2u:
            if ( *((_QWORD *)v36 + 4) )
            {
              *(_QWORD *)(v15 + 16) = *((_QWORD *)v36 + 2);
              *(_WORD *)(v15 + 698) = *((_QWORD *)v36 + 5) >> 4;
            }
            break;
          case 4u:
            v35 = (unsigned __int64)v36;
            if ( (unsigned int)dl_process_pt_note(v15, v36, (_QWORD *)fd[0], v132, (u32 *)v23, v24) )
            {
              v52 = "cannot process note segment";
              goto LABEL_82;
            }
            break;
          case 1u:
            v43 = *((_QWORD *)v36 + 6);
            if ( ((dl_pagesize - 1) & v43) != 0 )
            {
              v52 = "ELF load command alignment not page-aligned";
              goto LABEL_82;
            }
            v44 = *((_QWORD *)v36 + 2);
            v45 = *((_QWORD *)v36 + 1);
            if ( ((v43 - 1) & (v44 - v45)) != 0 )
            {
              v52 = "ELF load command address/offset not properly aligned";
              goto LABEL_82;
            }
            v46 = *((_QWORD *)v36 + 4);
            if ( v45 + v46 > v135 )
            {
              v52 = "ELF load command past end of file";
              goto LABEL_82;
            }
            v24 = v44 + v46;
            v47 = -dl_pagesize & v44;
            v35 = *((_QWORD *)v36 + 5) + v44;
            v48 = (__int64 *)&v114[48 * v37];
            v49 = -dl_pagesize & (v24 + dl_pagesize - 1);
            v50 = v45 & -dl_pagesize;
            *v48 = v47;
            v48[1] = v49;
            v48[2] = v24;
            v48[3] = v35;
            v48[4] = v50;
            if ( (unsigned __int64)(v37 + 1) > 1 )
            {
              v35 = (unsigned __int8)v126;
              if ( *(v48 - 5) != *v48 )
                v35 = 1LL;
              LOBYTE(v126) = v35;
            }
            v51 = 3 * v37++;
            *(_DWORD *)&v116[16 * v51 + 32] = (1934713408 >> (4 * (v36[4] & 7))) & 0xF;
            break;
        }
      }
      else
      {
        switch ( v38 )
        {
          case 0x6474E551u:
            v127 = *((unsigned int *)v36 + 1);
            break;
          case 0x6474E552u:
            *(_QWORD *)(v15 + 1120) = *((_QWORD *)v36 + 2);
            *(_QWORD *)(v15 + 1128) = *((_QWORD *)v36 + 5);
            break;
          case 7u:
            v39 = *((_QWORD *)v36 + 5);
            if ( v39 )
            {
              *(_QWORD *)(v15 + 1072) = v39;
              v40 = *((_QWORD *)v36 + 6);
              *(_QWORD *)(v15 + 1080) = v40;
              v41 = *((_QWORD *)v36 + 2);
              if ( v40 )
                v40 = v41 & (v40 - 1);
              *(_QWORD *)(v15 + 1088) = v40;
              v42 = *((_QWORD *)v36 + 4);
              *(_QWORD *)(v15 + 1056) = v41;
              *(_QWORD *)(v15 + 1064) = v42;
              if ( (*(_BYTE *)(v15 + 796) & 3) != 1 && !dl_tls_dtv_slotinfo_list )
                _assert_fail(
                  (__int64)"false && \"TLS not initialized in static application\"",
                  (__int64)"dl-load.c",
                  0x484u,
                  "_dl_map_object_from_fd");
              *(_QWORD *)(v15 + 1104) = dl_next_tls_modid();
            }
            break;
        }
      }
      v36 += 56;
    }
    while ( v36 < &v27[56 * *(unsigned __int16 *)(v15 + 696)] );
    v53 = v37;
    v54 = v122;
    if ( !v53 )
    {
LABEL_171:
      v52 = "object file has no loadable segments";
      goto LABEL_82;
    }
    v119 = (unsigned __int16)prot;
    if ( (unsigned __int16)prot != 3 )
    {
      if ( (a7 & 0x20000000) != 0 )
      {
        v64 = (unsigned __int64)v121;
        v59 = *(_QWORD *)&v121[48 * v53 - 24];
        v93 = *(_QWORD *)(8 * v120);
        v122 = v59 - v93;
        v94 = *(_QWORD *)v15 + v93;
        *(_QWORD *)(v15 + 848) = v59 + *(_QWORD *)v15;
        v95 = (unsigned __int8)v126;
        *(_QWORD *)(v15 + 840) = v94;
        v66 = (unsigned __int64 *)((unsigned __int8)((v95 ^ 1) & 1) << 6);
        *(_BYTE *)(v15 + 797) = (((v95 ^ 1) & 1) << 6) | *(_BYTE *)(v15 + 797) & 0xBF;
        goto LABEL_71;
      }
      v52 = "cannot dynamically load executable";
      goto LABEL_82;
    }
    v55 = *(_QWORD *)(8 * v120);
    v56 = *(unsigned int *)(8 * v120 + 0x28);
    v57 = *(_QWORD *)(8 * v120 + 0x20);
    v122 = *(_QWORD *)&v121[48 * v53 - 24] - v55;
    prot = v56;
    v58 = mmap64(v55 & dl_use_load_bias, v122, v56, 0x802uLL, fd[0], v57);
    *(_QWORD *)(v15 + 840) = v58;
    if ( v58 == -1LL )
    {
LABEL_74:
      v52 = "failed to map segment from shared object";
      goto LABEL_82;
    }
    v35 = v122;
    v60 = v58 + v122;
    v61 = v58 - v55;
    v62 = (_BYTE)v126 == 0;
    *(_QWORD *)(v15 + 848) = v60;
    *(_QWORD *)v15 = v61;
    if ( !v62 )
    {
      v63 = *(_QWORD *)(8 * v120 + 8);
      v35 = *(_QWORD *)&v121[48 * v53 - 48] - v63;
      if ( (mprotect(v61 + v63, v35, 0LL) & 0x80000000) != 0LL )
      {
LABEL_176:
        v52 = "cannot change memory protections";
        goto LABEL_82;
      }
    }
    *(_BYTE *)(v15 + 797) |= 0x40u;
    v64 = (unsigned __int64)v121;
    while ( 1 )
    {
      if ( (prot & 4) != 0 )
        *(_QWORD *)(v15 + 856) = *(_QWORD *)v15 + *(_QWORD *)(v64 + 8);
      if ( !*(_QWORD *)(v15 + 680) )
      {
        v35 = (unsigned __int64)v132;
        v91 = *(_QWORD *)(v64 + 32);
        v92 = *((_QWORD *)v132 + 5);
        if ( v91 <= v92 )
        {
          v23 = *((unsigned __int16 *)v132 + 32);
          v59 = v91 + *(_QWORD *)(v64 + 8) - *(_QWORD *)v64;
          v35 = v92 + 56 * v23;
          if ( v59 >= v35 )
            *(_QWORD *)(v15 + 680) = *(_QWORD *)v64 + v92 - v91;
        }
      }
      v65 = *(_QWORD *)(v64 + 24);
      v66 = *(unsigned __int64 **)(v64 + 16);
      if ( v65 > (unsigned __int64)v66 )
      {
        v35 = dl_pagesize;
        v23 = (unsigned __int64)v66 + *(_QWORD *)v15;
        v59 = v65 + *(_QWORD *)v15;
        v67 = -dl_pagesize & (v23 + dl_pagesize - 1);
        if ( v59 <= v67 )
          v67 = v65 + *(_QWORD *)v15;
        if ( v23 < v67 )
        {
          if ( (prot & 2) != 0 )
          {
            v35 = 0LL;
            v68 = (char *)v66 + *(_QWORD *)v15;
            v120 = v65 + *(_QWORD *)v15;
            v126 = (u32 *)v67;
            j_memset_ifunc(v68, 0LL, v67 - v23);
            v67 = (unsigned __int64)v126;
            v59 = v120;
          }
          else
          {
            v118 = (u32 *)v67;
            v120 = v59;
            v126 = (u32 *)v23;
            if ( (mprotect(v23 & -dl_pagesize, dl_pagesize, prot | 2) & 0x80000000) != 0LL )
              goto LABEL_176;
            v100 = (__int64)v126;
            v101 = (char *)v118 - (char *)v126;
            v126 = v118;
            v102 = j_memset_ifunc(v100, 0LL, v101);
            v35 = dl_pagesize;
            mprotect(v102 & -dl_pagesize, dl_pagesize, prot);
            v67 = (unsigned __int64)v126;
            v59 = v120;
          }
        }
        if ( v59 > v67 )
        {
          v35 = v59 - v67;
          if ( mmap64(v67, v59 - v67, prot, 0x32uLL, 0xFFFFFFFFuLL, 0LL) == -1LL )
          {
            v52 = "cannot map zero-fill pages";
            goto LABEL_82;
          }
        }
      }
      v64 += 48LL;
LABEL_71:
      if ( v64 >= (unsigned __int64)&v121[48 * v53] )
        break;
      v35 = *(_QWORD *)(v64 + 8);
      v69 = *(_QWORD *)v64;
      prot = *(_DWORD *)(v64 + 40);
      if ( v35 > v69 )
      {
        v35 -= v69;
        if ( mmap64(*(_QWORD *)v15 + v69, v35, prot, 0x812uLL, fd[0], *(_QWORD *)(v64 + 32)) == -1LL )
          goto LABEL_74;
      }
    }
    v73 = *(_QWORD *)(v15 + 16);
    if ( v73 )
    {
      v23 = *(_QWORD *)v15;
      v66 = (unsigned __int64 *)(v73 + *(_QWORD *)v15);
      *(_QWORD *)(v15 + 16) = v66;
      if ( v66 )
      {
        v74 = *v66;
        v35 = v15 + 64;
        if ( *v66 )
        {
          v24 = 1879048226LL;
          do
          {
            if ( v74 > 0x22 )
            {
              if ( 1879048191 - v74 > 0xF )
              {
                v59 = (unsigned int)((2 * (int)v74) >> 1);
                if ( (unsigned int)v59 <= 0xFFFFFFFC )
                {
                  v59 = 1879047679 - v74;
                  if ( 1879047679 - v74 > 0xB )
                  {
                    v59 = 1879047935 - v74;
                    if ( 1879047935 - v74 <= 0xA )
                    {
                      v59 = 0x37FFFFA08LL;
                      *(_QWORD *)(v35 - 8 * v74 + 0x37FFFFA08LL) = v66;
                    }
                  }
                  else
                  {
                    *(_QWORD *)(v35 - 8 * v74 + 0x37FFFF1A8LL) = v66;
                  }
                }
                else
                {
                  *(_QWORD *)(v35 + 8LL * (unsigned int)(50 - v59)) = v66;
                }
                goto LABEL_94;
              }
              v59 = 1879048226 - v74;
              v74 = 1879048226 - v74;
            }
            *(_QWORD *)(v35 + 8 * v74) = v66;
LABEL_94:
            v66 += 2;
            v74 = *v66;
          }
          while ( *v66 );
        }
        if ( v23 )
        {
          v75 = *(_QWORD *)(v15 + 96);
          if ( v75 )
            *(_QWORD *)(v75 + 8) += v23;
          v76 = *(_QWORD *)(v15 + 88);
          if ( v76 )
            *(_QWORD *)(v76 + 8) += v23;
          v77 = *(_QWORD *)(v15 + 104);
          if ( v77 )
            *(_QWORD *)(v77 + 8) += v23;
          v78 = *(_QWORD *)(v15 + 112);
          if ( v78 )
            *(_QWORD *)(v78 + 8) += v23;
          v79 = *(_QWORD *)(v15 + 120);
          if ( v79 )
            *(_QWORD *)(v79 + 8) += v23;
          v80 = *(_QWORD *)(v15 + 248);
          if ( v80 )
            *(_QWORD *)(v80 + 8) += v23;
          v81 = *(_QWORD *)(v15 + 464);
          if ( v81 )
            *(_QWORD *)(v81 + 8) += v23;
          v82 = *(_QWORD *)(v15 + 672);
          if ( v82 )
            *(_QWORD *)(v82 + 8) += v23;
        }
        v83 = *(_QWORD *)(v15 + 224);
        if ( v83 && *(_QWORD *)(v83 + 8) != 7LL )
          _assert_fail(
            (__int64)"info[DT_PLTREL]->d_un.d_val == DT_RELA",
            (__int64)"get-dynamic-info.h",
            0x7Bu,
            "elf_get_dynamic_info");
        if ( *(_QWORD *)(v15 + 120) && *(_QWORD *)(*(_QWORD *)(v15 + 136) + 8LL) != 24LL )
          _assert_fail(
            (__int64)"info[DT_RELAENT]->d_un.d_val == sizeof (ElfW(Rela))",
            (__int64)"get-dynamic-info.h",
            0x83u,
            "elf_get_dynamic_info");
        v66 = *(unsigned __int64 **)(v15 + 304);
        if ( v66 )
        {
          v84 = v66[1];
          *(_DWORD *)(v15 + 992) = v84;
          if ( (v84 & 2) != 0 )
            *(_QWORD *)(v15 + 192) = v66;
          if ( (v84 & 4) != 0 )
            *(_QWORD *)(v15 + 240) = v66;
          if ( (v84 & 8) != 0 )
            *(_QWORD *)(v15 + 256) = v66;
        }
        v85 = *(_QWORD *)(v15 + 376);
        if ( v85 )
        {
          v66 = *(unsigned __int64 **)(v85 + 8);
          LOBYTE(v85) = (_BYTE)v66;
          *(_DWORD *)(v15 + 988) = (_DWORD)v66;
          if ( (dl_debug_mask & 0x40) != 0 )
          {
            v35 = (unsigned int)v66 & 0xFFFFF716;
            if ( ((unsigned int)v66 & 0xFFFFF716) != 0 )
            {
              dl_debug_printf("\nWARNING: Unsupported flag value(s) of 0x%x in DT_FLAGS_1.\n", v35);
              LODWORD(v85) = *(_DWORD *)(v15 + 988);
            }
          }
          if ( (v85 & 1) != 0 )
          {
            v66 = *(unsigned __int64 **)(v15 + 376);
            *(_QWORD *)(v15 + 256) = v66;
          }
        }
        else
        {
          LODWORD(v85) = *(_DWORD *)(v15 + 988);
        }
        if ( *(_QWORD *)(v15 + 296) )
          *(_QWORD *)(v15 + 184) = 0LL;
        goto LABEL_135;
      }
    }
    else if ( v119 == 3 )
    {
      v52 = "object file has no dynamic section";
      goto LABEL_82;
    }
    LODWORD(v85) = *(_DWORD *)(v15 + 988);
LABEL_135:
    if ( (v85 & 0x40) == 0 || a7 >= 0 )
    {
      v86 = *(_QWORD *)(v15 + 680);
      if ( v86 )
      {
        *(_QWORD *)(v15 + 680) = *(_QWORD *)v15 + v86;
      }
      else
      {
        v96 = 56LL * *((unsigned __int16 *)v132 + 32);
        v97 = malloc(v96, v35, v66, v59, (u32 *)v23, v24);
        if ( !v97 )
        {
          v52 = "cannot allocate memory for program header";
          goto LABEL_156;
        }
        v35 = (unsigned __int64)v27;
        v98 = j_memcpy(v97, v27, v96);
        *(_BYTE *)(v15 + 796) |= 0x80u;
        *(_QWORD *)(v15 + 680) = v98;
      }
      if ( ((unsigned __int8)v127 & (unsigned __int8)~(_BYTE)dl_stack_flags & 1) != 0 )
      {
        _stack_prot |= 7u;
        stack_executable_hook = dl_make_stack_executable_hook(a8, v35);
        if ( stack_executable_hook )
        {
          v52 = "cannot enable executable stack as shared object requires";
          goto LABEL_82;
        }
      }
      v87 = *(_QWORD *)(v15 + 1056);
      if ( v87 )
        *(_QWORD *)(v15 + 1056) = *(_QWORD *)v15 + v87;
      if ( !(unsigned int)_close_nocancel(fd[0]) )
      {
        if ( v119 == 2 && (*(_BYTE *)(v15 + 796) & 3) != 0 )
          _assert_fail(
            (__int64)"type != ET_EXEC || l->l_type == lt_executable",
            (__int64)"dl-load.c",
            0x52Au,
            "_dl_map_object_from_fd");
        v88 = *(u32 **)v15;
        v89 = *(_QWORD *)v15 + *(_QWORD *)(v15 + 688);
        *(_QWORD *)(v15 + 688) = v89;
        if ( (dl_debug_mask & 0x40) != 0 )
          dl_debug_printf(
            "  dynamic: 0x%0*lx  base: 0x%0*lx   size: 0x%0*Zx\n    entry: 0x%0*lx  phdr: 0x%0*lx  phnum:   %*u\n\n",
            16LL,
            *(_QWORD *)(v15 + 16),
            16LL,
            v88,
            16LL,
            v122,
            16LL,
            v89,
            16LL,
            *(_QWORD *)(v15 + 680),
            16LL,
            *(unsigned __int16 *)(v15 + 696));
        dl_setup_hash(v15);
        if ( (a7 & 8) == 0 )
        {
          if ( *(_QWORD *)(v15 + 192) )
          {
            v103 = *(_QWORD **)(v15 + 904);
            if ( *v103 != v15 + 704 )
            {
              **(_QWORD **)(v15 + 720) = v15;
              v104 = *(_QWORD *)(v15 + 896);
              *(_DWORD *)(v15 + 728) = 1;
              j_memmove(v103 + 1, v103, 8 * v104 - 8);
              **(_QWORD **)(v15 + 904) = v15 + 720;
            }
          }
        }
        if ( (*(_BYTE *)(v15 + 988) & 0x20) != 0 )
          dl_initfirst = v15;
        v90 = v128;
        v62 = dl_profile == 0;
        *(_QWORD *)(v15 + 928) = v54;
        *(_QWORD *)(v15 + 936) = v90;
        if ( !v62 )
        {
          v99 = *(_QWORD *)(v15 + 176);
          if ( v99 )
            add_name_to_object_isra_5(
              *(_QWORD **)(v15 + 56),
              (void *)(*(_QWORD *)(*(_QWORD *)(v15 + 104) + 8LL) + *(_QWORD *)(v99 + 8)));
        }
        dl_add_to_namespace_list((_QWORD *)v15, a9);
        return v15;
      }
      v52 = "cannot close file descriptor";
LABEL_156:
      stack_executable_hook = __readfsdword(0xFFFFFFC0);
      goto LABEL_82;
    }
    v105 = *(_QWORD *)(v15 + 840);
    v106 = *(_QWORD *)(v15 + 848) - v105;
    munmap(v105, v106);
    v111 = *(_QWORD *)(v15 + 56);
    if ( !*(_DWORD *)(v111 + 16) )
      free(v111, v106, v107, v108, v109, v110);
    v52 = "shared object cannot be dlopen()ed";
    if ( *(char *)(v15 + 796) < 0 )
    {
      v112 = *(_QWORD *)(v15 + 680);
      v132 = "shared object cannot be dlopen()ed";
      free(v112, v106, v107, v108, v109, (unsigned __int64)"shared object cannot be dlopen()ed");
      v52 = v132;
    }
LABEL_82:
    if ( prot_7 )
      goto LABEL_83;
    goto LABEL_85;
  }
  while ( (*(_BYTE *)(v15 + 797) & 0x20) != 0
       || *(_QWORD *)&fd[1] != *(_QWORD *)(v15 + 928)
       || *(_QWORD *)&fd[3] != *(_QWORD *)(v15 + 936) )
  {
    v15 = *(_QWORD *)(v15 + 24);
    if ( !v15 )
      goto LABEL_10;
  }
  _close_nocancel(fd[0]);
  free((__int64)v129, a2, v16, v17, v18, v19);
  add_name_to_object_isra_5(*(_QWORD **)(v15 + 56), v130);
  return v15;
}
// 4678CE: write access to const memory at 4A7F10 has been detected
// 466BE6: variable 'v16' is possibly undefined
// 466BE6: variable 'v17' is possibly undefined
// 466BE6: variable 'v18' is possibly undefined
// 466BE6: variable 'v19' is possibly undefined
// 466FCB: variable 'v23' is possibly undefined
// 466FCB: variable 'v24' is possibly undefined
// 467657: variable 'v11' is possibly undefined
// 467657: variable 'v12' is possibly undefined
// 467657: variable 'v13' is possibly undefined
// 467887: variable 'v66' is possibly undefined
// 467887: variable 'v59' is possibly undefined
// 467B1C: variable 'v107' is possibly undefined
// 467B1C: variable 'v108' is possibly undefined
// 467B1C: variable 'v109' is possibly undefined
// 467B1C: variable 'v110' is possibly undefined
// 401030: using guessed type __int64 __fastcall j_memmove(_QWORD, _QWORD, _QWORD);
// 401040: using guessed type __int64 __fastcall j_memcpy(_QWORD, _QWORD, _QWORD);
// 401090: using guessed type __int64 __fastcall j_memset_ifunc(_QWORD, _QWORD, _QWORD);
// 4A7F10: using guessed type int _stack_prot;
// 4A91E8: using guessed type int dl_stack_flags;
// 4A91F8: using guessed type __int64 dl_pagesize;
// 4A9218: using guessed type __int64 dl_use_load_bias;
// 4A9220: using guessed type __int64 (__fastcall *dl_make_stack_executable_hook)(_QWORD, _QWORD);
// 4A9280: using guessed type void *dl_ns;
// 4AB7E0: using guessed type __int64 dl_tls_dtv_slotinfo_list;
// 4AB880: using guessed type int dl_debug_mask;
// 4AB890: using guessed type __int64 dl_profile;
// 4AB918: using guessed type __int64 dl_initfirst;

//----- (0000000000467B30) ----------------------------------------------------
void __fastcall add_path_isra_4_constprop_11(__int64 a1, __int64 *a2)
{
  __int64 *v2; // r12
  __int64 v4; // rsi
  unsigned __int64 v5; // rdx
  __int64 v6; // rcx
  __int64 v7; // rax
  _BYTE *v8; // rdi
  __int64 v9; // rbx
  _BYTE *v10; // rax

  if ( a2 != (__int64 *)-1LL )
  {
    v2 = a2;
    v4 = *a2;
    do
    {
      while ( 1 )
      {
        ++v2;
        v6 = *(_QWORD *)(a1 + 8);
        v5 = *(_QWORD *)(v4 + 32);
        if ( *(_BYTE *)a1 )
          break;
        v7 = *(unsigned int *)(a1 + 4);
        *(_DWORD *)(a1 + 4) = v7 + 1;
        v8 = *(_BYTE **)(a1 + 16);
        v9 = v6 + 16 * v7;
        *(_QWORD *)(v9 + 16) = v8;
        if ( v5 > 1 )
        {
          v10 = (_BYTE *)j_mempcpy(v8, *(_QWORD *)(v4 + 24), v5 - 1);
        }
        else
        {
          *(_QWORD *)(a1 + 16) = v8 + 1;
          *v8 = (v5 != 0) + 46;
          v10 = *(_BYTE **)(a1 + 16);
        }
        *(_QWORD *)(a1 + 16) = v10 + 1;
        *v10 = 0;
        v4 = *v2;
        *(_DWORD *)(v9 + 24) = 0;
        if ( !v4 )
          return;
      }
      v4 = *v2;
      ++*(_DWORD *)(v6 + 8);
      if ( v5 < 2 )
        v5 = 2LL;
      *(_QWORD *)v6 += v5;
    }
    while ( v4 );
  }
}
// 4010B0: using guessed type __int64 __fastcall j_mempcpy(_QWORD, _QWORD, _QWORD);

//----- (0000000000467C00) ----------------------------------------------------
__int64 __fastcall dl_dst_count(__int64 a1)
{
  __int64 v1; // rbp
  __int64 i; // rax
  _BYTE *v4; // rbx
  __int64 v5; // rax

  v1 = 0LL;
  for ( i = j_strchr_ifunc(a1, 36LL); i; i = j_strchr_ifunc(v4, 36LL) )
  {
    v4 = (_BYTE *)(i + 1);
    v5 = is_dst((_BYTE *)(i + 1), (__int64)"ORIGIN");
    if ( !v5 )
    {
      v5 = is_dst(v4, (__int64)"PLATFORM");
      if ( !v5 )
      {
        v5 = is_dst(v4, (__int64)&off_491E7A);
        if ( !v5 )
          continue;
      }
    }
    ++v1;
    v4 += v5;
  }
  return v1;
}
// 4010D0: using guessed type __int64 __fastcall j_strchr_ifunc(_QWORD, _QWORD);
// 491E7A: using guessed type void *__ptr32 off_491E7A;

//----- (0000000000467CA0) ----------------------------------------------------
char *__fastcall dl_dst_substitute(__int64 a1, char *a2, char *a3)
{
  char *v3; // r15
  char *v4; // r13
  bool v5; // bp
  char v7; // al
  __int64 v8; // rcx
  char *v9; // rax
  char v11; // al
  __int64 v12; // [rsp+0h] [rbp-48h]

  v3 = a3;
  v4 = a2;
  v5 = 0;
  v7 = *a2;
  do
  {
    while ( 1 )
    {
      ++v4;
      if ( v7 != 36 )
      {
        *v3++ = v7;
        goto LABEL_3;
      }
      v8 = is_dst(v4, (__int64)"ORIGIN");
      if ( v8 )
        break;
      v8 = is_dst(v4, (__int64)"PLATFORM");
      if ( v8 )
      {
        v9 = (char *)(dl_platform - 1);
        goto LABEL_8;
      }
      v8 = is_dst(v4, (__int64)&off_491E7A);
      if ( v8 )
      {
        v9 = (char *)&off_491E7A + 3;
        goto LABEL_8;
      }
      *v3++ = 36;
LABEL_3:
      v7 = *v4;
      if ( !*v4 )
        goto LABEL_10;
    }
    if ( _libc_enable_secure )
    {
      if ( v4 != a2 + 1 )
        goto LABEL_19;
      v11 = v4[v8];
      if ( v11 )
      {
        if ( v11 != 47 )
          goto LABEL_19;
      }
      v5 = (*(_BYTE *)(a1 + 796) & 3) == 0;
      v9 = (char *)(*(_QWORD *)(a1 + 832) - 1LL);
    }
    else
    {
      v5 = 0;
      v9 = (char *)(*(_QWORD *)(a1 + 832) - 1LL);
    }
LABEL_8:
    if ( (unsigned __int64)v9 > 0xFFFFFFFFFFFFFFFDLL )
      goto LABEL_19;
    v12 = v8;
    v3 = (char *)j_stpcpy(v3);
    v4 += v12;
    v7 = *v4;
  }
  while ( *v4 );
LABEL_10:
  if ( !v5 || is_trusted_path_normalize(a3, v3 - a3) )
  {
    *v3 = 0;
    return a3;
  }
LABEL_19:
  *a3 = 0;
  return a3;
}
// 401058: using guessed type __int64 __fastcall j_stpcpy(_QWORD);
// 491E7A: using guessed type void *__ptr32 off_491E7A;
// 4A7AD8: using guessed type int _libc_enable_secure;
// 4AB8A8: using guessed type __int64 dl_platform;

//----- (0000000000467E20) ----------------------------------------------------
char *__fastcall expand_dynamic_string_token(__int64 a1, char *a2)
{
  __int64 v3; // rax
  __int64 v5; // rbp
  __int64 v6; // rax
  __int64 v7; // rcx
  u32 *v8; // r8
  __int64 v9; // r9
  __int64 v10; // rdi
  __int64 v11; // r13
  unsigned __int64 v12; // rax
  unsigned __int64 v13; // rdx
  char *v14; // rax
  __int64 origin; // rax

  v3 = dl_dst_count((__int64)a2);
  if ( !v3 )
    return (char *)strdup((__int64)a2, (__int64)a2);
  v5 = v3;
  v6 = j_strlen_ifunc(a2);
  v10 = *(_QWORD *)(a1 + 832);
  v11 = v6;
  if ( !v10 )
  {
    if ( **(_BYTE **)(a1 + 8) )
      _assert_fail(
        (__int64)"(l)->l_name[0] == '\\0' || IS_RTLD (l)",
        (__int64)"dl-load.c",
        0x18Bu,
        "expand_dynamic_string_token");
    origin = dl_get_origin();
    *(_QWORD *)(a1 + 832) = origin;
    if ( (unsigned __int64)(origin - 1) <= 0xFFFFFFFFFFFFFFFDLL )
    {
      v12 = j_strlen_ifunc(origin);
      goto LABEL_6;
    }
    goto LABEL_12;
  }
  if ( v10 == -1 )
  {
LABEL_12:
    v12 = 0LL;
    goto LABEL_6;
  }
  v12 = j_strlen_ifunc(v10);
LABEL_6:
  v13 = 5LL;
  if ( (unsigned __int64)dl_platformlen >= 5 )
    v13 = dl_platformlen;
  if ( v13 < v12 )
    v13 = v12;
  v14 = (char *)malloc(v11 + (v13 - 4) * v5 + 1, (__int64)a2, (_QWORD *)(v13 - 4), v7, v8, v9);
  if ( v14 )
    return dl_dst_substitute(a1, a2, v14);
  else
    return 0LL;
}
// 467E9F: variable 'v7' is possibly undefined
// 467E9F: variable 'v8' is possibly undefined
// 467E9F: variable 'v9' is possibly undefined
// 4010C8: using guessed type __int64 __fastcall j_strlen_ifunc(_QWORD);
// 4AB878: using guessed type __int64 dl_platformlen;

//----- (0000000000467F30) ----------------------------------------------------
_QWORD *__fastcall fillin_rpath(__int64 a1, _QWORD *a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v7; // rbx
  __int64 v8; // rsi
  char *v9; // rax
  __int64 v10; // rcx
  u32 *v11; // r8
  __int64 *v12; // r9
  char *v13; // r14
  char *v14; // rax
  __int64 v15; // rax
  __int64 v16; // rdx
  __int64 v17; // rdx
  unsigned __int64 v18; // r15
  __int64 v19; // r13
  _QWORD *v20; // r12
  __int64 v21; // rdx
  __int64 v22; // rax
  __int64 *v23; // rax
  char *v24; // rdi
  _BYTE *v25; // rax
  bool v26; // cf
  __int64 v27; // rax
  __int64 v28; // rax
  __int64 v30; // [rsp+0h] [rbp-88h]
  __int64 v34; // [rsp+28h] [rbp-60h]
  __int64 *v35; // [rsp+30h] [rbp-58h]
  __int64 v37[8]; // [rsp+48h] [rbp-40h] BYREF

  v7 = 0LL;
  v37[0] = a1;
  while ( 1 )
  {
    v8 = a3;
    v9 = (char *)strsep(v37, a3);
    v13 = v9;
    if ( !v9 )
      break;
    if ( *v9 )
    {
      v8 = (__int64)v9;
      v14 = expand_dynamic_string_token(a6, v9);
      v13 = v14;
      if ( v14 )
      {
        v15 = j_strlen_ifunc(v14);
        if ( v15 )
        {
          if ( v15 != 1 )
          {
            v17 = v15 - 1;
            if ( v13[v15 - 1] != 47 )
            {
              v17 = v15;
              goto LABEL_38;
            }
            while ( v17 != 1 )
            {
              if ( v13[v17 - 1] != 47 )
                goto LABEL_38;
              --v17;
            }
          }
          if ( *v13 == 47 )
          {
            v30 = (__int64)v13;
            v18 = 1LL;
          }
          else
          {
            v17 = 1LL;
LABEL_38:
            v18 = v17 + 1;
            v13[v17] = 47;
            v30 = (__int64)v13;
          }
          v19 = dl_all_dirs;
          if ( !dl_all_dirs )
            goto LABEL_27;
          goto LABEL_15;
        }
        free((__int64)v13, v8, v16, v10, v11, (unsigned __int64)v12);
      }
    }
    else
    {
      v19 = dl_all_dirs;
      v18 = 0LL;
      v30 = 0LL;
      if ( !dl_all_dirs )
      {
LABEL_27:
        if ( a5 )
          v34 = j_strlen_ifunc(a5) + 1;
        else
          v34 = 0LL;
        v23 = malloc(v34 + 4 * ncapstr + 41 + v18, v8, (_QWORD *)(4 * ncapstr + 40), v10, v11, (__int64)v12);
        if ( !v23 )
          dl_signal_error(12, 0LL, 0LL, "cannot create cache for search path");
        v24 = (char *)v23 + 4 * ncapstr + 40;
        v8 = (__int64)v13;
        v35 = v23;
        v23[3] = (__int64)v24;
        v25 = (_BYTE *)j_mempcpy(v24, v13, v18);
        v12 = v35;
        v26 = max_dirnamelen < v18;
        *v25 = 0;
        v35[4] = v18;
        if ( v26 )
          max_dirnamelen = v18;
        v27 = 0LL;
        v21 = 2 * (unsigned int)(*v13 != 47);
        if ( ncapstr )
        {
          do
            *((_DWORD *)v35 + v27++ + 10) = v21;
          while ( ncapstr != v27 );
        }
        v35[1] = a4;
        if ( a5 )
        {
          v8 = a5;
          v28 = j_memcpy((char *)v35 + 4 * ncapstr + v18 + 41, a5, v34);
          v12 = v35;
          v35[2] = v28;
        }
        else
        {
          v35[2] = 0LL;
        }
        dl_all_dirs = (__int64)v12;
        *v12 = v19;
        a2[v7++] = v12;
        goto LABEL_25;
      }
LABEL_15:
      v20 = (_QWORD *)v19;
      while ( 1 )
      {
        if ( v20[4] == v18 )
        {
          v8 = v20[3];
          if ( !(unsigned int)j_memcmp_ifunc(v13, v8, v18) )
            break;
        }
        v20 = (_QWORD *)*v20;
        if ( !v20 )
          goto LABEL_27;
      }
      if ( v7 )
      {
        if ( v20 == (_QWORD *)*a2 )
          goto LABEL_25;
        v22 = 0LL;
        while ( v7 != ++v22 )
        {
          if ( (_QWORD *)a2[v22] == v20 )
            goto LABEL_25;
        }
      }
      a2[v7++] = v20;
LABEL_25:
      free(v30, v8, v21, v10, v11, (unsigned __int64)v12);
    }
  }
  a2[v7] = 0LL;
  return a2;
}
// 468075: variable 'v21' is possibly undefined
// 468075: variable 'v10' is possibly undefined
// 468075: variable 'v11' is possibly undefined
// 468075: variable 'v12' is possibly undefined
// 4681AB: variable 'v16' is possibly undefined
// 401040: using guessed type __int64 __fastcall j_memcpy(_QWORD, _QWORD, _QWORD);
// 401080: using guessed type __int64 __fastcall j_memcmp_ifunc(_QWORD, _QWORD, _QWORD);
// 4010B0: using guessed type __int64 __fastcall j_mempcpy(_QWORD, _QWORD, _QWORD);
// 4010C8: using guessed type __int64 __fastcall j_strlen_ifunc(_QWORD);
// 4A7EE8: using guessed type __int64 ncapstr;
// 4AB010: using guessed type __int64 max_dirnamelen;
// 4AB920: using guessed type __int64 dl_all_dirs;
// 467F30: using guessed type __int64 var_40[8];

//----- (0000000000468230) ----------------------------------------------------
__int64 __fastcall cache_rpath_part_8(__int64 a1, __int64 a2, int a3, __int64 a4)
{
  __int64 result; // rax
  __int64 v5; // r8
  char *v6; // rax
  char *v7; // rbp
  _BYTE *v8; // r8
  char *v12; // rax
  _QWORD *v13; // rdx
  __int64 v14; // rcx
  u32 *v15; // r8
  __int64 v16; // r9
  __int64 v17; // r14
  char v18; // al
  unsigned __int64 v19; // rdi
  _QWORD *v20; // rax
  __int64 v21; // rdx
  __int64 v22; // rcx
  u32 *v23; // r8
  unsigned __int64 v24; // r9
  _QWORD *v25; // r15
  __int64 v26; // rsi
  __int64 v27; // rdx
  __int64 v28; // rcx
  u32 *v29; // r8
  unsigned __int64 v30; // r9
  __int64 v31; // rdx
  __int64 v32; // rcx
  u32 *v33; // r8
  unsigned __int64 v34; // r9
  char v35; // r11
  char v36; // dl
  char *v37; // r9
  char v38; // r10
  char v39; // dl
  const char *v40; // rcx

  result = *(_QWORD *)(a1 + 8LL * a3 + 64);
  if ( !result )
  {
    *(_QWORD *)a2 = -1LL;
    return result;
  }
  v5 = *(_QWORD *)(result + 8);
  v6 = (char *)dl_inhibit_rpath;
  v7 = *(char **)(a1 + 8);
  v8 = (_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 104) + 8LL) + v5);
  if ( dl_inhibit_rpath && !_libc_enable_secure )
  {
    v35 = *v7;
    v36 = *(_BYTE *)dl_inhibit_rpath;
    do
    {
      if ( v35 == v36 )
      {
        if ( !v35 )
          goto LABEL_4;
        v37 = *(char **)(a1 + 8);
        while ( 1 )
        {
          ++v6;
          ++v37;
          v36 = *v6;
          v38 = *v37;
          if ( *v6 != *v37 )
            break;
          if ( !v36 )
            goto LABEL_26;
        }
      }
      else
      {
        v38 = *v7;
      }
      if ( v38 )
        goto LABEL_22;
LABEL_26:
      if ( !v36 || v36 == 58 )
        goto LABEL_4;
      do
      {
LABEL_22:
        v39 = *v6;
        if ( !*v6 )
          goto LABEL_3;
        ++v6;
      }
      while ( v39 != 58 );
      v36 = *v6;
    }
    while ( *v6 );
  }
LABEL_3:
  if ( !*v8 )
  {
LABEL_4:
    *(_QWORD *)a2 = -1LL;
    return 0LL;
  }
  v12 = (char *)strdup((__int64)v8, a2);
  v17 = (__int64)v12;
  if ( !v12 )
  {
    v40 = "cannot create RUNPATH/RPATH copy";
LABEL_33:
    dl_signal_error(12, 0LL, 0LL, v40);
  }
  v18 = *v12;
  if ( v18 )
  {
    v13 = (_QWORD *)v17;
    v14 = 0LL;
    do
    {
      v13 = (_QWORD *)((char *)v13 + 1);
      v14 += v18 == 58;
      v18 = *(_BYTE *)v13;
    }
    while ( *(_BYTE *)v13 );
    v19 = 8 * v14 + 16;
  }
  else
  {
    v19 = 16LL;
  }
  v20 = malloc(v19, a2, v13, v14, v15, v16);
  v25 = v20;
  if ( !v20 )
  {
    free(v17, a2, v21, v22, v23, v24);
    v40 = "cannot create cache for search path";
    goto LABEL_33;
  }
  v26 = (__int64)v20;
  fillin_rpath(v17, v20, (__int64)":", a4, (__int64)v7, a1);
  free(v17, v26, v27, v28, v29, v30);
  if ( *v25 )
  {
    *(_QWORD *)a2 = v25;
    result = 1LL;
    *(_DWORD *)(a2 + 8) = 1;
  }
  else
  {
    free((__int64)v25, v26, v31, v32, v33, v34);
    *(_QWORD *)a2 = -1LL;
    return 0LL;
  }
  return result;
}
// 4682DE: variable 'v13' is possibly undefined
// 4682DE: variable 'v14' is possibly undefined
// 4682DE: variable 'v15' is possibly undefined
// 4682DE: variable 'v16' is possibly undefined
// 46830D: variable 'v27' is possibly undefined
// 46830D: variable 'v28' is possibly undefined
// 46830D: variable 'v29' is possibly undefined
// 46830D: variable 'v30' is possibly undefined
// 4683FB: variable 'v31' is possibly undefined
// 4683FB: variable 'v32' is possibly undefined
// 4683FB: variable 'v33' is possibly undefined
// 4683FB: variable 'v34' is possibly undefined
// 468418: variable 'v21' is possibly undefined
// 468418: variable 'v22' is possibly undefined
// 468418: variable 'v23' is possibly undefined
// 468418: variable 'v24' is possibly undefined
// 4A7AD8: using guessed type int _libc_enable_secure;
// 4AB930: using guessed type __int64 dl_inhibit_rpath;

//----- (0000000000468440) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
const char *__fastcall dl_init_paths(_BYTE *a1)
{
  __int64 v1; // rsi
  _QWORD *v2; // rdx
  __int64 v3; // rcx
  u32 *v4; // r8
  __int64 v5; // r9
  _QWORD *v6; // rax
  u32 *v7; // r8
  __int64 v8; // r9
  _QWORD *v9; // r14
  unsigned __int64 v10; // rdx
  __int64 v11; // rbx
  _QWORD *v12; // rax
  __int64 v13; // rbx
  __int64 v14; // rdx
  _QWORD *v15; // rdx
  _QWORD *v16; // rsi
  const char *result; // rax
  __int64 v18; // rax
  __int64 v19; // rsi
  _QWORD *v20; // rdx
  __int64 v21; // rcx
  _BYTE *v22; // rbx
  u32 *v23; // r8
  __int64 v24; // r9
  char v25; // al
  __int64 v26; // rax
  unsigned __int64 v27; // rdi
  _QWORD *v28; // rax
  __int64 v29; // rsi
  __int64 v30; // rdx
  __int64 v31; // rcx
  u32 *v32; // r8
  unsigned __int64 v33; // r9
  void *v34; // rsp
  const char *v35; // rcx
  _BYTE v37[15]; // [rsp+8h] [rbp-20h] BYREF

  v1 = dl_platformlen;
  capstr = (__int64)dl_important_hwcaps(dl_platform, dl_platformlen, &ncapstr, &max_capstrlen);
  v6 = malloc(0x18uLL, v1, v2, v3, v4, v5);
  rtld_search_dirs = (__int64)v6;
  if ( !v6 )
  {
    v35 = "cannot create search path array";
LABEL_28:
    dl_signal_error(12, 0LL, 0LL, v35);
  }
  v9 = v6;
  v10 = (4 * ncapstr + 79) / 0x28uLL;
  v11 = 5 * v10;
  v12 = malloc(80 * v10, v1, (_QWORD *)v10, 0xCCCCCCCCCCCCCCCDLL, v7, v8);
  *v9 = v12;
  if ( !v12 )
    goto LABEL_27;
  dword_4A7ED8 = 0;
  v13 = v11;
  dl_all_dirs = (__int64)v12;
  v12[1] = "system search path";
  v12[2] = 0LL;
  v12[3] = "/lib64/";
  v12[4] = 7LL;
  if ( ncapstr )
  {
    v14 = 0LL;
    do
      *((_DWORD *)v12 + v14++ + 10) = 0;
    while ( ncapstr != v14 );
    v15 = &v12[v13];
    v16 = v9 + 2;
    *v12 = &v12[v13];
    v9[1] = &v12[v13];
    v15[1] = "system search path";
    v15[2] = 0LL;
    v15[4] = 11LL;
    v15[3] = "/usr/lib64/";
    result = 0LL;
    do
      *((_DWORD *)v15 + (_QWORD)result++ + 10) = 0;
    while ( (const char *)ncapstr != result );
  }
  else
  {
    v15 = &v12[v13];
    v16 = v9 + 2;
    *v12 = &v12[v13];
    result = "/usr/lib64/";
    v9[1] = v15;
    v15[1] = "system search path";
    v15[2] = 0LL;
    v15[3] = "/usr/lib64/";
    v15[4] = 11LL;
  }
  *v15 = 0LL;
  max_dirnamelen = 11LL;
  *v16 = 0LL;
  if ( !a1 || !*a1 )
  {
    env_path_list = -1LL;
    return result;
  }
  v18 = j_strlen_ifunc(a1);
  while ( v37 != &v37[-((v18 + 24) & 0xFFFFFFFFFFFFF000LL)] )
    ;
  if ( (((_WORD)v18 + 24) & 0xFF0) != 0 )
  {
    v34 = alloca(((_WORD)v18 + 24) & 0xFF0);
    *(_QWORD *)&v37[(((_WORD)v18 + 24) & 0xFF0) - 8] = *(_QWORD *)&v37[(((_WORD)v18 + 24) & 0xFF0) - 8];
  }
  v19 = (__int64)a1;
  v22 = (_BYTE *)j_memcpy(v37, a1, v18 + 1);
  v25 = *v22;
  if ( *v22 )
  {
    v20 = v22;
    v19 = 1LL;
    do
    {
      v21 = v19 + 1;
      if ( (unsigned __int8)(v25 - 58) <= 1u )
      {
        v26 = v19 + 2;
        ++v19;
        v21 = v26;
      }
      v20 = (_QWORD *)((char *)v20 + 1);
      v25 = *(_BYTE *)v20;
    }
    while ( *(_BYTE *)v20 );
    v27 = 8 * v21;
  }
  else
  {
    v27 = 16LL;
  }
  v28 = malloc(v27, v19, v20, v21, v23, v24);
  env_path_list = (__int64)v28;
  if ( !v28 )
  {
LABEL_27:
    v35 = "cannot create cache for search path";
    goto LABEL_28;
  }
  v29 = (__int64)v28;
  result = (const char *)fillin_rpath((__int64)v22, v28, (__int64)":;", (__int64)"LD_LIBRARY_PATH", 0LL, 0LL);
  if ( !*(_QWORD *)env_path_list )
  {
    result = (const char *)free(env_path_list, v29, v30, v31, v32, v33);
    env_path_list = -1LL;
  }
  dword_4A7F08 = 0;
  return result;
}
// 468478: write access to const memory at 4A7EF0 has been detected
// 468484: write access to const memory at 4A7ED0 has been detected
// 4684E4: write access to const memory at 4A7ED8 has been detected
// 46859E: write access to const memory at 4A7F00 has been detected
// 46865D: write access to const memory at 4A7F00 has been detected
// 468699: write access to const memory at 4A7F08 has been detected
// 4686F6: write access to const memory at 4A7F00 has been detected
// 46847F: variable 'v2' is possibly undefined
// 46847F: variable 'v3' is possibly undefined
// 46847F: variable 'v4' is possibly undefined
// 46847F: variable 'v5' is possibly undefined
// 4684C5: variable 'v7' is possibly undefined
// 4684C5: variable 'v8' is possibly undefined
// 468658: variable 'v20' is possibly undefined
// 468658: variable 'v21' is possibly undefined
// 468658: variable 'v23' is possibly undefined
// 468658: variable 'v24' is possibly undefined
// 4686F1: variable 'v30' is possibly undefined
// 4686F1: variable 'v31' is possibly undefined
// 4686F1: variable 'v32' is possibly undefined
// 4686F1: variable 'v33' is possibly undefined
// 401040: using guessed type __int64 __fastcall j_memcpy(_QWORD, _QWORD, _QWORD);
// 4010C8: using guessed type __int64 __fastcall j_strlen_ifunc(_QWORD);
// 4A7ED0: using guessed type __int64 rtld_search_dirs;
// 4A7ED8: using guessed type int dword_4A7ED8;
// 4A7EE0: using guessed type __int64 max_capstrlen;
// 4A7EE8: using guessed type __int64 ncapstr;
// 4A7EF0: using guessed type __int64 capstr;
// 4A7F00: using guessed type __int64 env_path_list;
// 4A7F08: using guessed type int dword_4A7F08;
// 4AB010: using guessed type __int64 max_dirnamelen;
// 4AB878: using guessed type __int64 dl_platformlen;
// 4AB8A8: using guessed type __int64 dl_platform;
// 4AB920: using guessed type __int64 dl_all_dirs;

//----- (0000000000468730) ----------------------------------------------------
u32 *__fastcall dl_map_object(__int64 a1, char *a2, char a3, int a4, int a5, __int64 a6)
{
  __int64 v6; // rbp
  __int64 v7; // r12
  u32 *v10; // r15
  __int64 v11; // rax
  void *v12; // rbp
  char v14; // r15
  __int64 v15; // rsi
  unsigned __int8 *v16; // rax
  unsigned int v17; // eax
  __int64 v18; // rdx
  __int64 v19; // rcx
  u32 *v20; // r8
  unsigned __int64 v21; // r9
  unsigned __int8 *v22; // rax
  __int64 v23; // rdx
  __int64 v24; // rcx
  u32 *v25; // r8
  unsigned __int64 v26; // r9
  __int64 v27; // r14
  unsigned int v28; // eax
  __int64 v29; // rax
  unsigned int v30; // eax
  __int64 v31; // rdx
  __int64 v32; // rcx
  u32 *v33; // r8
  __int64 cache_lookup; // r9
  unsigned int v35; // eax
  const char *v36; // rcx
  __int64 v37; // r8
  char *v38; // rdi
  __int64 v39; // rax
  __int64 v40; // r15
  unsigned __int8 v41; // bp
  unsigned int v42; // eax
  __int64 v43; // rax
  unsigned __int8 v44; // al
  __int64 v45; // r15
  __int64 v46; // rax
  __int64 v47; // rax
  unsigned int v48; // eax
  int v50; // [rsp+8h] [rbp-3F0h]
  __int64 v53; // [rsp+18h] [rbp-3E0h]
  unsigned __int8 *v54; // [rsp+20h] [rbp-3D8h]
  void *v55; // [rsp+20h] [rbp-3D8h]
  __int64 v56; // [rsp+48h] [rbp-3B0h]
  char v57; // [rsp+5Fh] [rbp-399h] BYREF
  unsigned __int8 *v58; // [rsp+60h] [rbp-398h] BYREF
  __int64 v59; // [rsp+68h] [rbp-390h] BYREF
  char v60[904]; // [rsp+70h] [rbp-388h] BYREF

  if ( a6 < 0 )
    _assert_fail((__int64)"nsid >= 0", (__int64)"dl-load.c", 0x797u, "_dl_map_object");
  v6 = a6;
  if ( a6 >= (unsigned __int64)dl_nns )
    _assert_fail((__int64)"nsid < GL(dl_nns)", (__int64)"dl-load.c", 0x798u, "_dl_map_object");
  v7 = a1;
  v10 = (u32 *)*(&dl_ns + 18 * a6);
  if ( v10 )
  {
    do
    {
      if ( (*((_BYTE *)v10 + 797) & 2) == 0 && (*((_BYTE *)v10 + 797) & 0x20) == 0 )
      {
        if ( (unsigned int)dl_name_match_p((__int64)a2, (__int64)v10) )
          return v10;
        if ( (*((_BYTE *)v10 + 797) & 1) == 0 )
        {
          v11 = *((_QWORD *)v10 + 22);
          if ( v11 )
          {
            v12 = (void *)(*(_QWORD *)(*((_QWORD *)v10 + 13) + 8LL) + *(_QWORD *)(v11 + 8));
            if ( !(unsigned int)j_strcmp_ifunc(a2, v12) )
            {
              add_name_to_object_isra_5(*((_QWORD **)v10 + 7), v12);
              *((_BYTE *)v10 + 797) |= 1u;
              return v10;
            }
          }
        }
      }
      v10 = (u32 *)*((_QWORD *)v10 + 3);
    }
    while ( v10 );
    v6 = a6;
  }
  v14 = dl_debug_mask;
  v50 = a5 & 0x10000000;
  if ( (dl_debug_mask & 0x40) != 0 )
  {
    if ( a1 )
    {
      v36 = *(const char **)(a1 + 8);
      v37 = *(_QWORD *)(a1 + 48);
      if ( !*v36 )
      {
        v36 = (const char *)program_invocation_short_name[0];
        if ( !program_invocation_short_name[0] )
          v36 = "<main program>";
      }
      v38 = "\nfile=%s [%lu];  needed by %s [%lu]\n";
      if ( v50 )
        v38 = "\nfile=%s [%lu];  dynamically loaded by %s [%lu]\n";
      dl_debug_printf(v38, a2, v6, v36, v37);
      v15 = 47LL;
      v57 = 0;
      if ( j_strchr_ifunc(a2, 47LL) )
      {
LABEL_17:
        v15 = (__int64)a2;
        v16 = (unsigned __int8 *)expand_dynamic_string_token(v7, a2);
        v58 = v16;
        if ( v16 )
        {
LABEL_18:
          v17 = open_verify_constprop_9((const char *)v16, (unsigned __int64)v60, a5, &v57, 1);
          v15 = v17;
          if ( v17 != -1 )
          {
            if ( v50 )
              v7 = 0LL;
LABEL_21:
            v59 = _libc_stack_end;
            return (u32 *)dl_map_object_from_fd_constprop_10(a2, v15, v60, v58, (_QWORD *)v7, a3, a5, (__int64)&v59, v6);
          }
          free((__int64)v58, 0xFFFFFFFFLL, v18, v19, v20, v21);
        }
LABEL_23:
        if ( v50 )
          v7 = 0LL;
        goto LABEL_25;
      }
      v53 = j_strlen_ifunc(a2) + 1;
      if ( (dl_debug_mask & 1) == 0 )
      {
LABEL_32:
        if ( !*(_QWORD *)(v7 + 296) )
        {
          v56 = v6;
          v40 = v7;
          v41 = 0;
          v55 = dl_ns;
          while ( 1 )
          {
            v43 = *(_QWORD *)(v40 + 800);
            if ( v43 != -1 )
            {
              if ( v43 || (v15 = v40 + 800, (unsigned __int8)cache_rpath_part_8(v40, v40 + 800, 15, (__int64)"RPATH")) )
              {
                v15 = v53;
                v42 = open_path(
                        (__int64)a2,
                        v53,
                        a5,
                        (__int64 *)(v40 + 800),
                        (__int64 *)&v58,
                        (unsigned __int64)v60,
                        v7,
                        4,
                        &v57);
                if ( v42 != -1 )
                {
                  v15 = v42;
                  v6 = v56;
                  goto LABEL_40;
                }
                v41 |= v40 == (_QWORD)v55;
              }
            }
            v40 = *(_QWORD *)(v40 + 736);
            if ( !v40 )
            {
              v44 = v41;
              v6 = v56;
              v45 = v44 ^ 1u;
              goto LABEL_84;
            }
          }
        }
        if ( env_path_list != -1 )
        {
LABEL_34:
          v28 = open_path((__int64)a2, v53, a5, &env_path_list, (__int64 *)&v58, (unsigned __int64)v60, v7, 2, &v57);
          v15 = v28;
          if ( v28 != -1 )
            goto LABEL_39;
          goto LABEL_35;
        }
        goto LABEL_35;
      }
    }
    else
    {
      v15 = 47LL;
      v57 = 0;
      if ( j_strchr_ifunc(a2, 47LL) )
        goto LABEL_22;
      v53 = j_strlen_ifunc(a2) + 1;
      if ( (v14 & 1) == 0 )
        goto LABEL_103;
    }
    goto LABEL_64;
  }
  v15 = 47LL;
  v57 = 0;
  if ( j_strchr_ifunc(a2, 47LL) )
  {
    if ( a1 )
      goto LABEL_17;
LABEL_22:
    v16 = (unsigned __int8 *)strdup((__int64)a2, 47LL);
    v58 = v16;
    if ( v16 )
      goto LABEL_18;
    goto LABEL_23;
  }
  v53 = j_strlen_ifunc(a2) + 1;
  if ( (v14 & 1) != 0 )
  {
LABEL_64:
    v15 = (__int64)a2;
    dl_debug_printf("find library=%s [%lu]; searching\n", a2, v6);
  }
  if ( v7 )
    goto LABEL_32;
LABEL_103:
  LOBYTE(v45) = 1;
  v55 = dl_ns;
LABEL_84:
  if ( !v55 )
    goto LABEL_92;
  if ( !(_BYTE)v45 )
    goto LABEL_92;
  if ( (*((_BYTE *)v55 + 796) & 3) == 2 )
    goto LABEL_92;
  v46 = *((_QWORD *)v55 + 100);
  if ( v46 == -1 )
    goto LABEL_92;
  if ( !v46 )
  {
    v15 = (__int64)v55 + 800;
    if ( !(unsigned __int8)cache_rpath_part_8((__int64)v55, (__int64)v55 + 800, 15, (__int64)"RPATH") )
      goto LABEL_92;
  }
  v47 = (__int64)v55;
  if ( v7 )
    v47 = v7;
  v48 = open_path((__int64)a2, v53, a5, (__int64 *)v55 + 100, (__int64 *)&v58, (unsigned __int64)v60, v47, 4, &v57);
  v15 = v48;
  if ( v48 == -1 )
  {
LABEL_92:
    if ( env_path_list != -1 )
    {
      if ( !v7 )
      {
        v30 = open_path(
                (__int64)a2,
                v53,
                a5,
                &env_path_list,
                (__int64 *)&v58,
                (unsigned __int64)v60,
                (__int64)dl_ns,
                2,
                &v57);
LABEL_38:
        v15 = v30;
LABEL_39:
        if ( (_DWORD)v15 != -1 )
          goto LABEL_40;
LABEL_49:
        v58 = 0LL;
        if ( (a5 & 0x4000000) != 0 && _libc_enable_secure )
          goto LABEL_71;
        if ( dl_inhibit_cache )
          goto LABEL_71;
        cache_lookup = dl_load_cache_lookup(a2);
        if ( !cache_lookup )
          goto LABEL_71;
        if ( v7 )
        {
          if ( (*(_BYTE *)(v7 + 989) & 8) == 0 )
            goto LABEL_54;
        }
        else if ( (*((_BYTE *)dl_ns + 989) & 8) == 0 )
        {
          goto LABEL_54;
        }
        if ( *(_DWORD *)cache_lookup == 1651076143
          && *(_WORD *)(cache_lookup + 4) == 13366
          && *(_BYTE *)(cache_lookup + 6) == 47
          || *(_QWORD *)cache_lookup == 0x62696C2F7273752FLL
          && *(_WORD *)(cache_lookup + 8) == 13366
          && *(_BYTE *)(cache_lookup + 10) == 47 )
        {
LABEL_70:
          free(cache_lookup, v15, v31, v32, v33, cache_lookup);
LABEL_71:
          v39 = v7;
          if ( !v7 && (v39 = (__int64)*(&dl_ns + 18 * v6)) == 0
            || (v15 = 0xFFFFFFFFLL, (*(_BYTE *)(v39 + 989) & 8) == 0) )
          {
            v15 = 0xFFFFFFFFLL;
            if ( rtld_search_dirs != -1 )
              v15 = (unsigned int)open_path(
                                    (__int64)a2,
                                    v53,
                                    a5,
                                    &rtld_search_dirs,
                                    (__int64 *)&v58,
                                    (unsigned __int64)v60,
                                    v39,
                                    64,
                                    &v57);
          }
          goto LABEL_40;
        }
LABEL_54:
        v54 = (unsigned __int8 *)cache_lookup;
        v35 = open_verify_constprop_9((const char *)cache_lookup, (unsigned __int64)v60, a5, &v57, 0);
        cache_lookup = (__int64)v54;
        v15 = v35;
        if ( v35 != -1 )
        {
          v58 = v54;
          goto LABEL_40;
        }
        goto LABEL_70;
      }
      goto LABEL_34;
    }
    if ( !v7 )
      goto LABEL_49;
LABEL_35:
    v29 = *(_QWORD *)(v7 + 944);
    if ( v29 == -1 )
      goto LABEL_49;
    if ( !v29 )
    {
      v15 = v7 + 944;
      if ( !(unsigned __int8)cache_rpath_part_8(v7, v7 + 944, 29, (__int64)"RUNPATH") )
        goto LABEL_49;
    }
    v30 = open_path((__int64)a2, v53, a5, (__int64 *)(v7 + 944), (__int64 *)&v58, (unsigned __int64)v60, v7, 4, &v57);
    goto LABEL_38;
  }
LABEL_40:
  if ( (dl_debug_mask & 1) != 0 )
  {
    dl_debug_printf("\n");
    v15 = (unsigned int)v15;
  }
  if ( v50 )
    v7 = 0LL;
  if ( (_DWORD)v15 != -1 )
    goto LABEL_21;
LABEL_25:
  if ( !a4 || (dl_debug_mask & 0x800) != 0 )
  {
    if ( v57 )
      dl_signal_error(0, a2, 0LL, "wrong ELF class: ELFCLASS32");
    dl_signal_error(__readfsdword(0xFFFFFFC0), a2, 0LL, "cannot open shared object file");
  }
  v22 = (unsigned __int8 *)strdup((__int64)a2, v15);
  v27 = (__int64)v22;
  if ( !v22 || (v15 = (__int64)a2, (v10 = dl_new_object(v22, (__int64)a2, a3, (_QWORD *)v7, a5, v6)) == 0LL) )
  {
    free(v27, v15, v23, v24, v25, v26);
    dl_signal_error(12, a2, 0LL, "cannot create shared object descriptor");
  }
  *((_WORD *)v10 + 398) |= 0x204u;
  *((_QWORD *)v10 + 98) = &dummy_bucket_11494;
  v10[189] = 1;
  dl_add_to_namespace_list(v10, v6);
  return v10;
}
// 468A30: conditional instruction was optimized away because r12.8!=0
// 468C6B: variable 'v31' is possibly undefined
// 468C6B: variable 'v32' is possibly undefined
// 468C6B: variable 'v33' is possibly undefined
// 468ED6: variable 'v18' is possibly undefined
// 468ED6: variable 'v19' is possibly undefined
// 468ED6: variable 'v20' is possibly undefined
// 468ED6: variable 'v21' is possibly undefined
// 46901C: variable 'v23' is possibly undefined
// 46901C: variable 'v24' is possibly undefined
// 46901C: variable 'v25' is possibly undefined
// 46901C: variable 'v26' is possibly undefined
// 4010A0: using guessed type __int64 __fastcall j_strcmp_ifunc(_QWORD, _QWORD);
// 4010C8: using guessed type __int64 __fastcall j_strlen_ifunc(_QWORD);
// 4010D0: using guessed type __int64 __fastcall j_strchr_ifunc(_QWORD, _QWORD);
// 4924E4: using guessed type int dummy_bucket_11494;
// 4A7AD0: using guessed type __int64 _libc_stack_end;
// 4A7AD8: using guessed type int _libc_enable_secure;
// 4A7ED0: using guessed type __int64 rtld_search_dirs;
// 4A7F00: using guessed type __int64 env_path_list;
// 4A9168: using guessed type char (*program_invocation_short_name[2])[1707];
// 4A9210: using guessed type __int64 dl_nns;
// 4A9280: using guessed type void *dl_ns;
// 4AB880: using guessed type int dl_debug_mask;
// 4AB8C8: using guessed type int dl_inhibit_cache;

//----- (0000000000469040) ----------------------------------------------------
void __fastcall dl_rtld_di_serinfo(__int64 a1, __int64 a2, char a3)
{
  __int64 v5; // rax
  bool v6; // zf
  __int64 *v7; // rsi
  __int64 v8; // rbx
  __int64 *v9; // rsi
  void *v10; // rbx
  __int64 *v11; // rsi
  char v12[4]; // [rsp+0h] [rbp-58h] BYREF
  int v13; // [rsp+4h] [rbp-54h]
  __int64 v14; // [rsp+8h] [rbp-50h]
  __int64 v15; // [rsp+10h] [rbp-48h]

  if ( a3 )
  {
    *(_DWORD *)(a2 + 8) = 0;
    v5 = 16LL;
    *(_QWORD *)a2 = 0LL;
  }
  else
  {
    v5 = 16 * (*(unsigned int *)(a2 + 8) + 1LL);
  }
  v12[0] = a3;
  v6 = *(_QWORD *)(a1 + 296) == 0LL;
  v13 = 0;
  v14 = a2;
  v15 = a2 + v5;
  if ( !v6 )
    goto LABEL_4;
  v8 = a1;
  do
  {
    v9 = *(__int64 **)(v8 + 800);
    if ( v9 != (__int64 *)-1LL )
    {
      if ( v9 )
        goto LABEL_16;
      if ( (unsigned __int8)cache_rpath_part_8(v8, v8 + 800, 15, (__int64)"RPATH") )
      {
        v9 = *(__int64 **)(v8 + 800);
LABEL_16:
        add_path_isra_4_constprop_11((__int64)v12, v9);
      }
    }
    v8 = *(_QWORD *)(v8 + 736);
  }
  while ( v8 );
  if ( !*(_QWORD *)(a1 + 48) )
  {
    v10 = dl_ns;
    if ( dl_ns )
    {
      if ( (*((_BYTE *)dl_ns + 796) & 3) != 2 && (void *)a1 != dl_ns )
      {
        v11 = (__int64 *)*((_QWORD *)dl_ns + 100);
        if ( v11 != (__int64 *)-1LL )
        {
          if ( v11 )
            goto LABEL_28;
          if ( (unsigned __int8)cache_rpath_part_8((__int64)dl_ns, (__int64)dl_ns + 800, 15, (__int64)"RPATH") )
          {
            v11 = (__int64 *)*((_QWORD *)v10 + 100);
LABEL_28:
            add_path_isra_4_constprop_11((__int64)v12, v11);
          }
        }
      }
    }
  }
LABEL_4:
  add_path_isra_4_constprop_11((__int64)v12, (__int64 *)env_path_list);
  v7 = *(__int64 **)(a1 + 944);
  if ( v7 != (__int64 *)-1LL )
  {
    if ( v7 )
      goto LABEL_6;
    if ( (unsigned __int8)cache_rpath_part_8(a1, a1 + 944, 29, (__int64)"RUNPATH") )
    {
      v7 = *(__int64 **)(a1 + 944);
LABEL_6:
      add_path_isra_4_constprop_11((__int64)v12, v7);
    }
  }
  if ( (*(_BYTE *)(a1 + 989) & 8) == 0 )
    add_path_isra_4_constprop_11((__int64)v12, (__int64 *)rtld_search_dirs);
  if ( a3 )
    *(_QWORD *)a2 += 16 * (*(unsigned int *)(a2 + 8) + 1LL);
}
// 4A7ED0: using guessed type __int64 rtld_search_dirs;
// 4A7F00: using guessed type __int64 env_path_list;
// 4A9280: using guessed type void *dl_ns;

//----- (0000000000469250) ----------------------------------------------------
unsigned int *__fastcall check_match(
        __int64 a1,
        unsigned int *a2,
        __int64 a3,
        char a4,
        unsigned __int8 a5,
        unsigned int *a6,
        unsigned int a7,
        __int64 a8,
        __int64 a9,
        unsigned int **a10,
        _DWORD *a11)
{
  __int16 v11; // r10
  unsigned int v12; // eax
  int v13; // er8
  __int64 v17; // rax
  __int16 v18; // r13
  __int64 v19; // rax
  int v20; // ebp
  __int64 v23; // rdi

  v11 = *((_WORD *)a6 + 3);
  v12 = a6[1] & 0xF;
  if ( *((_QWORD *)a6 + 1) || (_BYTE)v12 == 6 || v11 == -15 )
  {
    if ( (a5 & (v11 == 0)) == 0 )
    {
      v13 = 1127;
      if ( _bittest(&v13, v12) )
      {
        if ( a6 == a2 || !(unsigned int)j_strcmp_ifunc(a8 + *a6, a1) )
        {
          v17 = *(_QWORD *)(a9 + 824);
          if ( a3 )
          {
            if ( !v17 )
            {
              v23 = *(_QWORD *)(a3 + 16);
              if ( v23 && (unsigned int)dl_name_match_p(v23, a9) )
                _assert_fail(
                  (__int64)"version->filename == NULL || ! _dl_name_match_p (version->filename, map)",
                  (__int64)"dl-lookup.c",
                  0x70u,
                  "check_match");
              return a6;
            }
            v18 = *(_WORD *)(v17 + 2LL * a7);
            v19 = *(_QWORD *)(a9 + 744) + 24LL * (v18 & 0x7FFF);
            v20 = *(_DWORD *)(v19 + 8);
            if ( v20 == *(_DWORD *)(a3 + 8) && !(unsigned int)j_strcmp_ifunc(*(_QWORD *)v19, *(_QWORD *)a3)
              || !(*(_DWORD *)(a3 + 12) | v20) && v18 >= 0 )
            {
              return a6;
            }
          }
          else
          {
            if ( !v17 || __SPAIR64__(*(_WORD *)(v17 + 2LL * a7) & 0x7FFF, a4 & 2) < 0x200000001LL )
              return a6;
            if ( *(__int16 *)(v17 + 2LL * a7) >= 0 && !(*a11)++ )
              *a10 = a6;
          }
        }
      }
    }
    return 0LL;
  }
  return 0LL;
}
// 4010A0: using guessed type __int64 __fastcall j_strcmp_ifunc(_QWORD, _QWORD);

//----- (00000000004693F0) ----------------------------------------------------
__int64 __fastcall do_lookup_x(
        unsigned __int8 *a1,
        unsigned __int64 a2,
        unsigned __int64 *a3,
        unsigned int *a4,
        unsigned int **a5,
        __int64 a6,
        __int64 a7,
        __int64 a8,
        char a9,
        __int64 a10,
        int a11,
        __int64 a12)
{
  __int64 v13; // r15
  unsigned __int64 v14; // r10
  unsigned __int64 v15; // rsi
  __int64 v16; // rax
  __int64 v17; // rax
  unsigned __int64 v18; // rax
  unsigned __int64 v19; // rcx
  __int64 v20; // rbx
  const char *v21; // rdx
  __int64 v22; // rdx
  unsigned int v23; // eax
  __int64 v24; // rbp
  unsigned int *v25; // rax
  __int64 v26; // rdx
  unsigned int *v27; // r8
  char v28; // al
  __int64 v30; // rax
  _DWORD *v31; // r13
  unsigned __int64 v32; // rdx
  unsigned int *v33; // rax
  __int64 v34; // rax
  unsigned __int64 v35; // rax
  unsigned __int64 v36; // rax
  __int64 v37; // rbx
  __int64 v38; // rbp
  unsigned __int64 v39; // r13
  unsigned __int64 v40; // r13
  void **v41; // rbp
  unsigned __int64 v42; // r14
  unsigned __int64 v43; // r12
  unsigned __int64 v44; // rbx
  u32 *v45; // rbp
  __int64 v46; // rdi
  __int64 v47; // rdx
  unsigned __int64 v48; // r15
  __int64 v49; // rsi
  __int64 v50; // rcx
  u32 *v51; // rax
  u32 *v52; // rax
  unsigned __int64 v53; // rcx
  __int64 v54; // rax
  __int64 v55; // rax
  __int64 v56; // rax
  __int64 v57; // rax
  unsigned __int64 v58; // rcx
  unsigned __int8 *v59; // rdx
  __int64 i; // rax
  unsigned __int64 v61; // rbp
  __int64 v62; // rdx
  __int64 v63; // rcx
  u32 *v64; // r8
  __int64 v65; // r9
  u32 *v66; // r10
  unsigned int *v67; // rsi
  __int64 v68; // rdi
  __int64 v69; // r11
  __int64 v70; // r12
  unsigned __int64 v71; // rcx
  u32 *v72; // rax
  void **v73; // r12
  u32 *v74; // rax
  __int64 v75; // [rsp+10h] [rbp-98h]
  unsigned __int64 v76; // [rsp+10h] [rbp-98h]
  u32 *v77; // [rsp+10h] [rbp-98h]
  unsigned __int64 v79; // [rsp+18h] [rbp-90h]
  unsigned int *v80; // [rsp+18h] [rbp-90h]
  __int64 v82; // [rsp+20h] [rbp-88h]
  __int64 v84; // [rsp+30h] [rbp-78h]
  unsigned __int64 v85; // [rsp+38h] [rbp-70h]
  unsigned int *v86; // [rsp+38h] [rbp-70h]
  unsigned int *v89; // [rsp+48h] [rbp-60h]
  u32 *v90; // [rsp+48h] [rbp-60h]
  unsigned int *v91; // [rsp+50h] [rbp-58h]
  unsigned __int64 v92; // [rsp+58h] [rbp-50h]
  unsigned __int64 v93; // [rsp+58h] [rbp-50h]
  __int64 v94; // [rsp+58h] [rbp-50h]
  int v95; // [rsp+64h] [rbp-44h] BYREF
  unsigned int *v96[8]; // [rsp+68h] [rbp-40h] BYREF
  __int64 v97; // [rsp+B0h] [rbp+8h]
  __int64 v98; // [rsp+B0h] [rbp+8h]

  v85 = a2 >> 6;
  v13 = *(_QWORD *)a6;
  v14 = *(unsigned int *)(a6 + 8);
  while ( 1 )
  {
    v20 = *(_QWORD *)(*(_QWORD *)(v13 + 8 * a7) + 40LL);
    if ( v20 == a10 || (a11 & 2) != 0 && (*(_BYTE *)(v20 + 796) & 3) == 0 || (*(_BYTE *)(v20 + 797) & 0x20) != 0 )
      goto LABEL_5;
    if ( (dl_debug_mask & 8) != 0 )
    {
      v21 = *(const char **)(v20 + 8);
      if ( !*v21 )
      {
        v21 = (const char *)program_invocation_short_name[0];
        if ( !program_invocation_short_name[0] )
          v21 = "<main program>";
      }
      v76 = v14;
      dl_debug_printf("symbol=%s;  lookup in file=%s [%lu]\n", (const char *)a1, v21, *(_QWORD *)(v20 + 48));
      v14 = v76;
    }
    v15 = *(unsigned int *)(v20 + 756);
    if ( !(_DWORD)v15 )
      goto LABEL_5;
    v16 = *(_QWORD *)(v20 + 112);
    v95 = 0;
    v96[0] = 0LL;
    v75 = *(_QWORD *)(v16 + 8);
    v84 = *(_QWORD *)(*(_QWORD *)(v20 + 104) + 8LL);
    v17 = *(_QWORD *)(v20 + 768);
    if ( v17 )
    {
      v18 = *(_QWORD *)(v17 + 8LL * (*(_DWORD *)(v20 + 760) & (unsigned int)v85));
      v19 = (unsigned int)a2;
      if ( ((unsigned __int8)(v18 >> (a2 >> *(_DWORD *)(v20 + 764))) & (unsigned __int8)(v18 >> a2) & 1) != 0 )
      {
        v30 = *(unsigned int *)(*(_QWORD *)(v20 + 776) + 4 * (a2 % v15));
        if ( (_DWORD)v30 )
        {
          v31 = (_DWORD *)(*(_QWORD *)(v20 + 784) + 4 * v30);
          v93 = v14;
          while ( 1 )
          {
            v32 = (unsigned int)*v31;
            if ( !((a2 ^ v32) >> 1) )
            {
              v33 = check_match(
                      (__int64)a1,
                      a4,
                      a8,
                      a9,
                      a11,
                      (unsigned int *)(v75 + 24LL * (unsigned int)(((__int64)v31 - *(_QWORD *)(v20 + 784)) >> 2)),
                      ((__int64)v31 - *(_QWORD *)(v20 + 784)) >> 2,
                      v84,
                      v20,
                      v96,
                      &v95);
              if ( v33 )
              {
                v27 = v33;
                v14 = v93;
                goto LABEL_23;
              }
              LODWORD(v32) = *v31;
            }
            ++v31;
            v26 = v32 & 1;
            if ( (_DWORD)v26 )
            {
              v14 = v93;
              goto LABEL_63;
            }
          }
        }
      }
      goto LABEL_5;
    }
    if ( *a3 == 0xFFFFFFFF )
    {
      v22 = 0LL;
      v53 = *a1;
      if ( *a1 )
      {
        v54 = a1[1];
        if ( (_BYTE)v54 )
        {
          v53 = v54 + 16 * v53;
          v55 = a1[2];
          if ( (_BYTE)v55 )
          {
            v53 = v55 + 16 * v53;
            v56 = a1[3];
            if ( (_BYTE)v56 )
            {
              v53 = v56 + 16 * v53;
              v57 = a1[4];
              if ( (_BYTE)v57 )
              {
                v58 = v57 + 16 * v53;
                v59 = a1 + 5;
                for ( i = a1[5]; (_BYTE)i; i = *v59 )
                {
                  ++v59;
                  v58 = (16 * v58 + i) ^ ((16 * v58 + i) >> 24) & 0xF0;
                }
                v53 = v58 & 0xFFFFFFF;
              }
            }
          }
        }
        v22 = 4 * (v53 % v15);
      }
      *a3 = v53;
    }
    else
    {
      v22 = 4 * (*a3 % v15);
    }
    v23 = *(_DWORD *)(*(_QWORD *)(v20 + 784) + v22);
    if ( v23 )
    {
      v97 = a7;
      v92 = v14;
      do
      {
        v24 = v23;
        v25 = check_match((__int64)a1, a4, a8, a9, a11, (unsigned int *)(v75 + 24LL * v23), v23, v84, v20, v96, &v95);
        if ( v25 )
        {
          v14 = v92;
          v27 = v25;
          a7 = v97;
          goto LABEL_23;
        }
        v23 = *(_DWORD *)(*(_QWORD *)(v20 + 776) + 4 * v24);
      }
      while ( v23 );
      a7 = v97;
      v14 = v92;
LABEL_63:
      if ( v95 == 1 )
      {
        v27 = v96[0];
        if ( v96[0] )
          break;
      }
    }
LABEL_5:
    if ( v14 <= ++a7 )
      return 0LL;
  }
LABEL_23:
  if ( !a12 && (*(_BYTE *)(v20 + 796) & 3) == 0 && a11 == 4 )
  {
    v26 = *(_QWORD *)(v20 + 120);
    if ( v26 )
    {
      v34 = *(_QWORD *)(v20 + 128);
      if ( v34 )
      {
        v35 = *(_QWORD *)(v34 + 8);
        if ( v35 )
        {
          a6 = *(_QWORD *)(v26 + 8);
          v26 = (0xAAAAAAAAAAAAAAABLL * (unsigned __int128)v35) >> 64;
          v36 = v35 / 0x18;
          if ( (_DWORD)v36 )
          {
            v94 = v20;
            v37 = a6;
            v98 = a7;
            v91 = v27;
            v38 = a6 + 24LL * (unsigned int)(v36 - 1) + 24;
            v39 = v14;
            do
            {
              v19 = *(_QWORD *)(v37 + 8);
              if ( (unsigned int)v19 <= 0x24uLL
                && (unsigned int)v19 == 5LL
                && ((0x1000070080uLL >> v19) & 1) == 0
                && !(unsigned int)j_strcmp_ifunc(v84 + *(unsigned int *)(v75 + 24 * HIDWORD(v19)), a1) )
              {
                a7 = v98;
                v14 = v39;
                goto LABEL_5;
              }
              v37 += 24LL;
            }
            while ( v37 != v38 );
            v27 = v91;
            v20 = v94;
            v14 = v39;
            a7 = v98;
          }
        }
      }
    }
  }
  if ( (*((_BYTE *)v27 + 5) & 3u) - 1 <= 1 )
    goto LABEL_5;
  v28 = *((_BYTE *)v27 + 4) >> 4;
  if ( v28 == 2 )
  {
    if ( !dl_dynamic_weak )
      goto LABEL_28;
    if ( !*a5 )
    {
      *a5 = v27;
      a5[1] = (unsigned int *)v20;
    }
    goto LABEL_5;
  }
  if ( v28 != 10 )
  {
    if ( v28 == 1 )
      goto LABEL_28;
    goto LABEL_5;
  }
  v40 = a2;
  v82 = *(_QWORD *)(v20 + 48);
  v41 = &dl_ns + 18 * v82;
  v42 = (unsigned __int64)v41[10];
  v77 = (u32 *)v41[9];
  if ( !v77 )
  {
    v80 = v27;
    v74 = calloc(32LL, 0x1FuLL, v26, v19, v27, a6);
    v77 = v74;
    if ( v74 )
    {
      v41[9] = v74;
      v41[10] = (void *)31;
      v42 = 31LL;
      v27 = v80;
      v41[12] = free;
      v48 = v40 % 0x1F;
      v47 = (__int64)v40 % 29 + 1;
      goto LABEL_67;
    }
LABEL_108:
    dl_dprintf(2, "out of memory\n");
    exit(127);
  }
  v86 = v27;
  v89 = (unsigned int *)v20;
  v43 = v40 % v42;
  v44 = v40 % (v42 - 2) + 1;
LABEL_55:
  v45 = &v77[8 * v43];
  while ( 1 )
  {
    v46 = *((_QWORD *)v45 + 1);
    if ( v40 != *v45 )
    {
      if ( v46 )
        goto LABEL_57;
      v47 = v40 % (v42 - 2) + 1;
      v27 = v86;
      v20 = (__int64)v89;
      v48 = v40 % v42;
      if ( 3 * v42 > 4 * (__int64)*(&dl_ns + 18 * v82 + 11) )
      {
LABEL_67:
        v49 = 32 * v47;
        v50 = v84 + *v27;
        if ( (a11 & 2) != 0 )
        {
LABEL_68:
          v51 = &v77[8 * v48];
          while ( *((_QWORD *)v51 + 1) )
          {
            v48 += v47;
            v51 = (u32 *)((char *)v51 + v49);
            if ( v42 <= v48 )
            {
              v48 -= v42;
              goto LABEL_68;
            }
          }
          *v51 = v40;
          *((_QWORD *)v51 + 1) = v50;
          *((_QWORD *)v51 + 2) = a4;
          *((_QWORD *)v51 + 3) = a12;
        }
        else
        {
LABEL_74:
          v52 = &v77[8 * v48];
          while ( *((_QWORD *)v52 + 1) )
          {
            v48 += v47;
            v52 = (u32 *)((char *)v52 + v49);
            if ( v42 <= v48 )
            {
              v48 -= v42;
              goto LABEL_74;
            }
          }
          *v52 = v40;
          *((_QWORD *)v52 + 1) = v50;
          *((_QWORD *)v52 + 2) = v27;
          *((_QWORD *)v52 + 3) = v20;
          if ( (*(_BYTE *)(v20 + 796) & 3) == 2 )
            *(_DWORD *)(v20 + 988) |= 8u;
        }
        *(&dl_ns + 18 * v82 + 11) = (char *)*(&dl_ns + 18 * v82 + 11) + 1;
LABEL_28:
        *a5 = v27;
        a5[1] = (unsigned int *)v20;
        return 1LL;
      }
      v61 = dl_higher_prime_number(v42 + 1);
      v66 = calloc(32LL, v61, v62, v63, v64, v65);
      if ( v66 )
      {
        v79 = v61 - 2;
        v67 = v77;
        do
        {
          v68 = *((_QWORD *)v67 + 1);
          if ( v68 )
          {
            v69 = *((_QWORD *)v67 + 3);
            v70 = *((_QWORD *)v67 + 2);
            v71 = *v67 % v61;
LABEL_97:
            v72 = &v66[8 * v71];
            while ( *((_QWORD *)v72 + 1) )
            {
              v71 += *v67 % v79 + 1;
              v72 += 8 * (*v67 % v79) + 8;
              if ( v61 <= v71 )
              {
                v71 -= v61;
                goto LABEL_97;
              }
            }
            *v72 = *v67;
            *((_QWORD *)v72 + 1) = v68;
            *((_QWORD *)v72 + 2) = v70;
            *((_QWORD *)v72 + 3) = v69;
          }
          v67 += 8;
        }
        while ( &v77[8 * v42] != v67 );
        v90 = v66;
        v42 = v61;
        v73 = &dl_ns + 18 * v82;
        ((void (__fastcall *)(u32 *, unsigned int *))v73[12])(v77, v67);
        v73[10] = (void *)v61;
        v27 = v86;
        v73[12] = free;
        v73[9] = v90;
        v77 = v90;
        v48 = v40 % v61;
        v47 = v40 % v79 + 1;
        goto LABEL_67;
      }
      goto LABEL_108;
    }
    if ( !(unsigned int)j_strcmp_ifunc(v46, a1) )
      break;
LABEL_57:
    v43 += v44;
    v45 += 8 * v44;
    if ( v42 <= v43 )
    {
      v43 -= v42;
      goto LABEL_55;
    }
  }
  if ( (a11 & 2) != 0 )
  {
    *a5 = v86;
    a5[1] = v89;
  }
  else
  {
    *a5 = (unsigned int *)*((_QWORD *)v45 + 2);
    a5[1] = (unsigned int *)*((_QWORD *)v45 + 3);
  }
  return 1LL;
}
// 469CC7: conditional instruction was optimized away because r14.8!=0
// 469C93: variable 'v62' is possibly undefined
// 469C93: variable 'v63' is possibly undefined
// 469C93: variable 'v64' is possibly undefined
// 469C93: variable 'v65' is possibly undefined
// 469DCD: variable 'v26' is possibly undefined
// 469DCD: variable 'v19' is possibly undefined
// 469DCD: variable 'a6' is possibly undefined
// 4010A0: using guessed type __int64 __fastcall j_strcmp_ifunc(_QWORD, _QWORD);
// 4A9168: using guessed type char (*program_invocation_short_name[2])[1707];
// 4A9280: using guessed type void *dl_ns;
// 4AB880: using guessed type int dl_debug_mask;
// 4AB8EC: using guessed type int dl_dynamic_weak;

//----- (0000000000469F10) ----------------------------------------------------
__int64 __fastcall dl_lookup_symbol_x(
        unsigned __int8 *a1,
        __int64 a2,
        unsigned int **a3,
        __int64 *a4,
        const char **a5,
        int a6,
        double a7,
        double a8,
        double a9,
        double a10,
        double a11,
        double a12,
        double a13,
        double a14,
        int a15,
        __int64 a16)
{
  int v20; // edx
  unsigned __int8 *v21; // rcx
  unsigned int v22; // eax
  unsigned __int64 v23; // rbx
  __int64 v24; // rcx
  _QWORD *v25; // r9
  __int64 v26; // rax
  __int64 *v27; // r14
  __int64 v28; // rsi
  __int64 v29; // r14
  int v30; // ebx
  __int64 v32; // r9
  __int64 v33; // rdx
  __int64 *v34; // r13
  int v35; // eax
  __int64 v36; // rdx
  const char *v37; // rcx
  const char *v38; // r9
  const char *v39; // rsi
  double v40; // xmm4_8
  double v41; // xmm5_8
  u32 *v42; // r8
  __int64 v43; // rax
  __int64 v44; // rdx
  __int64 v45; // r9
  unsigned int *v46; // rax
  __int64 i; // rax
  unsigned __int64 v48; // rdx
  unsigned int v49; // eax
  unsigned int *v50; // rax
  int v52; // er14
  __int64 v53; // rax
  volatile __int32 *v54; // rax
  signed __int64 v55; // rax
  __int64 *v56; // rdx
  unsigned int *v57; // rdx
  unsigned int *v58; // rdx
  __int64 v59; // rdx
  _QWORD *v60; // rax
  unsigned __int64 v61; // r9
  _DWORD *v62; // rcx
  u32 *v63; // r8
  __int64 v64; // rdi
  const char *v65; // rcx
  const char *v66; // rsi
  char *v67; // rsi
  const char *v68; // r9
  u32 *v69; // r8
  __int64 v70; // [rsp-10h] [rbp-C8h]
  char v71; // [rsp+0h] [rbp-B8h]
  unsigned int v73; // [rsp+14h] [rbp-A4h]
  unsigned int *v74; // [rsp+18h] [rbp-A0h]
  unsigned int v75; // [rsp+18h] [rbp-A0h]
  unsigned int v77; // [rsp+20h] [rbp-98h]
  _DWORD *v78; // [rsp+20h] [rbp-98h]
  __int64 v79; // [rsp+28h] [rbp-90h]
  __int64 v80; // [rsp+28h] [rbp-90h]
  __int64 v81; // [rsp+28h] [rbp-90h]
  unsigned __int64 v82; // [rsp+48h] [rbp-70h] BYREF
  unsigned int *v83; // [rsp+50h] [rbp-68h] BYREF
  __int64 v84; // [rsp+58h] [rbp-60h]
  __m128i v85[5]; // [rsp+60h] [rbp-58h] BYREF

  v20 = *a1;
  if ( (_BYTE)v20 )
  {
    v21 = a1;
    v22 = 5381;
    do
    {
      ++v21;
      v22 = v20 + 33 * v22;
      v20 = *v21;
    }
    while ( (_BYTE)v20 );
    v23 = v22;
  }
  else
  {
    v23 = 5381LL;
  }
  v83 = 0LL;
  v82 = 0xFFFFFFFFLL;
  v84 = 0LL;
  if ( a5 && (a15 & 0xFFFFFFFA) != 0 )
    _assert_fail(
      (__int64)"version == NULL || (flags & ~(DL_LOOKUP_ADD_DEPENDENCY | DL_LOOKUP_GSCOPE_LOCK)) == 0",
      (__int64)"dl-lookup.c",
      0x31Fu,
      "_dl_lookup_symbol_x");
  v24 = (__int64)*a3;
  v25 = (_QWORD *)*a4;
  if ( a16 )
  {
    if ( a16 != *(_QWORD *)*v25 )
    {
      v36 = 0LL;
      do
        ++v36;
      while ( *(_QWORD *)(*v25 + 8 * v36) != a16 );
      v79 = v36;
      goto LABEL_10;
    }
  }
  else if ( !v25 )
  {
    goto LABEL_34;
  }
  v79 = 0LL;
LABEL_10:
  v26 = v79;
  v27 = a4;
  while ( 1 )
  {
    v28 = v23;
    if ( (unsigned int)do_lookup_x(
                         a1,
                         v23,
                         &v82,
                         (unsigned int *)v24,
                         &v83,
                         (__int64)v25,
                         v26,
                         (__int64)a5,
                         a15,
                         a16,
                         a6,
                         a2) )
      break;
    v25 = (_QWORD *)*++v27;
    v24 = (__int64)*a3;
    v26 = 0LL;
    if ( !*v27 )
      goto LABEL_14;
  }
  v24 = (__int64)*a3;
LABEL_14:
  if ( !v83 )
  {
LABEL_34:
    if ( v24 && *(_BYTE *)(v24 + 4) >> 4 == 2 || (dl_debug_mask & 0x100) != 0 )
    {
      *a3 = 0LL;
      return 0LL;
    }
    if ( a2 )
    {
      v67 = *(char **)(a2 + 8);
      if ( a5 )
      {
        v68 = *a5;
        v69 = (u32 *)", version ";
        if ( !*a5 )
          v68 = (const char *)byte_493255;
      }
      else
      {
        v69 = (u32 *)byte_493255;
        v68 = (const char *)byte_493255;
      }
      if ( *v67 )
      {
LABEL_152:
        dl_exception_create_format(
          (const char **)v85,
          v67,
          "undefined symbol: %s%s%s",
          a7,
          a8,
          a9,
          a10,
          a11,
          a12,
          a13,
          a14,
          (__int64)a1,
          v69,
          (__int64)v68,
          v71);
        dl_signal_exception(0, v85, "symbol lookup error");
      }
    }
    else if ( a5 )
    {
      v68 = *a5;
      v69 = (u32 *)", version ";
      if ( !*a5 )
        v68 = (const char *)byte_493255;
    }
    else
    {
      v69 = (u32 *)byte_493255;
      v68 = (const char *)byte_493255;
    }
    v67 = (char *)program_invocation_short_name[0];
    if ( !program_invocation_short_name[0] )
      v67 = "<main program>";
    goto LABEL_152;
  }
  if ( v24 && (*(_BYTE *)(v24 + 5) & 3) == 3 )
  {
    if ( a6 == 1 )
    {
      if ( v84 != a2 )
      {
        v83 = (unsigned int *)v24;
        v84 = a2;
      }
      v29 = a2;
      v30 = 1;
      goto LABEL_19;
    }
    v85[0] = 0uLL;
    v32 = *a4;
    if ( !*a4 )
      goto LABEL_91;
    v33 = v79;
    v80 = a2;
    v34 = a4;
    while ( 1 )
    {
      if ( (*(_BYTE *)(v24 + 4) & 0xF) != 1 || (v35 = 4, a6 != 4) )
        v35 = 1;
      v28 = v23;
      if ( (unsigned int)do_lookup_x(
                           a1,
                           v23,
                           &v82,
                           (unsigned int *)v24,
                           (unsigned int **)v85,
                           v32,
                           v33,
                           (__int64)a5,
                           a15,
                           a16,
                           v35,
                           0LL) )
        break;
      v32 = *++v34;
      if ( !*v34 )
        break;
      v24 = (__int64)*a3;
      v33 = 0LL;
    }
    a2 = v80;
    if ( v85[0].m128i_i64[0] && v85[0].m128i_i64[1] != v80 )
    {
      v50 = *a3;
      v84 = v80;
      v29 = v80;
      v83 = v50;
    }
    else
    {
LABEL_91:
      v29 = v84;
    }
    v30 = 1;
  }
  else
  {
    v29 = v84;
    v30 = 0;
  }
  if ( (*(_BYTE *)(v29 + 796) & 3) == 2 && (a15 & 1) != 0 && a2 != v29 && (*(_DWORD *)(v29 + 988) & 8) == 0 )
  {
    v74 = *(unsigned int **)(a2 + 968);
    v42 = *(u32 **)(a2 + 960);
    if ( v42 && *(_QWORD *)v42 )
    {
      LODWORD(v43) = 0;
      if ( *(_QWORD *)v42 == v29 )
        goto LABEL_83;
      while ( 1 )
      {
        v43 = (unsigned int)(v43 + 1);
        v44 = *(_QWORD *)&v42[2 * v43];
        if ( !v44 )
          break;
        if ( v44 == v29 )
          goto LABEL_83;
      }
    }
    if ( v74 )
    {
      v45 = *v74;
      if ( (_DWORD)v45 )
      {
        if ( *((_QWORD *)v74 + 1) == v29 )
        {
LABEL_83:
          v29 = v84;
          goto LABEL_19;
        }
        v46 = v74 + 4;
        while ( &v74[2 * (unsigned int)(v45 - 1) + 4] != v46 )
        {
          v46 += 2;
          if ( *((_QWORD *)v46 - 1) == v29 )
            goto LABEL_83;
        }
      }
    }
    else
    {
      v45 = 0LL;
    }
    v81 = *(_QWORD *)(v29 + 1136);
    if ( (a15 & 4) == 0 )
      goto LABEL_70;
    LODWORD(v54) = _InterlockedExchange(MK_FP(__FS__, 28LL), 0);
    if ( (_DWORD)v54 == 2 )
    {
      v28 = 129LL;
      v55 = sys_futex((u32 *)(__readfsqword(0x10u) + 28), 129, 1u, 0LL, v42, v45);
    }
    v56 = *(__int64 **)(a2 + 960);
    if ( v56 != (__int64 *)v42 )
    {
      if ( v56 )
      {
        v24 = *v56;
        if ( *v56 )
        {
          if ( v24 == v29 )
          {
            v53 = *(_QWORD *)(v29 + 1136);
LABEL_100:
            v52 = -(v81 != v53);
            goto LABEL_145;
          }
          LODWORD(v24) = 0;
          while ( 1 )
          {
            v24 = (unsigned int)(v24 + 1);
            v28 = v56[v24];
            if ( !v28 )
              break;
            if ( v29 == v28 )
              goto LABEL_137;
          }
        }
      }
    }
    v57 = *(unsigned int **)(a2 + 968);
    if ( v57 )
    {
      v24 = *v57;
      if ( v74 == v57 )
      {
        if ( (unsigned int)v45 < (unsigned int)v24 )
        {
          v28 = (__int64)&v74[2 * (unsigned int)v45];
          v59 = 0LL;
          while ( *(_QWORD *)(v28 + 8 * v59 + 8) != v29 )
          {
            if ( (int)v45 + (int)++v59 >= (unsigned int)v24 )
              goto LABEL_117;
          }
LABEL_137:
          v53 = *(_QWORD *)(v29 + 1136);
          goto LABEL_100;
        }
      }
      else
      {
        if ( (_DWORD)v24 )
        {
          if ( *((_QWORD *)v57 + 1) != v29 )
          {
            v58 = v57 + 4;
            v28 = (__int64)&v58[2 * (unsigned int)(v24 - 1)];
            while ( (unsigned int *)v28 != v58 )
            {
              v58 += 2;
              if ( *((_QWORD *)v58 - 1) == v29 )
                goto LABEL_137;
            }
LABEL_117:
            v45 = (unsigned int)v24;
            goto LABEL_70;
          }
          goto LABEL_137;
        }
        v45 = 0LL;
      }
    }
LABEL_70:
    for ( i = (__int64)*(&dl_ns + 18 * *(_QWORD *)(a2 + 48)); i; i = *(_QWORD *)(i + 24) )
    {
      if ( i == v29 )
        break;
    }
    if ( !i )
    {
      if ( (a15 & 4) == 0 )
        return dl_lookup_symbol_x(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16);
      __writefsdword(0x1Cu, 1u);
      return dl_lookup_symbol_x(
               a1,
               a2,
               a3,
               *(__int64 **)(a2 + 904),
               a5,
               a6,
               a7,
               a8,
               a9,
               a10,
               a11,
               a12,
               a13,
               a14,
               a15,
               a16);
    }
    if ( v81 == *(_QWORD *)(v29 + 1136) )
    {
      v48 = *(unsigned int *)(v29 + 988);
      if ( (v48 & 8) == 0 )
      {
        if ( (*(_BYTE *)(a2 + 796) & 3) == 2 && (*(_BYTE *)(a2 + 988) & 8) == 0 )
        {
          v49 = *(_DWORD *)(a2 + 976);
          if ( v49 > (unsigned int)v45 )
          {
            *(_QWORD *)(*(_QWORD *)(a2 + 968) + 8LL * (unsigned int)v45 + 8) = v29;
            **(_DWORD **)(a2 + 968) = v45 + 1;
LABEL_81:
            if ( (dl_debug_mask & 0x40) != 0 )
            {
              v65 = *(const char **)(a2 + 8);
              if ( !*v65 )
              {
                v65 = (const char *)program_invocation_short_name[0];
                if ( !program_invocation_short_name[0] )
                  v65 = "<main program>";
              }
              v66 = *(const char **)(v29 + 8);
              if ( !*v66 )
              {
                v66 = (const char *)program_invocation_short_name[0];
                if ( !program_invocation_short_name[0] )
                  v66 = "<main program>";
              }
              dl_debug_printf(
                "\nfile=%s [%lu];  needed by %s [%lu] (relocation dependency)\n\n",
                v66,
                *(_QWORD *)(v29 + 48),
                v65,
                *(_QWORD *)(a2 + 48));
            }
            goto LABEL_119;
          }
          v73 = 10;
          if ( v49 )
            v73 = 2 * v49;
          v77 = *(_DWORD *)(v29 + 988);
          v75 = v45;
          v60 = malloc(8LL * v73 + 8, v28, (_QWORD *)v48, v24, v42, v45);
          v61 = v75;
          v48 = v77;
          v62 = v60;
          if ( v60 )
          {
            v63 = (u32 *)v75;
            if ( v75 )
            {
              v78 = v60;
              v28 = *(_QWORD *)(a2 + 968) + 8LL;
              j_memcpy(v60 + 1, v28, 8LL * v75);
              v61 = v75;
              v62 = v78;
              v63 = (u32 *)v75;
            }
            *(_QWORD *)&v62[2 * (_QWORD)v63 + 2] = v29;
            *v62 = v61 + 1;
            v64 = *(_QWORD *)(a2 + 968);
            *(_QWORD *)(a2 + 968) = v62;
            *(_DWORD *)(a2 + 976) = v73;
            if ( v64 )
              dl_scope_free(v64, v28, (_QWORD *)v48, (__int64)v62, v63, v61);
            goto LABEL_81;
          }
        }
        *(_DWORD *)(v29 + 988) = v48 | 8;
      }
LABEL_119:
      if ( (a15 & 4) != 0 )
        __writefsdword(0x1Cu, 1u);
      goto LABEL_83;
    }
    v52 = -1;
    if ( (a15 & 4) == 0 )
      return dl_lookup_symbol_x(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16);
LABEL_145:
    __writefsdword(0x1Cu, 1u);
    if ( v52 != -1 )
      goto LABEL_83;
    return dl_lookup_symbol_x(
             a1,
             a2,
             a3,
             *(__int64 **)(a2 + 904),
             a5,
             a6,
             a7,
             a8,
             a9,
             a10,
             a11,
             a12,
             a13,
             a14,
             a15,
             a16);
  }
LABEL_19:
  if ( !*(_DWORD *)(v29 + 980) )
    *(_DWORD *)(v29 + 980) = 1;
  if ( (dl_debug_mask & 0x804) != 0 && (dl_debug_mask & 4) != 0 )
  {
    v37 = *(const char **)(v29 + 8);
    v38 = "protected";
    if ( !v30 )
      v38 = "normal";
    if ( !*v37 )
    {
      v37 = (const char *)program_invocation_short_name[0];
      if ( !program_invocation_short_name[0] )
        v37 = "<main program>";
    }
    v39 = *(const char **)(a2 + 8);
    if ( !*v39 )
    {
      v39 = (const char *)program_invocation_short_name[0];
      if ( !program_invocation_short_name[0] )
        v39 = "<main program>";
    }
    dl_debug_printf(
      "binding file %s [%lu] to %s [%lu]: %s symbol `%s'",
      v39,
      *(_QWORD *)(a2 + 48),
      v37,
      *(_QWORD *)(v29 + 48),
      v38,
      (const char *)a1);
    if ( a5 )
      dl_debug_printf_c(" [%s]\n", *a5);
    else
      dl_debug_printf_c("\n", v39, v70, a7, a8, a9, a10, v40, v41, a13, a14);
    v29 = v84;
  }
  *a3 = v83;
  return v29;
}
// 46A420: variable 'v45' is possibly undefined
// 46A4DE: variable 'v70' is possibly undefined
// 46A4DE: variable 'v40' is possibly undefined
// 46A4DE: variable 'v41' is possibly undefined
// 46A542: variable 'a11' is possibly undefined
// 46A542: variable 'a12' is possibly undefined
// 46A619: variable 'v42' is possibly undefined
// 46A765: variable 'v24' is possibly undefined
// 46A7B4: variable 'v48' is possibly undefined
// 46A8B8: variable 'v71' is possibly undefined
// 401040: using guessed type __int64 __fastcall j_memcpy(_QWORD, _QWORD, _QWORD);
// 493255: using guessed type unsigned __int8 byte_493255[1707];
// 4A9168: using guessed type char (*program_invocation_short_name[2])[1707];
// 4A9280: using guessed type void *dl_ns;
// 4AB880: using guessed type int dl_debug_mask;

//----- (000000000046A960) ----------------------------------------------------
unsigned int *__fastcall dl_setup_hash(__int64 a1)
{
  __int64 v1; // rax
  unsigned int *v2; // rcx
  __int64 v3; // rdx
  unsigned int v4; // eax
  __int64 v5; // rsi
  unsigned int *v6; // r8
  unsigned int v7; // ecx
  unsigned int *v8; // rax
  unsigned int *result; // rax
  unsigned int *v10; // rax
  __int64 v11; // rdx

  v1 = *(_QWORD *)(a1 + 672);
  if ( v1 )
  {
    v2 = *(unsigned int **)(v1 + 8);
    v3 = *v2;
    *(_DWORD *)(a1 + 756) = v3;
    v4 = v2[2];
    v5 = v2[1];
    if ( (v4 & (v4 - 1)) != 0 )
      _assert_fail(
        (__int64)"(bitmask_nwords & (bitmask_nwords - 1)) == 0",
        (__int64)"dl-lookup.c",
        0x398u,
        "_dl_setup_hash");
    *(_DWORD *)(a1 + 760) = v4 - 1;
    v6 = v2 + 4;
    v7 = v2[3];
    v8 = &v6[2 * v4];
    *(_QWORD *)(a1 + 768) = v6;
    *(_QWORD *)(a1 + 776) = v8;
    result = &v8[v3 - v5];
    *(_DWORD *)(a1 + 764) = v7;
    *(_QWORD *)(a1 + 784) = result;
  }
  else
  {
    result = *(unsigned int **)(a1 + 96);
    if ( result )
    {
      v10 = (unsigned int *)*((_QWORD *)result + 1);
      v11 = *v10;
      v10 += 2;
      *(_QWORD *)(a1 + 784) = v10;
      result = &v10[v11];
      *(_DWORD *)(a1 + 756) = v11;
      *(_QWORD *)(a1 + 776) = result;
    }
  }
  return result;
}

//----- (000000000046AA20) ----------------------------------------------------
__int64 __fastcall dl_add_to_namespace_list(_QWORD *a1, __int64 a2)
{
  void **v2; // rax
  _QWORD *v3; // rdx
  __int64 v4; // rax
  __int64 result; // rax

  v2 = &dl_ns + 18 * a2;
  v3 = *v2;
  if ( *v2 )
  {
    while ( v3[3] )
      v3 = (_QWORD *)v3[3];
    a1[4] = v3;
    v3[3] = a1;
  }
  else
  {
    *v2 = a1;
  }
  ++*((_DWORD *)&dl_ns + 36 * a2 + 2);
  v4 = dl_load_adds;
  a1[142] = dl_load_adds;
  result = v4 + 1;
  dl_load_adds = result;
  return result;
}
// 46AAB9: control flows out of bounds to 0
// 4A9208: using guessed type __int64 dl_load_adds;
// 4A9280: using guessed type void *dl_ns;

//----- (000000000046AAE0) ----------------------------------------------------
u32 *__fastcall dl_new_object(unsigned __int8 *a1, __int64 a2, char a3, _QWORD *a4, char a5, __int64 a6)
{
  __int64 v9; // r15
  __int64 v10; // rcx
  u32 *v11; // r8
  __int64 v12; // r9
  u32 *v13; // rax
  u32 *v14; // r13
  __int64 v15; // rax
  unsigned __int8 *v16; // rax
  unsigned __int8 v17; // dl
  _QWORD *v18; // rcx
  __int64 v19; // rax
  _QWORD *v20; // rax
  __int64 v21; // rsi
  _QWORD *v22; // rbx
  __int64 v23; // r15
  __int64 v24; // rax
  __int64 v25; // rcx
  u32 *v26; // r8
  unsigned __int64 v27; // r9
  __int64 v28; // rdx
  __int64 v29; // r12
  unsigned __int64 v30; // rax
  unsigned __int64 v31; // rbx
  unsigned __int64 v32; // rsi
  __int64 *v33; // rax
  __int64 v34; // r14
  _BYTE *v35; // rdi
  __int64 i; // rax
  _BYTE *v37; // rdx
  _QWORD *v39; // rax
  unsigned __int8 v41; // [rsp+10h] [rbp-48h]
  unsigned __int64 v43; // [rsp+18h] [rbp-40h]

  v9 = j_strlen_ifunc(a2);
  v13 = calloc(v9 + 1177, 1uLL, v9 + 1, v10, v11, v12);
  v14 = v13;
  if ( !v13 )
    return v14;
  *((_QWORD *)v13 + 5) = v13;
  *((_QWORD *)v13 + 90) = v13 + 286;
  *((_QWORD *)v13 + 7) = v13 + 288;
  v15 = j_memcpy(v13 + 294, a2, v9 + 1);
  v14[292] = 1;
  *((_QWORD *)v14 + 144) = v15;
  v16 = (unsigned __int8 *)(v9 + v15);
  v17 = *a1;
  if ( *a1 )
    v16 = a1;
  *((_QWORD *)v14 + 1) = v16;
  *((_BYTE *)v14 + 796) = v14[199] & 0xFC | a3 & 3;
  if ( (dl_debug_mask & 0x100) == 0 )
    v14[245] = 1;
  *((_QWORD *)v14 + 6) = a6;
  v18 = v14 + 216;
  *((_QWORD *)v14 + 92) = a4;
  v19 = (__int64)*(&dl_ns + 18 * a6);
  *((_QWORD *)v14 + 113) = v14 + 216;
  *((_QWORD *)v14 + 112) = 4LL;
  if ( v19 )
  {
    v20 = (_QWORD *)(v19 + 704);
    v21 = 1LL;
    *((_QWORD *)v14 + 108) = v20;
    if ( !a4 )
    {
      a4 = v14;
      goto LABEL_32;
    }
  }
  else
  {
    v21 = 0LL;
    if ( !a4 )
    {
      a4 = v14;
LABEL_12:
      v22 = a4 + 88;
LABEL_13:
      *v18 = v22;
      goto LABEL_14;
    }
  }
  while ( a4[92] )
    a4 = (_QWORD *)a4[92];
  if ( !(_DWORD)v21 )
    goto LABEL_12;
  v20 = (_QWORD *)*((_QWORD *)v14 + 108);
LABEL_32:
  v22 = a4 + 88;
  if ( v22 != v20 )
  {
    if ( (a5 & 8) != 0 )
      *((_QWORD *)v14 + 109) = v20;
    else
      v18 = v14 + 218;
    goto LABEL_13;
  }
LABEL_14:
  v41 = v17;
  *((_QWORD *)v14 + 114) = v14 + 176;
  if ( v17 )
  {
    v23 = 0LL;
    v24 = j_strlen_ifunc(a1);
    v28 = v41;
    v29 = v24;
    v30 = v24 + 1;
    v43 = v30;
    v31 = v30;
    if ( v41 == 47 )
    {
      v39 = malloc(v30, v21, (_QWORD *)0x2F, v25, v26, v27);
      v34 = (__int64)v39;
      if ( !v39 )
      {
        v34 = -1LL;
LABEL_29:
        *((_QWORD *)v14 + 104) = v34;
        return v14;
      }
      v35 = v39;
    }
    else
    {
      while ( 1 )
      {
        v32 = v31 + 128;
        v33 = realloc(v23, v31 + 128, (_QWORD *)v28, v25, v26, v27);
        v34 = (__int64)v33;
        if ( !v33 )
        {
LABEL_20:
          v34 = -1LL;
          free(v23, v32, v28, v25, v26, v27);
          goto LABEL_29;
        }
        v32 = v31 + 127 - v29;
        if ( getcwd(v33, v32, (_QWORD *)v28, v25, v26, v27) )
          break;
        v23 = v34;
        v31 += 128LL;
        if ( __readfsdword(0xFFFFFFC0) != 34 )
          goto LABEL_20;
      }
      v35 = (_BYTE *)(v34 + strlen((const char *)v34));
      if ( *(v35 - 1) != 47 )
        *v35++ = 47;
    }
    for ( i = j_mempcpy(v35, a1, v43); ; --i )
    {
      v37 = (_BYTE *)(i - 1);
      if ( *(_BYTE *)(i - 1) == 47 )
        break;
    }
    if ( (_BYTE *)v34 == v37 )
      v37 = (_BYTE *)i;
    *v37 = 0;
    goto LABEL_29;
  }
  return v14;
}
// 46AB28: variable 'v10' is possibly undefined
// 46AB28: variable 'v11' is possibly undefined
// 46AB28: variable 'v12' is possibly undefined
// 46ADDB: variable 'v25' is possibly undefined
// 46ADDB: variable 'v26' is possibly undefined
// 46ADDB: variable 'v27' is possibly undefined
// 46AC9A: variable 'v28' is possibly undefined
// 401040: using guessed type __int64 __fastcall j_memcpy(_QWORD, _QWORD, _QWORD);
// 4010B0: using guessed type __int64 __fastcall j_mempcpy(_QWORD, _QWORD, _QWORD);
// 4010C8: using guessed type __int64 __fastcall j_strlen_ifunc(_QWORD);
// 4A9280: using guessed type void *dl_ns;
// 4AB880: using guessed type int dl_debug_mask;

//----- (000000000046AE00) ----------------------------------------------------
__int64 __fastcall dl_try_allocate_static_tls(__int64 a1)
{
  unsigned __int64 v1; // rsi
  __int64 v2; // rcx
  unsigned __int64 v3; // rax
  unsigned __int64 v4; // r8
  unsigned __int64 v5; // rdx
  __int64 v6; // rcx
  __int64 v7; // rax

  if ( *(_QWORD *)(a1 + 1096) == -1LL )
    return 0xFFFFFFFFLL;
  v1 = *(_QWORD *)(a1 + 1080);
  if ( v1 > dl_tls_static_align )
    return 0xFFFFFFFFLL;
  if ( (unsigned __int64)(dl_tls_static_size - dl_tls_static_used) <= 0x8FF )
    return 0xFFFFFFFFLL;
  v2 = *(_QWORD *)(a1 + 1088);
  v3 = dl_tls_static_size - dl_tls_static_used - 2304;
  v4 = v2 + *(_QWORD *)(a1 + 1072);
  if ( v3 < v4 )
    return 0xFFFFFFFFLL;
  v5 = (v3 - v4) % v1;
  v6 = v3 + dl_tls_static_used - v2 - v1 * ((v3 - v4) / v1);
  v7 = *(_QWORD *)(a1 + 40);
  dl_tls_static_used = v6;
  *(_QWORD *)(a1 + 1096) = v6;
  if ( (*(_BYTE *)(v7 + 796) & 4) != 0 )
    dl_init_static_tls(a1, v1, v5);
  else
    *(_BYTE *)(a1 + 797) |= 4u;
  return 0LL;
}
// 4A80E8: using guessed type __int64 dl_tls_static_size;
// 4A9240: using guessed type __int64 (__fastcall *dl_init_static_tls)(_QWORD, _QWORD, _QWORD);
// 4AB3C0: using guessed type __int64 dl_tls_static_used;
// 4AB3C8: using guessed type __int64 dl_tls_static_align;

//----- (000000000046AEC0) ----------------------------------------------------
__int64 __fastcall dl_allocate_static_tls(__int64 a1)
{
  __int64 result; // rax

  if ( *(_QWORD *)(a1 + 1096) == -1LL || (result = dl_try_allocate_static_tls(a1), (_DWORD)result) )
    dl_signal_error(0, *(void **)(a1 + 8), 0LL, "cannot allocate memory in static TLS block");
  return result;
}

//----- (000000000046AF00) ----------------------------------------------------
__int64 __fastcall dl_nothread_init_static_tls(_QWORD *a1)
{
  __int64 v1; // rdx
  __int64 v2; // rbx
  __int64 v3; // rax

  v1 = a1[133];
  v2 = a1[134] - v1;
  v3 = j_mempcpy(__readfsqword(0x10u) - a1[137], a1[132], v1);
  return j_memset_ifunc(v3, 0LL, v2);
}
// 401090: using guessed type __int64 __fastcall j_memset_ifunc(_QWORD, _QWORD, _QWORD);
// 4010B0: using guessed type __int64 __fastcall j_mempcpy(_QWORD, _QWORD, _QWORD);

//----- (000000000046AF50) ----------------------------------------------------
unsigned __int64 __fastcall dl_protect_relro(_QWORD *a1)
{
  __int64 v1; // rcx
  unsigned __int64 result; // rax
  __int64 v3; // rcx
  unsigned __int64 v4; // rsi

  v1 = *a1 + a1[140];
  result = a1[141] + v1;
  v3 = -dl_pagesize & v1;
  v4 = -dl_pagesize & result;
  if ( v3 != v4 )
  {
    result = mprotect(v3, v4 - v3, 1uLL);
    if ( (result & 0x80000000) != 0LL )
      dl_signal_error(
        __readfsdword(0xFFFFFFC0),
        (void *)a1[1],
        0LL,
        "cannot apply additional memory protection after relocation");
  }
  return result;
}
// 4A91F8: using guessed type __int64 dl_pagesize;

//----- (000000000046AFC0) ----------------------------------------------------
void __fastcall __noreturn dl_reloc_bad_type(__int64 a1, unsigned int a2)
{
  char v2; // bl
  _BYTE *v3; // rax
  void *v4; // rsi
  _BYTE savedregs[72]; // [rsp+0h] [rbp+0h] BYREF

  v2 = a2;
  v3 = (_BYTE *)j_stpcpy(savedregs);
  if ( a2 > 0xFF )
  {
    v3 += 6;
    *(v3 - 6) = itoa_lower_digits[a2 >> 28];
    *(v3 - 5) = itoa_lower_digits[HIBYTE(a2) & 0xF];
    *(v3 - 4) = itoa_lower_digits[(a2 >> 20) & 0xF];
    *(v3 - 3) = itoa_lower_digits[HIWORD(a2) & 0xF];
    *(v3 - 2) = itoa_lower_digits[(unsigned __int16)a2 >> 12];
    *(v3 - 1) = itoa_lower_digits[(a2 >> 8) & 0xF];
  }
  v3[2] = 0;
  *v3 = itoa_lower_digits[(unsigned __int8)a2 >> 4];
  v4 = *(void **)(a1 + 8);
  v3[1] = itoa_lower_digits[v2 & 0xF];
  dl_signal_error(0, v4, 0LL, savedregs);
}
// 401058: using guessed type __int64 __fastcall j_stpcpy(_QWORD);

//----- (000000000046B090) ----------------------------------------------------
void __fastcall dl_relocate_object(
        __int64 a1,
        __int64 *a2,
        int a3,
        unsigned int a4,
        u32 *a5,
        __int64 a6,
        double a7,
        double a8,
        double a9,
        double a10,
        double a11,
        double a12,
        double a13,
        double a14)
{
  __int64 v14; // r11
  int v15; // er12
  int v16; // er13
  bool v17; // zf
  __int64 v18; // rax
  __int64 v19; // rdx
  __int64 v20; // rax
  __int64 v21; // rax
  unsigned __int64 v22; // rdx
  __int64 v23; // rcx
  __int64 v24; // r15
  __int64 v25; // rax
  __int64 v26; // rdi
  __int64 v27; // rsi
  __int64 v28; // rax
  int v29; // esi
  __int64 v30; // r10
  unsigned __int64 v31; // rdi
  unsigned __int64 v32; // rax
  __int64 v33; // r15
  unsigned __int64 v34; // r12
  unsigned __int64 v35; // rbx
  unsigned __int64 v36; // rdi
  _QWORD *v37; // rcx
  __int64 v38; // rdx
  __int64 v39; // rsi
  _QWORD *v40; // r14
  __int64 (__fastcall *v41)(double, double, double, double, double, double, double, double); // rax
  __int64 (__fastcall **v42)(double, double, double, double, double, double, double, double); // r13
  __int64 v43; // r11
  const char *v44; // rdx
  __int64 v45; // rsi
  __int64 v46; // rdx
  const char *v47; // rsi
  _QWORD *v48; // rbx
  __int64 v49; // rdi
  __int64 v50; // r14
  _QWORD *v51; // r15
  unsigned __int64 v52; // r14
  const char *v53; // rsi
  __int16 v54; // dx
  unsigned int *v55; // r13
  unsigned __int8 v56; // al
  __int64 v57; // rdi
  int v58; // er9
  char *v59; // r8
  __int64 v60; // rax
  unsigned int *v61; // rdx
  __int64 v62; // r11
  _QWORD *v63; // rbx
  unsigned __int64 v64; // r13
  __int64 v65; // r15
  unsigned __int64 v66; // rax
  unsigned __int64 v67; // rax
  _QWORD *v68; // r14
  const char *v69; // rsi
  __int16 v70; // cx
  __int64 v71; // rdi
  unsigned int *v72; // r12
  __int64 v73; // rdx
  char *v74; // r8
  __int64 v75; // rax
  unsigned int *v76; // rcx
  __int64 v77; // rax
  __int64 v78; // rdx
  _QWORD *v79; // rcx
  __int64 v80; // rdx
  unsigned __int64 v81; // r14
  unsigned int *v82; // r13
  unsigned __int8 v83; // al
  int v84; // er9
  __int64 v85; // rdi
  __int64 *v86; // rcx
  __int64 v87; // rax
  unsigned int *v88; // rdx
  __int64 v89; // r11
  __int16 v90; // cx
  __int64 v91; // r10
  void (__fastcall *v92)(_QWORD, _QWORD, double, double, double, double, double, double, double, double); // r10
  char v93; // al
  __int64 v94; // rax
  const char *v95; // r8
  const char *v96; // rcx
  const char *v97; // rdx
  __int64 v98; // r9
  unsigned __int64 v99; // r11
  unsigned __int64 v100; // r10
  __int64 v101; // rsi
  const char *v102; // r8
  const char *v103; // rcx
  const char *v104; // rdx
  const char *v105; // r9
  void *v106; // rdx
  int v107; // ecx
  unsigned __int64 v108; // rax
  _QWORD *v109; // r14
  unsigned __int64 v110; // r12
  unsigned __int64 v111; // rax
  _QWORD *v112; // r13
  unsigned int *v113; // rbx
  unsigned __int8 v114; // dl
  __int64 v115; // rdi
  __int64 v116; // rax
  unsigned int *v117; // rcx
  __int16 v118; // cx
  __int64 v119; // r15
  void (__fastcall *v120)(double, double, double, double, double, double, double, double); // r15
  char v121; // al
  __int64 v122; // rax
  const char *v123; // rcx
  const char *v124; // r8
  const char *v125; // rdx
  __int64 v126; // r9
  __int64 v127; // r11
  unsigned __int64 v128; // r10
  __int64 v129; // rsi
  __int64 v130; // r9
  const char *v131; // r8
  const char *v132; // rdx
  const char *v133; // r9
  __int64 v134; // rdx
  unsigned __int64 v135; // rcx
  unsigned __int64 v136; // rbx
  __int64 v137; // r15
  __int64 v138; // r12
  __int64 v139; // rdi
  size_t v140; // rsi
  unsigned __int64 v141; // rdi
  int v142; // eax
  int v143; // ecx
  int v144; // eax
  int v145; // edx
  unsigned __int64 v146; // rax
  const char *v147; // rsi
  __int64 v148; // rax
  __int64 v149; // rdx
  unsigned __int64 v150; // rax
  unsigned __int64 v151; // rcx
  u32 *v152; // rax
  const char *v153; // rdx
  __int64 v154; // rbx
  __int64 v155; // r12
  int matched; // eax
  __int64 v157; // r11
  const char *v158; // rcx
  _QWORD v159[5]; // [rsp-Eh] [rbp-1138h] BYREF
  const char *v160; // [rsp+1012h] [rbp-118h]
  u32 *v161; // [rsp+101Ah] [rbp-110h]
  void (__fastcall *v162)(_QWORD, _QWORD, double, double, double, double, double, double, double, double); // [rsp+102Ah] [rbp-100h]
  __int64 v163; // [rsp+1032h] [rbp-F8h]
  __int64 v164; // [rsp+103Ah] [rbp-F0h]
  __int128 *v165; // [rsp+1042h] [rbp-E8h]
  unsigned int v166; // [rsp+104Ah] [rbp-E0h]
  unsigned int v167; // [rsp+104Eh] [rbp-DCh]
  unsigned __int64 v168; // [rsp+1052h] [rbp-D8h]
  unsigned __int64 v169; // [rsp+105Ah] [rbp-D0h]
  __int64 *v170; // [rsp+1062h] [rbp-C8h]
  __int64 v171; // [rsp+106Ah] [rbp-C0h]
  __int128 *v172; // [rsp+1072h] [rbp-B8h]
  unsigned __int64 v173; // [rsp+107Ah] [rbp-B0h]
  _QWORD *v174; // [rsp+1082h] [rbp-A8h]
  __int64 v175; // [rsp+108Ah] [rbp-A0h]
  unsigned int **v176; // [rsp+1092h] [rbp-98h]
  _QWORD *v177; // [rsp+109Ah] [rbp-90h]
  unsigned int *v178; // [rsp+10AAh] [rbp-80h] BYREF
  __int128 v179; // [rsp+10B2h] [rbp-78h] BYREF
  __int128 v180; // [rsp+10C2h] [rbp-68h]
  __int128 v181; // [rsp+10D2h] [rbp-58h]
  __int128 v182; // [rsp+10E2h] [rbp-48h]
  __int64 v183; // [rsp+10F2h] [rbp-38h] BYREF

  if ( (*(_BYTE *)(a1 + 796) & 4) == 0 )
  {
    v14 = a1;
    v15 = a3;
    v166 = a4;
    v170 = a2;
    if ( a4 || !*(_QWORD *)(a1 + 256) )
    {
      v16 = a3 & 1;
      if ( (dl_debug_mask & 0x20) == 0 )
        goto LABEL_4;
      v44 = " (lazy)";
      if ( (v15 & 1) == 0 )
        v44 = (const char *)byte_493255;
    }
    else
    {
      v16 = 0;
      if ( (dl_debug_mask & 0x20) == 0 )
        goto LABEL_4;
      v44 = (const char *)byte_493255;
    }
    v147 = *(const char **)(a1 + 8);
    if ( !*v147 )
    {
      v147 = (const char *)program_invocation_short_name[0];
      if ( !program_invocation_short_name[0] )
        v147 = "<main program>";
    }
    v177 = (_QWORD *)a1;
    dl_debug_printf("\nrelocation processing: %s%s\n", v147, v44);
    v14 = a1;
LABEL_4:
    v164 = *(_QWORD *)(v14 + 240);
    if ( v164 )
    {
      v134 = *(unsigned __int16 *)(v14 + 696);
      v135 = *(_QWORD *)(v14 + 680);
      v136 = v135;
      if ( v135 >= v135 + 56 * v134 )
      {
        v164 = 0LL;
      }
      else
      {
        LODWORD(v176) = v15;
        v137 = v14;
        v138 = 0LL;
        do
        {
          if ( (*(_QWORD *)v136 & 0x2FFFFFFFFLL) == 1 )
          {
            v139 = -dl_pagesize & *(_QWORD *)(v136 + 16);
            v140 = (-dl_pagesize & (*(_QWORD *)(v136 + 40) + *(_QWORD *)(v136 + 16) + dl_pagesize - 1)) - v139;
            v141 = *(_QWORD *)v137 + v139;
            v159[1] = v140;
            v159[0] = v141;
            v177 = v159;
            v142 = mprotect(v141, v140, 3uLL);
            a6 = (__int64)v177;
            if ( v142 < 0 )
            {
              v157 = v137;
              v158 = "cannot make segment writable for relocation";
              goto LABEL_270;
            }
            v143 = *(_DWORD *)(v136 + 4);
            v177[3] = v138;
            v138 = a6;
            v134 = *(unsigned __int16 *)(v137 + 696);
            v144 = 1934713408 >> (4 * (v143 & 7));
            v135 = *(_QWORD *)(v137 + 680);
            *(_DWORD *)(a6 + 16) = v144 & 0xF;
          }
          v136 += 56LL;
        }
        while ( v136 < v135 + 56 * v134 );
        v164 = v138;
        v14 = v137;
        v15 = (int)v176;
      }
    }
    v17 = *(_QWORD *)(v14 + 248) == 0LL;
    v171 = *(_QWORD *)(*(_QWORD *)(v14 + 104) + 8LL);
    if ( v17 )
    {
      v20 = *(_QWORD *)(v14 + 656);
      if ( !v20 || !v16 )
        goto LABEL_13;
    }
    else
    {
      if ( !v16 )
        goto LABEL_13;
      v18 = *(_QWORD *)(*(_QWORD *)(v14 + 88) + 8LL);
      v19 = *(_QWORD *)(v18 + 8);
      if ( v19 )
      {
        *(_QWORD *)(v14 + 1000) = *(_QWORD *)v14 + v19;
        *(_QWORD *)(v14 + 1008) = v18 + 24;
      }
      a5 = (u32 *)v166;
      *(_QWORD *)(v18 + 8) = v14;
      if ( (_DWORD)a5 )
      {
        if ( (dword_4AAE4C & 0x1000) != 0 )
        {
          *(_QWORD *)(v18 + 16) = &dl_runtime_profile_avx512;
        }
        else if ( (dword_4AAE4C & 0x40) != 0 )
        {
          *(_QWORD *)(v18 + 16) = &dl_runtime_profile_avx;
        }
        else
        {
          *(_QWORD *)(v18 + 16) = dl_runtime_profile_sse;
        }
        if ( dl_profile )
        {
          v177 = (_QWORD *)v14;
          matched = dl_name_match_p(dl_profile, v14);
          v14 = (__int64)v177;
          if ( matched )
            dl_profile_map = (__int64)v177;
        }
      }
      else if ( qword_4AAE40 )
      {
        v106 = dl_runtime_resolve_xsave;
        if ( (dword_4AAE4C & 0x400000) != 0 )
          v106 = dl_runtime_resolve_xsavec;
        *(_QWORD *)(v18 + 16) = v106;
      }
      else
      {
        *(_QWORD *)(v18 + 16) = dl_runtime_resolve_fxsave;
      }
      v20 = *(_QWORD *)(v14 + 656);
      if ( !v20 )
        goto LABEL_13;
    }
    *(_QWORD *)(*(_QWORD *)(v20 + 8) + *(_QWORD *)v14) = dl_tlsdesc_resolve_rela;
LABEL_13:
    v21 = *(_QWORD *)(v14 + 120);
    v179 = 0LL;
    v180 = 0LL;
    v181 = 0LL;
    v182 = 0LL;
    if ( v21 )
    {
      v22 = *(_QWORD *)(v21 + 8);
      v23 = 0LL;
      v24 = *(_QWORD *)(*(_QWORD *)(v14 + 128) + 8LL);
      v25 = *(_QWORD *)(v14 + 392);
      *(_QWORD *)&v179 = v22;
      *((_QWORD *)&v179 + 1) = v24;
      v26 = v22 + v24;
      if ( v25 )
      {
        v23 = *(_QWORD *)(v25 + 8);
        *(_QWORD *)&v180 = v23;
      }
    }
    else
    {
      v23 = 0LL;
      v26 = 0LL;
      v24 = 0LL;
      v22 = 0LL;
    }
    if ( *(_QWORD *)(v14 + 224) )
    {
      v27 = *(_QWORD *)(*(_QWORD *)(v14 + 248) + 8LL);
      v28 = *(_QWORD *)(*(_QWORD *)(v14 + 80) + 8LL);
      a5 = (u32 *)(v27 + v28);
      if ( v27 + v28 == v26 )
      {
        v24 -= v28;
        *((_QWORD *)&v179 + 1) = v24;
        v26 = v24 + v22;
      }
      if ( !v16 && v27 == v26 )
      {
        v24 += v28;
        *((_QWORD *)&v179 + 1) = v24;
      }
      else
      {
        *(_QWORD *)&v181 = v27;
        *((_QWORD *)&v181 + 1) = v28;
        DWORD2(v182) = v16;
      }
    }
    v29 = 0;
    v30 = v14;
    v172 = &v179;
    v167 = v15 & 0x2000000;
    v165 = (__int128 *)&v183;
    while ( 1 )
    {
      v31 = v22 + v24;
      v32 = v22;
      v33 = *(_QWORD *)v30;
      v177 = (_QWORD *)v31;
      if ( !v29 )
      {
        v47 = *(const char **)(v30 + 112);
        v48 = (_QWORD *)(v22 + 24 * v23);
        v49 = *((_QWORD *)v47 + 1);
        v175 = v49;
        if ( v30 && (v33 || !*(_QWORD *)(v30 + 576)) && v22 < (unsigned __int64)v48 )
        {
          do
          {
            v78 = *(unsigned int *)(v32 + 8);
            v79 = (_QWORD *)(v33 + *(_QWORD *)v32);
            if ( v78 != 38 && v78 != 8 )
              _assert_fail(
                (__int64)"ELFW(R_TYPE) (reloc->r_info) == R_X86_64_RELATIVE",
                (__int64)"../sysdeps/x86_64/dl-machine.h",
                0x21Au,
                "elf_machine_rela_relative");
            v80 = *(_QWORD *)(v32 + 16);
            v32 += 24LL;
            *v79 = v33 + v80;
          }
          while ( (unsigned __int64)v48 > v32 );
          v50 = *(_QWORD *)(v30 + 464);
          if ( !v50 )
          {
LABEL_98:
            v169 = 0LL;
            if ( v177 <= v48 )
              goto LABEL_42;
            v174 = (_QWORD *)v33;
            v173 = v50;
            while ( 2 )
            {
              v81 = v48[1];
              if ( (unsigned int)v81 == 37LL )
              {
                v169 = (unsigned __int64)v48;
                if ( !v173 )
                  v173 = (unsigned __int64)v48;
              }
              else
              {
                v176 = (unsigned int **)((char *)v174 + *v48);
                v49 = v175;
                v82 = (unsigned int *)(v175 + 24 * HIDWORD(v81));
                v178 = v82;
                if ( (unsigned int)v81 == 8LL )
                {
                  v49 = (__int64)v176;
                  *v176 = (unsigned int *)(*(_QWORD *)v30 + v48[2]);
                }
                else if ( (unsigned int)v81 == 38LL )
                {
                  v47 = (const char *)v176;
                  *v176 = (unsigned int *)(*(_QWORD *)v30 + v48[2]);
                }
                else if ( (_DWORD)v81 )
                {
                  v83 = *((_BYTE *)v82 + 4);
                  if ( !(v83 >> 4) || (*((_BYTE *)v82 + 5) & 3u) - 1 <= 1 )
                  {
                    v88 = (unsigned int *)(v175 + 24 * HIDWORD(v81));
                    v89 = v30;
                    v118 = *((_WORD *)v82 + 3);
                    if ( v118 == -15 )
                      goto LABEL_193;
                    goto LABEL_179;
                  }
                  if ( v82 != *(unsigned int **)(v30 + 1024) )
                  {
LABEL_107:
                    if ( (unsigned int)v81 == 7LL || (unsigned int)v81 == 16LL )
                    {
                      v84 = 1;
                      goto LABEL_110;
                    }
LABEL_109:
                    v84 = (unsigned int)v81 == 36LL || (unsigned __int64)(unsigned int)v81 - 17 <= 1;
                    if ( (unsigned int)v81 == 5LL )
                    {
                      v84 |= 2u;
                    }
                    else
                    {
LABEL_110:
                      if ( (unsigned int)v81 == 6LL )
                        v84 |= 4u;
                    }
                    v85 = *v82;
                    *(_DWORD *)(v30 + 1032) = v84;
                    v86 = v170;
                    *(_QWORD *)(v30 + 1024) = v82;
                    v168 = v30;
                    v87 = dl_lookup_symbol_x(
                            (unsigned __int8 *)(v171 + v85),
                            v30,
                            &v178,
                            v86,
                            0LL,
                            v84,
                            0.0,
                            a8,
                            a9,
                            a10,
                            a11,
                            a12,
                            a13,
                            a14,
                            1,
                            0LL);
                    v30 = v168;
                    v88 = v178;
                    v89 = v87;
                    *(_QWORD *)(v168 + 1048) = v178;
                    *(_QWORD *)(v30 + 1040) = v87;
LABEL_113:
                    if ( !v88 )
                    {
LABEL_114:
                      if ( (unsigned int)v81 <= 0x25uLL )
                        __asm { jmp     rax }
                      dl_reloc_bad_type(v30, v81);
                    }
                    v118 = *((_WORD *)v88 + 3);
                    v83 = *((_BYTE *)v88 + 4);
                    if ( v118 == -15 )
                    {
LABEL_193:
                      v119 = 0LL;
                      goto LABEL_180;
                    }
LABEL_179:
                    v119 = *(_QWORD *)v89;
LABEL_180:
                    v120 = (void (__fastcall *)(double, double, double, double, double, double, double, double))(*((_QWORD *)v88 + 1) + v119);
                    if ( (v83 & 0xF) == 10 && v118 && !v167 )
                    {
                      if ( v30 != v89 )
                      {
                        v121 = *(_BYTE *)(v89 + 796);
                        if ( (v121 & 3) != 0 && (v121 & 4) == 0 )
                        {
                          v122 = *(_QWORD *)(v30 + 104);
                          v123 = *(const char **)(v30 + 8);
                          v124 = *(const char **)(v89 + 8);
                          v163 = v30;
                          v125 = (const char *)program_invocation_short_name[0];
                          v126 = *v82;
                          v168 = v89;
                          if ( !program_invocation_short_name[0] )
                            v125 = "<program name unknown>";
                          dl_dprintf(
                            2,
                            "%s: Relink `%s' with `%s' for IFUNC symbol `%s'\n",
                            v125,
                            v123,
                            v124,
                            (const char *)(*(_QWORD *)(v122 + 8) + v126));
                          v30 = v163;
                          v89 = v168;
                        }
                      }
                      v163 = v30;
                      v168 = v89;
                      v120(0.0, a8, a9, a10, a11, a12, a13, a14);
                      v30 = v163;
                    }
                    goto LABEL_114;
                  }
                  if ( (unsigned int)v81 > 0x24uLL )
                  {
                    v145 = *(_DWORD *)(v30 + 1032);
                    LODWORD(v146) = 0;
                  }
                  else
                  {
                    v145 = *(_DWORD *)(v30 + 1032);
                    v146 = (0x1000070080uLL >> v81) & 1;
                    if ( (unsigned int)v81 == 5LL )
                    {
                      if ( ((unsigned int)v146 | 2) != v145 )
                        goto LABEL_109;
                      goto LABEL_224;
                    }
                    if ( (unsigned int)v81 == 6LL )
                    {
                      if ( v145 != 5 - ((_DWORD)v146 == 0) )
                        goto LABEL_109;
                      goto LABEL_224;
                    }
                  }
                  if ( v145 != (_DWORD)v146 )
                    goto LABEL_107;
LABEL_224:
                  v88 = *(unsigned int **)(v30 + 1048);
                  v89 = *(_QWORD *)(v30 + 1040);
                  v178 = v88;
                  goto LABEL_113;
                }
              }
              v48 += 3;
              if ( v177 > v48 )
                continue;
              break;
            }
            v109 = (_QWORD *)v173;
            if ( !v173 )
              goto LABEL_42;
            v110 = v169;
            if ( v173 > v169 )
              goto LABEL_42;
            v177 = v174;
            v65 = v30;
            v176 = &v178;
            while ( 2 )
            {
              v111 = v109[1];
              if ( (_DWORD)v111 == 37 )
              {
                v112 = (_QWORD *)((char *)v177 + *v109);
                v113 = (unsigned int *)(v175 + 24 * HIDWORD(v111));
                v178 = v113;
                v114 = *((_BYTE *)v113 + 4);
                if ( v114 >> 4 && (*((_BYTE *)v113 + 5) & 3u) - 1 > 1 )
                {
                  if ( v113 != *(unsigned int **)(v65 + 1024) || *(_DWORD *)(v65 + 1032) )
                  {
                    v115 = *v113;
                    *(_QWORD *)(v65 + 1024) = v113;
                    *(_DWORD *)(v65 + 1032) = 0;
                    v116 = dl_lookup_symbol_x(
                             (unsigned __int8 *)(v171 + v115),
                             v65,
                             v176,
                             v170,
                             0LL,
                             0,
                             0.0,
                             a8,
                             a9,
                             a10,
                             a11,
                             a12,
                             a13,
                             a14,
                             1,
                             0LL);
                    v117 = v178;
                    *(_QWORD *)(v65 + 1040) = v116;
                    *(_QWORD *)(v65 + 1048) = v117;
                    v47 = v160;
                    v49 = (__int64)v161;
                  }
                  else
                  {
                    v117 = *(unsigned int **)(v65 + 1048);
                    v116 = *(_QWORD *)(v65 + 1040);
                    v178 = v117;
                  }
                  if ( !v117 )
                    goto LABEL_175;
                  v114 = *((_BYTE *)v117 + 4);
                }
                else
                {
                  v116 = v65;
                  v117 = v113;
                }
                v47 = (const char *)*((unsigned __int16 *)v117 + 3);
                if ( (_WORD)v47 == 0xFFF1 )
                  v127 = 0LL;
                else
                  v127 = *(_QWORD *)v116;
                if ( (v114 & 0xF) == 10 && !v167 && (_WORD)v47 )
                {
                  v128 = *((_QWORD *)v117 + 1);
                  if ( v65 != v116 && (*(_BYTE *)(v116 + 796) & 3) != 0 && (*(_BYTE *)(v116 + 796) & 4) == 0 )
                  {
                    v129 = *(_QWORD *)(v65 + 104);
                    v49 = 2LL;
                    v173 = *((_QWORD *)v117 + 1);
                    v130 = *v113;
                    v131 = *(const char **)(v116 + 8);
                    v174 = (_QWORD *)v127;
                    v132 = (const char *)program_invocation_short_name[0];
                    if ( !program_invocation_short_name[0] )
                      v132 = "<program name unknown>";
                    v133 = (const char *)(*(_QWORD *)(v129 + 8) + v130);
                    v47 = "%s: Relink `%s' with `%s' for IFUNC symbol `%s'\n";
                    dl_dprintf(
                      2,
                      "%s: Relink `%s' with `%s' for IFUNC symbol `%s'\n",
                      v132,
                      *(const char **)(v65 + 8),
                      v131,
                      v133);
                    v128 = v173;
                    v127 = (__int64)v174;
                  }
                  ((void (__fastcall *)(double, double, double, double, double, double, double, double))(v128 + v127))(
                    0.0,
                    a8,
                    a9,
                    a10,
                    a11,
                    a12,
                    a13,
                    a14);
                }
LABEL_175:
                *v112 = ((__int64 (__fastcall *)(__int64, const char *))(*(_QWORD *)v65 + v109[2]))(v49, v47);
              }
              v109 += 3;
              if ( (unsigned __int64)v109 > v110 )
                goto LABEL_92;
              continue;
            }
          }
        }
        else
        {
          v50 = *(_QWORD *)(v30 + 464);
          if ( !v50 )
            goto LABEL_98;
        }
        v174 = *(_QWORD **)(v50 + 8);
        if ( v177 <= v48 )
          goto LABEL_42;
        v168 = 0LL;
        v169 = 0LL;
        v173 = v33;
        v51 = (_QWORD *)v30;
        while ( 2 )
        {
          v52 = v48[1];
          if ( (unsigned int)v52 == 37LL )
          {
            v168 = (unsigned __int64)v48;
            if ( !v169 )
              v169 = (unsigned __int64)v48;
          }
          else
          {
            v53 = *(const char **)(v30 + 744);
            v54 = *((_WORD *)v174 + HIDWORD(v52));
            v176 = (unsigned int **)(*v48 + v173);
            v55 = (unsigned int *)(v175 + 24 * HIDWORD(v52));
            v178 = v55;
            if ( (unsigned int)v52 == 8LL || (unsigned int)v52 == 38LL )
            {
              *v176 = (unsigned int *)(*(_QWORD *)v30 + v48[2]);
            }
            else if ( (_DWORD)v52 )
            {
              v56 = *((_BYTE *)v55 + 4);
              v57 = v56;
              LOBYTE(v57) = v56 >> 4;
              if ( !(v56 >> 4) || (*((_BYTE *)v55 + 5) & 3u) - 1 <= 1 )
              {
                v61 = (unsigned int *)(v175 + 24 * HIDWORD(v52));
                v62 = v30;
                v90 = *((_WORD *)v55 + 3);
                if ( v90 == -15 )
                  goto LABEL_134;
                goto LABEL_117;
              }
              if ( v55 != *(unsigned int **)(v30 + 1024) )
              {
LABEL_65:
                if ( (unsigned int)v52 == 7LL || (unsigned int)v52 == 16LL )
                {
                  v58 = 1;
                  goto LABEL_68;
                }
LABEL_67:
                v58 = (unsigned int)v52 == 36LL || (unsigned __int64)(unsigned int)v52 - 17 <= 1;
                if ( (unsigned int)v52 == 5LL )
                {
                  v58 |= 2u;
                }
                else
                {
LABEL_68:
                  if ( (unsigned int)v52 == 6LL )
                    v58 |= 4u;
                }
                *(_DWORD *)(v30 + 1032) = v58;
                *(_QWORD *)(v30 + 1024) = v55;
                v59 = (char *)&v53[24 * (v54 & 0x7FFF)];
                if ( v59 && !*((_DWORD *)v59 + 2) )
                  v59 = 0LL;
                v53 = (const char *)v30;
                v57 = v171 + *v55;
                v60 = dl_lookup_symbol_x(
                        (unsigned __int8 *)v57,
                        v30,
                        &v178,
                        v170,
                        (const char **)v59,
                        v58,
                        0.0,
                        a8,
                        a9,
                        a10,
                        a11,
                        a12,
                        a13,
                        a14,
                        1,
                        0LL);
                v61 = v178;
                v51[130] = v60;
                v62 = v60;
                v51[131] = v61;
LABEL_74:
                if ( !v61 )
                {
LABEL_75:
                  if ( (unsigned int)v52 <= 0x25uLL )
                    __asm { jmp     rax }
                  dl_reloc_bad_type((__int64)v51, v52);
                }
                v90 = *((_WORD *)v61 + 3);
                v56 = *((_BYTE *)v61 + 4);
                if ( v90 == -15 )
                {
LABEL_134:
                  v91 = 0LL;
                  goto LABEL_118;
                }
LABEL_117:
                v91 = *(_QWORD *)v62;
LABEL_118:
                v92 = (void (__fastcall *)(_QWORD, _QWORD, double, double, double, double, double, double, double, double))(*((_QWORD *)v61 + 1) + v91);
                if ( (v56 & 0xF) == 10 && v90 && !v167 )
                {
                  if ( v51 != (_QWORD *)v62 )
                  {
                    v93 = *(_BYTE *)(v62 + 796);
                    if ( (v93 & 3) != 0 && (v93 & 4) == 0 )
                    {
                      v94 = v51[13];
                      v57 = 2LL;
                      v95 = *(const char **)(v62 + 8);
                      v96 = (const char *)v51[1];
                      v162 = v92;
                      v97 = (const char *)program_invocation_short_name[0];
                      v98 = *v55;
                      v163 = v62;
                      if ( !program_invocation_short_name[0] )
                        v97 = "<program name unknown>";
                      v53 = "%s: Relink `%s' with `%s' for IFUNC symbol `%s'\n";
                      dl_dprintf(
                        2,
                        "%s: Relink `%s' with `%s' for IFUNC symbol `%s'\n",
                        v97,
                        v96,
                        v95,
                        (const char *)(*(_QWORD *)(v94 + 8) + v98));
                      v92 = v162;
                      v62 = v163;
                    }
                  }
                  v163 = v62;
                  v92(v57, v53, 0.0, a8, a9, a10, a11, a12, a13, a14);
                }
                goto LABEL_75;
              }
              if ( (unsigned int)v52 <= 0x24uLL )
              {
                v107 = *(_DWORD *)(v30 + 1032);
                v108 = (0x1000070080uLL >> v52) & 1;
                if ( (unsigned int)v52 == 5LL )
                {
                  if ( ((unsigned int)v108 | 2) != v107 )
                    goto LABEL_67;
                }
                else
                {
                  if ( (unsigned int)v52 != 6LL )
                    goto LABEL_162;
                  if ( 5 - ((_DWORD)v108 == 0) != v107 )
                    goto LABEL_67;
                }
              }
              else
              {
                v107 = *(_DWORD *)(v30 + 1032);
                LODWORD(v108) = 0;
LABEL_162:
                if ( v107 != (_DWORD)v108 )
                  goto LABEL_65;
              }
              v61 = *(unsigned int **)(v30 + 1048);
              v62 = *(_QWORD *)(v30 + 1040);
              v178 = v61;
              goto LABEL_74;
            }
          }
          v48 += 3;
          if ( v177 > v48 )
            continue;
          break;
        }
        v63 = (_QWORD *)v169;
        if ( !v169 )
          goto LABEL_42;
        v64 = v168;
        if ( v169 > v168 )
          goto LABEL_42;
        v177 = (_QWORD *)v173;
        v65 = v30;
        v176 = &v178;
        while ( 2 )
        {
          while ( 1 )
          {
            v66 = v63[1];
            if ( (_DWORD)v66 == 37 )
              break;
            v63 += 3;
            if ( (unsigned __int64)v63 > v64 )
              goto LABEL_92;
          }
          v67 = HIDWORD(v66);
          v68 = (_QWORD *)((char *)v177 + *v63);
          v69 = *(const char **)(v65 + 744);
          v70 = *((_WORD *)v174 + v67);
          v71 = v175;
          v72 = (unsigned int *)(v175 + 24 * v67);
          v178 = v72;
          v73 = *((unsigned __int8 *)v72 + 4);
          if ( *((_BYTE *)v72 + 4) >> 4 && (*((_BYTE *)v72 + 5) & 3u) - 1 > 1 )
          {
            if ( v72 != *(unsigned int **)(v65 + 1024) || *(_DWORD *)(v65 + 1032) )
            {
              *(_QWORD *)(v65 + 1024) = v72;
              *(_DWORD *)(v65 + 1032) = 0;
              v74 = (char *)&v69[24 * (v70 & 0x7FFF)];
              if ( v74 && !*((_DWORD *)v74 + 2) )
                v74 = 0LL;
              v69 = (const char *)v65;
              v75 = dl_lookup_symbol_x(
                      (unsigned __int8 *)(v171 + *v72),
                      v65,
                      v176,
                      v170,
                      (const char **)v74,
                      0,
                      0.0,
                      a8,
                      a9,
                      a10,
                      a11,
                      a12,
                      a13,
                      a14,
                      1,
                      0LL);
              v76 = v178;
              *(_QWORD *)(v65 + 1040) = v75;
              *(_QWORD *)(v65 + 1048) = v76;
              v71 = (__int64)v160;
              a5 = v161;
            }
            else
            {
              v76 = *(unsigned int **)(v65 + 1048);
              v75 = *(_QWORD *)(v65 + 1040);
              v178 = v76;
            }
            if ( !v76 )
            {
LABEL_91:
              v77 = v63[2];
              v63 += 3;
              *v68 = ((__int64 (__fastcall *)(__int64, const char *, __int64, unsigned int *, u32 *))(*(_QWORD *)v65 + v77))(
                       v71,
                       v69,
                       v73,
                       v76,
                       a5);
              if ( (unsigned __int64)v63 > v64 )
              {
LABEL_92:
                v30 = v65;
                goto LABEL_42;
              }
              continue;
            }
            LOBYTE(v73) = *((_BYTE *)v76 + 4);
          }
          else
          {
            v75 = v65;
            v76 = v72;
          }
          break;
        }
        v69 = (const char *)*((unsigned __int16 *)v76 + 3);
        if ( (_WORD)v69 == 0xFFF1 )
          v99 = 0LL;
        else
          v99 = *(_QWORD *)v75;
        v73 &= 0xFu;
        if ( (_BYTE)v73 == 10 )
        {
          if ( (_WORD)v69 )
          {
            v69 = (const char *)v167;
            if ( !v167 )
            {
              v100 = *((_QWORD *)v76 + 1);
              if ( v65 != v75 && (*(_BYTE *)(v75 + 796) & 3) != 0 && (*(_BYTE *)(v75 + 796) & 4) == 0 )
              {
                v101 = *(_QWORD *)(v65 + 104);
                v169 = *((_QWORD *)v76 + 1);
                v102 = *(const char **)(v75 + 8);
                v103 = *(const char **)(v65 + 8);
                v173 = v99;
                v104 = (const char *)program_invocation_short_name[0];
                if ( !program_invocation_short_name[0] )
                  v104 = "<program name unknown>";
                v105 = (const char *)(*(_QWORD *)(v101 + 8) + *v72);
                v71 = 2LL;
                v69 = "%s: Relink `%s' with `%s' for IFUNC symbol `%s'\n";
                dl_dprintf(2, "%s: Relink `%s' with `%s' for IFUNC symbol `%s'\n", v104, v103, v102, v105);
                v100 = v169;
                v99 = v173;
              }
              ((void (__fastcall *)(double, double, double, double, double, double, double, double))(v100 + v99))(
                0.0,
                a8,
                a9,
                a10,
                a11,
                a12,
                a13,
                a14);
            }
          }
        }
        goto LABEL_91;
      }
      v34 = 0LL;
      v35 = 0LL;
      if ( v22 >= v31 )
        goto LABEL_42;
      v36 = (unsigned __int64)v177;
      do
      {
        while ( 1 )
        {
          v39 = *(_QWORD *)(v32 + 8);
          if ( (unsigned int)v39 != 37LL )
          {
            v37 = (_QWORD *)(v33 + *(_QWORD *)v32);
            if ( (unsigned int)v39 == 7LL )
            {
              v38 = *(_QWORD *)(v30 + 1000);
              if ( v38 )
                *v37 = v38 + 2LL * ((_QWORD)v37 - *(_QWORD *)(v30 + 1008));
              else
                *v37 += v33;
            }
            else
            {
              if ( (unsigned int)v39 != 36LL )
                dl_reloc_bad_type(v30, v39);
              v45 = *(_QWORD *)(v30 + 664);
              v46 = *(_QWORD *)v30;
              v37[1] = v32;
              *v37 = *(_QWORD *)(v45 + 8) + v46;
            }
            goto LABEL_29;
          }
          v34 = v32;
          if ( !v35 )
            break;
LABEL_29:
          v32 += 24LL;
          if ( v36 <= v32 )
            goto LABEL_33;
        }
        v35 = v32;
        v32 += 24LL;
      }
      while ( v36 > v32 );
LABEL_33:
      if ( v35 && v35 <= v34 )
      {
        v40 = (_QWORD *)v30;
        do
        {
          while ( *(_DWORD *)(v35 + 8) != 37 )
          {
            v35 += 24LL;
            if ( v35 > v34 )
              goto LABEL_41;
          }
          v41 = (__int64 (__fastcall *)(double, double, double, double, double, double, double, double))(*v40 + *(_QWORD *)(v35 + 16));
          v42 = (__int64 (__fastcall **)(double, double, double, double, double, double, double, double))(v33 + *(_QWORD *)v35);
          if ( !v167 )
            v41 = (__int64 (__fastcall *)(double, double, double, double, double, double, double, double))v41(0.0, a8, a9, a10, a11, a12, a13, a14);
          v35 += 24LL;
          *v42 = v41;
        }
        while ( v35 <= v34 );
LABEL_41:
        v30 = (__int64)v40;
      }
LABEL_42:
      v172 += 2;
      if ( v165 == v172 )
      {
        v43 = v30;
        if ( v166 )
        {
          v148 = *(_QWORD *)(v30 + 80);
          if ( v148 )
          {
            v149 = *(_QWORD *)(v30 + 224);
            v150 = *(_QWORD *)(v148 + 8);
            v177 = (_QWORD *)v30;
            v151 = 8LL * (*(_QWORD *)(v149 + 8) == 7LL) + 16;
            v152 = calloc(32LL, v150 / v151, v150 % v151, v151, a5, a6);
            v43 = (__int64)v177;
            v177[102] = v152;
            if ( !v152 )
            {
              v153 = (const char *)program_invocation_short_name[0];
              if ( !program_invocation_short_name[0] )
                v153 = "<program name unknown>";
              dl_dprintf(2, "%s: out of memory to store relocation results for %s\n", v153, *(const char **)(v43 + 8));
              exit(127);
            }
          }
        }
        *(_BYTE *)(v43 + 796) |= 4u;
        if ( !v164 )
        {
LABEL_45:
          if ( *(_QWORD *)(v43 + 1128) )
            dl_protect_relro((_QWORD *)v43);
          return;
        }
        v154 = v164;
        v155 = v43;
        while ( (mprotect(*(_QWORD *)v154, *(_QWORD *)(v154 + 8), *(unsigned int *)(v154 + 16)) & 0x80000000) == 0LL )
        {
          v154 = *(_QWORD *)(v154 + 24);
          if ( !v154 )
          {
            v43 = v155;
            goto LABEL_45;
          }
        }
        v157 = v155;
        v158 = "cannot restore segment prot after reloc";
LABEL_270:
        dl_signal_error(__readfsdword(0xFFFFFFC0), *(void **)(v157 + 8), 0LL, v158);
      }
      v29 = *((_DWORD *)v172 + 6);
      v23 = *((_QWORD *)v172 + 2);
      v24 = *((_QWORD *)v172 + 1);
      v22 = *(_QWORD *)v172;
    }
  }
}
// 46BC1A: conditional instruction was optimized away because r12.8 is in (==7|==10)
// 46C2AA: conditional instruction was optimized away because r12.8 is in (==7|==10)
// 46B2F6: variable 'a11' is possibly undefined
// 46B2F6: variable 'a12' is possibly undefined
// 46B72A: variable 'v73' is possibly undefined
// 46B72A: variable 'v76' is possibly undefined
// 46B72A: variable 'a5' is possibly undefined
// 46C688: variable 'a6' is possibly undefined
// 493255: using guessed type unsigned __int8 byte_493255[1707];
// 4A9168: using guessed type char (*program_invocation_short_name[2])[1707];
// 4A91F8: using guessed type __int64 dl_pagesize;
// 4AAE40: using guessed type __int64 qword_4AAE40;
// 4AAE4C: using guessed type int dword_4AAE4C;
// 4AB880: using guessed type int dl_debug_mask;
// 4AB890: using guessed type __int64 dl_profile;
// 4AB910: using guessed type __int64 dl_profile_map;

//----- (000000000046C990) ----------------------------------------------------
_QWORD *__fastcall dl_important_hwcaps(__int64 a1, __int64 a2, __int64 *a3, _QWORD *a4)
{
  __int64 v4; // r9
  __int64 v5; // rdx
  __int64 v6; // r8
  unsigned __int64 v7; // rcx
  unsigned __int64 v8; // rbx
  unsigned __int64 v9; // rax
  __int64 v10; // r15
  __int64 v11; // rsi
  __int64 v12; // r12
  unsigned __int64 v13; // r14
  unsigned __int64 v14; // rdi
  unsigned int *v15; // rdx
  __int64 v16; // rcx
  __int64 v17; // rax
  __int64 v18; // r13
  __int64 v19; // r8
  unsigned int *v20; // rcx
  unsigned int *v21; // r14
  __int64 *v22; // rsi
  void *v23; // rsp
  __int64 v24; // rax
  unsigned __int64 *v25; // r12
  int v26; // er15
  unsigned __int64 v27; // rax
  __int64 v28; // r13
  __int64 v29; // rcx
  unsigned int *v30; // r12
  unsigned __int64 v31; // r14
  _BYTE *v32; // rbx
  __int64 v33; // rax
  __int64 v34; // rdx
  _QWORD *v35; // rdx
  unsigned __int64 v36; // r15
  __int64 v37; // rdx
  __int64 v38; // r14
  __int64 v39; // rsi
  __int64 v40; // rbx
  __int64 v41; // r12
  __int64 v42; // r13
  unsigned __int8 v43; // cf
  char *v44; // rdi
  char **v45; // r14
  __int64 v46; // rax
  char v47; // cl
  __int64 v48; // rdx
  __int64 v49; // rax
  __int16 v50; // ax
  __int64 *v51; // rdx
  unsigned int v52; // eax
  void *v53; // rsp
  __int64 v54; // rsi
  _QWORD *v55; // rdx
  __int64 *v56; // rax
  __int64 v57; // rcx
  unsigned __int64 *v58; // rax
  __int64 v59; // rax
  __int64 v60; // rax
  __int64 v61; // rdx
  __int64 v62; // rax
  __int64 v63; // rcx
  unsigned int v64; // esi
  __int64 v65; // rcx
  int v66; // edi
  __int64 v67; // rsi
  __int64 v68; // r13
  _QWORD *v69; // rax
  char v70; // si
  _QWORD *v71; // r14
  _BYTE *v72; // rdi
  __int64 *v73; // rax
  unsigned __int64 v74; // rax
  __int64 v75; // rbx
  unsigned __int64 v76; // r15
  unsigned __int64 v77; // r14
  _BYTE *v78; // rax
  _BYTE *v79; // rdi
  _BYTE *v80; // rax
  _BYTE *v81; // rax
  unsigned __int64 v82; // rcx
  unsigned __int64 v83; // rax
  unsigned __int64 v84; // rdx
  __int64 v85; // rdi
  __int64 v86; // r11
  unsigned __int64 v87; // rcx
  _QWORD *v88; // rdx
  __int64 v89; // rax
  __int64 v90; // rsi
  __int64 v91; // r10
  _QWORD *v92; // rdi
  __int64 v93; // rsi
  __int64 v94; // r8
  _QWORD *v95; // rax
  __int64 v96; // rdx
  __int64 v97; // rcx
  __int64 v98; // rcx
  __int64 v99; // rcx
  __int64 v100; // rax
  __int64 v101; // rdx
  __int64 *v103; // rdx
  __int64 v104; // rbx
  _QWORD *v105; // rax
  _BYTE *v106; // rax
  __int64 v107; // rdx
  __int64 *v108; // rsi
  __int64 v109; // rdx
  unsigned __int64 v110; // rsi
  _BYTE *v111; // rax
  _QWORD *v112; // rbx
  _BYTE v114[4088]; // [rsp+8h] [rbp-10B0h] BYREF
  __int64 v115; // [rsp+1008h] [rbp-B0h] BYREF
  _QWORD *v116; // [rsp+1010h] [rbp-A8h]
  unsigned __int64 v117; // [rsp+1018h] [rbp-A0h]
  int v118; // [rsp+1024h] [rbp-94h]
  __int64 v119; // [rsp+1028h] [rbp-90h]
  __int64 v120; // [rsp+1030h] [rbp-88h]
  unsigned __int64 *v121; // [rsp+1038h] [rbp-80h]
  _QWORD *v122; // [rsp+1040h] [rbp-78h]
  unsigned __int64 *v123; // [rsp+1048h] [rbp-70h]
  __int64 v124; // [rsp+1050h] [rbp-68h]
  __int64 v125; // [rsp+1058h] [rbp-60h]
  __int64 *v126; // [rsp+1060h] [rbp-58h]
  __int64 v127; // [rsp+1068h] [rbp-50h]
  _BYTE *v128; // [rsp+1070h] [rbp-48h]
  __int64 v129[7]; // [rsp+1080h] [rbp-38h] BYREF

  v125 = a1;
  v123 = (unsigned __int64 *)a2;
  v126 = a3;
  v121 = (unsigned __int64 *)v129;
  v122 = a4;
  _tunable_get_val(0x10u, v129, 0LL);
  v127 = dl_hwcap;
  v5 = a1 != 0;
  v124 = v129[0];
  v6 = v129[0] & dl_hwcap;
  if ( (v129[0] & dl_hwcap) != 0 )
  {
    v7 = 0LL;
    do
    {
      v8 = v5 + 1;
      if ( _bittest64(&v6, v7) )
      {
        v9 = v5 + 2;
        ++v5;
        v8 = v9;
      }
      ++v7;
    }
    while ( (v6 & -(1LL << v7)) != 0 );
  }
  else
  {
    v8 = v5 + 1;
  }
  if ( !dl_sysinfo_map )
  {
    v50 = 16 * v8;
    v103 = (__int64 *)((char *)&v115 - ((16 * v8) & 0xFFFFFFFFFFFFF000LL));
    if ( &v115 != v103 )
    {
      while ( v114 != (_BYTE *)v103 )
        ;
    }
LABEL_40:
    v52 = v50 & 0xFFF;
    if ( v52 )
    {
      v53 = alloca(v52);
      *(_QWORD *)&v114[v52 - 8] = *(_QWORD *)&v114[v52 - 8];
    }
    v28 = 0LL;
    v25 = (unsigned __int64 *)v114;
    v29 = 1LL;
    v36 = 0LL;
    v37 = 1LL;
    v38 = 0LL;
    if ( v6 )
      goto LABEL_31;
LABEL_43:
    v54 = v125;
    if ( !v125 )
      goto LABEL_85;
    goto LABEL_44;
  }
  v10 = *(unsigned __int16 *)(dl_sysinfo_map + 696);
  v11 = *(_QWORD *)(dl_sysinfo_map + 680);
  if ( !*(_WORD *)(dl_sysinfo_map + 696) )
  {
LABEL_38:
    v50 = 16 * v8;
    v51 = (__int64 *)((char *)&v115 - ((16 * v8) & 0xFFFFFFFFFFFFF000LL));
    if ( &v115 != v51 )
    {
      while ( v114 != (_BYTE *)v51 )
        ;
    }
    goto LABEL_40;
  }
  v128 = (_BYTE *)(v129[0] & dl_hwcap);
  v12 = 0LL;
  while ( 1 )
  {
    if ( *(_DWORD *)v11 != 4 )
      goto LABEL_9;
    v13 = *(_QWORD *)(v11 + 48);
    if ( v13 <= 3 )
      break;
    if ( ((v13 - 4) & 0xFFFFFFFFFFFFFFFBLL) == 0 )
      goto LABEL_13;
LABEL_9:
    ++v12;
    v11 += 56LL;
    if ( v12 == v10 )
    {
      v6 = (__int64)v128;
      goto LABEL_38;
    }
  }
  v13 = 4LL;
LABEL_13:
  v14 = *(_QWORD *)(v11 + 40);
  v15 = (unsigned int *)(*(_QWORD *)(v11 + 16) + *(_QWORD *)dl_sysinfo_map);
  v4 = 12LL - (_QWORD)v15;
  if ( v14 <= 0xC )
    goto LABEL_9;
  v16 = -(__int64)v13;
  while ( 1 )
  {
    v17 = *v15;
    v18 = v15[1];
    if ( v15[2] == 2 && (_DWORD)v17 == 4 && v15[3] == 5590599 && (unsigned int)v18 > 0xA )
      break;
    v15 = (unsigned int *)((char *)v15 + (v16 & (v13 - 1 + v18 + (v16 & (v13 + 11 + v17)))));
    if ( (unsigned __int64)v15 + v4 >= v14 )
      goto LABEL_9;
  }
  v19 = (__int64)v128;
  v20 = (unsigned int *)((char *)v15 + ((v13 + 15) & v16));
  v21 = v20 + 2;
  v8 += *v20;
  v22 = (__int64 *)((char *)&v115 - ((16 * v8) & 0xFFFFFFFFFFFFF000LL));
  if ( &v115 != v22 )
  {
    while ( v114 != (_BYTE *)v22 )
      ;
  }
  if ( ((16 * (_WORD)v8) & 0xFFF) != 0 )
  {
    v23 = alloca((16 * (_WORD)v8) & 0xFFF);
    *(_QWORD *)&v114[((16 * (_WORD)v8) & 0xFFF) - 8] = *(_QWORD *)&v114[((16 * (_WORD)v8) & 0xFFF) - 8];
  }
  v24 = v20[1];
  v25 = (unsigned __int64 *)v114;
  v120 = v19;
  v26 = v24;
  v128 = v114;
  dl_hwcap = (v24 << 52) | v127;
  v129[0] = v124 | (v24 << 52);
  _tunable_set_val(0x10u, v121);
  v27 = (unsigned __int64)v21 + v18 - 8;
  v28 = 0LL;
  v29 = 1LL;
  v6 = v120;
  if ( (unsigned __int64)v21 < v27 )
  {
    v124 = v120;
    v127 = v8;
    v121 = (unsigned __int64 *)v114;
    v30 = v21;
    v31 = v27;
    do
    {
      v32 = (char *)v30 + 1;
      v33 = j_strlen_ifunc((char *)v30 + 1);
      if ( (v26 & (1 << *(_BYTE *)v30)) != 0 )
      {
        v34 = v28;
        v29 = v28 + 2;
        ++v28;
        v35 = &v128[16 * v34];
        *v35 = v32;
        v35[1] = v33;
      }
      else
      {
        --v127;
        v29 = v28 + 1;
      }
      v30 = (unsigned int *)&v32[v33 + 1];
    }
    while ( (unsigned __int64)v30 < v31 );
    v6 = v124;
    v8 = v127;
    v25 = v121;
  }
  v36 = 0LL;
  v37 = v28 + 1;
  v38 = v28;
  if ( !v6 )
    goto LABEL_43;
LABEL_31:
  v124 = v8;
  v39 = (__int64)v25;
  v40 = v37;
  v41 = v28;
  v42 = v6;
  while ( 1 )
  {
    v43 = _bittest64(&v42, v36);
    v128 = (_BYTE *)v40;
    if ( v43 )
      break;
LABEL_35:
    ++v36;
  }
  while ( 1 )
  {
    v127 = v39;
    v44 = &dl_x86_hwcap_flags[9 * (int)v36];
    v45 = (char **)(v39 + 16 * v41);
    *v45 = v44;
    v46 = j_strlen_ifunc(v44);
    v47 = v36++;
    v39 = v127;
    v45[1] = (char *)v46;
    v48 = v40;
    v49 = 1LL << v47;
    v29 = v41 + 2;
    if ( v49 == v42 )
      break;
    v42 ^= v49;
    v41 = v40++;
    v43 = _bittest64(&v42, v36);
    v128 = (_BYTE *)v40;
    if ( !v43 )
      goto LABEL_35;
  }
  v25 = (unsigned __int64 *)v39;
  v54 = v125;
  v8 = v124;
  v38 = v48;
  if ( v125 )
  {
LABEL_44:
    v55 = (_QWORD *)(v29 + 1);
    v4 = 16 * v38;
    v56 = (__int64 *)&v25[2 * v38];
    *v56 = v54;
    v56[1] = (__int64)v123;
    goto LABEL_45;
  }
LABEL_85:
  v55 = (_QWORD *)v29;
  v29 = v38;
LABEL_45:
  v57 = 2 * v29;
  v58 = &v25[v57];
  *v58 = (unsigned __int64)"tls";
  v58[1] = 3LL;
  if ( (_QWORD *)v8 != v55 )
    _assert_fail((__int64)"m == cnt", (__int64)"dl-hwcaps.c", 0xB8u, "_dl_important_hwcaps");
  v59 = v25[1];
  v128 = (_BYTE *)v59;
  if ( v8 == 1 )
  {
    v104 = v59 + 1;
    *v126 = 2LL;
    v105 = malloc(v59 + 33, (__int64)"tls", v55, v57 * 8, (u32 *)v6, v4);
    v71 = v105;
    if ( !v105 )
      goto LABEL_88;
    v109 = (__int64)v128;
    v110 = *v25;
    v105[1] = v104;
    *v105 = v105 + 4;
    v105[2] = v105 + 4;
    v105[3] = 0LL;
    v111 = (_BYTE *)j_mempcpy(v105 + 4, v110, v109);
    v112 = v122;
    *v111 = 47;
    *v126 = 2LL;
    *v112 = v71[1];
  }
  else
  {
    v123 = &v25[2 * v8];
    v127 = *(v123 - 1);
    v60 = (__int64)&v128[v127 + 2];
    if ( v8 > 2 )
    {
      v61 = 2 * v60;
      v62 = 0LL;
      do
      {
        v63 = v62++;
        v61 += v25[2 * v63 + 3] + 1;
      }
      while ( v8 - 2 != v62 );
      if ( v8 == 3 )
      {
        v64 = 3;
        goto LABEL_53;
      }
      if ( v8 <= 0x3F )
      {
        v64 = v8;
        if ( !((unsigned __int64)(v61 + 128) >> (67 - (unsigned __int8)v8)) )
        {
LABEL_53:
          v60 = v61 << ((unsigned __int8)v64 - 3);
          goto LABEL_54;
        }
      }
      goto LABEL_88;
    }
    v64 = v8;
LABEL_54:
    v65 = v64;
    LODWORD(v125) = v64;
    v66 = 1 << v64;
    v67 = 1 << v64;
    v118 = v66;
    v119 = v67;
    *v126 = v67;
    v68 = 2 * v67;
    v69 = malloc(v60 + 16 * v67, v67, (_QWORD *)1, v65, (u32 *)v6, v4);
    v70 = v125;
    v71 = v69;
    if ( !v69 )
LABEL_88:
      dl_signal_error(12, 0LL, 0LL, "cannot create capability list");
    v72 = &v69[v68];
    LODWORD(v121) = v125 - 1;
    v73 = (__int64 *)*v25;
    *v71 = &v71[v68];
    v126 = v73;
    v71[2] = &v71[v68];
    LODWORD(v124) = 1 << (v70 - 1);
    v120 = 1LL << v70;
    if ( v8 == 2 )
    {
      v106 = (_BYTE *)j_mempcpy(v72, v25[2], v25[3]);
      v107 = (__int64)v128;
      v108 = v126;
      *v106 = 47;
      *(_BYTE *)j_mempcpy(v106 + 1, v108, v107) = 47;
    }
    else
    {
      v116 = v71;
      v117 = v8;
      v125 = *(v123 - 2);
      v74 = v8 - 2;
      v75 = (int)v124;
      v76 = v74;
      do
      {
        v75 -= 2LL;
        v77 = v76;
        v78 = (_BYTE *)j_mempcpy(v72, v125, v127);
        *v78 = 47;
        v79 = v78 + 1;
        do
        {
          while ( (v75 & (1 << v77)) == 0 )
          {
            if ( !--v77 )
              goto LABEL_61;
          }
          v80 = (_BYTE *)j_mempcpy(v79, v25[2 * v77], v25[2 * v77 + 1]);
          *v80 = 47;
          v79 = v80 + 1;
          --v77;
        }
        while ( v77 );
LABEL_61:
        v81 = (_BYTE *)j_mempcpy(v79, v126, v128);
        *v81 = 47;
        v72 = v81 + 1;
      }
      while ( v75 );
      v8 = v117;
      v71 = v116;
    }
    v82 = v120;
    v83 = 0LL;
    do
    {
      v84 = v83++;
      v71[2 * v84 + 1] = 0LL;
    }
    while ( v83 < v82 );
    v85 = (__int64)v123;
    v86 = v119;
    v87 = v8;
    do
    {
      --v87;
      v88 = v71;
      v89 = v86;
      v90 = 1 << v87;
      while ( v89 )
      {
        --v89;
        for ( v88 += 2; (v89 & v90) != 0; *(v88 - 3) = v91 + *(_QWORD *)(v85 - 8) + 1 )
        {
          v91 = *(v88 - 1);
          --v89;
          v88 += 2;
        }
      }
      v85 -= 16LL;
    }
    while ( v87 );
    v92 = v71 + 4;
    v93 = 1LL << (char)v121;
    v94 = v118 - 2;
    if ( v94 != 1LL << (char)v121 )
    {
      v95 = v71 + 4;
      v96 = v118 - 2;
      do
      {
        while ( (--v96 & 1) != 0 )
        {
          v97 = *(v95 - 4) + *(v95 - 3);
          v95 += 2;
          *(v95 - 2) = v97;
          if ( v96 == v93 )
            goto LABEL_76;
        }
        v98 = *(v95 - 2);
        v95 += 2;
        *(v95 - 2) = v98;
      }
      while ( v96 != v93 );
LABEL_76:
      v92 += 2 * (v94 - v93);
    }
    v99 = v127 + 1;
    v100 = 2LL * -(int)v124;
    do
    {
      v101 = v92[v100];
      v92 += 2;
      *(v92 - 2) = v99 + v101;
      --v93;
    }
    while ( v93 );
    *v122 = v71[1];
  }
  return v71;
}
// 46CE4B: variable 'v6' is possibly undefined
// 46CE4B: variable 'v4' is possibly undefined
// 4010B0: using guessed type __int64 __fastcall j_mempcpy(_QWORD, _QWORD, _QWORD);
// 4010C8: using guessed type __int64 __fastcall j_strlen_ifunc(_QWORD);
// 4AADE8: using guessed type __int64 dl_hwcap;
// 4AB8C0: using guessed type __int64 dl_sysinfo_map;

//----- (000000000046D1E0) ----------------------------------------------------
signed __int64 __fastcall dl_debug_vdprintf(int a1, int a2, _BYTE *a3, __int64 a4)
{
  int v6; // er12
  _BYTE *v7; // rbx
  char v8; // al
  _BYTE *v9; // rdx
  __int64 v11; // rax
  char v12; // al
  _BYTE *v13; // rcx
  char v14; // r10
  int v15; // er9
  int v16; // edx
  char v17; // al
  _BYTE *v18; // rbx
  __int64 v19; // rax
  unsigned int v20; // eax
  unsigned __int64 *v21; // rdx
  unsigned __int64 v22; // rdi
  unsigned int v23; // edx
  _BYTE *v24; // rax
  __int64 v25; // r11
  int v26; // er9
  signed __int64 v27; // rdx
  __int64 v28; // rcx
  unsigned int v29; // eax
  unsigned int *v30; // rdx
  unsigned int v31; // eax
  int *v32; // rdx
  unsigned int v33; // eax
  void **v34; // rcx
  void *v35; // rdi
  unsigned __int64 v36; // rax
  size_t v37; // rdx
  char *v38; // rax
  char v39; // r10
  __int64 v40; // rcx
  __int64 v41; // rcx
  unsigned int v42; // eax
  int *v43; // rdx
  __int64 v44[512]; // [rsp+Ah] [rbp-1478h] BYREF
  _DWORD fd[3]; // [rsp+1016h] [rbp-46Ch]
  __int64 v46; // [rsp+1022h] [rbp-460h]
  __int64 *v47; // [rsp+102Ah] [rbp-458h]
  __int64 v48; // [rsp+1032h] [rbp-450h]
  int v49; // [rsp+103Ah] [rbp-448h]
  int v50; // [rsp+103Eh] [rbp-444h]
  char v51[10]; // [rsp+1046h] [rbp-43Ch] BYREF
  __int16 v52; // [rsp+1050h] [rbp-432h] BYREF
  iovec vec[67]; // [rsp+1052h] [rbp-430h] BYREF

  v6 = 0;
  v7 = a3;
  *(_QWORD *)&fd[1] = &v52;
  v8 = *a3;
  fd[0] = a1;
  v50 = 0;
  if ( v8 )
  {
    while ( a2 == 1 )
    {
      while ( 1 )
      {
        if ( !v50 )
        {
          v48 = a4;
          v50 = getpid();
          if ( v50 < 0 )
            _assert_fail((__int64)"pid >= 0 && sizeof (pid_t) <= 4", (__int64)"dl-misc.c", 0x62u, "_dl_debug_vdprintf");
          v38 = (char *)itoa_word(v50, *(__int64 *)&fd[1], 0xAu, 0);
          a4 = v48;
          if ( v38 > v51 )
          {
            do
              *--v38 = 32;
            while ( v38 != v51 );
          }
          v52 = 2362;
        }
        if ( v6 > 63 )
          _assert_fail((__int64)"niov < NIOVMAX", (__int64)"dl-misc.c", 0x6Bu, "_dl_debug_vdprintf");
        v11 = v6;
        a2 = -1;
        ++v6;
        v11 *= 16LL;
        *(size_t *)((char *)&vec[0].iov_len + v11) = 12LL;
        *(void **)((char *)&vec[0].iov_base + v11) = v51;
        v8 = *v7;
        if ( *v7 != 37 )
          goto LABEL_4;
LABEL_25:
        if ( v6 > 63 )
          goto LABEL_94;
        v9 = v7;
        vec[v6].iov_len = 0LL;
        if ( v8 == 37 )
          goto LABEL_27;
LABEL_16:
        if ( v8 != 10 )
          break;
        if ( v7 == v9 )
        {
          v40 = v6;
LABEL_85:
          v41 = v40;
          ++v6;
          vec[v41].iov_base = v7;
          vec[v41].iov_len = 1LL;
          goto LABEL_21;
        }
        ++vec[v6 - 1].iov_len;
LABEL_21:
        v7 = v9 + 1;
        if ( !v9[1] )
          return sys_writev(fd[0], vec, v6);
      }
LABEL_17:
      v7 = v9;
      v8 = *v9;
      if ( !*v9 )
        return sys_writev(fd[0], vec, v6);
    }
    if ( v8 == 37 )
      goto LABEL_25;
LABEL_4:
    if ( !v8 )
      goto LABEL_25;
    if ( v8 == 10 && a2 )
    {
      if ( v6 > 63 )
        goto LABEL_94;
      v40 = v6;
      v9 = v7;
      vec[v6].iov_len = 0LL;
      goto LABEL_85;
    }
    v9 = v7;
    do
      v8 = *++v9;
    while ( *v9 && v8 != 37 && (v8 != 10 || !a2) );
    if ( v6 > 63 )
LABEL_94:
      _assert_fail((__int64)"niov < NIOVMAX", (__int64)"dl-misc.c", 0x78u, "_dl_debug_vdprintf");
    vec[v6].iov_len = v9 - v7;
    if ( v9 != v7 )
      vec[v6++].iov_base = v7;
    if ( v8 != 37 )
      goto LABEL_16;
LABEL_27:
    v12 = v9[1];
    if ( v12 == 48 )
    {
      v13 = v9 + 2;
      v14 = 48;
      v12 = v9[2];
    }
    else
    {
      v13 = v9 + 1;
      v14 = 32;
    }
    v15 = -1;
    if ( v12 == 42 )
    {
      v31 = *(_DWORD *)a4;
      if ( *(_DWORD *)a4 > 0x2Fu )
      {
        v32 = *(int **)(a4 + 8);
        *(_QWORD *)(a4 + 8) = v32 + 2;
      }
      else
      {
        v32 = (int *)(*(_QWORD *)(a4 + 16) + v31);
        *(_DWORD *)a4 = v31 + 8;
      }
      v12 = v13[1];
      v15 = *v32;
      ++v13;
    }
    v16 = -1;
    if ( v12 == 46 )
    {
      if ( v13[1] != 42 )
LABEL_62:
        _assert_fail((__int64)"! \"invalid format specifier\"", (__int64)"dl-misc.c", 0xD8u, "_dl_debug_vdprintf");
      v42 = *(_DWORD *)a4;
      if ( *(_DWORD *)a4 > 0x2Fu )
      {
        v43 = *(int **)(a4 + 8);
        *(_QWORD *)(a4 + 8) = v43 + 2;
      }
      else
      {
        v43 = (int *)(*(_QWORD *)(a4 + 16) + v42);
        *(_DWORD *)a4 = v42 + 8;
      }
      v12 = v13[2];
      v16 = *v43;
      v13 += 2;
    }
    if ( v12 == 108 || v12 == 90 )
    {
      v17 = v13[1];
      v18 = v13 + 1;
      if ( v17 != 115 )
      {
        if ( v17 <= 115 )
        {
          if ( v17 != 37 )
            goto LABEL_62;
LABEL_36:
          v19 = v6;
          vec[v19].iov_base = v18;
          vec[v19].iov_len = 1LL;
LABEL_37:
          ++v6;
LABEL_38:
          v9 = v18 + 1;
          goto LABEL_17;
        }
        if ( v17 == 117 )
        {
          v20 = *(_DWORD *)a4;
          if ( *(_DWORD *)a4 <= 0x2Fu )
          {
LABEL_45:
            v21 = (unsigned __int64 *)(*(_QWORD *)(a4 + 16) + v20);
            *(_DWORD *)a4 = v20 + 8;
LABEL_46:
            v22 = *v21;
LABEL_47:
            LOBYTE(v48) = v14;
            v49 = v15;
            v46 = a4;
            v23 = 16;
            if ( *v18 != 120 )
              v23 = 10;
            v47 = v44;
            v24 = (_BYTE *)itoa_word(v22, (__int64)v44, v23, 0);
            v25 = (__int64)v47;
            v26 = v49;
            a4 = v46;
            v27 = (char *)v47 - v24;
            if ( v49 != -1 && v49 > v27 )
            {
              v39 = v48;
              do
              {
                *--v24 = v39;
                v27 = v25 - (_QWORD)v24;
              }
              while ( v26 > v25 - (__int64)v24 );
            }
            v28 = v6++;
            v28 *= 16LL;
            *(void **)((char *)&vec[0].iov_base + v28) = v24;
            *(size_t *)((char *)&vec[0].iov_len + v28) = v27;
            goto LABEL_38;
          }
        }
        else
        {
          if ( v17 != 120 )
            goto LABEL_62;
          v20 = *(_DWORD *)a4;
          if ( *(_DWORD *)a4 <= 0x2Fu )
            goto LABEL_45;
        }
        v21 = *(unsigned __int64 **)(a4 + 8);
        *(_QWORD *)(a4 + 8) = v21 + 1;
        goto LABEL_46;
      }
LABEL_68:
      v33 = *(_DWORD *)a4;
      if ( *(_DWORD *)a4 > 0x2Fu )
      {
        v34 = *(void ***)(a4 + 8);
        *(_QWORD *)(a4 + 8) = v34 + 1;
      }
      else
      {
        v34 = (void **)(*(_QWORD *)(a4 + 16) + v33);
        *(_DWORD *)a4 = v33 + 8;
      }
      v35 = *v34;
      v46 = a4;
      LODWORD(v47) = v16;
      vec[v6].iov_base = v35;
      v48 = 16LL * v6;
      v36 = j_strlen_ifunc(v35);
      v37 = (int)v47;
      a4 = v46;
      if ( (_DWORD)v47 == -1 )
      {
        *(size_t *)((char *)&vec[0].iov_len + v48) = v36;
      }
      else
      {
        if ( (int)v47 > v36 )
          v37 = v36;
        *(size_t *)((char *)&vec[0].iov_len + v48) = v37;
      }
      goto LABEL_37;
    }
    if ( v12 == 115 )
    {
      v18 = v13;
      goto LABEL_68;
    }
    if ( v12 <= 115 )
    {
      if ( v12 != 37 )
        goto LABEL_62;
      v18 = v13;
      goto LABEL_36;
    }
    if ( v12 == 117 )
    {
      v29 = *(_DWORD *)a4;
      if ( *(_DWORD *)a4 <= 0x2Fu )
      {
LABEL_56:
        v30 = (unsigned int *)(*(_QWORD *)(a4 + 16) + v29);
        *(_DWORD *)a4 = v29 + 8;
LABEL_57:
        v22 = *v30;
        v18 = v13;
        goto LABEL_47;
      }
    }
    else
    {
      if ( v12 != 120 )
        goto LABEL_62;
      v29 = *(_DWORD *)a4;
      if ( *(_DWORD *)a4 <= 0x2Fu )
        goto LABEL_56;
    }
    v30 = *(unsigned int **)(a4 + 8);
    *(_QWORD *)(a4 + 8) = v30 + 2;
    goto LABEL_57;
  }
  return sys_writev(fd[0], vec, v6);
}
// 4010C8: using guessed type __int64 __fastcall j_strlen_ifunc(_QWORD);
// 46D1E0: using guessed type struct iovec vec[67];

//----- (000000000046D7E0) ----------------------------------------------------
unsigned __int64 __fastcall dl_sysdep_read_whole_file(const char *a1, __off_t *a2, unsigned int a3)
{
  unsigned __int64 v5; // rbp
  signed int v6; // eax
  unsigned int v8; // ebx
  unsigned __int64 st_size; // rsi
  struct stat v10; // [rsp+0h] [rbp-B8h] BYREF

  v5 = -1LL;
  v6 = _open_nocancel(a1, 0x80000, a3);
  if ( v6 >= 0 )
  {
    v8 = v6;
    if ( (fxstat(1u, v6, &v10) & 0x80000000) == 0LL && (st_size = v10.st_size, *a2 = v10.st_size, st_size) )
      v5 = mmap64(0LL, st_size, a3, 2uLL, v8, 0LL);
    else
      v5 = -1LL;
    _close_nocancel(v8);
  }
  return v5;
}

//----- (000000000046D880) ----------------------------------------------------
signed __int64 dl_debug_printf(_BYTE *a1, ...)
{
  __va_list_tag va[1]; // [rsp+8h] [rbp-D0h] BYREF

  va_start(va, a1);
  return dl_debug_vdprintf(dl_debug_fd, 1, a1, (__int64)va);
}
// 4A91F4: using guessed type int dl_debug_fd;

//----- (000000000046D930) ----------------------------------------------------
signed __int64 dl_debug_printf_c(_BYTE *a1, ...)
{
  __va_list_tag va[1]; // [rsp+8h] [rbp-D0h] BYREF

  va_start(va, a1);
  return dl_debug_vdprintf(dl_debug_fd, -1, a1, (__int64)va);
}
// 4A91F4: using guessed type int dl_debug_fd;

//----- (000000000046D9E0) ----------------------------------------------------
signed __int64 dl_dprintf(int a1, _BYTE *a2, ...)
{
  __va_list_tag va[1]; // [rsp+8h] [rbp-D0h] BYREF

  va_start(va, a2);
  return dl_debug_vdprintf(a1, 0, a2, (__int64)va);
}

//----- (000000000046DA80) ----------------------------------------------------
__int64 __fastcall dl_name_match_p(__int64 a1, __int64 a2)
{
  _QWORD *v2; // rbx

  if ( !(unsigned int)j_strcmp_ifunc(a1, *(_QWORD *)(a2 + 8)) )
    return 1LL;
  v2 = *(_QWORD **)(a2 + 56);
  if ( v2 )
  {
    while ( (unsigned int)j_strcmp_ifunc(a1, *v2) )
    {
      v2 = (_QWORD *)v2[1];
      if ( !v2 )
        return 0LL;
    }
    return 1LL;
  }
  return 0LL;
}
// 4010A0: using guessed type __int64 __fastcall j_strcmp_ifunc(_QWORD, _QWORD);

//----- (000000000046DAF0) ----------------------------------------------------
__int64 __fastcall dl_higher_prime_number(unsigned __int64 a1)
{
  const char *v1; // rcx
  char *v2; // r8
  __int64 v3; // rdx
  char *v4; // rsi
  const char *v6; // rax

  v1 = "\a";
  v2 = &primes_10644[120];
  do
  {
    v3 = (v2 - v1) >> 2;
    v4 = (char *)&v1[4 * ((__int64)(v3 + ((unsigned __int64)(v2 - v1) >> 63)) >> 1)];
    if ( a1 <= *(unsigned int *)v4 )
    {
      while ( 1 )
      {
        if ( v1 == v4 )
          return *(unsigned int *)v4;
        v6 = &v1[4 * ((__int64)(((v4 - v1) >> 2) + ((unsigned __int64)(v4 - v1) >> 63)) >> 1)];
        if ( *(unsigned int *)v6 < a1 )
          break;
        v4 = (char *)&v1[4 * ((__int64)(((v4 - v1) >> 2) + ((unsigned __int64)(v4 - v1) >> 63)) >> 1)];
      }
      v2 = v4;
    }
    else
    {
      v6 = &v1[4 * ((__int64)(v3 + ((unsigned __int64)(v2 - v1) >> 63)) >> 1)];
    }
    v1 = v6 + 4;
  }
  while ( v6 + 4 != v2 );
  return *(unsigned int *)v2;
}

//----- (000000000046DB70) ----------------------------------------------------
__int64 __fastcall dl_strtoul(char *a1, char **a2)
{
  char v2; // al
  char v3; // bl
  char *v4; // rdi
  char v5; // al
  int v6; // er10
  int v7; // er11
  unsigned __int64 v8; // r8
  unsigned int v9; // er11
  int v10; // ecx
  __int64 result; // rax

  v2 = *a1;
  if ( *a1 != 32 )
    goto LABEL_3;
  do
  {
    do
      v2 = *++a1;
    while ( *a1 == 32 );
LABEL_3:
    ;
  }
  while ( v2 == 9 );
  if ( v2 == 45 )
  {
    v4 = a1 + 1;
    v3 = 0;
  }
  else
  {
    v3 = 1;
    v4 = &a1[v2 == 43];
  }
  v5 = *v4;
  if ( (unsigned __int8)(*v4 - 48) <= 9u )
  {
    v6 = 10;
    v7 = 9;
    if ( v5 == 48 )
    {
      if ( (v4[1] & 0xDF) == 88 )
      {
        v5 = v4[2];
        v6 = 16;
        v4 += 2;
      }
      else
      {
        v6 = 8;
        v7 = 7;
      }
    }
    v8 = 0LL;
    v9 = v7 + 48;
    while ( 1 )
    {
      if ( v5 <= 47 || v5 > v9 )
      {
        if ( v6 != 16 )
          goto LABEL_21;
        if ( (unsigned __int8)(v5 - 97) > 5u )
        {
          if ( (unsigned __int8)(v5 - 65) > 5u )
          {
LABEL_21:
            if ( a2 )
              *a2 = v4;
            if ( !v3 )
              return -(__int64)v8;
            return v8;
          }
          v10 = v5 - 55;
        }
        else
        {
          v10 = v5 - 87;
        }
      }
      else
      {
        v10 = v5 - 48;
      }
      if ( ~(__int64)v10 / (unsigned __int64)v6 <= v8 )
        break;
      v5 = *++v4;
      v8 = v10 + v6 * v8;
    }
    v8 = -1LL;
    if ( a2 )
      goto LABEL_27;
    return v8;
  }
  v8 = 0LL;
  if ( !a2 )
    return v8;
LABEL_27:
  result = v8;
  *a2 = v4;
  return result;
}

//----- (000000000046DCD0) ----------------------------------------------------
unsigned __int64 dl_start_profile()
{
  _QWORD *v0; // rax
  _QWORD *v1; // rdi
  unsigned __int64 v2; // rsi
  unsigned __int64 v3; // rcx
  __int64 v4; // r11
  __int64 v5; // rdi
  __int64 v6; // r8
  __int64 v7; // rax
  unsigned __int64 v8; // r12
  unsigned __int64 v9; // rbx
  unsigned __int64 v10; // rdx
  __int32 v11; // eax
  unsigned __int64 v12; // rdx
  __int64 *v13; // rsi
  __int16 v14; // dx
  unsigned int v15; // edx
  _BYTE *v16; // rax
  unsigned int v17; // eax
  unsigned int v18; // er14
  unsigned __int64 v19; // r13
  __int64 v20; // rcx
  __int64 v21; // r9
  char *v22; // rdx
  const char *v23; // r14
  char *v24; // r8
  int v25; // eax
  __m128i v26; // xmm0
  __m128i v27; // xmm1
  __m128i v28; // xmm2
  __int64 v29; // rax
  u32 *v30; // rax
  __int64 v31; // rdx
  unsigned int v32; // ecx
  char *v33; // r9
  const char *v34; // rcx
  const char *v35; // r8
  unsigned int v36; // esi
  __int64 v37; // rdi
  __int16 *v38; // rdi
  __int16 v39; // r10
  char *v40; // rdx
  unsigned __int64 v41; // rcx
  unsigned __int64 v42; // r12
  unsigned __int64 result; // rax
  char *v44; // rbx
  int v45; // er12
  unsigned __int8 *v46; // rax
  void *v47; // rsp
  __int64 v48; // rcx
  char *v49; // rax
  void *v50; // rsp
  signed __int64 v51; // rax
  _BYTE v53[4096]; // [rsp+8h] [rbp-22D0h] BYREF
  __int64 v54; // [rsp+1008h] [rbp-12D0h] BYREF
  char v55[7]; // [rsp+1010h] [rbp-12C8h] BYREF
  __int64 v56[2]; // [rsp+2008h] [rbp-2D0h] BYREF
  char *v57; // [rsp+2018h] [rbp-2C0h]
  __int64 v58; // [rsp+2020h] [rbp-2B8h]
  unsigned __int64 v59; // [rsp+2028h] [rbp-2B0h]
  unsigned __int64 v60; // [rsp+2030h] [rbp-2A8h]
  __m128i v61; // [rsp+2038h] [rbp-2A0h] BYREF
  int v62; // [rsp+2048h] [rbp-290h]
  __m128i v63; // [rsp+2058h] [rbp-280h] BYREF
  __m128i v64; // [rsp+2068h] [rbp-270h] BYREF
  __int64 v65; // [rsp+2078h] [rbp-260h]
  struct stat v66; // [rsp+2088h] [rbp-250h] BYREF
  char v67[448]; // [rsp+2118h] [rbp-1C0h] BYREF

  v0 = *(_QWORD **)(dl_profile_map + 680);
  v1 = &v0[7 * *(unsigned __int16 *)(dl_profile_map + 696)];
  if ( v0 >= v1 )
  {
    v5 = -1LL;
    v6 = 0LL;
    v2 = 0LL;
    v3 = -1LL;
  }
  else
  {
    v2 = 0LL;
    v3 = -1LL;
    v4 = -dl_pagesize;
    do
    {
      if ( (*v0 & 0x1FFFFFFFFLL) == 0x100000001LL )
      {
        if ( v3 > ((unsigned __int64)v4 & v0[2]) )
          v3 = v4 & v0[2];
        if ( v2 < (v4 & (unsigned __int64)(dl_pagesize - 1 + v0[5] + v0[2])) )
          v2 = v4 & (dl_pagesize - 1 + v0[5] + v0[2]);
      }
      v0 += 7;
    }
    while ( v0 < v1 );
    v5 = v3;
    v6 = v2;
  }
  running = 0;
  v7 = *(_QWORD *)dl_profile_map;
  log_hashfraction = 5;
  v8 = (v7 + v2 + 3) & 0xFFFFFFFFFFFFFFFCLL;
  lowpc = (v7 + v3) & 0xFFFFFFFFFFFFFFFCLL;
  v9 = v8 - lowpc;
  textsize = v8 - lowpc;
  v10 = 3 * (v8 - lowpc) / 0x64;
  if ( (unsigned int)v10 > 0x31 )
  {
    if ( (unsigned int)v10 <= 0x100000 )
    {
      fromlimit = 3 * (v8 - lowpc) / 0x64;
      v58 = 16LL * (unsigned int)v10;
      v59 = 320LL * (unsigned int)v10 + 72;
    }
    else
    {
      fromlimit = 0x100000;
      v58 = 0x1000000LL;
      v59 = 335544392LL;
    }
  }
  else
  {
    fromlimit = 50;
    v58 = 800LL;
    v59 = 16072LL;
  }
  v63.m128i_i64[1] = v6;
  v63.m128i_i64[0] = v5;
  v61 = (__m128i)0x1FFFF6E6F6D67uLL;
  v62 = 0;
  v64.m128i_i32[0] = v9 >> 2;
  v11 = _profile_frequency();
  v65 = 0x7300000000000000LL;
  v64.m128i_i32[1] = v11;
  v64.m128i_i64[1] = 0x73646E6F636573LL;
  v60 = j_strlen_ifunc(dl_profile_output);
  v12 = v60 + j_strlen_ifunc(dl_profile) + 33;
  v13 = (__int64 *)((char *)v56 - (v12 & 0xFFFFFFFFFFFFF000LL));
  v14 = v12 & 0xFFF0;
  if ( v56 != v13 )
  {
    while ( &v54 != v13 )
      ;
  }
  v15 = v14 & 0xFFF;
  if ( v15 )
  {
    v47 = alloca(v15);
    *(_QWORD *)&v53[v15 + 4088] = *(_QWORD *)&v53[v15 + 4088];
  }
  v57 = v55;
  v16 = (_BYTE *)j_stpcpy(v55);
  *v16 = 47;
  strcpy((char *)j_stpcpy(v16 + 1), ".profile");
  v17 = _open_nocancel(v55, 131138, 438);
  v18 = v17;
  if ( v17 == -1 )
  {
    v44 = "%s: cannot open file: %s\n";
    v45 = __readfsdword(0xFFFFFFC0);
LABEL_38:
    v46 = strerror_r(v45, (__int64)v67, 0x190uLL);
    return dl_dprintf(2, v44, v57, v46);
  }
  if ( (fxstat(1u, v17, &v66) & 0x80000000) != 0LL || (v66.st_mode & 0xF000) != 0x8000 )
  {
    v44 = "%s: cannot stat file: %s\n";
    goto LABEL_40;
  }
  v60 = v9 >> 1;
  v19 = (v9 >> 1) + v59;
  if ( !v66.st_size )
  {
    v48 = dl_pagesize;
    v56[1] = (__int64)&v54;
    v49 = &v55[-((dl_pagesize + 15) & 0xFFFFFFFFFFFFF000LL) - 8];
    if ( &v54 != (__int64 *)v49 )
    {
      while ( v53 != v49 )
        ;
    }
    if ( (((_WORD)dl_pagesize + 15) & 0xFF0) != 0 )
    {
      v50 = alloca(((_WORD)dl_pagesize + 15) & 0xFF0);
      *(_QWORD *)&v53[(((_WORD)dl_pagesize + 15) & 0xFF0) - 8] = *(_QWORD *)&v53[(((_WORD)dl_pagesize + 15) & 0xFF0) - 8];
    }
    v56[0] = v48;
    v59 = (unsigned __int64)v53;
    j_memset_ifunc(v53, 0LL, v48);
    if ( lseek64(v18, v19 & -v56[0], 0) != -1LL )
    {
      while ( 1 )
      {
        v51 = _write_nocancel(v18, (const char *)v59, v19 & (dl_pagesize - 1));
        if ( v51 != -1 )
          break;
        if ( __readfsdword(0xFFFFFFC0) != 4 )
          goto LABEL_63;
      }
      if ( v51 >= 0 )
        goto LABEL_21;
    }
LABEL_63:
    v44 = "%s: cannot create file: %s\n";
LABEL_40:
    v45 = __readfsdword(0xFFFFFFC0);
    _close_nocancel(v18);
    goto LABEL_38;
  }
  if ( v66.st_size != v19 )
  {
    _close_nocancel(v18);
    return dl_dprintf(2, "%s: file is no correct profile data file for `%s'\n", v57, (const char *)dl_profile);
  }
LABEL_21:
  v59 = mmap64(0LL, v19, 3uLL, 1uLL, v18, 0LL);
  if ( v59 == -1LL )
  {
    v44 = "%s: cannot map file: %s\n";
    goto LABEL_40;
  }
  _close_nocancel(v18);
  v22 = (char *)v59;
  v23 = (const char *)(v59 + 64);
  v24 = (char *)(v59 + 64 + v60 + 4);
  narcsp = (__int64)v24;
  data = v59 + 64 + v60 + 8;
  if ( v66.st_size )
  {
    if ( *(_OWORD *)&v61 == *(_OWORD *)v59
      && *(_DWORD *)(v59 + 16) == v62
      && !*(_DWORD *)(v59 + 20)
      && *(_OWORD *)&v63 == *(_OWORD *)(v59 + 24) )
    {
      v20 = v64.m128i_i64[0] ^ *(_QWORD *)(v59 + 40) | v64.m128i_i64[1] ^ *(_QWORD *)(v59 + 48);
      if ( *(_OWORD *)&v64 == *(_OWORD *)(v59 + 40) && *(_QWORD *)(v59 + 56) == v65 && *(_DWORD *)(v59 + 64 + v60) == 1 )
        goto LABEL_24;
    }
    munmap(v59, v19);
    return dl_dprintf(2, "%s: file is no correct profile data file for `%s'\n", v57, (const char *)dl_profile);
  }
  v25 = v62;
  v26 = _mm_load_si128(&v61);
  *(_DWORD *)(v59 + 20) = 0;
  v27 = _mm_load_si128(&v63);
  v28 = _mm_load_si128(&v64);
  *((_DWORD *)v22 + 4) = v25;
  v29 = v65;
  *(__m128i *)v22 = v26;
  *(__m128i *)(v22 + 24) = v27;
  *(__m128i *)(v22 + 40) = v28;
  *((_QWORD *)v22 + 7) = v29;
  *((_DWORD *)v24 - 1) = 1;
LABEL_24:
  v57 = v22;
  v59 = (unsigned __int64)v24;
  v30 = calloc(v60 + v58, 1uLL, (__int64)v22, v20, (u32 *)v24, v21);
  tos = (__int64)v30;
  if ( !v30 )
  {
    munmap((unsigned __int64)v57, v19);
    dl_dprintf(2, "Out of memory while initializing profiler\n");
    exit(127);
  }
  v31 = (unsigned int)fromlimit;
  fromidx = 0;
  v32 = *(_DWORD *)v59;
  v33 = (char *)v30 + v60;
  froms = (__int64)v30 + v60;
  if ( v32 < fromlimit )
    v31 = *(unsigned int *)v59;
  narcs = v31;
  if ( v31 )
  {
    v34 = (const char *)(v59 + 20 * v31 - 16);
    v35 = (const char *)(v59 - 16);
    do
    {
      v36 = fromidx;
      v37 = *((_QWORD *)v34 + 1) >> 2;
      ++fromidx;
      v38 = (__int16 *)v30 + v37;
      v39 = *v38;
      v40 = &v33[16 * v36];
      *(_QWORD *)v40 = v34;
      v34 -= 20;
      *((_WORD *)v40 + 4) = v39;
      *v38 = v36;
    }
    while ( v35 != v34 );
  }
  LODWORD(v41) = 0x10000;
  v42 = v8 - lowpc;
  if ( v42 > v60 )
  {
    LODWORD(v41) = 1;
    if ( v42 / v60 <= 0xFFFF )
    {
      if ( v42 / v60 <= 0xFF )
      {
        if ( v42 <= 0xFFFFFFFFFFFFFFLL )
          v41 = 0x1000000 / ((v42 << 8) / v60);
        else
          v41 = 0x1000000 / (v42 / (v9 >> 9));
      }
      else
      {
        v41 = 0x10000 / (v42 / v60);
      }
    }
  }
  result = profil((__int64)v23, v60, lowpc, v41);
  running = 1;
  return result;
}
// 46E085: variable 'v20' is possibly undefined
// 46E085: variable 'v21' is possibly undefined
// 401058: using guessed type __int64 __fastcall j_stpcpy(_QWORD);
// 401090: using guessed type __int64 __fastcall j_memset_ifunc(_QWORD, _QWORD, _QWORD);
// 4010C8: using guessed type __int64 __fastcall j_strlen_ifunc(_QWORD);
// 4A91F8: using guessed type __int64 dl_pagesize;
// 4AB018: using guessed type int log_hashfraction;
// 4AB020: using guessed type __int64 textsize;
// 4AB028: using guessed type __int64 lowpc;
// 4AB030: using guessed type int fromidx;
// 4AB034: using guessed type int fromlimit;
// 4AB038: using guessed type __int64 froms;
// 4AB040: using guessed type __int64 tos;
// 4AB048: using guessed type __int64 narcsp;
// 4AB050: using guessed type int narcs;
// 4AB054: using guessed type int running;
// 4AB058: using guessed type __int64 data;
// 4AB870: using guessed type __int64 dl_profile_output;
// 4AB890: using guessed type __int64 dl_profile;
// 4AB910: using guessed type __int64 dl_profile_map;
// 46DCD0: using guessed type char var_1C0[448];

//----- (000000000046E510) ----------------------------------------------------
void __fastcall dl_mcount(__int64 a1, __int64 a2)
{
  unsigned __int64 v2; // rdi
  unsigned __int64 v3; // rsi
  __int64 v4; // rcx
  _WORD *v5; // rdx
  __int64 v6; // rax
  __int64 v7; // rdx
  _QWORD *v8; // r8
  __int64 v9; // rax
  _DWORD *v10; // r11
  __int64 v11; // rax
  __int64 v12; // r9
  __int64 v13; // r10
  __int64 v14; // rbp
  int v15; // er8
  _WORD *v16; // rbp
  __int64 v17; // r8
  __int64 v18; // rax
  unsigned int v19; // ecx
  __int16 v20; // ax
  __int64 v21; // rax
  __int64 v22; // rdx

  if ( running )
  {
    v2 = a1 - lowpc;
    if ( textsize <= v2 )
      v2 = 0LL;
    v3 = a2 - lowpc;
    if ( textsize > v3 )
    {
      v4 = tos;
      v5 = (_WORD *)(tos + 2 * (v3 >> log_hashfraction));
      v6 = (unsigned __int16)*v5;
      if ( !*v5 )
        goto LABEL_10;
      while ( 1 )
      {
        v7 = froms + 16 * v6;
        v8 = *(_QWORD **)v7;
        if ( **(_QWORD **)v7 == v2 )
          goto LABEL_28;
        v9 = *(unsigned __int16 *)(v7 + 8);
        if ( (_WORD)v9 )
        {
          do
          {
            v7 = froms + 16 * v9;
            v9 = *(unsigned __int16 *)(v7 + 8);
            v8 = *(_QWORD **)v7;
          }
          while ( (_WORD)v9 && *v8 != v2 );
        }
        if ( *v8 == v2 )
          goto LABEL_28;
        v5 = (_WORD *)(v7 + 8);
LABEL_10:
        v10 = (_DWORD *)narcsp;
        v11 = (unsigned int)narcs;
        if ( *(_DWORD *)narcsp != narcs && fromlimit > (unsigned int)narcs )
        {
          v12 = froms;
          v13 = data;
          do
          {
            v14 = *(_QWORD *)(v13 + 20 * v11 + 8) >> 2;
            if ( __readfsdword(0x18u) )
              __asm { lock }
            v15 = fromidx++;
            v16 = (_WORD *)(v4 + 2 * v14);
            v17 = (unsigned int)(v15 + 1);
            v18 = v12 + 16 * v17;
            *(_QWORD *)v18 = v13 + 20LL * (unsigned int)narcs;
            *(_WORD *)(v18 + 8) = *v16;
            *v16 = v17;
            if ( __readfsdword(0x18u) )
              __asm { lock }
            v11 = (unsigned int)++narcs;
          }
          while ( *v10 != narcs && narcs < (unsigned int)fromlimit );
        }
        if ( !*v5 )
          break;
        v6 = (unsigned __int16)*v5;
      }
      if ( __readfsdword(0x18u) )
        __asm { lock }
      v19 = (*v10)++;
      if ( fromlimit > v19 )
      {
        if ( __readfsdword(0x18u) )
          __asm { lock }
        v20 = fromidx++;
        *v5 = v20 + 1;
        v21 = froms + 16LL * (unsigned __int16)*v5;
        v22 = data + 20LL * v19;
        *(_QWORD *)v21 = v22;
        *(_QWORD *)v22 = v2;
        *(_QWORD *)(v22 + 8) = v3;
        *(_DWORD *)(v22 + 16) = 0;
        *(_WORD *)(v21 + 8) = 0;
        if ( __readfsdword(0x18u) )
          __asm { lock }
        ++narcs;
        v8 = *(_QWORD **)v21;
LABEL_28:
        if ( __readfsdword(0x18u) )
          __asm { lock }
        ++*((_DWORD *)v8 + 4);
      }
    }
  }
}
// 4AB018: using guessed type int log_hashfraction;
// 4AB020: using guessed type __int64 textsize;
// 4AB028: using guessed type __int64 lowpc;
// 4AB030: using guessed type int fromidx;
// 4AB034: using guessed type int fromlimit;
// 4AB038: using guessed type __int64 froms;
// 4AB040: using guessed type __int64 tos;
// 4AB048: using guessed type __int64 narcsp;
// 4AB050: using guessed type int narcs;
// 4AB054: using guessed type int running;
// 4AB058: using guessed type __int64 data;

//----- (000000000046E760) ----------------------------------------------------
u32 *__fastcall allocate_dtv(__int64 a1, __int64 a2, __int64 a3, __int64 a4, u32 *a5, __int64 a6)
{
  __int64 v6; // rbp
  u32 *result; // rax

  v6 = dl_tls_max_dtv_idx + 14;
  result = calloc(dl_tls_max_dtv_idx + 16, 0x10uLL, a3, a4, a5, a6);
  if ( result )
  {
    *(_QWORD *)result = v6;
    *(_QWORD *)(a1 + 8) = result + 4;
    return (u32 *)a1;
  }
  return result;
}
// 4AB3D0: using guessed type __int64 dl_tls_max_dtv_idx;

//----- (000000000046E7A0) ----------------------------------------------------
void __noreturn oom()
{
  dl_dprintf(2, "cannot allocate memory for thread-local data: ABORT\n");
  exit(127);
}

//----- (000000000046E7D0) ----------------------------------------------------
unsigned __int64 dl_next_tls_modid()
{
  unsigned __int64 result; // rax
  unsigned __int64 *v1; // rcx
  __int64 v2; // rsi
  unsigned __int64 i; // rdi

  if ( dl_tls_dtv_gaps )
  {
    result = dl_tls_static_nelem + 1;
    if ( dl_tls_static_nelem + 1 > (unsigned __int64)dl_tls_max_dtv_idx )
      goto LABEL_12;
    v1 = (unsigned __int64 *)dl_tls_dtv_slotinfo_list;
    v2 = 0LL;
    for ( i = *(_QWORD *)dl_tls_dtv_slotinfo_list; ; i = *v1 )
    {
      while ( result - v2 < i )
      {
        if ( !v1[2 * (result - v2) + 3] )
          goto LABEL_11;
        if ( dl_tls_max_dtv_idx + 1 < ++result )
          _assert_fail(
            (__int64)"result <= GL(dl_tls_max_dtv_idx) + 1",
            (__int64)"../elf/dl-tls.c",
            0x49u,
            "_dl_next_tls_modid");
      }
      v1 = (unsigned __int64 *)v1[1];
      v2 += i;
      if ( !v1 )
        break;
    }
LABEL_11:
    if ( result > dl_tls_max_dtv_idx )
    {
LABEL_12:
      if ( dl_tls_max_dtv_idx + 1 != result )
        _assert_fail(
          (__int64)"result == GL(dl_tls_max_dtv_idx) + 1",
          (__int64)"../elf/dl-tls.c",
          0x57u,
          "_dl_next_tls_modid");
      dl_tls_dtv_gaps = 0;
      dl_tls_max_dtv_idx = result;
    }
  }
  else
  {
    return ++dl_tls_max_dtv_idx;
  }
  return result;
}
// 4AB3D0: using guessed type __int64 dl_tls_max_dtv_idx;
// 4AB7E0: using guessed type __int64 dl_tls_dtv_slotinfo_list;
// 4AB7E8: using guessed type char dl_tls_dtv_gaps;
// 4AB7F8: using guessed type __int64 dl_tls_static_nelem;

//----- (000000000046E8D0) ----------------------------------------------------
__int64 dl_count_modids()
{
  __int64 result; // rax
  _QWORD *v1; // rsi
  __int64 v2; // rdx

  if ( !dl_tls_dtv_gaps )
    return dl_tls_max_dtv_idx;
  v1 = (_QWORD *)dl_tls_dtv_slotinfo_list;
  result = 0LL;
  if ( dl_tls_dtv_slotinfo_list )
  {
    do
    {
      v2 = 0LL;
      if ( *v1 )
      {
        do
          result -= (v1[2 * v2++ + 3] == 0LL) - 1LL;
        while ( v2 != *v1 );
      }
      v1 = (_QWORD *)v1[1];
    }
    while ( v1 );
  }
  return result;
}
// 46E8D0: using guessed type __int64 __fastcall dl_count_modids();
// 4AB3D0: using guessed type __int64 dl_tls_max_dtv_idx;
// 4AB7E0: using guessed type __int64 dl_tls_dtv_slotinfo_list;
// 4AB7E8: using guessed type char dl_tls_dtv_gaps;

//----- (000000000046E940) ----------------------------------------------------
__int64 __fastcall dl_get_tls_static_info(_QWORD *a1, _QWORD *a2)
{
  __int64 result; // rax

  *a1 = dl_tls_static_size;
  result = dl_tls_static_align;
  *a2 = dl_tls_static_align;
  return result;
}
// 4A80E8: using guessed type __int64 dl_tls_static_size;
// 4AB3C8: using guessed type __int64 dl_tls_static_align;

//----- (000000000046E960) ----------------------------------------------------
u32 *__fastcall dl_allocate_tls_storage(__int64 a1, __int64 a2, _QWORD *a3, __int64 a4, u32 *a5, __int64 a6)
{
  __int64 v6; // r12
  unsigned __int64 v7; // rbx
  _QWORD *v8; // rax
  u32 *v9; // r8
  __int64 v10; // r9
  __int64 v11; // rbp
  unsigned __int64 v12; // rtt
  _QWORD *v13; // rdx
  u32 *result; // rax
  __int64 v15; // rdx
  __int64 v16; // rcx
  u32 *v17; // r8
  unsigned __int64 v18; // r9

  v6 = dl_tls_static_size;
  v7 = dl_tls_static_align;
  v8 = malloc(dl_tls_static_size + dl_tls_static_align + 8, a2, a3, a4, a5, a6);
  if ( !v8 )
    return 0LL;
  v11 = (__int64)v8;
  v12 = (unsigned __int64)v8 + v7 - 1;
  v13 = (_QWORD *)(v6 + v7 * (v12 / v7) - 2304);
  *v13 = 0LL;
  v13[287] = 0LL;
  memset(
    (void *)((unsigned __int64)(v13 + 1) & 0xFFFFFFFFFFFFFFF8LL),
    0,
    8LL * (((_DWORD)v6 + (_DWORD)v7 * (unsigned int)(v12 / v7) - (((_DWORD)v13 + 8) & 0xFFFFFFF8)) >> 3));
  v13[288] = v8;
  result = allocate_dtv((__int64)v13, a2, (__int64)v13, 0LL, v9, v10);
  if ( !result )
  {
    free(v11, a2, v15, v16, v17, v18);
    return 0LL;
  }
  return result;
}
// 46E9DE: variable 'v9' is possibly undefined
// 46E9DE: variable 'v10' is possibly undefined
// 46EA00: variable 'v15' is possibly undefined
// 46EA00: variable 'v16' is possibly undefined
// 46EA00: variable 'v17' is possibly undefined
// 46EA00: variable 'v18' is possibly undefined
// 4A80E8: using guessed type __int64 dl_tls_static_size;
// 4AB3C8: using guessed type __int64 dl_tls_static_align;

//----- (000000000046EA30) ----------------------------------------------------
__int64 __fastcall dl_allocate_tls_init(__int64 a1, __int64 a2, __int64 a3, __int64 a4, u32 *a5, unsigned __int64 a6)
{
  unsigned __int64 v6; // r10
  unsigned __int64 *v7; // r14
  unsigned __int64 v8; // r12
  unsigned __int64 v9; // rbp
  unsigned __int64 v10; // rbx
  unsigned __int64 v11; // rsi
  _QWORD *v12; // rax
  unsigned __int64 v13; // rdx
  __int64 v14; // rdi
  unsigned __int64 v15; // rdx
  unsigned __int64 *v16; // rcx
  unsigned __int64 v17; // r15
  unsigned __int64 v18; // r13
  __int64 v19; // rsi
  unsigned __int64 v20; // rdi
  __int64 v21; // rdx
  __int64 v22; // rax
  __int64 v24; // rbx
  __int64 v25; // rbp
  __int64 *v26; // r12
  __int64 v27; // r13
  __int64 *v28; // rax
  unsigned __int64 *v29; // [rsp+0h] [rbp-48h]

  if ( !a1 )
    return a1;
  v6 = dl_tls_max_dtv_idx;
  v29 = *(unsigned __int64 **)(a1 + 8);
  if ( *(v29 - 2) < dl_tls_max_dtv_idx )
  {
    v24 = dl_tls_max_dtv_idx + 14;
    v25 = *(v29 - 2);
    if ( v29 == qword_4AB3F0 )
    {
      v28 = malloc(16 * (dl_tls_max_dtv_idx + 16), (__int64)v29, qword_4AB3F0, a4, a5, a6);
      v26 = v28;
      if ( v28 )
      {
        v27 = 2 * (v25 + 2);
        j_memcpy(v28, &dl_static_dtv, v27 * 8);
        goto LABEL_25;
      }
    }
    else
    {
      v26 = realloc((__int64)(v29 - 2), 16 * (dl_tls_max_dtv_idx + 16), qword_4AB3F0, a4, a5, a6);
      if ( v26 )
      {
        v27 = 2 * (v25 + 2);
LABEL_25:
        *v26 = v24;
        j_memset_ifunc(&v26[v27], 0LL, 16 * (v24 - v25));
        v6 = dl_tls_max_dtv_idx;
        v29 = (unsigned __int64 *)(v26 + 2);
        *(_QWORD *)(a1 + 8) = v26 + 2;
        goto LABEL_3;
      }
    }
    oom();
  }
LABEL_3:
  v7 = (unsigned __int64 *)dl_tls_dtv_slotinfo_list;
  v8 = 0LL;
  v9 = 0LL;
  while ( 1 )
  {
    v10 = v9 == 0;
    v11 = v9 + v10;
    if ( v10 < *v7 )
      break;
LABEL_19:
    v9 = v11;
    if ( v11 >= v6 )
      goto LABEL_17;
    v7 = (unsigned __int64 *)v7[1];
    if ( !v7 )
      _assert_fail((__int64)"listp != NULL", (__int64)"../elf/dl-tls.c", 0x205u, "_dl_allocate_tls_init");
  }
  while ( v11 <= v6 )
  {
    v12 = (_QWORD *)v7[2 * v10 + 3];
    if ( v12 )
    {
      v13 = v7[2 * v10 + 2];
      if ( v13 > dl_tls_generation )
        _assert_fail(
          (__int64)"listp->slotinfo[cnt].gen <= GL(dl_tls_generation)",
          (__int64)"../elf/dl-tls.c",
          0x1E1u,
          "_dl_allocate_tls_init");
      v14 = v12[138];
      if ( v8 < v13 )
        v8 = v7[2 * v10 + 2];
      v15 = v12[137];
      v16 = &v29[2 * v14];
      *v16 = -1LL;
      v16[1] = 0LL;
      if ( v15 + 1 > 1 )
      {
        if ( v14 != v11 )
          _assert_fail(
            (__int64)"map->l_tls_modid == total + cnt",
            (__int64)"../elf/dl-tls.c",
            0x1EBu,
            "_dl_allocate_tls_init");
        v17 = v12[134];
        v18 = v12[133];
        if ( v17 < v18 )
          _assert_fail(
            (__int64)"map->l_tls_blocksize >= map->l_tls_initimage_size",
            (__int64)"../elf/dl-tls.c",
            0x1ECu,
            "_dl_allocate_tls_init");
        if ( v15 < v17 )
          _assert_fail(
            (__int64)"(size_t) map->l_tls_offset >= map->l_tls_blocksize",
            (__int64)"../elf/dl-tls.c",
            0x1EEu,
            "_dl_allocate_tls_init");
        v19 = v12[132];
        v20 = a1 - v15;
        v21 = v12[133];
        *v16 = v20;
        v22 = j_mempcpy(v20, v19, v21);
        j_memset_ifunc(v22, 0LL, v17 - v18);
        v6 = dl_tls_max_dtv_idx;
      }
    }
    ++v10;
    v11 = v9 + v10;
    if ( *v7 <= v10 )
      goto LABEL_19;
  }
LABEL_17:
  *v29 = v8;
  return a1;
}
// 401040: using guessed type __int64 __fastcall j_memcpy(_QWORD, _QWORD, _QWORD);
// 401090: using guessed type __int64 __fastcall j_memset_ifunc(_QWORD, _QWORD, _QWORD);
// 4010B0: using guessed type __int64 __fastcall j_mempcpy(_QWORD, _QWORD, _QWORD);
// 4AB3D0: using guessed type __int64 dl_tls_max_dtv_idx;
// 4AB3E0: using guessed type __int64 dl_static_dtv;
// 4AB3F0: using guessed type _QWORD qword_4AB3F0[2];
// 4AB7E0: using guessed type __int64 dl_tls_dtv_slotinfo_list;
// 4AB7F0: using guessed type __int64 dl_tls_generation;

//----- (000000000046ED00) ----------------------------------------------------
__int64 __fastcall dl_allocate_tls(__int64 a1, __int64 a2, _QWORD *a3, __int64 a4, u32 *a5, __int64 a6)
{
  u32 *dtv; // rax
  __int64 v7; // rdx
  __int64 v8; // rcx
  u32 *v9; // r8
  unsigned __int64 v10; // r9

  if ( a1 )
    dtv = allocate_dtv(a1, a2, (__int64)a3, a4, a5, a6);
  else
    dtv = dl_allocate_tls_storage(0LL, a2, a3, a4, a5, a6);
  return dl_allocate_tls_init((__int64)dtv, a2, v7, v8, v9, v10);
}
// 46ED19: variable 'v7' is possibly undefined
// 46ED19: variable 'v8' is possibly undefined
// 46ED19: variable 'v9' is possibly undefined
// 46ED19: variable 'v10' is possibly undefined

//----- (000000000046ED40) ----------------------------------------------------
__int64 *__fastcall dl_deallocate_tls(__int64 a1, __int64 a2, __int64 a3, __int64 a4, u32 *a5, unsigned __int64 a6)
{
  _QWORD *v6; // rbp
  unsigned __int64 v7; // rbx
  __int64 *result; // rax

  v6 = *(_QWORD **)(a1 + 8);
  if ( *(v6 - 2) )
  {
    v7 = 0LL;
    do
    {
      ++v7;
      free(v6[2 * v7 + 1], a2, a3, a4, a5, a6);
    }
    while ( v7 < *(v6 - 2) );
  }
  result = qword_4AB3F0;
  if ( v6 != qword_4AB3F0 )
    result = free((__int64)(v6 - 2), a2, a3, a4, a5, a6);
  if ( (_BYTE)a2 )
    return free(*(_QWORD *)(a1 + 2304), a2, a3, a4, a5, a6);
  return result;
}
// 46ED78: variable 'a3' is possibly undefined
// 46ED78: variable 'a4' is possibly undefined
// 46ED78: variable 'a5' is possibly undefined
// 46ED78: variable 'a6' is possibly undefined
// 4AB3F0: using guessed type _QWORD qword_4AB3F0[2];

//----- (000000000046EDD0) ----------------------------------------------------
__int64 __fastcall dl_tls_get_addr_soft(__int64 a1)
{
  unsigned __int64 v1; // rax
  _QWORD *v2; // rdx
  __int64 result; // rax
  unsigned __int64 *v4; // rsi
  unsigned __int64 v5; // rcx
  unsigned __int64 v6; // rdi

  v1 = *(_QWORD *)(a1 + 1104);
  if ( !v1 )
    return 0LL;
  v2 = (_QWORD *)__readfsqword(8u);
  if ( *v2 != dl_tls_generation )
  {
    if ( v1 >= *(v2 - 2) )
      return 0LL;
    v4 = (unsigned __int64 *)dl_tls_dtv_slotinfo_list;
    v5 = *(_QWORD *)(a1 + 1104);
    v6 = *(_QWORD *)dl_tls_dtv_slotinfo_list;
    if ( v1 >= *(_QWORD *)dl_tls_dtv_slotinfo_list )
    {
      do
      {
        v4 = (unsigned __int64 *)v4[1];
        v5 -= v6;
        v6 = *v4;
      }
      while ( *v4 <= v5 );
    }
    if ( *v2 < v4[2 * v5 + 2] )
      return 0LL;
  }
  result = v2[2 * v1];
  if ( result == -1 )
    return 0LL;
  return result;
}
// 4AB7E0: using guessed type __int64 dl_tls_dtv_slotinfo_list;
// 4AB7F0: using guessed type __int64 dl_tls_generation;

//----- (000000000046EE50) ----------------------------------------------------
__int64 __fastcall dl_add_to_slotinfo(unsigned __int64 a1, __int64 a2, _QWORD *a3, __int64 a4, u32 *a5, __int64 a6)
{
  unsigned __int64 *v6; // rbx
  unsigned __int64 v7; // rbp
  __int64 result; // rax
  __int64 v9; // rdx
  unsigned __int64 *v10; // rbx
  unsigned __int64 *v11; // rsi

  v6 = (unsigned __int64 *)dl_tls_dtv_slotinfo_list;
  v7 = *(_QWORD *)(a1 + 1104);
  while ( 1 )
  {
    if ( *v6 > v7 )
    {
      result = dl_tls_generation;
      v9 = dl_tls_generation + 1;
      goto LABEL_6;
    }
    v7 -= *v6;
    if ( !v6[1] )
      break;
    v6 = (unsigned __int64 *)v6[1];
  }
  if ( v7 )
    _assert_fail((__int64)"idx == 0", (__int64)"../elf/dl-tls.c", 0x392u, "_dl_add_to_slotinfo");
  v11 = malloc(0x3F0uLL, a2, a3, a4, a5, a6);
  v6[1] = (unsigned __int64)v11;
  v9 = dl_tls_generation + 1;
  if ( !v11 )
  {
    ++dl_tls_generation;
    dl_signal_error(12, "dlopen", 0LL, "cannot create TLS data structures");
  }
  result = 0LL;
  v6 = v11;
  *v11 = 62LL;
  v11[1] = 0LL;
  memset(v11 + 2, 0, 0x3E0uLL);
LABEL_6:
  v10 = &v6[2 * v7];
  v10[3] = a1;
  v10[2] = v9;
  return result;
}
// 4AB7E0: using guessed type __int64 dl_tls_dtv_slotinfo_list;
// 4AB7F0: using guessed type __int64 dl_tls_generation;

//----- (000000000046EF40) ----------------------------------------------------
__int64 dl_get_origin()
{
  signed __int64 v0; // rax
  __int64 v1; // rcx
  u32 *v2; // r8
  __int64 v3; // r9
  int v4; // ebp
  __int64 v5; // rax
  _QWORD *v6; // r12
  __int64 v7; // rbx
  __int64 v8; // rbp
  _QWORD *v9; // rdx
  __int64 v10; // rcx
  u32 *v11; // r8
  __int64 v12; // r9
  _QWORD *v13; // rax
  _QWORD *v14; // r12
  _BYTE *v15; // rax
  _QWORD *v17; // rax
  _QWORD *v18; // r12
  char v19[4120]; // [rsp+0h] [rbp-1018h] BYREF

  v0 = sys_readlink("/proc/self/exe", v19, 4096);
  if ( (unsigned int)v0 <= 0xFFFFF000 && (int)v0 > 0 && v19[0] != 91 )
  {
    if ( v19[0] != 47 )
      _assert_fail(
        (__int64)"linkval[0] == '/'",
        (__int64)"../sysdeps/unix/sysv/linux/dl-origin.c",
        0x2Fu,
        "_dl_get_origin");
    if ( (_DWORD)v0 != 1 )
    {
      v4 = v0;
      v5 = (int)v0 - 1;
      if ( v19[v5] == 47 )
      {
LABEL_21:
        v17 = malloc(v4 + 1, (__int64)v19, (_QWORD *)(unsigned __int8)v19[0], v1, v2, v3);
        v18 = v17;
        if ( v17 )
        {
          *(_BYTE *)j_mempcpy(v17, v19, v4 - 1) = 0;
          return (__int64)v18;
        }
        return -1LL;
      }
      while ( 1 )
      {
        v4 = v5;
        if ( (_DWORD)v5 == 1 )
          break;
        if ( v19[--v5] == 47 )
          goto LABEL_21;
      }
    }
    v6 = malloc(2uLL, (__int64)v19, (_QWORD *)(unsigned __int8)v19[0], v1, v2, v3);
    if ( v6 )
    {
      *(_WORD *)v6 = 47;
      return (__int64)v6;
    }
    return -1LL;
  }
  v7 = dl_origin_path;
  if ( !dl_origin_path )
    return -1LL;
  v8 = j_strlen_ifunc(dl_origin_path);
  v13 = malloc(v8 + 1, (__int64)v19, v9, v10, v11, v12);
  v14 = v13;
  if ( !v13 )
    return -1LL;
  v15 = (_BYTE *)j_mempcpy(v13, v7, v8);
  if ( (char *)v14 + 1 < v15 )
  {
    do
    {
      if ( *(v15 - 1) != 47 )
        break;
      --v15;
    }
    while ( (char *)v14 + 1 != v15 );
  }
  *v15 = 0;
  return (__int64)v14;
}
// 46EFC2: variable 'v1' is possibly undefined
// 46EFC2: variable 'v2' is possibly undefined
// 46EFC2: variable 'v3' is possibly undefined
// 46EFFB: variable 'v9' is possibly undefined
// 46EFFB: variable 'v10' is possibly undefined
// 46EFFB: variable 'v11' is possibly undefined
// 46EFFB: variable 'v12' is possibly undefined
// 4010B0: using guessed type __int64 __fastcall j_mempcpy(_QWORD, _QWORD, _QWORD);
// 4010C8: using guessed type __int64 __fastcall j_strlen_ifunc(_QWORD);
// 4AB8E0: using guessed type __int64 dl_origin_path;
// 46EF40: using guessed type char var_1018[4120];

//----- (000000000046F0D0) ----------------------------------------------------
__int64 __fastcall dl_scope_free(__int64 a1, __int64 a2, _QWORD *a3, __int64 a4, u32 *a5, unsigned __int64 a6)
{
  unsigned int v6; // ebx
  __int64 *v8; // rbx
  __int64 v9; // rax
  __int64 v10; // rdx
  __int64 v11; // rcx
  u32 *v12; // r8
  unsigned __int64 v13; // r9
  __int64 i; // rax
  __int64 v15; // rax
  _QWORD *v16; // rax
  __int64 v17; // rdx
  __int64 v18; // rcx
  __int64 v19; // r8
  __int64 v20; // r9
  __int64 v21; // rdx
  __int64 v22; // rcx
  u32 *v23; // r8
  unsigned __int64 v24; // r9

  v6 = __readfsdword(0x18u);
  if ( v6 )
  {
    v8 = (__int64 *)dl_scope_free_list;
    if ( dl_scope_free_list )
    {
      v9 = *(_QWORD *)dl_scope_free_list;
      if ( *(_QWORD *)dl_scope_free_list > 0x31uLL )
      {
        dl_wait_lookup_done(a1, a2, a3, a4, a5, a6);
        for ( i = *v8; *v8; i = *v8 )
        {
          v15 = i - 1;
          *v8 = v15;
          free(v8[v15 + 1], a2, v10, v11, v12, v13);
        }
        return 1;
      }
      else
      {
        *(_QWORD *)dl_scope_free_list = v9 + 1;
        v8[v9 + 1] = a1;
        return 0;
      }
    }
    else
    {
      v16 = malloc(0x198uLL, a2, a3, a4, a5, a6);
      dl_scope_free_list = (__int64)v16;
      if ( v16 )
      {
        v16[1] = a1;
        v6 = 0;
        *v16 = 1LL;
      }
      else
      {
        dl_wait_lookup_done(408LL, a2, v17, v18, v19, v20);
        v6 = 1;
        free(a1, a2, v21, v22, v23, v24);
      }
    }
  }
  else
  {
    free(a1, a2, (__int64)a3, a4, a5, a6);
  }
  return v6;
}
// 46F14C: variable 'v10' is possibly undefined
// 46F14C: variable 'v11' is possibly undefined
// 46F14C: variable 'v12' is possibly undefined
// 46F14C: variable 'v13' is possibly undefined
// 46F188: variable 'v17' is possibly undefined
// 46F188: variable 'v18' is possibly undefined
// 46F188: variable 'v19' is possibly undefined
// 46F188: variable 'v20' is possibly undefined
// 46F196: variable 'v21' is possibly undefined
// 46F196: variable 'v22' is possibly undefined
// 46F196: variable 'v23' is possibly undefined
// 46F196: variable 'v24' is possibly undefined
// 4AB888: using guessed type __int64 (__fastcall *dl_wait_lookup_done)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 4AB8D8: using guessed type __int64 dl_scope_free_list;

//----- (000000000046F1A0) ----------------------------------------------------
unsigned int __fastcall dl_make_stack_executable(_QWORD *a1)
{
  unsigned int result; // eax

  result = mprotect(*a1 & -dl_pagesize, dl_pagesize, (unsigned int)_stack_prot);
  if ( result )
    return __readfsdword(0xFFFFFFC0);
  *a1 = 0LL;
  dl_stack_flags |= 1u;
  return result;
}
// 4A7F10: using guessed type int _stack_prot;
// 4A91E8: using guessed type int dl_stack_flags;
// 4A91F8: using guessed type __int64 dl_pagesize;

//----- (000000000046F1F0) ----------------------------------------------------
#error "46F1F0: function frame is wrong (funcsize=0)"

//----- (000000000046F670) ----------------------------------------------------
#error "46F670: function frame is wrong (funcsize=0)"

//----- (000000000046FAF0) ----------------------------------------------------
__int64 __fastcall dl_runtime_profile_sse(
        unsigned __int64 a1,
        unsigned __int64 a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6,
        __m128 a7,
        __m128 a8,
        __m128 a9,
        __m128 a10,
        __m128 a11,
        __m128 a12,
        __m128 a13,
        __m128 a14,
        unsigned int a15,
        __int64 a16,
        __int64 a17)
{
  __int64 v17; // rax
  __int64 v18; // rbx
  __int64 v19; // rbp
  long double v20; // fst6
  long double v21; // fst7
  __int64 (*v26)(void); // r11
  __int64 v27; // rdx
  __int64 v28; // r8
  __int64 v29; // r9
  long double v30; // xmm0
  __m128 v31; // xmm1
  double v32; // xmm2_8
  double v33; // xmm3_8
  double v34; // xmm4_8
  double v35; // xmm5_8
  double v36; // xmm6_8
  double v37; // xmm7_8
  __int64 result; // rax
  unsigned __int64 v43; // r10
  void *v44; // rsp
  __int64 v45; // rax
  __int64 v47; // rdx
  __int64 v50; // [rsp+F0h] [rbp-3A0h] BYREF
  __int64 v51; // [rsp+F8h] [rbp-398h]
  long double v52; // [rsp+100h] [rbp-390h]
  __m128 v53; // [rsp+110h] [rbp-380h]
  long double v54; // [rsp+120h] [rbp-370h]
  long double v55; // [rsp+130h] [rbp-360h]
  __m128 v56; // [rsp+140h] [rbp-350h]
  __m128 v57; // [rsp+150h] [rbp-340h]
  __m128 v58; // [rsp+160h] [rbp-330h]
  __m128 v59; // [rsp+170h] [rbp-320h]
  __m128 v60; // [rsp+180h] [rbp-310h]
  __m128 v61; // [rsp+190h] [rbp-300h]
  __m128 v62; // [rsp+1A0h] [rbp-2F0h]
  __int64 v69; // [rsp+470h] [rbp-20h]
  __int64 v70; // [rsp+478h] [rbp-18h]
  _QWORD v71[2]; // [rsp+480h] [rbp-10h] BYREF
  __int64 retaddr; // [rsp+490h] [rbp+0h]

  v69 = v18;
  v70 = v17;
  v71[1] = &v50;
  v50 = a3;
  v51 = a5;
  *(_QWORD *)&v52 = a6;
  *((_QWORD *)&v52 + 1) = a4;
  v53.m128_u64[0] = a2;
  v53.m128_u64[1] = a1;
  *(_QWORD *)&v54 = v19;
  *((_QWORD *)&v54 + 1) = &a16;
  v55 = *(long double *)&a7;
  v56 = a8;
  v57 = a9;
  v58 = a10;
  v59 = a11;
  v60 = a12;
  v61 = a13;
  v62 = a14;
  __asm
  {
    bndmov  [rsp+3A0h+var_E0], bnd0
    bndmov  [rsp+3A0h+var_D0], bnd1
    bndmov  [rsp+3A0h+var_C0], bnd2
    bndmov  [rsp+3A0h+var_B0], bnd3
  }
  v26 = dl_profile_fixup(
          retaddr,
          a15,
          a16,
          *(double *)a7.m128_u64,
          *(double *)a8.m128_u64,
          *(double *)a9.m128_u64,
          *(double *)a10.m128_u64,
          *(double *)a11.m128_u64,
          *(double *)a12.m128_u64,
          *(double *)a13.m128_u64,
          *(double *)a14.m128_u64,
          (__int64)&v50,
          v71);
  v27 = v50;
  v28 = v51;
  v29 = *(_QWORD *)&v52;
  v30 = v55;
  v31 = v56;
  v32 = *(double *)v57.m128_u64;
  v33 = *(double *)v58.m128_u64;
  v34 = *(double *)v59.m128_u64;
  v35 = *(double *)v60.m128_u64;
  v36 = *(double *)v61.m128_u64;
  v37 = *(double *)v62.m128_u64;
  __asm
  {
    bndmov  bnd0, [rsp+3A0h+var_E0]
    bndmov  bnd1, [rsp+3A0h+var_D0]
    bndmov  bnd2, [rsp+3A0h+var_C0]
    bndmov  bnd3, [rsp+3A0h+var_B0]
  }
  if ( v71[0] < 0LL )
    return ((__int64 (__fastcall *)(unsigned __int64, unsigned __int64, __int64, _QWORD, __int64, _QWORD, double, double, double, double, double, double, double, double))v26)(
             v53.m128_u64[1],
             v53.m128_u64[0],
             v50,
             *((_QWORD *)&v52 + 1),
             v51,
             *(_QWORD *)&v52,
             *(double *)&v55,
             *(double *)v56.m128_u64,
             *(double *)v57.m128_u64,
             *(double *)v58.m128_u64,
             *(double *)v59.m128_u64,
             *(double *)v60.m128_u64,
             *(double *)v61.m128_u64,
             *(double *)v62.m128_u64);
  v43 = (v71[0] + 8LL) & 0xFFFFFFFFFFFFFFF0LL;
  v44 = alloca(v71[0] + 8LL);
  qmemcpy(&v50, &a17, 8 * (v43 >> 3));
  v45 = ((__int64 (__fastcall *)(unsigned __int64, unsigned __int64, __int64, _QWORD, __int64, __int64, double, double, double, double, double, double, double, double))v26)(
          v53.m128_u64[(v43 >> 3) + 1],
          v53.m128_u64[v43 >> 3],
          v27,
          *((_QWORD *)&v52 + (v43 >> 3) + 1),
          v28,
          v29,
          *(double *)&v30,
          *(double *)v31.m128_u64,
          v32,
          v33,
          v34,
          v35,
          v36,
          v37);
  _RCX = &v50;
  v50 = v45;
  v51 = v47;
  v52 = v30;
  v53 = v31;
  __asm
  {
    bndmov  [rcx+0D0h], bnd0
    bndmov  [rcx+0E0h], bnd1
  }
  v54 = v20;
  v55 = v21;
  dl_call_pltexit();
  result = v50;
  __asm
  {
    bndmov  bnd0, [rsp+3A0h+var_2D0]
    bndmov  bnd1, [rsp+3A0h+var_2C0]
  }
  return result;
}
// 46FAF0: could not find valid save-restore pair for rbx
// 46FAF0: unsupported processor register 'bnd0'
// 46FAF8: variable 'v18' is possibly undefined
// 46FAFC: variable 'v17' is possibly undefined
// 46FB30: variable 'v19' is possibly undefined
// 46FC80: variable 'v47' is possibly undefined
// 46FC9C: variable 'v20' is possibly undefined
// 46FC9F: variable 'v21' is possibly undefined

//----- (000000000046FCF0) ----------------------------------------------------
__int64 __fastcall dl_runtime_resolve_fxsave(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6,
        double a7,
        double a8,
        double a9,
        double a10,
        double a11,
        double a12,
        double a13,
        double a14,
        unsigned int a15)
{
  __int64 (*v15)(void); // rax
  int v23[124]; // [rsp+40h] [rbp-208h] BYREF
  __int64 retaddr; // [rsp+248h] [rbp+0h]

  _fxsave(v23);
  v15 = dl_fixup(retaddr, a15, a7, a8, a9, a10, a11, a12, a13, a14);
  _fxrstor(v23);
  return ((__int64 (__fastcall *)(__int64, __int64, __int64, __int64, __int64, __int64))v15)(a1, a2, a3, a4, a5, a6);
}

//----- (000000000046FD70) ----------------------------------------------------
__int64 __fastcall dl_runtime_resolve_xsave(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6,
        double a7,
        double a8,
        double a9,
        double a10,
        double a11,
        double a12,
        double a13,
        double a14,
        __int64 a15,
        __int64 a16,
        __int64 a17,
        __int64 a18,
        __int64 a19,
        int a20,
        __int64 a21,
        int a22,
        int a23,
        int a24,
        int a25,
        int a26,
        int a27,
        int a28,
        int a29,
        int a30,
        int a31,
        int a32,
        int a33,
        int a34,
        int a35,
        int a36,
        int a37,
        int a38,
        int a39,
        int a40,
        int a41,
        int a42,
        int a43,
        int a44,
        int a45,
        int a46,
        int a47,
        int a48,
        int a49,
        int a50,
        int a51,
        int a52,
        int a53,
        int a54,
        int a55,
        int a56,
        int a57,
        int a58,
        int a59,
        int a60,
        int a61,
        int a62,
        int a63)
{
  __int64 (*v63)(void); // rax

  STACK[0x250] = 0LL;
  STACK[0x258] = 0LL;
  STACK[0x260] = 0LL;
  STACK[0x268] = 0LL;
  STACK[0x270] = 0LL;
  STACK[0x278] = 0LL;
  STACK[0x280] = 0LL;
  STACK[0x288] = 0LL;
  _xsave(&a21, 0xEEuLL);
  v63 = dl_fixup(a4, a3, a7, a8, a9, a10, a11, a12, a13, a14);
  _xrstor(&a21, 0xEEuLL);
  return ((__int64 (__fastcall *)(__int64, __int64, __int64, __int64, __int64, __int64, __int64, __int64, __int64, __int64, __int64))v63)(
           a1,
           a2,
           a3,
           a4,
           a5,
           a6,
           a3,
           a2,
           a1,
           a5,
           a6);
}
// 4AAE40: using guessed type __int64 qword_4AAE40;

//----- (000000000046FE40) ----------------------------------------------------
__int64 __fastcall dl_runtime_resolve_xsavec(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6,
        double a7,
        double a8,
        double a9,
        double a10,
        double a11,
        double a12,
        double a13,
        double a14,
        __int64 a15,
        __int64 a16,
        __int64 a17,
        __int64 a18,
        __int64 a19,
        __int64 a20,
        __int64 a21,
        int a22,
        int a23,
        int a24,
        int a25,
        int a26,
        int a27,
        int a28,
        int a29,
        int a30,
        int a31,
        int a32,
        int a33,
        int a34,
        int a35,
        int a36,
        int a37,
        int a38,
        int a39,
        int a40,
        int a41,
        int a42,
        int a43,
        int a44,
        int a45,
        int a46,
        int a47,
        int a48,
        int a49,
        int a50,
        int a51,
        int a52,
        int a53,
        int a54,
        int a55,
        int a56,
        int a57,
        int a58,
        int a59,
        int a60,
        int a61,
        int a62,
        int a63)
{
  __int64 (*v63)(void); // rax

  STACK[0x260] = 0LL;
  STACK[0x268] = 0LL;
  STACK[0x270] = 0LL;
  STACK[0x278] = 0LL;
  STACK[0x280] = 0LL;
  STACK[0x288] = 0LL;
  __asm { xsavec  [rsp+8+arg_30] }
  v63 = dl_fixup(a4, a3, a7, a8, a9, a10, a11, a12, a13, a14);
  _xrstor(&a21, 0xEEuLL);
  return ((__int64 (__fastcall *)(__int64, __int64, __int64, __int64, __int64, __int64, __int64, __int64, __int64, __int64, __int64, __int64))v63)(
           a1,
           a2,
           a3,
           a4,
           a5,
           a6,
           a3,
           a2,
           a1,
           a5,
           a6,
           a20);
}
// 4AAE40: using guessed type __int64 qword_4AAE40;

//----- (000000000046FF00) ----------------------------------------------------
void __noreturn length_mismatch()
{
  dl_dprintf(2, "Fatal error: length accounting in _dl_exception_create_format\n");
  exit(127);
}

//----- (000000000046FF30) ----------------------------------------------------
const char *__fastcall dl_exception_create(const char **a1, void *a2, __int64 a3)
{
  unsigned __int8 *v4; // r13
  __int64 v5; // r12
  __int64 v6; // rbx
  _QWORD *v7; // rdx
  __int64 v8; // rcx
  u32 *v9; // r8
  __int64 v10; // r9
  const char *v11; // rax
  const char *v12; // r15
  __int64 v13; // rax
  const char *result; // rax

  if ( a2 )
  {
    v4 = (unsigned __int8 *)a2;
    v5 = j_strlen_ifunc(a2) + 1;
  }
  else
  {
    v5 = 1LL;
    v4 = byte_493255;
  }
  v6 = j_strlen_ifunc(a3) + 1;
  v11 = (const char *)malloc(v6 + v5, (__int64)a2, v7, v8, v9, v10);
  v12 = v11;
  if ( v11 )
  {
    v13 = j_mempcpy(v11, a3, v6);
    result = (const char *)j_memcpy(v13, v4, v5);
    a1[1] = v12;
    a1[2] = v12;
    *a1 = result;
  }
  else
  {
    a1[2] = 0LL;
    *a1 = (const char *)byte_493255;
    result = "out of memory";
    a1[1] = "out of memory";
  }
  return result;
}
// 46FF70: variable 'v7' is possibly undefined
// 46FF70: variable 'v8' is possibly undefined
// 46FF70: variable 'v9' is possibly undefined
// 46FF70: variable 'v10' is possibly undefined
// 401040: using guessed type __int64 __fastcall j_memcpy(_QWORD, _QWORD, _QWORD);
// 4010B0: using guessed type __int64 __fastcall j_mempcpy(_QWORD, _QWORD, _QWORD);
// 4010C8: using guessed type __int64 __fastcall j_strlen_ifunc(_QWORD);
// 493255: using guessed type unsigned __int8 byte_493255[1707];

//----- (0000000000470000) ----------------------------------------------------
const char *__fastcall dl_exception_create_format(
        const char **a1,
        void *a2,
        _BYTE *a3,
        double a4,
        double a5,
        double a6,
        double a7,
        double a8,
        double a9,
        double a10,
        double a11,
        __int64 a12,
        u32 *a13,
        __int64 a14,
        char a15)
{
  unsigned __int8 *v16; // r12
  __int64 v17; // rax
  signed __int64 v18; // r13
  unsigned __int64 v19; // rdx
  _BYTE *v20; // rbx
  unsigned int v21; // eax
  const char *v22; // rax
  double v23; // xmm4_8
  double v24; // xmm5_8
  char *v25; // rbx
  const char *v26; // r13
  char v27; // al
  _BYTE *v28; // r14
  char v29; // al
  const char *result; // rax
  char *v31; // rdx
  __int64 v32; // rax
  char *v33; // rdx
  __int64 v34; // r15
  unsigned __int64 v35; // rax
  __int64 v36; // [rsp+0h] [rbp-98h]
  unsigned int v37; // [rsp+18h] [rbp-80h]
  unsigned int v38; // [rsp+18h] [rbp-80h]
  char *v39; // [rsp+20h] [rbp-78h]
  char *v40; // [rsp+20h] [rbp-78h]
  char v41[24]; // [rsp+30h] [rbp-68h] BYREF
  __int64 v42; // [rsp+48h] [rbp-50h]
  u32 *v43; // [rsp+50h] [rbp-48h]
  __int64 v44; // [rsp+58h] [rbp-40h]

  v42 = a12;
  v43 = a13;
  v44 = a14;
  if ( a2 )
  {
    v16 = (unsigned __int8 *)a2;
    v17 = j_strlen_ifunc(a2);
    a12 = v17 + 1;
    v18 = v17 + 2;
    v36 = v17 + 1;
  }
  else
  {
    v18 = 2LL;
    v36 = 1LL;
    v16 = byte_493255;
  }
  v19 = (unsigned __int8)*a3;
  v37 = 24;
  v39 = &a15;
  if ( !(_BYTE)v19 )
  {
LABEL_11:
    v22 = (const char *)malloc(v18, (__int64)a2, (_QWORD *)v19, a12, a13, a14);
    v25 = (char *)v22;
    if ( !v22 )
      goto LABEL_27;
    a1[1] = v22;
    v26 = &v22[v18];
    a1[2] = v22;
    v40 = &a15;
    v27 = *a3;
    v38 = 24;
    if ( !*a3 )
    {
LABEL_21:
      if ( v26 == v25 || (*v25 = 0, v26 - (v25 + 1) != v36) )
LABEL_36:
        length_mismatch();
      result = (const char *)j_memcpy(v25 + 1, v16, v36);
      *a1 = result;
      return result;
    }
    while ( v27 == 37 )
    {
      v29 = a3[1];
      v28 = a3 + 1;
      if ( v29 == 37 )
      {
        if ( v26 == v25 )
          goto LABEL_36;
        v27 = a3[2];
        *v25 = 37;
        a3 += 2;
        ++v25;
        if ( !v27 )
          goto LABEL_21;
      }
      else
      {
        if ( v29 != 115 )
        {
          dl_dprintf(2, "Fatal error: invalid format in exception string\n", a4, a5, a6, a7, v23, v24, a10, a11);
          exit(127);
        }
        if ( v38 > 0x2F )
        {
          v33 = v40;
          v40 += 8;
        }
        else
        {
          v33 = &v41[v38];
          v38 += 8;
        }
        v34 = *(_QWORD *)v33;
        v35 = j_strlen_ifunc(*(_QWORD *)v33);
        if ( v26 - v25 < v35 )
          goto LABEL_36;
        v25 = (char *)j_mempcpy(v25, v34, v35);
LABEL_16:
        v27 = v28[1];
        a3 = v28 + 1;
        if ( !v27 )
          goto LABEL_21;
      }
    }
    if ( v26 == v25 )
      goto LABEL_36;
    *v25 = v27;
    v28 = a3;
    ++v25;
    goto LABEL_16;
  }
  v20 = a3;
  do
  {
    while ( 1 )
    {
      v21 = (unsigned __int8)v20[1];
      a2 = v20 + 1;
      if ( (_BYTE)v19 == 37 )
        break;
      ++v18;
      ++v20;
      v19 = v21;
LABEL_6:
      if ( !(_BYTE)v19 )
        goto LABEL_10;
    }
    if ( (_BYTE)v21 == 115 )
    {
      if ( v37 > 0x2F )
      {
        v31 = v39;
        v39 += 8;
      }
      else
      {
        v31 = &v41[v37];
        v37 += 8;
      }
      v32 = j_strlen_ifunc(*(_QWORD *)v31);
      v19 = (unsigned __int8)v20[2];
      v20 += 2;
      v18 += v32;
      goto LABEL_6;
    }
    v19 = (unsigned __int8)v20[2];
    ++v18;
    v20 += 2;
  }
  while ( (_BYTE)v19 );
LABEL_10:
  if ( v18 >= 0 )
    goto LABEL_11;
LABEL_27:
  a1[2] = 0LL;
  *a1 = (const char *)byte_493255;
  result = "out of memory";
  a1[1] = "out of memory";
  return result;
}
// 4700C1: variable 'a12' is possibly undefined
// 4700C1: variable 'a13' is possibly undefined
// 4700C1: variable 'a14' is possibly undefined
// 4702AD: variable 'v23' is possibly undefined
// 4702AD: variable 'v24' is possibly undefined
// 401040: using guessed type __int64 __fastcall j_memcpy(_QWORD, _QWORD, _QWORD);
// 4010B0: using guessed type __int64 __fastcall j_mempcpy(_QWORD, _QWORD, _QWORD);
// 4010C8: using guessed type __int64 __fastcall j_strlen_ifunc(_QWORD);
// 493255: using guessed type unsigned __int8 byte_493255[1707];

//----- (00000000004702C0) ----------------------------------------------------
__int64 *__fastcall dl_exception_free(_QWORD *a1, __int64 a2, __int64 a3, __int64 a4, u32 *a5, unsigned __int64 a6)
{
  __int64 *result; // rax

  result = free(a1[2], a2, a3, a4, a5, a6);
  *a1 = 0LL;
  a1[1] = 0LL;
  a1[2] = 0LL;
  return result;
}

//----- (00000000004702F0) ----------------------------------------------------
__int64 __fastcall dl_cache_libcmp(char *a1, char *a2)
{
  int v2; // eax
  int v3; // ecx
  unsigned __int8 v4; // dl
  int v6; // edx
  bool v7; // cc
  int v8; // edx

  while ( 1 )
  {
    v2 = *a1;
    v3 = *a2;
    if ( !*a1 )
      return (unsigned int)-(char)v3;
    while ( 1 )
    {
      v4 = v3 - 48;
      if ( (unsigned __int8)(v2 - 48) <= 9u )
        break;
      if ( v4 <= 9u )
        return 0xFFFFFFFFLL;
      if ( (_BYTE)v2 != (_BYTE)v3 )
        return (unsigned int)(v2 - v3);
      v2 = *++a1;
      v3 = *++a2;
      if ( !*a1 )
        return (unsigned int)-(char)v3;
    }
    if ( v4 > 9u )
      break;
    v6 = a1[1];
    v2 -= 48;
    v3 -= 48;
    v7 = (unsigned __int8)(*++a1 - 48) <= 9u;
    if ( v7 )
    {
      do
      {
        ++a1;
        v2 = v6 + 10 * v2 - 48;
        v6 = *a1;
      }
      while ( (unsigned __int8)(*a1 - 48) <= 9u );
    }
    v8 = a2[1];
    v7 = (unsigned __int8)(*++a2 - 48) <= 9u;
    if ( v7 )
    {
      do
      {
        ++a2;
        v3 = v8 + 10 * v3 - 48;
        v8 = *a2;
      }
      while ( (unsigned __int8)(*a2 - 48) <= 9u );
    }
    if ( v3 != v2 )
      return (unsigned int)(v2 - v3);
  }
  return 1LL;
}

//----- (00000000004703C0) ----------------------------------------------------
__int64 __fastcall dl_load_cache_lookup(char *a1)
{
  __int64 whole_file; // r14
  __int64 v3; // rsi
  __int64 v4; // r12
  __int64 v5; // r15
  unsigned int v6; // er13
  bool v7; // zf
  __int64 v8; // rax
  __int64 v9; // r15
  __int64 v10; // rsi
  int v11; // er14
  int v12; // er11
  int v13; // eax
  int v14; // er10
  int v16; // er14
  __int64 v17; // rsi
  const char *v18; // rcx
  const char *v19; // rdi
  __int64 v20; // r15
  __int64 v21; // rsi
  __int64 v22; // rax
  __int64 v23; // rsi
  __int64 v24; // rsi
  __int64 v25; // rax
  __int64 *v26; // rbx
  const char *v27; // rsi
  __int64 v28; // rax
  unsigned int v29; // er11
  __int64 v30; // rax
  const char *v31; // rsi
  unsigned int v32; // er12
  unsigned int v33; // edi
  int v34; // er11
  __int64 v35; // r15
  __int64 v36; // rsi
  int v37; // er13
  int v38; // er11
  int v39; // eax
  int v40; // er10
  void *v41; // rsp
  int v42; // er13
  __int64 v43; // rsi
  __int64 v44; // r15
  _DWORD *v45; // r15
  __int64 v46; // rsi
  __int64 v47; // rax
  __int64 v48; // rax
  unsigned __int64 v49; // rax
  unsigned __int64 v50; // rdi
  __int64 v51; // [rsp+0h] [rbp-1088h]
  __int64 v52; // [rsp+8h] [rbp-1080h] BYREF
  __int64 v53; // [rsp+10h] [rbp-1078h] BYREF
  _BYTE v54[12]; // [rsp+1008h] [rbp-80h] BYREF
  unsigned int v55; // [rsp+1014h] [rbp-74h]
  __int64 v56; // [rsp+1018h] [rbp-70h]
  __int64 v57; // [rsp+1020h] [rbp-68h]
  __int64 v58; // [rsp+1028h] [rbp-60h]
  unsigned __int64 v59; // [rsp+1030h] [rbp-58h]
  const char *v60; // [rsp+1038h] [rbp-50h]
  const char *v61; // [rsp+1040h] [rbp-48h]
  __int64 v62[7]; // [rsp+1050h] [rbp-38h] BYREF

  if ( (dl_debug_mask & 1) != 0 )
    dl_debug_printf(" search cache=%s\n", "/etc/ld.so.cache");
  whole_file = cache;
  if ( !cache )
  {
    whole_file = dl_sysdep_read_whole_file("/etc/ld.so.cache", &cachesize, 1u);
    if ( whole_file != -1 )
    {
      v3 = cachesize;
      if ( (unsigned __int64)cachesize > 0x10 )
      {
        if ( *(_QWORD *)whole_file == 0x2E312D6F732E646CLL
          && *(_WORD *)(whole_file + 8) == 11831
          && *(_BYTE *)(whole_file + 10) == 48 )
        {
          v48 = *(unsigned int *)(whole_file + 12);
          cache = whole_file;
          v49 = (12 * v48 + 23) & 0xFFFFFFFFFFFFFFF8LL;
          v50 = whole_file + v49;
          cache_new = whole_file + v49;
          if ( cachesize < v49 + 48
            || *(_QWORD *)v50 ^ 0x646C2D6362696C67LL | *(_QWORD *)(v50 + 8) ^ 0x686361632E6F732ELL
            || *(_DWORD *)(v50 + 16) != 825110885 )
          {
            cache_new = -1LL;
          }
          goto LABEL_6;
        }
        if ( (unsigned __int64)cachesize > 0x30
          && !(*(_QWORD *)whole_file ^ 0x646C2D6362696C67LL | *(_QWORD *)(whole_file + 8) ^ 0x686361632E6F732ELL)
          && *(_DWORD *)(whole_file + 16) == 825110885 )
        {
          cache_new = whole_file;
          cache = whole_file;
          goto LABEL_6;
        }
      }
      munmap(whole_file, cachesize);
    }
    cache = -1LL;
    return 0LL;
  }
  if ( cache == -1 )
    return 0LL;
  v3 = cachesize;
LABEL_6:
  v4 = cache_new;
  if ( cache_new == -1 )
  {
    v29 = *(_DWORD *)(whole_file + 12);
    v30 = 12LL * v29 + 16;
    v31 = (const char *)(v3 - v30);
    v61 = (const char *)(whole_file + v30);
    v32 = (unsigned int)v31;
    v33 = (unsigned int)v31;
    v60 = v31;
    v34 = v29 - 1;
    if ( v34 < 0 )
      return 0LL;
    v35 = v34 >> 1;
    v36 = *(unsigned int *)(whole_file + 12 * v35 + 20);
    if ( v33 <= (unsigned int)v36 )
      return 0LL;
    v37 = 0;
    while ( 1 )
    {
      v39 = dl_cache_libcmp(a1, (char *)&v61[v36]);
      if ( !v39 )
        break;
      if ( v39 >= 0 )
        v38 = v40 - 1;
      else
        v37 = v40 + 1;
      if ( v37 <= v38 )
      {
        v35 = (v37 + v38) >> 1;
        v36 = *(unsigned int *)(whole_file + 12 * v35 + 20);
        if ( v32 > (unsigned int)v36 )
          continue;
      }
      return 0LL;
    }
    if ( v40 )
    {
      v42 = v40 - 1;
      v43 = *(unsigned int *)(whole_file + 12LL * (v40 - 1) + 20);
      if ( (unsigned int)v60 <= (unsigned int)v43 )
      {
        v42 = v40;
      }
      else
      {
        v44 = whole_file + 12 * v35 - 4;
        while ( 1 )
        {
          LODWORD(v60) = v42 + 1;
          if ( (unsigned int)dl_cache_libcmp(a1, (char *)&v61[v43]) )
            break;
          if ( !v42 )
            goto LABEL_75;
          v44 -= 12LL;
          v43 = *(unsigned int *)(v44 + 12);
          if ( v32 <= (unsigned int)v43 )
            goto LABEL_75;
          --v42;
        }
        v42 = (int)v60;
      }
    }
    else
    {
      v42 = 0;
    }
LABEL_75:
    v60 = 0LL;
    LODWORD(v59) = dl_correct_cache_id;
    v45 = (_DWORD *)(whole_file + 12LL * v42 + 16);
    do
    {
      if ( v42 > v40 )
      {
        v46 = (unsigned int)v45[1];
        if ( (unsigned int)v46 >= v32 || (unsigned int)dl_cache_libcmp(a1, (char *)&v61[v46]) )
          break;
      }
      if ( *v45 == 771 )
      {
        v47 = (unsigned int)v45[2];
        if ( (unsigned int)v47 < v32 )
        {
          if ( v60 )
          {
            if ( (_DWORD)v59 == 771 )
            {
              v60 = &v61[v47];
              break;
            }
          }
          else
          {
            v60 = &v61[(unsigned int)v47];
            if ( (_DWORD)v59 == 771 )
              break;
          }
        }
      }
      ++v42;
      v45 += 3;
    }
    while ( v42 <= v38 );
  }
  else
  {
    v5 = dl_platform;
    v61 = (const char *)(whole_file + v3 - cache_new);
    v6 = whole_file + v3 - cache_new;
    if ( dl_platform )
    {
      if ( (unsigned int)j_strcmp_ifunc(dl_platform, "haswell") )
      {
        v7 = (unsigned int)j_strcmp_ifunc(v5, "xeon_phi") == 0;
        v8 = 0x8000000000000LL;
        if ( !v7 )
          v8 = -1LL;
        v56 = v8;
      }
      else
      {
        v56 = 0x4000000000000LL;
      }
    }
    else
    {
      v56 = -1LL;
    }
    _tunable_get_val(0x10u, v62, 0LL);
    v57 = v62[0];
    v60 = (const char *)cache_new;
    v58 = dl_hwcap;
    LODWORD(v59) = *(_DWORD *)(cache_new + 20);
    if ( (int)v59 - 1 < 0 )
      return 0LL;
    v9 = ((int)v59 - 1) >> 1;
    v10 = *(unsigned int *)(cache_new + 24 * v9 + 52);
    if ( (unsigned int)v10 >= (unsigned int)v61 )
      return 0LL;
    v11 = 0;
    while ( 1 )
    {
      v13 = dl_cache_libcmp(a1, (char *)(v4 + v10));
      if ( !v13 )
        break;
      if ( v13 >= 0 )
      {
        v12 = v14 - 1;
        if ( v14 - 1 < v11 )
          return 0LL;
      }
      else
      {
        v11 = v14 + 1;
        if ( v12 < v14 + 1 )
          return 0LL;
      }
      v9 = (v12 + v11) >> 1;
      v10 = *(unsigned int *)&v60[24 * v9 + 52];
      if ( v6 <= (unsigned int)v10 )
        return 0LL;
    }
    if ( v14 )
    {
      v16 = v14 - 1;
      v17 = *(unsigned int *)&v60[24 * v14 + 28];
      if ( (unsigned int)v61 <= (unsigned int)v17 )
      {
        v16 = v14;
      }
      else
      {
        v18 = &v60[24 * v9 + 4];
        while ( 1 )
        {
          v61 = v18;
          if ( (unsigned int)dl_cache_libcmp(a1, (char *)(v4 + v17)) )
            break;
          if ( !v16 )
            goto LABEL_29;
          v17 = *(unsigned int *)v61;
          v18 = v61 - 24;
          if ( v6 <= (unsigned int)v17 )
            goto LABEL_29;
          --v16;
        }
        ++v16;
      }
    }
    else
    {
      v16 = 0;
    }
LABEL_29:
    v19 = v60;
    v60 = 0LL;
    LODWORD(v61) = dl_correct_cache_id;
    v55 = dl_osversion;
    v20 = (__int64)&v19[24 * v16 + 48];
    v59 = ~(v57 & v58 | 0x800F000000000000LL);
    do
    {
      if ( v16 > v14 )
      {
        v21 = *(unsigned int *)(v20 + 4);
        if ( (unsigned int)v21 >= v6 || (unsigned int)dl_cache_libcmp(a1, (char *)(v4 + v21)) )
          break;
      }
      if ( *(_DWORD *)v20 == 771 )
      {
        v22 = *(unsigned int *)(v20 + 8);
        if ( (unsigned int)v22 < v6 && (!v60 || (_DWORD)v61 == 771) )
        {
          v23 = *(_QWORD *)(v20 + 16);
          if ( (v23 & v59) == 0 && (!v55 || v55 >= *(_DWORD *)(v20 + 12)) )
          {
            v24 = v23 & 0xF000000000000LL;
            if ( v24 == v56 || !v24 )
            {
              v60 = (const char *)(v4 + v22);
              if ( (_DWORD)v61 == 771 )
                break;
            }
          }
        }
      }
      ++v16;
      v20 += 24LL;
    }
    while ( v16 <= v12 );
  }
  if ( (dl_debug_mask & 1) != 0 )
  {
    if ( v60 )
    {
      dl_debug_printf("  trying file=%s\n", v60);
      goto LABEL_46;
    }
    return 0LL;
  }
  if ( !v60 )
    return 0LL;
LABEL_46:
  v25 = j_strlen_ifunc(v60);
  v26 = (__int64 *)&v54[-((v25 + 24) & 0xFFFFFFFFFFFFF000LL)];
  if ( v54 != (_BYTE *)v26 )
  {
    while ( &v52 != v26 )
      ;
  }
  if ( (((_WORD)v25 + 24) & 0xFF0) != 0 )
  {
    v41 = alloca(((_WORD)v25 + 24) & 0xFF0);
    *(__int64 *)((char *)&v51 + (((_WORD)v25 + 24) & 0xFF0)) = *(__int64 *)((char *)&v51 + (((_WORD)v25 + 24) & 0xFF0));
  }
  v27 = v60;
  v28 = j_memcpy(&v53, v60, v25 + 1);
  return strdup(v28, (__int64)v27);
}
// 4704D0: variable 'v14' is possibly undefined
// 4704D9: variable 'v12' is possibly undefined
// 470758: variable 'v40' is possibly undefined
// 47075F: variable 'v38' is possibly undefined
// 401040: using guessed type __int64 __fastcall j_memcpy(_QWORD, _QWORD, _QWORD);
// 4010A0: using guessed type __int64 __fastcall j_strcmp_ifunc(_QWORD, _QWORD);
// 4010C8: using guessed type __int64 __fastcall j_strlen_ifunc(_QWORD);
// 4A91F0: using guessed type int dl_correct_cache_id;
// 4AADE8: using guessed type __int64 dl_hwcap;
// 4AB060: using guessed type __int64 cachesize;
// 4AB068: using guessed type __int64 cache_new;
// 4AB070: using guessed type __int64 cache;
// 4AB880: using guessed type int dl_debug_mask;
// 4AB8A8: using guessed type __int64 dl_platform;
// 4AB928: using guessed type int dl_osversion;
// 4703C0: using guessed type __int64 var_38[7];

//----- (0000000000470A80) ----------------------------------------------------
unsigned __int64 dl_unload_cache()
{
  unsigned __int64 result; // rax

  result = cache - 1;
  if ( (unsigned __int64)(cache - 1) <= 0xFFFFFFFFFFFFFFFDLL )
  {
    result = munmap(cache, cachesize);
    cache = 0LL;
  }
  return result;
}
// 4AB060: using guessed type __int64 cachesize;
// 4AB070: using guessed type __int64 cache;

//----- (0000000000470AC0) ----------------------------------------------------
__int64 __fastcall dl_tlsdesc_return()
{
  __int64 v0; // rax

  return *(_QWORD *)(v0 + 8);
}
// 470AC4: variable 'v0' is possibly undefined
// 470AC0: using guessed type __int64 __fastcall dl_tlsdesc_return();

//----- (0000000000470AD0) ----------------------------------------------------
unsigned __int64 __fastcall dl_tlsdesc_undefweak()
{
  __int64 v0; // rax

  return *(_QWORD *)(v0 + 8) - __readfsqword(0);
}
// 470AD4: variable 'v0' is possibly undefined

//----- (0000000000470AF0) ----------------------------------------------------
// positive sp value has been detected, the output may be wrong!
__int64 __fastcall dl_tlsdesc_resolve_rela(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6,
        double a7,
        double a8,
        double a9,
        double a10,
        double a11,
        double a12,
        double a13,
        double a14)
{
  __int64 v14; // rax
  __int64 (__fastcall **v16)(__int64, __int64, __int64, __int64, __int64, __int64); // [rsp-8h] [rbp-58h]
  __int64 v21; // [rsp+48h] [rbp-8h]

  v16 = (__int64 (__fastcall **)(__int64, __int64, __int64, __int64, __int64, __int64))v14;
  dl_tlsdesc_resolve_rela_fixup(v14, v21, a7, a8, a9, a10, a11, a12, a13, a14);
  return (*v16)(a1, a2, a3, a4, a5, a6);
}
// 470B61: positive sp value 8 has been found
// 470AF8: variable 'v14' is possibly undefined
// 470B2C: variable 'v21' is possibly undefined

//----- (0000000000470B70) ----------------------------------------------------
__int64 __fastcall dl_tlsdesc_resolve_hold(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v6; // rax
  __int64 (__fastcall **v8)(__int64, __int64, __int64, __int64, __int64, __int64); // [rsp+0h] [rbp-48h]

  v8 = (__int64 (__fastcall **)(__int64, __int64, __int64, __int64, __int64, __int64))v6;
  dl_tlsdesc_resolve_hold_fixup(v6);
  return (*v8)(a1, a2, a3, a4, a5, a6);
}
// 470B78: variable 'v6' is possibly undefined

//----- (0000000000470BF0) ----------------------------------------------------
__int64 __fastcall do_dlopen(__int64 a1)
{
  __int64 v2; // [rsp-8h] [rbp-18h]

  *(_QWORD *)(a1 + 24) = dl_open(
                           *(void **)a1,
                           *(_DWORD *)(a1 + 8),
                           *(_QWORD *)(a1 + 16),
                           -2LL,
                           (unsigned int)_libc_argc,
                           _libc_argv,
                           (__int64)environ);
  return v2;
}
// 470C2A: variable 'v2' is possibly undefined
// 4AB958: using guessed type int _libc_argc;
// 4AB960: using guessed type __int64 _libc_argv;

//----- (0000000000470C30) ----------------------------------------------------
__int64 __fastcall dlerror_run(
        void (__fastcall *a1)(__int64),
        __int64 a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6)
{
  __int64 result; // rax
  __int64 v7; // rdx
  __int64 v8; // rcx
  u32 *v9; // r8
  unsigned __int64 v10; // r9
  unsigned int v11; // [rsp+Ch] [rbp-2Ch]
  bool v12; // [rsp+17h] [rbp-21h] BYREF
  __int64 v13; // [rsp+18h] [rbp-20h] BYREF
  __int64 v14[3]; // [rsp+20h] [rbp-18h] BYREF

  v14[1] = __readfsqword(0x28u);
  v14[0] = 0LL;
  result = dl_catch_error(&v13, v14, &v12, a1, a2, a6);
  if ( !(_DWORD)result )
  {
    if ( !v14[0] )
      return result;
    result = 1LL;
  }
  if ( v12 )
  {
    v11 = result;
    free(v14[0], (__int64)v14, v7, v8, v9, v10);
    return v11;
  }
  return result;
}
// 470CA0: variable 'v7' is possibly undefined
// 470CA0: variable 'v8' is possibly undefined
// 470CA0: variable 'v9' is possibly undefined
// 470CA0: variable 'v10' is possibly undefined

//----- (0000000000470CB0) ----------------------------------------------------
__int64 __fastcall _libc_dlclose(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  return dlerror_run(do_dlclose, a1, a3, a4, a5, a6);
}

//----- (0000000000470CD0) ----------------------------------------------------
__int64 __fastcall _libc_dlsym(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  int v6; // eax
  __int64 v7; // rdx
  __int64 v8; // rax
  __int64 v10[2]; // [rsp+0h] [rbp-38h] BYREF
  __int64 *v11; // [rsp+10h] [rbp-28h]
  __int64 v12; // [rsp+18h] [rbp-20h]
  unsigned __int64 v13; // [rsp+28h] [rbp-10h]

  v13 = __readfsqword(0x28u);
  v10[0] = a1;
  v10[1] = a2;
  v6 = dlerror_run((void (__fastcall *)(__int64))do_dlsym, (__int64)v10, a3, a4, a5, a6);
  v7 = 0LL;
  if ( !v6 )
  {
    v7 = v12;
    if ( v12 )
    {
      if ( *(_WORD *)(v12 + 6) == 0xFFF1 )
      {
        v8 = 0LL;
      }
      else
      {
        v8 = 0LL;
        if ( v11 )
          v8 = *v11;
      }
      return *(_QWORD *)(v12 + 8) + v8;
    }
  }
  return v7;
}

//----- (0000000000470D60) ----------------------------------------------------
__int64 __fastcall _libc_dlvsym(__int64 a1, __int64 a2, unsigned __int8 *a3, __int64 a4, __int64 a5, __int64 a6)
{
  unsigned __int64 v6; // rax
  __int64 v7; // rsi
  __int64 v8; // rax
  int v9; // eax
  __int64 v10; // rdx
  __int64 v11; // rax
  __int64 v13[2]; // [rsp+0h] [rbp-48h] BYREF
  __int64 *v14; // [rsp+10h] [rbp-38h]
  __int64 v15; // [rsp+18h] [rbp-30h]
  unsigned __int8 *v16; // [rsp+20h] [rbp-28h]
  int v17; // [rsp+28h] [rbp-20h]
  int v18; // [rsp+2Ch] [rbp-1Ch]
  __int64 v19; // [rsp+30h] [rbp-18h]
  unsigned __int64 v20; // [rsp+38h] [rbp-10h]

  v20 = __readfsqword(0x28u);
  LODWORD(v6) = 0;
  v13[1] = a2;
  v7 = *a3;
  v13[0] = a1;
  v16 = a3;
  v18 = 1;
  if ( v7 )
  {
    a4 = a3[1];
    if ( (_BYTE)a4 )
    {
      v8 = (unsigned __int8)a4;
      a4 = a3[2];
      v6 = 16 * v7 + v8;
      if ( (_BYTE)a4 )
      {
        v6 = a4 + 16 * v6;
        a4 = a3[3];
        if ( (_BYTE)a4 )
        {
          v6 = a4 + 16 * v6;
          a4 = a3[4];
          if ( (_BYTE)a4 )
          {
            v6 = a4 + 16 * v6;
            a4 = (__int64)(a3 + 5);
            a3 = (unsigned __int8 *)a3[5];
            if ( (_BYTE)a3 )
            {
              do
              {
                ++a4;
                v6 = ((unsigned __int64)&a3[16 * v6] >> 24) & 0xF0 ^ (unsigned __int64)&a3[16 * v6];
                a3 = (unsigned __int8 *)*(unsigned __int8 *)a4;
              }
              while ( (_BYTE)a3 );
              LODWORD(v6) = v6 & 0xFFFFFFF;
            }
          }
        }
      }
    }
    else
    {
      LODWORD(v6) = (unsigned __int8)v7;
    }
  }
  v17 = v6;
  v19 = 0LL;
  v9 = dlerror_run((void (__fastcall *)(__int64))do_dlvsym, (__int64)v13, (__int64)a3, a4, a5, a6);
  v10 = 0LL;
  if ( !v9 )
  {
    v10 = v15;
    if ( v15 )
    {
      if ( *(_WORD *)(v15 + 6) == 0xFFF1 )
      {
        v11 = 0LL;
      }
      else
      {
        v11 = 0LL;
        if ( v14 )
          v11 = *v14;
      }
      return *(_QWORD *)(v15 + 8) + v11;
    }
  }
  return v10;
}

//----- (0000000000470EB0) ----------------------------------------------------
unsigned __int64 __fastcall do_dlsym_private(
        __int64 a1,
        double a2,
        double a3,
        double a4,
        double a5,
        double a6,
        double a7,
        double a8,
        double a9)
{
  __int64 v9; // rsi
  __int64 *v10; // rcx
  const char *v12[3]; // [rsp+0h] [rbp-28h] BYREF
  unsigned __int64 v13; // [rsp+18h] [rbp-10h]

  v9 = *(_QWORD *)a1;
  v13 = __readfsqword(0x28u);
  v12[2] = 0LL;
  v12[0] = "GLIBC_PRIVATE";
  v10 = *(__int64 **)(v9 + 904);
  v12[1] = (const char *)0x10963CF85LL;
  *(_QWORD *)(a1 + 24) = 0LL;
  *(_QWORD *)(a1 + 16) = dl_lookup_symbol_x(
                           *(unsigned __int8 **)(a1 + 8),
                           v9,
                           (unsigned int **)(a1 + 24),
                           v10,
                           v12,
                           0,
                           a2,
                           a3,
                           a4,
                           a5,
                           a6,
                           a7,
                           a8,
                           a9,
                           0,
                           0LL);
  return __readfsqword(0x28u) ^ v13;
}

//----- (0000000000470F40) ----------------------------------------------------
__int64 __fastcall do_dlsym(
        __int64 a1,
        double a2,
        double a3,
        double a4,
        double a5,
        double a6,
        double a7,
        double a8,
        double a9)
{
  __int64 v9; // rsi
  __int64 v11; // [rsp-10h] [rbp-18h]

  v9 = *(_QWORD *)a1;
  *(_QWORD *)(a1 + 24) = 0LL;
  *(_QWORD *)(a1 + 16) = dl_lookup_symbol_x(
                           *(unsigned __int8 **)(a1 + 8),
                           v9,
                           (unsigned int **)(a1 + 24),
                           (__int64 *)(v9 + 912),
                           0LL,
                           0,
                           a2,
                           a3,
                           a4,
                           a5,
                           a6,
                           a7,
                           a8,
                           a9,
                           2,
                           0LL);
  return v11;
}
// 470F75: variable 'v11' is possibly undefined

//----- (0000000000470F80) ----------------------------------------------------
__int64 __fastcall do_dlvsym(
        __int64 a1,
        double a2,
        double a3,
        double a4,
        double a5,
        double a6,
        double a7,
        double a8,
        double a9)
{
  __int64 v9; // rsi
  __int64 v11; // [rsp-10h] [rbp-18h]

  v9 = *(_QWORD *)a1;
  *(_QWORD *)(a1 + 24) = 0LL;
  *(_QWORD *)(a1 + 16) = dl_lookup_symbol_x(
                           *(unsigned __int8 **)(a1 + 8),
                           v9,
                           (unsigned int **)(a1 + 24),
                           (__int64 *)(v9 + 912),
                           (const char **)(a1 + 32),
                           0,
                           a2,
                           a3,
                           a4,
                           a5,
                           a6,
                           a7,
                           a8,
                           a9,
                           0,
                           0LL);
  return v11;
}
// 470FB6: variable 'v11' is possibly undefined

//----- (0000000000470FC0) ----------------------------------------------------
void __fastcall do_dlclose(__int64 a1)
{
  dl_close(a1);
}

//----- (0000000000470FD0) ----------------------------------------------------
__int64 __fastcall _libc_dlsym_private(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  int v6; // eax
  __int64 v7; // rdx
  __int64 v8; // rax
  __int64 v10[2]; // [rsp+0h] [rbp-38h] BYREF
  __int64 *v11; // [rsp+10h] [rbp-28h]
  __int64 v12; // [rsp+18h] [rbp-20h]
  unsigned __int64 v13; // [rsp+28h] [rbp-10h]

  v13 = __readfsqword(0x28u);
  v10[0] = a1;
  v10[1] = a2;
  v6 = dlerror_run((void (__fastcall *)(__int64))do_dlsym_private, (__int64)v10, a3, a4, a5, a6);
  v7 = 0LL;
  if ( !v6 )
  {
    v7 = v12;
    if ( v12 )
    {
      if ( *(_WORD *)(v12 + 6) == 0xFFF1 )
      {
        v8 = 0LL;
      }
      else
      {
        v8 = 0LL;
        if ( v11 )
          v8 = *v11;
      }
      return *(_QWORD *)(v12 + 8) + v8;
    }
  }
  return v7;
}

//----- (0000000000471060) ----------------------------------------------------
_QWORD *__fastcall _libc_register_dl_open_hook(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  _QWORD *v6; // rax
  __int64 (__fastcall **v7)(); // rdx
  __int64 v8; // rcx
  __int64 v9; // r8
  __int64 v10; // r9
  _QWORD *result; // rax

  v6 = (_QWORD *)_libc_dlsym_private(a1, (__int64)"_dl_open_hook", a3, a4, a5, a6);
  if ( v6 )
  {
    v7 = dl_open_hook;
    *v6 = dl_open_hook;
  }
  result = (_QWORD *)_libc_dlsym_private(a1, (__int64)"_dl_open_hook2", (__int64)v7, v8, v9, v10);
  if ( result )
    *result = dl_open_hook;
  return result;
}
// 47108D: variable 'v7' is possibly undefined
// 47108D: variable 'v8' is possibly undefined
// 47108D: variable 'v9' is possibly undefined
// 47108D: variable 'v10' is possibly undefined
// 4A9B60: using guessed type __int64 (__fastcall *dl_open_hook[13])();

//----- (00000000004710B0) ----------------------------------------------------
__int64 __fastcall _libc_dlopen_mode(__int64 a1, int a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  int v6; // eax
  __int64 v7; // rcx
  __int64 v8; // r8
  __int64 v9; // r9
  __int64 v10; // rdx
  __int64 v11; // rdx
  __int64 v12; // rcx
  __int64 v13; // r8
  __int64 v14; // r9
  __int64 v16; // [rsp+0h] [rbp-38h] BYREF
  int v17; // [rsp+8h] [rbp-30h]
  __int64 v18; // [rsp+10h] [rbp-28h]
  __int64 v19; // [rsp+18h] [rbp-20h]
  unsigned __int64 v20; // [rsp+28h] [rbp-10h]
  __int64 retaddr; // [rsp+38h] [rbp+0h]

  v20 = __readfsqword(0x28u);
  v16 = a1;
  v17 = a2;
  v18 = retaddr;
  v6 = dlerror_run((void (__fastcall *)(__int64))do_dlopen, (__int64)&v16, a3, a4, a5, a6);
  v10 = 0LL;
  if ( !v6 )
  {
    _libc_register_dl_open_hook(v19, (__int64)&v16, 0LL, v7, v8, v9);
    _libc_register_dlfcn_hook(v19, (__int64)&v16, v11, v12, v13, v14);
    return v19;
  }
  return v10;
}
// 4710F4: variable 'v7' is possibly undefined
// 4710F4: variable 'v8' is possibly undefined
// 4710F4: variable 'v9' is possibly undefined
// 4710FE: variable 'v11' is possibly undefined
// 4710FE: variable 'v12' is possibly undefined
// 4710FE: variable 'v13' is possibly undefined
// 4710FE: variable 'v14' is possibly undefined

//----- (0000000000471130) ----------------------------------------------------
void __fastcall __noreturn fatal_error(int a1, const char *a2, const char *a3, const char *a4)
{
  unsigned __int8 *v7; // rax
  const char *v8; // rsi
  const char *v9; // r9
  const char *v10; // rdx
  const char *v11; // [rsp+8h] [rbp-430h]
  char v12[1032]; // [rsp+10h] [rbp-428h] BYREF
  unsigned __int64 v13; // [rsp+418h] [rbp-20h]

  v13 = __readfsqword(0x28u);
  v7 = byte_493255;
  v8 = (const char *)byte_493255;
  if ( a1 )
  {
    v11 = a2;
    v7 = strerror_r(a1, (__int64)v12, 0x400uLL);
    v8 = ": ";
    a2 = v11;
  }
  v9 = ": ";
  if ( !*a2 )
    v9 = (const char *)byte_493255;
  if ( !a3 )
    a3 = "error while loading shared libraries";
  v10 = (const char *)program_invocation_short_name[0];
  if ( !program_invocation_short_name[0] )
    v10 = "<program name unknown>";
  dl_dprintf(2, "%s: %s: %s%s%s%s%s\n", v10, a3, a2, v9, a4, v8, (const char *)v7);
  exit(127);
}
// 493255: using guessed type unsigned __int8 byte_493255[1707];
// 4A9168: using guessed type char (*program_invocation_short_name[2])[1707];
// 471130: using guessed type char var_428[1032];

//----- (00000000004711F0) ----------------------------------------------------
void __fastcall __noreturn dl_signal_exception(int a1, const __m128i *a2, const char *a3)
{
  unsigned __int64 v3; // rax
  __m128i *v4; // rdx

  v3 = __readfsqword(0xFFFFFFF8);
  if ( v3 )
  {
    v4 = *(__m128i **)v3;
    *v4 = _mm_loadu_si128(a2);
    v4[1].m128i_i64[0] = a2[1].m128i_i64[0];
    **(_DWORD **)(v3 + 8) = a1;
    _longjmp((struct __jmp_buf_tag *)(v3 + 16), 1);
  }
  fatal_error(a1, (const char *)a2->m128i_i64[0], a3, (const char *)a2->m128i_i64[1]);
}

//----- (0000000000471240) ----------------------------------------------------
void __fastcall __noreturn dl_signal_error(int a1, void *a2, const char *a3, const char *a4)
{
  unsigned __int64 v4; // rbx

  v4 = __readfsqword(0xFFFFFFF8);
  if ( !a4 )
    a4 = "DYNAMIC LINKER BUG!!!";
  if ( v4 )
  {
    dl_exception_create(*(const char ***)v4, a2, (__int64)a4);
    **(_DWORD **)(v4 + 8) = a1;
    _longjmp((struct __jmp_buf_tag *)(v4 + 16), 1);
  }
  fatal_error(a1, (const char *)a2, a3, a4);
}

//----- (0000000000471290) ----------------------------------------------------
__int64 __fastcall dl_catch_exception(
        __int64 a1,
        void (__fastcall *a2)(__int64),
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6)
{
  unsigned __int64 v6; // rcx
  unsigned int v7; // ebx
  unsigned __int64 v9; // [rsp+0h] [rbp-118h]
  unsigned int v11; // [rsp+2Ch] [rbp-ECh] BYREF
  __int64 v12[2]; // [rsp+30h] [rbp-E8h] BYREF
  char v13[200]; // [rsp+40h] [rbp-D8h] BYREF
  unsigned __int64 v14; // [rsp+108h] [rbp-10h]

  v14 = __readfsqword(0x28u);
  v12[1] = (__int64)&v11;
  v12[0] = a1;
  v6 = __readfsqword(0xFFFFFFF8);
  __writefsqword(0xFFFFFFF8, (unsigned __int64)v12);
  if ( (unsigned int)_sigsetjmp(v13, 0, a3, v6, a5, a6, v6) )
  {
    __writefsqword(0xFFFFFFF8, v9);
    return v11;
  }
  else
  {
    v7 = 0;
    a2(a3);
    __writefsqword(0xFFFFFFF8, v9);
    *(_QWORD *)(a1 + 16) = 0LL;
    *(_OWORD *)a1 = 0LL;
  }
  return v7;
}
// 471316: variable 'v9' is possibly undefined
// 471290: using guessed type char var_D8[200];

//----- (0000000000471370) ----------------------------------------------------
__int64 __fastcall dl_catch_error(
        _QWORD *a1,
        _QWORD *a2,
        bool *a3,
        void (__fastcall *a4)(__int64),
        __int64 a5,
        __int64 a6)
{
  __int64 result; // rax
  bool v8; // zf
  __int64 v9; // [rsp+0h] [rbp-38h] BYREF
  __int64 v10; // [rsp+8h] [rbp-30h]
  __int64 v11; // [rsp+10h] [rbp-28h]
  unsigned __int64 v12; // [rsp+18h] [rbp-20h]

  v12 = __readfsqword(0x28u);
  result = dl_catch_exception((__int64)&v9, a4, a5, (__int64)a4, a5, a6);
  *a1 = v9;
  v8 = v11 == v10;
  *a2 = v10;
  *a3 = v8;
  return result;
}

//----- (00000000004713E0) ----------------------------------------------------
void __noreturn _longjmp(struct __jmp_buf_tag env[1], int val)
{
  void (*v2)(void); // rdx
  __int64 v4; // rax
  unsigned __int64 v5; // rax
  bool v7; // cc

  v2 = (void (*)(void))(__readfsqword(0x30u) ^ __ROR8__(env->__jmpbuf[7], 17));
  __asm { rdsspq  rax }
  v4 = _RAX - env->__saved_mask.__val[2];
  if ( v4 )
  {
    v5 = ((unsigned __int64)-v4 >> 3) + 1;
    _RBX = 255LL;
    do
    {
      if ( v5 < _RBX )
        _RBX = v5;
      __asm { incsspq rbx }
      v7 = v5 <= _RBX;
      v5 -= _RBX;
    }
    while ( !v7 );
  }
  v2();
}

//----- (0000000000471470) ----------------------------------------------------
__int64 __fastcall _mpn_cmp(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v3; // rdx
  unsigned __int64 v4; // rax
  unsigned __int64 v5; // rcx

  v3 = a3 - 1;
  if ( v3 < 0 )
    return 0LL;
  while ( 1 )
  {
    v4 = *(_QWORD *)(a1 + 8 * v3);
    v5 = *(_QWORD *)(a2 + 8 * v3);
    if ( v4 != v5 )
      break;
    if ( --v3 == -1 )
      return 0LL;
  }
  return v5 < v4 ? 1 : -1;
}

//----- (00000000004714B0) ----------------------------------------------------
__int64 __fastcall _mpn_divrem(__int64 a1, __int64 a2, unsigned __int64 *a3, __int64 a4, __int64 *a5, __int64 a6)
{
  unsigned __int64 *v8; // r15
  unsigned __int64 v9; // rbp
  unsigned __int64 *v10; // r14
  __int64 v11; // r12
  unsigned __int64 v12; // rcx
  __int64 v13; // rbx
  unsigned __int64 v14; // r13
  __int64 i; // rbp
  unsigned __int64 v16; // rbx
  unsigned __int128 v17; // rtt
  unsigned __int64 v18; // rcx
  unsigned __int64 v19; // rax
  unsigned __int64 v20; // rsi
  bool v21; // cf
  unsigned __int64 v22; // r8
  unsigned __int64 v23; // rdx
  __int64 v24; // rdi
  __int64 v25; // rcx
  __int64 v26; // rcx
  unsigned __int128 v27; // rtt
  __int64 v28; // rcx
  __int64 v29; // rdi
  unsigned __int128 v30; // rtt
  unsigned __int64 *v32; // rax
  unsigned __int64 v33; // rdx
  unsigned __int64 *v34; // r12
  __int64 v35; // r11
  __int64 v36; // rbp
  unsigned __int64 v37; // r8
  unsigned __int64 v38; // r9
  __int64 v39; // rbx
  unsigned __int64 v40; // rcx
  unsigned __int64 v41; // r8
  unsigned __int128 v42; // rtt
  unsigned __int64 v43; // r9
  unsigned __int128 v44; // rax
  int v45; // eax
  unsigned __int64 v47; // [rsp+10h] [rbp-78h]
  unsigned __int64 v48; // [rsp+10h] [rbp-78h]
  __int64 v51; // [rsp+30h] [rbp-58h]
  __int64 v52; // [rsp+38h] [rbp-50h]
  __int64 v53; // [rsp+40h] [rbp-48h]
  __int64 v54; // [rsp+48h] [rbp-40h]

  if ( a6 != 1 )
  {
    if ( a6 != 2 )
    {
      if ( !a6 )
        BUG();
      v8 = &a3[a4 - a6];
      v9 = a5[a6 - 1];
      v10 = &v8[a6 - 1];
      v51 = a6;
      v11 = a5[a6 - 2];
      v12 = *v10;
      v53 = 8 * a6 - 8;
      v54 = 8 * a6 - 16;
      v52 = 0LL;
      if ( v9 <= *v10 )
      {
        if ( v9 < v12 || (v48 = *v10, v45 = _mpn_cmp((__int64)v8, (__int64)a5, a6 - 1), v12 = v48, v45 >= 0) )
        {
          _mpn_sub_n((__int64)v8, v8, a5, a6);
          v12 = *v10;
          v52 = 1LL;
        }
      }
      v13 = a2 + a4 - a6 - 1;
      if ( v13 >= 0 )
      {
        v14 = v9;
        for ( i = v13; i != -1; --i )
        {
          if ( a2 > i )
          {
            v47 = *v10;
            v32 = &v8[v51];
            if ( a6 > 0 )
            {
              do
              {
                v33 = *--v32;
                v32[1] = v33;
              }
              while ( v8 != v32 );
            }
            *v8 = 0LL;
          }
          else
          {
            --v8;
            v47 = v8[v51];
            v10 = (unsigned __int64 *)((char *)v8 + v53);
          }
          v16 = -1LL;
          if ( v14 != v12 )
          {
            *(_QWORD *)&v17 = *v10;
            *((_QWORD *)&v17 + 1) = v12;
            v16 = v17 / v14;
            v18 = v17 % v14;
            v19 = v16 * v11;
            v20 = (v16 * (unsigned __int128)(unsigned __int64)v11) >> 64;
            while ( v20 > v18 || v20 == v18 && *(unsigned __int64 *)((char *)v8 + v54) < v19 )
            {
              --v16;
              v21 = __CFADD__(v14, v18);
              v18 += v14;
              if ( v21 )
                break;
              v20 = (__PAIR128__(v20, v19) - (unsigned __int64)v11) >> 64;
              v19 -= v11;
            }
          }
          if ( v47 != _mpn_submul_1(v8, (unsigned __int64 *)a5, a6, v16) )
          {
            --v16;
            _mpn_add_n((__int64)v8, (__int64 *)v8, a5, a6);
          }
          *(_QWORD *)(a1 + 8 * i) = v16;
          v12 = *v10;
        }
      }
      return v52;
    }
    v34 = &a3[a4 - 2];
    v35 = a5[1];
    v36 = *a5;
    v52 = 0LL;
    v37 = v34[1];
    v38 = *v34;
    if ( __PAIR128__(v35, v36) <= __PAIR128__(v37, v38) )
    {
      v37 = (__PAIR128__(v37, v38) - __PAIR128__(v35, v36)) >> 64;
      v38 -= v36;
      v52 = 1LL;
    }
    v39 = a2 + a4 - 3;
    if ( v39 < 0 )
    {
LABEL_46:
      v34[1] = v37;
      *v34 = v38;
      return v52;
    }
    while ( 1 )
    {
      if ( a2 <= v39 )
      {
        v40 = *--v34;
        if ( v35 != v37 )
          goto LABEL_42;
      }
      else
      {
        *v34 = 0LL;
        v40 = 0LL;
        if ( v35 != v37 )
        {
LABEL_42:
          *(_QWORD *)&v42 = v38;
          *((_QWORD *)&v42 + 1) = v37;
          v43 = v42 / (unsigned __int64)v35;
          v41 = v42 % (unsigned __int64)v35;
          v44 = v43 * (unsigned __int128)(unsigned __int64)v36;
          goto LABEL_43;
        }
      }
      v41 = v35 + v38;
      if ( __CFADD__(v35, v38) )
      {
        *(_QWORD *)(a1 + 8 * v39--) = -1LL;
        v38 = v36 + v40;
        v37 = __CFADD__(v36, v40) + v41 - v36;
        if ( v39 == -1 )
          goto LABEL_46;
      }
      else
      {
        v43 = -1LL;
        *((_QWORD *)&v44 + 1) = v36 - (v36 != 0);
        *(_QWORD *)&v44 = -v36;
        do
        {
LABEL_43:
          if ( v44 <= __PAIR128__(v41, v40) )
            break;
          --v43;
          v44 -= (unsigned __int64)v36;
          v21 = __CFADD__(v35, v41);
          v41 += v35;
        }
        while ( !v21 );
        *(_QWORD *)(a1 + 8 * v39--) = v43;
        v37 = (__PAIR128__(v41, v40) - v44) >> 64;
        v38 = v40 - v44;
        if ( v39 == -1 )
          goto LABEL_46;
      }
    }
  }
  v22 = *a5;
  v23 = a3[a4 - 1];
  v52 = 0LL;
  if ( v22 <= v23 )
  {
    v52 = 1LL;
    v23 -= v22;
  }
  v24 = 8 * a2 + a1;
  v25 = a4 - 2;
  if ( v25 >= 0 )
  {
    v26 = v25;
    do
    {
      *(_QWORD *)&v27 = a3[v26];
      *((_QWORD *)&v27 + 1) = v23;
      v23 = v27 % v22;
      *(_QWORD *)(v24 + v26 * 8) = v27 / v22;
      --v26;
    }
    while ( v26 != -1 );
  }
  if ( a2 > 0 )
  {
    v28 = v24 - 8;
    v29 = v24 - 8 * a2 - 8;
    do
    {
      v28 -= 8LL;
      *(_QWORD *)&v30 = 0LL;
      *((_QWORD *)&v30 + 1) = v23;
      v23 = v30 % v22;
      *(_QWORD *)(v28 + 8) = v30 / v22;
    }
    while ( v29 != v28 );
  }
  *a3 = v23;
  return v52;
}

//----- (00000000004718B0) ----------------------------------------------------
unsigned __int64 __fastcall _mpn_lshift(__int64 a1, __int64 a2, unsigned __int64 a3, char a4)
{
  unsigned __int64 *v4; // rdi
  unsigned __int64 *v5; // rsi
  unsigned int v6; // eax
  unsigned __int64 v7; // r10
  unsigned __int64 v8; // r11
  unsigned __int64 result; // rax
  unsigned __int64 v10; // r8
  unsigned __int64 v11; // rdx
  unsigned __int64 v12; // r9
  bool v13; // cf

  v4 = (unsigned __int64 *)(a1 + 8 * a3 - 8);
  v5 = (unsigned __int64 *)(a2 + 8 * a3 - 8);
  v6 = a3 & 3;
  if ( (a3 & 3) == 0 )
  {
    v7 = *v5;
    v8 = *(v5 - 1);
    result = *v5 >> (64 - a4);
    v10 = *(v5 - 2);
    v4 += 3;
    v11 = a3 - 4;
    while ( 1 )
    {
      v12 = *(v5 - 3);
      *(v4 - 3) = (v7 << a4) | (v8 >> (64 - a4));
      v5 -= 4;
      v4 -= 4;
      v13 = v11 < 4;
      v11 -= 4LL;
      if ( v13 )
        break;
LABEL_12:
      v7 = *v5;
      *v4 = (v8 << a4) | (v10 >> (64 - a4));
LABEL_13:
      v8 = *(v5 - 1);
      *(v4 - 1) = (v10 << a4) | (v12 >> (64 - a4));
LABEL_14:
      v10 = *(v5 - 2);
      *(v4 - 2) = (v12 << a4) | (v7 >> (64 - a4));
    }
    goto LABEL_16;
  }
  if ( v6 >= 2 )
  {
    if ( v6 != 2 )
    {
      v8 = *v5;
      v10 = *(v5 - 1);
      result = *v5 >> (64 - a4);
      v12 = *(v5 - 2);
      v5 -= 3;
      v13 = a3 < 4;
      v11 = a3 - 4;
      if ( !v13 )
        goto LABEL_12;
LABEL_16:
      *v4 = (v8 << a4) | (v10 >> (64 - a4));
      *(v4 - 1) = (v10 << a4) | (v12 >> (64 - a4));
      *(v4 - 2) = v12 << a4;
      return result;
    }
    v10 = *v5;
    v12 = *(v5 - 1);
    result = *v5 >> (64 - a4);
    v13 = a3 < 3;
    v11 = a3 - 3;
    if ( !v13 )
    {
      v7 = *(v5 - 2);
      v5 -= 2;
      ++v4;
      goto LABEL_13;
    }
    *v4 = (v10 << a4) | (v12 >> (64 - a4));
    *(v4 - 1) = v12 << a4;
  }
  else
  {
    v12 = *v5;
    result = *v5 >> (64 - a4);
    v13 = a3 < 2;
    v11 = a3 - 2;
    if ( !v13 )
    {
      v7 = *(v5 - 1);
      v8 = *(v5 - 2);
      --v5;
      v4 += 2;
      goto LABEL_14;
    }
    *v4 = v12 << a4;
  }
  return result;
}

//----- (00000000004719D0) ----------------------------------------------------
unsigned __int64 __fastcall _mpn_rshift(unsigned __int64 *a1, unsigned __int64 *a2, unsigned __int64 a3, char a4)
{
  unsigned int v4; // eax
  unsigned __int64 v5; // r10
  unsigned __int64 v6; // r11
  unsigned __int64 result; // rax
  unsigned __int64 v8; // r8
  unsigned __int64 *v9; // rsi
  unsigned __int64 v10; // rdx
  unsigned __int64 v11; // r9
  bool v12; // cf

  v4 = a3 & 3;
  if ( (a3 & 3) == 0 )
  {
    v5 = *a2;
    v6 = a2[1];
    result = *a2 << (64 - a4);
    v8 = a2[2];
    v9 = a2 + 1;
    a1 -= 3;
    v10 = a3 - 4;
    while ( 1 )
    {
      v11 = v9[2];
      a1[3] = (v5 >> a4) | (v6 << (64 - a4));
      v9 += 4;
      a1 += 4;
      v12 = v10 < 4;
      v10 -= 4LL;
      if ( v12 )
        break;
LABEL_12:
      v5 = *(v9 - 1);
      *a1 = (v6 >> a4) | (v8 << (64 - a4));
LABEL_13:
      v6 = *v9;
      a1[1] = (v8 >> a4) | (v11 << (64 - a4));
LABEL_14:
      v8 = v9[1];
      a1[2] = (v11 >> a4) | (v5 << (64 - a4));
    }
    goto LABEL_16;
  }
  if ( v4 >= 2 )
  {
    if ( v4 != 2 )
    {
      v6 = *a2;
      v8 = a2[1];
      result = *a2 << (64 - a4);
      v11 = a2[2];
      v9 = a2 + 4;
      v12 = a3 < 4;
      v10 = a3 - 4;
      if ( !v12 )
        goto LABEL_12;
LABEL_16:
      *a1 = (v6 >> a4) | (v8 << (64 - a4));
      a1[1] = (v8 >> a4) | (v11 << (64 - a4));
      a1[2] = v11 >> a4;
      return result;
    }
    v8 = *a2;
    v11 = a2[1];
    result = *a2 << (64 - a4);
    v12 = a3 < 3;
    v10 = a3 - 3;
    if ( !v12 )
    {
      v5 = a2[2];
      v9 = a2 + 3;
      --a1;
      goto LABEL_13;
    }
    *a1 = (v8 >> a4) | (v11 << (64 - a4));
    a1[1] = v11 >> a4;
  }
  else
  {
    v11 = *a2;
    result = *a2 << (64 - a4);
    v12 = a3 < 2;
    v10 = a3 - 2;
    if ( !v12 )
    {
      v5 = a2[1];
      v6 = a2[2];
      v9 = a2 + 2;
      a1 -= 2;
      goto LABEL_14;
    }
    *a1 = v11 >> a4;
  }
  return result;
}

//----- (0000000000471AE0) ----------------------------------------------------
__int64 __fastcall _mpn_mul(_QWORD *a1, __int64 *a2, __int64 a3, unsigned __int64 *a4, __int64 a5)
{
  __int64 *v5; // r10
  _QWORD *v6; // r15
  __int64 v7; // r13
  __int64 result; // rax
  unsigned __int64 v10; // rcx
  _QWORD *v11; // rax
  _QWORD *v12; // rdx
  __int64 *v13; // rcx
  __int64 v14; // r14
  __int64 *v15; // r12
  unsigned __int64 *v16; // r10
  __int64 *v17; // rax
  void *v18; // rsp
  __int64 *v19; // r15
  __int64 v20; // r13
  __int64 *v21; // r14
  __int64 v22; // rax
  __int64 *v23; // rdx
  _BOOL8 v24; // rcx
  __int64 *v25; // rcx
  __int64 v26; // rsi
  __int64 v27; // rax
  __int64 *v28; // r14
  __int64 *v29; // rbx
  __int64 *v30; // r15
  __int64 v31; // r13
  unsigned __int64 *v32; // r12
  __int64 v33; // rax
  char *v34; // rcx
  __int64 v35; // rdx
  _BOOL8 v36; // rsi
  __int64 v37; // rax
  __int64 v38; // rax
  __int64 i; // rax
  void *v40; // rsp
  __int64 v41; // rsi
  __int64 v42; // rax
  __int64 v43; // [rsp+0h] [rbp-2088h]
  __int64 v44; // [rsp+8h] [rbp-2080h] BYREF
  __int64 v45[511]; // [rsp+10h] [rbp-2078h] BYREF
  __int64 v46; // [rsp+1008h] [rbp-1080h] BYREF
  __int64 v47[510]; // [rsp+1010h] [rbp-1078h] BYREF
  __int64 v48; // [rsp+2008h] [rbp-80h] BYREF
  _QWORD *v49; // [rsp+2010h] [rbp-78h]
  __int64 v50; // [rsp+2018h] [rbp-70h]
  __int64 *v51; // [rsp+2020h] [rbp-68h]
  __int64 v52; // [rsp+2028h] [rbp-60h]
  __int64 *v53; // [rsp+2030h] [rbp-58h]
  unsigned __int64 *v54; // [rsp+2038h] [rbp-50h]
  __int64 v55; // [rsp+2040h] [rbp-48h]
  unsigned __int64 v56; // [rsp+2050h] [rbp-38h]

  v5 = a2;
  v6 = a1;
  v7 = a3;
  v54 = a4;
  v56 = __readfsqword(0x28u);
  result = 0LL;
  if ( a5 <= 31 )
  {
    if ( !a5 )
      return result;
    v10 = *a4;
    if ( v10 > 1 )
    {
      result = _mpn_mul_1(a1, a2, a3, v10);
      v5 = a2;
    }
    else
    {
      if ( v10 != 1 )
      {
        v11 = a1;
        v12 = &a1[a3];
        if ( v7 > 0 )
        {
          do
            *v11++ = 0LL;
          while ( v12 != v11 );
        }
        goto LABEL_8;
      }
      if ( a3 <= 0 )
      {
LABEL_8:
        result = 0LL;
        goto LABEL_28;
      }
      for ( i = 0LL; i != a3; ++i )
        a1[i] = a2[i];
      result = 0LL;
    }
LABEL_28:
    a1[v7] = result;
    v28 = a1 + 1;
    if ( a5 > 1 )
    {
      v29 = &a1[a5];
      v55 = v7;
      v30 = v5;
      v31 = v7;
      v32 = v54 + 1;
      do
      {
        if ( *v32 <= 1 )
        {
          result = 0LL;
          if ( *v32 == 1 )
            result = _mpn_add_n((__int64)v28, v28, v30, v55);
        }
        else
        {
          result = _mpn_addmul_1(v28, (unsigned __int64 *)v30, v55, *v32);
        }
        v28[v31] = result;
        ++v28;
        ++v32;
      }
      while ( v29 != v28 );
    }
    return result;
  }
  v13 = (__int64 *)((char *)&v48 - ((16 * a5 + 23) & 0xFFFFFFFFFFFFF000LL));
  if ( &v48 != v13 )
  {
    while ( &v46 != v13 )
      ;
  }
  if ( ((16 * (_WORD)a5 + 23) & 0xFF0) != 0 )
  {
    v40 = alloca((16 * (_WORD)a5 + 23) & 0xFF0);
    *(__int64 *)((char *)&v45[510] + ((16 * (_WORD)a5 + 23) & 0xFF0)) = *(__int64 *)((char *)&v45[510]
                                                                                   + ((16 * (_WORD)a5 + 23) & 0xFF0));
  }
  v52 = 16 * a5 + 23;
  v53 = v47;
  v14 = a3 - a5;
  v51 = a2;
  _mpn_impn_mul_n(a1, a2, v54, a5, v47);
  v55 = 8 * a5;
  v15 = &a1[a5];
  v16 = (unsigned __int64 *)&v51[a5];
  if ( a5 <= v7 - a5 )
  {
    v17 = (__int64 *)((char *)&v47[-1] - (v52 & 0xFFFFFFFFFFFFF000LL));
    if ( &v46 != v17 )
    {
      while ( &v44 != v17 )
        ;
    }
    if ( (v52 & 0xFF0) != 0 )
    {
      v18 = alloca(v52 & 0xFF0);
      *(__int64 *)((char *)&v43 + (v52 & 0xFF0)) = *(__int64 *)((char *)&v43 + (v52 & 0xFF0));
    }
    v49 = a1;
    v50 = a5 - 1;
    v19 = &a1[a5];
    v48 = v7;
    v20 = v7 - a5;
    v52 = (__int64)v45 + v55;
    v21 = (__int64 *)v16;
    v51 = (__int64 *)((char *)&v45[1] + v55);
    while ( 1 )
    {
      _mpn_impn_mul_n(v45, v21, v54, a5, v53);
      v22 = _mpn_add_n((__int64)v19, v19, v45, a5);
      v19 = (__int64 *)((char *)v19 + v55);
      v23 = v19 + 1;
      v24 = __CFADD__(*(_QWORD *)v52, v22);
      *v19 = *(_QWORD *)v52 + v22;
      if ( v24 )
        break;
      v41 = v50;
      v25 = v51;
      if ( v23 != v51 )
        goto LABEL_49;
LABEL_23:
      v20 -= a5;
      v21 = (__int64 *)((char *)v21 + v55);
      if ( a5 > v20 )
      {
        v15 = v19;
        v16 = (unsigned __int64 *)v21;
        v6 = v49;
        v14 = v20;
        v7 = v48;
        goto LABEL_25;
      }
    }
    v25 = v51;
    v26 = a5 - 1;
    while ( 1 )
    {
      ++v25;
      ++v23;
      v27 = *(v25 - 1) + 1;
      *(v23 - 1) = v27;
      if ( v27 )
        break;
      if ( !--v26 )
        goto LABEL_23;
    }
    if ( v25 == v23 )
      goto LABEL_23;
    v41 = v26 - 1;
    if ( v41 <= 0 )
      goto LABEL_23;
LABEL_49:
    v42 = 0LL;
    do
    {
      v23[v42] = v25[v42];
      ++v42;
    }
    while ( v42 < v41 );
    goto LABEL_23;
  }
LABEL_25:
  if ( v14 )
  {
    _mpn_mul(v53, (__int64 *)v54, a5, v16, v14);
    v33 = _mpn_add_n((__int64)v15, v15, v53, a5);
    v34 = (char *)v53 + v55 + 8;
    v35 = (__int64)v15 + v55 + 8;
    v36 = __CFADD__(*(__int64 *)((char *)v53 + v55), v33);
    *(__int64 *)((char *)v15 + v55) = *(__int64 *)((char *)v53 + v55) + v33;
    if ( v36 )
    {
      while ( --v14 )
      {
        v34 += 8;
        v35 += 8LL;
        v38 = *((_QWORD *)v34 - 1) + 1LL;
        *(_QWORD *)(v35 - 8) = v38;
        if ( v38 )
          goto LABEL_36;
      }
    }
    else
    {
LABEL_36:
      if ( (char *)v35 != v34 && v14 > 1 )
      {
        v37 = 0LL;
        do
        {
          *(_QWORD *)(v35 + 8 * v37) = *(_QWORD *)&v34[8 * v37];
          ++v37;
        }
        while ( v37 != v14 - 1 );
      }
    }
  }
  return v6[v7 - 1 + a5];
}

//----- (0000000000471F40) ----------------------------------------------------
__int64 __fastcall _mpn_mul_1(_QWORD *a1, _QWORD *a2, __int64 a3, unsigned __int64 a4)
{
  unsigned __int128 v5; // rax
  __int64 v6; // r11
  _QWORD *v7; // rsi
  _QWORD *v8; // rdi
  __int64 v9; // r11
  unsigned __int64 v10; // r9
  unsigned __int64 v11; // rax
  unsigned __int64 v12; // r8
  unsigned __int64 v13; // rbx
  unsigned __int64 v14; // r8
  __int64 v15; // rbx
  unsigned __int64 v16; // r10
  unsigned __int64 v17; // r10
  unsigned __int64 v18; // rax
  unsigned __int64 v19; // r9
  unsigned __int64 v20; // kr00_8
  unsigned __int128 v21; // rax
  unsigned __int128 v22; // rax
  unsigned __int64 v23; // kr08_8
  unsigned __int128 v24; // rax

  v5 = 0 + a4 * (unsigned __int128)(unsigned __int64)*a2;
  switch ( a3 & 3 )
  {
    case 0LL:
      v7 = &a2[a3];
      v8 = &a1[a3 - 2];
      v9 = -a3;
      v13 = *((_QWORD *)&v5 + 1);
      v14 = v5;
      goto LABEL_12;
    case 2LL:
      v7 = &a2[a3 - 2];
      v8 = &a1[a3 - 4];
      v9 = -a3;
      v17 = v5;
      *(_QWORD *)&v5 = v7[v9 + 3];
      v19 = *((_QWORD *)&v5 + 1);
      goto LABEL_14;
    case 3LL:
      v7 = &a2[a3 - 1];
      v8 = &a1[a3 - 3];
      v9 = -a3;
      v16 = *((_QWORD *)&v5 + 1);
      v15 = v5;
      goto LABEL_13;
  }
  v6 = a3 - 1;
  if ( v6 )
  {
    v7 = &a2[v6 + 1];
    v8 = &a1[v6 - 1];
    v9 = -v6;
    v10 = v5;
    *(_QWORD *)&v5 = v7[v9];
    v12 = *((_QWORD *)&v5 + 1);
    while ( 1 )
    {
      v8[v9 + 1] = v10;
      v13 = (a4 * (unsigned __int128)v11 + v12) >> 64;
      v14 = a4 * v11 + v12;
LABEL_12:
      v21 = a4 * (unsigned __int128)(unsigned __int64)v7[v9 + 1];
      v8[v9 + 2] = v14;
      v16 = (v21 + v13) >> 64;
      v15 = v21 + v13;
LABEL_13:
      v22 = a4 * (unsigned __int128)(unsigned __int64)v7[v9 + 2];
      v8[v9 + 3] = v15;
      v23 = v22;
      v18 = v7[v9 + 3];
      v19 = (__PAIR128__(*((unsigned __int64 *)&v22 + 1), v23) + v16) >> 64;
      v17 = v23 + v16;
LABEL_14:
      v24 = a4 * (unsigned __int128)v18;
      v9 += 4LL;
      if ( v9 >= 0 )
        break;
      v8[v9] = v17;
      v20 = v24;
      v11 = v7[v9];
      v12 = (__PAIR128__(*((unsigned __int64 *)&v24 + 1), v20) + v19) >> 64;
      v10 = v20 + v19;
    }
    v8[v9] = v17;
    *((_QWORD *)&v5 + 1) = (v24 + v19) >> 64;
    v8[v9 + 1] = v24 + v19;
  }
  else
  {
    *a1 = a4 * *a2;
  }
  return *((_QWORD *)&v5 + 1);
}

//----- (0000000000472060) ----------------------------------------------------
__int64 __fastcall _mpn_impn_mul_n_basecase(_QWORD *a1, __int64 *a2, unsigned __int64 *a3, __int64 a4)
{
  _QWORD *v6; // rax
  __int64 result; // rax
  __int64 *v8; // r15
  __int64 *v9; // rbx
  unsigned __int64 *v10; // rbp
  __int64 i; // rax

  if ( *a3 > 1 )
  {
    result = _mpn_mul_1(a1, a2, a4, *a3);
  }
  else
  {
    if ( *a3 == 1 )
    {
      if ( a4 > 0 )
      {
        for ( i = 0LL; i != a4; ++i )
          a1[i] = a2[i];
      }
    }
    else
    {
      v6 = a1;
      if ( a4 > 0 )
      {
        do
          *v6++ = 0LL;
        while ( &a1[a4] != v6 );
      }
    }
    result = 0LL;
  }
  v8 = &a1[a4];
  v9 = a1 + 1;
  *v8 = result;
  if ( a4 > 1 )
  {
    v10 = a3 + 1;
    do
    {
      if ( *v10 <= 1 )
      {
        result = 0LL;
        if ( *v10 == 1 )
          result = _mpn_add_n((__int64)v9, v9, a2, a4);
      }
      else
      {
        result = _mpn_addmul_1(v9, (unsigned __int64 *)a2, a4, *v10);
      }
      v9[a4] = result;
      ++v9;
      ++v10;
    }
    while ( v8 != v9 );
  }
  return result;
}

//----- (0000000000472170) ----------------------------------------------------
__int64 __fastcall _mpn_impn_mul_n(__int64 *a1, __int64 *a2, unsigned __int64 *a3, __int64 a4, __int64 *a5)
{
  __int64 v7; // rbx
  __int64 v8; // rbx
  __int64 result; // rax
  __int64 v10; // rbp
  __int64 *v11; // r14
  __int64 v12; // rsi
  __int64 *v13; // r15
  unsigned __int64 *v14; // r15
  __int64 i; // rax
  _BOOL8 v16; // rax
  __int64 *v17; // r11
  __int64 v18; // rax
  bool v19; // cf
  __int64 v20; // rdi
  __int64 v21; // rax
  bool v22; // zf
  __int64 v23; // rax
  __int64 *v24; // r11
  __int64 v25; // rax
  __int64 v26; // rdi
  __int64 v27; // rax
  unsigned __int64 *v31; // [rsp+18h] [rbp-60h]
  __int64 v32; // [rsp+18h] [rbp-60h]
  __int64 v33; // [rsp+18h] [rbp-60h]
  int v34; // [rsp+28h] [rbp-50h]
  __int64 *v35; // [rsp+28h] [rbp-50h]
  __int64 v36; // [rsp+30h] [rbp-48h]

  v7 = a4 & 1;
  if ( (a4 & 1) != 0 )
  {
    v8 = a4 - 1;
    if ( a4 - 1 <= 31 )
      _mpn_impn_mul_n_basecase(a1, a2, a3, a4 - 1);
    else
      _mpn_impn_mul_n(a1, a2, a3, a4 - 1, a5);
    a1[2 * v8] = _mpn_addmul_1(&a1[v8], (unsigned __int64 *)a2, v8, a3[v8]);
    result = _mpn_addmul_1(&a1[v8], a3, a4, a2[v8]);
    a1[v8 + a4] = result;
    return result;
  }
  v10 = a4 >> 1;
  v36 = a4;
  v11 = &a1[a4];
  v12 = a4 >> 1;
  v13 = &a2[v12];
  v31 = &a3[v12];
  if ( a4 >> 1 <= 31 )
    _mpn_impn_mul_n_basecase(&a1[a4], &a2[v12], &a3[v12], a4 >> 1);
  else
    _mpn_impn_mul_n(&a1[a4], &a2[v12], v31, a4 >> 1, a5);
  if ( (int)_mpn_cmp((__int64)v13, (__int64)a2, v10) < 0 )
  {
    _mpn_sub_n((__int64)a1, (unsigned __int64 *)a2, v13, v10);
    v34 = 1;
  }
  else
  {
    _mpn_sub_n((__int64)a1, (unsigned __int64 *)v13, a2, v10);
    v34 = 0;
  }
  v14 = (unsigned __int64 *)&a1[v12];
  if ( (int)_mpn_cmp((__int64)v31, (__int64)a3, v10) < 0 )
  {
    _mpn_sub_n((__int64)&a1[v12], a3, (__int64 *)v31, v10);
  }
  else
  {
    _mpn_sub_n((__int64)&a1[v12], v31, (__int64 *)a3, v10);
    v34 ^= 1u;
  }
  if ( v10 > 31 )
  {
    _mpn_impn_mul_n(a5, a1, v14, v10, &a5[v36]);
LABEL_14:
    for ( i = 0LL; i < v10; ++i )
      v14[i] = v11[i];
    goto LABEL_16;
  }
  _mpn_impn_mul_n_basecase(a5, a1, v14, v10);
  if ( v10 > 0 )
    goto LABEL_14;
LABEL_16:
  v32 = _mpn_add_n((__int64)v11, v11, &a1[v10 + a4], v10);
  if ( v34 )
  {
    v16 = _mpn_sub_n((__int64)v14, v14, a5, a4);
    v17 = &a1[v10 + a4];
    v33 = v32 - v16;
  }
  else
  {
    v27 = _mpn_add_n((__int64)v14, (__int64 *)v14, a5, a4);
    v17 = &a1[v10 + a4];
    v33 = v32 + v27;
  }
  v35 = v17;
  if ( v10 <= 31 )
  {
    _mpn_impn_mul_n_basecase(a5, a2, a3, v10);
    v18 = v33 + _mpn_add_n((__int64)v14, (__int64 *)v14, a5, a4);
    if ( !v18 )
      goto LABEL_20;
    v24 = v35;
    v19 = __CFADD__(*v35, v18);
    *v35 += v18;
    if ( !v19 )
      goto LABEL_20;
    goto LABEL_32;
  }
  _mpn_impn_mul_n(a5, a2, a3, v10, &a5[v36]);
  v21 = _mpn_add_n((__int64)v14, (__int64 *)v14, a5, a4);
  v22 = v33 + v21 == 0;
  v23 = v33 + v21;
  v24 = v35;
  if ( !v22 )
  {
    v19 = __CFADD__(*v35, v23);
    *v35 += v23;
    if ( v19 )
    {
LABEL_32:
      v25 = 0LL;
      do
      {
        if ( v10 - 1 == v25 )
          break;
        v26 = v24[v25 + 1];
        v24[++v25] = v26 + 1;
      }
      while ( v26 == -1 );
LABEL_20:
      if ( v10 <= 0 )
        goto LABEL_22;
      goto LABEL_21;
    }
  }
  do
  {
LABEL_21:
    a1[v7] = a5[v7];
    ++v7;
  }
  while ( v10 > v7 );
LABEL_22:
  result = _mpn_add_n((__int64)v14, (__int64 *)v14, &a5[v12], v10);
  if ( result )
  {
    v19 = __CFADD__(*v11, 1LL);
    result = *v11 + 1;
    *v11 = result;
    if ( v19 )
    {
      result = 0LL;
      do
      {
        if ( result == a4 - 1 )
          break;
        v20 = v11[result + 1];
        v11[++result] = v20 + 1;
      }
      while ( v20 == -1 );
    }
  }
  return result;
}

//----- (0000000000472590) ----------------------------------------------------
__int64 __fastcall _mpn_impn_sqr_n_basecase(_QWORD *a1, unsigned __int64 *a2, __int64 a3)
{
  unsigned __int64 v4; // rcx
  _QWORD *v5; // rax
  _QWORD *v6; // rdx
  __int64 result; // rax
  unsigned __int64 *v8; // rbp
  __int64 *v9; // rbx
  __int64 i; // rax

  v4 = *a2;
  if ( *a2 > 1 )
  {
    result = _mpn_mul_1(a1, a2, a3, v4);
  }
  else
  {
    if ( *a2 == 1 )
    {
      if ( a3 > 0 )
      {
        for ( i = 0LL; ; v4 = a2[i] )
        {
          a1[i++] = v4;
          if ( a3 == i )
            break;
        }
      }
    }
    else
    {
      v5 = a1;
      v6 = &a1[a3];
      if ( a3 > 0 )
      {
        do
          *v5++ = 0LL;
        while ( v6 != v5 );
      }
    }
    result = 0LL;
  }
  a1[a3] = result;
  v8 = a2 + 1;
  v9 = a1 + 1;
  if ( a3 > 1 )
  {
    do
    {
      if ( *v8 <= 1 )
      {
        result = 0LL;
        if ( *v8 == 1 )
          result = _mpn_add_n((__int64)v9, v9, (__int64 *)a2, a3);
      }
      else
      {
        result = _mpn_addmul_1(v9, a2, a3, *v8);
      }
      ++v8;
      v9[a3] = result;
      ++v9;
    }
    while ( &a2[a3] != v8 );
  }
  return result;
}

//----- (00000000004726A0) ----------------------------------------------------
__int64 __fastcall _mpn_impn_sqr_n(unsigned __int64 *a1, unsigned __int64 *a2, __int64 a3, __int64 *a4)
{
  __int64 v6; // rbx
  __int64 v7; // r13
  unsigned __int64 *v8; // r12
  __int64 result; // rax
  __int64 v10; // rbp
  __int64 *v11; // r13
  __int64 v12; // rsi
  __int64 *v13; // r12
  unsigned __int64 *v14; // r12
  __int64 i; // rax
  _BOOL8 v16; // rax
  unsigned __int64 *v17; // r11
  __int64 v18; // rax
  bool v19; // zf
  __int64 v20; // rax
  unsigned __int64 *v21; // r11
  bool v22; // cf
  __int64 v23; // rdi
  _BOOL8 v24; // rax
  __int64 v25; // rax
  __int64 v26; // rax
  unsigned __int64 v27; // rdi
  __int64 v30; // [rsp+18h] [rbp-50h]
  __int64 v31; // [rsp+18h] [rbp-50h]
  unsigned __int64 *v32; // [rsp+18h] [rbp-50h]
  __int64 v33; // [rsp+20h] [rbp-48h]
  __int64 v34; // [rsp+20h] [rbp-48h]
  __int64 *v35; // [rsp+28h] [rbp-40h]

  v6 = a3 & 1;
  if ( (a3 & 1) != 0 )
  {
    v7 = a3 - 1;
    if ( a3 - 1 <= 31 )
      _mpn_impn_sqr_n_basecase(a1, a2, a3 - 1);
    else
      _mpn_impn_sqr_n(a1, a2, a3 - 1, a4);
    v8 = &a2[v7];
    a1[2 * v7] = _mpn_addmul_1((__int64 *)&a1[v7], a2, v7, *v8);
    result = _mpn_addmul_1((__int64 *)&a1[v7], a2, a3, *v8);
    a1[a3 + v7] = result;
    return result;
  }
  v10 = a3 >> 1;
  v30 = a3;
  v11 = (__int64 *)&a1[a3];
  v12 = a3 >> 1;
  v13 = (__int64 *)&a2[v12];
  if ( a3 >> 1 <= 31 )
    _mpn_impn_sqr_n_basecase(&a1[a3], &a2[v12], a3 >> 1);
  else
    _mpn_impn_sqr_n(&a1[a3], &a2[v12], a3 >> 1, a4);
  if ( (int)_mpn_cmp((__int64)v13, (__int64)a2, v10) < 0 )
    _mpn_sub_n((__int64)a1, a2, v13, v10);
  else
    _mpn_sub_n((__int64)a1, (unsigned __int64 *)v13, (__int64 *)a2, v10);
  if ( v10 > 31 )
  {
    _mpn_impn_sqr_n((unsigned __int64 *)a4, a1, v10, &a4[v30]);
  }
  else
  {
    _mpn_impn_sqr_n_basecase(a4, a1, v10);
    if ( v10 <= 0 )
    {
      v31 = _mpn_add_n((__int64)v11, v11, (__int64 *)&a1[v10 + a3], v10);
      v14 = &a1[v12];
      v24 = _mpn_sub_n((__int64)&a1[v12], &a1[v12], a4, a3);
      v17 = &a1[v10 + a3];
      v34 = v31 - v24;
      goto LABEL_27;
    }
  }
  v14 = &a1[v12];
  for ( i = 0LL; i < v10; ++i )
    v14[i] = v11[i];
  v35 = (__int64 *)&a1[v10 + a3];
  v33 = _mpn_add_n((__int64)v11, v11, v35, v10);
  v16 = _mpn_sub_n((__int64)v14, v14, a4, a3);
  v17 = (unsigned __int64 *)v35;
  v34 = v33 - v16;
  if ( v10 <= 31 )
  {
LABEL_27:
    v32 = v17;
    _mpn_impn_sqr_n_basecase(a4, a2, v10);
    v25 = v34 + _mpn_add_n((__int64)v14, (__int64 *)v14, a4, a3);
    if ( !v25 )
      goto LABEL_28;
    v21 = v32;
    v22 = __CFADD__(*v32, v25);
    *v32 += v25;
    if ( !v22 )
      goto LABEL_28;
    goto LABEL_33;
  }
  _mpn_impn_sqr_n((unsigned __int64 *)a4, a2, v10, &a4[v30]);
  v18 = _mpn_add_n((__int64)v14, (__int64 *)v14, a4, a3);
  v19 = v34 + v18 == 0;
  v20 = v34 + v18;
  v21 = &a1[v10 + a3];
  if ( !v19 )
  {
    v22 = __CFADD__(*v35, v20);
    *v35 += v20;
    if ( v22 )
    {
LABEL_33:
      v26 = 0LL;
      do
      {
        if ( v10 - 1 == v26 )
          break;
        v27 = v21[v26 + 1];
        v21[++v26] = v27 + 1;
      }
      while ( v27 == -1LL );
LABEL_28:
      if ( v10 <= 0 )
        goto LABEL_18;
      goto LABEL_17;
    }
  }
  do
  {
LABEL_17:
    a1[v6] = a4[v6];
    ++v6;
  }
  while ( v10 > v6 );
LABEL_18:
  result = _mpn_add_n((__int64)v14, (__int64 *)v14, &a4[v12], v10);
  if ( result )
  {
    v22 = __CFADD__(*v11, 1LL);
    result = *v11 + 1;
    *v11 = result;
    if ( v22 )
    {
      result = 0LL;
      do
      {
        if ( result == a3 - 1 )
          break;
        v23 = v11[result + 1];
        v11[++result] = v23 + 1;
      }
      while ( v23 == -1 );
    }
  }
  return result;
}

//----- (0000000000472A40) ----------------------------------------------------
unsigned __int64 __fastcall _mpn_mul_n(unsigned __int64 *a1, unsigned __int64 *a2, unsigned __int64 *a3, __int64 a4)
{
  __int64 v5; // rcx
  __int64 *v6; // r9
  unsigned int v7; // ecx
  void *v8; // rsp
  __int64 v10; // rdx
  __int64 *v11; // r10
  unsigned int v12; // edx
  void *v13; // rsp
  __int64 v14; // [rsp+0h] [rbp-1018h]
  __int64 v15; // [rsp+8h] [rbp-1010h] BYREF
  __int64 v16[510]; // [rsp+10h] [rbp-1008h] BYREF
  __int64 v17; // [rsp+1008h] [rbp-10h] BYREF
  unsigned __int64 v18; // [rsp+1010h] [rbp-8h]

  v18 = __readfsqword(0x28u);
  if ( a2 == a3 )
  {
    if ( a4 <= 31 )
    {
      _mpn_impn_sqr_n_basecase(a1, a2, a4);
    }
    else
    {
      v10 = 16 * a4 + 16;
      v11 = (__int64 *)((char *)&v17 - (v10 & 0xFFFFFFFFFFFFF000LL));
      if ( &v17 != v11 )
      {
        while ( &v15 != v11 )
          ;
      }
      v12 = v10 & 0xFFF;
      if ( v12 )
      {
        v13 = alloca(v12);
        *(__int64 *)((char *)&v14 + v12) = *(__int64 *)((char *)&v14 + v12);
      }
      _mpn_impn_sqr_n(a1, a2, a4, v16);
    }
  }
  else if ( a4 <= 31 )
  {
    _mpn_impn_mul_n_basecase(a1, (__int64 *)a2, a3, a4);
  }
  else
  {
    v5 = 16 * a4 + 16;
    v6 = (__int64 *)((char *)&v17 - (v5 & 0xFFFFFFFFFFFFF000LL));
    if ( &v17 != v6 )
    {
      while ( &v15 != v6 )
        ;
    }
    v7 = v5 & 0xFFF;
    if ( v7 )
    {
      v8 = alloca(v7);
      *(__int64 *)((char *)&v14 + v7) = *(__int64 *)((char *)&v14 + v7);
    }
    _mpn_impn_mul_n((__int64 *)a1, (__int64 *)a2, a3, a4, v16);
  }
  return __readfsqword(0x28u) ^ v18;
}

//----- (0000000000472B60) ----------------------------------------------------
_BOOL8 __fastcall _mpn_sub_n(__int64 a1, unsigned __int64 *a2, __int64 *a3, __int64 a4)
{
  unsigned __int64 v4; // r10
  __int64 v5; // r11
  unsigned __int64 *v6; // rsi
  __int64 *v7; // rdx
  __int64 v8; // rdi
  char v9; // al
  __int64 v10; // rcx
  int v11; // eax
  __int64 v12; // rcx
  bool v13; // cf
  bool v14; // cf
  unsigned __int64 v15; // r8
  __int64 v16; // r9
  bool v17; // cf
  bool v18; // cf
  unsigned __int64 v19; // r8
  __int64 v20; // r9
  unsigned __int64 v22; // rtt
  unsigned __int64 v23; // rtt
  unsigned __int64 v24; // rtt
  unsigned __int64 v25; // rtt

  v4 = *a2;
  v5 = *a3;
  v6 = &a2[a4 - 1];
  v7 = &a3[a4 - 1];
  v8 = a1 + 8 * a4 - 16;
  v9 = a4;
  v10 = -a4;
  v11 = v9 & 3;
  if ( !v11 )
  {
    v14 = 0;
    v15 = v4;
    v16 = v5;
    v12 = v10 + 4;
    goto LABEL_9;
  }
  v12 = (unsigned int)v11 + v10;
  if ( v11 < 2 )
  {
    v17 = 0;
    goto LABEL_12;
  }
  if ( v11 == 2 )
  {
    v18 = 0;
    v19 = v4;
    v20 = v5;
    goto LABEL_11;
  }
  v13 = 0;
  while ( 1 )
  {
    v19 = v6[v12 - 1];
    v20 = v7[v12 - 1];
    v24 = v13 + v5;
    v18 = v4 < v24;
    *(_QWORD *)(v8 + 8 * v12 - 8) = v4 - v24;
LABEL_11:
    v4 = v6[v12];
    v5 = v7[v12];
    v25 = v18 + v20;
    v17 = v19 < v25;
    *(_QWORD *)(v8 + 8 * v12) = v19 - v25;
LABEL_12:
    if ( !v12 )
      break;
    v12 += 4LL;
    v15 = v6[v12 - 3];
    v16 = v7[v12 - 3];
    v22 = v17 + v5;
    v14 = v4 < v22;
    *(_QWORD *)(v8 + 8 * v12 - 24) = v4 - v22;
LABEL_9:
    v4 = v6[v12 - 2];
    v5 = v7[v12 - 2];
    v23 = v14 + v16;
    v13 = v15 < v23;
    *(_QWORD *)(v8 + 8 * v12 - 16) = v15 - v23;
  }
  *(_QWORD *)(v8 + 8) = v4 - (v17 + v5);
  return v4 < (unsigned __int64)v17 + v5;
}

//----- (0000000000472C10) ----------------------------------------------------
unsigned __int64 __fastcall _mpn_submul_1(unsigned __int64 *a1, unsigned __int64 *a2, __int64 a3, unsigned __int64 a4)
{
  __int64 v4; // rbx
  unsigned __int64 v5; // rax
  unsigned __int64 v6; // r10
  unsigned __int64 *v7; // rdi
  unsigned __int64 *v8; // rsi
  unsigned __int128 v9; // rax
  __int64 v10; // rbp
  unsigned __int64 v11; // r11
  unsigned __int128 v12; // rax
  __int64 v13; // rbx
  __int64 v14; // r8
  unsigned __int64 v15; // rax
  __int64 v16; // r9
  unsigned __int64 v17; // r8
  __int64 v18; // r9
  unsigned __int64 v19; // r11
  unsigned __int64 v20; // rax
  __int64 v21; // rbp
  unsigned __int128 v22; // rax
  bool v23; // cf
  unsigned __int64 v24; // r10
  unsigned __int64 v25; // r11
  _BOOL8 v26; // rtt
  unsigned __int128 v27; // rax
  unsigned __int64 v28; // r10
  __int64 v29; // r8
  _BOOL8 v30; // rtt
  unsigned __int64 v31; // r11
  unsigned __int64 v32; // r10

  v4 = -a3;
  v5 = *a2;
  v6 = *a1;
  v7 = &a1[a3 - 2];
  v8 = &a2[a3];
  v9 = a4 * (unsigned __int128)v5;
  if ( (v4 & 1) != 0 )
  {
    v13 = v4 + 1;
    if ( v13 < 0 )
    {
      v18 = *((_QWORD *)&v9 + 1);
      v17 = v9;
      v19 = a4 * v8[v13];
      v20 = v8[v13 + 1];
      v21 = (a4 * (unsigned __int128)v8[v13]) >> 64;
      goto LABEL_8;
    }
  }
  else
  {
    v10 = *((_QWORD *)&v9 + 1);
    v11 = v9;
    v12 = a4 * (unsigned __int128)v8[v4 + 1];
    v13 = v4 + 2;
    if ( v13 < 0 )
    {
      v14 = v12;
      *(_QWORD *)&v12 = v8[v13];
      v16 = *((_QWORD *)&v12 + 1);
      while ( 1 )
      {
        v27 = a4 * (unsigned __int128)v15;
        v23 = v6 < v11;
        v28 = v6 - v11;
        v19 = v27;
        v20 = v8[v13 + 1];
        v30 = v23;
        v23 = __CFADD__(v23, v14);
        v29 = v30 + v14;
        v23 |= __CFADD__(v10, v29);
        v17 = v10 + v29;
        v7[v13] = v28;
        v6 = v7[v13 + 1];
        v21 = *((_QWORD *)&v27 + 1);
        v18 = v23 + v16;
LABEL_8:
        v13 += 2LL;
        if ( v13 >= 0 )
          break;
        v22 = a4 * (unsigned __int128)v20;
        v23 = v6 < v17;
        v24 = v6 - v17;
        v14 = v22;
        v15 = v8[v13];
        v26 = v23;
        v23 = __CFADD__(v23, v19);
        v25 = v26 + v19;
        v23 |= __CFADD__(v18, v25);
        v11 = v18 + v25;
        v7[v13 - 1] = v24;
        v6 = v7[v13];
        v16 = *((_QWORD *)&v22 + 1);
        v10 = v23 + v21;
      }
      v12 = a4 * (unsigned __int128)v20;
      v23 = __CFADD__(v6 < v17, v19);
      v31 = (v6 < v17) + v19;
      v23 |= __CFADD__(v18, v31);
      v11 = v18 + v31;
      *(v7 - 1) = v6 - v17;
      v10 = v23 + v21;
    }
    v23 = __CFADD__(*v7 < v11, (_QWORD)v12);
    *(_QWORD *)&v12 = (*v7 < v11) + (_QWORD)v12;
    v23 |= __CFADD__(v10, (_QWORD)v12);
    *(_QWORD *)&v9 = v10 + v12;
    *v7 -= v11;
    *((_QWORD *)&v9 + 1) = v23 + *((_QWORD *)&v12 + 1);
  }
  v32 = v7[1];
  v7[1] = v32 - v9;
  return *((_QWORD *)&v9 + 1) + (v32 < (unsigned __int64)v9) + (unsigned __int64)(unsigned int)v13;
}

//----- (0000000000472D00) ----------------------------------------------------
__int64 __fastcall _mpn_extract_double(__int64 *a1, double a2, __int64 a3, _DWORD *a4, _DWORD *a5)
{
  __int64 v5; // rsi
  unsigned __int64 v6; // rcx
  __int64 result; // rax

  *a5 = *(_QWORD *)&a2 >> 63;
  v5 = *(_QWORD *)&a2 & 0xFFFFFFFFFFFFFLL;
  *a4 = ((*(_QWORD *)&a2 >> 52) & 0x7FF) - 1023;
  *a1 = *(_QWORD *)&a2 & 0xFFFFFFFFFFFFFLL;
  if ( (HIWORD(a2) & 0x7FF0) != 0 )
  {
    result = 1LL;
    *a1 = v5 | 0x10000000000000LL;
  }
  else
  {
    if ( v5 )
    {
      _BitScanReverse64(&v6, v5);
      LODWORD(v6) = (v6 ^ 0x3F) - 11;
      *a1 = v5 << v6;
      *a4 = -1022 - v6;
    }
    else
    {
      *a4 = 0;
    }
    return 1LL;
  }
  return result;
}

//----- (0000000000472D90) ----------------------------------------------------
__int64 __fastcall _mpn_extract_long_double(
        __int64 *a1,
        __int64 a2,
        _DWORD *a3,
        int *a4,
        __int64 a5,
        __int64 a6,
        __int64 a7,
        __int16 a8)
{
  __int64 result; // rax
  __int64 v9; // rax
  unsigned __int64 v10; // rcx

  *a4 = HIBYTE(a8) >> 7;
  *a3 = (a8 & 0x7FFF) - 0x3FFF;
  *a1 = a7;
  if ( (a8 & 0x7FFF) != 0 )
  {
    if ( a7 )
      return 1LL;
    if ( (a8 & 0x7FFF) != 0x7FFF )
    {
LABEL_3:
      *a3 = 0;
      return 1LL;
    }
    return 1LL;
  }
  else
  {
    if ( !a7 )
      goto LABEL_3;
    v9 = a7 & 0x7FFFFFFFFFFFFFFFLL;
    *a1 = a7 & 0x7FFFFFFFFFFFFFFFLL;
    if ( (a7 & 0x7FFFFFFFFFFFFFFFLL) != 0 )
    {
      _BitScanReverse64(&v10, v9);
      LODWORD(v10) = v10 ^ 0x3F;
      *a1 = v9 << v10;
      *a3 = -16382 - v10;
      return 1LL;
    }
    else
    {
      *a1 = 0x8000000000000000LL;
      result = 1LL;
      *a3 = -16382;
    }
  }
  return result;
}

//----- (0000000000472E60) ----------------------------------------------------
__int64 __fastcall _mpn_extract_float128(_QWORD *a1, __m128i a2, __int64 a3, _DWORD *a4, _DWORD *a5)
{
  __m128i v5; // xmm1
  unsigned __int64 v6; // rax
  unsigned __int64 v8; // rax
  int v9; // eax
  unsigned __int64 v10; // r8
  __m128i v11; // [rsp+0h] [rbp-18h] BYREF

  v11 = a2;
  v5 = _mm_load_si128(&v11);
  *a5 = (unsigned __int64)a2.m128i_i64[1] >> 63;
  *a4 = (a2.m128i_i16[7] & 0x7FFF) - 0x3FFF;
  *a1 = a2.m128i_i64[0];
  v6 = a2.m128i_u32[2] | ((unsigned __int64)(unsigned int)_mm_extract_epi16(v5, 6) << 32);
  a1[1] = v6;
  if ( (_mm_extract_epi16(v5, 7) & 0x7FFF) != 0 )
  {
    a1[1] = v6 | 0x1000000000000LL;
    return 2LL;
  }
  if ( !a2.m128i_i64[0] )
  {
    if ( !v6 )
    {
      *a4 = 0;
      return 2LL;
    }
    goto LABEL_10;
  }
  if ( v6 )
  {
LABEL_10:
    _BitScanReverse64(&v10, v6);
    LODWORD(v10) = (v10 ^ 0x3F) - 15;
    *a1 = a2.m128i_i64[0] << v10;
    a1[1] = ((unsigned __int64)a2.m128i_i64[0] >> (64 - (unsigned __int8)v10)) | (v6 << v10);
    *a4 = -16382 - v10;
    return 2LL;
  }
  _BitScanReverse64(&v8, a2.m128i_u64[0]);
  v9 = v8 ^ 0x3F;
  if ( v9 <= 14 )
  {
    a1[1] = (unsigned __int64)a2.m128i_i64[0] >> (15 - (unsigned __int8)v9);
    *a1 = a2.m128i_i64[0] << ((unsigned __int8)v9 + 49);
  }
  else
  {
    *a1 = 0LL;
    a1[1] = a2.m128i_i64[0] << ((unsigned __int8)v9 - 15);
  }
  *a4 = -16431 - v9;
  return 2LL;
}
// 472E60: using guessed type __m128i var_18;

//----- (0000000000472F80) ----------------------------------------------------
__int64 __fastcall itoa_word(unsigned __int64 a1, __int64 a2, unsigned int a3, int a4)
{
  bool v4; // zf
  const char *v5; // rcx

  v4 = a4 == 0;
  v5 = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ";
  if ( v4 )
    v5 = "0123456789abcdefghijklmnopqrstuvwxyz";
  switch ( a3 )
  {
    case 0xAu:
      while ( 1 )
      {
        *(_BYTE *)--a2 = v5[a1 % 0xA];
        if ( a1 <= 9 )
          break;
        a1 /= 0xAuLL;
      }
      return a2;
    case 0x10u:
      while ( 1 )
      {
        *(_BYTE *)--a2 = v5[a1 & 0xF];
        if ( a1 <= 0xF )
          break;
        a1 >>= 4;
      }
      return a2;
    case 8u:
      while ( 1 )
      {
        *(_BYTE *)--a2 = v5[a1 & 7];
        if ( a1 <= 7 )
          break;
        a1 >>= 3;
      }
      return a2;
    default:
      while ( 1 )
      {
        *(_BYTE *)--a2 = v5[a1 % a3];
        if ( a1 < a3 )
          break;
        a1 /= a3;
      }
      return a2;
  }
}

//----- (0000000000473060) ----------------------------------------------------
_BYTE *__fastcall fitoa_word(unsigned __int64 a1, __int64 a2, unsigned int a3, int a4)
{
  unsigned __int64 v4; // rax
  _BYTE *v5; // r10
  _BYTE *v6; // r11
  _BYTE *v7; // rsi
  _BYTE *v8; // rdi
  char v10[8]; // [rsp+20h] [rbp-18h] BYREF
  unsigned __int64 v11; // [rsp+28h] [rbp-10h]

  v11 = __readfsqword(0x28u);
  v4 = itoa_word(a1, (__int64)v10, a3, a4);
  if ( v4 >= (unsigned __int64)v5 )
    return v6;
  v7 = (_BYTE *)v4;
  v8 = v6;
  do
    *v8++ = *v7++;
  while ( v7 != v5 );
  return &v7[(_QWORD)v6 - v4];
}
// 47308B: variable 'v5' is possibly undefined
// 473090: variable 'v6' is possibly undefined
// 473060: using guessed type char var_18[8];

//----- (00000000004730E0) ----------------------------------------------------
void *init()
{
  void *result; // rax

  result = &last_result;
  static_buf = (__int64)&last_result;
  return result;
}
// 4AB088: using guessed type __int64 static_buf;

//----- (0000000000473130) ----------------------------------------------------
__int64 __fastcall _dlerror(__int64 a1, __int64 a2, __int64 a3, __int64 a4, u32 *a5, unsigned __int64 a6)
{
  __int64 v6; // rdx
  unsigned __int8 *v7; // rax
  bool v8; // cf
  bool v9; // zf
  __int64 v10; // rcx
  const char *v11; // rdi
  const char *v12; // rsi
  __int64 result; // rax
  int v14; // edi
  unsigned __int8 *v15; // rbp
  unsigned __int8 *v16; // rax
  _BYTE *v17; // rdx
  unsigned __int8 *v18; // rcx
  int v19; // eax
  u32 *v20; // r8
  unsigned __int64 v21; // r9
  bool v22; // cf
  bool v23; // zf
  __int64 v24; // rcx
  const char *v25; // rdi
  const char *v26; // rsi
  unsigned int *v27; // rbx
  unsigned __int8 *v28; // rax
  _BYTE *v29; // rdx
  unsigned __int8 *v30; // rcx
  int v31; // eax
  __int64 v32; // [rsp+0h] [rbp-28h] BYREF
  unsigned __int64 v33; // [rsp+8h] [rbp-20h]

  v33 = __readfsqword(0x28u);
  v32 = 0LL;
  v27 = (unsigned int *)static_buf;
  if ( once )
  {
    if ( static_buf )
      goto LABEL_3;
  }
  else
  {
    v27 = (unsigned int *)&last_result;
    static_buf = (__int64)&last_result;
    once |= 2u;
    if ( &last_result )
      goto LABEL_3;
  }
  v27 = (unsigned int *)&last_result;
LABEL_3:
  v6 = v27[1];
  v7 = (unsigned __int8 *)*((_QWORD *)v27 + 3);
  if ( (_DWORD)v6 )
  {
    v8 = 0;
    v9 = v7 == 0LL;
    if ( v7 )
    {
      v10 = 14LL;
      v11 = "out of memory";
      v12 = (const char *)*((_QWORD *)v27 + 3);
      do
      {
        if ( !v10 )
          break;
        v8 = *v12 < (unsigned int)*v11;
        v9 = *v12++ == *v11++;
        --v10;
      }
      while ( v9 );
      LOBYTE(v6) = (!v8 && !v9) - v8;
      if ( (_BYTE)v6 )
        free(*((_QWORD *)v27 + 3), (__int64)v12, v6, v10, a5, a6);
      *((_QWORD *)v27 + 3) = 0LL;
    }
    return v32;
  }
  if ( !v7 )
    return v32;
  v14 = *v27;
  v32 = *((_QWORD *)v27 + 3);
  if ( v14 )
  {
    v15 = strerror(v14);
    v16 = dcgettext("libc", *((unsigned __int8 **)v27 + 3), 5u);
    v17 = (_BYTE *)*((_QWORD *)v27 + 2);
    v18 = byte_493255;
    if ( *v17 )
      v18 = ": ";
    v19 = asprintf(&v32, (unsigned __int64)"%s%s%s: %s", v17, v18, v16, v15, v32, v33);
    v22 = v19 != -1;
    v23 = v19 == -1;
    if ( v19 != -1 )
    {
LABEL_17:
      v24 = 14LL;
      v25 = "out of memory";
      v26 = (const char *)*((_QWORD *)v27 + 3);
      do
      {
        if ( !v24 )
          break;
        v22 = *v26 < (unsigned int)*v25;
        v23 = *v26++ == *v25++;
        --v24;
      }
      while ( v23 );
      if ( (!v22 && !v23) != v22 )
        free(*((_QWORD *)v27 + 3), (__int64)v26, *((_QWORD *)v27 + 3), v24, v20, v21);
      result = v32;
      *((_QWORD *)v27 + 3) = v32;
      goto LABEL_23;
    }
  }
  else
  {
    v28 = dcgettext("libc", v7, 5u);
    v29 = (_BYTE *)*((_QWORD *)v27 + 2);
    v30 = byte_493255;
    if ( *v29 )
      v30 = ": ";
    v31 = asprintf(&v32, (unsigned __int64)"%s%s%s", v29, v30, v28);
    v22 = v31 != -1;
    v23 = v31 == -1;
    if ( v31 != -1 )
      goto LABEL_17;
  }
  result = v32;
LABEL_23:
  v27[1] = 1;
  return result;
}
// 47339B: variable 'v20' is possibly undefined
// 47339B: variable 'v21' is possibly undefined
// 493255: using guessed type unsigned __int8 byte_493255[1707];
// 4AB080: using guessed type int once;
// 4AB088: using guessed type __int64 static_buf;

//----- (00000000004733B0) ----------------------------------------------------
__int64 *__fastcall check_free_isra_0(__int64 **a1, __int64 a2, __int64 a3, __int64 a4, u32 *a5, unsigned __int64 a6)
{
  __int64 *result; // rax
  bool v7; // cf
  bool v8; // zf
  __int64 v9; // rcx
  __int64 *v11; // rsi
  const char *v12; // rdi

  result = *a1;
  v7 = 0;
  v8 = *a1 == 0LL;
  if ( *a1 )
  {
    v9 = 14LL;
    v11 = *a1;
    v12 = "out of memory";
    do
    {
      if ( !v9 )
        break;
      v7 = *(_BYTE *)v11 < *v12;
      v8 = *(_BYTE *)v11 == *v12;
      v11 = (__int64 *)((char *)v11 + 1);
      ++v12;
      --v9;
    }
    while ( v8 );
    LOBYTE(a3) = (!v7 && !v8) - v7;
    if ( (_BYTE)a3 )
    {
      result = free((__int64)result, (__int64)v11, a3, v9, a5, a6);
      *a1 = 0LL;
    }
  }
  return result;
}

//----- (0000000000473400) ----------------------------------------------------
__int64 *__fastcall free_key_mem(__int64 a1, __int64 a2, __int64 a3, __int64 a4, u32 *a5, unsigned __int64 a6)
{
  __int64 v6; // rdx
  __int64 v7; // rcx
  u32 *v8; // r8
  unsigned __int64 v9; // r9

  check_free_isra_0((__int64 **)(a1 + 24), a2, a3, a4, a5, a6);
  return free(a1, a2, v6, v7, v8, v9);
}
// 47342C: control flows out of bounds to 0
// 473414: variable 'v6' is possibly undefined
// 473414: variable 'v7' is possibly undefined
// 473414: variable 'v8' is possibly undefined
// 473414: variable 'v9' is possibly undefined

//----- (0000000000473440) ----------------------------------------------------
_BOOL8 __fastcall dlerror_run(
        void (__fastcall *a1)(__int64),
        __int64 a2,
        __int64 a3,
        __int64 a4,
        u32 *a5,
        unsigned __int64 a6)
{
  __int64 v6; // r12
  __int64 v8; // rdi
  __int64 v9; // rax
  u32 *v11; // rbx

  v6 = a2;
  v11 = (u32 *)static_buf;
  if ( once )
  {
    if ( static_buf )
      goto LABEL_3;
  }
  else
  {
    v11 = (u32 *)&last_result;
    static_buf = (__int64)&last_result;
    once |= 2u;
    if ( &last_result )
      goto LABEL_3;
  }
  a2 = 32LL;
  v11 = calloc(1LL, 0x20uLL, a3, a4, a5, a6);
  if ( !v11 )
    v11 = (u32 *)&last_result;
LABEL_3:
  v8 = *((_QWORD *)v11 + 3);
  if ( v8 )
  {
    if ( *((_BYTE *)v11 + 8) )
      free(v8, a2, a3, a4, a5, a6);
    *((_QWORD *)v11 + 3) = 0LL;
  }
  *v11 = dl_catch_error((_QWORD *)v11 + 2, (_QWORD *)v11 + 3, (bool *)v11 + 8, a1, v6, a6);
  v9 = *((_QWORD *)v11 + 3);
  v11[1] = v9 == 0;
  return v9 != 0;
}
// 4734C8: variable 'a3' is possibly undefined
// 4734C8: variable 'a4' is possibly undefined
// 4734C8: variable 'a5' is possibly undefined
// 4734C8: variable 'a6' is possibly undefined
// 4AB080: using guessed type int once;
// 4AB088: using guessed type __int64 static_buf;

//----- (00000000004735B0) ----------------------------------------------------
_QWORD *__fastcall _libc_register_dlfcn_hook(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  _QWORD *result; // rax

  result = (_QWORD *)_libc_dlsym_private(a1, (__int64)"_dlfcn_hook", a3, a4, a5, a6);
  if ( result )
    *result = dlfcn_hooks;
  return result;
}
// 4A9B80: using guessed type __int64 (__fastcall *dlfcn_hooks[9])();

//----- (00000000004735E0) ----------------------------------------------------
__int64 __fastcall _dladdr(unsigned __int64 a1, _QWORD *a2)
{
  return dl_addr(a1, a2, 0LL, 0LL);
}

//----- (00000000004735F0) ----------------------------------------------------
__int64 __fastcall _dladdr1(unsigned __int64 a1, _QWORD *a2, _QWORD *a3, int a4)
{
  bool v4; // zf
  _QWORD *v5; // rcx

  if ( a4 == 1 )
  {
    v5 = a3;
    a3 = 0LL;
  }
  else
  {
    v4 = a4 == 2;
    v5 = 0LL;
    if ( !v4 )
      a3 = 0LL;
  }
  return dl_addr(a1, a2, a3, v5);
}

//----- (0000000000473620) ----------------------------------------------------
void __fastcall dlinfo_doit(__int64 a1)
{
  if ( *(_DWORD *)(a1 + 16) <= 0xAu )
    __asm { jmp     rax }
  dl_signal_error(0, 0LL, 0LL, "unsupported dlinfo request");
}

//----- (0000000000473710) ----------------------------------------------------
_BOOL8 __fastcall _dlinfo(__int64 a1, int a2, __int64 a3, __int64 a4, u32 *a5, unsigned __int64 a6)
{
  __int64 v7[2]; // [rsp+0h] [rbp-38h] BYREF
  int v8; // [rsp+10h] [rbp-28h]
  __int64 v9; // [rsp+18h] [rbp-20h]
  unsigned __int64 v10; // [rsp+28h] [rbp-10h]

  v10 = __readfsqword(0x28u);
  v7[1] = a1;
  v8 = a2;
  v9 = a3;
  v7[0] = a4;
  return -dlerror_run(dlinfo_doit, (__int64)v7, a3, a4, a5, a6);
}

//----- (0000000000473770) ----------------------------------------------------
__int64 __fastcall dlmopen_doit(__int64 a1)
{
  __int64 v1; // rdx
  int v2; // esi
  unsigned __int8 *v4; // rdi
  int v5; // esi
  __int64 v7; // [rsp-10h] [rbp-18h]

  if ( *(_QWORD *)a1 )
    dl_signal_error(22, 0LL, 0LL, "invalid namespace");
  v1 = *(_QWORD *)(a1 + 32);
  v2 = *(_DWORD *)(a1 + 16);
  v4 = *(unsigned __int8 **)(a1 + 8);
  v5 = v2 | 0x80000000;
  if ( !v4 )
    v4 = byte_493255;
  *(_QWORD *)(a1 + 24) = dl_open(v4, v5, v1, 0LL, (unsigned int)_libc_argc, _libc_argv, (__int64)environ);
  return v7;
}
// 4737C0: variable 'v7' is possibly undefined
// 493255: using guessed type unsigned __int8 byte_493255[1707];
// 4AB958: using guessed type int _libc_argc;
// 4AB960: using guessed type __int64 _libc_argv;

//----- (00000000004737E0) ----------------------------------------------------
__int64 __fastcall _dlmopen(__int64 a1, __int64 a2, __int64 a3, __int64 a4, u32 *a5, unsigned __int64 a6)
{
  _BOOL4 v6; // eax
  __int64 v7; // rcx
  __int64 v8; // r8
  __int64 v9; // r9
  __int64 v10; // rdx
  __int64 v11; // rdx
  __int64 v12; // rcx
  __int64 v13; // r8
  __int64 v14; // r9
  __int64 v16[2]; // [rsp+0h] [rbp-38h] BYREF
  int v17; // [rsp+10h] [rbp-28h]
  __int64 v18; // [rsp+18h] [rbp-20h]
  __int64 v19; // [rsp+20h] [rbp-18h]
  unsigned __int64 v20; // [rsp+28h] [rbp-10h]

  v20 = __readfsqword(0x28u);
  v16[0] = a1;
  v16[1] = a2;
  v17 = a3;
  v19 = a4;
  v6 = dlerror_run((void (__fastcall *)(__int64))dlmopen_doit, (__int64)v16, a3, a4, a5, a6);
  v10 = 0LL;
  if ( !v6 )
  {
    _libc_register_dl_open_hook(v18, (__int64)v16, 0LL, v7, v8, v9);
    _libc_register_dlfcn_hook(v18, (__int64)v16, v11, v12, v13, v14);
    return v18;
  }
  return v10;
}
// 473824: variable 'v7' is possibly undefined
// 473824: variable 'v8' is possibly undefined
// 473824: variable 'v9' is possibly undefined
// 47382E: variable 'v11' is possibly undefined
// 47382E: variable 'v12' is possibly undefined
// 47382E: variable 'v13' is possibly undefined
// 47382E: variable 'v14' is possibly undefined

//----- (0000000000473860) ----------------------------------------------------
unsigned __int8 *__fastcall strerror(int a1)
{
  unsigned __int8 *result; // rax
  _QWORD *v2; // rdx
  __int64 v3; // rcx
  u32 *v4; // r8
  __int64 v5; // r9
  __int64 v6; // rsi
  unsigned int v7; // er12
  _QWORD *v8; // rax

  result = strerror_r(a1, 0LL, 0LL);
  if ( !result )
  {
    v6 = buf;
    v7 = __readfsdword(0xFFFFFFC0);
    if ( buf )
      return strerror_r(a1, v6, 0x400uLL);
    v8 = malloc(0x400uLL, buf, v2, v3, v4, v5);
    buf = (__int64)v8;
    v6 = (__int64)v8;
    __writefsdword(0xFFFFFFC0, v7);
    if ( v8 )
      return strerror_r(a1, v6, 0x400uLL);
    else
      return dcgettext("libc", "Unknown error", 5u);
  }
  return result;
}
// 4738B5: variable 'v2' is possibly undefined
// 4738B5: variable 'v3' is possibly undefined
// 4738B5: variable 'v4' is possibly undefined
// 4738B5: variable 'v5' is possibly undefined
// 4ABA38: using guessed type __int64 buf;

//----- (00000000004738F0) ----------------------------------------------------
_BYTE *(__fastcall *strspn_ifunc())(__int64 a1, __m128i *a2)
{
  _BYTE *(__fastcall *result)(__int64, __m128i *); // rax

  result = (_BYTE *(__fastcall *)(__int64, __m128i *))_strspn_sse2;
  if ( (dword_4AAE10 & 0x100000) != 0 )
    return _strspn_sse42;
  return result;
}
// 4AAE10: using guessed type int dword_4AAE10;

//----- (0000000000473910) ----------------------------------------------------
__int64 __fastcall strsep(_QWORD *a1, __int64 a2)
{
  __int64 v2; // rbx
  _BYTE *v3; // rax

  v2 = *a1;
  if ( !*a1 )
    return v2;
  v3 = (_BYTE *)(v2 + j_strcspn_ifunc(*a1, a2));
  if ( *v3 )
  {
    *v3 = 0;
    *a1 = v3 + 1;
    return v2;
  }
  *a1 = 0LL;
  return v2;
}
// 4010B8: using guessed type __int64 __fastcall j_strcspn_ifunc(_QWORD, _QWORD);

//----- (0000000000473970) ----------------------------------------------------
_BYTE *__fastcall _strspn_sse2(__int64 a1, _BYTE *a2)
{
  __int64 v2; // rcx
  _BYTE *v4; // rax
  char v6[256]; // [rsp+0h] [rbp-100h] BYREF

  memset(v6, 0, sizeof(v6));
  v2 = 0LL;
  do
  {
    if ( !*a2 )
      break;
    LOBYTE(v2) = *a2;
    v6[v2] = *a2;
    LOBYTE(v2) = a2[1];
    if ( !(_BYTE)v2 )
      break;
    v6[v2] = v2;
    LOBYTE(v2) = a2[2];
    if ( !(_BYTE)v2 )
      break;
    v6[v2] = v2;
    LOBYTE(v2) = a2[3];
    a2 += 4;
    v6[v2] = v2;
  }
  while ( (_BYTE)v2 );
  v4 = (_BYTE *)(a1 - 4);
  while ( 1 )
  {
    v4 += 4;
    LOBYTE(v2) = *v4;
    if ( (*v4 & (unsigned __int8)v6[v2]) == 0 )
      return &v4[-a1];
    LOBYTE(v2) = v4[1];
    if ( ((unsigned __int8)v2 & (unsigned __int8)v6[v2]) == 0 )
      goto LABEL_13;
    LOBYTE(v2) = v4[2];
    if ( ((unsigned __int8)v2 & (unsigned __int8)v6[v2]) == 0 )
      goto LABEL_12;
    LOBYTE(v2) = v4[3];
    if ( ((unsigned __int8)v2 & (unsigned __int8)v6[v2]) == 0 )
    {
      ++v4;
LABEL_12:
      ++v4;
LABEL_13:
      ++v4;
      return &v4[-a1];
    }
  }
}
// 473970: using guessed type char var_100[256];

//----- (0000000000473A20) ----------------------------------------------------
_BYTE *__fastcall _strspn_sse42(__int64 a1, __m128i *a2)
{
  int v2; // edx
  __m128i v3; // xmm0
  int v4; // esi
  __m128i v5; // xmm2
  int v6; // ecx
  _BYTE *result; // rax
  __m128i si128; // xmm1
  int v9; // ecx
  __m128i *v10; // rax
  int i; // ecx

  if ( !a2->m128i_i8[0] )
    return 0LL;
  v2 = (unsigned __int8)a2 & 0xF;
  if ( ((unsigned __int8)a2 & 0xF) != 0 )
  {
    v3 = _mm_shuffle_epi8(
           _mm_load_si128((const __m128i *)((unsigned __int64)a2 & 0xFFFFFFFFFFFFFFF0LL)),
           _mm_loadu_si128((const __m128i *)((char *)&__m128i_shift_right + ((unsigned __int8)a2 & 0xF))));
    if ( 16 - v2 == _mm_cmpistri(v3, v3, 58) )
    {
      si128 = _mm_load_si128((const __m128i *)(((unsigned __int64)a2 & 0xFFFFFFFFFFFFFFF0LL) + 16));
      v9 = _mm_cmpistri(si128, si128, 58);
      if ( v9 + 16 - v2 > 16 )
        return _strspn_sse2(a1, a2);
      if ( v9 )
        v3 = _mm_loadu_si128(a2);
    }
  }
  else
  {
    v3 = _mm_load_si128(a2);
    if ( _mm_cmpistri(v3, v3, 58) == 16 && a2[1].m128i_i8[0] )
      return _strspn_sse2(a1, a2);
  }
  v4 = a1 & 0xF;
  if ( (a1 & 0xF) != 0 )
  {
    v5 = _mm_shuffle_epi8(
           _mm_load_si128((const __m128i *)(a1 & 0xFFFFFFFFFFFFFFF0LL)),
           _mm_loadu_si128((const __m128i *)((char *)&__m128i_shift_right + (a1 & 0xF))));
    v6 = _mm_cmpistri(v3, v5, 18);
    result = (_BYTE *)v6;
    if ( 16 - v4 > v6 || 16 - v4 > _mm_cmpistri(v5, v5, 58) )
      return result;
    v10 = (__m128i *)((a1 & 0xFFFFFFFFFFFFFFF0LL) + 16);
  }
  else
  {
    v10 = (__m128i *)a1;
  }
  for ( i = _mm_cmpistri(v3, *v10, 18); !_mm_cmpistrc(v3, *v10, 18); i = _mm_cmpistri(v3, *v10, 18) )
    ++v10;
  return (char *)v10 + i - a1;
}

//----- (0000000000473B50) ----------------------------------------------------
unsigned __int64 __fastcall _getdents64(unsigned int a1, struct linux_dirent64 *a2, unsigned int a3)
{
  unsigned __int64 result; // rax

  result = sys_getdents64(a1, a2, a3);
  if ( result > 0xFFFFFFFFFFFFF000LL )
  {
    __writefsdword(0xFFFFFFC0, -(int)result);
    return -1LL;
  }
  return result;
}

//----- (0000000000473B80) ----------------------------------------------------
signed __int64 getpid()
{
  return sys_getpid();
}

//----- (0000000000473B90) ----------------------------------------------------
unsigned __int64 __fastcall _profil_counter(__int64 a1, __int64 a2, __int64 a3)
{
  unsigned __int64 result; // rax

  result = (unsigned int)pc_scale * ((unsigned __int64)((*(_QWORD *)(a3 + 168) - pc_offset) / 2) >> 16)
         + (((unsigned int)pc_scale * (unsigned __int64)(unsigned __int16)((*(_QWORD *)(a3 + 168) - pc_offset) / 2)) >> 16);
  if ( result < nsamples )
    ++*(_WORD *)(samples + 2 * result);
  return result;
}
// 4AB180: using guessed type int pc_scale;
// 4AB188: using guessed type __int64 pc_offset;
// 4AB190: using guessed type __int64 nsamples;
// 4AB198: using guessed type __int64 samples;

//----- (0000000000473BF0) ----------------------------------------------------
unsigned __int64 __fastcall profil(__int64 a1, unsigned __int64 a2, __int64 a3, int a4)
{
  unsigned __int64 result; // rax
  __int64 *v7; // rsi
  struct itimerval v8; // [rsp+0h] [rbp-E8h] BYREF
  unsigned __int64 (__fastcall *v9)(__int64, __int64, __int64); // [rsp+20h] [rbp-C8h] BYREF
  _DWORD v10[6]; // [rsp+A0h] [rbp-48h] BYREF
  unsigned __int64 v11; // [rsp+B8h] [rbp-30h]

  v11 = __readfsqword(0x28u);
  result = 0LL;
  if ( a1 )
  {
    if ( !samples
      || (setitimer(2, &otimer_8660, 0LL) & 0x80000000) == 0LL
      && (sigaction(27, (__int64)&oact_8659, 0LL) & 0x80000000) == 0LL )
    {
      samples = a1;
      nsamples = a2 >> 1;
      pc_offset = a3;
      pc_scale = a4;
      v10[2] = 0x10000000;
      v9 = _profil_counter;
      v7 = (__int64 *)v10;
      do
        *v7-- = -1LL;
      while ( v7 != (__int64 *)&v9 );
      if ( (sigaction(27, (__int64)v7, (__int64)&oact_8659) & 0x80000000) == 0LL )
      {
        v8.it_value.tv_sec = 0LL;
        v8.it_value.tv_usec = 1000000 / (int)_profile_frequency();
        v8.it_interval = (timeval)_mm_load_si128((const __m128i *)&v8.it_value);
        return setitimer(2, &v8, &otimer_8660);
      }
    }
    return 0xFFFFFFFFLL;
  }
  if ( samples )
  {
    if ( (setitimer(2, &otimer_8660, 0LL) & 0x80000000) == 0LL )
    {
      samples = 0LL;
      return sigaction(27, (__int64)&oact_8659, 0LL);
    }
    return 0xFFFFFFFFLL;
  }
  return result;
}
// 4AB160: using guessed type struct itimerval otimer_8660;
// 4AB180: using guessed type int pc_scale;
// 4AB188: using guessed type __int64 pc_offset;
// 4AB190: using guessed type __int64 nsamples;
// 4AB198: using guessed type __int64 samples;

//----- (0000000000473D90) ----------------------------------------------------
__int64 _profile_frequency()
{
  return (unsigned int)dl_clktck;
}
// 4AB8E8: using guessed type int dl_clktck;

//----- (0000000000473DA0) ----------------------------------------------------
__int64 (*__fastcall dl_fixup(
        __int64 a1,
        unsigned int a2,
        double a3,
        double a4,
        double a5,
        double a6,
        double a7,
        double a8,
        double a9,
        double a10))(void)
{
  __int64 v11; // rdi
  __int64 *v12; // r8
  unsigned __int64 v13; // rcx
  __int64 v14; // rbx
  unsigned int *v15; // rsi
  __int64 v16; // rax
  _QWORD *v17; // rbx
  __int64 v18; // r8
  int v19; // eax
  u32 *v20; // r8
  u32 v21; // er9
  __int64 (*result)(void); // rax
  volatile __int32 *v23; // rax
  signed __int64 v24; // rax
  unsigned int *v25; // [rsp+8h] [rbp-10h] BYREF

  v11 = *(_QWORD *)(*(_QWORD *)(a1 + 104) + 8LL);
  v12 = (__int64 *)(*(_QWORD *)(*(_QWORD *)(a1 + 248) + 8LL) + 24LL * a2);
  v13 = v12[1];
  v14 = *v12;
  v15 = (unsigned int *)(*(_QWORD *)(*(_QWORD *)(a1 + 112) + 8LL) + 24 * HIDWORD(v13));
  v16 = *(_QWORD *)a1;
  v25 = v15;
  v17 = (_QWORD *)(v16 + v14);
  if ( (_DWORD)v13 != 7 )
    _assert_fail(
      (__int64)"ELFW(R_TYPE)(reloc->r_info) == ELF_MACHINE_JMP_SLOT",
      (__int64)"../elf/dl-runtime.c",
      0x50u,
      "_dl_fixup");
  if ( (*((_BYTE *)v15 + 5) & 3) != 0 )
  {
    if ( *((_WORD *)v15 + 3) == 0xFFF1 )
      v16 = 0LL;
    goto LABEL_13;
  }
  v18 = *(_QWORD *)(a1 + 464);
  if ( v18 )
  {
    v18 = *(_QWORD *)(a1 + 744) + 24LL * (*(_WORD *)(*(_QWORD *)(v18 + 8) + 2 * HIDWORD(v13)) & 0x7FFF);
    if ( !*(_DWORD *)(v18 + 8) )
      v18 = 0LL;
  }
  v19 = 1;
  if ( __readfsdword(0x18u) )
  {
    __writefsdword(0x1Cu, 1u);
    v19 = 5;
  }
  v20 = (u32 *)dl_lookup_symbol_x(
                 (unsigned __int8 *)(*v15 + v11),
                 a1,
                 &v25,
                 *(__int64 **)(a1 + 904),
                 (const char **)v18,
                 1,
                 a3,
                 a4,
                 a5,
                 a6,
                 a7,
                 a8,
                 a9,
                 a10,
                 v19,
                 0LL);
  if ( __readfsdword(0x18u) )
  {
    LODWORD(v23) = _InterlockedExchange(MK_FP(__FS__, 28LL), 0);
    if ( (_DWORD)v23 == 2 )
      v24 = sys_futex((u32 *)(__readfsqword(0x10u) + 28), 129, 1u, 0LL, v20, v21);
  }
  v15 = v25;
  result = 0LL;
  if ( v25 )
  {
    if ( *((_WORD *)v25 + 3) == 0xFFF1 || !v20 )
      v16 = 0LL;
    else
      v16 = *(_QWORD *)v20;
LABEL_13:
    result = (__int64 (*)(void))(*((_QWORD *)v15 + 1) + v16);
    if ( (v15[1] & 0xF) == 10 )
      result = (__int64 (*)(void))result();
  }
  if ( !dl_bind_not )
    *v17 = result;
  return result;
}
// 473E9B: variable 'v20' is possibly undefined
// 473F1E: variable 'v21' is possibly undefined
// 4AB898: using guessed type int dl_bind_not;

//----- (0000000000473F60) ----------------------------------------------------
__int64 (*__fastcall dl_profile_fixup(
        __int64 a1,
        unsigned int a2,
        __int64 a3,
        double a4,
        double a5,
        double a6,
        double a7,
        double a8,
        double a9,
        double a10,
        double a11,
        __int64 a12,
        _QWORD *a13))(void)
{
  __int64 v14; // rbx
  __int64 v16; // rbx
  __int64 v17; // r9
  unsigned __int64 v18; // rcx
  unsigned __int64 v19; // rdx
  __int64 v20; // rsi
  unsigned int *v21; // rax
  __int64 v22; // r8
  int v23; // esi
  __int64 *v24; // rcx
  u32 *v25; // r8
  u32 v26; // er9
  __int64 (__fastcall *v27)(__int64, __int64, unsigned __int64); // r13
  __int64 v28; // r13
  volatile __int32 *v30; // rax
  signed __int64 v31; // rax
  int v32; // [rsp-10h] [rbp-48h]
  unsigned __int64 v33; // [rsp-10h] [rbp-48h]
  unsigned int *v34; // [rsp+8h] [rbp-30h] BYREF

  v14 = *(_QWORD *)(a1 + 816);
  if ( v14 )
  {
    v16 = 32LL * a2 + v14;
    if ( *(_DWORD *)(v16 + 28) )
    {
      v27 = *(__int64 (__fastcall **)(__int64, __int64, unsigned __int64))v16;
LABEL_20:
      *a13 = -1LL;
      dl_mcount(a3, (__int64)v27);
      return (__int64 (*)(void))v27;
    }
    v17 = *(_QWORD *)(*(_QWORD *)(a1 + 104) + 8LL);
    v18 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 248) + 8LL) + 24LL * a2 + 8);
    v19 = HIDWORD(v18);
    v20 = 3 * HIDWORD(v18);
    v21 = (unsigned int *)(*(_QWORD *)(*(_QWORD *)(a1 + 112) + 8LL) + 24 * HIDWORD(v18));
    v34 = v21;
    if ( (_DWORD)v18 != 7 )
      _assert_fail(
        (__int64)"ELFW(R_TYPE)(reloc->r_info) == ELF_MACHINE_JMP_SLOT",
        (__int64)"../elf/dl-runtime.c",
        0xE5u,
        "_dl_profile_fixup");
    if ( (*((_BYTE *)v21 + 5) & 3) != 0 )
    {
      if ( *((_WORD *)v21 + 3) != 0xFFF1 )
      {
        v28 = *(_QWORD *)a1;
LABEL_15:
        v27 = (__int64 (__fastcall *)(__int64, __int64, unsigned __int64))(*((_QWORD *)v21 + 1) + v28);
        if ( (v21[1] & 0xF) == 10 )
          v27 = (__int64 (__fastcall *)(__int64, __int64, unsigned __int64))v27(a1, v20, v19);
LABEL_17:
        if ( !dl_bind_not )
        {
          *(_QWORD *)v16 = v27;
          *(_DWORD *)(v16 + 28) = 1;
        }
        goto LABEL_20;
      }
    }
    else
    {
      v22 = *(_QWORD *)(a1 + 464);
      if ( v22 )
      {
        v22 = *(_QWORD *)(a1 + 744) + 24LL * (*(_WORD *)(*(_QWORD *)(v22 + 8) + 2 * v19) & 0x7FFF);
        if ( !*(_DWORD *)(v22 + 8) )
          v22 = 0LL;
      }
      v23 = 1;
      if ( __readfsdword(0x18u) )
      {
        __writefsdword(0x1Cu, 1u);
        v23 = 5;
      }
      v24 = *(__int64 **)(a1 + 904);
      v32 = v23;
      v20 = a1;
      a1 = v17 + *v21;
      v25 = (u32 *)dl_lookup_symbol_x(
                     (unsigned __int8 *)a1,
                     v20,
                     &v34,
                     v24,
                     (const char **)v22,
                     1,
                     a4,
                     a5,
                     a6,
                     a7,
                     a8,
                     a9,
                     a10,
                     a11,
                     v32,
                     0LL);
      v19 = v33;
      if ( __readfsdword(0x18u) )
      {
        LODWORD(v30) = _InterlockedExchange(MK_FP(__FS__, 28LL), 0);
        if ( (_DWORD)v30 == 2 )
        {
          a1 = __readfsqword(0x10u) + 28;
          v20 = 129LL;
          v31 = sys_futex((u32 *)a1, 129, 1u, 0LL, v25, v26);
        }
      }
      v21 = v34;
      v27 = 0LL;
      if ( !v34 )
        goto LABEL_17;
      if ( *((_WORD *)v34 + 3) != 0xFFF1 && v25 )
      {
        v28 = *(_QWORD *)v25;
        goto LABEL_15;
      }
    }
    v28 = 0LL;
    goto LABEL_15;
  }
  *a13 = -1LL;
  return dl_fixup(a1, a2, a4, a5, a6, a7, a8, a9, a10, a11);
}
// 474066: variable 'v33' is possibly undefined
// 474087: variable 'v25' is possibly undefined
// 474108: variable 'v19' is possibly undefined
// 474172: variable 'v26' is possibly undefined
// 4AB898: using guessed type int dl_bind_not;

//----- (00000000004741A0) ----------------------------------------------------
void dl_call_pltexit()
{
  ;
}

//----- (00000000004741B0) ----------------------------------------------------
__int64 __fastcall add_to_global(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  int v7; // ebx
  __int64 v8; // rax
  __int64 v9; // rdx
  __int64 v10; // rcx
  bool v11; // cf
  __int64 v12; // r12
  void **v13; // r15
  u32 *v14; // r8
  _QWORD *v15; // rdx
  u32 v16; // er14
  unsigned int v17; // ebx
  __int64 v18; // rcx
  char v19; // al
  __int64 v20; // rdx
  __int64 v22; // rbx
  __int64 v23; // r14
  _QWORD *v24; // rax
  _QWORD *v25; // rdi
  __int64 v26; // rax
  __int64 v27; // rdx
  __int64 v28; // rcx
  unsigned __int64 v29; // r9
  u32 *v30; // r8
  unsigned __int64 v31; // rdi
  _QWORD *v32; // rax
  void *v33; // [rsp+0h] [rbp-48h]
  _DWORD *v34; // [rsp+0h] [rbp-48h]
  __int64 *v35; // [rsp+8h] [rbp-40h]

  v7 = *(_DWORD *)(a1 + 712);
  if ( v7 )
  {
    v8 = *(_QWORD *)(a1 + 704);
    v9 = v8 + 8;
    a2 = v8 + 8 + 8LL * (unsigned int)(v7 - 1);
    LODWORD(v10) = 0;
    while ( 1 )
    {
      v11 = (*(_BYTE *)(*(_QWORD *)v8 + 796LL) & 0x10) == 0;
      v8 = v9;
      v10 = v11 + (unsigned int)v10;
      if ( a2 == v9 )
        break;
      v9 += 8LL;
    }
  }
  else
  {
    v10 = 0LL;
  }
  v12 = *(_QWORD *)(a1 + 48);
  v13 = &dl_ns + 18 * v12;
  v14 = (u32 *)v13[2];
  v15 = v13[3];
  v16 = v14[2];
  if ( !v15 )
  {
    v31 = v16 + (unsigned int)v10 + 8;
    v34 = v13[2];
    v13[3] = (void *)v31;
    v32 = malloc(8 * v31, a2, 0LL, v10, v14, a6);
    if ( v32 )
    {
      *(_QWORD *)v34 = j_memcpy(v32, *(_QWORD *)v34, 8LL * v16);
      v16 = v34[2];
      goto LABEL_7;
    }
    v13[3] = 0LL;
LABEL_22:
    dl_signal_error(12, **(void ***)(a1 + 56), 0LL, "cannot extend global scope");
  }
  if ( (unsigned __int64)v15 >= (unsigned int)v10 + v16 )
    goto LABEL_7;
  v22 = *(_QWORD *)v14;
  v35 = (__int64 *)v13[2];
  v23 = 2 * ((_QWORD)v15 + v10);
  v33 = v13[3];
  v24 = malloc(16 * ((_QWORD)v15 + v10), a2, v15, v10, v14, a6);
  if ( !v24 )
    goto LABEL_22;
  v25 = v24;
  v26 = j_memcpy(v24, v22, 8LL * (_QWORD)v33);
  v30 = (u32 *)v35;
  v13[3] = (void *)v23;
  *v35 = v26;
  if ( __readfsdword(0x18u) )
    dl_wait_lookup_done(v25, v22, v27, v28, v35, v29);
  free(v22, v22, v27, v28, v30, v29);
  v7 = *(_DWORD *)(a1 + 712);
  v16 = *((_DWORD *)*(&dl_ns + 18 * v12 + 2) + 2);
LABEL_7:
  if ( v7 )
  {
    v17 = 0;
    do
    {
      v18 = *(_QWORD *)(*(_QWORD *)(a1 + 704) + 8LL * v17);
      v19 = *(_BYTE *)(v18 + 796);
      if ( (v19 & 0x10) == 0 )
      {
        v20 = v16++;
        *(_BYTE *)(v18 + 796) = v19 | 0x10;
        *(_QWORD *)(*(_QWORD *)*(&dl_ns + 18 * v12 + 2) + 8 * v20) = v18;
        if ( (dl_debug_mask & 0x200) != 0 )
          dl_debug_printf("\nadd %s [%lu] to global scope\n", *(const char **)(v18 + 8), *(_QWORD *)(v18 + 48));
      }
      ++v17;
    }
    while ( *(_DWORD *)(a1 + 712) > v17 );
  }
  *((_DWORD *)*(&dl_ns + 18 * v12 + 2) + 2) = v16;
  return 0LL;
}
// 4743AF: variable 'v27' is possibly undefined
// 4743AF: variable 'v28' is possibly undefined
// 4743AF: variable 'v29' is possibly undefined
// 474318: variable 'v30' is possibly undefined
// 401040: using guessed type __int64 __fastcall j_memcpy(_QWORD, _QWORD, _QWORD);
// 4A9280: using guessed type void *dl_ns;
// 4AB880: using guessed type int dl_debug_mask;
// 4AB888: using guessed type __int64 (__fastcall *dl_wait_lookup_done)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (00000000004743E0) ----------------------------------------------------
_QWORD *__fastcall dl_find_dso_for_object(unsigned __int64 a1)
{
  _QWORD *v1; // rbx

  if ( !dl_nns )
    return 0LL;
  v1 = dl_ns;
  if ( !dl_ns )
    return 0LL;
  while ( v1[105] > a1
       || v1[106] <= a1
       || (*((_BYTE *)v1 + 797) & 0x40) == 0 && !(unsigned int)dl_addr_inside_object((__int64)v1, a1) )
  {
    v1 = (_QWORD *)v1[3];
    if ( !v1 )
      return 0LL;
  }
  if ( v1[6] )
    _assert_fail((__int64)"ns == l->l_ns", (__int64)"dl-open.c", 0xADu, "_dl_find_dso_for_object");
  return v1;
}
// 4A9210: using guessed type __int64 dl_nns;
// 4A9280: using guessed type void *dl_ns;

//----- (0000000000474480) ----------------------------------------------------
__int64 __fastcall dl_open(void *a1, int a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, __int64 a7)
{
  int v7; // er12
  __m128i v9[2]; // [rsp+0h] [rbp-98h] BYREF
  void *v10; // [rsp+20h] [rbp-78h] BYREF
  int v11; // [rsp+28h] [rbp-70h]
  __int64 v12; // [rsp+30h] [rbp-68h]
  __int64 v13; // [rsp+38h] [rbp-60h]
  __int64 v14; // [rsp+40h] [rbp-58h]
  int v15; // [rsp+48h] [rbp-50h]
  __int64 v16; // [rsp+50h] [rbp-48h]
  __int64 v17; // [rsp+58h] [rbp-40h]

  if ( (a2 & 3) == 0 )
    dl_signal_error(22, a1, 0LL, "invalid mode for dlopen()");
  if ( a4 == -1 )
    dl_signal_error(22, a1, 0LL, "no more namespaces available for dlmopen()");
  if ( ((a4 + 2) & 0xFFFFFFFFFFFFFFFDLL) != 0 )
    dl_signal_error(22, a1, 0LL, "invalid target namespace in dlmopen()");
  v14 = a4;
  v10 = a1;
  v11 = a2;
  v12 = a3;
  v13 = 0LL;
  v15 = a5;
  v16 = a6;
  v17 = a7;
  v7 = dl_catch_exception((__int64)v9, (void (__fastcall *)(__int64))dl_open_worker, (__int64)&v10, a4, a5, a6);
  dl_unload_cache();
  if ( v9[0].m128i_i64[1] )
  {
    if ( v13 )
    {
      if ( (a2 & 0x8000000) == 0 )
        dl_tls_dtv_gaps = 1;
      dl_close_worker(v13, 1);
    }
    if ( !*((_DWORD *)dl_debug_initialize(0LL, v14) + 6) )
      dl_signal_exception(v7, v9, 0LL);
    _assert_fail(
      (__int64)"_dl_debug_initialize (0, args.nsid)->r_state == RT_CONSISTENT",
      (__int64)"dl-open.c",
      0x267u,
      "_dl_open");
  }
  if ( *((_DWORD *)dl_debug_initialize(0LL, v14) + 6) )
    _assert_fail(
      (__int64)"_dl_debug_initialize (0, args.nsid)->r_state == RT_CONSISTENT",
      (__int64)"dl-open.c",
      0x270u,
      "_dl_open");
  return v13;
}
// 4AB7E8: using guessed type char dl_tls_dtv_gaps;

//----- (0000000000474690) ----------------------------------------------------
signed __int64 __fastcall dl_show_scope(_QWORD *a1, unsigned int a2)
{
  const char *v3; // rsi
  __int64 v4; // rax
  __int64 v5; // rbp
  __int64 v6; // rdx
  unsigned int v7; // ebx
  const char *v8; // rsi

  v3 = (const char *)a1[1];
  if ( !*v3 )
  {
    v3 = (const char *)program_invocation_short_name[0];
    if ( !program_invocation_short_name[0] )
      v3 = "<main program>";
  }
  dl_debug_printf("object=%s [%lu]\n", v3, a1[6]);
  v4 = a1[113];
  if ( v4 )
  {
    v5 = 8LL * (int)a2;
    if ( *(_QWORD *)(v4 + v5) )
    {
      do
      {
        dl_debug_printf(" scope %u:", a2);
        v6 = *(_QWORD *)(a1[113] + v5);
        if ( *(_DWORD *)(v6 + 8) )
        {
          v7 = 0;
          do
          {
            v8 = *(const char **)(*(_QWORD *)(*(_QWORD *)v6 + 8LL * v7) + 8LL);
            if ( !*v8 )
            {
              v8 = (const char *)program_invocation_short_name[0];
              if ( !program_invocation_short_name[0] )
                v8 = "<program name unknown>";
            }
            ++v7;
            dl_debug_printf_c(" %s", v8);
            v6 = *(_QWORD *)(a1[113] + v5);
          }
          while ( *(_DWORD *)(v6 + 8) > v7 );
        }
        v5 += 8LL;
        ++a2;
        dl_debug_printf_c("\n");
      }
      while ( *(_QWORD *)(a1[113] + v5) );
    }
  }
  else
  {
    dl_debug_printf(" no scope\n");
  }
  return dl_debug_printf("\n");
}
// 4A9168: using guessed type char (*program_invocation_short_name[2])[1707];

//----- (00000000004747D0) ----------------------------------------------------
signed __int64 __fastcall dl_open_worker(
        __int64 a1,
        double a2,
        double a3,
        double a4,
        double a5,
        double a6,
        double a7,
        double a8,
        double a9)
{
  __int64 v9; // r15
  char *v10; // r13
  int v11; // eax
  char *v12; // rdi
  _QWORD *v13; // r12
  _QWORD *dso_for_object; // rbx
  __int64 v15; // r12
  const char *v16; // rsi
  signed __int64 result; // rax
  __int64 v18; // rdx
  __int64 v19; // r8
  unsigned __int64 v20; // r9
  __int64 v21; // rbx
  bool v22; // zf
  __int64 v23; // rcx
  unsigned int v24; // er12
  u32 *v25; // r8
  __int64 v26; // r9
  double v27; // xmm4_8
  double v28; // xmm5_8
  __int64 v29; // rcx
  _QWORD *v30; // rdi
  void **v31; // rax
  int v32; // er13
  __int64 v33; // rax
  __int64 v34; // rcx
  __int64 v35; // rdx
  unsigned __int64 v36; // rax
  __int64 *v37; // rdx
  unsigned int v38; // eax
  void *v39; // rsp
  __int64 v40; // rax
  unsigned int v41; // er8
  __int64 v42; // rdx
  __int64 v43; // rsi
  __int64 v44; // r9
  double v45; // xmm4_8
  double v46; // xmm5_8
  u32 *v47; // r8
  unsigned int v48; // er14
  __int64 i; // rdi
  _QWORD *v50; // rdx
  unsigned int v51; // er14
  unsigned int v52; // er13
  __int64 v53; // r15
  unsigned __int64 v54; // r12
  __int64 v55; // rbx
  unsigned __int64 v56; // rcx
  __int64 v57; // rax
  unsigned __int64 v58; // rdi
  __int64 v59; // rsi
  __int64 v60; // rdx
  __int64 v61; // rcx
  __int64 v62; // r8
  __int64 v63; // r9
  __int64 v64; // rdx
  __int64 v65; // r12
  __int64 v66; // r11
  _QWORD *v67; // r10
  __int64 v68; // rax
  _QWORD *v69; // rdx
  __int64 v70; // rdi
  __int64 v71; // r11
  _QWORD *v72; // rax
  _QWORD v74[511]; // [rsp+8h] [rbp-1080h] BYREF
  __int64 v75; // [rsp+1008h] [rbp-80h] BYREF
  unsigned __int64 v76; // [rsp+1010h] [rbp-78h]
  __int64 v77; // [rsp+1018h] [rbp-70h]
  unsigned __int64 v78; // [rsp+1020h] [rbp-68h]
  unsigned __int64 v79; // [rsp+1028h] [rbp-60h]
  __int64 v80; // [rsp+1030h] [rbp-58h]
  int v81; // [rsp+103Ch] [rbp-4Ch]
  __int64 *v82; // [rsp+1040h] [rbp-48h]
  void **v83; // [rsp+1048h] [rbp-40h]
  unsigned int v84; // [rsp+1050h] [rbp-38h]
  int v85; // [rsp+1054h] [rbp-34h]

  v9 = a1;
  v10 = *(char **)a1;
  v11 = *(_DWORD *)(a1 + 8);
  v12 = *(char **)a1;
  v85 = v11;
  if ( j_strchr_ifunc(v12, 36LL)
    || (v15 = *(_QWORD *)(v9 + 32), v15 == -2)
    || (dso_for_object = 0LL, !j_strchr_ifunc(v10, 47LL)) )
  {
    v13 = dl_ns;
    dso_for_object = dl_find_dso_for_object(*(_QWORD *)(v9 + 16));
    if ( !dso_for_object )
      dso_for_object = v13;
    v15 = *(_QWORD *)(v9 + 32);
    if ( v15 == -2 )
    {
      v15 = dso_for_object[6];
      *(_QWORD *)(v9 + 32) = v15;
    }
  }
  dl_debug_initialize(0LL, v15);
  v16 = v10;
  result = (signed __int64)dl_map_object((__int64)dso_for_object, v10, 2, 0, v85 | 0x10000000u, *(_QWORD *)(v9 + 32));
  v21 = result;
  *(_QWORD *)(v9 + 24) = result;
  if ( !result )
  {
    if ( (v85 & 4) == 0 )
      _assert_fail((__int64)"mode & RTLD_NOLOAD", (__int64)"dl-open.c", 0xE0u, "dl_open_worker");
    return result;
  }
  if ( (v85 & 0x1000) != 0 )
    *(_DWORD *)(result + 988) |= 8u;
  if ( (v85 & 0x40000000) != 0 )
    return result;
  v22 = *(_QWORD *)(result + 704) == 0LL;
  v23 = (unsigned int)(*(_DWORD *)(result + 792) + 1);
  *(_DWORD *)(result + 792) = v23;
  if ( !v22 )
  {
    if ( (dl_debug_mask & 0x40) != 0 )
    {
      v16 = *(const char **)(result + 8);
      dl_debug_printf("opening file=%s [%lu]; direct_opencount=%u\n\n", v16, *(_QWORD *)(result + 48), v23);
    }
    if ( (v85 & 0x100) != 0 && (*(_BYTE *)(v21 + 796) & 0x10) == 0 )
      add_to_global(v21, (__int64)v16, v18, v23, v19, v20);
    result = (signed __int64)dl_debug_initialize(0LL, *(_QWORD *)(v9 + 32));
    if ( *(_DWORD *)(result + 24) )
      _assert_fail(
        (__int64)"_dl_debug_initialize (0, args->nsid)->r_state == RT_CONSISTENT",
        (__int64)"dl-open.c",
        0xFEu,
        "dl_open_worker");
    return result;
  }
  v24 = 0;
  dl_map_object_deps(result, 0LL, 0LL, 0, v85 & 0x88000008, v20);
  v29 = *(unsigned int *)(v21 + 712);
  if ( (_DWORD)v29 )
  {
    do
    {
      while ( 1 )
      {
        v30 = *(_QWORD **)(*(_QWORD *)(*(_QWORD *)(v21 + 704) + 8LL * v24) + 40LL);
        if ( !v30[93] )
          break;
        if ( *(_DWORD *)(v21 + 712) <= ++v24 )
          goto LABEL_16;
      }
      ++v24;
      dl_check_map_versions(v30, 0, 0, a2, a3, a4, a5, v27, v28, a8, a9, v29, v25, v26);
    }
    while ( *(_DWORD *)(v21 + 712) > v24 );
  }
LABEL_16:
  v31 = dl_debug_initialize(0LL, *(_QWORD *)(v9 + 32));
  *((_DWORD *)v31 + 6) = 0;
  v83 = v31;
  dl_debug_state();
  dl_cet_open_check(v21);
  if ( (dl_debug_mask & 0x200) != 0 )
    dl_show_scope((_QWORD *)v21, 0);
  v32 = v85 & 0x8000001;
  if ( !dl_lazy )
    v32 = v85 & 0x8000000;
  v33 = v21;
  LODWORD(v34) = 0;
  do
  {
    v35 = *(_QWORD *)(v33 + 40);
    v33 = *(_QWORD *)(v33 + 24);
    v34 = ((*(_BYTE *)(v35 + 796) & 4) == 0) + (unsigned int)v34;
  }
  while ( v33 );
  v82 = &v75;
  v36 = 16 * ((unsigned __int64)(8 * v34 + 15) >> 4);
  v37 = (__int64 *)((char *)&v75 - (v36 & 0xFFFFFFFFFFFFF000LL));
  if ( &v75 != v37 )
  {
    while ( v74 != v37 )
      ;
  }
  v38 = v36 & 0xFFF;
  if ( v38 )
  {
    v39 = alloca(v38);
    *(_QWORD *)((char *)&v74[-1] + v38) = *(_QWORD *)((char *)&v74[-1] + v38);
  }
  v40 = v21;
  v41 = 0;
  do
  {
    if ( (*(_BYTE *)(*(_QWORD *)(v40 + 40) + 796LL) & 4) == 0 )
    {
      v42 = v41++;
      v74[v42] = v40;
    }
    v40 = *(_QWORD *)(v40 + 24);
  }
  while ( v40 );
  v43 = v41;
  v84 = v41;
  dl_sort_maps((__int64)v74, v41, 0LL, 0);
  v47 = (u32 *)v84;
  v48 = v84 - 1;
  if ( v84 )
  {
    for ( i = v74[v48]; ; i = v74[v48] )
    {
      v43 = *(_QWORD *)(i + 904);
      --v48;
      dl_relocate_object(i, (__int64 *)v43, v32, 0, v47, v44, a2, a3, a4, a5, v45, v46, a8, a9);
      if ( v48 == -1 )
        break;
    }
    v50 = (_QWORD *)*(unsigned int *)(v21 + 712);
    v81 = 1;
    v51 = (unsigned int)v50;
    if ( !(_DWORD)v50 )
      goto LABEL_52;
  }
  else
  {
    v50 = (_QWORD *)*(unsigned int *)(v21 + 712);
    v81 = 0;
    v51 = (unsigned int)v50;
    if ( !(_DWORD)v50 )
      goto LABEL_52;
  }
  v80 = v9;
  v52 = 0;
  v53 = v21;
  LOBYTE(v84) = 0;
  do
  {
    v55 = *(_QWORD *)(*(_QWORD *)(v53 + 704) + 8LL * v52);
    v56 = *(_BYTE *)(v55 + 796) & 0xB;
    if ( (_BYTE)v56 != 10 )
    {
      LODWORD(v54) = 0;
      if ( (*(_BYTE *)(v55 + 796) & 8) == 0 )
      {
        if ( *(_QWORD *)(v55 + 1072) )
        {
          dl_add_to_slotinfo(*(_QWORD *)(*(_QWORD *)(v53 + 704) + 8LL * v52), v43, v50, v56, v47, v44);
          LOBYTE(v84) = 1;
          if ( (*(_BYTE *)(v55 + 797) & 4) != 0 && *(_DWORD *)(v53 + 712) == v51 )
            v51 = v52;
        }
      }
      if ( (dl_debug_mask & 0x200) != 0 )
        goto LABEL_51;
      goto LABEL_39;
    }
    v43 = *(_QWORD *)(v55 + 904);
    if ( !*(_QWORD *)v43 )
    {
      v56 = 1LL;
      v54 = 0LL;
      goto LABEL_48;
    }
    if ( *(_QWORD *)v43 != v53 + 704 )
    {
      v56 = 0LL;
      while ( 1 )
      {
        v54 = v56 + 1;
        v57 = *(_QWORD *)(v43 + 8 * (v56 + 1));
        if ( !v57 )
          break;
        ++v56;
        if ( v53 + 704 == v57 )
          goto LABEL_40;
      }
      v56 += 2LL;
LABEL_48:
      v58 = *(_QWORD *)(v55 + 896);
      if ( v58 <= v56 )
      {
        v66 = v55 + 864;
        if ( v58 > 3 || (v67 = (_QWORD *)(v55 + 864), v79 = 4LL, v66 == v43) )
        {
          v76 = v56;
          v77 = v43;
          v78 = v55 + 864;
          v79 = 2 * v58;
          v72 = malloc(16 * v58, v43, v50, v56, v47, v44);
          v66 = v78;
          v43 = v77;
          v67 = v72;
          v56 = v76;
          if ( !v72 )
            dl_signal_error(12, "dlopen", 0LL, "cannot create scope list");
        }
        v76 = v56;
        v77 = v66;
        v78 = 8 * v54;
        v68 = j_memcpy(v67, v43, 8 * v54);
        v70 = *(_QWORD *)(v55 + 904);
        v71 = v77;
        *(_QWORD *)(v55 + 904) = v68;
        v43 = v68;
        v44 = v78;
        v56 = v76;
        if ( v71 != v70 )
        {
          v77 = v78;
          v78 = v76;
          dl_scope_free(v70, v68, v69, v76, v47, v44);
          v43 = *(_QWORD *)(v55 + 904);
          v44 = v77;
          v56 = v78;
        }
        *(_QWORD *)(v55 + 896) = v79;
      }
      else
      {
        v44 = 8 * v54;
      }
      *(_QWORD *)(v43 + 8 * v56) = 0LL;
      *(_QWORD *)(*(_QWORD *)(v55 + 904) + v44) = v53 + 704;
      if ( (dl_debug_mask & 0x200) != 0 )
      {
LABEL_51:
        v43 = (unsigned int)v54;
        dl_show_scope((_QWORD *)v55, v54);
      }
LABEL_39:
      v50 = (_QWORD *)*(unsigned int *)(v53 + 712);
    }
LABEL_40:
    ++v52;
  }
  while ( (unsigned int)v50 > v52 );
  v21 = v53;
  v9 = v80;
  if ( (_BYTE)v84 )
  {
    if ( !++dl_tls_generation )
    {
      dl_dprintf(2, "TLS generation counter wrapped!  Please report this.", v50, v56);
      exit(127);
    }
  }
  if ( (unsigned int)v50 > v51 )
  {
    do
    {
      v64 = *(_QWORD *)(v21 + 704);
      v65 = *(_QWORD *)(v64 + 8LL * v51);
      if ( (*(_WORD *)(v65 + 796) & 0x408) == 1024 )
      {
        if ( *(_QWORD *)(v65 + 1072) )
        {
          *(_BYTE *)(v65 + 797) &= ~4u;
          dl_init_static_tls(v65, v43, v64);
          if ( (*(_BYTE *)(v65 + 797) & 4) != 0 )
            _assert_fail((__int64)"imap->l_need_tls_init == 0", (__int64)"dl-open.c", 0x1EDu, "dl_open_worker");
        }
      }
      ++v51;
    }
    while ( *(_DWORD *)(v21 + 712) > v51 );
  }
LABEL_52:
  v59 = *(unsigned int *)(v9 + 40);
  result = (signed __int64)dl_init(v21, v59, *(_QWORD *)(v9 + 48), *(_QWORD *)(v9 + 56));
  if ( (v85 & 0x100) == 0 || (result = add_to_global(v21, v59, v60, v61, v62, v63), !(_DWORD)result) )
  {
    _libc_multiple_libcs = 1;
    if ( (dl_debug_mask & 0x40) != 0 )
      return dl_debug_printf(
               "opening file=%s [%lu]; direct_opencount=%u\n\n",
               *(const char **)(v21 + 8),
               *(_QWORD *)(v21 + 48),
               *(unsigned int *)(v21 + 792));
  }
  return result;
}
// 4748BC: variable 'v20' is possibly undefined
// 474901: variable 'v27' is possibly undefined
// 474901: variable 'v28' is possibly undefined
// 474901: variable 'v29' is possibly undefined
// 474901: variable 'v25' is possibly undefined
// 474901: variable 'v26' is possibly undefined
// 474A47: variable 'v47' is possibly undefined
// 474A47: variable 'v44' is possibly undefined
// 474A47: variable 'v45' is possibly undefined
// 474A47: variable 'v46' is possibly undefined
// 474D33: variable 'v60' is possibly undefined
// 474D33: variable 'v61' is possibly undefined
// 474D33: variable 'v62' is possibly undefined
// 474D33: variable 'v63' is possibly undefined
// 474DC0: variable 'v69' is possibly undefined
// 474E32: variable 'v18' is possibly undefined
// 474E32: variable 'v23' is possibly undefined
// 474E32: variable 'v19' is possibly undefined
// 474EFD: variable 'v56' is possibly undefined
// 401040: using guessed type __int64 __fastcall j_memcpy(_QWORD, _QWORD, _QWORD);
// 4010D0: using guessed type __int64 __fastcall j_strchr_ifunc(_QWORD, _QWORD);
// 4A9240: using guessed type __int64 (__fastcall *dl_init_static_tls)(_QWORD, _QWORD, _QWORD);
// 4A9280: using guessed type void *dl_ns;
// 4A97B8: using guessed type int _libc_multiple_libcs;
// 4AB7F0: using guessed type __int64 dl_tls_generation;
// 4AB880: using guessed type int dl_debug_mask;
// 4AB8B8: using guessed type int dl_lazy;

//----- (0000000000474F30) ----------------------------------------------------
__int64 __fastcall remove_slotinfo(__int64 a1, unsigned __int64 *a2, __int64 a3, unsigned __int8 a4)
{
  unsigned __int64 v5; // rax
  unsigned __int64 v7; // rdx
  unsigned __int64 *v8; // rsi
  unsigned __int64 *v9; // rax
  unsigned __int64 v10; // rdx
  __int64 v11; // rsi
  unsigned __int64 v13; // rcx
  unsigned __int64 v14; // rdi
  __int64 v15; // rsi

  v5 = a1 - a3;
  v7 = *a2;
  if ( v5 < *a2 )
  {
    v9 = &a2[2 * v5];
    v10 = v9[3];
    if ( v10 )
    {
      if ( *(_QWORD *)(v10 + 1104) != a1 )
        _assert_fail((__int64)"old_map->l_tls_modid == idx", (__int64)"dl-close.c", 0x50u, "remove_slotinfo");
      v11 = dl_tls_generation;
      v9[3] = 0LL;
      v9[2] = v11 + 1;
    }
    if ( dl_tls_max_dtv_idx != a1 )
      return 1LL;
  }
  else
  {
    v8 = (unsigned __int64 *)a2[1];
    if ( v8 )
    {
      if ( (unsigned __int8)remove_slotinfo(a1, v8, a3 + v7, a4) )
        return 1LL;
      a1 = a3 + *a2;
    }
    else if ( a4 )
    {
      _assert_fail((__int64)"! should_be_there", (__int64)"dl-close.c", 0x3Bu, "remove_slotinfo");
    }
  }
  v13 = dl_tls_static_nelem + 1;
  if ( a3 )
    v13 = 0LL;
  v14 = a1 - a3;
  do
  {
    if ( v14 <= v13 )
      return 0LL;
    v15 = a3 - 1 + v14--;
  }
  while ( !a2[2 * v14 + 3] );
  dl_tls_max_dtv_idx = v15;
  return 1LL;
}
// 4AB3D0: using guessed type __int64 dl_tls_max_dtv_idx;
// 4AB7F0: using guessed type __int64 dl_tls_generation;
// 4AB7F8: using guessed type __int64 dl_tls_static_nelem;

//----- (0000000000475060) ----------------------------------------------------
void __fastcall dl_close_worker(__int64 a1, char a2)
{
  sub_47506E(a1, a2);
}

//----- (000000000047506E) ----------------------------------------------------
void __fastcall sub_47506E(__int64 a1, char a2)
{
  __int64 v2; // rax
  int v3; // ecx
  __int64 v4; // rdx
  __int64 v5; // r14
  unsigned int v6; // er15
  unsigned __int64 v7; // rax
  __int64 *v8; // rcx
  unsigned int v9; // eax
  unsigned __int64 v10; // rax
  _BYTE *v11; // rdx
  unsigned int v12; // eax
  unsigned __int64 v13; // rax
  _QWORD *v14; // rcx
  unsigned int v15; // eax
  void *v16; // rsp
  _DWORD *v17; // rax
  _QWORD *v18; // rcx
  int v19; // edx
  int v20; // edi
  __int64 v21; // rcx
  __int64 v22; // rax
  unsigned int *v23; // rsi
  unsigned int v24; // edx
  int v25; // eax
  __int64 v26; // r8
  __int64 v27; // rax
  void *v28; // rsp
  void *v29; // rsp
  __int64 *v30; // rdx
  __int64 v31; // rax
  int v32; // eax
  __int64 v33; // rax
  __int64 v34; // r14
  __int64 v35; // rbx
  char v36; // r11
  __int64 v37; // r15
  __int64 v38; // rax
  __int64 v39; // rdx
  char v40; // al
  int v41; // er13
  char v42; // dl
  unsigned __int64 v43; // r8
  __int64 v44; // rcx
  __int64 v45; // rdx
  __int64 v46; // r12
  unsigned __int64 v47; // r9
  __int64 v48; // rsi
  __int64 v49; // rax
  __int64 v50; // rdi
  _QWORD *v51; // rax
  u32 *v52; // r8
  __int64 *v53; // rdi
  __int64 v54; // r10
  __int64 v55; // rdi
  int v56; // eax
  bool v57; // zf
  char v58; // al
  __int64 v59; // rax
  __int64 v60; // rbx
  unsigned int v61; // er15
  void (**v62)(void); // rcx
  __int64 v63; // rax
  void (**v64)(void); // rbx
  void (**v65)(void); // r12
  __int64 v66; // rax
  int i; // edx
  int v68; // eax
  __int64 v69; // rdx
  __int64 *v70; // rax
  __int64 v71; // rdx
  __int64 v72; // rdi
  __int64 v73; // rsi
  void **v74; // rax
  __int64 v75; // r8
  __int64 v76; // r9
  __int64 v77; // rcx
  __int64 v78; // rax
  __int64 v79; // rdi
  _BYTE *v80; // r12
  __int64 *v81; // r13
  __int64 v82; // rbx
  __int64 v83; // r14
  char *v84; // rax
  __int64 v85; // rcx
  u32 *v86; // r8
  unsigned __int64 v87; // r9
  __int64 v88; // rdx
  __int64 v89; // rax
  __int64 v90; // rdx
  __int64 v91; // rcx
  u32 *v92; // r8
  unsigned __int64 v93; // r9
  __int64 v94; // rdi
  __int64 v95; // rdx
  __int64 v96; // rcx
  u32 *v97; // r8
  unsigned __int64 v98; // r9
  __int64 v99; // rdx
  __int64 v100; // rcx
  u32 *v101; // r8
  unsigned __int64 v102; // r9
  __int64 v103; // rdi
  __int64 v104; // r15
  __int64 v105; // rdx
  __int64 v106; // rcx
  u32 *v107; // r8
  unsigned __int64 v108; // r9
  __int64 v109; // rdi
  __int64 v110; // rdi
  __int64 v111; // rdi
  void **v112; // rcx
  void *v113; // rdx
  char *v114; // rdx
  unsigned __int64 v115; // rax
  __int64 v116; // rdx
  int v117; // edx
  __int64 v118; // rax
  __int64 v119; // rdx
  __int64 v120; // rcx
  u32 *v121; // r8
  unsigned __int64 v122; // r9
  __int64 *v123; // r12
  __int64 v124; // rax
  __int64 v125; // rax
  __int64 v126; // rdx
  __int64 v127; // rdi
  _QWORD v129[512]; // [rsp+8h] [rbp-30D0h] BYREF
  _BYTE v130[4096]; // [rsp+1008h] [rbp-20D0h] BYREF
  _BYTE v131[4088]; // [rsp+2008h] [rbp-10D0h] BYREF
  __int64 v132; // [rsp+3008h] [rbp-D0h] BYREF
  unsigned int v133; // [rsp+3014h] [rbp-C4h]
  void **v134; // [rsp+3018h] [rbp-C0h]
  __int64 v135; // [rsp+3020h] [rbp-B8h]
  __int64 v136; // [rsp+3028h] [rbp-B0h]
  __int64 v137; // [rsp+3030h] [rbp-A8h]
  char v138; // [rsp+303Ah] [rbp-9Eh]
  unsigned __int8 v139; // [rsp+303Bh] [rbp-9Dh]
  unsigned int v140; // [rsp+303Ch] [rbp-9Ch]
  __int64 v141; // [rsp+3040h] [rbp-98h]
  __int64 *v142; // [rsp+3048h] [rbp-90h]
  __int64 v143; // [rsp+3050h] [rbp-88h]
  __int64 v144; // [rsp+3058h] [rbp-80h]
  void **v145; // [rsp+3060h] [rbp-78h]
  __int64 v146; // [rsp+3068h] [rbp-70h]
  __int64 v147; // [rsp+3070h] [rbp-68h]
  char v148; // [rsp+307Ah] [rbp-5Eh]
  char v149; // [rsp+307Bh] [rbp-5Dh]
  unsigned int v150; // [rsp+307Ch] [rbp-5Ch]
  __int64 v151; // [rsp+3080h] [rbp-58h]
  __int64 v152; // [rsp+3088h] [rbp-50h]
  _BYTE *v153; // [rsp+3090h] [rbp-48h]
  unsigned __int64 v154; // [rsp+3098h] [rbp-40h]
  _QWORD *v155; // [rsp+30A0h] [rbp-38h]

  v3 = *(_DWORD *)(a1 + 792);
  v149 = a2;
  v141 = a1;
  v4 = (unsigned int)(v3 - 1);
  LODWORD(v155) = v3;
  *(_DWORD *)(a1 + 792) = v4;
  if ( (v2 & *(_QWORD *)(a1 + 792)) == 0x200000000LL )
  {
    if ( !dl_close_state_11871 )
    {
      v151 = v2;
      v146 = *(_QWORD *)(v141 + 48);
      v132 = v146 == 0 ? 8 : 0;
      v134 = &dl_ns + 18 * v146 + 4;
      v145 = &dl_ns + 18 * v146;
      while ( 1 )
      {
        dl_close_state_11871 = 1;
        v142 = &v132;
        v5 = *((unsigned int *)v145 + 2);
        v6 = *((_DWORD *)v145 + 2);
        v7 = 16 * ((unsigned __int64)(v5 + 15) >> 4);
        v8 = (__int64 *)((char *)&v132 - (v7 & 0xFFFFFFFFFFFFF000LL));
        if ( &v132 != v8 )
        {
          while ( v131 != (_BYTE *)v8 )
            ;
        }
        v9 = v7 & 0xFFF;
        if ( v9 )
        {
          v28 = alloca(v9);
          *(_QWORD *)&v130[v9 + 4088] = *(_QWORD *)&v130[v9 + 4088];
        }
        v10 = 16 * ((unsigned __int64)(v5 + 15) >> 4);
        v11 = &v131[-(v10 & 0xFFFFFFFFFFFFF000LL)];
        if ( v131 != v11 )
        {
          while ( v130 != v11 )
            ;
        }
        v12 = v10 & 0xFFF;
        if ( v12 )
        {
          v29 = alloca(v12);
          *(_QWORD *)((char *)&v129[511] + v12) = *(_QWORD *)((char *)&v129[511] + v12);
        }
        v13 = 16 * ((unsigned __int64)(8 * v5 + 15) >> 4);
        v14 = &v130[-(v13 & 0xFFFFFFFFFFFFF000LL)];
        if ( v130 != (_BYTE *)v14 )
        {
          while ( v129 != v14 )
            ;
        }
        v15 = v13 & 0xFFF;
        if ( v15 )
        {
          v16 = alloca(v15);
          *(_QWORD *)((char *)&v129[-1] + v15) = *(_QWORD *)((char *)&v129[-1] + v15);
        }
        v155 = v129;
        if ( v149 )
          *(_DWORD *)(v141 + 988) &= ~8u;
        v17 = *v145;
        if ( *v145 )
        {
          v18 = v129;
          v19 = 0;
          do
          {
            v17[249] = v19;
            ++v18;
            ++v19;
            *(v18 - 1) = v17;
            v17 = (_DWORD *)*((_QWORD *)v17 + 3);
          }
          while ( v17 );
        }
        else
        {
          v19 = 0;
        }
        if ( v6 != v19 )
          _assert_fail((__int64)"idx == nloaded", (__int64)"dl-close.c", 0xA5u, "_dl_close_worker");
        j_memset_ifunc(v131, 0LL, v5);
        j_memset_ifunc(v130, 0LL, v5);
        v20 = -1;
LABEL_23:
        while ( v6 > ++v20 )
        {
          while ( !v130[v20] )
          {
            v21 = v155[v20];
            if ( (*(_QWORD *)(v21 + 792) & v151) != 0x200000000LL
              || (*(_BYTE *)(v21 + 988) & 8) != 0
              || *(_QWORD *)(v21 + 1112)
              || v131[v20] )
            {
              v131[v20] = 1;
              v130[v20] = 1;
              v22 = *(_QWORD *)(v21 + 960);
              *(_DWORD *)(v21 + 996) = -1;
              if ( v22 )
              {
                v30 = (__int64 *)(v22 + 8);
                v31 = *(_QWORD *)(v22 + 8);
                if ( v31 )
                {
                  do
                  {
                    v33 = *(int *)(v31 + 996);
                    if ( (_DWORD)v33 != -1 )
                    {
                      if ( (int)v33 < 0 || v6 <= (unsigned int)v33 )
                        _assert_fail(
                          (__int64)"(*lp)->l_idx >= 0 && (*lp)->l_idx < nloaded",
                          (__int64)"dl-close.c",
                          0xCFu,
                          "_dl_close_worker");
                      if ( !v131[v33] )
                      {
                        v131[v33] = 1;
                        v32 = *(_DWORD *)(*v30 + 996);
                        if ( v32 <= v20 )
                          v20 = v32 - 1;
                      }
                    }
                    v31 = *++v30;
                  }
                  while ( *v30 );
                }
              }
              v23 = *(unsigned int **)(v21 + 968);
              if ( v23 && *v23 )
              {
                v24 = 0;
                do
                {
                  v26 = *(_QWORD *)&v23[2 * v24 + 2];
                  v27 = *(int *)(v26 + 996);
                  if ( (_DWORD)v27 != -1 )
                  {
                    if ( (int)v27 < 0 || v6 <= (unsigned int)v27 )
                      _assert_fail(
                        (__int64)"jmap->l_idx >= 0 && jmap->l_idx < nloaded",
                        (__int64)"dl-close.c",
                        0xE8u,
                        "_dl_close_worker");
                    if ( !v131[v27] )
                    {
                      v131[v27] = 1;
                      v25 = *(_DWORD *)(v26 + 996);
                      if ( v25 <= v20 )
                        v20 = v25 - 1;
                      v23 = *(unsigned int **)(v21 + 968);
                    }
                  }
                  ++v24;
                }
                while ( v24 < *v23 );
              }
              goto LABEL_23;
            }
            if ( v6 <= ++v20 )
              goto LABEL_56;
          }
        }
LABEL_56:
        v34 = v146;
        dl_sort_maps((__int64)v155 + v132, v6 - (v146 == 0), (__int64)&v131[v146 == 0], 1);
        if ( !v6 )
          goto LABEL_105;
        if ( v34 != *(_QWORD *)(v129[0] + 48LL) )
LABEL_205:
          _assert_fail((__int64)"imap->l_ns == nsid", (__int64)"dl-close.c", 0x106u, "_dl_close_worker");
        v153 = v131;
        v35 = v129[0];
        v133 = v6 - 1;
        v152 = v6 - 1;
        v140 = v6;
        v36 = 0;
        v37 = 0LL;
        v150 = 0;
        v148 = 0;
        LODWORD(v154) = -1;
        while ( 1 )
        {
          v40 = *(_BYTE *)(v35 + 796);
          v41 = v37;
          v42 = v40 & 3;
          if ( !v153[v37] )
          {
            if ( v42 != 2 || (*(_BYTE *)(v35 + 988) & 8) != 0 )
              _assert_fail(
                (__int64)"imap->l_type == lt_loaded && (imap->l_flags_1 & DF_1_NODELETE) == 0",
                (__int64)"dl-close.c",
                0x10Bu,
                "_dl_close_worker");
            if ( (v40 & 8) != 0 )
            {
              if ( (dl_debug_mask & 2) != 0 )
                dl_debug_printf("\ncalling fini: %s [%lu]\n\n", *(const char **)(v35 + 8), v34);
              v38 = *(_QWORD *)(v35 + 272);
              if ( v38 )
              {
                v62 = (void (**)(void))(*(_QWORD *)(v38 + 8) + *(_QWORD *)v35);
                v63 = *(_QWORD *)(*(_QWORD *)(v35 + 288) + 8LL) >> 3;
                if ( (_DWORD)v63 )
                {
                  v147 = v35;
                  v64 = &v62[(unsigned int)(v63 - 1)];
                  v65 = v62;
                  while ( 1 )
                  {
                    (*v64)();
                    if ( v65 == v64 )
                      break;
                    --v64;
                  }
                  v35 = v147;
                }
              }
              v39 = *(_QWORD *)(v35 + 168);
              if ( v39 )
                ((void (*)(void))(*(_QWORD *)(v39 + 8) + *(_QWORD *)v35))();
              v40 = *(_BYTE *)(v35 + 796);
            }
            *(_BYTE *)(v35 + 797) |= 0x20u;
            v36 = 1;
            v150 -= ((v40 & 0x10) == 0) - 1;
            if ( (unsigned int)v154 <= (unsigned int)v37 )
              v41 = v154;
            LODWORD(v154) = v41;
LABEL_71:
            if ( v152 == v37 )
              break;
            goto LABEL_72;
          }
          if ( v42 != 2 )
            goto LABEL_71;
          if ( *(_QWORD *)(v35 + 704) )
          {
            v43 = 1LL;
            v44 = 0LL;
            v45 = **(_QWORD **)(v35 + 904);
            v147 = *(_QWORD *)(v35 + 904);
            if ( !v45 )
              goto LABEL_98;
          }
          else
          {
            v44 = *(_QWORD *)(v35 + 960);
            if ( v44 )
            {
              if ( *(_QWORD *)(v44 + 8) )
              {
                for ( i = 1; ; ++i )
                {
                  v68 = i + 1;
                  if ( !*(_QWORD *)(v44 + 8LL * (unsigned int)(i + 1)) )
                    break;
                }
                v69 = 8LL * (unsigned int)(i + 2);
              }
              else
              {
                v69 = 16LL;
                v68 = 1;
              }
              *(_DWORD *)(v35 + 712) = v68;
              v70 = *(__int64 **)(v35 + 904);
              v71 = v44 + v69;
              v44 = v35 + 704;
              *(_QWORD *)(v35 + 704) = v71;
              v45 = *v70;
              v147 = (__int64)v70;
              if ( !v45 )
              {
LABEL_113:
                *(_QWORD *)(v35 + 704) = 0LL;
                *(_DWORD *)(v35 + 712) = 0;
                goto LABEL_98;
              }
              v43 = 2LL;
            }
            else
            {
              v43 = 1LL;
              v45 = **(_QWORD **)(v35 + 904);
              v147 = *(_QWORD *)(v35 + 904);
              if ( !v45 )
                goto LABEL_98;
            }
          }
          v46 = v35 + 720;
          v47 = 0LL;
          v48 = v147 + 8;
          v49 = v45;
          v50 = v147 + 8;
          do
          {
            while ( v49 != v46 )
            {
              if ( v34 != *(_QWORD *)(v49 - 656) )
                _assert_fail((__int64)"tmap->l_ns == nsid", (__int64)"dl-close.c", 0x16Du, "_dl_close_worker");
              if ( *(_DWORD *)(v49 + 292) == -1 )
                break;
              v50 += 8LL;
              v49 = *(_QWORD *)(v50 - 8);
              v47 = 1LL;
              if ( !v49 )
                goto LABEL_83;
            }
            v50 += 8LL;
            v49 = *(_QWORD *)(v50 - 8);
            ++v43;
          }
          while ( v49 );
LABEL_83:
          if ( (_BYTE)v47 )
          {
            v51 = (_QWORD *)(v35 + 864);
            v144 = v35 + 864;
            if ( v43 > 3 || (v143 = 4LL, v51 == (_QWORD *)v147) )
            {
              v66 = *(_QWORD *)(v35 + 896);
              v138 = v36;
              v135 = v44;
              v139 = v47;
              v136 = v45;
              v137 = v147 + 8;
              v143 = v66;
              v51 = malloc(8 * v66, v48, (_QWORD *)v45, v44, (u32 *)v43, v47);
              v48 = v137;
              v45 = v136;
              v47 = v139;
              v44 = v135;
              v36 = v138;
              if ( !v51 )
                dl_signal_error(12, "dlclose", 0LL, "cannot create scope list");
            }
            v52 = 0LL;
            do
            {
              while ( 1 )
              {
                v54 = (__int64)v52;
                v53 = &v51[(_QWORD)v52];
                if ( v45 != v46 && *(_DWORD *)(v45 + 292) != -1 )
                  break;
                v48 += 8LL;
                *v53 = v45;
                v52 = (u32 *)((char *)v52 + 1);
                v53 = &v51[v54 + 1];
                v45 = *(_QWORD *)(v48 - 8);
                if ( !v45 )
                  goto LABEL_93;
              }
              if ( v44 )
              {
                *v53 = v44;
                v52 = (u32 *)((char *)v52 + 1);
                v53 = &v51[v54 + 1];
                v44 = 0LL;
              }
              v48 += 8LL;
              v45 = *(_QWORD *)(v48 - 8);
            }
            while ( v45 );
LABEL_93:
            *v53 = 0LL;
            v55 = v147;
            *(_QWORD *)(v35 + 904) = v51;
            if ( v144 == v55 )
            {
              v148 = v47;
            }
            else
            {
              LOBYTE(v147) = v36;
              v56 = dl_scope_free(v55, v48, (_QWORD *)v45, v44, v52, v47);
              v36 = v147;
              v57 = v56 == 0;
              v58 = v148;
              if ( !v57 )
                v58 = 0;
              v148 = v58;
            }
            *(_QWORD *)(v35 + 896) = v143;
          }
          else if ( v44 )
          {
            goto LABEL_113;
          }
LABEL_98:
          v59 = *(_QWORD *)(v35 + 736);
          if ( v59 && *(_DWORD *)(v59 + 996) != -1 )
            *(_QWORD *)(v35 + 736) = 0LL;
          if ( (unsigned int)v154 <= (unsigned int)v37 )
            v41 = v154;
          LODWORD(v154) = v41;
          if ( v152 == v37 )
            break;
LABEL_72:
          v35 = v155[++v37];
          if ( v34 != *(_QWORD *)(v35 + 48) )
            goto LABEL_205;
        }
        v60 = (__int64)v153;
        v61 = v140;
        LOBYTE(v153) = v36;
        if ( !v36 )
          goto LABEL_105;
        v72 = 0LL;
        v73 = v146;
        v74 = dl_debug_initialize(0LL, v146);
        *((_DWORD *)v74 + 6) = 2;
        v147 = (__int64)v74;
        dl_debug_state();
        v77 = v150;
        if ( v150 )
        {
          v73 = (__int64)v145[2];
          v117 = *(_DWORD *)(v73 + 8);
          if ( v117 )
          {
            v77 = *(_QWORD *)v73;
            v118 = (unsigned int)(v117 - 1);
            v72 = *(_QWORD *)(*(_QWORD *)v73 + 8 * v118);
            if ( (*(_BYTE *)(v72 + 797) & 0x20) != 0 )
            {
              while ( (_DWORD)v118 )
              {
                v72 = (unsigned int)(v118 - 1);
                v75 = *(_QWORD *)(v77 + 8 * v72);
                if ( (*(_BYTE *)(v75 + 797) & 0x20) == 0 )
                  goto LABEL_206;
                LODWORD(v118) = v118 - 1;
              }
            }
            else
            {
              LODWORD(v118) = *(_DWORD *)(v73 + 8);
LABEL_206:
              v72 = (unsigned int)v118 + v150;
              if ( v117 != (_DWORD)v72 )
              {
                v75 = (unsigned int)(v118 - 1);
                v126 = 0LL;
                LODWORD(v118) = 0;
                while ( 1 )
                {
                  v127 = *(_QWORD *)(v77 + 8 * v126);
                  if ( (*(_BYTE *)(v127 + 797) & 0x20) == 0 )
                  {
                    if ( (_DWORD)v118 != (_DWORD)v126 )
                    {
                      v76 = (unsigned int)v118;
                      *(_QWORD *)(v77 + 8LL * (unsigned int)v118) = v127;
                    }
                    LODWORD(v118) = v118 + 1;
                  }
                  v72 = v126 + 1;
                  if ( v75 == v126 )
                    break;
                  ++v126;
                }
              }
            }
          }
          else
          {
            LODWORD(v118) = 0;
          }
          *(_DWORD *)(v73 + 8) = v118;
        }
        if ( __readfsdword(0x18u) && (v150 || v148 || dl_scope_free_list && *(_QWORD *)dl_scope_free_list) )
        {
          dl_wait_lookup_done(v72, v73, v150, v77, v75, v76);
          v123 = (__int64 *)dl_scope_free_list;
          if ( dl_scope_free_list )
          {
            v124 = *(_QWORD *)dl_scope_free_list;
            if ( *(_QWORD *)dl_scope_free_list )
            {
              do
              {
                v125 = v124 - 1;
                *v123 = v125;
                free(v123[v125 + 1], v73, v119, v120, v121, v122);
                v124 = *v123;
              }
              while ( *v123 );
            }
          }
        }
        if ( v61 > (unsigned int)v154 )
        {
          v78 = (unsigned int)v154;
          v79 = (__int64)v155;
          LOBYTE(v155) = 0;
          v154 = 0LL;
          v80 = (_BYTE *)(v60 + v78);
          v81 = (__int64 *)(v79 + 8 * v78);
          v152 = 0LL;
          v82 = v133 - (unsigned int)v78 + v60 + v78 + 1;
          while ( 1 )
          {
            while ( *v80 )
            {
              ++v80;
              ++v81;
              if ( (_BYTE *)v82 == v80 )
                goto LABEL_158;
            }
            v83 = *v81;
            if ( (*(_BYTE *)(*v81 + 796) & 3) != 2 )
              _assert_fail((__int64)"imap->l_type == lt_loaded", (__int64)"dl-close.c", 0x225u, "_dl_close_worker");
            if ( !*(_QWORD *)(v83 + 1072) )
              goto LABEL_135;
            v73 = dl_tls_dtv_slotinfo_list;
            if ( dl_tls_dtv_slotinfo_list
              && !(unsigned __int8)remove_slotinfo(
                                     *(_QWORD *)(v83 + 1104),
                                     (unsigned __int64 *)dl_tls_dtv_slotinfo_list,
                                     0LL,
                                     (*(_BYTE *)(*v81 + 796) & 8) != 0) )
            {
              dl_tls_max_dtv_idx = dl_tls_static_nelem;
            }
            v115 = *(_QWORD *)(v83 + 1096);
            LOBYTE(v155) = (_BYTE)v153;
            if ( v115 + 1 <= 1 )
              goto LABEL_135;
            v116 = v115 - *(_QWORD *)(v83 + 1072);
            if ( !v152 || v115 == v152 )
              break;
            if ( v116 == v154 )
            {
              v154 = v115;
              LOBYTE(v155) = (_BYTE)v153;
              goto LABEL_135;
            }
            if ( dl_tls_static_used == v154 )
            {
              dl_tls_static_used = v152;
LABEL_183:
              v154 = v115;
LABEL_184:
              v152 = v116;
              LOBYTE(v155) = (_BYTE)v153;
              goto LABEL_135;
            }
            if ( v115 == dl_tls_static_used )
            {
              dl_tls_static_used = v115 - *(_QWORD *)(v83 + 1072);
              LOBYTE(v155) = (_BYTE)v153;
            }
            else
            {
              LOBYTE(v155) = (_BYTE)v153;
              if ( v115 > v154 )
              {
                v154 = v115;
                v152 = v116;
              }
            }
LABEL_135:
            if ( v149 )
            {
              v84 = (char *)v145[9];
              if ( v84 )
              {
                v112 = v145;
                v113 = v145[10];
                if ( v113 )
                {
                  v114 = &v84[32 * (_QWORD)v113];
                  do
                  {
                    if ( *((_QWORD *)v84 + 1) && v83 == *((_QWORD *)v84 + 3) )
                    {
                      *((_QWORD *)v84 + 1) = 0LL;
                      *(_DWORD *)v84 = 0;
                      v112[11] = (char *)v112[11] - 1;
                    }
                    v84 += 32;
                  }
                  while ( v84 != v114 );
                }
              }
            }
            dl_unmap(v83);
            if ( v146 )
              _assert_fail((__int64)"nsid == LM_ID_BASE", (__int64)"dl-close.c", 0x2B1u, "_dl_close_worker");
            v88 = *(_QWORD *)(v83 + 32);
            if ( !v88 )
              _assert_fail((__int64)"imap->l_prev != NULL", (__int64)"dl-close.c", 0x2B2u, "_dl_close_worker");
            v89 = *(_QWORD *)(v83 + 24);
            --dword_4A9288;
            *(_QWORD *)(v88 + 24) = v89;
            if ( v89 )
              *(_QWORD *)(v89 + 32) = v88;
            free(*(_QWORD *)(v83 + 744), v73, v88, v85, v86, v87);
            v94 = *(_QWORD *)(v83 + 832);
            if ( v94 != -1 )
              free(v94, v73, v90, v91, v92, v93);
            free(*(_QWORD *)(v83 + 968), v73, v90, v91, v92, v93);
            if ( (dl_debug_mask & 0x40) != 0 )
            {
              v73 = *(_QWORD *)(v83 + 8);
              dl_debug_printf("\nfile=%s [%lu];  destroying link map\n", (const char *)v73, *(_QWORD *)(v83 + 48));
            }
            free(*(_QWORD *)(v83 + 8), v73, v95, v96, v97, v98);
            v103 = *(_QWORD *)(v83 + 56);
            do
            {
              while ( 1 )
              {
                v104 = *(_QWORD *)(v103 + 8);
                if ( !*(_DWORD *)(v103 + 16) )
                  break;
                v103 = *(_QWORD *)(v103 + 8);
                if ( !v104 )
                  goto LABEL_149;
              }
              free(v103, v73, v99, v100, v101, v102);
              v103 = v104;
            }
            while ( v104 );
LABEL_149:
            free(*(_QWORD *)(v83 + 960), v73, v99, v100, v101, v102);
            v109 = *(_QWORD *)(v83 + 904);
            if ( v109 != v83 + 864 )
              free(v109, v73, v105, v106, v107, v108);
            if ( *(char *)(v83 + 796) < 0 )
              free(*(_QWORD *)(v83 + 680), v73, v105, v106, v107, v108);
            v110 = *(_QWORD *)(v83 + 800);
            if ( v110 != -1 )
              free(v110, v73, v105, v106, v107, v108);
            v111 = *(_QWORD *)(v83 + 944);
            if ( v111 != -1 )
              free(v111, v73, v105, v106, v107, v108);
            ++v80;
            ++v81;
            free(v83, v73, v105, v106, v107, v108);
            if ( (_BYTE *)v82 == v80 )
            {
LABEL_158:
              if ( (_BYTE)v155 )
              {
                if ( !++dl_tls_generation )
                {
                  dl_dprintf(
                    2,
                    "TLS generation counter wrapped!  Please report as described in <http://www.gnu.org/software/libc/bugs.html>.\n");
                  exit(127);
                }
                if ( dl_tls_static_used == v154 )
                  dl_tls_static_used = v152;
              }
              goto LABEL_162;
            }
          }
          if ( !v154 )
            goto LABEL_183;
          goto LABEL_184;
        }
LABEL_162:
        if ( !*v145 && dl_nns - 1 == v146 )
          dl_nns = v146;
        *(_DWORD *)(v147 + 24) = 0;
        dl_debug_state();
LABEL_105:
        if ( dl_close_state_11871 != 2 )
        {
          dl_close_state_11871 = 0;
          return;
        }
      }
    }
    dl_close_state_11871 = 2;
  }
  if ( (dl_debug_mask & 0x40) != 0 )
    dl_debug_printf("\nclosing file=%s; direct_opencount=%u\n", *(const char **)(v141 + 8), v4);
}
// 4750B0: variable 'v2' is possibly undefined
// 475ABA: variable 'v85' is possibly undefined
// 475ABA: variable 'v86' is possibly undefined
// 475ABA: variable 'v87' is possibly undefined
// 475ACC: variable 'v90' is possibly undefined
// 475ACC: variable 'v91' is possibly undefined
// 475ACC: variable 'v92' is possibly undefined
// 475ACC: variable 'v93' is possibly undefined
// 475AEE: variable 'v95' is possibly undefined
// 475AEE: variable 'v96' is possibly undefined
// 475AEE: variable 'v97' is possibly undefined
// 475AEE: variable 'v98' is possibly undefined
// 475B13: variable 'v99' is possibly undefined
// 475B13: variable 'v100' is possibly undefined
// 475B13: variable 'v101' is possibly undefined
// 475B13: variable 'v102' is possibly undefined
// 475B3F: variable 'v105' is possibly undefined
// 475B3F: variable 'v106' is possibly undefined
// 475B3F: variable 'v107' is possibly undefined
// 475B3F: variable 'v108' is possibly undefined
// 475E13: variable 'v75' is possibly undefined
// 475E13: variable 'v76' is possibly undefined
// 475E43: variable 'v119' is possibly undefined
// 475E43: variable 'v120' is possibly undefined
// 475E43: variable 'v121' is possibly undefined
// 475E43: variable 'v122' is possibly undefined
// 401090: using guessed type __int64 __fastcall j_memset_ifunc(_QWORD, _QWORD, _QWORD);
// 4A9210: using guessed type __int64 dl_nns;
// 4A9280: using guessed type void *dl_ns;
// 4A9288: using guessed type int dword_4A9288;
// 4AB1A0: using guessed type int dl_close_state_11871;
// 4AB3C0: using guessed type __int64 dl_tls_static_used;
// 4AB3D0: using guessed type __int64 dl_tls_max_dtv_idx;
// 4AB7E0: using guessed type __int64 dl_tls_dtv_slotinfo_list;
// 4AB7F0: using guessed type __int64 dl_tls_generation;
// 4AB7F8: using guessed type __int64 dl_tls_static_nelem;
// 4AB880: using guessed type int dl_debug_mask;
// 4AB888: using guessed type __int64 (__fastcall *dl_wait_lookup_done)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 4AB8D8: using guessed type __int64 dl_scope_free_list;

//----- (0000000000476000) ----------------------------------------------------
void __fastcall dl_close(__int64 a1)
{
  if ( (*(_BYTE *)(a1 + 988) & 8) == 0 )
  {
    if ( !*(_DWORD *)(a1 + 792) )
      dl_signal_error(0, *(void **)(a1 + 8), 0LL, "shared object not open");
    dl_close_worker(a1, 0);
  }
}
// 47604D: control flows out of bounds to 0

//----- (0000000000476090) ----------------------------------------------------
void __fastcall dl_sort_maps(__int64 a1, unsigned int a2, __int64 a3, char a4)
{
  unsigned __int64 v4; // rax
  _BYTE *v5; // r9
  unsigned int v6; // eax
  void *v7; // rsp
  unsigned int v8; // er15
  __int64 v9; // rcx
  unsigned int i; // er14
  _WORD *v11; // r10
  bool v12; // zf
  __int64 *v13; // rdi
  __int64 v14; // rbx
  __int64 v15; // r12
  __int64 v16; // r13
  __int64 v17; // rsi
  __int64 *v18; // rax
  unsigned __int16 *v19; // rdi
  __int64 v20; // rdx
  __int64 v21; // r13
  __int64 v22; // r9
  int v23; // er8
  __int64 v24; // r10
  __int64 v25; // rcx
  __int64 v26; // rdi
  char v27; // bl
  _DWORD *v28; // rax
  _DWORD *v29; // rdx
  unsigned int v30; // eax
  __int64 v31; // r11
  __int64 *v32; // rax
  __int64 v33; // rdx
  _BYTE v35[4088]; // [rsp+8h] [rbp-10A0h] BYREF
  _QWORD v36[2]; // [rsp+1008h] [rbp-A0h] BYREF
  __int64 v37; // [rsp+1018h] [rbp-90h]
  __int64 v38; // [rsp+1020h] [rbp-88h]
  __int64 v39; // [rsp+1028h] [rbp-80h]
  unsigned int v40; // [rsp+1034h] [rbp-74h]
  __int64 v41; // [rsp+1038h] [rbp-70h]
  __int64 v42; // [rsp+1040h] [rbp-68h]
  _WORD *v43; // [rsp+1048h] [rbp-60h]
  __int64 v44; // [rsp+1050h] [rbp-58h]
  __int64 v45; // [rsp+1058h] [rbp-50h]
  __int64 v46; // [rsp+1060h] [rbp-48h]
  unsigned int v47; // [rsp+1068h] [rbp-40h]
  __int16 v48; // [rsp+106Ch] [rbp-3Ch]
  char v49; // [rsp+106Fh] [rbp-39h]
  _BYTE *v50; // [rsp+1070h] [rbp-38h]

  v49 = a4;
  if ( a2 > 1 )
  {
    v4 = 16 * ((2 * (unsigned __int64)a2 + 15) >> 4);
    v5 = (char *)v36 - (v4 & 0xFFFFFFFFFFFFF000LL);
    if ( v36 != (_QWORD *)v5 )
    {
      while ( v35 != v5 )
        ;
    }
    v6 = v4 & 0xFFF;
    if ( v6 )
    {
      v7 = alloca(v6);
      *(_QWORD *)&v35[v6 - 8] = *(_QWORD *)&v35[v6 - 8];
    }
    v37 = a3;
    v47 = a2;
    v8 = 0;
    v46 = a1;
    v36[1] = v36;
    v50 = v35;
    j_memset_ifunc(v35, 0LL, 2LL * a2);
    v40 = a2 - 1;
    v39 = a2 - 1;
    v38 = a1 + 8 * v39;
    v9 = 0LL;
    for ( i = 1; ; ++i )
    {
LABEL_7:
      v11 = &v50[2 * v9];
      v12 = v49 == 0;
      v48 = *v11 + 1;
      *v11 = v48;
      v13 = (__int64 *)(v46 + 8 * v9);
      v14 = *v13;
      if ( (v12 || *(_QWORD *)(v14 + 40) == v14 && *(_DWORD *)(v14 + 996) != -1) && v8 < v40 )
      {
        v15 = v39;
        v16 = v38;
        do
        {
          v17 = *(_QWORD *)v16;
          v18 = *(__int64 **)(*(_QWORD *)v16 + 960LL);
          if ( v18 )
          {
            while ( 1 )
            {
              v20 = *v18;
              if ( !*v18 )
                break;
              ++v18;
              if ( v20 == v14 )
              {
LABEL_18:
                v42 = v9;
                v43 = v11;
                LODWORD(v44) = v15;
                v45 = i;
                v41 = (unsigned int)v15 - v8;
                j_memmove(v13, v46 + 8LL * i, 8 * v41);
                *(_QWORD *)v16 = v14;
                v21 = v37;
                v22 = v45;
                v23 = v44;
                v24 = (__int64)v43;
                v25 = v42;
                if ( v37 )
                {
                  v26 = v37 + v42;
                  LODWORD(v42) = v44;
                  v27 = *(_BYTE *)(v37 + v25);
                  v44 = v25;
                  j_memmove(v26, v37 + v45, v41);
                  v23 = v42;
                  v24 = (__int64)v43;
                  v25 = v44;
                  v22 = v45;
                  *(_BYTE *)(v21 + v15) = v27;
                }
                v19 = (unsigned __int16 *)&v50[2 * v22];
                if ( *v19 <= v47 - v8 )
                {
                  v44 = v25;
                  LODWORD(v45) = v23;
                  j_memmove(v24, &v50[2 * v22], 2 * v41);
                  *(_WORD *)&v50[2 * (unsigned int)v45] = v48;
                  v9 = v44;
                  goto LABEL_7;
                }
                goto LABEL_21;
              }
            }
          }
          if ( v49 )
          {
            v28 = *(_DWORD **)(v17 + 968);
            if ( v28 )
            {
              v29 = v28 + 2;
              v30 = *v28 - 1;
              while ( v30 != -1 )
              {
                v31 = v30--;
                if ( *(_QWORD *)&v29[2 * v31] == v14 )
                {
                  v32 = *(__int64 **)(v14 + 960);
                  if ( v32 )
                  {
                    while ( 1 )
                    {
                      v33 = *v32;
                      if ( !*v32 )
                        break;
                      ++v32;
                      if ( v17 == v33 )
                        goto LABEL_12;
                    }
                  }
                  goto LABEL_18;
                }
              }
            }
          }
LABEL_12:
          --v15;
          v16 -= 8LL;
        }
        while ( v8 < (unsigned int)v15 );
      }
      if ( v47 == i )
        break;
      v19 = (unsigned __int16 *)&v50[2 * i];
LABEL_21:
      v8 = i;
      j_memset_ifunc(v19, 0LL, 2LL * (v47 - i));
      v9 = i;
    }
  }
}
// 401030: using guessed type __int64 __fastcall j_memmove(_QWORD, _QWORD, _QWORD);
// 401090: using guessed type __int64 __fastcall j_memset_ifunc(_QWORD, _QWORD, _QWORD);

//----- (0000000000476380) ----------------------------------------------------
unsigned __int64 (__fastcall *__fastcall dl_tlsdesc_resolve_rela_fixup(
        __int64 a1,
        __int64 a2,
        double a3,
        double a4,
        double a5,
        double a6,
        double a7,
        double a8,
        double a9,
        double a10))()
{
  __int64 v10; // r12
  __int64 v11; // rbp
  unsigned __int64 (__fastcall *result)(); // rax
  __int64 v14; // rdx
  __int64 v15; // rdi
  unsigned int *v16; // rax
  __int64 v17; // r8
  __int64 v18; // rdx
  unsigned int *v19; // [rsp+18h] [rbp-20h] BYREF

  v10 = *(_QWORD *)(a1 + 8);
  v11 = *(_QWORD *)(*(_QWORD *)(a2 + 664) + 8LL) + *(_QWORD *)a2;
  result = *(unsigned __int64 (__fastcall **)())a1;
  if ( v11 == *(_QWORD *)a1 )
  {
    result = *(unsigned __int64 (__fastcall **)())a1;
    if ( v11 == *(_QWORD *)a1 )
    {
      *(_QWORD *)a1 = dl_tlsdesc_resolve_hold;
      v14 = *(unsigned int *)(v10 + 12);
      v15 = *(_QWORD *)(*(_QWORD *)(a2 + 104) + 8LL);
      v16 = (unsigned int *)(*(_QWORD *)(*(_QWORD *)(a2 + 112) + 8LL) + 24 * v14);
      v19 = v16;
      if ( !(*((_BYTE *)v16 + 4) >> 4) || (*((_BYTE *)v16 + 5) & 3) != 0 )
        goto LABEL_10;
      v17 = *(_QWORD *)(a2 + 464);
      if ( v17 )
      {
        v17 = *(_QWORD *)(a2 + 744) + 24LL * (*(_WORD *)(*(_QWORD *)(v17 + 8) + 2 * v14) & 0x7FFF);
        if ( !*(_DWORD *)(v17 + 8) )
          v17 = 0LL;
      }
      a2 = dl_lookup_symbol_x(
             (unsigned __int8 *)(*v16 + v15),
             a2,
             &v19,
             *(__int64 **)(a2 + 904),
             (const char **)v17,
             1,
             a3,
             a4,
             a5,
             a6,
             a7,
             a8,
             a9,
             a10,
             1,
             0LL);
      if ( v19 )
      {
LABEL_10:
        v18 = *(_QWORD *)(a2 + 1096);
        if ( (unsigned __int64)(v18 + 1) <= 1 )
        {
          dl_allocate_static_tls(a2);
          v18 = *(_QWORD *)(a2 + 1096);
        }
        *(_QWORD *)(a1 + 8) = *((_QWORD *)v19 + 1) + *(_QWORD *)(v10 + 16) - v18;
        result = (unsigned __int64 (__fastcall *)())dl_tlsdesc_return;
        *(_QWORD *)a1 = dl_tlsdesc_return;
      }
      else
      {
        *(_QWORD *)(a1 + 8) = *(_QWORD *)(v10 + 16);
        result = dl_tlsdesc_undefweak;
        *(_QWORD *)a1 = dl_tlsdesc_undefweak;
      }
    }
  }
  return result;
}
// 470AC0: using guessed type __int64 __fastcall dl_tlsdesc_return();

//----- (0000000000476520) ----------------------------------------------------
__int64 __fastcall dl_tlsdesc_resolve_hold_fixup(__int64 a1)
{
  return *(_QWORD *)a1;
}
// 47655F: control flows out of bounds to 0

//----- (0000000000476590) ----------------------------------------------------
unsigned __int64 __fastcall dl_unmap(__int64 a1)
{
  return munmap(*(_QWORD *)(a1 + 840), *(_QWORD *)(a1 + 848) - *(_QWORD *)(a1 + 840));
}

//----- (00000000004765B0) ----------------------------------------------------
char __fastcall dl_cet_open_check(__int64 a1)
{
  int v1; // er13
  unsigned int v2; // er14
  int v3; // er12
  unsigned int v4; // ebx
  int v5; // eax
  char v6; // cl
  _BOOL4 v7; // esi
  unsigned __int8 v8; // r10
  unsigned int v9; // er13
  unsigned __int64 v10; // rdx
  unsigned int v11; // eax
  __int64 v12; // rbp
  char v13; // cl
  signed __int64 v14; // rax
  char v15; // dl
  int v16; // er8
  unsigned __int8 v17; // r10
  signed __int64 v18; // rax
  unsigned __int64 v19; // r9
  __int64 v20; // r12
  __int64 v21; // r10
  _QWORD *v22; // rdi
  __int64 v23; // r8
  unsigned __int64 v24; // rcx
  unsigned __int64 v25; // rax
  char v26; // dl
  int v27; // ecx
  __int64 v28; // r13
  _QWORD *v29; // rsi
  unsigned __int64 v30; // rcx
  unsigned int v32; // [rsp+4h] [rbp-64h]
  size_t v33; // [rsp+8h] [rbp-60h]
  unsigned __int64 v34; // [rsp+10h] [rbp-58h]
  __int64 v35; // [rsp+18h] [rbp-50h]
  char v36; // [rsp+22h] [rbp-46h]
  unsigned __int8 v37; // [rsp+23h] [rbp-45h]
  int v38; // [rsp+24h] [rbp-44h]
  unsigned __int8 v39; // [rsp+2Fh] [rbp-39h]

  v3 = dword_4AB8B4 & 7;
  v4 = ((unsigned int)dword_4AB8B4 >> 3) & 7;
  LOBYTE(v5) = v4 == 2;
  v6 = v4 == 2 && v3 == 2;
  if ( v6 )
    return v5;
  LOBYTE(v5) = dl_x86_feature_1;
  if ( (dl_x86_feature_1 & 3) == 0 )
    return v5;
  v7 = (dl_x86_feature_1 & 2) != 0;
  v37 = dl_x86_feature_1 & 1;
  v36 = (dl_x86_feature_1 & 2) != 0;
  LOBYTE(v1) = v4 != 1;
  v10 = (unsigned __int8)dl_x86_feature_1 & 1u & (v3 != 1);
  v8 = dl_x86_feature_1 & 1 & (v3 != 1);
  v9 = v7 & v1;
  LOBYTE(v10) = v9 | v8;
  if ( !((unsigned __int8)v9 | v8) )
  {
    v13 = (dl_x86_feature_1 & 2) != 0;
    v12 = 0LL;
    goto LABEL_21;
  }
  v11 = *(_DWORD *)(a1 + 712);
  v12 = 0LL;
  while ( --v11 != -1 )
  {
    while ( 1 )
    {
      v10 = v11;
      v12 = *(_QWORD *)(*(_QWORD *)(a1 + 960) + 8LL * v11);
      if ( (*(_BYTE *)(v12 + 796) & 8) != 0 )
        break;
      LOBYTE(v10) = v8 & (v3 != 2);
      if ( (_BYTE)v10 )
      {
        if ( (*(_BYTE *)(v12 + 798) & 4) == 0 )
        {
          v2 = v11;
          if ( !v6 )
          {
            v32 = v11;
            v6 = v8 & (v3 != 2);
          }
        }
      }
      if ( v4 == 2 )
        break;
      --v11;
      v10 = *(_BYTE *)(v12 + 798) >> 3;
      v9 &= v10;
      if ( v11 == -1 )
        goto LABEL_13;
    }
  }
LABEL_13:
  if ( v6 )
  {
    if ( *(_QWORD *)&dl_x86_legacy_bitmap )
    {
      if ( (mprotect(*(unsigned __int64 *)&dl_x86_legacy_bitmap, qword_4AB948, 3uLL) & 0x80000000) != 0LL )
        goto LABEL_48;
    }
    else
    {
      v18 = sys_arch_prctl((struct task_struct *)0x3005, (int)&dl_x86_legacy_bitmap, (unsigned __int64 *)v10);
      if ( (_DWORD)v18 )
        dl_signal_error(22, *(void **)(v12 + 8), "dlopen", "legacy bitmap isn't available");
    }
    v34 = *(_QWORD *)&dl_x86_legacy_bitmap;
    v33 = qword_4AB948;
    if ( v2 <= v32 )
    {
      v19 = dl_pagesize;
      v39 = v9;
      v35 = dl_pagesize - 1;
      v38 = v3;
      v20 = *(_QWORD *)(a1 + 960);
      do
      {
        v12 = *(_QWORD *)(v20 + 8LL * v2);
        if ( (*(_BYTE *)(v12 + 796) & 8) == 0 && (*(_BYTE *)(v12 + 798) & 4) == 0 )
        {
          v21 = *(unsigned __int16 *)(v12 + 696);
          v22 = *(_QWORD **)(v12 + 680);
          if ( *(_WORD *)(v12 + 696) )
          {
            v23 = 0LL;
            do
            {
              while ( 1 )
              {
                if ( (*v22 & 0x1FFFFFFFFLL) == 0x100000001LL )
                {
                  v24 = (v22[2] + *(_QWORD *)v12) / v19;
                  v25 = (v22[5] + v35) / v19;
                  v26 = v24 + v25;
                  if ( v33 < (v24 + v25) >> 3 )
                    dl_signal_error(22, *(void **)(v12 + 8), "dlopen", "failed to mark legacy code region");
                  v27 = v24 & 0x3F;
                  v28 = -1LL << v27;
                  v29 = (_QWORD *)(v34 + 8 * (((v22[2] + *(_QWORD *)v12) / v19) >> 6));
                  v30 = (unsigned int)(64 - v27);
                  if ( v30 <= v25 )
                  {
                    do
                    {
                      v25 -= v30;
                      *v29 |= v28;
                      v30 = 64LL;
                      ++v29;
                      v28 = -1LL;
                    }
                    while ( v25 > 0x3F );
                  }
                  if ( v25 )
                    break;
                }
                ++v23;
                v22 += 7;
                if ( v21 == v23 )
                  goto LABEL_41;
              }
              ++v23;
              v22 += 7;
              *v29 |= (0xFFFFFFFFFFFFFFFFLL >> -v26) & v28;
            }
            while ( v21 != v23 );
          }
        }
LABEL_41:
        ++v2;
      }
      while ( v2 <= v32 );
      v3 = v38;
      v9 = v39;
    }
    if ( (mprotect(v34, v33, 1uLL) & 0x80000000) == 0LL )
    {
      v10 = v9;
      v13 = v9 ^ v36;
      goto LABEL_21;
    }
LABEL_48:
    dl_signal_error(22, *(void **)(v12 + 8), "dlopen", "mprotect legacy bitmap failed");
  }
  v10 = v9;
  v13 = v9 ^ v7;
LABEL_21:
  LOBYTE(v5) = v3 == 1;
  if ( ((v3 == 1) & v37) != 0 || v13 )
  {
    if ( v4 == 3 )
    {
      v14 = sys_arch_prctl((struct task_struct *)0x3002, 2 * (unsigned int)((_BYTE)v10 == 0), (unsigned __int64 *)v10);
      if ( (_DWORD)v14 )
        dl_signal_error(-(int)v14, *(void **)(v12 + 8), "dlopen", "can't disable CET");
      v5 = v17;
      dl_x86_feature_1 &= ~v16;
      if ( v15 )
        v5 = v17 | 2;
      __writefsdword(0x48u, v5);
    }
    else if ( v36 != (_BYTE)v10 )
    {
      dl_signal_error(22, *(void **)(v12 + 8), "dlopen", "shadow stack isn't enabled");
    }
  }
  return v5;
}
// 476626: variable 'v1' is possibly undefined
// 4766D3: variable 'v17' is possibly undefined
// 4766D7: variable 'v16' is possibly undefined
// 4766E8: variable 'v15' is possibly undefined
// 476798: variable 'v2' is possibly undefined
// 476798: variable 'v32' is possibly undefined
// 4A91F8: using guessed type __int64 dl_pagesize;
// 4AB8B0: using guessed type int dl_x86_feature_1;
// 4AB8B4: using guessed type int dword_4AB8B4;
// 4AB948: using guessed type __int64 qword_4AB948;

//----- (00000000004769F0) ----------------------------------------------------
__int64 __fastcall dl_addr(unsigned __int64 a1, _QWORD *a2, _QWORD *a3, _QWORD *a4)
{
  unsigned int v8; // er14
  _QWORD *dso_for_object; // rax
  _BYTE *v10; // rdx
  __int64 v11; // rcx
  unsigned int *v12; // r11
  unsigned int *v13; // r9
  int v14; // ecx
  unsigned int *v15; // rdx
  unsigned int *v16; // r10
  __int64 v17; // r15
  unsigned int v18; // edx
  __int64 v19; // rcx
  __int64 v20; // rsi
  unsigned __int64 v21; // r14
  unsigned __int64 v22; // r8
  __int64 v23; // rdi
  unsigned int *v24; // rcx
  __int16 v25; // di
  bool v26; // zf
  __int64 v27; // rax
  __int64 v29; // rdx
  unsigned int *v30; // rsi
  __int16 v31; // dx
  unsigned __int64 v32; // rdx
  unsigned __int64 v33; // rcx
  __int64 v34; // rdi
  __int64 v35; // [rsp+0h] [rbp-48h]
  unsigned int v36; // [rsp+Ch] [rbp-3Ch]

  v8 = 0;
  dso_for_object = dl_find_dso_for_object(a1);
  if ( !dso_for_object )
    return v8;
  v10 = (_BYTE *)dso_for_object[1];
  v11 = dso_for_object[105];
  *a2 = v10;
  a2[1] = v11;
  if ( !*v10 && (*((_BYTE *)dso_for_object + 796) & 3) == 0 )
    *a2 = program_invocation_short_name[0];
  v12 = (unsigned int *)dso_for_object[84];
  v13 = *(unsigned int **)(dso_for_object[14] + 8LL);
  v35 = *(_QWORD *)(dso_for_object[13] + 8LL);
  v36 = *(_DWORD *)(dso_for_object[18] + 8LL);
  if ( v12 )
  {
    v14 = *((_DWORD *)dso_for_object + 189);
    if ( v14 )
    {
      v15 = (unsigned int *)dso_for_object[97];
      v12 = 0LL;
      v16 = v15 + 1;
      v17 = (__int64)&v15[v14 - 1 + 1];
      while ( 1 )
      {
        v18 = *v15;
        if ( v18 )
          break;
LABEL_6:
        v15 = v16;
        if ( (unsigned int *)v17 == v16 )
          goto LABEL_22;
        ++v16;
      }
      v19 = v18;
      v20 = dso_for_object[98] + 4LL * v18;
      while ( 1 )
      {
        v24 = &v13[6 * v19];
        v25 = *((_WORD *)v24 + 3);
        if ( v25 )
        {
          if ( v25 == -15 )
            goto LABEL_16;
        }
        else if ( !*((_QWORD *)v24 + 1) )
        {
          goto LABEL_16;
        }
        if ( (v24[1] & 0xF) != 6 )
        {
          v21 = *((_QWORD *)v24 + 1);
          v22 = v21 + *dso_for_object;
          if ( a1 >= v22 )
            break;
        }
LABEL_16:
        v20 += 4LL;
        ++v18;
        if ( (*(_BYTE *)(v20 - 4) & 1) != 0 )
          goto LABEL_6;
        v19 = v18;
      }
      if ( v25 )
      {
        v23 = *((_QWORD *)v24 + 2);
        if ( !v23 )
        {
          if ( a1 != v22 )
            goto LABEL_16;
          goto LABEL_53;
        }
      }
      else
      {
        if ( a1 == v22 )
        {
LABEL_53:
          if ( (!v12 || v21 > *((_QWORD *)v12 + 1)) && v36 > *v24 )
            v12 = v24;
          goto LABEL_16;
        }
        v23 = *((_QWORD *)v24 + 2);
      }
      if ( a1 >= v23 + v22 )
        goto LABEL_16;
      goto LABEL_53;
    }
    v12 = 0LL;
    goto LABEL_22;
  }
  v29 = dso_for_object[12];
  v30 = *(unsigned int **)(dso_for_object[13] + 8LL);
  if ( v29 )
    v30 = &v13[6 * *(unsigned int *)(*(_QWORD *)(v29 + 8) + 4LL)];
  if ( v13 < v30 )
  {
    while ( 1 )
    {
      if ( (unsigned __int8)((*((_BYTE *)v13 + 4) >> 4) - 1) > 1u
        || (*((_BYTE *)v13 + 5) & 3u) - 1 <= 1
        || (v13[1] & 0xF) == 6 )
      {
        goto LABEL_47;
      }
      v31 = *((_WORD *)v13 + 3);
      if ( !v31 )
        break;
      if ( v31 == -15 )
        goto LABEL_47;
      v32 = *((_QWORD *)v13 + 1);
      v33 = v32 + *dso_for_object;
      if ( a1 < v33 )
        goto LABEL_47;
      v34 = *((_QWORD *)v13 + 2);
      if ( v34 )
        goto LABEL_42;
      if ( a1 == v33 )
      {
LABEL_43:
        if ( (!v12 || *((_QWORD *)v12 + 1) < v32) && v36 > *v13 )
          v12 = v13;
      }
LABEL_47:
      v13 += 6;
      if ( v13 >= v30 )
        goto LABEL_22;
    }
    v32 = *((_QWORD *)v13 + 1);
    if ( !v32 )
      goto LABEL_47;
    v33 = v32 + *dso_for_object;
    if ( a1 < v33 )
      goto LABEL_47;
    if ( a1 == v33 )
      goto LABEL_43;
    v34 = *((_QWORD *)v13 + 2);
LABEL_42:
    if ( a1 < v34 + v33 )
      goto LABEL_43;
    goto LABEL_47;
  }
LABEL_22:
  if ( a3 )
    *a3 = dso_for_object;
  if ( a4 )
    *a4 = v12;
  if ( v12 )
  {
    v26 = *((_WORD *)v12 + 3) == 0xFFF1;
    a2[2] = v35 + *v12;
    if ( v26 )
      v27 = 0LL;
    else
      v27 = *dso_for_object;
    v8 = 1;
    a2[3] = *((_QWORD *)v12 + 1) + v27;
  }
  else
  {
    a2[2] = 0LL;
    v8 = 1;
    a2[3] = 0LL;
  }
  return v8;
}
// 4A9168: using guessed type char (*program_invocation_short_name[2])[1707];

//----- (0000000000476D30) ----------------------------------------------------
__int64 __fastcall dl_addr_inside_object(__int64 a1, __int64 a2)
{
  __int64 v2; // rsi
  __int64 i; // rax
  __int64 v4; // rdx

  v2 = a2 - *(_QWORD *)a1;
  for ( i = 56LL * *(unsigned __int16 *)(a1 + 696) - 56; i != -56; i -= 56LL )
  {
    v4 = i + *(_QWORD *)(a1 + 680);
    if ( *(_DWORD *)v4 == 1 && (unsigned __int64)(v2 - *(_QWORD *)(v4 + 16)) < *(_QWORD *)(v4 + 40) )
      return 1LL;
  }
  return 0LL;
}

//----- (0000000000476D90) ----------------------------------------------------
__int64 __fastcall _mpn_add_n(__int64 a1, __int64 *a2, __int64 *a3, __int64 a4)
{
  __int64 v4; // r10
  __int64 v5; // r11
  __int64 *v6; // rsi
  __int64 *v7; // rdx
  __int64 v8; // rdi
  char v9; // al
  __int64 v10; // rcx
  int v11; // eax
  __int64 v12; // rcx
  bool v13; // cf
  char v14; // cf
  __int64 v15; // r8
  __int64 v16; // r9
  char v17; // cf
  char v18; // cf
  __int64 v19; // r8
  __int64 v20; // r9
  __int64 v21; // r10
  __int64 v22; // rtt
  __int64 v24; // r10
  __int64 v25; // rtt
  __int64 v26; // r8
  __int64 v27; // rtt
  __int64 v28; // r10
  _BOOL8 v29; // rtt
  __int64 v30; // r8
  __int64 v31; // rtt

  v4 = *a2;
  v5 = *a3;
  v6 = &a2[a4 - 1];
  v7 = &a3[a4 - 1];
  v8 = a1 + 8 * a4 - 16;
  v9 = a4;
  v10 = -a4;
  v11 = v9 & 3;
  if ( !v11 )
  {
    v14 = 0;
    v15 = v4;
    v16 = v5;
    v12 = v10 + 4;
    goto LABEL_9;
  }
  v12 = (unsigned int)v11 + v10;
  if ( v11 < 2 )
  {
    v17 = 0;
    goto LABEL_12;
  }
  if ( v11 == 2 )
  {
    v18 = 0;
    v19 = v4;
    v20 = v5;
    goto LABEL_11;
  }
  v13 = 0;
  while ( 1 )
  {
    v19 = v6[v12 - 1];
    v20 = v7[v12 - 1];
    v29 = v13;
    v13 = __CFADD__(v13, v4);
    v28 = v29 + v4;
    v18 = v13 | __CFADD__(v5, v28);
    *(_QWORD *)(v8 + 8 * v12 - 8) = v5 + v28;
LABEL_11:
    v4 = v6[v12];
    v5 = v7[v12];
    v31 = v18;
    v13 = __CFADD__(v18, v19);
    v30 = v31 + v19;
    v17 = v13 | __CFADD__(v20, v30);
    *(_QWORD *)(v8 + 8 * v12) = v20 + v30;
LABEL_12:
    if ( !v12 )
      break;
    v12 += 4LL;
    v15 = v6[v12 - 3];
    v16 = v7[v12 - 3];
    v25 = v17;
    v13 = __CFADD__(v17, v4);
    v24 = v25 + v4;
    v14 = v13 | __CFADD__(v5, v24);
    *(_QWORD *)(v8 + 8 * v12 - 24) = v5 + v24;
LABEL_9:
    v4 = v6[v12 - 2];
    v5 = v7[v12 - 2];
    v27 = v14;
    v13 = __CFADD__(v14, v15);
    v26 = v27 + v15;
    v13 |= __CFADD__(v16, v26);
    *(_QWORD *)(v8 + 8 * v12 - 16) = v16 + v26;
  }
  v22 = v17;
  v13 = __CFADD__(v17, v4);
  v21 = v22 + v4;
  *(_QWORD *)(v8 + 8) = v5 + v21;
  return v13 | (unsigned __int8)__CFADD__(v5, v21);
}

//----- (0000000000476E40) ----------------------------------------------------
unsigned __int64 __fastcall _mpn_addmul_1(__int64 *a1, unsigned __int64 *a2, __int64 a3, unsigned __int64 a4)
{
  __int64 v4; // rbx
  unsigned __int64 v5; // rax
  __int64 v6; // r10
  __int64 *v7; // rdi
  unsigned __int64 *v8; // rsi
  unsigned __int128 v9; // rax
  __int64 v10; // rbp
  __int64 v11; // r11
  unsigned __int128 v12; // rax
  __int64 v13; // rbx
  __int64 v14; // r8
  unsigned __int64 v15; // rax
  __int64 v16; // r9
  __int64 v17; // r8
  __int64 v18; // r9
  unsigned __int64 v19; // r11
  unsigned __int64 v20; // rax
  __int64 v21; // rbp
  unsigned __int128 v22; // rax
  bool v23; // cf
  __int64 v24; // r10
  unsigned __int64 v25; // r11
  _BOOL8 v26; // rtt
  unsigned __int128 v27; // rax
  __int64 v28; // r10
  __int64 v29; // r8
  _BOOL8 v30; // rtt
  unsigned __int64 v31; // r11
  __int64 v32; // r10

  v4 = -a3;
  v5 = *a2;
  v6 = *a1;
  v7 = &a1[a3 - 2];
  v8 = &a2[a3];
  v9 = a4 * (unsigned __int128)v5;
  if ( (v4 & 1) != 0 )
  {
    v13 = v4 + 1;
    if ( v13 < 0 )
    {
      v18 = *((_QWORD *)&v9 + 1);
      v17 = v9;
      v19 = a4 * v8[v13];
      v20 = v8[v13 + 1];
      v21 = (a4 * (unsigned __int128)v8[v13]) >> 64;
      goto LABEL_8;
    }
  }
  else
  {
    v10 = *((_QWORD *)&v9 + 1);
    v11 = v9;
    v12 = a4 * (unsigned __int128)v8[v4 + 1];
    v13 = v4 + 2;
    if ( v13 < 0 )
    {
      v14 = v12;
      *(_QWORD *)&v12 = v8[v13];
      v16 = *((_QWORD *)&v12 + 1);
      while ( 1 )
      {
        v27 = a4 * (unsigned __int128)v15;
        v23 = __CFADD__(v11, v6);
        v28 = v11 + v6;
        v19 = v27;
        v20 = v8[v13 + 1];
        v30 = v23;
        v23 = __CFADD__(v23, v14);
        v29 = v30 + v14;
        v23 |= __CFADD__(v10, v29);
        v17 = v10 + v29;
        v7[v13] = v28;
        v6 = v7[v13 + 1];
        v21 = *((_QWORD *)&v27 + 1);
        v18 = v23 + v16;
LABEL_8:
        v13 += 2LL;
        if ( v13 >= 0 )
          break;
        v22 = a4 * (unsigned __int128)v20;
        v23 = __CFADD__(v17, v6);
        v24 = v17 + v6;
        v14 = v22;
        v15 = v8[v13];
        v26 = v23;
        v23 = __CFADD__(v23, v19);
        v25 = v26 + v19;
        v23 |= __CFADD__(v18, v25);
        v11 = v18 + v25;
        v7[v13 - 1] = v24;
        v6 = v7[v13];
        v16 = *((_QWORD *)&v22 + 1);
        v10 = v23 + v21;
      }
      v12 = a4 * (unsigned __int128)v20;
      v23 = __CFADD__(__CFADD__(v17, v6), v19);
      v31 = __CFADD__(v17, v6) + v19;
      v23 |= __CFADD__(v18, v31);
      v11 = v18 + v31;
      *(v7 - 1) = v17 + v6;
      v10 = v23 + v21;
    }
    v23 = __CFADD__(__CFADD__(v11, *v7), (_QWORD)v12);
    *(_QWORD *)&v12 = __CFADD__(v11, *v7) + (_QWORD)v12;
    v23 |= __CFADD__(v10, (_QWORD)v12);
    *(_QWORD *)&v9 = v10 + v12;
    *v7 += v11;
    *((_QWORD *)&v9 + 1) = v23 + *((_QWORD *)&v12 + 1);
  }
  v32 = v7[1];
  v7[1] = v9 + v32;
  return *((_QWORD *)&v9 + 1) + __CFADD__((_QWORD)v9, v32) + (unsigned __int64)(unsigned int)v13;
}

//----- (0000000000476F30) ----------------------------------------------------
__int64 __fastcall dlopen_doit(__int64 a1)
{
  int v1; // esi
  __int64 v2; // rdx
  unsigned __int8 *v4; // rdi
  int v5; // esi
  unsigned __int8 *v7; // rax
  __int64 v8; // [rsp-10h] [rbp-18h]

  v1 = *(_DWORD *)(a1 + 8);
  if ( (v1 & 0xBFFFEEF0) != 0 )
  {
    v7 = dcgettext("libc", "invalid mode parameter", 5u);
    dl_signal_error(0, 0LL, 0LL, (const char *)v7);
  }
  v2 = *(_QWORD *)(a1 + 24);
  v4 = *(unsigned __int8 **)a1;
  v5 = v1 | 0x80000000;
  if ( !v4 )
    v4 = byte_493255;
  *(_QWORD *)(a1 + 16) = dl_open(v4, v5, v2, 0LL, (unsigned int)_libc_argc, _libc_argv, (__int64)environ);
  return v8;
}
// 476F81: variable 'v8' is possibly undefined
// 493255: using guessed type unsigned __int8 byte_493255[1707];
// 4AB958: using guessed type int _libc_argc;
// 4AB960: using guessed type __int64 _libc_argv;

//----- (0000000000476FB0) ----------------------------------------------------
__int64 __fastcall _dlopen(__int64 a1, int a2, __int64 a3, __int64 a4, u32 *a5, unsigned __int64 a6)
{
  _BOOL4 v6; // eax
  __int64 v7; // rcx
  __int64 v8; // r8
  __int64 v9; // r9
  __int64 v10; // rdx
  __int64 v11; // rdx
  __int64 v12; // rcx
  __int64 v13; // r8
  __int64 v14; // r9
  __int64 v16; // [rsp+0h] [rbp-38h] BYREF
  int v17; // [rsp+8h] [rbp-30h]
  __int64 v18; // [rsp+10h] [rbp-28h]
  __int64 v19; // [rsp+18h] [rbp-20h]
  unsigned __int64 v20; // [rsp+28h] [rbp-10h]

  v20 = __readfsqword(0x28u);
  v16 = a1;
  v17 = a2;
  v19 = a3;
  v6 = dlerror_run((void (__fastcall *)(__int64))dlopen_doit, (__int64)&v16, a3, a4, a5, a6);
  v10 = 0LL;
  if ( !v6 )
  {
    _libc_register_dl_open_hook(v18, (__int64)&v16, 0LL, v7, v8, v9);
    _libc_register_dlfcn_hook(v18, (__int64)&v16, v11, v12, v13, v14);
    return v18;
  }
  return v10;
}
// 476FEF: variable 'v7' is possibly undefined
// 476FEF: variable 'v8' is possibly undefined
// 476FEF: variable 'v9' is possibly undefined
// 476FF9: variable 'v11' is possibly undefined
// 476FF9: variable 'v12' is possibly undefined
// 476FF9: variable 'v13' is possibly undefined
// 476FF9: variable 'v14' is possibly undefined

//----- (0000000000477020) ----------------------------------------------------
void __fastcall dlclose_doit(__int64 a1)
{
  dl_close(a1);
}

//----- (0000000000477030) ----------------------------------------------------
_BOOL8 __fastcall _dlclose(__int64 a1, __int64 a2, __int64 a3, __int64 a4, u32 *a5, unsigned __int64 a6)
{
  return -dlerror_run(dlclose_doit, a1, a3, a4, a5, a6);
}

//----- (0000000000477060) ----------------------------------------------------
__int64 (*__fastcall dlsym_doit(
        __int64 a1,
        double a2,
        double a3,
        double a4,
        double a5,
        double a6,
        double a7,
        double a8,
        double a9))(void)
{
  __int64 (*result)(void); // rax

  result = dl_sym(*(_QWORD *)a1, *(unsigned __int8 **)(a1 + 8), *(_QWORD *)(a1 + 16), a2, a3, a4, a5, a6, a7, a8, a9);
  *(_QWORD *)(a1 + 24) = result;
  return result;
}

//----- (0000000000477080) ----------------------------------------------------
__int64 __fastcall _dlsym(__int64 a1, __int64 a2, __int64 a3, __int64 a4, u32 *a5, unsigned __int64 a6)
{
  __int64 v6; // rbx
  __int64 v8[7]; // [rsp+0h] [rbp-38h] BYREF

  v8[5] = __readfsqword(0x28u);
  v8[2] = a3;
  v8[0] = a1;
  v8[1] = a2;
  v6 = 0LL;
  if ( !dlerror_run((void (__fastcall *)(__int64))dlsym_doit, (__int64)v8, a3, a4, a5, a6) )
    return v8[3];
  return v6;
}

//----- (0000000000477110) ----------------------------------------------------
__int64 (*__fastcall dlvsym_doit(
        __int64 a1,
        double a2,
        double a3,
        double a4,
        double a5,
        double a6,
        double a7,
        double a8,
        double a9))(void)
{
  __int64 (*result)(void); // rax

  result = dl_vsym(
             *(_QWORD *)a1,
             *(unsigned __int8 **)(a1 + 8),
             *(unsigned __int8 **)(a1 + 16),
             *(_QWORD *)(a1 + 24),
             a2,
             a3,
             a4,
             a5,
             a6,
             a7,
             a8,
             a9);
  *(_QWORD *)(a1 + 32) = result;
  return result;
}

//----- (0000000000477140) ----------------------------------------------------
__int64 __fastcall _dlvsym(__int64 a1, __int64 a2, __int64 a3, __int64 a4, u32 *a5, unsigned __int64 a6)
{
  __int64 v6; // rbx
  __int64 v8[7]; // [rsp+0h] [rbp-38h] BYREF

  v8[5] = __readfsqword(0x28u);
  v8[0] = a1;
  v8[1] = a2;
  v8[3] = a4;
  v8[2] = a3;
  v6 = 0LL;
  if ( !dlerror_run((void (__fastcall *)(__int64))dlvsym_doit, (__int64)v8, a3, a4, a5, a6) )
    return v8[4];
  return v6;
}

//----- (00000000004771D0) ----------------------------------------------------
unsigned __int64 __fastcall setitimer(int a1, struct itimerval *a2, struct itimerval *a3)
{
  unsigned __int64 result; // rax

  result = sys_setitimer(a1, a2, a3);
  if ( result >= 0xFFFFFFFFFFFFF001LL )
  {
    __writefsdword(0xFFFFFFC0, -(int)result);
    return -1LL;
  }
  return result;
}

//----- (0000000000477200) ----------------------------------------------------
__int64 __fastcall dl_build_local_scope(_QWORD *a1, __int64 a2)
{
  __int64 result; // rax
  __int64 v3; // rdx
  _QWORD *v4; // rbp
  __int64 v5; // rsi
  __int64 *v6; // rbx

  *a1 = a2;
  result = 1LL;
  *(_BYTE *)(a2 + 796) = *(_BYTE *)(a2 + 796) & 0x9F | 0x20;
  v3 = *(_QWORD *)(a2 + 960);
  if ( v3 )
  {
    v4 = a1 + 1;
    v5 = *(_QWORD *)(v3 + 8);
    v6 = (__int64 *)(v3 + 8);
    if ( v5 )
    {
      do
      {
        if ( (*(_BYTE *)(v5 + 796) & 0x60) == 0 )
          v4 += dl_build_local_scope(v4, v5);
        v5 = *++v6;
      }
      while ( *v6 );
      return v4 - a1;
    }
  }
  return result;
}

//----- (0000000000477290) ----------------------------------------------------
u32 *__fastcall openaux(__int64 a1)
{
  __int64 v2; // rdi
  char v3; // dl
  u32 *result; // rax

  v2 = *(_QWORD *)a1;
  v3 = *(_BYTE *)(v2 + 796) & 3;
  if ( !v3 )
    v3 = 1;
  result = dl_map_object(v2, *(char **)(a1 + 24), v3, *(_DWORD *)(a1 + 8), *(_DWORD *)(a1 + 12), *(_QWORD *)(v2 + 48));
  *(_QWORD *)(a1 + 32) = result;
  return result;
}

//----- (00000000004772D0) ----------------------------------------------------
__int64 *__fastcall dl_map_object_deps(__int64 a1, __int64 *a2, __int64 a3, int a4, __int64 a5, unsigned __int64 a6)
{
  unsigned __int64 v6; // rax
  int *v7; // rcx
  unsigned int v8; // eax
  char v9; // al
  __int64 v10; // rcx
  __int64 v11; // rdi
  __int64 v12; // r13
  unsigned int v13; // er15
  __int64 v14; // rbx
  _QWORD *v15; // rax
  __int64 v16; // rdx
  __int64 v17; // rcx
  u32 *v18; // r8
  unsigned __int64 v19; // r9
  _QWORD *v20; // r12
  __int64 v21; // rbx
  __m128i *v22; // rax
  __int64 v23; // r15
  int v24; // er12
  __int64 v25; // rax
  __int64 *v26; // rbx
  __int64 v27; // rax
  char *v28; // r14
  __int64 v29; // rcx
  __int64 v30; // r12
  __int64 v31; // rax
  __int64 v32; // rdi
  __int64 v33; // rcx
  unsigned __int64 v34; // rax
  unsigned __int64 v35; // rdx
  __int64 v36; // rdx
  char *v37; // rsi
  __int16 v38; // dx
  unsigned int v39; // edx
  void *v40; // rsp
  char *v41; // rax
  int v42; // eax
  __int64 v43; // rax
  char v44; // cl
  char *v45; // r12
  __int64 v46; // rcx
  __int64 v47; // r14
  __int64 v48; // rax
  __int64 v49; // rdi
  __int64 v50; // rcx
  unsigned __int64 v51; // rax
  unsigned __int64 v52; // rdx
  __int64 v53; // rdx
  char *v54; // rdi
  __int16 v55; // dx
  unsigned int v56; // edx
  char *v57; // rax
  __int64 v58; // rax
  unsigned __int64 v59; // rdx
  int v60; // ebx
  __int64 v61; // rsi
  int v62; // ecx
  _QWORD *v63; // r14
  __int64 v64; // rax
  unsigned int v65; // ebx
  __int64 v66; // rax
  __m128i *v67; // r8
  u32 v68; // edi
  __int64 v69; // r9
  __int64 v70; // rcx
  unsigned int v71; // er13
  _DWORD *v72; // rcx
  unsigned int *v73; // rbx
  u32 *v74; // r12
  unsigned int v75; // er15
  __m128i *v76; // rax
  unsigned int v77; // er11
  __int64 v78; // rax
  char *v79; // rdi
  __int64 v80; // rax
  __int64 v81; // rdx
  _QWORD *v82; // rsi
  __int64 v83; // r14
  __int64 v84; // rsi
  _QWORD *v85; // rdx
  u32 *v86; // r8
  unsigned __int64 v87; // r9
  __int64 v88; // rcx
  __int64 v89; // rdi
  __int64 *result; // rax
  unsigned __int16 v91; // ax
  __int64 *v92; // rdi
  const __m128i *v93; // roff
  __int64 v94; // rax
  __int64 v95; // rdx
  __int64 v96; // rcx
  __int64 v97; // rdx
  __int64 v98; // rcx
  void *v99; // rsp
  __int64 origin; // rax
  _QWORD *v101; // r15
  _QWORD *v102; // r14
  __int64 v103; // r13
  __int64 v104; // r12
  __int64 v105; // rax
  __int64 v106; // rsi
  unsigned int v107; // eax
  __int64 v108; // rcx
  u32 *v109; // r8
  __int64 v110; // r9
  unsigned int v111; // ebx
  __int64 v112; // rdx
  _QWORD *v113; // rax
  _QWORD *v114; // rax
  __int64 *v115; // rdx
  __m128i *i; // rcx
  const __m128i *v117; // rcx
  __int64 v118; // rdi
  __m128i *v119; // rdx
  bool v120; // zf
  __int64 v121; // rdx
  void *v122; // rsp
  const char *v123; // rdx
  __m128i v124; // [rsp-Eh] [rbp-5540h] BYREF
  __int64 v125; // [rsp+2h] [rbp-5530h]
  char v127[15]; // [rsp+1012h] [rbp-4520h] BYREF
  int v128; // [rsp+2012h] [rbp-3520h] BYREF
  __int64 v129; // [rsp+201Ah] [rbp-3518h]
  __int64 v130; // [rsp+2022h] [rbp-3510h]
  char v132[4096]; // [rsp+3032h] [rbp-2500h] BYREF
  int v133; // [rsp+4032h] [rbp-1500h] BYREF
  __int64 v134; // [rsp+403Ah] [rbp-14F8h]
  _BYTE *v135; // [rsp+4042h] [rbp-14F0h]
  _BYTE v136[4064]; // [rsp+404Ah] [rbp-14E8h] BYREF
  int *v137; // [rsp+5032h] [rbp-500h] BYREF
  __int64 *v138; // [rsp+503Ah] [rbp-4F8h]
  __m128i *v139; // [rsp+5042h] [rbp-4F0h]
  unsigned int v140; // [rsp+504Ah] [rbp-4E8h]
  int v141; // [rsp+504Eh] [rbp-4E4h]
  int v142; // [rsp+5052h] [rbp-4E0h]
  int v143; // [rsp+5056h] [rbp-4DCh]
  __m128i *v144; // [rsp+505Ah] [rbp-4D8h]
  __m128i v145; // [rsp+5062h] [rbp-4D0h]
  __m128i *v146; // [rsp+5072h] [rbp-4C0h]
  __int64 v147; // [rsp+507Ah] [rbp-4B8h]
  __int64 *v148; // [rsp+5082h] [rbp-4B0h]
  _QWORD *v149; // [rsp+508Ah] [rbp-4A8h]
  __int64 *v150; // [rsp+5092h] [rbp-4A0h]
  __int64 v151; // [rsp+509Ah] [rbp-498h]
  __m128i v152[2]; // [rsp+50A2h] [rbp-490h] BYREF
  __int64 v153; // [rsp+50C2h] [rbp-470h] BYREF
  int v154; // [rsp+50CAh] [rbp-468h]
  int v155; // [rsp+50CEh] [rbp-464h]
  __int64 v156; // [rsp+50D2h] [rbp-460h]
  char *v157; // [rsp+50DAh] [rbp-458h]
  __int64 v158; // [rsp+50E2h] [rbp-450h]
  __int64 v159[2]; // [rsp+50F2h] [rbp-440h] BYREF
  __int64 v160; // [rsp+5102h] [rbp-430h] BYREF

  v6 = 16 * ((24 * (unsigned __int64)(unsigned int)(a3 + 2) + 23) >> 4);
  v142 = a4;
  v147 = a1;
  v141 = a5;
  v7 = (int *)((char *)&v137 - (v6 & 0xFFFFFFFFFFFFF000LL));
  if ( &v137 != (int **)v7 )
  {
    while ( &v133 != v7 )
      ;
  }
  v8 = v6 & 0xFFF;
  if ( v8 )
  {
    v99 = alloca(v8);
    *(_QWORD *)&v132[v8 + 4088] = *(_QWORD *)&v132[v8 + 4088];
  }
  v9 = *(_BYTE *)(v147 + 796);
  v10 = (__int64)v136;
  v133 = 0;
  v134 = v147;
  LOBYTE(v151) = v9;
  v135 = v136;
  *(_BYTE *)(v147 + 796) = v9 & 0x9F | 0x20;
  if ( (_DWORD)a3 )
  {
    a5 = 1LL;
    v143 = a3 + 1;
    while ( 1 )
    {
      v11 = *a2;
      v10 += 24LL;
      ++a2;
      a6 = (unsigned int)(a5 + 1);
      *(_DWORD *)(v10 - 24) = 0;
      *(_QWORD *)(v10 - 16) = v11;
      *(_QWORD *)(v10 - 8) = &v133 + 6 * a6;
      *(_BYTE *)(v11 + 796) = *(_BYTE *)(v11 + 796) & 0x9F | 0x20;
      if ( (_DWORD)a3 == (_DWORD)a5 )
        break;
      a5 = (unsigned int)a6;
    }
    v12 = v134;
    v146 = (__m128i *)(&v133 + 6 * (unsigned int)(a3 - 1) + 6);
  }
  else
  {
    v12 = v147;
    v146 = (__m128i *)&v133;
    v143 = 1;
  }
  v159[1] = 1024LL;
  v146[1].m128i_i64[0] = 0LL;
  v138 = v159;
  v159[0] = (__int64)&v160;
  v140 = __readfsdword(0xFFFFFFC0);
  __writefsdword(0xFFFFFFC0, 0);
  v148 = &v153;
  v144 = (__m128i *)&v133;
  v149 = (_QWORD *)v152;
  v137 = &v133;
  while ( 1 )
  {
    v144->m128i_i32[0] = 1;
    v150 = *(__int64 **)(v12 + 704);
    if ( v150 )
    {
      v150 = 0LL;
    }
    else if ( !*(_QWORD *)(v12 + 960) && v147 != v12 )
    {
      v91 = *(_WORD *)(v12 + 698);
      if ( v91 )
      {
        a2 = (__int64 *)v91;
        if ( !(unsigned __int8)_libc_scratch_buffer_set_array_size(v138, v91, 8LL, v10, (u32 *)a5, a6) )
          dl_signal_error(12, *(void **)(v147 + 8), 0LL, "cannot allocate dependency buffer");
        v150 = (__int64 *)v159[0];
      }
    }
    if ( *(_QWORD *)(v12 + 72) )
      break;
    if ( *(_QWORD *)(v12 + 488) )
      break;
    v13 = 0;
    if ( *(_QWORD *)(v12 + 472) )
      break;
LABEL_16:
    v10 = (__int64)v150;
    if ( v150 )
    {
      v14 = v13 + 1;
      v150[v13] = 0LL;
      v15 = malloc(8LL * (unsigned int)(2 * v14 + 1), (__int64)a2, (_QWORD *)a3, v10, (u32 *)a5, a6);
      v20 = v15;
      if ( !v15 )
      {
        if ( (__int64 *)v159[0] != v138 + 2 )
          free(v159[0], (__int64)a2, v16, v17, v18, v19);
        dl_signal_error(12, *(void **)(v147 + 8), 0LL, "cannot allocate dependency list");
      }
      *v15 = v12;
      v21 = 8 * v14;
      j_memcpy(v15 + 1, v150, v21);
      j_memcpy(&v20[v13 + 2], v20, v21);
      *(_BYTE *)(v12 + 798) |= 1u;
      *(_QWORD *)(v12 + 960) = v20;
    }
    v22 = v144;
    a2 = (__int64 *)v144->m128i_u32[0];
    if ( (_DWORD)a2 )
    {
      do
      {
        v22 = (__m128i *)v22[1].m128i_i64[0];
        if ( !v22 )
        {
          v23 = (__int64)v137;
          v24 = 0;
          goto LABEL_74;
        }
        v10 = v22->m128i_u32[0];
      }
      while ( (_DWORD)v10 );
      v144 = v22;
    }
    v12 = v144->m128i_i64[1];
  }
  v25 = *(_QWORD *)(v12 + 104);
  v26 = *(__int64 **)(v12 + 16);
  v153 = v12;
  v151 = *(_QWORD *)(v25 + 8);
  v156 = v151;
  v154 = v142;
  v155 = v141;
  v27 = *v26;
  if ( !*v26 )
  {
    v13 = 0;
    goto LABEL_16;
  }
  v13 = 0;
  v139 = v144;
  while ( v27 != 1 )
  {
    if ( (v27 & 0xFFFFFFFFFFFFFFFDLL) != 2147483645 )
      goto LABEL_45;
    v45 = (char *)(v26[1] + v151);
    v47 = dl_dst_count((__int64)v45);
    if ( !v47 )
      goto LABEL_122;
    if ( _libc_enable_secure )
      dl_signal_error(0, v45, 0LL, "DST not allowed in SUID/SGID programs");
    v48 = j_strlen_ifunc(v45);
    v49 = *(_QWORD *)(v12 + 832);
    v50 = v48;
    if ( v49 )
    {
      if ( v49 == -1 )
        goto LABEL_141;
      v145.m128i_i64[0] = v48;
      v51 = j_strlen_ifunc(v49);
      v50 = v145.m128i_i64[0];
    }
    else
    {
      if ( **(_BYTE **)(v12 + 8) )
        _assert_fail(
          (__int64)"(l)->l_name[0] == '\\0' || IS_RTLD (l)",
          (__int64)"dl-deps.c",
          0x120u,
          "_dl_map_object_deps");
      v145.m128i_i64[0] = v48;
      origin = dl_get_origin();
      v50 = v145.m128i_i64[0];
      *(_QWORD *)(v12 + 832) = origin;
      if ( (unsigned __int64)(origin - 1) > 0xFFFFFFFFFFFFFFFDLL )
      {
LABEL_141:
        v51 = 0LL;
        goto LABEL_53;
      }
      v145.m128i_i64[0] = v50;
      v51 = j_strlen_ifunc(origin);
      v50 = v145.m128i_i64[0];
    }
LABEL_53:
    v52 = 5LL;
    if ( (unsigned __int64)dl_platformlen >= 5 )
      v52 = dl_platformlen;
    if ( v52 >= v51 )
      v51 = v52;
    v53 = v50 + v47 * (v51 - 4) + 23;
    v54 = (char *)&v128 - (v53 & 0xFFFFFFFFFFFFF000LL);
    v55 = v53 & 0xFFF0;
    if ( &v128 != (int *)v54 )
    {
      while ( v127 != v54 )
        ;
    }
    v56 = v55 & 0xFFF;
    if ( v56 )
    {
      v122 = alloca(v56);
      *(_QWORD *)&v127[v56 - 8] = *(_QWORD *)&v127[v56 - 8];
    }
    a2 = (__int64 *)v45;
    v57 = dl_dst_substitute(v12, v45, v127);
    if ( *v57 )
    {
      v45 = v57;
LABEL_122:
      v157 = v45;
      if ( (dl_debug_mask & 1) != 0 )
      {
        v123 = *(const char **)(v12 + 8);
        if ( !*v123 )
        {
          v123 = (const char *)program_invocation_short_name[0];
          if ( !program_invocation_short_name[0] )
            v123 = "<main program>";
        }
        dl_debug_printf("load auxiliary object=%s requested by file=%s\n", v45, v123);
      }
      a2 = (__int64 *)openaux;
      v42 = dl_catch_exception((__int64)v149, (void (__fastcall *)(__int64))openaux, (__int64)v148, v46, a5, a6);
      a3 = (__int64)v127;
      if ( v152[0].m128i_i64[1] )
      {
        if ( *v26 != 2147483645 )
          goto LABEL_72;
        dl_exception_free(v149, (__int64)openaux, (__int64)v127, v10, (u32 *)a5, a6);
        goto LABEL_45;
      }
      v92 = v150;
      v93 = v139;
      v145 = _mm_loadu_si128(v139);
      a2 = (__int64 *)&v124;
      v124 = v145;
      v125 = v139[1].m128i_i64[0];
      v94 = v158;
      v139->m128i_i32[0] = 0;
      v93->m128i_i64[1] = v94;
      if ( v92 )
      {
        v95 = v13++;
        v92[v95] = v94;
        v94 = v158;
      }
      if ( (*(_BYTE *)(v94 + 796) & 0x60) != 0 )
      {
        for ( i = &v124; ; i = (__m128i *)i[1].m128i_i64[0] )
        {
          a3 = i[1].m128i_i64[0];
          if ( !a3 )
          {
            v117 = v139;
            *v139 = _mm_load_si128(&v124);
            v117[1].m128i_i64[0] = v125;
            goto LABEL_45;
          }
          if ( *(_QWORD *)(a3 + 8) == v94 )
            break;
        }
        v139[1].m128i_i64[0] = (__int64)&v124;
        v118 = (__int64)v146;
        v119 = (__m128i *)i[1].m128i_i64[0];
        v120 = v119 == v146;
        v121 = v119[1].m128i_i64[0];
        if ( v120 )
          v118 = (__int64)i;
        i[1].m128i_i64[0] = v121;
        v96 = *(_QWORD *)(v94 + 32);
        v146 = (__m128i *)v118;
        v97 = *(_QWORD *)(v94 + 24);
        if ( v96 )
        {
LABEL_128:
          *(_QWORD *)(v96 + 24) = v97;
          v97 = *(_QWORD *)(v94 + 24);
        }
      }
      else
      {
        v96 = *(_QWORD *)(v94 + 32);
        ++v143;
        v139[1].m128i_i64[0] = (__int64)&v124;
        *(_BYTE *)(v94 + 796) = *(_BYTE *)(v94 + 796) & 0x9F | 0x20;
        v97 = *(_QWORD *)(v94 + 24);
        if ( v96 )
          goto LABEL_128;
      }
      if ( v97 )
        *(_QWORD *)(v97 + 32) = v96;
      a3 = v124.m128i_i64[1];
      *(_QWORD *)(v94 + 32) = *(_QWORD *)(v124.m128i_i64[1] + 32);
      *(_QWORD *)(a3 + 32) = v94;
      v98 = *(_QWORD *)(v94 + 32);
      if ( v98 )
        *(_QWORD *)(v98 + 24) = v94;
      *(_QWORD *)(v94 + 24) = a3;
      if ( v139 == v146 )
      {
        v139 = &v124;
        v146 = &v124;
      }
      else
      {
        v139 = &v124;
      }
      goto LABEL_45;
    }
    if ( *v26 == 2147483645 )
      dl_signal_error(0, v45, 0LL, "empty dynamic string token substitution");
    if ( (dl_debug_mask & 1) != 0 )
    {
      a2 = (__int64 *)v45;
      dl_debug_printf("cannot load auxiliary `%s' because of empty dynamic string token substitution\n", v45);
    }
LABEL_45:
    v26 += 2;
    v27 = *v26;
    if ( !*v26 )
      goto LABEL_16;
  }
  v28 = (char *)(v26[1] + v151);
  v30 = dl_dst_count((__int64)v28);
  if ( !v30 )
  {
    v41 = v28;
    goto LABEL_40;
  }
  if ( _libc_enable_secure )
    dl_signal_error(0, v28, 0LL, "DST not allowed in SUID/SGID programs");
  v31 = j_strlen_ifunc(v28);
  v32 = *(_QWORD *)(v12 + 832);
  v33 = v31;
  if ( !v32 )
  {
    if ( **(_BYTE **)(v12 + 8) )
      _assert_fail(
        (__int64)"(l)->l_name[0] == '\\0' || IS_RTLD (l)",
        (__int64)"dl-deps.c",
        0xF4u,
        "_dl_map_object_deps");
    v145.m128i_i64[0] = v31;
    v58 = dl_get_origin();
    v33 = v145.m128i_i64[0];
    *(_QWORD *)(v12 + 832) = v58;
    if ( (unsigned __int64)(v58 - 1) <= 0xFFFFFFFFFFFFFFFDLL )
    {
      v145.m128i_i64[0] = v33;
      v34 = j_strlen_ifunc(v58);
      v33 = v145.m128i_i64[0];
      goto LABEL_31;
    }
    goto LABEL_66;
  }
  if ( v32 == -1 )
  {
LABEL_66:
    v34 = 0LL;
    goto LABEL_31;
  }
  v145.m128i_i64[0] = v31;
  v34 = j_strlen_ifunc(v32);
  v33 = v145.m128i_i64[0];
LABEL_31:
  v35 = 5LL;
  if ( (unsigned __int64)dl_platformlen >= 5 )
    v35 = dl_platformlen;
  if ( v35 < v34 )
    v35 = v34;
  v36 = v33 + (v35 - 4) * v30 + 23;
  v37 = (char *)&v133 - (v36 & 0xFFFFFFFFFFFFF000LL);
  v38 = v36 & 0xFFF0;
  if ( &v133 != (int *)v37 )
  {
    while ( v132 != v37 )
      ;
  }
  v39 = v38 & 0xFFF;
  if ( v39 )
  {
    v40 = alloca(v39);
    *(_QWORD *)&v132[v39 - 8] = *(_QWORD *)&v132[v39 - 8];
  }
  a2 = (__int64 *)v28;
  v41 = dl_dst_substitute(v12, v28, v132);
  if ( !*v41 )
  {
    if ( (dl_debug_mask & 1) != 0 )
    {
      a2 = (__int64 *)v28;
      dl_debug_printf("cannot load auxiliary `%s' because of empty dynamic string token substitution\n", v28);
    }
    goto LABEL_45;
  }
LABEL_40:
  a2 = (__int64 *)openaux;
  v157 = v41;
  v42 = dl_catch_exception((__int64)v149, (void (__fastcall *)(__int64))openaux, (__int64)v148, v29, a5, a6);
  if ( !v152[0].m128i_i64[1] )
  {
    v43 = v158;
    if ( (*(_BYTE *)(v158 + 796) & 0x60) == 0 )
    {
      ++v143;
      a3 = (__int64)&v128;
      v129 = v158;
      v128 = 0;
      v130 = 0LL;
      v146[1].m128i_i64[0] = (__int64)&v128;
      v44 = *(_BYTE *)(v43 + 796);
      v146 = (__m128i *)&v128;
      *(_BYTE *)(v43 + 796) = v44 & 0x9F | 0x20;
    }
    a2 = v150;
    if ( v150 )
    {
      a3 = v13++;
      v150[a3] = v43;
    }
    goto LABEL_45;
  }
LABEL_72:
  v23 = (__int64)v137;
  v24 = v42;
  if ( !v42 )
    v24 = -1;
LABEL_74:
  if ( (__int64 *)v159[0] != v138 + 2 )
    free(v159[0], (__int64)a2, a3, v10, (u32 *)a5, a6);
  LODWORD(a3) = __readfsdword(0xFFFFFFC0);
  if ( !(_DWORD)a3 && v140 )
    __writefsdword(0xFFFFFFC0, v140);
  v150 = *(__int64 **)(v147 + 960);
  if ( v150 )
  {
    LOBYTE(v151) = *(_BYTE *)(v147 + 796);
    if ( (v151 & 3) == 2 )
    {
      if ( *(_QWORD *)(v147 + 704) )
        _assert_fail((__int64)"map->l_searchlist.r_list == NULL", (__int64)"dl-deps.c", 0x1D8u, "_dl_map_object_deps");
    }
    else
    {
      v150 = 0LL;
    }
  }
  v151 = (__int64)malloc(8LL * (unsigned int)(2 * v143 + 1), (__int64)a2, (_QWORD *)a3, v10, (u32 *)a5, a6);
  if ( !v151 )
LABEL_189:
    dl_signal_error(12, *(void **)(v147 + 8), 0LL, "cannot allocate symbol search list");
  v60 = v143;
  v61 = v151;
  v62 = v142;
  v63 = (_QWORD *)(v151 + 8LL * (unsigned int)(v143 + 1));
  v64 = v147;
  *(_QWORD *)(v147 + 704) = v63;
  *(_DWORD *)(v64 + 712) = v60;
  v65 = 0;
  do
  {
    v66 = *(_QWORD *)(v23 + 8);
    if ( v62 && (*(_BYTE *)(v66 + 797) & 2) != 0 )
    {
      v61 = v147;
      --*(_DWORD *)(v147 + 712);
    }
    else
    {
      v59 = v65++;
      v63[v59] = v66;
      v66 = *(_QWORD *)(v23 + 8);
    }
    *(_BYTE *)(v66 + 796) &= 0x9Fu;
    v23 = *(_QWORD *)(v23 + 16);
  }
  while ( v23 );
  if ( (dl_debug_mask & 0x800) != 0 && dl_ns == (void *)v147 && v65 )
  {
    v146 = 0LL;
    v59 = (unsigned __int64)v63;
    v101 = (_QWORD *)v151;
    LODWORD(v144) = v24;
    v102 = 0LL;
    v149 = (_QWORD *)(8LL * (v65 - 1) + 8);
    v103 = v147;
    v145.m128i_i32[0] = v65;
    do
    {
      v104 = *(_QWORD *)((char *)v102 + v59);
      if ( v103 != v104 )
      {
        v105 = *(_QWORD *)(v104 + 912);
        if ( !v105 || !*(_DWORD *)(v105 + 8) )
        {
          if ( *(_QWORD *)(v104 + 488) || *(_QWORD *)(v104 + 472) )
            dl_signal_error(22, *(void **)(v104 + 8), 0LL, "Filters not supported with LD_TRACE_PRELINKING");
          v106 = *(_QWORD *)((char *)v102 + v59);
          v107 = dl_build_local_scope(v101, v106);
          v111 = v107;
          if ( v107 > v145.m128i_i32[0] )
            _assert_fail((__int64)"cnt <= nlist", (__int64)"dl-deps.c", 0x210u, "_dl_map_object_deps");
          if ( v107 )
          {
            v112 = v107 - 1;
            *(_BYTE *)(*v101 + 796LL) &= 0x9Fu;
            v113 = v101 + 1;
            v106 = (__int64)&v101[v112 + 1];
            while ( (_QWORD *)v106 != v113 )
            {
              *(_BYTE *)(*v113 + 796LL) &= 0x9Fu;
              if ( *(_QWORD *)(*v113 + 192LL) )
                *(_BYTE *)(v104 + 797) |= 0x80u;
              ++v113;
            }
          }
          v148 = (__int64 *)(8LL * v111 + 16);
          v114 = malloc((unsigned __int64)v148, v106, v148, v108, v109, v110);
          v115 = v148;
          *(_QWORD *)(v104 + 912) = v114;
          if ( !v114 )
            goto LABEL_189;
          *((_DWORD *)v114 + 2) = v111;
          v61 = (__int64)v101;
          *v114 = v114 + 2;
          j_memcpy(v114 + 2, v101, v115 - 2);
          v59 = *(_QWORD *)(v103 + 704);
        }
      }
      ++v102;
    }
    while ( v149 != v102 );
    v23 = (__int64)v146;
    v24 = (int)v144;
    v63 = (_QWORD *)v59;
    v65 = v145.m128i_i32[0];
  }
  if ( *v63 != v147 )
    _assert_fail((__int64)"map->l_searchlist.r_list[0] == map", (__int64)"dl-deps.c", 0x229u, "_dl_map_object_deps");
  v67 = *(__m128i **)(v147 + 968);
  if ( v67 )
  {
    v68 = v67->m128i_i32[0];
    v69 = (__int64)&v67->m128i_i64[1];
    if ( v65 <= 1 )
    {
      if ( v68 )
      {
LABEL_94:
        LODWORD(v148) = v65;
        v71 = 0;
        v72 = (_DWORD *)v23;
        LODWORD(v149) = v24;
        v73 = (unsigned int *)v67;
        v74 = &v67->m128i_u32[2];
        v146 = v67 + 1;
        v145.m128i_i64[0] = (__int64)v63;
        do
        {
          while ( 1 )
          {
            v75 = v71 + 1;
            if ( (*(_BYTE *)(*(_QWORD *)&v74[2 * v71] + 796LL) & 0x60) != 0 )
            {
              v76 = (__m128i *)malloc(
                                 8LL * *(unsigned int *)(v147 + 976) + 8,
                                 v61,
                                 (_QWORD *)v59,
                                 (__int64)v72,
                                 (u32 *)v67,
                                 v69);
              v72 = v76;
              if ( v76 )
                break;
            }
            ++v71;
            if ( v75 >= *v73 )
              goto LABEL_105;
          }
          v144 = v76;
          j_memcpy(&v76->m128i_u64[1], v74, 8LL * v71);
          v77 = *v73;
          v72 = v144;
          if ( *v73 <= v75 )
          {
            v61 = v71;
          }
          else
          {
            v78 = (__int64)&v73[2 * v75 + 2];
            v61 = v71;
            v79 = &v146->m128i_i8[8 * v75 + 8 * (unsigned __int64)(v77 - 2 - v71)];
            do
            {
              v59 = *(_QWORD *)v78;
              if ( (*(_BYTE *)(*(_QWORD *)v78 + 796LL) & 0x60) == 0 )
              {
                v67 = (__m128i *)(unsigned int)v61;
                v61 = (unsigned int)(v61 + 1);
                *(_QWORD *)&v72[2 * (_QWORD)v67 + 2] = v59;
              }
              v78 += 8LL;
            }
            while ( v79 != (char *)v78 );
            v75 = v77;
          }
          *v72 = v61;
          v71 = v75 + 1;
        }
        while ( v75 + 1 < *v73 );
LABEL_105:
        v65 = (unsigned int)v148;
        v23 = (__int64)v72;
        v24 = (int)v149;
        v63 = (_QWORD *)v145.m128i_i64[0];
        if ( (unsigned int)v148 > 1 )
          goto LABEL_106;
      }
    }
    else
    {
      v59 = (unsigned __int64)(v63 + 1);
      v61 = (__int64)&v63[v65];
      do
      {
        v70 = *(_QWORD *)v59;
        v59 += 8LL;
        *(_BYTE *)(v70 + 796) = *(_BYTE *)(v70 + 796) & 0x9F | 0x20;
      }
      while ( v61 != v59 );
      if ( v68 )
        goto LABEL_94;
LABEL_106:
      v80 = 1LL;
      do
      {
        v81 = v63[v80++];
        *(_BYTE *)(v81 + 796) &= 0x9Fu;
      }
      while ( v65 > (unsigned int)v80 );
    }
  }
  else
  {
    v23 = 0LL;
  }
  v82 = v63;
  v83 = v151;
  j_memcpy(v151, v82, 8LL * v65);
  v84 = v65 - 1;
  dl_sort_maps(v83 + 8, v84, 0LL, 0);
  *(_QWORD *)(v83 + 8LL * v65) = 0LL;
  v88 = v147;
  *(_QWORD *)(v147 + 960) = v83;
  *(_BYTE *)(v88 + 798) |= 1u;
  if ( v23 )
  {
    v89 = *(_QWORD *)(v88 + 968);
    *(_QWORD *)(v88 + 968) = v23;
    dl_scope_free(v89, v84, v85, v88, v86, v87);
  }
  result = v150;
  if ( v150 )
    result = (__int64 *)dl_scope_free((__int64)v150, v84, v85, v88, v86, v87);
  if ( v24 )
  {
    if ( v24 == -1 )
      v24 = 0;
    dl_signal_exception(v24, v152, 0LL);
  }
  return result;
}
// 4774FA: variable 'a3' is possibly undefined
// 4774FA: variable 'a5' is possibly undefined
// 4774FA: variable 'a6' is possibly undefined
// 4776FA: variable 'v29' is possibly undefined
// 4779A3: variable 'v10' is possibly undefined
// 477B75: variable 'v59' is possibly undefined
// 477B75: variable 'v67' is possibly undefined
// 477B75: variable 'v69' is possibly undefined
// 477CA8: variable 'v85' is possibly undefined
// 477CA8: variable 'v86' is possibly undefined
// 477CA8: variable 'v87' is possibly undefined
// 477CBC: variable 'v88' is possibly undefined
// 477D87: variable 'v46' is possibly undefined
// 478090: variable 'v108' is possibly undefined
// 478090: variable 'v109' is possibly undefined
// 478090: variable 'v110' is possibly undefined
// 478308: variable 'v16' is possibly undefined
// 478308: variable 'v17' is possibly undefined
// 478308: variable 'v18' is possibly undefined
// 478308: variable 'v19' is possibly undefined
// 401040: using guessed type __int64 __fastcall j_memcpy(_QWORD, _QWORD, _QWORD);
// 4010C8: using guessed type __int64 __fastcall j_strlen_ifunc(_QWORD);
// 4A7AD8: using guessed type int _libc_enable_secure;
// 4A9168: using guessed type char (*program_invocation_short_name[2])[1707];
// 4A9280: using guessed type void *dl_ns;
// 4AB878: using guessed type __int64 dl_platformlen;
// 4AB880: using guessed type int dl_debug_mask;
// 4772D0: using guessed type int anonymous_3[3];

//----- (0000000000478380) ----------------------------------------------------
__int64 __fastcall call_init_part_0(__int64 a1, unsigned int a2, __int64 a3, __int64 a4)
{
  const char *v4; // r8
  __int64 result; // rax
  __int64 v8; // rax
  __int64 (__fastcall **v9)(_QWORD, _QWORD, _QWORD); // rbx
  __int64 v10; // rdx
  __int64 v11; // r14

  v4 = *(const char **)(a1 + 8);
  result = *(unsigned __int8 *)(a1 + 796) | 8u;
  *(_BYTE *)(a1 + 796) |= 8u;
  if ( !*v4 && (result & 3) == 0 )
    return result;
  v8 = *(_QWORD *)(a1 + 160);
  if ( v8 )
  {
    if ( (dl_debug_mask & 2) == 0 )
    {
LABEL_4:
      ((void (__fastcall *)(_QWORD, __int64, __int64))(*(_QWORD *)a1 + *(_QWORD *)(v8 + 8)))(a2, a3, a4);
      goto LABEL_5;
    }
  }
  else
  {
    result = *(_QWORD *)(a1 + 264);
    if ( !result )
      return result;
    if ( (dl_debug_mask & 2) == 0 )
      goto LABEL_6;
  }
  if ( !*v4 )
  {
    v4 = (const char *)program_invocation_short_name[0];
    if ( !program_invocation_short_name[0] )
      v4 = "<main program>";
  }
  dl_debug_printf("\ncalling init: %s\n\n", v4);
  v8 = *(_QWORD *)(a1 + 160);
  if ( v8 )
    goto LABEL_4;
LABEL_5:
  result = *(_QWORD *)(a1 + 264);
  if ( !result )
    return result;
LABEL_6:
  v9 = (__int64 (__fastcall **)(_QWORD, _QWORD, _QWORD))(*(_QWORD *)(result + 8) + *(_QWORD *)a1);
  v10 = *(_QWORD *)(*(_QWORD *)(a1 + 280) + 8LL) >> 3;
  if ( (_DWORD)v10 )
  {
    v11 = (__int64)&v9[(unsigned int)(v10 - 1) + 1];
    do
      result = (*v9++)(a2, a3, a4);
    while ( (__int64 (__fastcall **)(_QWORD, _QWORD, _QWORD))v11 != v9 );
  }
  return result;
}
// 4A9168: using guessed type char (*program_invocation_short_name[2])[1707];
// 4AB880: using guessed type int dl_debug_mask;

//----- (00000000004784A0) ----------------------------------------------------
_DWORD *__fastcall dl_init(__int64 a1, unsigned int a2, __int64 a3, __int64 a4)
{
  __int64 v8; // rbx
  __int64 v9; // r15
  unsigned int v10; // ebx
  __int64 v11; // rdi
  _DWORD *result; // rax
  __int64 v13; // r15
  void (__fastcall **v14)(_QWORD, __int64, __int64); // rax
  void (__fastcall **v15)(_QWORD, __int64, __int64); // rbx
  __int64 v16; // r15
  const char *v17; // rsi

  v8 = *(_QWORD *)(a1 + 320);
  v9 = *(_QWORD *)(a1 + 328);
  if ( dl_initfirst )
  {
    if ( (*(_BYTE *)(dl_initfirst + 796) & 8) == 0 )
      call_init_part_0(dl_initfirst, a2, a3, a4);
    dl_initfirst = 0LL;
  }
  if ( v8 )
  {
    if ( v9 )
    {
      v13 = *(_QWORD *)(v9 + 8) >> 3;
      if ( (_DWORD)v13 )
      {
        if ( (dl_debug_mask & 2) != 0 )
        {
          v17 = *(const char **)(a1 + 8);
          if ( !*v17 )
          {
            v17 = (const char *)program_invocation_short_name[0];
            if ( !program_invocation_short_name[0] )
              v17 = "<main program>";
          }
          dl_debug_printf("\ncalling preinit: %s\n\n", v17);
        }
        v14 = (void (__fastcall **)(_QWORD, __int64, __int64))(*(_QWORD *)(v8 + 8) + *(_QWORD *)a1);
        v15 = v14 + 1;
        v16 = (__int64)&v14[(unsigned int)(v13 - 1) + 1];
        while ( 1 )
        {
          (*v14)(a2, a3, a4);
          v14 = v15;
          if ( (void (__fastcall **)(_QWORD, __int64, __int64))v16 == v15 )
            break;
          ++v15;
        }
      }
    }
  }
  v10 = *(_DWORD *)(a1 + 712);
  while ( --v10 != -1 )
  {
    while ( 1 )
    {
      v11 = *(_QWORD *)(*(_QWORD *)(a1 + 960) + 8LL * v10);
      if ( (*(_BYTE *)(v11 + 796) & 8) != 0 )
        break;
      --v10;
      call_init_part_0(v11, a2, a3, a4);
      if ( v10 == -1 )
        goto LABEL_8;
    }
  }
LABEL_8:
  result = dl_starting_up;
  dl_starting_up[0] = 0;
  return result;
}
// 4A9168: using guessed type char (*program_invocation_short_name[2])[1707];
// 4A9200: using guessed type _DWORD dl_starting_up[2];
// 4AB880: using guessed type int dl_debug_mask;
// 4AB918: using guessed type __int64 dl_initfirst;

//----- (00000000004785F0) ----------------------------------------------------
__int64 __fastcall dl_check_map_versions(
        _QWORD *a1,
        unsigned int a2,
        int a3,
        double a4,
        double a5,
        double a6,
        double a7,
        double a8,
        double a9,
        double a10,
        double a11,
        __int64 a12,
        u32 *a13,
        __int64 a14)
{
  __int64 v14; // rax
  _QWORD *v15; // rbp
  __int64 v16; // r13
  __int64 v17; // rcx
  __int64 v18; // rax
  unsigned int *v19; // rax
  unsigned int v20; // er15
  __int64 v21; // r12
  __int64 v22; // rbx
  __int64 j; // rdx
  double v24; // xmm4_8
  double v25; // xmm5_8
  char *i; // r12
  int v27; // ebx
  _QWORD *v28; // r14
  const char *v29; // r13
  __int64 v30; // rbp
  __int64 v31; // rax
  __int64 v32; // rdx
  char *v33; // r13
  __int64 v34; // r12
  int v35; // ebp
  __int64 v36; // rbx
  __int64 v37; // rax
  __int64 v38; // rax
  u32 *v39; // r8
  __int64 v40; // r9
  double v41; // xmm4_8
  double v42; // xmm5_8
  char *v43; // rsi
  __int64 v44; // rax
  unsigned int v45; // er13
  __int64 v46; // rax
  unsigned int v47; // ebx
  u32 *v48; // rax
  __int64 v49; // rdx
  unsigned int *k; // rdi
  char *m; // rcx
  unsigned __int16 v52; // si
  u32 v53; // er8
  u32 *v54; // rsi
  __int64 v55; // rdx
  __int64 v56; // rdx
  __int64 v57; // rdx
  __int64 n; // rdx
  __int64 v59; // rsi
  u32 *v60; // rcx
  __int64 v61; // rcx
  char *v63; // rsi
  const char *v64; // rdx
  __int64 v65; // rax
  char *v66; // rsi
  __int64 v67; // rax
  u32 *v68; // r8
  __int64 v69; // r9
  double v70; // xmm4_8
  double v71; // xmm5_8
  char *v72; // rsi
  int v73; // edi
  char *v74; // rsi
  char *v75; // rsi
  char v76; // [rsp+0h] [rbp-C8h]
  const char *v77; // [rsp+0h] [rbp-C8h]
  __int64 v78; // [rsp+8h] [rbp-C0h]
  _QWORD *v79; // [rsp+10h] [rbp-B8h]
  __int64 v80; // [rsp+18h] [rbp-B0h]
  __int16 v81; // [rsp+26h] [rbp-A2h]
  unsigned int *v82; // [rsp+28h] [rbp-A0h]
  u32 *v83; // [rsp+30h] [rbp-98h]
  __int64 v84; // [rsp+38h] [rbp-90h]
  __int64 v86; // [rsp+48h] [rbp-80h]
  char v87[13]; // [rsp+63h] [rbp-65h] BYREF
  __m128i v88[5]; // [rsp+70h] [rbp-58h] BYREF

  v14 = a1[13];
  if ( v14 )
  {
    v15 = a1;
    v16 = *(_QWORD *)(v14 + 8);
    v17 = a1[46];
    v18 = a1[44];
    v86 = v18;
    v84 = v17;
    if ( v18 )
    {
      v19 = (unsigned int *)(*a1 + *(_QWORD *)(v18 + 8));
      v20 = 0;
      v82 = v19;
      if ( *(_WORD *)v19 != 1 )
      {
        v87[0] = 0;
        v67 = itoa_word(*(unsigned __int16 *)v19, (__int64)v87, 0xAu, 0);
        v72 = (char *)a1[1];
        if ( !*v72 )
        {
          v72 = (char *)program_invocation_short_name[0];
          if ( !program_invocation_short_name[0] )
            v72 = "<main program>";
        }
        dl_exception_create_format(
          (const char **)v88,
          v72,
          "unsupported version %s of Verneed record",
          a4,
          a5,
          a6,
          a7,
          v70,
          v71,
          a10,
          a11,
          v67,
          v68,
          v69,
          v76);
        v73 = 0;
        goto LABEL_88;
      }
      v78 = v16;
      while ( 1 )
      {
        v21 = v78 + v82[1];
        v22 = (__int64)*(&dl_ns + 18 * v15[6]);
        if ( v22 )
        {
          while ( !(unsigned int)dl_name_match_p(v21, v22) )
          {
            v22 = *(_QWORD *)(v22 + 24);
            if ( !v22 )
              goto LABEL_34;
          }
        }
        else
        {
LABEL_34:
          if ( !*((_DWORD *)v15 + 178) )
            goto LABEL_39;
          v45 = 0;
          while ( !(unsigned int)dl_name_match_p(v21, *(_QWORD *)(v15[88] + 8LL * v45)) )
          {
            if ( ++v45 >= *((_DWORD *)v15 + 178) )
              goto LABEL_39;
          }
          v22 = *(_QWORD *)(v15[88] + 8LL * v45);
          if ( !v22 )
LABEL_39:
            _assert_fail((__int64)"needed != NULL", (__int64)"dl-version.c", 0xCDu, "_dl_check_map_versions");
        }
        if ( !a3 || (*(_BYTE *)(v22 + 797) & 2) == 0 )
        {
          v80 = v22;
          v79 = v15;
          for ( i = (char *)v82 + v82[2]; ; i += v44 )
          {
            v27 = *(_DWORD *)i;
            v81 = *((_WORD *)i + 2);
            v28 = *(_QWORD **)(v80 + 40);
            v77 = (const char *)(v78 + *((unsigned int *)i + 2));
            v29 = (const char *)v79[1];
            if ( !*v29 )
            {
              v29 = (const char *)program_invocation_short_name[0];
              if ( !program_invocation_short_name[0] )
                v29 = "<main program>";
            }
            v30 = *(_QWORD *)(v28[13] + 8LL);
            if ( (dl_debug_mask & 0x10) != 0 )
            {
              v64 = (const char *)v28[1];
              if ( !*v64 )
              {
                v64 = (const char *)program_invocation_short_name[0];
                if ( !program_invocation_short_name[0] )
                  v64 = "<main program>";
              }
              dl_debug_printf(
                "checking for version `%s' in file %s [%lu] required by file %s [%lu]\n",
                v77,
                v64,
                v28[6],
                v29,
                v79[6]);
            }
            v31 = v28[46];
            if ( v31 )
            {
              v32 = *(_QWORD *)(v31 + 8);
              if ( !v32 )
                _assert_fail((__int64)"def_offset != 0", (__int64)"dl-version.c", 0x58u, "match_symbol");
              j = *v28 + v32;
              if ( *(_WORD *)j != 1 )
              {
LABEL_23:
                v87[0] = 0;
                v38 = itoa_word(*(unsigned __int16 *)j, (__int64)v87, 0xAu, 0);
                v43 = (char *)v28[1];
                if ( !*v43 )
                {
                  v43 = (char *)program_invocation_short_name[0];
                  if ( !program_invocation_short_name[0] )
                    v43 = "<main program>";
                }
                dl_exception_create_format(
                  (const char **)v88,
                  v43,
                  "unsupported version %s of Verdef record",
                  a4,
                  a5,
                  a6,
                  a7,
                  v41,
                  v42,
                  a10,
                  a11,
                  v38,
                  v39,
                  v40,
                  (char)v77);
                goto LABEL_27;
              }
              v83 = (u32 *)v29;
              v33 = i;
              v34 = v30;
              v35 = v27;
              v36 = j;
              while ( 1 )
              {
                if ( v35 == *(_DWORD *)(v36 + 8)
                  && !(unsigned int)j_strcmp_ifunc(v77, v34 + *(unsigned int *)(v36 + *(unsigned int *)(v36 + 12))) )
                {
                  i = v33;
                  goto LABEL_30;
                }
                v37 = *(unsigned int *)(v36 + 16);
                if ( !(_DWORD)v37 )
                  break;
                v36 += v37;
                if ( *(_WORD *)v36 != 1 )
                {
                  j = v36;
                  goto LABEL_23;
                }
              }
              i = v33;
              if ( (v81 & 2) == 0 )
              {
                v74 = (char *)v28[1];
                if ( !*v74 )
                {
                  v74 = (char *)program_invocation_short_name[0];
                  if ( !program_invocation_short_name[0] )
                    v74 = "<main program>";
                }
                dl_exception_create_format(
                  (const char **)v88,
                  v74,
                  "version `%s' not found (required by %s)",
                  a4,
                  a5,
                  a6,
                  a7,
                  v24,
                  v25,
                  a10,
                  a11,
                  (__int64)v77,
                  v83,
                  a14,
                  (char)v77);
                goto LABEL_27;
              }
              if ( a2 )
              {
                v66 = (char *)v28[1];
                if ( !*v66 )
                {
                  v66 = (char *)program_invocation_short_name[0];
                  if ( !program_invocation_short_name[0] )
                    v66 = "<main program>";
                }
                dl_exception_create_format(
                  (const char **)v88,
                  v66,
                  "weak version `%s' not found (required by %s)",
                  a4,
                  a5,
                  a6,
                  a7,
                  v24,
                  v25,
                  a10,
                  a11,
                  (__int64)v77,
                  v83,
                  a14,
                  (char)v77);
                goto LABEL_27;
              }
            }
            else
            {
              j = a2;
              if ( a2 )
              {
                v63 = (char *)v28[1];
                if ( !*v63 )
                {
                  v63 = (char *)program_invocation_short_name[0];
                  if ( !program_invocation_short_name[0] )
                    v63 = "<main program>";
                }
                dl_exception_create_format(
                  (const char **)v88,
                  v63,
                  "no version information available (required by %s)",
                  a4,
                  a5,
                  a6,
                  a7,
                  v24,
                  v25,
                  a10,
                  a11,
                  (__int64)v29,
                  a13,
                  a14,
                  (char)v77);
LABEL_27:
                dl_signal_exception(0, v88, "version lookup error");
              }
            }
LABEL_30:
            if ( v20 < (*((_WORD *)i + 3) & 0x7FFFu) )
              v20 = *((_WORD *)i + 3) & 0x7FFF;
            v44 = *((unsigned int *)i + 3);
            if ( !(_DWORD)v44 )
              break;
          }
          v15 = v79;
        }
        v17 = (__int64)v82;
        v65 = v82[3];
        if ( !(_DWORD)v65 )
          break;
        v82 = (unsigned int *)((char *)v82 + v65);
      }
      v16 = v78;
      if ( !v84 )
        goto LABEL_46;
    }
    else
    {
      v20 = 0;
      if ( !v17 )
        return 0LL;
    }
    for ( j = *v15 + *(_QWORD *)(v84 + 8); ; j += v46 )
    {
      if ( v20 < (*(_WORD *)(j + 4) & 0x7FFFu) )
        v20 = *(_WORD *)(j + 4) & 0x7FFF;
      v46 = *(unsigned int *)(j + 16);
      if ( !(_DWORD)v46 )
        break;
    }
LABEL_46:
    if ( v20 )
    {
      v47 = v20 + 1;
      v48 = calloc(v20 + 1, 0x18uLL, j, v17, a13, a14);
      v15[93] = v48;
      if ( v48 )
      {
        v49 = v15[58];
        *((_DWORD *)v15 + 188) = v47;
        v15[103] = *(_QWORD *)(v49 + 8);
        if ( v86 )
        {
          for ( k = (unsigned int *)(*v15 + *(_QWORD *)(v86 + 8)); ; k = (unsigned int *)((char *)k + v57) )
          {
            for ( m = (char *)k + k[2]; ; m += v56 )
            {
              v52 = *((_WORD *)m + 3) & 0x7FFF;
              if ( v47 > v52 )
              {
                v53 = *(_DWORD *)m;
                v54 = &v48[6 * v52];
                v54[3] = *((_WORD *)m + 3) & 0x8000;
                v55 = *((unsigned int *)m + 2);
                v54[2] = v53;
                *(_QWORD *)v54 = v16 + v55;
                *((_QWORD *)v54 + 2) = v16 + k[1];
              }
              v56 = *((unsigned int *)m + 3);
              if ( !(_DWORD)v56 )
                break;
            }
            v57 = k[3];
            if ( !(_DWORD)v57 )
              break;
          }
        }
        if ( v84 )
        {
          for ( n = *v15 + *(_QWORD *)(v84 + 8); ; n += v61 )
          {
            if ( (*(_BYTE *)(n + 2) & 1) == 0 )
            {
              v59 = *(unsigned int *)(n + *(unsigned int *)(n + 12));
              v60 = &v48[6 * (*(_WORD *)(n + 4) & 0x7FFF)];
              v60[2] = *(_DWORD *)(n + 8);
              *(_QWORD *)v60 = v16 + v59;
              *((_QWORD *)v60 + 2) = 0LL;
            }
            v61 = *(unsigned int *)(n + 16);
            if ( !(_DWORD)v61 )
              break;
          }
        }
        return 0LL;
      }
      v75 = (char *)v15[1];
      if ( !*v75 )
      {
        v75 = (char *)program_invocation_short_name[0];
        if ( !program_invocation_short_name[0] )
          v75 = "<main program>";
      }
      dl_exception_create((const char **)v88, v75, (__int64)"cannot allocate version reference table");
      v73 = 12;
LABEL_88:
      dl_signal_exception(v73, v88, 0LL);
    }
    return 0LL;
  }
  return 0LL;
}
// 4787D5: variable 'v41' is possibly undefined
// 4787D5: variable 'v42' is possibly undefined
// 4787D5: variable 'v39' is possibly undefined
// 4787D5: variable 'v40' is possibly undefined
// 4788FF: variable 'j' is possibly undefined
// 4788FF: variable 'a13' is possibly undefined
// 4788FF: variable 'a14' is possibly undefined
// 478A4D: variable 'v24' is possibly undefined
// 478A4D: variable 'v25' is possibly undefined
// 478B7B: variable 'v70' is possibly undefined
// 478B7B: variable 'v71' is possibly undefined
// 478B7B: variable 'v68' is possibly undefined
// 478B7B: variable 'v69' is possibly undefined
// 478B7B: variable 'v76' is possibly undefined
// 4010A0: using guessed type __int64 __fastcall j_strcmp_ifunc(_QWORD, _QWORD);
// 4A9168: using guessed type char (*program_invocation_short_name[2])[1707];
// 4A9280: using guessed type void *dl_ns;
// 4AB880: using guessed type int dl_debug_mask;

//----- (0000000000478C80) ----------------------------------------------------
__int64 __fastcall dl_check_all_versions(
        __int64 a1,
        unsigned int a2,
        int a3,
        __int64 a4,
        u32 *a5,
        __int64 a6,
        double a7,
        double a8,
        double a9,
        double a10,
        double a11,
        double a12,
        double a13,
        double a14)
{
  __int64 v14; // rbx
  unsigned int v16; // ebp
  int v17; // eax

  if ( !a1 )
    return 0LL;
  v14 = a1;
  v16 = 0;
  do
  {
    while ( (*(_BYTE *)(v14 + 797) & 2) != 0 )
    {
      v14 = *(_QWORD *)(v14 + 24);
      if ( !v14 )
        return v16;
    }
    v17 = dl_check_map_versions((_QWORD *)v14, a2, a3, a7, a8, a9, a10, a11, a12, a13, a14, a4, a5, a6);
    v14 = *(_QWORD *)(v14 + 24);
    v16 |= v17 != 0;
  }
  while ( v14 );
  return v16;
}
// 478CBB: variable 'a11' is possibly undefined
// 478CBB: variable 'a12' is possibly undefined
// 478CBB: variable 'a4' is possibly undefined
// 478CBB: variable 'a5' is possibly undefined
// 478CBB: variable 'a6' is possibly undefined

//----- (0000000000478CF0) ----------------------------------------------------
__int64 __fastcall call_dl_lookup(
        __int64 a1,
        double a2,
        double a3,
        double a4,
        double a5,
        double a6,
        double a7,
        double a8,
        double a9)
{
  __int64 v10; // [rsp-10h] [rbp-18h]

  *(_QWORD *)a1 = dl_lookup_symbol_x(
                    *(unsigned __int8 **)(a1 + 8),
                    *(_QWORD *)a1,
                    *(unsigned int ***)(a1 + 40),
                    *(__int64 **)(*(_QWORD *)a1 + 904LL),
                    *(const char ***)(a1 + 16),
                    0,
                    a2,
                    a3,
                    a4,
                    a5,
                    a6,
                    a7,
                    a8,
                    a9,
                    *(_DWORD *)(a1 + 24),
                    0LL);
  return v10;
}
// 478D1F: variable 'v10' is possibly undefined

//----- (0000000000478D30) ----------------------------------------------------
__int64 (*__fastcall do_sym(
        __int64 a1,
        unsigned __int8 *a2,
        unsigned __int64 a3,
        const char **a4,
        int a5,
        double a6,
        double a7,
        double a8,
        double a9,
        double a10,
        double a11,
        double a12,
        double a13))(void)
{
  _QWORD *dso_for_object; // rax
  __int64 v17; // rcx
  __int64 v18; // r8
  __int64 v19; // r9
  double v20; // xmm4_8
  double v21; // xmm5_8
  __int64 *v22; // rax
  __int64 (*v23)(void); // rdx
  __int64 v24; // rdx
  _QWORD *v26; // rdi
  u32 *v27; // r8
  u32 v28; // er9
  volatile __int32 *v29; // rax
  signed __int64 v30; // rax
  unsigned int *v31; // [rsp+8h] [rbp-90h] BYREF
  __m128i v32[2]; // [rsp+10h] [rbp-88h] BYREF
  __int64 v33[3]; // [rsp+30h] [rbp-68h] BYREF
  int v34; // [rsp+48h] [rbp-50h]
  unsigned int **v35; // [rsp+58h] [rbp-40h]
  unsigned __int64 v36; // [rsp+68h] [rbp-30h]

  v36 = __readfsqword(0x28u);
  v31 = 0LL;
  dso_for_object = dl_find_dso_for_object(a3);
  if ( !dso_for_object )
    dso_for_object = dl_ns;
  if ( a1 )
  {
    if ( a1 == -1 )
    {
      v26 = dso_for_object;
      if ( dl_ns == dso_for_object && (!dso_for_object || dso_for_object[105] > a3 || dso_for_object[106] <= a3) )
        dl_signal_error(0, 0LL, 0LL, "RTLD_NEXT used in code not dynamically loaded");
      while ( v26[92] )
        v26 = (_QWORD *)v26[92];
      v22 = (__int64 *)dl_lookup_symbol_x(
                         a2,
                         (__int64)dso_for_object,
                         &v31,
                         v26 + 114,
                         a4,
                         0,
                         a6,
                         a7,
                         a8,
                         a9,
                         v20,
                         v21,
                         a12,
                         a13,
                         0,
                         (__int64)dso_for_object);
    }
    else
    {
      v22 = (__int64 *)dl_lookup_symbol_x(
                         a2,
                         a1,
                         &v31,
                         (__int64 *)(a1 + 912),
                         a4,
                         0,
                         a6,
                         a7,
                         a8,
                         a9,
                         v20,
                         v21,
                         a12,
                         a13,
                         a5,
                         0LL);
    }
  }
  else if ( __readfsdword(0x18u) )
  {
    v33[0] = (__int64)dso_for_object;
    v33[1] = (__int64)a2;
    v33[2] = (__int64)a4;
    v34 = a5 | 5;
    v35 = &v31;
    __writefsdword(0x1Cu, 1u);
    v27 = (u32 *)(unsigned int)dl_catch_exception(
                                 (__int64)v32,
                                 (void (__fastcall *)(__int64))call_dl_lookup,
                                 (__int64)v33,
                                 v17,
                                 v18,
                                 v19);
    LODWORD(v29) = _InterlockedExchange(MK_FP(__FS__, 28LL), 0);
    if ( (_DWORD)v29 == 2 )
      v30 = sys_futex((u32 *)(__readfsqword(0x10u) + 28), 129, 1u, 0LL, v27, v28);
    v22 = (__int64 *)v33[0];
    if ( v32[0].m128i_i64[1] )
      dl_signal_exception((int)v27, v32, 0LL);
  }
  else
  {
    v22 = (__int64 *)dl_lookup_symbol_x(
                       a2,
                       (__int64)dso_for_object,
                       &v31,
                       (__int64 *)dso_for_object[113],
                       a4,
                       0,
                       a6,
                       a7,
                       a8,
                       a9,
                       v20,
                       v21,
                       a12,
                       a13,
                       a5 | 1u,
                       0LL);
  }
  v23 = 0LL;
  if ( v31 )
  {
    if ( *((_WORD *)v31 + 3) == 0xFFF1 || !v22 )
      v24 = 0LL;
    else
      v24 = *v22;
    v23 = (__int64 (*)(void))(*((_QWORD *)v31 + 1) + v24);
    if ( (v31[1] & 0xF) == 10 )
      return (__int64 (*)(void))v23();
  }
  return v23;
}
// 478DA6: variable 'v20' is possibly undefined
// 478DA6: variable 'v21' is possibly undefined
// 478F12: variable 'v17' is possibly undefined
// 478F12: variable 'v18' is possibly undefined
// 478F12: variable 'v19' is possibly undefined
// 478F48: variable 'v28' is possibly undefined
// 478F63: variable 'v27' is possibly undefined
// 4A9280: using guessed type void *dl_ns;

//----- (0000000000478F70) ----------------------------------------------------
__int64 (*__fastcall dl_vsym(
        __int64 a1,
        unsigned __int8 *a2,
        unsigned __int8 *a3,
        unsigned __int64 a4,
        double a5,
        double a6,
        double a7,
        double a8,
        double a9,
        double a10,
        double a11,
        double a12))(void)
{
  __int64 v12; // r8
  unsigned __int64 v14; // rax
  unsigned __int8 v15; // cl
  __int64 v16; // rax
  __int64 v17; // rcx
  __int64 v18; // rcx
  __int64 v19; // rcx
  unsigned __int8 *v20; // rcx
  __int64 v21; // rdx
  const char *v23; // [rsp+0h] [rbp-28h] BYREF
  int v24; // [rsp+8h] [rbp-20h]
  int v25; // [rsp+Ch] [rbp-1Ch]
  __int64 v26; // [rsp+10h] [rbp-18h]
  unsigned __int64 v27; // [rsp+18h] [rbp-10h]

  v12 = *a3;
  v27 = __readfsqword(0x28u);
  LODWORD(v14) = 0;
  v23 = (const char *)a3;
  v25 = 1;
  if ( v12 )
  {
    v15 = a3[1];
    if ( v15 )
    {
      v16 = v15;
      v17 = a3[2];
      v14 = 16 * v12 + v16;
      if ( (_BYTE)v17 )
      {
        v14 = v17 + 16 * v14;
        v18 = a3[3];
        if ( (_BYTE)v18 )
        {
          v14 = v18 + 16 * v14;
          v19 = a3[4];
          if ( (_BYTE)v19 )
          {
            v14 = v19 + 16 * v14;
            v20 = a3 + 5;
            v21 = a3[5];
            if ( (_BYTE)v21 )
            {
              do
              {
                ++v20;
                v14 = ((v21 + 16 * v14) >> 24) & 0xF0 ^ (v21 + 16 * v14);
                v21 = *v20;
              }
              while ( (_BYTE)v21 );
              LODWORD(v14) = v14 & 0xFFFFFFF;
            }
          }
        }
      }
    }
    else
    {
      LODWORD(v14) = (unsigned __int8)v12;
    }
  }
  v24 = v14;
  v26 = 0LL;
  return do_sym(a1, a2, a4, &v23, 0, a5, a6, a7, a8, a9, a10, a11, a12);
}

//----- (0000000000479060) ----------------------------------------------------
__int64 (*__fastcall dl_sym(
        __int64 a1,
        unsigned __int8 *a2,
        unsigned __int64 a3,
        double a4,
        double a5,
        double a6,
        double a7,
        double a8,
        double a9,
        double a10,
        double a11))(void)
{
  return do_sym(a1, a2, a3, 0LL, 2, a4, a5, a6, a7, a8, a9, a10, a11);
}

//----- (0000000000479080) ----------------------------------------------------
unsigned __int64 __fastcall _unordtf2(__m128 a1, __m128 a2)
{
  unsigned __int64 v2; // r9
  unsigned __int64 v3; // rsi
  __int64 v4; // rdx
  unsigned __int64 result; // rax
  int v6; // edi
  unsigned __int64 v7; // [rsp+0h] [rbp-38h]

  _mm_getcsr();
  v2 = a1.m128_u64[1] & 0xFFFFFFFFFFFFLL;
  v3 = a2.m128_u64[1] & 0xFFFFFFFFFFFFLL;
  v4 = a2.m128_i16[7] & 0x7FFF;
  result = a1.m128_i16[7] & 0x7FFF;
  if ( (a1.m128_i16[7] & 0x7FFF) == 0 )
  {
    if ( a1.m128_u64[0] | v2 )
    {
      v6 = 2;
      if ( v4 != 0x7FFF )
      {
LABEL_4:
        v7 = result;
        _sfp_handle_exceptions(v6);
        return v7;
      }
    }
    else
    {
      if ( (a2.m128_i16[7] & 0x7FFF) == 0 )
      {
        if ( a2.m128_u64[0] | v3 )
        {
          LOBYTE(v6) = 2;
          goto LABEL_4;
        }
        v6 = 0;
        goto LABEL_23;
      }
      if ( v4 != 0x7FFF )
        return result;
      v6 = 0;
    }
    goto LABEL_9;
  }
  if ( (a2.m128_i16[7] & 0x7FFF) != 0 )
  {
    v6 = 0;
    if ( result != 0x7FFF )
    {
      if ( v4 != 0x7FFF )
        return 0LL;
LABEL_9:
      if ( a2.m128_u64[0] | v3 )
      {
        if ( result != 0x7FFF )
          goto LABEL_11;
        goto LABEL_29;
      }
      goto LABEL_23;
    }
  }
  else
  {
    v6 = 2 * ((a2.m128_u64[0] | v3) != 0);
    if ( result != 0x7FFF )
      goto LABEL_23;
  }
  if ( a1.m128_u64[0] | v2 )
  {
    if ( (a1.m128_u64[1] & 0x800000000000LL) == 0 )
      goto LABEL_12;
    if ( v4 != 0x7FFF )
      goto LABEL_18;
LABEL_30:
    if ( !(v3 | a2.m128_u64[0]) )
    {
LABEL_18:
      result = 1LL;
      goto LABEL_24;
    }
LABEL_11:
    if ( (a2.m128_u64[1] & 0x800000000000LL) == 0 )
    {
LABEL_12:
      LOBYTE(v6) = v6 | 1;
      result = 1LL;
      goto LABEL_4;
    }
    goto LABEL_18;
  }
  if ( v4 == 0x7FFF && a2.m128_u64[0] | v3 )
  {
LABEL_29:
    if ( v2 | a1.m128_u64[0] && (a1.m128_u64[1] & 0x800000000000LL) == 0 )
      goto LABEL_12;
    goto LABEL_30;
  }
LABEL_23:
  result = 0LL;
LABEL_24:
  if ( v6 )
    goto LABEL_4;
  return result;
}

//----- (0000000000479220) ----------------------------------------------------
__int64 __fastcall _lttf2(__m128 a1, __m128 a2)
{
  unsigned __int64 v2; // r9
  unsigned __int64 v3; // r11
  unsigned __int64 v4; // rsi
  __int64 result; // rax
  __int64 v6; // rcx
  __int64 v7; // rdi
  int v8; // er10
  unsigned __int64 v9; // rbx
  unsigned __int64 v10; // [rsp+0h] [rbp-48h]

  _mm_getcsr();
  v2 = a1.m128_u64[1] >> 63;
  v3 = a1.m128_u64[1] & 0xFFFFFFFFFFFFLL;
  v4 = a2.m128_u64[1] & 0xFFFFFFFFFFFFLL;
  result = a2.m128_u64[1] >> 63;
  v6 = a2.m128_i16[7] & 0x7FFF;
  v7 = a1.m128_i16[7] & 0x7FFF;
  if ( (a1.m128_i16[7] & 0x7FFF) == 0 )
  {
    if ( a1.m128_u64[0] | v3 )
    {
      v8 = 2;
    }
    else
    {
      v8 = 0;
      if ( (a2.m128_i16[7] & 0x7FFF) == 0 )
      {
        v9 = a1.m128_u64[0] | v3;
        v8 = 2 * ((a2.m128_u64[0] | v4) != 0);
LABEL_6:
        if ( !(a2.m128_u64[0] | v4) )
        {
          result = 0LL;
          if ( !v9 )
            goto LABEL_19;
          goto LABEL_18;
        }
LABEL_28:
        if ( !v9 )
        {
          if ( a2.m128_i64[1] < 0 )
            goto LABEL_19;
          goto LABEL_30;
        }
        if ( v2 != result )
          goto LABEL_18;
        goto LABEL_35;
      }
    }
    if ( v6 != 0x7FFF )
    {
LABEL_5:
      v9 = a1.m128_u64[0] | v3;
      if ( (a2.m128_i16[7] & 0x7FFF) != 0 )
        goto LABEL_28;
      goto LABEL_6;
    }
    goto LABEL_13;
  }
  if ( (a2.m128_i16[7] & 0x7FFF) != 0 )
  {
    v8 = 0;
    if ( v7 != 0x7FFF )
    {
      if ( v6 != 0x7FFF )
        goto LABEL_17;
      goto LABEL_13;
    }
  }
  else
  {
    v8 = 2 * ((a2.m128_u64[0] | v4) != 0);
    if ( v7 != 0x7FFF )
    {
LABEL_14:
      if ( (a1.m128_i16[7] & 0x7FFF) == 0 )
        goto LABEL_5;
      goto LABEL_15;
    }
  }
  if ( a1.m128_u64[0] | v3 )
    goto LABEL_21;
  if ( v6 == 0x7FFF )
  {
LABEL_13:
    if ( !(a2.m128_u64[0] | v4) )
      goto LABEL_14;
LABEL_21:
    LOBYTE(v8) = v8 | 1;
    result = 2LL;
    goto LABEL_22;
  }
LABEL_15:
  if ( (a2.m128_i16[7] & 0x7FFF) == 0 && !(a2.m128_u64[0] | v4) )
    goto LABEL_18;
LABEL_17:
  if ( v2 != result )
    goto LABEL_18;
  if ( v7 <= v6 )
  {
LABEL_35:
    if ( v7 < v6 )
    {
LABEL_42:
      result = -1LL;
      if ( a1.m128_i64[1] < 0 )
        result = a1.m128_u64[1] >> 63;
      goto LABEL_19;
    }
    if ( v3 <= v4 && (a1.m128_u64[0] <= a2.m128_u64[0] || v3 != v4) )
    {
      if ( v3 >= v4 && (a1.m128_u64[0] >= a2.m128_u64[0] || v3 != v4) )
      {
        result = 0LL;
        goto LABEL_19;
      }
      goto LABEL_42;
    }
LABEL_18:
    result = v2 == 0 ? 1LL : -1LL;
    goto LABEL_19;
  }
  if ( a2.m128_i64[1] < 0 )
  {
LABEL_30:
    result = -1LL;
    goto LABEL_19;
  }
  result = 1LL;
LABEL_19:
  if ( v8 )
  {
LABEL_22:
    v10 = result;
    _sfp_handle_exceptions(v8);
    return v10;
  }
  return result;
}

//----- (0000000000479460) ----------------------------------------------------
void __fastcall _sfp_handle_exceptions(char a1)
{
  __int16 v2; // [rsp+Ch] [rbp-24h]

  if ( (a1 & 2) != 0 )
  {
    __asm { fnstenv byte ptr [rsp+var_28] }
    v2 |= 2u;
    __asm { fldenv  byte ptr [rsp+var_28] }
  }
  if ( (a1 & 8) != 0 )
  {
    __asm { fnstenv byte ptr [rsp+var_28] }
    v2 |= 8u;
    __asm { fldenv  byte ptr [rsp+var_28] }
  }
  if ( (a1 & 0x10) != 0 )
  {
    __asm
    {
      fnstenv byte ptr [rsp+var_28]
      fldenv  byte ptr [rsp+var_28]
    }
  }
}

//----- (00000000004794F0) ----------------------------------------------------
_QWORD *__fastcall read_encoded_value_with_base(char a1, __int64 a2, __int64 a3, _QWORD *a4)
{
  __int64 *v4; // rax
  __int64 v5; // r8
  _QWORD *result; // rax

  if ( a1 != 80 )
  {
    if ( (a1 & 0xFu) <= 0xC )
      __asm { jmp     rax }
    read_encoded_value_with_base_cold_5();
  }
  v4 = (__int64 *)((a3 + 7) & 0xFFFFFFFFFFFFFFF8LL);
  v5 = *v4;
  result = v4 + 1;
  *a4 = v5;
  return result;
}
// 4015A0: using guessed type void __noreturn read_encoded_value_with_base_cold_5(void);

//----- (0000000000479640) ----------------------------------------------------
__int64 __fastcall base_of_encoded_value(char a1, _QWORD *a2, __int64 a3, __int64 a4, u32 *a5, u32 a6)
{
  __int64 v6; // rdi

  if ( a1 == -1 )
    return 0LL;
  v6 = a1 & 0x70;
  if ( (_BYTE)v6 == 32 )
    return a2[21];
  if ( (unsigned __int8)v6 <= 0x20u )
  {
    if ( (_BYTE)v6 && (_BYTE)v6 != 16 )
      goto LABEL_13;
    return 0LL;
  }
  if ( (_BYTE)v6 != 64 )
  {
    if ( (_BYTE)v6 != 80 )
    {
      if ( (_BYTE)v6 == 48 )
        return a2[22];
LABEL_13:
      abort(v6, (__int64)a2, a3, a4, a5, a6);
    }
    return 0LL;
  }
  return a2[23];
}

//----- (00000000004796A0) ----------------------------------------------------
void __fastcall execute_cfa_program(_BYTE *a1, unsigned __int64 a2, __int64 a3, _QWORD *a4)
{
  unsigned __int64 v6; // rax
  unsigned __int64 v7; // rdx
  unsigned __int64 v8; // r14
  __int64 v9; // rax
  unsigned __int8 v10; // al
  unsigned __int8 v11; // al
  int v12; // ecx
  __int64 v13; // rbx
  unsigned __int64 v14; // rdx
  __int64 v15; // rbx
  __int64 *v16; // r11

  a4[36] = 0LL;
  if ( (unsigned __int64)a1 < a2 )
  {
    v6 = *(_QWORD *)(a3 + 192);
    v7 = a4[41];
    if ( v7 < *(_QWORD *)(a3 + 152) + (v6 >> 63) )
    {
      v8 = a2;
      do
      {
        v9 = (unsigned __int8)*a1;
        switch ( *a1 & 0xC0 )
        {
          case 64:
            ++a1;
            a4[41] = v7 + a4[44] * (v9 & 0x3F);
            break;
          case 128:
            v11 = v9 & 0x3F;
            ++a1;
            v12 = 0;
            v13 = 0LL;
            do
            {
              a2 = (unsigned __int8)*a1++;
              v14 = (unsigned __int64)(*(a1 - 1) & 0x7F) << v12;
              v12 += 7;
              v13 |= v14;
            }
            while ( (a2 & 0x80u) != 0LL );
            v15 = a4[43] * v13;
            if ( v11 <= 0x11u )
            {
              v16 = &a4[2 * v11];
              *((_DWORD *)v16 + 2) = 1;
              *v16 = v15;
            }
            break;
          case -64:
            v10 = v9 & 0x3F;
            ++a1;
            if ( v10 <= 0x11u )
              LODWORD(a4[2 * v10 + 1]) = 0;
            break;
          default:
            if ( (unsigned __int8)v9 <= 0x2Fu )
              __asm { jmp     rax }
            execute_cfa_program_cold_6(a1, a2, v7, *a1 & 0xC0, 0LL, 336LL);
        }
        if ( v8 <= (unsigned __int64)a1 )
          break;
        v7 = a4[41];
      }
      while ( v7 < *(_QWORD *)(a3 + 152) + (*(_QWORD *)(a3 + 192) >> 63) );
    }
  }
}
// 4015A5: using guessed type void __fastcall __noreturn execute_cfa_program_cold_6(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (000000000047A030) ----------------------------------------------------
void init_dwarf_reg_size_table()
{
  memset(dwarf_reg_size_table, 8, 17);
}

//----- (000000000047A0B0) ----------------------------------------------------
__int64 __fastcall uw_frame_state_for(_QWORD *a1, char *a2, __int64 a3, __int64 a4, u32 *a5, __int64 a6)
{
  unsigned __int64 v7; // rdx
  unsigned int *FDE; // rax
  unsigned int *v10; // r14
  unsigned int *v11; // r15
  char *v12; // r12
  __int64 v13; // rax
  unsigned __int8 v14; // di
  char v15; // si
  __int64 v16; // r9
  int v17; // ecx
  unsigned __int64 v18; // rdx
  unsigned int v19; // ecx
  __int64 v20; // r9
  char *v21; // rbx
  unsigned __int64 v22; // rdx
  __int64 v23; // rsi
  __int64 v24; // rcx
  __int64 v25; // rdx
  unsigned __int64 v26; // rax
  char v27; // al
  u32 *v28; // r8
  char *v29; // r12
  char v30; // al
  __int64 v31; // rdx
  char v32; // al
  __int64 v33; // rax
  char *encoded_value_with_base; // rax
  __int64 v35; // rdi
  __int64 v36; // rsi
  __int64 v37; // rdx
  __int64 v38; // rcx
  u32 *v39; // r8
  u32 v40; // er9
  char v41; // al
  unsigned __int8 v42; // al
  __int64 v43; // rbx
  unsigned int *v44; // rbx
  char v45; // di
  __int64 v46; // rsi
  unsigned __int64 v47; // rax
  unsigned int *v48; // r12
  unsigned int *v49; // rax
  __int64 result; // rax
  __int64 v51; // rax
  unsigned __int64 v52; // rax
  __int64 v53; // rax
  __int64 v54; // rax
  __int64 v55; // rdx
  __int64 v56; // rcx
  char v57; // [rsp+Ch] [rbp-5Ch]
  u32 *v58; // [rsp+10h] [rbp-58h]
  __int64 v59[8]; // [rsp+28h] [rbp-40h] BYREF

  memset(a2, 0, 0x180uLL);
  a1[26] = 0LL;
  a1[20] = 0LL;
  v7 = a1[19];
  if ( !v7 )
    return 5LL;
  FDE = Unwind_Find_FDE(v7 + (a1[24] >> 63) - 1, a1 + 21, v7, 0LL, a5, a6);
  v10 = FDE;
  if ( FDE )
  {
    *((_QWORD *)a2 + 41) = a1[23];
    v11 = (unsigned int *)((char *)FDE - (int)FDE[1] + 4);
    v12 = (char *)v11 + 9;
    v13 = (__int64)v11 + j_strlen_ifunc((char *)v11 + 9) + 10;
    if ( *(_WORD *)((char *)v11 + 9) == 26725 )
    {
      v31 = *(_QWORD *)v13;
      v12 = (char *)v11 + 11;
      v13 += 8LL;
      *((_QWORD *)a2 + 47) = v31;
    }
    v14 = *((_BYTE *)v11 + 8);
    v15 = *(_BYTE *)v13;
    if ( v14 > 3u )
    {
      if ( v15 != 8 || *(_BYTE *)(v13 + 1) )
        return 3LL;
      v15 = *(_BYTE *)(v13 + 2);
      v13 += 2LL;
    }
    v16 = 0LL;
    v17 = 0;
    while ( 1 )
    {
      ++v13;
      v18 = (unsigned __int64)(v15 & 0x7F) << v17;
      v17 += 7;
      v16 |= v18;
      if ( v15 >= 0 )
        break;
      v15 = *(_BYTE *)v13;
    }
    *((_QWORD *)a2 + 44) = v16;
    v19 = 0;
    v20 = 0LL;
    while ( 1 )
    {
      v21 = (char *)(v13 + 1);
      v22 = (unsigned __int64)(*(_BYTE *)v13 & 0x7F) << v19;
      v19 += 7;
      v20 |= v22;
      if ( *(char *)v13 >= 0 )
        break;
      ++v13;
    }
    if ( v19 <= 0x3F && (*(_BYTE *)v13 & 0x40) != 0 )
      v20 |= -1LL << v19;
    *((_QWORD *)a2 + 43) = v20;
    v23 = 0LL;
    v24 = 0LL;
    if ( v14 == 1 )
    {
      v25 = (unsigned __int8)*v21;
      v21 = (char *)(v13 + 2);
      *((_QWORD *)a2 + 45) = v25;
    }
    else
    {
      do
      {
        v25 = (unsigned __int8)*v21++;
        v26 = (unsigned __int64)(*(v21 - 1) & 0x7F) << v24;
        v24 = (unsigned int)(v24 + 7);
        v23 |= v26;
      }
      while ( (v25 & 0x80u) != 0LL );
      *((_QWORD *)a2 + 45) = v23;
    }
    a2[369] = -1;
    v27 = *v12;
    v28 = 0LL;
    if ( *v12 == 122 )
    {
      v20 = 0LL;
      LODWORD(v24) = 0;
      do
      {
        v25 = (unsigned __int8)*v21++;
        v52 = (unsigned __int64)(*(v21 - 1) & 0x7F) << v24;
        v24 = (unsigned int)(v24 + 7);
        v20 |= v52;
      }
      while ( (v25 & 0x80u) != 0LL );
      a2[370] = 1;
      v28 = (u32 *)&v21[v20];
      v27 = *++v12;
    }
    v29 = v12 + 1;
    while ( v27 )
    {
      switch ( v27 )
      {
        case 'L':
          v30 = *v21++;
          a2[369] = v30;
          break;
        case 'R':
          v32 = *v21++;
          a2[368] = v32;
          break;
        case 'P':
          v58 = v28;
          v57 = *v21;
          v33 = base_of_encoded_value(*v21, a1, v25, v24, v28, v20);
          encoded_value_with_base = (char *)read_encoded_value_with_base(v57, v33, (__int64)(v21 + 1), v59);
          v28 = v58;
          v21 = encoded_value_with_base;
          *((_QWORD *)a2 + 42) = v59[0];
          break;
        case 'S':
          a2[371] = 1;
          break;
        default:
          goto LABEL_52;
      }
      v27 = *v29++;
    }
    if ( !v28 )
    {
      v28 = (u32 *)v21;
LABEL_52:
      if ( !v28 )
        return 3LL;
    }
    v35 = (__int64)v28;
    v36 = (__int64)v11 + *v11 + 4;
    execute_cfa_program(v28, v36, (__int64)a1, a2);
    v41 = a2[368];
    if ( v41 == -1 )
    {
      v43 = 2LL;
    }
    else
    {
      v42 = v41 & 7;
      if ( v42 != 2 )
      {
        if ( v42 <= 2u )
        {
          if ( !v42 )
          {
LABEL_48:
            v43 = 6LL;
            goto LABEL_36;
          }
        }
        else
        {
          v43 = 4LL;
          if ( v42 == 3 )
            goto LABEL_36;
          if ( v42 == 4 )
            goto LABEL_48;
        }
        abort(v35, v36, v37, v38, v39, v40);
      }
      v43 = 3LL;
    }
LABEL_36:
    v44 = &v10[v43];
    v45 = a2[369];
    if ( a2[370] )
    {
      v46 = 0LL;
      LODWORD(v38) = 0;
      do
      {
        v44 = (unsigned int *)((char *)v44 + 1);
        v37 = *((unsigned __int8 *)v44 - 1);
        v47 = (unsigned __int64)(*((_BYTE *)v44 - 1) & 0x7F) << v38;
        v38 = (unsigned int)(v38 + 7);
        v46 |= v47;
      }
      while ( (v37 & 0x80u) != 0LL );
      v48 = (unsigned int *)((char *)v44 + v46);
      v49 = v44;
      if ( v45 == -1 )
      {
LABEL_40:
        if ( v48 )
          v49 = v48;
        v44 = v49;
        goto LABEL_43;
      }
    }
    else
    {
      if ( v45 == -1 )
      {
LABEL_43:
        execute_cfa_program(v44, (unsigned __int64)v10 + *v10 + 4, (__int64)a1, a2);
        return 0LL;
      }
      v48 = 0LL;
    }
    v51 = base_of_encoded_value(v45, a1, v37, v38, v39, v40);
    v49 = (unsigned int *)read_encoded_value_with_base(v45, v51, (__int64)v44, v59);
    a1[20] = v59[0];
    goto LABEL_40;
  }
  v53 = a1[19];
  if ( *(_BYTE *)v53 != 72 || *(_QWORD *)(v53 + 1) != 0x50F0000000FC0C7LL )
    return 5LL;
  v54 = a1[18];
  v55 = *(_QWORD *)(v54 + 160);
  *((_DWORD *)a2 + 80) = 1;
  *((_QWORD *)a2 + 38) = 7LL;
  *((_DWORD *)a2 + 2) = 1;
  *(_QWORD *)a2 = v54 + 144 - v55;
  *((_QWORD *)a2 + 37) = v55 - v54;
  *((_QWORD *)a2 + 2) = v54 + 136 - v55;
  *((_QWORD *)a2 + 16) = v54 + 40 - v55;
  *((_QWORD *)a2 + 4) = v54 + 152 - v55;
  *((_QWORD *)a2 + 18) = v54 + 48 - v55;
  *((_QWORD *)a2 + 6) = v54 + 128 - v55;
  *((_QWORD *)a2 + 20) = v54 + 56 - v55;
  *((_QWORD *)a2 + 8) = v54 + 112 - v55;
  *((_QWORD *)a2 + 22) = v54 + 64 - v55;
  *((_QWORD *)a2 + 10) = v54 + 104 - v55;
  *((_QWORD *)a2 + 24) = v54 + 72 - v55;
  *((_DWORD *)a2 + 6) = 1;
  *((_QWORD *)a2 + 26) = v54 + 80 - v55;
  *((_DWORD *)a2 + 10) = 1;
  *((_DWORD *)a2 + 14) = 1;
  *((_DWORD *)a2 + 18) = 1;
  *((_DWORD *)a2 + 22) = 1;
  *((_DWORD *)a2 + 26) = 1;
  *((_QWORD *)a2 + 12) = v54 + 120 - v55;
  *((_DWORD *)a2 + 34) = 1;
  *((_DWORD *)a2 + 38) = 1;
  *((_DWORD *)a2 + 42) = 1;
  *((_DWORD *)a2 + 46) = 1;
  *((_DWORD *)a2 + 50) = 1;
  *((_DWORD *)a2 + 54) = 1;
  *((_DWORD *)a2 + 58) = 1;
  *((_QWORD *)a2 + 28) = v54 + 88 - v55;
  v56 = v54 + 96 - v55;
  *((_DWORD *)a2 + 62) = 1;
  *((_QWORD *)a2 + 32) = v54 + 168 - v55;
  result = 0LL;
  *((_QWORD *)a2 + 30) = v56;
  *((_DWORD *)a2 + 66) = 1;
  *((_QWORD *)a2 + 45) = 16LL;
  a2[371] = 1;
  return result;
}
// 47A2E4: variable 'v25' is possibly undefined
// 47A2E4: variable 'v24' is possibly undefined
// 47A2E4: variable 'v20' is possibly undefined
// 47A3FB: variable 'v37' is possibly undefined
// 47A3FB: variable 'v38' is possibly undefined
// 47A3FB: variable 'v39' is possibly undefined
// 47A3FB: variable 'v40' is possibly undefined
// 4010C8: using guessed type __int64 __fastcall j_strlen_ifunc(_QWORD);

//----- (000000000047A6E0) ----------------------------------------------------
__int64 __fastcall execute_stack_op(unsigned __int8 *a1, unsigned __int64 a2, __int64 a3, __int64 a4)
{
  __int64 v4; // rdx

  if ( (unsigned __int64)a1 < a2 )
  {
    v4 = *a1;
    if ( (unsigned __int8)(v4 - 3) <= 0xEEu )
      __asm { jmp     rax }
    abort((__int64)a1, (__int64)(a1 + 1), v4, a4, (u32 *)dwarf_reg_size_table, (u32)&unk_499318);
  }
  return a4;
}

//----- (000000000047AEB0) ----------------------------------------------------
__int64 __fastcall uw_update_context_1(const __m128i *a1, __int64 a2, __int64 a3, __int64 a4, u32 *a5, u32 a6)
{
  __int64 v7; // rax
  int v8; // eax
  __int64 v9; // rax
  _QWORD *v10; // r10
  __int64 v11; // r12
  __int64 v12; // rsi
  int v13; // ecx
  unsigned __int8 *v14; // rdi
  unsigned __int64 v15; // rax
  __int64 v16; // r15
  __int64 i; // rbx
  __int64 result; // rax
  __int64 v20; // [rsp+18h] [rbp-130h] BYREF
  __int128 v21[3]; // [rsp+20h] [rbp-128h] BYREF
  __m128i si128; // [rsp+50h] [rbp-F8h]
  __m128i v23; // [rsp+60h] [rbp-E8h]
  __m128i v24; // [rsp+70h] [rbp-D8h]
  __m128i v25; // [rsp+80h] [rbp-C8h]
  __m128i v26; // [rsp+90h] [rbp-B8h]
  __m128i v27; // [rsp+A0h] [rbp-A8h]
  __m128i v28; // [rsp+B0h] [rbp-98h]
  __m128i v29; // [rsp+C0h] [rbp-88h]
  __m128i v30; // [rsp+D0h] [rbp-78h]
  __m128i v31; // [rsp+E0h] [rbp-68h]
  __int128 v32[5]; // [rsp+F0h] [rbp-58h]

  v21[0] = (__int128)_mm_load_si128(a1);
  v21[1] = (__int128)_mm_load_si128(a1 + 1);
  v21[2] = (__int128)_mm_load_si128(a1 + 2);
  si128 = _mm_load_si128(a1 + 3);
  v23 = _mm_load_si128(a1 + 4);
  v24 = _mm_load_si128(a1 + 5);
  v25 = _mm_load_si128(a1 + 6);
  v26 = _mm_load_si128(a1 + 7);
  v27 = _mm_load_si128(a1 + 8);
  v28 = _mm_load_si128(a1 + 9);
  v29 = _mm_load_si128(a1 + 10);
  v30 = _mm_load_si128(a1 + 11);
  v7 = a1[12].m128i_i64[0];
  v31 = _mm_load_si128(a1 + 12);
  v32[0] = (__int128)_mm_load_si128(a1 + 13);
  v32[1] = (__int128)_mm_load_si128(a1 + 14);
  if ( ((v7 & 0x4000000000000000LL) == 0 || !HIBYTE(v32[0])) && !si128.m128i_i64[1] )
  {
    if ( byte_4AB1C7 != 8 )
      goto LABEL_29;
    v20 = a1[9].m128i_i64[0];
    if ( (v31.m128i_i8[7] & 0x40) != 0 )
      HIBYTE(v32[0]) = 0;
    si128.m128i_i64[1] = (__int64)&v20;
  }
  if ( (a1[12].m128i_i8[7] & 0x40) != 0 )
    a1[13].m128i_i8[15] = 0;
  a1[3].m128i_i64[1] = 0LL;
  v8 = *(_DWORD *)(a2 + 320);
  if ( v8 == 1 )
  {
    v9 = *(_QWORD *)(a2 + 304);
    if ( (int)v9 <= 17 )
    {
      a3 = (unsigned __int8)dwarf_reg_size_table[(int)v9];
      v10 = (_QWORD *)*((_QWORD *)v21 + (int)v9);
      if ( (v31.m128i_i8[7] & 0x40) != 0 && *((_BYTE *)v32 + (int)v9 + 8) )
        goto LABEL_12;
      if ( (_BYTE)a3 == 8 )
      {
        v10 = (_QWORD *)*v10;
LABEL_12:
        v11 = (__int64)v10 + *(_QWORD *)(a2 + 296);
        goto LABEL_17;
      }
    }
LABEL_29:
    uw_update_context_1_cold_8(a1, a2, a3, a4, a5);
  }
  if ( v8 != 2 )
    abort((__int64)a1, a2, a3, a4, a5, a6);
  v12 = 0LL;
  v13 = 0;
  v14 = *(unsigned __int8 **)(a2 + 312);
  do
  {
    v15 = (unsigned __int64)(*v14++ & 0x7F) << v13;
    v13 += 7;
    v12 |= v15;
  }
  while ( (*(v14 - 1) & 0x80u) != 0 );
  v11 = execute_stack_op(v14, (unsigned __int64)&v14[v12], (__int64)v21, 0LL);
LABEL_17:
  a1[9].m128i_i64[0] = v11;
  v16 = a2;
  for ( i = 0LL; i != 18; ++i )
  {
    if ( *(_DWORD *)(v16 + 8) <= 5u )
      __asm { jmp     rax }
    v16 += 16LL;
  }
  result = a1[12].m128i_i64[0] & 0x7FFFFFFFFFFFFFFFLL;
  if ( *(_BYTE *)(a2 + 371) )
    result = a1[12].m128i_i64[0] | 0x8000000000000000LL;
  a1[12].m128i_i64[0] = result;
  return result;
}
// 4015AF: using guessed type void __fastcall __noreturn uw_update_context_1_cold_8(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 4AB1C7: using guessed type char byte_4AB1C7;

//----- (000000000047B2A0) ----------------------------------------------------
__int64 __fastcall uw_init_context_1(__m128i *a1, __int64 a2, __int64 a3, __int64 a4, u32 *a5, __int64 a6)
{
  __int64 v7; // rdx
  __int64 v8; // rcx
  u32 *v9; // r8
  u32 v10; // er9
  __int64 result; // rax
  __int64 v12; // [rsp+8h] [rbp-1B0h] BYREF
  char v13[296]; // [rsp+10h] [rbp-1A8h] BYREF
  __int64 v14; // [rsp+138h] [rbp-80h]
  __int64 v15; // [rsp+140h] [rbp-78h]
  int v16; // [rsp+150h] [rbp-68h]
  __int64 retaddr; // [rsp+1B8h] [rbp+0h]

  memset(a1, 0, 0xF0uLL);
  a1[9].m128i_i64[1] = retaddr;
  a1[12].m128i_i64[0] = 0x4000000000000000LL;
  if ( (unsigned int)uw_frame_state_for(a1, v13, a3, 0LL, a5, a6) )
    goto LABEL_9;
  if ( !dwarf_reg_size_table[0] )
    memset(dwarf_reg_size_table, 8, 17);
  if ( byte_4AB1C7 != 8 )
LABEL_9:
    uw_init_context_1_cold_9();
  v12 = a2;
  if ( (a1[12].m128i_i8[7] & 0x40) != 0 )
    a1[13].m128i_i8[15] = 0;
  v16 = 1;
  a1[3].m128i_i64[1] = (__int64)&v12;
  v15 = 7LL;
  v14 = 0LL;
  result = uw_update_context_1(a1, (__int64)v13, v7, v8, v9, v10);
  a1[9].m128i_i64[1] = a3;
  return result;
}
// 47B371: variable 'v7' is possibly undefined
// 47B371: variable 'v8' is possibly undefined
// 47B371: variable 'v9' is possibly undefined
// 47B371: variable 'v10' is possibly undefined
// 4015B4: using guessed type void __noreturn uw_init_context_1_cold_9(void);
// 4AB1C7: using guessed type char byte_4AB1C7;

//----- (000000000047B420) ----------------------------------------------------
__int64 __fastcall uw_update_context(const __m128i *a1, __int64 a2, __int64 a3, __int64 a4, u32 *a5, u32 a6)
{
  __int64 result; // rax
  _QWORD *v7; // rdx

  uw_update_context_1(a1, a2, a3, a4, a5, a6);
  result = *(_QWORD *)(a2 + 360);
  if ( *(_DWORD *)(a2 + 16 * result + 8) == 6 )
  {
    a1[9].m128i_i64[1] = 0LL;
    return result;
  }
  if ( (int)result > 17 )
    goto LABEL_3;
  result = (int)result;
  v7 = (_QWORD *)a1->m128i_i64[(int)result];
  if ( (a1[12].m128i_i8[7] & 0x40) != 0 && a1[13].m128i_i8[(int)result + 8] )
    goto LABEL_8;
  if ( dwarf_reg_size_table[(int)result] != 8 )
LABEL_3:
    uw_update_context_cold_10();
  v7 = (_QWORD *)*v7;
LABEL_8:
  a1[9].m128i_i64[1] = (__int64)v7;
  return result;
}
// 4015B9: using guessed type void __noreturn uw_update_context_cold_10(void);

//----- (000000000047B4B0) ----------------------------------------------------
__int64 __fastcall Unwind_RaiseException_Phase2(_QWORD *a1, __m128i *a2, __int64 *a3, __int64 a4, u32 *a5, __int64 a6)
{
  __int64 i; // r14
  __int64 result; // rax
  __int64 v9; // rdx
  __int64 v10; // rcx
  u32 *v11; // r8
  u32 v12; // er9
  int v13; // eax
  int v14; // ebp
  char v15[336]; // [rsp+0h] [rbp-1B8h] BYREF
  __int64 (__fastcall *v16)(__int64, _QWORD, _QWORD, _QWORD *, __m128i *); // [rsp+150h] [rbp-68h]

  for ( i = 1LL; ; ++i )
  {
    v13 = uw_frame_state_for(a2, v15, (__int64)a3, a4, a5, a6);
    v9 = (unsigned __int64)a2[12].m128i_i64[0] >> 63;
    v10 = a2[9].m128i_i64[0] - v9;
    v14 = 4 * (a1[3] == v10);
    if ( v13 )
      return 2LL;
    if ( v16 )
      break;
LABEL_5:
    if ( v14 )
      Unwind_RaiseException_Phase2_cold_11();
    uw_update_context(a2, (__int64)v15, v9, v10, v11, v12);
  }
  result = v16(1LL, v14 | 2u, *a1, a1, a2);
  if ( (_DWORD)result != 7 )
  {
    if ( (_DWORD)result != 8 )
      return 2LL;
    goto LABEL_5;
  }
  *a3 = i;
  return result;
}
// 47B513: variable 'v9' is possibly undefined
// 47B513: variable 'v10' is possibly undefined
// 47B513: variable 'v11' is possibly undefined
// 47B513: variable 'v12' is possibly undefined
// 47B520: variable 'a3' is possibly undefined
// 47B520: variable 'a4' is possibly undefined
// 47B520: variable 'a5' is possibly undefined
// 47B520: variable 'a6' is possibly undefined
// 4015BE: using guessed type void __noreturn Unwind_RaiseException_Phase2_cold_11(void);

//----- (000000000047B580) ----------------------------------------------------
__int64 __fastcall Unwind_ForcedUnwind_Phase2(_QWORD *a1, __m128i *a2, __int64 *a3, __int64 a4, u32 *a5, __int64 a6)
{
  __int64 v6; // r13
  unsigned int (__fastcall *v7)(__int64, __int64, __int64, _QWORD *, __m128i *, __int64); // r14
  __int64 v8; // r15
  __int64 v9; // rdx
  __int64 v10; // rcx
  u32 *v11; // r8
  u32 v12; // er9
  unsigned int v13; // eax
  unsigned int v14; // er10
  int v15; // eax
  __int64 v16; // rdx
  unsigned int v17; // eax
  char v20[336]; // [rsp+10h] [rbp-1B8h] BYREF
  __int64 (__fastcall *v21)(__int64, __int64, _QWORD, _QWORD *, __m128i *); // [rsp+160h] [rbp-68h]

  v6 = 1LL;
  v7 = (unsigned int (__fastcall *)(__int64, __int64, __int64, _QWORD *, __m128i *, __int64))a1[2];
  v8 = a1[3];
  while ( 1 )
  {
    v15 = uw_frame_state_for(a2, v20, (__int64)a3, a4, a5, a6);
    if ( v15 && v15 != 5 )
      return 2;
    v16 = *a1;
    if ( v15 == 5 )
      break;
    if ( v7(1LL, 10LL, v16, a1, a2, v8) )
      return 2;
    if ( v21 )
    {
      v13 = v21(1LL, 10LL, *a1, a1, a2);
      v14 = v13;
      if ( v13 == 7 )
        goto LABEL_13;
      if ( v13 != 8 )
        return 2;
    }
    ++v6;
    uw_update_context(a2, (__int64)v20, v9, v10, v11, v12);
  }
  v17 = v7(1LL, 26LL, v16, a1, a2, v8);
  v14 = 5;
  if ( v17 )
    return 2;
LABEL_13:
  *a3 = v6;
  return v14;
}
// 47B60F: variable 'v9' is possibly undefined
// 47B60F: variable 'v10' is possibly undefined
// 47B60F: variable 'v11' is possibly undefined
// 47B60F: variable 'v12' is possibly undefined
// 47B61A: variable 'a3' is possibly undefined
// 47B61A: variable 'a4' is possibly undefined
// 47B61A: variable 'a5' is possibly undefined
// 47B61A: variable 'a6' is possibly undefined

//----- (000000000047B690) ----------------------------------------------------
char *__fastcall uw_install_context_1(unsigned __int64 a1, char *a2)
{
  unsigned __int64 v2; // r9
  char *v3; // r8
  __int64 v4; // rax
  char *v5; // rdx
  unsigned int v6; // ecx
  _BYTE *v7; // rdi
  signed __int64 v8; // rdx
  char *v9; // rsi
  unsigned int v10; // ecx
  char *result; // rax
  _QWORD *v12; // rax
  __int64 v13; // [rsp+8h] [rbp-10h] BYREF

  v2 = a1;
  v3 = a2;
  if ( ((a2[199] & 0x40) == 0 || !a2[223]) && !*((_QWORD *)a2 + 7) )
  {
    if ( byte_4AB1C7 != 8 )
      goto LABEL_35;
    v13 = *((_QWORD *)a2 + 18);
    if ( (a2[199] & 0x40) != 0 )
      a2[223] = 0;
    *((_QWORD *)a2 + 7) = &v13;
  }
  v4 = 0LL;
  do
  {
    while ( 1 )
    {
      v5 = *(char **)(v2 + 8 * v4);
      a2 = *(char **)&v3[8 * v4];
      if ( *(_BYTE *)(v2 + v4 + 216) )
        goto LABEL_35;
      if ( v3[v4 + 216] )
      {
        if ( v5 )
        {
          if ( dwarf_reg_size_table[v4] != 8 )
            goto LABEL_35;
          *(_QWORD *)v5 = a2;
        }
        goto LABEL_8;
      }
      LOBYTE(a1) = a2 != 0LL;
      if ( v5 != 0LL && a2 != 0LL && v5 != a2 )
        break;
LABEL_8:
      if ( ++v4 == 17 )
        goto LABEL_19;
    }
    v6 = (unsigned __int8)dwarf_reg_size_table[v4];
    if ( v6 < 8 )
    {
      if ( (v6 & 4) != 0 )
      {
        a1 = *(unsigned int *)a2;
        *(_DWORD *)v5 = a1;
        a2 = (char *)*(unsigned int *)&a2[v6 - 4];
        *(_DWORD *)&v5[v6 - 4] = (_DWORD)a2;
      }
      else if ( dwarf_reg_size_table[v4] )
      {
        a1 = (unsigned __int8)*a2;
        *v5 = a1;
        if ( (v6 & 2) != 0 )
        {
          a2 = (char *)*(unsigned __int16 *)&a2[v6 - 2];
          *(_WORD *)&v5[v6 - 2] = (_WORD)a2;
        }
      }
      goto LABEL_8;
    }
    ++v4;
    *(_QWORD *)v5 = *(_QWORD *)a2;
    *(_QWORD *)&v5[v6 - 8] = *(_QWORD *)&a2[v6 - 8];
    v7 = (_BYTE *)((unsigned __int64)(v5 + 8) & 0xFFFFFFFFFFFFFFF8LL);
    v8 = v5 - v7;
    v9 = &a2[-v8];
    v10 = ((unsigned int)v8 + v6) >> 3;
    qmemcpy(v7, v9, 8LL * v10);
    a2 = &v9[8 * v10];
    a1 = (unsigned __int64)&v7[8 * v10];
  }
  while ( v4 != 17 );
LABEL_19:
  result = 0LL;
  if ( ((*(_BYTE *)(v2 + 199) & 0x40) == 0 || !*(_BYTE *)(v2 + 223)) && !*(_QWORD *)(v2 + 56) )
  {
    v12 = (_QWORD *)*((_QWORD *)v3 + 7);
    if ( (v3[199] & 0x40) != 0 && v3[223] )
      return (char *)v12 + *((_QWORD *)v3 + 26) - *(_QWORD *)(v2 + 144);
    if ( byte_4AB1C7 == 8 )
    {
      v12 = (_QWORD *)*v12;
      return (char *)v12 + *((_QWORD *)v3 + 26) - *(_QWORD *)(v2 + 144);
    }
LABEL_35:
    uw_install_context_1_cold_12(a1, a2);
  }
  return result;
}
// 4015C3: using guessed type void __fastcall __noreturn uw_install_context_1_cold_12(_QWORD, _QWORD);
// 4AB1C7: using guessed type char byte_4AB1C7;

//----- (000000000047B850) ----------------------------------------------------
__int64 __fastcall Unwind_GetGR(__int64 a1, int a2)
{
  __int64 result; // rax

  if ( a2 > 17 )
    goto LABEL_7;
  result = *(_QWORD *)(a1 + 8LL * a2);
  if ( (*(_BYTE *)(a1 + 199) & 0x40) == 0 || !*(_BYTE *)(a1 + a2 + 216) )
  {
    if ( dwarf_reg_size_table[a2] == 8 )
      return *(_QWORD *)result;
LABEL_7:
    Unwind_GetGR_cold_13();
  }
  return result;
}
// 4015C8: using guessed type void __noreturn Unwind_GetGR_cold_13(void);

//----- (000000000047B8A0) ----------------------------------------------------
__int64 __fastcall Unwind_GetCFA(__int64 a1)
{
  return *(_QWORD *)(a1 + 144);
}

//----- (000000000047B8B0) ----------------------------------------------------
__int64 __fastcall Unwind_SetGR(__int64 a1, int a2, __int64 a3)
{
  __int64 result; // rax

  if ( a2 > 17 )
    goto LABEL_7;
  result = (unsigned __int8)dwarf_reg_size_table[a2];
  if ( (*(_BYTE *)(a1 + 199) & 0x40) == 0 || !*(_BYTE *)(a1 + a2 + 216) )
  {
    if ( (_BYTE)result == 8 )
    {
      **(_QWORD **)(a1 + 8LL * a2) = a3;
      return result;
    }
LABEL_7:
    Unwind_SetGR_cold_14();
  }
  *(_QWORD *)(a1 + 8LL * a2) = a3;
  return result;
}
// 4015CD: using guessed type void __noreturn Unwind_SetGR_cold_14(void);

//----- (000000000047B910) ----------------------------------------------------
__int64 __fastcall Unwind_GetIP(__int64 a1)
{
  return *(_QWORD *)(a1 + 152);
}

//----- (000000000047B920) ----------------------------------------------------
__int64 __fastcall Unwind_GetIPInfo(__int64 a1, _DWORD *a2)
{
  *a2 = (*(__int64 *)(a1 + 192) >> 63) & 1;
  return *(_QWORD *)(a1 + 152);
}

//----- (000000000047B940) ----------------------------------------------------
void __fastcall Unwind_SetIP(__int64 a1, __int64 a2)
{
  *(_QWORD *)(a1 + 152) = a2;
}

//----- (000000000047B950) ----------------------------------------------------
__int64 __fastcall Unwind_GetLanguageSpecificData(__int64 a1)
{
  return *(_QWORD *)(a1 + 160);
}

//----- (000000000047B960) ----------------------------------------------------
__int64 __fastcall Unwind_GetRegionStart(__int64 a1)
{
  return *(_QWORD *)(a1 + 184);
}

//----- (000000000047B970) ----------------------------------------------------
unsigned int *__fastcall Unwind_FindEnclosingFunction(
        __int64 a1,
        __int64 a2,
        unsigned __int64 a3,
        __int64 *a4,
        u32 *a5,
        __int64 a6)
{
  unsigned int *result; // rax
  _QWORD v7[5]; // [rsp+0h] [rbp-28h] BYREF

  result = Unwind_Find_FDE(a1 - 1, v7, a3, a4, a5, a6);
  if ( result )
    return (unsigned int *)v7[2];
  return result;
}

//----- (000000000047B9A0) ----------------------------------------------------
__int64 __fastcall Unwind_GetDataRelBase(__int64 a1)
{
  return *(_QWORD *)(a1 + 176);
}

//----- (000000000047B9B0) ----------------------------------------------------
__int64 __fastcall Unwind_GetTextRelBase(__int64 a1)
{
  return *(_QWORD *)(a1 + 168);
}

//----- (000000000047B9C0) ----------------------------------------------------
__int64 __fastcall _frame_state_for(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  char *v7; // rsi
  __int64 i; // rdx
  int v9; // ecx
  __int64 v10; // rax
  __int64 v12[30]; // [rsp+0h] [rbp-288h] BYREF
  char v13[296]; // [rsp+F0h] [rbp-198h] BYREF
  __int64 v14; // [rsp+218h] [rbp-70h]
  __int64 v15; // [rsp+220h] [rbp-68h]
  int v16; // [rsp+230h] [rbp-58h]
  __int64 v17; // [rsp+258h] [rbp-30h]
  __int64 v18; // [rsp+268h] [rbp-20h]

  memset(v12, 0, sizeof(v12));
  v12[19] = a1 + 1;
  v12[24] = 0x4000000000000000LL;
  if ( (unsigned int)uw_frame_state_for(v12, v13, (__int64)v12, 0LL, (u32 *)(a1 + 1), a6) || v16 == 2 )
    return 0LL;
  v7 = v13;
  for ( i = 0LL; i != 18; ++i )
  {
    while ( 1 )
    {
      v9 = *((_DWORD *)v7 + 2);
      *(_BYTE *)(a2 + i + 180) = v9;
      if ( (_BYTE)v9 == 1 || (_BYTE)v9 == 2 )
        break;
      *(_QWORD *)(a2 + 8 * i++ + 32) = 0LL;
      v7 += 16;
      if ( i == 18 )
        goto LABEL_8;
    }
    v10 = *(_QWORD *)v7;
    v7 += 16;
    *(_QWORD *)(a2 + 8 * i + 32) = v10;
  }
LABEL_8:
  *(_QWORD *)(a2 + 16) = v14;
  *(_WORD *)(a2 + 176) = v15;
  *(_WORD *)(a2 + 178) = v17;
  *(_QWORD *)(a2 + 24) = v12[26];
  *(_QWORD *)(a2 + 8) = v18;
  return a2;
}

//----- (000000000047BAE0) ----------------------------------------------------
void Unwind_DebugHook()
{
  ;
}

//----- (000000000047BAF0) ----------------------------------------------------
__int64 __fastcall Unwind_RaiseException(_QWORD *a1, __int64 a2, __int64 a3, __int64 a4, u32 *a5, __int64 a6, char a7)
{
  __int64 v7; // rax
  __int64 v8; // rdx
  __int64 v9; // rcx
  u32 *v10; // r8
  __int64 v11; // r9
  __m128i v12; // xmm1
  __m128i v13; // xmm2
  __m128i v14; // xmm3
  __m128i v15; // xmm4
  __m128i v16; // xmm5
  __m128i v17; // xmm6
  __m128i v18; // xmm7
  __m128i v19; // xmm0
  __m128i v20; // xmm1
  __m128i v21; // xmm2
  __m128i v22; // xmm3
  __m128i v23; // xmm4
  __m128i v24; // xmm5
  __m128i v25; // xmm6
  int v26; // eax
  __int64 v27; // rdx
  __int64 v28; // rcx
  u32 *v29; // r8
  __int64 v30; // r9
  __int64 result; // rax
  __m128i v32; // xmm7
  unsigned __int64 v33; // rax
  __m128i v34; // xmm0
  __m128i v35; // xmm7
  __m128i v36; // xmm1
  __m128i v37; // xmm2
  __m128i v38; // xmm3
  __int64 v39; // rcx
  __m128i v40; // xmm7
  __m128i v41; // xmm4
  __m128i v42; // xmm5
  __m128i v43; // xmm6
  __m128i v44; // xmm7
  __m128i v45; // xmm0
  __m128i v46; // xmm7
  __m128i v47; // xmm7
  __int64 v48; // rdx
  __int64 v49; // r8
  __m128i v53; // [rsp+0h] [rbp-3A0h] BYREF
  __m128i v54; // [rsp+10h] [rbp-390h] BYREF
  __m128i v55; // [rsp+20h] [rbp-380h] BYREF
  __m128i v56; // [rsp+30h] [rbp-370h] BYREF
  __m128i v57; // [rsp+40h] [rbp-360h] BYREF
  __m128i v58; // [rsp+50h] [rbp-350h] BYREF
  __m128i v59; // [rsp+60h] [rbp-340h] BYREF
  __m128i v60; // [rsp+70h] [rbp-330h] BYREF
  __m128i v61; // [rsp+80h] [rbp-320h] BYREF
  __m128i v62; // [rsp+90h] [rbp-310h] BYREF
  __m128i v63; // [rsp+A0h] [rbp-300h] BYREF
  __m128i v64; // [rsp+B0h] [rbp-2F0h] BYREF
  __m128i v65; // [rsp+C0h] [rbp-2E0h] BYREF
  __m128i v66; // [rsp+D0h] [rbp-2D0h] BYREF
  __m128i v67; // [rsp+E0h] [rbp-2C0h] BYREF
  __m128i v68; // [rsp+F0h] [rbp-2B0h] BYREF
  __m128i v69; // [rsp+100h] [rbp-2A0h]
  __m128i v70; // [rsp+110h] [rbp-290h]
  __m128i v71; // [rsp+120h] [rbp-280h]
  __m128i v72; // [rsp+130h] [rbp-270h]
  __m128i v73; // [rsp+140h] [rbp-260h]
  __m128i v74; // [rsp+150h] [rbp-250h]
  __m128i v75; // [rsp+160h] [rbp-240h]
  __m128i v76; // [rsp+170h] [rbp-230h]
  __m128i v77; // [rsp+180h] [rbp-220h]
  __m128i v78; // [rsp+190h] [rbp-210h]
  __m128i v79; // [rsp+1A0h] [rbp-200h]
  __m128i v80; // [rsp+1B0h] [rbp-1F0h]
  __m128i v81; // [rsp+1C0h] [rbp-1E0h]
  __m128i v82; // [rsp+1D0h] [rbp-1D0h]
  __int64 v83[42]; // [rsp+1E0h] [rbp-1C0h] BYREF
  __int64 (__fastcall *v84)(__int64, __int64, _QWORD, _QWORD *, __m128i *); // [rsp+330h] [rbp-70h]
  __int64 v85; // [rsp+368h] [rbp-38h]
  __int64 v86; // [rsp+370h] [rbp-30h]
  __int64 vars0; // [rsp+3A0h] [rbp+0h] BYREF
  __int64 retaddr; // [rsp+3A8h] [rbp+8h]

  v86 = a3;
  v85 = v7;
  uw_init_context_1(&v53, (__int64)&a7, retaddr, a4, a5, a6);
  v12 = _mm_load_si128(&v54);
  v13 = _mm_load_si128(&v55);
  v14 = _mm_load_si128(&v56);
  v15 = _mm_load_si128(&v57);
  v16 = _mm_load_si128(&v58);
  v68 = _mm_load_si128(&v53);
  v17 = _mm_load_si128(&v59);
  v69 = v12;
  v18 = _mm_load_si128(&v60);
  v70 = v13;
  v19 = _mm_load_si128(&v61);
  v20 = _mm_load_si128(&v62);
  v71 = v14;
  v21 = _mm_load_si128(&v63);
  v22 = _mm_load_si128(&v64);
  v72 = v15;
  v23 = _mm_load_si128(&v65);
  v73 = v16;
  v24 = _mm_load_si128(&v66);
  v74 = v17;
  v25 = _mm_load_si128(&v67);
  v75 = v18;
  v76 = v19;
  v77 = v20;
  v78 = v21;
  v79 = v22;
  v80 = v23;
  v81 = v24;
  v82 = v25;
  while ( 1 )
  {
    result = uw_frame_state_for(&v68, (char *)v83, v8, v9, v10, v11);
    if ( (_DWORD)result == 5 )
      break;
    if ( (_DWORD)result )
      return 3LL;
    if ( v84 )
    {
      v26 = v84(1LL, 1LL, *a1, a1, &v68);
      if ( v26 == 6 )
      {
        v32 = _mm_load_si128(&v53);
        v33 = v80.m128i_i64[0];
        a1[2] = 0LL;
        v34 = _mm_load_si128(&v58);
        v68 = v32;
        v35 = _mm_load_si128(&v54);
        v36 = _mm_load_si128(&v59);
        v73 = v34;
        v37 = _mm_load_si128(&v60);
        v38 = _mm_load_si128(&v61);
        v39 = v77.m128i_i64[0] - (v33 >> 63);
        v69 = v35;
        v40 = _mm_load_si128(&v55);
        v41 = _mm_load_si128(&v62);
        v42 = _mm_load_si128(&v63);
        v43 = _mm_load_si128(&v64);
        a1[3] = v39;
        v70 = v40;
        v44 = _mm_load_si128(&v56);
        v45 = _mm_load_si128(&v66);
        v74 = v36;
        v71 = v44;
        v46 = _mm_load_si128(&v57);
        v75 = v37;
        v72 = v46;
        v47 = _mm_load_si128(&v65);
        v76 = v38;
        v77 = v41;
        v78 = v42;
        v79 = v43;
        v80 = v47;
        v81 = v45;
        v82 = _mm_load_si128(&v67);
        result = Unwind_RaiseException_Phase2(a1, &v68, v83, v39, v29, v30);
        if ( (_DWORD)result == 7 )
        {
          uw_install_context_1((unsigned __int64)&v53, v68.m128i_i8);
          Unwind_DebugHook();
          __asm { rdsspq  rax }
          if ( _RAX )
          {
            _RAX = v83[0];
            _RCX = 255LL;
            while ( _RAX > 0xFF )
            {
              __asm { incsspq rcx }
              _RAX -= 255LL;
            }
            __asm { incsspq rax }
          }
          *(__int64 *)((char *)&vars0 + v48 + 8) = v49;
          return v85;
        }
        return result;
      }
      if ( v26 != 8 )
        return 3LL;
    }
    uw_update_context(&v68, (__int64)v83, v27, v28, v29, v30);
  }
  return result;
}
// 47BB21: variable 'v7' is possibly undefined
// 47BC4B: variable 'v27' is possibly undefined
// 47BC4B: variable 'v28' is possibly undefined
// 47BC4B: variable 'v29' is possibly undefined
// 47BC4B: variable 'v30' is possibly undefined
// 47BC56: variable 'v8' is possibly undefined
// 47BC56: variable 'v9' is possibly undefined
// 47BC56: variable 'v10' is possibly undefined
// 47BC56: variable 'v11' is possibly undefined
// 47BE02: variable 'v49' is possibly undefined
// 47BE02: variable 'v48' is possibly undefined

//----- (000000000047BE40) ----------------------------------------------------
__int64 __fastcall Unwind_ForcedUnwind(_QWORD *a1, __int64 a2, __int64 a3, __int64 a4, u32 *a5, __int64 a6, char a7)
{
  __int64 v7; // rax
  __m128i v9; // xmm0
  __m128i v10; // xmm1
  __m128i v11; // xmm2
  __m128i v12; // xmm3
  __m128i v13; // xmm4
  __m128i v14; // xmm5
  __m128i v15; // xmm6
  __m128i v16; // xmm7
  __m128i v17; // xmm0
  __m128i v18; // xmm1
  __m128i v19; // xmm2
  __m128i v20; // xmm3
  __m128i v21; // xmm4
  __m128i v22; // xmm5
  __m128i v23; // xmm6
  __int64 v24; // rcx
  u32 *v25; // r8
  __int64 v26; // r9
  __int64 result; // rax
  __int64 v28; // rdx
  __int64 v29; // r8
  unsigned __int64 v33; // [rsp+0h] [rbp-228h] BYREF
  __m128i v34; // [rsp+8h] [rbp-220h] BYREF
  __m128i v35; // [rsp+18h] [rbp-210h] BYREF
  __m128i v36; // [rsp+28h] [rbp-200h] BYREF
  __m128i v37; // [rsp+38h] [rbp-1F0h] BYREF
  __m128i v38; // [rsp+48h] [rbp-1E0h] BYREF
  __m128i v39; // [rsp+58h] [rbp-1D0h] BYREF
  __m128i v40; // [rsp+68h] [rbp-1C0h] BYREF
  __m128i v41; // [rsp+78h] [rbp-1B0h] BYREF
  __m128i v42; // [rsp+88h] [rbp-1A0h] BYREF
  __m128i v43; // [rsp+98h] [rbp-190h] BYREF
  __m128i v44; // [rsp+A8h] [rbp-180h] BYREF
  __m128i v45; // [rsp+B8h] [rbp-170h] BYREF
  __m128i v46; // [rsp+C8h] [rbp-160h] BYREF
  __m128i v47; // [rsp+D8h] [rbp-150h] BYREF
  __m128i v48; // [rsp+E8h] [rbp-140h] BYREF
  __m128i v49[15]; // [rsp+F8h] [rbp-130h] BYREF
  __int64 v50; // [rsp+1F0h] [rbp-38h]
  __int64 v51; // [rsp+1F8h] [rbp-30h]
  __int64 vars0; // [rsp+228h] [rbp+0h] BYREF
  __int64 retaddr; // [rsp+230h] [rbp+8h]

  v51 = a3;
  v50 = v7;
  uw_init_context_1(&v34, (__int64)&a7, retaddr, a4, a5, a6);
  v9 = _mm_load_si128(&v34);
  v10 = _mm_load_si128(&v35);
  v11 = _mm_load_si128(&v36);
  v12 = _mm_load_si128(&v37);
  a1[3] = a3;
  v13 = _mm_load_si128(&v38);
  v14 = _mm_load_si128(&v39);
  a1[2] = a2;
  v15 = _mm_load_si128(&v40);
  v49[0] = v9;
  v16 = _mm_load_si128(&v41);
  v49[1] = v10;
  v17 = _mm_load_si128(&v42);
  v18 = _mm_load_si128(&v43);
  v49[2] = v11;
  v19 = _mm_load_si128(&v44);
  v49[3] = v12;
  v20 = _mm_load_si128(&v45);
  v49[4] = v13;
  v21 = _mm_load_si128(&v46);
  v49[5] = v14;
  v22 = _mm_load_si128(&v47);
  v49[6] = v15;
  v23 = _mm_load_si128(&v48);
  v49[7] = v16;
  v49[8] = v17;
  v49[9] = v18;
  v49[10] = v19;
  v49[11] = v20;
  v49[12] = v21;
  v49[13] = v22;
  v49[14] = v23;
  result = Unwind_ForcedUnwind_Phase2(a1, v49, (__int64 *)&v33, v24, v25, v26);
  if ( (_DWORD)result == 7 )
  {
    uw_install_context_1((unsigned __int64)&v34, v49[0].m128i_i8);
    Unwind_DebugHook();
    __asm { rdsspq  rax }
    if ( _RAX )
    {
      _RAX = v33;
      if ( v33 > 0xFF )
      {
        _RCX = 255LL;
        do
        {
          __asm { incsspq rcx }
          _RAX -= 255LL;
        }
        while ( _RAX > 0xFF );
      }
      __asm { incsspq rax }
    }
    *(__int64 *)((char *)&vars0 + v28 + 8) = v29;
    return v50;
  }
  return result;
}
// 47BE69: variable 'v7' is possibly undefined
// 47BF6B: variable 'v24' is possibly undefined
// 47BF6B: variable 'v25' is possibly undefined
// 47BF6B: variable 'v26' is possibly undefined
// 47BFEA: variable 'v29' is possibly undefined
// 47BFEA: variable 'v28' is possibly undefined

//----- (000000000047C020) ----------------------------------------------------
void __fastcall __noreturn Unwind_Resume(_QWORD *a1, __int64 a2, __int64 a3, __int64 a4, u32 *a5, __int64 a6, char a7)
{
  __int64 v7; // rax
  __int64 v8; // rcx
  u32 *v9; // r8
  __int64 v10; // r9
  __m128i v11; // xmm1
  __m128i v12; // xmm2
  __m128i v13; // xmm3
  __m128i v14; // xmm4
  __m128i v15; // xmm5
  __m128i v16; // xmm6
  __m128i v17; // xmm7
  __m128i v18; // xmm0
  __m128i v19; // xmm1
  __m128i v20; // xmm2
  __m128i v21; // xmm3
  __m128i v22; // xmm4
  bool v23; // zf
  __m128i v24; // xmm5
  __m128i v25; // xmm6
  int v26; // eax
  __int64 v27; // rax
  __int64 v28; // r8
  unsigned __int64 v32; // [rsp+0h] [rbp-228h] BYREF
  __m128i v33; // [rsp+8h] [rbp-220h] BYREF
  __m128i v34; // [rsp+18h] [rbp-210h] BYREF
  __m128i v35; // [rsp+28h] [rbp-200h] BYREF
  __m128i v36; // [rsp+38h] [rbp-1F0h] BYREF
  __m128i v37; // [rsp+48h] [rbp-1E0h] BYREF
  __m128i v38; // [rsp+58h] [rbp-1D0h] BYREF
  __m128i v39; // [rsp+68h] [rbp-1C0h] BYREF
  __m128i v40; // [rsp+78h] [rbp-1B0h] BYREF
  __m128i v41; // [rsp+88h] [rbp-1A0h] BYREF
  __m128i v42; // [rsp+98h] [rbp-190h] BYREF
  __m128i v43; // [rsp+A8h] [rbp-180h] BYREF
  __m128i v44; // [rsp+B8h] [rbp-170h] BYREF
  __m128i v45; // [rsp+C8h] [rbp-160h] BYREF
  __m128i v46; // [rsp+D8h] [rbp-150h] BYREF
  __m128i v47; // [rsp+E8h] [rbp-140h] BYREF
  __m128i v48[15]; // [rsp+F8h] [rbp-130h] BYREF
  __int64 v49; // [rsp+1F0h] [rbp-38h]
  __int64 v50; // [rsp+1F8h] [rbp-30h]
  __int64 vars0; // [rsp+228h] [rbp+0h] BYREF
  __int64 retaddr; // [rsp+230h] [rbp+8h]

  v50 = a3;
  v49 = v7;
  uw_init_context_1(&v33, (__int64)&a7, retaddr, a4, a5, a6);
  v11 = _mm_load_si128(&v34);
  v12 = _mm_load_si128(&v35);
  v13 = _mm_load_si128(&v36);
  v14 = _mm_load_si128(&v37);
  v15 = _mm_load_si128(&v38);
  v48[0] = _mm_load_si128(&v33);
  v16 = _mm_load_si128(&v39);
  v48[1] = v11;
  v17 = _mm_load_si128(&v40);
  v48[2] = v12;
  v18 = _mm_load_si128(&v41);
  v19 = _mm_load_si128(&v42);
  v48[3] = v13;
  v20 = _mm_load_si128(&v43);
  v21 = _mm_load_si128(&v44);
  v48[4] = v14;
  v22 = _mm_load_si128(&v45);
  v23 = a1[2] == 0LL;
  v48[5] = v15;
  v24 = _mm_load_si128(&v46);
  v48[6] = v16;
  v25 = _mm_load_si128(&v47);
  v48[7] = v17;
  v48[8] = v18;
  v48[9] = v19;
  v48[10] = v20;
  v48[11] = v21;
  v48[12] = v22;
  v48[13] = v24;
  v48[14] = v25;
  if ( v23 )
    v26 = Unwind_RaiseException_Phase2(a1, v48, (__int64 *)&v32, v8, v9, v10);
  else
    v26 = Unwind_ForcedUnwind_Phase2(a1, v48, (__int64 *)&v32, v8, v9, v10);
  if ( v26 != 7 )
    Unwind_Resume_cold_15();
  uw_install_context_1((unsigned __int64)&v33, v48[0].m128i_i8);
  Unwind_DebugHook();
  __asm { rdsspq  rdx }
  if ( _RDX )
  {
    _RDX = v32;
    if ( v32 > 0xFF )
    {
      _RCX = 255LL;
      do
      {
        __asm { incsspq rcx }
        _RDX -= 255LL;
      }
      while ( _RDX > 0xFF );
    }
    __asm { incsspq rdx }
  }
  *(__int64 *)((char *)&vars0 + v27 + 8) = v28;
}
// 47C04A: variable 'v7' is possibly undefined
// 47C148: variable 'v8' is possibly undefined
// 47C148: variable 'v9' is possibly undefined
// 47C148: variable 'v10' is possibly undefined
// 47C1BD: variable 'v28' is possibly undefined
// 47C1BD: variable 'v27' is possibly undefined
// 4015D2: using guessed type void __noreturn Unwind_Resume_cold_15(void);

//----- (000000000047C200) ----------------------------------------------------
void __fastcall __noreturn Unwind_Resume_or_Rethrow(
        _QWORD *a1,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        u32 *a5,
        __int64 a6,
        char a7)
{
  __int64 v7; // rax
  __m128i v8; // xmm1
  __m128i v9; // xmm2
  __m128i v10; // xmm3
  __m128i v11; // xmm4
  __m128i v12; // xmm5
  __m128i v13; // xmm6
  __m128i v14; // xmm7
  __m128i v15; // xmm0
  __m128i v16; // xmm1
  __m128i v17; // xmm2
  __m128i v18; // xmm3
  __m128i v19; // xmm4
  __m128i v20; // xmm5
  __m128i v21; // xmm6
  __int64 v22; // rcx
  u32 *v23; // r8
  __int64 v24; // r9
  __int64 v25; // r8
  __int64 v26; // r9
  char v30; // [rsp-8h] [rbp-230h]
  unsigned __int64 v31; // [rsp+0h] [rbp-228h] BYREF
  __m128i v32; // [rsp+8h] [rbp-220h] BYREF
  __m128i v33; // [rsp+18h] [rbp-210h] BYREF
  __m128i v34; // [rsp+28h] [rbp-200h] BYREF
  __m128i v35; // [rsp+38h] [rbp-1F0h] BYREF
  __m128i v36; // [rsp+48h] [rbp-1E0h] BYREF
  __m128i v37; // [rsp+58h] [rbp-1D0h] BYREF
  __m128i v38; // [rsp+68h] [rbp-1C0h] BYREF
  __m128i v39; // [rsp+78h] [rbp-1B0h] BYREF
  __m128i v40; // [rsp+88h] [rbp-1A0h] BYREF
  __m128i v41; // [rsp+98h] [rbp-190h] BYREF
  __m128i v42; // [rsp+A8h] [rbp-180h] BYREF
  __m128i v43; // [rsp+B8h] [rbp-170h] BYREF
  __m128i v44; // [rsp+C8h] [rbp-160h] BYREF
  __m128i v45; // [rsp+D8h] [rbp-150h] BYREF
  __m128i v46; // [rsp+E8h] [rbp-140h] BYREF
  __m128i v47[15]; // [rsp+F8h] [rbp-130h] BYREF
  __int64 v48; // [rsp+1F0h] [rbp-38h]
  __int64 v49; // [rsp+1F8h] [rbp-30h]
  __int64 vars0; // [rsp+228h] [rbp+0h] BYREF
  __int64 retaddr; // [rsp+230h] [rbp+8h]

  v49 = a3;
  v48 = v7;
  if ( a1[2] )
  {
    uw_init_context_1(&v32, (__int64)&a7, retaddr, a4, a5, a6);
    v8 = _mm_load_si128(&v33);
    v9 = _mm_load_si128(&v34);
    v10 = _mm_load_si128(&v35);
    v11 = _mm_load_si128(&v36);
    v12 = _mm_load_si128(&v37);
    v47[0] = _mm_load_si128(&v32);
    v13 = _mm_load_si128(&v38);
    v47[1] = v8;
    v14 = _mm_load_si128(&v39);
    v47[2] = v9;
    v15 = _mm_load_si128(&v40);
    v16 = _mm_load_si128(&v41);
    v47[3] = v10;
    v17 = _mm_load_si128(&v42);
    v18 = _mm_load_si128(&v43);
    v47[4] = v11;
    v19 = _mm_load_si128(&v44);
    v47[5] = v12;
    v20 = _mm_load_si128(&v45);
    v47[6] = v13;
    v21 = _mm_load_si128(&v46);
    v47[7] = v14;
    v47[8] = v15;
    v47[9] = v16;
    v47[10] = v17;
    v47[11] = v18;
    v47[12] = v19;
    v47[13] = v20;
    v47[14] = v21;
    if ( (unsigned int)Unwind_ForcedUnwind_Phase2(a1, v47, (__int64 *)&v31, v22, v23, v24) != 7 )
      Unwind_Resume_or_Rethrow_cold_16();
    uw_install_context_1((unsigned __int64)&v32, v47[0].m128i_i8);
    Unwind_DebugHook();
    __asm { rdsspq  rax }
    if ( _RAX )
    {
      _RAX = v31;
      if ( v31 > 0xFF )
      {
        _RDX = 255LL;
        do
        {
          __asm { incsspq rdx }
          _RAX -= 255LL;
        }
        while ( _RAX > 0xFF );
      }
      __asm { incsspq rax }
    }
    *(__int64 *)((char *)&vars0 + v25 + 8) = v26;
  }
  else
  {
    Unwind_RaiseException(a1, a2, a3, a4, a5, a6, v30);
  }
}
// 47C215: variable 'v7' is possibly undefined
// 47C328: variable 'v22' is possibly undefined
// 47C328: variable 'v23' is possibly undefined
// 47C328: variable 'v24' is possibly undefined
// 47C39D: variable 'v26' is possibly undefined
// 47C39D: variable 'v25' is possibly undefined
// 47C3D0: variable 'v30' is possibly undefined
// 4015D7: using guessed type void __noreturn Unwind_Resume_or_Rethrow_cold_16(void);

//----- (000000000047C3F0) ----------------------------------------------------
__int64 (__fastcall *__fastcall Unwind_DeleteException(__int64 a1))(__int64, __int64)
{
  __int64 (__fastcall *result)(__int64, __int64); // rax

  result = *(__int64 (__fastcall **)(__int64, __int64))(a1 + 8);
  if ( result )
    return (__int64 (__fastcall *)(__int64, __int64))result(1LL, a1);
  return result;
}

//----- (000000000047C420) ----------------------------------------------------
__int64 __fastcall Unwind_Backtrace(
        unsigned int (__fastcall *a1)(__m128i *, __int64),
        __int64 a2,
        __int64 a3,
        __int64 a4,
        u32 *a5,
        __int64 a6,
        char a7)
{
  __int64 v7; // rdx
  __int64 v8; // rcx
  u32 *v9; // r8
  __int64 v10; // r9
  __int64 v11; // rdx
  __int64 v12; // rcx
  u32 *v13; // r8
  u32 v14; // er9
  unsigned int v15; // eax
  unsigned int v16; // ebx
  __m128i v18[15]; // [rsp+0h] [rbp-2A0h] BYREF
  char v19[432]; // [rsp+F0h] [rbp-1B0h] BYREF
  __int64 retaddr; // [rsp+2A8h] [rbp+8h]

  uw_init_context_1(v18, (__int64)&a7, retaddr, a4, a5, a6);
  while ( 1 )
  {
    v15 = uw_frame_state_for((_QWORD *)v18, v19, v7, v8, v9, v10);
    v16 = v15;
    if ( v15 )
    {
      if ( v15 != 5 )
        break;
    }
    if ( a1(v18, a2) )
      break;
    if ( v16 == 5 )
      return v16;
    uw_update_context(v18, (__int64)v19, v11, v12, v13, v14);
  }
  return 3;
}
// 47C478: variable 'v11' is possibly undefined
// 47C478: variable 'v12' is possibly undefined
// 47C478: variable 'v13' is possibly undefined
// 47C478: variable 'v14' is possibly undefined
// 47C483: variable 'v7' is possibly undefined
// 47C483: variable 'v8' is possibly undefined
// 47C483: variable 'v9' is possibly undefined
// 47C483: variable 'v10' is possibly undefined
// 47C420: using guessed type __m128i var_2A0[15];

//----- (000000000047C4B0) ----------------------------------------------------
__int64 __fastcall fde_unencoded_compare(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 result; // rax
  unsigned __int64 v4; // rcx

  result = 1LL;
  v4 = *(_QWORD *)(a3 + 8);
  if ( *(_QWORD *)(a2 + 8) <= v4 )
    return (unsigned int)-(*(_QWORD *)(a2 + 8) < v4);
  return result;
}

//----- (000000000047C4D0) ----------------------------------------------------
void __fastcall frame_downheap(
        __int64 a1,
        __int64 (__fastcall *a2)(__int64, __int64, _QWORD),
        __int64 a3,
        int a4,
        __int64 a5,
        _QWORD *a6)
{
  int v6; // ebx
  int v9; // er13
  int v10; // eax
  __int64 v11; // rsi
  int v12; // ebp
  __int64 *v13; // rbx
  __int64 v14; // rax
  __int64 v15; // rax
  __int64 *v16; // r15
  _QWORD *v17; // [rsp+10h] [rbp-48h]
  int v18; // [rsp+1Ch] [rbp-3Ch]

  v6 = 2 * a4 + 1;
  if ( v6 < (int)a5 )
  {
    v9 = a5;
    do
    {
      v12 = v6 + 1;
      v15 = 8LL * v6;
      v16 = (__int64 *)(a3 + v15);
      v11 = *(_QWORD *)(a3 + v15);
      if ( v6 + 1 < v9 )
      {
        v18 = a4;
        v17 = (_QWORD *)(a3 + v15 + 8);
        v10 = a2(a1, v11, *v17);
        a6 = v17;
        a4 = v18;
        if ( v10 < 0 )
        {
          v11 = *v17;
          v16 = v17;
        }
        else
        {
          v11 = *v16;
          v12 = v6;
        }
      }
      else
      {
        v12 = v6;
      }
      v13 = (__int64 *)(a3 + 8LL * a4);
      if ( ((int (__fastcall *)(__int64, __int64, __int64, _QWORD, __int64, _QWORD *))a2)(a1, *v13, v11, a4, a5, a6) >= 0 )
        break;
      v14 = *v13;
      a4 = v12;
      *v13 = *v16;
      v6 = 2 * v12 + 1;
      *v16 = v14;
    }
    while ( v9 > v6 );
  }
}
// 47C53D: variable 'a5' is possibly undefined
// 47C53D: variable 'a6' is possibly undefined

//----- (000000000047C590) ----------------------------------------------------
void __fastcall frame_heapsort(
        __int64 a1,
        __int64 (__fastcall *a2)(__int64, __int64, _QWORD),
        __int64 a3,
        __int64 a4,
        __int64 a5,
        _QWORD *a6)
{
  __int64 v7; // rbp
  int v8; // ebx
  int v9; // ecx
  __int64 v10; // rbx
  __int64 v11; // rdx
  __int64 v12; // r8
  unsigned __int64 v13; // [rsp+8h] [rbp-40h]

  v7 = a3 + 16;
  v13 = *(_QWORD *)(a3 + 8);
  v8 = (v13 >> 1) - 1;
  if ( v8 >= 0 )
  {
    do
    {
      v9 = v8--;
      frame_downheap(a1, a2, v7, v9, (unsigned int)v13, a6);
    }
    while ( v8 != -1 );
  }
  v10 = (int)v13 - 1;
  if ( (int)v13 - 1 > 0 )
  {
    do
    {
      v11 = *(_QWORD *)(a3 + 16);
      v12 = (unsigned int)v10;
      *(_QWORD *)(a3 + 16) = *(_QWORD *)(a3 + 8 * v10 + 16);
      *(_QWORD *)(a3 + 8 * v10-- + 16) = v11;
      frame_downheap(a1, a2, v7, 0, v12, a6);
    }
    while ( (int)v10 > 0 );
  }
}
// 47C5D9: variable 'a6' is possibly undefined

//----- (000000000047C640) ----------------------------------------------------
__int64 __fastcall size_of_encoded_value(char a1, __int64 a2, __int64 a3, __int64 a4, u32 *a5, u32 a6)
{
  __int64 v6; // rdi
  __int64 result; // rax

  if ( a1 == -1 )
    return 0LL;
  v6 = a1 & 7;
  if ( (_BYTE)v6 != 2 )
  {
    if ( (unsigned __int8)v6 <= 2u )
    {
      if ( !(_BYTE)v6 )
        return 8LL;
    }
    else
    {
      result = 4LL;
      if ( (_BYTE)v6 == 3 )
        return result;
      if ( (_BYTE)v6 == 4 )
        return 8LL;
    }
    abort(v6, a2, a3, a4, a5, a6);
  }
  return 2LL;
}

//----- (000000000047C6A0) ----------------------------------------------------
__int64 __fastcall base_from_object(char a1, __int64 a2, __int64 a3, __int64 a4, u32 *a5, u32 a6)
{
  __int64 v6; // rdi

  if ( a1 == -1 )
    return 0LL;
  v6 = a1 & 0x70;
  if ( (_BYTE)v6 != 32 )
  {
    if ( (unsigned __int8)v6 > 0x20u )
    {
      if ( (_BYTE)v6 == 48 )
        return *(_QWORD *)(a2 + 16);
      if ( (_BYTE)v6 == 80 )
        return 0LL;
LABEL_10:
      abort(v6, a2, a3, a4, a5, a6);
    }
    if ( (_BYTE)v6 && (_BYTE)v6 != 16 )
      goto LABEL_10;
    return 0LL;
  }
  return *(_QWORD *)(a2 + 8);
}

//----- (000000000047C6F0) ----------------------------------------------------
__int64 __fastcall base_from_cb_data(char a1, __int64 a2, __int64 a3, __int64 a4, u32 *a5, u32 a6)
{
  __int64 v6; // rdi

  if ( a1 == -1 )
    return 0LL;
  v6 = a1 & 0x70;
  if ( (_BYTE)v6 != 32 )
  {
    if ( (unsigned __int8)v6 > 0x20u )
    {
      if ( (_BYTE)v6 == 48 )
        return *(_QWORD *)(a2 + 16);
      if ( (_BYTE)v6 == 80 )
        return 0LL;
LABEL_10:
      abort(v6, a2, a3, a4, a5, a6);
    }
    if ( (_BYTE)v6 && (_BYTE)v6 != 16 )
      goto LABEL_10;
    return 0LL;
  }
  return *(_QWORD *)(a2 + 8);
}

//----- (000000000047C740) ----------------------------------------------------
_QWORD *__fastcall read_encoded_value_with_base_0(char a1, __int64 a2, __int64 a3, _QWORD *a4)
{
  __int64 *v4; // rax
  __int64 v5; // r8
  _QWORD *result; // rax

  if ( a1 != 80 )
  {
    if ( (a1 & 0xFu) <= 0xC )
      __asm { jmp     rax }
    read_encoded_value_with_base_cold_8();
  }
  v4 = (__int64 *)((a3 + 7) & 0xFFFFFFFFFFFFFFF8LL);
  v5 = *v4;
  result = v4 + 1;
  *a4 = v5;
  return result;
}
// 4015DC: using guessed type void __noreturn read_encoded_value_with_base_cold_8(void);

//----- (000000000047C890) ----------------------------------------------------
__int64 __fastcall fde_single_encoding_compare(__int64 a1, __int64 a2, __int64 a3, __int64 a4, u32 *a5, u32 a6)
{
  char v7; // bl
  __int64 v8; // r14
  __int64 result; // rax
  unsigned __int64 v10; // [rsp+0h] [rbp-38h] BYREF
  __int64 v11[6]; // [rsp+8h] [rbp-30h] BYREF

  v7 = *(_WORD *)(a1 + 32) >> 3;
  v8 = base_from_object(v7, a1, a3, a4, a5, a6);
  read_encoded_value_with_base_0(v7, v8, a2 + 8, &v10);
  read_encoded_value_with_base_0(*(_WORD *)(a1 + 32) >> 3, v8, a3 + 8, v11);
  result = 1LL;
  if ( v10 <= v11[0] )
    return (unsigned int)-(v10 < v11[0]);
  return result;
}
// 47C890: using guessed type unsigned __int64 var_30[6];

//----- (000000000047C910) ----------------------------------------------------
__int64 __fastcall get_cie_encoding(_BYTE *a1)
{
  __int64 v1; // rax
  unsigned __int8 v2; // cl
  char *v3; // rdx
  __int64 result; // rax
  _QWORD *encoded_value_with_base_0; // rax
  char *v6; // rbx
  char v7; // dl
  __int64 v8[4]; // [rsp+8h] [rbp-20h] BYREF

  v1 = j_strlen_ifunc(a1 + 9);
  v2 = a1[8];
  v3 = &a1[v1 + 10];
  if ( v2 > 3u )
  {
    result = 255LL;
    if ( *v3 != 8 || v3[1] )
      return result;
    v3 += 2;
  }
  if ( a1[9] != 122 )
    return 0LL;
  do
  {
    if ( *v3++ >= 0 )
      break;
    ++v3;
  }
  while ( *(v3 - 1) < 0 );
  while ( 1 )
  {
    encoded_value_with_base_0 = v3 + 1;
    if ( *v3 >= 0 )
      break;
    ++v3;
  }
  if ( v2 == 1 )
  {
    encoded_value_with_base_0 = v3 + 2;
  }
  else
  {
    do
      encoded_value_with_base_0 = (_QWORD *)((char *)encoded_value_with_base_0 + 1);
    while ( *((char *)encoded_value_with_base_0 - 1) < 0 );
  }
  v6 = a1 + 10;
  do
    encoded_value_with_base_0 = (_QWORD *)((char *)encoded_value_with_base_0 + 1);
  while ( *((char *)encoded_value_with_base_0 - 1) < 0 );
  v7 = a1[10];
  if ( v7 != 82 )
  {
    do
    {
      while ( v7 == 80 )
      {
        ++v6;
        encoded_value_with_base_0 = read_encoded_value_with_base_0(
                                      *(_BYTE *)encoded_value_with_base_0 & 0x7F,
                                      0LL,
                                      (__int64)encoded_value_with_base_0 + 1,
                                      v8);
        v7 = *v6;
        if ( *v6 == 82 )
          return *(unsigned __int8 *)encoded_value_with_base_0;
      }
      if ( v7 != 76 )
        return 0LL;
      v7 = *++v6;
      encoded_value_with_base_0 = (_QWORD *)((char *)encoded_value_with_base_0 + 1);
    }
    while ( *v6 != 82 );
  }
  return *(unsigned __int8 *)encoded_value_with_base_0;
}
// 4010C8: using guessed type __int64 __fastcall j_strlen_ifunc(_QWORD);
// 47C910: using guessed type __int64 var_20[4];

//----- (000000000047CA50) ----------------------------------------------------
unsigned int *__fastcall linear_search_fdes(__int64 a1, unsigned int *a2, __int64 a3, __int64 a4, __int64 a5, u32 a6)
{
  unsigned int *v7; // rbx
  u32 *v8; // r8
  int cie_encoding; // er14
  __int64 v10; // rax
  __int64 v11; // r15
  unsigned int *v12; // r13
  __int64 v13; // rax
  unsigned __int64 v14; // rdx
  __int64 v15; // rax
  __int64 v16; // rdx
  __int64 v17; // rcx
  u32 *v18; // r8
  u32 v19; // er9
  _QWORD *v20; // rax
  __int64 v21; // rdx
  __int64 v22; // rcx
  u32 *v23; // r8
  unsigned int v24; // eax
  __int64 v25; // rdx
  unsigned int *v27; // [rsp+8h] [rbp-60h]
  __int64 v28; // [rsp+20h] [rbp-48h] BYREF
  __int64 v29[8]; // [rsp+28h] [rbp-40h] BYREF

  v7 = a2;
  v8 = (u32 *)(*(_WORD *)(a1 + 32) >> 3);
  cie_encoding = (unsigned __int8)v8;
  v10 = base_from_object((char)v8, a1, a3, a4, v8, a6);
  if ( *a2 )
  {
    v11 = v10;
    v12 = 0LL;
    do
    {
      v15 = (int)v7[1];
      if ( (_DWORD)v15 )
      {
        if ( (*(_BYTE *)(a1 + 32) & 4) != 0 && (unsigned int *)((char *)v7 - v15 + 4) != v12 )
        {
          v27 = (unsigned int *)((char *)v7 - v15 + 4);
          cie_encoding = get_cie_encoding(v27);
          v11 = base_from_object(cie_encoding, a1, v16, v17, v18, v19);
          v12 = v27;
        }
        if ( cie_encoding )
        {
          v20 = read_encoded_value_with_base_0(cie_encoding, v11, (__int64)(v7 + 2), &v28);
          read_encoded_value_with_base_0(cie_encoding & 0xF, 0LL, (__int64)v20, v29);
          v24 = size_of_encoded_value(cie_encoding, 0LL, v21, v22, v23, (unsigned __int8)cie_encoding);
          v25 = -1LL;
          if ( v24 <= 7 )
            v25 = (1LL << (8 * (unsigned __int8)v24)) - 1;
          if ( (v25 & v28) != 0 && (unsigned __int64)(a3 - v28) < v29[0] )
            return v7;
        }
        else
        {
          v13 = *((_QWORD *)v7 + 1);
          v14 = *((_QWORD *)v7 + 2);
          v28 = v13;
          v29[0] = v14;
          if ( v13 && a3 - v13 < v14 )
            return v7;
        }
      }
      v7 = (unsigned int *)((char *)v7 + *v7 + 4);
    }
    while ( *v7 );
  }
  return 0LL;
}
// 47CB17: variable 'v16' is possibly undefined
// 47CB17: variable 'v17' is possibly undefined
// 47CB17: variable 'v18' is possibly undefined
// 47CB17: variable 'v19' is possibly undefined
// 47CB66: variable 'v21' is possibly undefined
// 47CB66: variable 'v22' is possibly undefined
// 47CB66: variable 'v23' is possibly undefined
// 47CA50: using guessed type unsigned __int64 var_40[8];

//----- (000000000047CBE0) ----------------------------------------------------
__int64 __fastcall Unwind_IteratePhdrCallback(
        __int64 *a1,
        unsigned __int64 a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        unsigned __int64 a6)
{
  unsigned int *v6; // rax
  __int64 v7; // r10
  __int64 *v8; // r12
  __int64 v9; // rcx
  unsigned __int64 v10; // r13
  __int64 v11; // r14
  __int64 v12; // rbx
  unsigned __int64 v13; // r8
  unsigned int *v14; // rbp
  unsigned int *v15; // rdi
  unsigned __int64 v16; // rcx
  unsigned __int64 v17; // r11
  __int64 *v18; // rax
  _BYTE *v19; // rbx
  __int64 v21; // r8
  char *v22; // rcx
  __int64 v23; // r11
  __int64 *v24; // rbx
  unsigned __int64 *v25; // rcx
  char v26; // r12
  __int64 v28; // rax
  _QWORD *v29; // rax
  __int64 v30; // rdx
  __int64 v31; // rcx
  unsigned __int64 v32; // r8
  u32 v33; // er9
  char v34; // di
  __int64 v35; // r13
  unsigned __int64 v36; // rdx
  __int64 v37; // rax
  __int64 v38; // rax
  unsigned int *v39; // rax
  char v40; // bl
  __int64 v41; // rdx
  __int64 v42; // rcx
  u32 *v43; // r8
  u32 v44; // er9
  __int64 v45; // rax
  __int64 v46; // rax
  _QWORD *v47; // rax
  unsigned __int64 v48; // rsi
  unsigned __int64 v49; // rdi
  unsigned __int64 v50; // rcx
  int *v51; // r14
  _BYTE *v52; // r12
  char cie_encoding; // r13
  __int64 v54; // rdx
  __int64 v55; // rcx
  u32 *v56; // r8
  u32 v57; // er9
  int v58; // eax
  _BYTE *v59; // r10
  __int64 v60; // rax
  __int64 *v61; // [rsp+8h] [rbp-80h]
  unsigned int *v62; // [rsp+10h] [rbp-78h] BYREF
  __int64 v63; // [rsp+18h] [rbp-70h] BYREF
  __int64 v64[13]; // [rsp+20h] [rbp-68h] BYREF

  v6 = (unsigned int *)a1[2];
  v7 = *a1;
  if ( *(_DWORD *)(a3 + 40) && a2 > 0x2F )
  {
    v21 = a1[5];
    if ( a1[4] != adds_9298 || subs_9299 != v21 )
    {
      adds_9298 = a1[4];
      v22 = (char *)&unk_4AB230;
      subs_9299 = v21;
      do
      {
        *((_QWORD *)v22 - 6) = 0LL;
        *((_QWORD *)v22 - 5) = 0LL;
        *((_QWORD *)v22 - 1) = v22;
        v22 += 48;
      }
      while ( (char *)&unk_4AB230 + 384 != v22 );
      v8 = 0LL;
      qword_4AB378 = 0LL;
      frame_hdr_cache_head = (__int64)&frame_hdr_cache;
      *(_DWORD *)(a3 + 40) = 0;
      v61 = 0LL;
      goto LABEL_5;
    }
    v23 = frame_hdr_cache_head;
    if ( !frame_hdr_cache_head )
    {
LABEL_4:
      v61 = 0LL;
      v8 = 0LL;
LABEL_5:
      v9 = *((unsigned __int16 *)a1 + 12);
      if ( !(_WORD)v9 )
        return 0LL;
      v10 = 0LL;
      v11 = 0LL;
      v12 = 0LL;
      v13 = 0LL;
      v14 = 0LL;
      v15 = &v6[14 * v9];
      while ( 1 )
      {
        v16 = *v6;
        if ( (_DWORD)v16 != 1 )
          break;
        v16 = *(_QWORD *)a3;
        a6 = v7 + *((_QWORD *)v6 + 2);
        if ( *(_QWORD *)a3 < a6 )
        {
LABEL_10:
          v6 += 14;
          if ( v6 == v15 )
            goto LABEL_19;
        }
        else
        {
          v17 = a6 + *((_QWORD *)v6 + 5);
          if ( v16 < v17 )
            v10 = a6 + *((_QWORD *)v6 + 5);
          if ( v16 < v17 )
          {
            v11 = v7 + *((_QWORD *)v6 + 2);
            if ( v16 < v17 )
              v12 = 1LL;
          }
          v6 += 14;
          if ( v6 == v15 )
          {
LABEL_19:
            if ( v12 )
            {
              if ( a2 > 0x2F )
              {
                v18 = (__int64 *)frame_hdr_cache_head;
                if ( v8 && v61 )
                {
                  v16 = v8[5];
                  frame_hdr_cache_head = (__int64)v8;
                  v61[5] = v16;
                  v8[5] = (__int64)v18;
                  v18 = v8;
                }
                v18[2] = v7;
                v18[3] = (__int64)v14;
                v18[4] = v13;
                *v18 = v11;
                v18[1] = v10;
              }
              goto LABEL_25;
            }
            return 0LL;
          }
        }
      }
      if ( (_DWORD)v16 == 1685382480 )
      {
        v14 = v6;
      }
      else if ( (_DWORD)v16 == 2 )
      {
        v13 = (unsigned __int64)v6;
      }
      goto LABEL_10;
    }
    v8 = (__int64 *)frame_hdr_cache_head;
    a6 = *(_QWORD *)a3;
    v24 = 0LL;
    v16 = *(_QWORD *)frame_hdr_cache_head;
    v13 = *(_QWORD *)(frame_hdr_cache_head + 8);
    if ( *(_QWORD *)a3 < *(_QWORD *)frame_hdr_cache_head )
    {
LABEL_39:
      while ( v13 | v16 )
      {
        v25 = (unsigned __int64 *)v8[5];
        if ( !v25 )
          break;
        v24 = v8;
        v8 = (__int64 *)v8[5];
        v16 = *v25;
        v13 = v8[1];
        if ( a6 >= v16 )
          goto LABEL_38;
      }
      v61 = v24;
      goto LABEL_5;
    }
LABEL_38:
    if ( a6 >= v13 )
      goto LABEL_39;
    v7 = v8[2];
    v14 = (unsigned int *)v8[3];
    if ( (__int64 *)frame_hdr_cache_head != v8 )
    {
      v60 = v8[5];
      frame_hdr_cache_head = (__int64)v8;
      v24[5] = v60;
      v8[5] = v23;
    }
LABEL_25:
    if ( !v14 )
      return 0LL;
    v19 = (_BYTE *)(v7 + *((_QWORD *)v14 + 2));
    if ( *v19 != 1 )
      return 1LL;
    v26 = v19[1];
    v28 = base_from_cb_data(v26, a3, a3, v16, (u32 *)v13, a6);
    v29 = read_encoded_value_with_base_0(v26, v28, (__int64)(v19 + 4), &v62);
    v34 = v19[2];
    v35 = (__int64)v29;
    if ( v34 != -1 && v19[3] == 59 )
    {
      v46 = base_from_cb_data(v34, a3, v30, v31, (u32 *)v32, v33);
      v47 = read_encoded_value_with_base_0(v34, v46, v35, &v63);
      if ( !v63 )
        return 1LL;
      v36 = *(_QWORD *)a3;
      v48 = (unsigned __int8)v47 & 3;
      if ( ((unsigned __int8)v47 & 3) == 0 )
      {
        if ( (unsigned __int64)&v19[*(int *)v47] <= v36 )
        {
          v49 = v63 - 1;
          v50 = (unsigned __int64)&v19[SLODWORD(v47[v63 - 1])];
          if ( v50 <= v36 )
          {
            v50 = v63 - 1;
          }
          else
          {
            do
            {
              if ( v48 >= v49 )
LABEL_58:
                abort(v49, v48, v36, v50, (u32 *)v32, v33);
              v50 = (v48 + v49) >> 1;
              v32 = (unsigned __int64)&v19[SLODWORD(v47[v50])];
              if ( v32 > v36 )
              {
                if ( v48 >= v50 )
                  goto LABEL_58;
                while ( 1 )
                {
                  v32 = (v48 + v50) >> 1;
                  v49 = (unsigned __int64)&v19[SLODWORD(v47[v32])];
                  if ( v49 <= v36 )
                    break;
                  v50 = (v48 + v50) >> 1;
                  if ( v48 >= v32 )
                    goto LABEL_58;
                }
                v49 = v50;
                v50 = (v48 + v50) >> 1;
              }
              v48 = v50 + 1;
              v32 = (unsigned __int64)&v19[SLODWORD(v47[v50 + 1])];
            }
            while ( v32 <= v36 );
          }
          v51 = (int *)&v47[v50];
          v52 = &v19[v51[1]];
          cie_encoding = get_cie_encoding(&v52[-*((int *)v52 + 1) + 4]);
          v58 = size_of_encoded_value(cie_encoding, v48, v54, v55, v56, v57);
          read_encoded_value_with_base_0(cie_encoding & 0xF, 0LL, (__int64)&v52[v58 + 8], v64);
          v59 = &v19[*v51];
          if ( *(_QWORD *)a3 < (unsigned __int64)&v59[v64[0]] )
            *(_QWORD *)(a3 + 32) = v52;
          *(_QWORD *)(a3 + 24) = v59;
        }
        return 1LL;
      }
    }
    else
    {
      v36 = *(_QWORD *)a3;
    }
    v37 = *(_QWORD *)(a3 + 8);
    v64[0] = 0LL;
    v64[4] = 4LL;
    v64[1] = v37;
    v38 = *(_QWORD *)(a3 + 16);
    v64[3] = (__int64)v62;
    v64[2] = v38;
    v39 = linear_search_fdes((__int64)v64, v62, v36, v31, v32, v33);
    *(_QWORD *)(a3 + 32) = v39;
    if ( v39 )
    {
      v40 = get_cie_encoding((_BYTE *)v39 - (int)v39[1] + 4);
      v45 = base_from_cb_data(v40, a3, v41, v42, v43, v44);
      read_encoded_value_with_base_0(v40, v45, *(_QWORD *)(a3 + 32) + 8LL, &v63);
      *(_QWORD *)(a3 + 24) = v63;
    }
    return 1LL;
  }
  if ( a2 > 0x19 )
    goto LABEL_4;
  return 0xFFFFFFFFLL;
}
// 47CEE5: variable 'v31' is possibly undefined
// 47CEE5: variable 'v32' is possibly undefined
// 47CEE5: variable 'v33' is possibly undefined
// 47CF0F: variable 'v41' is possibly undefined
// 47CF0F: variable 'v42' is possibly undefined
// 47CF0F: variable 'v43' is possibly undefined
// 47CF0F: variable 'v44' is possibly undefined
// 47CF54: variable 'v30' is possibly undefined
// 47D029: variable 'v54' is possibly undefined
// 47D029: variable 'v55' is possibly undefined
// 47D029: variable 'v56' is possibly undefined
// 47D029: variable 'v57' is possibly undefined
// 4A9BE8: using guessed type __int64 adds_9298;
// 4AB1E8: using guessed type __int64 subs_9299;
// 4AB1F0: using guessed type __int64 frame_hdr_cache_head;
// 4AB378: using guessed type __int64 qword_4AB378;

//----- (000000000047D0A0) ----------------------------------------------------
__int64 __fastcall fde_mixed_encoding_compare(__int64 a1, __int64 a2, __int64 a3)
{
  char cie_encoding; // r13
  __int64 v5; // rdx
  __int64 v6; // rcx
  u32 *v7; // r8
  u32 v8; // er9
  __int64 v9; // rax
  char v10; // bp
  __int64 v11; // rdx
  __int64 v12; // rcx
  u32 *v13; // r8
  u32 v14; // er9
  __int64 v15; // rax
  __int64 result; // rax
  unsigned __int64 v17; // [rsp+0h] [rbp-38h] BYREF
  __int64 v18[6]; // [rsp+8h] [rbp-30h] BYREF

  cie_encoding = get_cie_encoding((_BYTE *)(a2 + 4 - *(int *)(a2 + 4)));
  v9 = base_from_object(cie_encoding, a1, v5, v6, v7, v8);
  read_encoded_value_with_base_0(cie_encoding, v9, a2 + 8, &v17);
  v10 = get_cie_encoding((_BYTE *)(a3 + 4 - *(int *)(a3 + 4)));
  v15 = base_from_object(v10, a1, v11, v12, v13, v14);
  read_encoded_value_with_base_0(v10, v15, a3 + 8, v18);
  result = 1LL;
  if ( v17 <= v18[0] )
    return (unsigned int)-(v17 < v18[0]);
  return result;
}
// 47D0D1: variable 'v5' is possibly undefined
// 47D0D1: variable 'v6' is possibly undefined
// 47D0D1: variable 'v7' is possibly undefined
// 47D0D1: variable 'v8' is possibly undefined
// 47D100: variable 'v11' is possibly undefined
// 47D100: variable 'v12' is possibly undefined
// 47D100: variable 'v13' is possibly undefined
// 47D100: variable 'v14' is possibly undefined
// 47D0A0: using guessed type unsigned __int64 var_30[6];

//----- (000000000047D140) ----------------------------------------------------
__int64 __fastcall classify_object_over_fdes(__int64 a1, unsigned int *a2)
{
  unsigned int *v2; // r15
  __int64 v3; // r14
  int v4; // er13
  char *v5; // rcx
  __int64 v6; // rdx
  __int64 v7; // rcx
  u32 *v8; // r8
  u32 v9; // er9
  unsigned int v10; // eax
  __int64 v11; // rdx
  __int64 v12; // rax
  char v13; // bp
  char *v14; // rbx
  int cie_encoding; // eax
  __int64 v16; // rdx
  __int64 v17; // rcx
  u32 *v18; // r8
  u32 v19; // er9
  unsigned __int16 v20; // ax
  __int64 v22; // [rsp+8h] [rbp-50h]
  __int64 v23[8]; // [rsp+18h] [rbp-40h] BYREF

  if ( *a2 )
  {
    v2 = a2;
    v3 = 0LL;
    LOBYTE(v4) = 0;
    v5 = 0LL;
    v22 = 0LL;
    while ( 1 )
    {
      v12 = (int)v2[1];
      if ( (_DWORD)v12 )
      {
        v13 = v4;
        v14 = (char *)v2 - v12 + 4;
        if ( v14 != v5 )
        {
          cie_encoding = get_cie_encoding((_BYTE *)v2 - v12 + 4);
          v4 = cie_encoding;
          if ( cie_encoding == 255 )
            return -1LL;
          v13 = cie_encoding;
          v3 = base_from_object(cie_encoding, a1, v16, v17, v18, v19);
          v20 = *(_WORD *)(a1 + 32);
          if ( (v20 & 0x7F8) == 2040 )
          {
            *(_WORD *)(a1 + 32) = (8 * (unsigned __int8)v4) | v20 & 0xF807;
          }
          else if ( (unsigned __int8)(v20 >> 3) != v4 )
          {
            *(_BYTE *)(a1 + 32) |= 4u;
          }
        }
        read_encoded_value_with_base_0(v13, v3, (__int64)(v2 + 2), v23);
        v10 = size_of_encoded_value(v13, v3, v6, v7, v8, v9);
        v11 = -1LL;
        if ( v10 <= 7 )
          v11 = (1LL << (8 * (unsigned __int8)v10)) - 1;
        v5 = v14;
        if ( (v11 & v23[0]) != 0 )
        {
          ++v22;
          if ( *(_QWORD *)a1 > v23[0] )
            *(_QWORD *)a1 = v23[0];
          v5 = v14;
        }
      }
      v2 = (unsigned int *)((char *)v2 + *v2 + 4);
      if ( !*v2 )
        return v22;
    }
  }
  return 0LL;
}
// 47D1A6: variable 'v6' is possibly undefined
// 47D1A6: variable 'v7' is possibly undefined
// 47D1A6: variable 'v8' is possibly undefined
// 47D1A6: variable 'v9' is possibly undefined
// 47D22B: variable 'v16' is possibly undefined
// 47D22B: variable 'v17' is possibly undefined
// 47D22B: variable 'v18' is possibly undefined
// 47D22B: variable 'v19' is possibly undefined
// 47D140: using guessed type unsigned __int64 var_40[8];

//----- (000000000047D290) ----------------------------------------------------
__int64 __fastcall add_fdes(__int64 a1, __int64 *a2, __int64 a3, __int64 a4, __int64 a5, u32 a6)
{
  unsigned int *v6; // rbx
  u32 *v7; // r8
  int cie_encoding; // er13
  __int64 result; // rax
  __int64 v10; // r14
  unsigned int *v11; // r15
  __int64 v12; // rax
  __int64 v13; // rdx
  __int64 v14; // rax
  __int64 v15; // rdx
  __int64 v16; // rcx
  u32 *v17; // r8
  u32 v18; // er9
  __int64 v19; // rdx
  __int64 v20; // rcx
  u32 *v21; // r8
  u32 v22; // er9
  unsigned int v23; // eax
  __int64 v24; // rdx
  unsigned int *v25; // [rsp+0h] [rbp-58h]
  __int64 v26[8]; // [rsp+18h] [rbp-40h] BYREF

  v6 = (unsigned int *)a3;
  v7 = (u32 *)(*(_WORD *)(a1 + 32) >> 3);
  cie_encoding = (unsigned __int8)v7;
  result = base_from_object((char)v7, a1, a3, a4, v7, a6);
  if ( *v6 )
  {
    v10 = result;
    v11 = 0LL;
    while ( 1 )
    {
      v14 = (int)v6[1];
      if ( !(_DWORD)v14 )
        goto LABEL_6;
      if ( (*(_BYTE *)(a1 + 32) & 4) != 0 && (unsigned int *)((char *)v6 - v14 + 4) != v11 )
      {
        v25 = (unsigned int *)((char *)v6 - v14 + 4);
        cie_encoding = get_cie_encoding(v25);
        v10 = base_from_object(cie_encoding, a1, v15, v16, v17, v18);
        v11 = v25;
      }
      if ( cie_encoding )
      {
        read_encoded_value_with_base_0(cie_encoding, v10, (__int64)(v6 + 2), v26);
        v23 = size_of_encoded_value(cie_encoding, v10, v19, v20, v21, v22);
        v24 = -1LL;
        if ( v23 <= 7 )
          v24 = (1LL << (8 * (unsigned __int8)v23)) - 1;
        if ( (v24 & v26[0]) != 0 )
        {
LABEL_4:
          v12 = *a2;
          if ( *a2 )
          {
            v13 = *(_QWORD *)(v12 + 8);
            *(_QWORD *)(v12 + 8) = v13 + 1;
            *(_QWORD *)(v12 + 8 * v13 + 16) = v6;
          }
          goto LABEL_6;
        }
        v6 = (unsigned int *)((char *)v6 + *v6 + 4);
        result = *v6;
        if ( !(_DWORD)result )
          return result;
      }
      else
      {
        if ( *((_QWORD *)v6 + 1) )
          goto LABEL_4;
LABEL_6:
        v6 = (unsigned int *)((char *)v6 + *v6 + 4);
        result = *v6;
        if ( !(_DWORD)result )
          return result;
      }
    }
  }
  return result;
}
// 47D341: variable 'v15' is possibly undefined
// 47D341: variable 'v16' is possibly undefined
// 47D341: variable 'v17' is possibly undefined
// 47D341: variable 'v18' is possibly undefined
// 47D378: variable 'v19' is possibly undefined
// 47D378: variable 'v20' is possibly undefined
// 47D378: variable 'v21' is possibly undefined
// 47D378: variable 'v22' is possibly undefined
// 47D290: using guessed type __int64 var_40[8];

//----- (000000000047D3D0) ----------------------------------------------------
unsigned int *__fastcall search_object(__int64 a1, __int64 a2, __int64 a3, __int64 a4, u32 *a5, __int64 a6)
{
  unsigned __int64 v6; // r14
  __int64 v7; // rbp
  char v8; // al
  __int64 v9; // r13
  unsigned __int64 v10; // r12
  unsigned __int16 v11; // ax
  unsigned __int64 v12; // rcx
  unsigned __int64 v13; // rdx
  __int64 v14; // rbx
  unsigned __int64 v15; // rsi
  __int64 v16; // rdi
  __int64 v18; // r12
  __int64 *v19; // rbx
  __int64 v20; // rax
  unsigned __int64 v21; // rax
  unsigned __int64 v22; // rbp
  unsigned __int64 v23; // rbx
  __int64 v24; // r13
  char cie_encoding; // r15
  __int64 v26; // rdx
  __int64 v27; // rcx
  u32 *v28; // r8
  u32 v29; // er9
  __int64 v30; // rax
  _QWORD *v31; // rax
  unsigned int **v32; // r12
  unsigned int *v33; // rsi
  unsigned int *v34; // rax
  char v35; // bl
  char v36; // al
  unsigned __int64 v37; // rbp
  unsigned __int64 v38; // rbx
  __int64 v39; // r12
  _QWORD *v40; // rax
  __int64 *v41; // rax
  __int64 v42; // rdi
  _QWORD *v43; // rax
  __int64 v44; // rcx
  u32 *v45; // r8
  _QWORD *v46; // r9
  __int64 *v47; // rbx
  __int64 v48; // rdx
  __int64 *v49; // r15
  __int64 (__fastcall *v50)(__int64, __int64, _QWORD); // rbx
  u32 *v51; // rcx
  __int64 v52; // r14
  __int64 v53; // r12
  __int64 *v54; // r15
  __int64 *v55; // r13
  char *v56; // rax
  u32 *v57; // rax
  __int64 v58; // rdx
  __int64 v59; // rsi
  __int64 *v60; // rdx
  __int64 v61; // rcx
  u32 *v62; // r8
  unsigned __int64 v63; // r9
  __int64 v64; // rax
  __int64 *v65; // r14
  __int64 v66; // r13
  __int64 v67; // r15
  __int64 v68; // r12
  __int64 v69; // rbp
  __int64 *v70; // r13
  __int64 *v71; // rax
  char *v72; // [rsp+8h] [rbp-90h]
  __int64 v73; // [rsp+8h] [rbp-90h]
  __int64 v74; // [rsp+10h] [rbp-88h]
  __int64 v75; // [rsp+10h] [rbp-88h]
  __int64 v76; // [rsp+18h] [rbp-80h]
  char v77; // [rsp+18h] [rbp-80h]
  __int64 v78; // [rsp+18h] [rbp-80h]
  __int64 v79; // [rsp+18h] [rbp-80h]
  __int64 v80; // [rsp+20h] [rbp-78h]
  __int64 v81; // [rsp+20h] [rbp-78h]
  __int64 v82; // [rsp+20h] [rbp-78h]
  unsigned __int64 v83; // [rsp+20h] [rbp-78h]
  char v84; // [rsp+28h] [rbp-70h]
  __int64 *v85; // [rsp+28h] [rbp-70h]
  u32 *v86; // [rsp+30h] [rbp-68h]
  unsigned __int64 v87; // [rsp+38h] [rbp-60h]
  unsigned __int64 v88; // [rsp+48h] [rbp-50h] BYREF
  __int64 *v89; // [rsp+50h] [rbp-48h] BYREF
  _QWORD *v90; // [rsp+58h] [rbp-40h]

  v6 = a2;
  v7 = a1;
  v8 = *(_BYTE *)(a1 + 32);
  if ( (v8 & 1) != 0 )
    goto LABEL_2;
  v18 = *(_DWORD *)(a1 + 32) >> 11;
  v74 = v18;
  if ( !(*(_DWORD *)(a1 + 32) >> 11) )
  {
    v19 = *(__int64 **)(a1 + 24);
    if ( (v8 & 2) != 0 )
    {
      a2 = *v19;
      if ( !*v19 )
        goto LABEL_32;
      do
      {
        v20 = classify_object_over_fdes(a1, (unsigned int *)a2);
        if ( v20 == -1 )
          goto LABEL_18;
        a2 = *++v19;
        v18 += v20;
      }
      while ( *v19 );
      v74 = v18;
    }
    else
    {
      a2 = *(_QWORD *)(a1 + 24);
      v74 = classify_object_over_fdes(a1, (unsigned int *)a2);
      if ( v74 == -1 )
      {
LABEL_18:
        *(_QWORD *)(a1 + 32) = 2040LL;
        *(_QWORD *)(a1 + 24) = &terminator_9142;
        goto LABEL_32;
      }
    }
    if ( (v74 & 0xFFFFFFFFFFE00000LL) != 0 )
    {
      *(_DWORD *)(a1 + 32) &= 0x7FFu;
    }
    else
    {
      a3 = (unsigned int)((_DWORD)v74 << 11);
      *(_DWORD *)(a1 + 32) = a3 | *(_DWORD *)(a1 + 32) & 0x7FF;
    }
    if ( !v74 )
      goto LABEL_32;
  }
  v41 = malloc(8 * v74 + 16, a2, (_QWORD *)a3, a4, a5, a6);
  v89 = v41;
  if ( !v41 )
    goto LABEL_32;
  v41[1] = 0LL;
  v42 = 8 * v74 + 16;
  v43 = malloc(v42, a2, (_QWORD *)a3, a4, a5, a6);
  v90 = v43;
  if ( v43 )
    v43[1] = 0LL;
  v47 = *(__int64 **)(v7 + 24);
  if ( (*(_BYTE *)(v7 + 32) & 2) != 0 )
  {
    v48 = *v47;
    if ( !*v47 )
      goto LABEL_96;
    do
    {
      a2 = (__int64)&v89;
      v42 = v7;
      ++v47;
      add_fdes(v7, (__int64 *)&v89, v48, v44, (__int64)v45, (u32)v46);
      v48 = *v47;
    }
    while ( *v47 );
  }
  else
  {
    v42 = v7;
    a2 = (__int64)&v89;
    add_fdes(v7, (__int64 *)&v89, *(_QWORD *)(v7 + 24), v44, (__int64)v45, (u32)v46);
  }
  v49 = v89;
  v85 = v89;
  if ( v89 && v89[1] != v74 )
    goto LABEL_96;
  v50 = fde_mixed_encoding_compare;
  if ( (*(_BYTE *)(v7 + 32) & 4) == 0 )
  {
    v50 = fde_unencoded_compare;
    if ( (*(_WORD *)(v7 + 32) & 0x7F8) != 0 )
      v50 = (__int64 (__fastcall *)(__int64, __int64, _QWORD))fde_single_encoding_compare;
  }
  v82 = (__int64)v90;
  if ( !v90 )
  {
    frame_heapsort(v7, v50, (__int64)v89, v44, (__int64)v45, v46);
    goto LABEL_85;
  }
  v51 = (u32 *)v89[1];
  v86 = v51;
  if ( v51 )
  {
    v87 = v6;
    v78 = 8LL * (_QWORD)v51 + 8;
    v52 = 16LL;
    v53 = (__int64)v90;
    v72 = (char *)(v89 + 2);
    v54 = (__int64 *)&marker_9036;
    v55 = v89;
LABEL_61:
    while ( 1 )
    {
      *(_QWORD *)(v53 + v52) = v54;
      v54 = &v55[(unsigned __int64)v52 / 8];
      if ( v78 == v52 )
        break;
      while ( v54 != (__int64 *)&marker_9036 )
      {
        if ( (int)v50(v7, v55[(unsigned __int64)v52 / 8 + 1], *v54) >= 0 )
        {
          v52 += 8LL;
          goto LABEL_61;
        }
        v56 = (char *)(v53 + (char *)v54 - v72);
        v54 = (__int64 *)*((_QWORD *)v56 + 2);
        *((_QWORD *)v56 + 2) = 0LL;
      }
      v54 = (__int64 *)&marker_9036;
      v52 += 8LL;
    }
    v6 = v87;
    a2 = 0LL;
    v44 = 0LL;
    v57 = 0LL;
    v42 = v82;
    v45 = v86;
    do
    {
      v58 = v55[(_QWORD)v57 + 2];
      if ( *(_QWORD *)(v82 + 8LL * (_QWORD)v57 + 16) )
        v55[v44++ + 2] = v58;
      else
        *(_QWORD *)(v82 + 8 * a2++ + 16) = v58;
      v57 = (u32 *)((char *)v57 + 1);
    }
    while ( v86 != v57 );
    v48 = (__int64)v90;
    v49 = v89;
  }
  else
  {
    v48 = (__int64)v90;
    a2 = 0LL;
    v44 = 0LL;
  }
  v85[1] = v44;
  *(_QWORD *)(v82 + 8) = a2;
  if ( v49[1] + *(_QWORD *)(v48 + 8) != v74 )
LABEL_96:
    abort(v42, a2, v48, v44, v45, (u32)v46);
  v59 = (__int64)v50;
  frame_heapsort(v7, v50, v48, v44, (__int64)v45, v46);
  v79 = (__int64)v90;
  v64 = v90[1];
  if ( !v64 )
    goto LABEL_84;
  v73 = v7;
  v83 = v6;
  v65 = v89;
  v66 = v89[1];
  while ( 1 )
  {
    v75 = v64 - 1;
    v61 = v79;
    v60 = (__int64 *)(v79 + 8 * v64);
    v67 = v60[1];
    if ( !v66 )
      break;
    v68 = v64 + v66 - 1;
    while ( 1 )
    {
      v69 = v66 - 1;
      v59 = v65[v66 + 1];
      if ( (int)v50(v73, v59, v67) <= 0 )
        break;
      --v66;
      v65[v68-- + 2] = v65[v69 + 2];
      if ( !v69 )
      {
        v68 = v75;
        break;
      }
    }
LABEL_80:
    v65[v68 + 2] = v67;
    if ( !v75 )
      goto LABEL_83;
    v64 = v75;
  }
  v65[v64 + 1] = v67;
  if ( v64 != 1 )
  {
    v68 = v64 - 2;
    v67 = *v60;
    v75 = v64 - 2;
    goto LABEL_80;
  }
LABEL_83:
  v70 = v65;
  v7 = v73;
  v6 = v83;
  v70[1] += *(_QWORD *)(v79 + 8);
  v79 = (__int64)v90;
LABEL_84:
  free(v79, v59, (__int64)v60, v61, v62, v63);
LABEL_85:
  v71 = v89;
  a3 = *(_QWORD *)(v7 + 24);
  *v89 = a3;
  *(_QWORD *)(v7 + 24) = v71;
  *(_BYTE *)(v7 + 32) |= 1u;
LABEL_32:
  if ( *(_QWORD *)v7 > v6 )
    return 0LL;
  v8 = *(_BYTE *)(v7 + 32);
  v32 = *(unsigned int ***)(v7 + 24);
  if ( (v8 & 1) != 0 )
  {
LABEL_2:
    v9 = *(_QWORD *)(v7 + 24);
    v10 = *(_QWORD *)(v9 + 8);
    if ( (v8 & 4) != 0 )
    {
      if ( v10 )
      {
        v80 = v7;
        v22 = 0LL;
        v76 = v9;
        do
        {
          v23 = (v10 + v22) >> 1;
          v24 = *(_QWORD *)(v76 + 8 * v23 + 16);
          cie_encoding = get_cie_encoding((_BYTE *)(v24 + 4 - *(int *)(v24 + 4)));
          v30 = base_from_object(cie_encoding, v80, v26, v27, v28, v29);
          v31 = read_encoded_value_with_base_0(cie_encoding, v30, v24 + 8, &v88);
          read_encoded_value_with_base_0(cie_encoding & 0xF, 0LL, (__int64)v31, &v89);
          if ( v88 <= v6 )
          {
            if ( (unsigned __int64)v89 + v88 > v6 )
              return (unsigned int *)v24;
            v22 = v23 + 1;
          }
          else
          {
            v10 = (v10 + v22) >> 1;
          }
        }
        while ( v22 < v10 );
      }
    }
    else
    {
      v11 = *(_WORD *)(v7 + 32);
      v12 = 0LL;
      if ( (v11 & 0x7F8) != 0 )
      {
        v35 = v11 >> 3;
        v77 = v35;
        v81 = base_from_object(v35, v7, a3, 0LL, a5, a6);
        if ( v10 )
        {
          v36 = v35;
          v37 = 0LL;
          v38 = v10;
          v84 = v36 & 0xF;
          do
          {
            v39 = *(_QWORD *)(v9 + 8 * ((v38 + v37) >> 1) + 16);
            v40 = read_encoded_value_with_base_0(v77, v81, v39 + 8, &v88);
            read_encoded_value_with_base_0(v84, 0LL, (__int64)v40, &v89);
            if ( v88 <= v6 )
            {
              if ( (unsigned __int64)v89 + v88 > v6 )
                return (unsigned int *)v39;
              v37 = ((v38 + v37) >> 1) + 1;
            }
            else
            {
              v38 = (v38 + v37) >> 1;
            }
          }
          while ( v37 < v38 );
        }
      }
      else
      {
        while ( v12 < v10 )
        {
          v13 = (v12 + v10) >> 1;
          v14 = *(_QWORD *)(v9 + 8 * v13 + 16);
          v15 = *(_QWORD *)(v14 + 8);
          v16 = *(_QWORD *)(v14 + 16);
          if ( v6 < v15 )
          {
            while ( v13 > v12 )
            {
              v21 = (v13 + v12) >> 1;
              v14 = *(_QWORD *)(v9 + 8 * v21 + 16);
              v15 = *(_QWORD *)(v14 + 8);
              v16 = *(_QWORD *)(v14 + 16);
              if ( v6 >= v15 )
                goto LABEL_19;
              v13 = (v13 + v12) >> 1;
            }
            return 0LL;
          }
          v21 = (v12 + v10) >> 1;
          v13 = v10;
LABEL_19:
          if ( v6 < v16 + v15 )
            return (unsigned int *)v14;
          v12 = v21 + 1;
          v10 = v13;
        }
      }
    }
    return 0LL;
  }
  if ( (v8 & 2) == 0 )
    return linear_search_fdes(v7, *(unsigned int **)(v7 + 24), v6, a4, (__int64)a5, a6);
  v33 = *v32;
  if ( !*v32 )
    return 0LL;
  while ( 1 )
  {
    v34 = linear_search_fdes(v7, v33, v6, a4, (__int64)a5, a6);
    if ( v34 )
      break;
    v33 = *++v32;
    if ( !*v32 )
      return 0LL;
  }
  return v34;
}
// 47D593: variable 'v26' is possibly undefined
// 47D593: variable 'v27' is possibly undefined
// 47D593: variable 'v28' is possibly undefined
// 47D593: variable 'v29' is possibly undefined
// 47D667: variable 'a4' is possibly undefined
// 47D667: variable 'a5' is possibly undefined
// 47D667: variable 'a6' is possibly undefined
// 47D692: variable 'a3' is possibly undefined
// 47D7AA: variable 'v44' is possibly undefined
// 47D7AA: variable 'v45' is possibly undefined
// 47D7AA: variable 'v46' is possibly undefined
// 47DA29: variable 'v60' is possibly undefined
// 47DA29: variable 'v61' is possibly undefined
// 47DA29: variable 'v62' is possibly undefined
// 47DA29: variable 'v63' is possibly undefined
// 47DB0C: variable 'v48' is possibly undefined

//----- (000000000047DB20) ----------------------------------------------------
__int64 __fastcall _register_frame_info_bases_part_5(__int64 a1, _QWORD *a2, __int64 a3, __int64 a4)
{
  __int64 v4; // rax
  __int64 result; // rax

  *a2 = -1LL;
  a2[1] = a3;
  a2[2] = a4;
  a2[3] = a1;
  a2[4] = 2040LL;
  v4 = unseen_objects;
  unseen_objects = (__int64)a2;
  a2[5] = v4;
  result = (unsigned int)any_objects_registered;
  if ( !any_objects_registered )
    any_objects_registered = 1;
  return result;
}
// 47DB8A: control flows out of bounds to 0
// 4AB3A8: using guessed type int any_objects_registered;
// 4AB3B8: using guessed type __int64 unseen_objects;

//----- (000000000047DBB0) ----------------------------------------------------
__int64 __fastcall _register_frame_info_bases(unsigned int *a1, _QWORD *a2, __int64 a3, __int64 a4)
{
  __int64 result; // rax

  if ( a1 )
  {
    result = *a1;
    if ( (_DWORD)result )
      return _register_frame_info_bases_part_5((__int64)a1, a2, a3, a4);
  }
  return result;
}

//----- (000000000047DBD0) ----------------------------------------------------
__int64 __fastcall _register_frame_info(unsigned int *a1, _QWORD *a2)
{
  __int64 result; // rax

  if ( a1 )
  {
    result = *a1;
    if ( (_DWORD)result )
      return _register_frame_info_bases_part_5((__int64)a1, a2, 0LL, 0LL);
  }
  return result;
}

//----- (000000000047DC00) ----------------------------------------------------
__int64 __fastcall _register_frame(unsigned int *a1, __int64 a2, _QWORD *a3, __int64 a4, u32 *a5, __int64 a6)
{
  __int64 result; // rax
  _QWORD *v7; // rax

  result = *a1;
  if ( (_DWORD)result )
  {
    v7 = malloc(0x30uLL, a2, a3, a4, a5, a6);
    return _register_frame_info_bases_part_5((__int64)a1, v7, 0LL, 0LL);
  }
  return result;
}

//----- (000000000047DC30) ----------------------------------------------------
__int64 __fastcall _register_frame_info_table_bases(__int64 a1, _QWORD *a2, __int64 a3, __int64 a4)
{
  __int64 v4; // rax
  __int64 result; // rax

  *a2 = -1LL;
  a2[1] = a3;
  a2[2] = a4;
  a2[3] = a1;
  a2[4] = 2042LL;
  v4 = unseen_objects;
  unseen_objects = (__int64)a2;
  a2[5] = v4;
  result = (unsigned int)any_objects_registered;
  if ( !any_objects_registered )
    any_objects_registered = 1;
  return result;
}
// 47DC9E: control flows out of bounds to 0
// 4AB3A8: using guessed type int any_objects_registered;
// 4AB3B8: using guessed type __int64 unseen_objects;

//----- (000000000047DCC0) ----------------------------------------------------
__int64 __fastcall _register_frame_info_table(__int64 a1, _QWORD *a2)
{
  return _register_frame_info_table_bases(a1, a2, 0LL, 0LL);
}

//----- (000000000047DCD0) ----------------------------------------------------
__int64 __fastcall _register_frame_table(__int64 a1, __int64 a2, _QWORD *a3, __int64 a4, u32 *a5, __int64 a6)
{
  _QWORD *v6; // rax

  v6 = malloc(0x30uLL, a2, a3, a4, a5, a6);
  return _register_frame_info_table_bases(a1, v6, 0LL, 0LL);
}

//----- (000000000047DD00) ----------------------------------------------------
__int64 __fastcall _deregister_frame_info_bases(
        _DWORD *a1,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        u32 *a5,
        unsigned __int64 a6)
{
  _DWORD *v6; // rbp
  __int64 v7; // rax
  __int64 v9; // rdx
  __int64 v10; // rbx
  __int64 *v11; // rax

  if ( !a1 || !*a1 )
    return 0LL;
  v6 = a1;
  v7 = unseen_objects;
  if ( unseen_objects )
  {
    if ( a1 == *(_DWORD **)(unseen_objects + 24) )
    {
      v10 = unseen_objects;
      v11 = &unseen_objects;
    }
    else
    {
      while ( 1 )
      {
        v10 = *(_QWORD *)(v7 + 40);
        if ( !v10 )
          goto LABEL_9;
        if ( a1 == *(_DWORD **)(v10 + 24) )
          break;
        v7 = *(_QWORD *)(v7 + 40);
      }
      v11 = (__int64 *)(v7 + 40);
    }
LABEL_15:
    *v11 = *(_QWORD *)(v10 + 40);
    return v10;
  }
LABEL_9:
  v10 = seen_objects;
  if ( !seen_objects )
LABEL_19:
    abort((__int64)a1, a2, a3, a4, a5, a6);
  v11 = &seen_objects;
  while ( 1 )
  {
    a1 = *(_DWORD **)(v10 + 24);
    if ( (*(_BYTE *)(v10 + 32) & 1) != 0 )
      break;
    if ( v6 == a1 )
      goto LABEL_15;
LABEL_12:
    v11 = (__int64 *)(v10 + 40);
    v10 = *(_QWORD *)(v10 + 40);
    if ( !v10 )
      goto LABEL_19;
  }
  if ( v6 != *(_DWORD **)a1 )
    goto LABEL_12;
  v9 = *(_QWORD *)(v10 + 40);
  *v11 = v9;
  free((__int64)a1, a2, v9, a4, a5, a6);
  return v10;
}
// 4AB3B0: using guessed type __int64 seen_objects;
// 4AB3B8: using guessed type __int64 unseen_objects;

//----- (000000000047DE20) ----------------------------------------------------
__int64 __fastcall _deregister_frame_info(_DWORD *a1, __int64 a2, __int64 a3, __int64 a4, u32 *a5, unsigned __int64 a6)
{
  return _deregister_frame_info_bases(a1, a2, a3, a4, a5, a6);
}

//----- (000000000047DE30) ----------------------------------------------------
__int64 *__fastcall _deregister_frame(_DWORD *a1, __int64 a2, __int64 a3, __int64 a4, u32 *a5, unsigned __int64 a6)
{
  __int64 *result; // rax
  __int64 v7; // rax
  __int64 v8; // rdx
  __int64 v9; // rcx
  u32 *v10; // r8
  unsigned __int64 v11; // r9

  result = (__int64 *)(unsigned int)*a1;
  if ( (_DWORD)result )
  {
    v7 = _deregister_frame_info_bases(a1, a2, a3, a4, a5, a6);
    return free(v7, a2, v8, v9, v10, v11);
  }
  return result;
}
// 47DE50: variable 'v8' is possibly undefined
// 47DE50: variable 'v9' is possibly undefined
// 47DE50: variable 'v10' is possibly undefined
// 47DE50: variable 'v11' is possibly undefined

//----- (000000000047DE60) ----------------------------------------------------
unsigned int *__fastcall Unwind_Find_FDE(
        unsigned __int64 a1,
        _QWORD *a2,
        unsigned __int64 a3,
        __int64 *a4,
        u32 *a5,
        __int64 a6)
{
  unsigned int *v7; // rbp
  __int64 v9; // rbx
  __int16 v10; // r13
  __int64 v11; // rax
  __int64 v12; // rdi
  unsigned __int64 *v13; // rax
  unsigned __int64 v14; // [rsp+0h] [rbp-68h] BYREF
  __int64 v15; // [rsp+8h] [rbp-60h]
  __int64 v16; // [rsp+10h] [rbp-58h]
  __int64 v17; // [rsp+18h] [rbp-50h]
  unsigned int *v18; // [rsp+20h] [rbp-48h]
  int v19; // [rsp+28h] [rbp-40h]

  if ( !any_objects_registered )
  {
LABEL_2:
    v14 = a1;
    v15 = 0LL;
    v16 = 0LL;
    v17 = 0LL;
    v18 = 0LL;
    v19 = 1;
    if ( (int)dl_iterate_phdr(
                (__int64 (__fastcall *)(__int64 *, __int64, __int64))Unwind_IteratePhdrCallback,
                (__int64)&v14) < 0 )
      return 0LL;
    v7 = v18;
    if ( v18 )
    {
      *a2 = v15;
      a2[1] = v16;
      a2[2] = v17;
    }
    return v7;
  }
  v9 = seen_objects;
  if ( !seen_objects )
    goto LABEL_14;
  while ( a1 < *(_QWORD *)v9 )
  {
    v9 = *(_QWORD *)(v9 + 40);
    if ( !v9 )
      goto LABEL_14;
  }
  v7 = search_object(v9, a1, a3, (__int64)a4, a5, a6);
  if ( !v7 )
  {
LABEL_14:
    do
    {
      v9 = unseen_objects;
      if ( !unseen_objects )
        goto LABEL_2;
      v12 = unseen_objects;
      unseen_objects = *(_QWORD *)(unseen_objects + 40);
      v7 = search_object(v12, a1, a3, (__int64)a4, a5, a6);
      v13 = (unsigned __int64 *)seen_objects;
      if ( seen_objects && (a3 = *(_QWORD *)v9, *(_QWORD *)seen_objects >= *(_QWORD *)v9) )
      {
        do
        {
          a4 = (__int64 *)(v13 + 5);
          v13 = (unsigned __int64 *)v13[5];
        }
        while ( v13 && *v13 >= a3 );
      }
      else
      {
        a4 = &seen_objects;
      }
      *(_QWORD *)(v9 + 40) = v13;
      *a4 = v9;
    }
    while ( !v7 );
  }
  *a2 = *(_QWORD *)(v9 + 8);
  a2[1] = *(_QWORD *)(v9 + 16);
  if ( (*(_BYTE *)(v9 + 32) & 4) != 0 )
    LOBYTE(v10) = get_cie_encoding((_BYTE *)v7 - (int)v7[1] + 4);
  else
    v10 = *(_WORD *)(v9 + 32) >> 3;
  v11 = base_from_object(v10, v9, a3, (__int64)a4, a5, a6);
  read_encoded_value_with_base_0(v10, v11, (__int64)(v7 + 2), &v14);
  a2[2] = v14;
  return v7;
}
// 47DF99: variable 'a3' is possibly undefined
// 47DF99: variable 'a4' is possibly undefined
// 47DF99: variable 'a5' is possibly undefined
// 47DF99: variable 'a6' is possibly undefined
// 4AB3A8: using guessed type int any_objects_registered;
// 4AB3B0: using guessed type __int64 seen_objects;
// 4AB3B8: using guessed type __int64 unseen_objects;

//----- (000000000047E0B0) ----------------------------------------------------
__int64 __fastcall base_of_encoded_value_0(__int64 a1, __int64 a2, __int64 a3, __int64 a4, u32 *a5, u32 a6)
{
  unsigned __int8 v6; // al

  if ( (_BYTE)a1 == 0xFF )
    return 0LL;
  v6 = a1 & 0x70;
  if ( (a1 & 0x70) == 32 )
    return Unwind_GetTextRelBase(a2);
  if ( v6 <= 0x20u )
  {
    if ( v6 && v6 != 16 )
      goto LABEL_13;
    return 0LL;
  }
  if ( v6 != 64 )
  {
    if ( v6 != 80 )
    {
      if ( v6 == 48 )
        return Unwind_GetDataRelBase(a2);
LABEL_13:
      abort(a1, a2, a3, a4, a5, a6);
    }
    return 0LL;
  }
  return Unwind_GetRegionStart(a2);
}

//----- (000000000047E100) ----------------------------------------------------
_QWORD *__fastcall read_encoded_value_with_base_1(char a1, __int64 a2, __int64 a3, _QWORD *a4)
{
  __int64 *v4; // rax
  __int64 v5; // r8
  _QWORD *result; // rax

  if ( a1 != 80 )
  {
    if ( (a1 & 0xFu) <= 0xC )
      __asm { jmp     rax }
    read_encoded_value_with_base_cold_0();
  }
  v4 = (__int64 *)((a3 + 7) & 0xFFFFFFFFFFFFFFF8LL);
  v5 = *v4;
  result = v4 + 1;
  *a4 = v5;
  return result;
}
// 4015E1: using guessed type void __noreturn read_encoded_value_with_base_cold_0(void);

//----- (000000000047E250) ----------------------------------------------------
__int64 __fastcall _gcc_personality_v0(int a1, char a2, __int64 a3, __int64 a4, __int64 a5)
{
  __int64 result; // rax
  __int64 v7; // rdx
  __int64 v8; // rcx
  unsigned __int8 *LanguageSpecificData; // rbx
  u32 *v10; // r8
  u32 v11; // er9
  __int64 RegionStart; // rax
  unsigned __int8 v13; // di
  char *v14; // r12
  __int64 v15; // rax
  char *v16; // rsi
  __int64 v17; // rdi
  int v18; // ecx
  unsigned __int64 v19; // rax
  _QWORD *v20; // r15
  __int64 v21; // rdi
  int v22; // ecx
  unsigned __int64 v23; // rax
  __int64 IPInfo; // rax
  __int64 v25; // rdx
  __int64 v26; // rcx
  u32 *v27; // r8
  u32 v28; // er9
  unsigned __int64 v29; // rbx
  char v30; // bp
  __int64 v31; // rax
  _QWORD *v32; // rax
  char v33; // bp
  __int64 v34; // r15
  __int64 v35; // rdx
  __int64 v36; // rcx
  u32 *v37; // r8
  u32 v38; // er9
  __int64 v39; // rax
  _QWORD *v40; // rax
  __int64 v41; // rbp
  __int64 v42; // rdx
  __int64 v43; // rcx
  u32 *v44; // r8
  u32 v45; // er9
  __int64 v46; // rax
  __int64 v47; // rbx
  int v50; // [rsp+14h] [rbp-84h] BYREF
  __int64 v51; // [rsp+18h] [rbp-80h] BYREF
  __int64 v52; // [rsp+20h] [rbp-78h] BYREF
  __int64 v53; // [rsp+28h] [rbp-70h] BYREF
  __int64 v54; // [rsp+30h] [rbp-68h]
  __int64 v55; // [rsp+38h] [rbp-60h] BYREF
  char *v56; // [rsp+48h] [rbp-50h]
  unsigned __int64 v57; // [rsp+50h] [rbp-48h]
  char v58; // [rsp+58h] [rbp-40h]
  unsigned __int8 v59; // [rsp+59h] [rbp-3Fh]

  result = 3LL;
  v50 = 0;
  if ( a1 == 1 )
  {
    if ( (a2 & 2) != 0 )
    {
      LanguageSpecificData = (unsigned __int8 *)Unwind_GetLanguageSpecificData(a5);
      if ( LanguageSpecificData )
      {
        RegionStart = 0LL;
        if ( a5 )
          RegionStart = Unwind_GetRegionStart(a5);
        v54 = RegionStart;
        v13 = *LanguageSpecificData;
        v14 = (char *)(LanguageSpecificData + 1);
        if ( *LanguageSpecificData == 0xFF )
        {
          v55 = RegionStart;
        }
        else
        {
          v15 = base_of_encoded_value_0(v13, a5, v7, v8, v10, v11);
          v14 = (char *)read_encoded_value_with_base_1(v13, v15, (__int64)v14, &v55);
        }
        v16 = v14 + 1;
        v58 = *v14;
        if ( v58 == -1 )
        {
          v56 = 0LL;
        }
        else
        {
          v17 = 0LL;
          v18 = 0;
          do
          {
            v19 = (unsigned __int64)(*v16++ & 0x7F) << v18;
            v18 += 7;
            v17 |= v19;
          }
          while ( *(v16 - 1) < 0 );
          v56 = &v16[v17];
        }
        v20 = v16 + 1;
        v21 = 0LL;
        v22 = 0;
        v59 = *v16;
        do
        {
          v20 = (_QWORD *)((char *)v20 + 1);
          v23 = (unsigned __int64)(*((_BYTE *)v20 - 1) & 0x7F) << v22;
          v22 += 7;
          v21 |= v23;
        }
        while ( *((char *)v20 - 1) < 0 );
        v57 = (unsigned __int64)v20 + v21;
        IPInfo = Unwind_GetIPInfo(a5, &v50);
        v29 = IPInfo - (v50 == 0);
        while ( v57 > (unsigned __int64)v20 )
        {
          v30 = v59;
          v31 = base_of_encoded_value_0(v59, 0LL, v25, v26, v27, v28);
          v32 = read_encoded_value_with_base_1(v30, v31, (__int64)v20, &v51);
          v33 = v59;
          v34 = (__int64)v32;
          v39 = base_of_encoded_value_0(v59, 0LL, v35, v36, v37, v38);
          v40 = read_encoded_value_with_base_1(v33, v39, v34, &v52);
          LOBYTE(v34) = v59;
          v41 = (__int64)v40;
          v46 = base_of_encoded_value_0(v59, 0LL, v42, v43, v44, v45);
          v20 = read_encoded_value_with_base_1(v34, v46, v41, &v53);
          do
            v20 = (_QWORD *)((char *)v20 + 1);
          while ( *((char *)v20 - 1) < 0 );
          if ( v54 + v51 > v29 )
            break;
          if ( v52 + v54 + v51 > v29 )
          {
            if ( v53 )
            {
              v47 = v55 + v53;
              if ( v55 + v53 )
              {
                Unwind_SetGR(a5, 0, a4);
                Unwind_SetGR(a5, 1, 0LL);
                Unwind_SetIP(a5, v47);
                return 7LL;
              }
            }
            return 8LL;
          }
        }
      }
    }
    return 8LL;
  }
  return result;
}
// 47E2E3: variable 'v7' is possibly undefined
// 47E2E3: variable 'v8' is possibly undefined
// 47E2E3: variable 'v10' is possibly undefined
// 47E2E3: variable 'v11' is possibly undefined
// 47E3C1: variable 'v25' is possibly undefined
// 47E3C1: variable 'v26' is possibly undefined
// 47E3C1: variable 'v27' is possibly undefined
// 47E3C1: variable 'v28' is possibly undefined
// 47E3E2: variable 'v35' is possibly undefined
// 47E3E2: variable 'v36' is possibly undefined
// 47E3E2: variable 'v37' is possibly undefined
// 47E3E2: variable 'v38' is possibly undefined
// 47E405: variable 'v42' is possibly undefined
// 47E405: variable 'v43' is possibly undefined
// 47E405: variable 'v44' is possibly undefined
// 47E405: variable 'v45' is possibly undefined

//----- (000000000047E4D0) ----------------------------------------------------
__int64 __fastcall dl_iterate_phdr(__int64 (__fastcall *a1)(__int64 *, __int64, __int64), __int64 a2)
{
  _QWORD *v3; // r14
  __int64 v4; // rbx
  unsigned int v5; // er15
  __int64 v6; // rdi
  __int64 v7; // rax
  __int64 v9[3]; // [rsp+0h] [rbp-88h] BYREF
  __int16 v10; // [rsp+18h] [rbp-70h]
  __int64 v11; // [rsp+20h] [rbp-68h]
  __int64 v12; // [rsp+28h] [rbp-60h]
  __int64 addr_soft; // [rsp+38h] [rbp-50h]
  unsigned __int64 v15; // [rsp+48h] [rbp-40h]

  v15 = __readfsqword(0x28u);
  v3 = dl_ns;
  v4 = (unsigned int)dword_4A9288;
  if ( dl_ns )
  {
    while ( 1 )
    {
      v6 = v3[5];
      v9[0] = *(_QWORD *)v6;
      v7 = *(_QWORD *)(v6 + 8);
      addr_soft = 0LL;
      v9[1] = v7;
      v9[2] = *(_QWORD *)(v6 + 680);
      v10 = *(_WORD *)(v6 + 696);
      v11 = dl_load_adds;
      v12 = dl_load_adds - v4;
      if ( *(_QWORD *)(v6 + 1104) )
        addr_soft = dl_tls_get_addr_soft(v6);
      v5 = a1(v9, 64LL, a2);
      if ( v5 )
        break;
      v3 = (_QWORD *)v3[3];
      if ( !v3 )
        return 0;
    }
  }
  else
  {
    return 0;
  }
  return v5;
}
// 4A9208: using guessed type __int64 dl_load_adds;
// 4A9280: using guessed type void *dl_ns;
// 4A9288: using guessed type int dword_4A9288;

//----- (000000000047E600) ----------------------------------------------------
__int64 *__fastcall free_mem(__int64 a1, __int64 a2, __int64 a3, __int64 a4, u32 *a5, unsigned __int64 a6)
{
  __int64 *i; // rbx
  char *v7; // rdi
  __int64 v8; // rdx
  __int64 v9; // rcx
  u32 *v10; // r8
  unsigned __int64 v11; // r9
  __int64 *result; // rax
  __int64 v13; // rdx
  __int64 v14; // rcx
  u32 *v15; // r8
  unsigned __int64 v16; // r9
  __int64 *v17; // rdi
  __int64 v18; // rbx

  for ( i = (__int64 *)nl_domain_bindings; nl_domain_bindings; i = (__int64 *)nl_domain_bindings )
  {
    v7 = (char *)i[1];
    nl_domain_bindings = *i;
    if ( v7 != "/usr/share/locale" )
      free((__int64)v7, a2, a3, a4, a5, a6);
    free(i[2], a2, a3, a4, a5, a6);
    free((__int64)i, a2, v8, v9, v10, v11);
  }
  if ( nl_current_default_domain != "messages" )
    free((__int64)nl_current_default_domain, a2, a3, a4, a5, a6);
  result = tdestroy((_QWORD *)root, (void (__fastcall *)(_QWORD))free);
  v17 = (__int64 *)transmem_list;
  root = 0LL;
  if ( transmem_list )
  {
    do
    {
      transmem_list = *v17;
      v18 = transmem_list;
      result = free((__int64)v17, (__int64)free, v13, v14, v15, v16);
      v17 = (__int64 *)v18;
    }
    while ( v18 );
  }
  return result;
}
// 47E633: variable 'a3' is possibly undefined
// 47E633: variable 'a4' is possibly undefined
// 47E633: variable 'a5' is possibly undefined
// 47E633: variable 'a6' is possibly undefined
// 47E644: variable 'v8' is possibly undefined
// 47E644: variable 'v9' is possibly undefined
// 47E644: variable 'v10' is possibly undefined
// 47E644: variable 'v11' is possibly undefined
// 47E6AA: variable 'v13' is possibly undefined
// 47E6AA: variable 'v14' is possibly undefined
// 47E6AA: variable 'v15' is possibly undefined
// 47E6AA: variable 'v16' is possibly undefined
// 4A80F0: using guessed type char *nl_current_default_domain;
// 4AA7E0: using guessed type __int64 transmem_list;
// 4AA7E8: using guessed type __int64 root;
// 4AB800: using guessed type __int64 nl_domain_bindings;

//----- (000000000047E6C0) ----------------------------------------------------
__int64 *__fastcall nl_finddomain_subfreeres(
        __int64 a1,
        size_t a2,
        __int64 a3,
        __int64 a4,
        u32 *a5,
        unsigned __int64 a6)
{
  __int64 *v6; // rbx
  __int64 v7; // rdi
  __int64 *v8; // rbp
  __int64 v9; // rdx
  __int64 v10; // rcx
  u32 *v11; // r8
  unsigned __int64 v12; // r9
  __int64 *result; // rax

  v6 = (__int64 *)nl_loaded_domains;
  if ( nl_loaded_domains )
  {
    while ( 1 )
    {
      v7 = v6[2];
      if ( v7 )
        nl_unload_domain(v7, a2, a3, a4, a5, a6);
      v8 = (__int64 *)v6[3];
      free(*v6, a2, a3, a4, a5, a6);
      result = free((__int64)v6, a2, v9, v10, v11, v12);
      if ( !v8 )
        break;
      v6 = v8;
    }
  }
  return result;
}
// 47E6EC: variable 'a3' is possibly undefined
// 47E6EC: variable 'a4' is possibly undefined
// 47E6EC: variable 'a5' is possibly undefined
// 47E6EC: variable 'a6' is possibly undefined
// 47E700: variable 'v9' is possibly undefined
// 47E700: variable 'v10' is possibly undefined
// 47E700: variable 'v11' is possibly undefined
// 47E700: variable 'v12' is possibly undefined
// 4AA878: using guessed type __int64 nl_loaded_domains;

//----- (000000000047E720) ----------------------------------------------------
__int64 *__fastcall nl_unload_domain(__int64 a1, size_t a2, __int64 a3, __int64 a4, u32 *a5, unsigned __int64 a6)
{
  int *v7; // rdi
  unsigned __int64 v8; // rbx
  __int64 *v9; // rdi
  __int64 v10; // rdx
  __int64 *v11; // rbp
  __int64 v12; // rdi
  __int64 v13; // rdx
  __int64 v14; // rcx
  u32 *v15; // r8
  unsigned __int64 v16; // r9
  __int64 v17; // rdx
  __int64 v18; // rcx
  u32 *v19; // r8
  unsigned __int64 v20; // r9
  __int64 v21; // rdx
  __int64 v22; // rcx
  u32 *v23; // r8
  unsigned __int64 v24; // r9

  v7 = *(int **)(a1 + 184);
  if ( v7 != (int *)&_gettext_germanic_plural )
    _gettext_free_exp(v7, a2, a3, a4, a5, a6);
  if ( *(_QWORD *)(a1 + 120) )
  {
    v8 = 0LL;
    do
    {
      v10 = *(_QWORD *)(a1 + 112);
      v11 = (__int64 *)(v10 + 24 * v8);
      free(*v11, a2, v10, a4, a5, a6);
      v12 = v11[2];
      if ( (unsigned __int64)(v12 - 1) <= 0xFFFFFFFFFFFFFFFDLL )
        free(v12, a2, a3, a4, a5, a6);
      v9 = (__int64 *)v11[1];
      if ( v9 != (__int64 *)-1LL )
        _gconv_close(v9, a2, a3, a4, a5, a6);
      ++v8;
    }
    while ( *(_QWORD *)(a1 + 120) > v8 );
  }
  free(*(_QWORD *)(a1 + 112), a2, a3, a4, a5, a6);
  free(*(_QWORD *)(a1 + 32), a2, v13, v14, v15, v16);
  if ( *(_DWORD *)(a1 + 8) )
  {
    a2 = *(_QWORD *)(a1 + 16);
    munmap(*(_QWORD *)a1, a2);
  }
  else
  {
    free(*(_QWORD *)a1, a2, v17, v18, v19, v20);
  }
  return free(a1, a2, v21, v22, v23, v24);
}
// 47E75A: variable 'a3' is possibly undefined
// 47E75A: variable 'a4' is possibly undefined
// 47E75A: variable 'a5' is possibly undefined
// 47E75A: variable 'a6' is possibly undefined
// 47E7BE: variable 'v13' is possibly undefined
// 47E7BE: variable 'v14' is possibly undefined
// 47E7BE: variable 'v15' is possibly undefined
// 47E7BE: variable 'v16' is possibly undefined
// 47E7E1: variable 'v21' is possibly undefined
// 47E7E1: variable 'v22' is possibly undefined
// 47E7E1: variable 'v23' is possibly undefined
// 47E7E1: variable 'v24' is possibly undefined
// 47E7F4: variable 'v17' is possibly undefined
// 47E7F4: variable 'v18' is possibly undefined
// 47E7F4: variable 'v19' is possibly undefined
// 47E7F4: variable 'v20' is possibly undefined

//----- (000000000047E810) ----------------------------------------------------
__int64 *__fastcall buffer_free(__int64 a1, __int64 a2, __int64 a3, __int64 a4, u32 *a5, unsigned __int64 a6)
{
  __int64 v6; // rbx
  __int64 *result; // rax

  v6 = freeres_list;
  for ( dealloc_buffers = 1; v6; freeres_list = v6 )
  {
    result = free(*(_QWORD *)(v6 + 176), a2, a3, a4, a5, a6);
    v6 = *(_QWORD *)(v6 + 168);
  }
  return result;
}
// 47E837: variable 'a3' is possibly undefined
// 47E837: variable 'a4' is possibly undefined
// 47E837: variable 'a5' is possibly undefined
// 47E837: variable 'a6' is possibly undefined
// 4AAD10: using guessed type __int64 freeres_list;
// 4AAD18: using guessed type char dealloc_buffers;

//----- (000000000047E860) ----------------------------------------------------
__int64 *__fastcall free_derivation(__int64 a1, __int64 a2, __int64 a3, __int64 a4, u32 *a5, unsigned __int64 a6)
{
  __int64 v6; // rdx
  __int64 v7; // rbx
  unsigned __int64 v8; // rbp
  _QWORD *v9; // rax
  void (__fastcall *v10)(__int64); // r12
  __int64 v11; // rcx
  u32 *v12; // r8
  unsigned __int64 v13; // r9
  __int64 v14; // rdx
  __int64 v15; // rcx
  u32 *v16; // r8
  unsigned __int64 v17; // r9

  v6 = *(_QWORD *)(a1 + 16);
  if ( *(_QWORD *)(a1 + 24) )
  {
    v7 = 0LL;
    v8 = 0LL;
    do
    {
      v9 = (_QWORD *)(v6 + v7);
      a4 = *(unsigned int *)(v6 + v7 + 16);
      if ( (int)a4 > 0 )
      {
        if ( *v9 )
        {
          v10 = (void (__fastcall *)(__int64))(__readfsqword(0x30u) ^ __ROR8__(v9[8], 17));
          if ( v10 )
          {
            dl_mcount_wrapper_check((__int64)v10);
            v10(v7 + *(_QWORD *)(a1 + 16));
            v6 = *(_QWORD *)(a1 + 16);
          }
        }
      }
      ++v8;
      v7 += 104LL;
    }
    while ( *(_QWORD *)(a1 + 24) > v8 );
  }
  if ( v6 )
  {
    free(*(_QWORD *)(v6 + 24), a2, v6, a4, a5, a6);
    free(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 104LL * *(_QWORD *)(a1 + 24) - 72), a2, *(_QWORD *)(a1 + 16), v11, v12, v13);
    free(*(_QWORD *)(a1 + 16), a2, v14, v15, v16, v17);
  }
  return free(a1, a2, v6, a4, a5, a6);
}
// 47E8D4: variable 'a4' is possibly undefined
// 47E8D4: variable 'a5' is possibly undefined
// 47E8D4: variable 'a6' is possibly undefined
// 47E8F1: variable 'v11' is possibly undefined
// 47E8F1: variable 'v12' is possibly undefined
// 47E8F1: variable 'v13' is possibly undefined
// 47E8FA: variable 'v14' is possibly undefined
// 47E8FA: variable 'v15' is possibly undefined
// 47E8FA: variable 'v16' is possibly undefined
// 47E8FA: variable 'v17' is possibly undefined
// 47E90C: variable 'v6' is possibly undefined

//----- (000000000047E920) ----------------------------------------------------
__int64 *__fastcall free_modules_db(_QWORD *a1, __int64 a2, __int64 a3, __int64 a4, u32 *a5, unsigned __int64 a6)
{
  _QWORD *v6; // rbx
  __int64 v7; // rdi
  __int64 v8; // rdi
  __int64 *result; // rax
  __int64 v10; // rbp
  __int64 v11; // rdi

  v6 = a1;
  v7 = a1[4];
  if ( v7 )
    free_modules_db(v7, a2, a3, a4, a5, a6);
  v8 = v6[6];
  if ( v8 )
    free_modules_db(v8, a2, a3, a4, a5, a6);
  do
  {
    while ( 1 )
    {
      result = (__int64 *)v6[3];
      v10 = v6[5];
      if ( *(_BYTE *)result == 47 )
        break;
      v6 = (_QWORD *)v6[5];
      if ( !v10 )
        return result;
    }
    v11 = (__int64)v6;
    v6 = (_QWORD *)v6[5];
    result = free(v11, a2, a3, a4, a5, a6);
  }
  while ( v10 );
  return result;
}
// 47E940: variable 'a3' is possibly undefined
// 47E940: variable 'a4' is possibly undefined
// 47E940: variable 'a5' is possibly undefined
// 47E940: variable 'a6' is possibly undefined

//----- (000000000047E980) ----------------------------------------------------
__int64 *__fastcall free_mem_0(
        __int64 a1,
        __int64 *(__fastcall *a2)(__int64 a1, __int64 a2, __int64 a3, __int64 a4, u32 *a5, unsigned __int64 a6),
        __int64 a3,
        __int64 a4,
        u32 *a5,
        unsigned __int64 a6)
{
  __int64 v6; // rdx
  __int64 v7; // rcx
  u32 *v8; // r8
  unsigned __int64 v9; // r9
  __int64 *result; // rax
  __int64 v11; // rdx
  __int64 v12; // rcx
  u32 *v13; // r8
  unsigned __int64 v14; // r9

  nl_locale_subfreeres(a1, (__int64)a2, a3, a4, a5, a6);
  result = nl_finddomain_subfreeres(a1, (size_t)a2, v6, v7, v8, v9);
  if ( _gconv_alias_db )
  {
    a2 = free;
    result = tdestroy((_QWORD *)_gconv_alias_db, (void (__fastcall *)(_QWORD))free);
  }
  if ( _gconv_modules_db )
    result = free_modules_db((_QWORD *)_gconv_modules_db, (__int64)a2, v11, v12, v13, v14);
  if ( known_derivations )
    return tdestroy((_QWORD *)known_derivations, (void (__fastcall *)(_QWORD))free_derivation);
  return result;
}
// 47E98D: variable 'v6' is possibly undefined
// 47E98D: variable 'v7' is possibly undefined
// 47E98D: variable 'v8' is possibly undefined
// 47E98D: variable 'v9' is possibly undefined
// 47E9B6: variable 'v11' is possibly undefined
// 47E9B6: variable 'v12' is possibly undefined
// 47E9B6: variable 'v13' is possibly undefined
// 47E9B6: variable 'v14' is possibly undefined
// 4AAE78: using guessed type __int64 known_derivations;
// 4AB968: using guessed type __int64 _gconv_modules_db;
// 4AB978: using guessed type __int64 _gconv_alias_db;

//----- (000000000047E9F0) ----------------------------------------------------
__int64 *__fastcall free_mem_1(__int64 a1, __int64 a2, __int64 a3, __int64 a4, u32 *a5, unsigned __int64 a6)
{
  __int64 *result; // rax

  if ( _gconv_path_elem )
  {
    result = (__int64 *)&empty_path_elem;
    if ( (_UNKNOWN *)_gconv_path_elem != &empty_path_elem )
      return free(_gconv_path_elem, a2, a3, a4, a5, a6);
  }
  return result;
}
// 4AB990: using guessed type __int64 _gconv_path_elem;

//----- (000000000047EA20) ----------------------------------------------------
unsigned __int64 __fastcall free_mem_2(__int64 a1, __int64 a2, __int64 a3, __int64 a4, u32 *a5, unsigned __int64 a6)
{
  unsigned __int64 result; // rax

  result = (unsigned int)cache_malloced;
  if ( cache_malloced )
    return (unsigned __int64)free(gconv_cache, a2, a3, a4, a5, a6);
  if ( gconv_cache )
    return munmap(gconv_cache, cache_size);
  return result;
}
// 4AAE88: using guessed type int cache_malloced;
// 4AAE90: using guessed type __int64 cache_size;
// 4AAE98: using guessed type __int64 gconv_cache;

//----- (000000000047EA60) ----------------------------------------------------
__int64 *__fastcall do_release_all(__int64 a1, __int64 a2, __int64 a3, __int64 a4, u32 *a5, unsigned __int64 a6)
{
  __int64 v7; // rdi

  v7 = *(_QWORD *)(a1 + 16);
  if ( v7 )
    _libc_dlclose(v7, a2, a3, a4, (__int64)a5, a6);
  return free(a1, a2, a3, a4, a5, a6);
}
// 47EA7A: variable 'a3' is possibly undefined
// 47EA7A: variable 'a4' is possibly undefined
// 47EA7A: variable 'a5' is possibly undefined
// 47EA7A: variable 'a6' is possibly undefined

//----- (000000000047EA80) ----------------------------------------------------
__int64 *free_mem_3()
{
  __int64 *result; // rax

  result = tdestroy((_QWORD *)loaded, (void (__fastcall *)(_QWORD))do_release_all);
  loaded = 0LL;
  return result;
}
// 4AAEA8: using guessed type __int64 loaded;

//----- (000000000047EAB0) ----------------------------------------------------
__int64 *__fastcall free_category(int a1, void **a2, void **a3, __int64 a4, u32 *a5, unsigned __int64 a6)
{
  __int64 *result; // rax
  __int64 *v8; // rbx
  __int64 v9; // rbp
  const char *v10; // rdi
  void **v11; // rdi
  __int64 *v12; // rbp
  __int64 v13; // rdx
  __int64 v14; // rcx
  u32 *v15; // r8
  unsigned __int64 v16; // r9

  result = nl_locale_file_list;
  v8 = (__int64 *)nl_locale_file_list[a1];
  if ( a2 != a3 )
  {
    result = nl_current_used;
    if ( nl_current_used[a1] )
    {
      nl_global_locale[a1] = (char **)a3;
      result = (__int64 *)nl_category_postload[a1];
      if ( result )
        result = (__int64 *)((int (*(__fastcall *)())[256])result)();
    }
    v9 = a1 + 16LL;
    v10 = (const char *)nl_global_locale[v9];
    if ( v10 != "C" )
    {
      result = free((__int64)v10, (__int64)a2, (__int64)a3, a4, a5, a6);
      nl_global_locale[v9] = (char **)"C";
    }
  }
  if ( v8 )
  {
    while ( 1 )
    {
      v11 = (void **)v8[2];
      if ( v11 )
      {
        if ( a3 != v11 )
          nl_unload_locale((__int64)v11, (size_t)a2, (__int64)a3, a4, a5, a6);
      }
      v12 = (__int64 *)v8[3];
      free(*v8, (__int64)a2, (__int64)a3, a4, a5, a6);
      result = free((__int64)v8, (__int64)a2, v13, v14, v15, v16);
      if ( !v12 )
        break;
      v8 = v12;
    }
  }
  return result;
}
// 47EB0F: variable 'a3' is possibly undefined
// 47EB0F: variable 'a4' is possibly undefined
// 47EB0F: variable 'a5' is possibly undefined
// 47EB0F: variable 'a6' is possibly undefined
// 47EB45: variable 'v13' is possibly undefined
// 47EB45: variable 'v14' is possibly undefined
// 47EB45: variable 'v15' is possibly undefined
// 47EB45: variable 'v16' is possibly undefined
// 4A7C60: using guessed type __int64 (__fastcall *nl_category_postload[16])();
// 4A7CE0: using guessed type _QWORD nl_current_used[16];
// 4A9A60: using guessed type char **nl_global_locale[6];
// 4AB9A0: using guessed type _QWORD nl_locale_file_list[13];

//----- (000000000047EB60) ----------------------------------------------------
void __fastcall nl_locale_subfreeres(__int64 a1, __int64 a2, __int64 a3, __int64 a4, u32 *a5, unsigned __int64 a6)
{
  __int64 v6; // rcx
  u32 *v7; // r8
  unsigned __int64 v8; // r9
  void **v9; // rsi
  __int64 v10; // rcx
  u32 *v11; // r8
  unsigned __int64 v12; // r9
  __int64 v13; // rdx
  __int64 v14; // rcx
  u32 *v15; // r8
  unsigned __int64 v16; // r9
  char *v17; // rdi

  free_category(0, *(void ***)__readfsqword(0xFFFFFFA0), (void **)&nl_C_LC_CTYPE, a4, a5, a6);
  free_category(4, *(void ***)__readfsqword(0xFFFFFFB0), (void **)&nl_C_LC_MONETARY, v6, v7, v8);
  v9 = *(void ***)__readfsqword(0xFFFFFFB8);
  free_category(1, v9, (void **)&nl_C_LC_NUMERIC, v10, v11, v12);
  v17 = off_4A9B10[0];
  if ( off_4A9B10[0] != "C" )
  {
    free((__int64)off_4A9B10[0], (__int64)v9, v13, v14, v15, v16);
    off_4A9B10[0] = "C";
  }
  nl_archive_subfreeres((__int64)v17, (__int64)v9, v13, v14, v15, v16);
}
// 47EBD8: variable 'v6' is possibly undefined
// 47EBD8: variable 'v7' is possibly undefined
// 47EBD8: variable 'v8' is possibly undefined
// 47EC01: variable 'v10' is possibly undefined
// 47EC01: variable 'v11' is possibly undefined
// 47EC01: variable 'v12' is possibly undefined
// 47ED61: variable 'v13' is possibly undefined
// 47ED61: variable 'v14' is possibly undefined
// 47ED61: variable 'v15' is possibly undefined
// 47ED61: variable 'v16' is possibly undefined
// 4A51E0: using guessed type char *nl_C_LC_CTYPE;
// 4A6420: using guessed type char *nl_C_LC_MONETARY;
// 4A65E0: using guessed type char *nl_C_LC_NUMERIC;
// 4A9B10: using guessed type char *off_4A9B10[7];

//----- (000000000047ED80) ----------------------------------------------------
void __fastcall nl_archive_subfreeres(__int64 a1, __int64 a2, __int64 a3, __int64 a4, u32 *a5, unsigned __int64 a6)
{
  _QWORD *v6; // rbp
  _QWORD *v7; // r12
  __int64 v8; // rbx
  __int64 v9; // rdx
  __int64 v10; // rcx
  u32 *v11; // r8
  unsigned __int64 v12; // r9
  __int64 v13; // rdi
  void (*v14)(void); // rax
  __int64 v15; // rdi
  __int64 v16; // rbx
  size_t v17; // rsi
  unsigned __int64 v18; // rdi
  __int64 v19; // rbx
  size_t v20; // rsi
  __int64 v21; // rbp
  __int64 v22; // rdx
  __int64 v23; // rcx
  u32 *v24; // r8
  unsigned __int64 v25; // r9

  v6 = (_QWORD *)archloaded;
  if ( archloaded )
  {
    do
    {
      v7 = (_QWORD *)*v6;
      v8 = 0LL;
      free(v6[1], a2, a3, a4, a5, a6);
      while ( 1 )
      {
        if ( v8 != 6 )
        {
          v13 = v6[v8 + 2];
          if ( v13 )
          {
            v14 = *(void (**)(void))(v13 + 32);
            if ( v14 )
            {
              v14();
              v13 = v6[v8 + 2];
            }
            free(v13, a2, v9, v10, v11, v12);
          }
          if ( (_DWORD)v8 == 12 )
            break;
        }
        ++v8;
      }
      v15 = (__int64)v6;
      v6 = v7;
      free(v15, a2, v9, v10, v11, v12);
    }
    while ( v7 );
  }
  v16 = archmapped;
  archloaded = 0LL;
  if ( archmapped )
  {
    if ( (__int64 *)archmapped != &headmap )
      _assert_fail((__int64)"archmapped == &headmap", (__int64)"loadarchive.c", 0x216u, "_nl_archive_subfreeres");
    v17 = *(unsigned int *)(archmapped + 12);
    v18 = *(_QWORD *)archmapped;
    archmapped = 0LL;
    munmap(v18, v17);
    v19 = *(_QWORD *)(v16 + 16);
    if ( v19 )
    {
      do
      {
        v20 = *(unsigned int *)(v19 + 12);
        v21 = *(_QWORD *)(v19 + 16);
        munmap(*(_QWORD *)v19, v20);
        free(v19, v20, v22, v23, v24, v25);
        v19 = v21;
      }
      while ( v21 );
    }
  }
}
// 47EDA2: variable 'a3' is possibly undefined
// 47EDA2: variable 'a4' is possibly undefined
// 47EDA2: variable 'a5' is possibly undefined
// 47EDA2: variable 'a6' is possibly undefined
// 47EDD4: variable 'v9' is possibly undefined
// 47EDD4: variable 'v10' is possibly undefined
// 47EDD4: variable 'v11' is possibly undefined
// 47EDD4: variable 'v12' is possibly undefined
// 47EE42: variable 'v22' is possibly undefined
// 47EE42: variable 'v23' is possibly undefined
// 47EE42: variable 'v24' is possibly undefined
// 47EE42: variable 'v25' is possibly undefined
// 4AAF00: using guessed type __int64 archloaded;
// 4AAFB0: using guessed type __int64 headmap;
// 4AAFC8: using guessed type __int64 archmapped;

//----- (000000000047EE80) ----------------------------------------------------
__int64 *__fastcall free_mem_4(__int64 a1, __int64 a2, __int64 a3, __int64 a4, u32 *a5, unsigned __int64 a6)
{
  __int64 *result; // rax

  clearenv(a1, a2, a3, a4, a5, a6);
  result = tdestroy((_QWORD *)known_values, (void (__fastcall *)(_QWORD))free);
  known_values = 0LL;
  return result;
}
// 4AAFD8: using guessed type __int64 known_values;

//----- (000000000047EEB0) ----------------------------------------------------
__int64 *__fastcall free_mem_5(__int64 a1, __int64 a2, __int64 a3, __int64 a4, u32 *a5, unsigned __int64 a6)
{
  __int64 *result; // rax
  __int64 i; // rbp
  _QWORD *v8; // rdi
  _QWORD *v9; // rbx

  result = (__int64 *)_printf_modifier_table;
  if ( _printf_modifier_table )
  {
    for ( i = 0LL; i != 255; ++i )
    {
      v8 = (_QWORD *)result[i];
      if ( v8 )
      {
        do
        {
          v9 = (_QWORD *)*v8;
          free((__int64)v8, a2, a3, a4, a5, a6);
          v8 = v9;
        }
        while ( v9 );
        result = (__int64 *)_printf_modifier_table;
      }
    }
    return free((__int64)result, a2, a3, a4, a5, a6);
  }
  return result;
}
// 47EEE3: variable 'a3' is possibly undefined
// 47EEE3: variable 'a4' is possibly undefined
// 47EEE3: variable 'a5' is possibly undefined
// 47EEE3: variable 'a6' is possibly undefined
// 4ABA10: using guessed type __int64 _printf_modifier_table;

//----- (000000000047EF20) ----------------------------------------------------
__int64 __fastcall free_slotinfo(__int64 **a1)
{
  __int64 result; // rax
  __int64 v3; // rdx
  __int64 v4; // rcx
  u32 *v5; // r8
  unsigned __int64 v6; // r9
  __int64 *v7; // rdi
  __int64 v8; // rsi
  unsigned __int8 v9; // [rsp+1h] [rbp-9h]

  result = 1LL;
  if ( *a1 )
  {
    result = free_slotinfo((__int64 **)*a1 + 1);
    if ( (_BYTE)result )
    {
      v7 = *a1;
      v8 = **a1;
      if ( v8 )
      {
        if ( v7[3] )
          return 0LL;
        v3 = 0LL;
        while ( ++v3 != v8 )
        {
          v4 = 16 * v3;
          if ( v7[2 * v3 + 3] )
            return 0LL;
        }
      }
      v9 = result;
      free((__int64)v7, v8, v3, v4, v5, v6);
      *a1 = 0LL;
      return v9;
    }
  }
  return result;
}
// 47EF7C: variable 'v3' is possibly undefined
// 47EF7C: variable 'v4' is possibly undefined
// 47EF7C: variable 'v5' is possibly undefined
// 47EF7C: variable 'v6' is possibly undefined

//----- (000000000047EFB0) ----------------------------------------------------
__int64 *__fastcall free_mem_6(__int64 a1, __int64 a2, __int64 a3, __int64 a4, u32 *a5, unsigned __int64 a6)
{
  _QWORD *v6; // rdi
  _QWORD *v7; // rbx
  _QWORD *v8; // rbp
  __int64 v9; // rax
  __int64 v10; // rdi
  __int64 v11; // rbx
  __int64 v12; // rdi
  __int64 v13; // rdx
  __int64 v14; // rcx
  u32 *v15; // r8
  unsigned __int64 v16; // r9
  __int64 v18; // rcx
  void **v19; // rdx
  __int64 v20; // rdi

  v6 = (_QWORD *)dl_all_dirs;
  if ( dl_all_dirs != dl_init_all_dirs )
  {
    do
    {
      v7 = (_QWORD *)*v6;
      free((__int64)v6, a2, a3, a4, a5, a6);
      v6 = v7;
    }
    while ( (_QWORD *)dl_init_all_dirs != v7 );
  }
  if ( dl_nns )
  {
    v8 = dl_ns;
    if ( dl_ns )
    {
      do
      {
        v9 = v8[7];
        v10 = *(_QWORD *)(v9 + 8);
        *(_QWORD *)(v9 + 8) = 0LL;
        if ( v10 )
        {
          do
          {
            while ( 1 )
            {
              v11 = *(_QWORD *)(v10 + 8);
              if ( !*(_DWORD *)(v10 + 16) )
                break;
              v10 = *(_QWORD *)(v10 + 8);
              if ( !v11 )
                goto LABEL_10;
            }
            free(v10, a2, a3, a4, a5, a6);
            v10 = v11;
          }
          while ( v11 );
        }
LABEL_10:
        if ( (*((_BYTE *)v8 + 798) & 1) != 0 )
          free(v8[120], a2, a3, a4, a5, a6);
        v8[120] = 0LL;
        v8 = (_QWORD *)v8[3];
      }
      while ( v8 );
    }
    if ( qword_4A9298 )
    {
      v18 = (unsigned int)dword_4A9258;
      if ( *((_DWORD *)off_4A9290 + 2) == dword_4A9258 )
      {
        v19 = dl_initial_searchlist;
        v20 = (__int64)*off_4A9290;
        *off_4A9290 = dl_initial_searchlist;
        qword_4A9298 = 0LL;
        free(v20, a2, (__int64)v19, v18, a5, a6);
      }
    }
  }
  free_slotinfo((__int64 **)(dl_tls_dtv_slotinfo_list + 8));
  v12 = dl_scope_free_list;
  dl_scope_free_list = 0LL;
  return free(v12, a2, v13, v14, v15, v16);
}
// 47EFD3: variable 'a3' is possibly undefined
// 47EFD3: variable 'a4' is possibly undefined
// 47EFD3: variable 'a5' is possibly undefined
// 47EFD3: variable 'a6' is possibly undefined
// 47F08F: variable 'v13' is possibly undefined
// 47F08F: variable 'v14' is possibly undefined
// 47F08F: variable 'v15' is possibly undefined
// 47F08F: variable 'v16' is possibly undefined
// 4A9210: using guessed type __int64 dl_nns;
// 4A9250: using guessed type void **dl_initial_searchlist;
// 4A9258: using guessed type int dword_4A9258;
// 4A9280: using guessed type void *dl_ns;
// 4A9290: using guessed type void ***off_4A9290;
// 4A9298: using guessed type __int64 qword_4A9298;
// 4AB7E0: using guessed type __int64 dl_tls_dtv_slotinfo_list;
// 4AB8D8: using guessed type __int64 dl_scope_free_list;
// 4AB8F8: using guessed type __int64 dl_init_all_dirs;
// 4AB920: using guessed type __int64 dl_all_dirs;

// nfuncs=940 queued=890 decompiled=890 lumina nreq=0 worse=0 better=0
#error "There were 9 decompilation failure(s) on 890 function(s)"
