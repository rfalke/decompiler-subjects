/* This file was generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2020 Hex-Rays <info@hex-rays.com>

   Detected compiler: GNU C++
*/

#include <defs.h>

#include <stdarg.h>


//-------------------------------------------------------------------------
// Function declarations

// void __usercall __noreturn _assert_fail_base_cold_0(int@<ebp>, int *@<edi>, const struct timespec *@<esi>, int, int, int, int, int);
void __noreturn nl_load_domain_cold_0(void); // weak
// void __usercall __noreturn abort(int@<ebp>, int *@<edi>, const struct timespec *@<esi>);
// void __usercall __noreturn IO_new_fclose_cold_0(int@<eax>, int *tv_sec@<edx>, struct timespec *@<ecx>, int@<ebp>, int *@<edi>, const struct timespec *@<esi>);
// void __usercall __noreturn IO_fflush_cold_0(int@<eax>, int *tv_sec@<edx>, struct timespec *@<ecx>, int@<ebp>, int *@<edi>, const struct timespec *@<esi>);
// void __usercall __noreturn IO_puts_cold_0(int@<eax>, int *tv_sec@<edx>, struct timespec *@<ecx>, int@<ebp>, int *@<edi>, const struct timespec *@<esi>);
// void __usercall __noreturn IO_wfile_underflow_cold_2(int@<eax>, int *tv_sec@<edx>, struct timespec *@<ecx>, int@<ebp>, int *@<edi>, const struct timespec *@<esi>);
// void __usercall __noreturn IO_new_file_underflow_cold_6(int *@<edx>, struct timespec *@<ecx>, int@<ebp>, int *@<edi>, const struct timespec *@<esi>);
// void __usercall __noreturn dl_start(int@<ebp>, int *@<edi>);
// void __usercall __noreturn IO_fwrite_cold_0(int@<eax>, int *tv_sec@<edx>, struct timespec *@<ecx>, int@<ebp>, int *@<edi>, const struct timespec *@<esi>);
// void __usercall __noreturn IO_getdelim_cold_0(int@<eax>, int *@<edx>, struct timespec *@<ecx>, int@<ebp>, int *@<edi>, const struct timespec *@<esi>);
void __noreturn read_encoded_value_with_base_cold_6(void); // weak
// void __usercall __noreturn execute_cfa_program_cold_7(int@<ebp>, int *@<edi>, const struct timespec *@<esi>);
// void __usercall __noreturn uw_update_context_1_cold_9(int@<ebp>, int *@<edi>, const struct timespec *@<esi>, int);
void __noreturn uw_init_context_1_cold_10(void); // weak
void __noreturn uw_update_context_cold_11(void); // weak
// void __usercall __noreturn Unwind_RaiseException_Phase2_cold_12(int@<ebp>, int *@<edi>, const struct timespec *@<esi>, int, int, int);
// void __usercall __noreturn uw_install_context_1_cold_13(int@<ebp>, int *@<edi>, const struct timespec *@<esi>, int, int, int);
void __fastcall __noreturn Unwind_GetGR_cold_14(_DWORD); // weak
// void __usercall __noreturn Unwind_SetGR_cold_15(int@<ebp>, int *@<edi>, const struct timespec *@<esi>);
// void __usercall __noreturn Unwind_Resume_cold_16(int@<ebp>, int *@<edi>, const struct timespec *@<esi>);
// void __usercall __noreturn Unwind_Resume_or_Rethrow_cold_17(int@<ebp>, int *@<edi>, const struct timespec *@<esi>);
void __noreturn read_encoded_value_with_base_cold_8(void); // weak
void __noreturn read_encoded_value_with_base_cold_0(void); // weak
// const char **__usercall fini@<eax>(int@<ebp>);
int __cdecl main(int argc, const char **argv, const char **envp);
char init_cacheinfo();
void sub_8049997();
// __int16 __usercall get_common_indeces_constprop_1@<ax>(unsigned int _EAX@<eax>, int *@<edx>, unsigned int *@<ecx>, unsigned int *);
void *_x86_get_pc_thunk_ax();
void _x86_get_pc_thunk_di();
// int __usercall check_one_fd@<eax>(int@<eax>, int@<edx>);
int _libc_check_standard_fds();
void _x86_get_pc_thunk_si();
void _libc_setup_tls();
void __cdecl __noreturn _assert_fail_base(unsigned int *, int, int, int, int);
void __cdecl __noreturn _assert_fail(int, int, int, int);
unsigned __int8 *__cdecl dcgettext(char *, unsigned __int8 *, unsigned int);
// int __usercall plural_eval@<eax>(int *@<eax>, int@<edx>, int@<ecx>);
int __cdecl transcmp(int, int);
// _BYTE *__usercall plural_lookup_isra_2@<eax>(int@<eax>, int@<edx>, int@<ecx>, int);
// int __usercall nl_find_msg@<eax>(int@<esi>, int *, int, unsigned __int8 *, int, _DWORD *);
unsigned __int8 *__cdecl _dcigettext(char *, unsigned __int8 *, int, int, int, unsigned int);
__int64 __cdecl nl_find_domain(unsigned int *, unsigned int *, unsigned int *, int);
// unsigned int __usercall nl_load_domain@<eax>(size_t@<ebp>, int@<esi>, int *, int);
int __cdecl alias_compare(char **, unsigned __int8 **);
// int __usercall read_alias_file@<eax>(_BYTE *@<eax>, unsigned int@<edx>);
// int __usercall nl_expand_alias@<eax>(unsigned int@<ebp>, char *);
unsigned int **__cdecl nl_make_l10nflist(unsigned int ***, unsigned int *, unsigned int, int, unsigned int *, unsigned int *, unsigned int *, unsigned int *, unsigned int *, unsigned int *, int);
int *__cdecl nl_normalize_codeset(unsigned __int8 *a1, unsigned int a2);
int __cdecl nl_explode_name(unsigned __int8 *, unsigned __int8 **, _DWORD *, unsigned __int8 **, char **, _DWORD *);
// void __usercall _gettext_free_exp(int ebp0@<ebp>, int *@<edi>, int *);
// int *__usercall new_exp@<eax>(int a1@<eax>, int a2@<edx>, int *a3@<ecx>, int a4@<ebp>);
int __cdecl _gettextparse(unsigned __int8 **);
unsigned int __cdecl _gettext_extract_plural(char *, unsigned __int8 **, unsigned int *);
void _x86_get_pc_thunk_bp();
unsigned int __cdecl _hash_string(unsigned __int8 *);
int setjmp(jmp_buf env);
// _BYTE *__usercall msort_with_tmp_part_0@<eax>(unsigned int *@<eax>, _BYTE *@<edx>, unsigned int@<ecx>);
// unsigned int __usercall qsort_r@<eax>(int@<ebx>, int@<ebp>, int@<edi>, int@<esi>, char *, unsigned int, unsigned int, int (__cdecl *)(char *, char *, int), int);
// unsigned int __usercall qsort@<eax>(int@<ebx>, int@<ebp>, int@<edi>, int@<esi>, char *, unsigned int, unsigned int, int (__cdecl *)(char *, char *, int));
int __cdecl getenv(__int16 *);
// void __usercall __noreturn _run_exit_handlers(int *@<edi>, int status, int, int);
// void __usercall __noreturn exit(int *@<edi>, int status);
char *__cdecl _new_exitfn(int **a1);
// int __usercall _internal_atexit@<eax>(int@<ebp>, int *@<edi>, const struct timespec *@<esi>, int, int, int, int **);
int __cdecl _cxa_atexit(void (__cdecl *lpfunc)(void *), void *obj, void *lpdso_handle);
unsigned int __cdecl _strtoul_internal(unsigned __int8 *, _DWORD *, int, int);
unsigned int __cdecl strtoul(unsigned __int8 *, _DWORD *, int);
unsigned int __cdecl ___strtoul_l_internal(unsigned __int8 *, _DWORD *, int, int, int);
unsigned int __cdecl strtoul_l(unsigned __int8 *, _DWORD *, int, int);
unsigned int __cdecl _correctly_grouped_prefixmb(unsigned int, unsigned int, char *, char *);
// void __usercall printf(int@<ebx>, int@<esi>, unsigned int *, ...);
__int64 asprintf(int **, unsigned int *, ...);
// void __usercall locked_vfxprintf(struct timespec *@<eax>, unsigned int *@<edx>, int@<ecx>);
// int __usercall _fxprintf@<eax>(int@<ebp>, int *@<edi>, struct timespec *, unsigned int *, ...);
// int __usercall _fxprintf_nocancel@<eax>(int@<ebp>, struct timespec *, unsigned int *, const struct timespec);
int __cdecl fclose(struct timespec *);
int __cdecl fflush(const struct timespec *);
int __cdecl _fopen_maybe_mmap(int);
// int *__usercall _fopen_internal@<eax>(int a1@<ebp>, int a2, _BYTE *a3, int a4);
// int *__usercall fopen@<eax>(int a1@<ebp>, int a2, _BYTE *a3);
void _x86_get_pc_thunk_dx();
int __cdecl puts(unsigned int *);
// int __usercall adjust_wide_data@<eax>(_DWORD *@<eax>, char@<dl>);
// int __usercall IO_wfile_underflow@<eax>(int *@<edi>, int *);
int __cdecl IO_wfile_seekoff(int *, signed __int64, int, int);
// int __usercall IO_wfile_underflow_maybe_mmap@<eax>(int@<ebp>, int *);
// int __usercall IO_wfile_underflow_mmap@<eax>(int@<ebp>, _DWORD *);
int __cdecl IO_wdo_write(int *, int, int);
// int __usercall IO_wfile_overflow@<eax>(int *@<edi>, int *, int);
int __cdecl IO_wfile_sync(int *);
unsigned int __cdecl IO_wfile_xsputn(int *, char *, unsigned int);
__int64 __cdecl vasprintf(int **, unsigned int *, int);
unsigned int __cdecl _libc_message(char, char *, char);
void __cdecl __noreturn _libc_fatal(char);
_TBYTE *IO_vtable_check();
_BYTE *__cdecl fgets_unlocked(_BYTE *, int, int *);
int __cdecl IO_file_seekoff_maybe_mmap(_DWORD *, int, int, int);
unsigned int __cdecl IO_file_close(int);
_DWORD *__cdecl IO_new_file_setbuf(_DWORD *, int *, int);
_DWORD *__cdecl IO_file_setbuf_mmap(_DWORD *, int *, int);
// int __usercall new_do_write@<eax>(int@<eax>, unsigned int@<edx>, int@<ecx>);
int __cdecl IO_new_file_underflow(struct timespec *);
unsigned int __cdecl IO_file_close_mmap(int);
// int __usercall mmap_remap_check@<eax>(int@<eax>);
loff_t __cdecl IO_file_seek(int, unsigned int, unsigned int, unsigned int);
int __cdecl IO_file_sync_mmap(_DWORD *);
// unsigned int __usercall decide_maybe_mmap@<eax>(int *@<eax>, int@<ebp>);
// int __usercall IO_file_underflow_maybe_mmap@<eax>(int@<ebp>, int *);
// int __usercall IO_file_xsgetn_maybe_mmap@<eax>(int@<ebp>, int *, int, int);
__int64 __cdecl IO_new_file_seekoff(int *, __int64, int, int);
unsigned int __cdecl IO_file_stat(int, struct stat *);
int __cdecl IO_new_file_write(int, char *, int);
int __cdecl IO_file_xsgetn_mmap(_DWORD *, char *, unsigned int);
// unsigned int __usercall IO_file_xsgetn@<eax>(int *@<edi>, int, int, unsigned int);
int __cdecl IO_file_seekoff_mmap(int, __int64, int, int);
int __cdecl IO_file_underflow_mmap(_DWORD *);
unsigned int __cdecl IO_file_read(int, void *, size_t);
int __cdecl IO_new_file_xsputn(_DWORD *a1, _BYTE *a2, unsigned int a3);
// unsigned int __usercall IO_new_file_init_internal@<eax>(int@<ebp>, int *);
// unsigned int __usercall IO_new_file_init@<eax>(int@<ebp>, int *);
int __cdecl IO_file_open(int, int, int, int, __int16, int);
unsigned int *__cdecl IO_new_file_attach(unsigned int *, unsigned int);
int __cdecl IO_new_do_write(int, unsigned int, int);
int __cdecl IO_new_file_close_it(int);
int __cdecl IO_new_file_fopen(int, int, _BYTE *, int);
// int *__usercall IO_new_file_finish@<eax>(int@<ebp>, int tv_nsec@<edi>, struct timespec *);
int __cdecl IO_new_file_overflow(int *, int);
int __cdecl IO_new_file_sync(int *);
// int __usercall save_for_backup@<eax>(_DWORD *@<eax>, int@<edx>);
// int __usercall flush_cleanup@<eax>(int@<ebp>, int *@<edi>, const struct timespec *@<esi>);
// unsigned int __usercall IO_un_link_part_2@<eax>(struct timespec *@<eax>, int@<ebp>);
// struct timespec *__usercall IO_un_link@<eax>(int a1@<ebp>, struct timespec *a2);
// unsigned int __usercall IO_link_in@<eax>(int@<ebp>, int *);
int __cdecl IO_least_marker(int, int);
_DWORD *__cdecl IO_switch_to_main_get_area(_DWORD *);
_DWORD *__cdecl IO_switch_to_backup_area(_DWORD *);
int __cdecl IO_switch_to_get_mode(int *);
// int *__usercall IO_free_backup_area@<eax>(int ebp0@<ebp>, int *@<edi>, int *);
int __cdecl _overflow(int, int);
// int __usercall _underflow@<eax>(int ebp0@<ebp>, int *@<edi>, int *);
// int __usercall _uflow@<eax>(int ebp0@<ebp>, int *@<edi>, int *);
// int __usercall IO_setb@<eax>(int ebp0@<ebp>, int *edi0@<edi>, int *, int, int, int);
void __cdecl IO_doallocbuf(int *);
int IO_default_underflow();
int __cdecl IO_default_uflow(int);
unsigned int __cdecl IO_default_xsputn(_DWORD *, _BYTE *, unsigned int);
int __cdecl IO_sgetn(int, int, int);
// unsigned int __usercall IO_default_xsgetn@<eax>(int *@<edi>, int *, int *, unsigned int);
_DWORD *__cdecl IO_default_setbuf(_DWORD *, int *, int);
int __cdecl IO_default_seekpos(int, int, int, int);
// int __usercall IO_default_doallocate@<eax>(int@<ebp>, unsigned int *);
_TBYTE *IO_enable_locks();
_DWORD *__cdecl IO_old_init(int, int);
__int64 __cdecl IO_init_internal(_DWORD *, int);
__int64 __cdecl IO_init(_DWORD *, int);
int __cdecl IO_no_init(_DWORD *, int, int, _DWORD *, int);
int IO_default_sync();
// int *__usercall IO_default_finish@<eax>(int@<ebp>, int *@<edi>, struct timespec *);
__int64 IO_default_seekoff();
int __cdecl IO_sputbackc(_DWORD *, int);
int __cdecl IO_sungetc(_DWORD *);
int __cdecl IO_adjust_column(int, unsigned int, int);
// int __usercall IO_flush_all_lockp@<eax>(int *@<edi>, int);
// int __usercall IO_cleanup@<eax>(int@<ebp>, int *@<edi>);
// int __usercall IO_flush_all@<eax>(int *@<edi>);
// unsigned int __usercall flushlbf@<eax>(int@<ebp>, int *@<edi>);
int __cdecl IO_init_marker(int *, int *);
_DWORD *__cdecl IO_remove_marker(_DWORD *);
int __cdecl IO_marker_difference(int, int);
int __cdecl IO_marker_delta(int);
int __cdecl IO_seekmark(int *, int);
// int *__usercall IO_unsave_markers@<eax>(int ebp0@<ebp>, int *@<edi>, int *);
int __cdecl IO_default_pbackfail(int *, int);
__int64 IO_default_seek();
int IO_default_stat();
int IO_default_read();
int IO_default_write();
int IO_default_showmanyc();
void IO_default_imbue();
void *IO_iter_begin();
int IO_iter_end();
int __cdecl IO_iter_next(int);
int __cdecl IO_iter_file(int);
// void __usercall IO_list_lock(int@<ebp>, int *@<edi>);
// int __usercall IO_list_unlock@<eax>(int@<ebp>, int *@<edi>, const struct timespec *@<esi>);
_TBYTE *IO_list_resetlock();
void _x86_get_pc_thunk_cx();
int __cdecl IO_str_underflow(int *);
int __cdecl IO_str_overflow(int *, int);
// int __usercall enlarge_userbuf@<eax>(int *@<eax>, int@<edx>, unsigned int@<ecx>, int);
int __cdecl IO_str_seekoff(int *, __int64, int, int);
int __cdecl IO_str_pbackfail(int *, int);
// int *__usercall IO_str_finish@<eax>(int@<ebp>, int *@<edi>, struct timespec *);
int __cdecl IO_str_init_static_internal(int *, _BYTE *, int, int);
int __cdecl IO_str_init_static(int *, _BYTE *, int, int);
int __cdecl IO_str_init_readonly(int *, _BYTE *, int);
unsigned int __cdecl IO_str_count(_DWORD *);
_BOOL4 __cdecl _libc_alloca_cutoff(unsigned int);
// __int32 __usercall _lll_lock_wait_private@<eax>(int@<eax>, int *@<ecx>, int@<ebp>, int *@<edi>);
// int __usercall _lll_unlock_wake_private@<eax>(int *@<eax>, int@<ebp>, int *@<edi>, const struct timespec *@<esi>);
_TBYTE *__cdecl dl_tunable_set_arena_max(int *);
_TBYTE *__cdecl dl_tunable_set_arena_test(int *);
unsigned int __cdecl dl_tunable_set_tcache_max(unsigned int *);
int __cdecl dl_tunable_set_tcache_count(int *);
_TBYTE *__cdecl dl_tunable_set_tcache_unsorted_limit(int *);
// int __usercall mem2mem_check@<eax>(int result@<eax>, unsigned int@<edx>);
// unsigned int __usercall mem2chunk_check@<eax>(int@<eax>, _DWORD *@<edx>);
// _TBYTE *__usercall int_mallinfo@<eax>(int@<eax>, _DWORD *@<edx>);
_TBYTE *__cdecl dl_tunable_set_trim_threshold(int *);
_TBYTE *__cdecl dl_tunable_set_top_pad(int *);
int __cdecl dl_tunable_set_mmap_threshold(int *);
_TBYTE *__cdecl dl_tunable_set_mmaps_max(int *);
_TBYTE *__cdecl dl_tunable_set_perturb_byte(int *);
// void __usercall __noreturn _malloc_assert(int@<eax>, int@<edx>, int@<ecx>, int);
// int __usercall detach_arena@<eax>(int result@<eax>);
// int *__usercall get_free_list@<eax>(int@<ebp>);
// char *__usercall malloc_printerr@<eax>(char@<al>);
char *top_check();
// char *__usercall malloc_consolidate@<eax>(int@<eax>);
// char *__usercall new_heap@<eax>(unsigned int@<eax>, int@<edx>);
// int *__usercall munmap_chunk@<eax>(_DWORD *@<eax>);
// int *__usercall mremap_chunk@<eax>(int *result@<eax>, int@<edx>);
unsigned int ptmalloc_init();
// struct timespec *__usercall arena_get2_part_5@<eax>(int@<eax>, int@<edx>);
// struct timespec *__usercall arena_get_retry@<eax>(int *@<eax>, const struct timespec *@<edx>, int@<ebp>);
_TBYTE *__cdecl dl_tunable_set_mallopt_check(_DWORD *);
// int __usercall _malloc_info_part_10@<eax>(const struct timespec *a1@<eax>, int a2@<ebx>, int a3@<ebp>, const struct timespec *a4@<esi>);
// int __usercall systrim_isra_1_constprop_11@<eax>(unsigned int@<eax>);
// unsigned int __usercall int_free@<eax>(int@<eax>, unsigned int@<edx>, unsigned int@<ecx>, int *@<edi>);
// int *__usercall sysmalloc@<eax>(unsigned int@<eax>, int *@<edx>);
// int *__usercall int_malloc@<eax>(unsigned int@<eax>, unsigned int@<edx>, _DWORD *i@<edi>);
// int __usercall malloc_check@<eax>(int@<ebp>, int *@<edi>, const struct timespec *);
// int *__usercall tcache_init_part_6@<eax>(int@<ebp>, int *@<edi>, const struct timespec *@<esi>);
// int *__usercall int_memalign@<eax>(_TBYTE *a1@<eax>, unsigned int a2@<edx>, unsigned int a3@<ecx>);
// int __usercall memalign_check@<eax>(int@<ebp>, unsigned int, struct timespec *);
// const struct timespec *__usercall free_check_part_3@<eax>(const struct timespec *a1@<eax>, int a2@<ebp>, int *a3@<edi>, int a4);
// const struct timespec *__usercall free_check@<eax>(int a1@<ebp>, int *a2@<edi>, const struct timespec *a3);
// int *__usercall int_realloc@<eax>(unsigned int@<eax>, unsigned int@<edx>, unsigned int@<ecx>, unsigned int@<edi>, unsigned int@<esi>, unsigned int);
// __int32 __usercall realloc_check@<eax>(int *@<edi>, struct timespec *, const struct timespec *);
// __int32 __usercall _malloc_fork_lock_parent@<eax>(int@<ebp>, int *@<edi>);
// int __usercall _malloc_fork_unlock_parent@<eax>(int@<ebp>, int *@<edi>, const struct timespec *@<esi>);
int _malloc_fork_unlock_child();
_TBYTE *_malloc_check_init();
int *__cdecl malloc(const struct timespec *a1);
int *__cdecl malloc_hook_ini(const struct timespec *a1);
// int *__usercall mid_memalign@<eax>(unsigned int a1@<eax>, struct timespec *a2@<edx>, int a3@<ecx>);
int *__cdecl memalign_hook_ini(unsigned int a1, struct timespec *a2);
// int *__usercall free@<eax>(int@<ebp>, int *@<edi>, int);
// int __usercall _malloc_arena_thread_freeres@<eax>(int *@<edi>, struct timespec *@<esi>);
// int *__usercall realloc@<eax>(int ebp0@<ebp>, _BYTE *, const struct timespec *);
// int *__usercall realloc_hook_ini@<eax>(int@<ebp>, _BYTE *, const struct timespec *);
int *__cdecl memalign(unsigned int a1, struct timespec *a2);
int *__cdecl valloc(struct timespec *a1);
int *__cdecl pvalloc(unsigned int a1);
// unsigned __int8 *__usercall calloc@<eax>(int *edi0@<edi>, unsigned int, unsigned int);
// int __usercall malloc_trim@<eax>(int *@<edi>, const struct timespec *tv_nsec@<esi>, unsigned int);
struct timespec *__cdecl malloc_usable_size(int);
struct timespec *__stdcall mallinfo(struct timespec *);
unsigned int malloc_stats();
// int __usercall mallopt@<eax>(int@<ebp>, int *, const struct timespec *);
int __cdecl posix_memalign(int *, unsigned int, struct timespec *);
// int __usercall malloc_info@<eax>(int@<ebx>, int@<ebp>, int, const struct timespec *);
unsigned int __cdecl _default_morecore(int a1);
_DWORD *__cdecl strchr(_BYTE *, int);
int __cdecl strcmp(char *, _BYTE *);
_BYTE *__cdecl strcpy(_BYTE *, unsigned int *);
_BYTE *__cdecl strcspn(int, _BYTE *);
int *__cdecl strdup(unsigned int *a1);
int __cdecl strlen(unsigned int *);
int __cdecl strncmp(unsigned __int8 *, unsigned __int8 *, unsigned int);
// unsigned int __usercall critical_factorization@<eax>(int@<eax>, unsigned int@<edx>, int *@<ecx>);
// int __usercall two_way_long_needle@<eax>(int@<eax>, unsigned int@<edx>, unsigned int *@<ecx>, unsigned int);
char *__cdecl strstr(char *a1, unsigned int *a2);
int __cdecl memcmp(unsigned int *, unsigned int *, int);
_BYTE *__cdecl _memmove_chk(_BYTE *, _BYTE *, unsigned int, unsigned int);
_BYTE *__cdecl memmove(_BYTE *, _BYTE *, unsigned int);
unsigned __int8 *__cdecl memset(unsigned __int8 *, unsigned __int8, unsigned int);
_WORD *__cdecl _mempcpy_chk(_BYTE *, _BYTE *, unsigned int, unsigned int);
_WORD *__cdecl mempcpy(_BYTE *, _BYTE *, unsigned int);
_BYTE *__cdecl stpcpy(int, int);
int __cdecl strcasecmp_l(char *, unsigned __int8 *, int);
_BYTE *__cdecl _memcpy_chk(_BYTE *, _BYTE *, unsigned int, unsigned int);
_BYTE *__cdecl memcpy(_BYTE *, _BYTE *, unsigned int);
_BYTE *__cdecl rawmemchr(_BYTE *, int);
unsigned int *__cdecl strchrnul(unsigned int *, int);
_WORD *__cdecl wmempcpy(_BYTE *, _BYTE *, int);
int __cdecl mbsrtowcs(int, unsigned int **, int, void *);
// int *__usercall nl_cleanup_ctype@<eax>(int ebp0@<ebp>, int *@<edi>, int);
const struct timespec *__cdecl _wcsmbs_getfct(int, int, unsigned int *);
unsigned int __cdecl _wcsmbs_load_conv(_DWORD *);
_DWORD *__cdecl _wcsmbs_clone_conv(void **);
int __cdecl _wcsmbs_named_conv(int, int);
int __cdecl _mbsrtowcs_l(int, unsigned int **, int, int, _DWORD **);
void exit(int status);
// int __usercall _sysconf_check_spec@<eax>(unsigned int *@<eax>);
__int64 __cdecl sysconf(int);
unsigned int sched_yield();
int _get_child_max();
unsigned int __cdecl _xstat64(int, const char *, struct stat *);
unsigned int __cdecl _fxstat64(int, int, struct stat *);
unsigned int __cdecl open(int, int);
unsigned int __cdecl read(int, void *, size_t);
unsigned int __cdecl write(int, const void *, size_t);
loff_t __cdecl lseek64(int, unsigned int, unsigned int, unsigned int);
char *__cdecl getcwd(__int64);
unsigned int __cdecl _close_nocancel(int);
unsigned int __cdecl _fcntl64_nocancel_adjusted(int, int);
unsigned int __cdecl _fcntl64_nocancel(int, int);
unsigned int __cdecl _open_nocancel(int);
unsigned int __cdecl _openat64_nocancel(int, int, int);
unsigned int __cdecl _read_nocancel(int, void *, size_t);
unsigned int __cdecl _write_nocancel(int, const void *, size_t);
unsigned int __cdecl getrlimit(int, int);
unsigned int __cdecl sbrk(int a1);
int getpagesize();
int getdtablesize();
unsigned int __cdecl mmap(void *, size_t, int, int, int, unsigned int);
unsigned int __cdecl mmap64(void *, size_t, int, int, int, unsigned __int64);
unsigned int __cdecl munmap(void *, int);
unsigned int __cdecl mprotect(const void *, size_t, int);
unsigned int __cdecl madvise(void *, size_t, int);
// int __usercall trecurse@<eax>(int@<eax>, int (__cdecl *)(int, int, int)@<edx>, int@<ecx>);
// int *__usercall tdestroy_recurse@<eax>(_DWORD *@<eax>, int *@<edx>, int@<ecx>, int@<ebp>);
// unsigned int __usercall maybe_split_for_insert_isra_0@<eax>(int@<eax>, _DWORD *@<edx>, unsigned int *@<ecx>, int, int, int);
_DWORD *__cdecl tsearch(int, int *, int (__cdecl *)(int, _DWORD));
_DWORD *__cdecl tfind(int, _DWORD *, int (__cdecl *)(int, _DWORD));
_DWORD *__cdecl tdelete(unsigned int a1, _DWORD *a2, int a3);
int __cdecl twalk(int, int (__cdecl *)(int, int, int));
// int *__usercall tdestroy@<eax>(int@<ecx>, int@<ebp>, int *, int *);
// char *__usercall next_line@<eax>(int@<eax>, char *@<edx>, char **@<ecx>, void **, char *);
// unsigned int __usercall sysinfo_mempages@<eax>(int@<eax>, unsigned int@<edx>);
int get_nprocs();
// int __usercall get_nprocs_conf@<eax>(int *@<edi>);
unsigned int get_phys_pages();
unsigned int get_avphys_pages();
int _getclktck();
void __cdecl _init_misc(int, char (**)[1671]);
unsigned int __cdecl mremap(void *, size_t, size_t, unsigned int);
unsigned int __cdecl sysinfo(struct sysinfo *);
void __noreturn _chk_fail();
void __cdecl __noreturn _fortify_fail_abort(char, char);
void __cdecl __noreturn _fortify_fail(char);
void dl_debug_state();
void **__cdecl dl_debug_initialize(void *, int);
// int __usercall do_tunable_update_val@<eax>(int result@<eax>, unsigned int *@<edx>);
// int __usercall tunable_initialize@<eax>(int@<eax>, unsigned int *@<edx>);
int __cdecl _tunable_set_val(int, unsigned int *);
int *__cdecl _tunables_init(int *);
int __cdecl _tunable_get_val(int, char **, int (__cdecl *)(char **));
void dl_sysinfo_int80();
int __cdecl dl_aux_init(int *);
// __int16 *__usercall dl_non_dynamic_init@<eax>(int@<ebp>);
void *dl_get_dl_main_map();
int _libc_init_secure();
_TBYTE *__cdecl dl_mcount_wrapper(int);
_TBYTE *__cdecl dl_mcount_wrapper_check(int);
unsigned int __cdecl dl_tunable_set_hwcaps(char **);
_WORD *__cdecl dl_tunable_set_x86_ibt(_WORD **);
_WORD *__cdecl dl_tunable_set_x86_shstk(_WORD **);
int dl_discover_osversion();
unsigned int __cdecl _libc_init_first(int, char (**)[1671], _DWORD *);
// int __usercall _syscall_error@<eax>(int@<eax>);
int __cdecl _gconv_open(char *, int *, char **, char);
int __cdecl _gconv(int *, int *, unsigned int, int *, int, _DWORD *);
int __cdecl _gconv_close(int *);
int __cdecl _gconv_alias_compare(char **, _BYTE **);
int __cdecl derivation_compare(char **, _BYTE **);
int _gconv_get_modules_db();
int _gconv_get_alias_db();
_TBYTE *__cdecl _gconv_release_step(int *);
// int __usercall find_derivation@<eax>(_BYTE *@<eax>, _BYTE *@<edx>, unsigned int *@<ecx>, unsigned int *, unsigned int ***, unsigned int *);
int __cdecl _gconv_compare_alias(char *, int *);
int __cdecl _gconv_find_transform(unsigned __int8 *, int *, int ***, int *, char);
int __cdecl _gconv_close_transform(const struct timespec *, int);
// int __usercall insert_module@<eax>(int result@<eax>, int@<edx>);
// int __usercall detect_conflict@<eax>(char *@<eax>);
// unsigned int __usercall add_module_isra_0@<eax>(char *@<eax>, _BYTE *@<edx>, unsigned int@<ecx>, int);
// int *__usercall add_alias2_isra_1_part_2@<eax>(_BYTE *@<eax>, int@<edx>, int@<ecx>);
// unsigned int __usercall _gconv_get_path@<eax>(int *@<edi>);
// unsigned int __usercall _gconv_read_conf@<eax>(int *@<edi>);
int __cdecl _gconv_get_builtin_trans(char *, _DWORD *);
int __cdecl _gconv_btwoc_ascii(int, char);
int __cdecl _gconv_transform_internal_ucs4(int, unsigned int *, unsigned int *, unsigned int, unsigned int *, int, int, int);
int __cdecl _gconv_transform_ucs4_internal(int, int **, unsigned int **, unsigned int *, int **, _DWORD *, int, int);
int __cdecl _gconv_transform_internal_ucs4le(int, int, _DWORD *, _BYTE *, _DWORD *, int, int, int);
int __cdecl _gconv_transform_ucs4le_internal(int, _DWORD *, unsigned int *, unsigned int, _DWORD *, _DWORD *, int, int);
int __cdecl _gconv_transform_ascii_internal(int, _DWORD *, unsigned __int8 **, unsigned __int8 *, _DWORD *, _DWORD *, int, int);
int __cdecl _gconv_transform_internal_ascii(_DWORD *, _DWORD *, int *, unsigned int, _DWORD *, _DWORD *, int, int);
int __cdecl _gconv_transform_internal_utf8(_DWORD *, _DWORD *, int *, unsigned int, _DWORD *, _DWORD *, int, int);
int __cdecl _gconv_transform_utf8_internal(int, unsigned int **, unsigned __int8 **, unsigned int, unsigned int **, _DWORD *, int, int);
int __cdecl _gconv_transform_ucs2_internal(int, char **, unsigned int *, unsigned int, char **, _DWORD *, int, int);
int __cdecl _gconv_transform_internal_ucs2(_DWORD *, int *, int *, unsigned int, int *, _DWORD *, int, int);
int __cdecl _gconv_transform_ucs2reverse_internal(int, char **, unsigned int *, unsigned int, char **, _DWORD *, int, int);
int __cdecl _gconv_transform_internal_ucs2reverse(_DWORD *, int *, int *, unsigned int, int *, _DWORD *, int, int);
int __cdecl _gconv_transliterate(_DWORD *, int, int, unsigned int **, unsigned int, int *, _DWORD *);
// int __usercall find_module_idx@<eax>(unsigned __int8 *@<eax>, _DWORD *@<edx>);
// int __usercall find_module@<eax>(unsigned int *@<eax>, unsigned int *@<edx>, int **@<ecx>);
int _gconv_get_cache();
// int __usercall _gconv_load_cache@<eax>(unsigned int@<ebp>, int *@<edi>);
int __cdecl _gconv_compare_alias_cache(char *, unsigned __int8 *, int *);
int __cdecl _gconv_lookup_cache(unsigned __int8 *, unsigned __int8 *, int ***, int *, char);
// int *__usercall _gconv_release_cache@<eax>(int ebp0@<ebp>, int *@<edi>, int);
int __cdecl known_compare(char **, _BYTE **);
// int __usercall do_release_shlib@<eax>(int@<ebp>, int *edi0@<edi>, int *, int);
int *__cdecl _gconv_find_shlib(unsigned int *);
int __cdecl _gconv_release_shlib(int);
// const char *__usercall new_composite_name@<eax>(int@<eax>, char **@<edx>);
unsigned int **__cdecl setlocale(unsigned int a1, char *a2);
// _BYTE *__usercall strip@<eax>(_BYTE *result@<eax>, char *@<edx>);
char **__cdecl nl_find_locale(unsigned int *, unsigned int, unsigned int, int *);
// void __usercall nl_remove_locale(int@<ebp>, int *@<edi>, int, int);
int *__cdecl nl_intern_locale_data(unsigned int a1, _DWORD *a2, unsigned int a3);
unsigned int __cdecl nl_load_locale(int *, unsigned int);
// int *__usercall nl_unload_locale@<eax>(int@<ebp>, int *@<edi>, int);
int __cdecl rangecmp(_DWORD *, _DWORD *);
signed int __cdecl nl_load_locale_from_archive(int, unsigned int **);
int nl_postload_ctype();
int __cdecl _current_locale_name(int);
unsigned int _ctype_b_loc();
unsigned int _ctype_toupper_loc();
unsigned int _ctype_tolower_loc();
unsigned int _ctype_init();
unsigned int __cdecl _setfpucw(__int16);
__int64 __cdecl raise(int);
int __cdecl annobin_sigaction_c(int a1, int *a2, _DWORD *a3);
int __cdecl _libc_sigaction(int a1, int *a2, _DWORD *a3);
int __cdecl sigaction(int a1, int *a2, _DWORD *a3);
unsigned int __cdecl sigprocmask(int, _BYTE *, int);
unsigned int __cdecl quicksort(char *, unsigned int, unsigned int, int (__cdecl *)(char *, char *, int), int);
// int __usercall _add_to_environ@<eax>(int *@<edi>, unsigned __int8 *, unsigned int *, unsigned __int8 *, int);
// int __usercall setenv@<eax>(int *@<edi>, unsigned __int8 *, unsigned int *, int);
// int __usercall unsetenv@<eax>(int@<ebp>, struct timespec *);
// int __usercall clearenv@<eax>(int@<ebp>, int *@<edi>);
int __cdecl secure_getenv(__int16 *);
unsigned int __cdecl _strtol_internal(unsigned __int8 *, _DWORD *, int, int);
unsigned int __cdecl strtol(unsigned __int8 *, _DWORD *, int);
unsigned int __cdecl ___strtol_l_internal(unsigned __int8 *, _DWORD *, int, int, int);
unsigned int __cdecl strtol_l(unsigned __int8 *, _DWORD *, int, int);
// int __usercall read_int@<eax>(_DWORD *@<eax>);
// _BYTE *__usercall group_number@<eax>(_BYTE *@<eax>, _BYTE *@<edx>, _BYTE *@<ecx>, _BYTE *, unsigned int *);
// _BYTE *__usercall i18n_number_rewrite@<eax>(_BYTE *@<eax>, int@<edx>, _BYTE *@<ecx>);
int __cdecl IO_helper_overflow(_DWORD *, unsigned __int8);
// unsigned int __usercall printf_positional@<eax>(int *@<eax>, unsigned int *@<edx>, int@<ecx>, int, int, int, unsigned int, unsigned int, unsigned __int8 *, _BYTE *, signed int, char *, unsigned int *);
// void __usercall vfprintf(int@<ebx>, int@<esi>, int, unsigned int *, int);
// void __usercall sub_8077593(int@<ebp>);
// void __usercall sub_80775BA(int@<ebp>, const struct timespec *@<edx>);
// int __usercall buffered_vfprintf@<eax>(const struct timespec *a1@<eax>, unsigned int *a2@<edx>, int a3@<ecx>);
// int __usercall hack_digit@<eax>(int@<eax>);
// _BYTE *__usercall i18n_number_rewrite_0@<eax>(_BYTE *@<eax>, int@<edx>, _BYTE *@<ecx>);
// int __usercall _guess_grouping_part_0@<eax>(unsigned int@<eax>, char *@<edx>);
// int __usercall _printf_fp_l@<eax>(unsigned int@<ebx>, int@<ebp>, unsigned int@<edi>, unsigned int@<esi>, _DWORD *, unsigned __int32, int, const __m128i **);
// int __usercall _printf_fp@<eax>(unsigned int@<ebx>, int@<ebp>, unsigned int@<edi>, unsigned int@<esi>, _DWORD *, int, const __m128i **);
int __cdecl _guess_grouping(unsigned int, char *);
// int __usercall register_printf_specifier@<eax>(int@<ebp>, int *@<edi>, const struct timespec *, int, int);
// int __usercall register_printf_function@<eax>(int@<ebp>, int *@<edi>, const struct timespec *, int, int);
// int __usercall _printf_fphex@<eax>(int@<ebx>, int@<ebp>, int@<edi>, int@<esi>, int *, int, const __m128i **);
// int __usercall register_printf_modifier@<eax>(int *a1@<ebp>, int a2);
int __cdecl _handle_registered_modifier_mb(unsigned __int8 **, int);
int __cdecl _handle_registered_modifier_wc(_DWORD *, int);
// int __usercall register_printf_type@<eax>(int@<ebp>, int *@<edi>, const struct timespec *@<esi>, int);
// void __usercall fprintf(int@<ebx>, int@<esi>, int, unsigned int *, ...);
// int __usercall read_int_0@<eax>(_DWORD *@<eax>);
// _BYTE *__usercall group_number_0@<eax>(_BYTE *@<eax>, _BYTE *@<edx>, _BYTE *@<ecx>, char *, int);
// _BYTE *__usercall i18n_number_rewrite_1@<eax>(_BYTE *@<eax>, int@<edx>, _BYTE *@<ecx>);
int __cdecl IO_helper_overflow_0(_DWORD *, int);
// unsigned int __usercall printf_positional_0@<eax>(int *@<eax>, _DWORD *@<edx>, int@<ecx>, int, int, int, unsigned int, unsigned int, int *, _BYTE *, signed int, char *, int);
void __cdecl vfwprintf(struct timespec *, int *, int);
// void __usercall sub_8082185(int@<edx>, int@<ebp>, const struct timespec *@<ecx>);
// int __usercall buffered_vfprintf_0@<eax>(struct timespec *@<eax>, int *@<edx>, int@<ecx>);
// int __usercall funlockfile@<eax>(int@<ebp>, int *@<edi>, const struct timespec *@<esi>, int);
// int __usercall read_int_1@<eax>(_DWORD *@<eax>);
int __cdecl _parse_one_specmb(unsigned __int8 *, int, int, unsigned int *);
// int __usercall read_int_2@<eax>(_DWORD *@<eax>);
int __cdecl _parse_one_specwc(int *, int, int, unsigned int *);
int __cdecl IO_file_doallocate(int *);
int __cdecl fputs(unsigned int *, const struct timespec *);
// int __usercall IO_wfile_doallocate@<eax>(int@<ebp>, int *);
int __cdecl fwrite(int, unsigned int, int, const struct timespec *);
// int __usercall getdelim@<eax>(signed int@<esi>, _DWORD *, unsigned int *, int, int *);
_BYTE *__cdecl IO_getline_info(int *, _BYTE *, unsigned int, int, int, _DWORD *);
_BYTE *__cdecl IO_getline(int *, _BYTE *, unsigned int, int, int);
int __cdecl IO_padn(int, int, int);
int __cdecl IO_wpadn(int, int, int);
// int __usercall save_for_wbackup_isra_0@<eax>(_DWORD *@<eax>, int *@<edx>, int@<ecx>);
int __cdecl IO_least_wmarker(int, int);
_DWORD *__cdecl IO_switch_to_main_wget_area(_DWORD *);
_DWORD *__cdecl IO_switch_to_wbackup_area(_DWORD *);
// int __usercall IO_wsetb@<eax>(int ebp0@<ebp>, int *edi0@<edi>, int, int, int, int);
int __cdecl IO_wdefault_pbackfail(int *, int);
// struct timespec *__usercall IO_wdefault_finish@<eax>(int a1@<ebp>, int *a2@<edi>, int a3);
int __cdecl IO_wdefault_uflow(int);
int __cdecl _woverflow(_DWORD *, int);
unsigned int __cdecl IO_wdefault_xsputn(_DWORD *, int *, unsigned int);
// int __usercall IO_wdoallocbuf@<eax>(int@<ebp>, int *@<edi>, int);
// int __usercall IO_wdefault_doallocate@<eax>(int@<ebp>, int *@<edi>, int);
int __cdecl IO_switch_to_wget_mode(int *);
// _DWORD *__usercall IO_free_wbackup_area@<eax>(int ebp0@<ebp>, int *@<edi>, int *);
// int __usercall _wuflow@<eax>(int@<ebp>, int *);
// int __usercall _wunderflow@<eax>(int@<ebp>, int *);
unsigned int __cdecl IO_wdefault_xsgetn(int *, _WORD *, unsigned int);
int __cdecl IO_sputbackwc(_DWORD *, int);
int __cdecl IO_sungetwc(_DWORD *);
int __cdecl IO_adjust_wcolumn(int, unsigned int, int);
int __cdecl IO_init_wmarker(int *, int *);
int __cdecl IO_wmarker_delta(int);
int __cdecl IO_seekwmark(int *, int);
// int *__usercall IO_unsave_wmarkers@<eax>(int@<ebp>, int *@<edi>, int *);
int __cdecl do_encoding(int);
int do_always_noconv();
int __cdecl do_max_length(int);
int __cdecl do_in(_DWORD *, int, int, int, _DWORD *, int, int, _DWORD *);
int __cdecl do_unshift(_DWORD *, int, int, int, _DWORD *);
int __cdecl do_out(_DWORD *, int, int, int, _DWORD *, int, int, _DWORD *);
int __cdecl do_length(_DWORD *, int, int, int, int);
int __cdecl IO_fwide(_DWORD *, int);
void __cdecl _libc_enable_asynccancel(char);
void __cdecl _libc_disable_asynccancel(char);
int __cdecl _libc_scratch_buffer_grow_preserve(int);
int __cdecl _libc_scratch_buffer_set_array_size(int *, unsigned int, int);
int *__cdecl strndup(_BYTE *a1, int a2);
unsigned __int8 *__cdecl strerror_r(signed int, _BYTE *, unsigned int);
unsigned int __cdecl strnlen(_BYTE *, int);
unsigned int *__cdecl strrchr(unsigned int *, int);
int __cdecl strtok_r(int, _BYTE *, int *);
_BYTE *__cdecl memchr(_BYTE *, int, unsigned int);
// unsigned int __usercall critical_factorization_0@<eax>(int@<eax>, unsigned int@<edx>, int *@<ecx>);
// int __usercall two_way_long_needle_0@<eax>(int@<eax>, int@<edx>, unsigned int *@<ecx>, unsigned int);
_BYTE *__cdecl memmem(_BYTE *, unsigned int, unsigned int *, unsigned int);
int __cdecl argz_create_sep(unsigned int *, int *, unsigned int *, int *);
int __cdecl argz_add_sep(int **, _DWORD *, unsigned int *, int);
// int __usercall handle_amd@<eax>(int@<eax>);
// int __usercall intel_check_word_isra_0@<eax>(int a1@<eax>, int a2@<edx>, _BYTE *a3@<ecx>, _BYTE *a4, _DWORD *a5, _DWORD *a6);
// int __usercall handle_intel_constprop_1@<eax>(int a1@<eax>);
int __cdecl _cache_sysconf(int);
int __cdecl wcslen(_DWORD *);
_BYTE *__cdecl wmemcpy(_BYTE *, _BYTE *, int);
_BYTE *__cdecl wmemmove(_BYTE *, _BYTE *, int);
_DWORD *__cdecl wmemset(_DWORD *, int, unsigned int);
int __cdecl btowc(int);
int __cdecl wcrtomb(char *, int, void *);
int __cdecl wcsrtombs(int, int *, int, int *);
int __cdecl wcsnlen(_DWORD *, int);
int *__cdecl wcschrnul(int *, int);
int __cdecl time(time_t *);
int *__cdecl _alloc_dir(int, char, int, int);
// int *__usercall opendir_tail@<eax>(int@<eax>);
int *__cdecl _opendirat(int, _BYTE *);
int *__cdecl opendir(_BYTE *);
// unsigned int __usercall closedir@<eax>(int ebp0@<ebp>, int *@<edi>, int *);
int __cdecl readdir(int);
// int __usercall rewinddir@<eax>(int@<ebp>, int *@<edi>, const struct timespec *@<esi>, int *);
unsigned int __cdecl _getdents(int, struct dirent *, unsigned int);
int __cdecl readdir64(int);
int *__cdecl fdopendir(int);
unsigned int __cdecl uname(struct utsname *);
int getuid();
int geteuid();
int getgid();
int getegid();
unsigned int __cdecl _lxstat64(int, const char *, struct stat *);
int __cdecl _fxstatat64(int, int, int, int);
unsigned int __cdecl lseek(int, signed int, unsigned int);
_BOOL4 __cdecl isatty(int);
unsigned int __cdecl _open64_nocancel(int, int);
unsigned int __cdecl _openat_nocancel(int, int);
unsigned int __cdecl tcgetattr(int, int);
int __cdecl brk(void *end_data_segment); // idb
int __cdecl wctrans(char *);
unsigned int __cdecl towctrans(unsigned int, _DWORD *);
int __cdecl _readonly_area(unsigned int, unsigned int);
// int __usercall is_dst@<eax>(unsigned __int8 *@<eax>, unsigned int *@<edx>);
// _BOOL4 __usercall is_trusted_path_normalize@<eax>(char *@<eax>, int@<edx>);
// int __usercall dl_process_pt_note@<eax>(int@<eax>, _DWORD *@<edx>, int@<ecx>, _DWORD *);
// void __usercall __noreturn lose(int *a1@<eax>, int a2@<edx>, unsigned int *a3@<ecx>, int a4, int a5, unsigned int *a6, int a7);
// _BYTE *__usercall add_name_to_object_isra_4@<eax>(_BYTE **@<eax>, unsigned int *@<edx>);
// int __usercall open_verify_constprop_7@<eax>(unsigned int *@<eax>, int *@<edx>, int@<ecx>, _BYTE *, int);
// int __usercall open_path@<eax>(_BYTE *a1@<eax>, unsigned int a2@<edx>, const char *a3@<ecx>, int *a4, _DWORD *a5, int *a6, int a7, int a8, _BYTE *a9);
// int __usercall dl_map_object_from_fd_constprop_8@<eax>(unsigned int *@<eax>, int@<edx>, _DWORD *@<ecx>, unsigned int *, unsigned __int8 *, char, int, int, int);
// unsigned int __usercall add_path_isra_3_constprop_9@<eax>(unsigned int result@<eax>, int *@<edx>);
int __cdecl dl_dst_count(_BYTE *);
char *__cdecl dl_dst_substitute(int, unsigned __int8 *, char *);
// char *__usercall expand_dynamic_string_token@<eax>(int@<eax>, unsigned int *@<edx>);
// _DWORD *__usercall fillin_rpath@<eax>(int@<eax>, _DWORD *@<edx>, _BYTE *@<ecx>, int ebp0@<ebp>, int, unsigned int *, int);
// int __usercall cache_rpath_part_6@<eax>(int@<eax>, _DWORD *@<edx>, int@<ecx>, int);
int *__cdecl dl_init_paths(unsigned int *);
// unsigned __int8 *__usercall dl_map_object@<eax>(unsigned int *edi0@<edi>, int, char *, char, int, int, int);
int __cdecl dl_rtld_di_serinfo(int, _DWORD *, char);
// int __usercall check_match@<eax>(_BYTE *@<eax>, int@<edx>, int@<ecx>, char, unsigned __int8, int, int, int, int, _DWORD *, _DWORD *);
// int __usercall do_lookup_x@<eax>(unsigned __int8 *@<eax>, unsigned int@<edx>, unsigned int *@<ecx>, int, int *, int *, int, int, char, int, int, int);
_DWORD *__cdecl dl_lookup_symbol_x(unsigned __int8 *, _DWORD *, int *, int **, _DWORD *, int, int, int);
_DWORD *__cdecl dl_setup_hash(_DWORD *);
int __cdecl dl_add_to_namespace_list(_DWORD *, int);
// unsigned __int8 *__usercall dl_new_object@<eax>(int *edi0@<edi>, unsigned int *, unsigned int *, char, unsigned __int8 *, char, int);
int __cdecl dl_try_allocate_static_tls(int);
int __cdecl dl_allocate_static_tls(int);
unsigned __int8 *__cdecl dl_nothread_init_static_tls(int);
_BYTE *__cdecl dl_protect_relro(int a1);
void __cdecl __noreturn dl_reloc_bad_type(int, unsigned __int8, int);
_TBYTE *__cdecl dl_relocate_object(int, int, int, int);
unsigned int __cdecl dl_important_hwcaps(int, int, _DWORD *, _DWORD *);
// int __usercall dl_debug_vdprintf@<eax>(int@<eax>, int@<edx>, _BYTE *@<ecx>, unsigned int **);
unsigned int __cdecl dl_sysdep_read_whole_file(int a1, __off_t *a2, int a3);
int dl_debug_printf(_BYTE *, ...);
int dl_debug_printf_c(_BYTE *, ...);
int dl_dprintf(int, _BYTE *, ...);
int __cdecl dl_name_match_p(char *, int);
int __cdecl dl_higher_prime_number(unsigned int);
int __cdecl dl_strtoul(_BYTE *, _DWORD *);
unsigned int dl_start_profile();
_TBYTE *__cdecl dl_mcount(int, int);
// unsigned __int8 *__usercall allocate_dtv@<eax>(int *@<eax>);
void __noreturn oom();
unsigned int dl_next_tls_modid();
int dl_count_modids();
_DWORD *__cdecl dl_get_tls_static_info(_DWORD *, _DWORD *);
unsigned __int8 *dl_allocate_tls_storage();
int __cdecl dl_allocate_tls_init(int);
int __cdecl dl_allocate_tls(int *);
int *__cdecl dl_deallocate_tls(int, int);
int __cdecl dl_tls_get_addr_soft(int);
unsigned int *__cdecl dl_add_to_slotinfo(unsigned int);
int dl_get_origin();
// unsigned int __usercall dl_scope_free@<eax>(int ebp0@<ebp>, int *@<edi>, int);
unsigned int __cdecl dl_make_stack_executable(_DWORD *);
void __stdcall dl_runtime_resolve(int a1, int a2, int a3);
int __cdecl dl_runtime_resolve_shstk(int);
// int __usercall dl_runtime_profile_shstk@<eax>(int@<eax>, int@<edx>, int@<ecx>, int, int);
// void __userpurge dl_runtime_profile(unsigned int a1@<edx>, unsigned int a2@<ecx>, long double a3@<st1>, long double a4@<st0>, __int64 _XMM0_8@<xmm0>, __int64 _XMM1_8@<xmm1>, int a7@<eax>, int a8, int a9, char a10, int a11, int a12);
void __noreturn length_mismatch();
const char *__cdecl dl_exception_create(const char **, unsigned int *, unsigned int *);
_BYTE *__cdecl dl_exception_create_format(_DWORD *, unsigned int *, _BYTE *, char);
// int *__usercall dl_exception_free@<eax>(int ebp0@<ebp>, int *@<edi>, _DWORD *);
int __cdecl dl_cache_libcmp(char *, char *);
int *__cdecl dl_load_cache_lookup(char *a1);
unsigned int dl_unload_cache();
// int __usercall dl_tlsdesc_return@<eax>(int@<eax>);
// unsigned int __usercall dl_tlsdesc_undefweak@<eax>(int@<eax>);
// int __usercall dl_tlsdesc_resolve_abs_plus_addend@<eax>(int (__fastcall **)(int, int)@<eax>, int@<edx>, int@<ecx>, int@<ebx>);
// int __usercall dl_tlsdesc_resolve_rel@<eax>(int (__fastcall **)(int, int)@<eax>, int@<edx>, int@<ecx>, int@<ebx>);
// int __usercall dl_tlsdesc_resolve_rela@<eax>(int (__fastcall **)(int, int)@<eax>, int@<edx>, int@<ecx>, int@<ebx>);
// int __usercall dl_tlsdesc_resolve_hold@<eax>(char **@<eax>, int@<edx>, int@<ecx>);
int __cdecl do_dlopen(int);
// int __usercall dlerror_run@<eax>(void (__cdecl *)(int)@<eax>, int@<edx>, int@<ebp>, int *@<edi>);
// int __usercall _libc_dlclose@<eax>(int@<ebp>, int *edi0@<edi>, int);
// int __usercall _libc_dlsym@<eax>(int@<ebp>, int *edi0@<edi>, int, int);
// int __usercall _libc_dlvsym@<eax>(int@<ebp>, int *@<edi>, int, int, unsigned __int8 *);
unsigned int __cdecl do_dlsym_private(int);
_DWORD *__cdecl do_dlsym(int *);
_DWORD *__cdecl do_dlvsym(int *);
int __cdecl do_dlclose(int);
// int __usercall _libc_dlsym_private@<eax>(int@<ebp>, int *edi0@<edi>, int, int);
// _DWORD *__usercall _libc_register_dl_open_hook@<eax>(int@<ebp>, int *edi0@<edi>, int);
// int __usercall _libc_dlopen_mode@<eax>(int@<ebp>, int *edi0@<edi>, int, int);
// void __usercall __noreturn fatal_error(signed int@<eax>, _BYTE *@<edx>, const char *@<ecx>, int);
void __cdecl __noreturn dl_signal_exception(signed int, int, const char *);
void __cdecl __noreturn dl_signal_error(int, unsigned int *, int, unsigned int *);
// int __usercall dl_catch_exception@<eax>(int@<ebp>, int@<edi>, int@<esi>, _DWORD *, void (__cdecl *)(int), int);
// int __usercall dl_catch_error@<eax>(int@<ebp>, _DWORD *, _DWORD *, bool *, void (__cdecl *)(int), int);
// int __usercall _sigsetjmp@<eax>(int ebx0@<ebx>, int ebp0@<ebp>, int@<edi>, int@<esi>, int, int);
int __cdecl _sigjmp_save(int, int);
void _longjmp(struct __jmp_buf_tag env[1], int val);
int __cdecl _mpn_cmp(int, int, int);
int __cdecl _mpn_divrem(int, int, unsigned int *, int, unsigned int *, int);
int __cdecl _mpn_lshift(_DWORD *, int, int, char);
int __cdecl _mpn_rshift(int, unsigned int *, int, char);
int __cdecl _mpn_mul(int *, int *, int, unsigned int *, int);
int __cdecl _mpn_mul_1(int, int, int, unsigned int);
int __cdecl _mpn_impn_mul_n_basecase(int, int *, unsigned int *, int);
int __cdecl _mpn_impn_mul_n(int *, int *, unsigned int *, int, _DWORD *);
unsigned int *__cdecl _mpn_impn_sqr_n_basecase(int a1, unsigned int *a2, int a3);
unsigned int __cdecl _mpn_impn_sqr_n(unsigned int *a1, unsigned int *a2, int a3, _DWORD *a4);
unsigned int __cdecl _mpn_mul_n(unsigned int *, unsigned int *, unsigned int *, int);
_BOOL4 __cdecl _mpn_sub_n(_DWORD *, unsigned int *, _DWORD *, unsigned int);
int __cdecl _mpn_submul_1(int, int, int, unsigned int);
int __cdecl _mpn_extract_double(unsigned int *, int, _DWORD *, unsigned int *, unsigned int, unsigned int);
int __cdecl _mpn_extract_long_double(int, int, int, int, long double);
int __cdecl _mpn_extract_float128(_DWORD *, int, _DWORD *, int *, __int128);
int __cdecl itoa_word(unsigned int, int, unsigned int, int);
_BYTE *__cdecl itoa(unsigned __int64, _BYTE *, unsigned int, int);
char *__cdecl fitoa_word(unsigned int, _BYTE *, unsigned int, int);
_BYTE *__cdecl fitoa(unsigned __int64, _BYTE *, unsigned int, int);
_DWORD *__cdecl itowa(unsigned __int64, _DWORD *, unsigned int, int);
void *init();
int *_dlerror();
// const char **__usercall check_free_isra_0@<eax>(const char **result@<eax>, int@<ebp>);
// int __usercall free_key_mem@<eax>(int ebp0@<ebp>, int *@<edi>, int);
// int __usercall dlerror_run@<eax>(int@<ebp>, int *edi0@<edi>, void (__cdecl *)(int), int);
// _DWORD *__usercall _libc_register_dlfcn_hook@<eax>(int ebp0@<ebp>, int *@<edi>, int);
int __cdecl _dladdr(unsigned int, _DWORD *);
int __cdecl _dladdr1(unsigned int, _DWORD *, unsigned int *, int);
void __cdecl dlinfo_doit(int);
void __fastcall sub_8096470(int, int);
// int __usercall _dlinfo@<eax>(int@<ebp>, int *@<edi>, int, int, int, int);
int __cdecl dlmopen_doit(_DWORD *);
// int __usercall _dlmopen@<eax>(int@<ebp>, int *@<edi>, int, int, int, int);
unsigned __int8 *__cdecl strerror(signed int);
_BYTE *__cdecl strspn(int, _BYTE *);
int __cdecl strsep(int *, _BYTE *);
unsigned int __cdecl _getdents64(int, struct dirent *, unsigned int);
int getpid();
unsigned int __cdecl _profil_counter(int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int);
int __cdecl profil(int a1, unsigned int a2, int a3, int a4);
int _profile_frequency();
// int (*__usercall dl_fixup@<eax>(int@<eax>, int@<edx>))(void);
// int (*__userpurge dl_profile_fixup@<eax>(int@<eax>, unsigned int@<edx>, int@<ecx>, int, _DWORD *))(void);
void __stdcall dl_call_pltexit(int);
// int __usercall add_to_global@<eax>(int@<eax>);
_DWORD *__cdecl dl_find_dso_for_object(unsigned int);
int __cdecl dl_open(unsigned int *, int, int, int, int, int, int);
int __cdecl dl_show_scope(_DWORD *, int);
char **__cdecl dl_open_worker(char **);
// int __usercall remove_slotinfo@<eax>(int@<eax>, _DWORD *@<edx>, int@<ecx>, unsigned __int8);
_TBYTE *__cdecl dl_close_worker(int, char);
int __cdecl dl_close(int);
unsigned int __cdecl dl_sort_maps(int a1, unsigned int a2, int a3, unsigned __int8 a4);
// int __usercall dl_tlsdesc_resolve_early_return_p@<eax>(int (__usercall **)@<eax>(char **a1@<eax>, int a2@<edx>, int a3@<ecx>)@<eax>, int (__usercall *)@<eax>(char **a1@<eax>, int a2@<edx>, int a3@<ecx>)@<edx>);
// int __usercall dl_tlsdesc_resolve_abs_plus_addend_fixup@<eax>(int@<eax>, int@<edx>, int@<ecx>);
// int __usercall dl_tlsdesc_resolve_rel_fixup@<eax>(int@<eax>, _DWORD *@<edx>, int@<ecx>);
// int __usercall dl_tlsdesc_resolve_rela_fixup@<eax>(int@<eax>, _DWORD *@<edx>, int@<ecx>);
// char *__usercall dl_tlsdesc_resolve_hold_fixup@<eax>(char **@<eax>, int@<ecx>);
unsigned int __cdecl dl_unmap(int);
char __cdecl dl_cet_open_check(int);
int __cdecl dl_addr(unsigned int, _DWORD *, _DWORD *, unsigned int *);
int __cdecl dl_addr_inside_object(int, int);
// char *__usercall sub_8099B80@<eax>(int@<eax>);
_BOOL4 __cdecl _mpn_add_n(_DWORD *, _DWORD *, _DWORD *, unsigned int);
int __cdecl _mpn_addmul_1(int, int, int, unsigned int);
int __cdecl dlopen_doit(int);
// int __usercall _dlopen@<eax>(int@<ebp>, int *edi0@<edi>, int, int, int);
int __cdecl dlclose_doit(int);
// int __usercall _dlclose@<eax>(int@<ebp>, int *@<edi>, int);
int (*__cdecl dlsym_doit(int a1))(void);
// __int64 __usercall _dlsym@<edx:eax>(int@<ebp>, int *@<edi>, int, int, int);
int (*__cdecl dlvsym_doit(int a1))(void);
// __int64 __usercall _dlvsym@<edx:eax>(int@<ebp>, int *@<edi>, int, int, int, int);
unsigned int __cdecl setitimer(int, struct itimerval *, struct itimerval *);
// int __usercall dl_build_local_scope@<eax>(_DWORD *@<eax>, int@<edx>);
// unsigned __int8 *__usercall openaux@<eax>(unsigned int *edi0@<edi>, int);
// struct timespec *__usercall dl_map_object_deps@<eax>(int@<ebx>, int@<ebp>, int@<edi>, int@<esi>);
// int __usercall call_init_part_0@<eax>(int result@<eax>, int@<edx>, int@<ecx>, int);
_DWORD *__cdecl dl_init(_DWORD *, int, int, int);
int __cdecl dl_check_map_versions(_DWORD *, int, int);
int __cdecl dl_check_all_versions(int, int, int);
_DWORD *__cdecl call_dl_lookup(int);
// int (*__usercall do_sym@<eax>(int a1@<eax>, unsigned __int8 *a2@<edx>, unsigned int a3@<ecx>, _DWORD *a4, int a5))(void);
int (*__cdecl dl_vsym(int a1, unsigned __int8 *a2, unsigned __int8 *a3, unsigned int a4))(void);
int (*__cdecl dl_sym(int a1, unsigned __int8 *a2, unsigned int a3))(void);
unsigned int __cdecl _lttf2(unsigned __int64 a1, unsigned int a2, int a3, unsigned __int64 a4, unsigned int a5, int a6);
unsigned int __cdecl _unordtf2(int a1, int a2, int a3, unsigned int a4, int a5, int a6, int a7, unsigned int a8);
int __cdecl _sfp_handle_exceptions(int);
// _DWORD *__usercall read_encoded_value_with_base@<eax>(char@<al>, int@<ecx>, _DWORD *);
// int __usercall base_of_encoded_value@<eax>(char@<al>, _DWORD *@<edx>, int@<ebp>, int *@<edi>, const struct timespec *@<esi>);
// struct timespec *__usercall execute_cfa_program@<eax>(struct timespec *result@<eax>, unsigned int@<edx>, int *@<ecx>, int *);
_TBYTE *init_dwarf_reg_size_table();
// int __usercall uw_frame_state_for@<eax>(int *@<eax>, _DWORD *@<edx>);
// int __usercall execute_stack_op@<eax>(const struct timespec *@<eax>, unsigned int@<edx>, int@<ebp>, int *@<edi>, int);
// unsigned int __usercall uw_update_context_1@<eax>(int@<eax>, int@<edx>, int);
// int __usercall uw_init_context_1@<eax>(int@<eax>, int@<edx>, int@<ecx>);
// int __usercall uw_update_context@<eax>(int@<eax>, int@<edx>);
// int __usercall Unwind_RaiseException_Phase2@<eax>(const struct timespec *@<eax>, int *@<edx>, int *@<ecx>, int, int, int);
// int __usercall Unwind_ForcedUnwind_Phase2@<eax>(_DWORD *@<eax>, int *@<edx>, int *@<ecx>);
// int __usercall uw_install_context_1@<eax>(int@<eax>, unsigned int@<edx>, unsigned int@<ebp>, int, int, int);
int __cdecl Unwind_GetGR(int, int);
int __cdecl Unwind_GetCFA(int);
// int *__usercall Unwind_SetGR@<eax>(int a1@<ebp>, int *a2@<edi>, const struct timespec *a3@<esi>, int a4, int a5, int a6);
int __cdecl Unwind_GetIP(int);
int __cdecl Unwind_GetIPInfo(int, _DWORD *);
int __cdecl Unwind_SetIP(int, int);
int __cdecl Unwind_GetLanguageSpecificData(int);
int __cdecl Unwind_GetRegionStart(int);
int *__cdecl Unwind_FindEnclosingFunction(int);
int __cdecl Unwind_GetDataRelBase(int);
int __cdecl Unwind_GetTextRelBase(int);
int __cdecl _frame_state_for(int, int);
void Unwind_DebugHook();
// int __usercall Unwind_RaiseException@<eax>(int@<eax>, int@<edx>, const struct timespec *);
// int __usercall Unwind_ForcedUnwind@<eax>(int@<eax>, int@<edx>, _DWORD *, int, int);
// void __usercall __noreturn Unwind_Resume(int@<eax>, int@<edx>, struct timespec *);
// void __usercall __noreturn Unwind_Resume_or_Rethrow(int@<eax>, int@<edx>, struct timespec *);
int (__cdecl *__cdecl Unwind_DeleteException(int))(int, int);
int __cdecl Unwind_Backtrace(int (__cdecl *)(int *, int), int);
int __cdecl fde_unencoded_compare(int, int, int);
// int __usercall frame_downheap@<eax>(int result@<eax>, int (__cdecl *)(int, int, int)@<edx>, int@<ecx>, int, int);
// int __usercall frame_heapsort@<eax>(int@<eax>, int (__cdecl *)(int, int, int)@<edx>, int@<ecx>);
// int __usercall size_of_encoded_value@<eax>(char@<al>, int@<ebp>, int *@<edi>, const struct timespec *@<esi>);
// int __usercall base_from_object@<eax>(char@<al>, int@<edx>, int@<ebp>, int *@<edi>, const struct timespec *@<esi>);
// int __usercall base_from_cb_data@<eax>(char@<al>, int@<edx>, int@<ebp>, int *@<edi>, const struct timespec *@<esi>);
// _DWORD *__usercall read_encoded_value_with_base_0@<eax>(char@<al>, int@<ecx>, _DWORD *);
// int __usercall fde_single_encoding_compare@<eax>(int@<ebp>, const struct timespec *@<esi>, int, int, int);
// int __usercall get_cie_encoding@<eax>(int@<eax>);
// _DWORD *__usercall linear_search_fdes@<eax>(int@<eax>, _DWORD *@<edx>, int@<ecx>, int *@<edi>);
int __cdecl Unwind_IteratePhdrCallback(int, unsigned int, int *);
int __cdecl fde_mixed_encoding_compare(int, const struct timespec *, int);
// int __usercall classify_object_over_fdes@<eax>(int@<eax>, _DWORD *@<edx>);
// int __usercall add_fdes@<eax>(int@<eax>, int *@<edx>, int *@<ecx>, int@<ebp>);
// int *__usercall search_object@<eax>(int@<eax>, int *@<edx>, const struct timespec *@<esi>);
// int __usercall _register_frame_info_bases_part_5@<eax>(int@<eax>, _DWORD *@<edx>, int@<ecx>, int);
_DWORD *__cdecl _register_frame_info_bases(_DWORD *a1, _DWORD *a2, int a3, int a4);
_DWORD *__cdecl _register_frame_info(_DWORD *a1, _DWORD *a2);
int __cdecl _register_frame(int *);
int __cdecl _register_frame_info_table_bases(int, _DWORD *, int, int);
int __cdecl _register_frame_info_table(int, _DWORD *);
int __cdecl _register_frame_table(int);
int __cdecl _deregister_frame_info_bases(int *);
int __cdecl _deregister_frame_info(int *);
// int *__usercall _deregister_frame@<eax>(int@<ebp>, int *@<edi>, int *);
int *__cdecl Unwind_Find_FDE(int *, _DWORD *);
// int __usercall base_of_encoded_value_0@<eax>(char@<al>, int@<edx>, int@<ebp>, int *@<edi>, const struct timespec *@<esi>);
// _DWORD *__usercall read_encoded_value_with_base_1@<eax>(char@<al>, int@<ecx>, _DWORD *);
// int __usercall _gcc_personality_v0@<eax>(int@<ebp>, int, char, int, int, int, int);
int __cdecl dl_iterate_phdr(int (__cdecl *)(int *, int, int), int);
// int *__usercall free_mem@<eax>(int@<ecx>, const char *@<ebp>);
// int *__usercall nl_finddomain_subfreeres@<eax>(int@<ebp>, int *@<edi>);
// int *__usercall nl_unload_domain@<eax>(unsigned int a1@<edi>, int a2);
// int *__usercall buffer_free@<eax>(int@<ebp>, int *@<edi>);
// int *__usercall free_derivation@<eax>(int *@<edi>, int);
// int *__usercall free_modules_db@<eax>(_DWORD *@<eax>, int@<ebp>);
// int *__usercall free_mem_0@<eax>(int *@<ebp>, int *@<edi>);
// int *__usercall free_mem_1@<eax>(int@<ebp>, int *@<edi>);
// int *__usercall free_mem_2@<eax>(int@<ebp>, int *@<edi>);
// int *__usercall do_release_all@<eax>(int@<ebp>, int *@<edi>, int);
// int *__usercall free_mem_3@<eax>(int@<ecx>, int@<ebp>);
// int *__usercall free_category@<eax>(int *result@<eax>, void **@<edx>, void **@<ecx>, int@<ebp>);
// int __usercall nl_locale_subfreeres@<eax>(int *@<ebp>, int *@<edi>);
// int __usercall nl_archive_subfreeres@<eax>(int *@<ebp>);
// int *__usercall free_mem_4@<eax>(int@<ebp>, int *@<edi>);
// void __usercall free_mem_5(int@<ebp>);
// int __usercall free_slotinfo@<eax>(int ***@<eax>, int@<ebp>);
// int *__usercall free_mem_6@<eax>(_DWORD *@<ebp>);

//-------------------------------------------------------------------------
// Data declarations

_UNKNOWN _restore; // weak
_UNKNOWN def_8075167; // weak
char aOutputCharset[15] = "OUTPUT_CHARSET"; // weak
char yyr2[16] =
{
  '\0',
  '\x02',
  '\x01',
  '\x05',
  '\x03',
  '\x03',
  '\x03',
  '\x03',
  '\x03',
  '\x03',
  '\x02',
  '\x01',
  '\x01',
  '\x03',
  '\0',
  '\0'
}; // weak
char yyr1[36] =
{
  '\0',
  '\x10',
  '\x11',
  '\x12',
  '\x12',
  '\x12',
  '\x12',
  '\x12',
  '\x12',
  '\x12',
  '\x12',
  '\x12',
  '\x12',
  '\x12',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // weak
char yycheck[] = { '\x01' }; // weak
char byte_80A2581[63] =
{
  '\n',
  '\v',
  '\x04',
  '\r',
  '\x0E',
  '\b',
  '\t',
  '\0',
  '\n',
  '\v',
  '\f',
  '\r',
  '\x0E',
  '\x0F',
  '\x10',
  '\x03',
  '\x04',
  '\x05',
  '\x06',
  '\a',
  '\b',
  '\t',
  '\t',
  '\x19',
  '\a',
  '\b',
  '\t',
  '\x0F',
  '\x03',
  '\x04',
  '\x05',
  '\x06',
  '\a',
  '\b',
  '\t',
  '\xFF',
  '\xFF',
  '\f',
  '\x03',
  '\x04',
  '\x05',
  '\x06',
  '\a',
  '\b',
  '\t',
  '\x05',
  '\x06',
  '\a',
  '\b',
  '\t',
  '\x06',
  '\a',
  '\b',
  '\t',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // weak
char yytable[] = { '\a' }; // weak
char byte_80A25C1[41] =
{
  '\x01',
  '\x02',
  '\b',
  '\x03',
  '\x04',
  '\x0F',
  '\x10',
  '\t',
  '\x12',
  '\x13',
  '\x14',
  '\x15',
  '\x16',
  '\x17',
  '\x18',
  '\n',
  '\v',
  '\f',
  '\r',
  '\x0E',
  '\x0F',
  '\x10',
  '\x10',
  '\x1A',
  '\x0E',
  '\x0F',
  '\x10',
  '\x11',
  '\n',
  '\v',
  '\f',
  '\r',
  '\x0E',
  '\x0F',
  '\x10',
  '\0',
  '\0',
  '\x19',
  '\n',
  '\v',
  '\f'
}; // weak
char byte_80A25EA[13] =
{
  '\r',
  '\x0E',
  '\x0F',
  '\x10',
  '\f',
  '\r',
  '\x0E',
  '\x0F',
  '\x10',
  '\r',
  '\x0E',
  '\x0F',
  '\x10'
}; // weak
char yydefgoto[3] = { '\xFF', '\x05', '\x06' }; // weak
char yydefact[] = { '\0' }; // weak
char yypact[36] =
{
  '\xF7',
  '\xF7',
  '\xF6',
  '\xF6',
  '\xF7',
  '\b',
  '$',
  '\xF6',
  '\r',
  '\xF6',
  '\xF7',
  '\xF7',
  '\xF7',
  '\xF7',
  '\xF7',
  '\xF7',
  '\xF7',
  '\xF6',
  '\x1A',
  ')',
  '-',
  '\x12',
  '\xFE',
  '\x0E',
  '\xF6',
  '\xF7',
  '$',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // weak
char yytranslate[284] =
{
  '\0',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\n',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x05',
  '\x02',
  '\x0E',
  '\x0F',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\f',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x03',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\r',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x04',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x01',
  '\x02',
  '\x06',
  '\a',
  '\b',
  '\t',
  '\v',
  'p',
  'l',
  'u',
  'r',
  'a',
  'l',
  '=',
  '\0',
  'n',
  'p',
  'l',
  'u',
  'r',
  'a',
  'l',
  's',
  '=',
  '\0',
  '\0',
  '\0',
  '\0'
}; // weak
char aFatalErrorGlib[53] = "Fatal error: glibc detected an invalid stdio handle\n"; // weak
char aMallocTopChunk[29] = "malloc: top chunk is corrupt"; // weak
char aCorruptedSizeV[29] = "corrupted size vs. prev_size"; // weak
char aCorruptedDoubl[29] = "corrupted double-linked list"; // weak
char aFreeInvalidPoi[24] = "free(): invalid pointer"; // weak
char aFreeInvalidSiz[21] = "free(): invalid size"; // weak
char aInvalidFastbin[29] = "invalid fastbin entry (free)"; // weak
char aReallocInvalid[27] = "realloc(): invalid pointer"; // weak
char aCorruptedDoubl_0[41] = "corrupted double-linked list (not small)"; // weak
char aMunmapChunkInv[32] = "munmap_chunk(): invalid pointer"; // weak
char aMremapChunkInv[32] = "mremap_chunk(): invalid pointer"; // weak
char aFreeDoubleFree[41] = "free(): double free detected in tcache 2"; // weak
char aFreeInvalidNex[33] = "free(): invalid next size (fast)"; // weak
char aDoubleFreeOrCo[36] = "double free or corruption (fasttop)"; // weak
char aDoubleFreeOrCo_0[32] = "double free or corruption (top)"; // weak
char aDoubleFreeOrCo_1[32] = "double free or corruption (out)"; // weak
char aDoubleFreeOrCo_2[34] = "double free or corruption (!prev)"; // weak
char aFreeInvalidNex_0[35] = "free(): invalid next size (normal)"; // weak
char aCorruptedSizeV_0[49] = "corrupted size vs. prev_size while consolidating"; // weak
char aFreeCorruptedU[34] = "free(): corrupted unsorted chunks"; // weak
char aBreakAdjustedT[36] = "break adjusted to free malloc space"; // weak
char aMallocCheckGet[41] = "malloc_check_get_size: memory corruption"; // weak
struct timespec stru_80A46D8 = { 0, 0 }; // weak
_BYTE dl_x86_platforms[36] =
{
  105,
  53,
  56,
  54,
  0,
  0,
  0,
  0,
  0,
  105,
  54,
  56,
  54,
  0,
  0,
  0,
  0,
  0,
  104,
  97,
  115,
  119,
  101,
  108,
  108,
  0,
  0,
  120,
  101,
  111,
  110,
  95,
  112,
  104,
  105,
  0
}; // weak
_UNKNOWN unk_80A4B4A; // weak
_BYTE byte_80A4C94[2] = { 44, 0 }; // weak
char builtin_aliases[7] = "UCS4//"; // weak
_UNKNOWN empty_path_elem; // weak
char nl_category_name_sizes[16] =
{
  '\b',
  '\n',
  '\a',
  '\n',
  '\v',
  '\v',
  '\x06',
  '\b',
  '\a',
  '\n',
  '\f',
  '\x0E',
  '\x11',
  '\0',
  '\0',
  '\0'
}; // weak
char nl_category_name_idxs[16] =
{
  '\v',
  ' ',
  '+',
  '\0',
  '\x14',
  '3',
  '\0',
  '?',
  'H',
  'P',
  '[',
  'h',
  'w',
  '\0',
  '\0',
  '\0'
}; // weak
char nl_category_names[11] = "LC_COLLATE"; // weak
unsigned int slashdot_10224 = 791555631u; // weak
int codeset_idx_10249[13] = { 14, 5, 110, 18, 45, 4, 0, 2, 6, 12, 4, 1, 15 }; // weak
int nl_category_num_items[13] = { 86, 6, 159, 19, 46, 5, 0, 3, 7, 13, 5, 2, 16 }; // weak
_DWORD dword_80A6A40[256] =
{
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  13,
  14,
  15,
  16,
  17,
  18,
  19,
  20,
  21,
  22,
  23,
  24,
  25,
  26,
  27,
  28,
  29,
  30,
  31,
  32,
  33,
  34,
  35,
  36,
  37,
  38,
  39,
  40,
  41,
  42,
  43,
  44,
  45,
  46,
  47,
  48,
  49,
  50,
  51,
  52,
  53,
  54,
  55,
  56,
  57,
  58,
  59,
  60,
  61,
  62,
  63,
  64,
  97,
  98,
  99,
  100,
  101,
  102,
  103,
  104,
  105,
  106,
  107,
  108,
  109,
  110,
  111,
  112,
  113,
  114,
  115,
  116,
  117,
  118,
  119,
  120,
  121,
  122,
  91,
  92,
  93,
  94,
  95,
  96,
  97,
  98,
  99,
  100,
  101,
  102,
  103,
  104,
  105,
  106,
  107,
  108,
  109,
  110,
  111,
  112,
  113,
  114,
  115,
  116,
  117,
  118,
  119,
  120,
  121,
  122,
  123,
  124,
  125,
  126,
  127,
  128,
  129,
  130,
  131,
  132,
  133,
  134,
  135,
  136,
  137,
  138,
  139,
  140,
  141,
  142,
  143,
  144,
  145,
  146,
  147,
  148,
  149,
  150,
  151,
  152,
  153,
  154,
  155,
  156,
  157,
  158,
  159,
  160,
  161,
  162,
  163,
  164,
  165,
  166,
  167,
  168,
  169,
  170,
  171,
  172,
  173,
  174,
  175,
  176,
  177,
  178,
  179,
  180,
  181,
  182,
  183,
  184,
  185,
  186,
  187,
  188,
  189,
  190,
  191,
  192,
  193,
  194,
  195,
  196,
  197,
  198,
  199,
  200,
  201,
  202,
  203,
  204,
  205,
  206,
  207,
  208,
  209,
  210,
  211,
  212,
  213,
  214,
  215,
  216,
  217,
  218,
  219,
  220,
  221,
  222,
  223,
  224,
  225,
  226,
  227,
  228,
  229,
  230,
  231,
  232,
  233,
  234,
  235,
  236,
  237,
  238,
  239,
  240,
  241,
  242,
  243,
  244,
  245,
  246,
  247,
  248,
  249,
  250,
  251,
  252,
  253,
  254,
  255
}; // weak
int dword_80A7040[256] =
{
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  13,
  14,
  15,
  16,
  17,
  18,
  19,
  20,
  21,
  22,
  23,
  24,
  25,
  26,
  27,
  28,
  29,
  30,
  31,
  32,
  33,
  34,
  35,
  36,
  37,
  38,
  39,
  40,
  41,
  42,
  43,
  44,
  45,
  46,
  47,
  48,
  49,
  50,
  51,
  52,
  53,
  54,
  55,
  56,
  57,
  58,
  59,
  60,
  61,
  62,
  63,
  64,
  65,
  66,
  67,
  68,
  69,
  70,
  71,
  72,
  73,
  74,
  75,
  76,
  77,
  78,
  79,
  80,
  81,
  82,
  83,
  84,
  85,
  86,
  87,
  88,
  89,
  90,
  91,
  92,
  93,
  94,
  95,
  96,
  65,
  66,
  67,
  68,
  69,
  70,
  71,
  72,
  73,
  74,
  75,
  76,
  77,
  78,
  79,
  80,
  81,
  82,
  83,
  84,
  85,
  86,
  87,
  88,
  89,
  90,
  123,
  124,
  125,
  126,
  127,
  128,
  129,
  130,
  131,
  132,
  133,
  134,
  135,
  136,
  137,
  138,
  139,
  140,
  141,
  142,
  143,
  144,
  145,
  146,
  147,
  148,
  149,
  150,
  151,
  152,
  153,
  154,
  155,
  156,
  157,
  158,
  159,
  160,
  161,
  162,
  163,
  164,
  165,
  166,
  167,
  168,
  169,
  170,
  171,
  172,
  173,
  174,
  175,
  176,
  177,
  178,
  179,
  180,
  181,
  182,
  183,
  184,
  185,
  186,
  187,
  188,
  189,
  190,
  191,
  192,
  193,
  194,
  195,
  196,
  197,
  198,
  199,
  200,
  201,
  202,
  203,
  204,
  205,
  206,
  207,
  208,
  209,
  210,
  211,
  212,
  213,
  214,
  215,
  216,
  217,
  218,
  219,
  220,
  221,
  222,
  223,
  224,
  225,
  226,
  227,
  228,
  229,
  230,
  231,
  232,
  233,
  234,
  235,
  236,
  237,
  238,
  239,
  240,
  241,
  242,
  243,
  244,
  245,
  246,
  247,
  248,
  249,
  250,
  251,
  252,
  253,
  254,
  255
}; // weak
_BYTE byte_80A7940[512] =
{
  2,
  0,
  2,
  0,
  2,
  0,
  2,
  0,
  2,
  0,
  2,
  0,
  2,
  0,
  2,
  0,
  2,
  0,
  3,
  32,
  2,
  32,
  2,
  32,
  2,
  32,
  2,
  32,
  2,
  0,
  2,
  0,
  2,
  0,
  2,
  0,
  2,
  0,
  2,
  0,
  2,
  0,
  2,
  0,
  2,
  0,
  2,
  0,
  2,
  0,
  2,
  0,
  2,
  0,
  2,
  0,
  2,
  0,
  2,
  0,
  2,
  0,
  2,
  0,
  1,
  96,
  4,
  -64,
  4,
  -64,
  4,
  -64,
  4,
  -64,
  4,
  -64,
  4,
  -64,
  4,
  -64,
  4,
  -64,
  4,
  -64,
  4,
  -64,
  4,
  -64,
  4,
  -64,
  4,
  -64,
  4,
  -64,
  4,
  -64,
  8,
  -40,
  8,
  -40,
  8,
  -40,
  8,
  -40,
  8,
  -40,
  8,
  -40,
  8,
  -40,
  8,
  -40,
  8,
  -40,
  8,
  -40,
  4,
  -64,
  4,
  -64,
  4,
  -64,
  4,
  -64,
  4,
  -64,
  4,
  -64,
  4,
  -64,
  8,
  -43,
  8,
  -43,
  8,
  -43,
  8,
  -43,
  8,
  -43,
  8,
  -43,
  8,
  -59,
  8,
  -59,
  8,
  -59,
  8,
  -59,
  8,
  -59,
  8,
  -59,
  8,
  -59,
  8,
  -59,
  8,
  -59,
  8,
  -59,
  8,
  -59,
  8,
  -59,
  8,
  -59,
  8,
  -59,
  8,
  -59,
  8,
  -59,
  8,
  -59,
  8,
  -59,
  8,
  -59,
  8,
  -59,
  4,
  -64,
  4,
  -64,
  4,
  -64,
  4,
  -64,
  4,
  -64,
  4,
  -64,
  8,
  -42,
  8,
  -42,
  8,
  -42,
  8,
  -42,
  8,
  -42,
  8,
  -42,
  8,
  -58,
  8,
  -58,
  8,
  -58,
  8,
  -58,
  8,
  -58,
  8,
  -58,
  8,
  -58,
  8,
  -58,
  8,
  -58,
  8,
  -58,
  8,
  -58,
  8,
  -58,
  8,
  -58,
  8,
  -58,
  8,
  -58,
  8,
  -58,
  8,
  -58,
  8,
  -58,
  8,
  -58,
  8,
  -58,
  4,
  -64,
  4,
  -64,
  4,
  -64,
  4,
  -64,
  2,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0
}; // weak
_UNKNOWN unk_80B1B80; // weak
char byte_80B1BFE[2] = { '\xFF', '\xFF' }; // weak
char _strtol_ul_rem_tab[] = { '\x01' }; // weak
char aVfprintfC[11] = "vfprintf.c"; // weak
char aSFlags2IoFlags[32] = "s->_flags2 & _IO_FLAGS2_FORTIFY"; // weak
char aUnsignedIntDon[45] = "(unsigned int) done < (unsigned int) INT_MAX"; // weak
char aSizeTDoneSizeT[34] = "(size_t) done <= (size_t) INT_MAX"; // weak
char aNInWritableSeg[41] = "*** %n in writable segment detected ***\n"; // weak
char _PRETTY_FUNCTION___13739[18] = "printf_positional"; // weak
_UNKNOWN _PRETTY_FUNCTION___13500; // weak
char jump_table[91] =
{
  '\x01',
  '\0',
  '\0',
  '\x04',
  '\0',
  '\x0E',
  '\0',
  '\x06',
  '\0',
  '\0',
  '\a',
  '\x02',
  '\0',
  '\x03',
  '\t',
  '\0',
  '\x05',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x1A',
  '\0',
  '\x19',
  '\0',
  '\x13',
  '\x13',
  '\x13',
  '\0',
  '\x1D',
  '\0',
  '\0',
  '\f',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x15',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x12',
  '\0',
  '\r',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x1A',
  '\0',
  '\x14',
  '\x0F',
  '\x13',
  '\x13',
  '\x13',
  '\n',
  '\x0F',
  '\x1C',
  '\0',
  '\v',
  '\x18',
  '\x17',
  '\x11',
  '\x16',
  '\f',
  '\0',
  '\x15',
  '\x1B',
  '\x10',
  '\0',
  '\0',
  '\x12',
  '\0',
  '\r'
}; // weak
_UNKNOWN unk_80B1E5B; // weak
_UNKNOWN unk_80B1E5F; // weak
_UNKNOWN unk_80B1E67; // weak
_UNKNOWN unk_80B1E6C; // weak
_UNKNOWN unk_80B1E7C; // weak
_BYTE byte_80B1EAC[36] =
{
  48,
  0,
  0,
  0,
  46,
  0,
  0,
  0,
  48,
  0,
  0,
  0,
  48,
  0,
  0,
  0,
  48,
  0,
  0,
  0,
  49,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0
}; // weak
__int128 xmmword_80B1ED0 = 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFLL; // weak
__int128 xmmword_80B1EE0 = 0x7FFEFFFFFFFFFFFFFFFFFFFFFFFFFFFFLL; // weak
__int128 xmmword_80B1EF0 = 9223372036854775807LL; // weak
__int64 qword_80B1F00 = 9218868437227405311LL; // weak
_UNKNOWN unk_80B1F74; // weak
_UNKNOWN _PRETTY_FUNCTION___13526; // weak
char jump_table_0[91] =
{
  '\x01',
  '\0',
  '\0',
  '\x04',
  '\0',
  '\x0E',
  '\0',
  '\x06',
  '\0',
  '\0',
  '\a',
  '\x02',
  '\0',
  '\x03',
  '\t',
  '\0',
  '\x05',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\b',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x1A',
  '\0',
  '\x19',
  '\0',
  '\x13',
  '\x13',
  '\x13',
  '\0',
  '\x1D',
  '\0',
  '\0',
  '\f',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x15',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x12',
  '\0',
  '\r',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x1A',
  '\0',
  '\x14',
  '\x0F',
  '\x13',
  '\x13',
  '\x13',
  '\n',
  '\x0F',
  '\x1C',
  '\0',
  '\v',
  '\x18',
  '\x17',
  '\x11',
  '\x16',
  '\f',
  '\0',
  '\x15',
  '\x1B',
  '\x10',
  '\0',
  '\0',
  '\x12',
  '\0',
  '\r'
}; // weak
_UNKNOWN zeroes; // weak
char aTheFutexFacili[55] = "The futex facility returned an unexpected error code.\n"; // weak
char aTryingFileS[18] = "  trying file=%s\n"; // weak
char aLib_0[4] = "lib"; // weak
char aCannotMakeSegm[44] = "cannot make segment writable for relocation"; // weak
char aCannotRestoreS[40] = "cannot restore segment prot after reloc"; // weak
char aSRelinkSWithSF[49] = "%s: Relink `%s' with `%s' for IFUNC symbol `%s'\n"; // weak
char aSOutOfMemoryTo[54] = "%s: out of memory to store relocation results for %s\n"; // weak
char aProgramNameUnk[23] = "<program name unknown>"; // weak
char aRelocationProc[30] = "\nrelocation processing: %s%s\n"; // weak
char msg_10942[25] = "unexpected reloc type 0x"; // weak
char aDlMiscC[10] = "dl-misc.c"; // weak
char aNiovNiovmax[15] = "niov < NIOVMAX"; // weak
char aPid0SizeofPidT[32] = "pid >= 0 && sizeof (pid_t) <= 4"; // weak
char _PRETTY_FUNCTION___10496[19] = "_dl_debug_vdprintf"; // weak
_UNKNOWN unk_80B40F6; // weak
unsigned __int8 byte_80B41F9[1671] =
{
  0u,
  2u,
  0u,
  37u,
  97u,
  32u,
  37u,
  98u,
  32u,
  37u,
  101u,
  32u,
  37u,
  72u,
  58u,
  37u,
  77u,
  58u,
  37u,
  83u,
  32u,
  37u,
  90u,
  32u,
  37u,
  89u,
  0u,
  83u,
  0u,
  0u,
  0u,
  117u,
  0u,
  0u,
  0u,
  110u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  77u,
  0u,
  0u,
  0u,
  111u,
  0u,
  0u,
  0u,
  110u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  84u,
  0u,
  0u,
  0u,
  117u,
  0u,
  0u,
  0u,
  101u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  87u,
  0u,
  0u,
  0u,
  101u,
  0u,
  0u,
  0u,
  100u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  84u,
  0u,
  0u,
  0u,
  104u,
  0u,
  0u,
  0u,
  117u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  70u,
  0u,
  0u,
  0u,
  114u,
  0u,
  0u,
  0u,
  105u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  83u,
  0u,
  0u,
  0u,
  97u,
  0u,
  0u,
  0u,
  116u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  83u,
  0u,
  0u,
  0u,
  117u,
  0u,
  0u,
  0u,
  110u,
  0u,
  0u,
  0u,
  100u,
  0u,
  0u,
  0u,
  97u,
  0u,
  0u,
  0u,
  121u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  77u,
  0u,
  0u,
  0u,
  111u,
  0u,
  0u,
  0u,
  110u,
  0u,
  0u,
  0u,
  100u,
  0u,
  0u,
  0u,
  97u,
  0u,
  0u,
  0u,
  121u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  84u,
  0u,
  0u,
  0u,
  117u,
  0u,
  0u,
  0u,
  101u,
  0u,
  0u,
  0u,
  115u,
  0u,
  0u,
  0u,
  100u,
  0u,
  0u,
  0u,
  97u,
  0u,
  0u,
  0u,
  121u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  87u,
  0u,
  0u,
  0u,
  101u,
  0u,
  0u,
  0u,
  100u,
  0u,
  0u,
  0u,
  110u,
  0u,
  0u,
  0u,
  101u,
  0u,
  0u,
  0u,
  115u,
  0u,
  0u,
  0u,
  100u,
  0u,
  0u,
  0u,
  97u,
  0u,
  0u,
  0u,
  121u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  84u,
  0u,
  0u,
  0u,
  104u,
  0u,
  0u,
  0u,
  117u,
  0u,
  0u,
  0u,
  114u,
  0u,
  0u,
  0u,
  115u,
  0u,
  0u,
  0u,
  100u,
  0u,
  0u,
  0u,
  97u,
  0u,
  0u,
  0u,
  121u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  70u,
  0u,
  0u,
  0u,
  114u,
  0u,
  0u,
  0u,
  105u,
  0u,
  0u,
  0u,
  100u,
  0u,
  0u,
  0u,
  97u,
  0u,
  0u,
  0u,
  121u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  83u,
  0u,
  0u,
  0u,
  97u,
  0u,
  0u,
  0u,
  116u,
  0u,
  0u,
  0u,
  117u,
  0u,
  0u,
  0u,
  114u,
  0u,
  0u,
  0u,
  100u,
  0u,
  0u,
  0u,
  97u,
  0u,
  0u,
  0u,
  121u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  74u,
  0u,
  0u,
  0u,
  97u,
  0u,
  0u,
  0u,
  110u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  70u,
  0u,
  0u,
  0u,
  101u,
  0u,
  0u,
  0u,
  98u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  77u,
  0u,
  0u,
  0u,
  97u,
  0u,
  0u,
  0u,
  114u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  65u,
  0u,
  0u,
  0u,
  112u,
  0u,
  0u,
  0u,
  114u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  77u,
  0u,
  0u,
  0u,
  97u,
  0u,
  0u,
  0u,
  121u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  74u,
  0u,
  0u,
  0u,
  117u,
  0u,
  0u,
  0u,
  110u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  74u,
  0u,
  0u,
  0u,
  117u,
  0u,
  0u,
  0u,
  108u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  65u,
  0u,
  0u,
  0u,
  117u,
  0u,
  0u,
  0u,
  103u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  83u,
  0u,
  0u,
  0u,
  101u,
  0u,
  0u,
  0u,
  112u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  79u,
  0u,
  0u,
  0u,
  99u,
  0u,
  0u,
  0u,
  116u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  78u,
  0u,
  0u,
  0u,
  111u,
  0u,
  0u,
  0u,
  118u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  68u,
  0u,
  0u,
  0u,
  101u,
  0u,
  0u,
  0u,
  99u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  74u,
  0u,
  0u,
  0u,
  97u,
  0u,
  0u,
  0u,
  110u,
  0u,
  0u,
  0u,
  117u,
  0u,
  0u,
  0u,
  97u,
  0u,
  0u,
  0u,
  114u,
  0u,
  0u,
  0u,
  121u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  70u,
  0u,
  0u,
  0u,
  101u,
  0u,
  0u,
  0u,
  98u,
  0u,
  0u,
  0u,
  114u,
  0u,
  0u,
  0u,
  117u,
  0u,
  0u,
  0u,
  97u,
  0u,
  0u,
  0u,
  114u,
  0u,
  0u,
  0u,
  121u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  77u,
  0u,
  0u,
  0u,
  97u,
  0u,
  0u,
  0u,
  114u,
  0u,
  0u,
  0u,
  99u,
  0u,
  0u,
  0u,
  104u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  65u,
  0u,
  0u,
  0u,
  112u,
  0u,
  0u,
  0u,
  114u,
  0u,
  0u,
  0u,
  105u,
  0u,
  0u,
  0u,
  108u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  74u,
  0u,
  0u,
  0u,
  117u,
  0u,
  0u,
  0u,
  110u,
  0u,
  0u,
  0u,
  101u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  74u,
  0u,
  0u,
  0u,
  117u,
  0u,
  0u,
  0u,
  108u,
  0u,
  0u,
  0u,
  121u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  65u,
  0u,
  0u,
  0u,
  117u,
  0u,
  0u,
  0u,
  103u,
  0u,
  0u,
  0u,
  117u,
  0u,
  0u,
  0u,
  115u,
  0u,
  0u,
  0u,
  116u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  83u,
  0u,
  0u,
  0u,
  101u,
  0u,
  0u,
  0u,
  112u,
  0u,
  0u,
  0u,
  116u,
  0u,
  0u,
  0u,
  101u,
  0u,
  0u,
  0u,
  109u,
  0u,
  0u,
  0u,
  98u,
  0u,
  0u,
  0u,
  101u,
  0u,
  0u,
  0u,
  114u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  79u,
  0u,
  0u,
  0u,
  99u,
  0u,
  0u,
  0u,
  116u,
  0u,
  0u,
  0u,
  111u,
  0u,
  0u,
  0u,
  98u,
  0u,
  0u,
  0u,
  101u,
  0u,
  0u,
  0u,
  114u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  78u,
  0u,
  0u,
  0u,
  111u,
  0u,
  0u,
  0u,
  118u,
  0u,
  0u,
  0u,
  101u,
  0u,
  0u,
  0u,
  109u,
  0u,
  0u,
  0u,
  98u,
  0u,
  0u,
  0u,
  101u,
  0u,
  0u,
  0u,
  114u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  68u,
  0u,
  0u,
  0u,
  101u,
  0u,
  0u,
  0u,
  99u,
  0u,
  0u,
  0u,
  101u,
  0u,
  0u,
  0u,
  109u,
  0u,
  0u,
  0u,
  98u,
  0u,
  0u,
  0u,
  101u,
  0u,
  0u,
  0u,
  114u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  65u,
  0u,
  0u,
  0u,
  77u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  80u,
  0u,
  0u,
  0u,
  77u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  37u,
  0u,
  0u,
  0u,
  97u,
  0u,
  0u,
  0u,
  32u,
  0u,
  0u,
  0u,
  37u,
  0u,
  0u,
  0u,
  98u,
  0u,
  0u,
  0u,
  32u,
  0u,
  0u,
  0u,
  37u,
  0u,
  0u,
  0u,
  101u,
  0u,
  0u,
  0u,
  32u,
  0u,
  0u,
  0u,
  37u,
  0u,
  0u,
  0u,
  72u,
  0u,
  0u,
  0u,
  58u,
  0u,
  0u,
  0u,
  37u,
  0u,
  0u,
  0u,
  77u,
  0u,
  0u,
  0u,
  58u,
  0u,
  0u,
  0u,
  37u,
  0u,
  0u,
  0u,
  83u,
  0u,
  0u,
  0u,
  32u,
  0u,
  0u,
  0u,
  37u,
  0u,
  0u,
  0u,
  89u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  37u,
  0u,
  0u,
  0u,
  109u,
  0u,
  0u,
  0u,
  47u,
  0u,
  0u,
  0u,
  37u,
  0u,
  0u,
  0u,
  100u,
  0u,
  0u,
  0u,
  47u,
  0u,
  0u,
  0u,
  37u,
  0u,
  0u,
  0u,
  121u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  37u,
  0u,
  0u,
  0u,
  72u,
  0u,
  0u,
  0u,
  58u,
  0u,
  0u,
  0u,
  37u,
  0u,
  0u,
  0u,
  77u,
  0u,
  0u,
  0u,
  58u,
  0u,
  0u,
  0u,
  37u,
  0u,
  0u,
  0u,
  83u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  37u,
  0u,
  0u,
  0u,
  73u,
  0u,
  0u,
  0u,
  58u,
  0u,
  0u,
  0u,
  37u,
  0u,
  0u,
  0u,
  77u,
  0u,
  0u,
  0u,
  58u,
  0u,
  0u,
  0u,
  37u,
  0u,
  0u,
  0u,
  83u,
  0u,
  0u,
  0u,
  32u,
  0u,
  0u,
  0u,
  37u,
  0u,
  0u,
  0u,
  112u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  37u,
  0u,
  0u,
  0u,
  97u,
  0u,
  0u,
  0u,
  32u,
  0u,
  0u,
  0u,
  37u,
  0u,
  0u,
  0u,
  98u,
  0u,
  0u,
  0u,
  32u,
  0u,
  0u,
  0u,
  37u,
  0u,
  0u,
  0u,
  101u,
  0u,
  0u,
  0u,
  32u,
  0u,
  0u,
  0u,
  37u,
  0u,
  0u,
  0u,
  72u,
  0u,
  0u,
  0u,
  58u,
  0u,
  0u,
  0u,
  37u,
  0u,
  0u,
  0u,
  77u,
  0u,
  0u,
  0u,
  58u,
  0u,
  0u,
  0u,
  37u,
  0u,
  0u,
  0u,
  83u,
  0u,
  0u,
  0u,
  32u,
  0u,
  0u,
  0u,
  37u,
  0u,
  0u,
  0u,
  90u,
  0u,
  0u,
  0u,
  32u,
  0u,
  0u,
  0u,
  37u,
  0u,
  0u,
  0u,
  89u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  37u,
  112u,
  37u,
  116u,
  37u,
  103u,
  37u,
  116u,
  37u,
  109u,
  37u,
  116u,
  37u,
  102u,
  0u,
  0u,
  37u,
  97u,
  37u,
  78u,
  37u,
  102u,
  37u,
  78u,
  37u,
  100u,
  37u,
  78u,
  37u,
  98u,
  37u,
  78u,
  37u,
  115u,
  32u,
  37u,
  104u,
  32u,
  37u,
  101u,
  32u,
  37u,
  114u,
  37u,
  78u,
  37u,
  67u,
  45u,
  37u,
  122u,
  32u,
  37u,
  84u,
  37u,
  78u,
  37u,
  99u,
  37u,
  78u,
  0u,
  43u,
  37u,
  99u,
  32u,
  37u,
  97u,
  32u,
  37u,
  108u,
  0u,
  73u,
  83u,
  79u,
  47u,
  73u,
  69u,
  67u,
  32u,
  49u,
  52u,
  54u,
  53u,
  50u,
  32u,
  105u,
  49u,
  56u,
  110u,
  32u,
  70u,
  68u,
  67u,
  67u,
  45u,
  115u,
  101u,
  116u,
  0u,
  75u,
  101u,
  108u,
  100u,
  32u,
  83u,
  105u,
  109u,
  111u,
  110u,
  115u,
  101u,
  110u,
  0u,
  107u,
  101u,
  108u,
  100u,
  64u,
  100u,
  107u,
  117u,
  117u,
  103u,
  46u,
  100u,
  107u,
  0u,
  43u,
  52u,
  53u,
  32u,
  51u,
  49u,
  50u,
  50u,
  45u,
  54u,
  53u,
  52u,
  51u,
  0u,
  43u,
  52u,
  53u,
  32u,
  51u,
  51u,
  50u,
  53u,
  45u,
  54u,
  53u,
  52u,
  51u,
  0u,
  73u,
  83u,
  79u,
  0u,
  49u,
  46u,
  48u,
  0u,
  49u,
  57u,
  57u,
  55u,
  45u,
  49u,
  50u,
  45u,
  50u,
  48u,
  0u,
  0u,
  0u,
  0u,
  73u,
  83u,
  79u,
  47u,
  73u,
  69u,
  67u,
  32u,
  74u,
  84u,
  67u,
  49u,
  47u,
  83u,
  67u,
  50u,
  50u,
  47u,
  87u,
  71u,
  50u,
  48u,
  32u,
  45u,
  32u,
  105u,
  110u,
  116u,
  101u,
  114u,
  110u,
  97u,
  116u,
  105u,
  111u,
  110u,
  97u,
  108u,
  105u,
  122u,
  97u,
  116u,
  105u,
  111u,
  110u,
  0u,
  0u,
  0u,
  67u,
  47u,
  111u,
  32u,
  75u,
  101u,
  108u,
  100u,
  32u,
  83u,
  105u,
  109u,
  111u,
  110u,
  115u,
  101u,
  110u,
  44u,
  32u,
  83u,
  107u,
  116u,
  46u,
  32u,
  74u,
  111u,
  114u,
  103u,
  101u,
  110u,
  115u,
  32u,
  65u,
  108u,
  108u,
  101u,
  32u,
  56u,
  44u,
  32u,
  68u,
  75u,
  45u,
  49u,
  54u,
  49u,
  53u,
  32u,
  75u,
  111u,
  98u,
  101u,
  110u,
  104u,
  97u,
  118u,
  110u,
  32u,
  86u,
  0u,
  105u,
  49u,
  56u,
  110u,
  58u,
  49u,
  57u,
  57u,
  57u,
  0u,
  105u,
  49u,
  56u,
  110u,
  58u,
  49u,
  57u,
  57u,
  57u,
  0u,
  105u,
  49u,
  56u,
  110u,
  58u,
  49u,
  57u,
  57u,
  57u,
  0u,
  105u,
  49u,
  56u,
  110u,
  58u,
  49u,
  57u,
  57u,
  57u,
  0u,
  105u,
  49u,
  56u,
  110u,
  58u,
  49u,
  57u,
  57u,
  57u,
  0u,
  105u,
  49u,
  56u,
  110u,
  58u,
  49u,
  57u,
  57u,
  57u,
  0u,
  0u,
  105u,
  49u,
  56u,
  110u,
  58u,
  49u,
  57u,
  57u,
  57u,
  0u,
  105u,
  49u,
  56u,
  110u,
  58u,
  49u,
  57u,
  57u,
  57u,
  0u,
  105u,
  49u,
  56u,
  110u,
  58u,
  49u,
  57u,
  57u,
  57u,
  0u,
  105u,
  49u,
  56u,
  110u,
  58u,
  49u,
  57u,
  57u,
  57u,
  0u,
  105u,
  49u,
  56u,
  110u,
  58u,
  49u,
  57u,
  57u,
  57u,
  0u,
  105u,
  49u,
  56u,
  110u,
  58u,
  49u,
  57u,
  57u,
  57u,
  0u,
  105u,
  49u,
  56u,
  110u,
  58u,
  49u,
  57u,
  57u,
  57u,
  0u,
  105u,
  49u,
  56u,
  110u,
  58u,
  49u,
  57u,
  57u,
  57u,
  0u,
  105u,
  49u,
  56u,
  110u,
  58u,
  49u,
  57u,
  57u,
  57u,
  0u,
  105u,
  49u,
  56u,
  110u,
  58u,
  49u,
  57u,
  57u,
  57u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u
}; // weak
_UNKNOWN unk_80B4DB0; // weak
_UNKNOWN unk_80B4E70; // weak
_UNKNOWN itoa_base_table; // weak
char itoa_lower_digits[] = { '0' }; // weak
int sys_nerr = 135; // weak
char aCannotCreateSc[25] = "cannot create scope list"; // weak
char aOpeningFileSLu[45] = "opening file=%s [%lu]; direct_opencount=%u\n\n"; // weak
char aTlsGenerationC[53] = "TLS generation counter wrapped!  Please report this."; // weak
char aDlCloseC[11] = "dl-close.c"; // weak
char aIdxNloaded[15] = "idx == nloaded"; // weak
char aImapLNsNsid[19] = "imap->l_ns == nsid"; // weak
char aTmapLNsNsid[19] = "tmap->l_ns == nsid"; // weak
char aDlclose[8] = "dlclose"; // weak
char aImapLTypeLtLoa_0[26] = "imap->l_type == lt_loaded"; // weak
char aNsidLmIdBase[19] = "nsid == LM_ID_BASE"; // weak
char aImapLPrevNull[21] = "imap->l_prev != NULL"; // weak
char aLpLIdx0LpLIdxN[44] = "(*lp)->l_idx >= 0 && (*lp)->l_idx < nloaded"; // weak
char aJmapLIdx0JmapL[42] = "jmap->l_idx >= 0 && jmap->l_idx < nloaded"; // weak
char aImapLTypeLtLoa[68] = "imap->l_type == lt_loaded && (imap->l_flags_1 & DF_1_NODELETE) == 0"; // weak
char _PRETTY_FUNCTION___11769[17] = "_dl_close_worker"; // weak
char aCannotAllocate_4[34] = "cannot allocate dependency buffer"; // weak
char aDstNotAllowedI[38] = "DST not allowed in SUID/SGID programs"; // weak
char aCannotLoadAuxi[79] = "cannot load auxiliary `%s' because of empty dynamic string token substitution\n"; // weak
char aEmptyDynamicSt[40] = "empty dynamic string token substitution"; // weak
char aLoadAuxiliaryO[47] = "load auxiliary object=%s requested by file=%s\n"; // weak
char aCannotAllocate_3[32] = "cannot allocate dependency list"; // weak
char aCannotAllocate_2[35] = "cannot allocate symbol search list"; // weak
char aFiltersNotSupp[47] = "Filters not supported with LD_TRACE_PRELINKING"; // weak
_UNKNOWN unk_80C0800; // weak
_UNKNOWN _gettext_germanic_plural; // weak
void *_wcsmbs_gconv_fcts_c = &to_wc; // weak
char *nl_C_LC_CTYPE = "C"; // weak
char *nl_C_LC_MONETARY = "C"; // weak
char *nl_C_LC_NUMERIC = "C"; // weak
const char *const sys_errlist[] = { "Success" };
char *tunable_list = "glibc.tune.hwcaps"; // weak
char byte_80CD960[] = { '\0' }; // weak
int dword_80CD964[255] =
{
  0,
  0,
  134890476,
  0,
  2147483648,
  -1,
  2147483647,
  0,
  3,
  0,
  0,
  0,
  0,
  134889947,
  2,
  0,
  0,
  -1,
  0,
  0,
  0,
  0,
  1,
  134889975,
  134889998,
  0,
  0,
  0,
  255,
  0,
  0,
  0,
  0,
  1,
  134890019,
  134890035,
  3,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  134890056,
  0,
  2147483648,
  -1,
  2147483647,
  0,
  3,
  0,
  0,
  0,
  0,
  134890076,
  0,
  0,
  0,
  1,
  0,
  0,
  0,
  0,
  0,
  0,
  134890097,
  3,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  134890116,
  0,
  2147483648,
  -1,
  2147483647,
  0,
  3,
  0,
  0,
  0,
  0,
  134890145,
  2,
  0,
  0,
  -1,
  0,
  0,
  0,
  0,
  1,
  134890166,
  134890182,
  0,
  2147483648,
  -1,
  2147483647,
  0,
  0,
  0,
  0,
  1,
  134890204,
  134890516,
  0,
  2147483648,
  -1,
  2147483647,
  0,
  3,
  0,
  0,
  0,
  0,
  134890560,
  2,
  0,
  0,
  -1,
  0,
  0,
  0,
  0,
  0,
  0,
  134890596,
  2,
  0,
  0,
  -1,
  0,
  0,
  0,
  0,
  0,
  0,
  134890636,
  2,
  0,
  0,
  -1,
  0,
  0,
  0,
  0,
  0,
  0,
  134890672,
  0,
  2147483648,
  -1,
  2147483647,
  0,
  3,
  0,
  0,
  0,
  0,
  134890221,
  1,
  0,
  0,
  -1,
  -1,
  1,
  0,
  0,
  0,
  134890243,
  134890257,
  2,
  1,
  0,
  -1,
  0,
  0,
  0,
  0,
  1,
  134890280,
  134890297,
  2,
  0,
  0,
  -1,
  0,
  0,
  0,
  0,
  1,
  134890325,
  134890348,
  2,
  0,
  0,
  -1,
  0,
  0,
  0,
  0,
  0,
  0,
  134890374,
  2,
  1,
  0,
  -1,
  0,
  0,
  0,
  0,
  1,
  134890398,
  134890712,
  2,
  0,
  0,
  -1,
  0,
  0,
  0,
  0,
  0,
  0,
  134890416,
  2,
  0,
  0,
  -1,
  0,
  0,
  0,
  0,
  0,
  0,
  134890440,
  0,
  0,
  0,
  3,
  0,
  0,
  0,
  0,
  0,
  134890459
}; // weak
int dyn_temp_10684[] = { 0 }; // weak
int dword_80CDD64 = 0; // weak
char (**dl_argv)[1671] = &program_invocation_short_name; // weak
_UNKNOWN _libc_stack_end; // weak
int _libc_enable_secure = 1; // weak
char *map_0 = "=INTERNAL->ucs4"; // weak
char *off_80CDDD0 = "=ucs4->INTERNAL"; // weak
int (*nl_category_postload)() = &nl_postload_ctype; // weak
int nl_current_used[16] = { 2, 2, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }; // weak
char **nl_C[6] =
{
  &nl_C_LC_CTYPE,
  &nl_C_LC_NUMERIC,
  &nl_C_LC_TIME,
  &nl_C_LC_COLLATE,
  &nl_C_LC_MONETARY,
  &nl_C_LC_MESSAGES
}; // weak
char **nl_C_locobj[6] =
{
  &nl_C_LC_CTYPE,
  &nl_C_LC_NUMERIC,
  &nl_C_LC_TIME,
  &nl_C_LC_COLLATE,
  &nl_C_LC_MONETARY,
  &nl_C_LC_MESSAGES
}; // weak
int (*off_80CDF7C)[256] = &dword_80A7040; // weak
int rtld_search_dirs = 0; // weak
int dword_80CDFB8 = 0; // weak
int max_capstrlen = 0; // weak
int ncapstr = 0; // weak
int capstr = 0; // weak
int env_path_list = 0; // weak
int dword_80CDFCC = 0; // weak
int _stack_prot = 16777216; // weak
_TBYTE GLOBAL_OFFSET_TABLE_ = 0.0; // weak
int dl_tls_static_size = 2048; // weak
char *nl_current_default_domain = "messages"; // weak
void *_exit_funcs = &initial; // weak
void *IO_list_all = &IO_2_1_stderr_; // weak
int dword_80CE084 = 0; // weak
int dword_80CE088 = 0; // weak
void *off_80CE094 = &IO_2_1_stdout_; // weak
int dword_80CE098 = 2; // weak
int dword_80CE09C = 0; // weak
int dword_80CE0A0 = -1; // weak
int dword_80CE0A4 = 0; // weak
void *off_80CE0A8 = &IO_stdfile_2_lock; // weak
int dword_80CE0AC = -1; // weak
int dword_80CE0B0 = -1; // weak
int dword_80CE0B4 = 0; // weak
char byte_80CE0B8[] = { '\0' }; // weak
char byte_80CE0B9[] = { '\xE1' }; // weak
char byte_80CE0BA[] = { '\f' }; // weak
char byte_80CE0BB[] = { '\b' }; // weak
int dword_80CE0BC = 0; // weak
int dword_80CE0CC[7] = { 0, 0, 0, 0, 0, 0, 0 }; // weak
int dword_80CE0E8 = 0; // weak
int dword_80CE0EC = 0; // weak
void *off_80CE0F4 = &IO_file_jumps; // weak
int dword_80CE150 = 0; // weak
int dword_80CE154 = 0; // weak
__int16 word_80CE15C = 0; // weak
__int16 word_80CE15E = 0; // weak
int dword_80CE160 = 0; // weak
int dword_80CE174 = 0; // weak
int dword_80CE17C = 0; // weak
int dword_80CE18C = 0; // weak
int dword_80CE190 = 0; // weak
char byte_80CE198[] = { '\0' }; // weak
char byte_80CE199[] = { '\0' }; // weak
char byte_80CE19A = '\0'; // weak
int dword_80CE1AC = 0; // weak
void *off_80CE1B0 = &IO_wfile_jumps; // weak
int dword_80CE1CC = 0; // weak
int dword_80CE1D0 = 0; // weak
void *off_80CE1F4 = &IO_2_1_stdin_; // weak
int dword_80CE1F8 = 1; // weak
int dword_80CE1FC = 0; // weak
char byte_80CE208[24] =
{
  'P',
  '\xF8',
  '\f',
  '\b',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\xFF',
  '\0',
  '\0',
  '\0',
  '\0',
  '`',
  '\xE2',
  '\f',
  '\b',
  '\0',
  '\0',
  '\0',
  '\0'
}; // weak
int dword_80CE220 = 0; // weak
int dword_80CE224 = 0; // weak
int dword_80CE228 = 0; // weak
int dword_80CE22C = 0; // weak
int dword_80CE230 = 0; // weak
int dword_80CE234 = 0; // weak
int dword_80CE238 = 0; // weak
int dword_80CE244 = 0; // weak
int dword_80CE248 = 0; // weak
int dword_80CE258 = 0; // weak
int dword_80CE25C = 0; // weak
int dword_80CE448 = 0; // weak
void *stderr = &IO_2_1_stderr_; // weak
void *stdout = &IO_2_1_stdout_; // weak
void *stdin = &IO_2_1_stdin_; // weak
int may_shrink_heap_11496 = -1; // weak
int _libc_malloc_initialized = -1; // weak
int narenas = 1; // weak
int mp_ = 131072; // weak
int dword_80CE4A4 = 131072; // weak
int dword_80CE4A8 = 131072; // weak
int dword_80CE4AC = 2; // weak
int dword_80CE4B0 = 0; // weak
int dword_80CE4B4 = 0; // weak
int dword_80CE4B8 = 65536; // weak
int dword_80CE4BC = 0; // weak
int dword_80CE4C0 = 0; // weak
int dword_80CE4C4 = 0; // weak
int dword_80CE4C8 = 0; // weak
int dword_80CE4CC = 0; // weak
int dword_80CE4D0 = 64; // weak
int dword_80CE4D4 = 1020; // weak
int dword_80CE4D8 = 7; // weak
int dword_80CE4DC = 0; // weak
int (__cdecl *_memalign_hook[2])(int, int) = { &memalign_hook_ini, &realloc_hook_ini }; // weak
int _realloc_hook = 134602176; // weak
int (__cdecl *_malloc_hook)(int) = &malloc_hook_ini; // weak
int main_arena = 0; // weak
int dword_80CE504 = 0; // weak
int dword_80CE508 = 0; // weak
int dword_80CE538 = 0; // weak
_UNKNOWN unk_80CE930; // weak
int *off_80CE948 = &main_arena; // weak
int dword_80CE954 = 0; // weak
int (__cdecl *_morecore)(int) = &_default_morecore; // weak
char (*program_invocation_short_name[2])[1671] = { &byte_80B41F9, &byte_80B41F9 }; // weak
char (*program_invocation_name)[1671] = &byte_80B41F9; // weak
int dl_stack_flags = 7; // weak
__int16 dl_fpu_control = 895; // weak
_UNKNOWN dl_correct_cache_id; // weak
_UNKNOWN dl_debug_fd; // weak
int dl_pagesize = 4096; // weak
_DWORD dl_starting_up = 1; // weak
_DWORD dl_load_adds[2] = { 1, 0 }; // weak
int dl_nns = 1; // weak
_UNKNOWN dl_use_load_bias; // weak
int (*dl_sysinfo)() = &dl_sysinfo_int80; // weak
int (__cdecl *dl_init_static_tls)(_DWORD) = &dl_nothread_init_static_tls; // weak
void **dl_initial_searchlist = &_compound_literal_3; // weak
void *dl_ns = &dl_main_map; // weak
_UNKNOWN dl_main_map; // weak
int dword_80CEBB4 = 0; // weak
__int16 word_80CEBBC = 0; // weak
int dword_80CEC0C = 0; // weak
int (__cdecl *dl_make_stack_executable_hook)(_DWORD) = &dl_make_stack_executable; // weak
int _libc_multiple_libcs = 1; // weak
char *builtin_modules[2] = { "INTERNAL", "ISO-10646/UCS4/" }; // weak
char **nl_global_locale[6] =
{
  &nl_C_LC_CTYPE,
  &nl_C_LC_NUMERIC,
  &nl_C_LC_TIME,
  &nl_C_LC_COLLATE,
  &nl_C_LC_MONETARY,
  &nl_C_LC_MESSAGES
}; // weak
char (*off_80CEE94)[512] = &byte_80A7940; // weak
int (*off_80CEE98[2])[256] = { &dword_80A6A40, &dword_80A7040 }; // weak
int (*off_80CEE9C)[256] = &dword_80A7040; // weak
char *off_80CEEA0[13] = { "C", "C", "C", "C", "C", "C", "C", "C", "C", "C", "C", "C", "C" }; // weak
char *off_80CEEB8[7] = { "C", "C", "C", "C", "C", "C", "C" }; // weak
__int16 _fpu_control[2] = { 895, 0 }; // weak
int pa_next_type = 8; // weak
int _x86_raw_shared_cache_size = 1048576; // weak
int _x86_raw_shared_cache_size_half = 524288; // weak
int _x86_shared_cache_size = 1048576; // weak
int _x86_shared_cache_size_half = 524288; // weak
int _x86_raw_data_cache_size = 32768; // weak
int _x86_raw_data_cache_size_half = 16384; // weak
int _x86_data_cache_size = 32768; // weak
int _x86_data_cache_size_half = 16384; // weak
int (__cdecl *dl_open_hook[2])(int, int) = { &_libc_dlopen_mode, &_libc_dlsym }; // weak
int (__cdecl *dlfcn_hooks)(int, int, int) = &_dlopen; // weak
int _start___libc_IO_vtables[24] =
{
  0,
  0,
  134568112,
  134555744,
  134554848,
  134759232,
  134758688,
  134556848,
  134564112,
  134552208,
  134573216,
  134559024,
  134556464,
  134755584,
  134565200,
  134563680,
  134560976,
  134558912,
  134563648,
  134577376,
  134577392,
  0,
  0,
  0
}; // weak
_UNKNOWN IO_wfile_jumps_mmap; // weak
_UNKNOWN IO_wfile_jumps; // weak
_UNKNOWN IO_file_jumps_maybe_mmap; // weak
_UNKNOWN IO_file_jumps_mmap; // weak
_UNKNOWN IO_file_jumps; // weak
_UNKNOWN IO_str_jumps; // weak
_UNKNOWN IO_helper_jumps; // weak
_UNKNOWN IO_helper_jumps_0; // weak
int (*_start___libc_atexit)() = &IO_cleanup; // weak
_UNKNOWN edata; // weak
_UNKNOWN nl_state_lock; // weak
int output_charset_cache_11629; // weak
int output_charset_cached_11630; // weak
int freemem_size_11587; // weak
int freemem_11586; // weak
int transmem_list; // weak
int root; // weak
_UNKNOWN tree_lock; // weak
int nl_loaded_domains; // weak
int lock_10701; // weak
int dword_80CF5C8; // weak
int dword_80CF5CC; // weak
int locale_alias_path_10080; // weak
int maxmap; // weak
int nmap; // weak
int _abort_msg; // weak
int lock; // weak
int dword_80CF5F0; // weak
int dword_80CF5F4; // weak
int stage; // weak
int phys_pages_8655; // weak
int pagesize_8656; // weak
char _exit_funcs_done; // weak
int freeres_list; // weak
char dealloc_buffers; // weak
int stdio_needs_locking; // weak
int run_fp; // weak
int list_all_lock; // weak
int dword_80CF83C; // weak
int dword_80CF840; // weak
int _after_morecore_hook; // weak
int _free_hook; // weak
int next_to_use_12583; // weak
int narenas_limit_12605; // weak
int using_malloc_checking; // weak
int aligned_heap_area; // weak
int list_lock; // weak
int free_list; // weak
int free_list_lock; // weak
int perturb_byte; // weak
int global_max_fast; // weak
_UNKNOWN state; // weak
_DWORD *environ; // weak
int timestamp_11438; // weak
int dl_hwcap; // weak
_DWORD dl_x86_cpu_features[22]; // weak
int once_0; // weak
int known_derivations; // weak
int lock_12667; // weak
int cache_malloced; // weak
int cache_size; // weak
int gconv_cache; // weak
int release_handle; // weak
int loaded; // weak
_UNKNOWN _libc_setlocale_lock; // weak
int archloaded; // weak
int headmap; // weak
int dword_80CFA08; // weak
int dword_80CFA0C; // weak
int archmapped; // weak
int last_environ; // weak
int known_values; // weak
int envlock; // weak
int lock_1; // weak
int next_bit; // weak
int lock_2; // weak
int lock_3; // weak
_UNKNOWN state_0; // weak
_UNKNOWN state_1; // weak
int _curbrk; // weak
int max_dirnamelen; // weak
int log_hashfraction; // weak
int textsize; // weak
int lowpc; // weak
int fromidx; // weak
int fromlimit; // weak
int froms; // weak
int tos; // weak
int narcsp; // weak
int narcs; // weak
int running; // weak
int data; // weak
int cachesize; // weak
int cache_new; // weak
int cache; // weak
int once; // weak
int static_buf; // weak
_UNKNOWN last_result; // weak
const char *dword_80CFA9C; // weak
int oact_8609[35]; // weak
struct itimerval otimer_8610; // weak
int pc_scale; // weak
int pc_offset; // weak
int nsamples; // weak
int samples; // weak
int dl_close_state_11755; // weak
char dwarf_reg_size_table[]; // weak
char byte_80CFB55; // weak
char byte_80CFB56; // weak
char byte_80CFB57; // weak
char byte_80CFB58; // weak
char byte_80CFB59; // weak
char byte_80CFB5A; // weak
char byte_80CFB5B; // weak
char byte_80CFB5C; // weak
char byte_80CFB5D; // weak
char byte_80CFB5F; // weak
char byte_80CFB60; // weak
char byte_80CFB61; // weak
char byte_80CFB62; // weak
char byte_80CFB63; // weak
char byte_80CFB64; // weak
int any_objects_registered; // weak
int seen_objects; // weak
int unseen_objects; // weak
_UNKNOWN dl_tls_static_used; // weak
_UNKNOWN dl_tls_static_align; // weak
_UNKNOWN dl_tls_max_dtv_idx; // weak
_DWORD dl_static_dtv[128]; // weak
_DWORD *dl_tls_dtv_slotinfo_list; // weak
_UNKNOWN dl_tls_dtv_gaps; // weak
_UNKNOWN dl_tls_generation; // weak
_UNKNOWN dl_tls_static_nelem; // weak
int nl_domain_bindings; // weak
_UNKNOWN nl_msg_cat_cntr; // weak
struct timespec _exit_funcs_lock; // weak
__int64 _new_exitfn_called; // weak
_DWORD r_debug[5]; // weak
unsigned int *dl_profile_output; // weak
_UNKNOWN dl_platformlen; // weak
_BYTE dl_debug_mask[4]; // weak
int (*dl_wait_lookup_done)(void); // weak
char *dl_profile; // weak
_UNKNOWN dl_bind_not; // weak
_UNKNOWN dl_auxv; // weak
char *dl_platform; // weak
_DWORD dl_x86_feature_1[2]; // weak
_UNKNOWN dl_lazy; // weak
_UNKNOWN dl_sysinfo_map; // weak
_UNKNOWN dl_inhibit_cache; // weak
_DWORD *dl_phdr; // weak
_DWORD *dl_scope_free_list; // weak
unsigned int *dl_origin_path; // weak
_UNKNOWN dl_clktck; // weak
_UNKNOWN dl_dynamic_weak; // weak
int dl_sysinfo_dso; // weak
int dl_init_all_dirs; // weak
_UNKNOWN dl_verbose; // weak
__int16 dl_phnum; // weak
_UNKNOWN dl_profile_map; // weak
int dl_initfirst; // weak
_UNKNOWN dl_all_dirs; // weak
_UNKNOWN dl_osversion; // weak
_BYTE *dl_inhibit_rpath; // weak
_UNKNOWN dl_x86_legacy_bitmap; // weak
_UNKNOWN _libc_enable_secure_decided; // weak
int _libc_argc; // weak
int _libc_argv; // weak
int _gconv_modules_db; // weak
int _gconv_lock; // weak
int _gconv_alias_db; // weak
int _gconv_path_envvar; // weak
int _gconv_max_path_elem_len; // weak
int _gconv_path_elem; // weak
int nl_locale_file_list[13]; // weak
int _printf_function_table; // weak
int _printf_modifier_table; // weak
int _x86_shared_non_temporal_threshold; // weak
int map; // weak
int _printf_arginfo_table; // weak
int _printf_va_arg_table; // weak
int buf; // weak


//----- (08049030) --------------------------------------------------------
void __usercall __noreturn _assert_fail_base_cold_0(
        int a1@<ebp>,
        int *a2@<edi>,
        const struct timespec *a3@<esi>,
        int a4,
        int a5,
        int a6,
        int a7,
        int a8)
{
  free(a1, a2, a8);
  abort(a1, a2, a3);
}

//----- (08049049) --------------------------------------------------------
void __usercall __noreturn abort(int a1@<ebp>, int *a2@<edi>, const struct timespec *a3@<esi>)
{
  unsigned int v4; // edx
  bool v6; // zf
  int i; // eax
  unsigned int v8; // edx
  bool v10; // zf
  int j; // eax
  int v12[32]; // [esp+0h] [ebp-11Ch] BYREF
  int v13[39]; // [esp+80h] [ebp-9Ch] BYREF

  _EBX = &GLOBAL_OFFSET_TABLE_;
  v4 = __readgsdword(8u);
  v13[35] = __readgsdword(0x14u);
  if ( dword_80CF5F4 != v4 )
  {
    _ECX = 1;
    v6 = __readgsdword(0xCu) == 0;
    if ( !v6 )
      __asm { lock }
    __asm { cmpxchg ds:(lock - 80CE000h)[ebx], ecx }
    if ( !v6 )
      _lll_lock_wait_private(0, &lock, a1, a2);
    dword_80CF5F4 = v4;
  }
  ++dword_80CF5F0;
  if ( !stage )
  {
    stage = 1;
    for ( i = 32; --i != -1; v12[i] = 0 )
      ;
    v12[0] |= 0x20u;
    sigprocmask(1, v12, 0);
  }
  if ( stage == 1 )
  {
    v6 = dword_80CF5F0-- == 1;
    stage = 0;
    if ( v6 )
    {
      dword_80CF5F4 = 0;
      if ( __readgsdword(0xCu) )
        __asm { lock }
      if ( --lock )
        _lll_unlock_wake_private(&lock, a1, a2, a3);
    }
    raise(6);
    v8 = __readgsdword(8u);
    if ( dword_80CF5F4 != v8 )
    {
      _ECX = 1;
      v10 = __readgsdword(0xCu) == 0;
      if ( !v10 )
        __asm { lock }
      __asm { cmpxchg ds:(lock - 80CE000h)[ebx], ecx }
      if ( !v10 )
        _lll_lock_wait_private(0, &lock, a1, a2);
      dword_80CF5F4 = v8;
    }
    ++dword_80CF5F0;
  }
  else if ( stage != 2 )
  {
    goto LABEL_30;
  }
  stage = 3;
  memset(v13, 0, 0x8Cu);
  for ( j = 33; --j; v13[j] = -1 )
    ;
  v13[33] = 0;
  sigaction(6, v13, 0);
LABEL_30:
  if ( stage == 3 )
  {
    stage = 4;
    raise(6);
  }
  if ( stage == 4 )
  {
    stage = 5;
    __halt();
  }
  if ( stage == 5 )
  {
    stage = 6;
    exit(127);
  }
  __halt();
}
// 80490A2: variable 'v4' is possibly undefined
// 8049175: variable 'v8' is possibly undefined
// 80CE000: using guessed type _TBYTE GLOBAL_OFFSET_TABLE_;
// 80CF5EC: using guessed type int lock;
// 80CF5F0: using guessed type int dword_80CF5F0;
// 80CF5F4: using guessed type int dword_80CF5F4;
// 80CF5F8: using guessed type int stage;
// 8049049: using guessed type int var_11C[32];

//----- (08049222) --------------------------------------------------------
void __usercall __noreturn IO_new_fclose_cold_0(
        int a1@<eax>,
        int *tv_sec@<edx>,
        struct timespec *a3@<ecx>,
        int a4@<ebp>,
        int *a5@<edi>,
        const struct timespec *a6@<esi>)
{
  bool v6; // zf

  if ( (a6->tv_sec & 0x8000) == 0 )
  {
    tv_sec = (int *)a6[9].tv_sec;
    v6 = tv_sec[1]-- == 1;
    if ( v6 )
    {
      tv_sec[2] = 0;
      if ( __readgsdword(0xCu) )
        __asm { lock }
      v6 = (*tv_sec)-- == 1;
      if ( !v6 )
        a1 = _lll_unlock_wake_private(tv_sec, a4, a5, a6);
    }
  }
  Unwind_Resume(a1, (int)tv_sec, a3);
}
// 8049257: variable 'tv_sec' is possibly undefined
// 8049257: variable 'a3' is possibly undefined

//----- (0804925C) --------------------------------------------------------
void __usercall __noreturn IO_fflush_cold_0(
        int a1@<eax>,
        int *tv_sec@<edx>,
        struct timespec *a3@<ecx>,
        int a4@<ebp>,
        int *a5@<edi>,
        const struct timespec *a6@<esi>)
{
  bool v6; // zf

  if ( (a6->tv_sec & 0x8000) == 0 )
  {
    tv_sec = (int *)a6[9].tv_sec;
    v6 = tv_sec[1]-- == 1;
    if ( v6 )
    {
      tv_sec[2] = 0;
      if ( __readgsdword(0xCu) )
        __asm { lock }
      v6 = (*tv_sec)-- == 1;
      if ( !v6 )
        a1 = _lll_unlock_wake_private(tv_sec, a4, a5, a6);
    }
  }
  Unwind_Resume(a1, (int)tv_sec, a3);
}
// 8049291: variable 'tv_sec' is possibly undefined
// 8049291: variable 'a3' is possibly undefined

//----- (08049296) --------------------------------------------------------
void __usercall __noreturn IO_puts_cold_0(
        int a1@<eax>,
        int *tv_sec@<edx>,
        struct timespec *a3@<ecx>,
        int a4@<ebp>,
        int *a5@<edi>,
        const struct timespec *a6@<esi>)
{
  bool v6; // zf

  if ( (a6->tv_sec & 0x8000) == 0 )
  {
    tv_sec = (int *)a6[9].tv_sec;
    v6 = tv_sec[1]-- == 1;
    if ( v6 )
    {
      tv_sec[2] = 0;
      if ( __readgsdword(0xCu) )
        __asm { lock }
      v6 = (*tv_sec)-- == 1;
      if ( !v6 )
        a1 = _lll_unlock_wake_private(tv_sec, a4, a5, a6);
    }
  }
  Unwind_Resume(a1, (int)tv_sec, a3);
}
// 80492CB: variable 'tv_sec' is possibly undefined
// 80492CB: variable 'a3' is possibly undefined

//----- (080492D0) --------------------------------------------------------
void __usercall __noreturn IO_wfile_underflow_cold_2(
        int a1@<eax>,
        int *tv_sec@<edx>,
        struct timespec *a3@<ecx>,
        int a4@<ebp>,
        int *a5@<edi>,
        const struct timespec *a6@<esi>)
{
  bool v6; // zf

  if ( (a6->tv_sec & 0x8000) == 0 )
  {
    tv_sec = (int *)a6[9].tv_sec;
    v6 = tv_sec[1]-- == 1;
    if ( v6 )
    {
      tv_sec[2] = 0;
      if ( __readgsdword(0xCu) )
        __asm { lock }
      v6 = (*tv_sec)-- == 1;
      if ( !v6 )
        a1 = _lll_unlock_wake_private(tv_sec, a4, a5, a6);
    }
  }
  Unwind_Resume(a1, (int)tv_sec, a3);
}
// 8049306: variable 'tv_sec' is possibly undefined
// 8049306: variable 'a3' is possibly undefined

//----- (0804930B) --------------------------------------------------------
void __usercall __noreturn IO_new_file_underflow_cold_6(
        int *a1@<edx>,
        struct timespec *a2@<ecx>,
        int a3@<ebp>,
        int *a4@<edi>,
        const struct timespec *a5@<esi>)
{
  int v5; // eax
  int v6; // ebx
  bool v7; // zf

  v5 = *(_DWORD *)(a3 - 36);
  v6 = *(_DWORD *)v5;
  *(_DWORD *)(a3 - 28) = *(_DWORD *)v5;
  if ( (v6 & 0x8000) == 0 )
  {
    a1 = *(int **)(v5 + 72);
    v7 = a1[1]-- == 1;
    if ( v7 )
    {
      a1[2] = 0;
      if ( __readgsdword(0xCu) )
        __asm { lock }
      v7 = (*a1)-- == 1;
      if ( !v7 )
        v5 = _lll_unlock_wake_private(a1, a3, a4, a5);
    }
  }
  Unwind_Resume(v5, (int)a1, a2);
}
// 8049345: variable 'a1' is possibly undefined
// 8049345: variable 'a2' is possibly undefined

//----- (0804934A) --------------------------------------------------------
void __usercall __noreturn dl_start(int a1@<ebp>, int *a2@<edi>)
{
  const struct timespec *v2; // [esp+0h] [ebp-4h]

  abort(a1, a2, v2);
}
// 8049353: variable 'v2' is possibly undefined

//----- (08049392) --------------------------------------------------------
void __usercall __noreturn IO_fwrite_cold_0(
        int a1@<eax>,
        int *tv_sec@<edx>,
        struct timespec *a3@<ecx>,
        int a4@<ebp>,
        int *a5@<edi>,
        const struct timespec *a6@<esi>)
{
  bool v6; // zf

  if ( (a6->tv_sec & 0x8000) == 0 )
  {
    tv_sec = (int *)a6[9].tv_sec;
    v6 = tv_sec[1]-- == 1;
    if ( v6 )
    {
      tv_sec[2] = 0;
      if ( __readgsdword(0xCu) )
        __asm { lock }
      v6 = (*tv_sec)-- == 1;
      if ( !v6 )
        a1 = _lll_unlock_wake_private(tv_sec, a4, a5, a6);
    }
  }
  Unwind_Resume(a1, (int)tv_sec, a3);
}
// 80493C7: variable 'tv_sec' is possibly undefined
// 80493C7: variable 'a3' is possibly undefined

//----- (080493CC) --------------------------------------------------------
void __usercall __noreturn IO_getdelim_cold_0(
        int a1@<eax>,
        int *a2@<edx>,
        struct timespec *a3@<ecx>,
        int a4@<ebp>,
        int *a5@<edi>,
        const struct timespec *a6@<esi>)
{
  bool v6; // zf

  if ( (*a5 & 0x8000) == 0 )
  {
    a2 = (int *)a5[18];
    v6 = a2[1]-- == 1;
    if ( v6 )
    {
      a2[2] = 0;
      if ( __readgsdword(0xCu) )
        __asm { lock }
      v6 = (*a2)-- == 1;
      if ( !v6 )
        a1 = _lll_unlock_wake_private(a2, a4, a5, a6);
    }
  }
  Unwind_Resume(a1, (int)a2, a3);
}
// 8049402: variable 'a2' is possibly undefined
// 8049402: variable 'a3' is possibly undefined

//----- (0804940C) --------------------------------------------------------
void __usercall __noreturn execute_cfa_program_cold_7(int a1@<ebp>, int *a2@<edi>, const struct timespec *a3@<esi>)
{
  abort(a1, a2, a3);
}

//----- (0804941D) --------------------------------------------------------
void __usercall __noreturn uw_update_context_1_cold_9(
        int a1@<ebp>,
        int *a2@<edi>,
        const struct timespec *a3@<esi>,
        int a4)
{
  abort(a1, a2, a3);
}

//----- (08049430) --------------------------------------------------------
void __usercall __noreturn Unwind_RaiseException_Phase2_cold_12(
        int a1@<ebp>,
        int *a2@<edi>,
        const struct timespec *a3@<esi>,
        int a4,
        int a5,
        int a6)
{
  abort(a1, a2, a3);
}

//----- (08049439) --------------------------------------------------------
void __usercall __noreturn uw_install_context_1_cold_13(
        int a1@<ebp>,
        int *a2@<edi>,
        const struct timespec *a3@<esi>,
        int a4,
        int a5,
        int a6)
{
  abort(a1, a2, a3);
}

//----- (08049447) --------------------------------------------------------
void __usercall __noreturn Unwind_SetGR_cold_15(int a1@<ebp>, int *a2@<edi>, const struct timespec *a3@<esi>)
{
  abort(a1, a2, a3);
}

//----- (0804944E) --------------------------------------------------------
void __usercall __noreturn Unwind_Resume_cold_16(int a1@<ebp>, int *a2@<edi>, const struct timespec *a3@<esi>)
{
  abort(a1, a2, a3);
}

//----- (08049459) --------------------------------------------------------
void __usercall __noreturn Unwind_Resume_or_Rethrow_cold_17(
        int a1@<ebp>,
        int *a2@<edi>,
        const struct timespec *a3@<esi>)
{
  abort(a1, a2, a3);
}

//----- (08049470) --------------------------------------------------------
const char **__usercall fini@<eax>(int a1@<ebp>)
{
  return check_free_isra_0(&dword_80CFA9C, a1);
}
// 80CFA9C: using guessed type const char *dword_80CFA9C;

//----- (08049490) --------------------------------------------------------
int __cdecl main(int argc, const char **argv, const char **envp)
{
  int v3; // esi

  puts((unsigned int *)"Hello World");
  printf(argc, v3, (unsigned int *)"argc=%d\n", argc);
  return 0;
}
// 80494B6: variable 'v3' is possibly undefined

//----- (080494D0) --------------------------------------------------------
char init_cacheinfo()
{
  int v0; // eax
  unsigned int v1; // ecx
  int v2; // esi
  int v3; // eax
  unsigned int v4; // ebx
  int v5; // ecx
  int v6; // esi
  int v12; // ecx
  unsigned int v23; // ebx
  _BOOL4 v29; // eax
  int v30; // ecx
  int v31; // esi
  int v37; // ecx
  unsigned int v38; // ecx
  int v39; // ebx
  unsigned int v40; // ecx
  unsigned int v41; // eax
  unsigned int v42; // ecx
  int v44; // [esp+0h] [ebp-40h]
  int v45; // [esp+4h] [ebp-3Ch]
  int v46; // [esp+4h] [ebp-3Ch]
  int v47; // [esp+4h] [ebp-3Ch]
  int v48; // [esp+8h] [ebp-38h]
  int v49; // [esp+Ch] [ebp-34h]
  int v50; // [esp+10h] [ebp-30h]
  int v51; // [esp+14h] [ebp-2Ch]
  bool v52; // [esp+1Bh] [ebp-25h]
  int v53; // [esp+1Ch] [ebp-24h]
  int v54; // [esp+20h] [ebp-20h]

  if ( dl_x86_cpu_features[0] == 1 )
  {
    v51 = dl_x86_cpu_features[1];
    v44 = handle_intel_constprop_1(188);
    v48 = handle_intel_constprop_1(191);
    v2 = handle_intel_constprop_1(194);
    if ( v2 <= 0 )
    {
      v2 = v48;
      v49 = -1;
      v53 = 2;
    }
    else
    {
      v49 = 0;
      v53 = 3;
    }
    v1 = dl_x86_cpu_features[5] & 0x10000000;
    if ( !v1 )
      goto LABEL_41;
    if ( v51 <= 3 )
    {
      v50 = 0;
      v52 = 1;
LABEL_33:
      v1 = BYTE2(dl_x86_cpu_features[3]);
_L194:
      if ( v2 > 0 && v1 )
        v2 /= v1;
      goto LABEL_37;
    }
    if ( v49 )
    {
      v45 = 1;
      v49 = -1;
    }
    else
    {
      v45 = 3;
    }
    v50 = 0;
    v5 = 0;
    v52 = 1;
    v54 = v2;
    while ( 1 )
    {
      v6 = v5 + 1;
      _EAX = 4;
      __asm { cpuid }
      if ( (_EAX & 0x1F) == 0 )
      {
        v2 = v54;
        goto LABEL_33;
      }
      v12 = (unsigned __int8)_EAX >> 5;
      if ( v12 == 2 )
      {
        if ( (v45 & 1) == 0 )
          goto LABEL_30;
        v45 &= ~1u;
        v50 = (_EAX >> 14) & 0x3FF;
      }
      else if ( v12 == 3 )
      {
        if ( (v45 & 2) == 0 )
          goto LABEL_30;
        v45 &= ~2u;
        v49 = (_EAX >> 14) & 0x3FF;
        v52 = (_EDX & 2) != 0;
      }
      if ( !v45 )
      {
        v2 = v54;
        if ( v51 > 10 )
        {
          v29 = 1;
          if ( v49 <= 0 )
            v29 = v50 > 0 && v53 == 2;
          v30 = 0;
          v31 = (v50 > 0 && v53 == 3) | (2 * v29);
          while ( v31 )
          {
            v47 = v30 + 1;
            _EAX = 11;
            __asm { cpuid }
            v37 = _ECX & 0xFF00;
            if ( !(_BYTE)_EBX || !v37 )
              break;
            if ( v37 == 256 )
            {
              if ( (v31 & 1) != 0 )
              {
                _BitScanReverse(&v38, v50);
                v31 &= ~1u;
                v50 = ~(-1 << (v38 + 1)) & ((unsigned __int8)_EBX - 1);
              }
            }
            else if ( v37 == 512 && (v31 & 2) != 0 )
            {
              v39 = (unsigned __int8)_EBX - 1;
              if ( v53 == 2 )
              {
                _BitScanReverse(&v42, v50);
                v50 = v39 & ~(-1 << (v42 + 1));
              }
              else
              {
                _BitScanReverse(&v40, v49);
                v49 = v39 & ~(-1 << (v40 + 1));
              }
              v31 &= ~2u;
            }
            v30 = v47;
          }
          v2 = v54;
        }
        v50 -= (v50 == 0) - 1;
        if ( v49 > 0 )
        {
          if ( v53 != 2 )
          {
            v1 = v49 + 1;
            goto _L194;
          }
LABEL_77:
          if ( v50 )
          {
            v1 = v50;
            if ( (unsigned int)v50 > 2 && dl_x86_cpu_features[14] == 6 )
            {
              v41 = dl_x86_cpu_features[15] - 55;
              if ( v41 <= 0x26 )
                __asm { jmp     ebx }
            }
            goto _L194;
          }
          v1 = 0;
          if ( v52 )
          {
LABEL_41:
            v0 = dl_x86_cpu_features[19];
            if ( v0 )
LABEL_5:
              v44 = v0;
            if ( v44 > 0 )
            {
              _x86_raw_data_cache_size = v44;
              _x86_raw_data_cache_size_half = v44 >> 1;
              v3 = v44;
              LOBYTE(v3) = 0;
              _x86_data_cache_size = v3;
              _x86_data_cache_size_half = v3 >> 1;
            }
            v0 = dl_x86_cpu_features[20];
            if ( !v0 )
            {
LABEL_9:
              if ( v2 > 0 )
              {
                _x86_raw_shared_cache_size = v2;
                _x86_raw_shared_cache_size_half = v2 >> 1;
                v0 = v2;
                LOBYTE(v0) = 0;
                _x86_shared_cache_size = v0;
                _x86_shared_cache_size_half = v0 >> 1;
              }
              goto LABEL_11;
            }
LABEL_16:
            v2 = v0;
            goto LABEL_9;
          }
LABEL_40:
          v2 += v48;
          goto LABEL_41;
        }
        if ( v53 == 2 )
          goto LABEL_77;
        v1 = 0;
        if ( v49 )
        {
          v1 = -1;
          goto _L194;
        }
LABEL_37:
        if ( v52 )
          goto LABEL_41;
        if ( v50 )
          v48 /= v50;
        goto LABEL_40;
      }
LABEL_30:
      v5 = v6;
    }
  }
  if ( dl_x86_cpu_features[0] == 2 )
  {
    v44 = handle_amd(188);
    v2 = handle_amd(191);
    v46 = handle_amd(194);
    _EAX = 0x80000000;
    __asm { cpuid }
    v1 = 0;
    if ( v46 <= 0 )
      goto LABEL_41;
    if ( _EAX > 0x80000007 )
    {
      _EAX = -2147483640;
      __asm { cpuid }
      v1 = 1 << ((_ECX >> 12) & 0xF);
    }
    else
    {
      _EAX = 1;
      __asm { cpuid }
      v1 = _EDX & 0x10000000;
      if ( (_EDX & 0x10000000) == 0 )
        goto LABEL_47;
      v23 = HIWORD(_EBX);
      v1 = (unsigned __int8)v23;
      if ( !(_BYTE)v23 )
        goto LABEL_47;
    }
    v46 /= v1;
LABEL_47:
    v2 += v46;
    goto LABEL_41;
  }
  v0 = dl_x86_cpu_features[19];
  if ( v0 )
  {
    v1 = 0;
    v2 = -1;
    goto LABEL_5;
  }
  v1 = dl_x86_cpu_features[20];
  if ( v1 )
  {
    v0 = dl_x86_cpu_features[20];
    v1 = 0;
    goto LABEL_16;
  }
LABEL_11:
  v4 = dl_x86_cpu_features[21];
  if ( !v4 )
    v4 = (3 * _x86_shared_cache_size * v1) >> 2;
  _x86_shared_non_temporal_threshold = v4;
  return v0;
}
// 80CEEDC: using guessed type int _x86_raw_shared_cache_size;
// 80CEEE0: using guessed type int _x86_raw_shared_cache_size_half;
// 80CEEE4: using guessed type int _x86_shared_cache_size;
// 80CEEE8: using guessed type int _x86_shared_cache_size_half;
// 80CEEEC: using guessed type int _x86_raw_data_cache_size;
// 80CEEF0: using guessed type int _x86_raw_data_cache_size_half;
// 80CEEF4: using guessed type int _x86_data_cache_size;
// 80CEEF8: using guessed type int _x86_data_cache_size_half;
// 80CF8E0: using guessed type _DWORD dl_x86_cpu_features[22];
// 80CFFDC: using guessed type int _x86_shared_non_temporal_threshold;

//----- (08049997) --------------------------------------------------------
void sub_8049997()
{
  ;
}

//----- (08049AE0) --------------------------------------------------------
__int16 __usercall get_common_indeces_constprop_1@<ax>(
        unsigned int _EAX@<eax>,
        int *a2@<edx>,
        unsigned int *a3@<ecx>,
        unsigned int *a4)
{
  _DWORD *v4; // esi
  int v14; // ebx
  unsigned int v20; // ebx
  int *v24; // ebp
  unsigned int v25; // esi
  unsigned int v31; // eax
  int v32; // eax
  int v33; // edx
  int v34; // edx
  unsigned int v35; // ecx
  int v38; // [esp+8h] [ebp-10Ch]
  int v39; // [esp+Ch] [ebp-108h] BYREF
  int v40; // [esp+80h] [ebp-94h]
  int v41[31]; // [esp+84h] [ebp-90h] BYREF
  int v42; // [esp+100h] [ebp-14h]

  if ( _EAX )
  {
    v4 = (_DWORD *)_EAX;
    _EAX = 1;
    __asm { cpuid }
    dl_x86_cpu_features[5] = _EDX;
    dl_x86_cpu_features[3] = _EBX;
    dl_x86_cpu_features[4] = _ECX;
    dl_x86_cpu_features[2] = _EAX;
    *v4 = (_EAX >> 8) & 0xF;
    *a2 = (unsigned __int8)_EAX >> 4;
    *a3 = (_EAX >> 12) & 0xF0;
    *a4 = _EAX & 0xF;
    if ( *v4 == 15 )
    {
      *v4 = (unsigned __int8)(_EAX >> 20) + 15;
      _EAX = *a3;
      *a2 += *a3;
    }
  }
  if ( (int)dl_x86_cpu_features[1] > 6 )
  {
    _EAX = 7;
    __asm { cpuid }
    dl_x86_cpu_features[6] = _EAX;
    dl_x86_cpu_features[7] = _EBX;
    dl_x86_cpu_features[8] = _ECX;
    dl_x86_cpu_features[9] = _EDX;
  }
  v14 = dl_x86_cpu_features[4];
  if ( (v14 & 0x8000000) != 0 )
  {
    __asm { xgetbv }
    if ( (_EAX & 6) == 6 )
    {
      if ( (v14 & 0x10000000) != 0 )
      {
        v33 = dl_x86_cpu_features[18];
        dl_x86_cpu_features[18] = v33 | 0x40;
        if ( (dl_x86_cpu_features[7] & 0x20) != 0 )
          dl_x86_cpu_features[18] = v33 | 0xC40;
        if ( (v14 & 0x1000) != 0 )
          dl_x86_cpu_features[18] |= 0x80u;
      }
      _EAX &= 0xE0u;
      if ( _EAX == 224 )
      {
        v34 = dl_x86_cpu_features[7];
        if ( (v34 & 0x10000) != 0 )
        {
          _EAX = dl_x86_cpu_features[18];
          v35 = _EAX;
          BYTE1(_EAX) |= 0x10u;
          BYTE1(v35) |= 0x30u;
          if ( (v34 & 0x20000) != 0 )
            _EAX = v35;
          dl_x86_cpu_features[18] = _EAX;
        }
      }
    }
    if ( (int)dl_x86_cpu_features[1] > 12 )
    {
      _EAX = 13;
      __asm { cpuid }
      if ( _EBX )
      {
        _EAX = 13;
        v20 = (_EBX + 127) & 0xFFFFFFC0;
        dl_x86_cpu_features[16] = v20;
        dl_x86_cpu_features[17] = v20;
        __asm { cpuid }
        if ( (_EAX & 2) != 0 )
        {
          v24 = &v39;
          v25 = 2;
          v38 = 160;
          v39 = 576;
          v41[0] = 160;
          v41[1] = 256;
          while ( 1 )
          {
            v32 = 238;
            if ( _bittest(&v32, v25) )
            {
              _EAX = 13;
              __asm { cpuid }
              v41[v25] = _EAX;
              if ( v25 == 2 )
                goto LABEL_17;
              v31 = *(v24 - 1) + v41[v25 - 1];
              if ( (_ECX & 2) != 0 )
                v31 = (v31 + 63) & 0xFFFFFFC0;
              *v24 = v31;
            }
            else
            {
              v41[v25] = 0;
              if ( v25 == 2 )
                goto LABEL_17;
              *v24 = *(v24 - 1) + v41[v25 - 1];
            }
            if ( v25 == 31 )
            {
              _EAX = v40 + v42;
              if ( v40 + v42 )
              {
                dl_x86_cpu_features[18] |= 0x400000u;
                _EAX = (_EAX + 127) & 0xFFFFFFC0;
                dl_x86_cpu_features[16] = _EAX;
              }
              return _EAX;
            }
LABEL_17:
            ++v25;
            ++v24;
          }
        }
      }
    }
  }
  return _EAX;
}
// 80CF8E0: using guessed type _DWORD dl_x86_cpu_features[22];

//----- (0804A4D0) --------------------------------------------------------
void *_x86_get_pc_thunk_ax()
{
  void *retaddr; // [esp+0h] [ebp+0h]

  return retaddr;
}

//----- (0804A4D4) --------------------------------------------------------
void _x86_get_pc_thunk_di()
{
  ;
}

//----- (0804A4E0) --------------------------------------------------------
int __usercall check_one_fd@<eax>(int a1@<eax>, int a2@<edx>)
{
  int result; // eax
  int v5; // edi
  const char *v6; // eax
  struct stat v7; // [esp+0h] [ebp-7Ch] BYREF

  result = _fcntl64_nocancel(a1, 1);
  if ( result == -1 )
  {
    result = -32;
    if ( __readgsdword(0xFFFFFFE0) == 9 )
    {
      if ( a2 == 0x20000 )
      {
        v5 = 259;
        v6 = "/dev/null";
      }
      else
      {
        v5 = 263;
        v6 = "/dev/full";
      }
      if ( a1 != _open_nocancel((int)v6)
        || _fxstat64(3, a1, &v7)
        || (result = v7.st_mode & 0xF000, result != 0x2000)
        || v7.st_rdev != v5 )
      {
        __halt();
      }
    }
  }
  return result;
}

//----- (0804A590) --------------------------------------------------------
int _libc_check_standard_fds()
{
  check_one_fd(0, 131073);
  check_one_fd(1, 0x20000);
  return check_one_fd(2, 0x20000);
}

//----- (0804A5C4) --------------------------------------------------------
void _x86_get_pc_thunk_si()
{
  ;
}

//----- (0804A5D0) --------------------------------------------------------
void _libc_setup_tls()
{
  _DWORD *v0; // esi
  _DWORD *v1; // edx
  unsigned int v2; // edx
  unsigned int v3; // ebp
  int v4; // ebx
  unsigned int v5; // eax
  unsigned int v6; // edx
  _BYTE *v7; // eax
  _DWORD *v8; // eax
  unsigned int v9; // eax
  unsigned int v10; // [esp+0h] [ebp-4Ch]
  unsigned int v11; // [esp+4h] [ebp-48h]
  unsigned int v12; // [esp+8h] [ebp-44h]
  _DWORD *v13; // [esp+Ch] [ebp-40h]
  unsigned int v14; // [esp+10h] [ebp-3Ch]

  v13 = dl_ns;
  v0 = dl_phdr;
  if ( dl_phdr )
  {
    v1 = &dl_phdr[8 * *(_DWORD *)&dl_phnum];
    if ( dl_phdr < v1 )
    {
      while ( *v0 != 7 )
      {
        v0 += 8;
        if ( v1 <= v0 )
          goto LABEL_11;
      }
      v2 = v0[5];
      v3 = v0[7];
      v14 = v0[4];
      v12 = v2;
      v4 = *(_DWORD *)dl_ns + v0[2];
      v0 = (_DWORD *)v4;
      if ( v3 > 0x40 )
      {
        v11 = v3 * ((v3 + v2 + dl_tls_static_size - 1) / v3);
        v9 = sbrk(v11 + v3 + 1216);
        dl_static_dtv[0] = 62;
        v10 = -v3 & (v9 + v3 - 1);
        goto LABEL_10;
      }
    }
    else
    {
LABEL_11:
      v3 = 0;
      v0 = 0;
      v14 = 0;
      v2 = 0;
    }
  }
  else
  {
    v3 = 0;
    v14 = 0;
    v2 = 0;
  }
  v12 = v2;
  v11 = (v2 + dl_tls_static_size + 63) & 0xFFFFFFC0;
  v5 = sbrk(v11 + 1280);
  dl_static_dtv[0] = 62;
  v10 = (v5 + 63) & 0xFFFFFFC0;
  v6 = v12;
  if ( !v3 )
    goto LABEL_8;
  v4 = (int)v0;
LABEL_10:
  v0 = (_DWORD *)v4;
  v6 = v3 * ((v3 + v12 - 1) / v3);
LABEL_8:
  v7 = (_BYTE *)(v10 + v11 - v6);
  v13[145] = v6;
  dl_static_dtv[4] = v7;
  dl_static_dtv[5] = 0;
  memcpy(v7, v0, v14);
  v8 = (_DWORD *)(v11 + v10);
  *v8 = v8;
  v8[1] = &dl_static_dtv[2];
  v8[2] = v8;
  v8[4] = dl_sysinfo;
  __asm { int     80h; LINUX - sys_set_thread_area }
  __halt();
}
// 804A5D0: could not find valid save-restore pair for ebx
// 804A5D0: could not find valid save-restore pair for esi
// 80CE024: using guessed type int dl_tls_static_size;
// 80CE9E0: using guessed type int (*dl_sysinfo)();
// 80CEA00: using guessed type void *dl_ns;
// 80CFCC0: using guessed type _DWORD dl_static_dtv[128];
// 80CFEC0: using guessed type _DWORD *dl_tls_dtv_slotinfo_list;
// 80CFF30: using guessed type _DWORD *dl_phdr;
// 80CFF50: using guessed type __int16 dl_phnum;

//----- (0804A980) --------------------------------------------------------
void __cdecl __noreturn _assert_fail_base(unsigned int *a1, int a2, int a3, int a4, int a5)
{
  unsigned __int8 *v5; // esi
  unsigned __int8 *v6; // ecx
  unsigned __int8 *v7; // eax
  int *v8; // edi
  int v9; // ebp
  unsigned int v10; // eax
  const struct timespec *v11; // esi
  _DWORD *v12; // eax
  int *v13; // [esp-18h] [ebp-4Ch]
  int v14; // [esp-18h] [ebp-4Ch]
  unsigned int *v15; // [esp+Ch] [ebp-28h] BYREF
  size_t v16[9]; // [esp+10h] [ebp-24h] BYREF

  v5 = (unsigned __int8 *)a5;
  v16[1] = __readgsdword(0x14u);
  v6 = ": ";
  if ( !a5 )
  {
    v5 = byte_80B41F9;
    v6 = byte_80B41F9;
  }
  v7 = ": ";
  if ( !*(_BYTE *)program_invocation_short_name[0] )
    v7 = byte_80B41F9;
  if ( (int)asprintf((int **)&v15, a1, program_invocation_short_name[0], v7, a3, a4, v5, v6, a2, v16) >= 0 )
  {
    _fxprintf((int)v16, (int *)a2, 0, (unsigned int *)"%s", v15, v5);
    v8 = v13;
    fflush((const struct timespec *)stderr);
    v16[0] = -dl_pagesize & (dl_pagesize + v16[0]);
    v9 = v14;
    v10 = mmap(0, v16[0], 3, 34, -1, 0);
    v11 = (const struct timespec *)v10;
    if ( v10 != -1 )
    {
      *(_DWORD *)v10 = v16[0];
      strcpy((_BYTE *)(v10 + 4), v15);
      v12 = (_DWORD *)_InterlockedExchange(&_abort_msg, (__int32)v11);
      if ( v12 )
      {
        munmap(v12, *v12);
        _assert_fail_base_cold_0(v9, v8, v11, (int)a1, a2, a3, a4, a5);
      }
      _assert_fail_base_cold_0(v9, v8, v11, (int)a1, a2, a3, a4, a5);
    }
    _assert_fail_base_cold_0(v9, v8, (const struct timespec *)0xFFFFFFFF, (int)a1, a2, a3, a4, a5);
  }
  write(2, "Unexpected error.\n", 0x12u);
  JUMPOUT(0x804903F);
}
// 804AACD: control flows out of bounds to 804903F
// 804AA41: variable 'v13' is possibly undefined
// 804AA5F: variable 'v14' is possibly undefined
// 80B41F9: using guessed type unsigned __int8 byte_80B41F9[1671];
// 80CE474: using guessed type void *stderr;
// 80CE964: using guessed type char (*program_invocation_short_name[2])[1671];
// 80CE9B0: using guessed type int dl_pagesize;
// 80CF5E8: using guessed type int _abort_msg;

//----- (0804AAE0) --------------------------------------------------------
void __cdecl __noreturn _assert_fail(int a1, int a2, int a3, int a4)
{
  unsigned __int8 *v4; // eax

  v4 = dcgettext("libc", "%s%s%s:%u: %s%sAssertion `%s' failed.\n%n", 5u);
  _assert_fail_base((unsigned int *)v4, a1, a2, a3, a4);
}

//----- (0804AB20) --------------------------------------------------------
unsigned __int8 *__cdecl dcgettext(char *a1, unsigned __int8 *a2, unsigned int a3)
{
  return _dcigettext(a1, a2, 0, 0, 0, a3);
}

//----- (0804AB50) --------------------------------------------------------
int __usercall plural_eval@<eax>(int *a1@<eax>, int a2@<edx>, int a3@<ecx>)
{
  int *v4; // ebx
  int v5; // eax
  bool v6; // cc
  int v7; // esi
  int v9; // eax
  int v10; // eax
  int v11; // ecx
  int v12; // [esp+0h] [ebp-20h]

  v4 = a1;
  v5 = *a1;
  v6 = v5 <= 1;
  if ( v5 == 1 )
    return plural_eval((int *)v4[2], a2, a3) == 0;
  while ( 1 )
  {
    if ( v6 )
    {
      if ( v5 )
        return 0;
      v9 = v4[1];
      v7 = a2;
      if ( v9 )
      {
        v7 = 0;
        if ( v9 == 1 )
          return v4[2];
      }
      return v7;
    }
    if ( v5 == 2 )
      break;
    if ( v5 != 3 )
      return 0;
    v4 = (int *)v4[(plural_eval((int *)v4[2], a2, a3) == 0) + 3];
    v5 = *v4;
    v6 = *v4 <= 1;
    if ( *v4 == 1 )
      return plural_eval((int *)v4[2], a2, a3) == 0;
  }
  v10 = plural_eval((int *)v4[2], a2, a3);
  v11 = v4[1];
  v7 = v10;
  if ( v11 == 15 )
  {
    if ( v10 )
      return 1;
    return plural_eval((int *)v4[3], a2, v11) != 0;
  }
  if ( v11 != 14 )
  {
    v12 = v4[1];
    plural_eval((int *)v4[3], a2, v11);
    if ( (unsigned int)(v12 - 3) <= 0xA )
      __asm { jmp     edi }
    return 0;
  }
  if ( v10 )
    return plural_eval((int *)v4[3], a2, v11) != 0;
  return v7;
}
// 804AB7E: variable 'a3' is possibly undefined

//----- (0804ACF0) --------------------------------------------------------
int __cdecl transcmp(int a1, int a2)
{
  _BYTE *v2; // edx
  char *v3; // eax
  int result; // eax

  if ( *(_DWORD *)(a2 + 16) )
    v2 = (_BYTE *)(a2 + 28);
  else
    v2 = *(_BYTE **)(a2 + 28);
  if ( *(_DWORD *)(a1 + 16) )
    v3 = (char *)(a1 + 28);
  else
    v3 = *(char **)(a1 + 28);
  result = strcmp(v3, v2);
  if ( !result )
  {
    result = strcmp(*(char **)a1, *(_BYTE **)a2);
    if ( !result )
    {
      result = strcmp(*(char **)(a1 + 8), *(_BYTE **)(a2 + 8));
      if ( !result )
        return *(_DWORD *)(a1 + 4) - *(_DWORD *)(a2 + 4);
    }
  }
  return result;
}

//----- (0804AD70) --------------------------------------------------------
_BYTE *__usercall plural_lookup_isra_2@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>, int a4)
{
  int v4; // esi
  unsigned int v6; // eax
  unsigned int v7; // edi
  _BYTE *v8; // eax

  v4 = a3;
  v6 = plural_eval(*(int **)(a1 + 96), a2, a3);
  if ( v6 < *(_DWORD *)(a1 + 100) )
  {
    v7 = v6;
    v8 = (_BYTE *)v4;
    while ( --v7 != -1 )
    {
      v8 = rawmemchr(v8, 0) + 1;
      if ( (unsigned int)v8 >= v4 + a4 )
        return (_BYTE *)v4;
    }
    return v8;
  }
  return (_BYTE *)v4;
}

//----- (0804ADC0) --------------------------------------------------------
int __usercall nl_find_msg@<eax>(int a1@<esi>, int *a2, int a3, unsigned __int8 *a4, int a5, _DWORD *a6)
{
  int *tv_sec; // esi
  int v7; // edi
  unsigned int v8; // eax
  unsigned int v9; // edi
  unsigned int v10; // ebx
  _BYTE *v11; // ecx
  char *v12; // edx
  unsigned int *v13; // eax
  unsigned int v14; // esi
  int *v15; // esi
  unsigned __int32 v16; // eax
  int v17; // eax
  _BYTE *v18; // eax
  unsigned int v19; // edi
  unsigned __int32 v20; // eax
  unsigned int v21; // edi
  _DWORD *v22; // eax
  int v23; // eax
  const struct timespec *v24; // esi
  int *v25; // eax
  unsigned __int8 *v26; // ebx
  int v27; // eax
  _TBYTE *v28; // ebx
  unsigned int v30; // ebx
  char *v31; // esi
  unsigned int v32; // eax
  unsigned int v33; // edi
  int tv_nsec; // edx
  struct timespec *v35; // eax
  unsigned int v36; // esi
  unsigned int v37; // eax
  unsigned __int32 v38; // ecx
  int v39; // eax
  bool v40; // zf
  unsigned int *v41; // eax
  unsigned int v42; // edx
  unsigned int v43; // eax
  int v44; // edx
  __time_t v45; // ecx
  int v46; // edi
  char **v47; // esi
  char **v48; // ebx
  int v49; // eax
  _DWORD *v50; // eax
  unsigned __int8 *v51; // ecx
  int v52; // eax
  int v53; // edx
  _BYTE *v54; // ebx
  int v55; // edi
  char **v56; // esi
  char **v57; // ebx
  _TBYTE *v58; // eax
  int *v59; // eax
  bool v62; // zf
  unsigned int v63; // esi
  int v64; // edi
  int *v65; // eax
  _TBYTE *v66; // ecx
  int v67; // eax
  int v68; // edx
  int *v69; // ebx
  int *v70; // eax
  char *v71; // ecx
  _TBYTE *v72; // ebx
  char *msg; // eax
  char *v74; // eax
  unsigned int v75; // eax
  _BYTE *v76; // edx
  int v77; // ecx
  void *v78; // esp
  unsigned int v79; // ebx
  int *i; // eax
  char v81; // dl
  int v82; // edx
  _BYTE *v83; // ecx
  __int16 v84; // dx
  int v85; // eax
  void *v86; // esp
  int *v87; // edx
  char *v88; // ecx
  int v89; // eax
  int *p_tv_sec; // eax
  unsigned int j; // ebx
  char v92; // dl
  int v93; // edx
  _BYTE *v94; // ecx
  __int16 v95; // dx
  int v96; // eax
  void *v97; // esp
  struct timespec *v98; // edx
  int tv_sec_low; // eax
  char *v100; // esi
  int v101; // ecx
  char **v102; // eax
  int v103; // eax
  bool v106; // zf
  _TBYTE *v107; // ebx
  int *v108; // eax
  const struct timespec *v109; // esi
  int v110; // eax
  int *v111; // edi
  char *v112; // edx
  int v113; // ecx
  unsigned int v114; // edx
  int v115; // ecx
  unsigned __int8 *v116; // eax
  int v117; // [esp-Ch] [ebp-307Ch]
  char *v118; // [esp-Ch] [ebp-307Ch]
  _BYTE v120[4096]; // [esp+4h] [ebp-306Ch] BYREF
  _BYTE v121[4096]; // [esp+1004h] [ebp-206Ch] BYREF
  _BYTE v122[15]; // [esp+2004h] [ebp-106Ch] BYREF
  _BYTE *v123; // [esp+2FF8h] [ebp-78h]
  _BYTE v124[8]; // [esp+3004h] [ebp-6Ch] BYREF
  unsigned int v125; // [esp+300Ch] [ebp-64h]
  _DWORD *v126; // [esp+3010h] [ebp-60h]
  _BYTE *v127; // [esp+3014h] [ebp-5Ch]
  _BYTE *v128; // [esp+3018h] [ebp-58h]
  char *v129; // [esp+301Ch] [ebp-54h]
  _TBYTE *v130; // [esp+3020h] [ebp-50h]
  struct timespec *v131; // [esp+3024h] [ebp-4Ch]
  int *v132; // [esp+3028h] [ebp-48h]
  struct timespec *v133; // [esp+302Ch] [ebp-44h]
  struct timespec *v134; // [esp+3030h] [ebp-40h]
  int v135; // [esp+3034h] [ebp-3Ch]
  int *v136; // [esp+3038h] [ebp-38h]
  char *v137; // [esp+303Ch] [ebp-34h]
  unsigned __int8 *v138; // [esp+3040h] [ebp-30h]
  unsigned __int8 *v139; // [esp+3044h] [ebp-2Ch] BYREF
  int *v140; // [esp+3048h] [ebp-28h] BYREF
  _DWORD v141[8]; // [esp+304Ch] [ebp-24h] BYREF
  int v142; // [esp+306Ch] [ebp-4h] BYREF

  v141[6] = a1;
  v130 = &GLOBAL_OFFSET_TABLE_;
  v127 = (_BYTE *)a3;
  v131 = (struct timespec *)a2;
  v138 = a4;
  v126 = a6;
  v141[1] = __readgsdword(0x14u);
  if ( a2[1] <= 0 )
    nl_load_domain((size_t)&v142, a1, a2, (int)v127);
  tv_sec = (int *)v131[1].tv_sec;
  if ( !tv_sec )
    return 0;
  v7 = tv_sec[12];
  v137 = (char *)tv_sec[5];
  if ( v7 )
  {
    v134 = (struct timespec *)strlen((unsigned int *)v138);
    v8 = _hash_string(v138);
    v9 = tv_sec[11];
    v10 = v8 % v9;
    v136 = (int *)tv_sec[13];
    v135 = tv_sec[12];
    v11 = (_BYTE *)(v8 % (v9 - 2) + 1);
    v12 = (char *)tv_sec;
    v133 = (struct timespec *)(v9 - (_DWORD)v11);
    v132 = (int *)&v11[-v9];
    while ( 1 )
    {
      v19 = *(_DWORD *)(v135 + 4 * v10);
      v20 = _byteswap_ulong(v19);
      if ( v136 )
        v19 = v20;
      if ( !v19 )
        return 0;
      v21 = v19 - 1;
      if ( (unsigned int)v137 > v21 )
      {
        v13 = (unsigned int *)(*((_DWORD *)v12 + 6) + 8 * v21);
        v14 = *v13;
        if ( *((_DWORD *)v12 + 3) )
        {
          if ( (unsigned int)v134 > _byteswap_ulong(v14) )
            goto LABEL_10;
          v15 = *(int **)v12;
          v16 = _byteswap_ulong(v13[1]);
        }
        else
        {
          if ( (unsigned int)v134 > v14 )
            goto LABEL_10;
          v15 = *(int **)v12;
          v16 = v13[1];
        }
        v128 = v11;
        v129 = v12;
        v17 = strcmp((char *)v138, (_BYTE *)v15 + v16);
        v12 = v129;
        v11 = v128;
        if ( !v17 )
        {
          v136 = v15;
          v24 = (const struct timespec *)v129;
          goto LABEL_42;
        }
      }
      else
      {
        v22 = (_DWORD *)(*((_DWORD *)v12 + 9) + 8 * (v21 - (_DWORD)v137));
        if ( *v22 > (unsigned int)v134 )
        {
          v123 = (_BYTE *)v22[1];
          v128 = v11;
          v129 = v12;
          v23 = strcmp((char *)v138, v123);
          v12 = v129;
          v11 = v128;
          if ( !v23 )
          {
            v24 = (const struct timespec *)v129;
            goto LABEL_20;
          }
        }
      }
LABEL_10:
      v18 = (char *)v132 + v10;
      if ( (unsigned int)v133 > v10 )
        v18 = &v11[v10];
      v10 = (unsigned int)v18;
    }
  }
  v133 = (struct timespec *)tv_sec;
  v30 = 0;
  v31 = v137;
  while ( 1 )
  {
    if ( (unsigned int)v31 <= v30 )
      return 0;
    v33 = (unsigned int)v31;
    tv_nsec = v133[1].tv_nsec;
    v35 = (struct timespec *)v133[3].tv_sec;
    v136 = (int *)v133->tv_sec;
    v135 = tv_nsec;
    v134 = v35;
    while ( 1 )
    {
      v36 = (v30 + v33) >> 1;
      v37 = v134[v36].tv_nsec;
      v38 = _byteswap_ulong(v37);
      if ( v135 )
        v37 = v38;
      v39 = strcmp((char *)v138, (_BYTE *)v136 + v37);
      v40 = v39 == 0;
      if ( v39 >= 0 )
        break;
      v33 = (v30 + v33) >> 1;
      if ( v30 >= v36 )
        return 0;
    }
    v32 = (v30 + v33) >> 1;
    v31 = (char *)v33;
    v21 = v32;
    if ( v40 )
      break;
    v30 = v32 + 1;
  }
  v24 = v133;
  if ( (unsigned int)v137 > v32 )
  {
LABEL_42:
    v41 = (unsigned int *)(v24[3].tv_nsec + 8 * v21);
    v42 = *v41;
    v43 = v41[1];
    if ( v24[1].tv_nsec )
    {
      v43 = _byteswap_ulong(v43);
      v42 = _byteswap_ulong(v42);
    }
    v138 = (unsigned __int8 *)v136 + v43;
    v135 = v42 + 1;
  }
  else
  {
LABEL_20:
    v25 = (int *)(v24[5].tv_sec + 8 * (v21 - (_DWORD)v137));
    v26 = (unsigned __int8 *)v25[1];
    v27 = *v25;
    v138 = v26;
    v135 = v27;
  }
  if ( !a5 )
    goto LABEL_22;
  if ( !v127 || (v136 = (int *)*((_DWORD *)v127 + 2)) == 0 )
  {
    if ( *(_DWORD *)((char *)v130 + (_DWORD)(&output_charset_cached_11630 - 33765376)) )
    {
      v136 = *(int **)((char *)v130 + (_DWORD)(&output_charset_cache_11629 - 33765376));
    }
    else
    {
      v59 = (int *)getenv((__int16 *)&aOutputCharset[(_DWORD)v130 - 135061504]);
      if ( v59 && *(_BYTE *)v59 )
      {
        v133 = (struct timespec *)v59;
        v134 = (struct timespec *)(strlen((unsigned int *)v59) + 1);
        v108 = malloc(v134);
        v136 = v108;
        if ( v108 )
          memcpy(v108, v133, (unsigned int)v134);
        *(_DWORD *)((char *)v130 + (_DWORD)(&output_charset_cache_11629 - 33765376)) = v136;
      }
      else
      {
        v136 = *(int **)((char *)v130 + (_DWORD)(&output_charset_cache_11629 - 33765376));
      }
      *(_DWORD *)((char *)v130 + (_DWORD)(&output_charset_cached_11630 - 33765376)) = 1;
    }
    if ( !v136 )
      v136 = *(int **)(*(_DWORD *)__readgsdword(0xFFFFFFD0) + 92);
  }
  v44 = v24[7].tv_nsec;
  if ( v44 )
  {
    v45 = v24[7].tv_sec;
    v134 = (struct timespec *)v24;
    v133 = (struct timespec *)v21;
    v46 = v44;
    v47 = (char **)(v45 + 12 * v44 - 12);
    do
    {
      --v46;
      v48 = v47;
      if ( !strcmp(*v47, v136) )
      {
        v24 = v134;
        v136 = (int *)v48;
        v21 = (unsigned int)v133;
        goto LABEL_53;
      }
      v47 -= 3;
    }
    while ( v46 );
    v24 = v134;
    v21 = (unsigned int)v133;
  }
  v134 = 0;
  v53 = v24[7].tv_nsec;
  v54 = (_BYTE *)v24[7].tv_sec;
  v129 = (char *)v53;
  v128 = v54;
  if ( !v53 )
    goto LABEL_99;
  v133 = (struct timespec *)v24;
  v132 = (int *)v21;
  v55 = v53;
  v56 = (char **)&v54[12 * v53 - 12];
  while ( 1 )
  {
    --v55;
    v57 = v56;
    if ( !strcmp(*v56, v136) )
      break;
    v56 -= 3;
    if ( !v55 )
    {
      v24 = v133;
      v21 = (unsigned int)v132;
LABEL_99:
      v133 = (struct timespec *)(4 * (3 * (_DWORD)v129 + 3));
      if ( v128 )
        v69 = realloc((int)&v142, v128, (const struct timespec *)(4 * (3 * (_DWORD)v129 + 3)));
      else
        v69 = malloc(v133);
      if ( v69 )
      {
        v24[7].tv_sec = (__time_t)v69;
        v70 = strdup((unsigned int *)v136);
        v132 = v70;
        if ( v70 )
        {
          v71 = (char *)&v133[-1] + (_DWORD)v69 - 4;
          v72 = v130;
          *(_DWORD *)v71 = v70;
          *((_DWORD *)v71 + 1) = -1;
          v136 = (int *)v71;
          msg = (char *)nl_find_msg((int)v24, &v131->tv_sec, (int)v127, (unsigned __int8 *)v72 - 105991, 0, v141);
          if ( msg != (char *)-1 )
          {
            if ( !msg )
              goto LABEL_135;
            v74 = strstr(msg, (unsigned int *)((char *)v72 - 179557));
            if ( !v74 )
              goto LABEL_135;
            v133 = (struct timespec *)(v74 + 8);
            v75 = (unsigned int)strcspn((int)(v74 + 8), (_BYTE *)v72 - 179548);
            v76 = &v124[-((v75 + 28) & 0xFFFFF000)];
            if ( v124 != v76 )
            {
              while ( v122 != v76 )
                ;
            }
            v77 = ((_WORD)v75 + 28) & 0xFF0;
            if ( (((_WORD)v75 + 28) & 0xFF0) != 0 )
            {
              v78 = alloca(v77);
              *(_DWORD *)&v121[v77 + 4092] = *(_DWORD *)&v121[v77 + 4092];
            }
            v79 = 0;
            v131 = (struct timespec *)v122;
            v127 = v122;
            *(_BYTE *)mempcpy(v122, v133, v75) = 0;
            for ( i = v132; ; i = (int *)((char *)i + 1) )
            {
              v81 = *(_BYTE *)i;
              if ( !*(_BYTE *)i )
                break;
              v79 += v81 == 47;
            }
            v82 = (char *)i - (char *)v132 + 38;
            v83 = &v122[-(v82 & 0xFFFFF000)];
            v84 = v82 & 0xFFF0;
            if ( v122 != v83 )
            {
              while ( v121 != v83 )
                ;
            }
            v85 = v84 & 0xFFF;
            if ( (v84 & 0xFFF) != 0 )
            {
              v86 = alloca(v85);
              *(_DWORD *)&v120[v85 + 4092] = *(_DWORD *)&v120[v85 + 4092];
            }
            v87 = v132;
            v88 = v121;
            v129 = v121;
            LOBYTE(v128) = *(_BYTE *)v132;
            if ( (_BYTE)v128 )
            {
              v125 = v79;
              v133 = *(struct timespec **)((char *)v130 + (_DWORD)(&off_80CDF7C - 33765376));
              v89 = (char)v128;
              do
              {
                v87 = (int *)((char *)v87 + 1);
                *v88++ = *(&v133->tv_sec + v89);
                v89 = *(char *)v87;
              }
              while ( (_BYTE)v89 );
              v79 = v125;
            }
            else
            {
              v88 = v129;
            }
            if ( v79 <= 1 )
            {
              *v88 = 47;
              if ( v79 )
              {
                ++v88;
              }
              else
              {
                v88[1] = 47;
                v88 += 10;
                *((_DWORD *)v88 - 2) = 1312903764;
                *((_DWORD *)v88 - 1) = 1414089811;
              }
            }
            *v88 = 0;
            p_tv_sec = &v131->tv_sec;
            for ( j = 0; ; j += v92 == 47 )
            {
              v92 = *(_BYTE *)p_tv_sec;
              if ( !*(_BYTE *)p_tv_sec )
                break;
              p_tv_sec = (int *)((char *)p_tv_sec + 1);
            }
            v93 = (char *)p_tv_sec - (char *)v131 + 30;
            v94 = &v121[-(v93 & 0xFFFFF000)];
            v95 = v93 & 0xFFF0;
            if ( v121 != v94 )
            {
              while ( v120 != v94 )
                ;
            }
            v96 = v95 & 0xFFF;
            if ( (v95 & 0xFFF) != 0 )
            {
              v97 = alloca(v96);
              *(_DWORD *)&v120[v96 - 4] = *(_DWORD *)&v120[v96 - 4];
            }
            v98 = (struct timespec *)v120;
            v133 = (struct timespec *)v120;
            tv_sec_low = SLOBYTE(v131->tv_sec);
            if ( (_BYTE)tv_sec_low )
            {
              v131 = (struct timespec *)v24;
              v100 = v127;
              v101 = *((_DWORD *)v130 - 33);
              do
              {
                ++v100;
                v98 = (struct timespec *)((char *)v98 + 1);
                HIBYTE(v98[-1].tv_nsec) = *(_DWORD *)(v101 + 4 * tv_sec_low);
                tv_sec_low = *v100;
              }
              while ( (_BYTE)tv_sec_low );
              v24 = v131;
            }
            else
            {
              v98 = v133;
            }
            if ( j <= 1 )
            {
              LOBYTE(v98->tv_sec) = 47;
              if ( j )
              {
                v98 = (struct timespec *)((char *)v98 + 1);
              }
              else
              {
                BYTE1(v98->tv_sec) = 47;
                v98 = (struct timespec *)((char *)v98 + 2);
              }
            }
            v102 = (char **)v136;
            LOBYTE(v98->tv_sec) = 0;
            v103 = _gconv_open(v129, &v133->tv_sec, v102 + 1, 1);
            if ( !v103 )
            {
LABEL_135:
              v136[2] = 0;
              ++v24[7].tv_nsec;
              goto LABEL_69;
            }
            if ( v103 == -1 )
            {
              v136[1] = -1;
              goto LABEL_135;
            }
            if ( v134 )
              MEMORY[0](&v24[8]);
            free((int)&v142, (int *)v21, (int)v132);
            return 0;
          }
          return (int)msg;
        }
      }
      if ( v134 )
      {
        MEMORY[0](&v24[8]);
        return -1;
      }
      return -1;
    }
  }
  v24 = v133;
  v21 = (unsigned int)v132;
  v136 = (int *)v57;
LABEL_69:
  if ( v134 )
    MEMORY[0](&v24[8]);
LABEL_53:
  if ( v136[1] == -1 )
    goto LABEL_22;
  v49 = v136[2];
  if ( v49 )
    goto LABEL_55;
  _ECX = 1;
  _EBX = v130;
  v106 = __readgsdword(0xCu) == 0;
  if ( !v106 )
    __asm { lock }
  __asm { cmpxchg [ebx+1570h], ecx }
  if ( !v106 )
    _lll_lock_wait_private(0, (int *)_EBX + 1372, (int)&v142, (int *)v21);
  if ( v136[2] )
  {
LABEL_141:
    v107 = v130;
    if ( __readgsdword(0xCu) )
      __asm { lock }
    v40 = (*((_DWORD *)v130 + 1372))-- == 1;
    if ( !v40 )
      _lll_unlock_wake_private((int *)v107 + 1372, (int)&v142, (int *)v21, v24);
    v49 = v136[2];
LABEL_55:
    if ( v49 == -1 )
      return -1;
    v50 = *(_DWORD **)(v49 + 4 * v21);
    if ( v50 )
      goto LABEL_57;
    _ECX = 1;
    _EBX = v130;
    v62 = __readgsdword(0xCu) == 0;
    if ( !v62 )
      __asm { lock }
    __asm { cmpxchg [ebx+1570h], ecx }
    if ( !v62 )
      _lll_lock_wait_private(0, (int *)_EBX + 1372, (int)&v142, (int *)v21);
    goto LABEL_87;
  }
  v116 = calloc((int *)v21, (unsigned int)&v137[v24[4].tv_sec], 4u);
  if ( !v116 )
  {
    v136[2] = -1;
    goto LABEL_141;
  }
  v136[2] = (int)v116;
LABEL_87:
  v132 = (int *)v21;
  v139 = v138;
  v63 = *((_DWORD *)v130 + 1370);
  v64 = 0;
  v140 = (int *)(*((_DWORD *)v130 + 1371) + 4);
  v134 = (struct timespec *)v141;
  v133 = (struct timespec *)&v140;
  while ( 1 )
  {
    if ( v63 <= 3 )
      goto LABEL_95;
    v67 = _gconv((int *)v136[1], (int *)&v139, (unsigned int)&v139[v135], &v133->tv_sec, (int)v140 + v63 - 4, v134);
    if ( (v67 & 0xFFFFFFFB) == 0 )
      break;
    if ( v67 != 5 )
    {
      v28 = v130;
      if ( __readgsdword(0xCu) )
        __asm { lock }
      v40 = (*((_DWORD *)v130 + 1372))-- == 1;
      if ( !v40 )
        _lll_unlock_wake_private((int *)v28 + 1372, (int)&v142, (int *)v64, (const struct timespec *)v63);
      return 0;
    }
    v139 = v138;
LABEL_95:
    if ( v64 )
    {
      ++v64;
      v63 = 4080 * v64;
      v137 = *(char **)((char *)v130 + (_DWORD)(&transmem_list - 33765376));
      v118 = v137;
      *(_DWORD *)((char *)v130 + (_DWORD)(&freemem_size_11587 - 33765376)) = 4080 * v64;
      v65 = realloc((int)&v142, v118, (const struct timespec *)(4080 * v64));
      if ( !v65 )
      {
        v117 = (int)v137;
        *((_DWORD *)v130 + 1373) = *(_DWORD *)v137;
        free((int)&v142, (int *)v64, v117);
LABEL_74:
        v58 = v130;
        *(_DWORD *)((char *)v130 + (_DWORD)(&freemem_11586 - 33765376)) = 0;
        *(_DWORD *)((char *)v58 + (_DWORD)(&freemem_size_11587 - 33765376)) = 0;
        if ( __readgsdword(0xCu) )
          __asm { lock }
        v40 = (*((_DWORD *)v58 + 1372))-- == 1;
        if ( !v40 )
          _lll_unlock_wake_private((int *)v58 + 1372, (int)&v142, (int *)v64, (const struct timespec *)v63);
        return -1;
      }
      v63 -= 4;
      *((_DWORD *)v130 + 1373) = v65;
    }
    else
    {
      v64 = (int)v130;
      *((_DWORD *)v130 + 1370) = 4080;
      v65 = malloc((const struct timespec *)0xFF0);
      if ( !v65 )
        goto LABEL_74;
      v68 = *(_DWORD *)(v64 + 5492);
      v63 = 4076;
      *(_DWORD *)(v64 + 5492) = v65;
      v64 = 1;
      *v65 = v68;
    }
    v66 = v130;
    v140 = v65 + 2;
    *((_DWORD *)v130 + 1371) = v65 + 1;
    *((_DWORD *)v66 + 1370) = v63;
  }
  v109 = (const struct timespec *)v130;
  v110 = (int)v140;
  v111 = v132;
  v112 = (char *)*((_DWORD *)v130 + 1371);
  v113 = (char *)v140 - v112;
  *(_DWORD *)v112 = (char *)v140 - v112 - 4;
  *(_DWORD *)(v136[2] + 4 * (_DWORD)v111) = v112;
  v114 = (v109[685].tv_sec - v113) & 0xFFFFFFFC;
  v115 = (LOBYTE(v109[685].tv_sec) - (_BYTE)v113) & 3;
  v109[685].tv_sec = v114;
  v109[685].tv_nsec = v115 + v110;
  if ( __readgsdword(0xCu) )
    __asm { lock }
  v40 = v109[686].tv_sec-- == 1;
  if ( !v40 )
    _lll_unlock_wake_private(&v109[686].tv_sec, (int)&v142, v111, v109);
  v50 = *(_DWORD **)(v136[2] + 4 * (_DWORD)v111);
LABEL_57:
  v51 = (unsigned __int8 *)(v50 + 1);
  v52 = *v50;
  v138 = v51;
  v135 = v52;
LABEL_22:
  *v126 = v135;
  return (int)v138;
}
// 80CDF7C: using guessed type int (*off_80CDF7C)[256];
// 80CE000: using guessed type _TBYTE GLOBAL_OFFSET_TABLE_;
// 80CF560: using guessed type int output_charset_cache_11629;
// 80CF564: using guessed type int output_charset_cached_11630;
// 80CF568: using guessed type int freemem_size_11587;
// 80CF56C: using guessed type int freemem_11586;
// 80CF574: using guessed type int transmem_list;

//----- (0804B970) --------------------------------------------------------
unsigned __int8 *__cdecl _dcigettext(char *a1, unsigned __int8 *a2, int a3, int a4, int a5, unsigned int a6)
{
  char *v6; // eax
  _DWORD *v7; // edx
  int v8; // esi
  int v9; // eax
  unsigned int *v10; // eax
  char *v11; // eax
  int v12; // edi
  int v13; // esi
  const char *v14; // eax
  const char *v15; // edx
  const char *v16; // eax
  int v17; // eax
  char *v18; // edx
  unsigned int v19; // eax
  int *v20; // edi
  int v21; // ecx
  void *v22; // esp
  _BYTE *v23; // eax
  _WORD *v24; // eax
  unsigned int *v25; // edx
  int v26; // eax
  _DWORD *v27; // edx
  __int16 v28; // cx
  _BYTE *v29; // eax
  int v30; // ecx
  void *v31; // esp
  char v32; // al
  bool v33; // cf
  bool v34; // zf
  _BYTE *v35; // esi
  int v36; // ecx
  char v37; // al
  bool v38; // cf
  bool v39; // zf
  _BYTE *v40; // esi
  int v41; // ecx
  int *domain; // eax
  int msg; // eax
  _BYTE *v44; // esi
  _DWORD *v45; // eax
  int v46; // edx
  int *v47; // eax
  int v48; // eax
  _BYTE *v50; // ecx
  int *v51; // eax
  _DWORD *v52; // eax
  int v53; // eax
  int *v54; // eax
  int v55; // edx
  _BYTE *v56; // ecx
  int v57; // eax
  _BYTE *v58; // eax
  _BYTE *v59; // edx
  _DWORD *v60; // ecx
  _BYTE v61[4]; // [esp-2004h] [ebp-209Ch]
  _BYTE v62[4096]; // [esp-2000h] [ebp-2098h] BYREF
  _DWORD v63[1024]; // [esp-1000h] [ebp-1098h] BYREF
  _DWORD *v64; // [esp+0h] [ebp-98h] BYREF
  int v65; // [esp+4h] [ebp-94h]
  int *v66; // [esp+8h] [ebp-90h]
  int (__cdecl *v67)(int, int); // [esp+Ch] [ebp-8Ch]
  unsigned int *v68; // [esp+10h] [ebp-88h]
  int *v69; // [esp+14h] [ebp-84h]
  unsigned int v70; // [esp+18h] [ebp-80h]
  unsigned int v71; // [esp+1Ch] [ebp-7Ch]
  _DWORD *v72; // [esp+20h] [ebp-78h]
  int v73; // [esp+24h] [ebp-74h]
  int v74; // [esp+28h] [ebp-70h]
  const char *v75; // [esp+2Ch] [ebp-6Ch]
  unsigned int *v76; // [esp+30h] [ebp-68h]
  char *v77; // [esp+34h] [ebp-64h]
  const char *v78; // [esp+38h] [ebp-60h]
  unsigned int *v79; // [esp+3Ch] [ebp-5Ch]
  unsigned __int8 *v80; // [esp+40h] [ebp-58h]
  char *v81; // [esp+44h] [ebp-54h]
  _BYTE *v82; // [esp+48h] [ebp-50h]
  int v83; // [esp+4Ch] [ebp-4Ch]
  unsigned int *v84; // [esp+54h] [ebp-44h] BYREF
  int v85; // [esp+58h] [ebp-40h] BYREF
  int v86[15]; // [esp+5Ch] [ebp-3Ch] BYREF
  int savedregs; // [esp+98h] [ebp+0h] BYREF

  v77 = a1;
  v73 = a3;
  v80 = a2;
  v86[8] = __readgsdword(0x14u);
  v84 = 0;
  if ( !a2 )
    return 0;
  if ( a6 > 0xC || a6 == 6 )
  {
    if ( !a4 || a5 == 1 )
      return v80;
    return (unsigned __int8 *)v73;
  }
  v70 = -32;
  v71 = __readgsdword(0xFFFFFFE0);
  v6 = v77;
  v86[4] = 0;
  if ( !v77 )
    v6 = nl_current_default_domain;
  v86[7] = (int)v80;
  v77 = v6;
  v86[0] = (int)v6;
  v86[1] = a6;
  v68 = (unsigned int *)_current_locale_name(a6);
  v86[2] = (int)v68;
  v67 = transcmp;
  v66 = &root;
  v72 = tfind((int)v86, &root, transcmp);
  v74 = 0;
  if ( v72 )
  {
    v7 = (_DWORD *)*v72;
    if ( *(_DWORD *)(*v72 + 12) == nl_msg_cat_cntr )
    {
      v44 = (_BYTE *)v7[5];
      if ( a4 )
        v44 = plural_lookup_isra_2(*(_DWORD *)(v7[4] + 8), a5, v7[5], v7[6]);
      __writegsdword(v70, v71);
      return v44;
    }
  }
  v82 = (_BYTE *)nl_domain_bindings;
  if ( nl_domain_bindings )
  {
    v8 = nl_domain_bindings;
    while ( 1 )
    {
      v9 = strcmp(v77, (_BYTE *)(v8 + 12));
      if ( !v9 )
        break;
      if ( v9 < 0 )
      {
        v82 = 0;
        goto LABEL_68;
      }
      v8 = *(_DWORD *)v8;
      if ( !v8 )
      {
        v82 = 0;
        v79 = (unsigned int *)"/usr/share/locale";
        goto LABEL_17;
      }
    }
    v10 = *(unsigned int **)(v8 + 4);
    v82 = (_BYTE *)v8;
    v34 = *(_BYTE *)v10 == 47;
    v79 = v10;
    if ( v34 )
      goto LABEL_17;
    v11 = getcwd(0LL);
    v12 = (int)v11;
    if ( v11 )
    {
      v13 = asprintf((int **)&v84, (unsigned int *)"%s/%s", v11, v79);
      free((int)&savedregs, (int *)v12, v12);
      if ( v13 >= 0 )
      {
        v79 = v84;
        goto LABEL_17;
      }
    }
LABEL_55:
    free((int)&savedregs, (int *)v12, (int)v84);
    if ( v74 )
    {
      MEMORY[0](&nl_state_lock);
      MEMORY[0](&_libc_setlocale_lock);
    }
    __writegsdword(v70, v71);
    if ( a5 == 1 || !a4 )
      return v80;
    return (unsigned __int8 *)v73;
  }
LABEL_68:
  v79 = (unsigned int *)"/usr/share/locale";
LABEL_17:
  v63[1020] = a6;
  v83 = (int)&nl_category_names[(unsigned __int8)nl_category_name_idxs[a6]];
  v14 = (const char *)_current_locale_name(a6);
  v78 = "C";
  v15 = v14;
  if ( strcmp(v14, "C") )
  {
    v81 = (char *)v14;
    v16 = (const char *)getenv((__int16 *)"LANGUAGE");
    v15 = v81;
    if ( v16 )
    {
      if ( *v16 )
        v15 = v16;
    }
  }
  v81 = (char *)v15;
  v65 = strlen((unsigned int *)v77);
  v17 = strlen((unsigned int *)v83);
  v18 = v81;
  v19 = v65 + v17 + 32;
  v20 = (int *)((char *)&v64 - (v19 & 0xFFFFF000));
  if ( &v64 != (_DWORD **)v20 )
  {
    while ( v63 != v20 )
      ;
  }
  v21 = v19 & 0xFF0;
  if ( (v19 & 0xFF0) != 0 )
  {
    v22 = alloca(v21);
    *(_DWORD *)&v62[v21 + 4092] = *(_DWORD *)&v62[v21 + 4092];
  }
  v81 = v18;
  v76 = v63;
  v23 = stpcpy((int)v63, v83);
  *(_WORD *)v23 = 47;
  v24 = mempcpy(v23 + 1, v77, v65);
  v25 = (unsigned int *)v81;
  *(_DWORD *)v24 = 7302446;
  v83 = (int)v25;
  v26 = strlen(v25);
  v27 = (_DWORD *)v83;
  v28 = (v26 + 28) & 0xFFF0;
  v29 = (char *)v63 - ((v26 + 28) & 0xFFFFF000);
  if ( v63 != (_DWORD *)v29 )
  {
    while ( v62 != v29 )
      ;
  }
  v30 = v28 & 0xFFF;
  if ( v30 )
  {
    v31 = alloca(v30);
    *(_DWORD *)&v61[v30] = *(_DWORD *)&v61[v30];
  }
  v83 = (int)v62;
  v75 = "POSIX";
  v69 = &_libc_enable_secure;
  while ( 1 )
  {
    do
    {
      do
      {
LABEL_30:
        while ( 1 )
        {
          v32 = *(_BYTE *)v27;
          if ( *(_BYTE *)v27 != 58 )
            break;
          v27 = (_DWORD *)((char *)v27 + 1);
        }
        v33 = 0;
        v34 = v32 == 0;
        if ( !v32 )
        {
          *(_WORD *)v83 = 67;
          break;
        }
        v50 = (_BYTE *)v83;
        do
        {
          v27 = (_DWORD *)((char *)v27 + 1);
          *v50++ = v32;
          v32 = *(_BYTE *)v27;
        }
        while ( *(_BYTE *)v27 && v32 != 58 );
        v51 = v69;
        *v50 = 0;
        v33 = 0;
        v34 = *v51 == 0;
        if ( !*v51 )
          break;
        v81 = (char *)v27;
        v52 = strchr((_BYTE *)v83, 47);
        v27 = v81;
        v33 = 0;
        v34 = v52 == 0;
      }
      while ( v52 );
      v35 = (_BYTE *)v83;
      v12 = (int)v78;
      v36 = 2;
      v81 = (char *)v27;
      do
      {
        if ( !v36 )
          break;
        v33 = *v35 < *(_BYTE *)v12;
        v34 = *v35++ == *(_BYTE *)v12++;
        --v36;
      }
      while ( v34 );
      v37 = (!v33 && !v34) - v33;
      v38 = 0;
      v39 = v37 == 0;
      if ( !v37 )
        goto LABEL_55;
      v40 = (_BYTE *)v83;
      v12 = (int)v75;
      v41 = 6;
      do
      {
        if ( !v41 )
          break;
        v38 = *v40 < *(_BYTE *)v12;
        v39 = *v40++ == *(_BYTE *)v12++;
        --v41;
      }
      while ( v39 );
      if ( (!v38 && !v39) == v38 )
        goto LABEL_55;
      domain = (int *)nl_find_domain(v79, (unsigned int *)v83, v76, (int)v82);
      v27 = v81;
      v12 = (int)domain;
    }
    while ( !domain );
    msg = nl_find_msg((int)&v85, domain, (int)v82, v80, 1, &v85);
    v27 = v81;
    if ( msg )
      break;
    v47 = *(int **)(v12 + 16);
    if ( v47 )
    {
      v81 = (char *)v12;
      v64 = v27;
      v12 = 0;
      while ( 1 )
      {
        v48 = nl_find_msg((int)&v85, v47, (int)v82, v80, 1, &v85);
        if ( v48 == -1 )
          goto LABEL_55;
        if ( v48 )
        {
          v44 = (_BYTE *)v48;
          v12 = *(_DWORD *)&v81[4 * v12 + 16];
          goto LABEL_44;
        }
        ++v12;
        v47 = *(int **)&v81[4 * v12 + 16];
        if ( !v47 )
        {
          v27 = v64;
          goto LABEL_30;
        }
      }
    }
  }
  v44 = (_BYTE *)msg;
  if ( msg == -1 )
    goto LABEL_55;
LABEL_44:
  free((int)&savedregs, (int *)v12, (int)v84);
  if ( v72 )
  {
    v45 = (_DWORD *)*v72;
    v45[3] = nl_msg_cat_cntr;
    v46 = v85;
    v45[4] = v12;
    v45[5] = v44;
    v45[6] = v46;
  }
  else
  {
    v83 = strlen((unsigned int *)v80) + 1;
    v53 = strlen(v68);
    v54 = malloc((const struct timespec *)(v83 + v65 + v53 + 30));
    if ( v54 )
    {
      v81 = (char *)v54;
      v83 = (int)mempcpy((_BYTE *)v54 + 28, v80, v83);
      v82 = (_BYTE *)(v65 + 1);
      memcpy((_BYTE *)v83, v77, v65 + 1);
      v82 += v83;
      strcpy(v82, v68);
      v55 = (int)v81;
      v56 = v82;
      *(_DWORD *)v81 = v83;
      *(_DWORD *)(v55 + 8) = v56;
      *(_DWORD *)(v55 + 4) = a6;
      *(_DWORD *)(v55 + 16) = v12;
      v57 = nl_msg_cat_cntr;
      *(_DWORD *)(v55 + 20) = v44;
      *(_DWORD *)(v55 + 12) = v57;
      *(_DWORD *)(v55 + 24) = v85;
      v83 = v55;
      v58 = tsearch(v55, v66, v67);
      v59 = (_BYTE *)v83;
      v60 = v58;
      if ( v74 )
      {
        v82 = v58;
        MEMORY[0](&tree_lock);
        v60 = v82;
        v59 = (_BYTE *)v83;
      }
      if ( !v60 || (_BYTE *)*v60 != v59 )
        free((int)&savedregs, (int *)v12, (int)v59);
    }
  }
  __writegsdword(v70, v71);
  if ( a4 )
    v44 = plural_lookup_isra_2(*(_DWORD *)(v12 + 8), a5, (int)v44, v85);
  if ( v74 )
  {
    MEMORY[0](&nl_state_lock);
    MEMORY[0](&_libc_setlocale_lock);
  }
  return v44;
}
// 804BECB: conditional instruction was optimized away because %var_70.4==0
// 80CDDAC: using guessed type int _libc_enable_secure;
// 80CE028: using guessed type char *nl_current_default_domain;
// 80CF578: using guessed type int root;
// 80CFED0: using guessed type int nl_domain_bindings;

//----- (0804C140) --------------------------------------------------------
__int64 __cdecl nl_find_domain(unsigned int *a1, unsigned int *a2, unsigned int *a3, int a4)
{
  unsigned __int8 *v4; // edi
  int v5; // eax
  int *l10nflist; // ebp
  __int64 result; // rax
  int *v8; // eax
  int v9; // esi
  unsigned int *v10; // eax
  int *v11; // eax
  int v12; // eax
  int *v13; // eax
  int v14; // esi
  unsigned int *v15; // [esp+28h] [ebp-44h]
  const struct timespec *v16; // [esp+2Ch] [ebp-40h]
  int v17; // [esp+2Ch] [ebp-40h]
  unsigned __int8 *v18; // [esp+38h] [ebp-34h] BYREF
  unsigned int *v19; // [esp+3Ch] [ebp-30h] BYREF
  unsigned __int8 *v20; // [esp+40h] [ebp-2Ch] BYREF
  char *v21; // [esp+44h] [ebp-28h] BYREF
  unsigned int *v22; // [esp+48h] [ebp-24h] BYREF
  unsigned int v23; // [esp+4Ch] [ebp-20h]

  v4 = (unsigned __int8 *)a2;
  v23 = __readgsdword(0x14u);
  v5 = strlen(a1);
  l10nflist = (int *)nl_make_l10nflist((unsigned int ***)&nl_loaded_domains, a1, v5 + 1, 0, a2, 0, 0, 0, 0, a3, 0);
  if ( l10nflist )
  {
    if ( l10nflist[1] <= 0 )
      nl_load_domain((size_t)l10nflist, (int)a1, l10nflist, a4);
    if ( !l10nflist[2] )
    {
      v8 = (int *)l10nflist[4];
      if ( v8 )
      {
        v9 = (int)(l10nflist + 4);
        do
        {
          if ( v8[1] <= 0 )
            nl_load_domain((size_t)l10nflist, v9, v8, a4);
          if ( *(_DWORD *)(*(_DWORD *)v9 + 8) )
            break;
          v9 += 4;
          v8 = *(int **)v9;
        }
        while ( *(_DWORD *)v9 );
      }
    }
  }
  else
  {
    v10 = (unsigned int *)nl_expand_alias(0, (char *)a2);
    v15 = v10;
    if ( v10 )
    {
      v15 = v10;
      v16 = (const struct timespec *)(strlen(v10) + 1);
      v11 = malloc(v16);
      v4 = (unsigned __int8 *)v11;
      if ( !v11 )
        goto LABEL_5;
      memcpy(v11, v15, (unsigned int)v16);
    }
    v17 = nl_explode_name(v4, &v18, &v19, &v20, &v21, &v22);
    if ( v17 != -1 )
    {
      v12 = strlen(a1);
      l10nflist = (int *)nl_make_l10nflist(
                           (unsigned int ***)&nl_loaded_domains,
                           a1,
                           v12 + 1,
                           v17,
                           (unsigned int *)v18,
                           (unsigned int *)v20,
                           (unsigned int *)v21,
                           v22,
                           v19,
                           a3,
                           1);
      if ( l10nflist )
      {
        if ( l10nflist[1] <= 0 )
          nl_load_domain((size_t)l10nflist, (int)a1, l10nflist, a4);
        if ( !l10nflist[2] )
        {
          v13 = (int *)l10nflist[4];
          if ( v13 )
          {
            v14 = (int)(l10nflist + 4);
            do
            {
              if ( v13[1] <= 0 )
                nl_load_domain((size_t)l10nflist, v14, v13, a4);
              if ( *(_DWORD *)(*(_DWORD *)v14 + 8) )
                break;
              v14 += 4;
              v13 = *(int **)v14;
            }
            while ( *(_DWORD *)v14 );
          }
        }
        if ( v15 )
          free((int)l10nflist, (int *)v4, (int)v4);
      }
      if ( (v17 & 1) != 0 )
        free((int)l10nflist, (int *)v4, (int)v22);
    }
  }
LABEL_5:
  HIDWORD(result) = __readgsdword(0x14u) ^ v23;
  LODWORD(result) = l10nflist;
  return result;
}
// 804C35B: conditional instruction was optimized away because %var_4C.4==0
// 80CF5C0: using guessed type int nl_loaded_domains;

//----- (0804C420) --------------------------------------------------------
unsigned int __usercall nl_load_domain@<eax>(size_t a1@<ebp>, int a2@<esi>, int *a3, int a4)
{
  unsigned int v5; // edx
  int *v6; // edi
  bool v8; // zf
  int v9; // eax
  int v10; // ecx
  int v11; // edx
  unsigned int v12; // eax
  int *v13; // eax
  unsigned int v14; // eax
  unsigned __int32 v15; // edx
  char *msg; // eax
  int v18; // eax
  int v19; // eax
  unsigned int v20; // ecx
  char *v21; // edx
  unsigned __int32 v22; // eax
  char *v23; // edx
  unsigned int v24; // edi
  unsigned int v25; // edx
  _BYTE *v26; // eax
  char v27; // di
  char v28; // dl
  int *v29; // eax
  int v30; // edi
  int *v31; // esi
  signed int nocancel; // eax
  int v33; // esi
  int v34; // eax
  unsigned int v35; // eax
  unsigned int v36; // edx
  unsigned int *v37; // eax
  int v38; // eax
  int v39; // ebp
  unsigned int v40; // edi
  char *v41; // edi
  bool v42; // al
  unsigned int v43; // edi
  unsigned int *v44; // edi
  int i; // eax
  unsigned int v46; // edx
  char v47; // cl
  char v48; // cl
  int *v49; // eax
  unsigned __int8 *v50; // ebp
  int v51; // esi
  int v52; // edi
  unsigned int *v53; // eax
  unsigned int v54; // edx
  char *v55; // edx
  int v56; // ecx
  _BYTE *v57; // ebp
  unsigned int *v58; // esi
  unsigned __int32 v59; // eax
  unsigned int *v60; // esi
  int v61; // eax
  unsigned int v62; // ecx
  unsigned int v63; // edi
  char *j; // edx
  unsigned int v65; // eax
  unsigned __int32 v66; // ecx
  int *v67; // edi
  int v68; // esi
  int k; // eax
  unsigned int v70; // edx
  unsigned __int32 v71; // ecx
  unsigned int v72; // eax
  unsigned int v73; // edi
  unsigned int v74; // ecx
  unsigned int v75; // esi
  int v76; // edi
  unsigned int v77; // eax
  int *v78; // eax
  _BYTE *v79; // [esp-14h] [ebp-FCh]
  int *v80; // [esp+4h] [ebp-E4h]
  int v81; // [esp+8h] [ebp-E0h]
  unsigned int *v82; // [esp+8h] [ebp-E0h]
  int v83; // [esp+8h] [ebp-E0h]
  unsigned int v84; // [esp+Ch] [ebp-DCh]
  const struct timespec *st_size; // [esp+10h] [ebp-D8h]
  unsigned int v86; // [esp+14h] [ebp-D4h]
  unsigned int *v87; // [esp+14h] [ebp-D4h]
  int v88; // [esp+14h] [ebp-D4h]
  int v89; // [esp+14h] [ebp-D4h]
  unsigned __int8 *v90; // [esp+18h] [ebp-D0h]
  char *v91; // [esp+1Ch] [ebp-CCh]
  int v92; // [esp+1Ch] [ebp-CCh]
  unsigned __int8 *v93; // [esp+1Ch] [ebp-CCh]
  unsigned __int32 v94; // [esp+20h] [ebp-C8h]
  int *v95; // [esp+20h] [ebp-C8h]
  unsigned __int32 v96; // [esp+24h] [ebp-C4h]
  int v97; // [esp+24h] [ebp-C4h]
  unsigned int *v98; // [esp+28h] [ebp-C0h]
  unsigned int *v99; // [esp+28h] [ebp-C0h]
  unsigned int v100; // [esp+28h] [ebp-C0h]
  int *v101; // [esp+28h] [ebp-C0h]
  unsigned int *v102; // [esp+2Ch] [ebp-BCh]
  _BYTE *v103; // [esp+2Ch] [ebp-BCh]
  int *v104; // [esp+30h] [ebp-B8h]
  int v105; // [esp+30h] [ebp-B8h]
  _BYTE *v106; // [esp+30h] [ebp-B8h]
  unsigned __int32 *v107; // [esp+30h] [ebp-B8h]
  bool v108; // [esp+34h] [ebp-B4h]
  int v109; // [esp+34h] [ebp-B4h]
  bool v110; // [esp+38h] [ebp-B0h]
  _DWORD *v111; // [esp+38h] [ebp-B0h]
  int v112; // [esp+38h] [ebp-B0h]
  int *v113; // [esp+3Ch] [ebp-ACh]
  int *v114; // [esp+3Ch] [ebp-ACh]
  int v115; // [esp+40h] [ebp-A8h]
  _DWORD *v116; // [esp+40h] [ebp-A8h]
  int *v117; // [esp+44h] [ebp-A4h]
  int v118; // [esp+50h] [ebp-98h]
  unsigned int *v119; // [esp+54h] [ebp-94h]
  int *v120; // [esp+58h] [ebp-90h]
  char v121[4]; // [esp+5Ch] [ebp-8Ch] BYREF
  struct stat v122; // [esp+60h] [ebp-88h] BYREF
  int v123[2]; // [esp+C0h] [ebp-28h]
  unsigned int v124; // [esp+C8h] [ebp-20h]

  _EBX = &GLOBAL_OFFSET_TABLE_;
  v5 = __readgsdword(8u);
  v6 = a3;
  v124 = __readgsdword(0x14u);
  if ( dword_80CF5CC != v5 )
  {
    _ECX = 1;
    v8 = __readgsdword(0xCu) == 0;
    if ( !v8 )
      __asm { lock }
    __asm { cmpxchg ds:(lock_10701 - 80CE000h)[ebx], ecx }
    if ( !v8 )
      _lll_lock_wait_private(0, &lock_10701, a1, a3);
    dword_80CF5CC = v5;
  }
  v9 = dword_80CF5C8;
  v10 = a3[1];
  ++dword_80CF5C8;
  if ( v10 )
    goto LABEL_27;
  v11 = *a3;
  a3[1] = -1;
  a3[2] = 0;
  if ( !v11 )
    goto LABEL_26;
  a2 = _open_nocancel(v11);
  if ( a2 == -1 )
    goto LABEL_43;
  v84 = _fxstat64(3, a2, &v122);
  if ( v84 )
    goto LABEL_37;
  st_size = (const struct timespec *)v122.st_size;
  if ( v122.st_blksize || v122.st_size <= 0x2Fu )
    goto LABEL_37;
  v80 = (int *)mmap(0, v122.st_size, 1, 2, a2, 0);
  a1 = (size_t)v80;
  if ( v80 == (int *)-1 )
  {
    v29 = malloc(st_size);
    v80 = v29;
    if ( !v29 )
      goto LABEL_37;
    v30 = a2;
    v31 = v29;
    a1 = (size_t)st_size;
    do
    {
      while ( 1 )
      {
        nocancel = _read_nocancel(v30, v31, a1);
        if ( nocancel > 0 )
          break;
        if ( nocancel != -1 || __readgsdword(0xFFFFFFE0) != 4 )
        {
          a2 = v30;
          v6 = a3;
LABEL_37:
          _close_nocancel(a2);
          v9 = dword_80CF5C8 - 1;
          goto LABEL_26;
        }
      }
      v31 = (int *)((char *)v31 + nocancel);
      a1 -= nocancel;
    }
    while ( a1 );
    v33 = v30;
    v6 = a3;
    _close_nocancel(v33);
    v34 = (int)v80;
    v81 = *v80;
    LOBYTE(v34) = *v80 != -1794895138;
    a2 = v34;
    if ( *v80 != -569244523 && *v80 != -1794895138 )
    {
      free(0, a3, (int)v80);
      v9 = dword_80CF5C8 - 1;
      goto LABEL_26;
    }
  }
  else
  {
    v12 = _close_nocancel(a2);
    v81 = *v80;
    LOBYTE(v12) = *v80 != -1794895138;
    a2 = v12;
    if ( *v80 != -569244523 && *v80 != -1794895138 )
    {
      munmap(v80, (int)st_size);
      v9 = dword_80CF5C8 - 1;
      goto LABEL_26;
    }
    v84 = 1;
  }
  v13 = malloc((const struct timespec *)0x68);
  a1 = (size_t)v13;
  if ( !v13 )
  {
LABEL_43:
    v9 = dword_80CF5C8 - 1;
    goto LABEL_26;
  }
  v6[2] = (int)v13;
  *v13 = (int)v80;
  v13[4] = 0;
  v13[1] = v84;
  v13[2] = (int)st_size;
  a2 = (unsigned __int8)a2;
  v14 = v80[1];
  *(_DWORD *)(a1 + 12) = (unsigned __int8)a2;
  if ( v81 != -1794895138 )
  {
    v14 = _byteswap_ulong(v14);
    if ( v14 > 0x1FFFF )
      goto LABEL_39;
    *(_DWORD *)(a1 + 20) = _byteswap_ulong(v80[2]);
    *(_DWORD *)(a1 + 24) = (char *)v80 + _byteswap_ulong(v80[3]);
    *(_DWORD *)(a1 + 28) = (char *)v80 + _byteswap_ulong(v80[4]);
    v96 = _byteswap_ulong(v80[5]);
    *(_DWORD *)(a1 + 44) = v96;
    if ( v96 > 2 )
    {
      v15 = _byteswap_ulong(v80[6]);
      goto LABEL_46;
    }
LABEL_22:
    *(_DWORD *)(a1 + 48) = 0;
    *(_DWORD *)(a1 + 52) = (unsigned __int8)a2;
    if ( (_WORD)v14 )
      goto LABEL_39;
    goto LABEL_23;
  }
  if ( v14 > 0x1FFFF )
    goto LABEL_39;
  *(_DWORD *)(a1 + 20) = v80[2];
  *(_DWORD *)(a1 + 24) = (char *)v80 + v80[3];
  v20 = v80[5];
  *(_DWORD *)(a1 + 28) = (char *)v80 + v80[4];
  v96 = v20;
  *(_DWORD *)(a1 + 44) = v20;
  if ( v20 <= 2 )
    goto LABEL_22;
  v15 = v80[6];
LABEL_46:
  *(_DWORD *)(a1 + 52) = (unsigned __int8)a2;
  v21 = (char *)v80 + v15;
  *(_DWORD *)(a1 + 48) = v21;
  if ( !(_WORD)v14 )
    goto LABEL_23;
  if ( !v21 )
    goto LABEL_39;
  v94 = v80[9];
  if ( v81 == -1794895138 )
  {
    if ( v94 )
    {
      a2 = v80[7];
      v22 = v80[8];
      v86 = a2;
      goto LABEL_51;
    }
LABEL_23:
    *(_DWORD *)(a1 + 32) = 0;
    *(_DWORD *)(a1 + 36) = 0;
    *(_DWORD *)(a1 + 40) = 0;
    goto LABEL_24;
  }
  v94 = _byteswap_ulong(v80[9]);
  if ( !v94 )
    goto LABEL_23;
  a2 = (int)v80;
  v86 = _byteswap_ulong(v80[7]);
  v22 = _byteswap_ulong(v80[8]);
LABEL_51:
  v91 = (char *)v80 + v22;
  v90 = calloc(v6, v86, 4u);
  if ( !v90 )
    goto LABEL_39;
  a2 = 0;
  if ( !v86 )
    goto LABEL_95;
  v104 = v6;
  do
  {
    v24 = *(_DWORD *)&v91[8 * a2 + 4];
    v25 = *(_DWORD *)&v91[8 * a2];
    v26 = (char *)v80 + v24;
    if ( v81 != -1794895138 )
    {
      v26 = (char *)v80 + _byteswap_ulong(v24);
      v25 = _byteswap_ulong(v25);
    }
    if ( !v25 || v26[v25 - 1] )
    {
      v6 = v104;
LABEL_91:
      free(a1, v6, (int)v90);
      v18 = 0;
      goto LABEL_40;
    }
    if ( *v26 == 80 )
    {
      v23 = 0;
      if ( v26[1] == 82 && v26[2] == 73 )
      {
        v27 = v26[3];
        v108 = v27 == 105 || v27 == 100;
        v110 = v108 || v27 == 111 || v27 == 117;
        if ( (v27 & 0xDF) == 88 || v110 )
        {
          v28 = v26[4];
          switch ( v28 )
          {
            case '8':
              if ( v26[5] )
              {
                v23 = 0;
              }
              else if ( v27 == 100 )
              {
                v23 = (char *)&unk_80A4B4A;
              }
              else if ( v108 )
              {
                v23 = "i";
              }
              else if ( v27 == 111 )
              {
                v23 = "o";
              }
              else if ( v110 )
              {
                v23 = (char *)&unk_80B40F6;
              }
              else if ( v27 == 120 )
              {
                v23 = "x";
              }
              else
              {
                if ( v27 != 88 )
                  goto LABEL_391;
                v23 = "X";
              }
              break;
            case '1':
              v23 = 0;
              if ( v26[5] == 54 && !v26[6] )
              {
                if ( v27 == 100 )
                {
                  v23 = (char *)&unk_80A4B4A;
                }
                else if ( v108 )
                {
                  v23 = "i";
                }
                else if ( v27 == 111 )
                {
                  v23 = "o";
                }
                else if ( v110 )
                {
                  v23 = (char *)&unk_80B40F6;
                }
                else if ( v27 == 120 )
                {
                  v23 = "x";
                }
                else
                {
                  if ( v27 != 88 )
                    goto LABEL_391;
                  v23 = "X";
                }
              }
              break;
            case '3':
              v23 = 0;
              if ( v26[5] == 50 && !v26[6] )
              {
                if ( v27 == 100 )
                {
                  v23 = (char *)&unk_80A4B4A;
                }
                else if ( v108 )
                {
                  v23 = "i";
                }
                else if ( v27 == 111 )
                {
                  v23 = "o";
                }
                else if ( v110 )
                {
                  v23 = (char *)&unk_80B40F6;
                }
                else if ( v27 == 120 )
                {
                  v23 = "x";
                }
                else
                {
                  if ( v27 != 88 )
                    goto LABEL_391;
                  v23 = "X";
                }
              }
              break;
            case '6':
              v23 = 0;
              if ( v26[5] == 52 && !v26[6] )
              {
                if ( v27 == 100 )
                {
                  v23 = "lld";
                }
                else if ( v108 )
                {
                  v23 = "lli";
                }
                else if ( v27 == 111 )
                {
                  v23 = "llo";
                }
                else if ( v110 )
                {
                  v23 = "llu";
                }
                else if ( v27 == 120 )
                {
                  v23 = "llx";
                }
                else
                {
                  if ( v27 != 88 )
                    goto LABEL_391;
                  v23 = "llX";
                }
              }
              break;
            case 'L':
              v23 = 0;
              if ( v26[5] == 69 && v26[6] == 65 && v26[7] == 83 && v26[8] == 84 )
              {
                v47 = v26[9];
                if ( v47 == 56 )
                {
                  if ( v26[10] )
                  {
                    v23 = 0;
                  }
                  else if ( v27 == 100 )
                  {
                    v23 = (char *)&unk_80A4B4A;
                  }
                  else if ( v108 )
                  {
                    v23 = "i";
                  }
                  else if ( v27 == 111 )
                  {
                    v23 = "o";
                  }
                  else if ( v110 )
                  {
                    v23 = (char *)&unk_80B40F6;
                  }
                  else if ( v27 == 120 )
                  {
                    v23 = "x";
                  }
                  else
                  {
                    if ( v27 != 88 )
                      goto LABEL_391;
                    v23 = "X";
                  }
                }
                else
                {
                  v23 = 0;
                  if ( v47 == 49 )
                  {
                    if ( v26[10] == 54 && !v26[11] )
                    {
                      if ( v27 == 100 )
                      {
                        v23 = (char *)&unk_80A4B4A;
                      }
                      else if ( v108 )
                      {
                        v23 = "i";
                      }
                      else if ( v27 == 111 )
                      {
                        v23 = "o";
                      }
                      else if ( v110 )
                      {
                        v23 = (char *)&unk_80B40F6;
                      }
                      else if ( v27 == 120 )
                      {
                        v23 = "x";
                      }
                      else
                      {
                        if ( v27 != 88 )
                          goto LABEL_391;
                        v23 = "X";
                      }
                    }
                  }
                  else if ( v47 == 51 )
                  {
                    if ( v26[10] == 50 && !v26[11] )
                    {
                      if ( v27 == 100 )
                      {
                        v23 = (char *)&unk_80A4B4A;
                      }
                      else if ( v108 )
                      {
                        v23 = "i";
                      }
                      else if ( v27 == 111 )
                      {
                        v23 = "o";
                      }
                      else if ( v110 )
                      {
                        v23 = (char *)&unk_80B40F6;
                      }
                      else if ( v27 == 120 )
                      {
                        v23 = "x";
                      }
                      else
                      {
                        if ( v27 != 88 )
                          goto LABEL_391;
                        v23 = "X";
                      }
                    }
                  }
                  else if ( v47 == 54 && v26[10] == 52 && !v26[11] )
                  {
                    if ( v27 == 100 )
                    {
                      v23 = "lld";
                    }
                    else if ( v108 )
                    {
                      v23 = "lli";
                    }
                    else if ( v27 == 111 )
                    {
                      v23 = "llo";
                    }
                    else if ( v110 )
                    {
                      v23 = "llu";
                    }
                    else if ( v27 == 120 )
                    {
                      v23 = "llx";
                    }
                    else
                    {
                      if ( v27 != 88 )
                        goto LABEL_391;
                      v23 = "llX";
                    }
                  }
                }
              }
              break;
            case 'F':
              v23 = 0;
              if ( v26[5] == 65 && v26[6] == 83 && v26[7] == 84 )
              {
                v48 = v26[8];
                if ( v48 == 56 )
                {
                  if ( v26[9] )
                  {
                    v23 = 0;
                  }
                  else if ( v27 == 100 )
                  {
                    v23 = (char *)&unk_80A4B4A;
                  }
                  else if ( v108 )
                  {
                    v23 = "i";
                  }
                  else if ( v27 == 111 )
                  {
                    v23 = "o";
                  }
                  else if ( v110 )
                  {
                    v23 = (char *)&unk_80B40F6;
                  }
                  else if ( v27 == 120 )
                  {
                    v23 = "x";
                  }
                  else
                  {
                    if ( v27 != 88 )
                      goto LABEL_391;
                    v23 = "X";
                  }
                }
                else
                {
                  v23 = 0;
                  if ( v48 == 49 )
                  {
                    if ( v26[9] == 54 && !v26[10] )
                    {
                      if ( v27 == 100 )
                      {
                        v23 = (char *)&unk_80A4B4A;
                      }
                      else if ( v108 )
                      {
                        v23 = "i";
                      }
                      else if ( v27 == 111 )
                      {
                        v23 = "o";
                      }
                      else if ( v110 )
                      {
                        v23 = (char *)&unk_80B40F6;
                      }
                      else if ( v27 == 120 )
                      {
                        v23 = "x";
                      }
                      else
                      {
                        if ( v27 != 88 )
                          goto LABEL_391;
                        v23 = "X";
                      }
                    }
                  }
                  else if ( v48 == 51 )
                  {
                    if ( v26[9] == 50 && !v26[10] )
                    {
                      if ( v27 == 100 )
                      {
                        v23 = (char *)&unk_80A4B4A;
                      }
                      else if ( v108 )
                      {
                        v23 = "i";
                      }
                      else if ( v27 == 111 )
                      {
                        v23 = "o";
                      }
                      else if ( v110 )
                      {
                        v23 = (char *)&unk_80B40F6;
                      }
                      else if ( v27 == 120 )
                      {
                        v23 = "x";
                      }
                      else
                      {
                        if ( v27 != 88 )
                          goto LABEL_391;
                        v23 = "X";
                      }
                    }
                  }
                  else if ( v48 == 54 && v26[9] == 52 && !v26[10] )
                  {
                    if ( v27 == 100 )
                    {
                      v23 = "lld";
                    }
                    else if ( v108 )
                    {
                      v23 = "lli";
                    }
                    else if ( v27 == 111 )
                    {
                      v23 = "llo";
                    }
                    else if ( v110 )
                    {
                      v23 = "llu";
                    }
                    else if ( v27 == 120 )
                    {
                      v23 = "llx";
                    }
                    else
                    {
                      if ( v27 != 88 )
                        goto LABEL_391;
                      v23 = "llX";
                    }
                  }
                }
              }
              break;
            case 'M':
              v23 = 0;
              if ( v26[5] == 65 && v26[6] == 88 )
              {
                if ( v26[7] )
                {
                  v23 = 0;
                }
                else if ( v27 == 100 )
                {
                  v23 = "lld";
                }
                else if ( v108 )
                {
                  v23 = "lli";
                }
                else if ( v27 == 111 )
                {
                  v23 = "llo";
                }
                else if ( v110 )
                {
                  v23 = "llu";
                }
                else if ( v27 == 120 )
                {
                  v23 = "llx";
                }
                else
                {
                  if ( v27 != 88 )
                    goto LABEL_391;
                  v23 = "llX";
                }
              }
              break;
            default:
              v8 = v28 == 80;
              v23 = 0;
              if ( v8 && v26[5] == 84 && v26[6] == 82 )
              {
                if ( v26[7] )
                {
                  v23 = 0;
                }
                else if ( v27 == 100 )
                {
                  v23 = (char *)&unk_80A4B4A;
                }
                else if ( v108 )
                {
                  v23 = "i";
                }
                else if ( v27 == 111 )
                {
                  v23 = "o";
                }
                else if ( v110 )
                {
                  v23 = (char *)&unk_80B40F6;
                }
                else if ( v27 == 120 )
                {
                  v23 = "x";
                }
                else
                {
                  if ( v27 != 88 )
                    goto LABEL_391;
                  v23 = "X";
                }
              }
              break;
          }
        }
      }
    }
    else if ( *v26 == 73 )
    {
      v23 = 0;
      if ( !v26[1] )
        v23 = "I";
    }
    else
    {
      v23 = 0;
    }
    *(_DWORD *)&v90[4 * a2++] = v23;
  }
  while ( a2 != v86 );
  v6 = v104;
LABEL_95:
  v35 = v80[10];
  v36 = v80[11];
  if ( v81 == -1794895138 )
  {
    v37 = (unsigned int *)((char *)v80 + v35);
  }
  else
  {
    v37 = (unsigned int *)((char *)v80 + _byteswap_ulong(v35));
    v36 = _byteswap_ulong(v36);
  }
  v102 = v37;
  v92 = 0;
  v98 = (unsigned int *)((char *)v80 + v36);
  v38 = 4 * v96;
  v97 = 0;
  v115 = v38;
  v105 = v38;
  v111 = (_DWORD *)a1;
  v113 = v6;
  while ( 2 )
  {
    v39 = 0;
    while ( 2 )
    {
      if ( v81 == -1794895138 )
      {
        if ( v39 )
          v43 = v98[v92];
        else
          v43 = v102[v92];
        v41 = (char *)v80 + v43;
        v42 = *((_DWORD *)v41 + 2) != -1;
      }
      else
      {
        if ( v39 )
          v40 = v98[v92];
        else
          v40 = v102[v92];
        v41 = (char *)v80 + _byteswap_ulong(v40);
        v42 = *((_DWORD *)v41 + 2) != -1;
      }
      a2 = 0;
      if ( v42 )
      {
        v44 = (unsigned int *)(v41 + 4);
        for ( i = 0; ; i = a2 + strlen(*(unsigned int **)&v90[4 * v46]) )
        {
          v46 = v44[1];
          a2 = i + *v44;
          if ( v81 != -1794895138 )
          {
            a2 = i + _byteswap_ulong(*v44);
            v46 = _byteswap_ulong(v46);
          }
          if ( v46 == -1 )
            goto LABEL_104;
          if ( v46 >= v86 )
            break;
          if ( !*(_DWORD *)&v90[4 * v46] )
            goto LABEL_106;
          v44 += 2;
        }
        a1 = (size_t)v111;
        v6 = v113;
        goto LABEL_91;
      }
LABEL_104:
      v123[v39] = a2;
      if ( v39 != 1 )
      {
        v39 = 1;
        continue;
      }
      break;
    }
    ++v97;
    v105 += v123[0] + v123[1];
LABEL_106:
    if ( ++v92 != v94 )
      continue;
    break;
  }
  a2 = v97;
  a1 = (size_t)v111;
  v6 = v113;
  if ( !v97 )
  {
    v111[8] = 0;
    v111[9] = 0;
    v111[10] = 0;
    goto LABEL_109;
  }
  v49 = malloc((const struct timespec *)(v105 + 16 * v97));
  v95 = v49;
  if ( !v49 )
  {
LABEL_39:
    v18 = 0;
    goto LABEL_40;
  }
  v111[4] = v49;
  v112 = 0;
  v117 = &v49[2 * v97];
  v114 = &v117[2 * v97];
  v120 = v6;
  v106 = (char *)v114 + v115;
  v82 = v102;
  v87 = v98;
  v116 = (_DWORD *)a1;
  v50 = v90;
  v119 = &v102[v92];
  do
  {
    v51 = 0;
    v52 = v116[3];
    while ( 1 )
    {
      v53 = v87;
      if ( !v51 )
        v53 = v82;
      v54 = *v53;
      if ( v52 )
        v54 = _byteswap_ulong(v54);
      v55 = (char *)v80 + v54;
      if ( *((_DWORD *)v55 + 2) != -1 )
      {
        for ( j = v55 + 4; ; j += 8 )
        {
          v65 = *((_DWORD *)j + 1);
          v66 = _byteswap_ulong(v65);
          if ( v52 )
            v65 = v66;
          if ( v65 == -1 )
            break;
          if ( !*(_DWORD *)&v50[4 * v65] )
            goto LABEL_243;
        }
      }
      if ( v51 == 1 )
        break;
      v51 = 1;
    }
    v56 = v116[3];
    v93 = v50;
    v109 = 0;
    v57 = v106;
    if ( v52 )
    {
LABEL_219:
      if ( v109 )
      {
        v58 = (unsigned int *)((char *)v80 + _byteswap_ulong(*v87));
        v103 = (char *)v80 + _byteswap_ulong(*v58);
        v107 = (unsigned __int32 *)&v117[2 * v112];
      }
      else
      {
        v58 = (unsigned int *)((char *)v80 + _byteswap_ulong(*v82));
        v103 = (char *)v80 + _byteswap_ulong(*v58);
        v107 = (unsigned __int32 *)&v95[2 * v112];
      }
      v59 = _byteswap_ulong(v58[1]);
      if ( v58[2] != -1 )
        goto LABEL_228;
LABEL_222:
      *v107 = v59;
      v107[1] = (unsigned __int32)v103;
      goto LABEL_223;
    }
    while ( 1 )
    {
      if ( v109 )
      {
        v58 = (unsigned int *)((char *)v80 + *v87);
        v103 = (char *)v80 + *v58;
        v107 = (unsigned __int32 *)&v117[2 * v112];
      }
      else
      {
        v58 = (unsigned int *)((char *)v80 + *v82);
        v103 = (char *)v80 + *v58;
        v107 = (unsigned __int32 *)&v95[2 * v112];
      }
      v59 = v58[1];
      if ( v58[2] == -1 )
        goto LABEL_222;
LABEL_228:
      v60 = v58 + 1;
      v118 = v56;
      v107[1] = (unsigned __int32)v57;
      while ( 1 )
      {
        v62 = *v60;
        v63 = v60[1];
        if ( v118 )
        {
          v62 = _byteswap_ulong(v62);
          v63 = _byteswap_ulong(v63);
        }
        if ( v62 )
        {
          v100 = v62;
          memcpy(v57, v103, v62);
          v103 += v100;
          v57 += v100;
        }
        if ( v63 == -1 )
          break;
        v60 += 2;
        v99 = *(unsigned int **)&v93[4 * v63];
        v61 = strlen(v99);
        v79 = v57;
        v57 += v61;
        memcpy(v79, v99, v61);
      }
      *v107 = (unsigned __int32)&v57[-v107[1]];
LABEL_223:
      if ( v109 == 1 )
        break;
      v109 = 1;
      v56 = v116[3];
      if ( v56 )
        goto LABEL_219;
    }
    v106 = v57;
    v50 = v93;
    ++v112;
LABEL_243:
    ++v82;
    ++v87;
  }
  while ( v119 != v82 );
  a1 = (size_t)v116;
  v67 = v120;
  if ( v97 != v112 )
LABEL_391:
    nl_load_domain_cold_0();
  v68 = v116[11];
  if ( v68 )
  {
    v83 = v116[13];
    v88 = v116[12];
    for ( k = 0; k != v68; ++k )
    {
      v70 = *(_DWORD *)(v88 + 4 * k);
      v71 = _byteswap_ulong(v70);
      if ( v83 )
        v70 = v71;
      v114[k] = v70;
    }
    a1 = (size_t)v116;
    v67 = v120;
  }
  v89 = 0;
  v101 = v67;
  do
  {
    v72 = _hash_string((unsigned __int8 *)v95[2 * v89 + 1]);
    v73 = *(_DWORD *)(a1 + 44);
    v74 = v72 % v73;
    v75 = v72 % (v73 - 2) + 1;
    v76 = v75 - v73;
    while ( 1 )
    {
      v78 = &v114[v74];
      if ( !*v78 )
        break;
      v77 = v74 + v76;
      if ( *(_DWORD *)(a1 + 44) - v75 > v74 )
        v77 = v74 + v75;
      v74 = v77;
    }
    a2 = v89 + 1;
    *v78 = v89 + *(_DWORD *)(a1 + 20) + 1;
    v89 = a2;
  }
  while ( v97 != a2 );
  v6 = v101;
  *(_DWORD *)(a1 + 32) = v97;
  *(_DWORD *)(a1 + 52) = 0;
  *(_DWORD *)(a1 + 36) = v95;
  *(_DWORD *)(a1 + 40) = v117;
  *(_DWORD *)(a1 + 48) = v114;
LABEL_109:
  free(a1, v6, (int)v90);
LABEL_24:
  *(_DWORD *)(a1 + 56) = 0;
  *(_DWORD *)(a1 + 60) = 0;
  msg = (char *)nl_find_msg(a2, v6, a4, byte_80B41F9, 0, v121);
  if ( msg != (char *)-1 )
  {
    _gettext_extract_plural(msg, (unsigned __int8 **)(a1 + 96), (unsigned int *)(a1 + 100));
    v9 = dword_80CF5C8 - 1;
    goto LABEL_26;
  }
  v18 = *(_DWORD *)(a1 + 16);
LABEL_40:
  free(a1, v6, v18);
  if ( v84 )
    munmap(v80, (int)st_size);
  else
    free(a1, v6, (int)v80);
  free(a1, v6, a1);
  v19 = dword_80CF5C8;
  v6[2] = 0;
  v9 = v19 - 1;
LABEL_26:
  v6[1] = 1;
LABEL_27:
  dword_80CF5C8 = v9;
  if ( !v9 )
  {
    dword_80CF5CC = 0;
    if ( __readgsdword(0xCu) )
      __asm { lock }
    if ( --lock_10701 )
      _lll_unlock_wake_private(&lock_10701, a1, v6, (const struct timespec *)a2);
  }
  return __readgsdword(0x14u) ^ v124;
}
// 804C48D: variable 'v5' is possibly undefined
// 8049044: using guessed type void __noreturn nl_load_domain_cold_0(void);
// 80B41F9: using guessed type unsigned __int8 byte_80B41F9[1671];
// 80CE000: using guessed type _TBYTE GLOBAL_OFFSET_TABLE_;
// 80CF5C4: using guessed type int lock_10701;
// 80CF5C8: using guessed type int dword_80CF5C8;
// 80CF5CC: using guessed type int dword_80CF5CC;
// 804C420: using guessed type char var_8C[4];

//----- (0804D970) --------------------------------------------------------
int __cdecl alias_compare(char **a1, unsigned __int8 **a2)
{
  return strcasecmp_l(*a1, *a2, (int)nl_C_locobj);
}
// 80CDF40: using guessed type char **nl_C_locobj[6];

//----- (0804D9A0) --------------------------------------------------------
int __usercall read_alias_file@<eax>(_BYTE *a1@<eax>, unsigned int a2@<edx>)
{
  _BYTE *v2; // ecx
  int v3; // ebx
  _TBYTE *v4; // edi
  _WORD *v5; // eax
  int *v6; // eax
  int *v7; // ebx
  int v8; // eax
  int v9; // edx
  _TBYTE *p_tv_sec; // esi
  int v11; // edx
  unsigned int v12; // eax
  int i; // ecx
  char v15; // dl
  __int16 v16; // cx
  _TBYTE *v17; // edx
  unsigned __int8 v18; // dl
  _BYTE *v19; // ecx
  unsigned int v20; // eax
  unsigned int v21; // eax
  int *v22; // edx
  int v23; // ebx
  _BYTE *v24; // ecx
  _BYTE *v25; // eax
  _BYTE *v26; // edx
  _BYTE *v27; // eax
  _DWORD *v28; // edx
  unsigned int v29; // eax
  unsigned __int8 *v30; // ebx
  int v31; // ecx
  int v32; // ecx
  int *v33; // eax
  _TBYTE *v34; // edx
  _DWORD *v35; // ecx
  int v36; // eax
  int v37; // edx
  int *v38; // eax
  _TBYTE *v39; // ebx
  int v40; // edx
  void *v41; // esp
  int v42; // ecx
  int *v43; // edx
  _TBYTE *v44; // [esp-1010h] [ebp-1204h]
  _BYTE v45[4]; // [esp-1008h] [ebp-11FCh]
  _BYTE v46[4096]; // [esp-1004h] [ebp-11F8h] BYREF
  _DWORD v47[2]; // [esp-4h] [ebp-1F8h] BYREF
  int *v48; // [esp+4h] [ebp-1F0h]
  unsigned int v49; // [esp+8h] [ebp-1ECh]
  int v50; // [esp+Ch] [ebp-1E8h]
  int *v51; // [esp+10h] [ebp-1E4h]
  unsigned int v52; // [esp+14h] [ebp-1E0h]
  _DWORD *v53; // [esp+18h] [ebp-1DCh]
  int v54; // [esp+1Ch] [ebp-1D8h]
  unsigned int v55; // [esp+20h] [ebp-1D4h]
  int v56; // [esp+24h] [ebp-1D0h]
  _TBYTE *v57; // [esp+28h] [ebp-1CCh]
  unsigned int v58; // [esp+2Ch] [ebp-1C8h]
  unsigned __int8 *v59; // [esp+30h] [ebp-1C4h]
  _DWORD *v60; // [esp+34h] [ebp-1C0h]
  struct timespec *v61; // [esp+38h] [ebp-1BCh]
  unsigned __int8 v62; // [esp+48h] [ebp-1ACh] BYREF
  unsigned int v63; // [esp+1D8h] [ebp-1Ch]
  int savedregs; // [esp+1F4h] [ebp+0h] BYREF

  v57 = &GLOBAL_OFFSET_TABLE_;
  v63 = __readgsdword(0x14u);
  v2 = (char *)v47 - ((a2 + 41) & 0xFFFFF000);
  if ( v47 != (_DWORD *)v2 )
  {
    while ( v46 != v2 )
      ;
  }
  v3 = ((_WORD)a2 + 41) & 0xFF0;
  if ( (((_WORD)a2 + 41) & 0xFF0) != 0 )
  {
    v41 = alloca(v3);
    *(_DWORD *)&v45[v3] = *(_DWORD *)&v45[v3];
  }
  v4 = v57;
  v5 = mempcpy(v46, a1, a2);
  *(_DWORD *)v5 = *((_DWORD *)v4 - 44860);
  *((_DWORD *)v5 + 1) = *((_DWORD *)v4 - 44859);
  *((_DWORD *)v5 + 2) = *((_DWORD *)v4 - 44858);
  v5[6] = *((_WORD *)v4 - 89714);
  v6 = fopen((int)&savedregs, (int)v46, (_BYTE *)v4 - 179465);
  v7 = v6;
  v61 = (struct timespec *)v6;
  if ( !v6 )
    return 0;
  v56 = 0;
  v8 = *v6;
  v9 = v8;
  BYTE1(v9) = BYTE1(v8) | 0x80;
  *v7 = v9;
  v59 = &v62;
  v58 = -8;
  if ( (v8 & 0x10) != 0 )
  {
    fclose(v61);
    return v56;
  }
  do
  {
    p_tv_sec = (_TBYTE *)v59;
    if ( !fgets_unlocked(v59, 400, &v61->tv_sec) )
      break;
    v60 = strchr(p_tv_sec, 10);
    LOBYTE(v11) = v62;
    v12 = __readgsdword(v58);
    if ( (*(_BYTE *)(v12 + 2 * v62 + 1) & 0x20) != 0 )
    {
      do
      {
        p_tv_sec = (_TBYTE *)((char *)p_tv_sec + 1);
        v11 = *(unsigned __int8 *)p_tv_sec;
      }
      while ( (*(_BYTE *)(v12 + 2 * v11 + 1) & 0x20) != 0 );
    }
    else
    {
      p_tv_sec = (_TBYTE *)v59;
    }
    if ( !(_BYTE)v11 || (_BYTE)v11 == 35 )
      goto LABEL_12;
    v4 = (_TBYTE *)((char *)p_tv_sec + 1);
    for ( i = *((unsigned __int8 *)p_tv_sec + 1); ; i = *(unsigned __int8 *)v4 )
    {
      v15 = i;
      v16 = *(_WORD *)(v12 + 2 * i) & 0x2000;
      if ( !v15 )
      {
        if ( !v16 )
          goto LABEL_12;
        goto LABEL_22;
      }
      if ( v16 )
        break;
      v4 = (_TBYTE *)((char *)v4 + 1);
    }
    v17 = v4;
    v4 = (_TBYTE *)((char *)v4 + 1);
    v31 = *((unsigned __int8 *)v17 + 1);
    *(_BYTE *)v17 = 0;
    LOBYTE(v17) = v31;
    if ( (*(_BYTE *)(v12 + 2 * v31 + 1) & 0x20) == 0 )
      goto LABEL_23;
    do
    {
LABEL_22:
      v4 = (_TBYTE *)((char *)v4 + 1);
      v17 = (_TBYTE *)*(unsigned __int8 *)v4;
    }
    while ( (*(_BYTE *)(v12 + 2 * (_DWORD)v17 + 1) & 0x20) != 0 );
LABEL_23:
    if ( (_BYTE)v17 )
    {
      v18 = *((_BYTE *)v4 + 1);
      v19 = (char *)v4 + 1;
      if ( v18 )
      {
        while ( (*(_BYTE *)(v12 + 2 * v18 + 1) & 0x20) == 0 )
        {
          v18 = *++v19;
          if ( !*v19 )
            goto LABEL_30;
        }
        if ( v18 == 10 )
          *(_WORD *)v19 = 2560;
        else
          *v19 = 0;
      }
LABEL_30:
      v20 = *((_DWORD *)v57 + 1397);
      v55 = *((_DWORD *)v57 + 1398);
      if ( v55 >= v20 )
      {
        if ( v20 )
        {
          v37 = 2 * v20;
          v36 = 16 * v20;
        }
        else
        {
          v36 = 800;
          v37 = 100;
        }
        v54 = v37;
        v38 = realloc((int)&savedregs, *((_BYTE **)v57 + 2040), (const struct timespec *)v36);
        if ( !v38 )
          break;
        v39 = v57;
        v40 = v54;
        *(_DWORD *)((char *)v57 + (_DWORD)(&map - 33765376)) = v38;
        *(_DWORD *)((char *)v39 + (_DWORD)(&maxmap - 33765376)) = v40;
      }
      v54 = strlen((unsigned int *)p_tv_sec) + 1;
      v52 = strlen((unsigned int *)v4) + 1;
      v51 = (int *)*((_DWORD *)v57 + 1400);
      v50 = (int)v51 + v54;
      v21 = *((_DWORD *)v57 + 1399);
      v49 = (unsigned int)v51 + v54 + v52;
      v22 = (int *)*((_DWORD *)v57 + 2041);
      if ( v49 > v21 )
      {
        v32 = v52 + v54;
        v48 = (int *)*((_DWORD *)v57 + 2041);
        if ( v52 + v54 < 0x400 )
          v32 = 1024;
        v53 = (_DWORD *)(v32 + v21);
        v33 = realloc((int)&savedregs, v22, (const struct timespec *)(v32 + v21));
        if ( !v33 )
          break;
        v23 = *(_DWORD *)((char *)v57 + (_DWORD)(&map - 33765376));
        if ( v33 != v48 && v55 )
        {
          v42 = (char *)v33 - (char *)v48;
          v43 = *(int **)((char *)v57 + (_DWORD)(&map - 33765376));
          v47[1] = (char *)v33 - (char *)v48;
          v48 = (int *)(v23 + 8 * v55);
          do
          {
            *v43 += v42;
            v43[1] += v42;
            v43 += 2;
          }
          while ( v48 != v43 );
        }
        v34 = v57;
        v35 = v53;
        *((_DWORD *)v57 + 2041) = v33;
        *((_DWORD *)v34 + 1399) = v35;
        v22 = v33;
      }
      else
      {
        v23 = *((_DWORD *)v57 + 2040);
      }
      v44 = p_tv_sec;
      v24 = (char *)v51 + (_DWORD)v22;
      p_tv_sec = v57;
      v51 = v22;
      v53 = (_DWORD *)(v23 + 8 * v55);
      v25 = memcpy(v24, v44, v54);
      v26 = (char *)v51 + v50;
      *v53 = v25;
      v27 = memcpy(v26, v4, v52);
      v28 = v60;
      ++v56;
      v53[1] = v27;
      v29 = v55 + 1;
      *((_DWORD *)p_tv_sec + 1400) = v49;
      *((_DWORD *)p_tv_sec + 1398) = v29;
      if ( !v28 )
      {
LABEL_34:
        p_tv_sec = (_TBYTE *)&v61->tv_sec;
        v30 = v59;
        while ( fgets_unlocked(v30, 400, (int *)p_tv_sec) && !strchr(v30, 10) )
          ;
      }
    }
    else
    {
LABEL_12:
      if ( !v60 )
        goto LABEL_34;
    }
  }
  while ( (v61->tv_sec & 0x10) == 0 );
  fclose(v61);
  if ( v56 )
    qsort(
      (int)v57,
      (int)&savedregs,
      (int)v4,
      (int)p_tv_sec,
      *(char **)((char *)v57 + (_DWORD)(&map - 33765376)),
      *(_DWORD *)((char *)v57 + (_DWORD)(&nmap - 33765376)),
      8u,
      (int (__cdecl *)(char *, char *, int))((char *)v57 + (_DWORD)alias_compare - 135061504));
  return v56;
}
// 80CE000: using guessed type _TBYTE GLOBAL_OFFSET_TABLE_;
// 80CF5D4: using guessed type int maxmap;
// 80CF5D8: using guessed type int nmap;
// 80CFFE0: using guessed type int map;

//----- (0804DF20) --------------------------------------------------------
int __usercall nl_expand_alias@<eax>(unsigned int a1@<ebp>, char *a2)
{
  bool v4; // zf
  unsigned int v5; // esi
  char v6; // cl
  char *v7; // edx
  char v8; // al
  char *v9; // ecx
  char *v10; // eax
  char v11; // dl
  char *v12; // ecx
  char v13; // bl
  int v14; // edx
  unsigned int v16; // ebx
  int v17; // eax
  int v18; // [esp+4h] [ebp-24h]

  _ECX = 1;
  _EDI = &GLOBAL_OFFSET_TABLE_;
  v4 = __readgsdword(0xCu) == 0;
  if ( !v4 )
    __asm { lock }
  __asm { cmpxchg [edi+15E4h], ecx }
  if ( !v4 )
    _lll_lock_wait_private(0, (int *)&GLOBAL_OFFSET_TABLE_ + 1401, a1, (int *)&GLOBAL_OFFSET_TABLE_);
  if ( !*((_DWORD *)&GLOBAL_OFFSET_TABLE_ + 1396) )
  {
    _EDI = &GLOBAL_OFFSET_TABLE_;
    *((_DWORD *)&GLOBAL_OFFSET_TABLE_ + 1396) = (char *)&GLOBAL_OFFSET_TABLE_ - 179461;
  }
  v5 = nmap;
  if ( nmap )
    goto LABEL_29;
LABEL_8:
  while ( 1 )
  {
    v6 = 0;
    v7 = (char *)locale_alias_path_10080;
    v8 = *(_BYTE *)locale_alias_path_10080;
    if ( !*(_BYTE *)locale_alias_path_10080 )
      break;
    while ( 1 )
    {
      v9 = v7 + 1;
      if ( v8 != 58 )
        break;
      do
      {
        v10 = v9++;
        v11 = *(v9 - 1);
      }
      while ( v11 == 58 );
      if ( v11 )
        goto LABEL_12;
      v7 = v10;
LABEL_16:
      v8 = *v7;
      v6 = 1;
      if ( !*v7 )
        goto LABEL_17;
    }
    v10 = v7;
LABEL_12:
    v12 = v10 + 1;
    do
    {
      v13 = *v12;
      v7 = v12++;
    }
    while ( v13 && v13 != 58 );
    if ( v7 <= v10 )
      goto LABEL_16;
    _EDI = &GLOBAL_OFFSET_TABLE_;
    *((_DWORD *)&GLOBAL_OFFSET_TABLE_ + 1396) = v7;
    if ( read_alias_file(v10, v7 - v10) )
    {
      v5 = nmap;
      if ( nmap )
      {
LABEL_29:
        a1 = 0;
        v18 = map;
        while ( 1 )
        {
          v16 = (v5 + a1) >> 1;
          _EDI = (_TBYTE *)(v18 + 8 * v16);
          v17 = strcasecmp_l(a2, *(unsigned __int8 **)_EDI, (int)nl_C_locobj);
          if ( v17 >= 0 )
          {
            if ( !v17 )
            {
              v14 = *((_DWORD *)_EDI + 1);
              goto LABEL_20;
            }
            a1 = v16 + 1;
          }
          else
          {
            v5 = (v5 + a1) >> 1;
          }
          if ( v5 <= a1 )
            goto LABEL_8;
        }
      }
    }
  }
LABEL_17:
  if ( v6 )
    locale_alias_path_10080 = (int)v7;
  v14 = 0;
LABEL_20:
  if ( __readgsdword(0xCu) )
    __asm { lock }
  v4 = (*((_DWORD *)&GLOBAL_OFFSET_TABLE_ + 1401))-- == 1;
  if ( !v4 )
    _lll_unlock_wake_private(
      (int *)&GLOBAL_OFFSET_TABLE_ + 1401,
      a1,
      (int *)_EDI,
      (const struct timespec *)&GLOBAL_OFFSET_TABLE_);
  return v14;
}
// 804E017: variable 'v14' is possibly undefined
// 80CDF40: using guessed type char **nl_C_locobj[6];
// 80CE000: using guessed type _TBYTE GLOBAL_OFFSET_TABLE_;
// 80CF5D0: using guessed type int locale_alias_path_10080;
// 80CF5D8: using guessed type int nmap;
// 80CFFE0: using guessed type int map;

//----- (0804E0D0) --------------------------------------------------------
unsigned int **__cdecl nl_make_l10nflist(
        unsigned int ***a1,
        unsigned int *a2,
        unsigned int a3,
        int a4,
        unsigned int *a5,
        unsigned int *a6,
        unsigned int *a7,
        unsigned int *a8,
        unsigned int *a9,
        unsigned int *a10,
        int a11)
{
  int v11; // edi
  int v12; // ebx
  unsigned int v13; // edi
  int v14; // ebp
  unsigned int v15; // edi
  int v16; // ebx
  unsigned int v17; // edi
  int v18; // ebp
  int *v19; // eax
  int *v20; // edi
  unsigned int v21; // ebx
  unsigned int *v22; // ebp
  int v23; // eax
  _BYTE *v24; // eax
  _BYTE *v25; // eax
  _BYTE *v26; // edx
  unsigned int **v27; // ebp
  unsigned int **v28; // ebx
  int v29; // eax
  int v30; // ebx
  unsigned int v31; // esi
  unsigned int *v32; // ebp
  signed int v33; // edx
  int v34; // eax
  int *v35; // eax
  int *v36; // ebp
  unsigned int v37; // ebx
  unsigned int *v38; // edi
  int v39; // eax
  _BOOL4 v40; // eax
  unsigned int v41; // ebx
  unsigned int *v42; // edi
  int v43; // esi
  int v44; // eax
  int v45; // esi
  int v46; // ecx
  int *v47; // eax
  int v48; // ebp
  int *v49; // edx
  int v51; // edi
  int *v52; // esi
  unsigned int *v53; // ebp
  int v54; // eax
  int *v55; // eax
  unsigned int **v56; // [esp+20h] [ebp-2Ch]
  unsigned int *v57; // [esp+20h] [ebp-2Ch]
  char v58; // [esp+24h] [ebp-28h]
  int v59; // [esp+24h] [ebp-28h]
  unsigned int **v60; // [esp+28h] [ebp-24h]
  int v61; // [esp+28h] [ebp-24h]
  int v62; // [esp+2Ch] [ebp-20h]

  v11 = strlen(a5);
  if ( (a4 & 4) != 0 )
    v12 = strlen(a6) + 1;
  else
    v12 = 0;
  v13 = a3 + 2 + v11;
  v14 = 0;
  if ( (a4 & 2) != 0 )
    v14 = strlen(a7) + 1;
  v15 = v12 + v13;
  v16 = 0;
  if ( (a4 & 1) != 0 )
    v16 = strlen(a8) + 1;
  v17 = v14 + v15;
  v18 = 0;
  if ( (a4 & 8) != 0 )
    v18 = strlen(a9) + 1;
  v62 = strlen(a10);
  v19 = malloc((const struct timespec *)(v62 + v17 + v16 + v18));
  v20 = v19;
  if ( !v19 )
    return 0;
  memcpy(v19, a2, a3);
  if ( a3 )
  {
    v21 = a3;
    v22 = (unsigned int *)v20;
    while ( 1 )
    {
      v23 = strlen(v22);
      v21 += ~v23;
      if ( !v21 )
        break;
      v24 = (char *)v22 + v23;
      v22 = (unsigned int *)(v24 + 1);
      *v24 = 58;
    }
  }
  *((_BYTE *)v20 + a3 - 1) = 47;
  v25 = stpcpy((int)v20 + a3, (int)a5);
  if ( (a4 & 4) != 0 )
  {
    *v25 = 95;
    v25 = stpcpy((int)(v25 + 1), (int)a6);
  }
  v26 = v25 + 1;
  if ( (a4 & 2) != 0 )
  {
    *v25 = 46;
    v25 = stpcpy((int)(v25 + 1), (int)a7);
    v26 = v25 + 1;
  }
  if ( (a4 & 1) != 0 )
  {
    *v25 = 46;
    v25 = stpcpy((int)v26, (int)a8);
    v26 = v25 + 1;
  }
  if ( (a4 & 8) != 0 )
  {
    *v25 = 64;
    v25 = stpcpy((int)v26, (int)a9);
    v26 = v25 + 1;
  }
  *v25 = 47;
  memcpy(v26, a10, v62 + 1);
  v60 = *a1;
  if ( *a1 )
  {
    v27 = *a1;
    v28 = 0;
    while ( 1 )
    {
      if ( *v27 )
      {
        v29 = strcmp((char *)*v27, v20);
        if ( !v29 )
          goto LABEL_62;
        if ( v29 < 0 )
        {
LABEL_29:
          v56 = v28;
          goto LABEL_30;
        }
        v28 = v27;
      }
      v27 = (unsigned int **)v27[3];
      if ( !v27 )
        goto LABEL_29;
    }
  }
  v56 = 0;
LABEL_30:
  if ( a11 )
  {
    v30 = 0;
    v31 = a3;
    v32 = a2;
    v33 = (a4 & 0x5555) + ((a4 >> 1) & 0xFFFFD555);
    v58 = ((unsigned __int16)(((v33 & 0x3333)
                             + ((v33 >> 2) & 0xF333)
                             + ((int)((v33 & 0x3333) + ((v33 >> 2) & 0xFFFFF333)) >> 4)) & 0xF0F) >> 8)
        + (((v33 & 0x33) + ((v33 >> 2) & 0x33) + ((int)((v33 & 0x3333) + ((v33 >> 2) & 0xFFFFF333)) >> 4)) & 0xF);
    if ( a3 )
    {
      do
      {
        ++v30;
        v34 = strlen(v32);
        v32 = (unsigned int *)((char *)v32 + v34 + 1);
        v31 += ~v34;
      }
      while ( v31 );
      v35 = malloc((const struct timespec *)(4 * (v30 << v58) + 20));
      v36 = v35;
      if ( v35 )
      {
        *v35 = (int)v20;
        v37 = a3;
        v38 = a2;
        do
        {
          ++v31;
          v39 = strlen(v38);
          v38 = (unsigned int *)((char *)v38 + v39 + 1);
          v37 += ~v39;
        }
        while ( v37 );
        v40 = 1;
        if ( v31 == 1 )
          v40 = (a4 & 3) == 3;
        goto LABEL_38;
      }
    }
    else
    {
      v55 = malloc((const struct timespec *)0x14);
      v36 = v55;
      if ( v55 )
      {
        *v55 = (int)v20;
        v40 = 1;
LABEL_38:
        v36[1] = v40;
        v36[2] = 0;
        if ( v56 )
        {
          v36[3] = (int)v56[3];
          v56[3] = (unsigned int *)v36;
        }
        else
        {
          v36[3] = (int)v60;
          *a1 = (unsigned int **)v36;
        }
        if ( a3 )
        {
          v41 = a3;
          v42 = a2;
          v43 = 0;
          do
          {
            ++v43;
            v44 = strlen(v42);
            v42 = (unsigned int *)((char *)v42 + v44 + 1);
            v41 += ~v44;
          }
          while ( v41 );
          v45 = a4 - (v43 == 1);
        }
        else
        {
          v45 = a4;
        }
        v46 = 0;
        v57 = (unsigned int *)((char *)a2 + a3);
        if ( v45 >= 0 )
        {
          v47 = v36;
          v48 = ~a4;
          v49 = v47;
          do
          {
            if ( (v48 & v45) == 0 )
            {
              v61 = v48;
              v59 = v45;
              v51 = v46;
              v52 = v49;
              while ( a3 )
              {
                v53 = a2;
                while ( 1 )
                {
                  ++v51;
                  v54 = strlen(v53);
                  v52[v51 + 3] = (int)nl_make_l10nflist(a1, v53, v54 + 1, v59, a5, a6, a7, a8, a9, a10, 1);
                  if ( !v53 )
                    break;
                  if ( v53 < v57 )
                  {
                    v53 = (unsigned int *)((char *)v53 + strlen(v53) + 1);
                    if ( v53 < v57 )
                    {
                      if ( v53 )
                        continue;
                    }
                  }
                  goto LABEL_59;
                }
              }
LABEL_59:
              v49 = v52;
              v46 = v51;
              v48 = v61;
              v45 = v59;
            }
            --v45;
          }
          while ( v45 != -1 );
          v36 = v49;
        }
        v36[v46 + 4] = 0;
        return (unsigned int **)v36;
      }
    }
    v36 = 0;
    free(0, v20, (int)v20);
    return (unsigned int **)v36;
  }
  v27 = 0;
LABEL_62:
  free((int)v27, v20, (int)v20);
  return v27;
}

//----- (0804E610) --------------------------------------------------------
int *__cdecl nl_normalize_codeset(unsigned __int8 *a1, unsigned int a2)
{
  int v2; // ecx
  unsigned __int8 *v3; // eax
  int v4; // ebx
  int v5; // edx
  int *v6; // ebx
  int *v7; // edi
  unsigned int v8; // edx
  int v9; // eax
  int *v11; // eax
  int *v12; // eax

  if ( a2 )
  {
    v2 = 0;
    v3 = a1;
    v4 = 1;
    do
    {
      v5 = *v3;
      if ( (byte_80A7940[2 * v5] & 8) != 0 )
      {
        ++v2;
        if ( (unsigned int)(v5 - 48) >= 0xA )
          v4 = 0;
      }
      ++v3;
    }
    while ( &a1[a2] != v3 );
    if ( v4 )
    {
      v11 = malloc((const struct timespec *)(v2 + 4));
      v7 = v11;
      if ( v11 )
      {
        *v11 = 7304041;
        v6 = (int *)((char *)v11 + 3);
        goto LABEL_9;
      }
    }
    else
    {
      v6 = malloc((const struct timespec *)(v2 + 1));
      v7 = v6;
      if ( v6 )
      {
LABEL_9:
        v8 = 0;
        while ( 1 )
        {
          while ( 1 )
          {
            v9 = a1[v8];
            if ( (byte_80A7940[2 * v9 + 1] & 4) == 0 )
              break;
            v6 = (int *)((char *)v6 + 1);
            *((_BYTE *)v6 - 1) = dword_80A6A40[v9];
LABEL_11:
            if ( a2 <= ++v8 )
              goto LABEL_15;
          }
          if ( (unsigned int)(v9 - 48) > 9 )
            goto LABEL_11;
          *(_BYTE *)v6 = a1[v8++];
          v6 = (int *)((char *)v6 + 1);
          if ( a2 <= v8 )
            goto LABEL_15;
        }
      }
    }
    return 0;
  }
  v12 = malloc((const struct timespec *)4);
  v7 = v12;
  if ( !v12 )
    return 0;
  *v12 = 7304041;
  v6 = (int *)((char *)v12 + 3);
LABEL_15:
  *(_BYTE *)v6 = 0;
  return v7;
}
// 80A6A40: using guessed type _DWORD dword_80A6A40[256];
// 80A7940: using guessed type _BYTE byte_80A7940[512];

//----- (0804E760) --------------------------------------------------------
int __cdecl nl_explode_name(
        unsigned __int8 *a1,
        unsigned __int8 **a2,
        _DWORD *a3,
        unsigned __int8 **a4,
        char **a5,
        _DWORD *a6)
{
  unsigned __int8 **v6; // ecx
  char **v7; // edx
  unsigned __int8 v8; // al
  unsigned __int8 *v9; // ebx
  unsigned __int8 v10; // al
  unsigned __int8 *v11; // esi
  int v12; // edi
  unsigned __int8 *v14; // ebx
  unsigned __int8 *v15; // ebx
  int i; // ebp
  int *v17; // ebx
  int v18; // eax

  v6 = a4;
  v7 = a5;
  *a3 = 0;
  *a4 = 0;
  *a5 = 0;
  *a6 = 0;
  *a2 = a1;
  v8 = *a1;
  if ( (*a1 & 0xBF) == 0 || v8 == 95 || v8 == 46 )
  {
LABEL_21:
    v12 = 0;
  }
  else
  {
    v9 = a1;
    while ( 1 )
    {
      v10 = v9[1];
      v11 = v9 + 1;
      if ( !v10 || v10 == 95 )
        break;
      ++v9;
      if ( v10 == 46 || v10 == 64 )
      {
        if ( a1 == v11 )
          goto LABEL_21;
        goto LABEL_10;
      }
    }
    if ( a1 == v11 )
      goto LABEL_21;
    if ( v10 != 95 )
    {
LABEL_10:
      v12 = 0;
      if ( v10 != 46 )
        goto LABEL_11;
      goto LABEL_29;
    }
    v14 = v9 + 2;
    *v11 = 0;
    *a4 = v14;
    v10 = v11[1];
    if ( (v10 & 0xBF) != 0 )
    {
      do
      {
        if ( v10 == 46 )
          break;
        v10 = *++v14;
      }
      while ( (*v14 & 0xBF) != 0 );
    }
    v11 = v14;
    v12 = 4;
    if ( v10 != 46 )
      goto LABEL_11;
LABEL_29:
    v15 = v11 + 1;
    *v11 = 0;
    *a5 = (char *)(v11 + 1);
    v10 = v11[1];
    if ( (v10 & 0xBF) != 0 )
    {
      for ( i = (int)(v11 + 1); ; ++i )
      {
        v11 = (unsigned __int8 *)(i + 1);
        if ( (*(_BYTE *)(i + 1) & 0xBF) == 0 )
          break;
      }
      if ( v15 == v11 )
      {
        v12 |= 2u;
      }
      else
      {
        v17 = nl_normalize_codeset(v15, v11 - v15);
        *a6 = v17;
        if ( !v17 )
          return -1;
        v18 = strcmp(*a5, v17);
        v7 = a5;
        v6 = a4;
        if ( v18 )
        {
          v12 |= 3u;
          v10 = *(_BYTE *)(i + 1);
        }
        else
        {
          free(i, (int *)v12, (int)v17);
          v10 = *(_BYTE *)(i + 1);
          v12 |= 2u;
          v6 = a4;
          v7 = a5;
        }
      }
    }
    else
    {
      v12 |= 2u;
      ++v11;
    }
LABEL_11:
    if ( v10 == 64 )
    {
      *v11 = 0;
      *a3 = v11 + 1;
      if ( v11[1] )
        v12 |= 8u;
    }
  }
  if ( *v6 && !**v6 )
    v12 &= ~4u;
  if ( *v7 && !**v7 )
    return v12 & 0xFFFFFFFD;
  return v12;
}

//----- (0804E970) --------------------------------------------------------
void __usercall _gettext_free_exp(int ebp0@<ebp>, int *a2@<edi>, int *a3)
{
  int v3; // eax

  if ( a3 )
  {
    v3 = *a3;
    if ( *a3 != 2 )
    {
      if ( v3 != 3 )
      {
        if ( v3 != 1 )
        {
LABEL_5:
          free(ebp0, a2, (int)a3);
          return;
        }
LABEL_9:
        _gettext_free_exp(ebp0, a2, (int *)a3[2]);
        goto LABEL_5;
      }
      _gettext_free_exp(ebp0, a2, (int *)a3[4]);
    }
    _gettext_free_exp(ebp0, a2, (int *)a3[3]);
    goto LABEL_9;
  }
}

//----- (0804E9E0) --------------------------------------------------------
int *__usercall new_exp@<eax>(int a1@<eax>, int a2@<edx>, int *a3@<ecx>, int a4@<ebp>)
{
  int v4; // esi
  int *v6; // ecx
  int v7; // eax
  int *result; // eax
  int i; // esi
  int v10; // [esp+0h] [ebp-24h]

  v4 = a1 - 1;
  if ( !a1 )
  {
    result = malloc((const struct timespec *)0x14);
    if ( result )
    {
      *result = 0;
      result[1] = a2;
      return result;
    }
    return 0;
  }
  v6 = (int *)a3[v4];
  if ( !v6 )
    goto LABEL_11;
  a4 = a1;
  v7 = a1 - 1;
  while ( --v7 != -1 )
  {
    if ( !a3[v7] )
      goto LABEL_11;
  }
  v10 = (int)v6;
  result = malloc((const struct timespec *)0x14);
  v6 = (int *)v10;
  if ( !result )
  {
LABEL_11:
    while ( 1 )
    {
      --v4;
      _gettext_free_exp(a4, a3, v6);
      if ( v4 == -1 )
        break;
      v6 = (int *)a3[v4];
    }
    return 0;
  }
  *result = a4;
  result[1] = a2;
  result[v4 + 2] = v10;
  for ( i = v4 - 1; i != -1; --i )
    result[i + 2] = a3[i];
  return result;
}

//----- (0804EAC0) --------------------------------------------------------
int __cdecl _gettextparse(unsigned __int8 **a1)
{
  char *v1; // ebp
  __int16 *v2; // ebx
  int v3; // edx
  char *v4; // esi
  int v5; // eax
  __int16 *v6; // eax
  int v7; // esi
  int v8; // ecx
  int *v9; // eax
  unsigned int v10; // ebx
  unsigned int v11; // esi
  __int16 *v12; // ecx
  int v13; // esi
  int v14; // ecx
  int v15; // eax
  int v16; // ebp
  int v18; // ebx
  unsigned int v19; // edx
  char *v20; // ecx
  unsigned __int8 v21; // al
  unsigned __int8 *v22; // ecx
  int v23; // edx
  int v24; // eax
  __int16 *v25; // [esp+0h] [ebp-510h]
  int v26; // [esp+4h] [ebp-50Ch]
  unsigned int v27; // [esp+8h] [ebp-508h]
  int v28; // [esp+8h] [ebp-508h]
  int v29; // [esp+8h] [ebp-508h]
  unsigned int v30; // [esp+10h] [ebp-500h]
  char *v31; // [esp+14h] [ebp-4FCh]
  int v32; // [esp+1Ch] [ebp-4F4h]
  int v33; // [esp+20h] [ebp-4F0h]
  int v34; // [esp+20h] [ebp-4F0h]
  unsigned __int8 *v35; // [esp+20h] [ebp-4F0h]
  int *v36; // [esp+28h] [ebp-4E8h]
  int v37; // [esp+30h] [ebp-4E0h]
  __int16 v38[200]; // [esp+40h] [ebp-4D0h] BYREF
  char v39[800]; // [esp+1D0h] [ebp-340h] BYREF
  unsigned int v40; // [esp+4F0h] [ebp-20h]

  v1 = v39;
  v40 = __readgsdword(0x14u);
  v31 = v39;
  v32 = 0;
  v26 = -2;
  v30 = 200;
  v25 = v38;
  v38[0] = 0;
  v2 = v38;
  v3 = 0;
  v4 = v39;
  while ( 1 )
  {
    v27 = yypact[v3];
    if ( v27 == -10 )
      break;
    if ( v26 == -2 )
    {
      v35 = *a1;
      v21 = **a1;
      if ( !v21 )
        goto _L64_0;
      if ( v21 == 9 || v21 == 32 )
      {
        v22 = *a1;
        while ( 1 )
        {
          v21 = *++v22;
          if ( !*v22 )
            break;
          if ( v21 != 32 && v21 != 9 )
          {
            v35 = v22;
            goto LABEL_54;
          }
        }
        v35 = v22;
_L64_0:
        v26 = 0;
        *a1 = v35;
        v5 = 0;
        goto LABEL_7;
      }
LABEL_54:
      if ( v21 <= 0x7Cu )
        __asm { jmp     ebp }
      v26 = 256;
      *a1 = v35 + 1;
      v5 = 1;
    }
    else
    {
      if ( v26 <= 0 )
      {
        v5 = 0;
        v26 = 0;
        goto LABEL_7;
      }
      v5 = (unsigned __int8)yytranslate[v26];
    }
    v27 += v5;
LABEL_7:
    v1 = (char *)v27;
    if ( v27 > 0x36 || yycheck[v27] != v5 )
      break;
    v3 = (unsigned __int8)yytable[v27];
    if ( yytable[v27] )
    {
      v26 = -2;
      v4 += 4;
      v32 = (v32 == 0) + v32 - 1;
      *(_DWORD *)v4 = v37;
      v6 = v2;
      goto LABEL_11;
    }
    v20 = v4;
    v29 = -16;
    v16 = *((_DWORD *)v4 + 1);
    v6 = v2;
LABEL_41:
    v18 = *v6;
    v4 = v20 + 4;
    *((_DWORD *)v20 + 1) = v16;
    v19 = v18 + v3;
    if ( v19 <= 0x36 && (_WORD)v18 == yycheck[v19] )
      v3 = (unsigned __int8)yytable[v19];
    else
      v3 = yydefgoto[v29];
LABEL_11:
    v1 = (char *)v30;
    v2 = v6 + 1;
    v6[1] = v3;
    if ( v6 + 1 >= &v25[v30 - 1] )
    {
      v28 = v3;
      v7 = v2 - v25 + 1;
      if ( v30 > 0x270F )
        goto LABEL_59;
      v8 = 10000;
      if ( 2 * v30 <= 0x2710 )
        v8 = 2 * v30;
      v30 = v8;
      v33 = v8;
      v1 = (char *)(2 * v8);
      v9 = malloc((const struct timespec *)(6 * v8 + 3));
      if ( !v9 )
      {
LABEL_59:
        v2 = v25;
        v13 = 2;
        goto LABEL_37;
      }
      v10 = v7;
      v11 = 4 * v7;
      v36 = v9;
      memcpy(v9, v25, v10 * 2);
      v1 = (char *)v36 + ((unsigned int)(v1 + 3) & 0xFFFFFFFC);
      memcpy(v1, v31, v11);
      v12 = (__int16 *)v36;
      v3 = v28;
      if ( v25 != v38 )
      {
        free((int)v1, (int *)&GLOBAL_OFFSET_TABLE_, (int)v25);
        v12 = (__int16 *)v36;
        v3 = v28;
      }
      v4 = &v1[v11 - 4];
      v2 = &v12[v10 - 1];
      if ( v2 >= &v12[v33 - 1] )
      {
        v2 = v12;
        v13 = 1;
        goto LABEL_38;
      }
      v31 = v1;
      v25 = v12;
    }
    if ( v3 == 9 )
    {
      v2 = v25;
      v13 = 0;
      goto LABEL_37;
    }
  }
  v14 = (unsigned __int8)yydefact[v3];
  if ( yydefact[v3] )
  {
    v34 = (unsigned __int8)yyr2[v14];
    v16 = *(_DWORD *)&v4[4 * (1 - v34)];
    if ( (unsigned __int8)v14 <= 0xDu )
      __asm { jmp     edx }
    v23 = (unsigned __int8)yyr1[v14];
    v24 = v23 - 16;
    v3 = byte_80A25EA[v23];
    v29 = v24;
    v20 = &v4[-4 * v34];
    v6 = &v2[-v34];
    goto LABEL_41;
  }
  if ( v32 != 3 )
    goto LABEL_26;
  if ( v26 > 0 )
  {
    v1 = (char *)v25;
    v26 = -2;
    goto LABEL_29;
  }
  if ( !v26 )
  {
    v13 = 1;
    v2 = v25;
  }
  else
  {
LABEL_26:
    v1 = (char *)v25;
    while ( 1 )
    {
LABEL_29:
      v15 = yypact[v3];
      if ( v15 != -10 && (unsigned int)(v15 + 1) <= 0x36 && byte_80A2581[v15] == 1 )
      {
        v3 = (unsigned __int8)byte_80A25C1[v15];
        if ( byte_80A25C1[v15] )
        {
          v25 = (__int16 *)v1;
          v4 += 4;
          v32 = 3;
          *(_DWORD *)v4 = v37;
          v6 = v2;
          goto LABEL_11;
        }
      }
      if ( v2 == (__int16 *)v1 )
        break;
      v3 = *--v2;
      v4 -= 4;
    }
    v13 = 1;
  }
LABEL_37:
  if ( v2 == v38 )
    return v13;
LABEL_38:
  free((int)v1, (int *)&GLOBAL_OFFSET_TABLE_, (int)v2);
  return v13;
}
// 804EBC1: variable 'v37' is possibly undefined
// 80CE000: using guessed type _TBYTE GLOBAL_OFFSET_TABLE_;

//----- (0804F370) --------------------------------------------------------
unsigned int __cdecl _gettext_extract_plural(char *a1, unsigned __int8 **a2, unsigned int *a3)
{
  char *v3; // eax
  unsigned __int8 *v4; // ebx
  unsigned __int8 v5; // al
  unsigned int v6; // ecx
  unsigned int v7; // eax
  char *v9; // [esp+0h] [ebp-30h]
  unsigned __int8 *v10; // [esp+4h] [ebp-2Ch] BYREF
  unsigned __int8 *v11[2]; // [esp+8h] [ebp-28h] BYREF
  unsigned int v12; // [esp+10h] [ebp-20h]

  v12 = __readgsdword(0x14u);
  if ( !a1 )
    goto LABEL_12;
  v9 = strstr(a1, (unsigned int *)((char *)&GLOBAL_OFFSET_TABLE_ - 178361));
  v3 = strstr(a1, (unsigned int *)((char *)&GLOBAL_OFFSET_TABLE_ - 178353));
  if ( !v9 )
    goto LABEL_12;
  if ( !v3 )
    goto LABEL_12;
  v4 = (unsigned __int8 *)(v3 + 9);
  v5 = v3[9];
  if ( !v5 )
    goto LABEL_12;
  v6 = __readgsdword(0xFFFFFFF8);
  while ( (*(_BYTE *)(v6 + 2 * v5 + 1) & 0x20) != 0 )
  {
    v5 = *++v4;
    if ( !*v4 )
      goto LABEL_12;
  }
  if ( (unsigned __int8)(v5 - 48) <= 9u
    && (v7 = strtoul(v4, &v10, 10), v10 != v4)
    && (*a3 = v7, v11[0] = (unsigned __int8 *)(v9 + 7), !_gettextparse(v11)) )
  {
    *a2 = v11[1];
  }
  else
  {
LABEL_12:
    *a2 = (unsigned __int8 *)&GLOBAL_OFFSET_TABLE_ - 6464;
    *a3 = 2;
  }
  return __readgsdword(0x14u) ^ v12;
}
// 80CE000: using guessed type _TBYTE GLOBAL_OFFSET_TABLE_;

//----- (0804F478) --------------------------------------------------------
void _x86_get_pc_thunk_bp()
{
  ;
}

//----- (0804F480) --------------------------------------------------------
unsigned int __cdecl _hash_string(unsigned __int8 *a1)
{
  unsigned int result; // eax
  int v3; // edx

  result = 0;
  while ( 1 )
  {
    v3 = *a1;
    if ( !(_BYTE)v3 )
      break;
    while ( 1 )
    {
      ++a1;
      result = v3 + 16 * result;
      if ( (result & 0xF0000000) == 0 )
        break;
      result = ((result & 0xF0000000) >> 24) ^ result & 0xFFFFFFF;
      v3 = *a1;
      if ( !(_BYTE)v3 )
        return result;
    }
  }
  return result;
}

//----- (0804F4C0) --------------------------------------------------------
int setjmp(jmp_buf env)
{
  int v1; // ebx
  int v2; // ebp
  int v3; // edi
  int v4; // esi
  int result; // eax
  struct __jmp_buf_tag *__attribute__((__org_typedef(jmp_buf))) v6; // edx
  unsigned int retaddr; // [esp+0h] [ebp+0h]

  result = 0;
  v6 = env;
  env->__jmpbuf[0] = v1;
  v6->__jmpbuf[1] = v4;
  v6->__jmpbuf[2] = v3;
  v6->__jmpbuf[4] = __ROL4__(__readgsdword(0x18u) ^ (unsigned int)&env, 9);
  v6->__jmpbuf[5] = __ROL4__(__readgsdword(0x18u) ^ retaddr, 9);
  v6->__jmpbuf[3] = v2;
  v6->__mask_was_saved = 0;
  __asm { rdsspd  ecx }
  v6->__saved_mask.__val[3] = _ECX;
  return result;
}
// 804F4CA: variable 'v1' is possibly undefined
// 804F4CC: variable 'v4' is possibly undefined
// 804F4CF: variable 'v3' is possibly undefined
// 804F4F4: variable 'v2' is possibly undefined

//----- (0804F510) --------------------------------------------------------
_BYTE *__usercall msort_with_tmp_part_0@<eax>(unsigned int *a1@<eax>, _BYTE *a2@<edx>, unsigned int a3@<ecx>)
{
  unsigned int v5; // ecx
  _BYTE *v6; // ebp
  _BYTE *v7; // edi
  unsigned int v8; // eax
  bool v9; // dl
  _DWORD *v10; // esi
  int *v11; // edi
  _DWORD *v12; // ebp
  _BYTE *v13; // eax
  _BYTE *v15; // esi
  _WORD *v16; // eax
  _WORD *v17; // eax
  unsigned int v18; // edx
  _BYTE *v19; // ecx
  unsigned int v20; // ebp
  _DWORD *v21; // esi
  int v22; // eax
  int *v23; // edi
  _BYTE *v24; // eax
  int v25; // eax
  int v26; // edx
  unsigned int v27; // [esp+0h] [ebp-48h]
  unsigned int v28; // [esp+4h] [ebp-44h]
  int (__cdecl *v29)(_DWORD *, _DWORD *, unsigned int); // [esp+8h] [ebp-40h]
  unsigned int v30; // [esp+Ch] [ebp-3Ch]
  unsigned int v31; // [esp+10h] [ebp-38h]
  _BYTE *v32; // [esp+14h] [ebp-34h]
  _DWORD *v35; // [esp+20h] [ebp-28h]
  unsigned int v36; // [esp+24h] [ebp-24h]

  v5 = a3 >> 1;
  v28 = v5;
  v27 = a3 - v5;
  v6 = &a2[v5 * *a1];
  if ( a3 > 3 )
    msort_with_tmp_part_0(a1, a2, v5);
  if ( v27 > 1 )
    msort_with_tmp_part_0(a1, v6, v27);
  v7 = (_BYTE *)a1[4];
  v31 = *a1;
  v29 = (int (__cdecl *)(_DWORD *, _DWORD *, unsigned int))a1[2];
  v30 = a1[3];
  v8 = a1[1];
  v9 = v27 != 0 && v28 != 0;
  if ( v8 == 1 )
  {
    v32 = a2;
    v15 = a2;
    if ( v9 )
    {
      do
      {
        if ( v29(v15, v6, v30) > 0 )
        {
          --v27;
          v25 = *(_DWORD *)v6;
          v6 += 8;
          v26 = *((_DWORD *)v6 - 1);
        }
        else
        {
          v25 = *(_DWORD *)v15;
          v26 = *((_DWORD *)v15 + 1);
          v15 += 8;
          --v28;
        }
        *(_DWORD *)v7 = v25;
        v7 += 8;
        *((_DWORD *)v7 - 1) = v26;
      }
      while ( v28 && v27 );
      goto LABEL_24;
    }
  }
  else if ( v8 )
  {
    if ( v8 != 2 )
    {
      if ( v8 == 3 )
      {
        v32 = a2;
        if ( !v9 )
          goto LABEL_17;
        v10 = a2;
        v11 = (int *)v6;
        v12 = (_DWORD *)a1[4];
        do
        {
          if ( v29((_DWORD *)*v10, (_DWORD *)*v11, v30) > 0 )
          {
            --v27;
            v13 = (_BYTE *)*v11++;
          }
          else
          {
            v13 = (_BYTE *)*v10;
            --v28;
            ++v10;
          }
          *v12++ = v13;
        }
        while ( v28 && v27 );
        goto LABEL_16;
      }
      v15 = a2;
LABEL_20:
      if ( v28 )
      {
        while ( v27 )
        {
          if ( v29(v15, v6, v30) <= 0 )
          {
            v17 = mempcpy(v7, v15, v31);
            v15 += v31;
            --v28;
            v7 = v17;
            goto LABEL_20;
          }
          v16 = mempcpy(v7, v6, v31);
          v6 += v31;
          --v27;
          v7 = v16;
        }
      }
LABEL_24:
      v32 = v15;
      if ( !v28 )
        return memcpy(a2, (_BYTE *)a1[4], v31 * (a3 - v27));
LABEL_25:
      memcpy(v7, v32, v31 * v28);
      return memcpy(a2, (_BYTE *)a1[4], v31 * (a3 - v27));
    }
    v18 = *a1;
    v19 = v6;
    v32 = a2;
    while ( v28 && v27 )
    {
      v36 = v18;
      v20 = (unsigned int)&v7[v18];
      v21 = v32;
      v35 = v19;
      v22 = v29(v32, v19, v30);
      v19 = v35;
      v18 = v36;
      if ( v22 <= 0 )
      {
        --v28;
        v32 += v36;
      }
      else
      {
        --v27;
        v21 = v35;
        v19 = (char *)v35 + v36;
      }
      if ( v20 > v20 - v36 )
      {
        do
        {
          *(_DWORD *)v7 = *v21++;
          v7 += 4;
        }
        while ( v20 > (unsigned int)v7 );
      }
      v7 = (_BYTE *)v20;
    }
  }
  else
  {
    if ( v9 )
    {
      v10 = a2;
      v23 = (int *)v6;
      v12 = (_DWORD *)a1[4];
      do
      {
        if ( v29(v10, v23, v30) > 0 )
        {
          --v27;
          v24 = (_BYTE *)*v23++;
        }
        else
        {
          v24 = (_BYTE *)*v10;
          --v28;
          ++v10;
        }
        *v12++ = v24;
      }
      while ( v28 && v27 );
LABEL_16:
      v32 = v10;
      v7 = v12;
      goto LABEL_17;
    }
    v32 = a2;
  }
LABEL_17:
  if ( v28 )
    goto LABEL_25;
  return memcpy(a2, (_BYTE *)a1[4], v31 * (a3 - v27));
}
// 804F6AA: conditional instruction was optimized away because %var_44.4!=0

//----- (0804F890) --------------------------------------------------------
unsigned int __usercall qsort_r@<eax>(
        int a1@<ebx>,
        int a2@<ebp>,
        int a3@<edi>,
        int a4@<esi>,
        char *a5,
        unsigned int a6,
        unsigned int a7,
        int (__cdecl *a8)(char *, char *, int),
        int a9)
{
  unsigned int v9; // edi
  unsigned int v10; // ebx
  int *v11; // edx
  int v12; // eax
  void *v13; // esp
  unsigned int v14; // ecx
  int *v15; // eax
  unsigned int v16; // eax
  _BYTE *v17; // ebx
  char *v18; // ecx
  int *v19; // edx
  _BYTE *v20; // esi
  int v21; // edi
  _BYTE *v22; // ecx
  unsigned int v23; // ebx
  int *v24; // edx
  int v26; // eax
  int v27; // edx
  _BYTE v29[15]; // [esp+4h] [ebp-105Ch] BYREF
  int v30; // [esp+1004h] [ebp-5Ch] BYREF
  int *v31; // [esp+1008h] [ebp-58h]
  _BYTE *v32; // [esp+100Ch] [ebp-54h]
  char *v33; // [esp+1010h] [ebp-50h]
  unsigned int v34; // [esp+1014h] [ebp-4Ch]
  _TBYTE *v35; // [esp+1018h] [ebp-48h]
  int v36; // [esp+101Ch] [ebp-44h]
  int *v37; // [esp+1020h] [ebp-40h]
  unsigned int v38; // [esp+102Ch] [ebp-34h] BYREF
  int v39; // [esp+1030h] [ebp-30h]
  int (__cdecl *v40)(char *, char *, int); // [esp+1034h] [ebp-2Ch]
  int v41; // [esp+1038h] [ebp-28h]
  int *v42; // [esp+103Ch] [ebp-24h]
  unsigned int v43; // [esp+1040h] [ebp-20h]
  int v44; // [esp+1050h] [ebp-10h]
  int v45; // [esp+1054h] [ebp-Ch]
  int v46; // [esp+1058h] [ebp-8h]
  int v47; // [esp+105Ch] [ebp-4h] BYREF

  v47 = a2;
  v46 = a3;
  v45 = a4;
  v44 = a1;
  v9 = a9;
  v35 = &GLOBAL_OFFSET_TABLE_;
  v33 = a5;
  v43 = __readgsdword(0x14u);
  if ( a7 > 0x20 )
    v10 = a7 + 8 * a6;
  else
    v10 = a7 * a6;
  if ( v10 > 0x3FF )
  {
    v14 = *(_DWORD *)((char *)v35 + (_DWORD)(&pagesize_8656 - 33765376));
    if ( !v14 )
    {
      v26 = sysconf(85);
      v27 = 0x1FFFFFFF;
      if ( v26 != -1 )
        v27 = v26 / 4;
      *(_DWORD *)((char *)v35 + (_DWORD)(&phys_pages_8655 - 33765376)) = v27;
      v14 = sysconf(30);
      *(_DWORD *)((char *)v35 + (_DWORD)(&pagesize_8656 - 33765376)) = v14;
    }
    if ( v10 / v14 > *((_DWORD *)v35 + 1407)
      || (v36 = -32,
          v37 = (int *)__readgsdword(0xFFFFFFE0),
          v15 = malloc((const struct timespec *)v10),
          v31 = v15,
          __writegsdword(0xFFFFFFE0, (unsigned int)v37),
          !v15) )
    {
      quicksort(v33, a6, a7, a8, a9);
      return __readgsdword(0x14u) ^ v43;
    }
    v42 = v15;
  }
  else
  {
    v11 = (int *)((char *)&v30 - ((v10 + 27) & 0xFFFFF000));
    if ( &v30 != v11 )
    {
      while ( v29 != (_BYTE *)v11 )
        ;
    }
    v12 = ((_WORD)v10 + 27) & 0xFF0;
    if ( (((_WORD)v10 + 27) & 0xFF0) != 0 )
    {
      v13 = alloca(v12);
      *(_DWORD *)&v29[v12 - 4] = *(_DWORD *)&v29[v12 - 4];
    }
    v31 = 0;
    v42 = (int *)v29;
  }
  v39 = 4;
  v40 = a8;
  v38 = a7;
  v41 = a9;
  if ( a7 <= 0x20 )
  {
    if ( (a7 & 3) == 0 && ((unsigned __int8)v33 & 3) == 0 )
    {
      if ( a7 == 4 )
      {
        v39 = 0;
      }
      else if ( a7 != 8 || ((unsigned __int8)v33 & 7) != 0 )
      {
        v39 = 2;
      }
      else
      {
        v39 = 1;
      }
    }
    if ( a6 > 1 )
      msort_with_tmp_part_0(&v38, v33, a6);
    goto LABEL_35;
  }
  v16 = (unsigned int)&v42[a6];
  v17 = (_BYTE *)(v16 + 4 * a6);
  v37 = (int *)v16;
  v32 = v17;
  if ( v16 >= (unsigned int)v17 )
  {
    v19 = v37;
  }
  else
  {
    v18 = v33;
    do
    {
      v16 += 4;
      *(_DWORD *)(v16 - 4) = v18;
      v18 += a7;
    }
    while ( (unsigned int)v17 > v16 );
    v19 = &v42[a6];
  }
  v38 = 4;
  v39 = 3;
  if ( a6 > 1 )
  {
    msort_with_tmp_part_0(&v38, v19, a6);
    goto LABEL_20;
  }
  if ( a6 )
  {
LABEL_20:
    v34 = 0;
    v36 = (int)v33;
    do
    {
      v20 = (_BYTE *)v37[v34];
      if ( v20 != (_BYTE *)v36 )
      {
        v21 = v36;
        memcpy(v32, (_BYTE *)v36, a7);
        v22 = (_BYTE *)v21;
        v23 = v34;
        while ( 1 )
        {
          v9 = (v20 - v33) / a7;
          v37[v23] = (int)v22;
          memcpy(v22, v20, a7);
          v23 = v9;
          v22 = v20;
          v24 = &v37[v9];
          if ( *v24 == v36 )
            break;
          v20 = (_BYTE *)*v24;
        }
        *v24 = (int)v20;
        memcpy(v20, v32, a7);
      }
      ++v34;
      v36 += a7;
    }
    while ( a6 > v34 );
  }
LABEL_35:
  free((int)&v47, (int *)v9, (int)v31);
  return __readgsdword(0x14u) ^ v43;
}
// 804F890: could not find valid save-restore pair for ebx
// 804F890: could not find valid save-restore pair for ebp
// 804F890: could not find valid save-restore pair for edi
// 804F890: could not find valid save-restore pair for esi
// 80CE000: using guessed type _TBYTE GLOBAL_OFFSET_TABLE_;
// 80CF5FC: using guessed type int phys_pages_8655;
// 80CF600: using guessed type int pagesize_8656;

//----- (0804FBE0) --------------------------------------------------------
unsigned int __usercall qsort@<eax>(
        int a1@<ebx>,
        int a2@<ebp>,
        int a3@<edi>,
        int a4@<esi>,
        char *a5,
        unsigned int a6,
        unsigned int a7,
        int (__cdecl *a8)(char *, char *, int))
{
  return qsort_r(a1, a2, a3, a4, a5, a6, a7, a8, 0);
}

//----- (0804FC10) --------------------------------------------------------
int __cdecl getenv(__int16 *a1)
{
  _DWORD *v1; // edi
  int v2; // ebx
  __int16 v3; // ax
  __int16 v5; // bp
  int v6; // [esp+4h] [ebp-20h]

  v1 = environ;
  if ( !environ || !*(_BYTE *)a1 )
    return 0;
  v2 = *environ;
  if ( *((_BYTE *)a1 + 1) )
  {
    v5 = *a1;
    v6 = strlen((unsigned int *)a1);
    if ( v2 )
    {
      while ( v5 != *(_WORD *)v2
           || strncmp((unsigned __int8 *)(v2 + 2), (unsigned __int8 *)a1 + 2, v6 - 2)
           || *(_BYTE *)(v2 + v6) != 61 )
      {
        v2 = *++v1;
        if ( !*v1 )
          return v2;
      }
      v2 += v6 + 1;
    }
  }
  else
  {
    HIBYTE(v3) = 61;
    if ( v2 )
    {
      while ( 1 )
      {
        LOBYTE(v3) = *(_BYTE *)a1;
        if ( v3 == *(_WORD *)v2 )
          break;
        v2 = *++v1;
        if ( !*v1 )
          return v2;
      }
      v2 += 2;
    }
  }
  return v2;
}
// 80CF89C: using guessed type _DWORD *environ;

//----- (0804FCF0) --------------------------------------------------------
void __usercall __noreturn _run_exit_handlers(int *a1@<edi>, int status, int a3, int a4)
{
  bool v6; // zf
  _DWORD *v7; // edx
  bool v9; // zf
  int v10; // ecx
  int v11; // ebx
  int *v12; // edi
  _DWORD *v13; // ecx
  int v14; // eax
  int v15; // eax
  int v16; // eax
  int (**v17)(); // ebx
  _DWORD *v18; // [esp+0h] [ebp-24h]
  _DWORD *v19; // [esp+0h] [ebp-24h]
  _DWORD *v20; // [esp+0h] [ebp-24h]

  _ESI = &_exit_funcs_lock;
  while ( 1 )
  {
    _ECX = 1;
    v6 = __readgsdword(0xCu) == 0;
    if ( !v6 )
      __asm { lock }
    __asm { cmpxchg [esi], ecx }
    if ( !v6 )
      _lll_lock_wait_private(0, &_exit_funcs_lock.tv_sec, (int)&GLOBAL_OFFSET_TABLE_, a1);
LABEL_6:
    v7 = *(_DWORD **)a3;
    if ( !*(_DWORD *)a3 )
    {
      *((_BYTE *)&GLOBAL_OFFSET_TABLE_ + 5636) = 1;
      if ( __readgsdword(0xCu) )
        __asm { lock }
      if ( --_exit_funcs_lock.tv_sec )
        _lll_unlock_wake_private(&_exit_funcs_lock.tv_sec, (int)&GLOBAL_OFFSET_TABLE_, a1, &_exit_funcs_lock);
      if ( (_BYTE)a4 )
      {
        v17 = &_start___libc_atexit;
        if ( &_start___libc_atexit < (int (**)())&edata )
        {
          do
            (*v17++)();
          while ( v17 != &_start___libc_atexit
                       + ((unsigned int)((_UNKNOWN *)((char *)&edata - 1) - (_UNKNOWN *)&_start___libc_atexit) >> 2)
                       + 1 );
        }
      }
      exit(status);
    }
    while ( 1 )
    {
      v10 = v7[1];
      if ( !v10 )
        break;
      v11 = *((_DWORD *)&GLOBAL_OFFSET_TABLE_ + 1976);
      v12 = (int *)*((_DWORD *)&GLOBAL_OFFSET_TABLE_ + 1977);
      v7[1] = v10 - 1;
      if ( __readgsdword(0xCu) )
        __asm { lock }
      if ( --_exit_funcs_lock.tv_sec )
        _lll_unlock_wake_private(&_exit_funcs_lock.tv_sec, (int)&GLOBAL_OFFSET_TABLE_, v12, &_exit_funcs_lock);
      v13 = &v7[4 * v10];
      v14 = *(v13 - 2);
      switch ( v14 )
      {
        case 3:
          v19 = v7;
          ((void (*)(void))(__readgsdword(0x18u) ^ __ROR4__(*(v13 - 1), 9)))();
          v7 = v19;
          break;
        case 4:
          v18 = v7;
          v15 = *(v13 - 1);
          *(v13 - 2) = 0;
          ((void (__cdecl *)(_DWORD, int))(__readgsdword(0x18u) ^ __ROR4__(v15, 9)))(*v13, status);
          v7 = v18;
          break;
        case 2:
          v20 = v7;
          ((void (__cdecl *)(int, _DWORD))(__readgsdword(0x18u) ^ __ROR4__(*(v13 - 1), 9)))(status, *v13);
          v7 = v20;
          break;
      }
      _ECX = 1;
      v9 = __readgsdword(0xCu) == 0;
      if ( !v9 )
        __asm { lock }
      __asm { cmpxchg [esi], ecx }
      if ( !v9 )
        _lll_lock_wait_private(0, &_exit_funcs_lock.tv_sec, (int)&GLOBAL_OFFSET_TABLE_, v12);
      a1 = (int *)(*((_DWORD *)&GLOBAL_OFFSET_TABLE_ + 1976) ^ v11 | *((_DWORD *)&GLOBAL_OFFSET_TABLE_ + 1977) ^ (unsigned int)v12);
      if ( a1 )
        goto LABEL_6;
    }
    v16 = *v7;
    *(_DWORD *)a3 = *v7;
    if ( v16 )
      free((int)&GLOBAL_OFFSET_TABLE_, a1, (int)v7);
    if ( __readgsdword(0xCu) )
      __asm { lock }
    if ( --_exit_funcs_lock.tv_sec )
      _lll_unlock_wake_private(&_exit_funcs_lock.tv_sec, (int)&GLOBAL_OFFSET_TABLE_, a1, &_exit_funcs_lock);
  }
}
// 804FE30: variable 'v7' is possibly undefined
// 804FDCB: variable 'v10' is possibly undefined
// 80CE000: using guessed type _TBYTE GLOBAL_OFFSET_TABLE_;
// 80CF2F4: using guessed type int (*_start___libc_atexit)();
// 80CFED8: using guessed type struct timespec _exit_funcs_lock;

//----- (0804FF10) --------------------------------------------------------
void __usercall __noreturn exit(int *a1@<edi>, int status)
{
  _run_exit_handlers(a1, status, (int)&_exit_funcs, 1);
}
// 80CE02C: using guessed type void *_exit_funcs;

//----- (0804FF40) --------------------------------------------------------
char *__cdecl _new_exitfn(int **a1)
{
  int *v1; // edi
  char *v2; // esi
  char *v3; // ebp
  int v4; // eax
  int v5; // edx
  int v6; // eax
  char *result; // eax

  if ( _exit_funcs_done )
    return 0;
  v1 = *a1;
  if ( !*a1 )
    _assert_fail((int)"l != NULL", (int)"cxa_atexit.c", 108, (int)"__new_exitfn");
  v2 = (char *)*a1;
  v3 = 0;
  while ( 1 )
  {
    v4 = *((_DWORD *)v2 + 1);
    if ( !v4 )
      goto LABEL_10;
    v5 = v4 - 1;
    if ( *(_DWORD *)&v2[16 * v4 - 8] )
      break;
    while ( v5 )
    {
      if ( *(_DWORD *)&v2[16 * v5 - 8] )
        goto LABEL_12;
      --v5;
    }
LABEL_10:
    v6 = *(_DWORD *)v2;
    *((_DWORD *)v2 + 1) = 0;
    v3 = v2;
    if ( !v6 )
      goto LABEL_18;
    v2 = (char *)v6;
  }
  v5 = *((_DWORD *)v2 + 1);
LABEL_12:
  if ( v5 != 32 )
  {
    *((_DWORD *)v2 + 1) = v5 + 1;
    result = &v2[16 * v5 + 8];
LABEL_14:
    *(_DWORD *)result = 1;
    ++_new_exitfn_called;
    return result;
  }
  v2 = v3;
  if ( v3 )
  {
LABEL_18:
    result = v2 + 8;
    *((_DWORD *)v2 + 1) = 1;
    goto LABEL_14;
  }
  v2 = (char *)calloc(v1, 1u, 0x208u);
  if ( v2 )
  {
    *(_DWORD *)v2 = v1;
    *a1 = (int *)v2;
    goto LABEL_18;
  }
  return 0;
}
// 80CF604: using guessed type char _exit_funcs_done;
// 80CFEE0: using guessed type __int64 _new_exitfn_called;

//----- (08050050) --------------------------------------------------------
int __usercall _internal_atexit@<eax>(
        int a1@<ebp>,
        int *a2@<edi>,
        const struct timespec *a3@<esi>,
        int a4,
        int a5,
        int a6,
        int **a7)
{
  bool v9; // zf
  char *v10; // eax

  _ECX = 1;
  _EBX = &_exit_funcs_lock;
  v9 = __readgsdword(0xCu) == 0;
  if ( !v9 )
    __asm { lock }
  __asm { cmpxchg [ebx], ecx }
  if ( !v9 )
    _lll_lock_wait_private(0, &_exit_funcs_lock.tv_sec, a1, a2);
  v10 = _new_exitfn(a7);
  if ( v10 )
  {
    *(_DWORD *)v10 = 4;
    *((_DWORD *)v10 + 1) = __ROL4__(__readgsdword(0x18u) ^ a4, 9);
    *((_DWORD *)v10 + 2) = a5;
    *((_DWORD *)v10 + 3) = a6;
    if ( __readgsdword(0xCu) )
      __asm { lock }
    if ( --_exit_funcs_lock.tv_sec )
      _lll_unlock_wake_private(&_exit_funcs_lock.tv_sec, a1, a2, a3);
    return 0;
  }
  else
  {
    if ( __readgsdword(0xCu) )
      __asm { lock }
    if ( --_exit_funcs_lock.tv_sec )
      _lll_unlock_wake_private(&_exit_funcs_lock.tv_sec, a1, a2, a3);
    return -1;
  }
}
// 80CFED8: using guessed type struct timespec _exit_funcs_lock;

//----- (08050100) --------------------------------------------------------
int __cdecl _cxa_atexit(void (__cdecl *lpfunc)(void *), void *obj, void *lpdso_handle)
{
  int v3; // ebp
  int *v4; // edi
  const struct timespec *v5; // esi

  return _internal_atexit(v3, v4, v5, (int)lpfunc, (int)obj, (int)lpdso_handle, (int **)&_exit_funcs);
}
// 8050124: variable 'v3' is possibly undefined
// 8050124: variable 'v4' is possibly undefined
// 8050124: variable 'v5' is possibly undefined
// 80CE02C: using guessed type void *_exit_funcs;

//----- (08050130) --------------------------------------------------------
unsigned int __cdecl _strtoul_internal(unsigned __int8 *a1, _DWORD *a2, int a3, int a4)
{
  return ___strtoul_l_internal(a1, a2, a3, a4, __readgsdword(0xFFFFFFD4));
}

//----- (08050170) --------------------------------------------------------
unsigned int __cdecl strtoul(unsigned __int8 *a1, _DWORD *a2, int a3)
{
  return ___strtoul_l_internal(a1, a2, a3, 0, __readgsdword(0xFFFFFFD4));
}

//----- (080501B0) --------------------------------------------------------
unsigned int __cdecl ___strtoul_l_internal(unsigned __int8 *a1, _DWORD *a2, int a3, int a4, int a5)
{
  unsigned int *v5; // ebp
  unsigned __int8 *v6; // esi
  int v7; // ecx
  int i; // eax
  unsigned __int8 *v9; // esi
  int v10; // ecx
  int v11; // eax
  int v12; // edi
  char *v13; // ebx
  unsigned int result; // eax
  char *v15; // edx
  int v16; // edx
  int v17; // ecx
  int v18; // edx
  int v19; // edx
  int v20; // edx
  int v21; // eax
  int v22; // ebx
  unsigned int v23; // edx
  char v24; // cl
  unsigned int j; // eax
  unsigned int v26; // eax
  char *v27; // [esp+0h] [ebp-48h]
  unsigned int v28; // [esp+4h] [ebp-44h]
  unsigned __int8 v29; // [esp+4h] [ebp-44h]
  int v30; // [esp+8h] [ebp-40h]
  unsigned int v31; // [esp+Ch] [ebp-3Ch]
  int *v32; // [esp+14h] [ebp-34h]
  unsigned __int8 v33; // [esp+18h] [ebp-30h]
  int v34; // [esp+24h] [ebp-24h]

  v5 = 0;
  v27 = 0;
  if ( a4 )
  {
    v19 = *(_DWORD *)(a5 + 4);
    v27 = *(char **)(v19 + 44);
    if ( (unsigned __int8)(*v27 - 1) > 0x7Du )
    {
      v27 = 0;
    }
    else
    {
      v5 = *(unsigned int **)(v19 + 40);
      if ( !*(_BYTE *)v5 )
      {
        v27 = 0;
        v5 = 0;
      }
    }
  }
  if ( a3 == 1 || (unsigned int)a3 > 0x24 )
  {
    __writegsdword(0xFFFFFFE0, 0x16u);
    return 0;
  }
  v6 = a1;
  v7 = *(_DWORD *)(a5 + 52);
  for ( i = (char)*a1; (*(_BYTE *)(v7 + 2 * i + 1) & 0x20) != 0; i = (char)*v6 )
    ++v6;
  if ( !(_BYTE)i )
  {
    if ( !a2 )
      return 0;
    goto LABEL_60;
  }
  if ( (_BYTE)i == 45 )
  {
    v9 = v6 + 1;
    v34 = 1;
  }
  else
  {
    v34 = 0;
    v9 = &v6[(_BYTE)i == 43];
  }
  v10 = *v9;
  if ( (_BYTE)v10 != 48 )
  {
    if ( a3 && a3 != 10 )
    {
      v12 = 0;
      v27 = 0;
      v11 = a3 - 2;
      goto LABEL_13;
    }
    if ( !v27 )
    {
      a3 = 10;
      v11 = 8;
      v12 = 0;
      goto LABEL_13;
    }
LABEL_52:
    v29 = *v9;
    v20 = strlen(v5);
    v31 = v20;
    v12 = v20;
    if ( !v20 )
      goto LABEL_57;
    if ( v29 == *(_BYTE *)v5 )
    {
      v21 = 0;
      while ( v20 != ++v21 )
      {
        if ( *((_BYTE *)v5 + v21) != v9[v21] )
          goto LABEL_74;
      }
      goto LABEL_57;
    }
LABEL_74:
    v22 = v29;
    v23 = (unsigned int)v9;
    if ( v29 )
    {
      v23 = (unsigned int)v9;
      do
      {
        if ( (unsigned __int8)(v22 - 48) > 9u )
        {
          v24 = *(_BYTE *)v5;
          for ( j = 0; *(_BYTE *)(v23 + j) == v24; v24 = *((_BYTE *)v5 + j) )
          {
            if ( v31 == ++j )
              goto LABEL_76;
          }
          if ( v31 > j && ((byte_80A7940[2 * v22 + 1] & 4) == 0 || dword_80A7040[v22] > 64) )
            break;
        }
LABEL_76:
        v22 = *(unsigned __int8 *)++v23;
      }
      while ( (_BYTE)v22 );
    }
    v26 = _correctly_grouped_prefixmb((unsigned int)v9, v23, (char *)v5, v27);
    v10 = *v9;
    v27 = (char *)v26;
    v11 = 8;
    a3 = 10;
LABEL_13:
    v28 = *((_DWORD *)&GLOBAL_OFFSET_TABLE_ + v11 - 28912);
    v33 = _strtol_ul_rem_tab[v11];
    if ( (_BYTE)v10 && v27 != (char *)v9 )
      goto LABEL_15;
LABEL_57:
    if ( !a2 )
      return 0;
    if ( v9 - a1 > 1 && dword_80A7040[(char)*(v9 - 1)] == 88 && *(v9 - 2) == 48 )
    {
      *a2 = v9 - 1;
      return 0;
    }
LABEL_60:
    *a2 = a1;
    return 0;
  }
  if ( (a3 & 0xFFFFFFEF) == 0 )
  {
    v32 = dword_80A7040;
    if ( dword_80A7040[(char)v9[1]] == 88 )
    {
      v10 = v9[2];
      v11 = 14;
      v9 += 2;
      v12 = 0;
      a3 = 16;
      v27 = 0;
      goto LABEL_13;
    }
    if ( !a3 )
    {
      a3 = 8;
      v10 = 48;
      v27 = 0;
      v28 = 0x1FFFFFFF;
      v12 = 0;
      v33 = 7;
      goto LABEL_16;
    }
  }
  if ( a3 != 10 )
  {
    v10 = 48;
    v27 = 0;
    v28 = *((_DWORD *)&GLOBAL_OFFSET_TABLE_ + a3 - 28914);
    v33 = byte_80B1BFE[a3];
    v12 = 0;
    v32 = (int *)*((_DWORD *)&GLOBAL_OFFSET_TABLE_ - 33);
    goto LABEL_16;
  }
  if ( v27 )
    goto LABEL_52;
  v10 = 48;
  v28 = 429496729;
  v12 = 0;
  v33 = 5;
LABEL_15:
  v32 = dword_80A7040;
LABEL_16:
  v13 = (char *)v9;
  v30 = 0;
  result = 0;
  do
  {
    LOBYTE(v16) = v10 - 48;
    if ( (unsigned __int8)(v10 - 48) <= 9u )
      goto LABEL_26;
    if ( v12 )
    {
      v18 = 0;
      while ( *((_BYTE *)v5 + v18) == v13[v18] )
      {
        if ( ++v18 == v12 )
          goto LABEL_42;
      }
      v10 = (unsigned __int8)v10;
      if ( v12 == v18 )
      {
LABEL_42:
        v15 = &v13[v12 - 1];
        goto LABEL_20;
      }
    }
    if ( (byte_80A7940[2 * v10 + 1] & 4) == 0 )
      break;
    v16 = v32[v10] - 55;
LABEL_26:
    v17 = (unsigned __int8)v16;
    if ( (unsigned __int8)v16 >= a3 )
      break;
    if ( result > v28 || result == v28 && (unsigned __int8)v16 > v33 )
    {
      v30 = 1;
      v10 = (unsigned __int8)*++v13;
      if ( !(_BYTE)v10 )
        break;
    }
    else
    {
      v15 = v13;
      result = v17 + a3 * result;
LABEL_20:
      v10 = (unsigned __int8)v15[1];
      v13 = v15 + 1;
      if ( !(_BYTE)v10 )
        break;
    }
  }
  while ( v13 != v27 );
  if ( v13 == (char *)v9 )
    goto LABEL_57;
  if ( a2 )
    *a2 = v13;
  if ( v30 )
  {
    __writegsdword(0xFFFFFFE0, 0x22u);
    return -1;
  }
  else if ( v34 )
  {
    return -result;
  }
  return result;
}
// 80A7040: using guessed type int dword_80A7040[256];
// 80A7940: using guessed type _BYTE byte_80A7940[512];
// 80CE000: using guessed type _TBYTE GLOBAL_OFFSET_TABLE_;

//----- (08050710) --------------------------------------------------------
unsigned int __cdecl strtoul_l(unsigned __int8 *a1, _DWORD *a2, int a3, int a4)
{
  return ___strtoul_l_internal(a1, a2, a3, 0, a4);
}

//----- (08050740) --------------------------------------------------------
unsigned int __cdecl _correctly_grouped_prefixmb(unsigned int a1, unsigned int a2, char *a3, char *a4)
{
  int v4; // ebp
  unsigned int v5; // eax
  char v6; // dl
  char *v7; // edx
  char *v8; // ebx
  unsigned int v9; // esi
  char v10; // al
  char v11; // cl
  int v12; // edx
  unsigned int v13; // eax
  char *v15; // edi
  char v16; // si
  char v17; // al
  unsigned int v18; // edi
  char *v19; // eax
  char *v20; // ecx
  char v21; // bl
  char v22; // dl
  unsigned int v23; // eax
  char *v24; // eax
  char *v25; // ecx
  char v26; // bl
  char v27; // dl
  unsigned int v28; // [esp+4h] [ebp-38h]
  int v29; // [esp+8h] [ebp-34h]
  char v30; // [esp+Fh] [ebp-2Dh]
  unsigned int v31; // [esp+10h] [ebp-2Ch]
  char *v32; // [esp+14h] [ebp-28h]
  unsigned int v33; // [esp+1Ch] [ebp-20h]

  if ( a4 )
  {
    v4 = strlen((unsigned int *)a3);
    if ( a2 <= a1 )
      goto LABEL_20;
    v29 = v4 - 2;
    while ( 1 )
    {
      v5 = a2 - 1;
      if ( a1 > a2 - 1 )
        return a2;
      v28 = a1 - 1;
      while ( *(_BYTE *)(v5 + v4 - 1) != *a3 )
      {
LABEL_6:
        if ( --v5 == a1 - 1 )
          return a2;
      }
      v6 = a3[1];
      if ( v6 )
        break;
LABEL_14:
      if ( a1 > v5 )
        return a2;
      v12 = *a4 + 1;
      if ( a2 - v5 == v12 )
      {
        v32 = a4;
        v15 = a4;
        v31 = v5 - 1;
        v16 = *a3;
        v33 = v5 - 1;
        v30 = a4[1];
        if ( !v30 )
          goto LABEL_38;
LABEL_26:
        v17 = v30;
        v32 = v15 + 1;
        v18 = v31;
        if ( v30 != 127 )
        {
          do
          {
            if ( v17 < 0 )
              break;
            if ( a1 > v31 )
              return a2;
            v18 = v31;
            while ( v16 )
            {
              if ( v16 == *(_BYTE *)(v18 + v4 - 1) )
              {
                v19 = a3 + 1;
                v20 = (char *)(v18 + v29);
                do
                {
                  v22 = *v19;
                  if ( !*v19 )
                    goto LABEL_35;
                  v21 = *v20;
                  ++v19;
                  --v20;
                }
                while ( v21 == v22 );
              }
              if ( --v18 == v28 )
                goto LABEL_48;
            }
LABEL_35:
            if ( a1 > v18 )
            {
LABEL_48:
              if ( v30 >= (int)(v31 - v18) )
                return a2;
LABEL_49:
              a2 = v33;
              goto LABEL_19;
            }
            if ( v31 - v18 != v30 )
              goto LABEL_49;
LABEL_37:
            v23 = v18 - 1;
            v15 = v32;
            v31 = v23;
            v30 = v32[1];
            if ( v30 )
              goto LABEL_26;
LABEL_38:
            v18 = v31;
            v30 = *v32;
            v17 = *v32;
          }
          while ( *v32 != 127 );
        }
        if ( a1 <= v31 )
        {
          while ( v16 )
          {
            if ( v16 == *(_BYTE *)(v18 + v4 - 1) )
            {
              v24 = a3 + 1;
              v25 = (char *)(v18 + v29);
              do
              {
                v27 = *v24;
                if ( !*v24 )
                  goto LABEL_45;
                v26 = *v25;
                ++v24;
                --v25;
              }
              while ( v26 == v27 );
            }
            if ( --v18 == v28 )
              return a2;
          }
LABEL_45:
          if ( a1 <= v18 )
            goto LABEL_37;
        }
        return a2;
      }
      if ( (int)(a2 - v5) > v12 )
        v5 += v12;
      a2 = v5;
LABEL_19:
      if ( a1 >= a2 )
      {
LABEL_20:
        v13 = a2;
        if ( a2 < a1 )
          return a1;
        return v13;
      }
    }
    if ( *(_BYTE *)(v5 + v4 - 2) == v6 )
    {
      v7 = a3 + 2;
      v8 = (char *)(v5 + v4 - 3);
      v9 = v5;
      do
      {
        v11 = *v7;
        if ( !*v7 )
        {
          v5 = v9;
          goto LABEL_14;
        }
        v10 = *v8;
        ++v7;
        --v8;
      }
      while ( v10 == v11 );
      v5 = v9;
    }
    goto LABEL_6;
  }
  return a2;
}

//----- (08050A00) --------------------------------------------------------
void __usercall printf(int a1@<ebx>, int a2@<esi>, unsigned int *a3, ...)
{
  va_list va; // [esp+8h] [ebp+8h] BYREF

  va_start(va, a3);
  vfprintf(a1, a2, (int)stdout, a3, (int)va);
}
// 80CE478: using guessed type void *stdout;

//----- (08050A30) --------------------------------------------------------
__int64 asprintf(int **a1, unsigned int *a2, ...)
{
  va_list va; // [esp+10h] [ebp+Ch] BYREF

  va_start(va, a2);
  return vasprintf(a1, a2, (int)va);
}

//----- (08050A60) --------------------------------------------------------
void __usercall locked_vfxprintf(struct timespec *a1@<eax>, unsigned int *a2@<edx>, int a3@<ecx>)
{
  unsigned int v4; // edi
  _BOOL4 v5; // eax
  int *v6; // edx
  int v7; // eax
  void *v8; // esp
  int *v9; // eax
  int v10; // eax
  int *p_tv_sec; // ecx
  _BYTE v12[4]; // [esp-1008h] [ebp-103Ch]
  _BYTE v13[4096]; // [esp-1004h] [ebp-1038h] BYREF
  int v14; // [esp-4h] [ebp-38h] BYREF
  int v15; // [esp+0h] [ebp-34h]
  struct timespec *v16; // [esp+4h] [ebp-30h]
  unsigned int *v17[2]; // [esp+8h] [ebp-2Ch] BYREF
  int v18; // [esp+10h] [ebp-24h] BYREF
  int v19; // [esp+14h] [ebp-20h]
  unsigned int v20; // [esp+18h] [ebp-1Ch]
  int savedregs; // [esp+34h] [ebp+0h] BYREF

  v17[0] = a2;
  v15 = a3;
  v20 = __readgsdword(0x14u);
  if ( a1[13].tv_sec <= 0 )
  {
    vfprintf((int)&GLOBAL_OFFSET_TABLE_, (int)a1, (int)a1, a2, a3);
  }
  else
  {
    v4 = strlen(a2) + 1;
    if ( v4 > 0x3FFFFFFF )
    {
      __writegsdword(0xFFFFFFE0, 0x4Bu);
    }
    else
    {
      v16 = (struct timespec *)(4 * v4);
      v5 = _libc_alloca_cutoff(4 * v4);
      if ( 4 * v4 <= 0x1000 || v5 )
      {
        v6 = (int *)((char *)&v14 - (((unsigned int)&v16[3].tv_sec + 3) & 0xFFFFF000));
        if ( &v14 != v6 )
        {
          while ( v13 != (_BYTE *)v6 )
            ;
        }
        v7 = ((_WORD)v16 + 27) & 0xFF0;
        if ( (((_WORD)v16 + 27) & 0xFF0) != 0 )
        {
          v8 = alloca(v7);
          *(_DWORD *)&v12[v7] = *(_DWORD *)&v12[v7];
        }
        v18 = 0;
        v19 = 0;
        v16 = (struct timespec *)v13;
        if ( mbsrtowcs((int)v13, v17, v4, &v18) != -1 )
          vfwprintf(a1, &v16->tv_sec, v15);
      }
      else
      {
        v9 = malloc(v16);
        if ( v9 )
        {
          v16 = (struct timespec *)v9;
          v18 = 0;
          v19 = 0;
          v10 = mbsrtowcs((int)v9, v17, v4, &v18);
          p_tv_sec = &v16->tv_sec;
          if ( v10 != -1 )
          {
            vfwprintf(a1, &v16->tv_sec, v15);
            p_tv_sec = &v16->tv_sec;
          }
          free((int)&savedregs, (int *)v4, (int)p_tv_sec);
        }
      }
    }
  }
}
// 80CE000: using guessed type _TBYTE GLOBAL_OFFSET_TABLE_;

//----- (08050C20) --------------------------------------------------------
int __usercall _fxprintf@<eax>(int a1@<ebp>, int *a2@<edi>, struct timespec *a3, unsigned int *a4, ...)
{
  struct timespec *v4; // ebx
  bool v7; // zf
  int v8; // eax
  int v9; // ecx
  int *tv_sec; // edx
  struct timespec v12; // [esp+Ch] [ebp+Ch] BYREF

  v4 = a3;
  if ( !a3 )
    v4 = (struct timespec *)stderr;
  if ( (v4->tv_sec & 0x8000) == 0 )
  {
    _EDX = (int *)v4[9].tv_sec;
    a2 = (int *)__readgsdword(8u);
    if ( (int *)_EDX[2] != a2 )
    {
      _ECX = 1;
      v7 = __readgsdword(0xCu) == 0;
      if ( !v7 )
        __asm { lock }
      __asm { cmpxchg [edx], ecx }
      if ( !v7 )
        _lll_lock_wait_private(0, _EDX, a1, a2);
      _EDX = (int *)v4[9].tv_sec;
      _EDX[2] = (int)a2;
    }
    ++_EDX[1];
  }
  locked_vfxprintf(v4, a4, (int)&v12);
  v9 = v8;
  if ( (v4->tv_sec & 0x8000) == 0 )
  {
    tv_sec = (int *)v4[9].tv_sec;
    v7 = tv_sec[1]-- == 1;
    if ( v7 )
    {
      tv_sec[2] = 0;
      if ( __readgsdword(0xCu) )
        __asm { lock }
      v7 = (*tv_sec)-- == 1;
      if ( !v7 )
        _lll_unlock_wake_private(tv_sec, a1, a2, &v12);
    }
  }
  return v9;
}
// 8050C8C: variable 'v8' is possibly undefined
// 8050CBE: variable 'v9' is possibly undefined
// 80CE474: using guessed type void *stderr;

//----- (08050CE0) --------------------------------------------------------
int __usercall _fxprintf_nocancel@<eax>(int a1@<ebp>, struct timespec *a2, unsigned int *a3, const struct timespec a4)
{
  struct timespec *v4; // ebx
  int *v6; // edi
  bool v8; // zf
  unsigned int tv_nsec; // edi
  int v10; // eax
  int v11; // ecx
  int *tv_sec; // edx

  v4 = a2;
  if ( !a2 )
    v4 = (struct timespec *)stderr;
  if ( (v4->tv_sec & 0x8000) == 0 )
  {
    _EDX = (int *)v4[9].tv_sec;
    v6 = (int *)__readgsdword(8u);
    if ( (int *)_EDX[2] != v6 )
    {
      _ECX = 1;
      v8 = __readgsdword(0xCu) == 0;
      if ( !v8 )
        __asm { lock }
      __asm { cmpxchg [edx], ecx }
      if ( !v8 )
        _lll_lock_wait_private(0, _EDX, a1, v6);
      _EDX = (int *)v4[9].tv_sec;
      _EDX[2] = (int)v6;
    }
    ++_EDX[1];
  }
  tv_nsec = v4[7].tv_nsec;
  v4[7].tv_nsec = tv_nsec | 2;
  locked_vfxprintf(v4, a3, (int)&a4);
  v4[7].tv_nsec = tv_nsec;
  v11 = v10;
  if ( (v4->tv_sec & 0x8000) == 0 )
  {
    tv_sec = (int *)v4[9].tv_sec;
    v8 = tv_sec[1]-- == 1;
    if ( v8 )
    {
      tv_sec[2] = 0;
      if ( __readgsdword(0xCu) )
        __asm { lock }
      v8 = (*tv_sec)-- == 1;
      if ( !v8 )
        _lll_unlock_wake_private(tv_sec, a1, (int *)tv_nsec, &a4);
    }
  }
  return v11;
}
// 8050D5A: variable 'v10' is possibly undefined
// 8050D8C: variable 'v11' is possibly undefined
// 80CE474: using guessed type void *stderr;

//----- (08050DB0) --------------------------------------------------------
int __cdecl fclose(struct timespec *a1)
{
  __time_t tv_sec; // eax
  int v3; // ecx
  int tv_nsec; // ebx
  unsigned int v7; // ebx
  bool v9; // zf
  int *v10; // edx
  int v11; // ebx
  bool v13; // zf
  int v14; // [esp-14h] [ebp-30h]
  int v15; // [esp-10h] [ebp-2Ch]
  int v16; // [esp-Ch] [ebp-28h]
  int v17; // [esp-8h] [ebp-24h]
  int v18; // [esp-4h] [ebp-20h]
  int v19; // [esp+0h] [ebp-1Ch]
  int savedregs; // [esp+1Ch] [ebp+0h] BYREF

  _EDI = &GLOBAL_OFFSET_TABLE_;
  tv_sec = a1->tv_sec;
  if ( (a1->tv_sec & 0x2000) != 0 )
  {
    IO_un_link((int)&savedregs, a1);
    tv_sec = a1->tv_sec;
    if ( (BYTE1(a1->tv_sec) & 0x80u) != 0 )
      goto LABEL_22;
  }
  else
  {
    v3 = a1->tv_sec & 0x8000;
    if ( (tv_sec & 0x8000) != 0 )
      goto LABEL_3;
  }
  _EDX = (int *)a1[9].tv_sec;
  v7 = __readgsdword(8u);
  if ( _EDX[2] != v7 )
  {
    _ECX = 1;
    v9 = __readgsdword(0xCu) == 0;
    if ( !v9 )
      __asm { lock }
    __asm { cmpxchg [edx], ecx }
    if ( !v9 )
      _lll_lock_wait_private(0, _EDX, (int)&savedregs, (int *)&GLOBAL_OFFSET_TABLE_);
    _EDX = (int *)a1[9].tv_sec;
    tv_sec = a1->tv_sec;
    _EDX[2] = v7;
  }
  ++_EDX[1];
LABEL_22:
  v3 = tv_sec & 0x8000;
  if ( (tv_sec & 0x2000) != 0 )
  {
    v19 = IO_new_file_close_it((int)a1);
    if ( (a1->tv_sec & 0x8000) != 0 )
      goto LABEL_4;
    goto LABEL_24;
  }
LABEL_3:
  v19 = tv_sec << 26 >> 31;
  if ( v3 )
    goto LABEL_4;
LABEL_24:
  v10 = (int *)a1[9].tv_sec;
  v9 = v10[1]-- == 1;
  if ( v9 )
  {
    v10[2] = 0;
    if ( __readgsdword(0xCu) )
      __asm { lock }
    v9 = (*v10)-- == 1;
    if ( !v9 )
      _lll_unlock_wake_private(v10, (int)&savedregs, (int *)&GLOBAL_OFFSET_TABLE_, a1);
  }
LABEL_4:
  tv_nsec = a1[18].tv_nsec;
  if ( (char *)&_start___libc_atexit - (char *)_start___libc_IO_vtables <= (unsigned int)(tv_nsec
                                                                                        - (_DWORD)_start___libc_IO_vtables) )
    IO_vtable_check();
  (*(void (__stdcall **)(struct timespec *, _DWORD, int, int, int, int, int))(tv_nsec + 8))(
    a1,
    0,
    v14,
    v15,
    v16,
    v17,
    v18);
  if ( a1[13].tv_sec > 0 )
  {
    v11 = a1[10].tv_nsec;
    _ECX = 1;
    v13 = __readgsdword(0xCu) == 0;
    if ( !v13 )
      __asm { lock }
    __asm { cmpxchg ds:(__gconv_lock - 80CE000h)[edi], ecx }
    if ( !v13 )
      _lll_lock_wait_private(0, &_gconv_lock, (int)&savedregs, (int *)&GLOBAL_OFFSET_TABLE_);
    _gconv_release_step(*(int **)(v11 + 36));
    _gconv_release_step(*(int **)(v11 + 76));
    if ( __readgsdword(0xCu) )
      __asm { lock }
    if ( --_gconv_lock )
      _lll_unlock_wake_private(&_gconv_lock, (int)&savedregs, (int *)&GLOBAL_OFFSET_TABLE_, a1);
  }
  else if ( a1[4].tv_nsec )
  {
    IO_free_backup_area((int)&savedregs, (int *)&GLOBAL_OFFSET_TABLE_, &a1->tv_sec);
  }
  if ( stdin != a1 && stdout != a1 && stderr != a1 )
    free((int)&savedregs, (int *)&GLOBAL_OFFSET_TABLE_, (int)a1);
  return v19;
}
// 8050E1B: variable 'v14' is possibly undefined
// 8050E1B: variable 'v15' is possibly undefined
// 8050E1B: variable 'v16' is possibly undefined
// 8050E1B: variable 'v17' is possibly undefined
// 8050E1B: variable 'v18' is possibly undefined
// 8050E65: variable 'v19' is possibly undefined
// 80CE000: using guessed type _TBYTE GLOBAL_OFFSET_TABLE_;
// 80CE474: using guessed type void *stderr;
// 80CE478: using guessed type void *stdout;
// 80CE47C: using guessed type void *stdin;
// 80CEFA0: using guessed type int _start___libc_IO_vtables[24];
// 80CF2F4: using guessed type int (*_start___libc_atexit)();
// 80CFF80: using guessed type int _gconv_lock;

//----- (08050FA0) --------------------------------------------------------
int __cdecl fflush(const struct timespec *a1)
{
  unsigned int v2; // ebx
  bool v4; // zf
  int tv_nsec; // ebx
  int v6; // edx
  int *tv_sec; // ecx
  int v9; // [esp-20h] [ebp-24h]
  int v10; // [esp-1Ch] [ebp-20h]
  int savedregs; // [esp+4h] [ebp+0h] BYREF

  if ( !a1 )
    return IO_flush_all((int *)&GLOBAL_OFFSET_TABLE_);
  if ( (a1->tv_sec & 0x8000) == 0 )
  {
    _EDX = (int *)a1[9].tv_sec;
    v2 = __readgsdword(8u);
    if ( _EDX[2] != v2 )
    {
      _ECX = 1;
      v4 = __readgsdword(0xCu) == 0;
      if ( !v4 )
        __asm { lock }
      __asm { cmpxchg [edx], ecx }
      if ( !v4 )
        _lll_lock_wait_private(0, _EDX, (int)&savedregs, (int *)&GLOBAL_OFFSET_TABLE_);
      _EDX = (int *)a1[9].tv_sec;
      _EDX[2] = v2;
    }
    ++_EDX[1];
  }
  tv_nsec = a1[18].tv_nsec;
  if ( (char *)&_start___libc_atexit - (char *)_start___libc_IO_vtables <= (unsigned int)(tv_nsec
                                                                                        - (_DWORD)_start___libc_IO_vtables) )
    IO_vtable_check();
  v6 = -((*(int (__stdcall **)(const struct timespec *, int, int))(tv_nsec + 48))(a1, v9, v10) != 0);
  if ( (a1->tv_sec & 0x8000) == 0 )
  {
    tv_sec = (int *)a1[9].tv_sec;
    v4 = tv_sec[1]-- == 1;
    if ( v4 )
    {
      tv_sec[2] = 0;
      if ( __readgsdword(0xCu) )
        __asm { lock }
      v4 = (*tv_sec)-- == 1;
      if ( !v4 )
        _lll_unlock_wake_private(tv_sec, (int)&savedregs, (int *)&GLOBAL_OFFSET_TABLE_, a1);
    }
  }
  return v6;
}
// 8051021: variable 'v9' is possibly undefined
// 8051021: variable 'v10' is possibly undefined
// 8051062: variable 'v6' is possibly undefined
// 80CE000: using guessed type _TBYTE GLOBAL_OFFSET_TABLE_;
// 80CEFA0: using guessed type int _start___libc_IO_vtables[24];
// 80CF2F4: using guessed type int (*_start___libc_atexit)();

//----- (080510A0) --------------------------------------------------------
int __cdecl _fopen_maybe_mmap(int a1)
{
  int result; // eax
  int *v2; // ecx

  result = a1;
  if ( (*(_BYTE *)(a1 + 60) & 1) != 0 && (*(_BYTE *)a1 & 8) != 0 )
  {
    if ( *(int *)(a1 + 104) <= 0 )
      v2 = (int *)&IO_file_jumps_maybe_mmap;
    else
      v2 = _start___libc_IO_vtables;
    *(_DWORD *)(a1 + 148) = v2;
    *(_DWORD *)(*(_DWORD *)(a1 + 88) + 176) = _start___libc_IO_vtables;
  }
  return result;
}
// 80CEFA0: using guessed type int _start___libc_IO_vtables[24];

//----- (080510F0) --------------------------------------------------------
int *__usercall _fopen_internal@<eax>(int a1@<ebp>, int a2, _BYTE *a3, int a4)
{
  int *v4; // eax
  int v5; // esi
  int *v6; // edi
  int *v7; // edx

  v4 = malloc((const struct timespec *)0x158);
  if ( !v4 )
    return 0;
  v5 = (int)v4;
  v4[18] = (int)(v4 + 38);
  v6 = v4;
  IO_no_init(v4, 0, 0, v4 + 41, (int)&IO_wfile_jumps);
  *(_DWORD *)(v5 + 148) = &IO_file_jumps;
  IO_new_file_init_internal(a1, (int *)v5);
  if ( IO_new_file_fopen(v5, a2, a3, a4) )
  {
    if ( (*(_BYTE *)(v5 + 60) & 1) != 0 && (*(_BYTE *)v5 & 8) != 0 )
    {
      if ( *(int *)(v5 + 104) <= 0 )
        v7 = (int *)&IO_file_jumps_maybe_mmap;
      else
        v7 = _start___libc_IO_vtables;
      *(_DWORD *)(v5 + 148) = v7;
      *(_DWORD *)(*(_DWORD *)(v5 + 88) + 176) = _start___libc_IO_vtables;
    }
    return v6;
  }
  else
  {
    IO_un_link(a1, (struct timespec *)v5);
    free(a1, 0, v5);
    return 0;
  }
}
// 80CEFA0: using guessed type int _start___libc_IO_vtables[24];

//----- (080511E0) --------------------------------------------------------
int *__usercall fopen@<eax>(int a1@<ebp>, int a2, _BYTE *a3)
{
  return _fopen_internal(a1, a2, a3, 1);
}

//----- (080511FA) --------------------------------------------------------
void _x86_get_pc_thunk_dx()
{
  ;
}

//----- (08051200) --------------------------------------------------------
int __cdecl puts(unsigned int *a1)
{
  const struct timespec *v1; // esi
  _DWORD *v2; // ecx
  unsigned int v4; // ebx
  bool v6; // zf
  int v7; // eax
  _BYTE *v8; // edx
  int v9; // ebx
  int *tv_sec; // edx
  int v12; // [esp+0h] [ebp-20h]
  int v13; // [esp+4h] [ebp-1Ch]
  int savedregs; // [esp+20h] [ebp+0h] BYREF

  v1 = (const struct timespec *)stdout;
  v13 = strlen(a1);
  v2 = stdout;
  if ( (*(_DWORD *)stdout & 0x8000) == 0 )
  {
    _EDX = (int *)*((_DWORD *)stdout + 18);
    v4 = __readgsdword(8u);
    if ( _EDX[2] != v4 )
    {
      _ECX = 1;
      v6 = __readgsdword(0xCu) == 0;
      if ( !v6 )
        __asm { lock }
      __asm { cmpxchg [edx], ecx }
      if ( !v6 )
        _lll_lock_wait_private(0, _EDX, (int)&savedregs, (int *)&GLOBAL_OFFSET_TABLE_);
      _EDX = (int *)v1[9].tv_sec;
      v2 = stdout;
      _EDX[2] = v4;
    }
    ++_EDX[1];
  }
  v7 = v2[26];
  if ( v7 )
  {
    if ( v7 != -1 )
      goto LABEL_26;
  }
  else
  {
    v2[26] = -1;
  }
  v12 = v2[37];
  if ( (char *)&_start___libc_atexit - (char *)_start___libc_IO_vtables <= (unsigned int)(v12
                                                                                        - (_DWORD)_start___libc_IO_vtables) )
  {
    IO_vtable_check();
    v2 = stdout;
  }
  if ( v13 != (*(int (__cdecl **)(_DWORD *, unsigned int *, int))(v12 + 28))(v2, a1, v13) )
    goto LABEL_26;
  v8 = (_BYTE *)*((_DWORD *)stdout + 5);
  if ( (unsigned int)v8 < *((_DWORD *)stdout + 6) )
  {
    *((_DWORD *)stdout + 5) = v8 + 1;
    *v8 = 10;
    goto LABEL_16;
  }
  if ( _overflow((int)stdout, 10) == -1 )
  {
LABEL_26:
    v9 = -1;
    goto LABEL_18;
  }
LABEL_16:
  v9 = v13 + 1;
  if ( v13 + 1 < 0 )
    v9 = 0x7FFFFFFF;
LABEL_18:
  if ( (v1->tv_sec & 0x8000) == 0 )
  {
    tv_sec = (int *)v1[9].tv_sec;
    v6 = tv_sec[1]-- == 1;
    if ( v6 )
    {
      tv_sec[2] = 0;
      if ( __readgsdword(0xCu) )
        __asm { lock }
      v6 = (*tv_sec)-- == 1;
      if ( !v6 )
        _lll_unlock_wake_private(tv_sec, (int)&savedregs, (int *)&GLOBAL_OFFSET_TABLE_, v1);
    }
  }
  return v9;
}
// 80CE000: using guessed type _TBYTE GLOBAL_OFFSET_TABLE_;
// 80CE478: using guessed type void *stdout;
// 80CEFA0: using guessed type int _start___libc_IO_vtables[24];
// 80CF2F4: using guessed type int (*_start___libc_atexit)();

//----- (08051360) --------------------------------------------------------
int __usercall adjust_wide_data@<eax>(_DWORD *a1@<eax>, char a2@<dl>)
{
  int v4; // edi
  int v5; // ebx
  int *v6; // ecx
  int v7; // eax
  int v8; // edx
  _DWORD *v9; // eax
  int v10; // ebx
  _DWORD *v11; // ecx
  int v12; // eax
  int v14[9]; // [esp+14h] [ebp-24h] BYREF

  v4 = a1[21];
  v14[1] = __readgsdword(0x14u);
  v5 = (*(int (__cdecl **)(int))(v4 + 16))(v4);
  if ( a2 == 1 || v5 <= 0 )
  {
    v8 = a1[3];
    v14[0] = v8;
    while ( 1 )
    {
      v9 = (_DWORD *)a1[22];
      v10 = v9[12];
      v9[13] = v9[11];
      v11 = v9 + 1;
      v9 += 11;
      v9[3] = v10;
      v12 = (*(int (__cdecl **)(int, _DWORD *, int, _DWORD, int *, _DWORD, _DWORD, _DWORD *))(v4 + 12))(
              v4,
              v9,
              v8,
              a1[1],
              v14,
              *(v9 - 9),
              *(v9 - 4),
              v11);
      if ( v12 == 2 )
        break;
      if ( v12 != 1 )
      {
        v6 = (int *)a1[22];
        v7 = v6[1];
        goto LABEL_8;
      }
      v8 = a1[3];
    }
    *a1 |= 0x20u;
    return -1;
  }
  else
  {
    v6 = (int *)a1[22];
    v7 = v6[1] + 4 * ((a1[1] - a1[3]) / v5);
    v6[1] = v7;
LABEL_8:
    *v6 = v7;
    return 0;
  }
}

//----- (08051430) --------------------------------------------------------
int __usercall IO_wfile_underflow@<eax>(int *a1@<edi>, int *a2)
{
  int v2; // eax
  int v3; // eax
  unsigned int v4; // edx
  unsigned int v5; // ecx
  int v6; // esi
  int v7; // ebx
  int v8; // esi
  int v9; // eax
  int v10; // eax
  _BYTE *v11; // ecx
  int v12; // edx
  _DWORD *v13; // edx
  int v14; // eax
  int v15; // edx
  int result; // eax
  int v17; // eax
  const struct timespec *v18; // esi
  __time_t tv_sec; // eax
  int *v20; // edi
  __time_t *v22; // ecx
  unsigned int v23; // ebx
  int v24; // eax
  bool v26; // zf
  int *v27; // edx
  _DWORD *v28; // eax
  int v29; // edx
  _BYTE *v30; // esi
  int v31; // eax
  unsigned int v32; // edi
  int v33; // ebx
  signed int v34; // eax
  int v35; // edx
  __int64 v36; // rcx
  _DWORD *v37; // esi
  int v38; // ecx
  _BYTE *v39; // ebx
  int v40; // eax
  _BYTE *v41; // ecx
  _BYTE *v42; // edx
  _DWORD *v43; // ebx
  int v44; // eax
  _WORD *v45; // eax
  int v46; // edx
  int v47; // eax
  __time_t v48; // ebx
  int v49; // eax
  signed int v50; // [esp-60h] [ebp-60h]
  unsigned int v51; // [esp-50h] [ebp-50h]
  int v52; // [esp-4Ch] [ebp-4Ch]
  _BYTE *v53; // [esp-48h] [ebp-48h]
  unsigned int v54; // [esp-44h] [ebp-44h]
  int v55; // [esp-34h] [ebp-34h] BYREF
  _BYTE v56[16]; // [esp-30h] [ebp-30h] BYREF
  unsigned int v57; // [esp-20h] [ebp-20h]
  int *v58; // [esp-8h] [ebp-8h]
  int v59; // [esp-4h] [ebp-4h] BYREF

  v58 = a1;
  v2 = *a2;
  v57 = __readgsdword(0x14u);
  if ( (v2 & 0x10) != 0 )
    return -1;
  if ( (v2 & 4) != 0 )
  {
    *a2 = v2 | 0x20;
    __writegsdword(0xFFFFFFE0, 9u);
    return -1;
  }
  v3 = a2[22];
  if ( *(_DWORD *)v3 < *(_DWORD *)(v3 + 4) )
    return **(_DWORD **)v3;
  v52 = a2[21];
  v4 = a2[1];
  v5 = a2[2];
  if ( v4 >= v5 )
  {
    v14 = a2[7];
    a2[2] = v14;
    a2[1] = v14;
    a2[3] = v14;
  }
  else
  {
    v6 = *(_DWORD *)(v3 + 44);
    v7 = *(_DWORD *)(v3 + 24);
    v55 = a2[1];
    a1 = *(int **)(v3 + 48);
    *(_DWORD *)(v3 + 52) = v6;
    v8 = v3 + 4;
    v9 = v3 + 44;
    *(_DWORD *)(v9 - 44) = v7;
    *(_DWORD *)(v9 - 36) = v7;
    *(_DWORD *)(v9 + 12) = a1;
    v10 = (*(int (__cdecl **)(int, int, unsigned int, unsigned int, int *, int, _DWORD, int))(v52 + 12))(
            v52,
            v9,
            v4,
            v5,
            &v55,
            v7,
            *(_DWORD *)(v9 - 16),
            v8);
    v11 = (_BYTE *)v55;
    v12 = a2[1];
    a2[1] = v55;
    a2[3] = v12;
    v13 = (_DWORD *)a2[22];
    if ( *v13 < v13[1] )
      return *(_DWORD *)*v13;
    if ( v10 == 2 )
    {
      __writegsdword(0xFFFFFFE0, 0x54u);
      *a2 |= 0x20u;
      return -1;
    }
    memmove((_BYTE *)a2[7], v11, a2[2] - (_DWORD)v11);
    v14 = a2[7];
    v15 = v14 + a2[2] - a2[1];
    a2[3] = v14;
    a2[2] = v15;
    a2[1] = v14;
  }
  if ( !v14 )
  {
    if ( a2[9] )
    {
      free((int)&v59, a1, a2[9]);
      *a2 &= ~0x100u;
    }
    IO_doallocbuf(a2);
    v14 = a2[7];
    a2[2] = v14;
    a2[1] = v14;
    a2[3] = v14;
  }
  a2[6] = v14;
  a2[5] = v14;
  a2[4] = v14;
  v17 = a2[22];
  if ( !*(_DWORD *)(v17 + 24) )
  {
    v49 = *(_DWORD *)(v17 + 32);
    if ( v49 )
    {
      free((int)&v59, a1, v49);
      *a2 &= ~0x100u;
    }
    IO_wdoallocbuf((int)&v59, a1, (int)a2);
  }
  v51 = (char *)&_start___libc_atexit - (char *)_start___libc_IO_vtables;
  if ( (*a2 & 0x202) == 0 )
    goto LABEL_29;
  v18 = (const struct timespec *)*((_DWORD *)&GLOBAL_OFFSET_TABLE_ + 286);
  tv_sec = v18->tv_sec;
  v20 = (int *)(v18->tv_sec & 0x8000);
  if ( !v20 )
  {
    _EDX = (int *)v18[9].tv_sec;
    v22 = (__time_t *)*((_DWORD *)&GLOBAL_OFFSET_TABLE_ + 286);
    v23 = __readgsdword(8u);
    if ( _EDX[2] != v23 )
    {
      v24 = v18->tv_sec & 0x8000;
      _ECX = 1;
      v26 = __readgsdword(0xCu) == 0;
      if ( !v26 )
        __asm { lock }
      __asm { cmpxchg [edx], ecx }
      if ( !v26 )
        _lll_lock_wait_private(v24, _EDX, (int)&v59, 0);
      _EDX = (int *)v18[9].tv_sec;
      v22 = (__time_t *)*((_DWORD *)&GLOBAL_OFFSET_TABLE_ + 286);
      _EDX[2] = v23;
      tv_sec = *v22;
    }
    ++_EDX[1];
    if ( (tv_sec & 0x288) != 640 )
      goto LABEL_23;
    goto LABEL_63;
  }
  if ( (v18->tv_sec & 0x288) == 640 )
  {
    v22 = (__time_t *)*((_DWORD *)&GLOBAL_OFFSET_TABLE_ + 286);
LABEL_63:
    v48 = v22[37];
    if ( v48 - (int)_start___libc_IO_vtables >= v51 )
      IO_vtable_check();
    (*(void (__cdecl **)(void *, int))(v48 + 12))(stdout, -1);
LABEL_23:
    if ( (v18->tv_sec & 0x8000) == 0 )
    {
      v27 = (int *)v18[9].tv_sec;
      v26 = v27[1]-- == 1;
      if ( v26 )
      {
        v27[2] = 0;
        if ( __readgsdword(0xCu) )
          __asm { lock }
        v26 = (*v27)-- == 1;
        if ( !v26 )
          _lll_unlock_wake_private(v27, (int)&v59, v20, v18);
      }
    }
  }
LABEL_29:
  IO_switch_to_get_mode(a2);
  v28 = (_DWORD *)a2[22];
  v54 = 0;
  v29 = v28[6];
  *v28 = v29;
  v28[2] = v29;
  v28[1] = v29;
  v28[5] = v29;
  v28[4] = v29;
  v28[3] = v29;
  while ( 1 )
  {
    v33 = *(int *)((char *)a2 + (_DWORD)(&off_80CE094 - 33765376));
    if ( v33 - (int)_start___libc_IO_vtables >= v51 )
      IO_vtable_check();
    v34 = (*(int (__cdecl **)(int *, int, int))(v33 + 56))(a2, a2[2], a2[8] - a2[2]);
    if ( v34 <= 0 )
      break;
    LODWORD(v36) = a2[19];
    v35 = v34 + a2[2];
    a2[2] = v35;
    HIDWORD(v36) = a2[20];
    if ( (HIDWORD(v36) & (unsigned int)v36) != -1 )
      *(_QWORD *)(a2 + 19) = v34 + v36;
    v37 = (_DWORD *)a2[22];
    v38 = v37[11];
    v37[14] = v37[12];
    v39 = (_BYTE *)a2[1];
    v37[13] = v38;
    a2[3] = (int)v39;
    if ( v54 )
    {
      if ( 16 - v54 <= v34 )
        v34 = 16 - v54;
      v53 = &v56[v54];
      v50 = v34;
      v45 = mempcpy(&v56[v54], v39, v34);
      v54 += v50;
      v40 = (*(int (__cdecl **)(int, _DWORD *, _BYTE *, _WORD *, int *, _DWORD, _DWORD, _DWORD *))(v52 + 12))(
              v52,
              v37 + 11,
              v56,
              v45,
              &v55,
              v37[1],
              v37[7],
              v37 + 1);
      if ( v54 )
      {
        v41 = (_BYTE *)v55;
        v46 = v55 - (_DWORD)v53;
        if ( v55 - (int)v53 < 0 )
          v46 = 0;
        v42 = (_BYTE *)(a2[1] + v46);
        goto LABEL_42;
      }
    }
    else
    {
      v40 = (*(int (__cdecl **)(int, _DWORD *, _BYTE *, int, int *, _DWORD, _DWORD, _DWORD *))(v52 + 12))(
              v52,
              v37 + 11,
              v39,
              v35,
              &v55,
              v37[1],
              v37[7],
              v37 + 1);
    }
    v41 = (_BYTE *)v55;
    v54 = 0;
    v42 = (_BYTE *)v55;
LABEL_42:
    v43 = (_DWORD *)a2[22];
    a2[1] = (int)v42;
    if ( v43[1] != v43[6] )
      return *(_DWORD *)*v43;
    if ( v40 == 2 )
      goto LABEL_9;
    if ( v40 != 1 )
      _assert_fail(
        (int)&GLOBAL_OFFSET_TABLE_ - 178252,
        (int)&GLOBAL_OFFSET_TABLE_ - 178263,
        290,
        (int)&GLOBAL_OFFSET_TABLE_ - 178224);
    if ( v54 )
    {
      if ( v41 != v56 )
      {
        v54 -= v41 - v56;
        memmove(v56, v41, v54);
      }
      if ( v54 == 16 )
      {
LABEL_9:
        __writegsdword(0xFFFFFFE0, 0x54u);
        *a2 |= 0x20u;
        return -1;
      }
      v30 = (_BYTE *)a2[3];
LABEL_33:
      a2[2] = (int)v30;
      a2[1] = (int)v30;
    }
    else
    {
      v30 = (_BYTE *)a2[3];
      v31 = a2[2];
      v32 = v31 - (_DWORD)v42;
      if ( v30 >= v42 )
      {
        if ( v32 > 0xF )
          goto LABEL_9;
        memcpy(v56, v42, v32);
        v54 = v32;
        goto LABEL_33;
      }
      memmove(v30, v42, v31 - (_DWORD)v42);
      v47 = a2[3];
      a2[2] -= v32;
      a2[1] = v47;
    }
  }
  v26 = (v54 | v34) == 0;
  v44 = *a2;
  if ( v26 )
  {
    a2[19] = -1;
    *a2 = v44 | 0x10;
    result = -1;
    a2[20] = -1;
    return result;
  }
  *a2 = v44 | 0x20;
  if ( v54 )
  {
    __writegsdword(0xFFFFFFE0, 0x54u);
    return -1;
  }
  return -1;
}
// 80CE000: using guessed type _TBYTE GLOBAL_OFFSET_TABLE_;
// 80CE094: using guessed type void *off_80CE094;
// 80CE478: using guessed type void *stdout;
// 80CEFA0: using guessed type int _start___libc_IO_vtables[24];
// 80CF2F4: using guessed type int (*_start___libc_atexit)();

//----- (08051A90) --------------------------------------------------------
int __cdecl IO_wfile_seekoff(int *a1, signed __int64 a2, int a3, int a4)
{
  int v4; // ebp
  unsigned int *v5; // eax
  unsigned int v6; // ecx
  unsigned int v7; // edx
  int v8; // ecx
  __int64 v9; // rax
  int v10; // edi
  int v11; // ebx
  __int64 v12; // rax
  __int64 v13; // rax
  signed __int64 v14; // rcx
  _DWORD *v15; // eax
  int v16; // edx
  int v17; // ebx
  int v18; // ecx
  int v19; // edi
  int v20; // eax
  int v21; // eax
  _DWORD *v22; // eax
  int v23; // edx
  int v24; // ebx
  int v25; // eax
  int v26; // ebx
  int v27; // ecx
  _DWORD *v28; // ecx
  int v29; // ebx
  int v30; // ecx
  int v31; // esi
  int v32; // eax
  unsigned int v33; // esi
  int v34; // edx
  int v35; // eax
  int (__cdecl *v36)(int *, int, int); // ecx
  int v37; // edx
  int v38; // eax
  int v39; // eax
  int v40; // edx
  int v41; // eax
  int v42; // edx
  int v43; // ecx
  _DWORD *v44; // eax
  int v45; // edx
  unsigned int v46; // ebx
  int v47; // edx
  int v48; // edi
  __int64 v49; // rax
  unsigned int v50; // ecx
  int v51; // edi
  int v52; // eax
  int v53; // edx
  _DWORD *v54; // eax
  int v55; // esi
  int v56; // edx
  int v57; // eax
  int v58; // edx
  __int64 v59; // rax
  int v60; // ecx
  int v61; // edx
  __int64 v62; // rax
  int v63; // edi
  int v64; // edi
  int v65; // ebx
  int v66; // eax
  int v67; // esi
  int v68; // ebx
  int v69; // esi
  signed __int64 v71; // [esp+0h] [ebp-B4h]
  unsigned int v72; // [esp+0h] [ebp-B4h]
  __int64 v73; // [esp+0h] [ebp-B4h]
  const struct timespec *v74; // [esp+0h] [ebp-B4h]
  __int64 v75; // [esp+0h] [ebp-B4h]
  unsigned int v76; // [esp+Ch] [ebp-A8h]
  int v77; // [esp+Ch] [ebp-A8h]
  unsigned int v78; // [esp+Ch] [ebp-A8h]
  int v79; // [esp+Ch] [ebp-A8h]
  int v80; // [esp+10h] [ebp-A4h]
  unsigned __int64 v81; // [esp+10h] [ebp-A4h]
  __int64 v82; // [esp+10h] [ebp-A4h]
  unsigned int v83; // [esp+10h] [ebp-A4h]
  int *v84; // [esp+10h] [ebp-A4h]
  int v85; // [esp+18h] [ebp-9Ch]
  int v86; // [esp+1Ch] [ebp-98h]
  unsigned int v87; // [esp+1Ch] [ebp-98h]
  int v88; // [esp+1Ch] [ebp-98h]
  int v89; // [esp+20h] [ebp-94h]
  int v90; // [esp+20h] [ebp-94h]
  int v91; // [esp+20h] [ebp-94h]
  int v92; // [esp+24h] [ebp-90h]
  int *v93; // [esp+28h] [ebp-8Ch] BYREF
  int v94[4]; // [esp+2Ch] [ebp-88h] BYREF
  int v95; // [esp+3Ch] [ebp-78h]
  __int64 v96; // [esp+58h] [ebp-5Ch]
  int v97; // [esp+8Ch] [ebp-28h] BYREF
  int v98; // [esp+90h] [ebp-24h]
  unsigned int v99; // [esp+94h] [ebp-20h]

  v4 = (int)&GLOBAL_OFFSET_TABLE_;
  v71 = a2;
  v99 = __readgsdword(0x14u);
  v5 = (unsigned int *)a1[22];
  if ( !a4 )
  {
    if ( v5[6] )
    {
      v46 = v5[3];
      v47 = *a1;
      v72 = v5[4];
      v85 = *a1 & 0x1000;
      if ( v72 > v46 && (v47 & 0x1000) != 0 )
      {
        v48 = a1[37];
        if ( (char *)&_start___libc_atexit - (char *)_start___libc_IO_vtables <= (unsigned int)(v48
                                                                                              - (_DWORD)_start___libc_IO_vtables) )
          IO_vtable_check();
        v49 = ((__int64 (__cdecl *)(int *, _DWORD, _DWORD, int))*(_DWORD *)(v48 + 64))(a1, 0, 0, 2);
        if ( (HIDWORD(v49) & (unsigned int)v49) == -1 )
          goto LABEL_76;
        a1[19] = v49;
        v5 = (unsigned int *)a1[22];
        a1[20] = HIDWORD(v49);
        v47 = *a1;
      }
      v50 = *v5;
      v78 = v5[1];
      if ( (v47 & 0x100) != 0 )
      {
        if ( v5[1] > v50 )
        {
LABEL_75:
          __writegsdword(0xFFFFFFE0, 0x16u);
          goto LABEL_76;
        }
        v50 = v5[8];
        v87 = v50;
        v78 = v5[10];
      }
      else
      {
        v87 = v5[2];
      }
      v83 = v50;
      v51 = a1[21];
      v52 = (*(int (__cdecl **)(int))(v51 + 16))(v51);
      if ( v72 > v46 )
      {
        v60 = a1[22];
        v61 = *(_DWORD *)(v60 + 12);
        v79 = *(_DWORD *)(v60 + 16);
        v74 = (const struct timespec *)(v79 - v61);
        if ( v52 <= 0 )
        {
          v91 = *(_DWORD *)(v60 + 12);
          v88 = a1[22];
          v84 = malloc(v74);
          v68 = *(_DWORD *)(v88 + 52);
          v69 = *(_DWORD *)(v88 + 56);
          v93 = v84;
          v94[0] = v91;
          v97 = v68;
          v98 = v69;
          if ( (*(int (__cdecl **)(int, int *, int, int, int *, int *, int, int **))(v51 + 4))(
                 v51,
                 &v97,
                 v91,
                 v79,
                 v94,
                 v84,
                 (int)v74 + (_DWORD)v84,
                 &v93) )
          {
            free((int)&GLOBAL_OFFSET_TABLE_, (int *)v51, (int)v84);
            LODWORD(v9) = -1;
            return v9;
          }
          v75 = (char *)v93 - (char *)v84;
          free((int)&GLOBAL_OFFSET_TABLE_, (int *)((char *)v93 - (char *)v84), (int)v84);
          v62 = v75;
        }
        else
        {
          v62 = v52 * ((v79 - v61) >> 2);
        }
        v63 = a1[5];
        if ( v85 )
          v64 = v63 - a1[4];
        else
          v64 = v63 - a1[2];
        v73 = v62 + v64;
      }
      else
      {
        v53 = a1[2];
        if ( v52 <= 0 )
        {
          v66 = a1[22];
          v67 = *(_DWORD *)(v66 + 56);
          v97 = *(_DWORD *)(v66 + 52);
          v98 = v67;
          v73 = -(__int64)(a1[2]
                         - a1[3]
                         - (*(int (__cdecl **)(int, int *, int, int, int))(v51 + 24))(
                             v51,
                             &v97,
                             a1[3],
                             v53,
                             (int)(v83 - v87) >> 2));
        }
        else
        {
          v73 = -(__int64)(v52 * ((int)(v78 - v83) >> 2)) - (v53 - a1[1]);
        }
      }
    }
    else
    {
      v73 = 0LL;
    }
    v59 = *(_QWORD *)(a1 + 19);
    if ( (HIDWORD(v59) & (unsigned int)v59) == -1 )
    {
      v65 = a1[37];
      if ( (char *)&_start___libc_atexit - (char *)_start___libc_IO_vtables <= (unsigned int)(v65
                                                                                            - (_DWORD)_start___libc_IO_vtables) )
        IO_vtable_check();
      v59 = ((__int64 (__cdecl *)(int *, _DWORD, _DWORD, int))*(_DWORD *)(v65 + 64))(a1, 0, 0, 1);
      if ( (HIDWORD(v59) & (unsigned int)v59) == -1 )
        goto LABEL_76;
    }
    v9 = v73 + v59;
    if ( v9 >= 0 )
      return v9;
    goto LABEL_75;
  }
  v6 = v5[3];
  v7 = v5[4];
  if ( v5[2] == v5[1] && v6 == v7 )
  {
    v86 = 1;
  }
  else
  {
    v86 = 0;
    if ( v6 < v7 )
      goto LABEL_4;
  }
  if ( (*a1 & 0x800) == 0 )
  {
    v10 = v5[6];
    if ( !v10 )
      goto LABEL_29;
LABEL_6:
    if ( a3 == 1 )
      goto LABEL_32;
    goto LABEL_7;
  }
LABEL_4:
  v8 = IO_switch_to_wget_mode(a1);
  LODWORD(v9) = -1;
  if ( v8 )
    return v9;
  v5 = (unsigned int *)a1[22];
  v10 = v5[6];
  if ( v10 )
    goto LABEL_6;
LABEL_29:
  v20 = v5[2];
  if ( v20 )
  {
    free((int)&GLOBAL_OFFSET_TABLE_, (int *)v10, v20);
    *a1 &= ~0x100u;
  }
  IO_doallocbuf(a1);
  v21 = a1[7];
  a1[5] = v21;
  a1[4] = v21;
  a1[6] = v21;
  a1[3] = v21;
  a1[1] = v21;
  a1[2] = v21;
  v22 = (_DWORD *)a1[22];
  v23 = v22[6];
  v22[4] = v23;
  v22[3] = v23;
  v22[5] = v23;
  v22[2] = v23;
  *v22 = v23;
  v22[1] = v23;
  if ( a3 == 1 )
  {
LABEL_32:
    v24 = a1[21];
    v25 = (*(int (__cdecl **)(int))(v24 + 16))(v24);
    if ( v25 <= 0 )
    {
      v54 = (_DWORD *)a1[22];
      v55 = v54[13];
      v10 = v54[14];
      v54 += 11;
      v56 = *(v54 - 11) - *(v54 - 9);
      *v54 = v55;
      v54[1] = v10;
      v57 = (*(int (__cdecl **)(int, _DWORD *, int, int, int))(v24 + 24))(v24, v54, a1[3], a1[2], v56 >> 2);
      v58 = a1[3];
      a1[1] = v58 + v57;
      *(_DWORD *)(a1[22] + 4) = *(_DWORD *)a1[22];
      v71 = a2 - (a1[2] - v58 - v57);
    }
    else
    {
      v71 = a2 - ((*(_DWORD *)(a1[22] + 4) - *(_DWORD *)a1[22]) >> 2) * v25 - (a1[2] - a1[1]);
    }
    v12 = *(_QWORD *)(a1 + 19);
    if ( (HIDWORD(v12) & (unsigned int)v12) == -1 )
      goto LABEL_35;
    goto LABEL_13;
  }
LABEL_7:
  if ( a3 != 2 )
    goto LABEL_14;
  v11 = a1[37];
  v10 = (int)_start___libc_IO_vtables;
  v76 = (char *)&_start___libc_atexit - (char *)_start___libc_IO_vtables;
  if ( (char *)&_start___libc_atexit - (char *)_start___libc_IO_vtables <= (unsigned int)(v11
                                                                                        - (_DWORD)_start___libc_IO_vtables) )
    IO_vtable_check();
  if ( (*(int (__cdecl **)(int *, int *))(v11 + 72))(a1, v94) || (v95 & 0xF000) != 0x8000 )
    goto LABEL_36;
  v12 = v96;
LABEL_13:
  v71 += v12;
  a3 = 0;
LABEL_14:
  IO_free_wbackup_area((int)&GLOBAL_OFFSET_TABLE_, (int *)v10, a1);
  v13 = *(_QWORD *)(a1 + 19);
  if ( (HIDWORD(v13) & a1[19]) == -1 )
  {
    v80 = *a1;
LABEL_42:
    v10 = v80 & 4;
    v76 = (char *)&_start___libc_atexit - (char *)_start___libc_IO_vtables;
    v89 = v10;
    if ( (v80 & 4) != 0 )
      goto LABEL_36;
    v30 = a1[8];
    v31 = a1[7] - v30;
    v32 = v31 >> 31;
    v33 = v71 & v31;
    v81 = __PAIR64__(HIDWORD(v71) & (unsigned int)v32, v33);
    v4 = (v71 - __PAIR64__(HIDWORD(v71) & (unsigned int)v32, v33)) >> 32;
    v10 = v71 - v33;
    if ( v30 - a1[7] < (__int64)(v71 - __PAIR64__(HIDWORD(v71) & (unsigned int)v32, v33)) )
    {
      v81 = v71;
      v10 = 0;
      v4 = 0;
    }
    v34 = a1[37];
    if ( v34 - (int)_start___libc_IO_vtables >= v76 )
    {
      v92 = a1[37];
      IO_vtable_check();
      v34 = v92;
    }
    v82 = ((__int64 (__cdecl *)(int *, _DWORD, _DWORD, _DWORD))*(_DWORD *)(v34 + 64))(a1, v81, HIDWORD(v81), 0);
    if ( v82 >= 0 )
    {
      if ( v10 | v4 )
      {
        v35 = a1[37];
        if ( v35 - (int)_start___libc_IO_vtables >= v76 )
        {
          v90 = a1[37];
          IO_vtable_check();
          v35 = v90;
        }
        v36 = *(int (__cdecl **)(int *, int, int))(v35 + 56);
        v37 = a1[7];
        if ( v86 )
          v38 = v10;
        else
          v38 = a1[8] - v37;
        v39 = v36(a1, v37, v38);
        v89 = v39;
        if ( v39 < __SPAIR64__(v4, v10) )
        {
          if ( v39 == -1 )
          {
            v71 = __PAIR64__(v4, v10);
            a3 = 1;
          }
          else
          {
            a3 = 1;
            v4 = (__PAIR64__(v4, v10) - v39) >> 32;
            v10 -= v39;
            v71 = __PAIR64__(v4, v10);
          }
          goto LABEL_36;
        }
        v40 = v39;
      }
      else
      {
        v40 = 0;
      }
      v41 = a1[7];
      a1[3] = v41;
      v42 = v41 + v40;
      v43 = v41 + v10;
      a1[5] = v41;
      a1[4] = v41;
      a1[6] = v41;
      v44 = (_DWORD *)a1[22];
      a1[2] = v42;
      v45 = v44[6];
      a1[1] = v43;
      v44[2] = v45;
      *v44 = v45;
      v44[1] = v45;
      v44[4] = v45;
      v44[3] = v45;
      v44[5] = v45;
      if ( !adjust_wide_data(a1, 1) )
      {
        *(_QWORD *)(a1 + 19) = v82 + v89;
        LODWORD(v9) = v71;
        *a1 &= ~0x10u;
        return v9;
      }
      goto LABEL_36;
    }
LABEL_76:
    LODWORD(v9) = -1;
    return v9;
  }
  v80 = *a1;
  if ( !a1[3] )
    goto LABEL_42;
  if ( (*a1 & 0x100) != 0 )
    goto LABEL_42;
  v77 = a1[7];
  v14 = v13 - (a1[2] - v77);
  if ( v71 < v14 )
    goto LABEL_42;
  v10 = (unsigned __int64)(v71 - v13) >> 32;
  if ( v71 >= v13 )
    goto LABEL_42;
  a1[3] = v77;
  a1[1] = v77 + v71 - v14;
  v15 = (_DWORD *)a1[22];
  a1[5] = v77;
  a1[4] = v77;
  a1[6] = v77;
  v16 = v15[6];
  v15[2] = v16;
  *v15 = v16;
  v15[1] = v16;
  v15[4] = v16;
  v15[3] = v16;
  v15[5] = v16;
  if ( adjust_wide_data(a1, 0) )
  {
LABEL_35:
    v76 = (char *)&_start___libc_atexit - (char *)_start___libc_IO_vtables;
LABEL_36:
    IO_unsave_markers(v4, (int *)v10, a1);
    v26 = a1[37];
    if ( v26 - (int)_start___libc_IO_vtables >= v76 )
      IO_vtable_check();
    v9 = ((__int64 (__cdecl *)(int *, _DWORD, _DWORD, int))*(_DWORD *)(v26 + 64))(a1, v71, HIDWORD(v71), a3);
    if ( (HIDWORD(v9) & (unsigned int)v9) != -1 )
    {
      v27 = a1[7];
      *a1 &= ~0x10u;
      a1[19] = v9;
      a1[3] = v27;
      a1[1] = v27;
      a1[2] = v27;
      a1[5] = v27;
      a1[4] = v27;
      a1[6] = v27;
      v28 = (_DWORD *)a1[22];
      a1[20] = HIDWORD(v9);
      v29 = v28[6];
      v28[2] = v29;
      *v28 = v29;
      v28[1] = v29;
      v28[4] = v29;
      v28[3] = v29;
      v28[5] = v29;
    }
    return v9;
  }
  v17 = a1[20];
  *a1 &= ~0x10u;
  v18 = a1[19];
  if ( v17 >= 0 )
  {
    v19 = a1[37];
    if ( (char *)&_start___libc_atexit - (char *)_start___libc_IO_vtables <= (unsigned int)(v19
                                                                                          - (_DWORD)_start___libc_IO_vtables) )
    {
      IO_vtable_check();
      v18 = a1[19];
      v17 = a1[20];
    }
    (*(void (__cdecl **)(int *, int, int, _DWORD))(v19 + 64))(a1, v18, v17, 0);
  }
  LODWORD(v9) = v71;
  return v9;
}
// 80CE000: using guessed type _TBYTE GLOBAL_OFFSET_TABLE_;
// 80CEFA0: using guessed type int _start___libc_IO_vtables[24];
// 80CF2F4: using guessed type int (*_start___libc_atexit)();

//----- (080524E0) --------------------------------------------------------
int __usercall IO_wfile_underflow_maybe_mmap@<eax>(int a1@<ebp>, int *a2)
{
  if ( IO_file_underflow_maybe_mmap(a1, a2) == -1 )
    return -1;
  else
    return (*(int (__cdecl **)(int *))(*(_DWORD *)(a2[22] + 176) + 16))(a2);
}

//----- (08052530) --------------------------------------------------------
int __usercall IO_wfile_underflow_mmap@<eax>(int a1@<ebp>, _DWORD *a2)
{
  int *v2; // eax
  int v3; // edx
  int *v4; // edi
  unsigned int v5; // ecx
  int v6; // edx
  int v7; // ebp
  int v8; // edi
  _DWORD *v9; // ebp
  _DWORD *v10; // eax
  int *v11; // eax
  int result; // eax
  int v13; // eax
  int *v14; // [esp+0h] [ebp-30h]
  int v15[9]; // [esp+Ch] [ebp-24h] BYREF

  v15[1] = __readgsdword(0x14u);
  if ( (*a2 & 4) != 0 )
  {
    *a2 |= 0x20u;
    __writegsdword(0xFFFFFFE0, 9u);
    return -1;
  }
  else
  {
    v2 = (int *)a2[22];
    v3 = *v2;
    if ( *v2 < (unsigned int)v2[1] )
      return *(_DWORD *)v3;
    v4 = (int *)a2[21];
    v5 = a2[1];
    v14 = v4;
    if ( v5 < a2[2] )
    {
      v6 = v2[6];
      v15[0] = a2[1];
      if ( v6 )
        goto LABEL_5;
LABEL_10:
      v13 = v2[8];
      if ( v13 )
      {
        free(a1, v4, v13);
        *a2 &= ~0x100u;
      }
      IO_wdoallocbuf(a1, v4, (int)a2);
      v2 = (int *)a2[22];
      v5 = a2[1];
      v6 = v2[6];
LABEL_5:
      v7 = v2[12];
      v8 = v2[11];
      *v2 = v6;
      v2[2] = v6;
      v2[14] = v7;
      v9 = v2 + 1;
      v10 = v2 + 11;
      v10[2] = v8;
      ((void (__cdecl *)(int *, _DWORD *, unsigned int, _DWORD, int *, int, _DWORD, _DWORD *))v14[3])(
        v14,
        v10,
        v5,
        a2[2],
        v15,
        v6,
        *(v10 - 4),
        v9);
      a2[1] = v15[0];
      v11 = (int *)a2[22];
      v3 = *v11;
      if ( *v11 >= (unsigned int)v11[1] )
      {
        __writegsdword(0xFFFFFFE0, 0x54u);
        result = -1;
        *a2 |= 0x20u;
        return result;
      }
      return *(_DWORD *)v3;
    }
    if ( IO_file_underflow_mmap(a2) != -1 )
    {
      v2 = (int *)a2[22];
      v5 = a2[1];
      v6 = v2[6];
      v15[0] = v5;
      if ( v6 )
        goto LABEL_5;
      goto LABEL_10;
    }
    return -1;
  }
}

//----- (080526A0) --------------------------------------------------------
int __cdecl IO_wdo_write(int *a1, int a2, int a3)
{
  int v3; // ebp
  int v5; // ecx
  char *v6; // edx
  char *v7; // ebx
  unsigned int *v8; // eax
  int result; // eax
  _DWORD *v10; // edx
  int v11; // eax
  int v12; // ecx
  int v13; // ecx
  int v14; // [esp+0h] [ebp-58h]
  int v15; // [esp+0h] [ebp-58h]
  int v16; // [esp+4h] [ebp-54h]
  int v17; // [esp+20h] [ebp-38h] BYREF
  char *v18; // [esp+24h] [ebp-34h]
  char v19[16]; // [esp+28h] [ebp-30h] BYREF
  unsigned int v20; // [esp+38h] [ebp-20h] BYREF

  v3 = a3;
  v20 = __readgsdword(0x14u);
  if ( a3 )
  {
    v5 = a1[21];
    v6 = (char *)a1[5];
    v7 = (char *)a1[4];
    if ( (char *)a1[6] != v6 || v6 == v7 )
      goto LABEL_11;
    v15 = a1[21];
    result = IO_new_do_write((int)a1, (unsigned int)v7, v6 - v7);
    if ( result != -1 )
    {
      v6 = (char *)a1[5];
      v7 = (char *)a1[4];
      v5 = v15;
LABEL_11:
      while ( 1 )
      {
        if ( (unsigned int)(v6 - v7) <= 0xF )
        {
          v7 = v19;
          v8 = &v20;
          v18 = v19;
          v6 = v19;
        }
        else
        {
          v18 = v6;
          v8 = (unsigned int *)a1[8];
        }
        v16 = v5;
        v14 = (*(int (__cdecl **)(int, int, int, int, int *, char *, unsigned int *))(v5 + 4))(
                v5,
                a1[22] + 44,
                a2,
                a2 + 4 * v3,
                &v17,
                v6,
                v8);
        result = IO_new_do_write((int)a1, (unsigned int)v7, v18 - v7);
        if ( result == -1 )
          break;
        v5 = v16;
        v3 -= (v17 - a2) >> 2;
        if ( v14 && (v17 == a2 || v14 != 1) )
        {
          v10 = (_DWORD *)a1[22];
          v13 = v10[6];
          result = -(v3 != 0);
          v10[2] = v13;
          *v10 = v13;
          v10[1] = v13;
          v10[4] = v13;
          v10[3] = v13;
          if ( (*a1 & 0x202) != 0 )
            goto LABEL_17;
          goto LABEL_16;
        }
        if ( !v3 )
          goto LABEL_13;
        v6 = (char *)a1[5];
        v7 = (char *)a1[4];
        a2 = v17;
      }
    }
  }
  else
  {
LABEL_13:
    v10 = (_DWORD *)a1[22];
    v11 = *a1;
    v12 = v10[6];
    v10[2] = v12;
    *v10 = v12;
    v10[1] = v12;
    v10[4] = v12;
    v10[3] = v12;
    result = v11 & 0x202;
    if ( result )
    {
      v10[5] = v12;
      return 0;
    }
    else
    {
LABEL_16:
      v13 = v10[7];
LABEL_17:
      v10[5] = v13;
    }
  }
  return result;
}

//----- (08052860) --------------------------------------------------------
int __usercall IO_wfile_overflow@<eax>(int *a1@<edi>, int *a2, int a3)
{
  int v3; // edx
  int *v4; // eax
  int v5; // ecx
  int v6; // ebp
  int v7; // esi
  int *v8; // edx
  int *v9; // eax
  bool v12; // al
  int v13; // edi
  int v14; // edi
  int v15; // [esp+18h] [ebp-24h]
  int v16; // [esp+1Ch] [ebp-20h]

  v3 = *a2;
  if ( (*a2 & 8) != 0 )
  {
    *a2 = v3 | 0x20;
    __writegsdword(0xFFFFFFE0, 9u);
    return -1;
  }
  if ( (v3 & 0x800) == 0 )
  {
    v4 = (int *)a2[22];
    if ( v4[3] )
    {
      v5 = *v4;
      v15 = v4[7];
      if ( *v4 == v15 )
      {
        v7 = a2[7];
        v5 = v4[6];
        a2[2] = v7;
        v6 = v5;
        *v4 = v5;
        v4[1] = v5;
        v16 = v7;
      }
      else
      {
        v6 = v4[1];
        v7 = a2[1];
        v16 = a2[2];
      }
    }
    else
    {
      IO_wdoallocbuf(0, a1, (int)a2);
      IO_free_wbackup_area(0, a1, a2);
      v4 = (int *)a2[22];
      v13 = a2[4];
      v5 = v4[6];
      v4[2] = v5;
      *v4 = v5;
      v4[1] = v5;
      if ( v13 )
      {
        v6 = v5;
        v3 = *a2;
        v15 = v4[7];
        v7 = a2[1];
        v16 = a2[2];
      }
      else
      {
        IO_doallocbuf(a2);
        v4 = (int *)a2[22];
        v7 = a2[7];
        v3 = *a2;
        v14 = v4[7];
        v5 = *v4;
        a2[2] = v7;
        v6 = v4[1];
        v15 = v14;
        v16 = v7;
      }
    }
    v4[4] = v5;
    v4[3] = v5;
    v4[5] = v15;
    *v4 = v6;
    v4[2] = v6;
    a2[5] = v7;
    a2[4] = v7;
    a2[6] = a2[8];
    a2[1] = v16;
    a2[3] = v16;
    *a2 = v3 | 0x800;
    if ( (v3 & 0x202) != 0 )
    {
      v4[5] = v5;
      if ( a3 != -1 )
        goto LABEL_8;
LABEL_19:
      if ( a2[26] <= 0 )
        return IO_new_do_write((int)a2, a2[4], a2[5] - a2[4]);
      else
        return IO_wdo_write(a2, *(_DWORD *)(a2[22] + 12), (*(_DWORD *)(a2[22] + 16) - *(_DWORD *)(a2[22] + 12)) >> 2);
    }
  }
  if ( a3 == -1 )
    goto LABEL_19;
LABEL_8:
  v8 = (int *)a2[22];
  v9 = (int *)v8[4];
  if ( v9 == (int *)v8[7] )
  {
    if ( a2[26] <= 0 )
      v12 = IO_new_do_write((int)a2, a2[4], a2[5] - a2[4]) == -1;
    else
      v12 = IO_wdo_write(a2, v8[3], ((int)v9 - v8[3]) >> 2) == -1;
    if ( v12 )
      return -1;
    v8 = (int *)a2[22];
    v9 = (int *)v8[4];
  }
  v8[4] = (int)(v9 + 1);
  *v9 = a3;
  if ( ((*a2 & 2) != 0 || (*a2 & 0x200) != 0 && a3 == 10)
    && (a2[26] <= 0 ? IO_new_do_write((int)a2, a2[4], a2[5] - a2[4]) == -1 : IO_wdo_write(
                                                                               a2,
                                                                               v8[3],
                                                                               ((int)v9 - v8[3] + 4) >> 2) == -1) )
  {
    return -1;
  }
  return a3;
}

//----- (08052B30) --------------------------------------------------------
int __cdecl IO_wfile_sync(int *a1)
{
  int *v1; // edx
  unsigned int v2; // eax
  unsigned int v3; // ecx
  int v4; // edi
  int v5; // ebp
  int v6; // eax
  int v7; // edi
  int v8; // ebp
  __int64 v9; // rax
  int result; // eax
  _DWORD *v11; // ecx
  int v12; // edx
  int v13; // eax
  int v14; // edi
  int v15; // eax
  int v16; // edx
  int v17; // ecx
  int v18; // edx
  int v19; // [esp+0h] [ebp-20h]

  v1 = (int *)a1[22];
  v2 = v1[4];
  v3 = v1[3];
  if ( v2 <= v3 )
    goto LABEL_5;
  if ( a1[26] <= 0 )
  {
    if ( !IO_new_do_write((int)a1, a1[4], a1[5] - a1[4]) )
      goto LABEL_4;
    return -1;
  }
  if ( IO_wdo_write(a1, v3, (int)(v2 - v3) >> 2) )
    return -1;
LABEL_4:
  v1 = (int *)a1[22];
LABEL_5:
  v4 = *v1;
  v19 = v1[1];
  if ( *v1 == v19 )
  {
LABEL_12:
    a1[19] = -1;
    result = 0;
    a1[20] = -1;
    return result;
  }
  v5 = a1[21];
  v6 = (*(int (__cdecl **)(int))(v5 + 16))(v5);
  if ( v6 <= 0 )
  {
    v11 = (_DWORD *)a1[22];
    v12 = v11[14];
    v13 = v11[13];
    v11 += 11;
    v14 = *(v11 - 11) - *(v11 - 9);
    v11[1] = v12;
    *v11 = v13;
    v15 = (*(int (__cdecl **)(int, _DWORD *, int, int, int))(v5 + 24))(v5, v11, a1[3], a1[2], v14 >> 2);
    v16 = a1[3];
    v17 = v16 + v15;
    v18 = v16 - a1[2];
    a1[1] = v17;
    v7 = v18 + v15;
  }
  else
  {
    v7 = v6 * ((v4 - v19) >> 2);
  }
  v8 = a1[37];
  if ( (char *)&_start___libc_atexit - (char *)_start___libc_IO_vtables <= (unsigned int)(v8
                                                                                        - (_DWORD)_start___libc_IO_vtables) )
    IO_vtable_check();
  v9 = ((__int64 (__cdecl *)(int *, int, int, int))*(_DWORD *)(v8 + 64))(a1, v7, v7 >> 31, 1);
  if ( (HIDWORD(v9) & (unsigned int)v9) != -1 )
  {
    *(_DWORD *)(a1[22] + 4) = *(_DWORD *)a1[22];
    a1[2] = a1[1];
    goto LABEL_12;
  }
  if ( __readgsdword(0xFFFFFFE0) == 29 )
    goto LABEL_12;
  return -1;
}
// 80CEFA0: using guessed type int _start___libc_IO_vtables[24];
// 80CF2F4: using guessed type int (*_start___libc_atexit)();

//----- (08052CB0) --------------------------------------------------------
unsigned int __cdecl IO_wfile_xsputn(int *a1, char *a2, unsigned int a3)
{
  unsigned int result; // eax
  unsigned int v4; // ebp
  int *v5; // edx
  _DWORD *v6; // ecx
  _BYTE *v7; // edi
  unsigned int v8; // ebx
  char *v9; // esi
  _BYTE *v10; // eax
  unsigned int v11; // ebx
  int v12; // ecx
  int v13; // eax
  int v14; // ecx
  char *v15; // eax
  char *v16; // esi
  unsigned int v17; // eax
  int v18; // [esp+8h] [ebp-24h]
  int *v19; // [esp+30h] [ebp+4h]

  result = 0;
  v4 = a3;
  v5 = a1;
  if ( !a3 )
    return result;
  v6 = (_DWORD *)a1[22];
  v7 = (_BYTE *)v6[4];
  if ( (*a1 & 0xA00) == 2560 )
  {
    v18 = 0;
    v8 = (v6[7] - (int)v7) >> 2;
    if ( a3 <= v8 )
    {
      v15 = &a2[4 * a3];
      if ( a2 < v15 )
      {
        v16 = v15 - 4;
        if ( *((_DWORD *)v15 - 1) == 10 )
        {
LABEL_27:
          v18 = 1;
          v8 = ((v16 - a2) >> 2) + 1;
        }
        else
        {
          while ( a2 < v16 )
          {
            v16 -= 4;
            if ( *(_DWORD *)v16 == 10 )
              goto LABEL_27;
          }
          v18 = 0;
        }
      }
    }
  }
  else
  {
    v18 = 0;
    v8 = (v6[5] - (int)v7) >> 2;
  }
  if ( v8 )
  {
    if ( a3 <= v8 )
      v8 = a3;
    if ( v8 > 0x14 )
    {
      v6[4] = wmempcpy(v7, a2, v8);
      a2 += 4 * v8;
      v5 = a1;
    }
    else
    {
      v9 = a2;
      v10 = &v7[4 * v8];
      do
      {
        *(_DWORD *)v7 = *(_DWORD *)v9;
        v9 += 4;
        v7 += 4;
      }
      while ( v7 != v10 );
      a2 += 4 * v8;
      v6[4] = v7;
    }
    v11 = a3 - v8;
    if ( !v11 )
      goto LABEL_12;
  }
  else
  {
    v11 = a3;
  }
  v19 = v5;
  v17 = IO_wdefault_xsputn(v5, (int *)a2, v11);
  v5 = v19;
  v4 = v17 - v11 + a3;
LABEL_12:
  if ( v18 )
  {
    v12 = v5[22];
    v13 = *(_DWORD *)(v12 + 16);
    v14 = *(_DWORD *)(v12 + 12);
    if ( v13 != v14 )
      IO_wdo_write(v5, v14, (v13 - v14) >> 2);
  }
  return v4;
}

//----- (08052E50) --------------------------------------------------------
__int64 __cdecl vasprintf(int **a1, unsigned int *a2, int a3)
{
  int *v3; // eax
  int v4; // edi
  unsigned int v5; // esi
  int *v6; // eax
  int *v7; // eax
  __int64 result; // rax
  int *v9; // [esp+18h] [ebp-D4h]
  const struct timespec *v10; // [esp+18h] [ebp-D4h]
  int *v11; // [esp+1Ch] [ebp-D0h]
  int v12[4]; // [esp+2Ch] [ebp-C0h] BYREF
  int v13; // [esp+3Ch] [ebp-B0h]
  int v14; // [esp+40h] [ebp-ACh]
  int v15; // [esp+44h] [ebp-A8h]
  int *v16; // [esp+48h] [ebp-A4h]
  int v17; // [esp+74h] [ebp-78h]
  void *v18; // [esp+C0h] [ebp-2Ch]
  int *(__cdecl *v19)(const struct timespec *); // [esp+C4h] [ebp-28h]
  int *(__usercall *v20)@<eax>(int@<ebp>, int *@<edi>, int); // [esp+C8h] [ebp-24h]
  unsigned int v21; // [esp+CCh] [ebp-20h]

  v21 = __readgsdword(0x14u);
  v9 = malloc((const struct timespec *)0x64);
  if ( !v9 )
  {
    v4 = -1;
    goto LABEL_8;
  }
  v17 = 0;
  IO_no_init(v12, 0x8000, -1, 0, 0);
  v18 = &IO_str_jumps;
  IO_str_init_static_internal(v12, v9, 100, (int)v9);
  v12[0] &= ~1u;
  v19 = malloc;
  v20 = free;
  vfprintf((int)&GLOBAL_OFFSET_TABLE_, (int)v12, (int)v12, a2, a3);
  v4 = (int)v3;
  if ( (int)v3 < 0 )
  {
    free((int)a2, v3, (int)v16);
    goto LABEL_8;
  }
  v5 = v14 - v13;
  if ( (unsigned int)(v15 - v13) >> 1 > v14 - v13 + 1 )
  {
    v11 = v16;
    v10 = (const struct timespec *)(v14 - v13 + 1);
    v6 = malloc(v10);
    *a1 = v6;
    if ( v6 )
    {
      memcpy(v6, v11, v5);
      free((int)a1, (int *)v4, (int)v11);
      v7 = *a1;
    }
    else
    {
      v7 = realloc((int)a1, v11, v10);
      *a1 = v7;
    }
    if ( v7 )
      goto LABEL_7;
    goto LABEL_10;
  }
  v7 = realloc(v15 - v13, v16, (const struct timespec *)(v14 - v13 + 1));
  *a1 = v7;
  if ( !v7 )
  {
LABEL_10:
    v7 = v16;
    *a1 = v16;
  }
LABEL_7:
  *((_BYTE *)v7 + v5) = 0;
LABEL_8:
  HIDWORD(result) = __readgsdword(0x14u) ^ v21;
  LODWORD(result) = v4;
  return result;
}
// 8052F12: variable 'v3' is possibly undefined
// 80CE000: using guessed type _TBYTE GLOBAL_OFFSET_TABLE_;

//----- (08053030) --------------------------------------------------------
unsigned int __cdecl _libc_message(char a1, char *a2, char a3)
{
  char *v3; // edi
  char v4; // al
  char v5; // dl
  unsigned int *v6; // eax
  unsigned int *v7; // ebx
  int v8; // ecx
  int v9; // edx
  int v10; // ebx
  int v11; // edi
  _QWORD *v12; // ecx
  __int16 v13; // di
  int v14; // eax
  int v15; // edi
  int *v16; // edx
  int *v17; // eax
  int v18; // edi
  int v19; // ecx
  int v20; // ebx
  int v21; // edx
  const struct iovec *v22; // ecx
  int v23; // ebx
  _DWORD *v24; // eax
  int v25; // ebx
  _WORD *v26; // eax
  int v27; // ebx
  __int32 v28; // ebx
  _DWORD *v29; // ebx
  _BYTE *v31; // eax
  void *v32; // esp
  unsigned int v33; // [esp-2028h] [ebp-2070h]
  _BYTE v34[4]; // [esp-2024h] [ebp-206Ch]
  _QWORD v35[512]; // [esp-2020h] [ebp-2068h] BYREF
  _DWORD v36[1032]; // [esp-1020h] [ebp-1068h] BYREF
  _QWORD *v37; // [esp+0h] [ebp-48h]
  unsigned int v38; // [esp+4h] [ebp-44h]
  int v39; // [esp+8h] [ebp-40h]
  char *v40; // [esp+Ch] [ebp-3Ch]
  int v41; // [esp+10h] [ebp-38h]
  int v42; // [esp+14h] [ebp-34h]
  int *v43; // [esp+18h] [ebp-30h]
  unsigned int *v44; // [esp+1Ch] [ebp-2Ch]
  unsigned int v45; // [esp+2Ch] [ebp-1Ch]
  int savedregs; // [esp+48h] [ebp+0h] BYREF

  v3 = a2;
  v45 = __readgsdword(0x14u);
  v40 = &a3;
  if ( (a1 & 2) == 0
    || (v31 = (_BYTE *)secure_getenv((__int16 *)"LIBC_FATAL_STDERR_")) != 0 && *v31
    || (v36[1029] = 2306, v38 = _open_nocancel((int)"/dev/tty"), v38 == -1) )
  {
    v38 = 2;
  }
  v4 = *a2;
  v42 = 0;
  v39 = a1 & 1;
  LOBYTE(v44) = v4;
  v43 = 0;
  if ( v4 )
  {
    while ( 1 )
    {
      v5 = (char)v44;
      v6 = (unsigned int *)v3;
      do
      {
        if ( v5 == 37 && *((_BYTE *)v6 + 1) == 115 )
          break;
        v6 = strchrnul((unsigned int *)((char *)v6 + 1), 37);
        v5 = *(_BYTE *)v6;
      }
      while ( *(_BYTE *)v6 );
      if ( (_BYTE)v44 == 37 && v3[1] == 115 )
      {
        v3 += 2;
        v7 = *(unsigned int **)v40;
        v40 += 4;
        v8 = strlen(v7);
      }
      else
      {
        v7 = (unsigned int *)v3;
        v8 = (char *)v6 - v3;
        v3 = (char *)v6;
      }
      v36[2] = v43;
      v36[0] = v7;
      v36[1] = v8;
      v41 = v42 + 1;
      LOBYTE(v44) = *v3;
      if ( !(_BYTE)v44 )
        break;
      v43 = v36;
      v42 = v41;
    }
    v9 = v41;
    v44 = v7;
    v10 = v8;
    v11 = 8 * v41 + 27;
    v12 = (_QWORD *)((char *)v36 - (v11 & 0xFFFFF000));
    v13 = v11 & 0xFFF0;
    if ( v36 != (_DWORD *)v12 )
    {
      while ( v35 != v12 )
        ;
    }
    v14 = v13 & 0xFFF;
    if ( (v13 & 0xFFF) != 0 )
    {
      v32 = alloca(v14);
      *(_DWORD *)&v34[v14] = *(_DWORD *)&v34[v14];
    }
    v15 = v42;
    v42 = v9;
    v16 = v43;
    v41 = (int)v35;
    v40 = (char *)(8 * v15);
    v17 = (int *)&v35[v15];
    v18 = 0;
    v37 = v35;
    v19 = (int)v44;
    while ( 1 )
    {
      *v17 = v19;
      v17[1] = v10;
      v20 = v18 + v10;
      v18 = v20;
      v44 = (unsigned int *)(v17 - 2);
      if ( (int *)v41 == v17 )
        break;
      v19 = *v16;
      v10 = v16[1];
      v17 = (int *)v44;
      v16 = (int *)v16[2];
    }
    v21 = v42;
    v22 = (const struct iovec *)v41;
    v44 = (unsigned int *)v20;
    v23 = v38;
    while ( sys_writev(v23, v22, v21) == -4 )
      ;
    if ( v39 )
    {
      v3 = (char *)(-dl_pagesize & ((unsigned int)v44 + dl_pagesize));
      v24 = (_DWORD *)mmap(0, (size_t)v3, 3, 34, -1, 0);
      v25 = (int)v24;
      if ( v24 != (_DWORD *)-1 )
      {
        *v24 = v3;
        v26 = v24 + 1;
        v44 = (unsigned int *)v25;
        v27 = (int)v37;
        v3 = &v40[v41 + 8];
        do
        {
          v33 = *(_DWORD *)(v27 + 4);
          v27 += 8;
          v26 = mempcpy(v26, *(_BYTE **)(v27 - 8), v33);
        }
        while ( (char *)v27 != v3 );
        v28 = (__int32)v44;
        *(_BYTE *)v26 = 0;
        v29 = (_DWORD *)_InterlockedExchange(&_abort_msg, v28);
        if ( v29 )
          munmap(v29, *v29);
      }
LABEL_29:
      abort((int)&savedregs, (int *)v3, (const struct timespec *)&GLOBAL_OFFSET_TABLE_);
    }
  }
  else if ( v39 )
  {
    goto LABEL_29;
  }
  return __readgsdword(0x14u) ^ v45;
}
// 8053202: variable 'v22' is possibly undefined
// 8053202: variable 'v21' is possibly undefined
// 80CE000: using guessed type _TBYTE GLOBAL_OFFSET_TABLE_;
// 80CE9B0: using guessed type int dl_pagesize;
// 80CF5E8: using guessed type int _abort_msg;

//----- (08053320) --------------------------------------------------------
void __cdecl __noreturn _libc_fatal(char a1)
{
  while ( 1 )
    _libc_message(3, "%s", a1);
}

//----- (08053360) --------------------------------------------------------
_TBYTE *IO_vtable_check()
{
  _TBYTE *result; // eax

  result = &GLOBAL_OFFSET_TABLE_;
  if ( !_dlopen )
    _libc_fatal((unsigned __int8)&aFatalErrorGlib[-135061504] + (unsigned __int8)&GLOBAL_OFFSET_TABLE_);
  return result;
}
// 80CE000: using guessed type _TBYTE GLOBAL_OFFSET_TABLE_;

//----- (08053390) --------------------------------------------------------
_BYTE *__cdecl fgets_unlocked(_BYTE *a1, int a2, int *a3)
{
  char v3; // bl
  int v4; // ebx
  _BYTE *v5; // eax
  int v6; // edx
  _BYTE *v7; // ecx

  if ( a2 <= 0 )
    return 0;
  if ( a2 == 1 )
  {
    *a1 = 0;
    return a1;
  }
  else
  {
    v3 = *a3;
    *a3 &= ~0x20u;
    v4 = v3 & 0x20;
    v5 = IO_getline(a3, a1, a2 - 1, 10, 1);
    v6 = *a3;
    v7 = 0;
    if ( v5 )
    {
      if ( (v6 & 0x20) == 0 || (v7 = 0, __readgsdword(0xFFFFFFE0) == 11) )
      {
        v5[(_DWORD)a1] = 0;
        v7 = a1;
        v6 = *a3;
      }
    }
    *a3 = v6 | v4;
  }
  return v7;
}

//----- (08053440) --------------------------------------------------------
int __cdecl IO_file_seekoff_maybe_mmap(_DWORD *a1, int a2, int a3, int a4)
{
  int v4; // ebp
  int result; // eax
  int v6; // edx

  v4 = a1[37];
  if ( (char *)&_start___libc_atexit - (char *)_start___libc_IO_vtables <= (unsigned int)(v4
                                                                                        - (_DWORD)_start___libc_IO_vtables) )
    IO_vtable_check();
  result = (*(int (__cdecl **)(_DWORD *, int, int, int))(v4 + 64))(a1, a2, a3, a4);
  if ( v6 < 0 )
    return -1;
  a1[19] = result;
  a1[20] = v6;
  return result;
}
// 805348D: variable 'v6' is possibly undefined
// 80CEFA0: using guessed type int _start___libc_IO_vtables[24];
// 80CF2F4: using guessed type int (*_start___libc_atexit)();

//----- (080534C0) --------------------------------------------------------
unsigned int __cdecl IO_file_close(int a1)
{
  return _close_nocancel(*(_DWORD *)(a1 + 56));
}

//----- (080534E0) --------------------------------------------------------
_DWORD *__cdecl IO_new_file_setbuf(_DWORD *a1, int *a2, int a3)
{
  _DWORD *result; // eax
  int v4; // eax

  result = IO_default_setbuf(a1, a2, a3);
  if ( result )
  {
    v4 = a1[7];
    a1[6] = v4;
    a1[5] = v4;
    a1[4] = v4;
    a1[3] = v4;
    a1[1] = v4;
    a1[2] = v4;
    return a1;
  }
  return result;
}

//----- (08053530) --------------------------------------------------------
_DWORD *__cdecl IO_file_setbuf_mmap(_DWORD *a1, int *a2, int a3)
{
  _DWORD *result; // eax
  int v4; // eax

  a1[37] = &IO_file_jumps;
  *(_DWORD *)(a1[22] + 176) = &IO_wfile_jumps;
  result = IO_default_setbuf(a1, a2, a3);
  if ( result )
  {
    v4 = a1[7];
    a1[6] = v4;
    a1[5] = v4;
    a1[4] = v4;
    a1[3] = v4;
    a1[1] = v4;
    a1[2] = v4;
    return a1;
  }
  else
  {
    a1[37] = &IO_file_jumps_mmap;
    *(_DWORD *)(a1[22] + 176) = &IO_wfile_jumps_mmap;
  }
  return result;
}

//----- (080535C0) --------------------------------------------------------
int __usercall new_do_write@<eax>(int a1@<eax>, unsigned int a2@<edx>, int a3@<ecx>)
{
  int v5; // ebp
  unsigned int v6; // edx
  int v7; // ebp
  int v8; // eax
  int v9; // eax
  int v10; // edx
  int v12; // ecx
  int v13; // eax
  __int64 v14; // rax
  unsigned int v15; // [esp+0h] [ebp-24h]

  v5 = *(_DWORD *)(a1 + 148);
  v6 = v5 - (_DWORD)_start___libc_IO_vtables;
  v15 = (char *)&_start___libc_atexit - (char *)_start___libc_IO_vtables;
  if ( (*(_DWORD *)a1 & 0x1000) != 0 )
  {
    *(_DWORD *)(a1 + 76) = -1;
    *(_DWORD *)(a1 + 80) = -1;
LABEL_3:
    if ( v15 <= v6 )
      IO_vtable_check();
    v7 = (*(int (__cdecl **)(int, unsigned int, int))(v5 + 60))(a1, a2, a3);
    v8 = *(unsigned __int16 *)(a1 + 68);
    if ( (_WORD)v8 && v7 )
      *(_WORD *)(a1 + 68) = IO_adjust_column(v8 - 1, a2, v7) + 1;
    v9 = *(_DWORD *)(a1 + 28);
    v10 = *(_DWORD *)(a1 + 104);
    *(_DWORD *)(a1 + 12) = v9;
    *(_DWORD *)(a1 + 4) = v9;
    *(_DWORD *)(a1 + 8) = v9;
    *(_DWORD *)(a1 + 20) = v9;
    *(_DWORD *)(a1 + 16) = v9;
    if ( v10 > 0 || (*(_DWORD *)a1 & 0x202) == 0 )
      v9 = *(_DWORD *)(a1 + 32);
    *(_DWORD *)(a1 + 24) = v9;
    return v7;
  }
  v12 = *(_DWORD *)(a1 + 8);
  v13 = *(_DWORD *)(a1 + 16);
  if ( v12 == v13 )
    goto LABEL_3;
  if ( v15 <= v6 )
  {
    IO_vtable_check();
    v13 = *(_DWORD *)(a1 + 16);
    v12 = *(_DWORD *)(a1 + 8);
  }
  v14 = ((__int64 (__cdecl *)(int, int, int, int))*(_DWORD *)(v5 + 64))(a1, v13 - v12, (v13 - v12) >> 31, 1);
  v7 = 0;
  if ( (HIDWORD(v14) & (unsigned int)v14) != -1 )
  {
    v5 = *(_DWORD *)(a1 + 148);
    *(_QWORD *)(a1 + 76) = v14;
    v6 = v5 - (_DWORD)_start___libc_IO_vtables;
    goto LABEL_3;
  }
  return v7;
}
// 80CEFA0: using guessed type int _start___libc_IO_vtables[24];
// 80CF2F4: using guessed type int (*_start___libc_atexit)();

//----- (080536F0) --------------------------------------------------------
int __cdecl IO_new_file_underflow(struct timespec *a1)
{
  __time_t tv_sec; // eax
  unsigned __int8 *tv_nsec; // edx
  int *v3; // ecx
  int v4; // eax
  unsigned int v6; // ebx
  bool v8; // zf
  int *v9; // edx
  int v10; // eax
  int v11; // ebx
  int v12; // eax
  __int64 v13; // rcx
  int result; // eax
  __time_t v15; // edx
  __time_t v16; // ecx
  int v17; // edx
  int v18; // ecx
  int v19; // ebx
  int v20; // [esp+0h] [ebp-28h]
  _DWORD *v21; // [esp+4h] [ebp-24h]
  unsigned int v22; // [esp+Ch] [ebp-1Ch]
  int savedregs; // [esp+28h] [ebp+0h] BYREF

  tv_sec = a1->tv_sec;
  if ( (a1->tv_sec & 0x10) != 0 )
    return -1;
  if ( (tv_sec & 4) != 0 )
  {
    a1->tv_sec = tv_sec | 0x20;
    __writegsdword(0xFFFFFFE0, 9u);
    return -1;
  }
  tv_nsec = (unsigned __int8 *)a1->tv_nsec;
  if ( (unsigned int)tv_nsec < a1[1].tv_sec )
    return *tv_nsec;
  if ( !a1[3].tv_nsec )
  {
    if ( a1[4].tv_nsec )
    {
      free((int)&savedregs, (int *)&GLOBAL_OFFSET_TABLE_, a1[4].tv_nsec);
      a1->tv_sec &= ~0x100u;
    }
    IO_doallocbuf(&a1->tv_sec);
    tv_sec = a1->tv_sec;
  }
  v22 = (char *)&_start___libc_atexit - (char *)_start___libc_IO_vtables;
  if ( (tv_sec & 0x202) != 0 )
  {
    v3 = (int *)stdout;
    v4 = *(_DWORD *)stdout;
    v21 = stdout;
    v20 = *(_DWORD *)stdout & 0x8000;
    if ( (*(_DWORD *)stdout & 0x8000) == 0 )
    {
      _EDX = (int *)*((_DWORD *)stdout + 18);
      v6 = __readgsdword(8u);
      if ( _EDX[2] != v6 )
      {
        _ECX = 1;
        v8 = __readgsdword(0xCu) == 0;
        if ( !v8 )
          __asm { lock }
        __asm { cmpxchg [edx], ecx }
        if ( !v8 )
          _lll_lock_wait_private(v20, _EDX, (int)&savedregs, (int *)&GLOBAL_OFFSET_TABLE_);
        _EDX = (int *)v21[18];
        v3 = (int *)stdout;
        _EDX[2] = v6;
        v4 = *v3;
      }
      ++_EDX[1];
      if ( (v4 & 0x288) != 640 )
        goto LABEL_14;
      goto LABEL_28;
    }
    if ( (*(_DWORD *)stdout & 0x288) == 640 )
    {
      v3 = (int *)stdout;
LABEL_28:
      v19 = v3[37];
      if ( v19 - (int)_start___libc_IO_vtables >= v22 )
        IO_vtable_check();
      (*(void (__cdecl **)(void *, int))(v19 + 12))(stdout, -1);
LABEL_14:
      if ( (*v21 & 0x8000) == 0 )
      {
        v9 = (int *)v21[18];
        v8 = v9[1]-- == 1;
        if ( v8 )
        {
          v9[2] = 0;
          if ( __readgsdword(0xCu) )
            __asm { lock }
          v8 = (*v9)-- == 1;
          if ( !v8 )
            _lll_unlock_wake_private(v9, (int)&savedregs, 0, a1);
        }
      }
    }
  }
  IO_switch_to_get_mode(&a1->tv_sec);
  v10 = a1[3].tv_nsec;
  v11 = a1[18].tv_nsec;
  a1->tv_nsec = v10;
  a1[1].tv_nsec = v10;
  a1[1].tv_sec = v10;
  a1[3].tv_sec = v10;
  a1[2].tv_nsec = v10;
  a1[2].tv_sec = v10;
  if ( v11 - (int)_start___libc_IO_vtables >= v22 )
  {
    IO_vtable_check();
    v10 = a1[3].tv_nsec;
  }
  v12 = (*(int (__cdecl **)(struct timespec *, int, int))(v11 + 56))(a1, v10, a1[4].tv_sec - v10);
  if ( v12 <= 0 )
  {
    v15 = a1->tv_sec;
    a1[9].tv_nsec = -1;
    a1[10].tv_sec = -1;
    v16 = v15;
    v17 = v15 | 0x10;
    v18 = v16 | 0x20;
    v8 = v12 == 0;
    result = -1;
    if ( !v8 )
      v17 = v18;
    a1->tv_sec = v17;
  }
  else
  {
    v13 = *(_QWORD *)&a1[9].tv_nsec;
    a1[1].tv_sec += v12;
    if ( (HIDWORD(v13) & (unsigned int)v13) != -1 )
      *(_QWORD *)&a1[9].tv_nsec = v13 + v12;
    return *(unsigned __int8 *)a1->tv_nsec;
  }
  return result;
}
// 80CE000: using guessed type _TBYTE GLOBAL_OFFSET_TABLE_;
// 80CE478: using guessed type void *stdout;
// 80CEFA0: using guessed type int _start___libc_IO_vtables[24];
// 80CF2F4: using guessed type int (*_start___libc_atexit)();

//----- (08053990) --------------------------------------------------------
unsigned int __cdecl IO_file_close_mmap(int a1)
{
  int v1; // eax

  munmap(*(void **)(a1 + 28), *(_DWORD *)(a1 + 32) - *(_DWORD *)(a1 + 28));
  v1 = *(_DWORD *)(a1 + 56);
  *(_DWORD *)(a1 + 32) = 0;
  *(_DWORD *)(a1 + 28) = 0;
  return _close_nocancel(v1);
}

//----- (080539D0) --------------------------------------------------------
int __usercall mmap_remap_check@<eax>(int a1@<eax>)
{
  int v2; // esi
  __int64 v3; // rdi
  int v4; // eax
  int v5; // edx
  char *v6; // ecx
  __int64 v7; // kr00_8
  loff_t v8; // rax
  int v9; // ecx
  int v10; // eax
  char *v11; // eax
  _TBYTE *v12; // edx
  int v14; // [esp+0h] [ebp-A4h]
  char *v15; // [esp+0h] [ebp-A4h]
  int v16; // [esp+8h] [ebp-9Ch]
  char *v17; // [esp+10h] [ebp-94h]
  int v18; // [esp+14h] [ebp-90h]
  char v19[16]; // [esp+24h] [ebp-80h] BYREF
  int v20; // [esp+34h] [ebp-70h]
  __int64 v21; // [esp+50h] [ebp-54h]
  unsigned int v22; // [esp+84h] [ebp-20h]

  v2 = *(_DWORD *)(a1 + 148);
  v22 = __readgsdword(0x14u);
  if ( (char *)&_start___libc_atexit - (char *)_start___libc_IO_vtables <= (unsigned int)(v2
                                                                                        - (_DWORD)_start___libc_IO_vtables) )
    IO_vtable_check();
  HIDWORD(v3) = (*(int (__cdecl **)(int, char *))(v2 + 72))(a1, v19);
  v17 = *(char **)(a1 + 28);
  v14 = *(_DWORD *)(a1 + 32) - (_DWORD)v17;
  if ( HIDWORD(v3) || (v20 & 0xF000) != 0x8000 || (v16 = v21, !v21) || v21 > 0xFFFFF )
  {
    munmap(v17, v14);
    goto LABEL_15;
  }
  v4 = getpagesize();
  v18 = -v4;
  LODWORD(v3) = (v16 + v4 - 1) & -v4;
  v5 = -v4 & (v4 + v14 - 1);
  if ( v3 < (unsigned int)v5 )
  {
    munmap(&v17[v18 & (v4 + v16 - 1)], v5 - (v18 & (v4 + v16 - 1)));
    v17 = *(char **)(a1 + 28);
    v15 = &v17[v21];
    *(_DWORD *)(a1 + 32) = &v17[v21];
LABEL_11:
    v7 = *(_QWORD *)(a1 + 76) - (*(_DWORD *)(a1 + 8) - *(_DWORD *)(a1 + 4));
    *(_QWORD *)(a1 + 76) = v7;
    *(_DWORD *)(a1 + 12) = v17;
    if ( v7 >= v15 - v17 )
    {
      *(_DWORD *)(a1 + 4) = v15;
      *(_DWORD *)(a1 + 8) = v15;
    }
    else
    {
      *(_DWORD *)(a1 + 4) = &v17[v7];
      *(_DWORD *)(a1 + 8) = v15;
      v8 = lseek64(*(_DWORD *)(a1 + 56), v15 - v17, (v15 - v17) >> 31, 0);
      v9 = *(_DWORD *)(a1 + 32) - *(_DWORD *)(a1 + 28);
      if ( v9 == v8 )
        *(_QWORD *)(a1 + 76) = v9;
      else
        *(_DWORD *)a1 |= 0x20u;
    }
    return HIDWORD(v3);
  }
  if ( (unsigned int)v5 >= (__int64)(unsigned int)v3 )
  {
    v15 = &v17[v16];
    *(_DWORD *)(a1 + 32) = &v17[v16];
    goto LABEL_11;
  }
  v17 = (char *)mremap(v17, v5, v18 & (v4 + v16 - 1), 1u);
  if ( v17 != (char *)-1 )
  {
    v6 = &v17[v21];
    *(_DWORD *)(a1 + 28) = v17;
    v15 = v6;
    *(_DWORD *)(a1 + 32) = v6;
    goto LABEL_11;
  }
  munmap(*(void **)(a1 + 28), *(_DWORD *)(a1 + 32) - *(_DWORD *)(a1 + 28));
LABEL_15:
  v10 = *(_DWORD *)(a1 + 104);
  *(_DWORD *)(a1 + 32) = 0;
  *(_DWORD *)(a1 + 28) = 0;
  *(_DWORD *)(a1 + 12) = 0;
  *(_DWORD *)(a1 + 4) = 0;
  *(_DWORD *)(a1 + 8) = 0;
  if ( v10 <= 0 )
  {
    v12 = &GLOBAL_OFFSET_TABLE_ + 448;
    v11 = (char *)&GLOBAL_OFFSET_TABLE_ + 4192;
  }
  else
  {
    v11 = (char *)&GLOBAL_OFFSET_TABLE_ + 4192;
    v12 = (_TBYTE *)((char *)&GLOBAL_OFFSET_TABLE_ + 4192);
  }
  *(_DWORD *)(a1 + 148) = v12;
  HIDWORD(v3) = 1;
  *(_DWORD *)(*(_DWORD *)(a1 + 88) + 176) = v11;
  return HIDWORD(v3);
}
// 80CE000: using guessed type _TBYTE GLOBAL_OFFSET_TABLE_;
// 80CEFA0: using guessed type int _start___libc_IO_vtables[24];
// 80CF2F4: using guessed type int (*_start___libc_atexit)();
// 80539D0: using guessed type char var_80[16];

//----- (08053CD0) --------------------------------------------------------
loff_t __cdecl IO_file_seek(int a1, unsigned int a2, unsigned int a3, unsigned int a4)
{
  return lseek64(*(_DWORD *)(a1 + 56), a2, a3, a4);
}

//----- (08053CF0) --------------------------------------------------------
int __cdecl IO_file_sync_mmap(_DWORD *a1)
{
  loff_t v1; // rax

  v1 = a1[1] - a1[7];
  if ( a1[1] == a1[2] || (v1 = lseek64(a1[14], v1, HIDWORD(v1), 0), a1[1] - a1[7] == v1) )
  {
    a1[19] = v1;
    LODWORD(v1) = a1[3];
    a1[20] = HIDWORD(v1);
    a1[1] = v1;
    a1[2] = v1;
    return 0;
  }
  else
  {
    *a1 |= 0x20u;
    return -1;
  }
}

//----- (08053D60) --------------------------------------------------------
unsigned int __usercall decide_maybe_mmap@<eax>(int *a1@<eax>, int a2@<ebp>)
{
  int v3; // edi
  void *v4; // eax
  void *v5; // edx
  int v7; // eax
  int v8; // edi
  void *v9; // edi
  loff_t v10; // rax
  int v11; // edx
  int v12; // ecx
  int v13; // eax
  int v14; // edx
  char v15[16]; // [esp+10h] [ebp-70h] BYREF
  int v16; // [esp+20h] [ebp-60h]
  __int64 v17; // [esp+3Ch] [ebp-44h]
  unsigned int v18; // [esp+70h] [ebp-10h]

  v3 = a1[37];
  v18 = __readgsdword(0x14u);
  if ( (char *)&_start___libc_atexit - (char *)_start___libc_IO_vtables <= (unsigned int)(v3
                                                                                        - (_DWORD)_start___libc_IO_vtables) )
    IO_vtable_check();
  if ( (*(int (__cdecl **)(int *, char *))(v3 + 72))(a1, v15) )
    goto LABEL_5;
  if ( (v16 & 0xF000) != 0x8000 )
    goto LABEL_5;
  if ( !v17 )
    goto LABEL_5;
  if ( v17 > 0xFFFFF )
    goto LABEL_5;
  v7 = a1[19];
  v8 = a1[20];
  if ( v17 < __SPAIR64__(v8, v7) && (v8 & v7) != -1 )
    goto LABEL_5;
  v9 = (void *)mmap64(0, v17, 1, 1, a1[14], 0LL);
  if ( v9 == (void *)-1 )
    goto LABEL_5;
  v10 = lseek64(a1[14], v17, HIDWORD(v17), 0);
  if ( v17 != v10 )
  {
    munmap(v9, v17);
    a1[19] = -1;
    a1[20] = -1;
LABEL_5:
    if ( a1[26] <= 0 )
    {
      v5 = &IO_file_jumps;
      v4 = &IO_wfile_jumps;
    }
    else
    {
      v4 = &IO_wfile_jumps;
      v5 = &IO_wfile_jumps;
    }
    goto LABEL_7;
  }
  IO_setb(a2, (int *)v9, a1, (int)v9, (int)v9 + v17, 0);
  v11 = a1[19];
  v12 = a1[20];
  a1[3] = (int)v9;
  if ( (v11 & v12) == -1 )
    v11 = 0;
  a1[1] = (int)v9 + v11;
  v13 = (int)v9 + v17;
  a1[19] = v17;
  v14 = a1[26];
  a1[2] = v13;
  a1[20] = HIDWORD(v17);
  if ( v14 <= 0 )
  {
    v5 = &IO_file_jumps_mmap;
    v4 = &IO_wfile_jumps_mmap;
  }
  else
  {
    v4 = &IO_wfile_jumps_mmap;
    v5 = &IO_wfile_jumps_mmap;
  }
LABEL_7:
  a1[37] = (int)v5;
  *(_DWORD *)(a1[22] + 176) = v4;
  return __readgsdword(0x14u) ^ v18;
}
// 80CEFA0: using guessed type int _start___libc_IO_vtables[24];
// 80CF2F4: using guessed type int (*_start___libc_atexit)();
// 8053D60: using guessed type char var_70[16];

//----- (08053F30) --------------------------------------------------------
int __usercall IO_file_underflow_maybe_mmap@<eax>(int a1@<ebp>, int *a2)
{
  int v2; // esi

  decide_maybe_mmap(a2, a1);
  v2 = a2[37];
  if ( (char *)&_start___libc_atexit - (char *)_start___libc_IO_vtables <= (unsigned int)(v2
                                                                                        - (_DWORD)_start___libc_IO_vtables) )
    IO_vtable_check();
  return (*(int (__cdecl **)(int *))(v2 + 16))(a2);
}
// 80CEFA0: using guessed type int _start___libc_IO_vtables[24];
// 80CF2F4: using guessed type int (*_start___libc_atexit)();

//----- (08053F80) --------------------------------------------------------
int __usercall IO_file_xsgetn_maybe_mmap@<eax>(int a1@<ebp>, int *a2, int a3, int a4)
{
  int v4; // ebp

  decide_maybe_mmap(a2, a1);
  v4 = a2[37];
  if ( (char *)&_start___libc_atexit - (char *)_start___libc_IO_vtables <= (unsigned int)(v4
                                                                                        - (_DWORD)_start___libc_IO_vtables) )
    IO_vtable_check();
  return (*(int (__cdecl **)(int *, int, int))(v4 + 32))(a2, a3, a4);
}
// 8053F80: could not find valid save-restore pair for ebp
// 80CEFA0: using guessed type int _start___libc_IO_vtables[24];
// 80CF2F4: using guessed type int (*_start___libc_atexit)();

//----- (08053FF0) --------------------------------------------------------
__int64 __cdecl IO_new_file_seekoff(int *a1, __int64 a2, int a3, int a4)
{
  int v4; // ebp
  unsigned int v5; // edx
  unsigned int v6; // eax
  int *v7; // edi
  int v8; // ebx
  int v9; // eax
  __int64 v10; // rax
  __int64 v11; // rcx
  int v12; // ebp
  __int64 result; // rax
  int v14; // ebx
  int v15; // ecx
  int v16; // edx
  int v17; // edx
  int (__cdecl *v18)(int *, int, int); // ecx
  int v19; // edx
  int v20; // eax
  int v21; // eax
  int v22; // edx
  unsigned int v23; // ebp
  unsigned int v24; // ebx
  int v25; // ecx
  int v26; // ebx
  __int64 v27; // rax
  __int64 v28; // rcx
  int v29; // edi
  int v30; // ebp
  int v31; // ebx
  __int64 v32; // kr10_8
  __int64 v33; // [esp+0h] [ebp-B4h]
  __int64 v34; // [esp+8h] [ebp-ACh]
  int v35; // [esp+10h] [ebp-A4h]
  __int64 v36; // [esp+10h] [ebp-A4h]
  __int64 v37; // [esp+10h] [ebp-A4h]
  unsigned int v38; // [esp+18h] [ebp-9Ch]
  int v39; // [esp+18h] [ebp-9Ch]
  int v40; // [esp+20h] [ebp-94h]
  int v41; // [esp+24h] [ebp-90h]
  int v42; // [esp+24h] [ebp-90h]
  char v43[16]; // [esp+34h] [ebp-80h] BYREF
  int v44; // [esp+44h] [ebp-70h]
  __int64 v45; // [esp+60h] [ebp-54h]
  unsigned int v46; // [esp+94h] [ebp-20h]

  v4 = a4;
  v33 = a2;
  v46 = __readgsdword(0x14u);
  if ( !a4 )
  {
    if ( a1[7] )
    {
      v23 = a1[5];
      v24 = a1[4];
      v25 = *a1 & 0x1000;
      if ( v23 > v24 && v25 )
      {
        v26 = a1[37];
        if ( (char *)&_start___libc_atexit - (char *)_start___libc_IO_vtables <= (unsigned int)(v26
                                                                                              - (_DWORD)_start___libc_IO_vtables) )
          IO_vtable_check();
        v27 = ((__int64 (__cdecl *)(int *, _DWORD, _DWORD, int))*(_DWORD *)(v26 + 64))(a1, 0, 0, 2);
        LODWORD(v28) = ~HIDWORD(v27);
        HIDWORD(v28) = ~(_DWORD)v27;
        if ( v27 == -1 )
          return -1LL;
        a1[19] = v27;
        v23 = a1[5];
        a1[20] = HIDWORD(v27);
        goto LABEL_61;
      }
      v27 = *(_QWORD *)(a1 + 19);
      if ( v23 > v24 )
      {
        if ( v25 )
        {
          LODWORD(v28) = ~HIDWORD(v27);
          HIDWORD(v28) = ~(_DWORD)v27;
LABEL_61:
          v29 = v23 - a1[4];
          v30 = v29 >> 31;
          goto LABEL_64;
        }
        v29 = v23 - a1[2];
        LODWORD(v28) = ~HIDWORD(v27);
        v30 = v29 >> 31;
        HIDWORD(v28) = ~(_DWORD)v27;
      }
      else
      {
        v29 = a1[1] - a1[2];
        LODWORD(v28) = ~HIDWORD(v27);
        HIDWORD(v28) = ~(_DWORD)v27;
        v30 = -((a1[1] != a1[2]) + ((a1[2] - a1[1]) >> 31));
      }
    }
    else
    {
      v27 = *(_QWORD *)(a1 + 19);
      v29 = 0;
      v30 = 0;
      LODWORD(v28) = ~HIDWORD(v27);
      HIDWORD(v28) = ~(_DWORD)v27;
    }
LABEL_64:
    if ( !v28 )
    {
      v31 = a1[37];
      if ( (char *)&_start___libc_atexit - (char *)_start___libc_IO_vtables <= (unsigned int)(v31
                                                                                            - (_DWORD)_start___libc_IO_vtables) )
        IO_vtable_check();
      v27 = ((__int64 (__cdecl *)(int *, _DWORD, _DWORD, int))*(_DWORD *)(v31 + 64))(a1, 0, 0, 1);
      if ( (HIDWORD(v27) & (unsigned int)v27) == -1 )
        return -1LL;
    }
    result = __PAIR64__(v30, v29) + v27;
    if ( result >= 0 )
      return result;
    goto LABEL_66;
  }
  v5 = a1[4];
  v6 = a1[5];
  v7 = (int *)a1[2];
  if ( (int *)a1[3] == v7 && v5 == v6 )
  {
    v40 = 1;
  }
  else
  {
    v40 = 0;
    if ( v5 < v6 )
      goto LABEL_4;
  }
  if ( (*a1 & 0x800) == 0 )
  {
    if ( !a1[7] )
      goto LABEL_17;
LABEL_6:
    if ( a3 == 1 )
      goto LABEL_20;
    goto LABEL_7;
  }
LABEL_4:
  if ( IO_switch_to_get_mode(a1) )
    return -1LL;
  if ( a1[7] )
    goto LABEL_6;
LABEL_17:
  if ( a1[3] )
  {
    free(a4, v7, a1[3]);
    *a1 &= ~0x100u;
  }
  IO_doallocbuf(a1);
  v9 = a1[7];
  a1[5] = v9;
  a1[4] = v9;
  a1[6] = v9;
  a1[3] = v9;
  a1[1] = v9;
  a1[2] = v9;
  if ( a3 == 1 )
  {
LABEL_20:
    v33 = a2 - (a1[2] - a1[1]);
    v10 = *(_QWORD *)(a1 + 19);
    if ( (HIDWORD(v10) & (unsigned int)v10) == -1 )
    {
      v38 = (char *)&_start___libc_atexit - (char *)_start___libc_IO_vtables;
      goto LABEL_34;
    }
    v33 += v10;
    if ( v33 >= 0 )
      goto LABEL_22;
LABEL_66:
    __writegsdword(0xFFFFFFE0, 0x16u);
    return -1LL;
  }
LABEL_7:
  if ( a3 == 2 )
  {
    v8 = a1[37];
    v7 = (int *)((char *)&_start___libc_atexit - (char *)_start___libc_IO_vtables);
    v38 = (char *)&_start___libc_atexit - (char *)_start___libc_IO_vtables;
    if ( (char *)&_start___libc_atexit - (char *)_start___libc_IO_vtables <= (unsigned int)(v8
                                                                                          - (_DWORD)_start___libc_IO_vtables) )
      IO_vtable_check();
    if ( (*(int (__cdecl **)(int *, char *))(v8 + 72))(a1, v43) || (v44 & 0xF000) != 0x8000 )
      goto LABEL_34;
    v33 = v45 + a2;
LABEL_22:
    a3 = 0;
  }
  IO_free_backup_area(a4, v7, a1);
  v11 = *(_QWORD *)(a1 + 19);
  v35 = *a1;
  if ( (HIDWORD(v11) & a1[19]) != -1 )
  {
    if ( a1[3] )
    {
      if ( (*a1 & 0x100) == 0 )
      {
        v39 = a1[7];
        v4 = (unsigned __int64)(v11 - (a1[2] - v39)) >> 32;
        v7 = (int *)(v11 - (a1[2] - v39));
        if ( v33 >= v11 - (a1[2] - v39) && v33 < v11 )
        {
          a1[3] = v39;
          a1[5] = v39;
          a1[1] = v39 + v33 - (_DWORD)v7;
          a1[4] = v39;
          a1[6] = v39;
          *a1 = v35 & 0xFFFFFFEF;
          if ( v11 >= 0 )
          {
            v12 = a1[37];
            if ( (char *)&_start___libc_atexit - (char *)_start___libc_IO_vtables <= (unsigned int)(v12
                                                                                                  - (_DWORD)_start___libc_IO_vtables) )
            {
              IO_vtable_check();
              v11 = *(_QWORD *)(a1 + 19);
            }
            (*(void (__cdecl **)(int *, _DWORD, _DWORD, _DWORD))(v12 + 64))(a1, v11, HIDWORD(v11), 0);
            return v33;
          }
          return v33;
        }
      }
    }
  }
  v38 = (char *)&_start___libc_atexit - (char *)_start___libc_IO_vtables;
  if ( (v35 & 4) != 0 )
    goto LABEL_34;
  v36 = v33 & (a1[7] - a1[8]);
  v34 = v33 - v36;
  if ( a1[8] - a1[7] < v33 - v36 )
  {
    v34 = 0LL;
    v36 = v33;
  }
  v16 = a1[37];
  if ( v16 - (int)_start___libc_IO_vtables >= v38 )
  {
    v41 = a1[37];
    IO_vtable_check();
    v16 = v41;
  }
  v37 = ((__int64 (__cdecl *)(int *, _DWORD, _DWORD, _DWORD))*(_DWORD *)(v16 + 64))(a1, v36, HIDWORD(v36), 0);
  if ( v37 < 0 )
    return -1LL;
  if ( !v34 )
  {
    v21 = 0;
    goto LABEL_52;
  }
  v17 = a1[37];
  if ( v17 - (int)_start___libc_IO_vtables >= v38 )
  {
    v42 = a1[37];
    IO_vtable_check();
    v17 = v42;
  }
  v18 = *(int (__cdecl **)(int *, int, int))(v17 + 56);
  v19 = a1[7];
  if ( v40 )
    v20 = v34;
  else
    v20 = a1[8] - v19;
  v21 = v18(a1, v19, v20);
  v4 = HIDWORD(v34);
  v7 = (int *)v34;
  if ( v21 >= v34 )
  {
    v37 += v21;
LABEL_52:
    v22 = a1[7];
    *a1 &= ~0x10u;
    a1[3] = v22;
    a1[2] = v22 + v21;
    a1[5] = v22;
    a1[4] = v22;
    a1[6] = v22;
    a1[1] = v22 + v34;
    *(_QWORD *)(a1 + 19) = v37;
    return v33;
  }
  a3 = 1;
  if ( v21 == -1 )
  {
    v33 = v34;
  }
  else
  {
    v32 = v34 - v21;
    v4 = HIDWORD(v32);
    v7 = (int *)v32;
    v33 = v32;
  }
LABEL_34:
  IO_unsave_markers(v4, v7, a1);
  v14 = a1[37];
  if ( v38 <= v14 - (int)_start___libc_IO_vtables )
    IO_vtable_check();
  result = ((__int64 (__cdecl *)(int *, _DWORD, _DWORD, int))*(_DWORD *)(v14 + 64))(a1, v33, HIDWORD(v33), a3);
  if ( (HIDWORD(result) & (unsigned int)result) != -1 )
  {
    v15 = a1[7];
    *a1 &= ~0x10u;
    *(_QWORD *)(a1 + 19) = result;
    a1[3] = v15;
    a1[1] = v15;
    a1[2] = v15;
    a1[5] = v15;
    a1[4] = v15;
    a1[6] = v15;
  }
  return result;
}
// 80CEFA0: using guessed type int _start___libc_IO_vtables[24];
// 80CF2F4: using guessed type int (*_start___libc_atexit)();
// 8053FF0: using guessed type char var_80[16];

//----- (08054740) --------------------------------------------------------
unsigned int __cdecl IO_file_stat(int a1, struct stat *a2)
{
  return _fxstat64(3, *(_DWORD *)(a1 + 56), a2);
}

//----- (08054760) --------------------------------------------------------
int __cdecl IO_new_file_write(int a1, char *a2, int a3)
{
  int v4; // ebx
  signed int v5; // eax
  int v6; // eax
  int result; // eax
  __int64 v8; // rcx

  if ( a3 <= 0 )
  {
    result = 0;
  }
  else
  {
    v4 = a3;
    do
    {
      v6 = *(_DWORD *)(a1 + 56);
      if ( (*(_BYTE *)(a1 + 60) & 2) != 0 )
      {
        v5 = _write_nocancel(v6, a2, v4);
        if ( v5 < 0 )
        {
LABEL_7:
          *(_DWORD *)a1 |= 0x20u;
          result = a3 - v4;
          goto LABEL_8;
        }
      }
      else
      {
        v5 = write(v6, a2, v4);
        if ( v5 < 0 )
          goto LABEL_7;
      }
      v4 -= v5;
      a2 += v5;
    }
    while ( v4 > 0 );
    result = a3 - v4;
  }
LABEL_8:
  v8 = *(_QWORD *)(a1 + 76);
  if ( v8 >= 0 )
    *(_QWORD *)(a1 + 76) = result + v8;
  return result;
}

//----- (08054800) --------------------------------------------------------
int __cdecl IO_file_xsgetn_mmap(_DWORD *a1, char *a2, unsigned int a3)
{
  unsigned int v3; // ebp
  _BYTE *v4; // ecx
  _BYTE *v5; // edx
  unsigned int v6; // esi
  int v7; // eax
  int v9; // eax
  int v10; // esi
  _BYTE *v11; // [esp+1Ch] [ebp-20h]
  _WORD *v12; // [esp+1Ch] [ebp-20h]
  _BYTE *v13; // [esp+1Ch] [ebp-20h]
  int v14; // [esp+1Ch] [ebp-20h]

  v3 = a3;
  v4 = a2;
  v5 = (_BYTE *)a1[1];
  v6 = a1[2] - (_DWORD)v5;
  if ( v6 >= a3 )
  {
LABEL_6:
    if ( !v6 )
      return v4 - a2;
LABEL_9:
    if ( v6 > v3 )
      v6 = v3;
    v13 = v5;
    v4 = mempcpy(v4, v5, v6);
    a1[1] = &v13[v6];
    return v4 - a2;
  }
  if ( (*a1 & 0x100) != 0 )
  {
    v3 = a3 - v6;
    v12 = mempcpy(a2, v5, a1[2] - (_DWORD)v5);
    IO_switch_to_main_get_area(a1);
    v5 = (_BYTE *)a1[1];
    v4 = v12;
    v6 = a1[2] - (_DWORD)v5;
    if ( v3 <= v6 )
      goto LABEL_9;
  }
  v11 = v4;
  v7 = mmap_remap_check((int)a1);
  v4 = v11;
  if ( !v7 )
  {
    v5 = (_BYTE *)a1[1];
    v6 = a1[2] - (_DWORD)v5;
    if ( v6 >= v3 )
      goto LABEL_9;
    *a1 |= 0x10u;
    goto LABEL_6;
  }
  v9 = a1[37];
  v10 = v11 - a2;
  if ( (char *)&_start___libc_atexit - (char *)_start___libc_IO_vtables <= (unsigned int)(v9
                                                                                        - (_DWORD)_start___libc_IO_vtables) )
  {
    v14 = a1[37];
    IO_vtable_check();
    v9 = v14;
  }
  return v10 + (*(int (__cdecl **)(_DWORD *, char *, unsigned int))(v9 + 32))(a1, a2, v3);
}
// 80CEFA0: using guessed type int _start___libc_IO_vtables[24];
// 80CF2F4: using guessed type int (*_start___libc_atexit)();

//----- (08054910) --------------------------------------------------------
unsigned int __usercall IO_file_xsgetn@<eax>(int *a1@<edi>, int a2, int a3, unsigned int a4)
{
  _BYTE *v4; // ebp
  _BYTE *v5; // eax
  unsigned int v6; // edi
  unsigned int v7; // edx
  int v8; // eax
  unsigned int v9; // ecx
  unsigned int v10; // edx
  int v11; // ebx
  int v12; // eax
  int v13; // ecx
  __int64 v14; // rax
  _WORD *v15; // eax
  unsigned int result; // eax
  int v17; // edx
  unsigned int v18; // [esp+Ch] [ebp-20h]
  unsigned int v19; // [esp+Ch] [ebp-20h]

  v4 = (_BYTE *)a3;
  if ( !*(_DWORD *)(a2 + 28) )
  {
    if ( *(_DWORD *)(a2 + 36) )
    {
      free(a3, a1, *(_DWORD *)(a2 + 36));
      *(_DWORD *)a2 &= ~0x100u;
    }
    IO_doallocbuf((int *)a2);
  }
  if ( !a4 )
    return a4;
  v5 = *(_BYTE **)(a2 + 4);
  v6 = a4;
  v7 = *(_DWORD *)(a2 + 8) - (_DWORD)v5;
  if ( a4 <= v7 )
  {
LABEL_28:
    memcpy(v4, v5, v6);
    *(_DWORD *)(a2 + 4) += v6;
    return a4;
  }
  while ( !v7 )
  {
    if ( (*(_DWORD *)a2 & 0x100) == 0 )
      goto LABEL_6;
LABEL_19:
    IO_switch_to_main_get_area((_DWORD *)a2);
    if ( !v6 )
      return a4;
LABEL_16:
    v5 = *(_BYTE **)(a2 + 4);
    v7 = *(_DWORD *)(a2 + 8) - (_DWORD)v5;
    if ( v6 <= v7 )
      goto LABEL_28;
  }
  v18 = v7;
  v15 = mempcpy(v4, v5, v7);
  *(_DWORD *)(a2 + 4) += v18;
  v4 = v15;
  v6 -= v18;
  if ( (*(_DWORD *)a2 & 0x100) != 0 )
    goto LABEL_19;
LABEL_6:
  v8 = *(_DWORD *)(a2 + 28);
  if ( !v8 )
  {
    *(_DWORD *)(a2 + 12) = 0;
    *(_DWORD *)(a2 + 4) = 0;
    *(_DWORD *)(a2 + 8) = 0;
    *(_DWORD *)(a2 + 20) = 0;
    *(_DWORD *)(a2 + 16) = 0;
    *(_DWORD *)(a2 + 24) = 0;
    goto LABEL_22;
  }
  v9 = *(_DWORD *)(a2 + 32) - v8;
  if ( v9 > v6 )
  {
    if ( _underflow((int)v4, (int *)v6, (int *)a2) == -1 )
      return a4 - v6;
    goto LABEL_15;
  }
  *(_DWORD *)(a2 + 12) = v8;
  *(_DWORD *)(a2 + 4) = v8;
  *(_DWORD *)(a2 + 8) = v8;
  *(_DWORD *)(a2 + 20) = v8;
  *(_DWORD *)(a2 + 16) = v8;
  *(_DWORD *)(a2 + 24) = v8;
  if ( v9 > 0x7F )
  {
    v10 = v6 - v6 % v9;
    goto LABEL_10;
  }
LABEL_22:
  v10 = v6;
LABEL_10:
  v11 = *(_DWORD *)(a2 + 148);
  if ( (char *)&_start___libc_atexit - (char *)_start___libc_IO_vtables <= (unsigned int)(v11
                                                                                        - (_DWORD)_start___libc_IO_vtables) )
  {
    v19 = v10;
    IO_vtable_check();
    v10 = v19;
  }
  v12 = (*(int (__cdecl **)(int, _BYTE *, unsigned int))(v11 + 56))(a2, v4, v10);
  v13 = v12;
  if ( v12 > 0 )
  {
    v4 += v12;
    v6 -= v12;
    v14 = *(_QWORD *)(a2 + 76);
    if ( (HIDWORD(v14) & *(_DWORD *)(a2 + 76)) != -1 )
      *(_QWORD *)(a2 + 76) = v13 + v14;
LABEL_15:
    if ( !v6 )
      return a4;
    goto LABEL_16;
  }
  result = a4 - v6;
  v17 = *(_DWORD *)a2 | 0x10;
  if ( v13 )
    v17 = *(_DWORD *)a2 | 0x20;
  *(_DWORD *)a2 = v17;
  return result;
}
// 80CEFA0: using guessed type int _start___libc_IO_vtables[24];
// 80CF2F4: using guessed type int (*_start___libc_atexit)();

//----- (08054B70) --------------------------------------------------------
int __cdecl IO_file_seekoff_mmap(int a1, __int64 a2, int a3, int a4)
{
  int v4; // ebp
  unsigned int v5; // edi
  int v6; // esi
  __int64 v7; // rax
  int v8; // esi
  int v9; // esi
  int v11; // [esp+8h] [ebp-20h]

  v4 = HIDWORD(a2);
  v5 = a2;
  if ( !a4 )
    return *(_QWORD *)(a1 + 76) - (*(_DWORD *)(a1 + 8) - *(_DWORD *)(a1 + 4));
  if ( a3 == 1 )
  {
    v9 = *(_DWORD *)(a1 + 4) - *(_DWORD *)(a1 + 12);
  }
  else
  {
    if ( a3 != 2 )
      goto LABEL_4;
    v9 = *(_DWORD *)(a1 + 32) - *(_DWORD *)(a1 + 28);
  }
  v4 = (unsigned __int64)(v9 + a2) >> 32;
  v5 = v9 + a2;
LABEL_4:
  if ( v4 < 0 )
  {
    __writegsdword(0xFFFFFFE0, 0x16u);
    LODWORD(v7) = -1;
  }
  else
  {
    v6 = *(_DWORD *)(a1 + 148);
    if ( (char *)&_start___libc_atexit - (char *)_start___libc_IO_vtables <= (unsigned int)(v6
                                                                                          - (_DWORD)_start___libc_IO_vtables) )
      IO_vtable_check();
    v7 = ((__int64 (__cdecl *)(int, unsigned int, int, _DWORD))*(_DWORD *)(v6 + 64))(a1, v5, v4, 0);
    if ( v7 < 0 )
    {
      LODWORD(v7) = -1;
    }
    else
    {
      v8 = *(_DWORD *)(a1 + 28);
      v11 = *(_DWORD *)(a1 + 32);
      *(_DWORD *)(a1 + 12) = v8;
      if ( v11 - v8 < __SPAIR64__(v4, v5) )
      {
        *(_DWORD *)(a1 + 4) = v11;
        *(_DWORD *)(a1 + 8) = v11;
      }
      else
      {
        *(_DWORD *)(a1 + 4) = v8 + v5;
        *(_DWORD *)(a1 + 8) = v8 + v5;
      }
      *(_DWORD *)a1 &= ~0x10u;
      *(_QWORD *)(a1 + 76) = v7;
      LODWORD(v7) = v5;
    }
  }
  return v7;
}
// 80CEFA0: using guessed type int _start___libc_IO_vtables[24];
// 80CF2F4: using guessed type int (*_start___libc_atexit)();

//----- (08054CD0) --------------------------------------------------------
int __cdecl IO_file_underflow_mmap(_DWORD *a1)
{
  unsigned __int8 *v1; // eax
  int v3; // edi

  v1 = (unsigned __int8 *)a1[1];
  if ( (unsigned int)v1 < a1[2] )
    return *v1;
  if ( mmap_remap_check((int)a1) )
  {
    v3 = a1[37];
    if ( (char *)&_start___libc_atexit - (char *)_start___libc_IO_vtables <= (unsigned int)(v3
                                                                                          - (_DWORD)_start___libc_IO_vtables) )
      IO_vtable_check();
    return (*(int (__cdecl **)(_DWORD *))(v3 + 16))(a1);
  }
  else
  {
    v1 = (unsigned __int8 *)a1[1];
    if ( (unsigned int)v1 < a1[2] )
      return *v1;
    *a1 |= 0x10u;
    return -1;
  }
}
// 80CEFA0: using guessed type int _start___libc_IO_vtables[24];
// 80CF2F4: using guessed type int (*_start___libc_atexit)();

//----- (08054D50) --------------------------------------------------------
unsigned int __cdecl IO_file_read(int a1, void *a2, size_t a3)
{
  bool v3; // zf
  int v5; // [esp+4h] [ebp+4h]

  v3 = (*(_BYTE *)(a1 + 60) & 2) == 0;
  v5 = *(_DWORD *)(a1 + 56);
  if ( v3 )
    return read(v5, a2, a3);
  else
    return _read_nocancel(v5, a2, a3);
}

//----- (08054D80) --------------------------------------------------------
int __cdecl IO_new_file_xsputn(_DWORD *a1, _BYTE *a2, unsigned int a3)
{
  unsigned int v3; // edx
  _BYTE *v4; // ecx
  unsigned int v5; // ebp
  unsigned int v6; // ebp
  int v7; // edx
  _WORD *v8; // eax
  int v9; // edx
  unsigned int v10; // ebp
  _BYTE *v12; // edx
  _BYTE *v13; // eax
  int v14; // eax
  int v15; // eax
  unsigned int v16; // ecx
  unsigned int v17; // ebx
  unsigned int v18; // eax
  int v19; // eax
  int v20; // [esp+0h] [ebp-20h]
  int v21; // [esp+0h] [ebp-20h]

  v3 = 0;
  if ( !a3 )
    return v3;
  v4 = (_BYTE *)a1[5];
  if ( (*a1 & 0xA00) == 2560 )
  {
    v6 = a1[8] - (_DWORD)v4;
    if ( a3 <= v6 )
    {
      v12 = &a2[a3];
      if ( a2 < &a2[a3] )
      {
        v13 = v12 - 1;
        if ( *(v12 - 1) == 10 )
        {
LABEL_33:
          v19 = v13 - a2;
          v6 = v19 + 1;
          if ( v19 == -1 )
          {
            v10 = a3;
            v9 = 1;
            goto LABEL_9;
          }
          v7 = 1;
LABEL_6:
          v20 = v7;
          if ( a3 <= v6 )
            v6 = a3;
          v8 = mempcpy(v4, a2, v6);
          a2 += v6;
          v9 = v20;
          a1[5] = v8;
          v10 = a3 - v6;
LABEL_9:
          if ( !(v10 + v9) )
            return a3 - v10;
          goto LABEL_20;
        }
        while ( a2 != v13 )
        {
          if ( *--v13 == 10 )
            goto LABEL_33;
        }
      }
      v7 = 0;
      goto LABEL_6;
    }
  }
  else
  {
    v5 = a1[6];
    if ( v5 <= (unsigned int)v4 )
      goto LABEL_19;
    v6 = v5 - (_DWORD)v4;
  }
  v7 = 0;
  if ( v6 )
    goto LABEL_6;
LABEL_19:
  v10 = a3;
LABEL_20:
  v14 = a1[37];
  if ( (char *)&_start___libc_atexit - (char *)_start___libc_IO_vtables <= (unsigned int)(v14
                                                                                        - (_DWORD)_start___libc_IO_vtables) )
  {
    v21 = a1[37];
    IO_vtable_check();
    v14 = v21;
  }
  v15 = (*(int (__cdecl **)(_DWORD *, int))(v14 + 12))(a1, -1);
  if ( v15 == -1 )
  {
    if ( v10 )
      return a3 - v10;
    return v15;
  }
  else
  {
    v16 = a1[8] - a1[7];
    v17 = v10;
    if ( v16 > 0x7F )
      v17 = v10 - v10 % v16;
    if ( v17 )
    {
      v18 = new_do_write((int)a1, (unsigned int)a2, v17);
      if ( v18 < v17 )
        return a3 - v10 + v18;
      v10 -= v18;
    }
    v3 = a3;
    if ( v10 )
      return IO_default_xsputn(a1, &a2[v17], v10) - v10 + a3;
  }
  return v3;
}
// 80CEFA0: using guessed type int _start___libc_IO_vtables[24];
// 80CF2F4: using guessed type int (*_start___libc_atexit)();

//----- (08054F60) --------------------------------------------------------
unsigned int __usercall IO_new_file_init_internal@<eax>(int a1@<ebp>, int *a2)
{
  unsigned int result; // eax

  *a2 |= 0x240Cu;
  a2[19] = -1;
  a2[20] = -1;
  result = IO_link_in(a1, a2);
  a2[14] = -1;
  return result;
}

//----- (08054FA0) --------------------------------------------------------
unsigned int __usercall IO_new_file_init@<eax>(int a1@<ebp>, int *a2)
{
  unsigned int result; // eax

  *a2 |= 0x240Cu;
  a2[19] = -1;
  a2[20] = -1;
  result = IO_link_in(a1, a2);
  a2[14] = -1;
  return result;
}

//----- (08054FE0) --------------------------------------------------------
int __cdecl IO_file_open(int a1, int a2, int a3, int a4, __int16 a5, int a6)
{
  int v6; // eax
  int v7; // ebp
  int v8; // eax
  int v9; // esi
  __int64 v10; // rax

  v6 = a3;
  if ( !a6 )
    v6 = a3 | 0x8000;
  if ( (*(_BYTE *)(a1 + 60) & 2) != 0 )
    v7 = _open_nocancel(a2);
  else
    v7 = open(a2, v6);
  if ( v7 < 0 )
    return 0;
  v8 = *(_DWORD *)a1;
  *(_DWORD *)(a1 + 56) = v7;
  *(_DWORD *)a1 = a5 & 0x100C | v8 & 0xFFFFEFF3;
  if ( (a5 & 0x1004) != 4100 )
    goto LABEL_10;
  v9 = *(_DWORD *)(a1 + 148);
  if ( (char *)&_start___libc_atexit - (char *)_start___libc_IO_vtables <= (unsigned int)(v9
                                                                                        - (_DWORD)_start___libc_IO_vtables) )
    IO_vtable_check();
  v10 = ((__int64 (__cdecl *)(int, _DWORD, _DWORD, int))*(_DWORD *)(v9 + 64))(a1, 0, 0, 2);
  if ( (HIDWORD(v10) & (unsigned int)v10) == -1 && __readgsdword(0xFFFFFFE0) != 29 )
  {
    _close_nocancel(v7);
    return 0;
  }
  else
  {
LABEL_10:
    IO_link_in(v7, (int *)a1);
    return a1;
  }
}
// 80CEFA0: using guessed type int _start___libc_IO_vtables[24];
// 80CF2F4: using guessed type int (*_start___libc_atexit)();

//----- (08055110) --------------------------------------------------------
unsigned int *__cdecl IO_new_file_attach(unsigned int *a1, unsigned int a2)
{
  unsigned int v2; // ebp
  unsigned int v3; // esi
  __int64 v4; // rax

  if ( a1[14] != -1 )
    return 0;
  v2 = a1[37];
  a1[19] = -1;
  a1[20] = -1;
  a1[14] = a2;
  *a1 = *a1 & 0xFFFFFFB3 | 0x40;
  v3 = __readgsdword(0xFFFFFFE0);
  if ( (char *)&_start___libc_atexit - (char *)_start___libc_IO_vtables <= v2 - (unsigned int)_start___libc_IO_vtables )
    IO_vtable_check();
  v4 = ((__int64 (__cdecl *)(unsigned int *, _DWORD, _DWORD, int, int))*(_DWORD *)(v2 + 36))(a1, 0, 0, 1, 3);
  if ( (HIDWORD(v4) & (unsigned int)v4) == -1 && __readgsdword(0xFFFFFFE0) != 29 )
    return 0;
  __writegsdword(0xFFFFFFE0, v3);
  return a1;
}
// 80CEFA0: using guessed type int _start___libc_IO_vtables[24];
// 80CF2F4: using guessed type int (*_start___libc_atexit)();

//----- (080551C0) --------------------------------------------------------
int __cdecl IO_new_do_write(int a1, unsigned int a2, int a3)
{
  int result; // eax

  result = 0;
  if ( a3 )
    return -(a3 != new_do_write(a1, a2, a3));
  return result;
}

//----- (08055200) --------------------------------------------------------
int __cdecl IO_new_file_close_it(int a1)
{
  int v1; // esi
  int *v2; // edi
  int v3; // esi
  _DWORD *v4; // eax

  v1 = *(_DWORD *)(a1 + 56);
  if ( v1 != -1 )
  {
    v2 = 0;
    if ( (*(_DWORD *)a1 & 0x808) == 2048 )
    {
      if ( *(int *)(a1 + 104) <= 0 )
        v2 = (int *)IO_new_do_write(a1, *(_DWORD *)(a1 + 16), *(_DWORD *)(a1 + 20) - *(_DWORD *)(a1 + 16));
      else
        v2 = (int *)IO_wdo_write(
                      (int *)a1,
                      *(_DWORD *)(*(_DWORD *)(a1 + 88) + 12),
                      (*(_DWORD *)(*(_DWORD *)(a1 + 88) + 16) - *(_DWORD *)(*(_DWORD *)(a1 + 88) + 12)) >> 2);
    }
    v1 = 0;
    IO_unsave_markers((int)&GLOBAL_OFFSET_TABLE_, v2, (int *)a1);
    if ( (*(_BYTE *)(a1 + 60) & 0x20) == 0 )
    {
      v3 = *(_DWORD *)(a1 + 148);
      if ( (char *)&_start___libc_atexit - (char *)_start___libc_IO_vtables <= (unsigned int)(v3
                                                                                            - (_DWORD)_start___libc_IO_vtables) )
        IO_vtable_check();
      v1 = (*(int (__cdecl **)(int))(v3 + 68))(a1);
    }
    if ( *(int *)(a1 + 104) > 0 )
    {
      if ( *(_DWORD *)(*(_DWORD *)(a1 + 88) + 32) )
        IO_free_wbackup_area((int)&GLOBAL_OFFSET_TABLE_, v2, (int *)a1);
      IO_wsetb((int)&GLOBAL_OFFSET_TABLE_, v2, a1, 0, 0, 0);
      v4 = *(_DWORD **)(a1 + 88);
      v4[2] = 0;
      *v4 = 0;
      v4[1] = 0;
      v4[4] = 0;
      v4[3] = 0;
      v4[5] = 0;
    }
    IO_setb((int)&GLOBAL_OFFSET_TABLE_, v2, (int *)a1, 0, 0, 0);
    *(_DWORD *)(a1 + 12) = 0;
    *(_DWORD *)(a1 + 4) = 0;
    *(_DWORD *)(a1 + 8) = 0;
    *(_DWORD *)(a1 + 20) = 0;
    *(_DWORD *)(a1 + 16) = 0;
    *(_DWORD *)(a1 + 24) = 0;
    IO_un_link((int)&GLOBAL_OFFSET_TABLE_, (struct timespec *)a1);
    *(_DWORD *)a1 = -72539124;
    *(_DWORD *)(a1 + 56) = -1;
    if ( !v1 )
      v1 = (int)v2;
    *(_DWORD *)(a1 + 76) = -1;
    *(_DWORD *)(a1 + 80) = -1;
  }
  return v1;
}
// 80CE000: using guessed type _TBYTE GLOBAL_OFFSET_TABLE_;
// 80CEFA0: using guessed type int _start___libc_IO_vtables[24];
// 80CF2F4: using guessed type int (*_start___libc_atexit)();

//----- (080553A0) --------------------------------------------------------
int __cdecl IO_new_file_fopen(int a1, int a2, _BYTE *a3, int a4)
{
  _DWORD *v4; // ebp
  _BYTE *v5; // edx
  char v6; // al
  __int16 v8; // di
  int v9; // ecx
  _BYTE *v10; // ebx
  char v11; // al
  int *v12; // edi
  char *v13; // eax
  char *v14; // esi
  int v15; // eax
  int *v16; // ecx
  int *v17; // ebx
  int v18; // ebp
  int v19; // eax
  unsigned int v20; // esi
  int v21; // esi
  _BYTE *v22; // eax
  _BYTE *v23; // edx
  int *v24; // eax
  int v25; // ebx
  _DWORD *v26; // eax
  int v27; // edx
  int v28; // eax
  _DWORD *v29; // eax
  int v30; // edx
  int v31; // ecx
  int v32; // ebx
  int v33; // [esp+20h] [ebp-5Ch]
  int v34; // [esp+20h] [ebp-5Ch]
  int v35; // [esp+24h] [ebp-58h]
  int v36; // [esp+2Ch] [ebp-50h]
  int *v37; // [esp+30h] [ebp-4Ch]
  int *v38; // [esp+34h] [ebp-48h]
  _BYTE *v39; // [esp+38h] [ebp-44h]
  int v40[12]; // [esp+4Ch] [ebp-30h] BYREF

  v4 = (_DWORD *)a1;
  v5 = a3;
  v40[4] = __readgsdword(0x14u);
  if ( *(_DWORD *)(a1 + 56) != -1 )
    return 0;
  v6 = *a3;
  if ( *a3 == 114 )
  {
    v8 = 8;
    v33 = 0;
    v9 = 0;
  }
  else if ( v6 == 119 )
  {
    v33 = 1;
    v8 = 4;
    v9 = 576;
  }
  else
  {
    if ( v6 != 97 )
    {
      __writegsdword(0xFFFFFFE0, 0x16u);
      return 0;
    }
    v8 = 4100;
    v33 = 1;
    v9 = 1088;
  }
  v10 = a3;
  do
  {
    v11 = *++v5;
    if ( *v5 == 99 )
    {
      *(_DWORD *)(a1 + 60) |= 2u;
    }
    else if ( v11 > 99 )
    {
      switch ( v11 )
      {
        case 'm':
          *(_DWORD *)(a1 + 60) |= 1u;
          break;
        case 'x':
          LOBYTE(v9) = v9 | 0x80;
          v10 = v5;
          break;
        case 'e':
          v9 |= 0x80000u;
          *(_DWORD *)(a1 + 60) |= 0x40u;
          break;
      }
    }
    else
    {
      switch ( v11 )
      {
        case 43:
          v8 &= 0x1000u;
          v10 = v5;
          v33 = 2;
          break;
        case 98:
          v10 = v5;
          break;
        case 0:
          goto LABEL_15;
      }
    }
  }
  while ( v5 != a3 + 6 );
LABEL_15:
  v35 = IO_file_open(a1, a2, v33 | v9, 438, v8, a4);
  if ( !v35 )
    return 0;
  v12 = (int *)&GLOBAL_OFFSET_TABLE_;
  v13 = strstr(v10 + 1, (unsigned int *)((char *)&GLOBAL_OFFSET_TABLE_ - 178123));
  if ( !v13 )
    return v35;
  v39 = v13 + 5;
  v14 = (char *)((char *)strchrnul((unsigned int *)(v13 + 5), 44) - (v13 + 5));
  v38 = malloc((const struct timespec *)(v14 + 3));
  if ( !v38 )
  {
    v20 = __readgsdword(0xFFFFFFE0);
    IO_new_file_close_it(a1);
    __writegsdword(0xFFFFFFE0, v20);
    return 0;
  }
  *(_BYTE *)mempcpy(v38, v39, (unsigned int)v14) = 0;
  v15 = *(unsigned __int8 *)v38;
  if ( (_BYTE)v15 )
  {
    v34 = 0;
    v36 = *((_DWORD *)&GLOBAL_OFFSET_TABLE_ - 33);
    v16 = v38;
    v37 = (int *)*((_DWORD *)&GLOBAL_OFFSET_TABLE_ - 35);
    v17 = v38;
    do
    {
      v18 = v34 + 1;
      v12 = (int *)(v15 - 44);
      if ( (_BYTE)v15 == 58
        || (_BYTE)v15 == 95
        || (unsigned __int8)(v15 - 44) <= 2u
        || (v12 = v37, (*((_BYTE *)v37 + 2 * (char)v15) & 8) != 0) )
      {
        v16 = (int *)((char *)v16 + 1);
        *((_BYTE *)v16 - 1) = *(_DWORD *)(v36 + 4 * (char)v15);
      }
      else if ( (_BYTE)v15 == 47 )
      {
        if ( v34 == 2 )
        {
          v4 = (_DWORD *)a1;
          goto LABEL_43;
        }
        v19 = v34;
        *(_BYTE *)v16 = 47;
        v16 = (int *)((char *)v16 + 1);
        ++v34;
        v18 = v19 + 2;
      }
      v17 = (int *)((char *)v17 + 1);
      v15 = *(unsigned __int8 *)v17;
    }
    while ( (_BYTE)v15 );
    v21 = v18;
    v4 = (_DWORD *)a1;
    if ( v34 > 1 )
      goto LABEL_43;
    v22 = (char *)v16 + 1;
    *(_BYTE *)v16 = 47;
    if ( v21 != 1 )
    {
      v16 = (int *)((char *)v16 + 1);
      goto LABEL_43;
    }
  }
  else
  {
    v22 = (char *)v38 + 1;
    *(_BYTE *)v38 = 47;
  }
  *v22 = 47;
  v16 = (int *)(v22 + 1);
LABEL_43:
  *(_BYTE *)v16 = 0;
  if ( !*((_BYTE *)v38 + 2) )
  {
    v23 = v39;
    v24 = v38;
    do
    {
      ++v23;
      v24 = (int *)((char *)v24 + 1);
      v25 = dword_80A7040[(char)*(v23 - 1)];
      *((_BYTE *)v24 - 1) = v25;
    }
    while ( (_BYTE)v25 );
  }
  if ( _wcsmbs_named_conv((int)v40, (int)v38) )
  {
    IO_new_file_close_it((int)v4);
    free((int)v4, v12, (int)v38);
    __writegsdword(0xFFFFFFE0, 0x16u);
    return 0;
  }
  free((int)v4, v12, (int)v38);
  if ( v40[1] != 1 )
    _assert_fail(
      (int)&GLOBAL_OFFSET_TABLE_ - 178117,
      (int)&GLOBAL_OFFSET_TABLE_ - 178262,
      322,
      (int)&GLOBAL_OFFSET_TABLE_ - 178072);
  if ( v40[3] != 1 )
    _assert_fail(
      (int)&GLOBAL_OFFSET_TABLE_ - 178095,
      (int)&GLOBAL_OFFSET_TABLE_ - 178262,
      323,
      (int)&GLOBAL_OFFSET_TABLE_ - 178072);
  v26 = (_DWORD *)v4[22];
  v27 = v26[1];
  v26[11] = 0;
  v26[12] = 0;
  *v26 = v27;
  v26[4] = v26[3];
  v28 = v4[22];
  *(_DWORD *)(v28 + 52) = 0;
  *(_DWORD *)(v28 + 56) = 0;
  v29 = (_DWORD *)v4[22];
  v4[21] = v29 + 15;
  v30 = v40[0];
  qmemcpy(v29 + 15, &GLOBAL_OFFSET_TABLE_ - 416, 0x70u);
  v31 = v40[2];
  v29[23] = 1;
  v29[24] = v30;
  v32 = *(_DWORD *)(v35 + 88);
  v29[28] = 0;
  v29[29] = 1;
  v29[27] = 1;
  v29[30] = v32 + 44;
  *(_DWORD *)((char *)v29 + (_DWORD)(&dword_80CE084 - 33765376)) = 1;
  *(_DWORD *)((char *)v29 + (_DWORD)(&dword_80CE088 - 33765376)) = v31;
  *(_DWORD *)((char *)v29 + (_DWORD)(&dword_80CE098 - 33765376)) = 0;
  *(_DWORD *)((char *)v29 + (_DWORD)(&dword_80CE09C - 33765376)) = 1;
  *(_DWORD *)((char *)v29 + (_DWORD)(&off_80CE094 - 33765376)) = 9;
  *(_DWORD *)((char *)v29 + (_DWORD)(&dword_80CE0A0 - 33765376)) = v32 + 44;
  v4[37] = *(_DWORD *)((char *)v29 + (_DWORD)(&dword_80CE0B0 - 33765376));
  *(_DWORD *)(v35 + 104) = 1;
  return v35;
}
// 80A7040: using guessed type int dword_80A7040[256];
// 80CDF7C: using guessed type int (*off_80CDF7C)[256];
// 80CE000: using guessed type _TBYTE GLOBAL_OFFSET_TABLE_;
// 80CE084: using guessed type int dword_80CE084;
// 80CE088: using guessed type int dword_80CE088;
// 80CE094: using guessed type void *off_80CE094;
// 80CE098: using guessed type int dword_80CE098;
// 80CE09C: using guessed type int dword_80CE09C;
// 80CE0A0: using guessed type int dword_80CE0A0;
// 80CE0B0: using guessed type int dword_80CE0B0;

//----- (080558B0) --------------------------------------------------------
int *__usercall IO_new_file_finish@<eax>(int a1@<ebp>, int tv_nsec@<edi>, struct timespec *a3)
{
  if ( a3[7].tv_sec != -1 )
  {
    if ( a3[13].tv_sec <= 0 )
      IO_new_do_write((int)a3, a3[2].tv_sec, a3[2].tv_nsec - a3[2].tv_sec);
    else
      IO_wdo_write(
        &a3->tv_sec,
        *(_DWORD *)(a3[11].tv_sec + 12),
        (*(_DWORD *)(a3[11].tv_sec + 16) - *(_DWORD *)(a3[11].tv_sec + 12)) >> 2);
    if ( (a3->tv_sec & 0x40) == 0 )
    {
      tv_nsec = a3[18].tv_nsec;
      if ( (char *)&_start___libc_atexit - (char *)_start___libc_IO_vtables <= (unsigned int)(tv_nsec
                                                                                            - (_DWORD)_start___libc_IO_vtables) )
        IO_vtable_check();
      (*(void (__cdecl **)(struct timespec *))(tv_nsec + 68))(a3);
    }
  }
  return IO_default_finish(a1, (int *)tv_nsec, a3);
}
// 80CEFA0: using guessed type int _start___libc_IO_vtables[24];
// 80CF2F4: using guessed type int (*_start___libc_atexit)();

//----- (08055960) --------------------------------------------------------
int __cdecl IO_new_file_overflow(int *a1, int a2)
{
  int v2; // eax
  int v3; // edx
  _BYTE *v4; // edx
  int v6; // edi
  int v7; // ecx
  int v8; // ecx
  int v9; // ecx
  bool v10; // al
  unsigned int v11; // edi
  int v12; // eax

  v2 = *a1;
  if ( (*a1 & 8) != 0 )
  {
    *a1 = v2 | 0x20;
    __writegsdword(0xFFFFFFE0, 9u);
    return -1;
  }
  v3 = a1[4];
  if ( (v2 & 0x800) != 0 )
  {
    if ( v3 )
    {
      v4 = (_BYTE *)a1[5];
      goto LABEL_5;
    }
  }
  else if ( v3 )
  {
    v4 = (_BYTE *)a1[1];
    goto LABEL_14;
  }
  IO_doallocbuf(a1);
  v4 = (_BYTE *)a1[7];
  v2 = *a1;
  a1[3] = (int)v4;
  a1[1] = (int)v4;
  a1[2] = (int)v4;
LABEL_14:
  if ( (v2 & 0x100) != 0 )
  {
    v11 = a1[2] - (_DWORD)v4;
    IO_free_backup_area(v11, (int *)v11, a1);
    v12 = a1[7] - a1[3];
    if ( a1[3] - a1[7] > v11 )
      v12 = -v11;
    v4 = (_BYTE *)(v12 + a1[3]);
    v2 = *a1;
    a1[3] = (int)v4;
    a1[1] = (int)v4;
  }
  v6 = a1[8];
  if ( (_BYTE *)v6 == v4 )
  {
    v4 = (_BYTE *)a1[7];
    a1[2] = (int)v4;
    v7 = (int)v4;
  }
  else
  {
    v7 = a1[2];
  }
  a1[1] = v7;
  a1[3] = v7;
  v8 = v2;
  BYTE1(v8) = BYTE1(v2) | 8;
  a1[5] = (int)v4;
  *a1 = v8;
  v9 = a1[26];
  a1[4] = (int)v4;
  a1[6] = v6;
  if ( v9 <= 0 && (v2 & 0x202) != 0 )
  {
    a1[6] = (int)v4;
    if ( a2 != -1 )
      goto LABEL_6;
    return IO_new_do_write((int)a1, a1[4], (int)&v4[-a1[4]]);
  }
LABEL_5:
  if ( a2 == -1 )
    return IO_new_do_write((int)a1, a1[4], (int)&v4[-a1[4]]);
LABEL_6:
  if ( (_BYTE *)a1[8] == v4 )
  {
    if ( a1[26] <= 0 )
      v10 = IO_new_do_write((int)a1, a1[4], (int)&v4[-a1[4]]) == -1;
    else
      v10 = IO_wdo_write(a1, *(_DWORD *)(a1[22] + 12), (*(_DWORD *)(a1[22] + 16) - *(_DWORD *)(a1[22] + 12)) >> 2) == -1;
    if ( v10 )
      return -1;
    v4 = (_BYTE *)a1[5];
  }
  a1[5] = (int)(v4 + 1);
  *v4 = a2;
  if ( ((*a1 & 2) != 0 || (*a1 & 0x200) != 0 && a2 == 10) && IO_new_do_write((int)a1, a1[4], a1[5] - a1[4]) == -1 )
    return -1;
  return (unsigned __int8)a2;
}

//----- (08055B70) --------------------------------------------------------
int __cdecl IO_new_file_sync(int *a1)
{
  unsigned int v1; // eax
  unsigned int v2; // edx
  bool v3; // al
  int v4; // eax
  int v5; // edi
  __int64 v6; // rax
  int result; // eax
  int v8; // [esp+0h] [ebp-20h]

  v1 = a1[5];
  v2 = a1[4];
  if ( v1 <= v2
    || (a1[26] <= 0 ? (v3 = IO_new_do_write((int)a1, v2, v1 - v2) != 0) : (v3 = IO_wdo_write(
                                                                                  a1,
                                                                                  *(_DWORD *)(a1[22] + 12),
                                                                                  (*(_DWORD *)(a1[22] + 16)
                                                                                 - *(_DWORD *)(a1[22] + 12)) >> 2) != 0),
        !v3) )
  {
    v4 = a1[1] - a1[2];
    if ( !v4 )
    {
LABEL_10:
      a1[19] = -1;
      result = 0;
      a1[20] = -1;
      return result;
    }
    v5 = a1[37];
    if ( (char *)&_start___libc_atexit - (char *)_start___libc_IO_vtables <= (unsigned int)(v5
                                                                                          - (_DWORD)_start___libc_IO_vtables) )
    {
      v8 = a1[1] - a1[2];
      IO_vtable_check();
      v4 = v8;
    }
    v6 = ((__int64 (__cdecl *)(int *, int, int, int))*(_DWORD *)(v5 + 64))(a1, v4, v4 >> 31, 1);
    if ( (HIDWORD(v6) & (unsigned int)v6) != -1 )
    {
      a1[2] = a1[1];
      goto LABEL_10;
    }
    if ( __readgsdword(0xFFFFFFE0) == 29 )
      goto LABEL_10;
  }
  return -1;
}
// 80CEFA0: using guessed type int _start___libc_IO_vtables[24];
// 80CF2F4: using guessed type int (*_start___libc_atexit)();

//----- (08055C60) --------------------------------------------------------
int __usercall save_for_backup@<eax>(_DWORD *a1@<eax>, int a2@<edx>)
{
  _BYTE *v3; // eax
  signed int v4; // edi
  _DWORD *v5; // eax
  _DWORD *v6; // ecx
  unsigned int v7; // edx
  int v8; // esi
  int v9; // ebx
  unsigned int v10; // ecx
  _BYTE *v11; // ebx
  int *v13; // eax
  int *v14; // edx
  unsigned int v15; // edx
  _WORD *v16; // eax
  _BYTE *v17; // [esp-Ch] [ebp-48h]
  _BYTE *v18; // [esp-Ch] [ebp-48h]
  int v19; // [esp+4h] [ebp-38h]
  unsigned int v20; // [esp+4h] [ebp-38h]
  unsigned int v21; // [esp+4h] [ebp-38h]
  _BYTE *v23; // [esp+Ch] [ebp-30h]
  int *v24; // [esp+Ch] [ebp-30h]
  int *v25; // [esp+Ch] [ebp-30h]
  int v26; // [esp+10h] [ebp-2Ch]
  int *v27; // [esp+10h] [ebp-2Ch]
  unsigned int v28; // [esp+14h] [ebp-28h]
  int *v29; // [esp+18h] [ebp-24h]

  v3 = (_BYTE *)a1[3];
  v4 = a2 - (_DWORD)v3;
  v23 = v3;
  v5 = (_DWORD *)a1[12];
  v19 = a1[9];
  v26 = a1[11];
  v6 = v5;
  v7 = v26 - v19;
  v8 = v4;
  if ( !v5 )
  {
    if ( v4 >= 0 )
    {
      a1[10] = v26;
      return 0;
    }
    v11 = (_BYTE *)a1[11];
LABEL_18:
    v21 = v7;
    memmove(v11, (_BYTE *)(v8 + v26), -v8);
    memcpy((_BYTE *)(a1[9] + v21 - v8), (_BYTE *)a1[3], a2 - a1[3]);
    v4 = a2 - a1[3];
    v15 = a1[9] + v21;
    v5 = (_DWORD *)a1[12];
    goto LABEL_15;
  }
  do
  {
    v9 = v6[2];
    v6 = (_DWORD *)*v6;
    if ( v8 > v9 )
      v8 = v9;
  }
  while ( v6 );
  v10 = v4 - v8;
  if ( v4 - v8 <= v7 )
  {
    v7 -= v10;
    v11 = (_BYTE *)(v7 + v19);
    if ( v8 >= 0 )
    {
      v20 = v7;
      if ( !v10 )
      {
        a1[10] = v11;
        goto LABEL_9;
      }
      memcpy(v11, &v23[v8], v10);
      v15 = a1[9] + v20;
      v4 = a2 - a1[3];
      v5 = (_DWORD *)a1[12];
      goto LABEL_15;
    }
    goto LABEL_18;
  }
  v28 = v10 + 100;
  v13 = malloc((const struct timespec *)(v10 + 100));
  v29 = v13;
  if ( v13 )
  {
    if ( v8 < 0 )
    {
      v18 = (_BYTE *)(v26 + v8);
      v27 = v13 + 25;
      v16 = mempcpy((_BYTE *)v13 + 100, v18, -v8);
      memcpy(v16, v23, v4);
      v14 = v27;
    }
    else
    {
      v17 = &v23[v8];
      v24 = v13 + 25;
      memcpy((_BYTE *)v13 + 100, v17, v4 - v8);
      v14 = v24;
    }
    v25 = v14;
    free((int)a1, (int *)v4, v19);
    v4 = a2 - a1[3];
    a1[9] = v29;
    a1[11] = (char *)v29 + v28;
    v15 = (unsigned int)v25;
    v5 = (_DWORD *)a1[12];
LABEL_15:
    a1[10] = v15;
    while ( v5 )
    {
LABEL_9:
      v5[2] -= v4;
      v5 = (_DWORD *)*v5;
    }
    return 0;
  }
  return -1;
}

//----- (08055E80) --------------------------------------------------------
int __usercall flush_cleanup@<eax>(int a1@<ebp>, int *a2@<edi>, const struct timespec *a3@<esi>)
{
  _TBYTE *v3; // edx
  int result; // eax
  bool v5; // zf
  int *v6; // ecx

  v3 = &GLOBAL_OFFSET_TABLE_;
  result = run_fp;
  if ( run_fp )
  {
    if ( (*(_DWORD *)run_fp & 0x8000) == 0 )
    {
      v6 = *(int **)(run_fp + 72);
      v5 = v6[1]-- == 1;
      if ( v5 )
      {
        v6[2] = 0;
        if ( __readgsdword(0xCu) )
          __asm { lock }
        v5 = (*v6)-- == 1;
        if ( !v5 )
          result = _lll_unlock_wake_private(v6, a1, a2, a3);
      }
    }
  }
  v5 = (*(_DWORD *)((char *)v3 + (_DWORD)(&dword_80CF83C - 33765376)))-- == 1;
  if ( v5 )
  {
    *(_DWORD *)((char *)v3 + (_DWORD)(&dword_80CF840 - 33765376)) = 0;
    if ( __readgsdword(0xCu) )
      __asm { lock }
    v5 = (*(_DWORD *)((char *)v3 + (_DWORD)(&list_all_lock - 33765376)))-- == 1;
    if ( !v5 )
      return _lll_unlock_wake_private((int *)((char *)v3 + (_DWORD)(&list_all_lock - 33765376)), a1, a2, a3);
  }
  return result;
}
// 8055EA1: variable 'v3' is possibly undefined
// 80CE000: using guessed type _TBYTE GLOBAL_OFFSET_TABLE_;
// 80CF834: using guessed type int run_fp;
// 80CF838: using guessed type int list_all_lock;
// 80CF83C: using guessed type int dword_80CF83C;
// 80CF840: using guessed type int dword_80CF840;

//----- (08055F10) --------------------------------------------------------
unsigned int __usercall IO_un_link_part_2@<eax>(struct timespec *a1@<eax>, int a2@<ebp>)
{
  unsigned int v4; // edx
  bool v6; // zf
  __time_t tv_sec; // ecx
  int v8; // ebp
  int v9; // eax
  struct timespec *tv_nsec; // ebp
  bool v13; // zf
  struct timespec *v14; // edx
  struct timespec *v15; // edx
  int *v16; // edx
  unsigned int v18; // [esp+10h] [ebp-20h]

  _EBX = &GLOBAL_OFFSET_TABLE_;
  v18 = __readgsdword(0x14u);
  v4 = __readgsdword(8u);
  if ( v4 != dword_80CF840 )
  {
    _ECX = 1;
    v6 = __readgsdword(0xCu) == 0;
    if ( !v6 )
      __asm { lock }
    __asm { cmpxchg ds:(list_all_lock - 80CE000h)[ebx], ecx }
    if ( !v6 )
      _lll_lock_wait_private(0, &list_all_lock, a2, 0);
    dword_80CF840 = v4;
  }
  tv_sec = a1->tv_sec;
  run_fp = (int)a1;
  v8 = ++dword_80CF83C;
  v9 = tv_sec & 0x8000;
  if ( (tv_sec & 0x8000) != 0 )
  {
    v14 = (struct timespec *)IO_list_all;
    if ( !IO_list_all )
    {
      LOBYTE(tv_sec) = tv_sec & 0x7F;
      a1->tv_sec = tv_sec;
      goto LABEL_25;
    }
    goto LABEL_15;
  }
  _EDX = (int *)a1[9].tv_sec;
  tv_nsec = (struct timespec *)__readgsdword(8u);
  if ( tv_nsec != (struct timespec *)_EDX[2] )
  {
    _ECX = 1;
    v13 = __readgsdword(0xCu) == 0;
    if ( !v13 )
      __asm { lock }
    __asm { cmpxchg [edx], ecx }
    if ( !v13 )
      _lll_lock_wait_private(v9, _EDX, (int)tv_nsec, 0);
    _EDX = (int *)a1[9].tv_sec;
    tv_sec = a1->tv_sec;
    _EDX[2] = (int)tv_nsec;
    v9 = tv_sec & 0x8000;
  }
  ++_EDX[1];
  v14 = (struct timespec *)IO_list_all;
  if ( IO_list_all )
  {
LABEL_15:
    tv_nsec = (struct timespec *)v14[6].tv_nsec;
    if ( a1 == v14 )
    {
      IO_list_all = (void *)v14[6].tv_nsec;
    }
    else if ( tv_nsec )
    {
      if ( a1 == tv_nsec )
      {
        tv_nsec = (struct timespec *)((char *)v14 + 52);
LABEL_40:
        tv_nsec->tv_sec = a1[6].tv_nsec;
      }
      else
      {
        while ( 1 )
        {
          v15 = (struct timespec *)tv_nsec[6].tv_nsec;
          if ( !v15 )
            break;
          if ( a1 == v15 )
          {
            tv_nsec = (struct timespec *)((char *)tv_nsec + 52);
            goto LABEL_40;
          }
          tv_nsec = (struct timespec *)tv_nsec[6].tv_nsec;
        }
      }
    }
  }
  LOBYTE(tv_sec) = tv_sec & 0x7F;
  a1->tv_sec = tv_sec;
  if ( !v9 )
  {
    v16 = (int *)a1[9].tv_sec;
    v6 = v16[1]-- == 1;
    if ( v6 )
    {
      v16[2] = 0;
      if ( __readgsdword(0xCu) )
        __asm { lock }
      v6 = (*v16)-- == 1;
      if ( !v6 )
        _lll_unlock_wake_private(v16, (int)tv_nsec, 0, a1);
    }
  }
  v8 = dword_80CF83C;
LABEL_25:
  run_fp = 0;
  dword_80CF83C = v8 - 1;
  if ( v8 == 1 )
  {
    dword_80CF840 = 0;
    if ( __readgsdword(0xCu) )
      __asm { lock }
    if ( --list_all_lock )
      _lll_unlock_wake_private(&list_all_lock, 0, 0, a1);
  }
  return __readgsdword(0x14u) ^ v18;
}
// 8055F8C: variable 'v4' is possibly undefined
// 80CE000: using guessed type _TBYTE GLOBAL_OFFSET_TABLE_;
// 80CE040: using guessed type void *IO_list_all;
// 80CF834: using guessed type int run_fp;
// 80CF838: using guessed type int list_all_lock;
// 80CF83C: using guessed type int dword_80CF83C;
// 80CF840: using guessed type int dword_80CF840;

//----- (08056150) --------------------------------------------------------
struct timespec *__usercall IO_un_link@<eax>(int a1@<ebp>, struct timespec *a2)
{
  struct timespec *result; // eax

  result = a2;
  if ( SLOBYTE(a2->tv_sec) < 0 )
    return (struct timespec *)IO_un_link_part_2(a2, a1);
  return result;
}

//----- (08056170) --------------------------------------------------------
unsigned int __usercall IO_link_in@<eax>(int a1@<ebp>, int *a2)
{
  int v3; // eax
  unsigned int v4; // edx
  bool v6; // zf
  int v7; // eax
  int v8; // edx
  bool v11; // zf
  int v12; // eax
  void *v13; // ecx
  void *v14; // eax
  void *v16; // eax
  unsigned int v17; // [esp+10h] [ebp-20h]

  _EBX = &GLOBAL_OFFSET_TABLE_;
  v17 = __readgsdword(0x14u);
  v3 = *a2;
  if ( (*a2 & 0x80u) != 0 )
    return __readgsdword(0x14u) ^ v17;
  LOBYTE(v3) = v3 | 0x80;
  *a2 = v3;
  v4 = __readgsdword(8u);
  if ( dword_80CF840 != v4 )
  {
    _ECX = 1;
    v6 = __readgsdword(0xCu) == 0;
    if ( !v6 )
      __asm { lock }
    __asm { cmpxchg ds:(list_all_lock - 80CE000h)[ebx], ecx }
    if ( !v6 )
      _lll_lock_wait_private(0, &list_all_lock, a1, a2);
    dword_80CF840 = v4;
  }
  v7 = *a2;
  run_fp = (int)a2;
  v8 = ++dword_80CF83C;
  if ( (v7 & 0x8000) == 0 )
  {
    _EDX = (int *)a2[18];
    a1 = __readgsdword(8u);
    if ( _EDX[2] == a1 )
    {
      v16 = IO_list_all;
      ++_EDX[1];
      IO_list_all = a2;
      a2[13] = (int)v16;
    }
    else
    {
      _ECX = 1;
      v11 = __readgsdword(0xCu) == 0;
      if ( !v11 )
        __asm { lock }
      __asm { cmpxchg [edx], ecx }
      if ( !v11 )
        _lll_lock_wait_private(0, _EDX, a1, a2);
      _EDX = (int *)a2[18];
      v12 = *a2;
      v13 = IO_list_all;
      IO_list_all = a2;
      _EDX[2] = a1;
      ++_EDX[1];
      a2[13] = (int)v13;
      if ( (v12 & 0x8000) != 0 )
        goto LABEL_20;
    }
    v6 = _EDX[1]-- == 1;
    if ( v6 )
    {
      _EDX[2] = 0;
      if ( __readgsdword(0xCu) )
        __asm { lock }
      v6 = (*_EDX)-- == 1;
      if ( !v6 )
        _lll_unlock_wake_private(_EDX, a1, a2, 0);
    }
LABEL_20:
    v8 = dword_80CF83C;
    goto LABEL_22;
  }
  v14 = IO_list_all;
  IO_list_all = a2;
  a2[13] = (int)v14;
LABEL_22:
  run_fp = 0;
  dword_80CF83C = v8 - 1;
  if ( v8 == 1 )
  {
    dword_80CF840 = 0;
    if ( __readgsdword(0xCu) )
      __asm { lock }
    if ( --list_all_lock )
      _lll_unlock_wake_private(&list_all_lock, a1, a2, 0);
  }
  return __readgsdword(0x14u) ^ v17;
}
// 8056200: variable 'v4' is possibly undefined
// 80CE000: using guessed type _TBYTE GLOBAL_OFFSET_TABLE_;
// 80CE040: using guessed type void *IO_list_all;
// 80CF834: using guessed type int run_fp;
// 80CF838: using guessed type int list_all_lock;
// 80CF83C: using guessed type int dword_80CF83C;
// 80CF840: using guessed type int dword_80CF840;

//----- (08056360) --------------------------------------------------------
int __cdecl IO_least_marker(int a1, int a2)
{
  int result; // eax
  _DWORD *v3; // edx
  int v4; // ecx

  result = a2 - *(_DWORD *)(a1 + 12);
  v3 = *(_DWORD **)(a1 + 48);
  while ( v3 )
  {
    v4 = v3[2];
    v3 = (_DWORD *)*v3;
    if ( result > v4 )
      result = v4;
  }
  return result;
}

//----- (08056390) --------------------------------------------------------
_DWORD *__cdecl IO_switch_to_main_get_area(_DWORD *a1)
{
  _DWORD *result; // eax
  int v2; // edx
  int v3; // ecx
  int v4; // ecx
  int v5; // edx

  result = a1;
  v2 = a1[2];
  v3 = a1[11];
  *a1 &= ~0x100u;
  a1[2] = v3;
  v4 = a1[3];
  a1[11] = v2;
  v5 = a1[9];
  a1[9] = v4;
  a1[3] = v5;
  a1[1] = v5;
  return result;
}

//----- (080563C0) --------------------------------------------------------
_DWORD *__cdecl IO_switch_to_backup_area(_DWORD *a1)
{
  _DWORD *result; // eax
  int v2; // ecx
  int v3; // edx
  int v4; // ebx
  int v5; // ecx

  result = a1;
  v2 = a1[2];
  v3 = a1[11];
  v4 = a1[9];
  *a1 |= 0x100u;
  a1[11] = v2;
  v5 = a1[3];
  a1[2] = v3;
  a1[3] = v4;
  a1[9] = v5;
  a1[1] = v3;
  return result;
}

//----- (080563F0) --------------------------------------------------------
int __cdecl IO_switch_to_get_mode(int *a1)
{
  unsigned int v1; // eax
  int v2; // esi
  int result; // eax
  int v4; // edx

  v1 = a1[5];
  if ( v1 <= a1[4] )
  {
LABEL_6:
    v4 = *a1;
    if ( (*a1 & 0x100) != 0 )
    {
      a1[3] = a1[10];
    }
    else
    {
      a1[3] = a1[7];
      if ( a1[2] < v1 )
        a1[2] = v1;
    }
    BYTE1(v4) &= ~8u;
    a1[1] = v1;
    *a1 = v4;
    a1[6] = v1;
    a1[4] = v1;
    return 0;
  }
  v2 = a1[37];
  if ( (char *)&_start___libc_atexit - (char *)_start___libc_IO_vtables <= (unsigned int)(v2
                                                                                        - (_DWORD)_start___libc_IO_vtables) )
    IO_vtable_check();
  result = (*(int (__cdecl **)(int *, int))(v2 + 12))(a1, -1);
  if ( result != -1 )
  {
    v1 = a1[5];
    goto LABEL_6;
  }
  return result;
}
// 80CEFA0: using guessed type int _start___libc_IO_vtables[24];
// 80CF2F4: using guessed type int (*_start___libc_atexit)();

//----- (08056490) --------------------------------------------------------
int *__usercall IO_free_backup_area@<eax>(int ebp0@<ebp>, int *a2@<edi>, int *a3)
{
  int v3; // edx
  int v4; // eax
  int v5; // edx
  int *result; // eax

  v3 = *a3;
  v4 = a3[9];
  if ( (*a3 & 0x100) != 0 )
  {
    BYTE1(v3) &= ~1u;
    a3[1] = v4;
    *a3 = v3;
    a3[2] = a3[11];
    v5 = a3[3];
    a3[3] = v4;
    v4 = v5;
  }
  result = free(ebp0, a2, v4);
  a3[9] = 0;
  a3[11] = 0;
  a3[10] = 0;
  return result;
}

//----- (080564F0) --------------------------------------------------------
int __cdecl _overflow(int a1, int a2)
{
  int v2; // esi

  if ( !*(_DWORD *)(a1 + 104) )
    *(_DWORD *)(a1 + 104) = -1;
  v2 = *(_DWORD *)(a1 + 148);
  if ( (char *)&_start___libc_atexit - (char *)_start___libc_IO_vtables <= (unsigned int)(v2
                                                                                        - (_DWORD)_start___libc_IO_vtables) )
    IO_vtable_check();
  return (*(int (__cdecl **)(int, int))(v2 + 12))(a1, a2);
}
// 80CEFA0: using guessed type int _start___libc_IO_vtables[24];
// 80CF2F4: using guessed type int (*_start___libc_atexit)();

//----- (08056550) --------------------------------------------------------
int __usercall _underflow@<eax>(int ebp0@<ebp>, int *a2@<edi>, int *a3)
{
  int v3; // eax
  unsigned __int8 *v4; // eax
  unsigned int v5; // edx
  int v6; // eax
  unsigned int v7; // ecx
  int v8; // edx
  int v9; // edi

  v3 = a3[26];
  if ( v3 )
  {
    if ( v3 != -1 )
      return -1;
  }
  else
  {
    a3[26] = -1;
  }
  if ( (*a3 & 0x800) != 0 && IO_switch_to_get_mode(a3) == -1 )
    return -1;
  v4 = (unsigned __int8 *)a3[1];
  v5 = a3[2];
  if ( (unsigned int)v4 < v5 )
    return *v4;
  v6 = *a3;
  if ( (*a3 & 0x100) != 0 )
  {
    BYTE1(v6) &= ~1u;
    v7 = a3[11];
    a3[11] = v5;
    *a3 = v6;
    v8 = a3[3];
    v4 = (unsigned __int8 *)a3[9];
    a3[2] = v7;
    a3[9] = v8;
    a3[3] = (int)v4;
    a3[1] = (int)v4;
    if ( v7 > (unsigned int)v4 )
      return *v4;
  }
  if ( !a3[12] )
  {
    if ( a3[9] )
      IO_free_backup_area(ebp0, a2, a3);
    goto LABEL_9;
  }
  if ( save_for_backup(a3, a3[2]) )
    return -1;
LABEL_9:
  v9 = a3[37];
  if ( (char *)&_start___libc_atexit - (char *)_start___libc_IO_vtables <= (unsigned int)(v9
                                                                                        - (_DWORD)_start___libc_IO_vtables) )
    IO_vtable_check();
  return (*(int (__cdecl **)(int *))(v9 + 16))(a3);
}
// 80CEFA0: using guessed type int _start___libc_IO_vtables[24];
// 80CF2F4: using guessed type int (*_start___libc_atexit)();

//----- (08056660) --------------------------------------------------------
int __usercall _uflow@<eax>(int ebp0@<ebp>, int *a2@<edi>, int *a3)
{
  int v3; // eax
  unsigned __int8 *v4; // eax
  unsigned int v5; // edx
  int v6; // eax
  unsigned int v7; // ecx
  int v8; // edx
  int v9; // edi

  v3 = a3[26];
  if ( v3 )
  {
    if ( v3 != -1 )
      return -1;
  }
  else
  {
    a3[26] = -1;
  }
  if ( (*a3 & 0x800) != 0 && IO_switch_to_get_mode(a3) == -1 )
    return -1;
  v4 = (unsigned __int8 *)a3[1];
  v5 = a3[2];
  if ( (unsigned int)v4 < v5 )
    goto LABEL_17;
  v6 = *a3;
  if ( (*a3 & 0x100) == 0 )
    goto LABEL_8;
  BYTE1(v6) &= ~1u;
  v7 = a3[11];
  a3[11] = v5;
  *a3 = v6;
  v8 = a3[3];
  v4 = (unsigned __int8 *)a3[9];
  a3[2] = v7;
  a3[9] = v8;
  a3[3] = (int)v4;
  if ( v7 > (unsigned int)v4 )
  {
LABEL_17:
    a3[1] = (int)(v4 + 1);
    return *v4;
  }
  a3[1] = (int)v4;
LABEL_8:
  if ( !a3[12] )
  {
    if ( a3[9] )
      IO_free_backup_area(ebp0, a2, a3);
    goto LABEL_10;
  }
  if ( save_for_backup(a3, a3[2]) )
    return -1;
LABEL_10:
  v9 = a3[37];
  if ( (char *)&_start___libc_atexit - (char *)_start___libc_IO_vtables <= (unsigned int)(v9
                                                                                        - (_DWORD)_start___libc_IO_vtables) )
    IO_vtable_check();
  return (*(int (__cdecl **)(int *))(v9 + 20))(a3);
}
// 80CEFA0: using guessed type int _start___libc_IO_vtables[24];
// 80CF2F4: using guessed type int (*_start___libc_atexit)();

//----- (08056770) --------------------------------------------------------
int __usercall IO_setb@<eax>(int ebp0@<ebp>, int *edi0@<edi>, int *a3, int a4, int a5, int a6)
{
  int v6; // eax
  int v7; // edx
  int result; // eax
  unsigned int v9; // edx

  v6 = *a3;
  if ( a3[7] && (v6 & 1) == 0 )
  {
    free(ebp0, edi0, a3[7]);
    v6 = *a3;
  }
  a3[7] = a4;
  a3[8] = a5;
  v7 = v6;
  result = v6 | 1;
  v9 = v7 & 0xFFFFFFFE;
  if ( a6 )
    result = v9;
  *a3 = result;
  return result;
}

//----- (080567D0) --------------------------------------------------------
void __cdecl IO_doallocbuf(int *a1)
{
  int v1; // eax
  int v2; // edi
  int *v3; // ebp
  int *v4; // edi

  if ( a1[7] )
    return;
  v1 = *a1;
  if ( (*a1 & 2) != 0 && a1[26] <= 0 )
  {
    v3 = a1 + 18;
    v4 = (int *)((char *)a1 + 71);
LABEL_11:
    a1[7] = (int)v4;
    a1[8] = (int)v3;
    *a1 = v1 | 1;
    return;
  }
  v2 = a1[37];
  if ( (char *)&_start___libc_atexit - (char *)_start___libc_IO_vtables <= (unsigned int)(v2
                                                                                        - (_DWORD)_start___libc_IO_vtables) )
    IO_vtable_check();
  if ( (*(int (__cdecl **)(int *))(v2 + 52))(a1) == -1 )
  {
    v3 = a1 + 18;
    v4 = (int *)((char *)a1 + 71);
    v1 = *a1;
    if ( a1[7] )
    {
      if ( (v1 & 1) == 0 )
      {
        free((int)v3, v4, a1[7]);
        v1 = *a1;
      }
    }
    goto LABEL_11;
  }
}
// 80CEFA0: using guessed type int _start___libc_IO_vtables[24];
// 80CF2F4: using guessed type int (*_start___libc_atexit)();

//----- (08056890) --------------------------------------------------------
int IO_default_underflow()
{
  return -1;
}

//----- (080568A0) --------------------------------------------------------
int __cdecl IO_default_uflow(int a1)
{
  int v1; // esi
  int result; // eax
  unsigned __int8 *v3; // eax

  v1 = *(_DWORD *)(a1 + 148);
  if ( (char *)&_start___libc_atexit - (char *)_start___libc_IO_vtables <= (unsigned int)(v1
                                                                                        - (_DWORD)_start___libc_IO_vtables) )
    IO_vtable_check();
  result = (*(int (__cdecl **)(int))(v1 + 16))(a1);
  if ( result != -1 )
  {
    v3 = *(unsigned __int8 **)(a1 + 4);
    *(_DWORD *)(a1 + 4) = v3 + 1;
    return *v3;
  }
  return result;
}
// 80CEFA0: using guessed type int _start___libc_IO_vtables[24];
// 80CF2F4: using guessed type int (*_start___libc_atexit)();

//----- (08056900) --------------------------------------------------------
unsigned int __cdecl IO_default_xsputn(_DWORD *a1, _BYTE *a2, unsigned int a3)
{
  unsigned int i; // ebp
  _BYTE *v5; // edi
  unsigned int v6; // eax
  unsigned int v7; // eax
  unsigned int v8; // edx
  int v9; // esi
  _BYTE *v10; // edi
  _BYTE *v11; // eax
  _BYTE *v12; // esi
  _WORD *v13; // eax
  unsigned int v15; // [esp+8h] [ebp-20h]
  _BYTE *v16; // [esp+30h] [ebp+8h]
  _BYTE *v17; // [esp+30h] [ebp+8h]

  if ( !a3 )
    return 0;
  for ( i = a3; ; --i )
  {
    v5 = (_BYTE *)a1[5];
    v6 = a1[6];
    if ( (unsigned int)v5 < v6 )
    {
      v7 = v6 - (_DWORD)v5;
      if ( i <= v7 )
        v7 = i;
      v8 = v7;
      if ( v7 > 0x14 )
      {
        v15 = v7;
        v16 = a2;
        v13 = mempcpy(v5, a2, v7);
        v8 = v15;
        a1[5] = v13;
        a2 = &v16[v15];
      }
      else if ( v7 )
      {
        v11 = &v5[v7];
        v12 = a2;
        do
          *v5++ = *v12++;
        while ( v5 != v11 );
        a2 += v8;
        a1[5] = v5;
      }
      i -= v8;
    }
    if ( !i )
      break;
    v9 = a1[37];
    if ( (char *)&_start___libc_atexit - (char *)_start___libc_IO_vtables <= (unsigned int)(v9
                                                                                          - (_DWORD)_start___libc_IO_vtables) )
    {
      v17 = a2;
      IO_vtable_check();
      a2 = v17;
    }
    v10 = a2 + 1;
    if ( (*(int (__cdecl **)(_DWORD *, _DWORD))(v9 + 12))(a1, (unsigned __int8)*a2) == -1 )
    {
      a3 -= i;
      return a3;
    }
    a2 = v10;
  }
  return a3;
}
// 80CEFA0: using guessed type int _start___libc_IO_vtables[24];
// 80CF2F4: using guessed type int (*_start___libc_atexit)();

//----- (08056A40) --------------------------------------------------------
int __cdecl IO_sgetn(int a1, int a2, int a3)
{
  int v3; // ebx

  v3 = *(_DWORD *)(a1 + 148);
  if ( (char *)&_start___libc_atexit - (char *)_start___libc_IO_vtables <= (unsigned int)(v3
                                                                                        - (_DWORD)_start___libc_IO_vtables) )
    IO_vtable_check();
  return (*(int (__cdecl **)(int, int, int))(v3 + 32))(a1, a2, a3);
}
// 80CEFA0: using guessed type int _start___libc_IO_vtables[24];
// 80CF2F4: using guessed type int (*_start___libc_atexit)();

//----- (08056AB0) --------------------------------------------------------
unsigned int __usercall IO_default_xsgetn@<eax>(int *a1@<edi>, int *a2, int *a3, unsigned int a4)
{
  unsigned int v6; // ecx
  unsigned int v7; // esi
  unsigned int v8; // ebp
  int v9; // eax
  int v11; // eax
  int *v12; // eax
  unsigned int v13; // [esp+0h] [ebp-24h]
  unsigned int v14; // [esp+0h] [ebp-24h]
  int *v15; // [esp+28h] [ebp+4h]
  int *v16; // [esp+28h] [ebp+4h]

  v6 = a4;
  while ( 1 )
  {
    v7 = a2[1];
    v8 = a2[2];
    if ( v7 < v8 )
    {
      v8 -= v7;
      if ( v6 <= v8 )
        v8 = v6;
      if ( v8 > 0x14 )
      {
        v16 = a2;
        v14 = v6;
        v12 = (int *)mempcpy(a3, (_BYTE *)v7, v8);
        a2 = v16;
        v6 = v14;
        a3 = v12;
        v16[1] += v8;
      }
      else if ( v8 )
      {
        v11 = v7 + v8;
        a1 = a3;
        do
        {
          *(_BYTE *)a1 = *(_BYTE *)v7++;
          a1 = (int *)((char *)a1 + 1);
        }
        while ( v11 != v7 );
        a3 = (int *)((char *)a3 + v8);
        a2[1] = v11;
      }
      v6 -= v8;
    }
    v13 = v6;
    if ( !v6 )
      break;
    v15 = a2;
    v9 = _underflow(v8, a1, a2);
    a2 = v15;
    v6 = v13;
    if ( v9 == -1 )
    {
      a4 -= v13;
      return a4;
    }
  }
  return a4;
}

//----- (08056B80) --------------------------------------------------------
_DWORD *__cdecl IO_default_setbuf(_DWORD *a1, int *a2, int a3)
{
  int v3; // ebp
  int v4; // eax
  int v5; // ecx
  int v6; // edx
  unsigned int v7; // edx
  char *v8; // ebp
  _DWORD *result; // eax
  int v10; // edx
  int *v11; // edi
  char *v12; // ebp

  v3 = a1[37];
  if ( (char *)&_start___libc_atexit - (char *)_start___libc_IO_vtables <= (unsigned int)(v3
                                                                                        - (_DWORD)_start___libc_IO_vtables) )
    IO_vtable_check();
  if ( (*(int (__cdecl **)(_DWORD *))(v3 + 48))(a1) == -1 )
    return 0;
  v4 = *a1;
  v5 = a1[7];
  v6 = *a1;
  if ( a2 && a3 )
  {
    v7 = v6 & 0xFFFFFFFD;
    *a1 = v7;
    v8 = (char *)a2 + a3;
    if ( v5 )
    {
      if ( (v4 & 1) == 0 )
      {
        free((int)v8, a2, v5);
        v7 = *a1;
      }
    }
    a1[7] = a2;
    a1[8] = v8;
    *a1 = v7 | 1;
  }
  else
  {
    v10 = v6 | 2;
    v11 = a1 + 18;
    v12 = (char *)a1 + 71;
    *a1 = v10;
    if ( v5 && (v4 & 1) == 0 )
    {
      free((int)v12, v11, v5);
      v10 = *a1;
    }
    a1[7] = v12;
    a1[8] = v11;
    *a1 = v10 | 1;
  }
  a1[6] = 0;
  result = a1;
  a1[5] = 0;
  a1[4] = 0;
  a1[2] = 0;
  a1[1] = 0;
  a1[3] = 0;
  return result;
}
// 80CEFA0: using guessed type int _start___libc_IO_vtables[24];
// 80CF2F4: using guessed type int (*_start___libc_atexit)();

//----- (08056CA0) --------------------------------------------------------
int __cdecl IO_default_seekpos(int a1, int a2, int a3, int a4)
{
  int v4; // ebx

  v4 = *(_DWORD *)(a1 + 148);
  if ( (char *)&_start___libc_atexit - (char *)_start___libc_IO_vtables <= (unsigned int)(v4
                                                                                        - (_DWORD)_start___libc_IO_vtables) )
    IO_vtable_check();
  return (*(int (__cdecl **)(int, int, int, _DWORD, int))(v4 + 36))(a1, a2, a3, 0, a4);
}
// 80CEFA0: using guessed type int _start___libc_IO_vtables[24];
// 80CF2F4: using guessed type int (*_start___libc_atexit)();

//----- (08056D00) --------------------------------------------------------
int __usercall IO_default_doallocate@<eax>(int a1@<ebp>, unsigned int *a2)
{
  int *v2; // eax
  int v3; // ecx
  int *v4; // edi
  unsigned int v5; // edx
  int result; // eax
  int *v7; // [esp+0h] [ebp-10h]

  v2 = malloc((const struct timespec *)0x2000);
  if ( !v2 )
    return -1;
  v3 = a2[7];
  v4 = v2 + 2048;
  v5 = *a2;
  if ( v3 )
  {
    if ( (v5 & 1) == 0 )
    {
      v7 = v2;
      free(a1, v4, v3);
      v5 = *a2;
      v2 = v7;
    }
  }
  a2[7] = (unsigned int)v2;
  result = 1;
  a2[8] = (unsigned int)v4;
  *a2 = v5 & 0xFFFFFFFE;
  return result;
}

//----- (08056D80) --------------------------------------------------------
_TBYTE *IO_enable_locks()
{
  _TBYTE *result; // eax

  result = &GLOBAL_OFFSET_TABLE_;
  if ( !stdio_needs_locking )
  {
    stdio_needs_locking = 1;
    result = (_TBYTE *)IO_list_all;
    if ( IO_list_all )
    {
      do
      {
        *((_DWORD *)result + 15) |= 0x80u;
        result = (_TBYTE *)*((_DWORD *)result + 13);
      }
      while ( result );
    }
  }
  return result;
}
// 80CE000: using guessed type _TBYTE GLOBAL_OFFSET_TABLE_;
// 80CE040: using guessed type void *IO_list_all;
// 80CF830: using guessed type int stdio_needs_locking;

//----- (08056DC0) --------------------------------------------------------
_DWORD *__cdecl IO_old_init(int a1, int a2)
{
  _DWORD *result; // eax

  *(_DWORD *)(a1 + 60) = 0;
  *(_DWORD *)a1 = a2 | 0xFBAD0000;
  if ( stdio_needs_locking )
    *(_DWORD *)(a1 + 60) = 128;
  *(_DWORD *)(a1 + 28) = 0;
  *(_DWORD *)(a1 + 32) = 0;
  *(_DWORD *)(a1 + 12) = 0;
  *(_DWORD *)(a1 + 4) = 0;
  *(_DWORD *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 20) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  *(_DWORD *)(a1 + 52) = 0;
  *(_DWORD *)(a1 + 36) = 0;
  *(_DWORD *)(a1 + 40) = 0;
  *(_DWORD *)(a1 + 44) = 0;
  *(_DWORD *)(a1 + 48) = 0;
  *(_WORD *)(a1 + 68) = 0;
  result = *(_DWORD **)(a1 + 72);
  if ( result )
  {
    *result = 0;
    result[1] = 0;
    result[2] = 0;
  }
  return result;
}
// 80CF830: using guessed type int stdio_needs_locking;

//----- (08056E80) --------------------------------------------------------
__int64 __cdecl IO_init_internal(_DWORD *a1, int a2)
{
  __int64 v3; // [esp-8h] [ebp-Ch]

  IO_old_init((int)a1, a2);
  a1[26] = -1;
  a1[22] = -1;
  a1[23] = 0;
  return v3;
}
// 8056EA8: variable 'v3' is possibly undefined

//----- (08056EB0) --------------------------------------------------------
__int64 __cdecl IO_init(_DWORD *a1, int a2)
{
  __int64 v3; // [esp-8h] [ebp-Ch]

  IO_old_init((int)a1, a2);
  a1[26] = -1;
  a1[22] = -1;
  a1[23] = 0;
  return v3;
}
// 8056ED8: variable 'v3' is possibly undefined

//----- (08056EE0) --------------------------------------------------------
int __cdecl IO_no_init(_DWORD *a1, int a2, int a3, _DWORD *a4, int a5)
{
  int result; // eax
  int v6; // [esp-8h] [ebp-14h]

  IO_old_init((int)a1, a2);
  a1[26] = a3;
  result = v6;
  if ( a3 < 0 )
  {
    a1[22] = -1;
  }
  else
  {
    result = a5;
    a1[22] = a4;
    a4[6] = 0;
    a4[7] = 0;
    a4[2] = 0;
    *a4 = 0;
    a4[1] = 0;
    a4[3] = 0;
    a4[4] = 0;
    a4[5] = 0;
    a4[8] = 0;
    a4[9] = 0;
    a4[10] = 0;
    a4[44] = a5;
  }
  a1[23] = 0;
  return result;
}
// 8056F00: variable 'v6' is possibly undefined

//----- (08056F90) --------------------------------------------------------
int IO_default_sync()
{
  return 0;
}

//----- (08056FA0) --------------------------------------------------------
int *__usercall IO_default_finish@<eax>(int a1@<ebp>, int *a2@<edi>, struct timespec *a3)
{
  _DWORD *i; // edx
  int *result; // eax

  if ( a3[3].tv_nsec && (a3->tv_sec & 1) == 0 )
  {
    free(a1, a2, a3[3].tv_nsec);
    a3[4].tv_sec = 0;
    a3[3].tv_nsec = 0;
  }
  for ( i = (_DWORD *)a3[6].tv_sec; i; i = (_DWORD *)*i )
    i[1] = 0;
  result = (int *)a3[4].tv_nsec;
  if ( result )
  {
    result = free(a1, a2, a3[4].tv_nsec);
    a3[4].tv_nsec = 0;
  }
  if ( SLOBYTE(a3->tv_sec) < 0 )
    return (int *)IO_un_link_part_2(a3, a1);
  return result;
}

//----- (08057040) --------------------------------------------------------
__int64 IO_default_seekoff()
{
  return -1LL;
}

//----- (08057050) --------------------------------------------------------
int __cdecl IO_sputbackc(_DWORD *a1, int a2)
{
  int v2; // eax
  unsigned int v3; // edx
  int v4; // esi
  int result; // eax

  v2 = a2;
  v3 = a1[1];
  if ( v3 > a1[3] && *(_BYTE *)(v3 - 1) == (_BYTE)a2 )
  {
    result = (unsigned __int8)a2;
    a1[1] = v3 - 1;
LABEL_6:
    *a1 &= ~0x10u;
    return result;
  }
  v4 = a1[37];
  if ( (char *)&_start___libc_atexit - (char *)_start___libc_IO_vtables <= (unsigned int)(v4
                                                                                        - (_DWORD)_start___libc_IO_vtables) )
  {
    IO_vtable_check();
    v2 = a2;
  }
  result = (*(int (__cdecl **)(_DWORD *, int))(v4 + 24))(a1, v2);
  if ( result != -1 )
    goto LABEL_6;
  return result;
}
// 80CEFA0: using guessed type int _start___libc_IO_vtables[24];
// 80CF2F4: using guessed type int (*_start___libc_atexit)();

//----- (080570D0) --------------------------------------------------------
int __cdecl IO_sungetc(_DWORD *a1)
{
  unsigned int v1; // eax
  int result; // eax
  int v3; // esi

  v1 = a1[1];
  if ( v1 > a1[3] )
  {
    a1[1] = v1 - 1;
    result = *(unsigned __int8 *)(v1 - 1);
LABEL_3:
    *a1 &= ~0x10u;
    return result;
  }
  v3 = a1[37];
  if ( (char *)&_start___libc_atexit - (char *)_start___libc_IO_vtables <= (unsigned int)(v3
                                                                                        - (_DWORD)_start___libc_IO_vtables) )
    IO_vtable_check();
  result = (*(int (__cdecl **)(_DWORD *, int))(v3 + 24))(a1, -1);
  if ( result != -1 )
    goto LABEL_3;
  return result;
}
// 80CEFA0: using guessed type int _start___libc_IO_vtables[24];
// 80CF2F4: using guessed type int (*_start___libc_atexit)();

//----- (08057150) --------------------------------------------------------
int __cdecl IO_adjust_column(int a1, unsigned int a2, int a3)
{
  unsigned int v3; // eax
  unsigned int v4; // edx

  v3 = a2 + a3;
  if ( a2 < a2 + a3 )
  {
    v4 = v3 - 1;
    if ( *(_BYTE *)(v3 - 1) == 10 )
      return 0;
    while ( a2 != v4 )
    {
      if ( *(_BYTE *)--v4 == 10 )
        return v3 - v4 - 1;
    }
  }
  return a3 + a1;
}

//----- (080571A0) --------------------------------------------------------
int __usercall IO_flush_all_lockp@<eax>(int *a1@<edi>, int a2)
{
  unsigned int v3; // edx
  bool v5; // zf
  int v6; // eax
  const struct timespec *v7; // esi
  int v8; // edi
  int tv_nsec; // eax
  int *tv_sec; // edx
  bool v13; // zf
  unsigned int v15; // [esp+8h] [ebp-48h]
  int v16; // [esp+10h] [ebp-40h]
  int (__usercall *v17)@<eax>(int@<ebp>, int *@<edi>, const struct timespec *@<esi>); // [esp+20h] [ebp-30h]
  int v18; // [esp+24h] [ebp-2Ch]
  unsigned int v19; // [esp+30h] [ebp-20h]

  _EBX = &GLOBAL_OFFSET_TABLE_;
  v19 = __readgsdword(0x14u);
  v18 = 0;
  v17 = flush_cleanup;
  v3 = __readgsdword(8u);
  if ( dword_80CF840 != v3 )
  {
    _ECX = 1;
    v5 = __readgsdword(0xCu) == 0;
    if ( !v5 )
      __asm { lock }
    __asm { cmpxchg ds:(list_all_lock - 80CE000h)[ebx], ecx }
    if ( !v5 )
      _lll_lock_wait_private(0, &list_all_lock, a2, a1);
    dword_80CF840 = v3;
  }
  v6 = dword_80CF83C;
  v7 = (const struct timespec *)IO_list_all;
  v8 = 0;
  ++dword_80CF83C;
  if ( IO_list_all )
  {
    v15 = __readgsdword(8u);
    while ( 1 )
    {
      run_fp = (int)v7;
      if ( a2 && (v7->tv_sec & 0x8000) == 0 )
      {
        _EDX = (int *)v7[9].tv_sec;
        if ( _EDX[2] != v15 )
        {
          _ECX = 1;
          v13 = __readgsdword(0xCu) == 0;
          if ( !v13 )
            __asm { lock }
          __asm { cmpxchg [edx], ecx }
          if ( !v13 )
            _lll_lock_wait_private(0, _EDX, a2, (int *)v8);
          _EDX = (int *)v7[9].tv_sec;
          _EDX[2] = v15;
        }
        ++_EDX[1];
      }
      if ( v7[13].tv_sec > 0 )
      {
        if ( *(_DWORD *)(v7[11].tv_sec + 16) > *(_DWORD *)(v7[11].tv_sec + 12) )
          goto LABEL_10;
      }
      else if ( v7[2].tv_nsec > (unsigned int)v7[2].tv_sec )
      {
LABEL_10:
        tv_nsec = v7[18].tv_nsec;
        if ( (char *)&_start___libc_atexit - (char *)_start___libc_IO_vtables <= (unsigned int)(tv_nsec
                                                                                              - (_DWORD)_start___libc_IO_vtables) )
        {
          v16 = v7[18].tv_nsec;
          IO_vtable_check();
          tv_nsec = v16;
        }
        if ( (*(int (__cdecl **)(const struct timespec *, int))(tv_nsec + 12))(v7, -1) == -1 )
          v8 = -1;
      }
      if ( a2 )
      {
        if ( (v7->tv_sec & 0x8000) == 0 )
        {
          tv_sec = (int *)v7[9].tv_sec;
          v5 = tv_sec[1]-- == 1;
          if ( v5 )
          {
            tv_sec[2] = 0;
            if ( __readgsdword(0xCu) )
              __asm { lock }
            v5 = (*tv_sec)-- == 1;
            if ( !v5 )
              _lll_unlock_wake_private(tv_sec, a2, (int *)v8, v7);
          }
        }
      }
      run_fp = 0;
      v7 = (const struct timespec *)v7[6].tv_nsec;
      if ( !v7 )
      {
        v6 = dword_80CF83C - 1;
        break;
      }
    }
  }
  dword_80CF83C = v6;
  if ( !v6 )
  {
    dword_80CF840 = 0;
    if ( __readgsdword(0xCu) )
      __asm { lock }
    if ( --list_all_lock )
      _lll_unlock_wake_private(&list_all_lock, a2, (int *)v8, v7);
  }
  return v8;
}
// 80573A2: conditional instruction was optimized away because %var_44.4==0
// 8057226: variable 'v3' is possibly undefined
// 80CE000: using guessed type _TBYTE GLOBAL_OFFSET_TABLE_;
// 80CE040: using guessed type void *IO_list_all;
// 80CEFA0: using guessed type int _start___libc_IO_vtables[24];
// 80CF2F4: using guessed type int (*_start___libc_atexit)();
// 80CF834: using guessed type int run_fp;
// 80CF838: using guessed type int list_all_lock;
// 80CF83C: using guessed type int dword_80CF83C;
// 80CF840: using guessed type int dword_80CF840;

//----- (08057410) --------------------------------------------------------
int __usercall IO_cleanup@<eax>(int a1@<ebp>, int *a2@<edi>)
{
  unsigned int v3; // edx
  bool v5; // zf
  int v6; // eax
  const struct timespec *v7; // esi
  int tv_nsec; // eax
  int *v11; // edx
  int v13; // eax
  __time_t tv_sec; // eax
  unsigned int v15; // [esp+0h] [ebp-50h]
  int v16; // [esp+4h] [ebp-4Ch]
  int v17; // [esp+8h] [ebp-48h]

  _EBX = &GLOBAL_OFFSET_TABLE_;
  v16 = IO_flush_all_lockp(a2, 0);
  v3 = __readgsdword(8u);
  if ( v3 != dword_80CF840 )
  {
    _ECX = 1;
    v5 = __readgsdword(0xCu) == 0;
    if ( !v5 )
      __asm { lock }
    __asm { cmpxchg ds:(list_all_lock - 80CE000h)[ebx], ecx }
    if ( !v5 )
      _lll_lock_wait_private(0, &list_all_lock, a1, 0);
    dword_80CF840 = v3;
  }
  v6 = dword_80CF83C;
  v7 = (const struct timespec *)IO_list_all;
  ++dword_80CF83C;
  if ( IO_list_all )
  {
    v15 = __readgsdword(8u);
    do
    {
      while ( 1 )
      {
        a1 = v7->tv_sec & 2;
        if ( !a1 && v7[13].tv_sec )
        {
          _EDX = v7[9].tv_sec;
          if ( _EDX )
          {
            if ( *(_DWORD *)(_EDX + 8) == v15 )
            {
              ++*(_DWORD *)(_EDX + 4);
            }
            else
            {
              _ECX = 1;
              if ( __readgsdword(0xCu) )
                __asm { lock }
              __asm { cmpxchg [edx], ecx }
              tv_sec = v7[9].tv_sec;
              *(_DWORD *)(tv_sec + 4) = 1;
              *(_DWORD *)(tv_sec + 8) = v15;
            }
          }
          if ( !dealloc_buffers && (v7->tv_sec & 1) == 0 )
          {
            v7->tv_sec |= 1u;
            v13 = freeres_list;
            freeres_list = (int)v7;
            v7[11].tv_nsec = v13;
            v7[12].tv_sec = v7[3].tv_nsec;
          }
          tv_nsec = v7[18].tv_nsec;
          if ( (char *)&_start___libc_atexit - (char *)_start___libc_IO_vtables <= (unsigned int)(tv_nsec
                                                                                                - (_DWORD)_start___libc_IO_vtables) )
          {
            v17 = v7[18].tv_nsec;
            IO_vtable_check();
            tv_nsec = v17;
          }
          (*(void (__cdecl **)(const struct timespec *, _DWORD, _DWORD))(tv_nsec + 44))(v7, 0, 0);
          if ( v7[13].tv_sec > 0 )
            IO_wsetb(a1, 0, (int)v7, 0, 0, 0);
          v11 = (int *)v7[9].tv_sec;
          if ( v11 )
          {
            v5 = v11[1]-- == 1;
            if ( v5 )
              break;
          }
        }
        v7[13].tv_sec = -1;
        v7 = (const struct timespec *)v7[6].tv_nsec;
        if ( !v7 )
          goto LABEL_31;
      }
      v11[2] = 0;
      if ( __readgsdword(0xCu) )
        __asm { lock }
      v5 = (*v11)-- == 1;
      if ( !v5 )
        _lll_unlock_wake_private(v11, a1, 0, v7);
      v7[13].tv_sec = -1;
      v7 = (const struct timespec *)v7[6].tv_nsec;
    }
    while ( v7 );
LABEL_31:
    v6 = dword_80CF83C - 1;
  }
  dword_80CF83C = v6;
  if ( !v6 )
  {
    dword_80CF840 = 0;
    if ( __readgsdword(0xCu) )
      __asm { lock }
    if ( --list_all_lock )
      _lll_unlock_wake_private(&list_all_lock, a1, 0, v7);
  }
  return v16;
}
// 8057539: conditional instruction was optimized away because ebp.4==0
// 80575D3: conditional instruction was optimized away because ebp.4==0
// 805749C: variable 'v3' is possibly undefined
// 80CE000: using guessed type _TBYTE GLOBAL_OFFSET_TABLE_;
// 80CE040: using guessed type void *IO_list_all;
// 80CEFA0: using guessed type int _start___libc_IO_vtables[24];
// 80CF2F4: using guessed type int (*_start___libc_atexit)();
// 80CF828: using guessed type int freeres_list;
// 80CF82C: using guessed type char dealloc_buffers;
// 80CF838: using guessed type int list_all_lock;
// 80CF83C: using guessed type int dword_80CF83C;
// 80CF840: using guessed type int dword_80CF840;

//----- (08057720) --------------------------------------------------------
int __usercall IO_flush_all@<eax>(int *a1@<edi>)
{
  return IO_flush_all_lockp(a1, 1);
}

//----- (08057740) --------------------------------------------------------
unsigned int __usercall flushlbf@<eax>(int a1@<ebp>, int *a2@<edi>)
{
  unsigned int v3; // edx
  bool v5; // zf
  int v6; // eax
  const struct timespec *tv_nsec; // esi
  bool v10; // zf
  __time_t v11; // eax
  int *v12; // edx
  __time_t tv_sec; // edx
  int v14; // eax
  int v15; // eax
  int v17; // [esp+8h] [ebp-40h]
  int (__usercall *v18)@<eax>(int@<ebp>, int *@<edi>, const struct timespec *@<esi>); // [esp+18h] [ebp-30h]
  int v19; // [esp+1Ch] [ebp-2Ch]
  unsigned int v20; // [esp+28h] [ebp-20h]

  _EBX = &GLOBAL_OFFSET_TABLE_;
  v20 = __readgsdword(0x14u);
  v19 = 0;
  v18 = flush_cleanup;
  v3 = __readgsdword(8u);
  if ( dword_80CF840 != v3 )
  {
    _ECX = 1;
    v5 = __readgsdword(0xCu) == 0;
    if ( !v5 )
      __asm { lock }
    __asm { cmpxchg ds:(list_all_lock - 80CE000h)[ebx], ecx }
    if ( !v5 )
      _lll_lock_wait_private(0, &list_all_lock, a1, a2);
    dword_80CF840 = v3;
  }
  v6 = dword_80CF83C;
  tv_nsec = (const struct timespec *)IO_list_all;
  ++dword_80CF83C;
  if ( IO_list_all )
  {
    a2 = _start___libc_IO_vtables;
    a1 = __readgsdword(8u);
    while ( 1 )
    {
      tv_sec = tv_nsec->tv_sec;
      run_fp = (int)tv_nsec;
      v14 = tv_sec & 0x8000;
      if ( (tv_sec & 0x8000) == 0 )
        break;
      if ( (tv_sec & 0x208) == 512 )
        goto LABEL_25;
LABEL_22:
      run_fp = 0;
      tv_nsec = (const struct timespec *)tv_nsec[6].tv_nsec;
      if ( !tv_nsec )
      {
        v6 = dword_80CF83C - 1;
        goto LABEL_29;
      }
    }
    _EDX = (int *)tv_nsec[9].tv_sec;
    if ( _EDX[2] != a1 )
    {
      _ECX = 1;
      v10 = __readgsdword(0xCu) == 0;
      if ( !v10 )
        __asm { lock }
      __asm { cmpxchg [edx], ecx }
      if ( !v10 )
        _lll_lock_wait_private(v14, _EDX, a1, _start___libc_IO_vtables);
      _EDX = (int *)tv_nsec[9].tv_sec;
      _EDX[2] = a1;
    }
    v11 = tv_nsec->tv_sec;
    ++_EDX[1];
    if ( (v11 & 0x208) == 512 )
    {
LABEL_25:
      v15 = tv_nsec[18].tv_nsec;
      if ( (char *)&_start___libc_atexit - (char *)_start___libc_IO_vtables <= (unsigned int)(v15
                                                                                            - (_DWORD)_start___libc_IO_vtables) )
      {
        v17 = tv_nsec[18].tv_nsec;
        IO_vtable_check();
        v15 = v17;
      }
      (*(void (__cdecl **)(const struct timespec *, int))(v15 + 12))(tv_nsec, -1);
    }
    if ( (tv_nsec->tv_sec & 0x8000) == 0 )
    {
      v12 = (int *)tv_nsec[9].tv_sec;
      v5 = v12[1]-- == 1;
      if ( v5 )
      {
        v12[2] = 0;
        if ( __readgsdword(0xCu) )
          __asm { lock }
        v5 = (*v12)-- == 1;
        if ( !v5 )
          _lll_unlock_wake_private(v12, a1, _start___libc_IO_vtables, tv_nsec);
      }
    }
    goto LABEL_22;
  }
LABEL_29:
  dword_80CF83C = v6;
  if ( !v6 )
  {
    dword_80CF840 = 0;
    if ( __readgsdword(0xCu) )
      __asm { lock }
    if ( --list_all_lock )
      _lll_unlock_wake_private(&list_all_lock, a1, a2, tv_nsec);
  }
  return __readgsdword(0x14u) ^ v20;
}
// 805790A: conditional instruction was optimized away because %var_44.4==0
// 80577C2: variable 'v3' is possibly undefined
// 80CE000: using guessed type _TBYTE GLOBAL_OFFSET_TABLE_;
// 80CE040: using guessed type void *IO_list_all;
// 80CEFA0: using guessed type int _start___libc_IO_vtables[24];
// 80CF2F4: using guessed type int (*_start___libc_atexit)();
// 80CF834: using guessed type int run_fp;
// 80CF838: using guessed type int list_all_lock;
// 80CF83C: using guessed type int dword_80CF83C;
// 80CF840: using guessed type int dword_80CF840;

//----- (08057970) --------------------------------------------------------
int __cdecl IO_init_marker(int *a1, int *a2)
{
  int v2; // edx
  int v3; // eax
  int v4; // eax
  int result; // eax

  v2 = *a2;
  a1[1] = (int)a2;
  if ( (v2 & 0x800) != 0 )
  {
    IO_switch_to_get_mode(a2);
    v2 = *a2;
  }
  v3 = a2[1];
  if ( (v2 & 0x100) != 0 )
    v4 = v3 - a2[2];
  else
    v4 = v3 - a2[3];
  a1[2] = v4;
  result = a2[12];
  *a1 = result;
  a2[12] = (int)a1;
  return result;
}

//----- (080579D0) --------------------------------------------------------
_DWORD *__cdecl IO_remove_marker(_DWORD *a1)
{
  _DWORD *result; // eax
  _DWORD *v2; // edx

  result = (_DWORD *)a1[1];
  v2 = (_DWORD *)result[12];
  if ( v2 )
  {
    if ( a1 == v2 )
    {
      v2 = result + 12;
LABEL_8:
      result = (_DWORD *)*a1;
      *v2 = *a1;
    }
    else
    {
      while ( 1 )
      {
        result = (_DWORD *)*v2;
        if ( !*v2 )
          break;
        if ( a1 == result )
          goto LABEL_8;
        v2 = (_DWORD *)*v2;
      }
    }
  }
  return result;
}

//----- (08057A10) --------------------------------------------------------
int __cdecl IO_marker_difference(int a1, int a2)
{
  return *(_DWORD *)(a1 + 8) - *(_DWORD *)(a2 + 8);
}

//----- (08057A30) --------------------------------------------------------
int __cdecl IO_marker_delta(int a1)
{
  _DWORD *v1; // eax
  int v2; // edx
  int v3; // edx

  v1 = *(_DWORD **)(a1 + 4);
  if ( !v1 )
    return -1;
  v2 = v1[1];
  if ( (*v1 & 0x100) != 0 )
    v3 = v2 - v1[2];
  else
    v3 = v2 - v1[3];
  return *(_DWORD *)(a1 + 8) - v3;
}

//----- (08057A70) --------------------------------------------------------
int __cdecl IO_seekmark(int *a1, int a2)
{
  int v2; // ecx
  int v3; // edx
  int v4; // esi
  int v5; // ebx
  int v7; // esi
  int v8; // edx
  int v9; // edx
  int v10; // esi
  int v11; // edx
  int v12; // ebx

  if ( *(int **)(a2 + 4) != a1 )
    return -1;
  v2 = *(_DWORD *)(a2 + 8);
  v3 = *a1;
  v4 = *a1 & 0x100;
  if ( v2 < 0 )
  {
    v5 = a1[2];
    if ( !v4 )
    {
      BYTE1(v3) |= 1u;
      v10 = a1[9];
      *a1 = v3;
      v11 = a1[11];
      a1[11] = v5;
      v12 = a1[3];
      a1[2] = v11;
      a1[9] = v12;
      v5 = v11;
      a1[3] = v10;
    }
  }
  else
  {
    v5 = a1[3];
    if ( v4 )
    {
      BYTE1(v3) &= ~1u;
      v7 = a1[11];
      *a1 = v3;
      v8 = a1[2];
      a1[2] = v7;
      a1[11] = v8;
      v9 = a1[9];
      a1[9] = v5;
      a1[3] = v9;
      v5 = v9;
    }
  }
  a1[1] = v5 + v2;
  return 0;
}

//----- (08057B00) --------------------------------------------------------
int *__usercall IO_unsave_markers@<eax>(int ebp0@<ebp>, int *a2@<edi>, int *a3)
{
  int *result; // eax

  result = a3;
  if ( a3[12] )
    a3[12] = 0;
  if ( a3[9] )
    return IO_free_backup_area(ebp0, a2, a3);
  return result;
}

//----- (08057B40) --------------------------------------------------------
int __cdecl IO_default_pbackfail(int *a1, int a2)
{
  int v2; // edx
  int *v3; // edi
  int *v4; // ebp
  int v5; // eax
  int v7; // edi
  int *v8; // eax
  unsigned int v9; // edx
  int v10; // ecx
  int *v11; // eax
  int v12; // edx
  unsigned int v13; // [esp+18h] [ebp-24h]
  int v14; // [esp+18h] [ebp-24h]
  int v15; // [esp+18h] [ebp-24h]
  int v16; // [esp+1Ch] [ebp-20h]

  v2 = *a1;
  v3 = (int *)a1[1];
  v4 = (int *)a1[3];
  v5 = *a1 & 0x100;
  if ( v3 <= v4 )
  {
    if ( v5 )
    {
      v13 = a1[2] - (_DWORD)v4;
      v7 = 2 * v13;
      v8 = malloc((const struct timespec *)(2 * v13));
      if ( v8 )
      {
        v9 = v13;
        v16 = 2 * v13;
        v14 = (int)v8;
        v3 = (int *)((char *)v8 + v7 - v9);
        memcpy(v3, v4, v9);
        free((int)v4, v3, (int)v4);
        a1[10] = (int)v3;
        a1[3] = v14;
        a1[2] = v16 + v14;
        goto LABEL_3;
      }
      return -1;
    }
    v11 = (int *)a1[9];
    if ( v11 )
    {
      v10 = a1[1];
      v3 = (int *)a1[11];
      goto LABEL_15;
    }
    goto LABEL_16;
  }
  if ( !v5 )
  {
    if ( *((unsigned __int8 *)v3 - 1) == a2 )
    {
      a1[1] = (int)v3 - 1;
      return (unsigned __int8)a2;
    }
    if ( a1[9] )
    {
      if ( !save_for_backup(a1, a1[1]) )
      {
        v10 = a1[1];
        v2 = *a1;
        v3 = (int *)a1[11];
        v11 = (int *)a1[9];
LABEL_15:
        BYTE1(v2) |= 1u;
        a1[3] = (int)v11;
        *a1 = v2;
        v12 = a1[2];
        a1[9] = v10;
        a1[2] = (int)v3;
        a1[11] = v12;
        goto LABEL_3;
      }
      return -1;
    }
LABEL_16:
    v15 = *a1;
    v11 = malloc((const struct timespec *)0x80);
    if ( v11 )
    {
      v10 = (int)v3;
      v2 = v15;
      a1[10] = (int)(v11 + 32);
      v3 = v11 + 32;
      goto LABEL_15;
    }
    return -1;
  }
LABEL_3:
  a1[1] = (int)v3 - 1;
  *((_BYTE *)v3 - 1) = a2;
  return (unsigned __int8)a2;
}

//----- (08057CA0) --------------------------------------------------------
__int64 IO_default_seek()
{
  return -1LL;
}

//----- (08057CB0) --------------------------------------------------------
int IO_default_stat()
{
  return -1;
}

//----- (08057CC0) --------------------------------------------------------
int IO_default_read()
{
  return -1;
}

//----- (08057CD0) --------------------------------------------------------
int IO_default_write()
{
  return 0;
}

//----- (08057CE0) --------------------------------------------------------
int IO_default_showmanyc()
{
  return -1;
}

//----- (08057CF0) --------------------------------------------------------
void IO_default_imbue()
{
  ;
}

//----- (08057D00) --------------------------------------------------------
void *IO_iter_begin()
{
  return IO_list_all;
}
// 80CE040: using guessed type void *IO_list_all;

//----- (08057D20) --------------------------------------------------------
int IO_iter_end()
{
  return 0;
}

//----- (08057D30) --------------------------------------------------------
int __cdecl IO_iter_next(int a1)
{
  return *(_DWORD *)(a1 + 52);
}

//----- (08057D40) --------------------------------------------------------
int __cdecl IO_iter_file(int a1)
{
  return a1;
}

//----- (08057D50) --------------------------------------------------------
void __usercall IO_list_lock(int a1@<ebp>, int *a2@<edi>)
{
  int v3; // ebx
  bool v5; // zf

  _EDX = &GLOBAL_OFFSET_TABLE_;
  v3 = __readgsdword(8u);
  if ( dword_80CF840 != v3 )
  {
    _ECX = 1;
    v5 = __readgsdword(0xCu) == 0;
    if ( !v5 )
      __asm { lock }
    __asm { cmpxchg ds:(list_all_lock - 80CE000h)[edx], ecx }
    if ( !v5 )
      _lll_lock_wait_private(0, &list_all_lock, a1, a2);
    *(_DWORD *)((char *)_EDX + (_DWORD)(&dword_80CF840 - 33765376)) = v3;
  }
  ++*(_DWORD *)((char *)_EDX + (_DWORD)(&dword_80CF83C - 33765376));
}
// 8057D95: variable '_EDX' is possibly undefined
// 80CE000: using guessed type _TBYTE GLOBAL_OFFSET_TABLE_;
// 80CF838: using guessed type int list_all_lock;
// 80CF83C: using guessed type int dword_80CF83C;
// 80CF840: using guessed type int dword_80CF840;

//----- (08057DB0) --------------------------------------------------------
int __usercall IO_list_unlock@<eax>(int a1@<ebp>, int *a2@<edi>, const struct timespec *a3@<esi>)
{
  int result; // eax

  if ( !--dword_80CF83C )
  {
    dword_80CF840 = 0;
    if ( __readgsdword(0xCu) )
      __asm { lock }
    if ( --list_all_lock )
      return _lll_unlock_wake_private(&list_all_lock, a1, a2, a3);
  }
  return result;
}
// 80CF838: using guessed type int list_all_lock;
// 80CF83C: using guessed type int dword_80CF83C;
// 80CF840: using guessed type int dword_80CF840;

//----- (08057E00) --------------------------------------------------------
_TBYTE *IO_list_resetlock()
{
  _TBYTE *result; // eax

  result = &GLOBAL_OFFSET_TABLE_;
  list_all_lock = 0;
  dword_80CF83C = 0;
  dword_80CF840 = 0;
  return result;
}
// 80CE000: using guessed type _TBYTE GLOBAL_OFFSET_TABLE_;
// 80CF838: using guessed type int list_all_lock;
// 80CF83C: using guessed type int dword_80CF83C;
// 80CF840: using guessed type int dword_80CF840;

//----- (08057E2D) --------------------------------------------------------
void _x86_get_pc_thunk_cx()
{
  ;
}

//----- (08057E40) --------------------------------------------------------
int __cdecl IO_str_underflow(int *a1)
{
  unsigned __int8 *v1; // edx
  unsigned int v2; // ecx
  int v3; // ebx

  v1 = (unsigned __int8 *)a1[5];
  v2 = a1[2];
  if ( (unsigned int)v1 > v2 )
  {
    a1[2] = (int)v1;
    v2 = (unsigned int)v1;
  }
  v3 = *a1;
  if ( (*a1 & 0xC00) == 3072 )
  {
    BYTE1(v3) &= ~8u;
    a1[1] = (int)v1;
    *a1 = v3;
    a1[5] = a1[6];
  }
  else
  {
    v1 = (unsigned __int8 *)a1[1];
  }
  if ( (unsigned int)v1 >= v2 )
    return -1;
  else
    return *v1;
}

//----- (08057EA0) --------------------------------------------------------
int __cdecl IO_str_overflow(int *a1, int a2)
{
  int v2; // eax
  _BYTE *v3; // ebp
  unsigned int v4; // edi
  unsigned int v5; // ebp
  int *v6; // eax
  int *v7; // edx
  _BYTE *v8; // ecx
  unsigned int v9; // eax
  unsigned __int8 *v10; // edi
  int v11; // eax
  int v12; // ebp
  int v13; // eax
  int result; // eax
  int v15; // eax
  _BYTE *v16; // [esp+18h] [ebp-24h]
  int v17; // [esp+18h] [ebp-24h]
  int *v18; // [esp+1Ch] [ebp-20h]
  _BYTE *v19; // [esp+1Ch] [ebp-20h]

  v2 = *a1;
  if ( (*a1 & 8) != 0 )
    return -(a2 != -1);
  if ( (*a1 & 0xC00) == 1024 )
  {
    BYTE1(v2) |= 8u;
    v3 = (_BYTE *)a1[1];
    *a1 = v2;
    v15 = a1[2];
    a1[5] = (int)v3;
    a1[1] = v15;
  }
  else
  {
    v3 = (_BYTE *)a1[5];
  }
  v4 = a1[8] - a1[7];
  if ( v4 + (a2 == -1) <= (unsigned int)&v3[-a1[4]] )
  {
    if ( (*(_BYTE *)a1 & 1) != 0 )
      return -1;
    v5 = 2 * v4 + 100;
    v16 = (_BYTE *)a1[7];
    if ( v4 > v5 )
      return -1;
    v6 = malloc((const struct timespec *)(2 * v4 + 100));
    v7 = v6;
    if ( !v6 )
      return -1;
    v8 = v16;
    if ( v16 )
    {
      v18 = v6;
      memcpy(v6, v16, v4);
      free(v5, (int *)v4, (int)v16);
      v7 = v18;
      v8 = v16;
      a1[7] = 0;
    }
    v19 = v8;
    v17 = (int)v7;
    v9 = v5 - v4;
    v10 = (unsigned __int8 *)v7 + v4;
    memset(v10, 0, v9);
    IO_setb(v17 + v5, (int *)v10, a1, v17, v17 + v5, 1);
    v11 = v17 + a1[3] - (_DWORD)v19;
    v12 = a1[5] - (_DWORD)v19;
    a1[4] = v17;
    a1[3] = v11;
    v13 = a1[1];
    v3 = (_BYTE *)(v17 + v12);
    a1[5] = (int)v3;
    a1[1] = v17 + v13 - (_DWORD)v19;
    a1[2] = v17 + a1[2] - (_DWORD)v19;
    a1[6] = a1[8];
  }
  if ( a2 != -1 )
  {
    a1[5] = (int)(v3 + 1);
    *v3 = a2;
    v3 = (_BYTE *)a1[5];
  }
  result = a2;
  if ( a1[2] < (unsigned int)v3 )
    a1[2] = (int)v3;
  return result;
}

//----- (08058040) --------------------------------------------------------
int __usercall enlarge_userbuf@<eax>(int *a1@<eax>, int a2@<edx>, unsigned int a3@<ecx>, int a4)
{
  int v4; // ebp
  int *v7; // eax
  int v8; // ecx
  _BYTE *v9; // edx
  int v10; // ebp
  int v11; // eax
  int v12; // eax
  int v13; // [esp+10h] [ebp-3Ch]
  int v15; // [esp+1Ch] [ebp-30h]
  int v16; // [esp+1Ch] [ebp-30h]
  int v17; // [esp+20h] [ebp-2Ch]
  _BYTE *v19; // [esp+28h] [ebp-24h]
  _BYTE *v20; // [esp+28h] [ebp-24h]
  int *v21; // [esp+2Ch] [ebp-20h]

  v4 = a1[8] - a1[7];
  if ( v4 < a2 )
  {
    if ( (*a1 & 1) != 0 )
      return 1;
    v19 = (_BYTE *)a1[7];
    v13 = a1[6];
    v15 = a1[4];
    v17 = a2 + 100;
    v7 = malloc((const struct timespec *)(a2 + 100));
    v8 = (int)v7;
    if ( !v7 )
      return 1;
    v9 = v19;
    if ( v19 )
    {
      v21 = v7;
      memcpy(v7, v19, v4);
      free(v4, 0, (int)v19);
      v8 = (int)v21;
      v9 = v19;
      a1[7] = 0;
    }
    v20 = v9;
    v10 = v13 - v15;
    v16 = v8;
    IO_setb(v10, 0, a1, v8, v8 + v17, 1);
    if ( a4 )
    {
      v11 = a1[4];
      a1[3] = v16;
      a1[4] = v16 + v11 - (_DWORD)v20;
      a1[5] = v16 + a1[5] - (_DWORD)v20;
      a1[6] = v16 + a1[6] - (_DWORD)v20;
      a1[1] = v16 + a1[1] - (_DWORD)v20;
      a1[2] = a1[8];
      if ( __SPAIR64__(a3, a2) >= v10 )
      {
LABEL_9:
        memset((unsigned __int8 *)(v10 + v16), 0, a2 - v10);
        return 0;
      }
    }
    else
    {
      v12 = a1[3];
      a1[4] = v16;
      a1[3] = v16 + v12 - (_DWORD)v20;
      a1[1] = v16 + a1[1] - (_DWORD)v20;
      a1[2] = v16 + a1[2] - (_DWORD)v20;
      a1[5] = v16 + a1[5] - (_DWORD)v20;
      a1[6] = a1[8];
      if ( __SPAIR64__(a3, a2) >= v10 )
        goto LABEL_9;
    }
    _assert_fail((int)"offset >= oldend", (int)"strops.c", 222, (int)"enlarge_userbuf");
  }
  return 0;
}

//----- (08058240) --------------------------------------------------------
int __cdecl IO_str_seekoff(int *a1, __int64 a2, int a3, int a4)
{
  int v4; // ecx
  unsigned int v5; // edx
  unsigned int v6; // eax
  int v7; // eax
  int v8; // edx
  int v9; // esi
  int v10; // edi
  int v11; // ecx
  int v12; // esi
  int result; // eax
  int v14; // eax
  __int64 v15; // rax
  int v16; // ecx
  int v17; // ebp
  int v18; // [esp+4h] [ebp-2Ch]
  int v19; // [esp+Ch] [ebp-24h]
  int v20; // [esp+10h] [ebp-20h]
  int v21; // [esp+10h] [ebp-20h]

  v4 = *a1;
  v5 = a1[5];
  v6 = a1[4];
  if ( a4 )
  {
    if ( v6 >= v5 && (v4 & 0x800) == 0 )
    {
      v7 = a1[3];
      goto LABEL_27;
    }
LABEL_16:
    if ( (v4 & 0x100) == 0 )
    {
LABEL_17:
      v7 = a1[7];
      goto LABEL_18;
    }
LABEL_21:
    v7 = a1[10];
LABEL_18:
    BYTE1(v4) &= ~8u;
    a1[3] = v7;
    *a1 = v4;
    a1[2] = v5;
    a1[1] = v5;
    if ( !a4 )
      return a1[1] - v7;
LABEL_27:
    if ( a1[2] >= v5 )
      v5 = a1[2];
    v12 = -1;
    v19 = v5;
    v18 = v5 - v7;
    if ( (a4 & 1) == 0 )
      goto LABEL_30;
    goto LABEL_8;
  }
  a4 = *a1 & 0x400;
  if ( (v4 & 0x400) == 0 )
  {
    if ( v6 >= v5 && (v4 & 0x800) == 0 )
    {
      v7 = a1[3];
      return a1[1] - v7;
    }
    goto LABEL_16;
  }
  if ( (v4 & 0x800) != 0 )
  {
    a4 = 2;
    if ( (v4 & 0x100) == 0 )
      goto LABEL_17;
    goto LABEL_21;
  }
  if ( v6 < v5 )
  {
    a4 = 1;
    goto LABEL_16;
  }
  if ( a1[2] >= v5 )
    v5 = a1[2];
  LOBYTE(a4) = 1;
  v7 = a1[3];
  v19 = v5;
  v18 = v5 - v7;
LABEL_8:
  if ( a3 )
  {
    if ( a3 == 1 )
    {
      v8 = a1[1];
      v9 = v7 - v8;
      v20 = v8 - v7;
      v10 = (v7 - v8) >> 31;
      v11 = 0x7FFFFFFF - (v8 - v7);
    }
    else
    {
      v11 = 0x7FFFFFFF - v18;
      v20 = v18;
      v9 = -v18;
      v10 = -v18 >> 31;
    }
  }
  else
  {
    v20 = 0;
    v11 = 0x7FFFFFFF;
    v9 = 0;
    v10 = 0;
  }
  if ( a2 < __SPAIR64__(v10, v9) || v11 < a2 )
    goto LABEL_49;
  v21 = a2 + v20;
  v12 = v21;
  if ( v21 > v18 )
  {
    if ( enlarge_userbuf(a1, v21, v21 >> 31, 1) )
      return -1;
    v7 = a1[3];
    v19 = v7 + v18;
  }
  a1[1] = v21 + v7;
  a1[2] = v19;
LABEL_30:
  if ( (a4 & 2) == 0 )
    return v12;
  if ( a3 )
  {
    if ( a3 == 1 )
    {
      v14 = a1[4];
      a3 = a1[5] - v14;
      v15 = v14 - a1[5];
      v16 = 0x7FFFFFFF - a3;
    }
    else
    {
      v16 = 0x7FFFFFFF - v18;
      a3 = v18;
      v15 = -v18;
    }
  }
  else
  {
    v16 = 0x7FFFFFFF;
    v15 = 0LL;
  }
  if ( a2 < v15 || v16 < a2 )
  {
LABEL_49:
    v12 = -1;
    __writegsdword(0xFFFFFFE0, 0x16u);
    return v12;
  }
  v17 = a3 + a2;
  if ( a3 + (int)a2 > v18 && enlarge_userbuf(a1, v17, v17 >> 31, 0) )
    return -1;
  result = a3 + a2;
  a1[5] = a1[4] + v17;
  return result;
}

//----- (08058570) --------------------------------------------------------
int __cdecl IO_str_pbackfail(int *a1, int a2)
{
  if ( (*(_BYTE *)a1 & 8) != 0 && a2 != -1 )
    return -1;
  else
    return IO_default_pbackfail(a1, a2);
}

//----- (080585A0) --------------------------------------------------------
int *__usercall IO_str_finish@<eax>(int a1@<ebp>, int *a2@<edi>, struct timespec *a3)
{
  if ( a3[3].tv_nsec && (a3->tv_sec & 1) == 0 )
    free(a1, a2, a3[3].tv_nsec);
  a3[3].tv_nsec = 0;
  return IO_default_finish(a1, a2, a3);
}

//----- (08058600) --------------------------------------------------------
int __cdecl IO_str_init_static_internal(int *a1, _BYTE *a2, int a3, int a4)
{
  int v4; // edi
  int result; // eax

  if ( a3 )
  {
    v4 = (int)&a2[a3];
    if ( a2 >= &a2[a3] )
      v4 = -1;
  }
  else
  {
    v4 = (int)rawmemchr(a2, 0);
  }
  result = IO_setb(a4, (int *)v4, a1, (int)a2, v4, 0);
  a1[4] = (int)a2;
  a1[3] = (int)a2;
  a1[1] = (int)a2;
  if ( a4 )
  {
    a1[5] = a4;
    a1[6] = v4;
    a1[2] = a4;
  }
  else
  {
    a1[5] = (int)a2;
    a1[6] = (int)a2;
    a1[2] = v4;
  }
  a1[38] = 0;
  return result;
}

//----- (08058690) --------------------------------------------------------
int __cdecl IO_str_init_static(int *a1, _BYTE *a2, int a3, int a4)
{
  int v4; // eax

  v4 = a3;
  if ( a3 < 0 )
    v4 = -1;
  return IO_str_init_static_internal(a1, a2, v4, a4);
}

//----- (080586B0) --------------------------------------------------------
int __cdecl IO_str_init_readonly(int *a1, _BYTE *a2, int a3)
{
  int v3; // eax
  int result; // eax

  v3 = a3;
  if ( a3 < 0 )
    v3 = -1;
  result = IO_str_init_static_internal(a1, a2, v3, 0);
  *a1 |= 8u;
  return result;
}

//----- (080586E0) --------------------------------------------------------
unsigned int __cdecl IO_str_count(_DWORD *a1)
{
  unsigned int v1; // eax

  v1 = a1[5];
  if ( a1[2] >= v1 )
    v1 = a1[2];
  return v1 - a1[3];
}

//----- (08058700) --------------------------------------------------------
_BOOL4 __cdecl _libc_alloca_cutoff(unsigned int a1)
{
  unsigned int v1; // edx
  unsigned int v2; // eax

  v1 = 0x10000;
  if ( (__readgsdword(0x274u) >> 2) - 1 <= 0xFFFF )
  {
    v2 = __readgsdword(0x274u);
    v1 = v2 >> 2;
    if ( v2 <= 3 )
      v1 = 0x40000;
  }
  return v1 >= a1;
}

//----- (08058740) --------------------------------------------------------
__int32 __usercall _lll_lock_wait_private@<eax>(int a1@<eax>, int *a2@<ecx>, int a3@<ebp>, int *a4@<edi>)
{
  int v4; // edx
  int v6; // ecx
  int v7; // eax
  __int32 result; // eax

  v4 = 2;
  v6 = 128;
  if ( a1 != 2 )
    goto LABEL_3;
  do
  {
    v7 = sys_futex(a2, v6, v4, 0, a4, a3);
LABEL_3:
    result = _InterlockedExchange(a2, v4);
  }
  while ( result );
  return result;
}
// 805875B: variable 'v6' is possibly undefined
// 805875B: variable 'v4' is possibly undefined

//----- (08058770) --------------------------------------------------------
int __usercall _lll_unlock_wake_private@<eax>(
        int *a1@<eax>,
        int a2@<ebp>,
        int *a3@<edi>,
        const struct timespec *a4@<esi>)
{
  *a1 = 0;
  return sys_futex(a1, 129, 1, a4, a3, a2);
}

//----- (080587A0) --------------------------------------------------------
_TBYTE *__cdecl dl_tunable_set_arena_max(int *a1)
{
  _TBYTE *result; // eax

  result = &GLOBAL_OFFSET_TABLE_;
  dword_80CE4B0 = *a1;
  return result;
}
// 80CE000: using guessed type _TBYTE GLOBAL_OFFSET_TABLE_;
// 80CE4B0: using guessed type int dword_80CE4B0;

//----- (080587C0) --------------------------------------------------------
_TBYTE *__cdecl dl_tunable_set_arena_test(int *a1)
{
  _TBYTE *result; // eax

  result = &GLOBAL_OFFSET_TABLE_;
  dword_80CE4AC = *a1;
  return result;
}
// 80CE000: using guessed type _TBYTE GLOBAL_OFFSET_TABLE_;
// 80CE4AC: using guessed type int dword_80CE4AC;

//----- (080587E0) --------------------------------------------------------
unsigned int __cdecl dl_tunable_set_tcache_max(unsigned int *a1)
{
  unsigned int result; // eax

  result = *a1;
  if ( *a1 <= 0x3FC )
  {
    dword_80CE4D4 = *a1;
    result = ((((result + 19) & 0xFFFFFFF0) - 1) >> 4) + 1;
    dword_80CE4D0 = result;
  }
  return result;
}
// 80CE4D0: using guessed type int dword_80CE4D0;
// 80CE4D4: using guessed type int dword_80CE4D4;

//----- (08058820) --------------------------------------------------------
int __cdecl dl_tunable_set_tcache_count(int *a1)
{
  int result; // eax

  result = *a1;
  if ( (unsigned int)*a1 <= 0x7F )
    dword_80CE4D8 = *a1;
  return result;
}
// 80CE4D8: using guessed type int dword_80CE4D8;

//----- (08058850) --------------------------------------------------------
_TBYTE *__cdecl dl_tunable_set_tcache_unsorted_limit(int *a1)
{
  _TBYTE *result; // eax

  result = &GLOBAL_OFFSET_TABLE_;
  dword_80CE4DC = *a1;
  return result;
}
// 80CE000: using guessed type _TBYTE GLOBAL_OFFSET_TABLE_;
// 80CE4DC: using guessed type int dword_80CE4DC;

//----- (08058870) --------------------------------------------------------
int __usercall mem2mem_check@<eax>(int result@<eax>, unsigned int a2@<edx>)
{
  unsigned int v2; // ebx
  int v3; // esi
  unsigned int v4; // ecx
  unsigned int v5; // ebx
  unsigned int i; // ebx
  int v7; // ecx
  char v8; // [esp+1h] [ebp-11h]

  if ( result )
  {
    v2 = ((unsigned int)(result - 8) >> 11) ^ ((unsigned int)(result - 8) >> 3);
    if ( (_BYTE)v2 == 1 )
      LOBYTE(v2) = 2;
    v8 = v2;
    v3 = (unsigned __int8)v2;
    v4 = *(_DWORD *)(result - 4) & 0xFFFFFFF8;
    v5 = v4 - 4;
    if ( (*(_DWORD *)(result - 4) & 2) != 0 )
      v5 = v4 - 8;
    for ( i = v5 - 1; a2 < i; i -= v7 )
    {
      v7 = i - a2;
      if ( i - a2 > 0xFF )
        v7 = 255;
      if ( v7 == v3 )
        v7 = v3 - 1;
      *(_BYTE *)(result + i) = v7;
    }
    *(_BYTE *)(result + a2) = v8;
  }
  return result;
}

//----- (08058900) --------------------------------------------------------
unsigned int __usercall mem2chunk_check@<eax>(int a1@<eax>, _DWORD *a2@<edx>)
{
  int v2; // ebx
  unsigned int v3; // edx
  unsigned int v4; // ecx
  int v5; // edi
  unsigned int v6; // eax
  _BYTE *v7; // edi
  int v8; // esi
  int v10; // eax
  unsigned int v11; // ebx
  unsigned int v12; // ebx
  int v13; // esi
  unsigned int v14; // [esp+0h] [ebp-1Ch]

  if ( (a1 & 0xF) != 0 )
    return 0;
  v2 = *(_DWORD *)(a1 - 4);
  v3 = a1 - 8;
  v14 = v2 & 0xFFFFFFF8;
  v4 = ((unsigned int)(a1 - 8) >> 3) ^ ((unsigned int)(a1 - 8) >> 11);
  if ( (_BYTE)v4 == 1 )
    LOBYTE(v4) = 2;
  if ( (v2 & 2) != 0 )
  {
    v5 = (dl_pagesize - 1) & a1;
    if ( ((v5 - 16) & 0xFFFFFFEF) != 0
      && (unsigned int)(v5 - 1) <= 0x1FFE
      && ((v5 - 64) & 0xFFFFFFBF) != 0
      && ((v5 - 256) & 0xFFFFFEFF) != 0
      && ((v5 - 1024) & 0xFFFFFBFF) != 0
      && v5 != 4096
      || (v2 & 3) != 2
      || ((dl_pagesize - 1) & ((v3 - *(_DWORD *)(a1 - 8)) | (v14 + *(_DWORD *)(a1 - 8)))) != 0 )
    {
      return 0;
    }
    v6 = v14 - 1;
    v7 = (_BYTE *)(v3 + v14 - 1);
    v8 = (unsigned __int8)*v7;
    if ( (_BYTE)v4 != *v7 )
    {
      if ( !*v7 || v6 < v8 + 8 )
        return 0;
      while ( 1 )
      {
        v6 -= v8;
        v7 = (_BYTE *)(v3 + v6);
        v8 = *(unsigned __int8 *)(v3 + v6);
        if ( *(_BYTE *)(v3 + v6) == (_BYTE)v4 )
          break;
        if ( !*(_BYTE *)(v3 + v6) || v8 + 8 > v6 )
          return 0;
      }
    }
  }
  else
  {
    if ( (dword_80CE504 & 2) == 0
      && (dword_80CE4CC > v3 || v3 + (*(_DWORD *)(a1 - 4) & 0xFFFFFFF8) >= dword_80CE954 + dword_80CE4CC) )
    {
      return 0;
    }
    if ( v14 <= 0xF || (v2 & 8) != 0 || (*(_BYTE *)(v3 + v14 + 4) & 1) == 0 )
      return 0;
    if ( (v2 & 1) == 0 )
    {
      v10 = *(_DWORD *)(a1 - 8);
      if ( (v10 & 0xF) != 0 )
        return 0;
      v11 = v3 - v10;
      if ( (dword_80CE504 & 2) == 0 && dword_80CE4CC > v11 )
        return 0;
      if ( v10 != (*(_DWORD *)(v11 + 4) & 0xFFFFFFF8) )
        return 0;
    }
    v12 = v14 + 3;
    v7 = (_BYTE *)(v3 + v14 + 3);
    v13 = (unsigned __int8)*v7;
    if ( (_BYTE)v4 != *v7 )
    {
      if ( !*v7 || v12 < v13 + 8 )
        return 0;
      while ( 1 )
      {
        v12 -= v13;
        v7 = (_BYTE *)(v3 + v12);
        v13 = *(unsigned __int8 *)(v3 + v12);
        if ( *(_BYTE *)(v3 + v12) == (_BYTE)v4 )
          break;
        if ( !*(_BYTE *)(v3 + v12) || v13 + 8 > v12 )
          return 0;
      }
    }
  }
  *v7 = ~(_BYTE)v4;
  if ( a2 )
    *a2 = v7;
  return v3;
}
// 80CE4CC: using guessed type int dword_80CE4CC;
// 80CE504: using guessed type int dword_80CE504;
// 80CE954: using guessed type int dword_80CE954;
// 80CE9B0: using guessed type int dl_pagesize;

//----- (08058B00) --------------------------------------------------------
_TBYTE *__usercall int_mallinfo@<eax>(int a1@<eax>, _DWORD *a2@<edx>)
{
  int v2; // ebp
  int *v3; // ecx
  int *v4; // esi
  int v5; // edi
  int i; // eax
  int v7; // edx
  int v8; // ecx
  int v9; // ebx
  int *j; // eax
  int v11; // edx
  int v12; // eax
  _TBYTE *result; // eax
  int v14; // eax
  int v17; // [esp+Ch] [ebp-18h]

  v2 = 0;
  v3 = (int *)(a1 + 12);
  v4 = (int *)(a1 + 56);
  v5 = 0;
  v17 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 4);
  do
  {
    for ( i = *v3; i; v5 += v7 & 0xFFFFFFF8 )
    {
      v7 = *(_DWORD *)(i + 4);
      i = *(_DWORD *)(i + 8);
      ++v2;
    }
    ++v3;
  }
  while ( v4 != v3 );
  v8 = (v17 & 0xFFFFFFF8) + v5;
  v9 = 1;
  do
  {
    for ( j = (int *)v4[3]; j != v4; v8 += v11 & 0xFFFFFFF8 )
    {
      v11 = j[1];
      j = (int *)j[3];
      ++v9;
    }
    v4 += 2;
  }
  while ( (int *)(a1 + 1072) != v4 );
  a2[1] += v9;
  a2[2] += v2;
  a2[8] += v8;
  v12 = *(_DWORD *)(a1 + 1108);
  *a2 += v12;
  a2[6] += v5;
  a2[7] += v12 - v8;
  result = &GLOBAL_OFFSET_TABLE_ + 128;
  if ( (_TBYTE *)a1 == &GLOBAL_OFFSET_TABLE_ + 128 )
  {
    a2[3] = *((_DWORD *)&GLOBAL_OFFSET_TABLE_ + 301);
    v14 = *((_DWORD *)&GLOBAL_OFFSET_TABLE_ + 305);
    a2[5] = 0;
    a2[4] = v14;
    result = (_TBYTE *)(v17 & 0xFFFFFFF8);
    a2[9] = v17 & 0xFFFFFFF8;
  }
  return result;
}
// 80CE000: using guessed type _TBYTE GLOBAL_OFFSET_TABLE_;

//----- (08058C20) --------------------------------------------------------
_TBYTE *__cdecl dl_tunable_set_trim_threshold(int *a1)
{
  _TBYTE *result; // eax

  result = &GLOBAL_OFFSET_TABLE_;
  mp_ = *a1;
  dword_80CE4C0 = 1;
  return result;
}
// 80CE000: using guessed type _TBYTE GLOBAL_OFFSET_TABLE_;
// 80CE4A0: using guessed type int mp_;
// 80CE4C0: using guessed type int dword_80CE4C0;

//----- (08058C50) --------------------------------------------------------
_TBYTE *__cdecl dl_tunable_set_top_pad(int *a1)
{
  _TBYTE *result; // eax

  result = &GLOBAL_OFFSET_TABLE_;
  dword_80CE4A4 = *a1;
  dword_80CE4C0 = 1;
  return result;
}
// 80CE000: using guessed type _TBYTE GLOBAL_OFFSET_TABLE_;
// 80CE4A4: using guessed type int dword_80CE4A4;
// 80CE4C0: using guessed type int dword_80CE4C0;

//----- (08058C80) --------------------------------------------------------
int __cdecl dl_tunable_set_mmap_threshold(int *a1)
{
  int result; // eax

  result = *a1;
  if ( (unsigned int)*a1 <= 0x80000 )
  {
    dword_80CE4A8 = *a1;
    dword_80CE4C0 = 1;
  }
  return result;
}
// 80CE4A8: using guessed type int dword_80CE4A8;
// 80CE4C0: using guessed type int dword_80CE4C0;

//----- (08058CC0) --------------------------------------------------------
_TBYTE *__cdecl dl_tunable_set_mmaps_max(int *a1)
{
  _TBYTE *result; // eax

  result = &GLOBAL_OFFSET_TABLE_;
  dword_80CE4B8 = *a1;
  dword_80CE4C0 = 1;
  return result;
}
// 80CE000: using guessed type _TBYTE GLOBAL_OFFSET_TABLE_;
// 80CE4B8: using guessed type int dword_80CE4B8;
// 80CE4C0: using guessed type int dword_80CE4C0;

//----- (08058CF0) --------------------------------------------------------
_TBYTE *__cdecl dl_tunable_set_perturb_byte(int *a1)
{
  _TBYTE *result; // eax

  result = &GLOBAL_OFFSET_TABLE_;
  perturb_byte = *a1;
  return result;
}
// 80CE000: using guessed type _TBYTE GLOBAL_OFFSET_TABLE_;
// 80CF88C: using guessed type int perturb_byte;

//----- (08058D10) --------------------------------------------------------
void __usercall __noreturn _malloc_assert(int a1@<eax>, int a2@<edx>, int a3@<ecx>, int a4)
{
  const struct timespec *v4; // esi
  unsigned __int8 *v5; // ebp

  v4 = (const struct timespec *)program_invocation_short_name[0];
  if ( *(_BYTE *)program_invocation_short_name[0] )
    v5 = ": ";
  else
    v5 = byte_80B41F9;
  _fxprintf(
    (int)v5,
    (int *)": ",
    0,
    (unsigned int *)"%s%s%s:%u: %s%sAssertion `%s' failed.\n",
    program_invocation_short_name[0],
    v5,
    a2,
    a3,
    a4,
    ": ",
    a1);
  fflush((const struct timespec *)stderr);
  abort((int)v5, (int *)": ", v4);
}
// 80B41F9: using guessed type unsigned __int8 byte_80B41F9[1671];
// 80CE474: using guessed type void *stderr;
// 80CE964: using guessed type char (*program_invocation_short_name[2])[1671];

//----- (08058D80) --------------------------------------------------------
int __usercall detach_arena@<eax>(int result@<eax>)
{
  int v1; // edx

  if ( result )
  {
    v1 = *(_DWORD *)(result + 1104);
    if ( !v1 )
      _malloc_assert((int)"replaced_arena->attached_threads > 0", (int)"arena.c", 675, (int)"detach_arena");
    *(_DWORD *)(result + 1104) = v1 - 1;
  }
  return result;
}

//----- (08058DD0) --------------------------------------------------------
int *__usercall get_free_list@<eax>(int a1@<ebp>)
{
  int v4; // edx
  bool v5; // zf
  bool v7; // zf

  _ESI = &GLOBAL_OFFSET_TABLE_;
  _EBX = (int *)free_list;
  if ( free_list )
  {
    _ECX = 1;
    v4 = __readgsdword(0xFFFFFFEC);
    v5 = __readgsdword(0xCu) == 0;
    if ( !v5 )
      __asm { lock }
    __asm { cmpxchg ds:(free_list_lock - 80CE000h)[esi], ecx }
    if ( !v5 )
      _lll_lock_wait_private(0, &free_list_lock, a1, (int *)0xFFFFFFEC);
    _EBX = (int *)free_list;
    if ( free_list )
    {
      free_list = *(_DWORD *)(free_list + 1100);
      if ( _EBX[276] )
        _malloc_assert((int)"result->attached_threads == 0", (int)"arena.c", 769, (int)"get_free_list");
      _EBX[276] = 1;
      detach_arena(v4);
    }
    if ( __readgsdword(0xCu) )
      __asm { lock }
    if ( --free_list_lock )
      _lll_unlock_wake_private(&free_list_lock, a1, (int *)0xFFFFFFEC, (const struct timespec *)&GLOBAL_OFFSET_TABLE_);
    if ( _EBX )
    {
      _ECX = 1;
      v7 = __readgsdword(0xCu) == 0;
      if ( !v7 )
        __asm { lock }
      __asm { cmpxchg [ebx], ecx }
      if ( !v7 )
        _lll_lock_wait_private(0, _EBX, a1, (int *)0xFFFFFFEC);
      __writegsdword(0xFFFFFFEC, (unsigned int)_EBX);
    }
  }
  return _EBX;
}
// 8058E47: variable 'v4' is possibly undefined
// 80CE000: using guessed type _TBYTE GLOBAL_OFFSET_TABLE_;
// 80CF884: using guessed type int free_list;
// 80CF888: using guessed type int free_list_lock;

//----- (08058EC0) --------------------------------------------------------
char *__usercall malloc_printerr@<eax>(char a1@<al>)
{
  _libc_message(1, "%s\n", a1);
  return top_check();
}

//----- (08058EE0) --------------------------------------------------------
char *top_check()
{
  char *result; // eax
  int v1; // ecx
  char *v2; // eax

  result = (char *)&GLOBAL_OFFSET_TABLE_;
  if ( (int *)dword_80CE538 != &dword_80CE538 )
  {
    v1 = *(_DWORD *)(dword_80CE538 + 4);
    if ( (v1 & 2) != 0
      || (v1 & 0xFFFFFFF8) <= 0xF
      || (v1 & 1) == 0
      || (dword_80CE504 & 2) == 0 && (v1 & 0xFFFFFFF8) + dword_80CE538 != dword_80CE4CC + dword_80CE954 )
    {
      v2 = malloc_printerr((unsigned __int8)&aMallocTopChunk[-135061504] + (unsigned __int8)&GLOBAL_OFFSET_TABLE_);
      return malloc_consolidate((int)v2);
    }
  }
  return result;
}
// 80CE000: using guessed type _TBYTE GLOBAL_OFFSET_TABLE_;
// 80CE4CC: using guessed type int dword_80CE4CC;
// 80CE504: using guessed type int dword_80CE504;
// 80CE538: using guessed type int dword_80CE538;
// 80CE954: using guessed type int dword_80CE954;

//----- (08058F50) --------------------------------------------------------
char *__usercall malloc_consolidate@<eax>(int a1@<eax>)
{
  volatile __int32 *v2; // eax
  int v3; // ebp
  __int32 v4; // ebx
  char *result; // eax
  _DWORD *v6; // esi
  _DWORD *v7; // edi
  int v8; // edx
  unsigned int v9; // esi
  unsigned int v10; // eax
  _DWORD *v11; // edx
  unsigned int v12; // ecx
  _DWORD *v13; // ecx
  int v14; // esi
  char *v15; // eax
  int v16; // edx
  volatile __int32 *v17; // [esp+0h] [ebp-38h]
  __int32 v18; // [esp+4h] [ebp-34h]
  unsigned int v19; // [esp+8h] [ebp-30h]
  volatile __int32 *v20; // [esp+Ch] [ebp-2Ch]
  unsigned int v21; // [esp+10h] [ebp-28h]
  _DWORD *v22; // [esp+18h] [ebp-20h]

  v2 = (volatile __int32 *)(a1 + 56);
  v3 = a1;
  *((_DWORD *)v2 - 12) = 0;
  v20 = v2;
  v17 = (volatile __int32 *)(a1 + 12);
  while ( 1 )
  {
    v4 = _InterlockedExchange(v17, 0);
    if ( v4 )
      break;
LABEL_3:
    result = (char *)++v17;
    if ( v20 == v17 )
      return result;
  }
  while ( 1 )
  {
    v9 = *(_DWORD *)(v4 + 4);
    if ( v17 != (volatile __int32 *)(v3 + 4 * (v9 >> 3) + 4) )
      break;
    v18 = *(_DWORD *)(v4 + 8);
    v10 = v9 & 0xFFFFFFF8;
    v11 = (_DWORD *)(v4 + (v9 & 0xFFFFFFF8));
    v19 = v11[1];
    v7 = (_DWORD *)v19;
    v12 = v19 & 0xFFFFFFF8;
    if ( (v9 & 1) == 0 )
    {
      v6 = *(_DWORD **)v4;
      v4 -= *(_DWORD *)v4;
      v10 += (unsigned int)v6;
      v21 = *(_DWORD *)(v4 + 4);
      v7 = (_DWORD *)(v21 & 0xFFFFFFF8);
      if ( (_DWORD *)(v21 & 0xFFFFFFF8) != v6 )
        goto LABEL_33;
      if ( v7 != *(_DWORD **)((char *)v7 + v4) )
        goto LABEL_32;
      v6 = *(_DWORD **)(v4 + 8);
      v7 = *(_DWORD **)(v4 + 12);
      if ( v6[3] != v4 || v7[2] != v4 )
        goto LABEL_31;
      v6[3] = v7;
      v7[2] = v6;
      if ( v21 > 0x3EF )
      {
        v7 = *(_DWORD **)(v4 + 16);
        v21 = (unsigned int)v7;
        if ( v7 )
        {
LABEL_34:
          if ( v7[5] != v4 )
            goto LABEL_38;
          v7 = *(_DWORD **)(v4 + 20);
          v22 = v7;
          if ( v7[4] != v4 )
            goto LABEL_38;
          v7 = (_DWORD *)v6[4];
          if ( v7 )
          {
            v7 = (_DWORD *)v21;
            *(_DWORD *)(v21 + 20) = v22;
            *(_DWORD *)(*(_DWORD *)(v4 + 20) + 16) = v21;
          }
          else
          {
LABEL_39:
            if ( v21 == v4 )
            {
              v6[5] = v6;
              v6[4] = v6;
            }
            else
            {
              v6[4] = v21;
              v6[5] = v22;
              *(_DWORD *)(*(_DWORD *)(v4 + 16) + 20) = v6;
              v7 = *(_DWORD **)(v4 + 20);
              v7[4] = v6;
            }
          }
        }
      }
    }
    if ( *(_DWORD **)(v3 + 56) != v11 )
    {
      v6 = (_DWORD *)((char *)v11 + v12);
      if ( (*((_BYTE *)v11 + v12 + 4) & 1) != 0 )
      {
        v11[1] = v19 & 0xFFFFFFFE;
        goto LABEL_10;
      }
      v10 += v12;
      if ( *v6 == v12 )
      {
        v13 = (_DWORD *)v11[2];
        v6 = (_DWORD *)v11[3];
        if ( (_DWORD *)v13[3] == v11 && (_DWORD *)v6[2] == v11 )
        {
          v13[3] = v6;
          v6[2] = v13;
          if ( v19 <= 0x3EF )
            goto LABEL_10;
          v6 = (_DWORD *)v11[4];
          if ( !v6 )
            goto LABEL_10;
          if ( (_DWORD *)v6[5] == v11 )
          {
            v7 = (_DWORD *)v11[5];
            if ( (_DWORD *)v7[4] == v11 )
            {
              if ( v13[4] )
              {
                v6[5] = v7;
                *(_DWORD *)(v11[5] + 16) = v6;
              }
              else if ( v6 == v11 )
              {
                v13[5] = v13;
                v13[4] = v13;
              }
              else
              {
                v13[4] = v6;
                v14 = v11[4];
                v13[5] = v7;
                *(_DWORD *)(v14 + 20) = v13;
                *(_DWORD *)(v11[5] + 16) = v13;
              }
LABEL_10:
              v8 = *(_DWORD *)(v3 + 64);
              *(_DWORD *)(v3 + 64) = v4;
              *(_DWORD *)(v8 + 12) = v4;
              if ( v10 > 0x3EF )
              {
                *(_DWORD *)(v4 + 16) = 0;
                *(_DWORD *)(v4 + 20) = 0;
              }
              *(_DWORD *)(v4 + 8) = v8;
              *(_DWORD *)(v4 + 4) = v10 | 1;
              *(_DWORD *)(v4 + 12) = v20;
              *(_DWORD *)(v4 + v10) = v10;
              goto LABEL_13;
            }
          }
LABEL_38:
          v10 = (unsigned int)malloc_printerr((unsigned __int8)&GLOBAL_OFFSET_TABLE_ + 0x80);
          goto LABEL_39;
        }
LABEL_31:
        malloc_printerr((unsigned __int8)&GLOBAL_OFFSET_TABLE_ + 8);
      }
LABEL_32:
      malloc_printerr((unsigned __int8)&GLOBAL_OFFSET_TABLE_ - 21);
LABEL_33:
      v10 = (unsigned int)malloc_printerr((unsigned __int8)&GLOBAL_OFFSET_TABLE_ + 84);
      goto LABEL_34;
    }
    *(_DWORD *)(v4 + 4) = (v12 + v10) | 1;
    *(_DWORD *)(v3 + 56) = v4;
LABEL_13:
    v4 = v18;
    if ( !v18 )
      goto LABEL_3;
  }
  v15 = malloc_printerr((unsigned __int8)&GLOBAL_OFFSET_TABLE_ + 40);
  return new_heap((unsigned int)v15, v16);
}
// 8058FB0: variable 'v11' is possibly undefined
// 80590B5: variable 'v12' is possibly undefined
// 805915C: variable 'v21' is possibly undefined
// 805918E: variable 'v22' is possibly undefined
// 80591EA: variable 'v16' is possibly undefined
// 80CE000: using guessed type _TBYTE GLOBAL_OFFSET_TABLE_;

//----- (080591F0) --------------------------------------------------------
char *__usercall new_heap@<eax>(unsigned int a1@<eax>, int a2@<edx>)
{
  unsigned int v2; // edx
  int v3; // esi
  unsigned int v4; // eax
  char *v5; // ebx
  _BYTE *v6; // eax
  int v7; // edx
  unsigned int v9; // eax
  int v10; // [esp+0h] [ebp-20h]

  v2 = a1 + a2;
  if ( v2 <= 0x7FFF )
  {
    v2 = 0x8000;
  }
  else if ( v2 > 0x100000 )
  {
    v2 = 0x100000;
    if ( a1 > 0x100000 )
      return 0;
  }
  v3 = (v2 + dl_pagesize - 1) & -dl_pagesize;
  if ( aligned_heap_area )
  {
    v4 = mmap((void *)aligned_heap_area, 0x100000u, 0, 16418, -1, 0);
    aligned_heap_area = 0;
    v5 = (char *)v4;
    if ( v4 != -1 )
    {
      if ( (v4 & 0xFFFFF) == 0 )
        goto LABEL_11;
      munmap((void *)v4, 0x100000);
    }
  }
  v6 = (_BYTE *)mmap(0, 0x200000u, 0, 16418, -1, 0);
  if ( v6 != (_BYTE *)-1 )
  {
    v5 = (char *)((unsigned int)(v6 + 0xFFFFF) & 0xFFF00000);
    v7 = v5 - v6;
    if ( v5 == v6 )
    {
      aligned_heap_area = (int)(v5 + 0x100000);
    }
    else
    {
      v10 = v5 - v6;
      munmap(v6, v5 - v6);
      v7 = v10;
    }
    munmap(v5 + 0x100000, 0x100000 - v7);
    goto LABEL_11;
  }
  v9 = mmap(0, 0x100000u, 0, 16418, -1, 0);
  v5 = (char *)v9;
  if ( v9 != -1 )
  {
    if ( (v9 & 0xFFFFF) != 0 )
    {
LABEL_18:
      munmap(v5, 0x100000);
      return 0;
    }
LABEL_11:
    if ( !mprotect(v5, v3, 3) )
    {
      *((_DWORD *)v5 + 2) = v3;
      *((_DWORD *)v5 + 3) = v3;
      return v5;
    }
    goto LABEL_18;
  }
  return 0;
}
// 80CE9B0: using guessed type int dl_pagesize;
// 80CF87C: using guessed type int aligned_heap_area;

//----- (080593A0) --------------------------------------------------------
int *__usercall munmap_chunk@<eax>(_DWORD *a1@<eax>)
{
  int v1; // esi
  unsigned int v2; // edi
  unsigned int v3; // esi
  int v4; // edx
  int *v6; // eax
  int v7; // edx

  v1 = a1[1];
  v2 = v1 & 0xFFFFFFF8;
  if ( (v1 & 2) == 0 )
    _malloc_assert((int)"chunk_is_mmapped (p)", (int)"malloc.c", 2816, (int)"munmap_chunk");
  v3 = (unsigned int)a1 - *a1;
  v4 = v2 + *a1;
  if ( (((dl_pagesize - 1) & (unsigned int)(a1 + 2)) - 1) & (dl_pagesize - 1) & (unsigned int)(a1 + 2) | (v4 | v3) & (dl_pagesize - 1) )
  {
    v6 = (int *)malloc_printerr((unsigned __int8)&aMunmapChunkInv[-135061504] + (unsigned __int8)&GLOBAL_OFFSET_TABLE_);
    return mremap_chunk(v6, v7);
  }
  else
  {
    _InterlockedDecrement(&dword_80CE4B4);
    _InterlockedAdd(&dword_80CE4C4, -v4);
    return (int *)munmap((void *)v3, v4);
  }
}
// 805943F: variable 'v7' is possibly undefined
// 80CE000: using guessed type _TBYTE GLOBAL_OFFSET_TABLE_;
// 80CE4B4: using guessed type int dword_80CE4B4;
// 80CE4C4: using guessed type int dword_80CE4C4;
// 80CE9B0: using guessed type int dl_pagesize;

//----- (08059440) --------------------------------------------------------
int *__usercall mremap_chunk@<eax>(int *result@<eax>, int a2@<edx>)
{
  int v2; // edi
  int v3; // esi
  unsigned int v4; // ecx
  int v5; // edi
  unsigned int v6; // eax
  _DWORD *v7; // ecx
  unsigned __int32 v8; // edi
  unsigned __int32 v9; // eax
  int v10; // ett
  size_t v11; // [esp+0h] [ebp-28h]

  v2 = result[1];
  v3 = *result;
  v4 = v2 & 0xFFFFFFF8;
  if ( (v2 & 2) == 0 )
    _malloc_assert((int)"chunk_is_mmapped (p)", (int)"malloc.c", 2854, (int)"mremap_chunk");
  v11 = v3 + v4;
  if ( (((dl_pagesize - 1) & (unsigned int)(result + 2)) - 1) & (dl_pagesize - 1) & (unsigned int)(result + 2) | (dl_pagesize - 1) & ((v3 + v4) | ((unsigned int)result - v3)) )
  {
    malloc_printerr((unsigned __int8)&aMremapChunkInv[-135061504] + (unsigned __int8)&GLOBAL_OFFSET_TABLE_);
    goto LABEL_15;
  }
  v5 = (dl_pagesize + a2 + 3 + v3) & -dl_pagesize;
  if ( v11 != v5 )
  {
    v6 = mremap((char *)result - v3, v11, v5, 1u);
    if ( v6 == -1 )
      return 0;
    v7 = (_DWORD *)(v6 + v3);
    if ( (((_BYTE)v6 + (_BYTE)v3 + 8) & 0xF) == 0 )
    {
      if ( *v7 != v3 )
        _malloc_assert((int)"prev_size (p) == offset", (int)"malloc.c", 2880, (int)"mremap_chunk");
      v7[1] = (v5 - v3) | 2;
      v8 = _InterlockedExchangeAdd(&dword_80CE4C4, v5 - v11) + v5 - v11;
      do
      {
        v9 = *((_DWORD *)&GLOBAL_OFFSET_TABLE_ + 306);
        if ( v8 <= v9 )
          break;
        v10 = *((_DWORD *)&GLOBAL_OFFSET_TABLE_ + 306);
      }
      while ( v10 != _InterlockedCompareExchange(&dword_80CE4C8, v8, v9) );
      return v7;
    }
LABEL_15:
    _malloc_assert((int)"aligned_OK (chunk2mem (p))", (int)"malloc.c", 2878, (int)"mremap_chunk");
  }
  return result;
}
// 80CE000: using guessed type _TBYTE GLOBAL_OFFSET_TABLE_;
// 80CE4C4: using guessed type int dword_80CE4C4;
// 80CE4C8: using guessed type int dword_80CE4C8;
// 80CE9B0: using guessed type int dl_pagesize;

//----- (080595C0) --------------------------------------------------------
unsigned int ptmalloc_init()
{
  int *v0; // eax
  char *v2; // [esp+0h] [ebp-14h] BYREF
  unsigned int v3; // [esp+4h] [ebp-10h]

  v3 = __readgsdword(0x14u);
  if ( _libc_malloc_initialized < 0 )
  {
    _libc_malloc_initialized = 0;
    __writegsdword(0xFFFFFFEC, (unsigned int)&main_arena);
    v0 = &dword_80CE538;
    do
    {
      v0[3] = (int)v0;
      v0[2] = (int)v0;
      v0 += 2;
    }
    while ( v0 != (int *)&unk_80CE930 );
    dword_80CE538 = (int)&dword_80CE538;
    global_max_fast = 64;
    dword_80CE508 = 0;
    _tunable_get_val(23, &v2, (int (__cdecl *)(char **))dl_tunable_set_mallopt_check);
    _tunable_get_val(9, &v2, (int (__cdecl *)(char **))dl_tunable_set_top_pad);
    _tunable_get_val(3, &v2, (int (__cdecl *)(char **))dl_tunable_set_perturb_byte);
    _tunable_get_val(18, &v2, (int (__cdecl *)(char **))dl_tunable_set_mmap_threshold);
    _tunable_get_val(2, &v2, (int (__cdecl *)(char **))dl_tunable_set_trim_threshold);
    _tunable_get_val(10, &v2, (int (__cdecl *)(char **))dl_tunable_set_mmaps_max);
    _tunable_get_val(17, &v2, (int (__cdecl *)(char **))dl_tunable_set_arena_max);
    _tunable_get_val(20, &v2, (int (__cdecl *)(char **))dl_tunable_set_arena_test);
    _tunable_get_val(22, &v2, (int (__cdecl *)(char **))dl_tunable_set_tcache_max);
    _tunable_get_val(19, &v2, (int (__cdecl *)(char **))dl_tunable_set_tcache_count);
    _tunable_get_val(12, &v2, (int (__cdecl *)(char **))dl_tunable_set_tcache_unsorted_limit);
    _libc_malloc_initialized = 1;
  }
  return __readgsdword(0x14u) ^ v3;
}
// 80CE484: using guessed type int _libc_malloc_initialized;
// 80CE500: using guessed type int main_arena;
// 80CE508: using guessed type int dword_80CE508;
// 80CE538: using guessed type int dword_80CE538;
// 80CF890: using guessed type int global_max_fast;

//----- (08059730) --------------------------------------------------------
struct timespec *__usercall arena_get2_part_5@<eax>(int a1@<eax>, int a2@<edx>)
{
  int v5; // eax
  unsigned int v6; // edx
  int v10; // edx
  bool v11; // zf
  int v12; // eax
  struct timespec *tv_nsec; // edx
  int nprocs; // eax
  int *v17; // edx
  char *v18; // eax
  char *v19; // edx
  char *v20; // eax
  int v21; // eax
  int v22; // ecx
  bool v24; // zf
  bool v26; // zf
  bool v28; // zf
  int v29; // [esp+0h] [ebp-20h]

  _EBX = &GLOBAL_OFFSET_TABLE_;
  v5 = narenas_limit_12605;
  v6 = narenas;
  if ( !narenas_limit_12605 )
  {
    v5 = dword_80CE4B0;
    if ( dword_80CE4B0 )
    {
      narenas_limit_12605 = dword_80CE4B0;
    }
    else if ( dword_80CE4AC < (unsigned int)narenas )
    {
      nprocs = get_nprocs();
      if ( nprocs <= 0 )
      {
        narenas_limit_12605 = 4;
        v6 = narenas;
        v5 = 4;
      }
      else
      {
        v5 = 2 * nprocs;
        v6 = narenas;
        narenas_limit_12605 = v5;
      }
    }
  }
  if ( v5 - 1 < v6 )
  {
    _ESI = (struct timespec *)next_to_use_12583;
    if ( !next_to_use_12583 )
    {
      _ESI = (struct timespec *)&main_arena;
      next_to_use_12583 = (int)&main_arena;
    }
    _ECX = 1;
    if ( __readgsdword(0xCu) )
      __asm { lock }
    __asm { cmpxchg [esi], ecx }
    _ECX = 1;
    v10 = __readgsdword(0xFFFFFFEC);
    v11 = __readgsdword(0xCu) == 0;
    if ( !v11 )
      __asm { lock }
    __asm { cmpxchg ds:(free_list_lock - 80CE000h)[ebx], ecx }
    if ( !v11 )
      _lll_lock_wait_private(0, &free_list_lock, a2, (int *)0xFFFFFFEC);
    detach_arena(v10);
    v12 = free_list;
    if ( !free_list )
      goto LABEL_20;
    if ( *(_DWORD *)(free_list + 1104) )
LABEL_26:
      _malloc_assert((int)"p->attached_threads == 0", (int)"arena.c", 795, (int)"remove_from_free_list");
    if ( _ESI == (struct timespec *)free_list )
    {
      v17 = &free_list;
    }
    else
    {
      tv_nsec = *(struct timespec **)(free_list + 1100);
      if ( !tv_nsec )
      {
LABEL_20:
        ++_ESI[138].tv_sec;
        if ( __readgsdword(0xCu) )
          __asm { lock }
        if ( --free_list_lock )
          _lll_unlock_wake_private(&free_list_lock, a2, (int *)0xFFFFFFEC, _ESI);
        __writegsdword(0xFFFFFFEC, (unsigned int)_ESI);
        next_to_use_12583 = _ESI[137].tv_sec;
        return _ESI;
      }
      while ( 1 )
      {
        if ( tv_nsec[138].tv_sec )
          goto LABEL_26;
        if ( _ESI == tv_nsec )
          break;
        v12 = (int)tv_nsec;
        tv_nsec = (struct timespec *)tv_nsec[137].tv_nsec;
        if ( !tv_nsec )
          goto LABEL_20;
      }
      v17 = (int *)(v12 + 1100);
      v12 = (int)_ESI;
    }
    *v17 = *(_DWORD *)(v12 + 1100);
    goto LABEL_20;
  }
  _ECX = v6 + 1;
  if ( __readgsdword(0xCu) )
    __asm { lock }
  __asm { cmpxchg (narenas - 80CE000h)[ebx], ecx }
  v18 = new_heap(a1 + 1156, dword_80CE4A4);
  v19 = v18;
  if ( !v18 )
  {
    v19 = new_heap(0x484u, dword_80CE4A4);
    if ( !v19 )
      goto LABEL_73;
  }
  _ESI = (struct timespec *)(v19 + 24);
  v20 = v19 + 80;
  *(_DWORD *)v19 = v19 + 24;
  do
  {
    *((_DWORD *)v20 + 3) = v20;
    *((_DWORD *)v20 + 2) = v20;
    v20 += 8;
  }
  while ( v19 + 1096 != v20 );
  if ( _ESI == (struct timespec *)&main_arena )
    global_max_fast = 64;
  else
    *((_DWORD *)v19 + 7) |= 2u;
  v21 = *((_DWORD *)v19 + 2);
  *((_DWORD *)v19 + 8) = 0;
  v22 = (int)(v19 + 1140);
  *((_DWORD *)v19 + 282) = 1;
  *((_DWORD *)v19 + 284) = v21;
  *((_DWORD *)v19 + 283) = v21;
  if ( (((_BYTE)v19 + 124) & 0xF) != 0 )
    v22 = v22 - (((_BYTE)v19 + 124) & 0xF) + 16;
  *((_DWORD *)v19 + 20) = v22;
  *(_DWORD *)(v22 + 4) = (unsigned int)&v19[v21 - v22] | 1;
  v29 = __readgsdword(0xFFFFFFEC);
  _ECX = 1;
  __writegsdword(0xFFFFFFEC, (unsigned int)_ESI);
  *((_DWORD *)v19 + 6) = 0;
  v24 = __readgsdword(0xCu) == 0;
  if ( !v24 )
    __asm { lock }
  __asm { cmpxchg ds:(list_lock - 80CE000h)[ebx], ecx }
  if ( !v24 )
    _lll_lock_wait_private(0, &list_lock, 1, 0);
  *((_DWORD *)v19 + 280) = off_80CE948;
  off_80CE948 = &_ESI->tv_sec;
  if ( __readgsdword(0xCu) )
    __asm { lock }
  if ( --list_lock )
    _lll_unlock_wake_private(&list_lock, 1, 0, _ESI);
  _ECX = 1;
  v26 = __readgsdword(0xCu) == 0;
  if ( !v26 )
    __asm { lock }
  __asm { cmpxchg ds:(free_list_lock - 80CE000h)[ebx], ecx }
  if ( !v26 )
    _lll_lock_wait_private(0, &free_list_lock, 1, 0);
  detach_arena(v29);
  if ( __readgsdword(0xCu) )
    __asm { lock }
  if ( --free_list_lock )
    _lll_unlock_wake_private(&free_list_lock, 1, 0, _ESI);
  _ECX = 1;
  v28 = __readgsdword(0xCu) == 0;
  if ( !v28 )
    __asm { lock }
  __asm { cmpxchg [esi], ecx }
  if ( !v28 )
    _lll_lock_wait_private(0, &_ESI->tv_sec, 1, 0);
  if ( !_ESI )
  {
LABEL_73:
    if ( __readgsdword(0xCu) )
      __asm { lock }
    --narenas;
    return 0;
  }
  return _ESI;
}
// 80597E9: variable 'v10' is possibly undefined
// 8059A6A: variable 'v19' is possibly undefined
// 80CE000: using guessed type _TBYTE GLOBAL_OFFSET_TABLE_;
// 80CE488: using guessed type int narenas;
// 80CE4A4: using guessed type int dword_80CE4A4;
// 80CE4AC: using guessed type int dword_80CE4AC;
// 80CE4B0: using guessed type int dword_80CE4B0;
// 80CE500: using guessed type int main_arena;
// 80CE948: using guessed type int *off_80CE948;
// 80CF870: using guessed type int next_to_use_12583;
// 80CF874: using guessed type int narenas_limit_12605;
// 80CF880: using guessed type int list_lock;
// 80CF884: using guessed type int free_list;
// 80CF888: using guessed type int free_list_lock;
// 80CF890: using guessed type int global_max_fast;

//----- (08059B50) --------------------------------------------------------
struct timespec *__usercall arena_get_retry@<eax>(int *a1@<eax>, const struct timespec *a2@<edx>, int a3@<ebp>)
{
  bool v6; // zf
  struct timespec *result; // eax

  _EBX = &GLOBAL_OFFSET_TABLE_;
  if ( a1 == &main_arena )
  {
    if ( __readgsdword(0xCu) )
      __asm { lock }
    if ( --main_arena )
      _lll_unlock_wake_private(&main_arena, a3, a1, a2);
    result = (struct timespec *)get_free_list(a3);
    if ( !result )
      return arena_get2_part_5((int)a2, (int)a1);
  }
  else
  {
    if ( __readgsdword(0xCu) )
      __asm { lock }
    v6 = (*a1)-- == 1;
    if ( !v6 )
      _lll_unlock_wake_private(a1, a3, a1, (const struct timespec *)&main_arena);
    _ECX = 1;
    v6 = __readgsdword(0xCu) == 0;
    if ( !v6 )
      __asm { lock }
    __asm { cmpxchg (main_arena - 80CE000h)[ebx], ecx }
    if ( !v6 )
      _lll_lock_wait_private(0, &main_arena, a3, a1);
    return (struct timespec *)&main_arena;
  }
  return result;
}
// 80CE000: using guessed type _TBYTE GLOBAL_OFFSET_TABLE_;
// 80CE500: using guessed type int main_arena;

//----- (08059BF0) --------------------------------------------------------
_TBYTE *__cdecl dl_tunable_set_mallopt_check(_DWORD *a1)
{
  _TBYTE *result; // eax

  result = &GLOBAL_OFFSET_TABLE_;
  if ( *a1 )
  {
    using_malloc_checking = 1;
    _malloc_hook = (int (__cdecl *)(int))malloc_check;
    _free_hook = (int)free_check;
    _realloc_hook = (int)realloc_check;
    _memalign_hook[0] = (int (__cdecl *)(int, int))memalign_check;
  }
  return result;
}
// 80CE000: using guessed type _TBYTE GLOBAL_OFFSET_TABLE_;
// 80CE4E0: using guessed type int (__cdecl *_memalign_hook[2])(int, int);
// 80CE4E4: using guessed type int _realloc_hook;
// 80CE4E8: using guessed type int (__cdecl *_malloc_hook)(int);
// 80CF86C: using guessed type int _free_hook;
// 80CF878: using guessed type int using_malloc_checking;

//----- (08059C50) --------------------------------------------------------
int __usercall _malloc_info_part_10@<eax>(
        const struct timespec *a1@<eax>,
        int a2@<ebx>,
        int a3@<ebp>,
        const struct timespec *a4@<esi>)
{
  int v4; // eax
  bool v7; // zf
  int *v8; // ecx
  int *v9; // ebx
  int v10; // ebp
  int v11; // edi
  int v12; // edx
  int v13; // edx
  int v14; // eax
  unsigned int v15; // esi
  struct timespec *v16; // esi
  int v17; // ebx
  int *v18; // edx
  unsigned int v19; // ecx
  unsigned int v20; // ebx
  __time_t v21; // ebp
  unsigned int v22; // eax
  int v23; // ebp
  char *v24; // ebp
  int i; // ebx
  int v27; // ecx
  int v28; // edx
  _DWORD *v29; // eax
  int v30; // eax
  int v31; // [esp+0h] [ebp-934h]
  int v32; // [esp+0h] [ebp-934h]
  int *v33; // [esp+4h] [ebp-930h]
  int v34; // [esp+4h] [ebp-930h]
  int v35; // [esp+8h] [ebp-92Ch]
  int v36; // [esp+Ch] [ebp-928h]
  int v37; // [esp+10h] [ebp-924h]
  int v38; // [esp+14h] [ebp-920h]
  int *v39; // [esp+18h] [ebp-91Ch]
  int v41; // [esp+28h] [ebp-90Ch]
  int v42; // [esp+34h] [ebp-900h]
  int v43; // [esp+38h] [ebp-8FCh]
  int v44; // [esp+3Ch] [ebp-8F8h]
  int v45; // [esp+40h] [ebp-8F4h]
  int v46; // [esp+44h] [ebp-8F0h]
  int v47; // [esp+48h] [ebp-8ECh]
  int v48; // [esp+4Ch] [ebp-8E8h]
  int v49; // [esp+50h] [ebp-8E4h]
  int v50; // [esp+54h] [ebp-8E0h]
  char v51[176]; // [esp+74h] [ebp-8C0h] BYREF
  int v52[3]; // [esp+124h] [ebp-810h] BYREF
  int v53; // [esp+130h] [ebp-804h]
  int v54[8]; // [esp+914h] [ebp-20h] BYREF

  v54[7] = a3;
  v54[5] = (int)a4;
  v54[4] = a2;
  v54[0] = __readgsdword(0x14u);
  v50 = 0;
  v49 = 0;
  v48 = 0;
  v47 = 0;
  v44 = 0;
  v46 = 0;
  v43 = 0;
  v45 = 0;
  v39 = &main_arena;
  v4 = 0;
  do
  {
    v42 = v4 + 1;
    fprintf(a2, (int)a4, (int)a1, (unsigned int *)"<heap nr=\"%d\">\n<sizes>\n", v4);
    _ECX = 1;
    _EDI = v39;
    v7 = __readgsdword(0xCu) == 0;
    if ( !v7 )
      __asm { lock }
    __asm { cmpxchg [edi], ecx }
    if ( !v7 )
      _lll_lock_wait_private(0, v39, a3, v39);
    v8 = (int *)v51;
    v9 = v39 + 3;
    v10 = 0;
    v11 = (int)v52;
    v38 = 0;
    do
    {
      v14 = *v9;
      if ( *v9 )
      {
        v12 = 0;
        v15 = *(_DWORD *)(v14 + 4) & 0xFFFFFFF8;
        do
        {
          v14 = *(_DWORD *)(v14 + 8);
          ++v12;
        }
        while ( v14 );
        v38 += v12;
        v8[1] = v15;
        v8[3] = v12;
        v10 += v12 * v15;
        *v8 = v15 - 15;
      }
      else
      {
        v8[3] = 0;
        v12 = 0;
        v8[1] = 0;
        *v8 = 0;
      }
      v13 = v8[1] * v12;
      v8 += 4;
      ++v9;
      *(v8 - 2) = v13;
    }
    while ( v8 != v52 );
    v16 = (struct timespec *)v52;
    v41 = v10;
    v31 = 0;
    v37 = 0;
    v33 = v39 + 14;
    do
    {
      v16->tv_sec = -1;
      v16[1].tv_nsec = 0;
      v18 = (int *)v33[2];
      v16[1].tv_sec = 0;
      v16->tv_nsec = 0;
      if ( !v18 || v18 == v33 )
        goto LABEL_14;
      v11 = 1;
      v19 = 0;
      v20 = -1;
      v21 = 0;
      while ( 1 )
      {
        v22 = v18[1];
        v18 = (int *)v18[2];
        v21 += v22;
        if ( v20 > v22 )
          v20 = v22;
        if ( v19 < v22 )
          v19 = v22;
        if ( v18 == v33 )
          break;
        ++v11;
      }
      v37 += v11;
      v16[1].tv_nsec = v11;
      v16[1].tv_sec = v21;
      v16->tv_sec = v20;
      v16->tv_nsec = v19;
      if ( !v11 )
LABEL_14:
        v16->tv_sec = 0;
      v17 = v16[1].tv_sec + v31;
      v16 += 2;
      v31 = v17;
      v33 += 2;
    }
    while ( v16 != (struct timespec *)v54 );
    if ( v39 == &main_arena )
    {
      v36 = 0;
      v23 = 0;
      v35 = 0;
    }
    else
    {
      v27 = 0;
      v28 = 0;
      v23 = 0;
      v29 = (_DWORD *)(v39[14] & 0xFFF00000);
      do
      {
        v23 += v29[2];
        v28 += v29[3];
        ++v27;
        v29 = (_DWORD *)v29[1];
      }
      while ( v29 );
      v35 = v28;
      v36 = v27;
    }
    if ( __readgsdword(0xCu) )
      __asm { lock }
    v7 = (*v39)-- == 1;
    if ( !v7 )
      _lll_unlock_wake_private(v39, v23, (int *)v11, v16);
    v32 = v23;
    v43 += v38;
    v44 += v41;
    v45 += v37;
    v24 = v51;
    v46 += v17;
    v34 = v17;
    for ( i = 0; i != 138; ++i )
    {
      if ( i != 11 && *((_DWORD *)v24 + 3) )
        fprintf(
          i,
          (int)a1,
          (int)a1,
          (unsigned int *)&GLOBAL_OFFSET_TABLE_ - 44229,
          *(_DWORD *)v24,
          *((_DWORD *)v24 + 1),
          *((_DWORD *)v24 + 2),
          *((_DWORD *)v24 + 3));
      v24 += 16;
    }
    a3 = v32;
    a2 = v34;
    if ( v53 )
      fprintf(v34, (int)a1, (int)a1, (unsigned int *)&GLOBAL_OFFSET_TABLE_ - 44212, v52[0], v52[1], v52[2], v53);
    v47 += v39[277];
    v48 += v39[278];
    a4 = a1;
    fprintf(
      v34,
      (int)a1,
      (int)a1,
      (unsigned int *)"</sizes>\n"
                      "<total type=\"fast\" count=\"%zu\" size=\"%zu\"/>\n"
                      "<total type=\"rest\" count=\"%zu\" size=\"%zu\"/>\n"
                      "<system type=\"current\" size=\"%zu\"/>\n"
                      "<system type=\"max\" size=\"%zu\"/>\n",
      v38,
      v41,
      v37,
      v34,
      v39[277],
      v39[278]);
    if ( v39 == &main_arena )
    {
      fprintf(
        v34,
        (int)a1,
        (int)a1,
        (unsigned int *)&GLOBAL_OFFSET_TABLE_ - 44127,
        *((_DWORD *)&GLOBAL_OFFSET_TABLE_ + 597),
        *((_DWORD *)&GLOBAL_OFFSET_TABLE_ + 597));
      v30 = *((_DWORD *)&GLOBAL_OFFSET_TABLE_ + 597);
      v49 += v30;
      v50 += v30;
    }
    else
    {
      fprintf(v34, (int)a1, (int)a1, (unsigned int *)&GLOBAL_OFFSET_TABLE_ - 44155, v32, v35, v36);
      v49 += v32;
      v50 += v35;
    }
    fputs((unsigned int *)"</heap>\n", a1);
    v4 = v42;
    v39 = (int *)v39[274];
  }
  while ( v39 != &main_arena );
  fprintf(
    v34,
    (int)a1,
    (int)a1,
    (unsigned int *)&GLOBAL_OFFSET_TABLE_ - 44109,
    v43,
    v44,
    v45,
    v46,
    *((_DWORD *)&GLOBAL_OFFSET_TABLE_ + 301),
    *((_DWORD *)&GLOBAL_OFFSET_TABLE_ + 305),
    v47,
    v48,
    v49,
    v50);
  return 0;
}
// 80CE000: using guessed type _TBYTE GLOBAL_OFFSET_TABLE_;
// 80CE500: using guessed type int main_arena;
// 8059C50: using guessed type int var_20[8];

//----- (0805A100) --------------------------------------------------------
int __usercall systrim_isra_1_constprop_11@<eax>(unsigned int a1@<eax>)
{
  unsigned int v1; // ebx
  unsigned int v2; // edi
  int v3; // ebp
  int v5; // eax
  int v6; // ebp

  v1 = *(_DWORD *)(dword_80CE538 + 4) & 0xFFFFFFF8;
  if ( v1 - 17 <= a1 )
    return 0;
  v2 = (v1 - 17 - a1) & -dl_pagesize;
  if ( !v2 )
    return 0;
  v3 = _morecore(0);
  if ( v3 != v1 + dword_80CE538 )
    return 0;
  _morecore(-v2);
  if ( _after_morecore_hook )
    ((void (*)(void))_after_morecore_hook)();
  v5 = _morecore(0);
  if ( !v5 )
    return 0;
  v6 = v3 - v5;
  if ( !v6 )
    return 0;
  dword_80CE954 -= v6;
  *(_DWORD *)(dword_80CE538 + 4) = (v1 - v6) | 1;
  return 1;
}
// 80CE538: using guessed type int dword_80CE538;
// 80CE954: using guessed type int dword_80CE954;
// 80CE95C: using guessed type int (__cdecl *_morecore)(int);
// 80CE9B0: using guessed type int dl_pagesize;
// 80CF868: using guessed type int _after_morecore_hook;

//----- (0805A1C0) --------------------------------------------------------
unsigned int __usercall int_free@<eax>(int a1@<eax>, unsigned int a2@<edx>, unsigned int a3@<ecx>, int *a4@<edi>)
{
  int v5; // eax
  unsigned int v7; // eax
  unsigned int v8; // ecx
  unsigned int v9; // eax
  unsigned __int8 v10; // al
  unsigned int v11; // eax
  char *v12; // ecx
  char *v14; // eax
  unsigned int v15; // eax
  int v16; // eax
  _DWORD *v17; // ecx
  int v18; // edx
  int v19; // eax
  char *v20; // eax
  int v21; // edx
  unsigned int v22; // eax
  int v23; // eax
  unsigned int v24; // ebx
  int v25; // esi
  bool v27; // zf
  unsigned int v28; // eax
  _BOOL4 v29; // ecx
  int v30; // edx
  int v31; // ecx
  int v32; // ecx
  unsigned int v33; // eax
  int v34; // eax
  int v35; // edx
  bool v36; // dl
  int v37; // eax
  unsigned int v38; // eax
  char *v39; // eax
  _DWORD *v40; // edx
  bool v42; // zf
  int v43; // ecx
  char *v44; // eax
  unsigned int v45; // ecx
  _DWORD *v46; // eax
  int v47; // edx
  int v48; // edx
  int v49; // eax
  int v50; // ecx
  int *v51; // eax
  int *v52; // edx
  int v53; // ecx
  int v54; // eax
  signed int v55; // eax
  int v56; // edx
  int v57; // edx
  char *v58; // [esp+0h] [ebp-4Ch]
  size_t v60; // [esp+4h] [ebp-48h]
  unsigned int v61; // [esp+8h] [ebp-44h]
  unsigned __int8 *v62; // [esp+Ch] [ebp-40h]
  unsigned int v63; // [esp+Ch] [ebp-40h]
  unsigned int v64; // [esp+10h] [ebp-3Ch]
  int v65; // [esp+10h] [ebp-3Ch]
  unsigned int v66; // [esp+14h] [ebp-38h]
  unsigned int v67; // [esp+18h] [ebp-34h]
  int *v68; // [esp+1Ch] [ebp-30h]
  char v69; // [esp+2Bh] [ebp-21h] BYREF
  unsigned int v70; // [esp+2Ch] [ebp-20h]

  _EBP = a1;
  v58 = (char *)a2;
  v70 = __readgsdword(0x14u);
  v5 = *(_DWORD *)(a2 + 4);
  _ESI = v5 & 0xFFFFFFF8;
  if ( a2 > -(v5 & 0xFFFFFFF8) || (v62 = (unsigned __int8 *)(a2 + 8), (v61 = (a2 + 8) & 0xF) != 0) )
  {
    malloc_printerr((unsigned __int8)&aFreeInvalidPoi[-135061504] + (unsigned __int8)&GLOBAL_OFFSET_TABLE_);
LABEL_58:
    malloc_printerr((unsigned __int8)&aFreeInvalidSiz[-135061504] + (unsigned __int8)&GLOBAL_OFFSET_TABLE_);
LABEL_59:
    if ( a3 )
      goto LABEL_71;
    _ECX = 1;
    v27 = __readgsdword(0xCu) == 0;
    if ( !v27 )
      __asm { lock }
    __asm { cmpxchg [ebp+0], ecx }
    if ( !v27 )
      _lll_lock_wait_private(0, (int *)_EBP, _EBP, a4);
    v28 = a4[1];
    v29 = 1;
    if ( v28 > 8 )
      v29 = (v28 & 0xFFFFFFF8) >= *(_DWORD *)(_EBP + 1108);
    if ( __readgsdword(0xCu) )
      __asm { lock }
    v27 = (*(_DWORD *)_EBP)-- == 1;
    if ( !v27 )
      _lll_unlock_wake_private((int *)_EBP, _EBP, a4, (const struct timespec *)_ESI);
    if ( v29 )
    {
LABEL_71:
      v22 = (unsigned int)malloc_printerr((unsigned __int8)&aFreeInvalidNex[-135061504] + (unsigned __int8)&GLOBAL_OFFSET_TABLE_);
      goto LABEL_72;
    }
LABEL_12:
    v10 = perturb_byte;
    if ( !perturb_byte )
    {
LABEL_13:
      *(_DWORD *)(_EBP + 8) = 1;
      a4 = (int *)(_ESI >> 3);
      v11 = _EBP + 4 * (_ESI >> 3);
      v12 = *(char **)(v11 + 4);
      _ESI = __readgsdword(0xCu);
      if ( _ESI )
      {
        _ESI = (unsigned int)v58;
        if ( v58 != v12 )
        {
          _EBP += 4 * (_DWORD)a4 + 4;
          *((_DWORD *)v58 + 2) = v12;
          if ( __readgsdword(0xCu) )
            __asm { lock }
          __asm { cmpxchg [ebp+0], esi }
          _ESI = (unsigned int)v12;
          goto LABEL_16;
        }
      }
      else if ( v58 != v12 )
      {
        _ESI = (unsigned int)v58;
        *((_DWORD *)v58 + 2) = v12;
        *(_DWORD *)(v11 + 4) = v58;
LABEL_16:
        if ( !v12 || (a3 & 1) == 0 || a4 == (int *)(*((_DWORD *)v12 + 1) >> 3) )
          return __readgsdword(0x14u) ^ v70;
        malloc_printerr((unsigned __int8)&aInvalidFastbin[-135061504] + (unsigned __int8)&GLOBAL_OFFSET_TABLE_);
        goto LABEL_79;
      }
      malloc_printerr((unsigned __int8)&aDoubleFreeOrCo[-135061504] + (unsigned __int8)&GLOBAL_OFFSET_TABLE_);
LABEL_102:
      _ESI += a3;
      *((_DWORD *)v58 + 1) = _ESI | 1;
      *(_DWORD *)(_EBP + 56) = v58;
LABEL_49:
      if ( _ESI <= 0xFFFF )
        goto LABEL_91;
      if ( !*(_DWORD *)(_EBP + 8) )
        goto LABEL_51;
      goto LABEL_116;
    }
LABEL_104:
    v37 = 16843009 * v10;
    *(_DWORD *)v62 = v37;
    *(_DWORD *)&v62[_ESI - 12] = v37;
    memset32(
      (void *)((unsigned int)(v62 + 4) & 0xFFFFFFFC),
      v37,
      (unsigned int)&v62[_ESI - 8 - ((unsigned int)(v62 + 4) & 0xFFFFFFFC)] >> 2);
    goto LABEL_13;
  }
  if ( _ESI <= 0xF || (v5 & 8) != 0 )
    goto LABEL_58;
  v7 = __readgsdword(0xFFFFFFE4);
  if ( !v7 )
    goto LABEL_9;
  a4 = (int *)(_ESI - 1);
  v64 = _ESI - 1;
  v8 = (_ESI - 1) >> 4;
  if ( dword_80CE4D0 <= v8 )
    goto LABEL_9;
  if ( v7 == *(_DWORD *)(a2 + 12) )
  {
    v7 = __readgsdword(0xFFFFFFE4);
    a4 = *(int **)(v7 + 4 * v8 + 64);
    if ( a4 )
    {
      if ( v62 == (unsigned __int8 *)a4 )
      {
LABEL_161:
        malloc_printerr((unsigned __int8)&aFreeDoubleFree[-135061504] + (unsigned __int8)&GLOBAL_OFFSET_TABLE_);
        goto LABEL_162;
      }
      v66 = v7;
      while ( 1 )
      {
        a4 = (int *)*a4;
        if ( !a4 )
          break;
        if ( v62 == (unsigned __int8 *)a4 )
          goto LABEL_161;
      }
    }
  }
  a4 = (int *)*(char *)(v7 + v8);
  if ( (unsigned int)a4 >= dword_80CE4D8 )
  {
LABEL_9:
    if ( _ESI <= global_max_fast )
    {
      a4 = (int *)(a2 + _ESI);
      v9 = *(_DWORD *)(a2 + _ESI + 4);
      if ( v9 > 8 && (v9 & 0xFFFFFFF8) < *(_DWORD *)(_EBP + 1108) )
        goto LABEL_12;
      goto LABEL_59;
    }
    if ( (*(_DWORD *)(a2 + 4) & 2) != 0 )
    {
      munmap_chunk((_DWORD *)a2);
      return __readgsdword(0x14u) ^ v70;
    }
    if ( __readgsdword(0xCu) && (a3 & 1) == 0 )
    {
      _ECX = 1;
      v42 = __readgsdword(0xCu) == 0;
      if ( !v42 )
        __asm { lock }
      __asm { cmpxchg [ebp+0], ecx }
      if ( !v42 )
        _lll_lock_wait_private(0, (int *)_EBP, _EBP, a4);
    }
    else
    {
      v61 = 1;
    }
    v14 = *(char **)(_EBP + 56);
    a4 = (int *)&v58[_ESI];
    if ( v14 == v58 )
    {
      v14 = malloc_printerr((unsigned __int8)&aDoubleFreeOrCo_0[-135061504] + (unsigned __int8)&GLOBAL_OFFSET_TABLE_);
    }
    else if ( (*(_BYTE *)(_EBP + 4) & 2) != 0 )
    {
      goto LABEL_26;
    }
    if ( a4 >= (int *)&v14[*((_DWORD *)v14 + 1) & 0xFFFFFFF8] )
    {
      malloc_printerr((unsigned __int8)&aDoubleFreeOrCo_1[-135061504] + (unsigned __int8)&GLOBAL_OFFSET_TABLE_);
      goto LABEL_115;
    }
LABEL_26:
    v15 = a4[1];
    if ( (v15 & 1) != 0 )
    {
      a3 = v15 & 0xFFFFFFF8;
      if ( v15 > 8 && *(_DWORD *)(_EBP + 1108) > (v15 & 0xFFFFFFF8) )
      {
        if ( perturb_byte )
          memset(v62, perturb_byte, _ESI - 8);
        if ( (v58[4] & 1) != 0 )
          goto LABEL_42;
        v16 = *(_DWORD *)v58;
        _ESI += *(_DWORD *)v58;
        v58 -= *(_DWORD *)v58;
        v62 = (unsigned __int8 *)*((_DWORD *)v58 + 1);
        if ( ((unsigned int)v62 & 0xFFFFFFF8) == v16 )
        {
          if ( ((unsigned int)v62 & 0xFFFFFFF8) != *(_DWORD *)&v58[(unsigned int)v62 & 0xFFFFFFF8] )
          {
LABEL_127:
            v39 = malloc_printerr((unsigned __int8)&aCorruptedSizeV[-135061504] + (unsigned __int8)&GLOBAL_OFFSET_TABLE_);
LABEL_128:
            v68 = a4;
            while ( 1 )
            {
              _ESI = (unsigned int)v40 - *v40;
              v43 = *(_DWORD *)(_ESI + 4);
              v44 = &v39[v43 & 0xFFFFFFF8];
              if ( (unsigned int)(v44 + 7) > 0x1E )
                _malloc_assert(
                  (int)"new_size > 0 && new_size < (long) (2 * MINSIZE)",
                  (int)"arena.c",
                  615,
                  (int)"heap_trim");
              a4 = (int *)(v44 + 8);
              if ( (v43 & 1) == 0 )
              {
                a4 = (int *)((char *)a4 + *(_DWORD *)_ESI);
                if ( (unsigned int)a4 - 1 > 0xFFFFE )
                  _malloc_assert((int)"new_size > 0 && new_size < HEAP_MAX_SIZE", (int)"arena.c", 618, (int)"heap_trim");
              }
LABEL_135:
              if ( (char *)a4 - (char *)v62 + 0x100000 < v66 )
                goto LABEL_80;
              *(_DWORD *)(_EBP + 1108) -= *((_DWORD *)v58 + 2);
              if ( (char *)aligned_heap_area == v58 + 0x100000 )
                aligned_heap_area = 0;
              munmap(v58, 0x100000);
              if ( (*(_BYTE *)(_ESI + 4) & 1) == 0 )
              {
                _ESI -= *(_DWORD *)_ESI;
                v45 = *(_DWORD *)(_ESI + 4);
                if ( (v45 & 0xFFFFFFF8) != *(_DWORD *)(_ESI + (v45 & 0xFFFFFFF8)) )
                  goto LABEL_127;
                v46 = *(_DWORD **)(_ESI + 8);
                v47 = *(_DWORD *)(_ESI + 12);
                if ( _ESI != v46[3] || _ESI != *(_DWORD *)(v47 + 8) )
                  goto LABEL_79;
                v46[3] = v47;
                *(_DWORD *)(v47 + 8) = v46;
                if ( v45 > 0x3EF )
                {
                  v48 = *(_DWORD *)(_ESI + 16);
                  if ( v48 )
                  {
                    if ( _ESI != *(_DWORD *)(v48 + 20) )
                      goto LABEL_156;
                    v53 = *(_DWORD *)(_ESI + 20);
                    if ( _ESI != *(_DWORD *)(v53 + 16) )
                      goto LABEL_156;
                    if ( v46[4] )
                    {
                      *(_DWORD *)(v48 + 20) = v53;
                      *(_DWORD *)(*(_DWORD *)(_ESI + 20) + 16) = v48;
                    }
                    else if ( _ESI == v48 )
                    {
                      v46[5] = v46;
                      v46[4] = v46;
                    }
                    else
                    {
                      v46[4] = v48;
                      v57 = *(_DWORD *)(_ESI + 16);
                      v46[5] = v53;
                      *(_DWORD *)(v57 + 20) = v46;
                      *(_DWORD *)(*(_DWORD *)(_ESI + 20) + 16) = v46;
                    }
                  }
                }
              }
              if ( ((v64 - 1) & ((unsigned int)a4 + _ESI)) != 0 )
                _malloc_assert(
                  (int)"((unsigned long) ((char *) p + new_size) & (pagesz - 1)) == 0",
                  (int)"arena.c",
                  630,
                  (int)"heap_trim");
              if ( (int *)((char *)a4 + _ESI) != (int *)(a3 + *(_DWORD *)(a3 + 8)) )
                _malloc_assert(
                  (int)"((char *) p + new_size) == ((char *) heap + heap->size)",
                  (int)"arena.c",
                  631,
                  (int)"heap_trim");
              *(_DWORD *)(_EBP + 56) = _ESI;
              *(_DWORD *)(_ESI + 4) = (unsigned int)a4 | 1;
              if ( _ESI != a3 + 24 )
              {
                a4 = (int *)_ESI;
                v58 = (char *)a3;
                goto LABEL_81;
              }
              v68 = (int *)_ESI;
              v50 = *(_DWORD *)(a3 + 4);
              v58 = (char *)a3;
              v51 = *(int **)(v50 + 8);
              v52 = v51 - 2;
              v62 = (unsigned __int8 *)v51;
              v39 = (char *)(((_BYTE)v50 + (_BYTE)v51 - 8) & 0xF);
              v40 = (_DWORD *)(v50 + (char *)v52 - v39);
              if ( v40[1] != 1 )
                goto LABEL_119;
              a3 = *(_DWORD *)(a3 + 4);
            }
          }
          v17 = (_DWORD *)*((_DWORD *)v58 + 2);
          v18 = *((_DWORD *)v58 + 3);
          if ( (char *)v17[3] != v58 || *(char **)(v18 + 8) != v58 )
          {
LABEL_79:
            malloc_printerr((unsigned __int8)&aCorruptedDoubl[-135061504] + (unsigned __int8)&GLOBAL_OFFSET_TABLE_);
LABEL_80:
            a4 = v68;
            goto LABEL_81;
          }
          v17[3] = v18;
          *(_DWORD *)(v18 + 8) = v17;
          if ( (unsigned int)v62 <= 0x3EF )
            goto LABEL_42;
          v19 = *((_DWORD *)v58 + 4);
          v62 = (unsigned __int8 *)v19;
          if ( !v19 )
            goto LABEL_42;
          if ( *(char **)(v19 + 20) == v58 )
          {
            v20 = v58;
            v21 = *((_DWORD *)v58 + 5);
            if ( *(char **)(v21 + 16) == v58 )
            {
              if ( !v17[4] )
                goto LABEL_157;
              *((_DWORD *)v62 + 5) = v21;
              *(_DWORD *)(*((_DWORD *)v58 + 5) + 16) = v62;
              goto LABEL_42;
            }
          }
          while ( 1 )
          {
LABEL_156:
            v20 = malloc_printerr((unsigned __int8)&aCorruptedDoubl_0[-135061504] + (unsigned __int8)&GLOBAL_OFFSET_TABLE_);
LABEL_157:
            if ( v62 == (unsigned __int8 *)v20 )
            {
LABEL_162:
              v17[5] = v17;
              v17[4] = v17;
            }
            else
            {
              v17[5] = v21;
              v17[4] = v62;
              *(_DWORD *)(*((_DWORD *)v58 + 4) + 20) = v17;
              *(_DWORD *)(*((_DWORD *)v58 + 5) + 16) = v17;
            }
LABEL_42:
            if ( *(int **)(_EBP + 56) == a4 )
              goto LABEL_102;
            v22 = a4[1];
            if ( (*((_BYTE *)a4 + a3 + 4) & 1) != 0 )
            {
              a4[1] = v22 & 0xFFFFFFFE;
              goto LABEL_45;
            }
LABEL_72:
            if ( (v22 & 0xFFFFFFF8) != *(int *)((char *)a4 + (v22 & 0xFFFFFFF8)) )
              goto LABEL_127;
            v30 = a4[2];
            v31 = a4[3];
            if ( *(int **)(v30 + 12) != a4 || *(int **)(v31 + 8) != a4 )
              goto LABEL_79;
            *(_DWORD *)(v30 + 12) = v31;
            *(_DWORD *)(v31 + 8) = v30;
            if ( v22 > 0x3EF )
            {
              v32 = a4[4];
              if ( v32 )
                continue;
            }
            goto LABEL_77;
            if ( *(int **)(v32 + 20) == a4 )
            {
              v49 = a4[5];
              if ( *(int **)(v49 + 16) == a4 )
                break;
            }
          }
          if ( *(_DWORD *)(v30 + 16) )
          {
            *(_DWORD *)(v32 + 20) = v49;
            *(_DWORD *)(a4[5] + 16) = v32;
          }
          else if ( (int *)v32 == a4 )
          {
            *(_DWORD *)(v30 + 20) = v30;
            *(_DWORD *)(v30 + 16) = v30;
          }
          else
          {
            *(_DWORD *)(v30 + 20) = v49;
            *(_DWORD *)(v30 + 16) = v32;
            *(_DWORD *)(a4[4] + 20) = v30;
            *(_DWORD *)(a4[5] + 16) = v30;
          }
LABEL_77:
          _ESI += a3;
LABEL_45:
          v23 = *(_DWORD *)(_EBP + 64);
          if ( *(_DWORD *)(v23 + 12) == _EBP + 56 )
          {
            *((_DWORD *)v58 + 2) = v23;
            *((_DWORD *)v58 + 3) = _EBP + 56;
            if ( _ESI > 0x3EF )
            {
              *((_DWORD *)v58 + 4) = 0;
              *((_DWORD *)v58 + 5) = 0;
            }
            *(_DWORD *)(_EBP + 64) = v58;
            *(_DWORD *)(v23 + 12) = v58;
            *((_DWORD *)v58 + 1) = _ESI | 1;
            *(_DWORD *)&v58[_ESI] = _ESI;
            goto LABEL_49;
          }
        }
        else
        {
          malloc_printerr((unsigned __int8)&aCorruptedSizeV_0[-135061504] + (unsigned __int8)&GLOBAL_OFFSET_TABLE_);
        }
        malloc_printerr((unsigned __int8)&aFreeCorruptedU[-135061504] + (unsigned __int8)&GLOBAL_OFFSET_TABLE_);
        goto LABEL_135;
      }
      v10 = (unsigned __int8)malloc_printerr((unsigned __int8)&aFreeInvalidNex_0[-135061504] + (unsigned __int8)&GLOBAL_OFFSET_TABLE_);
      goto LABEL_104;
    }
LABEL_115:
    malloc_printerr((unsigned __int8)&aDoubleFreeOrCo_2[-135061504] + (unsigned __int8)&GLOBAL_OFFSET_TABLE_);
LABEL_116:
    malloc_consolidate(_EBP);
LABEL_51:
    if ( (int *)_EBP == &main_arena )
    {
      if ( (*(_DWORD *)(dword_80CE538 + 4) & 0xFFFFFFF8) >= mp_ )
        systrim_isra_1_constprop_11(dword_80CE4A4);
      goto LABEL_91;
    }
    a4 = *(int **)(_EBP + 56);
    v58 = (char *)((unsigned int)a4 & 0xFFF00000);
    if ( *(_DWORD *)((unsigned int)a4 & 0xFFF00000) != _EBP )
      _malloc_assert((int)"heap->ar_ptr == av", (int)"malloc.c", 4420, (int)"_int_free");
    v67 = dword_80CE4A4;
    _ESI = dl_pagesize;
    v64 = dl_pagesize;
    if ( a4 != (int *)(v58 + 24) )
    {
LABEL_81:
      v33 = a4[1] & 0xFFFFFFF8;
      v63 = v33;
      if ( mp_ <= v33 )
      {
        v34 = v33 - 17;
        if ( v34 >= 0 )
        {
          _ESI = v67;
          if ( v67 < v34 )
          {
            v35 = -v64 & (v34 - v67);
            v60 = v35;
            if ( v35 )
            {
              _ESI = *((_DWORD *)v58 + 2) - v35;
              if ( (int)_ESI > 23 )
              {
                if ( may_shrink_heap_11496 < 0 )
                {
                  may_shrink_heap_11496 = _libc_enable_secure;
                  if ( !_libc_enable_secure )
                  {
                    v54 = _open_nocancel((int)"/proc/sys/vm/overcommit_memory");
                    if ( v54 >= 0 )
                    {
                      v65 = v54;
                      v55 = _read_nocancel(v54, &v69, 1u);
                      v56 = _libc_enable_secure;
                      if ( v55 > 0 )
                        v56 = v69 == 50;
                      may_shrink_heap_11496 = v56;
                      _close_nocancel(v65);
                    }
                  }
                  v36 = may_shrink_heap_11496 != 0;
                }
                else
                {
                  v36 = may_shrink_heap_11496 != 0;
                }
                if ( !v36 )
                {
                  madvise(&v58[_ESI], v60, 4);
LABEL_90:
                  *((_DWORD *)v58 + 2) = _ESI;
                  *(_DWORD *)(_EBP + 1108) -= v60;
                  a4[1] = (v63 - v60) | 1;
                  goto LABEL_91;
                }
                if ( mmap(&v58[_ESI], v60, 0, 50, -1, 0) != -1 )
                {
                  *((_DWORD *)v58 + 3) = _ESI;
                  goto LABEL_90;
                }
              }
            }
          }
        }
      }
LABEL_91:
      if ( !v61 )
      {
        if ( __readgsdword(0xCu) )
          __asm { lock }
        v27 = (*(_DWORD *)_EBP)-- == 1;
        if ( !v27 )
          _lll_unlock_wake_private((int *)_EBP, _EBP, a4, (const struct timespec *)_ESI);
      }
      return __readgsdword(0x14u) ^ v70;
    }
    v38 = *(_DWORD *)((*(_DWORD *)(_EBP + 56) & 0xFFF00000) + 4);
    v66 = dword_80CE4A4 + dl_pagesize + 16;
    a3 = v38;
    v62 = *(unsigned __int8 **)(v38 + 8);
    v39 = (char *)(((_BYTE)v62 - 8 + (_BYTE)v38) & 0xF);
    v40 = (_DWORD *)(a3 + v62 - 8 - (unsigned __int8 *)v39);
    if ( v40[1] != 1 )
LABEL_119:
      _malloc_assert((int)"chunksize_nomask (p) == (0 | PREV_INUSE)", (int)"arena.c", 612, (int)"heap_trim");
    goto LABEL_128;
  }
  if ( v64 > 0x3FF )
    _malloc_assert((int)"tc_idx < TCACHE_MAX_BINS", (int)"malloc.c", 2926, (int)"tcache_put");
  v24 = v7 + 4 * v8;
  v25 = *(_DWORD *)(v24 + 64);
  *(_DWORD *)(a2 + 12) = v7;
  *(_DWORD *)(a2 + 8) = v25;
  *(_DWORD *)(v24 + 64) = v62;
  *(_BYTE *)(v7 + v8) = (_BYTE)a4 + 1;
  return __readgsdword(0x14u) ^ v70;
}
// 805A5A2: variable 'v29' is possibly undefined
// 805A633: variable 'v68' is possibly undefined
// 805A64E: variable 'v67' is possibly undefined
// 805A65E: variable 'v64' is possibly undefined
// 805A6CE: variable 'v61' is possibly undefined
// 805A7A6: variable 'v62' is possibly undefined
// 805A96D: variable 'v40' is possibly undefined
// 805A9E2: variable 'v66' is possibly undefined
// 805AB80: variable 'v21' is possibly undefined
// 805AB80: variable 'v17' is possibly undefined
// 80CDDAC: using guessed type int _libc_enable_secure;
// 80CE000: using guessed type _TBYTE GLOBAL_OFFSET_TABLE_;
// 80CE480: using guessed type int may_shrink_heap_11496;
// 80CE4A0: using guessed type int mp_;
// 80CE4A4: using guessed type int dword_80CE4A4;
// 80CE4D0: using guessed type int dword_80CE4D0;
// 80CE4D8: using guessed type int dword_80CE4D8;
// 80CE500: using guessed type int main_arena;
// 80CE538: using guessed type int dword_80CE538;
// 80CE9B0: using guessed type int dl_pagesize;
// 80CF87C: using guessed type int aligned_heap_area;
// 80CF88C: using guessed type int perturb_byte;
// 80CF890: using guessed type int global_max_fast;

//----- (0805ACF0) --------------------------------------------------------
int *__usercall sysmalloc@<eax>(unsigned int a1@<eax>, int *a2@<edx>)
{
  unsigned int v2; // ebp
  int v3; // edi
  int v5; // edi
  int v6; // eax
  unsigned int v7; // ecx
  unsigned int v8; // edx
  unsigned int v9; // eax
  int v10; // eax
  int *v11; // edi
  int v12; // edx
  unsigned int v13; // eax
  unsigned int v14; // eax
  char *v15; // edx
  int *v16; // edi
  size_t v17; // edx
  _DWORD *v18; // eax
  int v19; // edx
  int v20; // esi
  signed __int32 v21; // ecx
  signed __int32 v22; // eax
  int v23; // ett
  unsigned __int32 v24; // edx
  unsigned __int32 v25; // eax
  int v26; // ett
  char *v28; // eax
  int v29; // edi
  int v30; // edx
  int v31; // edi
  unsigned int v32; // eax
  int v33; // edx
  _DWORD *v34; // edi
  unsigned int v35; // eax
  int v36; // edx
  int v37; // edi
  int v38; // eax
  size_t v39; // eax
  int v40; // eax
  unsigned int v41; // edx
  int v42; // edi
  int v43; // edx
  unsigned int v44; // eax
  unsigned int v45; // eax
  int *v46; // [esp+0h] [ebp-48h]
  unsigned int v47; // [esp+0h] [ebp-48h]
  unsigned int v48; // [esp+0h] [ebp-48h]
  unsigned int v49; // [esp+0h] [ebp-48h]
  unsigned int v50; // [esp+0h] [ebp-48h]
  unsigned int v51; // [esp+0h] [ebp-48h]
  int *v52; // [esp+4h] [ebp-44h]
  int v53; // [esp+4h] [ebp-44h]
  unsigned int v54; // [esp+4h] [ebp-44h]
  int v55; // [esp+8h] [ebp-40h]
  int *v56; // [esp+8h] [ebp-40h]
  int v57; // [esp+8h] [ebp-40h]
  char v58; // [esp+Ch] [ebp-3Ch]
  int *v59; // [esp+Ch] [ebp-3Ch]
  int *v60; // [esp+Ch] [ebp-3Ch]
  int v61; // [esp+10h] [ebp-38h]
  unsigned int v62; // [esp+14h] [ebp-34h]
  unsigned int v63; // [esp+18h] [ebp-30h]
  int v64; // [esp+18h] [ebp-30h]
  int v65; // [esp+20h] [ebp-28h]
  unsigned int v66; // [esp+20h] [ebp-28h]
  int v67; // [esp+20h] [ebp-28h]
  unsigned int v68; // [esp+24h] [ebp-24h]
  bool v69; // [esp+24h] [ebp-24h]
  unsigned int v70; // [esp+28h] [ebp-20h]

  v2 = a1;
  v52 = &dl_pagesize;
  v3 = dl_pagesize;
  if ( !a2 )
  {
    v17 = -dl_pagesize & (dl_pagesize + a1 + 18);
    if ( a1 >= v17 )
      return 0;
    v47 = -dl_pagesize & (dl_pagesize + a1 + 18);
    v18 = (_DWORD *)mmap(0, v17, 3, 34, -1, 0);
    v19 = v47;
    if ( v18 == (_DWORD *)-1 )
      return 0;
    goto LABEL_29;
  }
  if ( dword_80CE4A8 <= a1 && dword_80CE4B4 < dword_80CE4B8 )
  {
    if ( (-dl_pagesize & (dl_pagesize + a1 + 18)) <= a1
      || (v18 = (_DWORD *)mmap(0, -dl_pagesize & (dl_pagesize + a1 + 18), 3, 34, -1, 0),
          v19 = -v3 & (v3 + v2 + 18),
          v18 == (_DWORD *)-1) )
    {
      v58 = 1;
      goto LABEL_4;
    }
LABEL_29:
    v16 = v18 + 2;
    v20 = ((_BYTE)v18 + 8) & 0xF;
    if ( (((_BYTE)v18 + 8) & 0xF) != 0 )
    {
      v34 = (_DWORD *)((char *)v18 + 16 - v20);
      *v34 = 16 - v20;
      v16 = v34 + 2;
      *(v16 - 1) = (v19 - (16 - v20)) | 2;
    }
    else
    {
      *v18 = 0;
      v18[1] = v19 | 2;
    }
    v21 = _InterlockedIncrement(&dword_80CE4B4);
    do
    {
      v22 = *((_DWORD *)&GLOBAL_OFFSET_TABLE_ + 303);
      if ( v21 <= v22 )
        break;
      v23 = *((_DWORD *)&GLOBAL_OFFSET_TABLE_ + 303);
    }
    while ( v23 != _InterlockedCompareExchange(&dword_80CE4BC, v21, v22) );
    v24 = _InterlockedExchangeAdd(&dword_80CE4C4, v19) + v19;
    do
    {
      v25 = *((_DWORD *)&GLOBAL_OFFSET_TABLE_ + 306);
      if ( v24 <= v25 )
        break;
      v26 = *((_DWORD *)&GLOBAL_OFFSET_TABLE_ + 306);
    }
    while ( v26 != _InterlockedCompareExchange(&dword_80CE4C8, v24, v25) );
    return v16;
  }
  v58 = 0;
LABEL_4:
  v55 = v3;
  v46 = a2 + 14;
  v61 = v3 + v2 + 18;
  while ( 1 )
  {
    v5 = a2[14];
    v6 = *(_DWORD *)(v5 + 4);
    v7 = v6 & 0xFFFFFFF8;
    if ( ((int *)v5 != v46 || v7) && (v7 <= 0xF || (v6 & 1) == 0 || ((v55 - 1) & (v5 + v7)) != 0) )
      _malloc_assert(
        (int)"(old_top == initial_top (av) && old_size == 0) || ((unsigned long) (old_size) >= MINSIZE && prev_inuse (old"
             "_top) && ((unsigned long) old_end & (pagesize - 1)) == 0)",
        (int)"malloc.c",
        2385,
        (int)"sysmalloc");
    v62 = v2 + 16;
    if ( v2 + 16 <= v7 )
      _malloc_assert(
        (int)"(unsigned long) (old_size) < (unsigned long) (nb + MINSIZE)",
        (int)"malloc.c",
        2388,
        (int)"sysmalloc");
    if ( a2 == &main_arena )
      break;
    v63 = v5 & 0xFFF00000;
    if ( (int)(v62 - v7) > 0 )
    {
      v65 = *(_DWORD *)((v5 & 0xFFF00000) + 8);
      v8 = ((v62 - v7 + *v52 - 1) & -*v52) + v65;
      if ( v8 <= 0x100000 )
      {
        v9 = *(_DWORD *)((v5 & 0xFFF00000) + 0xC);
        if ( v8 <= v9 )
        {
          v53 = a2[14];
LABEL_16:
          *(_DWORD *)((v5 & 0xFFF00000) + 8) = v8;
          v10 = *(_DWORD *)((v5 & 0xFFF00000) + 8);
          v11 = (int *)a2[14];
          v12 = v10 + a2[277] - v65;
          a2[277] = v12;
          v46 = (int *)v12;
          *(_DWORD *)(v53 + 4) = (v63 + v10 - v53) | 1;
          goto LABEL_17;
        }
        v68 = *(_DWORD *)(v5 + 4) & 0xFFFFFFF8;
        v70 = ((v62 - v7 + *v52 - 1) & -*v52) + v65;
        v35 = mprotect((const void *)(v63 + v9), v8 - v9, 3);
        v7 = v68;
        if ( !v35 )
        {
          v8 = v70;
          v53 = v5;
          *(_DWORD *)((v5 & 0xFFF00000) + 0xC) = v70;
          goto LABEL_16;
        }
      }
    }
    v66 = v7;
    v28 = new_heap(v2 + 40, dword_80CE4A4);
    if ( v28 )
    {
      v54 = v5;
      v29 = a2[277];
      *(_DWORD *)v28 = a2;
      *((_DWORD *)v28 + 1) = v63;
      v30 = *((_DWORD *)v28 + 2);
      v31 = v30 + v29;
      a2[277] = v31;
      v46 = (int *)v31;
      v11 = (int *)(v28 + 24);
      a2[14] = (int)(v28 + 24);
      *((_DWORD *)v28 + 7) = (v30 - 24) | 1;
      v32 = (v66 - 16) & 0xFFFFFFF0;
      v33 = v32 + 8;
      v56 = (int *)(v32 + 8 + v54);
      v56[1] = 1;
      if ( v32 > 0xF )
      {
        *(_DWORD *)(v54 + v32 + 4) = 9;
        *v56 = 8;
        *(_DWORD *)(v54 + 4) = v32 | 5;
        int_free((int)a2, v54, 1u, v56);
        v11 = (int *)a2[14];
        v46 = (int *)a2[277];
      }
      else
      {
        *(_DWORD *)(v54 + 4) = v33 | 1;
        *v56 = v33;
      }
      goto LABEL_17;
    }
    if ( v58 )
    {
      v11 = (int *)a2[14];
      v46 = (int *)a2[277];
      goto LABEL_17;
    }
    v11 = (int *)(v61 & -v55);
    if ( (unsigned int)v11 > v2 )
      goto LABEL_101;
LABEL_99:
    v58 = 1;
  }
  v52 = (int *)a2[14];
  v59 = (int *)(v5 + v7);
  v36 = v55 - 1;
  v37 = -v55;
  v38 = v2 + dword_80CE4A4 + 16;
  v64 = v55 - 1;
  v67 = -v55;
  if ( (dword_80CE504 & 2) != 0 )
  {
    v55 = v37 & (v36 + v38);
    if ( v55 <= 0 )
      goto LABEL_60;
  }
  else
  {
    v55 = v37 & (v36 + v38 - v7);
    if ( v55 <= 0 )
    {
LABEL_82:
      v55 = v67 & (v55 + v7 + v64);
      goto LABEL_60;
    }
  }
  v48 = v7;
  v11 = (int *)_morecore(v55);
  v7 = v48;
  if ( v11 )
  {
    v69 = 1;
    v61 = 0;
    if ( _after_morecore_hook )
    {
      ((void (*)(void))_after_morecore_hook)();
      v7 = v48;
    }
    goto LABEL_54;
  }
  if ( (dword_80CE504 & 2) == 0 )
    goto LABEL_82;
LABEL_60:
  v39 = 0x100000;
  if ( (unsigned int)v55 >= 0x100000 )
    v39 = v55;
  v55 = v39;
  if ( v2 >= v39 )
    goto LABEL_63;
  v50 = v7;
  v45 = mmap(0, v39, 3, 34, -1, 0);
  v7 = v50;
  v11 = (int *)v45;
  if ( v45 == -1 )
    goto LABEL_63;
  dword_80CE504 |= 2u;
  v61 = v45 + v55;
  if ( !v45 )
    goto LABEL_63;
  v69 = v61 == 0;
LABEL_54:
  if ( !dword_80CE4CC )
    dword_80CE4CC = (int)v11;
  v46 = (int *)(v55 + dword_80CE954);
  dword_80CE954 += v55;
  if ( v59 == v11 && v69 )
  {
    v11 = (int *)dword_80CE538;
    v52[1] = (v7 + v55) | 1;
    goto LABEL_17;
  }
  if ( (dword_80CE504 & 2) == 0 )
  {
    if ( !v7 || v59 <= v11 )
    {
      if ( v7 )
        dword_80CE954 = (int)v46 + (char *)v11 - (char *)v59;
      v40 = ((_BYTE)v11 + 8) & 0xF;
      if ( (((_BYTE)v11 + 8) & 0xF) != 0 )
      {
        v41 = v7 + 16 - v40;
        v60 = (int *)((char *)v11 + 16 - v40);
      }
      else
      {
        v41 = v7;
        v60 = v11;
      }
      v42 = (v67 & ((unsigned int)v11 + v41 + v55 + v64)) - ((_DWORD)v11 + v55);
      if ( v42 < 0 )
        _malloc_assert((int)"correction >= 0", (int)"malloc.c", 2603, (int)"sysmalloc");
      v57 = v42;
      v49 = v7;
      v61 = _morecore(v42);
      v7 = v49;
      v43 = v42;
      if ( v61 )
      {
        if ( _after_morecore_hook )
        {
          ((void (*)(void))_after_morecore_hook)();
          v43 = v42;
          v11 = v60;
          v7 = v49;
          v46 = (int *)(v43 + dword_80CE954);
        }
        else
        {
          v11 = v60;
          v46 = (int *)(v57 + dword_80CE954);
        }
        goto LABEL_78;
      }
      v61 = _morecore(0);
      v11 = v60;
      v7 = v49;
LABEL_90:
      v46 = (int *)dword_80CE954;
      if ( v61 )
      {
        v43 = 0;
        goto LABEL_78;
      }
LABEL_64:
      v11 = (int *)dword_80CE538;
      goto LABEL_17;
    }
    malloc_printerr((unsigned __int8)&aBreakAdjustedT[-135061504] + (unsigned __int8)&GLOBAL_OFFSET_TABLE_);
LABEL_101:
    v18 = (_DWORD *)mmap(0, (size_t)v11, 3, 34, -1, 0);
    if ( v18 != (_DWORD *)-1 )
    {
      v19 = (int)v11;
      goto LABEL_29;
    }
    goto LABEL_99;
  }
  if ( (((_BYTE)v11 + 8) & 0xF) != 0 )
    v11 = (int *)((char *)v11 - (((_BYTE)v11 + 8) & 0xF) + 16);
  v43 = 0;
  if ( !v61 )
  {
    v51 = v7;
    v61 = _morecore(0);
    v7 = v51;
    goto LABEL_90;
  }
LABEL_78:
  dword_80CE538 = (int)v11;
  v11[1] = (v43 + v61 - (_DWORD)v11) | 1;
  dword_80CE954 = (int)v46;
  if ( v7 )
  {
    v44 = (v7 - 16) & 0xFFFFFFF0;
    v52[1] = v44 | 1;
    *(int *)((char *)v52 + v44 + 4) = 9;
    *(int *)((char *)v52 + v44 + 12) = 9;
    if ( v44 > 0xF )
    {
      int_free((int)&main_arena, (unsigned int)v52, 1u, v11);
LABEL_63:
      v46 = (int *)dword_80CE954;
      goto LABEL_64;
    }
  }
LABEL_17:
  if ( (unsigned int)v46 > a2[278] )
    a2[278] = (int)v46;
  v13 = v11[1] & 0xFFFFFFF8;
  if ( v62 > v13 )
  {
    __writegsdword(0xFFFFFFE0, 0xCu);
    return 0;
  }
  v14 = v13 - v2;
  v15 = (char *)v11 + v2;
  a2[14] = (int)v11 + v2;
  if ( a2 != &main_arena )
    v2 |= 4u;
  v16 = v11 + 2;
  *(v16 - 1) = v2 | 1;
  *((_DWORD *)v15 + 1) = v14 | 1;
  return v16;
}
// 80CE000: using guessed type _TBYTE GLOBAL_OFFSET_TABLE_;
// 80CE4A4: using guessed type int dword_80CE4A4;
// 80CE4A8: using guessed type int dword_80CE4A8;
// 80CE4B4: using guessed type int dword_80CE4B4;
// 80CE4B8: using guessed type int dword_80CE4B8;
// 80CE4BC: using guessed type int dword_80CE4BC;
// 80CE4C4: using guessed type int dword_80CE4C4;
// 80CE4C8: using guessed type int dword_80CE4C8;
// 80CE4CC: using guessed type int dword_80CE4CC;
// 80CE500: using guessed type int main_arena;
// 80CE504: using guessed type int dword_80CE504;
// 80CE538: using guessed type int dword_80CE538;
// 80CE954: using guessed type int dword_80CE954;
// 80CE95C: using guessed type int (__cdecl *_morecore)(int);
// 80CE9B0: using guessed type int dl_pagesize;
// 80CF868: using guessed type int _after_morecore_hook;

//----- (0805B4F0) --------------------------------------------------------
int *__usercall int_malloc@<eax>(unsigned int a1@<eax>, unsigned int a2@<edx>, _DWORD *i@<edi>)
{
  unsigned int v3; // esi
  bool v4; // cl
  unsigned int v5; // edx
  unsigned int v6; // ebx
  _DWORD *v7; // ecx
  unsigned int v9; // edi
  unsigned int v10; // esi
  int v11; // edx
  unsigned int v12; // ebx
  int v13; // eax
  _DWORD *v14; // edx
  _DWORD *v17; // eax
  int *v18; // esi
  int v19; // eax
  int v21; // eax
  int v22; // eax
  unsigned int v23; // ebx
  unsigned int v24; // edi
  unsigned int v25; // eax
  unsigned int v26; // ebx
  unsigned int v27; // edx
  unsigned int v28; // eax
  int v29; // ecx
  unsigned int *v30; // eax
  char *v31; // eax
  unsigned int v33; // edx
  _DWORD *v34; // ecx
  int v35; // eax
  unsigned int v36; // ebx
  char *v37; // eax
  int v38; // eax
  unsigned int v39; // edx
  int *v40; // edx
  unsigned int v41; // edx
  _DWORD *v42; // edx
  unsigned int v43; // eax
  int v44; // eax
  int v45; // ecx
  int v46; // eax
  int v47; // edx
  unsigned int v48; // eax
  unsigned int v49; // edi
  unsigned int v50; // ebx
  char v51; // al
  int v52; // edx
  _DWORD *v53; // ebx
  unsigned int v54; // ecx
  int v55; // ebx
  unsigned int v56; // eax
  int v57; // eax
  char *v58; // ecx
  unsigned int v59; // ecx
  _DWORD *v60; // eax
  unsigned int v61; // eax
  int v62; // eax
  char *v63; // eax
  int v64; // edx
  unsigned int v65; // edi
  _DWORD *v66; // edx
  int v67; // eax
  char *v68; // eax
  char *v69; // edx
  int v70; // eax
  int v71; // edi
  unsigned int v72; // ecx
  _DWORD *v73; // edx
  int v74; // eax
  int v75; // ecx
  unsigned int v76; // ecx
  _DWORD *v77; // edx
  int v78; // eax
  int v79; // eax
  int v80; // eax
  unsigned int v81; // [esp+0h] [ebp-98h]
  unsigned int v82; // [esp+0h] [ebp-98h]
  _DWORD *v83; // [esp+4h] [ebp-94h]
  unsigned int v85; // [esp+Ch] [ebp-8Ch]
  _TBYTE *v86; // [esp+10h] [ebp-88h]
  unsigned int v87; // [esp+10h] [ebp-88h]
  unsigned int v88; // [esp+14h] [ebp-84h]
  unsigned int v89; // [esp+14h] [ebp-84h]
  unsigned int v90; // [esp+18h] [ebp-80h]
  _DWORD *v91; // [esp+1Ch] [ebp-7Ch]
  int v92; // [esp+20h] [ebp-78h]
  int v93; // [esp+24h] [ebp-74h]
  int v94; // [esp+24h] [ebp-74h]
  int v95; // [esp+28h] [ebp-70h]
  int v96; // [esp+2Ch] [ebp-6Ch]
  unsigned int v97; // [esp+30h] [ebp-68h]
  int v98; // [esp+34h] [ebp-64h]
  unsigned int *v99; // [esp+38h] [ebp-60h]
  unsigned int *v100; // [esp+38h] [ebp-60h]
  int v101; // [esp+3Ch] [ebp-5Ch]
  int v102; // [esp+40h] [ebp-58h]
  unsigned int v103; // [esp+44h] [ebp-54h]
  unsigned int v104; // [esp+48h] [ebp-50h]
  char *v105; // [esp+4Ch] [ebp-4Ch]
  int v106; // [esp+50h] [ebp-48h]
  bool v107; // [esp+57h] [ebp-41h]
  unsigned int v108; // [esp+58h] [ebp-40h]
  unsigned int v109; // [esp+5Ch] [ebp-3Ch]
  int v110; // [esp+60h] [ebp-38h]
  int v111; // [esp+64h] [ebp-34h]
  int v112; // [esp+68h] [ebp-30h]
  unsigned int v113; // [esp+6Ch] [ebp-2Ch]
  unsigned int v114; // [esp+70h] [ebp-28h]
  unsigned int v115; // [esp+74h] [ebp-24h]
  unsigned int v116; // [esp+78h] [ebp-20h]

  if ( a2 + 19 <= 0xF )
  {
    v4 = 0;
    v3 = 16;
  }
  else
  {
    v3 = (a2 + 19) & 0xFFFFFFF0;
    v4 = v3 > 0xFFFFFFDF;
  }
  if ( v3 < a2 || v4 )
  {
    __writegsdword(0xFFFFFFE0, 0xCu);
    return 0;
  }
  v81 = a1;
  if ( !a1 )
  {
LABEL_90:
    v40 = 0;
    goto LABEL_91;
  }
  if ( v3 > *((_DWORD *)&GLOBAL_OFFSET_TABLE_ + 1572) )
  {
    if ( v3 > 0x3EF )
    {
      v113 = v3 >> 6;
      v98 = (v3 >> 6) + 49;
      v102 = (v3 >> 9) + 91;
      v106 = (v3 >> 12) + 110;
      v109 = v3 >> 15;
      v111 = (v3 >> 15) + 119;
      v21 = v3 >> 18;
      if ( v3 >> 18 > 2 )
        v21 = 2;
      v114 = v3 >> 9;
      v115 = v3 >> 12;
      v22 = v21 + 124;
      v96 = (v3 >> 6) + 49;
      v110 = v22;
      if ( v3 >> 6 > 0x2D )
      {
        v96 = (v3 >> 9) + 91;
        if ( v3 >> 9 > 0x14 )
        {
          v96 = (v3 >> 12) + 110;
          if ( v3 >> 12 > 0xA )
          {
            if ( v109 < 5 )
              v22 = (v3 >> 15) + 119;
            v96 = v22;
          }
        }
      }
      v112 = (v3 >> 4) + 1;
      if ( *(_DWORD *)(v81 + 8) )
        malloc_consolidate(v81);
      goto LABEL_35;
    }
  }
  else
  {
    v5 = v3 >> 3;
    v6 = a1 + 4 * (v3 >> 3);
    v7 = *(_DWORD **)(v6 + 4);
    v83 = v7;
    if ( v7 )
    {
      v85 = a1 + 4 * v5 + 4;
      _ECX = v7[2];
      if ( __readgsdword(0xCu) )
      {
        v86 = (_TBYTE *)(v3 >> 3);
        i = v83;
        _EDX = a1 + 4 * v5 + 4;
        if ( __readgsdword(0xCu) )
          __asm { lock }
        __asm { cmpxchg [edx], ecx }
        v5 = v3 >> 3;
      }
      else
      {
        *(_DWORD *)(v6 + 4) = _ECX;
      }
      v81 = v83[1];
      if ( v5 != v81 >> 3 )
        goto LABEL_145;
      v9 = __readgsdword(0xFFFFFFE4);
      if ( v9 )
      {
        v10 = (v3 - 1) >> 4;
        if ( *((_DWORD *)&GLOBAL_OFFSET_TABLE_ + 308) > v10
          && (unsigned int)*(char *)(v9 + v10) < *((_DWORD *)&GLOBAL_OFFSET_TABLE_ + 310) )
        {
          v11 = *(_DWORD *)(v6 + 4);
          if ( v11 )
          {
            v82 = v6;
            v12 = v9 + 4 * v10;
            do
            {
              _ECX = *(_DWORD *)(v11 + 8);
              if ( __readgsdword(0xCu) )
              {
                v87 = v10;
                _ESI = v85;
                if ( __readgsdword(0xCu) )
                  __asm { lock }
                __asm { cmpxchg [esi], ecx }
                v10 = v87;
              }
              else
              {
                *(_DWORD *)(v82 + 4) = _ECX;
              }
              v13 = *(_DWORD *)(v12 + 64);
              *(_DWORD *)(v11 + 12) = v9;
              v14 = (_DWORD *)(v11 + 8);
              *v14 = v13;
              *(_DWORD *)(v12 + 64) = v14;
              LOBYTE(v13) = *(_BYTE *)(v9 + v10) + 1;
              *(_BYTE *)(v9 + v10) = v13;
              if ( (unsigned int)(char)v13 >= *((_DWORD *)&GLOBAL_OFFSET_TABLE_ + 310) )
                break;
              v11 = *(_DWORD *)(v82 + 4);
            }
            while ( v11 );
          }
        }
      }
      v17 = v83;
LABEL_24:
      v18 = v17 + 2;
      v19 = *((_DWORD *)&GLOBAL_OFFSET_TABLE_ + 1571);
      if ( v19 )
        goto LABEL_85;
      return v18;
    }
  }
  v33 = a1 + 8 * (v3 >> 4) + 64;
  i = *(_DWORD **)(a1 + 8 * (v3 >> 4) + 68);
  v34 = (_DWORD *)(a1 + 8 * (v3 >> 4) + 56);
  if ( v34 != i )
  {
    v35 = i[3];
    if ( *(_DWORD **)(v35 + 8) != i )
    {
      malloc_printerr((unsigned __int8)&GLOBAL_OFFSET_TABLE_ - 120);
LABEL_150:
      _malloc_assert(
        (int)(&GLOBAL_OFFSET_TABLE_ - 17761),
        (int)&GLOBAL_OFFSET_TABLE_ - 177883,
        3846,
        (int)&GLOBAL_OFFSET_TABLE_ - 173652);
    }
    *(_DWORD *)((char *)i + v3 + 4) |= 1u;
    *(_DWORD *)(v33 + 4) = v35;
    *(_DWORD *)(v35 + 8) = v34;
    v86 = &GLOBAL_OFFSET_TABLE_ + 128;
    if ( (_TBYTE *)v81 != &GLOBAL_OFFSET_TABLE_ + 128 )
      i[1] |= 4u;
    v83 = (_DWORD *)__readgsdword(0xFFFFFFE4);
    if ( v83 )
    {
      v36 = (v3 - 1) >> 4;
      v90 = v36;
      if ( *((_DWORD *)&GLOBAL_OFFSET_TABLE_ + 308) > v36 )
      {
        v92 = v3;
        v89 = *((_DWORD *)&GLOBAL_OFFSET_TABLE_ + 310);
        LOBYTE(v85) = *((_BYTE *)v83 + v36);
        v91 = &v83[v36];
        goto LABEL_71;
      }
    }
    goto LABEL_75;
  }
  v96 = (v3 >> 4) + 1;
  v114 = v3 >> 9;
  v102 = (v3 >> 9) + 91;
  v106 = (v3 >> 12) + 110;
  v111 = (v3 >> 15) + 119;
  v113 = v3 >> 6;
  v38 = v3 >> 18;
  v98 = (v3 >> 6) + 49;
  if ( v3 >> 18 > 2 )
    v38 = 2;
  v115 = v3 >> 12;
  v109 = v3 >> 15;
  v110 = v38 + 124;
  v112 = (v3 >> 4) + 1;
LABEL_35:
  v23 = 0;
  v108 = v3 - 1;
  v88 = (v3 - 1) >> 4;
  v24 = __readgsdword(0xFFFFFFE4);
  v97 = 0;
  if ( v24 )
  {
    if ( *((_DWORD *)&GLOBAL_OFFSET_TABLE_ + 308) > (v3 - 1) >> 4 )
      v23 = v3;
    v97 = v23;
  }
  v91 = 0;
  v93 = 1184;
  v86 = (_TBYTE *)v24;
  v83 = (_DWORD *)(v81 + 56);
  v95 = 4 * v88;
  v85 = v3;
  v3 = v81;
  while ( 2 )
  {
    i = *(_DWORD **)(v3 + 68);
    v90 = 0;
    v101 = 0;
    v104 = *(_DWORD *)((char *)&GLOBAL_OFFSET_TABLE_ + v93 + 60);
    v107 = v104 != 0;
    v103 = *(_DWORD *)((char *)&GLOBAL_OFFSET_TABLE_ + v93 + 56);
    v105 = (char *)v86 + v95;
    while ( i != v83 )
    {
      v25 = i[1] & 0xFFFFFFF8;
      v99 = (_DWORD *)((char *)i + v25);
      if ( v25 <= 8 || (v26 = *(_DWORD *)(v3 + 1108), v26 < v25) )
      {
        malloc_printerr((unsigned __int8)&GLOBAL_OFFSET_TABLE_ - 72);
        goto LABEL_90;
      }
      v27 = *(_DWORD *)((char *)i + v25 + 4);
      if ( v27 <= 7 || v26 < v27 )
      {
        v25 = (unsigned int)malloc_printerr((unsigned __int8)&GLOBAL_OFFSET_TABLE_ - 36);
        goto LABEL_95;
      }
      if ( (*(_DWORD *)((char *)i + v25) & 0xFFFFFFF8) != v25 )
      {
        v37 = malloc_printerr((unsigned __int8)&GLOBAL_OFFSET_TABLE_ + 4);
LABEL_140:
        v89 = v3;
        v94 = *((_DWORD *)v37 + 3);
        *(_DWORD *)&v37[v92 + 4] |= 1u;
        if ( (_TBYTE *)v81 != v86 )
          *((_DWORD *)v37 + 1) |= 4u;
        v60 = v37 + 8;
        LOBYTE(v85) = v85 + 1;
        *(_DWORD *)(v33 + 4) = v94;
        *(_DWORD *)(v94 + 8) = v34;
        v60[1] = v83;
        *v60 = v91[16];
        v91[16] = v60;
        *((_BYTE *)v83 + v90) = v85;
LABEL_71:
        v3 = v89;
        while ( (char)v85 < v89 )
        {
          v37 = *(char **)(v33 + 4);
          if ( v34 == (_DWORD *)v37 )
            break;
          if ( v37 )
            goto LABEL_140;
        }
LABEL_75:
        v18 = i + 2;
        v19 = *((_DWORD *)&GLOBAL_OFFSET_TABLE_ + 1571);
        if ( v19 )
          goto LABEL_85;
        return i + 2;
      }
      v92 = i[3];
      if ( *(_DWORD **)(v92 + 8) != i || (v6 = (unsigned int)v83, (_DWORD *)i[2] != v83) )
      {
        v25 = (unsigned int)malloc_printerr((unsigned __int8)&GLOBAL_OFFSET_TABLE_ + 56);
LABEL_113:
        v92 = v41 + 49;
        goto LABEL_98;
      }
      if ( (v27 & 1) != 0 )
      {
        malloc_printerr((unsigned __int8)&GLOBAL_OFFSET_TABLE_ + 104);
LABEL_145:
        malloc_printerr((unsigned __int8)&GLOBAL_OFFSET_TABLE_ + 100);
LABEL_146:
        i[5] = i;
        LOBYTE(v29) = v92;
        i[4] = i;
        v100 = (unsigned int *)v6;
        goto LABEL_55;
      }
      if ( v85 <= 0x3EF && (_DWORD *)v92 == v83 && *(_DWORD **)(v3 + 60) == i && v85 + 16 < v25 )
      {
        v17 = i;
        v53 = (_DWORD *)((char *)i + v85);
        v54 = (i[1] & 0xFFFFFFF8) - v85;
        *(_DWORD *)(v81 + 64) = (char *)i + v85;
        *(_DWORD *)(v81 + 68) = (char *)i + v85;
        *(_DWORD *)(v81 + 60) = (char *)i + v85;
        v53[2] = v83;
        v53[3] = v83;
        if ( v54 > 0x3EF )
        {
          v53[4] = 0;
          v53[5] = 0;
        }
        i[1] = v85 | (4 * (v81 != (_DWORD)(&GLOBAL_OFFSET_TABLE_ + 128))) | 1;
        v53[1] = v54 | 1;
        *v99 = v54;
        goto LABEL_24;
      }
      *(_DWORD *)(v3 + 68) = v92;
      *(_DWORD *)(v92 + 8) = v83;
      if ( v85 == v25 )
      {
        v99[1] = v27 | 1;
        if ( (_TBYTE *)v3 != &GLOBAL_OFFSET_TABLE_ + 128 )
          i[1] |= 4u;
        if ( !v97 || (v39 = *((char *)v86 + v88), v39 >= v103) )
        {
          v19 = *((_DWORD *)&GLOBAL_OFFSET_TABLE_ + 1571);
          v18 = i + 2;
          if ( v19 )
            goto LABEL_85;
          return v18;
        }
        if ( v108 > 0x3FF )
          _malloc_assert(
            (int)&GLOBAL_OFFSET_TABLE_ - 177699,
            (int)&GLOBAL_OFFSET_TABLE_ - 177883,
            2926,
            (int)&GLOBAL_OFFSET_TABLE_ - 173664);
        v51 = v39 + 1;
        v101 = 1;
        v52 = *((_DWORD *)v105 + 16);
        i[3] = v86;
        i[2] = v52;
        *((_DWORD *)v105 + 16) = i + 2;
        *((_BYTE *)v86 + v88) = v51;
        i = (_DWORD *)v92;
      }
      else
      {
        if ( v25 <= 0x3EF )
        {
          v28 = v25 >> 4;
          v29 = v28 + 1;
          v30 = (unsigned int *)(v3 + 8 * v28 + 64);
          v92 = v29;
          v100 = v30 - 2;
          v6 = *v30;
          goto LABEL_55;
        }
LABEL_95:
        v41 = v25 >> 6;
        if ( v25 >> 6 <= 0x2D )
          goto LABEL_113;
        if ( v25 >> 9 > 0x14 )
        {
          if ( v25 >> 12 > 0xA )
          {
            if ( v25 >> 15 > 4 )
            {
              v64 = v25 >> 18;
              if ( v25 >> 18 > 2 )
                v64 = 2;
              v92 = v64 + 124;
            }
            else
            {
              v92 = (v25 >> 15) + 119;
            }
          }
          else
          {
            v92 = (v25 >> 12) + 110;
          }
        }
        else
        {
          v92 = (v25 >> 9) + 91;
        }
LABEL_98:
        v42 = *(_DWORD **)(v3 + 8 * v92 + 56);
        v6 = v3 + 8 * v92 + 48;
        if ( (_DWORD *)v6 == v42 )
          goto LABEL_146;
        v116 = v25 | 1;
        v100 = *(unsigned int **)(v3 + 8 * v92 + 60);
        v43 = v100[1];
        if ( (v43 & 4) != 0 )
          goto LABEL_150;
        if ( v43 <= v116 )
        {
          v61 = v42[1];
          if ( (v61 & 4) != 0 )
            _malloc_assert(
              (int)&GLOBAL_OFFSET_TABLE_ - 177583,
              (int)&GLOBAL_OFFSET_TABLE_ - 177883,
              3859,
              (int)&GLOBAL_OFFSET_TABLE_ - 173652);
          while ( v116 < v61 )
          {
            v42 = (_DWORD *)v42[4];
            v61 = v42[1];
            if ( (v61 & 4) != 0 )
              _malloc_assert(
                (int)&GLOBAL_OFFSET_TABLE_ - 177583,
                (int)&GLOBAL_OFFSET_TABLE_ - 177883,
                3863,
                (int)&GLOBAL_OFFSET_TABLE_ - 173652);
          }
          if ( v116 == v61 )
          {
            v6 = v42[2];
          }
          else
          {
            v62 = v42[5];
            i[4] = v42;
            i[5] = v62;
            if ( *(_DWORD **)(v42[5] + 16) != v42 )
            {
              malloc_printerr((unsigned __int8)&GLOBAL_OFFSET_TABLE_ - 104);
LABEL_190:
              malloc_printerr((unsigned __int8)&GLOBAL_OFFSET_TABLE_ - 115);
              goto LABEL_191;
            }
            v42[5] = i;
            v6 = (unsigned int)v42;
            *(_DWORD *)(i[5] + 16) = i;
          }
          v100 = *(unsigned int **)(v6 + 12);
          if ( v100[2] != v6 )
          {
            malloc_printerr((unsigned __int8)&GLOBAL_OFFSET_TABLE_ - 44);
            goto LABEL_231;
          }
          LOBYTE(v29) = v92;
        }
        else
        {
          v44 = v42[5];
          LOBYTE(v29) = v92;
          i[4] = v42;
          i[5] = v44;
          *(_DWORD *)(v44 + 16) = i;
          v42[5] = i;
        }
LABEL_55:
        v91 = (_DWORD *)((char *)v91 + 1);
        *(_DWORD *)(v3 + 4 * (v92 >> 5) + 1080) |= 1 << v29;
        i[2] = v6;
        i[3] = v100;
        *(_DWORD *)(v6 + 12) = i;
        v100[2] = (unsigned int)i;
        if ( v101 )
        {
          if ( v104 < (unsigned int)v91 && v107 )
          {
            v31 = (char *)v86 + 4 * v88;
            v18 = (int *)*((_DWORD *)v31 + 16);
            if ( v108 <= 0x3FF )
            {
              if ( v18 )
              {
                *((_DWORD *)v31 + 16) = *v18;
                --*((_BYTE *)v86 + v88);
                v18[1] = 0;
                return v18;
              }
              goto LABEL_196;
            }
            goto LABEL_195;
          }
          if ( (int)++v90 > 9999 )
            goto LABEL_162;
        }
        else if ( (int)++v90 > 9999 )
        {
          goto LABEL_103;
        }
        i = *(_DWORD **)(v3 + 68);
      }
    }
    if ( v101 )
    {
LABEL_162:
      v63 = (char *)v86 + 4 * v88;
      v18 = (int *)*((_DWORD *)v63 + 16);
      if ( v108 <= 0x3FF )
      {
        if ( v18 )
        {
          *((_DWORD *)v63 + 16) = *v18;
          --*((_BYTE *)v86 + v88);
          v18[1] = 0;
          return v18;
        }
LABEL_196:
        _malloc_assert(
          (int)(&GLOBAL_OFFSET_TABLE_ - 17756),
          (int)&GLOBAL_OFFSET_TABLE_ - 177883,
          2944,
          (int)&GLOBAL_OFFSET_TABLE_ - 173676);
      }
LABEL_195:
      _malloc_assert(
        (int)&GLOBAL_OFFSET_TABLE_ - 177699,
        (int)&GLOBAL_OFFSET_TABLE_ - 177883,
        2943,
        (int)&GLOBAL_OFFSET_TABLE_ - 173676);
    }
LABEL_103:
    if ( v85 > 0x3EF )
    {
      v45 = v3 + 8 * v96 + 56;
      v46 = *(_DWORD *)v45;
      if ( *(_DWORD *)v45 != v3 + 8 * v96 + 48 && *(_DWORD *)(v46 + 4) >= v85 )
      {
        v3 = v85;
        for ( i = *(_DWORD **)(v46 + 20); ; i = (_DWORD *)i[5] )
        {
          v6 = i[1] & 0xFFFFFFF8;
          if ( v85 <= v6 )
            break;
        }
        v85 = i[1] & 0xFFFFFFF8;
        if ( *(_DWORD **)(v45 + 4) != i && i[1] == *(_DWORD *)(i[2] + 4) )
          i = (_DWORD *)i[2];
        v72 = i[1];
        if ( (v72 & 0xFFFFFFF8) != *(_DWORD *)((char *)i + (v72 & 0xFFFFFFF8)) )
          goto LABEL_194;
        v73 = (_DWORD *)i[2];
        v74 = i[3];
        if ( (_DWORD *)v73[3] == i && *(_DWORD **)(v74 + 8) == i )
        {
          v73[3] = v74;
          *(_DWORD *)(v74 + 8) = v73;
          if ( v72 > 0x3EF )
          {
            v75 = i[4];
            if ( v75 )
            {
LABEL_231:
              if ( *(_DWORD **)(v75 + 20) != i || (v80 = i[5], *(_DWORD **)(v80 + 16) != i) )
              {
LABEL_228:
                malloc_printerr((unsigned __int8)&GLOBAL_OFFSET_TABLE_ + 0x80);
LABEL_229:
                v66[5] = v66;
                v66[4] = v66;
                goto LABEL_179;
              }
              if ( v73[4] )
              {
                *(_DWORD *)(v75 + 20) = v80;
                *(_DWORD *)(i[5] + 16) = v75;
              }
              else if ( (_DWORD *)v75 == i )
              {
                v73[5] = v73;
                v73[4] = v73;
              }
              else
              {
                v73[5] = v80;
                v73[4] = v75;
                *(_DWORD *)(i[4] + 20) = v73;
                *(_DWORD *)(i[5] + 16) = v73;
              }
            }
          }
          v76 = v85 - v3;
          if ( v85 - v3 > 0xF )
          {
            v77 = (_DWORD *)((char *)i + v3);
            v78 = *(_DWORD *)(v81 + 64);
            if ( *(_DWORD **)(v78 + 12) == v83 )
            {
              v77[2] = v78;
              v77[3] = v83;
              *(_DWORD *)(v81 + 64) = v77;
              *(_DWORD *)(v78 + 12) = v77;
              if ( v76 > 0x3EF )
              {
                v77[4] = 0;
                v77[5] = 0;
              }
              i[1] = v3 | (4 * (v81 != (_DWORD)(&GLOBAL_OFFSET_TABLE_ + 128))) | 1;
              v77[1] = v76 | 1;
              *(_DWORD *)((char *)i + v85) = v76;
              goto LABEL_75;
            }
            malloc_printerr((unsigned __int8)&GLOBAL_OFFSET_TABLE_ + 12);
          }
          *(_DWORD *)((char *)i + v85 + 4) |= 1u;
          if ( (_TBYTE *)v81 != &GLOBAL_OFFSET_TABLE_ + 128 )
            i[1] |= 4u;
          goto LABEL_75;
        }
        goto LABEL_193;
      }
    }
    v47 = v3 + 8 * v96 + 56;
    v48 = 1 << (v96 + 1);
    v49 = (unsigned int)(v96 + 1) >> 5;
    v50 = *(_DWORD *)(v3 + 4 * v49 + 1080);
LABEL_107:
    if ( v48 > v50 || !v48 )
    {
      while ( ++v49 != 4 )
      {
        v50 = *(_DWORD *)(v3 + 4 * v49 + 1080);
        if ( v50 )
        {
          v47 = v3 + (v49 << 8) + 48;
          v48 = 1;
          goto LABEL_109;
        }
      }
      v55 = *(_DWORD *)(v3 + 56);
      v56 = *(_DWORD *)(v55 + 4) & 0xFFFFFFF8;
      if ( *(_DWORD *)(v3 + 1108) < v56 )
        goto LABEL_190;
      if ( v85 + 16 <= v56 )
      {
        *(_DWORD *)(v81 + 56) = v55 + v85;
        if ( (_TBYTE *)v81 == &GLOBAL_OFFSET_TABLE_ + 128 )
          v49 = 0;
        *(_DWORD *)(v55 + 4) = v49 | v85 | 1;
        *(_DWORD *)(v55 + v85 + 4) = (v56 - v85) | 1;
        v18 = (int *)(v55 + 8);
        v19 = *((_DWORD *)&GLOBAL_OFFSET_TABLE_ + 1571);
        if ( v19 )
          goto LABEL_85;
        return v18;
      }
      if ( *(_DWORD *)(v3 + 8) )
      {
        malloc_consolidate(v3);
        v96 = v112;
        if ( v85 > 0x3EF )
        {
          v96 = v98;
          if ( v113 > 0x2D )
          {
            v96 = v102;
            if ( v114 > 0x14 )
            {
              v96 = v106;
              if ( v115 > 0xA )
              {
                v57 = v111;
                if ( v109 > 4 )
                  v57 = v110;
                v96 = v57;
              }
            }
          }
        }
        v86 = (_TBYTE *)__readgsdword(0xFFFFFFE4);
        continue;
      }
      v3 = v85;
      v40 = (int *)v81;
LABEL_91:
      v18 = sysmalloc(v3, v40);
      if ( !v18 )
        return 0;
      v19 = *((_DWORD *)&GLOBAL_OFFSET_TABLE_ + 1571);
      if ( v19 )
        goto LABEL_85;
      return v18;
    }
    break;
  }
LABEL_109:
  while ( (v50 & v48) == 0 )
  {
    v47 += 8;
    v48 *= 2;
    if ( !v48 )
      _malloc_assert(
        (int)&GLOBAL_OFFSET_TABLE_ - 177532,
        (int)&GLOBAL_OFFSET_TABLE_ - 177883,
        4024,
        (int)&GLOBAL_OFFSET_TABLE_ - 173652);
  }
  v58 = *(char **)(v47 + 12);
  if ( (char *)v47 == v58 )
  {
    v59 = v48;
    v47 += 8;
    v48 *= 2;
    v50 &= ~v59;
    *(_DWORD *)(v3 + 4 * v49 + 1080) = v50;
    goto LABEL_107;
  }
  v3 = v85;
  v65 = *((_DWORD *)v58 + 1);
  v6 = v65 & 0xFFFFFFF8;
  if ( v85 > (v65 & 0xFFFFFFF8) )
    _malloc_assert(
      (int)(&GLOBAL_OFFSET_TABLE_ - 17480),
      (int)&GLOBAL_OFFSET_TABLE_ - 177883,
      4043,
      (int)&GLOBAL_OFFSET_TABLE_ - 173652);
  v85 = (unsigned int)&v58[v6];
  if ( *(_DWORD *)&v58[v6] != v6 )
  {
LABEL_194:
    malloc_printerr((unsigned __int8)&GLOBAL_OFFSET_TABLE_ - 21);
    goto LABEL_195;
  }
  v66 = (_DWORD *)*((_DWORD *)v58 + 2);
  v67 = *((_DWORD *)v58 + 3);
  if ( (char *)v66[3] != v58 || *(char **)(v67 + 8) != v58 )
  {
LABEL_193:
    malloc_printerr((unsigned __int8)&GLOBAL_OFFSET_TABLE_ + 8);
    goto LABEL_194;
  }
  v66[3] = v67;
  *(_DWORD *)(v67 + 8) = v66;
  if ( v65 > 0x3EF )
  {
    v68 = (char *)*((_DWORD *)v58 + 4);
    if ( v68 )
      goto LABEL_203;
  }
LABEL_179:
  while ( 1 )
  {
    v6 -= v3;
    if ( v6 <= 0xF )
      break;
    v69 = &v58[v3];
    v70 = *(_DWORD *)(v81 + 64);
    if ( *(_DWORD **)(v70 + 12) == v83 )
    {
      *((_DWORD *)v69 + 2) = v70;
      *((_DWORD *)v69 + 3) = v83;
      *(_DWORD *)(v81 + 64) = v69;
      *(_DWORD *)(v70 + 12) = v69;
      if ( v3 <= 0x3EF )
        *(_DWORD *)(v81 + 60) = v69;
      if ( v6 > 0x3EF )
      {
        *((_DWORD *)v69 + 4) = 0;
        *((_DWORD *)v69 + 5) = 0;
      }
      *((_DWORD *)v58 + 1) = v3 | (4 * (v81 != (_DWORD)(&GLOBAL_OFFSET_TABLE_ + 128))) | 1;
      *((_DWORD *)v69 + 1) = v6 | 1;
      *(_DWORD *)v85 = v6;
      goto LABEL_186;
    }
    v68 = malloc_printerr((unsigned __int8)&GLOBAL_OFFSET_TABLE_ + 96);
LABEL_203:
    if ( *((char **)v68 + 5) != v58 )
      goto LABEL_228;
    v71 = *((_DWORD *)v58 + 5);
    if ( *(char **)(v71 + 16) != v58 )
      goto LABEL_228;
    if ( v66[4] )
    {
      *((_DWORD *)v68 + 5) = v71;
      *(_DWORD *)(*((_DWORD *)v58 + 5) + 16) = v68;
    }
    else
    {
      if ( v68 == v58 )
        goto LABEL_229;
      v66[4] = v68;
      v79 = *((_DWORD *)v58 + 4);
      v66[5] = v71;
      *(_DWORD *)(v79 + 20) = v66;
      *(_DWORD *)(*((_DWORD *)v58 + 5) + 16) = v66;
    }
  }
LABEL_191:
  *(_DWORD *)(v85 + 4) |= 1u;
  if ( (_TBYTE *)v81 != &GLOBAL_OFFSET_TABLE_ + 128 )
    *((_DWORD *)v58 + 1) |= 4u;
LABEL_186:
  v18 = (int *)(v58 + 8);
  v19 = *((_DWORD *)&GLOBAL_OFFSET_TABLE_ + 1571);
  if ( v19 )
LABEL_85:
    memset((unsigned __int8 *)v18, ~(_BYTE)v19, a2);
  return v18;
}
// 805B7B8: variable 'v93' is possibly undefined
// 805B7D7: variable 'v95' is possibly undefined
// 805B8B1: variable 'v91' is possibly undefined
// 805B8B8: variable 'v92' is possibly undefined
// 805B8DC: variable 'v101' is possibly undefined
// 805B8E6: variable 'v104' is possibly undefined
// 805B8F1: variable 'v107' is possibly undefined
// 805B907: variable 'v86' is possibly undefined
// 805B907: variable 'v88' is possibly undefined
// 805B90D: variable 'v108' is possibly undefined
// 805BA10: variable 'v33' is possibly undefined
// 805BA15: variable 'v34' is possibly undefined
// 805BAF1: variable 'v97' is possibly undefined
// 805BB05: variable 'v103' is possibly undefined
// 805BB40: variable 'v90' is possibly undefined
// 805BC70: variable 'v96' is possibly undefined
// 805BD03: variable 'v41' is possibly undefined
// 805BD31: variable 'v105' is possibly undefined
// 805BE51: variable 'v112' is possibly undefined
// 805BE60: variable 'v98' is possibly undefined
// 805BE64: variable 'v113' is possibly undefined
// 805BE6F: variable 'v102' is possibly undefined
// 805BE73: variable 'v114' is possibly undefined
// 805BE7E: variable 'v106' is possibly undefined
// 805BE82: variable 'v115' is possibly undefined
// 805BE89: variable 'v111' is possibly undefined
// 805BE8D: variable 'v109' is possibly undefined
// 805BE8D: variable 'v110' is possibly undefined
// 805C1BA: variable 'v58' is possibly undefined
// 805C362: variable 'v66' is possibly undefined
// 805C4C4: variable 'v75' is possibly undefined
// 805C4D1: variable 'v73' is possibly undefined
// 80CE000: using guessed type _TBYTE GLOBAL_OFFSET_TABLE_;

//----- (0805C510) --------------------------------------------------------
int __usercall malloc_check@<eax>(int a1@<ebp>, int *a2@<edi>, const struct timespec *a3)
{
  bool v5; // zf
  int *v6; // ecx

  _EBX = &GLOBAL_OFFSET_TABLE_;
  if ( a3 == (const struct timespec *)-1 )
  {
    __writegsdword(0xFFFFFFE0, 0xCu);
    return 0;
  }
  else
  {
    _ECX = 1;
    v5 = __readgsdword(0xCu) == 0;
    if ( !v5 )
      __asm { lock }
    __asm { cmpxchg (main_arena - 80CE000h)[ebx], ecx }
    if ( !v5 )
      _lll_lock_wait_private(0, &main_arena, a1, a2);
    top_check();
    v6 = int_malloc((unsigned int)&main_arena, (unsigned int)&a3->tv_sec + 1, a2);
    if ( __readgsdword(0xCu) )
      __asm { lock }
    if ( --main_arena )
      _lll_unlock_wake_private(&main_arena, a1, a2, a3);
    return mem2mem_check((int)v6, (unsigned int)a3);
  }
}
// 805C590: variable 'v6' is possibly undefined
// 80CE000: using guessed type _TBYTE GLOBAL_OFFSET_TABLE_;
// 80CE500: using guessed type int main_arena;

//----- (0805C5B0) --------------------------------------------------------
int *__usercall tcache_init_part_6@<eax>(int a1@<ebp>, int *a2@<edi>, const struct timespec *a3@<esi>)
{
  bool v5; // zf
  int *result; // eax
  int *v7; // ecx

  _EBX = (struct timespec *)__readgsdword(0xFFFFFFEC);
  if ( _EBX )
  {
    _ECX = 1;
    v5 = __readgsdword(0xCu) == 0;
    if ( !v5 )
      __asm { lock }
    __asm { cmpxchg [ebx], ecx }
    if ( !v5 )
      _lll_lock_wait_private(0, &_EBX->tv_sec, a1, a2);
  }
  else
  {
    _EBX = (struct timespec *)get_free_list(a1);
    if ( !_EBX )
    {
      _EBX = arena_get2_part_5(320, 0);
      result = int_malloc((unsigned int)_EBX, 0x140u, a2);
      v7 = result;
      if ( result || !_EBX )
      {
LABEL_18:
        if ( !_EBX )
          goto LABEL_11;
        goto LABEL_7;
      }
LABEL_17:
      _EBX = arena_get_retry(&_EBX->tv_sec, (const struct timespec *)0x140, a1);
      result = int_malloc((unsigned int)_EBX, 0x140u, a2);
      v7 = result;
      goto LABEL_18;
    }
  }
  result = int_malloc((unsigned int)_EBX, 0x140u, a2);
  v7 = result;
  if ( !result )
    goto LABEL_17;
LABEL_7:
  if ( __readgsdword(0xCu) )
    __asm { lock }
  v5 = _EBX->tv_sec-- == 1;
  if ( !v5 )
    result = (int *)_lll_unlock_wake_private(&_EBX->tv_sec, a1, a2, a3);
LABEL_11:
  if ( v7 )
  {
    __writegsdword(0xFFFFFFE4, (unsigned int)v7);
    result = 0;
    *v7 = 0;
    v7[79] = 0;
    memset(
      (void *)((unsigned int)(v7 + 1) & 0xFFFFFFFC),
      0,
      4 * (((unsigned int)v7 - ((unsigned int)(v7 + 1) & 0xFFFFFFFC) + 320) >> 2));
  }
  return result;
}
// 805C61D: variable 'v7' is possibly undefined

//----- (0805C6B0) --------------------------------------------------------
int *__usercall int_memalign@<eax>(_TBYTE *a1@<eax>, unsigned int a2@<edx>, unsigned int a3@<ecx>)
{
  unsigned int v3; // ebx
  bool v4; // si
  int *v6; // eax
  int *v7; // esi
  int *v8; // ecx
  int v9; // eax
  unsigned int v10; // eax
  unsigned int v11; // eax
  unsigned int v12; // edx
  int v14; // edx
  int v15; // eax
  unsigned int v16; // ecx
  int *v17; // [esp+0h] [ebp-34h]
  int *v19; // [esp+8h] [ebp-2Ch]
  unsigned int v20; // [esp+Ch] [ebp-28h]
  int v21; // [esp+10h] [ebp-24h]
  int v22; // [esp+14h] [ebp-20h]

  if ( a3 + 19 <= 0xF )
  {
    v4 = 0;
    v3 = 16;
  }
  else
  {
    v3 = (a3 + 19) & 0xFFFFFFF0;
    v4 = v3 > 0xFFFFFFDF;
  }
  if ( v3 >= a3 && !v4 && -17 - a2 >= v3 )
  {
    v6 = int_malloc((unsigned int)a1, v3 + a2 + 16, (_DWORD *)a2);
    v7 = v6;
    if ( v6 )
    {
      v8 = v6 - 2;
      v17 = v6 - 2;
      if ( !((unsigned int)v6 % a2) )
      {
LABEL_8:
        v9 = v17[1];
        if ( (v9 & 2) == 0 )
        {
          v10 = v9 & 0xFFFFFFF8;
          if ( v3 + 16 < v10 )
          {
            v11 = v10 - v3;
            v12 = (unsigned int)v17 + v3;
            if ( a1 != &GLOBAL_OFFSET_TABLE_ + 128 )
              v11 |= 4u;
            *(_DWORD *)(v12 + 4) = v11 | 1;
            v17[1] = v17[1] & 7 | v3;
            int_free((int)a1, v12, 1u, v17);
          }
        }
        return v7;
      }
      v14 = (-a2 & ((unsigned int)v6 + a2 - 1)) - 8;
      v19 = (int *)v14;
      v15 = v14 - (_DWORD)v8;
      if ( (unsigned int)(v14 - (_DWORD)v8) <= 0xF )
      {
        v19 = (int *)(a2 + v14);
        v15 = a2 + v14 - (_DWORD)v8;
      }
      v16 = (*(v7 - 1) & 0xFFFFFFF8) - v15;
      v20 = v16;
      v21 = *(v7 - 1) & 2;
      if ( !v21 )
      {
        v22 = (*(v7 - 1) & 0xFFFFFFF8) - v15;
        if ( a1 != &GLOBAL_OFFSET_TABLE_ + 128 )
        {
          v21 = 4;
          v22 = v16 | 4;
        }
        v19[1] = v22 | 1;
        *(int *)((char *)v19 + v16 + 4) |= 1u;
        *(v7 - 1) = v21 | *(v7 - 1) & 7 | v15;
        int_free((int)a1, (unsigned int)v17, 1u, (int *)a2);
        if ( v3 > v20 || (v7 = v19 + 2, (unsigned int)(v19 + 2) % a2) )
          _malloc_assert(
            (int)&GLOBAL_OFFSET_TABLE_ - 174712,
            (int)&GLOBAL_OFFSET_TABLE_ - 177883,
            4742,
            (int)(&GLOBAL_OFFSET_TABLE_ - 17364));
        v17 = v19;
        goto LABEL_8;
      }
      *v19 = *(v7 - 2) + v15;
      v7 = v19 + 2;
      v19[1] = v16 | 2;
    }
    return v7;
  }
  __writegsdword(0xFFFFFFE0, 0xCu);
  return 0;
}
// 80CE000: using guessed type _TBYTE GLOBAL_OFFSET_TABLE_;

//----- (0805C8C0) --------------------------------------------------------
int __usercall memalign_check@<eax>(int a1@<ebp>, unsigned int a2, struct timespec *a3)
{
  unsigned int v4; // ebx
  unsigned int i; // eax
  bool v7; // zf
  int *v8; // ecx

  _ESI = &GLOBAL_OFFSET_TABLE_;
  v4 = a2;
  if ( a2 <= 0x10 )
    return malloc_check(a1, &a3->tv_sec, a3);
  if ( a2 > 0x80000000 )
  {
    __writegsdword(0xFFFFFFE0, 0x16u);
    return 0;
  }
  else if ( (unsigned int)a3 > -17 - a2 )
  {
    __writegsdword(0xFFFFFFE0, 0xCu);
    return 0;
  }
  else
  {
    if ( (a2 & (a2 - 1)) != 0 )
    {
      if ( a2 <= 0x20 )
      {
        v4 = 32;
      }
      else
      {
        for ( i = 32; i < a2; i *= 2 )
          ;
        v4 = i;
      }
    }
    _ECX = 1;
    v7 = __readgsdword(0xCu) == 0;
    if ( !v7 )
      __asm { lock }
    __asm { cmpxchg (main_arena - 80CE000h)[esi], ecx }
    if ( !v7 )
      _lll_lock_wait_private(0, &main_arena, a1, &a3->tv_sec);
    top_check();
    v8 = int_memalign((_TBYTE *)&main_arena, v4, (unsigned int)&a3->tv_sec + 1);
    if ( __readgsdword(0xCu) )
      __asm { lock }
    if ( --main_arena )
      _lll_unlock_wake_private(&main_arena, a1, &a3->tv_sec, (const struct timespec *)&GLOBAL_OFFSET_TABLE_);
    return mem2mem_check((int)v8, (unsigned int)a3);
  }
}
// 805C983: variable 'v8' is possibly undefined
// 80CE000: using guessed type _TBYTE GLOBAL_OFFSET_TABLE_;
// 80CE500: using guessed type int main_arena;

//----- (0805C9F0) --------------------------------------------------------
const struct timespec *__usercall free_check_part_3@<eax>(
        const struct timespec *a1@<eax>,
        int a2@<ebp>,
        int *a3@<edi>,
        int a4)
{
  bool v7; // zf
  unsigned int v8; // eax
  _DWORD *v9; // edx
  const struct timespec *result; // eax

  _ECX = 1;
  _EBX = &GLOBAL_OFFSET_TABLE_;
  v7 = __readgsdword(0xCu) == 0;
  if ( !v7 )
    __asm { lock }
  __asm { cmpxchg (main_arena - 80CE000h)[ebx], ecx }
  if ( !v7 )
    _lll_lock_wait_private(0, &main_arena, a2, a3);
  v8 = mem2chunk_check((int)a1, 0);
  if ( v8 )
  {
    v9 = (_DWORD *)v8;
    if ( (*(_BYTE *)(v8 + 4) & 2) != 0 )
    {
      if ( __readgsdword(0xCu) )
        __asm { lock }
      if ( --main_arena )
        _lll_unlock_wake_private(&main_arena, a2, a3, a1);
      return (const struct timespec *)munmap_chunk(v9);
    }
    else
    {
      result = (const struct timespec *)int_free((int)&main_arena, v8, 1u, a3);
      if ( __readgsdword(0xCu) )
        __asm { lock }
      if ( --main_arena )
        return (const struct timespec *)_lll_unlock_wake_private(&main_arena, a2, a3, a1);
    }
  }
  else
  {
    malloc_printerr((unsigned __int8)&aFreeInvalidPoi[-135061504] + (unsigned __int8)&GLOBAL_OFFSET_TABLE_);
    return free_check(a2, a3, (const struct timespec *)a4);
  }
  return result;
}
// 805CA9E: variable 'v9' is possibly undefined
// 80CE000: using guessed type _TBYTE GLOBAL_OFFSET_TABLE_;
// 80CE500: using guessed type int main_arena;

//----- (0805CAB0) --------------------------------------------------------
const struct timespec *__usercall free_check@<eax>(int a1@<ebp>, int *a2@<edi>, const struct timespec *a3)
{
  const struct timespec *result; // eax

  result = a3;
  if ( a3 )
    return free_check_part_3(a3, a1, a2, (int)a3);
  return result;
}

//----- (0805CAD0) --------------------------------------------------------
int *__usercall int_realloc@<eax>(
        unsigned int a1@<eax>,
        unsigned int a2@<edx>,
        unsigned int a3@<ecx>,
        unsigned int a4@<edi>,
        unsigned int a5@<esi>,
        unsigned int a6)
{
  unsigned int v7; // eax
  unsigned int v8; // edx
  _DWORD *v9; // ecx
  int v10; // edx
  unsigned int v11; // edi
  int v12; // eax
  int v13; // edx
  int *v14; // edi
  unsigned int v16; // edx
  int *v17; // edi
  int *v18; // eax
  unsigned int v19; // eax
  int v20; // eax
  int v21; // edx
  unsigned int v22; // ebp
  int *v23; // ebx
  int v24; // edx
  int *v25; // ecx
  int v26; // edx
  int *v27; // edi
  int v28; // edx
  int *v30; // [esp+4h] [ebp-2Ch]
  int v31; // [esp+8h] [ebp-28h]
  unsigned int v32; // [esp+Ch] [ebp-24h]
  unsigned int v33; // [esp+Ch] [ebp-24h]
  unsigned int v34; // [esp+10h] [ebp-20h]

  v7 = *(_DWORD *)(a2 + 4);
  if ( v7 <= 8 || (a5 = a2, v8 = *(_DWORD *)(a1 + 1108), v8 <= a3) )
  {
    malloc_printerr((unsigned __int8)&GLOBAL_OFFSET_TABLE_ - 86);
LABEL_33:
    LOBYTE(v7) = (unsigned __int8)malloc_printerr((unsigned __int8)&GLOBAL_OFFSET_TABLE_ - 33);
    goto LABEL_34;
  }
  v31 = v7 & 2;
  if ( (v7 & 2) != 0 )
    _malloc_assert(
      (int)&GLOBAL_OFFSET_TABLE_ - 177466,
      (int)&GLOBAL_OFFSET_TABLE_ - 177883,
      4570,
      (int)(&GLOBAL_OFFSET_TABLE_ - 17376));
  v30 = (int *)(a5 + a3);
  a4 = *(_DWORD *)(a5 + a3 + 4);
  v32 = a4 & 0xFFFFFFF8;
  if ( a4 <= 8 || v8 <= (*(_DWORD *)(a5 + a3 + 4) & 0xFFFFFFF8) )
    goto LABEL_33;
  if ( a3 >= a6 )
  {
LABEL_16:
    v11 = a3 - a6;
    v12 = v7 & 7;
    if ( a3 - a6 > 0xF )
    {
      v16 = a5 + a6;
      if ( (_TBYTE *)a1 != &GLOBAL_OFFSET_TABLE_ + 128 )
      {
        v31 = 4;
        v11 |= 4u;
      }
      v17 = (int *)(v11 | 1);
      *(_DWORD *)(a5 + 4) = v31 | a6 | v12;
      *(_DWORD *)(v16 + 4) = v17;
      v30[1] |= 1u;
      int_free(a1, v16, 1u, v17);
    }
    else
    {
      v13 = 4;
      if ( (_TBYTE *)a1 == &GLOBAL_OFFSET_TABLE_ + 128 )
        v13 = v31;
      *(_DWORD *)(a5 + 4) = v13 | v12 | a3;
      v30[1] |= 1u;
    }
    return (int *)(a5 + 8);
  }
  if ( *(int **)(a1 + 56) != v30 )
  {
    if ( (*((_BYTE *)v30 + v32 + 4) & 1) == 0 )
    {
      v34 = a3 + v32;
      if ( a6 <= a3 + v32 )
      {
        if ( *(int *)((char *)v30 + v32) == v32 )
        {
          v9 = (_DWORD *)v30[2];
          v10 = v30[3];
          if ( (int *)v9[3] == v30 && *(int **)(v10 + 8) == v30 )
          {
            v9[3] = v10;
            *(_DWORD *)(v10 + 8) = v9;
            if ( a4 <= 0x3EF || (a4 = v30[4]) == 0 )
            {
              a3 = v34;
              v30 = (int *)(a5 + v34);
              goto LABEL_16;
            }
LABEL_39:
            v23 = v30;
            if ( *(int **)(a4 + 20) == v30 && (v24 = v30[5], *(int **)(v24 + 16) == v30) )
            {
              v23 = (int *)(a5 + v34);
              if ( v9[4] )
              {
                v25 = v30;
                *(_DWORD *)(a4 + 20) = v24;
                v30 = (int *)(a5 + v34);
                v26 = v25[5];
                a3 = v34;
                *(_DWORD *)(v26 + 16) = a4;
                goto LABEL_16;
              }
              if ( (int *)a4 != v30 )
              {
                v9[4] = a4;
                v27 = v30;
                v9[5] = v24;
                v28 = v30[4];
                v30 = (int *)(a5 + v34);
                *(_DWORD *)(v28 + 20) = v9;
                *(_DWORD *)(v27[5] + 16) = v9;
                a3 = v34;
                goto LABEL_16;
              }
            }
            else
            {
              LOBYTE(v7) = (unsigned __int8)malloc_printerr((unsigned __int8)&GLOBAL_OFFSET_TABLE_ + 0x80);
            }
            v9[5] = v9;
            v9[4] = v9;
            a3 = v34;
            v30 = v23;
            goto LABEL_16;
          }
          malloc_printerr((unsigned __int8)&GLOBAL_OFFSET_TABLE_ + 8);
        }
        LOBYTE(v7) = (unsigned __int8)malloc_printerr((unsigned __int8)&GLOBAL_OFFSET_TABLE_ - 21);
        goto LABEL_39;
      }
    }
LABEL_26:
    v33 = a3;
    v18 = int_malloc(a1, a6 - 15, (_DWORD *)a4);
    v14 = v18;
    if ( !v18 )
      return v14;
    v19 = *(v18 - 1) & 0xFFFFFFF8;
    if ( v30 != v14 - 2 )
    {
      memcpy(v14, (_BYTE *)(a5 + 8), v33 - 4);
      int_free(a1, a5, 1u, v14);
      return v14;
    }
    a3 = v19 + v33;
    if ( a6 > v19 + v33 )
      _malloc_assert(
        (int)(&GLOBAL_OFFSET_TABLE_ - 17464),
        (int)&GLOBAL_OFFSET_TABLE_ - 177883,
        4639,
        (int)(&GLOBAL_OFFSET_TABLE_ - 17376));
    v7 = *(_DWORD *)(a5 + 4);
    v30 = (int *)(a5 + a3);
    goto LABEL_16;
  }
  a4 = a3 + v32;
  if ( a6 + 16 > a3 + v32 )
    goto LABEL_26;
LABEL_34:
  v20 = v7 & 7;
  v21 = 4;
  if ( (_TBYTE *)a1 == &GLOBAL_OFFSET_TABLE_ + 128 )
    v21 = v31;
  v22 = a4 - a6;
  v14 = (int *)(a5 + 8);
  *(_DWORD *)(a5 + 4) = v21 | a6 | v20;
  *(_DWORD *)(a1 + 56) = a5 + a6;
  *(_DWORD *)(a5 + a6 + 4) = v22 | 1;
  return v14;
}
// 805CD64: variable 'v31' is possibly undefined
// 805CDBD: variable 'v9' is possibly undefined
// 80CE000: using guessed type _TBYTE GLOBAL_OFFSET_TABLE_;

//----- (0805CE40) --------------------------------------------------------
__int32 __usercall realloc_check@<eax>(int *a1@<edi>, struct timespec *a2, const struct timespec *a3)
{
  const struct timespec *v4; // esi
  bool v6; // zf
  int *v7; // edi
  unsigned int v9; // eax
  bool v11; // zf
  int *v12; // eax
  int *v13; // edx
  int v14; // [esp-4h] [ebp-3Ch]
  unsigned int v15; // [esp+0h] [ebp-38h]
  const struct timespec *v16; // [esp+0h] [ebp-38h]
  unsigned int v17; // [esp+4h] [ebp-34h]
  int v18[9]; // [esp+14h] [ebp-24h] BYREF

  _EBX = &GLOBAL_OFFSET_TABLE_;
  v18[1] = __readgsdword(0x14u);
  v4 = a2;
  if ( a3 == (const struct timespec *)-1 )
    goto LABEL_14;
  if ( !a2 )
    return malloc_check((int)a3, a1, a3);
  if ( !a3 )
  {
    free_check_part_3(a2, 0, a1, v14);
    return 0;
  }
  _ECX = 1;
  v6 = __readgsdword(0xCu) == 0;
  if ( !v6 )
    __asm { lock }
  __asm { cmpxchg (main_arena - 80CE000h)[ebx], ecx }
  if ( !v6 )
    _lll_lock_wait_private(0, &main_arena, (int)a3, a1);
  v7 = (int *)mem2chunk_check((int)a2, v18);
  if ( __readgsdword(0xCu) )
    __asm { lock }
  if ( --main_arena )
    _lll_unlock_wake_private(&main_arena, (int)a3, v7, a2);
  if ( !v7 )
  {
    malloc_printerr((unsigned __int8)&aReallocInvalid[-135061504] + (unsigned __int8)&GLOBAL_OFFSET_TABLE_);
    return _malloc_fork_lock_parent((int)a3, 0);
  }
  if ( (unsigned int)&a3[2].tv_nsec <= 0xF
    || (v9 = (unsigned int)&a3[2].tv_nsec & 0xFFFFFFF0, v15 = v9, v9 > 0xFFFFFFDF)
    || v9 < (unsigned int)&a3->tv_sec + 1 )
  {
LABEL_14:
    __writegsdword(0xFFFFFFE0, 0xCu);
    return 0;
  }
  _ECX = 1;
  v17 = v7[1] & 0xFFFFFFF8;
  v11 = __readgsdword(0xCu) == 0;
  if ( !v11 )
    __asm { lock }
  __asm { cmpxchg (main_arena - 80CE000h)[ebx], ecx }
  if ( !v11 )
    _lll_lock_wait_private(0, &main_arena, (int)a3, v7);
  if ( (v7[1] & 2) == 0 )
  {
    top_check();
    v4 = (const struct timespec *)int_realloc(
                                    (unsigned int)&main_arena,
                                    (unsigned int)v7,
                                    v17,
                                    (unsigned int)v7,
                                    (unsigned int)a2,
                                    v15);
    if ( v4 )
      goto LABEL_26;
    goto LABEL_24;
  }
  v12 = mremap_chunk(v7, v15);
  if ( !v12 )
  {
    if ( v15 <= v17 - 4 )
      goto LABEL_26;
    top_check();
    v13 = int_malloc((unsigned int)&main_arena, (unsigned int)&a3->tv_sec + 1, v7);
    if ( v13 )
    {
      v16 = (const struct timespec *)v13;
      memcpy(v13, a2, v17 - 8);
      munmap_chunk(v7);
      v4 = v16;
      goto LABEL_26;
    }
    goto LABEL_24;
  }
  v4 = (const struct timespec *)(v12 + 2);
  if ( v12 == (int *)-8 )
  {
LABEL_24:
    v4 = 0;
    *(_BYTE *)v18[0] = ~*(_BYTE *)v18[0];
  }
LABEL_26:
  if ( __readgsdword(0xCu) )
    __asm { lock }
  if ( --main_arena )
    _lll_unlock_wake_private(&main_arena, (int)a3, v7, v4);
  return mem2mem_check((int)v4, (unsigned int)a3);
}
// 805D032: variable 'v14' is possibly undefined
// 80CE000: using guessed type _TBYTE GLOBAL_OFFSET_TABLE_;
// 80CE500: using guessed type int main_arena;

//----- (0805D070) --------------------------------------------------------
__int32 __usercall _malloc_fork_lock_parent@<eax>(int a1@<ebp>, int *a2@<edi>)
{
  __int32 result; // eax
  bool v5; // zf
  int *v6; // ebx
  bool v9; // zf

  _EDX = &GLOBAL_OFFSET_TABLE_;
  result = _libc_malloc_initialized;
  if ( _libc_malloc_initialized > 0 )
  {
    _ECX = 1;
    v5 = __readgsdword(0xCu) == 0;
    if ( !v5 )
      __asm { lock }
    __asm { cmpxchg ds:(list_lock - 80CE000h)[edx], ecx }
    if ( !v5 )
      _lll_lock_wait_private(0, &list_lock, a1, a2);
    v6 = (int *)((char *)_EDX + (_DWORD)(&main_arena - 33765376));
    _EDX = v6;
    do
    {
      result = 0;
      _ECX = 1;
      v9 = __readgsdword(0xCu) == 0;
      if ( !v9 )
        __asm { lock }
      __asm { cmpxchg dword ptr ds:(_GLOBAL_OFFSET_TABLE_ - 80CE000h)[edx], ecx }
      if ( !v9 )
        result = _lll_lock_wait_private(0, _EDX, a1, 0);
      _EDX = *(int **)((char *)_EDX + (_DWORD)(&dword_80CE448 - 33765376));
    }
    while ( _EDX != v6 );
  }
  return result;
}
// 805D0B2: variable '_EDX' is possibly undefined
// 805D0E3: variable '_EDX' is possibly undefined
// 80CE000: using guessed type _TBYTE GLOBAL_OFFSET_TABLE_;
// 80CE448: using guessed type int dword_80CE448;
// 80CE484: using guessed type int _libc_malloc_initialized;
// 80CE500: using guessed type int main_arena;
// 80CF880: using guessed type int list_lock;

//----- (0805D100) --------------------------------------------------------
int __usercall _malloc_fork_unlock_parent@<eax>(int a1@<ebp>, int *a2@<edi>, const struct timespec *a3@<esi>)
{
  int result; // eax
  int *v4; // ecx
  int *v5; // edx

  result = _libc_malloc_initialized;
  if ( _libc_malloc_initialized > 0 )
  {
    v4 = &main_arena;
    v5 = &main_arena;
    do
    {
      if ( __readgsdword(0xCu) )
        __asm { lock }
      if ( (*v5)-- != 1 )
        result = _lll_unlock_wake_private(v5, a1, a2, a3);
      v5 = (int *)v5[274];
    }
    while ( v5 != v4 );
    if ( __readgsdword(0xCu) )
      __asm { lock }
    if ( --list_lock )
      return _lll_unlock_wake_private(&list_lock, a1, a2, a3);
  }
  return result;
}
// 805D13F: variable 'v5' is possibly undefined
// 805D147: variable 'v4' is possibly undefined
// 80CE484: using guessed type int _libc_malloc_initialized;
// 80CE500: using guessed type int main_arena;
// 80CF880: using guessed type int list_lock;

//----- (0805D170) --------------------------------------------------------
int _malloc_fork_unlock_child()
{
  int result; // eax
  unsigned int v1; // ecx
  int v2; // edi
  int v3; // edx
  int *v4; // eax

  result = _libc_malloc_initialized;
  if ( _libc_malloc_initialized > 0 )
  {
    free_list_lock = 0;
    v1 = __readgsdword(0xFFFFFFEC);
    if ( v1 )
      *(_DWORD *)(v1 + 1104) = 1;
    free_list = 0;
    v2 = 0;
    v3 = 0;
    v4 = &main_arena;
    do
    {
      *v4 = 0;
      if ( (int *)v1 != v4 )
      {
        v4[276] = 0;
        v2 = 1;
        v4[275] = v3;
        v3 = (int)v4;
      }
      v4 = (int *)v4[274];
    }
    while ( v4 != &main_arena );
    result = v2;
    if ( (_BYTE)v2 )
      free_list = v3;
    list_lock = 0;
  }
  return result;
}
// 80CE484: using guessed type int _libc_malloc_initialized;
// 80CE500: using guessed type int main_arena;
// 80CF880: using guessed type int list_lock;
// 80CF884: using guessed type int free_list;
// 80CF888: using guessed type int free_list_lock;

//----- (0805D210) --------------------------------------------------------
_TBYTE *_malloc_check_init()
{
  _TBYTE *result; // eax

  result = &GLOBAL_OFFSET_TABLE_;
  using_malloc_checking = 1;
  _malloc_hook = (int (__cdecl *)(int))malloc_check;
  _free_hook = (int)free_check;
  _realloc_hook = (int)realloc_check;
  _memalign_hook[0] = (int (__cdecl *)(int, int))memalign_check;
  return result;
}
// 80CE000: using guessed type _TBYTE GLOBAL_OFFSET_TABLE_;
// 80CE4E0: using guessed type int (__cdecl *_memalign_hook[2])(int, int);
// 80CE4E4: using guessed type int _realloc_hook;
// 80CE4E8: using guessed type int (__cdecl *_malloc_hook)(int);
// 80CF86C: using guessed type int _free_hook;
// 80CF878: using guessed type int using_malloc_checking;

//----- (0805D260) --------------------------------------------------------
int *__cdecl malloc(const struct timespec *a1)
{
  bool v1; // dl
  unsigned int v2; // eax
  unsigned int v3; // edi
  unsigned int v4; // eax
  unsigned int v5; // ebp
  int *v6; // eax
  int *v7; // edx
  int v8; // eax
  unsigned int v9; // ecx
  bool v13; // zf
  int v14; // eax
  int *v15; // ecx
  void *retaddr; // [esp+10h] [ebp+0h]

  if ( _malloc_hook )
    return (int *)((int (__cdecl *)(const struct timespec *, void *))_malloc_hook)(a1, retaddr);
  if ( (unsigned int)&a1[2].tv_sec + 3 > 0xF )
  {
    v2 = ((unsigned int)&a1[2].tv_sec + 3) & 0xFFFFFFF0;
    v1 = v2 > 0xFFFFFFDF;
  }
  else
  {
    v1 = 0;
    v2 = 16;
  }
  if ( v2 >= (unsigned int)a1 && !v1 )
  {
    v3 = v2 - 1;
    v4 = __readgsdword(0xFFFFFFE4);
    v5 = v3 >> 4;
    if ( v4 )
    {
      if ( v5 >= dword_80CE4D0 )
        goto LABEL_8;
    }
    else
    {
      if ( __readgsbyte(0xFFFFFFE8) )
        goto LABEL_8;
      tcache_init_part_6(v5, (int *)v3, a1);
      if ( dword_80CE4D0 <= v5 )
        goto LABEL_8;
      v4 = __readgsdword(0xFFFFFFE4);
      if ( !v4 )
        goto LABEL_8;
    }
    v9 = v4 + 4 * v5;
    v7 = *(int **)(v9 + 64);
    if ( v7 )
    {
      if ( v3 > 0x3FF )
        _malloc_assert((int)"tc_idx < TCACHE_MAX_BINS", (int)"malloc.c", 2943, (int)"tcache_get");
      *(_DWORD *)(v9 + 64) = *v7;
      --*(_BYTE *)(v4 + v5);
      v7[1] = 0;
      return v7;
    }
LABEL_8:
    if ( !__readgsdword(0xCu) )
    {
      v6 = int_malloc((unsigned int)&main_arena, (unsigned int)a1, (_DWORD *)v3);
      v7 = v6;
      if ( v6 )
      {
        v8 = *(v6 - 1);
        if ( (v8 & 2) == 0 && (v8 & 4) != 0 && *(int **)((unsigned int)(v7 - 2) & 0xFFF00000) != &main_arena )
          _malloc_assert(
            (int)"!victim || chunk_is_mmapped (mem2chunk (victim)) || &main_arena == arena_for_chunk (mem2chunk (victim))",
            (int)"malloc.c",
            3062,
            (int)"__libc_malloc");
        return v7;
      }
      return 0;
    }
    _EDI = (struct timespec *)__readgsdword(0xFFFFFFEC);
    if ( _EDI )
    {
      _ECX = 1;
      v13 = __readgsdword(0xCu) == 0;
      if ( !v13 )
        __asm { lock }
      __asm { cmpxchg [edi], ecx }
      if ( !v13 )
        _lll_lock_wait_private(0, &_EDI->tv_sec, v5, &_EDI->tv_sec);
    }
    else
    {
      _EDI = (struct timespec *)get_free_list(v5);
      if ( !_EDI )
      {
        _EDI = arena_get2_part_5((int)a1, 0);
        v7 = int_malloc((unsigned int)_EDI, (unsigned int)a1, _EDI);
        if ( v7 || !_EDI )
        {
LABEL_45:
          if ( !_EDI )
            goto LABEL_35;
          goto LABEL_31;
        }
LABEL_44:
        _EDI = arena_get_retry(&_EDI->tv_sec, a1, v5);
        v7 = int_malloc((unsigned int)_EDI, (unsigned int)a1, _EDI);
        goto LABEL_45;
      }
    }
    v7 = int_malloc((unsigned int)_EDI, (unsigned int)a1, _EDI);
    if ( v7 )
    {
LABEL_31:
      if ( __readgsdword(0xCu) )
        __asm { lock }
      v13 = _EDI->tv_sec-- == 1;
      if ( !v13 )
        _lll_unlock_wake_private(&_EDI->tv_sec, v5, &_EDI->tv_sec, a1);
LABEL_35:
      if ( v7 )
      {
        v14 = *(v7 - 1);
        if ( (v14 & 2) == 0 )
        {
          v15 = &main_arena;
          if ( (v14 & 4) != 0 )
            v15 = *(int **)((unsigned int)(v7 - 2) & 0xFFF00000);
          if ( v15 != (int *)_EDI )
            _malloc_assert(
              (int)"!victim || chunk_is_mmapped (mem2chunk (victim)) || ar_ptr == arena_for_chunk (mem2chunk (victim))",
              (int)"malloc.c",
              3082,
              (int)"__libc_malloc");
        }
        return v7;
      }
      return 0;
    }
    goto LABEL_44;
  }
  __writegsdword(0xFFFFFFE0, 0xCu);
  return 0;
}
// 805D3AD: variable 'v7' is possibly undefined
// 80CE4D0: using guessed type int dword_80CE4D0;
// 80CE4E8: using guessed type int (__cdecl *_malloc_hook)(int);
// 80CE500: using guessed type int main_arena;

//----- (0805D530) --------------------------------------------------------
int *__cdecl malloc_hook_ini(const struct timespec *a1)
{
  _malloc_hook = 0;
  ptmalloc_init();
  return malloc(a1);
}
// 80CE4E8: using guessed type int (__cdecl *_malloc_hook)(int);

//----- (0805D570) --------------------------------------------------------
int *__usercall mid_memalign@<eax>(unsigned int a1@<eax>, struct timespec *a2@<edx>, int a3@<ecx>)
{
  unsigned int v4; // ebx
  int *v5; // eax
  int *v6; // edx
  int v7; // eax
  bool v11; // zf
  int v12; // eax
  int *v13; // ecx

  v4 = a1;
  if ( !_memalign_hook[0] )
  {
    if ( a1 <= 0x10 )
      return malloc(a2);
    if ( (unsigned int)a2 > -17 - a1 )
    {
      v6 = 0;
      __writegsdword(0xFFFFFFE0, 0xCu);
      return v6;
    }
    if ( (a1 & (a1 - 1)) != 0 )
      v4 = 32;
    if ( !__readgsdword(0xCu) )
    {
      v5 = int_memalign((_TBYTE *)&main_arena, v4, (unsigned int)a2);
      v6 = v5;
      if ( v5 )
      {
        v7 = *(v5 - 1);
        if ( (v7 & 2) == 0 && (v7 & 4) != 0 && *(int **)((unsigned int)(v6 - 2) & 0xFFF00000) != &main_arena )
          _malloc_assert(
            (int)"!p || chunk_is_mmapped (mem2chunk (p)) || &main_arena == arena_for_chunk (mem2chunk (p))",
            (int)"malloc.c",
            3310,
            (int)"_mid_memalign");
        return v6;
      }
      return 0;
    }
    _EBP = (struct timespec *)__readgsdword(0xFFFFFFEC);
    if ( _EBP )
    {
      _ECX = 1;
      v11 = __readgsdword(0xCu) == 0;
      if ( !v11 )
        __asm { lock }
      __asm { cmpxchg [ebp+0], ecx }
      if ( !v11 )
        _lll_lock_wait_private(0, &_EBP->tv_sec, (int)_EBP, &a2->tv_sec);
    }
    else
    {
      _EBP = (struct timespec *)get_free_list(0);
      if ( !_EBP )
      {
        _EBP = arena_get2_part_5((int)&a2[2] + v4, 0);
        v6 = int_memalign((_TBYTE *)&_EBP->tv_sec, v4, (unsigned int)a2);
        if ( v6 || !_EBP )
        {
LABEL_37:
          if ( !_EBP )
            goto LABEL_27;
          goto LABEL_23;
        }
LABEL_36:
        _EBP = arena_get_retry(&_EBP->tv_sec, a2, (int)_EBP);
        v6 = int_memalign((_TBYTE *)&_EBP->tv_sec, v4, (unsigned int)a2);
        goto LABEL_37;
      }
    }
    v6 = int_memalign((_TBYTE *)&_EBP->tv_sec, v4, (unsigned int)a2);
    if ( v6 )
    {
LABEL_23:
      if ( __readgsdword(0xCu) )
        __asm { lock }
      v11 = _EBP->tv_sec-- == 1;
      if ( !v11 )
        _lll_unlock_wake_private(&_EBP->tv_sec, (int)_EBP, &a2->tv_sec, (const struct timespec *)&GLOBAL_OFFSET_TABLE_);
LABEL_27:
      if ( v6 )
      {
        v12 = *(v6 - 1);
        if ( (v12 & 2) == 0 )
        {
          v13 = &main_arena;
          if ( (v12 & 4) != 0 )
            v13 = *(int **)((unsigned int)(v6 - 2) & 0xFFF00000);
          if ( v13 != (int *)_EBP )
            _malloc_assert(
              (int)"!p || chunk_is_mmapped (mem2chunk (p)) || ar_ptr == arena_for_chunk (mem2chunk (p))",
              (int)"malloc.c",
              3329,
              (int)"_mid_memalign");
        }
        return v6;
      }
      return 0;
    }
    goto LABEL_36;
  }
  return (int *)((int (__cdecl *)(unsigned int, struct timespec *, int))_memalign_hook[0])(a1, a2, a3);
}
// 805D5A3: conditional instruction was optimized away because eax.4==0
// 805D5C2: conditional instruction was optimized away because eax.4==0
// 805D652: variable 'v6' is possibly undefined
// 80CE000: using guessed type _TBYTE GLOBAL_OFFSET_TABLE_;
// 80CE4E0: using guessed type int (__cdecl *_memalign_hook[2])(int, int);
// 80CE500: using guessed type int main_arena;

//----- (0805D7E0) --------------------------------------------------------
int *__cdecl memalign_hook_ini(unsigned int a1, struct timespec *a2)
{
  int retaddr; // [esp+0h] [ebp+0h]

  _memalign_hook[0] = 0;
  ptmalloc_init();
  return mid_memalign(a1, a2, retaddr);
}
// 80CE4E0: using guessed type int (__cdecl *_memalign_hook[2])(int, int);

//----- (0805D820) --------------------------------------------------------
int *__usercall free@<eax>(int a1@<ebp>, int *a2@<edi>, int a3)
{
  int *result; // eax
  unsigned int v4; // ecx
  unsigned int v5; // edx
  int *v6; // eax
  void *retaddr; // [esp+10h] [ebp+0h]

  result = (int *)_free_hook;
  if ( _free_hook )
    return (int *)((int (__cdecl *)(int, void *))_free_hook)(a3, retaddr);
  if ( a3 )
  {
    v4 = *(_DWORD *)(a3 - 4);
    v5 = a3 - 8;
    if ( (v4 & 2) != 0 )
    {
      if ( !dword_80CE4C0 && v4 > dword_80CE4A8 && v4 <= 0x80000 )
      {
        dword_80CE4A8 = v4 & 0xFFFF8;
        mp_ = 2 * (v4 & 0xFFFF8);
      }
      return munmap_chunk((_DWORD *)v5);
    }
    else
    {
      if ( !__readgsdword(0xFFFFFFE4) && !__readgsbyte(0xFFFFFFE8) )
      {
        tcache_init_part_6(a1, a2, (const struct timespec *)&GLOBAL_OFFSET_TABLE_);
        v4 = *(_DWORD *)(a3 - 4);
        v5 = a3 - 8;
      }
      v6 = &main_arena;
      if ( (v4 & 4) != 0 )
        v6 = *(int **)(v5 & 0xFFF00000);
      return (int *)int_free((int)v6, v5, 0, a2);
    }
  }
  return result;
}
// 805D8C8: mask 0xFFFFFFF8 is shortened because ecx.4 <= 0x80000
// 80CE000: using guessed type _TBYTE GLOBAL_OFFSET_TABLE_;
// 80CE4A0: using guessed type int mp_;
// 80CE4A8: using guessed type int dword_80CE4A8;
// 80CE4C0: using guessed type int dword_80CE4C0;
// 80CE500: using guessed type int main_arena;
// 80CF86C: using guessed type int _free_hook;

//----- (0805D910) --------------------------------------------------------
int __usercall _malloc_arena_thread_freeres@<eax>(int *p_tv_sec@<edi>, struct timespec *a2@<esi>)
{
  struct timespec *v3; // ebp
  __time_t *i; // eax
  int result; // eax
  unsigned int v6; // edx
  bool v8; // zf
  int v9; // eax

  _EBX = &GLOBAL_OFFSET_TABLE_;
  v3 = (struct timespec *)__readgsdword(0xFFFFFFE4);
  if ( v3 )
  {
    __writegsdword(0xFFFFFFE4, 0);
    a2 = v3 + 8;
    p_tv_sec = &v3[40].tv_sec;
    __writegsbyte(0xFFFFFFE8, 1u);
    do
    {
      for ( i = (__time_t *)a2->tv_sec; a2->tv_sec; i = (__time_t *)a2->tv_sec )
      {
        a2->tv_sec = *i;
        free((int)v3, p_tv_sec, (int)i);
      }
      a2 = (struct timespec *)((char *)a2 + 4);
    }
    while ( a2 != (struct timespec *)p_tv_sec );
    free((int)v3, p_tv_sec, (int)v3);
  }
  result = -20;
  v6 = __readgsdword(0xFFFFFFEC);
  __writegsdword(0xFFFFFFEC, 0);
  if ( v6 )
  {
    _ECX = 1;
    v8 = __readgsdword(0xCu) == 0;
    if ( !v8 )
      __asm { lock }
    __asm { cmpxchg ds:(free_list_lock - 80CE000h)[ebx], ecx }
    if ( !v8 )
      _lll_lock_wait_private(0, &free_list_lock, (int)v3, p_tv_sec);
    v9 = *(_DWORD *)(v6 + 1104);
    if ( !v9 )
      _malloc_assert((int)"a->attached_threads > 0", (int)"arena.c", 960, (int)"__malloc_arena_thread_freeres");
    result = v9 - 1;
    *(_DWORD *)(v6 + 1104) = result;
    if ( !result )
    {
      result = free_list;
      free_list = v6;
      *(_DWORD *)(v6 + 1100) = result;
    }
    if ( __readgsdword(0xCu) )
      __asm { lock }
    if ( --free_list_lock )
      return _lll_unlock_wake_private(&free_list_lock, (int)v3, p_tv_sec, a2);
  }
  return result;
}
// 805D9C3: variable 'v6' is possibly undefined
// 80CE000: using guessed type _TBYTE GLOBAL_OFFSET_TABLE_;
// 80CF884: using guessed type int free_list;
// 80CF888: using guessed type int free_list_lock;

//----- (0805DA40) --------------------------------------------------------
int *__usercall realloc@<eax>(int ebp0@<ebp>, _BYTE *a2, const struct timespec *a3)
{
  bool v3; // dl
  int v4; // eax
  unsigned int v5; // ecx
  unsigned int v6; // ebp
  int *v7; // eax
  int *v8; // esi
  int v9; // eax
  int *v10; // edx
  int *v11; // eax
  bool v15; // zf
  int *v16; // ecx
  int v17; // eax
  int *v18; // edx
  unsigned int v19; // [esp+0h] [ebp-2Ch]
  _BYTE *v20; // [esp+4h] [ebp-28h]
  unsigned int v21; // [esp+8h] [ebp-24h]
  int *v22; // [esp+Ch] [ebp-20h]
  void *retaddr; // [esp+2Ch] [ebp+0h]

  if ( _realloc_hook )
    return (int *)((int (__cdecl *)(_BYTE *, const struct timespec *, void *))_realloc_hook)(a2, a3, retaddr);
  v3 = a2 != 0 && a3 == 0;
  if ( v3 )
  {
    free(ebp0, (int *)&GLOBAL_OFFSET_TABLE_, (int)a2);
    return 0;
  }
  if ( !a2 )
    return malloc(a3);
  v22 = 0;
  v21 = (unsigned int)(a2 - 8);
  v4 = *((_DWORD *)a2 - 1);
  v19 = v4 & 0xFFFFFFF8;
  if ( (v4 & 2) == 0 )
  {
    if ( !__readgsdword(0xFFFFFFE4) && !__readgsbyte(0xFFFFFFE8) )
    {
      tcache_init_part_6(ebp0, (int *)&GLOBAL_OFFSET_TABLE_, a3);
      v4 = *((_DWORD *)a2 - 1);
      v3 = a2 != 0 && a3 == 0;
    }
    v22 = &main_arena;
    if ( (v4 & 4) != 0 )
      v22 = *(int **)((unsigned int)(a2 - 8) & 0xFFF00000);
  }
  if ( -v19 < v21 || ((unsigned __int8)a2 & 0xF) != 0 )
  {
    malloc_printerr((unsigned __int8)&aReallocInvalid[-135061504] + (unsigned __int8)&GLOBAL_OFFSET_TABLE_);
    return realloc_hook_ini(ebp0, a2, a3);
  }
  else
  {
    v5 = (unsigned int)&a3[2].tv_sec + 3;
    v6 = 16;
    if ( (unsigned int)&a3[2].tv_sec + 3 > 0xF )
    {
      v6 = v5 & 0xFFFFFFF0;
      v3 = (v5 & 0xFFFFFFF0) > 0xFFFFFFDF;
    }
    if ( v6 >= (unsigned int)a3 && !v3 )
    {
      if ( (v4 & 2) != 0 )
      {
        v11 = mremap_chunk((int *)a2 - 2, v6);
        if ( v11 )
        {
          return v11 + 2;
        }
        else
        {
          v20 = a2;
          if ( v19 - 4 < v6 )
          {
            v20 = malloc(a3);
            if ( v20 )
            {
              memcpy(v20, a2, v19 - 8);
              munmap_chunk((_DWORD *)v21);
            }
          }
        }
      }
      else if ( __readgsdword(0xCu) )
      {
        _ECX = 1;
        _EDX = v22;
        v15 = __readgsdword(0xCu) == 0;
        if ( !v15 )
          __asm { lock }
        __asm { cmpxchg [edx], ecx }
        if ( !v15 )
          _lll_lock_wait_private(0, v22, v6, (int *)&GLOBAL_OFFSET_TABLE_);
        v16 = int_realloc(
                (unsigned int)v22,
                (unsigned int)(a2 - 8),
                v19,
                (unsigned int)&GLOBAL_OFFSET_TABLE_,
                (unsigned int)a3,
                v6);
        v20 = v16;
        if ( __readgsdword(0xCu) )
          __asm { lock }
        v15 = (*v22)-- == 1;
        if ( !v15 )
          _lll_unlock_wake_private(v22, (int)v22, (int *)&GLOBAL_OFFSET_TABLE_, a3);
        if ( v16 )
        {
          v17 = *(v16 - 1);
          if ( (v17 & 2) == 0 )
          {
            v18 = &main_arena;
            if ( (v17 & 4) != 0 )
              v18 = *(int **)((unsigned int)(v16 - 2) & 0xFFF00000);
            if ( v22 != v18 )
              _malloc_assert(
                (int)"!newp || chunk_is_mmapped (mem2chunk (newp)) || ar_ptr == arena_for_chunk (mem2chunk (newp))",
                (int)"malloc.c",
                3237,
                (int)"__libc_realloc");
          }
        }
        else
        {
          v20 = malloc(a3);
          if ( v20 )
          {
            memcpy(v20, a2, v19 - 4);
            int_free((int)v22, v21, 0, (int *)&GLOBAL_OFFSET_TABLE_);
          }
        }
      }
      else
      {
        v7 = int_realloc((unsigned int)v22, v21, v19, (unsigned int)&GLOBAL_OFFSET_TABLE_, (unsigned int)a3, v6);
        v20 = v7;
        v8 = v7;
        if ( v7 )
        {
          v9 = *(v7 - 1);
          if ( (v9 & 2) == 0 )
          {
            v10 = &main_arena;
            if ( (v9 & 4) != 0 )
              v10 = *(int **)((unsigned int)(v8 - 2) & 0xFFF00000);
            if ( v22 != v10 )
              _malloc_assert(
                (int)"!newp || chunk_is_mmapped (mem2chunk (newp)) || ar_ptr == arena_for_chunk (mem2chunk (newp))",
                (int)"malloc.c",
                3226,
                (int)"__libc_realloc");
          }
        }
      }
      return (int *)v20;
    }
    __writegsdword(0xFFFFFFE0, 0xCu);
    return 0;
  }
}
// 805DD22: variable 'v16' is possibly undefined
// 80CE000: using guessed type _TBYTE GLOBAL_OFFSET_TABLE_;
// 80CE4E4: using guessed type int _realloc_hook;
// 80CE500: using guessed type int main_arena;

//----- (0805DDC0) --------------------------------------------------------
int *__usercall realloc_hook_ini@<eax>(int a1@<ebp>, _BYTE *a2, const struct timespec *a3)
{
  _malloc_hook = 0;
  _realloc_hook = 0;
  ptmalloc_init();
  return realloc(a1, a2, a3);
}
// 80CE4E4: using guessed type int _realloc_hook;
// 80CE4E8: using guessed type int (__cdecl *_malloc_hook)(int);

//----- (0805DE10) --------------------------------------------------------
int *__cdecl memalign(unsigned int a1, struct timespec *a2)
{
  int retaddr; // [esp+0h] [ebp+0h]

  return mid_memalign(a1, a2, retaddr);
}

//----- (0805DE30) --------------------------------------------------------
int *__cdecl valloc(struct timespec *a1)
{
  int retaddr; // [esp+8h] [ebp+0h]

  if ( _libc_malloc_initialized < 0 )
    ptmalloc_init();
  return mid_memalign(dl_pagesize, a1, retaddr);
}
// 80CE484: using guessed type int _libc_malloc_initialized;
// 80CE9B0: using guessed type int dl_pagesize;

//----- (0805DE80) --------------------------------------------------------
int *__cdecl pvalloc(unsigned int a1)
{
  int retaddr; // [esp+Ch] [ebp+0h]

  if ( _libc_malloc_initialized < 0 )
    ptmalloc_init();
  if ( -17 - 2 * dl_pagesize >= a1 )
    return mid_memalign(dl_pagesize, (struct timespec *)(-dl_pagesize & (dl_pagesize + a1 - 1)), retaddr);
  __writegsdword(0xFFFFFFE0, 0xCu);
  return 0;
}
// 80CE484: using guessed type int _libc_malloc_initialized;
// 80CE9B0: using guessed type int dl_pagesize;

//----- (0805DEF0) --------------------------------------------------------
unsigned __int8 *__usercall calloc@<eax>(int *edi0@<edi>, unsigned int a2, unsigned int a3)
{
  unsigned int v3; // ebp
  int tv_sec; // ecx
  int *v6; // eax
  struct timespec *v7; // ecx
  struct timespec *v8; // esi
  int v9; // eax
  int tv_nsec; // eax
  unsigned int v12; // eax
  unsigned int v13; // eax
  int *v14; // edx
  unsigned __int8 *v15; // eax
  bool v17; // zf
  unsigned int v18; // eax
  int *v19; // eax
  int v20; // [esp+0h] [ebp-24h]
  unsigned int v21; // [esp+4h] [ebp-20h]
  void *retaddr; // [esp+24h] [ebp+0h]

  v3 = a3 * a2;
  if ( (a3 | a2) > 0xFFFF && a3 && v3 / a3 != a2 )
  {
    v8 = 0;
    __writegsdword(0xFFFFFFE0, 0xCu);
    return (unsigned __int8 *)v8;
  }
  if ( _malloc_hook )
  {
    v15 = (unsigned __int8 *)((int (__cdecl *)(unsigned int, void *))_malloc_hook)(a3 * a2, retaddr);
    if ( v15 )
      return memset(v15, 0, v3);
    return 0;
  }
  if ( !__readgsdword(0xFFFFFFE4) && !__readgsbyte(0xFFFFFFE8) )
    tcache_init_part_6(v3, edi0, (const struct timespec *)a2);
  if ( __readgsdword(0xCu) )
  {
    _EDI = (struct timespec *)__readgsdword(0xFFFFFFEC);
    if ( _EDI )
    {
      _ECX = 1;
      v17 = __readgsdword(0xCu) == 0;
      if ( !v17 )
        __asm { lock }
      __asm { cmpxchg [edi], ecx }
      if ( !v17 )
        _lll_lock_wait_private(0, &_EDI->tv_sec, v3, &_EDI->tv_sec);
    }
    else
    {
      _EDI = (struct timespec *)get_free_list(v3);
      if ( !_EDI )
      {
        _EDI = arena_get2_part_5(v3, 0);
        if ( !_EDI )
        {
          tv_sec = 0;
          v21 = 0;
          goto LABEL_7;
        }
      }
    }
    tv_sec = _EDI[7].tv_sec;
    v21 = *(_DWORD *)(tv_sec + 4) & 0xFFFFFFF8;
    if ( _EDI != (struct timespec *)&main_arena )
    {
      v18 = *(_DWORD *)((tv_sec & 0xFFF00000) + 0xC) + (tv_sec & 0xFFF00000) - tv_sec;
      if ( (*(_DWORD *)(tv_sec + 4) & 0xFFFFFFF8) >= v18 )
        v18 = *(_DWORD *)(tv_sec + 4) & 0xFFFFFFF8;
      v21 = v18;
    }
  }
  else
  {
    tv_sec = dword_80CE538;
    _EDI = (struct timespec *)&main_arena;
    v21 = *(_DWORD *)(dword_80CE538 + 4) & 0xFFFFFFF8;
  }
LABEL_7:
  v20 = tv_sec;
  v6 = int_malloc((unsigned int)_EDI, v3, _EDI);
  v7 = (struct timespec *)v20;
  v8 = (struct timespec *)v6;
  if ( v6 )
  {
    v9 = *(v6 - 1);
    if ( (v9 & 2) == 0 )
    {
      v14 = &main_arena;
      if ( (v9 & 4) != 0 )
        v14 = *(int **)((unsigned int)&v8[-1] & 0xFFF00000);
      if ( v14 != (int *)_EDI )
        _malloc_assert(
          (int)"!mem || chunk_is_mmapped (mem2chunk (mem)) || av == arena_for_chunk (mem2chunk (mem))",
          (int)"malloc.c",
          3442,
          (int)"__libc_calloc");
    }
  }
  if ( __readgsdword(0xCu) )
  {
    if ( !v8 && _EDI )
    {
      _EDI = arena_get_retry(&_EDI->tv_sec, (const struct timespec *)v3, v3);
      v19 = int_malloc((unsigned int)_EDI, v3, _EDI);
      v7 = (struct timespec *)v20;
      v8 = (struct timespec *)v19;
    }
    if ( _EDI )
    {
      if ( __readgsdword(0xCu) )
        __asm { lock }
      v17 = _EDI->tv_sec-- == 1;
      if ( !v17 )
        _lll_unlock_wake_private(&_EDI->tv_sec, v3, &_EDI->tv_sec, v8);
    }
  }
  if ( !v8 )
    return 0;
  tv_nsec = v8[-1].tv_nsec;
  if ( (tv_nsec & 2) != 0 )
  {
    if ( perturb_byte )
      return memset((unsigned __int8 *)v8, 0, v3);
  }
  else
  {
    v12 = tv_nsec & 0xFFFFFFF8;
    if ( !perturb_byte && v7 == &v8[-1] && v21 < v12 )
      v12 = v21;
    v13 = v12 - 4;
    if ( v13 <= 0xB )
      _malloc_assert((int)"nclears >= 3", (int)"malloc.c", 3488, (int)"__libc_calloc");
    if ( v13 > 0x27 )
    {
      memset((unsigned __int8 *)v8, 0, v13);
    }
    else
    {
      v8->tv_sec = 0;
      v8->tv_nsec = 0;
      v8[1].tv_sec = 0;
      if ( v13 > 0x13 )
      {
        v8[1].tv_nsec = 0;
        v8[2].tv_sec = 0;
        if ( v13 > 0x1B )
        {
          v8[2].tv_nsec = 0;
          v8[3].tv_sec = 0;
          if ( v13 > 0x23 )
          {
            v8[3].tv_nsec = 0;
            v8[4].tv_sec = 0;
          }
        }
      }
    }
  }
  return (unsigned __int8 *)v8;
}
// 805DFCC: variable 'v7' is possibly undefined
// 80CE4E8: using guessed type int (__cdecl *_malloc_hook)(int);
// 80CE500: using guessed type int main_arena;
// 80CE538: using guessed type int dword_80CE538;
// 80CF88C: using guessed type int perturb_byte;

//----- (0805E260) --------------------------------------------------------
int __usercall malloc_trim@<eax>(int *a1@<edi>, const struct timespec *tv_nsec@<esi>, unsigned int a3)
{
  bool v5; // zf
  int v6; // ebx
  int *v7; // edi
  unsigned int v8; // ebx
  unsigned int v9; // eax
  unsigned int v10; // edx
  unsigned int v11; // eax
  int *v12; // edx
  unsigned int v14; // eax
  signed int v15; // [esp+0h] [ebp-44h]
  int v16; // [esp+4h] [ebp-40h]
  int *v17; // [esp+8h] [ebp-3Ch]
  int v18; // [esp+Ch] [ebp-38h]
  int v19; // [esp+18h] [ebp-2Ch]
  int v20; // [esp+1Ch] [ebp-28h]
  _TBYTE *v21; // [esp+20h] [ebp-24h]
  int v22; // [esp+24h] [ebp-20h]

  if ( *((int *)&GLOBAL_OFFSET_TABLE_ + 289) < 0 )
    ptmalloc_init();
  v22 = 0;
  v21 = &GLOBAL_OFFSET_TABLE_ + 128;
  v17 = (int *)(&GLOBAL_OFFSET_TABLE_ + 128);
  do
  {
    _ECX = 1;
    _EDX = (int)v17;
    v5 = __readgsdword(0xCu) == 0;
    if ( !v5 )
      __asm { lock }
    __asm { cmpxchg [edx], ecx }
    if ( !v5 )
      _lll_lock_wait_private(0, v17, (int)&GLOBAL_OFFSET_TABLE_, a1);
    malloc_consolidate(_EDX);
    v16 = dl_pagesize;
    if ( (unsigned int)dl_pagesize > 0x3EF )
    {
      if ( (unsigned int)dl_pagesize >> 6 > 0x2D )
      {
        if ( (unsigned int)dl_pagesize >> 9 <= 0x14 )
        {
          v15 = ((unsigned int)dl_pagesize >> 9) + 91;
        }
        else if ( (unsigned int)dl_pagesize >> 12 > 0xA )
        {
          if ( (unsigned int)dl_pagesize >> 15 > 4 )
          {
            v14 = (unsigned int)dl_pagesize >> 18;
            if ( (unsigned int)dl_pagesize >> 18 > 2 )
              v14 = 2;
            v15 = v14 + 124;
          }
          else
          {
            v15 = ((unsigned int)dl_pagesize >> 15) + 119;
          }
        }
        else
        {
          v15 = ((unsigned int)dl_pagesize >> 12) + 110;
        }
      }
      else
      {
        v15 = ((unsigned int)dl_pagesize >> 6) + 49;
      }
    }
    else
    {
      v15 = ((unsigned int)dl_pagesize >> 4) + 1;
    }
    v6 = 1;
    v20 = 0;
    v7 = v17 + 14;
    v18 = -dl_pagesize;
    do
    {
      if ( v6 == 1 || v15 <= v6 )
      {
        tv_nsec = (const struct timespec *)v7[3];
        if ( v7 != (int *)tv_nsec )
        {
          v19 = v6;
          v8 = v16 + 23;
          do
          {
            v9 = tv_nsec->tv_nsec & 0xFFFFFFF8;
            if ( v9 > v8 )
            {
              v10 = v18 & ((unsigned int)tv_nsec + v8);
              if ( v10 < (unsigned int)&tv_nsec[3] )
                _malloc_assert(
                  (int)&GLOBAL_OFFSET_TABLE_ - 174024,
                  (int)&GLOBAL_OFFSET_TABLE_ - 177883,
                  4796,
                  (int)&GLOBAL_OFFSET_TABLE_ - 173888);
              if ( v10 >= (unsigned int)tv_nsec + v9 )
                _malloc_assert(
                  (int)&GLOBAL_OFFSET_TABLE_ - 173968,
                  (int)&GLOBAL_OFFSET_TABLE_ - 177883,
                  4797,
                  (int)&GLOBAL_OFFSET_TABLE_ - 173888);
              v11 = v9 - (v10 - (_DWORD)tv_nsec);
              if ( v16 - 1 < v11 )
              {
                madvise((void *)(v18 & ((unsigned int)tv_nsec + v8)), v18 & v11, 4);
                v20 = 1;
              }
            }
            tv_nsec = (const struct timespec *)tv_nsec[1].tv_nsec;
          }
          while ( v7 != (int *)tv_nsec );
          v6 = v19;
        }
      }
      ++v6;
      v7 += 2;
    }
    while ( v6 != 128 );
    if ( v17 == (int *)v21 )
      v20 |= systrim_isra_1_constprop_11(a3);
    a1 = (int *)v20;
    v12 = v17;
    v22 |= v20;
    if ( __readgsdword(0xCu) )
      __asm { lock }
    v5 = (*v17)-- == 1;
    if ( !v5 )
      _lll_unlock_wake_private(v17, (int)&GLOBAL_OFFSET_TABLE_, (int *)v20, tv_nsec);
    v17 = (int *)v12[274];
  }
  while ( v17 != (int *)v21 );
  return v22;
}
// 805E2C8: variable '_EDX' is possibly undefined
// 805E4A1: variable 'v12' is possibly undefined
// 80CE000: using guessed type _TBYTE GLOBAL_OFFSET_TABLE_;
// 80CE9B0: using guessed type int dl_pagesize;

//----- (0805E4F0) --------------------------------------------------------
struct timespec *__cdecl malloc_usable_size(int a1)
{
  int v1; // ebp
  unsigned int v2; // edx
  struct timespec *result; // eax
  int v4; // eax
  unsigned int v5; // edx
  unsigned int v6; // esi
  unsigned int v7; // eax
  int v8; // edx
  int v9; // [esp+0h] [ebp-20h]

  if ( !a1 )
    return 0;
  v9 = a1 - 8;
  v1 = *(_DWORD *)(a1 - 4) & 2;
  v2 = *(_DWORD *)(a1 - 4) & 0xFFFFFFF8;
  if ( using_malloc_checking == 1 )
  {
    v6 = ((unsigned int)(a1 - 8) >> 11) ^ ((unsigned int)(a1 - 8) >> 3);
    if ( ((unsigned __int8)((unsigned int)(a1 - 8) >> 11) ^ (unsigned __int8)((unsigned int)(a1 - 8) >> 3)) == 1 )
      LOBYTE(v6) = 2;
    v7 = v2 + 4 * (v1 == 0) - 1;
    v8 = *(unsigned __int8 *)(a1 + v7 - 8);
    if ( (_BYTE)v8 != (_BYTE)v6 )
    {
      if ( !(_BYTE)v8 || v7 < v8 + 8 )
      {
LABEL_18:
        malloc_printerr((unsigned __int8)&aMallocCheckGet[-135061504] + (unsigned __int8)&GLOBAL_OFFSET_TABLE_);
        return mallinfo((struct timespec *)a1);
      }
      while ( 1 )
      {
        v7 -= v8;
        v8 = *(unsigned __int8 *)(v9 + v7);
        if ( (_BYTE)v8 == (_BYTE)v6 )
          break;
        if ( !(_BYTE)v8 || v8 + 8 > v7 )
          goto LABEL_18;
      }
    }
    return (struct timespec *)(v7 - 8);
  }
  result = (struct timespec *)((*(_DWORD *)(a1 - 4) & 0xFFFFFFF8) - 8);
  if ( !v1 )
  {
    v4 = *(_DWORD *)(v9 + v2 + 4);
    v5 = v2 - 4;
    result = (struct timespec *)(v4 & 1);
    if ( result )
      return (struct timespec *)v5;
  }
  return result;
}
// 80CE000: using guessed type _TBYTE GLOBAL_OFFSET_TABLE_;
// 80CF878: using guessed type int using_malloc_checking;

//----- (0805E5D0) --------------------------------------------------------
struct timespec *__stdcall mallinfo(struct timespec *a1)
{
  bool v3; // zf
  struct timespec v5[5]; // [esp+0h] [ebp-48h] BYREF
  unsigned int v6; // [esp+28h] [ebp-20h]

  v6 = __readgsdword(0x14u);
  if ( _libc_malloc_initialized < 0 )
    ptmalloc_init();
  memset(v5, 0, sizeof(v5));
  _EBX = &main_arena;
  do
  {
    _ECX = 1;
    v3 = __readgsdword(0xCu) == 0;
    if ( !v3 )
      __asm { lock }
    __asm { cmpxchg dword ptr ds:(_GLOBAL_OFFSET_TABLE_ - 80CE000h)[ebx], ecx }
    if ( !v3 )
      _lll_lock_wait_private(0, _EBX, (int)a1, &main_arena);
    int_mallinfo((int)_EBX, v5);
    if ( __readgsdword(0xCu) )
      __asm { lock }
    v3 = (*_EBX)-- == 1;
    if ( !v3 )
      _lll_unlock_wake_private(_EBX, (int)a1, &main_arena, v5);
    _EBX = *(int **)((char *)_EBX + (_DWORD)(&dword_80CE448 - 33765376));
  }
  while ( _EBX != &main_arena );
  *a1 = v5[0];
  a1[1] = v5[1];
  a1[2] = v5[2];
  a1[3] = v5[3];
  a1[4] = v5[4];
  return a1;
}
// 80CE448: using guessed type int dword_80CE448;
// 80CE484: using guessed type int _libc_malloc_initialized;
// 80CE500: using guessed type int main_arena;

//----- (0805E6E0) --------------------------------------------------------
unsigned int malloc_stats()
{
  int v0; // ebp
  bool v3; // zf
  int *v4; // edi
  _TBYTE *v5; // edi
  int v7; // [esp+4h] [ebp-6Ch]
  int v8; // [esp+8h] [ebp-68h]
  unsigned int *v9; // [esp+Ch] [ebp-64h]
  unsigned int *v10; // [esp+10h] [ebp-60h]
  int v11; // [esp+20h] [ebp-50h]
  int v12[10]; // [esp+28h] [ebp-48h] BYREF
  int v13[8]; // [esp+50h] [ebp-20h] BYREF

  v13[0] = __readgsdword(0x14u);
  v7 = dword_80CE4C4;
  if ( _libc_malloc_initialized < 0 )
    ptmalloc_init();
  v0 = 0;
  v11 = *((_DWORD *)stderr + 15);
  *((_DWORD *)stderr + 15) = v11 | 2;
  v8 = v7;
  _EBX = (int *)(&GLOBAL_OFFSET_TABLE_ + 128);
  v9 = (unsigned int *)((char *)&GLOBAL_OFFSET_TABLE_ - 177337);
  v10 = (unsigned int *)((char *)&GLOBAL_OFFSET_TABLE_ - 177312);
  while ( 1 )
  {
    memset(v12, 0, sizeof(v12));
    _ECX = 1;
    v3 = __readgsdword(0xCu) == 0;
    if ( !v3 )
      __asm { lock }
    __asm { cmpxchg [ebx], ecx }
    if ( !v3 )
      _lll_lock_wait_private(0, _EBX, v0, v13);
    int_mallinfo((int)_EBX, v12);
    fprintf((int)_EBX, (int)&stderr, (int)stderr, (unsigned int *)&GLOBAL_OFFSET_TABLE_ - 44337, v0);
    fprintf((int)_EBX, (int)&stderr, (int)stderr, v9, v12[0]);
    fprintf((int)_EBX, (int)&stderr, (int)stderr, v10, v12[7]);
    v4 = (int *)v12[7];
    v7 += v12[0];
    v8 += v12[7];
    if ( __readgsdword(0xCu) )
      __asm { lock }
    v3 = (*_EBX)-- == 1;
    if ( !v3 )
      _lll_unlock_wake_private(_EBX, v0, v4, (const struct timespec *)&stderr);
    _EBX = (int *)_EBX[274];
    if ( _EBX == (int *)(&GLOBAL_OFFSET_TABLE_ + 128) )
      break;
    ++v0;
  }
  v5 = &GLOBAL_OFFSET_TABLE_;
  fwrite((int)&GLOBAL_OFFSET_TABLE_ - 177287, 1u, 20, (const struct timespec *)stderr);
  fprintf((int)&GLOBAL_OFFSET_TABLE_, (int)&stderr, (int)stderr, v9, v7);
  fprintf((int)&GLOBAL_OFFSET_TABLE_, (int)&stderr, (int)stderr, v10, v8);
  fprintf(
    (int)&GLOBAL_OFFSET_TABLE_,
    (int)&stderr,
    (int)stderr,
    (unsigned int *)((char *)v5 - 177266),
    *((_DWORD *)v5 + 303));
  fprintf(
    (int)&GLOBAL_OFFSET_TABLE_,
    (int)&stderr,
    (int)stderr,
    (unsigned int *)((char *)v5 - 177241),
    *((_DWORD *)v5 + 306));
  *((_DWORD *)stderr + 15) = v11;
  return __readgsdword(0x14u) ^ v13[0];
}
// 80CE000: using guessed type _TBYTE GLOBAL_OFFSET_TABLE_;
// 80CE474: using guessed type void *stderr;
// 80CE484: using guessed type int _libc_malloc_initialized;
// 80CE4C4: using guessed type int dword_80CE4C4;
// 805E6E0: using guessed type unsigned int var_20[8];

//----- (0805E8C0) --------------------------------------------------------
int __usercall mallopt@<eax>(int a1@<ebp>, int *a2, const struct timespec *a3)
{
  bool v5; // zf
  int v6; // edx

  _EBX = &GLOBAL_OFFSET_TABLE_;
  if ( _libc_malloc_initialized < 0 )
    ptmalloc_init();
  _ECX = 1;
  v5 = __readgsdword(0xCu) == 0;
  if ( !v5 )
    __asm { lock }
  __asm { cmpxchg (main_arena - 80CE000h)[ebx], ecx }
  if ( !v5 )
    _lll_lock_wait_private(0, &main_arena, a1, a2);
  malloc_consolidate((int)&main_arena);
  if ( (unsigned int)(a2 + 2) <= 9 )
    __asm { jmp     ecx }
  v6 = 1;
  if ( __readgsdword(0xCu) )
    __asm { lock }
  if ( --main_arena )
    _lll_unlock_wake_private(&main_arena, a1, a2, a3);
  return v6;
}
// 805E976: variable 'v6' is possibly undefined
// 80CE000: using guessed type _TBYTE GLOBAL_OFFSET_TABLE_;
// 80CE484: using guessed type int _libc_malloc_initialized;
// 80CE500: using guessed type int main_arena;

//----- (0805EA70) --------------------------------------------------------
int __cdecl posix_memalign(int *a1, unsigned int a2, struct timespec *a3)
{
  int *v3; // edx
  int result; // eax
  int retaddr; // [esp+Ch] [ebp+0h]

  if ( a2 & 3 | (a2 >> 2) & ((a2 >> 2) - 1) || !a2 )
    return 22;
  v3 = mid_memalign(a2, a3, retaddr);
  result = 12;
  if ( v3 )
  {
    *a1 = (int)v3;
    return 0;
  }
  return result;
}

//----- (0805EAD0) --------------------------------------------------------
int __usercall malloc_info@<eax>(int a1@<ebx>, int a2@<ebp>, int a3, const struct timespec *a4)
{
  if ( a3 )
    return 22;
  if ( _libc_malloc_initialized < 0 )
    ptmalloc_init();
  fputs((unsigned int *)"<malloc version=\"1\">\n", a4);
  return _malloc_info_part_10(a4, a1, a2, (const struct timespec *)&GLOBAL_OFFSET_TABLE_);
}
// 805EAD0: could not find valid save-restore pair for ebx
// 80CE000: using guessed type _TBYTE GLOBAL_OFFSET_TABLE_;
// 80CE484: using guessed type int _libc_malloc_initialized;

//----- (0805EB40) --------------------------------------------------------
unsigned int __cdecl _default_morecore(int a1)
{
  unsigned int result; // eax

  result = sbrk(a1);
  if ( result == -1 )
    return 0;
  return result;
}

//----- (0805EB60) --------------------------------------------------------
_DWORD *__cdecl strchr(_BYTE *a1, int a2)
{
  _DWORD *result; // eax
  int v3; // edx
  __int16 v4; // cx
  int v5; // edx
  unsigned int v6; // ecx
  unsigned int v7; // ecx
  unsigned int v8; // ecx
  unsigned int v9; // ecx
  unsigned int v10; // ecx

  result = a1;
  v3 = a2;
  BYTE1(v3) = a2;
  v4 = v3;
  v5 = v3 << 16;
  LOWORD(v5) = v4;
  if ( ((unsigned __int8)a1 & 3) == 0 )
  {
LABEL_12:
    while ( 1 )
    {
      v6 = v5 ^ *result;
      if ( v6 < 0x1010101 || (v6 ^ (v6 - 16843009) | 0xFEFEFEFF) != -1 )
        break;
      if ( *result < 0x1010101u || (*result ^ (*result - 16843009) | 0xFEFEFEFF) != -1 )
        return 0;
      v6 = v5 ^ result[1];
      if ( v6 < 0x1010101 || (v6 ^ (v6 - 16843009) | 0xFEFEFEFF) != -1 )
        goto LABEL_31;
      v7 = result[1];
      if ( v7 < 0x1010101 || (v7 ^ (v7 - 16843009) | 0xFEFEFEFF) != -1 )
        return 0;
      v6 = v5 ^ result[2];
      if ( v6 < 0x1010101 || (v6 ^ (v6 - 16843009) | 0xFEFEFEFF) != -1 )
        goto LABEL_30;
      v8 = result[2];
      if ( v8 < 0x1010101 || (v8 ^ (v8 - 16843009) | 0xFEFEFEFF) != -1 )
        return 0;
      v6 = v5 ^ result[3];
      if ( v6 < 0x1010101 || (v6 ^ (v6 - 16843009) | 0xFEFEFEFF) != -1 )
      {
        ++result;
LABEL_30:
        ++result;
LABEL_31:
        ++result;
        break;
      }
      v9 = result[3];
      if ( v9 < 0x1010101 || (v9 ^ (v9 - 16843009) | 0xFEFEFEFF) != -1 )
        return 0;
      result += 4;
    }
    if ( !(_BYTE)v6 )
      return result;
    if ( (_BYTE)v6 != (_BYTE)v5 )
    {
      result = (_DWORD *)((char *)result + 1);
      if ( !BYTE1(v6) )
        return result;
      if ( BYTE1(v6) != (_BYTE)v5 )
      {
        result = (_DWORD *)((char *)result + 1);
        v10 = HIWORD(v6);
        if ( !(_BYTE)v10 )
          return result;
        if ( (_BYTE)v10 != (_BYTE)v5 )
          return (_DWORD *)((char *)result + 1);
      }
    }
    return 0;
  }
  if ( (_BYTE)v4 == *a1 )
    return result;
  if ( !*a1 )
    return 0;
  result = a1 + 1;
  if ( (((_BYTE)a1 + 1) & 3) == 0 )
    goto LABEL_12;
  if ( (_BYTE)v4 == *(_BYTE *)result )
    return result;
  if ( !*(_BYTE *)result )
    return 0;
  result = a1 + 2;
  if ( (((_BYTE)a1 + 2) & 3) == 0 )
    goto LABEL_12;
  if ( (_BYTE)v4 != *(_BYTE *)result )
  {
    if ( *(_BYTE *)result )
    {
      result = a1 + 3;
      goto LABEL_12;
    }
    return 0;
  }
  return result;
}

//----- (0805ECD0) --------------------------------------------------------
int __cdecl strcmp(char *a1, _BYTE *a2)
{
  char v4; // al
  int result; // eax

  while ( 1 )
  {
    v4 = *a1;
    if ( *a1 != *a2 )
      break;
    ++a1;
    ++a2;
    if ( !v4 )
      return 0;
  }
  result = 1;
  if ( (unsigned __int8)*a1 < *a2 )
    return -1;
  return result;
}

//----- (0805ED00) --------------------------------------------------------
_BYTE *__cdecl strcpy(_BYTE *a1, unsigned int *a2)
{
  int v2; // eax

  v2 = strlen(a2);
  return memcpy(a1, a2, v2 + 1);
}

//----- (0805ED40) --------------------------------------------------------
_BYTE *__cdecl strcspn(int a1, _BYTE *a2)
{
  int v3; // ecx
  _BYTE *v4; // eax
  char v6[256]; // [esp+0h] [ebp-100h] BYREF

  v3 = 0;
  memset(v6, 0, sizeof(v6));
  do
  {
    if ( !*a2 )
      break;
    LOBYTE(v3) = *a2;
    v6[v3] = *a2;
    LOBYTE(v3) = a2[1];
    if ( !(_BYTE)v3 )
      break;
    v6[v3] = v3;
    LOBYTE(v3) = a2[2];
    if ( !(_BYTE)v3 )
      break;
    v6[v3] = v3;
    LOBYTE(v3) = a2[3];
    a2 += 4;
    v6[v3] = v3;
  }
  while ( (_BYTE)v3 );
  v4 = (_BYTE *)(a1 - 4);
  while ( 1 )
  {
    v4 += 4;
    LOBYTE(v3) = *v4;
    if ( v6[v3] == *v4 )
      return &v4[-a1];
    LOBYTE(v3) = v4[1];
    if ( v6[v3] == (_BYTE)v3 )
      goto LABEL_13;
    LOBYTE(v3) = v4[2];
    if ( v6[v3] == (_BYTE)v3 )
      goto LABEL_12;
    LOBYTE(v3) = v4[3];
    if ( v6[v3] == (_BYTE)v3 )
    {
      ++v4;
LABEL_12:
      ++v4;
LABEL_13:
      ++v4;
      return &v4[-a1];
    }
  }
}
// 805ED40: using guessed type char var_100[256];

//----- (0805EE00) --------------------------------------------------------
int *__cdecl strdup(unsigned int *a1)
{
  const struct timespec *v1; // esi
  int *result; // eax

  v1 = (const struct timespec *)(strlen(a1) + 1);
  result = malloc(v1);
  if ( result )
    return (int *)memcpy(result, a1, (unsigned int)v1);
  return result;
}

//----- (0805EE50) --------------------------------------------------------
int __cdecl strlen(unsigned int *a1)
{
  unsigned int *v1; // eax
  int v2; // ecx
  int v3; // ecx
  int v4; // ecx
  unsigned int v5; // ecx

  v1 = a1;
  v2 = (unsigned __int8)a1 & 3;
  if ( ((unsigned __int8)a1 & 3) == 0 )
    goto LABEL_9;
  if ( *(_BYTE *)a1 != BYTE1(v2) )
  {
    v1 = (unsigned int *)((char *)a1 + 1);
    v3 = v2 ^ 3;
    if ( !v3 )
      goto LABEL_9;
    if ( *(_BYTE *)v1 != BYTE1(v3) )
    {
      v1 = (unsigned int *)((char *)a1 + 2);
      v4 = v3 - 1;
      if ( !v4 )
        goto LABEL_9;
      if ( *(_BYTE *)v1 != BYTE1(v4) )
      {
        v1 = (unsigned int *)((char *)a1 - 13);
        while ( 1 )
        {
          v1 += 4;
LABEL_9:
          v5 = *v1;
          if ( *v1 < 0x1010101 || (v5 ^ (*v1 - 16843009) | 0xFEFEFEFF) != -1 )
            break;
          v5 = v1[1];
          if ( v5 < 0x1010101 || (v5 ^ (v5 - 16843009) | 0xFEFEFEFF) != -1 )
            goto LABEL_19;
          v5 = v1[2];
          if ( v5 < 0x1010101 || (v5 ^ (v5 - 16843009) | 0xFEFEFEFF) != -1 )
            goto LABEL_18;
          v5 = v1[3];
          if ( v5 < 0x1010101 || (v5 ^ (v5 - 16843009) | 0xFEFEFEFF) != -1 )
          {
            ++v1;
LABEL_18:
            ++v1;
LABEL_19:
            ++v1;
            break;
          }
        }
        if ( (_BYTE)v5 )
        {
          v1 = (unsigned int *)((char *)v1 + 1);
          if ( BYTE1(v5) )
          {
            v1 = (unsigned int *)((char *)v1 + 1);
            if ( (v5 & 0xFF0000) != 0 )
              v1 = (unsigned int *)((char *)v1 + 1);
          }
        }
      }
    }
  }
  return (char *)v1 - (char *)a1;
}

//----- (0805EF10) --------------------------------------------------------
int __cdecl strncmp(unsigned __int8 *a1, unsigned __int8 *a2, unsigned int a3)
{
  unsigned int v3; // esi
  unsigned __int8 *v4; // ecx
  int v6; // eax
  unsigned __int8 v7; // di
  unsigned __int8 *v8; // ebp
  unsigned __int8 *v9; // ecx
  unsigned __int8 *v10; // esi

  v3 = a3;
  v4 = a1;
  if ( a3 <= 3 )
  {
    v7 = 0;
    v6 = 0;
LABEL_13:
    if ( v3 )
    {
      v7 = *a2;
      v6 = *v4;
      v8 = v4 + 1;
      v9 = a2 + 1;
      if ( (_BYTE)v6 == *a2 )
      {
        v10 = &a2[v3];
        if ( (_BYTE)v6 )
        {
          do
          {
            if ( v10 == v9 )
              break;
            v6 = *v8++;
            v7 = *v9++;
            if ( !(_BYTE)v6 )
              break;
          }
          while ( (_BYTE)v6 == v7 );
        }
      }
    }
  }
  else
  {
    while ( 1 )
    {
      v6 = *v4;
      v7 = *a2;
      if ( !(_BYTE)v6 )
        break;
      if ( (_BYTE)v6 != v7 )
        break;
      v6 = v4[1];
      v7 = a2[1];
      if ( !(_BYTE)v6 )
        break;
      if ( (_BYTE)v6 != v7 )
        break;
      v6 = v4[2];
      v7 = a2[2];
      if ( !(_BYTE)v6 )
        break;
      if ( (_BYTE)v6 != v7 )
        break;
      v4 += 4;
      v6 = *(v4 - 1);
      a2 += 4;
      v7 = *(a2 - 1);
      if ( !(_BYTE)v6 || (_BYTE)v6 != v7 )
        break;
      if ( v4 == &a1[a3 & 0xFFFFFFFC] )
      {
        v3 = a3 & 3;
        goto LABEL_13;
      }
    }
  }
  return v6 - v7;
}

//----- (0805EFF0) --------------------------------------------------------
unsigned int __usercall critical_factorization@<eax>(int a1@<eax>, unsigned int a2@<edx>, int *a3@<ecx>)
{
  int v3; // ebp
  int v4; // esi
  int v5; // ebx
  int v6; // ecx
  unsigned __int8 v7; // dl
  int v8; // ebx
  int v9; // esi
  int v10; // edi
  unsigned int v11; // ecx
  unsigned __int8 v12; // dl
  unsigned int v13; // edi
  unsigned int result; // eax
  int v15; // [esp+0h] [ebp-20h]
  int v17; // [esp+8h] [ebp-18h]

  v3 = 1;
  v4 = 0;
  v5 = 1;
  v15 = -1;
  while ( 1 )
  {
    v6 = v4 + v5;
    if ( v4 + v5 >= a2 )
      break;
    while ( 1 )
    {
      v7 = *(_BYTE *)(a1 + v15 + v5);
      if ( *(_BYTE *)(a1 + v6) >= v7 )
        break;
      v4 = v6;
      v5 = 1;
      v3 = v6 - v15;
      if ( ++v6 >= a2 )
        goto LABEL_5;
    }
    if ( *(_BYTE *)(a1 + v6) == v7 )
    {
      if ( v5 == v3 )
      {
        v4 = v6;
        v5 = 1;
      }
      else
      {
        ++v5;
      }
    }
    else
    {
      v15 = v4;
      v3 = 1;
      ++v4;
      v5 = 1;
    }
  }
LABEL_5:
  v17 = 1;
  v8 = 1;
  v9 = 0;
  *a3 = v3;
  v10 = -1;
  while ( 1 )
  {
    v11 = v9 + v8;
    if ( v9 + v8 >= a2 )
      break;
    while ( 1 )
    {
      v12 = *(_BYTE *)(a1 + v10 + v8);
      if ( *(_BYTE *)(a1 + v11) <= v12 )
        break;
      v8 = 1;
      v17 = v11 - v10;
      v9 = v11++;
      if ( v11 >= a2 )
        goto LABEL_9;
    }
    if ( *(_BYTE *)(a1 + v11) == v12 )
    {
      if ( v8 == v17 )
      {
        v9 = v11;
        v8 = 1;
      }
      else
      {
        ++v8;
      }
    }
    else
    {
      v10 = v9;
      v17 = 1;
      ++v9;
      v8 = 1;
    }
  }
LABEL_9:
  v13 = v10 + 1;
  result = v15 + 1;
  if ( v13 >= v15 + 1 )
  {
    *a3 = v17;
    return v13;
  }
  return result;
}

//----- (0805F140) --------------------------------------------------------
int __usercall two_way_long_needle@<eax>(int a1@<eax>, unsigned int a2@<edx>, unsigned int *a3@<ecx>, unsigned int a4)
{
  int *v5; // eax
  unsigned int *v6; // eax
  int v7; // edx
  char *v8; // ecx
  int i; // ebx
  unsigned int v10; // ecx
  unsigned int v11; // ebp
  unsigned int v12; // eax
  unsigned int v13; // eax
  unsigned int v14; // edx
  unsigned int v16; // eax
  unsigned int v17; // ebp
  int v18; // eax
  unsigned int v19; // eax
  unsigned int v20; // eax
  unsigned int v23; // [esp+8h] [ebp-448h]
  unsigned int v24; // [esp+Ch] [ebp-444h]
  unsigned int v25; // [esp+14h] [ebp-43Ch]
  unsigned int v26; // [esp+14h] [ebp-43Ch]
  unsigned int v27; // [esp+2Ch] [ebp-424h] BYREF
  int v28[256]; // [esp+30h] [ebp-420h] BYREF
  unsigned int v29; // [esp+430h] [ebp-20h] BYREF

  v29 = __readgsdword(0x14u);
  v24 = critical_factorization((int)a3, a4, (int *)&v27);
  v5 = v28;
  do
    *v5++ = a4;
  while ( v5 != (int *)&v29 );
  if ( a4 )
  {
    v6 = a3;
    do
    {
      v7 = *(unsigned __int8 *)v6;
      v8 = (char *)((char *)a3 + a4 - 1 - (char *)v6);
      v6 = (unsigned int *)((char *)v6 + 1);
      v28[v7] = (int)v8;
    }
    while ( (unsigned int *)((char *)a3 + a4) != v6 );
  }
  v25 = v27;
  if ( !memcmp(a3, (unsigned int *)((char *)a3 + v27), v24) )
  {
    v23 = 0;
    for ( i = 0; ; i = v13 + i - v24 + 1 )
    {
      while ( 1 )
      {
        v10 = a2;
        v11 = i + a4;
        if ( i + a4 <= a2 )
          goto LABEL_10;
LABEL_9:
        a2 = strnlen((_BYTE *)(v10 + a1), a4 + 512) + v10;
        if ( v11 > a2 )
          return 0;
LABEL_10:
        while ( 1 )
        {
          v12 = v28[*(unsigned __int8 *)(a1 + v11 - 1)];
          if ( !v12 )
            break;
          if ( v23 )
          {
            if ( v25 > v12 )
              v12 = a4 - v25;
          }
          i += v12;
          v10 = a2;
          v23 = 0;
          v11 = i + a4;
          if ( i + a4 > a2 )
            goto LABEL_9;
        }
        v13 = v24;
        if ( v23 >= v24 )
          v13 = v23;
        if ( v13 < a4 - 1 )
          break;
LABEL_23:
        v14 = v24 - 1;
        if ( v23 >= v24 )
        {
          v14 = v24;
        }
        else if ( *(_BYTE *)(a1 + i + v24 - 1) == *((_BYTE *)a3 + v24 - 1) )
        {
          while ( v23 != v14 && *((_BYTE *)a3 + v14 - 1) == *(_BYTE *)(v14 + a1 + i - 1) )
            --v14;
        }
        else
        {
          v14 = v24;
        }
        if ( v23 + 1 > v14 )
          return i + a1;
        i += v25;
        v23 = a4 - v25;
      }
      if ( *(_BYTE *)(a1 + i + v13) == *((_BYTE *)a3 + v13) )
      {
        while ( ++v13 < a4 - 1 )
        {
          if ( *((_BYTE *)a3 + v13) != *(_BYTE *)(a1 + i + v13) )
            goto LABEL_31;
        }
        goto LABEL_23;
      }
LABEL_31:
      v23 = 0;
    }
  }
  v16 = a4 - v24;
  if ( a4 - v24 < v24 )
    v16 = v24;
  i = 0;
  v26 = v16 + 1;
  v27 = v16 + 1;
  while ( 1 )
  {
    while ( 1 )
    {
      while ( 1 )
      {
        v17 = i + a4;
        if ( i + a4 > a2 )
        {
          a2 += strnlen((_BYTE *)(a2 + a1), a4 + 512);
          if ( v17 > a2 )
            return 0;
        }
        v18 = v28[*(unsigned __int8 *)(a1 + v17 - 1)];
        if ( !v18 )
          break;
        i += v18;
      }
      if ( v24 >= a4 - 1 )
        break;
      if ( *((_BYTE *)a3 + v24) == *(_BYTE *)(a1 + i + v24) )
      {
        v19 = v24;
        while ( ++v19 < a4 - 1 )
        {
          if ( *((_BYTE *)a3 + v19) != *(_BYTE *)(i + a1 + v19) )
            goto LABEL_51;
        }
        break;
      }
      v19 = v24;
LABEL_51:
      i += v19 + 1 - v24;
    }
    v20 = v24 - 1;
    if ( !v24 )
      return i + a1;
    if ( *((_BYTE *)a3 + v24 - 1) == *(_BYTE *)(a1 + i + v24 - 1) )
      break;
LABEL_52:
    i += v26;
  }
  while ( --v20 != -1 )
  {
    if ( *((_BYTE *)a3 + v20) != *(_BYTE *)(v20 + a1 + i) )
      goto LABEL_52;
  }
  return i + a1;
}
// 805F140: using guessed type int var_420[256];

//----- (0805F500) --------------------------------------------------------
char *__cdecl strstr(char *a1, unsigned int *a2)
{
  char v2; // cl
  char v3; // al
  unsigned int *v4; // ebx
  char *v5; // edx
  char v6; // si
  bool v7; // al
  unsigned int v8; // esi
  char *v9; // eax
  char *v10; // edx
  bool v11; // cf
  unsigned int v12; // eax
  unsigned int v14; // edi
  int i; // ebx
  unsigned int v16; // ebp
  unsigned int v17; // eax
  unsigned int v18; // eax
  unsigned int v19; // edx
  unsigned int v20; // eax
  int v21; // edi
  char *v22; // edx
  char *v23; // eax
  char *v24; // eax
  char *v25; // edi
  unsigned int v26; // edx
  char *v27; // ecx
  char v28; // al
  unsigned int v29; // eax
  char *v30; // ecx
  char v31; // dl
  int v32; // eax
  char *v33; // [esp+0h] [ebp-4Ch]
  char v34; // [esp+4h] [ebp-48h]
  unsigned int v35; // [esp+4h] [ebp-48h]
  unsigned int v36; // [esp+8h] [ebp-44h]
  unsigned __int8 v37; // [esp+Ch] [ebp-40h]
  unsigned int v38; // [esp+10h] [ebp-3Ch]
  int v39; // [esp+14h] [ebp-38h]
  int v40[9]; // [esp+28h] [ebp-24h] BYREF

  v2 = *(_BYTE *)a2;
  v40[1] = __readgsdword(0x14u);
  v3 = *a1;
  v34 = v2;
  if ( !*a1 )
  {
    v32 = 0;
    if ( !v2 )
      return a1;
    return (char *)v32;
  }
  if ( !v2 )
    return a1;
  v4 = a2;
  v5 = a1;
  v6 = 1;
  while ( 1 )
  {
    ++v5;
    v4 = (unsigned int *)((char *)v4 + 1);
    v7 = v3 == v2;
    v2 = *(_BYTE *)v4;
    v6 &= v7;
    v3 = *v5;
    if ( !*v5 )
      break;
    if ( !v2 )
      goto LABEL_7;
  }
  v33 = 0;
  if ( v2 )
    return v33;
LABEL_7:
  v33 = a1;
  if ( v6 )
    return v33;
  v8 = (char *)v4 - (char *)a2;
  v9 = (char *)strchr(a1 + 1, v34);
  v33 = v9;
  if ( !v9 || v8 == 1 )
    return v33;
  v10 = (char *)(&a1[v8] - v9);
  v11 = &a1[v8] < v9;
  v12 = 1;
  if ( !v11 )
    v12 = (unsigned int)v10;
  v35 = v12;
  if ( v8 > 0x1F )
    return (char *)two_way_long_needle((int)v33, v12, a2, v8);
  v36 = critical_factorization((int)a2, v8, v40);
  v39 = v40[0];
  if ( !memcmp(a2, (unsigned int *)((char *)a2 + v40[0]), v36) )
  {
    v14 = 0;
    for ( i = 0; ; i = v18 + i - v36 + 1 )
    {
      while ( 1 )
      {
        v16 = v35;
        if ( v8 + i > v35 )
        {
          v17 = strnlen(&v33[v35], v8 + 512);
          v35 += v17;
          if ( v8 + i > v17 + v16 )
            return 0;
        }
        v18 = v36;
        if ( v36 < v14 )
          v18 = v14;
        if ( v8 > v18 )
          break;
LABEL_26:
        v19 = v36 - 1;
        if ( v36 > v14 && *((_BYTE *)a2 + v36 - 1) == v33[i - 1 + v36] )
        {
          while ( v14 != v19 && *((_BYTE *)a2 + v19 - 1) == v33[i - 1 + v19] )
            --v19;
        }
        else
        {
          v19 = v36;
        }
        if ( v14 + 1 > v19 )
        {
          v33 += i;
          return v33;
        }
        i += v39;
        v14 = v8 - v39;
      }
      if ( v33[v18 + i] == *((_BYTE *)a2 + v18) )
      {
        while ( v8 != ++v18 )
        {
          if ( *((_BYTE *)a2 + v18) != v33[i + v18] )
            goto LABEL_34;
        }
        goto LABEL_26;
      }
LABEL_34:
      v14 = 0;
    }
  }
  v37 = *((_BYTE *)a2 + v36);
  v20 = v8 - v36;
  if ( v8 - v36 < v36 )
    v20 = v36;
  v21 = 0;
  v38 = v20 + 1;
  v40[0] = v20 + 1;
  while ( 1 )
  {
    while ( 1 )
    {
      if ( v8 + v21 > v35 )
      {
        v35 += strnlen(&v33[v35], v8 + 512);
        if ( v8 + v21 > v35 )
          return 0;
      }
      v22 = &v33[v36 + v21];
      v23 = v22 + 1;
      if ( v37 != *v22 )
      {
        v24 = (char *)strchr(v23, v37);
        if ( !v24 )
          return 0;
        v25 = v24;
        v23 = v24 + 1;
        v21 = v25 - &v33[v36];
      }
      v26 = v36 + 1;
      if ( v8 <= v36 + 1 )
      {
        v27 = v23;
        goto LABEL_49;
      }
      v27 = v23 + 1;
      v28 = *v23;
      if ( v28 == *((_BYTE *)a2 + v36 + 1) )
      {
        while ( v8 > ++v26 )
        {
          v28 = *v27++;
          if ( *((_BYTE *)a2 + v26) != v28 )
            goto LABEL_56;
        }
LABEL_49:
        if ( v27 <= &v33[v35] )
          break;
LABEL_58:
        v35 = v27 - v33;
        goto LABEL_59;
      }
LABEL_56:
      if ( !v28 )
        return 0;
      if ( v27 > &v33[v35] )
        goto LABEL_58;
LABEL_59:
      if ( v8 <= v26 )
        break;
      v21 = v26 + v21 - v36 + 1;
    }
    v29 = v36 - 1;
    v30 = &v33[v36 - 1 + v21];
    if ( !v36 )
      goto LABEL_55;
    v31 = *v30;
    if ( *((_BYTE *)a2 + v36 - 1) == *v30 )
      break;
LABEL_61:
    if ( !v31 )
      return 0;
    v21 += v38;
  }
  while ( --v29 != -1 )
  {
    v31 = v33[v21 + v29];
    if ( *((_BYTE *)a2 + v29) != v31 )
      goto LABEL_61;
  }
LABEL_55:
  v33 += v21;
  return v33;
}

//----- (0805F930) --------------------------------------------------------
int __cdecl memcmp(unsigned int *a1, unsigned int *a2, int a3)
{
  unsigned int *v3; // edx
  int v4; // ecx
  unsigned int *v6; // esi
  unsigned int v7; // eax
  unsigned int v8; // ecx
  bool v9; // cf
  unsigned int v10; // eax
  unsigned int v11; // ecx

  v3 = a2;
  v4 = a3;
  if ( a3 == 1 )
  {
    if ( *(_BYTE *)a1 == *(_BYTE *)a2 )
      return 0;
    return -(*(_BYTE *)a1 < *(_BYTE *)a2) - ((*(_BYTE *)a1 < *(_BYTE *)a2) - 1);
  }
  else
  {
    if ( a3 < 1 )
      return 0;
    v6 = a1;
    if ( a3 < 32 )
      __asm { jmp     ebx }
    while ( 1 )
    {
      v4 -= 32;
      v7 = *v6;
      if ( *v6 != *v3 )
        break;
      v7 = v6[1];
      if ( v7 != v3[1] )
        goto LABEL_24;
      v7 = v6[2];
      if ( v7 != v3[2] )
        goto LABEL_23;
      v7 = v6[3];
      if ( v7 != v3[3] )
        goto LABEL_22;
      v7 = v6[4];
      if ( v7 != v3[4] )
        goto LABEL_21;
      v7 = v6[5];
      if ( v7 != v3[5] )
        goto LABEL_20;
      v7 = v6[6];
      if ( v7 != v3[6] )
        goto LABEL_19;
      v7 = v6[7];
      if ( v7 != v3[7] )
      {
        ++v3;
LABEL_19:
        ++v3;
LABEL_20:
        ++v3;
LABEL_21:
        ++v3;
LABEL_22:
        ++v3;
LABEL_23:
        ++v3;
LABEL_24:
        ++v3;
        break;
      }
      v6 += 8;
      v3 += 8;
      if ( v4 < 32 )
        __asm { jmp     ebx }
    }
    v8 = *v3;
    v9 = (unsigned __int8)v7 < (unsigned __int8)*v3;
    if ( (_BYTE)v7 == (unsigned __int8)*v3 )
    {
      v9 = BYTE1(v7) < BYTE1(v8);
      if ( BYTE1(v7) == BYTE1(v8) )
      {
        v10 = HIWORD(v7);
        v11 = HIWORD(v8);
        v9 = (unsigned __int8)v10 < (unsigned __int8)v11;
        if ( (_BYTE)v10 == (_BYTE)v11 )
          v9 = v10 < v11;
      }
    }
    return -v9 - (v9 - 1);
  }
}

//----- (0805FC10) --------------------------------------------------------
_BYTE *__cdecl _memmove_chk(_BYTE *a1, _BYTE *a2, unsigned int a3, unsigned int a4)
{
  if ( a4 < a3 )
    _chk_fail();
  return memmove(a1, a2, a3);
}

//----- (0805FC30) --------------------------------------------------------
_BYTE *__cdecl memmove(_BYTE *a1, _BYTE *a2, unsigned int a3)
{
  _BYTE *v3; // edi
  _BYTE *v4; // esi
  _BYTE *v6; // edi
  _BYTE *v7; // esi
  _WORD *v8; // edi
  _WORD *v9; // esi

  v3 = a1;
  v4 = a2;
  if ( a3 > a1 - a2 )
  {
    v6 = &a1[a3 - 1];
    v7 = &a2[a3 - 1];
    if ( a3 & 1 )
    {
      *v6 = *v7;
      v7 = &a2[a3 - 2];
      v6 = &a1[a3 - 2];
    }
    v8 = v6 - 1;
    v9 = v7 - 1;
    if ( (a3 & 2) != 0 )
      *v8++ = *v9++;
    qmemcpy(v8 - 1, v9 - 1, 4 * (a3 >> 2));
    return a1;
  }
  else
  {
    if ( a3 & 1 )
    {
      *a1 = *a2;
      v4 = a2 + 1;
      v3 = a1 + 1;
    }
    if ( (a3 & 2) != 0 )
    {
      *(_WORD *)v3 = *(_WORD *)v4;
      v4 += 2;
      v3 += 2;
    }
    qmemcpy(v3, v4, 4 * (a3 >> 2));
    return a1;
  }
}

//----- (0805FC90) --------------------------------------------------------
unsigned __int8 *__cdecl memset(unsigned __int8 *a1, unsigned __int8 a2, unsigned int a3)
{
  unsigned int v3; // ecx
  unsigned __int8 *v4; // edi
  int v5; // edx
  char v6; // dl
  unsigned int v7; // ecx

  v3 = a3;
  if ( a3 )
  {
    v4 = a1;
    v5 = (unsigned __int8)a1 & 3;
    if ( ((unsigned __int8)a1 & 3) == 0 )
    {
LABEL_8:
      v6 = v3;
      v7 = v3 >> 2;
      memset32(v4, 16843009 * a2, v7);
      memset(&v4[4 * v7], a2, v6 & 3);
      return a1;
    }
    if ( __SETP__(v5, 0) || (*a1 = a2, v4 = a1 + 1, v3 = a3 - 1, a3 != 1) )
    {
      *v4++ = a2;
      if ( --v3 )
      {
        if ( v5 == 1 )
        {
          *v4++ = a2;
          --v3;
        }
        goto LABEL_8;
      }
    }
  }
  return a1;
}

//----- (0805FCE0) --------------------------------------------------------
_WORD *__cdecl _mempcpy_chk(_BYTE *a1, _BYTE *a2, unsigned int a3, unsigned int a4)
{
  if ( a4 < a3 )
    _chk_fail();
  return mempcpy(a1, a2, a3);
}

//----- (0805FD00) --------------------------------------------------------
_WORD *__cdecl mempcpy(_BYTE *a1, _BYTE *a2, unsigned int a3)
{
  _BYTE *v3; // edi
  _BYTE *v4; // esi
  unsigned int v5; // ecx

  v3 = a1;
  v4 = a2;
  if ( a3 & 1 )
  {
    *a1 = *a2;
    v4 = a2 + 1;
    v3 = a1 + 1;
  }
  v5 = a3 >> 2;
  if ( (a3 & 2) != 0 )
  {
    *(_WORD *)v3 = *(_WORD *)v4;
    v4 += 2;
    v3 += 2;
  }
  qmemcpy(v3, v4, 4 * v5);
  return &v3[4 * v5];
}

//----- (0805FD30) --------------------------------------------------------
_BYTE *__cdecl stpcpy(int a1, int a2)
{
  int v2; // ecx
  _BYTE *result; // eax
  char v4; // dl
  char v5; // dl
  char v6; // dl
  char v7; // dl

  v2 = a2 - a1;
  result = (_BYTE *)(a1 - 4);
  while ( 1 )
  {
    result += 4;
    v4 = result[v2];
    *result = v4;
    if ( !v4 )
      return result;
    v5 = result[v2 + 1];
    result[1] = v5;
    if ( !v5 )
      goto LABEL_8;
    v6 = result[v2 + 2];
    result[2] = v6;
    if ( !v6 )
      goto LABEL_7;
    v7 = result[v2 + 3];
    result[3] = v7;
    if ( !v7 )
    {
      ++result;
LABEL_7:
      ++result;
LABEL_8:
      ++result;
      return result;
    }
  }
}

//----- (0805FD80) --------------------------------------------------------
int __cdecl strcasecmp_l(char *a1, unsigned __int8 *a2, int a3)
{
  char *v3; // ecx
  unsigned __int8 *v4; // edx
  char v5; // di
  int v6; // esi

  v3 = a1;
  v4 = a2;
  if ( a1 == (char *)a2 )
    return 0;
  do
  {
    v5 = *v3;
    v6 = *(_DWORD *)(*(_DWORD *)(a3 + 56) + 4 * (unsigned __int8)*v3) - *(_DWORD *)(*(_DWORD *)(a3 + 56) + 4 * *v4++);
    if ( v6 )
      break;
    ++v3;
  }
  while ( v5 );
  return v6;
}

//----- (0805FDE0) --------------------------------------------------------
_BYTE *__cdecl _memcpy_chk(_BYTE *a1, _BYTE *a2, unsigned int a3, unsigned int a4)
{
  if ( a4 < a3 )
    _chk_fail();
  return memcpy(a1, a2, a3);
}

//----- (0805FE00) --------------------------------------------------------
_BYTE *__cdecl memcpy(_BYTE *a1, _BYTE *a2, unsigned int a3)
{
  _BYTE *v3; // edi
  _BYTE *v4; // esi
  unsigned int v5; // ecx

  v3 = a1;
  v4 = a2;
  v5 = a3;
  if ( (((unsigned __int8)a2 ^ (unsigned __int8)a1) & 3) != 0 || a3 <= 3 )
  {
    if ( a3 & 1 )
    {
      *a1 = *a2;
      v4 = a2 + 1;
      v3 = a1 + 1;
    }
    if ( (a3 & 2) != 0 )
    {
      *(_WORD *)v3 = *(_WORD *)v4;
      v4 += 2;
      v3 += 2;
    }
    qmemcpy(v3, v4, 4 * (a3 >> 2));
  }
  else
  {
    if ( ((unsigned __int8)a2 & 3) != 0 )
    {
      *a1 = *a2;
      v4 = a2 + 1;
      v3 = a1 + 1;
      v5 = a3 - 1;
      if ( ((unsigned int)(a2 + 1) & 3) != 0 )
      {
        *v3 = *v4;
        v4 = a2 + 2;
        v3 = a1 + 2;
        v5 = a3 - 2;
        if ( ((unsigned int)(a2 + 2) & 3) != 0 )
        {
          *v3 = *v4;
          v4 = a2 + 3;
          v3 = a1 + 3;
          v5 = a3 - 3;
        }
      }
    }
    qmemcpy(v3, v4, v5);
  }
  return a1;
}

//----- (0805FE70) --------------------------------------------------------
_BYTE *__cdecl rawmemchr(_BYTE *a1, int a2)
{
  _BYTE *result; // eax
  int v3; // edx
  __int16 v4; // cx
  int v5; // edx
  unsigned int v6; // ecx

  result = a1;
  v3 = a2;
  BYTE1(v3) = a2;
  v4 = v3;
  v5 = v3 << 16;
  LOWORD(v5) = v4;
  if ( ((unsigned __int8)a1 & 3) != 0 )
  {
    if ( *a1 != (_BYTE)v4 )
    {
      result = a1 + 1;
      if ( (((_BYTE)a1 + 1) & 3) == 0 )
        goto LABEL_8;
      if ( *result != (_BYTE)v4 )
      {
        result = a1 + 2;
        if ( (((_BYTE)a1 + 2) & 3) == 0 )
          goto LABEL_8;
        if ( *result != (_BYTE)v4 )
        {
          result = a1 + 3;
          goto LABEL_8;
        }
      }
    }
  }
  else
  {
LABEL_8:
    while ( 1 )
    {
      v6 = v5 ^ *(_DWORD *)result;
      if ( v6 < 0x1010101 || (v6 ^ (v6 - 16843009) | 0xFEFEFEFF) != -1 )
        break;
      v6 = v5 ^ *((_DWORD *)result + 1);
      if ( v6 < 0x1010101 || (v6 ^ (v6 - 16843009) | 0xFEFEFEFF) != -1 )
        goto LABEL_19;
      v6 = v5 ^ *((_DWORD *)result + 2);
      if ( v6 < 0x1010101 || (v6 ^ (v6 - 16843009) | 0xFEFEFEFF) != -1 )
        goto LABEL_18;
      v6 = v5 ^ *((_DWORD *)result + 3);
      if ( v6 < 0x1010101 || (v6 ^ (v6 - 16843009) | 0xFEFEFEFF) != -1 )
      {
        result += 4;
LABEL_18:
        result += 4;
LABEL_19:
        result += 4;
        break;
      }
      result += 16;
    }
    if ( (_BYTE)v6 )
    {
      ++result;
      if ( BYTE1(v6) )
      {
        ++result;
        if ( (v6 & 0xFF0000) != 0 )
          ++result;
      }
    }
  }
  return result;
}

//----- (0805FF40) --------------------------------------------------------
unsigned int *__cdecl strchrnul(unsigned int *a1, int a2)
{
  unsigned int *result; // eax
  int v3; // edx
  __int16 v4; // cx
  int v5; // edx
  unsigned int v6; // ecx
  unsigned int v7; // ecx

  result = a1;
  v3 = a2;
  BYTE1(v3) = a2;
  v4 = v3;
  v5 = v3 << 16;
  LOWORD(v5) = v4;
  if ( ((unsigned __int8)a1 & 3) != 0 )
  {
    if ( (_BYTE)v4 != *(_BYTE *)a1 && *(_BYTE *)a1 )
    {
      result = (unsigned int *)((char *)a1 + 1);
      if ( (((_BYTE)a1 + 1) & 3) == 0 )
        goto LABEL_12;
      if ( (_BYTE)v4 != *(_BYTE *)result && *(_BYTE *)result )
      {
        result = (unsigned int *)((char *)a1 + 2);
        if ( (((_BYTE)a1 + 2) & 3) == 0 )
          goto LABEL_12;
        if ( (_BYTE)v4 != *(_BYTE *)result && *(_BYTE *)result )
        {
          result = (unsigned int *)((char *)a1 + 3);
          goto LABEL_12;
        }
      }
    }
  }
  else
  {
LABEL_12:
    while ( 1 )
    {
      v6 = v5 ^ *result;
      if ( v6 < 0x1010101 )
        break;
      if ( (v6 ^ (v6 - 16843009) | 0xFEFEFEFF) != -1 )
        break;
      v6 = *result;
      if ( *result < 0x1010101 || (v6 ^ (v6 - 16843009) | 0xFEFEFEFF) != -1 )
        break;
      v6 = v5 ^ result[1];
      if ( v6 < 0x1010101 )
        goto LABEL_30;
      if ( (v6 ^ (v6 - 16843009) | 0xFEFEFEFF) != -1 )
        goto LABEL_30;
      v6 = result[1];
      if ( v6 < 0x1010101 || (v6 ^ (v6 - 16843009) | 0xFEFEFEFF) != -1 )
        goto LABEL_30;
      v6 = v5 ^ result[2];
      if ( v6 < 0x1010101 )
        goto LABEL_29;
      if ( (v6 ^ (v6 - 16843009) | 0xFEFEFEFF) != -1 )
        goto LABEL_29;
      v6 = result[2];
      if ( v6 < 0x1010101 || (v6 ^ (v6 - 16843009) | 0xFEFEFEFF) != -1 )
        goto LABEL_29;
      v6 = v5 ^ result[3];
      if ( v6 < 0x1010101
        || (v6 ^ (v6 - 16843009) | 0xFEFEFEFF) != -1
        || (v6 = result[3], v6 < 0x1010101)
        || (v6 ^ (v6 - 16843009) | 0xFEFEFEFF) != -1 )
      {
        ++result;
LABEL_29:
        ++result;
LABEL_30:
        ++result;
        break;
      }
      result += 4;
    }
    if ( (_BYTE)v6 )
    {
      if ( (_BYTE)v6 != (_BYTE)v5 )
      {
        result = (unsigned int *)((char *)result + 1);
        if ( BYTE1(v6) )
        {
          if ( BYTE1(v6) != (_BYTE)v5 )
          {
            result = (unsigned int *)((char *)result + 1);
            v7 = HIWORD(v6);
            if ( (_BYTE)v7 )
            {
              if ( (_BYTE)v7 != (_BYTE)v5 )
                return (unsigned int *)((char *)result + 1);
            }
          }
        }
      }
    }
  }
  return result;
}

//----- (080600A0) --------------------------------------------------------
_WORD *__cdecl wmempcpy(_BYTE *a1, _BYTE *a2, int a3)
{
  return mempcpy(a1, a2, 4 * a3);
}

//----- (080600D0) --------------------------------------------------------
int __cdecl mbsrtowcs(int a1, unsigned int **a2, int a3, void *a4)
{
  void *v4; // eax

  v4 = a4;
  if ( !a4 )
    v4 = &state;
  return _mbsrtowcs_l(a1, a2, a3, (int)v4, (_DWORD **)__readgsdword(0xFFFFFFD4));
}

//----- (08060110) --------------------------------------------------------
int *__usercall nl_cleanup_ctype@<eax>(int ebp0@<ebp>, int *a2@<edi>, int a3)
{
  int *result; // eax
  int v4; // esi

  result = (int *)a3;
  v4 = *(_DWORD *)(a3 + 20);
  if ( v4 )
  {
    *(_DWORD *)(a3 + 20) = 0;
    *(_DWORD *)(a3 + 16) = 0;
    _gconv_close_transform(*(const struct timespec **)(v4 + 8), *(_DWORD *)(v4 + 12));
    _gconv_close_transform(*(const struct timespec **)v4, *(_DWORD *)(v4 + 4));
    return free(ebp0, a2, v4);
  }
  return result;
}

//----- (08060170) --------------------------------------------------------
const struct timespec *__cdecl _wcsmbs_getfct(int a1, int a2, unsigned int *a3)
{
  const struct timespec *result; // eax
  unsigned int v4; // [esp+10h] [ebp-18h] BYREF
  int **v5[5]; // [esp+14h] [ebp-14h] BYREF

  v5[1] = (int **)__readgsdword(0x14u);
  if ( _gconv_find_transform((unsigned __int8 *)a1, (int *)a2, v5, (int *)&v4, 0) )
    return 0;
  result = (const struct timespec *)v5[0];
  if ( v4 > 1 )
  {
    _gconv_close_transform((const struct timespec *)v5[0], v4);
    return 0;
  }
  else
  {
    *a3 = v4;
  }
  return result;
}

//----- (08060200) --------------------------------------------------------
unsigned int __cdecl _wcsmbs_load_conv(_DWORD *a1)
{
  char *v1; // ecx
  int v2; // edi
  char *v3; // eax
  unsigned int i; // esi
  char v5; // dl
  int v6; // eax
  __int16 v7; // dx
  _BYTE *v8; // eax
  int v9; // edx
  unsigned __int8 *v10; // edx
  int v11; // eax
  unsigned __int8 *v12; // edi
  const struct timespec *v13; // eax
  const struct timespec *v14; // eax
  int v15; // esi
  unsigned int v17; // esi
  unsigned __int8 *v18; // ecx
  void *v19; // esp
  unsigned __int8 *v20; // edi
  unsigned int v21; // esi
  int v22; // edx
  unsigned int v23; // edi
  unsigned int v24; // eax
  _BYTE v25[4]; // [esp-1010h] [ebp-104Ch]
  _BYTE v26[4096]; // [esp-100Ch] [ebp-1048h] BYREF
  _BYTE v27[12]; // [esp-Ch] [ebp-48h] BYREF
  unsigned __int8 *v28; // [esp+0h] [ebp-3Ch]
  unsigned int v29; // [esp+4h] [ebp-38h]
  unsigned __int8 *v30; // [esp+8h] [ebp-34h]
  unsigned __int8 *v31; // [esp+Ch] [ebp-30h]
  _DWORD *v32; // [esp+10h] [ebp-2Ch]
  unsigned int v33; // [esp+20h] [ebp-1Ch]
  int savedregs; // [esp+3Ch] [ebp+0h] BYREF

  v32 = a1;
  v33 = __readgsdword(0x14u);
  if ( !a1[5] )
  {
    v31 = calloc(a1, 1u, 0x10u);
    if ( v31 )
    {
      v1 = (char *)a1[23];
      if ( a1[7] )
      {
        v29 = 8;
        v2 = 11;
        v28 = "TRANSLIT";
      }
      else
      {
        v29 = 0;
        v2 = 3;
        v28 = byte_80B41F9;
      }
      v3 = v1;
      for ( i = 0; ; i += v5 == 47 )
      {
        v5 = *v3;
        if ( !*v3 )
          break;
        ++v3;
      }
      v6 = v2 + v3 - v1 + 27;
      v7 = v6 & 0xFFF0;
      v8 = &v27[-(v6 & 0xFFFFF000)];
      if ( v27 != v8 )
      {
        while ( v26 != v8 )
          ;
      }
      v9 = v7 & 0xFFF;
      if ( v9 )
      {
        v19 = alloca(v9);
        *(_DWORD *)&v25[v9] = *(_DWORD *)&v25[v9];
      }
      v10 = v26;
      v30 = v26;
      v11 = *v1;
      if ( (_BYTE)v11 )
      {
        do
        {
          ++v1;
          *v10++ = dword_80A7040[v11];
          v11 = *v1;
        }
        while ( (_BYTE)v11 );
      }
      else
      {
        v10 = v30;
      }
      if ( i <= 1 )
      {
        *v10 = 47;
        if ( i )
        {
          ++v10;
        }
        else
        {
          v17 = v29;
          v18 = v10 + 2;
          v10[1] = 47;
          if ( v17 )
          {
            if ( v29 >= 4 )
            {
              v20 = v28;
              *(_DWORD *)v18 = *(_DWORD *)v28;
              *(_DWORD *)&v18[v29 - 4] = *(_DWORD *)&v20[v29 - 4];
              v21 = (unsigned int)(v10 + 6) & 0xFFFFFFFC;
              v22 = v20 - &v18[-v21];
              if ( ((unsigned int)&v18[v29 - v21] & 0xFFFFFFFC) >= 4 )
              {
                v28 = v18;
                v23 = (unsigned int)&v18[v29 - v21] & 0xFFFFFFFC;
                v24 = 0;
                do
                {
                  *(_DWORD *)(v21 + v24) = *(_DWORD *)(v22 + v24);
                  v24 += 4;
                }
                while ( v24 < v23 );
                v18 = v28;
              }
            }
            else if ( v29 )
            {
              *v18 = *v28;
            }
            v10 = &v18[v29];
          }
          else
          {
            v10 += 2;
          }
        }
      }
      v12 = v31;
      *v10 = 0;
      v13 = _wcsmbs_getfct((int)"INTERNAL", (int)v30, (unsigned int *)v12 + 1);
      *(_DWORD *)v12 = v13;
      if ( v13 )
      {
        v14 = _wcsmbs_getfct((int)v30, (int)"INTERNAL", (unsigned int *)v12 + 3);
        *((_DWORD *)v12 + 2) = v14;
        if ( v14 )
        {
LABEL_17:
          v15 = (int)v32;
          v32[5] = v31;
          *(_DWORD *)(v15 + 16) = nl_cleanup_ctype;
          return __readgsdword(0x14u) ^ v33;
        }
        if ( *(_DWORD *)v31 )
          _gconv_close_transform(*(const struct timespec **)v31, *((_DWORD *)v31 + 1));
      }
      else if ( *((_DWORD *)v31 + 2) )
      {
        goto LABEL_17;
      }
      free((int)&savedregs, (int *)v12, (int)v31);
    }
    v32[5] = &_wcsmbs_gconv_fcts_c;
  }
  return __readgsdword(0x14u) ^ v33;
}
// 80A7040: using guessed type int dword_80A7040[256];
// 80B41F9: using guessed type unsigned __int8 byte_80B41F9[1671];
// 80CC6D4: using guessed type void *_wcsmbs_gconv_fcts_c;
// 80CDF7C: using guessed type int (*off_80CDF7C)[256];

//----- (080604E0) --------------------------------------------------------
_DWORD *__cdecl _wcsmbs_clone_conv(void **a1)
{
  unsigned int v1; // eax
  char **v2; // esi
  void **v3; // eax
  int *v4; // edx
  int v5; // ecx
  _DWORD *result; // eax

  v1 = __readgsdword(0xFFFFFFD0);
  v2 = *(char ***)v1;
  v3 = *(void ***)(*(_DWORD *)v1 + 20);
  if ( !v3 )
  {
    if ( v2 == &nl_C_LC_CTYPE )
    {
      v3 = &_wcsmbs_gconv_fcts_c;
    }
    else
    {
      _wcsmbs_load_conv(v2);
      v3 = (void **)v2[5];
    }
  }
  v4 = (int *)*v3;
  *a1 = *v3;
  a1[1] = v3[1];
  a1[2] = v3[2];
  v5 = *v4;
  a1[3] = v3[3];
  if ( v5 )
    ++v4[2];
  result = a1[2];
  if ( *result )
    ++result[2];
  return result;
}
// 80CC6D4: using guessed type void *_wcsmbs_gconv_fcts_c;
// 80CC740: using guessed type char *nl_C_LC_CTYPE;

//----- (08060570) --------------------------------------------------------
int __cdecl _wcsmbs_named_conv(int a1, int a2)
{
  const struct timespec *v2; // eax
  int v3; // ecx
  const struct timespec *v4; // eax

  v2 = _wcsmbs_getfct((int)"INTERNAL", a2, (unsigned int *)(a1 + 4));
  v3 = 1;
  *(_DWORD *)a1 = v2;
  if ( v2 )
  {
    v4 = _wcsmbs_getfct(a2, (int)"INTERNAL", (unsigned int *)(a1 + 12));
    v3 = 0;
    *(_DWORD *)(a1 + 8) = v4;
    if ( !v4 )
    {
      _gconv_close_transform(*(const struct timespec **)a1, *(_DWORD *)(a1 + 4));
      return 1;
    }
  }
  return v3;
}

//----- (080605F0) --------------------------------------------------------
int __cdecl _mbsrtowcs_l(int a1, unsigned int **a2, int a3, int a4, _DWORD **a5)
{
  int v5; // ecx
  char **v6; // ebx
  void **v7; // eax
  void *v8; // edi
  int (__cdecl *v9)(void *, char **, unsigned int **, unsigned int, _DWORD, char *, _DWORD, int); // esi
  unsigned int *v10; // ebp
  int v11; // ebx
  unsigned int v12; // ebx
  unsigned int v13; // eax
  int v14; // edx
  int v15; // edx
  int v16; // edx
  int v18; // eax
  int v19; // edx
  int v20; // ebp
  int v21; // [esp+24h] [ebp-168h]
  char v22[4]; // [esp+3Ch] [ebp-150h] BYREF
  unsigned int *v23; // [esp+40h] [ebp-14Ch] BYREF
  int v24[2]; // [esp+44h] [ebp-148h] BYREF
  char *v25; // [esp+4Ch] [ebp-140h] BYREF
  unsigned int *v26; // [esp+50h] [ebp-13Ch]
  int v27; // [esp+54h] [ebp-138h]
  int v28; // [esp+58h] [ebp-134h]
  int v29; // [esp+5Ch] [ebp-130h]
  int *v30; // [esp+60h] [ebp-12Ch]
  char v31[256]; // [esp+6Ch] [ebp-120h] BYREF
  unsigned int v32; // [esp+16Ch] [ebp-20h] BYREF

  v5 = a3;
  v32 = __readgsdword(0x14u);
  v28 = 0;
  v29 = 1;
  v30 = (int *)a4;
  v27 = 1;
  v6 = (char **)*a5;
  v7 = (void **)(*a5)[5];
  if ( !v7 )
  {
    if ( v6 == &nl_C_LC_CTYPE )
    {
      v7 = &_wcsmbs_gconv_fcts_c;
    }
    else
    {
      _wcsmbs_load_conv(*a5);
      v7 = (void **)v6[5];
      v5 = a3;
    }
  }
  v8 = *v7;
  v9 = (int (__cdecl *)(void *, char **, unsigned int **, unsigned int, _DWORD, char *, _DWORD, int))*((_DWORD *)*v7 + 5);
  if ( *(_DWORD *)*v7 )
    v9 = (int (__cdecl *)(void *, char **, unsigned int **, unsigned int, _DWORD, char *, _DWORD, int))(__readgsdword(0x18u) ^ __ROR4__(v9, 9));
  v10 = *a2;
  v23 = *a2;
  if ( a1 )
  {
    v11 = v5;
    v25 = (char *)a1;
    v26 = (unsigned int *)(a1 + 4 * v5);
    if ( !v5 )
      return 0;
    do
    {
      v12 = (unsigned int)v10 + strnlen(v10, v11) + 1;
      dl_mcount_wrapper_check((int)v9);
      v13 = v9(v8, &v25, &v23, v12, 0, v22, 0, 1);
      v10 = v23;
      if ( v13 != 4 && v13 != 7 )
      {
        v14 = (int)v25;
        goto LABEL_14;
      }
      if ( v23 != (unsigned int *)v12 )
        break;
      if ( !*(_BYTE *)(v12 - 1) )
        break;
      v11 = ((char *)v26 - v25) >> 2;
    }
    while ( v11 );
    v14 = (int)v25;
LABEL_14:
    v15 = (v14 - a1) >> 2;
    *a2 = v23;
    v20 = v15;
    if ( (v13 & 0xFFFFFFFB) != 0 )
    {
      if ( v13 - 4 <= 3 )
        goto LABEL_21;
LABEL_25:
      _assert_fail(
        (int)&GLOBAL_OFFSET_TABLE_ - 173304,
        (int)&GLOBAL_OFFSET_TABLE_ - 173399,
        153,
        (int)&GLOBAL_OFFSET_TABLE_ - 173144);
    }
    if ( !*(_DWORD *)(a1 + 4 * v15 - 4) )
    {
      if ( !v15 )
        _assert_fail(
          (int)&GLOBAL_OFFSET_TABLE_ - 173385,
          (int)&GLOBAL_OFFSET_TABLE_ - 173399,
          141,
          (int)&GLOBAL_OFFSET_TABLE_ - 173144);
      if ( *v30 )
        _assert_fail(
          (int)&GLOBAL_OFFSET_TABLE_ - 173374,
          (int)&GLOBAL_OFFSET_TABLE_ - 173399,
          142,
          (int)&GLOBAL_OFFSET_TABLE_ - 173144);
      *a2 = 0;
LABEL_19:
      --v20;
    }
  }
  else
  {
    v18 = (int)v10 + strlen(v10) + 1;
    v20 = 0;
    v21 = v18;
    v19 = v30[1];
    v24[0] = *v30;
    v30 = v24;
    v26 = &v32;
    v24[1] = v19;
    do
    {
      v25 = v31;
      dl_mcount_wrapper_check((int)v9);
      v13 = v9(v8, &v25, &v23, v21, 0, v22, 0, 1);
      v20 += (v25 - v31) >> 2;
    }
    while ( v13 == 5 );
    if ( (v13 & 0xFFFFFFFB) == 0 )
    {
      if ( *((_DWORD *)v25 - 1) )
        _assert_fail(
          (int)&GLOBAL_OFFSET_TABLE_ - 173348,
          (int)&GLOBAL_OFFSET_TABLE_ - 173399,
          94,
          (int)&GLOBAL_OFFSET_TABLE_ - 173144);
      goto LABEL_19;
    }
  }
  if ( v13 != 0 && v13 - 4 > 3 )
    goto LABEL_25;
LABEL_21:
  if ( v13 > 7 || (v16 = 177, !_bittest(&v16, v13)) )
  {
    v20 = -1;
    __writegsdword(0xFFFFFFE0, 0x54u);
  }
  return v20;
}
// 80CC6D4: using guessed type void *_wcsmbs_gconv_fcts_c;
// 80CC740: using guessed type char *nl_C_LC_CTYPE;
// 80CE000: using guessed type _TBYTE GLOBAL_OFFSET_TABLE_;
// 80605F0: using guessed type char var_150[4];

//----- (08060972) --------------------------------------------------------
void __noreturn exit(int status)
{
  int v1; // eax

  ((void (*)(void))__readgsdword(0x10u))();
  v1 = sys_exit(status);
}

//----- (08060990) --------------------------------------------------------
int __usercall _sysconf_check_spec@<eax>(unsigned int *a1@<eax>)
{
  unsigned int *v2; // eax
  char *v3; // esi
  int v4; // edx
  unsigned int v5; // ecx
  unsigned int *v6; // eax
  __int16 v7; // cx
  int v8; // ecx
  _WORD *v9; // eax
  unsigned int v10; // edx
  signed int v11; // eax
  void *v13; // esp
  const char *v14; // [esp-1008h] [ebp-10A0h]
  _BYTE v15[4]; // [esp-1004h] [ebp-109Ch]
  _BYTE v16[4096]; // [esp-1000h] [ebp-1098h] BYREF
  unsigned int v17; // [esp+0h] [ebp-98h] BYREF
  unsigned int v18; // [esp+4h] [ebp-94h]
  unsigned int v19; // [esp+8h] [ebp-90h]
  int v20; // [esp+Ch] [ebp-8Ch]
  stat v21; // [esp+1Ch] [ebp-7Ch] BYREF
  unsigned int v22; // [esp+7Ch] [ebp-1Ch]

  v22 = __readgsdword(0x14u);
  v17 = -32;
  v18 = __readgsdword(0xFFFFFFE0);
  v2 = (unsigned int *)secure_getenv((__int16 *)"GETCONF_DIR");
  if ( v2 )
  {
    v3 = (char *)v2;
    v20 = strlen(v2);
  }
  else
  {
    v20 = 20;
    v3 = "/usr/libexec/getconf";
  }
  v4 = strlen(a1);
  v5 = v20 + v4 + 26;
  v19 = v5 & 0xFFFFFFF0;
  v6 = (unsigned int *)((char *)&v17 - (v5 & 0xFFFFF000));
  v7 = v5 & 0xFFF0;
  if ( &v17 != v6 )
  {
    while ( v16 != (_BYTE *)v6 )
      ;
  }
  v8 = v7 & 0xFFF;
  if ( v8 )
  {
    v13 = alloca(v8);
    *(_DWORD *)&v15[v8] = *(_DWORD *)&v15[v8];
  }
  v14 = (const char *)v20;
  v20 = (int)v16;
  v19 = v4;
  v9 = mempcpy(v16, v3, (unsigned int)v14);
  v9[4] = 24374;
  v10 = v19;
  v9 += 5;
  *(_DWORD *)(v9 - 5) = 1397706799;
  *(_DWORD *)(v9 - 3) = 1449089097;
  memcpy(v9, a1, v10 + 1);
  v11 = _xstat64(3, (const char *)v20, &v21);
  __writegsdword(v17, v18);
  return (v11 >> 31) | 1;
}
// 8060990: using guessed type struct stat var_7C;

//----- (08060B10) --------------------------------------------------------
__int64 __cdecl sysconf(int a1)
{
  int v1; // ebp
  __int64 result; // rax
  unsigned int v3; // eax
  unsigned int nocancel; // eax
  int v5; // [esp+0h] [ebp-50h]
  int v6[2]; // [esp+8h] [ebp-48h] BYREF
  char v7[32]; // [esp+10h] [ebp-40h] BYREF
  unsigned int v8; // [esp+30h] [ebp-20h]

  v8 = __readgsdword(0x14u);
  if ( (unsigned int)(a1 - 185) <= 0xE )
  {
    v1 = _cache_sysconf(a1);
    goto LABEL_8;
  }
  if ( a1 == 34 )
  {
    v3 = getrlimit(11, (int)v6);
    v1 = v6[0];
    if ( !v3 )
      goto LABEL_8;
    v1 = _open_nocancel((int)"/proc/sys/kernel/rtsig-max");
    if ( v1 == -1 )
      goto LABEL_8;
LABEL_26:
    while ( 1 )
    {
      nocancel = _read_nocancel(v1, v7, 0x1Fu);
      if ( nocancel != -1 )
        break;
      if ( __readgsdword(0xFFFFFFE0) != 4 )
      {
        _close_nocancel(v1);
        goto LABEL_15;
      }
    }
    v5 = nocancel;
    _close_nocancel(v1);
    if ( v5 <= 0 )
      goto LABEL_15;
    v7[v5] = 0;
    v1 = strtol((unsigned __int8 *)v7, v6, 10);
    if ( (char *)v6[0] == v7 || *(_BYTE *)v6[0] && *(_BYTE *)v6[0] != 10 )
      goto LABEL_15;
  }
  else
  {
    if ( a1 > 34 )
    {
      if ( a1 >= 138 )
      {
        if ( a1 <= 139 )
        {
          v1 = 200809;
          goto LABEL_8;
        }
        if ( a1 == 149 )
        {
          v1 = (unsigned int)((int (__fastcall *)(int *))__readgsdword(0x10u))(v6) < 0xFFFFF001 ? 200809 : -1;
          goto LABEL_8;
        }
      }
      goto LABEL_15;
    }
    if ( a1 )
    {
      if ( a1 != 3 )
      {
LABEL_15:
        if ( (unsigned int)a1 <= 0xF6 )
          __asm { jmp     eax }
        v1 = -1;
        __writegsdword(0xFFFFFFE0, 0x16u);
        goto LABEL_8;
      }
      v1 = _open_nocancel((int)"/proc/sys/kernel/ngroups_max");
      if ( v1 != -1 )
        goto LABEL_26;
      v1 = 0x10000;
    }
    else
    {
      v1 = 0x20000;
      if ( !getrlimit(3, (int)v6) && v6[0] > 0x7FFFFu )
        v1 = (unsigned int)v6[0] >> 2;
    }
  }
LABEL_8:
  HIDWORD(result) = __readgsdword(0x14u) ^ v8;
  LODWORD(result) = v1;
  return result;
}
// 8060B10: using guessed type unsigned __int8 var_40[32];

//----- (08060F10) --------------------------------------------------------
unsigned int sched_yield()
{
  unsigned int result; // eax

  result = ((int (*)(void))__readgsdword(0x10u))();
  if ( result >= 0xFFFFF001 )
    return _syscall_error(result);
  return result;
}

//----- (08060F30) --------------------------------------------------------
int _get_child_max()
{
  int v1[6]; // [esp+Ch] [ebp-18h] BYREF

  v1[2] = __readgsdword(0x14u);
  if ( getrlimit(6, (int)v1) )
    return -1;
  else
    return v1[0];
}

//----- (08060F80) --------------------------------------------------------
unsigned int __cdecl _xstat64(int a1, const char *a2, struct stat *a3)
{
  unsigned int result; // eax

  result = sys_stat64(a2, a3);
  if ( result > 0xFFFFF000 )
    return _syscall_error(result);
  return result;
}

//----- (08060FB0) --------------------------------------------------------
unsigned int __cdecl _fxstat64(int a1, int a2, struct stat *a3)
{
  unsigned int result; // eax

  result = sys_fstat64(a2, a3);
  if ( result > 0xFFFFF000 )
    return _syscall_error(result);
  return result;
}

//----- (08060FE0) --------------------------------------------------------
unsigned int __cdecl open(int a1, int a2)
{
  unsigned int result; // eax
  char v3; // al
  char v4; // di
  unsigned int v5; // eax
  char v6; // [esp+0h] [ebp-1Ch]
  unsigned int v7; // [esp+Ch] [ebp-10h]

  if ( __readgsdword(0xCu) )
  {
    _libc_enable_asynccancel(v6);
    v4 = v3;
    v5 = ((int (__fastcall *)(int, int))__readgsdword(0x10u))(a1, a2);
    if ( v5 > 0xFFFFF000 )
      v5 = _syscall_error(v5);
    v7 = v5;
    _libc_disable_asynccancel(v4);
    return v7;
  }
  else
  {
    result = ((int (__fastcall *)(int))__readgsdword(0x10u))(a1);
    if ( result > 0xFFFFF000 )
      return _syscall_error(result);
  }
  return result;
}
// 8061049: variable 'v6' is possibly undefined
// 8061056: variable 'v3' is possibly undefined

//----- (080610A0) --------------------------------------------------------
unsigned int __cdecl read(int a1, void *a2, size_t a3)
{
  unsigned int result; // eax
  char v4; // al
  char v5; // si
  unsigned int v6; // eax
  char v7; // [esp+0h] [ebp-1Ch]
  unsigned int v8; // [esp+8h] [ebp-14h]

  if ( __readgsdword(0xCu) )
  {
    _libc_enable_asynccancel(v7);
    v5 = v4;
    v6 = sys_read(a1, a2, a3);
    if ( v6 > 0xFFFFF000 )
      v6 = _syscall_error(v6);
    v8 = v6;
    _libc_disable_asynccancel(v5);
    return v8;
  }
  else
  {
    result = sys_read(a1, a2, a3);
    if ( result > 0xFFFFF000 )
      return _syscall_error(result);
  }
  return result;
}
// 80610E8: variable 'v7' is possibly undefined
// 80610F5: variable 'v4' is possibly undefined

//----- (08061140) --------------------------------------------------------
unsigned int __cdecl write(int a1, const void *a2, size_t a3)
{
  unsigned int result; // eax
  char v4; // al
  char v5; // si
  unsigned int v6; // eax
  char v7; // [esp+0h] [ebp-1Ch]
  unsigned int v8; // [esp+8h] [ebp-14h]

  if ( __readgsdword(0xCu) )
  {
    _libc_enable_asynccancel(v7);
    v5 = v4;
    v6 = sys_write(a1, a2, a3);
    if ( v6 > 0xFFFFF000 )
      v6 = _syscall_error(v6);
    v8 = v6;
    _libc_disable_asynccancel(v5);
    return v8;
  }
  else
  {
    result = sys_write(a1, a2, a3);
    if ( result > 0xFFFFF000 )
      return _syscall_error(result);
  }
  return result;
}
// 8061188: variable 'v7' is possibly undefined
// 8061195: variable 'v4' is possibly undefined

//----- (080611E0) --------------------------------------------------------
loff_t __cdecl lseek64(int a1, unsigned int a2, unsigned int a3, unsigned int a4)
{
  loff_t result; // rax
  __int64 v5; // [esp+0h] [ebp-1Ch] BYREF
  unsigned int v6; // [esp+Ch] [ebp-10h]

  v6 = __readgsdword(0x14u);
  LODWORD(result) = sys_llseek(a1, a3, a2, &v5, a4);
  if ( (unsigned int)result > 0xFFFFF000 )
    LODWORD(result) = _syscall_error(result);
  result = (int)result;
  if ( !(_DWORD)result )
    return v5;
  return result;
}
// 80611E0: using guessed type loff_t var_1C;

//----- (08061250) --------------------------------------------------------
char *__cdecl getcwd(__int64 a1)
{
  int v1; // eax
  size_t v2; // edi
  const struct timespec *v3; // eax
  int v4; // edx
  char *v5; // ebx
  struct timespec *v6; // esi
  int v7; // eax
  unsigned __int8 v8; // bl
  int v9; // eax
  unsigned int v10; // eax
  unsigned int v12; // edx
  unsigned int v13; // eax
  unsigned int v14; // ebx
  int *v15; // eax
  char *v16; // ecx
  const struct timespec *v17; // ebx
  void *v18; // ebx
  char *v19; // ebx
  unsigned int v20; // edx
  char *v21; // [esp+1Ch] [ebp-E0h]
  int *v22; // [esp+20h] [ebp-DCh]
  void *v23; // [esp+20h] [ebp-DCh]
  int v24; // [esp+20h] [ebp-DCh]
  int v25; // [esp+24h] [ebp-D8h]
  unsigned int v26; // [esp+24h] [ebp-D8h]
  unsigned int v27; // [esp+24h] [ebp-D8h]
  unsigned int v28; // [esp+28h] [ebp-D4h]
  unsigned int v29; // [esp+28h] [ebp-D4h]
  int v30; // [esp+2Ch] [ebp-D0h]
  __dev_t st_dev; // [esp+30h] [ebp-CCh]
  int v32; // [esp+30h] [ebp-CCh]
  unsigned int v33; // [esp+34h] [ebp-C8h]
  unsigned __int64 v34; // [esp+38h] [ebp-C4h]
  unsigned int v35; // [esp+40h] [ebp-BCh]
  int v36; // [esp+44h] [ebp-B8h]
  bool v37; // [esp+4Fh] [ebp-ADh]
  unsigned __int64 v38; // [esp+50h] [ebp-ACh]
  unsigned int *v39; // [esp+58h] [ebp-A4h]
  unsigned int v40; // [esp+5Ch] [ebp-A0h]
  char *v41; // [esp+60h] [ebp-9Ch]
  __dev_t v42; // [esp+64h] [ebp-98h]
  int v43; // [esp+6Ch] [ebp-90h]
  struct stat v44; // [esp+7Ch] [ebp-80h] BYREF
  __int64 v45; // [esp+D4h] [ebp-28h]
  unsigned int v46; // [esp+DCh] [ebp-20h]

  v46 = __readgsdword(0x14u);
  if ( HIDWORD(a1) )
  {
    v2 = HIDWORD(a1);
    if ( (_DWORD)a1 )
    {
      v21 = (char *)a1;
      goto LABEL_9;
    }
  }
  else
  {
    if ( (_DWORD)a1 )
    {
      __writegsdword(0xFFFFFFE0, 0x16u);
      return 0;
    }
    v1 = getpagesize();
    v2 = 4096;
    if ( v1 >= 4096 )
      v2 = v1;
  }
  v21 = (char *)malloc((const struct timespec *)v2);
  if ( !v21 )
    return 0;
LABEL_9:
  v3 = (const struct timespec *)sys_getcwd(v21, v2);
  if ( (unsigned int)v3 > 0xFFFFF000 )
    v3 = (const struct timespec *)_syscall_error((int)v3);
  if ( (int)v3 <= 0 )
  {
    if ( v3 )
    {
      v10 = __readgsdword(0xFFFFFFE0);
      if ( v10 != 36 )
      {
        if ( v10 == 34 && !a1 )
          _assert_fail(
            (int)&GLOBAL_OFFSET_TABLE_ - 171988,
            (int)&GLOBAL_OFFSET_TABLE_ - 172024,
            121,
            (int)&GLOBAL_OFFSET_TABLE_ - 171944);
        if ( !(_DWORD)a1 )
        {
          free((int)&GLOBAL_OFFSET_TABLE_, (int *)0xFFFFFFE0, (int)v21);
          return 0;
        }
        return 0;
      }
    }
    v4 = a1 | HIDWORD(a1);
  }
  else
  {
    v4 = a1 | HIDWORD(a1);
    if ( *v21 == 47 )
    {
      v24 = a1;
      if ( !a1 )
        v24 = (int)realloc((int)&GLOBAL_OFFSET_TABLE_, v21, v3);
      v19 = v21;
      if ( v24 )
        return (char *)v24;
      return v19;
    }
  }
  if ( v4 )
  {
    if ( HIDWORD(a1) )
    {
      v40 = __readgsdword(0xFFFFFFE0);
      v22 = (int *)v21;
      v35 = HIDWORD(a1);
      goto LABEL_16;
    }
    __writegsdword(0xFFFFFFE0, 0x16u);
    return 0;
  }
  free((int)&GLOBAL_OFFSET_TABLE_, (int *)0xFFFFFFE0, (int)v21);
  v40 = __readgsdword(0xFFFFFFE0);
  v21 = (char *)malloc((const struct timespec *)0x1001);
  if ( !v21 )
    return 0;
  v22 = 0;
  v35 = 4097;
LABEL_16:
  v5 = &v21[v35];
  v21[v35 - 1] = 0;
  if ( (_lxstat64(3, (const char *)&GLOBAL_OFFSET_TABLE_ - 172027, &v44) & 0x80000000) != 0
    || (st_dev = v44.st_dev,
        v30 = v45,
        (_lxstat64(3, (const char *)&GLOBAL_OFFSET_TABLE_ - 168411, &v44) & 0x80000000) != 0) )
  {
LABEL_77:
    v12 = __readgsdword(0xFFFFFFE0);
    goto LABEL_68;
  }
  v41 = v5 - 1;
  v36 = v45;
  v42 = v44.st_dev;
  v37 = v30 != (_DWORD)v45 || v44.st_dev != st_dev;
  if ( v37 )
  {
    v25 = -100;
    v6 = 0;
    while ( 2 )
    {
      v7 = _openat64_nocancel(v25, (int)&GLOBAL_OFFSET_TABLE_ - 172028, 0x80000);
      v25 = v7;
      if ( v7 < 0 )
      {
        v12 = __readgsdword(0xFFFFFFE0);
        if ( v6 )
          goto LABEL_67;
      }
      else
      {
        if ( (_fxstat64(3, v7, &v44) & 0x80000000) != 0 )
        {
          v20 = __readgsdword(0xFFFFFFE0);
          if ( v6 )
          {
            v29 = v20;
            closedir((int)&GLOBAL_OFFSET_TABLE_, (int *)0xFFFFFFE0, &v6->tv_sec);
            v20 = v29;
          }
        }
        else
        {
          if ( !v6 || !closedir((int)&GLOBAL_OFFSET_TABLE_, (int *)0xFFFFFFE0, &v6->tv_sec) )
          {
            v38 = __PAIR64__(v44.st_dev, HIDWORD(v44.st_dev));
            v43 = v45;
            v6 = (struct timespec *)fdopendir(v25);
            if ( v6 )
            {
              v34 = st_dev ^ __PAIR64__(v38, HIDWORD(v38));
              v8 = v37;
              do
              {
                while ( 1 )
                {
                  do
                  {
                    while ( 1 )
                    {
                      __writegsdword(0xFFFFFFE0, 0);
                      v9 = readdir((int)v6);
                      if ( v9 )
                        break;
                      v12 = __readgsdword(0xFFFFFFE0);
                      if ( v12 )
                        goto LABEL_67;
                      if ( !v8 )
                      {
                        __writegsdword(0xFFFFFFE0, 2u);
                        v12 = 2;
                        goto LABEL_67;
                      }
                      v8 = 0;
                      rewinddir((int)&GLOBAL_OFFSET_TABLE_, (int *)0xFFFFFFE0, v6, &v6->tv_sec);
                    }
                  }
                  while ( (*(_BYTE *)(v9 + 10) & 0xFB) != 0
                       || *(_BYTE *)(v9 + 11) == 46 && (!*(_BYTE *)(v9 + 12) || *(_WORD *)(v9 + 12) == 46) );
                  if ( (v8 & (v34 == 0)) == 0 || *(_DWORD *)v9 == v30 )
                    break;
                  v8 &= v34 == 0;
                }
                v39 = (unsigned int *)(v9 + 11);
              }
              while ( _fxstatat64(3, v25, v9 + 11, (int)&v44) < 0
                   || (v44.st_mode & 0xF000) != 0x4000
                   || v44.st_dev != st_dev
                   || v45 != v30 );
              v13 = strlen(v39);
              v33 = v13;
              v32 = v41 - v21;
              if ( v13 < v41 - v21 )
                goto LABEL_53;
              if ( HIDWORD(a1) )
              {
                __writegsdword(0xFFFFFFE0, 0x22u);
                v12 = 34;
              }
              else
              {
                v14 = v35;
                if ( v13 >= v35 )
                  v14 = v13;
                v15 = realloc((int)&GLOBAL_OFFSET_TABLE_, v21, (const struct timespec *)(2 * v14));
                if ( v15 )
                {
                  v16 = v21;
                  v21 = (char *)v15;
                  v41 = memcpy((_BYTE *)v15 + 2 * v14 - (&v16[v35] - v41), (_BYTE *)v15 + v32, &v16[v35] - v41);
                  v35 = 2 * v14;
LABEL_53:
                  v30 = v43;
                  memcpy(&v41[-v33], v39, v33);
                  v41[-v33 - 1] = 47;
                  v41 = &v41[-v33 - 1];
                  st_dev = __PAIR64__(v38, HIDWORD(v38));
                  if ( (v36 != v43) | (v38 != __PAIR64__(v42, HIDWORD(v42))) )
                    continue;
                  if ( !closedir((int)&GLOBAL_OFFSET_TABLE_, (int *)0xFFFFFFE0, &v6->tv_sec) )
                  {
                    v5 = &v21[v35];
                    goto LABEL_56;
                  }
                  goto LABEL_77;
                }
                v12 = __readgsdword(0xFFFFFFE0);
              }
LABEL_67:
              v26 = v12;
              closedir((int)&GLOBAL_OFFSET_TABLE_, (int *)0xFFFFFFE0, &v6->tv_sec);
              v12 = v26;
              break;
            }
          }
          v20 = __readgsdword(0xFFFFFFE0);
        }
        v28 = v20;
        _close_nocancel(v25);
        v12 = v28;
      }
      break;
    }
LABEL_68:
    if ( !v22 )
    {
      v27 = v12;
      free((int)&GLOBAL_OFFSET_TABLE_, (int *)0xFFFFFFE0, (int)v21);
      v12 = v27;
    }
    __writegsdword(0xFFFFFFE0, v12);
    if ( HIDWORD(a1) && !(_DWORD)a1 )
    {
      free((int)&GLOBAL_OFFSET_TABLE_, (int *)0xFFFFFFE0, (int)v22);
      return 0;
    }
    return 0;
  }
LABEL_56:
  if ( v41 == &v21[v35 - 1] )
    *--v41 = 47;
  v17 = (const struct timespec *)(v5 - v41);
  memmove(v21, v41, (unsigned int)v17);
  if ( !HIDWORD(a1) )
    v22 = realloc((int)&GLOBAL_OFFSET_TABLE_, v21, v17);
  v18 = v21;
  if ( v22 )
    v18 = v22;
  v23 = v18;
  __writegsdword(0xFFFFFFE0, v40);
  return (char *)v23;
}
// 80CE000: using guessed type _TBYTE GLOBAL_OFFSET_TABLE_;

//----- (080619F0) --------------------------------------------------------
unsigned int __cdecl _close_nocancel(int a1)
{
  unsigned int result; // eax

  result = sys_close(a1);
  if ( result > 0xFFFFF000 )
    return _syscall_error(result);
  return result;
}

//----- (08061A20) --------------------------------------------------------
unsigned int __cdecl _fcntl64_nocancel_adjusted(int a1, int a2)
{
  unsigned int result; // eax
  int v3; // [esp+4h] [ebp-18h]
  unsigned int v4; // [esp+8h] [ebp-14h]

  if ( a2 != 9 )
  {
    result = sys_fcntl64(a1, a2);
    if ( result <= 0xFFFFF000 )
      return result;
    return _syscall_error(result);
  }
  result = sys_fcntl64(a1, 16);
  if ( result > 0xFFFFF000 )
    return _syscall_error(result);
  result = v4;
  if ( v3 == 2 )
    return -v4;
  return result;
}
// 8061A95: variable 'v4' is possibly undefined
// 8061A99: variable 'v3' is possibly undefined

//----- (08061AB0) --------------------------------------------------------
unsigned int __cdecl _fcntl64_nocancel(int a1, int a2)
{
  return _fcntl64_nocancel_adjusted(a1, a2);
}

//----- (08061AD0) --------------------------------------------------------
unsigned int __cdecl _open_nocancel(int a1)
{
  unsigned int result; // eax

  result = ((int (__fastcall *)(int))__readgsdword(0x10u))(a1);
  if ( result > 0xFFFFF000 )
    return _syscall_error(result);
  return result;
}

//----- (08061B30) --------------------------------------------------------
unsigned int __cdecl _openat64_nocancel(int a1, int a2, int a3)
{
  int v3; // eax
  unsigned int result; // eax

  v3 = a3;
  BYTE1(v3) = BYTE1(a3) | 0x80;
  result = ((int (__fastcall *)(int, int))__readgsdword(0x10u))(a2, v3);
  if ( result > 0xFFFFF000 )
    return _syscall_error(result);
  return result;
}

//----- (08061BA0) --------------------------------------------------------
unsigned int __cdecl _read_nocancel(int a1, void *a2, size_t a3)
{
  unsigned int result; // eax

  result = sys_read(a1, a2, a3);
  if ( result > 0xFFFFF000 )
    return _syscall_error(result);
  return result;
}

//----- (08061BE0) --------------------------------------------------------
unsigned int __cdecl _write_nocancel(int a1, const void *a2, size_t a3)
{
  unsigned int result; // eax

  result = sys_write(a1, a2, a3);
  if ( result > 0xFFFFF000 )
    return _syscall_error(result);
  return result;
}

//----- (08061C20) --------------------------------------------------------
unsigned int __cdecl getrlimit(int a1, int a2)
{
  unsigned int result; // eax

  result = ((int (__fastcall *)(int))__readgsdword(0x10u))(a2);
  if ( result > 0xFFFFF000 )
    return _syscall_error(result);
  return result;
}

//----- (08061C50) --------------------------------------------------------
unsigned int __cdecl sbrk(int a1)
{
  unsigned int v1; // ebx

  v1 = _curbrk;
  if ( !_curbrk || _libc_multiple_libcs )
  {
    if ( brk(0) < 0 )
      return -1;
    v1 = _curbrk;
  }
  if ( !a1 )
    return v1;
  if ( a1 <= 0 )
  {
    if ( -a1 > v1 )
      goto LABEL_6;
  }
  else if ( __CFADD__(a1, v1) )
  {
LABEL_6:
    __writegsdword(0xFFFFFFE0, 0xCu);
    return -1;
  }
  if ( brk((void *)(v1 + a1)) < 0 )
    return -1;
  return v1;
}
// 80CECD4: using guessed type int _libc_multiple_libcs;
// 80CFA40: using guessed type int _curbrk;

//----- (08061D00) --------------------------------------------------------
int getpagesize()
{
  int result; // eax

  result = dl_pagesize;
  if ( !dl_pagesize )
    _assert_fail(
      (int)"GLRO(dl_pagesize) != 0",
      (int)"../sysdeps/unix/sysv/linux/getpagesize.c",
      28,
      (int)"__getpagesize");
  return result;
}
// 80CE9B0: using guessed type int dl_pagesize;

//----- (08061D40) --------------------------------------------------------
int getdtablesize()
{
  bool v0; // sf
  int result; // eax
  int v2[6]; // [esp+Ch] [ebp-18h] BYREF

  v2[2] = __readgsdword(0x14u);
  v0 = (getrlimit(7, (int)v2) & 0x80000000) != 0;
  result = 256;
  if ( !v0 )
    return v2[0];
  return result;
}

//----- (08061D90) --------------------------------------------------------
unsigned int __cdecl mmap(void *a1, size_t a2, int a3, int a4, int a5, unsigned int a6)
{
  unsigned int result; // eax

  if ( (a6 & 0xFFF) != 0 )
  {
    result = -22;
    return _syscall_error(result);
  }
  result = sys_mmap2(a1, a2, a3, a4, a5, a6 >> 12);
  if ( result > 0xFFFFF000 )
    return _syscall_error(result);
  return result;
}

//----- (08061DF0) --------------------------------------------------------
unsigned int __cdecl mmap64(void *a1, size_t a2, int a3, int a4, int a5, unsigned __int64 a6)
{
  unsigned int result; // eax

  result = -22;
  if ( a6 & 0xFFF | HIDWORD(a6) & 0xFFFFF000 )
    return _syscall_error(result);
  result = sys_mmap2(a1, a2, a3, a4, a5, a6 >> 12);
  if ( result > 0xFFFFF000 )
    return _syscall_error(result);
  return result;
}

//----- (08061E80) --------------------------------------------------------
unsigned int __cdecl munmap(void *a1, int a2)
{
  unsigned int result; // eax

  result = sys_munmap(a1, a2);
  if ( result >= 0xFFFFF001 )
    return _syscall_error(result);
  return result;
}

//----- (08061EB0) --------------------------------------------------------
unsigned int __cdecl mprotect(const void *a1, size_t a2, int a3)
{
  unsigned int result; // eax

  result = sys_mprotect(a1, a2, a3);
  if ( result >= 0xFFFFF001 )
    return _syscall_error(result);
  return result;
}

//----- (08061EE0) --------------------------------------------------------
unsigned int __cdecl madvise(void *a1, size_t a2, int a3)
{
  unsigned int result; // eax

  result = sys_madvise1(a1, a2, a3);
  if ( result >= 0xFFFFF001 )
    return _syscall_error(result);
  return result;
}

//----- (08061F10) --------------------------------------------------------
int __usercall trecurse@<eax>(int a1@<eax>, int (__cdecl *a2)(int, int, int)@<edx>, int a3@<ecx>)
{
  int v6; // eax

  if ( (*(_DWORD *)(a1 + 4) & 0xFFFFFFFE) == 0 && !*(_DWORD *)(a1 + 8) )
    return a2(a1, 3, a3);
  a2(a1, 0, a3);
  if ( (*(_DWORD *)(a1 + 4) & 0xFFFFFFFE) != 0 )
    trecurse(*(_DWORD *)(a1 + 4) & 0xFFFFFFFE, a2, a3 + 1);
  a2(a1, 1, a3);
  v6 = *(_DWORD *)(a1 + 8);
  if ( v6 )
    trecurse(v6, a2, a3 + 1);
  return a2(a1, 2, a3);
}

//----- (08061F90) --------------------------------------------------------
int *__usercall tdestroy_recurse@<eax>(_DWORD *a1@<eax>, int *a2@<edx>, int a3@<ecx>, int a4@<ebp>)
{
  _DWORD *v6; // eax
  _DWORD *v7; // eax

  v6 = (_DWORD *)(a1[1] & 0xFFFFFFFE);
  if ( v6 )
  {
    tdestroy_recurse(v6, a2, a3, a4);
    v7 = (_DWORD *)a1[2];
    if ( !v7 )
      goto LABEL_3;
LABEL_5:
    tdestroy_recurse(v7, a2, a3, a4);
    goto LABEL_3;
  }
  v7 = (_DWORD *)a1[2];
  if ( v7 )
    goto LABEL_5;
LABEL_3:
  ((void (__thiscall *)(int, _DWORD))a2)(a3, *a1);
  return free(a4, a2, (int)a1);
}
// 8061FB6: variable 'a3' is possibly undefined

//----- (08061FF0) --------------------------------------------------------
unsigned int __usercall maybe_split_for_insert_isra_0@<eax>(
        int a1@<eax>,
        _DWORD *a2@<edx>,
        unsigned int *a3@<ecx>,
        int a4,
        int a5,
        int a6)
{
  unsigned int result; // eax
  int v7; // edi
  int v8; // ebx
  unsigned int v9; // esi
  unsigned int v10; // edx
  int v11; // ebp
  unsigned int v12; // edi
  int v13; // ebp
  int v14; // ecx

  result = a1 & 0xFFFFFFFE;
  v7 = *(_DWORD *)(result + 4);
  v8 = *(_DWORD *)(result + 8);
  v9 = v7 & 0xFFFFFFFE;
  if ( a6 == 1 )
  {
    *(_DWORD *)(result + 4) = v7 | 1;
    if ( !v8 )
      goto LABEL_9;
  }
  else
  {
    if ( !v8 || !v9 || (*(_BYTE *)(v8 + 4) & 1) == 0 || (*(_BYTE *)(v9 + 4) & 1) == 0 )
      return result;
    *(_DWORD *)(result + 4) = v7 | 1;
  }
  *(_DWORD *)(v8 + 4) &= ~1u;
LABEL_9:
  if ( v9 )
    *(_DWORD *)(v9 + 4) &= ~1u;
  if ( a2 )
  {
    v10 = *a2 & 0xFFFFFFFE;
    v11 = *(_DWORD *)(v10 + 4);
    if ( (v11 & 1) != 0 )
    {
      v12 = *a3 & 0xFFFFFFFE;
      if ( a4 > 0 == a5 > 0 )
      {
        *a3 = v10 | *a3 & 1;
        *(_DWORD *)(v10 + 4) = v11 & 0xFFFFFFFE;
        *(_DWORD *)(v12 + 4) |= 1u;
        if ( a4 < 0 )
        {
          result = *(_DWORD *)(v10 + 8) | 1;
          *(_DWORD *)(v12 + 4) = result;
          *(_DWORD *)(v10 + 8) = v12;
        }
        else
        {
          v14 = *(_DWORD *)(v10 + 4);
          result = v14 & 1;
          *(_DWORD *)(v12 + 8) = v14 & 0xFFFFFFFE;
          *(_DWORD *)(v10 + 4) = result | v12;
        }
      }
      else
      {
        *(_DWORD *)(v10 + 4) = v11 | 1;
        *(_DWORD *)(v12 + 4) |= 1u;
        v13 = v8 & 1;
        *(_DWORD *)(result + 4) &= ~1u;
        if ( a4 < 0 )
        {
          *(_DWORD *)(v10 + 4) = *(_DWORD *)(v10 + 4) & 1 | v8;
          *(_DWORD *)(result + 8) = v13 | v10;
          *(_DWORD *)(v12 + 8) = v9;
          *(_DWORD *)(result + 4) = v12;
        }
        else
        {
          *(_DWORD *)(v10 + 8) = v9;
          *(_DWORD *)(result + 4) = v10;
          *(_DWORD *)(v12 + 4) = *(_DWORD *)(v12 + 4) & 1 | v8;
          *(_DWORD *)(result + 8) = v13 | v12;
        }
        result |= *a3 & 1;
        *a3 = result;
      }
    }
  }
  return result;
}

//----- (08062150) --------------------------------------------------------
_DWORD *__cdecl tsearch(int a1, int *a2, int (__cdecl *a3)(int, _DWORD))
{
  int *v3; // ebp
  int v4; // ebx
  unsigned int *v5; // ecx
  int v6; // eax
  int *v7; // edi
  int v8; // eax
  _DWORD *v9; // ebx
  int v10; // esi
  int *v11; // eax
  int *v13; // [esp+0h] [ebp-30h]
  int v14; // [esp+4h] [ebp-2Ch]
  unsigned int *v15; // [esp+8h] [ebp-28h]
  int v16; // [esp+Ch] [ebp-24h]

  v3 = a2;
  if ( !a2 )
    return 0;
  v4 = *a2;
  if ( (*a2 & 0xFFFFFFFE) != 0 )
  {
    *(_DWORD *)((*a2 & 0xFFFFFFFE) + 4) &= ~1u;
    v5 = 0;
    v16 = 0;
    v14 = 0;
    v13 = 0;
    while ( 1 )
    {
      v9 = (_DWORD *)(v4 & 0xFFFFFFFE);
      if ( !v9 )
        break;
      v15 = v5;
      v10 = a3(a1, *v9);
      if ( !v10 )
        return v9;
      maybe_split_for_insert_isra_0(*v3, v13, v15, v14, v16, 0);
      if ( v10 >= 0 )
      {
        v6 = v9[2];
        v7 = v9 + 2;
      }
      else
      {
        v7 = v9 + 1;
        v6 = v9[1];
      }
      if ( (v6 & 0xFFFFFFFE) == 0 )
        goto LABEL_13;
      v8 = v14;
      v4 = *v7;
      v14 = v10;
      v5 = (unsigned int *)v13;
      v13 = v3;
      v3 = v7;
      v16 = v8;
    }
    v10 = v14;
  }
  else
  {
    v13 = 0;
    v10 = 0;
  }
  v14 = v10;
  v7 = v3;
LABEL_13:
  v11 = malloc((const struct timespec *)0xC);
  v9 = v11;
  if ( !v11 )
    return 0;
  *v7 = (unsigned int)v11 | *v7 & 1;
  v11[1] = 1;
  *v11 = a1;
  v11[2] = 0;
  if ( v7 != v3 )
    maybe_split_for_insert_isra_0(*v7, v3, (unsigned int *)v13, v10, v14, 1);
  return v9;
}

//----- (080622B0) --------------------------------------------------------
_DWORD *__cdecl tfind(int a1, _DWORD *a2, int (__cdecl *a3)(int, _DWORD))
{
  _DWORD *v3; // ebx
  _DWORD *v4; // ebp
  int v5; // eax
  _DWORD *v6; // edx
  _DWORD *v7; // ebx

  v3 = a2;
  if ( a2 )
  {
    while ( 1 )
    {
      v7 = (_DWORD *)(*v3 & 0xFFFFFFFE);
      if ( !v7 )
        break;
      v4 = v7;
      v5 = a3(a1, *v7);
      if ( !v5 )
        return v4;
      v6 = v7 + 1;
      v3 = v7 + 2;
      if ( v5 < 0 )
        v3 = v6;
    }
  }
  return 0;
}

//----- (08062300) --------------------------------------------------------
_DWORD *__cdecl tdelete(unsigned int a1, _DWORD *a2, int a3)
{
  unsigned int v3; // ebx
  int *v4; // eax
  int v5; // esi
  _DWORD *v6; // edx
  int v7; // eax
  _DWORD *v8; // edx
  int v9; // edi
  int v10; // ecx
  int v11; // ebx
  int v13; // ebx
  _BYTE *v14; // eax
  __int16 v15; // bx
  int v16; // ebx
  void *v17; // esp
  _BYTE *v18; // eax
  int v19; // eax
  unsigned int v20; // edi
  _DWORD *v21; // eax
  unsigned int v22; // ecx
  unsigned int v23; // edx
  int v24; // ecx
  _DWORD *i; // edi
  unsigned int v26; // eax
  int v27; // edx
  int v28; // ebx
  _BYTE *v29; // eax
  int v30; // eax
  void *v31; // esp
  _BYTE *v32; // eax
  int v33; // eax
  unsigned int v34; // ebx
  unsigned int v35; // eax
  unsigned int v36; // edx
  int v37; // ecx
  unsigned int *v38; // edx
  int v39; // eax
  int v40; // esi
  int v41; // edx
  unsigned int v42; // eax
  int v43; // edx
  bool v44; // zf
  int *v45; // esi
  int v46; // edx
  int v47; // eax
  int v48; // esi
  unsigned int v49; // edx
  int *v50; // esi
  int v51; // eax
  unsigned int v52; // ecx
  unsigned int v53; // eax
  unsigned int *v54; // ecx
  int v55; // eax
  unsigned int v56; // edx
  int v57; // edx
  int v58; // esi
  unsigned int v59; // ecx
  int *v60; // esi
  int v61; // ecx
  int v62; // edx
  int v63; // edx
  int v64; // esi
  int *v65; // esi
  int v66; // eax
  int v67; // edx
  unsigned int v68; // eax
  _BYTE v70[15]; // [esp+4h] [ebp-210Ch] BYREF
  int v71; // [esp+FF8h] [ebp-1118h]
  _BYTE v72[15]; // [esp+1004h] [ebp-110Ch] BYREF
  unsigned int v73; // [esp+20C0h] [ebp-50h]
  _TBYTE *v74; // [esp+20C4h] [ebp-4Ch]
  _DWORD *v75; // [esp+20C8h] [ebp-48h]
  _DWORD *v76; // [esp+20CCh] [ebp-44h]
  int v77; // [esp+20D0h] [ebp-40h]
  unsigned int v78; // [esp+20D4h] [ebp-3Ch]
  unsigned int v79; // [esp+20D8h] [ebp-38h]
  _DWORD *v80; // [esp+20DCh] [ebp-34h]
  unsigned int v81; // [esp+20E0h] [ebp-30h]
  unsigned int v82; // [esp+20F0h] [ebp-20h]
  int v83; // [esp+210Ch] [ebp-4h] BYREF

  v74 = &GLOBAL_OFFSET_TABLE_;
  v78 = a1;
  v77 = a3;
  v82 = __readgsdword(0x14u);
  v79 = (unsigned int)v72;
  if ( !a2 )
    return 0;
  v3 = *a2 & 0xFFFFFFFE;
  if ( !v3 )
    return 0;
  v4 = (int *)(*a2 & 0xFFFFFFFE);
  v5 = 0;
  v81 = 40;
  v6 = a2;
  while ( 1 )
  {
    v71 = *v4;
    v80 = v6;
    v7 = ((int (__cdecl *)(unsigned int, int))v77)(v78, v71);
    v8 = v80;
    v9 = v7;
    if ( !v7 )
      break;
    v10 = 4 * v5;
    if ( v81 == v5 )
    {
      v81 += 20;
      v13 = 4 * v81 + 27;
      v80 = (_DWORD *)(v13 & 0xFFFFFFF0);
      v14 = &v72[-(v13 & 0xFFFFF000)];
      v15 = v13 & 0xFFF0;
      if ( v72 != v14 )
      {
        while ( v70 != v14 )
          ;
      }
      v16 = v15 & 0xFFF;
      if ( v16 )
      {
        v17 = alloca(v16);
        *(_DWORD *)&v70[v16 - 4] = *(_DWORD *)&v70[v16 - 4];
      }
      v76 = v8;
      v80 = (_DWORD *)(4 * v5);
      v18 = memcpy(v70, (_BYTE *)v79, 4 * v5);
      v8 = v76;
      v10 = (int)v80;
      v79 = (unsigned int)v18;
    }
    v11 = *v8;
    ++v5;
    *(_DWORD *)(v79 + v10) = v8;
    v3 = v11 & 0xFFFFFFFE;
    if ( v9 >= 0 )
    {
      v4 = *(int **)(v3 + 8);
      v6 = (_DWORD *)(v3 + 8);
      if ( !v4 )
        return 0;
    }
    else
    {
      v6 = (_DWORD *)(v3 + 4);
      v4 = (int *)(*(_DWORD *)(v3 + 4) & 0xFFFFFFFE);
      if ( !v4 )
        return 0;
    }
  }
  v19 = *v80;
  v20 = (unsigned int)v80;
  v76 = (_DWORD *)v3;
  v77 = v19;
  v21 = (_DWORD *)(v19 & 0xFFFFFFFE);
  v22 = v21[1];
  v80 = v21;
  v78 = v22;
  v23 = v22 & 0xFFFFFFFE;
  if ( v21[2] && v23 )
  {
    v24 = v20;
    v73 = v20;
    for ( i = v21 + 2; ; i = (_DWORD *)(v26 + 4) )
    {
      v27 = 4 * v5;
      if ( v81 == v5 )
      {
        v81 += 20;
        v28 = 4 * v81 + 27;
        v78 = v28 & 0xFFFFFFF0;
        v29 = &v72[-(v28 & 0xFFFFF000)];
        if ( v72 != v29 )
        {
          while ( v70 != v29 )
            ;
        }
        v30 = v78 & 0xFFF;
        if ( (v78 & 0xFFF) != 0 )
        {
          v31 = alloca(v30);
          *(_DWORD *)&v70[v30 - 4] = *(_DWORD *)&v70[v30 - 4];
        }
        v75 = (_DWORD *)v24;
        v78 = 4 * v5;
        v32 = memcpy(v70, (_BYTE *)v79, 4 * v5);
        v24 = (int)v75;
        v27 = v78;
        v79 = (unsigned int)v32;
      }
      ++v5;
      *(_DWORD *)(v79 + v27) = v24;
      v26 = *i & 0xFFFFFFFE;
      if ( (*(_DWORD *)(v26 + 4) & 0xFFFFFFFE) == 0 )
        break;
      v24 = (int)i;
    }
    v75 = (_DWORD *)(*i & 0xFFFFFFFE);
    v20 = v73;
  }
  else
  {
    v75 = v80;
    if ( v23 )
      goto LABEL_28;
  }
  v23 = v75[2];
LABEL_28:
  if ( v5 )
  {
    v68 = **(_DWORD **)(v79 + 4 * v5 - 4) & 0xFFFFFFFE;
    if ( v75 == *(_DWORD **)(v68 + 8) )
      *(_DWORD *)(v68 + 8) = v23;
    else
      *(_DWORD *)(v68 + 4) = v23 | *(_DWORD *)(v68 + 4) & 1;
  }
  else
  {
    *(_DWORD *)v20 = v23 | v77 & 1;
  }
  if ( v80 != v75 )
    *v80 = *v75;
  if ( (v75[1] & 1) != 0 )
    goto LABEL_45;
  if ( !v5 )
  {
    if ( v23 )
    {
LABEL_54:
      v33 = *(_DWORD *)(v23 + 4);
LABEL_55:
      *(_DWORD *)(v23 + 4) = v33 & 0xFFFFFFFE;
    }
    goto LABEL_45;
  }
  while ( 1 )
  {
    if ( v23 )
    {
      v33 = *(_DWORD *)(v23 + 4);
      if ( (v33 & 1) != 0 )
        goto LABEL_55;
    }
    v78 = 4 * (v5 + 0x3FFFFFFF);
    v80 = *(_DWORD **)(v79 + v78);
    v77 = *v80;
    v34 = v77 & 0xFFFFFFFE;
    v35 = *(_DWORD *)((v77 & 0xFFFFFFFE) + 4) & 0xFFFFFFFE;
    v20 = v35;
    if ( v35 == v23 )
      break;
    v36 = *(_DWORD *)(v35 + 4);
    v81 = v36 & 0xFFFFFFFE;
    v37 = *(_DWORD *)(v35 + 8);
    if ( (v36 & 1) != 0 )
    {
      ++v5;
      *(_DWORD *)(v35 + 4) = v81;
      *(_DWORD *)(v34 + 4) = v37 | 1;
      v38 = v80;
      *(_DWORD *)(v35 + 8) = v34;
      *v38 = v35 | v77 & 1;
      v80 = (_DWORD *)(v35 + 8);
      *(_DWORD *)(v79 + v78 + 4) = v35 + 8;
      v20 = v37 & 0xFFFFFFFE;
      v37 = *(_DWORD *)((v37 & 0xFFFFFFFE) + 8);
      v36 = *(_DWORD *)(v20 + 4);
      v81 = v36 & 0xFFFFFFFE;
    }
    if ( v37 )
    {
      v39 = *(_DWORD *)(v37 + 4);
      if ( (v39 & 1) != 0 )
      {
        v79 = v36;
        v40 = *(_DWORD *)(v34 + 4) & 1;
        if ( !v81 || (*(_BYTE *)(v81 + 4) & 1) == 0 )
        {
          v41 = v39;
          v42 = v39 & 0xFFFFFFFE;
          v43 = v41 | 1;
          v44 = v40 == 0;
          v45 = v80;
          if ( !v44 )
            v42 = v43;
          *(_DWORD *)(v37 + 4) = v42;
          *(_DWORD *)(v34 + 4) = *(_DWORD *)(v37 + 8) | *(_DWORD *)(v34 + 4) & 1;
          v46 = *(_DWORD *)(v37 + 4);
          *(_DWORD *)(v20 + 8) = v46 & 0xFFFFFFFE;
          *(_DWORD *)(v37 + 4) = v20 | v46 & 1;
          v47 = *v45;
          *(_DWORD *)(v37 + 8) = v34;
          v81 = v47;
          *v45 = v37 | v47 & 1;
          *(_DWORD *)(v34 + 4) &= ~1u;
          goto LABEL_45;
        }
LABEL_49:
        v49 = v79 | 1;
        if ( !v40 )
          v49 = v81;
        v50 = v80;
        *(_DWORD *)(v20 + 4) = v49;
        *(_DWORD *)(v34 + 4) &= ~1u;
        *(_DWORD *)((*(_DWORD *)(v20 + 4) & 0xFFFFFFFE) + 4) &= ~1u;
        *(_DWORD *)(v34 + 4) = v37 | *(_DWORD *)(v34 + 4) & 1;
        v51 = *v50;
        *(_DWORD *)(v20 + 8) = v34;
        v81 = v51;
        *v50 = v20 | v51 & 1;
        goto LABEL_45;
      }
    }
    if ( v81 && (*(_BYTE *)(v81 + 4) & 1) != 0 )
    {
      v48 = *(_DWORD *)(v34 + 4);
      v79 = v36;
      v40 = v48 & 1;
      goto LABEL_49;
    }
    *(_DWORD *)(v20 + 4) = v36 | 1;
LABEL_53:
    v23 = v34;
    if ( !--v5 )
      goto LABEL_54;
  }
  v20 = *(_DWORD *)(v34 + 8);
  v52 = *(_DWORD *)(v20 + 4);
  v53 = v52 & 0xFFFFFFFE;
  if ( (v52 & 1) != 0 )
  {
    *(_DWORD *)(v20 + 4) = v53;
    v54 = v80;
    ++v5;
    *(_DWORD *)(v34 + 4) |= 1u;
    v55 = *(_DWORD *)(v20 + 4) & 1;
    v56 = *(_DWORD *)(v20 + 4) & 0xFFFFFFFE;
    *(_DWORD *)(v34 + 8) = v56;
    *(_DWORD *)(v20 + 4) = v34 | v55;
    *v54 = v20 | v77 & 1;
    v80 = (_DWORD *)(v20 + 4);
    *(_DWORD *)(v79 + v78 + 4) = v20 + 4;
    v52 = *(_DWORD *)(v56 + 4);
    v20 = v56;
    v53 = v52 & 0xFFFFFFFE;
  }
  if ( !v53 || (v57 = *(_DWORD *)(v53 + 4), (v57 & 1) == 0) )
  {
    v63 = *(_DWORD *)(v20 + 8);
    if ( v63 )
    {
      v78 = *(_DWORD *)(v20 + 8);
      if ( (*(_BYTE *)(v63 + 4) & 1) != 0 )
      {
        v64 = *(_DWORD *)(v34 + 4);
        v79 = v52;
        v81 = v64 & 1;
        goto LABEL_67;
      }
    }
    *(_DWORD *)(v20 + 4) = v52 | 1;
    goto LABEL_53;
  }
  v79 = v52;
  v58 = *(_DWORD *)(v20 + 8);
  v81 = *(_DWORD *)(v34 + 4) & 1;
  if ( !v58 || (v78 = v58, (*(_BYTE *)(v58 + 4) & 1) == 0) )
  {
    if ( v81 )
      v59 = v57 | 1;
    else
      v59 = v57 & 0xFFFFFFFE;
    *(_DWORD *)(v53 + 4) = v59;
    v60 = v80;
    *(_DWORD *)(v34 + 8) = v57 & 0xFFFFFFFE;
    v61 = *v60;
    *(_DWORD *)(v20 + 4) = *(_DWORD *)(v53 + 8) | *(_DWORD *)(v20 + 4) & 1;
    v62 = *(_DWORD *)(v53 + 4);
    *(_DWORD *)(v53 + 8) = v20;
    v81 = v61;
    *(_DWORD *)(v53 + 4) = v34 | v62 & 1;
    *v60 = v61 & 1 | v53;
    *(_DWORD *)(v34 + 4) &= ~1u;
    goto LABEL_45;
  }
LABEL_67:
  v65 = v80;
  if ( v81 )
    v53 = v79 | 1;
  *(_DWORD *)(v20 + 4) = v53;
  v66 = v78;
  *(_DWORD *)(v34 + 4) &= ~1u;
  *(_DWORD *)(v66 + 4) &= ~1u;
  v67 = *(_DWORD *)(v20 + 4);
  *(_DWORD *)(v34 + 8) = v67 & 0xFFFFFFFE;
  *(_DWORD *)(v20 + 4) = v34 | v67 & 1;
  v81 = *v65;
  v20 |= v81 & 1;
  *v65 = v20;
LABEL_45:
  free((int)&v83, (int *)v20, (int)v75);
  return v76;
}
// 80CE000: using guessed type _TBYTE GLOBAL_OFFSET_TABLE_;

//----- (08062920) --------------------------------------------------------
int __cdecl twalk(int a1, int (__cdecl *a2)(int, int, int))
{
  int result; // eax

  result = a1;
  if ( a1 )
  {
    if ( a2 )
      return trecurse(a1, a2, 0);
  }
  return result;
}

//----- (08062940) --------------------------------------------------------
int *__usercall tdestroy@<eax>(int a1@<ecx>, int a2@<ebp>, int *a3, int *a4)
{
  int *result; // eax

  result = a3;
  if ( a3 )
    return tdestroy_recurse(a3, a4, a1, a2);
  return result;
}

//----- (08062960) --------------------------------------------------------
char *__usercall next_line@<eax>(int a1@<eax>, char *a2@<edx>, char **a3@<ecx>, void **a4, char *a5)
{
  char *v5; // ebp
  char *v6; // ebx
  _BYTE *v8; // eax
  signed int nocancel; // eax
  char *v11; // ebp
  _BYTE *v12; // edi
  char *v13; // edx
  int v14; // eax
  int v15; // ebx

  v5 = *a3;
  v6 = (char *)*a4;
  v8 = memchr(v5, 10, (_BYTE *)*a4 - v5);
  if ( !v8 )
  {
    if ( v5 == a2 || v6 != a5 )
      goto LABEL_3;
    memmove(a2, v5, v6 - v5);
    *a4 = (void *)((char *)*a4 + (_DWORD)a2 - *a3);
    *a3 = a2;
    nocancel = _read_nocancel(a1, *a4, a5 - (_BYTE *)*a4);
    if ( nocancel < 0 )
      return 0;
    v6 = (char *)*a4 + nocancel;
    *a4 = v6;
    v5 = *a3;
    v8 = memchr(*a3, 10, v6 - *a3);
    if ( !v8 )
    {
      if ( v6 == a5 )
      {
        v11 = &a2[3 * (a5 - a2) / 4];
        while ( 1 )
        {
          *a4 = v11;
          v14 = _read_nocancel(a1, v11, a5 - v11);
          v15 = v14;
          if ( v14 < 0 )
            return 0;
          v12 = *a4;
          v8 = memchr(*a4, 10, v14);
          *v12 = 10;
          v13 = (char *)*a4 + v15;
          *a4 = v13;
          if ( v8 )
          {
            v5 = *a3;
            goto LABEL_2;
          }
          if ( v13 != a5 )
          {
            v6 = v13;
            v5 = *a3;
            goto LABEL_3;
          }
        }
      }
      goto LABEL_3;
    }
  }
LABEL_2:
  v6 = v8 + 1;
LABEL_3:
  *a3 = v6;
  if ( *a4 < v6 )
    _assert_fail(
      (int)&GLOBAL_OFFSET_TABLE_ - 171762,
      (int)&GLOBAL_OFFSET_TABLE_ - 171848,
      119,
      (int)&GLOBAL_OFFSET_TABLE_ - 171772);
  if ( *a4 != v5 )
    return v5;
  return 0;
}
// 80CE000: using guessed type _TBYTE GLOBAL_OFFSET_TABLE_;

//----- (08062B00) --------------------------------------------------------
unsigned int __usercall sysinfo_mempages@<eax>(int a1@<eax>, unsigned int a2@<edx>)
{
  unsigned int v4; // ecx
  unsigned int result; // eax

  v4 = getpagesize();
  if ( v4 > 1 && a2 > 1 )
  {
    do
    {
      a2 >>= 1;
      v4 >>= 1;
    }
    while ( a2 > 1 && v4 > 1 );
  }
  result = a2 * a1;
  if ( v4 > 1 )
  {
    do
    {
      v4 >>= 1;
      result >>= 1;
    }
    while ( v4 != 1 );
  }
  return result;
}

//----- (08062B50) --------------------------------------------------------
int get_nprocs()
{
  int v0; // eax
  char *v1; // ecx
  int v2; // edx
  char *v3; // ebx
  int v4; // eax
  int v5; // ebx
  unsigned __int8 *v6; // edi
  unsigned int v7; // eax
  unsigned __int8 *v8; // edx
  unsigned int v9; // esi
  int v10; // esi
  unsigned int v11; // edi
  int v12; // edi
  char *v13; // eax
  _TBYTE *v14; // eax
  void *v16; // esp
  char *line; // esi
  char *v18; // [esp-100Ch] [ebp-1054h]
  _BYTE v19[4]; // [esp-1004h] [ebp-104Ch]
  char v20[4096]; // [esp-1000h] [ebp-1048h] BYREF
  int v21; // [esp+0h] [ebp-48h] BYREF
  _TBYTE *v22; // [esp+4h] [ebp-44h]
  char *i; // [esp+8h] [ebp-40h]
  char *v24; // [esp+Ch] [ebp-3Ch]
  int v25; // [esp+10h] [ebp-38h]
  unsigned int v26; // [esp+14h] [ebp-34h]
  char *v27; // [esp+18h] [ebp-30h]
  char **v28; // [esp+1Ch] [ebp-2Ch]
  char *v29; // [esp+20h] [ebp-28h] BYREF
  char *v30; // [esp+24h] [ebp-24h] BYREF
  int v31[8]; // [esp+28h] [ebp-20h] BYREF

  v22 = &GLOBAL_OFFSET_TABLE_;
  v31[1] = __readgsdword(0x14u);
  v21 = time(0);
  if ( v21 != timestamp_11438 || (v5 = *((_DWORD *)v22 + 600), v5 < 0) )
  {
    v0 = !_libc_alloca_cutoff(0x2000u) ? 512 : 0x2000;
    v1 = (char *)&v21 - ((v0 + 16) & 0xFFFFF000);
    if ( &v21 != (int *)v1 )
    {
      while ( v20 != v1 )
        ;
    }
    v2 = ((_WORD)v0 + 16) & 0xFFF;
    if ( (((_WORD)v0 + 16) & 0xFFF) != 0 )
    {
      v16 = alloca(v2);
      *(_DWORD *)&v19[v2] = *(_DWORD *)&v19[v2];
    }
    v24 = v20;
    v27 = &v20[v0];
    v3 = &v20[v0];
    v29 = &v20[v0];
    v30 = &v20[v0];
    v4 = _open_nocancel((int)v22 - 171804);
    v25 = v4;
    if ( v4 != -1 )
    {
      v18 = v3;
      v5 = 0;
      v6 = (unsigned __int8 *)next_line(v4, v20, &v29, (void **)&v30, v18);
      v28 = (char **)v31;
      v26 = -8;
      if ( v6 )
      {
        while ( 1 )
        {
          v7 = strtoul(v6, v28, 10);
          v8 = (unsigned __int8 *)v31[0];
          v9 = v7;
          if ( (unsigned __int8 *)v31[0] == v6 )
            break;
          if ( *(_BYTE *)v31[0] == 45 )
          {
            v12 = v31[0] + 1;
            v7 = strtoul((unsigned __int8 *)(v31[0] + 1), v28, 10);
            v8 = (unsigned __int8 *)v31[0];
            if ( v31[0] == v12 )
              break;
          }
          v10 = v7 + v5 - v9 + 1;
          v5 = v10;
          if ( v8 >= (unsigned __int8 *)v30 )
          {
LABEL_27:
            _close_nocancel(v25);
            if ( v10 > 0 )
              goto LABEL_23;
            goto LABEL_17;
          }
          v11 = __readgsdword(v26);
          while ( (*(_BYTE *)(v11 + 2 * (char)*v8 + 1) & 0x20) != 0 )
          {
            if ( ++v8 == (unsigned __int8 *)v30 )
              goto LABEL_27;
          }
          v6 = v8;
        }
      }
      _close_nocancel(v25);
    }
LABEL_17:
    v29 = v27;
    v30 = v27;
    v25 = _open_nocancel((int)v22 - 171751);
    if ( v25 == -1 )
    {
      v5 = 2;
      v25 = _open_nocancel((int)(v22 - 17174));
      if ( v25 == -1 )
        goto LABEL_23;
      v5 = 0;
      v28 = &v29;
      v26 = (unsigned int)&v30;
      for ( i = (char *)v22 - 171726; ; v5 += memcmp(line, i, 9u) == 0 )
      {
        line = next_line(v25, v24, v28, (void **)v26, v27);
        if ( !line )
          break;
      }
    }
    else
    {
      v5 = 0;
      v28 = &v29;
      v26 = (unsigned int)&v30;
      i = (char *)v22 - 171696;
      while ( 1 )
      {
        v13 = next_line(v25, v24, v28, (void **)v26, v27);
        if ( !v13 || memcmp(v13, i, 3u) )
          break;
        v5 += (unsigned int)(v13[3] - 48) < 0xA;
      }
    }
    _close_nocancel(v25);
LABEL_23:
    v14 = v22;
    *((_DWORD *)v22 + 600) = v5;
    *((_DWORD *)v14 + 1576) = v21;
  }
  return v5;
}
// 80CE000: using guessed type _TBYTE GLOBAL_OFFSET_TABLE_;
// 80CF8A0: using guessed type int timestamp_11438;

//----- (08062E90) --------------------------------------------------------
int __usercall get_nprocs_conf@<eax>(int *a1@<edi>)
{
  int v1; // ebp
  int *v2; // ebx
  int v3; // eax
  bool v4; // cf
  bool v5; // zf
  _BYTE *v6; // esi
  int v7; // ecx
  int v8; // esi
  int v10[9]; // [esp+10h] [ebp-24h] BYREF

  v1 = 0;
  v10[1] = __readgsdword(0x14u);
  v2 = opendir("/sys/devices/system/cpu");
  if ( !v2 )
    return get_nprocs();
  while ( 1 )
  {
    v3 = readdir64((int)v2);
    if ( !v3 )
      break;
    while ( 1 )
    {
      v4 = *(_BYTE *)(v3 + 18) < 4u;
      v5 = *(_BYTE *)(v3 + 18) == 4;
      if ( *(_BYTE *)(v3 + 18) != 4 )
        break;
      a1 = (int *)"cpu";
      v6 = (_BYTE *)(v3 + 19);
      v7 = 3;
      do
      {
        if ( !v7 )
          break;
        v4 = *v6 < *(_BYTE *)a1;
        v5 = *v6++ == *(_BYTE *)a1;
        a1 = (int *)((char *)a1 + 1);
        --v7;
      }
      while ( v5 );
      if ( (!v4 && !v5) != v4 )
        break;
      v8 = v3 + 22;
      if ( strtoul((unsigned __int8 *)(v3 + 22), v10, 10) == -1 || v8 == v10[0] )
        break;
      v1 += *(_BYTE *)v10[0] == 0;
      v3 = readdir64((int)v2);
      if ( !v3 )
        goto LABEL_11;
    }
  }
LABEL_11:
  closedir(v1, a1, v2);
  return v1;
}

//----- (08062F90) --------------------------------------------------------
unsigned int get_phys_pages()
{
  struct sysinfo v1; // [esp+18h] [ebp-50h] BYREF
  unsigned int v2; // [esp+58h] [ebp-10h]

  v2 = __readgsdword(0x14u);
  sysinfo(&v1);
  return sysinfo_mempages(v1.totalram, v1.mem_unit);
}

//----- (08062FE0) --------------------------------------------------------
unsigned int get_avphys_pages()
{
  struct sysinfo v1; // [esp+18h] [ebp-50h] BYREF
  unsigned int v2; // [esp+58h] [ebp-10h]

  v2 = __readgsdword(0x14u);
  sysinfo(&v1);
  return sysinfo_mempages(v1.freeram, v1.mem_unit);
}

//----- (08063030) --------------------------------------------------------
int _getclktck()
{
  int result; // eax

  result = dl_clktck;
  if ( !dl_clktck )
    return 100;
  return result;
}

//----- (08063060) --------------------------------------------------------
void __cdecl _init_misc(int a1, char (**a2)[1671])
{
  unsigned int *v2; // ebx
  unsigned int *v3; // eax

  if ( a2 )
  {
    v2 = (unsigned int *)*a2;
    if ( *a2 )
    {
      v3 = strrchr(v2, 47);
      if ( v3 )
        v2 = (unsigned int *)((char *)v3 + 1);
      program_invocation_short_name[0] = (char (*)[1671])v2;
      program_invocation_name = *a2;
    }
  }
}
// 80CE964: using guessed type char (*program_invocation_short_name[2])[1671];
// 80CE968: using guessed type char (*program_invocation_name)[1671];

//----- (080630B0) --------------------------------------------------------
unsigned int __cdecl mremap(void *a1, size_t a2, size_t a3, unsigned int a4)
{
  unsigned int result; // eax

  result = sys_mremap(a1, a2, a3, a4);
  if ( result >= 0xFFFFF001 )
    return _syscall_error(result);
  return result;
}

//----- (080630F0) --------------------------------------------------------
unsigned int __cdecl sysinfo(struct sysinfo *a1)
{
  unsigned int result; // eax

  result = sys_sysinfo(a1);
  if ( result >= 0xFFFFF001 )
    return _syscall_error(result);
  return result;
}

//----- (08063120) --------------------------------------------------------
void __noreturn _chk_fail()
{
  _fortify_fail((char)"buffer overflow detected");
}

//----- (08063170) --------------------------------------------------------
void __cdecl __noreturn _fortify_fail_abort(char a1, char a2)
{
  char v2; // dl

  while ( 1 )
  {
    if ( a1 )
      v2 = 3;
    else
      v2 = 1;
    _libc_message(v2, "*** %s ***: %s terminated\n", a2);
  }
}
// 80CFF78: using guessed type int _libc_argv;

//----- (080631E0) --------------------------------------------------------
void __cdecl __noreturn _fortify_fail(char a1)
{
  _fortify_fail_abort(1, a1);
}

//----- (08063200) --------------------------------------------------------
void dl_debug_state()
{
  ;
}

//----- (08063210) --------------------------------------------------------
void **__cdecl dl_debug_initialize(void *a1, int a2)
{
  void *v2; // ebx
  void **result; // eax

  v2 = a1;
  if ( !a2 )
  {
    result = (void **)r_debug;
    if ( r_debug[1] )
      goto LABEL_3;
LABEL_8:
    *result = (void *)1;
    if ( !a1 )
      v2 = (void *)r_debug[4];
    goto LABEL_5;
  }
  result = &dl_ns + 19 * a2 + 14;
  if ( !*(&dl_ns + 19 * a2 + 15) )
    goto LABEL_8;
LABEL_3:
  if ( !a1 )
    return result;
  *result = (void *)1;
LABEL_5:
  result[4] = v2;
  result[1] = *(&dl_ns + 19 * a2);
  result[2] = dl_debug_state;
  return result;
}
// 80CEA00: using guessed type void *dl_ns;
// 80CFEE8: using guessed type _DWORD r_debug[5];

//----- (080632A0) --------------------------------------------------------
int __usercall do_tunable_update_val@<eax>(int result@<eax>, unsigned int *a2@<edx>)
{
  int v2; // ecx
  unsigned int v3; // ebx
  unsigned int v4; // edx

  v2 = *(_DWORD *)(result + 4);
  if ( v2 == 3 )
  {
    *(_DWORD *)(result + 24) = a2;
    return result;
  }
  v3 = *a2;
  v4 = a2[1];
  if ( v2 == 1 || v2 )
  {
    if ( __PAIR64__(v4, v3) >= *(_QWORD *)(result + 8) && *(_QWORD *)(result + 16) >= __PAIR64__(v4, v3) )
    {
LABEL_6:
      *(_DWORD *)(result + 24) = v3;
      *(_DWORD *)(result + 28) = v4;
      *(_BYTE *)(result + 32) = 1;
    }
  }
  else if ( __SPAIR64__(v4, v3) >= *(_QWORD *)(result + 8) && *(_QWORD *)(result + 16) >= __SPAIR64__(v4, v3) )
  {
    goto LABEL_6;
  }
  return result;
}

//----- (08063310) --------------------------------------------------------
int __usercall tunable_initialize@<eax>(int a1@<eax>, unsigned int *a2@<edx>)
{
  unsigned int v4; // edx
  unsigned int v5[5]; // [esp+8h] [ebp-14h] BYREF

  if ( *(_DWORD *)(a1 + 4) == 3 )
  {
    *(_BYTE *)(a1 + 32) = 1;
    return do_tunable_update_val(a1, a2);
  }
  else
  {
    v5[0] = dl_strtoul(a2, 0);
    v5[1] = v4;
    return do_tunable_update_val(a1, v5);
  }
}
// 8063341: variable 'v4' is possibly undefined

//----- (08063360) --------------------------------------------------------
int __cdecl _tunable_set_val(int a1, unsigned int *a2)
{
  return do_tunable_update_val((int)&(&tunable_list)[11 * a1], a2);
}
// 80CD940: using guessed type char *tunable_list;

//----- (08063390) --------------------------------------------------------
int *__cdecl _tunables_init(int *a1)
{
  int *result; // eax
  int v2; // ebp
  char v3; // cl
  int *v4; // ebx
  char v5; // dl
  int *v6; // esi
  char *v7; // esi
  _BYTE *v8; // eax
  char v9; // dl
  _BYTE *v10; // ebx
  int v11; // edi
  char *v12; // esi
  _BYTE *v13; // ebx
  char v14; // al
  char *v15; // edx
  _BYTE *v16; // ecx
  char v17; // bl
  int v18; // eax
  int v19; // ebx
  char j; // dl
  int v21; // eax
  bool v22; // zf
  char *v23; // esi
  char *v24; // ebp
  int v25; // edx
  char v26; // al
  char *v27; // edx
  char v28; // di
  int v29; // ebx
  char v30; // al
  char **v31; // esi
  int v32; // edi
  char v33; // al
  int v34; // eax
  char v35; // cl
  char v36; // dl
  char *v37; // esi
  int v38; // eax
  unsigned int *v39; // edx
  char *i; // ebp
  char v41; // dl
  int v42; // eax
  char v43; // cl
  int *v44; // eax
  int v45; // edx
  char *v46; // edx
  char *v47; // eax
  char k; // cl
  char *v49; // [esp+0h] [ebp-48h]
  char v50; // [esp+0h] [ebp-48h]
  char *v51; // [esp+4h] [ebp-44h]
  int *v52; // [esp+4h] [ebp-44h]
  int *v53; // [esp+Ch] [ebp-3Ch]
  unsigned int *v54; // [esp+18h] [ebp-30h]
  char v55; // [esp+1Fh] [ebp-29h]
  int v56; // [esp+24h] [ebp-24h]
  char *v57; // [esp+28h] [ebp-20h]

  if ( _libc_enable_secure && (unsigned int)sys_access((const char *)&GLOBAL_OFFSET_TABLE_ - 171591, 0) <= 0xFFFFF000 )
    *((_DWORD *)&GLOBAL_OFFSET_TABLE_ - 170) = 2;
LABEL_2:
  while ( 1 )
  {
    result = a1;
    if ( !a1 )
      return result;
    while ( 1 )
    {
      result = a1;
      v2 = *a1;
      if ( !*a1 )
        return result;
      result = a1;
      v3 = *(_BYTE *)v2;
      v4 = a1 + 1;
      if ( !*(_BYTE *)v2 )
        goto LABEL_39;
LABEL_5:
      if ( v3 != 61 )
      {
        result = 0;
        do
        {
          result = (int *)((char *)result + 1);
          v5 = *((_BYTE *)result + v2);
          v6 = result;
        }
        while ( v5 && v5 != 61 );
        goto LABEL_9;
      }
LABEL_39:
      while ( 1 )
      {
        v5 = v3;
        v6 = 0;
LABEL_9:
        if ( v5 )
          break;
        if ( !v4 )
          return result;
        v2 = *v4;
        a1 = v4;
        if ( !*v4 )
          return result;
        result = v4;
        v3 = *(_BYTE *)v2;
        ++v4;
        if ( *(_BYTE *)v2 )
          goto LABEL_5;
      }
      v7 = (char *)v6 + 1;
      v53 = v4;
      result = (int *)&v7[v2];
      v54 = (unsigned int *)&v7[v2];
      if ( !v4 )
        return result;
      if ( v3 == 71 )
      {
        v8 = (_BYTE *)(v2 + 1);
        v9 = 76;
        v10 = (char *)&GLOBAL_OFFSET_TABLE_ - 171605;
        do
        {
          if ( *v8 != v9 || !*v8 )
            goto LABEL_17;
          v9 = *++v10;
          ++v8;
        }
        while ( *v10 );
        if ( *v8 == 61 )
          break;
      }
LABEL_17:
      v49 = (char *)v2;
      v11 = 0;
      v12 = byte_80CD960;
      do
      {
        if ( !*v12 )
        {
          v13 = (_BYTE *)*((_DWORD *)v12 + 2);
          if ( v13 )
          {
            v14 = *v49;
            if ( *v13 )
            {
              if ( !v14 || *v13 != v14 )
                goto LABEL_29;
              v15 = v49;
              v16 = (_BYTE *)*((_DWORD *)v12 + 2);
              while ( 1 )
              {
                ++v16;
                v17 = *++v15;
                if ( !*v16 )
                  break;
                if ( *v16 != v17 || !v17 )
                  goto LABEL_29;
              }
              v14 = *v15;
              v13 = (_BYTE *)*((_DWORD *)v12 + 2);
            }
            if ( v14 != 61 )
              goto LABEL_29;
            if ( !_libc_enable_secure )
              goto LABEL_35;
            v18 = *((_DWORD *)v12 + 1);
            if ( v18 )
              goto LABEL_34;
            v52 = a1;
LABEL_83:
            for ( i = (char *)*v52; *v52; i = (char *)*v52 )
            {
              v41 = *i;
              if ( *v13 )
              {
                if ( *v13 != v41 || !v41 )
                  goto LABEL_92;
                v42 = 1;
                while ( 1 )
                {
                  v43 = v13[v42];
                  v41 = i[v42];
                  if ( !v43 )
                    break;
                  ++v42;
                  if ( !v41 || v43 != v41 )
                    goto LABEL_92;
                }
              }
              if ( v41 == 61 )
              {
                v44 = v52;
                do
                {
                  v45 = v44[1];
                  *v44++ = v45;
                }
                while ( v45 );
                goto LABEL_83;
              }
LABEL_92:
              ++v52;
            }
            v18 = *((_DWORD *)v12 + 1);
            v53 = a1;
LABEL_34:
            if ( v18 == 2 )
            {
LABEL_35:
              tunable_initialize((int)&(&tunable_list)[11 * v11], v54);
              a1 = v53;
              goto LABEL_2;
            }
          }
        }
LABEL_29:
        ++v11;
        v12 += 44;
      }
      while ( v11 != 24 );
      a1 = v53;
      result = v53;
      if ( !v53 )
        return result;
    }
    v19 = 0;
    for ( j = v3; j; j = *(_BYTE *)(v2 + v19++ + 1) )
      ;
    v56 = sbrk(v19 + 1);
    if ( v56 == -1 )
    {
      v56 = 0;
    }
    else
    {
      v21 = v19 - 1;
      if ( v19 )
      {
        do
        {
          *(_BYTE *)(v56 + v21) = *(_BYTE *)(v2 + v21);
          --v21;
        }
        while ( v21 != -1 );
LABEL_46:
        v22 = &v7[v56] == 0;
        v23 = &v7[v56];
        v57 = v23;
        if ( !v22 )
        {
          v24 = v23;
          v50 = *v23;
          if ( *v23 )
          {
            while ( 2 )
            {
              while ( 2 )
              {
                if ( v50 == 58 || v50 == 61 )
                {
                  v26 = v50;
                  v25 = 0;
                }
                else
                {
                  if ( !v50 )
                    goto LABEL_55;
                  v25 = 0;
                  while ( 1 )
                  {
                    v26 = v24[++v25];
                    if ( v26 == 61 || v26 == 58 )
                      break;
                    if ( !v26 )
                      goto LABEL_55;
                  }
                }
                v27 = &v24[v25 + 1];
                v28 = *v27;
                v51 = v27;
                if ( v26 == 58 )
                {
                  v50 = *v27;
                  v24 = v27;
                  continue;
                }
                break;
              }
              v29 = 0;
              if ( v28 && v28 != 58 )
              {
                do
                  v30 = v27[++v29];
                while ( v30 != 58 && v30 );
                v28 = v27[v29];
              }
              v31 = &tunable_list;
              v55 = v28;
              v32 = 0;
LABEL_65:
              v33 = **v31;
              if ( v33 )
              {
                if ( v33 == v50 )
                {
                  v34 = 1;
                  do
                  {
                    v35 = (*v31)[v34];
                    v36 = v24[v34];
                    if ( !v35 )
                      goto LABEL_71;
                    ++v34;
                  }
                  while ( v36 && v35 == v36 );
                }
              }
              else
              {
                v36 = v50;
LABEL_71:
                if ( v36 == 61 )
                {
                  if ( !_libc_enable_secure )
                  {
                    v24 = v51;
                    v37 = &v51[v29];
                    goto LABEL_80;
                  }
                  v38 = dword_80CD964[11 * v32];
                  if ( v38 )
                  {
                    v24 = v51;
                    v37 = &v51[v29];
                  }
                  else
                  {
                    if ( !v55 )
                    {
                      *v24 = 0;
                      goto LABEL_55;
                    }
                    v46 = &v51[v29 + 1];
                    v47 = v24;
                    for ( k = *v46; *v46; k = *v46 )
                    {
                      ++v46;
                      *v47++ = k;
                    }
                    *v47 = 0;
                    v37 = v24;
                    v29 = 0;
                    v38 = dword_80CD964[11 * v32];
                  }
                  if ( v38 == 2 )
                  {
LABEL_80:
                    v39 = (unsigned int *)((char *)v54 + v51 - v57);
                    *((_BYTE *)v39 + v29) = 0;
                    tunable_initialize((int)&(&tunable_list)[11 * v32], v39);
                  }
LABEL_74:
                  if ( !*v37 )
                    goto LABEL_55;
                  v24 += v29 + 1;
                  v50 = *v24;
                  continue;
                }
              }
              break;
            }
            ++v32;
            v31 += 11;
            if ( v32 == 24 )
            {
              v24 = v51;
              v37 = &v51[v29];
              goto LABEL_74;
            }
            goto LABEL_65;
          }
        }
      }
      else if ( v56 )
      {
        goto LABEL_46;
      }
    }
LABEL_55:
    *a1 = v56;
    a1 = v53;
  }
}
// 806364A: conditional instruction was optimized away because al.1 is in (==3A|==3D)
// 80636A7: conditional instruction was optimized away because %var_48.1!=0
// 80CD940: using guessed type char *tunable_list;
// 80CD964: using guessed type int dword_80CD964[255];
// 80CDDAC: using guessed type int _libc_enable_secure;
// 80CE000: using guessed type _TBYTE GLOBAL_OFFSET_TABLE_;

//----- (080638D0) --------------------------------------------------------
int __cdecl _tunable_get_val(int a1, char **a2, int (__cdecl *a3)(char **))
{
  char **v3; // edi
  int result; // eax
  char *v5; // ebp
  char *v6; // edi

  v3 = &(&tunable_list)[11 * a1];
  if ( v3[1] == (char *)1 )
  {
    v5 = v3[7];
    v6 = v3[6];
    a2[1] = v5;
    *a2 = v6;
  }
  else
  {
    *a2 = v3[6];
  }
  result = 11 * a1;
  if ( byte_80CD960[44 * a1] )
  {
    if ( a3 )
      return a3(&(&tunable_list)[result + 6]);
  }
  return result * 4;
}
// 80CD940: using guessed type char *tunable_list;

//----- (08063960) --------------------------------------------------------
void dl_sysinfo_int80()
{
  __asm { int     80h; Alternative name is '.annobin_dl_support.c' }
}

//----- (08063970) --------------------------------------------------------
int __cdecl dl_aux_init(int *a1)
{
  int result; // eax
  int *v2; // edx
  unsigned int v3; // eax

  dl_auxv = a1;
  result = *a1;
  if ( *a1 )
  {
    v2 = a1;
    do
    {
      v3 = result - 3;
      if ( v3 <= 0x1E )
        __asm { jmp     edi }
      v2 += 2;
      result = *v2;
    }
    while ( *v2 );
    return 0;
  }
  return result;
}
// 8063AFD: conditional instruction was optimized away because %var_6F.1==0
// 8063B08: conditional instruction was optimized away because %var_6E.1==0
// 8063B19: conditional instruction was optimized away because %var_6D.1==0
// 8063B2A: conditional instruction was optimized away because %var_50.1==0
// 8063B3B: conditional instruction was optimized away because %var_4F.1==0
// 8063B4C: conditional instruction was optimized away because %var_4E.1==0
// 8063B67: conditional instruction was optimized away because %var_4D.1==0
// 8063B82: conditional instruction was optimized away because %var_46.1==0
// 8063B95: conditional instruction was optimized away because %var_45.1==0
// 8063BA6: conditional instruction was optimized away because %var_34.1==0
// 8063BB7: conditional instruction was optimized away because %var_33.1==0
// 8063BC8: conditional instruction was optimized away because %var_32.1==0
// 8063BD9: conditional instruction was optimized away because %var_31.1==0
// 80CDDAC: using guessed type int _libc_enable_secure;
// 80CE9B0: using guessed type int dl_pagesize;
// 80CE9E0: using guessed type int (*dl_sysinfo)();
// 80CF8C8: using guessed type int dl_hwcap;
// 80CFF18: using guessed type char *dl_platform;
// 80CFF30: using guessed type _DWORD *dl_phdr;
// 80CFF44: using guessed type int dl_sysinfo_dso;
// 80CFF50: using guessed type __int16 dl_phnum;

//----- (08063E50) --------------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
__int16 *__usercall dl_non_dynamic_init@<eax>(int a1@<ebp>)
{
  _BYTE *v1; // eax
  _BOOL4 v2; // edx
  unsigned __int8 *v3; // esi
  int v4; // ebp
  int v5; // ecx
  int v6; // edi
  int v7; // eax
  int v8; // edx
  int v9; // edx
  bool v10; // zf
  unsigned int *v11; // edx
  unsigned int v12; // eax
  unsigned __int8 *v13; // edi
  int *v14; // edx
  int v15; // eax
  int *v16; // edx
  int *v17; // ecx
  int *v18; // edx
  int *v19; // ecx
  int *v20; // edx
  int *v21; // ecx
  int *v22; // edx
  int *v23; // ecx
  int *v24; // edx
  int *v25; // ecx
  int *v26; // edx
  int *v27; // ecx
  int *v28; // edx
  int *v29; // ecx
  int *v30; // edx
  int v31; // edi
  int *v32; // ecx
  int v33; // eax
  int v34; // eax
  int v35; // eax
  int v36; // edx
  int v37; // eax
  int v38; // eax
  _DWORD *v39; // eax
  int v40; // eax
  unsigned int *v41; // edi
  int *v42; // eax
  int v43; // ecx
  _BYTE *v44; // eax
  _DWORD *v45; // edx
  unsigned int *v46; // eax
  _BYTE *v47; // eax
  _BOOL4 v48; // edx
  _BYTE *v49; // eax
  _BOOL4 v50; // edx
  _BYTE *v51; // eax
  _BOOL4 v52; // edx
  unsigned int *v53; // eax
  int v54; // edx
  const char *v55; // eax
  struct timespec *v56; // edi
  _BYTE *v57; // ebp
  int v58; // edi
  int i; // esi
  unsigned int v60; // eax
  int v61; // edx
  unsigned int v62; // edx
  __int16 *result; // eax
  __int16 *v64; // ecx
  int v65; // edx
  unsigned int v66; // ecx
  int v67[8]; // [esp+2Ch] [ebp-20h] BYREF

  dword_80CEC0C = dl_get_origin();
  dword_80CEBB4 = (int)dl_phdr;
  word_80CEBBC = dl_phnum;
  v1 = (_BYTE *)getenv((__int16 *)"LD_WARN");
  v2 = 0;
  if ( v1 )
    v2 = *v1 != 0;
  dl_verbose = v2;
  if ( dl_sysinfo_dso )
  {
    v3 = dl_new_object(&dl_sysinfo_dso, (unsigned int *)byte_80B41F9, (unsigned int *)byte_80B41F9, 1, 0, 0, 0);
    if ( v3 )
    {
      v4 = dl_sysinfo_dso;
      v5 = 0;
      v6 = *(unsigned __int16 *)(dl_sysinfo_dso + 44);
      v7 = dl_sysinfo_dso + *(_DWORD *)(dl_sysinfo_dso + 28);
      *((_WORD *)v3 + 174) = v6;
      *((_DWORD *)v3 + 85) = v7;
      if ( v6 )
      {
        do
        {
          while ( 1 )
          {
            v8 = *(_DWORD *)v7;
            if ( *(_DWORD *)v7 != 2 )
              break;
            v9 = *(_DWORD *)(v7 + 8);
            ++v5;
            v7 += 32;
            *((_DWORD *)v3 + 2) = v9;
            *((_WORD *)v3 + 175) = *(_DWORD *)(v7 - 12) >> 3;
            if ( v5 == v6 )
              goto LABEL_12;
          }
          if ( v8 == 1 )
          {
            v61 = *(_DWORD *)(v7 + 8);
            if ( !*(_DWORD *)v3 )
              *(_DWORD *)v3 = v61;
            v62 = *(_DWORD *)(v7 + 20) + v61;
            if ( v62 >= *((_DWORD *)v3 + 109) )
              *((_DWORD *)v3 + 109) = v62;
            if ( (*(_BYTE *)(v7 + 24) & 1) != 0 && v62 >= *((_DWORD *)v3 + 110) )
              *((_DWORD *)v3 + 110) = v62;
          }
          else if ( v8 == 7 )
          {
            _assert_fail((int)"ph->p_type != PT_TLS", (int)"setup-vdso.h", 61, (int)"setup_vdso");
          }
          ++v5;
          v7 += 32;
        }
        while ( v5 != v6 );
      }
LABEL_12:
      *((_DWORD *)v3 + 108) = v4;
      a1 = v4 - *(_DWORD *)v3;
      *((_DWORD *)v3 + 109) += a1;
      *((_DWORD *)v3 + 110) += a1;
      v10 = *((_DWORD *)v3 + 2) + a1 == 0;
      v11 = (unsigned int *)(*((_DWORD *)v3 + 2) + a1);
      *(_DWORD *)v3 = a1;
      *((_DWORD *)v3 + 2) = v11;
      if ( v10 )
        goto LABEL_53;
      v12 = *v11;
      v13 = v3 + 32;
      if ( !*v11 )
      {
LABEL_14:
        if ( a1 )
        {
          v14 = (int *)*((_DWORD *)v3 + 12);
          v15 = 0;
          if ( v14 )
          {
            dyn_temp_10684[0] = *v14;
            dword_80CDD64 = a1 + v14[1];
            *((_DWORD *)v3 + 12) = dyn_temp_10684;
            v15 = 1;
          }
          v16 = (int *)*((_DWORD *)v3 + 11);
          if ( v16 )
          {
            v17 = &dyn_temp_10684[2 * v15++];
            *v17 = *v16;
            v17[1] = a1 + v16[1];
            *((_DWORD *)v3 + 11) = v17;
          }
          v18 = (int *)*((_DWORD *)v3 + 13);
          if ( v18 )
          {
            v19 = &dyn_temp_10684[2 * v15++];
            *v19 = *v18;
            v19[1] = a1 + v18[1];
            *((_DWORD *)v3 + 13) = v19;
          }
          v20 = (int *)*((_DWORD *)v3 + 14);
          if ( v20 )
          {
            v21 = &dyn_temp_10684[2 * v15++];
            *v21 = *v20;
            v21[1] = a1 + v20[1];
            *((_DWORD *)v3 + 14) = v21;
          }
          v22 = (int *)*((_DWORD *)v3 + 15);
          if ( v22 )
          {
            v23 = &dyn_temp_10684[2 * v15++];
            *v23 = *v22;
            v23[1] = a1 + v22[1];
            *((_DWORD *)v3 + 15) = v23;
          }
          v24 = (int *)*((_DWORD *)v3 + 25);
          if ( v24 )
          {
            v25 = &dyn_temp_10684[2 * v15++];
            *v25 = *v24;
            v25[1] = a1 + v24[1];
            *((_DWORD *)v3 + 25) = v25;
          }
          v26 = (int *)*((_DWORD *)v3 + 31);
          if ( v26 )
          {
            v27 = &dyn_temp_10684[2 * v15++];
            *v27 = *v26;
            v27[1] = a1 + v26[1];
            *((_DWORD *)v3 + 31) = v27;
          }
          v28 = (int *)*((_DWORD *)v3 + 58);
          if ( v28 )
          {
            v29 = &dyn_temp_10684[2 * v15++];
            *v29 = *v28;
            v29[1] = a1 + v28[1];
            *((_DWORD *)v3 + 58) = v29;
          }
          v30 = (int *)*((_DWORD *)v3 + 84);
          if ( v30 )
          {
            v31 = *v30;
            v32 = &dyn_temp_10684[2 * v15];
            v32[1] = v30[1] + a1;
            *v32 = v31;
            *((_DWORD *)v3 + 84) = v32;
            if ( v15 == 8 )
              _assert_fail(
                (int)"cnt <= DL_RO_DYN_TEMP_CNT",
                (int)"get-dynamic-info.h",
                115,
                (int)"elf_get_dynamic_info");
          }
        }
        v33 = *((_DWORD *)v3 + 28);
        if ( v33 )
        {
          v34 = *(_DWORD *)(v33 + 4);
          if ( v34 != 17 && v34 != 7 )
            _assert_fail(
              (int)"info[DT_PLTREL]->d_un.d_val == DT_REL || info[DT_PLTREL]->d_un.d_val == DT_RELA",
              (int)"get-dynamic-info.h",
              126,
              (int)"elf_get_dynamic_info");
        }
        if ( *((_DWORD *)v3 + 15) && *(_DWORD *)(*((_DWORD *)v3 + 17) + 4) != 12 )
          _assert_fail(
            (int)"info[DT_RELAENT]->d_un.d_val == sizeof (ElfW(Rela))",
            (int)"get-dynamic-info.h",
            131,
            (int)"elf_get_dynamic_info");
        a1 = *((_DWORD *)v3 + 25);
        if ( a1 && *(_DWORD *)(*((_DWORD *)v3 + 27) + 4) != 8 )
          _assert_fail(
            (int)"info[DT_RELENT]->d_un.d_val == sizeof (ElfW(Rel))",
            (int)"get-dynamic-info.h",
            135,
            (int)"elf_get_dynamic_info");
        v35 = *((_DWORD *)v3 + 38);
        if ( v35 )
        {
          v36 = *(_DWORD *)(v35 + 4);
          *((_DWORD *)v3 + 131) = v36;
          if ( (v36 & 2) != 0 )
            *((_DWORD *)v3 + 24) = v35;
          if ( (v36 & 4) != 0 )
            *((_DWORD *)v3 + 30) = v35;
          if ( (v36 & 8) != 0 )
            *((_DWORD *)v3 + 32) = v35;
        }
        v37 = *((_DWORD *)v3 + 47);
        if ( v37 )
        {
          v38 = *(_DWORD *)(v37 + 4);
          *((_DWORD *)v3 + 130) = v38;
          if ( (dl_debug_mask[0] & 0x40) != 0 && (v38 & 0xFFFFF716) != 0 )
          {
            dl_debug_printf("\nWARNING: Unsupported flag value(s) of 0x%x in DT_FLAGS_1.\n", v38 & 0xFFFFF716);
            v38 = *((_DWORD *)v3 + 130);
          }
          if ( (v38 & 1) != 0 )
            *((_DWORD *)v3 + 32) = *((_DWORD *)v3 + 47);
        }
        if ( *((_DWORD *)v3 + 37) )
          *((_DWORD *)v3 + 23) = 0;
LABEL_53:
        dl_setup_hash(v3);
        v39 = (_DWORD *)*((_DWORD *)v3 + 117);
        v3[408] |= 4u;
        *((_DWORD *)v3 + 128) = 1;
        v39[1] = 1;
        *v39 = v3 + 20;
        v40 = *((_DWORD *)v3 + 22);
        if ( v40 )
        {
          v41 = (unsigned int *)(*(_DWORD *)(*((_DWORD *)v3 + 13) + 4) + *(_DWORD *)(v40 + 4));
          a1 = strlen(v41) + 1;
          v42 = malloc((const struct timespec *)a1);
          if ( !v42 )
          {
            dl_dprintf(2, "out of memory\n", v43, v43);
            exit(127);
          }
          v44 = memcpy(v42, v41, a1);
          v45 = (_DWORD *)*((_DWORD *)v3 + 7);
          *((_DWORD *)v3 + 1) = v44;
          *v45 = v44;
        }
        dl_add_to_namespace_list(v3, 0);
        dl_nns = 1;
        dl_sysinfo_map = v3;
        if ( (char *)dl_sysinfo == (char *)dl_sysinfo_int80 )
          dl_sysinfo = (int (*)())(*(_DWORD *)(dl_sysinfo_dso + 24) + *(_DWORD *)v3);
        goto LABEL_58;
      }
      while ( 1 )
      {
        if ( v12 > 0x22 )
        {
          if ( 1879048191 - v12 > 0xF )
          {
            v66 = (int)(2 * v12) >> 1;
            if ( v66 <= 0xFFFFFFFC )
            {
              if ( 1879047679 - v12 > 0xB )
              {
                if ( 1879047935 - v12 <= 0xA )
                  *(_DWORD *)&v13[-4 * v12 - 1073742588] = v11;
              }
              else
              {
                *(_DWORD *)&v13[-4 * v12 - 1073743660] = v11;
              }
            }
            else
            {
              *(_DWORD *)&v13[4 * ~v66 + 204] = v11;
            }
            goto LABEL_105;
          }
          v12 = 1879048226 - v12;
        }
        *(_DWORD *)&v13[4 * v12] = v11;
LABEL_105:
        v11 += 2;
        v12 = *v11;
        if ( !*v11 )
          goto LABEL_14;
      }
    }
  }
LABEL_58:
  v46 = (unsigned int *)getenv((__int16 *)"LD_LIBRARY_PATH");
  dl_init_paths(v46);
  dl_init_all_dirs = dl_all_dirs;
  v47 = (_BYTE *)getenv((__int16 *)"LD_BIND_NOW");
  v48 = 1;
  if ( v47 )
    v48 = *v47 == 0;
  dl_lazy = v48;
  v49 = (_BYTE *)getenv((__int16 *)"LD_BIND_NOT");
  v50 = 0;
  if ( v49 )
    v50 = *v49 != 0;
  dl_bind_not = v50;
  v51 = (_BYTE *)getenv((__int16 *)"LD_DYNAMIC_WEAK");
  v52 = 1;
  if ( v51 )
    v52 = *v51 == 0;
  dl_dynamic_weak = v52;
  v53 = (unsigned int *)getenv((__int16 *)"LD_PROFILE_OUTPUT");
  dl_profile_output = v53;
  if ( v53 )
  {
    v54 = _libc_enable_secure;
    if ( *(_BYTE *)v53 )
      goto LABEL_69;
  }
  else
  {
    v54 = _libc_enable_secure;
  }
  v55 = "/var/tmp";
  if ( v54 )
    v55 = "/var/profile";
  dl_profile_output = (unsigned int *)v55;
LABEL_69:
  if ( v54 )
  {
    v56 = (struct timespec *)"GCONV_PATH";
    do
    {
      unsetenv(a1, v56);
      v56 = (struct timespec *)(rawmemchr(v56, 0) + 1);
    }
    while ( v56 < &stru_80A46D8 );
  }
  if ( dl_platform && !*dl_platform )
    dl_platform = 0;
  v57 = (_BYTE *)getenv((__int16 *)"LD_ASSUME_KERNEL");
  if ( v57 )
  {
    v58 = 0;
    for ( i = 0; ; ++i )
    {
      v60 = dl_strtoul(v57, v67);
      if ( v60 > 0xFE || (_BYTE *)v67[0] == v57 )
        break;
      if ( i == 2 )
      {
        v58 |= v60;
LABEL_92:
        if ( v58 )
          dl_osversion = v58;
        break;
      }
      if ( *(_BYTE *)v67[0] && *(_BYTE *)v67[0] != 46 )
        break;
      v58 |= v60 << (-8 * i + 16);
      if ( !*(_BYTE *)v67[0] )
        goto LABEL_92;
      v57 = (_BYTE *)(v67[0] + 1);
    }
  }
  if ( dl_platform )
    dl_platformlen = strlen((unsigned int *)dl_platform);
  result = (__int16 *)&dl_phdr;
  v64 = (__int16 *)dl_phdr;
  if ( dl_phdr )
  {
    result = &dl_phnum;
    if ( *(_DWORD *)&dl_phnum )
    {
      v65 = 0;
      result = (__int16 *)(dl_phdr + 8);
      if ( *dl_phdr == 1685382481 )
      {
LABEL_114:
        result = (__int16 *)*((_DWORD *)v64 + 6);
        dl_stack_flags = (int)result;
      }
      else
      {
        while ( ++v65 != *(_DWORD *)&dl_phnum )
        {
          v64 = result;
          result += 16;
          if ( *((_DWORD *)result - 8) == 1685382481 )
            goto LABEL_114;
        }
      }
    }
  }
  return result;
}
// 8063FAB: write access to const memory at 80CDD60 has been detected
// 8063FB6: write access to const memory at 80CDD64 has been detected
// 80645C0: variable 'v43' is possibly undefined
// 80A46D8: using guessed type struct timespec stru_80A46D8;
// 80B41F9: using guessed type unsigned __int8 byte_80B41F9[1671];
// 80CDD60: using guessed type int dyn_temp_10684[];
// 80CDD64: using guessed type int dword_80CDD64;
// 80CDDAC: using guessed type int _libc_enable_secure;
// 80CE9A0: using guessed type int dl_stack_flags;
// 80CE9C0: using guessed type int dl_nns;
// 80CE9E0: using guessed type int (*dl_sysinfo)();
// 80CEBB4: using guessed type int dword_80CEBB4;
// 80CEBBC: using guessed type __int16 word_80CEBBC;
// 80CEC0C: using guessed type int dword_80CEC0C;
// 80CFEFC: using guessed type unsigned int *dl_profile_output;
// 80CFF04: using guessed type _BYTE dl_debug_mask[4];
// 80CFF18: using guessed type char *dl_platform;
// 80CFF30: using guessed type _DWORD *dl_phdr;
// 80CFF44: using guessed type int dl_sysinfo_dso;
// 80CFF48: using guessed type int dl_init_all_dirs;
// 80CFF50: using guessed type __int16 dl_phnum;
// 8063E50: using guessed type int var_20[8];

//----- (08064650) --------------------------------------------------------
void *dl_get_dl_main_map()
{
  return &dl_main_map;
}

//----- (08064670) --------------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
int _libc_init_secure()
{
  int result; // eax
  int v1; // esi
  _BOOL4 v2; // edx
  int v3; // esi

  result = _libc_enable_secure_decided;
  if ( !_libc_enable_secure_decided )
  {
    v1 = geteuid();
    result = getuid();
    v2 = 1;
    if ( v1 == result )
    {
      v3 = getegid();
      result = getgid();
      v2 = v3 != result;
    }
    _libc_enable_secure = v2;
  }
  return result;
}
// 80646B5: write access to const memory at 80CDDAC has been detected
// 80CDDAC: using guessed type int _libc_enable_secure;

//----- (080646E0) --------------------------------------------------------
_TBYTE *__cdecl dl_mcount_wrapper(int a1)
{
  int retaddr; // [esp+4h] [ebp+0h]

  return dl_mcount(retaddr, a1);
}

//----- (08064710) --------------------------------------------------------
_TBYTE *__cdecl dl_mcount_wrapper_check(int a1)
{
  _TBYTE *result; // eax
  int retaddr; // [esp+4h] [ebp+0h]

  result = (_TBYTE *)dl_profile_map;
  if ( dl_profile_map )
    return dl_mcount(retaddr, a1);
  return result;
}

//----- (08064750) --------------------------------------------------------
unsigned int __cdecl dl_tunable_set_hwcaps(char **a1)
{
  char *v1; // esi
  char v2; // dl
  unsigned int result; // eax
  char *v4; // eax
  int v5; // eax
  int v6; // edi

  v1 = *a1;
  v2 = **a1;
  result = dl_x86_cpu_features[17];
  do
  {
    while ( v2 == 44 || !v2 )
    {
      v2 = *++v1;
      if ( !*v1 )
        return result;
    }
    v4 = v1;
    do
      ++v4;
    while ( *v4 && *v4 != 44 );
    v5 = v4 - v1;
    v6 = v5 + 1;
    if ( v2 == 45 )
    {
      result = v5 - 4;
      if ( result <= 0x17 )
        __asm { jmp     ecx }
    }
    else
    {
      result = v5 - 4;
      if ( result <= 0x16 )
        __asm { jmp     ecx }
    }
    v1 += v6;
    v2 = *v1;
  }
  while ( *v1 );
  return result;
}
// 80CF8E0: using guessed type _DWORD dl_x86_cpu_features[22];

//----- (08065450) --------------------------------------------------------
_WORD *__cdecl dl_tunable_set_x86_ibt(_WORD **a1)
{
  _WORD *result; // eax

  result = *a1;
  if ( **a1 != 28271 || *((_BYTE *)result + 2) )
  {
    if ( *(_DWORD *)result == 6710895 )
    {
      result = (_WORD *)(dl_x86_feature_1[1] & 0xFFFFFFF8 | 1);
      dl_x86_feature_1[1] = result;
    }
    else if ( *(_DWORD *)result == 1836213616
           && *((_DWORD *)result + 1) == 1769173865
           && result[4] == 25974
           && !*((_BYTE *)result + 10) )
    {
      result = (_WORD *)(dl_x86_feature_1[1] & 0xFFFFFFF8 | 3);
      dl_x86_feature_1[1] = result;
    }
  }
  else
  {
    result = (_WORD *)(dl_x86_feature_1[1] & 0xFFFFFFF8 | 2);
    dl_x86_feature_1[1] = result;
  }
  return result;
}
// 80CFF1C: using guessed type _DWORD dl_x86_feature_1[2];

//----- (080654F0) --------------------------------------------------------
_WORD *__cdecl dl_tunable_set_x86_shstk(_WORD **a1)
{
  _WORD *result; // eax

  result = *a1;
  if ( **a1 != 28271 || *((_BYTE *)result + 2) )
  {
    if ( *(_DWORD *)result == 6710895 )
    {
      result = (_WORD *)(dl_x86_feature_1[1] & 0xFFFFFFC7 | 8);
      dl_x86_feature_1[1] = result;
    }
    else if ( *(_DWORD *)result == 1836213616
           && *((_DWORD *)result + 1) == 1769173865
           && result[4] == 25974
           && !*((_BYTE *)result + 10) )
    {
      result = (_WORD *)(dl_x86_feature_1[1] & 0xFFFFFFC7 | 0x18);
      dl_x86_feature_1[1] = result;
    }
  }
  else
  {
    result = (_WORD *)(dl_x86_feature_1[1] & 0xFFFFFFC7 | 0x10);
    dl_x86_feature_1[1] = result;
  }
  return result;
}
// 80CFF1C: using guessed type _DWORD dl_x86_feature_1[2];

//----- (08065590) --------------------------------------------------------
int dl_discover_osversion()
{
  char *release; // ebx
  int v1; // edi
  int result; // eax
  int v3; // ecx
  int v4; // edx
  char *v5; // esi
  int i; // ecx
  int v7; // eax
  int v8; // edi
  signed int nocancel; // esi
  char v10[64]; // [esp+1Ah] [ebp-1D2h] BYREF
  struct utsname v11; // [esp+5Ah] [ebp-192h] BYREF

  release = v11.release;
  if ( uname(&v11) )
  {
    v7 = _open64_nocancel((int)"/proc/sys/kernel/osrelease", 0);
    v8 = v7;
    if ( v7 < 0 )
      return -1;
    release = v10;
    nocancel = _read_nocancel(v7, v10, 0x40u);
    _close_nocancel(v8);
    if ( nocancel <= 0 )
      return -1;
    if ( nocancel >= 63 )
      nocancel = 63;
    v10[nocancel] = 0;
  }
  v1 = 0;
  result = 0;
  while ( 1 )
  {
    v3 = *release;
    if ( (unsigned __int8)(v3 - 48) > 9u )
      break;
    v4 = release[1];
    v5 = release + 1;
    for ( i = v3 - 48; (unsigned __int8)(v4 - 48) <= 9u; v4 = *v5 )
    {
      ++v5;
      i = v4 + 10 * i - 48;
    }
    ++v1;
    release = v5 + 1;
    result = i | (result << 8);
    if ( (_BYTE)v4 != 46 )
    {
      if ( v1 == 3 )
        return result;
      break;
    }
    if ( v1 == 3 )
      return result;
  }
  result <<= 8 * (3 - v1);
  return result;
}
// 8065590: using guessed type char var_1D2[64];

//----- (080656A0) --------------------------------------------------------
unsigned int __cdecl _libc_init_first(int a1, char (**a2)[1671], _DWORD *a3)
{
  if ( !&dl_starting_up || dl_starting_up )
  {
    _libc_multiple_libcs = 0;
    if ( _fpu_control[0] != dl_fpu_control )
      _setfpucw(_fpu_control[0]);
  }
  else
  {
    _libc_multiple_libcs = 1;
  }
  _libc_argc = a1;
  _libc_argv = (int)a2;
  environ = a3;
  dl_non_dynamic_init((int)a3);
  _init_misc(a1, a2);
  return _ctype_init();
}
// 80CE9A4: using guessed type __int16 dl_fpu_control;
// 80CE9B4: using guessed type _DWORD dl_starting_up;
// 80CECD4: using guessed type int _libc_multiple_libcs;
// 80CEED4: using guessed type __int16 _fpu_control[2];
// 80CF89C: using guessed type _DWORD *environ;
// 80CFF74: using guessed type int _libc_argc;
// 80CFF78: using guessed type int _libc_argv;

//----- (08065740) --------------------------------------------------------
int __usercall _syscall_error@<eax>(int a1@<eax>)
{
  __writegsdword(0xFFFFFFE0, -a1);
  return -1;
}

//----- (08065760) --------------------------------------------------------
int __cdecl _gconv_open(char *a1, int *a2, char **a3, char a4)
{
  _DWORD *v4; // eax
  _DWORD *v5; // eax
  _DWORD *v6; // eax
  _DWORD *v7; // eax
  char *v8; // edx
  _BYTE *transform; // eax
  unsigned int v11; // esi
  int *v12; // eax
  int *v13; // ecx
  int *v14; // edi
  int *v15; // esi
  int *v16; // edi
  int *v17; // eax
  int *v18; // ecx
  bool v19; // zf
  int v20; // eax
  unsigned int v21; // edx
  unsigned int *v22; // esi
  int v23; // eax
  _BYTE *v24; // edi
  int v25; // ecx
  unsigned int *v26; // edi
  int v27; // eax
  _BYTE *v28; // ecx
  int v29; // esi
  char *v30; // eax
  unsigned int *v31; // esi
  unsigned int v32; // edx
  _BYTE *v33; // edi
  int v34; // ecx
  int v35; // eax
  _BYTE *v36; // edi
  int v37; // ecx
  void *v38; // esp
  _BYTE *v39; // eax
  int v40; // eax
  char *v41; // edi
  int v42; // eax
  unsigned int v43; // eax
  _BYTE *v44; // esi
  int v45; // ecx
  void *v46; // esp
  char *v47; // esi
  char *v48; // eax
  void *v49; // esp
  void *v50; // esp
  void *v51; // esp
  _BYTE v52[4]; // [esp-200Ch] [ebp-205Ch]
  _BYTE v53[4096]; // [esp-2008h] [ebp-2058h] BYREF
  _BYTE v54[4096]; // [esp-1008h] [ebp-1058h] BYREF
  _BYTE v55[8]; // [esp-8h] [ebp-58h] BYREF
  unsigned __int8 *v56; // [esp+0h] [ebp-50h]
  unsigned __int8 *v57; // [esp+4h] [ebp-4Ch]
  char **v58; // [esp+8h] [ebp-48h]
  int v59; // [esp+Ch] [ebp-44h]
  char *v60; // [esp+10h] [ebp-40h]
  char *v61; // [esp+14h] [ebp-3Ch]
  struct timespec *v62; // [esp+18h] [ebp-38h]
  char *v63; // [esp+1Ch] [ebp-34h]
  unsigned int v64; // [esp+20h] [ebp-30h]
  int v65; // [esp+24h] [ebp-2Ch]
  int **v66; // [esp+2Ch] [ebp-24h] BYREF
  int v67[8]; // [esp+30h] [ebp-20h] BYREF
  int savedregs; // [esp+50h] [ebp+0h] BYREF

  v63 = (char *)a2;
  v61 = a1;
  v58 = a3;
  v67[1] = __readgsdword(0x14u);
  v4 = strchr(a1, 47);
  if ( v4 && (v5 = strchr((_BYTE *)v4 + 1, 47)) != 0 && *((_BYTE *)v5 + 1) )
  {
    v31 = (_DWORD *)((char *)v5 + 1);
    v32 = (char *)v5 + 1 - v61;
    v33 = &v55[-((v32 + 28) & 0xFFFFF000)];
    if ( v55 != v33 )
    {
      while ( v54 != v33 )
        ;
    }
    v34 = ((_WORD)v32 + 28) & 0xFF0;
    if ( (((_WORD)v32 + 28) & 0xFF0) != 0 )
    {
      v51 = alloca(v34);
      *(_DWORD *)&v53[v34 + 4092] = *(_DWORD *)&v53[v34 + 4092];
    }
    v67[0] = 0;
    v54[v32] = 0;
    v61 = memcpy(v54, v61, v32);
    v35 = strlen(v31);
    v36 = &v54[-((v35 + 28) & 0xFFFFF000)];
    if ( v54 != v36 )
    {
      while ( v53 != v36 )
        ;
    }
    v37 = ((_WORD)v35 + 28) & 0xFF0;
    if ( (((_WORD)v35 + 28) & 0xFF0) != 0 )
    {
      v38 = alloca(v37);
      *(_DWORD *)&v52[v37] = *(_DWORD *)&v52[v37];
    }
    v39 = memcpy(v53, v31, v35 + 1);
    v62 = (struct timespec *)v67;
    v59 = (int)byte_80A4C94;
    v40 = strtok_r((int)v39, byte_80A4C94, v67);
    LOBYTE(v64) = 0;
    v41 = (char *)v40;
    v65 = 0;
    if ( v40 )
    {
      v60 = "TRANSLIT";
      v57 = "IGNORE";
      do
      {
        if ( strcasecmp_l(v41, (unsigned __int8 *)v60, (int)nl_C_locobj) )
        {
          v19 = strcasecmp_l(v41, v57, (int)nl_C_locobj) == 0;
          v42 = 2;
          if ( !v19 )
            v42 = v65;
          v65 = v42;
        }
        else
        {
          LOBYTE(v64) = 1;
        }
        v41 = (char *)strtok_r(0, (_BYTE *)v59, &v62->tv_sec);
      }
      while ( v41 );
    }
  }
  else
  {
    LOBYTE(v64) = 0;
    v65 = 0;
    v62 = (struct timespec *)v67;
  }
  v6 = strchr(v63, 47);
  if ( v6 )
  {
    v7 = strchr((_BYTE *)v6 + 1, 47);
    if ( v7 )
    {
      if ( *((_BYTE *)v7 + 1) )
      {
        v43 = (char *)v7 + 1 - v63;
        v44 = &v55[-((v43 + 28) & 0xFFFFF000)];
        if ( v55 != v44 )
        {
          while ( v54 != v44 )
            ;
        }
        v45 = ((_WORD)v43 + 28) & 0xFF0;
        if ( (((_WORD)v43 + 28) & 0xFF0) != 0 )
        {
          v46 = alloca(v45);
          *(_DWORD *)&v53[v45 + 4092] = *(_DWORD *)&v53[v45 + 4092];
        }
        v54[v43] = 0;
        v63 = memcpy(v54, v63, v43);
      }
    }
  }
  v8 = "//";
  if ( !strcmp(v61, "//") )
  {
    v61 = "//";
    v26 = *(unsigned int **)(*(_DWORD *)__readgsdword(0xFFFFFFD0) + 92);
    v27 = strlen(v26);
    v28 = &v55[-((v27 + 30) & 0xFFFFF000)];
    if ( v55 != v28 )
    {
      while ( v54 != v28 )
        ;
    }
    v29 = ((_WORD)v27 + 30) & 0xFF0;
    if ( (((_WORD)v27 + 30) & 0xFF0) != 0 )
    {
      v50 = alloca(v29);
      *(_DWORD *)&v53[v29 + 4092] = *(_DWORD *)&v53[v29 + 4092];
    }
    v60 = "//";
    v61 = v54;
    v30 = (char *)mempcpy(v54, v26, v27);
    v8 = v60;
    strcpy(v30, "//");
  }
  if ( !memcmp(v63, v8, 3u) )
  {
    v22 = *(unsigned int **)(*(_DWORD *)__readgsdword(0xFFFFFFD0) + 92);
    v23 = strlen(v22);
    v24 = &v55[-((v23 + 30) & 0xFFFFF000)];
    if ( v55 != v24 )
    {
      while ( v54 != v24 )
        ;
    }
    v25 = ((_WORD)v23 + 30) & 0xFF0;
    if ( (((_WORD)v23 + 30) & 0xFF0) != 0 )
    {
      v49 = alloca(v25);
      *(_DWORD *)&v53[v25 + 4092] = *(_DWORD *)&v53[v25 + 4092];
    }
    v63 = v54;
    strcpy((char *)mempcpy(v54, v22, v23), "//");
  }
  transform = (_BYTE *)_gconv_find_transform((unsigned __int8 *)v61, (int *)v63, &v66, &v62->tv_sec, a4);
  v61 = 0;
  v59 = (int)transform;
  if ( !transform )
  {
    v63 = (char *)v67[0];
    v11 = 32 * v67[0];
    v12 = malloc((const struct timespec *)(32 * v67[0] + 8));
    v13 = (int *)v63;
    v14 = v12;
    v61 = (char *)v12;
    v60 = (char *)v66;
    if ( v12 )
    {
      v12[1] = (int)v66;
      *v12 = (int)v13;
      memset((unsigned __int8 *)v12 + 8, 0, v11);
      if ( !v63 )
        goto LABEL_11;
      v15 = v14 + 8;
      v16 = 0;
      v57 = (unsigned __int8 *)nl_C_locobj;
      v56 = "INTERNAL";
      while ( 1 )
      {
        v19 = (_BYTE)v64 == 0;
        *(v15 - 1) = (int)v15;
        if ( !v19 )
        {
          v20 = strcasecmp_l((char *)v66[15 * (_DWORD)v16 + 3], v56, (int)v57);
          v21 = v65 | 8;
          if ( v20 )
            v21 = v65;
          v65 = v21;
        }
        v63 = (char *)v67[0];
        if ( v67[0] - 1 <= (unsigned int)v16 )
        {
          *(_DWORD *)&v61[32 * (_DWORD)v16 + 16] = v65 | 1;
          goto LABEL_11;
        }
        *(v15 - 4) = v65;
        v60 = (char *)v66;
        v62 = (struct timespec *)(8160 * (_DWORD)v66[15 * (_DWORD)v16 + 12]);
        v17 = malloc(v62);
        v18 = (int *)v63;
        *(v15 - 6) = (int)v17;
        if ( !v17 )
          break;
        v16 = (int *)((char *)v16 + 1);
        v15 += 8;
        *(v15 - 13) = (int)v17 + (_DWORD)v62;
        if ( v18 <= v16 )
          goto LABEL_11;
      }
      v47 = (char *)v16 - 1;
      v64 = -32;
      v65 = __readgsdword(0xFFFFFFE0);
      if ( v16 )
      {
        v16 = (int *)v61;
        do
        {
          v48 = v47--;
          free((int)&savedregs, v16, v16[8 * (_DWORD)v48 + 2]);
        }
        while ( v47 != (char *)-1 );
        v18 = (int *)v67[0];
        v60 = (char *)v66;
      }
      v63 = (char *)v18;
      free((int)&savedregs, v16, (int)v61);
      v13 = (int *)v63;
    }
    else
    {
      v64 = -32;
      v65 = __readgsdword(0xFFFFFFE0);
    }
    _gconv_close_transform((const struct timespec *)v60, (int)v13);
    __writegsdword(v64, v65);
    v59 = 3;
    v61 = 0;
  }
LABEL_11:
  *v58 = v61;
  return v59;
}
// 80A4C94: using guessed type _BYTE byte_80A4C94[2];
// 80CDF40: using guessed type char **nl_C_locobj[6];

//----- (08065D60) --------------------------------------------------------
int __cdecl _gconv(int *a1, int *a2, unsigned int a3, int *a4, int a5, _DWORD *a6)
{
  int v6; // eax
  int v7; // edx
  int *v8; // esi
  _DWORD *v9; // eax
  int (__cdecl *v10)(int, int *, int *, unsigned int, _DWORD, _DWORD *, int, _DWORD); // esi
  int v11; // edi
  int result; // eax
  unsigned int v13; // edx
  unsigned int v14; // ecx
  unsigned int v15; // [esp+0h] [ebp-24h]
  int *v16; // [esp+4h] [ebp-20h]

  if ( a1 == (int *)-1 )
    return 8;
  v6 = *a1;
  v15 = *a1 - 1;
  if ( !a6 )
    _assert_fail((int)"irreversible != NULL", (int)"gconv.c", 43, (int)"__gconv");
  *a6 = 0;
  v7 = 0;
  if ( a4 )
    v7 = *a4;
  v8 = &a1[8 * v6];
  *(v8 - 6) = v7;
  *(v8 - 5) = a5;
  v9 = (_DWORD *)a1[1];
  v16 = v8;
  v10 = (int (__cdecl *)(int, int *, int *, unsigned int, _DWORD, _DWORD *, int, _DWORD))v9[5];
  if ( *v9 )
    v10 = (int (__cdecl *)(int, int *, int *, unsigned int, _DWORD, _DWORD *, int, _DWORD))(__readgsdword(0x18u) ^ __ROR4__(v10, 9));
  if ( a2 )
  {
    v11 = *a2;
    if ( *a2 )
    {
      if ( !a4 || !*a4 )
        _assert_fail((int)"outbuf != NULL && *outbuf != NULL", (int)"gconv.c", 73, (int)"__gconv");
      while ( 1 )
      {
        dl_mcount_wrapper_check((int)v10);
        result = v10(a1[1], a1 + 2, a2, a3, 0, a6, 0, 0);
        if ( result != 4 || *a2 == v11 || a3 < *a2 + *(_DWORD *)(a1[1] + 36) )
          break;
        v11 = *a2;
      }
LABEL_16:
      if ( *a4 )
        *a4 = *(v16 - 6);
      return result;
    }
  }
  dl_mcount_wrapper_check((int)v10);
  result = v10(a1[1], a1 + 2, 0, 0, 0, a6, (*(v16 - 6) == 0) + 1, 0);
  if ( !result )
  {
    v13 = 0;
    do
    {
      v14 = v13++;
      a1[8 * v14 + 5] = 0;
    }
    while ( v15 >= v13 );
  }
  if ( a4 )
    goto LABEL_16;
  return result;
}

//----- (08065F40) --------------------------------------------------------
int __cdecl _gconv_close(int *a1)
{
  int v1; // ebp
  int *v2; // edi
  int v3; // edx
  const struct timespec *v5; // [esp+0h] [ebp-20h]

  v1 = *a1;
  v2 = a1 + 2;
  v5 = (const struct timespec *)a1[1];
  while ( (v2[2] & 1) == 0 )
  {
    v3 = *v2;
    v2 += 8;
    if ( v3 )
    {
      free(v1, v2, v3);
      if ( (*(_BYTE *)(v2 - 6) & 1) != 0 )
        break;
    }
  }
  free(v1, v2, (int)a1);
  return _gconv_close_transform(v5, v1);
}

//----- (08065FB0) --------------------------------------------------------
int __cdecl _gconv_alias_compare(char **a1, _BYTE **a2)
{
  return strcmp(*a1, *a2);
}

//----- (08065FD0) --------------------------------------------------------
int __cdecl derivation_compare(char **a1, _BYTE **a2)
{
  int result; // eax

  result = strcmp(*a1, *a2);
  if ( !result )
    return strcmp(a1[1], a2[1]);
  return result;
}

//----- (08066020) --------------------------------------------------------
int _gconv_get_modules_db()
{
  return _gconv_modules_db;
}
// 80CFF7C: using guessed type int _gconv_modules_db;

//----- (08066040) --------------------------------------------------------
int _gconv_get_alias_db()
{
  return _gconv_alias_db;
}
// 80CFF84: using guessed type int _gconv_alias_db;

//----- (08066060) --------------------------------------------------------
_TBYTE *__cdecl _gconv_release_step(int *a1)
{
  _TBYTE *result; // eax
  int v2; // edx
  void (__cdecl *v4)(int *); // esi

  result = &GLOBAL_OFFSET_TABLE_;
  v2 = *a1;
  if ( *a1 )
  {
    if ( a1[2]-- == 1 )
    {
      v4 = (void (__cdecl *)(int *))(__readgsdword(0x18u) ^ __ROR4__(a1[8], 9));
      if ( v4 )
      {
        dl_mcount_wrapper_check((int)v4);
        v4(a1);
        v2 = *a1;
      }
      result = (_TBYTE *)_gconv_release_shlib(v2);
      *a1 = 0;
    }
  }
  else if ( a1[8] )
  {
    _assert_fail((int)"step->__end_fct == NULL", (int)"gconv_db.c", 226, (int)"__gconv_release_step");
  }
  return result;
}
// 80CE000: using guessed type _TBYTE GLOBAL_OFFSET_TABLE_;

//----- (080660F0) --------------------------------------------------------
int __usercall find_derivation@<eax>(
        _BYTE *a1@<eax>,
        _BYTE *a2@<edx>,
        unsigned int *a3@<ecx>,
        unsigned int *a4,
        unsigned int ***a5,
        unsigned int *a6)
{
  int *v7; // eax
  int v8; // eax
  unsigned int **v9; // ecx
  unsigned int **v10; // edi
  _DWORD *v11; // esi
  int v12; // ebx
  int v13; // eax
  int *shlib; // eax
  int v15; // edx
  int v16; // eax
  int v17; // edx
  int v18; // eax
  int v19; // eax
  int v20; // eax
  _DWORD *v21; // eax
  int v22; // esi
  char *v23; // ebx
  int v24; // eax
  int i; // eax
  unsigned int *v26; // ebx
  int v27; // edi
  int v28; // esi
  int v29; // eax
  int v30; // esi
  int v31; // eax
  unsigned int **v32; // esi
  unsigned int *v33; // eax
  unsigned int *v34; // edx
  unsigned int *v35; // ebx
  unsigned int *v36; // ecx
  unsigned int j; // eax
  int *v38; // eax
  int v39; // esi
  int v40; // ebx
  int v41; // edi
  int v42; // ecx
  int v43; // edx
  int v44; // ecx
  int v45; // eax
  int v46; // eax
  int v47; // eax
  int v48; // eax
  int v49; // edi
  int v50; // eax
  int k; // edi
  unsigned int v52; // esi
  int *v53; // eax
  int v54; // ecx
  int v55; // esi
  int v56; // edx
  int **v57; // ebx
  int v58; // eax
  int v59; // eax
  unsigned int *v60; // eax
  int *v61; // eax
  int v62; // ecx
  int v63; // edi
  int v64; // edi
  int v65; // eax
  int v66; // edi
  int v67; // eax
  int v68; // ecx
  int *v69; // eax
  unsigned int v70; // edi
  int *v71; // eax
  unsigned int *v72; // esi
  int *v73; // ebx
  int *v74; // edi
  int v75; // edi
  int *v76; // eax
  int *v77; // ecx
  _BYTE *v78; // eax
  int *v79; // edi
  _WORD *v80; // eax
  _BYTE *v81; // eax
  int v82; // ecx
  int v83; // eax
  int *v85; // edi
  _DWORD *v86; // edx
  int *v87; // ebx
  int *v88; // edi
  unsigned int *v89; // [esp-3098h] [ebp-3118h] BYREF
  int v90; // [esp-3094h] [ebp-3114h]
  int v91; // [esp-3090h] [ebp-3110h]
  int v92; // [esp-308Ch] [ebp-310Ch]
  int v93; // [esp-3088h] [ebp-3108h]
  _DWORD *v94; // [esp-3084h] [ebp-3104h]
  int v95; // [esp-3080h] [ebp-3100h] BYREF
  unsigned int *v96; // [esp-2078h] [ebp-20F8h]
  int **v97; // [esp-2074h] [ebp-20F4h]
  int v98; // [esp-2070h] [ebp-20F0h]
  _DWORD v99[6]; // [esp-2068h] [ebp-20E8h] BYREF
  int v100; // [esp-2050h] [ebp-20D0h] BYREF
  unsigned int *v101; // [esp-1038h] [ebp-10B8h] BYREF
  int v102; // [esp-1034h] [ebp-10B4h]
  int v103; // [esp-1030h] [ebp-10B0h]
  int v104; // [esp-102Ch] [ebp-10ACh]
  int v105; // [esp-1028h] [ebp-10A8h]
  int v106; // [esp-1024h] [ebp-10A4h]
  _DWORD *v107; // [esp-1020h] [ebp-10A0h] BYREF
  int *v108; // [esp-18h] [ebp-98h]
  int *v109; // [esp+0h] [ebp-80h]
  int *v110; // [esp+4h] [ebp-7Ch]
  int *v111; // [esp+8h] [ebp-78h]
  unsigned int ***v112; // [esp+Ch] [ebp-74h]
  unsigned int *v113; // [esp+10h] [ebp-70h]
  unsigned int **v114; // [esp+14h] [ebp-6Ch]
  int *v115; // [esp+18h] [ebp-68h]
  _BYTE *v116; // [esp+1Ch] [ebp-64h]
  unsigned int *v117; // [esp+20h] [ebp-60h]
  int *v118; // [esp+24h] [ebp-5Ch]
  char *v119; // [esp+28h] [ebp-58h]
  _BYTE *v120; // [esp+2Ch] [ebp-54h]
  int *v121; // [esp+30h] [ebp-50h]
  unsigned int *v122; // [esp+34h] [ebp-4Ch]
  int v123; // [esp+38h] [ebp-48h]
  int *v124; // [esp+3Ch] [ebp-44h]
  _DWORD *v125; // [esp+40h] [ebp-40h]
  int v126; // [esp+44h] [ebp-3Ch]
  unsigned int *v127; // [esp+54h] [ebp-2Ch] BYREF
  unsigned int *v128; // [esp+58h] [ebp-28h]
  int v129; // [esp+5Ch] [ebp-24h]
  int v130; // [esp+60h] [ebp-20h]
  unsigned int v131; // [esp+64h] [ebp-1Ch]
  int savedregs; // [esp+80h] [ebp+0h] BYREF

  v120 = a1;
  v116 = a2;
  v115 = (int *)&GLOBAL_OFFSET_TABLE_;
  v112 = a5;
  v113 = a4;
  v117 = a6;
  v131 = __readgsdword(0x14u);
  if ( a2 )
    a1 = a2;
  v122 = (unsigned int *)a1;
  if ( a4 )
  {
    v129 = 0;
    v130 = 0;
    v127 = v113;
    v128 = v122;
    v110 = v115 + 1616;
    v111 = v115 - 106508;
    v7 = tfind((int)&v127, v115 + 1616, (int (__cdecl *)(int, _DWORD))(v115 - 106508));
    if ( v7 )
      goto LABEL_5;
    v101 = v113;
    v114 = &v101;
    v18 = strlen(v113);
    v104 = 0;
    v102 = v18;
    v103 = 0;
    v105 = 0;
    v106 = 0;
    v107 = 0;
    v99[0] = a3;
    v19 = strlen(a3);
    v107 = v99;
    v99[1] = v19;
    memset(&v99[2], 0, 16);
    v100 = 0;
    v109 = &v100;
  }
  else
  {
    v127 = a3;
    v129 = 0;
    v128 = v122;
    v130 = 0;
    v110 = v115 + 1616;
    v111 = v115 - 106508;
    v7 = tfind((int)&v127, v115 + 1616, (int (__cdecl *)(int, _DWORD))(v115 - 106508));
    if ( v7 )
    {
LABEL_5:
      v8 = *v7;
      v9 = *(unsigned int ***)(v8 + 8);
      *v112 = v9;
      v10 = v9;
      v125 = *(_DWORD **)(v8 + 12);
      v11 = v125;
      *v117 = (unsigned int)v125;
      v126 = 60 * (_DWORD)v11;
      v12 = (int)&v9[15 * (_DWORD)v11 - 15];
      if ( !v11 )
        return 0;
      while ( 1 )
      {
        v13 = *(_DWORD *)(v12 + 8);
        *(_DWORD *)(v12 + 8) = v13 + 1;
        if ( !v13 && *(_DWORD *)(v12 + 4) )
        {
          shlib = _gconv_find_shlib(*(unsigned int **)(v12 + 4));
          *(_DWORD *)v12 = shlib;
          if ( !shlib )
          {
            v86 = v125;
            --*(_DWORD *)(v12 + 8);
            if ( v86 > v11 )
            {
              v87 = (int *)&v10[15 * (_DWORD)v11];
              do
              {
                v108 = v87;
                v87 += 15;
                _gconv_release_step(v108);
              }
              while ( (int *)((char *)v10 + v126) != v87 );
            }
            return 1;
          }
          *(_DWORD *)(v12 + 20) = shlib[3];
          v15 = shlib[4];
          v16 = shlib[5];
          *(_DWORD *)(v12 + 24) = 0;
          *(_DWORD *)(v12 + 28) = v15;
          *(_DWORD *)(v12 + 32) = v16;
          v17 = __readgsdword(0x18u) ^ __ROR4__(v15, 9);
          if ( v17 )
          {
            v124 = (int *)v17;
            dl_mcount_wrapper_check(v17);
            ((void (__cdecl *)(int))v124)(v12);
            v17 = *(_DWORD *)(v12 + 24);
          }
          *(_DWORD *)(v12 + 24) = __ROL4__(__readgsdword(0x18u) ^ v17, 9);
        }
        v11 = (_DWORD *)((char *)v11 - 1);
        v12 -= 60;
        if ( !v11 )
          return 0;
      }
    }
    v101 = a3;
    v114 = &v101;
    v20 = strlen(a3);
    v104 = 0;
    v102 = v20;
    v103 = 0;
    v105 = 0;
    v106 = 0;
    v107 = 0;
    v109 = (int *)&v107;
    v113 = a3;
  }
  v124 = 0;
  v121 = (int *)0x7FFFFFFF;
  v125 = v114;
  v123 = 0x7FFFFFFF;
  v118 = 0;
  v119 = (char *)v115 - 168693;
  while ( 1 )
  {
    if ( (int)v124 <= v123 && (v124 != (int *)v123 || v125[2] < (int)v121) )
    {
      v22 = v115[2015];
      if ( v22 )
      {
        v23 = (char *)*v125;
        while ( 1 )
        {
          v24 = strcmp(v23, *(_BYTE **)v22);
          if ( !v24 )
            break;
          if ( v24 >= 0 )
            v22 = *(_DWORD *)(v22 + 28);
          else
            v22 = *(_DWORD *)(v22 + 20);
          if ( !v22 )
            goto LABEL_19;
        }
        v126 = v22;
        for ( i = (int)v124; ; i = v125[3] )
        {
          v26 = *(unsigned int **)(v126 + 4);
          if ( !memcmp(v26, v119, 2u) )
            v26 = v122;
          v27 = *(_DWORD *)(v126 + 8) + i;
          v124 = (int *)(*(_DWORD *)(v126 + 12) + v125[2]);
          if ( !strcmp((char *)v26, v120) || v116 && !strcmp((char *)v26, v116) )
          {
            if ( v118 )
            {
              v28 = (int)v118;
              while ( strcmp((char *)v26, *(_BYTE **)v28) )
              {
                v28 = *(_DWORD *)(v28 + 24);
                if ( !v28 )
                  goto LABEL_77;
              }
              if ( *(_DWORD *)(v28 + 12) > v27 || *(_DWORD *)(v28 + 12) == v27 && *(_DWORD *)(v28 + 8) > (int)v124 )
              {
                v45 = v126;
                *(_DWORD *)(v28 + 12) = v27;
                *(_DWORD *)(v28 + 16) = v45;
                *(_DWORD *)(v28 + 20) = v125;
                *(_DWORD *)(v28 + 8) = v124;
              }
            }
            else
            {
LABEL_77:
              v89 = v26;
              v46 = strlen(v26);
              v92 = v27;
              v90 = v46;
              v91 = (int)v124;
              v93 = v126;
              v94 = v125;
              v47 = (int)v118;
              v118 = (int *)&v89;
              v95 = v47;
            }
            if ( v123 > v27 )
            {
              v123 = v27;
              v121 = v124;
            }
            else if ( v123 == v27 )
            {
              v29 = (int)v124;
              if ( (int)v121 <= (int)v124 )
                v29 = (int)v121;
              v121 = (int *)v29;
            }
          }
          else if ( v123 > v27 || v123 == v27 && (int)v121 > (int)v124 )
          {
            v30 = (int)v114;
            while ( strcmp((char *)v26, *(_BYTE **)v30) )
            {
              v30 = *(_DWORD *)(v30 + 24);
              if ( !v30 )
              {
                v89 = v26;
                v31 = strlen(v26);
                v92 = v27;
                v90 = v31;
                v95 = 0;
                v91 = (int)v124;
                v93 = v126;
                v94 = v125;
                *v109 = (int)&v89;
                v109 = &v95;
                goto LABEL_36;
              }
            }
            if ( *(_DWORD *)(v30 + 12) > v27 || *(_DWORD *)(v30 + 12) == v27 && *(_DWORD *)(v30 + 8) > (int)v124 )
            {
              *(_DWORD *)(v30 + 16) = v126;
              *(_DWORD *)(v30 + 20) = v125;
              v32 = v114;
              do
              {
                while ( 1 )
                {
                  v33 = v32[4];
                  if ( v33 )
                    break;
                  v32 = (unsigned int **)v32[6];
                  if ( !v32 )
                    goto LABEL_66;
                }
                v34 = v32[5];
                v35 = (unsigned int *)v33[2];
                v36 = (unsigned int *)v33[3];
                for ( j = v34[4]; j; j = v34[4] )
                {
                  v34 = (unsigned int *)v34[5];
                  v35 = (unsigned int *)((char *)v35 + *(_DWORD *)(j + 8));
                  v36 = (unsigned int *)((char *)v36 + *(_DWORD *)(j + 12));
                }
                v32[3] = v35;
                v32[2] = v36;
                v32 = (unsigned int **)v32[6];
              }
              while ( v32 );
LABEL_66:
              v38 = v118;
              if ( v118 )
              {
                v39 = v123;
                v40 = (int)v121;
                do
                {
                  while ( 1 )
                  {
                    v41 = v38[4];
                    v42 = v38[5];
                    v43 = *(_DWORD *)(v41 + 8) + *(_DWORD *)(v42 + 12);
                    v44 = *(_DWORD *)(v41 + 12) + *(_DWORD *)(v42 + 8);
                    v38[3] = v43;
                    v38[2] = v44;
                    if ( v43 >= v39 )
                      break;
                    v38 = (int *)v38[6];
                    v40 = v44;
                    v39 = v43;
                    if ( !v38 )
                      goto LABEL_74;
                  }
                  if ( v43 == v39 && v44 < v40 )
                    v40 = v44;
                  v38 = (int *)v38[6];
                }
                while ( v38 );
LABEL_74:
                v123 = v39;
                v121 = (int *)v40;
              }
            }
          }
LABEL_36:
          v126 = *(_DWORD *)(v126 + 24);
          if ( !v126 )
            break;
        }
      }
    }
LABEL_19:
    v21 = (_DWORD *)v125[6];
    v125 = v21;
    if ( !v21 )
      break;
    v124 = (int *)v21[3];
  }
  if ( !v118 )
  {
    v126 = 1;
    v52 = 0;
    *v112 = 0;
    *v117 = 0;
    goto LABEL_116;
  }
  v48 = v118[6];
  if ( v48 )
  {
    v49 = v118[3];
    if ( *(_DWORD *)(v48 + 12) < v49 )
    {
      v118 = (int *)v118[6];
    }
    else if ( *(_DWORD *)(v48 + 12) == v49 )
    {
      if ( *(_DWORD *)(v48 + 8) >= v118[2] )
        v48 = (int)v118;
      v118 = (int *)v48;
    }
  }
  v50 = v118[5];
  if ( !v50 )
  {
    v118 = malloc(0);
    if ( v118 )
    {
      v52 = 0;
      *v117 = 0;
LABEL_105:
      v126 = 0;
      *v112 = (unsigned int **)v118;
      goto LABEL_116;
    }
LABEL_124:
    v118 = 0;
    v52 = 0;
    v126 = 3;
    *v117 = 0;
    *v112 = 0;
    goto LABEL_116;
  }
  for ( k = 0; ; ++k )
  {
    v50 = *(_DWORD *)(v50 + 20);
    v52 = k + 1;
    if ( !v50 )
      break;
  }
  v53 = malloc((const struct timespec *)(60 * v52));
  v125 = v53;
  if ( !v53 )
    goto LABEL_124;
  *v117 = v52;
  if ( k == -1 )
  {
    v118 = v125;
    goto LABEL_105;
  }
  v54 = k + 1;
  v121 = 0;
  v55 = (int)v118;
  v123 = 0;
  v56 = k;
  v57 = (int **)&v53[15 * k];
  while ( 1 )
  {
    if ( v56 )
    {
      v57[3] = **(int ***)(v55 + 20);
    }
    else
    {
      v124 = 0;
      v126 = v54;
      v69 = strdup(v113);
      v54 = v126;
      v123 = (int)v69;
      v56 = (int)v124;
      v125[3] = v69;
      if ( !v69 )
      {
        v70 = 1;
        goto LABEL_110;
      }
    }
    if ( *v117 != v54 )
    {
      v57[4] = (int *)v125[15 * v54 + 3];
      goto LABEL_98;
    }
    v96 = *(unsigned int **)v55;
    v124 = (int *)v56;
    v126 = v54;
    v71 = strdup(v96);
    v54 = v126;
    v56 = (int)v124;
    v121 = v71;
    v57[4] = v71;
    if ( !v71 )
      break;
LABEL_98:
    v59 = *(_DWORD *)(v55 + 16);
    v57[2] = (int *)1;
    v57[14] = 0;
    v60 = *(unsigned int **)(v59 + 16);
    if ( *(_BYTE *)v60 == 47 )
    {
      v124 = (int *)v56;
      v126 = v54;
      v61 = _gconv_find_shlib(v60);
      v62 = v126;
      v56 = (int)v124;
      if ( !v61 )
        break;
      v63 = *v61;
      *v57 = v61;
      v126 = v62;
      v57[1] = (int *)v63;
      v57[5] = (int *)v61[3];
      v64 = v61[4];
      v65 = v61[5];
      v57[6] = 0;
      v57[7] = (int *)v64;
      v57[8] = (int *)v65;
      v66 = __readgsdword(0x18u) ^ __ROR4__(v64, 9);
      if ( v66 )
      {
        v124 = (int *)v56;
        dl_mcount_wrapper_check(v66);
        v67 = ((int (__cdecl *)(int **))v66)(v57);
        v68 = v126;
        if ( v67 )
        {
          v126 = v67;
          v70 = v68 - 1;
          v57[8] = (int *)__ROL4__(__readgsdword(0x18u), 9);
          if ( *v117 <= v68 - 1 )
          {
            v85 = v115;
            free((int)&savedregs, v115, (int)v125);
            free((int)&savedregs, v85, v123);
            v52 = 0;
            free((int)&savedregs, v85, (int)v121);
            v118 = 0;
            *v117 = 0;
            *v112 = 0;
            goto LABEL_116;
          }
          goto LABEL_111;
        }
        v66 = (int)v57[6];
        v56 = (int)v124;
      }
      v55 = *(_DWORD *)(v55 + 20);
      v57[6] = (int *)__ROL4__(__readgsdword(0x18u) ^ v66, 9);
      v58 = v56 - 1;
      v57 -= 15;
      v54 = v56;
      if ( !v56 )
      {
LABEL_104:
        v52 = *v117;
        v118 = v125;
        goto LABEL_105;
      }
    }
    else
    {
      v126 = v56;
      v97 = v57;
      v57 -= 15;
      _gconv_get_builtin_trans((char *)v60, v97);
      v55 = *(_DWORD *)(v55 + 20);
      v58 = v126 - 1;
      v54 = v126;
      if ( !v126 )
        goto LABEL_104;
    }
    v56 = v58;
  }
  v70 = v56 + 1;
LABEL_110:
  v126 = 0;
  if ( *v117 <= v70 )
  {
    v88 = v115;
    v52 = 0;
    free((int)&savedregs, v115, (int)v125);
    free((int)&savedregs, v88, v123);
    free((int)&savedregs, v88, (int)v121);
    v118 = 0;
    v126 = 1;
    *v117 = 0;
    *v112 = 0;
    goto LABEL_116;
  }
LABEL_111:
  v72 = v117;
  v73 = &v125[15 * v70];
  do
  {
    ++v70;
    v96 = (unsigned int *)v73;
    v73 += 15;
    _gconv_release_step((int *)v96);
  }
  while ( v70 < *v72 );
  v74 = v115;
  v52 = 0;
  free((int)&savedregs, v115, (int)v125);
  free((int)&savedregs, v74, v123);
  free((int)&savedregs, v74, (int)v121);
  v118 = 0;
  *v117 = 0;
  *v112 = 0;
  if ( !v126 )
  {
    v126 = 1;
    v118 = 0;
    v52 = 0;
  }
LABEL_116:
  v75 = strlen(v113) + 1;
  v125 = (_DWORD *)(strlen(v122) + 1);
  v76 = malloc((const struct timespec *)((char *)v125 + v75 + 16));
  v77 = v76;
  if ( v76 )
  {
    v78 = v76 + 4;
    v124 = v77;
    *v77 = (int)v78;
    v98 = v75;
    v79 = v115;
    v80 = mempcpy(v78, v113, v98);
    v81 = memcpy(v80, v122, (unsigned int)v125);
    v82 = (int)v124;
    v124[1] = (int)v81;
    v83 = (int)v118;
    *(_DWORD *)(v82 + 12) = v52;
    *(_DWORD *)(v82 + 8) = v83;
    v125 = (_DWORD *)v82;
    if ( !tsearch(v82, v110, (int (__cdecl *)(int, _DWORD))v111) )
      free((int)&savedregs, v79, (int)v125);
  }
  return v126;
}
// 80CE000: using guessed type _TBYTE GLOBAL_OFFSET_TABLE_;

//----- (08066C30) --------------------------------------------------------
int __cdecl _gconv_compare_alias(char *a1, int *a2)
{
  int *v3; // ebx
  _DWORD *v4; // eax
  _DWORD *v5; // eax
  char *v6; // eax
  int v7; // [esp+8h] [ebp-2Ch] BYREF
  int v8[10]; // [esp+Ch] [ebp-28h] BYREF

  v8[2] = __readgsdword(0x14u);
  if ( !once_0 )
  {
    _gconv_read_conf(a2);
    once_0 |= 2u;
  }
  if ( !_gconv_compare_alias_cache(a1, (unsigned __int8 *)a2, &v7) )
    return v7;
  v8[0] = (int)a2;
  v3 = a2;
  v4 = tfind((int)v8, &_gconv_alias_db, (int (__cdecl *)(int, _DWORD))_gconv_alias_compare);
  if ( v4 )
  {
    v3 = *(int **)(*v4 + 4);
    if ( !v3 )
      v3 = a2;
  }
  v8[0] = (int)a1;
  v5 = tfind((int)v8, &_gconv_alias_db, (int (__cdecl *)(int, _DWORD))_gconv_alias_compare);
  if ( v5 )
  {
    v6 = *(char **)(*v5 + 4);
    if ( !v6 )
      v6 = a1;
  }
  else
  {
    v6 = a1;
  }
  return strcmp(v6, v3);
}
// 80CF93C: using guessed type int once_0;
// 80CFF84: using guessed type int _gconv_alias_db;

//----- (08066D60) --------------------------------------------------------
int __cdecl _gconv_find_transform(unsigned __int8 *a1, int *a2, int ***a3, int *a4, char a5)
{
  bool v7; // zf
  int derivation; // edx
  unsigned int *v9; // eax
  unsigned int *v10; // edx
  char *v11; // eax
  unsigned int *v12; // edx
  char *v13; // ebp
  int v15; // eax
  int v16; // eax
  unsigned int *v17; // [esp+8h] [ebp-34h]
  unsigned int *v18; // [esp+Ch] [ebp-30h]
  int v19[10]; // [esp+14h] [ebp-28h] BYREF

  _EBX = &GLOBAL_OFFSET_TABLE_;
  v19[2] = __readgsdword(0x14u);
  if ( !once_0 )
  {
    _gconv_read_conf(a2);
    once_0 |= 2u;
  }
  _ECX = 1;
  v7 = __readgsdword(0xCu) == 0;
  if ( !v7 )
    __asm { lock }
  __asm { cmpxchg ds:(__gconv_lock - 80CE000h)[ebx], ecx }
  if ( !v7 )
    _lll_lock_wait_private(0, &_gconv_lock, 0, a2);
  derivation = _gconv_lookup_cache(a1, (unsigned __int8 *)a2, a3, a4, a5);
  if ( derivation == 2 )
  {
    if ( _gconv_modules_db )
    {
      v19[0] = (int)a2;
      v9 = tfind((int)v19, &_gconv_alias_db, (int (__cdecl *)(int, _DWORD))_gconv_alias_compare);
      v10 = v9;
      if ( v9 )
        v10 = *(unsigned int **)(*v9 + 4);
      v18 = v10;
      v19[0] = (int)a1;
      v11 = (char *)tfind((int)v19, &_gconv_alias_db, (int (__cdecl *)(int, _DWORD))_gconv_alias_compare);
      v12 = v18;
      v13 = v11;
      if ( v11 )
        v13 = *(char **)(*(_DWORD *)v11 + 4);
      if ( (a5 & 1) != 0
        && (!strcmp((char *)a1, a2)
         || (v12 = v18, v13) && (v15 = strcmp(v13, a2), v12 = v18, !v15)
         || v12
         && ((v17 = v12, !strcmp((char *)a1, v12)) || (v12 = v17, v13) && (v16 = strcmp(v13, v17), v12 = v17, !v16))) )
      {
        if ( __readgsdword(0xCu) )
          __asm { lock }
        if ( --_gconv_lock )
          _lll_unlock_wake_private(&_gconv_lock, (int)v13, a2, (const struct timespec *)a1);
        return -1;
      }
      else
      {
        derivation = find_derivation(a1, v13, (unsigned int *)a2, v12, (unsigned int ***)a3, (unsigned int *)a4);
        if ( __readgsdword(0xCu) )
          __asm { lock }
        if ( --_gconv_lock )
          _lll_unlock_wake_private(&_gconv_lock, (int)v13, a2, (const struct timespec *)a1);
        if ( !derivation )
          return *a3 == 0;
      }
    }
    else
    {
      if ( __readgsdword(0xCu) )
        __asm { lock }
      if ( --_gconv_lock )
        _lll_unlock_wake_private(&_gconv_lock, 0, a2, (const struct timespec *)a1);
      return 1;
    }
  }
  else
  {
    if ( __readgsdword(0xCu) )
      __asm { lock }
    if ( --_gconv_lock )
      _lll_unlock_wake_private(&_gconv_lock, 0, a2, (const struct timespec *)a1);
  }
  return derivation;
}
// 8066EC1: variable 'derivation' is possibly undefined
// 80CE000: using guessed type _TBYTE GLOBAL_OFFSET_TABLE_;
// 80CF93C: using guessed type int once_0;
// 80CFF7C: using guessed type int _gconv_modules_db;
// 80CFF80: using guessed type int _gconv_lock;
// 80CFF84: using guessed type int _gconv_alias_db;

//----- (08067020) --------------------------------------------------------
int __cdecl _gconv_close_transform(const struct timespec *a1, int a2)
{
  bool v4; // zf
  struct timespec *i; // ebx

  _ECX = 1;
  _EDI = &GLOBAL_OFFSET_TABLE_;
  v4 = __readgsdword(0xCu) == 0;
  if ( !v4 )
    __asm { lock }
  __asm { cmpxchg ds:(__gconv_lock - 80CE000h)[edi], ecx }
  if ( !v4 )
    _lll_lock_wait_private(0, &_gconv_lock, a2, (int *)&GLOBAL_OFFSET_TABLE_);
  if ( a2 )
  {
    for ( i = (struct timespec *)((char *)&a1[-7] + 60 * a2 - 4); ; i = (struct timespec *)((char *)i - 60) )
    {
      _gconv_release_step(&i->tv_sec);
      if ( i == a1 )
        break;
    }
  }
  _gconv_release_cache(a2, (int *)&GLOBAL_OFFSET_TABLE_, (int)a1);
  if ( __readgsdword(0xCu) )
    __asm { lock }
  if ( --_gconv_lock )
    _lll_unlock_wake_private(&_gconv_lock, a2, (int *)&GLOBAL_OFFSET_TABLE_, a1);
  return 0;
}
// 80CE000: using guessed type _TBYTE GLOBAL_OFFSET_TABLE_;
// 80CFF80: using guessed type int _gconv_lock;

//----- (080670C0) --------------------------------------------------------
int __usercall insert_module@<eax>(int result@<eax>, int a2@<edx>)
{
  int v2; // ebp
  int *v3; // esi
  char *v4; // edi
  _BYTE **v5; // ebx
  _BYTE *v6; // eax

  v2 = result;
  v3 = &_gconv_modules_db;
  while ( 1 )
  {
    v5 = (_BYTE **)*v3;
    if ( !*v3 )
      goto LABEL_6;
    v4 = *(char **)v2;
    result = strcmp(*(char **)v2, *v5);
    if ( !result )
      break;
    v3 = (int *)(v5 + 5);
    if ( result >= 0 )
      v3 = (int *)(v5 + 7);
  }
LABEL_8:
  result = strcmp(*(char **)(v2 + 4), v5[1]);
  if ( result )
  {
    while ( 1 )
    {
      v3 = (int *)(v5 + 6);
      v5 = (_BYTE **)v5[6];
      if ( !v5 )
        break;
      result = strcmp(v4, *v5);
      if ( !result )
        goto LABEL_8;
    }
LABEL_6:
    *v3 = v2;
    return result;
  }
  v6 = v5[2];
  if ( *(_DWORD *)(v2 + 8) < (int)v6 || *(_BYTE **)(v2 + 8) == v6 && *(_DWORD *)(v2 + 12) < (int)v5[3] )
  {
    *(_DWORD *)(v2 + 20) = v5[5];
    *(_DWORD *)(v2 + 28) = v5[7];
    *(_DWORD *)(v2 + 24) = v5[6];
    *v3 = v2;
    return (int)free(v2, (int *)v4, (int)v5);
  }
  else
  {
    result = a2;
    if ( a2 )
      return (int)free(v2, (int *)v4, v2);
  }
  return result;
}
// 80CFF7C: using guessed type int _gconv_modules_db;

//----- (080671B0) --------------------------------------------------------
int __usercall detect_conflict@<eax>(char *a1@<eax>)
{
  int v1; // ebx
  int v3; // eax

  v1 = _gconv_modules_db;
  if ( !_gconv_modules_db )
    return 0;
  while ( 1 )
  {
    v3 = strcmp(a1, *(_BYTE **)v1);
    if ( !v3 )
      break;
    if ( v3 >= 0 )
    {
      v1 = *(_DWORD *)(v1 + 28);
      if ( !v1 )
        return 0;
    }
    else
    {
      v1 = *(_DWORD *)(v1 + 20);
      if ( !v1 )
        return 0;
    }
  }
  return 1;
}
// 80CFF7C: using guessed type int _gconv_modules_db;

//----- (08067210) --------------------------------------------------------
unsigned int __usercall add_module_isra_0@<eax>(char *a1@<eax>, _BYTE *a2@<edx>, unsigned int a3@<ecx>, int a4)
{
  char *v4; // edi
  int v5; // edx
  char v6; // cl
  char *v7; // ebx
  int v8; // ecx
  _BYTE *v9; // esi
  int v11; // edx
  unsigned __int8 *v12; // ebx
  unsigned __int8 *v13; // esi
  int *v14; // edi
  int v15; // ecx
  signed __int8 v16; // dl
  char *v17; // esi
  char *v18; // ecx
  _BYTE *v19; // esi
  char v20; // al
  bool v21; // zf
  unsigned int v22; // eax
  unsigned int v23; // eax
  _BYTE *v24; // edx
  int v25; // ecx
  unsigned __int8 *v26; // eax
  unsigned __int8 *v27; // esi
  _BYTE *v28; // eax
  _WORD *v29; // eax
  unsigned __int8 *v30; // ecx
  char *v31; // edx
  _WORD *v32; // eax
  int v33; // ecx
  unsigned int v34; // ecx
  _TBYTE *v35; // edi
  _WORD *v36; // eax
  signed int v37; // eax
  void *v38; // esp
  _BYTE v39[4]; // [esp-1010h] [ebp-105Ch]
  _BYTE v40[4096]; // [esp-100Ch] [ebp-1058h] BYREF
  _BYTE v41[12]; // [esp-Ch] [ebp-58h] BYREF
  unsigned int v42; // [esp+0h] [ebp-4Ch]
  unsigned int v43; // [esp+4h] [ebp-48h]
  int v44; // [esp+8h] [ebp-44h]
  _BYTE *v45; // [esp+Ch] [ebp-40h]
  int v46; // [esp+10h] [ebp-3Ch]
  unsigned int v47; // [esp+14h] [ebp-38h]
  unsigned __int8 *v48; // [esp+18h] [ebp-34h]
  char *v49; // [esp+1Ch] [ebp-30h]
  _TBYTE *v50; // [esp+20h] [ebp-2Ch]
  int v51[2]; // [esp+28h] [ebp-24h] BYREF
  unsigned int v52; // [esp+30h] [ebp-1Ch]

  v4 = a1;
  v45 = a2;
  v5 = *a1;
  v47 = a3;
  v50 = &GLOBAL_OFFSET_TABLE_;
  v52 = __readgsdword(0x14u);
  if ( (byte_80A7940[2 * v5 + 1] & 0x20) != 0 )
  {
    do
    {
      v5 = *++v4;
      v6 = *v4;
    }
    while ( (byte_80A7940[2 * v5 + 1] & 0x20) != 0 );
  }
  else
  {
    v6 = v5;
  }
  if ( v6 )
  {
    v7 = v4;
    v8 = *((_DWORD *)v50 - 33);
    while ( 1 )
    {
      v9 = v7 + 1;
      *v7 = *(_DWORD *)(v8 + 4 * v5);
      v5 = v7[1];
      if ( !(_BYTE)v5 )
        break;
      if ( (byte_80A7940[2 * v5 + 1] & 0x20) != 0 )
      {
        v11 = v7[2];
        v12 = (unsigned __int8 *)(v7 + 2);
        *v9 = 0;
        v48 = v12;
        LOBYTE(v49) = v11;
        if ( (byte_80A7940[2 * v11 + 1] & 0x20) != 0 )
        {
          do
            v11 = (char)*++v12;
          while ( (byte_80A7940[2 * v11 + 1] & 0x20) != 0 );
          LOBYTE(v49) = *v12;
        }
        v13 = v48;
        if ( (_BYTE)v49 )
        {
          v49 = v4;
          while ( 1 )
          {
            ++v12;
            *v13 = *(_DWORD *)(v8 + 4 * v11);
            v11 = (char)*v12;
            if ( !(_BYTE)v11 )
              break;
            if ( (byte_80A7940[2 * v11 + 1] & 0x20) != 0 )
            {
              v46 = (int)(v13 + 1);
              v14 = (int *)v49;
              v49 = (char *)(v13 + 2);
              v13[1] = 0;
              do
              {
                v15 = (char)*++v12;
                v16 = *v12;
              }
              while ( (byte_80A7940[2 * v15 + 1] & 0x20) != 0 );
              if ( (_BYTE)v15 )
              {
                v17 = v49;
                v44 = (int)v14;
                while ( 1 )
                {
                  ++v12;
                  v18 = v17 + 1;
                  *v17 = v16;
                  v16 = *v12;
                  if ( !*v12 )
                  {
                    v14 = (int *)v44;
                    goto LABEL_26;
                  }
                  if ( (byte_80A7940[2 * v16 + 1] & 0x20) != 0 )
                    break;
                  ++v17;
                }
                *v18 = 0;
                v14 = (int *)v44;
                v19 = v17 + 2;
                v37 = strtol(v12, v51, 10);
                v44 = v37;
                if ( (unsigned __int8 *)v51[0] == v12 || v37 <= 0 )
                  v44 = 1;
              }
              else
              {
                v18 = v49;
LABEL_26:
                *v18 = 0;
                v19 = v18 + 1;
                v44 = 1;
              }
              v20 = *(_BYTE *)(v46 + 1);
              if ( v20 )
              {
                v21 = v20 == 47;
                v22 = 0;
                if ( !v21 )
                  v22 = v47;
                v46 = 3;
                v47 = v22;
                v43 = v19 - v49;
                if ( v19 - v49 > 3 )
                  v46 = 3 * (*((_DWORD *)v19 - 1) != 7303982);
                v42 = v48 - (unsigned __int8 *)v14;
                v23 = strnlen(v14, v48 - (unsigned __int8 *)v14);
                v24 = &v41[-((v23 + 28) & 0xFFFFF000)];
                if ( v41 != v24 )
                {
                  while ( v40 != v24 )
                    ;
                }
                v25 = ((_WORD)v23 + 28) & 0xFF0;
                if ( (((_WORD)v23 + 28) & 0xFF0) != 0 )
                {
                  v38 = alloca(v25);
                  *(_DWORD *)&v39[v25] = *(_DWORD *)&v39[v25];
                }
                v40[v23] = 0;
                v51[0] = (int)memcpy(v40, v14, v23);
                if ( !tfind((int)v51, (_DWORD *)v50 + 2017, (int (__cdecl *)(int, _DWORD))((char *)v50 - 426064)) )
                {
                  v26 = calloc(v14, 1u, v46 + v47 + v19 - (_BYTE *)v14 + 32);
                  v27 = v26;
                  if ( v26 )
                  {
                    v28 = v26 + 32;
                    *(_DWORD *)v27 = v28;
                    v29 = mempcpy(v28, v14, v42);
                    v30 = v48;
                    v31 = v49;
                    *((_DWORD *)v27 + 1) = v29;
                    v32 = mempcpy(v29, v30, v31 - (char *)v30);
                    v33 = v44;
                    *((_DWORD *)v27 + 4) = v32;
                    *((_DWORD *)v27 + 2) = v33;
                    v34 = v47;
                    *((_DWORD *)v27 + 3) = a4;
                    if ( v34 )
                      v32 = mempcpy(v32, v45, v47);
                    v35 = v50;
                    v36 = mempcpy(v32, v49, v43);
                    if ( v46 )
                      *(_DWORD *)((char *)v36 - 1) = *((_DWORD *)v35 - 42074);
                    insert_module((int)v27, 1);
                  }
                }
              }
              return __readgsdword(0x14u) ^ v52;
            }
            ++v13;
          }
        }
        return __readgsdword(0x14u) ^ v52;
      }
      ++v7;
    }
  }
  return __readgsdword(0x14u) ^ v52;
}
// 80A7940: using guessed type _BYTE byte_80A7940[512];
// 80CE000: using guessed type _TBYTE GLOBAL_OFFSET_TABLE_;

//----- (08067580) --------------------------------------------------------
int *__usercall add_alias2_isra_1_part_2@<eax>(_BYTE *a1@<eax>, int a2@<edx>, int a3@<ecx>)
{
  unsigned int v4; // ebp
  int *result; // eax
  int *v6; // esi
  _BYTE *v7; // eax

  v4 = a3 - (_DWORD)a1;
  result = malloc((const struct timespec *)(a3 - (_DWORD)a1 + 8));
  if ( result )
  {
    v6 = result;
    v7 = memcpy((_BYTE *)result + 8, a1, v4);
    *v6 = (int)v7;
    v6[1] = (int)&v7[a2 - (_DWORD)a1];
    result = tsearch((int)v6, &_gconv_alias_db, (int (__cdecl *)(int, _DWORD))_gconv_alias_compare);
    if ( !result || v6 != (int *)*result )
      return free(a2 - (_DWORD)a1, (int *)a1, (int)v6);
  }
  return result;
}
// 80CFF84: using guessed type int _gconv_alias_db;

//----- (08067600) --------------------------------------------------------
unsigned int __usercall _gconv_get_path@<eax>(int *a1@<edi>)
{
  bool v3; // zf
  int v4; // esi
  int v6; // eax
  int v7; // ecx
  _DWORD *v8; // eax
  int v9; // ecx
  _DWORD *i; // edi
  char *v11; // esi
  _DWORD *v12; // eax
  int v13; // edx
  int v14; // ecx
  int *v15; // eax
  int v16; // eax
  int *v17; // edx
  int *v18; // ecx
  _WORD *v19; // eax
  _BYTE *v20; // eax
  unsigned int v21; // edx
  int v22; // eax
  int *v23; // eax
  void *v24; // esp
  char v25[4128]; // [esp-1024h] [ebp-1068h] BYREF
  char v26; // [esp-4h] [ebp-48h] BYREF
  int v27; // [esp+0h] [ebp-44h]
  char *v28; // [esp+4h] [ebp-40h]
  int v29; // [esp+8h] [ebp-3Ch]
  int v30; // [esp+Ch] [ebp-38h]
  char *v31; // [esp+10h] [ebp-34h]
  unsigned int *v32; // [esp+14h] [ebp-30h]
  int *v33; // [esp+18h] [ebp-2Ch]
  char *v34; // [esp+24h] [ebp-20h] BYREF
  unsigned int v35; // [esp+28h] [ebp-1Ch]
  int savedregs; // [esp+44h] [ebp+0h] BYREF

  _ECX = 1;
  _EBX = &GLOBAL_OFFSET_TABLE_;
  v35 = __readgsdword(0x14u);
  v3 = __readgsdword(0xCu) == 0;
  if ( !v3 )
    __asm { lock }
  __asm { cmpxchg ds:(lock_12667 - 80CE000h)[ebx], ecx }
  if ( !v3 )
    _lll_lock_wait_private(0, &lock_12667, (int)&savedregs, a1);
  v4 = _gconv_path_elem;
  if ( !_gconv_path_elem )
  {
    v32 = (unsigned int *)_gconv_path_envvar;
    if ( _gconv_path_envvar )
    {
      v6 = strlen(v32);
      v30 = v6 + 16;
      while ( &v26 != &v26 - ((v6 + 43) & 0xFFFFF000) )
        ;
      v7 = ((_WORD)v6 + 43) & 0xFF0;
      if ( (((_WORD)v6 + 43) & 0xFF0) != 0 )
      {
        v24 = alloca(v7);
        *(_DWORD *)&v25[v7 + 4124] = *(_DWORD *)&v25[v7 + 4124];
      }
      v34 = &v26;
      strcpy((char *)mempcpy(&v26, v32, v6), ":/usr/lib/gconv");
      v32 = (unsigned int *)getcwd(0LL);
      if ( v32 )
      {
        v29 = strlen(v32);
        v28 = v34;
        v27 = v29 + 1;
      }
      else
      {
        v27 = 1;
        v29 = 0;
        v28 = v34;
      }
    }
    else
    {
      v27 = 1;
      v29 = 0;
      v28 = v25;
      v34 = v25;
      strcpy(v25, "/usr/lib/gconv");
      v30 = 15;
    }
    v8 = strchr(v28, 58);
    if ( v8 )
    {
      v9 = 1;
      for ( i = v8; ; i = v12 )
      {
        v31 = (char *)(v9 + 1);
        if ( i != (_DWORD *)(v4 + 1) )
        {
          v11 = (char *)(v9 + 2);
          ++v9;
          v31 = v11;
        }
        v33 = (int *)v9;
        v4 = (int)i;
        v12 = strchr((_BYTE *)i + 1, 58);
        v9 = (int)v33;
        if ( !v12 )
          break;
      }
      v4 = (int)v33;
      v13 = ((_DWORD)v33 - 1) * v27;
      v14 = 8 * (_DWORD)v31;
    }
    else
    {
      v13 = 0;
      v4 = 1;
      v14 = 16;
    }
    v15 = malloc((const struct timespec *)(v13 + v14 + v4 + v30));
    a1 = v15;
    if ( v15 )
    {
      _gconv_max_path_elem_len = 0;
      v30 = (int)&v34;
      v33 = &v15[2 * v4 + 2];
      v31 = ":";
      v16 = strtok_r((int)v28, ":", (int *)&v34);
      v17 = v33;
      v18 = (int *)v16;
      if ( !v16 )
        _assert_fail((int)"elem != NULL", (int)"gconv_conf.c", 495, (int)"__gconv_get_path");
      v4 = 0;
      do
      {
        a1[2 * v4] = (int)v17;
        if ( *(_BYTE *)v18 != 47 )
        {
          if ( !v32 )
            _assert_fail((int)"cwd != NULL", (int)"gconv_conf.c", 501, (int)"__gconv_get_path");
          v33 = v18;
          v19 = mempcpy(v17, v32, v29);
          v18 = v33;
          *(_BYTE *)v19 = 47;
          v17 = (int *)((char *)v19 + 1);
        }
        v20 = stpcpy((int)v17, (int)v18);
        if ( *(v20 - 1) != 47 )
          *v20++ = 47;
        v21 = (unsigned int)&v20[-a1[2 * v4]];
        a1[2 * v4 + 1] = v21;
        if ( v21 > _gconv_max_path_elem_len )
          _gconv_max_path_elem_len = v21;
        *v20 = 0;
        ++v4;
        v33 = (int *)(v20 + 1);
        v22 = strtok_r(0, v31, (int *)v30);
        v17 = v33;
        v18 = (int *)v22;
      }
      while ( v22 );
      v23 = &a1[2 * v4];
      *v23 = 0;
      v23[1] = 0;
    }
    else
    {
      a1 = (int *)&empty_path_elem;
    }
    _gconv_path_elem = (int)a1;
    free((int)&savedregs, a1, (int)v32);
  }
  if ( __readgsdword(0xCu) )
    __asm { lock }
  if ( --lock_12667 )
    _lll_unlock_wake_private(&lock_12667, (int)&savedregs, a1, (const struct timespec *)v4);
  return __readgsdword(0x14u) ^ v35;
}
// 80CE000: using guessed type _TBYTE GLOBAL_OFFSET_TABLE_;
// 80CF948: using guessed type int lock_12667;
// 80CFF88: using guessed type int _gconv_path_envvar;
// 80CFF8C: using guessed type int _gconv_max_path_elem_len;
// 80CFF90: using guessed type int _gconv_path_elem;

//----- (08067A10) --------------------------------------------------------
unsigned int __usercall _gconv_read_conf@<eax>(int *a1@<edi>)
{
  int v1; // eax
  _BYTE *v2; // ecx
  int v3; // edx
  void *v4; // esp
  _TBYTE *v5; // edi
  _BYTE *v6; // esi
  _WORD *v7; // eax
  int v8; // ebx
  int v9; // edx
  int v10; // ebx
  int v11; // edx
  int v12; // ebx
  int *v13; // eax
  int *v14; // edi
  int v15; // eax
  int v16; // ebx
  char *v17; // edi
  char *v18; // eax
  int i; // ebx
  int v20; // eax
  char v21; // dl
  struct timespec *v22; // edi
  _BYTE *v23; // ebx
  _DWORD *v24; // ebx
  int *v25; // esi
  int (__cdecl *v26)(int, _DWORD); // edi
  int v27; // eax
  char *v28; // ebx
  _BYTE *v29; // esi
  char *v31; // edx
  int j; // eax
  _BYTE *v33; // edx
  int v34; // edi
  _BYTE *v35; // ecx
  int v36; // eax
  char *v37; // edx
  char k; // cl
  int v39; // eax
  _BYTE *m; // esi
  _BYTE *v41; // ecx
  int v42; // ebx
  _BYTE *v43; // edi
  int v44; // [esp+0h] [ebp-108Ch]
  _BYTE v46[15]; // [esp+10h] [ebp-107Ch] BYREF
  _BYTE v47[8]; // [esp+1010h] [ebp-7Ch] BYREF
  unsigned int v48; // [esp+1018h] [ebp-74h]
  unsigned int v49; // [esp+101Ch] [ebp-70h]
  int v50; // [esp+1020h] [ebp-6Ch]
  int v51; // [esp+1024h] [ebp-68h]
  int v52; // [esp+1028h] [ebp-64h]
  int v53; // [esp+102Ch] [ebp-60h]
  _BYTE *v54; // [esp+1030h] [ebp-5Ch]
  _BYTE *v55; // [esp+1034h] [ebp-58h]
  _BYTE *v56; // [esp+1038h] [ebp-54h]
  int v57; // [esp+103Ch] [ebp-50h]
  _BYTE *v58; // [esp+1040h] [ebp-4Ch]
  unsigned int v59; // [esp+1044h] [ebp-48h]
  _BYTE *v60; // [esp+1048h] [ebp-44h]
  char **v61; // [esp+104Ch] [ebp-40h]
  int v62; // [esp+1050h] [ebp-3Ch]
  unsigned int *v63; // [esp+1054h] [ebp-38h]
  struct timespec *v64; // [esp+1058h] [ebp-34h]
  _TBYTE *v65; // [esp+105Ch] [ebp-30h]
  char *v66; // [esp+1060h] [ebp-2Ch] BYREF
  _DWORD v67[2]; // [esp+1064h] [ebp-28h] BYREF
  unsigned int v68; // [esp+106Ch] [ebp-20h]
  int *v69; // [esp+1084h] [ebp-8h]
  int v70; // [esp+1088h] [ebp-4h] BYREF

  v69 = a1;
  v65 = &GLOBAL_OFFSET_TABLE_;
  v68 = __readgsdword(0x14u);
  v48 = -32;
  v49 = __readgsdword(0xFFFFFFE0);
  if ( _gconv_load_cache((unsigned int)&v70, a1) )
  {
    v1 = *(_DWORD *)((char *)v65 + (_DWORD)(&_gconv_path_elem - 33765376));
    if ( !v1 )
    {
      _gconv_get_path(a1);
      v1 = *(_DWORD *)((char *)v65 + (_DWORD)(&_gconv_path_elem - 33765376));
    }
    v60 = *(_BYTE **)v1;
    if ( v60 )
    {
      v62 = 8;
      v53 = -168292;
      v51 = -168284;
      v52 = -168288;
      v50 = -168280;
      v54 = (char *)v65 - 179465;
      v63 = v67;
      v61 = &v66;
      do
      {
        v59 = *(_DWORD *)(v1 + 4);
        v2 = &v47[-((v59 + 41) & 0xFFFFF000)];
        if ( v47 != v2 )
        {
          while ( v46 != v2 )
            ;
        }
        v3 = ((_WORD)v59 + 41) & 0xFF0;
        if ( (((_WORD)v59 + 41) & 0xFF0) != 0 )
        {
          v4 = alloca(v3);
          *(_DWORD *)&v46[v3 - 4] = *(_DWORD *)&v46[v3 - 4];
        }
        v5 = v65;
        v6 = v46;
        v7 = mempcpy(v46, v60, v59);
        v8 = v52;
        *(_DWORD *)v7 = *(_DWORD *)((char *)v5 + v53);
        v9 = *(_DWORD *)((char *)v5 + v8);
        v10 = v51;
        *((_DWORD *)v7 + 1) = v9;
        v11 = *(_DWORD *)((char *)v5 + v10);
        v12 = v50;
        *((_DWORD *)v7 + 2) = v11;
        v7[6] = *(_WORD *)((char *)v5 + v12);
        v13 = fopen((int)&v70, (int)v46, v54);
        v66 = 0;
        v14 = v13;
        v67[0] = 0;
        if ( v13 )
        {
          v15 = *v13;
          v64 = (struct timespec *)v14;
          BYTE1(v15) |= 0x80u;
          *v14 = v15;
          if ( (v15 & 0x10) == 0 )
          {
            do
            {
              v16 = getdelim((signed int)v6, v61, v63, 10, &v64->tv_sec);
              if ( v16 < 0 )
                break;
              v17 = v66;
              v18 = (char *)strchr(v66, 35);
              if ( v18 )
              {
                *v18 = 0;
              }
              else
              {
                v31 = &v17[v16 - 1];
                if ( *v31 == 10 )
                  *v31 = 0;
              }
              for ( i = *((_DWORD *)v65 - 35); (*(_BYTE *)(i + 2 * *v17 + 1) & 0x20) != 0; ++v17 )
                ;
              if ( v18 != v17 )
              {
                v20 = *v17;
                if ( (_BYTE)v20 )
                {
                  if ( (*(_BYTE *)(i + 2 * v20 + 1) & 0x20) == 0 )
                  {
                    v6 = v17;
                    do
                      v21 = *++v6;
                    while ( *v6 && (*(_BYTE *)(i + 2 * v21 + 1) & 0x20) == 0 );
                    if ( v6 - v17 == 5 )
                    {
                      if ( *(_DWORD *)v17 == 1634298977 && v17[4] == 115 )
                      {
                        for ( j = v21; (*(_BYTE *)(i + 2 * j + 1) & 0x20) != 0; v21 = *v6 )
                          j = (char)*++v6;
                        if ( v21 )
                        {
                          v33 = v6;
                          v34 = *((_DWORD *)v65 - 33);
                          while ( 1 )
                          {
                            v35 = v33 + 1;
                            *v33 = *(_DWORD *)(v34 + 4 * j);
                            j = (char)v33[1];
                            if ( !(_BYTE)j )
                              break;
                            if ( (*(_BYTE *)(i + 2 * j + 1) & 0x20) != 0 )
                            {
                              v36 = (char)v33[2];
                              v37 = v33 + 2;
                              *v35 = 0;
                              v58 = v37;
                              for ( k = v36; (*(_BYTE *)(i + 2 * v36 + 1) & 0x20) != 0; k = *v37 )
                                v36 = *++v37;
                              v57 = v36;
                              v56 = v58;
                              if ( k )
                              {
                                v55 = v6;
                                v39 = v57;
                                for ( m = v56; ; ++m )
                                {
                                  ++v37;
                                  v41 = m + 1;
                                  *m = *(_DWORD *)(v34 + 4 * v39);
                                  v39 = *v37;
                                  if ( !(_BYTE)v39 || (*(_BYTE *)(i + 2 * v39 + 1) & 0x20) != 0 )
                                    break;
                                }
                                v42 = (int)v58;
                                v43 = m;
                                v6 = v55;
                                if ( v58 != v41 )
                                {
                                  *v41 = 0;
                                  if ( !detect_conflict(v6) )
                                    add_alias2_isra_1_part_2(v6, v42, (int)(v43 + 2));
                                }
                              }
                              break;
                            }
                            ++v33;
                          }
                        }
                      }
                    }
                    else if ( v6 - v17 == 6 && *(_DWORD *)v17 == 1969516397 && *((_WORD *)v17 + 2) == 25964 )
                    {
                      v44 = *((_DWORD *)v65 + 1617);
                      *((_DWORD *)v65 + 1617) = v44 + 1;
                      add_module_isra_0(v6, v60, v59, v44);
                    }
                  }
                }
              }
            }
            while ( (v64->tv_sec & 0x10) == 0 );
          }
          v22 = v64;
          free((int)&v70, &v64->tv_sec, (int)v66);
          fclose(v22);
        }
        v1 = v62 + *((_DWORD *)v65 + 2020);
        v23 = *(_BYTE **)v1;
        v62 += 8;
        v60 = v23;
      }
      while ( v23 );
    }
    else
    {
      v63 = v67;
    }
    v24 = (_DWORD *)((char *)v65 + (_DWORD)(&_gconv_alias_db - 33765376));
    v25 = (int *)((char *)&builtin_modules[-33765376] + (_DWORD)v65);
    v64 = (struct timespec *)((char *)&nl_global_locale[-33765376] + (_DWORD)v65);
    v26 = (int (__cdecl *)(int, _DWORD))((char *)v65 + (_DWORD)_gconv_alias_compare - 135061504);
    do
    {
      while ( 1 )
      {
        v67[0] = *v25;
        if ( !tfind((int)v63, v24, v26) )
          break;
        v25 += 8;
        if ( v64 == (struct timespec *)v25 )
          goto LABEL_33;
      }
      v27 = (int)v25;
      v25 += 8;
      insert_module(v27, 0);
    }
    while ( v64 != (struct timespec *)v25 );
LABEL_33:
    v28 = &builtin_aliases[(_DWORD)v65 - 135061504];
    do
    {
      v65 = (_TBYTE *)(rawmemchr(v28, 0) + 1);
      v29 = rawmemchr(v65, 0);
      if ( !detect_conflict(v28) )
        add_alias2_isra_1_part_2(v28, (int)v65, (int)(v29 + 1));
      v28 = v29 + 1;
    }
    while ( v29[1] );
  }
  __writegsdword(v48, v49);
  return __readgsdword(0x14u) ^ v68;
}
// 80CE000: using guessed type _TBYTE GLOBAL_OFFSET_TABLE_;
// 80CECE0: using guessed type char *builtin_modules[2];
// 80CEE60: using guessed type char **nl_global_locale[6];
// 80CFF84: using guessed type int _gconv_alias_db;
// 80CFF90: using guessed type int _gconv_path_elem;

//----- (08067EE0) --------------------------------------------------------
int __cdecl _gconv_get_builtin_trans(char *a1, _DWORD *a2)
{
  int v2; // ebx
  char **v3; // edi
  char *v4; // eax
  char **v5; // eax
  char *v6; // edx
  int v7; // edx
  int result; // eax

  v2 = 0;
  v3 = &off_80CDDD0;
  v4 = "=INTERNAL->ucs4";
  while ( strcmp(a1, v4) )
  {
    if ( ++v2 == 12 )
      _assert_fail(
        (int)&GLOBAL_OFFSET_TABLE_ - 167232,
        (int)&GLOBAL_OFFSET_TABLE_ - 167248,
        70,
        (int)&GLOBAL_OFFSET_TABLE_ - 167192);
    v4 = *v3;
    v3 += 4;
  }
  a2[7] = 0;
  a2[8] = 0;
  v5 = &(&map_0)[4 * v2];
  *a2 = 0;
  v6 = v5[1];
  a2[1] = 0;
  a2[13] = 0;
  a2[5] = v6;
  a2[6] = v5[2];
  a2[9] = *((char *)v5 + 12);
  a2[10] = *((char *)v5 + 13);
  v7 = *((char *)v5 + 14);
  result = *((char *)v5 + 15);
  a2[11] = v7;
  a2[12] = result;
  return result;
}
// 80CDDC0: using guessed type char *map_0;
// 80CDDD0: using guessed type char *off_80CDDD0;
// 80CE000: using guessed type _TBYTE GLOBAL_OFFSET_TABLE_;

//----- (08067FC0) --------------------------------------------------------
int __cdecl _gconv_btwoc_ascii(int a1, char a2)
{
  int result; // eax

  result = (unsigned __int8)a2;
  if ( a2 < 0 )
    return -1;
  return result;
}

//----- (08067FE0) --------------------------------------------------------
int __cdecl _gconv_transform_internal_ucs4(
        int a1,
        unsigned int *a2,
        unsigned int *a3,
        unsigned int a4,
        unsigned int *a5,
        int a6,
        int a7,
        int a8)
{
  unsigned int *v8; // eax
  unsigned int v9; // ebp
  unsigned int v10; // ecx
  int v11; // ebx
  unsigned int v12; // edx
  unsigned int v13; // eax
  unsigned int v14; // ebx
  signed int v15; // eax
  int v16; // ecx
  int v17; // eax
  unsigned int v18; // edi
  int v19; // edx
  int v20; // eax
  _DWORD *v22; // eax
  unsigned int v23; // ecx
  unsigned int *v24; // ebx
  unsigned int v25; // eax
  _DWORD *v26; // esi
  unsigned int v27; // eax
  unsigned int v28; // [esp+8h] [ebp-50h]
  int v29; // [esp+10h] [ebp-48h]
  int (__cdecl *v30)(int, unsigned int *, int *, unsigned int, _DWORD, int, int, int); // [esp+14h] [ebp-44h]
  int v31; // [esp+18h] [ebp-40h]
  unsigned int *v32; // [esp+1Ch] [ebp-3Ch]
  int v33[9]; // [esp+34h] [ebp-24h] BYREF

  v33[1] = __readgsdword(0x14u);
  v30 = 0;
  v31 = a1 + 60;
  v32 = a2 + 8;
  if ( (a2[2] & 1) == 0 )
  {
    v30 = *(int (__cdecl **)(int, unsigned int *, int *, unsigned int, _DWORD, int, int, int))(a1 + 80);
    if ( *(_DWORD *)(a1 + 60) )
      v30 = (int (__cdecl *)(int, unsigned int *, int *, unsigned int, _DWORD, int, int, int))(__readgsdword(0x18u) ^ __ROR4__(*(_DWORD *)(a1 + 80), 9));
  }
  if ( a7 )
  {
    if ( a5 )
      _assert_fail(
        (int)&GLOBAL_OFFSET_TABLE_ - 167146,
        (int)&GLOBAL_OFFSET_TABLE_ - 167166,
        415,
        (int)(&GLOBAL_OFFSET_TABLE_ - 16592));
    v22 = (_DWORD *)a2[5];
    v19 = 0;
    *v22 = 0;
    v22[1] = 0;
    if ( (a2[2] & 1) == 0 )
    {
      dl_mcount_wrapper_check((int)v30);
      return v30(v31, v32, 0, 0, 0, a6, a7, a8);
    }
    return v19;
  }
  v8 = a5;
  if ( !a5 )
    v8 = a2;
  v9 = *v8;
  v28 = a2[1];
  if ( a8 )
  {
    v10 = a2[5];
    v11 = *(_DWORD *)v10;
    v12 = *(_DWORD *)v10 & 7;
    if ( v12 )
    {
      if ( a5 )
        _assert_fail(
          (int)&GLOBAL_OFFSET_TABLE_ - 167146,
          (int)&GLOBAL_OFFSET_TABLE_ - 167166,
          559,
          (int)(&GLOBAL_OFFSET_TABLE_ - 16592));
      v13 = *a3;
      if ( *a3 < a4 )
      {
        if ( (v11 & 4) != 0 )
          goto LABEL_16;
        while ( 1 )
        {
          ++v13;
          ++v12;
          *a3 = v13;
          *(_BYTE *)(v10 + v12 + 3) = *(_BYTE *)(v13 - 1);
          if ( a4 == v13 )
            break;
          if ( v12 == 4 )
            goto LABEL_16;
        }
      }
      if ( v12 <= 3 )
      {
        *(_DWORD *)v10 = v11 & 0xFFFFFFF8 | v12;
        return 7;
      }
LABEL_16:
      v9 += 4;
      *(_BYTE *)(v9 - 4) = *(_BYTE *)(v10 + 7);
      *(_BYTE *)(v9 - 3) = *(_BYTE *)(v10 + 6);
      *(_BYTE *)(v9 - 2) = *(_BYTE *)(v10 + 5);
      *(_BYTE *)(v9 - 1) = *(_BYTE *)(v10 + 4);
      *(_DWORD *)v10 &= 0xFFFFFFF8;
      goto LABEL_17;
    }
  }
  while ( 1 )
  {
LABEL_17:
    v14 = *a3;
    v15 = a4 - *a3;
    if ( (int)(v28 - v9) <= v15 )
      v15 = v28 - v9;
    v16 = v15 / 4;
    if ( v15 / 4 )
    {
      v17 = 0;
      do
      {
        *(_DWORD *)(v9 + 4 * v17) = _byteswap_ulong(*(_DWORD *)(v14 + 4 * v17));
        ++v17;
      }
      while ( v16 != v17 );
      v18 = v9 + 4 * v16;
      v14 += 4 * v16;
    }
    else
    {
      v18 = v9;
    }
    v19 = 4;
    *a3 = v14;
    if ( a4 != v14 )
      v19 = v28 < v18 + 4 ? 5 : 7;
    if ( a5 )
    {
      *a5 = v18;
      return v19;
    }
    ++a2[3];
    if ( (a2[2] & 1) != 0 )
    {
      *a2 = v18;
      goto LABEL_34;
    }
    if ( v18 <= v9 )
      goto LABEL_34;
    v29 = v19;
    v33[0] = *a2;
    dl_mcount_wrapper_check((int)v30);
    v20 = v30(v31, v32, v33, v18, 0, a6, 0, a8);
    v19 = v29;
    if ( v20 != 4 )
      break;
    if ( v29 != 5 )
      goto LABEL_34;
LABEL_32:
    v9 = *a2;
  }
  if ( v33[0] != v18 )
    *a3 -= v18 - v33[0];
  if ( !v20 )
    goto LABEL_32;
  v19 = v20;
LABEL_34:
  if ( a8 && v19 == 7 )
  {
    v23 = *a3;
    if ( (int)(a4 - *a3) > 3 )
      _assert_fail(
        (int)&GLOBAL_OFFSET_TABLE_ - 167126,
        (int)&GLOBAL_OFFSET_TABLE_ - 167166,
        777,
        (int)(&GLOBAL_OFFSET_TABLE_ - 16592));
    v24 = (unsigned int *)a2[5];
    v25 = *a3;
    v26 = v24 + 1;
    if ( v23 >= a4 )
    {
      v27 = 0;
    }
    else
    {
      do
      {
        ++v25;
        v26 = (_DWORD *)((char *)v26 + 1);
        *a3 = v25;
        *((_BYTE *)v26 - 1) = *(_BYTE *)(v25 - 1);
      }
      while ( v25 != a4 );
      v27 = v25 - v23;
    }
    v19 = 7;
    *v24 = *v24 & 0xFFFFFFF8 | v27;
  }
  return v19;
}
// 80CE000: using guessed type _TBYTE GLOBAL_OFFSET_TABLE_;

//----- (08068390) --------------------------------------------------------
int __cdecl _gconv_transform_ucs4_internal(
        int a1,
        int **a2,
        unsigned int **a3,
        unsigned int *a4,
        int **a5,
        _DWORD *a6,
        int a7,
        int a8)
{
  int *v8; // ebp
  int **v9; // eax
  int *v10; // esi
  int *v11; // ecx
  int *v12; // ecx
  int v13; // ebx
  int v14; // esi
  unsigned int v15; // edx
  unsigned int *v16; // eax
  int *v17; // ebx
  unsigned int *v18; // edx
  int v19; // eax
  int v20; // esi
  int v21; // ecx
  int v22; // ebp
  int v23; // eax
  int v24; // esi
  int v26; // eax
  unsigned int *v27; // edx
  int *v28; // ecx
  unsigned int *v29; // eax
  int *v30; // ebx
  int v31; // eax
  int *v32; // eax
  unsigned int *v33; // eax
  int v34; // eax
  int *v35; // [esp+0h] [ebp-64h]
  int *v36; // [esp+10h] [ebp-54h]
  int *v37; // [esp+14h] [ebp-50h]
  int (__cdecl *v38)(int, int **, int *, int *, _DWORD, _DWORD *, int, int); // [esp+1Ch] [ebp-48h]
  int v39; // [esp+20h] [ebp-44h]
  int **v40; // [esp+24h] [ebp-40h]
  int v41; // [esp+34h] [ebp-30h]
  int v42; // [esp+3Ch] [ebp-28h] BYREF
  int v43[9]; // [esp+40h] [ebp-24h] BYREF

  v8 = a2[2];
  v43[1] = __readgsdword(0x14u);
  v39 = a1 + 60;
  v40 = a2 + 8;
  v38 = 0;
  if ( ((unsigned __int8)v8 & 1) == 0 )
  {
    v38 = *(int (__cdecl **)(int, int **, int *, int *, _DWORD, _DWORD *, int, int))(a1 + 80);
    if ( *(_DWORD *)(a1 + 60) )
      v38 = (int (__cdecl *)(int, int **, int *, int *, _DWORD, _DWORD *, int, int))(__readgsdword(0x18u) ^ __ROR4__(*(_DWORD *)(a1 + 80), 9));
  }
  if ( a7 )
  {
    if ( a5 )
      _assert_fail(
        (int)&GLOBAL_OFFSET_TABLE_ - 167146,
        (int)&GLOBAL_OFFSET_TABLE_ - 167166,
        415,
        (int)&GLOBAL_OFFSET_TABLE_ - 165952);
    v32 = a2[5];
    v24 = 0;
    *v32 = 0;
    v32[1] = 0;
    if ( ((_BYTE)a2[2] & 1) == 0 )
    {
      dl_mcount_wrapper_check((int)v38);
      return v38(v39, v40, 0, 0, 0, a6, a7, a8);
    }
    return v24;
  }
  v9 = a5;
  if ( !a5 )
    v9 = a2;
  v10 = *v9;
  v36 = a2[1];
  v42 = 0;
  v35 = v10;
  v11 = 0;
  if ( a6 )
    v11 = &v42;
  v37 = v11;
  if ( a8 )
  {
    v12 = a2[5];
    v13 = *v12;
    v14 = *v12 & 7;
    if ( v14 )
    {
      if ( a5 )
        _assert_fail(
          (int)&GLOBAL_OFFSET_TABLE_ - 167146,
          (int)&GLOBAL_OFFSET_TABLE_ - 167166,
          559,
          (int)&GLOBAL_OFFSET_TABLE_ - 165952);
      v15 = *v12 & 7;
      v16 = *a3;
      if ( *a3 >= a4 )
      {
LABEL_18:
        if ( v15 > 3 )
          goto LABEL_19;
        v24 = 7;
        *v12 = v13 & 0xFFFFFFF8 | v15;
      }
      else
      {
        if ( (v13 & 4) != 0 )
          goto LABEL_19;
        v41 = *v12;
        do
        {
          v16 = (unsigned int *)((char *)v16 + 1);
          ++v15;
          *a3 = v16;
          *((_BYTE *)v12 + v15 + 3) = *((_BYTE *)v16 - 1);
          if ( a4 == v16 )
          {
            v13 = v41;
            goto LABEL_18;
          }
        }
        while ( v15 != 4 );
        v13 = v41;
LABEL_19:
        if ( *((_BYTE *)v12 + 4) <= 0x80u )
        {
          *(_BYTE *)v35 = *((_BYTE *)v12 + 7);
          *((_BYTE *)v35 + 1) = *((_BYTE *)v12 + 6);
          *((_BYTE *)v35 + 2) = *((_BYTE *)v12 + 5);
          *((_BYTE *)v35 + 3) = *((_BYTE *)v12 + 4);
          v13 = *v12;
          ++v35;
LABEL_21:
          v8 = a2[2];
          *v12 = v13 & 0xFFFFFFF8;
          goto LABEL_22;
        }
        if ( ((unsigned __int8)v8 & 2) != 0 )
          goto LABEL_21;
        v33 = (unsigned int *)((char *)v16 + v14 - v15);
        v24 = 6;
        *a3 = v33;
      }
      return v24;
    }
  }
  while ( 1 )
  {
LABEL_22:
    v17 = v35;
    v18 = *a3;
    v19 = (char *)a4 - (char *)*a3;
    if ( (char *)v36 - (char *)v35 <= v19 )
      v19 = (char *)v36 - (char *)v35;
    v20 = v19 / 4;
    if ( v19 / 4 )
    {
      v21 = 0;
      v22 = (unsigned __int8)v8 & 2;
      while ( 1 )
      {
        while ( 1 )
        {
          v23 = _byteswap_ulong(*v18);
          if ( v23 < 0 )
            break;
          ++v21;
          *v17 = v23;
          ++v18;
          ++v17;
          if ( v20 == v21 )
            goto LABEL_31;
        }
        if ( !v37 )
          break;
        if ( !v22 )
        {
          v24 = 6;
          *a3 = v18;
          goto LABEL_36;
        }
        ++v21;
        ++*v37;
        ++v18;
        if ( v20 == v21 )
          goto LABEL_31;
      }
      v17 = v35;
      v24 = 6;
    }
    else
    {
      v17 = v35;
LABEL_31:
      v24 = 4;
      *a3 = v18;
      if ( v18 != a4 )
      {
        v24 = v36 < v17 + 1 ? 5 : 7;
        if ( a5 )
          goto LABEL_33;
        goto LABEL_37;
      }
    }
LABEL_36:
    if ( a5 )
    {
LABEL_33:
      *a5 = v17;
      return v24;
    }
LABEL_37:
    a2[3] = (int *)((char *)a2[3] + 1);
    if ( ((_BYTE)a2[2] & 1) != 0 )
    {
      v31 = v42;
      *a2 = v17;
      *a6 += v31;
      goto LABEL_45;
    }
    if ( v35 >= v17 )
      goto LABEL_45;
    v43[0] = (int)*a2;
    dl_mcount_wrapper_check((int)v38);
    v26 = v38(v39, v40, v43, v17, 0, a6, 0, a8);
    if ( v26 != 4 )
      break;
    if ( v24 != 5 )
      goto LABEL_45;
LABEL_43:
    v8 = a2[2];
    v35 = *a2;
  }
  if ( (int *)v43[0] != v17 )
    *a3 = (unsigned int *)((char *)*a3 - ((unsigned int)v17 - v43[0]));
  if ( !v26 )
    goto LABEL_43;
  v24 = v26;
LABEL_45:
  if ( a8 && v24 == 7 )
  {
    v27 = *a3;
    if ( (char *)a4 - (char *)*a3 > 3 )
      _assert_fail(
        (int)&GLOBAL_OFFSET_TABLE_ - 167126,
        (int)&GLOBAL_OFFSET_TABLE_ - 167166,
        777,
        (int)&GLOBAL_OFFSET_TABLE_ - 165952);
    v28 = a2[5];
    v29 = (unsigned int *)((char *)v27 + 1);
    v30 = v28 + 1;
    if ( v27 >= a4 )
    {
      v34 = 0;
    }
    else
    {
      while ( 1 )
      {
        v30 = (int *)((char *)v30 + 1);
        *a3 = v29;
        *((_BYTE *)v30 - 1) = *((_BYTE *)v29 - 1);
        if ( a4 == v29 )
          break;
        v29 = (unsigned int *)((char *)v29 + 1);
      }
      v34 = (char *)a4 - (char *)v27;
    }
    *v28 = *v28 & 0xFFFFFFF8 | v34;
  }
  return v24;
}
// 80CE000: using guessed type _TBYTE GLOBAL_OFFSET_TABLE_;

//----- (08068830) --------------------------------------------------------
int __cdecl _gconv_transform_internal_ucs4le(int a1, int a2, _DWORD *a3, _BYTE *a4, _DWORD *a5, int a6, int a7, int a8)
{
  _DWORD *v8; // eax
  _BYTE *v9; // ebp
  _BYTE *i; // edi
  _BYTE *v11; // ecx
  _BYTE *v12; // ebx
  unsigned int v13; // eax
  unsigned int v14; // eax
  int v15; // ebx
  _WORD *v16; // ecx
  int v17; // eax
  unsigned int *v18; // edi
  unsigned int *v20; // ebx
  unsigned int v21; // edx
  unsigned int v22; // ecx
  _BYTE *v23; // eax
  _DWORD *v24; // eax
  unsigned int v25; // ebx
  unsigned int *v26; // esi
  _BYTE *v27; // eax
  _DWORD *v28; // ebp
  unsigned int v29; // eax
  unsigned int v30; // [esp+4h] [ebp-50h]
  _WORD *v31; // [esp+Ch] [ebp-48h]
  int (__cdecl *v32)(int, int, int *, _WORD *, _DWORD, int, int, int); // [esp+14h] [ebp-40h]
  int v33; // [esp+18h] [ebp-3Ch]
  int v34; // [esp+1Ch] [ebp-38h]
  unsigned int v35; // [esp+24h] [ebp-30h]
  int v36[9]; // [esp+30h] [ebp-24h] BYREF

  v36[1] = __readgsdword(0x14u);
  v32 = 0;
  v33 = a1 + 60;
  v34 = a2 + 32;
  if ( (*(_BYTE *)(a2 + 8) & 1) == 0 )
  {
    v32 = *(int (__cdecl **)(int, int, int *, _WORD *, _DWORD, int, int, int))(a1 + 80);
    if ( *(_DWORD *)(a1 + 60) )
      v32 = (int (__cdecl *)(int, int, int *, _WORD *, _DWORD, int, int, int))(__readgsdword(0x18u) ^ __ROR4__(*(_DWORD *)(a1 + 80), 9));
  }
  if ( a7 )
  {
    if ( a5 )
      _assert_fail(
        (int)&GLOBAL_OFFSET_TABLE_ - 167146,
        (int)&GLOBAL_OFFSET_TABLE_ - 167166,
        415,
        (int)&GLOBAL_OFFSET_TABLE_ - 166016);
    v24 = *(_DWORD **)(a2 + 20);
    v15 = 0;
    *v24 = 0;
    v24[1] = 0;
    if ( (*(_BYTE *)(a2 + 8) & 1) == 0 )
    {
      dl_mcount_wrapper_check((int)v32);
      return v32(v33, v34, 0, 0, 0, a6, a7, a8);
    }
    return v15;
  }
  v8 = a5;
  if ( !a5 )
    v8 = (_DWORD *)a2;
  v9 = (_BYTE *)*v8;
  v30 = *(_DWORD *)(a2 + 4);
  if ( !a8 )
    goto LABEL_8;
  v20 = *(unsigned int **)(a2 + 20);
  v21 = *v20;
  v22 = *v20 & 7;
  if ( !v22 )
    goto LABEL_8;
  if ( a5 )
    _assert_fail(
      (int)&GLOBAL_OFFSET_TABLE_ - 167146,
      (int)&GLOBAL_OFFSET_TABLE_ - 167166,
      559,
      (int)&GLOBAL_OFFSET_TABLE_ - 166016);
  v23 = (_BYTE *)*a3;
  if ( (unsigned int)a4 <= *a3 )
    goto LABEL_36;
  if ( (v21 & 4) == 0 )
  {
    v35 = *v20;
    while ( 1 )
    {
      ++v23;
      ++v22;
      *a3 = v23;
      *((_BYTE *)v20 + v22 + 3) = *(v23 - 1);
      if ( a4 == v23 )
        break;
      if ( v22 == 4 )
        goto LABEL_37;
    }
    v21 = v35;
LABEL_36:
    if ( v22 <= 3 )
    {
      *v20 = v21 & 0xFFFFFFF8 | v22;
      return 7;
    }
  }
LABEL_37:
  v9 += 4;
  *(v9 - 4) = *((_BYTE *)v20 + 4);
  *(v9 - 3) = *((_BYTE *)v20 + 5);
  *(v9 - 2) = *((_BYTE *)v20 + 6);
  *(v9 - 1) = *((_BYTE *)v20 + 7);
  *v20 &= 0xFFFFFFF8;
LABEL_8:
  for ( i = v9; ; i = *(_BYTE **)a2 )
  {
    v11 = (_BYTE *)*a3;
    v12 = &a4[-*a3];
    if ( (int)(v30 - (_DWORD)i) <= (int)v12 )
      v12 = (_BYTE *)(v30 - (_DWORD)i);
    v13 = (unsigned int)(v12 + 3);
    if ( (int)v12 >= 0 )
      v13 = (unsigned int)v12;
    v14 = v13 & 0xFFFFFFFC;
    *a3 = &v11[v14];
    v15 = 4;
    v16 = mempcpy(i, v11, v14);
    if ( a4 != (_BYTE *)*a3 )
      v15 = v30 < (unsigned int)(v16 + 2) ? 5 : 7;
    if ( a5 )
    {
      *a5 = v16;
      return v15;
    }
    ++*(_DWORD *)(a2 + 12);
    if ( (*(_BYTE *)(a2 + 8) & 1) != 0 )
    {
      v18 = a3;
      *(_DWORD *)a2 = v16;
      goto LABEL_25;
    }
    v31 = v16;
    if ( v16 <= (_WORD *)i )
      goto LABEL_24;
    v36[0] = *(_DWORD *)a2;
    dl_mcount_wrapper_check((int)v32);
    v17 = v32(v33, v34, v36, v31, 0, a6, 0, a8);
    if ( v17 != 4 )
      break;
    if ( v15 != 5 )
    {
LABEL_24:
      v18 = a3;
      goto LABEL_25;
    }
LABEL_22:
    ;
  }
  if ( (_WORD *)v36[0] != v31 )
    *a3 -= (char *)v31 - v36[0];
  if ( !v17 )
    goto LABEL_22;
  v18 = a3;
  v15 = v17;
LABEL_25:
  if ( v15 == 7 && a8 )
  {
    v25 = *v18;
    if ( (int)&a4[-*v18] > 3 )
      _assert_fail(
        (int)&GLOBAL_OFFSET_TABLE_ - 167126,
        (int)&GLOBAL_OFFSET_TABLE_ - 167166,
        777,
        (int)&GLOBAL_OFFSET_TABLE_ - 166016);
    v26 = *(unsigned int **)(a2 + 20);
    v27 = (_BYTE *)*v18;
    v28 = v26 + 1;
    if ( v25 >= (unsigned int)a4 )
    {
      v29 = 0;
    }
    else
    {
      do
      {
        ++v27;
        v28 = (_DWORD *)((char *)v28 + 1);
        *v18 = (unsigned int)v27;
        *((_BYTE *)v28 - 1) = *(v27 - 1);
      }
      while ( v27 != a4 );
      v29 = (unsigned int)&v27[-v25];
    }
    v15 = 7;
    *v26 = *v26 & 0xFFFFFFF8 | v29;
  }
  return v15;
}
// 80CE000: using guessed type _TBYTE GLOBAL_OFFSET_TABLE_;

//----- (08068BF0) --------------------------------------------------------
int __cdecl _gconv_transform_ucs4le_internal(
        int a1,
        _DWORD *a2,
        unsigned int *a3,
        unsigned int a4,
        _DWORD *a5,
        _DWORD *a6,
        int a7,
        int a8)
{
  int v8; // ebp
  _DWORD *v9; // eax
  _BYTE *v10; // eax
  int *v11; // eax
  unsigned int *v12; // ecx
  unsigned int v13; // ebx
  unsigned int v14; // edx
  unsigned int v15; // eax
  _DWORD *v16; // ebx
  int *v17; // eax
  signed int v18; // edx
  int v19; // esi
  int v20; // edx
  int v21; // ebp
  int v22; // esi
  int v24; // eax
  unsigned int *v25; // ecx
  unsigned int v26; // eax
  _DWORD *v27; // ebx
  unsigned int v28; // ebp
  unsigned int v29; // eax
  _DWORD *v30; // eax
  _BYTE *v31; // [esp+0h] [ebp-60h]
  unsigned int v32; // [esp+10h] [ebp-50h]
  int *v33; // [esp+14h] [ebp-4Ch]
  int (__cdecl *v34)(int, _DWORD *, int *, _DWORD *, _DWORD, _DWORD *, int, int); // [esp+1Ch] [ebp-44h]
  int v35; // [esp+20h] [ebp-40h]
  _DWORD *v36; // [esp+24h] [ebp-3Ch]
  int v37; // [esp+38h] [ebp-28h] BYREF
  int v38[9]; // [esp+3Ch] [ebp-24h] BYREF

  v8 = a2[2];
  v38[1] = __readgsdword(0x14u);
  v34 = 0;
  v35 = a1 + 60;
  v36 = a2 + 8;
  if ( (v8 & 1) == 0 )
  {
    v34 = *(int (__cdecl **)(int, _DWORD *, int *, _DWORD *, _DWORD, _DWORD *, int, int))(a1 + 80);
    if ( *(_DWORD *)(a1 + 60) )
      v34 = (int (__cdecl *)(int, _DWORD *, int *, _DWORD *, _DWORD, _DWORD *, int, int))(__readgsdword(0x18u) ^ __ROR4__(*(_DWORD *)(a1 + 80), 9));
  }
  if ( a7 )
  {
    if ( a5 )
      _assert_fail(
        (int)&GLOBAL_OFFSET_TABLE_ - 167146,
        (int)&GLOBAL_OFFSET_TABLE_ - 167166,
        415,
        (int)(&GLOBAL_OFFSET_TABLE_ - 16608));
    v30 = (_DWORD *)a2[5];
    v22 = 0;
    *v30 = 0;
    v30[1] = 0;
    if ( (a2[2] & 1) == 0 )
    {
      dl_mcount_wrapper_check((int)v34);
      return v34(v35, v36, 0, 0, 0, a6, a7, a8);
    }
    return v22;
  }
  v9 = a5;
  if ( !a5 )
    v9 = a2;
  v10 = (_BYTE *)*v9;
  v37 = 0;
  v31 = v10;
  v32 = a2[1];
  v11 = 0;
  if ( a6 )
    v11 = &v37;
  v33 = v11;
  if ( a8 )
  {
    v12 = (unsigned int *)a2[5];
    v13 = *v12;
    v14 = *v12 & 7;
    if ( v14 )
    {
      if ( a5 )
        _assert_fail(
          (int)&GLOBAL_OFFSET_TABLE_ - 167146,
          (int)&GLOBAL_OFFSET_TABLE_ - 167166,
          559,
          (int)(&GLOBAL_OFFSET_TABLE_ - 16608));
      v15 = *a3;
      if ( a4 > *a3 )
      {
        if ( (v13 & 4) != 0 )
          goto LABEL_18;
        while ( 1 )
        {
          ++v15;
          ++v14;
          *a3 = v15;
          *((_BYTE *)v12 + v14 + 3) = *(_BYTE *)(v15 - 1);
          if ( a4 == v15 )
            break;
          if ( v14 == 4 )
            goto LABEL_18;
        }
      }
      if ( v14 <= 3 )
      {
        v22 = 7;
        *v12 = v13 & 0xFFFFFFF8 | v14;
        return v22;
      }
LABEL_18:
      if ( *((_BYTE *)v12 + 7) > 0x80u )
      {
        if ( (v8 & 2) == 0 )
          return 6;
      }
      else
      {
        *v31 = *((_BYTE *)v12 + 4);
        v31[1] = *((_BYTE *)v12 + 5);
        v31[2] = *((_BYTE *)v12 + 6);
        v31[3] = *((_BYTE *)v12 + 7);
        v31 += 4;
        v13 = *v12;
      }
      v8 = a2[2];
      *v12 = v13 & 0xFFFFFFF8;
      goto LABEL_21;
    }
  }
  while ( 1 )
  {
LABEL_21:
    v16 = v31;
    v17 = (int *)*a3;
    v18 = a4 - *a3;
    if ( (int)(v32 - (_DWORD)v31) <= v18 )
      v18 = v32 - (_DWORD)v31;
    v19 = v18 / 4;
    if ( v18 / 4 )
    {
      v20 = 0;
      v21 = v8 & 2;
      while ( 1 )
      {
        while ( *v17 >= 0 )
        {
          ++v20;
          *v16++ = *v17++;
          if ( v19 == v20 )
            goto LABEL_30;
        }
        if ( !v33 )
          break;
        if ( !v21 )
        {
          *a3 = (unsigned int)v17;
          v22 = 6;
          goto LABEL_37;
        }
        ++v20;
        ++*v33;
        ++v17;
        if ( v19 == v20 )
          goto LABEL_30;
      }
      v16 = v31;
      v22 = 6;
LABEL_37:
      if ( a5 )
        goto LABEL_34;
      goto LABEL_38;
    }
    v16 = v31;
LABEL_30:
    *a3 = (unsigned int)v17;
    if ( v17 == (int *)a4 )
    {
      v22 = 4;
      goto LABEL_37;
    }
    if ( a4 < (unsigned int)(v17 + 1) )
    {
      v22 = 7;
      goto LABEL_37;
    }
    if ( v32 >= (unsigned int)(v16 + 1) )
      _assert_fail(
        (int)&GLOBAL_OFFSET_TABLE_ - 167091,
        (int)&GLOBAL_OFFSET_TABLE_ - 167106,
        660,
        (int)&GLOBAL_OFFSET_TABLE_ - 166628);
    v22 = 5;
    if ( a5 )
    {
LABEL_34:
      *a5 = v16;
      return v22;
    }
LABEL_38:
    ++a2[3];
    if ( (a2[2] & 1) != 0 )
    {
      *a2 = v16;
      *a6 += v37;
      goto LABEL_46;
    }
    if ( v31 >= (_BYTE *)v16 )
      goto LABEL_46;
    v38[0] = *a2;
    dl_mcount_wrapper_check((int)v34);
    v24 = v34(v35, v36, v38, v16, 0, a6, 0, a8);
    if ( v24 != 4 )
      break;
    if ( v22 != 5 )
      goto LABEL_46;
LABEL_44:
    v8 = a2[2];
    v31 = (_BYTE *)*a2;
  }
  if ( (_DWORD *)v38[0] != v16 )
    *a3 -= (unsigned int)v16 - v38[0];
  if ( !v24 )
    goto LABEL_44;
  v22 = v24;
LABEL_46:
  if ( a8 && v22 == 7 )
  {
    if ( (int)(a4 - *a3) > 3 )
      _assert_fail(
        (int)&GLOBAL_OFFSET_TABLE_ - 167126,
        (int)&GLOBAL_OFFSET_TABLE_ - 167166,
        777,
        (int)(&GLOBAL_OFFSET_TABLE_ - 16608));
    v25 = (unsigned int *)a2[5];
    v26 = *a3;
    v27 = v25 + 1;
    if ( *a3 >= a4 )
    {
      v29 = 0;
    }
    else
    {
      v28 = *a3;
      do
      {
        ++v26;
        v27 = (_DWORD *)((char *)v27 + 1);
        *a3 = v26;
        *((_BYTE *)v27 - 1) = *(_BYTE *)(v26 - 1);
      }
      while ( v26 != a4 );
      v29 = v26 - v28;
    }
    *v25 = *v25 & 0xFFFFFFF8 | v29;
  }
  return v22;
}
// 80CE000: using guessed type _TBYTE GLOBAL_OFFSET_TABLE_;

//----- (080690C0) --------------------------------------------------------
int __cdecl _gconv_transform_ascii_internal(
        int a1,
        _DWORD *a2,
        unsigned __int8 **a3,
        unsigned __int8 *a4,
        _DWORD *a5,
        _DWORD *a6,
        int a7,
        int a8)
{
  int v8; // edx
  _DWORD *v9; // eax
  _DWORD *v10; // eax
  _DWORD *v11; // ebx
  int *v12; // eax
  unsigned __int8 *v13; // ecx
  _DWORD *v14; // esi
  unsigned __int8 *v15; // eax
  int v16; // edx
  int v17; // eax
  _DWORD *v19; // eax
  unsigned int v20; // [esp+0h] [ebp-58h]
  _DWORD *v21; // [esp+4h] [ebp-54h]
  int v22; // [esp+8h] [ebp-50h]
  int v23; // [esp+14h] [ebp-44h]
  int (__cdecl *v24)(int, _DWORD *, int *, _DWORD *, _DWORD, _DWORD *, int, int); // [esp+1Ch] [ebp-3Ch]
  int v25; // [esp+20h] [ebp-38h]
  _DWORD *v26; // [esp+24h] [ebp-34h]
  int *v27; // [esp+28h] [ebp-30h]
  int v28; // [esp+30h] [ebp-28h] BYREF
  int v29[9]; // [esp+34h] [ebp-24h] BYREF

  v8 = a2[2];
  v29[1] = __readgsdword(0x14u);
  v24 = 0;
  v25 = a1 + 60;
  v26 = a2 + 8;
  if ( (v8 & 1) == 0 )
  {
    v24 = *(int (__cdecl **)(int, _DWORD *, int *, _DWORD *, _DWORD, _DWORD *, int, int))(a1 + 80);
    if ( *(_DWORD *)(a1 + 60) )
      v24 = (int (__cdecl *)(int, _DWORD *, int *, _DWORD *, _DWORD, _DWORD *, int, int))(__readgsdword(0x18u) ^ __ROR4__(*(_DWORD *)(a1 + 80), 9));
  }
  if ( a7 )
  {
    if ( a5 )
      _assert_fail((int)"outbufstart == NULL", (int)"../iconv/skeleton.c", 415, (int)"__gconv_transform_ascii_internal");
    v19 = (_DWORD *)a2[5];
    v22 = 0;
    *v19 = 0;
    v19[1] = 0;
    if ( (a2[2] & 1) == 0 )
    {
      dl_mcount_wrapper_check((int)v24);
      return v24(v25, v26, 0, 0, 0, a6, a7, a8);
    }
  }
  else
  {
    v9 = a5;
    if ( !a5 )
      v9 = a2;
    v10 = (_DWORD *)*v9;
    v28 = 0;
    v21 = v10;
    v11 = v10;
    v20 = a2[1];
    v12 = 0;
    if ( a6 )
      v12 = &v28;
    v27 = v12;
    v13 = *a3;
    if ( a4 == *a3 )
      goto LABEL_26;
LABEL_10:
    v14 = v11 + 1;
    if ( (unsigned int)(v11 + 1) <= v20 )
    {
      v15 = v13;
      v22 = 4;
      v23 = v8 & 2;
      while ( 1 )
      {
        v16 = *v15;
        v13 = v15;
        if ( (v16 & 0x80u) == 0 )
        {
          ++v15;
          *v11 = v16;
          v11 = v14;
          v13 = v15;
          if ( a4 == v15 )
            goto LABEL_18;
        }
        else
        {
          if ( !v27 || !v23 )
          {
            v22 = 6;
            goto LABEL_18;
          }
          ++v15;
          ++*v27;
          v13 = v15;
          v22 = 6;
          if ( a4 == v15 )
            goto LABEL_18;
        }
        v14 = v11 + 1;
        if ( v20 < (unsigned int)(v11 + 1) )
        {
          v22 = 5;
          goto LABEL_18;
        }
      }
    }
    v11 = v21;
    v22 = 5;
LABEL_18:
    for ( *a3 = v13; !a5; *a3 = v13 )
    {
      ++a2[3];
      if ( (a2[2] & 1) != 0 )
      {
        *a2 = v11;
        *a6 += v28;
        return v22;
      }
      if ( v11 <= v21 )
        return v22;
      v29[0] = *a2;
      dl_mcount_wrapper_check((int)v24);
      v17 = v24(v25, v26, v29, v11, 0, a6, 0, a8);
      if ( v17 == 4 )
      {
        if ( v22 != 5 )
          return v22;
      }
      else
      {
        if ( v11 != (_DWORD *)v29[0] )
          *a3 -= ((int)v11 - v29[0]) / 4;
        if ( v17 )
          return v17;
      }
      v8 = a2[2];
      v21 = (_DWORD *)*a2;
      v11 = (_DWORD *)*a2;
      v13 = *a3;
      if ( a4 != *a3 )
        goto LABEL_10;
LABEL_26:
      v22 = 4;
    }
    *a5 = v11;
  }
  return v22;
}

//----- (080693E0) --------------------------------------------------------
int __cdecl _gconv_transform_internal_ascii(
        _DWORD *a1,
        _DWORD *a2,
        int *a3,
        unsigned int a4,
        _DWORD *a5,
        _DWORD *a6,
        int a7,
        int a8)
{
  int v8; // ebp
  _DWORD *v9; // edx
  unsigned int *v10; // eax
  _BYTE *v11; // ebx
  int *v12; // ebx
  int v13; // edx
  unsigned int v14; // edi
  unsigned int v15; // ebp
  _BYTE *v16; // ebx
  unsigned int v17; // edx
  int v18; // eax
  unsigned int *v20; // ebx
  int i; // edx
  unsigned int *v22; // edx
  unsigned int v23; // ebx
  unsigned int *v24; // eax
  int v25; // eax
  int v26; // ebp
  int v27; // edi
  int v28; // eax
  unsigned int v29; // ebp
  unsigned int *v30; // ebx
  int v31; // eax
  _BYTE *v32; // edx
  _DWORD *v33; // eax
  unsigned int *v34; // eax
  char *v35; // ebx
  unsigned int *v36; // ecx
  unsigned int *v37; // eax
  signed int v38; // eax
  _DWORD *v39; // eax
  unsigned int v40; // eax
  unsigned int v41; // [esp+0h] [ebp-80h]
  int v42; // [esp+4h] [ebp-7Ch]
  int v43; // [esp+4h] [ebp-7Ch]
  int v44; // [esp+14h] [ebp-6Ch]
  unsigned int v45; // [esp+14h] [ebp-6Ch]
  int (__cdecl *v46)(_DWORD *, _DWORD *, int *, _BYTE *, _DWORD, _DWORD *, int, int); // [esp+18h] [ebp-68h]
  _DWORD *v47; // [esp+1Ch] [ebp-64h]
  _DWORD *v48; // [esp+20h] [ebp-60h]
  int *v49; // [esp+24h] [ebp-5Ch]
  _BYTE *v50; // [esp+28h] [ebp-58h]
  unsigned int v51; // [esp+34h] [ebp-4Ch]
  int *v52; // [esp+34h] [ebp-4Ch]
  unsigned int *v53; // [esp+3Ch] [ebp-44h]
  int v54; // [esp+50h] [ebp-30h] BYREF
  unsigned int *v55; // [esp+54h] [ebp-2Ch] BYREF
  int v56; // [esp+58h] [ebp-28h] BYREF
  unsigned int v57; // [esp+5Ch] [ebp-24h] BYREF
  int v58[8]; // [esp+60h] [ebp-20h] BYREF

  v8 = a2[2];
  v58[0] = __readgsdword(0x14u);
  v46 = 0;
  v47 = a1 + 15;
  v48 = a2 + 8;
  if ( (v8 & 1) == 0 )
  {
    v46 = (int (__cdecl *)(_DWORD *, _DWORD *, int *, _BYTE *, _DWORD, _DWORD *, int, int))a1[20];
    if ( a1[15] )
      v46 = (int (__cdecl *)(_DWORD *, _DWORD *, int *, _BYTE *, _DWORD, _DWORD *, int, int))(__readgsdword(0x18u) ^ __ROR4__(a1[20], 9));
  }
  if ( a7 )
  {
    if ( a5 )
      _assert_fail(
        (int)&GLOBAL_OFFSET_TABLE_ - 167146,
        (int)&GLOBAL_OFFSET_TABLE_ - 167166,
        415,
        (int)&GLOBAL_OFFSET_TABLE_ - 166208);
    v33 = (_DWORD *)a2[5];
    v42 = 0;
    *v33 = 0;
    v33[1] = 0;
    if ( (a2[2] & 1) == 0 )
    {
      dl_mcount_wrapper_check((int)v46);
      return v46(v47, v48, 0, 0, 0, a6, a7, a8);
    }
    return v42;
  }
  v9 = a5;
  v10 = (unsigned int *)*a3;
  if ( !a5 )
    v9 = a2;
  v11 = (_BYTE *)*v9;
  v54 = 0;
  v50 = v11;
  v41 = a2[1];
  v12 = 0;
  if ( a6 )
    v12 = &v54;
  v49 = v12;
  if ( !a8 || (v20 = (unsigned int *)a2[5], v51 = *v20, (v43 = *v20 & 7) == 0) )
  {
    LOBYTE(v13) = v8;
    v14 = a4;
    v15 = (unsigned int)v50;
    goto LABEL_11;
  }
  if ( a5 )
    _assert_fail(
      (int)&GLOBAL_OFFSET_TABLE_ - 167146,
      (int)&GLOBAL_OFFSET_TABLE_ - 167166,
      559,
      (int)&GLOBAL_OFFSET_TABLE_ - 166208);
  v55 = v10;
  v56 = (int)v50;
  if ( (unsigned int)v43 > 4 )
    _assert_fail(
      (int)&GLOBAL_OFFSET_TABLE_ - 167008,
      (int)&GLOBAL_OFFSET_TABLE_ - 167069,
      395,
      (int)&GLOBAL_OFFSET_TABLE_ - 166656);
  for ( i = 0; i != v43; ++i )
    *((_BYTE *)&v58[-1] + i) = *((_BYTE *)v20 + i + 4);
  if ( a4 < (unsigned int)v10 + 4 - v43 )
  {
    *a3 = a4;
    if ( (unsigned int)v10 < a4 )
    {
      v34 = (unsigned int *)((char *)v10 + 1);
      v35 = (char *)v20 + v43;
      while ( 1 )
      {
        v55 = v34;
        (++v35)[3] = *((_BYTE *)v34 - 1);
        if ( (unsigned int *)a4 == v34 )
          break;
        v34 = (unsigned int *)((char *)v34 + 1);
      }
    }
    return 7;
  }
  v22 = v10;
  if ( (unsigned int)v50 >= v41 )
    return 5;
  v14 = a4;
  v53 = v20;
  v23 = v43;
  do
  {
    v22 = (unsigned int *)((char *)v22 + 1);
    ++v23;
    v55 = v22;
    *((_BYTE *)&v56 + v23 + 3) = *((_BYTE *)v22 - 1);
  }
  while ( v23 <= 3 && a4 > (unsigned int)v22 );
  v55 = &v57;
  if ( v57 > 0x7F )
  {
    if ( v57 >> 7 == 7168 )
    {
      v55 = (unsigned int *)v58;
      v25 = 4;
      goto LABEL_50;
    }
    if ( !v49 )
      return 6;
    if ( (v8 & 8) == 0 )
    {
      v42 = 6;
      v37 = &v57;
      if ( (v8 & 2) == 0 )
        return v42;
      goto LABEL_89;
    }
    v52 = (int *)((char *)&v58[-1] + v23);
    v42 = _gconv_transliterate(a1, (int)a2, (int)v10, &v55, (unsigned int)&v58[-1] + v23, &v56, v49);
    v36 = &v57;
    v37 = v55;
    if ( v42 == 6 )
    {
      if ( (v8 & 2) == 0 )
      {
LABEL_90:
        if ( v37 != &v57 )
          goto LABEL_91;
        return 6;
      }
LABEL_89:
      v55 = ++v37;
      ++*v49;
      goto LABEL_90;
    }
    if ( v55 != &v57 )
    {
LABEL_91:
      v25 = (char *)v37 - (char *)&v57;
      v51 = *v53;
      v43 = *v53 & 7;
      goto LABEL_50;
    }
    if ( v42 != 7 )
    {
      if ( v42 )
        return v42;
      goto LABEL_70;
    }
    if ( v52 == v58 )
      _assert_fail(
        (int)(&GLOBAL_OFFSET_TABLE_ - 16692),
        (int)&GLOBAL_OFFSET_TABLE_ - 167069,
        475,
        (int)&GLOBAL_OFFSET_TABLE_ - 166656);
    v38 = *v53 & 0xFFFFFFF8;
    *a3 += v23 - (*v53 & 7);
    if ( v38 >= (int)v23 )
      _assert_fail(
        (int)&GLOBAL_OFFSET_TABLE_ - 166884,
        (int)&GLOBAL_OFFSET_TABLE_ - 167069,
        485,
        (int)&GLOBAL_OFFSET_TABLE_ - 166656);
    if ( v23 > 4 )
      _assert_fail(
        (int)&GLOBAL_OFFSET_TABLE_ - 166844,
        (int)&GLOBAL_OFFSET_TABLE_ - 167069,
        486,
        (int)&GLOBAL_OFFSET_TABLE_ - 166656);
    *v53 = v23 | v38;
    if ( v52 > (int *)&v57 )
    {
      v39 = v53 + 1;
      do
      {
        v36 = (unsigned int *)((char *)v36 + 1);
        v39 = (_DWORD *)((char *)v39 + 1);
        v55 = v36;
        *((_BYTE *)v39 - 1) = *((_BYTE *)v36 - 1);
      }
      while ( v52 != (int *)v36 );
    }
    return 7;
  }
  v56 = (int)(v50 + 1);
  *v50 = v57;
  v24 = v55 + 1;
  v55 = v24;
  if ( v24 != &v57 )
  {
    v25 = (char *)v24 - (char *)&v57;
    v51 = *v53;
    v43 = *v53 & 7;
LABEL_50:
    if ( v25 <= v43 )
      _assert_fail(
        (int)(&GLOBAL_OFFSET_TABLE_ - 16696),
        (int)&GLOBAL_OFFSET_TABLE_ - 167069,
        457,
        (int)&GLOBAL_OFFSET_TABLE_ - 166656);
    v26 = a2[2];
    v10 = (unsigned int *)(*a3 + v25 - v43);
    *a3 = (int)v10;
    v27 = v56;
    *v53 = v51 & 0xFFFFFFF8;
    LOBYTE(v13) = v26;
    v15 = v27;
    v14 = a4;
    goto LABEL_11;
  }
LABEL_70:
  v13 = a2[2];
  v10 = (unsigned int *)*a3;
  v15 = (unsigned int)v50;
LABEL_11:
  while ( 2 )
  {
    v55 = v10;
    v16 = (_BYTE *)v15;
    v56 = v15;
    v42 = 4;
    v44 = v13 & 2;
    do
    {
      while ( 1 )
      {
        while ( 1 )
        {
          if ( (unsigned int *)v14 == v10 )
            goto LABEL_17;
          while ( 1 )
          {
            if ( v14 < (unsigned int)(v10 + 1) )
            {
              v42 = 7;
              *a3 = (int)v10;
              if ( !a5 )
                goto LABEL_18;
              goto LABEL_26;
            }
            if ( v41 <= (unsigned int)v16 )
            {
              v42 = 5;
              goto LABEL_17;
            }
            v17 = *v10;
            if ( *v10 > 0x7F )
              break;
            v56 = (int)(v16 + 1);
            *v16 = v17;
            v16 = (_BYTE *)v56;
            v10 = v55 + 1;
            v55 = v10;
            if ( (unsigned int *)v14 == v10 )
              goto LABEL_17;
          }
          if ( v17 >> 7 != 7168 )
            break;
          v55 = ++v10;
        }
        if ( !v49 )
          goto LABEL_33;
        if ( (a2[2] & 8) != 0 )
        {
          v42 = _gconv_transliterate(a1, (int)a2, *a3, &v55, v14, &v56, v49);
          v16 = (_BYTE *)v56;
          v10 = v55;
          if ( v42 != 6 )
            break;
        }
        if ( !v44 )
        {
LABEL_33:
          v42 = 6;
          goto LABEL_17;
        }
        ++v10;
        v42 = 6;
        v55 = v10;
        ++*v49;
      }
    }
    while ( v42 != 5 );
LABEL_17:
    *a3 = (int)v10;
    if ( a5 )
    {
LABEL_26:
      *a5 = v16;
      return v42;
    }
LABEL_18:
    ++a2[3];
    if ( (a2[2] & 1) != 0 )
    {
      v28 = v54;
      *a2 = v16;
      v45 = v14;
      *a6 += v28;
    }
    else
    {
      if ( v15 >= (unsigned int)v16 )
      {
        v18 = v42;
        goto LABEL_23;
      }
      v56 = *a2;
      dl_mcount_wrapper_check((int)v46);
      v18 = v46(v47, v48, &v56, v16, 0, a6, 0, a8);
      if ( v18 == 4 )
      {
        v18 = v42;
        if ( v42 == 5 || !v42 )
          goto LABEL_24;
      }
      else
      {
        if ( (_BYTE *)v56 != v16 )
          *a3 -= 4 * (_DWORD)&v16[-v56];
LABEL_23:
        if ( !v18 )
        {
LABEL_24:
          v13 = a2[2];
          v15 = *a2;
          v10 = (unsigned int *)*a3;
          continue;
        }
      }
      v45 = v14;
      v42 = v18;
    }
    break;
  }
  if ( v42 == 7 && a8 )
  {
    v29 = *a3;
    if ( (int)(v45 - *a3) > 3 )
      _assert_fail(
        (int)&GLOBAL_OFFSET_TABLE_ - 167126,
        (int)&GLOBAL_OFFSET_TABLE_ - 167166,
        777,
        (int)&GLOBAL_OFFSET_TABLE_ - 166208);
    v30 = (unsigned int *)a2[5];
    v31 = v29 + 1;
    v32 = v30 + 1;
    if ( v29 >= v45 )
    {
      v40 = 0;
    }
    else
    {
      while ( 1 )
      {
        *a3 = v31;
        *v32++ = *(_BYTE *)(v31 - 1);
        if ( v31 == v45 )
          break;
        ++v31;
      }
      v40 = v31 - v29;
    }
    *v30 = *v30 & 0xFFFFFFF8 | v40;
  }
  return v42;
}
// 80696DB: conditional instruction was optimized away because %var_7C.4 is in (1..4)
// 80CE000: using guessed type _TBYTE GLOBAL_OFFSET_TABLE_;

//----- (08069C40) --------------------------------------------------------
int __cdecl _gconv_transform_internal_utf8(
        _DWORD *a1,
        _DWORD *a2,
        int *a3,
        unsigned int a4,
        _DWORD *a5,
        _DWORD *a6,
        int a7,
        int a8)
{
  int v8; // esi
  _DWORD *v9; // eax
  _BYTE *v10; // eax
  int *v11; // eax
  unsigned int *v12; // eax
  _BYTE *v13; // ebx
  int v14; // edx
  int v15; // esi
  unsigned int v16; // edx
  int v18; // ecx
  char v19; // al
  unsigned int v20; // edx
  unsigned int v21; // ebx
  int v22; // eax
  int v23; // eax
  unsigned int *v24; // eax
  unsigned int v25; // edx
  unsigned int *v26; // eax
  int v27; // eax
  int v28; // edx
  int v29; // ecx
  int v30; // eax
  int v31; // eax
  unsigned int v32; // esi
  unsigned int *v33; // ebx
  int v34; // eax
  _BYTE *v35; // edx
  unsigned int *v36; // eax
  _BYTE *v37; // ebx
  int v38; // esi
  _DWORD *v39; // eax
  int v40; // ecx
  char v41; // al
  unsigned int *v42; // eax
  char *v43; // edx
  unsigned int *v44; // ecx
  signed int v45; // eax
  int v46; // ebx
  unsigned int *v47; // eax
  _DWORD *v48; // ebp
  int v49; // ecx
  char v50; // al
  unsigned int v51; // eax
  unsigned int v52; // [esp+Ch] [ebp-7Ch]
  _BYTE *v53; // [esp+10h] [ebp-78h]
  int v54; // [esp+14h] [ebp-74h]
  int v55; // [esp+14h] [ebp-74h]
  unsigned int *v56; // [esp+1Ch] [ebp-6Ch]
  int v57; // [esp+1Ch] [ebp-6Ch]
  _DWORD *v58; // [esp+20h] [ebp-68h]
  int v59; // [esp+20h] [ebp-68h]
  int (__cdecl *v60)(_DWORD *, _DWORD *, _BYTE **, _BYTE *, _DWORD, _DWORD *, int, int); // [esp+2Ch] [ebp-5Ch]
  _DWORD *v61; // [esp+30h] [ebp-58h]
  _DWORD *v62; // [esp+34h] [ebp-54h]
  int *v63; // [esp+3Ch] [ebp-4Ch]
  int v64; // [esp+44h] [ebp-44h]
  unsigned int v65; // [esp+48h] [ebp-40h]
  int v66; // [esp+54h] [ebp-34h] BYREF
  _BYTE *v67; // [esp+58h] [ebp-30h] BYREF
  unsigned int *v68; // [esp+5Ch] [ebp-2Ch] BYREF
  _BYTE *v69; // [esp+60h] [ebp-28h] BYREF
  unsigned int v70; // [esp+64h] [ebp-24h] BYREF
  unsigned int v71; // [esp+68h] [ebp-20h] BYREF

  v71 = __readgsdword(0x14u);
  v60 = 0;
  v61 = a1 + 15;
  v62 = a2 + 8;
  v8 = a2[2];
  if ( (v8 & 1) == 0 )
  {
    v60 = (int (__cdecl *)(_DWORD *, _DWORD *, _BYTE **, _BYTE *, _DWORD, _DWORD *, int, int))a1[20];
    if ( a1[15] )
      v60 = (int (__cdecl *)(_DWORD *, _DWORD *, _BYTE **, _BYTE *, _DWORD, _DWORD *, int, int))(__readgsdword(0x18u) ^ __ROR4__(a1[20], 9));
  }
  if ( a7 )
  {
    if ( a5 )
      _assert_fail(
        (int)&GLOBAL_OFFSET_TABLE_ - 167146,
        (int)&GLOBAL_OFFSET_TABLE_ - 167166,
        415,
        (int)(&GLOBAL_OFFSET_TABLE_ - 16624));
    v39 = (_DWORD *)a2[5];
    v54 = 0;
    *v39 = 0;
    v39[1] = 0;
    if ( (a2[2] & 1) == 0 )
    {
      dl_mcount_wrapper_check((int)v60);
      return v60(v61, v62, 0, 0, 0, a6, a7, a8);
    }
    return v54;
  }
  v56 = (unsigned int *)*a3;
  v9 = a5;
  if ( !a5 )
    v9 = a2;
  v10 = (_BYTE *)*v9;
  v66 = 0;
  v53 = v10;
  v52 = a2[1];
  v11 = 0;
  if ( a6 )
    v11 = &v66;
  v63 = v11;
  if ( !a8 )
    goto LABEL_10;
  v58 = (_DWORD *)a2[5];
  v55 = *v58;
  v20 = *v58 & 7;
  if ( (*v58 & 7) == 0 )
    goto LABEL_10;
  if ( a5 )
    _assert_fail(
      (int)&GLOBAL_OFFSET_TABLE_ - 167146,
      (int)&GLOBAL_OFFSET_TABLE_ - 167166,
      559,
      (int)(&GLOBAL_OFFSET_TABLE_ - 16624));
  v21 = *v58 & 7;
  v68 = v56;
  v69 = v53;
  if ( v20 > 4 )
    _assert_fail(
      (int)&GLOBAL_OFFSET_TABLE_ - 167008,
      (int)&GLOBAL_OFFSET_TABLE_ - 167069,
      395,
      (int)&GLOBAL_OFFSET_TABLE_ - 166684);
  v22 = 0;
  if ( (v55 & 7) != 0 )
  {
    do
    {
      *((_BYTE *)&v70 + v22) = *((_BYTE *)v58 + v22 + 4);
      ++v22;
    }
    while ( v20 != v22 );
    v21 = v55 & 7;
    v23 = 4 - v20;
  }
  else
  {
    v23 = 4;
  }
  if ( a4 < (unsigned int)v56 + v23 )
  {
    *a3 = a4;
    if ( (unsigned int)v56 < a4 )
    {
      v42 = (unsigned int *)((char *)v56 + 1);
      v43 = (char *)v58 + v20;
      while ( 1 )
      {
        v68 = v42;
        (++v43)[3] = *((_BYTE *)v42 - 1);
        if ( (unsigned int *)a4 == v42 )
          break;
        v42 = (unsigned int *)((char *)v42 + 1);
      }
    }
    return 7;
  }
  if ( (unsigned int)v53 >= v52 )
    return 5;
  v24 = v56;
  do
  {
    v24 = (unsigned int *)((char *)v24 + 1);
    ++v21;
    v68 = v24;
    *((_BYTE *)&v69 + v21 + 3) = *((_BYTE *)v24 - 1);
  }
  while ( v21 <= 3 && a4 > (unsigned int)v24 );
  v25 = v70;
  v68 = &v70;
  if ( v70 <= 0x7F )
  {
    v69 = v53 + 1;
    *v53 = v70;
    goto LABEL_53;
  }
  if ( v70 - 55296 <= 0x7FF || (v70 & 0x80000000) != 0 )
  {
    if ( !v63 )
      return 6;
    if ( (v8 & 8) == 0 )
    {
      v54 = 6;
      if ( (v8 & 2) == 0 )
        return v54;
      goto LABEL_146;
    }
    v54 = _gconv_transliterate(a1, (int)a2, (int)v56, &v68, (unsigned int)&v70 + v21, (int *)&v69, v63);
    v44 = (unsigned int *)((char *)&v70 + v21);
    if ( v54 == 6 )
    {
      if ( (v8 & 2) == 0 )
      {
LABEL_147:
        v26 = v68;
        if ( v68 != &v70 )
          goto LABEL_54;
        return 6;
      }
LABEL_146:
      ++v68;
      ++*v63;
      goto LABEL_147;
    }
    v26 = v68;
    if ( v68 != &v70 )
      goto LABEL_54;
    if ( v54 != 7 )
    {
      if ( v54 )
        return v54;
      goto LABEL_108;
    }
    if ( (unsigned int *)((char *)&v70 + v21) == &v71 )
      _assert_fail(
        (int)(&GLOBAL_OFFSET_TABLE_ - 16692),
        (int)&GLOBAL_OFFSET_TABLE_ - 167069,
        475,
        (int)&GLOBAL_OFFSET_TABLE_ - 166684);
    v45 = *v58 & 0xFFFFFFF8;
    *a3 += v21 - (*v58 & 7);
    if ( (int)v21 <= v45 )
      _assert_fail(
        (int)&GLOBAL_OFFSET_TABLE_ - 166884,
        (int)&GLOBAL_OFFSET_TABLE_ - 167069,
        485,
        (int)&GLOBAL_OFFSET_TABLE_ - 166684);
    if ( v21 > 4 )
      _assert_fail(
        (int)&GLOBAL_OFFSET_TABLE_ - 166844,
        (int)&GLOBAL_OFFSET_TABLE_ - 167069,
        486,
        (int)&GLOBAL_OFFSET_TABLE_ - 166684);
    v46 = v45 | v21;
    v47 = &v70;
    *v58 = v46;
    if ( v44 > &v70 )
    {
      v48 = v58 + 1;
      do
      {
        v47 = (unsigned int *)((char *)v47 + 1);
        v48 = (_DWORD *)((char *)v48 + 1);
        v68 = v47;
        *((_BYTE *)v48 - 1) = *((_BYTE *)v47 - 1);
      }
      while ( v44 != v47 );
    }
    return 7;
  }
  if ( (v70 & 0xFFFFF800) != 0 )
  {
    if ( (v70 & 0xFFFF0000) != 0 )
    {
      if ( (v70 & 0xFFE00000) != 0 )
        v49 = ((v70 & 0xFC000000) != 0) + 5;
      else
        v49 = 4;
    }
    else
    {
      v49 = 3;
    }
  }
  else
  {
    v49 = 2;
  }
  if ( v52 < (unsigned int)&v53[v49] )
    return 5;
  *v53 = -256 >> v49;
  v69 += v49;
  do
  {
    v50 = v25;
    --v49;
    v25 >>= 6;
    v53[v49] = v50 & 0x3F | 0x80;
  }
  while ( v49 != 1 );
  *v53 |= v25;
LABEL_53:
  v26 = v68 + 1;
  v68 = v26;
  if ( v26 != &v70 )
  {
LABEL_54:
    v27 = (char *)v26 - (char *)&v70;
    v28 = *v58;
    v29 = *v58 & 7;
    if ( v27 <= v29 )
      _assert_fail(
        (int)(&GLOBAL_OFFSET_TABLE_ - 16696),
        (int)&GLOBAL_OFFSET_TABLE_ - 167069,
        457,
        (int)&GLOBAL_OFFSET_TABLE_ - 166684);
    v30 = *a3 + v27 - v29;
    *a3 = v30;
    v8 = a2[2];
    v56 = (unsigned int *)v30;
    v53 = v69;
    *v58 = v28 & 0xFFFFFFF8;
    goto LABEL_10;
  }
LABEL_108:
  v8 = a2[2];
  v56 = (unsigned int *)*a3;
LABEL_10:
  while ( 2 )
  {
    v12 = v56;
    v54 = 4;
    v68 = v56;
    v13 = v53;
    v69 = v53;
LABEL_11:
    if ( (unsigned int *)a4 == v12 )
      goto LABEL_17;
    while ( a4 >= (unsigned int)(v12 + 1) )
    {
      if ( v52 <= (unsigned int)v13 )
        goto LABEL_27;
      v14 = *v12;
      if ( *v12 > 0x7F )
      {
        if ( (unsigned int)(v14 - 55296) <= 0x7FF || v14 < 0 )
        {
          if ( !v63 )
            goto LABEL_76;
          if ( (a2[2] & 8) == 0
            || (v54 = _gconv_transliterate(a1, (int)a2, *a3, &v68, a4, (int *)&v69, v63), v13 = v69, v12 = v68, v54 == 6) )
          {
            if ( (v8 & 2) != 0 )
            {
              ++v12;
              v54 = 6;
              v68 = v12;
              ++*v63;
              goto LABEL_11;
            }
LABEL_76:
            v54 = 6;
            goto LABEL_17;
          }
          if ( v54 == 5 )
          {
LABEL_17:
            *a3 = (int)v12;
            if ( !a5 )
              goto LABEL_18;
LABEL_25:
            *a5 = v13;
            return v54;
          }
          goto LABEL_11;
        }
        if ( (v14 & 0xFFFFF800) != 0 )
        {
          if ( (v14 & 0xFFFF0000) != 0 )
          {
            if ( (v14 & 0xFFE00000) != 0 )
              v18 = ((v14 & 0xFC000000) != 0) + 5;
            else
              v18 = 4;
          }
          else
          {
            v18 = 3;
          }
        }
        else
        {
          v18 = 2;
        }
        if ( v52 < (unsigned int)&v13[v18] )
        {
LABEL_27:
          v54 = 5;
          goto LABEL_17;
        }
        *v13 = -256 >> v18;
        v69 += v18;
        do
        {
          v19 = v14;
          --v18;
          v14 = (unsigned int)v14 >> 6;
          v13[v18] = v19 & 0x3F | 0x80;
        }
        while ( v18 != 1 );
        *v13 |= v14;
      }
      else
      {
        v69 = v13 + 1;
        *v13 = v14;
      }
      v13 = v69;
      v12 = v68 + 1;
      v68 = v12;
      if ( (unsigned int *)a4 == v12 )
        goto LABEL_17;
    }
    v54 = 7;
    *a3 = (int)v12;
    if ( a5 )
      goto LABEL_25;
LABEL_18:
    ++a2[3];
    if ( (a2[2] & 1) != 0 )
    {
      v31 = v66;
      *a2 = v13;
      *a6 += v31;
      goto LABEL_57;
    }
    if ( v53 >= v13 )
    {
      v15 = v54;
      goto LABEL_22;
    }
    v67 = (_BYTE *)*a2;
    dl_mcount_wrapper_check((int)v60);
    v15 = v60(v61, v62, &v67, v13, 0, a6, 0, a8);
    if ( v15 == 4 )
    {
      v15 = v54;
      if ( v54 != 5 )
        goto LABEL_22;
      goto LABEL_23;
    }
    v16 = (unsigned int)v67;
    if ( v67 == v13 )
      goto LABEL_22;
    v36 = v56;
    v59 = v15;
    *a3 = (int)v56;
    v68 = v56;
    v69 = v53;
    v37 = v53;
    v64 = a2[2] & 2;
    do
    {
LABEL_65:
      if ( (unsigned int *)a4 == v36 )
      {
LABEL_71:
        *a3 = a4;
        if ( v67 != v37 )
          goto LABEL_81;
        goto LABEL_72;
      }
      while ( 1 )
      {
        if ( a4 < (unsigned int)(v36 + 1) )
          goto LABEL_80;
        if ( v16 <= (unsigned int)v37 )
          goto LABEL_84;
        v38 = *v36;
        if ( *v36 <= 0x7F )
        {
          v69 = v37 + 1;
          *v37 = v38;
          goto LABEL_70;
        }
        if ( (unsigned int)(v38 - 55296) <= 0x7FF || v38 < 0 )
          break;
        if ( (v38 & 0xFFFFF800) != 0 )
        {
          if ( (v38 & 0xFFFF0000) != 0 )
          {
            if ( (v38 & 0xFFE00000) != 0 )
              v40 = ((v38 & 0xFC000000) != 0) + 5;
            else
              v40 = 4;
          }
          else
          {
            v40 = 3;
          }
        }
        else
        {
          v40 = 2;
        }
        if ( v16 < (unsigned int)&v37[v40] )
          goto LABEL_84;
        *v37 = -256 >> v40;
        v69 += v40;
        do
        {
          v41 = v38;
          --v40;
          v38 = (unsigned int)v38 >> 6;
          v37[v40] = v41 & 0x3F | 0x80;
        }
        while ( v40 != 1 );
        *v37 |= v38;
LABEL_70:
        v37 = v69;
        v36 = v68 + 1;
        v68 = v36;
        if ( (unsigned int *)a4 == v36 )
          goto LABEL_71;
      }
      if ( !v63 )
        goto LABEL_80;
      if ( (a2[2] & 8) != 0 )
      {
        v65 = v16;
        v57 = _gconv_transliterate(a1, (int)a2, *a3, &v68, a4, (int *)&v69, v63);
        v16 = v65;
        v36 = v68;
        v37 = v69;
        if ( v57 != 6 )
          continue;
      }
      if ( !v64 )
      {
LABEL_80:
        *a3 = (int)v36;
        if ( v37 != v67 )
          goto LABEL_81;
LABEL_72:
        _assert_fail(
          (int)(&GLOBAL_OFFSET_TABLE_ - 16680),
          (int)&GLOBAL_OFFSET_TABLE_ - 167166,
          728,
          (int)(&GLOBAL_OFFSET_TABLE_ - 16624));
      }
      v68 = ++v36;
      ++*v63;
      goto LABEL_65;
    }
    while ( v57 != 5 );
LABEL_84:
    v15 = v59;
    *a3 = (int)v36;
    if ( v37 != v67 )
LABEL_81:
      _assert_fail(
        (int)&GLOBAL_OFFSET_TABLE_ - 167053,
        (int)&GLOBAL_OFFSET_TABLE_ - 167166,
        727,
        (int)(&GLOBAL_OFFSET_TABLE_ - 16624));
    if ( v53 == v67 )
      --a2[3];
LABEL_22:
    if ( !v15 )
    {
LABEL_23:
      v8 = a2[2];
      v56 = (unsigned int *)*a3;
      v53 = (_BYTE *)*a2;
      continue;
    }
    break;
  }
  v54 = v15;
LABEL_57:
  if ( a8 && v54 == 7 )
  {
    v32 = *a3;
    if ( (int)(a4 - *a3) > 3 )
      _assert_fail(
        (int)&GLOBAL_OFFSET_TABLE_ - 167126,
        (int)&GLOBAL_OFFSET_TABLE_ - 167166,
        777,
        (int)(&GLOBAL_OFFSET_TABLE_ - 16624));
    v33 = (unsigned int *)a2[5];
    v34 = v32 + 1;
    v35 = v33 + 1;
    if ( v32 >= a4 )
    {
      v51 = 0;
    }
    else
    {
      while ( 1 )
      {
        *a3 = v34;
        *v35++ = *(_BYTE *)(v34 - 1);
        if ( v34 == a4 )
          break;
        ++v34;
      }
      v51 = v34 - v32;
    }
    *v33 = *v33 & 0xFFFFFFF8 | v51;
  }
  return v54;
}
// 806A187: conditional instruction was optimized away because %var_6C.4!=5
// 80CE000: using guessed type _TBYTE GLOBAL_OFFSET_TABLE_;

//----- (0806A7C0) --------------------------------------------------------
int __cdecl _gconv_transform_utf8_internal(
        int a1,
        unsigned int **a2,
        unsigned __int8 **a3,
        unsigned int a4,
        unsigned int **a5,
        _DWORD *a6,
        int a7,
        int a8)
{
  unsigned int *v8; // edi
  unsigned int **v9; // eax
  unsigned int *v10; // eax
  int *v11; // eax
  unsigned int *v12; // eax
  unsigned __int8 *v13; // edx
  unsigned int *v14; // edi
  unsigned int *v15; // ebp
  unsigned int v16; // eax
  unsigned int v17; // ecx
  int v18; // ebx
  unsigned __int8 v19; // cl
  int v20; // ebp
  unsigned int v21; // esi
  unsigned int *v23; // ebp
  unsigned __int8 *v24; // edi
  int v25; // edx
  int v26; // eax
  char v27; // cl
  int v28; // esi
  unsigned __int8 *v29; // edx
  char v30; // bl
  unsigned int v31; // eax
  unsigned int v32; // edx
  unsigned int v33; // ecx
  unsigned __int8 v34; // cl
  unsigned int v35; // edx
  unsigned __int8 v36; // cl
  int v37; // esi
  int v38; // eax
  unsigned __int8 *v39; // edx
  unsigned int *v40; // edi
  unsigned int v41; // ebp
  unsigned int *v42; // esi
  unsigned int v43; // eax
  unsigned int v44; // ecx
  int i; // ebx
  unsigned __int8 v46; // cl
  int v47; // eax
  unsigned int *v48; // ebx
  unsigned int *v49; // edi
  unsigned int *v50; // esi
  unsigned int *v51; // eax
  unsigned int v52; // ebx
  char v53; // al
  char *v54; // ebx
  char *v55; // edx
  int v56; // esi
  int v57; // ebx
  int v58; // edx
  char *v59; // edi
  char v60; // cl
  int v61; // eax
  _DWORD *v62; // esi
  unsigned int *v63; // [esp+4h] [ebp-88h]
  unsigned int v64; // [esp+4h] [ebp-88h]
  unsigned int *v65; // [esp+8h] [ebp-84h]
  int v66; // [esp+10h] [ebp-7Ch]
  unsigned int *v67; // [esp+10h] [ebp-7Ch]
  int v68; // [esp+10h] [ebp-7Ch]
  unsigned __int8 *v69; // [esp+18h] [ebp-74h]
  int v70; // [esp+18h] [ebp-74h]
  int v71; // [esp+1Ch] [ebp-70h]
  int v72; // [esp+1Ch] [ebp-70h]
  int v73; // [esp+1Ch] [ebp-70h]
  int v74; // [esp+28h] [ebp-64h]
  unsigned int *v75; // [esp+28h] [ebp-64h]
  unsigned int v76; // [esp+28h] [ebp-64h]
  int (__cdecl *v77)(int, unsigned int **, _WORD *, unsigned int *, _DWORD, _DWORD *, int, int); // [esp+2Ch] [ebp-60h]
  int v78; // [esp+30h] [ebp-5Ch]
  unsigned int **v79; // [esp+34h] [ebp-58h]
  int v80; // [esp+38h] [ebp-54h]
  int *v81; // [esp+3Ch] [ebp-50h]
  int *v82; // [esp+40h] [ebp-4Ch]
  int v83; // [esp+48h] [ebp-44h]
  unsigned int v84; // [esp+4Ch] [ebp-40h]
  int v85; // [esp+5Ch] [ebp-30h] BYREF
  _WORD v86[3]; // [esp+60h] [ebp-2Ch] BYREF
  unsigned __int8 v87; // [esp+66h] [ebp-26h] BYREF
  char v88; // [esp+67h] [ebp-25h] BYREF
  char v89; // [esp+68h] [ebp-24h] BYREF
  unsigned int v90; // [esp+6Ch] [ebp-20h] BYREF

  v90 = __readgsdword(0x14u);
  v77 = 0;
  v78 = a1 + 60;
  v79 = a2 + 8;
  v8 = a2[2];
  if ( ((unsigned __int8)v8 & 1) == 0 )
  {
    v77 = *(int (__cdecl **)(int, unsigned int **, _WORD *, unsigned int *, _DWORD, _DWORD *, int, int))(a1 + 80);
    if ( *(_DWORD *)(a1 + 60) )
      v77 = (int (__cdecl *)(int, unsigned int **, _WORD *, unsigned int *, _DWORD, _DWORD *, int, int))(__readgsdword(0x18u) ^ __ROR4__(*(_DWORD *)(a1 + 80), 9));
  }
  if ( a7 )
  {
    if ( a5 )
      _assert_fail(
        (int)&GLOBAL_OFFSET_TABLE_ - 167146,
        (int)&GLOBAL_OFFSET_TABLE_ - 167166,
        415,
        (int)&GLOBAL_OFFSET_TABLE_ - 166272);
    v66 = 0;
    v51 = a2[5];
    *v51 = 0;
    v51[1] = 0;
    if ( ((_BYTE)a2[2] & 1) == 0 )
    {
      dl_mcount_wrapper_check((int)v77);
      return v77(v78, v79, 0, 0, 0, a6, a7, a8);
    }
    return v66;
  }
  v69 = *a3;
  v9 = a5;
  if ( !a5 )
    v9 = a2;
  v10 = *v9;
  v85 = 0;
  v65 = v10;
  v63 = a2[1];
  v11 = 0;
  if ( a6 )
    v11 = &v85;
  v82 = v11;
  if ( !a8 || (v67 = a2[5], v31 = *v67, (v72 = *v67 & 7) == 0) )
  {
    LOBYTE(v12) = (_BYTE)v8;
    goto LABEL_11;
  }
  if ( a5 )
    _assert_fail(
      (int)&GLOBAL_OFFSET_TABLE_ - 167146,
      (int)&GLOBAL_OFFSET_TABLE_ - 167166,
      559,
      (int)&GLOBAL_OFFSET_TABLE_ - 166272);
  v31 = (unsigned __int8)v31;
  v32 = (int)*v67 >> 8;
  v33 = v67[1];
  v87 = *((_BYTE *)&GLOBAL_OFFSET_TABLE_ + v32 - 165890);
  do
  {
    if ( (unsigned __int8)v31 > --v32 )
      *(&v87 + v32) = v33 & 0x3F | 0x80;
    v33 >>= 6;
  }
  while ( v32 > 1 );
  v34 = v87 | v33;
  v75 = v65 + 1;
  if ( v63 < v65 + 1 )
    return 5;
  v87 = v34;
  v35 = (unsigned int)v69;
  do
    *((_BYTE *)&v86[2] + ++v31 + 1) = *(_BYTE *)v35++;
  while ( a4 > v35 && v31 <= 5 );
  v36 = v87;
  v80 = v87;
  if ( v87 > 0x7Fu )
  {
    v81 = (int *)(&v87 + v31);
    v84 = v87 - 194;
    if ( v84 > 0x1D )
    {
      if ( (v87 & 0xF0) == 0xE0 )
      {
        v83 = 3;
        v52 = v87 & 0xF;
      }
      else if ( (v87 & 0xF8) == 0xF0 )
      {
        v83 = 4;
        v52 = v87 & 7;
      }
      else if ( (v87 & 0xFC) == 0xF8 )
      {
        v83 = 5;
        v52 = v87 & 3;
      }
      else
      {
        if ( (v87 & 0xFE) != 0xFC )
        {
          v37 = 0;
          do
            ++v37;
          while ( v81 > (int *)(&v87 + v37) && (*(&v87 + v37) & 0xC0) == 0x80 && v37 != 5 );
          goto LABEL_125;
        }
        v83 = 6;
        v52 = v87 & 1;
      }
    }
    else
    {
      v83 = 2;
      v52 = v87 & 0x1F;
    }
    v37 = 1;
    if ( v81 >= (int *)(&v87 + v83) )
    {
      while ( 1 )
      {
        v53 = *(&v87 + v37);
        if ( (v53 & 0xC0) != 0x80 )
          goto LABEL_125;
        ++v37;
        v52 = v53 & 0x3F | (v52 << 6);
        if ( v83 == v37 )
        {
          if ( v83 != 2 )
          {
            if ( v52 >> (5 * v83 - 4) && v52 - 55296 > 0x7FF )
            {
              v37 = v83;
              *v65 = v52;
              v72 = *v67 & 7;
              goto LABEL_63;
            }
            goto LABEL_125;
          }
          if ( v52 - 55296 <= 0x7FF )
            goto LABEL_125;
          v37 = 2;
          *v65 = v52;
          v72 = *v67 & 7;
          goto LABEL_63;
        }
      }
    }
    if ( v81 > (int *)&v88 )
    {
      if ( (v88 & 0xC0) != 0x80 )
        goto LABEL_125;
      v54 = &v89;
      while ( 1 )
      {
        ++v37;
        v55 = v54;
        if ( v81 <= (int *)v54 )
          break;
        ++v54;
        if ( (*v55 & 0xC0) != 0x80 )
          goto LABEL_125;
      }
      if ( v81 != (int *)v54 )
        goto LABEL_125;
      if ( v81 == (int *)&v90 )
        _assert_fail(
          (int)(&GLOBAL_OFFSET_TABLE_ - 16692),
          (int)&GLOBAL_OFFSET_TABLE_ - 167069,
          475,
          (int)&GLOBAL_OFFSET_TABLE_ - 166712);
LABEL_152:
      *a3 = &v69[v31 - v72];
      *v67 = v31;
      if ( (unsigned int)(v80 - 192) <= 1 )
        _assert_fail(
          (int)&GLOBAL_OFFSET_TABLE_ - 167036,
          (int)&GLOBAL_OFFSET_TABLE_ - 167069,
          481,
          (int)&GLOBAL_OFFSET_TABLE_ - 166712);
      if ( v84 > 0x1D )
      {
        if ( (v36 & 0xF0) == 0xE0 )
        {
          v56 = 768;
          v57 = 2;
          v58 = v36 & 0xF;
        }
        else if ( (v36 & 0xF8) == 0xF0 )
        {
          v56 = 1024;
          v57 = 3;
          v58 = v36 & 7;
        }
        else if ( (v36 & 0xFC) == 0xF8 )
        {
          v58 = v36 & 3;
          v56 = 1280;
          v57 = 4;
        }
        else
        {
          v58 = v36 & 1;
          v56 = 1536;
          v57 = 5;
        }
      }
      else
      {
        v56 = 512;
        v57 = 1;
        v58 = v36 & 0x1F;
      }
      v59 = &v88;
      if ( v81 > (int *)&v88 )
      {
        do
        {
          v60 = *v59++;
          v58 = v60 & 0x3F | (v58 << 6);
        }
        while ( v81 != (int *)v59 );
        v57 += &v88 - (char *)v81;
      }
      v61 = v56 | v31;
      v62 = v67;
      v66 = 7;
      *v62 = v61;
      v62[1] = v58 << (6 * v57);
      return v66;
    }
    if ( v81 == (int *)&v88 )
      goto LABEL_152;
LABEL_125:
    if ( !v82 || ((unsigned __int8)v8 & 2) == 0 )
      return 6;
    ++*v82;
    v75 = v65;
    goto LABEL_63;
  }
  v37 = 1;
  *v65 = v87;
  v72 = *v67 & 7;
LABEL_63:
  if ( v37 <= v72 )
    _assert_fail(
      (int)(&GLOBAL_OFFSET_TABLE_ - 16696),
      (int)&GLOBAL_OFFSET_TABLE_ - 167069,
      457,
      (int)&GLOBAL_OFFSET_TABLE_ - 166712);
  v69 += v37 - v72;
  *a3 = v69;
  *v67 = 0;
  v65 = v75;
  LOBYTE(v12) = (unsigned __int8)a2[2];
LABEL_11:
  while ( 2 )
  {
    v13 = v69;
    if ( (unsigned __int8 *)a4 != v69 )
    {
      v14 = v65;
      v15 = v65 + 1;
      if ( v63 < v65 + 1 )
      {
        v13 = v69;
        v14 = v65;
        v66 = 5;
        goto LABEL_29;
      }
      v66 = 4;
      v74 = (unsigned __int8)v12 & 2;
      while ( 1 )
      {
        v16 = *v13;
        v17 = (unsigned int)(v13 + 1);
        if ( v16 > 0x7F )
        {
          if ( v16 - 194 > 0x1D )
          {
            if ( (v16 & 0xF0) == 0xE0 )
            {
              v71 = 3;
              v16 &= 0xFu;
            }
            else if ( (v16 & 0xF8) == 0xF0 )
            {
              v71 = 4;
              v16 &= 7u;
            }
            else if ( (v16 & 0xFC) == 0xF8 )
            {
              v71 = 5;
              v16 &= 3u;
            }
            else
            {
              if ( (v16 & 0xFE) != 0xFC )
              {
                v18 = 0;
                do
                  ++v18;
                while ( a4 > (unsigned int)&v13[v18] && (v13[v18] & 0xC0) == 0x80 && v18 != 5 );
                goto LABEL_26;
              }
              v71 = 6;
              v16 &= 1u;
            }
          }
          else
          {
            v71 = 2;
            v16 &= 0x1Fu;
          }
          v18 = 1;
          if ( a4 < (unsigned int)&v13[v71] )
          {
            if ( a4 <= v17 )
            {
              v38 = 1;
            }
            else
            {
              if ( (v13[1] & 0xC0) != 0x80 )
              {
LABEL_26:
                if ( !v82 || !v74 )
                {
                  v66 = 6;
                  goto LABEL_29;
                }
                v13 += v18;
                ++*v82;
                v66 = 6;
                if ( (unsigned __int8 *)a4 == v13 )
                  goto LABEL_29;
                goto LABEL_15;
              }
              v38 = a4 - (_DWORD)v13;
              while ( 1 )
              {
                v17 = (unsigned int)&v13[++v18];
                if ( v18 == v38 )
                  break;
                if ( (v13[v18] & 0xC0) != 0x80 )
                  goto LABEL_26;
              }
            }
            if ( a4 == v17 )
            {
              v66 = 7;
              goto LABEL_29;
            }
            v18 = v38;
            goto LABEL_26;
          }
          do
          {
            v19 = v13[v18];
            if ( (v19 & 0xC0) != 0x80 )
              goto LABEL_26;
            ++v18;
            v16 = v19 & 0x3F | (v16 << 6);
          }
          while ( v71 != v18 );
          if ( v18 != 2 && !(v16 >> (5 * v18 - 4)) || (unsigned int)&unk_80C0800 + v16 - 135061504 <= 0x7FF )
            goto LABEL_26;
          v17 = (unsigned int)&v13[v71];
        }
        *v14 = v16;
        v13 = (unsigned __int8 *)v17;
        v14 = v15;
        if ( a4 == v17 )
          goto LABEL_29;
LABEL_15:
        v15 = v14 + 1;
        if ( v63 < v14 + 1 )
        {
          v66 = 5;
          *a3 = v13;
          if ( a5 )
            goto LABEL_37;
          goto LABEL_30;
        }
      }
    }
    v13 = (unsigned __int8 *)a4;
    v14 = v65;
    v66 = 4;
LABEL_29:
    *a3 = v13;
    if ( a5 )
    {
LABEL_37:
      *a5 = v14;
      return v66;
    }
LABEL_30:
    a2[3] = (unsigned int *)((char *)a2[3] + 1);
    if ( ((_BYTE)a2[2] & 1) != 0 )
    {
      *a2 = v14;
      *a6 += v85;
      goto LABEL_42;
    }
    if ( v65 >= v14 )
      goto LABEL_42;
    *(_DWORD *)v86 = *a2;
    dl_mcount_wrapper_check((int)v77);
    v20 = v77(v78, v79, v86, v14, 0, a6, 0, a8);
    if ( v20 == 4 )
    {
      if ( v66 == 5 )
        goto LABEL_35;
      goto LABEL_42;
    }
    v21 = *(_DWORD *)v86;
    if ( *(unsigned int **)v86 == v14 )
      goto LABEL_34;
    v39 = v69;
    *a3 = v69;
    if ( (unsigned __int8 *)a4 == v69 )
    {
      v48 = v65;
LABEL_96:
      *a3 = v69;
      if ( (unsigned int *)v21 == v48 )
        _assert_fail(
          (int)(&GLOBAL_OFFSET_TABLE_ - 16680),
          (int)&GLOBAL_OFFSET_TABLE_ - 167166,
          728,
          (int)&GLOBAL_OFFSET_TABLE_ - 166272);
      goto LABEL_97;
    }
    v40 = v65 + 1;
    if ( v21 < (unsigned int)(v65 + 1) )
    {
      if ( (unsigned int *)v21 == v65 )
        goto LABEL_113;
LABEL_97:
      _assert_fail(
        (int)&GLOBAL_OFFSET_TABLE_ - 167053,
        (int)&GLOBAL_OFFSET_TABLE_ - 167166,
        727,
        (int)&GLOBAL_OFFSET_TABLE_ - 166272);
    }
    v73 = v20;
    v41 = v21;
    v42 = v65;
    v76 = (unsigned int)a2[2] & 2;
    do
    {
      v43 = *v39;
      v44 = (unsigned int)(v39 + 1);
      if ( v43 <= 0x7F )
        goto LABEL_77;
      if ( v43 - 194 > 0x1D )
      {
        if ( (v43 & 0xF0) == 0xE0 )
        {
          v70 = 3;
          v43 &= 0xFu;
        }
        else if ( (v43 & 0xF8) == 0xF0 )
        {
          v70 = 4;
          v43 &= 7u;
        }
        else if ( (v43 & 0xFC) == 0xF8 )
        {
          v70 = 5;
          v43 &= 3u;
        }
        else
        {
          if ( (v43 & 0xFE) != 0xFC )
          {
            i = 0;
            do
              ++i;
            while ( a4 > (unsigned int)&v39[i] && (v39[i] & 0xC0) == 0x80 && i != 5 );
LABEL_109:
            v68 = i;
            goto LABEL_93;
          }
          v70 = 6;
          v43 &= 1u;
        }
      }
      else
      {
        v70 = 2;
        v43 &= 0x1Fu;
      }
      v68 = 1;
      if ( a4 < (unsigned int)&v39[v70] )
      {
        if ( a4 > v44 )
        {
          if ( (v39[1] & 0xC0) != 0x80 )
          {
            v47 = 1;
LABEL_92:
            v68 = v47;
            goto LABEL_93;
          }
          v47 = 1;
          while ( 1 )
          {
            v44 = (unsigned int)&v39[++v47];
            if ( v47 == a4 - (_DWORD)v39 )
              break;
            if ( (v39[v47] & 0xC0) != 0x80 )
              goto LABEL_92;
          }
          v68 = a4 - (_DWORD)v39;
        }
        if ( v44 == a4 )
          goto LABEL_95;
      }
      else
      {
        for ( i = 1; i != v70; ++i )
        {
          v46 = v39[i];
          if ( (v46 & 0xC0) != 0x80 )
            goto LABEL_109;
          v43 = v46 & 0x3F | (v43 << 6);
        }
        v68 = i;
        if ( (i == 2 || v43 >> (5 * i - 4)) && (unsigned int)&unk_80C0800 + v43 - 135061504 > 0x7FF )
        {
          v44 = (unsigned int)&v39[v70];
LABEL_77:
          *v42 = v43;
          v39 = (unsigned __int8 *)v44;
          v42 = v40;
          goto LABEL_78;
        }
      }
LABEL_93:
      if ( !v82 || !v76 )
      {
LABEL_95:
        v69 = v39;
        v48 = v42;
        v21 = v41;
        goto LABEL_96;
      }
      v39 += v68;
      ++*v82;
LABEL_78:
      if ( (unsigned __int8 *)a4 == v39 )
        goto LABEL_95;
      v40 = v42 + 1;
    }
    while ( v41 >= (unsigned int)(v42 + 1) );
    v49 = v42;
    v50 = (unsigned int *)v41;
    v20 = v73;
    *a3 = v39;
    if ( v50 != v49 )
      goto LABEL_97;
    if ( v50 == v65 )
LABEL_113:
      a2[3] = (unsigned int *)((char *)a2[3] - 1);
LABEL_34:
    if ( !v20 )
    {
LABEL_35:
      v69 = *a3;
      v12 = a2[2];
      v65 = *a2;
      continue;
    }
    break;
  }
  v66 = v20;
LABEL_42:
  if ( a8 && v66 == 7 )
  {
    v23 = a2[5];
    v24 = *a3;
    v25 = **a3;
    v64 = a4 - (_DWORD)*a3;
    *v23 = v64;
    if ( (unsigned int)(v25 - 192) <= 1 )
      _assert_fail(
        (int)&GLOBAL_OFFSET_TABLE_ - 167036,
        (int)&GLOBAL_OFFSET_TABLE_ - 167166,
        773,
        (int)&GLOBAL_OFFSET_TABLE_ - 166272);
    if ( (unsigned int)(v25 - 194) > 0x1D )
    {
      if ( (v25 & 0xF0) == 0xE0 )
      {
        v26 = v25 & 0xF;
        v27 = 2;
        v28 = 768;
      }
      else if ( (v25 & 0xF8) == 0xF0 )
      {
        v26 = v25 & 7;
        v27 = 3;
        v28 = 1024;
      }
      else if ( (v25 & 0xFC) == 0xF8 )
      {
        v26 = v25 & 3;
        v27 = 4;
        v28 = 1280;
      }
      else
      {
        v26 = v25 & 1;
        v27 = 5;
        v28 = 1536;
      }
    }
    else
    {
      v26 = v25 & 0x1F;
      v27 = 1;
      v28 = 512;
    }
    v29 = v24 + 1;
    *a3 = v24 + 1;
    if ( a4 > (unsigned int)(v24 + 1) )
    {
      do
      {
        v30 = *v29++;
        v26 = v30 & 0x3F | (v26 << 6);
        *a3 = v29;
      }
      while ( v29 != (unsigned __int8 *)a4 );
      v27 += (_BYTE)v24 - (_BYTE)v29 + 1;
    }
    *v23 = v64 | v28;
    v23[1] = v26 << (6 * v27);
  }
  return v66;
}
// 80CE000: using guessed type _TBYTE GLOBAL_OFFSET_TABLE_;

//----- (0806B590) --------------------------------------------------------
int __cdecl _gconv_transform_ucs2_internal(
        int a1,
        char **a2,
        unsigned int *a3,
        unsigned int a4,
        char **a5,
        _DWORD *a6,
        int a7,
        int a8)
{
  char *v8; // esi
  char *v9; // edx
  char **v10; // eax
  char *v11; // ecx
  int *v12; // ebx
  unsigned int v13; // eax
  char *v14; // ebx
  char *v15; // ecx
  int v16; // edx
  int v18; // eax
  unsigned int v19; // esi
  char *v20; // ebx
  unsigned int v21; // eax
  _BYTE *v22; // edx
  char *v23; // ebx
  unsigned int v24; // ecx
  char *v25; // ecx
  int v26; // eax
  int v27; // eax
  bool v28; // cf
  bool v29; // zf
  int v30; // eax
  char *v31; // eax
  char *v32; // eax
  unsigned int v33; // eax
  char *v34; // [esp+0h] [ebp-6Ch]
  char *v35; // [esp+4h] [ebp-68h]
  int v36; // [esp+8h] [ebp-64h]
  int v37; // [esp+8h] [ebp-64h]
  unsigned int v38; // [esp+14h] [ebp-58h]
  int (__cdecl *v39)(int, char **, void **, char *, _DWORD, _DWORD *, int, int); // [esp+1Ch] [ebp-50h]
  int v40; // [esp+20h] [ebp-4Ch]
  int v41; // [esp+24h] [ebp-48h]
  char **v42; // [esp+28h] [ebp-44h]
  int *v43; // [esp+2Ch] [ebp-40h]
  int v44; // [esp+40h] [ebp-2Ch] BYREF
  void *v45; // [esp+44h] [ebp-28h] BYREF
  unsigned __int16 v46; // [esp+4Ah] [ebp-22h]
  unsigned int v47; // [esp+4Ch] [ebp-20h]

  v47 = __readgsdword(0x14u);
  v8 = a2[2];
  v41 = a1 + 60;
  v42 = a2 + 8;
  v39 = 0;
  if ( ((unsigned __int8)v8 & 1) == 0 )
  {
    v39 = *(int (__cdecl **)(int, char **, void **, char *, _DWORD, _DWORD *, int, int))(a1 + 80);
    if ( *(_DWORD *)(a1 + 60) )
      v39 = (int (__cdecl *)(int, char **, void **, char *, _DWORD, _DWORD *, int, int))(__readgsdword(0x18u) ^ __ROR4__(*(_DWORD *)(a1 + 80), 9));
  }
  if ( a7 )
  {
    if ( a5 )
      _assert_fail(
        (int)&GLOBAL_OFFSET_TABLE_ - 167146,
        (int)&GLOBAL_OFFSET_TABLE_ - 167166,
        415,
        (int)&GLOBAL_OFFSET_TABLE_ - 166304);
    v31 = a2[5];
    v36 = 0;
    *(_DWORD *)v31 = 0;
    *((_DWORD *)v31 + 1) = 0;
    if ( ((_BYTE)a2[2] & 1) == 0 )
    {
      dl_mcount_wrapper_check((int)v39);
      return v39(v41, v42, 0, 0, 0, a6, a7, a8);
    }
    return v36;
  }
  v9 = (char *)*a3;
  v10 = a5;
  if ( !a5 )
    v10 = a2;
  v11 = *v10;
  v44 = 0;
  v35 = v11;
  v12 = 0;
  v34 = a2[1];
  if ( a6 )
    v12 = &v44;
  v43 = v12;
  if ( a8 )
  {
    v23 = a2[5];
    v37 = *(_DWORD *)v23;
    v38 = *(_DWORD *)v23 & 7;
    if ( v38 )
    {
      if ( a5 )
        _assert_fail(
          (int)&GLOBAL_OFFSET_TABLE_ - 167146,
          (int)&GLOBAL_OFFSET_TABLE_ - 167166,
          559,
          (int)&GLOBAL_OFFSET_TABLE_ - 166304);
      if ( v38 > 4 )
        _assert_fail(
          (int)&GLOBAL_OFFSET_TABLE_ - 167008,
          (int)&GLOBAL_OFFSET_TABLE_ - 167069,
          395,
          (int)(&GLOBAL_OFFSET_TABLE_ - 16674));
      LOBYTE(v46) = v23[4];
      if ( (v37 & 6) != 0 )
      {
        v40 = 2;
        v24 = (unsigned int)v9;
        HIBYTE(v46) = v23[5];
      }
      else
      {
        v24 = (unsigned int)(v9 + 1);
        v40 = 1;
      }
      if ( a4 < v24 )
      {
        *a3 = a4;
        if ( (unsigned int)v9 < a4 )
        {
          v32 = &v23[v40 + 4];
          do
            *v32++ = *v9++;
          while ( (char *)a4 != v9 );
        }
        return 7;
      }
      v25 = v9;
      if ( v34 < v35 + 4 )
        return 5;
      v26 = v40;
      do
      {
        *((_BYTE *)&v46 + v26) = *v25++;
        v27 = v26 + 1;
        v28 = v27 == 0;
        v29 = v27 == 1;
        v26 = 1;
      }
      while ( a4 > (unsigned int)v25 && (v28 || v29) );
      if ( (unsigned __int16)(v46 + 10240) <= 0x7FFu )
      {
        if ( !v43 || ((unsigned __int8)v8 & 2) == 0 )
          return 6;
        ++*v43;
      }
      else
      {
        *(_DWORD *)v35 = v46;
        v37 = *(_DWORD *)v23;
        v38 = *(_DWORD *)v23 & 7;
        v35 += 4;
      }
      if ( (v37 & 6) != 0 )
        _assert_fail(
          (int)(&GLOBAL_OFFSET_TABLE_ - 16696),
          (int)&GLOBAL_OFFSET_TABLE_ - 167069,
          457,
          (int)(&GLOBAL_OFFSET_TABLE_ - 16674));
      v9 = &v9[-v38 + 2];
      v8 = a2[2];
      *a3 = (unsigned int)v9;
      *(_DWORD *)v23 = v37 & 0xFFFFFFF8;
    }
  }
  while ( (char *)a4 == v9 )
  {
    v14 = v35;
    v13 = a4;
    v36 = 4;
LABEL_26:
    *a3 = v13;
    if ( a5 )
      goto LABEL_23;
LABEL_27:
    ++a2[3];
    if ( ((_BYTE)a2[2] & 1) != 0 )
    {
      v30 = v44;
      *a2 = v14;
      *a6 += v30;
LABEL_36:
      if ( a8 && v36 == 7 )
      {
        v19 = *a3;
        if ( (int)(a4 - *a3) > 3 )
          _assert_fail(
            (int)&GLOBAL_OFFSET_TABLE_ - 167126,
            (int)&GLOBAL_OFFSET_TABLE_ - 167166,
            777,
            (int)&GLOBAL_OFFSET_TABLE_ - 166304);
        v20 = a2[5];
        v21 = v19 + 1;
        v22 = v20 + 4;
        if ( v19 >= a4 )
        {
          v33 = 0;
        }
        else
        {
          while ( 1 )
          {
            *a3 = v21;
            *v22++ = *(_BYTE *)(v21 - 1);
            if ( v21 == a4 )
              break;
            ++v21;
          }
          v33 = v21 - v19;
        }
        *(_DWORD *)v20 = *(_DWORD *)v20 & 0xFFFFFFF8 | v33;
      }
      return v36;
    }
    if ( v14 <= v35 )
      goto LABEL_36;
    v45 = *a2;
    dl_mcount_wrapper_check((int)v39);
    v18 = v39(v41, v42, &v45, v14, 0, a6, 0, a8);
    if ( v18 == 4 )
    {
      if ( v36 != 5 )
        goto LABEL_36;
    }
    else
    {
      if ( v45 != v14 )
        *a3 -= (v14 - (_BYTE *)v45) / 2;
      if ( v18 )
      {
        v36 = v18;
        goto LABEL_36;
      }
    }
    v8 = a2[2];
    v9 = (char *)*a3;
    v35 = *a2;
  }
  v13 = (unsigned int)(v9 + 2);
  v14 = v35;
  if ( a4 < (unsigned int)(v9 + 2) )
  {
    v13 = (unsigned int)v9;
    v36 = 7;
    goto LABEL_26;
  }
  v15 = v35 + 4;
  if ( v34 < v35 + 4 )
  {
    v14 = v35;
    v13 = (unsigned int)v9;
    v36 = 5;
    goto LABEL_26;
  }
  v36 = 4;
  while ( 1 )
  {
    v16 = *(unsigned __int16 *)(v13 - 2);
    if ( (unsigned __int16)(v16 + 10240) <= 0x7FFu )
      break;
    *(_DWORD *)v14 = v16;
    v14 = v15;
    if ( v13 == a4 )
      goto LABEL_22;
LABEL_16:
    if ( a4 < v13 + 2 )
    {
      v36 = 7;
      goto LABEL_26;
    }
    v15 = v14 + 4;
    if ( v34 < v14 + 4 )
    {
      v36 = 5;
      goto LABEL_26;
    }
    v13 += 2;
  }
  if ( !v43 || ((unsigned __int8)v8 & 2) == 0 )
  {
    v13 -= 2;
    v36 = 6;
    goto LABEL_26;
  }
  ++*v43;
  v36 = 6;
  if ( v13 != a4 )
    goto LABEL_16;
LABEL_22:
  *a3 = v13;
  if ( !a5 )
    goto LABEL_27;
LABEL_23:
  *a5 = v14;
  return v36;
}
// 806B8C8: conditional instruction was optimized away because %var_58.4 is in (1..4)
// 80CE000: using guessed type _TBYTE GLOBAL_OFFSET_TABLE_;
// 806B590: using guessed type void *var_28;

//----- (0806BBA0) --------------------------------------------------------
int __cdecl _gconv_transform_internal_ucs2(
        _DWORD *a1,
        int *a2,
        int *a3,
        unsigned int a4,
        int *a5,
        _DWORD *a6,
        int a7,
        int a8)
{
  int v8; // esi
  int *v9; // edx
  unsigned int *v10; // eax
  char *v11; // ecx
  int v12; // edx
  int *v13; // edx
  char *v14; // ebx
  unsigned int *v15; // edx
  int v16; // esi
  unsigned int v17; // ecx
  int v19; // eax
  int i; // edx
  unsigned int *v21; // edx
  unsigned int v22; // ebx
  int v23; // eax
  int v24; // ebx
  int v25; // eax
  unsigned int v26; // esi
  unsigned int *v27; // ebx
  int v28; // eax
  _BYTE *v29; // edx
  _DWORD *v30; // eax
  unsigned int *v31; // eax
  char *v32; // esi
  unsigned int *v33; // ecx
  unsigned int *v34; // eax
  signed int v35; // eax
  _DWORD *v36; // ebp
  unsigned int v37; // eax
  unsigned int v38; // [esp+0h] [ebp-80h]
  int v39; // [esp+4h] [ebp-7Ch]
  int v40; // [esp+4h] [ebp-7Ch]
  unsigned int v41; // [esp+8h] [ebp-78h]
  int v42; // [esp+18h] [ebp-68h]
  unsigned int *v43; // [esp+18h] [ebp-68h]
  int (__cdecl *v44)(_DWORD *, int *, char **, char *, _DWORD, _DWORD *, int, int); // [esp+20h] [ebp-60h]
  _DWORD *v45; // [esp+24h] [ebp-5Ch]
  int *v46; // [esp+28h] [ebp-58h]
  int *v47; // [esp+2Ch] [ebp-54h]
  unsigned int v48; // [esp+38h] [ebp-48h]
  int *v49; // [esp+38h] [ebp-48h]
  int v50; // [esp+50h] [ebp-30h] BYREF
  unsigned int *v51; // [esp+54h] [ebp-2Ch] BYREF
  char *v52; // [esp+58h] [ebp-28h] BYREF
  unsigned int v53; // [esp+5Ch] [ebp-24h] BYREF
  int v54[8]; // [esp+60h] [ebp-20h] BYREF

  v54[0] = __readgsdword(0x14u);
  v8 = a2[2];
  v45 = a1 + 15;
  v46 = a2 + 8;
  v44 = 0;
  if ( (v8 & 1) == 0 )
  {
    v44 = (int (__cdecl *)(_DWORD *, int *, char **, char *, _DWORD, _DWORD *, int, int))a1[20];
    if ( a1[15] )
      v44 = (int (__cdecl *)(_DWORD *, int *, char **, char *, _DWORD, _DWORD *, int, int))(__readgsdword(0x18u) ^ __ROR4__(a1[20], 9));
  }
  if ( a7 )
  {
    if ( a5 )
      _assert_fail(
        (int)&GLOBAL_OFFSET_TABLE_ - 167146,
        (int)&GLOBAL_OFFSET_TABLE_ - 167166,
        415,
        (int)&GLOBAL_OFFSET_TABLE_ - 166336);
    v30 = (_DWORD *)a2[5];
    v39 = 0;
    *v30 = 0;
    v30[1] = 0;
    if ( (a2[2] & 1) == 0 )
    {
      dl_mcount_wrapper_check((int)v44);
      return v44(v45, v46, 0, 0, 0, a6, a7, a8);
    }
    return v39;
  }
  v9 = a5;
  v10 = (unsigned int *)*a3;
  if ( !a5 )
    v9 = a2;
  v11 = (char *)*v9;
  v12 = a2[1];
  v50 = 0;
  v38 = v12;
  v41 = (unsigned int)v11;
  v13 = 0;
  if ( a6 )
    v13 = &v50;
  v47 = v13;
  if ( !a8 )
    goto LABEL_10;
  v43 = (unsigned int *)a2[5];
  v48 = *v43;
  v40 = *v43 & 7;
  if ( !v40 )
    goto LABEL_10;
  if ( a5 )
    _assert_fail(
      (int)&GLOBAL_OFFSET_TABLE_ - 167146,
      (int)&GLOBAL_OFFSET_TABLE_ - 167166,
      559,
      (int)&GLOBAL_OFFSET_TABLE_ - 166336);
  v51 = v10;
  v52 = v11;
  if ( (unsigned int)v40 > 4 )
    _assert_fail(
      (int)&GLOBAL_OFFSET_TABLE_ - 167008,
      (int)&GLOBAL_OFFSET_TABLE_ - 167069,
      395,
      (int)&GLOBAL_OFFSET_TABLE_ - 166768);
  for ( i = 0; i != v40; ++i )
    *((_BYTE *)&v54[-1] + i) = *((_BYTE *)v43 + i + 4);
  if ( a4 < (unsigned int)v10 + 4 - v40 )
  {
    *a3 = a4;
    if ( (unsigned int)v10 < a4 )
    {
      v31 = (unsigned int *)((char *)v10 + 1);
      v32 = (char *)v43 + v40;
      while ( 1 )
      {
        v51 = v31;
        (++v32)[3] = *((_BYTE *)v31 - 1);
        if ( (unsigned int *)a4 == v31 )
          break;
        v31 = (unsigned int *)((char *)v31 + 1);
      }
    }
    return 7;
  }
  v21 = v10;
  if ( v38 < (unsigned int)(v11 + 2) )
    return 5;
  v22 = v48 & 7;
  do
  {
    v21 = (unsigned int *)((char *)v21 + 1);
    ++v22;
    v51 = v21;
    *((_BYTE *)&v52 + v22 + 3) = *((_BYTE *)v21 - 1);
  }
  while ( v22 <= 3 && a4 > (unsigned int)v21 );
  v51 = &v53;
  if ( v53 <= 0xFFFF )
  {
    if ( v53 - 55296 > 0x7FF )
    {
      *(_WORD *)v11 = v53;
      v52 = v11 + 2;
LABEL_54:
      v51 = (unsigned int *)v54;
      v23 = 4;
LABEL_55:
      if ( v40 >= v23 )
        _assert_fail(
          (int)(&GLOBAL_OFFSET_TABLE_ - 16696),
          (int)&GLOBAL_OFFSET_TABLE_ - 167069,
          457,
          (int)&GLOBAL_OFFSET_TABLE_ - 166768);
      v24 = (int)v52;
      v10 = (unsigned int *)(*a3 + v23 - v40);
      *a3 = (int)v10;
      v41 = v24;
      *v43 = v48 & 0xFFFFFFF8;
      v8 = a2[2];
      goto LABEL_10;
    }
    if ( v47 && (v8 & 2) != 0 )
    {
      v51 = (unsigned int *)v54;
      ++*v47;
      v48 = *v43;
      v40 = *v43 & 7;
      v23 = 4;
      goto LABEL_55;
    }
    return 6;
  }
  if ( v53 >> 7 == 7168 )
    goto LABEL_54;
  if ( !v47 )
    return 6;
  if ( (v8 & 8) == 0 )
  {
    v39 = 6;
    v34 = &v53;
    if ( (v8 & 2) == 0 )
      return v39;
    goto LABEL_92;
  }
  v49 = (int *)((char *)&v54[-1] + v22);
  v39 = _gconv_transliterate(a1, (int)a2, (int)v10, &v51, (unsigned int)&v54[-1] + v22, (int *)&v52, v47);
  v33 = &v53;
  v34 = v51;
  if ( v39 == 6 )
  {
    if ( (v8 & 2) == 0 )
    {
LABEL_93:
      if ( v34 == &v53 )
        return 6;
LABEL_94:
      v23 = (char *)v34 - (char *)&v53;
      v48 = *v43;
      v40 = *v43 & 7;
      goto LABEL_55;
    }
LABEL_92:
    v51 = ++v34;
    ++*v47;
    goto LABEL_93;
  }
  if ( v51 != &v53 )
    goto LABEL_94;
  if ( v39 == 7 )
  {
    if ( v49 == v54 )
      _assert_fail(
        (int)(&GLOBAL_OFFSET_TABLE_ - 16692),
        (int)&GLOBAL_OFFSET_TABLE_ - 167069,
        475,
        (int)&GLOBAL_OFFSET_TABLE_ - 166768);
    v35 = *v43 & 0xFFFFFFF8;
    *a3 += v22 - (*v43 & 7);
    if ( (int)v22 <= v35 )
      _assert_fail(
        (int)&GLOBAL_OFFSET_TABLE_ - 166884,
        (int)&GLOBAL_OFFSET_TABLE_ - 167069,
        485,
        (int)&GLOBAL_OFFSET_TABLE_ - 166768);
    if ( v22 > 4 )
      _assert_fail(
        (int)&GLOBAL_OFFSET_TABLE_ - 166844,
        (int)&GLOBAL_OFFSET_TABLE_ - 167069,
        486,
        (int)&GLOBAL_OFFSET_TABLE_ - 166768);
    *v43 = v35 | v22;
    if ( v49 > (int *)&v53 )
    {
      v36 = v43 + 1;
      do
      {
        v33 = (unsigned int *)((char *)v33 + 1);
        v36 = (_DWORD *)((char *)v36 + 1);
        v51 = v33;
        *((_BYTE *)v36 - 1) = *((_BYTE *)v33 - 1);
      }
      while ( v49 != (int *)v33 );
    }
    return 7;
  }
  if ( v39 )
    return v39;
  v8 = a2[2];
  v10 = (unsigned int *)*a3;
  while ( 1 )
  {
LABEL_10:
    v14 = (char *)v41;
    v51 = v10;
    v39 = 4;
    v52 = (char *)v41;
    v42 = v8 & 2;
LABEL_11:
    if ( (unsigned int *)a4 != v10 )
    {
      while ( 1 )
      {
        v15 = v10 + 1;
        if ( a4 < (unsigned int)(v10 + 1) )
        {
          v39 = 7;
          goto LABEL_21;
        }
        v16 = (int)(v14 + 2);
        if ( v38 < (unsigned int)(v14 + 2) )
          break;
        v17 = *v10;
        if ( *v10 > 0xFFFF )
        {
          if ( v17 >> 7 == 7168 )
          {
            v51 = ++v10;
            goto LABEL_11;
          }
          if ( v47 )
          {
            if ( (a2[2] & 8) != 0 )
            {
              v39 = _gconv_transliterate(a1, (int)a2, *a3, &v51, a4, (int *)&v52, v47);
              v14 = v52;
              v10 = v51;
              if ( v39 != 6 )
              {
                if ( v39 != 5 )
                  goto LABEL_11;
                goto LABEL_17;
              }
            }
            if ( v42 )
            {
              ++v10;
              v39 = 6;
              v51 = v10;
              ++*v47;
              goto LABEL_11;
            }
          }
LABEL_34:
          v39 = 6;
LABEL_21:
          *a3 = (int)v10;
          if ( a5 )
            goto LABEL_18;
          goto LABEL_22;
        }
        if ( v17 - 55296 <= 0x7FF )
        {
          if ( v47 && v42 )
          {
            v51 = ++v10;
            ++*v47;
            v39 = 6;
            goto LABEL_11;
          }
          goto LABEL_34;
        }
        ++v10;
        *(_WORD *)v14 = v17;
        v14 += 2;
        v52 = (char *)v16;
        v51 = v15;
        if ( (unsigned int *)a4 == v15 )
          goto LABEL_17;
      }
      v39 = 5;
      goto LABEL_21;
    }
LABEL_17:
    *a3 = (int)v10;
    if ( a5 )
    {
LABEL_18:
      *a5 = (int)v14;
      return v39;
    }
LABEL_22:
    ++a2[3];
    if ( (a2[2] & 1) != 0 )
      break;
    if ( (unsigned int)v14 <= v41 )
    {
      v19 = v39;
      goto LABEL_27;
    }
    v52 = (char *)*a2;
    dl_mcount_wrapper_check((int)v44);
    v19 = v44(v45, v46, &v52, v14, 0, a6, 0, a8);
    if ( v19 != 4 )
    {
      if ( v14 != v52 )
        *a3 -= 2 * (v14 - v52);
LABEL_27:
      if ( v19 )
        goto LABEL_40;
      goto LABEL_28;
    }
    v19 = v39;
    if ( v39 != 5 && v39 )
    {
LABEL_40:
      v39 = v19;
      goto LABEL_59;
    }
LABEL_28:
    v8 = a2[2];
    v10 = (unsigned int *)*a3;
    v41 = *a2;
  }
  v25 = v50;
  *a2 = (int)v14;
  *a6 += v25;
LABEL_59:
  if ( v39 == 7 && a8 )
  {
    v26 = *a3;
    if ( (int)(a4 - *a3) > 3 )
      _assert_fail(
        (int)&GLOBAL_OFFSET_TABLE_ - 167126,
        (int)&GLOBAL_OFFSET_TABLE_ - 167166,
        777,
        (int)&GLOBAL_OFFSET_TABLE_ - 166336);
    v27 = (unsigned int *)a2[5];
    v28 = v26 + 1;
    v29 = v27 + 1;
    if ( v26 >= a4 )
    {
      v37 = 0;
    }
    else
    {
      while ( 1 )
      {
        *a3 = v28;
        *v29++ = *(_BYTE *)(v28 - 1);
        if ( v28 == a4 )
          break;
        ++v28;
      }
      v37 = v28 - v26;
    }
    *v27 = *v27 & 0xFFFFFFF8 | v37;
  }
  return v39;
}
// 806BED7: conditional instruction was optimized away because %var_7C.4 is in (1..4)
// 80CE000: using guessed type _TBYTE GLOBAL_OFFSET_TABLE_;

//----- (0806C460) --------------------------------------------------------
int __cdecl _gconv_transform_ucs2reverse_internal(
        int a1,
        char **a2,
        unsigned int *a3,
        unsigned int a4,
        char **a5,
        _DWORD *a6,
        int a7,
        int a8)
{
  char *v8; // esi
  char **v9; // edx
  char *v10; // eax
  char *v11; // ebx
  int *v12; // ebx
  unsigned int v13; // edx
  char *v14; // ebx
  char *v15; // ecx
  unsigned __int16 v16; // ax
  int v17; // esi
  int v18; // eax
  unsigned int v20; // ecx
  char *v21; // ebx
  unsigned int v22; // eax
  _BYTE *v23; // edx
  char *v24; // ebx
  unsigned int v25; // ecx
  char *v26; // ecx
  int v27; // edx
  int v28; // edx
  bool v29; // cf
  bool v30; // zf
  unsigned __int16 v31; // dx
  int v32; // eax
  char *v33; // eax
  char *v34; // edx
  unsigned int v35; // eax
  char *v36; // [esp+0h] [ebp-6Ch]
  unsigned int v37; // [esp+0h] [ebp-6Ch]
  char *v38; // [esp+4h] [ebp-68h]
  int (__cdecl *v39)(int, char **, void **, char *, _DWORD, _DWORD *, int, int); // [esp+Ch] [ebp-60h]
  int v40; // [esp+14h] [ebp-58h]
  unsigned int v41; // [esp+1Ch] [ebp-50h]
  int v42; // [esp+20h] [ebp-4Ch]
  char **v43; // [esp+24h] [ebp-48h]
  int *v44; // [esp+28h] [ebp-44h]
  int v45; // [esp+30h] [ebp-3Ch]
  int v46; // [esp+40h] [ebp-2Ch] BYREF
  void *v47; // [esp+44h] [ebp-28h] BYREF
  __int16 v48; // [esp+4Ah] [ebp-22h]
  unsigned int v49; // [esp+4Ch] [ebp-20h]

  v49 = __readgsdword(0x14u);
  v8 = a2[2];
  v42 = a1 + 60;
  v43 = a2 + 8;
  v39 = 0;
  if ( ((unsigned __int8)v8 & 1) == 0 )
  {
    v39 = *(int (__cdecl **)(int, char **, void **, char *, _DWORD, _DWORD *, int, int))(a1 + 80);
    if ( *(_DWORD *)(a1 + 60) )
      v39 = (int (__cdecl *)(int, char **, void **, char *, _DWORD, _DWORD *, int, int))(__readgsdword(0x18u) ^ __ROR4__(*(_DWORD *)(a1 + 80), 9));
  }
  if ( a7 )
  {
    if ( a5 )
      _assert_fail(
        (int)&GLOBAL_OFFSET_TABLE_ - 167146,
        (int)&GLOBAL_OFFSET_TABLE_ - 167166,
        415,
        (int)(&GLOBAL_OFFSET_TABLE_ - 16640));
    v33 = a2[5];
    v17 = 0;
    *(_DWORD *)v33 = 0;
    *((_DWORD *)v33 + 1) = 0;
    if ( ((_BYTE)a2[2] & 1) == 0 )
    {
      dl_mcount_wrapper_check((int)v39);
      return v39(v42, v43, 0, 0, 0, a6, a7, a8);
    }
    return v17;
  }
  v9 = a5;
  v10 = (char *)*a3;
  if ( !a5 )
    v9 = a2;
  v11 = *v9;
  v46 = 0;
  v38 = v11;
  v36 = a2[1];
  v12 = 0;
  if ( a6 )
    v12 = &v46;
  v44 = v12;
  if ( !a8 || (v24 = a2[5], v40 = *(_DWORD *)v24, (v41 = *(_DWORD *)v24 & 7) == 0) )
  {
    while ( 1 )
    {
LABEL_10:
      if ( (char *)a4 == v10 )
      {
        v14 = v38;
        v13 = a4;
        v17 = 4;
      }
      else
      {
        v13 = (unsigned int)(v10 + 2);
        v14 = v38;
        if ( a4 < (unsigned int)(v10 + 2) )
        {
          v13 = (unsigned int)v10;
          v17 = 7;
        }
        else
        {
          v15 = v38 + 4;
          if ( v36 >= v38 + 4 )
          {
            while ( 1 )
            {
              v16 = __ROL2__(*(_WORD *)(v13 - 2), 8);
              if ( (unsigned __int16)(v16 + 10240) <= 0x7FFu )
              {
                if ( !v44 || ((unsigned __int8)v8 & 2) == 0 )
                {
                  v13 -= 2;
                  v17 = 6;
                  goto LABEL_21;
                }
                ++*v44;
                if ( v13 == a4 )
                {
LABEL_54:
                  v17 = 4;
                  goto LABEL_21;
                }
              }
              else
              {
                *(_DWORD *)v14 = v16;
                v14 = v15;
                if ( v13 == a4 )
                  goto LABEL_54;
              }
              if ( a4 < v13 + 2 )
                break;
              v15 = v14 + 4;
              if ( v36 < v14 + 4 )
              {
                v17 = 5;
                goto LABEL_21;
              }
              v13 += 2;
            }
            v17 = 7;
            *a3 = v13;
            if ( !a5 )
              goto LABEL_22;
LABEL_30:
            *a5 = v14;
            return v17;
          }
          v14 = v38;
          v13 = (unsigned int)v10;
          v17 = 5;
        }
      }
LABEL_21:
      *a3 = v13;
      if ( a5 )
        goto LABEL_30;
LABEL_22:
      ++a2[3];
      if ( ((_BYTE)a2[2] & 1) != 0 )
      {
        v32 = v46;
        *a2 = v14;
        *a6 += v32;
        goto LABEL_34;
      }
      if ( v14 <= v38 )
        goto LABEL_34;
      v47 = *a2;
      dl_mcount_wrapper_check((int)v39);
      v18 = v39(v42, v43, &v47, v14, 0, a6, 0, a8);
      if ( v18 == 4 )
      {
        if ( v17 != 5 )
          goto LABEL_34;
      }
      else
      {
        if ( v14 != v47 )
          *a3 -= (v14 - (_BYTE *)v47) / 2;
        if ( v18 )
        {
          v17 = v18;
LABEL_34:
          if ( a8 && v17 == 7 )
          {
            v20 = *a3;
            v37 = *a3;
            if ( (int)(a4 - *a3) > 3 )
              _assert_fail(
                (int)&GLOBAL_OFFSET_TABLE_ - 167126,
                (int)&GLOBAL_OFFSET_TABLE_ - 167166,
                777,
                (int)(&GLOBAL_OFFSET_TABLE_ - 16640));
            v21 = a2[5];
            v22 = v20 + 1;
            v23 = v21 + 4;
            if ( v20 >= a4 )
            {
              v35 = 0;
            }
            else
            {
              while ( 1 )
              {
                *a3 = v22;
                *v23++ = *(_BYTE *)(v22 - 1);
                if ( a4 == v22 )
                  break;
                ++v22;
              }
              v35 = a4 - v37;
            }
            *(_DWORD *)v21 = *(_DWORD *)v21 & 0xFFFFFFF8 | v35;
          }
          return v17;
        }
      }
      v8 = a2[2];
      v10 = (char *)*a3;
      v38 = *a2;
    }
  }
  if ( a5 )
    _assert_fail(
      (int)&GLOBAL_OFFSET_TABLE_ - 167146,
      (int)&GLOBAL_OFFSET_TABLE_ - 167166,
      559,
      (int)(&GLOBAL_OFFSET_TABLE_ - 16640));
  if ( v41 > 4 )
    _assert_fail(
      (int)&GLOBAL_OFFSET_TABLE_ - 167008,
      (int)&GLOBAL_OFFSET_TABLE_ - 167069,
      395,
      (int)&GLOBAL_OFFSET_TABLE_ - 166464);
  LOBYTE(v48) = v24[4];
  if ( (v40 & 6) != 0 )
  {
    v45 = 2;
    v25 = (unsigned int)v10;
    HIBYTE(v48) = v24[5];
  }
  else
  {
    v25 = (unsigned int)(v10 + 1);
    v45 = 1;
  }
  if ( a4 < v25 )
  {
    *a3 = a4;
    if ( (unsigned int)v10 < a4 )
    {
      v34 = &v24[v45 + 4];
      do
        *v34++ = *v10++;
      while ( (char *)a4 != v10 );
    }
    return 7;
  }
  else
  {
    v26 = v10;
    if ( v36 >= v38 + 4 )
    {
      v27 = v45;
      do
      {
        *((_BYTE *)&v48 + v27) = *v26++;
        v28 = v27 + 1;
        v29 = v28 == 0;
        v30 = v28 == 1;
        v27 = 1;
      }
      while ( a4 > (unsigned int)v26 && (v29 || v30) );
      v31 = __ROL2__(v48, 8);
      if ( (unsigned __int16)(v31 + 10240) <= 0x7FFu )
      {
        if ( !v44 || ((unsigned __int8)v8 & 2) == 0 )
          return 6;
        ++*v44;
      }
      else
      {
        *(_DWORD *)v38 = v31;
        v40 = *(_DWORD *)v24;
        v41 = *(_DWORD *)v24 & 7;
        v38 += 4;
      }
      if ( (v40 & 6) != 0 )
        _assert_fail(
          (int)(&GLOBAL_OFFSET_TABLE_ - 16696),
          (int)&GLOBAL_OFFSET_TABLE_ - 167069,
          457,
          (int)&GLOBAL_OFFSET_TABLE_ - 166464);
      v10 = &v10[-v41 + 2];
      *a3 = (unsigned int)v10;
      v8 = a2[2];
      *(_DWORD *)v24 = v40 & 0xFFFFFFF8;
      goto LABEL_10;
    }
    return 5;
  }
}
// 806C758: conditional instruction was optimized away because %var_50.4 is in (1..4)
// 80CE000: using guessed type _TBYTE GLOBAL_OFFSET_TABLE_;
// 806C460: using guessed type void *var_28;

//----- (0806CA50) --------------------------------------------------------
int __cdecl _gconv_transform_internal_ucs2reverse(
        _DWORD *a1,
        int *a2,
        int *a3,
        unsigned int a4,
        int *a5,
        _DWORD *a6,
        int a7,
        int a8)
{
  int v8; // esi
  int *v9; // edx
  unsigned int *v10; // eax
  char *v11; // ecx
  int *v12; // edx
  char *v13; // ebx
  unsigned int *v14; // ecx
  int v15; // esi
  unsigned int v16; // edx
  int v18; // eax
  int i; // edx
  unsigned int *v20; // edx
  unsigned int v21; // ebx
  int v22; // eax
  int v23; // esi
  unsigned int v24; // esi
  unsigned int *v25; // ebx
  int v26; // eax
  _BYTE *v27; // edx
  _DWORD *v28; // eax
  unsigned int *v29; // eax
  char *v30; // esi
  unsigned int *v31; // ecx
  unsigned int *v32; // eax
  signed int v33; // eax
  _DWORD *v34; // ebp
  unsigned int v35; // eax
  unsigned int v36; // [esp+0h] [ebp-80h]
  unsigned int v37; // [esp+4h] [ebp-7Ch]
  int v38; // [esp+8h] [ebp-78h]
  int v39; // [esp+8h] [ebp-78h]
  unsigned int *v40; // [esp+10h] [ebp-70h]
  int v41; // [esp+18h] [ebp-68h]
  unsigned int v42; // [esp+18h] [ebp-68h]
  int *v43; // [esp+18h] [ebp-68h]
  int (__cdecl *v44)(_DWORD *, int *, char **, char *, _DWORD, _DWORD *, int, int); // [esp+20h] [ebp-60h]
  _DWORD *v45; // [esp+24h] [ebp-5Ch]
  int *v46; // [esp+28h] [ebp-58h]
  int *v47; // [esp+2Ch] [ebp-54h]
  int v48; // [esp+50h] [ebp-30h] BYREF
  unsigned int *v49; // [esp+54h] [ebp-2Ch] BYREF
  char *v50; // [esp+58h] [ebp-28h] BYREF
  unsigned int v51; // [esp+5Ch] [ebp-24h] BYREF
  int v52[8]; // [esp+60h] [ebp-20h] BYREF

  v52[0] = __readgsdword(0x14u);
  v46 = a2 + 8;
  v45 = a1 + 15;
  v8 = a2[2];
  v44 = 0;
  if ( (v8 & 1) == 0 )
  {
    v44 = (int (__cdecl *)(_DWORD *, int *, char **, char *, _DWORD, _DWORD *, int, int))a1[20];
    if ( a1[15] )
      v44 = (int (__cdecl *)(_DWORD *, int *, char **, char *, _DWORD, _DWORD *, int, int))(__readgsdword(0x18u) ^ __ROR4__(a1[20], 9));
  }
  if ( a7 )
  {
    if ( a5 )
      _assert_fail(
        (int)&GLOBAL_OFFSET_TABLE_ - 167146,
        (int)&GLOBAL_OFFSET_TABLE_ - 167166,
        415,
        (int)&GLOBAL_OFFSET_TABLE_ - 166528);
    v28 = (_DWORD *)a2[5];
    v38 = 0;
    *v28 = 0;
    v28[1] = 0;
    if ( (a2[2] & 1) == 0 )
    {
      dl_mcount_wrapper_check((int)v44);
      return v44(v45, v46, 0, 0, 0, a6, a7, a8);
    }
    return v38;
  }
  v9 = a5;
  v10 = (unsigned int *)*a3;
  if ( !a5 )
    v9 = a2;
  v11 = (char *)*v9;
  v48 = 0;
  v37 = (unsigned int)v11;
  v12 = 0;
  v36 = a2[1];
  if ( a6 )
    v12 = &v48;
  v47 = v12;
  if ( !a8 )
    goto LABEL_10;
  v40 = (unsigned int *)a2[5];
  v42 = *v40;
  v39 = *v40 & 7;
  if ( !v39 )
    goto LABEL_10;
  if ( a5 )
    _assert_fail(
      (int)&GLOBAL_OFFSET_TABLE_ - 167146,
      (int)&GLOBAL_OFFSET_TABLE_ - 167166,
      559,
      (int)&GLOBAL_OFFSET_TABLE_ - 166528);
  v49 = v10;
  v50 = v11;
  if ( (unsigned int)v39 > 4 )
    _assert_fail(
      (int)&GLOBAL_OFFSET_TABLE_ - 167008,
      (int)&GLOBAL_OFFSET_TABLE_ - 167069,
      395,
      (int)&GLOBAL_OFFSET_TABLE_ - 166592);
  for ( i = 0; i != v39; ++i )
    *((_BYTE *)&v52[-1] + i) = *((_BYTE *)v40 + i + 4);
  if ( a4 < (unsigned int)v10 + 4 - v39 )
  {
    *a3 = a4;
    if ( (unsigned int)v10 < a4 )
    {
      v29 = (unsigned int *)((char *)v10 + 1);
      v30 = (char *)v40 + v39;
      while ( 1 )
      {
        v49 = v29;
        (++v30)[3] = *((_BYTE *)v29 - 1);
        if ( (unsigned int *)a4 == v29 )
          break;
        v29 = (unsigned int *)((char *)v29 + 1);
      }
    }
    return 7;
  }
  v20 = v10;
  if ( v36 < (unsigned int)(v11 + 2) )
    return 5;
  v21 = v39;
  do
  {
    v20 = (unsigned int *)((char *)v20 + 1);
    ++v21;
    v49 = v20;
    *((_BYTE *)&v50 + v21 + 3) = *((_BYTE *)v20 - 1);
  }
  while ( v21 <= 3 && a4 > (unsigned int)v20 );
  v49 = &v51;
  if ( v51 <= 0xFFFF )
  {
    if ( v51 - 55296 > 0x7FF )
    {
      *(_WORD *)v11 = __ROL2__(v51, 8);
      v50 = v11 + 2;
LABEL_54:
      v49 = (unsigned int *)v52;
      v22 = 4;
LABEL_55:
      if ( v39 >= v22 )
        _assert_fail(
          (int)(&GLOBAL_OFFSET_TABLE_ - 16696),
          (int)&GLOBAL_OFFSET_TABLE_ - 167069,
          457,
          (int)&GLOBAL_OFFSET_TABLE_ - 166592);
      v10 = (unsigned int *)(*a3 + v22 - v39);
      *a3 = (int)v10;
      v23 = (int)v50;
      *v40 = v42 & 0xFFFFFFF8;
      v37 = v23;
      v8 = a2[2];
      goto LABEL_10;
    }
    if ( v47 && (v8 & 2) != 0 )
    {
      v49 = (unsigned int *)v52;
      ++*v47;
      v42 = *v40;
      v39 = *v40 & 7;
      v22 = 4;
      goto LABEL_55;
    }
    return 6;
  }
  if ( v51 >> 7 == 7168 )
    goto LABEL_54;
  if ( !v47 )
    return 6;
  if ( (v8 & 8) == 0 )
  {
    v38 = 6;
    v32 = &v51;
    if ( (v8 & 2) == 0 )
      return v38;
    goto LABEL_92;
  }
  v43 = (int *)((char *)&v52[-1] + v21);
  v38 = _gconv_transliterate(a1, (int)a2, (int)v10, &v49, (unsigned int)&v52[-1] + v21, (int *)&v50, v47);
  v31 = &v51;
  v32 = v49;
  if ( v38 == 6 )
  {
    if ( (v8 & 2) == 0 )
    {
LABEL_93:
      if ( v32 == &v51 )
        return 6;
LABEL_94:
      v22 = (char *)v32 - (char *)&v51;
      v42 = *v40;
      v39 = *v40 & 7;
      goto LABEL_55;
    }
LABEL_92:
    v49 = ++v32;
    ++*v47;
    goto LABEL_93;
  }
  if ( v49 != &v51 )
    goto LABEL_94;
  if ( v38 == 7 )
  {
    if ( v43 == v52 )
      _assert_fail(
        (int)(&GLOBAL_OFFSET_TABLE_ - 16692),
        (int)&GLOBAL_OFFSET_TABLE_ - 167069,
        475,
        (int)&GLOBAL_OFFSET_TABLE_ - 166592);
    v33 = *v40 & 0xFFFFFFF8;
    *a3 += v21 - (*v40 & 7);
    if ( (int)v21 <= v33 )
      _assert_fail(
        (int)&GLOBAL_OFFSET_TABLE_ - 166884,
        (int)&GLOBAL_OFFSET_TABLE_ - 167069,
        485,
        (int)&GLOBAL_OFFSET_TABLE_ - 166592);
    if ( v21 > 4 )
      _assert_fail(
        (int)&GLOBAL_OFFSET_TABLE_ - 166844,
        (int)&GLOBAL_OFFSET_TABLE_ - 167069,
        486,
        (int)&GLOBAL_OFFSET_TABLE_ - 166592);
    *v40 = v33 | v21;
    if ( v43 > (int *)&v51 )
    {
      v34 = v40 + 1;
      do
      {
        v31 = (unsigned int *)((char *)v31 + 1);
        v34 = (_DWORD *)((char *)v34 + 1);
        v49 = v31;
        *((_BYTE *)v34 - 1) = *((_BYTE *)v31 - 1);
      }
      while ( v43 != (int *)v31 );
    }
    return 7;
  }
  if ( v38 )
    return v38;
  v8 = a2[2];
  v10 = (unsigned int *)*a3;
  while ( 1 )
  {
LABEL_10:
    v49 = v10;
    v38 = 4;
    v50 = (char *)v37;
    v13 = (char *)v37;
    v41 = v8 & 2;
LABEL_11:
    if ( (unsigned int *)a4 != v10 )
    {
      while ( 1 )
      {
        v14 = v10 + 1;
        if ( a4 < (unsigned int)(v10 + 1) )
        {
          v38 = 7;
          goto LABEL_21;
        }
        v15 = (int)(v13 + 2);
        if ( v36 < (unsigned int)(v13 + 2) )
          break;
        v16 = *v10;
        if ( *v10 > 0xFFFF )
        {
          if ( v16 >> 7 == 7168 )
          {
            v49 = ++v10;
            goto LABEL_11;
          }
          if ( v47 )
          {
            if ( (a2[2] & 8) != 0 )
            {
              v38 = _gconv_transliterate(a1, (int)a2, *a3, &v49, a4, (int *)&v50, v47);
              v13 = v50;
              v10 = v49;
              if ( v38 != 6 )
              {
                if ( v38 != 5 )
                  goto LABEL_11;
                goto LABEL_17;
              }
            }
            if ( v41 )
            {
              ++v10;
              v38 = 6;
              v49 = v10;
              ++*v47;
              goto LABEL_11;
            }
          }
LABEL_34:
          v38 = 6;
LABEL_21:
          *a3 = (int)v10;
          if ( a5 )
            goto LABEL_18;
          goto LABEL_22;
        }
        if ( v16 - 55296 <= 0x7FF )
        {
          if ( v47 && v41 )
          {
            v49 = ++v10;
            ++*v47;
            goto LABEL_11;
          }
          goto LABEL_34;
        }
        ++v10;
        *(_WORD *)v13 = __ROL2__(v16, 8);
        v13 += 2;
        v50 = (char *)v15;
        v49 = v14;
        if ( (unsigned int *)a4 == v14 )
          goto LABEL_17;
      }
      v38 = 5;
      goto LABEL_21;
    }
LABEL_17:
    *a3 = (int)v10;
    if ( a5 )
    {
LABEL_18:
      *a5 = (int)v13;
      return v38;
    }
LABEL_22:
    ++a2[3];
    if ( (a2[2] & 1) != 0 )
      break;
    if ( (unsigned int)v13 <= v37 )
    {
      v18 = v38;
      goto LABEL_27;
    }
    v50 = (char *)*a2;
    dl_mcount_wrapper_check((int)v44);
    v18 = v44(v45, v46, &v50, v13, 0, a6, 0, a8);
    if ( v18 != 4 )
    {
      if ( v13 != v50 )
        *a3 -= 2 * (v13 - v50);
LABEL_27:
      if ( v18 )
        goto LABEL_40;
      goto LABEL_28;
    }
    v18 = v38;
    if ( v38 != 5 && v38 )
    {
LABEL_40:
      v38 = v18;
      goto LABEL_59;
    }
LABEL_28:
    v8 = a2[2];
    v10 = (unsigned int *)*a3;
    v37 = *a2;
  }
  *a2 = (int)v13;
  *a6 += v48;
LABEL_59:
  if ( v38 == 7 && a8 )
  {
    v24 = *a3;
    if ( (int)(a4 - *a3) > 3 )
      _assert_fail(
        (int)&GLOBAL_OFFSET_TABLE_ - 167126,
        (int)&GLOBAL_OFFSET_TABLE_ - 167166,
        777,
        (int)&GLOBAL_OFFSET_TABLE_ - 166528);
    v25 = (unsigned int *)a2[5];
    v26 = v24 + 1;
    v27 = v25 + 1;
    if ( v24 >= a4 )
    {
      v35 = 0;
    }
    else
    {
      while ( 1 )
      {
        *a3 = v26;
        *v27++ = *(_BYTE *)(v26 - 1);
        if ( v26 == a4 )
          break;
        ++v26;
      }
      v35 = v26 - v24;
    }
    *v25 = *v25 & 0xFFFFFFF8 | v35;
  }
  return v38;
}
// 806CD97: conditional instruction was optimized away because %var_78.4 is in (1..4)
// 80CE000: using guessed type _TBYTE GLOBAL_OFFSET_TABLE_;

//----- (0806D330) --------------------------------------------------------
int __cdecl _gconv_transliterate(_DWORD *a1, int a2, int a3, unsigned int **a4, unsigned int a5, int *a6, _DWORD *a7)
{
  unsigned int *v7; // edi
  unsigned int v8; // eax
  _DWORD *v9; // esi
  unsigned int v10; // ecx
  int v11; // esi
  int *v12; // edx
  int v13; // eax
  unsigned int *v14; // eax
  int v15; // esi
  unsigned int v16; // eax
  int v17; // ebp
  unsigned int *v18; // ecx
  unsigned int v19; // edx
  int result; // eax
  int v21; // ebx
  int v22; // eax
  int v23; // edx
  int v24; // ecx
  int v25; // eax
  _DWORD *v26; // esi
  unsigned int v27; // eax
  int v28; // ebx
  int v29; // ebx
  int v30; // esi
  unsigned int v31; // [esp+0h] [ebp-80h]
  unsigned int v32; // [esp+4h] [ebp-7Ch]
  unsigned int v33; // [esp+8h] [ebp-78h]
  int v34; // [esp+24h] [ebp-5Ch]
  int v35; // [esp+28h] [ebp-58h]
  int v36; // [esp+2Ch] [ebp-54h]
  int (__cdecl *v37)(_DWORD *, int, int *, _DWORD *, int *, _DWORD, _DWORD, _DWORD); // [esp+30h] [ebp-50h]
  int v38; // [esp+40h] [ebp-40h]
  int v39; // [esp+44h] [ebp-3Ch]
  int v40; // [esp+48h] [ebp-38h]
  unsigned int v41; // [esp+50h] [ebp-30h]
  int v42; // [esp+58h] [ebp-28h] BYREF
  int v43[9]; // [esp+5Ch] [ebp-24h] BYREF

  v43[1] = __readgsdword(0x14u);
  v7 = *a4;
  v37 = (int (__cdecl *)(_DWORD *, int, int *, _DWORD *, int *, _DWORD, _DWORD, _DWORD))a1[5];
  if ( *a1 )
    v37 = (int (__cdecl *)(_DWORD *, int, int *, _DWORD *, int *, _DWORD, _DWORD, _DWORD))(__readgsdword(0x18u) ^ __ROR4__(a1[5], 9));
  v8 = __readgsdword(0xFFFFFFD0);
  v9 = *(_DWORD **)v8;
  v32 = *(_DWORD *)(*(_DWORD *)v8 + 280);
  if ( v32 )
  {
    if ( a5 >= (unsigned int)(v7 + 1) )
    {
      v31 = 0;
      v36 = v9[71];
      v34 = v9[72];
      v38 = v9[73];
      v39 = v9[74];
      v10 = ((a5 - 1 - (unsigned int)v7) >> 2) + 1;
      while ( 2 )
      {
        v11 = 0;
        v33 = (v32 + v31) >> 1;
        v35 = *(_DWORD *)(v36 + 4 * v33);
        v12 = (int *)(v34 + 4 * v35);
        v13 = *v12;
        while ( v7[v11] == v13 )
        {
          v13 = v12[++v11];
          if ( !v13 )
            goto LABEL_23;
          if ( v11 == v10 )
            return 7;
        }
        if ( v11 )
        {
          if ( v13 )
            return 7;
LABEL_23:
          v40 = v11;
          v41 = v10;
          v21 = *(_DWORD *)(v38 + 4 * v33);
          v22 = *(_DWORD *)(v39 + 4 * v21);
          while ( 1 )
          {
            v23 = 4 * v21;
            v24 = v39 + 4 * v21;
            if ( v22 )
            {
              ++v21;
              v25 = v39 + v23 + 4;
              while ( 1 )
              {
                v26 = (_DWORD *)v25;
                v25 += 4;
                if ( !*v26 )
                  break;
                ++v21;
              }
            }
            else
            {
              v26 = (_DWORD *)(v39 + 4 * v21);
            }
            v42 = v24;
            v43[0] = *a6;
            dl_mcount_wrapper_check((int)v37);
            result = v37(a1, a2, &v42, v26, v43, 0, 0, 0);
            if ( result != 6 )
              break;
            ++v21;
            v22 = *(_DWORD *)(v39 + 4 * v21);
            if ( !v22 )
            {
              v15 = v40;
              v10 = v41;
              v14 = &v7[v40];
              goto LABEL_12;
            }
          }
          if ( result == 4 )
          {
            *a4 += v40;
            ++*a7;
            result = 0;
          }
          else if ( result == 5 )
          {
            return result;
          }
          goto LABEL_46;
        }
        v14 = v7;
        v15 = 0;
LABEL_12:
        if ( a5 <= (unsigned int)v14 || *(_DWORD *)(v34 + 4 * (v35 + v15)) < *v14 )
          v31 = v33 + 1;
        else
          v32 = (v32 + v31) >> 1;
        if ( v31 < v32 )
          continue;
        break;
      }
      v16 = __readgsdword(0xFFFFFFD0);
      v9 = *(_DWORD **)v16;
      v17 = *(_DWORD *)(*(_DWORD *)v16 + 308);
      if ( !v17 )
        goto LABEL_42;
      v18 = (unsigned int *)v9[78];
      v7 = *a4;
      v19 = **a4;
      goto LABEL_35;
    }
    goto LABEL_18;
  }
  v17 = v9[77];
  if ( v17 )
  {
    if ( a5 >= (unsigned int)(v7 + 1) )
    {
      v18 = (unsigned int *)v9[78];
      v19 = *v7;
LABEL_35:
      if ( v17 > 0 )
      {
        v27 = *v18;
        if ( *v18 <= v19 )
        {
          v28 = 0;
          while ( v18[1] < v19 || (v19 - v27) % v18[2] )
          {
            ++v28;
            v18 += 3;
            if ( v28 != v17 )
            {
              v27 = *v18;
              if ( *v18 <= v19 )
                continue;
            }
            goto LABEL_42;
          }
          *a4 = v7 + 1;
          ++*a7;
          return 0;
        }
      }
LABEL_42:
      v29 = v9[75];
      if ( !v29 )
        return 6;
      v30 = v9[76];
      v42 = v30;
      goto LABEL_49;
    }
LABEL_18:
    result = 4;
    if ( v7 != (unsigned int *)a5 )
      return 7;
    return result;
  }
  v29 = v9[75];
  if ( !v29 )
    return 6;
  v30 = v9[76];
  v42 = v30;
  if ( a5 < (unsigned int)(v7 + 1) )
    return 3 * (v7 != (unsigned int *)a5) + 4;
LABEL_49:
  v43[0] = *a6;
  dl_mcount_wrapper_check((int)v37);
  result = v37(a1, a2, &v42, (_DWORD *)(v30 + 4 * v29), v43, 0, 0, 0);
  if ( result != 6 )
  {
    if ( result == 4 )
    {
      ++*a7;
      ++*a4;
      result = 0;
    }
LABEL_46:
    *a6 = v43[0];
  }
  return result;
}

//----- (0806D760) --------------------------------------------------------
int __usercall find_module_idx@<eax>(unsigned __int8 *a1@<eax>, _DWORD *a2@<edx>)
{
  int v2; // ebx
  unsigned int v3; // eax
  unsigned int v4; // ecx
  unsigned int v5; // ebx
  unsigned int v6; // edi
  unsigned int v7; // ebp
  unsigned __int16 *v8; // esi
  int result; // eax
  unsigned int v10; // eax
  unsigned int v11; // [esp+0h] [ebp-38h]
  unsigned int v12; // [esp+4h] [ebp-34h]
  int v13; // [esp+8h] [ebp-30h]
  int v14; // [esp+Ch] [ebp-2Ch]
  int v16; // [esp+14h] [ebp-24h]

  v2 = gconv_cache;
  v14 = *(unsigned __int16 *)(gconv_cache + 4);
  v16 = *(unsigned __int16 *)(gconv_cache + 6);
  v3 = _hash_string(a1);
  v4 = *(unsigned __int16 *)(v2 + 8);
  v13 = v2;
  v5 = v3 % v4;
  v6 = cache_size - *(unsigned __int16 *)(v13 + 4);
  v7 = v4;
  v11 = 4 * (v3 % (v4 - 2) + 1);
  v12 = v3 % (v4 - 2) + 1;
LABEL_2:
  v8 = (unsigned __int16 *)(v13 + v16 + 4 * v5);
  while ( 1 )
  {
    v10 = *v8;
    if ( !(_WORD)v10 )
      return -1;
    if ( v10 < v6 )
    {
      result = strcmp((char *)a1, (_BYTE *)(v13 + v14 + v10));
      if ( !result )
        break;
    }
    v5 += v12;
    v8 = (unsigned __int16 *)((char *)v8 + v11);
    if ( v7 <= v5 )
    {
      v5 -= v7;
      goto LABEL_2;
    }
  }
  *a2 = v8[1];
  return result;
}
// 80CF950: using guessed type int cache_size;
// 80CF954: using guessed type int gconv_cache;

//----- (0806D860) --------------------------------------------------------
int __usercall find_module@<eax>(unsigned int *a1@<eax>, unsigned int *a2@<edx>, int **a3@<ecx>)
{
  int v5; // ecx
  unsigned int v6; // eax
  __int16 v7; // dx
  int *v8; // eax
  int v9; // edx
  _WORD *v10; // eax
  int *shlib; // edx
  int result; // eax
  int *v13; // eax
  int *v14; // ebx
  int *v15; // eax
  int (__cdecl *v16)(int **); // ebx
  void *v17; // esp
  unsigned int *v18; // [esp-1008h] [ebp-1040h]
  _BYTE v19[4]; // [esp-1004h] [ebp-103Ch]
  _BYTE v20[4096]; // [esp-1000h] [ebp-1038h] BYREF
  int v21; // [esp+0h] [ebp-38h] BYREF
  unsigned int *v22; // [esp+4h] [ebp-34h]
  _TBYTE *v23; // [esp+8h] [ebp-30h]
  unsigned int *v24; // [esp+Ch] [ebp-2Ch]
  unsigned int v25; // [esp+1Ch] [ebp-1Ch]

  v24 = a2;
  v23 = &GLOBAL_OFFSET_TABLE_;
  v25 = __readgsdword(0x14u);
  v22 = (unsigned int *)strlen(a1);
  v5 = strlen(v24) + 1;
  v6 = (unsigned int)v22 + v5 + 15;
  v7 = v6 & 0xFFF0;
  v8 = (int *)((char *)&v21 - (v6 & 0xFFFFF000));
  if ( &v21 != v8 )
  {
    while ( v20 != (_BYTE *)v8 )
      ;
  }
  v9 = v7 & 0xFFF;
  if ( v9 )
  {
    v17 = alloca(v9);
    *(_DWORD *)&v19[v9] = *(_DWORD *)&v19[v9];
  }
  v18 = v22;
  v22 = (unsigned int *)v20;
  v21 = v5;
  v10 = mempcpy(v20, a1, (unsigned int)v18);
  memcpy(v10, v24, v21);
  shlib = _gconv_find_shlib(v22);
  *a3 = shlib;
  result = 1;
  if ( shlib )
  {
    v13 = (int *)shlib[3];
    v14 = (int *)shlib[4];
    a3[1] = 0;
    a3[5] = v13;
    v15 = (int *)shlib[5];
    a3[7] = v14;
    a3[8] = v15;
    result = 0;
    a3[6] = 0;
    a3[14] = 0;
    v16 = (int (__cdecl *)(int **))(__readgsdword(0x18u) ^ __ROR4__(v14, 9));
    if ( v16 )
    {
      dl_mcount_wrapper_check((int)v16);
      result = v16(a3);
      a3[6] = (int *)__ROL4__(__readgsdword(0x18u) ^ (unsigned int)a3[6], 9);
    }
  }
  return result;
}
// 80CE000: using guessed type _TBYTE GLOBAL_OFFSET_TABLE_;

//----- (0806D9B0) --------------------------------------------------------
int _gconv_get_cache()
{
  return gconv_cache;
}
// 80CF954: using guessed type int gconv_cache;

//----- (0806D9D0) --------------------------------------------------------
int __usercall _gconv_load_cache@<eax>(unsigned int a1@<ebp>, int *a2@<edi>)
{
  int v2; // esi
  unsigned int v3; // esi
  int v4; // eax
  int result; // eax
  int *v6; // eax
  int *v7; // edi
  unsigned int v8; // eax
  struct stat v9; // [esp+0h] [ebp-80h] BYREF
  unsigned int v10; // [esp+60h] [ebp-20h]

  v10 = __readgsdword(0x14u);
  _gconv_path_envvar = getenv((__int16 *)"GCONV_PATH");
  if ( _gconv_path_envvar )
    return -1;
  v2 = _open_nocancel((int)"/usr/lib/gconv/gconv-modules.cache");
  if ( v2 == -1 )
    return -1;
  if ( (_fxstat64(3, v2, &v9) & 0x80000000) != 0 || v9.st_size <= 0xFu )
    goto LABEL_25;
  cache_size = v9.st_size;
  gconv_cache = mmap(0, v9.st_size, 1, 1, v2, 0);
  if ( gconv_cache != -1 )
    goto LABEL_6;
  a2 = (int *)cache_size;
  v6 = malloc((const struct timespec *)cache_size);
  gconv_cache = (int)v6;
  if ( !v6 )
  {
LABEL_25:
    _close_nocancel(v2);
    return -1;
  }
  a1 = 0;
  while ( 1 )
  {
    v7 = (int *)((char *)a2 - a1);
    v8 = read(v2, (char *)v6 + a1, (size_t)v7);
    if ( v8 == -1 )
    {
      free(a1, v7, gconv_cache);
      gconv_cache = 0;
      goto LABEL_25;
    }
    a2 = (int *)cache_size;
    a1 += v8;
    if ( cache_size <= a1 )
      break;
    v6 = (int *)gconv_cache;
  }
  cache_malloced = 1;
LABEL_6:
  _close_nocancel(v2);
  if ( *(_DWORD *)gconv_cache != 536937252
    || *(unsigned __int16 *)(gconv_cache + 4) >= (unsigned int)cache_size
    || (v3 = *(unsigned __int16 *)(gconv_cache + 6), cache_size <= v3)
    || (v4 = *(unsigned __int16 *)(gconv_cache + 8), !(_WORD)v4)
    || cache_size < v3 + 4 * v4
    || cache_size <= (unsigned int)*(unsigned __int16 *)(gconv_cache + 10)
    || (result = 0, cache_size < (unsigned int)*(unsigned __int16 *)(gconv_cache + 12)) )
  {
    if ( cache_malloced )
    {
      free(a1, a2, gconv_cache);
      cache_malloced = 0;
    }
    else
    {
      munmap((void *)gconv_cache, cache_size);
    }
    gconv_cache = 0;
    return -1;
  }
  return result;
}
// 80CF94C: using guessed type int cache_malloced;
// 80CF950: using guessed type int cache_size;
// 80CF954: using guessed type int gconv_cache;
// 80CFF88: using guessed type int _gconv_path_envvar;

//----- (0806DBE0) --------------------------------------------------------
int __cdecl _gconv_compare_alias_cache(char *a1, unsigned __int8 *a2, int *a3)
{
  int result; // eax
  int v4; // [esp+0h] [ebp-18h] BYREF
  int v5[5]; // [esp+4h] [ebp-14h] BYREF

  v5[1] = __readgsdword(0x14u);
  if ( !gconv_cache )
    return -1;
  if ( find_module_idx((unsigned __int8 *)a1, &v4) || (result = find_module_idx(a2, v5)) != 0 )
  {
    *a3 = strcmp(a1, a2);
    return 0;
  }
  else
  {
    *a3 = v4 - v5[0];
  }
  return result;
}
// 80CF954: using guessed type int gconv_cache;

//----- (0806DC80) --------------------------------------------------------
int __cdecl _gconv_lookup_cache(unsigned __int8 *a1, unsigned __int8 *a2, int ***a3, int *a4, char a5)
{
  int v5; // ebx
  int v6; // ebp
  int module_idx; // esi
  int v9; // eax
  int v10; // edx
  int v11; // ebp
  int v12; // eax
  int *v13; // eax
  int v14; // ebx
  int *v15; // ecx
  int v16; // eax
  unsigned int *v17; // eax
  int v18; // edx
  char *v19; // edx
  int module; // eax
  int v21; // eax
  int *v22; // eax
  int v23; // eax
  unsigned int *v24; // eax
  unsigned int *v25; // edx
  int v26; // ecx
  int v27; // eax
  int *v28; // ebx
  unsigned __int16 *v29; // ebp
  int v30; // esi
  int v31; // eax
  int v32; // esi
  int v33; // eax
  unsigned int *v34; // edx
  unsigned int *v35; // eax
  int v36; // [esp+0h] [ebp-54h]
  int v37; // [esp+0h] [ebp-54h]
  unsigned __int16 v38; // [esp+8h] [ebp-4Ch]
  int v39; // [esp+8h] [ebp-4Ch]
  int v40; // [esp+Ch] [ebp-48h]
  unsigned __int16 *v41; // [esp+Ch] [ebp-48h]
  int v42; // [esp+10h] [ebp-44h]
  unsigned __int16 *v43; // [esp+14h] [ebp-40h]
  int v44; // [esp+18h] [ebp-3Ch]
  unsigned __int16 *v45; // [esp+1Ch] [ebp-38h]
  int *v46; // [esp+20h] [ebp-34h]
  int v47; // [esp+2Ch] [ebp-28h] BYREF
  int v48[9]; // [esp+30h] [ebp-24h] BYREF

  v48[1] = __readgsdword(0x14u);
  v5 = gconv_cache;
  if ( !gconv_cache )
    return 2;
  v6 = *(unsigned __int16 *)(gconv_cache + 10);
  v38 = *(_WORD *)(gconv_cache + 4);
  if ( find_module_idx(a2, &v47) )
    return 1;
  v40 = 4 * (3 * v47 + 3);
  if ( v40 + (unsigned int)*(unsigned __int16 *)(v5 + 10) > cache_size )
    return 1;
  module_idx = find_module_idx(a1, v48);
  if ( module_idx )
    return 1;
  v9 = 4 * (3 * v48[0] + 3);
  if ( v9 + (unsigned int)*(unsigned __int16 *)(v5 + 10) > cache_size )
    return 1;
  v10 = v5 + v6;
  v11 = v47;
  v42 = v10;
  v43 = (unsigned __int16 *)(v10 + v9 - 12);
  if ( (a5 & 1) != 0 && v48[0] == v47 )
    return -1;
  v39 = v5 + v38;
  v12 = v10 + v40 - 12;
  v41 = (unsigned __int16 *)v12;
  if ( v48[0] && v47 )
  {
    v21 = *(unsigned __int16 *)(v12 + 10);
    if ( (_WORD)v21 )
    {
      v11 = gconv_cache + *(unsigned __int16 *)(v5 + 12) + v21 - 1;
      v27 = *(unsigned __int16 *)v11;
      if ( (_WORD)v27 )
      {
        while ( v48[0] != *(unsigned __int16 *)(v11 + 2 * (3 * v27 - 3) + 2) )
        {
          v11 += 6 * v27 + 2;
          v27 = *(unsigned __int16 *)v11;
          if ( !(_WORD)v27 )
            goto LABEL_21;
        }
        *a4 = v27;
        v46 = malloc((const struct timespec *)(60 * v27));
        *a3 = (int **)v46;
        if ( v46 )
        {
          v28 = v46;
          v45 = (unsigned __int16 *)v11;
          v29 = (unsigned __int16 *)(v11 + 2);
          v44 = 0;
          v30 = v39 + *v41;
          while ( 1 )
          {
            v31 = *v29;
            v28[3] = v30;
            v32 = *(unsigned __int16 *)(v42 + 12 * v31);
            v33 = v29[1];
            v34 = (unsigned int *)(v39 + v29[2]);
            v28[2] = 1;
            v28[14] = 0;
            v30 = v39 + v32;
            v35 = (unsigned int *)(v39 + v33);
            v28[4] = v30;
            if ( *(_BYTE *)v35 )
            {
              if ( find_module(v35, v34, (int **)v28) )
              {
                module_idx = 0;
                free((int)v29, (int *)&GLOBAL_OFFSET_TABLE_, (int)v46);
                v11 = v47;
                goto LABEL_11;
              }
            }
            else
            {
              _gconv_get_builtin_trans((char *)v34, v28);
            }
            ++v44;
            v28 += 15;
            v29 += 3;
            if ( *v45 <= v44 )
              return 0;
          }
        }
        return 3;
      }
    }
LABEL_21:
    if ( !v41[2] )
      return 1;
LABEL_22:
    if ( !v43[4] )
      return 1;
LABEL_23:
    v22 = malloc((const struct timespec *)0x78);
    v14 = (int)v22;
    if ( v22 )
    {
      *a3 = (int **)v22;
      *a4 = 0;
      v23 = *v41;
      *(_DWORD *)(v14 + 8) = 1;
      *(_DWORD *)(v14 + 56) = 0;
      *(_DWORD *)(v14 + 12) = v39 + v23;
      *(_DWORD *)(v14 + 16) = "INTERNAL";
      v24 = (unsigned int *)(v39 + v41[3]);
      v25 = (unsigned int *)(v39 + v41[4]);
      if ( *(_BYTE *)v24 )
      {
        module = find_module(v24, v25, (int **)v14);
        if ( module )
          goto LABEL_38;
      }
      else
      {
        _gconv_get_builtin_trans((char *)v25, (_DWORD *)v14);
      }
      v26 = v48[0];
      v11 = *a4 + 1;
      *a4 = v11;
      if ( !v26 )
        return module_idx;
      v15 = (int *)(v14 + 60 * v11);
LABEL_16:
      v15[3] = (int)"INTERNAL";
      v16 = v39 + *v43;
      v15[2] = 1;
      v15[4] = v16;
      v17 = (unsigned int *)(v39 + v43[1]);
      v18 = v43[2];
      v15[14] = 0;
      v19 = (char *)(v39 + v18);
      if ( !*(_BYTE *)v17 )
      {
        _gconv_get_builtin_trans(v19, v15);
        goto LABEL_18;
      }
      module = find_module(v17, (unsigned int *)v19, (int **)v15);
      if ( !module )
      {
LABEL_18:
        ++*a4;
        return module_idx;
      }
      if ( v11 )
      {
        v36 = module;
        _gconv_release_step((int *)v14);
        module = v36;
      }
LABEL_38:
      v37 = module;
      free(v11, (int *)&GLOBAL_OFFSET_TABLE_, v14);
      return v37;
    }
    return 3;
  }
LABEL_11:
  if ( v11 )
  {
    if ( !v41[2] )
      return 1;
    if ( !v48[0] )
      goto LABEL_23;
    goto LABEL_22;
  }
  if ( v48[0] && v43[4] )
  {
    v13 = malloc((const struct timespec *)0x78);
    v14 = (int)v13;
    if ( v13 )
    {
      v15 = v13;
      *a3 = (int **)v13;
      *a4 = 0;
      goto LABEL_16;
    }
    return 3;
  }
  return 1;
}
// 80CE000: using guessed type _TBYTE GLOBAL_OFFSET_TABLE_;
// 80CF950: using guessed type int cache_size;
// 80CF954: using guessed type int gconv_cache;

//----- (0806E100) --------------------------------------------------------
int *__usercall _gconv_release_cache@<eax>(int ebp0@<ebp>, int *a2@<edi>, int a3)
{
  int *result; // eax

  result = (int *)gconv_cache;
  if ( gconv_cache )
    return free(ebp0, a2, a3);
  return result;
}
// 80CF954: using guessed type int gconv_cache;

//----- (0806E140) --------------------------------------------------------
int __cdecl known_compare(char **a1, _BYTE **a2)
{
  return strcmp(*a1, *a2);
}

//----- (0806E160) --------------------------------------------------------
int __usercall do_release_shlib@<eax>(int a1@<ebp>, int *edi0@<edi>, int *a3, int a4)
{
  int result; // eax
  int v5; // ebx

  result = a4;
  if ( !a4 || a4 == 3 )
  {
    v5 = *a3;
    result = *(_DWORD *)(*a3 + 4);
    if ( release_handle == *a3 )
    {
      if ( result <= 0 )
        _assert_fail((int)"obj->counter > 0", (int)"gconv_dl.c", 170, (int)"do_release_shlib");
      *(_DWORD *)(v5 + 4) = --result;
    }
    else if ( (unsigned int)result >= 0xFFFFFFFE || result == 0 )
    {
      *(_DWORD *)(v5 + 4) = --result;
      if ( result == -3 )
      {
        result = *(_DWORD *)(v5 + 8);
        if ( result )
        {
          result = _libc_dlclose(a1, edi0, *(_DWORD *)(v5 + 8));
          *(_DWORD *)(v5 + 8) = 0;
        }
      }
    }
  }
  return result;
}
// 80CF958: using guessed type int release_handle;

//----- (0806E200) --------------------------------------------------------
int *__cdecl _gconv_find_shlib(unsigned int *a1)
{
  int **v1; // eax
  int *v2; // esi
  int v3; // eax
  int v4; // edx
  int v5; // eax
  int v6; // eax
  int v7; // eax
  int v8; // edx
  int *result; // eax
  int *v10; // eax
  _BYTE *v11; // eax
  int v12; // [esp+18h] [ebp-24h]
  unsigned int *v13; // [esp+1Ch] [ebp-20h]

  v1 = (int **)tfind((int)&a1, &loaded, (int (__cdecl *)(int, _DWORD))known_compare);
  if ( v1 )
  {
    v2 = *v1;
    if ( !*v1 )
      return 0;
  }
  else
  {
    v13 = a1;
    v12 = strlen(a1);
    v10 = malloc((const struct timespec *)(v12 + 25));
    v2 = v10;
    if ( !v10 )
      return 0;
    v11 = memcpy((_BYTE *)v10 + 24, v13, v12 + 1);
    v2[1] = -3;
    *v2 = (int)v11;
    v2[2] = 0;
    if ( !tsearch((int)v2, &loaded, (int (__cdecl *)(int, _DWORD))known_compare) )
    {
      free((int)known_compare, &loaded, (int)v2);
      return 0;
    }
  }
  v3 = v2[1];
  v4 = v2[2];
  if ( v3 >= -2 )
  {
    if ( v4 )
    {
      if ( v3 < 0 )
        v3 = 0;
      v2[1] = v3 + 1;
    }
    return v2;
  }
  if ( v4 )
    _assert_fail((int)"found->handle == NULL", (int)"gconv_dl.c", 114, (int)"__gconv_find_shlib");
  v5 = _libc_dlopen_mode((int)known_compare, &loaded, *v2, -2147483646);
  v2[2] = v5;
  if ( v5 )
  {
    v6 = _libc_dlsym((int)known_compare, &loaded, v5, (int)"gconv");
    v2[3] = v6;
    if ( v6 )
    {
      v2[4] = _libc_dlsym((int)known_compare, &loaded, v2[2], (int)"gconv_init");
      v7 = _libc_dlsym((int)known_compare, &loaded, v2[2], (int)"gconv_end");
      v2[1] = 1;
      v8 = __ROL4__(__readgsdword(0x18u) ^ v2[3], 9);
      v2[5] = __ROL4__(__readgsdword(0x18u) ^ v7, 9);
      result = v2;
      v2[3] = v8;
      v2[4] = __ROL4__(__readgsdword(0x18u) ^ v2[4], 9);
      return result;
    }
    release_handle = (int)v2;
    v2 = 0;
    twalk(loaded, (int (__cdecl *)(int, int, int))do_release_shlib);
    return v2;
  }
  return 0;
}
// 80CF958: using guessed type int release_handle;
// 80CF95C: using guessed type int loaded;

//----- (0806E3F0) --------------------------------------------------------
int __cdecl _gconv_release_shlib(int a1)
{
  release_handle = a1;
  return twalk(loaded, (int (__cdecl *)(int, int, int))do_release_shlib);
}
// 80CF958: using guessed type int release_handle;
// 80CF95C: using guessed type int loaded;

//----- (0806E430) --------------------------------------------------------
const char *__usercall new_composite_name@<eax>(int a1@<eax>, char **a2@<edx>)
{
  const struct timespec *v2; // edi
  int v3; // esi
  char *v4; // ebp
  int v5; // ecx
  int v6; // eax
  char *v7; // esi
  int v9; // edx
  int i; // esi
  char *v11; // ebp
  _BYTE *v12; // eax
  _BYTE *v13; // eax
  int *v14; // eax
  _BOOL4 v16; // [esp+4h] [ebp-28h]
  const char *v17; // [esp+4h] [ebp-28h]
  int *v18; // [esp+4h] [ebp-28h]
  int v20; // [esp+Ch] [ebp-20h]
  int v21; // [esp+Ch] [ebp-20h]

  v2 = 0;
  v3 = 0;
  v16 = 1;
  while ( 1 )
  {
    if ( v3 != 6 )
    {
      if ( a1 == 6 )
      {
        v4 = a2[v3];
      }
      else if ( a1 == v3 )
      {
        v4 = *a2;
      }
      else
      {
        v4 = off_80CEEA0[v3];
      }
      v5 = strlen((unsigned int *)v4);
      v2 = (const struct timespec *)((char *)v2 + v5 + (unsigned __int8)nl_category_name_sizes[v3] + 2);
      if ( v16 && *a2 != v4 )
      {
        v20 = v5;
        v6 = strcmp(v4, *a2);
        v5 = v20;
        v16 = v6 == 0;
      }
      if ( v3 == 12 )
        break;
    }
    ++v3;
  }
  v21 = v5;
  if ( v16 )
  {
    v7 = *a2;
    v17 = "C";
    if ( !strcmp(*a2, "C") || !strcmp(v7, "POSIX") )
      return v17;
    v14 = malloc((const struct timespec *)(v21 + 1));
    if ( v14 )
      return memcpy(v14, v7, v21 + 1);
    return 0;
  }
  v18 = malloc(v2);
  v9 = (int)v18;
  if ( !v18 )
    return 0;
  for ( i = 0; ; ++i )
  {
    if ( i != 6 )
    {
      if ( a1 == 6 )
        v11 = a2[i];
      else
        v11 = i == a1 ? *a2 : off_80CEEA0[i];
      v12 = stpcpy(v9, (int)&nl_category_names[(unsigned __int8)nl_category_name_idxs[i]]);
      *v12 = 61;
      v13 = stpcpy((int)(v12 + 1), (int)v11);
      v9 = (int)(v13 + 1);
      *v13 = 59;
      if ( i == 12 )
        break;
    }
  }
  *v13 = 0;
  return (const char *)v18;
}
// 80CEEA0: using guessed type char *off_80CEEA0[13];

//----- (0806E630) --------------------------------------------------------
unsigned int **__cdecl setlocale(unsigned int a1, char *a2)
{
  int *v2; // edi
  unsigned int **v3; // ebp
  unsigned int *v5; // eax
  char *v6; // edx
  int i; // eax
  unsigned int v8; // esi
  unsigned int v9; // ebp
  char **locale; // eax
  char *v11; // edx
  const char *v12; // ebp
  int k; // ebp
  void (__cdecl *v14)(); // edx
  char *v15; // esi
  const char *v16; // edx
  int v17; // eax
  char **v18; // eax
  char *v19; // eax
  void (__cdecl *v20)(); // edx
  char **v21; // esi
  const char *v22; // edx
  int v23; // eax
  unsigned int v24; // eax
  unsigned int m; // esi
  const char *v26; // eax
  int *v27; // eax
  unsigned int v28; // eax
  unsigned int *v29; // esi
  char *v30; // eax
  int v31; // ebp
  int *v32; // edi
  _DWORD *v33; // eax
  int j; // eax
  unsigned int *v35; // [esp+0h] [ebp-B4h]
  int v36; // [esp+0h] [ebp-B4h]
  char *v37; // [esp+0h] [ebp-B4h]
  char *v38; // [esp+0h] [ebp-B4h]
  char *v39; // [esp+0h] [ebp-B4h]
  char *v40; // [esp+4h] [ebp-B0h]
  char **v41; // [esp+8h] [ebp-ACh]
  char *v42; // [esp+8h] [ebp-ACh]
  unsigned int *v43; // [esp+Ch] [ebp-A8h]
  unsigned int *v44; // [esp+10h] [ebp-A4h]
  char **v45; // [esp+14h] [ebp-A0h]
  unsigned int *v46; // [esp+24h] [ebp-90h] BYREF
  unsigned int v47; // [esp+28h] [ebp-8Ch] BYREF
  char *v48[13]; // [esp+2Ch] [ebp-88h] BYREF
  char *v49[21]; // [esp+60h] [ebp-54h] BYREF

  v49[13] = (char *)__readgsdword(0x14u);
  if ( a1 > 0xC )
  {
    v3 = 0;
    __writegsdword(0xFFFFFFE0, 0x16u);
    return v3;
  }
  if ( !a2 )
    return (unsigned int **)off_80CEEA0[a1];
  v2 = (int *)(a1 + 16);
  v3 = (unsigned int **)nl_global_locale[a1 + 16];
  if ( strcmp(a2, v3) )
  {
    v46 = 0;
    v47 = 0;
    v5 = (unsigned int *)getenv((__int16 *)"LOCPATH");
    v6 = a2;
    if ( v5 )
    {
      if ( *(_BYTE *)v5 )
      {
        v3 = &v46;
        if ( argz_create_sep(v5, (int *)0x3A, (unsigned int *)&v46, (int *)&v47) )
          return 0;
        v23 = argz_add_sep((int **)&v46, &v47, (unsigned int *)"/usr/lib/locale", 58);
        v6 = a2;
        if ( v23 )
          return 0;
      }
    }
    if ( a1 == 6 )
    {
      for ( i = 0; ; ++i )
      {
        if ( i != 6 )
        {
          v48[i] = v6;
          if ( i == 12 )
            break;
        }
      }
      v35 = (unsigned int *)v6;
      v44 = strchr(v6, 59);
      if ( v44 )
      {
        v44 = (unsigned int *)strdup(v35);
        v29 = v44;
        if ( !v44 )
          return 0;
LABEL_84:
        v30 = (char *)strchr(v29, 61);
        v42 = v30;
        if ( !v30 )
        {
LABEL_93:
          v32 = (int *)v48;
          for ( j = 0; ; ++j )
          {
            if ( j != 6 )
            {
              if ( v48[j] == (char *)v35 )
                goto LABEL_98;
              if ( j == 12 )
                goto LABEL_13;
            }
          }
        }
        v31 = 0;
        v32 = (int *)(v30 - (char *)v29);
        while ( 1 )
        {
          if ( v31 != 6 )
          {
            if ( (int *)*((unsigned __int8 *)&GLOBAL_OFFSET_TABLE_ + v31 - 165696) == v32
              && !memcmp(
                    v29,
                    (unsigned int *)&nl_category_names[*((unsigned __int8 *)&GLOBAL_OFFSET_TABLE_ + v31 - 165680)],
                    (int)v32) )
            {
              v48[v31] = v42 + 1;
              v33 = strchr(v42 + 1, 59);
              if ( !v33 )
                goto LABEL_93;
              *(_BYTE *)v33 = 0;
              v29 = (_DWORD *)((char *)v33 + 1);
              goto LABEL_84;
            }
            if ( v31 == 12 )
              break;
          }
          ++v31;
        }
LABEL_98:
        v3 = 0;
        free(0, v32, (int)v44);
        __writegsdword(0xFFFFFFE0, 0x16u);
        return v3;
      }
LABEL_13:
      v8 = 13;
LABEL_14:
      while ( 2 )
      {
        v9 = v8 - 1;
        if ( v8 )
        {
          while ( 1 )
          {
            if ( v9 == 6 )
            {
              v8 = 5;
            }
            else
            {
              v28 = v9;
              v9 = v8;
              v8 = v28;
            }
            locale = nl_find_locale(v46, v47, v8, (int *)&v48[v8]);
            v49[v8] = (char *)locale;
            if ( !locale )
            {
              if ( v48[v8] == "C" )
                goto LABEL_14;
              goto LABEL_65;
            }
            if ( locale[6] != (char *)-1 )
              locale[6] = (char *)-1;
            v11 = v48[v8];
            if ( v11 == "C" )
              goto LABEL_14;
            v45 = nl_global_locale[v8 + 16];
            v43 = (unsigned int *)v48[v8];
            if ( strcmp(v11, v45) )
              break;
            v9 = v8 - 1;
            v48[v8] = (char *)v45;
            if ( !v8 )
              goto LABEL_23;
          }
          v27 = strdup(v43);
          v48[v8] = (char *)v27;
          if ( v27 )
            continue;
LABEL_65:
          v24 = v9;
          if ( v9 == 13 )
            goto LABEL_73;
        }
        else
        {
LABEL_23:
          v12 = new_composite_name(6, v48);
          if ( v12 )
          {
            v40 = (char *)v12;
            for ( k = 0; ; ++k )
            {
              if ( k != 6 )
              {
                if ( nl_current_used[k] )
                {
                  nl_global_locale[k] = (char **)v49[k];
                  v14 = (void (__cdecl *)())*(&nl_category_postload + k);
                  if ( v14 )
                    v14();
                }
                v15 = v48[k];
                v16 = off_80CEEA0[k];
                if ( v15 != v16 )
                {
                  if ( v16 != "C" )
                    free(k, (int *)v48, (int)off_80CEEA0[k]);
                  off_80CEEA0[k] = v15;
                }
                if ( k == 12 )
                  break;
              }
            }
            v3 = (unsigned int **)v40;
            if ( v40 != off_80CEEB8[0] )
            {
              if ( off_80CEEB8[0] != "C" )
                free((int)v40, (int *)v48, (int)off_80CEEB8[0]);
              off_80CEEB8[0] = v40;
            }
            ++nl_msg_cat_cntr;
LABEL_74:
            free((int)v3, (int *)v48, (int)v46);
            free((int)v3, (int *)v48, (int)v44);
            return v3;
          }
          v24 = 0;
        }
        break;
      }
      for ( m = v24; ; ++m )
      {
        if ( m != 6 )
        {
          v26 = v48[m];
          if ( v26 != "C" && v26 != off_80CEEA0[m] )
            free((int)"C", (int *)v48, (int)v48[m]);
          if ( m == 12 )
            break;
        }
      }
LABEL_73:
      v3 = 0;
      goto LABEL_74;
    }
    v17 = nl_current_used[a1];
    v49[0] = v6;
    v36 = v17;
    if ( v17 )
    {
      v18 = nl_find_locale(v46, v47, a1, (int *)v49);
      v41 = v18;
      if ( !v18 )
        goto LABEL_79;
      v6 = v49[0];
      if ( v18[6] != (char *)-1 )
        v18[6] = (char *)-1;
    }
    else
    {
      v41 = 0;
    }
    v3 = (unsigned int **)"C";
    if ( v6 == "C" || (v49[0] = (char *)strdup((unsigned int *)v6)) != 0 )
    {
      v19 = (char *)new_composite_name(a1, v49);
      if ( v19 )
      {
        if ( v36 )
        {
          nl_global_locale[a1] = v41;
          v20 = (void (__cdecl *)())*(&nl_category_postload + a1);
          if ( v20 )
          {
            v37 = v19;
            v20();
            v19 = v37;
          }
        }
        v21 = (char **)v49[0];
        v22 = (const char *)nl_global_locale[(_DWORD)v2];
        if ( v49[0] != v22 )
        {
          if ( v22 != "C" )
          {
            v38 = v19;
            free((int)"C", v2, (int)v22);
            v19 = v38;
          }
          nl_global_locale[(_DWORD)v2] = v21;
        }
        if ( v19 != off_80CEEB8[0] )
        {
          if ( off_80CEEB8[0] != "C" )
          {
            v39 = v19;
            free((int)"C", v2, (int)off_80CEEB8[0]);
            v19 = v39;
          }
          off_80CEEB8[0] = v19;
        }
        ++nl_msg_cat_cntr;
        goto LABEL_59;
      }
      if ( v49[0] != "C" )
        free((int)"C", v2, (int)v49[0]);
    }
LABEL_79:
    v49[0] = 0;
LABEL_59:
    free((int)v3, v2, (int)v46);
    return (unsigned int **)v49[0];
  }
  return v3;
}
// 80CDE80: using guessed type int (*nl_category_postload)();
// 80CDEC0: using guessed type int nl_current_used[16];
// 80CE000: using guessed type _TBYTE GLOBAL_OFFSET_TABLE_;
// 80CEE60: using guessed type char **nl_global_locale[6];
// 80CEEA0: using guessed type char *off_80CEEA0[13];
// 80CEEB8: using guessed type char *off_80CEEB8[7];

//----- (0806ED30) --------------------------------------------------------
_BYTE *__usercall strip@<eax>(_BYTE *result@<eax>, char *a2@<edx>)
{
  char v2; // cl
  int v3; // ebp
  int v4; // ecx
  _BYTE *v5; // edx
  int v6; // [esp+2h] [ebp-1Ch]

  v2 = *a2;
  if ( !*a2 )
  {
    v5 = result + 1;
    *result = 47;
LABEL_12:
    *v5 = 47;
    result = v5 + 1;
    goto LABEL_13;
  }
  v3 = 0;
  do
  {
    while ( 1 )
    {
      v6 = v3 + 1;
      if ( v2 != 95 && v2 != 58 && (unsigned __int8)(v2 - 44) > 2u && (byte_80A7940[2 * v2] & 8) == 0 )
        break;
      *result++ = dword_80A7040[v2];
LABEL_4:
      v2 = *++a2;
      if ( !*a2 )
        goto LABEL_10;
    }
    if ( v2 != 47 )
      goto LABEL_4;
    if ( v3 == 2 )
      goto LABEL_13;
    v4 = v3 + 2;
    ++a2;
    *result = 47;
    ++v3;
    v6 = v4;
    v2 = *a2;
    ++result;
  }
  while ( *a2 );
LABEL_10:
  if ( v3 <= 1 )
  {
    v5 = result + 1;
    *result = 47;
    if ( v6 == 1 )
      goto LABEL_12;
    ++result;
  }
LABEL_13:
  *result = 0;
  return result;
}
// 80A7040: using guessed type int dword_80A7040[256];
// 80A7940: using guessed type _BYTE byte_80A7940[512];

//----- (0806EE10) --------------------------------------------------------
char **__cdecl nl_find_locale(unsigned int *a1, unsigned int a2, unsigned int a3, int *a4)
{
  char *v4; // esi
  unsigned int v5; // edi
  char *v6; // eax
  unsigned int **v7; // edx
  unsigned int *v8; // esi
  int **locale_from_archive; // edi
  unsigned int *v11; // eax
  unsigned int *v12; // eax
  unsigned int *v13; // eax
  char *v14; // edi
  int v15; // eax
  int *v16; // esi
  int v17; // ecx
  void *v18; // esp
  unsigned __int8 *v19; // eax
  int v20; // edi
  int *l10nflist; // esi
  int *v22; // edi
  unsigned int *v23; // edi
  int v24; // eax
  _BYTE *v25; // ecx
  int v26; // edx
  void *v27; // esp
  int v28; // eax
  __int16 v29; // cx
  char *v30; // eax
  char *v31; // edx
  int v32; // ecx
  void *v33; // esp
  int *v34; // eax
  int v35; // ecx
  char *v36; // eax
  int v37; // ecx
  int v38; // eax
  unsigned int v39; // eax
  int *v40; // edx
  int *v41; // eax
  int v42; // edx
  int **v43; // ecx
  unsigned int *v44; // eax
  _BYTE *v45; // edx
  int v46; // eax
  _BYTE v47[4]; // [esp-3008h] [ebp-304Ch]
  char v48[4096]; // [esp-3004h] [ebp-3048h] BYREF
  _BYTE v49[4088]; // [esp-2004h] [ebp-2048h] BYREF
  int v50; // [esp-100Ch] [ebp-1050h]
  _BYTE v51[4]; // [esp-1008h] [ebp-104Ch]
  _BYTE v52[4096]; // [esp-1004h] [ebp-1048h] BYREF
  int v53; // [esp-4h] [ebp-48h] BYREF
  unsigned int *v54; // [esp+0h] [ebp-44h]
  unsigned int *v55; // [esp+4h] [ebp-40h]
  unsigned int **v56; // [esp+8h] [ebp-3Ch]
  const char *v57; // [esp+10h] [ebp-34h] BYREF
  unsigned __int8 *v58; // [esp+14h] [ebp-30h] BYREF
  unsigned int *v59; // [esp+18h] [ebp-2Ch] BYREF
  unsigned __int8 *v60; // [esp+1Ch] [ebp-28h] BYREF
  char *v61; // [esp+20h] [ebp-24h] BYREF
  unsigned int *v62[8]; // [esp+24h] [ebp-20h] BYREF
  int savedregs; // [esp+44h] [ebp+0h] BYREF

  v55 = a1;
  v56 = (unsigned int **)a4;
  v4 = (char *)*a4;
  v62[1] = (unsigned int *)__readgsdword(0x14u);
  v57 = v4;
  if ( !*v4 )
  {
    v11 = (unsigned int *)getenv((__int16 *)"LC_ALL");
    v57 = (const char *)v11;
    if ( v11 && *(_BYTE *)v11
      || (v13 = (unsigned int *)getenv((__int16 *)&nl_category_names[(unsigned __int8)nl_category_name_idxs[a3]]),
          (v57 = (const char *)v13) != 0)
      && *(_BYTE *)v13 )
    {
      v12 = (unsigned int *)v57;
    }
    else
    {
      v12 = (unsigned int *)getenv((__int16 *)"LANG");
      v57 = (const char *)v12;
      if ( !v12 )
        goto LABEL_26;
    }
    if ( *(_BYTE *)v12 )
    {
      v4 = (char *)v57;
      goto LABEL_2;
    }
LABEL_26:
    v57 = "C";
    v4 = "C";
  }
LABEL_2:
  if ( !strcmp(v4, "C") || !strcmp(v4, "POSIX") )
  {
    *v56 = (unsigned int *)"C";
    return nl_C[a3];
  }
  v5 = strlen((unsigned int *)v4);
  if ( v5 > 0xFF || memmem(v4, v5, &slashdot_10224, 4u) )
    goto LABEL_17;
  if ( v5 == 2 )
  {
    if ( *v4 == 46 )
    {
      if ( v4[1] == 46 || memchr(v4, 47, 2u) )
        goto LABEL_17;
      goto LABEL_11;
    }
  }
  else if ( v5 > 2
         && (*v4 == 46 && v4[1] == 46 && v4[2] == 47 || v4[v5 - 3] == 47 && v4[v5 - 2] == 46 && v4[v5 - 1] == 46) )
  {
    goto LABEL_17;
  }
  if ( memchr(v4, 47, v5) && *v4 != 47 )
  {
LABEL_17:
    locale_from_archive = 0;
    __writegsdword(0xFFFFFFE0, 0x16u);
    return (char **)locale_from_archive;
  }
LABEL_11:
  v6 = (char *)v57;
  v7 = v56;
  v8 = v55;
  *v56 = (unsigned int *)v57;
  if ( v8 )
  {
    v57 = (const char *)nl_expand_alias((unsigned int)&savedregs, v6);
    v14 = (char *)v57;
    goto LABEL_29;
  }
  locale_from_archive = (int **)nl_load_locale_from_archive(a3, v7);
  if ( locale_from_archive )
    return (char **)locale_from_archive;
  v57 = (const char *)nl_expand_alias((unsigned int)&savedregs, (char *)*v56);
  if ( v57 )
  {
    locale_from_archive = (int **)nl_load_locale_from_archive(a3, (unsigned int **)&v57);
    if ( locale_from_archive )
      return (char **)locale_from_archive;
    v14 = (char *)v57;
    a2 = 16;
    v55 = (unsigned int *)"/usr/lib/locale";
LABEL_29:
    if ( v14 )
      goto LABEL_30;
    goto LABEL_69;
  }
  a2 = 16;
  v55 = (unsigned int *)"/usr/lib/locale";
LABEL_69:
  v14 = (char *)*v56;
  v57 = (const char *)*v56;
LABEL_30:
  v15 = strlen((unsigned int *)v14);
  v16 = (int *)((char *)&v53 - ((v15 + 28) & 0xFFFFF000));
  if ( &v53 != v16 )
  {
    while ( v52 != (_BYTE *)v16 )
      ;
  }
  v17 = ((_WORD)v15 + 28) & 0xFF0;
  if ( (((_WORD)v15 + 28) & 0xFF0) != 0 )
  {
    v18 = alloca(v17);
    *(_DWORD *)&v51[v17] = *(_DWORD *)&v51[v17];
  }
  v19 = memcpy(v52, v14, v15 + 1);
  v20 = nl_explode_name(v19, &v58, &v59, &v60, &v61, v62);
  if ( v20 == -1 )
    return 0;
  v50 = 0;
  v54 = (unsigned int *)&nl_category_names[(unsigned __int8)nl_category_name_idxs[a3]];
  v56 = (unsigned int **)&nl_locale_file_list[a3];
  l10nflist = (int *)nl_make_l10nflist(
                       (unsigned int ***)v56,
                       v55,
                       a2,
                       v20,
                       (unsigned int *)v58,
                       (unsigned int *)v60,
                       (unsigned int *)v61,
                       v62[0],
                       v59,
                       v54,
                       0);
  if ( !l10nflist )
  {
    l10nflist = (int *)nl_make_l10nflist(
                         (unsigned int ***)v56,
                         v55,
                         a2,
                         v20,
                         (unsigned int *)v58,
                         (unsigned int *)v60,
                         (unsigned int *)v61,
                         v62[0],
                         v59,
                         v54,
                         1);
    if ( !l10nflist )
      return 0;
  }
  v22 = (int *)(v20 & 1);
  if ( v22 )
    free((int)&savedregs, v22, (int)v62[0]);
  if ( !l10nflist[1] )
    nl_load_locale(l10nflist, a3);
  locale_from_archive = (int **)l10nflist[2];
  if ( !locale_from_archive )
  {
    v40 = (int *)l10nflist[4];
    if ( !v40 )
    {
LABEL_91:
      l10nflist[4] = 0;
      return (char **)locale_from_archive;
    }
    v41 = l10nflist + 4;
    while ( 1 )
    {
      if ( !v40[1] )
      {
        v56 = (unsigned int **)v41;
        nl_load_locale(v40, a3);
        v41 = (int *)v56;
      }
      v42 = *v41;
      v43 = *(int ***)(*v41 + 8);
      if ( v43 )
        break;
      v40 = (int *)*++v41;
      if ( !*v41 )
        goto LABEL_91;
    }
    l10nflist[4] = v42;
    locale_from_archive = v43;
    l10nflist = (int *)v42;
  }
  if ( v61 )
  {
    v23 = (unsigned int *)locale_from_archive[codeset_idx_10249[a3] + 9];
    if ( !v23 )
      _assert_fail((int)"locale_codeset != NULL", (int)"findlocale.c", 286, (int)"_nl_find_locale");
    v24 = strlen(v23);
    v25 = &v52[-((v24 + 30) & 0xFFFFF000)];
    if ( v52 != v25 )
    {
      while ( v49 != v25 )
        ;
    }
    v26 = ((_WORD)v24 + 30) & 0xFF0;
    if ( (((_WORD)v24 + 30) & 0xFF0) != 0 )
    {
      v27 = alloca(v26);
      *(_DWORD *)&v48[v26 + 4092] = *(_DWORD *)&v48[v26 + 4092];
    }
    v56 = (unsigned int **)v49;
    strip(v49, (char *)v23);
    v55 = (unsigned int *)v61;
    v28 = strlen((unsigned int *)v61);
    v29 = (v28 + 30) & 0xFFF0;
    v30 = &v49[-((v28 + 30) & 0xFFFFF000)];
    v31 = v61;
    if ( v49 != v30 )
    {
      while ( v48 != v30 )
        ;
    }
    v32 = v29 & 0xFFF;
    if ( v32 )
    {
      v33 = alloca(v32);
      *(_DWORD *)&v47[v32] = *(_DWORD *)&v47[v32];
    }
    strip(v48, v31);
    v34 = (int *)v56;
    do
    {
      v34 = (int *)((char *)v34 + 1);
      v35 = dword_80A7040[*((char *)v34 - 1)];
      *((_BYTE *)v34 - 1) = v35;
    }
    while ( (_BYTE)v35 );
    v36 = v48;
    do
    {
      v37 = dword_80A7040[*v36++];
      *(v36 - 1) = v37;
    }
    while ( (_BYTE)v37 );
    if ( _gconv_compare_alias(v48, (int *)v56) )
      return 0;
    locale_from_archive = (int **)l10nflist[2];
  }
  if ( !*locale_from_archive )
  {
    v44 = strrchr((unsigned int *)*l10nflist, 47);
    v45 = (char *)v44 - 1;
    if ( *((_BYTE *)v44 - 2) == 47 )
    {
      v46 = 1;
    }
    else
    {
      do
        --v45;
      while ( *(v45 - 1) != 47 );
      v46 = (char *)v44 - v45;
    }
    *locale_from_archive = strndup(v45, v46);
  }
  if ( v59 )
  {
    v38 = strcasecmp_l((char *)v59, "TRANSLIT", (int)nl_C_locobj);
    locale_from_archive = (int **)l10nflist[2];
    if ( !v38 )
      locale_from_archive[7] = (int *)1;
  }
  else
  {
    locale_from_archive = (int **)l10nflist[2];
  }
  v39 = (unsigned int)locale_from_archive[6];
  if ( v39 <= 0xFFFFFFFD )
    locale_from_archive[6] = (int *)(v39 + 1);
  return (char **)locale_from_archive;
}
// 80A599C: using guessed type unsigned int slashdot_10224;
// 80A59C0: using guessed type int codeset_idx_10249[13];
// 80A7040: using guessed type int dword_80A7040[256];
// 80CDF00: using guessed type char **nl_C[6];
// 80CDF40: using guessed type char **nl_C_locobj[6];
// 80CDF7C: using guessed type int (*off_80CDF7C)[256];
// 80CFFA0: using guessed type int nl_locale_file_list[13];

//----- (0806F4B0) --------------------------------------------------------
void __usercall nl_remove_locale(int a1@<ebp>, int *a2@<edi>, int a3, int a4)
{
  _DWORD *i; // eax

  if ( (*(_DWORD *)(a4 + 24))-- == 1 )
  {
    if ( *(_DWORD *)(a4 + 12) != 2 )
    {
      for ( i = (_DWORD *)nl_locale_file_list[a3]; i[2] != a4; i = (_DWORD *)i[3] )
        ;
      i[1] = 0;
      i[2] = 0;
    }
    nl_unload_locale(a1, a2, a4);
  }
}
// 80CFFA0: using guessed type int nl_locale_file_list[13];

//----- (0806F510) --------------------------------------------------------
int *__cdecl nl_intern_locale_data(unsigned int a1, _DWORD *a2, unsigned int a3)
{
  unsigned int v3; // eax
  unsigned int v4; // edi
  int *result; // eax

  if ( a3 <= 7 )
    goto LABEL_14;
  v3 = 537202711;
  if ( a1 != 3 )
  {
    v3 = a1 ^ 0x20031115;
    if ( !a1 )
      v3 = 537462560;
  }
  if ( *a2 == v3 && (v4 = a2[1], v4 >= nl_category_num_items[a1]) && 4 * v4 + 8 < a3 )
  {
    result = malloc((const struct timespec *)(4 * v4 + 36));
    if ( result )
    {
      result[1] = (int)a2;
      result[5] = 0;
      result[2] = a3;
      result[4] = 0;
      result[6] = 0;
      result[7] = 0;
      result[8] = v4;
      if ( v4 )
      {
        if ( a2[2] <= a3 )
        {
          if ( a1 <= 0xC )
            __asm { jmp     edi }
          _assert_fail((int)"category == LC_CTYPE", (int)"loadlocale.c", 144, (int)"_nl_intern_locale_data");
        }
        free((int)a2, (int *)v4, (int)result);
        __writegsdword(0xFFFFFFE0, 0x16u);
        return 0;
      }
    }
  }
  else
  {
LABEL_14:
    __writegsdword(0xFFFFFFE0, 0x16u);
    return 0;
  }
  return result;
}
// 806F722: conditional instruction was optimized away because esi.4>=Du
// 80A6060: using guessed type int nl_category_num_items[13];

//----- (0806F770) --------------------------------------------------------
unsigned int __cdecl nl_load_locale(int *a1, unsigned int a2)
{
  int v2; // eax
  int *v3; // edi
  _DWORD *v4; // ebx
  int *v5; // eax
  int v6; // edx
  unsigned int **v7; // ecx
  int *v9; // eax
  int *v10; // ebx
  int *v11; // edi
  signed int nocancel; // eax
  unsigned int *v13; // ebx
  int v14; // eax
  int v15; // edi
  int v16; // ecx
  _BYTE *v17; // esi
  __int16 v18; // cx
  int v19; // ecx
  void *v20; // esp
  char *v21; // esi
  _WORD *v22; // eax
  int v23; // edx
  char *v24; // ecx
  int v25; // eax
  _BYTE v27[15]; // [esp+4h] [ebp-10ACh] BYREF
  int v28; // [esp+FF8h] [ebp-B8h]
  _BYTE v29[12]; // [esp+1004h] [ebp-ACh] BYREF
  int *v30; // [esp+1010h] [ebp-A0h]
  int *st_size; // [esp+1014h] [ebp-9Ch]
  struct stat *v32; // [esp+1018h] [ebp-98h]
  unsigned int **v33; // [esp+101Ch] [ebp-94h]
  _TBYTE *v34; // [esp+1020h] [ebp-90h]
  struct stat v35; // [esp+1030h] [ebp-80h] BYREF
  unsigned int v36; // [esp+1090h] [ebp-20h]
  int v37; // [esp+10ACh] [ebp-4h] BYREF

  v34 = &GLOBAL_OFFSET_TABLE_;
  v33 = (unsigned int **)a1;
  v36 = __readgsdword(0x14u);
  a1[2] = 0;
  v28 = 0x80000;
  v2 = _open_nocancel(*a1);
  if ( v2 < 0 )
    return __readgsdword(0x14u) ^ v36;
  v3 = (int *)v2;
  v32 = &v35;
  if ( (_fxstat64(3, v2, &v35) & 0x80000000) != 0 )
    goto LABEL_18;
  if ( (v35.st_mode & 0xF000) == 0x4000 )
  {
    _close_nocancel((int)v3);
    v13 = *v33;
    v14 = strlen(*v33);
    v15 = *((unsigned __int8 *)v34 + a2 - 165696);
    v16 = v14 + v15 + 33;
    v17 = &v29[-(v16 & 0xFFFFF000)];
    v18 = v16 & 0xFFF0;
    if ( v29 != v17 )
    {
      while ( v27 != v17 )
        ;
    }
    v19 = v18 & 0xFFF;
    if ( v19 )
    {
      v20 = alloca(v19);
      *(_DWORD *)&v27[v19 - 4] = *(_DWORD *)&v27[v19 - 4];
    }
    st_size = (int *)v27;
    v21 = (char *)v34 + *((unsigned __int8 *)v34 + a2 - 165680) - 165664;
    v22 = mempcpy(v27, v13, v14);
    v23 = v15 + 1;
    *(_DWORD *)v22 = 1398362927;
    v24 = (char *)v22 + 5;
    *((_BYTE *)v22 + 4) = 95;
    if ( (unsigned int)(v15 + 1) >= 4 )
    {
      *(_DWORD *)((char *)v22 + 5) = *(_DWORD *)v21;
      *(_DWORD *)&v24[v23 - 4] = *(_DWORD *)&v21[v23 - 4];
      qmemcpy(
        (void *)(((unsigned int)v22 + 9) & 0xFFFFFFFC),
        (const void *)(v21 - &v24[-(((unsigned int)v22 + 9) & 0xFFFFFFFC)]),
        4 * ((unsigned int)&v24[v23 - (((unsigned int)v22 + 9) & 0xFFFFFFFC)] >> 2));
    }
    else
    {
      *((_BYTE *)v22 + 5) = *v21;
      if ( (v23 & 2) != 0 )
        *(_WORD *)&v24[v23 - 2] = *(_WORD *)&v21[v23 - 2];
    }
    v25 = _open_nocancel((int)st_size);
    v3 = (int *)v25;
    if ( v25 < 0 )
      return __readgsdword(0x14u) ^ v36;
    if ( (_fxstat64(3, v25, v32) & 0x80000000) != 0 )
    {
LABEL_18:
      _close_nocancel((int)v3);
      return __readgsdword(0x14u) ^ v36;
    }
  }
  v32 = (struct stat *)__readgsdword(0xFFFFFFE0);
  v4 = (_DWORD *)mmap(0, v35.st_size, 1, 2, (int)v3, 0);
  if ( v4 == (_DWORD *)-1 )
  {
    if ( __readgsdword(0xFFFFFFE0) == 38 )
    {
      st_size = (int *)v35.st_size;
      v9 = malloc((const struct timespec *)v35.st_size);
      v30 = v9;
      if ( v9 )
      {
        v10 = st_size;
        if ( (int)st_size <= 0 )
        {
LABEL_30:
          __writegsdword(0xFFFFFFE0, (unsigned int)v32);
          _close_nocancel((int)v3);
          v5 = nl_intern_locale_data(a2, v30, v35.st_size);
          if ( !v5 )
            return __readgsdword(0x14u) ^ v36;
          v6 = 0;
          goto LABEL_8;
        }
        st_size = v3;
        v11 = v9;
        while ( 1 )
        {
          nocancel = _read_nocancel((int)st_size, v11, (size_t)v10);
          if ( nocancel <= 0 )
            break;
          v10 = (int *)((char *)v10 - nocancel);
          v11 = (int *)((char *)v11 + nocancel);
          if ( (int)v10 <= 0 )
          {
            v3 = st_size;
            goto LABEL_30;
          }
        }
        v3 = st_size;
        v33 = (unsigned int **)nocancel;
        free((int)&v37, st_size, (int)v30);
        if ( !v33 )
          __writegsdword(0xFFFFFFE0, 0x16u);
      }
    }
    goto LABEL_18;
  }
  _close_nocancel((int)v3);
  if ( v4 )
  {
    v5 = nl_intern_locale_data(a2, v4, v35.st_size);
    if ( !v5 )
    {
      munmap(v4, v35.st_size);
      return __readgsdword(0x14u) ^ v36;
    }
    v6 = 1;
LABEL_8:
    v7 = v33;
    *v5 = 0;
    v5[3] = v6;
    v7[2] = (unsigned int *)v5;
    v7[1] = (unsigned int *)1;
  }
  return __readgsdword(0x14u) ^ v36;
}
// 806FA12: conditional instruction was optimized away because edi.4<100u
// 80CE000: using guessed type _TBYTE GLOBAL_OFFSET_TABLE_;

//----- (0806FB00) --------------------------------------------------------
int *__usercall nl_unload_locale@<eax>(int a1@<ebp>, int *a2@<edi>, int a3)
{
  void (__cdecl *v3)(int); // eax
  int v4; // eax

  v3 = *(void (__cdecl **)(int))(a3 + 16);
  if ( v3 )
    v3(a3);
  v4 = *(_DWORD *)(a3 + 12);
  if ( v4 )
  {
    if ( v4 == 1 )
    {
      munmap(*(void **)(a3 + 4), *(_DWORD *)(a3 + 8));
      v4 = *(_DWORD *)(a3 + 12);
    }
  }
  else
  {
    free(a1, a2, *(_DWORD *)(a3 + 4));
    v4 = *(_DWORD *)(a3 + 12);
  }
  if ( v4 != 2 )
    free(a1, a2, *(_DWORD *)a3);
  return free(a1, a2, a3);
}

//----- (0806FB90) --------------------------------------------------------
int __cdecl rangecmp(_DWORD *a1, _DWORD *a2)
{
  return *a1 - *a2;
}

//----- (0806FBB0) --------------------------------------------------------
signed int __cdecl nl_load_locale_from_archive(int a1, unsigned int **a2)
{
  unsigned int *v2; // esi
  int v3; // eax
  _DWORD *v4; // ebx
  unsigned int *i; // edi
  _DWORD *v7; // eax
  unsigned int v8; // edi
  unsigned int *v9; // eax
  unsigned __int8 *v10; // edx
  int v11; // ecx
  unsigned int v12; // ebx
  unsigned int v13; // edx
  unsigned int v14; // esi
  unsigned int v15; // ecx
  unsigned int v16; // edi
  signed int v17; // edx
  unsigned int *v18; // eax
  _DWORD *v19; // ebx
  unsigned int v20; // edi
  unsigned int *v21; // ecx
  int v22; // eax
  int v23; // eax
  int v24; // esi
  char *v25; // esi
  int v26; // ecx
  int v27; // edi
  int v28; // edx
  int v29; // ebx
  int v30; // eax
  _TBYTE *v31; // edi
  unsigned int v32; // ebx
  _TBYTE *v33; // eax
  unsigned int v34; // ecx
  char *v35; // edi
  int *v36; // eax
  _BYTE *v37; // ebx
  int v38; // eax
  signed int v39; // edx
  int v40; // eax
  unsigned int v41; // ecx
  unsigned int v42; // ebx
  _BYTE *v43; // edx
  __int16 v44; // bx
  _BYTE *v45; // eax
  signed int v46; // edx
  int v47; // eax
  void *v48; // esp
  _WORD *v49; // eax
  _WORD *v50; // eax
  unsigned int v51; // eax
  _TBYTE *v52; // edi
  int v53; // ecx
  size_t v54; // edi
  _DWORD *v55; // eax
  _DWORD *v56; // ecx
  int v57; // edx
  int v58; // eax
  int v59; // edx
  _TBYTE *v60; // eax
  unsigned int v61; // edx
  _TBYTE *v62; // esi
  int v63; // edi
  unsigned int v64; // eax
  unsigned int *v65; // ebx
  int v66; // edx
  int *j; // edx
  int *v68; // esi
  signed int v69; // edx
  unsigned int v70; // ecx
  unsigned int v71; // eax
  unsigned int v72; // eax
  int v73; // edx
  int v74; // eax
  signed int v75; // ebx
  int *v76; // eax
  int *v77; // esi
  int *v78; // eax
  unsigned int v79; // ebx
  int v80; // eax
  int *v81; // eax
  int v82; // edx
  unsigned int v83; // ebx
  int *v84; // eax
  unsigned int v85; // ecx
  unsigned int v86; // eax
  size_t v87; // edx
  int *v88; // edx
  unsigned int v89; // eax
  char *v90; // edx
  int v91; // esi
  int v92; // eax
  _TBYTE *v93; // eax
  _TBYTE *v94; // eax
  unsigned int v95; // ecx
  unsigned int *v96; // [esp-1014h] [ebp-11F4h]
  _BYTE v97[4]; // [esp-100Ch] [ebp-11ECh]
  _BYTE v98[4084]; // [esp-1008h] [ebp-11E8h] BYREF
  unsigned __int64 v99; // [esp-14h] [ebp-1F4h]
  _BYTE v100[8]; // [esp-8h] [ebp-1E8h] BYREF
  int v101; // [esp+0h] [ebp-1E0h]
  int v102; // [esp+4h] [ebp-1DCh]
  size_t v103; // [esp+8h] [ebp-1D8h]
  int v104; // [esp+Ch] [ebp-1D4h]
  int *v105; // [esp+10h] [ebp-1D0h]
  int v106; // [esp+14h] [ebp-1CCh]
  unsigned int **v107; // [esp+18h] [ebp-1C8h]
  char *v108; // [esp+1Ch] [ebp-1C4h]
  _TBYTE *v109; // [esp+20h] [ebp-1C0h]
  int v110; // [esp+24h] [ebp-1BCh]
  int *v111; // [esp+28h] [ebp-1B8h]
  signed int v112; // [esp+2Ch] [ebp-1B4h]
  unsigned int *v113; // [esp+30h] [ebp-1B0h]
  signed int v114; // [esp+34h] [ebp-1ACh]
  struct stat v115; // [esp+3Ch] [ebp-1A4h] BYREF
  __int64 v116; // [esp+94h] [ebp-14Ch]
  int v117[26]; // [esp+9Ch] [ebp-144h] BYREF
  int v118; // [esp+104h] [ebp-DCh] BYREF
  int v119[54]; // [esp+108h] [ebp-D8h] BYREF
  int savedregs; // [esp+1E0h] [ebp+0h] BYREF

  v107 = a2;
  v2 = *a2;
  v109 = &GLOBAL_OFFSET_TABLE_;
  v119[47] = __readgsdword(0x14u);
  v3 = sysconf(30);
  v4 = (_DWORD *)archloaded;
  v110 = v3;
  if ( archloaded )
  {
    for ( i = *(unsigned int **)(archloaded + 4); i != v2; i = (unsigned int *)v4[1] )
    {
      if ( !strcmp((char *)v2, i) )
        break;
      v4 = (_DWORD *)*v4;
      if ( !v4 )
        goto LABEL_8;
    }
    *v107 = i;
    return v4[a1 + 2];
  }
LABEL_8:
  v7 = strchr(v2, 46);
  if ( v7 && (*((_BYTE *)v7 + 1) & 0xBF) != 0 )
  {
    v35 = (char *)v7 + 1;
    v113 = strchrnul((_DWORD *)((char *)v7 + 1), 64);
    v114 = (char *)v113 - v35;
    v36 = nl_normalize_codeset((unsigned __int8 *)v35, (char *)v113 - v35);
    if ( !v36 )
      return 0;
    v37 = (_BYTE *)v114;
    v114 = (signed int)v36;
    v38 = strncmp((unsigned __int8 *)v36, (unsigned __int8 *)v35, (unsigned int)v37);
    v39 = v114;
    if ( v38 || v37[v114] )
    {
      v111 = (int *)strlen((unsigned int *)v114);
      v40 = strlen(v113);
      v41 = v35 - (char *)v2;
      v112 = v40 + 1;
      v42 = (unsigned int)v111 + v35 - (char *)v2 + v40 + 28;
      v43 = &v100[-(v42 & 0xFFFFF000)];
      v44 = v42 & 0xFFF0;
      v45 = v43;
      v46 = v114;
      if ( v100 != v45 )
      {
        while ( v98 != v45 )
          ;
      }
      v47 = v44 & 0xFFF;
      if ( (v44 & 0xFFF) != 0 )
      {
        v48 = alloca(v47);
        *(_DWORD *)&v97[v47] = *(_DWORD *)&v97[v47];
      }
      v35 = (char *)v109;
      v114 = v46;
      v96 = v2;
      v2 = (unsigned int *)v98;
      v49 = mempcpy(v98, v96, v41);
      v50 = mempcpy(v49, (_BYTE *)v114, (unsigned int)v111);
      memcpy(v50, v113, v112);
      v39 = v114;
    }
    free((int)&savedregs, (int *)v35, v39);
  }
  if ( *((_DWORD *)v109 + 1668) )
  {
    v111 = (int *)*((_DWORD *)v109 + 1664);
    if ( !v111 )
      return 0;
    goto LABEL_12;
  }
  v52 = v109;
  LODWORD(v99) = 557056;
  *((_DWORD *)v109 + 1668) = (char *)v109 + 6656;
  v53 = _open_nocancel((int)v52 - 163516);
  v104 = v53;
  if ( v53 < 0 )
    return 0;
  if ( _fxstat64(3, v53, (struct stat *)(v52 + 656)) == -1 )
    goto LABEL_38;
  v54 = *((_DWORD *)v109 + 1651);
  if ( *(__int64 *)((char *)v109 + 6604) > 0x200000 )
    v54 = 0x200000;
  v55 = (_DWORD *)mmap64(0, v54, 1, 2, v104, 0LL);
  v56 = v55;
  v111 = v55;
  if ( v55 == (_DWORD *)-1 )
    goto LABEL_38;
  v57 = v55[2] + 12 * v55[4];
  v58 = v55[8] + 108 * v55[9];
  if ( v57 >= v58 )
    v58 = v57;
  v59 = v56[5] + v56[6];
  if ( v58 >= v59 )
    v59 = v58;
  if ( v54 >= v59 )
  {
    v60 = v109;
    if ( v54 < *(__int64 *)((char *)v109 + 6604) )
    {
      v61 = (unsigned int)v111;
      *((_DWORD *)v109 + 1666) = v54;
      *((_DWORD *)v60 + 1664) = v61;
      goto LABEL_13;
    }
    _close_nocancel(v104);
    v93 = v109;
    *((_DWORD *)v109 + 1664) = v111;
    *((_DWORD *)v93 + 1666) = v54;
    goto LABEL_12;
  }
  v114 = v59;
  munmap(v56, v54);
  v31 = v109;
  if ( *(_QWORD *)((char *)v109 + 6604) < (__int64)(unsigned int)v114 )
    goto LABEL_38;
  v32 = -v110 & (v110 + v114 - 1);
  v111 = (int *)mmap64(0, v32, 1, 2, v104, 0LL);
  if ( v111 == (int *)-1 )
    goto LABEL_38;
  if ( v32 >= *(__int64 *)((char *)v31 + 6604) )
  {
    _close_nocancel(v104);
    v94 = v109;
    v95 = (unsigned int)v111;
    *((_DWORD *)v109 + 1664) = v111;
    *((_DWORD *)v94 + 1666) = v32;
    if ( !v95 )
      return 0;
LABEL_12:
    v104 = -1;
    goto LABEL_13;
  }
  v33 = v109;
  v34 = (unsigned int)v111;
  *((_DWORD *)v109 + 1666) = v32;
  *((_DWORD *)v33 + 1664) = v34;
  if ( !v34 )
    goto LABEL_38;
LABEL_13:
  v8 = strlen(v2);
  if ( v8 )
  {
    v9 = v2;
    v10 = (unsigned __int8 *)v2 + v8;
    do
    {
      v11 = *(unsigned __int8 *)v9;
      v9 = (unsigned int *)((char *)v9 + 1);
      v8 = v11 + __ROL4__(v8, 9);
    }
    while ( v10 != (unsigned __int8 *)v9 );
    if ( !v8 )
      v8 = -1;
  }
  else
  {
    v8 = -1;
  }
  v12 = v111[4];
  v106 = v111[2];
  if ( !v12 )
    goto LABEL_32;
  v113 = (unsigned int *)v12;
  v108 = (char *)v2;
  v13 = v8 % (v12 - 2);
  v14 = v8 % v12;
  v15 = v8;
  v16 = v12;
  v17 = v13 + 1;
  v114 = 12 * v17;
LABEL_20:
  v18 = (unsigned int *)v16;
  v19 = (int *)((char *)&v111[3 * v14] + v106);
  v20 = v15;
  v21 = v18;
  while ( 1 )
  {
    v22 = v19[1];
    if ( !v22 )
      goto LABEL_32;
    if ( *v19 == v20 )
    {
      v112 = v17;
      v113 = v21;
      v23 = strcmp(v108, (_BYTE *)v111 + v22);
      v21 = v113;
      v17 = v112;
      if ( !v23 )
        break;
    }
    v14 += v17;
    v19 = (_DWORD *)((char *)v19 + v114);
    if ( (unsigned int)v21 <= v14 )
    {
      v51 = (unsigned int)v21;
      v15 = v20;
      v14 -= v51;
      v16 = v51;
      goto LABEL_20;
    }
  }
  v24 = v19[2];
  v113 = 0;
  if ( !v24 )
  {
LABEL_32:
    if ( v104 < 0 )
      return 0;
LABEL_38:
    _close_nocancel(v104);
    return 0;
  }
  v25 = (char *)v111 + v24;
  v26 = 0;
  v27 = 0;
  while ( 1 )
  {
    v114 = v27 + 1;
    v30 = v26 + 1;
    if ( v26 != 6 )
      break;
    v114 = v27;
LABEL_28:
    v27 = v114;
    ++v26;
  }
  v28 = 4 * v27;
  v119[v28 - 1] = *(_DWORD *)&v25[8 * v30 - 4];
  v29 = *(_DWORD *)&v25[8 * v30];
  v119[v28 + 1] = v26;
  v119[v28] = v29;
  v119[v28 + 2] = 0;
  if ( v26 != 12 )
    goto LABEL_28;
  v62 = v109;
  v112 = v27;
  v108 = (char *)&v118;
  qsort(
    v27 + 1,
    (int)&savedregs,
    v27,
    (int)v109,
    (char *)&v118,
    v27 + 1,
    0x10u,
    (int (__cdecl *)(char *, char *, int))(v109 - 38616));
  v111 = (int *)*((_DWORD *)v62 + 1668);
  v106 = v110 - 1;
  v101 = v110 & (v110 - 1);
  v105 = v111;
  v63 = (int)v113;
  do
  {
    if ( !v105 )
    {
      v68 = 0;
      v105 = v111;
      goto LABEL_69;
    }
    v64 = v105[1];
    v65 = (unsigned int *)v119[4 * v63 - 1];
    v66 = v105[2];
    v114 = v119[4 * v63];
    if ( (unsigned int)v65 + v114 < v64 + v66 )
    {
      v68 = v105;
      if ( (unsigned int)v65 >= v64 )
      {
        v105 = v111;
        goto LABEL_79;
      }
      v105 = v111;
LABEL_69:
      if ( v101 )
        _assert_fail((int)v109 - 163655, (int)v109 - 163669, 376, (int)v109 - 163548);
      v69 = v63;
      v102 = v63;
      v70 = v119[4 * v63 - 1];
      v103 = v70;
      v114 = -v110;
      v113 = (unsigned int *)*((_DWORD *)v109 + 1651);
      v111 = v119;
      while ( 1 )
      {
        v72 = v70 + v111[4 * v69];
        if ( (unsigned int)v113 < v72 )
          goto LABEL_32;
        v71 = v114 & (v106 + v72);
        if ( v68 )
        {
          if ( v68[1] <= v70 )
            break;
        }
        if ( v69 >= v112 || (v70 = *(_DWORD *)&v108[16 * v69 + 16], v70 >= v71 + v110) )
        {
          v113 = (unsigned int *)(v69 + 1);
          v63 = v102;
          v83 = v71;
LABEL_95:
          if ( v104 != -1 )
            goto LABEL_96;
          LODWORD(v99) = 557056;
          v104 = _open_nocancel((int)v109 - 163516);
          if ( v104 == -1 )
            return 0;
          if ( (_fxstat64(3, v104, &v115) & 0x80000000) == 0
            && *(_QWORD *)((char *)v109 + 6604) == *(_QWORD *)&v115.st_size
            && v115.st_ctim.tv_sec == *((_DWORD *)v109 + 1658)
            && *((_QWORD *)v109 + 820) == v115.st_dev
            && *((_QWORD *)v109 + 831) == v116 )
          {
LABEL_96:
            v99 = v114 & v103;
            v103 = v83 - (v114 & v103);
            v102 = v99;
            v114 = mmap64(0, v103, 1, 2, v104, v99);
            if ( v114 == -1 )
              goto LABEL_32;
            v84 = malloc((const struct timespec *)0x10);
            v85 = v102;
            v111 = v84;
            if ( !v84 )
            {
              munmap((void *)v114, v103);
              goto LABEL_32;
            }
            v86 = (unsigned int)v111;
            *v111 = v114;
            v87 = v103;
            *(_DWORD *)(v86 + 4) = v85;
            *(_DWORD *)(v86 + 8) = v87;
            if ( (int *)v105[3] != v68 )
              _assert_fail((int)v109 - 163641, (int)v109 - 163669, 434, (int)v109 - 163548);
            v88 = v105;
            v89 = (unsigned int)v111;
            v75 = v63;
            v105 = v68;
            v111[3] = (int)v68;
            v88[3] = v89;
            v90 = &v108[16 * v63];
            while ( 1 )
            {
              v92 = *(_DWORD *)v90;
              if ( *(_DWORD *)v90 < v85 )
                _assert_fail((int)(v109 - 16362), (int)v109 - 163669, 442, (int)v109 - 163548);
              v91 = *((_DWORD *)v90 + 2);
              ++v63;
              v90 += 16;
              v117[2 * v91] = v114 + v92 - v85;
              v117[2 * v91 + 1] = *((_DWORD *)v90 - 3);
              if ( (int)v113 <= v63 )
                break;
              v75 = v63;
            }
            goto LABEL_80;
          }
          goto LABEL_32;
        }
        ++v69;
      }
      v63 = v102;
      v83 = v71;
      v113 = (unsigned int *)v69;
      goto LABEL_95;
    }
    v113 = v65;
    for ( j = v105; ; j = (int *)j[3] )
    {
      v68 = (int *)j[3];
      if ( !v68 )
      {
        v105 = j;
        goto LABEL_69;
      }
      v64 = v68[1];
      if ( v64 + v68[2] > (unsigned int)v65 + v114 )
        break;
    }
    v65 = v113;
    v105 = j;
    if ( v64 > (unsigned int)v113 )
      goto LABEL_69;
LABEL_79:
    v73 = v119[4 * v63 + 1];
    v74 = (int)v65 + *v68 - v64;
    v75 = v63++;
    v117[2 * v73] = v74;
    v117[2 * v73 + 1] = v114;
    v76 = v105;
    v105 = v68;
    v111 = v76;
LABEL_80:
    ;
  }
  while ( v75 < v112 );
  if ( v104 >= 0 )
    _close_nocancel(v104);
  v77 = malloc((const struct timespec *)0x3C);
  if ( !v77 )
    return 0;
  v78 = strdup(*v107);
  v77[1] = (int)v78;
  if ( v78 )
  {
    v79 = 0;
    v80 = *((_DWORD *)v109 + 1632);
    *((_DWORD *)v109 + 1632) = v77;
    *v77 = v80;
    while ( 1 )
    {
      if ( v79 != 6 )
      {
        v81 = nl_intern_locale_data(v79, (_DWORD *)v117[2 * v79], v117[2 * v79 + 1]);
        v77[v79 + 2] = (int)v81;
        if ( v81 )
        {
          v82 = v77[1];
          v81[3] = 2;
          v81[6] = -1;
          *v81 = v82;
        }
        if ( v79 == 12 )
          break;
      }
      ++v79;
    }
    *v107 = (unsigned int *)v77[1];
    return v77[a1 + 2];
  }
  else
  {
    v114 = 0;
    free((int)&savedregs, (int *)v63, (int)v77);
    return v114;
  }
}
// 80CE000: using guessed type _TBYTE GLOBAL_OFFSET_TABLE_;
// 80CF980: using guessed type int archloaded;

//----- (08070760) --------------------------------------------------------
int nl_postload_ctype()
{
  int result; // eax
  char (*v1)[512]; // ebx
  int (*v2)[256]; // edx
  int (*v3)[256]; // ecx

  result = (int)&GLOBAL_OFFSET_TABLE_;
  v1 = (char (*)[512])(nl_global_locale[0][9] + 256);
  v2 = (int (*)[256])(nl_global_locale[0][12] + 512);
  v3 = (int (*)[256])(nl_global_locale[0][10] + 512);
  off_80CEE94 = v1;
  off_80CEE98[0] = v2;
  off_80CEE9C = v3;
  if ( (char ***)__readgsdword(0xFFFFFFD4) == nl_global_locale )
  {
    __writegsdword(0xFFFFFFF8, (unsigned int)v1);
    result = -16;
    __writegsdword(0xFFFFFFF4, (unsigned int)v3);
    __writegsdword(0xFFFFFFF0, (unsigned int)v2);
  }
  return result;
}
// 80CE000: using guessed type _TBYTE GLOBAL_OFFSET_TABLE_;
// 80CEE60: using guessed type char **nl_global_locale[6];
// 80CEE94: using guessed type char (*off_80CEE94)[512];
// 80CEE98: using guessed type int (*off_80CEE98[2])[256];
// 80CEE9C: using guessed type int (*off_80CEE9C)[256];

//----- (080707E0) --------------------------------------------------------
int __cdecl _current_locale_name(int a1)
{
  return *(_DWORD *)(__readgsdword(0xFFFFFFD4) + 4 * a1 + 64);
}

//----- (08070800) --------------------------------------------------------
unsigned int _ctype_b_loc()
{
  return __readgsdword(0) - 8;
}

//----- (08070820) --------------------------------------------------------
unsigned int _ctype_toupper_loc()
{
  return __readgsdword(0) - 12;
}

//----- (08070840) --------------------------------------------------------
unsigned int _ctype_tolower_loc()
{
  return __readgsdword(0) - 16;
}

//----- (08070860) --------------------------------------------------------
unsigned int _ctype_init()
{
  _DWORD *v0; // edx
  unsigned int result; // eax

  v0 = *(_DWORD **)__readgsdword(0xFFFFFFD0);
  __writegsdword(0xFFFFFFF8, v0[9] + 256);
  __writegsdword(0xFFFFFFF4, v0[10] + 512);
  result = v0[12] + 512;
  __writegsdword(0xFFFFFFF0, result);
  return result;
}

//----- (080708C0) --------------------------------------------------------
unsigned int __cdecl _setfpucw(__int16 a1)
{
  unsigned int v2; // [esp+6h] [ebp-10h]

  v2 = __readgsdword(0x14u);
  if ( (dl_x86_cpu_features[5] & 0x2000000) != 0 )
    _mm_setcsr(_mm_getcsr() & 0xFFFF817F | (8 * a1) & 0x6000 | (a1 << 7) & 0x1E80);
  return __readgsdword(0x14u) ^ v2;
}
// 80CF8E0: using guessed type _DWORD dl_x86_cpu_features[22];

//----- (08070960) --------------------------------------------------------
__int64 __cdecl raise(int a1)
{
  int v1; // eax
  unsigned int v2; // eax
  int v3; // edi
  __int64 result; // rax
  char v5[128]; // [esp+0h] [ebp-120h] BYREF
  int v6[32]; // [esp+80h] [ebp-A0h] BYREF
  unsigned int v7; // [esp+100h] [ebp-20h]

  v7 = __readgsdword(0x14u);
  qmemcpy(v6, &unk_80B1B80, sizeof(v6));
  v6[0] = 0x7FFFFFFF;
  v6[1] = -2;
  ((void (__fastcall *)(int *, char *))__readgsdword(0x10u))(v6, v5);
  ((void (*)(void))__readgsdword(0x10u))();
  v1 = ((int (*)(void))__readgsdword(0x10u))();
  v2 = ((int (__fastcall *)(int, int))__readgsdword(0x10u))(v1, a1);
  v3 = v2;
  if ( v2 > 0xFFFFF000 )
    v3 = _syscall_error(v2);
  ((void (__fastcall *)(char *, _DWORD))__readgsdword(0x10u))(v5, 0);
  HIDWORD(result) = __readgsdword(0x14u) ^ v7;
  LODWORD(result) = v3;
  return result;
}

//----- (08070A60) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
int __cdecl annobin_sigaction_c(int a1, int *a2, _DWORD *a3)
{
  __asm
  {
    int     80h; LINUX - sys_rt_sigreturn
    int     80h; LINUX - sys_sigreturn
  }
  return _libc_sigaction(a1, a2, a3);
}
// 8070A69: positive sp value 4 has been found

//----- (08070A70) --------------------------------------------------------
int __cdecl _libc_sigaction(int a1, int *a2, _DWORD *a3)
{
  int *v3; // ecx
  int v4; // eax
  int *v5; // edx
  int result; // eax
  int v7; // edx
  bool v8; // zf
  unsigned int (__cdecl *v9)(int, int *, _DWORD *); // eax
  int v10; // [esp+0h] [ebp-138h] BYREF
  int v11; // [esp+4h] [ebp-134h]
  unsigned int (__cdecl *v12)(int, int *, _DWORD *); // [esp+8h] [ebp-130h]
  char v13[128]; // [esp+Ch] [ebp-12Ch] BYREF
  int v14[3]; // [esp+8Ch] [ebp-ACh] BYREF
  int v15[40]; // [esp+98h] [ebp-A0h] BYREF

  v3 = 0;
  v15[32] = __readgsdword(0x14u);
  if ( a2 )
  {
    v10 = *a2;
    v4 = a2[33];
    qmemcpy(v13, a2 + 1, sizeof(v13));
    v11 = v4;
    if ( dl_sysinfo_dso )
    {
      v12 = 0;
    }
    else
    {
      v7 = v4 | 0x4000000;
      v8 = (v4 & 4) == 0;
      v9 = annobin_sigaction_c;
      v11 = v7;
      if ( v8 )
        v9 = (unsigned int (__cdecl *)(int, int *, _DWORD *))&_restore;
      v12 = v9;
    }
    v3 = &v10;
  }
  v5 = 0;
  if ( a3 )
    v5 = v14;
  result = ((int (__fastcall *)(int *, int *))__readgsdword(0x10u))(v3, v5);
  if ( (unsigned int)result > 0xFFFFF000 )
    result = _syscall_error(result);
  if ( a3 )
  {
    if ( result >= 0 )
    {
      *a3 = v14[0];
      a3[1] = v15[0];
      a3[32] = v15[31];
      qmemcpy(
        (void *)((unsigned int)(a3 + 2) & 0xFFFFFFFC),
        (const void *)((char *)v15 - ((char *)a3 - ((unsigned int)(a3 + 2) & 0xFFFFFFFC) + 4)),
        4 * (((unsigned int)a3 - ((unsigned int)(a3 + 2) & 0xFFFFFFFC) + 132) >> 2));
      a3[33] = v14[1];
      a3[34] = v14[2];
    }
  }
  return result;
}
// 80CFF44: using guessed type int dl_sysinfo_dso;

//----- (08070BE0) --------------------------------------------------------
int __cdecl sigaction(int a1, int *a2, _DWORD *a3)
{
  if ( (unsigned int)(a1 - 1) <= 0x3F && (unsigned int)(a1 - 32) > 1 )
    return _libc_sigaction(a1, a2, a3);
  __writegsdword(0xFFFFFFE0, 0x16u);
  return -1;
}

//----- (08070C30) --------------------------------------------------------
unsigned int __cdecl sigprocmask(int a1, _BYTE *a2, int a3)
{
  int *v3; // ecx
  unsigned int result; // eax
  int v5; // eax
  int v6[36]; // [esp+Ch] [ebp-90h] BYREF

  v3 = 0;
  v6[32] = __readgsdword(0x14u);
  if ( a2 )
  {
    if ( *(int *)a2 < 0 || (a2[4] & 1) != 0 )
    {
      v5 = *(_DWORD *)a2 & 0x7FFFFFFF;
      qmemcpy(v6, a2, 0x80u);
      v6[0] = v5;
      v3 = v6;
      v6[1] &= ~1u;
    }
    else
    {
      v3 = (int *)a2;
    }
  }
  result = ((int (__fastcall *)(int *, int))__readgsdword(0x10u))(v3, a3);
  if ( result > 0xFFFFF000 )
    return _syscall_error(result);
  return result;
}

//----- (08070CE0) --------------------------------------------------------
unsigned int __cdecl quicksort(
        char *a1,
        unsigned int a2,
        unsigned int a3,
        int (__cdecl *a4)(char *, char *, int),
        int a5)
{
  char *v5; // esi
  char *v6; // ebx
  unsigned int v7; // eax
  char *v8; // edx
  char *v9; // ebx
  char *v10; // eax
  char *v11; // esi
  char *v12; // eax
  char *v13; // esi
  char v14; // cl
  char v15; // dl
  char *v16; // esi
  unsigned int v17; // ebx
  unsigned int v18; // eax
  char *v19; // ebx
  unsigned int v20; // esi
  int i; // eax
  unsigned int v22; // eax
  char *v23; // edi
  char *v24; // edx
  char *v25; // eax
  char *v26; // eax
  char *v28; // eax
  char *v29; // edx
  char v30; // cl
  char v31; // bl
  _DWORD *v32; // esi
  char *v33; // edx
  char *v34; // eax
  char v35; // cl
  char v36; // bl
  char *v37; // edx
  char *v38; // eax
  char v39; // cl
  char v40; // bl
  char *v41; // edx
  char *v42; // eax
  char v43; // cl
  char v44; // bl
  _DWORD *v45; // eax
  char *v46; // edx
  char *v47; // [esp+0h] [ebp-15Ch]
  char *v48; // [esp+4h] [ebp-158h]
  char v49; // [esp+4h] [ebp-158h]
  char *v50; // [esp+4h] [ebp-158h]
  char *v51; // [esp+8h] [ebp-154h]
  char *v52; // [esp+Ch] [ebp-150h]
  char *v53; // [esp+10h] [ebp-14Ch]
  char *v54; // [esp+14h] [ebp-148h]
  unsigned int v55; // [esp+14h] [ebp-148h]
  char *v56; // [esp+18h] [ebp-144h]
  char *v57; // [esp+1Ch] [ebp-140h]
  char *v58; // [esp+20h] [ebp-13Ch]
  unsigned int v59; // [esp+24h] [ebp-138h]
  int v60[2]; // [esp+3Ch] [ebp-120h] BYREF
  char v61; // [esp+44h] [ebp-118h] BYREF
  unsigned int v62; // [esp+13Ch] [ebp-20h]

  v62 = __readgsdword(0x14u);
  if ( !a2 )
    return __readgsdword(0x14u) ^ v62;
  v59 = 4 * a3;
  v57 = &a1[a3 * (a2 - 1)];
  if ( a2 <= 4 )
    goto LABEL_18;
  v60[0] = 0;
  v60[1] = 0;
  v54 = &a1[a3 * (a2 - 1)];
  v58 = &v61;
  v56 = a1;
  do
  {
    v5 = &v56[a3 * (((v54 - v56) / a3) >> 1)];
    if ( a4(v5, v56, a5) < 0 )
    {
      v41 = v56;
      v42 = &v56[a3 * (((v54 - v56) / a3) >> 1)];
      do
      {
        v43 = *v42;
        v44 = *v41;
        ++v42;
        ++v41;
        *(v42 - 1) = v44;
        *(v41 - 1) = v43;
      }
      while ( v42 != &v5[a3] );
    }
    if ( a4(v54, v5, a5) < 0 )
    {
      v33 = v54;
      v34 = &v56[a3 * (((v54 - v56) / a3) >> 1)];
      v50 = &v5[a3];
      do
      {
        v35 = *v34;
        v36 = *v33;
        ++v34;
        ++v33;
        *(v34 - 1) = v36;
        *(v33 - 1) = v35;
      }
      while ( v34 != v50 );
      if ( a4(v5, v56, a5) < 0 )
      {
        v37 = v56;
        v38 = &v56[a3 * (((v54 - v56) / a3) >> 1)];
        do
        {
          v39 = *v38;
          v40 = *v37;
          ++v38;
          ++v37;
          *(v38 - 1) = v40;
          *(v37 - 1) = v39;
        }
        while ( v38 != v50 );
      }
    }
    v48 = &v56[a3];
    v6 = &v54[-a3];
    while ( 1 )
    {
      while ( a4(v48, v5, a5) < 0 )
        v48 += a3;
      while ( a4(v5, v6, a5) < 0 )
        v6 -= a3;
      if ( v48 < v6 )
      {
        v28 = v48;
        v53 = v6;
        v29 = v6;
        do
        {
          v30 = *v28;
          v31 = *v29;
          ++v28;
          ++v29;
          *(v28 - 1) = v31;
          *(v29 - 1) = v30;
        }
        while ( v28 != &v48[a3] );
        if ( v48 == v5 )
        {
          v5 = v53;
        }
        else if ( v53 == v5 )
        {
          v5 = v48;
        }
        v6 = &v53[-a3];
        v48 += a3;
        goto LABEL_13;
      }
      if ( v48 == v6 )
        break;
LABEL_13:
      if ( v48 > v6 )
        goto LABEL_14;
    }
    v6 -= a3;
    v48 += a3;
LABEL_14:
    v7 = v54 - v48;
    if ( v6 - v56 > v59 )
    {
      if ( v59 >= v7 )
      {
        v54 = v6;
      }
      else
      {
        v32 = v58;
        if ( v6 - v56 <= (int)v7 )
        {
          v45 = v58;
          v58 += 8;
          *v45 = v48;
          v46 = v54;
          v54 = v6;
          v45[1] = v46;
        }
        else
        {
          *((_DWORD *)v58 + 1) = v6;
          v58 += 8;
          *v32 = v56;
          v56 = v48;
        }
      }
    }
    else
    {
      v56 = v48;
      if ( v59 >= v7 )
      {
        v56 = (char *)*((_DWORD *)v58 - 2);
        v8 = (char *)*((_DWORD *)v58 - 1);
        v58 -= 8;
        v54 = v8;
      }
    }
  }
  while ( v58 > (char *)v60 );
LABEL_18:
  v9 = a1;
  v10 = &a1[v59];
  if ( v57 < &a1[v59] )
    v10 = &a1[a3 * (a2 - 1)];
  v11 = &a1[a3];
  v47 = v10;
  if ( v10 >= &a1[a3] )
  {
    do
    {
      if ( a4(v11, v9, a5) < 0 )
        v9 = v11;
      v11 += a3;
    }
    while ( v47 >= v11 );
    v12 = a1;
    if ( v9 != a1 )
    {
      v13 = &v9[a3];
      do
      {
        v14 = *v9;
        v15 = *v12;
        ++v9;
        ++v12;
        *(v9 - 1) = v15;
        *(v12 - 1) = v14;
      }
      while ( v9 != v13 );
    }
  }
  v16 = &a1[a3];
  v17 = -a3;
  v55 = a3 - 1;
  while ( 1 )
  {
    v52 = &v16[a3];
    if ( &v16[a3] > v57 )
      return __readgsdword(0x14u) ^ v62;
    v18 = v17;
    v19 = v16;
    v20 = v18;
    for ( i = a4(v52, v19, a5); i < 0; i = a4(v52, v19, a5) )
      v19 += v20;
    v22 = v20;
    v16 = &v19[a3];
    v17 = v22;
    if ( v52 != v16 )
    {
      v23 = &v52[v55];
      if ( !__CFADD__(v55, v52) )
      {
        v51 = v52 - 1;
        do
        {
          while ( 1 )
          {
            v24 = v23;
            v49 = *v23;
            v25 = &v23[-a3];
            if ( v16 <= &v23[-a3] )
              break;
            v26 = v23--;
            *v26 = v49;
            if ( v23 == v51 )
              goto LABEL_40;
          }
          while ( 1 )
          {
            *v24 = *v25;
            v24 -= a3;
            if ( v16 > &v25[v17] )
              break;
            v25 += v17;
          }
          --v23;
          *v25 = v49;
        }
        while ( v23 != v51 );
      }
LABEL_40:
      v16 = v52;
    }
  }
}

//----- (080711A0) --------------------------------------------------------
int __usercall _add_to_environ@<eax>(int *a1@<edi>, unsigned __int8 *a2, unsigned int *a3, unsigned __int8 *a4, int a5)
{
  bool v7; // zf
  int *v8; // edi
  unsigned int v9; // esi
  int **v10; // ebx
  unsigned int v11; // ebx
  int v12; // eax
  int **v13; // eax
  int **v14; // edx
  int *v15; // eax
  _TBYTE *v16; // ecx
  _BOOL4 v18; // eax
  int *v19; // edx
  unsigned int *v20; // ecx
  int v21; // ebx
  _TBYTE *v22; // edi
  _BYTE *v23; // eax
  int **v24; // edx
  int **v25; // eax
  int **v26; // edx
  void *v27; // esp
  _TBYTE *v28; // ecx
  _BYTE *v29; // eax
  unsigned __int8 **v30; // eax
  unsigned __int8 *v31; // eax
  unsigned __int8 *v32; // [esp-8h] [ebp-1058h]
  _BYTE v34[15]; // [esp+4h] [ebp-104Ch] BYREF
  int v35; // [esp+FF8h] [ebp-58h]
  unsigned int v36; // [esp+1004h] [ebp-4Ch] BYREF
  unsigned int *v37; // [esp+1008h] [ebp-48h]
  int *v38; // [esp+100Ch] [ebp-44h]
  int **v39; // [esp+1010h] [ebp-40h]
  int *v40; // [esp+1014h] [ebp-3Ch]
  _TBYTE *v41; // [esp+1018h] [ebp-38h]
  unsigned __int8 *v42; // [esp+101Ch] [ebp-34h]
  int **v43; // [esp+1020h] [ebp-30h]
  unsigned int v44; // [esp+1030h] [ebp-20h]
  int *v45; // [esp+1048h] [ebp-8h]
  int v46; // [esp+104Ch] [ebp-4h] BYREF

  v45 = a1;
  v41 = &GLOBAL_OFFSET_TABLE_;
  v37 = a3;
  v42 = a2;
  v40 = (int *)a4;
  v44 = __readgsdword(0x14u);
  v43 = (int **)strlen((unsigned int *)a2);
  if ( !a4 )
    v36 = strlen(v37) + 1;
  _ECX = 1;
  _EDX = v41;
  v7 = __readgsdword(0xCu) == 0;
  if ( !v7 )
    __asm { lock }
  __asm { cmpxchg [edx+1A1Ch], ecx }
  if ( !v7 )
    _lll_lock_wait_private(0, (int *)_EDX + 1671, (int)&v46, a1);
  v39 = &environ;
  if ( environ && (v8 = (int *)*environ) != 0 )
  {
    v9 = 0;
    v10 = (int **)environ;
    while ( strncmp((unsigned __int8 *)v8, v42, (unsigned int)v43) || *((_BYTE *)v43 + (_DWORD)v8) != 61 )
    {
      v8 = *++v10;
      if ( !*v10 )
      {
        v11 = v9++;
        v12 = 4 * v11 + 12;
        goto LABEL_15;
      }
      ++v9;
    }
    v14 = v10;
    v15 = *v10;
    if ( *v10 )
      goto LABEL_19;
    v12 = 4 * v9 + 8;
  }
  else
  {
    v12 = 8;
    v9 = 0;
  }
LABEL_15:
  v35 = v12;
  v38 = (int *)*((_DWORD *)v41 + 1669);
  v8 = realloc((int)&v46, v38, (const struct timespec *)v12);
  if ( !v8 )
    goto LABEL_42;
  v9 *= 4;
  if ( v38 != *v39 )
    memcpy(v8, *v39, v9);
  v13 = v39;
  v14 = (int **)((char *)v8 + v9);
  *(int *)((char *)v8 + v9) = 0;
  *(int *)((char *)v8 + v9 + 4) = 0;
  *v13 = v8;
  *(_DWORD *)((char *)v41 + (_DWORD)(&last_environ - 33765376)) = v8;
  v15 = *(int **)((char *)v8 + v9);
LABEL_19:
  if ( !a5 && v15 )
    goto LABEL_23;
  if ( v40 )
  {
LABEL_22:
    *v14 = v40;
LABEL_23:
    v16 = v41;
    if ( __readgsdword(0xCu) )
      __asm { lock }
    v7 = (*((_DWORD *)v41 + 1671))-- == 1;
    if ( !v7 )
      _lll_unlock_wake_private((int *)v16 + 1671, (int)&v46, v8, (const struct timespec *)v9);
    return 0;
  }
  v40 = (int *)v14;
  v9 = (unsigned int)v43 + v36 + 1;
  v18 = _libc_alloca_cutoff(v9);
  v19 = v40;
  if ( v9 <= 0x1000 || v18 )
  {
    v20 = (unsigned int *)((char *)&v36 - (((unsigned int)v43 + v36 + 28) & 0xFFFFF000));
    if ( &v36 != v20 )
    {
      while ( v34 != (_BYTE *)v20 )
        ;
    }
    v21 = ((_WORD)v9 + 27) & 0xFF0;
    if ( (((_WORD)v9 + 27) & 0xFF0) != 0 )
    {
      v27 = alloca(v21);
      *(_DWORD *)&v34[v21 - 4] = *(_DWORD *)&v34[v21 - 4];
    }
    v22 = v41;
    v32 = v42;
    v40 = v19;
    v42 = v34;
    v23 = mempcpy(v34, v32, (unsigned int)v43);
    *v23 = 61;
    memcpy(v23 + 1, v37, v36);
    v24 = (int **)((char *)v22 - 455472);
    v8 = (int *)(v22 + 668);
    v39 = v24;
    v25 = (int **)tfind((int)v42, v8, (int (__cdecl *)(int, _DWORD))v24);
    v14 = (int **)v40;
    if ( v25 )
    {
      v40 = *v25;
      if ( v40 )
        goto LABEL_22;
    }
    v43 = v14;
    v40 = malloc((const struct timespec *)v9);
    if ( v40 )
    {
      memcpy(v40, v42, v9);
      v26 = v43;
LABEL_41:
      v43 = v26;
      tsearch((int)v40, v8, (int (__cdecl *)(int, _DWORD))v39);
      v14 = v43;
      goto LABEL_22;
    }
  }
  else
  {
    v39 = (int **)v40;
    v40 = malloc((const struct timespec *)v9);
    if ( v40 )
    {
      v9 = (unsigned int)v41;
      v8 = (int *)(v41 + 668);
      v38 = (int *)v39;
      v29 = mempcpy(v40, v42, (unsigned int)v43);
      *v29 = 61;
      memcpy(v29 + 1, v37, v36);
      v39 = (int **)(v9 - 455472);
      v30 = (unsigned __int8 **)tfind((int)v40, (_DWORD *)(v9 + 6680), (int (__cdecl *)(int, _DWORD))(v9 - 455472));
      v26 = (int **)v38;
      if ( v30 )
      {
        v31 = *v30;
        if ( v31 )
        {
          v42 = v31;
          v43 = (int **)v38;
          free((int)&v46, v8, (int)v40);
          v14 = (int **)v38;
          v40 = (int *)v42;
          goto LABEL_22;
        }
      }
      goto LABEL_41;
    }
  }
LABEL_42:
  v28 = v41;
  if ( __readgsdword(0xCu) )
    __asm { lock }
  v7 = (*((_DWORD *)v41 + 1671))-- == 1;
  if ( !v7 )
    _lll_unlock_wake_private((int *)v28 + 1671, (int)&v46, v8, (const struct timespec *)v9);
  return -1;
}
// 80CE000: using guessed type _TBYTE GLOBAL_OFFSET_TABLE_;
// 80CF89C: using guessed type _DWORD *environ;
// 80CFA14: using guessed type int last_environ;

//----- (08071590) --------------------------------------------------------
int __usercall setenv@<eax>(int *a1@<edi>, unsigned __int8 *a2, unsigned int *a3, int a4)
{
  if ( a2 && *a2 && !strchr(a2, 61) )
    return _add_to_environ(a1, a2, a3, 0, a4);
  __writegsdword(0xFFFFFFE0, 0x16u);
  return -1;
}

//----- (08071600) --------------------------------------------------------
int __usercall unsetenv@<eax>(int a1@<ebp>, struct timespec *a2)
{
  int *v2; // eax
  int *v5; // edi
  bool v6; // zf
  unsigned __int8 **v7; // ebp
  unsigned __int8 *v8; // ebx
  unsigned __int8 **v10; // eax
  unsigned __int8 *v11; // ecx

  if ( a2 && LOBYTE(a2->tv_sec) && !strchr(a2, 61) )
  {
    v2 = (int *)strlen((unsigned int *)a2);
    _ECX = 1;
    _EDX = &GLOBAL_OFFSET_TABLE_;
    v5 = v2;
    v6 = __readgsdword(0xCu) == 0;
    if ( !v6 )
      __asm { lock }
    __asm { cmpxchg [edx+1A1Ch], ecx }
    if ( !v6 )
      _lll_lock_wait_private(0, (int *)&GLOBAL_OFFSET_TABLE_ + 1671, a1, v2);
    v7 = (unsigned __int8 **)environ;
    if ( environ )
    {
      while ( 1 )
      {
        v8 = *v7;
        if ( !*v7 )
          break;
        if ( !strncmp(v8, (unsigned __int8 *)a2, (unsigned int)v5) && *((_BYTE *)v5 + (_DWORD)v8) == 61 )
        {
          v10 = v7;
          do
          {
            v11 = v10[1];
            *v10++ = v11;
          }
          while ( v11 );
        }
        else
        {
          ++v7;
        }
      }
    }
    if ( __readgsdword(0xCu) )
      __asm { lock }
    v6 = (*((_DWORD *)&GLOBAL_OFFSET_TABLE_ + 1671))-- == 1;
    if ( !v6 )
      _lll_unlock_wake_private((int *)&GLOBAL_OFFSET_TABLE_ + 1671, (int)v7, v5, a2);
    return 0;
  }
  else
  {
    __writegsdword(0xFFFFFFE0, 0x16u);
    return -1;
  }
}
// 80CE000: using guessed type _TBYTE GLOBAL_OFFSET_TABLE_;
// 80CF89C: using guessed type _DWORD *environ;

//----- (08071710) --------------------------------------------------------
int __usercall clearenv@<eax>(int a1@<ebp>, int *a2@<edi>)
{
  bool v4; // zf

  _ECX = 1;
  _EBX = &GLOBAL_OFFSET_TABLE_;
  v4 = __readgsdword(0xCu) == 0;
  if ( !v4 )
    __asm { lock }
  __asm { cmpxchg ds:(envlock - 80CE000h)[ebx], ecx }
  if ( !v4 )
    _lll_lock_wait_private(0, &envlock, a1, a2);
  if ( (_DWORD *)last_environ == environ && environ )
  {
    free(a1, a2, (int)environ);
    last_environ = 0;
  }
  environ = 0;
  if ( __readgsdword(0xCu) )
    __asm { lock }
  if ( --envlock )
    _lll_unlock_wake_private(&envlock, a1, a2, (const struct timespec *)&environ);
  return 0;
}
// 80CE000: using guessed type _TBYTE GLOBAL_OFFSET_TABLE_;
// 80CF89C: using guessed type _DWORD *environ;
// 80CFA14: using guessed type int last_environ;
// 80CFA1C: using guessed type int envlock;

//----- (080717B0) --------------------------------------------------------
int __cdecl secure_getenv(__int16 *a1)
{
  if ( _libc_enable_secure )
    return 0;
  else
    return getenv(a1);
}
// 80CDDAC: using guessed type int _libc_enable_secure;

//----- (080717E0) --------------------------------------------------------
unsigned int __cdecl _strtol_internal(unsigned __int8 *a1, _DWORD *a2, int a3, int a4)
{
  return ___strtol_l_internal(a1, a2, a3, a4, __readgsdword(0xFFFFFFD4));
}

//----- (08071820) --------------------------------------------------------
unsigned int __cdecl strtol(unsigned __int8 *a1, _DWORD *a2, int a3)
{
  return ___strtol_l_internal(a1, a2, a3, 0, __readgsdword(0xFFFFFFD4));
}

//----- (08071860) --------------------------------------------------------
unsigned int __cdecl ___strtol_l_internal(unsigned __int8 *a1, _DWORD *a2, int a3, int a4, int a5)
{
  unsigned int *v5; // ebp
  unsigned __int8 *v6; // esi
  int v7; // ecx
  unsigned __int8 v8; // al
  unsigned __int8 *v9; // esi
  int v10; // ecx
  int v11; // edi
  char *v12; // ebx
  unsigned int result; // eax
  char *v14; // edx
  int v15; // edx
  int v16; // ecx
  int v17; // edx
  int v18; // edx
  int v19; // edx
  int v20; // eax
  int v21; // ebx
  unsigned int v22; // edx
  char v23; // cl
  unsigned int i; // eax
  unsigned int v25; // eax
  char *v26; // [esp+0h] [ebp-48h]
  unsigned int v27; // [esp+4h] [ebp-44h]
  unsigned __int8 v28; // [esp+4h] [ebp-44h]
  int v29; // [esp+8h] [ebp-40h]
  unsigned int v30; // [esp+Ch] [ebp-3Ch]
  int *v31; // [esp+10h] [ebp-38h]
  unsigned __int8 v32; // [esp+18h] [ebp-30h]
  int v33; // [esp+24h] [ebp-24h]

  v5 = 0;
  v26 = 0;
  if ( a4 )
  {
    v18 = *(_DWORD *)(a5 + 4);
    v26 = *(char **)(v18 + 44);
    if ( (unsigned __int8)(*v26 - 1) > 0x7Du )
    {
      v26 = 0;
    }
    else
    {
      v5 = *(unsigned int **)(v18 + 40);
      if ( !*(_BYTE *)v5 )
      {
        v26 = 0;
        v5 = 0;
      }
    }
  }
  if ( a3 == 1 || (unsigned int)a3 > 0x24 )
  {
    __writegsdword(0xFFFFFFE0, 0x16u);
    return 0;
  }
  v6 = a1;
  v7 = *(_DWORD *)(a5 + 52);
  v8 = *a1;
  if ( (*(_BYTE *)(v7 + 2 * (char)*a1 + 1) & 0x20) != 0 )
  {
    do
      v8 = *++v6;
    while ( (*(_BYTE *)(v7 + 2 * (char)*v6 + 1) & 0x20) != 0 );
  }
  if ( !v8 )
  {
    if ( !a2 )
      return 0;
    goto LABEL_64;
  }
  if ( v8 == 45 )
  {
    v9 = v6 + 1;
    v33 = 1;
  }
  else
  {
    v33 = 0;
    v9 = &v6[v8 == 43];
  }
  v10 = *v9;
  if ( (_BYTE)v10 != 48 )
  {
    if ( a3 && a3 != 10 )
    {
      v26 = 0;
      v32 = byte_80B1BFE[a3];
      v11 = 0;
      v27 = *((_DWORD *)&GLOBAL_OFFSET_TABLE_ + a3 - 28914);
      goto LABEL_13;
    }
    if ( !v26 )
    {
      v27 = 429496729;
      v11 = 0;
      v32 = 5;
      a3 = 10;
      goto LABEL_13;
    }
LABEL_56:
    v28 = *v9;
    v19 = strlen(v5);
    v30 = v19;
    v11 = v19;
    if ( !v19 )
      goto LABEL_61;
    if ( v28 == *(_BYTE *)v5 )
    {
      v20 = 0;
      while ( v19 != ++v20 )
      {
        if ( *((_BYTE *)v5 + v20) != v9[v20] )
          goto LABEL_77;
      }
      goto LABEL_61;
    }
LABEL_77:
    v21 = v28;
    v22 = (unsigned int)v9;
    if ( v28 )
    {
      v22 = (unsigned int)v9;
      do
      {
        if ( (unsigned __int8)(v21 - 48) > 9u )
        {
          v23 = *(_BYTE *)v5;
          for ( i = 0; *(_BYTE *)(v22 + i) == v23; v23 = *((_BYTE *)v5 + i) )
          {
            if ( v30 == ++i )
              goto LABEL_79;
          }
          if ( v30 > i && ((byte_80A7940[2 * v21 + 1] & 4) == 0 || dword_80A7040[v21] > 64) )
            break;
        }
LABEL_79:
        v21 = *(unsigned __int8 *)++v22;
      }
      while ( (_BYTE)v21 );
    }
    v25 = _correctly_grouped_prefixmb((unsigned int)v9, v22, (char *)v5, v26);
    v10 = *v9;
    v26 = (char *)v25;
    v27 = 429496729;
    v32 = 5;
    a3 = 10;
LABEL_13:
    if ( v26 != (char *)v9 && (_BYTE)v10 )
      goto LABEL_15;
LABEL_61:
    if ( !a2 )
      return 0;
    if ( v9 - a1 > 1 && dword_80A7040[(char)*(v9 - 1)] == 88 && *(v9 - 2) == 48 )
    {
      *a2 = v9 - 1;
      return 0;
    }
LABEL_64:
    *a2 = a1;
    return 0;
  }
  if ( (a3 & 0xFFFFFFEF) == 0 )
  {
    v31 = dword_80A7040;
    if ( dword_80A7040[(char)v9[1]] == 88 )
    {
      v10 = v9[2];
      v32 = 15;
      v9 += 2;
      v11 = 0;
      v27 = 0xFFFFFFF;
      a3 = 16;
      v26 = 0;
      goto LABEL_13;
    }
    if ( !a3 )
    {
      a3 = 8;
      v11 = 0;
      v10 = 48;
      v26 = 0;
      v27 = 0x1FFFFFFF;
      v32 = 7;
      goto LABEL_16;
    }
  }
  if ( a3 != 10 )
  {
    v10 = 48;
    v26 = 0;
    v27 = *((_DWORD *)&GLOBAL_OFFSET_TABLE_ + a3 - 28914);
    v32 = byte_80B1BFE[a3];
    v11 = 0;
    v31 = (int *)*((_DWORD *)&GLOBAL_OFFSET_TABLE_ - 33);
    goto LABEL_16;
  }
  if ( v26 )
    goto LABEL_56;
  v27 = 429496729;
  v11 = 0;
  v10 = 48;
  v32 = 5;
LABEL_15:
  v31 = dword_80A7040;
LABEL_16:
  v12 = (char *)v9;
  v29 = 0;
  result = 0;
  do
  {
    LOBYTE(v15) = v10 - 48;
    if ( (unsigned __int8)(v10 - 48) <= 9u )
      goto LABEL_26;
    if ( v11 )
    {
      v17 = 0;
      while ( *((_BYTE *)v5 + v17) == v12[v17] )
      {
        if ( ++v17 == v11 )
          goto LABEL_41;
      }
      v10 = (unsigned __int8)v10;
      if ( v11 == v17 )
      {
LABEL_41:
        v14 = &v12[v11 - 1];
        goto LABEL_20;
      }
    }
    if ( (byte_80A7940[2 * v10 + 1] & 4) == 0 )
      break;
    v15 = v31[v10] - 55;
LABEL_26:
    v16 = (unsigned __int8)v15;
    if ( (unsigned __int8)v15 >= a3 )
      break;
    if ( result > v27 || result == v27 && (unsigned __int8)v15 > v32 )
    {
      v29 = 1;
      v10 = (unsigned __int8)*++v12;
      if ( !(_BYTE)v10 )
        break;
    }
    else
    {
      v14 = v12;
      result = v16 + a3 * result;
LABEL_20:
      v10 = (unsigned __int8)v14[1];
      v12 = v14 + 1;
      if ( !(_BYTE)v10 )
        break;
    }
  }
  while ( v12 != v26 );
  if ( v12 == (char *)v9 )
    goto LABEL_61;
  if ( a2 )
    *a2 = v12;
  if ( v29 )
  {
    __writegsdword(0xFFFFFFE0, 0x22u);
    return 0x80000000 - (v33 == 0);
  }
  else if ( v33 )
  {
    if ( result > 0x80000000 )
    {
      __writegsdword(0xFFFFFFE0, 0x22u);
      return 0x80000000;
    }
    else
    {
      return -result;
    }
  }
  else if ( (result & 0x80000000) != 0 )
  {
    __writegsdword(0xFFFFFFE0, 0x22u);
    return 0x7FFFFFFF;
  }
  return result;
}
// 80A7040: using guessed type int dword_80A7040[256];
// 80A7940: using guessed type _BYTE byte_80A7940[512];
// 80CE000: using guessed type _TBYTE GLOBAL_OFFSET_TABLE_;

//----- (08071E20) --------------------------------------------------------
unsigned int __cdecl strtol_l(unsigned __int8 *a1, _DWORD *a2, int a3, int a4)
{
  return ___strtol_l_internal(a1, a2, a3, 0, a4);
}

//----- (08071E50) --------------------------------------------------------
int __usercall read_int@<eax>(_DWORD *a1@<eax>)
{
  unsigned __int8 *v1; // ebx
  int v2; // ecx
  int v3; // ebp
  bool v4; // sf
  unsigned int v5; // edx

  v1 = (unsigned __int8 *)(*a1 + 1);
  v2 = *(unsigned __int8 *)*a1 - 48;
  while ( 1 )
  {
    *a1 = v1;
    v5 = *v1 - 48;
    if ( v5 > 9 )
      break;
    if ( v2 >= 0 )
    {
      if ( v2 <= 214748364 )
      {
        v3 = 10 * v2;
        v4 = (int)(0x7FFFFFFF - v5 - 10 * v2) < 0;
        v2 = 10 * v2 + v5;
        if ( v4 != __OFSUB__(0x7FFFFFFF - v5, v3) )
          v2 = -1;
      }
      else
      {
        v2 = -1;
      }
    }
    ++v1;
  }
  return v2;
}

//----- (08071EB0) --------------------------------------------------------
_BYTE *__usercall group_number@<eax>(_BYTE *a1@<eax>, _BYTE *a2@<edx>, _BYTE *a3@<ecx>, _BYTE *a4, unsigned int *a5)
{
  unsigned int v9; // esi
  int v10; // ecx
  char *v11; // eax
  int v12; // ecx
  int v13; // [esp+4h] [ebp-28h]
  int v14; // [esp+8h] [ebp-24h]

  if ( (unsigned __int8)(*a4 - 1) > 0x7Du )
    return a2;
  v13 = strlen(a5);
  v14 = (char)*a4;
  v9 = (unsigned int)&a1[a3 - a2];
  memmove(a1, a2, a3 - a2);
  v10 = v14;
  if ( (unsigned int)a1 >= v9 )
    return a3;
  v11 = a4 + 1;
  while ( 1 )
  {
    while ( 1 )
    {
      --v9;
      a2 = a3 - 1;
      *(a3 - 1) = *(_BYTE *)v9;
      if ( !--v10 )
        break;
      if ( (unsigned int)a1 >= v9 )
        return a2;
      --a3;
    }
    if ( (unsigned int)a1 >= v9 )
      return a2;
    if ( (int)&a2[-v9] <= v13 )
      break;
    v12 = v13;
    do
    {
      --v12;
      *--a2 = *((_BYTE *)a5 + v12);
    }
    while ( v12 > 0 );
    v10 = *v11;
    if ( (_BYTE)v10 == 127 || (v10 & 0x80u) != 0 )
      break;
    if ( (_BYTE)v10 )
      ++v11;
    else
      v10 = *(v11 - 1);
    a3 = a2;
  }
  memmove(a2, (_BYTE *)v9, (unsigned int)&a1[-v9]);
  return a2;
}

//----- (08071FE0) --------------------------------------------------------
_BYTE *__usercall i18n_number_rewrite@<eax>(_BYTE *a1@<eax>, int a2@<edx>, _BYTE *a3@<ecx>)
{
  int v5; // ebx
  unsigned int v6; // eax
  unsigned int v7; // edi
  int *v9; // eax
  int *v10; // edi
  int *v11; // ecx
  int v12; // eax
  unsigned int *v13; // ebx
  int v14; // eax
  int v15; // edx
  __int16 *v16; // ebx
  int v17; // eax
  int v18; // edx
  int v19; // eax
  int v20; // eax
  char *v21; // [esp+4h] [ebp-470h]
  int v22; // [esp+8h] [ebp-46Ch]
  int *v24; // [esp+14h] [ebp-460h]
  int *v25; // [esp+14h] [ebp-460h]
  _DWORD *v26; // [esp+18h] [ebp-45Ch]
  char *v27; // [esp+1Ch] [ebp-458h] BYREF
  int v28; // [esp+20h] [ebp-454h]
  char v29[1034]; // [esp+2Ch] [ebp-448h] BYREF
  __int16 v30[8]; // [esp+436h] [ebp-3Eh] BYREF
  __int16 v31[8]; // [esp+447h] [ebp-2Dh] BYREF
  unsigned int v32; // [esp+458h] [ebp-1Ch]
  int savedregs; // [esp+474h] [ebp+0h] BYREF

  v32 = __readgsdword(0x14u);
  v26 = (_DWORD *)wctrans("to_outpunct");
  v5 = towctrans(0x2Eu, v26);
  v6 = towctrans(0x2Cu, v26);
  if ( v26 )
  {
    v22 = v6;
    v27 = 0;
    v28 = 0;
    v19 = wcrtomb((char *)v30, v5, &v27);
    if ( v19 == -1 )
      v30[0] = 46;
    else
      *((_BYTE *)v30 + v19) = 0;
    v27 = 0;
    v28 = 0;
    v20 = wcrtomb((char *)v31, v22, &v27);
    if ( v20 == -1 )
      v31[0] = 44;
    else
      *((_BYTE *)v31 + v20) = 0;
  }
  v7 = a2 - (_DWORD)a1;
  v28 = 1024;
  v27 = v29;
  if ( (unsigned __int8)_libc_scratch_buffer_set_array_size((int *)&v27, v7, 1) )
  {
    v21 = v27;
    v9 = (int *)mempcpy(v27, a1, v7);
    a1 = a3;
    v10 = v9;
    v11 = (int *)v21;
LABEL_5:
    while ( 1 )
    {
      v10 = (int *)((char *)v10 - 1);
      if ( v11 > v10 )
        break;
      while ( 1 )
      {
        v12 = *(char *)v10;
        if ( (unsigned __int8)(v12 - 48) <= 9u )
          break;
        if ( v26 && (v12 & 0xFD) == 44 )
        {
          v16 = v30;
          if ( (_BYTE)v12 != 46 )
            v16 = v31;
          v25 = v11;
          v17 = strlen((unsigned int *)v16);
          v11 = v25;
          a1 -= v17;
          v18 = v17 - 1;
          if ( v17 )
          {
            do
            {
              a1[v18] = *((_BYTE *)v16 + v18);
              --v18;
            }
            while ( v18 != -1 );
          }
          goto LABEL_5;
        }
        v10 = (int *)((char *)v10 - 1);
        *--a1 = v12;
        if ( v11 > v10 )
          goto LABEL_9;
      }
      v24 = v11;
      v13 = *(unsigned int **)(*(_DWORD *)__readgsdword(0xFFFFFFD0) + 4 * v12 + 8);
      v14 = strlen(v13);
      v11 = v24;
      a1 -= v14;
      v15 = v14 - 1;
      if ( v14 )
      {
        do
        {
          a1[v15] = *((_BYTE *)v13 + v15);
          --v15;
        }
        while ( v15 != -1 );
      }
    }
LABEL_9:
    if ( v27 != v29 )
      free((int)&savedregs, v10, (int)v27);
  }
  return a1;
}

//----- (080722A0) --------------------------------------------------------
int __cdecl IO_helper_overflow(_DWORD *a1, unsigned __int8 a2)
{
  unsigned __int8 *v2; // ecx
  _BYTE *v3; // eax
  _BYTE *v4; // esi
  int v5; // ebp
  int result; // eax
  int v7; // [esp+0h] [ebp-24h]
  int v8; // [esp+4h] [ebp-20h]

  v2 = (unsigned __int8 *)a1[5];
  v3 = (_BYTE *)a1[4];
  v4 = (_BYTE *)(v2 - v3);
  if ( v2 != v3 )
  {
    v8 = a1[38];
    v7 = *(_DWORD *)(v8 + 148);
    if ( (char *)&_start___libc_atexit - (char *)_start___libc_IO_vtables <= (unsigned int)(v7
                                                                                          - (_DWORD)_start___libc_IO_vtables) )
    {
      IO_vtable_check();
      v3 = (_BYTE *)a1[4];
    }
    v5 = (*(int (__cdecl **)(int, _BYTE *, _BYTE *))(v7 + 28))(v8, v3, v4);
    if ( (unsigned int)(v5 - 1) > 0xFFFFFFFD )
      return -1;
    memmove((_BYTE *)a1[4], (_BYTE *)(a1[4] + v5), (unsigned int)&v4[-v5]);
    v2 = (unsigned __int8 *)(a1[5] - v5);
    a1[5] = v2;
  }
  result = a2;
  if ( a1[6] <= (unsigned int)v2 )
    return _overflow((int)a1, a2);
  a1[5] = v2 + 1;
  *v2 = a2;
  return result;
}
// 80CEFA0: using guessed type int _start___libc_IO_vtables[24];
// 80CF2F4: using guessed type int (*_start___libc_atexit)();

//----- (08072380) --------------------------------------------------------
unsigned int __usercall printf_positional@<eax>(
        int *a1@<eax>,
        unsigned int *a2@<edx>,
        int a3@<ecx>,
        int a4,
        int a5,
        int a6,
        unsigned int a7,
        unsigned int a8,
        unsigned __int8 *a9,
        _BYTE *a10,
        signed int a11,
        char *a12,
        unsigned int *a13)
{
  unsigned int v13; // edi
  int *v14; // ebx
  unsigned __int8 *v15; // esi
  int *v16; // edx
  int *v17; // ecx
  int v18; // ebx
  char *v19; // edi
  float v20; // esi
  int v21; // ecx
  int v22; // eax
  int v23; // eax
  int v24; // eax
  int v25; // edx
  char **v26; // esi
  unsigned int v27; // ebx
  long double **v28; // edi
  int v29; // eax
  long double v30; // fst7
  unsigned __int8 v31; // al
  char v32; // dl
  int v33; // esi
  char v34; // cl
  int v35; // edx
  int v36; // ecx
  int v37; // esi
  int v38; // eax
  int *v39; // eax
  int v40; // eax
  const struct timespec *v41; // ebx
  _BOOL4 v42; // eax
  int *v43; // eax
  int v44; // edx
  void *v45; // esp
  int *v46; // eax
  int *v47; // eax
  __int64 v48; // xmm1_8
  long double *v49; // eax
  long double *v50; // eax
  char *v51; // edx
  char *v52; // eax
  int v53; // edx
  int v54; // eax
  _BYTE *v55; // edx
  unsigned int v56; // ebx
  unsigned int v57; // esi
  unsigned int v58; // esi
  int v60; // eax
  unsigned int *v61; // edi
  char v62; // al
  int v63; // eax
  int (__cdecl *v64)(int *, unsigned int, _BYTE *); // edx
  int v65; // edx
  int v66; // ebx
  _BYTE *v67; // esi
  __int16 v68; // bx
  int v69; // ebx
  void *v70; // esp
  char ***v71; // eax
  char **v72; // edx
  _BYTE *v73; // eax
  char v74; // al
  _BYTE *v75; // eax
  _BYTE *v76; // eax
  _BYTE *v77; // eax
  _BYTE *v78; // eax
  unsigned int v79; // eax
  _BYTE *v80; // eax
  int *v81; // esi
  char v82; // dl
  _BYTE *v83; // eax
  int v84; // esi
  int v85; // ebx
  unsigned int v86; // eax
  char v87; // al
  int v88; // eax
  int v89; // esi
  int v90; // ebx
  int v91; // ebx
  char ***v92; // eax
  char **v93; // esi
  char ***v94; // edx
  int v95; // eax
  int v96; // ebx
  int v97; // eax
  int v98; // edx
  int v99; // eax
  int v100; // eax
  unsigned int v101; // ebx
  _BYTE *v102; // ecx
  unsigned int v103; // esi
  int v104; // edx
  unsigned int v105; // ebx
  unsigned int *v106; // eax
  unsigned __int64 v107; // rax
  int *v108; // eax
  int v109; // ebx
  int v110; // eax
  int v111; // ecx
  char v112; // al
  _BYTE *v113; // eax
  _BYTE *v114; // eax
  unsigned __int8 *v115; // eax
  char *v116; // edx
  int v117; // edx
  int v118; // eax
  char **v119; // eax
  char *v120; // edx
  int v121; // ebx
  unsigned int v122; // eax
  char v123; // dl
  unsigned int v124; // ebx
  int *v125; // esi
  _BYTE *v126; // eax
  bool v127; // bl
  char *v128; // eax
  unsigned __int8 *v129; // eax
  __m128i *v130; // ebx
  unsigned int v131; // eax
  bool v132; // zf
  int v133; // edx
  char *v134; // edx
  _BYTE *v135; // eax
  unsigned int v136; // ebx
  _BYTE *v137; // eax
  void *v138; // esp
  _BYTE *v139; // edx
  int *v140; // edx
  int *v141; // eax
  _BYTE *v142; // eax
  _BYTE *v143; // eax
  unsigned __int8 *v144; // eax
  unsigned __int8 v145; // cl
  unsigned int v146; // esi
  int v147; // edx
  unsigned int v148; // ebx
  int v149; // eax
  int *v150; // esi
  _BYTE *v151; // eax
  int v152; // eax
  int *v153; // esi
  _BYTE *v154; // eax
  int *v155; // ebx
  int *v156; // eax
  int v157; // edx
  _BYTE *v158; // eax
  int *v159; // ebx
  _BYTE *v160; // eax
  int v161; // edx
  int *v162; // eax
  int v163; // eax
  void *v164; // esp
  int *v165; // eax
  int v166; // eax
  unsigned int v167; // ebx
  _BYTE *v168; // eax
  int v169; // ebx
  _BOOL4 v170; // eax
  _BYTE *v171; // edx
  int v172; // eax
  void *v173; // esp
  _BYTE *v174; // eax
  int v175; // eax
  int *v176; // esi
  char v177; // dl
  _BYTE *v178; // eax
  _BYTE *v179; // eax
  int v180; // eax
  int v181; // eax
  _BYTE *v182; // eax
  unsigned int v183; // esi
  int v184; // eax
  _BYTE *v185; // eax
  _BOOL4 v186; // eax
  const struct timespec *v187; // ecx
  _BYTE *v188; // eax
  int v189; // edx
  void *v190; // esp
  int v191; // eax
  int *v192; // eax
  int *v193; // edx
  int v194; // eax
  int v195; // eax
  int v196; // eax
  _TBYTE *v197; // edi
  _TBYTE *v198; // edi
  unsigned int v199; // [esp-2010h] [ebp-2948h]
  int v200; // [esp-2008h] [ebp-2940h]
  int v201; // [esp-2004h] [ebp-293Ch]
  _BYTE v202[4080]; // [esp-2000h] [ebp-2938h] BYREF
  int *v203; // [esp-1010h] [ebp-1948h]
  int v204; // [esp-100Ch] [ebp-1944h]
  int v205; // [esp-1008h] [ebp-1940h]
  _TBYTE *v206; // [esp-1004h] [ebp-193Ch]
  _BYTE v207[4080]; // [esp-1000h] [ebp-1938h] BYREF
  int v208; // [esp-10h] [ebp-948h]
  int v209[2]; // [esp+0h] [ebp-938h] BYREF
  unsigned int v210; // [esp+8h] [ebp-930h]
  int *v211; // [esp+Ch] [ebp-92Ch]
  unsigned int v212; // [esp+10h] [ebp-928h]
  int *v213; // [esp+14h] [ebp-924h]
  unsigned int v214; // [esp+18h] [ebp-920h]
  int *v215; // [esp+1Ch] [ebp-91Ch]
  unsigned __int64 v216; // [esp+20h] [ebp-918h]
  unsigned int v217; // [esp+28h] [ebp-910h]
  int *v218; // [esp+2Ch] [ebp-90Ch]
  unsigned int v219; // [esp+30h] [ebp-908h]
  int *v220; // [esp+34h] [ebp-904h]
  unsigned int v221; // [esp+38h] [ebp-900h]
  int *v222; // [esp+3Ch] [ebp-8FCh]
  int v223; // [esp+40h] [ebp-8F8h]
  unsigned int v224; // [esp+44h] [ebp-8F4h]
  int v225; // [esp+48h] [ebp-8F0h]
  unsigned int v226; // [esp+4Ch] [ebp-8ECh]
  int *v227; // [esp+50h] [ebp-8E8h]
  int *v228; // [esp+54h] [ebp-8E4h]
  unsigned int *v229; // [esp+58h] [ebp-8E0h]
  signed int v230; // [esp+5Ch] [ebp-8DCh]
  int v231; // [esp+60h] [ebp-8D8h]
  _BYTE *v232; // [esp+64h] [ebp-8D4h]
  unsigned int *v233; // [esp+68h] [ebp-8D0h]
  char *v234; // [esp+6Ch] [ebp-8CCh]
  int v235; // [esp+70h] [ebp-8C8h]
  int *v236; // [esp+74h] [ebp-8C4h]
  unsigned int v237; // [esp+78h] [ebp-8C0h]
  signed int v238; // [esp+7Ch] [ebp-8BCh]
  bool v239; // [esp+80h] [ebp-8B8h]
  unsigned __int8 v240; // [esp+81h] [ebp-8B7h]
  char v241; // [esp+82h] [ebp-8B6h]
  unsigned __int8 v242; // [esp+83h] [ebp-8B5h]
  const struct timespec *v243; // [esp+84h] [ebp-8B4h]
  unsigned int v244; // [esp+88h] [ebp-8B0h]
  int v245; // [esp+8Ch] [ebp-8ACh]
  char *v246; // [esp+90h] [ebp-8A8h]
  int *v247; // [esp+94h] [ebp-8A4h]
  char *v248; // [esp+98h] [ebp-8A0h]
  unsigned int v249; // [esp+9Ch] [ebp-89Ch]
  char **v250; // [esp+A0h] [ebp-898h]
  unsigned int v251; // [esp+A4h] [ebp-894h]
  int *v252; // [esp+A8h] [ebp-890h]
  _TBYTE *v253; // [esp+ACh] [ebp-88Ch]
  float v254; // [esp+B0h] [ebp-888h]
  int v255; // [esp+B4h] [ebp-884h]
  char *v256; // [esp+B8h] [ebp-880h]
  int v257; // [esp+BCh] [ebp-87Ch]
  unsigned int v258; // [esp+CCh] [ebp-86Ch] BYREF
  const __m128i *v259; // [esp+D0h] [ebp-868h] BYREF
  __m128i *v260; // [esp+D4h] [ebp-864h] BYREF
  _BYTE *v261; // [esp+D8h] [ebp-860h] BYREF
  int v262; // [esp+DCh] [ebp-85Ch]
  char *v263; // [esp+E0h] [ebp-858h] BYREF
  unsigned int v264; // [esp+E4h] [ebp-854h]
  char v265[1024]; // [esp+F0h] [ebp-848h] BYREF
  int v266[4]; // [esp+4F0h] [ebp-448h] BYREF
  char v267[1036]; // [esp+500h] [ebp-438h] BYREF
  char v268[12]; // [esp+90Ch] [ebp-2Ch] BYREF
  char v269[4]; // [esp+918h] [ebp-20h] BYREF
  unsigned int v270; // [esp+91Ch] [ebp-1Ch]
  int savedregs; // [esp+938h] [ebp+0h] BYREF

  v252 = a1;
  v231 = a3;
  v247 = (int *)a6;
  v253 = &GLOBAL_OFFSET_TABLE_;
  v251 = a7;
  v229 = a2;
  v249 = a8;
  v232 = a10;
  v230 = a11;
  v246 = a12;
  v233 = a13;
  v270 = __readgsdword(0x14u);
  v248 = v265;
  v263 = v265;
  v264 = 1024;
  v234 = v267;
  v266[0] = (int)v267;
  v266[1] = 1024;
  v258 = 0;
  if ( a12 == (char *)-1 )
  {
    v60 = *(_DWORD *)__readgsdword(0xFFFFFFDC);
    v61 = *(unsigned int **)(v60 + 40);
    v246 = *(char **)(v60 + 44);
    v62 = *v246;
    v233 = v61;
    if ( !v62 || v62 == 127 )
      v246 = 0;
  }
  if ( *a9 )
  {
    v13 = 0;
    v14 = 0;
    v15 = a9;
    v255 = 19;
    v256 = v248;
    v254 = COERCE_FLOAT(&v258);
    v250 = &v263;
    while ( 1 )
    {
      v16 = (int *)&v256[52 * v13++];
      v257 = (int)v16;
      v14 = (int *)((char *)v14 + _parse_one_specmb(v15, (int)v14, (int)v16, (unsigned int *)LODWORD(v254)));
      v15 = *(unsigned __int8 **)(v257 + 24);
      if ( !*v15 )
        break;
      if ( v255 == v13 )
      {
        if ( !(unsigned __int8)_libc_scratch_buffer_grow_preserve((int)v250) )
          goto LABEL_79;
        v256 = v263;
        v255 = v264 / 0x34;
      }
    }
    if ( v258 >= (unsigned int)v14 )
      v14 = (int *)v258;
    v257 = (int)v14;
  }
  else
  {
    v13 = 0;
    v257 = 0;
    v256 = v248;
  }
  if ( !(unsigned __int8)_libc_scratch_buffer_set_array_size(v266, v257, 20) )
    goto LABEL_79;
  v250 = (char **)v266[0];
  v255 = v266[0] + 12 * v257;
  LODWORD(v254) = 4 * v257 + v255;
  memset((unsigned __int8 *)LODWORD(v254), v252[15] << 29 >> 31, 4 * v257);
  v17 = (int *)LODWORD(v254);
  if ( !v13 )
  {
    if ( v257 )
      goto LABEL_24;
    goto LABEL_158;
  }
  v245 = v13;
  v18 = (int)v256;
  v19 = &v256[52 * v13];
  v20 = v254;
  do
  {
    while ( 1 )
    {
      v22 = *(_DWORD *)(v18 + 32);
      if ( v22 != -1 )
        *(_DWORD *)(LODWORD(v20) + 4 * v22) = 0;
      v23 = *(_DWORD *)(v18 + 28);
      if ( v23 != -1 )
        *(_DWORD *)(LODWORD(v20) + 4 * v23) = 0;
      v24 = *(_DWORD *)(v18 + 44);
      if ( !v24 )
        goto LABEL_15;
      if ( v24 != 1 )
        break;
      v21 = v255;
      *(_DWORD *)(LODWORD(v20) + 4 * *(_DWORD *)(v18 + 36)) = *(_DWORD *)(v18 + 40);
      *(_DWORD *)(v21 + 4 * *(_DWORD *)(v18 + 36)) = *(_DWORD *)(v18 + 48);
LABEL_15:
      v18 += 52;
      if ( v19 == (char *)v18 )
        goto LABEL_23;
    }
    v25 = 4 * *(_DWORD *)(v18 + 36);
    v254 = *(float *)(v18 + 8);
    v208 = v18;
    v18 += 52;
    (*(void (__cdecl **)(int, int, int, int))(*((_DWORD *)v253 + 2042) + 4 * LODWORD(v254)))(
      v208,
      v24,
      LODWORD(v20) + v25,
      v25 + v255);
  }
  while ( v19 != (char *)v18 );
LABEL_23:
  v13 = v245;
  v17 = (int *)LODWORD(v20);
  if ( !v257 )
    goto LABEL_40;
LABEL_24:
  v245 = v13;
  v26 = v250;
  v27 = 0;
  v28 = (long double **)v247;
  v254 = 0.0;
  while ( 2 )
  {
    v29 = v17[v27];
    if ( v29 > 5 )
    {
      if ( v29 == 256 )
      {
        v50 = *v28;
        *v28 = (long double *)((char *)*v28 + 8);
        v51 = (char *)*((_DWORD *)v50 + 1);
        v52 = *(char **)v50;
        v26[1] = v51;
        *v26 = v52;
      }
      else if ( v29 <= 256 )
      {
        if ( v29 > 7 )
          goto LABEL_62;
        v48 = *(_QWORD *)*v28;
        *v28 = (long double *)((char *)*v28 + 8);
        *(_QWORD *)v26 = v48;
      }
      else
      {
        if ( v29 == 512 || v29 == 1024 )
          goto LABEL_63;
        if ( v29 != 263 )
          goto LABEL_62;
        v30 = *(*v28)++;
        *(long double *)v26 = v30;
      }
    }
    else
    {
      if ( v29 >= 3 || v29 > 1 || v29 >= 0 )
        goto LABEL_63;
      if ( v29 == -1 )
      {
        if ( (v252[15] & 4) != 0 )
          _libc_fatal((_BYTE)v253 + 32);
        _assert_fail((int)v253 - 115456, (int)(v253 - 11549), 1887, (int)(v253 - 11526));
      }
LABEL_62:
      if ( (v29 & 0x800) != 0 )
      {
LABEL_63:
        v49 = *v28;
        *v28 = (long double *)((char *)*v28 + 4);
        *v26 = *(char **)v49;
      }
      else
      {
        v53 = *((_DWORD *)v253 + 2043);
        v247 = (int *)v53;
        if ( v53 && *(_DWORD *)(v53 + 4 * v29 - 32) )
        {
          v161 = *(_DWORD *)(v255 + 4 * v27) + 27;
          v244 = v161 & 0xFFFFFFF0;
          v162 = (int *)((char *)v209 - (v161 & 0xFFFFF000));
          if ( v209 != v162 )
          {
            while ( v207 != (_BYTE *)v162 )
              ;
          }
          v163 = v244 & 0xFFF;
          if ( (v244 & 0xFFF) != 0 )
          {
            v164 = alloca(v163);
            *(_DWORD *)&v207[v163 - 4] = *(_DWORD *)&v207[v163 - 4];
          }
          v244 = (unsigned int)v17;
          *v26 = v207;
          ((void (__cdecl *)(_BYTE *, long double **))v247[v17[v27] - 8])(v207, v28);
          v17 = (int *)v244;
        }
        else
        {
          *(long double *)v26 = v254;
        }
      }
    }
    ++v27;
    v26 += 3;
    if ( v27 < v257 )
      continue;
    break;
  }
  v13 = v245;
LABEL_40:
  if ( v13 <= v249 )
  {
LABEL_158:
    v58 = v251;
    goto LABEL_80;
  }
  v224 = v13;
  v222 = (int *)(v232 + 1000);
  v13 = (unsigned int)&v256[52 * v249];
  v215 = _start___libc_IO_vtables;
  v214 = (char *)&_start___libc_atexit - (char *)_start___libc_IO_vtables;
  v211 = _start___libc_IO_vtables;
  v210 = (char *)&_start___libc_atexit - (char *)_start___libc_IO_vtables;
  v213 = _start___libc_IO_vtables;
  v212 = (char *)&_start___libc_atexit - (char *)_start___libc_IO_vtables;
  v220 = _start___libc_IO_vtables;
  v219 = (char *)&_start___libc_atexit - (char *)_start___libc_IO_vtables;
  v218 = _start___libc_IO_vtables;
  v217 = (char *)&_start___libc_atexit - (char *)_start___libc_IO_vtables;
  v227 = _start___libc_IO_vtables;
  v226 = (char *)&_start___libc_atexit - (char *)_start___libc_IO_vtables;
  while ( 2 )
  {
    v31 = *(_BYTE *)(v13 + 12);
    v32 = *(_BYTE *)(v13 + 13);
    LOBYTE(v245) = (v31 & 8) != 0;
    LODWORD(v254) = (v31 & 0x20) != 0;
    v33 = *(_DWORD *)(v13 + 16);
    LOBYTE(v244) = (v31 & 0x10) != 0;
    v235 = v33;
    LOBYTE(v243) = (v31 & 0x40) != 0;
    v241 = v31 >> 7;
    v242 = v31 & 1;
    LOBYTE(v238) = (v31 & 2) != 0;
    v34 = v32;
    v239 = (v32 & 8) != 0;
    v35 = *(_DWORD *)(v13 + 32);
    LOBYTE(v237) = (v34 & 2) != 0;
    LOBYTE(v236) = (v31 & 4) != 0;
    v257 = *(_DWORD *)v13;
    v36 = *(_DWORD *)(v13 + 8);
    v240 = v36;
    if ( v35 == -1 )
    {
      v255 = *(_DWORD *)(v13 + 4);
    }
    else
    {
      v37 = (int)v250[3 * v35];
      v255 = v37;
      if ( v37 < 0 )
      {
        v255 = -v255;
        v90 = v255;
        *(_BYTE *)(v13 + 12) = v31 | 0x20;
        *(_DWORD *)(v13 + 4) = v90;
        LODWORD(v254) = 1;
      }
      else
      {
        *(_DWORD *)(v13 + 4) = v37;
      }
    }
    v38 = *(_DWORD *)(v13 + 28);
    if ( v38 != -1 )
    {
      v39 = (int *)v250[3 * v38];
      v257 = (int)v39;
      if ( (int)v39 < 0 )
      {
        *(_DWORD *)v13 = -1;
        v257 = -1;
      }
      else
      {
        *(_DWORD *)v13 = v39;
      }
    }
    v40 = v257;
    if ( v255 >= v257 )
      v40 = v255;
    if ( v40 <= 968 )
    {
      v247 = 0;
      v228 = v222;
    }
    else
    {
      v41 = (const struct timespec *)(v40 + 32);
      v247 = (int *)v36;
      v42 = _libc_alloca_cutoff(v40 + 32);
      v36 = (int)v247;
      if ( (int)v41 <= 4096 || v42 )
      {
        v43 = (int *)((char *)v209 - (((unsigned int)&v41[3].tv_sec + 3) & 0xFFFFF000));
        if ( v209 != v43 )
        {
          while ( v207 != (_BYTE *)v43 )
            ;
        }
        v44 = ((_WORD)v41 + 27) & 0xFF0;
        if ( (((_WORD)v41 + 27) & 0xFF0) != 0 )
        {
          v45 = alloca(v44);
          *(_DWORD *)&v207[v44 - 4] = *(_DWORD *)&v207[v44 - 4];
        }
        v247 = (int *)v207;
        v46 = (int *)(v255 + 32);
        if ( v255 < v257 )
          v46 = (int *)(v257 + 32);
        v47 = (int *)((char *)v46 + (_DWORD)v247);
        v247 = 0;
        v228 = v47;
      }
      else
      {
        v228 = v247;
        v192 = malloc(v41);
        v36 = (int)v228;
        v247 = v192;
        if ( !v192 )
          break;
        v193 = (int *)(v255 + 32);
        if ( v255 < v257 )
          v193 = (int *)(v257 + 32);
        v228 = (int *)((char *)v193 + (_DWORD)v247);
      }
    }
    v63 = *((_DWORD *)v253 + 2037);
    if ( v63 )
    {
      v64 = *(int (__cdecl **)(int *, unsigned int, _BYTE *))(v63 + 4 * (char)v36);
      v225 = (char)v36;
      if ( v64 )
      {
        v223 = *(_DWORD *)(v13 + 44);
        v88 = 4 * v223;
        v89 = 4 * v223 + 27;
        v221 = v89 & 0xFFFFFFF0;
        while ( v207 != &v207[-(v89 & 0xFFFFF000)] )
          ;
        v91 = v221 & 0xFFF;
        if ( (v221 & 0xFFF) != 0 )
        {
          v138 = alloca(v91);
          *(_DWORD *)&v207[v91 - 4] = *(_DWORD *)&v207[v91 - 4];
        }
        if ( v223 )
        {
          v92 = (char ***)&v207[v88];
          v93 = &v250[3 * *(_DWORD *)(v13 + 36)];
          v94 = (char ***)v207;
          do
          {
            *v94++ = v93;
            v93 += 3;
          }
          while ( v92 != v94 );
          v64 = *(int (__cdecl **)(int *, unsigned int, _BYTE *))(*((_DWORD *)v253 + 2037) + 4 * v225);
        }
        v225 = v36;
        v95 = v64(v252, v13, v207);
        v36 = v225;
        if ( v95 != -2 )
        {
          if ( v95 < 0 )
            goto LABEL_77;
          if ( v251 <= 0x7FFFFFFE )
          {
            if ( 0x7FFFFFFF - v251 < v95 )
              goto LABEL_76;
LABEL_149:
            v251 += v95;
            goto LABEL_150;
          }
          v197 = v253;
          v206 = v253 - 11526;
          v205 = 2010;
LABEL_510:
          _assert_fail((int)v197 - 115388, (int)(v197 - 11549), v200, v201);
        }
      }
    }
    v84 = (int)v253;
    v85 = (unsigned __int8)v237;
    v223 = (unsigned __int8)v245;
    v225 = (unsigned __int8)v244;
    v243 = (const struct timespec *)(unsigned __int8)v243;
    v86 = v242;
    v242 = v235;
    v244 = v86;
    v238 = (unsigned __int8)v238;
    v87 = (char)v236;
    switch ( (char)v36 )
    {
      case '%':
        v137 = (_BYTE *)v252[5];
        if ( (unsigned int)v137 >= v252[6] )
        {
          if ( _overflow((int)v252, 37) == -1 )
            goto LABEL_77;
        }
        else
        {
          v252[5] = (int)(v137 + 1);
          *v137 = 37;
        }
        if ( v251 == 0x7FFFFFFF )
          goto LABEL_77;
        ++v251;
        goto LABEL_150;
      case 'A':
      case 'a':
        v121 = (int)v250;
        v260 = (__m128i *)&v250[3 * *(_DWORD *)(v13 + 36)];
        *(_BYTE *)(v13 + 13) &= ~0x10u;
        v95 = _printf_fphex(v121, (int)&savedregs, v13, v84, v252, (int)&v256[52 * v249], (const __m128i **)&v260);
        if ( v95 < 0 )
          goto LABEL_77;
        if ( v251 > 0x7FFFFFFE )
          goto LABEL_509;
        if ( 0x7FFFFFFF - v251 < v95 )
          goto LABEL_76;
        goto LABEL_149;
      case 'C':
        goto LABEL_159;
      case 'E':
      case 'F':
      case 'G':
      case 'e':
      case 'f':
      case 'g':
        v136 = (unsigned int)v250;
        v259 = (const __m128i *)&v250[3 * *(_DWORD *)(v13 + 36)];
        *(_BYTE *)(v13 + 13) &= ~0x10u;
        v95 = _printf_fp(v136, (int)&savedregs, v13, v84, v252, (int)&v256[52 * v249], &v259);
        if ( v95 < 0 )
          goto LABEL_77;
        if ( v251 > 0x7FFFFFFE )
          goto LABEL_509;
        if ( 0x7FFFFFFF - v251 < v95 )
          goto LABEL_76;
        goto LABEL_149;
      case 'S':
      case 's':
        v130 = (__m128i *)v250[3 * *(_DWORD *)(v13 + 36)];
        goto LABEL_245;
      case 'X':
      case 'x':
        v237 = 16;
        goto LABEL_182;
      case 'c':
        if ( (_BYTE)v236 )
        {
LABEL_159:
          v261 = 0;
          v205 = (int)&v261;
          v262 = 0;
          v99 = *(_DWORD *)(v13 + 36);
          v245 = (int)v268;
          v100 = wcrtomb(v268, (int)v250[3 * v99], &v261);
          v101 = v100;
          if ( v100 == -1 )
            goto LABEL_77;
          v102 = (_BYTE *)v245;
          v103 = v255 - v100;
          LOBYTE(v257) = v255 - v100 > 0;
          if ( v254 == 0.0 && (_BYTE)v257 )
          {
            v255 = v245;
            if ( v103 != IO_padn((int)v252, 32, v103) )
              goto LABEL_77;
            if ( v251 > 0x7FFFFFFE )
              goto LABEL_516;
            v102 = (_BYTE *)v255;
            if ( 0x7FFFFFFF - v251 < v103 )
              goto LABEL_76;
            v251 += v103;
          }
          if ( (v251 & 0x80000000) != 0 )
            goto LABEL_519;
          v104 = v252[37];
          if ( v212 <= v104 - (int)v213 )
          {
            v245 = (int)v102;
            v255 = v104;
            IO_vtable_check();
            v102 = (_BYTE *)v245;
            v104 = v255;
          }
          if ( v101 != (*(int (__cdecl **)(int *, _BYTE *, unsigned int))(v104 + 28))(v252, v102, v101) )
            goto LABEL_77;
          if ( 0x7FFFFFFF - v251 < v101 )
            goto LABEL_76;
          v36 = v101 + v251;
          v251 += v101;
          if ( v254 != 0.0 && (_BYTE)v257 )
          {
            v257 = 0x7FFFFFFF;
            if ( v103 != IO_padn((int)v252, 32, v103) )
              goto LABEL_77;
            v105 = v251;
            if ( v251 > 0x7FFFFFFE )
              goto LABEL_516;
            if ( v257 - v251 < v103 )
              goto LABEL_76;
            goto LABEL_176;
          }
        }
        else
        {
          v56 = v255 - 1;
          LOBYTE(v257) = v255 - 1 > 0;
          if ( v254 == 0.0 && v255 - 1 > 0 )
          {
            if ( v56 != IO_padn((int)v252, 32, v255 - 1) )
              goto LABEL_77;
            if ( v251 > 0x7FFFFFFE )
            {
LABEL_516:
              v197 = v253;
              v206 = v253 - 11526;
              v205 = 2018;
              goto LABEL_510;
            }
            if ( 0x7FFFFFFF - v251 < v56 )
              goto LABEL_76;
            v251 += v56;
          }
          v134 = v250[3 * *(_DWORD *)(v13 + 36)];
          v135 = (_BYTE *)v252[5];
          if ( (unsigned int)v135 >= v252[6] )
          {
            if ( _overflow((int)v252, (unsigned __int8)v134) == -1 )
              goto LABEL_77;
          }
          else
          {
            v252[5] = (int)(v135 + 1);
            *v135 = (_BYTE)v134;
          }
          if ( v251 == 0x7FFFFFFF )
            goto LABEL_77;
          v36 = LODWORD(v254);
          ++v251;
          if ( v254 != 0.0 && (_BYTE)v257 )
          {
            if ( v56 != IO_padn((int)v252, 32, v56) )
              goto LABEL_77;
            v57 = v251;
            if ( v251 > 0x7FFFFFFE )
              goto LABEL_516;
            if ( 0x7FFFFFFF - v251 < v56 )
              goto LABEL_76;
            goto LABEL_274;
          }
        }
        goto LABEL_150;
      case 'd':
      case 'i':
        v118 = 3 * *(_DWORD *)(v13 + 36);
        if ( v244 )
        {
          v237 = 10;
          v119 = &v250[v118];
          v120 = *v119;
          v238 = (signed int)v119[1];
          v244 = (unsigned int)v238 >> 31;
          v209[1] = v238 >> 31;
          v209[0] = v238 >> 31;
          v216 = __PAIR64__((v238 >> 31) ^ (unsigned int)v238, (v238 >> 31) ^ (unsigned int)v120)
               - __PAIR64__(v238 >> 31, v238 >> 31);
          goto LABEL_184;
        }
        v165 = (int *)&v250[3 * *(_DWORD *)(v13 + 36)];
        if ( (_BYTE)v237 )
        {
          v166 = *(char *)v165;
        }
        else if ( v238 )
        {
          v166 = *(__int16 *)v165;
        }
        else
        {
          v166 = *v165;
        }
        v237 = 10;
        v167 = v166;
        v122 = abs32(v166);
        v244 = v167 >> 31;
        v238 = v122;
        goto LABEL_294;
      case 'm':
        v245 = v36;
        v129 = strerror_r(v230, v232, 0x3E8u);
        LOBYTE(v36) = v245;
        v130 = (__m128i *)v129;
        v87 = 0;
LABEL_245:
        if ( v130 )
        {
          if ( (v87 & 1) != 0 || (_BYTE)v36 == 83 )
          {
            v260 = v130;
            v244 = (unsigned int)&v261;
            v261 = 0;
            v262 = 0;
            if ( v257 >= 0 )
              goto LABEL_395;
            v257 = (int)&v260;
            v103 = wcsrtombs(0, (int *)&v260, 0, (int *)v244);
            if ( v103 == -1 )
              goto LABEL_77;
            v245 = (int)v261;
            if ( v261 )
              _assert_fail((int)v253 - 115479, (int)(v253 - 11549), 2018, (int)(v253 - 11526));
            v260 = v130;
            v243 = (const struct timespec *)(v103 + 1);
            v186 = _libc_alloca_cutoff(v103 + 1);
            v187 = v243;
            if ( (unsigned int)v243 <= 0x1000 || v186 )
            {
              v188 = &v207[-(((unsigned int)&v243[3].tv_sec + 3) & 0xFFFFF000)];
              if ( v207 != v188 )
              {
                while ( v202 != v188 )
                  ;
              }
              v189 = ((_WORD)v243 + 27) & 0xFF0;
              if ( (((_WORD)v243 + 27) & 0xFF0) != 0 )
              {
                v190 = alloca(v189);
                *(_DWORD *)&v202[v189 - 4] = *(_DWORD *)&v202[v189 - 4];
              }
              v130 = (__m128i *)v202;
            }
            else
            {
              v130 = (__m128i *)malloc(v243);
              if ( !v130 )
                goto LABEL_77;
              v245 = 1;
              v187 = v243;
            }
            wcsrtombs((int)v130, (int *)v257, (int)v187, (int *)v244);
          }
          else
          {
            if ( v257 != -1 )
              goto LABEL_249;
            v175 = strlen((unsigned int *)v130);
            v245 = 0;
            v103 = v175;
          }
        }
        else
        {
          v245 = 0;
          if ( v257 == -1 || v257 > 5 )
          {
            v103 = 6;
            v130 = (__m128i *)((char *)v253 - 115216);
          }
          else
          {
            v103 = 0;
            v130 = (__m128i *)((char *)v253 - 105991);
          }
        }
        goto LABEL_250;
      case 'n':
        if ( (v252[15] & 4) != 0 )
        {
          if ( !v231 )
          {
            v184 = strlen(v229);
            v231 = _readonly_area((unsigned int)v229, v184 + 1);
          }
          if ( v231 < 0 )
            _libc_fatal((_BYTE)v253 - 104);
        }
        v36 = v244;
        v128 = v250[3 * *(_DWORD *)(v13 + 36)];
        if ( v244 )
        {
          *(_QWORD *)v128 = (int)v251;
        }
        else if ( v85 )
        {
          v36 = (unsigned __int8)v251;
          *v128 = v251;
        }
        else if ( v238 )
        {
          *(_WORD *)v128 = v251;
        }
        else
        {
          *(_DWORD *)v128 = v251;
        }
        goto LABEL_150;
      case 'o':
        v237 = 8;
        goto LABEL_182;
      case 'p':
        v122 = (unsigned int)v250[3 * *(_DWORD *)(v13 + 36)];
        if ( !v122 )
        {
          v180 = 5;
          if ( v257 >= 5 )
            v180 = v257;
          v257 = v180;
          v130 = (__m128i *)((char *)v253 - 115496);
          if ( (_BYTE)v36 == 83 )
          {
            v260 = (__m128i *)((char *)v253 - 115496);
            v244 = (unsigned int)&v261;
            v261 = 0;
            v262 = 0;
LABEL_395:
            v169 = v257;
            v170 = _libc_alloca_cutoff(v257);
            if ( v169 <= 4096 || v170 )
            {
              v171 = &v207[-((v257 + 27) & 0xFFFFF000)];
              if ( v207 != v171 )
              {
                while ( v202 != v171 )
                  ;
              }
              v172 = ((_WORD)v257 + 27) & 0xFF0;
              if ( (((_WORD)v257 + 27) & 0xFF0) != 0 )
              {
                v173 = alloca(v172);
                *(_DWORD *)&v202[v172 - 4] = *(_DWORD *)&v202[v172 - 4];
              }
              v245 = 0;
              v130 = (__m128i *)v202;
            }
            else
            {
              v130 = (__m128i *)malloc((const struct timespec *)v169);
              if ( !v130 )
                goto LABEL_77;
              v245 = 1;
            }
            v103 = wcsrtombs((int)v130, (int *)&v260, v257, (int *)v244);
            if ( v103 == -1 )
              goto LABEL_77;
          }
          else
          {
LABEL_249:
            v131 = strnlen(v130, v257);
            v245 = 0;
            v103 = v131;
          }
LABEL_250:
          v132 = v255 == v103;
          v255 -= v103;
          if ( v255 < 0 )
          {
            if ( (v251 & 0x80000000) == 0 )
            {
              v157 = v252[37];
              if ( v210 <= v157 - (int)v211 )
              {
                v257 = v252[37];
                IO_vtable_check();
                v157 = v257;
              }
              if ( v103 != (*(int (__cdecl **)(int *, __m128i *, unsigned int))(v157 + 28))(v252, v130, v103) )
                goto LABEL_77;
              v105 = v251;
              if ( 0x7FFFFFFF - v251 < v103 )
                goto LABEL_76;
LABEL_176:
              v251 = v103 + v105;
              goto LABEL_150;
            }
LABEL_519:
            v198 = v253;
            v206 = v253 - 11526;
            v205 = 2018;
LABEL_518:
            _assert_fail((int)(v198 - 11534), (int)(v198 - 11549), v200, v201);
          }
          LOBYTE(v257) = !v132;
          if ( v254 == 0.0 && !v132 )
          {
            v181 = IO_padn((int)v252, 32, v255);
            if ( v255 != v181 )
              goto LABEL_77;
            if ( v251 > 0x7FFFFFFE )
              goto LABEL_516;
            if ( 0x7FFFFFFF - v251 < v255 )
              goto LABEL_76;
            v251 += v255;
          }
          if ( (v251 & 0x80000000) != 0 )
            goto LABEL_519;
          v133 = v252[37];
          if ( v214 <= v133 - (int)v215 )
          {
            v244 = v252[37];
            IO_vtable_check();
            v133 = v244;
          }
          if ( v103 != (*(int (__cdecl **)(int *, __m128i *, unsigned int))(v133 + 28))(v252, v130, v103) )
            goto LABEL_77;
          if ( 0x7FFFFFFF - v251 < v103 )
            goto LABEL_76;
          v36 = v103 + v251;
          v251 += v103;
          if ( v254 != 0.0 && (_BYTE)v257 )
          {
            v183 = v255;
            v257 = 0x7FFFFFFF;
            if ( v183 != IO_padn((int)v252, 32, v255) )
              goto LABEL_77;
            if ( v251 > 0x7FFFFFFE )
              goto LABEL_516;
            if ( v257 - v251 < v183 )
              goto LABEL_76;
            v36 = v183 + v251;
            v251 += v183;
          }
          if ( v245 )
            free((int)&savedregs, (int *)v13, (int)v130);
          goto LABEL_150;
        }
        v238 = (signed int)v250[3 * *(_DWORD *)(v13 + 36)];
        if ( v257 < 0 )
        {
          v185 = (_BYTE *)itoa_word(v238, (int)v228, 0x10u, 0);
          v240 = 120;
          v245 = (int)v185;
          v237 = 16;
          v257 = 1;
          v223 = 1;
          v244 = 0;
          goto LABEL_236;
        }
        v244 = 0;
        v123 = 0;
        v223 = 1;
        v240 = 120;
        v237 = 16;
        if ( v257 )
          goto LABEL_347;
        goto LABEL_231;
      case 'u':
        v237 = 10;
LABEL_182:
        v106 = (unsigned int *)&v250[3 * *(_DWORD *)(v13 + 36)];
        if ( v244 )
        {
          v243 = 0;
          HIDWORD(v107) = v106[1];
          v225 = 0;
          LODWORD(v107) = *v106;
          v216 = v107;
          v244 = 0;
LABEL_184:
          if ( v257 < 0 )
          {
            v257 = 1;
          }
          else
          {
            if ( !v257 && !v216 )
            {
              if ( v237 == 8 && (_BYTE)v245 )
              {
                v108 = v228;
                v242 = 32;
                *((_BYTE *)v228 - 1) = 48;
                v245 = (int)v108 - 1;
                v109 = 1;
              }
              else
              {
                v109 = 0;
                v242 = 32;
                v245 = (int)v228;
              }
LABEL_190:
              v238 = v216 != 0;
              goto LABEL_191;
            }
            v242 = 32;
          }
          v153 = v228;
          v154 = itoa(v216, v228, v237, (_BYTE)v36 == 88);
          v245 = (int)v154;
          if ( v246 && v241 )
            v245 = (int)group_number(v232, v154, v153, v246, v233);
          v155 = v228;
          if ( v237 == 10 && v239 )
          {
            v245 = (int)i18n_number_rewrite((_BYTE *)v245, (int)v228, v228);
            v109 = (int)v155 - v245;
          }
          else
          {
            v109 = (int)v228 - v245;
          }
          goto LABEL_190;
        }
        if ( v85 )
        {
          v243 = 0;
          v122 = *(unsigned __int8 *)v106;
          v225 = 0;
          v238 = v122;
        }
        else
        {
          v243 = 0;
          if ( v238 )
            v122 = *(unsigned __int16 *)v106;
          else
            v122 = *v106;
          v225 = 0;
          v238 = v122;
        }
LABEL_294:
        v123 = v241;
        if ( v257 < 0 )
        {
          v257 = 1;
        }
        else if ( v257 )
        {
LABEL_347:
          v242 = 32;
          v241 = v123 & 1;
        }
        else
        {
          if ( !v122 )
          {
            if ( v237 == 8 && (_BYTE)v245 )
            {
              v257 = -1;
              v141 = v228;
              v223 = 1;
              *((_BYTE *)v228 - 1) = 48;
              v245 = (int)v141 - 1;
              v109 = 1;
            }
            else
            {
              v109 = 0;
              v257 = 0;
              v245 = (int)v228;
            }
            v242 = 32;
            goto LABEL_301;
          }
LABEL_231:
          v242 = 32;
          v257 = 0;
          v241 = v123 & 1;
        }
        v124 = v237;
        v125 = v228;
        v126 = (_BYTE *)itoa_word(v122, (int)v228, v237, v240 == 88);
        v245 = (int)v126;
        v127 = v239 && v124 == 10;
        if ( v246 && v241 )
          v245 = (int)group_number(v232, v126, v125, v246, v233);
        if ( v127 )
        {
          v159 = v228;
          v245 = (int)i18n_number_rewrite((_BYTE *)v245, (int)v228, v228);
          v109 = (int)v159 - v245;
        }
        else
        {
LABEL_236:
          v109 = (int)v228 - v245;
        }
LABEL_191:
        if ( v257 > v109 )
        {
          v110 = v257;
          v257 -= v109;
          if ( v254 == 0.0 )
          {
            v111 = v255 - v110;
            if ( !v238 )
              goto LABEL_198;
            v112 = v223 & 1;
            goto LABEL_195;
          }
          v236 = (int *)v257;
          goto LABEL_303;
        }
        if ( !v238 )
        {
          v257 -= v109;
LABEL_301:
          if ( v254 == 0.0 )
          {
            v257 = 0;
            v111 = v255 - v109;
            goto LABEL_198;
          }
          v236 = 0;
          goto LABEL_303;
        }
        v112 = v223 & 1;
        if ( v237 == 8 && v112 )
        {
          v139 = (_BYTE *)(v245 - 1);
          *v139 = 48;
          v245 = (int)v139;
          v109 = (char *)v228 - v139;
        }
        v140 = 0;
        if ( v257 - v109 >= 0 )
          v140 = (int *)(v257 - v109);
        v257 -= v109;
        v236 = v140;
        if ( v254 == 0.0 )
        {
          v257 = (int)v236;
          v111 = v255 - ((_DWORD)v236 + v109);
LABEL_195:
          if ( v237 == 16 && v112 )
            v111 -= 2;
LABEL_198:
          if ( v225 | (unsigned int)v243 | v244 )
          {
            --v111;
            if ( v242 != 32 )
            {
LABEL_200:
              if ( v244 )
              {
                v113 = (_BYTE *)v252[5];
                if ( (unsigned int)v113 < v252[6] )
                {
                  v252[5] = (int)(v113 + 1);
                  *v113 = 45;
LABEL_203:
                  if ( v251 == 0x7FFFFFFF )
                    goto LABEL_77;
                  ++v251;
                  goto LABEL_205;
                }
                v255 = v111;
                v204 = 45;
                v203 = v252;
                goto LABEL_466;
              }
              if ( v243 )
              {
                v158 = (_BYTE *)v252[5];
                if ( (unsigned int)v158 < v252[6] )
                {
                  v252[5] = (int)(v158 + 1);
                  *v158 = 43;
                  goto LABEL_203;
                }
                v255 = v111;
                v204 = 43;
                v203 = v252;
LABEL_466:
                v191 = _overflow((int)v203, v204);
                v111 = v255;
                if ( v191 == -1 )
                  goto LABEL_77;
                goto LABEL_203;
              }
              if ( v225 )
              {
                v182 = (_BYTE *)v252[5];
                if ( (unsigned int)v182 < v252[6] )
                {
                  v252[5] = (int)(v182 + 1);
                  *v182 = 32;
                  goto LABEL_203;
                }
                v255 = v111;
                v204 = 32;
                v203 = v252;
                goto LABEL_466;
              }
LABEL_205:
              if ( v238 && v237 == 16 && (v223 & 1) != 0 )
              {
                v114 = (_BYTE *)v252[5];
                if ( (unsigned int)v114 >= v252[6] )
                {
                  v255 = v111;
                  v196 = _overflow((int)v252, 48);
                  v111 = v255;
                  if ( v196 == -1 )
                    goto LABEL_77;
                }
                else
                {
                  v252[5] = (int)(v114 + 1);
                  *v114 = 48;
                }
                if ( v251 == 0x7FFFFFFF )
                  goto LABEL_77;
                v115 = (unsigned __int8 *)v252[5];
                if ( (unsigned int)v115 >= v252[6] )
                {
                  v255 = v111;
                  v195 = _overflow((int)v252, v240);
                  v111 = v255;
                  if ( v195 == -1 )
                    goto LABEL_77;
                }
                else
                {
                  v252[5] = (int)(v115 + 1);
                  *v115 = v240;
                }
                if ( v251 == 2147483646 )
                  goto LABEL_77;
                v251 += 2;
              }
              v116 = (char *)(v111 + v257);
              if ( v111 + v257 > 0 )
              {
                v257 += v111;
                v156 = (int *)IO_padn((int)v252, 48, (int)v116);
                if ( (int *)v257 != v156 )
                  goto LABEL_77;
                if ( v251 > 0x7FFFFFFE )
                  goto LABEL_509;
                if ( 0x7FFFFFFF - v251 < v257 )
                  goto LABEL_76;
                v251 += v257;
              }
              if ( (v251 & 0x80000000) != 0 )
                goto LABEL_517;
              v117 = v252[37];
              if ( v217 <= v117 - (int)v218 )
              {
                v257 = v252[37];
                IO_vtable_check();
                v117 = v257;
              }
              if ( v109 != (*(int (__cdecl **)(int *, int, int))(v117 + 28))(v252, v245, v109) )
                goto LABEL_77;
              if ( (int)(0x7FFFFFFF - v251) < v109 )
                goto LABEL_76;
              v36 = v109 + v251;
              v251 += v109;
              goto LABEL_150;
            }
            if ( v111 <= 0 )
            {
              v111 = 0;
              goto LABEL_200;
            }
          }
          else
          {
            if ( v242 != 32 )
              goto LABEL_205;
            if ( v111 <= 0 )
            {
              v111 = 0;
              goto LABEL_205;
            }
          }
          v255 = v111;
          v152 = IO_padn((int)v252, 32, v111);
          if ( v152 != v255 )
            goto LABEL_77;
          if ( v251 > 0x7FFFFFFE )
            goto LABEL_509;
          if ( 0x7FFFFFFF - v251 < v255 )
            goto LABEL_76;
          v111 = 0;
          v251 += v255;
          goto LABEL_200;
        }
LABEL_303:
        if ( v244 )
        {
          v142 = (_BYTE *)v252[5];
          if ( (unsigned int)v142 >= v252[6] )
          {
            if ( _overflow((int)v252, 45) == -1 )
              goto LABEL_77;
          }
          else
          {
            v252[5] = (int)(v142 + 1);
            *v142 = 45;
          }
          goto LABEL_306;
        }
        if ( v243 )
        {
          v150 = v252;
          v151 = (_BYTE *)v252[5];
          if ( (unsigned int)v151 < v252[6] )
          {
            v252[5] = (int)(v151 + 1);
            *v151 = 43;
LABEL_306:
            if ( v251 == 0x7FFFFFFF )
              goto LABEL_77;
            --v255;
            ++v251;
            goto LABEL_308;
          }
          v204 = 43;
          goto LABEL_476;
        }
        if ( v225 )
        {
          v150 = v252;
          v160 = (_BYTE *)v252[5];
          if ( (unsigned int)v160 < v252[6] )
          {
            v252[5] = (int)(v160 + 1);
            *v160 = 32;
            goto LABEL_306;
          }
          v204 = 32;
LABEL_476:
          if ( _overflow((int)v150, v204) == -1 )
            goto LABEL_77;
          goto LABEL_306;
        }
LABEL_308:
        if ( v238 && v237 == 16 && (v223 & 1) != 0 )
        {
          v143 = (_BYTE *)v252[5];
          if ( (unsigned int)v143 >= v252[6] )
          {
            if ( _overflow((int)v252, 48) == -1 )
              goto LABEL_77;
          }
          else
          {
            v252[5] = (int)(v143 + 1);
            *v143 = 48;
          }
          if ( v251 == 0x7FFFFFFF )
            goto LABEL_77;
          v144 = (unsigned __int8 *)v252[5];
          if ( (unsigned int)v144 >= v252[6] )
          {
            if ( _overflow((int)v252, v240) == -1 )
              goto LABEL_77;
          }
          else
          {
            v145 = v240;
            v252[5] = (int)(v144 + 1);
            *v144 = v145;
          }
          if ( v251 == 2147483646 )
            goto LABEL_77;
          v255 -= 2;
          v251 += 2;
        }
        v146 = (unsigned int)v236;
        v255 -= (int)v236 + v109;
        if ( v257 > 0 )
        {
          if ( IO_padn((int)v252, 48, (int)v236) != v146 )
            goto LABEL_77;
          if ( v251 > 0x7FFFFFFE )
          {
LABEL_509:
            v197 = v253;
            v206 = v253 - 11526;
            v205 = 2017;
            goto LABEL_510;
          }
          if ( 0x7FFFFFFF - v251 < v146 )
            goto LABEL_76;
          v251 += v146;
        }
        if ( (v251 & 0x80000000) != 0 )
        {
LABEL_517:
          v198 = v253;
          v206 = v253 - 11526;
          v205 = 2017;
          goto LABEL_518;
        }
        v147 = v252[37];
        if ( v219 <= v147 - (int)v220 )
        {
          v257 = v252[37];
          IO_vtable_check();
          v147 = v257;
        }
        if ( v109 != (*(int (__cdecl **)(int *, int, int))(v147 + 28))(v252, v245, v109) )
          goto LABEL_77;
        if ( (int)(0x7FFFFFFF - v251) < v109 )
          goto LABEL_76;
        v148 = v109 + v251;
        v251 = v148;
        v36 = v255;
        if ( v255 > 0 )
        {
          v149 = IO_padn((int)v252, 32, v255);
          v36 = v255;
          if ( v255 != v149 )
            goto LABEL_77;
          if ( v148 > 0x7FFFFFFE )
            goto LABEL_509;
          if ( 0x7FFFFFFF - v148 < v255 )
            goto LABEL_76;
          v251 = v255 + v148;
        }
LABEL_150:
        if ( v247 )
          free((int)&savedregs, (int *)v13, (int)v247);
        if ( (v251 & 0x80000000) != 0 )
          _assert_fail((int)(v253 - 11534), (int)(v253 - 11549), 2057, (int)(v253 - 11526));
        v96 = v252[37];
        if ( v226 <= v96 - (int)v227 )
          IO_vtable_check();
        v97 = (*(int (__thiscall **)(int, int *, _DWORD, int))(v96 + 28))(
                v36,
                v252,
                *(_DWORD *)(v13 + 20),
                *(_DWORD *)(v13 + 24) - *(_DWORD *)(v13 + 20));
        v98 = *(_DWORD *)(v13 + 24) - *(_DWORD *)(v13 + 20);
        if ( v98 != v97 )
          break;
        if ( v98 <= (int)(0x7FFFFFFF - v251) )
        {
          ++v249;
          v13 += 52;
          v251 += v98;
          if ( v249 >= v224 )
            goto LABEL_158;
          continue;
        }
        v58 = -1;
        __writegsdword(0xFFFFFFE0, 0x4Bu);
LABEL_80:
        if ( (char *)v266[0] != v234 )
          free((int)&savedregs, (int *)v13, v266[0]);
        if ( v263 != v248 )
          free((int)&savedregs, (int *)v13, (int)v263);
        return v58;
      default:
        v65 = *(_DWORD *)(v13 + 44);
        v36 = 4 * v65;
        v66 = 4 * v65 + 27;
        v67 = &v207[-(v66 & 0xFFFFF000)];
        v68 = v66 & 0xFFF0;
        if ( v207 != v67 )
        {
          while ( v202 != v67 )
            ;
        }
        v69 = v68 & 0xFFF;
        if ( v69 )
        {
          v70 = alloca(v69);
          *(_DWORD *)&v202[v69 - 4] = *(_DWORD *)&v202[v69 - 4];
        }
        v71 = (char ***)v202;
        if ( v65 )
        {
          v36 += (int)v202;
          v72 = &v250[3 * *(_DWORD *)(v13 + 36)];
          do
          {
            *v71++ = v72;
            v72 += 3;
          }
          while ( (char ***)v36 != v71 );
        }
        v73 = (_BYTE *)v252[5];
        if ( (unsigned int)v73 >= v252[6] )
        {
          if ( _overflow((int)v252, 37) == -1 )
            goto LABEL_77;
        }
        else
        {
          v252[5] = (int)(v73 + 1);
          *v73 = 37;
        }
        v74 = *(_BYTE *)(v13 + 12);
        if ( (v74 & 8) != 0 )
        {
          v75 = (_BYTE *)v252[5];
          if ( (unsigned int)v75 >= v252[6] )
          {
            if ( _overflow((int)v252, 35) == -1 )
              goto LABEL_77;
          }
          else
          {
            v252[5] = (int)(v75 + 1);
            *v75 = 35;
          }
          v74 = *(_BYTE *)(v13 + 12);
          v56 = 2;
        }
        else
        {
          v56 = 1;
        }
        if ( v74 >= 0 )
          goto LABEL_106;
        v174 = (_BYTE *)v252[5];
        if ( (unsigned int)v174 >= v252[6] )
        {
          if ( _overflow((int)v252, 39) == -1 )
            goto LABEL_77;
        }
        else
        {
          v252[5] = (int)(v174 + 1);
          *v174 = 39;
        }
        ++v56;
        v74 = *(_BYTE *)(v13 + 12);
LABEL_106:
        if ( (v74 & 0x40) != 0 )
        {
          v76 = (_BYTE *)v252[5];
          if ( (unsigned int)v76 < v252[6] )
          {
            v252[5] = (int)(v76 + 1);
            *v76 = 43;
LABEL_109:
            v74 = *(_BYTE *)(v13 + 12);
            ++v56;
            goto LABEL_110;
          }
          v194 = _overflow((int)v252, 43);
          goto LABEL_486;
        }
        if ( (v74 & 0x10) != 0 )
        {
          v168 = (_BYTE *)v252[5];
          if ( (unsigned int)v168 < v252[6] )
          {
            v252[5] = (int)(v168 + 1);
            *v168 = 32;
            goto LABEL_109;
          }
          v194 = _overflow((int)v252, 32);
LABEL_486:
          if ( v194 == -1 )
            goto LABEL_77;
          goto LABEL_109;
        }
LABEL_110:
        if ( (v74 & 0x20) != 0 )
        {
          v77 = (_BYTE *)v252[5];
          if ( (unsigned int)v77 >= v252[6] )
          {
            if ( _overflow((int)v252, 45) == -1 )
              goto LABEL_77;
          }
          else
          {
            v252[5] = (int)(v77 + 1);
            *v77 = 45;
          }
          ++v56;
        }
        if ( *(_DWORD *)(v13 + 16) == 48 )
        {
          v179 = (_BYTE *)v252[5];
          if ( (unsigned int)v179 >= v252[6] )
          {
            if ( _overflow((int)v252, 48) == -1 )
              goto LABEL_77;
          }
          else
          {
            v252[5] = (int)(v179 + 1);
            *v179 = 48;
          }
          ++v56;
        }
        if ( (*(_BYTE *)(v13 + 13) & 8) != 0 )
        {
          v78 = (_BYTE *)v252[5];
          if ( (unsigned int)v78 >= v252[6] )
          {
            if ( _overflow((int)v252, 73) == -1 )
              goto LABEL_77;
          }
          else
          {
            v252[5] = (int)(v78 + 1);
            *v78 = 73;
          }
          ++v56;
        }
        v79 = *(_DWORD *)(v13 + 4);
        if ( v79 )
        {
          v257 = (int)v269;
          v176 = (int *)itoa_word(v79, (int)v269, 0xAu, 0);
          if ( (unsigned int)v176 < v257 )
          {
            v255 = v13;
            v13 = (unsigned int)v252;
            do
            {
              v176 = (int *)((char *)v176 + 1);
              v177 = *((_BYTE *)v176 - 1);
              v178 = *(_BYTE **)(v13 + 20);
              if ( (unsigned int)v178 < *(_DWORD *)(v13 + 24) )
              {
                v36 = (int)(v178 + 1);
                *(_DWORD *)(v13 + 20) = v178 + 1;
                *v178 = v177;
              }
              else if ( _overflow(v13, *((unsigned __int8 *)v176 - 1)) == -1 )
              {
                goto LABEL_77;
              }
              if ( v56 == 0x7FFFFFFF )
                goto LABEL_77;
              ++v56;
            }
            while ( v176 != (int *)v257 );
            v13 = v255;
          }
        }
        if ( *(_DWORD *)v13 != -1 )
        {
          v80 = (_BYTE *)v252[5];
          if ( (unsigned int)v80 >= v252[6] )
          {
            if ( _overflow((int)v252, 46) == -1 )
              goto LABEL_77;
          }
          else
          {
            v252[5] = (int)(v80 + 1);
            *v80 = 46;
          }
          if ( v56 == 0x7FFFFFFF )
            goto LABEL_77;
          v201 = 0;
          ++v56;
          v199 = *(_DWORD *)v13;
          v257 = (int)v269;
          v81 = (int *)itoa_word(v199, (int)v269, 0xAu, 0);
          if ( (unsigned int)v81 < v257 )
          {
            v255 = v13;
            v13 = (unsigned int)v252;
            do
            {
              v81 = (int *)((char *)v81 + 1);
              v82 = *((_BYTE *)v81 - 1);
              v83 = *(_BYTE **)(v13 + 20);
              if ( (unsigned int)v83 < *(_DWORD *)(v13 + 24) )
              {
                v36 = (int)(v83 + 1);
                *(_DWORD *)(v13 + 20) = v83 + 1;
                *v83 = v82;
              }
              else if ( _overflow(v13, *((unsigned __int8 *)v81 - 1)) == -1 )
              {
                goto LABEL_77;
              }
              if ( v56 == 0x7FFFFFFF )
                goto LABEL_77;
              ++v56;
            }
            while ( v81 != (int *)v257 );
            v13 = v255;
          }
        }
        v54 = *(_DWORD *)(v13 + 8);
        if ( v54 )
        {
          v55 = (_BYTE *)v252[5];
          if ( (unsigned int)v55 >= v252[6] )
          {
            if ( _overflow((int)v252, (unsigned __int8)v54) == -1 )
              goto LABEL_77;
          }
          else
          {
            v36 = (int)(v55 + 1);
            v252[5] = (int)(v55 + 1);
            *v55 = v54;
          }
          if ( v56 == 0x7FFFFFFF )
            goto LABEL_77;
          ++v56;
        }
        if ( v251 > 0x7FFFFFFE )
          _assert_fail((int)v253 - 115388, (int)(v253 - 11549), 2045, (int)(v253 - 11526));
        v57 = v251;
        if ( 0x7FFFFFFF - v251 >= v56 )
        {
LABEL_274:
          v251 = v56 + v57;
          goto LABEL_150;
        }
LABEL_76:
        __writegsdword(0xFFFFFFE0, 0x4Bu);
LABEL_77:
        if ( v247 )
          free((int)&savedregs, (int *)v13, (int)v247);
        break;
    }
    break;
  }
LABEL_79:
  v58 = -1;
  goto LABEL_80;
}
// 8072FF6: variable 'v36' is possibly undefined
// 80CE000: using guessed type _TBYTE GLOBAL_OFFSET_TABLE_;
// 80CEFA0: using guessed type int _start___libc_IO_vtables[24];
// 80CF2F4: using guessed type int (*_start___libc_atexit)();
// 8072380: using guessed type char var_20[4];

//----- (08074CB0) --------------------------------------------------------
void __usercall vfprintf(int a1@<ebx>, int a2@<esi>, int a3, unsigned int *a4, int a5)
{
  int v5; // eax
  unsigned int v6; // edx
  int v7; // ebx
  unsigned int *v8; // edx
  char v9; // bl
  char *v10; // ecx
  unsigned int v12; // ebx
  bool v14; // zf
  int *v15; // edx
  int v16; // eax
  unsigned int v17; // eax
  _BOOL4 v18; // eax
  struct timespec *v19; // edx
  _BYTE *v20; // eax
  int v21; // eax
  void *v22; // esp
  void *v23; // eax
  int v24; // eax
  _BOOL4 v25; // eax
  struct timespec *v26; // edx
  _BYTE *v27; // eax
  int v28; // eax
  void *v29; // esp
  char v30; // bl
  int v31; // eax
  unsigned int v32; // ebx
  int v33; // edx
  int v34; // ecx
  unsigned int *v35; // eax
  const struct timespec *v36; // ecx
  int v37; // ebx
  int v38; // eax
  int v39; // ecx
  unsigned __int8 *v40; // eax
  unsigned int *v41; // edx
  unsigned int v42; // eax
  int *p_tv_sec; // edx
  unsigned int v44; // ecx
  int v45; // ebx
  int v46; // eax
  int v47; // ebx
  _QWORD *v48; // eax
  unsigned int v49; // eax
  char *v50; // ecx
  _BYTE *v51; // edx
  bool v52; // sf
  int *v53; // eax
  int *v54; // ecx
  int v55; // edx
  _BYTE *v56; // eax
  _BYTE *v57; // eax
  char *v58; // eax
  unsigned int v59; // ebx
  int v60; // ebx
  int v61; // eax
  int v62; // eax
  long double v63; // fst6
  int v64; // eax
  unsigned __int8 *v65; // eax
  unsigned __int64 v66; // rax
  char *v67; // ecx
  unsigned int v68; // ebx
  int v69; // edx
  _BYTE *v70; // eax
  int v71; // eax
  long double v72; // fst6
  int v73; // eax
  _BYTE *v74; // eax
  unsigned int *v75; // eax
  int v76; // eax
  _BYTE *v77; // eax
  _BYTE *v78; // eax
  char *v79; // eax
  int v80; // eax
  int v81; // eax
  _BYTE *v82; // edx
  _BYTE *v83; // eax
  int v84; // ebx
  int *v85; // eax
  int *v86; // edx
  _BYTE *v87; // eax
  int v88; // eax
  _BYTE *v89; // edx
  int *v90; // eax
  _BYTE *v91; // eax
  _BYTE *v92; // eax
  __int64 v93; // xmm0_8
  int v94; // eax
  unsigned int v95; // ecx
  __int64 v96; // xmm2_8
  int v97; // ebx
  _BYTE *v98; // ebx
  int v99; // edx
  void *v100; // esp
  int v101; // eax
  int v102; // eax
  int v103; // edx
  int v104; // eax
  _BOOL4 v105; // eax
  const struct timespec *v106; // edx
  _BYTE *v107; // eax
  int v108; // eax
  void *v109; // esp
  int v110; // eax
  int v111; // eax
  _BYTE *v112; // edx
  unsigned int *v113; // ebx
  char v114; // al
  _BYTE *v115; // eax
  _BYTE *v116; // eax
  unsigned int v117; // ebx
  unsigned int v118; // eax
  int v119; // eax
  int v120; // eax
  unsigned int v121; // ebx
  int v122; // eax
  int v123; // eax
  int v124; // ecx
  const struct timespec *v125; // ebx
  _BOOL4 v126; // eax
  unsigned int v127; // ecx
  _BYTE *v128; // ebx
  int v129; // edx
  void *v130; // esp
  int *v131; // edx
  int v132; // eax
  int v133; // eax
  int v134; // eax
  int v135; // eax
  const struct timespec *v136; // eax
  _BYTE v137[4088]; // [esp-200Ch] [ebp-2508h] BYREF
  int v138; // [esp-1014h] [ebp-1510h]
  _BYTE v139[4]; // [esp-1010h] [ebp-150Ch]
  _BYTE v140[4084]; // [esp-100Ch] [ebp-1508h] BYREF
  int v141; // [esp-18h] [ebp-514h]
  int v142; // [esp-14h] [ebp-510h]
  void *v143; // [esp-10h] [ebp-50Ch]
  _BYTE v144[12]; // [esp-Ch] [ebp-508h] BYREF
  char *v145; // [esp+0h] [ebp-4FCh]
  int v146; // [esp+4h] [ebp-4F8h]
  int v147; // [esp+8h] [ebp-4F4h]
  unsigned int v148; // [esp+Ch] [ebp-4F0h]
  int v149; // [esp+10h] [ebp-4ECh]
  unsigned __int64 v150; // [esp+14h] [ebp-4E8h]
  int v151; // [esp+1Ch] [ebp-4E0h]
  char *v152; // [esp+20h] [ebp-4DCh]
  int v153; // [esp+24h] [ebp-4D8h]
  int v154; // [esp+28h] [ebp-4D4h]
  signed int v155; // [esp+2Ch] [ebp-4D0h]
  int v156; // [esp+30h] [ebp-4CCh]
  int v157; // [esp+34h] [ebp-4C8h]
  int v158; // [esp+38h] [ebp-4C4h]
  int v159; // [esp+3Ch] [ebp-4C0h]
  unsigned __int8 v160; // [esp+43h] [ebp-4B9h]
  unsigned int v161; // [esp+44h] [ebp-4B8h]
  unsigned int v162; // [esp+48h] [ebp-4B4h]
  struct timespec *v163; // [esp+4Ch] [ebp-4B0h]
  int v164; // [esp+50h] [ebp-4ACh]
  int v165; // [esp+54h] [ebp-4A8h]
  int v166; // [esp+58h] [ebp-4A4h]
  int v167; // [esp+5Ch] [ebp-4A0h]
  _BYTE *v168; // [esp+60h] [ebp-49Ch]
  unsigned int v169; // [esp+64h] [ebp-498h]
  int v170; // [esp+68h] [ebp-494h]
  const struct timespec *v171; // [esp+6Ch] [ebp-490h]
  int *v172; // [esp+70h] [ebp-48Ch]
  unsigned int v173; // [esp+74h] [ebp-488h]
  unsigned int *v174; // [esp+78h] [ebp-484h]
  long double v175; // [esp+7Ch] [ebp-480h]
  unsigned int v176; // [esp+88h] [ebp-474h]
  unsigned int *v177; // [esp+8Ch] [ebp-470h]
  unsigned int v178; // [esp+90h] [ebp-46Ch]
  unsigned int *v179; // [esp+A0h] [ebp-45Ch] BYREF
  int v180; // [esp+A4h] [ebp-458h] BYREF
  LONG_DOUBLE_12 *v181; // [esp+A8h] [ebp-454h] BYREF
  LONG_DOUBLE_12 *v182; // [esp+ACh] [ebp-450h] BYREF
  LONG_DOUBLE_12 v183; // [esp+B0h] [ebp-44Ch] BYREF
  int v184[4]; // [esp+BCh] [ebp-440h] BYREF
  const char *v185; // [esp+CCh] [ebp-430h] BYREF
  int v186; // [esp+D0h] [ebp-42Ch]
  int v187; // [esp+D4h] [ebp-428h]
  int v188; // [esp+D8h] [ebp-424h]
  int v189; // [esp+DCh] [ebp-420h]
  int v190; // [esp+E0h] [ebp-41Ch] BYREF
  int v191; // [esp+E4h] [ebp-418h]
  char v192[16]; // [esp+E8h] [ebp-414h] BYREF
  unsigned __int8 v193[1000]; // [esp+F8h] [ebp-404h] BYREF
  int v194[7]; // [esp+4E0h] [ebp-1Ch] BYREF
  int savedregs; // [esp+4FCh] [ebp+0h] BYREF

  v194[5] = a2;
  v194[4] = a1;
  v177 = a4;
  LODWORD(v175) = a5;
  v194[0] = __readgsdword(0x14u);
  v169 = -32;
  v168 = (_BYTE *)__readgsdword(0xFFFFFFE0);
  v5 = *(_DWORD *)(a3 + 104);
  if ( v5 )
  {
    if ( v5 != -1 )
    {
      v178 = -1;
      return;
    }
  }
  else
  {
    *(_DWORD *)(a3 + 104) = -1;
  }
  v6 = *(_DWORD *)a3;
  if ( (*(_DWORD *)a3 & 8) != 0 )
  {
    v118 = v169;
    *(_DWORD *)a3 = v6 | 0x20;
    __writegsdword(v118, 9u);
    v178 = -1;
    return;
  }
  if ( !v177 )
  {
    __writegsdword(v169, 0x16u);
    v178 = -1;
    return;
  }
  v170 = *(_DWORD *)a3 & 2;
  if ( (v6 & 2) != 0 )
  {
    v178 = buffered_vfprintf((const struct timespec *)a3, v177, SLODWORD(v175));
    return;
  }
  v178 = v6;
  v180 = LODWORD(v175);
  v174 = strchrnul(v177, 37);
  v179 = v174;
  v176 = v178 & 0x8000;
  if ( (v178 & 0x8000) != 0 )
  {
    v176 = 0;
  }
  else
  {
    v184[1] = a3;
    v184[0] = (int)funlockfile;
    _EDX = *(int **)(a3 + 72);
    v12 = __readgsdword(8u);
    if ( _EDX[2] != v12 )
    {
      _ECX = 1;
      v14 = __readgsdword(0xCu) == 0;
      if ( !v14 )
        __asm { lock }
      __asm { cmpxchg [edx], ecx }
      if ( !v14 )
        _lll_lock_wait_private(0, _EDX, (int)&savedregs, (int *)&GLOBAL_OFFSET_TABLE_);
      _EDX = *(int **)(a3 + 72);
      _EDX[2] = v12;
    }
    ++_EDX[1];
  }
  v7 = *(_DWORD *)(a3 + 148);
  v172 = _start___libc_IO_vtables;
  v173 = (char *)&_start___libc_atexit - (char *)_start___libc_IO_vtables;
  if ( (char *)&_start___libc_atexit - (char *)_start___libc_IO_vtables <= (unsigned int)(v7
                                                                                        - (_DWORD)_start___libc_IO_vtables) )
    IO_vtable_check();
  v178 = (char *)v174 - (char *)v177;
  if ( (char *)v174 - (char *)v177 != (*(int (__cdecl **)(int, unsigned int *, int))(v7 + 28))(
                                        a3,
                                        v177,
                                        (char *)v174 - (char *)v177) )
    goto LABEL_38;
  v8 = v179;
  if ( !*(_BYTE *)v179 )
    goto LABEL_26;
  v152 = (char *)_printf_function_table;
  if ( _printf_function_table )
  {
    v162 = 0;
    v152 = 0;
    v155 = -1;
    goto LABEL_25;
  }
  if ( _printf_modifier_table || _printf_va_arg_table )
  {
    v162 = 0;
    v155 = -1;
    goto LABEL_25;
  }
  v149 = 0;
  v162 = 0;
  v155 = -1;
  v148 = -36;
  while ( 2 )
  {
    v179 = (unsigned int *)((char *)v8 + 1);
    v9 = *((_BYTE *)v8 + 1);
    v10 = jump_table;
    v151 = 0;
    v167 = (int)jump_table;
    v166 = 0;
    v163 = (struct timespec *)v194;
    v153 = 0;
    v161 = 0;
    v158 = 0;
    v165 = 0;
    v154 = 0;
    v159 = 0;
    v164 = 0;
    v157 = 0;
    v156 = 0;
    v171 = 0;
    v160 = 32;
    v170 = -1;
    switch ( v9 )
    {
      case ' ':
LABEL_55:
        while ( 2 )
        {
          v179 = (unsigned int *)((char *)v179 + 1);
          v9 = *(_BYTE *)v179;
          v157 = 1;
          switch ( v9 )
          {
            case ' ':
              continue;
            case '#':
              goto LABEL_52;
            case '%':
              goto LABEL_206;
            case '\'':
              goto LABEL_82;
            case '*':
              goto LABEL_68;
            case '+':
              goto LABEL_54;
            case '-':
              goto LABEL_53;
            case '.':
              goto LABEL_212;
            case '0':
              goto LABEL_85;
            case '1':
            case '2':
            case '3':
            case '4':
            case '5':
            case '6':
            case '7':
            case '8':
            case '9':
              goto LABEL_56;
            case 'A':
            case 'a':
              goto LABEL_199;
            case 'C':
              goto LABEL_88;
            case 'E':
            case 'F':
            case 'G':
            case 'e':
            case 'f':
            case 'g':
              goto LABEL_169;
            case 'I':
              goto LABEL_84;
            case 'L':
            case 'j':
            case 'q':
              goto LABEL_44;
            case 'S':
            case 's':
              goto LABEL_186;
            case 'X':
            case 'x':
              goto LABEL_175;
            case 'Z':
            case 't':
            case 'z':
              goto LABEL_45;
            case 'c':
              goto LABEL_187;
            case 'd':
            case 'i':
              goto LABEL_204;
            case 'h':
              goto LABEL_215;
            case 'l':
              goto LABEL_203;
            case 'm':
              goto LABEL_108;
            case 'n':
              goto LABEL_121;
            case 'o':
              goto LABEL_211;
            case 'p':
              goto LABEL_125;
            case 'u':
              goto LABEL_185;
            default:
              goto LABEL_34;
          }
        }
      case '!':
      case '"':
      case '$':
      case '&':
      case '(':
      case ')':
      case ',':
      case '/':
      case ':':
      case ';':
      case '<':
      case '=':
      case '>':
      case '?':
      case '@':
      case 'B':
      case 'D':
      case 'H':
      case 'J':
      case 'K':
      case 'M':
      case 'N':
      case 'O':
      case 'P':
      case 'Q':
      case 'R':
      case 'T':
      case 'U':
      case 'V':
      case 'W':
      case 'Y':
      case '[':
      case '\\':
      case ']':
      case '^':
      case '_':
      case '`':
      case 'b':
      case 'k':
      case 'r':
      case 'v':
      case 'w':
      case 'y':
        goto LABEL_34;
      case '#':
LABEL_52:
        while ( 2 )
        {
          v179 = (unsigned int *)((char *)v179 + 1);
          v9 = *(_BYTE *)v179;
          v156 = 1;
          switch ( v9 )
          {
            case ' ':
              goto LABEL_55;
            case '#':
              continue;
            case '%':
              goto LABEL_206;
            case '\'':
              goto LABEL_82;
            case '*':
              goto LABEL_68;
            case '+':
              goto LABEL_54;
            case '-':
              goto LABEL_53;
            case '.':
              goto LABEL_212;
            case '0':
              goto LABEL_85;
            case '1':
            case '2':
            case '3':
            case '4':
            case '5':
            case '6':
            case '7':
            case '8':
            case '9':
              goto LABEL_56;
            case 'A':
            case 'a':
              goto LABEL_199;
            case 'C':
              goto LABEL_88;
            case 'E':
            case 'F':
            case 'G':
            case 'e':
            case 'f':
            case 'g':
              goto LABEL_169;
            case 'I':
              goto LABEL_84;
            case 'L':
            case 'j':
            case 'q':
              goto LABEL_44;
            case 'S':
            case 's':
              goto LABEL_186;
            case 'X':
            case 'x':
              goto LABEL_175;
            case 'Z':
            case 't':
            case 'z':
              goto LABEL_45;
            case 'c':
              goto LABEL_187;
            case 'd':
            case 'i':
              goto LABEL_204;
            case 'h':
              goto LABEL_215;
            case 'l':
              goto LABEL_203;
            case 'm':
              goto LABEL_108;
            case 'n':
              goto LABEL_121;
            case 'o':
              goto LABEL_211;
            case 'p':
              goto LABEL_125;
            case 'u':
              goto LABEL_185;
            default:
              goto LABEL_34;
          }
        }
      case '%':
LABEL_206:
        v74 = *(_BYTE **)(a3 + 20);
        if ( (unsigned int)v74 >= *(_DWORD *)(a3 + 24) )
        {
          if ( _overflow(a3, 37) == -1 )
            goto LABEL_36;
        }
        else
        {
          *(_DWORD *)(a3 + 20) = v74 + 1;
          *v74 = 37;
        }
        if ( v178 == 0x7FFFFFFF )
          goto LABEL_36;
        ++v178;
        goto LABEL_99;
      case '\'':
LABEL_82:
        while ( 2 )
        {
          if ( v155 == -1 )
          {
            v111 = *(_DWORD *)__readgsdword(v148);
            v112 = *(_BYTE **)(v111 + 44);
            v113 = *(unsigned int **)(v111 + 40);
            v114 = *v112;
            v152 = (char *)v113;
            if ( !v114 || v114 == 127 )
            {
              v155 = 0;
            }
            else
            {
              v115 = 0;
              if ( *(_BYTE *)v113 )
                v115 = v112;
              v155 = (signed int)v115;
            }
          }
          v179 = (unsigned int *)((char *)v179 + 1);
          v9 = *(_BYTE *)v179;
          v154 = 1;
          switch ( v9 )
          {
            case ' ':
              goto LABEL_55;
            case '#':
              goto LABEL_52;
            case '%':
              goto LABEL_206;
            case '\'':
              continue;
            case '*':
              goto LABEL_68;
            case '+':
              goto LABEL_54;
            case '-':
              goto LABEL_53;
            case '.':
              goto LABEL_212;
            case '0':
              goto LABEL_85;
            case '1':
            case '2':
            case '3':
            case '4':
            case '5':
            case '6':
            case '7':
            case '8':
            case '9':
              goto LABEL_56;
            case 'A':
            case 'a':
              goto LABEL_199;
            case 'C':
              goto LABEL_88;
            case 'E':
            case 'F':
            case 'G':
            case 'e':
            case 'f':
            case 'g':
              goto LABEL_169;
            case 'I':
              goto LABEL_84;
            case 'L':
            case 'j':
            case 'q':
              goto LABEL_44;
            case 'S':
            case 's':
              goto LABEL_186;
            case 'X':
            case 'x':
              goto LABEL_175;
            case 'Z':
            case 't':
            case 'z':
              goto LABEL_45;
            case 'c':
              goto LABEL_187;
            case 'd':
            case 'i':
              goto LABEL_204;
            case 'h':
              goto LABEL_215;
            case 'l':
              goto LABEL_203;
            case 'm':
              goto LABEL_108;
            case 'n':
              goto LABEL_121;
            case 'o':
              goto LABEL_211;
            case 'p':
              goto LABEL_125;
            case 'u':
              goto LABEL_185;
            default:
              goto LABEL_34;
          }
        }
      case '*':
LABEL_68:
        v179 = (unsigned int *)((char *)v179 + 1);
        v185 = (const char *)v179;
        if ( (unsigned int)*(unsigned __int8 *)v179 - 48 > 9 )
          goto LABEL_69;
        v166 = (int)jump_table;
        v16 = read_int(&v185);
        v10 = (char *)v166;
        if ( v16 == -1 )
          goto LABEL_246;
        if ( v16 && *v185 == 36 )
          goto LABEL_50;
LABEL_69:
        v24 = *(_DWORD *)LODWORD(v175);
        LODWORD(v175) += 4;
        v166 = v24;
        if ( v24 < 0 )
        {
          v160 = 32;
          v166 = -v24;
          v164 = 1;
        }
        if ( v166 > 2147483614 )
          goto LABEL_246;
        if ( v166 <= 967 )
          goto LABEL_80;
        v145 = v10;
        v163 = (struct timespec *)(v166 + 32);
        v25 = _libc_alloca_cutoff(v166 + 32);
        v26 = v163;
        v10 = v145;
        if ( (unsigned int)v163 > 0x1000 && !v25 )
        {
          sub_80775BA((int)&savedregs, v163);
          return;
        }
        v163 = (struct timespec *)(((unsigned int)&v163[3].tv_sec + 3) & 0xFFFFFFF0);
        v27 = &v144[-(((unsigned int)&v26[3].tv_sec + 3) & 0xFFFFF000)];
        if ( v144 != v27 )
        {
          while ( v140 != v27 )
            ;
        }
        v28 = ((_WORD)v26 + 27) & 0xFF0;
        if ( (((_WORD)v26 + 27) & 0xFF0) != 0 )
        {
          v29 = alloca(v28);
          *(_DWORD *)&v139[v28] = *(_DWORD *)&v139[v28];
        }
        v163 = (struct timespec *)&v140[(_DWORD)v26];
LABEL_80:
        v9 = *(_BYTE *)v179;
        goto LABEL_81;
      case '+':
LABEL_54:
        while ( 2 )
        {
          v179 = (unsigned int *)((char *)v179 + 1);
          v9 = *(_BYTE *)v179;
          v159 = 1;
          switch ( v9 )
          {
            case ' ':
              goto LABEL_55;
            case '#':
              goto LABEL_52;
            case '%':
              goto LABEL_206;
            case '\'':
              goto LABEL_82;
            case '*':
              goto LABEL_68;
            case '+':
              continue;
            case '-':
              goto LABEL_53;
            case '.':
              goto LABEL_212;
            case '0':
              goto LABEL_85;
            case '1':
            case '2':
            case '3':
            case '4':
            case '5':
            case '6':
            case '7':
            case '8':
            case '9':
              goto LABEL_56;
            case 'A':
            case 'a':
              goto LABEL_199;
            case 'C':
              goto LABEL_88;
            case 'E':
            case 'F':
            case 'G':
            case 'e':
            case 'f':
            case 'g':
              goto LABEL_169;
            case 'I':
              goto LABEL_84;
            case 'L':
            case 'j':
            case 'q':
              goto LABEL_44;
            case 'S':
            case 's':
              goto LABEL_186;
            case 'X':
            case 'x':
              goto LABEL_175;
            case 'Z':
            case 't':
            case 'z':
              goto LABEL_45;
            case 'c':
              goto LABEL_187;
            case 'd':
            case 'i':
              goto LABEL_204;
            case 'h':
              goto LABEL_215;
            case 'l':
              goto LABEL_203;
            case 'm':
              goto LABEL_108;
            case 'n':
              goto LABEL_121;
            case 'o':
              goto LABEL_211;
            case 'p':
              goto LABEL_125;
            case 'u':
              goto LABEL_185;
            default:
              goto LABEL_34;
          }
        }
      case '-':
LABEL_53:
        while ( 2 )
        {
          v179 = (unsigned int *)((char *)v179 + 1);
          v9 = *(_BYTE *)v179;
          v160 = 32;
          v164 = 1;
          switch ( v9 )
          {
            case ' ':
              goto LABEL_55;
            case '#':
              goto LABEL_52;
            case '%':
              goto LABEL_206;
            case '\'':
              goto LABEL_82;
            case '*':
              goto LABEL_68;
            case '+':
              goto LABEL_54;
            case '-':
              continue;
            case '.':
              goto LABEL_212;
            case '0':
              goto LABEL_85;
            case '1':
            case '2':
            case '3':
            case '4':
            case '5':
            case '6':
            case '7':
            case '8':
            case '9':
              goto LABEL_56;
            case 'A':
            case 'a':
              goto LABEL_199;
            case 'C':
              goto LABEL_88;
            case 'E':
            case 'F':
            case 'G':
            case 'e':
            case 'f':
            case 'g':
              goto LABEL_169;
            case 'I':
              goto LABEL_84;
            case 'L':
            case 'j':
            case 'q':
              goto LABEL_44;
            case 'S':
            case 's':
              goto LABEL_186;
            case 'X':
            case 'x':
              goto LABEL_175;
            case 'Z':
            case 't':
            case 'z':
              goto LABEL_45;
            case 'c':
              goto LABEL_187;
            case 'd':
            case 'i':
              goto LABEL_204;
            case 'h':
              goto LABEL_215;
            case 'l':
              goto LABEL_203;
            case 'm':
              goto LABEL_108;
            case 'n':
              goto LABEL_121;
            case 'o':
              goto LABEL_211;
            case 'p':
              goto LABEL_125;
            case 'u':
              goto LABEL_185;
            default:
              goto LABEL_34;
          }
        }
      case '.':
LABEL_212:
        v75 = v179;
        v179 = (unsigned int *)((char *)v179 + 1);
        v9 = *(_BYTE *)v179;
        if ( *(_BYTE *)v179 == 42 )
        {
          v179 = (unsigned int *)((char *)v75 + 2);
          v185 = (char *)v75 + 2;
          if ( (unsigned int)*((unsigned __int8 *)v75 + 2) - 48 > 9 )
            goto LABEL_331;
          v170 = (int)v10;
          v133 = read_int(&v185);
          v10 = (char *)v170;
          if ( v133 == -1 )
          {
LABEL_246:
            __writegsdword(v169, 0x4Bu);
LABEL_36:
            if ( v171 )
              free((int)&savedregs, (int *)&GLOBAL_OFFSET_TABLE_, (int)v171);
LABEL_38:
            v178 = -1;
            goto LABEL_26;
          }
          if ( !v133 || *v185 != 36 )
          {
LABEL_331:
            v103 = -1;
            if ( (int)*(_DWORD *)LODWORD(v175) >= 0 )
              v103 = *(_DWORD *)LODWORD(v175);
            LODWORD(v175) += 4;
            v170 = v103;
            goto LABEL_334;
          }
LABEL_50:
          v170 = v149;
          if ( v171 )
            free((int)&savedregs, (int *)&GLOBAL_OFFSET_TABLE_, (int)v171);
LABEL_25:
          v178 = printf_positional(
                   (int *)a3,
                   v177,
                   v170,
                   SLODWORD(v175),
                   (int)&v180,
                   v178,
                   v162,
                   (unsigned int)v174,
                   v193,
                   v168,
                   v155,
                   v152,
                   (unsigned int *)v141);
          goto LABEL_26;
        }
        v170 = 0;
        if ( (unsigned int)(unsigned __int8)v9 - 48 > 9 )
          goto LABEL_214;
        v145 = v10;
        v122 = read_int(&v179);
        v10 = v145;
        v170 = v122;
        if ( v122 == -1 )
          goto LABEL_246;
LABEL_334:
        v104 = 968;
        if ( v166 >= 968 )
          v104 = v166;
        if ( v170 <= v104 )
          goto LABEL_423;
        if ( v171 )
        {
          v163 = (struct timespec *)v10;
          free((int)&savedregs, (int *)&GLOBAL_OFFSET_TABLE_, (int)v171);
          v10 = (char *)v163;
        }
        if ( v170 <= 2147483614 )
        {
          v163 = (struct timespec *)v10;
          v171 = (const struct timespec *)(v170 + 32);
          v105 = _libc_alloca_cutoff(v170 + 32);
          v106 = v171;
          if ( (unsigned int)v171 <= 0x1000 || v105 )
          {
            v171 = (const struct timespec *)(((unsigned int)&v171[3].tv_sec + 3) & 0xFFFFFFF0);
            v107 = &v140[-(((unsigned int)&v106[3].tv_sec + 3) & 0xFFFFF000)];
            if ( v140 != v107 )
            {
              while ( v137 != v107 )
                ;
            }
            v108 = ((_WORD)v106 + 27) & 0xFF0;
            if ( (((_WORD)v106 + 27) & 0xFF0) != 0 )
            {
              v109 = alloca(v108);
              *(_DWORD *)&v137[v108 - 4] = *(_DWORD *)&v137[v108 - 4];
            }
            v171 = 0;
            v163 = (struct timespec *)&v137[(_DWORD)v106];
            v9 = *(_BYTE *)v179;
LABEL_214:
            v23 = (void *)v9;
            switch ( v9 )
            {
              case ' ':
              case '!':
              case '"':
              case '#':
              case '$':
              case '&':
              case '\'':
              case '(':
              case ')':
              case '*':
              case '+':
              case ',':
              case '-':
              case '.':
              case '/':
              case '0':
              case '1':
              case '2':
              case '3':
              case '4':
              case '5':
              case '6':
              case '7':
              case '8':
              case '9':
              case ':':
              case ';':
              case '<':
              case '=':
              case '>':
              case '?':
              case '@':
              case 'B':
              case 'D':
              case 'H':
              case 'I':
              case 'J':
              case 'K':
              case 'M':
              case 'N':
              case 'O':
              case 'P':
              case 'Q':
              case 'R':
              case 'T':
              case 'U':
              case 'V':
              case 'W':
              case 'Y':
              case '[':
              case '\\':
              case ']':
              case '^':
              case '_':
              case '`':
              case 'b':
              case 'k':
              case 'r':
              case 'v':
              case 'w':
              case 'y':
                goto LABEL_34;
              case '%':
                goto LABEL_206;
              case 'A':
              case 'a':
                goto LABEL_199;
              case 'C':
                goto LABEL_88;
              case 'E':
              case 'F':
              case 'G':
              case 'e':
              case 'f':
              case 'g':
                goto LABEL_169;
              case 'L':
              case 'j':
              case 'q':
                goto LABEL_44;
              case 'S':
              case 's':
                goto LABEL_186;
              case 'X':
              case 'x':
                goto LABEL_175;
              case 'Z':
              case 't':
              case 'z':
                goto LABEL_45;
              case 'c':
                goto LABEL_187;
              case 'd':
              case 'i':
                goto LABEL_204;
              case 'h':
                goto LABEL_215;
              case 'l':
                goto LABEL_203;
              case 'm':
                goto LABEL_108;
              case 'n':
                goto LABEL_121;
              case 'o':
                goto LABEL_211;
              case 'p':
                goto LABEL_125;
              case 'u':
                goto LABEL_185;
              default:
                goto LABEL_67;
            }
          }
          v145 = (char *)v163;
          v163 = (struct timespec *)v171;
          v171 = (const struct timespec *)malloc(v171);
          if ( !v171 )
            goto LABEL_38;
          v163 = (struct timespec *)((char *)v163 + (_DWORD)v171);
LABEL_423:
          v9 = *(_BYTE *)v179;
          goto LABEL_214;
        }
LABEL_288:
        __writegsdword(v169, 0x4Bu);
        v178 = -1;
LABEL_26:
        if ( (*(_DWORD *)a3 & 0x8000) == 0 )
        {
          v15 = *(int **)(a3 + 72);
          v14 = v15[1]-- == 1;
          if ( v14 )
          {
            v15[2] = 0;
            if ( __readgsdword(0xCu) )
              __asm { lock }
            v14 = (*v15)-- == 1;
            if ( !v14 )
              _lll_unlock_wake_private(v15, (int)&savedregs, (int *)&GLOBAL_OFFSET_TABLE_, (const struct timespec *)a3);
          }
        }
        if ( v176 )
          MEMORY[0](v184, 0);
        return;
      case '0':
LABEL_85:
        while ( 2 )
        {
          v30 = v160;
          if ( !v164 )
            v30 = 48;
          v160 = v30;
          v179 = (unsigned int *)((char *)v179 + 1);
          v9 = *(_BYTE *)v179;
          v23 = (void *)*(char *)v179;
          switch ( *(_BYTE *)v179 )
          {
            case ' ':
              goto LABEL_55;
            case '!':
            case '"':
            case '$':
            case '&':
            case '(':
            case ')':
            case ',':
            case '/':
            case ':':
            case ';':
            case '<':
            case '=':
            case '>':
            case '?':
            case '@':
            case 'B':
            case 'D':
            case 'H':
            case 'J':
            case 'K':
            case 'M':
            case 'N':
            case 'O':
            case 'P':
            case 'Q':
            case 'R':
            case 'T':
            case 'U':
            case 'V':
            case 'W':
            case 'Y':
            case '[':
            case '\\':
            case ']':
            case '^':
            case '_':
            case '`':
            case 'b':
            case 'k':
            case 'r':
            case 'v':
            case 'w':
            case 'y':
              goto LABEL_34;
            case '#':
              goto LABEL_52;
            case '%':
              goto LABEL_206;
            case '\'':
              goto LABEL_82;
            case '*':
              goto LABEL_68;
            case '+':
              goto LABEL_54;
            case '-':
              goto LABEL_53;
            case '.':
              goto LABEL_212;
            case '0':
              continue;
            case '1':
            case '2':
            case '3':
            case '4':
            case '5':
            case '6':
            case '7':
            case '8':
            case '9':
              goto LABEL_56;
            case 'A':
            case 'a':
              goto LABEL_199;
            case 'C':
              goto LABEL_88;
            case 'E':
            case 'F':
            case 'G':
            case 'e':
            case 'f':
            case 'g':
              goto LABEL_169;
            case 'I':
              goto LABEL_84;
            case 'L':
            case 'j':
            case 'q':
              goto LABEL_44;
            case 'S':
            case 's':
              goto LABEL_186;
            case 'X':
            case 'x':
              goto LABEL_175;
            case 'Z':
            case 't':
            case 'z':
              goto LABEL_45;
            case 'c':
              goto LABEL_187;
            case 'd':
            case 'i':
              goto LABEL_204;
            case 'h':
              goto LABEL_215;
            case 'l':
              goto LABEL_203;
            case 'm':
              goto LABEL_108;
            case 'n':
              goto LABEL_121;
            case 'o':
              goto LABEL_211;
            case 'p':
              goto LABEL_125;
            case 'u':
              goto LABEL_185;
            default:
              goto LABEL_67;
          }
        }
      case '1':
      case '2':
      case '3':
      case '4':
      case '5':
      case '6':
      case '7':
      case '8':
      case '9':
LABEL_56:
        v145 = jump_table;
        v17 = read_int(&v179);
        v10 = v145;
        v166 = v17;
        if ( v17 > 0x7FFFFFDE )
          goto LABEL_246;
        if ( v166 <= 967 )
          goto LABEL_65;
        v163 = (struct timespec *)(v166 + 32);
        v18 = _libc_alloca_cutoff(v166 + 32);
        v19 = v163;
        v10 = v145;
        if ( (unsigned int)v163 <= 0x1000 || v18 )
        {
          v163 = (struct timespec *)(((unsigned int)&v163[3].tv_sec + 3) & 0xFFFFFFF0);
          v20 = &v144[-(((unsigned int)&v19[3].tv_sec + 3) & 0xFFFFF000)];
          if ( v144 != v20 )
          {
            while ( v140 != v20 )
              ;
          }
          v21 = ((_WORD)v19 + 27) & 0xFF0;
          if ( (((_WORD)v19 + 27) & 0xFF0) != 0 )
          {
            v22 = alloca(v21);
            *(_DWORD *)&v139[v21] = *(_DWORD *)&v139[v21];
          }
          v163 = (struct timespec *)&v140[(_DWORD)v19];
        }
        else
        {
          v136 = (const struct timespec *)malloc(v163);
          v10 = v145;
          v171 = v136;
          if ( !v136 )
            goto LABEL_38;
          v163 = (struct timespec *)((char *)v163 + (_DWORD)v171);
        }
LABEL_65:
        v9 = *(_BYTE *)v179;
        if ( *(_BYTE *)v179 != 36 )
        {
          v23 = &def_8075167;
          if ( (unsigned __int8)(v9 - 32) > 0x5Au )
LABEL_67:
            __asm { jmp     eax; jumptable 080756B4 default case }
LABEL_81:
          switch ( v9 )
          {
            case 5:
              goto LABEL_206;
            case 14:
              goto LABEL_212;
            case 33:
            case 65:
              goto LABEL_199;
            case 35:
              goto LABEL_88;
            case 37:
            case 38:
            case 39:
            case 69:
            case 70:
            case 71:
              goto LABEL_169;
            case 44:
            case 74:
            case 81:
              goto LABEL_44;
            case 51:
            case 83:
              goto LABEL_186;
            case 56:
            case 88:
              goto LABEL_175;
            case 58:
            case 84:
            case 90:
              goto LABEL_45;
            case 67:
              goto LABEL_187;
            case 68:
            case 73:
              goto LABEL_204;
            case 72:
              goto LABEL_215;
            case 76:
              goto LABEL_203;
            case 77:
              goto LABEL_108;
            case 78:
              goto LABEL_121;
            case 79:
              goto LABEL_211;
            case 80:
              goto LABEL_125;
            case 85:
              goto LABEL_185;
            default:
              goto LABEL_34;
          }
        }
        goto LABEL_50;
      case 'A':
      case 'a':
LABEL_199:
        v187 = v9;
        v185 = (const char *)v170;
        v186 = v166;
        v188 = (unsigned __int8)(((_BYTE)v154 << 7) | ((_BYTE)v159 << 6) | (32 * v164) & 0x3F | (16 * v157) & 0x3F | ((8 * v156) | v165 | (4 * v161) | (2 * v158)) & 0xF);
        v189 = v160;
        if ( v165 )
        {
          v71 = LODWORD(v175) + 12;
          v72 = *(long double *)LODWORD(v175);
          v175 = v72;
          LODWORD(v175) = v71;
          *(long double *)&v183 = v72;
        }
        else
        {
          v96 = *(_QWORD *)LODWORD(v175);
          DWORD1(v175) = *(_DWORD *)(LODWORD(v175) + 4);
          *(_QWORD *)&v183.value = v96;
          LODWORD(v175) += 8;
        }
        v182 = &v183;
        v64 = _printf_fphex(
                v165,
                (int)&savedregs,
                (int)&GLOBAL_OFFSET_TABLE_,
                a3,
                (int *)a3,
                (int)&v185,
                (const __m128i **)&v182);
        if ( v64 < 0 )
          goto LABEL_36;
        goto LABEL_172;
      case 'C':
        goto LABEL_88;
      case 'E':
      case 'F':
      case 'G':
      case 'e':
      case 'f':
      case 'g':
LABEL_169:
        v187 = v9;
        v185 = (const char *)v170;
        v186 = v166;
        v188 = (unsigned __int8)(((_BYTE)v154 << 7) | ((_BYTE)v159 << 6) | (32 * v164) & 0x3F | (16 * v157) & 0x3F | ((8 * v156) | v165 | (4 * v161) | (2 * v158)) & 0xF);
        BYTE1(v188) = 8 * v151;
        v189 = v160;
        if ( v165 )
        {
          v62 = LODWORD(v175) + 12;
          v63 = *(long double *)LODWORD(v175);
          v175 = v63;
          LODWORD(v175) = v62;
          *(long double *)&v183 = v63;
        }
        else
        {
          v93 = *(_QWORD *)LODWORD(v175);
          DWORD1(v175) = *(_DWORD *)(LODWORD(v175) + 4);
          *(_QWORD *)&v183.value = v93;
          LODWORD(v175) += 8;
        }
        v181 = &v183;
        v64 = _printf_fp(
                v165,
                (int)&savedregs,
                (unsigned int)&GLOBAL_OFFSET_TABLE_,
                a3,
                (_DWORD *)a3,
                (int)&v185,
                (const __m128i **)&v181);
        if ( v64 < 0 )
          goto LABEL_36;
LABEL_172:
        if ( v178 > 0x7FFFFFFE )
          goto LABEL_440;
        if ( 0x7FFFFFFF - v178 < v64 )
          goto LABEL_246;
        v178 += v64;
        goto LABEL_99;
      case 'I':
LABEL_84:
        while ( 2 )
        {
          v179 = (unsigned int *)((char *)v179 + 1);
          v9 = *(_BYTE *)v179;
          v151 = 1;
          switch ( v9 )
          {
            case ' ':
              goto LABEL_55;
            case '#':
              goto LABEL_52;
            case '%':
              goto LABEL_206;
            case '\'':
              goto LABEL_82;
            case '*':
              goto LABEL_68;
            case '+':
              goto LABEL_54;
            case '-':
              goto LABEL_53;
            case '.':
              goto LABEL_212;
            case '0':
              goto LABEL_85;
            case '1':
            case '2':
            case '3':
            case '4':
            case '5':
            case '6':
            case '7':
            case '8':
            case '9':
              goto LABEL_56;
            case 'A':
            case 'a':
              goto LABEL_199;
            case 'C':
              goto LABEL_88;
            case 'E':
            case 'F':
            case 'G':
            case 'e':
            case 'f':
            case 'g':
              goto LABEL_169;
            case 'I':
              continue;
            case 'L':
            case 'j':
            case 'q':
              goto LABEL_44;
            case 'S':
            case 's':
              goto LABEL_186;
            case 'X':
            case 'x':
              goto LABEL_175;
            case 'Z':
            case 't':
            case 'z':
              goto LABEL_45;
            case 'c':
              goto LABEL_187;
            case 'd':
            case 'i':
              goto LABEL_204;
            case 'h':
              goto LABEL_215;
            case 'l':
              goto LABEL_203;
            case 'm':
              goto LABEL_108;
            case 'n':
              goto LABEL_121;
            case 'o':
              goto LABEL_211;
            case 'p':
              goto LABEL_125;
            case 'u':
              goto LABEL_185;
            default:
              goto LABEL_34;
          }
        }
      case 'L':
      case 'j':
      case 'q':
LABEL_44:
        v179 = (unsigned int *)((char *)v179 + 1);
        v9 = *(_BYTE *)v179;
        v161 = 1;
        v165 = 1;
        switch ( v9 )
        {
          case '%':
            goto LABEL_206;
          case 'A':
          case 'a':
            goto LABEL_199;
          case 'C':
            goto LABEL_88;
          case 'E':
          case 'F':
          case 'G':
          case 'e':
          case 'f':
          case 'g':
            goto LABEL_169;
          case 'S':
          case 's':
            goto LABEL_186;
          case 'X':
          case 'x':
            goto LABEL_175;
          case 'c':
            goto LABEL_187;
          case 'd':
          case 'i':
            goto LABEL_204;
          case 'm':
            goto LABEL_108;
          case 'n':
            goto LABEL_121;
          case 'o':
            goto LABEL_211;
          case 'p':
            goto LABEL_125;
          case 'u':
            goto LABEL_185;
          default:
            goto LABEL_34;
        }
      case 'S':
      case 's':
LABEL_186:
        v41 = *(unsigned int **)LODWORD(v175);
        LODWORD(v175) += 4;
        goto LABEL_109;
      case 'X':
      case 'x':
LABEL_175:
        v161 = 16;
        v65 = (unsigned __int8 *)LODWORD(v175);
        goto LABEL_176;
      case 'Z':
      case 't':
      case 'z':
LABEL_45:
        v179 = (unsigned int *)((char *)v179 + 1);
        v9 = *(_BYTE *)v179;
        v161 = 0;
        v165 = 0;
        switch ( v9 )
        {
          case '%':
            goto LABEL_206;
          case 'A':
          case 'a':
            goto LABEL_199;
          case 'C':
            goto LABEL_88;
          case 'E':
          case 'F':
          case 'G':
          case 'e':
          case 'f':
          case 'g':
            goto LABEL_169;
          case 'S':
          case 's':
            goto LABEL_186;
          case 'X':
          case 'x':
            goto LABEL_175;
          case 'c':
            goto LABEL_187;
          case 'd':
          case 'i':
            goto LABEL_204;
          case 'm':
            goto LABEL_108;
          case 'n':
            goto LABEL_121;
          case 'o':
            goto LABEL_211;
          case 'p':
            goto LABEL_125;
          case 'u':
            goto LABEL_185;
          default:
            goto LABEL_34;
        }
      case 'c':
LABEL_187:
        if ( v161 )
        {
LABEL_88:
          v142 = (int)&v190;
          v141 = *(_DWORD *)LODWORD(v175);
          v190 = 0;
          v191 = 0;
          v165 = LODWORD(v175) + 4;
          v170 = (int)v192;
          v31 = wcrtomb(v192, v141, &v190);
          v32 = v31;
          if ( v31 == -1 )
            goto LABEL_36;
          v167 = v166 - v31;
          LOBYTE(v175) = v166 - v31 > 0;
          v33 = v170;
          if ( !v164 && LOBYTE(v175) )
          {
            v119 = IO_padn(a3, 32, v167);
            if ( v167 != v119 )
              goto LABEL_36;
            if ( v178 > 0x7FFFFFFE )
              goto LABEL_444;
            v33 = v170;
            if ( 0x7FFFFFFF - v178 < v167 )
              goto LABEL_246;
            v178 += v167;
          }
          if ( (v178 & 0x80000000) != 0 )
            goto LABEL_445;
          v34 = *(_DWORD *)(a3 + 148);
          if ( v173 <= v34 - (int)v172 )
          {
            v166 = v33;
            v170 = v34;
            IO_vtable_check();
            v33 = v166;
            v34 = v170;
          }
          if ( v32 != (*(int (__cdecl **)(int, int, unsigned int))(v34 + 28))(a3, v33, v32) )
            goto LABEL_36;
          if ( 0x7FFFFFFF - v178 < v32 )
            goto LABEL_246;
          v178 += v32;
          if ( v164 && LOBYTE(v175) )
          {
            v121 = v167;
            LODWORD(v175) = 0x7FFFFFFF;
            if ( v121 != IO_padn(a3, 32, v167) )
              goto LABEL_36;
            if ( v178 > 0x7FFFFFFE )
              goto LABEL_444;
            if ( LODWORD(v175) - v178 < v121 )
              goto LABEL_246;
            v178 += v167;
          }
          LODWORD(v175) = v165;
        }
        else
        {
          v68 = v166 - 1;
          LOBYTE(v170) = v166 - 1 > 0;
          if ( !v164 && v166 - 1 > 0 )
          {
            if ( v68 != IO_padn(a3, 32, v166 - 1) )
              goto LABEL_36;
            if ( v178 > 0x7FFFFFFE )
            {
LABEL_444:
              v143 = &_PRETTY_FUNCTION___13500;
              v142 = 1638;
LABEL_441:
              _assert_fail((int)"(unsigned int) done < (unsigned int) INT_MAX", (int)"vfprintf.c", v142, (int)v143);
            }
            if ( 0x7FFFFFFF - v178 < v68 )
              goto LABEL_246;
            v178 += v68;
          }
          v69 = *(_DWORD *)LODWORD(v175);
          v70 = *(_BYTE **)(a3 + 20);
          LODWORD(v175) += 4;
          if ( (unsigned int)v70 >= *(_DWORD *)(a3 + 24) )
          {
            if ( _overflow(a3, (unsigned __int8)v69) == -1 )
              goto LABEL_36;
          }
          else
          {
            *(_DWORD *)(a3 + 20) = v70 + 1;
            *v70 = v69;
          }
          if ( v178 == 0x7FFFFFFF )
            goto LABEL_36;
          ++v178;
          if ( v164 && (_BYTE)v170 )
          {
            if ( v68 != IO_padn(a3, 32, v68) )
              goto LABEL_36;
            if ( v178 > 0x7FFFFFFE )
              goto LABEL_444;
            if ( 0x7FFFFFFF - v178 < v68 )
              goto LABEL_246;
            goto LABEL_198;
          }
        }
        goto LABEL_99;
      case 'd':
      case 'i':
LABEL_204:
        if ( v165 )
        {
          v161 = 10;
          v73 = *(_DWORD *)(LODWORD(v175) + 4);
          v165 = (unsigned int)v73 >> 31;
          v146 = v73 >> 31;
          v147 = v146;
          LODWORD(v150) = *(_DWORD *)LODWORD(v175) ^ v146;
          HIDWORD(v150) = v146 ^ v73;
          v150 -= __PAIR64__(v146, v146);
          LODWORD(v175) += 8;
          goto LABEL_178;
        }
        if ( v153 )
        {
          v94 = (char)*(_BYTE *)LODWORD(v175);
          LODWORD(v175) += 4;
        }
        else
        {
          if ( v158 )
            v94 = (__int16)*(_WORD *)LODWORD(v175);
          else
            v94 = *(_DWORD *)LODWORD(v175);
          LODWORD(v175) += 4;
        }
        v161 = 10;
        v95 = v94;
        v49 = abs32(v94);
        v165 = v95 >> 31;
        v153 = v49;
        goto LABEL_127;
      case 'h':
LABEL_215:
        v179 = (unsigned int *)((char *)v179 + 1);
        v9 = *(_BYTE *)v179;
        v158 = 1;
        switch ( v9 )
        {
          case '%':
            goto LABEL_206;
          case 'X':
          case 'x':
            goto LABEL_175;
          case 'd':
          case 'i':
            goto LABEL_204;
          case 'h':
            v179 = (unsigned int *)((char *)v179 + 1);
            v9 = *(_BYTE *)v179;
            v158 = 0;
            v153 = 1;
            switch ( v9 )
            {
              case '%':
                goto LABEL_206;
              case 'A':
              case 'a':
                goto LABEL_199;
              case 'C':
                goto LABEL_88;
              case 'E':
              case 'F':
              case 'G':
              case 'e':
              case 'f':
              case 'g':
                goto LABEL_169;
              case 'S':
              case 's':
                goto LABEL_186;
              case 'X':
              case 'x':
                goto LABEL_175;
              case 'c':
                goto LABEL_187;
              case 'd':
              case 'i':
                goto LABEL_204;
              case 'm':
                goto LABEL_108;
              case 'n':
                goto LABEL_121;
              case 'o':
                goto LABEL_211;
              case 'p':
                goto LABEL_125;
              case 'u':
                goto LABEL_185;
              default:
                goto LABEL_34;
            }
          case 'n':
            goto LABEL_121;
          case 'o':
            goto LABEL_211;
          case 'u':
            goto LABEL_185;
          default:
            goto LABEL_34;
        }
      case 'l':
LABEL_203:
        v179 = (unsigned int *)((char *)v179 + 1);
        v9 = *(_BYTE *)v179;
        v161 = 1;
        switch ( v9 )
        {
          case '%':
            goto LABEL_206;
          case 'A':
          case 'a':
            goto LABEL_199;
          case 'C':
            goto LABEL_88;
          case 'E':
          case 'F':
          case 'G':
          case 'e':
          case 'f':
          case 'g':
            goto LABEL_169;
          case 'S':
          case 's':
            goto LABEL_186;
          case 'X':
          case 'x':
            goto LABEL_175;
          case 'c':
            goto LABEL_187;
          case 'd':
          case 'i':
            goto LABEL_204;
          case 'l':
            goto LABEL_44;
          case 'm':
            goto LABEL_108;
          case 'n':
            goto LABEL_121;
          case 'o':
            goto LABEL_211;
          case 'p':
            goto LABEL_125;
          case 'u':
            goto LABEL_185;
          default:
            goto LABEL_34;
        }
      case 'm':
LABEL_108:
        v40 = strerror_r((signed int)v168, v193, 0x3E8u);
        v161 = 0;
        v41 = (unsigned int *)v40;
LABEL_109:
        if ( v41 )
        {
          if ( v161 || v9 == 83 )
          {
            v185 = (const char *)v41;
            v165 = (int)&v190;
            v190 = 0;
            v191 = 0;
            if ( v170 >= 0 )
              goto LABEL_319;
            v170 = (int)v41;
            v163 = (struct timespec *)&v185;
            v124 = wcsrtombs(0, (int *)&v185, 0, (int *)v165);
            if ( v124 == -1 )
              goto LABEL_36;
            v167 = v190;
            if ( v190 )
              _assert_fail((int)"__mbsinit (&mbstate)", (int)"vfprintf.c", 1638, (int)&_PRETTY_FUNCTION___13500);
            v161 = v124;
            v125 = (const struct timespec *)(v124 + 1);
            v185 = (const char *)v170;
            v170 = v124 + 1;
            v126 = _libc_alloca_cutoff(v124 + 1);
            v127 = v161;
            if ( v126 || (unsigned int)v125 <= 0x1000 )
            {
              v128 = &v144[-((v170 + 27) & 0xFFFFF000)];
              if ( v144 != v128 )
              {
                while ( v140 != v128 )
                  ;
              }
              v129 = ((_WORD)v170 + 27) & 0xFF0;
              if ( (((_WORD)v170 + 27) & 0xFF0) != 0 )
              {
                v130 = alloca(v129);
                *(_DWORD *)&v139[v129] = *(_DWORD *)&v139[v129];
              }
              v131 = (int *)v140;
            }
            else
            {
              v131 = malloc(v125);
              if ( !v131 )
                goto LABEL_36;
              v167 = 1;
              v127 = v161;
            }
            v138 = v170;
            v161 = v127;
            v170 = (int)v131;
            wcsrtombs((int)v131, &v163->tv_sec, v138, (int *)v165);
            p_tv_sec = (int *)v170;
            v44 = v161;
          }
          else
          {
            if ( v170 != -1 )
              goto LABEL_113;
            v170 = (int)v41;
            v102 = strlen(v41);
            p_tv_sec = (int *)v170;
            v167 = 0;
            v44 = v102;
          }
        }
        else
        {
          v167 = 0;
          if ( v170 != -1 && v170 <= 5 )
          {
            p_tv_sec = (int *)byte_80B41F9;
            v44 = 0;
            goto LABEL_260;
          }
          v44 = 6;
          p_tv_sec = (int *)"(null)";
        }
        goto LABEL_114;
      case 'n':
LABEL_121:
        if ( (*(_BYTE *)(a3 + 60) & 4) != 0 && !v149 )
        {
          v123 = strlen(v177);
          v149 = _readonly_area((unsigned int)v177, v123 + 1);
          if ( v149 < 0 )
            _libc_fatal((unsigned __int8)&aNInWritableSeg[-135061504] + (unsigned __int8)&GLOBAL_OFFSET_TABLE_);
        }
        v47 = LODWORD(v175);
        v48 = *(_QWORD **)LODWORD(v175);
        if ( v165 )
        {
          *v48 = (int)v178;
          LODWORD(v175) = v47 + 4;
        }
        else if ( v153 )
        {
          *(_BYTE *)v48 = v178;
          LODWORD(v175) = v47 + 4;
        }
        else
        {
          if ( v158 )
            *(_WORD *)v48 = v178;
          else
            *(_DWORD *)v48 = v178;
          LODWORD(v175) = v47 + 4;
        }
        goto LABEL_99;
      case 'o':
LABEL_211:
        v161 = 8;
        v65 = (unsigned __int8 *)LODWORD(v175);
        goto LABEL_176;
      case 'p':
LABEL_125:
        v49 = *(_DWORD *)LODWORD(v175);
        if ( *(_DWORD *)LODWORD(v175) )
        {
          v153 = *(_DWORD *)LODWORD(v175);
          v9 = 120;
          LODWORD(v175) += 4;
          v154 = 0;
          v165 = 0;
          v156 = 1;
          v161 = 16;
LABEL_127:
          if ( v170 < 0 )
          {
            v170 = 1;
          }
          else
          {
            if ( !v170 && !v49 )
            {
              if ( v161 == 8 && v156 )
              {
                v167 = 1;
                v160 = 32;
                v50 = (char *)&v163[-1].tv_nsec + 3;
                *v50 = 48;
                v158 = (int)v50;
                v156 = 1;
              }
              else
              {
                v160 = 32;
                v167 = 0;
                v158 = (int)v163;
              }
              goto LABEL_133;
            }
            v160 = 32;
          }
          v82 = (_BYTE *)itoa_word(v49, (int)v163, v161, v9 == 88);
          v158 = (int)v82;
          if ( v155 && v154 )
            v158 = (int)group_number(v193, v82, v163, (_BYTE *)v155, (unsigned int *)v152);
          if ( v161 == 10 && v151 )
          {
            v83 = i18n_number_rewrite((_BYTE *)v158, (int)v163, v163);
            v161 = 10;
            v158 = (int)v83;
            v167 = (char *)v163 - v83;
          }
          else
          {
            v167 = (int)v163 - v158;
          }
LABEL_133:
          if ( v170 > v167 )
          {
            v76 = v170;
            v170 -= v167;
            if ( !v164 )
            {
              v55 = v166 - v76;
              if ( v153 )
              {
                LOBYTE(v154) = v156 & 1;
LABEL_142:
                if ( v161 == 16 && (_BYTE)v154 )
                  v55 -= 2;
              }
LABEL_145:
              if ( v165 | v159 | v157 )
              {
                --v55;
                if ( v160 != 32 )
                  goto LABEL_147;
                if ( v55 <= 0 )
                {
                  v55 = 0;
                  goto LABEL_147;
                }
LABEL_276:
                v166 = v55;
                v88 = IO_padn(a3, 32, v55);
                if ( v88 != v166 )
                  goto LABEL_36;
                if ( v178 > 0x7FFFFFFE )
                  goto LABEL_440;
                if ( 0x7FFFFFFF - v178 < v166 )
                  goto LABEL_246;
                v178 += v166;
                v55 = 0;
LABEL_147:
                if ( v165 )
                {
                  v56 = *(_BYTE **)(a3 + 20);
                  if ( (unsigned int)v56 < *(_DWORD *)(a3 + 24) )
                  {
                    *(_DWORD *)(a3 + 20) = v56 + 1;
                    *v56 = 45;
                    goto LABEL_150;
                  }
                  v166 = v55;
                  v141 = 45;
LABEL_410:
                  v132 = _overflow(a3, v141);
                  v55 = v166;
                  if ( v132 == -1 )
                    goto LABEL_36;
                  goto LABEL_150;
                }
                if ( v159 )
                {
                  v91 = *(_BYTE **)(a3 + 20);
                  if ( (unsigned int)v91 >= *(_DWORD *)(a3 + 24) )
                  {
                    v166 = v55;
                    v141 = 43;
                    goto LABEL_410;
                  }
                  *(_DWORD *)(a3 + 20) = v91 + 1;
                  *v91 = 43;
LABEL_150:
                  if ( v178 == 0x7FFFFFFF )
                    goto LABEL_36;
                  ++v178;
                }
                else if ( v157 )
                {
                  v116 = *(_BYTE **)(a3 + 20);
                  if ( (unsigned int)v116 >= *(_DWORD *)(a3 + 24) )
                  {
                    v166 = v55;
                    v141 = 32;
                    goto LABEL_410;
                  }
                  *(_DWORD *)(a3 + 20) = v116 + 1;
                  *v116 = 32;
                  goto LABEL_150;
                }
              }
              else if ( v160 == 32 )
              {
                if ( v55 > 0 )
                  goto LABEL_276;
                v55 = 0;
              }
              if ( v153 && v161 == 16 && v156 )
              {
                v57 = *(_BYTE **)(a3 + 20);
                if ( (unsigned int)v57 >= *(_DWORD *)(a3 + 24) )
                {
                  v166 = v55;
                  v135 = _overflow(a3, 48);
                  v55 = v166;
                  if ( v135 == -1 )
                    goto LABEL_36;
                }
                else
                {
                  *(_DWORD *)(a3 + 20) = v57 + 1;
                  *v57 = 48;
                }
                if ( v178 == 0x7FFFFFFF )
                  goto LABEL_36;
                v58 = *(char **)(a3 + 20);
                if ( (unsigned int)v58 >= *(_DWORD *)(a3 + 24) )
                {
                  v166 = v55;
                  v134 = _overflow(a3, (unsigned __int8)v9);
                  v55 = v166;
                  if ( v134 == -1 )
                    goto LABEL_36;
                }
                else
                {
                  *(_DWORD *)(a3 + 20) = v58 + 1;
                  *v58 = v9;
                }
                if ( v178 == 2147483646 )
                  goto LABEL_36;
                v178 += 2;
              }
              v59 = v55 + v170;
              if ( v55 + v170 > 0 )
              {
                if ( v59 != IO_padn(a3, 48, v55 + v170) )
                  goto LABEL_36;
                if ( v178 > 0x7FFFFFFE )
                {
LABEL_440:
                  v143 = &_PRETTY_FUNCTION___13500;
                  v142 = 1637;
                  goto LABEL_441;
                }
                if ( 0x7FFFFFFF - v178 < v59 )
                  goto LABEL_246;
                v178 += v59;
              }
              if ( (v178 & 0x80000000) != 0 )
                goto LABEL_442;
              v60 = *(_DWORD *)(a3 + 148);
              if ( v173 <= v60 - (int)v172 )
                IO_vtable_check();
              v61 = (*(int (__cdecl **)(int, int, int))(v60 + 28))(a3, v158, v167);
              if ( v167 != v61 )
                goto LABEL_36;
              if ( (int)(0x7FFFFFFF - v178) < v167 )
                goto LABEL_246;
              v178 += v167;
              goto LABEL_99;
            }
            v163 = (struct timespec *)v170;
          }
          else if ( v153 )
          {
            LOBYTE(v154) = v156 & 1;
            if ( v161 == 8 && (v156 & 1) != 0 )
            {
              v51 = (_BYTE *)(v158 - 1);
              *v51 = 48;
              v158 = (int)v51;
              v167 = (char *)v163 - v51;
            }
            v52 = v170 - v167 < 0;
            v53 = (int *)(v170 - v167);
            v170 -= v167;
            v54 = 0;
            if ( !v52 )
              v54 = v53;
            v163 = (struct timespec *)v54;
            if ( !v164 )
            {
              v170 = (int)v163;
              v55 = v166 - ((_DWORD)v163 + v167);
              goto LABEL_142;
            }
          }
          else
          {
            v170 -= v167;
            if ( !v164 )
            {
              v170 = 0;
              v55 = v166 - v167;
              goto LABEL_145;
            }
            v163 = 0;
          }
          if ( v165 )
          {
            v77 = *(_BYTE **)(a3 + 20);
            if ( (unsigned int)v77 < *(_DWORD *)(a3 + 24) )
            {
              *(_DWORD *)(a3 + 20) = v77 + 1;
              *v77 = 45;
              goto LABEL_224;
            }
            v141 = 45;
LABEL_407:
            if ( _overflow(a3, v141) == -1 )
              goto LABEL_36;
            goto LABEL_224;
          }
          if ( v159 )
          {
            v87 = *(_BYTE **)(a3 + 20);
            if ( (unsigned int)v87 >= *(_DWORD *)(a3 + 24) )
            {
              v141 = 43;
              goto LABEL_407;
            }
            *(_DWORD *)(a3 + 20) = v87 + 1;
            *v87 = 43;
LABEL_224:
            if ( v178 == 0x7FFFFFFF )
              goto LABEL_36;
            --v166;
            ++v178;
          }
          else if ( v157 )
          {
            v92 = *(_BYTE **)(a3 + 20);
            if ( (unsigned int)v92 >= *(_DWORD *)(a3 + 24) )
            {
              v141 = 32;
              goto LABEL_407;
            }
            *(_DWORD *)(a3 + 20) = v92 + 1;
            *v92 = 32;
            goto LABEL_224;
          }
          if ( v153 && v161 == 16 && v156 )
          {
            v78 = *(_BYTE **)(a3 + 20);
            if ( (unsigned int)v78 >= *(_DWORD *)(a3 + 24) )
            {
              if ( _overflow(a3, 48) == -1 )
                goto LABEL_36;
            }
            else
            {
              *(_DWORD *)(a3 + 20) = v78 + 1;
              *v78 = 48;
            }
            if ( v178 == 0x7FFFFFFF )
              goto LABEL_36;
            v79 = *(char **)(a3 + 20);
            if ( (unsigned int)v79 >= *(_DWORD *)(a3 + 24) )
            {
              if ( _overflow(a3, (unsigned __int8)v9) == -1 )
                goto LABEL_36;
            }
            else
            {
              *(_DWORD *)(a3 + 20) = v79 + 1;
              *v79 = v9;
            }
            if ( v178 == 2147483646 )
              goto LABEL_36;
            v166 -= 2;
            v178 += 2;
          }
          v68 = v166 - ((_DWORD)v163 + v167);
          if ( v170 > 0 )
          {
            v90 = (int *)IO_padn(a3, 48, (int)v163);
            if ( v163 != (struct timespec *)v90 )
              goto LABEL_36;
            if ( v178 > 0x7FFFFFFE )
              goto LABEL_440;
            if ( 0x7FFFFFFF - v178 < (unsigned int)v163 )
              goto LABEL_246;
            v178 += (unsigned int)v163;
          }
          if ( (v178 & 0x80000000) != 0 )
          {
LABEL_442:
            v143 = &_PRETTY_FUNCTION___13500;
            v142 = 1637;
            goto LABEL_437;
          }
          v80 = *(_DWORD *)(a3 + 148);
          if ( v173 <= v80 - (int)v172 )
          {
            v170 = *(_DWORD *)(a3 + 148);
            IO_vtable_check();
            v80 = v170;
          }
          v81 = (*(int (__cdecl **)(int, int, int))(v80 + 28))(a3, v158, v167);
          if ( v167 != v81 )
            goto LABEL_36;
          if ( v167 > (int)(0x7FFFFFFF - v178) )
            goto LABEL_246;
          v170 = 0x7FFFFFFF;
          v178 += v167;
          if ( (int)v68 > 0 )
          {
            if ( v68 != IO_padn(a3, 32, v68) )
              goto LABEL_36;
            if ( v178 > 0x7FFFFFFE )
              goto LABEL_440;
            if ( v170 - v178 < v68 )
              goto LABEL_246;
LABEL_198:
            v178 += v68;
          }
          goto LABEL_99;
        }
        v110 = 5;
        if ( v170 >= 5 )
          v110 = v170;
        v170 = v110;
        if ( v9 == 83 )
        {
          LODWORD(v175) += 4;
          v185 = "(nil)";
          v165 = (int)&v190;
          v190 = 0;
          v191 = 0;
LABEL_319:
          v97 = v170;
          if ( !_libc_alloca_cutoff(v170) && v97 > 4096 )
          {
            sub_8077593((int)&savedregs);
            return;
          }
          v98 = &v144[-((v170 + 27) & 0xFFFFF000)];
          if ( v144 != v98 )
          {
            while ( v140 != v98 )
              ;
          }
          v99 = ((_WORD)v170 + 27) & 0xFF0;
          if ( (((_WORD)v170 + 27) & 0xFF0) != 0 )
          {
            v100 = alloca(v99);
            *(_DWORD *)&v139[v99] = *(_DWORD *)&v139[v99];
          }
          v167 = 0;
          v138 = v170;
          v170 = (int)v140;
          v101 = wcsrtombs((int)v140, (int *)&v185, v138, (int *)v165);
          p_tv_sec = (int *)v170;
          v44 = v101;
          if ( v101 == -1 )
            goto LABEL_36;
        }
        else
        {
          LODWORD(v175) += 4;
          v41 = (unsigned int *)"(nil)";
LABEL_113:
          v141 = v170;
          v170 = (int)v41;
          v42 = strnlen(v41, v141);
          p_tv_sec = (int *)v170;
          v167 = 0;
          v44 = v42;
        }
LABEL_114:
        v166 -= v44;
        if ( v166 >= 0 )
        {
LABEL_260:
          LOBYTE(v170) = v166 != 0;
          if ( !v164 && v166 )
          {
            v117 = v166;
            v163 = (struct timespec *)p_tv_sec;
            v165 = v44;
            if ( v117 != IO_padn(a3, 32, v166) )
              goto LABEL_36;
            if ( v178 > 0x7FFFFFFE )
              goto LABEL_444;
            p_tv_sec = &v163->tv_sec;
            v44 = v165;
            if ( 0x7FFFFFFF - v178 < v117 )
              goto LABEL_246;
            v178 += v166;
          }
          if ( (v178 & 0x80000000) != 0 )
          {
LABEL_445:
            v143 = &_PRETTY_FUNCTION___13500;
            v142 = 1638;
LABEL_437:
            _assert_fail((int)"(size_t) done <= (size_t) INT_MAX", (int)"vfprintf.c", v142, (int)v143);
          }
          v84 = *(_DWORD *)(a3 + 148);
          if ( v173 <= v84 - (int)v172 )
          {
            v163 = (struct timespec *)p_tv_sec;
            v165 = v44;
            IO_vtable_check();
            p_tv_sec = &v163->tv_sec;
            v44 = v165;
          }
          v163 = (struct timespec *)v44;
          v165 = (int)p_tv_sec;
          v85 = (int *)(*(int (__cdecl **)(int, int *, unsigned int))(v84 + 28))(a3, p_tv_sec, v44);
          if ( v163 != (struct timespec *)v85 )
            goto LABEL_36;
          v86 = (int *)v165;
          if ( (unsigned int)v163 > 0x7FFFFFFF - v178 )
            goto LABEL_246;
          v178 += (unsigned int)v163;
          if ( v164 && (_BYTE)v170 )
          {
            v170 = v165;
            v120 = IO_padn(a3, 32, v166);
            if ( v166 != v120 )
              goto LABEL_36;
            if ( v178 > 0x7FFFFFFE )
              goto LABEL_444;
            v86 = (int *)v170;
            if ( 0x7FFFFFFF - v178 < v166 )
              goto LABEL_246;
            v178 += v166;
          }
          if ( v167 )
            free((int)&savedregs, (int *)&GLOBAL_OFFSET_TABLE_, (int)v86);
        }
        else
        {
          if ( (v178 & 0x80000000) != 0 )
            goto LABEL_445;
          v45 = *(_DWORD *)(a3 + 148);
          if ( v173 <= v45 - (int)v172 )
          {
            v167 = (int)p_tv_sec;
            v170 = v44;
            IO_vtable_check();
            p_tv_sec = (int *)v167;
            v44 = v170;
          }
          v170 = v44;
          v46 = (*(int (__cdecl **)(int, int *, unsigned int))(v45 + 28))(a3, p_tv_sec, v44);
          if ( v170 != v46 )
            goto LABEL_36;
          if ( v170 > 0x7FFFFFFF - v178 )
            goto LABEL_246;
          v178 += v170;
        }
LABEL_99:
        ++v162;
        if ( v171 )
          free((int)&savedregs, (int *)&GLOBAL_OFFSET_TABLE_, (int)v171);
        v179 = (unsigned int *)((char *)v179 + 1);
        v171 = (const struct timespec *)v179;
        v35 = strchrnul(v179, 37);
        v36 = v171;
        v179 = v35;
        if ( (v178 & 0x80000000) != 0 )
        {
          v143 = &_PRETTY_FUNCTION___13500;
          v142 = 1669;
          goto LABEL_437;
        }
        v37 = *(_DWORD *)(a3 + 148);
        if ( v173 <= v37 - (int)v172 )
        {
          IO_vtable_check();
          v35 = v179;
          v36 = v171;
        }
        v171 = v36;
        v38 = (*(int (__cdecl **)(int, const struct timespec *, int))(v37 + 28))(a3, v36, (char *)v35 - (char *)v36);
        v8 = v179;
        v39 = (char *)v179 - (char *)v171;
        if ( (char *)v179 - (char *)v171 != v38 )
          goto LABEL_38;
        if ( v39 > (int)(0x7FFFFFFF - v178) )
          goto LABEL_288;
        v14 = *(_BYTE *)v179 == 0;
        v178 += v39;
        if ( v14 )
          goto LABEL_26;
        continue;
      case 'u':
LABEL_185:
        v161 = 10;
        v65 = (unsigned __int8 *)LODWORD(v175);
LABEL_176:
        if ( v165 )
        {
          v66 = *(_QWORD *)v65;
          v159 = 0;
          LODWORD(v175) += 8;
          v150 = v66;
          v157 = 0;
          v165 = 0;
LABEL_178:
          if ( v170 < 0 )
          {
            v170 = 1;
          }
          else
          {
            if ( !v170 && !v150 )
            {
              if ( v161 == 8 && v156 )
              {
                v160 = 32;
                v167 = 1;
                v67 = (char *)&v163[-1].tv_nsec + 3;
                *v67 = 48;
                v158 = (int)v67;
              }
              else
              {
                v160 = 32;
                v167 = 0;
                v158 = (int)v163;
              }
LABEL_184:
              v153 = v150 != 0;
              goto LABEL_133;
            }
            v160 = 32;
          }
          v89 = itoa(v150, v163, v161, v9 == 88);
          v158 = (int)v89;
          if ( v155 && v154 )
            v158 = (int)group_number(v193, v89, v163, (_BYTE *)v155, (unsigned int *)v152);
          if ( v161 == 10 && v151 )
          {
            v158 = (int)i18n_number_rewrite((_BYTE *)v158, (int)v163, v163);
            v167 = (int)v163 - v158;
          }
          else
          {
            v167 = (int)v163 - v158;
          }
          goto LABEL_184;
        }
        if ( v153 )
        {
          v49 = *v65;
          LODWORD(v175) += 4;
          v159 = 0;
          v153 = v49;
          v157 = 0;
        }
        else
        {
          if ( v158 )
            v49 = *(unsigned __int16 *)v65;
          else
            v49 = *(_DWORD *)v65;
          LODWORD(v175) += 4;
          v159 = 0;
          v153 = v49;
          v157 = 0;
        }
        goto LABEL_127;
      default:
        v171 = 0;
LABEL_34:
        if ( v9 )
          goto LABEL_50;
        __writegsdword(v169, 0x16u);
        goto LABEL_36;
    }
  }
}
// 80B41F9: using guessed type unsigned __int8 byte_80B41F9[1671];
// 80CE000: using guessed type _TBYTE GLOBAL_OFFSET_TABLE_;
// 80CEFA0: using guessed type int _start___libc_IO_vtables[24];
// 80CF2F4: using guessed type int (*_start___libc_atexit)();
// 80CFFD4: using guessed type int _printf_function_table;
// 80CFFD8: using guessed type int _printf_modifier_table;
// 80CFFEC: using guessed type int _printf_va_arg_table;
// 8074CB0: using guessed type int var_1C[7];
// 8074CB0: using guessed type long double var_44C;

//----- (08077593) --------------------------------------------------------
void __usercall sub_8077593(int a1@<ebp>)
{
  const struct timespec *v1; // [esp+0h] [ebp-10h]

  if ( malloc(v1) )
  {
    *(_DWORD *)(a1 - 1184) = 1;
    JUMPOUT(0x8076C2D);
  }
  JUMPOUT(0x8075098);
}
// 80775B5: control flows out of bounds to 8076C2D
// 80775A5: control flows out of bounds to 8075098
// 8077599: variable 'v1' is possibly undefined

//----- (080775BA) --------------------------------------------------------
void __usercall sub_80775BA(int a1@<ebp>, const struct timespec *a2@<edx>)
{
  int *v2; // eax
  int v3; // edx

  v2 = malloc(a2);
  v3 = *(_DWORD *)(a1 - 1200);
  *(_DWORD *)(a1 - 1168) = v2;
  if ( v2 )
  {
    *(_DWORD *)(a1 - 1200) = *(_DWORD *)(a1 - 1168) + v3;
    JUMPOUT(0x807559B);
  }
  JUMPOUT(0x80750B8);
}
// 80775EE: control flows out of bounds to 807559B
// 80775DC: control flows out of bounds to 80750B8

//----- (08077700) --------------------------------------------------------
int __usercall buffered_vfprintf@<eax>(const struct timespec *a1@<eax>, unsigned int *a2@<edx>, int a3@<ecx>)
{
  __time_t tv_sec; // eax
  int tv_nsec; // eax
  int v6; // eax
  int v7; // ebp
  int v8; // ecx
  int v9; // eax
  int *v10; // edx
  int v13; // ebp
  bool v15; // zf
  int v16; // [esp+0h] [ebp-20E4h]
  int v17; // [esp+4h] [ebp-20E0h]
  int v18[4]; // [esp+1Ch] [ebp-20C8h] BYREF
  char *v19; // [esp+2Ch] [ebp-20B8h]
  char *v20; // [esp+30h] [ebp-20B4h]
  unsigned int *v21; // [esp+34h] [ebp-20B0h]
  int v22; // [esp+58h] [ebp-208Ch]
  int v23; // [esp+64h] [ebp-2080h]
  int v24; // [esp+84h] [ebp-2060h]
  void *v25; // [esp+B0h] [ebp-2034h]
  const struct timespec *v26; // [esp+B4h] [ebp-2030h]
  char v27[16]; // [esp+C4h] [ebp-2020h] BYREF
  unsigned int v28; // [esp+20C4h] [ebp-20h] BYREF

  v28 = __readgsdword(0x14u);
  tv_sec = a1[13].tv_sec;
  if ( tv_sec )
  {
    if ( tv_sec != -1 )
      return -1;
  }
  else
  {
    a1[13].tv_sec = -1;
  }
  v26 = a1;
  v20 = v27;
  v19 = v27;
  v21 = &v28;
  tv_nsec = a1[7].tv_nsec;
  v24 = -1;
  v22 = tv_nsec;
  v18[0] = -72515580;
  v23 = 0;
  v25 = &IO_helper_jumps;
  vfprintf((int)&GLOBAL_OFFSET_TABLE_, (int)a1, (int)v18, a2, a3);
  v16 = v6;
  if ( (a1->tv_sec & 0x8000) != 0 )
  {
    v7 = v20 - v19;
    if ( v20 - v19 <= 0 )
      return v16;
  }
  else
  {
    _EDX = (int *)a1[9].tv_sec;
    v13 = __readgsdword(8u);
    if ( _EDX[2] != v13 )
    {
      _ECX = 1;
      v15 = __readgsdword(0xCu) == 0;
      if ( !v15 )
        __asm { lock }
      __asm { cmpxchg [edx], ecx }
      if ( !v15 )
        _lll_lock_wait_private(0, _EDX, v13, 0);
      _EDX = (int *)a1[9].tv_sec;
      _EDX[2] = v13;
    }
    v7 = v20 - v19;
    ++_EDX[1];
    if ( v7 <= 0 )
      goto LABEL_10;
  }
  v8 = a1[18].tv_nsec;
  if ( (char *)&_start___libc_atexit - (char *)_start___libc_IO_vtables <= (unsigned int)(v8
                                                                                        - (_DWORD)_start___libc_IO_vtables) )
  {
    v17 = a1[18].tv_nsec;
    IO_vtable_check();
    v8 = v17;
  }
  v15 = (*(int (__cdecl **)(const struct timespec *, char *, int))(v8 + 28))(a1, v19, v7) == v7;
  v9 = -1;
  if ( v15 )
    v9 = v16;
  v16 = v9;
LABEL_10:
  if ( (a1->tv_sec & 0x8000) == 0 )
  {
    v10 = (int *)a1[9].tv_sec;
    v15 = v10[1]-- == 1;
    if ( v15 )
    {
      v10[2] = 0;
      if ( __readgsdword(0xCu) )
        __asm { lock }
      v15 = (*v10)-- == 1;
      if ( !v15 )
        _lll_unlock_wake_private(v10, v7, 0, a1);
    }
  }
  return v16;
}
// 80777B1: variable 'v6' is possibly undefined
// 80CE000: using guessed type _TBYTE GLOBAL_OFFSET_TABLE_;
// 80CEFA0: using guessed type int _start___libc_IO_vtables[24];
// 80CF2F4: using guessed type int (*_start___libc_atexit)();
// 8077700: using guessed type int var_20C8[4];

//----- (08077940) --------------------------------------------------------
int __usercall hack_digit@<eax>(int a1@<eax>)
{
  int v2; // eax
  int v3; // ecx
  unsigned int *v4; // esi
  int v5; // eax
  int *v6; // ecx
  int v7; // edi
  int v8; // edi
  int v9; // edx
  int v11; // eax
  int v12; // edx
  int v13; // ecx
  int *v14; // ebx
  int v15; // edi
  int v16; // edx

  if ( *(_DWORD *)a1 )
  {
    if ( *(_DWORD *)(a1 + 4) == 102 )
    {
      v16 = *(_DWORD *)(a1 + 8);
      *(_DWORD *)(a1 + 8) = v16 - 1;
      if ( v16 > 0 )
        return 48;
    }
  }
  v2 = *(_DWORD *)(a1 + 24);
  v3 = *(_DWORD *)(a1 + 16);
  v4 = *(unsigned int **)(a1 + 12);
  if ( !v2 )
  {
    v14 = (int *)&v4[v3 - 1];
    v15 = *v14 + 48;
    *v14 = _mpn_mul_1((int)v4, (int)v4, v3 - 1, 0xAu);
    return v15;
  }
  if ( v2 > v3 )
  {
    v8 = 48;
  }
  else
  {
    v5 = _mpn_divrem(*(_DWORD *)(a1 + 28), 0, v4, v3, *(unsigned int **)(a1 + 20), v2);
    v6 = *(int **)(a1 + 28);
    v6[*(_DWORD *)(a1 + 16) - *(_DWORD *)(a1 + 24)] = v5;
    v7 = *v6;
    v3 = *(_DWORD *)(a1 + 24);
    *(_DWORD *)(a1 + 16) = v3;
    if ( !v3 )
    {
      v8 = v7 + 48;
LABEL_10:
      *(_DWORD *)(a1 + 16) = 1;
      return v8;
    }
    v4 = *(unsigned int **)(a1 + 12);
    v8 = v7 + 48;
    if ( !v4[v3 - 1] )
    {
      v9 = v3 - 1;
      do
      {
        v3 = v9;
        *(_DWORD *)(a1 + 16) = v9;
        if ( !v9 )
          goto LABEL_10;
        --v9;
      }
      while ( !v4[v9] );
    }
  }
  v11 = _mpn_mul_1((int)v4, (int)v4, v3, 0xAu);
  if ( v11 )
  {
    v12 = *(_DWORD *)(a1 + 16);
    v13 = *(_DWORD *)(a1 + 12);
    *(_DWORD *)(a1 + 16) = v12 + 1;
    *(_DWORD *)(v13 + 4 * v12) = v11;
  }
  return v8;
}

//----- (08077A50) --------------------------------------------------------
_BYTE *__usercall i18n_number_rewrite_0@<eax>(_BYTE *a1@<eax>, int a2@<edx>, _BYTE *a3@<ecx>)
{
  int v5; // ebx
  unsigned int v6; // eax
  unsigned int v7; // edi
  int *v9; // eax
  int *v10; // edi
  int *v11; // ecx
  int v12; // eax
  unsigned int *v13; // ebx
  int v14; // eax
  int v15; // edx
  __int16 *v16; // ebx
  int v17; // eax
  int v18; // edx
  int v19; // eax
  int v20; // eax
  char *v21; // [esp+4h] [ebp-470h]
  int v22; // [esp+8h] [ebp-46Ch]
  int *v24; // [esp+14h] [ebp-460h]
  int *v25; // [esp+14h] [ebp-460h]
  _DWORD *v26; // [esp+18h] [ebp-45Ch]
  char *v27; // [esp+1Ch] [ebp-458h] BYREF
  int v28; // [esp+20h] [ebp-454h]
  char v29[1034]; // [esp+2Ch] [ebp-448h] BYREF
  __int16 v30[8]; // [esp+436h] [ebp-3Eh] BYREF
  __int16 v31[8]; // [esp+447h] [ebp-2Dh] BYREF
  unsigned int v32; // [esp+458h] [ebp-1Ch]
  int savedregs; // [esp+474h] [ebp+0h] BYREF

  v32 = __readgsdword(0x14u);
  v26 = (_DWORD *)wctrans("to_outpunct");
  v5 = towctrans(0x2Eu, v26);
  v6 = towctrans(0x2Cu, v26);
  if ( v26 )
  {
    v22 = v6;
    v27 = 0;
    v28 = 0;
    v19 = wcrtomb((char *)v30, v5, &v27);
    if ( v19 == -1 )
      v30[0] = 46;
    else
      *((_BYTE *)v30 + v19) = 0;
    v27 = 0;
    v28 = 0;
    v20 = wcrtomb((char *)v31, v22, &v27);
    if ( v20 == -1 )
      v31[0] = 44;
    else
      *((_BYTE *)v31 + v20) = 0;
  }
  v7 = a2 - (_DWORD)a1;
  v28 = 1024;
  v27 = v29;
  if ( (unsigned __int8)_libc_scratch_buffer_set_array_size((int *)&v27, v7, 1) )
  {
    v21 = v27;
    v9 = (int *)mempcpy(v27, a1, v7);
    a1 = a3;
    v10 = v9;
    v11 = (int *)v21;
LABEL_5:
    while ( 1 )
    {
      v10 = (int *)((char *)v10 - 1);
      if ( v11 > v10 )
        break;
      while ( 1 )
      {
        v12 = *(char *)v10;
        if ( (unsigned __int8)(v12 - 48) <= 9u )
          break;
        if ( v26 && (v12 & 0xFD) == 44 )
        {
          v16 = v30;
          if ( (_BYTE)v12 != 46 )
            v16 = v31;
          v25 = v11;
          v17 = strlen((unsigned int *)v16);
          v11 = v25;
          a1 -= v17;
          v18 = v17 - 1;
          if ( v17 )
          {
            do
            {
              a1[v18] = *((_BYTE *)v16 + v18);
              --v18;
            }
            while ( v18 != -1 );
          }
          goto LABEL_5;
        }
        v10 = (int *)((char *)v10 - 1);
        *--a1 = v12;
        if ( v11 > v10 )
          goto LABEL_9;
      }
      v24 = v11;
      v13 = *(unsigned int **)(*(_DWORD *)__readgsdword(0xFFFFFFD0) + 4 * v12 + 8);
      v14 = strlen(v13);
      v11 = v24;
      a1 -= v14;
      v15 = v14 - 1;
      if ( v14 )
      {
        do
        {
          a1[v15] = *((_BYTE *)v13 + v15);
          --v15;
        }
        while ( v15 != -1 );
      }
    }
LABEL_9:
    if ( v27 != v29 )
      free((int)&savedregs, v10, (int)v27);
  }
  return a1;
}

//----- (08077D10) --------------------------------------------------------
int __usercall _guess_grouping_part_0@<eax>(unsigned int a1@<eax>, char *a2@<edx>)
{
  int v2; // ebx
  char v3; // cl
  unsigned int v4; // esi

  v2 = 0;
  v3 = *a2;
  do
  {
    v4 = v3;
    if ( a1 > v3 )
    {
      ++v2;
      a1 -= v3;
      v3 = a2[v2];
      if ( v3 != 127 && v3 >= 0 )
        continue;
    }
    return v2;
  }
  while ( v3 );
  return (a1 - 1) / v4 + v2;
}

//----- (08077D50) --------------------------------------------------------
int __usercall _printf_fp_l@<eax>(
        unsigned int a1@<ebx>,
        int a2@<ebp>,
        unsigned int a3@<edi>,
        unsigned int a4@<esi>,
        _DWORD *a5,
        unsigned __int32 a6,
        int a7,
        const __m128i **a8)
{
  char v9; // al
  char v10; // si
  _DWORD *v11; // ecx
  const __m128i *v12; // edx
  __m128i *v13; // edi
  __m128i v14; // xmm0
  __m128i v15; // xmm5
  __m128i v16; // xmm0
  int v17; // edx
  int v18; // ebx
  __int8 *v19; // edi
  int v20; // edx
  char v21; // al
  int v22; // eax
  _DWORD *v23; // edx
  int v24; // ecx
  unsigned int v25; // edi
  char *v26; // ecx
  __int16 v27; // fps
  int v32; // edx
  __int32 v33; // eax
  __m128d v34; // xmm0
  int v35; // edx
  int v36; // eax
  int v37; // eax
  _DWORD *v38; // edx
  int v39; // eax
  _DWORD *v40; // edx
  __int32 v41; // esi
  int v42; // ecx
  int v43; // eax
  _DWORD *v44; // edx
  bool v45; // al
  int v46; // eax
  _DWORD *v48; // esi
  _BYTE *v49; // eax
  char *v50; // ecx
  __int32 v51; // edi
  __int32 v52; // ebx
  int v53; // eax
  _BYTE *v54; // ecx
  int v55; // edx
  _BYTE *v56; // ecx
  int v57; // edx
  void *v58; // esp
  _BYTE *v59; // ecx
  __int16 v60; // dx
  int v61; // eax
  void *v62; // esp
  int v63; // ecx
  int v64; // eax
  int v65; // eax
  int v66; // edx
  __int32 v67; // edi
  __int32 v68; // eax
  int *v69; // esi
  int v70; // eax
  unsigned int *v71; // eax
  int v72; // edi
  int *m128i_i32; // esi
  int v74; // eax
  int v75; // ebx
  int v76; // edx
  bool v77; // zf
  int v78; // eax
  char *v79; // edx
  unsigned int v80; // ebx
  char v81; // cl
  unsigned int v82; // edi
  __int32 v83; // ebx
  int *v85; // esi
  __int32 v86; // ebx
  unsigned int *v89; // edx
  int v93; // esi
  int v94; // eax
  int v95; // eax
  int v96; // esi
  int v97; // edi
  __int32 v98; // edx
  unsigned int v99; // ebx
  int v100; // esi
  __int32 v101; // eax
  unsigned __int8 v102; // dl
  int v103; // eax
  unsigned int v104; // ebx
  _BOOL4 v105; // eax
  _BYTE *v106; // edx
  int v107; // eax
  void *v108; // esp
  int v109; // ebx
  int v110; // edi
  unsigned int k; // esi
  int *v112; // eax
  int *v113; // edi
  __int32 v114; // ebx
  int v115; // eax
  int *v116; // ebx
  int v117; // eax
  __int32 v118; // esi
  int (__cdecl *v119)(_DWORD *, int *, __int32); // eax
  int v120; // eax
  int v121; // eax
  _DWORD *v122; // edi
  char v123; // dl
  _BYTE *v124; // eax
  _BYTE *v125; // eax
  void *v126; // esp
  _BYTE *v127; // eax
  int *v128; // eax
  int v129; // esi
  bool v130; // dl
  int v131; // eax
  unsigned __int16 v132; // ax
  char *v133; // edx
  int *v134; // eax
  unsigned int v135; // ebx
  int *v136; // esi
  unsigned __int32 v137; // esi
  unsigned __int32 v138; // edx
  unsigned __int32 v139; // esi
  int *v140; // ebx
  unsigned int *v141; // ecx
  unsigned __int32 v142; // eax
  int *v143; // ecx
  unsigned __int32 v144; // eax
  __int32 v145; // edi
  unsigned __int32 v146; // esi
  int *v147; // eax
  int v148; // edx
  int v149; // ebx
  int v150; // eax
  int m; // ecx
  _DWORD *v152; // ebx
  __int32 v153; // edx
  __int32 v154; // eax
  _DWORD *v155; // esi
  char v156; // si
  char v157; // dl
  char v158; // cl
  int v159; // eax
  int v160; // eax
  int v161; // eax
  _DWORD *v162; // edx
  int v163; // edx
  _BYTE *v164; // esi
  int v165; // edx
  void *v166; // esp
  int *v167; // esi
  _BYTE *v168; // eax
  int v169; // ebx
  int v170; // esi
  int *v171; // ecx
  int v172; // edx
  int v173; // edi
  int v174; // esi
  int v175; // eax
  int v176; // edx
  __int32 v177; // ebx
  int v178; // eax
  _DWORD *v179; // edx
  __int32 v180; // eax
  __int32 v181; // ecx
  __int32 v182; // ebx
  int *v183; // esi
  int *v184; // edx
  bool v185; // al
  int v186; // ecx
  int v187; // eax
  int v188; // eax
  _BYTE *v189; // ebx
  char v190; // dl
  _BYTE *v191; // eax
  int v192; // eax
  _DWORD *v193; // edx
  _BYTE *v194; // eax
  int v195; // eax
  int v196; // edx
  __int8 *v197; // edi
  int v198; // eax
  int v199; // ecx
  int v200; // edx
  int *v201; // edx
  unsigned int v202; // ebx
  __int32 v203; // eax
  signed int v204; // ebx
  int v205; // esi
  int v206; // eax
  int v207; // eax
  __int32 v208; // eax
  unsigned int *v210; // eax
  int i; // esi
  int v212; // edi
  int v214; // ebx
  int v215; // ecx
  int *v217; // edx
  char v218; // cl
  unsigned int v219; // ecx
  int v221; // eax
  int v223; // eax
  int v224; // edx
  int *v225; // eax
  int v226; // eax
  int *v227; // esi
  bool v228; // cf
  unsigned int v229; // ecx
  int v230; // eax
  int v231; // edx
  int v232; // esi
  int v233; // eax
  int v234; // ebx
  _BYTE *v235; // eax
  bool v236; // al
  int v237; // eax
  int v238; // eax
  int *v239; // edi
  int v240; // edx
  _BYTE *j; // esi
  int v242; // edx
  __int32 v243; // esi
  int v244; // eax
  __int32 v245; // ecx
  _BYTE *v246; // eax
  int v247; // eax
  char *v248; // esi
  bool v249; // al
  int *v250; // edx
  unsigned int *v251; // ecx
  int v252; // eax
  int v254; // eax
  char v255; // di
  int v256; // eax
  int v257; // edx
  bool v258; // al
  int v259; // esi
  unsigned int v260; // eax
  int v261; // ecx
  int *v262; // ebx
  int v263; // ecx
  int *v264; // esi
  int *v265; // [esp-Ch] [ebp-5110h]
  _BYTE v267[15]; // [esp+4h] [ebp-5100h] BYREF
  int v268; // [esp+FF8h] [ebp-410Ch]
  int v269; // [esp+1000h] [ebp-4104h]
  _BYTE v270[4096]; // [esp+1004h] [ebp-4100h] BYREF
  _BYTE v271[4096]; // [esp+2004h] [ebp-3100h] BYREF
  _BYTE v272[4096]; // [esp+3004h] [ebp-2100h] BYREF
  _BYTE v273[15]; // [esp+4004h] [ebp-1100h] BYREF
  __int128 v274; // [esp+4FF4h] [ebp-110h]
  _BYTE v275[8]; // [esp+5004h] [ebp-100h] BYREF
  int v276; // [esp+500Ch] [ebp-F8h]
  int v277; // [esp+5010h] [ebp-F4h]
  int v278; // [esp+5014h] [ebp-F0h]
  int v279; // [esp+5018h] [ebp-ECh]
  int *v280; // [esp+501Ch] [ebp-E8h]
  __int32 v281; // [esp+5020h] [ebp-E4h]
  int v282; // [esp+5024h] [ebp-E0h]
  unsigned int *v283; // [esp+5028h] [ebp-DCh]
  unsigned int v284; // [esp+502Ch] [ebp-D8h]
  unsigned int *v285; // [esp+5030h] [ebp-D4h]
  int v286; // [esp+5034h] [ebp-D0h]
  unsigned int *v287; // [esp+5038h] [ebp-CCh]
  int *v288; // [esp+503Ch] [ebp-C8h]
  unsigned __int32 v289; // [esp+5040h] [ebp-C4h]
  unsigned int v290; // [esp+5044h] [ebp-C0h]
  int v291; // [esp+5048h] [ebp-BCh]
  int v292; // [esp+504Ch] [ebp-B8h]
  _BOOL4 v293; // [esp+5050h] [ebp-B4h]
  __m128i v294; // [esp+5054h] [ebp-B0h] BYREF
  __m128i v295; // [esp+5064h] [ebp-A0h] BYREF
  char *v296; // [esp+5074h] [ebp-90h]
  _DWORD *v297; // [esp+5078h] [ebp-8Ch]
  __m128i *v298; // [esp+507Ch] [ebp-88h]
  int v299; // [esp+5080h] [ebp-84h]
  __m128 si128; // [esp+5084h] [ebp-80h] BYREF
  __int16 v301; // [esp+509Eh] [ebp-66h]
  int v302; // [esp+50A0h] [ebp-64h] BYREF
  int v303; // [esp+50A4h] [ebp-60h] BYREF
  int v304; // [esp+50A8h] [ebp-5Ch]
  int v305; // [esp+50ACh] [ebp-58h] BYREF
  unsigned int *v306; // [esp+50B0h] [ebp-54h]
  int v307; // [esp+50B4h] [ebp-50h]
  int *v308; // [esp+50B8h] [ebp-4Ch]
  unsigned int *v309; // [esp+50BCh] [ebp-48h]
  int *v310; // [esp+50C0h] [ebp-44h]
  int v311; // [esp+50C4h] [ebp-40h]
  unsigned int v312; // [esp+50C8h] [ebp-3Ch] BYREF
  unsigned int v313; // [esp+50CCh] [ebp-38h]
  unsigned int v314[11]; // [esp+50D0h] [ebp-34h] BYREF
  _DWORD v315[2]; // [esp+50FCh] [ebp-8h] BYREF
  void *retaddr; // [esp+5104h] [ebp+0h]

  v315[1] = retaddr;
  v315[0] = a2;
  _EBP = v315;
  v314[10] = a3;
  v314[9] = a4;
  v314[8] = a1;
  v314[7] = (unsigned int)&a5;
  v298 = (__m128i *)&GLOBAL_OFFSET_TABLE_;
  v299 = a7;
  v297 = a5;
  v289 = a6;
  v9 = *(_BYTE *)(a7 + 13);
  v314[4] = __readgsdword(0x14u);
  v302 = 0;
  v10 = *(_BYTE *)(a7 + 12);
  v303 = 0;
  v293 = (v9 & 4) != 0;
  si128.m128_i8[0] = v9 & 1;
  if ( (v9 & 1) != 0 )
  {
    v24 = *(_DWORD *)(v289 + 16);
    v77 = **(_BYTE **)(v24 + 44) == 0;
    v285 = *(unsigned int **)(v24 + 44);
    if ( v77 )
      v285 = *(unsigned int **)(*(_DWORD *)(v289 + 4) + 36);
    v292 = *(_DWORD *)(v24 + 208);
    if ( !v292 )
      v292 = *(_DWORD *)(*(_DWORD *)(v289 + 4) + 48);
    if ( v10 >= 0 )
      goto LABEL_3;
    v296 = *(char **)(v24 + 52);
  }
  else
  {
    v11 = *(_DWORD **)(v289 + 4);
    v285 = (unsigned int *)v11[9];
    v292 = v11[12];
    if ( v10 >= 0 )
    {
LABEL_3:
      v296 = 0;
      v290 = 0;
      v283 = 0;
      goto LABEL_4;
    }
    v296 = (char *)v11[11];
  }
  v295.m128i_i8[0] = *v296;
  if ( (unsigned __int8)(v295.m128i_i8[0] - 1) > 0x7Du )
    goto LABEL_3;
  if ( v293 )
  {
    if ( si128.m128_i8[0] )
      v25 = *(_DWORD *)(*(_DWORD *)(v289 + 16) + 212);
    else
      v25 = *(_DWORD *)(*(_DWORD *)(v289 + 4) + 52);
    v290 = v25;
    v12 = *a8;
    v283 = 0;
    v26 = 0;
    if ( v25 )
      v26 = v296;
    v296 = v26;
    if ( (v9 & 0x10) != 0 )
      goto LABEL_5;
    goto LABEL_31;
  }
  if ( si128.m128_i8[0] )
    v283 = *(unsigned int **)(*(_DWORD *)(v289 + 16) + 48);
  else
    v283 = *(unsigned int **)(*(_DWORD *)(v289 + 4) + 40);
  v50 = 0;
  if ( *(_BYTE *)v283 )
    v50 = v296;
  v290 = *(_BYTE *)v283 != 0 ? 0xFFFFFFFE : 0;
  v296 = v50;
LABEL_4:
  v12 = *a8;
  if ( (v9 & 0x10) != 0 )
  {
LABEL_5:
    si128 = (__m128)_mm_load_si128(v12);
    if ( !_unordtf2(
            si128.m128_i32[0],
            si128.m128_i32[1],
            si128.m128_i32[2],
            si128.m128_u32[3],
            si128.m128_i32[0],
            si128.m128_i32[1],
            si128.m128_i32[2],
            si128.m128_u32[3]) )
    {
      v13 = v298;
      v14 = _mm_and_si128(_mm_load_si128((const __m128i *)&si128), v298[-7187]);
      v295 = _mm_load_si128(v298 - 7186);
      v294 = v14;
      if ( !_unordtf2(
              v14.m128i_i32[0],
              v14.m128i_i32[1],
              v14.m128i_i32[2],
              v14.m128i_u32[3],
              v295.m128i_i32[0],
              v295.m128i_i32[1],
              v295.m128i_i32[2],
              v295.m128i_u32[3]) )
      {
        v15 = _mm_load_si128(&v295);
        v16 = _mm_load_si128(&v294);
        if ( (int)_lttf2(
                    v16.m128i_u64[0],
                    v16.m128i_u32[2],
                    v16.m128i_i32[3],
                    v15.m128i_u64[0],
                    v15.m128i_u32[2],
                    v15.m128i_i32[3]) > 0 )
        {
          v17 = *(_DWORD *)(v299 + 8);
          v18 = _mm_movemask_ps(si128) & 8;
          v302 = v18;
          if ( (*(_BYTE *)(__readgsdword(0xFFFFFFF8) + 2 * v17 + 1) & 1) != 0 )
          {
LABEL_9:
            v295.m128i_i32[0] = (__int32)v298->m128i_i32 + (_DWORD)&unk_80B1E7C - 135061504;
            v19 = &v298->m128i_i8[(_DWORD)&unk_80B1E5F - 135061504];
            goto LABEL_10;
          }
          goto LABEL_34;
        }
      }
      si128.m128_i32[0] = _mpn_extract_float128(
                            v314,
                            4,
                            &v305,
                            &v302,
                            *(_OWORD *)&_mm_load_si128((const __m128i *)&si128));
      v307 = si128.m128_i32[0];
      v51 = 32 * si128.m128_i32[0] - 112;
      goto LABEL_82;
    }
    v18 = _mm_movemask_ps(si128) & 8;
    v302 = v18;
    if ( (*(_BYTE *)(__readgsdword(0xFFFFFFF8) + 2 * *(_DWORD *)(v299 + 8) + 1) & 1) != 0 )
    {
      v295.m128i_i32[0] = (__int32)v298->m128i_i32 + (_DWORD)&unk_80B1E6C - 135061504;
      v19 = &v298->m128i_i8[(_DWORD)&unk_80B1E5B - 135061504];
    }
    else
    {
      v19 = &v298[-7194].m128i_i8[3];
      v295.m128i_i32[0] = (__int32)&v298[-7192].m128i_i32[3];
    }
LABEL_10:
    v20 = *(_DWORD *)(v299 + 4);
    v21 = (((unsigned __int8)v10 >> 5) ^ 1) & 1;
    if ( v18 )
    {
      si128.m128_i32[0] = v20 - 4;
      v294.m128i_i8[0] = v20 - 4 > 0;
      if ( v20 - 4 <= 0 || !v21 )
      {
        v18 = 0;
LABEL_14:
        if ( v293 )
        {
          v22 = v297[22];
          if ( v22 )
          {
            v23 = *(_DWORD **)(v22 + 16);
            if ( (unsigned int)v23 < *(_DWORD *)(v22 + 20) )
            {
              *(_DWORD *)(v22 + 16) = v23 + 1;
              *v23 = 45;
LABEL_57:
              ++v18;
              goto LABEL_58;
            }
          }
          DWORD1(v274) = 45;
          goto LABEL_466;
        }
        v48 = v297;
        v49 = (_BYTE *)v297[5];
        if ( (unsigned int)v49 < v297[6] )
        {
          v297[5] = v49 + 1;
          *v49 = 45;
          goto LABEL_57;
        }
        DWORD1(v274) = 45;
LABEL_498:
        v236 = _overflow((int)v48, SDWORD1(v274)) == -1;
        goto LABEL_467;
      }
LABEL_39:
      if ( v293 )
        v36 = IO_wpadn((int)v297, 32, si128.m128_i32[0]);
      else
        v36 = IO_padn((int)v297, 32, si128.m128_i32[0]);
      if ( v36 != si128.m128_i32[0] )
        return -1;
      v18 = si128.m128_i32[0];
      v294.m128i_i8[0] = 1;
      if ( v302 )
        goto LABEL_14;
      v10 = *(_BYTE *)(v299 + 12);
      if ( (v10 & 0x40) == 0 )
      {
LABEL_44:
        if ( (v10 & 0x10) == 0 )
        {
LABEL_58:
          v41 = v18 + 3;
          if ( v293 )
          {
            v295.m128i_i32[0] -= 4 * v18;
            while ( 1 )
            {
              v42 = *(_DWORD *)(v295.m128i_i32[0] + 4 * v18);
              v43 = v297[22];
              if ( v43 && (v44 = *(_DWORD **)(v43 + 16), (unsigned int)v44 < *(_DWORD *)(v43 + 20)) )
              {
                *(_DWORD *)(v43 + 16) = v44 + 1;
                v45 = v42 == -1;
                *v44 = v42;
              }
              else
              {
                v45 = _woverflow(v297, *(_DWORD *)(v295.m128i_i32[0] + 4 * v18)) == -1;
              }
              if ( v45 )
                return -1;
              if ( ++v18 == v41 )
              {
                if ( (*(_BYTE *)(v299 + 12) & 0x20) != 0 && v294.m128i_i8[0] )
                {
                  v46 = IO_wpadn((int)v297, 32, si128.m128_i32[0]);
                  goto LABEL_68;
                }
                return v41;
              }
            }
          }
          v295.m128i_i32[0] = (__int32)&v19[-v18];
          v122 = v297;
          do
          {
            v123 = *(_BYTE *)(v295.m128i_i32[0] + v18);
            v124 = (_BYTE *)v122[5];
            if ( (unsigned int)v124 >= v122[6] )
            {
              if ( _overflow((int)v122, *(unsigned __int8 *)(v295.m128i_i32[0] + v18)) == -1 )
                return -1;
            }
            else
            {
              v122[5] = v124 + 1;
              *v124 = v123;
            }
            ++v18;
          }
          while ( v18 != v41 );
          if ( (*(_BYTE *)(v299 + 12) & 0x20) == 0 || !v294.m128i_i8[0] )
            return v41;
          v46 = IO_padn((int)v297, 32, si128.m128_i32[0]);
LABEL_68:
          if ( v46 != si128.m128_i32[0] )
            return -1;
LABEL_69:
          v41 += v46;
          return v41;
        }
        if ( v293 )
        {
          v37 = v297[22];
          if ( v37 )
          {
            v38 = *(_DWORD **)(v37 + 16);
            if ( (unsigned int)v38 < *(_DWORD *)(v37 + 20) )
            {
              *(_DWORD *)(v37 + 16) = v38 + 1;
              *v38 = 32;
              goto LABEL_57;
            }
          }
          DWORD1(v274) = 32;
          goto LABEL_466;
        }
        v127 = (_BYTE *)v297[5];
        if ( (unsigned int)v127 < v297[6] )
        {
          v297[5] = v127 + 1;
          *v127 = 32;
          goto LABEL_57;
        }
        v236 = _overflow((int)v297, 32) == -1;
LABEL_467:
        if ( v236 )
          return -1;
        goto LABEL_57;
      }
LABEL_53:
      if ( v293 )
      {
        v39 = v297[22];
        if ( v39 )
        {
          v40 = *(_DWORD **)(v39 + 16);
          if ( (unsigned int)v40 < *(_DWORD *)(v39 + 20) )
          {
            *(_DWORD *)(v39 + 16) = v40 + 1;
            *v40 = 43;
            goto LABEL_57;
          }
        }
        DWORD1(v274) = 43;
LABEL_466:
        v236 = _woverflow(v297, SDWORD1(v274)) == -1;
        goto LABEL_467;
      }
      v48 = v297;
      v125 = (_BYTE *)v297[5];
      if ( (unsigned int)v125 < v297[6] )
      {
        v297[5] = v125 + 1;
        *v125 = 43;
        goto LABEL_57;
      }
      DWORD1(v274) = 43;
      goto LABEL_498;
    }
    if ( (v10 & 0x50) != 0 )
    {
      si128.m128_i32[0] = v20 - 4;
      v294.m128i_i8[0] = v20 - 4 > 0;
      if ( v20 - 4 <= 0 )
        goto LABEL_52;
    }
    else
    {
      si128.m128_i32[0] = v20 - 3;
      v294.m128i_i8[0] = v20 - 3 > 0;
      if ( v20 - 3 <= 0 )
        goto LABEL_52;
    }
    if ( v21 )
      goto LABEL_39;
LABEL_52:
    if ( (v10 & 0x40) == 0 )
      goto LABEL_44;
    goto LABEL_53;
  }
LABEL_31:
  if ( (v10 & 1) == 0 )
  {
    v34 = (__m128d)v12->m128i_u64[0];
    if ( COERCE_DOUBLE(*(_QWORD *)&v34.m128d_f64[0] & *(__int64 *)((_BYTE *)v298->m128i_i64
                                                                 + (_DWORD)(&xmmword_80B1EF0 - 8441344))) <= *(double *)((char *)v298->m128i_i64 + (_DWORD)(&qword_80B1F00 - 16882688)) )
    {
      si128.m128_i32[0] = _mpn_extract_double(
                            v314,
                            4,
                            &v305,
                            (unsigned int *)&v302,
                            v12->m128i_i32[0],
                            v12->m128i_u32[1]);
      v307 = si128.m128_i32[0];
      v51 = 32 * si128.m128_i32[0] - 52;
      goto LABEL_82;
    }
    v18 = _mm_movemask_pd(v34) & 1;
    v35 = *(_DWORD *)(v299 + 8);
    v302 = v18;
    if ( (*(_BYTE *)(__readgsdword(0xFFFFFFF8) + 2 * v35 + 1) & 1) != 0 )
      goto LABEL_9;
    v295.m128i_i32[0] = (__int32)&v298[-7191].m128i_i32[3];
    v19 = &v298->m128i_i8[(_DWORD)&unk_80B1E67 - 135061504];
    goto LABEL_10;
  }
  _FST7 = *(long double *)v12->m128i_i8;
  __asm { fxam }
  if ( (HIBYTE(v27) & 0x45) == 5 )
  {
    v13 = v298;
    v18 = v27 & 0x200;
    v32 = *(_DWORD *)(v299 + 8);
    v302 = v18;
    if ( (*(_BYTE *)(__readgsdword(0xFFFFFFF8) + 2 * v32 + 1) & 1) != 0 )
      goto LABEL_9;
LABEL_34:
    v33 = (__int32)&v13[-7191].m128i_i32[3];
    v19 = &v13[-7194].m128i_i8[7];
    v295.m128i_i32[0] = v33;
    goto LABEL_10;
  }
  si128.m128_i32[0] = _mpn_extract_long_double((int)v314, 4, (int)&v305, (int)&v302, _FST7);
  v307 = si128.m128_i32[0];
  v51 = 32 * si128.m128_i32[0] - 63;
LABEL_82:
  v52 = v305;
  v53 = 4 * ((int)(abs32(v305) + 31) >> 5) + 59;
  v295.m128i_i32[0] = v53 & 0xFFFFFFF0;
  v54 = &v275[-(v53 & 0xFFFFF000)];
  if ( v275 != v54 )
  {
    while ( v273 != v54 )
      ;
  }
  v55 = v53 & 0xFF0;
  if ( (v53 & 0xFF0) != 0 )
  {
    v126 = alloca(v55);
    *(_DWORD *)&v272[v55 + 4092] = *(_DWORD *)&v272[v55 + 4092];
  }
  v295.m128i_i32[0] = (__int32)v273;
  v306 = (unsigned int *)v273;
  v294.m128i_i32[0] = v53 & 0xFFFFFFF0;
  v56 = &v273[-(v53 & 0xFFFFF000)];
  if ( v273 != v56 )
  {
    while ( v272 != v56 )
      ;
  }
  v57 = v53 & 0xFF0;
  if ( (v53 & 0xFF0) != 0 )
  {
    v58 = alloca(v57);
    *(_DWORD *)&v271[v57 + 4092] = *(_DWORD *)&v271[v57 + 4092];
  }
  v310 = (int *)v272;
  v59 = &v272[-(v53 & 0xFFFFF000)];
  v60 = v53 & 0xFFF0;
  if ( v272 != v59 )
  {
    while ( v271 != v59 )
      ;
  }
  v61 = v53 & 0xFF0;
  if ( (v60 & 0xFFF) != 0 )
  {
    v62 = alloca(v61);
    *(_DWORD *)&v270[v61 + 4092] = *(_DWORD *)&v270[v61 + 4092];
  }
  v309 = 0;
  v308 = (int *)v271;
  if ( v52 <= 2 )
  {
    if ( v52 >= 0 )
    {
      v175 = _mpn_lshift(v295.m128i_i32[0], (int)v314, si128.m128_i32[0], v51 + v52);
      v176 = v307++;
      v306[v176] = v175;
      v305 = 0;
      goto LABEL_133;
    }
    v195 = _mpn_lshift(v295.m128i_i32[0], (int)v314, si128.m128_i32[0], v51);
    v196 = v307;
    v294.m128i_i32[0] = 12;
    v286 = 0;
    ++v307;
    v306[v196] = v195;
    v303 = 1;
    v305 = -v305;
    v288 = (__int32 *)((char *)v298->m128i_i32 + (_DWORD)&unk_80B4DB0 - 135061504);
    v197 = &v298->m128i_i8[(_DWORD)&unk_80B4E70 - 135061504];
    si128.m128_i32[0] = v305;
    while ( 1 )
    {
      v197 -= 16;
      if ( *((_DWORD *)v197 + 3) > si128.m128_i32[0] )
        goto LABEL_392;
      v206 = *((_DWORD *)v197 + 1) - 2;
      if ( v307 < v206 )
      {
        v198 = _mpn_mul(v310, (int *)&v298[-6421] + *(_DWORD *)v197 - 2, v206, v306, v307);
        v199 = v307;
        v200 = v307 + *((_DWORD *)v197 + 1);
        if ( v198 )
          goto LABEL_389;
      }
      else
      {
        v207 = _mpn_mul(
                 v310,
                 (int *)v306,
                 v307,
                 (unsigned int *)&v298[-6421] + *(_DWORD *)v197 - 2,
                 *((_DWORD *)v197 + 1) - 2);
        v199 = v307;
        v200 = v307 + *((_DWORD *)v197 + 1);
        if ( v207 )
        {
LABEL_389:
          v291 = v200 - 2;
          v311 = v200 - 2;
          goto LABEL_390;
        }
      }
      v291 = v200 - 3;
      v311 = v200 - 3;
LABEL_390:
      v287 = (unsigned int *)v310;
      v201 = &v310[v291 - 1];
      _BitScanReverse(&v202, *v201);
      v203 = v305;
      si128.m128_i32[0] = v305;
      v204 = v202 ^ 0x1F;
      v205 = 32 * (v291 - v199) + 31 - v204;
      v295.m128i_i32[0] = v204;
      if ( v305 + 3 == v205 )
      {
        if ( v204 > 28 )
        {
          v312 = -1610612736;
          v313 = 0;
          _mpn_lshift(&v312, (int)&v312, 2, 32 - v295.m128i_i8[0]);
          v203 = v305;
          si128.m128_i32[0] = v305;
          if ( v305 + 2 >= v205 )
          {
            v287 = (unsigned int *)v310;
            v291 = v311;
            goto LABEL_399;
          }
          if ( v305 + 3 != v205 )
            goto LABEL_392;
          v291 = v311;
          v201 = &v310[v311 - 1];
          v219 = v313;
          v287 = (unsigned int *)v310;
        }
        else
        {
          v312 = 0;
          v219 = 10 << (28 - v204);
          v313 = v219;
          if ( v205 <= v305 + 2 )
            goto LABEL_399;
        }
        if ( *v201 >= v219 && (*v201 != v219 || v287[v291 - 2] >= v312) )
        {
          si128.m128_i32[0] = v203;
          goto LABEL_392;
        }
      }
      else if ( v205 > v305 + 2 )
      {
        goto LABEL_392;
      }
LABEL_399:
      si128.m128_i32[0] = v203 - v205;
      v305 = v203 - v205;
      v286 |= 1 << v294.m128i_i8[0];
      v208 = v295.m128i_i32[0] - (v203 - v205);
      if ( si128.m128_i32[0] >= 0 )
        v208 = v295.m128i_i32[0];
      v295.m128i_i32[0] = v208;
      _EAX = *v287;
      if ( !*v287 )
      {
        v210 = v287 + 1;
        v284 = (unsigned int)v197;
        for ( i = 0; ; ++i )
        {
          v212 = (int)v210++;
          _EDX = *(v210 - 1);
          v214 = i + 1;
          v215 = i + 1;
          if ( _EDX )
            break;
        }
        v282 = v212;
        v197 = (__int8 *)v284;
        if ( v295.m128i_i32[0] != 31 )
        {
          __asm { tzcnt   eax, edx }
          v217 = (int *)v306;
          si128.m128_i32[0] = _EAX;
          v218 = 31 - v295.m128i_i8[0];
          if ( 31 - v295.m128i_i32[0] > _EAX )
          {
            _mpn_rshift((int)v306, &v287[i], v291 - i, 31 - v295.m128i_i8[0]);
            v307 = v311 - i;
            si128.m128_i32[0] = v305;
            goto LABEL_392;
          }
          v291 -= v214;
          v287 = (unsigned int *)v282;
LABEL_529:
          _mpn_rshift((int)v217, v287, v291, v218);
          v307 = v311 - v214;
          si128.m128_i32[0] = v305;
          goto LABEL_392;
        }
        v291 -= v214;
        goto LABEL_523;
      }
      if ( v295.m128i_i32[0] == 31 )
      {
        v215 = 0;
        v214 = 0;
LABEL_523:
        if ( v291 > 0 )
        {
          v250 = (int *)v306;
          v251 = &v287[v215];
          v252 = 0;
          do
          {
            v250[v252] = v251[v252];
            ++v252;
          }
          while ( v311 - v214 > v252 );
          v291 = v311 - v214;
        }
        v307 = v291;
        goto LABEL_392;
      }
      __asm { tzcnt   eax, eax }
      v217 = (int *)v306;
      v218 = 31 - v295.m128i_i8[0];
      v214 = 0;
      if ( _EAX >= 31 - v295.m128i_i32[0] )
        goto LABEL_529;
      v254 = _mpn_lshift(v306, (int)v287, v291, v295.m128i_i8[0] + 1);
      v307 = v311 + 1;
      v306[v311] = v254;
      si128.m128_i32[0] = v305;
LABEL_392:
      --v294.m128i_i32[0];
      if ( v197 == (__int8 *)v288 )
      {
        if ( si128.m128_i32[0] > 0 )
        {
          _mpn_mul_1((int)v310, (int)v306, v307, 0xAu);
          _EBX = v310;
          v221 = 4;
          v311 = v307;
          __asm { tzcnt   ecx, [ebx] }
          if ( v305 <= 4 )
            v221 = v305;
          if ( v221 <= _ECX )
          {
            _mpn_rshift((int)v306, (unsigned int *)v310, v307, v221);
          }
          else
          {
            v223 = _mpn_lshift(v306, (int)v310, v307, 32 - v221);
            if ( v223 )
            {
              v224 = v311++;
              v306[v224] = v223;
            }
          }
          v286 |= 1u;
          v307 = v311;
        }
LABEL_420:
        v305 = v286;
        goto LABEL_133;
      }
      if ( si128.m128_i32[0] <= 0 )
        goto LABEL_420;
    }
  }
  v63 = v51 + v52;
  v64 = v51 + v52 + 31;
  if ( v51 + v52 >= 0 )
    v64 = v51 + v52;
  v65 = v64 >> 5;
  v294.m128i_i32[0] = v65;
  v66 = v65;
  if ( (v63 & 0x1F) != 0 )
  {
    v230 = _mpn_lshift((_DWORD *)(v295.m128i_i32[0] + 4 * v65), (int)v314, si128.m128_i32[0], v63 % 32);
    v52 = v305;
    v63 = v51 + v305;
    v231 = v51 + v305 + 31;
    if ( v51 + v305 >= 0 )
      v231 = v51 + v305;
    v66 = v231 >> 5;
    v232 = v66 + v307;
    v307 += v66;
    if ( v230 )
    {
      v307 = v232 + 1;
      v306[v232] = v230;
    }
  }
  else
  {
    v67 = v295.m128i_i32[0] + 4 * v65;
    v68 = si128.m128_i32[0] - 1;
    if ( si128.m128_i32[0] - 1 >= 0 )
    {
      v295.m128i_i32[0] = v66;
      do
      {
        *(_DWORD *)(v67 + 4 * v68) = v314[v68];
        --v68;
      }
      while ( v68 != -1 );
      v66 = v295.m128i_i32[0];
    }
    v307 = si128.m128_i32[0] + v294.m128i_i32[0];
  }
  v69 = (int *)v306;
  v70 = 0;
  if ( v63 > 31 )
  {
    do
      v69[v70++] = 0;
    while ( v66 > v70 );
  }
  v71 = v309;
  v291 = 0;
  v72 = 12;
  si128.m128_i32[0] = 0;
  m128i_i32 = v298[-6425].m128i_i32;
  v295.m128i_i32[0] = (__int32)v298[-6438].m128i_i32;
  v294.m128i_i32[0] = (__int32)v298[-6422].m128i_i32;
  while ( 1 )
  {
    m128i_i32 -= 4;
    if ( m128i_i32[2] + si128.m128_i32[0] - 1 <= v52 )
      break;
LABEL_111:
    --v72;
    if ( m128i_i32 == (int *)v295.m128i_i32[0] )
      goto LABEL_118;
LABEL_112:
    v52 = v305;
  }
  if ( !v71 )
  {
    v74 = m128i_i32[1];
    v75 = *m128i_i32;
    if ( (*(_BYTE *)(v299 + 13) & 0x10) != 0 )
    {
      v311 = v74 + 2;
      memcpy((_BYTE *)v310 + 8, (_BYTE *)(v294.m128i_i32[0] + 4 * v75), 4 * (v74 + 2));
      v128 = v310;
      *v310 = 0;
      v128[1] = 0;
      v76 = v311;
      v305 += 64;
    }
    else
    {
      v311 = m128i_i32[1];
      memcpy(v310, (_BYTE *)(v294.m128i_i32[0] + 4 * v75), 4 * v74);
      v76 = v311;
    }
LABEL_108:
    v77 = v307 == v76;
    if ( v307 > v76 )
      goto LABEL_117;
    goto LABEL_109;
  }
  v78 = _mpn_mul(v310, v308, (int)v71, (unsigned int *)(v294.m128i_i32[0] + 4 * *m128i_i32 + 8), m128i_i32[1] - 2);
  v79 = (char *)v309 + m128i_i32[1];
  if ( !v78 )
  {
    v76 = (int)(v79 - 3);
    v311 = v76;
    goto LABEL_108;
  }
  v76 = (int)(v79 - 2);
  v311 = v76;
  v77 = v307 == v76;
  if ( v307 > v76 )
    goto LABEL_117;
LABEL_109:
  if ( !v77 || (v188 = _mpn_cmp((int)v306, (int)v310, v76), v76 = v311, v188 < 0) )
  {
    v71 = v309;
    goto LABEL_111;
  }
LABEL_117:
  v309 = (unsigned int *)v76;
  memcpy(v308, v310, 4 * v76);
  v71 = v309;
  _BitScanReverse(&v80, v308[(_DWORD)v309 - 1]);
  si128.m128_i32[0] = (v80 ^ 0xFFFFFFE0) + 32 * ((_DWORD)v309 - 2);
  v81 = v72--;
  v291 |= 1 << v81;
  if ( m128i_i32 != (int *)v295.m128i_i32[0] )
    goto LABEL_112;
LABEL_118:
  v305 = v291;
  if ( (int)v71 <= 0 )
    goto LABEL_133;
  _BitScanReverse(&v82, v308[(_DWORD)v71 - 1]);
  v83 = *v308;
  v288 = v308;
  v294.m128i_i32[0] = v83;
  v291 = v82 ^ 0x1F;
  if ( v83 )
  {
    if ( !v291 )
      goto LABEL_133;
    __asm { tzcnt   edi, [ebp-0A8h] }
    _ECX = *v306;
    if ( *v306 )
    {
      v89 = (unsigned int *)v288;
      v86 = 0;
      v295.m128i_i32[0] = 0;
      v294.m128i_i32[0] = 0;
LABEL_126:
      __asm { tzcnt   ecx, ecx }
      if ( _EDI > _ECX )
        _EDI = _ECX;
      v93 = 32 - v291;
      if ( v86 )
        goto LABEL_458;
    }
    else
    {
      v294.m128i_i32[0] = 0;
      v89 = (unsigned int *)v288;
      v93 = 32 - v291;
    }
LABEL_129:
    v86 = 0;
    if ( _EDI < v93 )
    {
      v255 = v291;
      _mpn_lshift(v288, (int)v288, (int)v71, v291);
      v256 = _mpn_lshift(v306, (int)v306, v307, v255);
      if ( v256 )
      {
        v257 = v307++;
        v306[v257] = v256;
      }
      goto LABEL_133;
    }
LABEL_130:
    _mpn_rshift((int)v288, v89, (int)v71 - v86, v93);
    v309 = (unsigned int *)((char *)v309 - v86 - 1);
    _mpn_rshift((int)v306, (unsigned int *)((char *)v306 + v294.m128i_i32[0]), v307 - v86, v93);
    v94 = v307 - v86;
    if ( !v306[v307 - v86 - 1] )
      v94 = v307 - (v86 + 1);
    goto LABEL_132;
  }
  _EDX = *v306;
  si128.m128_i32[0] = (__int32)v306;
  if ( _EDX )
  {
    if ( !v291 )
      goto LABEL_133;
    __asm { tzcnt   edi, edx }
    v89 = (unsigned int *)v288;
    v93 = 32 - v291;
    goto LABEL_129;
  }
  v85 = v308 + 1;
  v86 = 0;
  v287 = v71;
  while ( 1 )
  {
    _ECX = *v85;
    ++v86;
    v89 = (unsigned int *)v85;
    v295.m128i_i32[0] = v86;
    if ( _ECX )
      break;
    _EDI = *(_DWORD *)(si128.m128_i32[0] + 4 * v86);
    ++v85;
    if ( _EDI )
    {
      v294.m128i_i32[0] = 4 * v86;
      v71 = v287;
      if ( v291 )
      {
        __asm { tzcnt   edi, edi }
        v93 = 32 - v291;
        goto LABEL_458;
      }
      goto LABEL_483;
    }
  }
  v294.m128i_i32[0] = 4 * v86;
  v71 = v287;
  if ( !v291 )
  {
LABEL_483:
    v238 = (int)v71 - v86;
    if ( v238 > 0 )
    {
      v239 = v288;
      v240 = 0;
      for ( j = (char *)v288 + v294.m128i_i32[0]; ; _ECX = *(_DWORD *)&j[4 * v240] )
      {
        v239[v240++] = _ECX;
        v238 = (int)v309 - v86;
        if ( (int)v309 - v86 <= v240 )
          break;
      }
    }
    v309 = (unsigned int *)v238;
    v242 = v307 - v86;
    if ( v307 - v86 > 0 )
    {
      v243 = si128.m128_i32[0];
      v244 = 0;
      v245 = si128.m128_i32[0] + v294.m128i_i32[0];
      do
      {
        *(_DWORD *)(v243 + 4 * v244) = *(_DWORD *)(v245 + 4 * v244);
        ++v244;
        v242 = v307 - v86;
      }
      while ( v307 - v86 > v244 );
    }
    v307 = v242;
    goto LABEL_133;
  }
  __asm { tzcnt   edi, ecx }
  _ECX = *(_DWORD *)(si128.m128_i32[0] + v294.m128i_i32[0]);
  if ( _ECX )
    goto LABEL_126;
  v93 = 32 - v291;
LABEL_458:
  if ( v93 <= _EDI )
    goto LABEL_130;
  si128.m128_i32[0] = 4 * v295.m128i_i32[0] - 4;
  _mpn_rshift((int)v288, (unsigned int *)((char *)v288 + si128.m128_i32[0]), (int)v71 - v86 + 1, v93);
  v309 = (unsigned int *)((char *)v309 - v86);
  _mpn_rshift((int)v306, (unsigned int *)((char *)v306 + si128.m128_i32[0]), v307 - (v86 - 1), v93);
  v94 = v307 - (v86 - 1);
  if ( !v306[v94 - 1] )
    v94 = v307 - v86;
LABEL_132:
  v307 = v94;
LABEL_133:
  v279 = *(_DWORD *)(v299 + 4);
  v95 = *(_DWORD *)(v299 + 8);
  v96 = *(_DWORD *)v299;
  v97 = *(_DWORD *)(__readgsdword(0xFFFFFFF0) + 4 * v95);
  v294.m128i_i32[0] = *(_DWORD *)v299;
  v278 = v97;
  if ( (_BYTE)v97 == 101 )
  {
    v304 = v95;
    if ( v96 < 0 )
    {
      v284 = 14;
      v99 = 6;
      v294.m128i_i32[0] = 6;
    }
    else
    {
      v99 = v96;
      v284 = v96 + 8;
    }
    goto LABEL_356;
  }
  if ( (_BYTE)v278 == 102 )
  {
    v99 = v294.m128i_i32[0];
    v304 = 102;
    if ( v294.m128i_i32[0] < 0 )
    {
      v294.m128i_i32[0] = 6;
      v99 = 6;
    }
    if ( !v303 )
    {
      v100 = 1;
      v276 = 0x7FFFFFFF;
      v284 = v305 + v99 + 2;
      v291 = v305 + 1;
      v286 = v294.m128i_i32[0];
      goto LABEL_145;
    }
    v284 = v99 + 2;
LABEL_356:
    v100 = 1;
    v276 = 0x7FFFFFFF;
    v291 = 1;
    v286 = v294.m128i_i32[0];
    goto LABEL_145;
  }
  if ( v294.m128i_i32[0] < 0 )
  {
    v276 = 6;
    v98 = 6;
  }
  else if ( v294.m128i_i32[0] )
  {
    v276 = v294.m128i_i32[0];
    v98 = v294.m128i_i32[0];
  }
  else
  {
    v276 = 1;
    v98 = 1;
  }
  if ( v303 )
  {
    if ( v305 <= 4 )
    {
      v304 = 102;
      v99 = v98;
      v291 = 0;
      v294.m128i_i32[0] = v276;
      goto LABEL_141;
    }
LABEL_421:
    v291 = 1;
    v304 = v95 - 2;
    v99 = v276 - 1;
    v294.m128i_i32[0] = v276 - 1;
    v284 = v98 + 7;
  }
  else
  {
    if ( v276 <= v305 )
      goto LABEL_421;
    v304 = 102;
    v291 = v305 + 1;
    v294.m128i_i32[0] = v276 - (v305 + 1);
    v99 = v294.m128i_i32[0];
LABEL_141:
    v284 = v98 + 5;
  }
  v100 = 0;
  v101 = v294.m128i_i32[0];
  if ( (*(_BYTE *)(v299 + 12) & 8) == 0 )
    v101 = 0;
  v286 = v101;
LABEL_145:
  v282 = 0;
  if ( v296 )
  {
    v102 = *v296 - 1;
    si128.m128_i8[0] = *v296;
    v103 = 0;
    if ( v102 <= 0x7Du )
    {
      v103 = _guess_grouping_part_0(v291, v296);
      v282 = v103;
    }
    v284 += v103 + 1;
  }
  if ( v284 > 0x3FFFFFFC || v284 < v99 )
  {
    v41 = -1;
    __writegsdword(0xFFFFFFE0, 0x22u);
    return v41;
  }
  v104 = 4 * v284 + 8;
  v105 = _libc_alloca_cutoff(v104);
  if ( v104 > 0x1000 && !v105 )
  {
    v280 = malloc((const struct timespec *)v104);
    if ( v280 )
    {
      v277 = 0;
      goto LABEL_158;
    }
    return -1;
  }
  v106 = &v271[-((v104 + 27) & 0xFFFFF000)];
  if ( v271 != v106 )
  {
    while ( v270 != v106 )
      ;
  }
  v107 = ((_WORD)v104 + 27) & 0xFF0;
  if ( (((_WORD)v104 + 27) & 0xFF0) != 0 )
  {
    v108 = alloca(v107);
    *(_DWORD *)&v270[v107 - 4] = *(_DWORD *)&v270[v107 - 4];
  }
  v277 = 1;
  v280 = (int *)v270;
LABEL_158:
  v288 = v280 + 2;
  if ( v303 && v304 == 102 )
  {
    v233 = (int)v280;
    v234 = v292;
    v281 = 0;
    --v305;
    v280[2] = 48;
    v113 = (int *)(v233 + 16);
    *(_DWORD *)(v233 + 12) = v234;
    v295.m128i_i32[0] = (__int32)&v303;
    goto LABEL_167;
  }
  v281 = 0;
  v295.m128i_i32[0] = (__int32)&v303;
  if ( v291 <= 0 )
  {
    v112 = v288;
  }
  else
  {
    v109 = (int)v280;
    v110 = v295.m128i_i32[0];
    for ( k = 0; k != v291; *(_DWORD *)(v109 + 4 * k + 4) = hack_digit(v110) )
      ++k;
    v281 = k;
    v112 = &v288[v291];
  }
  if ( (*(_BYTE *)(v299 + 12) & 8) != 0 || v286 > 0 )
  {
LABEL_166:
    v113 = v112 + 1;
    *v112 = v292;
    v100 = 1;
    goto LABEL_167;
  }
  if ( v294.m128i_i32[0] <= 0 )
  {
    v287 = 0;
    v113 = v112;
    v114 = 0;
  }
  else
  {
    if ( v307 > 1 || *v306 )
      goto LABEL_166;
    v113 = v112;
    v100 = 1;
LABEL_167:
    v114 = 0;
    v287 = 0;
    si128.m128_i32[0] = v286;
    while ( 1 )
    {
      if ( si128.m128_i32[0] > v114 )
        goto LABEL_171;
LABEL_169:
      if ( v294.m128i_i32[0] <= v114 || v307 <= 1 && !*v306 )
        break;
LABEL_171:
      while ( 1 )
      {
        ++v114;
        ++v113;
        v115 = hack_digit(v295.m128i_i32[0]);
        *(v113 - 1) = v115;
        if ( !v100 && v115 == 48 )
          break;
        v100 = 1;
        if ( si128.m128_i32[0] <= v114 )
          goto LABEL_169;
      }
      ++v294.m128i_i32[0];
      if ( v286 > 0 )
      {
        v287 = (unsigned int *)((char *)v287 + 1);
        si128.m128_i32[0] = (__int32)v287 + v286;
      }
    }
  }
  si128.m128_i32[0] = *(v113 - 1);
  if ( si128.m128_i32[0] == v292 )
    si128.m128_i32[0] = *(v113 - 2);
  v129 = hack_digit(v295.m128i_i32[0]);
  v130 = v129 != 48 && v129 != 53;
  if ( !v130 )
  {
    v131 = v307;
    if ( v307 == 1 )
    {
      if ( *v306 )
        v130 = 1;
    }
    else
    {
      if ( v309 )
        goto LABEL_358;
      v295.m128i_i32[0] = v307;
      if ( v307 )
      {
        while ( !v306[v131 - 1] )
        {
          if ( !--v131 )
            goto LABEL_225;
        }
LABEL_358:
        v130 = 1;
      }
    }
  }
LABEL_225:
  v132 = v301 & 0xC00;
  if ( (v301 & 0xC00) == 1024 )
  {
    if ( !v302 )
      goto LABEL_231;
LABEL_229:
    if ( v129 > 52 )
      goto LABEL_315;
LABEL_230:
    if ( !v130 )
      goto LABEL_231;
    goto LABEL_315;
  }
  if ( v132 > 0x400u )
  {
    if ( v132 == 2048 )
    {
      if ( !v302 )
        goto LABEL_229;
LABEL_231:
      v133 = (char *)v287 + v286;
      goto LABEL_232;
    }
    if ( v132 == 3072 )
      goto LABEL_231;
LABEL_311:
    abort((int)v315, v113, (const struct timespec *)v129);
  }
  if ( v132 )
    goto LABEL_311;
  if ( v129 <= 52 )
    goto LABEL_231;
  if ( (si128.m128_i8[0] & 1) == 0 )
    goto LABEL_230;
LABEL_315:
  v134 = v113 - 1;
  v170 = *(v113 - 1);
  v171 = v113 - 1;
  if ( !v114 )
  {
    v225 = v113;
    v133 = (char *)v287 + v286;
LABEL_423:
    if ( v170 == v292 )
      v225 = v171--;
    if ( v288 <= v171 )
    {
      v226 = *(v225 - 1);
      v227 = v288;
      if ( v226 != 57 )
      {
LABEL_448:
        *v171 = v226 + 1;
        goto LABEL_232;
      }
      while ( 1 )
      {
        *v171-- = 48;
        if ( v227 > v171 )
          break;
        v226 = *v171;
        if ( *v171 != 57 )
          goto LABEL_448;
      }
    }
    if ( v304 == 102 )
    {
      v247 = (int)v280;
      if ( v276 == v281 )
      {
        v259 = v292;
        *v280 = 49;
        *(_DWORD *)(v247 + 4) = v259;
        if ( (*(_BYTE *)(v299 + 12) & 8) != 0 || v114 )
        {
          v260 = v281;
          v280[v281 + 2] = 48;
          v114 += v260 + 1;
        }
        else
        {
          v114 = v276;
        }
        ++v305;
        v261 = *(_DWORD *)(v299 + 8);
        v281 = 1;
        v304 = (*(_WORD *)(__readgsdword(0xFFFFFFF8) + 2 * v261) & 0x100) == 0 ? 101 : 69;
        v288 = v280;
      }
      else
      {
        v280[1] = 49;
        v288 = (int *)(v247 + 4);
        ++v281;
      }
    }
    else
    {
      v228 = v303 == 0;
      v280[2] = 49;
      v305 += v228 ? 1 : -1;
      if ( !v305 )
        v303 = 0;
    }
    if ( v114 + v281 > v276 )
    {
      v229 = 4 * (v114 + v281 - v276);
      v114 = v276 - v281;
      v113 = (int *)((char *)v113 - v229);
    }
LABEL_232:
    if ( v114 > (int)v133 )
    {
      v134 = v113 - 1;
      if ( *(v113 - 1) == 48 )
        goto LABEL_237;
    }
    goto LABEL_238;
  }
  v172 = 0;
  if ( v170 == v292 )
  {
LABEL_322:
    if ( v172 == v286 )
      v287 = (unsigned int *)((char *)v287 + ((int)v287 <= 0) - 1);
  }
  else
  {
    if ( v170 == 57 )
    {
      si128.m128_i32[0] = (__int32)v113;
      v173 = v292;
      do
      {
        *v171-- = 48;
        v170 = *v171;
        ++v172;
        if ( *v171 == v173 )
        {
          v113 = (int *)si128.m128_i32[0];
          goto LABEL_322;
        }
      }
      while ( v170 == 57 );
      v113 = (int *)si128.m128_i32[0];
    }
    if ( v172 != v286 || (int)v287 <= 0 || (v287 = (unsigned int *)((char *)v287 - 1), v170 != v292) )
    {
      v174 = v170 + 1;
      *v171 = v174;
      goto LABEL_325;
    }
  }
  v174 = *v171;
  if ( (_BYTE)v278 == 103 && v304 == 102 && (*(_BYTE *)(v299 + 12) & 8) != 0 && v171 == v280 + 3 && v280[2] == 48 )
    v287 = (unsigned int *)((char *)v287 - 1);
LABEL_325:
  v133 = (char *)v287 + v286;
  if ( v174 == v292 )
  {
    v170 = *(v171 - 1);
    v225 = v171--;
    goto LABEL_423;
  }
  if ( (int)v133 >= v114 || *(v113 - 1) != 48 )
    goto LABEL_242;
LABEL_237:
  while ( 1 )
  {
    --v114;
    v113 = v134;
    if ( v114 <= (int)v133 || *(v134 - 1) != 48 )
      break;
    --v134;
  }
LABEL_238:
  if ( !v114 && (*(_BYTE *)(v299 + 12) & 8) == 0 && *(v113 - 1) == v292 )
    --v113;
LABEL_242:
  if ( v296 )
  {
    v295.m128i_i32[0] = v281;
    if ( v291 == v281 )
    {
LABEL_246:
      if ( v282 )
      {
        v135 = v282 + v281;
        v136 = &v288[v135 - 1];
        wmemmove(&v288[v135], &v288[v281], v113 - &v288[v281]);
        si128.m128_i32[0] = (__int32)v136;
        v294.m128i_i32[0] = (__int32)v113;
        v137 = v295.m128i_i32[0];
        v138 = *v296;
        do
        {
          v295.m128i_i32[0] = v138;
          v139 = 0x3FFFFFFF * v138 + v137;
          v140 = &v288[v139];
          v141 = (unsigned int *)(si128.m128_i32[0] - 4 * v138);
          v142 = v138;
          do
          {
            v141[v142] = v140[v142 - 1];
            --v142;
          }
          while ( v142 );
          si128.m128_i32[0] = si128.m128_i32[0] - 4 * v138 - 4;
          v137 = v139 - (v295.m128i_i32[0] << 30);
          *v141 = v290;
          v138 = v296[1];
          if ( (_BYTE)v138 == 127 || (v138 & 0x80u) != 0 )
            break;
          if ( (_BYTE)v138 )
            ++v296;
          else
            v138 = *v296;
        }
        while ( v138 < v137 );
        v143 = v288;
        v144 = v137;
        v145 = v294.m128i_i32[0];
        v146 = si128.m128_i32[0];
        v147 = &v288[v144 - 1];
        do
        {
          v148 = *v147;
          v146 -= 4;
          --v147;
          *(_DWORD *)(v146 + 4) = v148;
        }
        while ( v146 > (unsigned int)v143 );
        v113 = (int *)(v145 + 4 * v282);
      }
    }
    else
    {
      v282 = 0;
      si128.m128_i8[0] = *v296;
      if ( (unsigned __int8)(si128.m128_i8[0] - 1) <= 0x7Du )
      {
        v282 = _guess_grouping_part_0(v281, v296);
        goto LABEL_246;
      }
    }
  }
  if ( v304 != 102 )
  {
    v149 = v305;
    if ( !v303 )
    {
      *v113 = v304;
      v150 = 43;
      goto LABEL_261;
    }
    if ( (_BYTE)v278 == 103 && v305 == 4 )
    {
      v269 = 4;
      v262 = v288;
      wmemcpy(v288, &byte_80B1EAC[(_DWORD)v298 - 135061504], 6);
      v262[1] = v292;
      if ( v262 + 2 <= v113 )
      {
        v264 = v113;
        v269 = v263;
        v113 += 4;
        wmemset(v288 + 6, 48, v264 - (v262 + 2));
      }
      else
      {
        v113 += 5;
      }
    }
    else
    {
      *v113 = v304;
      v150 = 45;
LABEL_261:
      v113[1] = v150;
      if ( v149 <= 9 )
      {
        v113[2] = 48;
        v155 = v113 + 3;
      }
      else
      {
        for ( m = 10; m <= v149; m *= 10 )
          ;
        si128.m128_i32[0] = v149;
        v152 = v113 + 2;
        while ( 1 )
        {
          ++v152;
          v153 = si128.m128_i32[0] % (m / 10);
          v154 = si128.m128_i32[0] / (m / 10) + 48;
          si128.m128_i32[0] = v153;
          *(v152 - 1) = v154;
          if ( m <= 109 )
            break;
          m /= 10;
        }
        v305 = v153;
        v155 = v152;
        v149 = v153;
      }
      v113 = v155 + 1;
      *v155 = v149 + 48;
    }
  }
  v156 = *(_BYTE *)(v299 + 12);
  si128.m128_i32[0] = v302;
  v294.m128i_i32[0] = (char *)v113 - (char *)v288;
  v157 = v156;
  v158 = v156 & 0x20;
  if ( v302 )
  {
    v295.m128i_i32[0] = v279 - (v113 - v288) - 1;
    if ( !v158 )
    {
      v159 = *(_DWORD *)(v299 + 16);
      if ( v295.m128i_i32[0] > 0 && v159 != 48 )
        goto LABEL_274;
    }
    v177 = 0;
    goto LABEL_336;
  }
  if ( (v156 & 0x50) == 0 )
  {
    v295.m128i_i32[0] = v279 - (v113 - v288);
    if ( v158 )
    {
LABEL_280:
      if ( (v156 & 0x40) != 0 )
      {
        if ( v293 )
        {
          v161 = v297[22];
          if ( v161 )
          {
            v162 = *(_DWORD **)(v161 + 16);
            if ( (unsigned int)v162 < *(_DWORD *)(v161 + 20) )
            {
              *(_DWORD *)(v161 + 16) = v162 + 1;
              *v162 = 43;
LABEL_285:
              ++si128.m128_i32[0];
              v157 = *(_BYTE *)(v299 + 12);
LABEL_286:
              if ( (v157 & 0x20) == 0 && *(_DWORD *)(v299 + 16) == 48 && v295.m128i_i32[0] > 0 )
              {
                if ( v293 )
                  v237 = IO_wpadn((int)v297, 48, v295.m128i_i32[0]);
                else
                  v237 = IO_padn((int)v297, 48, v295.m128i_i32[0]);
                if ( v237 != v295.m128i_i32[0] )
                  goto LABEL_193;
                si128.m128_i32[0] += v295.m128i_i32[0];
              }
              if ( v293 )
              {
                if ( (*(_BYTE *)(v299 + 13) & 8) != 0 )
                  v116 = (int *)i18n_number_rewrite_0(0, 0, 0);
                else
                  v116 = 0;
                v180 = v294.m128i_i32[0] >> 2;
                v118 = v294.m128i_i32[0] >> 2;
                if ( v113 == v288 )
                {
                  if ( v180 )
                  {
                    v181 = si128.m128_i32[0];
                    si128.m128_i32[0] += v180;
                    v182 = v181;
                    v183 = &v113[-v181];
                    while ( 1 )
                    {
                      v186 = v183[v182];
                      v187 = v297[22];
                      if ( v187 && (v184 = *(int **)(v187 + 16), (unsigned int)v184 < *(_DWORD *)(v187 + 20)) )
                      {
                        v113 = v184 + 1;
                        *(_DWORD *)(v187 + 16) = v184 + 1;
                        v185 = v186 == -1;
                        *v184 = v186;
                      }
                      else
                      {
                        v185 = _woverflow(v297, v183[v182]) == -1;
                      }
                      if ( v185 )
                        goto LABEL_193;
                      if ( ++v182 == si128.m128_i32[0] )
                      {
                        v296 = 0;
                        v41 = v182;
                        goto LABEL_186;
                      }
                    }
                  }
                  v296 = 0;
                  v41 = si128.m128_i32[0];
                  goto LABEL_186;
                }
                v113 = *(int **)((char *)v297 + (_DWORD)(&off_80CE094 - 33765376));
                if ( (char *)v113 - (char *)_start___libc_IO_vtables < (unsigned int)((char *)&_start___libc_atexit
                                                                                    - (char *)_start___libc_IO_vtables) )
                {
                  v296 = 0;
                  v120 = ((int (__cdecl *)(_DWORD *, int *, __int32))v113[7])(v297, v288, v118);
                  goto LABEL_184;
                }
                v296 = 0;
                goto LABEL_509;
              }
              if ( (*(_BYTE *)(v299 + 13) & 8) != 0 )
                v284 *= *(_DWORD *)(*(_DWORD *)v289 + 88);
              v294.m128i_i32[0] = strlen(v285);
              if ( v283 )
              {
                v291 = strlen(v283);
                v163 = v291 * v282;
              }
              else
              {
                v291 = 0;
                v163 = 0;
              }
              v289 = v163 + v284 + v294.m128i_i32[0] + 2;
              if ( v277 )
              {
                v164 = &v270[-((v289 + 27) & 0xFFFFF000)];
                if ( v270 != v164 )
                {
                  while ( v267 != v164 )
                    ;
                }
                v165 = ((_WORD)v289 + 27) & 0xFF0;
                if ( (((_WORD)v289 + 27) & 0xFF0) != 0 )
                {
                  v166 = alloca(v165);
                  *(_DWORD *)&v267[v165 - 4] = *(_DWORD *)&v267[v165 - 4];
                }
                v296 = v267;
              }
              else
              {
                v296 = (char *)malloc((const struct timespec *)(v163 + v284 + v294.m128i_i32[0] + 2));
                if ( !v296 )
                {
LABEL_194:
                  free((int)v315, v113, (int)v280);
                  return -1;
                }
              }
              if ( v113 <= v288 )
              {
                if ( (*(_BYTE *)(v299 + 13) & 8) == 0 )
                  goto LABEL_505;
                v168 = v296;
              }
              else
              {
                v167 = v288;
                v168 = v296;
                do
                {
                  v169 = *v167;
                  if ( *v167 == v292 )
                  {
                    v168 = mempcpy(v168, v285, v294.m128i_u32[0]);
                  }
                  else if ( v290 == v169 )
                  {
                    v168 = mempcpy(v168, v283, v291);
                  }
                  else
                  {
                    *v168++ = v169;
                  }
                  ++v167;
                }
                while ( v113 > v167 );
                if ( (*(_BYTE *)(v299 + 13) & 8) == 0 )
                {
                  v116 = (int *)v296;
LABEL_180:
                  v117 = v168 - (_BYTE *)v116;
                  v118 = v117;
                  if ( v117 > 20 )
                  {
                    v113 = *(int **)((char *)v297 + (_DWORD)(&off_80CE094 - 33765376));
                    if ( (char *)v113 - (char *)_start___libc_IO_vtables < (unsigned int)((char *)&_start___libc_atexit
                                                                                        - (char *)_start___libc_IO_vtables) )
                    {
                      v288 = v116;
                      v119 = (int (__cdecl *)(_DWORD *, int *, __int32))v113[7];
LABEL_183:
                      v120 = v119(v297, v288, v118);
LABEL_184:
                      if ( v120 != v118 )
                        goto LABEL_193;
                      v41 = si128.m128_i32[0] + v118;
                      goto LABEL_186;
                    }
LABEL_509:
                    IO_vtable_check();
                    v119 = (int (__cdecl *)(_DWORD *, int *, __int32))v113[7];
                    if ( v293 )
                      v116 = v288;
                    v288 = v116;
                    goto LABEL_183;
                  }
                  v41 = si128.m128_i32[0];
                  v189 = (char *)v116 - si128.m128_i32[0];
                  if ( v117 )
                  {
                    si128.m128_i32[0] += v117;
                    v113 = v297;
                    while ( 1 )
                    {
                      v190 = v189[v41];
                      v191 = (_BYTE *)v113[5];
                      if ( (unsigned int)v191 < v113[6] )
                      {
                        v113[5] = (int)(v191 + 1);
                        *v191 = v190;
                      }
                      else if ( _overflow((int)v113, (unsigned __int8)v189[v41]) == -1 )
                      {
                        goto LABEL_193;
                      }
                      if ( ++v41 == si128.m128_i32[0] )
                        goto LABEL_186;
                    }
                  }
LABEL_505:
                  v41 = si128.m128_i32[0];
LABEL_186:
                  if ( !v277 )
                  {
                    free((int)v315, v298->m128i_i32, (int)v296);
                    free((int)v315, v265, (int)v280);
                  }
                  if ( (*(_BYTE *)(v299 + 12) & 0x20) == 0 )
                    return v41;
                  v113 = (int *)v295.m128i_i32[0];
                  if ( v295.m128i_i32[0] <= 0 )
                    return v41;
                  v121 = *(_DWORD *)(v299 + 16);
                  if ( v293 )
                    v46 = IO_wpadn((int)v297, v121, v295.m128i_i32[0]);
                  else
                    v46 = IO_padn((int)v297, v121, v295.m128i_i32[0]);
                  if ( v46 != v295.m128i_i32[0] )
                    goto LABEL_193;
                  goto LABEL_69;
                }
              }
              v248 = &v296[v289];
              v116 = (int *)i18n_number_rewrite_0(v296, (int)v168, &v296[v289]);
              v168 = v248;
              goto LABEL_180;
            }
          }
          v268 = 43;
LABEL_539:
          v258 = _woverflow(v297, v268) == -1;
          goto LABEL_540;
        }
        v235 = (_BYTE *)v297[5];
        if ( (unsigned int)v235 < v297[6] )
        {
          v297[5] = v235 + 1;
          *v235 = 43;
          goto LABEL_285;
        }
        v258 = _overflow((int)v297, 43) == -1;
      }
      else
      {
        if ( (v156 & 0x10) == 0 )
          goto LABEL_286;
        if ( v293 )
        {
          v192 = v297[22];
          if ( v192 )
          {
            v193 = *(_DWORD **)(v192 + 16);
            if ( (unsigned int)v193 < *(_DWORD *)(v192 + 20) )
            {
              *(_DWORD *)(v192 + 16) = v193 + 1;
              *v193 = 32;
              goto LABEL_285;
            }
          }
          v268 = 32;
          goto LABEL_539;
        }
        v246 = (_BYTE *)v297[5];
        if ( (unsigned int)v246 < v297[6] )
        {
          v297[5] = v246 + 1;
          *v246 = 32;
          goto LABEL_285;
        }
        v258 = _overflow((int)v297, 32) == -1;
      }
LABEL_540:
      if ( v258 )
        goto LABEL_193;
      goto LABEL_285;
    }
    v159 = *(_DWORD *)(v299 + 16);
    if ( v159 != 48 && v295.m128i_i32[0] > 0 )
      goto LABEL_274;
LABEL_279:
    v157 = v156;
    goto LABEL_280;
  }
  v295.m128i_i32[0] = v279 - (v113 - v288) - 1;
  if ( v158 )
    goto LABEL_279;
  v159 = *(_DWORD *)(v299 + 16);
  if ( v295.m128i_i32[0] <= 0 || v159 == 48 )
    goto LABEL_279;
LABEL_274:
  if ( v293 )
    v160 = IO_wpadn((int)v297, v159, v295.m128i_i32[0]);
  else
    v160 = IO_padn((int)v297, v159, v295.m128i_i32[0]);
  if ( v160 != v295.m128i_i32[0] )
    goto LABEL_193;
  if ( !v302 )
  {
    si128.m128_i32[0] = v295.m128i_i32[0];
    v156 = *(_BYTE *)(v299 + 12);
    goto LABEL_279;
  }
  v177 = v295.m128i_i32[0];
LABEL_336:
  if ( !v293 )
  {
    v194 = (_BYTE *)v297[5];
    if ( (unsigned int)v194 >= v297[6] )
    {
      v249 = _overflow((int)v297, 45) == -1;
      goto LABEL_519;
    }
    v297[5] = v194 + 1;
    *v194 = 45;
    goto LABEL_340;
  }
  v178 = v297[22];
  if ( v178 )
  {
    v179 = *(_DWORD **)(v178 + 16);
    if ( (unsigned int)v179 < *(_DWORD *)(v178 + 20) )
    {
      *(_DWORD *)(v178 + 16) = v179 + 1;
      *v179 = 45;
      goto LABEL_340;
    }
  }
  v249 = _woverflow(v297, 45) == -1;
LABEL_519:
  if ( !v249 )
  {
LABEL_340:
    si128.m128_i32[0] = v177 + 1;
    v157 = *(_BYTE *)(v299 + 12);
    goto LABEL_286;
  }
LABEL_193:
  if ( !v277 )
    goto LABEL_194;
  return -1;
}
// 8077D50: could not find valid save-restore pair for ebx
// 8077D50: could not find valid save-restore pair for ebp
// 8077D50: could not find valid save-restore pair for edi
// 8077D50: could not find valid save-restore pair for esi
// 807A084: variable 'v265' is possibly undefined
// 807A60E: variable 'v263' is possibly undefined
// 80B1EAC: using guessed type _BYTE byte_80B1EAC[36];
// 80B1EF0: using guessed type __int128 xmmword_80B1EF0;
// 80B1F00: using guessed type __int64 qword_80B1F00;
// 80CE000: using guessed type _TBYTE GLOBAL_OFFSET_TABLE_;
// 80CE094: using guessed type void *off_80CE094;
// 80CEFA0: using guessed type int _start___libc_IO_vtables[24];
// 80CF2F4: using guessed type int (*_start___libc_atexit)();

//----- (0807A640) --------------------------------------------------------
int __usercall _printf_fp@<eax>(
        unsigned int a1@<ebx>,
        int a2@<ebp>,
        unsigned int a3@<edi>,
        unsigned int a4@<esi>,
        _DWORD *a5,
        int a6,
        const __m128i **a7)
{
  return _printf_fp_l(a1, a2, a3, a4, a5, __readgsdword(0xFFFFFFD4), a6, a7);
}

//----- (0807A670) --------------------------------------------------------
int __cdecl _guess_grouping(unsigned int a1, char *a2)
{
  if ( (unsigned __int8)(*a2 - 1) > 0x7Du )
    return 0;
  else
    return _guess_grouping_part_0(a1, a2);
}

//----- (0807A6A0) --------------------------------------------------------
int __usercall register_printf_specifier@<eax>(int a1@<ebp>, int *a2@<edi>, const struct timespec *a3, int a4, int a5)
{
  bool v7; // zf
  int v8; // edx
  unsigned __int8 *v9; // eax
  int v10; // edx

  _EBX = &GLOBAL_OFFSET_TABLE_;
  if ( (unsigned int)a3 > 0xFF )
  {
    v10 = -1;
    __writegsdword(0xFFFFFFE0, 0x16u);
    return v10;
  }
  _ECX = 1;
  v7 = __readgsdword(0xCu) == 0;
  if ( !v7 )
    __asm { lock }
  __asm { cmpxchg ds:(lock_1 - 80CE000h)[ebx], ecx }
  if ( !v7 )
    _lll_lock_wait_private(0, &lock_1, a1, a2);
  v8 = _printf_function_table;
  if ( _printf_function_table )
  {
    v9 = (unsigned __int8 *)_printf_arginfo_table;
  }
  else
  {
    v9 = calloc(a2, 0x100u, 8u);
    _printf_arginfo_table = (int)v9;
    if ( !v9 )
    {
      v10 = -1;
      goto LABEL_9;
    }
    v8 = (int)(v9 + 1024);
    _printf_function_table = (int)(v9 + 1024);
  }
  *(_DWORD *)(v8 + 4 * (_DWORD)a3) = a4;
  *(_DWORD *)&v9[4 * (_DWORD)a3] = a5;
  v10 = 0;
LABEL_9:
  if ( __readgsdword(0xCu) )
    __asm { lock }
  if ( --lock_1 )
    _lll_unlock_wake_private(&lock_1, a1, a2, a3);
  return v10;
}
// 807A72C: variable 'v10' is possibly undefined
// 80CE000: using guessed type _TBYTE GLOBAL_OFFSET_TABLE_;
// 80CFA20: using guessed type int lock_1;
// 80CFFD4: using guessed type int _printf_function_table;
// 80CFFE8: using guessed type int _printf_arginfo_table;

//----- (0807A790) --------------------------------------------------------
int __usercall register_printf_function@<eax>(int a1@<ebp>, int *a2@<edi>, const struct timespec *a3, int a4, int a5)
{
  return register_printf_specifier(a1, a2, a3, a4, a5);
}

//----- (0807A7A0) --------------------------------------------------------
int __usercall _printf_fphex@<eax>(
        int a1@<ebx>,
        int a2@<ebp>,
        int a3@<edi>,
        int a4@<esi>,
        int *a5,
        int a6,
        const __m128i **a7)
{
  int *v7; // edi
  char v8; // dl
  int v9; // ecx
  unsigned int *v10; // esi
  int v11; // ecx
  const __m128i *v12; // eax
  int v13; // esi
  __m128i v14; // xmm0
  __m128i v15; // xmm0
  __m128i v16; // xmm7
  char *v17; // esi
  _DWORD *v18; // ebx
  _DWORD *v19; // edx
  char *v20; // eax
  int v21; // edx
  _DWORD *v22; // eax
  _DWORD *v23; // edx
  _BYTE *v24; // eax
  int v25; // edx
  __int64 v26; // rcx
  __int32 v27; // eax
  unsigned int v28; // ebx
  int v29; // ecx
  char v30; // dl
  __int16 v32; // fps
  __int32 v33; // esi
  int v34; // eax
  unsigned __int32 v35; // edx
  unsigned __int32 v36; // ecx
  int v37; // eax
  int *v38; // edi
  _DWORD *v39; // edi
  char v40; // bl
  int v41; // eax
  int v42; // eax
  int v43; // eax
  int v44; // esi
  char v45; // al
  int v46; // esi
  int v47; // eax
  int v48; // ebx
  int v49; // eax
  _DWORD *v50; // edx
  int v51; // ebx
  int v52; // ecx
  int v53; // eax
  _DWORD *v54; // edx
  bool v55; // al
  __int32 v56; // esi
  int v57; // eax
  char *v59; // eax
  char *v60; // esi
  _DWORD *v61; // ebx
  _DWORD *v62; // edx
  char *v63; // eax
  _DWORD *v64; // eax
  char *v65; // edx
  const struct timespec *v66; // esi
  char v67; // al
  char v68; // dl
  int v69; // edx
  _BOOL4 v70; // ecx
  unsigned __int16 v71; // ax
  int v72; // eax
  char v73; // cl
  char v74; // cl
  __int32 v75; // edx
  _BYTE *v76; // eax
  int v77; // eax
  int v78; // eax
  _DWORD *v79; // edx
  int v80; // ebx
  int v81; // esi
  char v82; // dl
  _BYTE *v83; // eax
  int v84; // eax
  _DWORD *v85; // edx
  int v86; // eax
  _DWORD *v87; // edx
  unsigned int v88; // ebx
  int *v89; // ecx
  int v90; // edx
  bool v91; // al
  int v92; // eax
  int v93; // eax
  _DWORD *v94; // edx
  bool v95; // al
  __int32 v96; // esi
  int v97; // eax
  int v98; // edx
  char *v99; // ebx
  char v100; // dl
  char *v101; // eax
  int v102; // eax
  _BYTE *v103; // ebx
  char v104; // dl
  _BYTE *v105; // eax
  int v106; // eax
  _DWORD *v107; // edx
  int v108; // eax
  bool v109; // al
  int v110; // eax
  _DWORD *v111; // edx
  bool v112; // al
  int v113; // ecx
  int v114; // eax
  int v115; // eax
  _DWORD *v116; // edx
  char v117; // al
  int v118; // eax
  _DWORD *v119; // edx
  _BYTE *v120; // eax
  unsigned __int8 v121; // al
  unsigned __int8 *v122; // edx
  char *v123; // eax
  int v124; // eax
  int v125; // edx
  int *v126; // ecx
  bool v127; // al
  int v128; // eax
  int v129; // edx
  int *v130; // ecx
  int v131; // ebx
  _DWORD *v132; // edx
  bool v133; // al
  int v134; // ecx
  int v135; // eax
  int v136; // eax
  int v137; // eax
  _BYTE *v138; // eax
  _BYTE *v139; // eax
  int v140; // eax
  _DWORD *v141; // edx
  _BYTE *v142; // edx
  bool v143; // cf
  _BYTE *v144; // edx
  int v145; // ebx
  int v146; // esi
  char v147; // dl
  _BYTE *v148; // eax
  int v149; // eax
  _BYTE *v150; // eax
  _BYTE *v151; // eax
  int v152; // eax
  bool v153; // al
  unsigned __int8 v154; // cl
  unsigned __int8 v155; // al
  unsigned __int8 v156; // dl
  _BYTE *v157; // eax
  int v158; // eax
  bool v159; // al
  int v160; // edx
  int v161; // eax
  bool v162; // al
  int v163; // eax
  int v164; // eax
  int v165; // eax
  int v166; // eax
  __m128i v167; // [esp+10h] [ebp-1A0h]
  int *v168; // [esp+24h] [ebp-18Ch]
  _BYTE *v169; // [esp+28h] [ebp-188h]
  char *v170; // [esp+2Ch] [ebp-184h]
  unsigned __int64 v171; // [esp+30h] [ebp-180h]
  _BOOL4 v172; // [esp+30h] [ebp-180h]
  int v173; // [esp+30h] [ebp-180h]
  unsigned __int8 v174; // [esp+30h] [ebp-180h]
  char v175; // [esp+30h] [ebp-180h]
  char v176; // [esp+3Bh] [ebp-175h]
  _BYTE *v177; // [esp+3Ch] [ebp-174h]
  __m128i v178; // [esp+40h] [ebp-170h] BYREF
  __m128i v179; // [esp+50h] [ebp-160h] BYREF
  int v180; // [esp+60h] [ebp-150h]
  unsigned int *v181; // [esp+64h] [ebp-14Ch]
  int v182; // [esp+68h] [ebp-148h]
  int v183; // [esp+6Ch] [ebp-144h]
  __m128 si128; // [esp+70h] [ebp-140h] BYREF
  int v185; // [esp+80h] [ebp-130h]
  int v186; // [esp+84h] [ebp-12Ch]
  int v187; // [esp+88h] [ebp-128h]
  _TBYTE *v188; // [esp+8Ch] [ebp-124h]
  long double v189; // [esp+90h] [ebp-120h]
  long double v190; // [esp+A0h] [ebp-110h]
  long double v191; // [esp+B0h] [ebp-100h]
  __m128i v192; // [esp+C0h] [ebp-F0h]
  int v193; // [esp+E4h] [ebp-CCh] BYREF
  _DWORD v194[13]; // [esp+130h] [ebp-80h] BYREF
  _DWORD v195[2]; // [esp+164h] [ebp-4Ch] BYREF
  int v196; // [esp+16Ch] [ebp-44h] BYREF
  _BYTE v197[12]; // [esp+170h] [ebp-40h] BYREF
  char v198; // [esp+17Ch] [ebp-34h] BYREF
  _BYTE v199[3]; // [esp+17Dh] [ebp-33h] BYREF
  _DWORD v200[7]; // [esp+18Ch] [ebp-24h] BYREF
  _DWORD v201[2]; // [esp+1A8h] [ebp-8h] BYREF
  void *retaddr; // [esp+1B0h] [ebp+0h]

  v201[1] = retaddr;
  v201[0] = a2;
  v200[6] = a3;
  v200[5] = a4;
  v200[4] = a1;
  v200[3] = &a5;
  v7 = a5;
  v188 = &GLOBAL_OFFSET_TABLE_;
  v186 = a6;
  v8 = *(_BYTE *)(a6 + 13);
  v200[0] = __readgsdword(0x14u);
  v183 = *(_DWORD *)a6;
  v180 = *(_DWORD *)(a6 + 4);
  v185 = (v8 & 4) != 0;
  if ( (v8 & 1) != 0 )
  {
    v29 = *(_DWORD *)__readgsdword(0xFFFFFFD8);
    v10 = *(unsigned int **)(v29 + 44);
    v11 = *(_DWORD *)(v29 + 208);
  }
  else
  {
    v9 = *(_DWORD *)__readgsdword(0xFFFFFFDC);
    v10 = *(unsigned int **)(v9 + 36);
    v11 = *(_DWORD *)(v9 + 48);
  }
  v181 = v10;
  v182 = v11;
  if ( !*(_BYTE *)v10 || !v182 )
    _assert_fail((int)v188 - 114904, (int)v188 - 114936, 165, (int)v188 - 114864);
  v12 = *a7;
  v13 = *(_DWORD *)(v186 + 8);
  if ( (v8 & 0x10) != 0 )
  {
    si128 = (__m128)_mm_load_si128(v12);
    v187 = _mm_movemask_ps(si128) & 8;
    if ( _unordtf2(
           si128.m128_i32[0],
           si128.m128_i32[1],
           si128.m128_i32[2],
           si128.m128_u32[3],
           si128.m128_i32[0],
           si128.m128_i32[1],
           si128.m128_i32[2],
           si128.m128_u32[3]) )
    {
      if ( (*(_BYTE *)(__readgsdword(0xFFFFFFF8) + 2 * v13 + 1) & 1) != 0 )
      {
        v183 = (int)v188 + (_DWORD)&unk_80B1E6C - 135061504;
        si128.m128_i32[0] = (__int32)v188 + (_DWORD)&unk_80B1E5B - 135061504;
      }
      else
      {
        v183 = (int)(v188 - 11506);
        si128.m128_i32[0] = (__int32)v188 - 115101;
      }
    }
    else
    {
      v14 = _mm_and_si128(
              _mm_load_si128((const __m128i *)&si128),
              *(__m128i *)((char *)v188 + (_DWORD)(&xmmword_80B1ED0 - 8441344)));
      v179 = _mm_load_si128((const __m128i *)((char *)v188 + (_DWORD)(&xmmword_80B1EE0 - 8441344)));
      v178 = v14;
      if ( _unordtf2(
             v14.m128i_i32[0],
             v14.m128i_i32[1],
             v14.m128i_i32[2],
             v14.m128i_u32[3],
             v179.m128i_i32[0],
             v179.m128i_i32[1],
             v179.m128i_i32[2],
             v179.m128i_u32[3])
        || (v15 = _mm_load_si128(&v178),
            v167 = _mm_load_si128(&v179),
            (int)_lttf2(
                   v15.m128i_u64[0],
                   v15.m128i_u32[2],
                   v15.m128i_i32[3],
                   v167.m128i_u64[0],
                   v167.m128i_u32[2],
                   v167.m128i_i32[3]) <= 0) )
      {
        v16 = _mm_load_si128((const __m128i *)&si128);
        v178.m128i_i64[0] = si128.m128_u64[0];
        v192 = v16;
        v170 = (char *)v200;
        v17 = itoa(si128.m128_u64[0], v200, 0x10u, v13 == 65);
        v18 = itowa(v178.m128i_u64[0], v195, 0x10u, *(_DWORD *)(v186 + 8) == 65);
        v19 = v18;
        v20 = v17;
        if ( v17 > &v198 )
        {
          do
          {
            --v20;
            --v19;
            *v20 = 48;
            *v19 = 48;
          }
          while ( v20 != &v198 );
          v21 = v20 - v17;
          v17 = v20;
          v18 += v21;
        }
        LODWORD(v171) = si128.m128_i32[2];
        HIDWORD(v171) = si128.m128_u16[6];
        v177 = itoa(v171, v17, 0x10u, *(_DWORD *)(v186 + 8) == 65);
        v22 = itowa(v171, v18, 0x10u, *(_DWORD *)(v186 + 8) == 65);
        v179.m128i_i32[0] = (__int32)v22;
        if ( v177 > v197 )
        {
          v23 = v22;
          v24 = v177;
          do
          {
            --v24;
            --v23;
            *v24 = 48;
            *v23 = 48;
          }
          while ( v24 != v197 );
          v25 = v24 - v177;
          v177 = v24;
          v179.m128i_i32[0] += 4 * v25;
        }
        v176 = ((_mm_extract_epi16(_mm_load_si128((const __m128i *)&si128), 7) & 0x7FFF) != 0) + 48;
        v26 = v178.m128i_i64[0] | v171;
        v178.m128i_i32[0] = v192.m128i_i16[7] & 0x7FFF;
        if ( (v192.m128i_i16[7] & 0x7FFF) != 0 )
        {
          v27 = v178.m128i_i32[0];
          if ( v178.m128i_i32[0] <= 16382 )
          {
            v28 = 0x3FFF - v178.m128i_i32[0];
            v178.m128i_i32[0] = 1;
          }
          else
          {
            v178.m128i_i32[0] = 0;
            v28 = v27 - 0x3FFF;
          }
        }
        else
        {
          v149 = v26 | HIDWORD(v26);
          v28 = v26 != 0 ? 0x3FFE : 0;
          v178.m128i_i32[0] = v149 != 0;
        }
        v172 = __PAIR64__(v26, v178.m128i_i32[1] | HIDWORD(v171)) == 0;
        goto LABEL_90;
      }
      if ( (*(_BYTE *)(__readgsdword(0xFFFFFFF8) + 2 * v13 + 1) & 1) != 0 )
      {
        v183 = (int)v188 + (_DWORD)&unk_80B1E7C - 135061504;
        si128.m128_i32[0] = (__int32)v188 + (_DWORD)&unk_80B1E5F - 135061504;
      }
      else
      {
        v183 = (int)v188 - 115044;
        si128.m128_i32[0] = (__int32)v188 - 115097;
      }
    }
    v30 = *(_BYTE *)(v186 + 12);
    goto LABEL_54;
  }
  v30 = *(_BYTE *)(v186 + 12);
  if ( (v30 & 1) != 0 )
  {
    _FST7 = *(long double *)v12->m128i_i8;
    *(long double *)v192.m128i_i8 = _FST7;
    __asm { fxam }
    v187 = v32 & 0x200;
    v178.m128i_i32[0] = (HIBYTE(v32) & 0x45) == 5;
    if ( (HIBYTE(v32) & 0x45) != 5 )
    {
      v191 = _FST7;
      v190 = _FST7;
      v189 = _FST7;
      si128.m128_u64[0] = __PAIR64__(DWORD1(v190), LODWORD(v189));
      v172 = __PAIR64__(DWORD1(v190), LODWORD(v189)) == 0;
      v170 = (char *)v200;
      v60 = itoa(__PAIR64__(DWORD1(v190), LODWORD(v189)), v200, 0x10u, v13 == 65);
      v61 = itowa(__PAIR64__(DWORD1(v190), LODWORD(v189)), v195, 0x10u, *(_DWORD *)(v186 + 8) == 65);
      v62 = v61;
      v63 = v60;
      if ( v60 <= &v198 )
      {
        v177 = v60 + 1;
        v179.m128i_i32[0] = (__int32)(v61 + 1);
      }
      else
      {
        do
        {
          --v63;
          --v62;
          *v63 = 48;
          *v62 = 48;
        }
        while ( v63 != &v198 );
        v177 = v199;
        v179.m128i_i32[0] = (__int32)&v61[v63 - v60 + 1];
        v60 = v63;
      }
      v176 = *v60;
      v28 = WORD4(v191) & 0x7FFF;
      if ( (WORD4(v191) & 0x7FFF) != 0 )
      {
        if ( (WORD4(v191) & 0x7FFFu) <= 0x4001 )
        {
          v178.m128i_i32[0] = 1;
          v28 = 16386 - v28;
        }
        else
        {
          v28 -= 16386;
        }
      }
      else
      {
        v178.m128i_i32[0] = si128.m128_u64[0] != 0;
        if ( si128.m128_u64[0] )
          v28 = 16385;
      }
LABEL_90:
      if ( !v172 )
        goto LABEL_91;
LABEL_33:
      v170 = v177;
      if ( v183 == -1 )
        v183 = 0;
      goto LABEL_35;
    }
    if ( (*(_BYTE *)(__readgsdword(0xFFFFFFF8) + 2 * v13 + 1) & 1) != 0 )
    {
      v183 = (int)v188 + (_DWORD)&unk_80B1E7C - 135061504;
      si128.m128_i32[0] = (__int32)v188 + (_DWORD)&unk_80B1E5F - 135061504;
    }
    else
    {
      v183 = (int)v188 - 115044;
      si128.m128_i32[0] = (__int32)v188 - 115097;
    }
LABEL_54:
    v45 = v30 & 0x20;
    if ( v187 )
    {
      v46 = v180 - 4;
      if ( v45 || v46 <= 0 )
      {
        v48 = 0;
        if ( v185 )
        {
LABEL_63:
          v49 = v7[22];
          if ( v49 )
          {
            v50 = *(_DWORD **)(v49 + 16);
            if ( (unsigned int)v50 < *(_DWORD *)(v49 + 20) )
            {
              *(_DWORD *)(v49 + 16) = v50 + 1;
              *v50 = 45;
LABEL_66:
              v187 = v48 + 1;
              goto LABEL_67;
            }
          }
          v153 = _woverflow(v7, 45) == -1;
          goto LABEL_308;
        }
LABEL_123:
        v76 = (_BYTE *)v7[5];
        if ( (unsigned int)v76 < v7[6] )
        {
          v7[5] = (int)(v76 + 1);
          *v76 = 45;
          goto LABEL_66;
        }
        v153 = _overflow((int)v7, 45) == -1;
LABEL_308:
        if ( v153 )
          return -1;
        goto LABEL_66;
      }
    }
    else if ( (v30 & 0x50) != 0 )
    {
      v46 = v180 - 4;
      if ( v45 )
        goto LABEL_127;
      if ( v46 <= 0 )
      {
        v77 = v180 - 4;
        v46 = 0;
LABEL_126:
        v187 = v46;
        v46 = v77;
        goto LABEL_127;
      }
    }
    else
    {
      v46 = v180 - 3;
      if ( v45 || v46 <= 0 )
      {
LABEL_127:
        if ( (v30 & 0x40) != 0 )
        {
          if ( v185 )
          {
            v78 = v7[22];
            if ( v78 )
            {
              v79 = *(_DWORD **)(v78 + 16);
              if ( (unsigned int)v79 < *(_DWORD *)(v78 + 20) )
              {
                *(_DWORD *)(v78 + 16) = v79 + 1;
                *v79 = 43;
                goto LABEL_132;
              }
            }
            v158 = _woverflow(v7, 43);
LABEL_332:
            v159 = v158 == -1;
            goto LABEL_333;
          }
          v138 = (_BYTE *)v7[5];
          if ( (unsigned int)v138 < v7[6] )
          {
            v7[5] = (int)(v138 + 1);
            *v138 = 43;
            goto LABEL_132;
          }
          v165 = _overflow((int)v7, 43);
        }
        else
        {
          if ( (v30 & 0x10) == 0 )
          {
LABEL_67:
            if ( v185 )
              goto LABEL_68;
            goto LABEL_133;
          }
          if ( v185 )
          {
            v115 = v7[22];
            if ( v115 )
            {
              v116 = *(_DWORD **)(v115 + 16);
              if ( (unsigned int)v116 < *(_DWORD *)(v115 + 20) )
              {
                *(_DWORD *)(v115 + 16) = v116 + 1;
                *v116 = 32;
                goto LABEL_132;
              }
            }
            v158 = _woverflow(v7, 32);
            goto LABEL_332;
          }
          v150 = (_BYTE *)v7[5];
          if ( (unsigned int)v150 < v7[6] )
          {
            v7[5] = (int)(v150 + 1);
            *v150 = 32;
            goto LABEL_132;
          }
          v165 = _overflow((int)v7, 32);
        }
        v159 = v165 == -1;
LABEL_333:
        if ( v159 )
          return -1;
LABEL_132:
        ++v187;
        if ( v185 )
        {
LABEL_68:
          v51 = v187;
          si128.m128_i32[0] = v46;
          v185 = v187 + 3;
          v187 = v183 - 4 * v187;
          while ( 1 )
          {
            v52 = *(_DWORD *)(v187 + 4 * v51);
            v53 = v7[22];
            if ( v53 && (v54 = *(_DWORD **)(v53 + 16), (unsigned int)v54 < *(_DWORD *)(v53 + 20)) )
            {
              *(_DWORD *)(v53 + 16) = v54 + 1;
              v55 = v52 == -1;
              *v54 = v52;
            }
            else
            {
              v55 = _woverflow(v7, *(_DWORD *)(v187 + 4 * v51)) == -1;
            }
            if ( v55 )
              return -1;
            if ( v185 == ++v51 )
            {
              v56 = si128.m128_i32[0];
              v187 = v51;
              if ( (*(_BYTE *)(v186 + 12) & 0x20) != 0 && si128.m128_i32[0] > 0 )
              {
                v57 = IO_wpadn((int)v7, 32, si128.m128_i32[0]);
                goto LABEL_77;
              }
              return v187;
            }
          }
        }
LABEL_133:
        v185 = v46;
        v80 = si128.m128_i32[0] - v187;
        v81 = v187;
        v188 = (_TBYTE *)(v187 + 3);
        do
        {
          v82 = *(_BYTE *)(v80 + v81);
          v83 = (_BYTE *)v7[5];
          if ( (unsigned int)v83 >= v7[6] )
          {
            if ( _overflow((int)v7, *(unsigned __int8 *)(v80 + v81)) == -1 )
              return -1;
          }
          else
          {
            v7[5] = (int)(v83 + 1);
            *v83 = v82;
          }
          ++v81;
        }
        while ( v188 != (_TBYTE *)v81 );
        v187 = v81;
        v56 = v185;
        if ( (*(_BYTE *)(v186 + 12) & 0x20) != 0 && v185 > 0 )
        {
          v57 = IO_padn((int)v7, 32, v185);
LABEL_77:
          if ( v57 == v56 )
          {
            v187 += v57;
            return v187;
          }
          return -1;
        }
        return v187;
      }
    }
    if ( v185 )
      v47 = IO_wpadn((int)v7, 32, v46);
    else
      v47 = IO_padn((int)v7, 32, v46);
    if ( v47 != v46 )
      return -1;
    if ( v187 )
    {
      v48 = v46;
      if ( v185 )
        goto LABEL_63;
      goto LABEL_123;
    }
    v77 = v46;
    v30 = *(_BYTE *)(v186 + 12);
    goto LABEL_126;
  }
  v192.m128i_i64[0] = v12->m128i_i64[0];
  v187 = _mm_movemask_pd((__m128d)v192.m128i_u64[0]) & 1;
  if ( COERCE_DOUBLE(v192.m128i_i64[0] & *(_QWORD *)(v188 - 11496)) > *((double *)v188 - 14368) )
  {
    if ( (*(_BYTE *)(__readgsdword(0xFFFFFFF8) + 2 * v13 + 1) & 1) != 0 )
    {
      v59 = (char *)v188 + (_DWORD)&unk_80B1E5F - 135061504;
      v183 = (int)v188 + (_DWORD)&unk_80B1E7C - 135061504;
    }
    else
    {
      v59 = (char *)v188 + (_DWORD)&unk_80B1E67 - 135061504;
      v183 = (int)v188 - 115044;
    }
    si128.m128_i32[0] = (__int32)v59;
    goto LABEL_54;
  }
  si128.m128_u64[0] = v192.m128i_i64[0] & 0xFFFFFFFFFFFFFLL;
  v172 = (v192.m128i_i64[0] & 0xFFFFFFFFFFFFFLL) == 0;
  v170 = (char *)v200;
  v179.m128i_i32[0] = (__int32)itowa(v192.m128i_i64[0] & 0xFFFFFFFFFFFFFLL, v195, 0x10u, v13 == 65);
  v177 = itoa(v192.m128i_i64[0] & 0xFFFFFFFFFFFFFLL, v200, 0x10u, *(_DWORD *)(v186 + 8) == 65);
  if ( v179.m128i_i32[0] > (unsigned int)v194 )
  {
    v33 = v179.m128i_i32[0];
    v34 = 0;
    v35 = ~((v179.m128i_i32[0] + ~(unsigned int)v194) >> 2);
    do
    {
      *(_DWORD *)(v33 + 4 * v34 - 4) = 48;
      v177[--v34] = 48;
    }
    while ( v34 != v35 );
    v36 = (v179.m128i_i32[0] + ~(unsigned int)v194) >> 2;
    v177 += ~v36;
    v179.m128i_i32[0] -= 4 * v36 + 4;
  }
  v176 = ((v192.m128i_i16[3] & 0x7FF0) != 0) + 48;
  v28 = ((unsigned __int16)v192.m128i_i16[3] >> 4) & 0x7FF;
  if ( (((unsigned __int16)v192.m128i_i16[3] >> 4) & 0x7FF) != 0 )
  {
    if ( (((unsigned __int16)v192.m128i_i16[3] >> 4) & 0x7FFu) <= 0x3FE )
    {
      v178.m128i_i32[0] = 1;
      v28 = 1023 - v28;
    }
    else
    {
      v178.m128i_i32[0] = 0;
      v28 -= 1023;
    }
    goto LABEL_90;
  }
  if ( !si128.m128_u64[0] )
  {
    v178.m128i_i32[0] = 0;
    goto LABEL_33;
  }
  v178.m128i_i32[0] = 1;
  v28 = 1022;
LABEL_91:
  if ( v194[12] == 48 )
  {
    v64 = v195;
    v65 = (char *)v200;
    do
    {
      --v64;
      --v65;
    }
    while ( *(v64 - 1) == 48 );
    v170 = v65;
  }
  v66 = (const struct timespec *)(v170 - v177);
  if ( v183 == -1 )
  {
    v183 = v170 - v177;
    goto LABEL_35;
  }
  if ( v183 < (int)v66 )
  {
    v67 = v176;
    if ( v183 > 0 )
      v67 = v177[v183 - 1];
    v68 = v67;
    si128.m128_i8[0] = v177[v183];
    if ( (unsigned __int8)(v67 - 65) > 5u )
    {
      v154 = v67 - 97;
      v155 = v67 - 87;
      v156 = v68 - 48;
      if ( v154 > 5u )
        v155 = v156;
      v174 = v155;
    }
    else
    {
      v174 = v67 - 55;
    }
    if ( (unsigned __int8)(si128.m128_i8[0] - 65) > 5u )
    {
      if ( (unsigned __int8)(si128.m128_i8[0] - 97) > 5u )
      {
        v69 = si128.m128_i8[0] - 48;
        if ( ((si128.m128_i8[0] - 48) & 7) == 0 )
        {
          v70 = v183 + 1 < (int)v66;
LABEL_104:
          v71 = LOWORD(v191) & 0xC00;
          if ( (LOWORD(v191) & 0xC00) != 1024 )
          {
            if ( v71 <= 0x400u )
            {
              if ( !v71 )
              {
                if ( v69 <= 7 || ((v70 | v174) & 1) == 0 )
                  goto LABEL_35;
                goto LABEL_110;
              }
            }
            else
            {
              if ( v71 == 2048 )
              {
                if ( v187 )
                  goto LABEL_35;
LABEL_108:
                if ( v69 <= 7 && !v70 )
                  goto LABEL_35;
LABEL_110:
                v72 = v183 - 1;
                if ( v183 - 1 >= 0 )
                {
                  v73 = v177[v72];
                  si128.m128_i32[0] = (__int32)&v177[v72];
                  v175 = v73;
                  if ( v73 == 57 )
                  {
LABEL_335:
                    v160 = *(_DWORD *)(v186 + 8);
                    *(_DWORD *)(v179.m128i_i32[0] + 4 * v72) = v160;
                    *(_BYTE *)si128.m128_i32[0] = v160;
                    goto LABEL_35;
                  }
                  if ( *(int *)(__readgsdword(0xFFFFFFF0) + 4 * v73) <= 101 )
                  {
LABEL_337:
                    *(_BYTE *)si128.m128_i32[0] = v175 + 1;
                    ++*(_DWORD *)(v179.m128i_i32[0] + 4 * v72);
                    goto LABEL_35;
                  }
                  while ( 1 )
                  {
                    v75 = v179.m128i_i32[0];
                    v177[v72] = 48;
                    *(_DWORD *)(v75 + 4 * v72--) = 48;
                    if ( v72 == -1 )
                      break;
                    si128.m128_i32[0] = (__int32)&v177[v72];
                    v74 = v177[v72];
                    if ( v74 == 57 )
                      goto LABEL_335;
                    if ( *(int *)(__readgsdword(0xFFFFFFF0) + 4 * v74) <= 101 )
                    {
                      v175 = v177[v72];
                      goto LABEL_337;
                    }
                  }
                }
                if ( v176 == 57 )
                {
                  v176 = *(_BYTE *)(v186 + 8);
                }
                else if ( *(int *)(__readgsdword(0xFFFFFFF0) + 4 * v176) > 101 )
                {
                  if ( v178.m128i_i32[0] )
                  {
                    if ( (int)(v28 - 4) <= 0 )
                    {
                      v176 = 49;
                      v178.m128i_i32[0] = 0;
                      v28 = 4 - v28;
                    }
                    else
                    {
                      v28 -= 4;
                      v176 = 49;
                    }
                  }
                  else
                  {
                    v28 += 4;
                    v176 = 49;
                  }
                }
                else
                {
                  ++v176;
                }
                goto LABEL_35;
              }
              if ( v71 == 3072 )
                goto LABEL_35;
            }
            abort((int)v201, v7, v66);
          }
          if ( !v187 )
            goto LABEL_35;
          goto LABEL_108;
        }
      }
      else
      {
        v69 = si128.m128_i8[0] - 87;
      }
    }
    else
    {
      v69 = si128.m128_i8[0] - 55;
    }
    v70 = 1;
    goto LABEL_104;
  }
LABEL_35:
  v37 = itoa_word(v28, (int)&v196, 0xAu, 0);
  si128.m128_i32[0] = (__int32)v7;
  v173 = v37;
  v38 = &v193;
  while ( 1 )
  {
    *--v38 = *((_DWORD *)v188 + v28 % 0xA - 22064);
    if ( v28 <= 9 )
      break;
    v28 /= 0xAu;
  }
  v168 = v38;
  v39 = (_DWORD *)si128.m128_i32[0];
  v40 = *(_BYTE *)(v186 + 12);
  v41 = 4;
  if ( !v187 )
    v41 = ((v40 & 0x50) != 0) + 3;
  v169 = &v197[-v173 - 4];
  v180 -= (int)&v197[v183 - 2 + v41 - v173];
  if ( v183 > 0 || (v40 & 8) != 0 )
  {
    v42 = 1;
    if ( !v185 )
      v42 = strlen(v181);
    v180 -= v42;
  }
  if ( (v40 & 0x20) != 0 || *(_DWORD *)(v186 + 16) == 48 || v180 <= 0 )
  {
    v44 = 0;
  }
  else
  {
    if ( v185 )
      v43 = IO_wpadn(si128.m128_i32[0], 32, v180);
    else
      v43 = IO_padn(si128.m128_i32[0], 32, v180);
    v44 = v180;
    if ( v43 != v180 )
      return -1;
  }
  if ( v187 )
  {
    if ( v185 )
    {
      v84 = v39[22];
      if ( v84 )
      {
        v85 = *(_DWORD **)(v84 + 16);
        if ( (unsigned int)v85 < *(_DWORD *)(v84 + 20) )
        {
          *(_DWORD *)(v84 + 16) = v85 + 1;
          *v85 = 45;
LABEL_146:
          ++v44;
          goto LABEL_147;
        }
      }
      v161 = _woverflow(v39, 45);
      goto LABEL_343;
    }
    v139 = (_BYTE *)v39[5];
    if ( (unsigned int)v139 < v39[6] )
    {
      v39[5] = v139 + 1;
      *v139 = 45;
      goto LABEL_146;
    }
    v166 = _overflow((int)v39, 45);
    goto LABEL_358;
  }
  v117 = *(_BYTE *)(v186 + 12);
  if ( (v117 & 0x40) != 0 )
  {
    if ( v185 )
    {
      v118 = v39[22];
      if ( v118 )
      {
        v119 = *(_DWORD **)(v118 + 16);
        if ( (unsigned int)v119 < *(_DWORD *)(v118 + 20) )
        {
          *(_DWORD *)(v118 + 16) = v119 + 1;
          *v119 = 43;
          goto LABEL_146;
        }
      }
      v161 = _woverflow(v39, 43);
      goto LABEL_343;
    }
    v151 = (_BYTE *)v39[5];
    if ( (unsigned int)v151 < v39[6] )
    {
      v39[5] = v151 + 1;
      *v151 = 43;
      goto LABEL_146;
    }
    v166 = _overflow((int)v39, 43);
    goto LABEL_358;
  }
  if ( (v117 & 0x10) != 0 )
  {
    if ( v185 )
    {
      v140 = v39[22];
      if ( v140 )
      {
        v141 = *(_DWORD **)(v140 + 16);
        if ( (unsigned int)v141 < *(_DWORD *)(v140 + 20) )
        {
          *(_DWORD *)(v140 + 16) = v141 + 1;
          *v141 = 32;
          goto LABEL_146;
        }
      }
      v161 = _woverflow(v39, 32);
LABEL_343:
      v162 = v161 == -1;
      goto LABEL_344;
    }
    v157 = (_BYTE *)v39[5];
    if ( (unsigned int)v157 < v39[6] )
    {
      v39[5] = v157 + 1;
      *v157 = 32;
      goto LABEL_146;
    }
    v166 = _overflow((int)v39, 32);
LABEL_358:
    v162 = v166 == -1;
LABEL_344:
    if ( v162 )
      return -1;
    goto LABEL_146;
  }
LABEL_147:
  if ( v185 )
  {
    v86 = v39[22];
    if ( v86 && (v87 = *(_DWORD **)(v86 + 16), v88 = *(_DWORD *)(v86 + 20), (unsigned int)v87 < v88) )
    {
      v89 = v87 + 1;
      *(_DWORD *)(v86 + 16) = v87 + 1;
      *v87 = 48;
      v187 = *(_DWORD *)(v186 + 8);
      v90 = v187 + 23;
    }
    else
    {
      if ( _woverflow(v39, 48) == -1 )
        return -1;
      v187 = *(_DWORD *)(v186 + 8);
      v90 = v187 + 23;
      v86 = v39[22];
      if ( !v86 )
      {
LABEL_310:
        v91 = _woverflow(v39, v90) == -1;
        goto LABEL_153;
      }
      v89 = *(int **)(v86 + 16);
      v88 = *(_DWORD *)(v86 + 20);
    }
    if ( (unsigned int)v89 < v88 )
    {
      *(_DWORD *)(v86 + 16) = v89 + 1;
      v91 = v90 == -1;
      *v89 = v90;
      goto LABEL_153;
    }
    goto LABEL_310;
  }
  v120 = (_BYTE *)v39[5];
  if ( (unsigned int)v120 >= v39[6] )
  {
    if ( _overflow((int)v39, 48) == -1 )
      return -1;
    v187 = *(_DWORD *)(v186 + 8);
    v121 = v187 + 23;
  }
  else
  {
    v39[5] = v120 + 1;
    *v120 = 48;
    v187 = *(_DWORD *)(v186 + 8);
    v121 = v187 + 23;
  }
  v122 = (unsigned __int8 *)v39[5];
  if ( (unsigned int)v122 < v39[6] )
  {
    v39[5] = v122 + 1;
    *v122 = v121;
    si128.m128_i32[0] = v44 + 2;
    if ( (*(_BYTE *)(v186 + 12) & 0x20) != 0 || *(_DWORD *)(v186 + 16) != 48 || v180 <= 0 )
      goto LABEL_221;
    goto LABEL_220;
  }
  v91 = _overflow((int)v39, v121) == -1;
LABEL_153:
  if ( v91 )
    return -1;
  si128.m128_i32[0] = v44 + 2;
  if ( (*(_BYTE *)(v186 + 12) & 0x20) == 0 && *(_DWORD *)(v186 + 16) == 48 && v180 > 0 )
  {
    if ( v185 )
    {
      v92 = IO_wpadn((int)v39, 48, v180);
LABEL_159:
      if ( v180 != v92 )
        return -1;
      si128.m128_i32[0] += v180;
      goto LABEL_161;
    }
LABEL_220:
    v92 = IO_padn((int)v39, 48, v180);
    goto LABEL_159;
  }
LABEL_161:
  if ( v185 )
  {
    v93 = v39[22];
    if ( v93 && (v94 = *(_DWORD **)(v93 + 16), (unsigned int)v94 < *(_DWORD *)(v93 + 20)) )
    {
      *(_DWORD *)(v93 + 16) = v94 + 1;
      *v94 = v176;
      v95 = v176 == -1;
    }
    else
    {
      v95 = _woverflow(v39, v176) == -1;
    }
    goto LABEL_165;
  }
LABEL_221:
  v123 = (char *)v39[5];
  if ( (unsigned int)v123 < v39[6] )
  {
    v39[5] = v123 + 1;
    *v123 = v176;
    goto LABEL_166;
  }
  v95 = _overflow((int)v39, (unsigned __int8)v176) == -1;
LABEL_165:
  if ( v95 )
    return -1;
LABEL_166:
  v96 = si128.m128_i32[0] + 1;
  if ( v183 > 0 || (*(_BYTE *)(v186 + 12) & 8) != 0 )
  {
    v187 = si128.m128_i32[0] + 1;
    if ( v185 )
    {
      v106 = v39[22];
      if ( v106 && (v107 = *(_DWORD **)(v106 + 16), (unsigned int)v107 < *(_DWORD *)(v106 + 20)) )
      {
        *(_DWORD *)(v106 + 16) = v107 + 1;
        v108 = v182;
        *v107 = v182;
        v109 = v108 == -1;
      }
      else
      {
        v109 = _woverflow(v39, v182) == -1;
      }
      if ( v109 )
        return -1;
      v96 = si128.m128_i32[0] + 2;
      if ( v183 <= 0 )
        goto LABEL_364;
      v110 = v170 - v177;
      v182 = v170 - v177;
      if ( v183 <= v170 - v177 )
        v110 = v183;
      v187 = v179.m128i_i32[0] - 4 * si128.m128_i32[0];
      si128.m128_i32[0] += v110 + 2;
      if ( v110 )
      {
        do
        {
          v113 = *(_DWORD *)(v187 + 4 * v96 - 8);
          v114 = v39[22];
          if ( v114 && (v111 = *(_DWORD **)(v114 + 16), (unsigned int)v111 < *(_DWORD *)(v114 + 20)) )
          {
            *(_DWORD *)(v114 + 16) = v111 + 1;
            v112 = v113 == -1;
            *v111 = v113;
          }
          else
          {
            v112 = _woverflow(v39, *(_DWORD *)(v187 + 4 * v96 - 8)) == -1;
          }
          if ( v112 )
            return -1;
        }
        while ( ++v96 != si128.m128_i32[0] );
      }
      si128.m128_i32[0] = v183 - v182;
      if ( v183 - v182 <= 0 )
      {
LABEL_364:
        v187 = *(_DWORD *)(v186 + 8);
        v124 = v187 + 15;
        goto LABEL_227;
      }
      v152 = IO_wpadn((int)v39, 48, si128.m128_i32[0]);
    }
    else
    {
      v97 = strlen(v181);
      v98 = v187;
      v99 = (char *)v181 - si128.m128_i32[0];
      v187 += v97;
      if ( v97 )
      {
        while ( 1 )
        {
          while ( 1 )
          {
            v100 = v99[v96 - 1];
            v101 = (char *)v39[5];
            if ( (unsigned int)v101 >= v39[6] )
              break;
            ++v96;
            v39[5] = v101 + 1;
            *v101 = v100;
            if ( v187 == v96 )
              goto LABEL_174;
          }
          if ( _overflow((int)v39, (unsigned __int8)v99[v96 - 1]) == -1 )
            return -1;
          if ( v187 == ++v96 )
            goto LABEL_174;
        }
      }
      v187 = v98;
LABEL_174:
      if ( v183 <= 0 )
        goto LABEL_265;
      v102 = v170 - v177;
      if ( v183 <= v170 - v177 )
        v102 = v183;
      v96 = v187;
      si128.m128_i32[0] = v183 - (v170 - v177);
      v103 = &v177[-v187];
      v187 += v102;
      if ( v102 )
      {
        do
        {
          v104 = v103[v96];
          v105 = (_BYTE *)v39[5];
          if ( (unsigned int)v105 < v39[6] )
          {
            v39[5] = v105 + 1;
            *v105 = v104;
          }
          else if ( _overflow((int)v39, (unsigned __int8)v103[v96]) == -1 )
          {
            return -1;
          }
          ++v96;
        }
        while ( v96 != v187 );
      }
      if ( si128.m128_i32[0] <= 0 )
      {
        v187 = v96;
LABEL_265:
        si128.m128_i32[0] = *(_DWORD *)(v186 + 8);
        LOBYTE(v124) = si128.m128_i8[0] + 15;
        goto LABEL_266;
      }
      v152 = IO_padn((int)v39, 48, si128.m128_i32[0]);
    }
    if ( v152 != si128.m128_i32[0] )
      return -1;
    v96 += v152;
  }
  v187 = *(_DWORD *)(v186 + 8);
  v124 = v187 + 15;
  if ( v185 )
  {
LABEL_227:
    v125 = v39[22];
    if ( v125 && (v126 = *(int **)(v125 + 16), (unsigned int)v126 < *(_DWORD *)(v125 + 20)) )
    {
      *(_DWORD *)(v125 + 16) = v126 + 1;
      *v126 = v124;
      v127 = v124 == -1;
    }
    else
    {
      v127 = _woverflow(v39, v124) == -1;
    }
    goto LABEL_230;
  }
  v187 = v96;
LABEL_266:
  v142 = (_BYTE *)v39[5];
  if ( (unsigned int)v142 < v39[6] )
  {
    v143 = v178.m128i_i32[0] == 0;
    v39[5] = v142 + 1;
    *v142 = v124;
    v128 = v143 ? 43 : 45;
    goto LABEL_268;
  }
  v163 = _overflow((int)v39, (unsigned __int8)v124);
  v96 = v187;
  v127 = v163 == -1;
LABEL_230:
  if ( v127 )
    return -1;
  v128 = v178.m128i_i32[0] == 0 ? 43 : 45;
  if ( v185 )
  {
    v129 = v39[22];
    if ( v129 )
    {
      v130 = *(int **)(v129 + 16);
      if ( (unsigned int)v130 < *(_DWORD *)(v129 + 20) )
      {
        *(_DWORD *)(v129 + 16) = v130 + 1;
        v131 = v96 + 2;
        *v130 = v128;
        goto LABEL_235;
      }
    }
    v131 = v96 + 2;
    if ( _woverflow(v39, v178.m128i_i32[0] == 0 ? 43 : 45) != -1 )
    {
LABEL_235:
      v187 = (int)&v169[v131];
      si128.m128_i32[0] = (__int32)&v168[-v131];
      if ( v169 )
      {
        while ( 1 )
        {
          v134 = *(_DWORD *)(si128.m128_i32[0] + 4 * v131);
          v135 = v39[22];
          if ( v135 && (v132 = *(_DWORD **)(v135 + 16), (unsigned int)v132 < *(_DWORD *)(v135 + 20)) )
          {
            *(_DWORD *)(v135 + 16) = v132 + 1;
            v133 = v134 == -1;
            *v132 = v134;
          }
          else
          {
            v133 = _woverflow(v39, *(_DWORD *)(si128.m128_i32[0] + 4 * v131)) == -1;
          }
          if ( v133 )
            return -1;
          if ( v187 == ++v131 )
            goto LABEL_244;
        }
      }
      goto LABEL_243;
    }
    return -1;
  }
  v187 = v96;
LABEL_268:
  v144 = (_BYTE *)v39[5];
  if ( (unsigned int)v144 >= v39[6] )
  {
    v164 = _overflow((int)v39, v128);
    v131 = v187 + 2;
    if ( v164 == -1 )
      return -1;
  }
  else
  {
    v145 = v187;
    v39[5] = v144 + 1;
    *v144 = v128;
    v131 = v145 + 2;
  }
  v187 = (int)&v169[v131];
  v146 = v173 - v131;
  if ( v169 )
  {
    while ( 1 )
    {
      v147 = *(_BYTE *)(v146 + v131);
      v148 = (_BYTE *)v39[5];
      if ( (unsigned int)v148 < v39[6] )
      {
        v39[5] = v148 + 1;
        *v148 = v147;
      }
      else if ( _overflow((int)v39, *(unsigned __int8 *)(v146 + v131)) == -1 )
      {
        return -1;
      }
      if ( v187 == ++v131 )
        goto LABEL_244;
    }
  }
LABEL_243:
  v187 = v131;
LABEL_244:
  if ( (*(_BYTE *)(v186 + 12) & 0x20) != 0 )
  {
    v136 = *(_DWORD *)(v186 + 16);
    if ( v136 != 48 && v180 > 0 )
    {
      if ( v185 )
        v137 = IO_wpadn((int)v39, v136, v180);
      else
        v137 = IO_padn((int)v39, v136, v180);
      if ( v180 == v137 )
      {
        v187 += v180;
        return v187;
      }
      return -1;
    }
  }
  return v187;
}
// 807A7A0: could not find valid save-restore pair for ebx
// 807A7A0: could not find valid save-restore pair for ebp
// 807A7A0: could not find valid save-restore pair for edi
// 807A7A0: could not find valid save-restore pair for esi
// 80B1ED0: using guessed type __int128 xmmword_80B1ED0;
// 80B1EE0: using guessed type __int128 xmmword_80B1EE0;
// 80CE000: using guessed type _TBYTE GLOBAL_OFFSET_TABLE_;
// 807A7A0: using guessed type __m128i var_1A0;
// 807A7A0: using guessed type __m128i anonymous_5;

//----- (0807C4E0) --------------------------------------------------------
int __usercall register_printf_modifier@<eax>(int *a1@<ebp>, int a2)
{
  int v3; // esi
  bool v5; // zf
  int v6; // ecx
  int v7; // edx

  _EBX = &GLOBAL_OFFSET_TABLE_;
  if ( (unsigned int)(*(_DWORD *)a2 - 1) > 0xFE )
  {
LABEL_18:
    __writegsdword(0xFFFFFFE0, 0x16u);
    return -1;
  }
  else
  {
    v3 = a2;
    while ( 1 )
    {
      v3 += 4;
      if ( !*(_DWORD *)v3 )
        break;
      if ( *(_DWORD *)v3 > 0xFFu )
        goto LABEL_18;
    }
    if ( (unsigned int)(next_bit - 16) <= 7 )
    {
      v7 = -1;
      __writegsdword(0xFFFFFFE0, 0x1Cu);
    }
    else
    {
      _ECX = 1;
      v5 = __readgsdword(0xCu) == 0;
      if ( !v5 )
        __asm { lock }
      __asm { cmpxchg ds:(lock_2 - 80CE000h)[ebx], ecx }
      if ( !v5 )
        _lll_lock_wait_private(0, &lock_2, (int)a1, (int *)a2);
      if ( (_printf_modifier_table || (_printf_modifier_table = (int)calloc((int *)a2, 0xFFu, 4u)) != 0)
        && (v3 -= a2, (a1 = malloc((const struct timespec *)(v3 + 8))) != 0) )
      {
        v3 >>= 2;
        v6 = next_bit;
        *a1 = *(_DWORD *)(_printf_modifier_table + 4 * *(unsigned __int8 *)a2);
        next_bit = v6 + 1;
        a1[1] = 1 << v6;
        wmemcpy((_BYTE *)a1 + 8, (_BYTE *)(a2 + 4), v3);
        *(_DWORD *)(_printf_modifier_table + 4 * *(unsigned __int8 *)a2) = a1;
        v7 = a1[1];
      }
      else
      {
        v7 = -1;
      }
      if ( __readgsdword(0xCu) )
        __asm { lock }
      if ( --lock_2 )
        _lll_unlock_wake_private(&lock_2, (int)a1, (int *)a2, (const struct timespec *)v3);
    }
    return v7;
  }
}
// 807C5F3: variable 'v7' is possibly undefined
// 80CE000: using guessed type _TBYTE GLOBAL_OFFSET_TABLE_;
// 80CFA24: using guessed type int next_bit;
// 80CFA28: using guessed type int lock_2;
// 80CFFD8: using guessed type int _printf_modifier_table;

//----- (0807C660) --------------------------------------------------------
int __cdecl _handle_registered_modifier_mb(unsigned __int8 **a1, int a2)
{
  unsigned __int8 *v2; // ebx
  _DWORD *v3; // esi
  int v4; // edi
  unsigned __int8 *v5; // ebp
  _DWORD *v6; // ebx
  int v7; // edx
  unsigned __int8 *v8; // ecx
  int v9; // eax
  int v10; // eax
  int result; // eax
  _BYTE v12[5]; // [esp+1h] [ebp-21h]
  int v13; // [esp+Ah] [ebp-18h]
  unsigned __int8 *v14; // [esp+Eh] [ebp-14h]

  v2 = *a1;
  v3 = *(_DWORD **)(_printf_modifier_table + 4 * **a1);
  if ( !v3 )
    return 1;
  v4 = v2[1];
  v14 = 0;
  v5 = v2 + 1;
  v12[4] = 0;
  v13 = 0;
  *(_DWORD *)v12 = v4;
  do
  {
    v6 = v3 + 2;
    v7 = v3[2];
    if ( (_BYTE)v4 )
    {
      if ( !v7 )
      {
        v8 = v5;
        v10 = 1;
        goto LABEL_12;
      }
      if ( v7 != v4 )
        goto LABEL_14;
      v8 = v5;
      while ( 1 )
      {
        v9 = *++v8;
        v7 = *++v6;
        if ( !(_BYTE)v9 )
          break;
        if ( !v7 )
          goto LABEL_11;
        if ( v9 != v7 )
          goto LABEL_14;
      }
    }
    else
    {
      v8 = v5;
    }
    if ( v7 )
      goto LABEL_14;
LABEL_11:
    v10 = v8 - *a1;
LABEL_12:
    if ( v10 > *(int *)&v12[1] )
    {
      v14 = v8;
      *(_DWORD *)&v12[1] = v10;
      v13 = v3[1];
    }
LABEL_14:
    v3 = (_DWORD *)*v3;
  }
  while ( v3 );
  result = 1;
  if ( v13 )
  {
    *(_WORD *)(a2 + 14) |= v13;
    *a1 = v14;
    return 0;
  }
  return result;
}
// 80CFFD8: using guessed type int _printf_modifier_table;

//----- (0807C770) --------------------------------------------------------
int __cdecl _handle_registered_modifier_wc(_DWORD *a1, int a2)
{
  int v2; // ebp
  _DWORD *v3; // esi
  int v4; // edi
  _DWORD *v5; // ebp
  _DWORD *v6; // ecx
  int v7; // eax
  _DWORD *v8; // edx
  int v9; // eax
  int result; // eax
  int v11; // [esp+0h] [ebp-20h]
  int v12; // [esp+8h] [ebp-18h]
  _DWORD *v13; // [esp+Ch] [ebp-14h]

  v2 = *a1;
  v3 = *(_DWORD **)(_printf_modifier_table + 4 * *(_DWORD *)*a1);
  if ( !v3 )
    return 1;
  v13 = 0;
  v4 = *(_DWORD *)(v2 + 4);
  v11 = 0;
  v12 = 0;
  v5 = (_DWORD *)(v2 + 4);
  do
  {
    v6 = v3 + 2;
    v7 = v3[2];
    if ( v4 )
    {
      if ( !v7 )
      {
        v8 = v5;
        v9 = 1;
        goto LABEL_12;
      }
      if ( v4 != v7 )
        goto LABEL_14;
      v8 = v5;
      while ( 1 )
      {
        ++v8;
        v7 = *++v6;
        if ( !*v8 )
          break;
        if ( !v7 )
          goto LABEL_11;
        if ( v7 != *v8 )
          goto LABEL_14;
      }
    }
    else
    {
      v8 = v5;
    }
    if ( v7 )
      goto LABEL_14;
LABEL_11:
    v9 = ((int)v8 - *a1) >> 2;
LABEL_12:
    if ( v11 < v9 )
    {
      v13 = v8;
      v11 = v9;
      v12 = v3[1];
    }
LABEL_14:
    v3 = (_DWORD *)*v3;
  }
  while ( v3 );
  result = 1;
  if ( v12 )
  {
    *(_WORD *)(a2 + 14) |= v12;
    *a1 = v13;
    return 0;
  }
  return result;
}
// 80CFFD8: using guessed type int _printf_modifier_table;

//----- (0807C870) --------------------------------------------------------
int __usercall register_printf_type@<eax>(int a1@<ebp>, int *a2@<edi>, const struct timespec *a3@<esi>, int a4)
{
  bool v6; // zf
  int v7; // edx

  _ECX = 1;
  _EBX = &GLOBAL_OFFSET_TABLE_;
  v6 = __readgsdword(0xCu) == 0;
  if ( !v6 )
    __asm { lock }
  __asm { cmpxchg ds:(lock_3 - 80CE000h)[ebx], ecx }
  if ( !v6 )
    _lll_lock_wait_private(0, &lock_3, a1, a2);
  if ( _printf_va_arg_table || (_printf_va_arg_table = (int)calloc(a2, 0xF8u, 4u)) != 0 )
  {
    v7 = pa_next_type;
    if ( pa_next_type == 256 )
    {
      v7 = -1;
      __writegsdword(0xFFFFFFE0, 0x1Cu);
    }
    else
    {
      ++pa_next_type;
      *(_DWORD *)(_printf_va_arg_table + 4 * v7 - 32) = a4;
    }
  }
  else
  {
    v7 = -1;
  }
  if ( __readgsdword(0xCu) )
    __asm { lock }
  if ( --lock_3 )
    _lll_unlock_wake_private(&lock_3, a1, a2, a3);
  return v7;
}
// 807C8FA: variable 'v7' is possibly undefined
// 80CE000: using guessed type _TBYTE GLOBAL_OFFSET_TABLE_;
// 80CEED8: using guessed type int pa_next_type;
// 80CFA2C: using guessed type int lock_3;
// 80CFFEC: using guessed type int _printf_va_arg_table;

//----- (0807C940) --------------------------------------------------------
void __usercall fprintf(int a1@<ebx>, int a2@<esi>, int a3, unsigned int *a4, ...)
{
  va_list va; // [esp+18h] [ebp+Ch] BYREF

  va_start(va, a4);
  vfprintf(a1, a2, a3, a4, (int)va);
}

//----- (0807C960) --------------------------------------------------------
int __usercall read_int_0@<eax>(_DWORD *a1@<eax>)
{
  _DWORD *v1; // ecx
  _DWORD *v2; // ebx
  unsigned int v3; // esi
  int v4; // edx
  int v5; // edx
  _DWORD *v7; // ebx

  v1 = (_DWORD *)(*a1 + 4);
  v2 = v1;
  v3 = *v1 - 48;
  v4 = *(_DWORD *)*a1 - 48;
  if ( v3 > 9 )
  {
LABEL_7:
    *a1 = v2;
    return v4;
  }
  while ( 1 )
  {
    if ( v4 < 0 )
      goto LABEL_6;
    if ( v4 <= 214748364 )
    {
      v5 = 10 * v4;
      if ( (int)(0x7FFFFFFF - v3) >= v5 )
      {
        v4 = v3 + v5;
        goto LABEL_6;
      }
    }
    v7 = v2 + 1;
    if ( (unsigned int)(*v7 - 48) > 9 )
      break;
    v1 += 2;
    v4 = -1;
    if ( (unsigned int)(*v1 - 48) > 9 )
    {
      *a1 = v1;
      return -1;
    }
LABEL_6:
    v2 = ++v1;
    v3 = *v1 - 48;
    if ( v3 > 9 )
      goto LABEL_7;
  }
  *a1 = v7;
  return -1;
}

//----- (0807CA00) --------------------------------------------------------
_BYTE *__usercall group_number_0@<eax>(_BYTE *a1@<eax>, _BYTE *a2@<edx>, _BYTE *a3@<ecx>, char *a4, int a5)
{
  _BYTE *v6; // edi
  int v7; // ebx
  _BYTE *v9; // esi
  char *v10; // ecx
  unsigned int v11; // esi
  int v12; // ebx
  _BYTE *v13; // [esp+Ch] [ebp-20h]

  v6 = a3;
  v7 = *a4;
  if ( (unsigned __int8)(v7 - 1) <= 0x7Du )
  {
    v9 = &a1[a3 - a2];
    memmove(a1, a2, a3 - a2);
    a2 = v6;
    v10 = a4 + 1;
    if ( a1 < v9 )
    {
      v11 = (unsigned int)(v9 - 4);
      a2 = v6 - 4;
      *((_DWORD *)v6 - 1) = *(_DWORD *)v11;
      v12 = v7 - 1;
      if ( v12 )
        goto LABEL_13;
      while ( (unsigned int)a1 < v11 )
      {
        if ( (_BYTE *)v11 == a2
          || (a2 = v6 - 8, *((_DWORD *)v6 - 2) = a5, v12 = *v10, (_BYTE)v12 == 127)
          || (v12 & 0x80u) != 0 )
        {
          v13 = a2;
          memmove(a2, (_BYTE *)v11, (unsigned int)&a1[-v11]);
          return v13;
        }
        if ( (_BYTE)v12 )
          ++v10;
        else
          v12 = *(v10 - 1);
        for ( v6 -= 8; ; v6 = a2 )
        {
          v11 -= 4;
          a2 = v6 - 4;
          *((_DWORD *)v6 - 1) = *(_DWORD *)v11;
          if ( !--v12 )
            break;
LABEL_13:
          if ( (unsigned int)a1 >= v11 )
            return a2;
        }
      }
    }
  }
  return a2;
}

//----- (0807CAE0) --------------------------------------------------------
_BYTE *__usercall i18n_number_rewrite_1@<eax>(_BYTE *a1@<eax>, int a2@<edx>, _BYTE *a3@<ecx>)
{
  int *v4; // edi
  _WORD *v6; // eax
  int v7; // edx
  bool v8; // zf
  unsigned int v9; // edx
  _BYTE *v10; // [esp+0h] [ebp-454h]
  unsigned int v11; // [esp+4h] [ebp-450h]
  unsigned int v12; // [esp+8h] [ebp-44Ch]
  _DWORD *i; // [esp+14h] [ebp-440h]
  _BYTE *v16[4]; // [esp+1Ch] [ebp-438h] BYREF
  char v17[1036]; // [esp+2Ch] [ebp-428h] BYREF
  unsigned int v18; // [esp+438h] [ebp-1Ch]
  int savedregs; // [esp+454h] [ebp+0h] BYREF

  v18 = __readgsdword(0x14u);
  v4 = (int *)wctrans("to_outpunct");
  v12 = towctrans(0x2Eu, v4);
  v11 = towctrans(0x2Cu, v4);
  v16[0] = v17;
  v16[1] = (_BYTE *)1024;
  if ( (unsigned __int8)_libc_scratch_buffer_set_array_size((int *)v16, (a2 - (int)a1) >> 2, 4) )
  {
    v10 = v16[0];
    v6 = mempcpy(v16[0], a1, a2 - (_DWORD)a1);
    a1 = a3;
    for ( i = (_DWORD *)__readgsdword(0xFFFFFFD0); ; *(_DWORD *)a1 = *(_DWORD *)(*i + 4 * v7 + 48) )
    {
      v6 -= 2;
      if ( v10 > (_BYTE *)v6 )
        break;
      while ( 1 )
      {
        v7 = *(_DWORD *)v6;
        a1 -= 4;
        if ( (unsigned int)(*(_DWORD *)v6 - 48) <= 9 )
          break;
        if ( v4 && (v7 & 0xFFFFFFFD) == 44 )
        {
          v8 = v7 == 46;
          v9 = v12;
          if ( !v8 )
            v9 = v11;
          *(_DWORD *)a1 = v9;
        }
        else
        {
          *(_DWORD *)a1 = v7;
        }
        v6 -= 2;
        if ( v10 > (_BYTE *)v6 )
          goto LABEL_9;
      }
    }
LABEL_9:
    if ( v16[0] != v17 )
      free((int)&savedregs, v4, (int)v16[0]);
  }
  return a1;
}

//----- (0807CC80) --------------------------------------------------------
int __cdecl IO_helper_overflow_0(_DWORD *a1, int a2)
{
  _DWORD *v2; // edx
  _DWORD *v3; // esi
  int *v4; // ebx
  int v5; // edx
  int *v6; // eax
  int v7; // esi
  int v8; // eax
  int v9; // ebx
  int *v10; // eax
  int result; // eax
  int v12; // [esp+0h] [ebp-24h]
  int v13; // [esp+4h] [ebp-20h]

  v2 = (_DWORD *)a1[22];
  v3 = (_DWORD *)v2[4];
  v4 = (int *)v2[3];
  if ( v3 != v4 )
  {
    v5 = a1[83];
    v12 = *(_DWORD *)(v5 + 148);
    v6 = v4;
    if ( (char *)&_start___libc_atexit - (char *)_start___libc_IO_vtables <= (unsigned int)(v12
                                                                                          - (_DWORD)_start___libc_IO_vtables) )
    {
      v13 = a1[83];
      IO_vtable_check();
      v5 = v13;
      v6 = *(int **)(a1[22] + 12);
    }
    v7 = v3 - v4;
    v8 = (*(int (__cdecl **)(int, int *, int))(v12 + 28))(v5, v6, v7);
    if ( (unsigned int)(v8 - 1) > 0xFFFFFFFD )
      return -1;
    v9 = 4 * v8;
    wmemmove(*(_BYTE **)(a1[22] + 12), (_BYTE *)(*(_DWORD *)(a1[22] + 12) + 4 * v8), v7 - v8);
    v2 = (_DWORD *)a1[22];
    v10 = (int *)(v2[4] - v9);
    v2[4] = v10;
    v4 = v10;
  }
  if ( v2[5] <= (unsigned int)v4 )
    return _woverflow(a1, a2);
  v2[4] = v4 + 1;
  result = a2;
  *v4 = a2;
  return result;
}
// 80CEFA0: using guessed type int _start___libc_IO_vtables[24];
// 80CF2F4: using guessed type int (*_start___libc_atexit)();

//----- (0807CD80) --------------------------------------------------------
unsigned int __usercall printf_positional_0@<eax>(
        int *a1@<eax>,
        _DWORD *a2@<edx>,
        int a3@<ecx>,
        int a4,
        int a5,
        int a6,
        unsigned int a7,
        unsigned int a8,
        int *a9,
        _BYTE *a10,
        signed int a11,
        char *a12,
        int a13)
{
  int v13; // edi
  unsigned int v14; // ebx
  int *v15; // esi
  int v16; // edx
  int v17; // esi
  int v18; // eax
  unsigned int v19; // ecx
  int v20; // ebx
  int v21; // edi
  unsigned int v22; // esi
  int v23; // ecx
  int v24; // eax
  int v25; // eax
  int v26; // eax
  int v27; // edx
  char **v28; // esi
  unsigned int v29; // ebx
  long double **v30; // edi
  int v31; // eax
  long double v32; // fst7
  int *v33; // esi
  unsigned __int8 v34; // al
  char v35; // dl
  char v36; // cl
  int v37; // edx
  int v38; // ecx
  int v39; // ecx
  int v40; // eax
  int v41; // eax
  const struct timespec *v42; // ebx
  __int64 *v43; // edx
  int v44; // eax
  void *v45; // esp
  int v46; // eax
  int v47; // ecx
  int v48; // edx
  int v49; // ebx
  __int16 v50; // bx
  __int64 v51; // xmm1_8
  long double *v52; // eax
  long double *v53; // eax
  char *v54; // edx
  char *v55; // eax
  int v56; // edx
  int v57; // eax
  int (__cdecl *v58)(int *, int *, unsigned int); // edx
  int v59; // ebx
  int v60; // eax
  _BYTE *v61; // ecx
  int v62; // ecx
  void *v63; // esp
  char **v64; // ecx
  char ***v65; // edx
  char ***v66; // eax
  int v67; // eax
  unsigned int v68; // esi
  int v70; // eax
  int v71; // esi
  char v72; // al
  int v73; // ebx
  unsigned int v74; // ecx
  char *v75; // ecx
  int v76; // eax
  char **v77; // edx
  unsigned int v78; // ecx
  unsigned int *v79; // edx
  int v80; // ebx
  _BOOL4 v81; // eax
  _BYTE *v82; // edx
  int v83; // eax
  void *v84; // esp
  int *v85; // edx
  int v86; // eax
  _BYTE *v87; // edx
  unsigned __int8 *v88; // eax
  int v89; // eax
  _DWORD *v90; // edx
  unsigned int v91; // ecx
  char v92; // al
  char *v93; // ebx
  _BYTE *v94; // ebx
  _BYTE *v95; // eax
  int v96; // ebx
  int v97; // ebx
  int v98; // eax
  int v99; // edx
  unsigned int *v100; // eax
  unsigned __int64 v101; // rax
  _BYTE *v102; // ebx
  unsigned int *v103; // eax
  unsigned int v104; // ecx
  _BYTE *v105; // eax
  _BYTE *v106; // ebx
  int v107; // edi
  int v108; // eax
  int v109; // ecx
  int v110; // eax
  _DWORD *v111; // edx
  int v112; // eax
  _DWORD *v113; // ebx
  _DWORD *v114; // edx
  int v115; // ebx
  char *v116; // eax
  int v117; // eax
  _DWORD *v118; // edx
  int v119; // eax
  _DWORD *v120; // ecx
  _DWORD *v121; // edx
  int v122; // edx
  int v123; // ebx
  int v124; // eax
  int v125; // eax
  _BYTE *v126; // eax
  bool v127; // sf
  int v128; // edi
  int v129; // ecx
  _BYTE *v130; // eax
  int v131; // eax
  _DWORD *v132; // edx
  int v133; // eax
  int v134; // eax
  int v135; // edx
  int *v136; // ecx
  int v137; // eax
  _DWORD *v138; // edx
  _BYTE *v139; // eax
  unsigned int v140; // edx
  unsigned int v141; // eax
  int v142; // ebx
  int v143; // edi
  int v144; // ebx
  void *v145; // esp
  char ***v146; // eax
  char ***v147; // ecx
  char **v148; // edx
  int v149; // eax
  _DWORD *v150; // edx
  unsigned int v151; // ebx
  _DWORD *v152; // ecx
  char v153; // dl
  int v154; // eax
  _DWORD *v155; // edx
  int v156; // eax
  _DWORD *v157; // edx
  int v158; // eax
  _DWORD *v159; // edx
  unsigned int v160; // ecx
  char **v161; // ebx
  int v162; // esi
  int *v163; // edx
  int v164; // eax
  int v165; // eax
  bool v166; // zf
  int v167; // ebx
  _BYTE *v168; // edx
  int v169; // eax
  _BYTE *v170; // eax
  int v171; // ebx
  int v172; // eax
  _DWORD *v173; // edx
  int v174; // edi
  int v175; // eax
  unsigned int v176; // ecx
  int v177; // eax
  _DWORD *v178; // edx
  char **v179; // ebx
  int v180; // esi
  int *v181; // edx
  int v182; // eax
  _BYTE *v183; // eax
  _BYTE *v184; // edi
  int v185; // eax
  _DWORD *v186; // edx
  int v187; // edx
  __int64 *v188; // eax
  int v189; // eax
  void *v190; // esp
  int v191; // eax
  int v192; // edx
  int *v193; // ecx
  _DWORD *v194; // edx
  int v195; // eax
  _DWORD *v196; // edx
  int v197; // eax
  _DWORD *v198; // edx
  int v199; // eax
  int v200; // eax
  int v201; // eax
  int v202; // eax
  int v203; // eax
  int v204; // eax
  _TBYTE *v205; // esi
  _TBYTE *v206; // esi
  char *v207; // [esp-2004h] [ebp-294Ch]
  _BYTE v208[4084]; // [esp-2000h] [ebp-2948h] BYREF
  int v209; // [esp-100Ch] [ebp-1954h]
  int v210; // [esp-1008h] [ebp-1950h]
  char *v211; // [esp-1004h] [ebp-194Ch]
  _BYTE v212[4080]; // [esp-1000h] [ebp-1948h] BYREF
  int v213; // [esp-10h] [ebp-958h]
  unsigned int v214; // [esp-8h] [ebp-950h]
  __int64 v215; // [esp+0h] [ebp-948h] BYREF
  unsigned int v216; // [esp+Ch] [ebp-93Ch]
  int v217; // [esp+10h] [ebp-938h]
  unsigned int v218; // [esp+14h] [ebp-934h]
  int *v219; // [esp+18h] [ebp-930h]
  unsigned int v220; // [esp+1Ch] [ebp-92Ch]
  int *v221; // [esp+20h] [ebp-928h]
  unsigned int v222; // [esp+24h] [ebp-924h]
  int *v223; // [esp+28h] [ebp-920h]
  unsigned int v224; // [esp+2Ch] [ebp-91Ch]
  unsigned __int64 v225; // [esp+30h] [ebp-918h]
  int *v226; // [esp+38h] [ebp-910h]
  int *v227; // [esp+3Ch] [ebp-90Ch]
  _BYTE *v228; // [esp+40h] [ebp-908h]
  unsigned int v229; // [esp+44h] [ebp-904h]
  int v230; // [esp+48h] [ebp-900h]
  unsigned int v231; // [esp+4Ch] [ebp-8FCh]
  unsigned int v232; // [esp+50h] [ebp-8F8h]
  int *v233; // [esp+54h] [ebp-8F4h]
  _BYTE *v234; // [esp+58h] [ebp-8F0h]
  _DWORD *v235; // [esp+5Ch] [ebp-8ECh]
  unsigned int v236; // [esp+60h] [ebp-8E8h]
  signed int v237; // [esp+64h] [ebp-8E4h]
  int v238; // [esp+68h] [ebp-8E0h]
  int v239; // [esp+6Ch] [ebp-8DCh]
  bool v240; // [esp+72h] [ebp-8D6h]
  char v241; // [esp+73h] [ebp-8D5h]
  _BOOL4 v242; // [esp+74h] [ebp-8D4h]
  int v243; // [esp+78h] [ebp-8D0h]
  unsigned int v244; // [esp+7Ch] [ebp-8CCh]
  _BYTE *v245; // [esp+80h] [ebp-8C8h]
  int v246; // [esp+84h] [ebp-8C4h]
  _BYTE *v247; // [esp+88h] [ebp-8C0h]
  char *v248; // [esp+8Ch] [ebp-8BCh]
  char *v249; // [esp+90h] [ebp-8B8h]
  int v250; // [esp+94h] [ebp-8B4h]
  char *v251; // [esp+98h] [ebp-8B0h]
  unsigned int v252; // [esp+9Ch] [ebp-8ACh]
  char **v253; // [esp+A0h] [ebp-8A8h]
  unsigned int v254; // [esp+A4h] [ebp-8A4h]
  int *v255; // [esp+A8h] [ebp-8A0h]
  _TBYTE *v256; // [esp+ACh] [ebp-89Ch]
  unsigned int v257; // [esp+B0h] [ebp-898h]
  int v258; // [esp+B4h] [ebp-894h]
  int v259; // [esp+B8h] [ebp-890h]
  unsigned int v260; // [esp+BCh] [ebp-88Ch]
  unsigned int v261; // [esp+C4h] [ebp-884h] BYREF
  const __m128i *v262; // [esp+C8h] [ebp-880h] BYREF
  unsigned int *v263; // [esp+CCh] [ebp-87Ch] BYREF
  int v264[12]; // [esp+D0h] [ebp-878h] BYREF
  char *v265; // [esp+100h] [ebp-848h] BYREF
  unsigned int v266; // [esp+104h] [ebp-844h]
  char v267[1024]; // [esp+110h] [ebp-838h] BYREF
  int v268[4]; // [esp+510h] [ebp-438h] BYREF
  char v269[1036]; // [esp+520h] [ebp-428h] BYREF
  unsigned int v270; // [esp+92Ch] [ebp-1Ch]
  int savedregs; // [esp+948h] [ebp+0h] BYREF

  v255 = a1;
  v238 = a3;
  v250 = a6;
  v256 = &GLOBAL_OFFSET_TABLE_;
  v254 = a7;
  v235 = a2;
  v252 = a8;
  v245 = a10;
  v237 = a11;
  v249 = a12;
  v246 = a13;
  v270 = __readgsdword(0x14u);
  v266 = 1024;
  v251 = v267;
  v265 = v267;
  v248 = v269;
  v268[0] = (int)v269;
  v268[1] = 1024;
  v261 = 0;
  if ( a12 == (char *)-1 )
  {
    v70 = *(_DWORD *)__readgsdword(0xFFFFFFDC);
    v71 = *(_DWORD *)(v70 + 52);
    v249 = *(char **)(v70 + 44);
    v72 = *v249;
    v246 = v71;
    if ( !v72 || v72 == 127 )
      v249 = 0;
  }
  v13 = *a9;
  if ( *a9 )
  {
    v13 = 0;
    v14 = 0;
    v15 = a9;
    v258 = 19;
    v259 = (int)v251;
    *(float *)&v257 = COERCE_FLOAT(&v261);
    v253 = &v265;
    while ( 1 )
    {
      v16 = v259 + 52 * v13++;
      v260 = v16;
      v14 += _parse_one_specwc(v15, v14, v16, (unsigned int *)v257);
      v15 = *(int **)(v260 + 24);
      if ( !*v15 )
        break;
      if ( v258 == v13 )
      {
        if ( !(unsigned __int8)_libc_scratch_buffer_grow_preserve((int)v253) )
          goto LABEL_91;
        v259 = (int)v265;
        v258 = v266 / 0x34;
      }
    }
    if ( v261 >= v14 )
      v14 = v261;
    v260 = v14;
  }
  else
  {
    v260 = 0;
    v259 = (int)v251;
  }
  if ( !(unsigned __int8)_libc_scratch_buffer_set_array_size(v268, v260, 20) )
    goto LABEL_91;
  v17 = v268[0] + 12 * v260;
  v253 = (char **)v268[0];
  v214 = 4 * v260;
  v257 = v17 + 4 * v260;
  v18 = v255[15];
  v258 = v17;
  memset((unsigned __int8 *)(v17 + v214), v18 << 29 >> 31, v214);
  v19 = v257;
  if ( !v13 )
  {
    if ( v260 )
      goto LABEL_24;
    goto LABEL_174;
  }
  v247 = (_BYTE *)v13;
  v20 = v259;
  v21 = v259 + 52 * v13;
  v22 = v257;
  do
  {
    while ( 1 )
    {
      v24 = *(_DWORD *)(v20 + 32);
      if ( v24 != -1 )
        *(_DWORD *)(v22 + 4 * v24) = 0;
      v25 = *(_DWORD *)(v20 + 28);
      if ( v25 != -1 )
        *(_DWORD *)(v22 + 4 * v25) = 0;
      v26 = *(_DWORD *)(v20 + 44);
      if ( !v26 )
        goto LABEL_15;
      if ( v26 != 1 )
        break;
      v23 = v258;
      *(_DWORD *)(v22 + 4 * *(_DWORD *)(v20 + 36)) = *(_DWORD *)(v20 + 40);
      *(_DWORD *)(v23 + 4 * *(_DWORD *)(v20 + 36)) = *(_DWORD *)(v20 + 48);
LABEL_15:
      v20 += 52;
      if ( v21 == v20 )
        goto LABEL_23;
    }
    v27 = 4 * *(_DWORD *)(v20 + 36);
    v257 = *(unsigned int *)(v20 + 8);
    v213 = v20;
    v20 += 52;
    (*(void (__cdecl **)(int, int, unsigned int, int))(*((_DWORD *)v256 + 2042) + 4 * v257))(
      v213,
      v26,
      v22 + v27,
      v27 + v258);
  }
  while ( v21 != v20 );
LABEL_23:
  v13 = (int)v247;
  v19 = v22;
  if ( !v260 )
    goto LABEL_40;
LABEL_24:
  v247 = (_BYTE *)v13;
  v28 = v253;
  v29 = 0;
  v30 = (long double **)v250;
  *(float *)&v257 = 0.0;
  while ( 2 )
  {
    v31 = *(_DWORD *)(v19 + 4 * v29);
    if ( v31 > 5 )
    {
      if ( v31 == 256 )
      {
        v53 = *v30;
        *v30 = (long double *)((char *)*v30 + 8);
        v54 = (char *)*((_DWORD *)v53 + 1);
        v55 = *(char **)v53;
        v28[1] = v54;
        *v28 = v55;
      }
      else if ( v31 <= 256 )
      {
        if ( v31 > 7 )
          goto LABEL_66;
        v51 = *(_QWORD *)*v30;
        *v30 = (long double *)((char *)*v30 + 8);
        *(_QWORD *)v28 = v51;
      }
      else
      {
        if ( v31 == 512 || v31 == 1024 )
          goto LABEL_67;
        if ( v31 != 263 )
          goto LABEL_66;
        v32 = *(*v30)++;
        *(long double *)v28 = v32;
      }
    }
    else
    {
      if ( v31 >= 3 || v31 > 1 || v31 >= 0 )
        goto LABEL_67;
      if ( v31 == -1 )
      {
        if ( (v255[15] & 4) != 0 )
          _libc_fatal((_BYTE)v256 + 32);
        _assert_fail(
          (int)&aSFlags2IoFlags[(_DWORD)v256 - 135061504],
          (int)&aVfprintfC[(_DWORD)v256 - 135061504],
          1887,
          (int)&_PRETTY_FUNCTION___13739[(_DWORD)v256 - 135061504]);
      }
LABEL_66:
      if ( (v31 & 0x800) != 0 )
      {
LABEL_67:
        v52 = *v30;
        *v30 = (long double *)((char *)*v30 + 4);
        *v28 = *(char **)v52;
      }
      else
      {
        v56 = *((_DWORD *)v256 + 2043);
        v250 = v56;
        if ( v56 && *(_DWORD *)(v56 + 4 * v31 - 32) )
        {
          v187 = *(_DWORD *)(v258 + 4 * v29) + 27;
          v244 = v187 & 0xFFFFFFF0;
          v188 = (__int64 *)((char *)&v215 - (v187 & 0xFFFFF000));
          if ( &v215 != v188 )
          {
            while ( v212 != (_BYTE *)v188 )
              ;
          }
          v189 = v244 & 0xFFF;
          if ( (v244 & 0xFFF) != 0 )
          {
            v190 = alloca(v189);
            *(_DWORD *)&v212[v189 - 4] = *(_DWORD *)&v212[v189 - 4];
          }
          v244 = v19;
          *v28 = v212;
          (*(void (__cdecl **)(_BYTE *, long double **))(v250 + 4 * *(_DWORD *)(v19 + 4 * v29) - 32))(v212, v30);
          v19 = v244;
        }
        else
        {
          *(long double *)v28 = *(float *)&v257;
        }
      }
    }
    ++v29;
    v28 += 3;
    if ( v29 < v260 )
      continue;
    break;
  }
  v13 = (int)v247;
LABEL_40:
  if ( v13 <= v252 )
  {
LABEL_174:
    v68 = v254;
    goto LABEL_92;
  }
  v229 = v13;
  v228 = v245 + 1000;
  v33 = (int *)(52 * v252 + v259);
  v221 = _start___libc_IO_vtables;
  v220 = (char *)&_start___libc_atexit - (char *)_start___libc_IO_vtables;
  v219 = _start___libc_IO_vtables;
  v218 = (char *)&_start___libc_atexit - (char *)_start___libc_IO_vtables;
  v226 = _start___libc_IO_vtables;
  v224 = (char *)&_start___libc_atexit - (char *)_start___libc_IO_vtables;
  v223 = _start___libc_IO_vtables;
  v222 = (char *)&_start___libc_atexit - (char *)_start___libc_IO_vtables;
  v233 = _start___libc_IO_vtables;
  v232 = (char *)&_start___libc_atexit - (char *)_start___libc_IO_vtables;
  while ( 2 )
  {
    v34 = *((_BYTE *)v33 + 12);
    LOBYTE(v230) = (v34 & 8) != 0;
    v239 = (unsigned __int8)v230;
    v242 = (v34 & 0x10) != 0;
    v250 = (v34 & 0x20) != 0;
    v244 = (v34 & 0x40) != 0;
    LOBYTE(v243) = v34 >> 7;
    v257 = v34 & 1;
    v35 = *((_BYTE *)v33 + 13);
    v231 = (v34 & 2) != 0;
    v36 = v35;
    v240 = (v35 & 8) != 0;
    v37 = v33[8];
    v234 = (_BYTE *)((v36 & 2) != 0);
    v241 = *((_BYTE *)v33 + 16);
    v38 = v33[2];
    v236 = (v34 & 4) != 0;
    v13 = *v33;
    v259 = v38;
    if ( v37 == -1 )
    {
      v260 = v33[1];
    }
    else
    {
      v39 = (int)v253[3 * v37];
      v260 = v39;
      if ( v39 < 0 )
      {
        v260 = -v260;
        v74 = v260;
        *((_BYTE *)v33 + 12) = v34 | 0x20;
        v33[1] = v74;
        v250 = 1;
      }
      else
      {
        v33[1] = v39;
      }
    }
    v40 = v33[7];
    if ( v40 != -1 )
    {
      v13 = (int)v253[3 * v40];
      if ( v13 < 0 )
      {
        *v33 = -1;
        v13 = -1;
      }
      else
      {
        *v33 = v13;
      }
    }
    v41 = v260;
    if ( (int)v260 < v13 )
      v41 = v13;
    if ( v41 <= 218 )
    {
      v258 = 0;
      v247 = v228;
      goto LABEL_73;
    }
    v42 = (const struct timespec *)(4 * v41 + 128);
    if ( !_libc_alloca_cutoff((unsigned int)v42) && (unsigned int)v42 > 0x1000 )
    {
      v258 = (int)malloc(v42);
      if ( !v258 )
        goto LABEL_91;
      if ( (int)v260 >= v13 )
        v204 = 4 * v260 + 128;
      else
        v204 = 4 * v13 + 128;
      v247 = (_BYTE *)(v258 + v204);
LABEL_73:
      v47 = v259;
      if ( v259 > 255 )
        goto LABEL_100;
      goto LABEL_74;
    }
    v43 = (__int64 *)((char *)&v215 - (((unsigned int)&v42[3].tv_sec + 3) & 0xFFFFF000));
    if ( &v215 != v43 )
    {
      while ( v212 != (_BYTE *)v43 )
        ;
    }
    v44 = ((_WORD)v42 + 27) & 0xFF0;
    if ( (((_WORD)v42 + 27) & 0xFF0) != 0 )
    {
      v45 = alloca(v44);
      *(_DWORD *)&v212[v44 - 4] = *(_DWORD *)&v212[v44 - 4];
    }
    if ( (int)v260 >= v13 )
      v46 = 4 * v260 + 128;
    else
      v46 = 4 * v13 + 128;
    v47 = v259;
    v258 = 0;
    v247 = &v212[v46];
    if ( v259 > 255 )
      goto LABEL_100;
LABEL_74:
    v57 = *((_DWORD *)v256 + 2037);
    if ( v57 )
    {
      v58 = *(int (__cdecl **)(int *, int *, unsigned int))(v57 + 4 * v47);
      v59 = 4 * v47;
      if ( v58 )
      {
        v217 = v33[11];
        v227 = (int *)(4 * v217);
        v60 = 4 * v217 + 27;
        v216 = v60 & 0xFFFFFFF0;
        v61 = &v212[-(v60 & 0xFFFFF000)];
        if ( v212 != v61 )
        {
          while ( v208 != v61 )
            ;
        }
        v227 = (int *)(4 * v217);
        v62 = v216 & 0xFFF;
        if ( (v216 & 0xFFF) != 0 )
        {
          v63 = alloca(v62);
          *(_DWORD *)&v208[v62 - 4] = *(_DWORD *)&v208[v62 - 4];
        }
        v216 = (unsigned int)v208;
        if ( v217 )
        {
          v64 = &v253[3 * v33[9]];
          v65 = (char ***)v208;
          v66 = (char ***)&v208[(_DWORD)v227];
          do
          {
            *v65++ = v64;
            v64 += 3;
          }
          while ( v66 != v65 );
          v58 = *(int (__cdecl **)(int *, int *, unsigned int))(*((_DWORD *)v256 + 2037) + v59);
        }
        v67 = v58(v255, v33, v216);
        if ( v67 != -2 )
        {
          if ( v67 < 0 )
            goto LABEL_89;
          if ( v254 <= 0x7FFFFFFE )
          {
            if ( 0x7FFFFFFF - v254 < v67 )
              goto LABEL_88;
LABEL_165:
            v254 += v67;
            goto LABEL_166;
          }
          v205 = v256;
          v207 = &_PRETTY_FUNCTION___13739[(_DWORD)v256 - 135061504];
          goto LABEL_542;
        }
      }
    }
LABEL_100:
    v73 = (int)v256;
    switch ( v259 )
    {
      case '%':
        v89 = v255[22];
        if ( v89 && (v90 = *(_DWORD **)(v89 + 16), (unsigned int)v90 < *(_DWORD *)(v89 + 20)) )
        {
          *(_DWORD *)(v89 + 16) = v90 + 1;
          *v90 = 37;
        }
        else if ( _woverflow(v255, 37) == -1 )
        {
          goto LABEL_89;
        }
        if ( v254 == 0x7FFFFFFF )
          goto LABEL_89;
        ++v254;
        goto LABEL_166;
      case 'A':
      case 'a':
        v13 = (int)v253;
        v263 = (unsigned int *)&v253[3 * v33[9]];
        *((_BYTE *)v33 + 13) &= ~0x10u;
        v67 = _printf_fphex(v73, (int)&savedregs, v13, (int)v33, v255, (int)v33, (const __m128i **)&v263);
        if ( v67 >= 0 )
          goto LABEL_163;
        goto LABEL_89;
      case 'C':
        goto LABEL_105;
      case 'E':
      case 'F':
      case 'G':
      case 'e':
      case 'f':
      case 'g':
        v13 = (int)v253;
        v262 = (const __m128i *)&v253[3 * v33[9]];
        *((_BYTE *)v33 + 13) &= ~0x10u;
        v67 = _printf_fp(v73, (int)&savedregs, v13, (unsigned int)v33, v255, (int)v33, &v262);
        if ( v67 < 0 )
          goto LABEL_89;
LABEL_163:
        v13 = v254;
        if ( v254 > 0x7FFFFFFE )
          goto LABEL_541;
        if ( 0x7FFFFFFF - v254 >= v67 )
          goto LABEL_165;
        goto LABEL_88;
      case 'S':
      case 's':
        v79 = (unsigned int *)v253[3 * v33[9]];
        goto LABEL_122;
      case 'X':
      case 'x':
        v236 = 16;
        goto LABEL_178;
      case 'c':
        if ( v236 )
        {
LABEL_105:
          v13 = v260 - 1;
          LOBYTE(v260) = (int)(v260 - 1) > 0;
          if ( !v250 && (_BYTE)v260 )
          {
            if ( v13 != IO_wpadn((int)v255, 32, v13) )
              goto LABEL_89;
            if ( v254 > 0x7FFFFFFE )
              goto LABEL_546;
            if ( 0x7FFFFFFF - v254 < v13 )
              goto LABEL_88;
            v254 += v13;
          }
          v75 = v253[3 * v33[9]];
          v76 = v255[22];
          if ( v76 )
          {
            v77 = *(char ***)(v76 + 16);
            if ( (unsigned int)v77 < *(_DWORD *)(v76 + 20) )
            {
              *(_DWORD *)(v76 + 16) = v77 + 1;
              *v77 = v75;
              if ( v75 == (char *)-1 )
                goto LABEL_89;
              goto LABEL_114;
            }
          }
          v209 = (int)v253[3 * v33[9]];
          goto LABEL_473;
        }
        v13 = v260 - 1;
        LOBYTE(v260) = (int)(v260 - 1) > 0;
        if ( v250 || !(_BYTE)v260 )
          goto LABEL_304;
        if ( v13 != IO_wpadn((int)v255, 32, v13) )
          goto LABEL_89;
        if ( v254 > 0x7FFFFFFE )
        {
LABEL_546:
          v205 = v256;
          v211 = &_PRETTY_FUNCTION___13739[(_DWORD)v256 - 135061504];
          v210 = 2018;
          goto LABEL_542;
        }
        if ( 0x7FFFFFFF - v254 < v13 )
          goto LABEL_88;
        v254 += v13;
LABEL_304:
        v134 = btowc(LOBYTE(v253[3 * v33[9]]));
        v135 = v255[22];
        if ( v135 )
        {
          v136 = *(int **)(v135 + 16);
          if ( (unsigned int)v136 < *(_DWORD *)(v135 + 20) )
          {
            *(_DWORD *)(v135 + 16) = v136 + 1;
            *v136 = v134;
            if ( v134 == -1 )
              goto LABEL_89;
            goto LABEL_114;
          }
        }
        v209 = v134;
LABEL_473:
        if ( _woverflow(v255, v209) == -1 )
          goto LABEL_89;
LABEL_114:
        if ( v254 == 0x7FFFFFFF )
          goto LABEL_89;
        ++v254;
        if ( v250 && (_BYTE)v260 )
        {
          if ( v13 != IO_wpadn((int)v255, 32, v13) )
            goto LABEL_89;
          v78 = v254;
          if ( v254 > 0x7FFFFFFE )
            goto LABEL_546;
          if ( 0x7FFFFFFF - v254 < v13 )
            goto LABEL_88;
LABEL_233:
          v254 = v13 + v78;
        }
LABEL_166:
        if ( v258 )
          free((int)&savedregs, (int *)v13, v258);
        if ( (v254 & 0x80000000) != 0 )
        {
          v206 = v256;
          v211 = &_PRETTY_FUNCTION___13739[(_DWORD)v256 - 135061504];
          v210 = 2057;
LABEL_544:
          _assert_fail(
            (int)&aSizeTDoneSizeT[(_DWORD)v206 - 135061504],
            (int)&aVfprintfC[(_DWORD)v206 - 135061504],
            v210,
            (int)v211);
        }
        v97 = v255[37];
        if ( v232 <= v97 - (int)v233 )
          IO_vtable_check();
        v98 = (*(int (__cdecl **)(int *, int, int))(v97 + 28))(v255, v33[5], (v33[6] - v33[5]) >> 2);
        v99 = (v33[6] - v33[5]) >> 2;
        if ( v99 != v98 )
          goto LABEL_91;
        if ( v99 <= (int)(0x7FFFFFFF - v254) )
        {
          ++v252;
          v33 += 13;
          v254 += v99;
          if ( v252 >= v229 )
            goto LABEL_174;
          continue;
        }
        v68 = -1;
        __writegsdword(0xFFFFFFE0, 0x4Bu);
LABEL_92:
        if ( (char *)v268[0] != v248 )
          free((int)&savedregs, (int *)v13, v268[0]);
        if ( v265 != v251 )
          free((int)&savedregs, (int *)v13, (int)v265);
        return v68;
      case 'd':
      case 'i':
        v103 = (unsigned int *)&v253[3 * v33[9]];
        if ( *(float *)&v257 != 0.0 )
        {
          v140 = *v103;
          v236 = v103[1];
          v141 = v236;
          v257 = v236 >> 31;
          v142 = v236;
          v236 = 10;
          v215 = v142 >> 31;
          v225 = __PAIR64__((v142 >> 31) ^ v141, (v142 >> 31) ^ v140) - v142;
          goto LABEL_180;
        }
        if ( v234 )
        {
          v104 = *(char *)v103;
        }
        else if ( v231 )
        {
          v104 = *(__int16 *)v103;
        }
        else
        {
          v104 = *v103;
        }
        v236 = 10;
        v257 = v104 >> 31;
        v91 = abs32(v104);
        v231 = v91;
        goto LABEL_277;
      case 'm':
        v88 = strerror_r(v237, v245, 0x3E8u);
        v236 = 0;
        v79 = (unsigned int *)v88;
LABEL_122:
        if ( !v79 )
        {
          *(float *)&v257 = 0.0;
          if ( v13 == -1 || v13 > 5 )
          {
            v13 = 6;
            v87 = (char *)v256 - 114824;
          }
          else
          {
            v13 = 0;
            v87 = (char *)v256 - 114828;
          }
          goto LABEL_357;
        }
        if ( !v236 && v259 != 83 )
        {
          v263 = v79;
          if ( v13 == -1 )
            v13 = strlen(v79);
          else
            v13 = strnlen(v79, v13);
          if ( (unsigned int)v13 <= 0x3FFFFFFF )
          {
            v80 = 4 * v13;
            v81 = _libc_alloca_cutoff(4 * v13);
            if ( (unsigned int)(4 * v13) <= 0x1000 || v81 )
            {
              v82 = &v212[-((v80 + 27) & 0xFFFFF000)];
              if ( v212 != v82 )
              {
                while ( v208 != v82 )
                  ;
              }
              v83 = ((_WORD)v80 + 27) & 0xFF0;
              if ( (((_WORD)v80 + 27) & 0xFF0) != 0 )
              {
                v84 = alloca(v83);
                *(_DWORD *)&v208[v83 - 4] = *(_DWORD *)&v208[v83 - 4];
              }
              *(float *)&v257 = 0.0;
              v85 = (int *)v208;
            }
            else
            {
              v85 = malloc((const struct timespec *)(4 * v13));
              if ( !v85 )
                goto LABEL_89;
              v257 = 1;
            }
            v259 = (int)v85;
            v264[0] = 0;
            v264[1] = 0;
            v86 = mbsrtowcs((int)v85, &v263, v13, v264);
            v87 = (_BYTE *)v259;
            v13 = v86;
            if ( v86 == -1 )
              goto LABEL_89;
            goto LABEL_357;
          }
LABEL_88:
          __writegsdword(0xFFFFFFE0, 0x4Bu);
LABEL_89:
          if ( v258 )
            free((int)&savedregs, (int *)v13, v258);
LABEL_91:
          v68 = -1;
          goto LABEL_92;
        }
        if ( v13 != -1 )
          goto LABEL_356;
        v259 = (int)v79;
        v169 = wcslen(v79);
        v87 = (_BYTE *)v259;
        *(float *)&v257 = 0.0;
        v13 = v169;
        goto LABEL_357;
      case 'n':
        if ( (v255[15] & 4) != 0 )
        {
          if ( !v238 )
          {
            v201 = wcslen(v235);
            v238 = _readonly_area((unsigned int)v235, 4 * v201 + 4);
          }
          if ( v238 < 0 )
            _libc_fatal((_BYTE)v256 - 104);
        }
        v13 = (int)v253;
        v116 = v253[3 * v33[9]];
        if ( *(float *)&v257 == 0.0 )
        {
          if ( v234 )
          {
            *v116 = v254;
          }
          else if ( v231 )
          {
            v13 = (unsigned __int16)v254;
            *(_WORD *)v116 = v254;
          }
          else
          {
            v13 = v254;
            *(_DWORD *)v116 = v254;
          }
        }
        else
        {
          v143 = v254;
          *(_DWORD *)v116 = v254;
          v13 = v143 >> 31;
          *((_DWORD *)v116 + 1) = v13;
        }
        goto LABEL_166;
      case 'o':
        v236 = 8;
        goto LABEL_178;
      case 'p':
        v91 = (unsigned int)v253[3 * v33[9]];
        if ( !v91 )
        {
          if ( v13 < 5 )
            v13 = 5;
          v79 = (unsigned int *)((char *)v256 - 114848);
LABEL_356:
          v259 = (int)v79;
          v165 = wcsnlen(v79, v13);
          v87 = (_BYTE *)v259;
          *(float *)&v257 = 0.0;
          v13 = v165;
LABEL_357:
          v166 = v260 == v13;
          v259 = v260 - v13;
          if ( (int)(v260 - v13) < 0 )
          {
            if ( (v254 & 0x80000000) != 0 )
            {
LABEL_543:
              v206 = v256;
              v207 = &_PRETTY_FUNCTION___13739[(_DWORD)v256 - 135061504];
              goto LABEL_544;
            }
            v171 = v255[37];
            if ( v218 <= v171 - (int)v219 )
            {
              v260 = (unsigned int)v87;
              IO_vtable_check();
              v87 = (_BYTE *)v260;
            }
            if ( v13 != (*(int (__cdecl **)(int *, _BYTE *, int))(v171 + 28))(v255, v87, v13) )
              goto LABEL_89;
            v78 = v254;
            if ( 0x7FFFFFFF - v254 < v13 )
              goto LABEL_88;
            goto LABEL_233;
          }
          LOBYTE(v260) = v260 != v13;
          if ( !v250 && !v166 )
          {
            v247 = v87;
            v199 = IO_wpadn((int)v255, 32, v259);
            if ( v259 != v199 )
              goto LABEL_89;
            if ( v254 > 0x7FFFFFFE )
              goto LABEL_546;
            if ( 0x7FFFFFFF - v254 < v259 )
              goto LABEL_88;
            v87 = v247;
            v254 += v259;
          }
          if ( (v254 & 0x80000000) != 0 )
            goto LABEL_543;
          v167 = v255[37];
          if ( v220 <= v167 - (int)v221 )
          {
            v247 = v87;
            IO_vtable_check();
            v87 = v247;
          }
          v247 = v87;
          if ( v13 != (*(int (__cdecl **)(int *, _BYTE *, int))(v167 + 28))(v255, v87, v13) )
            goto LABEL_89;
          if ( 0x7FFFFFFF - v254 < v13 )
            goto LABEL_88;
          v168 = v247;
          v254 += v13;
          if ( v250 && (_BYTE)v260 )
          {
            v13 = v259;
            v250 = 0x7FFFFFFF;
            v260 = (unsigned int)v247;
            if ( v13 != IO_wpadn((int)v255, 32, v259) )
              goto LABEL_89;
            if ( v254 > 0x7FFFFFFE )
              goto LABEL_546;
            if ( v250 - v254 < v13 )
              goto LABEL_88;
            v168 = (_BYTE *)v260;
            v254 += v13;
          }
          v13 = v257;
          if ( *(float *)&v257 != 0.0 )
            free((int)&savedregs, (int *)v257, (int)v168);
          goto LABEL_166;
        }
        v231 = (unsigned int)v253[3 * v33[9]];
        if ( v13 < 0 )
        {
          v13 = 1;
          v239 = 1;
          v259 = 120;
          *(float *)&v257 = 0.0;
          v93 = (char *)v256 - 88256;
          LOBYTE(v243) = 0;
          goto LABEL_420;
        }
        v92 = 0;
        if ( v13 )
        {
          v259 = 120;
          *(float *)&v257 = 0.0;
          v236 = 16;
          v239 = 1;
LABEL_152:
          v241 = 32;
          LOBYTE(v243) = v92 & 1;
          goto LABEL_153;
        }
        *(float *)&v257 = 0.0;
        v259 = 120;
        v236 = 16;
        v239 = 1;
        goto LABEL_454;
      case 'u':
        v236 = 10;
LABEL_178:
        v100 = (unsigned int *)&v253[3 * v33[9]];
        if ( *(float *)&v257 == 0.0 )
        {
          if ( v234 )
          {
            v244 = 0;
            v91 = *(unsigned __int8 *)v100;
            v242 = 0;
            v231 = v91;
          }
          else
          {
            v244 = 0;
            if ( v231 )
              v91 = *(unsigned __int16 *)v100;
            else
              v91 = *v100;
            v242 = 0;
            v231 = v91;
          }
LABEL_277:
          v92 = v243;
          if ( v13 < 0 )
          {
            v13 = 1;
          }
          else
          {
            if ( v13 )
              goto LABEL_152;
            if ( !v91 )
            {
              if ( v236 == 8 && (_BYTE)v230 )
              {
                v243 = -1;
                v130 = v247;
                v239 = 1;
                *((_DWORD *)v247 - 1) = 48;
                v234 = v130 - 4;
                v96 = 4;
              }
              else
              {
                v96 = 0;
                v243 = 0;
                v234 = v247;
              }
              v241 = 32;
              goto LABEL_204;
            }
LABEL_454:
            v241 = 32;
            v13 = 0;
            LOBYTE(v243) = v92 & 1;
          }
LABEL_153:
          LOBYTE(v243) = v243 & (v249 != 0);
          v93 = (char *)v256 - 88416;
          if ( v259 != 88 )
            v93 = (char *)v256 - 88256;
          if ( v236 == 10 )
          {
            v230 = v13;
            v227 = v33;
            v184 = v247;
            while ( 1 )
            {
              v184 -= 4;
              *(_DWORD *)v184 = *(_DWORD *)&v93[4 * (v91 % 0xA)];
              if ( v91 <= 9 )
                break;
              v91 /= 0xAu;
            }
            v234 = v184;
            v33 = v227;
            v13 = v230;
            if ( !(_BYTE)v243 )
            {
LABEL_159:
              v94 = v247;
              if ( v236 == 10 && v240 )
              {
                v95 = i18n_number_rewrite_1(v234, (int)v247, v247);
                v236 = 10;
                v96 = v94 - v95;
                v234 = v95;
                v243 = v96 >> 2;
                goto LABEL_200;
              }
LABEL_378:
              v96 = v94 - v234;
              v243 = v96 >> 2;
LABEL_200:
              if ( v13 > v243 )
              {
LABEL_201:
                v107 = v13 - (v96 >> 2);
                v108 = 0;
                if ( v107 >= 0 )
                  v108 = v107;
                v243 = v107;
                v13 = v108;
                goto LABEL_204;
              }
              if ( v231 )
              {
                if ( v236 != 8 || !v239 )
                  goto LABEL_201;
                v236 = 8;
                v126 = v234 - 4;
                *(_DWORD *)v126 = 48;
                v234 = v126;
                v96 = v247 - v126;
                v128 = v13 - ((v247 - v126) >> 2);
                v127 = v128 < 0;
                v129 = v128;
                v243 = v128;
                v13 = 0;
                if ( !v127 )
                  v13 = v129;
              }
              else
              {
                v174 = v13 - (v96 >> 2);
                v127 = v174 < 0;
                v175 = v174;
                v243 = v174;
                v13 = 0;
                if ( !v127 )
                  v13 = v175;
              }
LABEL_204:
              if ( !v250 )
              {
                v250 = v96 >> 2;
                v109 = v260 - ((v96 >> 2) + v13);
                if ( v231 && v236 == 16 && v239 )
                  v109 -= 2;
                if ( v244 | v242 | v257 )
                {
                  --v109;
                  if ( v241 != 32 )
                    goto LABEL_211;
                  if ( v109 <= 0 )
                  {
                    v109 = 0;
                    goto LABEL_211;
                  }
                }
                else
                {
                  if ( v241 != 32 )
                    goto LABEL_217;
                  if ( v109 <= 0 )
                  {
                    v109 = 0;
                    goto LABEL_217;
                  }
                }
                v260 = v109;
                v133 = IO_wpadn((int)v255, 32, v109);
                if ( v260 != v133 )
                  goto LABEL_89;
                if ( v254 > 0x7FFFFFFE )
                  goto LABEL_541;
                if ( 0x7FFFFFFF - v254 < v260 )
                  goto LABEL_88;
                v109 = 0;
                v254 += v260;
LABEL_211:
                if ( *(float *)&v257 == 0.0 )
                {
                  if ( v244 )
                  {
                    v172 = v255[22];
                    if ( v172 )
                    {
                      v173 = *(_DWORD **)(v172 + 16);
                      if ( (unsigned int)v173 < *(_DWORD *)(v172 + 20) )
                      {
                        *(_DWORD *)(v172 + 16) = v173 + 1;
                        *v173 = 43;
                        goto LABEL_215;
                      }
                    }
                    v260 = v109;
                    v209 = 43;
                  }
                  else
                  {
                    if ( !v242 )
                      goto LABEL_217;
                    v197 = v255[22];
                    if ( v197 )
                    {
                      v198 = *(_DWORD **)(v197 + 16);
                      if ( (unsigned int)v198 < *(_DWORD *)(v197 + 20) )
                      {
                        *(_DWORD *)(v197 + 16) = v198 + 1;
                        *v198 = 32;
                        goto LABEL_215;
                      }
                    }
                    v260 = v109;
                    v209 = 32;
                  }
                }
                else
                {
                  v110 = v255[22];
                  if ( v110 )
                  {
                    v111 = *(_DWORD **)(v110 + 16);
                    if ( (unsigned int)v111 < *(_DWORD *)(v110 + 20) )
                    {
                      *(_DWORD *)(v110 + 16) = v111 + 1;
                      *v111 = 45;
LABEL_215:
                      if ( v254 == 0x7FFFFFFF )
                        goto LABEL_89;
                      ++v254;
LABEL_217:
                      if ( !v231 || v236 != 16 || !v239 )
                        goto LABEL_227;
                      v112 = v255[22];
                      if ( v112
                        && (v113 = *(_DWORD **)(v112 + 16), v260 = *(_DWORD *)(v112 + 20), (unsigned int)v113 < v260) )
                      {
                        v166 = v254 == 0x7FFFFFFF;
                        v114 = v113 + 1;
                        *(_DWORD *)(v112 + 16) = v113 + 1;
                        *v113 = 48;
                        if ( v166 )
                          goto LABEL_89;
                      }
                      else
                      {
                        v260 = v109;
                        v203 = _woverflow(v255, 48);
                        v109 = v260;
                        if ( v203 == -1 || v254 == 0x7FFFFFFF )
                          goto LABEL_89;
                        v112 = v255[22];
                        if ( !v112 )
                          goto LABEL_516;
                        v114 = *(_DWORD **)(v112 + 16);
                        v260 = *(_DWORD *)(v112 + 20);
                      }
                      if ( v260 > (unsigned int)v114 )
                      {
                        *(_DWORD *)(v112 + 16) = v114 + 1;
                        *v114 = v259;
LABEL_225:
                        if ( v254 == 2147483646 )
                          goto LABEL_89;
                        v254 += 2;
LABEL_227:
                        v13 += v109;
                        if ( v13 > 0 )
                        {
                          if ( v13 != IO_wpadn((int)v255, 48, v13) )
                            goto LABEL_89;
                          if ( v254 > 0x7FFFFFFE )
                          {
LABEL_541:
                            v205 = v256;
                            v211 = &_PRETTY_FUNCTION___13739[(_DWORD)v256 - 135061504];
                            v210 = 2017;
                            goto LABEL_542;
                          }
                          if ( 0x7FFFFFFF - v254 < v13 )
                            goto LABEL_88;
                          v254 += v13;
                        }
                        if ( (v254 & 0x80000000) != 0 )
                          goto LABEL_547;
                        v115 = v255[37];
                        if ( v222 <= v115 - (int)v223 )
                          IO_vtable_check();
                        v13 = v250;
                        if ( v13 != (*(int (__cdecl **)(int *, _BYTE *, int))(v115 + 28))(v255, v234, v250) )
                          goto LABEL_89;
                        v78 = v254;
                        if ( v13 > (int)(0x7FFFFFFF - v254) )
                          goto LABEL_88;
                        goto LABEL_233;
                      }
LABEL_516:
                      v260 = v109;
                      v202 = _woverflow(v255, v259);
                      v109 = v260;
                      if ( v202 == -1 )
                        goto LABEL_89;
                      goto LABEL_225;
                    }
                  }
                  v260 = v109;
                  v209 = 45;
                }
                v200 = _woverflow(v255, v209);
                v109 = v260;
                if ( v200 == -1 )
                  goto LABEL_89;
                goto LABEL_215;
              }
              if ( *(float *)&v257 == 0.0 )
              {
                if ( v244 )
                {
                  v137 = v255[22];
                  if ( v137 )
                  {
                    v138 = *(_DWORD **)(v137 + 16);
                    if ( (unsigned int)v138 < *(_DWORD *)(v137 + 20) )
                    {
                      *(_DWORD *)(v137 + 16) = v138 + 1;
                      *v138 = 43;
                      goto LABEL_242;
                    }
                  }
                  v209 = 43;
                }
                else
                {
                  if ( !v242 )
                    goto LABEL_244;
                  v131 = v255[22];
                  if ( v131 )
                  {
                    v132 = *(_DWORD **)(v131 + 16);
                    if ( (unsigned int)v132 < *(_DWORD *)(v131 + 20) )
                    {
                      *(_DWORD *)(v131 + 16) = v132 + 1;
                      *v132 = 32;
                      goto LABEL_242;
                    }
                  }
                  v209 = 32;
                }
              }
              else
              {
                v117 = v255[22];
                if ( v117 )
                {
                  v118 = *(_DWORD **)(v117 + 16);
                  if ( (unsigned int)v118 < *(_DWORD *)(v117 + 20) )
                  {
                    *(_DWORD *)(v117 + 16) = v118 + 1;
                    *v118 = 45;
LABEL_242:
                    if ( v254 == 0x7FFFFFFF )
                      goto LABEL_89;
                    --v260;
                    ++v254;
LABEL_244:
                    if ( !v231 || v236 != 16 || !v239 )
                    {
LABEL_254:
                      v122 = v96 >> 2;
                      v260 -= (v96 >> 2) + v13;
                      if ( v243 > 0 )
                      {
                        v259 = v96 >> 2;
                        if ( IO_wpadn((int)v255, 48, v13) != v13 )
                          goto LABEL_89;
                        if ( v254 > 0x7FFFFFFE )
                          goto LABEL_541;
                        if ( 0x7FFFFFFF - v254 < v13 )
                          goto LABEL_88;
                        v122 = v259;
                        v254 += v13;
                      }
                      v13 = v254;
                      if ( (v254 & 0x80000000) != 0 )
                      {
LABEL_547:
                        v206 = v256;
                        v211 = &_PRETTY_FUNCTION___13739[(_DWORD)v256 - 135061504];
                        v210 = 2017;
                        goto LABEL_544;
                      }
                      v123 = v255[37];
                      if ( v224 <= v123 - (int)v226 )
                      {
                        v259 = v122;
                        IO_vtable_check();
                        v122 = v259;
                      }
                      v259 = v122;
                      v124 = (*(int (__cdecl **)(int *, _BYTE *, int))(v123 + 28))(v255, v234, v122);
                      if ( v259 != v124 )
                        goto LABEL_89;
                      v13 = 0x7FFFFFFF;
                      if ( v259 > (int)(0x7FFFFFFF - v254) )
                        goto LABEL_88;
                      v254 += v259;
                      if ( (int)v260 > 0 )
                      {
                        v125 = IO_wpadn((int)v255, 32, v260);
                        if ( v260 != v125 )
                          goto LABEL_89;
                        if ( v254 > 0x7FFFFFFE )
                          goto LABEL_541;
                        v13 = 0x7FFFFFFF - v254;
                        if ( 0x7FFFFFFF - v254 < v260 )
                          goto LABEL_88;
                        v254 += v260;
                      }
                      goto LABEL_166;
                    }
                    v119 = v255[22];
                    if ( v119
                      && (v120 = *(_DWORD **)(v119 + 16), v257 = *(unsigned int *)(v119 + 20), (unsigned int)v120 < v257) )
                    {
                      v166 = v254 == 0x7FFFFFFF;
                      v121 = v120 + 1;
                      *(_DWORD *)(v119 + 16) = v120 + 1;
                      *v120 = 48;
                      if ( v166 )
                        goto LABEL_89;
                    }
                    else
                    {
                      if ( _woverflow(v255, 48) == -1 || v254 == 0x7FFFFFFF )
                        goto LABEL_89;
                      v119 = v255[22];
                      if ( !v119 )
                        goto LABEL_522;
                      v121 = *(_DWORD **)(v119 + 16);
                      v257 = *(unsigned int *)(v119 + 20);
                    }
                    if ( (unsigned int)v121 < v257 )
                    {
                      *(_DWORD *)(v119 + 16) = v121 + 1;
                      *v121 = v259;
LABEL_252:
                      if ( v254 == 2147483646 )
                        goto LABEL_89;
                      v260 -= 2;
                      v254 += 2;
                      goto LABEL_254;
                    }
LABEL_522:
                    if ( _woverflow(v255, v259) == -1 )
                      goto LABEL_89;
                    goto LABEL_252;
                  }
                }
                v209 = 45;
              }
              if ( _woverflow(v255, v209) == -1 )
                goto LABEL_89;
              goto LABEL_242;
            }
LABEL_397:
            v234 = group_number_0(v245, v234, v247, v249, v246);
            goto LABEL_159;
          }
          if ( v236 != 16 )
          {
            v170 = v247;
            while ( 1 )
            {
              v170 -= 4;
              *(_DWORD *)v170 = *(_DWORD *)&v93[4 * (v91 & 7)];
              if ( v91 <= 7 )
                break;
              v91 >>= 3;
            }
            v234 = v170;
            goto LABEL_376;
          }
LABEL_420:
          v183 = v247;
          while ( 1 )
          {
            v183 -= 4;
            *(_DWORD *)v183 = *(_DWORD *)&v93[4 * (v91 & 0xF)];
            if ( v91 <= 0xF )
              break;
            v91 >>= 4;
          }
          v234 = v183;
          v236 = 16;
LABEL_376:
          if ( !(_BYTE)v243 )
          {
            v94 = v247;
            goto LABEL_378;
          }
          goto LABEL_397;
        }
        v244 = 0;
        HIDWORD(v101) = v100[1];
        v242 = 0;
        LODWORD(v101) = *v100;
        v225 = v101;
        *(float *)&v257 = 0.0;
LABEL_180:
        if ( v13 < 0 )
        {
          v13 = 1;
        }
        else
        {
          if ( !v13 && !v225 )
          {
            if ( v236 == 8 && (_BYTE)v230 )
            {
              v241 = 32;
              v243 = 1;
              v102 = v247 - 4;
              *(_DWORD *)v102 = 48;
              v234 = v102;
              v96 = 4;
            }
            else
            {
              v96 = 0;
              v241 = 32;
              v243 = 0;
              v234 = v247;
            }
LABEL_199:
            v231 = v225 != 0;
            goto LABEL_200;
          }
          v241 = 32;
        }
        v105 = itowa(v225, v247, v236, v259 == 88);
        v234 = v105;
        if ( v249 && (_BYTE)v243 )
          v234 = group_number_0(v245, v105, v247, v249, v246);
        v106 = v247;
        if ( v236 == 10 && v240 )
        {
          v139 = i18n_number_rewrite_1(v234, (int)v247, v247);
          v96 = v106 - v139;
          v234 = v139;
          v243 = v96 >> 2;
        }
        else
        {
          v96 = v247 - v234;
          v243 = (v247 - v234) >> 2;
        }
        goto LABEL_199;
      default:
        v48 = v33[11];
        v49 = 4 * v48 + 27;
        v13 = (int)&v212[-(v49 & 0xFFFFF000)];
        v50 = v49 & 0xFFF0;
        while ( v212 != (_BYTE *)v13 )
          ;
        v144 = v50 & 0xFFF;
        if ( v144 )
        {
          v145 = alloca(v144);
          *(_DWORD *)&v212[v144 - 4] = *(_DWORD *)&v212[v144 - 4];
        }
        v146 = (char ***)v212;
        if ( v48 )
        {
          v13 = (int)v253;
          v147 = (char ***)&v212[4 * v48];
          v148 = &v253[3 * v33[9]];
          do
          {
            *v146++ = v148;
            v148 += 3;
          }
          while ( v147 != v146 );
        }
        v149 = v255[22];
        if ( v149 && (v150 = *(_DWORD **)(v149 + 16), v151 = *(_DWORD *)(v149 + 20), (unsigned int)v150 < v151) )
        {
          v152 = v150 + 1;
          *(_DWORD *)(v149 + 16) = v150 + 1;
          *v150 = 37;
          v153 = *((_BYTE *)v33 + 12);
          if ( (v153 & 8) == 0 )
          {
            v259 = 1;
            if ( v153 >= 0 )
              goto LABEL_324;
LABEL_450:
            v194 = *(_DWORD **)(v149 + 16);
            if ( (unsigned int)v194 < *(_DWORD *)(v149 + 20) )
            {
              *(_DWORD *)(v149 + 16) = v194 + 1;
              *v194 = 39;
LABEL_452:
              ++v259;
              v153 = *((_BYTE *)v33 + 12);
              goto LABEL_324;
            }
LABEL_494:
            if ( _woverflow(v255, 39) == -1 )
              goto LABEL_89;
            goto LABEL_452;
          }
        }
        else
        {
          if ( _woverflow(v255, 37) == -1 )
            goto LABEL_89;
          v259 = 1;
          v153 = *((_BYTE *)v33 + 12);
          if ( (v153 & 8) == 0 )
            goto LABEL_492;
          v149 = v255[22];
          if ( !v149 )
          {
LABEL_490:
            if ( _woverflow(v255, 35) == -1 )
              goto LABEL_89;
            v259 = 2;
            v153 = *((_BYTE *)v33 + 12);
LABEL_492:
            if ( v153 < 0 )
            {
              v149 = v255[22];
              if ( !v149 )
                goto LABEL_494;
              goto LABEL_450;
            }
LABEL_324:
            if ( (v153 & 0x40) != 0 )
            {
              v154 = v255[22];
              if ( v154 )
              {
                v155 = *(_DWORD **)(v154 + 16);
                if ( (unsigned int)v155 < *(_DWORD *)(v154 + 20) )
                {
                  *(_DWORD *)(v154 + 16) = v155 + 1;
                  *v155 = 43;
LABEL_328:
                  ++v259;
                  v153 = *((_BYTE *)v33 + 12);
LABEL_329:
                  if ( (v153 & 0x20) != 0 )
                  {
                    v156 = v255[22];
                    if ( v156 && (v157 = *(_DWORD **)(v156 + 16), (unsigned int)v157 < *(_DWORD *)(v156 + 20)) )
                    {
                      *(_DWORD *)(v156 + 16) = v157 + 1;
                      *v157 = 45;
                    }
                    else if ( _woverflow(v255, 45) == -1 )
                    {
                      goto LABEL_89;
                    }
                    ++v259;
                  }
                  if ( v33[4] == 48 )
                  {
                    v195 = v255[22];
                    if ( v195 && (v196 = *(_DWORD **)(v195 + 16), (unsigned int)v196 < *(_DWORD *)(v195 + 20)) )
                    {
                      *(_DWORD *)(v195 + 16) = v196 + 1;
                      *v196 = 48;
                    }
                    else if ( _woverflow(v255, 48) == -1 )
                    {
                      goto LABEL_89;
                    }
                    ++v259;
                  }
                  if ( (*((_BYTE *)v33 + 13) & 8) != 0 )
                  {
                    v158 = v255[22];
                    if ( v158 && (v159 = *(_DWORD **)(v158 + 16), (unsigned int)v159 < *(_DWORD *)(v158 + 20)) )
                    {
                      *(_DWORD *)(v158 + 16) = v159 + 1;
                      *v159 = 73;
                    }
                    else if ( _woverflow(v255, 73) == -1 )
                    {
                      goto LABEL_89;
                    }
                    ++v259;
                  }
                  v160 = v33[1];
                  if ( v160 )
                  {
                    v260 = (unsigned int)&v265;
                    v161 = &v265;
                    while ( 1 )
                    {
                      --v161;
                      v13 = *((_DWORD *)v256 + v160 % 0xA - 22064);
                      *v161 = (char *)v13;
                      if ( v160 <= 9 )
                        break;
                      v160 /= 0xAu;
                    }
                    if ( (unsigned int)v161 < v260 )
                    {
                      v257 = (unsigned int)v33;
                      v162 = v259;
                      while ( 1 )
                      {
                        ++v161;
                        v164 = v255[22];
                        if ( v164 && (v163 = *(int **)(v164 + 16), (unsigned int)v163 < *(_DWORD *)(v164 + 20)) )
                        {
                          *(_DWORD *)(v164 + 16) = v163 + 1;
                          *v163 = v13;
                          if ( v13 == -1 )
                            goto LABEL_89;
                        }
                        else if ( _woverflow(v255, v13) == -1 )
                        {
                          goto LABEL_89;
                        }
                        ++v162;
                        if ( (unsigned int)v161 >= v260 )
                          break;
                        v13 = (int)*v161;
                      }
                      v259 = v162;
                      v33 = (int *)v257;
                    }
                  }
                  v176 = *v33;
                  if ( *v33 != -1 )
                  {
                    v177 = v255[22];
                    if ( v177 && (v178 = *(_DWORD **)(v177 + 16), (unsigned int)v178 < *(_DWORD *)(v177 + 20)) )
                    {
                      *(_DWORD *)(v177 + 16) = v178 + 1;
                      *v178 = 46;
                    }
                    else
                    {
                      if ( _woverflow(v255, 46) == -1 )
                        goto LABEL_89;
                      v176 = *v33;
                    }
                    ++v259;
                    v260 = (unsigned int)&v265;
                    v179 = &v265;
                    while ( 1 )
                    {
                      --v179;
                      v13 = *((_DWORD *)v256 + v176 % 0xA - 22064);
                      *v179 = (char *)v13;
                      if ( v176 <= 9 )
                        break;
                      v176 /= 0xAu;
                    }
                    if ( (unsigned int)v179 < v260 )
                    {
                      v257 = (unsigned int)v33;
                      v180 = v259;
                      while ( 1 )
                      {
                        ++v179;
                        v182 = v255[22];
                        if ( v182 && (v181 = *(int **)(v182 + 16), (unsigned int)v181 < *(_DWORD *)(v182 + 20)) )
                        {
                          *(_DWORD *)(v182 + 16) = v181 + 1;
                          *v181 = v13;
                          if ( v13 == -1 )
                            goto LABEL_89;
                        }
                        else if ( _woverflow(v255, v13) == -1 )
                        {
                          goto LABEL_89;
                        }
                        if ( v180 == 0x7FFFFFFF )
                          goto LABEL_89;
                        ++v180;
                        if ( (unsigned int)v179 >= v260 )
                          break;
                        v13 = (int)*v179;
                      }
                      v259 = v180;
                      v33 = (int *)v257;
                    }
                  }
                  v191 = v33[2];
                  if ( v191 )
                  {
                    v13 = (int)v255;
                    v192 = v255[22];
                    if ( v192 && (v193 = *(int **)(v192 + 16), (unsigned int)v193 < *(_DWORD *)(v192 + 20)) )
                    {
                      *(_DWORD *)(v192 + 16) = v193 + 1;
                      *v193 = v191;
                      if ( v191 == -1 )
                        goto LABEL_89;
                    }
                    else if ( _woverflow(v255, v33[2]) == -1 )
                    {
                      goto LABEL_89;
                    }
                    if ( v259 == 0x7FFFFFFF )
                      goto LABEL_89;
                    ++v259;
                  }
                  if ( v254 <= 0x7FFFFFFE )
                  {
                    v13 = v254;
                    if ( 0x7FFFFFFF - v254 < v259 )
                      goto LABEL_88;
                    v13 = v259 + v254;
                    v254 += v259;
                    goto LABEL_166;
                  }
                  v205 = v256;
                  v211 = &_PRETTY_FUNCTION___13739[(_DWORD)v256 - 135061504];
                  v210 = 2045;
LABEL_542:
                  _assert_fail(
                    (int)&aUnsignedIntDon[(_DWORD)v205 - 135061504],
                    (int)&aVfprintfC[(_DWORD)v205 - 135061504],
                    v210,
                    (int)v211);
                }
              }
              v209 = 43;
            }
            else
            {
              if ( (v153 & 0x10) == 0 )
                goto LABEL_329;
              v185 = v255[22];
              if ( v185 )
              {
                v186 = *(_DWORD **)(v185 + 16);
                if ( (unsigned int)v186 < *(_DWORD *)(v185 + 20) )
                {
                  *(_DWORD *)(v185 + 16) = v186 + 1;
                  *v186 = 32;
                  goto LABEL_328;
                }
              }
              v209 = 32;
            }
            if ( _woverflow(v255, v209) == -1 )
              goto LABEL_89;
            goto LABEL_328;
          }
          v152 = *(_DWORD **)(v149 + 16);
          v151 = *(_DWORD *)(v149 + 20);
        }
        if ( v151 > (unsigned int)v152 )
        {
          v259 = 2;
          *(_DWORD *)(v149 + 16) = v152 + 1;
          *v152 = 35;
          v153 = *((_BYTE *)v33 + 12);
          if ( v153 >= 0 )
            goto LABEL_324;
          goto LABEL_450;
        }
        goto LABEL_490;
    }
  }
}
// 807DACA: conditional instruction was optimized away because %var_8E8.4==8
// 80CE000: using guessed type _TBYTE GLOBAL_OFFSET_TABLE_;
// 80CEFA0: using guessed type int _start___libc_IO_vtables[24];
// 80CF2F4: using guessed type int (*_start___libc_atexit)();

//----- (0807F7D0) --------------------------------------------------------
void __cdecl vfwprintf(struct timespec *a1, int *a2, int a3)
{
  struct timespec *v3; // esi
  __time_t tv_sec; // edi
  int *tv_nsec; // edx
  int v6; // edi
  int *v7; // edx
  const struct timespec *v8; // ecx
  int *v10; // edi
  bool v12; // zf
  int *v13; // edx
  int v14; // eax
  int v15; // eax
  int v16; // eax
  int v17; // eax
  const struct timespec *v18; // eax
  unsigned int v19; // eax
  _BOOL4 v20; // eax
  _BYTE *v21; // eax
  int v22; // edx
  void *v23; // esp
  unsigned int v24; // edx
  const struct timespec *v25; // eax
  int v26; // eax
  int v27; // eax
  _BOOL4 v28; // eax
  _BYTE *v29; // eax
  int v30; // edx
  void *v31; // esp
  unsigned int v32; // eax
  int v33; // eax
  int v34; // eax
  int v35; // eax
  int v36; // eax
  int v37; // eax
  int v38; // eax
  __time_t v39; // eax
  _DWORD *v40; // edx
  int v41; // eax
  int *v42; // eax
  int *p_tv_sec; // ecx
  int *v44; // eax
  int v45; // ecx
  _BYTE *v46; // ecx
  unsigned int v47; // edx
  _BOOL4 v48; // eax
  unsigned int v49; // ecx
  int v50; // edx
  _BYTE *v51; // ecx
  int v52; // eax
  void *v53; // esp
  int v54; // edx
  int v55; // eax
  const struct timespec *v56; // eax
  int v57; // eax
  long double v58; // fst6
  int v59; // eax
  unsigned __int8 *v60; // eax
  int v61; // ecx
  int v62; // eax
  int v63; // eax
  int v64; // eax
  int v65; // eax
  __time_t v66; // edx
  _DWORD *v67; // ecx
  int v68; // eax
  unsigned int v69; // ecx
  unsigned int *v70; // ecx
  unsigned int *v71; // edx
  _BYTE *v72; // eax
  unsigned int *v73; // edx
  int v74; // eax
  __time_t v75; // eax
  _DWORD *v76; // edx
  __time_t v77; // eax
  _DWORD *v78; // ecx
  unsigned int *v79; // edx
  unsigned int v80; // eax
  unsigned int v81; // edx
  int v82; // eax
  int v83; // eax
  long double v84; // fst6
  int v85; // eax
  unsigned int *v86; // ecx
  int *v87; // eax
  const struct timespec *v88; // edx
  unsigned __int8 *v89; // eax
  unsigned __int64 v90; // rax
  int v91; // eax
  __time_t v92; // eax
  _DWORD *v93; // edx
  int v94; // ecx
  __time_t v95; // eax
  _DWORD *v96; // ecx
  __time_t v97; // eax
  _DWORD *v98; // ecx
  unsigned int *v99; // edx
  unsigned int v100; // ecx
  int v101; // ecx
  int v102; // edx
  int v103; // eax
  const struct timespec *v104; // eax
  int v105; // eax
  int v106; // eax
  unsigned int *v107; // eax
  int v108; // eax
  const char *v109; // eax
  const char *v110; // edx
  unsigned int *v111; // edx
  _BYTE *v112; // eax
  unsigned int *v113; // eax
  __time_t v114; // eax
  _DWORD *v115; // ecx
  int v116; // eax
  int v117; // eax
  int v118; // eax
  const struct timespec *v119; // eax
  __time_t v120; // eax
  _DWORD *v121; // edx
  __time_t v122; // eax
  _DWORD *v123; // ecx
  unsigned int *v124; // esi
  int v125; // eax
  int v126; // edx
  int v127; // eax
  int v128; // edx
  __int64 v129; // xmm0_8
  unsigned int v130; // ecx
  __int64 v131; // xmm2_8
  int v132; // eax
  int *v133; // edx
  int v134; // eax
  int v135; // edx
  int v136; // eax
  _BOOL4 v137; // eax
  _BYTE *v138; // eax
  int v139; // eax
  void *v140; // esp
  int v141; // eax
  char *v142; // edx
  __time_t v143; // eax
  _DWORD *v144; // edx
  int v145; // eax
  int v146; // eax
  int v147; // ecx
  _WORD *v148; // eax
  int v149; // eax
  int v150; // eax
  int v151; // eax
  int v152; // eax
  int *v153; // eax
  int *v154; // eax
  _BYTE v155[4080]; // [esp-200Ch] [ebp-24F8h] BYREF
  const struct timespec *v156; // [esp-101Ch] [ebp-1508h]
  int v157; // [esp-1014h] [ebp-1500h]
  void *v158; // [esp-1010h] [ebp-14FCh]
  _BYTE v159[4080]; // [esp-100Ch] [ebp-14F8h] BYREF
  const struct timespec *v160; // [esp-1Ch] [ebp-508h]
  int v161; // [esp-18h] [ebp-504h]
  int v162; // [esp-14h] [ebp-500h]
  void *v163; // [esp-10h] [ebp-4FCh]
  _BYTE v164[12]; // [esp-Ch] [ebp-4F8h] BYREF
  struct timespec *v165; // [esp+0h] [ebp-4ECh]
  int v166; // [esp+4h] [ebp-4E8h]
  int v167; // [esp+8h] [ebp-4E4h]
  unsigned __int64 v168; // [esp+Ch] [ebp-4E0h]
  unsigned int v169; // [esp+14h] [ebp-4D8h]
  int v170; // [esp+18h] [ebp-4D4h]
  int v171; // [esp+1Ch] [ebp-4D0h]
  char *v172; // [esp+20h] [ebp-4CCh]
  int v173; // [esp+24h] [ebp-4C8h]
  int v174; // [esp+28h] [ebp-4C4h]
  int v175; // [esp+2Ch] [ebp-4C0h]
  signed int v176; // [esp+30h] [ebp-4BCh]
  int v177; // [esp+34h] [ebp-4B8h]
  const struct timespec *v178; // [esp+38h] [ebp-4B4h]
  int v179; // [esp+3Ch] [ebp-4B0h]
  int v180; // [esp+40h] [ebp-4ACh]
  int v181; // [esp+44h] [ebp-4A8h]
  int v182; // [esp+48h] [ebp-4A4h]
  unsigned int *v183; // [esp+4Ch] [ebp-4A0h]
  int v184; // [esp+50h] [ebp-49Ch]
  unsigned int v185; // [esp+54h] [ebp-498h]
  unsigned int v186; // [esp+58h] [ebp-494h]
  int v187; // [esp+5Ch] [ebp-490h]
  _BYTE *v188; // [esp+60h] [ebp-48Ch]
  int v189; // [esp+64h] [ebp-488h]
  unsigned int v190; // [esp+68h] [ebp-484h]
  struct timespec *v191; // [esp+6Ch] [ebp-480h]
  int *v192; // [esp+70h] [ebp-47Ch]
  unsigned int v193; // [esp+74h] [ebp-478h]
  int *v194; // [esp+78h] [ebp-474h]
  unsigned int p_tv_nsec; // [esp+7Ch] [ebp-470h]
  int v196; // [esp+80h] [ebp-46Ch]
  long double v197; // [esp+84h] [ebp-468h]
  int *v198; // [esp+90h] [ebp-45Ch]
  int *v199; // [esp+A0h] [ebp-44Ch] BYREF
  int v200; // [esp+A4h] [ebp-448h] BYREF
  LONG_DOUBLE_12 *v201; // [esp+A8h] [ebp-444h] BYREF
  LONG_DOUBLE_12 *v202; // [esp+ACh] [ebp-440h] BYREF
  LONG_DOUBLE_12 v203; // [esp+B0h] [ebp-43Ch] BYREF
  int v204[4]; // [esp+BCh] [ebp-430h] BYREF
  unsigned int *v205; // [esp+CCh] [ebp-420h] BYREF
  int v206; // [esp+D0h] [ebp-41Ch]
  unsigned int v207; // [esp+D4h] [ebp-418h]
  int v208; // [esp+D8h] [ebp-414h]
  int v209; // [esp+DCh] [ebp-410h]
  int v210[2]; // [esp+E0h] [ebp-40Ch] BYREF
  int v211[250]; // [esp+E8h] [ebp-404h] BYREF
  unsigned int v212; // [esp+4D0h] [ebp-1Ch] BYREF
  int savedregs; // [esp+4ECh] [ebp+0h] BYREF

  v3 = a1;
  v198 = a2;
  LODWORD(v197) = a3;
  v212 = __readgsdword(0x14u);
  v190 = -32;
  v188 = (_BYTE *)__readgsdword(0xFFFFFFE0);
  if ( IO_fwide(a1, 1) == 1 )
  {
    if ( (a1->tv_sec & 8) != 0 )
    {
      a1->tv_sec |= 0x20u;
      __writegsdword(v190, 9u);
      return;
    }
    if ( !v198 )
    {
      __writegsdword(v190, 0x16u);
      return;
    }
    if ( IO_fwide(a1, 1) == 1 )
    {
      tv_sec = a1->tv_sec;
      p_tv_nsec = a1->tv_sec & 2;
      if ( p_tv_nsec )
      {
        buffered_vfprintf_0(a1, v198, SLODWORD(v197));
        return;
      }
      v200 = LODWORD(v197);
      v194 = wcschrnul(v198, 37);
      v199 = v194;
      v196 = tv_sec & 0x8000;
      if ( (tv_sec & 0x8000) != 0 )
      {
        v196 = 0;
      }
      else
      {
        v204[1] = (int)a1;
        v204[0] = (int)funlockfile;
        _EDX = (int *)a1[9].tv_sec;
        v10 = (int *)__readgsdword(8u);
        if ( (int *)_EDX[2] != v10 )
        {
          _ECX = 1;
          v12 = __readgsdword(0xCu) == 0;
          if ( !v12 )
            __asm { lock }
          __asm { cmpxchg [edx], ecx }
          if ( !v12 )
            _lll_lock_wait_private(0, _EDX, (int)&savedregs, v10);
          _EDX = (int *)a1[9].tv_sec;
          _EDX[2] = (int)v10;
        }
        ++_EDX[1];
      }
      tv_nsec = (int *)a1[18].tv_nsec;
      v192 = _start___libc_IO_vtables;
      v193 = (char *)&_start___libc_atexit - (char *)_start___libc_IO_vtables;
      if ( (char *)&_start___libc_atexit - (char *)_start___libc_IO_vtables <= (unsigned int)((char *)tv_nsec
                                                                                            - (char *)_start___libc_IO_vtables) )
      {
        v191 = (struct timespec *)tv_nsec;
        IO_vtable_check();
        tv_nsec = &v191->tv_sec;
      }
      v6 = v194 - v198;
      if ( v6 != ((int (__cdecl *)(struct timespec *, int *, int))tv_nsec[7])(a1, v198, v6) )
        goto LABEL_36;
      v7 = v199;
      if ( !*v199 )
        goto LABEL_26;
      if ( _printf_function_table || _printf_modifier_table || _printf_va_arg_table )
      {
        v172 = 0;
        v170 = 0;
        v176 = -1;
      }
      else
      {
        v170 = 0;
        v178 = 0;
        v172 = 0;
        v176 = -1;
        v169 = -36;
        while ( 2 )
        {
          v8 = (const struct timespec *)v7[1];
          v199 = v7 + 1;
          p_tv_nsec = (unsigned int)v8;
          v173 = 0;
          v186 = (unsigned int)jump_table_0;
          v187 = 0;
          v183 = &v212;
          v171 = 0;
          v182 = 0;
          v174 = 0;
          v185 = 0;
          v181 = 0;
          v179 = 0;
          v184 = 0;
          v177 = 0;
          v175 = 0;
          v191 = 0;
          v180 = 32;
          v189 = -1;
          switch ( (unsigned int)v8 )
          {
            case ' ':
LABEL_51:
              while ( 2 )
              {
                v18 = (const struct timespec *)v199[1];
                ++v199;
                p_tv_nsec = (unsigned int)v18;
                v177 = 1;
                switch ( (unsigned int)v18 )
                {
                  case ' ':
                    continue;
                  case '#':
                    goto LABEL_81;
                  case '%':
                    goto LABEL_212;
                  case '\'':
                    goto LABEL_78;
                  case '*':
                    goto LABEL_64;
                  case '+':
                    goto LABEL_50;
                  case '-':
                    goto LABEL_82;
                  case '.':
                    goto LABEL_204;
                  case '0':
                    goto LABEL_83;
                  case '1':
                  case '2':
                  case '3':
                  case '4':
                  case '5':
                  case '6':
                  case '7':
                  case '8':
                  case '9':
                    goto LABEL_52;
                  case 'A':
                  case 'a':
                    goto LABEL_125;
                  case 'C':
                    goto LABEL_87;
                  case 'E':
                  case 'F':
                  case 'G':
                  case 'e':
                  case 'f':
                  case 'g':
                    goto LABEL_191;
                  case 'I':
                    goto LABEL_80;
                  case 'L':
                  case 'j':
                  case 'q':
                    goto LABEL_42;
                  case 'S':
                  case 's':
                    goto LABEL_104;
                  case 'X':
                  case 'x':
                    goto LABEL_217;
                  case 'Z':
                  case 't':
                  case 'z':
                    goto LABEL_43;
                  case 'c':
                    goto LABEL_138;
                  case 'd':
                  case 'i':
                    goto LABEL_195;
                  case 'h':
                    goto LABEL_137;
                  case 'l':
                    goto LABEL_211;
                  case 'm':
                    goto LABEL_131;
                  case 'n':
                    goto LABEL_132;
                  case 'o':
                    goto LABEL_207;
                  case 'p':
                    goto LABEL_145;
                  case 'u':
                    goto LABEL_210;
                  default:
                    goto LABEL_32;
                }
              }
            case '!':
            case '"':
            case '$':
            case '&':
            case '(':
            case ')':
            case ',':
            case '/':
            case ':':
            case ';':
            case '<':
            case '=':
            case '>':
            case '?':
            case '@':
            case 'B':
            case 'D':
            case 'H':
            case 'J':
            case 'K':
            case 'M':
            case 'N':
            case 'O':
            case 'P':
            case 'Q':
            case 'R':
            case 'T':
            case 'U':
            case 'V':
            case 'W':
            case 'Y':
            case '[':
            case '\\':
            case ']':
            case '^':
            case '_':
            case '`':
            case 'b':
            case 'k':
            case 'r':
            case 'v':
            case 'w':
            case 'y':
              goto LABEL_32;
            case '#':
LABEL_81:
              while ( 2 )
              {
                v35 = *++v199 - 32;
                p_tv_nsec = *v199;
                v175 = 1;
                switch ( v35 )
                {
                  case 0:
                    goto LABEL_51;
                  case 3:
                    continue;
                  case 5:
                    goto LABEL_212;
                  case 7:
                    goto LABEL_78;
                  case 10:
                    goto LABEL_64;
                  case 11:
                    goto LABEL_50;
                  case 13:
                    goto LABEL_82;
                  case 14:
                    goto LABEL_204;
                  case 16:
                    goto LABEL_83;
                  case 17:
                  case 18:
                  case 19:
                  case 20:
                  case 21:
                  case 22:
                  case 23:
                  case 24:
                  case 25:
                    goto LABEL_52;
                  case 33:
                  case 65:
                    goto LABEL_125;
                  case 35:
                    goto LABEL_87;
                  case 37:
                  case 38:
                  case 39:
                  case 69:
                  case 70:
                  case 71:
                    goto LABEL_191;
                  case 41:
                    goto LABEL_80;
                  case 44:
                  case 74:
                  case 81:
                    goto LABEL_42;
                  case 51:
                  case 83:
                    goto LABEL_104;
                  case 56:
                  case 88:
                    goto LABEL_217;
                  case 58:
                  case 84:
                  case 90:
                    goto LABEL_43;
                  case 67:
                    goto LABEL_138;
                  case 68:
                  case 73:
                    goto LABEL_195;
                  case 72:
                    goto LABEL_137;
                  case 76:
                    goto LABEL_211;
                  case 77:
                    goto LABEL_131;
                  case 78:
                    goto LABEL_132;
                  case 79:
                    goto LABEL_207;
                  case 80:
                    goto LABEL_145;
                  case 85:
                    goto LABEL_210;
                  default:
                    goto LABEL_32;
                }
              }
            case '%':
LABEL_212:
              v92 = v3[11].tv_sec;
              if ( v92 && (v93 = *(_DWORD **)(v92 + 16), (unsigned int)v93 < *(_DWORD *)(v92 + 20)) )
              {
                *(_DWORD *)(v92 + 16) = v93 + 1;
                *v93 = 37;
              }
              else if ( _woverflow(v3, 37) == -1 )
              {
                goto LABEL_34;
              }
              if ( v6 == 0x7FFFFFFF )
                goto LABEL_34;
              ++v6;
              goto LABEL_95;
            case '\'':
LABEL_78:
              while ( 2 )
              {
                if ( v176 == -1 )
                {
                  v141 = *(_DWORD *)__readgsdword(v169);
                  v142 = *(char **)(v141 + 52);
                  v176 = *(_DWORD *)(v141 + 44);
                  LOBYTE(v141) = *(_BYTE *)v176;
                  v172 = v142;
                  if ( (_BYTE)v141 == 127 || (_BYTE)v141 == 0 || !v172 )
                    v176 = 0;
                }
                v33 = *++v199 - 32;
                p_tv_nsec = *v199;
                v181 = 1;
                switch ( v33 )
                {
                  case 0:
                    goto LABEL_51;
                  case 3:
                    goto LABEL_81;
                  case 5:
                    goto LABEL_212;
                  case 7:
                    continue;
                  case 10:
                    goto LABEL_64;
                  case 11:
                    goto LABEL_50;
                  case 13:
                    goto LABEL_82;
                  case 14:
                    goto LABEL_204;
                  case 16:
                    goto LABEL_83;
                  case 17:
                  case 18:
                  case 19:
                  case 20:
                  case 21:
                  case 22:
                  case 23:
                  case 24:
                  case 25:
                    goto LABEL_52;
                  case 33:
                  case 65:
                    goto LABEL_125;
                  case 35:
                    goto LABEL_87;
                  case 37:
                  case 38:
                  case 39:
                  case 69:
                  case 70:
                  case 71:
                    goto LABEL_191;
                  case 41:
                    goto LABEL_80;
                  case 44:
                  case 74:
                  case 81:
                    goto LABEL_42;
                  case 51:
                  case 83:
                    goto LABEL_104;
                  case 56:
                  case 88:
                    goto LABEL_217;
                  case 58:
                  case 84:
                  case 90:
                    goto LABEL_43;
                  case 67:
                    goto LABEL_138;
                  case 68:
                  case 73:
                    goto LABEL_195;
                  case 72:
                    goto LABEL_137;
                  case 76:
                    goto LABEL_211;
                  case 77:
                    goto LABEL_131;
                  case 78:
                    goto LABEL_132;
                  case 79:
                    goto LABEL_207;
                  case 80:
                    goto LABEL_145;
                  case 85:
                    goto LABEL_210;
                  default:
                    goto LABEL_32;
                }
              }
            case '*':
LABEL_64:
              v26 = v199[1];
              v205 = (unsigned int *)++v199;
              if ( (unsigned int)(v26 - 48) > 9 )
                goto LABEL_65;
              p_tv_nsec = (unsigned int)v8;
              v16 = read_int_0(&v205);
              v8 = (const struct timespec *)p_tv_nsec;
              if ( v16 == -1 )
                goto LABEL_253;
              if ( v16 && *v205 == 36 )
                goto LABEL_48;
LABEL_65:
              v27 = *(_DWORD *)LODWORD(v197);
              LODWORD(v197) += 4;
              v187 = v27;
              if ( v27 < 0 )
              {
                v184 = 1;
                v187 = -v27;
                v180 = 32;
              }
              if ( v187 > 536870878 )
                goto LABEL_253;
              if ( v187 <= 217 )
                goto LABEL_76;
              v183 = (unsigned int *)v8;
              v160 = (const struct timespec *)(4 * v187 + 128);
              p_tv_nsec = (unsigned int)v160;
              v28 = _libc_alloca_cutoff((unsigned int)v160);
              v8 = (const struct timespec *)v183;
              if ( v28 || p_tv_nsec <= 0x1000 )
              {
                v183 = (unsigned int *)((p_tv_nsec + 27) & 0xFFFFFFF0);
                v29 = &v164[-((p_tv_nsec + 27) & 0xFFFFF000)];
                if ( v164 != v29 )
                {
                  while ( v159 != v29 )
                    ;
                }
                v30 = ((_WORD)p_tv_nsec + 27) & 0xFF0;
                if ( (((_WORD)p_tv_nsec + 27) & 0xFF0) != 0 )
                {
                  v31 = alloca(v30);
                  *(_DWORD *)&v159[v30 - 4] = *(_DWORD *)&v159[v30 - 4];
                }
                v183 = (unsigned int *)&v159[p_tv_nsec];
              }
              else
              {
                v154 = malloc((const struct timespec *)p_tv_nsec);
                v8 = (const struct timespec *)v183;
                v191 = (struct timespec *)v154;
                if ( !v154 )
                  goto LABEL_36;
                v183 = (unsigned int *)((char *)v191 + p_tv_nsec);
              }
LABEL_76:
              v24 = *v199;
              v32 = *v199 - 32;
              p_tv_nsec = *v199;
              if ( v32 <= 0x5A )
                goto LABEL_63;
LABEL_32:
              if ( !p_tv_nsec )
              {
                __writegsdword(v190, 0x16u);
                goto LABEL_34;
              }
              goto LABEL_48;
            case '+':
LABEL_50:
              while ( 2 )
              {
                v17 = *++v199 - 32;
                p_tv_nsec = *v199;
                v179 = 1;
                switch ( v17 )
                {
                  case 0:
                    goto LABEL_51;
                  case 3:
                    goto LABEL_81;
                  case 5:
                    goto LABEL_212;
                  case 7:
                    goto LABEL_78;
                  case 10:
                    goto LABEL_64;
                  case 11:
                    continue;
                  case 13:
                    goto LABEL_82;
                  case 14:
                    goto LABEL_204;
                  case 16:
                    goto LABEL_83;
                  case 17:
                  case 18:
                  case 19:
                  case 20:
                  case 21:
                  case 22:
                  case 23:
                  case 24:
                  case 25:
                    goto LABEL_52;
                  case 33:
                  case 65:
                    goto LABEL_125;
                  case 35:
                    goto LABEL_87;
                  case 37:
                  case 38:
                  case 39:
                  case 69:
                  case 70:
                  case 71:
                    goto LABEL_191;
                  case 41:
                    goto LABEL_80;
                  case 44:
                  case 74:
                  case 81:
                    goto LABEL_42;
                  case 51:
                  case 83:
                    goto LABEL_104;
                  case 56:
                  case 88:
                    goto LABEL_217;
                  case 58:
                  case 84:
                  case 90:
                    goto LABEL_43;
                  case 67:
                    goto LABEL_138;
                  case 68:
                  case 73:
                    goto LABEL_195;
                  case 72:
                    goto LABEL_137;
                  case 76:
                    goto LABEL_211;
                  case 77:
                    goto LABEL_131;
                  case 78:
                    goto LABEL_132;
                  case 79:
                    goto LABEL_207;
                  case 80:
                    goto LABEL_145;
                  case 85:
                    goto LABEL_210;
                  default:
                    goto LABEL_32;
                }
              }
            case '-':
LABEL_82:
              while ( 2 )
              {
                v36 = *++v199 - 32;
                p_tv_nsec = *v199;
                v184 = 1;
                v180 = 32;
                switch ( v36 )
                {
                  case 0:
                    goto LABEL_51;
                  case 3:
                    goto LABEL_81;
                  case 5:
                    goto LABEL_212;
                  case 7:
                    goto LABEL_78;
                  case 10:
                    goto LABEL_64;
                  case 11:
                    goto LABEL_50;
                  case 13:
                    continue;
                  case 14:
                    goto LABEL_204;
                  case 16:
                    goto LABEL_83;
                  case 17:
                  case 18:
                  case 19:
                  case 20:
                  case 21:
                  case 22:
                  case 23:
                  case 24:
                  case 25:
                    goto LABEL_52;
                  case 33:
                  case 65:
                    goto LABEL_125;
                  case 35:
                    goto LABEL_87;
                  case 37:
                  case 38:
                  case 39:
                  case 69:
                  case 70:
                  case 71:
                    goto LABEL_191;
                  case 41:
                    goto LABEL_80;
                  case 44:
                  case 74:
                  case 81:
                    goto LABEL_42;
                  case 51:
                  case 83:
                    goto LABEL_104;
                  case 56:
                  case 88:
                    goto LABEL_217;
                  case 58:
                  case 84:
                  case 90:
                    goto LABEL_43;
                  case 67:
                    goto LABEL_138;
                  case 68:
                  case 73:
                    goto LABEL_195;
                  case 72:
                    goto LABEL_137;
                  case 76:
                    goto LABEL_211;
                  case 77:
                    goto LABEL_131;
                  case 78:
                    goto LABEL_132;
                  case 79:
                    goto LABEL_207;
                  case 80:
                    goto LABEL_145;
                  case 85:
                    goto LABEL_210;
                  default:
                    goto LABEL_32;
                }
              }
            case '.':
LABEL_204:
              v87 = v199++;
              v88 = (const struct timespec *)*v199;
              if ( *v199 != 42 )
              {
                v189 = 0;
                if ( (unsigned int)&v88[-6] > 9 )
                  goto LABEL_206;
                p_tv_nsec = (unsigned int)v8;
                v105 = read_int_0(&v199);
                v8 = (const struct timespec *)p_tv_nsec;
                v189 = v105;
                if ( v105 == -1 )
                  goto LABEL_253;
                goto LABEL_365;
              }
              v133 = v87 + 2;
              v134 = v87[2];
              v199 = v133;
              v205 = (unsigned int *)v133;
              if ( (unsigned int)(v134 - 48) > 9 )
                goto LABEL_362;
              p_tv_nsec = (unsigned int)v8;
              v152 = read_int_0(&v205);
              v8 = (const struct timespec *)p_tv_nsec;
              if ( v152 == -1 )
              {
LABEL_253:
                __writegsdword(v190, 0x4Bu);
LABEL_34:
                if ( v191 )
                  free((int)&savedregs, &v191->tv_sec, (int)v191);
                goto LABEL_36;
              }
              if ( !v152 || *v205 != 36 )
              {
LABEL_362:
                v135 = -1;
                if ( (int)*(_DWORD *)LODWORD(v197) >= 0 )
                  v135 = *(_DWORD *)LODWORD(v197);
                v189 = v135;
                LODWORD(v197) += 4;
LABEL_365:
                v136 = 218;
                if ( v187 >= 218 )
                  v136 = v187;
                if ( v189 <= v136 )
                  goto LABEL_442;
                if ( v191 )
                {
                  p_tv_nsec = (unsigned int)v8;
                  free((int)&savedregs, (int *)v6, (int)v191);
                  v8 = (const struct timespec *)p_tv_nsec;
                }
                if ( v189 > 536870878 )
                {
LABEL_309:
                  v6 = -1;
                  __writegsdword(v190, 0x4Bu);
LABEL_26:
                  if ( (v3->tv_sec & 0x8000) == 0 )
                  {
                    v13 = (int *)v3[9].tv_sec;
                    v12 = v13[1]-- == 1;
                    if ( v12 )
                    {
                      v13[2] = 0;
                      if ( __readgsdword(0xCu) )
                        __asm { lock }
                      v12 = (*v13)-- == 1;
                      if ( !v12 )
                        _lll_unlock_wake_private(v13, (int)&savedregs, (int *)v6, v3);
                    }
                  }
                  if ( v196 )
                    MEMORY[0](v204, 0);
                  return;
                }
                v191 = (struct timespec *)v8;
                v156 = (const struct timespec *)(4 * v189 + 128);
                p_tv_nsec = (unsigned int)v156;
                v137 = _libc_alloca_cutoff((unsigned int)v156);
                if ( p_tv_nsec <= 0x1000 || v137 )
                {
                  v191 = (struct timespec *)((p_tv_nsec + 27) & 0xFFFFFFF0);
                  v138 = &v159[-((p_tv_nsec + 27) & 0xFFFFF000)];
                  if ( v159 != v138 )
                  {
                    while ( v155 != v138 )
                      ;
                  }
                  v139 = (unsigned __int16)v191 & 0xFFF;
                  if ( ((unsigned __int16)v191 & 0xFFF) != 0 )
                  {
                    v140 = alloca(v139);
                    *(_DWORD *)&v155[v139 - 4] = *(_DWORD *)&v155[v139 - 4];
                  }
                  v191 = 0;
                  v183 = (unsigned int *)&v155[p_tv_nsec];
                  v88 = (const struct timespec *)*v199;
LABEL_206:
                  p_tv_nsec = (unsigned int)v88;
                  v165 = (struct timespec *)&v88[-4];
                  v25 = (const struct timespec *)v186;
                  switch ( (unsigned int)v88 )
                  {
                    case 0u:
                    case 1u:
                    case 2u:
                    case 3u:
                    case 4u:
                    case 6u:
                    case 7u:
                    case 8u:
                    case 9u:
                    case 0xAu:
                    case 0xBu:
                    case 0xCu:
                    case 0xDu:
                    case 0xEu:
                    case 0xFu:
                    case 0x10u:
                    case 0x11u:
                    case 0x12u:
                    case 0x13u:
                    case 0x14u:
                    case 0x15u:
                    case 0x16u:
                    case 0x17u:
                    case 0x18u:
                    case 0x19u:
                    case 0x1Au:
                    case 0x1Bu:
                    case 0x1Cu:
                    case 0x1Du:
                    case 0x1Eu:
                    case 0x1Fu:
                    case 0x20u:
                    case 0x22u:
                    case 0x24u:
                    case 0x28u:
                    case 0x29u:
                    case 0x2Au:
                    case 0x2Bu:
                    case 0x2Du:
                    case 0x2Eu:
                    case 0x2Fu:
                    case 0x30u:
                    case 0x31u:
                    case 0x32u:
                    case 0x34u:
                    case 0x35u:
                    case 0x36u:
                    case 0x37u:
                    case 0x39u:
                    case 0x3Bu:
                    case 0x3Cu:
                    case 0x3Du:
                    case 0x3Eu:
                    case 0x3Fu:
                    case 0x40u:
                    case 0x42u:
                    case 0x4Bu:
                    case 0x52u:
                    case 0x56u:
                    case 0x57u:
                    case 0x59u:
                      goto LABEL_32;
                    case 5u:
                      goto LABEL_212;
                    case 0x21u:
                    case 0x41u:
                      goto LABEL_125;
                    case 0x23u:
                      goto LABEL_87;
                    case 0x25u:
                    case 0x26u:
                    case 0x27u:
                    case 0x45u:
                    case 0x46u:
                    case 0x47u:
                      goto LABEL_191;
                    case 0x2Cu:
                    case 0x4Au:
                    case 0x51u:
                      goto LABEL_42;
                    case 0x33u:
                    case 0x53u:
                      goto LABEL_104;
                    case 0x38u:
                    case 0x58u:
                      goto LABEL_217;
                    case 0x3Au:
                    case 0x54u:
                    case 0x5Au:
                      goto LABEL_43;
                    case 0x43u:
                      goto LABEL_138;
                    case 0x44u:
                    case 0x49u:
                      goto LABEL_195;
                    case 0x48u:
                      goto LABEL_137;
                    case 0x4Cu:
                      goto LABEL_211;
                    case 0x4Du:
                      goto LABEL_131;
                    case 0x4Eu:
                      goto LABEL_132;
                    case 0x4Fu:
                      goto LABEL_207;
                    case 0x50u:
                      goto LABEL_145;
                    case 0x55u:
                      goto LABEL_210;
                    default:
                      goto LABEL_86;
                  }
                }
                v183 = (unsigned int *)v191;
                v191 = (struct timespec *)malloc((const struct timespec *)p_tv_nsec);
                if ( v191 )
                {
                  v183 = (unsigned int *)((char *)v191 + p_tv_nsec);
LABEL_442:
                  v88 = (const struct timespec *)*v199;
                  goto LABEL_206;
                }
LABEL_36:
                v6 = -1;
                goto LABEL_26;
              }
LABEL_48:
              p_tv_nsec = (unsigned int)v178;
              if ( v191 )
                free((int)&savedregs, (int *)v6, (int)v191);
              break;
            case '0':
LABEL_83:
              while ( 2 )
              {
                v37 = 48;
                if ( v184 )
                  v37 = v180;
                v180 = v37;
                v25 = (const struct timespec *)v199[1];
                ++v199;
                p_tv_nsec = (unsigned int)v25;
                switch ( (unsigned int)v25 )
                {
                  case ' ':
                    goto LABEL_51;
                  case '!':
                  case '"':
                  case '$':
                  case '&':
                  case '(':
                  case ')':
                  case ',':
                  case '/':
                  case ':':
                  case ';':
                  case '<':
                  case '=':
                  case '>':
                  case '?':
                  case '@':
                  case 'B':
                  case 'D':
                  case 'H':
                  case 'J':
                  case 'K':
                  case 'M':
                  case 'N':
                  case 'O':
                  case 'P':
                  case 'Q':
                  case 'R':
                  case 'T':
                  case 'U':
                  case 'V':
                  case 'W':
                  case 'Y':
                  case '[':
                  case '\\':
                  case ']':
                  case '^':
                  case '_':
                  case '`':
                  case 'b':
                  case 'k':
                  case 'r':
                  case 'v':
                  case 'w':
                  case 'y':
                    goto LABEL_32;
                  case '#':
                    goto LABEL_81;
                  case '%':
                    goto LABEL_212;
                  case '\'':
                    goto LABEL_78;
                  case '*':
                    goto LABEL_64;
                  case '+':
                    goto LABEL_50;
                  case '-':
                    goto LABEL_82;
                  case '.':
                    goto LABEL_204;
                  case '0':
                    continue;
                  case '1':
                  case '2':
                  case '3':
                  case '4':
                  case '5':
                  case '6':
                  case '7':
                  case '8':
                  case '9':
                    goto LABEL_52;
                  case 'A':
                  case 'a':
                    goto LABEL_125;
                  case 'C':
                    goto LABEL_87;
                  case 'E':
                  case 'F':
                  case 'G':
                  case 'e':
                  case 'f':
                  case 'g':
                    goto LABEL_191;
                  case 'I':
                    goto LABEL_80;
                  case 'L':
                  case 'j':
                  case 'q':
                    goto LABEL_42;
                  case 'S':
                  case 's':
                    goto LABEL_104;
                  case 'X':
                  case 'x':
                    goto LABEL_217;
                  case 'Z':
                  case 't':
                  case 'z':
                    goto LABEL_43;
                  case 'c':
                    goto LABEL_138;
                  case 'd':
                  case 'i':
                    goto LABEL_195;
                  case 'h':
                    goto LABEL_137;
                  case 'l':
                    goto LABEL_211;
                  case 'm':
                    goto LABEL_131;
                  case 'n':
                    goto LABEL_132;
                  case 'o':
                    goto LABEL_207;
                  case 'p':
                    goto LABEL_145;
                  case 'u':
                    goto LABEL_210;
                  default:
LABEL_86:
                    __asm { jmp     eax; jumptable 0807FF53 default case }
                    return;
                }
              }
            case '1':
            case '2':
            case '3':
            case '4':
            case '5':
            case '6':
            case '7':
            case '8':
            case '9':
LABEL_52:
              p_tv_nsec = (unsigned int)v8;
              v19 = read_int_0(&v199);
              v8 = (const struct timespec *)p_tv_nsec;
              v187 = v19;
              if ( v19 > 0x1FFFFFDE )
                goto LABEL_253;
              if ( v187 <= 217 )
                goto LABEL_61;
              v183 = (unsigned int *)p_tv_nsec;
              v160 = (const struct timespec *)(4 * v187 + 128);
              p_tv_nsec = (unsigned int)v160;
              v20 = _libc_alloca_cutoff((unsigned int)v160);
              v8 = (const struct timespec *)v183;
              if ( v20 || p_tv_nsec <= 0x1000 )
              {
                v183 = (unsigned int *)((p_tv_nsec + 27) & 0xFFFFFFF0);
                v21 = &v164[-((p_tv_nsec + 27) & 0xFFFFF000)];
                if ( v164 != v21 )
                {
                  while ( v159 != v21 )
                    ;
                }
                v22 = ((_WORD)p_tv_nsec + 27) & 0xFF0;
                if ( (((_WORD)p_tv_nsec + 27) & 0xFF0) != 0 )
                {
                  v23 = alloca(v22);
                  *(_DWORD *)&v159[v22 - 4] = *(_DWORD *)&v159[v22 - 4];
                }
                v183 = (unsigned int *)&v159[p_tv_nsec];
              }
              else
              {
                v153 = malloc((const struct timespec *)p_tv_nsec);
                v8 = (const struct timespec *)v183;
                v191 = (struct timespec *)v153;
                if ( !v153 )
                  goto LABEL_36;
                v183 = (unsigned int *)((char *)v191 + p_tv_nsec);
              }
LABEL_61:
              v24 = *v199;
              if ( *v199 != 36 )
              {
                p_tv_nsec = *v199;
                v165 = (struct timespec *)(v24 - 32);
LABEL_63:
                v25 = (const struct timespec *)v186;
                switch ( v24 )
                {
                  case 0u:
                  case 1u:
                  case 2u:
                  case 3u:
                  case 4u:
                  case 6u:
                  case 7u:
                  case 8u:
                  case 9u:
                  case 0xAu:
                  case 0xBu:
                  case 0xCu:
                  case 0xDu:
                  case 0xFu:
                  case 0x10u:
                  case 0x11u:
                  case 0x12u:
                  case 0x13u:
                  case 0x14u:
                  case 0x15u:
                  case 0x16u:
                  case 0x17u:
                  case 0x18u:
                  case 0x19u:
                  case 0x1Au:
                  case 0x1Bu:
                  case 0x1Cu:
                  case 0x1Du:
                  case 0x1Eu:
                  case 0x1Fu:
                  case 0x20u:
                  case 0x22u:
                  case 0x24u:
                  case 0x28u:
                  case 0x29u:
                  case 0x2Au:
                  case 0x2Bu:
                  case 0x2Du:
                  case 0x2Eu:
                  case 0x2Fu:
                  case 0x30u:
                  case 0x31u:
                  case 0x32u:
                  case 0x34u:
                  case 0x35u:
                  case 0x36u:
                  case 0x37u:
                  case 0x39u:
                  case 0x3Bu:
                  case 0x3Cu:
                  case 0x3Du:
                  case 0x3Eu:
                  case 0x3Fu:
                  case 0x40u:
                  case 0x42u:
                  case 0x4Bu:
                  case 0x52u:
                  case 0x56u:
                  case 0x57u:
                  case 0x59u:
                    goto LABEL_32;
                  case 5u:
                    goto LABEL_212;
                  case 0xEu:
                    goto LABEL_204;
                  case 0x21u:
                  case 0x41u:
                    goto LABEL_125;
                  case 0x23u:
                    goto LABEL_87;
                  case 0x25u:
                  case 0x26u:
                  case 0x27u:
                  case 0x45u:
                  case 0x46u:
                  case 0x47u:
                    goto LABEL_191;
                  case 0x2Cu:
                  case 0x4Au:
                  case 0x51u:
                    goto LABEL_42;
                  case 0x33u:
                  case 0x53u:
                    goto LABEL_104;
                  case 0x38u:
                  case 0x58u:
                    goto LABEL_217;
                  case 0x3Au:
                  case 0x54u:
                  case 0x5Au:
                    goto LABEL_43;
                  case 0x43u:
                    goto LABEL_138;
                  case 0x44u:
                  case 0x49u:
                    goto LABEL_195;
                  case 0x48u:
                    goto LABEL_137;
                  case 0x4Cu:
                    goto LABEL_211;
                  case 0x4Du:
                    goto LABEL_131;
                  case 0x4Eu:
                    goto LABEL_132;
                  case 0x4Fu:
                    goto LABEL_207;
                  case 0x50u:
                    goto LABEL_145;
                  case 0x55u:
                    goto LABEL_210;
                  default:
                    goto LABEL_86;
                }
              }
              goto LABEL_48;
            case 'A':
            case 'a':
LABEL_125:
              v208 = 1024;
              v205 = (unsigned int *)v189;
              v206 = v187;
              v207 = p_tv_nsec;
              LOBYTE(v208) = ((_BYTE)v181 << 7) | ((_BYTE)v179 << 6) | (16 * v177) & 0x3F | ((8 * v175) | v185 | (4 * v182) | (2 * v174)) & 0xF | (32 * v184) & 0x3F;
              v209 = v180;
              if ( v185 )
              {
                v57 = LODWORD(v197) + 12;
                v58 = *(long double *)LODWORD(v197);
                v197 = v58;
                LODWORD(v197) = v57;
                *(long double *)&v203 = v58;
              }
              else
              {
                v131 = *(_QWORD *)LODWORD(v197);
                DWORD1(v197) = *(_DWORD *)(LODWORD(v197) + 4);
                *(_QWORD *)&v203.value = v131;
                LODWORD(v197) += 8;
              }
              v202 = &v203;
              v59 = _printf_fphex(
                      (int)&GLOBAL_OFFSET_TABLE_,
                      (int)&savedregs,
                      v6,
                      (int)v3,
                      &v3->tv_sec,
                      (int)&v205,
                      (const __m128i **)&v202);
              if ( v59 >= 0 )
                goto LABEL_128;
              goto LABEL_34;
            case 'C':
              goto LABEL_87;
            case 'E':
            case 'F':
            case 'G':
            case 'e':
            case 'f':
            case 'g':
LABEL_191:
              v205 = (unsigned int *)v189;
              v206 = v187;
              v207 = p_tv_nsec;
              v209 = v180;
              v208 = (unsigned __int8)(((_BYTE)v181 << 7) | ((_BYTE)v179 << 6) | (16 * v177) & 0x3F | ((8 * v175) | v185 | (4 * v182) | (2 * v174)) & 0xF | (32 * v184) & 0x3F);
              BYTE1(v208) = (8 * v173) | 4;
              if ( v185 )
              {
                v83 = LODWORD(v197) + 12;
                v84 = *(long double *)LODWORD(v197);
                v197 = v84;
                LODWORD(v197) = v83;
                *(long double *)&v203 = v84;
              }
              else
              {
                v129 = *(_QWORD *)LODWORD(v197);
                DWORD1(v197) = *(_DWORD *)(LODWORD(v197) + 4);
                *(_QWORD *)&v203.value = v129;
                LODWORD(v197) += 8;
              }
              v201 = &v203;
              v59 = _printf_fp(
                      (unsigned int)&GLOBAL_OFFSET_TABLE_,
                      (int)&savedregs,
                      v6,
                      (unsigned int)v3,
                      v3,
                      (int)&v205,
                      (const __m128i **)&v201);
              if ( v59 < 0 )
                goto LABEL_34;
LABEL_128:
              if ( (unsigned int)v6 > 0x7FFFFFFE )
                goto LABEL_448;
              if ( 0x7FFFFFFF - v6 < (unsigned int)v59 )
                goto LABEL_253;
              v6 += v59;
              goto LABEL_95;
            case 'I':
LABEL_80:
              while ( 2 )
              {
                v34 = *++v199 - 32;
                p_tv_nsec = *v199;
                v173 = 1;
                switch ( v34 )
                {
                  case 0:
                    goto LABEL_51;
                  case 3:
                    goto LABEL_81;
                  case 5:
                    goto LABEL_212;
                  case 7:
                    goto LABEL_78;
                  case 10:
                    goto LABEL_64;
                  case 11:
                    goto LABEL_50;
                  case 13:
                    goto LABEL_82;
                  case 14:
                    goto LABEL_204;
                  case 16:
                    goto LABEL_83;
                  case 17:
                  case 18:
                  case 19:
                  case 20:
                  case 21:
                  case 22:
                  case 23:
                  case 24:
                  case 25:
                    goto LABEL_52;
                  case 33:
                  case 65:
                    goto LABEL_125;
                  case 35:
                    goto LABEL_87;
                  case 37:
                  case 38:
                  case 39:
                  case 69:
                  case 70:
                  case 71:
                    goto LABEL_191;
                  case 41:
                    continue;
                  case 44:
                  case 74:
                  case 81:
                    goto LABEL_42;
                  case 51:
                  case 83:
                    goto LABEL_104;
                  case 56:
                  case 88:
                    goto LABEL_217;
                  case 58:
                  case 84:
                  case 90:
                    goto LABEL_43;
                  case 67:
                    goto LABEL_138;
                  case 68:
                  case 73:
                    goto LABEL_195;
                  case 72:
                    goto LABEL_137;
                  case 76:
                    goto LABEL_211;
                  case 77:
                    goto LABEL_131;
                  case 78:
                    goto LABEL_132;
                  case 79:
                    goto LABEL_207;
                  case 80:
                    goto LABEL_145;
                  case 85:
                    goto LABEL_210;
                  default:
                    goto LABEL_32;
                }
              }
            case 'L':
            case 'j':
            case 'q':
LABEL_42:
              v14 = *++v199 - 32;
              p_tv_nsec = *v199;
              v182 = 1;
              v185 = 1;
              switch ( v14 )
              {
                case 5:
                  goto LABEL_212;
                case 33:
                case 65:
                  goto LABEL_125;
                case 35:
                  goto LABEL_87;
                case 37:
                case 38:
                case 39:
                case 69:
                case 70:
                case 71:
                  goto LABEL_191;
                case 51:
                case 83:
                  goto LABEL_104;
                case 56:
                case 88:
                  goto LABEL_217;
                case 67:
                  goto LABEL_138;
                case 68:
                case 73:
                  goto LABEL_195;
                case 77:
                  goto LABEL_131;
                case 78:
                  goto LABEL_132;
                case 79:
                  goto LABEL_207;
                case 80:
                  goto LABEL_145;
                case 85:
                  goto LABEL_210;
                default:
                  goto LABEL_32;
              }
            case 'S':
            case 's':
LABEL_104:
              v46 = *(_BYTE **)LODWORD(v197);
              LODWORD(v197) += 4;
              v186 = (unsigned int)v46;
              goto LABEL_105;
            case 'X':
            case 'x':
LABEL_217:
              v186 = 16;
              v89 = (unsigned __int8 *)LODWORD(v197);
              goto LABEL_208;
            case 'Z':
            case 't':
            case 'z':
LABEL_43:
              v15 = *++v199 - 32;
              p_tv_nsec = *v199;
              v182 = 0;
              v185 = 0;
              switch ( v15 )
              {
                case 5:
                  goto LABEL_212;
                case 33:
                case 65:
                  goto LABEL_125;
                case 35:
                  goto LABEL_87;
                case 37:
                case 38:
                case 39:
                case 69:
                case 70:
                case 71:
                  goto LABEL_191;
                case 51:
                case 83:
                  goto LABEL_104;
                case 56:
                case 88:
                  goto LABEL_217;
                case 67:
                  goto LABEL_138;
                case 68:
                case 73:
                  goto LABEL_195;
                case 77:
                  goto LABEL_131;
                case 78:
                  goto LABEL_132;
                case 79:
                  goto LABEL_207;
                case 80:
                  goto LABEL_145;
                case 85:
                  goto LABEL_210;
                default:
                  goto LABEL_32;
              }
            case 'c':
LABEL_138:
              if ( v182 )
              {
LABEL_87:
                v189 = v187 - 1;
                LOBYTE(p_tv_nsec) = v187 - 1 > 0;
                if ( !v184 && v187 - 1 > 0 )
                {
                  v145 = IO_wpadn((int)v3, 32, v189);
                  if ( v189 != v145 )
                    goto LABEL_34;
                  if ( (unsigned int)v6 > 0x7FFFFFFE )
                    goto LABEL_457;
                  if ( 0x7FFFFFFF - v6 < (unsigned int)v189 )
                    goto LABEL_253;
                  v6 += v189;
                }
                v38 = *(_DWORD *)LODWORD(v197);
                LODWORD(v197) += 4;
                v187 = v38;
                v39 = v3[11].tv_sec;
                if ( v39 )
                {
                  v40 = *(_DWORD **)(v39 + 16);
                  if ( (unsigned int)v40 < *(_DWORD *)(v39 + 20) )
                  {
                    *(_DWORD *)(v39 + 16) = v40 + 1;
                    v41 = v187;
                    *v40 = v187;
                    if ( v41 == -1 )
                      goto LABEL_34;
                    goto LABEL_92;
                  }
                }
              }
              else
              {
                v189 = v187 - 1;
                LOBYTE(p_tv_nsec) = v187 - 1 > 0;
                if ( !v184 && v187 - 1 > 0 )
                {
                  v150 = IO_wpadn((int)v3, 32, v187 - 1);
                  if ( v189 != v150 )
                    goto LABEL_34;
                  if ( (unsigned int)v6 > 0x7FFFFFFE )
                  {
LABEL_457:
                    v163 = &_PRETTY_FUNCTION___13526;
                    v162 = 1638;
LABEL_449:
                    _assert_fail(
                      (int)"(unsigned int) done < (unsigned int) INT_MAX",
                      (int)"vfprintf.c",
                      v162,
                      (int)v163);
                  }
                  if ( 0x7FFFFFFF - v6 < (unsigned int)v189 )
                    goto LABEL_253;
                  v6 += v189;
                }
                v64 = (unsigned __int8)*(_BYTE *)LODWORD(v197);
                LODWORD(v197) += 4;
                v65 = btowc(v64);
                v66 = v3[11].tv_sec;
                v187 = v65;
                if ( v66 )
                {
                  v67 = *(_DWORD **)(v66 + 16);
                  if ( (unsigned int)v67 < *(_DWORD *)(v66 + 20) )
                  {
                    *(_DWORD *)(v66 + 16) = v67 + 1;
                    v68 = v187;
                    *v67 = v187;
                    if ( v68 == -1 )
                      goto LABEL_34;
                    goto LABEL_92;
                  }
                }
              }
              if ( _woverflow(v3, v187) == -1 )
                goto LABEL_34;
LABEL_92:
              if ( v6 == 0x7FFFFFFF )
                goto LABEL_34;
              ++v6;
              if ( v184 && (_BYTE)p_tv_nsec )
              {
                v132 = IO_wpadn((int)v3, 32, v189);
                if ( v189 != v132 )
                  goto LABEL_34;
                if ( (unsigned int)v6 > 0x7FFFFFFE )
                  goto LABEL_457;
                if ( 0x7FFFFFFF - v6 < (unsigned int)v189 )
                  goto LABEL_253;
                v6 += v189;
              }
              goto LABEL_95;
            case 'd':
            case 'i':
LABEL_195:
              if ( v185 )
              {
                v186 = 10;
                v85 = *(_DWORD *)(LODWORD(v197) + 4);
                v185 = (unsigned int)v85 >> 31;
                v166 = v85 >> 31;
                v167 = v166;
                LODWORD(v168) = *(_DWORD *)LODWORD(v197) ^ v166;
                HIDWORD(v168) = v166 ^ v85;
                v168 -= __PAIR64__(v166, v166);
                LODWORD(v197) += 8;
                goto LABEL_197;
              }
              if ( v171 )
              {
                v130 = (char)*(_BYTE *)LODWORD(v197);
                LODWORD(v197) += 4;
              }
              else
              {
                if ( v174 )
                  v130 = (__int16)*(_WORD *)LODWORD(v197);
                else
                  v130 = *(_DWORD *)LODWORD(v197);
                LODWORD(v197) += 4;
              }
              v186 = 10;
              v185 = v130 >> 31;
              v69 = abs32(v130);
              v174 = v69;
              goto LABEL_147;
            case 'h':
LABEL_137:
              v63 = *++v199 - 32;
              p_tv_nsec = *v199;
              v174 = 1;
              switch ( v63 )
              {
                case 5:
                  goto LABEL_212;
                case 56:
                case 88:
                  goto LABEL_217;
                case 68:
                case 73:
                  goto LABEL_195;
                case 72:
                  v62 = *++v199 - 32;
                  p_tv_nsec = *v199;
                  v171 = 1;
                  v174 = 0;
                  switch ( v62 )
                  {
                    case 5:
                      goto LABEL_212;
                    case 33:
                    case 65:
                      goto LABEL_125;
                    case 35:
                      goto LABEL_87;
                    case 37:
                    case 38:
                    case 39:
                    case 69:
                    case 70:
                    case 71:
                      goto LABEL_191;
                    case 51:
                    case 83:
                      goto LABEL_104;
                    case 56:
                    case 88:
                      goto LABEL_217;
                    case 67:
                      goto LABEL_138;
                    case 68:
                    case 73:
                      goto LABEL_195;
                    case 77:
                      goto LABEL_131;
                    case 78:
                      goto LABEL_132;
                    case 79:
                      goto LABEL_207;
                    case 80:
                      goto LABEL_145;
                    case 85:
                      goto LABEL_210;
                    default:
                      goto LABEL_32;
                  }
                case 78:
                  goto LABEL_132;
                case 79:
                  goto LABEL_207;
                case 85:
                  goto LABEL_210;
                default:
                  goto LABEL_32;
              }
            case 'l':
LABEL_211:
              v91 = *++v199 - 32;
              p_tv_nsec = *v199;
              v182 = 1;
              switch ( v91 )
              {
                case 5:
                  goto LABEL_212;
                case 33:
                case 65:
                  goto LABEL_125;
                case 35:
                  goto LABEL_87;
                case 37:
                case 38:
                case 39:
                case 69:
                case 70:
                case 71:
                  goto LABEL_191;
                case 51:
                case 83:
                  goto LABEL_104;
                case 56:
                case 88:
                  goto LABEL_217;
                case 67:
                  goto LABEL_138;
                case 68:
                case 73:
                  goto LABEL_195;
                case 76:
                  goto LABEL_42;
                case 77:
                  goto LABEL_131;
                case 78:
                  goto LABEL_132;
                case 79:
                  goto LABEL_207;
                case 80:
                  goto LABEL_145;
                case 85:
                  goto LABEL_210;
                default:
                  goto LABEL_32;
              }
            case 'm':
LABEL_131:
              v60 = strerror_r((signed int)v188, v211, 0x3E8u);
              v182 = 0;
              v186 = (unsigned int)v60;
LABEL_105:
              if ( v186 )
              {
                if ( v182 || p_tv_nsec == 83 )
                {
                  if ( v189 != -1 )
                    goto LABEL_345;
                  v125 = wcslen((_DWORD *)v186);
                  v189 = 0;
                  v54 = v125;
                }
                else
                {
                  v205 = (unsigned int *)v186;
                  if ( v189 == -1 )
                    v47 = strlen((unsigned int *)v186);
                  else
                    v47 = strnlen((_BYTE *)v186, v189);
                  if ( v47 > 0x3FFFFFFF )
                    goto LABEL_253;
                  v189 = v47;
                  p_tv_nsec = 4 * v47;
                  v48 = _libc_alloca_cutoff(4 * v47);
                  v49 = p_tv_nsec;
                  v50 = v189;
                  if ( !v48 && p_tv_nsec > 0x1000 )
                  {
                    sub_8082185(v189, (int)&savedregs, (const struct timespec *)p_tv_nsec);
                    return;
                  }
                  p_tv_nsec = (p_tv_nsec + 27) & 0xFFFFFFF0;
                  v51 = &v164[-((v49 + 27) & 0xFFFFF000)];
                  if ( v164 != v51 )
                  {
                    while ( v159 != v51 )
                      ;
                  }
                  v52 = p_tv_nsec & 0xFFF;
                  if ( (p_tv_nsec & 0xFFF) != 0 )
                  {
                    v53 = alloca(v52);
                    *(_DWORD *)&v159[v52 - 4] = *(_DWORD *)&v159[v52 - 4];
                  }
                  v189 = 0;
                  v186 = (unsigned int)v159;
                  v210[0] = 0;
                  v210[1] = 0;
                  v54 = mbsrtowcs((int)v159, &v205, v50, v210);
                  if ( v54 == -1 )
                    goto LABEL_34;
                }
              }
              else
              {
                v106 = v189;
                v189 = 0;
                if ( v106 != -1 && v106 <= 5 )
                {
                  v54 = 0;
                  v186 = (unsigned int)&unk_80B1F74;
                  goto LABEL_259;
                }
                v54 = 6;
                v186 = (unsigned int)"(";
              }
              goto LABEL_118;
            case 'n':
LABEL_132:
              if ( (v3[7].tv_nsec & 4) != 0 && !v170 )
              {
                v151 = wcslen(v198);
                v170 = _readonly_area((unsigned int)v198, 4 * v151 + 4);
                if ( v170 < 0 )
                  _libc_fatal((unsigned __int8)&aNInWritableSeg[-135061504] + (unsigned __int8)&GLOBAL_OFFSET_TABLE_);
              }
              if ( v185 )
              {
                v61 = LODWORD(v197);
                *(_QWORD *)*(_DWORD *)LODWORD(v197) = v6;
                LODWORD(v197) = v61 + 4;
              }
              else if ( v171 )
              {
                v128 = LODWORD(v197);
                **(_BYTE **)LODWORD(v197) = v6;
                LODWORD(v197) = v128 + 4;
              }
              else
              {
                v147 = LODWORD(v197);
                v148 = *(_WORD **)LODWORD(v197);
                if ( v174 )
                  *v148 = v6;
                else
                  *(_DWORD *)v148 = v6;
                LODWORD(v197) = v147 + 4;
              }
              goto LABEL_95;
            case 'o':
LABEL_207:
              v186 = 8;
              v89 = (unsigned __int8 *)LODWORD(v197);
              goto LABEL_208;
            case 'p':
LABEL_145:
              v69 = *(_DWORD *)LODWORD(v197);
              if ( *(_DWORD *)LODWORD(v197) )
              {
                v174 = *(_DWORD *)LODWORD(v197);
                LODWORD(v197) += 4;
                v181 = 0;
                v175 = 1;
                v185 = 0;
                p_tv_nsec = 120;
                v186 = 16;
                goto LABEL_147;
              }
              v126 = 5;
              LODWORD(v197) += 4;
              v186 = (unsigned int)"(";
              if ( v189 >= 5 )
                v126 = v189;
              v189 = v126;
LABEL_345:
              v127 = wcsnlen((_DWORD *)v186, v189);
              v189 = 0;
              v54 = v127;
LABEL_118:
              v187 -= v54;
              if ( v187 >= 0 )
              {
LABEL_259:
                LOBYTE(p_tv_nsec) = v187 != 0;
                if ( !v184 && v187 )
                {
                  v185 = v54;
                  v146 = IO_wpadn((int)v3, 32, v187);
                  if ( v187 != v146 )
                    goto LABEL_34;
                  if ( (unsigned int)v6 > 0x7FFFFFFE )
                    goto LABEL_457;
                  v54 = v185;
                  if ( 0x7FFFFFFF - v6 < (unsigned int)v187 )
                    goto LABEL_253;
                  v6 += v187;
                }
                if ( v6 < 0 )
                {
LABEL_458:
                  v158 = &_PRETTY_FUNCTION___13526;
                  v157 = 1638;
LABEL_447:
                  _assert_fail((int)"(size_t) done <= (size_t) INT_MAX", (int)"vfprintf.c", v162, (int)v163);
                }
                v107 = (unsigned int *)v3[18].tv_nsec;
                if ( v193 <= (char *)v107 - (char *)v192 )
                {
                  v183 = (unsigned int *)v3[18].tv_nsec;
                  v185 = v54;
                  IO_vtable_check();
                  v107 = v183;
                  v54 = v185;
                }
                v185 = v54;
                v108 = ((int (__cdecl *)(struct timespec *, unsigned int, int))v107[7])(v3, v186, v54);
                if ( v185 != v108 )
                  goto LABEL_34;
                if ( v185 > 0x7FFFFFFF - v6 )
                  goto LABEL_253;
                v6 += v185;
                if ( v184 && (_BYTE)p_tv_nsec )
                {
                  p_tv_nsec = 0x7FFFFFFF;
                  v149 = IO_wpadn((int)v3, 32, v187);
                  if ( v187 != v149 )
                    goto LABEL_34;
                  if ( (unsigned int)v6 > 0x7FFFFFFE )
                    goto LABEL_457;
                  if ( p_tv_nsec - v6 < v187 )
                    goto LABEL_253;
                  v6 += v187;
                }
                if ( v189 )
                  free((int)&savedregs, (int *)v6, v186);
              }
              else
              {
                if ( v6 < 0 )
                  goto LABEL_458;
                v55 = v3[18].tv_nsec;
                if ( v193 <= v55 - (int)v192 )
                {
                  v189 = v3[18].tv_nsec;
                  p_tv_nsec = v54;
                  IO_vtable_check();
                  v55 = v189;
                  v54 = p_tv_nsec;
                }
                p_tv_nsec = v54;
                v56 = (const struct timespec *)(*(int (__cdecl **)(struct timespec *, unsigned int, int))(v55 + 28))(
                                                 v3,
                                                 v186,
                                                 v54);
                if ( (const struct timespec *)p_tv_nsec != v56 )
                  goto LABEL_34;
                if ( p_tv_nsec > 0x7FFFFFFF - v6 )
                  goto LABEL_253;
                v6 += p_tv_nsec;
              }
              goto LABEL_95;
            case 'u':
LABEL_210:
              v186 = 10;
              v89 = (unsigned __int8 *)LODWORD(v197);
LABEL_208:
              if ( v185 )
              {
                v90 = *(_QWORD *)v89;
                v179 = 0;
                LODWORD(v197) += 8;
                v168 = v90;
                v177 = 0;
                v185 = 0;
LABEL_197:
                if ( v189 < 0 )
                {
                  v189 = 1;
                }
                else
                {
                  if ( !v189 && !v168 )
                  {
                    if ( v186 == 8 && v175 )
                    {
                      v181 = 1;
                      v173 = 4;
                      v86 = v183 - 1;
                      *v86 = 48;
                      v182 = (int)v86;
                      v180 = 32;
                    }
                    else
                    {
                      v181 = 0;
                      v173 = 0;
                      v182 = (int)v183;
                      v180 = 32;
                    }
LABEL_203:
                    v174 = v168 != 0;
                    goto LABEL_153;
                  }
                  v180 = 32;
                }
                v182 = (int)itowa(v168, v183, v186, p_tv_nsec == 88);
                if ( v176 && v181 )
                  v182 = (int)group_number_0(v211, (_BYTE *)v182, v183, (char *)v176, (int)v172);
                if ( v186 == 10 && v173 )
                {
                  v182 = (int)i18n_number_rewrite_1((_BYTE *)v182, (int)v183, v183);
                  v173 = (int)v183 - v182;
                  v181 = ((int)v183 - v182) >> 2;
                }
                else
                {
                  v173 = (int)v183 - v182;
                  v181 = ((int)v183 - v182) >> 2;
                }
                goto LABEL_203;
              }
              if ( v171 )
              {
                v69 = *v89;
                LODWORD(v197) += 4;
                v179 = 0;
                v174 = v69;
                v177 = 0;
              }
              else
              {
                if ( v174 )
                  v69 = *(unsigned __int16 *)v89;
                else
                  v69 = *(_DWORD *)v89;
                LODWORD(v197) += 4;
                v179 = 0;
                v174 = v69;
                v177 = 0;
              }
LABEL_147:
              if ( v189 < 0 )
              {
                v189 = 1;
LABEL_271:
                v109 = "0";
                if ( p_tv_nsec == 88 )
                  v109 = "0";
                v110 = v109;
                if ( v186 == 10 )
                {
                  v165 = v3;
                  v171 = v6;
                  v182 = (int)v109;
                  v124 = v183;
                  while ( 1 )
                  {
                    *--v124 = *(_DWORD *)(v182 + 4 * (v69 % 0xA));
                    if ( v69 <= 9 )
                      break;
                    v69 /= 0xAu;
                  }
                  v182 = (int)v124;
                  v6 = v171;
                  v3 = v165;
                  if ( v176 && v181 )
                    goto LABEL_278;
                }
                else
                {
                  if ( v186 == 16 )
                  {
                    v171 = v6;
                    v113 = v183;
                    while ( 1 )
                    {
                      *--v113 = *(_DWORD *)&v110[4 * (v69 & 0xF)];
                      if ( v69 <= 0xF )
                        break;
                      v69 >>= 4;
                    }
                  }
                  else
                  {
                    v171 = v6;
                    v113 = v183;
                    while ( 1 )
                    {
                      *--v113 = *(_DWORD *)&v110[4 * (v69 & 7)];
                      if ( v69 <= 7 )
                        break;
                      v69 >>= 3;
                    }
                  }
                  v182 = (int)v113;
                  v6 = v171;
                  if ( !v176 || !v181 )
                  {
                    v111 = v183;
LABEL_287:
                    v173 = (int)v111 - v182;
                    v181 = ((int)v111 - v182) >> 2;
                    goto LABEL_153;
                  }
LABEL_278:
                  v182 = (int)group_number_0(v211, (_BYTE *)v182, v183, (char *)v176, (int)v172);
                }
                v111 = v183;
                if ( v186 == 10 && v173 )
                {
                  v112 = i18n_number_rewrite_1((_BYTE *)v182, (int)v183, v183);
                  v186 = 10;
                  v182 = (int)v112;
                  v173 = (char *)v183 - v112;
                  v181 = ((char *)v183 - v112) >> 2;
                  goto LABEL_153;
                }
                goto LABEL_287;
              }
              if ( v189 || v69 )
              {
                v180 = 32;
                goto LABEL_271;
              }
              if ( v186 == 8 && v175 )
              {
                v181 = 1;
                v175 = 1;
                v70 = v183 - 1;
                *v70 = 48;
                v182 = (int)v70;
                v173 = 4;
                v180 = 32;
              }
              else
              {
                v181 = 0;
                v173 = 0;
                v182 = (int)v183;
                v180 = 32;
              }
LABEL_153:
              if ( v189 > v181 )
              {
                v183 = (unsigned int *)(v189 - (v173 >> 2));
                v94 = 0;
                if ( (int)v183 >= 0 )
                  v94 = v189 - (v173 >> 2);
                v189 = v94;
                if ( v184 )
                {
LABEL_223:
                  if ( v185 )
                  {
                    v95 = v3[11].tv_sec;
                    if ( v95 )
                    {
                      v96 = *(_DWORD **)(v95 + 16);
                      if ( (unsigned int)v96 < *(_DWORD *)(v95 + 20) )
                      {
                        *(_DWORD *)(v95 + 16) = v96 + 1;
                        *v96 = 45;
                        goto LABEL_227;
                      }
                    }
                    v161 = 45;
LABEL_406:
                    if ( _woverflow(v3, v161) == -1 )
                      goto LABEL_34;
                    goto LABEL_227;
                  }
                  if ( v179 )
                  {
                    v114 = v3[11].tv_sec;
                    if ( !v114 || (v115 = *(_DWORD **)(v114 + 16), (unsigned int)v115 >= *(_DWORD *)(v114 + 20)) )
                    {
                      v161 = 43;
                      goto LABEL_406;
                    }
                    *(_DWORD *)(v114 + 16) = v115 + 1;
                    *v115 = 43;
LABEL_227:
                    if ( v6 == 0x7FFFFFFF )
                      goto LABEL_34;
                    --v187;
                    ++v6;
                  }
                  else if ( v177 )
                  {
                    v122 = v3[11].tv_sec;
                    if ( !v122 || (v123 = *(_DWORD **)(v122 + 16), (unsigned int)v123 >= *(_DWORD *)(v122 + 20)) )
                    {
                      v161 = 32;
                      goto LABEL_406;
                    }
                    *(_DWORD *)(v122 + 16) = v123 + 1;
                    *v123 = 32;
                    goto LABEL_227;
                  }
                  if ( v174 && v186 == 16 && v175 )
                  {
                    v97 = v3[11].tv_sec;
                    if ( v97 && (v98 = *(_DWORD **)(v97 + 16), v186 = *(_DWORD *)(v97 + 20), (unsigned int)v98 < v186) )
                    {
                      v99 = v98 + 1;
                      *(_DWORD *)(v97 + 16) = v98 + 1;
                      *v98 = 48;
                      if ( v6 == 0x7FFFFFFF )
                        goto LABEL_34;
LABEL_235:
                      if ( v186 > (unsigned int)v99 )
                      {
                        *(_DWORD *)(v97 + 16) = v99 + 1;
                        v100 = p_tv_nsec;
                        *v99 = p_tv_nsec;
                        if ( v100 == -1 )
                          goto LABEL_34;
                        goto LABEL_237;
                      }
                    }
                    else
                    {
                      if ( _woverflow(v3, 48) == -1 || v6 == 0x7FFFFFFF )
                        goto LABEL_34;
                      v97 = v3[11].tv_sec;
                      if ( v97 )
                      {
                        v99 = *(unsigned int **)(v97 + 16);
                        v186 = *(_DWORD *)(v97 + 20);
                        goto LABEL_235;
                      }
                    }
                    if ( _woverflow(v3, p_tv_nsec) == -1 )
                      goto LABEL_34;
LABEL_237:
                    if ( v6 == 2147483646 )
                      goto LABEL_34;
                    v187 -= 2;
                    v6 += 2;
                  }
                  v101 = v173 >> 2;
                  p_tv_nsec = v187 - ((v173 >> 2) + v189);
                  if ( (int)v183 > 0 )
                  {
                    v187 = v173 >> 2;
                    v118 = IO_wpadn((int)v3, 48, v189);
                    if ( v189 != v118 )
                      goto LABEL_34;
                    if ( (unsigned int)v6 > 0x7FFFFFFE )
                      goto LABEL_448;
                    v101 = v187;
                    if ( 0x7FFFFFFF - v6 < (unsigned int)v189 )
                      goto LABEL_253;
                    v6 += v189;
                  }
                  if ( v6 < 0 )
                  {
LABEL_452:
                    v163 = &_PRETTY_FUNCTION___13526;
                    v162 = 1637;
                    goto LABEL_447;
                  }
                  v102 = v3[18].tv_nsec;
                  if ( v193 <= v102 - (int)v192 )
                  {
                    v187 = v101;
                    v189 = v102;
                    IO_vtable_check();
                    v101 = v187;
                    v102 = v189;
                  }
                  v189 = v101;
                  v103 = (*(int (__cdecl **)(struct timespec *, int, int))(v102 + 28))(v3, v182, v101);
                  if ( v189 != v103 )
                    goto LABEL_34;
                  if ( v189 > 0x7FFFFFFF - v6 )
                    goto LABEL_253;
                  v6 += v189;
                  v189 = 0x7FFFFFFF;
                  if ( (int)p_tv_nsec > 0 )
                  {
                    v104 = (const struct timespec *)IO_wpadn((int)v3, 32, p_tv_nsec);
                    if ( (const struct timespec *)p_tv_nsec != v104 )
                      goto LABEL_34;
                    if ( (unsigned int)v6 > 0x7FFFFFFE )
                      goto LABEL_448;
                    if ( v189 - v6 < p_tv_nsec )
                      goto LABEL_253;
                    v6 += p_tv_nsec;
                  }
                  goto LABEL_95;
                }
                v187 -= v181 + v94;
                if ( v174 )
                {
                  LOBYTE(v171) = v175 & 1;
LABEL_162:
                  if ( v186 == 16 )
                  {
                    v74 = v187 - 2;
                    if ( !(_BYTE)v171 )
                      v74 = v187;
                    v187 = v74;
                  }
                }
              }
              else
              {
                if ( v174 )
                {
                  LOBYTE(v171) = v175 & 1;
                  if ( v186 == 8 && (v175 & 1) != 0 )
                  {
                    v71 = v183;
                    v72 = (_BYTE *)(v182 - 4);
                    *(_DWORD *)v72 = 48;
                    v182 = (int)v72;
                    v173 = (char *)v71 - v72;
                  }
                  v183 = (unsigned int *)(v189 - (v173 >> 2));
                  v73 = 0;
                  if ( (int)v183 >= 0 )
                    v73 = v183;
                  v189 = (int)v73;
                  if ( v184 )
                    goto LABEL_223;
                  v181 = v173 >> 2;
                  v187 -= (v173 >> 2) + v189;
                  goto LABEL_162;
                }
                v117 = 0;
                v183 = (unsigned int *)(v189 - (v173 >> 2));
                if ( (int)v183 >= 0 )
                  v117 = v189 - (v173 >> 2);
                v189 = v117;
                if ( v184 )
                  goto LABEL_223;
                v187 -= v181 + v189;
              }
              if ( v179 | v177 | v185 )
              {
                --v187;
                if ( v180 != 32 )
                  goto LABEL_168;
                if ( v187 <= 0 )
                {
                  v187 = 0;
                  goto LABEL_168;
                }
              }
              else
              {
                if ( v180 != 32 )
                  goto LABEL_174;
                if ( v187 <= 0 )
                {
                  v187 = 0;
                  goto LABEL_174;
                }
              }
              v116 = IO_wpadn((int)v3, 32, v187);
              if ( v116 != v187 )
                goto LABEL_34;
              if ( (unsigned int)v6 > 0x7FFFFFFE )
                goto LABEL_448;
              if ( 0x7FFFFFFF - v6 < (unsigned int)v187 )
                goto LABEL_253;
              v6 += v187;
              v187 = 0;
LABEL_168:
              if ( v185 )
              {
                v75 = v3[11].tv_sec;
                if ( v75 )
                {
                  v76 = *(_DWORD **)(v75 + 16);
                  if ( (unsigned int)v76 < *(_DWORD *)(v75 + 20) )
                  {
                    *(_DWORD *)(v75 + 16) = v76 + 1;
                    *v76 = 45;
                    goto LABEL_172;
                  }
                }
                v161 = 45;
              }
              else if ( v179 )
              {
                v120 = v3[11].tv_sec;
                if ( v120 )
                {
                  v121 = *(_DWORD **)(v120 + 16);
                  if ( (unsigned int)v121 < *(_DWORD *)(v120 + 20) )
                  {
                    *(_DWORD *)(v120 + 16) = v121 + 1;
                    *v121 = 43;
                    goto LABEL_172;
                  }
                }
                v161 = 43;
              }
              else
              {
                if ( !v177 )
                  goto LABEL_174;
                v143 = v3[11].tv_sec;
                if ( v143 )
                {
                  v144 = *(_DWORD **)(v143 + 16);
                  if ( (unsigned int)v144 < *(_DWORD *)(v143 + 20) )
                  {
                    *(_DWORD *)(v143 + 16) = v144 + 1;
                    *v144 = 32;
                    goto LABEL_172;
                  }
                }
                v161 = 32;
              }
              if ( _woverflow(v3, v161) == -1 )
                goto LABEL_34;
LABEL_172:
              if ( v6 == 0x7FFFFFFF )
                goto LABEL_34;
              ++v6;
LABEL_174:
              if ( !v174 || v186 != 16 || !v175 )
                goto LABEL_184;
              v77 = v3[11].tv_sec;
              if ( v77 && (v78 = *(_DWORD **)(v77 + 16), v186 = *(_DWORD *)(v77 + 20), (unsigned int)v78 < v186) )
              {
                v79 = v78 + 1;
                *(_DWORD *)(v77 + 16) = v78 + 1;
                *v78 = 48;
                if ( v6 == 0x7FFFFFFF )
                  goto LABEL_34;
              }
              else
              {
                if ( _woverflow(v3, 48) == -1 || v6 == 0x7FFFFFFF )
                  goto LABEL_34;
                v77 = v3[11].tv_sec;
                if ( !v77 )
                  goto LABEL_434;
                v79 = *(unsigned int **)(v77 + 16);
                v186 = *(_DWORD *)(v77 + 20);
              }
              if ( (unsigned int)v79 < v186 )
              {
                *(_DWORD *)(v77 + 16) = v79 + 1;
                v80 = p_tv_nsec;
                *v79 = p_tv_nsec;
                if ( v80 == -1 )
                  goto LABEL_34;
                goto LABEL_182;
              }
LABEL_434:
              if ( _woverflow(v3, p_tv_nsec) == -1 )
                goto LABEL_34;
LABEL_182:
              if ( v6 == 2147483646 )
                goto LABEL_34;
              v6 += 2;
LABEL_184:
              if ( v187 + v189 > 0 )
              {
                p_tv_nsec = v187 + v189;
                v119 = (const struct timespec *)IO_wpadn((int)v3, 48, v187 + v189);
                if ( (const struct timespec *)p_tv_nsec != v119 )
                  goto LABEL_34;
                if ( (unsigned int)v6 > 0x7FFFFFFE )
                {
LABEL_448:
                  v163 = &_PRETTY_FUNCTION___13526;
                  v162 = 1637;
                  goto LABEL_449;
                }
                if ( 0x7FFFFFFF - v6 < p_tv_nsec )
                  goto LABEL_253;
                v6 += p_tv_nsec;
              }
              if ( v6 < 0 )
                goto LABEL_452;
              v81 = v3[18].tv_nsec;
              if ( v193 <= v81 - (unsigned int)v192 )
              {
                p_tv_nsec = v3[18].tv_nsec;
                IO_vtable_check();
                v81 = p_tv_nsec;
              }
              v82 = (*(int (__cdecl **)(struct timespec *, int, int))(v81 + 28))(v3, v182, v181);
              if ( v181 != v82 )
                goto LABEL_34;
              if ( v181 > 0x7FFFFFFF - v6 )
                goto LABEL_253;
              v6 += v181;
LABEL_95:
              v178 = (const struct timespec *)((char *)v178 + 1);
              if ( v191 )
                free((int)&savedregs, (int *)v6, (int)v191);
              p_tv_nsec = (unsigned int)&CONTAINING_RECORD(v199++, const struct timespec, tv_sec)->tv_nsec;
              v42 = wcschrnul(v199, 37);
              v199 = v42;
              if ( v6 < 0 )
              {
                v163 = &_PRETTY_FUNCTION___13526;
                v162 = 1669;
                goto LABEL_447;
              }
              p_tv_sec = (int *)v3[18].tv_nsec;
              if ( v193 <= (char *)p_tv_sec - (char *)v192 )
              {
                v191 = (struct timespec *)v3[18].tv_nsec;
                IO_vtable_check();
                v42 = v199;
                p_tv_sec = &v191->tv_sec;
              }
              v44 = (int *)((int (__cdecl *)(struct timespec *, unsigned int, int))p_tv_sec[7])(
                             v3,
                             p_tv_nsec,
                             (int)((int)v42 - p_tv_nsec) >> 2);
              v7 = v199;
              v191 = (struct timespec *)v44;
              v45 = (int)((int)v199 - p_tv_nsec) >> 2;
              if ( (int *)v45 != v44 )
                goto LABEL_36;
              if ( v45 > 0x7FFFFFFF - v6 )
                goto LABEL_309;
              v6 += v45;
              if ( !*v199 )
                goto LABEL_26;
              continue;
            default:
              v191 = 0;
              goto LABEL_32;
          }
          break;
        }
      }
      v6 = printf_positional_0(
             &v3->tv_sec,
             v198,
             v170,
             SLODWORD(v197),
             (int)&v200,
             v6,
             p_tv_nsec,
             (unsigned int)v194,
             v211,
             v188,
             v176,
             v172,
             v161);
      goto LABEL_26;
    }
  }
}
// 808131D: conditional instruction was optimized away because %var_494.4==8
// 80CE000: using guessed type _TBYTE GLOBAL_OFFSET_TABLE_;
// 80CEFA0: using guessed type int _start___libc_IO_vtables[24];
// 80CF2F4: using guessed type int (*_start___libc_atexit)();
// 80CFFD4: using guessed type int _printf_function_table;
// 80CFFD8: using guessed type int _printf_modifier_table;
// 80CFFEC: using guessed type int _printf_va_arg_table;
// 807F7D0: using guessed type int var_404[250];
// 807F7D0: using guessed type long double var_43C;

//----- (08082185) --------------------------------------------------------
void __usercall sub_8082185(int a1@<edx>, int a2@<ebp>, const struct timespec *a3@<ecx>)
{
  int *v3; // eax

  *(_DWORD *)(a2 - 1136) = a1;
  v3 = malloc(a3);
  *(_DWORD *)(a2 - 1172) = v3;
  if ( v3 )
  {
    *(_DWORD *)(a2 - 1160) = 1;
    JUMPOUT(0x80804B0);
  }
  JUMPOUT(0x807FBB8);
}
// 80821B5: control flows out of bounds to 80804B0
// 808219F: control flows out of bounds to 807FBB8

//----- (080822D0) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
int __usercall buffered_vfprintf_0@<eax>(struct timespec *a1@<eax>, int *a2@<edx>, int a3@<ecx>)
{
  int tv_nsec; // eax
  int v7; // eax
  _DWORD *v8; // eax
  int v9; // edx
  unsigned int v10; // ebp
  int v11; // eax
  int *tv_sec; // edx
  bool v16; // zf
  int v17; // [esp-188h] [ebp-8198h]
  int v18; // [esp-180h] [ebp-8190h]
  int (__usercall *v19)@<eax>(int@<ebp>, int *@<edi>, const struct timespec *@<esi>, int); // [esp-17Ch] [ebp-818Ch]
  struct timespec *v20; // [esp-178h] [ebp-8188h]
  struct timespec v21; // [esp-16Ch] [ebp-817Ch] BYREF
  int v22; // [esp-130h] [ebp-8140h]
  int v23; // [esp-124h] [ebp-8134h]
  _DWORD *v24; // [esp-114h] [ebp-8124h]
  int v25; // [esp-104h] [ebp-8114h]
  void *v26; // [esp-D8h] [ebp-80E8h]
  _DWORD v27[49]; // [esp-D4h] [ebp-80E4h] BYREF
  _BYTE v28[16]; // [esp-10h] [ebp-8020h] BYREF
  char v29; // [esp+0h] [ebp-8010h] BYREF
  int v30; // [esp+1000h] [ebp-7010h] BYREF
  unsigned int v31; // [esp+7FF0h] [ebp-20h] BYREF

  while ( &v29 != (char *)(&v30 - 0x2000) )
    ;
  v31 = __readgsdword(0x14u);
  if ( IO_fwide(a1, 1) != 1 )
    return -1;
  v27[45] = a1;
  v24 = v27;
  v27[4] = v28;
  v27[3] = v28;
  v27[5] = &v31;
  tv_nsec = a1[7].tv_nsec;
  v25 = 1;
  v22 = tv_nsec;
  v21.tv_sec = -72515580;
  v23 = 0;
  v26 = &IO_helper_jumps_0;
  vfwprintf(&v21, a2, a3);
  v17 = v7;
  v20 = a1;
  v19 = funlockfile;
  if ( (a1->tv_sec & 0x8000) != 0 )
  {
    v8 = v24;
    v9 = v24[4] - v24[3];
    if ( v9 <= 0 )
      return v17;
  }
  else
  {
    _EDX = (int *)a1[9].tv_sec;
    v10 = __readgsdword(8u);
    if ( _EDX[2] != v10 )
    {
      _ECX = 1;
      v16 = __readgsdword(0xCu) == 0;
      if ( !v16 )
        __asm { lock }
      __asm { cmpxchg [edx], ecx }
      if ( !v16 )
        _lll_lock_wait_private(0, _EDX, v10, a2);
      _EDX = (int *)a1[9].tv_sec;
      _EDX[2] = v10;
    }
    v8 = v24;
    ++_EDX[1];
    v9 = v8[4] - v8[3];
    if ( v9 <= 0 )
      goto LABEL_10;
  }
  v10 = a1[18].tv_nsec;
  v18 = v9 >> 2;
  if ( (char *)&_start___libc_atexit - (char *)_start___libc_IO_vtables <= v10 - (unsigned int)_start___libc_IO_vtables )
  {
    IO_vtable_check();
    v8 = v24;
  }
  a2 = (int *)v18;
  v16 = (*(int (__cdecl **)(struct timespec *, _DWORD, int))(v10 + 28))(a1, v8[3], v18) == v18;
  v11 = -1;
  if ( v16 )
    v11 = v17;
  v17 = v11;
LABEL_10:
  if ( (a1->tv_sec & 0x8000) == 0 )
  {
    tv_sec = (int *)a1[9].tv_sec;
    v16 = tv_sec[1]-- == 1;
    if ( v16 )
    {
      tv_sec[2] = 0;
      if ( __readgsdword(0xCu) )
        __asm { lock }
      v16 = (*tv_sec)-- == 1;
      if ( !v16 )
        _lll_unlock_wake_private(tv_sec, v10, a2, a1);
    }
  }
  return v17;
}
// 8082495: positive sp value 7000 has been found
// 808245F: conditional instruction was optimized away because %0x18.4==0
// 8082396: variable 'v7' is possibly undefined
// 80CEFA0: using guessed type int _start___libc_IO_vtables[24];
// 80CF2F4: using guessed type int (*_start___libc_atexit)();

//----- (08082540) --------------------------------------------------------
int __usercall funlockfile@<eax>(int a1@<ebp>, int *a2@<edi>, const struct timespec *a3@<esi>, int a4)
{
  int result; // eax
  int *v5; // edx
  bool v6; // zf

  result = a4;
  v5 = *(int **)(a4 + 72);
  v6 = v5[1]-- == 1;
  if ( v6 )
  {
    v5[2] = 0;
    if ( __readgsdword(0xCu) )
      __asm { lock }
    v6 = (*v5)-- == 1;
    if ( !v6 )
      return _lll_unlock_wake_private(v5, a1, a2, a3);
  }
  return result;
}

//----- (08082570) --------------------------------------------------------
int __usercall read_int_1@<eax>(_DWORD *a1@<eax>)
{
  unsigned __int8 *v1; // ebx
  int v2; // ecx
  int v3; // ebp
  bool v4; // sf
  unsigned int v5; // edx

  v1 = (unsigned __int8 *)(*a1 + 1);
  v2 = *(unsigned __int8 *)*a1 - 48;
  while ( 1 )
  {
    *a1 = v1;
    v5 = *v1 - 48;
    if ( v5 > 9 )
      break;
    if ( v2 >= 0 )
    {
      if ( v2 <= 214748364 )
      {
        v3 = 10 * v2;
        v4 = (int)(0x7FFFFFFF - v5 - 10 * v2) < 0;
        v2 = 10 * v2 + v5;
        if ( v4 != __OFSUB__(0x7FFFFFFF - v5, v3) )
          v2 = -1;
      }
      else
      {
        v2 = -1;
      }
    }
    ++v1;
  }
  return v2;
}

//----- (080825D0) --------------------------------------------------------
int __cdecl _parse_one_specmb(unsigned __int8 *a1, int a2, int a3, unsigned int *a4)
{
  unsigned __int8 *v4; // edi
  int v5; // esi
  unsigned __int8 *v6; // ebp
  int v7; // eax
  unsigned __int8 v8; // al
  int v9; // eax
  int v10; // edi
  int v11; // eax
  unsigned __int8 v12; // al
  int v13; // eax
  int v14; // edx
  int v15; // eax
  int v16; // eax
  int v17; // eax
  unsigned int v18; // eax
  unsigned __int8 *v19; // edx
  unsigned __int8 *v20; // eax
  unsigned __int8 *v21; // eax
  int v23; // eax
  unsigned __int8 *v24; // eax
  unsigned __int8 *v25; // edx
  unsigned __int8 *v26; // edx
  int v27; // eax
  unsigned int v28; // eax
  unsigned __int8 *v29; // edx
  int (__cdecl *v30)(int, int, int, int); // eax
  int v31; // eax
  unsigned int v32; // eax
  unsigned __int8 *v33; // ecx

  v4 = a1;
  v5 = a3;
  v6 = a1 + 1;
  *(_DWORD *)(a3 + 36) = -1;
  a1 = v6;
  *(_DWORD *)(v5 + 16) = 32;
  *(_WORD *)(v5 + 12) &= 0xE207u;
  v7 = *v6;
  if ( (unsigned int)(v7 - 48) <= 9 )
  {
    v18 = read_int_1(&a1);
    if ( v18 && (v19 = a1, *a1 == 36) )
    {
      v6 = ++a1;
      if ( v18 != -1 )
      {
        *(_DWORD *)(v5 + 36) = v18 - 1;
        if ( *a4 >= v18 )
          v18 = *a4;
        *a4 = v18;
      }
      LOBYTE(v7) = v19[1];
    }
    else
    {
      a1 = v6;
      LOBYTE(v7) = v4[1];
    }
  }
  v8 = v7 - 32;
  if ( v8 <= 0x29u )
    __asm { jmp     ecx }
  if ( (*(_BYTE *)(v5 + 12) & 0x20) != 0 )
    *(_DWORD *)(v5 + 16) = 32;
  *(_DWORD *)(v5 + 32) = -1;
  *(_DWORD *)(v5 + 4) = 0;
  v9 = *v6;
  if ( (_BYTE)v9 == 42 )
  {
    a1 = v6 + 1;
    if ( (unsigned int)v6[1] - 48 > 9 )
      goto LABEL_19;
    v28 = read_int_1(&a1);
    if ( v28 )
    {
      v29 = a1;
      if ( *a1 == 36 )
      {
        if ( v28 != -1 )
        {
          *(_DWORD *)(v5 + 32) = v28 - 1;
          if ( *a4 >= v28 )
            v28 = *a4;
          *a4 = v28;
        }
        a1 = v29 + 1;
      }
    }
    if ( *(int *)(v5 + 32) < 0 )
    {
LABEL_19:
      v16 = a2;
      a1 = ++v6;
      v10 = 1;
      *(_DWORD *)(v5 + 32) = a2;
      a2 = v16 + 1;
    }
    else
    {
      v6 = a1;
      v10 = 0;
    }
  }
  else
  {
    v10 = 0;
    if ( (unsigned int)(v9 - 48) <= 9 )
    {
      v15 = read_int_1(&a1);
      if ( v15 != -1 )
        *(_DWORD *)(v5 + 4) = v15;
      v6 = a1;
    }
  }
  *(_DWORD *)(v5 + 28) = -1;
  *(_DWORD *)v5 = -1;
  if ( *v6 == 46 )
  {
    a1 = v6 + 1;
    v17 = v6[1];
    if ( (_BYTE)v17 == 42 )
    {
      v26 = v6 + 2;
      a1 = v6 + 2;
      if ( (unsigned int)v6[2] - 48 > 9 )
        goto LABEL_41;
      v32 = read_int_1(&a1);
      v26 = v6 + 2;
      if ( v32 )
      {
        v33 = a1;
        if ( *a1 == 36 )
        {
          if ( v32 != -1 )
          {
            *(_DWORD *)(v5 + 28) = v32 - 1;
            if ( *a4 >= v32 )
              v32 = *a4;
            *a4 = v32;
          }
          a1 = v33 + 1;
        }
      }
      if ( *(int *)(v5 + 28) < 0 )
      {
LABEL_41:
        v27 = a2;
        ++v10;
        a1 = v26;
        v6 = v26;
        *(_DWORD *)(v5 + 28) = a2;
        a2 = v27 + 1;
        goto LABEL_9;
      }
    }
    else
    {
      if ( (unsigned int)(v17 - 48) > 9 )
      {
        *(_DWORD *)v5 = 0;
        ++v6;
        goto LABEL_9;
      }
      v23 = read_int_1(&a1);
      if ( v23 != -1 )
        *(_DWORD *)v5 = v23;
    }
    v6 = a1;
  }
LABEL_9:
  v11 = _printf_modifier_table;
  *(_DWORD *)(v5 + 12) &= 0xFDF8u;
  if ( v11 && *(_DWORD *)(v11 + 4 * *v6) )
  {
    if ( !_handle_registered_modifier_mb(&a1, v5) )
    {
      v25 = a1;
      v24 = a1 + 1;
      goto LABEL_12;
    }
    v6 = a1;
  }
  a1 = v6 + 1;
  v12 = *v6 - 76;
  if ( v12 <= 0x2Eu )
    __asm { jmp     ecx }
  v24 = v6 + 1;
  v25 = v6;
LABEL_12:
  a1 = v24;
  v13 = _printf_function_table;
  v14 = *v25;
  *(_DWORD *)(v5 + 48) = -1;
  *(_DWORD *)(v5 + 8) = v14;
  if ( v13
    && (v30 = *(int (__cdecl **)(int, int, int, int))(_printf_arginfo_table + 4 * v14)) != 0
    && (v31 = v30(v5, 1, v5 + 40, v5 + 48), v14 = *(_DWORD *)(v5 + 8), *(_DWORD *)(v5 + 44) = v31, v31 >= 0) )
  {
    if ( *(_DWORD *)(v5 + 36) == -1 && v31 )
    {
      v10 += v31;
      *(_DWORD *)(v5 + 36) = a2;
    }
  }
  else
  {
    *(_DWORD *)(v5 + 44) = 1;
    if ( (unsigned int)(v14 - 65) <= 0x37 )
      __asm { jmp     ebp }
    *(_DWORD *)(v5 + 44) = 0;
  }
  v20 = a1;
  if ( v14 )
  {
    *(_DWORD *)(v5 + 20) = a1;
    *(_DWORD *)(v5 + 24) = strchrnul((unsigned int *)v20, 37);
  }
  else
  {
    v21 = a1 - 1;
    *(_DWORD *)(v5 + 24) = a1 - 1;
    *(_DWORD *)(v5 + 20) = v21;
  }
  return v10;
}
// 80CFFD4: using guessed type int _printf_function_table;
// 80CFFD8: using guessed type int _printf_modifier_table;
// 80CFFE8: using guessed type int _printf_arginfo_table;

//----- (08082BA0) --------------------------------------------------------
int __usercall read_int_2@<eax>(_DWORD *a1@<eax>)
{
  _DWORD *v1; // ecx
  _DWORD *v2; // ebx
  unsigned int v3; // esi
  int v4; // edx
  int v5; // edx
  _DWORD *v7; // ebx

  v1 = (_DWORD *)(*a1 + 4);
  v2 = v1;
  v3 = *v1 - 48;
  v4 = *(_DWORD *)*a1 - 48;
  if ( v3 > 9 )
  {
LABEL_7:
    *a1 = v2;
    return v4;
  }
  while ( 1 )
  {
    if ( v4 < 0 )
      goto LABEL_6;
    if ( v4 <= 214748364 )
    {
      v5 = 10 * v4;
      if ( (int)(0x7FFFFFFF - v3) >= v5 )
      {
        v4 = v3 + v5;
        goto LABEL_6;
      }
    }
    v7 = v2 + 1;
    if ( (unsigned int)(*v7 - 48) > 9 )
      break;
    v1 += 2;
    v4 = -1;
    if ( (unsigned int)(*v1 - 48) > 9 )
    {
      *a1 = v1;
      return -1;
    }
LABEL_6:
    v2 = ++v1;
    v3 = *v1 - 48;
    if ( v3 > 9 )
      goto LABEL_7;
  }
  *a1 = v7;
  return -1;
}

//----- (08082C40) --------------------------------------------------------
int __cdecl _parse_one_specwc(int *a1, int a2, int a3, unsigned int *a4)
{
  int v4; // esi
  int *v5; // ebp
  __int16 v6; // ax
  int v7; // eax
  unsigned int v8; // eax
  int v9; // edx
  int v10; // eax
  int *v11; // edx
  int *v12; // edi
  int v13; // edx
  unsigned int v14; // eax
  int *v15; // edx
  int v16; // eax
  int v17; // eax
  int v18; // eax
  int v19; // eax
  int *v20; // edx
  int *v21; // edx
  int result; // eax
  int v23; // eax
  int (__cdecl *v24)(int, int, int, int); // edx
  int v25; // edx
  int v26; // eax
  int *v27; // edx
  int v28; // eax
  unsigned int v29; // eax
  int *v30; // edx
  unsigned int v31; // eax
  int *v32; // ecx
  int v33; // [esp+0h] [ebp-24h]

  v4 = a3;
  v5 = a1;
  v6 = *(_WORD *)(a3 + 12);
  *(_DWORD *)(a3 + 36) = -1;
  a1 = v5 + 1;
  v6 &= 0xE207u;
  *(_DWORD *)(v4 + 16) = 32;
  HIBYTE(v6) |= 4u;
  *(_WORD *)(v4 + 12) = v6;
  v7 = v5[1];
  if ( (unsigned int)(v7 - 48) <= 9 )
  {
    v14 = read_int_2(&a1);
    if ( v14 && (v15 = a1, *a1 == 36) )
    {
      ++a1;
      if ( v14 != -1 )
      {
        *(_DWORD *)(v4 + 36) = v14 - 1;
        if ( *a4 >= v14 )
          v14 = *a4;
        *a4 = v14;
      }
      v7 = v15[1];
    }
    else
    {
      a1 = v5 + 1;
      v7 = v5[1];
    }
  }
  v8 = v7 - 32;
  if ( v8 <= 0x29 )
    __asm { jmp     ecx }
  v12 = a1;
  if ( (*(_BYTE *)(v4 + 12) & 0x20) != 0 )
    *(_DWORD *)(v4 + 16) = 32;
  *(_DWORD *)(v4 + 32) = -1;
  *(_DWORD *)(v4 + 4) = 0;
  if ( *v12 == 42 )
  {
    v17 = v12[1];
    a1 = v12 + 1;
    if ( (unsigned int)(v17 - 48) > 9 )
      goto LABEL_29;
    v29 = read_int_2(&a1);
    if ( v29 )
    {
      v30 = a1;
      if ( *a1 == 36 )
      {
        if ( v29 != -1 )
        {
          *(_DWORD *)(v4 + 32) = v29 - 1;
          if ( *a4 >= v29 )
            v29 = *a4;
          *a4 = v29;
        }
        a1 = v30 + 1;
      }
    }
    if ( *(int *)(v4 + 32) < 0 )
    {
LABEL_29:
      v18 = a2;
      a1 = ++v12;
      v33 = 1;
      *(_DWORD *)(v4 + 32) = a2;
      a2 = v18 + 1;
    }
    else
    {
      v12 = a1;
      v33 = 0;
    }
  }
  else
  {
    v33 = 0;
    if ( (unsigned int)(*v12 - 48) <= 9 )
    {
      v16 = read_int_2(&a1);
      if ( v16 != -1 )
        *(_DWORD *)(v4 + 4) = v16;
      v12 = a1;
    }
  }
  *(_DWORD *)(v4 + 28) = -1;
  *(_DWORD *)v4 = -1;
  if ( *v12 == 46 )
  {
    v19 = v12[1];
    a1 = v12 + 1;
    if ( v19 == 42 )
    {
      v26 = v12[2];
      v27 = v12 + 2;
      a1 = v12 + 2;
      if ( (unsigned int)(v26 - 48) > 9 )
        goto LABEL_46;
      v31 = read_int_2(&a1);
      v27 = v12 + 2;
      if ( v31 )
      {
        v32 = a1;
        if ( *a1 == 36 )
        {
          if ( v31 != -1 )
          {
            *(_DWORD *)(v4 + 28) = v31 - 1;
            if ( *a4 >= v31 )
              v31 = *a4;
            *a4 = v31;
          }
          a1 = v32 + 1;
        }
      }
      if ( *(int *)(v4 + 28) < 0 )
      {
LABEL_46:
        v28 = a2;
        ++v33;
        v12 = v27;
        a1 = v27;
        *(_DWORD *)(v4 + 28) = a2;
        a2 = v28 + 1;
        goto LABEL_9;
      }
    }
    else
    {
      if ( (unsigned int)(v19 - 48) > 9 )
      {
        *(_DWORD *)v4 = 0;
        ++v12;
        goto LABEL_9;
      }
      v23 = read_int_2(&a1);
      if ( v23 != -1 )
        *(_DWORD *)v4 = v23;
    }
    v12 = a1;
  }
LABEL_9:
  v9 = _printf_modifier_table;
  *(_DWORD *)(v4 + 12) &= 0xFDF8u;
  v10 = *v12;
  if ( v9 && *(_DWORD *)(v9 + 4 * v10) )
  {
    if ( !_handle_registered_modifier_wc(&a1, v4) )
    {
      v11 = a1 + 1;
      v10 = *a1;
      goto _L51_0;
    }
    v12 = a1;
    v10 = *a1;
  }
  v11 = v12 + 1;
  a1 = v12 + 1;
  if ( (unsigned int)(v10 - 76) <= 0x2E )
    __asm { jmp     ebp }
_L51_0:
  a1 = v11;
  v13 = _printf_function_table;
  *(_DWORD *)(v4 + 8) = v10;
  *(_DWORD *)(v4 + 48) = -1;
  if ( v13
    && v10 <= 255
    && (v24 = *(int (__cdecl **)(int, int, int, int))(_printf_arginfo_table + 4 * v10)) != 0
    && (v25 = v24(v4, 1, v4 + 40, v4 + 48), *(_DWORD *)(v4 + 44) = v25, v10 = *(_DWORD *)(v4 + 8), v25 >= 0) )
  {
    if ( *(_DWORD *)(v4 + 36) == -1 && v25 )
    {
      v33 += v25;
      *(_DWORD *)(v4 + 36) = a2;
    }
  }
  else
  {
    *(_DWORD *)(v4 + 44) = 1;
    if ( (unsigned int)(v10 - 65) <= 0x37 )
      __asm { jmp     edi }
    *(_DWORD *)(v4 + 44) = 0;
  }
  v20 = a1;
  if ( v10 )
  {
    *(_DWORD *)(v4 + 20) = a1;
    *(_DWORD *)(v4 + 24) = wcschrnul(v20, 37);
    return v33;
  }
  else
  {
    v21 = a1 - 1;
    result = v33;
    *(_DWORD *)(v4 + 24) = a1 - 1;
    *(_DWORD *)(v4 + 20) = v21;
  }
  return result;
}
// 80CFFD4: using guessed type int _printf_function_table;
// 80CFFD8: using guessed type int _printf_modifier_table;
// 80CFFE8: using guessed type int _printf_arginfo_table;

//----- (08083260) --------------------------------------------------------
int __cdecl IO_file_doallocate(int *a1)
{
  int v1; // ebx
  int v2; // ebp
  int *v3; // eax
  unsigned int v5; // ebp
  _BOOL4 v6; // eax
  char v7[16]; // [esp+0h] [ebp-80h] BYREF
  int v8; // [esp+10h] [ebp-70h]
  _DWORD v9[4]; // [esp+20h] [ebp-60h]
  int v10; // [esp+34h] [ebp-4Ch]
  unsigned int v11; // [esp+60h] [ebp-20h]

  v11 = __readgsdword(0x14u);
  if ( a1[14] < 0 )
    goto LABEL_9;
  v1 = a1[37];
  if ( (char *)&_start___libc_atexit - (char *)_start___libc_IO_vtables <= (unsigned int)(v1
                                                                                        - (_DWORD)_start___libc_IO_vtables) )
    IO_vtable_check();
  if ( (*(int (__cdecl **)(int *, char *))(v1 + 72))(a1, v7) < 0 )
    goto LABEL_9;
  if ( (v8 & 0xF000) != 0x2000
    || (v9[1] & 0xFFFFF000 | (v9[0] >> 8) & 0xFFF) - 136 > 7
    && (v5 = __readgsdword(0xFFFFFFE0), v6 = isatty(a1[14]), __writegsdword(0xFFFFFFE0, v5), !v6) )
  {
    v2 = v10;
    if ( (unsigned int)(v10 - 1) <= 0x1FFE )
      goto LABEL_7;
    goto LABEL_9;
  }
  v2 = v10;
  *a1 |= 0x200u;
  if ( (unsigned int)(v2 - 1) > 0x1FFE )
LABEL_9:
    v2 = 0x2000;
LABEL_7:
  v3 = malloc((const struct timespec *)v2);
  if ( !v3 )
    return -1;
  IO_setb((int)v3 + v2, (int *)&GLOBAL_OFFSET_TABLE_, a1, (int)v3, (int)v3 + v2, 1);
  return 1;
}
// 80CE000: using guessed type _TBYTE GLOBAL_OFFSET_TABLE_;
// 80CEFA0: using guessed type int _start___libc_IO_vtables[24];
// 80CF2F4: using guessed type int (*_start___libc_atexit)();
// 8083260: using guessed type char var_80[16];

//----- (080833D0) --------------------------------------------------------
int __cdecl fputs(unsigned int *a1, const struct timespec *a2)
{
  int v2; // ebx
  bool v5; // zf
  __time_t tv_sec; // eax
  int v7; // eax
  int v8; // ecx
  int *v10; // edx
  unsigned int v11; // [esp+0h] [ebp-1Ch]
  int tv_nsec; // [esp+0h] [ebp-1Ch]
  int savedregs; // [esp+1Ch] [ebp+0h] BYREF

  v2 = strlen(a1);
  if ( (a2->tv_sec & 0x8000) == 0 )
  {
    _EDX = (int *)a2[9].tv_sec;
    v11 = __readgsdword(8u);
    if ( _EDX[2] != v11 )
    {
      _ECX = 1;
      v5 = __readgsdword(0xCu) == 0;
      if ( !v5 )
        __asm { lock }
      __asm { cmpxchg [edx], ecx }
      if ( !v5 )
        _lll_lock_wait_private(0, _EDX, (int)&savedregs, (int *)&GLOBAL_OFFSET_TABLE_);
      _EDX = (int *)a2[9].tv_sec;
      _EDX[2] = v11;
    }
    ++_EDX[1];
  }
  tv_sec = a2[13].tv_sec;
  if ( tv_sec )
  {
    if ( tv_sec != -1 )
      goto LABEL_17;
  }
  else
  {
    a2[13].tv_sec = -1;
  }
  tv_nsec = a2[18].tv_nsec;
  if ( (char *)&_start___libc_atexit - (char *)_start___libc_IO_vtables <= (unsigned int)(tv_nsec
                                                                                        - (_DWORD)_start___libc_IO_vtables) )
    IO_vtable_check();
  v7 = (*(int (__cdecl **)(const struct timespec *, unsigned int *, int))(tv_nsec + 28))(a2, a1, v2);
  v8 = 1;
  if ( v2 != v7 )
  {
LABEL_17:
    v8 = -1;
    if ( (a2->tv_sec & 0x8000) != 0 )
      return v8;
    goto LABEL_18;
  }
  if ( (a2->tv_sec & 0x8000) != 0 )
    return v8;
LABEL_18:
  v10 = (int *)a2[9].tv_sec;
  v5 = v10[1]-- == 1;
  if ( !v5 )
    return v8;
  v10[2] = 0;
  if ( __readgsdword(0xCu) )
    __asm { lock }
  v5 = (*v10)-- == 1;
  if ( !v5 )
    _lll_unlock_wake_private(v10, (int)&savedregs, (int *)&GLOBAL_OFFSET_TABLE_, a2);
  return v8;
}
// 80834D4: variable 'v8' is possibly undefined
// 80CE000: using guessed type _TBYTE GLOBAL_OFFSET_TABLE_;
// 80CEFA0: using guessed type int _start___libc_IO_vtables[24];
// 80CF2F4: using guessed type int (*_start___libc_atexit)();

//----- (08083500) --------------------------------------------------------
int __usercall IO_wfile_doallocate@<eax>(int a1@<ebp>, int *a2)
{
  int v2; // eax
  unsigned int v3; // eax
  int v4; // esi
  int *v5; // eax

  v2 = a2[7];
  if ( !v2 )
  {
    IO_file_doallocate(a2);
    v2 = a2[7];
  }
  v3 = a2[8] - v2;
  if ( (*(_BYTE *)a2 & 1) != 0 )
    v3 = (v3 + 3) >> 2;
  v4 = v3;
  v5 = malloc((const struct timespec *)(4 * v3));
  if ( !v5 )
    return -1;
  IO_wsetb(a1, a2, (int)a2, (int)v5, (int)&v5[v4], 1);
  return 1;
}

//----- (08083590) --------------------------------------------------------
int __cdecl fwrite(int a1, unsigned int a2, int a3, const struct timespec *a4)
{
  unsigned int v4; // ebx
  bool v7; // zf
  __time_t tv_sec; // eax
  int v9; // eax
  unsigned int v10; // edx
  int *v11; // edi
  int *v12; // ecx
  unsigned int v14; // [esp+0h] [ebp-1Ch]
  int tv_nsec; // [esp+0h] [ebp-1Ch]
  int savedregs; // [esp+1Ch] [ebp+0h] BYREF

  v4 = a3 * a2;
  if ( !(a3 * a2) )
    return v4;
  if ( (a4->tv_sec & 0x8000) == 0 )
  {
    _EDX = (int *)a4[9].tv_sec;
    v14 = __readgsdword(8u);
    if ( _EDX[2] != v14 )
    {
      _ECX = 1;
      v7 = __readgsdword(0xCu) == 0;
      if ( !v7 )
        __asm { lock }
      __asm { cmpxchg [edx], ecx }
      if ( !v7 )
        _lll_lock_wait_private(0, _EDX, (int)&savedregs, (int *)&GLOBAL_OFFSET_TABLE_);
      _EDX = (int *)a4[9].tv_sec;
      _EDX[2] = v14;
    }
    ++_EDX[1];
  }
  tv_sec = a4[13].tv_sec;
  if ( !tv_sec )
  {
    a4[13].tv_sec = -1;
    goto LABEL_12;
  }
  if ( tv_sec == -1 )
  {
LABEL_12:
    tv_nsec = a4[18].tv_nsec;
    if ( (char *)&_start___libc_atexit - (char *)_start___libc_IO_vtables <= (unsigned int)(tv_nsec
                                                                                          - (_DWORD)_start___libc_IO_vtables) )
      IO_vtable_check();
    v9 = (*(int (__cdecl **)(const struct timespec *, int, unsigned int))(tv_nsec + 28))(a4, a1, v4);
    v10 = v9;
    LOBYTE(v9) = v9 == -1;
    v11 = (int *)v9;
    if ( (a4->tv_sec & 0x8000) != 0 )
      goto LABEL_20;
    v12 = (int *)a4[9].tv_sec;
    v7 = v12[1]-- == 1;
    if ( !v7 )
      goto LABEL_20;
    goto LABEL_16;
  }
  if ( (a4->tv_sec & 0x8000) == 0 )
  {
    v12 = (int *)a4[9].tv_sec;
    v7 = v12[1]-- == 1;
    if ( v7 )
    {
      v11 = 0;
      v10 = 0;
LABEL_16:
      v12[2] = 0;
      if ( __readgsdword(0xCu) )
        __asm { lock }
      v7 = (*v12)-- == 1;
      if ( !v7 )
        _lll_unlock_wake_private(v12, (int)&savedregs, v11, a4);
LABEL_20:
      if ( v4 == v10 || (_BYTE)v11 )
        return a3;
      else
        return v10 / a2;
    }
  }
  return 0;
}
// 808367D: variable 'v10' is possibly undefined
// 80CE000: using guessed type _TBYTE GLOBAL_OFFSET_TABLE_;
// 80CEFA0: using guessed type int _start___libc_IO_vtables[24];
// 80CF2F4: using guessed type int (*_start___libc_atexit)();

//----- (08083700) --------------------------------------------------------
int __usercall getdelim@<eax>(signed int a1@<esi>, _DWORD *a2, unsigned int *a3, int a4, int *a5)
{
  int v5; // ecx
  int *v6; // eax
  _BYTE *v7; // ebx
  int *v8; // eax
  const struct timespec *v9; // edx
  _BYTE *v10; // ecx
  int v11; // eax
  unsigned int v14; // ebx
  bool v16; // zf
  int v17; // edx
  _BYTE *v18; // [esp-30h] [ebp-30h]
  int v19; // [esp-28h] [ebp-28h]
  unsigned int v20; // [esp-24h] [ebp-24h]
  unsigned int v21; // [esp-24h] [ebp-24h]
  _BYTE *v22; // [esp-24h] [ebp-24h]
  int v23; // [esp-20h] [ebp-20h]
  int v24; // [esp-4h] [ebp-4h] BYREF

  if ( !a2 || !a3 )
  {
    __writegsdword(0xFFFFFFE0, 0x16u);
    return -1;
  }
  v5 = *a5;
  if ( (*a5 & 0x8000) == 0 )
  {
    _EDX = (int *)a5[18];
    v14 = __readgsdword(8u);
    if ( _EDX[2] == v14 )
    {
      ++_EDX[1];
      if ( (v5 & 0x20) != 0 )
      {
        v19 = -1;
LABEL_25:
        v16 = _EDX[1]-- == 1;
        if ( v16 )
        {
          _EDX[2] = 0;
          if ( __readgsdword(0xCu) )
            __asm { lock }
          v16 = (*_EDX)-- == 1;
          if ( !v16 )
            _lll_unlock_wake_private(_EDX, (int)&v24, a5, (const struct timespec *)a1);
        }
        return v19;
      }
    }
    else
    {
      _ECX = 1;
      v16 = __readgsdword(0xCu) == 0;
      if ( !v16 )
        __asm { lock }
      __asm { cmpxchg [edx], ecx }
      if ( !v16 )
        _lll_lock_wait_private(0, _EDX, (int)&v24, a5);
      v17 = a5[18];
      v11 = *a5;
      *(_DWORD *)(v17 + 8) = v14;
      ++*(_DWORD *)(v17 + 4);
      if ( (v11 & 0x20) != 0 )
      {
        v19 = -1;
        goto LABEL_23;
      }
    }
LABEL_5:
    if ( !*a2 || !*a3 )
    {
      *a3 = 120;
      v6 = malloc((const struct timespec *)0x78);
      *a2 = v6;
      if ( !v6 )
      {
LABEL_22:
        v19 = -1;
        v11 = *a5;
        goto LABEL_23;
      }
    }
    v7 = (_BYTE *)a5[1];
    a1 = a5[2] - (_DWORD)v7;
    if ( a1 <= 0 )
    {
      v19 = _underflow((int)&v24, a5, a5);
      if ( v19 == -1 )
      {
LABEL_40:
        v11 = *a5;
LABEL_23:
        if ( (v11 & 0x8000) == 0 )
        {
          _EDX = (int *)a5[18];
          goto LABEL_25;
        }
        return v19;
      }
      v7 = (_BYTE *)a5[1];
      a1 = a5[2] - (_DWORD)v7;
    }
    v23 = 0;
    while ( 1 )
    {
      v10 = memchr(v7, a4, a1);
      if ( v10 )
        a1 = v10 - v7 + 1;
      if ( a1 >= 0x7FFFFFFF - v23 )
      {
        __writegsdword(0xFFFFFFE0, 0x4Bu);
        goto LABEL_22;
      }
      v19 = a1 + v23;
      v20 = a1 + v23 + 1;
      v8 = (int *)*a2;
      if ( *a3 < v20 )
      {
        v9 = (const struct timespec *)(2 * *a3);
        v18 = v10;
        if ( (unsigned int)v9 < v20 )
          v9 = (const struct timespec *)(a1 + v23 + 1);
        v21 = (unsigned int)v9;
        v8 = realloc((int)&v24, v8, v9);
        v10 = v18;
        if ( !v8 )
          goto LABEL_22;
        *a2 = v8;
        *a3 = v21;
        v7 = (_BYTE *)a5[1];
      }
      v22 = v10;
      memcpy((_BYTE *)v8 + v23, v7, a1);
      a5[1] += a1;
      if ( v22 || _underflow((int)&v24, a5, a5) == -1 )
        break;
      v7 = (_BYTE *)a5[1];
      v23 += a1;
      a1 = a5[2] - (_DWORD)v7;
    }
    *(_BYTE *)(*a2 + v19) = 0;
    goto LABEL_40;
  }
  if ( (v5 & 0x20) == 0 )
    goto LABEL_5;
  return -1;
}

//----- (080839B0) --------------------------------------------------------
_BYTE *__cdecl IO_getline_info(int *a1, _BYTE *a2, unsigned int a3, int a4, int a5, _DWORD *a6)
{
  unsigned int v6; // ebp
  signed int v7; // esi
  _BYTE *v8; // eax
  _BYTE *v9; // ebx
  int v10; // eax
  _BYTE *result; // eax
  _BYTE *v12; // edx
  unsigned int v13; // esi
  _BYTE *v14; // [esp+0h] [ebp-28h]
  int v15; // [esp+8h] [ebp-20h]

  v6 = a3;
  if ( a6 )
    *a6 = 0;
  if ( !a1[26] )
    a1[26] = -1;
  if ( !a3 )
    return 0;
  v14 = a2;
  while ( 1 )
  {
    while ( 1 )
    {
      v9 = (_BYTE *)a1[1];
      v7 = a1[2] - (_DWORD)v9;
      if ( v7 > 0 )
        break;
      v10 = _uflow(v6, a1, a1);
      if ( v10 == -1 )
      {
        result = (_BYTE *)(v14 - a2);
        if ( a6 )
          *a6 = -1;
        return result;
      }
      if ( v10 == a4 )
      {
        if ( a5 <= 0 )
        {
          if ( a5 )
            IO_sputbackc(a1, a4);
        }
        else
        {
          *v14++ = a4;
        }
        return (_BYTE *)(v14 - a2);
      }
      --v6;
      *v14++ = v10;
      if ( !v6 )
        return (_BYTE *)(v14 - a2);
    }
    if ( v7 > v6 )
      v7 = v6;
    v8 = memchr(v9, a4, v7);
    if ( v8 )
      break;
    v6 -= v7;
    memcpy(v14, v9, v7);
    v14 += v7;
    a1[1] += v7;
    if ( !v6 )
      return (_BYTE *)(v14 - a2);
  }
  v12 = v8;
  v13 = v8 - v9;
  if ( a5 >= 0 )
  {
    v12 = v8 + 1;
    v13 -= (a5 == 0) - 1;
  }
  v15 = (int)v12;
  memcpy(v14, v9, v13);
  result = (_BYTE *)(v13 + v14 - a2);
  a1[1] = v15;
  return result;
}

//----- (08083B50) --------------------------------------------------------
_BYTE *__cdecl IO_getline(int *a1, _BYTE *a2, unsigned int a3, int a4, int a5)
{
  return IO_getline_info(a1, a2, a3, a4, a5, 0);
}

//----- (08083B80) --------------------------------------------------------
int __cdecl IO_padn(int a1, int a2, int a3)
{
  char *i; // ebx
  int v4; // ebp
  int v5; // esi
  int v6; // eax
  int v7; // eax
  int v8; // edx
  int v10; // [esp+0h] [ebp-4Ch]
  int v11; // [esp+Ch] [ebp-40h]
  char v12; // [esp+1Ch] [ebp-30h] BYREF
  char v13; // [esp+2Bh] [ebp-21h] BYREF
  unsigned int v14; // [esp+2Ch] [ebp-20h]

  i = "                ";
  v4 = a3;
  v14 = __readgsdword(0x14u);
  if ( a2 != 32 )
  {
    i = (char *)&zeroes;
    if ( a2 != 48 )
    {
      for ( i = &v13; ; --i )
      {
        *i = a2;
        if ( i == &v12 )
          break;
      }
    }
  }
  if ( a3 <= 15 )
  {
    v5 = 0;
LABEL_13:
    if ( v4 > 0 )
    {
      v8 = *(_DWORD *)(a1 + 148);
      if ( (char *)&_start___libc_atexit - (char *)_start___libc_IO_vtables <= (unsigned int)(v8
                                                                                            - (_DWORD)_start___libc_IO_vtables) )
      {
        v10 = *(_DWORD *)(a1 + 148);
        IO_vtable_check();
        v8 = v10;
      }
      v5 += (*(int (__cdecl **)(int, char *, int))(v8 + 28))(a1, i, v4);
    }
  }
  else
  {
    v5 = 0;
    while ( 1 )
    {
      v7 = *(_DWORD *)(a1 + 148);
      if ( (char *)&_start___libc_atexit - (char *)_start___libc_IO_vtables <= (unsigned int)(v7
                                                                                            - (_DWORD)_start___libc_IO_vtables) )
      {
        v11 = *(_DWORD *)(a1 + 148);
        IO_vtable_check();
        v7 = v11;
      }
      v6 = (*(int (__cdecl **)(int, char *, int))(v7 + 28))(a1, i, 16);
      v5 += v6;
      if ( v6 != 16 )
        break;
      v4 -= 16;
      if ( v4 <= 15 )
        goto LABEL_13;
    }
  }
  return v5;
}
// 80CEFA0: using guessed type int _start___libc_IO_vtables[24];
// 80CF2F4: using guessed type int (*_start___libc_atexit)();

//----- (08083CB0) --------------------------------------------------------
int __cdecl IO_wpadn(int a1, int a2, int a3)
{
  char *i; // ebx
  int v4; // ebp
  int v5; // esi
  int v6; // eax
  int v7; // eax
  int v8; // edx
  int v10; // [esp+0h] [ebp-7Ch]
  int v11; // [esp+Ch] [ebp-70h]
  char v12; // [esp+1Ch] [ebp-60h] BYREF
  char v13; // [esp+58h] [ebp-24h] BYREF
  unsigned int v14; // [esp+5Ch] [ebp-20h]

  i = " ";
  v4 = a3;
  v14 = __readgsdword(0x14u);
  if ( a2 != 32 )
  {
    i = "0";
    if ( a2 != 48 )
    {
      for ( i = &v13; ; i -= 4 )
      {
        *(_DWORD *)i = a2;
        if ( i == &v12 )
          break;
      }
    }
  }
  if ( a3 <= 15 )
  {
    v5 = 0;
LABEL_13:
    if ( v4 > 0 )
    {
      v8 = *(_DWORD *)(a1 + 148);
      if ( (char *)&_start___libc_atexit - (char *)_start___libc_IO_vtables <= (unsigned int)(v8
                                                                                            - (_DWORD)_start___libc_IO_vtables) )
      {
        v10 = *(_DWORD *)(a1 + 148);
        IO_vtable_check();
        v8 = v10;
      }
      v5 += (*(int (__cdecl **)(int, char *, int))(v8 + 28))(a1, i, v4);
    }
  }
  else
  {
    v5 = 0;
    while ( 1 )
    {
      v7 = *(_DWORD *)(a1 + 148);
      if ( (char *)&_start___libc_atexit - (char *)_start___libc_IO_vtables <= (unsigned int)(v7
                                                                                            - (_DWORD)_start___libc_IO_vtables) )
      {
        v11 = *(_DWORD *)(a1 + 148);
        IO_vtable_check();
        v7 = v11;
      }
      v6 = (*(int (__cdecl **)(int, char *, int))(v7 + 28))(a1, i, 16);
      v5 += v6;
      if ( v6 != 16 )
        break;
      v4 -= 16;
      if ( v4 <= 15 )
        goto LABEL_13;
    }
  }
  return v5;
}
// 80CEFA0: using guessed type int _start___libc_IO_vtables[24];
// 80CF2F4: using guessed type int (*_start___libc_atexit)();

//----- (08083DE0) --------------------------------------------------------
int __usercall save_for_wbackup_isra_0@<eax>(_DWORD *a1@<eax>, int *a2@<edx>, int a3@<ecx>)
{
  _DWORD *v3; // eax
  int v4; // ebx
  int v5; // ecx
  int v6; // esi
  unsigned int v7; // edi
  int v8; // ecx
  _DWORD *v9; // edx
  int v10; // ebp
  int v11; // ebp
  int v12; // edi
  _BYTE *v13; // edx
  int *v15; // edx
  int v16; // eax
  int *v17; // edi
  int *v18; // edx
  _DWORD *v19; // ebx
  int v20; // ecx
  _WORD *v21; // eax
  int v22; // [esp+0h] [ebp-44h]
  int *v23; // [esp+0h] [ebp-44h]
  int *v24; // [esp+0h] [ebp-44h]
  unsigned int v25; // [esp+4h] [ebp-40h]
  int v29; // [esp+18h] [ebp-2Ch]
  int *v30; // [esp+18h] [ebp-2Ch]
  _BYTE *v31; // [esp+1Ch] [ebp-28h]
  int v32; // [esp+20h] [ebp-24h]

  v3 = (_DWORD *)*a1;
  v4 = *a2;
  v5 = a3 - *(_DWORD *)(*a2 + 8);
  v31 = *(_BYTE **)(*a2 + 8);
  v29 = *(_DWORD *)(*a2 + 32);
  v32 = *(_DWORD *)(*a2 + 40);
  v6 = v5 >> 2;
  v7 = (v32 - v29) >> 2;
  v22 = v5 >> 2;
  v25 = v7;
  if ( !v3 )
  {
    v12 = v32 - v29;
    if ( v5 >= 0 )
    {
      *(_DWORD *)(v4 + 36) = v32;
      return 0;
    }
    v13 = *(_BYTE **)(*a2 + 40);
    goto LABEL_20;
  }
  v8 = v5 >> 2;
  v9 = v3;
  do
  {
    v10 = v9[2];
    v9 = (_DWORD *)*v9;
    if ( v6 > v10 )
      v6 = v10;
  }
  while ( v9 );
  v11 = v22 - v6;
  if ( v22 - v6 <= v7 )
  {
    v25 = v7 - v11;
    v12 = 4 * (v7 - v11);
    v13 = (_BYTE *)(v12 + v29);
    if ( v6 >= 0 )
    {
      if ( !v11 )
      {
        *(_DWORD *)(v4 + 36) = v13;
        goto LABEL_10;
      }
      wmemcpy((_BYTE *)(v12 + v29), &v31[4 * v6], v22 - v6);
      v19 = (_DWORD *)*a2;
      v17 = (int *)(*(_DWORD *)(*a2 + 32) + v12);
      goto LABEL_16;
    }
LABEL_20:
    wmemmove(v13, (_BYTE *)(v32 + 4 * v6), -v6);
    wmemcpy((_BYTE *)(*(_DWORD *)(*a2 + 32) + 4 * (v25 - v6)), *(_BYTE **)(*a2 + 8), (a3 - *(_DWORD *)(*a2 + 8)) >> 2);
    v19 = (_DWORD *)*a2;
    v20 = a3;
    v17 = (int *)(*(_DWORD *)(*a2 + 32) + v12);
LABEL_17:
    v8 = (v20 - v19[2]) >> 2;
    v3 = (_DWORD *)*a1;
    v19[9] = v17;
    while ( v3 )
    {
LABEL_10:
      v3[2] -= v8;
      v3 = (_DWORD *)*v3;
    }
    return 0;
  }
  v15 = malloc((const struct timespec *)(4 * v11 + 400));
  if ( v15 )
  {
    v16 = 4 * v6;
    v17 = v15 + 100;
    if ( v6 < 0 )
    {
      v30 = v15;
      v21 = wmempcpy((_BYTE *)v15 + 400, (_BYTE *)(v32 + v16), -v6);
      wmempcpy(v21, v31, v22);
      v18 = v30;
    }
    else
    {
      v23 = v15;
      wmemcpy((_BYTE *)v15 + 400, &v31[v16], v11);
      v18 = v23;
    }
    v24 = v18;
    free(v11, v17, *(_DWORD *)(*a2 + 32));
    v19 = (_DWORD *)*a2;
    v19[8] = v24;
    v19[10] = &v24[v11 + 100];
LABEL_16:
    v20 = a3;
    goto LABEL_17;
  }
  return -1;
}

//----- (08084020) --------------------------------------------------------
int __cdecl IO_least_wmarker(int a1, int a2)
{
  _DWORD *v2; // edx
  int result; // eax
  int v4; // ecx

  v2 = *(_DWORD **)(a1 + 48);
  result = (a2 - *(_DWORD *)(*(_DWORD *)(a1 + 88) + 8)) >> 2;
  while ( v2 )
  {
    v4 = v2[2];
    v2 = (_DWORD *)*v2;
    if ( result > v4 )
      result = v4;
  }
  return result;
}

//----- (08084050) --------------------------------------------------------
_DWORD *__cdecl IO_switch_to_main_wget_area(_DWORD *a1)
{
  _DWORD *result; // eax
  int v2; // ecx
  int v3; // edx
  int v4; // ecx

  *a1 &= ~0x100u;
  result = (_DWORD *)a1[22];
  v2 = result[10];
  result[10] = result[1];
  v3 = result[8];
  result[1] = v2;
  v4 = result[2];
  *result = v3;
  result[2] = v3;
  result[8] = v4;
  return result;
}

//----- (08084080) --------------------------------------------------------
_DWORD *__cdecl IO_switch_to_wbackup_area(_DWORD *a1)
{
  _DWORD *result; // eax
  int v2; // edx
  int v3; // ebx
  int v4; // ecx

  *a1 |= 0x100u;
  result = (_DWORD *)a1[22];
  v2 = result[10];
  v3 = result[8];
  result[10] = result[1];
  v4 = result[2];
  result[1] = v2;
  result[2] = v3;
  result[8] = v4;
  *result = v2;
  return result;
}

//----- (080840B0) --------------------------------------------------------
int __usercall IO_wsetb@<eax>(int ebp0@<ebp>, int *edi0@<edi>, int a3, int a4, int a5, int a6)
{
  int v6; // edx
  int v7; // eax
  int v8; // edx
  int result; // eax
  unsigned int v10; // edx

  v6 = *(_DWORD *)(a3 + 88);
  v7 = *(_DWORD *)(a3 + 60);
  if ( *(_DWORD *)(v6 + 24) && (v7 & 8) == 0 )
  {
    free(ebp0, edi0, *(_DWORD *)(v6 + 24));
    v6 = *(_DWORD *)(a3 + 88);
    v7 = *(_DWORD *)(a3 + 60);
  }
  *(_DWORD *)(v6 + 24) = a4;
  *(_DWORD *)(v6 + 28) = a5;
  v8 = v7;
  result = v7 | 8;
  v10 = v8 & 0xFFFFFFF7;
  if ( a6 )
    result = v10;
  *(_DWORD *)(a3 + 60) = result;
  return result;
}

//----- (08084120) --------------------------------------------------------
int __cdecl IO_wdefault_pbackfail(int *a1, int a2)
{
  int *v2; // esi
  int v3; // edx
  int *v4; // edi
  unsigned int v5; // ecx
  int v6; // eax
  int result; // eax
  int v8; // edi
  int v9; // esi
  int *v10; // eax
  int v11; // ecx
  int *v12; // ecx
  int *v13; // eax
  int v14; // edx
  const struct timespec *v15; // [esp+0h] [ebp-28h]
  int v16; // [esp+0h] [ebp-28h]
  _BYTE *v17; // [esp+4h] [ebp-24h]
  int *v18; // [esp+8h] [ebp-20h]

  v2 = (int *)a1[22];
  v3 = *a1;
  v4 = (int *)*v2;
  v5 = v2[2];
  v6 = *a1 & 0x100;
  if ( *v2 <= v5 )
  {
    if ( v6 )
    {
      v17 = (_BYTE *)v2[2];
      v8 = v2[1] - v5;
      v9 = v8 >> 2;
      v15 = (const struct timespec *)(8 * (v8 >> 2));
      v10 = malloc(v15);
      if ( v10 )
      {
        v18 = v10;
        v4 = (int *)((char *)v10 + v8);
        wmemcpy(v4, v17, v9);
        free((int)a1, v4, *(_DWORD *)(a1[22] + 8));
        v2 = (int *)a1[22];
        v2[2] = (int)v18;
        *v2 = (int)v4;
        v2[1] = (int)v18 + (_DWORD)v15;
        v2[9] = (int)v4;
        goto LABEL_3;
      }
      return -1;
    }
    v13 = (int *)v2[8];
    if ( v13 )
    {
      v12 = (int *)*v2;
      v4 = (int *)v2[10];
      goto LABEL_14;
    }
    goto LABEL_15;
  }
  if ( !v6 )
  {
    v11 = a1[1];
    result = *(char *)(v11 - 1);
    if ( result == a2 )
    {
      a1[1] = v11 - 1;
      return result;
    }
    if ( v2[8] )
    {
      if ( !save_for_wbackup_isra_0(a1 + 12, a1 + 22, *v2) )
      {
        v2 = (int *)a1[22];
        v3 = *a1;
        v12 = (int *)*v2;
        v4 = (int *)v2[10];
        v13 = (int *)v2[8];
LABEL_14:
        BYTE1(v3) |= 1u;
        *a1 = v3;
        v14 = v2[1];
        v2[2] = (int)v13;
        v2[1] = (int)v4;
        v2[10] = v14;
        v2[8] = (int)v12;
        *v2 = (int)v4;
        goto LABEL_3;
      }
      return -1;
    }
LABEL_15:
    v16 = *a1;
    v13 = malloc((const struct timespec *)0x200);
    if ( v13 )
    {
      v12 = v4;
      v2[8] = (int)v13;
      v3 = v16;
      v2[10] = (int)(v13 + 128);
      v4 = v13 + 128;
      v2[9] = (int)(v13 + 128);
      goto LABEL_14;
    }
    return -1;
  }
LABEL_3:
  *v2 = (int)(v4 - 1);
  result = a2;
  *(v4 - 1) = a2;
  return result;
}

//----- (080842B0) --------------------------------------------------------
struct timespec *__usercall IO_wdefault_finish@<eax>(int a1@<ebp>, int *a2@<edi>, int a3)
{
  int *v3; // edx
  _DWORD *i; // eax

  v3 = *(int **)(a3 + 88);
  if ( v3[6] && (*(_BYTE *)(a3 + 60) & 8) == 0 )
  {
    free(a1, a2, v3[6]);
    v3 = *(int **)(a3 + 88);
    v3[7] = 0;
    v3[6] = 0;
  }
  for ( i = *(_DWORD **)(a3 + 48); i; i = (_DWORD *)*i )
    i[1] = 0;
  if ( *(_DWORD *)(a3 + 36) )
  {
    free(a1, a2, v3[8]);
    *(_DWORD *)(a3 + 36) = 0;
  }
  return IO_un_link(a1, (struct timespec *)a3);
}

//----- (08084340) --------------------------------------------------------
int __cdecl IO_wdefault_uflow(int a1)
{
  int v1; // esi
  int **v2; // edx

  v1 = *(_DWORD *)(a1 + 148);
  if ( (char *)&_start___libc_atexit - (char *)_start___libc_IO_vtables <= (unsigned int)(v1
                                                                                        - (_DWORD)_start___libc_IO_vtables) )
    IO_vtable_check();
  if ( (*(int (__cdecl **)(int))(v1 + 16))(a1) == -1 )
    return -1;
  v2 = *(int ***)(a1 + 88);
  return *(*v2)++;
}
// 80CEFA0: using guessed type int _start___libc_IO_vtables[24];
// 80CF2F4: using guessed type int (*_start___libc_atexit)();

//----- (080843B0) --------------------------------------------------------
int __cdecl _woverflow(_DWORD *a1, int a2)
{
  int v2; // ebp

  if ( !a1[26] )
    IO_fwide(a1, 1);
  v2 = a1[37];
  if ( (char *)&_start___libc_atexit - (char *)_start___libc_IO_vtables <= (unsigned int)(v2
                                                                                        - (_DWORD)_start___libc_IO_vtables) )
    IO_vtable_check();
  return (*(int (__cdecl **)(_DWORD *, int))(v2 + 12))(a1, a2);
}
// 80CEFA0: using guessed type int _start___libc_IO_vtables[24];
// 80CF2F4: using guessed type int (*_start___libc_atexit)();

//----- (08084430) --------------------------------------------------------
unsigned int __cdecl IO_wdefault_xsputn(_DWORD *a1, int *a2, unsigned int a3)
{
  unsigned int i; // ebp
  int *v4; // esi
  int v5; // edx
  _BYTE *v6; // edi
  int v7; // ebx
  _BYTE *v9; // eax
  int v10; // [esp+Ch] [ebp-20h]

  if ( !a3 )
    return 0;
  for ( i = a3; ; --i )
  {
    v4 = a2;
    v5 = a1[22];
    v6 = *(_BYTE **)(v5 + 16);
    if ( *(_DWORD *)(v5 + 20) - (int)v6 <= 0 )
      goto LABEL_4;
    v7 = (*(_DWORD *)(v5 + 20) - (int)v6) >> 2;
    if ( v7 > i )
      v7 = i;
    if ( v7 <= 20 )
    {
      v4 = a2;
      if ( v7 )
      {
        v9 = &v6[4 * v7];
        do
        {
          *(_DWORD *)v6 = *v4++;
          v6 += 4;
        }
        while ( v9 != v6 );
        *(_DWORD *)(v5 + 16) = v9;
        i -= v7;
        v4 = &a2[v7];
      }
LABEL_4:
      if ( !i )
        return a3;
      goto LABEL_5;
    }
    v10 = a1[22];
    i -= v7;
    v4 = &a2[v7];
    *(_DWORD *)(v10 + 16) = wmempcpy(v6, a2, v7);
    if ( !i )
      return a3;
LABEL_5:
    a2 = v4 + 1;
    if ( _woverflow(a1, *v4) == -1 )
      break;
  }
  a3 -= i;
  return a3;
}

//----- (08084520) --------------------------------------------------------
int __usercall IO_wdoallocbuf@<eax>(int a1@<ebp>, int *a2@<edi>, int a3)
{
  int result; // eax

  result = *(_DWORD *)(a3 + 88);
  if ( !*(_DWORD *)(result + 24) )
  {
    if ( (*(_BYTE *)a3 & 2) == 0 )
    {
      result = (*(int (__cdecl **)(int))(*(_DWORD *)(result + 176) + 52))(a3);
      if ( result != -1 )
        return result;
      result = *(_DWORD *)(a3 + 88);
    }
    return IO_wsetb(a1, a2, a3, result + 172, result + 176, 0);
  }
  return result;
}

//----- (08084580) --------------------------------------------------------
int __usercall IO_wdefault_doallocate@<eax>(int a1@<ebp>, int *a2@<edi>, int a3)
{
  int *v3; // eax

  v3 = malloc((const struct timespec *)0x2000);
  if ( !v3 )
    return -1;
  IO_wsetb(a1, a2, a3, (int)v3, (int)(v3 + 0x2000), 1);
  return 1;
}

//----- (080845E0) --------------------------------------------------------
int __cdecl IO_switch_to_wget_mode(int *a1)
{
  unsigned int *v1; // eax
  unsigned int v2; // edx
  int result; // eax
  int v4; // ecx

  v1 = (unsigned int *)a1[22];
  v2 = v1[4];
  if ( v2 > v1[3] )
  {
    result = (*(int (__cdecl **)(int *, int))(v1[44] + 12))(a1, -1);
    if ( result == -1 )
      return result;
    v1 = (unsigned int *)a1[22];
    v2 = v1[4];
  }
  v4 = *a1;
  if ( (*a1 & 0x100) != 0 )
  {
    v1[2] = v1[9];
  }
  else
  {
    v1[2] = v1[6];
    if ( v1[1] < v2 )
      v1[1] = v2;
  }
  BYTE1(v4) &= ~8u;
  *v1 = v2;
  v1[5] = v2;
  v1[3] = v2;
  result = 0;
  *a1 = v4;
  return result;
}

//----- (08084650) --------------------------------------------------------
_DWORD *__usercall IO_free_wbackup_area@<eax>(int ebp0@<ebp>, int *a2@<edi>, int *a3)
{
  int v3; // eax
  int v4; // ecx
  int v5; // edx
  int v6; // ecx
  int v7; // ecx
  _DWORD *result; // eax

  v3 = a3[22];
  v4 = *a3;
  v5 = *(_DWORD *)(v3 + 32);
  if ( (*a3 & 0x100) != 0 )
  {
    BYTE1(v4) &= ~1u;
    a2 = *(int **)(v3 + 40);
    *a3 = v4;
    v6 = *(_DWORD *)(v3 + 4);
    *(_DWORD *)(v3 + 4) = a2;
    *(_DWORD *)(v3 + 40) = v6;
    v7 = *(_DWORD *)(v3 + 8);
    *(_DWORD *)v3 = v5;
    *(_DWORD *)(v3 + 32) = v7;
    *(_DWORD *)(v3 + 8) = v5;
    v5 = v7;
  }
  free(ebp0, a2, v5);
  result = (_DWORD *)a3[22];
  result[8] = 0;
  result[10] = 0;
  result[9] = 0;
  return result;
}

//----- (080846C0) --------------------------------------------------------
int __usercall _wuflow@<eax>(int a1@<ebp>, int *a2)
{
  int *v2; // edi
  unsigned int *v3; // eax
  unsigned int v4; // edx
  unsigned int v5; // ecx
  int v6; // edx
  unsigned int v7; // ecx
  int v8; // edi

  v2 = (int *)a2[26];
  if ( (int)v2 < 0 )
    return -1;
  if ( !v2 )
  {
    if ( IO_fwide(a2, 1) != 1 )
      return -1;
    if ( !a2[26] )
      IO_fwide(a2, 1);
  }
  if ( (*a2 & 0x800) != 0 && IO_switch_to_wget_mode(a2) == -1 )
    return -1;
  v3 = (unsigned int *)a2[22];
  v4 = *v3;
  v5 = v3[1];
  if ( *v3 < v5 )
    goto LABEL_15;
  v6 = *a2;
  if ( (*a2 & 0x100) == 0 )
    goto LABEL_8;
  BYTE1(v6) &= ~1u;
  v2 = (int *)v3[10];
  *a2 = v6;
  v4 = v3[8];
  v3[10] = v5;
  v7 = v3[2];
  v3[1] = (unsigned int)v2;
  v3[2] = v4;
  v3[8] = v7;
  if ( (unsigned int)v2 > v4 )
  {
LABEL_15:
    *v3 = v4 + 4;
    return *(_DWORD *)v4;
  }
  *v3 = v4;
LABEL_8:
  if ( !a2[12] )
  {
    if ( v3[8] )
      IO_free_wbackup_area(a1, v2, a2);
    goto LABEL_10;
  }
  if ( save_for_wbackup_isra_0(a2 + 12, a2 + 22, v3[1]) )
    return -1;
LABEL_10:
  v8 = a2[37];
  if ( (char *)&_start___libc_atexit - (char *)_start___libc_IO_vtables <= (unsigned int)(v8
                                                                                        - (_DWORD)_start___libc_IO_vtables) )
    IO_vtable_check();
  return (*(int (__cdecl **)(int *))(v8 + 20))(a2);
}
// 80CEFA0: using guessed type int _start___libc_IO_vtables[24];
// 80CF2F4: using guessed type int (*_start___libc_atexit)();

//----- (08084820) --------------------------------------------------------
int __usercall _wunderflow@<eax>(int a1@<ebp>, int *a2)
{
  int *v2; // edi
  unsigned int *v3; // eax
  unsigned int v4; // edx
  unsigned int v5; // ecx
  int v6; // edx
  unsigned int v7; // ecx
  int v8; // edi

  v2 = (int *)a2[26];
  if ( (int)v2 < 0 )
    return -1;
  if ( !v2 )
  {
    if ( IO_fwide(a2, 1) != 1 )
      return -1;
    if ( !a2[26] )
      IO_fwide(a2, 1);
  }
  if ( (*a2 & 0x800) != 0 && IO_switch_to_wget_mode(a2) == -1 )
    return -1;
  v3 = (unsigned int *)a2[22];
  v4 = *v3;
  v5 = v3[1];
  if ( *v3 < v5 )
    return *(_DWORD *)v4;
  v6 = *a2;
  if ( (*a2 & 0x100) != 0 )
  {
    BYTE1(v6) &= ~1u;
    v2 = (int *)v3[10];
    *a2 = v6;
    v4 = v3[8];
    v3[10] = v5;
    v7 = v3[2];
    v3[1] = (unsigned int)v2;
    v3[2] = v4;
    v3[8] = v7;
    *v3 = v4;
    if ( (unsigned int)v2 > v4 )
      return *(_DWORD *)v4;
  }
  if ( !a2[12] )
  {
    if ( a2[9] )
      IO_free_wbackup_area(a1, v2, a2);
    goto LABEL_9;
  }
  if ( save_for_wbackup_isra_0(a2 + 12, a2 + 22, v3[1]) )
    return -1;
LABEL_9:
  v8 = a2[37];
  if ( (char *)&_start___libc_atexit - (char *)_start___libc_IO_vtables <= (unsigned int)(v8
                                                                                        - (_DWORD)_start___libc_IO_vtables) )
    IO_vtable_check();
  return (*(int (__cdecl **)(int *))(v8 + 16))(a2);
}
// 80CEFA0: using guessed type int _start___libc_IO_vtables[24];
// 80CF2F4: using guessed type int (*_start___libc_atexit)();

//----- (08084980) --------------------------------------------------------
unsigned int __cdecl IO_wdefault_xsgetn(int *a1, _WORD *a2, unsigned int a3)
{
  unsigned int v3; // ebp
  int v4; // eax
  _BYTE *v5; // esi
  int v6; // ebx
  _WORD *v8; // edi
  _BYTE *v9; // ecx

  v3 = a3;
  do
  {
    v4 = a1[22];
    v5 = *(_BYTE **)v4;
    if ( *(_DWORD *)(v4 + 4) - *(_DWORD *)v4 <= 0 )
      goto LABEL_3;
    v6 = (*(_DWORD *)(v4 + 4) - *(_DWORD *)v4) >> 2;
    if ( v6 > v3 )
      v6 = v3;
    if ( v6 <= 20 )
    {
      if ( v6 )
      {
        v8 = a2;
        v9 = &v5[4 * v6];
        do
        {
          *(_DWORD *)v8 = *(_DWORD *)v5;
          v5 += 4;
          v8 += 2;
        }
        while ( v9 != v5 );
        a2 += 2 * v6;
        v3 -= v6;
        *(_DWORD *)v4 = v9;
      }
LABEL_3:
      if ( !v3 )
        return a3;
      continue;
    }
    v3 -= v6;
    a2 = wmempcpy(a2, v5, v6);
    *(_DWORD *)a1[22] += 4 * v6;
    if ( !v3 )
      return a3;
  }
  while ( _wunderflow(v3, a1) != -1 );
  return a3 - v3;
}

//----- (08084A50) --------------------------------------------------------
int __cdecl IO_sputbackwc(_DWORD *a1, int a2)
{
  int *v2; // eax
  int v3; // edx
  int v4; // edi
  int result; // eax

  v2 = (int *)a1[22];
  v3 = *v2;
  if ( *v2 > (unsigned int)v2[2] && *(_DWORD *)(v3 - 4) == a2 )
  {
    *v2 = v3 - 4;
    result = a2;
  }
  else
  {
    v4 = a1[37];
    if ( (char *)&_start___libc_atexit - (char *)_start___libc_IO_vtables <= (unsigned int)(v4
                                                                                          - (_DWORD)_start___libc_IO_vtables) )
      IO_vtable_check();
    result = (*(int (__cdecl **)(_DWORD *, int))(v4 + 24))(a1, a2);
  }
  if ( result != -1 )
    *a1 &= ~0x10u;
  return result;
}
// 80CEFA0: using guessed type int _start___libc_IO_vtables[24];
// 80CF2F4: using guessed type int (*_start___libc_atexit)();

//----- (08084AD0) --------------------------------------------------------
int __cdecl IO_sungetwc(_DWORD *a1)
{
  int *v1; // eax
  int v2; // edx
  int result; // eax
  int v4; // esi

  v1 = (int *)a1[22];
  v2 = *v1;
  if ( *v1 <= (unsigned int)v1[2] )
  {
    v4 = a1[37];
    if ( (char *)&_start___libc_atexit - (char *)_start___libc_IO_vtables <= (unsigned int)(v4
                                                                                          - (_DWORD)_start___libc_IO_vtables) )
      IO_vtable_check();
    result = (*(int (__cdecl **)(_DWORD *, int))(v4 + 24))(a1, -1);
  }
  else
  {
    *v1 = v2 - 4;
    result = *(_DWORD *)(v2 - 4);
  }
  if ( result != -1 )
    *a1 &= ~0x10u;
  return result;
}
// 80CEFA0: using guessed type int _start___libc_IO_vtables[24];
// 80CF2F4: using guessed type int (*_start___libc_atexit)();

//----- (08084B50) --------------------------------------------------------
int __cdecl IO_adjust_wcolumn(int a1, unsigned int a2, int a3)
{
  unsigned int v3; // eax
  _DWORD *v4; // edx

  v3 = a2 + 4 * a3;
  if ( a2 < v3 )
  {
    v4 = (_DWORD *)(v3 - 4);
    if ( *(_DWORD *)(v3 - 4) == 10 )
      return 0;
    while ( a2 < (unsigned int)v4 )
    {
      if ( *--v4 == 10 )
        return ((int)(v3 - (_DWORD)v4) >> 2) - 1;
    }
  }
  return a3 + a1;
}

//----- (08084BA0) --------------------------------------------------------
int __cdecl IO_init_wmarker(int *a1, int *a2)
{
  int v2; // edx
  int *v3; // ecx
  int v4; // eax
  int v5; // eax
  int result; // eax

  v2 = *a2;
  a1[1] = (int)a2;
  if ( (v2 & 0x800) != 0 )
  {
    IO_switch_to_wget_mode(a2);
    v2 = *a2;
  }
  v3 = (int *)a2[22];
  v4 = *v3;
  if ( (v2 & 0x100) != 0 )
    v5 = v4 - v3[1];
  else
    v5 = v4 - v3[2];
  a1[2] = v5 >> 2;
  result = a2[12];
  *a1 = result;
  a2[12] = (int)a1;
  return result;
}

//----- (08084C00) --------------------------------------------------------
int __cdecl IO_wmarker_delta(int a1)
{
  _DWORD *v1; // eax
  int *v2; // ebx
  int v3; // edx
  int v4; // edx

  v1 = *(_DWORD **)(a1 + 4);
  if ( !v1 )
    return -1;
  v2 = (int *)v1[22];
  v3 = *v2;
  if ( (*v1 & 0x100) != 0 )
    v4 = v3 - v2[1];
  else
    v4 = v3 - v2[2];
  return *(_DWORD *)(a1 + 8) - (v4 >> 2);
}

//----- (08084C40) --------------------------------------------------------
int __cdecl IO_seekwmark(int *a1, int a2)
{
  int v2; // ecx
  int v3; // ebx
  _DWORD *v4; // eax
  int v5; // esi
  int v6; // edi
  int v8; // ecx
  int v9; // edx
  int v10; // esi
  int v11; // edx
  int v12; // ecx

  if ( *(int **)(a2 + 4) != a1 )
    return -1;
  v2 = *a1;
  v3 = *(_DWORD *)(a2 + 8);
  v4 = (_DWORD *)a1[22];
  v5 = *a1 & 0x100;
  if ( v3 < 0 )
  {
    v6 = v4[1];
    if ( !v5 )
    {
      BYTE1(v2) |= 1u;
      v10 = v4[8];
      *a1 = v2;
      v11 = v4[10];
      v12 = v4[2];
      v4[10] = v6;
      v4[1] = v11;
      v6 = v11;
      v4[2] = v10;
      v4[8] = v12;
    }
  }
  else
  {
    v6 = v4[2];
    if ( v5 )
    {
      BYTE1(v2) &= ~1u;
      *a1 = v2;
      v8 = v4[10];
      v4[10] = v4[1];
      v9 = v4[8];
      v4[1] = v8;
      v4[8] = v6;
      v6 = v9;
      v4[2] = v9;
    }
  }
  *v4 = v6 + 4 * v3;
  return 0;
}

//----- (08084CD0) --------------------------------------------------------
int *__usercall IO_unsave_wmarkers@<eax>(int a1@<ebp>, int *a2@<edi>, int *a3)
{
  int *result; // eax

  result = a3;
  if ( a3[12] )
    a3[12] = 0;
  if ( a3[9] )
    return IO_free_wbackup_area(a1, a2, a3);
  return result;
}

//----- (08084D10) --------------------------------------------------------
int __cdecl do_encoding(int a1)
{
  _DWORD *v1; // edx
  int result; // eax

  v1 = *(_DWORD **)(a1 + 36);
  if ( v1[13] )
    return -1;
  result = v1[10];
  if ( v1[9] != result )
    return v1[13];
  return result;
}

//----- (08084D40) --------------------------------------------------------
int do_always_noconv()
{
  return 0;
}

//----- (08084D50) --------------------------------------------------------
int __cdecl do_max_length(int a1)
{
  return *(_DWORD *)(*(_DWORD *)(a1 + 36) + 40);
}

//----- (08084D60) --------------------------------------------------------
int __cdecl do_in(_DWORD *a1, int a2, int a3, int a4, _DWORD *a5, int a6, int a7, _DWORD *a8)
{
  _DWORD *v8; // eax
  int (__cdecl *v9)(_DWORD *, _DWORD *, int *, int, _DWORD, char *, _DWORD, _DWORD); // ebx
  int v10; // eax
  int v11; // edx
  _DWORD *v13; // [esp+8h] [ebp-34h]
  char v14[4]; // [esp+14h] [ebp-28h] BYREF
  int v15[9]; // [esp+18h] [ebp-24h] BYREF

  v15[1] = __readgsdword(0x14u);
  v8 = (_DWORD *)a1[9];
  v15[0] = a3;
  v9 = (int (__cdecl *)(_DWORD *, _DWORD *, int *, int, _DWORD, char *, _DWORD, _DWORD))v8[5];
  a1[10] = a6;
  a1[11] = a7;
  a1[15] = a2;
  if ( *v8 )
    v9 = (int (__cdecl *)(_DWORD *, _DWORD *, int *, int, _DWORD, char *, _DWORD, _DWORD))(__readgsdword(0x18u) ^ __ROR4__(v9, 9));
  v13 = v8;
  dl_mcount_wrapper_check((int)v9);
  v10 = v9(v13, a1 + 10, v15, a4, 0, v14, 0, 0);
  *a5 = v15[0];
  *a8 = a1[10];
  if ( v10 == 4 )
    return 0;
  if ( v10 <= 4 )
    return 2 * (v10 != 0);
  v11 = 1;
  if ( v10 != 5 )
    return (v10 != 7) + 1;
  return v11;
}
// 8084D60: using guessed type char var_28[4];

//----- (08084E50) --------------------------------------------------------
int __cdecl do_unshift(_DWORD *a1, int a2, int a3, int a4, _DWORD *a5)
{
  _DWORD *v5; // edi
  int (__cdecl *v6)(_DWORD *, _DWORD *, _DWORD, _DWORD, _DWORD, char *, int, _DWORD); // ebx
  int v7; // eax
  int v8; // edx
  char v10[4]; // [esp+8h] [ebp-24h] BYREF
  unsigned int v11; // [esp+Ch] [ebp-20h]

  v11 = __readgsdword(0x14u);
  a1[20] = a3;
  v5 = (_DWORD *)a1[19];
  a1[21] = a4;
  v6 = (int (__cdecl *)(_DWORD *, _DWORD *, _DWORD, _DWORD, _DWORD, char *, int, _DWORD))v5[5];
  a1[25] = a2;
  if ( *v5 )
    v6 = (int (__cdecl *)(_DWORD *, _DWORD *, _DWORD, _DWORD, _DWORD, char *, int, _DWORD))(__readgsdword(0x18u) ^ __ROR4__(v6, 9));
  dl_mcount_wrapper_check((int)v6);
  v7 = v6(v5, a1 + 20, 0, 0, 0, v10, 1, 0);
  *a5 = a1[20];
  if ( v7 == 4 )
    return 0;
  if ( v7 <= 4 )
    return 2 * (v7 != 0);
  v8 = 1;
  if ( v7 != 5 )
    return (v7 != 7) + 1;
  return v8;
}
// 8084E50: using guessed type char var_24[4];

//----- (08084F20) --------------------------------------------------------
int __cdecl do_out(_DWORD *a1, int a2, int a3, int a4, _DWORD *a5, int a6, int a7, _DWORD *a8)
{
  _DWORD *v8; // eax
  int (__cdecl *v9)(_DWORD *, _DWORD *, int *, int, _DWORD, char *, _DWORD, _DWORD); // ebx
  int v10; // eax
  int v11; // edx
  _DWORD *v13; // [esp+8h] [ebp-34h]
  char v14[4]; // [esp+14h] [ebp-28h] BYREF
  int v15[9]; // [esp+18h] [ebp-24h] BYREF

  v15[1] = __readgsdword(0x14u);
  v8 = (_DWORD *)a1[19];
  v15[0] = a3;
  v9 = (int (__cdecl *)(_DWORD *, _DWORD *, int *, int, _DWORD, char *, _DWORD, _DWORD))v8[5];
  a1[20] = a6;
  a1[21] = a7;
  a1[25] = a2;
  if ( *v8 )
    v9 = (int (__cdecl *)(_DWORD *, _DWORD *, int *, int, _DWORD, char *, _DWORD, _DWORD))(__readgsdword(0x18u) ^ __ROR4__(v9, 9));
  v13 = v8;
  dl_mcount_wrapper_check((int)v9);
  v10 = v9(v13, a1 + 20, v15, a4, 0, v14, 0, 0);
  *a5 = v15[0];
  *a8 = a1[20];
  if ( v10 == 4 )
    return 0;
  if ( v10 <= 4 )
    return 2 * (v10 != 0);
  v11 = 1;
  if ( v10 != 5 )
    return (v10 != 7) + 1;
  return v11;
}
// 8084F20: using guessed type char var_28[4];

//----- (08085010) --------------------------------------------------------
int __cdecl do_length(_DWORD *a1, int a2, int a3, int a4, int a5)
{
  int v5; // edx
  _DWORD *v6; // esi
  int v7; // edx
  int *v8; // esi
  int v9; // edx
  int v10; // eax
  void *v12; // esp
  _BYTE v13[4]; // [esp-1004h] [ebp-103Ch]
  _DWORD v14[1024]; // [esp-1000h] [ebp-1038h] BYREF
  _BYTE v15[8]; // [esp+0h] [ebp-38h] BYREF
  unsigned int v16; // [esp+8h] [ebp-30h]
  int v17; // [esp+Ch] [ebp-2Ch]
  int v18; // [esp+14h] [ebp-24h] BYREF
  char v19[4]; // [esp+18h] [ebp-20h] BYREF
  unsigned int v20; // [esp+1Ch] [ebp-1Ch]

  v17 = a4;
  v20 = __readgsdword(0x14u);
  v18 = a3;
  v5 = 4 * a5 + 15;
  v16 = v5 & 0xFFFFFFF0;
  v6 = &v15[-(v5 & 0xFFFFF000)];
  if ( v15 != (_BYTE *)v6 )
  {
    while ( v14 != v6 )
      ;
  }
  v7 = v16 & 0xFFF;
  if ( (v16 & 0xFFF) != 0 )
  {
    v12 = alloca(v7);
    *(_DWORD *)&v13[v7] = *(_DWORD *)&v13[v7];
  }
  v8 = (int *)a1[9];
  a1[15] = a2;
  a1[10] = v14;
  v9 = *v8;
  a1[11] = &v14[a5];
  v10 = v8[5];
  if ( v9 )
    v10 = __readgsdword(0x18u) ^ __ROR4__(v10, 9);
  v16 = v10;
  dl_mcount_wrapper_check(v10);
  ((void (__cdecl *)(int *, _DWORD *, int *, int, _DWORD, char *, _DWORD, _DWORD))v16)(
    v8,
    a1 + 10,
    &v18,
    v17,
    0,
    v19,
    0,
    0);
  return v18 - a3;
}
// 8085010: using guessed type char var_20[4];

//----- (080850F0) --------------------------------------------------------
int __cdecl IO_fwide(_DWORD *a1, int a2)
{
  int result; // eax
  _DWORD *v3; // ebx
  int v4; // ecx
  int v5; // ecx
  int v6; // ecx
  void *v7; // ecx
  void *v8; // eax
  int v9; // eax
  int v10; // edx
  int v11; // eax
  int v12; // [esp+4h] [ebp-40h]
  void *v13[12]; // [esp+14h] [ebp-30h] BYREF

  v13[4] = (void *)__readgsdword(0x14u);
  result = a1[26];
  if ( a2 < 0 )
  {
    if ( result )
      return result;
    result = -1;
LABEL_7:
    a1[26] = result;
    return result;
  }
  if ( !result && a2 )
  {
    v3 = (_DWORD *)a1[22];
    v12 = a1[26];
    v4 = v3[1];
    a1[21] = v3 + 15;
    *v3 = v4;
    v5 = v3[3];
    v3[11] = 0;
    v3[4] = v5;
    v3[12] = 0;
    v6 = a1[22];
    *(_DWORD *)(v6 + 52) = 0;
    *(_DWORD *)(v6 + 56) = 0;
    _wcsmbs_clone_conv(v13);
    if ( v13[1] != (void *)1 )
      _assert_fail(
        (int)&GLOBAL_OFFSET_TABLE_ - 178117,
        (int)&GLOBAL_OFFSET_TABLE_ - 113312,
        119,
        (int)(&GLOBAL_OFFSET_TABLE_ - 11330));
    if ( v13[3] != (void *)1 )
      _assert_fail(
        (int)&GLOBAL_OFFSET_TABLE_ - 178095,
        (int)&GLOBAL_OFFSET_TABLE_ - 113312,
        120,
        (int)(&GLOBAL_OFFSET_TABLE_ - 11330));
    memset32(v3 + 15, v12, 0x1Cu);
    v7 = v13[2];
    v3[23] = 1;
    v3[16] = (char *)&GLOBAL_OFFSET_TABLE_ - 299232;
    v3[17] = &GLOBAL_OFFSET_TABLE_ - 29944;
    v3[18] = &GLOBAL_OFFSET_TABLE_ - 29968;
    v3[19] = &GLOBAL_OFFSET_TABLE_ - 29976;
    v3[20] = (char *)&GLOBAL_OFFSET_TABLE_ - 299712;
    v3[21] = (char *)&GLOBAL_OFFSET_TABLE_ - 298992;
    v3[22] = (char *)&GLOBAL_OFFSET_TABLE_ - 299696;
    v8 = v13[0];
    v3[29] = 1;
    v3[24] = v8;
    v9 = a1[22];
    v3[27] = 1;
    v10 = v9 + 44;
    v11 = *(_DWORD *)(v9 + 176);
    v3[33] = 1;
    v3[30] = v10;
    v3[34] = v7;
    v3[39] = 1;
    v3[37] = 9;
    v3[40] = v10;
    a1[37] = v11;
    result = 1;
    goto LABEL_7;
  }
  return result;
}
// 80CE000: using guessed type _TBYTE GLOBAL_OFFSET_TABLE_;

//----- (080852C0) --------------------------------------------------------
void __cdecl _libc_enable_asynccancel(char a1)
{
  signed __int32 i; // edx
  signed __int32 v2; // eax

  for ( i = __readgsdword(0x84u); i != (i | 2); i = v2 )
  {
    v2 = _InterlockedCompareExchange(MK_FP(__GS__, 132), i | 2, i);
    if ( i == v2 )
    {
      if ( (i & 0xFFFFFFB9 | 2) == 10 )
      {
        __writegsdword(0x228u, 0xFFFFFFFF);
        _InterlockedOr(MK_FP(__GS__, 132), 0x10u);
        MEMORY[0]();
        _libc_disable_asynccancel(a1);
      }
      return;
    }
  }
}

//----- (08085340) --------------------------------------------------------
void __cdecl _libc_disable_asynccancel(char a1)
{
  unsigned int v1; // ebx
  signed __int32 i; // ecx
  int v3; // edx
  signed __int32 v4; // eax
  int *v5; // ebx
  unsigned int v6; // eax

  if ( (a1 & 2) == 0 )
  {
    v1 = __readgsdword(8u);
    for ( i = __readgsdword(0x84u); ; i = v4 )
    {
      v3 = i & 0xFFFFFFFD;
      v4 = _InterlockedCompareExchange(MK_FP(__GS__, 132), i & 0xFFFFFFFD, i);
      if ( i == v4 )
        break;
    }
    if ( (i & 0xC) == 4 )
    {
      v5 = (int *)(v1 + 132);
      do
      {
        v6 = sys_futex(v5, 128, v3, 0, (int *)&GLOBAL_OFFSET_TABLE_, 240);
        if ( v6 > 0xFFFFF000 && (v6 < 0xFFFFFFF5 && v6 != 0 || ((1 << (v6 + 11)) & 0x881) == 0) )
          _libc_fatal((unsigned __int8)&aTheFutexFacili[-135061504] + (unsigned __int8)&GLOBAL_OFFSET_TABLE_);
        v3 = __readgsdword(0x84u);
      }
      while ( (v3 & 0xC) == 4 );
    }
  }
}
// 80CE000: using guessed type _TBYTE GLOBAL_OFFSET_TABLE_;

//----- (08085400) --------------------------------------------------------
int __cdecl _libc_scratch_buffer_grow_preserve(int a1)
{
  unsigned int v1; // edx
  _BYTE *v2; // ebp
  int *v3; // edi
  int *v4; // ecx
  int result; // eax
  int *v6; // ecx
  unsigned int v7; // [esp-14h] [ebp-34h]
  unsigned int v8; // [esp+0h] [ebp-20h]
  int *v9; // [esp+0h] [ebp-20h]

  v1 = *(_DWORD *)(a1 + 4);
  v2 = *(_BYTE **)a1;
  v3 = (int *)(2 * v1);
  if ( *(_DWORD *)a1 != a1 + 16 )
  {
    if ( v1 > (unsigned int)v3 )
    {
      __writegsdword(0xFFFFFFE0, 0xCu);
    }
    else
    {
      v4 = realloc((int)v2, v2, (const struct timespec *)(2 * v1));
      if ( v4 )
      {
LABEL_4:
        *(_DWORD *)a1 = v4;
        result = 1;
        *(_DWORD *)(a1 + 4) = v3;
        return result;
      }
      v2 = *(_BYTE **)a1;
    }
    free((int)v2, v3, (int)v2);
    *(_DWORD *)(a1 + 4) = 1024;
    *(_DWORD *)a1 = a1 + 16;
    return 0;
  }
  v8 = *(_DWORD *)(a1 + 4);
  v6 = malloc((const struct timespec *)(2 * v1));
  result = 0;
  if ( v6 )
  {
    v7 = v8;
    v9 = v6;
    memcpy(v6, v2, v7);
    v4 = v9;
    goto LABEL_4;
  }
  return result;
}

//----- (080854D0) --------------------------------------------------------
int __cdecl _libc_scratch_buffer_set_array_size(int *a1, unsigned int a2, int a3)
{
  unsigned int v3; // edi
  int result; // eax
  int *v5; // ebp
  int *v6; // edi

  v3 = a3 * a2;
  if ( (a3 | a2) >> 16 && a2 && v3 / a2 != a3 )
  {
    v6 = a1 + 4;
    if ( (int *)*a1 != a1 + 4 )
      free(a3, v6, *a1);
    *a1 = (int)v6;
    a1[1] = 1024;
    __writegsdword(0xFFFFFFE0, 0xCu);
    return 0;
  }
  else
  {
    result = 1;
    if ( a1[1] < v3 )
    {
      v5 = a1 + 4;
      if ( (int *)*a1 != a1 + 4 )
        free((int)v5, (int *)v3, *a1);
      result = (int)malloc((const struct timespec *)v3);
      if ( result )
      {
        a1[1] = v3;
        *a1 = result;
        return 1;
      }
      else
      {
        *a1 = (int)v5;
        a1[1] = 1024;
      }
    }
  }
  return result;
}

//----- (080855B0) --------------------------------------------------------
int *__cdecl strndup(_BYTE *a1, int a2)
{
  unsigned int v2; // esi
  int *result; // eax

  v2 = strnlen(a1, a2);
  result = malloc((const struct timespec *)(v2 + 1));
  if ( result )
  {
    *((_BYTE *)result + v2) = 0;
    return (int *)memcpy(result, a1, v2);
  }
  return result;
}

//----- (08085600) --------------------------------------------------------
unsigned __int8 *__cdecl strerror_r(signed int a1, _BYTE *a2, unsigned int a3)
{
  unsigned __int8 *v3; // eax
  unsigned int v5; // ebp
  _BYTE *v6; // esi
  unsigned int v7; // eax
  _WORD *v8; // eax
  _WORD *v9; // edx
  unsigned int v10; // ebp
  char *v11; // eax
  unsigned int v12; // eax
  unsigned __int8 *v13; // [esp+1Ch] [ebp-40h]
  unsigned __int8 *v14; // [esp+1Ch] [ebp-40h]
  char v15; // [esp+3Bh] [ebp-21h] BYREF
  int v16[8]; // [esp+3Ch] [ebp-20h] BYREF

  v16[0] = __readgsdword(0x14u);
  if ( a1 < 0 )
  {
    v13 = dcgettext("libc", "Unknown error ", 5u);
    v5 = strlen((unsigned int *)v13);
    v15 = 0;
    v6 = (_BYTE *)itoa_word(-a1, (int)&v15, 0xAu, 0);
    v7 = v5;
    if ( v5 > a3 )
      v7 = a3;
    v8 = mempcpy(a2, v13, v7);
    if ( v5 >= a3 )
      goto LABEL_16;
    v9 = (_WORD *)((char *)v8 + 1);
    *(_BYTE *)v8 = 45;
    v10 = v5 + 1;
    if ( a3 <= v10 )
    {
LABEL_12:
      a2[a3 - 1] = 0;
      return a2;
    }
LABEL_9:
    v11 = (char *)(a3 - v10);
    if ( a3 - v10 > (char *)v16 - v6 )
      v11 = (char *)((char *)v16 - v6);
    memcpy(v9, v6, (unsigned int)v11);
    goto LABEL_12;
  }
  if ( sys_nerr > a1 )
  {
    v3 = (unsigned __int8 *)sys_errlist[a1];
    if ( v3 )
      return dcgettext("libc", v3, 5u);
  }
  v14 = dcgettext("libc", "Unknown error ", 5u);
  v10 = strlen((unsigned int *)v14);
  v15 = 0;
  v6 = (_BYTE *)itoa_word(a1, (int)&v15, 0xAu, 0);
  v12 = v10;
  if ( a3 <= v10 )
    v12 = a3;
  v9 = mempcpy(a2, v14, v12);
  if ( a3 > v10 )
    goto LABEL_9;
LABEL_16:
  if ( a3 )
    goto LABEL_12;
  return a2;
}
// 80B941C: using guessed type int sys_nerr;

//----- (080857B0) --------------------------------------------------------
unsigned int __cdecl strnlen(_BYTE *a1, int a2)
{
  unsigned int result; // eax
  unsigned int v3; // eax
  _BYTE *v4; // edx
  _BYTE *v5; // ecx

  result = 0;
  if ( !a2 )
    return result;
  v3 = (unsigned int)&a1[a2];
  if ( __CFADD__(a1, a2) )
    v3 = -1;
  v4 = a1;
  if ( ((unsigned __int8)a1 & 3) != 0 )
  {
    if ( !*a1 )
    {
LABEL_18:
      if ( v3 > (unsigned int)v4 )
        v3 = (unsigned int)v4;
      return v3 - (_DWORD)a1;
    }
    while ( ((unsigned __int8)++v4 & 3) != 0 )
    {
      if ( !*v4 )
        goto LABEL_18;
    }
  }
  if ( v3 <= (unsigned int)v4 )
    return v3 - (_DWORD)a1;
  while ( 1 )
  {
    v5 = v4 + 4;
    if ( ((*(_DWORD *)v4 - 16843009) & 0x80808080) == 0 )
      goto LABEL_15;
    if ( !*v4 )
      break;
    if ( !v4[1] )
    {
      if ( v3 > (unsigned int)(v4 + 1) )
        v3 = (unsigned int)(v4 + 1);
      return v3 - (_DWORD)a1;
    }
    if ( !v4[2] )
    {
      if ( v3 > (unsigned int)(v4 + 2) )
        v3 = (unsigned int)(v4 + 2);
      return v3 - (_DWORD)a1;
    }
    if ( !v4[3] )
    {
      if ( v3 > (unsigned int)(v4 + 3) )
        v3 = (unsigned int)(v4 + 3);
      return v3 - (_DWORD)a1;
    }
LABEL_15:
    v4 += 4;
    if ( v3 <= (unsigned int)v5 )
      return v3 - (_DWORD)a1;
  }
  if ( v3 > (unsigned int)v4 )
    v3 = (unsigned int)v4;
  return v3 - (_DWORD)a1;
}

//----- (08085870) --------------------------------------------------------
unsigned int *__cdecl strrchr(unsigned int *a1, int a2)
{
  unsigned int *result; // eax
  unsigned int *v3; // esi
  int v4; // ecx
  __int16 v5; // dx
  int v6; // ecx
  unsigned int v7; // edx
  unsigned int v8; // edx
  unsigned int v9; // edx

  result = 0;
  v3 = a1;
  v4 = a2;
  BYTE1(v4) = a2;
  v5 = v4;
  v6 = v4 << 16;
  LOWORD(v6) = v5;
  if ( ((unsigned __int8)a1 & 3) == 0 )
  {
    while ( 1 )
    {
LABEL_27:
      v7 = *v3;
      if ( *v3 < 0x1010101 || (v7 ^ (*v3 - 16843009) | 0xFEFEFEFF) != -1 )
      {
LABEL_47:
        if ( (_BYTE)v7 == (_BYTE)v6 )
          result = v3;
        if ( (_BYTE)v7 )
        {
          if ( BYTE1(v7) == (_BYTE)v6 )
            result = (unsigned int *)((char *)v3 + 1);
          if ( BYTE1(v7) )
          {
            v9 = HIWORD(v7);
            if ( (_BYTE)v9 == (_BYTE)v6 )
              result = (unsigned int *)((char *)v3 + 2);
            if ( (_BYTE)v9 && BYTE1(v9) == (_BYTE)v6 )
              return (unsigned int *)((char *)v3 + 3);
          }
        }
        return result;
      }
      v8 = v6 ^ v7;
      if ( v8 < 0x1010101 )
      {
        --v3;
LABEL_15:
        --v3;
LABEL_16:
        --v3;
LABEL_17:
        if ( (v8 & 0xFF000000) == 0 )
        {
          result = (unsigned int *)((char *)v3 + 15);
          goto LABEL_26;
        }
        goto LABEL_22;
      }
      if ( (v8 ^ (v8 - 16843009) | 0xFEFEFEFF) != -1 )
        break;
      v7 = v3[1];
      if ( v7 < 0x1010101 || (v7 ^ (v7 - 16843009) | 0xFEFEFEFF) != -1 )
        goto LABEL_46;
      v8 = v6 ^ v7;
      if ( v8 < 0x1010101 )
        goto LABEL_15;
      if ( (v8 ^ (v8 - 16843009) | 0xFEFEFEFF) != -1 )
        goto LABEL_20;
      v7 = v3[2];
      if ( v7 < 0x1010101 || (v7 ^ (v7 - 16843009) | 0xFEFEFEFF) != -1 )
        goto LABEL_45;
      v8 = v6 ^ v7;
      if ( v8 < 0x1010101 )
        goto LABEL_16;
      if ( (v8 ^ (v8 - 16843009) | 0xFEFEFEFF) == -1 )
      {
        v7 = v3[3];
        if ( v7 < 0x1010101 || (v7 ^ (v7 - 16843009) | 0xFEFEFEFF) != -1 )
        {
          ++v3;
LABEL_45:
          ++v3;
LABEL_46:
          ++v3;
          goto LABEL_47;
        }
        v8 = v6 ^ v7;
        if ( v8 >= 0x1010101 )
        {
          if ( (v8 ^ (v8 - 16843009) | 0xFEFEFEFF) == -1 )
            goto LABEL_26;
          goto LABEL_22;
        }
        goto LABEL_17;
      }
LABEL_21:
      --v3;
LABEL_22:
      if ( (v8 & 0xFF0000) != 0 )
      {
        result = v3 + 3;
        if ( !BYTE1(v8) )
          result = (unsigned int *)((char *)v3 + 13);
      }
      else
      {
        result = (unsigned int *)((char *)v3 + 14);
      }
LABEL_26:
      v3 += 4;
    }
    --v3;
LABEL_20:
    --v3;
    goto LABEL_21;
  }
  if ( (_BYTE)v5 == *(_BYTE *)a1 )
    result = a1;
  if ( *(_BYTE *)a1 )
  {
    v3 = (unsigned int *)((char *)a1 + 1);
    if ( (((unsigned int)a1 + 1) & 3) == 0 )
      goto LABEL_27;
    if ( (_BYTE)v5 == *(_BYTE *)v3 )
      result = (unsigned int *)((char *)a1 + 1);
    if ( *(_BYTE *)v3 )
    {
      v3 = (unsigned int *)((char *)a1 + 2);
      if ( (((unsigned int)a1 + 2) & 3) == 0 )
        goto LABEL_27;
      if ( (_BYTE)v5 == *(_BYTE *)v3 )
        result = (unsigned int *)((char *)a1 + 2);
      if ( *(_BYTE *)v3 )
      {
        v3 = (unsigned int *)((char *)a1 + 3);
        goto LABEL_27;
      }
    }
  }
  return result;
}

//----- (08085A30) --------------------------------------------------------
int __cdecl strtok_r(int a1, _BYTE *a2, int *a3)
{
  int v3; // ebx
  _BYTE *v4; // eax

  v3 = a1;
  if ( !a1 )
    v3 = *a3;
  if ( *(_BYTE *)v3 && (v3 += (int)strspn(v3, a2), *(_BYTE *)v3) )
  {
    v4 = &strcspn(v3, a2)[v3];
    if ( *v4 )
      *v4++ = 0;
    *a3 = (int)v4;
    return v3;
  }
  else
  {
    *a3 = v3;
    return 0;
  }
}

//----- (08085AA0) --------------------------------------------------------
_BYTE *__cdecl memchr(_BYTE *a1, int a2, unsigned int a3)
{
  _BYTE *result; // eax
  int v4; // edx
  unsigned int v5; // esi
  __int16 v6; // cx
  unsigned int v7; // ecx
  bool v8; // cf
  int v9; // esi
  int v10; // esi

  result = a1;
  v4 = a2;
  v5 = a3;
  if ( a3 < 4 )
  {
LABEL_31:
    v9 = v5 & 3;
    if ( !v9 )
      return 0;
    if ( *result != (_BYTE)v4 )
    {
      ++result;
      v10 = v9 - 1;
      if ( !v10 )
        return 0;
      if ( *result != (_BYTE)v4 )
      {
        ++result;
        if ( v10 == 1 || *result != (_BYTE)v4 )
          return 0;
      }
    }
  }
  else
  {
    BYTE1(v4) = a2;
    v6 = v4;
    v4 <<= 16;
    LOWORD(v4) = v6;
    if ( ((unsigned __int8)a1 & 3) == 0 )
      goto LABEL_20;
    if ( *a1 != (_BYTE)v6 )
    {
      result = a1 + 1;
      v5 = a3 - 1;
      if ( ((unsigned __int8)result & 3) != 0 )
      {
        if ( *result != (_BYTE)v6 )
        {
          result = a1 + 2;
          v5 = a3 - 2;
          if ( ((unsigned __int8)result & 3) == 0 )
            goto LABEL_20;
          if ( *result != (_BYTE)v6 )
          {
            result = a1 + 3;
            v5 = a3 - 3;
            goto LABEL_20;
          }
        }
      }
      else
      {
LABEL_20:
        while ( 1 )
        {
          v8 = v5 < 0x10;
          v5 -= 16;
          if ( v8 )
            break;
          v7 = v4 ^ *(_DWORD *)result;
          if ( v7 < 0x1010101 || (v7 ^ (v7 - 16843009) | 0xFEFEFEFF) != -1 )
            goto LABEL_41;
          v7 = v4 ^ *((_DWORD *)result + 1);
          if ( v7 < 0x1010101 || (v7 ^ (v7 - 16843009) | 0xFEFEFEFF) != -1 )
            goto LABEL_40;
          v7 = v4 ^ *((_DWORD *)result + 2);
          if ( v7 < 0x1010101 || (v7 ^ (v7 - 16843009) | 0xFEFEFEFF) != -1 )
            goto LABEL_39;
          v7 = v4 ^ *((_DWORD *)result + 3);
          if ( v7 < 0x1010101 || (v7 ^ (v7 - 16843009) | 0xFEFEFEFF) != -1 )
          {
            result += 4;
LABEL_39:
            result += 4;
LABEL_40:
            result += 4;
            goto LABEL_41;
          }
          result += 16;
        }
        if ( v5 < 0xFFFFFFF4 )
          goto LABEL_31;
        v7 = v4 ^ *(_DWORD *)result;
        if ( v7 >= 0x1010101 && (v7 ^ (v7 - 16843009) | 0xFEFEFEFF) == -1 )
        {
          result += 4;
          if ( v5 < 0xFFFFFFF8 )
            goto LABEL_31;
          v7 = v4 ^ *(_DWORD *)result;
          if ( v7 >= 0x1010101 && (v7 ^ (v7 - 16843009) | 0xFEFEFEFF) == -1 )
          {
            result += 4;
            if ( v5 < 0xFFFFFFFC )
              goto LABEL_31;
            v7 = v4 ^ *(_DWORD *)result;
            if ( v7 >= 0x1010101 && (v7 ^ (v7 - 16843009) | 0xFEFEFEFF) == -1 )
            {
              result += 4;
              goto LABEL_31;
            }
          }
        }
LABEL_41:
        if ( (_BYTE)v7 )
        {
          ++result;
          if ( BYTE1(v7) )
          {
            ++result;
            if ( (v7 & 0xFF0000) != 0 )
              ++result;
          }
        }
      }
    }
  }
  return result;
}
// 8085AD7: conditional instruction was optimized away because %arg_8.4>=4u
// 8085AEF: conditional instruction was optimized away because %arg_8.4>=4u

//----- (08085C40) --------------------------------------------------------
unsigned int __usercall critical_factorization_0@<eax>(int a1@<eax>, unsigned int a2@<edx>, int *a3@<ecx>)
{
  int v3; // ebp
  int v4; // esi
  int v5; // ebx
  int v6; // ecx
  unsigned __int8 v7; // dl
  int v8; // ebx
  int v9; // esi
  int v10; // edi
  unsigned int v11; // ecx
  unsigned __int8 v12; // dl
  unsigned int v13; // edi
  unsigned int result; // eax
  int v15; // [esp+0h] [ebp-20h]
  int v17; // [esp+8h] [ebp-18h]

  v3 = 1;
  v4 = 0;
  v5 = 1;
  v15 = -1;
  while ( 1 )
  {
    v6 = v4 + v5;
    if ( v4 + v5 >= a2 )
      break;
    while ( 1 )
    {
      v7 = *(_BYTE *)(a1 + v15 + v5);
      if ( *(_BYTE *)(a1 + v6) >= v7 )
        break;
      v4 = v6;
      v5 = 1;
      v3 = v6 - v15;
      if ( ++v6 >= a2 )
        goto LABEL_5;
    }
    if ( *(_BYTE *)(a1 + v6) == v7 )
    {
      if ( v5 == v3 )
      {
        v4 = v6;
        v5 = 1;
      }
      else
      {
        ++v5;
      }
    }
    else
    {
      v15 = v4;
      v3 = 1;
      ++v4;
      v5 = 1;
    }
  }
LABEL_5:
  v17 = 1;
  v8 = 1;
  v9 = 0;
  *a3 = v3;
  v10 = -1;
  while ( 1 )
  {
    v11 = v9 + v8;
    if ( v9 + v8 >= a2 )
      break;
    while ( 1 )
    {
      v12 = *(_BYTE *)(a1 + v10 + v8);
      if ( *(_BYTE *)(a1 + v11) <= v12 )
        break;
      v8 = 1;
      v17 = v11 - v10;
      v9 = v11++;
      if ( v11 >= a2 )
        goto LABEL_9;
    }
    if ( *(_BYTE *)(a1 + v11) == v12 )
    {
      if ( v8 == v17 )
      {
        v9 = v11;
        v8 = 1;
      }
      else
      {
        ++v8;
      }
    }
    else
    {
      v10 = v9;
      v17 = 1;
      ++v9;
      v8 = 1;
    }
  }
LABEL_9:
  v13 = v10 + 1;
  result = v15 + 1;
  if ( v13 >= v15 + 1 )
  {
    *a3 = v17;
    return v13;
  }
  return result;
}

//----- (08085D90) --------------------------------------------------------
int __usercall two_way_long_needle_0@<eax>(int a1@<eax>, int a2@<edx>, unsigned int *a3@<ecx>, unsigned int a4)
{
  int *v5; // eax
  unsigned int v6; // ebp
  unsigned int *v7; // eax
  int v8; // edx
  char *v9; // ecx
  unsigned int v10; // ebx
  unsigned int v11; // esi
  unsigned int v12; // eax
  unsigned int v13; // eax
  unsigned int i; // ecx
  int result; // eax
  unsigned int v16; // eax
  unsigned int v17; // ecx
  int v18; // edx
  unsigned int v19; // edx
  unsigned int v22; // [esp+Ch] [ebp-448h]
  unsigned int v23; // [esp+10h] [ebp-444h]
  unsigned int v24; // [esp+14h] [ebp-440h]
  unsigned int v25; // [esp+18h] [ebp-43Ch]
  unsigned int v26; // [esp+30h] [ebp-424h] BYREF
  int v27[256]; // [esp+34h] [ebp-420h] BYREF
  unsigned int v28; // [esp+434h] [ebp-20h] BYREF

  v28 = __readgsdword(0x14u);
  v22 = critical_factorization_0((int)a3, a4, (int *)&v26);
  v5 = v27;
  do
    *v5++ = a4;
  while ( v5 != (int *)&v28 );
  v6 = a4 - 1;
  v7 = a3;
  if ( a4 )
  {
    do
    {
      v8 = *(unsigned __int8 *)v7;
      v9 = (char *)((char *)a3 + a4 - 1 - (char *)v7);
      v7 = (unsigned int *)((char *)v7 + 1);
      v27[v8] = (int)v9;
    }
    while ( v7 != (unsigned int *)((char *)a3 + a4) );
    v6 = a4 - 1;
  }
  v23 = v26;
  if ( !memcmp(a3, (unsigned int *)((char *)a3 + v26), v22) )
  {
    v10 = 0;
    v11 = 0;
    while ( 1 )
    {
      v12 = v27[*(unsigned __int8 *)(v10 + a1 + v6)];
      if ( v12 )
        break;
      v13 = v22;
      if ( v11 >= v22 )
        v13 = v11;
      if ( v13 >= v6 )
        goto LABEL_21;
      if ( *(_BYTE *)(a1 + v13 + v10) == *((_BYTE *)a3 + v13) )
      {
        while ( ++v13 < v6 )
        {
          if ( *((_BYTE *)a3 + v13) != *(_BYTE *)(v10 + a1 + v13) )
            goto LABEL_32;
        }
LABEL_21:
        if ( v11 < v22 && *(_BYTE *)(a1 + v10 + v22 - 1) == *((_BYTE *)a3 + v22 - 1) )
        {
          for ( i = v22 - 1; v11 != i && *((_BYTE *)a3 + i - 1) == *(_BYTE *)(i + a1 + v10 - 1); --i )
            ;
          v24 = i;
        }
        else
        {
          v24 = v22;
        }
        if ( v11 + 1 > v24 )
          return v10 + a1;
        v10 += v23;
        v11 = a4 - v23;
        if ( a2 - a4 < v10 )
          return 0;
      }
      else
      {
LABEL_32:
        v11 = 0;
        v10 = v13 + v10 - v22 + 1;
LABEL_12:
        if ( a2 - a4 < v10 )
          return 0;
      }
    }
    if ( v11 && v23 > v12 )
      v12 = a4 - v23;
    v10 += v12;
    v11 = 0;
    goto LABEL_12;
  }
  v16 = a4 - v22;
  if ( a4 - v22 < v22 )
    v16 = v22;
  v17 = 0;
  v25 = v16 + 1;
  while ( 1 )
  {
    result = v17 + a1;
    v18 = v27[*(unsigned __int8 *)(v17 + a1 + v6)];
    if ( !v18 )
      break;
LABEL_37:
    v17 += v18;
LABEL_38:
    if ( v17 > a2 - a4 )
      return 0;
  }
  if ( v22 >= v6 )
    goto LABEL_45;
  v18 = v22;
  if ( *((_BYTE *)a3 + v22) != *(_BYTE *)(a1 + v17 + v22) )
  {
LABEL_51:
    v17 += 1 - v22;
    goto LABEL_37;
  }
  while ( ++v18 < v6 )
  {
    if ( *((_BYTE *)a3 + v18) != *(_BYTE *)(result + v18) )
      goto LABEL_51;
  }
LABEL_45:
  if ( !v22 )
    return result;
  if ( *(_BYTE *)(a1 + v17 + v22 - 1) != *((_BYTE *)a3 + v22 - 1) )
  {
LABEL_50:
    v17 += v25;
    goto LABEL_38;
  }
  v19 = v22 - 1;
  while ( --v19 != -1 )
  {
    if ( *((_BYTE *)a3 + v19) != *(_BYTE *)(v19 + a1 + v17) )
      goto LABEL_50;
  }
  return result;
}
// 8085D90: using guessed type int var_420[256];

//----- (080860F0) --------------------------------------------------------
_BYTE *__cdecl memmem(_BYTE *a1, unsigned int a2, unsigned int *a3, unsigned int a4)
{
  _BYTE *result; // eax
  unsigned int v5; // edi
  unsigned int v6; // edi
  unsigned int v7; // eax
  unsigned int v8; // ecx
  unsigned int v9; // edx
  unsigned int v10; // ebx
  unsigned int v11; // eax
  unsigned int v12; // edx
  _BYTE *v13; // ecx
  _BYTE *v14; // eax
  _BYTE *v15; // eax
  _BYTE *v16; // ebx
  _BYTE *v17; // eax
  unsigned int v18; // ecx
  unsigned int v19; // eax
  unsigned int v20; // [esp+0h] [ebp-44h]
  unsigned int v21; // [esp+0h] [ebp-44h]
  _BYTE *v22; // [esp+4h] [ebp-40h]
  unsigned int v23; // [esp+8h] [ebp-3Ch]
  int v24; // [esp+Ch] [ebp-38h]
  unsigned __int8 v25; // [esp+Ch] [ebp-38h]
  unsigned int v26; // [esp+14h] [ebp-30h]
  int v27[9]; // [esp+20h] [ebp-24h] BYREF

  v27[1] = __readgsdword(0x14u);
  result = a1;
  if ( a4 )
  {
    if ( a4 > a2 )
    {
      return 0;
    }
    else
    {
      if ( a4 > 0x1F )
        return (_BYTE *)two_way_long_needle_0((int)a1, a2, a3, a4);
      result = memchr(a1, *(unsigned __int8 *)a3, a2);
      v22 = result;
      if ( result )
      {
        if ( a4 != 1 )
        {
          v5 = a2 - (result - a1);
          result = 0;
          v20 = v5;
          if ( a4 <= v5 )
          {
            v6 = critical_factorization_0((int)a3, a4, v27);
            v24 = v27[0];
            v7 = memcmp(a3, (unsigned int *)((char *)a3 + v27[0]), v6);
            if ( v7 )
            {
              v25 = *((_BYTE *)a3 + v6);
              v11 = a4 - v6;
              if ( a4 - v6 < v6 )
                v11 = v6;
              v12 = 0;
              v23 = v20 - a4;
              v26 = v11 + 1;
              while ( 1 )
              {
                v13 = &v22[v6 + v12];
                v14 = v13 + 1;
                if ( v25 != *v13 )
                {
                  v15 = memchr(v14, v25, v23 - v12);
                  if ( !v15 )
                    return 0;
                  v16 = v15;
                  v14 = v15 + 1;
                  v12 = v16 - &v22[v6];
                }
                v21 = v6 + 1;
                if ( a4 <= v6 + 1 )
                {
LABEL_40:
                  if ( !v6 )
                    return &v22[v12];
                  if ( *((_BYTE *)a3 + v6 - 1) == v22[v6 - 1 + v12] )
                  {
                    v19 = v6 - 1;
                    while ( --v19 != -1 )
                    {
                      if ( *((_BYTE *)a3 + v19) != v22[v12 + v19] )
                        goto LABEL_50;
                    }
                    return &v22[v12];
                  }
LABEL_50:
                  v12 += v26;
                }
                else
                {
                  if ( *((_BYTE *)a3 + v6 + 1) == *v14 )
                  {
                    v17 = &v14[-v6];
                    v18 = v6 + 1;
                    do
                    {
                      if ( a4 == ++v18 )
                        goto LABEL_40;
                    }
                    while ( *((_BYTE *)a3 + v18) == v17[v18 - 1] );
                    v21 = v18;
                  }
                  v12 += v21 + 1 - v6;
                }
                if ( v23 < v12 )
                  return 0;
              }
            }
            v8 = 0;
            while ( 1 )
            {
              v9 = v8;
              if ( v6 >= v8 )
                v9 = v6;
              if ( a4 > v9 )
              {
                if ( *((_BYTE *)a3 + v9) != v22[v9 + v7] )
                {
LABEL_28:
                  v8 = 0;
                  v7 = v9 + v7 - v6 + 1;
                  goto LABEL_24;
                }
                while ( a4 != ++v9 )
                {
                  if ( *((_BYTE *)a3 + v9) != v22[v7 + v9] )
                    goto LABEL_28;
                }
              }
              v10 = v6 - 1;
              if ( v6 > v8 && v22[v6 - 1 + v7] == *((_BYTE *)a3 + v6 - 1) )
              {
                while ( v10 != v8 && *((_BYTE *)a3 + v10 - 1) == v22[v7 - 1 + v10] )
                  --v10;
              }
              else
              {
                v10 = v6;
              }
              if ( v10 < v8 + 1 )
                return &v22[v7];
              v7 += v24;
              v8 = a4 - v24;
LABEL_24:
              if ( v20 - a4 < v7 )
                return 0;
            }
          }
        }
      }
    }
  }
  return result;
}

//----- (08086410) --------------------------------------------------------
int __cdecl argz_create_sep(unsigned int *a1, int *a2, unsigned int *a3, int *a4)
{
  unsigned int *v4; // esi
  int v5; // eax
  int v6; // ebp
  int *v8; // eax
  int *v9; // ecx
  int *v10; // ebx

  v4 = a1;
  v5 = strlen(a1);
  v6 = v5 + 1;
  if ( !v5 )
  {
    *a3 = 0;
    *a4 = 0;
    return 0;
  }
  v8 = malloc((const struct timespec *)(v5 + 1));
  *a3 = (unsigned int)v8;
  if ( !v8 )
    return 12;
  v9 = v8;
  do
  {
    while ( 1 )
    {
      v10 = (int *)*(char *)v4;
      if ( v10 == a2 )
        break;
      *(_BYTE *)v9 = (_BYTE)v10;
      v9 = (int *)((char *)v9 + 1);
LABEL_6:
      v4 = (unsigned int *)((char *)v4 + 1);
      if ( !(_BYTE)v10 )
        goto LABEL_11;
    }
    if ( v8 >= v9 || !*((_BYTE *)v9 - 1) )
    {
      --v6;
      goto LABEL_6;
    }
    *(_BYTE *)v9 = 0;
    v4 = (unsigned int *)((char *)v4 + 1);
    v9 = (int *)((char *)v9 + 1);
  }
  while ( (_BYTE)v10 );
LABEL_11:
  if ( !v6 )
  {
    free(0, a2, (int)v8);
    *a3 = 0;
  }
  *a4 = v6;
  return 0;
}

//----- (08086510) --------------------------------------------------------
int __cdecl argz_add_sep(int **a1, _DWORD *a2, unsigned int *a3, int a4)
{
  unsigned int *v4; // ebp
  int v5; // ecx
  int result; // eax
  int *v7; // eax
  int *v8; // eax
  int v9; // ecx
  char v10; // dl
  int v11; // ebx
  char v12; // dl
  int v13; // [esp+0h] [ebp-20h]

  v4 = a3;
  v5 = strlen(a3) + 1;
  result = 0;
  if ( v5 != 1 )
  {
    v13 = v5;
    v7 = realloc((int)a3, *a1, (const struct timespec *)(*a2 + v5));
    *a1 = v7;
    if ( v7 )
    {
      v8 = (int *)((char *)v7 + *a2);
      v9 = v13;
      while ( 1 )
      {
        while ( 1 )
        {
          v11 = *(char *)v4;
          v10 = *(_BYTE *)v4;
          if ( v11 == a4 )
            break;
          *(_BYTE *)v8 = v11;
          v10 = *(_BYTE *)v4;
          v8 = (int *)((char *)v8 + 1);
LABEL_5:
          v4 = (unsigned int *)((char *)v4 + 1);
          if ( !v10 )
            goto LABEL_10;
        }
        if ( *a1 >= v8 || !*((_BYTE *)v8 - 1) )
        {
          --v9;
          goto LABEL_5;
        }
        *(_BYTE *)v8 = 0;
        v12 = *(_BYTE *)v4;
        v8 = (int *)((char *)v8 + 1);
        v4 = (unsigned int *)((char *)v4 + 1);
        if ( !v12 )
        {
LABEL_10:
          *a2 += v9;
          return 0;
        }
      }
    }
    return 12;
  }
  return result;
}

//----- (080865E0) --------------------------------------------------------
int __usercall handle_amd@<eax>(int a1@<eax>)
{
  unsigned int v12; // esi

  _EAX = 0x80000000;
  __asm { cpuid }
  if ( a1 <= 196 )
  {
    if ( a1 > 190 )
    {
      if ( _EAX > 0x80000005 )
      {
        _EAX = -2147483642;
        __asm { cpuid }
        goto LABEL_6;
      }
    }
    else if ( _EAX > 0x80000004 )
    {
      _EAX = -2147483643;
      __asm { cpuid }
      if ( a1 <= 187 )
        a1 += 3;
LABEL_6:
      v12 = a1 - 188;
      if ( v12 <= 8 )
        __asm { jmp     eax }
      _assert_fail((int)"! \"cannot happen\"", (int)"../sysdeps/x86/cacheinfo.c", 433, (int)"handle_amd");
    }
  }
  return 0;
}

//----- (08086810) --------------------------------------------------------
int __usercall intel_check_word_isra_0@<eax>(
        int a1@<eax>,
        int a2@<edx>,
        _BYTE *a3@<ecx>,
        _BYTE *a4,
        _DWORD *a5,
        _DWORD *a6)
{
  unsigned int v6; // ebp
  unsigned int v7; // ecx
  unsigned int v8; // edx
  unsigned int v9; // eax
  char *v10; // esi
  int v11; // edx
  int v18; // edx
  int v19; // esi
  int v23; // eax
  int v24; // eax
  int v25; // eax
  int v26; // [esp+0h] [ebp-2Ch]
  int v27; // [esp+8h] [ebp-24h]
  int v29; // [esp+Ch] [ebp-20h]

  v27 = a1;
  if ( a2 < 0 )
    return 0;
  v26 = 3 * ((a1 - 185) / 3);
  if ( !a2 )
    return 0;
  v6 = a2;
  while ( 1 )
  {
    if ( (unsigned __int8)v6 == 64 )
    {
      *a4 = 1;
      if ( v26 == 9 )
        return 0;
      goto LABEL_5;
    }
    if ( (unsigned __int8)v6 == 255 )
      break;
    if ( (unsigned __int8)v6 == 73 && v26 == 9 )
    {
      if ( *a5 == 15 && *a6 == 6 )
      {
        v27 -= 3;
        v26 = 6;
      }
      else
      {
        v26 = 9;
      }
    }
    v7 = 68;
    v8 = 0;
    while ( 1 )
    {
      v9 = (v8 + v7) >> 1;
      v10 = (char *)&GLOBAL_OFFSET_TABLE_ + 8 * v9 - 112832;
      if ( (_BYTE)v6 == *v10 )
        break;
      if ( (unsigned __int8)v6 < (unsigned __int8)*v10 )
        v7 = (v8 + v7) >> 1;
      else
        v8 = v9 + 1;
      if ( v7 <= v8 )
        goto LABEL_5;
    }
    v11 = (unsigned __int8)v10[3];
    if ( v11 == v26 )
    {
      v25 = v27 - 185 - v26;
      if ( v27 - 185 == v26 )
        return *((_DWORD *)v10 + 1);
      if ( v25 == 1 )
        return (unsigned __int8)v10[1];
      if ( v25 != 2 )
        _assert_fail((int)"offset == 2", (int)"../sysdeps/x86/cacheinfo.c", 240, (int)"intel_check_word");
      return (unsigned __int8)v10[2];
    }
    if ( (_BYTE)v11 == 6 )
    {
      v6 >>= 8;
      *a3 = 1;
      if ( !v6 )
        return 0;
    }
    else
    {
LABEL_5:
      v6 >>= 8;
      if ( !v6 )
        return 0;
    }
  }
  _EAX = 4;
  __asm { cpuid }
  v18 = _EAX & 0x1F;
  if ( (_EAX & 0x1F) == 0 )
    return 0;
  v19 = 0;
  v29 = _ECX;
  while ( 1 )
  {
    v23 = (unsigned __int8)_EAX >> 5;
    if ( v18 == 1 && v23 == 1 )
    {
      if ( v26 == 3 )
        goto LABEL_33;
      goto LABEL_28;
    }
    if ( v18 != 2 || v23 != 1 )
      break;
    if ( !v26 )
      goto LABEL_33;
LABEL_28:
    ++v19;
    _EAX = 4;
    __asm { cpuid }
    v29 = _ECX;
    v18 = _EAX & 0x1F;
    if ( (_EAX & 0x1F) == 0 )
      return 0;
  }
  if ( (v23 != 2 || v26 != 6) && (v23 != 3 || v26 != 9) && (v23 != 4 || v26 != 12) )
    goto LABEL_28;
LABEL_33:
  v24 = v27 - 185 - v26;
  if ( v27 - 185 == v26 )
    return ((_EBX & 0xFFF) + 1) * ((_EBX >> 22) + 1) * (v29 + 1) * (((_EBX >> 12) & 0x3FF) + 1);
  if ( v24 == 1 )
    return (_EBX >> 22) + 1;
  if ( v24 != 2 )
    _assert_fail((int)"offset == 2", (int)"../sysdeps/x86/cacheinfo.c", 192, (int)"intel_check_word");
  return (_EBX & 0xFFF) + 1;
}
// 80CE000: using guessed type _TBYTE GLOBAL_OFFSET_TABLE_;

//----- (08086AC0) --------------------------------------------------------
int __usercall handle_intel_constprop_1@<eax>(int a1@<eax>)
{
  _DWORD *v1; // edi
  int v7; // edx
  _DWORD *v8; // esi
  int result; // eax
  unsigned int i; // [esp+4h] [ebp-44h]
  int v12; // [esp+Ch] [ebp-3Ch]
  int v13; // [esp+10h] [ebp-38h]
  unsigned int v14; // [esp+14h] [ebp-34h]
  unsigned __int8 v15; // [esp+26h] [ebp-22h] BYREF
  char v16; // [esp+27h] [ebp-21h] BYREF
  unsigned int v17; // [esp+28h] [ebp-20h]

  v17 = __readgsdword(0x14u);
  if ( dl_x86_cpu_features[1] <= 1u )
    return -1;
  v15 = 0;
  v1 = &dl_x86_cpu_features[15];
  v16 = 0;
  v14 = 1;
  for ( i = 1; ; ++i )
  {
    _EAX = 2;
    __asm { cpuid }
    v13 = _EDX;
    v7 = _EAX;
    v12 = _ECX;
    if ( i == 1 )
    {
      LOBYTE(v7) = 0;
      v14 = (unsigned __int8)_EAX;
    }
    v8 = &dl_x86_cpu_features[14];
    result = intel_check_word_isra_0(a1, v7, &v16, &v15, &dl_x86_cpu_features[14], v1);
    if ( result )
      break;
    result = intel_check_word_isra_0(a1, _EBX, &v16, &v15, v8, v1);
    if ( result )
      break;
    result = intel_check_word_isra_0(a1, v12, &v16, &v15, v8, v1);
    if ( result )
      break;
    result = intel_check_word_isra_0(a1, v13, &v16, &v15, v8, v1);
    if ( result )
      break;
    if ( v14 <= i )
    {
      if ( (unsigned int)(a1 - 191) <= 5 )
        return -v15;
      return result;
    }
  }
  return result;
}
// 80CF8E0: using guessed type _DWORD dl_x86_cpu_features[22];

//----- (08086C20) --------------------------------------------------------
int __cdecl _cache_sysconf(int a1)
{
  if ( dl_x86_cpu_features[0] == 1 )
    return handle_intel_constprop_1(a1);
  if ( dl_x86_cpu_features[0] == 2 )
    return handle_amd(a1);
  return 0;
}
// 80CF8E0: using guessed type _DWORD dl_x86_cpu_features[22];

//----- (08086C60) --------------------------------------------------------
int __cdecl wcslen(_DWORD *a1)
{
  int i; // edx
  int result; // eax
  int v3; // edx

  if ( !*a1 )
    return 0;
  if ( !a1[1] )
    return 1;
  if ( !a1[2] )
    return 2;
  for ( i = 0; ; i = result )
  {
    result = i + 3;
    if ( !a1[i + 3] )
      break;
    result = i + 4;
    if ( !a1[i + 4] )
      break;
    if ( !a1[result + 1] )
      return i + 5;
    v3 = i + 6;
    if ( !a1[result + 2] )
      return v3;
  }
  return result;
}

//----- (08086CE0) --------------------------------------------------------
_BYTE *__cdecl wmemcpy(_BYTE *a1, _BYTE *a2, int a3)
{
  return memcpy(a1, a2, 4 * a3);
}

//----- (08086D10) --------------------------------------------------------
_BYTE *__cdecl wmemmove(_BYTE *a1, _BYTE *a2, int a3)
{
  return memmove(a1, a2, 4 * a3);
}

//----- (08086D20) --------------------------------------------------------
_DWORD *__cdecl wmemset(_DWORD *a1, int a2, unsigned int a3)
{
  _DWORD *result; // eax
  unsigned int v4; // esi
  _DWORD *v5; // edx
  unsigned int v6; // ebx

  result = a1;
  v4 = a3;
  v5 = a1;
  if ( a3 > 3 )
  {
    v6 = a3;
    do
    {
      v6 -= 4;
      *v5 = a2;
      v5 += 4;
      *(v5 - 3) = a2;
      *(v5 - 2) = a2;
      *(v5 - 1) = a2;
    }
    while ( v6 > 3 );
    v4 = a3 & 3;
    v5 = &a1[4 * ((a3 - 4) >> 2) + 4];
  }
  if ( v4 )
  {
    *v5 = a2;
    if ( v4 != 1 )
    {
      v5[1] = a2;
      if ( v4 == 3 )
        v5[2] = a2;
    }
  }
  return result;
}

//----- (08086D80) --------------------------------------------------------
int __cdecl btowc(int a1)
{
  int result; // eax
  unsigned int v2; // eax
  char **v3; // esi
  void **v4; // edi
  int (__cdecl *v5)(void *, _DWORD); // esi
  int *v6; // eax
  int (__cdecl *v7)(void *, int *, char **, char *, _DWORD, char *, _DWORD, int); // ebx
  int v8; // eax
  int v9; // edx
  int v10; // [esp+0h] [ebp-40h] BYREF
  char *v11; // [esp+4h] [ebp-3Ch] BYREF
  char v12[4]; // [esp+8h] [ebp-38h] BYREF
  int v13[6]; // [esp+Ch] [ebp-34h] BYREF
  int v14[2]; // [esp+24h] [ebp-1Ch] BYREF
  char v15; // [esp+2Fh] [ebp-11h] BYREF
  unsigned int v16; // [esp+30h] [ebp-10h]

  v16 = __readgsdword(0x14u);
  if ( (unsigned int)(a1 + 128) > 0x17F || a1 == -1 )
    return -1;
  result = a1;
  if ( (a1 & 0xFFFFFF80) != 0 )
  {
    v2 = __readgsdword(0xFFFFFFD0);
    v3 = *(char ***)v2;
    v4 = *(void ***)(*(_DWORD *)v2 + 20);
    if ( !v4 )
    {
      if ( v3 == &nl_C_LC_CTYPE )
      {
        v4 = &_wcsmbs_gconv_fcts_c;
      }
      else
      {
        _wcsmbs_load_conv(v3);
        v4 = (void **)v3[5];
      }
    }
    v5 = (int (__cdecl *)(void *, _DWORD))*((_DWORD *)*v4 + 6);
    if ( *(_DWORD *)*v4 )
      v5 = (int (__cdecl *)(void *, _DWORD))(__readgsdword(0x18u) ^ __ROR4__(v5, 9));
    if ( v4[1] == (void *)1 && v5 )
    {
      dl_mcount_wrapper_check((int)v5);
      return v5(*v4, (unsigned __int8)a1);
    }
    else
    {
      v14[0] = 0;
      v11 = &v15;
      v13[0] = (int)&v10;
      v14[1] = 0;
      v15 = a1;
      v13[5] = (int)v14;
      v6 = (int *)*v4;
      v13[1] = (int)&v11;
      v7 = (int (__cdecl *)(void *, int *, char **, char *, _DWORD, char *, _DWORD, int))v6[5];
      v8 = *v6;
      v13[3] = 0;
      v13[4] = 1;
      v13[2] = 1;
      if ( v8 )
        v7 = (int (__cdecl *)(void *, int *, char **, char *, _DWORD, char *, _DWORD, int))(__readgsdword(0x18u) ^ __ROR4__(v7, 9));
      dl_mcount_wrapper_check((int)v7);
      v9 = v7(*v4, v13, &v11, v11 + 1, 0, v12, 0, 1);
      if ( (unsigned int)(v9 - 4) <= 1 )
        return v10;
      result = -1;
      if ( !v9 )
        return v10;
    }
  }
  return result;
}
// 80CC6D4: using guessed type void *_wcsmbs_gconv_fcts_c;
// 80CC740: using guessed type char *nl_C_LC_CTYPE;
// 8086D80: using guessed type char var_38[4];

//----- (08086F10) --------------------------------------------------------
int __cdecl wcrtomb(char *a1, int a2, void *a3)
{
  void *v3; // eax
  char *v4; // esi
  unsigned int v5; // eax
  char **v6; // ebx
  void **v7; // ebp
  _DWORD *v8; // eax
  int (__cdecl *v9)(void *, int *, int **, void **, _DWORD, char *, int, int); // ebx
  int v10; // eax
  _BYTE *v12; // eax
  char v13[4]; // [esp+0h] [ebp-58h] BYREF
  int *v14; // [esp+4h] [ebp-54h] BYREF
  int v15[8]; // [esp+8h] [ebp-50h] BYREF
  char v16; // [esp+28h] [ebp-30h] BYREF
  unsigned int v17; // [esp+38h] [ebp-20h]

  v17 = __readgsdword(0x14u);
  v3 = a3;
  v4 = a1;
  v15[3] = 0;
  v15[4] = 1;
  v15[2] = 1;
  if ( !a3 )
    v3 = &state_0;
  v15[5] = (int)v3;
  if ( !a1 )
  {
    a2 = 0;
    v4 = &v16;
  }
  v15[0] = (int)v4;
  v5 = __readgsdword(0xFFFFFFD0);
  v6 = *(char ***)v5;
  v7 = *(void ***)(*(_DWORD *)v5 + 20);
  v15[1] = (int)&v4[*(_DWORD *)(*(_DWORD *)v5 + 88)];
  if ( !v7 )
  {
    if ( v6 == &nl_C_LC_CTYPE )
    {
      v7 = &_wcsmbs_gconv_fcts_c;
    }
    else
    {
      _wcsmbs_load_conv(v6);
      v7 = (void **)v6[5];
    }
  }
  v8 = v7[2];
  v9 = (int (__cdecl *)(void *, int *, int **, void **, _DWORD, char *, int, int))v8[5];
  if ( *v8 )
    v9 = (int (__cdecl *)(void *, int *, int **, void **, _DWORD, char *, int, int))(__readgsdword(0x18u) ^ __ROR4__(v9, 9));
  if ( a2 )
  {
    v14 = &a2;
    dl_mcount_wrapper_check((int)v9);
    v10 = v9(v7[2], v15, &v14, &a3, 0, v13, 0, 1);
    if ( (v10 & 0xFFFFFFFB) == 0 )
      return v15[0] - (_DWORD)v4;
  }
  else
  {
    dl_mcount_wrapper_check((int)v9);
    v10 = v9(v7[2], v15, 0, 0, 0, v13, 1, 1);
    if ( (v10 & 0xFFFFFFFB) == 0 )
    {
      v12 = (_BYTE *)v15[0]++;
      *v12 = 0;
      return v15[0] - (_DWORD)v4;
    }
  }
  if ( (unsigned int)(v10 - 5) > 2 )
    _assert_fail(
      (int)"status == __GCONV_OK || status == __GCONV_EMPTY_INPUT || status == __GCONV_ILLEGAL_INPUT || status == __GCONV"
           "_INCOMPLETE_INPUT || status == __GCONV_FULL_OUTPUT",
      (int)"wcrtomb.c",
      101,
      (int)"__wcrtomb");
  if ( v10 != 5 )
  {
    __writegsdword(0xFFFFFFE0, 0x54u);
    return -1;
  }
  return v15[0] - (_DWORD)v4;
}
// 80CC6D4: using guessed type void *_wcsmbs_gconv_fcts_c;
// 80CC740: using guessed type char *nl_C_LC_CTYPE;
// 8086F10: using guessed type char var_58[4];

//----- (080870E0) --------------------------------------------------------
int __cdecl wcsrtombs(int a1, int *a2, int a3, int *a4)
{
  int *v4; // eax
  int *v5; // ecx
  unsigned int v6; // eax
  _DWORD *v7; // ebx
  char *v8; // eax
  _DWORD *v9; // ebp
  int (__cdecl *v10)(_DWORD *, char **, int *, int, _DWORD, char *, _DWORD, int); // esi
  _DWORD *v11; // edx
  int v12; // ebx
  int v13; // eax
  int v14; // ebx
  unsigned int v15; // edx
  int v17; // eax
  int v18; // edx
  int v19; // [esp+1Ch] [ebp-170h]
  int v20; // [esp+1Ch] [ebp-170h]
  int *v21; // [esp+20h] [ebp-16Ch]
  int v22; // [esp+3Ch] [ebp-150h] BYREF
  char v23[4]; // [esp+40h] [ebp-14Ch] BYREF
  int v24[2]; // [esp+44h] [ebp-148h] BYREF
  char *v25; // [esp+4Ch] [ebp-140h] BYREF
  unsigned int *v26; // [esp+50h] [ebp-13Ch]
  int v27; // [esp+54h] [ebp-138h]
  int v28; // [esp+58h] [ebp-134h]
  int v29; // [esp+5Ch] [ebp-130h]
  int *v30; // [esp+60h] [ebp-12Ch]
  char v31[256]; // [esp+6Ch] [ebp-120h] BYREF
  unsigned int v32; // [esp+16Ch] [ebp-20h] BYREF

  v4 = a4;
  v5 = a2;
  v32 = __readgsdword(0x14u);
  v28 = 0;
  if ( !a4 )
    v4 = (int *)&state_1;
  v29 = 1;
  v27 = 1;
  v30 = v4;
  v6 = __readgsdword(0xFFFFFFD0);
  v7 = *(_DWORD **)v6;
  v8 = *(char **)(*(_DWORD *)v6 + 20);
  if ( !v8 )
  {
    if ( v7 == (_DWORD *)((char *)&GLOBAL_OFFSET_TABLE_ - 6336) )
    {
      v8 = (char *)&GLOBAL_OFFSET_TABLE_ - 6444;
    }
    else
    {
      _wcsmbs_load_conv(v7);
      v8 = (char *)v7[5];
      v5 = a2;
    }
  }
  v9 = (_DWORD *)*((_DWORD *)v8 + 2);
  v10 = (int (__cdecl *)(_DWORD *, char **, int *, int, _DWORD, char *, _DWORD, int))v9[5];
  if ( *v9 )
    v10 = (int (__cdecl *)(_DWORD *, char **, int *, int, _DWORD, char *, _DWORD, int))(__readgsdword(0x18u) ^ __ROR4__(v10, 9));
  v11 = (_DWORD *)*v5;
  if ( a1 )
  {
    v21 = v5;
    v25 = (char *)a1;
    v12 = (int)&v11[wcsnlen(v11, a3) + 1];
    v26 = (unsigned int *)(a1 + a3);
    dl_mcount_wrapper_check((int)v10);
    v13 = v10(v9, &v25, v21, v12, 0, v23, 0, 1);
    v14 = (int)&v25[-a1];
    if ( (v13 & 0xFFFFFFFB) == 0 && !*(v25 - 1) )
    {
      if ( v25 == (char *)a1 )
        _assert_fail(
          (int)(&GLOBAL_OFFSET_TABLE_ - 11220),
          (int)&GLOBAL_OFFSET_TABLE_ - 112238,
          122,
          (int)(&GLOBAL_OFFSET_TABLE_ - 11216));
      if ( *v30 )
        _assert_fail(
          (int)&GLOBAL_OFFSET_TABLE_ - 173374,
          (int)&GLOBAL_OFFSET_TABLE_ - 112238,
          123,
          (int)(&GLOBAL_OFFSET_TABLE_ - 11216));
      *v21 = 0;
LABEL_23:
      --v14;
    }
  }
  else
  {
    v19 = *v5;
    v17 = wcslen((_DWORD *)*v5);
    v14 = 0;
    v22 = v19;
    v20 = v19 + 4 * v17 + 4;
    v18 = v30[1];
    v24[0] = *v30;
    v30 = v24;
    v26 = &v32;
    v24[1] = v18;
    do
    {
      v25 = v31;
      dl_mcount_wrapper_check((int)v10);
      v13 = v10(v9, &v25, &v22, v20, 0, v23, 0, 1);
      v14 += v25 - v31;
    }
    while ( v13 == 5 );
    if ( (v13 & 0xFFFFFFFB) == 0 )
    {
      if ( *(v25 - 1) )
        _assert_fail(
          (int)&GLOBAL_OFFSET_TABLE_ - 112226,
          (int)&GLOBAL_OFFSET_TABLE_ - 112238,
          94,
          (int)(&GLOBAL_OFFSET_TABLE_ - 11216));
      goto LABEL_23;
    }
  }
  v15 = v13 - 4;
  if ( v13 && v15 > 3 )
    _assert_fail(
      (int)&GLOBAL_OFFSET_TABLE_ - 173304,
      (int)&GLOBAL_OFFSET_TABLE_ - 112238,
      134,
      (int)(&GLOBAL_OFFSET_TABLE_ - 11216));
  if ( v13 && v15 > 1 )
  {
    v14 = -1;
    __writegsdword(0xFFFFFFE0, 0x54u);
  }
  return v14;
}
// 80CE000: using guessed type _TBYTE GLOBAL_OFFSET_TABLE_;
// 80870E0: using guessed type char var_14C[4];

//----- (08087410) --------------------------------------------------------
int __cdecl wcsnlen(_DWORD *a1, int a2)
{
  int v2; // ecx
  int v3; // edx
  int result; // eax

  v2 = a2;
  if ( !a2 || !*a1 )
    return 0;
  if ( a2 == 1 || !a1[1] )
    return 1;
  if ( a2 == 2 )
    return 2;
  v3 = 2;
  do
  {
    if ( !a1[v3] )
      break;
    result = v3 + 1;
    if ( v2 == 3 )
      return result;
    if ( !a1[v3 + 1] )
      return result;
    result = v3 + 2;
    v2 -= 4;
    if ( !v2 )
      return result;
    if ( !a1[v3 + 2] )
      return result;
    result = v3 + 3;
    if ( v2 == 1 || !a1[v3 + 3] )
      return result;
    v3 += 4;
  }
  while ( v2 != 2 );
  return v3;
}

//----- (080874A0) --------------------------------------------------------
int *__cdecl wcschrnul(int *a1, int a2)
{
  int *result; // eax
  int i; // edx

  result = a1;
  for ( i = *a1; *result != a2; i = *result )
  {
    if ( !i )
      break;
    ++result;
  }
  return result;
}

//----- (080874D0) --------------------------------------------------------
int __cdecl time(time_t *a1)
{
  return sys_time(a1);
}

//----- (080874F0) --------------------------------------------------------
int *__cdecl _alloc_dir(int a1, char a2, int a3, int a4)
{
  int v4; // eax
  int v5; // edi
  unsigned int v6; // edx
  int *v7; // esi
  unsigned int v9; // ebp

  if ( !a2 && (_fcntl64_nocancel(a1, 2) & 0x80000000) != 0 )
    return 0;
  v4 = 32796;
  v5 = 0x8000;
  if ( a4 )
  {
    v6 = 0x8000;
    if ( *(_DWORD *)(a4 + 52) >= 0x8000u )
      v6 = *(_DWORD *)(a4 + 52);
    v5 = v6;
    if ( v6 > 0x100000 )
      v5 = 0x100000;
    v4 = v5 + 28;
  }
  v7 = malloc((const struct timespec *)v4);
  if ( !v7 )
  {
    v5 = 0x2000;
    v7 = malloc((const struct timespec *)0x201C);
    if ( !v7 )
    {
      if ( a2 )
      {
        v9 = __readgsdword(0xFFFFFFE0);
        _close_nocancel(a1);
        __writegsdword(0xFFFFFFE0, v9);
        return v7;
      }
      return 0;
    }
  }
  v7[1] = 0;
  v7[2] = v5;
  *v7 = a1;
  v7[3] = 0;
  v7[4] = 0;
  v7[5] = 0;
  v7[6] = 0;
  return v7;
}

//----- (08087600) --------------------------------------------------------
int *__usercall opendir_tail@<eax>(int a1@<eax>)
{
  struct stat v3; // [esp+0h] [ebp-70h] BYREF
  unsigned int v4; // [esp+60h] [ebp-10h]

  v4 = __readgsdword(0x14u);
  if ( a1 < 0 )
    return 0;
  if ( (_fxstat64(3, a1, &v3) & 0x80000000) == 0 )
  {
    if ( (v3.st_mode & 0xF000) == 0x4000 )
      return _alloc_dir(a1, 1, 0, (int)&v3);
    __writegsdword(0xFFFFFFE0, 0x14u);
  }
  _close_nocancel(a1);
  return 0;
}

//----- (080876A0) --------------------------------------------------------
int *__cdecl _opendirat(int a1, _BYTE *a2)
{
  int v2; // eax

  if ( *a2 )
  {
    v2 = _openat_nocancel(a1, (int)a2);
    return opendir_tail(v2);
  }
  else
  {
    __writegsdword(0xFFFFFFE0, 2u);
    return 0;
  }
}

//----- (08087700) --------------------------------------------------------
int *__cdecl opendir(_BYTE *a1)
{
  int v1; // eax

  if ( *a1 )
  {
    v1 = _open_nocancel((int)a1);
    return opendir_tail(v1);
  }
  else
  {
    __writegsdword(0xFFFFFFE0, 2u);
    return 0;
  }
}

//----- (08087750) --------------------------------------------------------
unsigned int __usercall closedir@<eax>(int ebp0@<ebp>, int *a2@<edi>, int *a3)
{
  int v3; // esi

  if ( a3 )
  {
    v3 = *a3;
    free(ebp0, a2, (int)a3);
    return _close_nocancel(v3);
  }
  else
  {
    __writegsdword(0xFFFFFFE0, 0x16u);
    return -1;
  }
}

//----- (080877A0) --------------------------------------------------------
int __cdecl readdir(int a1)
{
  int *v3; // edi
  bool v4; // zf
  unsigned int v5; // eax
  int v6; // edx
  int v7; // ecx
  int v8; // edx
  signed int v9; // eax

  _ECX = 1;
  _EBP = a1;
  v3 = (int *)__readgsdword(0xFFFFFFE0);
  v4 = __readgsdword(0xCu) == 0;
  if ( !v4 )
    __asm { lock }
  __asm { cmpxchg [ebp+4], ecx }
  if ( !v4 )
    _lll_lock_wait_private(0, (int *)(a1 + 4), a1, v3);
  v5 = *(_DWORD *)(a1 + 16);
  while ( 1 )
  {
    v8 = v5 + 28;
    if ( *(_DWORD *)(a1 + 12) <= v5 )
      break;
LABEL_6:
    v6 = a1 + v8;
    v5 += *(unsigned __int16 *)(v6 + 8);
    v7 = *(_DWORD *)(v6 + 4);
    *(_DWORD *)(a1 + 16) = v5;
    *(_DWORD *)(a1 + 20) = v7;
    if ( *(_DWORD *)v6 )
      goto LABEL_12;
  }
  v9 = _getdents(*(_DWORD *)a1, (struct dirent *)(a1 + 28), *(_DWORD *)(a1 + 8));
  if ( v9 > 0 )
  {
    *(_DWORD *)(a1 + 12) = v9;
    v8 = 28;
    v5 = 0;
    goto LABEL_6;
  }
  if ( !v9 || (v6 = 0, __readgsdword(0xFFFFFFE0) == 2) )
  {
    __writegsdword(0xFFFFFFE0, (unsigned int)v3);
    v6 = 0;
  }
LABEL_12:
  if ( __readgsdword(0xCu) )
    __asm { lock }
  v4 = (*(_DWORD *)(a1 + 4))-- == 1;
  if ( !v4 )
    _lll_unlock_wake_private((int *)(a1 + 4), a1, v3, (const struct timespec *)0xFFFFFFE0);
  return v6;
}
// 808785B: variable 'v6' is possibly undefined

//----- (08087870) --------------------------------------------------------
int __usercall rewinddir@<eax>(int a1@<ebp>, int *a2@<edi>, const struct timespec *a3@<esi>, int *a4)
{
  bool v6; // zf
  int result; // eax

  _ECX = 1;
  _EBX = a4;
  v6 = __readgsdword(0xCu) == 0;
  if ( !v6 )
    __asm { lock }
  __asm { cmpxchg [ebx+4], ecx }
  if ( !v6 )
    _lll_lock_wait_private(0, a4 + 1, a1, a2);
  result = lseek(*a4, 0, 0);
  a4[5] = 0;
  a4[4] = 0;
  a4[3] = 0;
  a4[6] = 0;
  if ( __readgsdword(0xCu) )
    __asm { lock }
  v6 = a4[1]-- == 1;
  if ( !v6 )
    return _lll_unlock_wake_private(a4 + 1, a1, a2, a3);
  return result;
}

//----- (080878F0) --------------------------------------------------------
unsigned int __cdecl _getdents(int a1, struct dirent *a2, unsigned int a3)
{
  struct dirent *v3; // ecx
  struct dirent *v4; // ebp
  unsigned int result; // eax
  struct dirent *v6; // ecx
  struct dirent *v7; // ebx
  int v8; // esi
  int v9; // edi
  unsigned int v10; // [esp+8h] [ebp-164h]
  unsigned int v11; // [esp+Ch] [ebp-160h]
  __ino_t d_ino; // [esp+14h] [ebp-158h]
  unsigned int v13; // [esp+18h] [ebp-154h]
  __off_t d_off; // [esp+1Ch] [ebp-150h]
  unsigned int v15; // [esp+20h] [ebp-14Ch]
  unsigned __int8 v16; // [esp+27h] [ebp-145h]
  char *v17; // [esp+28h] [ebp-144h]
  char v18; // [esp+38h] [ebp-134h] BYREF
  unsigned int v19; // [esp+14Ch] [ebp-20h]

  v3 = (struct dirent *)&v18;
  v19 = __readgsdword(0x14u);
  if ( a3 >= 0x10D )
    v3 = a2;
  v4 = v3;
  result = sys_getdents64(a1, v3, a3);
  if ( result > 0xFFFFF000 )
    result = _syscall_error(result);
  if ( result != -1 )
  {
    v6 = a2;
    v17 = (char *)v4 + result;
    if ( v4 >= (struct dirent *)((char *)v4 + result) )
    {
      return (char *)v6 - (char *)a2;
    }
    else
    {
      v10 = -1;
      v7 = a2;
      v11 = -1;
      while ( 1 )
      {
        v8 = *(unsigned __int16 *)&v4->d_name[5];
        v9 = *(_DWORD *)&v4->d_reclen;
        d_off = v4->d_off;
        v13 = *(_DWORD *)&v4->d_name[1];
        v15 = (v8 - 5) & 0xFFFFFFFC;
        d_ino = v4->d_ino;
        v16 = v4->d_name[7];
        memmove(v7->d_name, &v4->d_name[8], v8 - 19);
        v7->d_off = v9;
        v7->d_ino = d_ino;
        if ( __PAIR64__(v13, d_off) != __PAIR64__(v9 >> 31, 0) )
          break;
        v4 = (struct dirent *)((char *)v4 + v8);
        v10 = v9;
        v11 = v13;
        v7->d_reclen = v15;
        v7->d_type = v16;
        v7 = (struct dirent *)((char *)v7 + v15);
        if ( v17 <= (char *)v4 )
        {
          v6 = v7;
          return (char *)v6 - (char *)a2;
        }
      }
      if ( (v11 & v10) == -1 )
      {
        return _syscall_error(-75);
      }
      else
      {
        lseek64(a1, v10, v11, 0);
        return (char *)v7 - (char *)a2;
      }
    }
  }
  return result;
}

//----- (08087AA0) --------------------------------------------------------
int __cdecl readdir64(int a1)
{
  int *v3; // edi
  bool v4; // zf
  unsigned int v5; // eax
  int v6; // edx
  int v7; // ecx
  int v8; // edx
  signed int v9; // eax

  _ECX = 1;
  _EBP = a1;
  v3 = (int *)__readgsdword(0xFFFFFFE0);
  v4 = __readgsdword(0xCu) == 0;
  if ( !v4 )
    __asm { lock }
  __asm { cmpxchg [ebp+4], ecx }
  if ( !v4 )
    _lll_lock_wait_private(0, (int *)(a1 + 4), a1, v3);
  v5 = *(_DWORD *)(a1 + 16);
  while ( 1 )
  {
    v8 = v5 + 28;
    if ( *(_DWORD *)(a1 + 12) <= v5 )
      break;
LABEL_6:
    v6 = a1 + v8;
    v5 += *(unsigned __int16 *)(v6 + 16);
    v7 = *(_DWORD *)(v6 + 8);
    *(_DWORD *)(a1 + 16) = v5;
    *(_DWORD *)(a1 + 20) = v7;
    if ( *(_QWORD *)v6 )
      goto LABEL_12;
  }
  v9 = _getdents64(*(_DWORD *)a1, (struct dirent *)(a1 + 28), *(_DWORD *)(a1 + 8));
  if ( v9 > 0 )
  {
    *(_DWORD *)(a1 + 12) = v9;
    v8 = 28;
    v5 = 0;
    goto LABEL_6;
  }
  if ( !v9 || (v6 = 0, __readgsdword(0xFFFFFFE0) == 2) )
  {
    __writegsdword(0xFFFFFFE0, (unsigned int)v3);
    v6 = 0;
  }
LABEL_12:
  if ( __readgsdword(0xCu) )
    __asm { lock }
  v4 = (*(_DWORD *)(a1 + 4))-- == 1;
  if ( !v4 )
    _lll_unlock_wake_private((int *)(a1 + 4), a1, v3, (const struct timespec *)0xFFFFFFE0);
  return v6;
}
// 8087B5B: variable 'v6' is possibly undefined

//----- (08087B70) --------------------------------------------------------
int *__cdecl fdopendir(int a1)
{
  int v1; // eax
  struct stat v3; // [esp+0h] [ebp-70h] BYREF
  unsigned int v4; // [esp+60h] [ebp-10h]

  v4 = __readgsdword(0x14u);
  if ( (_fxstat64(3, a1, &v3) & 0x80000000) != 0 )
    return 0;
  if ( (v3.st_mode & 0xF000) != 0x4000 )
  {
    __writegsdword(0xFFFFFFE0, 0x14u);
    return 0;
  }
  v1 = _fcntl64_nocancel(a1, 3);
  if ( v1 == -1 )
    return 0;
  if ( (v1 & 3) != 1 )
    return _alloc_dir(a1, 0, v1, (int)&v3);
  __writegsdword(0xFFFFFFE0, 0x16u);
  return 0;
}

//----- (08087C30) --------------------------------------------------------
unsigned int __cdecl uname(struct utsname *a1)
{
  unsigned int result; // eax

  result = sys_newuname(a1);
  if ( result >= 0xFFFFF001 )
    return _syscall_error(result);
  return result;
}

//----- (08087C60) --------------------------------------------------------
int getuid()
{
  return ((int (*)(void))__readgsdword(0x10u))();
}

//----- (08087C80) --------------------------------------------------------
int geteuid()
{
  return ((int (*)(void))__readgsdword(0x10u))();
}

//----- (08087CA0) --------------------------------------------------------
int getgid()
{
  return ((int (*)(void))__readgsdword(0x10u))();
}

//----- (08087CC0) --------------------------------------------------------
int getegid()
{
  return ((int (*)(void))__readgsdword(0x10u))();
}

//----- (08087CE0) --------------------------------------------------------
unsigned int __cdecl _lxstat64(int a1, const char *a2, struct stat *a3)
{
  unsigned int result; // eax

  result = sys_lstat64(a2, a3);
  if ( result > 0xFFFFF000 )
    return _syscall_error(result);
  return result;
}

//----- (08087D10) --------------------------------------------------------
int __cdecl _fxstatat64(int a1, int a2, int a3, int a4)
{
  unsigned int v4; // eax

  if ( a1 != 3 )
    return _syscall_error(-22);
  v4 = ((int (__fastcall *)(int, int))__readgsdword(0x10u))(a3, a4);
  if ( v4 <= 0xFFFFF000 )
    return 0;
  else
    return _syscall_error(v4);
}

//----- (08087D70) --------------------------------------------------------
unsigned int __cdecl lseek(int a1, signed int a2, unsigned int a3)
{
  unsigned int result; // eax
  loff_t v4; // [esp+8h] [ebp-2Ch] BYREF
  unsigned int v5; // [esp+14h] [ebp-20h]

  v5 = __readgsdword(0x14u);
  result = sys_llseek(a1, a2 >> 31, a2, &v4, a3);
  if ( result > 0xFFFFF000 )
    result = _syscall_error(result);
  if ( !result )
  {
    result = v4;
    if ( HIDWORD(v4) != (int)v4 >> 31 )
    {
      __writegsdword(0xFFFFFFE0, 0x4Bu);
      return -1;
    }
  }
  return result;
}

//----- (08087E20) --------------------------------------------------------
_BOOL4 __cdecl isatty(int a1)
{
  char v2[60]; // [esp+8h] [ebp-4Ch] BYREF
  unsigned int v3; // [esp+44h] [ebp-10h]

  v3 = __readgsdword(0x14u);
  return tcgetattr(a1, (int)v2) == 0;
}
// 8087E20: using guessed type char var_4C[60];

//----- (08087E70) --------------------------------------------------------
unsigned int __cdecl _open64_nocancel(int a1, int a2)
{
  int v2; // edx
  unsigned int result; // eax

  v2 = a2;
  BYTE1(v2) = BYTE1(a2) | 0x80;
  result = ((int (__fastcall *)(int, int))__readgsdword(0x10u))(a1, v2);
  if ( result > 0xFFFFF000 )
    return _syscall_error(result);
  return result;
}

//----- (08087EE0) --------------------------------------------------------
unsigned int __cdecl _openat_nocancel(int a1, int a2)
{
  unsigned int result; // eax

  result = ((int (__fastcall *)(int))__readgsdword(0x10u))(a2);
  if ( result > 0xFFFFF000 )
    return _syscall_error(result);
  return result;
}

//----- (08087F40) --------------------------------------------------------
unsigned int __cdecl tcgetattr(int a1, int a2)
{
  unsigned int result; // eax
  int v3; // [esp+8h] [ebp-34h]
  int v4; // [esp+Ch] [ebp-30h]
  int v5; // [esp+10h] [ebp-2Ch]
  int v6; // [esp+14h] [ebp-28h]
  char v7; // [esp+18h] [ebp-24h]
  int v8; // [esp+19h] [ebp-23h]
  int v9; // [esp+1Dh] [ebp-1Fh]
  int v10; // [esp+21h] [ebp-1Bh]
  int v11; // [esp+25h] [ebp-17h]
  __int16 v12; // [esp+29h] [ebp-13h]
  char v13; // [esp+2Bh] [ebp-11h]

  result = sys_ioctl(a1, 21505);
  if ( result > 0xFFFFF000 )
    result = _syscall_error(result);
  if ( !result )
  {
    *(_DWORD *)(a2 + 36) = 0;
    *(_DWORD *)(a2 + 40) = 0;
    *(_DWORD *)(a2 + 12) = v6;
    *(_DWORD *)a2 = v3;
    *(_BYTE *)(a2 + 16) = v7;
    *(_DWORD *)(a2 + 4) = v4;
    *(_DWORD *)(a2 + 17) = v8;
    *(_DWORD *)(a2 + 8) = v5;
    *(_DWORD *)(a2 + 21) = v9;
    *(_DWORD *)(a2 + 52) = v5 & 0x100F;
    *(_DWORD *)(a2 + 25) = v10;
    *(_DWORD *)(a2 + 56) = v5 & 0x100F;
    *(_DWORD *)(a2 + 29) = v11;
    *(_DWORD *)(a2 + 44) = 0;
    *(_WORD *)(a2 + 33) = v12;
    *(_BYTE *)(a2 + 48) = 0;
    *(_BYTE *)(a2 + 35) = v13;
  }
  return result;
}
// 8087F97: variable 'v6' is possibly undefined
// 8087F9F: variable 'v3' is possibly undefined
// 8087FA5: variable 'v7' is possibly undefined
// 8087FAC: variable 'v4' is possibly undefined
// 8087FB3: variable 'v8' is possibly undefined
// 8087FBA: variable 'v5' is possibly undefined
// 8087FC3: variable 'v9' is possibly undefined
// 8087FCD: variable 'v10' is possibly undefined
// 8087FD7: variable 'v11' is possibly undefined
// 8087FE6: variable 'v12' is possibly undefined
// 8087FF3: variable 'v13' is possibly undefined

//----- (08088020) --------------------------------------------------------
int __cdecl brk(void *end_data_segment)
{
  unsigned int v1; // eax
  int v2; // edx

  v1 = sys_brk(end_data_segment);
  *(int *)((char *)&_curbrk + v2 - 135061504) = v1;
  if ( (unsigned int)end_data_segment > v1 )
    return _syscall_error(-12);
  else
    return 0;
}
// 808803B: variable 'v2' is possibly undefined
// 80CFA40: using guessed type int _curbrk;

//----- (08088060) --------------------------------------------------------
int __cdecl wctrans(char *a1)
{
  int v1; // eax
  unsigned int *v2; // ebp
  int v3; // esi
  int v5; // [esp+0h] [ebp-20h]

  v1 = *(_DWORD *)__readgsdword(0xFFFFFFD0);
  v2 = *(unsigned int **)(v1 + 80);
  v5 = v1;
  if ( !*(_BYTE *)v2 )
    return 0;
  v3 = 0;
  while ( strcmp(a1, v2) )
  {
    ++v3;
    v2 = (unsigned int *)((char *)v2 + strlen(v2) + 1);
    if ( !*(_BYTE *)v2 )
      return 0;
  }
  return *(_DWORD *)(v5 + 4 * (*(_DWORD *)(v5 + 108) + v3) + 36);
}

//----- (080880F0) --------------------------------------------------------
unsigned int __cdecl towctrans(unsigned int a1, _DWORD *a2)
{
  unsigned int result; // eax
  unsigned int v3; // ebx
  int v4; // ebx
  int v5; // ecx

  result = a1;
  if ( a2 )
  {
    v3 = a1 >> *a2;
    if ( v3 < a2[1] )
    {
      v4 = a2[v3 + 5];
      if ( v4 )
      {
        v5 = *(_DWORD *)((char *)&a2[(a1 >> a2[2]) & a2[3]] + v4);
        if ( v5 )
          return *(_DWORD *)((char *)&a2[a1 & a2[4]] + v5) + a1;
      }
    }
  }
  return result;
}

//----- (08088140) --------------------------------------------------------
int __cdecl _readonly_area(unsigned int a1, unsigned int a2)
{
  int *v2; // eax
  struct timespec *v3; // edi
  int v4; // eax
  __time_t v5; // edx
  unsigned int v6; // ebx
  unsigned __int8 *v7; // eax
  unsigned int v8; // eax
  _BYTE *v9; // edx
  unsigned int v10; // ecx
  unsigned int v12; // eax
  unsigned int v13; // [esp+4h] [ebp-50h]
  unsigned __int8 *v14; // [esp+24h] [ebp-30h] BYREF
  unsigned int v15; // [esp+28h] [ebp-2Ch] BYREF
  unsigned __int8 *v16; // [esp+2Ch] [ebp-28h] BYREF
  int v17[9]; // [esp+30h] [ebp-24h] BYREF

  v17[1] = __readgsdword(0x14u);
  v2 = fopen((int)&GLOBAL_OFFSET_TABLE_, (int)&GLOBAL_OFFSET_TABLE_ - 112148, (_BYTE *)&GLOBAL_OFFSET_TABLE_ - 179465);
  if ( v2 )
  {
    v3 = (struct timespec *)v2;
    v4 = *v2;
    v5 = v4;
    BYTE1(v5) = BYTE1(v4) | 0x80;
    v3->tv_sec = v5;
    v13 = a2;
    v14 = 0;
    v15 = 0;
    if ( (v4 & 0x10) == 0 )
    {
      do
      {
        if ( getdelim(a1, &v14, &v15, 10, &v3->tv_sec) <= 0 )
          break;
        v6 = strtoul(v14, &v16, 16);
        v7 = v16;
        if ( v16 == v14 )
          break;
        ++v16;
        if ( *v7 != 45 )
          break;
        v8 = strtoul(v7 + 1, v17, 16);
        v9 = (_BYTE *)v17[0];
        if ( (unsigned __int8 *)v17[0] == v16 )
          break;
        ++v17[0];
        if ( *v9 != 32 )
          break;
        v10 = a1 + a2;
        if ( a1 + a2 > v6 && a1 < v8 )
        {
          v17[0] = (int)(v9 + 2);
          if ( v9[1] != 114 )
            break;
          v17[0] = (int)(v9 + 3);
          if ( v9[2] != 45 )
            break;
          if ( a1 >= v6 && v10 <= v8 )
          {
            v13 = 0;
            break;
          }
          if ( a1 >= v6 )
          {
            v13 = a1 + v13 - v8;
          }
          else if ( v10 > v8 )
          {
            v13 = v13 + v6 - v8;
          }
          else
          {
            v13 = v6 + v13 - v10;
          }
          if ( !v13 )
            break;
        }
      }
      while ( (v3->tv_sec & 0x10) == 0 );
    }
    fclose(v3);
    free((int)&GLOBAL_OFFSET_TABLE_, &v3->tv_sec, (int)v14);
    if ( v13 )
      return -1;
  }
  else
  {
    v12 = __readgsdword(0xFFFFFFE0);
    if ( v12 != 2 && v12 != 13 )
      return -1;
  }
  return 1;
}
// 80CE000: using guessed type _TBYTE GLOBAL_OFFSET_TABLE_;

//----- (08088370) --------------------------------------------------------
int __usercall is_dst@<eax>(unsigned __int8 *a1@<eax>, unsigned int *a2@<edx>)
{
  int v4; // eax
  int v5; // ebx
  unsigned __int8 v7; // dl
  int v8; // ebp

  v4 = strlen(a2);
  v5 = v4;
  if ( *a1 != 123 )
  {
    if ( strncmp(a1, (unsigned __int8 *)a2, v4) )
      return 0;
    v7 = a1[v5];
    if ( (unsigned __int8)((v7 & 0xDF) - 65) <= 0x19u || (unsigned __int8)(v7 - 48) <= 9u || v7 == 95 )
      return 0;
    return v5;
  }
  v8 = v4;
  v5 = 0;
  if ( strncmp(a1 + 1, (unsigned __int8 *)a2, v4) || a1[v8 + 1] != 125 )
    return v5;
  return v8 + 2;
}

//----- (08088400) --------------------------------------------------------
_BOOL4 __usercall is_trusted_path_normalize@<eax>(char *a1@<eax>, int a2@<edx>)
{
  __int16 v2; // cx
  int *v3; // edx
  int v4; // ecx
  void *v5; // esp
  char v6; // dl
  int *v7; // ecx
  char v8; // bl
  char *v9; // eax
  unsigned int v10; // eax
  char v12; // di
  char v13; // di
  int *v14; // edx
  int v15; // [esp+0h] [ebp-1030h]
  int v16; // [esp+4h] [ebp-102Ch] BYREF
  int v17; // [esp+10h] [ebp-1020h] BYREF
  int v18; // [esp+14h] [ebp-101Ch]
  char v19; // [esp+18h] [ebp-1018h]
  _BYTE v20[15]; // [esp+1004h] [ebp-2Ch] BYREF
  char v21; // [esp+1013h] [ebp-1Dh]

  if ( !a2 )
    return 0;
  v2 = (a2 + 29) & 0xFFF0;
  v3 = (int *)&v20[-((a2 + 29) & 0xFFFFF000)];
  if ( v20 != (_BYTE *)v3 )
  {
    while ( &v16 != v3 )
      ;
  }
  v4 = v2 & 0xFFF;
  if ( v4 )
  {
    v5 = alloca(v4);
    *(int *)((char *)&v15 + v4) = *(int *)((char *)&v15 + v4);
  }
  v6 = *a1;
  v7 = &v17;
LABEL_9:
  if ( v6 )
  {
    do
    {
      v8 = a1[1];
      v21 = v8;
      if ( v6 != 47 )
      {
        ++a1;
LABEL_8:
        *(_BYTE *)v7 = v6;
        v6 = v21;
        v7 = (int *)((char *)v7 + 1);
        goto LABEL_9;
      }
      if ( v8 == 46 )
      {
        v12 = a1[2];
        if ( v12 == 46 )
        {
          v13 = a1[3];
          if ( v13 == 47 || !v13 )
          {
            if ( v7 > &v17 )
            {
              v14 = (int *)((char *)v7 - 1);
              if ( *((_BYTE *)v7 - 1) == 47 )
              {
LABEL_42:
                v7 = v14;
              }
              else
              {
                while ( &v17 != v14 )
                {
                  v14 = (int *)((char *)v14 - 1);
                  if ( *(_BYTE *)v14 == 47 )
                    goto LABEL_42;
                }
                v7 = &v17;
              }
            }
            a1 += 3;
            v6 = v13;
            goto LABEL_9;
          }
        }
        else if ( v12 == 47 || !v12 )
        {
          a1 += 2;
          v6 = v12;
          goto LABEL_9;
        }
      }
      ++a1;
      if ( v7 <= &v17 || *((_BYTE *)v7 - 1) != 47 )
        goto LABEL_8;
      v6 = v21;
    }
    while ( v21 );
  }
  if ( v7 == &v17 || (v9 = (char *)v7, *((_BYTE *)v7 - 1) != 47) )
  {
    *(_BYTE *)v7 = 47;
    v9 = (char *)v7 + 1;
  }
  v10 = v9 - (char *)&v17;
  return v10 > 4
      && (v17 == 1651076143 && (_BYTE)v18 == 47 || v10 > 8 && v17 == 1920169263 && v18 == 1651076143 && v19 == 47);
}

//----- (08088590) --------------------------------------------------------
int __usercall dl_process_pt_note@<eax>(int a1@<eax>, _DWORD *a2@<edx>, int a3@<ecx>, _DWORD *a4)
{
  signed int v5; // edi
  int *v6; // ebx
  int *v7; // eax
  unsigned int v8; // edi
  int v9; // esi
  char v10; // al
  unsigned int v11; // esi
  unsigned int *v12; // eax
  char *v13; // esi
  unsigned int v14; // edx
  unsigned int v15; // ecx
  _BYTE *v17; // eax
  int v18; // edx
  void *v19; // esp
  unsigned int v20; // edi
  int v21; // eax
  _BYTE v22[4]; // [esp-1010h] [ebp-104Ch]
  _BYTE v23[4096]; // [esp-100Ch] [ebp-1048h] BYREF
  _BYTE v24[12]; // [esp-Ch] [ebp-48h] BYREF
  int v25; // [esp+0h] [ebp-3Ch]
  int *v26; // [esp+4h] [ebp-38h]
  unsigned int v27; // [esp+8h] [ebp-34h]
  int *v28; // [esp+Ch] [ebp-30h]
  int v29; // [esp+10h] [ebp-2Ch]
  _TBYTE *v30; // [esp+14h] [ebp-28h]
  int v31; // [esp+18h] [ebp-24h]
  int v32; // [esp+1Ch] [ebp-20h]
  unsigned int v33; // [esp+20h] [ebp-1Ch]
  int savedregs; // [esp+3Ch] [ebp+0h] BYREF

  v31 = a1;
  v30 = &GLOBAL_OFFSET_TABLE_;
  v33 = a2[4];
  v5 = a2[1];
  if ( v5 + v33 <= *a4 )
  {
    if ( (*(_BYTE *)(a1 + 410) & 0xE) != 0 )
      return 0;
    if ( a2[7] != 4 )
      return 0;
    v6 = (_DWORD *)((char *)a4 + v5 + 4);
    v28 = 0;
    v7 = v6;
    if ( v33 <= 0xC )
      return 0;
    goto LABEL_5;
  }
  if ( v33 <= 0xFFFF )
  {
    v17 = &v24[-((v33 + 27) & 0xFFFFF000)];
    if ( v24 != v17 )
    {
      while ( v23 != v17 )
        ;
    }
    v18 = ((_WORD)v33 + 27) & 0xFF0;
    if ( (((_WORD)v33 + 27) & 0xFF0) != 0 )
    {
      v19 = alloca(v18);
      *(_DWORD *)&v22[v18] = *(_DWORD *)&v22[v18];
    }
    v32 = a3;
    v6 = (int *)v23;
    lseek(a3, v5, 0);
    v20 = v33;
    if ( v20 == _read_nocancel(v32, v23, v33) )
    {
      if ( (*(_BYTE *)(v31 + 410) & 0xE) != 0 )
        return 0;
      if ( a2[7] != 4 )
        return 0;
      v7 = (int *)v23;
      if ( v33 <= 0xC )
        return 0;
      v28 = 0;
      goto LABEL_5;
    }
    return -1;
  }
  v32 = a3;
  v28 = malloc((const struct timespec *)v33);
  lseek(v32, v5, 0);
  v8 = v33;
  if ( _read_nocancel(v32, v28, v33) != v33 )
  {
    if ( v28 )
      free((int)&savedregs, (int *)v33, (int)v28);
    return -1;
  }
  if ( (*(_BYTE *)(v31 + 410) & 0xE) == 0 && a2[7] == 4 )
  {
    v6 = v28;
    v7 = v28;
LABEL_5:
    v27 = 0;
    v8 = 0;
    v29 = 12 - (_DWORD)v7;
    while ( 1 )
    {
      v32 = *v6;
      if ( v32 == 4 && v6[2] == 5 && v6[3] == 5590599 )
        break;
      v9 = v6[1];
LABEL_7:
      v6 = (int *)((char *)v6 + ((v9 + ((v32 + 15) | 3)) & 0xFFFFFFFC));
      if ( v33 <= (unsigned int)v6 + v29 )
      {
        v21 = v27 & 2;
        if ( (v27 & 1) != 0 )
          *(_BYTE *)(v31 + 410) |= 4u;
        if ( v21 )
          *(_BYTE *)(v31 + 410) |= 8u;
        goto LABEL_20;
      }
    }
    v10 = *(_BYTE *)(v31 + 410);
    if ( (v10 & 0xE) == 0 )
    {
      *(_BYTE *)(v31 + 410) = v10 & 0xF1 | 2;
      v11 = v6[1];
      if ( v11 > 7 && (v11 & 3) == 0 )
      {
        v12 = (unsigned int *)(v6 + 4);
        v25 = v6[1];
        v26 = v6;
        v13 = (char *)v6 + v11 + 16;
        while ( 1 )
        {
          v14 = *v12;
          v15 = v12[1];
          if ( *v12 < v8 )
            break;
          v8 = (unsigned int)v12 + v15 + 8;
          if ( (unsigned int)v13 < v8 )
            break;
          if ( v14 == -1073741822 )
          {
            v6 = v26;
            v9 = v25;
            if ( v15 != 4 )
              break;
            v8 = -1073741822;
            v27 = v12[2];
            goto LABEL_7;
          }
          if ( v14 > 0xC0000002 )
            break;
          v8 = *v12;
          v12 = (unsigned int *)((char *)v12 + ((v15 + 3) & 0xFFFFFFFC) + 8);
          if ( v13 - (char *)v12 <= 7 )
          {
            v6 = v26;
            v9 = v25;
            goto LABEL_7;
          }
        }
      }
    }
  }
LABEL_20:
  if ( v28 )
    free((int)&savedregs, (int *)v8, (int)v28);
  return 0;
}
// 80CE000: using guessed type _TBYTE GLOBAL_OFFSET_TABLE_;

//----- (08088890) --------------------------------------------------------
void __usercall __noreturn lose(
        int *a1@<eax>,
        int a2@<edx>,
        unsigned int *a3@<ecx>,
        int a4,
        int a5,
        unsigned int *a6,
        int a7)
{
  if ( a2 != -1 )
    _close_nocancel(a2);
  if ( a5 && *(_DWORD *)(a5 + 428) != -1 )
    free((int)a3, a1, *(_DWORD *)(a5 + 428));
  free((int)a3, a1, a5);
  free((int)a3, a1, a4);
  if ( a7 )
  {
    *(_DWORD *)(a7 + 12) = 0;
    dl_debug_state();
  }
  dl_signal_error((int)a1, a3, 0, a6);
}

//----- (08088920) --------------------------------------------------------
_BYTE *__usercall add_name_to_object_isra_4@<eax>(_BYTE **a1@<eax>, unsigned int *a2@<edx>)
{
  _BYTE **v3; // esi
  _BYTE *result; // eax
  int v5; // eax
  int *v6; // ebp
  int v7; // eax
  unsigned int v8; // [esp+1Ch] [ebp-20h]

  if ( !a1 )
  {
    v7 = strlen(a2);
    if ( malloc((const struct timespec *)(v7 + 13)) )
      _assert_fail((int)"lastp != NULL", (int)"dl-load.c", 431, (int)"add_name_to_object");
    goto LABEL_9;
  }
  do
  {
    v3 = a1;
    result = (_BYTE *)strcmp((char *)a2, *a1);
    if ( !result )
      return result;
    a1 = (_BYTE **)v3[1];
  }
  while ( a1 );
  v5 = strlen(a2);
  v8 = v5 + 1;
  v6 = malloc((const struct timespec *)(v5 + 13));
  if ( !v6 )
LABEL_9:
    dl_signal_error(12, a2, 0, (unsigned int *)"cannot allocate name record");
  result = memcpy((_BYTE *)v6 + 12, a2, v8);
  v6[1] = 0;
  *v6 = (int)result;
  v6[2] = 0;
  v3[1] = v6;
  return result;
}

//----- (08088A10) --------------------------------------------------------
int __usercall open_verify_constprop_7@<eax>(unsigned int *a1@<eax>, int *a2@<edx>, int a3@<ecx>, _BYTE *a4, int a5)
{
  int *v7; // edi
  int v8; // eax
  signed int nocancel; // eax
  int v10; // edx
  _TBYTE *v11; // ecx
  unsigned __int8 v12; // dl
  __int16 v14; // dx
  int v15; // edx
  signed int v16; // ecx
  size_t v17; // esi
  size_t v18; // ecx
  unsigned int v19; // eax
  signed int v20; // esi
  _DWORD *v21; // eax
  int v22; // edx
  void *v23; // esp
  int *v24; // ebx
  int v25; // esi
  unsigned int v26; // eax
  unsigned int v27; // eax
  unsigned int *v28; // esi
  int v29; // eax
  unsigned int v30; // edx
  __int16 v31; // cx
  _BYTE *v32; // eax
  int v33; // eax
  void *v34; // esp
  _DWORD *v35; // eax
  int v36; // edx
  void *v37; // esp
  int v38; // edi
  int *v39; // eax
  char v40; // dl
  bool v41; // al
  unsigned __int8 v42; // dl
  signed int v43; // [esp-1018h] [ebp-1064h]
  _BYTE v44[4]; // [esp-1010h] [ebp-105Ch]
  _DWORD v45[1023]; // [esp-100Ch] [ebp-1058h] BYREF
  int v46; // [esp-10h] [ebp-5Ch]
  _BYTE v47[12]; // [esp-Ch] [ebp-58h] BYREF
  int *v48; // [esp+0h] [ebp-4Ch]
  unsigned int v49; // [esp+4h] [ebp-48h]
  int *v50; // [esp+8h] [ebp-44h]
  int v51; // [esp+Ch] [ebp-40h]
  unsigned int *v52; // [esp+10h] [ebp-3Ch]
  int *v53; // [esp+14h] [ebp-38h]
  unsigned int v54; // [esp+18h] [ebp-34h]
  size_t v55; // [esp+1Ch] [ebp-30h]
  int v56; // [esp+20h] [ebp-2Ch]
  unsigned int v57; // [esp+24h] [ebp-28h]
  int *v58; // [esp+28h] [ebp-24h]
  int *v59; // [esp+2Ch] [ebp-20h]
  _TBYTE *v60; // [esp+30h] [ebp-1Ch]
  int savedregs; // [esp+4Ch] [ebp+0h] BYREF

  v52 = a1;
  v60 = &GLOBAL_OFFSET_TABLE_;
  v58 = a2;
  v51 = a5;
  v56 = _open64_nocancel((int)a1, 0x80000);
  if ( v56 != -1 )
  {
    v7 = a2;
    v49 = -32;
    __writegsdword(0xFFFFFFE0, 0);
    *a2 = 0;
    v53 = a2 + 1;
    v8 = 0;
    while ( 1 )
    {
      nocancel = _read_nocancel(v56, (char *)v53 + v8, 512 - v8);
      if ( nocancel <= 0 )
        break;
      v8 = *a2 + nocancel;
      *a2 = v8;
      if ( (unsigned int)v8 > 0x33 )
        goto LABEL_5;
    }
    v8 = *v58;
LABEL_5:
    if ( v8 <= 51 )
    {
      v7 = (int *)__readgsdword(v49);
      v28 = (unsigned int *)(v60 - 11208);
      if ( v7 )
        v28 = (unsigned int *)((char *)v60 - 112065);
      goto LABEL_58;
    }
    v10 = v58[1];
    if ( v10 == *((_DWORD *)v60 - 27551) )
    {
      if ( v53[1] == *((_DWORD *)v60 - 27550) )
      {
LABEL_9:
        v12 = *((_BYTE *)v58 + 12);
        if ( (!v12 || *((_BYTE *)v58 + 11) == 3 && v12 <= 3u)
          && *(int *)((char *)v58 + 13) == *(_DWORD *)((char *)v60 - 110195)
          && *(_WORD *)((char *)v58 + 17) == *(_WORD *)((char *)v60 - 110191)
          && *((_BYTE *)v58 + 19) == *((_BYTE *)v60 - 110189) )
        {
          v7 = 0;
          if ( v58[6] != 1 )
          {
            v28 = (unsigned int *)((char *)v60 - 111428);
            goto LABEL_58;
          }
          if ( *((_WORD *)v58 + 11) == 3 )
          {
            v14 = *((_WORD *)v58 + 10);
            if ( (unsigned __int16)(v14 - 2) > 1u )
            {
              v28 = (unsigned int *)((char *)v60 - 111564);
              goto LABEL_58;
            }
            if ( v14 == 2 && (a3 & 0x20000000) == 0 )
            {
              v28 = (unsigned int *)(v60 - 11160);
              goto LABEL_58;
            }
            if ( *((_WORD *)v58 + 23) != 32 )
            {
              v28 = (unsigned int *)((char *)v60 - 111384);
              goto LABEL_58;
            }
            v15 = *((unsigned __int16 *)v58 + 24);
            v16 = v58[8];
            v17 = 32 * v15;
            if ( 32 * v15 + v16 > (unsigned int)v8 )
            {
              v35 = &v47[-((v17 + 27) & 0x3FF000)];
              if ( v47 != (_BYTE *)v35 )
              {
                while ( v45 != v35 )
                  ;
              }
              v36 = ((_WORD)v17 + 27) & 0xFF0;
              if ( (((_WORD)v17 + 27) & 0xFF0) != 0 )
              {
                v37 = alloca(v36);
                *(_DWORD *)&v44[v36] = *(_DWORD *)&v44[v36];
              }
              v38 = v56;
              v59 = v45;
              lseek(v56, v16, 0);
              if ( _read_nocancel(v38, v45, v17) != v17 )
                goto LABEL_89;
              v15 = *((unsigned __int16 *)v58 + 24);
              v17 = 32 * v15;
            }
            else
            {
              v59 = (int *)((char *)v53 + v16);
            }
            v7 = v59;
            v50 = 0;
            if ( v59 >= &v59[v17 / 4] )
              goto LABEL_15;
LABEL_32:
            if ( *v7 != 4 )
              goto LABEL_31;
            v18 = v7[4];
            if ( v18 <= 0x1F )
              goto LABEL_31;
            v19 = v7[7];
            v57 = v19;
            if ( v19 <= 3 || ((v19 - 4) & 0xFFFFFFFB) != 0 )
              goto LABEL_31;
            v20 = v7[1];
            if ( v18 + v20 <= *v58 )
            {
              v24 = (int *)((char *)v53 + v20);
LABEL_44:
              v48 = v7;
              v55 = -110232;
              v54 = v57 + 11;
              while ( *v24 != *(_DWORD *)((char *)v60 + v55)
                   || v24[1] != *((_DWORD *)v60 - 27557)
                   || v24[2] != *((_DWORD *)v60 - 27556)
                   || v24[3] != *((_DWORD *)v60 - 27555) )
              {
                v27 = -v57 & (v57 + v24[1] - 1 + (-v57 & (*v24 + v54)));
                if ( v27 > v18 - 32 )
                {
                  v7 = v48;
LABEL_70:
                  v15 = *((unsigned __int16 *)v58 + 24);
LABEL_31:
                  v7 += 8;
                  if ( v7 < &v59[8 * v15] )
                    goto LABEL_32;
                  goto LABEL_15;
                }
                v18 -= v27;
                v24 = (int *)((char *)v24 + v27);
              }
              v7 = v48;
              if ( !v18 )
                goto LABEL_70;
              if ( !v24[4]
                && (*((unsigned __int8 *)v24 + 28)
                  + ((*((unsigned __int8 *)v24 + 24) + (*((unsigned __int8 *)v24 + 20) << 8)) << 8) <= dl_osversion
                 || !dl_osversion) )
              {
                goto LABEL_15;
              }
              goto LABEL_14;
            }
            if ( v18 <= 0xFFFF )
            {
              v21 = &v47[-((v18 + 27) & 0xFFFFF000)];
              if ( v47 != (_BYTE *)v21 )
              {
                while ( v45 != v21 )
                  ;
              }
              v22 = ((_WORD)v18 + 27) & 0xFF0;
              if ( (((_WORD)v18 + 27) & 0xFF0) != 0 )
              {
                v23 = alloca(v22);
                *(_DWORD *)&v44[v22] = *(_DWORD *)&v44[v22];
              }
              v24 = v45;
              goto LABEL_43;
            }
            v55 = v18;
            v39 = realloc((int)&savedregs, v50, (const struct timespec *)v18);
            v24 = v39;
            if ( v39 )
            {
              v50 = v39;
              v18 = v55;
LABEL_43:
              v55 = v18;
              v43 = v20;
              v25 = v56;
              lseek(v56, v43, 0);
              v26 = _read_nocancel(v25, v24, v55);
              v18 = v55;
              if ( v55 == v26 )
                goto LABEL_44;
              free((int)&savedregs, v7, (int)v50);
            }
LABEL_89:
            v7 = (int *)__readgsdword(v49);
            v28 = (unsigned int *)((char *)v60 - 112065);
            goto LABEL_58;
          }
          v50 = 0;
LABEL_14:
          _close_nocancel(v56);
          __writegsdword(v49, 2u);
          v56 = -1;
LABEL_15:
          free((int)&savedregs, v7, (int)v50);
          return v56;
        }
        goto LABEL_11;
      }
      v11 = v60;
      if ( v10 != *((_DWORD *)v60 - 27554) )
      {
LABEL_11:
        if ( v58[1] != 1179403647 )
        {
          v7 = 0;
          v28 = (unsigned int *)((char *)v60 - 111948);
          goto LABEL_58;
        }
        if ( *((_BYTE *)v58 + 8) != 1 )
        {
          v50 = 0;
          *a4 = 1;
          goto LABEL_14;
        }
        if ( *((_BYTE *)v58 + 9) == 1 )
        {
          if ( *((_BYTE *)v58 + 10) == 1 )
          {
            v40 = *((_BYTE *)v58 + 11);
            v41 = v40 != 3;
            if ( !v40 || v40 == 3 )
            {
              v42 = *((_BYTE *)v58 + 12);
              if ( v42 && (v42 > 3u || v41) )
              {
                v7 = 0;
                v28 = (unsigned int *)((char *)v60 - 112019);
              }
              else
              {
                v46 = *((unsigned __int8 *)v58 + 12);
                v28 = (unsigned int *)((char *)v60 - 111963);
                v7 = (int *)memcmp((unsigned int *)((char *)v58 + 13), (unsigned int *)((char *)v60 - 110195), 7);
                if ( v7 )
                {
                  v7 = 0;
                  v28 = (unsigned int *)(v60 - 11199);
                }
              }
            }
            else
            {
              v7 = 0;
              v28 = (unsigned int *)((char *)v60 - 112043);
            }
          }
          else
          {
            v7 = 0;
            v28 = (unsigned int *)((char *)v60 - 111524);
          }
        }
        else
        {
          v7 = 0;
          v28 = (unsigned int *)((char *)v60 - 111472);
        }
LABEL_58:
        if ( (_BYTE)v51 )
        {
          v29 = strlen(v52);
          v30 = v29 + 1;
          v31 = (v29 + 28) & 0xFFF0;
          v32 = &v47[-((v29 + 28) & 0xFFFFF000)];
          while ( v47 != v32 )
            ;
          v33 = v31 & 0xFFF;
          if ( (v31 & 0xFFF) != 0 )
          {
            v34 = alloca(v33);
            *(_DWORD *)&v47[v33 - 4] = *(_DWORD *)&v47[v33 - 4];
          }
          v59 = (int *)memcpy(v47, v52, v30);
          free((int)&savedregs, v7, (int)v52);
          v52 = (unsigned int *)v59;
        }
        v45[1020] = 0;
        lose(v7, v56, v52, 0, 0, v28, 0);
      }
    }
    else
    {
      v11 = v60;
      if ( v10 != *((_DWORD *)v60 - 27554) )
        goto LABEL_11;
    }
    if ( v53[1] == *((_DWORD *)v11 - 27553) )
      goto LABEL_9;
    goto LABEL_11;
  }
  return v56;
}
// 80CE000: using guessed type _TBYTE GLOBAL_OFFSET_TABLE_;

//----- (080890B0) --------------------------------------------------------
int __usercall open_path@<eax>(
        _BYTE *a1@<eax>,
        unsigned int a2@<edx>,
        const char *a3@<ecx>,
        int *a4,
        _DWORD *a5,
        int *a6,
        int a7,
        int a8,
        _BYTE *a9)
{
  unsigned int v11; // ecx
  _BYTE *v12; // eax
  __int16 v13; // cx
  int v14; // ecx
  int v15; // edi
  unsigned int v16; // esi
  _WORD *v17; // eax
  unsigned int v18; // eax
  _WORD *v19; // eax
  _WORD *v20; // eax
  const char *v21; // edx
  int v22; // eax
  int *v23; // eax
  int v24; // edx
  unsigned int v26; // eax
  unsigned int v27; // eax
  const char *v28; // ecx
  unsigned int v29; // eax
  int v30; // edx
  int v31; // eax
  bool v32; // zf
  int v33; // eax
  const char *v34; // eax
  int v35; // edx
  _BYTE *v36; // ecx
  __int16 v37; // dx
  int v38; // edx
  void *v39; // esp
  int v40; // eax
  int *v41; // esi
  unsigned int v42; // edi
  char *v43; // eax
  struct timespec *v44; // eax
  void *v45; // esp
  const char *v46; // eax
  _BYTE v47[4]; // [esp-2010h] [ebp-20CCh]
  _BYTE v48[4096]; // [esp-200Ch] [ebp-20C8h] BYREF
  _BYTE v49[4096]; // [esp-100Ch] [ebp-10C8h] BYREF
  _BYTE v50[12]; // [esp-Ch] [ebp-C8h] BYREF
  int v51; // [esp+0h] [ebp-BCh]
  _BYTE *v52; // [esp+4h] [ebp-B8h]
  const char *v53; // [esp+8h] [ebp-B4h]
  int *v54; // [esp+Ch] [ebp-B0h]
  const char *v55; // [esp+10h] [ebp-ACh]
  int v56; // [esp+14h] [ebp-A8h]
  const char *v57; // [esp+18h] [ebp-A4h]
  int *v58; // [esp+1Ch] [ebp-A0h]
  _BYTE *v59; // [esp+20h] [ebp-9Ch]
  unsigned int v60; // [esp+24h] [ebp-98h]
  unsigned int v61; // [esp+28h] [ebp-94h]
  _BYTE *v62; // [esp+2Ch] [ebp-90h]
  _DWORD *v63; // [esp+30h] [ebp-8Ch]
  struct timespec *v64; // [esp+34h] [ebp-88h]
  int v65; // [esp+38h] [ebp-84h]
  int v66; // [esp+3Ch] [ebp-80h]
  unsigned int v67; // [esp+40h] [ebp-7Ch]
  struct stat v68; // [esp+44h] [ebp-78h] BYREF
  int savedregs; // [esp+BCh] [ebp+0h] BYREF

  v58 = (int *)*a4;
  if ( !v58 )
    return -1;
  v11 = a2 + max_dirnamelen + max_capstrlen + 27;
  v67 = v11 & 0xFFFFFFF0;
  v12 = &v50[-(v11 & 0xFFFFF000)];
  v13 = v11 & 0xFFF0;
  if ( v50 != v12 )
  {
    while ( v49 != v12 )
      ;
  }
  v14 = v13 & 0xFFF;
  if ( v14 )
  {
    v45 = alloca(v14);
    *(_DWORD *)&v48[v14 + 4092] = *(_DWORD *)&v48[v14 + 4092];
  }
  v66 = (int)a3;
  v61 = a2;
  v67 = (unsigned int)v49;
  v59 = a1;
  v56 = 0;
  v15 = *v58;
  v53 = 0;
  v63 = dl_debug_mask;
  v54 = &_libc_enable_secure;
  while ( 1 )
  {
    v65 = *v63 & 1;
    if ( v65 )
    {
      v55 = *(const char **)(v15 + 4);
      if ( v55 != v53 )
      {
        v34 = *(const char **)(v15 + 8);
        v52 = v49;
        v53 = v34;
        v35 = max_dirnamelen + max_capstrlen + 15;
        v36 = &v49[-(v35 & 0xFFFFF000)];
        v37 = v35 & 0xFFF0;
        if ( v49 != v36 )
        {
          while ( v48 != v36 )
            ;
        }
        v38 = v37 & 0xFFF;
        if ( v38 )
        {
          v39 = alloca(v38);
          *(_DWORD *)&v47[v38] = *(_DWORD *)&v47[v38];
        }
        v64 = (struct timespec *)v48;
        dl_debug_printf(" search path=");
        v40 = *v58;
        if ( *v58 && v55 == *(const char **)(v40 + 4) )
        {
          v51 = v15;
          v41 = v58;
          v57 = ":%s";
          do
          {
            v62 = mempcpy(v64, *(_BYTE **)(v40 + 12), *(_DWORD *)(v40 + 16));
            if ( ncapstr )
            {
              v42 = 0;
              v60 = (unsigned int)"%s";
              do
              {
                if ( *(_DWORD *)(*v41 + 4 * v42 + 20) != 1 )
                {
                  v44 = (struct timespec *)mempcpy(
                                             v62,
                                             *(_BYTE **)(capstr + 8 * v42),
                                             *(_DWORD *)(capstr + 8 * v42 + 4));
                  if ( v64 == v44 )
                  {
                    LOBYTE(v44->tv_sec) = 0;
                  }
                  else if ( v44 == (struct timespec *)((char *)&v64->tv_sec + 1) && LOBYTE(v64->tv_sec) == 47 )
                  {
                    LOBYTE(v44->tv_sec) = 0;
                  }
                  else
                  {
                    HIBYTE(v44[-1].tv_nsec) = 0;
                  }
                  v43 = (char *)v57;
                  if ( v65 )
                    v43 = (char *)v60;
                  dl_debug_printf_c(v43, v64);
                  v65 = 0;
                }
                ++v42;
              }
              while ( v42 < ncapstr );
            }
            v40 = *++v41;
          }
          while ( *v41 && v55 == *(const char **)(v40 + 4) );
          v15 = v51;
        }
        if ( v53 )
        {
          if ( !*v53 )
          {
            v46 = "<main program>";
            if ( program_invocation_short_name[0] )
              v46 = (const char *)program_invocation_short_name[0];
            v53 = v46;
          }
          dl_debug_printf_c("\t\t(%s from file %s)\n", v55, v53);
        }
        else
        {
          dl_debug_printf_c("\t\t(%s)\n", v55);
        }
        v53 = v55;
      }
    }
    v16 = 0;
    v17 = mempcpy((_BYTE *)v67, *(_BYTE **)(v15 + 12), *(_DWORD *)(v15 + 16));
    v65 = 0;
    v62 = v17;
LABEL_9:
    v18 = ncapstr;
    v60 = -32;
    if ( ncapstr > v16 )
      break;
LABEL_27:
    if ( v65 )
    {
      v27 = __readgsdword(0xFFFFFFE0);
      if ( v27 != 13 && v27 != 2 )
        return -1;
    }
    ++v58;
    v56 |= v65;
    v15 = *v58;
    if ( !*v58 )
    {
      if ( !v56 )
      {
        if ( a4[1] )
          free((int)&savedregs, 0, *a4);
        if ( a4 != &env_path_list && a4 != &rtld_search_dirs )
          *a4 = -1;
      }
      return -1;
    }
  }
  while ( *(_DWORD *)(v15 + 4 * v16 + 20) == 1 )
  {
LABEL_26:
    if ( v18 <= ++v16 )
      goto LABEL_27;
  }
  v19 = mempcpy(v62, *(_BYTE **)(capstr + 8 * v16), *(_DWORD *)(capstr + 8 * v16 + 4));
  v20 = mempcpy(v19, v59, v61);
  v64 = (struct timespec *)((char *)v20 - v67);
  if ( (*(_BYTE *)v63 & 1) != 0 )
    dl_debug_printf("  trying file=%s\n", v67);
  v21 = (const char *)open_verify_constprop_7((unsigned int *)v67, a6, v66, a9, 0);
  v22 = *(_DWORD *)(v15 + 4 * v16 + 20);
  if ( v22 )
  {
    v65 |= v22 != 1;
    if ( v21 == (const char *)-1 )
      goto LABEL_38;
  }
  else
  {
    if ( v21 == (const char *)-1 )
    {
      if ( a7 && (*((_BYTE *)*(&dl_ns + 19 * *(_DWORD *)(a7 + 24)) + 409) & 8) != 0 )
      {
        v65 = 1;
      }
      else
      {
        v28 = (const char *)v67;
        *((_BYTE *)&v64->tv_sec + v67 + ~v61) = 0;
        v29 = _xstat64(3, v28, &v68);
        v30 = 1;
        if ( !v29 )
        {
          v31 = v68.st_mode & 0xF000;
          v30 = (v31 == 0x4000) + 1;
          v32 = v31 == 0x4000;
          v33 = 1;
          if ( !v32 )
            v33 = v65;
          v65 = v33;
        }
        *(_DWORD *)(v15 + 4 * v16 + 20) = v30;
      }
LABEL_38:
      ++v16;
      goto LABEL_9;
    }
    *(_DWORD *)(v15 + 4 * v16 + 20) = 2;
    v65 = 1;
  }
  if ( (v66 & 0x4000000) == 0 )
    goto LABEL_19;
  if ( *v54 )
  {
    v57 = v21;
    v26 = _fxstat64(3, (int)v21, &v68);
    v21 = v57;
    if ( v26 || (v68.st_mode & 0x800) == 0 )
    {
      _close_nocancel((int)v57);
      __writegsdword(v60, 2u);
      v18 = ncapstr;
      goto LABEL_26;
    }
  }
  ++v16;
  if ( v21 == (const char *)-1 )
    goto LABEL_9;
LABEL_19:
  v66 = (int)v21;
  v23 = malloc(v64);
  v24 = v66;
  *a5 = v23;
  if ( v23 )
  {
    v66 = v24;
    memcpy(v23, (_BYTE *)v67, (unsigned int)v64);
    return v66;
  }
  _close_nocancel(v24);
  return -1;
}
// 80CDDA4: using guessed type char (**dl_argv)[1671];
// 80CDDAC: using guessed type int _libc_enable_secure;
// 80CDFB4: using guessed type int rtld_search_dirs;
// 80CDFBC: using guessed type int max_capstrlen;
// 80CDFC0: using guessed type int ncapstr;
// 80CDFC4: using guessed type int capstr;
// 80CDFC8: using guessed type int env_path_list;
// 80CE964: using guessed type char (*program_invocation_short_name[2])[1671];
// 80CEA00: using guessed type void *dl_ns;
// 80CFA44: using guessed type int max_dirnamelen;
// 80CFF04: using guessed type _BYTE dl_debug_mask[4];

//----- (08089720) --------------------------------------------------------
int __usercall dl_map_object_from_fd_constprop_8@<eax>(
        unsigned int *a1@<eax>,
        int a2@<edx>,
        _DWORD *a3@<ecx>,
        unsigned int *a4,
        unsigned __int8 *a5,
        char a6,
        int a7,
        int a8,
        int a9)
{
  int v10; // edi
  void *v12; // eax
  unsigned __int8 *v13; // eax
  _DWORD *v14; // esi
  signed int v15; // edx
  int v16; // eax
  size_t v17; // ebx
  const struct timespec *v18; // esi
  int v19; // edx
  _BYTE *v20; // ecx
  __int16 v21; // dx
  int v22; // edx
  void *v23; // esp
  struct timespec *v24; // ebx
  int v25; // esi
  __time_t tv_sec; // eax
  int v27; // eax
  int v28; // eax
  __time_t v29; // ecx
  __time_t v30; // eax
  int tv_nsec; // edi
  int v32; // ecx
  __time_t v33; // ecx
  __time_t v34; // eax
  int *v35; // edx
  unsigned int v36; // edi
  int v37; // edi
  unsigned int v38; // eax
  int v39; // ecx
  unsigned int v40; // edi
  bool v41; // cc
  char v42; // cl
  unsigned int *v43; // esi
  struct timespec *v44; // esi
  int v45; // ebx
  size_t v46; // eax
  unsigned int v47; // eax
  unsigned int v48; // edx
  int v49; // eax
  bool v50; // zf
  unsigned __int8 *v51; // ecx
  unsigned int v52; // eax
  unsigned int v53; // edx
  unsigned int v54; // edx
  unsigned __int8 *v55; // ebx
  int v56; // ebx
  unsigned int v57; // edx
  unsigned int v58; // eax
  unsigned int v59; // eax
  _BYTE *v60; // eax
  int v61; // ecx
  void *v62; // esp
  int v63; // eax
  unsigned int *v64; // edx
  unsigned int v65; // eax
  int v66; // ebx
  int v67; // eax
  int v68; // eax
  int v69; // eax
  int v70; // eax
  int v71; // eax
  int v72; // eax
  int v73; // eax
  int v74; // eax
  int v75; // eax
  int v76; // eax
  int v77; // eax
  unsigned int v78; // ecx
  int v79; // edx
  int v80; // eax
  int v81; // eax
  int v82; // eax
  _BYTE *v83; // ecx
  int v84; // eax
  int v85; // eax
  int v86; // eax
  _BYTE *v87; // esi
  int v88; // edx
  unsigned int v89; // eax
  unsigned int v90; // eax
  unsigned int v91; // ebx
  unsigned int v92; // edx
  int v93; // ecx
  int v94; // edx
  int v95; // edx
  int v96; // eax
  int *v97; // eax
  _BYTE *v98; // eax
  int v99; // eax
  _BYTE *v100; // eax
  int v101; // edx
  void *v102; // edx
  unsigned __int8 *v103; // [esp-1014h] [ebp-10F4h]
  _BYTE v104[4]; // [esp-100Ch] [ebp-10ECh]
  _BYTE v105[3]; // [esp-1008h] [ebp-10E8h] BYREF
  char v106; // [esp-1005h] [ebp-10E5h] BYREF
  _BYTE v107[8]; // [esp-8h] [ebp-E8h] BYREF
  unsigned int v108; // [esp+0h] [ebp-E0h]
  unsigned __int8 *v109; // [esp+4h] [ebp-DCh]
  _BYTE *v110; // [esp+8h] [ebp-D8h]
  size_t *v111; // [esp+Ch] [ebp-D4h]
  _BYTE *v112; // [esp+10h] [ebp-D0h]
  char v113; // [esp+17h] [ebp-C9h]
  int *stack_executable_hook; // [esp+18h] [ebp-C8h]
  int v115; // [esp+1Ch] [ebp-C4h]
  unsigned __int8 *v116; // [esp+20h] [ebp-C0h]
  __time_t v117; // [esp+24h] [ebp-BCh]
  unsigned int v118; // [esp+28h] [ebp-B8h]
  unsigned int st_dev_high; // [esp+2Ch] [ebp-B4h]
  unsigned int st_dev; // [esp+30h] [ebp-B0h]
  unsigned __int8 *v121; // [esp+34h] [ebp-ACh]
  unsigned __int8 *v122; // [esp+38h] [ebp-A8h]
  unsigned int *v123; // [esp+3Ch] [ebp-A4h]
  void **v124; // [esp+40h] [ebp-A0h]
  unsigned int v125; // [esp+44h] [ebp-9Ch]
  unsigned int v126; // [esp+48h] [ebp-98h]
  _DWORD *v127; // [esp+4Ch] [ebp-94h]
  unsigned int v128; // [esp+50h] [ebp-90h]
  size_t v129; // [esp+54h] [ebp-8Ch]
  int v130; // [esp+58h] [ebp-88h]
  unsigned int v131; // [esp+5Ch] [ebp-84h]
  _TBYTE *v132; // [esp+60h] [ebp-80h]
  int v133; // [esp+64h] [ebp-7Ch]
  struct stat v134; // [esp+68h] [ebp-78h] BYREF
  unsigned int v135; // [esp+C0h] [ebp-20h]
  unsigned int v136; // [esp+C4h] [ebp-1Ch]
  int v137; // [esp+D0h] [ebp-10h]
  int v138; // [esp+D8h] [ebp-8h]
  int v139; // [esp+DCh] [ebp-4h]
  int savedregs; // [esp+E0h] [ebp+0h] BYREF

  v130 = a2;
  v127 = a3;
  v123 = a1;
  v132 = &GLOBAL_OFFSET_TABLE_;
  v124 = dl_debug_initialize(0, a9);
  if ( (_fxstat64(3, a2, &v134) & 0x80000000) != 0 )
  {
    v10 = 0;
    v43 = (unsigned int *)(v132 - 11182);
    stack_executable_hook = (int *)__readgsdword(0xFFFFFFE0);
LABEL_86:
    v124 = 0;
LABEL_84:
    v137 = a9;
    lose(stack_executable_hook, v130, v123, (int)a4, v10, v43, (int)v124);
  }
  st_dev_high = HIDWORD(v134.st_dev);
  st_dev = v134.st_dev;
  v128 = v135;
  v118 = v136;
  v10 = (int)*(&dl_ns + 19 * a9);
  if ( !v10 )
  {
LABEL_10:
    stack_executable_hook = (int *)(a7 & 4);
    if ( (a7 & 4) != 0 )
    {
      v10 = 0;
      free((int)&savedregs, 0, (int)a4);
      _close_nocancel(v130);
      return v10;
    }
    v110 = dl_debug_mask;
    if ( (dl_debug_mask[0] & 0x40) != 0 )
      dl_debug_printf((_BYTE *)v132 - 110868, v123, a9);
    v12 = v124[3];
    if ( v12 )
    {
      if ( v12 != (void *)1 )
        _assert_fail((int)v132 - 111739, (int)v132 - 112104, 999, (int)(v132 - 11032));
      v113 = 0;
    }
    else
    {
      v124[3] = (void *)1;
      dl_debug_state();
      v113 = 1;
    }
    v13 = dl_new_object((int *)v10, a4, v123, a6, a5, a7, a9);
    v10 = (int)v13;
    if ( !v13 )
    {
      v43 = (unsigned int *)((char *)v132 - 111296);
      goto LABEL_162;
    }
    v14 = v127;
    v15 = v127[8];
    *((_DWORD *)v13 + 86) = v127[7];
    LOWORD(v111) = *((_WORD *)v14 + 10);
    v16 = *((unsigned __int16 *)v14 + 24);
    *(_WORD *)(v10 + 348) = v16;
    v17 = 32 * v16;
    if ( (unsigned int)(32 * v16 + v15) > *v14 )
    {
      v60 = &v107[-((v17 + 27) & 0x3FF000)];
      if ( v107 != v60 )
      {
        while ( v105 != v60 )
          ;
      }
      v61 = ((_WORD)v17 + 27) & 0xFF0;
      if ( (((_WORD)v17 + 27) & 0xFF0) != 0 )
      {
        v62 = alloca(v61);
        *(_DWORD *)&v104[v61] = *(_DWORD *)&v104[v61];
      }
      v18 = (const struct timespec *)v105;
      lseek(v130, v15, 0);
      if ( _read_nocancel(v130, v105, v17) != v17 )
      {
        v43 = (unsigned int *)((char *)v132 - 112065);
        goto LABEL_162;
      }
      v16 = *(unsigned __int16 *)(v10 + 348);
      v17 = 32 * v16;
    }
    else
    {
      v18 = (const struct timespec *)((char *)v14 + v15 + 4);
    }
    v112 = v107;
    v19 = 24 * v16 + 15;
    v20 = &v107[-(v19 & 0x3FF000)];
    v21 = v19 & 0xFFF0;
    if ( v107 != v20 )
    {
      while ( v105 != v20 )
        ;
    }
    v22 = v21 & 0xFFF;
    if ( v22 )
    {
      v23 = alloca(v22);
      *(_DWORD *)&v104[v22] = *(_DWORD *)&v104[v22];
    }
    v108 = (unsigned int)&v106 >> 2;
    v122 = v105;
    if ( v18 >= &v18[v17 / 8] )
      goto LABEL_177;
    v24 = (struct timespec *)v18;
    v133 = (int)v18;
    v25 = v10;
    v117 = 7;
    LOBYTE(v115) = 0;
    v131 = 0;
    v109 = (unsigned __int8 *)&dl_tls_dtv_slotinfo_list;
    v116 = (unsigned __int8 *)&dl_pagesize;
    do
    {
      tv_sec = v24->tv_sec;
      if ( v24->tv_sec == 6 )
      {
        *(_DWORD *)(v25 + 340) = v24[1].tv_sec;
      }
      else if ( v24->tv_sec <= 6u )
      {
        switch ( tv_sec )
        {
          case 2:
            if ( v24[2].tv_sec )
            {
              *(_DWORD *)(v25 + 8) = v24[1].tv_sec;
              *(_WORD *)(v25 + 350) = (unsigned int)v24[2].tv_nsec >> 3;
            }
            break;
          case 4:
            if ( dl_process_pt_note(v25, v24, v130, v127) )
            {
              v10 = v25;
              v43 = (unsigned int *)((char *)v132 - 111794);
              goto LABEL_83;
            }
            break;
          case 1:
            tv_nsec = v24[3].tv_nsec;
            v32 = *(_DWORD *)v116 - 1;
            v125 = *(_DWORD *)v116;
            v121 = (unsigned __int8 *)v32;
            if ( (tv_nsec & v32) != 0 )
            {
              v10 = v25;
              v43 = (unsigned int *)((char *)v132 - 111048);
              goto LABEL_83;
            }
            v33 = v24[1].tv_sec;
            v129 = v24->tv_nsec;
            if ( ((tv_nsec - 1) & (v33 - v129)) != 0 )
            {
              v10 = v25;
              v43 = (unsigned int *)((char *)v132 - 111004);
              goto LABEL_83;
            }
            v34 = v24[2].tv_sec;
            if ( *(__int64 *)&v134.st_size < v34 + v129 )
            {
              v10 = v25;
              v43 = (unsigned int *)((char *)v132 - 111084);
              goto LABEL_83;
            }
            v126 = v131 + 1;
            v125 = -v125;
            v35 = (int *)&v122[24 * v131];
            v36 = v125;
            v35[2] = v33 + v34;
            v37 = v33 & v36;
            v38 = (unsigned int)&v121[v35[2]];
            v39 = v24[2].tv_nsec + v33;
            *v35 = v37;
            v40 = v125;
            v35[3] = v39;
            v35[1] = v40 & v38;
            v41 = v126 <= 1;
            v35[4] = v40 & v129;
            if ( !v41 )
            {
              v42 = v115;
              if ( *(v35 - 5) != *v35 )
                v42 = 1;
              LOBYTE(v115) = v42;
            }
            *(_DWORD *)&v122[24 * v131 + 20] = (1934713408 >> (4 * (v24[3].tv_sec & 7))) & 0xF;
            v131 = v126;
            break;
        }
      }
      else
      {
        switch ( tv_sec )
        {
          case 1685382481:
            v117 = v24[3].tv_sec;
            break;
          case 1685382482:
            *(_DWORD *)(v25 + 592) = v24[1].tv_sec;
            *(_DWORD *)(v25 + 596) = v24[2].tv_nsec;
            break;
          case 7:
            v27 = v24[2].tv_nsec;
            if ( v27 )
            {
              *(_DWORD *)(v25 + 568) = v27;
              v28 = v24[3].tv_nsec;
              *(_DWORD *)(v25 + 572) = v28;
              v29 = v24[1].tv_sec;
              if ( v28 )
                v28 = v29 & (v28 - 1);
              *(_DWORD *)(v25 + 576) = v28;
              v30 = v24[2].tv_sec;
              *(_DWORD *)(v25 + 560) = v29;
              *(_DWORD *)(v25 + 564) = v30;
              if ( (*(_BYTE *)(v25 + 408) & 3) != 1 && !*(_DWORD *)v109 )
                _assert_fail((int)v132 - 110828, (int)v132 - 112104, 1156, (int)(v132 - 11032));
              *(_DWORD *)(v25 + 584) = dl_next_tls_modid();
            }
            break;
        }
      }
      v24 += 4;
    }
    while ( (unsigned int)v24 < v133 + 32 * (unsigned int)*(unsigned __int16 *)(v25 + 348) );
    v10 = v25;
    v44 = (struct timespec *)v133;
    if ( !v131 )
    {
LABEL_177:
      v43 = (unsigned int *)((char *)v132 - 111124);
      goto LABEL_83;
    }
    v126 = (unsigned __int16)v111;
    if ( (unsigned __int16)v111 != 3 )
    {
      if ( (a7 & 0x20000000) != 0 )
      {
        v93 = *(_DWORD *)&v122[24 * v131 - 12];
        v94 = *(_DWORD *)(4 * v108);
        v129 = v93 - v94;
        v95 = *(_DWORD *)v10 + v94;
        v96 = v93 + *(_DWORD *)v10;
        v51 = v122;
        *(_DWORD *)(v10 + 436) = v96;
        LOBYTE(v96) = v115;
        *(_DWORD *)(v10 + 432) = v95;
        *(_BYTE *)(v10 + 409) = ((((unsigned __int8)v96 ^ 1) & 1) << 6) | *(_BYTE *)(v10 + 409) & 0xBF;
        goto LABEL_72;
      }
      v43 = (unsigned int *)(v132 - 11160);
      goto LABEL_83;
    }
    v45 = *(_DWORD *)(4 * v108);
    v46 = *(_DWORD *)&v122[24 * v131 - 12] - v45;
    v133 = *(_DWORD *)(4 * v108 + 0x14);
    v129 = v46;
    v47 = mmap((void *)(v45 & dl_use_load_bias), v46, v133, 2050, v130, *(_DWORD *)(4 * v108 + 0x10));
    *(_DWORD *)(v10 + 432) = v47;
    if ( v47 == -1 )
    {
LABEL_75:
      v43 = (unsigned int *)((char *)v132 - 110912);
      goto LABEL_83;
    }
    v48 = v47 + v129;
    v49 = v47 - v45;
    v50 = (_BYTE)v115 == 0;
    *(_DWORD *)(v10 + 436) = v48;
    *(_DWORD *)v10 = v49;
    if ( !v50
      && (mprotect(
            (const void *)(*(_DWORD *)(4 * v108 + 4) + v49),
            *(_DWORD *)&v122[24 * v131 - 24] - *(_DWORD *)(4 * v108 + 4),
            0) & 0x80000000) != 0 )
    {
LABEL_182:
      v43 = (unsigned int *)((char *)v132 - 110948);
      goto LABEL_83;
    }
    *(_BYTE *)(v10 + 409) |= 0x40u;
    v51 = v122;
    while ( 1 )
    {
      if ( (v133 & 4) != 0 )
        *(_DWORD *)(v10 + 440) = *(_DWORD *)v10 + *((_DWORD *)v51 + 1);
      if ( !*(_DWORD *)(v10 + 340) )
      {
        v90 = *((_DWORD *)v51 + 4);
        v91 = v127[8];
        if ( v90 <= v91 )
        {
          v92 = *(_DWORD *)v51;
          v121 = (unsigned __int8 *)*((_DWORD *)v51 + 4);
          v125 = v92;
          if ( v90 + *((_DWORD *)v51 + 1) - v92 >= v91 + 32 * *((unsigned __int16 *)v127 + 24) )
            *(_DWORD *)(v10 + 340) = v91 + v125 - (_DWORD)v121;
        }
      }
      v52 = *((_DWORD *)v51 + 3);
      v53 = *((_DWORD *)v51 + 2);
      if ( v52 > v53 )
      {
        v54 = *(_DWORD *)v10 + v53;
        v125 = *(_DWORD *)v10 + v52;
        v111 = (size_t *)&dl_pagesize;
        v116 = (unsigned __int8 *)dl_pagesize;
        v115 = -dl_pagesize;
        v55 = (unsigned __int8 *)(-dl_pagesize & (v54 + dl_pagesize - 1));
        if ( v125 <= (unsigned int)v55 )
          v55 = (unsigned __int8 *)v125;
        v121 = v55;
        if ( v54 < (unsigned int)v55 )
        {
          if ( (v133 & 2) != 0 )
          {
            v116 = v51;
            memset((unsigned __int8 *)v54, 0, (unsigned int)&v121[-v54]);
            v51 = v116;
          }
          else
          {
            v109 = v51;
            v103 = v116;
            v116 = (unsigned __int8 *)v54;
            if ( (mprotect((const void *)(v54 & v115), (size_t)v103, v133 | 2) & 0x80000000) != 0 )
              goto LABEL_182;
            v115 = (int)v109;
            memset(v116, 0, v121 - v116);
            mprotect((const void *)((unsigned int)v116 & -*v111), *v111, v133);
            v51 = (unsigned __int8 *)v115;
          }
        }
        if ( v125 > (unsigned int)v121 )
        {
          v116 = v51;
          v89 = mmap(v121, v125 - (_DWORD)v121, v133, 50, -1, 0);
          v51 = v116;
          if ( v89 == -1 )
          {
            v43 = (unsigned int *)((char *)v132 - 111766);
            goto LABEL_83;
          }
        }
      }
      v51 += 24;
LABEL_72:
      v56 = (int)v122;
      if ( v51 >= &v122[24 * v131] )
        break;
      v57 = *((_DWORD *)v51 + 1);
      v58 = *(_DWORD *)v51;
      v133 = *((_DWORD *)v51 + 5);
      if ( v57 > v58 )
      {
        v103 = (unsigned __int8 *)*((_DWORD *)v51 + 4);
        v125 = (unsigned int)v51;
        v59 = mmap((void *)(*(_DWORD *)v10 + v58), v57 - v58, v133, 2066, v130, (unsigned int)v103);
        v51 = (unsigned __int8 *)v125;
        if ( v59 == -1 )
          goto LABEL_75;
      }
    }
    v63 = *(_DWORD *)(v10 + 8);
    if ( v63 )
    {
      v64 = (unsigned int *)(v63 + *(_DWORD *)v10);
      v133 = *(_DWORD *)v10;
      *(_DWORD *)(v10 + 8) = v64;
      if ( v64 )
      {
        v65 = *v64;
        v66 = v10 + 32;
        if ( !*v64 )
        {
LABEL_92:
          if ( v133 )
          {
            v67 = *(_DWORD *)(v10 + 48);
            if ( v67 )
              *(_DWORD *)(v67 + 4) += v133;
            v68 = *(_DWORD *)(v10 + 44);
            if ( v68 )
              *(_DWORD *)(v68 + 4) += v133;
            v69 = *(_DWORD *)(v10 + 52);
            if ( v69 )
              *(_DWORD *)(v69 + 4) += v133;
            v70 = *(_DWORD *)(v10 + 56);
            if ( v70 )
              *(_DWORD *)(v70 + 4) += v133;
            v71 = *(_DWORD *)(v10 + 60);
            if ( v71 )
              *(_DWORD *)(v71 + 4) += v133;
            v72 = *(_DWORD *)(v10 + 100);
            if ( v72 )
              *(_DWORD *)(v72 + 4) += v133;
            v73 = *(_DWORD *)(v10 + 124);
            if ( v73 )
              *(_DWORD *)(v73 + 4) += v133;
            v74 = *(_DWORD *)(v10 + 232);
            if ( v74 )
              *(_DWORD *)(v74 + 4) += v133;
            v75 = *(_DWORD *)(v10 + 336);
            if ( v75 )
              *(_DWORD *)(v75 + 4) += v133;
          }
          v76 = *(_DWORD *)(v10 + 112);
          if ( v76 )
          {
            v77 = *(_DWORD *)(v76 + 4);
            if ( v77 != 17 && v77 != 7 )
              _assert_fail((int)(v132 - 16976), (int)v132 - 169911, 126, (int)v132 - 169516);
          }
          v56 = *(_DWORD *)(v10 + 60);
          if ( v56 && *(_DWORD *)(*(_DWORD *)(v10 + 68) + 4) != 12 )
            _assert_fail((int)(v132 - 16968), (int)v132 - 169911, 131, (int)v132 - 169516);
          if ( *(_DWORD *)(v10 + 100) && *(_DWORD *)(*(_DWORD *)(v10 + 108) + 4) != 8 )
            _assert_fail((int)v132 - 169628, (int)v132 - 169911, 135, (int)v132 - 169516);
          v79 = *(_DWORD *)(v10 + 152);
          if ( v79 )
          {
            v80 = *(_DWORD *)(v79 + 4);
            *(_DWORD *)(v10 + 524) = v80;
            if ( (v80 & 2) != 0 )
              *(_DWORD *)(v10 + 96) = v79;
            if ( (v80 & 4) != 0 )
              *(_DWORD *)(v10 + 120) = v79;
            if ( (v80 & 8) != 0 )
              *(_DWORD *)(v10 + 128) = v79;
          }
          v81 = *(_DWORD *)(v10 + 188);
          if ( v81 )
          {
            v82 = *(_DWORD *)(v81 + 4);
            v83 = v110;
            *(_DWORD *)(v10 + 520) = v82;
            if ( (*v83 & 0x40) != 0 && (v82 & 0xFFFFF716) != 0 )
            {
              dl_debug_printf((_BYTE *)v132 - 169576, v82 & 0xFFFFF716);
              v82 = *(_DWORD *)(v10 + 520);
            }
            if ( (v82 & 1) != 0 )
              *(_DWORD *)(v10 + 128) = *(_DWORD *)(v10 + 188);
          }
          else
          {
            v82 = *(_DWORD *)(v10 + 520);
          }
          if ( *(_DWORD *)(v10 + 148) )
            *(_DWORD *)(v10 + 92) = 0;
LABEL_141:
          if ( (v82 & 0x40) == 0 || a7 >= 0 )
          {
            v84 = *(_DWORD *)(v10 + 340);
            if ( v84 )
            {
              *(_DWORD *)(v10 + 340) = *(_DWORD *)v10 + v84;
LABEL_145:
              if ( ((unsigned __int8)v117 & (unsigned __int8)~(_BYTE)dl_stack_flags & 1) != 0 )
              {
                *((_DWORD *)v132 - 12) |= 7u;
                stack_executable_hook = (int *)dl_make_stack_executable_hook(a8);
                if ( stack_executable_hook )
                {
                  v43 = (unsigned int *)((char *)v132 - 111184);
                  goto LABEL_83;
                }
              }
              v85 = *(_DWORD *)(v10 + 560);
              if ( v85 )
                *(_DWORD *)(v10 + 560) = *(_DWORD *)v10 + v85;
              if ( !_close_nocancel(v130) )
              {
                if ( v126 == 2 && (*(_BYTE *)(v10 + 408) & 3) != 0 )
                  _assert_fail((int)v132 - 110772, (int)v132 - 112104, 1322, (int)(v132 - 11032));
                v86 = *(_DWORD *)v10;
                v87 = v110;
                v88 = *(_DWORD *)v10 + *(_DWORD *)(v10 + 344);
                *(_DWORD *)(v10 + 344) = v88;
                if ( (*v87 & 0x40) != 0 )
                  dl_debug_printf(
                    (_BYTE *)v132 - 110724,
                    8,
                    *(_DWORD *)(v10 + 8),
                    8,
                    v86,
                    8,
                    v129,
                    8,
                    v88,
                    8,
                    *(_DWORD *)(v10 + 340),
                    8,
                    *(unsigned __int16 *)(v10 + 348));
                dl_setup_hash((_DWORD *)v10);
                if ( (a7 & 8) == 0 )
                {
                  if ( *(_DWORD *)(v10 + 96) )
                  {
                    v100 = *(_BYTE **)(v10 + 464);
                    if ( *(_DWORD *)v100 != v10 + 352 )
                    {
                      **(_DWORD **)(v10 + 360) = v10;
                      v101 = *(_DWORD *)(v10 + 460);
                      *(_DWORD *)(v10 + 364) = 1;
                      memmove(v100 + 4, v100, 4 * v101 - 4);
                      **(_DWORD **)(v10 + 464) = v10 + 360;
                    }
                  }
                }
                if ( (*(_BYTE *)(v10 + 520) & 0x20) != 0 )
                  dl_initfirst = v10;
                *(_DWORD *)(v10 + 476) = st_dev;
                *(_DWORD *)(v10 + 480) = st_dev_high;
                *(_DWORD *)(v10 + 484) = v128;
                *(_DWORD *)(v10 + 488) = v118;
                if ( dl_profile )
                {
                  v99 = *(_DWORD *)(v10 + 88);
                  if ( v99 )
                    add_name_to_object_isra_4(
                      *(_BYTE ***)(v10 + 28),
                      (unsigned int *)(*(_DWORD *)(*(_DWORD *)(v10 + 52) + 4) + *(_DWORD *)(v99 + 4)));
                }
                dl_add_to_namespace_list((_DWORD *)v10, a9);
                return v10;
              }
              v43 = (unsigned int *)((char *)v132 - 111849);
            }
            else
            {
              v133 = 32 * *((unsigned __int16 *)v127 + 24);
              v97 = malloc((const struct timespec *)v133);
              if ( v97 )
              {
                v98 = memcpy(v97, v44, v133);
                *(_BYTE *)(v10 + 408) |= 0x80u;
                *(_DWORD *)(v10 + 340) = v98;
                goto LABEL_145;
              }
              v43 = (unsigned int *)(v132 - 11134);
            }
LABEL_162:
            stack_executable_hook = (int *)__readgsdword(0xFFFFFFE0);
            goto LABEL_83;
          }
          v102 = *(void **)(v10 + 432);
          v139 = v56;
          v138 = v56;
          munmap(v102, *(_DWORD *)(v10 + 436) - (_DWORD)v102);
          if ( !*(_DWORD *)(*(_DWORD *)(v10 + 28) + 8) )
            free((int)&savedregs, (int *)v10, *(_DWORD *)(v10 + 28));
          v43 = (unsigned int *)(v132 - 11122);
          if ( *(char *)(v10 + 408) < 0 )
            free((int)&savedregs, (int *)v10, *(_DWORD *)(v10 + 340));
LABEL_83:
          if ( v113 )
            goto LABEL_84;
          goto LABEL_86;
        }
        while ( 1 )
        {
          if ( v65 > 0x22 )
          {
            if ( 1879048191 - v65 > 0xF )
            {
              v78 = (int)(2 * v65) >> 1;
              if ( v78 <= 0xFFFFFFFC )
              {
                if ( 1879047679 - v65 <= 0xB )
                {
                  *(_DWORD *)(v66 - 4 * v65 - 1073743660) = v64;
                }
                else if ( 1879047935 - v65 <= 0xA )
                {
                  *(_DWORD *)(v66 - 4 * v65 - 1073742588) = v64;
                }
              }
              else
              {
                *(int *)((char *)&dword_80CE0CC[~v78 - 33765376] + v66) = (int)v64;
              }
              goto LABEL_117;
            }
            v65 = 1879048226 - v65;
          }
          *(_DWORD *)(v66 + 4 * v65) = v64;
LABEL_117:
          v64 += 2;
          v65 = *v64;
          if ( !*v64 )
            goto LABEL_92;
        }
      }
    }
    else if ( v126 == 3 )
    {
      v43 = (unsigned int *)((char *)v132 - 111256);
      goto LABEL_83;
    }
    v82 = *(_DWORD *)(v10 + 520);
    goto LABEL_141;
  }
  while ( (*(_BYTE *)(v10 + 409) & 0x20) != 0
       || __PAIR64__(st_dev_high, st_dev) != *(_QWORD *)(v10 + 476)
       || *(_QWORD *)(v10 + 484) != __PAIR64__(v118, v128) )
  {
    v10 = *(_DWORD *)(v10 + 12);
    if ( !v10 )
      goto LABEL_10;
  }
  _close_nocancel(v130);
  free((int)&savedregs, (int *)v10, (int)a4);
  add_name_to_object_isra_4(*(_BYTE ***)(v10 + 28), v123);
  return v10;
}
// 80CE000: using guessed type _TBYTE GLOBAL_OFFSET_TABLE_;
// 80CE0CC: using guessed type int dword_80CE0CC[7];
// 80CE9A0: using guessed type int dl_stack_flags;
// 80CE9B0: using guessed type int dl_pagesize;
// 80CEA00: using guessed type void *dl_ns;
// 80CECD0: using guessed type int (__cdecl *dl_make_stack_executable_hook)(_DWORD);
// 80CFEC0: using guessed type _DWORD *dl_tls_dtv_slotinfo_list;
// 80CFF04: using guessed type _BYTE dl_debug_mask[4];
// 80CFF0C: using guessed type char *dl_profile;
// 80CFF58: using guessed type int dl_initfirst;

//----- (0808A7E0) --------------------------------------------------------
unsigned int __usercall add_path_isra_3_constprop_9@<eax>(unsigned int result@<eax>, int *a2@<edx>)
{
  int *v2; // edi
  unsigned int v3; // esi
  int v4; // edx
  _DWORD *v5; // ecx
  int v6; // ebp
  int v7; // ebx
  _DWORD *v8; // ebp
  _BYTE *v9; // ebx

  if ( a2 != (int *)-1 )
  {
    v2 = a2;
    v3 = result;
    v4 = *a2;
    do
    {
      while ( 1 )
      {
        ++v2;
        v5 = *(_DWORD **)(v3 + 8);
        result = *(_DWORD *)(v4 + 16);
        if ( *(_BYTE *)v3 )
          break;
        v6 = *(_DWORD *)(v3 + 4);
        v7 = v6 + 1;
        v8 = &v5[2 * v6];
        *(_DWORD *)(v3 + 4) = v7;
        v9 = *(_BYTE **)(v3 + 12);
        v8[2] = v9;
        if ( result > 1 )
        {
          result = (unsigned int)mempcpy(v9, *(_BYTE **)(v4 + 12), result - 1);
        }
        else
        {
          *(_DWORD *)(v3 + 12) = v9 + 1;
          *v9 = (result != 0) + 46;
          result = *(_DWORD *)(v3 + 12);
        }
        *(_DWORD *)(v3 + 12) = result + 1;
        *(_BYTE *)result = 0;
        v4 = *v2;
        v8[3] = 0;
        if ( !v4 )
          return result;
      }
      v4 = *v2;
      ++v5[1];
      if ( result < 2 )
        result = 2;
      *v5 += result;
    }
    while ( v4 );
  }
  return result;
}

//----- (0808A8A0) --------------------------------------------------------
int __cdecl dl_dst_count(_BYTE *a1)
{
  int v1; // ebx
  unsigned __int8 *i; // eax
  unsigned __int8 *v4; // ebp
  int v5; // eax

  v1 = 0;
  for ( i = (unsigned __int8 *)strchr(a1, 36); i; i = (unsigned __int8 *)strchr(v4, 36) )
  {
    v4 = i + 1;
    v5 = is_dst(i + 1, (unsigned int *)"ORIGIN");
    if ( !v5 )
    {
      v5 = is_dst(v4, (unsigned int *)"PLATFORM");
      if ( !v5 )
      {
        v5 = is_dst(v4, (unsigned int *)"LIB");
        if ( !v5 )
          continue;
      }
    }
    ++v1;
    v4 += v5;
  }
  return v1;
}

//----- (0808A940) --------------------------------------------------------
char *__cdecl dl_dst_substitute(int a1, unsigned __int8 *a2, char *a3)
{
  bool v3; // bp
  char *v4; // edi
  unsigned __int8 *v5; // esi
  unsigned __int8 v6; // al
  int v7; // edx
  const char *v8; // eax
  unsigned __int8 v10; // al
  char *v11; // [esp+0h] [ebp-28h]
  int v12; // [esp+0h] [ebp-28h]

  v3 = 0;
  v4 = a3;
  v5 = a2;
  v6 = *a2;
  do
  {
    while ( 1 )
    {
      ++v5;
      if ( v6 != 36 )
      {
        *v4++ = v6;
        goto LABEL_3;
      }
      v7 = is_dst(v5, (unsigned int *)"ORIGIN");
      if ( v7 )
        break;
      v7 = is_dst(v5, (unsigned int *)"PLATFORM");
      if ( v7 )
      {
        v8 = dl_platform;
        v11 = dl_platform - 1;
        goto LABEL_8;
      }
      v7 = is_dst(v5, (unsigned int *)"LIB");
      if ( v7 )
      {
        v8 = "lib";
        v11 = &aLib_0[-1];
        goto LABEL_8;
      }
      *v4++ = 36;
LABEL_3:
      v6 = *v5;
      if ( !*v5 )
        goto LABEL_10;
    }
    if ( _libc_enable_secure )
    {
      if ( v5 != a2 + 1 )
        goto LABEL_19;
      v10 = v5[v7];
      if ( v10 )
      {
        if ( v10 != 47 )
          goto LABEL_19;
      }
      v8 = *(const char **)(a1 + 428);
      v11 = (char *)(v8 - 1);
      v3 = (*(_BYTE *)(a1 + 408) & 3) == 0;
    }
    else
    {
      v3 = 0;
      v8 = *(const char **)(a1 + 428);
      v11 = (char *)(v8 - 1);
    }
LABEL_8:
    if ( (unsigned int)v11 > 0xFFFFFFFD )
      goto LABEL_19;
    v12 = v7;
    v4 = stpcpy((int)v4, (int)v8);
    v5 += v12;
    v6 = *v5;
  }
  while ( *v5 );
LABEL_10:
  if ( !v3 || is_trusted_path_normalize(a3, v4 - a3) )
  {
    *v4 = 0;
    return a3;
  }
LABEL_19:
  *a3 = 0;
  return a3;
}
// 80CDDAC: using guessed type int _libc_enable_secure;
// 80CFF18: using guessed type char *dl_platform;

//----- (0808AAD0) --------------------------------------------------------
char *__usercall expand_dynamic_string_token@<eax>(int a1@<eax>, unsigned int *a2@<edx>)
{
  int v4; // eax
  char *result; // eax
  int v6; // edi
  int v7; // edx
  unsigned int *origin; // eax
  unsigned int v9; // eax
  int v10; // [esp+0h] [ebp-24h]
  int v11; // [esp+4h] [ebp-20h]
  int v12; // [esp+4h] [ebp-20h]

  v4 = dl_dst_count(a2);
  if ( !v4 )
    return (char *)strdup(a2);
  v6 = v4;
  v7 = strlen(a2);
  v10 = v7;
  origin = *(unsigned int **)(a1 + 428);
  if ( !origin )
  {
    if ( **(_BYTE **)(a1 + 4) )
      _assert_fail(
        (int)"(l)->l_name[0] == '\\0' || IS_RTLD (l)",
        (int)"dl-load.c",
        395,
        (int)"expand_dynamic_string_token");
    v12 = v7;
    origin = (unsigned int *)dl_get_origin();
    v7 = v12;
    *(_DWORD *)(a1 + 428) = origin;
    if ( (unsigned int)origin - 1 <= 0xFFFFFFFD )
      goto LABEL_6;
LABEL_15:
    v9 = 0;
    goto LABEL_7;
  }
  if ( origin == (unsigned int *)-1 )
    goto LABEL_15;
LABEL_6:
  v11 = v7;
  v9 = strlen(origin);
  v7 = v11;
LABEL_7:
  if ( dl_platformlen >= v9 )
    v9 = dl_platformlen;
  if ( v9 > 4 )
    v10 = v7 + (v9 - 4) * v6;
  result = (char *)malloc((const struct timespec *)(v10 + 1));
  if ( result )
    return dl_dst_substitute(a1, (unsigned __int8 *)a2, result);
  return result;
}

//----- (0808ABF0) --------------------------------------------------------
_DWORD *__usercall fillin_rpath@<eax>(
        int a1@<eax>,
        _DWORD *a2@<edx>,
        _BYTE *a3@<ecx>,
        int ebp0@<ebp>,
        int a5,
        unsigned int *a6,
        int a7)
{
  unsigned int *v7; // eax
  int *v8; // edi
  unsigned int *v9; // eax
  int v10; // eax
  int v11; // edx
  unsigned int v12; // esi
  int v13; // eax
  int v14; // eax
  int *v15; // eax
  int *v16; // ecx
  _WORD *v17; // eax
  bool v18; // cf
  int v19; // eax
  int v20; // ecx
  _DWORD *result; // eax
  int v22; // [esp+0h] [ebp-4Ch]
  int v24; // [esp+Ch] [ebp-40h]
  int v25; // [esp+14h] [ebp-38h]
  unsigned int v27; // [esp+1Ch] [ebp-30h]
  int v28; // [esp+28h] [ebp-24h]
  int v29[8]; // [esp+2Ch] [ebp-20h] BYREF

  v29[0] = a1;
  v24 = 0;
  while ( 1 )
  {
    v7 = (unsigned int *)strsep(v29, a3);
    v8 = (int *)v7;
    if ( !v7 )
      break;
    if ( *(_BYTE *)v7 )
    {
      v9 = (unsigned int *)expand_dynamic_string_token(a7, v7);
      v8 = (int *)v9;
      if ( v9 )
      {
        v10 = strlen(v9);
        if ( v10 )
        {
          if ( v10 != 1 )
          {
            v11 = v10 - 1;
            if ( *((_BYTE *)v8 + v10 - 1) != 47 )
            {
              v11 = v10;
              goto LABEL_38;
            }
            while ( v11 != 1 )
            {
              if ( *((_BYTE *)v8 + v11 - 1) != 47 )
                goto LABEL_38;
              --v11;
            }
          }
          if ( *(_BYTE *)v8 == 47 )
          {
            v22 = (int)v8;
            v12 = 1;
          }
          else
          {
            v11 = 1;
LABEL_38:
            v12 = v11 + 1;
            *((_BYTE *)v8 + v11) = 47;
            v22 = (int)v8;
          }
          v13 = dl_all_dirs;
          v25 = dl_all_dirs;
          if ( !dl_all_dirs )
            goto LABEL_27;
          goto LABEL_15;
        }
        free(ebp0, v8, (int)v8);
      }
    }
    else
    {
      v12 = 0;
      v22 = 0;
      v13 = dl_all_dirs;
      v25 = dl_all_dirs;
      if ( !dl_all_dirs )
      {
LABEL_27:
        if ( a6 )
          v27 = strlen(a6) + 1;
        else
          v27 = 0;
        v28 = 4 * ncapstr + 21;
        v15 = malloc((const struct timespec *)(v27 + v12 + v28));
        ebp0 = (int)v15;
        if ( !v15 )
          dl_signal_error(12, 0, 0, (unsigned int *)"cannot create cache for search path");
        v16 = &v15[ncapstr + 5];
        v15[3] = (int)v16;
        v17 = mempcpy(v16, v8, v12);
        v18 = max_dirnamelen < v12;
        *(_BYTE *)v17 = 0;
        *(_DWORD *)(ebp0 + 16) = v12;
        if ( v18 )
          max_dirnamelen = v12;
        v19 = 0;
        v20 = 2 * (*(_BYTE *)v8 != 47);
        if ( ncapstr )
        {
          do
            *(_DWORD *)(ebp0 + 4 * v19++ + 20) = v20;
          while ( ncapstr != v19 );
        }
        *(_DWORD *)(ebp0 + 4) = a5;
        if ( a6 )
          *(_DWORD *)(ebp0 + 8) = memcpy((_BYTE *)(ebp0 + v28 + v12), a6, v27);
        else
          *(_DWORD *)(ebp0 + 8) = 0;
        *(_DWORD *)ebp0 = v25;
        dl_all_dirs = ebp0;
LABEL_24:
        a2[v24++] = ebp0;
        goto LABEL_25;
      }
LABEL_15:
      ebp0 = v13;
      while ( 1 )
      {
        if ( *(_DWORD *)(ebp0 + 16) == v12 )
        {
          v14 = memcmp((unsigned int *)v8, *(unsigned int **)(ebp0 + 12), v12);
          if ( !v14 )
            break;
        }
        ebp0 = *(_DWORD *)ebp0;
        if ( !ebp0 )
          goto LABEL_27;
      }
      if ( !v24 )
        goto LABEL_24;
      if ( ebp0 != *a2 )
      {
        while ( v24 != ++v14 )
        {
          if ( a2[v14] == ebp0 )
            goto LABEL_25;
        }
        goto LABEL_24;
      }
LABEL_25:
      free(ebp0, v8, v22);
    }
  }
  result = a2;
  a2[v24] = 0;
  return result;
}
// 80CDFC0: using guessed type int ncapstr;
// 80CFA44: using guessed type int max_dirnamelen;
// 808ABF0: using guessed type int var_20[8];

//----- (0808AED0) --------------------------------------------------------
int __usercall cache_rpath_part_6@<eax>(int a1@<eax>, _DWORD *a2@<edx>, int a3@<ecx>, int a4)
{
  int result; // eax
  char *v6; // ecx
  unsigned int *v7; // eax
  _DWORD *v8; // esi
  int *v9; // eax
  int *v10; // edi
  char v11; // al
  int *v12; // edx
  int v13; // ecx
  int v14; // eax
  int *v15; // eax
  int *v16; // ebp
  _DWORD *v17; // ebp
  char v18; // al
  char v19; // dl
  char *v20; // esi
  char v21; // al
  char *v22; // eax
  unsigned int *v23; // [esp+10h] [ebp-2Ch]
  unsigned int *v24; // [esp+14h] [ebp-28h]
  int v25; // [esp+14h] [ebp-28h]

  result = *(_DWORD *)(a1 + 4 * a3 + 32);
  if ( !result )
  {
    *a2 = -1;
    return result;
  }
  v24 = (unsigned int *)(*(_DWORD *)(*(_DWORD *)(a1 + 52) + 4) + *(_DWORD *)(result + 4));
  v23 = *(unsigned int **)(a1 + 4);
  v6 = dl_inhibit_rpath;
  if ( dl_inhibit_rpath && !_libc_enable_secure )
  {
    v17 = a2;
    v18 = *dl_inhibit_rpath;
    while ( 1 )
    {
      v19 = *(_BYTE *)v23;
      if ( *(_BYTE *)v23 == v18 )
      {
        if ( !*(_BYTE *)v23 )
          break;
        v20 = *(char **)(a1 + 4);
        while ( 1 )
        {
          ++v6;
          ++v20;
          v18 = *v6;
          v19 = *v20;
          if ( *v6 != *v20 )
            break;
          if ( !v18 )
            goto LABEL_28;
        }
      }
      if ( v19 )
        goto LABEL_24;
LABEL_28:
      if ( !v18 || v18 == 58 )
        break;
      do
      {
LABEL_24:
        v21 = *v6;
        if ( !*v6 )
          goto LABEL_25;
        ++v6;
      }
      while ( v21 != 58 );
      v18 = *v6;
      if ( !*v6 )
      {
LABEL_25:
        a2 = v17;
        goto LABEL_3;
      }
    }
    a2 = v17;
    goto LABEL_4;
  }
LABEL_3:
  v7 = v24;
  if ( !*(_BYTE *)v24 )
  {
LABEL_4:
    *a2 = -1;
    return 0;
  }
  v25 = a1;
  v8 = a2;
  v9 = strdup(v7);
  v10 = v9;
  if ( !v9 )
  {
    v22 = "cannot create RUNPATH/RPATH copy";
LABEL_34:
    dl_signal_error(12, 0, 0, (unsigned int *)v22);
  }
  v11 = *(_BYTE *)v9;
  if ( v11 )
  {
    v12 = v10;
    v13 = 0;
    do
    {
      v12 = (int *)((char *)v12 + 1);
      v13 += v11 == 58;
      v11 = *(_BYTE *)v12;
    }
    while ( *(_BYTE *)v12 );
    v14 = 4 * v13 + 8;
  }
  else
  {
    v14 = 8;
  }
  v15 = malloc((const struct timespec *)v14);
  v16 = v15;
  if ( !v15 )
  {
    free(0, v10, (int)v10);
    v22 = "cannot create cache for search path";
    goto LABEL_34;
  }
  fillin_rpath((int)v10, v15, ":", (int)v15, a4, v23, v25);
  free((int)v16, v10, (int)v10);
  if ( *v16 )
  {
    *v8 = v16;
    result = 1;
    v8[1] = 1;
  }
  else
  {
    free((int)v16, v10, (int)v16);
    *v8 = -1;
    return 0;
  }
  return result;
}
// 80CDDAC: using guessed type int _libc_enable_secure;
// 80CFF64: using guessed type _BYTE *dl_inhibit_rpath;

//----- (0808B0F0) --------------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
int *__cdecl dl_init_paths(unsigned int *a1)
{
  int *v1; // eax
  _DWORD *v2; // edi
  int *v3; // eax
  unsigned int v4; // ecx
  int v5; // edx
  int *v6; // edx
  int *result; // eax
  unsigned int v8; // edi
  int v9; // ecx
  int v10; // eax
  int v11; // edi
  int v12; // ecx
  _BYTE *v13; // esi
  char v14; // al
  _BYTE *v15; // edx
  int v16; // ecx
  int v17; // eax
  int v18; // ecx
  int *v19; // eax
  unsigned int v20; // edi
  void *v21; // esp
  char *v22; // eax
  _BYTE v23[4]; // [esp-10h] [ebp-2Ch]
  _BYTE v24[12]; // [esp-Ch] [ebp-28h] BYREF
  unsigned int v25; // [esp+0h] [ebp-1Ch]
  int savedregs; // [esp+1Ch] [ebp+0h] BYREF

  capstr = dl_important_hwcaps((int)dl_platform, dl_platformlen, &ncapstr, &max_capstrlen);
  v1 = malloc((const struct timespec *)0xC);
  rtld_search_dirs = (int)v1;
  if ( !v1 )
  {
    v22 = "cannot create search path array";
LABEL_28:
    dl_signal_error(12, 0, 0, (unsigned int *)v22);
  }
  v2 = v1;
  v25 = 5 * ((4 * ncapstr + 39) / 0x14u);
  v3 = malloc((const struct timespec *)(40 * ((4 * ncapstr + 39) / 0x14u)));
  *v2 = v3;
  if ( !v3 )
    goto LABEL_27;
  v3[2] = 0;
  dword_80CDFB8 = 0;
  dl_all_dirs = v3;
  v25 = (unsigned int)"system search path";
  v3[1] = (int)"system search path";
  v3[3] = (int)"/lib/";
  v4 = 5 * ((4 * ncapstr + 39) / 0x14u);
  v3[4] = 5;
  if ( ncapstr )
  {
    v5 = 0;
    do
      v3[v5++ + 5] = 0;
    while ( ncapstr != v5 );
    v6 = &v3[v4];
    *v3 = (int)&v3[v4];
    result = v2 + 2;
    v2[1] = v6;
    v8 = v25;
    v6[2] = 0;
    v6[1] = v8;
    v6[4] = 9;
    v6[3] = (int)"/usr/lib/";
    v9 = 0;
    do
      v6[v9++ + 5] = 0;
    while ( ncapstr != v9 );
  }
  else
  {
    v6 = &v3[v4];
    *v3 = (int)&v3[v4];
    result = v2 + 2;
    v2[1] = v6;
    v20 = v25;
    v6[2] = 0;
    v6[1] = v20;
    v6[3] = (int)"/usr/lib/";
    v6[4] = 9;
  }
  *v6 = 0;
  max_dirnamelen = 9;
  *result = 0;
  if ( !a1 || (result = (int *)a1, !*(_BYTE *)a1) )
  {
    env_path_list = -1;
    return result;
  }
  v10 = strlen(a1);
  v11 = (int)&v24[-((v10 + 28) & 0xFFFFF000)];
  while ( v24 != (_BYTE *)v11 )
    ;
  v12 = ((_WORD)v10 + 28) & 0xFF0;
  if ( (((_WORD)v10 + 28) & 0xFF0) != 0 )
  {
    v21 = alloca(v12);
    *(_DWORD *)&v23[v12] = *(_DWORD *)&v23[v12];
  }
  v13 = memcpy(v24, a1, v10 + 1);
  v14 = *v13;
  if ( *v13 )
  {
    v15 = v13;
    v11 = 1;
    do
    {
      v16 = v11 + 1;
      if ( (unsigned __int8)(v14 - 58) <= 1u )
      {
        v17 = v11 + 2;
        ++v11;
        v16 = v17;
      }
      v14 = *++v15;
    }
    while ( *v15 );
    v18 = 4 * v16;
  }
  else
  {
    v18 = 8;
  }
  v19 = malloc((const struct timespec *)v18);
  env_path_list = (int)v19;
  if ( !v19 )
  {
LABEL_27:
    v22 = "cannot create cache for search path";
    goto LABEL_28;
  }
  fillin_rpath((int)v13, v19, ":;", (int)&savedregs, (int)"LD_LIBRARY_PATH", 0, 0);
  result = (int *)env_path_list;
  if ( !*(_DWORD *)env_path_list )
  {
    result = free((int)&savedregs, (int *)v11, env_path_list);
    env_path_list = -1;
  }
  dword_80CDFCC = 0;
  return result;
}
// 808B132: write access to const memory at 80CDFC4 has been detected
// 808B140: write access to const memory at 80CDFB4 has been detected
// 808B24C: write access to const memory at 80CDFC8 has been detected
// 808B334: write access to const memory at 80CDFCC has been detected
// 808B38B: write access to const memory at 80CDFC8 has been detected
// 808B2FA: write access to const memory at 80CDFC8 has been detected
// 808B19A: write access to const memory at 80CDFB8 has been detected
// 80CDFB4: using guessed type int rtld_search_dirs;
// 80CDFB8: using guessed type int dword_80CDFB8;
// 80CDFBC: using guessed type int max_capstrlen;
// 80CDFC0: using guessed type int ncapstr;
// 80CDFC4: using guessed type int capstr;
// 80CDFC8: using guessed type int env_path_list;
// 80CDFCC: using guessed type int dword_80CDFCC;
// 80CFA44: using guessed type int max_dirnamelen;
// 80CFF18: using guessed type char *dl_platform;

//----- (0808B3C0) --------------------------------------------------------
unsigned __int8 *__usercall dl_map_object@<eax>(
        unsigned int *edi0@<edi>,
        int a2,
        char *a3,
        char a4,
        int a5,
        int a6,
        int a7)
{
  unsigned __int8 *v7; // ebx
  int v8; // eax
  char v10; // bl
  unsigned int *v11; // eax
  int v12; // eax
  int v13; // edx
  int v14; // eax
  int *v15; // eax
  int *v16; // edi
  int v17; // eax
  int v18; // edx
  int *cache_lookup; // edi
  char (*v20)[1671]; // edx
  _TBYTE *v21; // eax
  int v22; // edx
  int v23; // ebx
  char v24; // di
  int v25; // eax
  char v26; // al
  int v27; // eax
  int v28; // eax
  int v29; // [esp+25Ch] [ebp-248h]
  int v30; // [esp+260h] [ebp-244h]
  unsigned int v31; // [esp+264h] [ebp-240h]
  _DWORD *v32; // [esp+26Ch] [ebp-238h]
  char v33; // [esp+27Bh] [ebp-229h] BYREF
  unsigned int *v34; // [esp+27Ch] [ebp-228h] BYREF
  int v35; // [esp+280h] [ebp-224h] BYREF
  int v36[136]; // [esp+284h] [ebp-220h] BYREF
  unsigned __int8 *v37; // [esp+4A8h] [ebp+4h]

  v36[134] = (int)edi0;
  if ( a7 < 0 )
    _assert_fail(
      (int)&GLOBAL_OFFSET_TABLE_ - 111672,
      (int)&GLOBAL_OFFSET_TABLE_ - 112104,
      1943,
      (int)&GLOBAL_OFFSET_TABLE_ - 110276);
  if ( a7 >= (unsigned int)dl_nns )
    _assert_fail(
      (int)&GLOBAL_OFFSET_TABLE_ - 111662,
      (int)&GLOBAL_OFFSET_TABLE_ - 112104,
      1944,
      (int)&GLOBAL_OFFSET_TABLE_ - 110276);
  v7 = (unsigned __int8 *)*(&dl_ns + 19 * a7);
  if ( v7 )
  {
    while ( 1 )
    {
      if ( (v7[409] & 2) == 0 && (v7[409] & 0x20) == 0 )
      {
        if ( dl_name_match_p(a3, (int)v7) )
          return v7;
        if ( (v7[409] & 1) == 0 )
        {
          v8 = *((_DWORD *)v7 + 22);
          if ( v8 )
          {
            edi0 = (unsigned int *)(*(_DWORD *)(*((_DWORD *)v7 + 13) + 4) + *(_DWORD *)(v8 + 4));
            if ( !strcmp(a3, edi0) )
              break;
          }
        }
      }
      v7 = (unsigned __int8 *)*((_DWORD *)v7 + 3);
      if ( !v7 )
        goto LABEL_13;
    }
    add_name_to_object_isra_4(*((_BYTE ***)v7 + 7), edi0);
    v7[409] |= 1u;
    return v7;
  }
LABEL_13:
  v10 = dl_debug_mask[0];
  v30 = a6 & 0x10000000;
  if ( (dl_debug_mask[0] & 0x40) != 0 )
  {
    if ( a2 )
    {
      v20 = *(char (**)[1671])(a2 + 4);
      if ( !*(_BYTE *)v20 )
      {
        v20 = program_invocation_short_name[0];
        if ( !program_invocation_short_name[0] )
          v20 = (char (*)[1671])((char *)&GLOBAL_OFFSET_TABLE_ - 111925);
      }
      v21 = &GLOBAL_OFFSET_TABLE_ - 11048;
      if ( v30 )
        v21 = &GLOBAL_OFFSET_TABLE_ - 11044;
      dl_debug_printf(v21, a3, a7, v20, *(_DWORD *)(a2 + 24));
      v33 = 0;
      if ( strchr(a3, 47) )
      {
LABEL_16:
        v11 = (unsigned int *)expand_dynamic_string_token(a2, (unsigned int *)a3);
        v34 = v11;
        if ( v11 )
          goto LABEL_17;
LABEL_23:
        v14 = 0;
        if ( !v30 )
          v14 = a2;
        v37 = (unsigned __int8 *)v14;
LABEL_26:
        if ( !a5 || (dl_debug_mask[1] & 8) != 0 )
        {
          if ( v33 )
            dl_signal_error(0, (unsigned int *)a3, 0, (unsigned int *)(&GLOBAL_OFFSET_TABLE_ - 11163));
          dl_signal_error(
            __readgsdword(0xFFFFFFE0),
            (unsigned int *)a3,
            0,
            (unsigned int *)&GLOBAL_OFFSET_TABLE_ - 27588);
        }
        v15 = strdup((unsigned int *)a3);
        v16 = v15;
        if ( !v15 || (v7 = dl_new_object(v15, (unsigned int *)v15, (unsigned int *)a3, a4, v37, a6, a7)) == 0 )
        {
          free((int)&GLOBAL_OFFSET_TABLE_, v16, (int)v16);
          dl_signal_error(12, (unsigned int *)a3, 0, (unsigned int *)&GLOBAL_OFFSET_TABLE_ - 27824);
        }
        *((_WORD *)v7 + 204) |= 0x204u;
        *((_DWORD *)v7 + 100) = (char *)&GLOBAL_OFFSET_TABLE_ - 110172;
        *((_DWORD *)v7 + 95) = 1;
        dl_add_to_namespace_list(v7, a7);
        return v7;
      }
      v31 = strlen((unsigned int *)a3) + 1;
      if ( (dl_debug_mask[0] & 1) == 0 )
        goto LABEL_33;
    }
    else
    {
      v33 = 0;
      if ( strchr(a3, 47) )
        goto LABEL_22;
      v31 = strlen((unsigned int *)a3) + 1;
      if ( (v10 & 1) == 0 )
        goto LABEL_103;
    }
LABEL_64:
    dl_debug_printf((_BYTE *)&GLOBAL_OFFSET_TABLE_ - 110388, a3, a7);
LABEL_32:
    if ( a2 )
    {
LABEL_33:
      if ( *(_DWORD *)(a2 + 148) )
      {
        if ( *((_DWORD *)&GLOBAL_OFFSET_TABLE_ - 14) == -1 )
          goto LABEL_36;
        goto LABEL_35;
      }
      v23 = a2;
      v24 = 0;
      v32 = dl_ns;
      do
      {
        v25 = *(_DWORD *)(v23 + 412);
        if ( v25 != -1
          && (v25
           || (unsigned __int8)cache_rpath_part_6(v23, (_DWORD *)(v23 + 412), 15, (int)&GLOBAL_OFFSET_TABLE_ - 111644)) )
        {
          v12 = open_path(a3, v31, (const char *)a6, (int *)(v23 + 412), &v34, v36, a2, 4, &v33);
          if ( v12 != -1 )
            goto LABEL_40;
          v24 |= v23 == (_DWORD)v32;
        }
        v23 = *(_DWORD *)(v23 + 368);
      }
      while ( v23 );
      v26 = v24 ^ 1;
LABEL_84:
      if ( v32 )
      {
        if ( v26 )
        {
          if ( (v32[102] & 3) != 2 )
          {
            v27 = v32[103];
            if ( v27 != -1
              && (v27
               || (unsigned __int8)cache_rpath_part_6((int)v32, v32 + 103, 15, (int)&GLOBAL_OFFSET_TABLE_ - 111644)) )
            {
              v28 = (int)v32;
              if ( a2 )
                v28 = a2;
              v12 = open_path(a3, v31, (const char *)a6, v32 + 103, &v34, v36, v28, 4, &v33);
              if ( v12 != -1 )
              {
LABEL_40:
                if ( (dl_debug_mask[0] & 1) != 0 )
                {
                  v29 = v12;
                  dl_debug_printf((_BYTE *)&GLOBAL_OFFSET_TABLE_ - 179546);
                  v12 = v29;
                }
                v18 = 0;
                if ( !v30 )
                  v18 = a2;
                v37 = (unsigned __int8 *)v18;
                if ( v12 != -1 )
                  goto LABEL_21;
                goto LABEL_26;
              }
            }
          }
        }
      }
      if ( *((_DWORD *)&GLOBAL_OFFSET_TABLE_ - 14) == -1 )
      {
        if ( !a2 )
          goto LABEL_49;
        goto LABEL_36;
      }
      if ( !a2 )
      {
        v12 = open_path(a3, v31, (const char *)a6, (int *)&GLOBAL_OFFSET_TABLE_ - 14, &v34, v36, (int)dl_ns, 2, &v33);
        goto LABEL_39;
      }
LABEL_35:
      v12 = open_path(a3, v31, (const char *)a6, (int *)&GLOBAL_OFFSET_TABLE_ - 14, &v34, v36, a2, 2, &v33);
      if ( v12 == -1 )
      {
LABEL_36:
        v17 = *(_DWORD *)(a2 + 492);
        if ( v17 == -1
          || !v17
          && !(unsigned __int8)cache_rpath_part_6(a2, (_DWORD *)(a2 + 492), 29, (int)&GLOBAL_OFFSET_TABLE_ - 111638) )
        {
          goto LABEL_49;
        }
        v12 = open_path(a3, v31, (const char *)a6, (int *)(a2 + 492), &v34, v36, a2, 4, &v33);
      }
LABEL_39:
      if ( v12 != -1 )
        goto LABEL_40;
LABEL_49:
      v34 = 0;
      if ( (a6 & 0x4000000) != 0 && _libc_enable_secure
        || dl_inhibit_cache
        || (cache_lookup = dl_load_cache_lookup(a3)) == 0 )
      {
LABEL_71:
        v22 = a2;
        if ( (a2 || (v22 = (int)*(&dl_ns + 19 * a7)) != 0) && (*(_BYTE *)(v22 + 521) & 8) != 0 )
        {
          v12 = -1;
        }
        else
        {
          v12 = -1;
          if ( *((_DWORD *)&GLOBAL_OFFSET_TABLE_ - 19) != -1 )
            v12 = open_path(a3, v31, (const char *)a6, (int *)&GLOBAL_OFFSET_TABLE_ - 19, &v34, v36, v22, 64, &v33);
        }
        goto LABEL_40;
      }
      if ( a2 )
      {
        if ( (*(_BYTE *)(a2 + 521) & 8) == 0 )
          goto LABEL_54;
      }
      else if ( (*((_BYTE *)dl_ns + 521) & 8) == 0 )
      {
        goto LABEL_54;
      }
      if ( *cache_lookup == 1651076143 && *((_BYTE *)cache_lookup + 4) == 47
        || *cache_lookup == 1920169263 && cache_lookup[1] == 1651076143 && *((_BYTE *)cache_lookup + 8) == 47 )
      {
LABEL_70:
        free((int)&GLOBAL_OFFSET_TABLE_, cache_lookup, (int)cache_lookup);
        goto LABEL_71;
      }
LABEL_54:
      v12 = open_verify_constprop_7((unsigned int *)cache_lookup, v36, a6, &v33, 0);
      if ( v12 != -1 )
      {
        v34 = (unsigned int *)cache_lookup;
        goto LABEL_40;
      }
      goto LABEL_70;
    }
LABEL_103:
    v32 = dl_ns;
    v26 = 1;
    goto LABEL_84;
  }
  v33 = 0;
  if ( !strchr(a3, 47) )
  {
    v31 = strlen((unsigned int *)a3) + 1;
    if ( (v10 & 1) == 0 )
      goto LABEL_32;
    goto LABEL_64;
  }
  if ( a2 )
    goto LABEL_16;
LABEL_22:
  v11 = (unsigned int *)strdup((unsigned int *)a3);
  v34 = v11;
  if ( !v11 )
    goto LABEL_23;
LABEL_17:
  v12 = open_verify_constprop_7(v11, v36, a6, &v33, 1);
  if ( v12 == -1 )
  {
    free((int)&GLOBAL_OFFSET_TABLE_, (int *)edi0, (int)v34);
    goto LABEL_23;
  }
  v13 = 0;
  if ( !v30 )
    v13 = a2;
  v37 = (unsigned __int8 *)v13;
LABEL_21:
  v35 = _libc_stack_end;
  return (unsigned __int8 *)dl_map_object_from_fd_constprop_8(
                              (unsigned int *)a3,
                              v12,
                              v36,
                              v34,
                              v37,
                              a4,
                              a6,
                              (int)&v35,
                              a7);
}
// 808B6FA: conditional instruction was optimized away because %arg_0.4!=0
// 80CDDA4: using guessed type char (**dl_argv)[1671];
// 80CDDAC: using guessed type int _libc_enable_secure;
// 80CE000: using guessed type _TBYTE GLOBAL_OFFSET_TABLE_;
// 80CE964: using guessed type char (*program_invocation_short_name[2])[1671];
// 80CE9C0: using guessed type int dl_nns;
// 80CEA00: using guessed type void *dl_ns;
// 80CFF04: using guessed type _BYTE dl_debug_mask[4];
// 808B3C0: using guessed type int var_220[136];

//----- (0808BD00) --------------------------------------------------------
int __cdecl dl_rtld_di_serinfo(int a1, _DWORD *a2, char a3)
{
  _DWORD *v3; // esi
  int v4; // eax
  int v5; // edx
  int result; // eax
  int *v7; // edx
  int v8; // ebx
  int *v9; // edx
  void *v10; // ebx
  int *v11; // edx
  char v12[4]; // [esp+8h] [ebp-2Ch] BYREF
  int v13; // [esp+Ch] [ebp-28h]
  _DWORD *v14; // [esp+10h] [ebp-24h]
  int v15; // [esp+14h] [ebp-20h]

  v3 = a2;
  if ( a3 )
  {
    a2[1] = 0;
    v4 = 8;
    *a2 = 0;
  }
  else
  {
    v4 = 8 * a2[1] + 8;
  }
  v14 = a2;
  v5 = *(_DWORD *)(a1 + 148);
  v13 = 0;
  v12[0] = a3;
  v15 = (int)a2 + v4;
  if ( v5 )
    goto LABEL_4;
  v8 = a1;
  do
  {
    v9 = *(int **)(v8 + 412);
    if ( v9 != (int *)-1 )
    {
      if ( v9 )
        goto LABEL_16;
      if ( (unsigned __int8)cache_rpath_part_6(v8, (_DWORD *)(v8 + 412), 15, (int)"RPATH") )
      {
        v9 = *(int **)(v8 + 412);
LABEL_16:
        add_path_isra_3_constprop_9((unsigned int)v12, v9);
      }
    }
    v8 = *(_DWORD *)(v8 + 368);
  }
  while ( v8 );
  v3 = a2;
  if ( !*(_DWORD *)(a1 + 24) )
  {
    v10 = dl_ns;
    if ( dl_ns )
    {
      if ( (*((_BYTE *)dl_ns + 408) & 3) != 2 && (void *)a1 != dl_ns )
      {
        v11 = (int *)*((_DWORD *)dl_ns + 103);
        if ( v11 != (int *)-1 )
        {
          if ( v11 )
            goto LABEL_28;
          if ( (unsigned __int8)cache_rpath_part_6(
                                  (int)dl_ns,
                                  (_DWORD *)dl_ns + 103,
                                  15,
                                  (int)&GLOBAL_OFFSET_TABLE_ - 111644) )
          {
            v11 = (int *)*((_DWORD *)v10 + 103);
LABEL_28:
            add_path_isra_3_constprop_9((unsigned int)v12, v11);
          }
        }
      }
    }
  }
LABEL_4:
  result = add_path_isra_3_constprop_9((unsigned int)v12, *((int **)&GLOBAL_OFFSET_TABLE_ - 14));
  v7 = *(int **)(a1 + 492);
  if ( v7 != (int *)-1 )
  {
    if ( v7 )
      goto LABEL_6;
    result = cache_rpath_part_6(a1, (_DWORD *)(a1 + 492), 29, (int)&GLOBAL_OFFSET_TABLE_ - 111638);
    if ( (_BYTE)result )
    {
      v7 = *(int **)(a1 + 492);
LABEL_6:
      result = add_path_isra_3_constprop_9((unsigned int)v12, v7);
    }
  }
  if ( (*(_BYTE *)(a1 + 521) & 8) == 0 )
    result = add_path_isra_3_constprop_9((unsigned int)v12, (int *)rtld_search_dirs);
  if ( a3 )
  {
    result = 8 * v3[1] + 8;
    *v3 += result;
  }
  return result;
}
// 80CDFB4: using guessed type int rtld_search_dirs;
// 80CE000: using guessed type _TBYTE GLOBAL_OFFSET_TABLE_;
// 80CEA00: using guessed type void *dl_ns;
// 808BD00: using guessed type char var_2C[4];

//----- (0808BF20) --------------------------------------------------------
int __usercall check_match@<eax>(
        _BYTE *a1@<eax>,
        int a2@<edx>,
        int a3@<ecx>,
        char a4,
        unsigned __int8 a5,
        int a6,
        int a7,
        int a8,
        int a9,
        _DWORD *a10,
        _DWORD *a11)
{
  __int16 v11; // bp
  int v12; // esi
  int v13; // ebp
  int v15; // eax
  __int16 v16; // di
  int v17; // eax
  int v18; // ebp
  char *v21; // eax

  v11 = *(_WORD *)(a6 + 14);
  v12 = *(_BYTE *)(a6 + 12) & 0xF;
  if ( !*(_DWORD *)(a6 + 4) && (_BYTE)v12 != 6 && v11 != -15 )
    return 0;
  if ( ((v11 == 0) & a5) == 0 )
  {
    v13 = 1127;
    if ( _bittest(&v13, v12) )
    {
      if ( a6 == a2 || !strcmp((char *)(*(_DWORD *)a6 + a8), a1) )
      {
        v15 = *(_DWORD *)(a9 + 424);
        if ( a3 )
        {
          if ( !v15 )
          {
            v21 = *(char **)(a3 + 12);
            if ( v21 && dl_name_match_p(v21, a9) )
              _assert_fail(
                (int)"version->filename == NULL || ! _dl_name_match_p (version->filename, map)",
                (int)"dl-lookup.c",
                112,
                (int)"check_match");
            return a6;
          }
          v16 = *(_WORD *)(v15 + 2 * a7);
          v17 = *(_DWORD *)(a9 + 372) + 16 * (v16 & 0x7FFF);
          v18 = *(_DWORD *)(v17 + 4);
          if ( v18 == *(_DWORD *)(a3 + 4) && !strcmp(*(char **)v17, *(_BYTE **)a3)
            || !(*(_DWORD *)(a3 + 8) | v18) && v16 >= 0 )
          {
            return a6;
          }
        }
        else
        {
          if ( !v15 || (*(_WORD *)(v15 + 2 * a7) & 0x7FFF) < ((a4 & 2) == 0) + 2 )
            return a6;
          if ( *(__int16 *)(v15 + 2 * a7) >= 0 && !(*a11)++ )
            *a10 = a6;
        }
      }
    }
  }
  return 0;
}

//----- (0808C0C0) --------------------------------------------------------
int __usercall do_lookup_x@<eax>(
        unsigned __int8 *a1@<eax>,
        unsigned int a2@<edx>,
        unsigned int *a3@<ecx>,
        int a4,
        int *a5,
        int *a6,
        int a7,
        int a8,
        char a9,
        int a10,
        int a11,
        int a12)
{
  int v13; // edi
  int v14; // eax
  int v15; // ecx
  unsigned int v16; // eax
  int v17; // ebp
  const char *v18; // eax
  unsigned int v19; // eax
  int v20; // ebx
  int v21; // eax
  int v22; // ecx
  char v23; // al
  int v25; // eax
  int *v26; // ebx
  int v27; // eax
  int v28; // eax
  int v29; // eax
  int v30; // edx
  unsigned int v31; // ebx
  unsigned int v32; // eax
  unsigned int v33; // ebx
  int v34; // edi
  unsigned int v35; // esi
  unsigned int v36; // eax
  int v37; // edx
  int v38; // eax
  unsigned int v39; // eax
  unsigned int v40; // eax
  int v41; // ebx
  int v42; // esi
  unsigned int v43; // eax
  void **v44; // esi
  unsigned int v45; // ecx
  unsigned int v46; // ebp
  unsigned int v47; // esi
  unsigned int v48; // ecx
  int v49; // edx
  unsigned __int8 *v50; // ebx
  char *v51; // eax
  int v52; // eax
  unsigned int v53; // ecx
  unsigned int v54; // edx
  unsigned int v55; // edi
  int v56; // ebx
  int v57; // edx
  unsigned int *v58; // eax
  unsigned int *v59; // eax
  int v60; // edx
  unsigned __int8 *v61; // eax
  int i; // ecx
  int v63; // edx
  unsigned int v64; // esi
  unsigned __int8 *v65; // eax
  unsigned int v66; // ecx
  unsigned __int8 *v67; // edi
  int v68; // ebx
  unsigned int v69; // ecx
  unsigned __int8 *v70; // eax
  void **v71; // ebx
  unsigned int v72; // [esp+14h] [ebp-68h]
  unsigned int v73; // [esp+14h] [ebp-68h]
  unsigned __int8 *v74; // [esp+14h] [ebp-68h]
  int v75; // [esp+1Ch] [ebp-60h]
  int v76; // [esp+20h] [ebp-5Ch]
  int v77; // [esp+20h] [ebp-5Ch]
  unsigned int v78; // [esp+20h] [ebp-5Ch]
  unsigned __int8 *v79; // [esp+20h] [ebp-5Ch]
  int v81; // [esp+24h] [ebp-58h]
  _DWORD *v82; // [esp+28h] [ebp-54h]
  unsigned int v83; // [esp+2Ch] [ebp-50h]
  int v84; // [esp+2Ch] [ebp-50h]
  int v85; // [esp+2Ch] [ebp-50h]
  unsigned __int8 *v86; // [esp+2Ch] [ebp-50h]
  unsigned int v88; // [esp+34h] [ebp-48h]
  int v89; // [esp+34h] [ebp-48h]
  unsigned int v91; // [esp+40h] [ebp-3Ch]
  int v92; // [esp+40h] [ebp-3Ch]
  int v93; // [esp+44h] [ebp-38h]
  int v94; // [esp+44h] [ebp-38h]
  int v95; // [esp+44h] [ebp-38h]
  int v96; // [esp+48h] [ebp-34h]
  unsigned int v97; // [esp+48h] [ebp-34h]
  unsigned int v98; // [esp+48h] [ebp-34h]
  int v99; // [esp+4Ch] [ebp-30h]
  int v100; // [esp+58h] [ebp-24h] BYREF
  int v101[8]; // [esp+5Ch] [ebp-20h] BYREF
  int v102; // [esp+8Ch] [ebp+10h]

  v72 = a6[1];
  v13 = *a6;
  v88 = a2 >> 5;
  while ( 1 )
  {
    v17 = *(_DWORD *)(*(_DWORD *)(v13 + 4 * a7) + 20);
    if ( v17 == a10 || (a11 & 2) != 0 && (*(_BYTE *)(v17 + 408) & 3) == 0 || (*(_BYTE *)(v17 + 409) & 0x20) != 0 )
      goto LABEL_5;
    if ( (dl_debug_mask[0] & 8) != 0 )
    {
      v18 = *(const char **)(v17 + 4);
      if ( !*v18 )
      {
        v18 = (const char *)program_invocation_short_name[0];
        if ( !program_invocation_short_name[0] )
          v18 = "<main program>";
      }
      dl_debug_printf((_BYTE *)&GLOBAL_OFFSET_TABLE_ - 110000, a1, v18, *(_DWORD *)(v17 + 24));
    }
    v83 = *(_DWORD *)(v17 + 380);
    if ( !v83 )
      goto LABEL_5;
    v14 = *(_DWORD *)(v17 + 56);
    v15 = *(_DWORD *)(v17 + 392);
    v100 = 0;
    v101[0] = 0;
    v76 = *(_DWORD *)(v14 + 4);
    v75 = *(_DWORD *)(*(_DWORD *)(v17 + 52) + 4);
    if ( v15 )
    {
      v16 = *(_DWORD *)(v15 + 4 * (*(_DWORD *)(v17 + 384) & v88));
      if ( ((unsigned __int8)(v16 >> (a2 >> *(_DWORD *)(v17 + 388))) & (unsigned __int8)(v16 >> a2) & 1) != 0 )
      {
        v25 = *(_DWORD *)(*(_DWORD *)(v17 + 396) + 4 * (a2 % v83));
        if ( v25 )
        {
          v26 = (int *)(*(_DWORD *)(v17 + 400) + 4 * v25);
          while ( 1 )
          {
            v27 = *v26;
            if ( !((a2 ^ *v26) >> 1) )
            {
              v28 = check_match(
                      a1,
                      a4,
                      a8,
                      a9,
                      a11,
                      v76 + 16 * (((int)v26 - *(_DWORD *)(v17 + 400)) >> 2),
                      ((int)v26 - *(_DWORD *)(v17 + 400)) >> 2,
                      v75,
                      v17,
                      v101,
                      &v100);
              if ( v28 )
              {
                v22 = v28;
                goto LABEL_22;
              }
              v27 = *v26;
            }
            ++v26;
            if ( (v27 & 1) != 0 )
              goto LABEL_71;
          }
        }
      }
      goto LABEL_5;
    }
    v19 = *a3;
    if ( *a3 == -1 )
    {
      v60 = 0;
      if ( *a1 )
      {
        v60 = *a1;
        if ( a1[1] )
        {
          v60 = a1[1] + 16 * v60;
          if ( a1[2] )
          {
            v60 = a1[2] + 16 * v60;
            if ( a1[3] )
            {
              v60 = a1[3] + 16 * v60;
              if ( a1[4] )
              {
                v61 = a1 + 5;
                v60 = a1[4] + 16 * v60;
                for ( i = a1[5]; *v61; v60 = ((v63 & 0xF0000000) >> 24) ^ v63 & 0xFFFFFFF )
                {
                  ++v61;
                  v63 = i + 16 * v60;
                  i = *v61;
                }
              }
            }
          }
        }
      }
      v19 = v60;
      *a3 = v60;
    }
    v20 = *(_DWORD *)(*(_DWORD *)(v17 + 400) + 4 * (v19 % v83));
    if ( v20 )
    {
      do
      {
        v21 = check_match(a1, a4, a8, a9, a11, v76 + 16 * v20, v20, v75, v17, v101, &v100);
        if ( v21 )
        {
          v22 = v21;
          goto LABEL_22;
        }
        v20 = *(_DWORD *)(*(_DWORD *)(v17 + 396) + 4 * v20);
      }
      while ( v20 );
LABEL_71:
      if ( v100 == 1 )
      {
        v22 = v101[0];
        if ( v101[0] )
          break;
      }
    }
LABEL_5:
    if ( v72 <= ++a7 )
      return 0;
  }
LABEL_22:
  if ( !a12 && (*(_BYTE *)(v17 + 408) & 3) == 0 && a11 == 4 )
  {
    v29 = *(_DWORD *)(v17 + 60);
    if ( v29 )
    {
      v30 = *(_DWORD *)(v17 + 64);
      if ( v30 )
      {
        v31 = *(_DWORD *)(v30 + 4);
        if ( v31 )
        {
          v93 = *(_DWORD *)(v29 + 4);
          v32 = v31 / 0xC;
          if ( v31 > 0xB )
          {
            v96 = v22;
            v33 = 0;
            v84 = v13;
            v34 = v93;
            v102 = a7;
            v35 = v32;
            while ( 1 )
            {
              v36 = *(_DWORD *)(v34 + 4);
              if ( (unsigned int)(unsigned __int8)v36 - 7 > 0x1E
                && (unsigned __int8)v36 == 5
                && !strcmp((char *)(*(_DWORD *)(v76 + 16 * (v36 >> 8)) + v75), a1) )
              {
                break;
              }
              ++v33;
              v34 += 12;
              if ( v35 <= v33 )
              {
                v22 = v96;
                v13 = v84;
                a7 = v102;
                goto LABEL_49;
              }
            }
            v13 = v84;
            goto LABEL_116;
          }
        }
      }
    }
LABEL_49:
    v37 = *(_DWORD *)(v17 + 100);
    if ( v37 )
    {
      v38 = *(_DWORD *)(v17 + 104);
      if ( v38 )
      {
        v39 = *(_DWORD *)(v38 + 4);
        if ( v39 )
        {
          v40 = v39 >> 3;
          v41 = *(_DWORD *)(v37 + 4);
          if ( v40 )
          {
            v85 = v22;
            v102 = a7;
            v42 = v41 + 8 * v40;
            while ( 1 )
            {
              v43 = *(_DWORD *)(v41 + 4);
              if ( (unsigned int)(unsigned __int8)v43 - 7 > 0x1E
                && (unsigned __int8)v43 == 5
                && !strcmp((char *)(*(_DWORD *)(v76 + 16 * (v43 >> 8)) + v75), a1) )
              {
                break;
              }
              v41 += 8;
              if ( v41 == v42 )
              {
                v22 = v85;
                a7 = v102;
                goto LABEL_23;
              }
            }
LABEL_116:
            a7 = v102;
            goto LABEL_5;
          }
        }
      }
    }
  }
LABEL_23:
  if ( (*(_BYTE *)(v22 + 13) & 3u) - 1 <= 1 )
    goto LABEL_5;
  v23 = *(_BYTE *)(v22 + 12) >> 4;
  if ( v23 == 2 )
  {
    if ( !dl_dynamic_weak )
    {
LABEL_27:
      v82 = (_DWORD *)v22;
LABEL_28:
      a5[1] = v17;
      *a5 = (int)v82;
      return 1;
    }
    if ( !*a5 )
    {
      *a5 = v22;
      a5[1] = v17;
    }
    goto LABEL_5;
  }
  if ( v23 != 10 )
  {
    if ( v23 == 1 )
      goto LABEL_27;
    goto LABEL_5;
  }
  v82 = (_DWORD *)v22;
  v89 = *(_DWORD *)(v17 + 24);
  v44 = &dl_ns + 19 * v89;
  v45 = (unsigned int)v44[11];
  v86 = (unsigned __int8 *)v44[10];
  if ( !v86 )
  {
    v65 = calloc((int *)&GLOBAL_OFFSET_TABLE_, 0x10u, 0x1Fu);
    v86 = v65;
    if ( v65 )
    {
      v44[10] = v65;
      v53 = 31;
      v44[11] = (void *)31;
      v44[13] = free;
      v55 = a2 % 0x1F;
      v91 = a2 % 0x1D + 1;
      goto LABEL_75;
    }
LABEL_117:
    dl_dprintf(2, (_BYTE *)&GLOBAL_OFFSET_TABLE_ - 169866, v65, v65);
    exit(127);
  }
  v94 = v17;
  v46 = (unsigned int)v44[11];
  v97 = a2 % v45;
  v47 = a2 % v45;
  v91 = a2 % (v45 - 2) + 1;
  v48 = v91;
  v49 = 16 * v91;
LABEL_64:
  v50 = &v86[16 * v47];
  while ( 1 )
  {
    v51 = (char *)*((_DWORD *)v50 + 1);
    if ( a2 != *(_DWORD *)v50 )
    {
      if ( v51 )
        goto LABEL_66;
      v53 = v46;
      v54 = 3 * v46;
      v17 = v94;
      v55 = v97;
      if ( v54 > 4 * (int)*(&dl_ns + 19 * v89 + 12) )
      {
LABEL_75:
        v56 = *v82 + v75;
        v57 = 16 * v91;
        if ( (a11 & 2) != 0 )
        {
LABEL_76:
          v58 = (unsigned int *)&v86[16 * v55];
          while ( v58[1] )
          {
            v55 += v91;
            v58 = (unsigned int *)((char *)v58 + v57);
            if ( v53 <= v55 )
            {
              v55 -= v53;
              goto LABEL_76;
            }
          }
          v58[1] = v56;
          *v58 = a2;
          v58[2] = a4;
          v58[3] = a12;
        }
        else
        {
LABEL_82:
          v59 = (unsigned int *)&v86[16 * v55];
          while ( v59[1] )
          {
            v55 += v91;
            v59 = (unsigned int *)((char *)v59 + v57);
            if ( v53 <= v55 )
            {
              v55 -= v53;
              goto LABEL_82;
            }
          }
          v59[1] = v56;
          v59[3] = v17;
          *v59 = a2;
          v59[2] = (unsigned int)v82;
          if ( (*(_BYTE *)(v17 + 408) & 3) == 2 )
            *(_DWORD *)(v17 + 520) |= 8u;
        }
        *(&dl_ns + 19 * v89 + 12) = (char *)*(&dl_ns + 19 * v89 + 12) + 1;
        goto LABEL_28;
      }
      v78 = v53;
      v64 = dl_higher_prime_number(v53 + 1);
      v65 = calloc((int *)v97, 0x10u, v64);
      v74 = v65;
      if ( v65 )
      {
        v66 = v78;
        v98 = v64 - 2;
        v67 = v86;
        v79 = &v86[16 * v78];
        if ( v66 )
        {
          v99 = v94;
          do
          {
            v68 = *((_DWORD *)v67 + 1);
            if ( v68 )
            {
              v81 = *((_DWORD *)v67 + 3);
              v92 = *((_DWORD *)v67 + 2);
              v95 = *(_DWORD *)v67;
              v69 = *(_DWORD *)v67 % v64;
LABEL_104:
              v70 = &v74[16 * v69];
              while ( *((_DWORD *)v70 + 1) )
              {
                v69 += *(_DWORD *)v67 % v98 + 1;
                v70 += 16 * (*(_DWORD *)v67 % v98) + 16;
                if ( v64 <= v69 )
                {
                  v69 -= v64;
                  goto LABEL_104;
                }
              }
              *((_DWORD *)v70 + 1) = v68;
              *(_DWORD *)v70 = v95;
              *((_DWORD *)v70 + 2) = v92;
              *((_DWORD *)v70 + 3) = v81;
            }
            v67 += 16;
          }
          while ( v79 != v67 );
          v17 = v99;
        }
        v71 = &dl_ns + 19 * v89;
        ((void (__cdecl *)(unsigned __int8 *))v71[13])(v86);
        v71[11] = (void *)v64;
        v53 = v64;
        v71[10] = v74;
        v71[13] = free;
        v55 = a2 % v64;
        v91 = a2 % v98 + 1;
        v86 = v74;
        goto LABEL_75;
      }
      goto LABEL_117;
    }
    v77 = v49;
    v73 = v48;
    v52 = strcmp(v51, a1);
    v48 = v73;
    v49 = v77;
    if ( !v52 )
      break;
LABEL_66:
    v47 += v48;
    v50 += v49;
    if ( v46 <= v47 )
    {
      v47 -= v46;
      goto LABEL_64;
    }
  }
  if ( (a11 & 2) != 0 )
  {
    a5[1] = v94;
    *a5 = (int)v82;
  }
  else
  {
    *a5 = *((_DWORD *)v50 + 2);
    a5[1] = *((_DWORD *)v50 + 3);
  }
  return 1;
}
// 80CE000: using guessed type _TBYTE GLOBAL_OFFSET_TABLE_;
// 80CE964: using guessed type char (*program_invocation_short_name[2])[1671];
// 80CEA00: using guessed type void *dl_ns;
// 80CFF04: using guessed type _BYTE dl_debug_mask[4];

//----- (0808CA90) --------------------------------------------------------
_DWORD *__cdecl dl_lookup_symbol_x(
        unsigned __int8 *a1,
        _DWORD *a2,
        int *a3,
        int **a4,
        _DWORD *a5,
        int a6,
        int a7,
        int a8)
{
  int v8; // eax
  unsigned __int8 *v9; // edx
  unsigned int v10; // ebx
  int *v11; // eax
  int v12; // edx
  int v13; // ecx
  int **v14; // esi
  _DWORD *v15; // edi
  int v16; // ebp
  int *v18; // ecx
  int **v19; // esi
  int i; // ebx
  int v21; // eax
  int v22; // esi
  char (*v23)[1671]; // ecx
  char *v24; // eax
  char (*v25)[1671]; // edx
  _DWORD *v26; // eax
  _DWORD *v27; // edx
  _DWORD *v28; // eax
  _DWORD *v29; // edx
  int v30; // eax
  _DWORD *j; // eax
  int v32; // edx
  unsigned int v33; // eax
  int v34; // esi
  __int64 v35; // rax
  int v37; // eax
  _DWORD *v38; // edx
  _DWORD *v39; // ecx
  _DWORD *v40; // edx
  _DWORD *v41; // ecx
  unsigned int *v42; // edx
  unsigned int v43; // ecx
  unsigned int v44; // ebx
  unsigned int *v45; // ecx
  const char *v46; // edx
  const char *v47; // eax
  int v48; // esi
  int *v49; // eax
  int *v50; // ecx
  int v51; // eax
  int v52; // [esp+14h] [ebp-58h]
  unsigned int v53; // [esp+18h] [ebp-54h]
  unsigned int v54; // [esp+18h] [ebp-54h]
  unsigned int *v55; // [esp+1Ch] [ebp-50h]
  int v56; // [esp+1Ch] [ebp-50h]
  int *v57; // [esp+20h] [ebp-4Ch]
  __int64 v58; // [esp+24h] [ebp-48h]
  _DWORD *v59; // [esp+2Ch] [ebp-40h]
  unsigned int v60; // [esp+38h] [ebp-34h] BYREF
  int v61; // [esp+3Ch] [ebp-30h] BYREF
  _DWORD *v62; // [esp+40h] [ebp-2Ch]
  int v63; // [esp+44h] [ebp-28h] BYREF
  _DWORD *v64; // [esp+48h] [ebp-24h]

  v8 = *a1;
  if ( (_BYTE)v8 )
  {
    v9 = a1;
    v10 = 5381;
    do
    {
      ++v9;
      v10 = v8 + 33 * v10;
      v8 = *v9;
    }
    while ( (_BYTE)v8 );
  }
  else
  {
    v10 = 5381;
  }
  v60 = -1;
  v61 = 0;
  v62 = 0;
  if ( a5 && (a7 & 0xFFFFFFFA) != 0 )
    _assert_fail(
      (int)(&GLOBAL_OFFSET_TABLE_ - 10996),
      (int)&GLOBAL_OFFSET_TABLE_ - 110168,
      799,
      (int)(&GLOBAL_OFFSET_TABLE_ - 10968));
  v11 = *a4;
  v12 = *a3;
  if ( a8 )
  {
    if ( a8 != *(_DWORD *)*v11 )
    {
      v22 = 0;
      do
        ++v22;
      while ( *(_DWORD *)(*v11 + 4 * v22) != a8 );
      v52 = v22;
      goto LABEL_9;
    }
  }
  else if ( !v11 )
  {
    goto LABEL_33;
  }
  v52 = 0;
LABEL_9:
  v13 = v52;
  v14 = a4;
  while ( !do_lookup_x(a1, v10, &v60, v12, &v61, v11, v13, (int)a5, a7, a8, a6, (int)a2) )
  {
    v11 = *++v14;
    v13 = 0;
    v12 = *a3;
    if ( !*v14 )
      goto LABEL_13;
  }
  v12 = *a3;
LABEL_13:
  if ( v61 )
  {
    if ( v12 && (*(_BYTE *)(v12 + 13) & 3) == 3 )
    {
      if ( a6 == 1 )
      {
        if ( v62 != a2 )
        {
          v61 = v12;
          v62 = a2;
        }
        v15 = a2;
        v16 = 1;
        goto LABEL_18;
      }
      v63 = 0;
      v64 = 0;
      v18 = *a4;
      if ( !*a4 )
        goto LABEL_90;
      v19 = a4;
      v53 = v10;
      for ( i = v52; ; i = 0 )
      {
        if ( (*(_BYTE *)(v12 + 12) & 0xF) != 1 || (v21 = 4, a6 != 4) )
          v21 = 1;
        if ( do_lookup_x(a1, v53, &v60, v12, &v63, v18, i, (int)a5, a7, a8, v21, 0) )
          break;
        v18 = *++v19;
        if ( !*v19 )
          break;
        v12 = *a3;
      }
      if ( v63 && v64 != a2 )
      {
        v61 = *a3;
        v62 = a2;
        v15 = a2;
      }
      else
      {
LABEL_90:
        v15 = v62;
      }
      v16 = 1;
    }
    else
    {
      v15 = v62;
      v16 = 0;
    }
    if ( (v15[102] & 3) != 2 || (a7 & 1) == 0 || a2 == v15 || (v15[130] & 8) != 0 )
    {
LABEL_18:
      if ( !v15[128] )
        v15[128] = 1;
      if ( (*(_WORD *)dl_debug_mask & 0x804) != 0 && (dl_debug_mask[0] & 4) != 0 )
      {
        v23 = (char (*)[1671])v15[1];
        v24 = (char *)&GLOBAL_OFFSET_TABLE_ - 110145;
        if ( !v16 )
          v24 = (char *)&GLOBAL_OFFSET_TABLE_ - 110135;
        if ( !*(_BYTE *)v23 )
        {
          v23 = program_invocation_short_name[0];
          if ( !program_invocation_short_name[0] )
            v23 = (char (*)[1671])((char *)&GLOBAL_OFFSET_TABLE_ - 111925);
        }
        v25 = (char (*)[1671])a2[1];
        if ( !*(_BYTE *)v25 )
        {
          v25 = program_invocation_short_name[0];
          if ( !program_invocation_short_name[0] )
            v25 = (char (*)[1671])((char *)&GLOBAL_OFFSET_TABLE_ - 111925);
        }
        dl_debug_printf((_BYTE *)&GLOBAL_OFFSET_TABLE_ - 109808, v25, a2[6], v23, v15[6], v24, a1);
        if ( a5 )
          dl_debug_printf_c((_BYTE *)&GLOBAL_OFFSET_TABLE_ - 110083, *a5);
        else
          dl_debug_printf_c("\n");
        v15 = v62;
      }
      *a3 = v61;
      return v15;
    }
    v55 = *(unsigned int **)((char *)a2 + (_DWORD)(&dword_80CE1F8 - 33765376));
    v26 = *(_DWORD **)((char *)a2 + (_DWORD)(&off_80CE1F4 - 33765376));
    v59 = v26;
    if ( v26 )
    {
      v27 = (_DWORD *)*v26;
      if ( *v26 )
      {
        v28 = v26 + 1;
        if ( v27 == v15 )
          goto LABEL_82;
        while ( 1 )
        {
          v29 = (_DWORD *)*v28;
          if ( !*v28 )
            break;
          ++v28;
          if ( v29 == v15 )
            goto LABEL_92;
        }
      }
    }
    if ( v55 )
    {
      v54 = *v55;
      if ( *v55 )
      {
        v30 = 0;
        if ( (_DWORD *)v55[1] == v15 )
        {
LABEL_92:
          v15 = v62;
          goto LABEL_18;
        }
        while ( v54 != ++v30 )
        {
          if ( (_DWORD *)v55[v30 + 1] == v15 )
            goto LABEL_92;
        }
      }
    }
    else
    {
      v54 = 0;
    }
    v58 = *((_QWORD *)v15 + 75);
    if ( (a7 & 4) == 0 )
      goto LABEL_69;
    if ( _InterlockedExchange(MK_FP(__GS__, 28), 0) == 2 )
      v37 = sys_futex((int *)(__readgsdword(8u) + 28), 129, 1, 0, v15, v16);
    v38 = (_DWORD *)a2[125];
    if ( v38 != v59 )
    {
      if ( v38 )
      {
        v39 = (_DWORD *)*v38;
        if ( *v38 )
        {
          v40 = v38 + 1;
          if ( v15 == v39 )
          {
            HIDWORD(v35) = *(_DWORD *)((char *)v15 + (_DWORD)(&dword_80CE258 - 33765376));
            LODWORD(v35) = *(_DWORD *)((char *)v15 + (_DWORD)(&dword_80CE25C - 33765376));
            goto LABEL_99;
          }
          while ( 1 )
          {
            v41 = (_DWORD *)*v40;
            if ( !*v40 )
              break;
            ++v40;
            if ( v15 == v41 )
              goto LABEL_98;
          }
        }
      }
    }
    v42 = (unsigned int *)a2[126];
    if ( v42 )
    {
      v43 = *v42;
      if ( v55 == v42 )
      {
        v44 = v54;
        if ( v54 < v43 )
        {
          while ( (_DWORD *)v42[v44 + 1] != v15 )
          {
            if ( ++v44 == v43 )
              goto LABEL_116;
          }
          goto LABEL_98;
        }
      }
      else if ( v43 )
      {
        v44 = 0;
        if ( (_DWORD *)v42[1] == v15 )
        {
LABEL_98:
          HIDWORD(v35) = *(_DWORD *)((char *)v15 + (_DWORD)(&dword_80CE258 - 33765376));
          LODWORD(v35) = *(_DWORD *)((char *)v15 + (_DWORD)(&dword_80CE25C - 33765376));
LABEL_99:
          v34 = -(v35 != __PAIR64__(v58, HIDWORD(v58)));
          goto LABEL_131;
        }
        while ( ++v44 != v43 )
        {
          if ( (_DWORD *)v42[v44 + 1] == v15 )
            goto LABEL_98;
        }
LABEL_116:
        v54 = v44;
      }
      else
      {
        v54 = 0;
      }
    }
LABEL_69:
    for ( j = *(&dl_ns + 19 * a2[6]); j; j = (_DWORD *)j[3] )
    {
      if ( j == v15 )
        break;
    }
    if ( !j )
    {
      if ( (a7 & 4) == 0 )
        return dl_lookup_symbol_x(a1, a2, a3, a4, a5, a6, a7, a8);
      __writegsdword(0x1Cu, 1u);
      goto LABEL_97;
    }
    if ( *((_QWORD *)v15 + 75) == v58 )
    {
      v32 = v15[130];
      if ( (v32 & 8) != 0 )
      {
LABEL_121:
        if ( (a7 & 4) == 0 )
          goto LABEL_82;
        goto LABEL_124;
      }
      if ( (byte_80CE198[(_DWORD)a2 - 135061504] & 3) == 2 && (byte_80CE208[(_DWORD)a2 - 135061504] & 8) == 0 )
      {
        v33 = *(_DWORD *)((char *)a2 + (_DWORD)(&dword_80CE1FC - 33765376));
        if ( v33 > v54 )
        {
          *(_DWORD *)(*(_DWORD *)((char *)a2 + (_DWORD)(&dword_80CE1F8 - 33765376)) + 4 * v54 + 4) = v15;
          **(_DWORD **)((char *)a2 + (_DWORD)(&dword_80CE1F8 - 33765376)) = v54 + 1;
          goto LABEL_80;
        }
        v48 = 2 * v33;
        v56 = v15[130];
        if ( !v33 )
          v48 = 10;
        v49 = malloc((const struct timespec *)(4 * v48 + 4));
        v32 = v56;
        v50 = v49;
        if ( v49 )
        {
          if ( v54 )
          {
            v57 = v49;
            memcpy(
              (_BYTE *)v49 + 4,
              (_BYTE *)(*(_DWORD *)((char *)a2 + (_DWORD)(&dword_80CE1F8 - 33765376)) + 4),
              4 * v54);
            v50 = v57;
          }
          v50[v54 + 1] = (int)v15;
          *v50 = v54 + 1;
          v51 = *(_DWORD *)((char *)a2 + (_DWORD)(&dword_80CE1F8 - 33765376));
          a2[126] = v50;
          a2[127] = v48;
          if ( v51 )
            dl_scope_free(v16, v15, v51);
LABEL_80:
          if ( (dl_debug_mask[0] & 0x40) != 0 )
          {
            v46 = (const char *)a2[1];
            if ( !*v46 )
            {
              v46 = (const char *)program_invocation_short_name[0];
              if ( !program_invocation_short_name[0] )
                v46 = "<main program>";
            }
            v47 = (const char *)v15[1];
            if ( !*v47 )
            {
              v47 = (const char *)program_invocation_short_name[0];
              if ( !program_invocation_short_name[0] )
                v47 = "<main program>";
            }
            dl_debug_printf((_BYTE *)&GLOBAL_OFFSET_TABLE_ - 109872, v47, v15[6], v46, a2[6]);
            if ( *((_DWORD *)&GLOBAL_OFFSET_TABLE_ - 9) )
            {
              MEMORY[0](*((_DWORD *)&GLOBAL_OFFSET_TABLE_ - 7));
              if ( (a7 & 4) == 0 )
                goto LABEL_82;
              goto LABEL_124;
            }
          }
          goto LABEL_121;
        }
      }
      v15[130] = v32 | 8;
      if ( (a7 & 4) == 0 )
        goto LABEL_82;
LABEL_124:
      __writegsdword(0x1Cu, 1u);
LABEL_82:
      v15 = v62;
      goto LABEL_18;
    }
    v34 = -1;
    if ( (a7 & 4) == 0 )
      return dl_lookup_symbol_x(a1, a2, a3, a4, a5, a6, a7, a8);
LABEL_131:
    __writegsdword(0x1Cu, 1u);
    if ( v34 != -1 )
      goto LABEL_82;
LABEL_97:
    a4 = *(int ***)((char *)a2 + (_DWORD)(&dword_80CE1D0 - 33765376));
    return dl_lookup_symbol_x(a1, a2, a3, a4, a5, a6, a7, a8);
  }
LABEL_33:
  if ( (!v12 || *(_BYTE *)(v12 + 12) >> 4 != 2) && (dl_debug_mask[1] & 1) == 0 )
  {
    if ( !a2 || (v45 = (unsigned int *)a2[1], !*(_BYTE *)v45) )
    {
      v45 = (unsigned int *)program_invocation_short_name[0];
      if ( !program_invocation_short_name[0] )
        v45 = (unsigned int *)((char *)&GLOBAL_OFFSET_TABLE_ - 111925);
    }
    dl_exception_create_format(&v63, v45, (_BYTE *)&GLOBAL_OFFSET_TABLE_ - 110128, (char)a1);
    dl_signal_exception(0, (int)&v63, (const char *)&GLOBAL_OFFSET_TABLE_ - 110103);
  }
  v15 = 0;
  *a3 = 0;
  return v15;
}
// 80CDDA4: using guessed type char (**dl_argv)[1671];
// 80CE000: using guessed type _TBYTE GLOBAL_OFFSET_TABLE_;
// 80CE1D0: using guessed type int dword_80CE1D0;
// 80CE1F4: using guessed type void *off_80CE1F4;
// 80CE1F8: using guessed type int dword_80CE1F8;
// 80CE1FC: using guessed type int dword_80CE1FC;
// 80CE258: using guessed type int dword_80CE258;
// 80CE25C: using guessed type int dword_80CE25C;
// 80CE964: using guessed type char (*program_invocation_short_name[2])[1671];
// 80CEA00: using guessed type void *dl_ns;
// 80CFF04: using guessed type _BYTE dl_debug_mask[4];

//----- (0808D5C0) --------------------------------------------------------
_DWORD *__cdecl dl_setup_hash(_DWORD *a1)
{
  _DWORD *result; // eax
  int v2; // edx
  int *v3; // edx
  int v4; // ecx
  int v5; // ebx
  int v6; // ebp
  _DWORD *v7; // esi
  int v8; // edx
  _DWORD *v9; // edx
  int v10; // edx
  int *v11; // edx
  int v12; // ecx

  result = a1;
  v2 = a1[84];
  if ( v2 )
  {
    v3 = *(int **)(v2 + 4);
    v4 = *v3;
    a1[95] = *v3;
    v5 = v3[2];
    v6 = v3[1];
    if ( (v5 & (v5 - 1)) != 0 )
      _assert_fail((int)"(bitmask_nwords & (bitmask_nwords - 1)) == 0", (int)"dl-lookup.c", 920, (int)"_dl_setup_hash");
    a1[96] = v5 - 1;
    v7 = v3 + 4;
    v8 = v3[3];
    a1[98] = v7;
    a1[97] = v8;
    v9 = &v7[v5];
    a1[99] = v9;
    a1[100] = &v9[v4 - v6];
  }
  else
  {
    v10 = a1[12];
    if ( v10 )
    {
      v11 = *(int **)(v10 + 4);
      v12 = *v11;
      v11 += 2;
      a1[100] = v11;
      a1[95] = v12;
      a1[99] = &v11[v12];
    }
  }
  return result;
}

//----- (0808D680) --------------------------------------------------------
int __cdecl dl_add_to_namespace_list(_DWORD *a1, int a2)
{
  void **v2; // eax
  _DWORD *v3; // edx
  unsigned int v4; // eax
  unsigned int v5; // edx
  unsigned int v6; // kr04_4
  int result; // eax

  v2 = &dl_ns + 19 * a2;
  v3 = *v2;
  if ( *v2 )
  {
    while ( v3[3] )
      v3 = (_DWORD *)v3[3];
    a1[4] = v3;
    v3[3] = a1;
  }
  else
  {
    *v2 = a1;
  }
  *(&dl_ns + 19 * a2 + 1) = (char *)*(&dl_ns + 19 * a2 + 1) + 1;
  v4 = dl_load_adds[0];
  v5 = dl_load_adds[1];
  a1[150] = dl_load_adds[0];
  v6 = v4;
  dl_load_adds[0] = v4 + 1;
  result = 0;
  a1[151] = v5;
  dl_load_adds[1] = (__PAIR64__(v5, v6) + 1) >> 32;
  return result;
}
// 80CE9B8: using guessed type _DWORD dl_load_adds[2];
// 80CEA00: using guessed type void *dl_ns;

//----- (0808D740) --------------------------------------------------------
unsigned __int8 *__usercall dl_new_object@<eax>(
        int *edi0@<edi>,
        unsigned int *a2,
        unsigned int *a3,
        char a4,
        unsigned __int8 *a5,
        char a6,
        int a7)
{
  unsigned __int8 *v7; // esi
  int v8; // ebp
  unsigned __int8 *v9; // eax
  unsigned __int8 *v10; // edi
  _BYTE *v11; // eax
  unsigned int *v12; // eax
  char v13; // dl
  unsigned __int8 **v14; // ecx
  int v15; // eax
  unsigned __int8 *v16; // eax
  int v17; // ebp
  unsigned __int8 *v18; // esi
  const struct timespec *v19; // esi
  int *v20; // ebp
  char *v21; // eax
  int *v22; // edx
  int *v23; // eax
  int v24; // edx
  int *v26; // ecx
  int v27; // esi
  unsigned int v28; // eax
  char *v29; // ebp
  int *v30; // ecx
  _WORD *v31; // eax
  int *v32; // ecx
  int *v33; // eax
  __int64 v34; // [esp-1Ch] [ebp-4Ch]
  char v35; // [esp+0h] [ebp-30h]
  int *v36; // [esp+0h] [ebp-30h]
  int *v37; // [esp+0h] [ebp-30h]
  int v38; // [esp+4h] [ebp-2Ch]
  const struct timespec *v39; // [esp+Ch] [ebp-24h]

  v7 = a5;
  v8 = strlen(a3);
  v9 = calloc(edi0, v8 + 625, 1u);
  v10 = v9;
  if ( !v9 )
    return v10;
  *((_DWORD *)v9 + 5) = v9;
  *((_DWORD *)v9 + 90) = v9 + 608;
  *((_DWORD *)v9 + 7) = v9 + 612;
  v11 = memcpy(v9 + 624, a3, v8 + 1);
  *((_DWORD *)v10 + 155) = 1;
  *((_DWORD *)v10 + 153) = v11;
  v12 = (unsigned int *)&v11[v8];
  v13 = *(_BYTE *)a2;
  if ( *(_BYTE *)a2 )
    v12 = a2;
  *((_DWORD *)v10 + 1) = v12;
  v10[408] = a4 & 3 | v10[408] & 0xFC;
  if ( (dl_debug_mask[1] & 1) == 0 )
    *((_DWORD *)v10 + 128) = 1;
  v14 = (unsigned __int8 **)(v10 + 444);
  *((_DWORD *)v10 + 92) = a5;
  *((_DWORD *)v10 + 116) = v10 + 444;
  *((_DWORD *)v10 + 6) = a7;
  *((_DWORD *)v10 + 115) = 4;
  v15 = (int)*(&dl_ns + 19 * a7);
  if ( v15 )
  {
    v16 = (unsigned __int8 *)(v15 + 352);
    v17 = 1;
    *((_DWORD *)v10 + 111) = v16;
    if ( !a5 )
    {
      v7 = v10;
      goto LABEL_24;
    }
  }
  else
  {
    v17 = 0;
    if ( !a5 )
    {
      v7 = v10;
LABEL_12:
      v18 = v7 + 352;
LABEL_13:
      *v14 = v18;
      goto LABEL_14;
    }
  }
  while ( *((_DWORD *)v7 + 92) )
    v7 = (unsigned __int8 *)*((_DWORD *)v7 + 92);
  if ( !v17 )
    goto LABEL_12;
  v16 = (unsigned __int8 *)*((_DWORD *)v10 + 111);
LABEL_24:
  v18 = v7 + 352;
  if ( v18 != v16 )
  {
    if ( (a6 & 8) != 0 )
      *((_DWORD *)v10 + 112) = v16;
    else
      v14 = (unsigned __int8 **)(v10 + 448);
    goto LABEL_13;
  }
LABEL_14:
  v35 = v13;
  *((_DWORD *)v10 + 117) = v10 + 352;
  if ( v13 )
  {
    v38 = strlen(a2);
    v39 = (const struct timespec *)(v38 + 1);
    v19 = (const struct timespec *)(v38 + 1);
    if ( v35 == 47 )
    {
      v33 = malloc(v39);
      v22 = v33;
      if ( !v33 )
      {
        v24 = -1;
LABEL_21:
        *((_DWORD *)v10 + 107) = v24;
        return v10;
      }
      v30 = v33;
    }
    else
    {
      v20 = 0;
      while ( 1 )
      {
        v23 = realloc((int)v20, v20, v19 + 16);
        if ( !v23 )
        {
LABEL_20:
          free((int)v20, (int *)v10, (int)v20);
          v24 = -1;
          goto LABEL_21;
        }
        HIDWORD(v34) = (char *)v19 - v38 + 127;
        LODWORD(v34) = v23;
        v36 = v23;
        v21 = getcwd(v34);
        v22 = v36;
        if ( v21 )
          break;
        v20 = v36;
        v19 += 16;
        if ( __readgsdword(0xFFFFFFE0) != 34 )
          goto LABEL_20;
      }
      v26 = v36;
      do
      {
        v27 = *v26++;
        v28 = ~v27 & (v27 - 16843009) & 0x80808080;
      }
      while ( !v28 );
      v29 = (char *)v26;
      if ( (~v27 & (v27 - 16843009) & 0x8080) == 0 )
        v28 >>= 16;
      if ( (~v27 & (v27 - 16843009) & 0x8080) == 0 )
        v29 = (char *)v26 + 2;
      v30 = (int *)&v29[-__CFADD__((_BYTE)v28, (_BYTE)v28) - 3];
      if ( *((_BYTE *)v30 - 1) != 47 )
      {
        *(_BYTE *)v30 = 47;
        v30 = (int *)((char *)v30 + 1);
      }
    }
    v37 = v22;
    v31 = mempcpy(v30, a2, (unsigned int)v39);
    v24 = (int)v37;
    while ( 1 )
    {
      v32 = (int *)((char *)v31 - 1);
      if ( *((_BYTE *)v31 - 1) == 47 )
        break;
      v31 = (_WORD *)((char *)v31 - 1);
    }
    if ( v37 == v32 )
      v32 = (int *)v31;
    *(_BYTE *)v32 = 0;
    goto LABEL_21;
  }
  return v10;
}
// 80CEA00: using guessed type void *dl_ns;
// 80CFF04: using guessed type _BYTE dl_debug_mask[4];

//----- (0808DA60) --------------------------------------------------------
int __cdecl dl_try_allocate_static_tls(int a1)
{
  int result; // eax
  unsigned int v2; // esi
  int v3; // edx
  unsigned int v4; // eax
  unsigned int v5; // ebp
  unsigned int v6; // ecx

  result = *(_DWORD *)(a1 + 580);
  if ( result != -1 )
  {
    v2 = *(_DWORD *)(a1 + 572);
    if ( v2 > dl_tls_static_align )
      return -1;
    if ( (unsigned int)(dl_tls_static_size - dl_tls_static_used) <= 0x4BF )
      return -1;
    v3 = *(_DWORD *)(a1 + 576);
    v4 = dl_tls_static_size - dl_tls_static_used - 1216;
    v5 = v3 + *(_DWORD *)(a1 + 568);
    if ( v4 < v5 )
    {
      return -1;
    }
    else
    {
      v6 = v4 + dl_tls_static_used - v3 - v2 * ((v4 - v5) / v2);
      *(_DWORD *)(a1 + 580) = v6;
      dl_tls_static_used = v6;
      if ( (*(_BYTE *)(*(_DWORD *)(a1 + 20) + 408) & 4) != 0 )
      {
        dl_init_static_tls(a1);
        return 0;
      }
      else
      {
        *(_BYTE *)(a1 + 409) |= 4u;
        return 0;
      }
    }
  }
  return result;
}
// 80CE024: using guessed type int dl_tls_static_size;
// 80CE9E4: using guessed type int (__cdecl *dl_init_static_tls)(_DWORD);

//----- (0808DB40) --------------------------------------------------------
int __cdecl dl_allocate_static_tls(int a1)
{
  int result; // eax

  if ( *(_DWORD *)(a1 + 580) == -1 || (result = dl_try_allocate_static_tls(a1)) != 0 )
    dl_signal_error(0, *(unsigned int **)(a1 + 4), 0, (unsigned int *)"cannot allocate memory in static TLS block");
  return result;
}

//----- (0808DB90) --------------------------------------------------------
unsigned __int8 *__cdecl dl_nothread_init_static_tls(int a1)
{
  unsigned int v1; // esi
  unsigned __int8 *v2; // eax
  unsigned int v4; // [esp-Ch] [ebp-14h]

  v4 = *(_DWORD *)(a1 + 564);
  v1 = *(_DWORD *)(a1 + 568) - v4;
  v2 = (unsigned __int8 *)mempcpy((_BYTE *)(__readgsdword(8u) - *(_DWORD *)(a1 + 580)), *(_BYTE **)(a1 + 560), v4);
  return memset(v2, 0, v1);
}

//----- (0808DBF0) --------------------------------------------------------
_BYTE *__cdecl dl_protect_relro(int a1)
{
  int v1; // edx
  int v2; // eax
  _BYTE *v3; // edx
  _BYTE *result; // eax

  v1 = *(_DWORD *)a1 + *(_DWORD *)(a1 + 592);
  v2 = *(_DWORD *)(a1 + 596) + v1;
  v3 = (_BYTE *)(-dl_pagesize & v1);
  result = (_BYTE *)(-dl_pagesize & v2);
  if ( v3 != result )
  {
    result = (_BYTE *)mprotect(v3, result - v3, 1);
    if ( (int)result < 0 )
      dl_signal_error(
        __readgsdword(0xFFFFFFE0),
        *(unsigned int **)(a1 + 4),
        0,
        (unsigned int *)"cannot apply additional memory protection after relocation");
  }
  return result;
}
// 80CE9B0: using guessed type int dl_pagesize;

//----- (0808DC60) --------------------------------------------------------
void __cdecl __noreturn dl_reloc_bad_type(int a1, unsigned __int8 a2, int a3)
{
  _BYTE *v3; // eax
  int v4[11]; // [esp+0h] [ebp-2Ch] BYREF

  v3 = stpcpy((int)v4, (int)&msg_10942[32 * a3]);
  v3[2] = 0;
  *v3 = itoa_lower_digits[a2 >> 4];
  v3[1] = itoa_lower_digits[a2 & 0xF];
  dl_signal_error(0, *(unsigned int **)(a1 + 4), 0, (unsigned int *)v4);
}
// 808DC60: using guessed type unsigned int var_2C[11];

//----- (0808DCD0) --------------------------------------------------------
_TBYTE *__cdecl dl_relocate_object(int a1, int a2, int a3, int a4)
{
  _TBYTE *result; // eax
  int v5; // edi
  int v6; // edx
  int v7; // ecx
  char v8; // al
  int v9; // eax
  bool v10; // zf
  char *v11; // eax
  unsigned int i; // eax
  int v13; // eax
  unsigned int v14; // ebx
  int v15; // ecx
  int v16; // esi
  int v17; // eax
  unsigned int v18; // edx
  int v19; // ecx
  unsigned int v20; // edx
  int v21; // edi
  int *v22; // esi
  unsigned int v23; // edi
  unsigned int v24; // ecx
  int *v25; // ecx
  int v26; // edi
  int v27; // eax
  unsigned int v28; // eax
  int (**v29)(void); // esi
  int *v30; // edi
  unsigned int j; // eax
  int v32; // eax
  unsigned int v33; // eax
  int v34; // ecx
  int v35; // ebx
  int v36; // ecx
  int *v37; // edx
  int *v38; // edi
  int v39; // eax
  unsigned int v40; // edx
  int v41; // esi
  __int16 v42; // ax
  int v43; // ebx
  int v44; // edx
  _DWORD *v45; // eax
  unsigned int *v46; // eax
  int v47; // edx
  unsigned int v48; // edx
  int v49; // edx
  int v50; // eax
  int (*v51)(void); // ecx
  int v52; // edx
  _DWORD *v53; // eax
  unsigned int v54; // ebx
  int v55; // edx
  int v56; // eax
  unsigned int v57; // ebx
  char (***v58)[1671]; // ecx
  int v59; // edx
  __int16 v60; // di
  int v61; // esi
  unsigned __int8 v62; // cl
  int v63; // edi
  int v64; // eax
  _DWORD *v65; // edx
  _DWORD *v66; // eax
  int v67; // edx
  _DWORD *v68; // edi
  int v69; // eax
  void (*v70)(void); // edx
  char v71; // al
  int v72; // ecx
  int v73; // eax
  char (*v74)[1671]; // eax
  int v75; // eax
  int v76; // eax
  int v77; // ebx
  int v78; // ecx
  unsigned int v79; // eax
  int v80; // ebx
  int v81; // eax
  _DWORD *v82; // eax
  int v83; // edx
  unsigned int v84; // edx
  int v85; // eax
  __int16 v86; // dx
  unsigned int v87; // eax
  _DWORD *v88; // eax
  _DWORD *v89; // eax
  unsigned int v90; // edx
  int (*v91)(void); // ecx
  bool v92; // cl
  int v93; // edi
  int v94; // ecx
  int v95; // ecx
  int v96; // eax
  int v97; // edi
  bool v98; // dl
  unsigned int v99; // eax
  char v100; // al
  int v101; // edx
  char *v102; // eax
  _DWORD *v103; // esi
  unsigned int v104; // eax
  unsigned int v105; // edi
  int v106; // ebx
  unsigned __int8 v107; // dl
  int v108; // eax
  char (***v109)[1671]; // eax
  int v110; // ecx
  void (*v111)(void); // ecx
  char v112; // al
  char (*v113)[1671]; // eax
  int v114; // ecx
  unsigned int v115; // esi
  _TBYTE *v116; // eax
  int v117; // edx
  int v118; // edx
  int v119; // ecx
  char (***v120)[1671]; // eax
  bool v121; // al
  int v122; // edx
  int v123; // edx
  int v124; // ecx
  int v125; // eax
  bool v126; // al
  int v127; // ecx
  unsigned int v128; // edx
  _DWORD *v129; // ebx
  int v130; // ecx
  int v131; // edx
  const void *v132; // eax
  int v133; // eax
  unsigned __int8 *v134; // eax
  char (*v135)[1671]; // edx
  int v136; // ebx
  int v137; // eax
  unsigned __int8 *v138; // eax
  char *v139; // eax
  _DWORD *v140; // edx
  _DWORD *v141; // eax
  _DWORD *v142; // edx
  unsigned __int8 v143; // dl
  _TBYTE *v144; // eax
  char v145; // al
  char *v146; // eax
  int v147; // eax
  int (*v148)(void); // eax
  int v149; // edx
  char *v150; // eax
  const void *v151; // [esp-Eh] [ebp-10BCh] BYREF
  size_t v152; // [esp-Ah] [ebp-10B8h]
  int v153; // [esp-6h] [ebp-10B4h]
  int v154; // [esp-2h] [ebp-10B0h]
  void (*v155)(void); // [esp+1016h] [ebp-98h]
  int v156; // [esp+101Ah] [ebp-94h]
  int v157; // [esp+101Eh] [ebp-90h]
  char (***v158)[1671]; // [esp+1022h] [ebp-8Ch]
  const void **v159; // [esp+1026h] [ebp-88h]
  int *v160; // [esp+102Ah] [ebp-84h]
  unsigned int *v161; // [esp+102Eh] [ebp-80h]
  int v162; // [esp+1032h] [ebp-7Ch]
  int v163; // [esp+1036h] [ebp-78h]
  int v164; // [esp+103Ah] [ebp-74h]
  unsigned int *v165; // [esp+103Eh] [ebp-70h]
  int v166; // [esp+1042h] [ebp-6Ch]
  int v167; // [esp+1046h] [ebp-68h]
  int (*v168)(void); // [esp+104Ah] [ebp-64h]
  char (***v169)[1671]; // [esp+104Eh] [ebp-60h]
  unsigned int v170; // [esp+1052h] [ebp-5Ch]
  _TBYTE *v171; // [esp+1056h] [ebp-58h]
  unsigned int v172; // [esp+105Ah] [ebp-54h]
  int v173; // [esp+105Eh] [ebp-50h]
  int v174; // [esp+106Eh] [ebp-40h] BYREF
  unsigned int v175; // [esp+1072h] [ebp-3Ch] BYREF
  int v176; // [esp+1076h] [ebp-38h]
  int v177; // [esp+107Ah] [ebp-34h]
  int v178; // [esp+1082h] [ebp-2Ch]
  unsigned int v179; // [esp+1086h] [ebp-28h]
  int v180; // [esp+108Eh] [ebp-20h]
  _BYTE v181[28]; // [esp+1092h] [ebp-1Ch] BYREF
  int v182; // [esp+10B2h] [ebp+4h]
  int *v183; // [esp+10B2h] [ebp+4h]
  int *v184; // [esp+10B2h] [ebp+4h]
  int *v185; // [esp+10B2h] [ebp+4h]
  int *v186; // [esp+10B2h] [ebp+4h]
  int *v187; // [esp+10B2h] [ebp+4h]
  int *v188; // [esp+10B2h] [ebp+4h]
  int *v189; // [esp+10B2h] [ebp+4h]
  int *v190; // [esp+10B2h] [ebp+4h]

  result = &GLOBAL_OFFSET_TABLE_;
  v5 = a1;
  v171 = &GLOBAL_OFFSET_TABLE_;
  if ( (*(_BYTE *)(a1 + 408) & 4) != 0 )
    return result;
  if ( a4 || !*(_DWORD *)(a1 + 128) )
  {
    v163 = a3 & 1;
    if ( (dl_debug_mask[0] & 0x20) == 0 )
      goto LABEL_4;
    v134 = (unsigned __int8 *)v171 - 109275;
    if ( (a3 & 1) == 0 )
      v134 = (unsigned __int8 *)v171 - 105991;
  }
  else
  {
    if ( (dl_debug_mask[0] & 0x20) == 0 )
    {
      v159 = *(const void ***)(a1 + 120);
      if ( !v159 )
      {
        v50 = *(_DWORD *)(a1 + 52);
        v163 = 0;
        v164 = *(_DWORD *)(v50 + 4);
        goto LABEL_13;
      }
      v127 = *(unsigned __int16 *)(a1 + 348);
      v128 = *(_DWORD *)(a1 + 340);
      v163 = 0;
      v129 = (_DWORD *)v128;
      if ( v128 >= v128 + 32 * v127 )
      {
        v159 = 0;
        v164 = *(_DWORD *)(*(_DWORD *)(a1 + 52) + 4);
        v163 = 0;
        goto LABEL_13;
      }
LABEL_310:
      v159 = 0;
      v173 = (int)&dl_pagesize;
      while ( 1 )
      {
        if ( *v129 == 1 && (v129[6] & 2) == 0 )
        {
          v130 = *(_DWORD *)v173;
          v131 = -*(_DWORD *)v173;
          v172 = v131 & v129[2];
          v132 = (const void *)(*(_DWORD *)a1 + v172);
          v152 = ((v129[5] + v129[2] + v130 - 1) & v131) - v172;
          v151 = v132;
          if ( (mprotect(v132, v152, 3) & 0x80000000) != 0 )
          {
            v150 = &aCannotMakeSegm[(_DWORD)v171 - 135061504];
            goto LABEL_378;
          }
          v128 = *(_DWORD *)(a1 + 340);
          v127 = *(unsigned __int16 *)(a1 + 348);
          v153 = (1934713408 >> (4 * (v129[6] & 7))) & 0xF;
          v133 = (int)v159;
          v159 = &v151;
          v154 = v133;
        }
        v129 += 8;
        if ( (unsigned int)v129 >= v128 + 32 * v127 )
          goto LABEL_5;
      }
    }
    v163 = 0;
    v134 = &byte_80B41F9[(_DWORD)v171 - 135061504];
  }
  v135 = *(char (**)[1671])(a1 + 4);
  if ( !*(_BYTE *)v135 )
  {
    v135 = program_invocation_short_name[0];
    if ( !program_invocation_short_name[0] )
      v135 = (char (*)[1671])((char *)v171 - 111925);
  }
  dl_debug_printf(&aRelocationProc[(_DWORD)v171 - 135061504], v135, v134);
LABEL_4:
  v159 = *(const void ***)(a1 + 120);
  if ( v159 )
  {
    v127 = *(unsigned __int16 *)(a1 + 348);
    v128 = *(_DWORD *)(a1 + 340);
    v129 = (_DWORD *)v128;
    if ( v128 < v128 + 32 * v127 )
      goto LABEL_310;
    v159 = 0;
  }
LABEL_5:
  v164 = *(_DWORD *)(*(_DWORD *)(a1 + 52) + 4);
  if ( *(_DWORD *)(a1 + 124) && v163 )
  {
    v6 = *(_DWORD *)(*(_DWORD *)(a1 + 44) + 4);
    v7 = *(_DWORD *)(v6 + 4);
    v8 = dl_x86_feature_1[0];
    if ( v7 )
    {
      *(_DWORD *)(a1 + 532) = *(_DWORD *)a1 + v7;
      *(_DWORD *)(a1 + 536) = v6 + 12;
    }
    v9 = v8 & 2;
    *(_DWORD *)(v6 + 4) = a1;
    if ( a4 )
    {
      v10 = v9 == 0;
      v163 = 1;
      v144 = v171 - 24400;
      if ( !v10 )
        v144 = v171 - 24408;
      *(_DWORD *)(v6 + 8) = v144;
      if ( dl_profile && dl_name_match_p(dl_profile, a1) )
        dl_profile_map = a1;
    }
    else
    {
      v10 = v9 == 0;
      v163 = 1;
      v11 = (char *)v171 - 244176;
      if ( !v10 )
        v11 = (char *)v171 - 244128;
      *(_DWORD *)(v6 + 8) = v11;
    }
  }
LABEL_13:
  for ( i = 0; i < 0x20; i += 4 )
    *(unsigned int *)((char *)&v175 + i) = 0;
  v13 = *(_DWORD *)(a1 + 100);
  if ( v13 )
  {
    v14 = *(_DWORD *)(v13 + 4);
    v15 = *(_DWORD *)(a1 + 192);
    v16 = *(_DWORD *)(*(_DWORD *)(a1 + 104) + 4);
    v175 = v14;
    v17 = 0;
    v176 = v16;
    v18 = v14 + v16;
    if ( v15 )
    {
      v17 = *(_DWORD *)(v15 + 4);
      v177 = v17;
    }
  }
  else
  {
    v17 = 0;
    v18 = 0;
    v16 = 0;
    v14 = 0;
  }
  v19 = *(_DWORD *)(a1 + 112);
  if ( v19 && *(_DWORD *)(v19 + 4) == 17 )
  {
    v173 = *(_DWORD *)(*(_DWORD *)(a1 + 124) + 4);
    v172 = *(_DWORD *)(*(_DWORD *)(a1 + 40) + 4);
    if ( v173 + v172 == v18 )
    {
      v16 -= v172;
      v176 = v16;
      v18 = v16 + v14;
    }
    if ( !v163 && v173 == v18 )
    {
      v16 += v172;
      v176 = v16;
    }
    else
    {
      v178 = v173;
      v179 = v172;
      v180 = v163;
    }
  }
  v20 = 0;
  v162 = a3 & 0x2000000;
  v160 = (int *)&v175;
  v165 = &v175;
  v161 = (unsigned int *)v181;
  v21 = v16;
  v22 = (int *)a1;
  v173 = *(_DWORD *)a1;
  v158 = &dl_argv;
  while ( 1 )
  {
    v23 = v14 + v21;
    v24 = v14;
    v170 = v23;
    if ( v20 )
      break;
    v52 = v22[14];
    v172 = v14 + 8 * v17;
    v168 = *(int (**)(void))(v52 + 4);
    if ( v173 && v22 && v14 < v172 )
    {
      v53 = (_DWORD *)(*(_DWORD *)v14 + v173);
      if ( *(_BYTE *)(v14 + 4) != 8 )
LABEL_375:
        _assert_fail((int)(v171 - 10948), (int)v171 - 109214, 648, (int)(v171 - 10930));
      v54 = v172;
      v55 = v173;
      while ( 1 )
      {
        v24 += 8;
        *v53 += v55;
        if ( v54 <= v24 )
          break;
        v53 = (_DWORD *)(v55 + *(_DWORD *)v24);
        if ( *(_BYTE *)(v24 + 4) != 8 )
          goto LABEL_375;
      }
    }
    v56 = v22[58];
    if ( !v56 )
    {
      if ( v170 <= v172 )
        goto LABEL_116;
      v182 = (int)v22;
      v103 = (_DWORD *)v172;
      v166 = (int)&dl_argv;
      v157 = (int)&dl_verbose;
      while ( 1 )
      {
        while ( 1 )
        {
          v172 = *v103 + v173;
          v104 = v103[1];
          v105 = (unsigned __int8)v104;
          v106 = (int)v168 + 16 * (v104 >> 8);
          v174 = v106;
          if ( (unsigned __int8)v104 != 8 )
            break;
          v103 += 2;
          *(_DWORD *)v172 += *(_DWORD *)v182;
          if ( v170 <= (unsigned int)v103 )
          {
LABEL_115:
            v22 = (int *)v182;
            goto LABEL_116;
          }
        }
        if ( (_BYTE)v104 )
          break;
        v103 += 2;
        if ( v170 <= (unsigned int)v103 )
          goto LABEL_115;
      }
      v107 = *(_BYTE *)(v106 + 12);
      if ( v107 >> 4 )
      {
        if ( (*(_BYTE *)(v106 + 13) & 3u) - 1 > 1 )
        {
          if ( v106 != *(int *)((char *)&dword_80CE220 + v182 - 135061504) )
          {
LABEL_231:
            switch ( v105 )
            {
              case 7u:
              case 0x23u:
                v108 = 1;
                break;
              case 5u:
                v108 |= 2u;
                break;
              case 6u:
                goto LABEL_249;
              default:
LABEL_233:
                if ( v105 - 14 <= 0x1B )
                {
                  v108 = (0x8C00001u >> (v105 - 14)) & 1;
                  goto LABEL_235;
                }
                v108 = 0;
                break;
            }
            goto LABEL_235;
          }
          if ( (unsigned int)(unsigned __int8)v104 - 7 <= 0x1E )
          {
            v117 = 1879048321;
            if ( _bittest(&v117, (unsigned __int8)v104 - 7) )
            {
              v118 = 1;
              v119 = *(int *)((char *)&dword_80CE224 + v182 - 135061504);
LABEL_281:
              if ( v119 != v118 )
                goto LABEL_231;
              goto LABEL_282;
            }
          }
          v121 = (unsigned __int8)v104 == 41;
          v118 = v105 == 41;
          v119 = *(_DWORD *)(v182 + 548);
          if ( v105 == 5 )
          {
            if ( 3 - !v121 != v119 )
              goto LABEL_233;
            goto LABEL_282;
          }
          if ( v105 != 6 )
            goto LABEL_281;
          if ( 5 - !v121 == v119 )
          {
LABEL_282:
            v110 = *(int *)((char *)&dword_80CE22C + v182 - 135061504);
            v120 = *(char (****)[1671])((char *)&dword_80CE228 + v182 - 135061504);
            v174 = v110;
            v169 = v120;
          }
          else
          {
            v108 = 0;
LABEL_249:
            v108 |= 4u;
LABEL_235:
            *(_DWORD *)(v182 + 548) = v108;
            *(_DWORD *)(v182 + 544) = v106;
            v109 = (char (***)[1671])dl_lookup_symbol_x(
                                       (unsigned __int8 *)(*(_DWORD *)v106 + v164),
                                       (_DWORD *)v182,
                                       &v174,
                                       (int **)a2,
                                       0,
                                       v108,
                                       1,
                                       0);
            v110 = v174;
            v169 = v109;
            *(_DWORD *)(v182 + 556) = v174;
            *(_DWORD *)(v182 + 552) = v109;
          }
          if ( !v110 )
          {
            if ( v105 <= 0x2A )
              __asm { jmp     eax }
_L164_0:
            v143 = v105;
            goto LABEL_343;
          }
          v107 = *(_BYTE *)(v110 + 12);
          LOWORD(v167) = *(_WORD *)(v110 + 14);
          if ( (_WORD)v167 == 0xFFF1 )
          {
LABEL_251:
            v111 = *(void (**)(void))(v110 + 4);
            if ( (v107 & 0xF) == 10 )
            {
LABEL_252:
              if ( !v162 && (_WORD)v167 )
              {
                if ( (char (***)[1671])v182 != v169 )
                {
                  v112 = byte_80CE198[(_DWORD)v169 - 135061504];
                  if ( (v112 & 3) != 0 && (v112 & 4) == 0 )
                  {
                    v156 = (int)v111;
                    v167 = *(_DWORD *)(*(_DWORD *)(v182 + 52) + 4) + *(_DWORD *)v106;
                    v113 = program_invocation_short_name[0];
                    if ( !program_invocation_short_name[0] )
                      v113 = (char (*)[1671])((char *)v171 - 109267);
                    dl_dprintf(2, (_BYTE *)v171 - 109532, v113, *(_DWORD *)(v182 + 4), v169[1], v167);
                    v111 = (void (*)(void))v156;
                  }
                }
                v111();
                if ( v105 <= 0x2A )
                  __asm { jmp     eax }
                goto _L164_0;
              }
            }
LABEL_244:
            if ( v105 <= 0x2A )
              __asm { jmp     eax }
            goto _L164_0;
          }
LABEL_243:
          v111 = (void (*)(void))((char *)*v169 + *(_DWORD *)(v110 + 4));
          if ( (v107 & 0xF) == 10 )
            goto LABEL_252;
          goto LABEL_244;
        }
        v169 = (char (***)[1671])v182;
        v110 = (int)v168 + 16 * (v104 >> 8);
      }
      else
      {
        v110 = (int)v168 + 16 * (v104 >> 8);
        v169 = (char (***)[1671])v182;
      }
      LOWORD(v167) = *(_WORD *)(v110 + 14);
      if ( (_WORD)v167 == 0xFFF1 )
        goto LABEL_251;
      goto LABEL_243;
    }
    v166 = *(_DWORD *)(v56 + 4);
    if ( v170 > v172 )
    {
      v182 = (int)v22;
      v157 = (int)&dl_verbose;
      while ( 1 )
      {
        while ( 1 )
        {
          v57 = *(_DWORD *)(v172 + 4);
          v58 = (char (***)[1671])(*(_DWORD *)v172 + v173);
          v169 = v58;
          v59 = *(int *)((char *)&dword_80CE174 + v182 - 135061504);
          v60 = *(_WORD *)(v166 + 2 * (v57 >> 8));
          v61 = (int)v168 + 16 * (v57 >> 8);
          v174 = v61;
          LOWORD(v167) = v60;
          if ( (unsigned __int8)v57 != 8 )
            break;
          v75 = *(_DWORD *)v182;
          v172 += 8;
          *v58 = (char (**)[1671])((char *)*v58 + v75);
          if ( v170 <= v172 )
            goto LABEL_115;
        }
        if ( (_BYTE)v57 )
          break;
        v172 += 8;
        if ( v170 <= v172 )
          goto LABEL_115;
      }
      v62 = *(_BYTE *)(v61 + 12);
      if ( !(v62 >> 4) || (*(_BYTE *)(v61 + 13) & 3u) - 1 <= 1 )
      {
        v67 = (int)v168 + 16 * (v57 >> 8);
        v68 = (_DWORD *)v182;
        LOWORD(v167) = *(_WORD *)(v61 + 14);
        if ( (_WORD)v167 == 0xFFF1 )
          goto LABEL_127;
        goto LABEL_119;
      }
      if ( v61 != *(int *)((char *)&dword_80CE220 + v182 - 135061504) )
      {
LABEL_103:
        switch ( (unsigned __int8)v57 )
        {
          case 7u:
          case 0x23u:
            v63 = 1;
            break;
          case 5u:
            v63 |= 2u;
            break;
          case 6u:
LABEL_125:
            v63 |= 4u;
            break;
          default:
LABEL_105:
            if ( (unsigned int)(unsigned __int8)v57 - 14 <= 0x1B )
            {
              v63 = (0x8C00001u >> (v57 - 14)) & 1;
              break;
            }
            v63 = 0;
            break;
        }
        v64 = v167 & 0x7FFF;
        *(_DWORD *)(v182 + 548) = v63;
        *(_DWORD *)(v182 + 544) = v61;
        v65 = (_DWORD *)(16 * v64 + v59);
        if ( v65 && !v65[1] )
          v65 = 0;
        v66 = dl_lookup_symbol_x(
                (unsigned __int8 *)(*(_DWORD *)v61 + v164),
                (_DWORD *)v182,
                &v174,
                (int **)a2,
                v65,
                v63,
                1,
                0);
        v67 = v174;
        v68 = v66;
        *(int *)((char *)&dword_80CE22C + v182 - 135061504) = v174;
        *(int *)((char *)&dword_80CE228 + v182 - 135061504) = (int)v66;
LABEL_111:
        if ( !v67 )
        {
          if ( (unsigned __int8)v57 <= 0x2Au )
            __asm { jmp     eax }
_L121:
          v143 = v57;
          goto LABEL_343;
        }
        v62 = *(_BYTE *)(v67 + 12);
        LOWORD(v167) = *(_WORD *)(v67 + 14);
        if ( (_WORD)v167 == 0xFFF1 )
        {
LABEL_127:
          v70 = *(void (**)(void))(v67 + 4);
          if ( (v62 & 0xF) == 10 )
          {
LABEL_128:
            if ( (_WORD)v167 && !v162 )
            {
              if ( (_DWORD *)v182 != v68 )
              {
                v71 = *((_BYTE *)v68 + 408);
                if ( (v71 & 3) != 0 && (v71 & 4) == 0 )
                {
                  v72 = *(_DWORD *)v61;
                  v155 = v70;
                  v73 = v68[1];
                  v167 = *(_DWORD *)(*(_DWORD *)(v182 + 52) + 4) + v72;
                  v156 = v73;
                  v74 = program_invocation_short_name[0];
                  if ( !program_invocation_short_name[0] )
                    v74 = (char (*)[1671])((char *)v171 - 109267);
                  dl_dprintf(2, (_BYTE *)v171 - 109532, v74, *(_DWORD *)(v182 + 4), v156, v167);
                  v70 = v155;
                }
              }
              v70();
              if ( (unsigned __int8)v57 <= 0x2Au )
                __asm { jmp     eax }
              goto _L121;
            }
          }
LABEL_120:
          if ( (unsigned __int8)v57 <= 0x2Au )
            __asm { jmp     eax }
          goto _L121;
        }
LABEL_119:
        v70 = (void (*)(void))(*(_DWORD *)(v67 + 4) + *v68);
        if ( (v62 & 0xF) == 10 )
          goto LABEL_128;
        goto LABEL_120;
      }
      if ( (unsigned int)(unsigned __int8)v57 - 7 <= 0x1E )
      {
        v97 = 1879048321;
        if ( _bittest(&v97, (unsigned __int8)v57 - 7) )
        {
          v156 = 1;
          v93 = *(int *)((char *)&dword_80CE224 + v182 - 135061504);
          goto LABEL_200;
        }
      }
      v92 = (unsigned __int8)v57 == 41;
      v156 = v92;
      v93 = *(int *)((char *)&dword_80CE224 + v182 - 135061504);
      if ( (unsigned __int8)v57 == 5 )
      {
        if ( 3 - !v92 != v93 )
          goto LABEL_105;
      }
      else if ( (unsigned __int8)v57 == 6 )
      {
        if ( 5 - !v92 != v93 )
        {
          v63 = 0;
          goto LABEL_125;
        }
      }
      else
      {
LABEL_200:
        if ( v93 != v156 )
          goto LABEL_103;
      }
      v67 = *(int *)((char *)&dword_80CE22C + v182 - 135061504);
      v68 = *(_DWORD **)((char *)&dword_80CE228 + v182 - 135061504);
      v174 = v67;
      goto LABEL_111;
    }
LABEL_116:
    v69 = *v22;
    v165 += 4;
    v173 = v69;
    if ( v165 == v161 )
      goto LABEL_33;
LABEL_117:
    v20 = v165[3];
    v17 = v165[2];
    v21 = v165[1];
    v14 = *v165;
  }
  v169 = &dl_argv;
  v168 = (int (*)(void))&dl_argv;
  if ( v14 >= v23 )
    goto LABEL_32;
  v25 = v22;
  v26 = v173;
  do
  {
    while ( 1 )
    {
      v28 = *(_DWORD *)(v14 + 4);
      v29 = (int (**)(void))(v26 + *(_DWORD *)v14);
      if ( (unsigned __int8)v28 == 7 )
      {
        v27 = v25[133];
        if ( v27 )
          *v29 = (int (*)(void))(v27 + 4 * ((_DWORD)v29 - v25[134]));
        else
          *v29 = (int (*)(void))((char *)*v29 + v26);
        goto LABEL_26;
      }
      if ( (unsigned __int8)v28 != 41 )
      {
        if ( (unsigned __int8)v28 != 42 )
          dl_reloc_bad_type((int)v25, v28, 1);
        v148 = (int (*)(void))((char *)*v29 + *v25);
        if ( !v162 )
        {
          v190 = v25;
          v148 = (int (*)(void))v148();
          v25 = v190;
        }
        *v29 = v148;
        goto LABEL_26;
      }
      v173 = v28 >> 8;
      if ( !(v28 >> 8) )
        break;
      if ( !v29[1] )
      {
        v116 = v171;
        v29[1] = (int (*)(void))v14;
        *v29 = (int (*)(void))((char *)v116 + (_DWORD)dl_tlsdesc_resolve_rel - 135061504);
        goto LABEL_26;
      }
      v85 = v25[14];
      v167 = v25[58];
      v172 = *(_DWORD *)(v85 + 4) + 16 * v173;
      LOBYTE(v157) = *(_BYTE *)(v172 + 12);
      LOBYTE(v166) = (unsigned __int8)v157 >> 4;
      if ( v167 )
      {
        v86 = *(_WORD *)(*(_DWORD *)(v167 + 4) + 2 * v173);
        v173 = v25[93];
        v174 = v172;
        if ( !(_BYTE)v166 || (*(_BYTE *)(v172 + 13) & 3u) - 1 <= 1 )
        {
          v173 = (int)v25;
          v90 = v172;
LABEL_288:
          LOWORD(v167) = *(_WORD *)(v90 + 14);
          if ( (_WORD)v167 == 0xFFF1 )
            v166 = 0;
          else
            v166 = *(_DWORD *)v173;
          if ( (v157 & 0xF) != 10 || !(_WORD)v167 || v162 )
            goto LABEL_291;
          v167 = *(_DWORD *)(v90 + 4);
          if ( v25 != (int *)v173 )
          {
            v145 = byte_80CE198[v173 - 135061504];
            if ( (v145 & 3) != 0 && (v145 & 4) == 0 )
            {
              v188 = v25;
              v172 = *(_DWORD *)(v25[13] + 4) + *(_DWORD *)v172;
              v157 = *(_DWORD *)(v173 + 4);
              v146 = **(char ***)v168;
              if ( !v146 )
                v146 = (char *)v171 - 109267;
              dl_dprintf(2, (_BYTE *)v171 - 109532, v146, v25[1], v157, v172);
              v25 = v188;
            }
          }
          v189 = v25;
          ((void (*)(void))(v166 + v167))();
          v25 = v189;
          if ( v174 )
            goto LABEL_291;
          goto LABEL_172;
        }
        if ( v25[136] == v172 && v25[137] == 1 )
        {
          v90 = v25[139];
          v147 = v25[138];
          v174 = v90;
          v173 = v147;
        }
        else
        {
          v87 = v172;
          v25[137] = 1;
          v25[136] = v87;
          v88 = (_DWORD *)(16 * (v86 & 0x7FFF) + v173);
          if ( v88 && !v88[1] )
            v88 = 0;
          v183 = v25;
          v89 = dl_lookup_symbol_x((unsigned __int8 *)(*(_DWORD *)v172 + v164), v25, &v174, (int **)a2, v88, 1, 1, 0);
          v25 = v183;
          v90 = v174;
          v173 = (int)v89;
          v183[139] = v174;
          v183[138] = (int)v89;
        }
        if ( v90 )
        {
          LOBYTE(v157) = *(_BYTE *)(v90 + 12);
          goto LABEL_288;
        }
      }
      else
      {
        v174 = v172;
        if ( !(_BYTE)v166 || (*(_BYTE *)(v172 + 13) & 3u) - 1 <= 1 )
        {
          v173 = (int)v25;
          v99 = v172;
LABEL_208:
          LOWORD(v166) = *(_WORD *)(v99 + 14);
          if ( (_WORD)v166 == 0xFFF1 )
            v167 = 0;
          else
            v167 = *(_DWORD *)v173;
          if ( (v157 & 0xF) != 10 || !(_WORD)v166 || v162 )
            goto LABEL_291;
          v166 = *(_DWORD *)(v99 + 4);
          if ( v25 != (int *)v173 )
          {
            v100 = byte_80CE198[v173 - 135061504];
            if ( (v100 & 3) != 0 && (v100 & 4) == 0 )
            {
              v101 = *(_DWORD *)(v25[13] + 4) + *(_DWORD *)v172;
              v172 = *(_DWORD *)(v173 + 4);
              v157 = v25[1];
              v102 = (char *)**v169;
              if ( !v102 )
                v102 = &aProgramNameUnk[(_DWORD)v171 - 135061504];
              v184 = v25;
              dl_dprintf(2, &aSRelinkSWithSF[(_DWORD)v171 - 135061504], v102, v157, v172, v101, v25, v25);
              v25 = v184;
            }
          }
          v185 = v25;
          ((void (*)(void))(v167 + v166))();
          v25 = v185;
          if ( v174 )
          {
LABEL_291:
            v172 = *(int *)((char *)&dword_80CE244 + v173 - 135061504);
            if ( v172 == -1 || v172 == 0 )
            {
              v187 = v25;
              dl_allocate_static_tls(v173);
              v25 = v187;
              v172 = *(int *)((char *)&dword_80CE244 + v173 - 135061504);
            }
            v29[1] = (int (*)(void))((char *)v29[1] + *(_DWORD *)(v174 + 4) - v172);
            *v29 = (int (*)(void))((char *)v171 + (_DWORD)dl_tlsdesc_return - 135061504);
            goto LABEL_26;
          }
          goto LABEL_172;
        }
        if ( v25[136] == v172 && v25[137] == 1 )
        {
          v99 = v25[139];
          v149 = v25[138];
          v174 = v99;
          v173 = v149;
        }
        else
        {
          v140 = (_DWORD *)v172;
          v186 = v25;
          v25[137] = 1;
          v25[136] = (int)v140;
          v141 = dl_lookup_symbol_x((unsigned __int8 *)(*v140 + v164), v25, &v174, (int **)a2, 0, 1, 1, 0);
          v25 = v186;
          v142 = v141;
          v173 = (int)v141;
          v99 = v174;
          v186[138] = (int)v142;
          v186[139] = v99;
        }
        if ( v99 )
        {
          LOBYTE(v157) = *(_BYTE *)(v99 + 12);
          goto LABEL_208;
        }
      }
LABEL_172:
      *v29 = (int (*)(void))((char *)v171 + (_DWORD)dl_tlsdesc_undefweak - 135061504);
LABEL_26:
      v14 += 8;
      if ( v170 <= v14 )
        goto LABEL_31;
    }
    v14 += 8;
    *v29 = (int (*)(void))((char *)v171 + (_DWORD)dl_tlsdesc_resolve_abs_plus_addend - 135061504);
  }
  while ( v170 > v14 );
LABEL_31:
  v22 = v25;
  v173 = *v25;
LABEL_32:
  v165 += 4;
  if ( v165 != v161 )
    goto LABEL_117;
LABEL_33:
  v30 = v22;
  for ( j = 0; j < 0x20; j += 4 )
    *(unsigned int *)((char *)&v175 + j) = 0;
  v32 = v22[15];
  if ( v32 )
  {
    v33 = *(_DWORD *)(v32 + 4);
    v34 = v22[49];
    v35 = *(_DWORD *)(v22[16] + 4);
    v175 = v33;
    v176 = v35;
    v172 = v33 + v35;
    if ( v34 )
      v177 = *(_DWORD *)(v34 + 4);
  }
  else
  {
    v172 = 0;
    v35 = 0;
    v33 = 0;
  }
  v36 = v22[28];
  if ( v36 && *(_DWORD *)(v36 + 4) == 7 )
  {
    v114 = *(_DWORD *)(v22[31] + 4);
    v115 = *(_DWORD *)(v22[10] + 4);
    if ( v114 + v115 == v172 )
    {
      v35 -= v115;
      v176 = v35;
      v172 = v35 + v33;
    }
    if ( !v163 && v114 == v172 )
    {
      v35 += v115;
      v176 = v35;
    }
    else
    {
      v178 = v114;
      v179 = v115;
    }
  }
  v182 = (int)v30;
  v163 = (int)v160;
  v161 = (unsigned int *)v181;
  v160 = 0;
  v157 = (int)&dl_argv;
  while ( 2 )
  {
    v37 = (int *)v33;
    v170 = v35 + v33;
    v169 = *(char (****)[1671])(*(_DWORD *)(v182 + 56) + 4);
    v38 = (int *)(v33 + 12 * *(_DWORD *)(v163 + 8));
    if ( (int *)v182 == v160 || !v173 && *(_DWORD *)(v182 + 288) || v33 >= (unsigned int)v38 )
    {
      v39 = *(int *)((char *)&dword_80CE0E8 + v182 - 135061504);
      if ( v39 )
        goto LABEL_45;
LABEL_146:
      if ( v170 > (unsigned int)v38 )
      {
        v165 = (unsigned int *)&dl_argv;
        v158 = (char (***)[1671])&dl_verbose;
        do
        {
          v172 = *v38 + v173;
          v79 = v38[1];
          v41 = (unsigned __int8)v79;
          v80 = (int)&v169[4 * (v79 >> 8)];
          v174 = v80;
          if ( (unsigned __int8)v79 == 8 )
          {
            *(_DWORD *)v172 = *(_DWORD *)v182 + v38[2];
          }
          else if ( (_BYTE)v79 )
          {
            if ( *(_BYTE *)(v80 + 12) >> 4 )
            {
              if ( (*(_BYTE *)(v80 + 13) & 3u) - 1 <= 1 )
              {
                v166 = v182;
                v83 = (int)&v169[4 * (v79 >> 8)];
              }
              else
              {
                if ( v80 != *(int *)((char *)&dword_80CE220 + v182 - 135061504) )
                {
LABEL_153:
                  switch ( v41 )
                  {
                    case 7:
                    case 35:
                      v81 = 1;
                      break;
                    case 5:
                      v81 |= 2u;
                      break;
                    case 6:
                      goto LABEL_186;
                    default:
LABEL_155:
                      if ( (unsigned int)(v41 - 14) <= 0x1B )
                      {
                        v81 = (0x8C00001u >> (v41 - 14)) & 1;
                        goto LABEL_157;
                      }
                      v81 = 0;
                      break;
                  }
                  goto LABEL_157;
                }
                if ( (unsigned int)(unsigned __int8)v79 - 7 <= 0x1E )
                {
                  v122 = 1879048321;
                  if ( _bittest(&v122, (unsigned __int8)v79 - 7) )
                  {
                    v123 = 1;
                    v124 = *(int *)((char *)&dword_80CE224 + v182 - 135061504);
LABEL_297:
                    if ( v124 != v123 )
                      goto LABEL_153;
                    goto LABEL_298;
                  }
                }
                v126 = (unsigned __int8)v79 == 41;
                v123 = v41 == 41;
                v124 = *(_DWORD *)(v182 + 548);
                if ( v41 == 5 )
                {
                  if ( 3 - !v126 != v124 )
                    goto LABEL_155;
                  goto LABEL_298;
                }
                if ( v41 != 6 )
                  goto LABEL_297;
                if ( 5 - !v126 == v124 )
                {
LABEL_298:
                  v83 = *(int *)((char *)&dword_80CE22C + v182 - 135061504);
                  v125 = *(int *)((char *)&dword_80CE228 + v182 - 135061504);
                  v174 = v83;
                  v166 = v125;
                }
                else
                {
                  v81 = 0;
LABEL_186:
                  v81 |= 4u;
LABEL_157:
                  *(_DWORD *)(v182 + 548) = v81;
                  *(_DWORD *)(v182 + 544) = v80;
                  v82 = dl_lookup_symbol_x(
                          (unsigned __int8 *)(*(_DWORD *)v80 + v164),
                          (_DWORD *)v182,
                          &v174,
                          (int **)a2,
                          0,
                          v81,
                          1,
                          0);
                  v83 = v174;
                  v166 = (int)v82;
                  *(int *)((char *)&dword_80CE22C + v182 - 135061504) = v174;
                  *(int *)((char *)&dword_80CE228 + v182 - 135061504) = (int)v82;
                }
                v168 = 0;
                if ( !v83 )
                {
LABEL_159:
                  v84 = *((unsigned __int8 *)v38 + 4);
                  if ( v84 <= 0x2A )
                    __asm { jmp     ecx }
_L257_0:
                  v143 = v41;
LABEL_343:
                  dl_reloc_bad_type(v182, v143, 0);
                }
              }
            }
            else
            {
              v83 = (int)&v169[4 * (v79 >> 8)];
              v166 = v182;
            }
            v91 = *(int (**)(void))(v83 + 4);
            LOWORD(v167) = *(_WORD *)(v83 + 14);
            v168 = v91;
            if ( (_WORD)v167 == 0xFFF1 || (v168 = (int (*)(void))((char *)v91 + *(_DWORD *)v166), (_WORD)v167) )
            {
              if ( (*(_BYTE *)(v83 + 12) & 0xF) == 10 && !v162 )
                v168 = (int (*)(void))v168();
            }
            goto LABEL_159;
          }
          v38 += 3;
        }
        while ( v170 > (unsigned int)v38 );
      }
    }
    else
    {
      v76 = v173;
      do
      {
        v77 = v37[2];
        v78 = *v37;
        v37 += 3;
        *(_DWORD *)(v78 + v76) = v76 + v77;
      }
      while ( v38 > v37 );
      v39 = *(int *)((char *)&dword_80CE0E8 + v182 - 135061504);
      if ( !v39 )
        goto LABEL_146;
LABEL_45:
      v167 = *(_DWORD *)(v39 + 4);
      if ( v170 > (unsigned int)v38 )
      {
        v158 = (char (***)[1671])&dl_verbose;
        do
        {
          v40 = v38[1];
          v172 = *v38 + v173;
          v41 = (unsigned __int8)v40;
          v42 = *(_WORD *)(v167 + 2 * (v40 >> 8));
          v43 = (int)&v169[4 * (v40 >> 8)];
          v168 = *(int (**)(void))(v182 + 372);
          v174 = v43;
          if ( (unsigned __int8)v40 == 8 )
          {
            *(_DWORD *)v172 = *(_DWORD *)v182 + v38[2];
          }
          else if ( (_BYTE)v40 )
          {
            if ( !(*(_BYTE *)(v43 + 12) >> 4) || (*(_BYTE *)(v43 + 13) & 3u) - 1 <= 1 )
            {
              v47 = (int)&v169[4 * (v40 >> 8)];
              v165 = (unsigned int *)v182;
              goto LABEL_77;
            }
            if ( v43 != *(_DWORD *)(v182 + 544) )
            {
LABEL_52:
              switch ( v41 )
              {
                case 7:
                case 35:
                  v44 = 1;
                  break;
                case 5:
                  v44 |= 2u;
                  break;
                case 6:
LABEL_85:
                  v44 |= 4u;
                  break;
                default:
LABEL_54:
                  if ( (unsigned int)(v41 - 14) <= 0x1B )
                  {
                    v44 = (0x8C00001u >> (v41 - 14)) & 1;
                    break;
                  }
                  v44 = 0;
                  break;
              }
              *(_DWORD *)(v182 + 548) = v44;
              *(_DWORD *)(v182 + 544) = v43;
              v45 = (_DWORD *)((char *)v168 + 16 * (v42 & 0x7FFF));
              if ( v45 && !v45[1] )
                v45 = 0;
              v46 = dl_lookup_symbol_x(
                      (unsigned __int8 *)(*(_DWORD *)v43 + v164),
                      (_DWORD *)v182,
                      &v174,
                      (int **)a2,
                      v45,
                      v44,
                      1,
                      0);
              v47 = v174;
              v165 = v46;
              *(int *)((char *)&dword_80CE22C + v182 - 135061504) = v174;
              *(int *)((char *)&dword_80CE228 + v182 - 135061504) = (int)v46;
LABEL_60:
              v168 = 0;
              if ( !v47 )
              {
LABEL_61:
                v48 = *((unsigned __int8 *)v38 + 4);
                if ( v48 <= 0x2A )
                  __asm { jmp     ecx }
                goto _L257_0;
              }
LABEL_77:
              v51 = *(int (**)(void))(v47 + 4);
              LOWORD(v166) = *(_WORD *)(v47 + 14);
              v168 = v51;
              if ( (_WORD)v166 == 0xFFF1 || (v168 = (int (*)(void))((char *)v51 + *v165), (_WORD)v166) )
              {
                if ( (*(_BYTE *)(v47 + 12) & 0xF) == 10 && !v162 )
                  v168 = (int (*)(void))v168();
              }
              goto LABEL_61;
            }
            if ( (unsigned int)(unsigned __int8)v40 - 7 <= 0x1E
              && (v94 = 1879048321, _bittest(&v94, (unsigned __int8)v40 - 7)) )
            {
              v166 = 1;
              v95 = *(_DWORD *)(v182 + 548);
LABEL_196:
              if ( v95 != v166 )
                goto LABEL_52;
            }
            else
            {
              v98 = (unsigned __int8)v40 == 41;
              v166 = v41 == 41;
              v95 = *(_DWORD *)(v182 + 548);
              if ( v41 == 5 )
              {
                if ( 3 - !v98 != v95 )
                  goto LABEL_54;
              }
              else
              {
                if ( v41 != 6 )
                  goto LABEL_196;
                if ( 5 - !v98 != v95 )
                {
                  v44 = 0;
                  goto LABEL_85;
                }
              }
            }
            v47 = *(int *)((char *)&dword_80CE22C + v182 - 135061504);
            v96 = *(int *)((char *)&dword_80CE228 + v182 - 135061504);
            v174 = v47;
            v165 = (unsigned int *)v96;
            goto LABEL_60;
          }
          v38 += 3;
        }
        while ( v170 > (unsigned int)v38 );
      }
    }
    v163 += 16;
    if ( (unsigned int *)v163 != v161 )
    {
      v35 = *(_DWORD *)(v163 + 4);
      v33 = *(_DWORD *)v163;
      v173 = *(_DWORD *)v182;
      continue;
    }
    break;
  }
  v5 = v182;
  if ( a4 )
  {
    v137 = *(_DWORD *)(v182 + 40);
    if ( v137 )
    {
      v138 = calloc(
               (int *)v182,
               0x18u,
               *(_DWORD *)(v137 + 4) / (4 * (unsigned int)(*(_DWORD *)(*(_DWORD *)(v182 + 112) + 4) == 7) + 8));
      *(_DWORD *)(v182 + 420) = v138;
      if ( !v138 )
      {
        v139 = (char *)program_invocation_short_name[0];
        if ( !program_invocation_short_name[0] )
          v139 = &aProgramNameUnk[(_DWORD)v171 - 135061504];
        dl_dprintf(2, &aSOutOfMemoryTo[(_DWORD)v171 - 135061504], v139, *(_DWORD *)(v182 + 4));
        exit(127);
      }
    }
  }
  v49 = (int)v159;
  *(_BYTE *)(v182 + 408) |= 4u;
  if ( v49 )
  {
    v136 = (int)v159;
    while ( (mprotect(*(const void **)v136, *(_DWORD *)(v136 + 4), *(_DWORD *)(v136 + 8)) & 0x80000000) == 0 )
    {
      v136 = *(_DWORD *)(v136 + 12);
      if ( !v136 )
        goto LABEL_65;
    }
    v150 = &aCannotRestoreS[(_DWORD)v171 - 135061504];
LABEL_378:
    dl_signal_error(__readgsdword(0xFFFFFFE0), *(unsigned int **)(v5 + 4), 0, (unsigned int *)v150);
  }
LABEL_65:
  result = *(_TBYTE **)(v182 + 596);
  if ( result )
    return (_TBYTE *)dl_protect_relro(v182);
  return result;
}
// 80B41F9: using guessed type unsigned __int8 byte_80B41F9[1671];
// 80CDDA4: using guessed type char (**dl_argv)[1671];
// 80CE000: using guessed type _TBYTE GLOBAL_OFFSET_TABLE_;
// 80CE0E8: using guessed type int dword_80CE0E8;
// 80CE174: using guessed type int dword_80CE174;
// 80CE220: using guessed type int dword_80CE220;
// 80CE224: using guessed type int dword_80CE224;
// 80CE228: using guessed type int dword_80CE228;
// 80CE22C: using guessed type int dword_80CE22C;
// 80CE244: using guessed type int dword_80CE244;
// 80CE964: using guessed type char (*program_invocation_short_name[2])[1671];
// 80CE9B0: using guessed type int dl_pagesize;
// 80CFF04: using guessed type _BYTE dl_debug_mask[4];
// 80CFF0C: using guessed type char *dl_profile;
// 80CFF1C: using guessed type _DWORD dl_x86_feature_1[2];

//----- (0808FF70) --------------------------------------------------------
unsigned int __cdecl dl_important_hwcaps(int a1, int a2, _DWORD *a3, _DWORD *a4)
{
  int v4; // eax
  unsigned int v5; // esi
  int v6; // edi
  unsigned int v7; // ebx
  char v8; // cl
  unsigned __int64 v9; // rax
  unsigned int v10; // eax
  _BYTE *v11; // eax
  _BYTE *v12; // ecx
  _BYTE *v13; // eax
  int *v14; // esi
  int v15; // ebx
  int v16; // edi
  int v17; // eax
  unsigned int v18; // edx
  _DWORD *v19; // ecx
  unsigned int v20; // esi
  int v21; // ebx
  _BYTE *v22; // edi
  __int16 v23; // bx
  int v24; // eax
  void *v25; // esp
  unsigned int v26; // eax
  int *v27; // ebx
  _BYTE *v28; // edi
  int v29; // edx
  unsigned int v30; // ecx
  int v31; // edi
  unsigned int v32; // ebx
  int v33; // eax
  unsigned int *v34; // ecx
  int v35; // ebx
  unsigned int v36; // esi
  unsigned __int64 v37; // rax
  int v38; // edi
  unsigned int *v39; // eax
  unsigned int **v40; // edx
  __int64 v41; // rax
  bool v42; // zf
  int v43; // edx
  int v44; // eax
  _BYTE *v45; // edi
  __int16 v46; // ax
  int v47; // eax
  void *v48; // esp
  unsigned int v49; // eax
  int v50; // edx
  _BYTE *v51; // edi
  __int16 v52; // dx
  int v53; // edx
  void *v54; // esp
  int *v55; // eax
  _TBYTE *v56; // ebx
  _DWORD *v57; // edx
  int v58; // esi
  unsigned int v59; // ebx
  int v60; // edx
  int v61; // edx
  int v62; // eax
  int v63; // ecx
  char v64; // bl
  unsigned int v65; // ebx
  _BYTE *v66; // eax
  int v67; // esi
  _WORD *v68; // eax
  unsigned int v69; // ecx
  _BYTE *v70; // edx
  int v71; // edi
  _BYTE *v72; // eax
  unsigned int v73; // esi
  _WORD *v74; // eax
  _WORD *v75; // eax
  unsigned int v76; // edx
  unsigned int v77; // ecx
  unsigned int v78; // eax
  _TBYTE *v79; // ecx
  _BYTE *v80; // esi
  unsigned int v81; // edx
  unsigned int v82; // eax
  int v83; // edi
  int v84; // ecx
  unsigned int v85; // ebx
  int v86; // edx
  int v87; // eax
  unsigned int v88; // ecx
  int v89; // esi
  int v90; // esi
  int v91; // ebx
  int v92; // esi
  int v93; // ecx
  _BYTE *v95; // eax
  _DWORD *v96; // esi
  unsigned int v97; // ebx
  _BYTE *v98; // eax
  int v99; // edx
  _BYTE *v100; // [esp-1014h] [ebp-1084h]
  unsigned int v101; // [esp-1010h] [ebp-1080h]
  _BYTE v102[4]; // [esp-100Ch] [ebp-107Ch]
  _BYTE v103[4096]; // [esp-1008h] [ebp-1078h] BYREF
  _BYTE v104[8]; // [esp-8h] [ebp-78h] BYREF
  unsigned int *v105; // [esp+0h] [ebp-70h]
  int *v106; // [esp+4h] [ebp-6Ch]
  unsigned int v107; // [esp+8h] [ebp-68h]
  char *v108; // [esp+Ch] [ebp-64h]
  int v109; // [esp+10h] [ebp-60h]
  int v110; // [esp+14h] [ebp-5Ch]
  unsigned int v111; // [esp+18h] [ebp-58h]
  _BYTE *v112; // [esp+1Ch] [ebp-54h]
  int v113; // [esp+20h] [ebp-50h]
  unsigned int v114; // [esp+24h] [ebp-4Ch]
  unsigned __int64 v115; // [esp+28h] [ebp-48h]
  unsigned int v116; // [esp+30h] [ebp-40h]
  unsigned int v117; // [esp+34h] [ebp-3Ch]
  __int64 v118; // [esp+38h] [ebp-38h]
  unsigned int v119; // [esp+40h] [ebp-30h]
  _TBYTE *v120; // [esp+44h] [ebp-2Ch]
  unsigned int v121; // [esp+50h] [ebp-20h] BYREF
  unsigned int v122; // [esp+54h] [ebp-1Ch]

  v105 = &v121;
  v120 = &GLOBAL_OFFSET_TABLE_;
  _tunable_get_val(16, (char **)&v121, 0);
  v107 = v122;
  v106 = &dl_hwcap;
  v4 = *(&dl_hwcap + 1);
  v108 = (char *)v121;
  v110 = dl_hwcap;
  v109 = v4;
  LODWORD(v115) = v121 & dl_hwcap;
  v5 = v121 & dl_hwcap;
  HIDWORD(v115) = v122 & v4;
  v6 = v122 & v4;
  v7 = a1 != 0;
  if ( v121 & dl_hwcap | v122 & v4 )
  {
    v8 = 0;
    do
    {
      v116 = v7 + 1;
      v9 = __PAIR64__(v6, v5) >> (v8 & 0x1F);
      if ( (v8 & 0x20) != 0 )
        LOBYTE(v9) = __PAIR64__(v6, v5) >> (v8 & 0x1F) >> 32;
      if ( (v9 & 1) != 0 )
      {
        v10 = v7 + 2;
        v7 = v116;
        v116 = v10;
      }
      v118 = -1LL << ++v8;
    }
    while ( v5 & (unsigned int)(-1LL << v8) | v6 & ((unsigned __int64)(-1LL << v8) >> 32) );
  }
  else
  {
    v116 = v7 + 1;
  }
  v111 = dl_sysinfo_map;
  if ( dl_sysinfo_map )
  {
    v11 = *(_BYTE **)((char *)&dword_80CE154 + v111 - 135061504);
    v114 = *(unsigned __int16 *)((char *)&word_80CE15C + v111 - 135061504);
    if ( v114 )
    {
      v12 = v11;
      v117 = 0;
      do
      {
LABEL_12:
        if ( *(_DWORD *)v12 == 4 )
        {
          v13 = (_BYTE *)*((_DWORD *)v12 + 7);
          v113 = (int)v13;
          if ( (unsigned int)v13 <= 3 )
          {
            v113 = 4;
          }
          else if ( ((unsigned int)(v13 - 4) & 0xFFFFFFFB) != 0 )
          {
            goto LABEL_11;
          }
          v14 = (int *)(*((_DWORD *)v12 + 2) + *(_DWORD *)v111);
          v15 = 12 - (_DWORD)v14;
          LODWORD(v118) = *((_DWORD *)v12 + 5);
          if ( (unsigned int)v118 > 0xC )
          {
            v112 = v12;
            v16 = -v113;
            v119 = v113 + 11;
            while ( 1 )
            {
              v17 = *v14;
              v18 = v14[1];
              if ( v14[2] == 2 && v17 == 4 && v14[3] == 5590599 && v18 > 0xA )
                break;
              v14 = (int *)((char *)v14 + (v16 & (v113 - 1 + v18 + (v16 & (v119 + v17)))));
              if ( (unsigned int)v14 + v15 >= (unsigned int)v118 )
              {
                ++v117;
                v12 = v112 + 32;
                if ( v114 != v117 )
                  goto LABEL_12;
                goto LABEL_40;
              }
            }
            v19 = (int *)((char *)v14 + (v16 & (v113 + 15)));
            v116 += *v19;
            v20 = (unsigned int)(v19 + 2);
            v21 = 8 * v116 + 15;
            v22 = &v104[-(v21 & 0xFFFFF000)];
            v23 = v21 & 0xFFF0;
            if ( v104 != v22 )
            {
              while ( v103 != v22 )
                ;
            }
            v24 = v23 & 0xFFF;
            if ( (v23 & 0xFFF) != 0 )
            {
              v25 = alloca(v24);
              *(_DWORD *)&v102[v24] = *(_DWORD *)&v102[v24];
            }
            v26 = v19[1];
            v27 = v106;
            v28 = v103;
            LODWORD(v118) = v18;
            v119 = v26;
            v114 = (unsigned int)v103;
            *v106 = v110;
            v27[1] = (v26 << 18) | v109;
            v121 = (unsigned int)v108;
            v122 = (v26 << 18) | v107;
            _tunable_set_val(16, v105);
            v29 = v118;
            v30 = 1;
            LODWORD(v118) = 0;
            v117 = v20 + v29 - 8;
            if ( v20 < v117 )
            {
              v113 = (int)v103;
              v31 = 0;
              do
              {
                v32 = v20 + 1;
                v33 = strlen((unsigned int *)(v20 + 1));
                if ( ((1 << *(_BYTE *)v20) & v119) != 0 )
                {
                  v34 = (unsigned int *)(v114 + 8 * v31);
                  *v34 = v32;
                  v34[1] = v33;
                  v30 = v31 + 2;
                  ++v31;
                }
                else
                {
                  --v116;
                  v30 = v31 + 1;
                }
                v20 = v32 + v33 + 1;
              }
              while ( v20 < v117 );
              LODWORD(v118) = v31;
              v28 = (_BYTE *)v113;
            }
            if ( !v115 )
              goto LABEL_45;
LABEL_33:
            v114 = (unsigned int)v28;
            v35 = 0;
            v36 = v118 + 1;
            v113 = (int)"sse2";
            while ( 1 )
            {
              while ( 1 )
              {
                v117 = v36;
                v37 = v115 >> (v35 & 0x1F);
                if ( (v35 & 0x20) != 0 )
                  LOBYTE(v37) = v115 >> (v35 & 0x1F) >> 32;
                if ( (v37 & 1) != 0 )
                  break;
                ++v35;
              }
              v38 = v118;
              v39 = (unsigned int *)(v113 + 9 * v35);
              v40 = (unsigned int **)(v114 + 8 * v118);
              *v40 = v39;
              LODWORD(v118) = v40;
              v40[1] = (unsigned int *)strlen(v39);
              v41 = 1LL << v35++;
              v118 = v41;
              v119 = v115 ^ v41;
              v30 = v38 + 2;
              v42 = v115 == v41;
              v43 = HIDWORD(v115) ^ HIDWORD(v41);
              if ( v42 )
                break;
              LODWORD(v118) = v36++;
              v115 = __PAIR64__(v43, v119);
            }
            v28 = (_BYTE *)v114;
            if ( a1 )
              goto LABEL_54;
LABEL_46:
            v49 = v30;
            v30 = v117;
            goto LABEL_55;
          }
        }
LABEL_11:
        ++v117;
        v12 += 32;
      }
      while ( v114 != v117 );
    }
LABEL_40:
    v44 = 8 * v116 + 15;
    v45 = &v104[-(v44 & 0xFFFFF000)];
    v46 = v44 & 0xFFF0;
    if ( v104 != v45 )
    {
      while ( v103 != v45 )
        ;
    }
    v47 = v46 & 0xFFF;
    if ( v47 )
    {
      v48 = alloca(v47);
      *(_DWORD *)&v102[v47] = *(_DWORD *)&v102[v47];
    }
  }
  else
  {
    v50 = 8 * v116 + 15;
    v51 = &v104[-(v50 & 0xFFFFF000)];
    v52 = v50 & 0xFFF0;
    if ( v104 != v51 )
    {
      while ( v103 != v51 )
        ;
    }
    v53 = v52 & 0xFFF;
    if ( v53 )
    {
      v54 = alloca(v53);
      *(_DWORD *)&v102[v53] = *(_DWORD *)&v102[v53];
    }
  }
  v28 = v103;
  v30 = 1;
  LODWORD(v118) = 0;
  if ( v115 )
    goto LABEL_33;
LABEL_45:
  v117 = v118;
  if ( !a1 )
    goto LABEL_46;
LABEL_54:
  v55 = (int *)&v28[8 * v117];
  *v55 = a1;
  v55[1] = a2;
  v49 = v30 + 1;
LABEL_55:
  v56 = v120;
  v57 = &v28[8 * v30];
  v57[1] = 3;
  *v57 = v56 - 10768;
  if ( v116 != v49 )
    _assert_fail((int)v56 - 107664, (int)v56 - 107676, 184, (int)v56 - 107624);
  LODWORD(v115) = *((_DWORD *)v28 + 1);
  if ( v116 == 1 )
  {
    *a3 = 2;
    v119 = (unsigned int)malloc((const struct timespec *)(v115 + 17));
    if ( v119 )
    {
      v96 = (_DWORD *)v119;
      v97 = v115;
      v98 = (_BYTE *)(v119 + 16);
      v99 = v115 + 1;
      *(_DWORD *)(v119 + 12) = 0;
      *v96 = v98;
      v96[1] = v99;
      v96[2] = v98;
      *(_BYTE *)mempcpy(v98, *(_BYTE **)v28, v97) = 47;
      *a3 = 2;
      *a4 = v96[1];
      return v119;
    }
    goto LABEL_95;
  }
  v58 = v116 - 1;
  LODWORD(v118) = &v28[8 * v116];
  v59 = *(_DWORD *)(v118 - 4);
  v111 = v116 - 1;
  v114 = v59;
  v60 = v59 + v115 + 2;
  if ( v116 <= 2 )
    goto LABEL_64;
  v61 = 2 * v60;
  v62 = 0;
  do
  {
    v63 = *(_DWORD *)&v28[8 * v62++ + 12];
    v61 += v63 + 1;
  }
  while ( v116 - 2 != v62 );
  if ( v116 != 3 && (v116 > 0x1F || (unsigned int)(v61 + 64) >> (35 - v116)) )
LABEL_95:
    dl_signal_error(12, 0, 0, (unsigned int *)((char *)v120 - 107655));
  v60 = v61 << (v116 - 3);
LABEL_64:
  v64 = v116;
  v117 = 1 << v116;
  *a3 = 1 << v116;
  v113 = 8 << v64;
  v119 = (unsigned int)malloc((const struct timespec *)((8 << v64) + v60));
  if ( !v119 )
    goto LABEL_95;
  v65 = v119;
  v66 = (_BYTE *)(v119 + v113);
  *(_DWORD *)v119 = v119 + v113;
  v42 = v116 == 2;
  *(_DWORD *)(v65 + 8) = v66;
  v113 = *(_DWORD *)v28;
  if ( v42 )
  {
    v95 = mempcpy(v66, *((_BYTE **)v28 + 2), *((_DWORD *)v28 + 3));
    *v95 = 47;
    *(_BYTE *)mempcpy(v95 + 1, (_BYTE *)v113, v115) = 47;
  }
  else
  {
    v110 = v58;
    v67 = 1 << v58;
    v112 = *(_BYTE **)(v118 - 8);
    v116 -= 2;
    do
    {
      v68 = mempcpy(v66, v112, v114);
      v69 = v116;
      v70 = v28;
      *(_BYTE *)v68 = 47;
      v71 = v67 - 2;
      v72 = (char *)v68 + 1;
      v73 = v69;
      do
      {
        while ( (v71 & (1 << v73)) == 0 )
        {
          if ( !--v73 )
            goto LABEL_71;
        }
        v101 = *(_DWORD *)&v70[8 * v73 + 4];
        v100 = *(_BYTE **)&v70[8 * v73];
        LODWORD(v118) = v70;
        v74 = mempcpy(v72, v100, v101);
        v70 = (_BYTE *)v118;
        *(_BYTE *)v74 = 47;
        v72 = (char *)v74 + 1;
        --v73;
      }
      while ( v73 );
LABEL_71:
      v67 = v71;
      v28 = v70;
      v75 = mempcpy(v72, (_BYTE *)v113, v115);
      *(_BYTE *)v75 = 47;
      v66 = (char *)v75 + 1;
    }
    while ( v67 );
    v58 = v110;
    if ( !v117 )
      goto LABEL_75;
  }
  v76 = v117;
  v77 = v119;
  v78 = 0;
  do
    *(_DWORD *)(v77 + 8 * v78++ + 4) = 0;
  while ( v78 < v76 );
LABEL_75:
  v79 = (_TBYTE *)v58;
  v80 = v28;
  while ( 1 )
  {
    v81 = v119;
    v82 = v117;
    if ( v117 )
    {
      v120 = v79;
      v83 = 1 << (char)v79;
      do
      {
        --v82;
        for ( v81 += 8; (v82 & v83) != 0; *(_DWORD *)(v81 - 12) = v84 + *(_DWORD *)&v80[8 * (_DWORD)v120 + 4] + 1 )
        {
          v84 = *(_DWORD *)(v81 - 4);
          --v82;
          v81 += 8;
        }
      }
      while ( v82 );
      v79 = v120;
    }
    if ( !v79 )
      break;
    v79 = (_TBYTE *)((char *)v79 - 1);
  }
  v85 = v117 - 2;
  v86 = v119 + 16;
  v87 = 1 << v111;
  if ( v117 - 2 != 1 << v111 )
  {
    v88 = v119 + 16;
    do
    {
      while ( (--v85 & 1) != 0 )
      {
        v89 = *(_DWORD *)(v88 - 16) + *(_DWORD *)(v88 - 12);
        v88 += 8;
        *(_DWORD *)(v88 - 8) = v89;
        if ( v85 == v87 )
          goto LABEL_89;
      }
      v90 = *(_DWORD *)(v88 - 8);
      v88 += 8;
      *(_DWORD *)(v88 - 8) = v90;
    }
    while ( v85 != v87 );
LABEL_89:
    v86 = v86 + 8 * (v117 - v87) - 16;
  }
  v91 = -8 << v111;
  v92 = v114 + 1;
  do
  {
    v93 = *(_DWORD *)(v86 + v91);
    v86 += 8;
    *(_DWORD *)(v86 - 8) = v92 + v93;
    --v87;
  }
  while ( v87 );
  *a4 = *(_DWORD *)(v119 + 4);
  return v119;
}
// 80CE000: using guessed type _TBYTE GLOBAL_OFFSET_TABLE_;
// 80CE154: using guessed type int dword_80CE154;
// 80CE15C: using guessed type __int16 word_80CE15C;
// 80CF8C8: using guessed type int dl_hwcap;

//----- (08090790) --------------------------------------------------------
int __usercall dl_debug_vdprintf@<eax>(int a1@<eax>, int a2@<edx>, _BYTE *a3@<ecx>, unsigned int **a4)
{
  int v4; // esi
  _BYTE *v5; // ebx
  char v6; // al
  _BYTE *v7; // edx
  char *v9; // eax
  char v10; // al
  char *v11; // ebx
  unsigned int **v12; // eax
  size_t v13; // edi
  bool v14; // zf
  unsigned int v15; // eax
  _BYTE *v16; // eax
  _BYTE *v17; // edx
  unsigned int **v18; // eax
  unsigned int v19; // eax
  char *v20; // eax
  int v21; // edx
  char v22; // cl
  int v23; // ebx
  _TBYTE *v24; // edi
  _BYTE v25[4100]; // [esp-1020h] [ebp-126Ch] BYREF
  unsigned int *v26; // [esp-1Ch] [ebp-268h]
  int v27; // [esp-14h] [ebp-260h]
  char *v28; // [esp-10h] [ebp-25Ch]
  int v29; // [esp+0h] [ebp-24Ch]
  _TBYTE *v30; // [esp+4h] [ebp-248h]
  char *v31; // [esp+8h] [ebp-244h]
  unsigned int **v32; // [esp+Ch] [ebp-240h]
  char v33; // [esp+13h] [ebp-239h]
  int v34; // [esp+14h] [ebp-238h]
  char *v35; // [esp+18h] [ebp-234h]
  int v36; // [esp+1Ch] [ebp-230h]
  int v37; // [esp+20h] [ebp-22Ch]
  char v38[10]; // [esp+28h] [ebp-224h] BYREF
  __int16 v39; // [esp+32h] [ebp-21Ah] BYREF
  struct iovec v40[67]; // [esp+34h] [ebp-218h] BYREF

  v4 = 0;
  v5 = a3;
  v29 = a1;
  v35 = v38;
  v6 = *a3;
  v30 = &GLOBAL_OFFSET_TABLE_;
  v36 = 0;
  v37 = a2;
  if ( v6 )
  {
    while ( v37 == 1 )
    {
      while ( 1 )
      {
        if ( !v36 )
        {
          v36 = getpid();
          if ( v36 < 0 )
            _assert_fail(
              (int)&aPid0SizeofPidT[(_DWORD)v30 - 135061504],
              (int)&aDlMiscC[(_DWORD)v30 - 135061504],
              98,
              (int)&_PRETTY_FUNCTION___10496[(_DWORD)v30 - 135061504]);
          v20 = itoa(v36, &v39, 0xAu, 0);
          v21 = (int)v35;
          if ( v20 > v35 )
          {
            do
              *--v20 = 32;
            while ( v20 != (char *)v21 );
          }
          v39 = 2362;
        }
        if ( v4 > 63 )
        {
          v24 = v30;
          v28 = &_PRETTY_FUNCTION___10496[(_DWORD)v30 - 135061504];
          v27 = 107;
          goto LABEL_70;
        }
        v37 = -1;
        v9 = v35;
        v40[v4].iov_len = 12;
        v40[v4].iov_base = v9;
        v6 = *v5;
        ++v4;
        if ( *v5 != 37 )
          goto LABEL_4;
LABEL_26:
        if ( v4 > 63 )
          goto LABEL_71;
        v40[v4].iov_len = 0;
        v7 = v5;
        if ( v6 == 37 )
          break;
LABEL_16:
        if ( v6 != 10 )
        {
          v5 = v7;
          goto LABEL_18;
        }
        if ( v5 == v7 )
          goto LABEL_43;
        ++*(_DWORD *)&v38[8 * v4 + 8];
LABEL_22:
        v5 = v7 + 1;
        if ( !v7[1] )
          return sys_writev(v29, v40, v4);
      }
LABEL_28:
      v10 = v7[1];
      if ( v10 == 48 )
      {
        v11 = v7 + 2;
        v33 = 48;
        v10 = v7[2];
      }
      else
      {
        v33 = 32;
        v11 = v7 + 1;
      }
      v34 = -1;
      if ( v10 == 42 )
      {
        ++v11;
        v12 = (unsigned int **)*a4++;
        v34 = (int)v12;
        v10 = *v11;
      }
      v13 = -1;
      if ( v10 == 46 )
      {
        if ( v11[1] != 42 )
          goto LABEL_52;
        v11 += 2;
        v13 = (size_t)*a4;
        v10 = *v11;
        ++a4;
      }
      if ( v10 == 108 || v10 == 90 )
        v10 = *++v11;
      if ( v10 == 115 )
      {
        v34 = (int)(a4 + 1);
        v26 = *a4;
        v40[v4].iov_base = v26;
        v19 = strlen(v26);
        if ( v13 == -1 )
        {
          v40[v4].iov_len = v19;
        }
        else
        {
          if ( v13 > v19 )
            v13 = v19;
          v40[v4].iov_len = v13;
        }
        ++v4;
        a4 = (unsigned int **)v34;
      }
      else if ( v10 > 115 )
      {
        if ( v10 != 117 && v10 != 120 )
LABEL_52:
          _assert_fail((int)v30 - 107578, (int)v30 - 107603, 216, (int)v30 - 107516);
        v32 = a4 + 1;
        v14 = v10 == 120;
        v15 = 16;
        if ( !v14 )
          v15 = 10;
        v16 = itoa((unsigned int)*a4, v25, v15, 0);
        v17 = (_BYTE *)(v25 - v16);
        if ( v34 != -1 && v34 > (int)v17 )
        {
          v31 = v11;
          v22 = v33;
          v23 = v34;
          do
          {
            *--v16 = v22;
            v17 = (_BYTE *)(v25 - v16);
          }
          while ( v25 - v16 < v23 );
          v11 = v31;
        }
        v40[v4].iov_base = v16;
        v18 = v32;
        v40[v4++].iov_len = (size_t)v17;
        a4 = v18;
      }
      else
      {
        if ( v10 != 37 )
          goto LABEL_52;
        v40[v4].iov_base = v11;
        v40[v4++].iov_len = 1;
      }
      v5 = v11 + 1;
LABEL_18:
      v6 = *v5;
      if ( !*v5 )
        return sys_writev(v29, v40, v4);
    }
    if ( v6 == 37 )
      goto LABEL_26;
LABEL_4:
    if ( !v6 )
      goto LABEL_26;
    if ( v6 != 10 || !v37 )
    {
      v7 = v5;
      do
        v6 = *++v7;
      while ( *v7 && v6 != 37 && (v6 != 10 || !v37) );
      if ( v4 > 63 )
      {
LABEL_71:
        v24 = v30;
        v28 = &_PRETTY_FUNCTION___10496[(_DWORD)v30 - 135061504];
        v27 = 120;
LABEL_70:
        _assert_fail(
          (int)&aNiovNiovmax[(_DWORD)v24 - 135061504],
          (int)&aDlMiscC[(_DWORD)v24 - 135061504],
          v27,
          (int)v28);
      }
      v40[v4].iov_len = v7 - v5;
      if ( v7 != v5 )
        v40[v4++].iov_base = v5;
      if ( v6 == 37 )
        goto LABEL_28;
      goto LABEL_16;
    }
    if ( v4 > 63 )
      goto LABEL_71;
    v40[v4].iov_len = 0;
    v7 = v5;
LABEL_43:
    v40[v4].iov_base = v5;
    v40[v4++].iov_len = 1;
    goto LABEL_22;
  }
  return sys_writev(v29, v40, v4);
}
// 80CE000: using guessed type _TBYTE GLOBAL_OFFSET_TABLE_;

//----- (08090C40) --------------------------------------------------------
unsigned int __cdecl dl_sysdep_read_whole_file(int a1, __off_t *a2, int a3)
{
  int v3; // eax
  int v5; // ebx
  __off_t st_size; // eax
  unsigned int v7; // esi
  struct stat v8; // [esp+8h] [ebp-6Ch] BYREF

  v3 = _open64_nocancel(a1, 0x80000);
  if ( v3 < 0 )
    return -1;
  v5 = v3;
  if ( (_fxstat64(3, v3, &v8) & 0x80000000) == 0 && (st_size = v8.st_size, *a2 = v8.st_size, st_size) )
    v7 = mmap(0, st_size, a3, 2, v5, 0);
  else
    v7 = -1;
  _close_nocancel(v5);
  return v7;
}

//----- (08090CD0) --------------------------------------------------------
int dl_debug_printf(_BYTE *a1, ...)
{
  va_list va; // [esp+8h] [ebp+8h] BYREF

  va_start(va, a1);
  return dl_debug_vdprintf(dl_debug_fd, 1, a1, (unsigned int **)va);
}

//----- (08090D10) --------------------------------------------------------
int dl_debug_printf_c(_BYTE *a1, ...)
{
  va_list va; // [esp+8h] [ebp+8h] BYREF

  va_start(va, a1);
  return dl_debug_vdprintf(dl_debug_fd, -1, a1, (unsigned int **)va);
}

//----- (08090D50) --------------------------------------------------------
int dl_dprintf(int a1, _BYTE *a2, ...)
{
  va_list va; // [esp+18h] [ebp+Ch] BYREF

  va_start(va, a2);
  return dl_debug_vdprintf(a1, 0, a2, (unsigned int **)va);
}

//----- (08090D80) --------------------------------------------------------
int __cdecl dl_name_match_p(char *a1, int a2)
{
  int v2; // ebx

  if ( !strcmp(a1, *(_BYTE **)(a2 + 4)) )
    return 1;
  v2 = *(_DWORD *)(a2 + 28);
  if ( v2 )
  {
    while ( strcmp(a1, *(_BYTE **)v2) )
    {
      v2 = *(_DWORD *)(v2 + 4);
      if ( !v2 )
        return 0;
    }
    return 1;
  }
  return 0;
}

//----- (08090DF0) --------------------------------------------------------
int __cdecl dl_higher_prime_number(unsigned int a1)
{
  const char *v1; // ecx
  const char *v2; // edx
  int v3; // eax
  const char *v4; // ebx
  int v5; // edx
  const char *v7; // eax

  v1 = "\a";
  v2 = "%s: cannot open file: %s\n";
  do
  {
    v3 = (int)(((v2 - v1) >> 2) + ((unsigned int)(v2 - v1) >> 31)) >> 1;
    v4 = &v1[4 * v3];
    if ( a1 <= *(_DWORD *)v4 )
    {
      while ( 1 )
      {
        if ( v1 == v4 )
          return *(_DWORD *)v4;
        v5 = (v4 - v1) >> 2;
        v7 = &v1[4 * ((int)(v5 + ((unsigned int)(v4 - v1) >> 31)) >> 1)];
        if ( *(_DWORD *)v7 < a1 )
          break;
        v4 = &v1[4 * ((int)(v5 + ((unsigned int)(v4 - v1) >> 31)) >> 1)];
      }
      v2 = v4;
    }
    else
    {
      v7 = &v1[4 * v3];
    }
    v1 = v7 + 4;
  }
  while ( v7 + 4 != v2 );
  return *(_DWORD *)v2;
}

//----- (08090E70) --------------------------------------------------------
int __cdecl dl_strtoul(_BYTE *a1, _DWORD *a2)
{
  _BYTE *v2; // ebp
  char v3; // al
  char *v4; // ebp
  int v5; // eax
  int v6; // ecx
  int v7; // edx
  int v8; // esi
  unsigned int v9; // edi
  int v10; // eax
  char v12; // [esp+27h] [ebp-1Dh]

  v2 = a1;
  v3 = *a1;
  if ( *a1 != 32 )
    goto LABEL_3;
  do
  {
    do
      v3 = *++v2;
    while ( *v2 == 32 );
LABEL_3:
    ;
  }
  while ( v3 == 9 );
  if ( v3 == 45 )
  {
    v4 = v2 + 1;
    v12 = 0;
  }
  else
  {
    v12 = 1;
    v4 = &v2[v3 == 43];
  }
  v5 = *v4;
  if ( (unsigned __int8)(v5 - 48) <= 9u )
  {
    v6 = 10;
    v7 = 9;
    if ( (_BYTE)v5 == 48 )
    {
      if ( (v4[1] & 0xDF) == 88 )
      {
        v5 = v4[2];
        v6 = 16;
        v4 += 2;
      }
      else
      {
        v6 = 8;
        v7 = 7;
      }
    }
    v8 = 0;
    v9 = 0;
    while ( 1 )
    {
      if ( (char)v5 <= 47 || (char)v5 > (unsigned int)(v7 + 48) )
      {
        if ( v6 != 16 )
          goto LABEL_21;
        if ( (unsigned __int8)(v5 - 97) > 5u )
        {
          if ( (unsigned __int8)(v5 - 65) > 5u )
          {
LABEL_21:
            if ( a2 )
              *a2 = v4;
            if ( !v12 )
              return -v8;
            return v8;
          }
          v10 = v5 - 55;
        }
        else
        {
          v10 = v5 - 87;
        }
      }
      else
      {
        v10 = (char)v5 - 48;
      }
      if ( __PAIR64__(v9, v8) >= ~(__int64)v10 / (unsigned __int64)v6 )
        break;
      v9 = (v10 + v6 * __PAIR64__(v9, v8)) >> 32;
      v8 = v10 + v6 * v8;
      v5 = *++v4;
    }
    v8 = -1;
    if ( a2 )
      goto LABEL_27;
    return v8;
  }
  v8 = 0;
  if ( !a2 )
    return v8;
LABEL_27:
  *a2 = v4;
  return v8;
}

//----- (08091060) --------------------------------------------------------
unsigned int dl_start_profile()
{
  int v0; // edx
  unsigned int v1; // eax
  unsigned int v2; // edx
  unsigned int v3; // ebx
  unsigned int v4; // edi
  int v5; // ecx
  unsigned int v6; // ebx
  int v7; // eax
  unsigned int v8; // ebx
  unsigned int *v9; // ebx
  char *v10; // edi
  int v11; // edx
  int *v12; // ecx
  __int16 v13; // dx
  int v14; // edx
  _BYTE *v15; // eax
  int v16; // ebx
  unsigned int *v17; // edi
  unsigned int v18; // ecx
  unsigned int v19; // eax
  unsigned __int8 *v20; // eax
  int v21; // ecx
  unsigned int v22; // edx
  int v23; // eax
  int v24; // eax
  int v25; // edx
  int v26; // ecx
  __int16 *v27; // ecx
  __int16 v28; // di
  unsigned int v29; // ebx
  int v30; // eax
  unsigned int v31; // ecx
  unsigned int v32; // edi
  unsigned int result; // eax
  unsigned int v34; // edx
  char *v35; // ebx
  signed int v36; // edi
  unsigned __int8 *v37; // eax
  void *v38; // esp
  unsigned int v39; // ecx
  unsigned __int8 *v40; // edx
  int v41; // ebx
  void *v42; // esp
  signed int v43; // eax
  unsigned int v44; // ecx
  _BYTE v45[4]; // [esp-2008h] [ebp-227Ch]
  unsigned __int8 v46[4088]; // [esp-2004h] [ebp-2278h] BYREF
  int v47; // [esp-100Ch] [ebp-1280h]
  int v48; // [esp-1008h] [ebp-127Ch]
  _BYTE v49[4096]; // [esp-1004h] [ebp-1278h] BYREF
  int v50; // [esp-4h] [ebp-278h] BYREF
  unsigned int v51; // [esp+0h] [ebp-274h]
  _BYTE *v52; // [esp+4h] [ebp-270h]
  unsigned __int8 *v53; // [esp+8h] [ebp-26Ch]
  char **v54; // [esp+Ch] [ebp-268h]
  unsigned int v55; // [esp+10h] [ebp-264h]
  unsigned int v56; // [esp+14h] [ebp-260h]
  unsigned int v57; // [esp+18h] [ebp-25Ch]
  unsigned int *v58; // [esp+1Ch] [ebp-258h]
  unsigned int v59; // [esp+20h] [ebp-254h]
  unsigned int v60; // [esp+24h] [ebp-250h]
  int v61; // [esp+28h] [ebp-24Ch]
  unsigned int v62; // [esp+38h] [ebp-23Ch] BYREF
  unsigned int v63; // [esp+3Ch] [ebp-238h]
  unsigned int v64; // [esp+40h] [ebp-234h]
  unsigned int v65; // [esp+44h] [ebp-230h]
  unsigned int v66; // [esp+48h] [ebp-22Ch]
  int v67; // [esp+4Ch] [ebp-228h] BYREF
  int v68; // [esp+50h] [ebp-224h]
  unsigned int v69; // [esp+54h] [ebp-220h]
  int v70; // [esp+58h] [ebp-21Ch]
  _DWORD v71[2]; // [esp+5Ch] [ebp-218h] BYREF
  unsigned int v72; // [esp+64h] [ebp-210h]
  unsigned int v73; // [esp+68h] [ebp-20Ch]
  struct stat v74; // [esp+6Ch] [ebp-208h] BYREF
  char v75[424]; // [esp+CCh] [ebp-1A8h] BYREF

  v0 = *(unsigned __int16 *)(dl_profile_map + 348);
  v1 = *(_DWORD *)(dl_profile_map + 340);
  v59 = dl_profile_map;
  v2 = v1 + 32 * v0;
  if ( v1 >= v2 )
  {
    v5 = 0;
    v3 = -1;
    v4 = 0;
    v61 = -1;
  }
  else
  {
    v60 = dl_pagesize - 1;
    v3 = -1;
    v61 = -dl_pagesize;
    v4 = 0;
    do
    {
      while ( *(_DWORD *)v1 != 1 || (*(_BYTE *)(v1 + 24) & 1) == 0 )
      {
        v1 += 32;
        if ( v1 >= v2 )
          goto LABEL_11;
      }
      if ( v3 > (*(_DWORD *)(v1 + 8) & (unsigned int)v61) )
        v3 = *(_DWORD *)(v1 + 8) & v61;
      if ( v4 < (v61 & (v60 + *(_DWORD *)(v1 + 20) + *(_DWORD *)(v1 + 8))) )
        v4 = v61 & (v60 + *(_DWORD *)(v1 + 20) + *(_DWORD *)(v1 + 8));
      v1 += 32;
    }
    while ( v1 < v2 );
LABEL_11:
    v61 = v3;
    v5 = v4;
  }
  running = 0;
  log_hashfraction = 4;
  v6 = (*(_DWORD *)v59 + v3) & 0xFFFFFFFC;
  v55 = (*(_DWORD *)v59 + v4 + 3) & 0xFFFFFFFC;
  v7 = v55 - v6;
  lowpc = v6;
  v8 = 3 * (v55 - v6);
  v60 = v7;
  textsize = v7;
  if ( (unsigned int)(3 * v7) > 0x1387 )
  {
    v34 = v8 / 0x64;
    if ( v8 <= 0x6400063 )
    {
      fromlimit = v8 / 0x64;
      v59 = 96 * v34 + 64;
      v56 = 8 * v34;
    }
    else
    {
      fromlimit = 0x100000;
      v56 = 0x800000;
      v59 = 100663360;
    }
  }
  else
  {
    fromlimit = 50;
    v56 = 400;
    v59 = 4864;
  }
  v68 = v5;
  v62 = 1852796263;
  v67 = v61;
  v63 = 0x1FFFF;
  v64 = 0;
  v65 = 0;
  v66 = 0;
  v69 = v60 >> 2;
  v73 = 1929379840;
  v70 = _profile_frequency();
  strcpy((char *)v71, "seconds");
  v9 = dl_profile_output;
  v72 = 0;
  v61 = strlen(dl_profile_output);
  v10 = dl_profile;
  v54 = &dl_profile;
  v11 = v61 + strlen((unsigned int *)dl_profile) + 37;
  v12 = (int *)((char *)&v50 - (v11 & 0xFFFFF000));
  v13 = v11 & 0xFFF0;
  if ( &v50 != v12 )
  {
    while ( v49 != (_BYTE *)v12 )
      ;
  }
  v14 = v13 & 0xFFF;
  if ( v14 )
  {
    v38 = alloca(v14);
    *(_DWORD *)&v49[v14 - 4] = *(_DWORD *)&v49[v14 - 4];
  }
  v58 = (unsigned int *)v49;
  v15 = stpcpy((int)v49, (int)v9);
  *v15 = 47;
  strcpy(stpcpy((int)(v15 + 1), (int)v10), ".profile");
  v47 = 438;
  v61 = _open64_nocancel((int)v58, 131138);
  if ( v61 == -1 )
  {
    v35 = "%s: cannot open file: %s\n";
    v36 = __readgsdword(0xFFFFFFE0);
LABEL_40:
    v37 = strerror_r(v36, v75, 0x190u);
    return dl_dprintf(2, v35, v58, v37);
  }
  if ( (_fxstat64(3, v61, &v74) & 0x80000000) != 0 || (v74.st_mode & 0xF000) != 0x8000 )
  {
    v35 = "%s: cannot stat file: %s\n";
    goto LABEL_42;
  }
  v57 = v60 >> 1;
  v59 += v60 >> 1;
  if ( !*(_QWORD *)&v74.st_size )
  {
    v52 = v49;
    v39 = dl_pagesize;
    v40 = &v49[-((dl_pagesize + 15) & 0xFFFFF000)];
    if ( v49 != v40 )
    {
      while ( v46 != v40 )
        ;
    }
    v41 = ((_WORD)dl_pagesize + 15) & 0xFF0;
    if ( (((_WORD)dl_pagesize + 15) & 0xFF0) != 0 )
    {
      v42 = alloca(v41);
      *(_DWORD *)&v45[v41] = *(_DWORD *)&v45[v41];
    }
    v53 = v46;
    v51 = v39;
    memset(v46, 0, v39);
    if ( lseek(v61, v59 & -v51, 0) != -1 )
    {
      while ( 1 )
      {
        v43 = _write_nocancel(v61, v53, v59 & (dl_pagesize - 1));
        if ( v43 != -1 )
          break;
        if ( __readgsdword(0xFFFFFFE0) != 4 )
          goto LABEL_61;
      }
      if ( v43 >= 0 )
        goto LABEL_23;
    }
LABEL_61:
    v35 = "%s: cannot create file: %s\n";
LABEL_42:
    v36 = __readgsdword(0xFFFFFFE0);
    _close_nocancel(v61);
    goto LABEL_40;
  }
  if ( v59 != *(_QWORD *)&v74.st_size )
  {
    _close_nocancel(v61);
    return dl_dprintf(2, "%s: file is no correct profile data file for `%s'\n", v58, *v54);
  }
LABEL_23:
  v16 = v61;
  v17 = (unsigned int *)mmap(0, v59, 3, 1, v61, 0);
  if ( v17 == (unsigned int *)-1 )
  {
    v35 = "%s: cannot map file: %s\n";
    goto LABEL_42;
  }
  _close_nocancel(v16);
  v53 = (unsigned __int8 *)(v17 + 14);
  v18 = (unsigned int)v17 + v57 + 60;
  narcsp = v18;
  data = (int)v17 + v57 + 64;
  if ( *(_QWORD *)&v74.st_size )
  {
    v61 = (int)v17 + v57 + 60;
    if ( !memcmp(v17, &v62, 20) && !v17[5] && !memcmp(v17 + 6, (unsigned int *)&v67, 32) )
    {
      v18 = v61;
      if ( *(_DWORD *)(v61 - 4) == 1 )
        goto LABEL_26;
    }
    munmap(v17, v59);
    return dl_dprintf(2, "%s: file is no correct profile data file for `%s'\n", v58, *v54);
  }
  v19 = v62;
  v17[5] = 0;
  *v17 = v19;
  v17[1] = v63;
  v17[2] = v64;
  v17[3] = v65;
  v17[4] = v66;
  v17[6] = v67;
  v17[7] = v68;
  v17[8] = v69;
  v17[9] = v70;
  v17[10] = v71[0];
  v17[11] = v71[1];
  v17[12] = v72;
  v17[13] = v73;
  *(_DWORD *)(v18 - 4) = 1;
LABEL_26:
  v58 = (unsigned int *)v18;
  v20 = calloc((int *)v17, v57 + v56, 1u);
  v21 = (int)v58;
  v61 = (int)v20;
  tos = (int)v20;
  if ( !v20 )
  {
    v48 = 0;
    v47 = 0;
    munmap(v17, v59);
    dl_dprintf(2, "Out of memory while initializing profiler\n");
    exit(127);
  }
  fromidx = 0;
  v22 = *v58;
  v59 = v57 + v61;
  froms = v57 + v61;
  v23 = fromlimit;
  if ( v22 < fromlimit )
    v23 = *v58;
  narcs = v23;
  if ( v23 )
  {
    v58 -= 2;
    v24 = v21 + 12 * v23 - 8;
    do
    {
      v25 = fromidx;
      v26 = *(_DWORD *)(v24 + 4) >> 2;
      ++fromidx;
      v27 = (__int16 *)(v61 + 2 * v26);
      v28 = *v27;
      v29 = v59 + 8 * v25;
      *(_DWORD *)v29 = v24;
      v24 -= 12;
      *(_WORD *)(v29 + 4) = v28;
      *v27 = v25;
    }
    while ( (unsigned int *)v24 != v58 );
  }
  v30 = 0x10000;
  v31 = v55 - lowpc;
  if ( v55 - lowpc > v57 )
  {
    v32 = v31 / v57;
    v30 = 1;
    if ( v31 / v57 <= 0xFFFF )
    {
      if ( v32 <= 0xFF )
      {
        if ( v31 <= 0xFFFFFF )
          v44 = (v31 << 8) / v57;
        else
          v44 = v31 / (v60 >> 9);
        v30 = 0x1000000 / v44;
      }
      else
      {
        v30 = 0x10000 / v32;
      }
    }
  }
  result = profil((int)v53, v57, lowpc, v30);
  running = 1;
  return result;
}
// 80CE9B0: using guessed type int dl_pagesize;
// 80CFA48: using guessed type int log_hashfraction;
// 80CFA4C: using guessed type int textsize;
// 80CFA50: using guessed type int lowpc;
// 80CFA54: using guessed type int fromidx;
// 80CFA58: using guessed type int fromlimit;
// 80CFA5C: using guessed type int froms;
// 80CFA60: using guessed type int tos;
// 80CFA64: using guessed type int narcsp;
// 80CFA68: using guessed type int narcs;
// 80CFA6C: using guessed type int running;
// 80CFA70: using guessed type int data;
// 80CFEFC: using guessed type unsigned int *dl_profile_output;
// 80CFF0C: using guessed type char *dl_profile;
// 8091060: using guessed type char var_1A8[424];

//----- (080918B0) --------------------------------------------------------
_TBYTE *__cdecl dl_mcount(int a1, int a2)
{
  _TBYTE *result; // eax
  int v3; // ebx
  _WORD *v4; // edi
  int v5; // edx
  int v6; // ecx
  _DWORD *v7; // esi
  int v8; // edx
  int v9; // edx
  int v10; // edi
  int v11; // ebx
  int v12; // ebp
  int v13; // ecx
  int v14; // edx
  int v15; // esi
  _WORD *v16; // ecx
  unsigned int v17; // ecx
  __int16 v18; // dx
  int v19; // esi
  int v20; // esi
  int *v21; // edx
  int v22; // [esp+0h] [ebp-34h]
  _DWORD *v23; // [esp+4h] [ebp-30h]
  _WORD *v24; // [esp+8h] [ebp-2Ch]
  int v25; // [esp+Ch] [ebp-28h]
  int v26; // [esp+10h] [ebp-24h]

  result = &GLOBAL_OFFSET_TABLE_;
  if ( running )
  {
    v3 = a1 - lowpc;
    if ( textsize <= (unsigned int)(a1 - lowpc) )
      v3 = 0;
    v25 = a2 - lowpc;
    if ( textsize > (unsigned int)(a2 - lowpc) )
    {
      v22 = tos;
      v4 = (_WORD *)(tos + 2 * ((unsigned int)(a2 - lowpc) >> log_hashfraction));
      v5 = (unsigned __int16)*v4;
      v24 = v4;
      if ( !*v4 )
        goto LABEL_10;
      while ( 1 )
      {
        v6 = froms + 8 * v5;
        v7 = *(_DWORD **)v6;
        if ( **(_DWORD **)v6 == v3 )
          goto LABEL_29;
        v8 = *(unsigned __int16 *)(v6 + 4);
        if ( (_WORD)v8 )
        {
          do
          {
            v6 = froms + 8 * v8;
            v8 = *(unsigned __int16 *)(v6 + 4);
            v7 = *(_DWORD **)v6;
          }
          while ( (_WORD)v8 && *v7 != v3 );
        }
        if ( *v7 == v3 )
          goto LABEL_29;
        v24 = (_WORD *)(v6 + 4);
LABEL_10:
        v9 = narcs;
        v23 = (_DWORD *)narcsp;
        if ( narcs != *(_DWORD *)narcsp && fromlimit > (unsigned int)narcs )
        {
          v10 = froms;
          v26 = v3;
          v11 = data;
          do
          {
            v12 = v11 + 12 * v9;
            v13 = *(_DWORD *)(v12 + 4) >> 2;
            if ( __readgsdword(0xCu) )
              __asm { lock }
            v14 = fromidx++;
            ++v14;
            v15 = v10 + 8 * v14;
            *(_DWORD *)v15 = v12;
            v16 = (_WORD *)(v22 + 2 * v13);
            *(_WORD *)(v15 + 4) = *v16;
            *v16 = v14;
            if ( __readgsdword(0xCu) )
              __asm { lock }
            v9 = ++narcs;
          }
          while ( *v23 != narcs && narcs < (unsigned int)fromlimit );
          v3 = v26;
        }
        if ( !*v24 )
          break;
        v5 = (unsigned __int16)*v24;
      }
      if ( __readgsdword(0xCu) )
        __asm { lock }
      v17 = (*v23)++;
      if ( v17 < fromlimit )
      {
        if ( __readgsdword(0xCu) )
          __asm { lock }
        v18 = fromidx++;
        v19 = froms;
        *v24 = v18 + 1;
        v20 = v19 + 8 * (unsigned __int16)*v24;
        v21 = (int *)(data + 12 * v17);
        *(_DWORD *)v20 = v21;
        *v21 = v3;
        v21[2] = 0;
        v21[1] = v25;
        *(_WORD *)(v20 + 4) = 0;
        if ( __readgsdword(0xCu) )
          __asm { lock }
        ++narcs;
        v7 = *(_DWORD **)v20;
LABEL_29:
        if ( __readgsdword(0xCu) )
          __asm { lock }
        ++v7[2];
      }
    }
  }
  return result;
}
// 80CE000: using guessed type _TBYTE GLOBAL_OFFSET_TABLE_;
// 80CFA48: using guessed type int log_hashfraction;
// 80CFA4C: using guessed type int textsize;
// 80CFA50: using guessed type int lowpc;
// 80CFA54: using guessed type int fromidx;
// 80CFA58: using guessed type int fromlimit;
// 80CFA5C: using guessed type int froms;
// 80CFA60: using guessed type int tos;
// 80CFA64: using guessed type int narcsp;
// 80CFA68: using guessed type int narcs;
// 80CFA6C: using guessed type int running;
// 80CFA70: using guessed type int data;

//----- (08091B00) --------------------------------------------------------
unsigned __int8 *__usercall allocate_dtv@<eax>(int *a1@<eax>)
{
  int v2; // esi
  unsigned __int8 *result; // eax

  v2 = dl_tls_max_dtv_idx + 14;
  result = calloc(a1, dl_tls_max_dtv_idx + 16, 8u);
  if ( result )
  {
    *(_DWORD *)result = v2;
    a1[1] = (int)(result + 8);
    return (unsigned __int8 *)a1;
  }
  return result;
}

//----- (08091B40) --------------------------------------------------------
void __noreturn oom()
{
  dl_dprintf(2, "cannot allocate memory for thread-local data: ABORT\n");
  exit(127);
}

//----- (08091B70) --------------------------------------------------------
unsigned int dl_next_tls_modid()
{
  unsigned int result; // eax
  int v1; // edi
  unsigned int *v2; // edx
  unsigned int i; // ebp

  if ( !dl_tls_dtv_gaps )
  {
    result = dl_tls_max_dtv_idx + 1;
LABEL_3:
    dl_tls_max_dtv_idx = result;
    return result;
  }
  result = dl_tls_static_nelem + 1;
  if ( (unsigned int)(dl_tls_static_nelem + 1) > dl_tls_max_dtv_idx )
    goto LABEL_14;
  v1 = 0;
  v2 = dl_tls_dtv_slotinfo_list;
  for ( i = *dl_tls_dtv_slotinfo_list; ; i = *v2 )
  {
    while ( result - v1 < i )
    {
      if ( !v2[2 * (result - v1) + 3] )
        goto LABEL_13;
      if ( dl_tls_max_dtv_idx + 1 < ++result )
        _assert_fail((int)"result <= GL(dl_tls_max_dtv_idx) + 1", (int)"dl-tls.c", 73, (int)"_dl_next_tls_modid");
    }
    v2 = (unsigned int *)v2[1];
    v1 += i;
    if ( !v2 )
      break;
  }
LABEL_13:
  if ( result > dl_tls_max_dtv_idx )
  {
LABEL_14:
    if ( dl_tls_max_dtv_idx + 1 != result )
      _assert_fail((int)"result == GL(dl_tls_max_dtv_idx) + 1", (int)"dl-tls.c", 87, (int)"_dl_next_tls_modid");
    dl_tls_dtv_gaps = 0;
    goto LABEL_3;
  }
  return result;
}
// 80CFEC0: using guessed type _DWORD *dl_tls_dtv_slotinfo_list;

//----- (08091C70) --------------------------------------------------------
int dl_count_modids()
{
  int result; // eax
  _DWORD *v1; // ecx
  int v2; // edx

  if ( !dl_tls_dtv_gaps )
    return dl_tls_max_dtv_idx;
  v1 = dl_tls_dtv_slotinfo_list;
  for ( result = 0; v1; v1 = (_DWORD *)v1[1] )
  {
    v2 = 0;
    if ( *v1 )
    {
      do
        result -= (v1[2 * v2++ + 3] == 0) - 1;
      while ( v2 != *v1 );
    }
  }
  return result;
}
// 80CFEC0: using guessed type _DWORD *dl_tls_dtv_slotinfo_list;

//----- (08091CE0) --------------------------------------------------------
_DWORD *__cdecl dl_get_tls_static_info(_DWORD *a1, _DWORD *a2)
{
  _DWORD *result; // eax

  *a1 = dl_tls_static_size;
  result = a2;
  *a2 = dl_tls_static_align;
  return result;
}
// 80CE024: using guessed type int dl_tls_static_size;

//----- (08091D10) --------------------------------------------------------
unsigned __int8 *dl_allocate_tls_storage()
{
  int v0; // ebp
  unsigned int v1; // edi
  int *v2; // eax
  int v3; // esi
  int *v4; // edx
  _BYTE *v5; // edi
  unsigned int v6; // ecx
  int *v7; // edi
  unsigned __int8 *result; // eax

  v0 = dl_tls_static_size;
  v1 = dl_tls_static_align;
  v2 = malloc((const struct timespec *)(dl_tls_static_size + dl_tls_static_align + 4));
  if ( !v2 )
    return 0;
  v3 = (int)v2;
  v4 = (int *)(v0 + v1 * (((unsigned int)v2 + v1 - 1) / v1) - 1216);
  *v4 = 0;
  v4[303] = 0;
  v5 = (_BYTE *)((unsigned int)(v4 + 1) & 0xFFFFFFFC);
  v6 = (unsigned int)((char *)v4 - v5 + 1216) >> 2;
  memset(v5, 0, 4 * v6);
  v7 = (int *)&v5[4 * v6];
  v4[304] = (int)v2;
  result = allocate_dtv(v4);
  if ( !result )
  {
    free(v0, v7, v3);
    return 0;
  }
  return result;
}
// 80CE024: using guessed type int dl_tls_static_size;

//----- (08091DD0) --------------------------------------------------------
int __cdecl dl_allocate_tls_init(int a1)
{
  unsigned int v1; // eax
  unsigned int v2; // esi
  unsigned int v3; // ebx
  unsigned int v4; // eax
  unsigned int v5; // edx
  unsigned int v6; // ecx
  int v7; // edi
  unsigned int *v8; // edx
  unsigned int v9; // edi
  unsigned int v10; // ebp
  unsigned __int8 *v11; // eax
  int v13; // ebp
  int *v14; // esi
  unsigned int v15; // edi
  int *v16; // eax
  unsigned int *v17; // [esp+0h] [ebp-38h]
  int v18; // [esp+0h] [ebp-38h]
  unsigned int v19; // [esp+4h] [ebp-34h]
  int v20; // [esp+Ch] [ebp-2Ch]
  unsigned int *v21; // [esp+14h] [ebp-24h]

  if ( !a1 )
    return a1;
  v1 = dl_tls_max_dtv_idx;
  v21 = *(unsigned int **)(a1 + 4);
  if ( *(v21 - 2) < dl_tls_max_dtv_idx )
  {
    v18 = dl_tls_max_dtv_idx + 14;
    v13 = *(v21 - 2);
    if ( v21 == &dl_static_dtv[2] )
    {
      v16 = malloc((const struct timespec *)(8 * dl_tls_max_dtv_idx + 128));
      v14 = v16;
      if ( v16 )
      {
        v15 = 8 * v13 + 16;
        memcpy(v16, dl_static_dtv, v15);
        goto LABEL_25;
      }
    }
    else
    {
      v14 = realloc(v13, (_BYTE *)v21 - 8, (const struct timespec *)(8 * dl_tls_max_dtv_idx + 128));
      if ( v14 )
      {
        v15 = 8 * v13 + 16;
LABEL_25:
        *v14 = v18;
        memset((unsigned __int8 *)v14 + v15, 0, 8 * (v18 - v13));
        v21 = (unsigned int *)(v14 + 2);
        *(_DWORD *)(a1 + 4) = v14 + 2;
        v1 = dl_tls_max_dtv_idx;
        goto LABEL_3;
      }
    }
    oom();
  }
LABEL_3:
  v19 = 0;
  v20 = 0;
  v17 = dl_tls_dtv_slotinfo_list;
  while ( 1 )
  {
    v2 = v20 == 0;
    v3 = v20 + v2;
    if ( v2 < *v17 )
      break;
LABEL_19:
    v20 = v3;
    if ( v1 <= v3 )
      goto LABEL_17;
    v17 = (unsigned int *)v17[1];
    if ( !v17 )
      _assert_fail(
        (int)&GLOBAL_OFFSET_TABLE_ - 106732,
        (int)&GLOBAL_OFFSET_TABLE_ - 106741,
        517,
        (int)&GLOBAL_OFFSET_TABLE_ - 106784);
  }
  while ( v3 <= v1 )
  {
    v4 = v17[2 * v2 + 3];
    if ( v4 )
    {
      v5 = v17[2 * v2 + 2];
      if ( v5 > dl_tls_generation )
        _assert_fail(
          (int)&GLOBAL_OFFSET_TABLE_ - 107028,
          (int)&GLOBAL_OFFSET_TABLE_ - 106741,
          481,
          (int)&GLOBAL_OFFSET_TABLE_ - 106784);
      v6 = *(int *)((char *)&dword_80CE244 + v4 - 135061504);
      if ( v19 >= v5 )
        v5 = v19;
      v7 = *(int *)((char *)&dword_80CE248 + v4 - 135061504);
      v19 = v5;
      v8 = &v21[2 * v7];
      *v8 = -1;
      v8[1] = 0;
      if ( v6 + 1 > 1 )
      {
        if ( v7 != v3 )
          _assert_fail(
            (int)&GLOBAL_OFFSET_TABLE_ - 106976,
            (int)&GLOBAL_OFFSET_TABLE_ - 106741,
            491,
            (int)&GLOBAL_OFFSET_TABLE_ - 106784);
        v9 = *(int *)((char *)&dword_80CE238 + v4 - 135061504);
        v10 = *(int *)((char *)&dword_80CE234 + v4 - 135061504);
        if ( v9 < v10 )
          _assert_fail(
            (int)&GLOBAL_OFFSET_TABLE_ - 106944,
            (int)&GLOBAL_OFFSET_TABLE_ - 106741,
            492,
            (int)&GLOBAL_OFFSET_TABLE_ - 106784);
        if ( v6 < v9 )
          _assert_fail(
            (int)&GLOBAL_OFFSET_TABLE_ - 106892,
            (int)&GLOBAL_OFFSET_TABLE_ - 106741,
            494,
            (int)&GLOBAL_OFFSET_TABLE_ - 106784);
        *v8 = a1 - v6;
        v11 = (unsigned __int8 *)mempcpy((_BYTE *)(a1 - v6), *(_BYTE **)((char *)&dword_80CE230 + v4 - 135061504), v10);
        memset(v11, 0, v9 - v10);
      }
    }
    ++v2;
    v3 = v20 + v2;
    v1 = dl_tls_max_dtv_idx;
    if ( *v17 <= v2 )
      goto LABEL_19;
  }
LABEL_17:
  *v21 = v19;
  return a1;
}
// 80CE000: using guessed type _TBYTE GLOBAL_OFFSET_TABLE_;
// 80CE230: using guessed type int dword_80CE230;
// 80CE234: using guessed type int dword_80CE234;
// 80CE238: using guessed type int dword_80CE238;
// 80CE244: using guessed type int dword_80CE244;
// 80CE248: using guessed type int dword_80CE248;
// 80CFCC0: using guessed type _DWORD dl_static_dtv[128];
// 80CFEC0: using guessed type _DWORD *dl_tls_dtv_slotinfo_list;

//----- (08092100) --------------------------------------------------------
int __cdecl dl_allocate_tls(int *a1)
{
  unsigned __int8 *dtv; // eax

  if ( a1 )
    dtv = allocate_dtv(a1);
  else
    dtv = dl_allocate_tls_storage();
  return dl_allocate_tls_init((int)dtv);
}

//----- (08092140) --------------------------------------------------------
int *__cdecl dl_deallocate_tls(int a1, int a2)
{
  int *v2; // edi
  unsigned int v3; // esi
  int *result; // eax

  v2 = *(int **)(a1 + 4);
  if ( *(v2 - 2) )
  {
    v3 = 0;
    do
    {
      ++v3;
      free(a2, v2, v2[2 * v3 + 1]);
    }
    while ( v3 < *(v2 - 2) );
  }
  if ( v2 != &dl_static_dtv[2] )
    free(a2, v2, (int)(v2 - 2));
  result = (int *)a2;
  if ( (_BYTE)a2 )
    return free(a2, v2, *(_DWORD *)(a1 + 1216));
  return result;
}
// 80CFCC0: using guessed type _DWORD dl_static_dtv[128];

//----- (080921E0) --------------------------------------------------------
int __cdecl dl_tls_get_addr_soft(int a1)
{
  unsigned int v1; // eax
  _DWORD *v2; // edx
  int result; // eax
  unsigned int v4; // ebx
  unsigned int *v5; // ecx
  unsigned int v6; // esi

  v1 = *(_DWORD *)(a1 + 584);
  if ( !v1 )
    return 0;
  v2 = (_DWORD *)__readgsdword(4u);
  if ( *v2 != dl_tls_generation )
  {
    if ( v1 >= *(v2 - 2) )
      return 0;
    v4 = *(_DWORD *)(a1 + 584);
    v5 = dl_tls_dtv_slotinfo_list;
    v6 = *dl_tls_dtv_slotinfo_list;
    if ( v1 >= *dl_tls_dtv_slotinfo_list )
    {
      do
      {
        v5 = (unsigned int *)v5[1];
        v4 -= v6;
        v6 = *v5;
      }
      while ( *v5 <= v4 );
    }
    if ( *v2 < v5[2 * v4 + 2] )
      return 0;
  }
  result = v2[2 * v1];
  if ( result == -1 )
    return 0;
  return result;
}
// 80CFEC0: using guessed type _DWORD *dl_tls_dtv_slotinfo_list;

//----- (08092260) --------------------------------------------------------
unsigned int *__cdecl dl_add_to_slotinfo(unsigned int a1)
{
  unsigned int v1; // esi
  int *i; // edi
  int v3; // edx
  unsigned int *result; // eax
  int *v5; // ebp

  v1 = *(_DWORD *)(a1 + 584);
  for ( i = dl_tls_dtv_slotinfo_list; ; i = (int *)i[1] )
  {
    if ( *i > v1 )
    {
      v3 = dl_tls_generation + 1;
      goto LABEL_6;
    }
    v1 -= *i;
    if ( !i[1] )
      break;
  }
  if ( v1 )
    _assert_fail((int)"idx == 0", (int)"dl-tls.c", 914, (int)"_dl_add_to_slotinfo");
  v5 = malloc((const struct timespec *)0x1F8);
  i[1] = (int)v5;
  v3 = dl_tls_generation + 1;
  if ( !v5 )
  {
    ++dl_tls_generation;
    dl_signal_error(12, (unsigned int *)"dlopen", 0, (unsigned int *)"cannot create TLS data structures");
  }
  *v5 = 62;
  v5[1] = 0;
  memset(v5 + 2, 0, 0x1F0u);
  i = v5;
LABEL_6:
  result = (unsigned int *)&i[2 * v1];
  result[2] = v3;
  result[3] = a1;
  return result;
}
// 80CFEC0: using guessed type _DWORD *dl_tls_dtv_slotinfo_list;

//----- (08092350) --------------------------------------------------------
int dl_get_origin()
{
  int v0; // eax
  _BYTE *v1; // ecx
  int v2; // edi
  int *v3; // ebp
  unsigned int *v4; // edi
  int *v5; // eax
  int *v6; // ebp
  _WORD *v7; // eax
  int *v9; // eax
  int *v10; // ebp
  _BYTE *v11; // [esp+1Ch] [ebp-1020h]
  char v12[12]; // [esp+20h] [ebp-101Ch] BYREF

  v0 = ((int (__fastcall *)(char *, int))__readgsdword(0x10u))(v12, 4096);
  if ( v0 > 0 && v12[0] != 91 )
  {
    if ( v12[0] != 47 )
      _assert_fail((int)"linkval[0] == '/'", (int)"../sysdeps/unix/sysv/linux/dl-origin.c", 47, (int)"_dl_get_origin");
    if ( v0 != 1 )
    {
      v2 = v0 - 1;
      if ( v12[v0 - 1] == 47 )
      {
        v2 = v0;
LABEL_21:
        v11 = v1;
        v9 = malloc((const struct timespec *)(v2 + 1));
        v10 = v9;
        if ( v9 )
        {
          *(_BYTE *)mempcpy(v9, v11, v2 - 1) = 0;
          return (int)v10;
        }
        return -1;
      }
      while ( v2 != 1 )
      {
        if ( v1[v2 - 1] == 47 )
          goto LABEL_21;
        --v2;
      }
    }
    v3 = malloc((const struct timespec *)2);
    if ( v3 )
    {
      *(_WORD *)v3 = 47;
      return (int)v3;
    }
    return -1;
  }
  v4 = dl_origin_path;
  if ( !dl_origin_path )
    return -1;
  v11 = (_BYTE *)strlen(dl_origin_path);
  v5 = malloc((const struct timespec *)(v11 + 1));
  v6 = v5;
  if ( !v5 )
    return -1;
  v7 = mempcpy(v5, v4, (unsigned int)v11);
  if ( (char *)v6 + 1 < (char *)v7 )
  {
    do
    {
      if ( *((_BYTE *)v7 - 1) != 47 )
        break;
      v7 = (_WORD *)((char *)v7 - 1);
    }
    while ( (_WORD *)((char *)v6 + 1) != v7 );
  }
  *(_BYTE *)v7 = 0;
  return (int)v6;
}
// 80923C0: variable 'v1' is possibly undefined
// 80CFF38: using guessed type unsigned int *dl_origin_path;
// 8092350: using guessed type char var_101C[12];

//----- (080924E0) --------------------------------------------------------
unsigned int __usercall dl_scope_free@<eax>(int ebp0@<ebp>, int *a2@<edi>, int a3)
{
  unsigned int v3; // esi
  int *v5; // esi
  int v6; // eax
  int i; // eax
  int v8; // eax
  int *v9; // eax

  v3 = __readgsdword(0xCu);
  if ( v3 )
  {
    v5 = dl_scope_free_list;
    if ( dl_scope_free_list )
    {
      v6 = *dl_scope_free_list;
      if ( *dl_scope_free_list > 0x31u )
      {
        dl_wait_lookup_done();
        for ( i = *v5; *v5; i = *v5 )
        {
          v8 = i - 1;
          *v5 = v8;
          free(ebp0, (int *)&dl_scope_free_list, v5[v8 + 1]);
        }
        return 1;
      }
      else
      {
        *dl_scope_free_list = v6 + 1;
        v5[v6 + 1] = a3;
        return 0;
      }
    }
    else
    {
      v9 = malloc((const struct timespec *)0xCC);
      dl_scope_free_list = v9;
      if ( v9 )
      {
        *v9 = 1;
        v3 = 0;
        v9[1] = a3;
      }
      else
      {
        v3 = 1;
        dl_wait_lookup_done();
        free(ebp0, (int *)&dl_scope_free_list, a3);
      }
    }
  }
  else
  {
    free(ebp0, a2, a3);
  }
  return v3;
}
// 80CFF08: using guessed type int (*dl_wait_lookup_done)(void);
// 80CFF34: using guessed type _DWORD *dl_scope_free_list;

//----- (080925D0) --------------------------------------------------------
unsigned int __cdecl dl_make_stack_executable(_DWORD *a1)
{
  unsigned int result; // eax

  result = mprotect((const void *)(*a1 & -dl_pagesize), dl_pagesize, _stack_prot);
  if ( result )
    return __readgsdword(0xFFFFFFE0);
  *a1 = 0;
  dl_stack_flags |= 1u;
  return result;
}
// 80CDFD0: using guessed type int _stack_prot;
// 80CE9A0: using guessed type int dl_stack_flags;
// 80CE9B0: using guessed type int dl_pagesize;

//----- (08092630) --------------------------------------------------------
void __stdcall dl_runtime_resolve(int a1, int a2, int a3)
{
  int retaddr; // [esp+8h] [ebp+0h]

  dl_fixup(retaddr, a1);
}

//----- (08092660) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
int __cdecl dl_runtime_resolve_shstk(int a1)
{
  int (*v1)(void); // eax
  int v3; // [esp+0h] [ebp-8h]
  int v4; // [esp+4h] [ebp-4h]

  v1 = dl_fixup(v3, v4);
  return v1();
}
// 809267F: positive sp value 8 has been found
// 809266E: variable 'v3' is possibly undefined
// 809266E: variable 'v4' is possibly undefined

//----- (08092690) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
int __usercall dl_runtime_profile_shstk@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>, int a4, int a5)
{
  int (*v5)(void); // eax
  int v7; // [esp-4h] [ebp-20h] BYREF
  int v8[4]; // [esp+0h] [ebp-1Ch] BYREF
  int v9; // [esp+10h] [ebp-Ch]
  int v10; // [esp+14h] [ebp-8h]
  unsigned int v11; // [esp+18h] [ebp-4h]
  int retaddr; // [esp+1Ch] [ebp+0h]

  v9 += 8;
  v8[2] = a1;
  v8[1] = a3;
  v8[0] = a2;
  v7 = -1;
  v5 = dl_profile_fixup(v10, v11, retaddr, (int)v8, &v7);
  if ( v7 >= 0 )
    JUMPOUT(0x8092729);
  return v5();
}
// 80926D7: positive sp value 8 has been found
// 80926C8: control flows out of bounds to 8092729

//----- (080926E0) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __userpurge dl_runtime_profile(
        unsigned int a1@<edx>,
        unsigned int a2@<ecx>,
        long double a3@<st1>,
        long double a4@<st0>,
        __int64 _XMM0_8@<xmm0>,
        __int64 _XMM1_8@<xmm1>,
        int a7@<eax>,
        int a8,
        int a9,
        char a10,
        int a11,
        int a12)
{
  int (*v12)(void); // eax
  __int64 v15; // [esp-8h] [ebp-4Ch] BYREF
  long double v16; // [esp+0h] [ebp-44h]
  long double v17; // [esp+Ch] [ebp-38h]
  __int64 v18; // [esp+18h] [ebp-2Ch] BYREF
  __int64 v19; // [esp+20h] [ebp-24h] BYREF
  unsigned __int64 v20; // [esp+28h] [ebp-1Ch] BYREF
  int v21; // [esp+30h] [ebp-14h]
  int v22; // [esp+38h] [ebp-Ch]
  int v23; // [esp+3Ch] [ebp-8h]
  unsigned int v24; // [esp+40h] [ebp-4h]
  int retaddr; // [esp+44h] [ebp+0h]

  v22 += 8;
  v21 = a7;
  v20 = __PAIR64__(a2, a1);
  HIDWORD(v19) = -1;
  v12 = dl_profile_fixup(v23, v24, retaddr, (int)&v20, (_DWORD *)&v19 + 1);
  if ( v19 >= 0 )
  {
    qmemcpy((char *)&v18 - (HIDWORD(v19) & 0xFFFFFFF8 | 4) + 4, &a8, 4 * (HIDWORD(v19) >> 2));
    v15 = ((__int64 (__fastcall *)(_DWORD, _DWORD, int (*)(void)))v12)(HIDWORD(v20), v20, v12);
    v16 = a3;
    v17 = a4;
    __asm
    {
      bndmov  [esp+44h+var_24], bnd0
      bndmov  [esp+44h+var_1C], bnd1
    }
    dl_call_pltexit((int)&v15);
    __asm
    {
      bndmov  bnd0, [esp+44h+var_24]
      bndmov  bnd1, [esp+44h+var_1C]
    }
  }
  else
  {
    HIDWORD(v20) = v12;
  }
}
// 80927AF: positive sp value 8 has been found
// 80926E0: unsupported processor register 'bnd0'

//----- (080927C0) --------------------------------------------------------
void __noreturn length_mismatch()
{
  dl_dprintf(2, "Fatal error: length accounting in _dl_exception_create_format\n");
  exit(127);
}

//----- (080927F0) --------------------------------------------------------
const char *__cdecl dl_exception_create(const char **a1, unsigned int *a2, unsigned int *a3)
{
  unsigned int v3; // edi
  unsigned int v4; // ebp
  int *v5; // eax
  _WORD *v6; // eax
  const char *result; // eax
  const char *v8; // [esp+1Ch] [ebp-20h]

  if ( a2 )
  {
    v3 = strlen(a2) + 1;
  }
  else
  {
    v3 = 1;
    a2 = (unsigned int *)byte_80B41F9;
  }
  v4 = strlen(a3) + 1;
  v5 = malloc((const struct timespec *)(v4 + v3));
  if ( v5 )
  {
    v8 = (const char *)v5;
    v6 = mempcpy(v5, a3, v4);
    result = memcpy(v6, a2, v3);
    *a1 = result;
    a1[1] = v8;
    a1[2] = v8;
  }
  else
  {
    a1[2] = 0;
    *a1 = (const char *)byte_80B41F9;
    result = "out of memory";
    a1[1] = "out of memory";
  }
  return result;
}
// 80B41F9: using guessed type unsigned __int8 byte_80B41F9[1671];

//----- (080928D0) --------------------------------------------------------
_BYTE *__cdecl dl_exception_create_format(_DWORD *a1, unsigned int *a2, _BYTE *a3, char a4)
{
  _BYTE *v4; // edi
  int v5; // eax
  int v6; // ebp
  char v7; // dl
  char *v8; // esi
  _BYTE *v9; // ebx
  char v10; // al
  _BYTE *v11; // ebx
  _BYTE *v12; // ebp
  char v13; // dl
  unsigned int **v14; // eax
  _BYTE *v15; // esi
  char v16; // dl
  _BYTE *v17; // ebx
  _BYTE *result; // eax
  unsigned int **v19; // eax
  int v20; // eax
  unsigned int *v21; // edi
  unsigned int v22; // eax
  char v23; // [esp+10h] [ebp-2Ch]
  unsigned int **v24; // [esp+10h] [ebp-2Ch]
  unsigned int v25; // [esp+1Ch] [ebp-20h]

  v4 = a3;
  if ( a2 )
  {
    v5 = strlen(a2);
    v6 = v5 + 2;
    v25 = v5 + 1;
  }
  else
  {
    v6 = 2;
    v25 = 1;
    a2 = (unsigned int *)byte_80B41F9;
  }
  v7 = *a3;
  v8 = &a4;
  if ( !*a3 )
  {
LABEL_11:
    v11 = malloc((const struct timespec *)v6);
    if ( !v11 )
      goto LABEL_25;
    v12 = &v11[v6];
    a1[1] = v11;
    a1[2] = v11;
    v13 = *a3;
    v14 = (unsigned int **)&a4;
    if ( !*a3 )
    {
LABEL_21:
      if ( v12 == v11 || (*v11 = 0, v17 = v11 + 1, v12 - v17 != v25) )
LABEL_30:
        length_mismatch();
      result = memcpy(v17, a2, v25);
      *a1 = result;
      return result;
    }
    while ( v13 == 37 )
    {
      v16 = v4[1];
      v15 = v4 + 1;
      if ( v16 == 37 )
      {
        if ( v12 == v11 )
          goto LABEL_30;
        v13 = v4[2];
        *v11 = 37;
        v4 += 2;
        ++v11;
        if ( !v13 )
          goto LABEL_21;
      }
      else
      {
        if ( v16 != 115 )
        {
          dl_dprintf(2, "Fatal error: invalid format in exception string\n");
          exit(127);
        }
        v21 = *v14;
        v24 = v14 + 1;
        v22 = strlen(*v14);
        if ( v12 - v11 < v22 )
          goto LABEL_30;
        v11 = mempcpy(v11, v21, v22);
        v14 = v24;
LABEL_16:
        v13 = v15[1];
        v4 = v15 + 1;
        if ( !v13 )
          goto LABEL_21;
      }
    }
    if ( v12 == v11 )
      goto LABEL_30;
    *v11 = v13;
    v15 = v4;
    ++v11;
    goto LABEL_16;
  }
  v9 = a3;
  do
  {
    while ( 1 )
    {
      v10 = v9[1];
      if ( v7 == 37 )
        break;
      ++v6;
      ++v9;
      v7 = v10;
LABEL_6:
      if ( !v7 )
        goto LABEL_10;
    }
    v7 = v9[2];
    v9 += 2;
    if ( v10 == 115 )
    {
      v19 = (unsigned int **)v8;
      v23 = v7;
      v8 += 4;
      v20 = strlen(*v19);
      v7 = v23;
      v6 += v20;
      goto LABEL_6;
    }
    ++v6;
  }
  while ( v7 );
LABEL_10:
  if ( v6 >= 0 )
    goto LABEL_11;
LABEL_25:
  a1[2] = 0;
  *a1 = (char *)&GLOBAL_OFFSET_TABLE_ - 105991;
  result = (char *)&GLOBAL_OFFSET_TABLE_ - 106496;
  a1[1] = (char *)&GLOBAL_OFFSET_TABLE_ - 106496;
  return result;
}
// 80B41F9: using guessed type unsigned __int8 byte_80B41F9[1671];
// 80CE000: using guessed type _TBYTE GLOBAL_OFFSET_TABLE_;

//----- (08092B10) --------------------------------------------------------
int *__usercall dl_exception_free@<eax>(int ebp0@<ebp>, int *a2@<edi>, _DWORD *a3)
{
  int *result; // eax

  result = free(ebp0, a2, a3[2]);
  *a3 = 0;
  a3[1] = 0;
  a3[2] = 0;
  return result;
}

//----- (08092B50) --------------------------------------------------------
int __cdecl dl_cache_libcmp(char *a1, char *a2)
{
  int v3; // eax
  int v4; // edx
  unsigned __int8 v5; // cl
  int v7; // ebp
  int v8; // edx
  int v9; // eax
  char *v10; // ecx
  int i; // edx

  while ( 1 )
  {
    v3 = *a1;
    v4 = *a2;
    if ( !(_BYTE)v3 )
      return -(char)v4;
    while ( 1 )
    {
      v5 = v4 - 48;
      if ( (unsigned __int8)(v3 - 48) <= 9u )
        break;
      if ( v5 <= 9u )
        return -1;
      if ( (_BYTE)v3 != (_BYTE)v4 )
        return v3 - v4;
      ++a1;
      ++a2;
      v3 = *a1;
      v4 = *a2;
      if ( !(_BYTE)v3 )
        return -(char)v4;
    }
    if ( v5 > 9u )
      break;
    v7 = v4 - 48;
    v8 = a1[1];
    v9 = v3 - 48;
    ++a1;
    for ( ; (unsigned __int8)(v8 - 48) <= 9u; v8 = *a1 )
    {
      ++a1;
      v9 = v8 + 10 * v9 - 48;
    }
    v10 = a2++;
    for ( i = v10[1]; (unsigned __int8)(i - 48) <= 9u; i = *a2 )
    {
      ++a2;
      v7 = i + 10 * v7 - 48;
    }
    if ( v7 != v9 )
      return v9 - v7;
  }
  return 1;
}

//----- (08092C60) --------------------------------------------------------
int *__cdecl dl_load_cache_lookup(char *a1)
{
  _DWORD *v1; // edi
  unsigned int v2; // esi
  int v3; // ebx
  char *v4; // ebx
  int v5; // eax
  int v6; // ebx
  int v7; // eax
  int v8; // edi
  int v9; // esi
  unsigned int v10; // eax
  int v11; // ebx
  int v12; // eax
  unsigned int v14; // eax
  int v15; // edx
  int v16; // esi
  unsigned int *v17; // ebx
  int v18; // edi
  unsigned int *v19; // ebx
  unsigned int *v20; // ebx
  unsigned int v21; // eax
  unsigned int v22; // eax
  int v23; // eax
  unsigned int *v24; // edx
  int v25; // ecx
  int v26; // eax
  int v27; // ecx
  int v28; // eax
  int v29; // edx
  unsigned int v30; // ebx
  int v31; // esi
  unsigned int v32; // eax
  int v33; // edi
  int v34; // ebx
  int v35; // eax
  void *v36; // esp
  unsigned int whole_file; // eax
  _TBYTE *v38; // ebx
  unsigned int *v39; // edi
  unsigned int v40; // eax
  int v41; // ecx
  int v42; // esi
  int v43; // edi
  int v44; // ebx
  unsigned int *v45; // edi
  unsigned int v46; // eax
  unsigned int v47; // eax
  unsigned int v48; // edx
  _TBYTE *v49; // ebx
  int v50; // eax
  unsigned int v52[3]; // [esp+10h] [ebp-106Ch] BYREF
  unsigned int v53; // [esp+1010h] [ebp-6Ch] BYREF
  __int64 v54; // [esp+1014h] [ebp-68h]
  unsigned int v55; // [esp+101Ch] [ebp-60h]
  unsigned int v56; // [esp+1020h] [ebp-5Ch]
  unsigned int v57; // [esp+1024h] [ebp-58h]
  int v58; // [esp+1028h] [ebp-54h]
  unsigned int v59; // [esp+102Ch] [ebp-50h]
  _BYTE *v60; // [esp+1030h] [ebp-4Ch]
  int v61; // [esp+1034h] [ebp-48h]
  unsigned int v62; // [esp+1038h] [ebp-44h]
  unsigned int *v63; // [esp+103Ch] [ebp-40h]
  _TBYTE *v64; // [esp+1040h] [ebp-3Ch]
  unsigned int *v65; // [esp+1044h] [ebp-38h]
  int v66; // [esp+1048h] [ebp-34h]
  unsigned int v67; // [esp+104Ch] [ebp-30h]
  char *v68[9]; // [esp+1058h] [ebp-24h] BYREF

  v64 = &GLOBAL_OFFSET_TABLE_;
  v60 = dl_debug_mask;
  if ( (dl_debug_mask[0] & 1) != 0 )
    dl_debug_printf((_BYTE *)v64 - 106465, (char *)v64 - 106482);
  v1 = *(_DWORD **)((char *)v64 + (_DWORD)(&cache - 33765376));
  if ( !v1 )
  {
    whole_file = dl_sysdep_read_whole_file(
                   (int)v64 - 106482,
                   (__off_t *)((char *)v64 + (_DWORD)(&cachesize - 33765376)),
                   1);
    v1 = (_DWORD *)whole_file;
    if ( whole_file != -1 )
    {
      v2 = *((_DWORD *)v64 + 1693);
      if ( v2 > 0x10 )
      {
        if ( *(_DWORD *)whole_file == 1932420204
          && *(_DWORD *)(whole_file + 4) == 774974831
          && *(_WORD *)(whole_file + 8) == 11831
          && *(_BYTE *)(whole_file + 10) == 48 )
        {
          v49 = v64;
          *((_DWORD *)v64 + 1695) = whole_file;
          v50 = 12 * *(_DWORD *)(whole_file + 12) + 16;
          *((_DWORD *)v49 + 1694) = (char *)v1 + v50;
          if ( v2 < v50 + 48 || memcmp((_DWORD *)((char *)v1 + v50), (unsigned int *)((char *)v64 - 106435), 20) )
            *(_DWORD *)((char *)v64 + (_DWORD)(&cache_new - 33765376)) = -1;
          goto LABEL_6;
        }
        if ( v2 > 0x30 )
        {
          v38 = v64;
          if ( !memcmp((unsigned int *)whole_file, (unsigned int *)((char *)v64 - 106435), 20) )
          {
            *((_DWORD *)v64 + 1694) = v1;
            *((_DWORD *)v38 + 1695) = v1;
            goto LABEL_6;
          }
        }
      }
      munmap(v1, v2);
    }
    *(_DWORD *)((char *)v64 + (_DWORD)(&cache - 33765376)) = -1;
    return 0;
  }
  if ( v1 == (_DWORD *)-1 )
    return 0;
  v2 = *(_DWORD *)((char *)v64 + (_DWORD)(&cachesize - 33765376));
LABEL_6:
  v3 = *((_DWORD *)v64 + 1694);
  v66 = v3;
  if ( v3 == -1 )
  {
    v26 = v1[3];
    v27 = 12 * v26 + 16;
    v28 = v26 - 1;
    v66 = (int)v1 + v27;
    v29 = v28;
    v30 = v2 - v27;
    v67 = v2 - v27;
    if ( v28 < 0 )
      return 0;
    v31 = v28 >> 1;
    v32 = v1[3 * (v28 >> 1) + 5];
    if ( v30 <= v32 )
      return 0;
    v65 = v1;
    v33 = 0;
    v34 = v29;
    while ( 1 )
    {
      v35 = dl_cache_libcmp(a1, (char *)(v66 + v32));
      if ( !v35 )
        break;
      if ( v35 >= 0 )
        v34 = v31 - 1;
      else
        v33 = v31 + 1;
      if ( v33 <= v34 )
      {
        v31 = (v33 + v34) >> 1;
        v32 = v65[3 * v31 + 5];
        if ( v67 > v32 )
          continue;
      }
      return 0;
    }
    v39 = v65;
    v65 = (unsigned int *)v34;
    if ( v31 )
    {
      v40 = v39[3 * v31 + 2];
      if ( v67 <= v40 )
      {
        v44 = v31;
      }
      else
      {
        v63 = v39;
        v41 = (int)&v39[3 * v31 - 1];
        v62 = v31;
        v42 = v31 - 1;
        v43 = v41;
        while ( 1 )
        {
          v44 = v42 + 1;
          if ( dl_cache_libcmp(a1, (char *)(v66 + v40)) )
          {
            v39 = v63;
            v31 = v62;
            goto LABEL_75;
          }
          if ( !v42 )
            break;
          v43 -= 12;
          v40 = *(_DWORD *)(v43 + 12);
          if ( v67 <= v40 )
            break;
          --v42;
        }
        v44 = v42;
        v39 = v63;
        v31 = v62;
      }
    }
    else
    {
      v44 = 0;
    }
LABEL_75:
    v63 = 0;
    v62 = dl_correct_cache_id;
    v45 = &v39[3 * v44 + 4];
    do
    {
      if ( v44 > v31 )
      {
        v46 = v45[1];
        if ( v46 >= v67 || dl_cache_libcmp(a1, (char *)(v66 + v46)) )
          break;
      }
      v47 = *v45;
      if ( (*v45 & 0xFFFFFFFD) == 1 )
      {
        v48 = v45[2];
        if ( v48 < v67 )
        {
          if ( v63 )
          {
            if ( v62 == v47 )
            {
              v63 = (unsigned int *)(v66 + v48);
              break;
            }
          }
          else
          {
            v63 = (unsigned int *)(v66 + v48);
            if ( v62 == v47 )
              break;
          }
        }
      }
      ++v44;
      v45 += 3;
    }
    while ( v44 <= (int)v65 );
  }
  else
  {
    v67 = (unsigned int)v1 + v2 - v3;
    v4 = dl_platform;
    if ( dl_platform )
    {
      if ( !strcmp(dl_platform, "i586") )
      {
        v54 = 0x10000LL;
      }
      else
      {
        v5 = -(strcmp(v4, &dl_x86_platforms[9]) == 0);
        HIDWORD(v54) = ~v5;
        LODWORD(v54) = (v5 & 0x20001) - 1;
      }
    }
    else
    {
      v54 = -1LL;
    }
    _tunable_get_val(16, v68, 0);
    v6 = *((_DWORD *)v64 + 1694);
    v57 = (unsigned int)v68[0];
    v63 = (unsigned int *)v6;
    v59 = (unsigned int)v68[1];
    v62 = *(&dl_hwcap + 1);
    v7 = *(_DWORD *)(v6 + 20);
    v58 = dl_hwcap;
    v65 = (unsigned int *)v7;
    v8 = v7 - 1;
    if ( v7 - 1 < 0 )
      return 0;
    v9 = v8 >> 1;
    v10 = *(_DWORD *)(v6 + 24 * (v8 >> 1) + 52);
    if ( v67 <= v10 )
      return 0;
    v11 = 0;
    while ( 1 )
    {
      v12 = dl_cache_libcmp(a1, (char *)(v66 + v10));
      if ( !v12 )
        break;
      if ( v12 >= 0 )
      {
        v8 = v9 - 1;
        if ( v9 - 1 < v11 )
          return 0;
      }
      else
      {
        v11 = v9 + 1;
        if ( v8 < v9 + 1 )
          return 0;
      }
      v9 = (v8 + v11) >> 1;
      v10 = v63[6 * v9 + 13];
      if ( v67 <= v10 )
        return 0;
    }
    v65 = (unsigned int *)v8;
    if ( v9 )
    {
      v14 = v63[6 * v9 + 7];
      if ( v67 <= v14 )
      {
        v18 = v9;
      }
      else
      {
        v15 = 3 * v9;
        v61 = v9;
        v16 = v9 - 1;
        v17 = &v63[2 * v15 + 1];
        while ( 1 )
        {
          v18 = v16 + 1;
          if ( dl_cache_libcmp(a1, (char *)(v66 + v14)) )
            break;
          if ( !v16 || (v17 -= 6, v14 = v17[6], v67 <= v14) )
          {
            v18 = v16;
            break;
          }
          --v16;
        }
        v9 = v61;
      }
    }
    else
    {
      v18 = 0;
    }
    v61 = dl_correct_cache_id;
    v19 = v63;
    v63 = 0;
    v53 = dl_osversion;
    v20 = &v19[6 * v18 + 12];
    v55 = v59 & v62 | 0x80030000;
    do
    {
      if ( v18 > v9 )
      {
        v21 = v20[1];
        if ( v21 >= v67 || dl_cache_libcmp(a1, (char *)(v66 + v21)) )
          break;
      }
      v22 = *v20;
      if ( (*v20 & 0xFFFFFFFD) == 1 )
      {
        v62 = v20[2];
        if ( v62 < v67 && (!v63 || v61 == v22) )
        {
          v56 = v20[5];
          v59 = v20[4] & ~(v57 & v58);
          if ( !(v59 | v56 & ~v55) && (!v53 || v53 >= v20[3]) && (v54 == (v56 & 0x30000) || (v56 & 0x30000) == 0) )
          {
            v63 = (unsigned int *)(v66 + v62);
            if ( v61 == v22 )
              break;
          }
        }
      }
      ++v18;
      v20 += 6;
    }
    while ( v18 <= (int)v65 );
  }
  if ( (*v60 & 1) != 0 )
  {
    if ( v63 )
    {
      dl_debug_printf(&aTryingFileS[(_DWORD)v64 - 135061504], v63);
      goto LABEL_44;
    }
    return 0;
  }
  if ( !v63 )
    return 0;
LABEL_44:
  v23 = strlen(v63);
  v24 = (unsigned int *)((char *)&v53 - ((v23 + 28) & 0xFFFFF000));
  if ( &v53 != v24 )
  {
    while ( v52 != v24 )
      ;
  }
  v25 = ((_WORD)v23 + 28) & 0xFF0;
  if ( (((_WORD)v23 + 28) & 0xFF0) != 0 )
  {
    v36 = alloca(v25);
    *(unsigned int *)((char *)&v52[-1] + v25) = *(unsigned int *)((char *)&v52[-1] + v25);
  }
  memcpy(v52, v63, v23 + 1);
  return strdup(v52);
}
// 80A47E0: using guessed type _BYTE dl_x86_platforms[36];
// 80CE000: using guessed type _TBYTE GLOBAL_OFFSET_TABLE_;
// 80CF8C8: using guessed type int dl_hwcap;
// 80CFA74: using guessed type int cachesize;
// 80CFA78: using guessed type int cache_new;
// 80CFA7C: using guessed type int cache;
// 80CFF04: using guessed type _BYTE dl_debug_mask[4];
// 80CFF18: using guessed type char *dl_platform;

//----- (08093340) --------------------------------------------------------
unsigned int dl_unload_cache()
{
  unsigned int result; // eax

  result = cache;
  if ( (unsigned int)(cache - 1) <= 0xFFFFFFFD )
  {
    result = munmap((void *)cache, cachesize);
    cache = 0;
  }
  return result;
}
// 80CFA74: using guessed type int cachesize;
// 80CFA7C: using guessed type int cache;

//----- (080933A0) --------------------------------------------------------
int __usercall dl_tlsdesc_return@<eax>(int a1@<eax>)
{
  return *(_DWORD *)(a1 + 4);
}

//----- (080933B0) --------------------------------------------------------
unsigned int __usercall dl_tlsdesc_undefweak@<eax>(int a1@<eax>)
{
  return *(_DWORD *)(a1 + 4) - __readgsdword(0);
}

//----- (080933C0) --------------------------------------------------------
int __usercall dl_tlsdesc_resolve_abs_plus_addend@<eax>(
        int (__fastcall **a1)(int, int)@<eax>,
        int a2@<edx>,
        int a3@<ecx>,
        int a4@<ebx>)
{
  dl_tlsdesc_resolve_abs_plus_addend_fixup((int)a1, *(_DWORD *)(a4 + 4), 20);
  return (*a1)(a3, a2);
}

//----- (080933E0) --------------------------------------------------------
int __usercall dl_tlsdesc_resolve_rel@<eax>(
        int (__fastcall **a1)(int, int)@<eax>,
        int a2@<edx>,
        int a3@<ecx>,
        int a4@<ebx>)
{
  dl_tlsdesc_resolve_rel_fixup((int)a1, *(_DWORD **)(a4 + 4), 20);
  return (*a1)(a3, a2);
}

//----- (08093400) --------------------------------------------------------
int __usercall dl_tlsdesc_resolve_rela@<eax>(
        int (__fastcall **a1)(int, int)@<eax>,
        int a2@<edx>,
        int a3@<ecx>,
        int a4@<ebx>)
{
  dl_tlsdesc_resolve_rela_fixup((int)a1, *(_DWORD **)(a4 + 4), 20);
  return (*a1)(a3, a2);
}

//----- (08093420) --------------------------------------------------------
int __usercall dl_tlsdesc_resolve_hold@<eax>(char **a1@<eax>, int a2@<edx>, int a3@<ecx>)
{
  dl_tlsdesc_resolve_hold_fixup(a1, 20);
  return ((int (__fastcall *)(int, int))*a1)(a3, a2);
}

//----- (08093440) --------------------------------------------------------
int __cdecl do_dlopen(int a1)
{
  int result; // eax

  result = dl_open(
             *(unsigned int **)a1,
             *(_DWORD *)(a1 + 4),
             *(_DWORD *)(a1 + 8),
             -2,
             _libc_argc,
             _libc_argv,
             (int)environ);
  *(_DWORD *)(a1 + 12) = result;
  return result;
}
// 80CF89C: using guessed type _DWORD *environ;
// 80CFF74: using guessed type int _libc_argc;
// 80CFF78: using guessed type int _libc_argv;

//----- (08093490) --------------------------------------------------------
int __usercall dlerror_run@<eax>(void (__cdecl *a1)(int)@<eax>, int a2@<edx>, int a3@<ebp>, int *a4@<edi>)
{
  int result; // eax
  int v5; // [esp+0h] [ebp-20h]
  bool v6; // [esp+7h] [ebp-19h] BYREF
  int v7; // [esp+8h] [ebp-18h] BYREF
  int v8[5]; // [esp+Ch] [ebp-14h] BYREF

  v8[1] = __readgsdword(0x14u);
  v8[0] = 0;
  result = dl_catch_error(a3, &v7, v8, &v6, a1, a2);
  if ( !result )
  {
    if ( !v8[0] )
      return result;
    result = 1;
  }
  if ( v6 )
  {
    v5 = result;
    free(a3, a4, v8[0]);
    return v5;
  }
  return result;
}

//----- (08093520) --------------------------------------------------------
int __usercall _libc_dlclose@<eax>(int a1@<ebp>, int *edi0@<edi>, int a3)
{
  return dlerror_run((void (__cdecl *)(int))do_dlclose, a3, a1, edi0);
}

//----- (08093540) --------------------------------------------------------
int __usercall _libc_dlsym@<eax>(int a1@<ebp>, int *edi0@<edi>, int a3, int a4)
{
  int v4; // eax
  int v5; // edx
  int v7[2]; // [esp+0h] [ebp-20h] BYREF
  int *v8; // [esp+8h] [ebp-18h]
  int v9; // [esp+Ch] [ebp-14h]
  unsigned int v10; // [esp+10h] [ebp-10h]

  v10 = __readgsdword(0x14u);
  v7[0] = a3;
  v7[1] = a4;
  v4 = dlerror_run((void (__cdecl *)(int))do_dlsym, (int)v7, a1, edi0);
  v5 = 0;
  if ( !v4 )
  {
    v5 = v9;
    if ( v9 )
    {
      if ( *(_WORD *)(v9 + 14) == 0xFFF1 )
      {
        v4 = 0;
      }
      else if ( v8 )
      {
        v4 = *v8;
      }
      return *(_DWORD *)(v9 + 4) + v4;
    }
  }
  return v5;
}

//----- (080935D0) --------------------------------------------------------
int __usercall _libc_dlvsym@<eax>(int a1@<ebp>, int *a2@<edi>, int a3, int a4, unsigned __int8 *a5)
{
  int v5; // edx
  unsigned __int8 *v6; // eax
  int i; // ecx
  int v8; // edx
  int v9; // eax
  int v10; // edx
  int v12[2]; // [esp+0h] [ebp-30h] BYREF
  int *v13; // [esp+8h] [ebp-28h]
  int v14; // [esp+Ch] [ebp-24h]
  unsigned __int8 *v15; // [esp+10h] [ebp-20h]
  int v16; // [esp+14h] [ebp-1Ch]
  int v17; // [esp+18h] [ebp-18h]
  int v18; // [esp+1Ch] [ebp-14h]
  unsigned int v19; // [esp+20h] [ebp-10h]

  v19 = __readgsdword(0x14u);
  v17 = 1;
  v12[0] = a3;
  v15 = a5;
  v12[1] = a4;
  v5 = 0;
  if ( *a5 )
  {
    v5 = *a5;
    if ( a5[1] )
    {
      v5 = a5[1] + 16 * v5;
      if ( a5[2] )
      {
        v5 = a5[2] + 16 * v5;
        if ( a5[3] )
        {
          v5 = a5[3] + 16 * v5;
          if ( a5[4] )
          {
            v6 = a5 + 5;
            v5 = a5[4] + 16 * v5;
            for ( i = a5[5]; *v6; v5 = ((v8 & 0xF0000000) >> 24) ^ v8 & 0xFFFFFFF )
            {
              ++v6;
              v8 = i + 16 * v5;
              i = *v6;
            }
          }
        }
      }
    }
  }
  v16 = v5;
  v18 = 0;
  v9 = dlerror_run((void (__cdecl *)(int))do_dlvsym, (int)v12, a1, a2);
  v10 = 0;
  if ( !v9 )
  {
    v10 = v14;
    if ( v14 )
    {
      if ( *(_WORD *)(v14 + 14) == 0xFFF1 )
      {
        v9 = 0;
      }
      else if ( v13 )
      {
        v9 = *v13;
      }
      return *(_DWORD *)(v14 + 4) + v9;
    }
  }
  return v10;
}

//----- (080936E0) --------------------------------------------------------
unsigned int __cdecl do_dlsym_private(int a1)
{
  _DWORD *v1; // eax
  int v3[4]; // [esp+0h] [ebp-20h] BYREF
  unsigned int v4; // [esp+10h] [ebp-10h]

  v4 = __readgsdword(0x14u);
  v3[2] = 1;
  v3[1] = 157536133;
  v3[3] = 0;
  v3[0] = (int)"GLIBC_PRIVATE";
  v1 = *(_DWORD **)a1;
  *(_DWORD *)(a1 + 12) = 0;
  *(_DWORD *)(a1 + 8) = dl_lookup_symbol_x(
                          *(unsigned __int8 **)(a1 + 4),
                          v1,
                          (int *)(a1 + 12),
                          *(int ***)((char *)v1 + (_DWORD)(&dword_80CE1D0 - 33765376)),
                          v3,
                          0,
                          0,
                          0);
  return __readgsdword(0x14u) ^ v4;
}
// 80CE1D0: using guessed type int dword_80CE1D0;

//----- (08093770) --------------------------------------------------------
_DWORD *__cdecl do_dlsym(int *a1)
{
  int v1; // eax
  _DWORD *result; // eax

  v1 = *a1;
  a1[3] = 0;
  result = dl_lookup_symbol_x((unsigned __int8 *)a1[1], (_DWORD *)v1, a1 + 3, (int **)(v1 + 468), 0, 0, 2, 0);
  a1[2] = (int)result;
  return result;
}

//----- (080937B0) --------------------------------------------------------
_DWORD *__cdecl do_dlvsym(int *a1)
{
  int v1; // eax
  _DWORD *result; // eax

  v1 = *a1;
  a1[3] = 0;
  result = dl_lookup_symbol_x((unsigned __int8 *)a1[1], (_DWORD *)v1, a1 + 3, (int **)(v1 + 468), a1 + 4, 0, 0, 0);
  a1[2] = (int)result;
  return result;
}

//----- (080937F0) --------------------------------------------------------
int __cdecl do_dlclose(int a1)
{
  return dl_close(a1);
}

//----- (08093800) --------------------------------------------------------
int __usercall _libc_dlsym_private@<eax>(int a1@<ebp>, int *edi0@<edi>, int a3, int a4)
{
  int v4; // eax
  int v5; // edx
  int v7[2]; // [esp+0h] [ebp-20h] BYREF
  int *v8; // [esp+8h] [ebp-18h]
  int v9; // [esp+Ch] [ebp-14h]
  unsigned int v10; // [esp+10h] [ebp-10h]

  v10 = __readgsdword(0x14u);
  v7[0] = a3;
  v7[1] = a4;
  v4 = dlerror_run((void (__cdecl *)(int))do_dlsym_private, (int)v7, a1, edi0);
  v5 = 0;
  if ( !v4 )
  {
    v5 = v9;
    if ( v9 )
    {
      if ( *(_WORD *)(v9 + 14) == 0xFFF1 )
      {
        v4 = 0;
      }
      else if ( v8 )
      {
        v4 = *v8;
      }
      return *(_DWORD *)(v9 + 4) + v4;
    }
  }
  return v5;
}

//----- (08093890) --------------------------------------------------------
_DWORD *__usercall _libc_register_dl_open_hook@<eax>(int a1@<ebp>, int *edi0@<edi>, int a3)
{
  _DWORD *v3; // eax
  _DWORD *result; // eax

  v3 = (_DWORD *)_libc_dlsym_private(a1, edi0, a3, (int)"_dl_open_hook");
  if ( v3 )
    *v3 = dl_open_hook;
  result = (_DWORD *)_libc_dlsym_private(a1, edi0, a3, (int)"_dl_open_hook2");
  if ( result )
    *result = dl_open_hook;
  return result;
}
// 80CEEFC: using guessed type int (__cdecl *dl_open_hook[2])(int, int);

//----- (080938F0) --------------------------------------------------------
int __usercall _libc_dlopen_mode@<eax>(int a1@<ebp>, int *edi0@<edi>, int a3, int a4)
{
  int v4; // eax
  int v5; // edx
  int v7[3]; // [esp+0h] [ebp-20h] BYREF
  int v8; // [esp+Ch] [ebp-14h]
  unsigned int v9; // [esp+10h] [ebp-10h]
  int retaddr; // [esp+20h] [ebp+0h]

  v9 = __readgsdword(0x14u);
  v7[0] = a3;
  v7[1] = a4;
  v7[2] = retaddr;
  v4 = dlerror_run((void (__cdecl *)(int))do_dlopen, (int)v7, a1, edi0);
  v5 = 0;
  if ( !v4 )
  {
    _libc_register_dl_open_hook(a1, edi0, v8);
    _libc_register_dlfcn_hook(a1, edi0, v8);
    return v8;
  }
  return v5;
}

//----- (08093970) --------------------------------------------------------
void __usercall __noreturn fatal_error(signed int a1@<eax>, _BYTE *a2@<edx>, const char *a3@<ecx>, int a4)
{
  unsigned __int8 *v6; // ecx
  unsigned __int8 *v7; // edx
  unsigned __int8 *v8; // eax
  const char *v9; // esi
  unsigned __int8 *v10; // eax
  char v11[1024]; // [esp+14h] [ebp-420h] BYREF
  unsigned int v12; // [esp+414h] [ebp-20h]

  v12 = __readgsdword(0x14u);
  v6 = byte_80B41F9;
  v7 = byte_80B41F9;
  if ( a1 )
  {
    v10 = strerror_r(a1, v11, 0x400u);
    v7 = ": ";
    v6 = v10;
  }
  v8 = byte_80B41F9;
  if ( *a2 )
    v8 = ": ";
  if ( !a3 )
    a3 = "error while loading shared libraries";
  v9 = (const char *)program_invocation_short_name[0];
  if ( !program_invocation_short_name[0] )
    v9 = "<program name unknown>";
  dl_dprintf(2, "%s: %s: %s%s%s%s%s\n", v9, a3, a2, v8, a4, v7, v6);
  exit(127);
}
// 80B41F9: using guessed type unsigned __int8 byte_80B41F9[1671];
// 80CDDA4: using guessed type char (**dl_argv)[1671];
// 80CE964: using guessed type char (*program_invocation_short_name[2])[1671];
// 8093970: using guessed type char var_420[1024];

//----- (08093A30) --------------------------------------------------------
void __cdecl __noreturn dl_signal_exception(signed int a1, int a2, const char *a3)
{
  _DWORD **v3; // edx
  _DWORD *v4; // ecx
  struct __jmp_buf_tag *v5; // edx

  v3 = (_DWORD **)__readgsdword(0xFFFFFFFC);
  if ( v3 )
  {
    v4 = *v3;
    v5 = (struct __jmp_buf_tag *)(v3 + 2);
    *v4 = *(_DWORD *)a2;
    v4[1] = *(_DWORD *)(a2 + 4);
    v4[2] = *(_DWORD *)(a2 + 8);
    *(_DWORD *)v5[-1].__saved_mask.__val[31] = a1;
    _longjmp(v5, 1);
  }
  fatal_error(a1, *(_BYTE **)a2, a3, *(_DWORD *)(a2 + 4));
}

//----- (08093A90) --------------------------------------------------------
void __cdecl __noreturn dl_signal_error(int a1, unsigned int *a2, int a3, unsigned int *a4)
{
  unsigned int *v4; // eax
  unsigned int v5; // esi
  struct __jmp_buf_tag *v6; // esi

  v4 = a4;
  v5 = __readgsdword(0xFFFFFFFC);
  if ( !a4 )
    v4 = (unsigned int *)"DYNAMIC LINKER BUG!!!";
  if ( v5 )
  {
    v6 = (struct __jmp_buf_tag *)(v5 + 8);
    dl_exception_create((const char **)v6[-1].__saved_mask.__val[30], a2, v4);
    *(_DWORD *)v6[-1].__saved_mask.__val[31] = a1;
    _longjmp(v6, 1);
  }
  fatal_error(a1, a2, (const char *)a3, (int)v4);
}

//----- (08093B00) --------------------------------------------------------
int __usercall dl_catch_exception@<eax>(
        int a1@<ebp>,
        int a2@<edi>,
        int a3@<esi>,
        _DWORD *a4,
        void (__cdecl *a5)(int),
        int a6)
{
  int v6; // ebx
  unsigned int v8; // [esp+4h] [ebp-CCh]
  int v9; // [esp+18h] [ebp-B8h] BYREF
  int v10[2]; // [esp+1Ch] [ebp-B4h] BYREF
  char v11[156]; // [esp+24h] [ebp-ACh] BYREF
  unsigned int v12; // [esp+C0h] [ebp-10h]

  v12 = __readgsdword(0x14u);
  v10[0] = (int)a4;
  v10[1] = (int)&v9;
  v8 = __readgsdword(0xFFFFFFFC);
  __writegsdword(0xFFFFFFFC, (unsigned int)v10);
  if ( _sigsetjmp(0, a1, a2, a3, (int)v11, 0) )
  {
    __writegsdword(0xFFFFFFFC, v8);
    return v9;
  }
  else
  {
    v6 = 0;
    a5(a6);
    __writegsdword(0xFFFFFFFC, v8);
    *a4 = 0;
    a4[1] = 0;
    a4[2] = 0;
  }
  return v6;
}
// 8093B00: using guessed type char var_AC[156];

//----- (08093C00) --------------------------------------------------------
int __usercall dl_catch_error@<eax>(int a1@<ebp>, _DWORD *a2, _DWORD *a3, bool *a4, void (__cdecl *a5)(int), int a6)
{
  int result; // eax
  bool v7; // zf
  int v8; // [esp+4h] [ebp-1Ch] BYREF
  int v9; // [esp+8h] [ebp-18h]
  int v10; // [esp+Ch] [ebp-14h]
  unsigned int v11; // [esp+10h] [ebp-10h]

  v11 = __readgsdword(0x14u);
  result = dl_catch_exception(a1, (int)a2, (int)a3, &v8, a5, a6);
  *a2 = v8;
  v7 = v10 == v9;
  *a3 = v9;
  *a4 = v7;
  return result;
}

//----- (08093C70) --------------------------------------------------------
int __usercall _sigsetjmp@<eax>(int ebx0@<ebx>, int ebp0@<ebp>, int a3@<edi>, int a4@<esi>, int a5, int a6)
{
  _DWORD *v6; // eax
  unsigned int retaddr; // [esp+0h] [ebp+0h]

  v6 = (_DWORD *)a5;
  *(_DWORD *)a5 = ebx0;
  v6[1] = a4;
  v6[2] = a3;
  v6[4] = __ROL4__(__readgsdword(0x18u) ^ (unsigned int)&a5, 9);
  v6[5] = __ROL4__(__readgsdword(0x18u) ^ retaddr, 9);
  v6[3] = ebp0;
  __asm { rdsspd  ecx }
  v6[10] = _ECX;
  return _sigjmp_save(a5, a6);
}

//----- (08093CC0) --------------------------------------------------------
int __cdecl _sigjmp_save(int a1, int a2)
{
  if ( a2 )
    *(_DWORD *)(a1 + 24) = sigprocmask(0, 0, a1 + 28) == 0;
  else
    *(_DWORD *)(a1 + 24) = 0;
  return 0;
}

//----- (08093D10) --------------------------------------------------------
void __noreturn _longjmp(struct __jmp_buf_tag env[1], int val)
{
  int v3; // edx
  unsigned int v4; // edx
  bool v6; // cc

  __asm { rdsspd  edx }
  v3 = _EDX - env->__saved_mask.__val[3];
  if ( v3 )
  {
    v4 = ((unsigned int)-v3 >> 2) + 1;
    _EBX = 255;
    do
    {
      if ( v4 < _EBX )
        _EBX = v4;
      __asm { incsspd ebx }
      v6 = v4 <= _EBX;
      v4 -= _EBX;
    }
    while ( !v6 );
  }
  ((void (*)(void))(__readgsdword(0x18u) ^ __ROR4__(env->__jmpbuf[5], 9)))();
}

//----- (08093D70) --------------------------------------------------------
int __cdecl _mpn_cmp(int a1, int a2, int a3)
{
  int v3; // eax
  unsigned int v4; // edx
  unsigned int v5; // ecx

  v3 = a3 - 1;
  if ( a3 - 1 < 0 )
    return 0;
  while ( 1 )
  {
    v4 = *(_DWORD *)(a1 + 4 * v3);
    v5 = *(_DWORD *)(a2 + 4 * v3);
    if ( v4 != v5 )
      break;
    if ( --v3 == -1 )
      return 0;
  }
  return v5 < v4 ? 1 : -1;
}

//----- (08093DC0) --------------------------------------------------------
int __cdecl _mpn_divrem(int a1, int a2, unsigned int *a3, int a4, unsigned int *a5, int a6)
{
  unsigned int *v6; // edi
  unsigned int v7; // esi
  unsigned int v8; // ebp
  unsigned int v9; // eax
  unsigned int *v10; // esi
  unsigned int v11; // ecx
  unsigned int v12; // ebx
  unsigned int v13; // eax
  unsigned int *v14; // ecx
  unsigned int v15; // edi
  int v16; // eax
  unsigned int v17; // esi
  int v18; // eax
  unsigned __int64 v19; // rtt
  unsigned int v20; // ebx
  unsigned __int64 i; // rax
  bool v22; // cf
  unsigned int v23; // ebx
  unsigned int v24; // edx
  int v25; // edi
  int v26; // ecx
  unsigned __int64 v27; // rtt
  int v28; // ecx
  int v29; // eax
  unsigned int *v31; // eax
  unsigned int v32; // edx
  unsigned int *v33; // eax
  unsigned int v34; // edi
  unsigned int v35; // ecx
  unsigned int v36; // ebx
  unsigned int v37; // ebp
  unsigned int v38; // esi
  unsigned int v39; // edx
  unsigned int v40; // ecx
  int v41; // edx
  unsigned int v42; // edx
  int v43; // ebx
  unsigned int v44; // ebp
  unsigned __int64 v45; // rax
  int v46; // edx
  int v47; // eax
  unsigned int *v48; // [esp+0h] [ebp-3Ch]
  unsigned int v49; // [esp+0h] [ebp-3Ch]
  int v50; // [esp+0h] [ebp-3Ch]
  unsigned int v51; // [esp+0h] [ebp-3Ch]
  unsigned int v52; // [esp+0h] [ebp-3Ch]
  int v53; // [esp+4h] [ebp-38h]
  unsigned int v54; // [esp+4h] [ebp-38h]
  unsigned int v55; // [esp+8h] [ebp-34h]
  unsigned int *v56; // [esp+8h] [ebp-34h]
  unsigned int *v57; // [esp+Ch] [ebp-30h]
  unsigned int v58; // [esp+Ch] [ebp-30h]
  int v59; // [esp+10h] [ebp-2Ch]
  unsigned int v60; // [esp+14h] [ebp-28h]
  int v61; // [esp+18h] [ebp-24h]
  int v62; // [esp+18h] [ebp-24h]

  if ( a6 == 1 )
  {
    v61 = 0;
    v23 = *a5;
    v24 = a3[a4 - 1];
    if ( *a5 <= v24 )
    {
      v61 = 1;
      v24 -= v23;
    }
    v25 = 4 * a2 + a1;
    if ( a4 - 2 >= 0 )
    {
      v26 = a4 - 2;
      do
      {
        LODWORD(v27) = a3[v26];
        HIDWORD(v27) = v24;
        v24 = v27 % v23;
        *(_DWORD *)(v25 + v26 * 4) = v27 / v23;
        --v26;
      }
      while ( v26 != -1 );
    }
    if ( a2 > 0 )
    {
      v28 = v25 - 4;
      do
      {
        v28 -= 4;
        v29 = __PAIR64__(v24, 0) / v23;
        v24 = __PAIR64__(v24, 0) % v23;
        *(_DWORD *)(v28 + 4) = v29;
      }
      while ( a1 - 4 != v28 );
    }
    *a3 = v24;
    return v61;
  }
  if ( a6 != 2 )
  {
    if ( !a6 )
      BUG();
    v61 = 0;
    v6 = &a3[a4 - a6];
    v7 = 4 * (a6 + 0x3FFFFFFF);
    v8 = a5[v7 / 4];
    v60 = v7;
    v9 = v7;
    v55 = v7 - 4;
    v10 = &v6[v7 / 4];
    v11 = *(unsigned int *)((char *)a5 + v9 - 4);
    v12 = *(unsigned int *)((char *)v6 + v9);
    if ( v8 <= v12 )
    {
      if ( v8 < v12
        || (v51 = *(unsigned int *)((char *)a5 + v9 - 4), v47 = _mpn_cmp((int)v6, (int)a5, a6 - 1), v11 = v51, v47 >= 0) )
      {
        v52 = v11;
        _mpn_sub_n(v6, v6, a5, a6);
        v12 = *v10;
        v11 = v52;
        v61 = 1;
      }
    }
    v53 = a2 + a4 - a6 - 1;
    if ( v53 >= 0 )
    {
      v13 = v11;
      v14 = &a3[a4 - a6];
      v15 = v13;
      do
      {
        if ( a2 > v53 )
        {
          v57 = (unsigned int *)((char *)v14 + v60);
          v59 = *(unsigned int *)((char *)v14 + v60);
          v31 = (unsigned int *)((char *)v14 + v60 + 4);
          if ( a6 > 0 )
          {
            do
            {
              v32 = *--v31;
              v31[1] = v32;
            }
            while ( v14 != v31 );
          }
          *v14 = 0;
        }
        else
        {
          v57 = (unsigned int *)((char *)v14 + v60 - 4);
          v59 = *(unsigned int *)((char *)v14-- + v60);
        }
        v17 = -1;
        if ( v8 != v12 )
        {
          LODWORD(v19) = *v57;
          HIDWORD(v19) = v12;
          v20 = v19 % v8;
          v49 = v19 / v8;
          for ( i = v49 * (unsigned __int64)v15; __PAIR64__(v20, *(unsigned int *)((char *)v14 + v55)) < i; i -= v15 )
          {
            --v49;
            v22 = __CFADD__(v8, v20);
            v20 += v8;
            if ( v22 )
              break;
          }
          v17 = v49;
        }
        v48 = v14;
        v16 = _mpn_submul_1((int)v14, (int)a5, a6, v17);
        v14 = v48;
        if ( v59 != v16 )
        {
          --v17;
          _mpn_add_n(v48, v48, a5, a6);
          v14 = v48;
        }
        v18 = v53;
        *(_DWORD *)(a1 + 4 * v53--) = v17;
        v12 = *v57;
      }
      while ( v18 );
    }
    return v61;
  }
  v62 = 0;
  v33 = &a3[a4 - 2];
  v34 = a5[1];
  v35 = v33[1];
  v36 = *v33;
  v56 = v33;
  v37 = *a5;
  if ( __PAIR64__(v34, v37) <= __PAIR64__(v35, v36) )
  {
    v35 = (__PAIR64__(v35, v36) - __PAIR64__(v34, v37)) >> 32;
    v36 -= v37;
    v62 = 1;
  }
  v50 = a2 + a4 - 3;
  if ( v50 >= 0 )
  {
    v38 = *a5;
    while ( 1 )
    {
      if ( a2 <= v50 )
      {
        v39 = *--v56;
        v54 = v39;
        if ( v34 == v35 )
          goto LABEL_36;
LABEL_40:
        v42 = __PAIR64__(v35, v36) % v34;
        v43 = __PAIR64__(v35, v36) / v34;
        v40 = v42;
        v45 = (unsigned int)v43 * (unsigned __int64)v38;
        v44 = v43 * v38;
        LODWORD(v45) = v54;
        do
        {
LABEL_41:
          if ( HIDWORD(v45) <= v40 && (HIDWORD(v45) != v40 || v44 <= (unsigned int)v45) )
            break;
          --v43;
          HIDWORD(v45) = (__PAIR64__(HIDWORD(v45), v44) - v38) >> 32;
          v44 -= v38;
          v22 = __CFADD__(v34, v40);
          v40 += v34;
        }
        while ( !v22 );
        v58 = HIDWORD(v45);
        v46 = v50--;
        *(_DWORD *)(a1 + 4 * v46) = v43;
        v35 = (__PAIR64__(v40, v54) - __PAIR64__(v58, v44)) >> 32;
        v36 = v54 - v44;
        if ( v50 == -1 )
          break;
      }
      else
      {
        *v56 = 0;
        v54 = 0;
        if ( v34 != v35 )
          goto LABEL_40;
LABEL_36:
        v40 = v34 + v36;
        if ( !__CFADD__(v34, v36) )
        {
          v43 = -1;
          v44 = -v38;
          HIDWORD(v45) = v38 - (v38 != 0);
          LODWORD(v45) = v54;
          goto LABEL_41;
        }
        v41 = v50--;
        *(_DWORD *)(a1 + 4 * v41) = -1;
        v35 = (v38 + __PAIR64__(v40 - v38, v54)) >> 32;
        v36 = v38 + v54;
        if ( v50 == -1 )
          break;
      }
    }
  }
  v56[1] = v35;
  *v56 = v36;
  return v62;
}

//----- (080941C0) --------------------------------------------------------
int __cdecl _mpn_lshift(_DWORD *a1, int a2, int a3, char a4)
{
  int v4; // esi
  unsigned int v5; // ebx
  int result; // eax
  int v7; // edx
  unsigned int v8; // eax
  int v9; // [esp-4h] [ebp-10h]

  v4 = a2 - 4;
  v5 = *(_DWORD *)(a2 - 4 + 4 * a3);
  result = (unsigned __int64)v5 << a4 >> 32;
  v7 = a3 - 1;
  if ( a3 == 1 )
  {
    *a1 = v5 << a4;
  }
  else
  {
    v9 = (unsigned __int64)*(unsigned int *)(a2 - 4 + 4 * a3) << a4 >> 32;
    if ( (v7 & 1) != 0 )
      goto LABEL_5;
    v8 = *(_DWORD *)(a2 - 4 + 4 * a3);
    do
    {
      v5 = *(_DWORD *)(v4 + 4 * v7);
      a1[v7--] = __PAIR64__(v8, v5) << a4 >> 32;
LABEL_5:
      v8 = *(_DWORD *)(v4 + 4 * v7);
      a1[v7--] = __PAIR64__(v5, v8) << a4 >> 32;
    }
    while ( v7 );
    *a1 = v8 << a4;
    return v9;
  }
  return result;
}

//----- (08094220) --------------------------------------------------------
int __cdecl _mpn_rshift(int a1, unsigned int *a2, int a3, char a4)
{
  unsigned int *v4; // edi
  unsigned int *v5; // esi
  unsigned int v6; // ebx
  int result; // eax
  unsigned __int64 v8; // rt0
  int v9; // edx
  unsigned int v10; // eax
  int v11; // [esp-4h] [ebp-10h]

  v4 = (unsigned int *)(a1 + 4 * a3 - 4);
  v5 = &a2[a3];
  v6 = *a2;
  LODWORD(v8) = 0;
  HIDWORD(v8) = *a2;
  result = v8 >> a4;
  v9 = 1 - a3;
  if ( a3 == 1 )
  {
    *v4 = v6 >> a4;
  }
  else
  {
    v11 = result;
    if ( (v9 & 1) != 0 )
      goto LABEL_5;
    v10 = *a2;
    do
    {
      v6 = v5[v9];
      v4[v9++] = __PAIR64__(v6, v10) >> a4;
LABEL_5:
      v10 = v5[v9];
      v4[v9++] = __PAIR64__(v10, v6) >> a4;
    }
    while ( v9 );
    *v4 = v10 >> a4;
    return v11;
  }
  return result;
}

//----- (08094280) --------------------------------------------------------
int __cdecl _mpn_mul(int *a1, int *a2, int a3, unsigned int *a4, int a5)
{
  int result; // eax
  int *v6; // eax
  int *v7; // ecx
  int v8; // edx
  int v9; // edi
  int *v10; // ebx
  int *v11; // ebx
  _BYTE *v12; // ecx
  int v13; // edx
  void *v14; // esp
  int *v15; // edi
  _BOOL4 v16; // eax
  _BYTE *v17; // edx
  _BOOL4 v18; // ecx
  _BYTE *v19; // ecx
  int v20; // edi
  int v21; // eax
  int *v22; // edx
  _DWORD *v23; // ebx
  unsigned int *v24; // esi
  int *v25; // edi
  _BOOL4 v26; // eax
  _DWORD *v27; // ebx
  bool v28; // cf
  int *v29; // edx
  int *v30; // ecx
  int v31; // ebx
  int v32; // eax
  int v33; // eax
  int v34; // ebx
  int *v35; // edx
  int *v36; // eax
  int *v37; // ecx
  int v38; // ebx
  void *v39; // esp
  int v40; // edi
  int v41; // eax
  _BYTE v42[4]; // [esp-2004h] [ebp-205Ch]
  _BYTE v43[4096]; // [esp-2000h] [ebp-2058h] BYREF
  _DWORD v44[1024]; // [esp-1000h] [ebp-1058h] BYREF
  int v45; // [esp+0h] [ebp-58h] BYREF
  int v46; // [esp+4h] [ebp-54h]
  int *v47; // [esp+8h] [ebp-50h]
  _BYTE *v48; // [esp+Ch] [ebp-4Ch]
  int *v49; // [esp+10h] [ebp-48h]
  int v50; // [esp+14h] [ebp-44h]
  int *v51; // [esp+18h] [ebp-40h]
  int *v52; // [esp+1Ch] [ebp-3Ch]
  unsigned int *v53; // [esp+20h] [ebp-38h]
  int *v54; // [esp+24h] [ebp-34h]
  int v55; // [esp+28h] [ebp-30h]
  int v56; // [esp+2Ch] [ebp-2Ch]
  unsigned int v57; // [esp+3Ch] [ebp-1Ch]

  v52 = a1;
  v55 = (int)a2;
  v53 = a4;
  v57 = __readgsdword(0x14u);
  result = 0;
  if ( a5 <= 31 )
  {
    if ( !a5 )
      return result;
    if ( *a4 > 1 )
    {
      result = _mpn_mul_1((int)v52, v55, a3, *a4);
    }
    else
    {
      if ( *a4 != 1 )
      {
        v6 = a1;
        if ( a3 > 0 )
        {
          do
            *v6++ = 0;
          while ( &a1[a3] != v6 );
        }
        goto LABEL_8;
      }
      if ( a3 <= 0 )
      {
LABEL_8:
        result = 0;
        goto LABEL_27;
      }
      v35 = v52;
      v36 = (int *)v55;
      v37 = (int *)(v55 + 4 * a3);
      do
      {
        v38 = *v36++;
        *v35++ = v38;
      }
      while ( v36 != v37 );
      result = 0;
    }
LABEL_27:
    v22 = v52;
    v52[a3] = result;
    v23 = v22 + 1;
    if ( a5 > 1 )
    {
      v56 = (int)&v22[a5];
      v24 = v53 + 1;
      do
      {
        if ( *v24 <= 1 )
        {
          result = 0;
          if ( *v24 == 1 )
            result = _mpn_add_n(v23, v23, (_DWORD *)v55, a3);
        }
        else
        {
          result = _mpn_addmul_1((int)v23, v55, a3, *v24);
        }
        v23[a3] = result;
        ++v24;
        ++v23;
      }
      while ( (_DWORD *)v56 != v23 );
    }
    return result;
  }
  v7 = (int *)((char *)&v45 - ((8 * a5 + 27) & 0xFFFFF000));
  if ( &v45 != v7 )
  {
    while ( v44 != v7 )
      ;
  }
  v8 = (8 * (_WORD)a5 + 27) & 0xFF0;
  if ( ((8 * (_WORD)a5 + 27) & 0xFF0) != 0 )
  {
    v39 = alloca(v8);
    *(_DWORD *)&v43[v8 + 4092] = *(_DWORD *)&v43[v8 + 4092];
  }
  v9 = v55;
  v10 = v52;
  v50 = 8 * a5 + 27;
  v51 = v44;
  _mpn_impn_mul_n(v52, (int *)v55, v53, a5, v44);
  v55 = 4 * a5;
  v11 = &v10[a5];
  v54 = (int *)(4 * a5 + v9);
  v56 = a3 - a5;
  if ( a5 <= a3 - a5 )
  {
    v12 = (char *)v44 - (v50 & 0xFFFFF000);
    if ( v44 != (_DWORD *)v12 )
    {
      while ( v43 != v12 )
        ;
    }
    v13 = v50 & 0xFF0;
    if ( (v50 & 0xFF0) != 0 )
    {
      v14 = alloca(v13);
      *(_DWORD *)&v42[v13] = *(_DWORD *)&v42[v13];
    }
    v49 = (int *)v43;
    v50 = (int)&v43[v55];
    v48 = &v43[v55 + 4];
    v46 = a5 - 1;
    while ( 1 )
    {
      v15 = v49;
      _mpn_impn_mul_n(v49, v54, v53, a5, v51);
      v16 = _mpn_add_n(v11, v11, v15, a5);
      v11 = (int *)((char *)v11 + v55);
      v17 = v11 + 1;
      v18 = __CFADD__(*(_DWORD *)v50, v16);
      *v11 = *(_DWORD *)v50 + v16;
      if ( v18 )
      {
        v19 = v48;
        v20 = a5 - 1;
        while ( 1 )
        {
          v19 += 4;
          v17 += 4;
          v21 = *((_DWORD *)v19 - 1) + 1;
          *((_DWORD *)v17 - 1) = v21;
          if ( v21 )
            break;
          if ( !--v20 )
            goto LABEL_23;
        }
        if ( v19 == v17 )
          goto LABEL_23;
        v40 = v20 - 1;
        if ( v40 <= 0 )
          goto LABEL_23;
LABEL_49:
        v47 = v11;
        v41 = 0;
        do
        {
          *(_DWORD *)&v17[4 * v41] = *(_DWORD *)&v19[4 * v41];
          ++v41;
        }
        while ( v41 < v40 );
        v56 -= a5;
        v11 = v47;
        v54 = (int *)((char *)v54 + v55);
        if ( a5 > v56 )
          break;
      }
      else
      {
        v40 = v46;
        v19 = v48;
        if ( v48 != v17 )
          goto LABEL_49;
LABEL_23:
        v56 -= a5;
        v54 = (int *)((char *)v54 + v55);
        if ( a5 > v56 )
          break;
      }
    }
  }
  if ( v56 )
  {
    v25 = v51;
    _mpn_mul(v51, (int *)v53, a5, (unsigned int *)v54, v56);
    v26 = _mpn_add_n(v11, v11, v25, a5);
    v27 = (int *)((char *)v11 + v55);
    v28 = __CFADD__(*(int *)((char *)v25 + v55), v26);
    v29 = (int *)((char *)v25 + v55 + 4);
    *v27 = *(int *)((char *)v25 + v55) + v26;
    v30 = v27 + 1;
    if ( v28 )
    {
      v31 = v56;
      while ( --v31 )
      {
        ++v29;
        ++v30;
        v32 = *(v29 - 1) + 1;
        *(v30 - 1) = v32;
        if ( v32 )
        {
          v56 = v31;
          goto LABEL_39;
        }
      }
    }
    else
    {
LABEL_39:
      if ( v30 != v29 && v56 > 1 )
      {
        v33 = (int)&v29[v56 - 1];
        do
        {
          v34 = *v29++;
          *v30++ = v34;
        }
        while ( v29 != (int *)v33 );
      }
    }
  }
  return v52[a3 + a5 - 1];
}

//----- (08094660) --------------------------------------------------------
int __cdecl _mpn_mul_1(int a1, int a2, int a3, unsigned int a4)
{
  int v4; // ecx
  int v5; // ebp
  unsigned __int64 v6; // rax
  int v7; // edx

  v4 = -a3;
  v5 = 0;
  do
  {
    v6 = a4 * (unsigned __int64)*(unsigned int *)(a2 + 4 * a3 + 4 * v4);
    *(_DWORD *)(a1 + 4 * a3 + 4 * v4) = v5 + v6;
    v7 = __CFADD__(v5, (_DWORD)v6) + HIDWORD(v6);
    v5 = v7;
    ++v4;
  }
  while ( v4 );
  return v7;
}

//----- (080946B0) --------------------------------------------------------
int __cdecl _mpn_impn_mul_n_basecase(int a1, int *a2, unsigned int *a3, int a4)
{
  _DWORD *v4; // eax
  int result; // eax
  _DWORD *v6; // edi
  _DWORD *v7; // ebx
  unsigned int *v8; // ebp
  int *v9; // eax
  int v10; // edx
  int v11; // edi
  int v12; // [esp-10h] [ebp-2Ch]
  unsigned int v13; // [esp-4h] [ebp-20h]

  if ( *a3 > 1 )
  {
    result = _mpn_mul_1(a1, (int)a2, a4, *a3);
  }
  else
  {
    if ( *a3 == 1 )
    {
      if ( a4 > 0 )
      {
        v9 = a2;
        v10 = a1;
        do
        {
          v11 = *v9++;
          v10 += 4;
          *(_DWORD *)(v10 - 4) = v11;
        }
        while ( v9 != &a2[a4] );
      }
    }
    else
    {
      v4 = (_DWORD *)a1;
      if ( a4 > 0 )
      {
        do
          *v4++ = 0;
        while ( v4 != (_DWORD *)(a1 + 4 * a4) );
      }
    }
    result = 0;
  }
  v6 = (_DWORD *)(a1 + 4 * a4);
  v7 = (_DWORD *)(a1 + 4);
  *v6 = result;
  if ( a4 > 1 )
  {
    v8 = a3 + 1;
    do
    {
      while ( *v8 > 1 )
      {
        v13 = *v8++;
        v12 = (int)v7++;
        result = _mpn_addmul_1(v12, (int)a2, a4, v13);
        v7[a4 - 1] = result;
        if ( v6 == v7 )
          return result;
      }
      result = 0;
      if ( *v8 == 1 )
        result = _mpn_add_n(v7, v7, a2, a4);
      v7[a4] = result;
      ++v7;
      ++v8;
    }
    while ( v6 != v7 );
  }
  return result;
}

//----- (080947E0) --------------------------------------------------------
int __cdecl _mpn_impn_mul_n(int *a1, int *a2, unsigned int *a3, int a4, _DWORD *a5)
{
  int v5; // ebx
  int v6; // ebx
  int result; // eax
  int v8; // esi
  int v9; // ecx
  unsigned int *v10; // eax
  int *v11; // ebp
  int *v12; // edi
  unsigned int *v13; // ebp
  int i; // eax
  int v15; // eax
  bool v16; // cf
  int v17; // edx
  _BOOL4 v18; // eax
  int *v19; // ecx
  int v20; // eax
  int v21; // eax
  int v22; // esi
  int v23; // edx
  unsigned int *v24; // [esp+Ch] [ebp-30h]
  _BOOL4 v25; // [esp+Ch] [ebp-30h]
  int v26; // [esp+Ch] [ebp-30h]
  int v27; // [esp+10h] [ebp-2Ch]
  int v28; // [esp+14h] [ebp-28h]
  int v29; // [esp+18h] [ebp-24h]
  int *v30; // [esp+1Ch] [ebp-20h]

  v5 = a4 & 1;
  if ( (a4 & 1) != 0 )
  {
    v6 = a4 - 1;
    if ( a4 - 1 <= 31 )
      _mpn_impn_mul_n_basecase((int)a1, a2, a3, a4 - 1);
    else
      _mpn_impn_mul_n(a1, a2, a3, a4 - 1, a5);
    a1[2 * v6] = _mpn_addmul_1((int)&a1[v6], (int)a2, v6, a3[v6]);
    result = _mpn_addmul_1((int)&a1[v6], (int)a3, a4, a2[v6]);
    a1[a4 + v6] = result;
    return result;
  }
  v8 = a4 >> 1;
  v9 = a4 >> 1;
  v10 = &a3[v9];
  v27 = v9 * 4;
  v11 = &a2[v9];
  v24 = &a3[v9];
  v29 = a4;
  v12 = &a1[a4];
  if ( a4 >> 1 <= 31 )
    _mpn_impn_mul_n_basecase((int)&a1[a4], v11, v10, a4 >> 1);
  else
    _mpn_impn_mul_n(&a1[a4], v11, v10, a4 >> 1, a5);
  if ( _mpn_cmp((int)v11, (int)a2, v8) < 0 )
  {
    _mpn_sub_n(a1, (unsigned int *)a2, v11, v8);
    v28 = 1;
  }
  else
  {
    _mpn_sub_n(a1, (unsigned int *)v11, a2, v8);
    v28 = 0;
  }
  v13 = (unsigned int *)((char *)a1 + v27);
  if ( _mpn_cmp((int)v24, (int)a3, v8) < 0 )
  {
    _mpn_sub_n((int *)((char *)a1 + v27), a3, v24, v8);
  }
  else
  {
    _mpn_sub_n((int *)((char *)a1 + v27), v24, a3, v8);
    v28 ^= 1u;
  }
  if ( v8 > 31 )
  {
    _mpn_impn_mul_n(a5, a1, v13, v8, &a5[v29]);
LABEL_14:
    for ( i = 0; i < v8; ++i )
      v13[i] = v12[i];
    goto LABEL_16;
  }
  _mpn_impn_mul_n_basecase((int)a5, a1, v13, v8);
  if ( v8 > 0 )
    goto LABEL_14;
LABEL_16:
  v25 = _mpn_add_n(v12, v12, &a1[v8 + a4], v8);
  if ( v28 )
    v26 = v25 - _mpn_sub_n(v13, v13, a5, a4);
  else
    v26 = v25 + _mpn_add_n(v13, v13, a5, a4);
  v30 = &a1[v8 + a4];
  if ( v8 <= 31 )
  {
    _mpn_impn_mul_n_basecase((int)a5, a2, a3, v8);
    v15 = v26 + _mpn_add_n(v13, v13, a5, a4);
    if ( !v15 )
      goto LABEL_20;
    v19 = &a1[v8 + a4];
    v16 = __CFADD__(*v30, v15);
    *v30 += v15;
    if ( !v16 )
      goto LABEL_20;
    goto LABEL_32;
  }
  _mpn_impn_mul_n(a5, a2, a3, v8, &a5[v29]);
  v18 = _mpn_add_n(v13, v13, a5, a4);
  v19 = &a1[v8 + a4];
  v20 = v26 + v18;
  if ( v20 )
  {
    v16 = __CFADD__(*v30, v20);
    *v30 += v20;
    if ( v16 )
    {
LABEL_32:
      v21 = 0;
      v22 = v8 - 1;
      do
      {
        if ( v22 == v21 )
          break;
        v23 = v19[v21 + 1] + 1;
        v19[++v21] = v23;
      }
      while ( !v23 );
      v8 = a4 >> 1;
LABEL_20:
      if ( v8 <= 0 )
        goto LABEL_22;
      goto LABEL_21;
    }
  }
  do
  {
LABEL_21:
    a1[v5] = a5[v5];
    ++v5;
  }
  while ( v8 > v5 );
LABEL_22:
  result = _mpn_add_n(v13, v13, (_DWORD *)((char *)a5 + v27), v8);
  if ( result )
  {
    v16 = __CFADD__(*v12, 1);
    result = *v12 + 1;
    *v12 = result;
    if ( v16 )
    {
      result = 0;
      do
      {
        if ( result == a4 - 1 )
          break;
        v17 = v12[result + 1] + 1;
        v12[++result] = v17;
      }
      while ( !v17 );
    }
  }
  return result;
}

//----- (08094BD0) --------------------------------------------------------
unsigned int *__cdecl _mpn_impn_sqr_n_basecase(int a1, unsigned int *a2, int a3)
{
  unsigned int v3; // edx
  _DWORD *v4; // eax
  int v5; // eax
  _DWORD *v6; // ebx
  unsigned int *v7; // edi
  unsigned int *result; // eax
  int i; // eax
  int v10; // [esp-10h] [ebp-3Ch]
  unsigned int v11; // [esp-4h] [ebp-30h]
  unsigned int *v12; // [esp+Ch] [ebp-20h]

  v3 = *a2;
  if ( *a2 > 1 )
  {
    v5 = _mpn_mul_1(a1, (int)a2, a3, *a2);
  }
  else
  {
    if ( *a2 == 1 )
    {
      if ( a3 > 0 )
      {
        for ( i = 0; ; v3 = a2[i] )
        {
          *(_DWORD *)(a1 + 4 * i++) = v3;
          if ( a3 == i )
            break;
        }
      }
    }
    else
    {
      v4 = (_DWORD *)a1;
      if ( a3 > 0 )
      {
        do
          *v4++ = 0;
        while ( (_DWORD *)(a1 + 4 * a3) != v4 );
      }
    }
    v5 = 0;
  }
  *(_DWORD *)(a1 + 4 * a3) = v5;
  v6 = (_DWORD *)(a1 + 4);
  v7 = a2 + 1;
  result = &a2[a3];
  v12 = result;
  if ( a3 > 1 )
  {
    do
    {
      while ( *v7 > 1 )
      {
        v11 = *v7++;
        v10 = (int)v6++;
        result = (unsigned int *)_mpn_addmul_1(v10, (int)a2, a3, v11);
        v6[a3 - 1] = result;
        if ( v12 == v7 )
          return result;
      }
      result = 0;
      if ( *v7 == 1 )
        result = (unsigned int *)_mpn_add_n(v6, v6, a2, a3);
      v6[a3] = result;
      ++v7;
      ++v6;
    }
    while ( v12 != v7 );
  }
  return result;
}

//----- (08094CE0) --------------------------------------------------------
unsigned int __cdecl _mpn_impn_sqr_n(unsigned int *a1, unsigned int *a2, int a3, _DWORD *a4)
{
  int v4; // ebx
  int v5; // ebx
  unsigned int *v6; // edi
  unsigned int result; // eax
  int v8; // esi
  unsigned int *v9; // edx
  int i; // eax
  unsigned int *v11; // edx
  _BOOL4 v12; // eax
  unsigned int *v13; // edx
  int v14; // eax
  bool v15; // cf
  unsigned int v16; // edi
  _BOOL4 v17; // eax
  int v18; // eax
  int v19; // eax
  int v20; // esi
  int v21; // ecx
  unsigned int *v22; // [esp+8h] [ebp-34h]
  unsigned int *v23; // [esp+8h] [ebp-34h]
  int v24; // [esp+Ch] [ebp-30h]
  int v25; // [esp+10h] [ebp-2Ch]
  unsigned int *v26; // [esp+10h] [ebp-2Ch]
  _BOOL4 v27; // [esp+10h] [ebp-2Ch]
  unsigned int *v28; // [esp+10h] [ebp-2Ch]
  _BOOL4 v29; // [esp+14h] [ebp-28h]
  int v30; // [esp+14h] [ebp-28h]
  unsigned int *v31; // [esp+18h] [ebp-24h]
  unsigned int *v32; // [esp+1Ch] [ebp-20h]

  v4 = a3 & 1;
  if ( (a3 & 1) != 0 )
  {
    v5 = a3 - 1;
    if ( a3 - 1 <= 31 )
      _mpn_impn_sqr_n_basecase((int)a1, a2, a3 - 1);
    else
      _mpn_impn_sqr_n(a1, a2, a3 - 1, a4);
    v6 = &a2[v5];
    a1[2 * v5] = _mpn_addmul_1((int)&a1[v5], (int)a2, v5, *v6);
    result = _mpn_addmul_1((int)&a1[v5], (int)a2, a3, *v6);
    a1[a3 + v5] = result;
    return result;
  }
  v8 = a3 >> 1;
  v25 = a3;
  v24 = a3 >> 1;
  v22 = &a2[v24];
  if ( a3 >> 1 <= 31 )
    _mpn_impn_sqr_n_basecase((int)&a1[a3], &a2[v24], a3 >> 1);
  else
    _mpn_impn_sqr_n(&a1[a3], v22, a3 >> 1, a4);
  if ( _mpn_cmp((int)v22, (int)a2, v8) < 0 )
    _mpn_sub_n(a1, a2, v22, v8);
  else
    _mpn_sub_n(a1, v22, a2, v8);
  if ( v8 > 31 )
  {
    _mpn_impn_sqr_n(a4, a1, v8, &a4[v25]);
    v9 = &a1[a3];
  }
  else
  {
    _mpn_impn_sqr_n_basecase((int)a4, a1, v8);
    v9 = &a1[a3];
    if ( v8 <= 0 )
    {
      v32 = &a1[v8 + a3];
      v27 = _mpn_add_n(&a1[a3], &a1[a3], v32, v8);
      v23 = &a1[v24];
      v30 = v27 - _mpn_sub_n(&a1[v24], &a1[v24], a4, a3);
      v11 = &a1[a3];
      goto LABEL_27;
    }
  }
  for ( i = 0; i < v8; ++i )
    a1[v24 + i] = v9[i];
  v23 = &a1[v24];
  v32 = &a1[v8 + a3];
  v31 = v9;
  v29 = _mpn_add_n(v9, v9, v32, v8);
  v30 = v29 - _mpn_sub_n(v23, v23, a4, a3);
  v11 = v31;
  if ( v8 > 31 )
  {
    _mpn_impn_sqr_n(a4, a2, v8, &a4[v25]);
    v12 = _mpn_add_n(v23, v23, a4, a3);
    v13 = v31;
    v14 = v30 + v12;
    if ( !v14 || (v15 = __CFADD__(*v32, v14), *v32 += v14, !v15) )
    {
      do
      {
LABEL_17:
        a1[v4] = a4[v4];
        ++v4;
      }
      while ( v8 > v4 );
      goto LABEL_18;
    }
    goto LABEL_34;
  }
LABEL_27:
  v28 = v11;
  _mpn_impn_sqr_n_basecase((int)a4, a2, v8);
  v17 = _mpn_add_n(v23, v23, a4, a3);
  v13 = v28;
  v18 = v30 + v17;
  if ( !v18 || (v15 = __CFADD__(*v32, v18), *v32 += v18, !v15) )
  {
    if ( v8 <= 0 )
      goto LABEL_18;
    goto LABEL_29;
  }
LABEL_34:
  v19 = 0;
  v20 = v8 - 1;
  do
  {
    if ( v20 == v19 )
      break;
    v21 = v32[v19 + 1] + 1;
    v32[++v19] = v21;
  }
  while ( !v21 );
  v8 = a3 >> 1;
  v4 = a3 & 1;
  if ( a3 >> 1 > 0 )
  {
LABEL_29:
    a1[v4] = a4[v4];
    if ( v8 <= ++v4 )
      goto LABEL_18;
    goto LABEL_17;
  }
LABEL_18:
  v26 = v13;
  result = _mpn_add_n(v23, v23, &a4[v24], v8);
  if ( result )
  {
    v15 = __CFADD__(*v26, 1);
    result = *v26 + 1;
    *v26 = result;
    if ( v15 )
    {
      result = 0;
      do
      {
        if ( result == a3 - 1 )
          break;
        v16 = v26[result + 1];
        v26[++result] = v16 + 1;
      }
      while ( v16 == -1 );
    }
  }
  return result;
}

//----- (080950A0) --------------------------------------------------------
unsigned int __cdecl _mpn_mul_n(unsigned int *a1, unsigned int *a2, unsigned int *a3, int a4)
{
  int v4; // edi
  _DWORD *v5; // ebx
  int v6; // edi
  void *v7; // esp
  int v9; // ebx
  _DWORD *v10; // edi
  __int16 v11; // bx
  int v12; // ebx
  void *v13; // esp
  _BYTE v14[4]; // [esp-1004h] [ebp-103Ch]
  _DWORD v15[1024]; // [esp-1000h] [ebp-1038h] BYREF
  _BYTE v16[12]; // [esp+0h] [ebp-38h] BYREF
  unsigned int v17; // [esp+Ch] [ebp-2Ch]
  unsigned int v18; // [esp+1Ch] [ebp-1Ch]

  v18 = __readgsdword(0x14u);
  if ( a2 == a3 )
  {
    if ( a4 <= 31 )
    {
      _mpn_impn_sqr_n_basecase((int)a1, a2, a4);
    }
    else
    {
      v9 = 8 * a4 + 27;
      v10 = &v16[-(v9 & 0xFFFFF000)];
      v11 = v9 & 0xFFF0;
      if ( v16 != (_BYTE *)v10 )
      {
        while ( v15 != v10 )
          ;
      }
      v12 = v11 & 0xFFF;
      if ( v12 )
      {
        v13 = alloca(v12);
        *(_DWORD *)&v14[v12] = *(_DWORD *)&v14[v12];
      }
      _mpn_impn_sqr_n(a1, a2, a4, v15);
    }
  }
  else if ( a4 <= 31 )
  {
    _mpn_impn_mul_n_basecase((int)a1, (int *)a2, a3, a4);
  }
  else
  {
    v4 = 8 * a4 + 27;
    v17 = v4 & 0xFFFFFFF0;
    v5 = &v16[-(v4 & 0xFFFFF000)];
    if ( v16 != (_BYTE *)v5 )
    {
      while ( v15 != v5 )
        ;
    }
    v6 = v17 & 0xFFF;
    if ( (v17 & 0xFFF) != 0 )
    {
      v7 = alloca(v6);
      *(_DWORD *)&v14[v6] = *(_DWORD *)&v14[v6];
    }
    _mpn_impn_mul_n((int *)a1, (int *)a2, a3, a4, v15);
  }
  return __readgsdword(0x14u) ^ v18;
}

//----- (080951D0) --------------------------------------------------------
_BOOL4 __cdecl _mpn_sub_n(_DWORD *a1, unsigned int *a2, _DWORD *a3, unsigned int a4)
{
  unsigned int v7; // ecx
  bool v8; // cf
  unsigned int v9; // ett
  unsigned int v10; // eax
  unsigned int v11; // ett
  unsigned int v12; // eax
  unsigned int v13; // ett
  unsigned int v14; // eax
  unsigned int v15; // ett
  unsigned int v16; // eax
  unsigned int v17; // ett
  unsigned int v18; // eax
  unsigned int v19; // ett
  unsigned int v20; // eax
  unsigned int v21; // ett
  unsigned int v22; // eax
  unsigned int v23; // ett

  v7 = a4 >> 3;
  v8 = 0;
  if ( (-a4 & 7) != 0 )
    __asm { jmp     eax }
  do
  {
    v9 = v8 + *a3;
    v8 = *a2 < v9;
    *a1 = *a2 - v9;
    v10 = a2[1];
    v11 = v8 + a3[1];
    v8 = v10 < v11;
    a1[1] = v10 - v11;
    v12 = a2[2];
    v13 = v8 + a3[2];
    v8 = v12 < v13;
    a1[2] = v12 - v13;
    v14 = a2[3];
    v15 = v8 + a3[3];
    v8 = v14 < v15;
    a1[3] = v14 - v15;
    v16 = a2[4];
    v17 = v8 + a3[4];
    v8 = v16 < v17;
    a1[4] = v16 - v17;
    v18 = a2[5];
    v19 = v8 + a3[5];
    v8 = v18 < v19;
    a1[5] = v18 - v19;
    v20 = a2[6];
    v21 = v8 + a3[6];
    v8 = v20 < v21;
    a1[6] = v20 - v21;
    v22 = a2[7];
    v23 = v8 + a3[7];
    v8 = v22 < v23;
    a1[7] = v22 - v23;
    a1 += 8;
    a2 += 8;
    a3 += 8;
    --v7;
  }
  while ( v7 );
  return v8;
}

//----- (080952A0) --------------------------------------------------------
int __cdecl _mpn_submul_1(int a1, int a2, int a3, unsigned int a4)
{
  int v4; // edi
  int v5; // ecx
  int v6; // ebp
  unsigned __int64 v7; // rax
  bool v8; // cf
  int v9; // edx

  v4 = a1 + 4 * a3;
  v5 = -a3;
  v6 = 0;
  do
  {
    v7 = (unsigned int)v6 + a4 * (unsigned __int64)*(unsigned int *)(a2 + 4 * a3 + 4 * v5);
    v8 = *(_DWORD *)(v4 + 4 * v5) < (unsigned int)v7;
    *(_DWORD *)(v4 + 4 * v5) -= v7;
    v9 = v8 + HIDWORD(v7);
    v6 = v9;
    ++v5;
  }
  while ( v5 );
  return v9;
}

//----- (080952F0) --------------------------------------------------------
int __cdecl _mpn_extract_double(
        unsigned int *a1,
        int a2,
        _DWORD *a3,
        unsigned int *a4,
        unsigned int a5,
        unsigned int a6)
{
  unsigned int v6; // edi
  int result; // eax
  unsigned int v8; // edx
  signed int v9; // edx
  unsigned int v10; // edx
  unsigned int v11; // edx

  v6 = a6 & 0xFFFFF;
  *a4 = a6 >> 31;
  *a3 = ((a6 >> 20) & 0x7FF) - 1023;
  a1[1] = a6 & 0xFFFFF;
  *a1 = a5;
  if ( (a6 & 0x7FF00000) != 0 )
  {
    result = 2;
    a1[1] = v6 | 0x100000;
    return result;
  }
  if ( !a5 )
  {
    if ( !v6 )
    {
      *a3 = 0;
      return 2;
    }
    goto LABEL_10;
  }
  if ( v6 )
  {
LABEL_10:
    _BitScanReverse(&v10, v6);
    v11 = (v10 ^ 0x1F) - 11;
    *a1 = a5 << v11;
    a1[1] = (v6 << v11) | (a5 >> (32 - v11));
    *a3 = -1022 - v11;
    return 2;
  }
  _BitScanReverse(&v8, a5);
  v9 = v8 ^ 0x1F;
  if ( v9 <= 10 )
  {
    a1[1] = a5 >> (11 - v9);
    *a1 = a5 << (v9 + 21);
  }
  else
  {
    *a1 = 0;
    a1[1] = a5 << (v9 - 11);
  }
  *a3 = -1043 - v9;
  return 2;
}

//----- (08095400) --------------------------------------------------------
int __cdecl _mpn_extract_long_double(int a1, int a2, int a3, int a4, long double a5)
{
  int v6; // eax
  unsigned int v7; // edi
  unsigned int v8; // ecx

  *(_DWORD *)a4 = BYTE9(a5) >> 7;
  *(_DWORD *)a3 = (WORD4(a5) & 0x7FFF) - 0x3FFF;
  *(_DWORD *)a1 = LODWORD(a5);
  *(_DWORD *)(a1 + 4) = DWORD1(a5);
  if ( (WORD4(a5) & 0x7FFF) != 0 )
  {
    if ( __PAIR64__(LODWORD(a5), DWORD1(a5)) )
      return 2;
    if ( (WORD4(a5) & 0x7FFF) != 0x7FFF )
    {
LABEL_4:
      *(_DWORD *)a3 = 0;
      return 2;
    }
    return 2;
  }
  else
  {
    if ( LODWORD(a5) )
    {
      v6 = DWORD1(a5) & 0x7FFFFFFF;
      if ( (DWORD1(a5) & 0x7FFFFFFF) == 0 )
      {
        _BitScanReverse(&v8, LODWORD(a5));
        *(_DWORD *)a1 = 0;
        v8 ^= 0x1Fu;
        *(_DWORD *)(a1 + 4) = LODWORD(a5) << v8;
        *(_DWORD *)a3 = -16414 - v8;
        return 2;
      }
    }
    else
    {
      if ( !DWORD1(a5) )
        goto LABEL_4;
      v6 = DWORD1(a5) & 0x7FFFFFFF;
      if ( (DWORD1(a5) & 0x7FFFFFFF) == 0 )
      {
        *(_DWORD *)(a1 + 4) = 0x80000000;
        *(_DWORD *)a3 = -16382;
        return 2;
      }
    }
    _BitScanReverse(&v7, v6);
    *(_DWORD *)(a1 + 4) = (LODWORD(a5) >> (32 - (v7 ^ 0x1F))) | (v6 << (v7 ^ 0x1F));
    *(_DWORD *)a1 = LODWORD(a5) << (v7 ^ 0x1F);
    *(_DWORD *)a3 = -16382 - (v7 ^ 0x1F);
    return 2;
  }
}

//----- (08095530) --------------------------------------------------------
int __cdecl _mpn_extract_float128(_DWORD *a1, int a2, _DWORD *a3, int *a4, __int128 a5)
{
  __m128i si128; // xmm0
  unsigned __int16 v6; // bp
  _DWORD *v7; // eax
  int v8; // ebx
  int v9; // esi
  int v10; // edi
  int v11; // edi
  int v12; // edx
  int v13; // esi
  unsigned int v14; // ecx
  unsigned int v15; // edx
  unsigned int v16; // edx
  unsigned int v17; // ebp
  _DWORD *v18; // edx
  _DWORD *v19; // edi
  int v20; // ecx
  int v21; // edx
  int v23; // edx

  si128 = _mm_load_si128((const __m128i *)&a5);
  v6 = WORD6(a5);
  v7 = a1;
  v8 = a5;
  v9 = DWORD2(a5);
  *a4 = (unsigned __int8)si128.m128i_i8[15] >> 7;
  *a3 = (si128.m128i_i16[7] & 0x7FFF) - 0x3FFF;
  v10 = DWORD1(a5);
  *a1 = v8;
  a1[1] = v10;
  a1[2] = v9;
  a1[3] = v6;
  if ( (_mm_extract_epi16(si128, 7) & 0x7FFF) == 0 )
  {
    if ( v9 | v8 | v10 )
    {
      if ( !v6 )
      {
        if ( v9 )
        {
          v13 = 1;
          v12 = 2;
          v11 = 2;
        }
        else
        {
          v11 = v10 != 0;
          v12 = v11;
          v13 = 3 - v11;
        }
LABEL_6:
        v14 = a1[v12];
        _BitScanReverse(&v15, v14);
        v16 = v15 ^ 0x1F;
        v17 = v16 - 15;
        if ( (int)(v16 - 15) < 0 )
        {
          v17 = v16 + 17;
          v13 = 2 - v11;
        }
        else
        {
          if ( v16 == 15 )
          {
            v18 = a1 + 3;
            a1[3] = v14;
            v19 = &a1[v13];
            if ( v19 != a1 + 3 )
            {
              do
              {
                v20 = v18[-v13 - 1];
                *--v18 = v20;
              }
              while ( v19 != v18 );
            }
            v21 = v13 - 1;
LABEL_11:
            if ( v21 < 0 )
            {
LABEL_13:
              *a3 = -16382 - 32 * v13 - v17;
              return 4;
            }
            do
LABEL_12:
              v7[v21--] = 0;
            while ( v21 != -1 );
            goto LABEL_13;
          }
          if ( v13 == 3 )
          {
            v21 = 2;
            a1[3] = v8 << v17;
            goto LABEL_12;
          }
        }
        v23 = 3;
        do
        {
          v7 = a1;
          a1[v23] = (a1[v23 - v13 - 1] >> (32 - v17)) | (a1[v23 - v13] << v17);
          --v23;
        }
        while ( v13 < v23 );
        v21 = v13 - 1;
        a1[v13] = *a1 << v17;
        goto LABEL_11;
      }
    }
    else if ( !v6 )
    {
      *a3 = 0;
      return 4;
    }
    v13 = 0;
    v12 = 3;
    v11 = 3;
    goto LABEL_6;
  }
  a1[3] = v6 | 0x10000;
  return 4;
}

//----- (08095740) --------------------------------------------------------
int __cdecl itoa_word(unsigned int a1, int a2, unsigned int a3, int a4)
{
  char *v6; // esi

  v6 = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ";
  if ( !a4 )
    v6 = itoa_lower_digits;
  switch ( a3 )
  {
    case 0xAu:
      while ( 1 )
      {
        *(_BYTE *)--a2 = v6[a1 % 0xA];
        if ( a1 <= 9 )
          break;
        a1 /= 0xAu;
      }
      return a2;
    case 0x10u:
      while ( 1 )
      {
        *(_BYTE *)--a2 = v6[a1 & 0xF];
        if ( a1 <= 0xF )
          break;
        a1 >>= 4;
      }
      return a2;
    case 8u:
      while ( 1 )
      {
        *(_BYTE *)--a2 = v6[a1 & 7];
        if ( a1 <= 7 )
          break;
        a1 >>= 3;
      }
      return a2;
    default:
      while ( 1 )
      {
        *(_BYTE *)--a2 = v6[a1 % a3];
        if ( a1 < a3 )
          break;
        a1 /= a3;
      }
      return a2;
  }
}

//----- (08095840) --------------------------------------------------------
_BYTE *__cdecl itoa(unsigned __int64 a1, _BYTE *a2, unsigned int a3, int a4)
{
  char *v4; // ebp
  unsigned int v5; // ebx
  unsigned int v6; // edi
  unsigned int v7; // eax
  int v8; // edx
  unsigned __int64 v9; // rtt
  char *v10; // edi
  int v11; // edx
  _BYTE *v12; // edi
  _BYTE *v13; // ecx
  int v14; // edx
  _BYTE *v16; // esi
  char v17; // al
  char v18; // al
  int v19; // eax
  _BYTE *v20; // eax
  char v21; // si
  int v22; // eax
  int v23; // eax
  int v24; // eax
  int v25; // [esp+0h] [ebp-3Ch]
  int v26; // [esp+0h] [ebp-3Ch]
  unsigned int v27; // [esp+Ch] [ebp-30h]
  int v28; // [esp+10h] [ebp-2Ch]
  unsigned int v29; // [esp+14h] [ebp-28h]
  int v30; // [esp+18h] [ebp-24h]
  unsigned int v31; // [esp+1Ch] [ebp-20h]

  v4 = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ";
  v31 = __readgsdword(0x14u);
  v5 = a1;
  if ( !a4 )
    v4 = itoa_lower_digits;
  if ( a3 == 8 )
  {
    v16 = a2;
    v13 = a2;
    if ( HIDWORD(a1) )
    {
      v13 = a2 - 10;
      do
      {
        v17 = v5;
        --v16;
        v5 >>= 3;
        *v16 = v4[v17 & 7];
      }
      while ( v13 != v16 );
      v5 |= (4 * BYTE4(a1)) & 4;
      if ( HIDWORD(a1) >> 1 )
      {
        v18 = v4[v5];
        v5 = HIDWORD(a1) >> 1;
        *(a2 - 11) = v18;
        v13 = a2 - 11;
      }
    }
    do
    {
      --v13;
      v19 = v5 & 7;
      v5 >>= 3;
      *v13 = v4[v19];
    }
    while ( v5 );
  }
  else if ( a3 == 16 )
  {
    v20 = a2;
    v13 = a2;
    if ( HIDWORD(a1) )
    {
      v13 = a2 - 8;
      do
      {
        v21 = v5;
        --v20;
        v5 >>= 4;
        *v20 = v4[v21 & 0xF];
      }
      while ( v13 != v20 );
      v5 = HIDWORD(a1);
    }
    do
    {
      --v13;
      v22 = v5 & 0xF;
      v5 >>= 4;
      *v13 = v4[v22];
    }
    while ( v5 );
  }
  else
  {
    if ( HIDWORD(a1) )
    {
      v6 = *((_DWORD *)&itoa_base_table + 3 * a3 - 4);
      if ( v6 > HIDWORD(a1) )
      {
        v25 = 2;
        v28 = a1 / v6;
        v5 = a1 % v6;
        v29 = v5;
      }
      else
      {
        v27 = HIDWORD(a1) / v6;
        LODWORD(v9) = a1;
        HIDWORD(v9) = HIDWORD(a1) % v6;
        v7 = v9 / v6;
        v8 = v9 % v6;
        v10 = (char *)&itoa_base_table + 12 * a3 - 24;
        v5 = v8;
        v30 = v8;
        v25 = 3;
        v11 = __PAIR64__(v27, v7) % *((unsigned int *)v10 + 2);
        v28 = __PAIR64__(v27, v7) / *((unsigned int *)v10 + 2);
        v29 = v11;
      }
    }
    else
    {
      v28 = a1;
      v25 = 1;
    }
    v12 = a2;
    v26 = v25 - 1;
    v13 = a2;
    if ( v5 )
      goto LABEL_11;
LABEL_34:
    v14 = 0;
    while ( v26 )
    {
      v23 = *((char *)&itoa_base_table + 12 * a3 - 19);
      if ( v23 <= v14 )
      {
        v12 = v13;
      }
      else
      {
        v12 = &v13[v14 - v23];
        do
          *--v13 = 48;
        while ( v12 != v13 );
      }
      v24 = v26;
      v13 = v12;
      --v26;
      v5 = *(&v27 + v24);
      if ( !v5 )
        goto LABEL_34;
LABEL_11:
      while ( 1 )
      {
        *--v13 = v4[v5 % a3];
        v14 = v12 - v13;
        if ( v5 < a3 )
          break;
        v5 /= a3;
      }
    }
    if ( a2 == v13 )
      *--v13 = 48;
  }
  return v13;
}

//----- (08095AB0) --------------------------------------------------------
char *__cdecl fitoa_word(unsigned int a1, _BYTE *a2, unsigned int a3, int a4)
{
  int *v4; // eax
  int *v5; // esi
  _BYTE *v6; // edi
  int v8[8]; // [esp+1Ch] [ebp-20h] BYREF

  v8[0] = __readgsdword(0x14u);
  v4 = (int *)itoa_word(a1, (int)v8, a3, a4);
  if ( v4 >= v8 )
    return a2;
  v5 = v4;
  v6 = a2;
  do
  {
    *v6 = *(_BYTE *)v5;
    v5 = (int *)((char *)v5 + 1);
    ++v6;
  }
  while ( v5 != v8 );
  return &a2[(char *)v5 - (char *)v4];
}

//----- (08095B20) --------------------------------------------------------
_BYTE *__cdecl fitoa(unsigned __int64 a1, _BYTE *a2, unsigned int a3, int a4)
{
  int *v4; // eax
  int *v5; // esi
  _BYTE *v6; // edi
  int v8[8]; // [esp+38h] [ebp-20h] BYREF

  v8[0] = __readgsdword(0x14u);
  v4 = (int *)itoa(a1, v8, a3, a4);
  if ( v4 >= v8 )
    return a2;
  v5 = v4;
  v6 = a2;
  do
  {
    *v6 = *(_BYTE *)v5;
    v5 = (int *)((char *)v5 + 1);
    ++v6;
  }
  while ( v5 != v8 );
  return &a2[(char *)v5 - (char *)v4];
}

//----- (08095B90) --------------------------------------------------------
_DWORD *__cdecl itowa(unsigned __int64 a1, _DWORD *a2, unsigned int a3, int a4)
{
  _DWORD *v4; // ebp
  const char *v5; // edi
  unsigned int v6; // ecx
  unsigned int v7; // ebx
  unsigned int v8; // eax
  int v9; // edx
  unsigned __int64 v10; // rtt
  char *v11; // ebx
  int v12; // edx
  _DWORD *v13; // ebx
  int v14; // ebp
  int v15; // ecx
  _DWORD *v16; // eax
  _DWORD *v17; // eax
  char v18; // si
  int v19; // eax
  int v20; // eax
  char v22; // al
  int v23; // eax
  int v24; // [esp+0h] [ebp-3Ch]
  unsigned int v25; // [esp+Ch] [ebp-30h]
  int v26; // [esp+10h] [ebp-2Ch]
  unsigned int v27; // [esp+14h] [ebp-28h]
  int v28; // [esp+18h] [ebp-24h]
  unsigned int v29; // [esp+1Ch] [ebp-20h]

  v4 = a2;
  v29 = __readgsdword(0x14u);
  v5 = "0";
  if ( !a4 )
    v5 = "0";
  v6 = a1;
  if ( a3 == 8 )
  {
    v13 = a2;
    if ( HIDWORD(a1) )
    {
      v13 = a2 - 10;
      v17 = a2;
      do
      {
        v18 = v6;
        --v17;
        v6 >>= 3;
        *v17 = *(_DWORD *)&v5[4 * (v18 & 7)];
      }
      while ( v17 != v13 );
      v6 |= (4 * BYTE4(a1)) & 4;
      if ( HIDWORD(a1) >> 1 )
      {
        v19 = *(_DWORD *)&v5[4 * v6];
        v13 = a2 - 11;
        v6 = HIDWORD(a1) >> 1;
        *(a2 - 11) = v19;
      }
    }
    do
    {
      --v13;
      v20 = v6 & 7;
      v6 >>= 3;
      *v13 = *(_DWORD *)&v5[4 * v20];
    }
    while ( v6 );
  }
  else if ( a3 == 16 )
  {
    v13 = a2;
    if ( HIDWORD(a1) )
    {
      v13 = a2 - 8;
      do
      {
        v22 = v6;
        --v4;
        v6 >>= 4;
        *v4 = *(_DWORD *)&v5[4 * (v22 & 0xF)];
      }
      while ( v13 != v4 );
      v6 = HIDWORD(a1);
    }
    do
    {
      --v13;
      v23 = v6 & 0xF;
      v6 >>= 4;
      *v13 = *(_DWORD *)&v5[4 * v23];
    }
    while ( v6 );
  }
  else
  {
    if ( HIDWORD(a1) )
    {
      v7 = *((_DWORD *)&GLOBAL_OFFSET_TABLE_ + 3 * a3 - 22252);
      if ( v7 > HIDWORD(a1) )
      {
        v24 = 2;
        v26 = a1 / v7;
        v6 = a1 % v7;
        v27 = v6;
      }
      else
      {
        v25 = HIDWORD(a1) / v7;
        LODWORD(v10) = a1;
        HIDWORD(v10) = HIDWORD(a1) % v7;
        v8 = v10 / v7;
        v9 = v10 % v7;
        v11 = (char *)&GLOBAL_OFFSET_TABLE_ + 12 * a3 - 89016;
        v6 = v9;
        v28 = v9;
        v24 = 3;
        v12 = __PAIR64__(v25, v8) % *((unsigned int *)v11 + 2);
        v26 = __PAIR64__(v25, v8) / *((unsigned int *)v11 + 2);
        v27 = v12;
      }
    }
    else
    {
      v26 = a1;
      v24 = 1;
    }
    v13 = a2;
    while ( 1 )
    {
      --v24;
      v14 = 0;
      if ( v6 )
      {
        while ( 1 )
        {
          --v13;
          ++v14;
          *v13 = *(_DWORD *)&v5[4 * (v6 % a3)];
          if ( v6 < a3 )
            break;
          v6 /= a3;
        }
      }
      if ( !v24 )
        break;
      v15 = *((char *)&GLOBAL_OFFSET_TABLE_ + 12 * a3 - 89011);
      if ( v15 > v14 )
      {
        v16 = v13;
        do
          *--v16 = 48;
        while ( v16 != &v13[v14 - v15] );
        v13 += v14 - v15;
      }
      v6 = *(&v25 + v24);
    }
  }
  return v13;
}
// 80CE000: using guessed type _TBYTE GLOBAL_OFFSET_TABLE_;

//----- (08095DC0) --------------------------------------------------------
void *init()
{
  void *result; // eax

  result = &last_result;
  static_buf = (int)&last_result;
  return result;
}
// 80CFA88: using guessed type int static_buf;

//----- (08095E10) --------------------------------------------------------
int *_dlerror()
{
  unsigned __int8 *v0; // eax
  bool v1; // cf
  bool v2; // zf
  int v3; // ecx
  int *v4; // edi
  _BYTE *v5; // esi
  int *result; // eax
  signed int v7; // edx
  unsigned __int8 *v8; // esi
  unsigned __int8 *v9; // eax
  _BYTE *v10; // ecx
  unsigned __int8 *v11; // edx
  int v12; // eax
  bool v13; // cf
  bool v14; // zf
  int v15; // ecx
  int *v16; // edi
  _BYTE *v17; // esi
  signed int *v18; // ebp
  unsigned __int8 *v19; // eax
  _BYTE *v20; // ecx
  unsigned __int8 *v21; // edx
  int v22; // [esp+4h] [ebp-38h]
  int *v23[9]; // [esp+18h] [ebp-24h] BYREF

  v23[1] = (int *)__readgsdword(0x14u);
  v23[0] = 0;
  if ( once )
  {
    v18 = (signed int *)static_buf;
    if ( static_buf )
      goto LABEL_3;
    goto LABEL_27;
  }
  v18 = (signed int *)&last_result;
  static_buf = (int)&last_result;
  once = 2;
  if ( !&last_result )
LABEL_27:
    v18 = (signed int *)&last_result;
LABEL_3:
  v0 = (unsigned __int8 *)v18[4];
  if ( v18[1] )
  {
    v1 = 0;
    v2 = v0 == 0;
    if ( v0 )
    {
      v3 = 14;
      v4 = (int *)"out of memory";
      v5 = (_BYTE *)v18[4];
      do
      {
        if ( !v3 )
          break;
        v1 = *v5 < *(_BYTE *)v4;
        v2 = *v5++ == *(_BYTE *)v4;
        v4 = (int *)((char *)v4 + 1);
        --v3;
      }
      while ( v2 );
      if ( (!v1 && !v2) != v1 )
        free((int)v18, v4, v18[4]);
      v18[4] = 0;
    }
    return v23[0];
  }
  if ( !v0 )
    return v23[0];
  v7 = *v18;
  v23[0] = (int *)v18[4];
  if ( v7 )
  {
    v8 = strerror(v7);
    v9 = dcgettext("libc", (unsigned __int8 *)v18[4], 5u);
    v10 = (_BYTE *)v18[3];
    v11 = byte_80B41F9;
    if ( *v10 )
      v11 = ": ";
    v12 = asprintf(v23, (unsigned int *)"%s%s%s: %s", v10, v11, v9, v8);
  }
  else
  {
    v19 = dcgettext("libc", v0, 5u);
    v20 = (_BYTE *)v18[3];
    v21 = byte_80B41F9;
    if ( *v20 )
      v21 = ": ";
    v12 = asprintf(v23, (unsigned int *)"%s%s%s", v20, v21, v19, v22);
  }
  v13 = v12 != -1;
  v14 = v12 == -1;
  if ( v12 == -1 )
  {
    result = v23[0];
  }
  else
  {
    v15 = 14;
    v16 = (int *)"out of memory";
    v17 = (_BYTE *)v18[4];
    do
    {
      if ( !v15 )
        break;
      v13 = *v17 < *(_BYTE *)v16;
      v14 = *v17++ == *(_BYTE *)v16;
      v16 = (int *)((char *)v16 + 1);
      --v15;
    }
    while ( v14 );
    if ( (!v13 && !v14) != v13 )
      free((int)v18, v16, v18[4]);
    result = v23[0];
    v18[4] = (signed int)v23[0];
  }
  v18[1] = 1;
  return result;
}
// 809602A: variable 'v22' is possibly undefined
// 80B41F9: using guessed type unsigned __int8 byte_80B41F9[1671];
// 80CFA80: using guessed type int once;
// 80CFA88: using guessed type int static_buf;

//----- (08096090) --------------------------------------------------------
const char **__usercall check_free_isra_0@<eax>(const char **result@<eax>, int a2@<ebp>)
{
  bool v2; // cf
  bool v3; // zf
  int v4; // ecx
  int *v5; // edi
  const char *v6; // esi
  const char **v7; // esi

  v2 = 0;
  v3 = *result == 0;
  if ( *result )
  {
    v4 = 14;
    v5 = (int *)"out of memory";
    v6 = *result;
    do
    {
      if ( !v4 )
        break;
      v2 = *v6 < *(_BYTE *)v5;
      v3 = *v6++ == *(_BYTE *)v5;
      v5 = (int *)((char *)v5 + 1);
      --v4;
    }
    while ( v3 );
    if ( (!v2 && !v3) != v2 )
    {
      v7 = result;
      result = (const char **)free(a2, v5, (int)*result);
      *v7 = 0;
    }
  }
  return result;
}

//----- (080960E0) --------------------------------------------------------
int __usercall free_key_mem@<eax>(int ebp0@<ebp>, int *a2@<edi>, int a3)
{
  check_free_isra_0((const char **)(a3 + 16), ebp0);
  free(ebp0, a2, a3);
  return 0;
}

//----- (08096130) --------------------------------------------------------
int __usercall dlerror_run@<eax>(int a1@<ebp>, int *edi0@<edi>, void (__cdecl *a3)(int), int a4)
{
  int result; // eax
  unsigned __int8 *v5; // esi

  if ( once )
  {
    v5 = (unsigned __int8 *)static_buf;
    if ( static_buf )
      goto LABEL_3;
  }
  else
  {
    v5 = (unsigned __int8 *)&last_result;
    static_buf = (int)&last_result;
    once = 2;
    if ( &last_result )
      goto LABEL_3;
  }
  v5 = calloc(edi0, 1u, 0x14u);
  if ( !v5 )
    v5 = (unsigned __int8 *)&last_result;
LABEL_3:
  if ( *((_DWORD *)v5 + 4) )
  {
    if ( v5[8] )
      free(a1, edi0, *((_DWORD *)v5 + 4));
    *((_DWORD *)v5 + 4) = 0;
  }
  *(_DWORD *)v5 = dl_catch_error(a1, (_DWORD *)v5 + 3, (_DWORD *)v5 + 4, (bool *)v5 + 8, a3, a4);
  LOBYTE(result) = *((_DWORD *)v5 + 4) != 0;
  *((_DWORD *)v5 + 1) = *((_DWORD *)v5 + 4) == 0;
  return (unsigned __int8)result;
}
// 80CFA80: using guessed type int once;
// 80CFA88: using guessed type int static_buf;

//----- (080962C0) --------------------------------------------------------
_DWORD *__usercall _libc_register_dlfcn_hook@<eax>(int ebp0@<ebp>, int *a2@<edi>, int a3)
{
  _DWORD *result; // eax

  result = (_DWORD *)_libc_dlsym_private(ebp0, a2, a3, (int)"_dlfcn_hook");
  if ( result )
    *result = &dlfcn_hooks;
  return result;
}
// 80CEF20: using guessed type int (__cdecl *dlfcn_hooks)(int, int, int);

//----- (08096300) --------------------------------------------------------
int __cdecl _dladdr(unsigned int a1, _DWORD *a2)
{
  return dl_addr(a1, a2, 0, 0);
}

//----- (08096320) --------------------------------------------------------
int __cdecl _dladdr1(unsigned int a1, _DWORD *a2, unsigned int *a3, int a4)
{
  unsigned int *v6; // [esp+10h] [ebp+10h]

  if ( a4 == 1 )
  {
    v6 = a3;
    goto LABEL_3;
  }
  v6 = 0;
  if ( a4 != 2 )
LABEL_3:
    a3 = 0;
  return dl_addr(a1, a2, a3, v6);
}

//----- (08096360) --------------------------------------------------------
void __cdecl dlinfo_doit(int a1)
{
  if ( *(_DWORD *)(a1 + 8) <= 0xAu )
    __asm { jmp     ecx }
  dl_signal_error(0, 0, 0, (unsigned int *)"unsupported dlinfo request");
}

//----- (08096470) --------------------------------------------------------
void __fastcall sub_8096470(int a1, int a2)
{
  dl_tls_get_addr_soft(a2);
  JUMPOUT(0x80963A8);
}
// 809647C: control flows out of bounds to 80963A8

//----- (08096490) --------------------------------------------------------
int __usercall _dlinfo@<eax>(int a1@<ebp>, int *a2@<edi>, int a3, int a4, int a5, int a6)
{
  int v7[8]; // [esp+0h] [ebp-20h] BYREF

  v7[4] = __readgsdword(0x14u);
  v7[0] = a6;
  v7[1] = a3;
  v7[2] = a4;
  v7[3] = a5;
  return -(dlerror_run(a1, a2, dlinfo_doit, (int)v7) != 0);
}

//----- (08096510) --------------------------------------------------------
int __cdecl dlmopen_doit(_DWORD *a1)
{
  unsigned int *v1; // edx
  int result; // eax

  if ( *a1 )
    dl_signal_error(22, 0, 0, (unsigned int *)"invalid namespace");
  v1 = (unsigned int *)a1[1];
  if ( !v1 )
    v1 = (unsigned int *)byte_80B41F9;
  result = dl_open(v1, a1[2] | 0x80000000, a1[4], 0, _libc_argc, _libc_argv, (int)environ);
  a1[3] = result;
  return result;
}
// 80B41F9: using guessed type unsigned __int8 byte_80B41F9[1671];
// 80CF89C: using guessed type _DWORD *environ;
// 80CFF74: using guessed type int _libc_argc;
// 80CFF78: using guessed type int _libc_argv;

//----- (08096590) --------------------------------------------------------
int __usercall _dlmopen@<eax>(int a1@<ebp>, int *a2@<edi>, int a3, int a4, int a5, int a6)
{
  int v6; // eax
  int v7; // edx
  int v9[3]; // [esp+0h] [ebp-24h] BYREF
  int v10; // [esp+Ch] [ebp-18h]
  int v11; // [esp+10h] [ebp-14h]
  unsigned int v12; // [esp+14h] [ebp-10h]

  v12 = __readgsdword(0x14u);
  v9[0] = a3;
  v9[1] = a4;
  v9[2] = a5;
  v11 = a6;
  v6 = dlerror_run(a1, a2, (void (__cdecl *)(int))dlmopen_doit, (int)v9);
  v7 = 0;
  if ( !v6 )
  {
    _libc_register_dl_open_hook(a1, a2, v10);
    _libc_register_dlfcn_hook(a1, a2, v10);
    return v10;
  }
  return v7;
}

//----- (08096620) --------------------------------------------------------
unsigned __int8 *__cdecl strerror(signed int a1)
{
  unsigned __int8 *result; // eax
  int *v2; // eax
  unsigned int v3; // ebp

  result = strerror_r(a1, 0, 0);
  if ( !result )
  {
    v2 = (int *)buf;
    v3 = __readgsdword(0xFFFFFFE0);
    if ( buf )
      return strerror_r(a1, v2, 0x400u);
    v2 = malloc((const struct timespec *)0x400);
    buf = (int)v2;
    __writegsdword(0xFFFFFFE0, v3);
    if ( v2 )
      return strerror_r(a1, v2, 0x400u);
    else
      return dcgettext("libc", "Unknown error", 5u);
  }
  return result;
}
// 80CFFF0: using guessed type int buf;

//----- (080966C0) --------------------------------------------------------
_BYTE *__cdecl strspn(int a1, _BYTE *a2)
{
  int v3; // ecx
  _BYTE *v4; // eax
  char v6[256]; // [esp+0h] [ebp-100h] BYREF

  v3 = 0;
  memset(v6, 0, sizeof(v6));
  do
  {
    if ( !*a2 )
      break;
    LOBYTE(v3) = *a2;
    v6[v3] = *a2;
    LOBYTE(v3) = a2[1];
    if ( !(_BYTE)v3 )
      break;
    v6[v3] = v3;
    LOBYTE(v3) = a2[2];
    if ( !(_BYTE)v3 )
      break;
    v6[v3] = v3;
    LOBYTE(v3) = a2[3];
    a2 += 4;
    v6[v3] = v3;
  }
  while ( (_BYTE)v3 );
  v4 = (_BYTE *)(a1 - 4);
  while ( 1 )
  {
    v4 += 4;
    LOBYTE(v3) = *v4;
    if ( (*v4 & (unsigned __int8)v6[v3]) == 0 )
      return &v4[-a1];
    LOBYTE(v3) = v4[1];
    if ( ((unsigned __int8)v3 & (unsigned __int8)v6[v3]) == 0 )
      goto LABEL_13;
    LOBYTE(v3) = v4[2];
    if ( ((unsigned __int8)v3 & (unsigned __int8)v6[v3]) == 0 )
      goto LABEL_12;
    LOBYTE(v3) = v4[3];
    if ( ((unsigned __int8)v3 & (unsigned __int8)v6[v3]) == 0 )
    {
      ++v4;
LABEL_12:
      ++v4;
LABEL_13:
      ++v4;
      return &v4[-a1];
    }
  }
}
// 80966C0: using guessed type char var_100[256];

//----- (08096780) --------------------------------------------------------
int __cdecl strsep(int *a1, _BYTE *a2)
{
  int v2; // esi
  _BYTE *v3; // eax

  v2 = *a1;
  if ( !*a1 )
    return v2;
  v3 = &strcspn(v2, a2)[v2];
  if ( *v3 )
  {
    *v3 = 0;
    *a1 = (int)(v3 + 1);
    return v2;
  }
  *a1 = 0;
  return v2;
}

//----- (080967D0) --------------------------------------------------------
unsigned int __cdecl _getdents64(int a1, struct dirent *a2, unsigned int a3)
{
  unsigned int result; // eax

  result = sys_getdents64(a1, a2, a3);
  if ( result > 0xFFFFF000 )
    return _syscall_error(result);
  return result;
}

//----- (08096810) --------------------------------------------------------
int getpid()
{
  return ((int (*)(void))__readgsdword(0x10u))();
}

//----- (08096830) --------------------------------------------------------
unsigned int __cdecl _profil_counter(
        int a1,
        int a2,
        int a3,
        int a4,
        int a5,
        int a6,
        int a7,
        int a8,
        int a9,
        int a10,
        int a11,
        int a12,
        int a13,
        int a14,
        int a15,
        int a16)
{
  unsigned int result; // eax

  result = ((unsigned int)pc_scale * (unsigned __int64)(unsigned int)((a16 - pc_offset) / 2)) >> 16;
  if ( result < nsamples )
    ++*(_WORD *)(samples + 2 * result);
  return result;
}
// 80CFB3C: using guessed type int pc_scale;
// 80CFB40: using guessed type int pc_offset;
// 80CFB44: using guessed type int nsamples;
// 80CFB48: using guessed type int samples;

//----- (08096880) --------------------------------------------------------
int __cdecl profil(int a1, unsigned int a2, int a3, int a4)
{
  int result; // eax
  int *v5; // eax
  struct itimerval v6; // [esp+0h] [ebp-ACh] BYREF
  unsigned int (__cdecl *v7)(int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int); // [esp+10h] [ebp-9Ch] BYREF
  char v8; // [esp+90h] [ebp-1Ch] BYREF
  int v9; // [esp+94h] [ebp-18h]
  unsigned int v10; // [esp+9Ch] [ebp-10h]

  v10 = __readgsdword(0x14u);
  result = 0;
  if ( a1 )
  {
    if ( !samples || (setitimer(2, &otimer_8610, 0) & 0x80000000) == 0 && sigaction(27, oact_8609, 0) >= 0 )
    {
      samples = a1;
      v9 = 0x10000000;
      nsamples = a2 >> 1;
      pc_offset = a3;
      pc_scale = a4;
      v7 = _profil_counter;
      v5 = (int *)&v8;
      do
        *v5-- = -1;
      while ( v5 != (int *)&v7 );
      if ( sigaction(27, v5, oact_8609) >= 0 )
      {
        v6.it_value.tv_sec = 0;
        v6.it_value.tv_usec = 1000000 / _profile_frequency();
        v6.it_interval.tv_sec = 0;
        v6.it_interval.tv_usec = v6.it_value.tv_usec;
        return setitimer(2, &v6, &otimer_8610);
      }
    }
    return -1;
  }
  if ( samples )
  {
    if ( (setitimer(2, &otimer_8610, 0) & 0x80000000) == 0 )
    {
      samples = 0;
      return sigaction(27, oact_8609, 0);
    }
    return -1;
  }
  return result;
}
// 80CFAA0: using guessed type int oact_8609[35];
// 80CFB2C: using guessed type struct itimerval otimer_8610;
// 80CFB3C: using guessed type int pc_scale;
// 80CFB40: using guessed type int pc_offset;
// 80CFB44: using guessed type int nsamples;
// 80CFB48: using guessed type int samples;

//----- (08096A40) --------------------------------------------------------
int _profile_frequency()
{
  return dl_clktck;
}

//----- (08096A60) --------------------------------------------------------
int (*__usercall dl_fixup@<eax>(int a1@<eax>, int a2@<edx>))(void)
{
  int *v2; // ebp
  unsigned int v3; // edx
  int v4; // edi
  unsigned int v5; // esi
  int v6; // ecx
  int v7; // ebx
  _DWORD *v8; // edi
  _DWORD *v9; // ebp
  _DWORD *v10; // edx
  int v11; // ebx
  int *v12; // edi
  int (*result)(void); // eax
  int v14; // eax
  int v16; // eax
  int v17; // [esp+4h] [ebp-30h]
  int v18[8]; // [esp+14h] [ebp-20h] BYREF

  v17 = *(_DWORD *)(*(_DWORD *)(a1 + 52) + 4);
  v2 = (int *)(*(_DWORD *)(*(_DWORD *)(a1 + 124) + 4) + a2);
  v3 = v2[1];
  v4 = *v2;
  v5 = v3 >> 8;
  v6 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 4) + 16 * (v3 >> 8);
  v7 = *(_DWORD *)a1;
  v18[0] = v6;
  v8 = (_DWORD *)(v7 + v4);
  if ( (_BYTE)v3 != 7 )
    _assert_fail(
      (int)&GLOBAL_OFFSET_TABLE_ - 84804,
      (int)(&GLOBAL_OFFSET_TABLE_ - 8482),
      80,
      (int)&GLOBAL_OFFSET_TABLE_ - 84732);
  v9 = v8;
  if ( (*(_BYTE *)(v6 + 13) & 3) != 0 )
  {
    if ( *(_WORD *)(v6 + 14) == 0xFFF1 )
      v7 = 0;
    v14 = v7;
    goto LABEL_13;
  }
  v10 = *(_DWORD **)(a1 + 232);
  if ( v10 )
  {
    v10 = (_DWORD *)(*(_DWORD *)(a1 + 372) + 16 * (*(_WORD *)(v10[1] + 2 * v5) & 0x7FFF));
    if ( !v10[1] )
      v10 = 0;
  }
  v11 = 1;
  if ( __readgsdword(0xCu) )
  {
    __writegsdword(0x1Cu, 1u);
    v11 = 5;
  }
  v12 = dl_lookup_symbol_x(
          (unsigned __int8 *)(*(_DWORD *)v6 + v17),
          (_DWORD *)a1,
          v18,
          *(int ***)(a1 + 464),
          v10,
          1,
          v11,
          0);
  if ( __readgsdword(0xCu) && _InterlockedExchange(MK_FP(__GS__, 28), 0) == 2 )
    v16 = sys_futex((int *)(__readgsdword(8u) + 28), 129, 1, 0, v12, (int)v9);
  v6 = v18[0];
  result = 0;
  if ( v18[0] )
  {
    if ( *(_WORD *)(v18[0] + 14) == 0xFFF1 || !v12 )
      v14 = 0;
    else
      v14 = *v12;
LABEL_13:
    result = (int (*)(void))(*(_DWORD *)(v6 + 4) + v14);
    if ( (*(_BYTE *)(v6 + 12) & 0xF) == 10 )
      result = (int (*)(void))result();
  }
  if ( !dl_bind_not )
    *v9 = result;
  return result;
}
// 80CE000: using guessed type _TBYTE GLOBAL_OFFSET_TABLE_;
// 8096A60: using guessed type int var_20[8];

//----- (08096C10) --------------------------------------------------------
int (*__userpurge dl_profile_fixup@<eax>(int a1@<eax>, unsigned int a2@<edx>, int a3@<ecx>, int a4, _DWORD *a5))(void)
{
  int v5; // ecx
  int *v6; // edi
  int (*v7)(void); // ebp
  unsigned int v8; // edx
  unsigned int v9; // ebx
  int v10; // ecx
  _DWORD *v11; // edx
  int v12; // ebx
  int v15; // eax
  int v17; // [esp+8h] [ebp-30h]
  int (**v18)(void); // [esp+8h] [ebp-30h]
  int v19[8]; // [esp+18h] [ebp-20h] BYREF

  v5 = *(_DWORD *)(a1 + 420);
  if ( !v5 )
  {
    *a5 = -1;
    return dl_fixup(a1, a2);
  }
  v6 = (int *)(v5 + 24 * (a2 >> 3));
  v7 = (int (*)(void))v6[5];
  if ( !v7 )
  {
    v17 = *(_DWORD *)(*(_DWORD *)(a1 + 52) + 4);
    v8 = *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(a1 + 124) + 4) + a2 + 4);
    v9 = v8 >> 8;
    v10 = *(_DWORD *)(*(_DWORD *)(a1 + 56) + 4) + 16 * (v8 >> 8);
    v19[0] = v10;
    if ( (_BYTE)v8 != 7 )
      _assert_fail(
        (int)&GLOBAL_OFFSET_TABLE_ - 84804,
        (int)(&GLOBAL_OFFSET_TABLE_ - 8482),
        229,
        (int)&GLOBAL_OFFSET_TABLE_ - 84752);
    if ( (*(_BYTE *)(v10 + 13) & 3) != 0 )
    {
      if ( *(_WORD *)(v10 + 14) != 0xFFF1 )
        v7 = *(int (**)(void))a1;
      v7 = (int (*)(void))((char *)v7 + *(_DWORD *)(v10 + 4));
      if ( (*(_BYTE *)(v10 + 12) & 0xF) != 10 )
        goto LABEL_16;
    }
    else
    {
      v11 = *(_DWORD **)(a1 + 232);
      if ( v11 )
      {
        v11 = (_DWORD *)(*(_DWORD *)(a1 + 372) + 16 * (*(_WORD *)(v11[1] + 2 * v9) & 0x7FFF));
        if ( !v11[1] )
          v11 = 0;
      }
      v12 = 1;
      if ( __readgsdword(0xCu) )
      {
        __writegsdword(0x1Cu, 1u);
        v12 = 5;
      }
      v18 = (int (**)(void))dl_lookup_symbol_x(
                              (unsigned __int8 *)(*(_DWORD *)v10 + v17),
                              (_DWORD *)a1,
                              v19,
                              *(int ***)(a1 + 464),
                              v11,
                              1,
                              v12,
                              0);
      if ( __readgsdword(0xCu) && _InterlockedExchange(MK_FP(__GS__, 28), 0) == 2 )
        v15 = sys_futex((int *)(__readgsdword(8u) + 28), 129, 1, 0, v6, 0);
      if ( !v19[0] )
        goto LABEL_16;
      if ( *(_WORD *)(v19[0] + 14) != 0xFFF1 && v18 )
        v7 = *v18;
      v7 = (int (*)(void))((char *)v7 + *(_DWORD *)(v19[0] + 4));
      if ( (*(_BYTE *)(v19[0] + 12) & 0xF) != 10 )
        goto LABEL_16;
    }
    v7 = (int (*)(void))v7();
LABEL_16:
    if ( !dl_bind_not )
    {
      *v6 = (int)v7;
      v6[5] = 1;
    }
    goto LABEL_19;
  }
  v7 = (int (*)(void))*v6;
LABEL_19:
  *a5 = -1;
  dl_mcount(a3, (int)v7);
  return v7;
}
// 80CE000: using guessed type _TBYTE GLOBAL_OFFSET_TABLE_;
// 8096C10: using guessed type int var_20[8];

//----- (08096E30) --------------------------------------------------------
void __stdcall dl_call_pltexit(int a1)
{
  ;
}

//----- (08096E40) --------------------------------------------------------
int __usercall add_to_global@<eax>(int a1@<eax>)
{
  int v2; // ebp
  int v3; // edx
  int v4; // eax
  int v5; // edi
  void **v6; // ecx
  int v7; // edi
  unsigned int v8; // ebp
  void **v9; // ecx
  int v10; // edx
  char v11; // al
  int v13; // eax
  _BYTE *v14; // ebp
  int *v15; // eax
  int *v16; // edi
  int v17; // eax
  int *v18; // eax
  int v19; // [esp+0h] [ebp-34h]
  unsigned int v20; // [esp+8h] [ebp-2Ch]
  void **v21; // [esp+8h] [ebp-2Ch]
  _DWORD *v22; // [esp+Ch] [ebp-28h]
  void *v23; // [esp+10h] [ebp-24h]

  v2 = *(_DWORD *)(a1 + 356);
  if ( v2 )
  {
    v3 = *(_DWORD *)(a1 + 352);
    v4 = 0;
    v5 = v3 + 4 * v2;
    do
    {
      v4 += (*(_BYTE *)(*(_DWORD *)v3 + 408) & 0x10) == 0;
      v3 += 4;
    }
    while ( v5 != v3 );
  }
  else
  {
    v4 = 0;
  }
  v19 = *(_DWORD *)(a1 + 24);
  v6 = &dl_ns + 19 * v19;
  v22 = v6[2];
  v7 = v22[1];
  v20 = (unsigned int)v6[3];
  if ( !v20 )
  {
    v17 = v4 + v7 + 8;
    v6[3] = (void *)v17;
    v18 = malloc((const struct timespec *)(4 * v17));
    if ( v18 )
    {
      *v22 = memcpy(v18, (_BYTE *)*v22, 4 * v7);
      v7 = v22[1];
      goto LABEL_6;
    }
    *(&dl_ns + 19 * v19 + 3) = 0;
LABEL_21:
    dl_signal_error(12, **(unsigned int ***)(a1 + 28), 0, (unsigned int *)"cannot extend global scope");
  }
  if ( v20 >= v4 + v7 )
    goto LABEL_6;
  v13 = v20 + v4;
  v23 = (void *)(2 * v13);
  v14 = (_BYTE *)*v22;
  v15 = malloc((const struct timespec *)(8 * v13));
  v16 = v15;
  if ( !v15 )
    goto LABEL_21;
  memcpy(v15, v14, 4 * v20);
  *(&dl_ns + 19 * v19 + 3) = v23;
  *v22 = v16;
  if ( __readgsdword(0xCu) )
    dl_wait_lookup_done();
  free((int)v14, v16, (int)v14);
  v2 = *(_DWORD *)(a1 + 356);
  v7 = *((_DWORD *)*(&dl_ns + 19 * v19 + 2) + 1);
LABEL_6:
  if ( v2 )
  {
    v8 = 0;
    v9 = &dl_ns + 19 * v19;
    do
    {
      v10 = *(_DWORD *)(*(_DWORD *)(a1 + 352) + 4 * v8);
      v11 = *(_BYTE *)(v10 + 408);
      if ( (v11 & 0x10) == 0 )
      {
        *(_BYTE *)(v10 + 408) = v11 | 0x10;
        *(_DWORD *)(*(_DWORD *)v9[2] + 4 * v7++) = v10;
        if ( (dl_debug_mask[1] & 2) != 0 )
        {
          v21 = v9;
          dl_debug_printf("\nadd %s [%lu] to global scope\n", *(_DWORD *)(v10 + 4), *(_DWORD *)(v10 + 24));
          v9 = v21;
        }
      }
      ++v8;
    }
    while ( *(_DWORD *)(a1 + 356) > v8 );
  }
  *((_DWORD *)*(&dl_ns + 19 * v19 + 2) + 1) = v7;
  return 0;
}
// 80CEA00: using guessed type void *dl_ns;
// 80CFF04: using guessed type _BYTE dl_debug_mask[4];
// 80CFF08: using guessed type int (*dl_wait_lookup_done)(void);

//----- (08097060) --------------------------------------------------------
_DWORD *__cdecl dl_find_dso_for_object(unsigned int a1)
{
  _DWORD *v1; // ebx

  if ( !dl_nns )
    return 0;
  v1 = dl_ns;
  if ( !dl_ns )
    return 0;
  while ( v1[108] > a1 || v1[109] <= a1 || (*((_BYTE *)v1 + 409) & 0x40) == 0 && !dl_addr_inside_object((int)v1, a1) )
  {
    v1 = (_DWORD *)v1[3];
    if ( !v1 )
      return 0;
  }
  if ( v1[6] )
    _assert_fail((int)"ns == l->l_ns", (int)"dl-open.c", 173, (int)"_dl_find_dso_for_object");
  return v1;
}
// 80CE9C0: using guessed type int dl_nns;
// 80CEA00: using guessed type void *dl_ns;

//----- (08097100) --------------------------------------------------------
int __cdecl dl_open(unsigned int *a1, int a2, int a3, int a4, int a5, int a6, int a7)
{
  char *v7; // eax
  int v8; // ebp
  _DWORD v10[3]; // [esp+0h] [ebp-48h] BYREF
  int v11[3]; // [esp+Ch] [ebp-3Ch] BYREF
  int v12; // [esp+18h] [ebp-30h]
  int v13; // [esp+1Ch] [ebp-2Ch]
  int v14; // [esp+20h] [ebp-28h]
  int v15; // [esp+24h] [ebp-24h]
  int v16; // [esp+28h] [ebp-20h]

  if ( (a2 & 3) == 0 )
  {
    v7 = "invalid mode for dlopen()";
LABEL_8:
    dl_signal_error(22, a1, 0, (unsigned int *)v7);
  }
  if ( a4 == -1 )
  {
    v7 = "no more namespaces available for dlmopen()";
    goto LABEL_8;
  }
  v7 = "invalid target namespace in dlmopen()";
  if ( ((a4 + 2) & 0xFFFFFFFD) != 0 )
    goto LABEL_8;
  v13 = a4;
  v11[0] = (int)a1;
  v11[2] = a3;
  v11[1] = a2;
  v14 = a5;
  v12 = 0;
  v15 = a6;
  v16 = a7;
  v8 = dl_catch_exception(a4, (int)v10, a2, v10, (void (__cdecl *)(int))dl_open_worker, (int)v11);
  dl_unload_cache();
  if ( v10[1] )
  {
    if ( v12 )
    {
      if ( (a2 & 0x8000000) == 0 )
        dl_tls_dtv_gaps = 1;
      dl_close_worker(v12, 1);
    }
    if ( !dl_debug_initialize(0, v13)[3] )
      dl_signal_exception(v8, (int)v10, 0);
    _assert_fail(
      (int)"_dl_debug_initialize (0, args.nsid)->r_state == RT_CONSISTENT",
      (int)"dl-open.c",
      615,
      (int)"_dl_open");
  }
  if ( dl_debug_initialize(0, v13)[3] )
    _assert_fail(
      (int)"_dl_debug_initialize (0, args.nsid)->r_state == RT_CONSISTENT",
      (int)"dl-open.c",
      624,
      (int)"_dl_open");
  return v12;
}

//----- (080972F0) --------------------------------------------------------
int __cdecl dl_show_scope(_DWORD *a1, int a2)
{
  _DWORD *v2; // edi
  const char *v3; // eax
  int v4; // eax
  int v5; // ebx
  _DWORD *v6; // edx
  _DWORD *v7; // eax
  unsigned int v8; // edi
  _DWORD *v9; // esi
  char (*v10)[1671]; // edx
  int v12; // [esp+8h] [ebp-2Ch]
  _BYTE *v13; // [esp+Ch] [ebp-28h]

  v2 = a1;
  v12 = a2;
  v3 = (const char *)a1[1];
  if ( !*v3 )
  {
    v3 = (const char *)program_invocation_short_name[0];
    if ( !program_invocation_short_name[0] )
      v3 = "<main program>";
  }
  dl_debug_printf((_BYTE *)&GLOBAL_OFFSET_TABLE_ - 84645, v3, a1[6]);
  v4 = a1[116];
  if ( v4 )
  {
    v5 = 4 * a2;
    v13 = (char *)&GLOBAL_OFFSET_TABLE_ - 179546;
    if ( *(_DWORD *)(v4 + 4 * a2) )
    {
      do
      {
        dl_debug_printf((_BYTE *)&GLOBAL_OFFSET_TABLE_ - 84628, v12);
        v6 = *(_DWORD **)(v2[116] + v5);
        if ( v6[1] )
        {
          v7 = v2;
          v8 = 0;
          v9 = v7;
          do
          {
            v10 = *(char (**)[1671])(*(_DWORD *)(*v6 + 4 * v8) + 4);
            if ( !*(_BYTE *)v10 )
            {
              v10 = program_invocation_short_name[0];
              if ( !program_invocation_short_name[0] )
                v10 = (char (*)[1671])((char *)&GLOBAL_OFFSET_TABLE_ - 109267);
            }
            ++v8;
            dl_debug_printf_c((_BYTE *)&GLOBAL_OFFSET_TABLE_ - 84939, v10);
            v6 = *(_DWORD **)(v9[116] + v5);
          }
          while ( v6[1] > v8 );
          v2 = v9;
        }
        v5 += 4;
        dl_debug_printf_c(v13);
        ++v12;
      }
      while ( *(_DWORD *)(v2[116] + v5) );
    }
    return dl_debug_printf(v13);
  }
  else
  {
    dl_debug_printf((_BYTE *)&GLOBAL_OFFSET_TABLE_ - 84617);
    return dl_debug_printf((_BYTE *)&GLOBAL_OFFSET_TABLE_ - 179546);
  }
}
// 80CDDA4: using guessed type char (**dl_argv)[1671];
// 80CE000: using guessed type _TBYTE GLOBAL_OFFSET_TABLE_;
// 80CE964: using guessed type char (*program_invocation_short_name[2])[1671];

//----- (08097480) --------------------------------------------------------
char **__cdecl dl_open_worker(char **a1)
{
  char *v1; // ebx
  unsigned int *v2; // esi
  unsigned int *dso_for_object; // edi
  char *v4; // esi
  int v5; // esi
  unsigned __int8 *v6; // edi
  char **result; // eax
  int v8; // edx
  int v9; // eax
  unsigned int v10; // ebx
  _DWORD *v11; // eax
  void **v12; // eax
  unsigned __int8 *v13; // ecx
  unsigned __int8 *v14; // eax
  int v15; // ecx
  int v16; // edx
  int v17; // eax
  unsigned __int8 **v18; // ecx
  int v19; // edx
  void *v20; // esp
  unsigned __int8 *v21; // eax
  unsigned int v22; // esi
  int v23; // edx
  unsigned int i; // esi
  int *v25; // ebx
  unsigned __int8 *v26; // ecx
  int *v27; // edi
  int v28; // esi
  char v29; // al
  int *v30; // esi
  unsigned __int8 *v31; // eax
  int v32; // edx
  int *v33; // ecx
  char *v34; // eax
  unsigned int v35; // edx
  unsigned int v36; // eax
  unsigned int v37; // esi
  unsigned __int8 *v38; // edx
  int v39; // edi
  unsigned __int8 *v40; // ebx
  unsigned int v41; // eax
  unsigned __int8 *v42; // ebx
  int v43; // eax
  bool v44; // zf
  int *v45; // eax
  _DWORD v47[1023]; // [esp+10h] [ebp-105Ch] BYREF
  unsigned __int8 *v48; // [esp+1010h] [ebp-5Ch] BYREF
  unsigned __int8 *v49; // [esp+1014h] [ebp-58h]
  unsigned int v50; // [esp+1018h] [ebp-54h]
  int v51; // [esp+101Ch] [ebp-50h]
  unsigned __int8 **v52; // [esp+1020h] [ebp-4Ch]
  unsigned int v53; // [esp+1024h] [ebp-48h]
  char v54; // [esp+102Bh] [ebp-41h]
  int *v55; // [esp+102Ch] [ebp-40h]
  int *v56; // [esp+1030h] [ebp-3Ch]
  int *v57; // [esp+1034h] [ebp-38h]
  void **v58; // [esp+1038h] [ebp-34h]
  _TBYTE *v59; // [esp+103Ch] [ebp-30h]
  unsigned int v60; // [esp+1040h] [ebp-2Ch]
  char **v61; // [esp+1044h] [ebp-28h]
  char *v62; // [esp+1048h] [ebp-24h]
  unsigned __int8 *v63; // [esp+104Ch] [ebp-20h]
  int v64; // [esp+1068h] [ebp-4h] BYREF

  v59 = &GLOBAL_OFFSET_TABLE_;
  v1 = *a1;
  v60 = (unsigned int)a1[1];
  if ( strchr(v1, 36) || (dso_for_object = 0, v4 = a1[4], v4 == (char *)-2) || !strchr(v1, 47) )
  {
    v2 = (unsigned int *)dl_ns;
    dso_for_object = dl_find_dso_for_object((unsigned int)a1[2]);
    if ( !dso_for_object )
      dso_for_object = v2;
    v4 = a1[4];
    if ( v4 == (char *)-2 )
    {
      v4 = (char *)dso_for_object[6];
      a1[4] = v4;
    }
  }
  dl_debug_initialize(0, (int)v4);
  v5 = v47[1021];
  v6 = dl_map_object(dso_for_object, (int)dso_for_object, v1, 2, 0, v60 | 0x10000000, (int)a1[4]);
  result = a1;
  a1[3] = (char *)v6;
  if ( !v6 )
  {
    if ( (v60 & 4) == 0 )
      _assert_fail((int)v59 - 84606, (int)v59 - 84695, 224, (int)v59 - 84184);
    return result;
  }
  if ( (v60 & 0x1000) != 0 )
    *((_DWORD *)v6 + 130) |= 8u;
  if ( (v60 & 0x40000000) != 0 )
    return result;
  v8 = *((_DWORD *)v6 + 88);
  v9 = *((_DWORD *)v6 + 101) + 1;
  *((_DWORD *)v6 + 101) = v9;
  if ( v8 )
  {
    if ( (dl_debug_mask[0] & 0x40) != 0 )
      dl_debug_printf(&aOpeningFileSLu[(_DWORD)v59 - 135061504], *((_DWORD *)v6 + 1), *((_DWORD *)v6 + 6), v9);
    if ( (v60 & 0x100) != 0 && (v6[408] & 0x10) == 0 )
      add_to_global((int)v6);
    result = (char **)dl_debug_initialize(0, (int)a1[4])[3];
    if ( result )
      _assert_fail((int)v59 - 84304, (int)v59 - 84695, 254, (int)v59 - 84184);
    return result;
  }
  v10 = 0;
  v47[1020] = v60 & 0x88000008;
  memset(&v47[1017], 0, 12);
  v47[1016] = v6;
  dl_map_object_deps(0, (int)&v64, (int)v6, v5);
  if ( *((_DWORD *)v6 + 89) )
  {
    do
    {
      while ( 1 )
      {
        v11 = *(_DWORD **)(*(_DWORD *)(*((_DWORD *)v6 + 88) + 4 * v10) + 20);
        if ( !*(_DWORD *)((char *)v11 + (_DWORD)(&dword_80CE174 - 33765376)) )
          break;
        if ( *((_DWORD *)v6 + 89) <= ++v10 )
          goto LABEL_16;
      }
      ++v10;
      dl_check_map_versions(v11, 0, 0);
    }
    while ( *((_DWORD *)v6 + 89) > v10 );
  }
LABEL_16:
  v12 = dl_debug_initialize(0, (int)a1[4]);
  v12[3] = 0;
  v58 = v12;
  dl_debug_state();
  dl_cet_open_check((int)v6);
  v61 = (char **)dl_debug_mask;
  v63 = *(unsigned __int8 **)dl_debug_mask;
  if ( (dl_debug_mask[1] & 2) != 0 )
    dl_show_scope(v6, 0);
  v13 = (unsigned __int8 *)(v60 & 0x8000000);
  if ( dl_lazy )
    v13 = (unsigned __int8 *)(v60 & 0x8000001);
  v14 = v6;
  v63 = v13;
  v15 = 0;
  do
  {
    v16 = *((_DWORD *)v14 + 5);
    v14 = (unsigned __int8 *)*((_DWORD *)v14 + 3);
    v15 += (*(_BYTE *)(v16 + 408) & 4) == 0;
  }
  while ( v14 );
  v17 = 4 * v15 + 15;
  v52 = &v48;
  v18 = (unsigned __int8 **)((char *)&v48 - (v17 & 0xFFFFF000));
  if ( &v48 != v18 )
  {
    while ( v47 != v18 )
      ;
  }
  v19 = v17 & 0xFF0;
  if ( (v17 & 0xFF0) != 0 )
  {
    v20 = alloca(v19);
    *(_DWORD *)((char *)&v47[-1] + v19) = *(_DWORD *)((char *)&v47[-1] + v19);
  }
  v21 = v6;
  v22 = 0;
  do
  {
    if ( (*(_BYTE *)(*((_DWORD *)v21 + 5) + 408) & 4) == 0 )
      v47[v22++] = v21;
    v21 = (unsigned __int8 *)*((_DWORD *)v21 + 3);
  }
  while ( v21 );
  dl_sort_maps((int)v47, v22, 0, 0);
  if ( v22 )
  {
    v23 = v47[v22 - 1];
    for ( i = v22 - 1; ; v23 = v47[i] )
    {
      --i;
      dl_relocate_object(v23, *(_DWORD *)(v23 + 464), (int)v63, 0);
      if ( i == -1 )
        break;
    }
    v25 = (int *)*((_DWORD *)v6 + 89);
    v51 = 1;
    v53 = (unsigned int)v25;
    if ( !v25 )
      goto LABEL_53;
  }
  else
  {
    v25 = (int *)*((_DWORD *)v6 + 89);
    v51 = 0;
    v53 = (unsigned int)v25;
    if ( !v25 )
      goto LABEL_53;
  }
  v26 = v6;
  v54 = 0;
  v27 = 0;
  do
  {
    while ( 1 )
    {
      v63 = *(unsigned __int8 **)(*((_DWORD *)v26 + 88) + 4 * (_DWORD)v27);
      v29 = byte_80CE198[(_DWORD)v63 - 135061504];
      if ( (v29 & 0xB) != 10 )
      {
        v28 = 0;
        if ( (v29 & 8) == 0 )
        {
          if ( *(_DWORD *)&v63[(_DWORD)(&dword_80CE238 - 33765376)] )
          {
            v62 = (char *)v26;
            v40 = v63;
            dl_add_to_slotinfo((unsigned int)v63);
            v54 = 1;
            v26 = (unsigned __int8 *)v62;
            if ( (v40[409] & 4) != 0 )
            {
              v41 = v53;
              if ( *((_DWORD *)v62 + 89) == v53 )
                v41 = (unsigned int)v27;
              v53 = v41;
            }
          }
        }
        v62 = *v61;
        if ( (BYTE1(v62) & 2) == 0 )
          goto LABEL_39;
        goto LABEL_51;
      }
      v30 = *(int **)&v63[(_DWORD)(&dword_80CE1D0 - 33765376)];
      v31 = (unsigned __int8 *)*v30;
      v56 = v30;
      if ( v31 )
        break;
      v35 = 1;
      v28 = 0;
LABEL_48:
      v36 = *(_DWORD *)&v63[(_DWORD)(&dword_80CE1CC - 33765376)];
      if ( v36 <= v35 )
      {
        v55 = (int *)(v63 + 444);
        if ( v36 > 3 || (v57 = (int *)(v63 + 444), v50 = 4, v63 + 444 == (unsigned __int8 *)v56) )
        {
          v49 = v26;
          v62 = (char *)v35;
          v50 = 2 * v36;
          v45 = malloc((const struct timespec *)(8 * v36));
          v35 = (unsigned int)v62;
          v26 = v49;
          v57 = v45;
          if ( !v45 )
            dl_signal_error(12, (unsigned int *)((char *)v59 - 106709), 0, (unsigned int *)((char *)v59 - 84587));
        }
        v48 = v26;
        v49 = (unsigned __int8 *)v35;
        v62 = (char *)(4 * v28);
        memcpy(v57, v56, 4 * v28);
        v42 = v63;
        v35 = (unsigned int)v49;
        v43 = *((_DWORD *)v63 + 116);
        v44 = v55 == (int *)v43;
        v56 = v57;
        *((_DWORD *)v63 + 116) = v57;
        v26 = v48;
        if ( !v44 )
        {
          v55 = (int *)v48;
          v57 = (int *)v35;
          dl_scope_free((int)&v64, v27, v43);
          v26 = (unsigned __int8 *)v55;
          v35 = (unsigned int)v57;
          v56 = (int *)*((_DWORD *)v42 + 116);
        }
        *(_DWORD *)&v63[(_DWORD)(&dword_80CE1CC - 33765376)] = v50;
      }
      else
      {
        v62 = (char *)(4 * v28);
      }
      v56[v35] = 0;
      *(_DWORD *)&v62[*(_DWORD *)&v63[(_DWORD)(&dword_80CE1D0 - 33765376)]] = v26 + 352;
      v62 = *v61;
      if ( (BYTE1(v62) & 2) == 0 )
        goto LABEL_39;
LABEL_51:
      v62 = (char *)v26;
      dl_show_scope(v63, v28);
      v26 = (unsigned __int8 *)v62;
LABEL_39:
      v25 = (int *)*((_DWORD *)v26 + 89);
LABEL_40:
      v27 = (int *)((char *)v27 + 1);
      if ( v25 <= v27 )
        goto LABEL_63;
    }
    v62 = (char *)(v26 + 352);
    if ( v31 == v26 + 352 )
      goto LABEL_40;
    v57 = (int *)v26;
    v32 = 0;
    v33 = v30;
    v55 = v25;
    do
    {
      v28 = v32 + 1;
      v34 = (char *)v33[v32 + 1];
      if ( !v34 )
      {
        v26 = (unsigned __int8 *)v57;
        v35 = v32 + 2;
        goto LABEL_48;
      }
      ++v32;
    }
    while ( v34 != v62 );
    v25 = v55;
    v27 = (int *)((char *)v27 + 1);
    v26 = (unsigned __int8 *)v57;
  }
  while ( v55 > v27 );
LABEL_63:
  v6 = v26;
  if ( v54 )
  {
    if ( !++dl_tls_generation )
    {
      dl_dprintf(2, &aTlsGenerationC[(_DWORD)v59 - 135061504]);
      exit(127);
    }
  }
  v37 = v53;
  if ( (unsigned int)v25 > v53 )
  {
    v38 = v26;
    do
    {
      v39 = *(_DWORD *)(*((_DWORD *)v38 + 88) + 4 * v37);
      if ( (*(_WORD *)(v39 + 408) & 0x408) == 1024 )
      {
        if ( *(_DWORD *)(v39 + 568) )
        {
          v63 = v38;
          *(_BYTE *)(v39 + 409) &= ~4u;
          dl_init_static_tls(v39);
          v38 = v63;
          if ( (*(_BYTE *)(v39 + 409) & 4) != 0 )
            _assert_fail((int)v59 - 84562, (int)v59 - 84695, 493, (int)v59 - 84184);
        }
      }
      ++v37;
    }
    while ( *((_DWORD *)v38 + 89) > v37 );
    v6 = v38;
  }
LABEL_53:
  dl_init(v6, (int)a1[5], (int)a1[6], (int)a1[7]);
  if ( (v60 & 0x100) == 0 || (result = (char **)add_to_global((int)v6)) == 0 )
  {
    *(_DWORD *)((char *)v59 + (_DWORD)(&_libc_multiple_libcs - 33765376)) = 1;
    result = v61;
    if ( (*(_BYTE *)v61 & 0x40) != 0 )
      return (char **)dl_debug_printf(
                        &aOpeningFileSLu[(_DWORD)v59 - 135061504],
                        *((_DWORD *)v6 + 1),
                        *((_DWORD *)v6 + 6),
                        *((_DWORD *)v6 + 101));
  }
  return result;
}
// 80CE000: using guessed type _TBYTE GLOBAL_OFFSET_TABLE_;
// 80CE174: using guessed type int dword_80CE174;
// 80CE1CC: using guessed type int dword_80CE1CC;
// 80CE1D0: using guessed type int dword_80CE1D0;
// 80CE238: using guessed type int dword_80CE238;
// 80CE9E4: using guessed type int (__cdecl *dl_init_static_tls)(_DWORD);
// 80CEA00: using guessed type void *dl_ns;
// 80CECD4: using guessed type int _libc_multiple_libcs;
// 80CFF04: using guessed type _BYTE dl_debug_mask[4];

//----- (08097C40) --------------------------------------------------------
int __usercall remove_slotinfo@<eax>(int a1@<eax>, _DWORD *a2@<edx>, int a3@<ecx>, unsigned __int8 a4)
{
  _DWORD *v6; // edx
  _DWORD *v7; // edx
  int v8; // ecx
  unsigned int v10; // edx
  unsigned int v11; // eax
  int v12; // ebx
  int v13; // ecx

  if ( (unsigned int)(a1 - a3) < *a2 )
  {
    v7 = &a2[2 * (a1 - a3)];
    v8 = v7[3];
    if ( v8 )
    {
      if ( *(_DWORD *)(v8 + 584) != a1 )
        _assert_fail((int)"old_map->l_tls_modid == idx", (int)"dl-close.c", 80, (int)"remove_slotinfo");
      v7[3] = 0;
      v7[2] = dl_tls_generation + 1;
    }
    if ( dl_tls_max_dtv_idx != a1 )
      return 1;
  }
  else
  {
    v6 = (_DWORD *)a2[1];
    if ( v6 )
    {
      if ( (unsigned __int8)remove_slotinfo(a1, v6, a3 + *a2, a4) )
        return 1;
      a1 = a3 + *a2;
    }
    else if ( a4 )
    {
      _assert_fail((int)"! should_be_there", (int)"dl-close.c", 59, (int)"remove_slotinfo");
    }
  }
  v10 = dl_tls_static_nelem + 1;
  if ( a3 )
    v10 = 0;
  v11 = a1 - a3;
  v12 = a3 - 1;
  do
  {
    if ( v11 <= v10 )
      return 0;
    v13 = v12 + v11--;
  }
  while ( !a2[2 * v11 + 3] );
  dl_tls_max_dtv_idx = v13;
  return 1;
}

//----- (08097D70) --------------------------------------------------------
_TBYTE *__cdecl dl_close_worker(int a1, char a2)
{
  bool v2; // zf
  _TBYTE *result; // eax
  int v4; // eax
  unsigned __int8 *v5; // ecx
  int v6; // edx
  void *v7; // esp
  __int16 v8; // dx
  unsigned __int8 *v9; // eax
  int v10; // edx
  unsigned int v11; // eax
  _BYTE *v12; // ebx
  __int16 v13; // ax
  void *v14; // esp
  int v15; // eax
  void *v16; // esp
  int v17; // edx
  _DWORD *v18; // eax
  int v19; // ecx
  int v20; // esi
  unsigned __int8 *v21; // eax
  unsigned int v22; // eax
  int v23; // edx
  unsigned int *v24; // ecx
  unsigned int v25; // edx
  int v26; // eax
  unsigned int v27; // ebx
  int v28; // eax
  int *v29; // eax
  int v30; // edx
  unsigned int v31; // ecx
  int v32; // edx
  int v33; // edx
  unsigned int v34; // ebx
  int v35; // esi
  unsigned int v36; // edi
  int v37; // eax
  int v38; // edx
  char v39; // al
  bool v40; // cf
  unsigned int v41; // eax
  char v42; // dl
  int *v43; // eax
  unsigned int v44; // ebx
  int v45; // edx
  int v46; // eax
  _DWORD *v47; // ecx
  char v48; // di
  int v49; // edx
  int *v50; // eax
  int v51; // ecx
  int v52; // edi
  int v53; // ebx
  int v54; // edx
  int *v55; // eax
  int v56; // esi
  unsigned int v57; // eax
  char v58; // bl
  int v59; // eax
  unsigned int v60; // eax
  int *v61; // edi
  void **v62; // eax
  int *v63; // ebx
  unsigned int v64; // eax
  int *v65; // edi
  int *v66; // esi
  _DWORD *v67; // eax
  int v68; // edx
  int v69; // eax
  void **v70; // ebx
  int v71; // eax
  int v72; // esi
  int v73; // esi
  int v74; // eax
  int v75; // ecx
  int v76; // eax
  void (**v77)(void); // esi
  void (**v78)(void); // ebx
  int v79; // eax
  int *v80; // eax
  void **v81; // ecx
  void *v82; // edx
  _DWORD *v83; // edx
  int i; // edx
  int v85; // eax
  int v86; // edx
  int v87; // edx
  int *v88; // eax
  unsigned int v89; // eax
  int v90; // edx
  unsigned __int8 *v91; // eax
  int v92; // ecx
  int v93; // ebx
  int v94; // eax
  int v95; // esi
  int j; // ecx
  int v97; // edx
  int *v98; // esi
  int v99; // eax
  int v100; // eax
  _BYTE v101[4]; // [esp-2010h] [ebp-208Ch]
  _BYTE v102[3]; // [esp-200Ch] [ebp-2088h] BYREF
  _BYTE v103[4093]; // [esp-2009h] [ebp-2085h] BYREF
  unsigned __int8 v104[4096]; // [esp-100Ch] [ebp-1088h] BYREF
  _BYTE v105[12]; // [esp-Ch] [ebp-88h] BYREF
  int v106; // [esp+0h] [ebp-7Ch]
  void **v107; // [esp+4h] [ebp-78h]
  _BYTE *v108; // [esp+8h] [ebp-74h]
  void **v109; // [esp+Ch] [ebp-70h]
  unsigned int v110; // [esp+10h] [ebp-6Ch]
  int v111; // [esp+14h] [ebp-68h]
  int v112; // [esp+18h] [ebp-64h]
  char v113; // [esp+1Eh] [ebp-5Eh]
  char v114; // [esp+1Fh] [ebp-5Dh]
  void **v115; // [esp+20h] [ebp-5Ch]
  _DWORD *v116; // [esp+24h] [ebp-58h]
  unsigned int v117; // [esp+28h] [ebp-54h]
  int v118; // [esp+2Ch] [ebp-50h]
  int *v119; // [esp+30h] [ebp-4Ch]
  int *v120; // [esp+34h] [ebp-48h]
  _BYTE *v121; // [esp+38h] [ebp-44h]
  int v122; // [esp+3Ch] [ebp-40h]
  int v123; // [esp+40h] [ebp-3Ch]
  unsigned int v124; // [esp+44h] [ebp-38h]
  _TBYTE *v125; // [esp+48h] [ebp-34h]
  int v126; // [esp+4Ch] [ebp-30h]
  int v127; // [esp+50h] [ebp-2Ch]
  unsigned __int8 *v128; // [esp+54h] [ebp-28h]
  int *v129; // [esp+58h] [ebp-24h]
  unsigned int v130; // [esp+5Ch] [ebp-20h]
  unsigned int v131; // [esp+60h] [ebp-1Ch]
  int savedregs; // [esp+7Ch] [ebp+0h] BYREF

  v114 = a2;
  v125 = &GLOBAL_OFFSET_TABLE_;
  v131 = *(_DWORD *)(a1 + 404);
  result = (_TBYTE *)(v131 - 1);
  v2 = v131 == 1;
  *(_DWORD *)(a1 + 404) = v131 - 1;
  if ( !v2 || (LOBYTE(v131) = *(_BYTE *)(a1 + 408), (v131 & 3) != 2) )
  {
LABEL_17:
    if ( (dl_debug_mask[0] & 0x40) != 0 )
      return (_TBYTE *)dl_debug_printf((_BYTE *)v125 - 83896, *(_DWORD *)(a1 + 4), result);
    return result;
  }
  if ( dl_close_state_11755 )
  {
    *(_DWORD *)((char *)v125 + (_DWORD)(&dl_close_state_11755 - 33765376)) = 2;
    goto LABEL_17;
  }
  v126 = *(_DWORD *)(a1 + 24);
  v106 = v126 == 0 ? 4 : 0;
  v109 = &dl_ns;
  v107 = &dl_ns + 19 * v126 + 4;
  v115 = &dl_ns + 19 * v126;
  while ( 2 )
  {
    v108 = v105;
    *((_DWORD *)v125 + 1747) = 1;
    v131 = (unsigned int)v115[1];
    v4 = v131 + 15;
    v5 = &v105[-((v131 + 15) & 0xFFFFF000)];
    if ( v105 != v5 )
    {
      while ( v104 != v5 )
        ;
    }
    v6 = ((_WORD)v131 + 15) & 0xFF0;
    if ( (((_WORD)v131 + 15) & 0xFF0) != 0 )
    {
      v7 = alloca(v6);
      *(_DWORD *)&v103[v6 + 4089] = *(_DWORD *)&v103[v6 + 4089];
    }
    v8 = v4 & 0xFFF0;
    v9 = &v104[-(v4 & 0xFFFFF000)];
    if ( v104 != v9 )
    {
      while ( v102 != v9 )
        ;
    }
    v10 = v8 & 0xFFF;
    if ( v10 )
    {
      v14 = alloca(v10);
      *(_DWORD *)&v101[v10] = *(_DWORD *)&v101[v10];
    }
    v128 = v102;
    v11 = 4 * v131 + 15;
    v12 = &v102[-(v11 & 0xFFFFF000)];
    v13 = v11 & 0xFFF0;
    while ( v102 != v12 )
      ;
    v15 = v13 & 0xFFF;
    if ( v15 )
    {
      v16 = alloca(v15);
      *(_DWORD *)&v101[v15] = *(_DWORD *)&v101[v15];
    }
    v124 = (unsigned int)v103 >> 2;
    v129 = (int *)v102;
    if ( v114 )
      *(_DWORD *)(a1 + 520) &= ~8u;
    v17 = 0;
    v18 = *v115;
    if ( *v115 )
    {
      v19 = (int)v129;
      do
      {
        v18[132] = v17;
        *(_DWORD *)(v19 + 4 * v17) = v18;
        v18 = (_DWORD *)v18[3];
        ++v17;
      }
      while ( v18 );
    }
    if ( v131 != v17 )
      _assert_fail(
        (int)&aIdxNloaded[(_DWORD)v125 - 135061504],
        (int)&aDlCloseC[(_DWORD)v125 - 135061504],
        165,
        (int)&_PRETTY_FUNCTION___11769[(_DWORD)v125 - 135061504]);
    v20 = -1;
    memset(v104, 0, v131);
    memset(v128, 0, v131);
LABEL_29:
    while ( v131 > ++v20 )
    {
      while ( !v128[v20] )
      {
        v130 = v129[v20];
        LOBYTE(v127) = *(_BYTE *)(v130 + 408);
        if ( (v127 & 3) != 2
          || *(_DWORD *)(v130 + 404)
          || (*(_BYTE *)(v130 + 520) & 8) != 0
          || (v127 = *(_DWORD *)(v130 + 588)) != 0
          || v104[v20] )
        {
          v21 = v128;
          v104[v20] = 1;
          v21[v20] = 1;
          v22 = v130;
          *(_DWORD *)(v130 + 528) = -1;
          v23 = *(_DWORD *)(v22 + 500);
          if ( v23 )
          {
            v29 = (int *)(v23 + 4);
            v30 = *(_DWORD *)(v23 + 4);
            if ( v30 )
            {
              v31 = v131;
              do
              {
                v33 = *(_DWORD *)(v30 + 528);
                if ( v33 != -1 )
                {
                  if ( v33 < 0 || v31 <= v33 )
                    _assert_fail(
                      (int)&aLpLIdx0LpLIdxN[(_DWORD)v125 - 135061504],
                      (int)&aDlCloseC[(_DWORD)v125 - 135061504],
                      207,
                      (int)&_PRETTY_FUNCTION___11769[(_DWORD)v125 - 135061504]);
                  if ( !v104[v33] )
                  {
                    v104[v33] = 1;
                    v32 = *(_DWORD *)(*v29 + 528);
                    if ( v32 <= v20 )
                      v20 = v32 - 1;
                  }
                }
                v30 = *++v29;
              }
              while ( *v29 );
            }
          }
          v24 = *(unsigned int **)(v130 + 504);
          if ( v24 && *v24 )
          {
            v25 = 0;
            do
            {
              v27 = v24[v25 + 1];
              v28 = *(_DWORD *)(v27 + 528);
              if ( v28 != -1 )
              {
                if ( v28 < 0 || v131 <= v28 )
                  _assert_fail(
                    (int)&aJmapLIdx0JmapL[(_DWORD)v125 - 135061504],
                    (int)&aDlCloseC[(_DWORD)v125 - 135061504],
                    232,
                    (int)&_PRETTY_FUNCTION___11769[(_DWORD)v125 - 135061504]);
                if ( !v104[v28] )
                {
                  v104[v28] = 1;
                  v26 = *(_DWORD *)(v27 + 528);
                  if ( v26 <= v20 )
                    v20 = v26 - 1;
                  v24 = *(unsigned int **)(v130 + 504);
                }
              }
              ++v25;
            }
            while ( v25 < *v24 );
          }
          goto LABEL_29;
        }
        if ( v131 <= ++v20 )
          goto LABEL_60;
      }
    }
LABEL_60:
    v34 = v131;
    dl_sort_maps((int)v129 + v106, (__PAIR64__(v131, v126) - 1) >> 32, (int)&v104[v126 == 0], 1u);
    if ( !v34 )
      goto LABEL_148;
    v35 = *(_DWORD *)(4 * v124);
    if ( v126 != *(_DWORD *)(v35 + 24) )
LABEL_217:
      _assert_fail(
        (int)&aImapLNsNsid[(_DWORD)v125 - 135061504],
        (int)&aDlCloseC[(_DWORD)v125 - 135061504],
        262,
        (int)&_PRETTY_FUNCTION___11769[(_DWORD)v125 - 135061504]);
    v128 = v104;
    v124 = 0;
    v36 = 0;
    LOBYTE(v127) = 0;
    v113 = 0;
    v130 = -1;
    v121 = dl_debug_mask;
    while ( 1 )
    {
      v39 = *(_BYTE *)(v35 + 408);
      v42 = v39 & 3;
      if ( !v128[v36] )
      {
        if ( v42 != 2 || (*(_BYTE *)(v35 + 520) & 8) != 0 )
          _assert_fail(
            (int)&aImapLTypeLtLoa[(_DWORD)v125 - 135061504],
            (int)&aDlCloseC[(_DWORD)v125 - 135061504],
            267,
            (int)&_PRETTY_FUNCTION___11769[(_DWORD)v125 - 135061504]);
        if ( (v39 & 8) != 0 )
        {
          if ( (*v121 & 2) != 0 )
            dl_debug_printf((_BYTE *)v125 - 84041, *(_DWORD *)(v35 + 4), v126);
          v37 = *(_DWORD *)(v35 + 136);
          if ( v37 )
          {
            v75 = *(_DWORD *)(v37 + 4) + *(_DWORD *)v35;
            v76 = *(_DWORD *)(*(_DWORD *)(v35 + 144) + 4) >> 2;
            if ( v76 )
            {
              v127 = v35;
              v77 = (void (**)(void))(v75 + 4 * v76 - 4);
              v78 = (void (**)(void))v75;
              while ( 1 )
              {
                (*v77)();
                if ( v78 == v77 )
                  break;
                --v77;
              }
              v35 = v127;
            }
          }
          v38 = *(_DWORD *)(v35 + 84);
          if ( v38 )
            ((void (*)(void))(*(_DWORD *)(v38 + 4) + *(_DWORD *)v35))();
          v39 = *(_BYTE *)(v35 + 408);
        }
        *(_BYTE *)(v35 + 409) |= 0x20u;
        v40 = (v39 & 0x10) == 0;
        v41 = v130;
        v124 -= v40 - 1;
        LOBYTE(v127) = 1;
        if ( v130 > v36 )
          v41 = v36;
        v130 = v41;
LABEL_75:
        if ( v131 == ++v36 )
          break;
        goto LABEL_76;
      }
      if ( v42 != 2 )
        goto LABEL_75;
      if ( *(_DWORD *)(v35 + 352) )
      {
        v43 = *(int **)(v35 + 464);
        v44 = 1;
        v122 = 0;
        v45 = *v43;
        v120 = v43;
        if ( !v45 )
          goto LABEL_102;
      }
      else
      {
        v122 = *(_DWORD *)(v35 + 500);
        if ( v122 )
        {
          if ( *(_DWORD *)(v122 + 4) )
          {
            for ( i = 1; ; ++i )
            {
              v85 = i + 1;
              if ( !*(_DWORD *)(v122 + 4 * (i + 1)) )
                break;
            }
            v86 = 4 * i + 8;
          }
          else
          {
            v86 = 8;
            v85 = 1;
          }
          *(_DWORD *)(v35 + 356) = v85;
          v87 = v122 + v86;
          v122 = v35 + 352;
          v88 = *(int **)(v35 + 464);
          *(_DWORD *)(v35 + 352) = v87;
          v45 = *v88;
          v120 = v88;
          if ( !v45 )
          {
LABEL_156:
            *(_DWORD *)(v35 + 352) = 0;
            *(_DWORD *)(v35 + 356) = 0;
            goto LABEL_102;
          }
          v44 = 2;
        }
        else
        {
          v44 = 1;
          v45 = **(_DWORD **)(v35 + 464);
          v120 = *(int **)(v35 + 464);
          if ( !v45 )
            goto LABEL_102;
        }
      }
      v119 = (int *)v35;
      v123 = v35 + 360;
      v46 = v45;
      v47 = v120 + 1;
      v118 = v45;
      v117 = v36;
      v48 = 0;
      v116 = v120 + 1;
      do
      {
        while ( v46 != v123 )
        {
          if ( v126 != *(_DWORD *)(v46 - 328) )
            _assert_fail(
              (int)&aTmapLNsNsid[(_DWORD)v125 - 135061504],
              (int)&aDlCloseC[(_DWORD)v125 - 135061504],
              365,
              (int)&_PRETTY_FUNCTION___11769[(_DWORD)v125 - 135061504]);
          if ( *(_DWORD *)(v46 + 176) == -1 )
            break;
          v46 = *v47++;
          v48 = 1;
          if ( !v46 )
            goto LABEL_87;
        }
        v46 = *v47++;
        ++v44;
      }
      while ( v46 );
LABEL_87:
      v49 = v118;
      v35 = (int)v119;
      LOBYTE(v118) = v48;
      v36 = v117;
      if ( (_BYTE)v118 )
      {
        v50 = v119 + 111;
        v117 = (unsigned int)(v119 + 111);
        if ( v44 > 3 || (v119 += 111, v112 = 4, v50 == v120) )
        {
          v79 = *(_DWORD *)(v35 + 460);
          v111 = v49;
          v112 = v79;
          v80 = malloc((const struct timespec *)(4 * v79));
          v49 = v111;
          v119 = v80;
          if ( !v80 )
            dl_signal_error(
              12,
              (unsigned int *)&aDlclose[(_DWORD)v125 - 135061504],
              0,
              (unsigned int *)&aCannotCreateSc[(_DWORD)v125 - 135061504]);
        }
        v110 = v36;
        v51 = 0;
        v52 = (int)v119;
        v111 = v35;
        v53 = (int)v116;
        do
        {
          while ( 1 )
          {
            v56 = 4 * v51;
            v55 = (int *)(v52 + 4 * v51);
            if ( v49 != v123 && *(_DWORD *)(v49 + 176) != -1 )
              break;
            v53 += 4;
            *v55 = v49;
            ++v51;
            v55 = (int *)(v52 + v56 + 4);
            v49 = *(_DWORD *)(v53 - 4);
            if ( !v49 )
              goto LABEL_97;
          }
          v54 = v122;
          if ( v122 )
          {
            v122 = 0;
            ++v51;
            *v55 = v54;
            v55 = (int *)(v52 + v56 + 4);
          }
          v53 += 4;
          v49 = *(_DWORD *)(v53 - 4);
        }
        while ( v49 );
LABEL_97:
        v35 = v111;
        v36 = v110;
        *v55 = 0;
        *(_DWORD *)(v35 + 464) = v119;
        if ( (int *)v117 == v120 )
        {
          v113 = v118;
        }
        else
        {
          v57 = dl_scope_free((int)&savedregs, (int *)v36, (int)v120);
          v58 = v113;
          if ( v57 )
            v58 = 0;
          v113 = v58;
        }
        *(_DWORD *)(v35 + 460) = v112;
      }
      else if ( v122 )
      {
        goto LABEL_156;
      }
LABEL_102:
      v59 = *(_DWORD *)(v35 + 368);
      if ( v59 && *(_DWORD *)(v59 + 528) != -1 )
        *(_DWORD *)(v35 + 368) = 0;
      v60 = v130;
      if ( v130 > v36 )
        v60 = v36;
      ++v36;
      v130 = v60;
      if ( v131 == v36 )
        break;
LABEL_76:
      v35 = v129[v36];
      if ( v126 != *(_DWORD *)(v35 + 24) )
        goto LABEL_217;
    }
    v61 = (int *)v128;
    if ( (_BYTE)v127 )
    {
      v62 = dl_debug_initialize(0, v126);
      v62[3] = (void *)2;
      v121 = v62;
      dl_debug_state();
      if ( v124 )
      {
        v91 = (unsigned __int8 *)v115[2];
        v92 = *((_DWORD *)v91 + 1);
        v128 = v91;
        if ( v92 )
        {
          v93 = *(_DWORD *)v91;
          if ( (*(_BYTE *)(*(_DWORD *)(*(_DWORD *)v91 + 4 * v92 - 4) + 409) & 0x20) != 0 )
          {
            v94 = v92;
            while ( --v94 )
            {
              if ( (*(_BYTE *)(*(_DWORD *)(v93 + 4 * v94 - 4) + 409) & 0x20) == 0 )
              {
                v95 = v94;
                goto LABEL_198;
              }
            }
          }
          else
          {
            v95 = v92;
LABEL_198:
            v94 = v95;
            if ( v92 != v124 + v95 )
            {
              v94 = 0;
              for ( j = 0; j != v95; ++j )
              {
                v97 = *(_DWORD *)(v93 + 4 * j);
                if ( (*(_BYTE *)(v97 + 409) & 0x20) == 0 )
                {
                  if ( v94 != j )
                    *(_DWORD *)(v93 + 4 * v94) = v97;
                  ++v94;
                }
              }
            }
          }
        }
        else
        {
          v94 = 0;
        }
        *((_DWORD *)v128 + 1) = v94;
      }
      if ( __readgsdword(0xCu) && (v124 || v113 || dl_scope_free_list && *dl_scope_free_list) )
      {
        dl_wait_lookup_done();
        v98 = dl_scope_free_list;
        if ( dl_scope_free_list )
        {
          v99 = *dl_scope_free_list;
          if ( *dl_scope_free_list )
          {
            do
            {
              v100 = v99 - 1;
              *v98 = v100;
              free((int)&savedregs, v61, v98[v100 + 1]);
              v99 = *v98;
            }
            while ( *v98 );
          }
        }
      }
      v122 = 0;
      if ( v131 > v130 )
      {
        LOBYTE(v128) = 0;
        v124 = 0;
        v63 = (int *)((char *)v61 + v130);
        v123 = 0;
        v130 = (unsigned int)&v129[v130];
        v64 = (unsigned int)v61 + v131;
        v65 = v63;
        v131 = v64;
        while ( 1 )
        {
          while ( *(_BYTE *)v65 )
          {
            v65 = (int *)((char *)v65 + 1);
            v130 += 4;
            if ( (int *)v131 == v65 )
              goto LABEL_142;
          }
          v66 = *(int **)v130;
          if ( (*(_BYTE *)(*(_DWORD *)v130 + 408) & 3) != 2 )
            _assert_fail(
              (int)&aImapLTypeLtLoa_0[(_DWORD)v125 - 135061504],
              (int)&aDlCloseC[(_DWORD)v125 - 135061504],
              549,
              (int)&_PRETTY_FUNCTION___11769[(_DWORD)v125 - 135061504]);
          if ( !v66[142] )
            goto LABEL_117;
          if ( dl_tls_dtv_slotinfo_list
            && !(unsigned __int8)remove_slotinfo(
                                   v66[146],
                                   dl_tls_dtv_slotinfo_list,
                                   0,
                                   (*(_BYTE *)(*(_DWORD *)v130 + 408) & 8) != 0) )
          {
            dl_tls_max_dtv_idx = dl_tls_static_nelem;
          }
          v89 = v66[145];
          LOBYTE(v128) = v127;
          if ( v89 + 1 <= 1 )
            goto LABEL_117;
          v90 = v89 - v66[142];
          if ( !v123 || v89 == v123 )
            break;
          if ( v124 == v90 )
          {
            v124 = v89;
            LOBYTE(v128) = v127;
          }
          else
          {
            if ( dl_tls_static_used == v124 )
            {
              dl_tls_static_used = v123;
LABEL_188:
              v124 = v89;
LABEL_189:
              v123 = v90;
              LOBYTE(v128) = v127;
              goto LABEL_117;
            }
            if ( v89 == dl_tls_static_used )
            {
              dl_tls_static_used = v89 - v66[142];
              LOBYTE(v128) = v127;
            }
            else
            {
              LOBYTE(v128) = v127;
              if ( v89 > v124 )
              {
                v124 = v89;
                v123 = v90;
              }
            }
          }
LABEL_117:
          if ( v114 )
          {
            if ( v122 )
              MEMORY[0](v107);
            v67 = v115[10];
            if ( v67 )
            {
              v81 = v115;
              v82 = v115[11];
              if ( v82 )
              {
                v83 = &v67[4 * (_DWORD)v82];
                do
                {
                  if ( v67[1] && v66 == (int *)v67[3] )
                  {
                    v67[1] = 0;
                    *v67 = 0;
                    v81[12] = (char *)v81[12] - 1;
                  }
                  v67 += 4;
                }
                while ( v67 != v83 );
              }
            }
          }
          dl_unmap((int)v66);
          if ( v126 )
            _assert_fail(
              (int)&aNsidLmIdBase[(_DWORD)v125 - 135061504],
              (int)&aDlCloseC[(_DWORD)v125 - 135061504],
              689,
              (int)&_PRETTY_FUNCTION___11769[(_DWORD)v125 - 135061504]);
          v68 = v66[4];
          if ( !v68 )
            _assert_fail(
              (int)&aImapLPrevNull[(_DWORD)v125 - 135061504],
              (int)&aDlCloseC[(_DWORD)v125 - 135061504],
              690,
              (int)&_PRETTY_FUNCTION___11769[(_DWORD)v125 - 135061504]);
          v69 = v66[3];
          v70 = v109;
          *(_DWORD *)(v68 + 12) = v69;
          v70[1] = (char *)v70[1] - 1;
          if ( v69 )
            *(_DWORD *)(v69 + 16) = v68;
          free((int)&savedregs, v65, v66[93]);
          if ( v66[107] != -1 )
            free((int)&savedregs, v65, v66[107]);
          free((int)&savedregs, v65, v66[126]);
          if ( (dl_debug_mask[0] & 0x40) != 0 )
            dl_debug_printf((_BYTE *)v125 - 83700, v66[1], v66[6]);
          free((int)&savedregs, v65, v66[1]);
          v71 = v66[7];
          v129 = v66;
          do
          {
            while ( 1 )
            {
              v72 = *(_DWORD *)(v71 + 4);
              if ( !*(_DWORD *)(v71 + 8) )
                break;
              v71 = *(_DWORD *)(v71 + 4);
              if ( !v72 )
                goto LABEL_133;
            }
            free((int)&savedregs, v65, v71);
            v71 = v72;
          }
          while ( v72 );
LABEL_133:
          v73 = (int)v129;
          free((int)&savedregs, v65, v129[125]);
          v74 = *(_DWORD *)(v73 + 464);
          if ( v74 != v73 + 444 )
            free((int)&savedregs, v65, v74);
          if ( *(char *)(v73 + 408) < 0 )
            free((int)&savedregs, v65, *(_DWORD *)(v73 + 340));
          if ( *(_DWORD *)(v73 + 412) != -1 )
            free((int)&savedregs, v65, *(_DWORD *)(v73 + 412));
          if ( *(_DWORD *)(v73 + 492) != -1 )
            free((int)&savedregs, v65, *(_DWORD *)(v73 + 492));
          v65 = (int *)((char *)v65 + 1);
          free((int)&savedregs, v65, v73);
          v130 += 4;
          if ( (int *)v131 == v65 )
          {
LABEL_142:
            if ( (_BYTE)v128 )
            {
              if ( !++dl_tls_generation )
              {
                dl_dprintf(2, (_BYTE *)v125 - 83660);
                exit(127);
              }
              if ( dl_tls_static_used == v124 )
                dl_tls_static_used = v123;
            }
            goto LABEL_146;
          }
        }
        if ( !v124 )
          goto LABEL_188;
        goto LABEL_189;
      }
LABEL_146:
      if ( !*v115 && dl_nns - 1 == v126 )
        dl_nns = v126;
      *((_DWORD *)v121 + 3) = 0;
      dl_debug_state();
    }
LABEL_148:
    if ( *((_DWORD *)v125 + 1747) == 2 )
      continue;
    break;
  }
  result = v125;
  *((_DWORD *)v125 + 1747) = 0;
  return result;
}
// 80CE000: using guessed type _TBYTE GLOBAL_OFFSET_TABLE_;
// 80CE9C0: using guessed type int dl_nns;
// 80CEA00: using guessed type void *dl_ns;
// 80CFB4C: using guessed type int dl_close_state_11755;
// 80CFEC0: using guessed type _DWORD *dl_tls_dtv_slotinfo_list;
// 80CFF04: using guessed type _BYTE dl_debug_mask[4];
// 80CFF08: using guessed type int (*dl_wait_lookup_done)(void);
// 80CFF34: using guessed type _DWORD *dl_scope_free_list;

//----- (08098C60) --------------------------------------------------------
int __cdecl dl_close(int a1)
{
  if ( (*(_BYTE *)(a1 + 520) & 8) == 0 )
  {
    if ( !*(_DWORD *)(a1 + 404) )
      dl_signal_error(0, *(unsigned int **)(a1 + 4), 0, (unsigned int *)"shared object not open");
    dl_close_worker(a1, 0);
  }
  return 0;
}

//----- (08098D10) --------------------------------------------------------
unsigned int __cdecl dl_sort_maps(int a1, unsigned int a2, int a3, unsigned __int8 a4)
{
  unsigned int result; // eax
  unsigned __int8 *v5; // esi
  int v6; // ebx
  void *v7; // esp
  unsigned int v8; // edi
  unsigned __int8 *v9; // eax
  __int16 v10; // dx
  _DWORD *v11; // ebx
  unsigned int v12; // esi
  int v13; // edx
  int v14; // edi
  _DWORD *v15; // eax
  unsigned __int8 *v16; // edx
  _DWORD *v17; // ecx
  unsigned int v18; // edi
  char v19; // bl
  unsigned int v20; // edi
  int v21; // ebx
  int *v22; // eax
  int v23; // ecx
  int *v24; // eax
  int v25; // ecx
  unsigned __int8 v27[4092]; // [esp+4h] [ebp-104Ch] BYREF
  _DWORD v28[3]; // [esp+1004h] [ebp-4Ch] BYREF
  unsigned int v29; // [esp+1010h] [ebp-40h]
  _DWORD *v30; // [esp+1014h] [ebp-3Ch]
  unsigned __int8 *v31; // [esp+1018h] [ebp-38h]
  _BYTE *v32; // [esp+101Ch] [ebp-34h]
  unsigned int v33; // [esp+1020h] [ebp-30h]
  unsigned __int8 *v34; // [esp+1024h] [ebp-2Ch]
  unsigned int v35; // [esp+1028h] [ebp-28h]
  __int16 v36; // [esp+102Ch] [ebp-24h]
  unsigned __int8 v37; // [esp+102Fh] [ebp-21h]
  unsigned int v38; // [esp+1030h] [ebp-20h]

  v28[2] = &GLOBAL_OFFSET_TABLE_;
  result = a4;
  v37 = a4;
  if ( a2 > 1 )
  {
    v5 = (unsigned __int8 *)v28 - ((2 * a2 + 15) & 0xFFFFF000);
    if ( v28 != (_DWORD *)v5 )
    {
      while ( v27 != v5 )
        ;
    }
    v6 = (2 * (_WORD)a2 + 15) & 0xFF0;
    if ( ((2 * (_WORD)a2 + 15) & 0xFF0) != 0 )
    {
      v7 = alloca(v6);
      *(_DWORD *)&v27[v6 - 4] = *(_DWORD *)&v27[v6 - 4];
    }
    v28[1] = v28;
    v34 = v27;
    memset(v27, 0, 2 * a2);
    v38 = 0;
    v35 = 1;
    v29 = a1 + 4 * a2 - 4;
    while ( 1 )
    {
LABEL_7:
      v8 = v38;
      v9 = &v34[2 * v38];
      v10 = *(_WORD *)v9;
      v31 = v9;
      *(_WORD *)v9 = v10 + 1;
      v33 = 4 * v8;
      v11 = *(_DWORD **)(a1 + 4 * v8);
      v36 = v10 + 1;
      v32 = (_BYTE *)(a1 + 4 * v8);
      if ( !v37 || (_DWORD *)v11[5] == v11 && v11[132] != -1 )
      {
        v12 = a2 - 1;
        if ( v38 < a2 - 1 )
        {
          v13 = v29;
          do
          {
            v14 = *(_DWORD *)v13;
            v15 = *(_DWORD **)(*(_DWORD *)v13 + 500);
            if ( v15 )
            {
              while ( 1 )
              {
                v17 = (_DWORD *)*v15;
                if ( !*v15 )
                  break;
                ++v15;
                if ( v17 == v11 )
                {
LABEL_18:
                  v30 = (_DWORD *)v13;
                  v18 = v12 - v38;
                  memmove(v32, (_BYTE *)(a1 + v33 + 4), 4 * (v12 - v38));
                  *v30 = v11;
                  if ( a3 )
                  {
                    v19 = *(_BYTE *)(a3 + v38);
                    memmove((_BYTE *)(a3 + v38), (_BYTE *)(a3 + v35), v18);
                    *(_BYTE *)(a3 + v12) = v19;
                  }
                  v16 = &v34[2 * v35];
                  if ( *((unsigned __int16 *)v31 + 1) <= a2 - v38 )
                  {
                    v21 = (int)v34;
                    memmove(&v34[2 * v35 - 2], v16, 2 * v18);
                    *(_WORD *)(v21 + 2 * v12) = v36;
                    goto LABEL_7;
                  }
                  goto LABEL_21;
                }
              }
            }
            if ( v37 )
            {
              v22 = *(int **)(v14 + 504);
              if ( v22 )
              {
                v23 = *v22;
                while ( v23 )
                {
                  if ( (_DWORD *)v22[v23--] == v11 )
                  {
                    v24 = (int *)v11[125];
                    if ( v24 )
                    {
                      while ( 1 )
                      {
                        v25 = *v24;
                        if ( !*v24 )
                          break;
                        ++v24;
                        if ( v14 == v25 )
                          goto LABEL_12;
                      }
                    }
                    goto LABEL_18;
                  }
                }
              }
            }
LABEL_12:
            --v12;
            v13 -= 4;
          }
          while ( v38 != v12 );
        }
      }
      result = v35;
      if ( a2 == v35 )
        break;
      v16 = &v34[2 * v35];
LABEL_21:
      v20 = v35;
      memset(v16, 0, 2 * (a2 - v35));
      v38 = v20;
      v35 = v20 + 1;
    }
  }
  return result;
}
// 80CE000: using guessed type _TBYTE GLOBAL_OFFSET_TABLE_;

//----- (08098F80) --------------------------------------------------------
int __usercall dl_tlsdesc_resolve_early_return_p@<eax>(
        int (__usercall **a1)@<eax>(char **a1@<eax>, int a2@<edx>, int a3@<ecx>)@<eax>,
        int (__usercall *a2)@<eax>(char **a1@<eax>, int a2@<edx>, int a3@<ecx>)@<edx>)
{
  if ( *a1 != a2 || a2 != *a1 )
    return 1;
  *a1 = dl_tlsdesc_resolve_hold;
  return 0;
}

//----- (08099000) --------------------------------------------------------
int __usercall dl_tlsdesc_resolve_abs_plus_addend_fixup@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>)
{
  int v5; // edi
  int result; // eax
  int v7; // eax
  char *retaddr; // [esp+10h] [ebp+0h]

  v5 = *(_DWORD *)(a1 + 4);
  result = dl_tlsdesc_resolve_early_return_p(
             (int (__usercall **)@<eax>(char **@<eax>, int@<edx>, int@<ecx>))a1,
             (int (__usercall *)@<eax>(char **@<eax>, int@<edx>, int@<ecx>))&retaddr[-a3]);
  if ( !result )
  {
    v7 = *(_DWORD *)(a2 + 580);
    if ( (unsigned int)(v7 + 1) <= 1 )
    {
      dl_allocate_static_tls(a2);
      v7 = *(_DWORD *)(a2 + 580);
    }
    *(_DWORD *)(a1 + 4) = v5 - v7;
    *(_DWORD *)a1 = dl_tlsdesc_return;
    return 0;
  }
  return result;
}

//----- (08099090) --------------------------------------------------------
int __usercall dl_tlsdesc_resolve_rel_fixup@<eax>(int a1@<eax>, _DWORD *a2@<edx>, int a3@<ecx>)
{
  int v5; // ebp
  int result; // eax
  int v7; // ebp
  int v8; // edx
  unsigned __int8 v9; // cl
  _DWORD *v10; // ecx
  int v11; // edx
  int v12; // [esp+0h] [ebp-30h]
  int v13[8]; // [esp+10h] [ebp-20h] BYREF
  char *retaddr; // [esp+30h] [ebp+0h]

  v5 = *(_DWORD *)(a1 + 4);
  result = dl_tlsdesc_resolve_early_return_p(
             (int (__usercall **)@<eax>(char **@<eax>, int@<edx>, int@<ecx>))a1,
             (int (__usercall *)@<eax>(char **@<eax>, int@<edx>, int@<ecx>))&retaddr[-a3]);
  if ( !result )
  {
    v7 = *(_DWORD *)(v5 + 4) >> 8;
    v12 = *(_DWORD *)(a2[13] + 4);
    v8 = *(_DWORD *)(a2[14] + 4) + 16 * v7;
    v9 = *(_BYTE *)(v8 + 12);
    v13[0] = v8;
    if ( !(v9 >> 4) || (*(_BYTE *)(v8 + 13) & 3) != 0 )
      goto LABEL_10;
    v10 = (_DWORD *)a2[58];
    if ( v10 )
    {
      v10 = (_DWORD *)(a2[93] + 16 * (*(_WORD *)(v10[1] + 2 * v7) & 0x7FFF));
      if ( !v10[1] )
        v10 = 0;
    }
    a2 = dl_lookup_symbol_x((unsigned __int8 *)(*(_DWORD *)v8 + v12), a2, v13, (int **)a2[116], v10, 1, 1, 0);
    if ( v13[0] )
    {
LABEL_10:
      v11 = a2[145];
      if ( (unsigned int)(v11 + 1) <= 1 )
      {
        dl_allocate_static_tls((int)a2);
        v11 = a2[145];
      }
      *(_DWORD *)(a1 + 4) = *(_DWORD *)(v13[0] + 4) - v11;
      *(_DWORD *)a1 = dl_tlsdesc_return;
      return 0;
    }
    else
    {
      *(_DWORD *)(a1 + 4) = 0;
      *(_DWORD *)a1 = dl_tlsdesc_undefweak;
      return 0;
    }
  }
  return result;
}
// 8099090: using guessed type int var_20[8];

//----- (080991D0) --------------------------------------------------------
int __usercall dl_tlsdesc_resolve_rela_fixup@<eax>(int a1@<eax>, _DWORD *a2@<edx>, int a3@<ecx>)
{
  int v5; // ebp
  int result; // eax
  int v7; // eax
  int v8; // edx
  unsigned __int8 v9; // cl
  _DWORD *v10; // ecx
  int v11; // edx
  int v12; // [esp+4h] [ebp-30h]
  int v13[8]; // [esp+14h] [ebp-20h] BYREF
  char *retaddr; // [esp+34h] [ebp+0h]

  v5 = *(_DWORD *)(a1 + 4);
  result = dl_tlsdesc_resolve_early_return_p(
             (int (__usercall **)@<eax>(char **@<eax>, int@<edx>, int@<ecx>))a1,
             (int (__usercall *)@<eax>(char **@<eax>, int@<edx>, int@<ecx>))&retaddr[-a3]);
  if ( !result )
  {
    v12 = *(_DWORD *)(a2[13] + 4);
    v7 = *(_DWORD *)(v5 + 4) >> 8;
    v8 = *(_DWORD *)(a2[14] + 4) + 16 * v7;
    v9 = *(_BYTE *)(v8 + 12);
    v13[0] = v8;
    if ( !(v9 >> 4) || (*(_BYTE *)(v8 + 13) & 3) != 0 )
      goto LABEL_10;
    v10 = (_DWORD *)a2[58];
    if ( v10 )
    {
      v10 = (_DWORD *)(a2[93] + 16 * (*(_WORD *)(v10[1] + 2 * v7) & 0x7FFF));
      if ( !v10[1] )
        v10 = 0;
    }
    a2 = dl_lookup_symbol_x((unsigned __int8 *)(*(_DWORD *)v8 + v12), a2, v13, (int **)a2[116], v10, 1, 1, 0);
    if ( v13[0] )
    {
LABEL_10:
      v11 = a2[145];
      if ( (unsigned int)(v11 + 1) <= 1 )
      {
        dl_allocate_static_tls((int)a2);
        v11 = a2[145];
      }
      *(_DWORD *)(a1 + 4) = *(_DWORD *)(v13[0] + 4) + *(_DWORD *)(v5 + 8) - v11;
      *(_DWORD *)a1 = dl_tlsdesc_return;
      return 0;
    }
    else
    {
      *(_DWORD *)(a1 + 4) = *(_DWORD *)(v5 + 8);
      *(_DWORD *)a1 = dl_tlsdesc_undefweak;
      return 0;
    }
  }
  return result;
}
// 80991D0: using guessed type int var_20[8];

//----- (08099320) --------------------------------------------------------
char *__usercall dl_tlsdesc_resolve_hold_fixup@<eax>(char **a1@<eax>, int a2@<ecx>)
{
  char *v2; // edx
  char *result; // eax
  char *retaddr; // [esp+4h] [ebp+0h]

  v2 = *a1;
  result = &retaddr[-a2];
  if ( v2 == &retaddr[-a2] )
    return 0;
  return result;
}

//----- (08099390) --------------------------------------------------------
unsigned int __cdecl dl_unmap(int a1)
{
  return munmap(*(void **)(a1 + 432), *(_DWORD *)(a1 + 436) - *(_DWORD *)(a1 + 432));
}

//----- (080993C0) --------------------------------------------------------
char __cdecl dl_cet_open_check(int a1)
{
  int v1; // ebp
  int v2; // eax
  char v3; // cl
  int v4; // edx
  unsigned int v5; // eax
  _DWORD *v6; // ebp
  int v7; // esi
  const void *v8; // eax
  int v9; // ebp
  unsigned int v10; // ecx
  unsigned int v11; // eax
  unsigned int v12; // ecx
  int v13; // esi
  _DWORD *v14; // ebx
  int v15; // edx
  int v16; // eax
  char v17; // dl
  int v18; // ecx
  char v19; // cl
  unsigned int *v20; // eax
  int v22; // [esp+0h] [ebp-68h]
  unsigned int v23; // [esp+4h] [ebp-64h]
  int v24; // [esp+8h] [ebp-60h]
  int v25; // [esp+Ch] [ebp-5Ch]
  int v26; // [esp+14h] [ebp-54h]
  int v27; // [esp+18h] [ebp-50h]
  _DWORD *v28; // [esp+1Ch] [ebp-4Ch]
  unsigned int v29; // [esp+20h] [ebp-48h]
  int v30; // [esp+24h] [ebp-44h]
  __int16 v31; // [esp+28h] [ebp-40h]
  char v32; // [esp+2Ah] [ebp-3Eh]
  unsigned __int8 v33; // [esp+2Bh] [ebp-3Dh]
  unsigned int v34; // [esp+2Ch] [ebp-3Ch]
  char v35; // [esp+30h] [ebp-38h]
  unsigned int v36; // [esp+34h] [ebp-34h]
  int v37; // [esp+3Ch] [ebp-2Ch] BYREF
  unsigned int v38; // [esp+44h] [ebp-24h]

  v1 = dl_x86_feature_1[1] & 7;
  v24 = (dl_x86_feature_1[1] >> 3) & 7;
  v25 = v1;
  LOBYTE(v2) = v24 == 2;
  v3 = v24 == 2 && v1 == 2;
  if ( !v3 )
  {
    LOBYTE(v2) = dl_x86_feature_1[0];
    if ( (dl_x86_feature_1[0] & 3) != 0 )
    {
      v33 = dl_x86_feature_1[0] & 1;
      v32 = (dl_x86_feature_1[0] & 2) != 0;
      LOBYTE(v31) = dl_x86_feature_1[0] & 1 & (v1 != 1);
      HIBYTE(v31) = v32 & (v24 != 1);
      v4 = (unsigned __int8)(HIBYTE(v31) | v31);
      if ( v31 )
      {
        v5 = *(_DWORD *)(a1 + 356);
        v6 = 0;
        while ( --v5 != -1 )
        {
          while ( 1 )
          {
            v4 = *(_DWORD *)(a1 + 500);
            v6 = *(_DWORD **)(v4 + 4 * v5);
            if ( (v6[102] & 8) != 0 )
              break;
            LOBYTE(v4) = v31 & (v25 != 2);
            if ( (_BYTE)v4 )
            {
              if ( (*((_BYTE *)v6 + 410) & 4) == 0 )
              {
                v23 = v5;
                if ( !v3 )
                {
                  v29 = v5;
                  v3 = v31 & (v25 != 2);
                }
              }
            }
            if ( v24 == 2 )
              break;
            v4 = *((unsigned __int8 *)v6 + 410);
            --v5;
            LOBYTE(v4) = (unsigned __int8)v4 >> 3;
            HIBYTE(v31) &= v4;
            if ( v5 == -1 )
              goto LABEL_13;
          }
        }
LABEL_13:
        if ( v3 )
        {
          if ( dl_x86_legacy_bitmap )
          {
            if ( (mprotect(dl_x86_legacy_bitmap, *((_DWORD *)&dl_x86_legacy_bitmap + 1), 3) & 0x80000000) != 0 )
              goto LABEL_50;
            v34 = *((_DWORD *)&dl_x86_legacy_bitmap + 1);
            v27 = dl_x86_legacy_bitmap;
          }
          else
          {
            if ( ((int (__fastcall *)(int *, int))__readgsdword(0x10u))(&v37, v4) )
            {
              v20 = (unsigned int *)(&GLOBAL_OFFSET_TABLE_ - 8344);
              goto LABEL_45;
            }
            v27 = v37;
            dl_x86_legacy_bitmap = v37;
            v34 = v38;
            *((_DWORD *)&dl_x86_legacy_bitmap + 1) = v38;
          }
          if ( v23 > v29 )
          {
            v8 = (const void *)v27;
          }
          else
          {
            v30 = *(_DWORD *)(a1 + 500);
            v36 = dl_pagesize;
            do
            {
              v7 = *(_DWORD *)(v30 + 4 * v23);
              v8 = (const void *)v27;
              v28 = (_DWORD *)v7;
              if ( (*(_BYTE *)(v7 + 408) & 8) == 0 && (*(_BYTE *)(v7 + 410) & 4) == 0 )
              {
                v26 = *(unsigned __int16 *)(v7 + 348);
                if ( *(_WORD *)(v7 + 348) )
                {
                  v9 = *(_DWORD *)(v7 + 340);
                  v22 = 0;
                  do
                  {
                    if ( *(_DWORD *)v9 == 1 && (*(_BYTE *)(v9 + 24) & 1) != 0 )
                    {
                      v10 = (*(_DWORD *)(v9 + 8) + *v28) / v36;
                      v11 = (v36 + *(_DWORD *)(v9 + 20) - 1) / v36;
                      v35 = v10 + v11;
                      if ( v34 < (v10 + v11) >> 3 )
                      {
                        v6 = v28;
                        v20 = (unsigned int *)((char *)&GLOBAL_OFFSET_TABLE_ - 83408);
LABEL_45:
                        dl_signal_error(22, (unsigned int *)v6[1], (int)&GLOBAL_OFFSET_TABLE_ - 106709, v20);
                      }
                      v12 = ((*(_DWORD *)(v9 + 8) + *v28) / v36) & 0x1F;
                      v13 = 32 - v12;
                      v14 = (_DWORD *)(v27 + 4 * (((*(_DWORD *)(v9 + 8) + *v28) / v36) >> 5));
                      v15 = -1 << v12;
                      if ( v11 >= 32 - v12 )
                      {
                        do
                        {
                          v11 -= v13;
                          *v14 |= v15;
                          v13 = 32;
                          ++v14;
                          v15 = -1;
                        }
                        while ( v11 > 0x1F );
                      }
                      if ( v11 )
                        *v14 |= (0xFFFFFFFF >> -v35) & v15;
                    }
                    ++v22;
                    v9 += 32;
                  }
                  while ( v26 != v22 );
                  v8 = (const void *)dl_x86_legacy_bitmap;
                  v34 = *((_DWORD *)&dl_x86_legacy_bitmap + 1);
                  v27 = dl_x86_legacy_bitmap;
                }
              }
              ++v23;
            }
            while ( v23 <= v29 );
            v6 = v28;
          }
          if ( (mprotect(v8, v34, 1) & 0x80000000) != 0 )
          {
LABEL_50:
            v20 = (unsigned int *)((char *)&GLOBAL_OFFSET_TABLE_ - 83515);
            goto LABEL_45;
          }
        }
        LOBYTE(v4) = HIBYTE(v31);
        v19 = HIBYTE(v31) ^ v32;
      }
      else
      {
        v19 = (dl_x86_feature_1[0] & 2) != 0;
        v6 = 0;
      }
      LOBYTE(v2) = v25 == 1;
      if ( ((v25 == 1) & v33) != 0 || v19 )
      {
        if ( v24 == 3 )
        {
          v16 = ((int (__fastcall *)(int))__readgsdword(0x10u))(2 * ((_BYTE)v4 == 0));
          if ( v16 )
            dl_signal_error(
              -v16,
              (unsigned int *)v6[1],
              (int)&GLOBAL_OFFSET_TABLE_ - 106709,
              (unsigned int *)((char *)&GLOBAL_OFFSET_TABLE_ - 83458));
          v2 = (unsigned __int8)v31;
          dl_x86_feature_1[0] &= ~v18;
          if ( v17 )
            v2 = (unsigned __int8)v31 | 2;
          __writegsdword(0x20u, v2);
        }
        else if ( v32 != (_BYTE)v4 )
        {
          v20 = (unsigned int *)((char *)&GLOBAL_OFFSET_TABLE_ - 83485);
          goto LABEL_45;
        }
      }
    }
  }
  return v2;
}
// 809951B: variable 'v23' is possibly undefined
// 809951B: variable 'v29' is possibly undefined
// 809966B: variable 'v18' is possibly undefined
// 8099676: variable 'v17' is possibly undefined
// 80CE000: using guessed type _TBYTE GLOBAL_OFFSET_TABLE_;
// 80CE9B0: using guessed type int dl_pagesize;
// 80CFF1C: using guessed type _DWORD dl_x86_feature_1[2];

//----- (080997C0) --------------------------------------------------------
int __cdecl dl_addr(unsigned int a1, _DWORD *a2, _DWORD *a3, unsigned int *a4)
{
  int v4; // esi
  _DWORD *dso_for_object; // eax
  _BYTE *v6; // edx
  int v7; // ecx
  unsigned int v8; // ebp
  unsigned int v9; // edx
  int v10; // edx
  int *v11; // esi
  int v12; // edx
  int v13; // ecx
  unsigned int v14; // edx
  unsigned int v15; // edi
  int v16; // ebx
  __int16 v17; // bx
  bool v18; // zf
  int v19; // eax
  int v21; // ecx
  unsigned int v22; // edi
  __int16 v23; // cx
  unsigned int v24; // ecx
  unsigned int v25; // ebx
  int v26; // esi
  unsigned int v27; // eax
  _DWORD *v28; // [esp+0h] [ebp-38h]
  int *v29; // [esp+4h] [ebp-34h]
  unsigned int v30; // [esp+8h] [ebp-30h]
  unsigned int v31; // [esp+10h] [ebp-28h]
  int v32; // [esp+14h] [ebp-24h]
  unsigned int v33; // [esp+18h] [ebp-20h]

  v4 = 0;
  dso_for_object = dl_find_dso_for_object(a1);
  if ( !dso_for_object )
    return v4;
  v6 = (_BYTE *)dso_for_object[1];
  v7 = *(_DWORD *)((char *)dso_for_object + (_DWORD)(&off_80CE1B0 - 33765376));
  *a2 = v6;
  a2[1] = v7;
  if ( !*v6 && (byte_80CE198[(_DWORD)dso_for_object - 135061504] & 3) == 0 )
    *a2 = program_invocation_short_name[0];
  v8 = *(_DWORD *)((char *)dso_for_object + (_DWORD)(&dword_80CE150 - 33765376));
  v31 = *(_DWORD *)(dso_for_object[14] + 4);
  v9 = v31;
  v32 = *(_DWORD *)(dso_for_object[13] + 4);
  v33 = *(_DWORD *)(dso_for_object[18] + 4);
  if ( v8 )
  {
    v10 = *(_DWORD *)((char *)dso_for_object + (_DWORD)(&dword_80CE17C - 33765376));
    if ( v10 )
    {
      v11 = *(int **)((char *)dso_for_object + (_DWORD)(&dword_80CE18C - 33765376));
      v30 = 0;
      v29 = &v11[v10];
      while ( 1 )
      {
        while ( 1 )
        {
          v12 = *v11;
          if ( *v11 )
            break;
          if ( v29 == ++v11 )
            goto LABEL_20;
        }
        v28 = dso_for_object;
        v13 = *(_DWORD *)((char *)dso_for_object + (_DWORD)(&dword_80CE190 - 33765376)) + 4 * v12;
        v14 = v31 + 16 * v12;
        do
        {
          while ( 1 )
          {
            v17 = *(_WORD *)(v14 + 14);
            if ( v17 )
              break;
            if ( !*(_DWORD *)(v14 + 4) )
              goto LABEL_15;
LABEL_10:
            if ( (*(_BYTE *)(v14 + 12) & 0xF) == 6 )
              goto LABEL_15;
            v15 = *v28 + *(_DWORD *)(v14 + 4);
            if ( a1 < v15 )
              goto LABEL_15;
            if ( v17 )
            {
              v16 = *(_DWORD *)(v14 + 8);
              if ( !v16 )
              {
                if ( a1 == v15 )
                  goto LABEL_52;
                goto LABEL_15;
              }
            }
            else
            {
              if ( a1 == v15 )
                goto LABEL_52;
              v16 = *(_DWORD *)(v14 + 8);
            }
            if ( a1 < v16 + v15 )
            {
LABEL_52:
              if ( !v30 || *(_DWORD *)(v14 + 4) > *(_DWORD *)(v30 + 4) )
              {
                v27 = v30;
                if ( v33 > *(_DWORD *)v14 )
                  v27 = v14;
                v30 = v27;
              }
            }
LABEL_15:
            v13 += 4;
            v14 += 16;
            if ( (*(_BYTE *)(v13 - 4) & 1) != 0 )
              goto LABEL_19;
          }
          if ( v17 != -15 )
            goto LABEL_10;
          v13 += 4;
          v14 += 16;
        }
        while ( (*(_BYTE *)(v13 - 4) & 1) == 0 );
LABEL_19:
        dso_for_object = v28;
        if ( v29 == ++v11 )
        {
LABEL_20:
          v8 = v30;
          goto LABEL_21;
        }
      }
    }
    v8 = 0;
    goto LABEL_21;
  }
  v21 = dso_for_object[12];
  v22 = *(_DWORD *)(dso_for_object[13] + 4);
  if ( v21 )
    v22 = v31 + 16 * *(_DWORD *)(*(_DWORD *)(v21 + 4) + 4);
  if ( v31 < v22 )
  {
    while ( 1 )
    {
      if ( (unsigned __int8)((*(_BYTE *)(v9 + 12) >> 4) - 1) > 1u
        || (*(_BYTE *)(v9 + 13) & 3u) - 1 <= 1
        || (*(_BYTE *)(v9 + 12) & 0xF) == 6 )
      {
        goto LABEL_46;
      }
      v23 = *(_WORD *)(v9 + 14);
      if ( !v23 )
        break;
      if ( v23 == -15 )
        goto LABEL_46;
      v24 = *(_DWORD *)(v9 + 4);
      v25 = v24 + *dso_for_object;
      if ( a1 < v25 )
        goto LABEL_46;
      v26 = *(_DWORD *)(v9 + 8);
      if ( v26 )
        goto LABEL_41;
      if ( a1 == v25 )
      {
LABEL_42:
        if ( (!v8 || *(_DWORD *)(v8 + 4) < v24) && v33 > *(_DWORD *)v9 )
          v8 = v9;
      }
LABEL_46:
      v9 += 16;
      if ( v9 >= v22 )
        goto LABEL_21;
    }
    v24 = *(_DWORD *)(v9 + 4);
    if ( !v24 )
      goto LABEL_46;
    v25 = v24 + *dso_for_object;
    if ( a1 < v25 )
      goto LABEL_46;
    if ( a1 == v25 )
      goto LABEL_42;
    v26 = *(_DWORD *)(v9 + 8);
LABEL_41:
    if ( a1 < v26 + v25 )
      goto LABEL_42;
    goto LABEL_46;
  }
LABEL_21:
  if ( a3 )
    *a3 = dso_for_object;
  if ( a4 )
    *a4 = v8;
  if ( v8 )
  {
    v18 = *(_WORD *)(v8 + 14) == 0xFFF1;
    a2[2] = *(_DWORD *)v8 + v32;
    if ( v18 )
      v19 = 0;
    else
      v19 = *dso_for_object;
    a2[3] = *(_DWORD *)(v8 + 4) + v19;
    return 1;
  }
  else
  {
    v4 = 1;
    a2[2] = 0;
    a2[3] = 0;
  }
  return v4;
}
// 80CDDA4: using guessed type char (**dl_argv)[1671];
// 80CE150: using guessed type int dword_80CE150;
// 80CE17C: using guessed type int dword_80CE17C;
// 80CE18C: using guessed type int dword_80CE18C;
// 80CE190: using guessed type int dword_80CE190;
// 80CE1B0: using guessed type void *off_80CE1B0;
// 80CE964: using guessed type char (*program_invocation_short_name[2])[1671];

//----- (08099B20) --------------------------------------------------------
int __cdecl dl_addr_inside_object(int a1, int a2)
{
  int v2; // edx
  _DWORD *v3; // eax

  v2 = *(unsigned __int16 *)(a1 + 348);
  while ( --v2 != -1 )
  {
    v3 = (_DWORD *)(*(_DWORD *)(a1 + 340) + 32 * v2);
    if ( *v3 == 1 && (unsigned int)(a2 - *(_DWORD *)a1 - v3[2]) < v3[5] )
      return 1;
  }
  return 0;
}

//----- (08099B80) --------------------------------------------------------
char *__usercall sub_8099B80@<eax>(int a1@<eax>)
{
  char *retaddr; // [esp+0h] [ebp+0h]

  return &retaddr[a1];
}

//----- (08099B90) --------------------------------------------------------
_BOOL4 __cdecl _mpn_add_n(_DWORD *a1, _DWORD *a2, _DWORD *a3, unsigned int a4)
{
  unsigned int v7; // ecx
  bool v8; // cf
  char *v9; // kr00_4
  _BOOL4 v10; // ett
  int v11; // eax
  int v12; // eax
  _BOOL4 v13; // ett
  int v14; // eax
  int v15; // eax
  _BOOL4 v16; // ett
  int v17; // eax
  int v18; // eax
  _BOOL4 v19; // ett
  int v20; // eax
  int v21; // eax
  _BOOL4 v22; // ett
  int v23; // eax
  int v24; // eax
  _BOOL4 v25; // ett
  int v26; // eax
  int v27; // eax
  _BOOL4 v28; // ett
  int v29; // eax
  int v30; // eax
  _BOOL4 v31; // ett

  v7 = a4 >> 3;
  v8 = 0;
  if ( (-a4 & 7) != 0 )
  {
    v9 = &sub_8099B80(9 * ((4 * (-a4 & 7)) >> 2) + 2)[4 * ((4 * (-a4 & 7)) >> 2) - 4];
    __asm { jmp     eax }
  }
  do
  {
    v10 = v8;
    v8 = __CFADD__(v8, *a2) | __CFADD__(*a3, v8 + *a2);
    *a1 = *a3 + v10 + *a2;
    v11 = a2[1];
    v13 = v8;
    v8 = __CFADD__(v8, v11);
    v12 = v13 + v11;
    v8 |= __CFADD__(a3[1], v12);
    a1[1] = a3[1] + v12;
    v14 = a2[2];
    v16 = v8;
    v8 = __CFADD__(v8, v14);
    v15 = v16 + v14;
    v8 |= __CFADD__(a3[2], v15);
    a1[2] = a3[2] + v15;
    v17 = a2[3];
    v19 = v8;
    v8 = __CFADD__(v8, v17);
    v18 = v19 + v17;
    v8 |= __CFADD__(a3[3], v18);
    a1[3] = a3[3] + v18;
    v20 = a2[4];
    v22 = v8;
    v8 = __CFADD__(v8, v20);
    v21 = v22 + v20;
    v8 |= __CFADD__(a3[4], v21);
    a1[4] = a3[4] + v21;
    v23 = a2[5];
    v25 = v8;
    v8 = __CFADD__(v8, v23);
    v24 = v25 + v23;
    v8 |= __CFADD__(a3[5], v24);
    a1[5] = a3[5] + v24;
    v26 = a2[6];
    v28 = v8;
    v8 = __CFADD__(v8, v26);
    v27 = v28 + v26;
    v8 |= __CFADD__(a3[6], v27);
    a1[6] = a3[6] + v27;
    v29 = a2[7];
    v31 = v8;
    v8 = __CFADD__(v8, v29);
    v30 = v31 + v29;
    v8 |= __CFADD__(a3[7], v30);
    a1[7] = a3[7] + v30;
    a1 += 8;
    a2 += 8;
    a3 += 8;
    --v7;
  }
  while ( v7 );
  return v8;
}

//----- (08099C50) --------------------------------------------------------
int __cdecl _mpn_addmul_1(int a1, int a2, int a3, unsigned int a4)
{
  int v4; // edi
  int v5; // ecx
  unsigned int v6; // ebp
  unsigned __int64 v7; // kr00_8

  v4 = a1 + 4 * a3;
  v5 = -a3;
  v6 = 0;
  do
  {
    v7 = v6 + a4 * (unsigned __int64)*(unsigned int *)(a2 + 4 * a3 + 4 * v5) + *(unsigned int *)(v4 + 4 * v5);
    *(_DWORD *)(v4 + 4 * v5) = v7;
    v6 = HIDWORD(v7);
    ++v5;
  }
  while ( v5 );
  return HIDWORD(v7);
}

//----- (08099CA0) --------------------------------------------------------
int __cdecl dlopen_doit(int a1)
{
  int v1; // edx
  unsigned int *v2; // ecx
  int v3; // edx
  int result; // eax
  unsigned __int8 *v5; // eax

  v1 = *(_DWORD *)(a1 + 4);
  if ( (v1 & 0xBFFFEEF0) != 0 )
  {
    v5 = dcgettext("libc", "invalid mode parameter", 5u);
    dl_signal_error(0, 0, 0, (unsigned int *)v5);
  }
  v2 = *(unsigned int **)a1;
  v3 = v1 | 0x80000000;
  if ( !*(_DWORD *)a1 )
    v2 = (unsigned int *)byte_80B41F9;
  result = dl_open(v2, v3, *(_DWORD *)(a1 + 12), 0, _libc_argc, _libc_argv, (int)environ);
  *(_DWORD *)(a1 + 8) = result;
  return result;
}
// 80B41F9: using guessed type unsigned __int8 byte_80B41F9[1671];
// 80CF89C: using guessed type _DWORD *environ;
// 80CFF74: using guessed type int _libc_argc;
// 80CFF78: using guessed type int _libc_argv;

//----- (08099D30) --------------------------------------------------------
int __usercall _dlopen@<eax>(int a1@<ebp>, int *edi0@<edi>, int a3, int a4, int a5)
{
  int v5; // eax
  int v6; // edx
  int v8[2]; // [esp+0h] [ebp-20h] BYREF
  int v9; // [esp+8h] [ebp-18h]
  int v10; // [esp+Ch] [ebp-14h]
  unsigned int v11; // [esp+10h] [ebp-10h]

  v11 = __readgsdword(0x14u);
  v8[0] = a3;
  v8[1] = a4;
  v10 = a5;
  v5 = dlerror_run(a1, edi0, (void (__cdecl *)(int))dlopen_doit, (int)v8);
  v6 = 0;
  if ( !v5 )
  {
    _libc_register_dl_open_hook(a1, edi0, v9);
    _libc_register_dlfcn_hook(a1, edi0, v9);
    return v9;
  }
  return v6;
}

//----- (08099DC0) --------------------------------------------------------
int __cdecl dlclose_doit(int a1)
{
  return dl_close(a1);
}

//----- (08099DD0) --------------------------------------------------------
int __usercall _dlclose@<eax>(int a1@<ebp>, int *a2@<edi>, int a3)
{
  return -(dlerror_run(a1, a2, (void (__cdecl *)(int))dlclose_doit, a3) != 0);
}

//----- (08099E00) --------------------------------------------------------
int (*__cdecl dlsym_doit(int a1))(void)
{
  int (*result)(void); // eax

  result = dl_sym(*(_DWORD *)a1, *(unsigned __int8 **)(a1 + 4), *(_DWORD *)(a1 + 8));
  *(_DWORD *)(a1 + 12) = result;
  return result;
}

//----- (08099E30) --------------------------------------------------------
__int64 __usercall _dlsym@<edx:eax>(int a1@<ebp>, int *a2@<edi>, int a3, int a4, int a5)
{
  int v5; // esi
  __int64 result; // rax
  int v7[4]; // [esp+0h] [ebp-20h] BYREF
  unsigned int v8; // [esp+10h] [ebp-10h]

  v8 = __readgsdword(0x14u);
  v7[2] = a5;
  v7[0] = a3;
  v7[1] = a4;
  v5 = 0;
  if ( !dlerror_run(a1, a2, (void (__cdecl *)(int))dlsym_doit, (int)v7) )
    v5 = v7[3];
  HIDWORD(result) = __readgsdword(0x14u) ^ v8;
  LODWORD(result) = v5;
  return result;
}

//----- (08099EE0) --------------------------------------------------------
int (*__cdecl dlvsym_doit(int a1))(void)
{
  int (*result)(void); // eax

  result = dl_vsym(*(_DWORD *)a1, *(unsigned __int8 **)(a1 + 4), *(unsigned __int8 **)(a1 + 8), *(_DWORD *)(a1 + 12));
  *(_DWORD *)(a1 + 16) = result;
  return result;
}

//----- (08099F20) --------------------------------------------------------
__int64 __usercall _dlvsym@<edx:eax>(int a1@<ebp>, int *a2@<edi>, int a3, int a4, int a5, int a6)
{
  int v6; // esi
  __int64 result; // rax
  int v8[5]; // [esp+0h] [ebp-24h] BYREF
  unsigned int v9; // [esp+14h] [ebp-10h]

  v9 = __readgsdword(0x14u);
  v8[0] = a3;
  v8[1] = a4;
  v8[3] = a6;
  v8[2] = a5;
  v6 = 0;
  if ( !dlerror_run(a1, a2, (void (__cdecl *)(int))dlvsym_doit, (int)v8) )
    v6 = v8[4];
  HIDWORD(result) = __readgsdword(0x14u) ^ v9;
  LODWORD(result) = v6;
  return result;
}

//----- (08099FE0) --------------------------------------------------------
unsigned int __cdecl setitimer(int a1, struct itimerval *a2, struct itimerval *a3)
{
  unsigned int result; // eax

  result = sys_setitimer(a1, a2, a3);
  if ( result >= 0xFFFFF001 )
    return _syscall_error(result);
  return result;
}

//----- (0809A010) --------------------------------------------------------
int __usercall dl_build_local_scope@<eax>(_DWORD *a1@<eax>, int a2@<edx>)
{
  int v2; // edx
  _DWORD *v4; // esi
  int result; // eax
  int *v6; // ebx
  int v7; // edx

  *a1 = a2;
  *(_BYTE *)(a2 + 408) = *(_BYTE *)(a2 + 408) & 0x9F | 0x20;
  v2 = *(_DWORD *)(a2 + 500);
  if ( !v2 )
    return 1;
  v4 = a1 + 1;
  result = 1;
  v6 = (int *)(v2 + 4);
  v7 = *(_DWORD *)(v2 + 4);
  if ( v7 )
  {
    do
    {
      if ( (*(_BYTE *)(v7 + 408) & 0x60) == 0 )
        v4 += dl_build_local_scope(v4, v7);
      v7 = *++v6;
    }
    while ( *v6 );
    return v4 - a1;
  }
  return result;
}

//----- (0809A080) --------------------------------------------------------
unsigned __int8 *__usercall openaux@<eax>(unsigned int *edi0@<edi>, int a2)
{
  char v2; // al
  unsigned __int8 *result; // eax

  v2 = 1;
  if ( (*(_BYTE *)(*(_DWORD *)a2 + 408) & 3) != 0 )
    v2 = *(_BYTE *)(*(_DWORD *)a2 + 408) & 3;
  result = dl_map_object(
             edi0,
             *(_DWORD *)a2,
             *(char **)(a2 + 16),
             v2,
             *(_DWORD *)(a2 + 4),
             *(_DWORD *)(a2 + 8),
             *(_DWORD *)(*(_DWORD *)a2 + 24));
  *(_DWORD *)(a2 + 20) = result;
  return result;
}

//----- (0809A0C0) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
struct timespec *__usercall dl_map_object_deps@<eax>(int a1@<ebx>, int a2@<ebp>, int a3@<edi>, int a4@<esi>)
{
  int *v4; // eax
  int v5; // ecx
  char (****v6)[1671]; // edi
  __int16 v7; // cx
  int v8; // ecx
  char v9; // bl
  char v10; // dl
  _BYTE *v11; // ebx
  int *v12; // ecx
  int *v13; // eax
  int *v14; // esi
  int v15; // ebx
  int v16; // edi
  int v17; // esi
  int *v18; // eax
  int *v19; // edi
  _BYTE *v20; // eax
  struct timespec *tv_sec; // eax
  struct timespec *v22; // edi
  int v23; // eax
  int *v24; // edi
  int v25; // eax
  unsigned int *v26; // esi
  int v27; // ebx
  const struct timespec *v28; // edx
  unsigned int *v29; // eax
  unsigned int v30; // eax
  char *v31; // edx
  int v32; // eax
  void *v33; // esp
  char *v34; // eax
  int v35; // eax
  int v36; // eax
  char v37; // cl
  int v38; // ebx
  unsigned int *v39; // ebx
  int v40; // esi
  const struct timespec *v41; // ecx
  unsigned int *origin; // eax
  unsigned int v43; // eax
  char *v44; // edx
  int v45; // eax
  char *v46; // eax
  unsigned int v47; // eax
  int v48; // ebx
  const struct timespec *v49; // edx
  int *v50; // ecx
  unsigned int v51; // esi
  int v52; // eax
  int v53; // eax
  int v54; // ecx
  int *v55; // edx
  int *v56; // ebx
  int v57; // ecx
  const struct timespec *v58; // esi
  unsigned int v59; // edi
  int *v60; // eax
  unsigned int v61; // ebx
  const struct timespec *v62; // edx
  char *v63; // ebx
  char *v64; // eax
  const struct timespec *v65; // ecx
  int *v66; // ecx
  unsigned int v67; // eax
  int v68; // edx
  int *v69; // ebx
  int v70; // ecx
  int v71; // esi
  int v72; // eax
  struct timespec *result; // eax
  unsigned int v74; // eax
  int v75; // esi
  int *v76; // ecx
  int v77; // eax
  int v78; // esi
  int v79; // ecx
  int v80; // edx
  int v81; // edx
  int v82; // ecx
  void *v83; // esp
  int *v84; // edx
  _BYTE *v85; // edi
  int v86; // esi
  int v87; // eax
  unsigned int v88; // eax
  int v89; // edx
  int *v90; // ebx
  int *v91; // eax
  int *v92; // ebx
  int *v93; // eax
  const struct timespec *v94; // ecx
  int v95; // edx
  __time_t *i; // ecx
  __time_t v97; // edx
  int v98; // esi
  signed int v99; // esi
  struct timespec *v100; // edx
  bool v101; // zf
  __time_t v102; // edx
  void *v103; // esp
  char (*v104)[1671]; // eax
  _TBYTE *v105; // edi
  char *v106; // eax
  char *v107; // eax
  __time_t v108; // [esp-100Eh] [ebp-64F0h] BYREF
  int v109; // [esp-100Ah] [ebp-64ECh]
  __time_t v110; // [esp-1006h] [ebp-64E8h]
  unsigned int *v111; // [esp+6h] [ebp-54DCh]
  char v113[4088]; // [esp+12h] [ebp-54D0h] BYREF
  int v114; // [esp+100Ah] [ebp-44D8h]
  int v115; // [esp+100Eh] [ebp-44D4h]
  _DWORD v116[1032]; // [esp+1012h] [ebp-44D0h] BYREF
  char v117[4080]; // [esp+2032h] [ebp-34B0h] BYREF
  int v118; // [esp+302Ah] [ebp-24B8h]
  int v119; // [esp+302Eh] [ebp-24B4h]
  _DWORD v120[3]; // [esp+3032h] [ebp-24B0h] BYREF
  int v121; // [esp+303Eh] [ebp-24A4h] BYREF
  int v122; // [esp+304Ah] [ebp-2498h] BYREF
  char (***v123)[1671]; // [esp+4032h] [ebp-14B0h] BYREF
  _BYTE *v124; // [esp+4036h] [ebp-14ACh]
  unsigned int v125; // [esp+403Ah] [ebp-14A8h]
  unsigned int v126; // [esp+403Eh] [ebp-14A4h]
  _DWORD *v127; // [esp+4042h] [ebp-14A0h]
  struct timespec *v128; // [esp+4046h] [ebp-149Ch]
  struct timespec *v129; // [esp+404Ah] [ebp-1498h]
  int v130; // [esp+404Eh] [ebp-1494h]
  const struct timespec *v131; // [esp+4052h] [ebp-1490h]
  unsigned int v132; // [esp+4056h] [ebp-148Ch]
  struct timespec *v133; // [esp+405Ah] [ebp-1488h]
  struct timespec *v134; // [esp+405Eh] [ebp-1484h]
  const struct timespec *v135; // [esp+4062h] [ebp-1480h]
  int v136; // [esp+4066h] [ebp-147Ch]
  int *v137; // [esp+406Ah] [ebp-1478h]
  int *v138; // [esp+406Eh] [ebp-1474h]
  int v139; // [esp+4072h] [ebp-1470h]
  struct timespec *v140; // [esp+4076h] [ebp-146Ch]
  _BYTE *tv_nsec; // [esp+407Ah] [ebp-1468h]
  _TBYTE *v142; // [esp+407Eh] [ebp-1464h]
  int v143; // [esp+408Eh] [ebp-1454h] BYREF
  int v144; // [esp+4092h] [ebp-1450h]
  _DWORD v145[4]; // [esp+409Ah] [ebp-1448h] BYREF
  char *v146; // [esp+40AAh] [ebp-1438h]
  int v147; // [esp+40AEh] [ebp-1434h]
  int v148[4]; // [esp+40B2h] [ebp-1430h] BYREF
  _DWORD v149[262]; // [esp+40C2h] [ebp-1420h] BYREF
  _DWORD v150[3]; // [esp+44DAh] [ebp-1008h] BYREF
  _DWORD v151[2]; // [esp+44E6h] [ebp-FFCh] BYREF
  int v152; // [esp+44EEh] [ebp-FF4h]
  const struct timespec *v153; // [esp+44F2h] [ebp-FF0h]
  int v154; // [esp+44F6h] [ebp-FECh]

  v150[1] = v150[2];
  v150[0] = a2;
  v149[261] = a3;
  v149[260] = a4;
  v149[259] = a1;
  v149[258] = v151;
  v142 = &GLOBAL_OFFSET_TABLE_;
  tv_nsec = (_BYTE *)v152;
  v136 = v151[0];
  v4 = (int *)v151[1];
  v131 = v153;
  v130 = v154;
  v5 = 12 * v152 + 51;
  v6 = (char (****)[1671])((char *)&v123 - (v5 & 0xFFFFF000));
  v7 = v5 & 0xFFF0;
  if ( &v123 != v6 )
  {
    while ( v120 != v6 )
      ;
  }
  v8 = v7 & 0xFFF;
  if ( v8 )
  {
    v83 = alloca(v8);
    *(_DWORD *)((char *)&v120[-1] + v8) = *(_DWORD *)((char *)&v120[-1] + v8);
  }
  v9 = *(_BYTE *)(v136 + 408);
  v120[1] = v136;
  v120[0] = 0;
  v140 = (struct timespec *)v120;
  v120[2] = &v121;
  LOBYTE(v139) = v9;
  v10 = v9 & 0x9F;
  v11 = tv_nsec;
  *(_BYTE *)(v136 + 408) = v10 | 0x20;
  if ( v11 )
  {
    v12 = v4;
    v13 = &v122;
    v14 = &v12[(_DWORD)v11];
    do
    {
      v15 = *v12;
      *(v13 - 3) = 0;
      ++v12;
      *(v13 - 1) = (int)v13;
      v13 += 3;
      *(v13 - 5) = v15;
      *(_BYTE *)(v15 + 408) = *(_BYTE *)(v15 + 408) & 0x9F | 0x20;
    }
    while ( v14 != v12 );
    v132 = (unsigned int)(tv_nsec + 1);
    v134 = (struct timespec *)((char *)v140 + 12 * (_DWORD)(tv_nsec + 1) - 12);
    tv_nsec = (_BYTE *)v140->tv_nsec;
  }
  else
  {
    v132 = 1;
    tv_nsec = (_BYTE *)v136;
    v134 = v140;
  }
  v148[1] = 1024;
  v134[1].tv_sec = 0;
  v127 = v149;
  v148[0] = (int)v149;
  v126 = -32;
  v125 = __readgsdword(0xFFFFFFE0);
  __writegsdword(0xFFFFFFE0, 0);
  v128 = (struct timespec *)v120;
  v133 = v140;
  v124 = dl_debug_mask;
  while ( 1 )
  {
    v133->tv_sec = 1;
    v137 = *(int **)&tv_nsec[(_DWORD)(&dword_80CE160 - 33765376)];
    if ( v137 )
    {
      v137 = 0;
    }
    else if ( !*(_DWORD *)&tv_nsec[(_DWORD)(&off_80CE1F4 - 33765376)] && (_BYTE *)v136 != tv_nsec )
    {
      v74 = *(unsigned __int16 *)&tv_nsec[(_DWORD)(&word_80CE15E - 67530752)];
      if ( (_WORD)v74 )
      {
        if ( !(unsigned __int8)_libc_scratch_buffer_set_array_size(v148, v74, 4) )
        {
          v107 = &aCannotAllocate_4[(_DWORD)v142 - 135061504];
          goto LABEL_193;
        }
        v137 = (int *)v148[0];
      }
    }
    if ( !*((_DWORD *)tv_nsec + 9) && !*(_DWORD *)&tv_nsec[(_DWORD)(&off_80CE0F4 - 33765376)] )
    {
      v139 = 0;
      if ( !*(_DWORD *)&tv_nsec[(_DWORD)(&dword_80CE0EC - 33765376)] )
        goto LABEL_15;
    }
    v23 = *((_DWORD *)tv_nsec + 13);
    v145[0] = tv_nsec;
    v24 = (int *)*((_DWORD *)tv_nsec + 2);
    v138 = *(int **)(v23 + 4);
    v145[3] = v138;
    v145[1] = v131;
    v145[2] = v130;
    v25 = *v24;
    if ( *v24 )
      break;
    v139 = 0;
LABEL_15:
    if ( v137 )
    {
      v16 = v139;
      v137[v139] = 0;
      v17 = 4 * v16;
      v18 = malloc((const struct timespec *)(8 * v16 + 12));
      v19 = v18;
      if ( !v18 )
      {
        if ( (_DWORD *)v148[0] != v127 )
          free((int)v150, 0, v148[0]);
        v107 = &aCannotAllocate_3[(_DWORD)v142 - 135061504];
LABEL_193:
        dl_signal_error(12, *(unsigned int **)(v136 + 4), 0, (unsigned int *)v107);
      }
      v140 = (struct timespec *)(v17 + 4);
      *v18 = (int)tv_nsec;
      memcpy((_BYTE *)v18 + 4, v137, v17 + 4);
      memcpy(&v19[v17 / 4u + 2], v19, (unsigned int)v140);
      v20 = tv_nsec;
      tv_nsec[(_DWORD)(&byte_80CE19A - 135061504)] |= 1u;
      *(_DWORD *)&v20[(_DWORD)(&off_80CE1F4 - 33765376)] = v19;
    }
    tv_sec = v133;
    if ( !v133->tv_sec )
      goto LABEL_19;
    do
    {
      tv_sec = (struct timespec *)tv_sec[1].tv_sec;
      if ( !tv_sec )
      {
        v134 = 0;
        v22 = v128;
        goto LABEL_73;
      }
    }
    while ( tv_sec->tv_sec );
    v133 = tv_sec;
LABEL_19:
    tv_nsec = (_BYTE *)v133->tv_nsec;
  }
  v139 = 0;
  v129 = v133;
  v123 = &dl_argv;
  while ( v25 != 1 )
  {
    if ( (v25 & 0xFFFFFFFD) != 2147483645 )
      goto LABEL_44;
    v39 = (unsigned int *)((char *)v138 + v24[1]);
    v40 = dl_dst_count(v39);
    if ( !v40 )
      goto LABEL_121;
    if ( _libc_enable_secure )
    {
      v106 = &aDstNotAllowedI[(_DWORD)v142 - 135061504];
      goto LABEL_188;
    }
    v140 = (struct timespec *)strlen(v39);
    v41 = v140;
    origin = *(unsigned int **)&tv_nsec[(_DWORD)(&dword_80CE1AC - 33765376)];
    if ( origin )
    {
      if ( origin == (unsigned int *)-1 )
        goto LABEL_139;
    }
    else
    {
      if ( **((_BYTE **)tv_nsec + 1) )
      {
        v105 = v142;
        v115 = (int)v142 - 82896;
        v114 = 288;
LABEL_183:
        _assert_fail((int)v105 - 110624, (int)v105 - 83351, v114, v115);
      }
      v135 = v140;
      origin = (unsigned int *)dl_get_origin();
      *((_DWORD *)tv_nsec + 107) = origin;
      v41 = v135;
      if ( (unsigned int)origin - 1 > 0xFFFFFFFD )
      {
LABEL_139:
        v43 = 0;
        goto LABEL_52;
      }
    }
    v135 = v41;
    v43 = strlen(origin);
    v41 = v135;
LABEL_52:
    if ( dl_platformlen >= v43 )
      v43 = dl_platformlen;
    if ( v43 > 4 )
    {
      v40 *= v43 - 4;
      v41 = (struct timespec *)((char *)v140 + v40);
    }
    v44 = (char *)v116 - (((unsigned int)&v41[3].tv_sec + 3) & 0xFFFFF000);
    if ( v116 != (_DWORD *)v44 )
    {
      while ( v113 != v44 )
        ;
    }
    v45 = ((_WORD)v41 + 27) & 0xFF0;
    if ( (((_WORD)v41 + 27) & 0xFF0) != 0 )
    {
      v103 = alloca(v45);
      *(_DWORD *)&v113[v45 - 4] = *(_DWORD *)&v113[v45 - 4];
    }
    v46 = dl_dst_substitute((int)tv_nsec, (unsigned __int8 *)v39, v113);
    if ( *v46 )
    {
      v39 = (unsigned int *)v46;
LABEL_121:
      v146 = (char *)v39;
      if ( (*v124 & 1) != 0 )
      {
        v104 = (char (*)[1671])*((_DWORD *)tv_nsec + 1);
        if ( !*(_BYTE *)v104 )
        {
          v40 = (int)v142;
          v104 = **v123;
          if ( !v104 )
            v104 = (char (*)[1671])((char *)v142 - 111925);
        }
        dl_debug_printf(&aLoadAuxiliaryO[(_DWORD)v142 - 135061504], v39, v104);
      }
      v35 = dl_catch_exception(
              (int)v150,
              (int)v24,
              v40,
              &v143,
              (void (__cdecl *)(int))((char *)v142 + (_DWORD)openaux - 135061504),
              (int)v145);
      if ( v144 )
      {
        if ( *v24 != 2147483645 )
          goto LABEL_71;
        dl_exception_free((int)v150, v24, &v143);
        goto LABEL_44;
      }
      v75 = (int)v129;
      v76 = v137;
      v108 = v129->tv_sec;
      v109 = v129->tv_nsec;
      v110 = v129[1].tv_sec;
      v77 = v147;
      v129->tv_sec = 0;
      *(_DWORD *)(v75 + 4) = v77;
      if ( v76 )
      {
        v78 = v139;
        v76[v139] = v77;
        v77 = v147;
        v139 = v78 + 1;
      }
      if ( (byte_80CE198[v77 - 135061504] & 0x60) != 0 )
      {
        for ( i = &v108; ; i = (__time_t *)i[2] )
        {
          v97 = i[2];
          if ( !v97 )
          {
            v98 = (int)v129;
            v129->tv_sec = v108;
            *(_DWORD *)(v98 + 4) = v109;
            *(_DWORD *)(v98 + 8) = v110;
            goto LABEL_44;
          }
          if ( v77 == *(_DWORD *)(v97 + 4) )
            break;
        }
        v129[1].tv_sec = (__time_t)&v108;
        v99 = (signed int)v134;
        v100 = (struct timespec *)i[2];
        v101 = v100 == v134;
        v102 = v100[1].tv_sec;
        if ( v101 )
          v99 = (signed int)i;
        i[2] = v102;
        v79 = *(_DWORD *)(v77 + 16);
        v134 = (struct timespec *)v99;
        v80 = *(_DWORD *)(v77 + 12);
        if ( v79 )
        {
LABEL_127:
          *(_DWORD *)(v79 + 12) = v80;
          v80 = *(_DWORD *)(v77 + 12);
        }
      }
      else
      {
        v79 = *(_DWORD *)(v77 + 16);
        ++v132;
        v129[1].tv_sec = (__time_t)&v108;
        byte_80CE198[v77 - 135061504] = byte_80CE198[v77 - 135061504] & 0x9F | 0x20;
        v80 = *(_DWORD *)(v77 + 12);
        if ( v79 )
          goto LABEL_127;
      }
      if ( v80 )
        *(_DWORD *)(v80 + 16) = v79;
      v81 = v109;
      *(_DWORD *)(v77 + 16) = *(_DWORD *)(v109 + 16);
      *(_DWORD *)(v81 + 16) = v77;
      v82 = *(_DWORD *)(v77 + 16);
      if ( v82 )
        *(_DWORD *)(v82 + 12) = v77;
      *(_DWORD *)(v77 + 12) = v81;
      if ( v134 == v129 )
      {
        v129 = (struct timespec *)&v108;
        v134 = (struct timespec *)&v108;
      }
      else
      {
        v129 = (struct timespec *)&v108;
      }
      goto LABEL_44;
    }
    if ( *v24 == 2147483645 )
    {
      v106 = &aEmptyDynamicSt[(_DWORD)v142 - 135061504];
LABEL_188:
      dl_signal_error(0, v39, 0, (unsigned int *)v106);
    }
    if ( (dl_debug_mask[0] & 1) != 0 )
    {
      v111 = v39;
LABEL_70:
      dl_debug_printf(&aCannotLoadAuxi[(_DWORD)v142 - 135061504], v111);
    }
LABEL_44:
    v24 += 2;
    v25 = *v24;
    if ( !*v24 )
      goto LABEL_15;
  }
  v26 = (unsigned int *)((char *)v138 + v24[1]);
  v27 = dl_dst_count(v26);
  if ( v27 )
  {
    if ( _libc_enable_secure )
      dl_signal_error(0, v26, 0, (unsigned int *)&aDstNotAllowedI[(_DWORD)v142 - 135061504]);
    v28 = (const struct timespec *)strlen(v26);
    v140 = (struct timespec *)v28;
    v29 = *(unsigned int **)&tv_nsec[(_DWORD)(&dword_80CE1AC - 33765376)];
    if ( v29 )
    {
      if ( v29 != (unsigned int *)-1 )
        goto LABEL_29;
LABEL_67:
      v30 = 0;
    }
    else
    {
      if ( **((_BYTE **)tv_nsec + 1) )
      {
        v105 = v142;
        v119 = (int)v142 - 82896;
        v118 = 244;
        goto LABEL_183;
      }
      v135 = v28;
      v29 = (unsigned int *)dl_get_origin();
      v28 = v135;
      *((_DWORD *)tv_nsec + 107) = v29;
      if ( (unsigned int)v29 - 1 > 0xFFFFFFFD )
        goto LABEL_67;
LABEL_29:
      v135 = v28;
      v30 = strlen(v29);
      v28 = v135;
    }
    if ( dl_platformlen >= v30 )
      v30 = dl_platformlen;
    if ( v30 > 4 )
      v140 = (struct timespec *)((char *)v28 + v27 * (v30 - 4));
    v31 = (char *)v120 - (((unsigned int)&v140[3].tv_sec + 3) & 0xFFFFF000);
    if ( v120 != (_DWORD *)v31 )
    {
      while ( v117 != v31 )
        ;
    }
    v32 = ((_WORD)v140 + 27) & 0xFF0;
    if ( (((_WORD)v140 + 27) & 0xFF0) != 0 )
    {
      v33 = alloca(v32);
      *(_DWORD *)((char *)&v116[1031] + v32) = *(_DWORD *)((char *)&v116[1031] + v32);
    }
    v34 = dl_dst_substitute((int)tv_nsec, (unsigned __int8 *)v26, v117);
    if ( !*v34 )
    {
      if ( (dl_debug_mask[0] & 1) == 0 )
        goto LABEL_44;
      v116[1029] = v26;
      goto LABEL_70;
    }
  }
  else
  {
    v34 = (char *)v26;
  }
  v146 = v34;
  v35 = dl_catch_exception(
          (int)v150,
          (int)v24,
          (int)v26,
          &v143,
          (void (__cdecl *)(int))((char *)v142 + (_DWORD)openaux - 135061504),
          (int)v145);
  if ( !v144 )
  {
    v36 = v147;
    if ( (byte_80CE198[v147 - 135061504] & 0x60) == 0 )
    {
      ++v132;
      v116[1] = v147;
      v116[0] = 0;
      v116[2] = 0;
      v134[1].tv_sec = (__time_t)v116;
      v37 = byte_80CE198[v36 - 135061504];
      v134 = (struct timespec *)v116;
      byte_80CE198[v36 - 135061504] = v37 & 0x9F | 0x20;
    }
    if ( v137 )
    {
      v38 = v139;
      v137[v139] = v36;
      v139 = v38 + 1;
    }
    goto LABEL_44;
  }
LABEL_71:
  v134 = (struct timespec *)v35;
  v22 = v128;
  if ( !v35 )
    v134 = (struct timespec *)-1;
LABEL_73:
  if ( (_DWORD *)v148[0] != v127 )
    free((int)v150, &v22->tv_sec, v148[0]);
  if ( !__readgsdword(v126) && v125 )
    __writegsdword(v126, v125);
  v133 = *(struct timespec **)(v136 + 500);
  if ( v133 )
  {
    LOBYTE(tv_nsec) = *(_BYTE *)(v136 + 408);
    if ( ((unsigned __int8)tv_nsec & 3) == 2 )
    {
      if ( *(_DWORD *)(v136 + 352) )
        _assert_fail((int)v142 - 83052, (int)v142 - 83351, 472, (int)v142 - 82896);
    }
    else
    {
      v133 = 0;
    }
  }
  v138 = malloc((const struct timespec *)(8 * v132 + 4));
  if ( !v138 )
  {
LABEL_192:
    v107 = &aCannotAllocate_2[(_DWORD)v142 - 135061504];
    goto LABEL_193;
  }
  v47 = v132;
  v48 = v136;
  v49 = v131;
  v50 = &v138[v132 + 1];
  v51 = 0;
  v137 = v50;
  *(_DWORD *)(v136 + 352) = v50;
  *(_DWORD *)(v48 + 356) = v47;
  do
  {
    v52 = v22->tv_nsec;
    if ( v49 && (byte_80CE199[v52 - 135061504] & 2) != 0 )
    {
      --*(_DWORD *)(v136 + 356);
    }
    else
    {
      v50[v51] = v52;
      v52 = v22->tv_nsec;
      ++v51;
    }
    byte_80CE198[v52 - 135061504] &= 0x9Fu;
    v22 = (struct timespec *)v22[1].tv_sec;
  }
  while ( v22 );
  if ( (dl_debug_mask[1] & 8) != 0 && dl_ns == (void *)v136 && v51 )
  {
    v135 = 0;
    v84 = v137;
    v85 = 0;
    tv_nsec = (_BYTE *)v51;
    do
    {
      v86 = v84[(_DWORD)v85];
      if ( v136 != v86 )
      {
        v87 = *(_DWORD *)(v86 + 468);
        if ( !v87 || !*(_DWORD *)(v87 + 4) )
        {
          if ( *(_DWORD *)(v86 + 244) || *(_DWORD *)(v86 + 236) )
            dl_signal_error(
              22,
              *(unsigned int **)(v86 + 4),
              0,
              (unsigned int *)&aFiltersNotSupp[(_DWORD)v142 - 135061504]);
          v88 = dl_build_local_scope(v138, v84[(_DWORD)v85]);
          v89 = v88;
          if ( v88 > (unsigned int)tv_nsec )
            _assert_fail((int)v142 - 83341, (int)v142 - 83351, 528, (int)v142 - 82896);
          if ( v88 )
          {
            v90 = v138;
            byte_80CE198[*v138 - 135061504] &= 0x9Fu;
            v91 = v90 + 1;
            v92 = &v90[v89];
            while ( v92 != v91 )
            {
              *(_BYTE *)(*v91 + 408) &= 0x9Fu;
              if ( *(_DWORD *)(*v91 + 96) )
                *(_BYTE *)(v86 + 409) |= 0x80u;
              ++v91;
            }
          }
          v139 = v89;
          v140 = (struct timespec *)(4 * v89 + 8);
          v93 = malloc(v140);
          v94 = v140;
          v95 = v139;
          *(_DWORD *)(v86 + 468) = v93;
          if ( !v93 )
            goto LABEL_192;
          v93[1] = v95;
          *v93 = (int)(v93 + 2);
          memcpy((_BYTE *)v93 + 8, v138, (unsigned int)&v94[-1]);
          v84 = *(int **)((char *)&dword_80CE160 + v136 - 135061504);
        }
      }
      ++v85;
    }
    while ( v85 != tv_nsec );
    v137 = v84;
    v22 = (struct timespec *)v135;
    v51 = (unsigned int)tv_nsec;
  }
  if ( *v137 != v136 )
    _assert_fail((int)v142 - 82932, (int)v142 - 83351, 553, (int)v142 - 82896);
  v53 = *(int *)((char *)&dword_80CE1F8 + v136 - 135061504);
  v140 = (struct timespec *)v53;
  if ( v53 )
  {
    v54 = *(_DWORD *)v53;
    tv_nsec = (_BYTE *)(v53 + 4);
    v139 = v54;
    if ( v51 <= 1 )
    {
      if ( v139 )
      {
LABEL_93:
        v132 = v51;
        v139 = (int)v22;
        v58 = 0;
        do
        {
          while ( 1 )
          {
            v59 = (unsigned int)&v58->tv_sec + 1;
            if ( (byte_80CE198[*(_DWORD *)&tv_nsec[4 * (_DWORD)v58] - 135061504] & 0x60) != 0 )
            {
              v135 = (const struct timespec *)(4 * (_DWORD)v58);
              v60 = malloc((const struct timespec *)(4 * *(int *)((char *)&dword_80CE1FC + v136 - 135061504) + 4));
              v139 = (int)v60;
              if ( v60 )
                break;
            }
            v58 = (const struct timespec *)((char *)v58 + 1);
            if ( v140->tv_sec <= v59 )
              goto LABEL_104;
          }
          v131 = v135;
          memcpy((_BYTE *)v60 + 4, tv_nsec, (unsigned int)v135);
          v61 = v140->tv_sec;
          v135 = (const struct timespec *)v61;
          if ( v61 <= v59 )
          {
            v65 = v58;
          }
          else
          {
            v62 = v131;
            v131 = v58;
            v63 = &tv_nsec[4 * v61];
            v64 = (char *)&v62[1] + (_DWORD)v140;
            v65 = v58;
            do
            {
              if ( (*(_BYTE *)(*(_DWORD *)v64 + 408) & 0x60) == 0 )
              {
                *(_DWORD *)(v139 + 4 * (_DWORD)v65 + 4) = *(_DWORD *)v64;
                v65 = (const struct timespec *)((char *)v65 + 1);
              }
              v64 += 4;
            }
            while ( v64 != v63 );
            v59 = (char *)v58 + (_DWORD)v135 - (char *)v131;
          }
          v58 = (const struct timespec *)(v59 + 1);
          *(_DWORD *)v139 = v65;
        }
        while ( v140->tv_sec > v59 + 1 );
LABEL_104:
        v51 = v132;
        v22 = (struct timespec *)v139;
        if ( v132 > 1 )
          goto LABEL_105;
      }
    }
    else
    {
      v55 = v137 + 1;
      v56 = &v137[v51];
      do
      {
        v57 = *v55++;
        *(_BYTE *)(v57 + 408) = *(_BYTE *)(v57 + 408) & 0x9F | 0x20;
      }
      while ( v56 != v55 );
      if ( v139 )
        goto LABEL_93;
LABEL_105:
      v66 = v137;
      v67 = 1;
      do
      {
        v68 = v66[v67++];
        *(_BYTE *)(v68 + 408) &= 0x9Fu;
      }
      while ( v67 < v51 );
    }
  }
  else
  {
    v22 = 0;
  }
  memcpy(v138, v137, 4 * v51);
  v69 = v138;
  dl_sort_maps((int)(v138 + 1), v51 - 1, 0, 0);
  v69[v51] = 0;
  v71 = v136;
  *(_DWORD *)(v136 + 500) = v69;
  *(_BYTE *)(v71 + 410) |= 1u;
  if ( v22 )
  {
    v72 = *(_DWORD *)(v71 + 504);
    *(_DWORD *)(v71 + 504) = v22;
    dl_scope_free((int)v150, &v22->tv_sec, v72);
  }
  result = v133;
  if ( v133 )
    result = (struct timespec *)dl_scope_free((int)v150, &v22->tv_sec, (int)v133);
  if ( v134 )
  {
    if ( v134 == (struct timespec *)-1 )
      v134 = 0;
    v119 = v70;
    dl_signal_exception((signed int)v134, (int)&v143, 0);
  }
  return result;
}
// 809AB6F: positive sp value 1000 has been found
// 809A0C0: could not find valid save-restore pair for ebx
// 809A0C0: could not find valid save-restore pair for ebp
// 809A0C0: could not find valid save-restore pair for edi
// 809A0C0: could not find valid save-restore pair for esi
// 809B0F2: variable 'v70' is possibly undefined
// 80CDDA4: using guessed type char (**dl_argv)[1671];
// 80CDDAC: using guessed type int _libc_enable_secure;
// 80CE000: using guessed type _TBYTE GLOBAL_OFFSET_TABLE_;
// 80CE0EC: using guessed type int dword_80CE0EC;
// 80CE0F4: using guessed type void *off_80CE0F4;
// 80CE15E: using guessed type __int16 word_80CE15E;
// 80CE160: using guessed type int dword_80CE160;
// 80CE19A: using guessed type char byte_80CE19A;
// 80CE1AC: using guessed type int dword_80CE1AC;
// 80CE1F4: using guessed type void *off_80CE1F4;
// 80CE1F8: using guessed type int dword_80CE1F8;
// 80CE1FC: using guessed type int dword_80CE1FC;
// 80CEA00: using guessed type void *dl_ns;
// 80CFF04: using guessed type _BYTE dl_debug_mask[4];

//----- (0809B200) --------------------------------------------------------
int __usercall call_init_part_0@<eax>(int result@<eax>, int a2@<edx>, int a3@<ecx>, int a4)
{
  char v6; // bp
  const char *v7; // edx
  _DWORD *v8; // ebp
  int v9; // eax
  int v10; // edi
  int v11; // edx
  int v12; // eax
  int (__cdecl **v13)(int, _DWORD, int); // ebp
  int v14; // esi
  int (__cdecl **v15)(int, _DWORD, int); // ebx
  int v16; // edi

  v6 = *(_BYTE *)(result + 408) | 8;
  *(_BYTE *)(result + 408) = v6;
  v7 = *(const char **)(result + 4);
  if ( !*v7 && (v6 & 3) == 0 )
    return result;
  v8 = (_DWORD *)result;
  v9 = *(_DWORD *)(result + 80);
  if ( v9 )
  {
    if ( (dl_debug_mask[0] & 2) == 0 )
    {
LABEL_4:
      ((void (__cdecl *)(int, int, int))(*v8 + *(_DWORD *)(v9 + 4)))(a2, a3, a4);
      result = v8[33];
      goto LABEL_5;
    }
  }
  else
  {
    result = v8[33];
    if ( !result )
      return result;
    if ( (dl_debug_mask[0] & 2) == 0 )
      goto LABEL_6;
  }
  if ( !*v7 )
  {
    v7 = (const char *)program_invocation_short_name[0];
    if ( !program_invocation_short_name[0] )
      v7 = "<main program>";
  }
  dl_debug_printf("\ncalling init: %s\n\n", v7);
  v9 = v8[20];
  if ( v9 )
    goto LABEL_4;
  result = v8[33];
LABEL_5:
  if ( !result )
    return result;
LABEL_6:
  v10 = *v8 + *(_DWORD *)(result + 4);
  v11 = *(_DWORD *)(v8[35] + 4) >> 2;
  if ( v11 )
  {
    v12 = a3;
    v13 = (int (__cdecl **)(int, _DWORD, int))(v10 + 4 * v11);
    v14 = a2;
    v15 = (int (__cdecl **)(int, _DWORD, int))v10;
    v16 = v12;
    do
      result = (*v15++)(v14, v16, a4);
    while ( v13 != v15 );
  }
  return result;
}
// 80CDDA4: using guessed type char (**dl_argv)[1671];
// 80CE964: using guessed type char (*program_invocation_short_name[2])[1671];
// 80CFF04: using guessed type _BYTE dl_debug_mask[4];

//----- (0809B330) --------------------------------------------------------
_DWORD *__cdecl dl_init(_DWORD *a1, int a2, int a3, int a4)
{
  _DWORD *v4; // ebx
  int v5; // edi
  int v6; // eax
  _DWORD *result; // eax
  unsigned int v8; // ecx
  void (__cdecl **v9)(int, int, int); // ebx
  char (*v10)[1671]; // eax
  int v11; // [esp+4h] [ebp-24h]
  void (__cdecl **v12)(int, int, int); // [esp+4h] [ebp-24h]
  int v13; // [esp+8h] [ebp-20h]
  unsigned int v14; // [esp+8h] [ebp-20h]

  v4 = a1;
  v11 = a1[40];
  v13 = a1[41];
  if ( dl_initfirst )
  {
    if ( (byte_80CE198[dl_initfirst - 135061504] & 8) == 0 )
      call_init_part_0(dl_initfirst, a2, a3, a4);
    dl_initfirst = 0;
  }
  if ( v11 )
  {
    if ( v13 )
    {
      v8 = *(_DWORD *)(v13 + 4);
      if ( v8 > 3 )
      {
        if ( (dl_debug_mask[0] & 2) != 0 )
        {
          v10 = (char (*)[1671])a1[1];
          if ( !*(_BYTE *)v10 )
          {
            v10 = program_invocation_short_name[0];
            if ( !program_invocation_short_name[0] )
              v10 = (char (*)[1671])((char *)&GLOBAL_OFFSET_TABLE_ - 111925);
          }
          v14 = *(_DWORD *)(v13 + 4);
          dl_debug_printf("\ncalling preinit: %s\n\n", v10);
          v8 = v14;
        }
        v9 = (void (__cdecl **)(int, int, int))(*(_DWORD *)(v11 + 4) + *a1);
        v12 = (void (__cdecl **)(int, int, int))((char *)v9 + (v8 & 0xFFFFFFFC));
        do
          (*v9++)(a2, a3, a4);
        while ( v12 != v9 );
        v4 = a1;
      }
    }
  }
  v5 = v4[89];
  while ( --v5 != -1 )
  {
    while ( 1 )
    {
      v6 = *(_DWORD *)(v4[125] + 4 * v5);
      if ( (byte_80CE198[v6 - 135061504] & 8) != 0 )
        break;
      --v5;
      call_init_part_0(v6, a2, a3, a4);
      if ( v5 == -1 )
        goto LABEL_8;
    }
  }
LABEL_8:
  result = &dl_starting_up;
  dl_starting_up = 0;
  return result;
}
// 80CDDA4: using guessed type char (**dl_argv)[1671];
// 80CE000: using guessed type _TBYTE GLOBAL_OFFSET_TABLE_;
// 80CE964: using guessed type char (*program_invocation_short_name[2])[1671];
// 80CE9B4: using guessed type _DWORD dl_starting_up;
// 80CFF04: using guessed type _BYTE dl_debug_mask[4];
// 80CFF58: using guessed type int dl_initfirst;

//----- (0809B4B0) --------------------------------------------------------
int __cdecl dl_check_map_versions(_DWORD *a1, int a2, int a3)
{
  _DWORD *v3; // ebp
  int v4; // eax
  int v5; // eax
  char *v6; // esi
  int v7; // ebx
  char *i; // esi
  int v9; // edx
  _DWORD *v10; // ebp
  char (*v11)[1671]; // edi
  int v12; // ecx
  int v13; // eax
  int v14; // ebx
  unsigned __int16 *v15; // ebx
  int v16; // ebp
  int v17; // edi
  int v18; // eax
  _DWORD *v19; // edi
  unsigned __int16 *v20; // ecx
  char v21; // al
  unsigned int *v22; // edx
  unsigned int v23; // eax
  int v24; // eax
  int v26; // edi
  unsigned int *v27; // eax
  char (*v28)[1671]; // eax
  int *v29; // edi
  int v30; // edx
  unsigned int v31; // eax
  unsigned int v32; // ecx
  int v33; // eax
  unsigned int v34; // esi
  unsigned __int8 *v35; // eax
  int v36; // edx
  _DWORD *j; // edi
  char *k; // ebx
  unsigned int v39; // edx
  unsigned __int8 *v40; // edx
  int v41; // eax
  int v42; // ecx
  int v43; // edx
  int v44; // edx
  int v45; // eax
  unsigned int *v46; // eax
  int m; // edx
  int v48; // ebx
  unsigned __int8 *v49; // ecx
  int v50; // edi
  int v51; // ecx
  char v52; // al
  unsigned int *v53; // edx
  signed int v54; // eax
  unsigned int *v55; // eax
  unsigned int *v56; // eax
  unsigned __int8 *v57; // [esp+0h] [ebp-7Ch]
  int *v58; // [esp+4h] [ebp-78h]
  char *v59; // [esp+8h] [ebp-74h]
  int v60; // [esp+Ch] [ebp-70h]
  int v61; // [esp+14h] [ebp-68h]
  __int16 v62; // [esp+1Ah] [ebp-62h]
  unsigned __int16 *v63; // [esp+1Ch] [ebp-60h]
  _DWORD *v64; // [esp+20h] [ebp-5Ch]
  int v65; // [esp+24h] [ebp-58h]
  int v66; // [esp+2Ch] [ebp-50h]
  int v67; // [esp+34h] [ebp-48h]
  int v68; // [esp+3Ch] [ebp-40h]
  const char *v69[7]; // [esp+40h] [ebp-3Ch] BYREF
  char v70[29]; // [esp+5Fh] [ebp-1Dh] BYREF
  _DWORD *v71; // [esp+80h] [ebp+4h]

  v3 = a1;
  v4 = a1[13];
  if ( !v4 )
    return 0;
  v60 = *(_DWORD *)(v4 + 4);
  v5 = a1[44];
  v66 = a1[46];
  v67 = v5;
  if ( !v5 )
  {
    v58 = 0;
    if ( !v66 )
      return 0;
LABEL_48:
    v29 = v58;
    v30 = *v3 + *(_DWORD *)(v66 + 4);
    v31 = *(_WORD *)(v30 + 4) & 0x7FFF;
    if ( (unsigned int)v58 >= v31 )
      v31 = (unsigned int)v58;
    v32 = v31;
    v58 = (int *)v31;
    v33 = *(_DWORD *)(v30 + 16);
    if ( v33 )
    {
      do
      {
        v30 += v33;
        if ( v32 < (*(_WORD *)(v30 + 4) & 0x7FFFu) )
          v32 = *(_WORD *)(v30 + 4) & 0x7FFF;
        v33 = *(_DWORD *)(v30 + 16);
      }
      while ( v33 );
      v58 = (int *)v32;
    }
    goto LABEL_55;
  }
  v58 = 0;
  v63 = (unsigned __int16 *)(*a1 + *(_DWORD *)(v5 + 4));
  if ( *v63 != 1 )
  {
    v70[0] = 0;
    v52 = (unsigned __int8)itoa(*v63, v70, 0xAu, 0);
    v53 = (unsigned int *)a1[1];
    if ( !*(_BYTE *)v53 )
    {
      v53 = (unsigned int *)program_invocation_short_name[0];
      if ( !program_invocation_short_name[0] )
        v53 = (unsigned int *)"<main program>";
    }
    dl_exception_create_format(v69, v53, (_BYTE *)&GLOBAL_OFFSET_TABLE_ - 82768, v52);
    v54 = 0;
LABEL_90:
    dl_signal_exception(v54, (int)v69, 0);
  }
  while ( 1 )
  {
    v6 = (char *)(*((_DWORD *)v63 + 1) + v60);
    v7 = (int)*(&dl_ns + 19 * v3[6]);
    if ( v7 )
    {
      while ( !dl_name_match_p(v6, v7) )
      {
        v7 = *(_DWORD *)(v7 + 12);
        if ( !v7 )
          goto LABEL_34;
      }
    }
    else
    {
LABEL_34:
      if ( !v3[89] )
        goto LABEL_39;
      v26 = 0;
      while ( !dl_name_match_p(v6, *(_DWORD *)(v3[88] + 4 * v26)) )
      {
        if ( (unsigned int)++v26 >= v3[89] )
          goto LABEL_39;
      }
      v7 = *(_DWORD *)(v3[88] + 4 * v26);
      if ( !v7 )
LABEL_39:
        _assert_fail((int)"needed != NULL", (int)"dl-version.c", 205, (int)"_dl_check_map_versions");
    }
    if ( !a3 || (*(_BYTE *)(v7 + 409) & 2) == 0 )
    {
      v61 = v7;
      v71 = v3;
      for ( i = (char *)v63 + *((_DWORD *)v63 + 2); ; i += v24 )
      {
        v9 = *(_DWORD *)i;
        v62 = *((_WORD *)i + 2);
        v10 = *(_DWORD **)(v61 + 20);
        v59 = (char *)(*((_DWORD *)i + 2) + v60);
        v11 = (char (*)[1671])v71[1];
        if ( !*(_BYTE *)v11 )
        {
          v11 = program_invocation_short_name[0];
          if ( !program_invocation_short_name[0] )
            v11 = (char (*)[1671])((char *)&GLOBAL_OFFSET_TABLE_ - 111925);
        }
        v12 = *(_DWORD *)(v10[13] + 4);
        if ( (dl_debug_mask[0] & 0x10) != 0 )
        {
          v28 = (char (*)[1671])v10[1];
          if ( !*(_BYTE *)v28 )
          {
            v28 = program_invocation_short_name[0];
            if ( !program_invocation_short_name[0] )
              v28 = (char (*)[1671])((char *)&GLOBAL_OFFSET_TABLE_ - 111925);
          }
          v68 = *(_DWORD *)(v10[13] + 4);
          v65 = *(_DWORD *)i;
          dl_debug_printf((_BYTE *)&GLOBAL_OFFSET_TABLE_ - 82724, v59, v28, v10[6], v11, v71[6]);
          v12 = v68;
          v9 = v65;
        }
        v13 = v10[46];
        if ( v13 )
        {
          v14 = *(_DWORD *)(v13 + 4);
          if ( !v14 )
            _assert_fail((int)"def_offset != 0", (int)"dl-version.c", 88, (int)"match_symbol");
          v15 = (unsigned __int16 *)(*v10 + v14);
          if ( *v15 != 1 )
          {
            v20 = v15;
            v19 = v10;
LABEL_22:
            v70[0] = 0;
            v21 = (unsigned __int8)itoa(*v20, v70, 0xAu, 0);
            v22 = (unsigned int *)v19[1];
            if ( !*(_BYTE *)v22 )
            {
              v22 = (unsigned int *)program_invocation_short_name[0];
              if ( !program_invocation_short_name[0] )
                v22 = (unsigned int *)"<main program>";
            }
            dl_exception_create_format(v69, v22, (_BYTE *)&GLOBAL_OFFSET_TABLE_ - 82600, v21);
LABEL_26:
            dl_signal_exception(0, (int)v69, (const char *)&GLOBAL_OFFSET_TABLE_ - 82789);
          }
          v64 = v10;
          v16 = v12;
          v17 = v9;
          while ( 1 )
          {
            if ( v17 == *((_DWORD *)v15 + 2)
              && !strcmp(v59, (_BYTE *)(v16 + *(_DWORD *)((char *)v15 + *((_DWORD *)v15 + 3)))) )
            {
              goto LABEL_28;
            }
            v18 = *((_DWORD *)v15 + 4);
            if ( !v18 )
              break;
            v15 = (unsigned __int16 *)((char *)v15 + v18);
            if ( *v15 != 1 )
            {
              v19 = v64;
              v20 = v15;
              goto LABEL_22;
            }
          }
          if ( (v62 & 2) == 0 )
          {
            v55 = (unsigned int *)v64[1];
            if ( !*(_BYTE *)v55 )
            {
              v55 = (unsigned int *)program_invocation_short_name[0];
              if ( !program_invocation_short_name[0] )
                v55 = (unsigned int *)((char *)&GLOBAL_OFFSET_TABLE_ - 111925);
            }
            dl_exception_create_format(v69, v55, (_BYTE *)&GLOBAL_OFFSET_TABLE_ - 82512, (char)v59);
            goto LABEL_26;
          }
          if ( a2 )
          {
            v46 = (unsigned int *)v64[1];
            if ( !*(_BYTE *)v46 )
            {
              v46 = (unsigned int *)program_invocation_short_name[0];
              if ( !program_invocation_short_name[0] )
                v46 = (unsigned int *)((char *)&GLOBAL_OFFSET_TABLE_ - 111925);
            }
            dl_exception_create_format(v69, v46, (_BYTE *)&GLOBAL_OFFSET_TABLE_ - 82560, (char)v59);
            goto LABEL_26;
          }
        }
        else if ( a2 )
        {
          v27 = (unsigned int *)v10[1];
          if ( !*(_BYTE *)v27 )
          {
            v27 = (unsigned int *)program_invocation_short_name[0];
            if ( !program_invocation_short_name[0] )
              v27 = (unsigned int *)((char *)&GLOBAL_OFFSET_TABLE_ - 111925);
          }
          dl_exception_create_format(v69, v27, (_BYTE *)&GLOBAL_OFFSET_TABLE_ - 82652, (char)v11);
          goto LABEL_26;
        }
LABEL_28:
        v23 = *((_WORD *)i + 3) & 0x7FFF;
        if ( (unsigned int)v58 >= v23 )
          v23 = (unsigned int)v58;
        v58 = (int *)v23;
        v24 = *((_DWORD *)i + 3);
        if ( !v24 )
          break;
      }
      v3 = v71;
    }
    v29 = (int *)v63;
    v45 = *((_DWORD *)v63 + 3);
    if ( !v45 )
      break;
    v63 = (unsigned __int16 *)((char *)v63 + v45);
  }
  if ( v66 )
    goto LABEL_48;
LABEL_55:
  if ( !v58 )
    return 0;
  v34 = (unsigned int)v58 + 1;
  v35 = calloc(v29, (unsigned int)v58 + 1, 0x10u);
  v3[93] = v35;
  if ( !v35 )
  {
    v56 = (unsigned int *)v3[1];
    if ( !*(_BYTE *)v56 )
    {
      v56 = (unsigned int *)program_invocation_short_name[0];
      if ( !program_invocation_short_name[0] )
        v56 = (unsigned int *)"<main program>";
    }
    dl_exception_create(v69, v56, (unsigned int *)&GLOBAL_OFFSET_TABLE_ - 20618);
    v54 = 12;
    goto LABEL_90;
  }
  v36 = v3[58];
  v3[94] = v34;
  v3[106] = *(_DWORD *)(v36 + 4);
  if ( v67 )
  {
    for ( j = (_DWORD *)(*v3 + *(_DWORD *)(v67 + 4)); ; j = (_DWORD *)((char *)j + v44) )
    {
      v57 = v35;
      for ( k = (char *)j + j[2]; ; k += v43 )
      {
        v39 = *((_WORD *)k + 3) & 0x7FFF;
        if ( v34 > v39 )
        {
          v40 = &v57[16 * v39];
          v41 = *(_DWORD *)k;
          *((_DWORD *)v40 + 2) = *((_WORD *)k + 3) & 0x8000;
          v42 = *((_DWORD *)k + 2);
          *((_DWORD *)v40 + 1) = v41;
          *(_DWORD *)v40 = v60 + v42;
          *((_DWORD *)v40 + 3) = v60 + j[1];
        }
        v43 = *((_DWORD *)k + 3);
        if ( !v43 )
          break;
      }
      v44 = j[3];
      v35 = v57;
      if ( !v44 )
        break;
    }
  }
  if ( v66 )
  {
    for ( m = *v3 + *(_DWORD *)(v66 + 4); ; m += v51 )
    {
      if ( (*(_BYTE *)(m + 2) & 1) == 0 )
      {
        v48 = *(_DWORD *)(m + 12);
        v49 = &v35[16 * (*(_WORD *)(m + 4) & 0x7FFF)];
        *((_DWORD *)v49 + 1) = *(_DWORD *)(m + 8);
        v50 = *(_DWORD *)(m + v48);
        *((_DWORD *)v49 + 3) = 0;
        *(_DWORD *)v49 = v60 + v50;
      }
      v51 = *(_DWORD *)(m + 16);
      if ( !v51 )
        break;
    }
  }
  return 0;
}
// 80CDDA4: using guessed type char (**dl_argv)[1671];
// 80CE000: using guessed type _TBYTE GLOBAL_OFFSET_TABLE_;
// 80CE964: using guessed type char (*program_invocation_short_name[2])[1671];
// 80CEA00: using guessed type void *dl_ns;
// 80CFF04: using guessed type _BYTE dl_debug_mask[4];

//----- (0809BBA0) --------------------------------------------------------
int __cdecl dl_check_all_versions(int a1, int a2, int a3)
{
  int v3; // esi
  int i; // ebx
  int v5; // eax

  v3 = 0;
  for ( i = a1; i; v3 |= v5 != 0 )
  {
    while ( (*(_BYTE *)(i + 409) & 2) != 0 )
    {
      i = *(_DWORD *)(i + 12);
      if ( !i )
        return v3;
    }
    v5 = dl_check_map_versions((_DWORD *)i, a2, a3);
    i = *(_DWORD *)(i + 12);
  }
  return v3;
}

//----- (0809BC00) --------------------------------------------------------
_DWORD *__cdecl call_dl_lookup(int a1)
{
  _DWORD *result; // eax

  result = dl_lookup_symbol_x(
             *(unsigned __int8 **)(a1 + 4),
             *(_DWORD **)a1,
             *(int **)(a1 + 20),
             *(int ***)(*(_DWORD *)a1 + 464),
             *(_DWORD **)(a1 + 8),
             0,
             *(_DWORD *)(a1 + 12),
             0);
  *(_DWORD *)a1 = result;
  return result;
}

//----- (0809BC40) --------------------------------------------------------
int (*__usercall do_sym@<eax>(
        int a1@<eax>,
        unsigned __int8 *a2@<edx>,
        unsigned int a3@<ecx>,
        _DWORD *a4,
        int a5))(void)
{
  int **dso_for_object; // eax
  int *v8; // eax
  int (*v9)(void); // edx
  int v10; // edx
  int **v12; // edx
  int v13; // ebp
  int v15; // eax
  int v17; // [esp+8h] [ebp-48h] BYREF
  int v18[3]; // [esp+Ch] [ebp-44h] BYREF
  int v19[14]; // [esp+18h] [ebp-38h] BYREF

  v19[6] = __readgsdword(0x14u);
  v17 = 0;
  dso_for_object = (int **)dl_find_dso_for_object(a3);
  if ( !dso_for_object )
    dso_for_object = (int **)dl_ns;
  if ( a1 )
  {
    if ( a1 == -1 )
    {
      v12 = dso_for_object;
      if ( dl_ns == dso_for_object
        && (!dso_for_object || (unsigned int)dso_for_object[108] > a3 || (unsigned int)dso_for_object[109] <= a3) )
      {
        dl_signal_error(0, 0, 0, (unsigned int *)"RTLD_NEXT used in code not dynamically loaded");
      }
      while ( v12[92] )
        v12 = (int **)v12[92];
      v8 = dl_lookup_symbol_x(a2, dso_for_object, &v17, v12 + 117, a4, 0, 0, (int)dso_for_object);
    }
    else
    {
      v8 = dl_lookup_symbol_x(a2, (_DWORD *)a1, &v17, (int **)(a1 + 468), a4, 0, a5, 0);
    }
  }
  else if ( __readgsdword(0xCu) )
  {
    v19[0] = (int)dso_for_object;
    v19[1] = (int)a2;
    v19[2] = (int)a4;
    v19[3] = a5 | 5;
    v19[5] = (int)&v17;
    __writegsdword(0x1Cu, 1u);
    v13 = dl_catch_exception((int)a4, (int)v18, 0, v18, (void (__cdecl *)(int))call_dl_lookup, (int)v19);
    if ( _InterlockedExchange(MK_FP(__GS__, 28), 0) == 2 )
      v15 = sys_futex((int *)(__readgsdword(8u) + 28), 129, 1, 0, v18, v13);
    v8 = (int *)v19[0];
    if ( v18[1] )
      dl_signal_exception(v13, (int)v18, 0);
  }
  else
  {
    v8 = dl_lookup_symbol_x(a2, dso_for_object, &v17, (int **)dso_for_object[116], a4, 0, a5 | 1, 0);
  }
  v9 = 0;
  if ( v17 )
  {
    if ( *(_WORD *)(v17 + 14) == 0xFFF1 || !v8 )
      v10 = 0;
    else
      v10 = *v8;
    v9 = (int (*)(void))(*(_DWORD *)(v17 + 4) + v10);
    if ( (*(_BYTE *)(v17 + 12) & 0xF) == 10 )
      return (int (*)(void))v9();
  }
  return v9;
}
// 80CEA00: using guessed type void *dl_ns;

//----- (0809BE70) --------------------------------------------------------
int (*__cdecl dl_vsym(int a1, unsigned __int8 *a2, unsigned __int8 *a3, unsigned int a4))(void)
{
  int v4; // edx
  unsigned __int8 *v5; // eax
  int i; // ecx
  int v7; // edx
  int v9[8]; // [esp+14h] [ebp-20h] BYREF

  v4 = 0;
  v9[4] = __readgsdword(0x14u);
  v9[2] = 1;
  v9[0] = (int)a3;
  if ( *a3 )
  {
    v4 = *a3;
    if ( a3[1] )
    {
      v4 = a3[1] + 16 * v4;
      if ( a3[2] )
      {
        v4 = a3[2] + 16 * v4;
        if ( a3[3] )
        {
          v4 = a3[3] + 16 * v4;
          if ( a3[4] )
          {
            v5 = a3 + 5;
            v4 = a3[4] + 16 * v4;
            for ( i = a3[5]; *v5; v4 = ((v7 & 0xF0000000) >> 24) ^ v7 & 0xFFFFFFF )
            {
              ++v5;
              v7 = i + 16 * v4;
              i = *v5;
            }
          }
        }
      }
    }
  }
  v9[1] = v4;
  v9[3] = 0;
  return do_sym(a1, a2, a4, v9, 0);
}

//----- (0809BF40) --------------------------------------------------------
int (*__cdecl dl_sym(int a1, unsigned __int8 *a2, unsigned int a3))(void)
{
  return do_sym(a1, a2, a3, 0, 2);
}

//----- (0809C080) --------------------------------------------------------
unsigned int __cdecl _lttf2(unsigned __int64 a1, unsigned int a2, int a3, unsigned __int64 a4, unsigned int a5, int a6)
{
  unsigned int result; // eax
  int v7; // edx
  int v8; // ecx
  unsigned int v9; // [esp+0h] [ebp-64h]
  int v10; // [esp+18h] [ebp-4Ch]
  unsigned int v11; // [esp+1Ch] [ebp-48h]
  _BOOL4 v12; // [esp+24h] [ebp-40h]

  v11 = (unsigned int)a3 >> 31;
  result = (unsigned int)a6 >> 31;
  v7 = HIWORD(a6) & 0x7FFF;
  v10 = HIWORD(a3) & 0x7FFF;
  if ( (a3 & 0x7FFF0000) != 0 )
  {
    if ( (a6 & 0x7FFF0000) != 0 )
    {
      v8 = 0;
      if ( v10 != 0x7FFF )
      {
        if ( v7 != 0x7FFF )
          goto LABEL_18;
        goto LABEL_22;
      }
    }
    else
    {
      v8 = 2 * (((unsigned __int16)a6 | a5 | (unsigned int)a4 | HIDWORD(a4)) != 0);
      if ( v10 != 0x7FFF )
      {
        if ( (a3 & 0x7FFF0000) == 0 )
          goto LABEL_5;
        goto LABEL_17;
      }
    }
    if ( (unsigned __int16)a3 | a2 | HIDWORD(a1) | (unsigned int)a1 )
      goto LABEL_29;
    if ( v7 != 0x7FFF )
    {
      if ( (a6 & 0x7FFF0000) != 0 )
        goto LABEL_18;
LABEL_17:
      if ( !((unsigned __int16)a6 | a5 | (unsigned int)a4 | HIDWORD(a4)) )
        goto LABEL_8;
      goto LABEL_18;
    }
LABEL_22:
    if ( !((unsigned __int16)a6 | a5 | (unsigned int)a4 | HIDWORD(a4)) )
    {
      if ( (a3 & 0x7FFF0000) == 0 )
      {
        v12 = ((unsigned __int16)a3 | a2 | HIDWORD(a1) | (unsigned int)a1) == 0;
        goto LABEL_25;
      }
LABEL_18:
      if ( v11 != result )
      {
        result = v11 == 0 ? 1 : -1;
        goto LABEL_27;
      }
      if ( v10 > v7 )
      {
        if ( a6 >= 0 )
        {
          result = 1;
          goto LABEL_27;
        }
        goto LABEL_43;
      }
      if ( v10 < v7 )
      {
LABEL_26:
        if ( a6 < 0 )
          goto LABEL_27;
LABEL_43:
        result = -1;
        goto LABEL_27;
      }
      if ( (unsigned __int16)a3 <= (unsigned int)(unsigned __int16)a6 )
      {
        if ( (unsigned __int16)a3 != (unsigned __int16)a6 )
        {
          if ( (unsigned __int16)a3 < (unsigned int)(unsigned __int16)a6 )
            goto LABEL_40;
LABEL_47:
          result = 0;
          goto LABEL_27;
        }
        if ( a5 >= a2 )
        {
          if ( a5 != a2 )
          {
            if ( a5 <= a2 )
              goto LABEL_47;
            goto LABEL_40;
          }
          if ( a4 >= a1 )
          {
            if ( HIDWORD(a4) <= HIDWORD(a1) )
            {
              if ( (unsigned int)a4 > (unsigned int)a1 )
              {
                if ( HIDWORD(a4) != HIDWORD(a1) )
                {
                  result = 0;
                  goto LABEL_27;
                }
                goto LABEL_40;
              }
              goto LABEL_47;
            }
LABEL_40:
            result = -1;
            if ( a3 < 0 )
              result = (unsigned int)a3 >> 31;
            goto LABEL_27;
          }
        }
      }
LABEL_8:
      result = v11 == 0 ? 1 : -1;
      if ( !v8 )
        return result;
LABEL_30:
      v9 = result;
      _sfp_handle_exceptions(v8);
      return v9;
    }
LABEL_29:
    v8 |= 1u;
    result = 2;
    goto LABEL_30;
  }
  if ( (unsigned __int16)a3 | a2 | HIDWORD(a1) | (unsigned int)a1 )
  {
    v8 = 2;
  }
  else
  {
    v8 = 0;
    if ( (a6 & 0x7FFF0000) == 0 )
    {
      v8 = 2 * (((unsigned __int16)a6 | a5 | (unsigned int)a4 | HIDWORD(a4)) != 0);
      goto LABEL_5;
    }
  }
  if ( v7 == 0x7FFF )
    goto LABEL_22;
LABEL_5:
  v12 = ((unsigned __int16)a3 | a2 | HIDWORD(a1) | (unsigned int)a1) == 0;
  if ( (a6 & 0x7FFF0000) != 0 || (unsigned __int16)a6 | a5 | (unsigned int)a4 | HIDWORD(a4) )
  {
LABEL_25:
    if ( v12 )
      goto LABEL_26;
    goto LABEL_18;
  }
  result = 0;
  if ( (unsigned __int16)a3 | a2 | HIDWORD(a1) | (unsigned int)a1 )
    goto LABEL_8;
LABEL_27:
  if ( v8 )
    goto LABEL_30;
  return result;
}

//----- (0809C370) --------------------------------------------------------
unsigned int __cdecl _unordtf2(int a1, int a2, int a3, unsigned int a4, int a5, int a6, int a7, unsigned int a8)
{
  unsigned int v8; // edx
  unsigned int result; // eax
  int v10; // esi
  unsigned int v11; // [esp+0h] [ebp-58h]

  v8 = HIWORD(a8) & 0x7FFF;
  result = HIWORD(a4) & 0x7FFF;
  if ( result )
  {
    if ( v8 )
    {
      if ( result != 0x7FFF )
        goto LABEL_10;
      v10 = 0;
      goto LABEL_24;
    }
  }
  else
  {
    if ( (unsigned __int16)a4 | a3 | a2 | a1 )
    {
      if ( v8 == 0x7FFF && a7 | a6 | a5 | (unsigned __int16)a8 )
      {
        v10 = 2;
        goto LABEL_6;
      }
LABEL_36:
      v10 = 2;
      goto LABEL_8;
    }
    if ( v8 )
    {
LABEL_10:
      if ( v8 == 0x7FFF && (unsigned __int16)a8 | a7 | a6 | a5 )
      {
        v10 = 0;
        goto LABEL_6;
      }
      return 0;
    }
  }
  if ( (unsigned __int16)a8 | a7 | a6 | a5 )
  {
    if ( result != 0x7FFF )
    {
      result = 0;
      goto LABEL_36;
    }
    v10 = 2;
    if ( (unsigned __int16)a4 | a3 | a2 | a1 )
      goto LABEL_16;
    goto LABEL_25;
  }
  if ( result != 0x7FFF )
    return 0;
  v10 = 0;
LABEL_24:
  if ( (unsigned __int16)a4 | a3 | a2 | a1 )
  {
LABEL_16:
    if ( (a4 & 0x8000u) == 0 )
      goto LABEL_7;
    if ( v8 != 0x7FFF )
      goto LABEL_18;
    goto LABEL_33;
  }
LABEL_25:
  if ( v8 == 0x7FFF )
  {
    if ( (unsigned __int16)a8 | a7 | a6 | a5 )
    {
      if ( !((unsigned __int16)a4 | a3 | a2 | a1) )
        goto LABEL_6;
      if ( (a4 & 0x8000u) == 0 )
        goto LABEL_7;
LABEL_33:
      if ( !(a7 | a6 | a5 | (unsigned __int16)a8) )
      {
LABEL_18:
        result = 1;
        goto LABEL_19;
      }
LABEL_6:
      if ( (a8 & 0x8000u) == 0 )
      {
LABEL_7:
        v10 |= 1u;
        result = 1;
LABEL_8:
        v11 = result;
        _sfp_handle_exceptions(v10);
        return v11;
      }
      goto LABEL_18;
    }
    result = 0;
  }
  else
  {
    result = 0;
  }
LABEL_19:
  if ( v10 )
    goto LABEL_8;
  return result;
}
// 809C51D: conditional instruction was optimized away because eax.4<7FFFu

//----- (0809C590) --------------------------------------------------------
int __cdecl _sfp_handle_exceptions(int a1)
{
  int result; // eax

  result = a1;
  if ( (a1 & 2) != 0 )
  {
    __asm
    {
      fnstenv byte ptr [esp+20h+var_1C]
      fldenv  byte ptr [esp+20h+var_1C]
    }
  }
  if ( (a1 & 8) != 0 )
  {
    __asm
    {
      fnstenv byte ptr [esp+20h+var_1C]
      fldenv  byte ptr [esp+20h+var_1C]
    }
  }
  if ( (a1 & 0x10) != 0 )
  {
    __asm
    {
      fnstenv byte ptr [esp+20h+var_1C]
      fldenv  byte ptr [esp+20h+var_1C]
    }
  }
  return result;
}

//----- (0809C610) --------------------------------------------------------
_DWORD *__usercall read_encoded_value_with_base@<eax>(char a1@<al>, int a2@<ecx>, _DWORD *a3)
{
  _DWORD *v3; // esi

  if ( a1 != 80 )
  {
    if ( (a1 & 0xFu) <= 0xC )
      __asm { jmp     ecx }
    read_encoded_value_with_base_cold_6();
  }
  v3 = (_DWORD *)((a2 + 3) & 0xFFFFFFFC);
  *a3 = *v3;
  return v3 + 1;
}
// 8049407: using guessed type void __noreturn read_encoded_value_with_base_cold_6(void);

//----- (0809C760) --------------------------------------------------------
int __usercall base_of_encoded_value@<eax>(
        char a1@<al>,
        _DWORD *a2@<edx>,
        int a3@<ebp>,
        int *a4@<edi>,
        const struct timespec *a5@<esi>)
{
  unsigned __int8 v5; // al

  if ( a1 == -1 )
    return 0;
  v5 = a1 & 0x70;
  if ( v5 == 32 )
    return a2[21];
  if ( v5 <= 0x20u )
  {
    if ( v5 && v5 != 16 )
LABEL_14:
      abort(a3, a4, a5);
    return 0;
  }
  if ( v5 == 64 )
    return a2[23];
  if ( v5 == 80 )
    return 0;
  if ( v5 != 48 )
    goto LABEL_14;
  return a2[22];
}

//----- (0809C7C0) --------------------------------------------------------
struct timespec *__usercall execute_cfa_program@<eax>(
        struct timespec *result@<eax>,
        unsigned int a2@<edx>,
        int *a3@<ecx>,
        int *a4)
{
  int *v4; // edi
  struct timespec *v5; // esi
  unsigned int v6; // edx
  int tv_sec_low; // eax
  char v8; // cl
  int v9; // edx
  int v10; // edi
  int v11; // ecx
  int v12; // edx
  __time_t v13; // edi
  int savedregs; // [esp+40h] [ebp+0h] BYREF

  v4 = a4;
  a4[36] = 0;
  v5 = result;
  if ( (unsigned int)result < a2 )
  {
    v6 = a4[41];
    for ( result = (struct timespec *)(a3[19] + ((unsigned int)a3[24] >> 31));
          v6 < (unsigned int)result;
          result = (struct timespec *)(a3[19] + ((unsigned int)a3[24] >> 31)) )
    {
      tv_sec_low = LOBYTE(v5->tv_sec);
      v8 = v5->tv_sec & 0xC0;
      switch ( v8 )
      {
        case 64:
          result = (struct timespec *)(v6
                                     + *(int *)((char *)a4 + (_DWORD)(&dword_80CE0B0 - 33765376)) * (tv_sec_low & 0x3F));
          *(int *)((char *)a4 + (_DWORD)(&dword_80CE0A4 - 33765376)) = (int)result;
          v5 = (struct timespec *)((char *)v5 + 1);
          break;
        case -128:
          result = (struct timespec *)(tv_sec_low & 0x3F);
          v10 = 0;
          v11 = 0;
          v5 = (struct timespec *)((char *)v5 + 1);
          do
          {
            v5 = (struct timespec *)((char *)v5 + 1);
            v12 = (HIBYTE(v5[-1].tv_nsec) & 0x7F) << v11;
            v11 += 7;
            v10 |= v12;
          }
          while ( v5[-1].tv_nsec < 0 );
          v13 = a4[43] * v10;
          if ( (unsigned __int8)result <= 0x11u )
          {
            result = (struct timespec *)&a4[2 * (unsigned __int8)result];
            result->tv_nsec = 1;
            result->tv_sec = v13;
          }
          break;
        case -64:
          result = (struct timespec *)(tv_sec_low & 0x3F);
          v9 = (unsigned __int8)result;
          if ( (unsigned __int8)result > 0x11u )
          {
            v5 = (struct timespec *)((char *)v5 + 1);
          }
          else
          {
            result = (struct timespec *)a4;
            v5 = (struct timespec *)((char *)v5 + 1);
            a4[2 * v9 + 1] = 0;
          }
          break;
        default:
          if ( (unsigned __int8)tv_sec_low <= 0x2Fu )
            __asm { jmp     ecx }
          execute_cfa_program_cold_7((int)&savedregs, v4, v5);
      }
      if ( a2 <= (unsigned int)v5 )
        break;
      v4 = a3;
      v6 = a4[41];
    }
  }
  return result;
}
// 80CE0A4: using guessed type int dword_80CE0A4;
// 80CE0B0: using guessed type int dword_80CE0B0;

//----- (0809D050) --------------------------------------------------------
_TBYTE *init_dwarf_reg_size_table()
{
  _TBYTE *result; // eax

  result = &GLOBAL_OFFSET_TABLE_;
  dwarf_reg_size_table[0] = 4;
  byte_80CFB56 = 4;
  byte_80CFB55 = 4;
  byte_80CFB57 = 4;
  byte_80CFB5A = 4;
  byte_80CFB5B = 4;
  byte_80CFB59 = 4;
  byte_80CFB58 = 4;
  byte_80CFB5F = 12;
  byte_80CFB60 = 12;
  byte_80CFB61 = 12;
  byte_80CFB62 = 12;
  byte_80CFB63 = 12;
  byte_80CFB64 = 12;
  byte_80CFB5D = 4;
  byte_80CFB5C = 4;
  return result;
}
// 80CE000: using guessed type _TBYTE GLOBAL_OFFSET_TABLE_;
// 80CFB55: using guessed type char byte_80CFB55;
// 80CFB56: using guessed type char byte_80CFB56;
// 80CFB57: using guessed type char byte_80CFB57;
// 80CFB58: using guessed type char byte_80CFB58;
// 80CFB59: using guessed type char byte_80CFB59;
// 80CFB5A: using guessed type char byte_80CFB5A;
// 80CFB5B: using guessed type char byte_80CFB5B;
// 80CFB5C: using guessed type char byte_80CFB5C;
// 80CFB5D: using guessed type char byte_80CFB5D;
// 80CFB5F: using guessed type char byte_80CFB5F;
// 80CFB60: using guessed type char byte_80CFB60;
// 80CFB61: using guessed type char byte_80CFB61;
// 80CFB62: using guessed type char byte_80CFB62;
// 80CFB63: using guessed type char byte_80CFB63;
// 80CFB64: using guessed type char byte_80CFB64;

//----- (0809D0D0) --------------------------------------------------------
int __usercall uw_frame_state_for@<eax>(int *a1@<eax>, _DWORD *a2@<edx>)
{
  int v3; // ecx
  int v5; // eax
  char v6; // bl
  int v7; // esi
  int v8; // ecx
  int v9; // edx
  int v10; // ebp
  unsigned int v11; // ecx
  int v12; // edx
  char *v13; // ebx
  int v14; // ecx
  int v15; // esi
  int v16; // eax
  unsigned __int8 *v17; // ebp
  char tv_sec; // al
  char *encoded_value_with_base; // ebp
  const struct timespec *v20; // esi
  char v21; // al
  int v22; // edx
  int v23; // edx
  char v24; // al
  char v25; // bl
  char *v26; // ebx
  struct timespec *v27; // ebp
  char v28; // al
  unsigned __int8 v29; // al
  int v30; // ebx
  struct timespec *v31; // ebx
  unsigned __int8 v32; // bp
  int v33; // esi
  int v34; // ecx
  int v35; // eax
  const struct timespec *v36; // esi
  struct timespec *v37; // eax
  int result; // eax
  int v39; // ecx
  int v40; // eax
  int v41; // esi
  int v42; // ecx
  int v43; // eax
  int v44; // eax
  int v45; // edx
  int v46; // ecx
  int *FDE; // [esp+4h] [ebp-40h]
  _BYTE *v49; // [esp+Ch] [ebp-38h]
  int v50; // [esp+10h] [ebp-34h]
  unsigned __int8 v51; // [esp+14h] [ebp-30h]
  struct timespec *v52; // [esp+14h] [ebp-30h]
  int v53[8]; // [esp+24h] [ebp-20h] BYREF

  memset(a2, 0, 0xC0u);
  a1[26] = 0;
  a1[20] = 0;
  v3 = a1[19];
  if ( !v3 )
    return 5;
  FDE = Unwind_Find_FDE((int *)(v3 + ((unsigned int)a1[24] >> 31) - 1), a1 + 21);
  if ( !FDE )
  {
    v39 = a1[18];
    v40 = a1[19];
    if ( *(_WORD *)v40 == 0xB858 && *(_DWORD *)(v40 + 2) == 119 && *(_WORD *)(v40 + 6) == 0x80CD )
    {
      v44 = v39 + 4;
      goto LABEL_71;
    }
    if ( *(_BYTE *)v40 == 0xB8 && *(_DWORD *)(v40 + 1) == 173 && *(_WORD *)(v40 + 5) == 0x80CD )
    {
      v44 = v39 + 160;
LABEL_71:
      v45 = *(_DWORD *)(v44 + 28);
      a2[1] = 1;
      *(_DWORD *)((char *)a2 + (_DWORD)(&dword_80CE0A0 - 33765376)) = 1;
      a2[7] = 1;
      *(_DWORD *)((char *)a2 + (_DWORD)(&dword_80CE098 - 33765376)) = 4;
      *(_DWORD *)((char *)a2 + (_DWORD)(&off_80CE094 - 33765376)) = v45 - v39;
      *a2 = v44 + 44 - v45;
      a2[3] = 1;
      a2[6] = v44 + 32 - v45;
      a2[5] = 1;
      a2[2] = v44 + 40 - v45;
      a2[13] = 1;
      a2[4] = v44 + 36 - v45;
      a2[15] = 1;
      a2[12] = v44 + 20 - v45;
      a2[11] = 1;
      a2[14] = v44 + 16 - v45;
      v46 = v44 + 24 - v45;
      a2[17] = 1;
      a2[16] = v44 + 56 - v45;
      result = 0;
      a2[10] = v46;
      *(_DWORD *)((char *)a2 + (_DWORD)(&dword_80CE0B4 - 33765376)) = 8;
      byte_80CE0BB[(_DWORD)a2 - 135061504] = 1;
      return result;
    }
    return 5;
  }
  *(_DWORD *)((char *)a2 + (_DWORD)(&dword_80CE0A4 - 33765376)) = a1[23];
  v50 = (int)FDE - FDE[1] + 4;
  v49 = (_BYTE *)(v50 + 9);
  v5 = v50 + 9 + strlen((unsigned int *)(v50 + 9)) + 1;
  if ( *(_BYTE *)(v50 + 9) == 101 && *(_BYTE *)(v50 + 10) == 104 )
  {
    v22 = *(_DWORD *)v5;
    v5 += 4;
    v49 = (_BYTE *)(v50 + 11);
    *(_DWORD *)((char *)a2 + (_DWORD)(&dword_80CE0BC - 33765376)) = v22;
  }
  v6 = *(_BYTE *)v5;
  v51 = *(_BYTE *)(v50 + 8);
  if ( v51 > 3u )
  {
    if ( v6 != 4 || *(_BYTE *)(v5 + 1) )
      return 3;
    v6 = *(_BYTE *)(v5 + 2);
    v5 += 2;
  }
  v7 = 0;
  v8 = 0;
  while ( 1 )
  {
    ++v5;
    v9 = (v6 & 0x7F) << v8;
    v8 += 7;
    v7 |= v9;
    if ( v6 >= 0 )
      break;
    v6 = *(_BYTE *)v5;
  }
  *(_DWORD *)((char *)a2 + (_DWORD)(&dword_80CE0B0 - 33765376)) = v7;
  v10 = 0;
  v11 = 0;
  while ( 1 )
  {
    v12 = (*(_BYTE *)v5 & 0x7F) << v11;
    v11 += 7;
    v10 |= v12;
    if ( *(char *)v5 >= 0 )
      break;
    ++v5;
  }
  v13 = (char *)(v5 + 1);
  if ( v11 <= 0x1F && (*(_BYTE *)v5 & 0x40) != 0 )
    v10 |= -1 << v11;
  v14 = 0;
  *(_DWORD *)((char *)a2 + (_DWORD)(&dword_80CE0AC - 33765376)) = v10;
  v15 = 0;
  if ( v51 == 1 )
  {
    v23 = (unsigned __int8)*v13;
    v13 = (char *)(v5 + 2);
    *(_DWORD *)((char *)a2 + (_DWORD)(&dword_80CE0B4 - 33765376)) = v23;
  }
  else
  {
    do
    {
      v16 = (*v13++ & 0x7F) << v14;
      v14 += 7;
      v15 |= v16;
    }
    while ( *(v13 - 1) < 0 );
    *(_DWORD *)((char *)a2 + (_DWORD)(&dword_80CE0B4 - 33765376)) = v15;
  }
  byte_80CE0B9[(_DWORD)a2 - 135061504] = -1;
  v17 = 0;
  tv_sec = *v49;
  if ( *v49 == 122 )
  {
    v41 = 0;
    v42 = 0;
    do
    {
      v43 = (*v13++ & 0x7F) << v42;
      v42 += 7;
      v41 |= v43;
    }
    while ( *(v13 - 1) < 0 );
    v17 = (unsigned __int8 *)&v13[v41];
    byte_80CE0BA[(_DWORD)a2 - 135061504] = 1;
    tv_sec = *++v49;
  }
  v52 = (struct timespec *)v17;
  encoded_value_with_base = v13;
  v20 = (const struct timespec *)(v49 + 1);
  while ( tv_sec )
  {
    switch ( tv_sec )
    {
      case 'L':
        v21 = *encoded_value_with_base++;
        byte_80CE0B9[(_DWORD)a2 - 135061504] = v21;
        break;
      case 'R':
        v24 = *encoded_value_with_base++;
        byte_80CE0B8[(_DWORD)a2 - 135061504] = v24;
        break;
      case 'P':
        v25 = *encoded_value_with_base;
        base_of_encoded_value(*encoded_value_with_base, a1, (int)encoded_value_with_base, a2, v20);
        encoded_value_with_base = (char *)read_encoded_value_with_base(v25, (int)(encoded_value_with_base + 1), v53);
        *(_DWORD *)((char *)a2 + (_DWORD)(&off_80CE0A8 - 33765376)) = v53[0];
        break;
      case 'S':
        byte_80CE0BB[(_DWORD)a2 - 135061504] = 1;
        break;
      default:
        v27 = v52;
        goto LABEL_62;
    }
    tv_sec = v20->tv_sec;
    v20 = (const struct timespec *)((char *)v20 + 1);
  }
  v26 = encoded_value_with_base;
  v27 = v52;
  if ( !v52 )
  {
    v27 = (struct timespec *)v26;
LABEL_62:
    if ( !v27 )
      return 3;
  }
  execute_cfa_program(v27, v50 + *(_DWORD *)v50 + 4, a1, a2);
  v28 = byte_80CE0B8[(_DWORD)a2 - 135061504];
  if ( v28 == -1 )
  {
    v30 = 2;
  }
  else
  {
    v29 = v28 & 7;
    if ( v29 == 2 )
    {
      v30 = 3;
    }
    else
    {
      if ( v29 <= 2u )
      {
        if ( v29 )
          goto LABEL_75;
      }
      else if ( v29 != 3 )
      {
        if ( v29 == 4 )
        {
          v30 = 6;
          goto LABEL_39;
        }
LABEL_75:
        abort((int)v27, a2, v20);
      }
      v30 = 4;
    }
  }
LABEL_39:
  v31 = (struct timespec *)&FDE[v30];
  v32 = byte_80CE0B9[(_DWORD)a2 - 135061504];
  if ( byte_80CE0BA[(_DWORD)a2 - 135061504] )
  {
    v33 = 0;
    v34 = 0;
    do
    {
      v31 = (struct timespec *)((char *)v31 + 1);
      v35 = (HIBYTE(v31[-1].tv_nsec) & 0x7F) << v34;
      v34 += 7;
      v33 |= v35;
    }
    while ( v31[-1].tv_nsec < 0 );
    v36 = (struct timespec *)((char *)v31 + v33);
    v37 = v31;
    if ( v32 == 0xFF )
    {
LABEL_43:
      if ( v36 )
        v37 = (struct timespec *)v36;
      v31 = v37;
      goto LABEL_46;
    }
LABEL_50:
    base_of_encoded_value(v32, a1, v32, a2, v36);
    v37 = (struct timespec *)read_encoded_value_with_base(v32, (int)v31, v53);
    a1[20] = v53[0];
    goto LABEL_43;
  }
  if ( v32 != 0xFF )
  {
    v36 = 0;
    goto LABEL_50;
  }
LABEL_46:
  execute_cfa_program(v31, (unsigned int)FDE + *FDE + 4, a1, a2);
  return 0;
}
// 80CE094: using guessed type void *off_80CE094;
// 80CE098: using guessed type int dword_80CE098;
// 80CE0A0: using guessed type int dword_80CE0A0;
// 80CE0A4: using guessed type int dword_80CE0A4;
// 80CE0A8: using guessed type void *off_80CE0A8;
// 80CE0AC: using guessed type int dword_80CE0AC;
// 80CE0B0: using guessed type int dword_80CE0B0;
// 80CE0B4: using guessed type int dword_80CE0B4;
// 80CE0BC: using guessed type int dword_80CE0BC;

//----- (0809D630) --------------------------------------------------------
int __usercall execute_stack_op@<eax>(
        const struct timespec *a1@<eax>,
        unsigned int a2@<edx>,
        int a3@<ebp>,
        int *a4@<edi>,
        int a5)
{
  int result; // eax
  unsigned __int8 v7; // cl

  result = a5;
  if ( (unsigned int)a1 < a2 )
  {
    v7 = LOBYTE(a1->tv_sec) - 3;
    if ( v7 <= 0xEEu )
      __asm { jmp     ebp }
    abort(a3, a4, a1);
  }
  return result;
}

//----- (0809DD30) --------------------------------------------------------
unsigned int __usercall uw_update_context_1@<eax>(int a1@<eax>, int a2@<edx>, int a3)
{
  int *v4; // edi
  const struct timespec *v5; // esi
  int v6; // edx
  int v7; // eax
  int v8; // eax
  _DWORD *v9; // ecx
  const struct timespec *v10; // eax
  int v11; // esi
  int v12; // ecx
  int v13; // edx
  int v14; // ebx
  unsigned int result; // eax
  int v16; // edx
  __int16 v17; // dx
  int v19; // [esp+8h] [ebp-B4h]
  int v20; // [esp+1Ch] [ebp-A0h] BYREF
  int v21[32]; // [esp+20h] [ebp-9Ch] BYREF
  int v22; // [esp+A0h] [ebp-1Ch] BYREF

  qmemcpy(v21, (const void *)a1, sizeof(v21));
  v5 = (const struct timespec *)(a1 + 128);
  v4 = &v22;
  v6 = v21[24];
  if ( ((v21[24] & 0x40000000) == 0 || !LOBYTE(v21[28])) && !v21[4] )
  {
    v4 = (int *)&GLOBAL_OFFSET_TABLE_;
    if ( *((_BYTE *)&GLOBAL_OFFSET_TABLE_ + 7000) != 4 )
      goto LABEL_34;
    v20 = *(_DWORD *)(a1 + 72);
    if ( (v21[24] & 0x40000000) != 0 )
      LOBYTE(v21[28]) = 0;
    v21[4] = (int)&v20;
  }
  if ( (*(_BYTE *)(a1 + 99) & 0x40) != 0 )
    *(_BYTE *)(a1 + 112) = 0;
  *(_DWORD *)(a1 + 16) = 0;
  v7 = *(_DWORD *)(a2 + 160);
  if ( v7 == 1 )
  {
    v8 = *(_DWORD *)(a2 + 152);
    if ( v8 <= 17 )
    {
      v5 = (const struct timespec *)&GLOBAL_OFFSET_TABLE_;
      v9 = (_DWORD *)v21[v8];
      if ( (v6 & 0x40000000) != 0 && *((_BYTE *)&v21[27] + v8) )
        goto LABEL_12;
      if ( dwarf_reg_size_table[v8] == 4 )
      {
        v9 = (_DWORD *)*v9;
LABEL_12:
        v19 = (int)v9 + *(_DWORD *)(a2 + 148);
        goto LABEL_17;
      }
    }
LABEL_34:
    uw_update_context_1_cold_9(a2, v4, v5, a3);
  }
  if ( v7 != 2 )
    abort(a2, v4, v5);
  v10 = *(const struct timespec **)(a2 + 156);
  v11 = 0;
  v12 = 0;
  do
  {
    v10 = (const struct timespec *)((char *)v10 + 1);
    v13 = (HIBYTE(v10[-1].tv_nsec) & 0x7F) << v12;
    v12 += 7;
    v11 |= v13;
  }
  while ( v10[-1].tv_nsec < 0 );
  v19 = execute_stack_op(v10, (unsigned int)v10 + v11, a2, v4, 0);
LABEL_17:
  v14 = 0;
  *(_DWORD *)(a1 + 72) = v19;
  do
  {
    if ( *(_DWORD *)(a2 + 8 * v14 + 4) <= 5u )
      __asm { jmp     edi }
    ++v14;
  }
  while ( v14 != 18 );
  result = *(_DWORD *)(a1 + 96) & 0x7FFFFFFF;
  if ( *(_BYTE *)(a2 + 187) )
    result = *(_DWORD *)(a1 + 96) | 0x80000000;
  v16 = *(_DWORD *)(a1 + 76);
  *(_DWORD *)(a1 + 96) = result;
  if ( *(_BYTE *)v16 == 0xB8 && *(_DWORD *)(v16 + 1) == 173 )
  {
    v17 = *(_WORD *)(v16 + 5);
    if ( v17 == -32563 || v17 == 1295 )
    {
      result |= 0x80000000;
      *(_DWORD *)(a1 + 96) = result;
    }
  }
  return result;
}
// 80CE000: using guessed type _TBYTE GLOBAL_OFFSET_TABLE_;

//----- (0809E0B0) --------------------------------------------------------
int __usercall uw_init_context_1@<eax>(int a1@<eax>, int a2@<edx>, int a3@<ecx>)
{
  int result; // eax
  int v6; // [esp-Ch] [ebp-FCh]
  int v8; // [esp+10h] [ebp-E0h] BYREF
  _DWORD v9[55]; // [esp+14h] [ebp-DCh] BYREF
  void *retaddr; // [esp+F0h] [ebp+0h]

  memset((void *)a1, 0, 0x80u);
  *(_DWORD *)(a1 + 96) = 0x40000000;
  *(_DWORD *)(a1 + 76) = retaddr;
  if ( uw_frame_state_for((int *)a1, v9) )
    goto LABEL_9;
  if ( !dwarf_reg_size_table[0] )
  {
    dwarf_reg_size_table[0] = 4;
    byte_80CFB56 = 4;
    byte_80CFB55 = 4;
    byte_80CFB57 = 4;
    byte_80CFB5A = 4;
    byte_80CFB5B = 4;
    byte_80CFB59 = 4;
    byte_80CFB58 = 4;
    byte_80CFB5F = 12;
    byte_80CFB60 = 12;
    byte_80CFB61 = 12;
    byte_80CFB62 = 12;
    byte_80CFB63 = 12;
    byte_80CFB64 = 12;
    byte_80CFB5D = 4;
    byte_80CFB5C = 4;
  }
  if ( byte_80CFB58 != 4 )
LABEL_9:
    uw_init_context_1_cold_10();
  v8 = a2;
  if ( (*(_BYTE *)(a1 + 99) & 0x40) != 0 )
    *(_BYTE *)(a1 + 112) = 0;
  v9[40] = 1;
  *(_DWORD *)(a1 + 16) = &v8;
  v9[38] = 4;
  v9[37] = 0;
  uw_update_context_1(a1, (int)v9, v6);
  result = a3;
  *(_DWORD *)(a1 + 76) = a3;
  return result;
}
// 809E170: variable 'v6' is possibly undefined
// 8049426: using guessed type void __noreturn uw_init_context_1_cold_10(void);
// 80CFB55: using guessed type char byte_80CFB55;
// 80CFB56: using guessed type char byte_80CFB56;
// 80CFB57: using guessed type char byte_80CFB57;
// 80CFB58: using guessed type char byte_80CFB58;
// 80CFB59: using guessed type char byte_80CFB59;
// 80CFB5A: using guessed type char byte_80CFB5A;
// 80CFB5B: using guessed type char byte_80CFB5B;
// 80CFB5C: using guessed type char byte_80CFB5C;
// 80CFB5D: using guessed type char byte_80CFB5D;
// 80CFB5F: using guessed type char byte_80CFB5F;
// 80CFB60: using guessed type char byte_80CFB60;
// 80CFB61: using guessed type char byte_80CFB61;
// 80CFB62: using guessed type char byte_80CFB62;
// 80CFB63: using guessed type char byte_80CFB63;
// 80CFB64: using guessed type char byte_80CFB64;

//----- (0809E210) --------------------------------------------------------
int __usercall uw_update_context@<eax>(int a1@<eax>, int a2@<edx>)
{
  int result; // eax
  _DWORD *v5; // edx
  int v6; // [esp+0h] [ebp-Ch]

  uw_update_context_1(a1, a2, v6);
  result = *(_DWORD *)(a2 + 180);
  if ( *(_DWORD *)(a2 + 8 * result + 4) == 6 )
  {
    *(_DWORD *)(a1 + 76) = 0;
    return result;
  }
  if ( result > 17 )
    goto LABEL_3;
  v5 = *(_DWORD **)(a1 + 4 * result);
  if ( (*(_BYTE *)(a1 + 99) & 0x40) != 0 && *(_BYTE *)(a1 + result + 108) )
    goto LABEL_8;
  if ( dwarf_reg_size_table[result] != 4 )
LABEL_3:
    uw_update_context_cold_11();
  v5 = (_DWORD *)*v5;
LABEL_8:
  *(_DWORD *)(a1 + 76) = v5;
  return result;
}
// 809E222: variable 'v6' is possibly undefined
// 804942B: using guessed type void __noreturn uw_update_context_cold_11(void);

//----- (0809E280) --------------------------------------------------------
int __usercall Unwind_RaiseException_Phase2@<eax>(
        const struct timespec *a1@<eax>,
        int *a2@<edx>,
        int *a3@<ecx>,
        int a4,
        int a5,
        int a6)
{
  int i; // ebp
  int result; // eax
  int v10; // edx
  int v11; // eax
  int v12; // [esp+0h] [ebp-E8h]
  int v14[42]; // [esp+Ch] [ebp-DCh] BYREF
  int (__cdecl *v15)(int, int, __time_t, int, const struct timespec *, int *); // [esp+B4h] [ebp-34h]

  for ( i = 1; ; ++i )
  {
    v11 = uw_frame_state_for(a2, v14);
    v10 = 4 * (a1[2].tv_sec == a2[18] - ((unsigned int)a2[24] >> 31));
    if ( v11 )
      return 2;
    if ( v15 )
      break;
LABEL_5:
    if ( v10 )
      Unwind_RaiseException_Phase2_cold_12(i, v14, a1, a4, a5, a6);
    uw_update_context((int)a2, (int)v14);
  }
  v12 = 4 * (a1[2].tv_sec == a2[18] - ((unsigned int)a2[24] >> 31));
  result = v15(1, v10 | 2, a1->tv_sec, a1->tv_nsec, a1, a2);
  if ( result != 7 )
  {
    v10 = v12;
    if ( result != 8 )
      return 2;
    goto LABEL_5;
  }
  *a3 = i;
  return result;
}
// 809E280: using guessed type int var_DC[42];

//----- (0809E350) --------------------------------------------------------
int __usercall Unwind_ForcedUnwind_Phase2@<eax>(_DWORD *a1@<eax>, int *a2@<edx>, int *a3@<ecx>)
{
  int v3; // ebp
  int v6; // eax
  int v7; // eax
  int v8; // ecx
  int v9; // eax
  int v10; // edx
  int v11; // edi
  int v12; // ebp
  int (__cdecl *v14)(int, int, int, int, _DWORD *, int *, int); // [esp+4h] [ebp-E8h]
  int v15; // [esp+8h] [ebp-E4h]
  int v17[42]; // [esp+10h] [ebp-DCh] BYREF
  int (__cdecl *v18)(int, int, _DWORD, _DWORD, _DWORD *, int *); // [esp+B8h] [ebp-34h]

  v3 = 1;
  v14 = (int (__cdecl *)(int, int, int, int, _DWORD *, int *, int))a1[3];
  v15 = a1[4];
  while ( 1 )
  {
    v7 = uw_frame_state_for(a2, v17);
    v8 = v7;
    if ( v7 && v7 != 5 )
      return 2;
    v9 = *a1;
    v10 = a1[1];
    if ( v8 == 5 )
      break;
    if ( v14(1, 10, v9, v10, a1, a2, v15) )
      return 2;
    if ( v18 )
    {
      v6 = v18(1, 10, *a1, a1[1], a1, a2);
      if ( v6 == 7 )
      {
        v11 = v3;
        v12 = 7;
        goto LABEL_13;
      }
      if ( v6 != 8 )
        return 2;
    }
    ++v3;
    uw_update_context((int)a2, (int)v17);
  }
  v11 = v3;
  v12 = 5;
  if ( v14(1, 26, v9, v10, a1, a2, v15) )
    return 2;
LABEL_13:
  *a3 = v11;
  return v12;
}
// 809E350: using guessed type _DWORD var_DC[42];

//----- (0809E440) --------------------------------------------------------
int __usercall uw_install_context_1@<eax>(
        int a1@<eax>,
        unsigned int a2@<edx>,
        unsigned int a3@<ebp>,
        int a4,
        int a5,
        int a6)
{
  int v7; // eax
  const struct timespec *v8; // esi
  int v9; // eax
  int *v10; // edi
  char *v11; // ecx
  _BYTE *v12; // edi
  int v13; // ecx
  char *v14; // esi
  unsigned int v15; // ecx
  int result; // eax
  _DWORD *v17; // eax
  unsigned int v18; // [esp+4h] [ebp-34h]
  int v19; // [esp+18h] [ebp-20h] BYREF

  v7 = *(_DWORD *)(a2 + 96);
  if ( (v7 & 0x40000000) == 0 || !*(_BYTE *)(a2 + 112) )
  {
    v8 = *(const struct timespec **)(a2 + 16);
    if ( !v8 )
    {
      v10 = (int *)&GLOBAL_OFFSET_TABLE_;
      if ( byte_80CFB58 != 4 )
        goto LABEL_33;
      v19 = *(_DWORD *)(a2 + 72);
      if ( (v7 & 0x40000000) != 0 )
        *(_BYTE *)(a2 + 112) = 0;
      *(_DWORD *)(a2 + 16) = &v19;
    }
  }
  v9 = 0;
  v18 = a2;
  do
  {
    while ( 1 )
    {
      v10 = (int *)a1;
      v11 = *(char **)(a1 + 4 * v9);
      v8 = *(const struct timespec **)(v18 + 4 * v9);
      if ( *(_BYTE *)(a1 + v9 + 108) )
        goto LABEL_33;
      if ( *(_BYTE *)(v18 + v9 + 108) )
      {
        if ( v11 )
        {
          if ( *((_BYTE *)&GLOBAL_OFFSET_TABLE_ + v9 + 6996) != 4 )
            goto LABEL_33;
          *(_DWORD *)v11 = v8;
        }
        goto LABEL_8;
      }
      LOBYTE(a2) = v8 != 0;
      a3 = a2;
      LOBYTE(a2) = v11 != 0;
      v10 = (int *)a2;
      a2 = a3;
      if ( ((unsigned __int8)v10 & (unsigned __int8)a3) != 0 && v11 != (char *)v8 )
        break;
LABEL_8:
      if ( ++v9 == 17 )
        goto LABEL_18;
    }
    v10 = (int *)&GLOBAL_OFFSET_TABLE_;
    a3 = (unsigned __int8)dwarf_reg_size_table[v9];
    if ( a3 < 4 )
    {
      if ( dwarf_reg_size_table[v9] )
      {
        *v11 = v8->tv_sec;
        if ( (a3 & 2) != 0 )
        {
          v8 = (const struct timespec *)*(unsigned __int16 *)((char *)v8 + a3 - 2);
          *(_WORD *)&v11[a3 - 2] = (_WORD)v8;
        }
      }
      goto LABEL_8;
    }
    ++v9;
    *(_DWORD *)v11 = v8->tv_sec;
    *(_DWORD *)&v11[a3 - 4] = *(_DWORD *)((char *)v8 + a3 - 4);
    v12 = (_BYTE *)((unsigned int)(v11 + 4) & 0xFFFFFFFC);
    v13 = v11 - v12;
    v14 = (char *)v8 - v13;
    v15 = (a3 + v13) >> 2;
    qmemcpy(v12, v14, 4 * v15);
    v8 = (const struct timespec *)&v14[4 * v15];
    v10 = (int *)&v12[4 * v15];
  }
  while ( v9 != 17 );
LABEL_18:
  result = 0;
  if ( ((*(_BYTE *)(a1 + 99) & 0x40) == 0 || !*(_BYTE *)(a1 + 112)) && !*(_DWORD *)(a1 + 16) )
  {
    v17 = *(_DWORD **)(v18 + 16);
    if ( (*(_BYTE *)(v18 + 99) & 0x40) != 0 && *(_BYTE *)(v18 + 112) )
      return (int)v17 + *(_DWORD *)(v18 + 104) - *(_DWORD *)(a1 + 72);
    if ( *((_BYTE *)&GLOBAL_OFFSET_TABLE_ + 7000) == 4 )
    {
      v17 = (_DWORD *)*v17;
      return (int)v17 + *(_DWORD *)(v18 + 104) - *(_DWORD *)(a1 + 72);
    }
LABEL_33:
    uw_install_context_1_cold_13(a3, v10, v8, a4, a5, a6);
  }
  return result;
}
// 80CE000: using guessed type _TBYTE GLOBAL_OFFSET_TABLE_;
// 80CFB58: using guessed type char byte_80CFB58;

//----- (0809E5D0) --------------------------------------------------------
int __cdecl Unwind_GetGR(int a1, int a2)
{
  int v2; // ecx
  int result; // eax

  v2 = a1;
  if ( a2 > 17 )
    goto LABEL_7;
  result = *(_DWORD *)(a1 + 4 * a2);
  if ( (*(_BYTE *)(a1 + 99) & 0x40) == 0 || !*(_BYTE *)(a1 + a2 + 108) )
  {
    v2 = (unsigned __int8)dwarf_reg_size_table[a2];
    if ( dwarf_reg_size_table[a2] == 4 )
      return *(_DWORD *)result;
LABEL_7:
    Unwind_GetGR_cold_14(v2);
  }
  return result;
}
// 8049442: using guessed type void __fastcall __noreturn Unwind_GetGR_cold_14(_DWORD);

//----- (0809E630) --------------------------------------------------------
int __cdecl Unwind_GetCFA(int a1)
{
  return *(_DWORD *)(a1 + 72);
}

//----- (0809E640) --------------------------------------------------------
int *__usercall Unwind_SetGR@<eax>(
        int a1@<ebp>,
        int *a2@<edi>,
        const struct timespec *a3@<esi>,
        int a4,
        int a5,
        int a6)
{
  int *result; // eax

  result = (int *)a5;
  if ( a5 > 17 )
    goto LABEL_7;
  if ( (*(_BYTE *)(a4 + 99) & 0x40) == 0 || !*(_BYTE *)(a4 + a5 + 108) )
  {
    result = *(int **)(a4 + 4 * a5);
    if ( dwarf_reg_size_table[a5] == 4 )
    {
      *result = a6;
      return result;
    }
LABEL_7:
    Unwind_SetGR_cold_15(a1, a2, a3);
  }
  *(_DWORD *)(a4 + 4 * a5) = a6;
  return result;
}

//----- (0809E6B0) --------------------------------------------------------
int __cdecl Unwind_GetIP(int a1)
{
  return *(_DWORD *)(a1 + 76);
}

//----- (0809E6C0) --------------------------------------------------------
int __cdecl Unwind_GetIPInfo(int a1, _DWORD *a2)
{
  *a2 = *(_DWORD *)(a1 + 96) >> 31;
  return *(_DWORD *)(a1 + 76);
}

//----- (0809E6E0) --------------------------------------------------------
int __cdecl Unwind_SetIP(int a1, int a2)
{
  int result; // eax

  result = a1;
  *(_DWORD *)(a1 + 76) = a2;
  return result;
}

//----- (0809E6F0) --------------------------------------------------------
int __cdecl Unwind_GetLanguageSpecificData(int a1)
{
  return *(_DWORD *)(a1 + 80);
}

//----- (0809E700) --------------------------------------------------------
int __cdecl Unwind_GetRegionStart(int a1)
{
  return *(_DWORD *)(a1 + 92);
}

//----- (0809E710) --------------------------------------------------------
int *__cdecl Unwind_FindEnclosingFunction(int a1)
{
  int *result; // eax
  _DWORD v2[6]; // [esp+0h] [ebp-18h] BYREF

  result = Unwind_Find_FDE((int *)(a1 - 1), v2);
  if ( result )
    return (int *)v2[2];
  return result;
}

//----- (0809E750) --------------------------------------------------------
int __cdecl Unwind_GetDataRelBase(int a1)
{
  return *(_DWORD *)(a1 + 88);
}

//----- (0809E760) --------------------------------------------------------
int __cdecl Unwind_GetTextRelBase(int a1)
{
  return *(_DWORD *)(a1 + 84);
}

//----- (0809E770) --------------------------------------------------------
int __cdecl _frame_state_for(int a1, int a2)
{
  int i; // edx
  int v3; // ecx
  int v5[32]; // [esp+0h] [ebp-15Ch] BYREF
  int v6[37]; // [esp+80h] [ebp-DCh] BYREF
  int v7; // [esp+114h] [ebp-48h]
  int v8; // [esp+118h] [ebp-44h]
  int v9; // [esp+120h] [ebp-3Ch]
  int v10; // [esp+134h] [ebp-28h]
  int v11; // [esp+13Ch] [ebp-20h]

  memset(v5, 0, sizeof(v5));
  v5[24] = 0x40000000;
  v5[19] = a1 + 1;
  if ( uw_frame_state_for(v5, v6) || v9 == 2 )
    return 0;
  for ( i = 0; i != 18; ++i )
  {
    while ( 1 )
    {
      v3 = v6[2 * i + 1];
      *(_BYTE *)(a2 + i + 92) = v3;
      if ( (_BYTE)v3 == 1 || (_BYTE)v3 == 2 )
        break;
      *(_DWORD *)(a2 + 4 * i++ + 16) = 0;
      if ( i == 18 )
        goto LABEL_8;
    }
    *(_DWORD *)(a2 + 4 * i + 16) = v6[2 * i];
  }
LABEL_8:
  *(_DWORD *)(a2 + 8) = v7;
  *(_WORD *)(a2 + 88) = v8;
  *(_WORD *)(a2 + 90) = v10;
  *(_DWORD *)(a2 + 12) = v5[26];
  *(_DWORD *)(a2 + 4) = v11;
  return a2;
}
// 809E770: using guessed type _DWORD var_DC[37];

//----- (0809E850) --------------------------------------------------------
void Unwind_DebugHook()
{
  ;
}

//----- (0809E860) --------------------------------------------------------
int __usercall Unwind_RaiseException@<eax>(int a1@<eax>, int a2@<edx>, const struct timespec *a3)
{
  int result; // eax
  int v4; // eax
  int v5; // edi
  int v6; // ebx
  int v7; // edx
  int v11; // [esp-8h] [ebp-1E8h]
  int v12; // [esp-8h] [ebp-1E8h]
  int v13; // [esp-4h] [ebp-1E4h]
  int v14; // [esp-4h] [ebp-1E4h]
  int v15; // [esp+0h] [ebp-1E0h]
  char v16[128]; // [esp+8h] [ebp-1D8h] BYREF
  int v17[32]; // [esp+88h] [ebp-158h] BYREF
  int v18[42]; // [esp+108h] [ebp-D8h] BYREF
  int (__cdecl *v19)(int, int, __time_t, int, const struct timespec *, int *); // [esp+1B0h] [ebp-30h]
  int v20; // [esp+1CCh] [ebp-14h]
  int v21; // [esp+1D0h] [ebp-10h]
  int vars0; // [esp+1E0h] [ebp+0h] BYREF
  int retaddr; // [esp+1E4h] [ebp+4h]

  v21 = a2;
  v20 = a1;
  uw_init_context_1((int)v16, (int)&a3, retaddr);
  qmemcpy(v17, v16, sizeof(v17));
  for ( result = uw_frame_state_for(v17, v18); result != 5; result = uw_frame_state_for(v17, v18) )
  {
    if ( result )
      return 3;
    if ( v19 )
    {
      v4 = v19(1, 1, a3->tv_sec, a3->tv_nsec, a3, v17);
      if ( v4 == 6 )
      {
        v5 = v17[18];
        a3[1].tv_nsec = 0;
        a3[2].tv_sec = v5 - ((unsigned int)v17[24] >> 31);
        qmemcpy(v17, v16, sizeof(v17));
        result = Unwind_RaiseException_Phase2(a3, v17, v18, v11, v13, (int)v16);
        if ( result == 7 )
        {
          uw_install_context_1(v15, (unsigned int)v17, (unsigned int)&vars0, v12, v14, v15);
          v6 = v17[19];
          Unwind_DebugHook();
          __asm { rdsspd  eax }
          if ( _EAX )
          {
            _EAX = v18[0];
            _ECX = 255;
            while ( _EAX > 0xFF )
            {
              __asm { incsspd ecx }
              _EAX -= 255;
            }
            __asm { incsspd eax }
          }
          *(int *)((char *)&vars0 + v7 + 4) = v6;
          return v20;
        }
        return result;
      }
      if ( v4 != 8 )
        return 3;
    }
    uw_update_context((int)v17, (int)v18);
  }
  return result;
}
// 809E95D: variable 'v11' is possibly undefined
// 809E95D: variable 'v13' is possibly undefined
// 809E96F: variable 'v15' is possibly undefined
// 809E96F: variable 'v12' is possibly undefined
// 809E96F: variable 'v14' is possibly undefined
// 809E9BA: variable 'v7' is possibly undefined

//----- (0809E9E0) --------------------------------------------------------
int __usercall Unwind_ForcedUnwind@<eax>(int a1@<eax>, int a2@<edx>, _DWORD *a3, int a4, int a5)
{
  _DWORD *v5; // esi
  int result; // eax
  int v7; // ebx
  int v8; // edx
  int v12; // [esp-Ch] [ebp-128h]
  int v13; // [esp-8h] [ebp-124h]
  int v14; // [esp-4h] [ebp-120h]
  unsigned int v15; // [esp+0h] [ebp-11Ch] BYREF
  char v16[128]; // [esp+4h] [ebp-118h] BYREF
  int v17[33]; // [esp+84h] [ebp-98h] BYREF
  int v18; // [esp+108h] [ebp-14h]
  int v19; // [esp+10Ch] [ebp-10h]
  int vars0; // [esp+11Ch] [ebp+0h] BYREF
  int retaddr; // [esp+120h] [ebp+4h]

  v19 = a2;
  v18 = a1;
  uw_init_context_1((int)v16, (int)&a3, retaddr);
  qmemcpy(v17, v16, 0x80u);
  v5 = a3;
  a3[3] = a4;
  v5[4] = a5;
  result = Unwind_ForcedUnwind_Phase2(v5, v17, (int *)&v15);
  if ( result == 7 )
  {
    uw_install_context_1((int)v16, (unsigned int)v17, (unsigned int)&vars0, v12, v13, v14);
    v7 = v17[19];
    Unwind_DebugHook();
    __asm { rdsspd  eax }
    if ( _EAX )
    {
      _EAX = v15;
      if ( v15 > 0xFF )
      {
        _ECX = 255;
        do
        {
          __asm { incsspd ecx }
          _EAX -= 255;
        }
        while ( _EAX > 0xFF );
      }
      __asm { incsspd eax }
    }
    *(int *)((char *)&vars0 + v8 + 4) = v7;
    return v18;
  }
  return result;
}
// 809EA4C: variable 'v12' is possibly undefined
// 809EA4C: variable 'v13' is possibly undefined
// 809EA4C: variable 'v14' is possibly undefined
// 809EA96: variable 'v8' is possibly undefined

//----- (0809EAC0) --------------------------------------------------------
void __usercall __noreturn Unwind_Resume(int a1@<eax>, int a2@<edx>, struct timespec *a3)
{
  const struct timespec *tv_nsec; // esi
  int v4; // eax
  int v5; // ebx
  int v6; // eax
  int v10; // [esp-8h] [ebp-138h]
  int v11; // [esp-4h] [ebp-134h]
  _TBYTE *v12; // [esp+0h] [ebp-130h]
  unsigned int v13; // [esp+14h] [ebp-11Ch] BYREF
  char v14[128]; // [esp+18h] [ebp-118h] BYREF
  int v15[32]; // [esp+98h] [ebp-98h] BYREF
  int v16[3]; // [esp+118h] [ebp-18h] BYREF
  int vars0; // [esp+130h] [ebp+0h] BYREF
  int retaddr; // [esp+134h] [ebp+4h]

  v16[2] = a2;
  v16[1] = a1;
  v12 = &GLOBAL_OFFSET_TABLE_;
  uw_init_context_1((int)v14, (int)&a3, retaddr);
  qmemcpy(v15, v14, sizeof(v15));
  tv_nsec = (const struct timespec *)a3[1].tv_nsec;
  if ( tv_nsec )
    v4 = Unwind_ForcedUnwind_Phase2(a3, v15, (int *)&v13);
  else
    v4 = Unwind_RaiseException_Phase2(a3, v15, (int *)&v13, v10, v11, (int)&GLOBAL_OFFSET_TABLE_);
  if ( v4 != 7 )
    Unwind_Resume_cold_16((int)&vars0, v16, tv_nsec);
  uw_install_context_1((int)v14, (unsigned int)v15, (unsigned int)&vars0, v10, v11, (int)v12);
  v5 = v15[19];
  Unwind_DebugHook();
  __asm { rdsspd  edx }
  if ( _EDX )
  {
    _EDX = v13;
    if ( v13 > 0xFF )
    {
      _ECX = 255;
      do
      {
        __asm { incsspd ecx }
        _EDX -= 255;
      }
      while ( _EDX > 0xFF );
    }
    __asm { incsspd edx }
  }
  *(int *)((char *)&vars0 + v6 + 4) = v5;
}
// 809EB20: variable 'v10' is possibly undefined
// 809EB20: variable 'v11' is possibly undefined
// 809EB36: variable 'v12' is possibly undefined
// 809EB88: variable 'v6' is possibly undefined
// 80CE000: using guessed type _TBYTE GLOBAL_OFFSET_TABLE_;

//----- (0809EBC0) --------------------------------------------------------
void __usercall __noreturn Unwind_Resume_or_Rethrow(int a1@<eax>, int a2@<edx>, struct timespec *a3)
{
  int v3; // eax
  int tv_nsec; // edi
  int v5; // ebx
  int v9; // [esp-Ch] [ebp-138h]
  int v10; // [esp-8h] [ebp-134h]
  int v11; // [esp-4h] [ebp-130h]
  unsigned int v12; // [esp+10h] [ebp-11Ch] BYREF
  char v13[128]; // [esp+14h] [ebp-118h] BYREF
  struct timespec v14[16]; // [esp+94h] [ebp-98h] BYREF
  int v15; // [esp+118h] [ebp-14h]
  int v16; // [esp+11Ch] [ebp-10h]
  int vars0; // [esp+12Ch] [ebp+0h] BYREF
  int retaddr; // [esp+130h] [ebp+4h]

  v16 = a2;
  v15 = a1;
  if ( a3[1].tv_nsec )
  {
    uw_init_context_1((int)v13, (int)&a3, retaddr);
    qmemcpy(v14, v13, sizeof(v14));
    if ( Unwind_ForcedUnwind_Phase2(a3, &v14[0].tv_sec, (int *)&v12) != 7 )
      Unwind_Resume_or_Rethrow_cold_17((int)&vars0, &v14[0].tv_sec, v14);
    v3 = uw_install_context_1((int)v13, (unsigned int)v14, (unsigned int)&vars0, v9, v10, v11);
    tv_nsec = v14[9].tv_nsec;
    v5 = v3;
    Unwind_DebugHook();
    __asm { rdsspd  eax }
    if ( _EAX )
    {
      _EAX = v12;
      if ( v12 > 0xFF )
      {
        _EDX = 255;
        do
        {
          __asm { incsspd edx }
          _EAX -= 255;
        }
        while ( _EAX > 0xFF );
      }
      __asm { incsspd eax }
    }
    *(int *)((char *)&vars0 + v5 + 4) = tv_nsec;
  }
  else
  {
    Unwind_RaiseException(0, a2, a3);
  }
}
// 809EC35: variable 'v9' is possibly undefined
// 809EC35: variable 'v10' is possibly undefined
// 809EC35: variable 'v11' is possibly undefined

//----- (0809ECD0) --------------------------------------------------------
int (__cdecl *__cdecl Unwind_DeleteException(int a1))(int, int)
{
  int (__cdecl *result)(int, int); // eax

  result = *(int (__cdecl **)(int, int))(a1 + 8);
  if ( result )
    return (int (__cdecl *)(int, int))result(1, a1);
  return result;
}

//----- (0809ED00) --------------------------------------------------------
int __cdecl Unwind_Backtrace(int (__cdecl *a1)(int *, int), int a2)
{
  int v2; // eax
  int v3; // edi
  int v5[32]; // [esp+0h] [ebp-158h] BYREF
  int v6[54]; // [esp+80h] [ebp-D8h] BYREF
  int retaddr; // [esp+15Ch] [ebp+4h]

  uw_init_context_1((int)v5, (int)&a1, retaddr);
  while ( 1 )
  {
    v2 = uw_frame_state_for(v5, v6);
    v3 = v2;
    if ( v2 )
    {
      if ( v2 != 5 )
        break;
    }
    if ( a1(v5, a2) )
      break;
    if ( v3 == 5 )
      return v3;
    uw_update_context((int)v5, (int)v6);
  }
  return 3;
}
// 809ED00: using guessed type _DWORD var_D8[54];
// 809ED00: using guessed type int var_158[32];

//----- (0809ED80) --------------------------------------------------------
int __cdecl fde_unencoded_compare(int a1, int a2, int a3)
{
  int result; // eax
  unsigned int v4; // edx

  result = 1;
  v4 = *(_DWORD *)(a3 + 8);
  if ( *(_DWORD *)(a2 + 8) <= v4 )
    return -(*(_DWORD *)(a2 + 8) < v4);
  return result;
}

//----- (0809EDA0) --------------------------------------------------------
int __usercall frame_downheap@<eax>(
        int result@<eax>,
        int (__cdecl *a2)(int, int, int)@<edx>,
        int a3@<ecx>,
        int a4,
        int a5)
{
  int v5; // edx
  int i; // ebx
  int v8; // eax
  int v9; // eax
  int v10; // esi
  int *v11; // ebx
  int *v12; // edi
  int v13; // [esp+4h] [ebp-28h]
  int *v15; // [esp+Ch] [ebp-20h]
  int v16; // [esp+30h] [ebp+4h]

  v5 = a4;
  v13 = result;
  for ( i = 2 * a4 + 1; a5 > i; *v12 = result )
  {
    v10 = i + 1;
    v12 = (int *)(a3 + 4 * i);
    v9 = *v12;
    if ( i + 1 < a5 )
    {
      v16 = v5;
      v15 = (int *)(a3 + 4 * i + 4);
      v8 = a2(v13, v9, *v15);
      v5 = v16;
      if ( v8 < 0 )
      {
        v9 = *v15;
        v12 = (int *)(a3 + 4 * i + 4);
      }
      else
      {
        v9 = *v12;
        v10 = i;
      }
    }
    else
    {
      v10 = i;
    }
    v11 = (int *)(a3 + 4 * v5);
    result = a2(v13, *v11, v9);
    if ( result >= 0 )
      break;
    result = *v11;
    *v11 = *v12;
    i = 2 * v10 + 1;
    v5 = v10;
  }
  return result;
}

//----- (0809EE60) --------------------------------------------------------
int __usercall frame_heapsort@<eax>(int a1@<eax>, int (__cdecl *a2)(int, int, int)@<edx>, int a3@<ecx>)
{
  int v4; // edi
  unsigned int v5; // ebx
  int result; // eax
  int v7; // esi
  int v8; // ebx
  int v9; // eax
  int v10; // [esp-10h] [ebp-3Ch]
  int v11; // [esp+4h] [ebp-28h]

  v4 = a3;
  v5 = *(_DWORD *)(a3 + 4);
  result = a3 + 8;
  v11 = a3 + 8;
  v7 = (v5 >> 1) - 1;
  if ( v5 >> 1 )
  {
    do
    {
      v10 = v7--;
      result = frame_downheap(a1, a2, v11, v10, v5);
    }
    while ( v7 != -1 );
    v4 = a3;
  }
  v8 = v5 - 1;
  if ( v8 > 0 )
  {
    do
    {
      v9 = *(_DWORD *)(v4 + 8);
      *(_DWORD *)(v4 + 8) = *(_DWORD *)(v4 + 4 * v8 + 8);
      *(_DWORD *)(v4 + 4 * v8 + 8) = v9;
      result = frame_downheap(a1, a2, v11, 0, v8--);
    }
    while ( v8 );
  }
  return result;
}

//----- (0809EF00) --------------------------------------------------------
int __usercall size_of_encoded_value@<eax>(char a1@<al>, int a2@<ebp>, int *a3@<edi>, const struct timespec *a4@<esi>)
{
  unsigned __int8 v4; // al

  if ( a1 == -1 )
    return 0;
  v4 = a1 & 7;
  if ( v4 == 2 )
    return 2;
  if ( v4 <= 2u )
  {
    if ( v4 )
LABEL_12:
      abort(a2, a3, a4);
    return 4;
  }
  if ( v4 == 3 )
    return 4;
  if ( v4 != 4 )
    goto LABEL_12;
  return 8;
}

//----- (0809EF60) --------------------------------------------------------
int __usercall base_from_object@<eax>(
        char a1@<al>,
        int a2@<edx>,
        int a3@<ebp>,
        int *a4@<edi>,
        const struct timespec *a5@<esi>)
{
  unsigned __int8 v5; // al

  if ( a1 == -1 )
    return 0;
  v5 = a1 & 0x70;
  if ( v5 == 32 )
    return *(_DWORD *)(a2 + 4);
  if ( v5 <= 0x20u )
  {
    if ( !v5 || v5 == 16 )
      return 0;
    goto LABEL_11;
  }
  if ( v5 != 48 )
  {
    if ( v5 == 80 )
      return 0;
LABEL_11:
    abort(a3, a4, a5);
  }
  return *(_DWORD *)(a2 + 8);
}

//----- (0809EFC0) --------------------------------------------------------
int __usercall base_from_cb_data@<eax>(
        char a1@<al>,
        int a2@<edx>,
        int a3@<ebp>,
        int *a4@<edi>,
        const struct timespec *a5@<esi>)
{
  unsigned __int8 v5; // al

  if ( a1 == -1 )
    return 0;
  v5 = a1 & 0x70;
  if ( v5 == 32 )
    return *(_DWORD *)(a2 + 4);
  if ( v5 <= 0x20u )
  {
    if ( !v5 || v5 == 16 )
      return 0;
    goto LABEL_11;
  }
  if ( v5 != 48 )
  {
    if ( v5 == 80 )
      return 0;
LABEL_11:
    abort(a3, a4, a5);
  }
  return *(_DWORD *)(a2 + 8);
}

//----- (0809F020) --------------------------------------------------------
_DWORD *__usercall read_encoded_value_with_base_0@<eax>(char a1@<al>, int a2@<ecx>, _DWORD *a3)
{
  _DWORD *v3; // esi

  if ( a1 != 80 )
  {
    if ( (a1 & 0xFu) <= 0xC )
      __asm { jmp     ecx }
    read_encoded_value_with_base_cold_8();
  }
  v3 = (_DWORD *)((a2 + 3) & 0xFFFFFFFC);
  *a3 = *v3;
  return v3 + 1;
}
// 8049464: using guessed type void __noreturn read_encoded_value_with_base_cold_8(void);

//----- (0809F170) --------------------------------------------------------
int __usercall fde_single_encoding_compare@<eax>(int a1@<ebp>, const struct timespec *a2@<esi>, int a3, int a4, int a5)
{
  char v5; // bl
  int result; // eax
  unsigned int v7; // [esp+8h] [ebp-14h] BYREF
  int v8[4]; // [esp+Ch] [ebp-10h] BYREF

  v5 = *(_WORD *)(a3 + 16) >> 3;
  base_from_object(v5, a3, a1, (int *)a3, a2);
  read_encoded_value_with_base_0(v5, a4 + 8, &v7);
  read_encoded_value_with_base_0(*(_WORD *)(a3 + 16) >> 3, a5 + 8, v8);
  result = 1;
  if ( v7 <= v8[0] )
    return -(v7 < v8[0]);
  return result;
}
// 809F170: using guessed type unsigned int var_10[4];

//----- (0809F1F0) --------------------------------------------------------
int __usercall get_cie_encoding@<eax>(int a1@<eax>)
{
  int v1; // edi
  int v3; // eax
  unsigned __int8 v4; // cl
  char *v5; // edx
  int result; // eax
  _DWORD *encoded_value_with_base_0; // eax
  char *v8; // ebx
  char v9; // dl
  int v10[4]; // [esp+0h] [ebp-10h] BYREF

  v1 = a1 + 9;
  v3 = strlen((unsigned int *)(a1 + 9));
  v4 = *(_BYTE *)(a1 + 8);
  v5 = (char *)(v1 + v3 + 1);
  if ( v4 > 3u )
  {
    result = 255;
    if ( *v5 != 4 || v5[1] )
      return result;
    v5 += 2;
  }
  if ( *(_BYTE *)(a1 + 9) != 122 )
    return 0;
  do
  {
    if ( *v5++ >= 0 )
      break;
    ++v5;
  }
  while ( *(v5 - 1) < 0 );
  while ( 1 )
  {
    encoded_value_with_base_0 = v5 + 1;
    if ( *v5 >= 0 )
      break;
    ++v5;
  }
  if ( v4 == 1 )
  {
    encoded_value_with_base_0 = v5 + 2;
  }
  else
  {
    do
      encoded_value_with_base_0 = (_DWORD *)((char *)encoded_value_with_base_0 + 1);
    while ( *((char *)encoded_value_with_base_0 - 1) < 0 );
  }
  v8 = (char *)(a1 + 10);
  do
    encoded_value_with_base_0 = (_DWORD *)((char *)encoded_value_with_base_0 + 1);
  while ( *((char *)encoded_value_with_base_0 - 1) < 0 );
  v9 = *(_BYTE *)(a1 + 10);
  if ( v9 != 82 )
  {
    do
    {
      while ( v9 == 80 )
      {
        ++v8;
        encoded_value_with_base_0 = read_encoded_value_with_base_0(
                                      *(_BYTE *)encoded_value_with_base_0 & 0x7F,
                                      (int)encoded_value_with_base_0 + 1,
                                      v10);
        v9 = *v8;
        if ( *v8 == 82 )
          return *(unsigned __int8 *)encoded_value_with_base_0;
      }
      if ( v9 != 76 )
        return 0;
      v9 = *++v8;
      encoded_value_with_base_0 = (_DWORD *)((char *)encoded_value_with_base_0 + 1);
    }
    while ( *v8 != 82 );
  }
  return *(unsigned __int8 *)encoded_value_with_base_0;
}
// 809F1F0: using guessed type int var_10[4];

//----- (0809F300) --------------------------------------------------------
_DWORD *__usercall linear_search_fdes@<eax>(int a1@<eax>, _DWORD *a2@<edx>, int a3@<ecx>, int *a4@<edi>)
{
  __int16 v7; // ax
  int cie_encoding; // esi
  int v9; // eax
  unsigned int v10; // edx
  int v11; // edx
  int *v12; // edi
  _DWORD *v13; // eax
  unsigned int v14; // eax
  int v15; // edx
  int *v17; // [esp+Ch] [ebp-40h]
  int v19; // [esp+28h] [ebp-24h] BYREF
  int v20[8]; // [esp+2Ch] [ebp-20h] BYREF

  v7 = *(_WORD *)(a1 + 16) >> 3;
  cie_encoding = (unsigned __int8)v7;
  v17 = 0;
  base_from_object(v7, a1, a1, a4, (const struct timespec *)(unsigned __int8)v7);
  for ( ; *a2; a2 = (_DWORD *)((char *)a2 + *a2 + 4) )
  {
    v11 = a2[1];
    if ( v11 )
    {
      if ( (*(_BYTE *)(a1 + 16) & 4) != 0 )
      {
        v12 = (_DWORD *)((char *)a2 - v11 + 4);
        if ( v12 != v17 )
        {
          cie_encoding = get_cie_encoding((int)a2 - v11 + 4);
          v17 = v12;
          base_from_object(cie_encoding, a1, a1, v12, (const struct timespec *)cie_encoding);
        }
      }
      if ( cie_encoding )
      {
        v13 = read_encoded_value_with_base_0(cie_encoding, (int)(a2 + 2), &v19);
        read_encoded_value_with_base_0(cie_encoding & 0xF, (int)v13, v20);
        v14 = size_of_encoded_value(
                cie_encoding,
                a1,
                (int *)(unsigned __int8)cie_encoding,
                (const struct timespec *)cie_encoding);
        v15 = -1;
        if ( v14 <= 3 )
          v15 = (1 << (8 * v14)) - 1;
        if ( (v15 & v19) != 0 && (unsigned int)(a3 - v19) < v20[0] )
          return a2;
      }
      else
      {
        v9 = a2[2];
        v10 = a2[3];
        v19 = v9;
        v20[0] = v10;
        if ( v9 && a3 - v9 < v10 )
          return a2;
      }
    }
  }
  return 0;
}
// 809F300: using guessed type unsigned int var_20[8];

//----- (0809F450) --------------------------------------------------------
int __cdecl Unwind_IteratePhdrCallback(int a1, unsigned int a2, int *a3)
{
  unsigned int v3; // edi
  int *v4; // eax
  int v5; // edx
  int *v6; // edx
  int *v7; // ebx
  int v8; // ecx
  unsigned int v9; // esi
  unsigned int v10; // ecx
  unsigned int v11; // ebx
  int v12; // ebx
  int *v13; // ebx
  int **v14; // eax
  int *v15; // edx
  unsigned int v16; // esi
  int *v17; // eax
  int v18; // edx
  char v19; // bl
  int *v20; // eax
  char v21; // bl
  int *v22; // edi
  unsigned int v23; // ecx
  int v24; // eax
  _DWORD *v25; // eax
  char cie_encoding; // bl
  unsigned int v28; // ebx
  unsigned int v29; // ecx
  _TBYTE *v30; // ecx
  _DWORD *v31; // ecx
  unsigned int v32; // esi
  unsigned int v33; // ebx
  unsigned int *v34; // ebx
  _DWORD *v35; // eax
  unsigned int v36; // eax
  unsigned int v37; // edx
  int v38; // ebx
  int *v39; // eax
  char v40; // di
  int v41; // eax
  int v42; // esi
  int v43; // eax
  int *v44; // [esp+0h] [ebp-5Ch]
  unsigned int v45; // [esp+0h] [ebp-5Ch]
  _DWORD *v46; // [esp+0h] [ebp-5Ch]
  _DWORD *v47; // [esp+0h] [ebp-5Ch]
  unsigned int v48; // [esp+4h] [ebp-58h]
  _DWORD *v49; // [esp+4h] [ebp-58h]
  unsigned int v50; // [esp+4h] [ebp-58h]
  int v51; // [esp+8h] [ebp-54h]
  unsigned int v52; // [esp+8h] [ebp-54h]
  int *v53; // [esp+Ch] [ebp-50h]
  unsigned int v54; // [esp+10h] [ebp-4Ch]
  int *v55; // [esp+14h] [ebp-48h]
  _DWORD *v56; // [esp+18h] [ebp-44h]
  int **v57; // [esp+1Ch] [ebp-40h]
  _DWORD *v58; // [esp+20h] [ebp-3Ch] BYREF
  int v59; // [esp+24h] [ebp-38h] BYREF
  int v60[13]; // [esp+28h] [ebp-34h] BYREF

  v3 = *(_DWORD *)a1;
  v4 = *(int **)(a1 + 8);
  v48 = *(_DWORD *)a1;
  if ( a3[5] && a2 > 0x1F )
  {
    v28 = *(_DWORD *)(a1 + 16);
    v29 = *(_DWORD *)(a1 + 20);
    v45 = *(_DWORD *)(a1 + 24);
    v52 = *(_DWORD *)(a1 + 28);
    v3 = v28 ^ *((_DWORD *)&GLOBAL_OFFSET_TABLE_ + 982);
    if ( *((_QWORD *)&GLOBAL_OFFSET_TABLE_ + 491) != __PAIR64__(v29, v28)
      || (v3 = *((_DWORD *)&GLOBAL_OFFSET_TABLE_ + 1762) ^ v45,
          *((_QWORD *)&GLOBAL_OFFSET_TABLE_ + 881) != __PAIR64__(v52, v45)) )
    {
      *((_DWORD *)&GLOBAL_OFFSET_TABLE_ + 982) = v28;
      *((_DWORD *)&GLOBAL_OFFSET_TABLE_ + 983) = v29;
      v30 = (_TBYTE *)((char *)&GLOBAL_OFFSET_TABLE_ + 7096);
      *((_DWORD *)&GLOBAL_OFFSET_TABLE_ + 1763) = v52;
      *((_DWORD *)&GLOBAL_OFFSET_TABLE_ + 1762) = v45;
      do
      {
        *((_DWORD *)v30 - 6) = 0;
        *((_DWORD *)v30 - 5) = 0;
        *((_DWORD *)v30 - 1) = v30;
        v30 = (_TBYTE *)((char *)v30 + 24);
      }
      while ( (_TBYTE *)((char *)&GLOBAL_OFFSET_TABLE_ + 7288) != v30 );
      *((_DWORD *)&GLOBAL_OFFSET_TABLE_ + 1764) = (char *)&GLOBAL_OFFSET_TABLE_ + 7072;
      *((_DWORD *)&GLOBAL_OFFSET_TABLE_ + 1815) = 0;
      v57 = 0;
      a3[5] = 0;
      v56 = 0;
      goto LABEL_5;
    }
    v3 = *((_DWORD *)&GLOBAL_OFFSET_TABLE_ + 1764);
    if ( !v3 )
    {
LABEL_4:
      v57 = 0;
      v56 = 0;
LABEL_5:
      v5 = *(unsigned __int16 *)(a1 + 12);
      if ( !(_WORD)v5 )
        return 0;
      v54 = 0;
      v6 = &v4[8 * v5];
      v53 = 0;
      v51 = 0;
      v55 = 0;
      v44 = 0;
      while ( 1 )
      {
        v8 = *v4;
        if ( *v4 != 1 )
          break;
        v3 = (unsigned int)a3;
        v9 = v4[2] + v48;
        v10 = *a3;
        if ( *a3 < v9 )
        {
LABEL_11:
          v4 += 8;
          if ( v4 == v6 )
            goto LABEL_21;
        }
        else
        {
          v11 = v54;
          v3 = v9 + v4[5];
          if ( v10 >= v3 )
            v9 = (unsigned int)v53;
          if ( v10 < v3 )
            v11 = v3;
          v53 = (int *)v9;
          v54 = v11;
          v12 = 1;
          if ( v10 >= v3 )
            v12 = v51;
          v4 += 8;
          v51 = v12;
          if ( v4 == v6 )
          {
LABEL_21:
            v13 = v44;
            if ( v51 )
            {
              if ( a2 > 0x1F )
              {
                v14 = (int **)*((_DWORD *)&GLOBAL_OFFSET_TABLE_ + 1764);
                if ( v57 && v56 )
                {
                  v15 = v57[5];
                  *((_DWORD *)&GLOBAL_OFFSET_TABLE_ + 1764) = v57;
                  v56[5] = v15;
                  v57[5] = (int *)v14;
                  v14 = v57;
                }
                v14[4] = v44;
                v14[2] = (int *)v48;
                v14[1] = (int *)v54;
                v14[3] = v55;
                v3 = (unsigned int)v53;
                *v14 = v53;
              }
              goto LABEL_27;
            }
            return 0;
          }
        }
      }
      if ( v8 == 1685382480 )
      {
        v55 = v4;
      }
      else
      {
        v7 = v44;
        if ( v8 == 2 )
          v7 = v4;
        v44 = v7;
      }
      goto LABEL_11;
    }
    v46 = (_DWORD *)*((_DWORD *)&GLOBAL_OFFSET_TABLE_ + 1764);
    v31 = v46;
    v56 = 0;
    v3 = *(_DWORD *)(v3 + 4);
    v32 = *a3;
    v33 = *v46;
    if ( (unsigned int)*a3 < *v46 )
    {
LABEL_52:
      while ( v3 | v33 )
      {
        v34 = (unsigned int *)v31[5];
        if ( !v34 )
          break;
        v56 = v31;
        v31 = (_DWORD *)v31[5];
        v33 = *v34;
        v3 = v31[1];
        if ( v32 >= v33 )
          goto LABEL_51;
      }
      v57 = (int **)v31;
      goto LABEL_5;
    }
LABEL_51:
    if ( v32 >= v3 )
      goto LABEL_52;
    v3 = *((_DWORD *)&GLOBAL_OFFSET_TABLE_ + 1764);
    v13 = (int *)v31[4];
    v48 = v31[2];
    v55 = (int *)v31[3];
    if ( v46 != v31 )
    {
      v43 = v31[5];
      *((_DWORD *)&GLOBAL_OFFSET_TABLE_ + 1764) = v31;
      v56[5] = v43;
      v31[5] = v46;
    }
LABEL_27:
    if ( !v55 )
      return 0;
    v16 = v55[2] + v48;
    if ( *(_BYTE *)v16 == 1 )
    {
      a3[2] = 0;
      if ( v13 )
      {
        v17 = (int *)(v13[2] + v48);
        v18 = *v17;
        if ( *v17 )
        {
          while ( v18 != 3 )
          {
            v17 += 2;
            v18 = *v17;
            if ( !*v17 )
              goto LABEL_35;
          }
          a3[2] = v17[1];
        }
      }
LABEL_35:
      v19 = *(_BYTE *)(v16 + 1);
      base_from_cb_data(v19, (int)a3, (int)&GLOBAL_OFFSET_TABLE_, (int *)v3, (const struct timespec *)v16);
      v20 = read_encoded_value_with_base_0(v19, v16 + 4, &v58);
      v21 = *(_BYTE *)(v16 + 2);
      v22 = v20;
      if ( v21 == -1 || *(_BYTE *)(v16 + 3) != 59 )
      {
        v23 = *a3;
LABEL_38:
        v60[0] = 0;
        v60[4] = 4;
        v24 = a3[1];
        v60[3] = (int)v58;
        v60[1] = v24;
        v60[2] = a3[2];
        v25 = linear_search_fdes((int)v60, v58, v23, v22);
        a3[4] = (int)v25;
        if ( v25 )
        {
          cie_encoding = get_cie_encoding((int)v25 - v25[1] + 4);
          base_from_cb_data(cie_encoding, (int)a3, (int)&GLOBAL_OFFSET_TABLE_, v22, (const struct timespec *)v16);
          read_encoded_value_with_base_0(cie_encoding, a3[4] + 8, &v59);
          a3[3] = v59;
        }
        return 1;
      }
      base_from_cb_data(*(_BYTE *)(v16 + 2), (int)a3, (int)&GLOBAL_OFFSET_TABLE_, v20, (const struct timespec *)v16);
      v35 = read_encoded_value_with_base_0(v21, (int)v22, &v59);
      v47 = v35;
      if ( v59 )
      {
        v23 = *a3;
        v22 = (int *)((unsigned __int8)v35 & 3);
        if ( ((unsigned __int8)v35 & 3) == 0 )
        {
          if ( v16 + *v35 <= v23 )
          {
            v49 = &v35[2 * v59 - 2];
            if ( v16 + *v49 > v23 )
            {
              v50 = v59 - 1;
              do
              {
                if ( (unsigned int)v22 >= v50 )
LABEL_67:
                  abort((int)&GLOBAL_OFFSET_TABLE_, v22, (const struct timespec *)v16);
                v36 = ((unsigned int)v22 + v50) >> 1;
                if ( v16 + v47[2 * v36] > v23 )
                {
                  if ( (unsigned int)v22 >= v36 )
                    goto LABEL_67;
                  while ( 1 )
                  {
                    v37 = ((unsigned int)v22 + v36) >> 1;
                    if ( v16 + v47[2 * v37] <= v23 )
                      break;
                    v36 = ((unsigned int)v22 + v36) >> 1;
                    if ( (unsigned int)v22 >= v37 )
                      goto LABEL_67;
                  }
                  v50 = v36;
                  v36 = ((unsigned int)v22 + v36) >> 1;
                }
                v22 = (int *)(v36 + 1);
              }
              while ( v16 + v47[2 * v36 + 2] <= v23 );
              v49 = &v47[2 * v36];
            }
            v38 = v16 + v49[1];
            v39 = (int *)get_cie_encoding(v38 + 4 - *(_DWORD *)(v38 + 4));
            v40 = (char)v39;
            v41 = size_of_encoded_value((char)v39, (int)v49, v39, (const struct timespec *)v16);
            read_encoded_value_with_base_0(v40 & 0xF, v38 + v41 + 8, v60);
            v42 = *v49 + v16;
            if ( *a3 < (unsigned int)(v42 + v60[0]) )
              a3[4] = v38;
            a3[3] = v42;
          }
          return 1;
        }
        goto LABEL_38;
      }
    }
    return 1;
  }
  if ( a2 > 0xD )
    goto LABEL_4;
  return -1;
}
// 80CE000: using guessed type _TBYTE GLOBAL_OFFSET_TABLE_;

//----- (0809F990) --------------------------------------------------------
int __cdecl fde_mixed_encoding_compare(int a1, const struct timespec *a2, int a3)
{
  unsigned __int8 cie_encoding; // al
  int *v5; // edi
  unsigned __int8 v6; // si
  int result; // eax
  unsigned int v8; // [esp+8h] [ebp-24h] BYREF
  int v9[8]; // [esp+Ch] [ebp-20h] BYREF

  cie_encoding = get_cie_encoding((int)&a2->tv_nsec - a2->tv_nsec);
  v5 = (int *)cie_encoding;
  base_from_object(cie_encoding, a1, a1, (int *)cie_encoding, a2);
  read_encoded_value_with_base_0((char)v5, (int)&a2[1], &v8);
  v6 = get_cie_encoding(a3 + 4 - *(_DWORD *)(a3 + 4));
  base_from_object(v6, a1, a1, v5, (const struct timespec *)v6);
  read_encoded_value_with_base_0(v6, a3 + 8, v9);
  result = 1;
  if ( v8 <= v9[0] )
    return -(v8 < v9[0]);
  return result;
}
// 809F990: using guessed type unsigned int var_20[8];

//----- (0809FA20) --------------------------------------------------------
int __usercall classify_object_over_fdes@<eax>(int a1@<eax>, _DWORD *a2@<edx>)
{
  _DWORD *v3; // ebx
  const struct timespec *v4; // ecx
  int v5; // eax
  int *v6; // edi
  const struct timespec *v7; // esi
  unsigned __int16 v8; // ax
  unsigned int v9; // eax
  int v10; // edx
  int cie_encoding; // [esp+0h] [ebp-3Ch]
  int v13; // [esp+Ch] [ebp-30h]
  int v14[8]; // [esp+1Ch] [ebp-20h] BYREF

  v13 = *a2;
  if ( !*a2 )
    return v13;
  v3 = a2;
  v4 = 0;
  LOBYTE(cie_encoding) = 0;
  v13 = 0;
  while ( 1 )
  {
    v5 = v3[1];
    if ( v5 )
      break;
LABEL_15:
    v3 = (_DWORD *)((char *)v3 + *v3 + 4);
    if ( !*v3 )
      return v13;
  }
  v6 = (int *)(unsigned __int8)cie_encoding;
  v7 = (const struct timespec *)((char *)v3 - v5 + 4);
  if ( v7 == v4 )
  {
LABEL_9:
    read_encoded_value_with_base_0((char)v6, (int)(v3 + 2), v14);
    v9 = size_of_encoded_value((char)v6, a1, v6, v7);
    v10 = -1;
    if ( v9 <= 3 )
      v10 = (1 << (8 * v9)) - 1;
    v4 = v7;
    if ( (v10 & v14[0]) != 0 )
    {
      ++v13;
      if ( *(_DWORD *)a1 > v14[0] )
        *(_DWORD *)a1 = v14[0];
      v4 = v7;
    }
    goto LABEL_15;
  }
  cie_encoding = get_cie_encoding((int)v3 - v5 + 4);
  if ( cie_encoding != 255 )
  {
    v6 = (int *)(unsigned __int8)cie_encoding;
    base_from_object(cie_encoding, a1, a1, (int *)(unsigned __int8)cie_encoding, v7);
    v8 = *(_WORD *)(a1 + 16);
    if ( (v8 & 0x7F8) == 2040 )
    {
      *(_WORD *)(a1 + 16) = (8 * (unsigned __int8)cie_encoding) | v8 & 0xF807;
    }
    else if ( (unsigned __int8)(v8 >> 3) != cie_encoding )
    {
      *(_BYTE *)(a1 + 16) |= 4u;
    }
    goto LABEL_9;
  }
  return -1;
}
// 809FA20: using guessed type unsigned int var_20[8];

//----- (0809FB70) --------------------------------------------------------
int __usercall add_fdes@<eax>(int a1@<eax>, int *a2@<edx>, int *a3@<ecx>, int a4@<ebp>)
{
  __int16 v6; // ax
  int cie_encoding; // esi
  int result; // eax
  int v9; // eax
  int v10; // edx
  int v11; // edx
  char *v12; // ebp
  unsigned int v13; // eax
  int v14; // edx
  char *v15; // [esp+0h] [ebp-3Ch]
  int v17[8]; // [esp+1Ch] [ebp-20h] BYREF

  v6 = *(_WORD *)(a1 + 16) >> 3;
  cie_encoding = (unsigned __int8)v6;
  result = base_from_object(v6, a1, a4, (int *)a1, (const struct timespec *)(unsigned __int8)v6);
  if ( *a3 )
  {
    v15 = 0;
    while ( 1 )
    {
      v11 = a3[1];
      if ( !v11 )
        goto LABEL_6;
      if ( (*(_BYTE *)(a1 + 16) & 4) != 0 )
      {
        v12 = (char *)a3 - v11 + 4;
        if ( v12 != v15 )
        {
          cie_encoding = get_cie_encoding((int)a3 - v11 + 4);
          v15 = v12;
          base_from_object(cie_encoding, a1, (int)v12, (int *)a1, (const struct timespec *)cie_encoding);
        }
      }
      if ( cie_encoding )
      {
        read_encoded_value_with_base_0(cie_encoding, (int)(a3 + 2), v17);
        v13 = size_of_encoded_value(
                cie_encoding,
                (unsigned __int8)cie_encoding,
                (int *)a1,
                (const struct timespec *)cie_encoding);
        v14 = -1;
        if ( v13 <= 3 )
          v14 = (1 << (8 * v13)) - 1;
        if ( (v14 & v17[0]) != 0 )
        {
LABEL_4:
          v9 = *a2;
          if ( *a2 )
          {
            v10 = *(_DWORD *)(v9 + 4);
            *(_DWORD *)(v9 + 4) = v10 + 1;
            *(_DWORD *)(v9 + 4 * v10 + 8) = a3;
          }
          goto LABEL_6;
        }
        a3 = (int *)((char *)a3 + *a3 + 4);
        result = *a3;
        if ( !*a3 )
          return result;
      }
      else
      {
        if ( a3[2] )
          goto LABEL_4;
LABEL_6:
        a3 = (int *)((char *)a3 + *a3 + 4);
        result = *a3;
        if ( !*a3 )
          return result;
      }
    }
  }
  return result;
}
// 809FB70: using guessed type int var_20[8];

//----- (0809FC80) --------------------------------------------------------
int *__usercall search_object@<eax>(int a1@<eax>, int *a2@<edx>, const struct timespec *a3@<esi>)
{
  int v3; // ebp
  int *v4; // edi
  char v5; // al
  int *v6; // edi
  unsigned __int16 v7; // ax
  unsigned int v8; // ecx
  unsigned int v9; // edx
  int v10; // ebx
  unsigned int v11; // esi
  int v12; // edi
  int *result; // eax
  int v14; // esi
  _DWORD **v15; // ebx
  _DWORD *v16; // edx
  int v17; // eax
  unsigned int v18; // eax
  unsigned int v19; // esi
  int *v20; // edi
  unsigned __int8 cie_encoding; // bp
  _DWORD *v22; // eax
  _DWORD *i; // edx
  char v24; // bl
  unsigned int v25; // ebp
  unsigned int v26; // edi
  unsigned int v27; // esi
  _DWORD *v28; // eax
  const struct timespec *v29; // esi
  int *v30; // eax
  int *v31; // eax
  int **v32; // ebx
  int *v33; // ecx
  int (__cdecl *v34)(int, int, int); // edx
  int v35; // eax
  int v36; // ebx
  _TBYTE *v37; // ebp
  char *v38; // eax
  int v39; // ebx
  int v40; // edx
  int v41; // eax
  int v42; // ecx
  int v43; // ecx
  int v44; // eax
  int *v45; // ebp
  int v46; // edi
  int *v47; // ebx
  int v48; // esi
  int v49; // edi
  int v50; // ebx
  int v51; // eax
  int v52; // esi
  int *v53; // eax
  unsigned int v54; // [esp+0h] [ebp-54h]
  char v55; // [esp+0h] [ebp-54h]
  int (__cdecl *v56)(int, int, int); // [esp+0h] [ebp-54h]
  int v58; // [esp+8h] [ebp-4Ch]
  int v59; // [esp+8h] [ebp-4Ch]
  int v60; // [esp+8h] [ebp-4Ch]
  unsigned int v61; // [esp+Ch] [ebp-48h]
  char v62; // [esp+Ch] [ebp-48h]
  int v63; // [esp+Ch] [ebp-48h]
  int v64; // [esp+Ch] [ebp-48h]
  char *v65; // [esp+10h] [ebp-44h]
  int v66; // [esp+10h] [ebp-44h]
  int v67; // [esp+18h] [ebp-3Ch]
  int v68; // [esp+18h] [ebp-3Ch]
  int v69; // [esp+18h] [ebp-3Ch]
  int v70; // [esp+1Ch] [ebp-38h]
  int *v71; // [esp+20h] [ebp-34h]
  int v72; // [esp+24h] [ebp-30h]
  unsigned int v73; // [esp+2Ch] [ebp-28h] BYREF
  int *v74; // [esp+30h] [ebp-24h] BYREF
  int *v75; // [esp+34h] [ebp-20h]
  const struct timespec *v76; // [esp+48h] [ebp-Ch]

  v3 = a1;
  v4 = (int *)&GLOBAL_OFFSET_TABLE_;
  v76 = a3;
  v5 = *(_BYTE *)(a1 + 16);
  if ( (v5 & 1) != 0 )
    goto LABEL_2;
  v14 = *(_DWORD *)(v3 + 16) >> 11;
  v67 = v14;
  if ( !v14 )
  {
    v15 = *(_DWORD ***)(v3 + 12);
    if ( (v5 & 2) != 0 )
    {
      v16 = *v15;
      if ( !*v15 )
        goto LABEL_32;
      do
      {
        v17 = classify_object_over_fdes(v3, v16);
        if ( v17 == -1 )
          goto LABEL_18;
        v16 = *++v15;
        v14 += v17;
      }
      while ( *v15 );
      v67 = v14;
    }
    else
    {
      v67 = classify_object_over_fdes(v3, *(_DWORD **)(v3 + 12));
      if ( v67 == -1 )
      {
LABEL_18:
        *(_DWORD *)(v3 + 16) = 2040;
        *(_DWORD *)(v3 + 12) = (char *)&GLOBAL_OFFSET_TABLE_ - 80984;
        goto LABEL_32;
      }
    }
    if ( (v67 & 0xFFE00000) != 0 )
      *(_DWORD *)(v3 + 16) &= 0x7FFu;
    else
      *(_DWORD *)(v3 + 16) = (v67 << 11) | *(_DWORD *)(v3 + 16) & 0x7FF;
    if ( !v67 )
      goto LABEL_32;
  }
  v29 = (const struct timespec *)(4 * v67 + 8);
  v4 = (int *)&GLOBAL_OFFSET_TABLE_;
  v30 = malloc(v29);
  v74 = v30;
  if ( !v30 )
    goto LABEL_32;
  v30[1] = 0;
  v31 = malloc(v29);
  v75 = v31;
  if ( v31 )
    v31[1] = 0;
  v32 = *(int ***)(v3 + 12);
  if ( (*(_BYTE *)(v3 + 16) & 2) != 0 )
  {
    v33 = *v32;
    if ( !*v32 )
      goto LABEL_98;
    v29 = (const struct timespec *)&v74;
    do
    {
      ++v32;
      add_fdes(v3, (int *)&v74, v33, v3);
      v33 = *v32;
    }
    while ( *v32 );
  }
  else
  {
    add_fdes(v3, (int *)&v74, *(int **)(v3 + 12), v3);
  }
  v4 = v74;
  v71 = v74;
  if ( v74 && v74[1] != v67 )
    goto LABEL_98;
  v56 = (int (__cdecl *)(int, int, int))((char *)&GLOBAL_OFFSET_TABLE_ - 190064);
  if ( (*(_BYTE *)(v3 + 16) & 4) == 0 )
  {
    v34 = (int (__cdecl *)(int, int, int))((char *)&GLOBAL_OFFSET_TABLE_ - 192144);
    if ( (*(_WORD *)(v3 + 16) & 0x7F8) == 0 )
      v34 = (int (__cdecl *)(int, int, int))((char *)&GLOBAL_OFFSET_TABLE_ - 193152);
    v56 = v34;
  }
  v59 = (int)v75;
  if ( !v75 )
  {
    frame_heapsort(v3, v56, (int)v74);
    goto LABEL_88;
  }
  v35 = v74[1];
  v72 = v35;
  if ( v35 )
  {
    v63 = v3;
    v36 = 8;
    v70 = 4 * v35 + 4;
    v65 = (char *)(v74 + 2);
    v37 = &GLOBAL_OFFSET_TABLE_ + 704;
LABEL_63:
    while ( 1 )
    {
      *(_DWORD *)(v59 + v36) = v37;
      v37 = (_TBYTE *)&v4[v36 / 4u];
      if ( v70 == v36 )
        break;
      while ( v37 != &GLOBAL_OFFSET_TABLE_ + 704 )
      {
        if ( v56(v63, v4[v36 / 4u + 1], *(_DWORD *)v37) >= 0 )
        {
          v36 += 4;
          goto LABEL_63;
        }
        v38 = (char *)(v59 + (char *)v37 - v65);
        v37 = (_TBYTE *)*((_DWORD *)v38 + 2);
        *((_DWORD *)v38 + 2) = 0;
      }
      v37 = &GLOBAL_OFFSET_TABLE_ + 704;
      v36 += 4;
    }
    v39 = 0;
    v40 = 0;
    v41 = 0;
    v29 = (const struct timespec *)v59;
    do
    {
      v42 = v4[v41 + 2];
      if ( *(_DWORD *)(v59 + 4 * v41 + 8) )
        v4[v40++ + 2] = v42;
      else
        *(_DWORD *)(v59 + 4 * v39++ + 8) = v42;
      ++v41;
    }
    while ( v72 != v41 );
    v3 = v63;
    v43 = (int)v75;
    v4 = v74;
  }
  else
  {
    v43 = (int)v75;
    v39 = 0;
    v40 = 0;
  }
  v71[1] = v40;
  *(_DWORD *)(v59 + 4) = v39;
  if ( v4[1] + *(_DWORD *)(v43 + 4) != v67 )
LABEL_98:
    abort(v3, v4, v29);
  frame_heapsort(v3, v56, v43);
  v69 = (int)v75;
  v44 = v75[1];
  if ( !v44 )
    goto LABEL_87;
  v64 = v3;
  v45 = v74;
  v46 = v74[1];
  while ( 1 )
  {
    v66 = v44 - 1;
    v47 = (int *)(v69 + 4 * v44);
    v60 = v47[1];
    if ( !v46 )
      break;
    v48 = v46;
    v49 = v44 + v46 - 1;
    do
    {
      v50 = v48 - 1;
      if ( v56(v64, v45[v48 + 1], v60) <= 0 )
      {
        v51 = v49;
        v46 = v48;
        v52 = v51;
        goto LABEL_83;
      }
      --v48;
      v45[v49-- + 2] = v45[v50 + 2];
    }
    while ( v50 );
    v46 = 0;
    v52 = v66;
LABEL_83:
    v45[v52 + 2] = v60;
    if ( !v66 )
      goto LABEL_86;
    v44 = v66;
  }
  v45[v44 + 1] = v60;
  if ( v44 != 1 )
  {
    v52 = v44 - 2;
    v66 = v44 - 2;
    v60 = *v47;
    goto LABEL_83;
  }
LABEL_86:
  v4 = v45;
  v3 = v64;
  v4[1] += *(_DWORD *)(v69 + 4);
  v69 = (int)v75;
LABEL_87:
  free(v3, v4, v69);
LABEL_88:
  v53 = v74;
  *v74 = *(_DWORD *)(v3 + 12);
  *(_DWORD *)(v3 + 12) = v53;
  *(_BYTE *)(v3 + 16) |= 1u;
LABEL_32:
  if ( *(_DWORD *)v3 > (unsigned int)a2 )
    return 0;
  v5 = *(_BYTE *)(v3 + 16);
  a3 = *(const struct timespec **)(v3 + 12);
  if ( (v5 & 1) == 0 )
  {
    if ( (v5 & 2) == 0 )
      return linear_search_fdes(v3, *(_DWORD **)(v3 + 12), (int)a2, v4);
    for ( i = (_DWORD *)a3->tv_sec; a3->tv_sec; i = (_DWORD *)a3->tv_sec )
    {
      result = linear_search_fdes(v3, i, (int)a2, a2);
      if ( result )
        return result;
      a3 = (const struct timespec *)((char *)a3 + 4);
    }
    return 0;
  }
LABEL_2:
  v58 = *(_DWORD *)(v3 + 12);
  v6 = *(int **)(v58 + 4);
  v54 = (unsigned int)v6;
  if ( (v5 & 4) == 0 )
  {
    v7 = *(_WORD *)(v3 + 16);
    v8 = 0;
    if ( (v7 & 0x7F8) != 0 )
    {
      v24 = v7 >> 3;
      v62 = v24;
      base_from_object(v24, v3, v3, v6, a3);
      if ( v6 )
      {
        v25 = (unsigned int)v6;
        v55 = v24 & 0xF;
        v26 = 0;
        do
        {
          v27 = (v25 + v26) >> 1;
          v10 = *(_DWORD *)(v58 + 4 * v27 + 8);
          v28 = read_encoded_value_with_base_0(v62, v10 + 8, &v73);
          read_encoded_value_with_base_0(v55, (int)v28, &v74);
          if ( v73 <= (unsigned int)a2 )
          {
            if ( (int *)((char *)v74 + v73) > a2 )
              return (int *)v10;
            v26 = v27 + 1;
          }
          else
          {
            v25 = (v25 + v26) >> 1;
          }
        }
        while ( v26 < v25 );
      }
    }
    else
    {
      while ( v8 < v54 )
      {
        v9 = (v8 + v54) >> 1;
        v10 = *(_DWORD *)(v58 + 4 * v9 + 8);
        v11 = *(_DWORD *)(v10 + 8);
        v12 = *(_DWORD *)(v10 + 12);
        if ( (unsigned int)a2 < v11 )
        {
          while ( v9 > v8 )
          {
            v18 = (v9 + v8) >> 1;
            v10 = *(_DWORD *)(v58 + 4 * v18 + 8);
            v11 = *(_DWORD *)(v10 + 8);
            v12 = *(_DWORD *)(v10 + 12);
            if ( (unsigned int)a2 >= v11 )
              goto LABEL_19;
            v9 = (v9 + v8) >> 1;
          }
          return 0;
        }
        v18 = (v8 + v54) >> 1;
        v9 = v54;
LABEL_19:
        if ( (unsigned int)a2 < v12 + v11 )
          return (int *)v10;
        v8 = v18 + 1;
        v54 = v9;
      }
    }
    return 0;
  }
  if ( !v6 )
    return 0;
  v61 = 0;
  v68 = v3;
  while ( 2 )
  {
    v19 = (v61 + v54) >> 1;
    v20 = *(int **)(v58 + 4 * v19 + 8);
    cie_encoding = get_cie_encoding((int)v20 - v20[1] + 4);
    base_from_object(cie_encoding, v68, cie_encoding, v20, (const struct timespec *)v19);
    v22 = read_encoded_value_with_base_0(cie_encoding, (int)(v20 + 2), &v73);
    read_encoded_value_with_base_0(cie_encoding & 0xF, (int)v22, &v74);
    if ( v73 > (unsigned int)a2 )
    {
      v54 = (v61 + v54) >> 1;
LABEL_25:
      if ( v61 >= v54 )
        return 0;
      continue;
    }
    break;
  }
  if ( (int *)((char *)v74 + v73) <= a2 )
  {
    v61 = v19 + 1;
    goto LABEL_25;
  }
  return v20;
}
// 80CE000: using guessed type _TBYTE GLOBAL_OFFSET_TABLE_;

//----- (080A0350) --------------------------------------------------------
int __usercall _register_frame_info_bases_part_5@<eax>(int a1@<eax>, _DWORD *a2@<edx>, int a3@<ecx>, int a4)
{
  int v4; // eax
  int result; // eax

  *a2 = -1;
  a2[1] = a3;
  a2[3] = a1;
  a2[2] = a4;
  a2[4] = 2040;
  v4 = unseen_objects;
  unseen_objects = (int)a2;
  a2[5] = v4;
  result = any_objects_registered;
  if ( !any_objects_registered )
    any_objects_registered = 1;
  return result;
}
// 80CFC78: using guessed type int any_objects_registered;
// 80CFC80: using guessed type int unseen_objects;

//----- (080A03E0) --------------------------------------------------------
_DWORD *__cdecl _register_frame_info_bases(_DWORD *a1, _DWORD *a2, int a3, int a4)
{
  _DWORD *result; // eax

  result = a1;
  if ( a1 )
  {
    if ( *a1 )
      return (_DWORD *)_register_frame_info_bases_part_5((int)a1, a2, a3, a4);
  }
  return result;
}

//----- (080A0420) --------------------------------------------------------
_DWORD *__cdecl _register_frame_info(_DWORD *a1, _DWORD *a2)
{
  _DWORD *result; // eax

  result = a1;
  if ( a1 )
  {
    if ( *a1 )
      return (_DWORD *)_register_frame_info_bases_part_5((int)a1, a2, 0, 0);
  }
  return result;
}

//----- (080A0450) --------------------------------------------------------
int __cdecl _register_frame(int *a1)
{
  int result; // eax
  int *v2; // eax

  result = *a1;
  if ( *a1 )
  {
    v2 = malloc((const struct timespec *)0x18);
    return _register_frame_info_bases_part_5((int)a1, v2, 0, 0);
  }
  return result;
}

//----- (080A04A0) --------------------------------------------------------
int __cdecl _register_frame_info_table_bases(int a1, _DWORD *a2, int a3, int a4)
{
  int v4; // eax
  int result; // eax

  *a2 = -1;
  a2[1] = a3;
  a2[4] = 2042;
  a2[2] = a4;
  a2[3] = a1;
  v4 = unseen_objects;
  unseen_objects = (int)a2;
  a2[5] = v4;
  result = any_objects_registered;
  if ( !any_objects_registered )
    any_objects_registered = 1;
  return result;
}
// 80CFC78: using guessed type int any_objects_registered;
// 80CFC80: using guessed type int unseen_objects;

//----- (080A0540) --------------------------------------------------------
int __cdecl _register_frame_info_table(int a1, _DWORD *a2)
{
  return _register_frame_info_table_bases(a1, a2, 0, 0);
}

//----- (080A0560) --------------------------------------------------------
int __cdecl _register_frame_table(int a1)
{
  int *v1; // eax

  v1 = malloc((const struct timespec *)0x18);
  return _register_frame_info_table_bases(a1, v1, 0, 0);
}

//----- (080A0590) --------------------------------------------------------
int __cdecl _deregister_frame_info_bases(int *a1)
{
  int v1; // eax
  int *v2; // edx
  int *v3; // eax
  int v5; // esi
  int *v6; // eax

  if ( !a1 || !*a1 )
    return 0;
  v1 = unseen_objects;
  if ( unseen_objects )
  {
    if ( a1 == *(int **)(unseen_objects + 12) )
    {
      v5 = unseen_objects;
      v6 = &unseen_objects;
    }
    else
    {
      while ( 1 )
      {
        v5 = *(_DWORD *)(v1 + 20);
        if ( !v5 )
          goto LABEL_9;
        if ( a1 == *(int **)(v5 + 12) )
          break;
        v1 = *(_DWORD *)(v1 + 20);
      }
      v6 = (int *)(v1 + 20);
    }
    *v6 = *(_DWORD *)(v5 + 20);
    return v5;
  }
LABEL_9:
  v5 = seen_objects;
  if ( !seen_objects )
LABEL_20:
    abort(0, a1, (const struct timespec *)v5);
  v2 = &seen_objects;
  while ( 1 )
  {
    v3 = *(int **)(v5 + 12);
    if ( (*(_BYTE *)(v5 + 16) & 1) != 0 )
      break;
    if ( a1 == v3 )
    {
      *v2 = *(_DWORD *)(v5 + 20);
      return v5;
    }
LABEL_12:
    v2 = (int *)(v5 + 20);
    v5 = *(_DWORD *)(v5 + 20);
    if ( !v5 )
      goto LABEL_20;
  }
  if ( a1 != (int *)*v3 )
    goto LABEL_12;
  *v2 = *(_DWORD *)(v5 + 20);
  free(0, a1, (int)v3);
  return v5;
}
// 80CFC7C: using guessed type int seen_objects;
// 80CFC80: using guessed type int unseen_objects;

//----- (080A06B0) --------------------------------------------------------
int __cdecl _deregister_frame_info(int *a1)
{
  return _deregister_frame_info_bases(a1);
}

//----- (080A06C0) --------------------------------------------------------
int *__usercall _deregister_frame@<eax>(int a1@<ebp>, int *a2@<edi>, int *a3)
{
  int *result; // eax
  int v4; // eax

  result = a3;
  if ( *a3 )
  {
    v4 = _deregister_frame_info_bases(a3);
    return free(a1, a2, v4);
  }
  return result;
}

//----- (080A0710) --------------------------------------------------------
int *__cdecl Unwind_Find_FDE(int *a1, _DWORD *a2)
{
  int *v2; // edi
  int v4; // esi
  __int16 v5; // bx
  int *v6; // eax
  _DWORD *v7; // edx
  int *v8; // edi
  int *v9; // [esp+10h] [ebp-34h] BYREF
  int v10; // [esp+14h] [ebp-30h]
  int v11; // [esp+18h] [ebp-2Ch]
  int v12; // [esp+1Ch] [ebp-28h]
  int *v13; // [esp+20h] [ebp-24h]
  int v14; // [esp+24h] [ebp-20h]

  if ( !any_objects_registered )
  {
LABEL_2:
    v9 = a1;
    v10 = 0;
    v11 = 0;
    v12 = 0;
    v13 = 0;
    v14 = 1;
    if ( dl_iterate_phdr((int (__cdecl *)(int *, int, int))Unwind_IteratePhdrCallback, (int)&v9) < 0 )
      return 0;
    v2 = v13;
    if ( v13 )
    {
      *a2 = v10;
      a2[1] = v11;
      a2[2] = v12;
    }
    return v2;
  }
  v4 = seen_objects;
  if ( !seen_objects )
    goto LABEL_14;
  while ( (unsigned int)a1 < *(_DWORD *)v4 )
  {
    v4 = *(_DWORD *)(v4 + 20);
    if ( !v4 )
      goto LABEL_14;
  }
  v2 = search_object(v4, a1, (const struct timespec *)v4);
  if ( !v2 )
  {
LABEL_14:
    while ( 1 )
    {
      v4 = unseen_objects;
      if ( !unseen_objects )
        goto LABEL_2;
      unseen_objects = *(_DWORD *)(unseen_objects + 20);
      v6 = search_object(v4, a1, (const struct timespec *)v4);
      v7 = (_DWORD *)seen_objects;
      if ( seen_objects && *(_DWORD *)seen_objects >= *(_DWORD *)v4 )
      {
        do
        {
          v8 = v7 + 5;
          v7 = (_DWORD *)v7[5];
        }
        while ( v7 && *v7 >= *(_DWORD *)v4 );
      }
      else
      {
        v8 = &seen_objects;
      }
      *(_DWORD *)(v4 + 20) = v7;
      *v8 = v4;
      if ( v6 )
      {
        v2 = v6;
        break;
      }
    }
  }
  *a2 = *(_DWORD *)(v4 + 4);
  a2[1] = *(_DWORD *)(v4 + 8);
  if ( (*(_BYTE *)(v4 + 16) & 4) != 0 )
    LOBYTE(v5) = get_cie_encoding((int)v2 - v2[1] + 4);
  else
    v5 = *(_WORD *)(v4 + 16) >> 3;
  base_from_object(v5, v4, (int)a1, v2, (const struct timespec *)v4);
  read_encoded_value_with_base_0(v5, (int)(v2 + 2), &v9);
  a2[2] = v9;
  return v2;
}
// 80A0804: conditional instruction was optimized away because %var_44.4==0
// 80A08F6: conditional instruction was optimized away because %var_44.4==0
// 80CFC78: using guessed type int any_objects_registered;
// 80CFC7C: using guessed type int seen_objects;
// 80CFC80: using guessed type int unseen_objects;

//----- (080A0930) --------------------------------------------------------
int __usercall base_of_encoded_value_0@<eax>(
        char a1@<al>,
        int a2@<edx>,
        int a3@<ebp>,
        int *a4@<edi>,
        const struct timespec *a5@<esi>)
{
  unsigned __int8 v5; // al

  if ( a1 == -1 )
    return 0;
  v5 = a1 & 0x70;
  if ( v5 == 32 )
    return Unwind_GetTextRelBase(a2);
  if ( v5 <= 0x20u )
  {
    if ( v5 && v5 != 16 )
LABEL_14:
      abort(a3, a4, a5);
    return 0;
  }
  if ( v5 == 64 )
    return Unwind_GetRegionStart(a2);
  if ( v5 == 80 )
    return 0;
  if ( v5 != 48 )
    goto LABEL_14;
  return Unwind_GetDataRelBase(a2);
}

//----- (080A09B0) --------------------------------------------------------
_DWORD *__usercall read_encoded_value_with_base_1@<eax>(char a1@<al>, int a2@<ecx>, _DWORD *a3)
{
  _DWORD *v3; // esi

  if ( a1 != 80 )
  {
    if ( (a1 & 0xFu) <= 0xC )
      __asm { jmp     ecx }
    read_encoded_value_with_base_cold_0();
  }
  v3 = (_DWORD *)((a2 + 3) & 0xFFFFFFFC);
  *a3 = *v3;
  return v3 + 1;
}
// 8049469: using guessed type void __noreturn read_encoded_value_with_base_cold_0(void);

//----- (080A0B00) --------------------------------------------------------
int __usercall _gcc_personality_v0@<eax>(int a1@<ebp>, int a2, char a3, int a4, int a5, int a6, int a7)
{
  int result; // eax
  _BYTE *LanguageSpecificData; // esi
  int RegionStart; // eax
  char *v10; // ebx
  const struct timespec *v11; // esi
  char *v12; // edx
  int v13; // esi
  int v14; // ecx
  int v15; // eax
  const struct timespec *v16; // esi
  int v17; // ebx
  int v18; // ecx
  int v19; // eax
  int IPInfo; // eax
  int *v21; // edi
  char v22; // bl
  const struct timespec *v23; // eax
  char v24; // bl
  int v25; // esi
  const struct timespec *v26; // eax
  char v27; // bl
  int v28; // esi
  const struct timespec *v29; // esi
  unsigned int v30; // [esp+14h] [ebp-44h] BYREF
  int v31; // [esp+18h] [ebp-40h] BYREF
  int v32; // [esp+1Ch] [ebp-3Ch] BYREF
  int v33; // [esp+20h] [ebp-38h] BYREF
  int v34; // [esp+24h] [ebp-34h]
  int v35; // [esp+28h] [ebp-30h] BYREF
  char *v36; // [esp+30h] [ebp-28h]
  unsigned int v37; // [esp+34h] [ebp-24h]
  char v38; // [esp+38h] [ebp-20h]
  char v39; // [esp+39h] [ebp-1Fh]
  int v40; // [esp+54h] [ebp-4h]

  v40 = a1;
  result = 3;
  v30 = 0;
  if ( a2 == 1 )
  {
    if ( (a3 & 2) != 0 )
    {
      LanguageSpecificData = (_BYTE *)Unwind_GetLanguageSpecificData(a7);
      if ( LanguageSpecificData )
      {
        RegionStart = 0;
        if ( a7 )
          RegionStart = Unwind_GetRegionStart(a7);
        v34 = RegionStart;
        v10 = LanguageSpecificData + 1;
        if ( *LanguageSpecificData == 0xFF )
        {
          v35 = RegionStart;
        }
        else
        {
          v11 = (const struct timespec *)(unsigned __int8)*LanguageSpecificData;
          base_of_encoded_value_0((char)v11, a7, a1, (int *)&GLOBAL_OFFSET_TABLE_, v11);
          v10 = (char *)read_encoded_value_with_base_1((char)v11, (int)v10, &v35);
        }
        v12 = v10 + 1;
        v38 = *v10;
        if ( v38 == -1 )
        {
          v36 = 0;
        }
        else
        {
          v13 = 0;
          v14 = 0;
          do
          {
            v15 = (*v12++ & 0x7F) << v14;
            v14 += 7;
            v13 |= v15;
          }
          while ( *(v12 - 1) < 0 );
          v36 = &v12[v13];
        }
        v16 = (const struct timespec *)(v12 + 1);
        v17 = 0;
        v18 = 0;
        v39 = *v12;
        do
        {
          v16 = (const struct timespec *)((char *)v16 + 1);
          v19 = (HIBYTE(v16[-1].tv_nsec) & 0x7F) << v18;
          v18 += 7;
          v17 |= v19;
        }
        while ( v16[-1].tv_nsec < 0 );
        v37 = (unsigned int)v16 + v17;
        IPInfo = Unwind_GetIPInfo(a7, &v30);
        v21 = (int *)((__PAIR64__(IPInfo, v30) - 1) >> 32);
        while ( v37 > (unsigned int)v16 )
        {
          v22 = v39;
          base_of_encoded_value_0(v39, 0, (int)&v31, v21, v16);
          v23 = (const struct timespec *)read_encoded_value_with_base_1(v22, (int)v16, &v31);
          v24 = v39;
          v25 = (int)v23;
          base_of_encoded_value_0(v39, 0, (int)&v31, v21, v23);
          v26 = (const struct timespec *)read_encoded_value_with_base_1(v24, v25, &v32);
          v27 = v39;
          v28 = (int)v26;
          base_of_encoded_value_0(v39, 0, (int)&v31, v21, v26);
          v16 = (const struct timespec *)read_encoded_value_with_base_1(v27, v28, &v33);
          do
            v16 = (const struct timespec *)((char *)v16 + 1);
          while ( v16[-1].tv_nsec < 0 );
          if ( v34 + v31 > (unsigned int)v21 )
            break;
          if ( v32 + v34 + v31 > (unsigned int)v21 )
          {
            if ( v33 )
            {
              v29 = (const struct timespec *)(v35 + v33);
              if ( v35 + v33 )
              {
                Unwind_SetGR((int)&v31, (int *)&GLOBAL_OFFSET_TABLE_, v29, a7, 0, a6);
                Unwind_SetGR((int)&v31, (int *)&GLOBAL_OFFSET_TABLE_, v29, a7, 2, 0);
                Unwind_SetIP(a7, (int)v29);
                return 7;
              }
            }
            return 8;
          }
        }
      }
    }
    return 8;
  }
  return result;
}
// 80CE000: using guessed type _TBYTE GLOBAL_OFFSET_TABLE_;

//----- (080A0D90) --------------------------------------------------------
int __cdecl dl_iterate_phdr(int (__cdecl *a1)(int *, int, int), int a2)
{
  void *v2; // edi
  int v3; // eax
  int *v4; // eax
  int v5; // edx
  int v6; // edx
  __int64 v9; // [esp+0h] [ebp-64h]
  int v10[3]; // [esp+1Ch] [ebp-48h] BYREF
  __int16 v11; // [esp+28h] [ebp-3Ch]
  __int64 v12; // [esp+2Ch] [ebp-38h]
  __int64 v13; // [esp+34h] [ebp-30h]
  int v14; // [esp+3Ch] [ebp-28h]
  int addr_soft; // [esp+40h] [ebp-24h]
  unsigned int v16; // [esp+44h] [ebp-20h]

  v16 = __readgsdword(0x14u);
  if ( !dl_ns )
    return 0;
  v2 = dl_ns;
  v9 = (unsigned int)*(&dl_ns + 1);
  while ( 1 )
  {
    v4 = (int *)*((_DWORD *)v2 + 5);
    v10[0] = *v4;
    v5 = v4[1];
    v12 = *(_QWORD *)dl_load_adds;
    v10[1] = v5;
    v10[2] = *(int *)((char *)v4 + (_DWORD)(&dword_80CE154 - 33765376));
    LOWORD(v5) = *(_WORD *)((char *)v4 + (_DWORD)(&word_80CE15C - 67530752));
    v13 = *(_QWORD *)dl_load_adds - v9;
    v11 = v5;
    v6 = *(int *)((char *)v4 + (_DWORD)(&dword_80CE248 - 33765376));
    addr_soft = 0;
    v14 = v6;
    if ( v6 )
      addr_soft = dl_tls_get_addr_soft((int)v4);
    v3 = a1(v10, 40, a2);
    if ( v3 )
      break;
    v2 = (void *)*((_DWORD *)v2 + 3);
    if ( !v2 )
      return 0;
  }
  return v3;
}
// 80CE154: using guessed type int dword_80CE154;
// 80CE15C: using guessed type __int16 word_80CE15C;
// 80CE248: using guessed type int dword_80CE248;
// 80CE9B8: using guessed type _DWORD dl_load_adds[2];
// 80CEA00: using guessed type void *dl_ns;

//----- (080A0F10) --------------------------------------------------------
int *__usercall free_mem@<eax>(int a1@<ecx>, const char *a2@<ebp>)
{
  int *v2; // esi
  int *result; // eax
  int *v4; // esi

  v2 = (int *)nl_domain_bindings;
  if ( nl_domain_bindings )
  {
    a2 = "/usr/share/locale";
    do
    {
      nl_domain_bindings = *v2;
      if ( (char *)v2[1] != "/usr/share/locale" )
        free((int)"/usr/share/locale", &nl_domain_bindings, v2[1]);
      free((int)"/usr/share/locale", &nl_domain_bindings, v2[2]);
      free((int)"/usr/share/locale", &nl_domain_bindings, (int)v2);
      v2 = (int *)nl_domain_bindings;
    }
    while ( nl_domain_bindings );
  }
  if ( nl_current_default_domain != "messages" )
    free((int)a2, &nl_domain_bindings, (int)nl_current_default_domain);
  tdestroy(a1, (int)a2, (int *)root, (int *)free);
  result = (int *)transmem_list;
  root = 0;
  if ( transmem_list )
  {
    do
    {
      transmem_list = *result;
      v4 = (int *)transmem_list;
      free((int)a2, &nl_domain_bindings, (int)result);
      result = v4;
    }
    while ( v4 );
  }
  return result;
}
// 80A0F9E: variable 'a1' is possibly undefined
// 80CE028: using guessed type char *nl_current_default_domain;
// 80CF574: using guessed type int transmem_list;
// 80CF578: using guessed type int root;
// 80CFED0: using guessed type int nl_domain_bindings;

//----- (080A0FF0) --------------------------------------------------------
int *__usercall nl_finddomain_subfreeres@<eax>(int a1@<ebp>, int *a2@<edi>)
{
  int *v2; // esi
  int *result; // eax

  v2 = (int *)nl_loaded_domains;
  if ( nl_loaded_domains )
  {
    while ( 1 )
    {
      if ( v2[2] )
        nl_unload_domain((unsigned int)a2, v2[2]);
      a2 = (int *)v2[3];
      free(a1, a2, *v2);
      result = free(a1, a2, (int)v2);
      if ( !a2 )
        break;
      v2 = a2;
    }
  }
  return result;
}
// 80CF5C0: using guessed type int nl_loaded_domains;

//----- (080A1050) --------------------------------------------------------
int *__usercall nl_unload_domain@<eax>(unsigned int a1@<edi>, int a2)
{
  int *v2; // eax
  unsigned int v3; // esi
  int v4; // eax

  v2 = *(int **)(a2 + 96);
  if ( v2 != (int *)&_gettext_germanic_plural )
    _gettext_free_exp(a2, (int *)a1, v2);
  if ( *(_DWORD *)(a2 + 60) )
  {
    v3 = 0;
    do
    {
      a1 = *(_DWORD *)(a2 + 56) + 12 * v3;
      free(a2, (int *)a1, *(_DWORD *)a1);
      v4 = *(_DWORD *)(a1 + 8);
      if ( (unsigned int)(v4 - 1) <= 0xFFFFFFFD )
        free(a2, (int *)a1, v4);
      if ( *(_DWORD *)(a1 + 4) != -1 )
        _gconv_close(*(int **)(a1 + 4));
      ++v3;
    }
    while ( *(_DWORD *)(a2 + 60) > v3 );
  }
  free(a2, (int *)a1, *(_DWORD *)(a2 + 56));
  free(a2, (int *)a1, *(_DWORD *)(a2 + 16));
  if ( *(_DWORD *)(a2 + 4) )
    munmap(*(void **)a2, *(_DWORD *)(a2 + 8));
  else
    free(a2, (int *)a1, *(_DWORD *)a2);
  return free(a2, (int *)a1, a2);
}

//----- (080A1150) --------------------------------------------------------
int *__usercall buffer_free@<eax>(int a1@<ebp>, int *a2@<edi>)
{
  int v2; // esi
  int *result; // eax

  v2 = freeres_list;
  for ( dealloc_buffers = 1; v2; freeres_list = v2 )
  {
    result = free(a1, a2, *(_DWORD *)(v2 + 96));
    v2 = *(_DWORD *)(v2 + 92);
  }
  return result;
}
// 80CF828: using guessed type int freeres_list;
// 80CF82C: using guessed type char dealloc_buffers;

//----- (080A11A0) --------------------------------------------------------
int *__usercall free_derivation@<eax>(int *a1@<edi>, int a2)
{
  int v2; // edx
  int v3; // ebp
  int v4; // ecx
  unsigned int v5; // esi
  int v6; // eax
  int v8; // [esp+30h] [ebp+4h]
  int v9; // [esp+30h] [ebp+4h]

  v2 = a2;
  v3 = *(_DWORD *)(a2 + 12);
  v4 = *(_DWORD *)(a2 + 8);
  if ( v3 )
  {
    v5 = 0;
    do
    {
      v3 = 60 * v5;
      v6 = v4 + 60 * v5;
      a1 = *(int **)(v6 + 8);
      if ( (int)a1 > 0 )
      {
        a1 = *(int **)v6;
        if ( *(_DWORD *)v6 )
        {
          a1 = (int *)(__readgsdword(0x18u) ^ __ROR4__(*(_DWORD *)(v6 + 32), 9));
          if ( a1 )
          {
            v8 = v2;
            dl_mcount_wrapper_check((int)a1);
            v3 += *(_DWORD *)(v8 + 8);
            ((void (__cdecl *)(int))a1)(v3);
            v2 = v8;
            v4 = *(_DWORD *)(v8 + 8);
          }
        }
      }
      ++v5;
    }
    while ( *(_DWORD *)(v2 + 12) > v5 );
  }
  if ( v4 )
  {
    v9 = v2;
    free(v3, a1, *(_DWORD *)(v4 + 12));
    free(v3, a1, *(_DWORD *)(*(_DWORD *)(v9 + 8) + 60 * *(_DWORD *)(v9 + 12) - 44));
    free(v3, a1, *(_DWORD *)(v9 + 8));
    v2 = v9;
  }
  return free(v3, a1, v2);
}

//----- (080A1270) --------------------------------------------------------
int *__usercall free_modules_db@<eax>(_DWORD *a1@<eax>, int a2@<ebp>)
{
  _DWORD *v2; // esi
  _DWORD *v3; // eax
  _DWORD *v4; // eax
  int *result; // eax
  int *v6; // edi
  int v7; // [esp-10h] [ebp-1Ch]

  v2 = a1;
  v3 = (_DWORD *)a1[5];
  if ( v3 )
    free_modules_db(v3, a2);
  v4 = (_DWORD *)v2[7];
  if ( v4 )
    free_modules_db(v4, a2);
  do
  {
    while ( 1 )
    {
      result = (int *)v2[4];
      v6 = (int *)v2[6];
      if ( *(_BYTE *)result == 47 )
        break;
      v2 = (_DWORD *)v2[6];
      if ( !v6 )
        return result;
    }
    v7 = (int)v2;
    v2 = (_DWORD *)v2[6];
    result = free(a2, v6, v7);
  }
  while ( v6 );
  return result;
}

//----- (080A12D0) --------------------------------------------------------
int *__usercall free_mem_0@<eax>(int *a1@<ebp>, int *a2@<edi>)
{
  int v2; // ecx
  int *result; // eax

  nl_locale_subfreeres(a1, a2);
  nl_finddomain_subfreeres((int)a1, a2);
  if ( _gconv_alias_db )
    tdestroy(v2, (int)a1, (int *)_gconv_alias_db, (int *)free);
  if ( _gconv_modules_db )
    free_modules_db((_DWORD *)_gconv_modules_db, (int)a1);
  result = (int *)known_derivations;
  if ( known_derivations )
    return tdestroy(v2, (int)a1, (int *)known_derivations, (int *)free_derivation);
  return result;
}
// 80A1301: variable 'v2' is possibly undefined
// 80CF940: using guessed type int known_derivations;
// 80CFF7C: using guessed type int _gconv_modules_db;
// 80CFF84: using guessed type int _gconv_alias_db;

//----- (080A1340) --------------------------------------------------------
int *__usercall free_mem_1@<eax>(int a1@<ebp>, int *a2@<edi>)
{
  int *result; // eax

  result = (int *)_gconv_path_elem;
  if ( _gconv_path_elem )
  {
    if ( (_UNKNOWN *)_gconv_path_elem != &empty_path_elem )
      return free(a1, a2, _gconv_path_elem);
  }
  return result;
}
// 80CFF90: using guessed type int _gconv_path_elem;

//----- (080A1380) --------------------------------------------------------
int *__usercall free_mem_2@<eax>(int a1@<ebp>, int *a2@<edi>)
{
  int *result; // eax

  result = (int *)gconv_cache;
  if ( cache_malloced )
    return free(a1, a2, gconv_cache);
  if ( gconv_cache )
    return (int *)munmap((void *)gconv_cache, cache_size);
  return result;
}
// 80CF94C: using guessed type int cache_malloced;
// 80CF950: using guessed type int cache_size;
// 80CF954: using guessed type int gconv_cache;

//----- (080A13E0) --------------------------------------------------------
int *__usercall do_release_all@<eax>(int a1@<ebp>, int *a2@<edi>, int a3)
{
  if ( *(_DWORD *)(a3 + 8) )
    _libc_dlclose(a1, a2, *(_DWORD *)(a3 + 8));
  return free(a1, a2, a3);
}

//----- (080A1420) --------------------------------------------------------
int *__usercall free_mem_3@<eax>(int a1@<ecx>, int a2@<ebp>)
{
  int *result; // eax

  result = tdestroy(a1, a2, (int *)loaded, (int *)do_release_all);
  loaded = 0;
  return result;
}
// 80CF95C: using guessed type int loaded;

//----- (080A1460) --------------------------------------------------------
int *__usercall free_category@<eax>(int *result@<eax>, void **a2@<edx>, void **a3@<ecx>, int a4@<ebp>)
{
  int *v5; // esi
  int *v6; // ebp
  void (__cdecl *v7)(); // eax
  const char *v8; // ecx
  void **v9; // eax

  v5 = (int *)nl_locale_file_list[(_DWORD)result];
  if ( a2 != a3 )
  {
    v6 = result;
    if ( nl_current_used[(_DWORD)result] )
    {
      v7 = (void (__cdecl *)())*(&nl_category_postload + (_DWORD)result);
      nl_global_locale[(_DWORD)v6] = (char **)a3;
      if ( v7 )
        v7();
    }
    a4 = (int)(v6 + 4);
    result = (int *)"C";
    v8 = (const char *)nl_global_locale[a4];
    if ( v8 != "C" )
    {
      free(a4, (int *)a3, (int)v8);
      result = (int *)"C";
      nl_global_locale[a4] = (char **)"C";
    }
  }
  if ( v5 )
  {
    while ( 1 )
    {
      v9 = (void **)v5[2];
      if ( v9 )
      {
        if ( a3 != v9 )
          nl_unload_locale(a4, (int *)a3, v5[2]);
      }
      a4 = v5[3];
      free(a4, (int *)a3, *v5);
      result = free(a4, (int *)a3, (int)v5);
      if ( !a4 )
        break;
      v5 = (int *)a4;
    }
  }
  return result;
}
// 80CDE80: using guessed type int (*nl_category_postload)();
// 80CDEC0: using guessed type int nl_current_used[16];
// 80CEE60: using guessed type char **nl_global_locale[6];
// 80CFFA0: using guessed type int nl_locale_file_list[13];

//----- (080A1520) --------------------------------------------------------
int __usercall nl_locale_subfreeres@<eax>(int *a1@<ebp>, int *a2@<edi>)
{
  free_category(0, *(void ***)__readgsdword(0xFFFFFFD0), (void **)&nl_C_LC_CTYPE, (int)a1);
  free_category((int *)4, *(void ***)__readgsdword(0xFFFFFFD8), (void **)&nl_C_LC_MONETARY, (int)a1);
  free_category((int *)1, *(void ***)__readgsdword(0xFFFFFFDC), (void **)&nl_C_LC_NUMERIC, (int)a1);
  if ( off_80CEEB8[0] != "C" )
  {
    free((int)a1, a2, (int)off_80CEEB8[0]);
    off_80CEEB8[0] = "C";
  }
  return nl_archive_subfreeres(a1);
}
// 80CC740: using guessed type char *nl_C_LC_CTYPE;
// 80CD080: using guessed type char *nl_C_LC_MONETARY;
// 80CD160: using guessed type char *nl_C_LC_NUMERIC;
// 80CEEB8: using guessed type char *off_80CEEB8[7];

//----- (080A1720) --------------------------------------------------------
int __usercall nl_archive_subfreeres@<eax>(int *a1@<ebp>)
{
  int *v1; // edi
  int v2; // esi
  int v3; // eax
  void (__cdecl *v4)(int); // edx
  int result; // eax
  int v6; // esi
  int *v7; // edi
  int v8; // [esp+0h] [ebp-2Ch]
  int v9; // [esp+0h] [ebp-2Ch]

  v1 = (int *)archloaded;
  if ( archloaded )
  {
    do
    {
      a1 = (int *)*v1;
      v2 = 0;
      free(*v1, v1, v1[1]);
      while ( 1 )
      {
        if ( v2 != 6 )
        {
          v3 = v1[v2 + 2];
          if ( v3 )
          {
            v4 = *(void (__cdecl **)(int))(v3 + 16);
            if ( v4 )
            {
              v4(v1[v2 + 2]);
              v3 = v1[v2 + 2];
            }
            free((int)a1, v1, v3);
          }
          if ( v2 == 12 )
            break;
        }
        ++v2;
      }
      v8 = (int)v1;
      v1 = a1;
      free((int)a1, a1, v8);
    }
    while ( a1 );
  }
  archloaded = 0;
  result = archmapped;
  if ( archmapped )
  {
    if ( (int *)archmapped != &headmap )
      _assert_fail((int)"archmapped == &headmap", (int)"loadarchive.c", 534, (int)"_nl_archive_subfreeres");
    archmapped = 0;
    result = munmap((void *)headmap, dword_80CFA08);
    v6 = dword_80CFA0C;
    if ( dword_80CFA0C )
    {
      do
      {
        v7 = *(int **)(v6 + 12);
        munmap(*(void **)v6, *(_DWORD *)(v6 + 8));
        v9 = v6;
        v6 = (int)v7;
        result = (int)free((int)a1, v7, v9);
      }
      while ( v7 );
    }
  }
  return result;
}
// 80CF980: using guessed type int archloaded;
// 80CFA00: using guessed type int headmap;
// 80CFA08: using guessed type int dword_80CFA08;
// 80CFA0C: using guessed type int dword_80CFA0C;
// 80CFA10: using guessed type int archmapped;

//----- (080A1840) --------------------------------------------------------
int *__usercall free_mem_4@<eax>(int a1@<ebp>, int *a2@<edi>)
{
  int v2; // ecx
  int *result; // eax

  clearenv(a1, a2);
  result = tdestroy(v2, a1, (int *)known_values, (int *)free);
  known_values = 0;
  return result;
}
// 80A1867: variable 'v2' is possibly undefined
// 80CFA18: using guessed type int known_values;

//----- (080A1880) --------------------------------------------------------
void __usercall free_mem_5(int a1@<ebp>)
{
  int v1; // edx
  int *i; // edi
  _DWORD *v3; // eax
  _DWORD *v4; // esi

  v1 = _printf_modifier_table;
  if ( _printf_modifier_table )
  {
    for ( i = 0; i != (int *)1020; ++i )
    {
      v3 = *(_DWORD **)((char *)i + v1);
      if ( v3 )
      {
        do
        {
          v4 = (_DWORD *)*v3;
          free(a1, i, (int)v3);
          v3 = v4;
        }
        while ( v4 );
        v1 = _printf_modifier_table;
      }
    }
    free(a1, (int *)0x3FC, v1);
  }
}
// 80CFFD8: using guessed type int _printf_modifier_table;

//----- (080A18F0) --------------------------------------------------------
int __usercall free_slotinfo@<eax>(int ***a1@<eax>, int a2@<ebp>)
{
  int result; // eax
  int **v4; // ecx
  int *v5; // edi
  int v6; // edx
  unsigned __int8 v7; // [esp+1h] [ebp-Dh]

  if ( !*a1 )
    return 1;
  result = free_slotinfo((int ***)*a1 + 1, a2);
  if ( (_BYTE)result )
  {
    v4 = *a1;
    v5 = **a1;
    if ( v5 )
    {
      if ( v4[3] )
        return 0;
      v6 = 0;
      while ( (int *)++v6 != v5 )
      {
        if ( v4[2 * v6 + 3] )
          return 0;
      }
    }
    v7 = result;
    free(a2, v5, (int)v4);
    *a1 = 0;
    return v7;
  }
  return result;
}

//----- (080A1980) --------------------------------------------------------
int *__usercall free_mem_6@<eax>(_DWORD *a1@<ebp>)
{
  int *v1; // edi
  _DWORD *v2; // eax
  _DWORD *v3; // esi
  int v4; // edx
  int v5; // eax
  int v6; // esi
  _DWORD *v7; // edx
  int v9; // eax
  int v10; // ecx

  v1 = &dl_init_all_dirs;
  v2 = (_DWORD *)dl_all_dirs;
  if ( dl_all_dirs != dl_init_all_dirs )
  {
    do
    {
      v3 = (_DWORD *)*v2;
      free((int)a1, &dl_init_all_dirs, (int)v2);
      v2 = v3;
    }
    while ( (_DWORD *)dl_init_all_dirs != v3 );
  }
  if ( dl_nns )
  {
    v1 = (int *)&dl_ns;
    a1 = dl_ns;
    if ( dl_ns )
    {
      do
      {
        v4 = a1[7];
        v5 = *(_DWORD *)(v4 + 4);
        *(_DWORD *)(v4 + 4) = 0;
        if ( v5 )
        {
          do
          {
            while ( 1 )
            {
              v6 = *(_DWORD *)(v5 + 4);
              if ( !*(_DWORD *)(v5 + 8) )
                break;
              v5 = *(_DWORD *)(v5 + 4);
              if ( !v6 )
                goto LABEL_10;
            }
            free((int)a1, (int *)&dl_ns, v5);
            v5 = v6;
          }
          while ( v6 );
        }
LABEL_10:
        if ( (*((_BYTE *)a1 + 410) & 1) != 0 )
          free((int)a1, (int *)&dl_ns, a1[125]);
        a1[125] = 0;
        a1 = (_DWORD *)a1[3];
      }
      while ( a1 );
    }
    if ( *(&dl_ns + 3) )
    {
      v9 = (int)*(&dl_ns + 2);
      if ( *(void ***)(v9 + 4) == *(&dl_initial_searchlist + 1) )
      {
        v10 = *(_DWORD *)v9;
        *(_DWORD *)v9 = dl_initial_searchlist;
        *(&dl_ns + 3) = 0;
        free((int)a1, (int *)&dl_ns, v10);
      }
    }
  }
  free_slotinfo((int ***)dl_tls_dtv_slotinfo_list + 1, (int)a1);
  v7 = dl_scope_free_list;
  dl_scope_free_list = 0;
  return free((int)a1, v1, (int)v7);
}
// 80CE9C0: using guessed type int dl_nns;
// 80CE9E8: using guessed type void **dl_initial_searchlist;
// 80CEA00: using guessed type void *dl_ns;
// 80CFEC0: using guessed type _DWORD *dl_tls_dtv_slotinfo_list;
// 80CFF34: using guessed type _DWORD *dl_scope_free_list;
// 80CFF48: using guessed type int dl_init_all_dirs;

// nfuncs=846 queued=824 decompiled=824 lumina nreq=0 worse=0 better=0
// ALL OK, 824 function(s) have been successfully decompiled
